{
  "module_name": "connect.c",
  "hash_id": "3d84b8872ef4d81d7d85fe2455b8ac638eabb40273d0611a201d17f1579b71ea",
  "original_prompt": "Ingested from linux-6.6.14/fs/smb/client/connect.c",
  "human_readable_source": "\n \n#include <linux/fs.h>\n#include <linux/net.h>\n#include <linux/string.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/ctype.h>\n#include <linux/utsname.h>\n#include <linux/mempool.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/pagevec.h>\n#include <linux/freezer.h>\n#include <linux/namei.h>\n#include <linux/uuid.h>\n#include <linux/uaccess.h>\n#include <asm/processor.h>\n#include <linux/inet.h>\n#include <linux/module.h>\n#include <keys/user-type.h>\n#include <net/ipv6.h>\n#include <linux/parser.h>\n#include <linux/bvec.h>\n#include \"cifspdu.h\"\n#include \"cifsglob.h\"\n#include \"cifsproto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_fs_sb.h\"\n#include \"ntlmssp.h\"\n#include \"nterr.h\"\n#include \"rfc1002pdu.h\"\n#include \"fscache.h\"\n#include \"smb2proto.h\"\n#include \"smbdirect.h\"\n#include \"dns_resolve.h\"\n#ifdef CONFIG_CIFS_DFS_UPCALL\n#include \"dfs.h\"\n#include \"dfs_cache.h\"\n#endif\n#include \"fs_context.h\"\n#include \"cifs_swn.h\"\n\nextern mempool_t *cifs_req_poolp;\nextern bool disable_legacy_dialects;\n\n \n#define TLINK_ERROR_EXPIRE\t(1 * HZ)\n#define TLINK_IDLE_EXPIRE\t(600 * HZ)\n\n \n#define MAX_STATUS_IO_TIMEOUT   5\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\nstatic void tlink_rb_insert(struct rb_root *root, struct tcon_link *new_tlink);\nstatic void cifs_prune_tlinks(struct work_struct *work);\n\n \nstatic int reconn_set_ipaddr_from_hostname(struct TCP_Server_Info *server)\n{\n\tint rc;\n\tint len;\n\tchar *unc;\n\tstruct sockaddr_storage ss;\n\n\tif (!server->hostname)\n\t\treturn -EINVAL;\n\n\t \n\tif (server->hostname[0] == '\\0')\n\t\treturn 0;\n\n\tlen = strlen(server->hostname) + 3;\n\n\tunc = kmalloc(len, GFP_KERNEL);\n\tif (!unc) {\n\t\tcifs_dbg(FYI, \"%s: failed to create UNC path\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\tscnprintf(unc, len, \"\\\\\\\\%s\", server->hostname);\n\n\tspin_lock(&server->srv_lock);\n\tss = server->dstaddr;\n\tspin_unlock(&server->srv_lock);\n\n\trc = dns_resolve_server_name_to_ip(unc, (struct sockaddr *)&ss, NULL);\n\tkfree(unc);\n\n\tif (rc < 0) {\n\t\tcifs_dbg(FYI, \"%s: failed to resolve server part of %s to IP: %d\\n\",\n\t\t\t __func__, server->hostname, rc);\n\t} else {\n\t\tspin_lock(&server->srv_lock);\n\t\tmemcpy(&server->dstaddr, &ss, sizeof(server->dstaddr));\n\t\tspin_unlock(&server->srv_lock);\n\t\trc = 0;\n\t}\n\n\treturn rc;\n}\n\nstatic void smb2_query_server_interfaces(struct work_struct *work)\n{\n\tint rc;\n\tstruct cifs_tcon *tcon = container_of(work,\n\t\t\t\t\tstruct cifs_tcon,\n\t\t\t\t\tquery_interfaces.work);\n\n\t \n\trc = SMB3_request_interfaces(0, tcon, false);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s: failed to query server interfaces: %d\\n\",\n\t\t\t\t__func__, rc);\n\t}\n\n\tqueue_delayed_work(cifsiod_wq, &tcon->query_interfaces,\n\t\t\t   (SMB_INTERFACE_POLL_INTERVAL * HZ));\n}\n\n \nvoid\ncifs_signal_cifsd_for_reconnect(struct TCP_Server_Info *server,\n\t\t\t\tbool all_channels)\n{\n\tstruct TCP_Server_Info *pserver;\n\tstruct cifs_ses *ses;\n\tint i;\n\n\t \n\tpserver = SERVER_IS_CHAN(server) ? server->primary_server : server;\n\n\t \n\tif (!all_channels) {\n\t\tspin_lock(&server->srv_lock);\n\t\tif (server->tcpStatus != CifsExiting)\n\t\t\tserver->tcpStatus = CifsNeedReconnect;\n\t\tspin_unlock(&server->srv_lock);\n\t\treturn;\n\t}\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each_entry(ses, &pserver->smb_ses_list, smb_ses_list) {\n\t\tspin_lock(&ses->chan_lock);\n\t\tfor (i = 0; i < ses->chan_count; i++) {\n\t\t\tspin_lock(&ses->chans[i].server->srv_lock);\n\t\t\tses->chans[i].server->tcpStatus = CifsNeedReconnect;\n\t\t\tspin_unlock(&ses->chans[i].server->srv_lock);\n\t\t}\n\t\tspin_unlock(&ses->chan_lock);\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n}\n\n \nvoid\ncifs_mark_tcp_ses_conns_for_reconnect(struct TCP_Server_Info *server,\n\t\t\t\t      bool mark_smb_session)\n{\n\tstruct TCP_Server_Info *pserver;\n\tstruct cifs_ses *ses, *nses;\n\tstruct cifs_tcon *tcon;\n\n\t \n\tcifs_dbg(FYI, \"%s: marking necessary sessions and tcons for reconnect\\n\", __func__);\n\n\t \n\tpserver = SERVER_IS_CHAN(server) ? server->primary_server : server;\n\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each_entry_safe(ses, nses, &pserver->smb_ses_list, smb_ses_list) {\n\t\t \n\t\tspin_lock(&ses->chan_lock);\n\t\tif (!cifs_chan_is_iface_active(ses, server)) {\n\t\t\tspin_unlock(&ses->chan_lock);\n\t\t\tcifs_chan_update_iface(ses, server);\n\t\t\tspin_lock(&ses->chan_lock);\n\t\t}\n\n\t\tif (!mark_smb_session && cifs_chan_needs_reconnect(ses, server)) {\n\t\t\tspin_unlock(&ses->chan_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (mark_smb_session)\n\t\t\tCIFS_SET_ALL_CHANS_NEED_RECONNECT(ses);\n\t\telse\n\t\t\tcifs_chan_set_need_reconnect(ses, server);\n\n\t\tcifs_dbg(FYI, \"%s: channel connect bitmap: 0x%lx\\n\",\n\t\t\t __func__, ses->chans_need_reconnect);\n\n\t\t \n\t\tif (!mark_smb_session && !CIFS_ALL_CHANS_NEED_RECONNECT(ses)) {\n\t\t\tspin_unlock(&ses->chan_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&ses->chan_lock);\n\n\t\tspin_lock(&ses->ses_lock);\n\t\tses->ses_status = SES_NEED_RECON;\n\t\tspin_unlock(&ses->ses_lock);\n\n\t\tlist_for_each_entry(tcon, &ses->tcon_list, tcon_list) {\n\t\t\ttcon->need_reconnect = true;\n\t\t\tspin_lock(&tcon->tc_lock);\n\t\t\ttcon->status = TID_NEED_RECON;\n\t\t\tspin_unlock(&tcon->tc_lock);\n\t\t}\n\t\tif (ses->tcon_ipc) {\n\t\t\tses->tcon_ipc->need_reconnect = true;\n\t\t\tspin_lock(&ses->tcon_ipc->tc_lock);\n\t\t\tses->tcon_ipc->status = TID_NEED_RECON;\n\t\t\tspin_unlock(&ses->tcon_ipc->tc_lock);\n\t\t}\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n}\n\nstatic void\ncifs_abort_connection(struct TCP_Server_Info *server)\n{\n\tstruct mid_q_entry *mid, *nmid;\n\tstruct list_head retry_list;\n\n\tserver->maxBuf = 0;\n\tserver->max_read = 0;\n\n\t \n\tcifs_dbg(FYI, \"%s: tearing down socket\\n\", __func__);\n\tcifs_server_lock(server);\n\tif (server->ssocket) {\n\t\tcifs_dbg(FYI, \"State: 0x%x Flags: 0x%lx\\n\", server->ssocket->state,\n\t\t\t server->ssocket->flags);\n\t\tkernel_sock_shutdown(server->ssocket, SHUT_WR);\n\t\tcifs_dbg(FYI, \"Post shutdown state: 0x%x Flags: 0x%lx\\n\", server->ssocket->state,\n\t\t\t server->ssocket->flags);\n\t\tsock_release(server->ssocket);\n\t\tserver->ssocket = NULL;\n\t}\n\tserver->sequence_number = 0;\n\tserver->session_estab = false;\n\tkfree_sensitive(server->session_key.response);\n\tserver->session_key.response = NULL;\n\tserver->session_key.len = 0;\n\tserver->lstrp = jiffies;\n\n\t \n\tINIT_LIST_HEAD(&retry_list);\n\tcifs_dbg(FYI, \"%s: moving mids to private list\\n\", __func__);\n\tspin_lock(&server->mid_lock);\n\tlist_for_each_entry_safe(mid, nmid, &server->pending_mid_q, qhead) {\n\t\tkref_get(&mid->refcount);\n\t\tif (mid->mid_state == MID_REQUEST_SUBMITTED)\n\t\t\tmid->mid_state = MID_RETRY_NEEDED;\n\t\tlist_move(&mid->qhead, &retry_list);\n\t\tmid->mid_flags |= MID_DELETED;\n\t}\n\tspin_unlock(&server->mid_lock);\n\tcifs_server_unlock(server);\n\n\tcifs_dbg(FYI, \"%s: issuing mid callbacks\\n\", __func__);\n\tlist_for_each_entry_safe(mid, nmid, &retry_list, qhead) {\n\t\tlist_del_init(&mid->qhead);\n\t\tmid->callback(mid);\n\t\trelease_mid(mid);\n\t}\n\n\tif (cifs_rdma_enabled(server)) {\n\t\tcifs_server_lock(server);\n\t\tsmbd_destroy(server);\n\t\tcifs_server_unlock(server);\n\t}\n}\n\nstatic bool cifs_tcp_ses_needs_reconnect(struct TCP_Server_Info *server, int num_targets)\n{\n\tspin_lock(&server->srv_lock);\n\tserver->nr_targets = num_targets;\n\tif (server->tcpStatus == CifsExiting) {\n\t\t \n\t\tspin_unlock(&server->srv_lock);\n\t\twake_up(&server->response_q);\n\t\treturn false;\n\t}\n\n\tcifs_dbg(FYI, \"Mark tcp session as need reconnect\\n\");\n\ttrace_smb3_reconnect(server->CurrentMid, server->conn_id,\n\t\t\t     server->hostname);\n\tserver->tcpStatus = CifsNeedReconnect;\n\n\tspin_unlock(&server->srv_lock);\n\treturn true;\n}\n\n \nstatic int __cifs_reconnect(struct TCP_Server_Info *server,\n\t\t\t    bool mark_smb_session)\n{\n\tint rc = 0;\n\n\tif (!cifs_tcp_ses_needs_reconnect(server, 1))\n\t\treturn 0;\n\n\tcifs_mark_tcp_ses_conns_for_reconnect(server, mark_smb_session);\n\n\tcifs_abort_connection(server);\n\n\tdo {\n\t\ttry_to_freeze();\n\t\tcifs_server_lock(server);\n\n\t\tif (!cifs_swn_set_server_dstaddr(server)) {\n\t\t\t \n\t\t\trc = reconn_set_ipaddr_from_hostname(server);\n\t\t\tcifs_dbg(FYI, \"%s: reconn_set_ipaddr_from_hostname: rc=%d\\n\", __func__, rc);\n\t\t}\n\n\t\tif (cifs_rdma_enabled(server))\n\t\t\trc = smbd_reconnect(server);\n\t\telse\n\t\t\trc = generic_ip_connect(server);\n\t\tif (rc) {\n\t\t\tcifs_server_unlock(server);\n\t\t\tcifs_dbg(FYI, \"%s: reconnect error %d\\n\", __func__, rc);\n\t\t\tmsleep(3000);\n\t\t} else {\n\t\t\tatomic_inc(&tcpSesReconnectCount);\n\t\t\tset_credits(server, 1);\n\t\t\tspin_lock(&server->srv_lock);\n\t\t\tif (server->tcpStatus != CifsExiting)\n\t\t\t\tserver->tcpStatus = CifsNeedNegotiate;\n\t\t\tspin_unlock(&server->srv_lock);\n\t\t\tcifs_swn_reset_server_dstaddr(server);\n\t\t\tcifs_server_unlock(server);\n\t\t\tmod_delayed_work(cifsiod_wq, &server->reconnect, 0);\n\t\t}\n\t} while (server->tcpStatus == CifsNeedReconnect);\n\n\tspin_lock(&server->srv_lock);\n\tif (server->tcpStatus == CifsNeedNegotiate)\n\t\tmod_delayed_work(cifsiod_wq, &server->echo, 0);\n\tspin_unlock(&server->srv_lock);\n\n\twake_up(&server->response_q);\n\treturn rc;\n}\n\n#ifdef CONFIG_CIFS_DFS_UPCALL\nstatic int __reconnect_target_unlocked(struct TCP_Server_Info *server, const char *target)\n{\n\tint rc;\n\tchar *hostname;\n\n\tif (!cifs_swn_set_server_dstaddr(server)) {\n\t\tif (server->hostname != target) {\n\t\t\thostname = extract_hostname(target);\n\t\t\tif (!IS_ERR(hostname)) {\n\t\t\t\tspin_lock(&server->srv_lock);\n\t\t\t\tkfree(server->hostname);\n\t\t\t\tserver->hostname = hostname;\n\t\t\t\tspin_unlock(&server->srv_lock);\n\t\t\t} else {\n\t\t\t\tcifs_dbg(FYI, \"%s: couldn't extract hostname or address from dfs target: %ld\\n\",\n\t\t\t\t\t __func__, PTR_ERR(hostname));\n\t\t\t\tcifs_dbg(FYI, \"%s: default to last target server: %s\\n\", __func__,\n\t\t\t\t\t server->hostname);\n\t\t\t}\n\t\t}\n\t\t \n\t\trc = reconn_set_ipaddr_from_hostname(server);\n\t\tcifs_dbg(FYI, \"%s: reconn_set_ipaddr_from_hostname: rc=%d\\n\", __func__, rc);\n\t}\n\t \n\tif (cifs_rdma_enabled(server))\n\t\trc = smbd_reconnect(server);\n\telse\n\t\trc = generic_ip_connect(server);\n\n\treturn rc;\n}\n\nstatic int reconnect_target_unlocked(struct TCP_Server_Info *server, struct dfs_cache_tgt_list *tl,\n\t\t\t\t     struct dfs_cache_tgt_iterator **target_hint)\n{\n\tint rc;\n\tstruct dfs_cache_tgt_iterator *tit;\n\n\t*target_hint = NULL;\n\n\t \n\ttit = dfs_cache_get_tgt_iterator(tl);\n\tif (!tit)\n\t\treturn __reconnect_target_unlocked(server, server->hostname);\n\n\t \n\tfor (; tit; tit = dfs_cache_get_next_tgt(tl, tit)) {\n\t\trc = __reconnect_target_unlocked(server, dfs_cache_get_tgt_name(tit));\n\t\tif (!rc) {\n\t\t\t*target_hint = tit;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn rc;\n}\n\nstatic int reconnect_dfs_server(struct TCP_Server_Info *server)\n{\n\tstruct dfs_cache_tgt_iterator *target_hint = NULL;\n\tDFS_CACHE_TGT_LIST(tl);\n\tint num_targets = 0;\n\tint rc = 0;\n\n\t \n\tmutex_lock(&server->refpath_lock);\n\tif (!dfs_cache_noreq_find(server->leaf_fullpath + 1, NULL, &tl))\n\t\tnum_targets = dfs_cache_get_nr_tgts(&tl);\n\tmutex_unlock(&server->refpath_lock);\n\tif (!num_targets)\n\t\tnum_targets = 1;\n\n\tif (!cifs_tcp_ses_needs_reconnect(server, num_targets))\n\t\treturn 0;\n\n\t \n\tcifs_mark_tcp_ses_conns_for_reconnect(server, true);\n\n\tcifs_abort_connection(server);\n\n\tdo {\n\t\ttry_to_freeze();\n\t\tcifs_server_lock(server);\n\n\t\trc = reconnect_target_unlocked(server, &tl, &target_hint);\n\t\tif (rc) {\n\t\t\t \n\t\t\tcifs_server_unlock(server);\n\t\t\tcifs_dbg(FYI, \"%s: reconnect error %d\\n\", __func__, rc);\n\t\t\tmsleep(3000);\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tatomic_inc(&tcpSesReconnectCount);\n\t\tset_credits(server, 1);\n\t\tspin_lock(&server->srv_lock);\n\t\tif (server->tcpStatus != CifsExiting)\n\t\t\tserver->tcpStatus = CifsNeedNegotiate;\n\t\tspin_unlock(&server->srv_lock);\n\t\tcifs_swn_reset_server_dstaddr(server);\n\t\tcifs_server_unlock(server);\n\t\tmod_delayed_work(cifsiod_wq, &server->reconnect, 0);\n\t} while (server->tcpStatus == CifsNeedReconnect);\n\n\tmutex_lock(&server->refpath_lock);\n\tdfs_cache_noreq_update_tgthint(server->leaf_fullpath + 1, target_hint);\n\tmutex_unlock(&server->refpath_lock);\n\tdfs_cache_free_tgts(&tl);\n\n\t \n\tspin_lock(&server->srv_lock);\n\tif (server->tcpStatus == CifsNeedNegotiate)\n\t\tmod_delayed_work(cifsiod_wq, &server->echo, 0);\n\tspin_unlock(&server->srv_lock);\n\n\twake_up(&server->response_q);\n\treturn rc;\n}\n\nint cifs_reconnect(struct TCP_Server_Info *server, bool mark_smb_session)\n{\n\tmutex_lock(&server->refpath_lock);\n\tif (!server->leaf_fullpath) {\n\t\tmutex_unlock(&server->refpath_lock);\n\t\treturn __cifs_reconnect(server, mark_smb_session);\n\t}\n\tmutex_unlock(&server->refpath_lock);\n\n\treturn reconnect_dfs_server(server);\n}\n#else\nint cifs_reconnect(struct TCP_Server_Info *server, bool mark_smb_session)\n{\n\treturn __cifs_reconnect(server, mark_smb_session);\n}\n#endif\n\nstatic void\ncifs_echo_request(struct work_struct *work)\n{\n\tint rc;\n\tstruct TCP_Server_Info *server = container_of(work,\n\t\t\t\t\tstruct TCP_Server_Info, echo.work);\n\n\t \n\n\tif (server->tcpStatus == CifsNeedReconnect ||\n\t    server->tcpStatus == CifsExiting ||\n\t    server->tcpStatus == CifsNew ||\n\t    (server->ops->can_echo && !server->ops->can_echo(server)) ||\n\t    time_before(jiffies, server->lstrp + server->echo_interval - HZ))\n\t\tgoto requeue_echo;\n\n\trc = server->ops->echo ? server->ops->echo(server) : -ENOSYS;\n\tcifs_server_dbg(FYI, \"send echo request: rc = %d\\n\", rc);\n\n\t \n\tcifs_swn_check();\n\nrequeue_echo:\n\tqueue_delayed_work(cifsiod_wq, &server->echo, server->echo_interval);\n}\n\nstatic bool\nallocate_buffers(struct TCP_Server_Info *server)\n{\n\tif (!server->bigbuf) {\n\t\tserver->bigbuf = (char *)cifs_buf_get();\n\t\tif (!server->bigbuf) {\n\t\t\tcifs_server_dbg(VFS, \"No memory for large SMB response\\n\");\n\t\t\tmsleep(3000);\n\t\t\t \n\t\t\treturn false;\n\t\t}\n\t} else if (server->large_buf) {\n\t\t \n\t\tmemset(server->bigbuf, 0, HEADER_SIZE(server));\n\t}\n\n\tif (!server->smallbuf) {\n\t\tserver->smallbuf = (char *)cifs_small_buf_get();\n\t\tif (!server->smallbuf) {\n\t\t\tcifs_server_dbg(VFS, \"No memory for SMB response\\n\");\n\t\t\tmsleep(1000);\n\t\t\t \n\t\t\treturn false;\n\t\t}\n\t\t \n\t} else {\n\t\t \n\t\tmemset(server->smallbuf, 0, HEADER_SIZE(server));\n\t}\n\n\treturn true;\n}\n\nstatic bool\nserver_unresponsive(struct TCP_Server_Info *server)\n{\n\t \n\tspin_lock(&server->srv_lock);\n\tif ((server->tcpStatus == CifsGood ||\n\t    server->tcpStatus == CifsNeedNegotiate) &&\n\t    (!server->ops->can_echo || server->ops->can_echo(server)) &&\n\t    time_after(jiffies, server->lstrp + 3 * server->echo_interval)) {\n\t\tspin_unlock(&server->srv_lock);\n\t\tcifs_server_dbg(VFS, \"has not responded in %lu seconds. Reconnecting...\\n\",\n\t\t\t (3 * server->echo_interval) / HZ);\n\t\tcifs_reconnect(server, false);\n\t\treturn true;\n\t}\n\tspin_unlock(&server->srv_lock);\n\n\treturn false;\n}\n\nstatic inline bool\nzero_credits(struct TCP_Server_Info *server)\n{\n\tint val;\n\n\tspin_lock(&server->req_lock);\n\tval = server->credits + server->echo_credits + server->oplock_credits;\n\tif (server->in_flight == 0 && val == 0) {\n\t\tspin_unlock(&server->req_lock);\n\t\treturn true;\n\t}\n\tspin_unlock(&server->req_lock);\n\treturn false;\n}\n\nstatic int\ncifs_readv_from_socket(struct TCP_Server_Info *server, struct msghdr *smb_msg)\n{\n\tint length = 0;\n\tint total_read;\n\n\tfor (total_read = 0; msg_data_left(smb_msg); total_read += length) {\n\t\ttry_to_freeze();\n\n\t\t \n\t\tif (zero_credits(server)) {\n\t\t\tcifs_reconnect(server, false);\n\t\t\treturn -ECONNABORTED;\n\t\t}\n\n\t\tif (server_unresponsive(server))\n\t\t\treturn -ECONNABORTED;\n\t\tif (cifs_rdma_enabled(server) && server->smbd_conn)\n\t\t\tlength = smbd_recv(server->smbd_conn, smb_msg);\n\t\telse\n\t\t\tlength = sock_recvmsg(server->ssocket, smb_msg, 0);\n\n\t\tspin_lock(&server->srv_lock);\n\t\tif (server->tcpStatus == CifsExiting) {\n\t\t\tspin_unlock(&server->srv_lock);\n\t\t\treturn -ESHUTDOWN;\n\t\t}\n\n\t\tif (server->tcpStatus == CifsNeedReconnect) {\n\t\t\tspin_unlock(&server->srv_lock);\n\t\t\tcifs_reconnect(server, false);\n\t\t\treturn -ECONNABORTED;\n\t\t}\n\t\tspin_unlock(&server->srv_lock);\n\n\t\tif (length == -ERESTARTSYS ||\n\t\t    length == -EAGAIN ||\n\t\t    length == -EINTR) {\n\t\t\t \n\t\t\tusleep_range(1000, 2000);\n\t\t\tlength = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (length <= 0) {\n\t\t\tcifs_dbg(FYI, \"Received no data or error: %d\\n\", length);\n\t\t\tcifs_reconnect(server, false);\n\t\t\treturn -ECONNABORTED;\n\t\t}\n\t}\n\treturn total_read;\n}\n\nint\ncifs_read_from_socket(struct TCP_Server_Info *server, char *buf,\n\t\t      unsigned int to_read)\n{\n\tstruct msghdr smb_msg = {};\n\tstruct kvec iov = {.iov_base = buf, .iov_len = to_read};\n\tiov_iter_kvec(&smb_msg.msg_iter, ITER_DEST, &iov, 1, to_read);\n\n\treturn cifs_readv_from_socket(server, &smb_msg);\n}\n\nssize_t\ncifs_discard_from_socket(struct TCP_Server_Info *server, size_t to_read)\n{\n\tstruct msghdr smb_msg = {};\n\n\t \n\tiov_iter_discard(&smb_msg.msg_iter, ITER_DEST, to_read);\n\n\treturn cifs_readv_from_socket(server, &smb_msg);\n}\n\nint\ncifs_read_page_from_socket(struct TCP_Server_Info *server, struct page *page,\n\tunsigned int page_offset, unsigned int to_read)\n{\n\tstruct msghdr smb_msg = {};\n\tstruct bio_vec bv;\n\n\tbvec_set_page(&bv, page, to_read, page_offset);\n\tiov_iter_bvec(&smb_msg.msg_iter, ITER_DEST, &bv, 1, to_read);\n\treturn cifs_readv_from_socket(server, &smb_msg);\n}\n\nint\ncifs_read_iter_from_socket(struct TCP_Server_Info *server, struct iov_iter *iter,\n\t\t\t   unsigned int to_read)\n{\n\tstruct msghdr smb_msg = { .msg_iter = *iter };\n\tint ret;\n\n\tiov_iter_truncate(&smb_msg.msg_iter, to_read);\n\tret = cifs_readv_from_socket(server, &smb_msg);\n\tif (ret > 0)\n\t\tiov_iter_advance(iter, ret);\n\treturn ret;\n}\n\nstatic bool\nis_smb_response(struct TCP_Server_Info *server, unsigned char type)\n{\n\t \n\tswitch (type) {\n\tcase RFC1002_SESSION_MESSAGE:\n\t\t \n\t\treturn true;\n\tcase RFC1002_SESSION_KEEP_ALIVE:\n\t\tcifs_dbg(FYI, \"RFC 1002 session keep alive\\n\");\n\t\tbreak;\n\tcase RFC1002_POSITIVE_SESSION_RESPONSE:\n\t\tcifs_dbg(FYI, \"RFC 1002 positive session response\\n\");\n\t\tbreak;\n\tcase RFC1002_NEGATIVE_SESSION_RESPONSE:\n\t\t \n\t\tcifs_dbg(FYI, \"RFC 1002 negative session response\\n\");\n\t\t \n\t\tmsleep(1000);\n\t\t \n\t\tcifs_set_port((struct sockaddr *)&server->dstaddr, CIFS_PORT);\n\t\tcifs_reconnect(server, true);\n\t\tbreak;\n\tdefault:\n\t\tcifs_server_dbg(VFS, \"RFC 1002 unknown response type 0x%x\\n\", type);\n\t\tcifs_reconnect(server, true);\n\t}\n\n\treturn false;\n}\n\nvoid\ndequeue_mid(struct mid_q_entry *mid, bool malformed)\n{\n#ifdef CONFIG_CIFS_STATS2\n\tmid->when_received = jiffies;\n#endif\n\tspin_lock(&mid->server->mid_lock);\n\tif (!malformed)\n\t\tmid->mid_state = MID_RESPONSE_RECEIVED;\n\telse\n\t\tmid->mid_state = MID_RESPONSE_MALFORMED;\n\t \n\tif (mid->mid_flags & MID_DELETED) {\n\t\tspin_unlock(&mid->server->mid_lock);\n\t\tpr_warn_once(\"trying to dequeue a deleted mid\\n\");\n\t} else {\n\t\tlist_del_init(&mid->qhead);\n\t\tmid->mid_flags |= MID_DELETED;\n\t\tspin_unlock(&mid->server->mid_lock);\n\t}\n}\n\nstatic unsigned int\nsmb2_get_credits_from_hdr(char *buffer, struct TCP_Server_Info *server)\n{\n\tstruct smb2_hdr *shdr = (struct smb2_hdr *)buffer;\n\n\t \n\tif (is_smb1(server))\n\t\treturn 0;\n\n\treturn le16_to_cpu(shdr->CreditRequest);\n}\n\nstatic void\nhandle_mid(struct mid_q_entry *mid, struct TCP_Server_Info *server,\n\t   char *buf, int malformed)\n{\n\tif (server->ops->check_trans2 &&\n\t    server->ops->check_trans2(mid, server, buf, malformed))\n\t\treturn;\n\tmid->credits_received = smb2_get_credits_from_hdr(buf, server);\n\tmid->resp_buf = buf;\n\tmid->large_buf = server->large_buf;\n\t \n\tif (!mid->multiRsp) {\n\t\t \n\t\tif (server->large_buf)\n\t\t\tserver->bigbuf = NULL;\n\t\telse\n\t\t\tserver->smallbuf = NULL;\n\t}\n\tdequeue_mid(mid, malformed);\n}\n\nint\ncifs_enable_signing(struct TCP_Server_Info *server, bool mnt_sign_required)\n{\n\tbool srv_sign_required = server->sec_mode & server->vals->signing_required;\n\tbool srv_sign_enabled = server->sec_mode & server->vals->signing_enabled;\n\tbool mnt_sign_enabled;\n\n\t \n\tif (!mnt_sign_required)\n\t\tmnt_sign_required = ((global_secflags & CIFSSEC_MUST_SIGN) ==\n\t\t\t\t\t\tCIFSSEC_MUST_SIGN);\n\n\t \n\tmnt_sign_enabled = mnt_sign_required ? mnt_sign_required :\n\t\t\t\t(global_secflags & CIFSSEC_MAY_SIGN);\n\n\t \n\tif (srv_sign_required) {\n\t\tif (!mnt_sign_enabled) {\n\t\t\tcifs_dbg(VFS, \"Server requires signing, but it's disabled in SecurityFlags!\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tserver->sign = true;\n\t}\n\n\t \n\tif (mnt_sign_required) {\n\t\tif (!srv_sign_enabled) {\n\t\t\tcifs_dbg(VFS, \"Server does not support signing!\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tserver->sign = true;\n\t}\n\n\tif (cifs_rdma_enabled(server) && server->sign)\n\t\tcifs_dbg(VFS, \"Signing is enabled, and RDMA read/write will be disabled\\n\");\n\n\treturn 0;\n}\n\nstatic noinline_for_stack void\nclean_demultiplex_info(struct TCP_Server_Info *server)\n{\n\tint length;\n\n\t \n\tspin_lock(&server->srv_lock);\n\tlist_del_init(&server->tcp_ses_list);\n\tspin_unlock(&server->srv_lock);\n\n\tcancel_delayed_work_sync(&server->echo);\n\n\tspin_lock(&server->srv_lock);\n\tserver->tcpStatus = CifsExiting;\n\tspin_unlock(&server->srv_lock);\n\twake_up_all(&server->response_q);\n\n\t \n\tspin_lock(&server->req_lock);\n\tif (server->credits <= 0)\n\t\tserver->credits = 1;\n\tspin_unlock(&server->req_lock);\n\t \n\twake_up_all(&server->request_q);\n\t \n\tmsleep(125);\n\tif (cifs_rdma_enabled(server))\n\t\tsmbd_destroy(server);\n\tif (server->ssocket) {\n\t\tsock_release(server->ssocket);\n\t\tserver->ssocket = NULL;\n\t}\n\n\tif (!list_empty(&server->pending_mid_q)) {\n\t\tstruct list_head dispose_list;\n\t\tstruct mid_q_entry *mid_entry;\n\t\tstruct list_head *tmp, *tmp2;\n\n\t\tINIT_LIST_HEAD(&dispose_list);\n\t\tspin_lock(&server->mid_lock);\n\t\tlist_for_each_safe(tmp, tmp2, &server->pending_mid_q) {\n\t\t\tmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\n\t\t\tcifs_dbg(FYI, \"Clearing mid %llu\\n\", mid_entry->mid);\n\t\t\tkref_get(&mid_entry->refcount);\n\t\t\tmid_entry->mid_state = MID_SHUTDOWN;\n\t\t\tlist_move(&mid_entry->qhead, &dispose_list);\n\t\t\tmid_entry->mid_flags |= MID_DELETED;\n\t\t}\n\t\tspin_unlock(&server->mid_lock);\n\n\t\t \n\t\tlist_for_each_safe(tmp, tmp2, &dispose_list) {\n\t\t\tmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\n\t\t\tcifs_dbg(FYI, \"Callback mid %llu\\n\", mid_entry->mid);\n\t\t\tlist_del_init(&mid_entry->qhead);\n\t\t\tmid_entry->callback(mid_entry);\n\t\t\trelease_mid(mid_entry);\n\t\t}\n\t\t \n\t\tmsleep(125);\n\t}\n\n\tif (!list_empty(&server->pending_mid_q)) {\n\t\t \n\t\tcifs_dbg(FYI, \"Wait for exit from demultiplex thread\\n\");\n\t\tmsleep(46000);\n\t\t \n\t}\n\n\tkfree(server->leaf_fullpath);\n\tkfree(server);\n\n\tlength = atomic_dec_return(&tcpSesAllocCount);\n\tif (length > 0)\n\t\tmempool_resize(cifs_req_poolp, length + cifs_min_rcv);\n}\n\nstatic int\nstandard_receive3(struct TCP_Server_Info *server, struct mid_q_entry *mid)\n{\n\tint length;\n\tchar *buf = server->smallbuf;\n\tunsigned int pdu_length = server->pdu_size;\n\n\t \n\tif (pdu_length > CIFSMaxBufSize + MAX_HEADER_SIZE(server) -\n\t    HEADER_PREAMBLE_SIZE(server)) {\n\t\tcifs_server_dbg(VFS, \"SMB response too long (%u bytes)\\n\", pdu_length);\n\t\tcifs_reconnect(server, true);\n\t\treturn -ECONNABORTED;\n\t}\n\n\t \n\tif (pdu_length > MAX_CIFS_SMALL_BUFFER_SIZE - 4) {\n\t\tserver->large_buf = true;\n\t\tmemcpy(server->bigbuf, buf, server->total_read);\n\t\tbuf = server->bigbuf;\n\t}\n\n\t \n\tlength = cifs_read_from_socket(server, buf + HEADER_SIZE(server) - 1,\n\t\t\t\t       pdu_length - MID_HEADER_SIZE(server));\n\n\tif (length < 0)\n\t\treturn length;\n\tserver->total_read += length;\n\n\tdump_smb(buf, server->total_read);\n\n\treturn cifs_handle_standard(server, mid);\n}\n\nint\ncifs_handle_standard(struct TCP_Server_Info *server, struct mid_q_entry *mid)\n{\n\tchar *buf = server->large_buf ? server->bigbuf : server->smallbuf;\n\tint rc;\n\n\t \n\trc = server->ops->check_message(buf, server->total_read, server);\n\tif (rc)\n\t\tcifs_dump_mem(\"Bad SMB: \", buf,\n\t\t\tmin_t(unsigned int, server->total_read, 48));\n\n\tif (server->ops->is_session_expired &&\n\t    server->ops->is_session_expired(buf)) {\n\t\tcifs_reconnect(server, true);\n\t\treturn -1;\n\t}\n\n\tif (server->ops->is_status_pending &&\n\t    server->ops->is_status_pending(buf, server))\n\t\treturn -1;\n\n\tif (!mid)\n\t\treturn rc;\n\n\thandle_mid(mid, server, buf, rc);\n\treturn 0;\n}\n\nstatic void\nsmb2_add_credits_from_hdr(char *buffer, struct TCP_Server_Info *server)\n{\n\tstruct smb2_hdr *shdr = (struct smb2_hdr *)buffer;\n\tint scredits, in_flight;\n\n\t \n\tif (is_smb1(server))\n\t\treturn;\n\n\tif (shdr->CreditRequest) {\n\t\tspin_lock(&server->req_lock);\n\t\tserver->credits += le16_to_cpu(shdr->CreditRequest);\n\t\tscredits = server->credits;\n\t\tin_flight = server->in_flight;\n\t\tspin_unlock(&server->req_lock);\n\t\twake_up(&server->request_q);\n\n\t\ttrace_smb3_hdr_credits(server->CurrentMid,\n\t\t\t\tserver->conn_id, server->hostname, scredits,\n\t\t\t\tle16_to_cpu(shdr->CreditRequest), in_flight);\n\t\tcifs_server_dbg(FYI, \"%s: added %u credits total=%d\\n\",\n\t\t\t\t__func__, le16_to_cpu(shdr->CreditRequest),\n\t\t\t\tscredits);\n\t}\n}\n\n\nstatic int\ncifs_demultiplex_thread(void *p)\n{\n\tint i, num_mids, length;\n\tstruct TCP_Server_Info *server = p;\n\tunsigned int pdu_length;\n\tunsigned int next_offset;\n\tchar *buf = NULL;\n\tstruct task_struct *task_to_wake = NULL;\n\tstruct mid_q_entry *mids[MAX_COMPOUND];\n\tchar *bufs[MAX_COMPOUND];\n\tunsigned int noreclaim_flag, num_io_timeout = 0;\n\tbool pending_reconnect = false;\n\n\tnoreclaim_flag = memalloc_noreclaim_save();\n\tcifs_dbg(FYI, \"Demultiplex PID: %d\\n\", task_pid_nr(current));\n\n\tlength = atomic_inc_return(&tcpSesAllocCount);\n\tif (length > 1)\n\t\tmempool_resize(cifs_req_poolp, length + cifs_min_rcv);\n\n\tset_freezable();\n\tallow_kernel_signal(SIGKILL);\n\twhile (server->tcpStatus != CifsExiting) {\n\t\tif (try_to_freeze())\n\t\t\tcontinue;\n\n\t\tif (!allocate_buffers(server))\n\t\t\tcontinue;\n\n\t\tserver->large_buf = false;\n\t\tbuf = server->smallbuf;\n\t\tpdu_length = 4;  \n\n\t\tlength = cifs_read_from_socket(server, buf, pdu_length);\n\t\tif (length < 0)\n\t\t\tcontinue;\n\n\t\tif (is_smb1(server))\n\t\t\tserver->total_read = length;\n\t\telse\n\t\t\tserver->total_read = 0;\n\n\t\t \n\t\tpdu_length = get_rfc1002_length(buf);\n\n\t\tcifs_dbg(FYI, \"RFC1002 header 0x%x\\n\", pdu_length);\n\t\tif (!is_smb_response(server, buf[0]))\n\t\t\tcontinue;\n\n\t\tpending_reconnect = false;\nnext_pdu:\n\t\tserver->pdu_size = pdu_length;\n\n\t\t \n\t\tif (server->pdu_size < MID_HEADER_SIZE(server)) {\n\t\t\tcifs_server_dbg(VFS, \"SMB response too short (%u bytes)\\n\",\n\t\t\t\t server->pdu_size);\n\t\t\tcifs_reconnect(server, true);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tlength = cifs_read_from_socket(server,\n\t\t\t     buf + HEADER_PREAMBLE_SIZE(server),\n\t\t\t     MID_HEADER_SIZE(server));\n\t\tif (length < 0)\n\t\t\tcontinue;\n\t\tserver->total_read += length;\n\n\t\tif (server->ops->next_header) {\n\t\t\tif (server->ops->next_header(server, buf, &next_offset)) {\n\t\t\t\tcifs_dbg(VFS, \"%s: malformed response (next_offset=%u)\\n\",\n\t\t\t\t\t __func__, next_offset);\n\t\t\t\tcifs_reconnect(server, true);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (next_offset)\n\t\t\t\tserver->pdu_size = next_offset;\n\t\t}\n\n\t\tmemset(mids, 0, sizeof(mids));\n\t\tmemset(bufs, 0, sizeof(bufs));\n\t\tnum_mids = 0;\n\n\t\tif (server->ops->is_transform_hdr &&\n\t\t    server->ops->receive_transform &&\n\t\t    server->ops->is_transform_hdr(buf)) {\n\t\t\tlength = server->ops->receive_transform(server,\n\t\t\t\t\t\t\t\tmids,\n\t\t\t\t\t\t\t\tbufs,\n\t\t\t\t\t\t\t\t&num_mids);\n\t\t} else {\n\t\t\tmids[0] = server->ops->find_mid(server, buf);\n\t\t\tbufs[0] = buf;\n\t\t\tnum_mids = 1;\n\n\t\t\tif (!mids[0] || !mids[0]->receive)\n\t\t\t\tlength = standard_receive3(server, mids[0]);\n\t\t\telse\n\t\t\t\tlength = mids[0]->receive(server, mids[0]);\n\t\t}\n\n\t\tif (length < 0) {\n\t\t\tfor (i = 0; i < num_mids; i++)\n\t\t\t\tif (mids[i])\n\t\t\t\t\trelease_mid(mids[i]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (server->ops->is_status_io_timeout &&\n\t\t    server->ops->is_status_io_timeout(buf)) {\n\t\t\tnum_io_timeout++;\n\t\t\tif (num_io_timeout > MAX_STATUS_IO_TIMEOUT) {\n\t\t\t\tcifs_server_dbg(VFS,\n\t\t\t\t\t\t\"Number of request timeouts exceeded %d. Reconnecting\",\n\t\t\t\t\t\tMAX_STATUS_IO_TIMEOUT);\n\n\t\t\t\tpending_reconnect = true;\n\t\t\t\tnum_io_timeout = 0;\n\t\t\t}\n\t\t}\n\n\t\tserver->lstrp = jiffies;\n\n\t\tfor (i = 0; i < num_mids; i++) {\n\t\t\tif (mids[i] != NULL) {\n\t\t\t\tmids[i]->resp_buf_size = server->pdu_size;\n\n\t\t\t\tif (bufs[i] != NULL) {\n\t\t\t\t\tif (server->ops->is_network_name_deleted &&\n\t\t\t\t\t    server->ops->is_network_name_deleted(bufs[i],\n\t\t\t\t\t\t\t\t\t\t server)) {\n\t\t\t\t\t\tcifs_server_dbg(FYI,\n\t\t\t\t\t\t\t\t\"Share deleted. Reconnect needed\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!mids[i]->multiRsp || mids[i]->multiEnd)\n\t\t\t\t\tmids[i]->callback(mids[i]);\n\n\t\t\t\trelease_mid(mids[i]);\n\t\t\t} else if (server->ops->is_oplock_break &&\n\t\t\t\t   server->ops->is_oplock_break(bufs[i],\n\t\t\t\t\t\t\t\tserver)) {\n\t\t\t\tsmb2_add_credits_from_hdr(bufs[i], server);\n\t\t\t\tcifs_dbg(FYI, \"Received oplock break\\n\");\n\t\t\t} else {\n\t\t\t\tcifs_server_dbg(VFS, \"No task to wake, unknown frame received! NumMids %d\\n\",\n\t\t\t\t\t\tatomic_read(&mid_count));\n\t\t\t\tcifs_dump_mem(\"Received Data is: \", bufs[i],\n\t\t\t\t\t      HEADER_SIZE(server));\n\t\t\t\tsmb2_add_credits_from_hdr(bufs[i], server);\n#ifdef CONFIG_CIFS_DEBUG2\n\t\t\t\tif (server->ops->dump_detail)\n\t\t\t\t\tserver->ops->dump_detail(bufs[i],\n\t\t\t\t\t\t\t\t server);\n\t\t\t\tcifs_dump_mids(server);\n#endif  \n\t\t\t}\n\t\t}\n\n\t\tif (pdu_length > server->pdu_size) {\n\t\t\tif (!allocate_buffers(server))\n\t\t\t\tcontinue;\n\t\t\tpdu_length -= server->pdu_size;\n\t\t\tserver->total_read = 0;\n\t\t\tserver->large_buf = false;\n\t\t\tbuf = server->smallbuf;\n\t\t\tgoto next_pdu;\n\t\t}\n\n\t\t \n\t\tif (pending_reconnect)\n\t\t\tcifs_reconnect(server, true);\n\n\t}  \n\n\t \n\tcifs_buf_release(server->bigbuf);\n\tif (server->smallbuf)  \n\t\tcifs_small_buf_release(server->smallbuf);\n\n\ttask_to_wake = xchg(&server->tsk, NULL);\n\tclean_demultiplex_info(server);\n\n\t \n\tif (!task_to_wake) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\twhile (!signal_pending(current)) {\n\t\t\tschedule();\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t}\n\t\tset_current_state(TASK_RUNNING);\n\t}\n\n\tmemalloc_noreclaim_restore(noreclaim_flag);\n\tmodule_put_and_kthread_exit(0);\n}\n\nint\ncifs_ipaddr_cmp(struct sockaddr *srcaddr, struct sockaddr *rhs)\n{\n\tstruct sockaddr_in *saddr4 = (struct sockaddr_in *)srcaddr;\n\tstruct sockaddr_in *vaddr4 = (struct sockaddr_in *)rhs;\n\tstruct sockaddr_in6 *saddr6 = (struct sockaddr_in6 *)srcaddr;\n\tstruct sockaddr_in6 *vaddr6 = (struct sockaddr_in6 *)rhs;\n\n\tswitch (srcaddr->sa_family) {\n\tcase AF_UNSPEC:\n\t\tswitch (rhs->sa_family) {\n\t\tcase AF_UNSPEC:\n\t\t\treturn 0;\n\t\tcase AF_INET:\n\t\tcase AF_INET6:\n\t\t\treturn 1;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\tcase AF_INET: {\n\t\tswitch (rhs->sa_family) {\n\t\tcase AF_UNSPEC:\n\t\t\treturn -1;\n\t\tcase AF_INET:\n\t\t\treturn memcmp(saddr4, vaddr4,\n\t\t\t\t      sizeof(struct sockaddr_in));\n\t\tcase AF_INET6:\n\t\t\treturn 1;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t}\n\tcase AF_INET6: {\n\t\tswitch (rhs->sa_family) {\n\t\tcase AF_UNSPEC:\n\t\tcase AF_INET:\n\t\t\treturn -1;\n\t\tcase AF_INET6:\n\t\t\treturn memcmp(saddr6,\n\t\t\t\t      vaddr6,\n\t\t\t\t      sizeof(struct sockaddr_in6));\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t}\n\tdefault:\n\t\treturn -1;  \n\t}\n}\n\n \nbool\ncifs_match_ipaddr(struct sockaddr *srcaddr, struct sockaddr *rhs)\n{\n\tswitch (srcaddr->sa_family) {\n\tcase AF_UNSPEC:\n\t\treturn (rhs->sa_family == AF_UNSPEC);\n\tcase AF_INET: {\n\t\tstruct sockaddr_in *saddr4 = (struct sockaddr_in *)srcaddr;\n\t\tstruct sockaddr_in *vaddr4 = (struct sockaddr_in *)rhs;\n\t\treturn (saddr4->sin_addr.s_addr == vaddr4->sin_addr.s_addr);\n\t}\n\tcase AF_INET6: {\n\t\tstruct sockaddr_in6 *saddr6 = (struct sockaddr_in6 *)srcaddr;\n\t\tstruct sockaddr_in6 *vaddr6 = (struct sockaddr_in6 *)rhs;\n\t\treturn (ipv6_addr_equal(&saddr6->sin6_addr, &vaddr6->sin6_addr)\n\t\t\t&& saddr6->sin6_scope_id == vaddr6->sin6_scope_id);\n\t}\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn false;  \n\t}\n}\n\n \nstatic bool\nmatch_port(struct TCP_Server_Info *server, struct sockaddr *addr)\n{\n\t__be16 port, *sport;\n\n\t \n\tif (server->rdma)\n\t\treturn true;\n\n\tswitch (addr->sa_family) {\n\tcase AF_INET:\n\t\tsport = &((struct sockaddr_in *) &server->dstaddr)->sin_port;\n\t\tport = ((struct sockaddr_in *) addr)->sin_port;\n\t\tbreak;\n\tcase AF_INET6:\n\t\tsport = &((struct sockaddr_in6 *) &server->dstaddr)->sin6_port;\n\t\tport = ((struct sockaddr_in6 *) addr)->sin6_port;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn false;\n\t}\n\n\tif (!port) {\n\t\tport = htons(CIFS_PORT);\n\t\tif (port == *sport)\n\t\t\treturn true;\n\n\t\tport = htons(RFC1001_PORT);\n\t}\n\n\treturn port == *sport;\n}\n\nstatic bool match_server_address(struct TCP_Server_Info *server, struct sockaddr *addr)\n{\n\tif (!cifs_match_ipaddr(addr, (struct sockaddr *)&server->dstaddr))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool\nmatch_security(struct TCP_Server_Info *server, struct smb3_fs_context *ctx)\n{\n\t \n\tif (server->ops->select_sectype(server, ctx->sectype)\n\t     == Unspecified)\n\t\treturn false;\n\n\t \n\tif (ctx->sign && !server->sign)\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic int match_server(struct TCP_Server_Info *server,\n\t\t\tstruct smb3_fs_context *ctx,\n\t\t\tbool match_super)\n{\n\tstruct sockaddr *addr = (struct sockaddr *)&ctx->dstaddr;\n\n\tlockdep_assert_held(&server->srv_lock);\n\n\tif (ctx->nosharesock)\n\t\treturn 0;\n\n\t \n\tif (server->nosharesock)\n\t\treturn 0;\n\n\t \n\tif (strcmp(ctx->vals->version_string, SMB3ANY_VERSION_STRING) == 0) {\n\t\tif (server->vals->protocol_id < SMB30_PROT_ID)\n\t\t\treturn 0;\n\t} else if (strcmp(ctx->vals->version_string,\n\t\t   SMBDEFAULT_VERSION_STRING) == 0) {\n\t\tif (server->vals->protocol_id < SMB21_PROT_ID)\n\t\t\treturn 0;\n\t} else if ((server->vals != ctx->vals) || (server->ops != ctx->ops))\n\t\treturn 0;\n\n\tif (!net_eq(cifs_net_ns(server), current->nsproxy->net_ns))\n\t\treturn 0;\n\n\tif (!cifs_match_ipaddr((struct sockaddr *)&ctx->srcaddr,\n\t\t\t       (struct sockaddr *)&server->srcaddr))\n\t\treturn 0;\n\t \n\tif (!match_super) {\n\t\tif (!ctx->nodfs) {\n\t\t\tif (server->leaf_fullpath) {\n\t\t\t\tif (!ctx->leaf_fullpath ||\n\t\t\t\t    strcasecmp(server->leaf_fullpath,\n\t\t\t\t\t       ctx->leaf_fullpath))\n\t\t\t\t\treturn 0;\n\t\t\t} else if (ctx->leaf_fullpath) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else if (server->leaf_fullpath) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\tif (!server->leaf_fullpath &&\n\t    (strcasecmp(server->hostname, ctx->server_hostname) ||\n\t     !match_server_address(server, addr) ||\n\t     !match_port(server, addr)))\n\t\treturn 0;\n\n\tif (!match_security(server, ctx))\n\t\treturn 0;\n\n\tif (server->echo_interval != ctx->echo_interval * HZ)\n\t\treturn 0;\n\n\tif (server->rdma != ctx->rdma)\n\t\treturn 0;\n\n\tif (server->ignore_signature != ctx->ignore_signature)\n\t\treturn 0;\n\n\tif (server->min_offload != ctx->min_offload)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstruct TCP_Server_Info *\ncifs_find_tcp_session(struct smb3_fs_context *ctx)\n{\n\tstruct TCP_Server_Info *server;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each_entry(server, &cifs_tcp_ses_list, tcp_ses_list) {\n\t\tspin_lock(&server->srv_lock);\n\t\t \n\t\tif (SERVER_IS_CHAN(server) ||\n\t\t    !match_server(server, ctx, false)) {\n\t\t\tspin_unlock(&server->srv_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&server->srv_lock);\n\n\t\t++server->srv_count;\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\tcifs_dbg(FYI, \"Existing tcp session with server found\\n\");\n\t\treturn server;\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\treturn NULL;\n}\n\nvoid\ncifs_put_tcp_session(struct TCP_Server_Info *server, int from_reconnect)\n{\n\tstruct task_struct *task;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tif (--server->srv_count > 0) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\n\t \n\tWARN_ON(server->srv_count < 0);\n\n\tput_net(cifs_net_ns(server));\n\n\tlist_del_init(&server->tcp_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\t \n\tif (SERVER_IS_CHAN(server))\n\t\tcifs_put_tcp_session(server->primary_server, from_reconnect);\n\n\tcancel_delayed_work_sync(&server->echo);\n\n\tif (from_reconnect)\n\t\t \n\t\tcancel_delayed_work(&server->reconnect);\n\telse\n\t\tcancel_delayed_work_sync(&server->reconnect);\n\n\tspin_lock(&server->srv_lock);\n\tserver->tcpStatus = CifsExiting;\n\tspin_unlock(&server->srv_lock);\n\n\tcifs_crypto_secmech_release(server);\n\n\tkfree_sensitive(server->session_key.response);\n\tserver->session_key.response = NULL;\n\tserver->session_key.len = 0;\n\tkfree(server->hostname);\n\tserver->hostname = NULL;\n\n\ttask = xchg(&server->tsk, NULL);\n\tif (task)\n\t\tsend_sig(SIGKILL, task, 1);\n}\n\nstruct TCP_Server_Info *\ncifs_get_tcp_session(struct smb3_fs_context *ctx,\n\t\t     struct TCP_Server_Info *primary_server)\n{\n\tstruct TCP_Server_Info *tcp_ses = NULL;\n\tint rc;\n\n\tcifs_dbg(FYI, \"UNC: %s\\n\", ctx->UNC);\n\n\t \n\ttcp_ses = cifs_find_tcp_session(ctx);\n\tif (tcp_ses)\n\t\treturn tcp_ses;\n\n\ttcp_ses = kzalloc(sizeof(struct TCP_Server_Info), GFP_KERNEL);\n\tif (!tcp_ses) {\n\t\trc = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\ttcp_ses->hostname = kstrdup(ctx->server_hostname, GFP_KERNEL);\n\tif (!tcp_ses->hostname) {\n\t\trc = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\tif (ctx->leaf_fullpath) {\n\t\ttcp_ses->leaf_fullpath = kstrdup(ctx->leaf_fullpath, GFP_KERNEL);\n\t\tif (!tcp_ses->leaf_fullpath) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\tif (ctx->nosharesock)\n\t\ttcp_ses->nosharesock = true;\n\n\ttcp_ses->ops = ctx->ops;\n\ttcp_ses->vals = ctx->vals;\n\tcifs_set_net_ns(tcp_ses, get_net(current->nsproxy->net_ns));\n\n\ttcp_ses->conn_id = atomic_inc_return(&tcpSesNextId);\n\ttcp_ses->noblockcnt = ctx->rootfs;\n\ttcp_ses->noblocksnd = ctx->noblocksnd || ctx->rootfs;\n\ttcp_ses->noautotune = ctx->noautotune;\n\ttcp_ses->tcp_nodelay = ctx->sockopt_tcp_nodelay;\n\ttcp_ses->rdma = ctx->rdma;\n\ttcp_ses->in_flight = 0;\n\ttcp_ses->max_in_flight = 0;\n\ttcp_ses->credits = 1;\n\tif (primary_server) {\n\t\tspin_lock(&cifs_tcp_ses_lock);\n\t\t++primary_server->srv_count;\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\ttcp_ses->primary_server = primary_server;\n\t}\n\tinit_waitqueue_head(&tcp_ses->response_q);\n\tinit_waitqueue_head(&tcp_ses->request_q);\n\tINIT_LIST_HEAD(&tcp_ses->pending_mid_q);\n\tmutex_init(&tcp_ses->_srv_mutex);\n\tmemcpy(tcp_ses->workstation_RFC1001_name,\n\t\tctx->source_rfc1001_name, RFC1001_NAME_LEN_WITH_NULL);\n\tmemcpy(tcp_ses->server_RFC1001_name,\n\t\tctx->target_rfc1001_name, RFC1001_NAME_LEN_WITH_NULL);\n\ttcp_ses->session_estab = false;\n\ttcp_ses->sequence_number = 0;\n\ttcp_ses->channel_sequence_num = 0;  \n\ttcp_ses->reconnect_instance = 1;\n\ttcp_ses->lstrp = jiffies;\n\ttcp_ses->compress_algorithm = cpu_to_le16(ctx->compression);\n\tspin_lock_init(&tcp_ses->req_lock);\n\tspin_lock_init(&tcp_ses->srv_lock);\n\tspin_lock_init(&tcp_ses->mid_lock);\n\tINIT_LIST_HEAD(&tcp_ses->tcp_ses_list);\n\tINIT_LIST_HEAD(&tcp_ses->smb_ses_list);\n\tINIT_DELAYED_WORK(&tcp_ses->echo, cifs_echo_request);\n\tINIT_DELAYED_WORK(&tcp_ses->reconnect, smb2_reconnect_server);\n\tmutex_init(&tcp_ses->reconnect_mutex);\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\tmutex_init(&tcp_ses->refpath_lock);\n#endif\n\tmemcpy(&tcp_ses->srcaddr, &ctx->srcaddr,\n\t       sizeof(tcp_ses->srcaddr));\n\tmemcpy(&tcp_ses->dstaddr, &ctx->dstaddr,\n\t\tsizeof(tcp_ses->dstaddr));\n\tif (ctx->use_client_guid)\n\t\tmemcpy(tcp_ses->client_guid, ctx->client_guid,\n\t\t       SMB2_CLIENT_GUID_SIZE);\n\telse\n\t\tgenerate_random_uuid(tcp_ses->client_guid);\n\t \n\ttcp_ses->tcpStatus = CifsNew;\n\t++tcp_ses->srv_count;\n\n\tif (ctx->echo_interval >= SMB_ECHO_INTERVAL_MIN &&\n\t\tctx->echo_interval <= SMB_ECHO_INTERVAL_MAX)\n\t\ttcp_ses->echo_interval = ctx->echo_interval * HZ;\n\telse\n\t\ttcp_ses->echo_interval = SMB_ECHO_INTERVAL_DEFAULT * HZ;\n\tif (tcp_ses->rdma) {\n#ifndef CONFIG_CIFS_SMB_DIRECT\n\t\tcifs_dbg(VFS, \"CONFIG_CIFS_SMB_DIRECT is not enabled\\n\");\n\t\trc = -ENOENT;\n\t\tgoto out_err_crypto_release;\n#endif\n\t\ttcp_ses->smbd_conn = smbd_get_connection(\n\t\t\ttcp_ses, (struct sockaddr *)&ctx->dstaddr);\n\t\tif (tcp_ses->smbd_conn) {\n\t\t\tcifs_dbg(VFS, \"RDMA transport established\\n\");\n\t\t\trc = 0;\n\t\t\tgoto smbd_connected;\n\t\t} else {\n\t\t\trc = -ENOENT;\n\t\t\tgoto out_err_crypto_release;\n\t\t}\n\t}\n\trc = ip_connect(tcp_ses);\n\tif (rc < 0) {\n\t\tcifs_dbg(VFS, \"Error connecting to socket. Aborting operation.\\n\");\n\t\tgoto out_err_crypto_release;\n\t}\nsmbd_connected:\n\t \n\t__module_get(THIS_MODULE);\n\ttcp_ses->tsk = kthread_run(cifs_demultiplex_thread,\n\t\t\t\t  tcp_ses, \"cifsd\");\n\tif (IS_ERR(tcp_ses->tsk)) {\n\t\trc = PTR_ERR(tcp_ses->tsk);\n\t\tcifs_dbg(VFS, \"error %d create cifsd thread\\n\", rc);\n\t\tmodule_put(THIS_MODULE);\n\t\tgoto out_err_crypto_release;\n\t}\n\ttcp_ses->min_offload = ctx->min_offload;\n\t \n\tspin_lock(&tcp_ses->srv_lock);\n\ttcp_ses->tcpStatus = CifsNeedNegotiate;\n\tspin_unlock(&tcp_ses->srv_lock);\n\n\tif ((ctx->max_credits < 20) || (ctx->max_credits > 60000))\n\t\ttcp_ses->max_credits = SMB2_MAX_CREDITS_AVAILABLE;\n\telse\n\t\ttcp_ses->max_credits = ctx->max_credits;\n\n\ttcp_ses->nr_targets = 1;\n\ttcp_ses->ignore_signature = ctx->ignore_signature;\n\t \n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_add(&tcp_ses->tcp_ses_list, &cifs_tcp_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\t \n\tqueue_delayed_work(cifsiod_wq, &tcp_ses->echo, tcp_ses->echo_interval);\n\n\treturn tcp_ses;\n\nout_err_crypto_release:\n\tcifs_crypto_secmech_release(tcp_ses);\n\n\tput_net(cifs_net_ns(tcp_ses));\n\nout_err:\n\tif (tcp_ses) {\n\t\tif (SERVER_IS_CHAN(tcp_ses))\n\t\t\tcifs_put_tcp_session(tcp_ses->primary_server, false);\n\t\tkfree(tcp_ses->hostname);\n\t\tkfree(tcp_ses->leaf_fullpath);\n\t\tif (tcp_ses->ssocket)\n\t\t\tsock_release(tcp_ses->ssocket);\n\t\tkfree(tcp_ses);\n\t}\n\treturn ERR_PTR(rc);\n}\n\n \nstatic int match_session(struct cifs_ses *ses, struct smb3_fs_context *ctx)\n{\n\tif (ctx->sectype != Unspecified &&\n\t    ctx->sectype != ses->sectype)\n\t\treturn 0;\n\n\t \n\tif (ses->chan_max < ctx->max_channels)\n\t\treturn 0;\n\n\tswitch (ses->sectype) {\n\tcase Kerberos:\n\t\tif (!uid_eq(ctx->cred_uid, ses->cred_uid))\n\t\t\treturn 0;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tif (ses->user_name == NULL) {\n\t\t\tif (!ctx->nullauth)\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (strncmp(ses->user_name,\n\t\t\t    ctx->username ? ctx->username : \"\",\n\t\t\t    CIFS_MAX_USERNAME_LEN))\n\t\t\treturn 0;\n\t\tif ((ctx->username && strlen(ctx->username) != 0) &&\n\t\t    ses->password != NULL &&\n\t\t    strncmp(ses->password,\n\t\t\t    ctx->password ? ctx->password : \"\",\n\t\t\t    CIFS_MAX_PASSWORD_LEN))\n\t\t\treturn 0;\n\t}\n\n\tif (strcmp(ctx->local_nls->charset, ses->local_nls->charset))\n\t\treturn 0;\n\n\treturn 1;\n}\n\n \nstatic int\ncifs_setup_ipc(struct cifs_ses *ses, struct smb3_fs_context *ctx)\n{\n\tint rc = 0, xid;\n\tstruct cifs_tcon *tcon;\n\tchar unc[SERVER_NAME_LENGTH + sizeof(\"//x/IPC$\")] = {0};\n\tbool seal = false;\n\tstruct TCP_Server_Info *server = ses->server;\n\n\t \n\tif (ctx->seal) {\n\t\tif (server->capabilities & SMB2_GLOBAL_CAP_ENCRYPTION)\n\t\t\tseal = true;\n\t\telse {\n\t\t\tcifs_server_dbg(VFS,\n\t\t\t\t \"IPC: server doesn't support encryption\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\n\t \n\ttcon = tcon_info_alloc(false);\n\tif (tcon == NULL)\n\t\treturn -ENOMEM;\n\n\tspin_lock(&server->srv_lock);\n\tscnprintf(unc, sizeof(unc), \"\\\\\\\\%s\\\\IPC$\", server->hostname);\n\tspin_unlock(&server->srv_lock);\n\n\txid = get_xid();\n\ttcon->ses = ses;\n\ttcon->ipc = true;\n\ttcon->seal = seal;\n\trc = server->ops->tree_connect(xid, ses, unc, tcon, ctx->local_nls);\n\tfree_xid(xid);\n\n\tif (rc) {\n\t\tcifs_server_dbg(VFS, \"failed to connect to IPC (rc=%d)\\n\", rc);\n\t\ttconInfoFree(tcon);\n\t\tgoto out;\n\t}\n\n\tcifs_dbg(FYI, \"IPC tcon rc=%d ipc tid=0x%x\\n\", rc, tcon->tid);\n\n\tspin_lock(&tcon->tc_lock);\n\ttcon->status = TID_GOOD;\n\tspin_unlock(&tcon->tc_lock);\n\tses->tcon_ipc = tcon;\nout:\n\treturn rc;\n}\n\n \nstatic int\ncifs_free_ipc(struct cifs_ses *ses)\n{\n\tstruct cifs_tcon *tcon = ses->tcon_ipc;\n\n\tif (tcon == NULL)\n\t\treturn 0;\n\n\ttconInfoFree(tcon);\n\tses->tcon_ipc = NULL;\n\treturn 0;\n}\n\nstatic struct cifs_ses *\ncifs_find_smb_ses(struct TCP_Server_Info *server, struct smb3_fs_context *ctx)\n{\n\tstruct cifs_ses *ses, *ret = NULL;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each_entry(ses, &server->smb_ses_list, smb_ses_list) {\n\t\tspin_lock(&ses->ses_lock);\n\t\tif (ses->ses_status == SES_EXITING) {\n\t\t\tspin_unlock(&ses->ses_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tspin_lock(&ses->chan_lock);\n\t\tif (match_session(ses, ctx)) {\n\t\t\tspin_unlock(&ses->chan_lock);\n\t\t\tspin_unlock(&ses->ses_lock);\n\t\t\tret = ses;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&ses->chan_lock);\n\t\tspin_unlock(&ses->ses_lock);\n\t}\n\tif (ret)\n\t\tcifs_smb_ses_inc_refcount(ret);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\treturn ret;\n}\n\nvoid __cifs_put_smb_ses(struct cifs_ses *ses)\n{\n\tunsigned int rc, xid;\n\tunsigned int chan_count;\n\tstruct TCP_Server_Info *server = ses->server;\n\n\tspin_lock(&ses->ses_lock);\n\tif (ses->ses_status == SES_EXITING) {\n\t\tspin_unlock(&ses->ses_lock);\n\t\treturn;\n\t}\n\tspin_unlock(&ses->ses_lock);\n\n\tcifs_dbg(FYI, \"%s: ses_count=%d\\n\", __func__, ses->ses_count);\n\tcifs_dbg(FYI,\n\t\t \"%s: ses ipc: %s\\n\", __func__, ses->tcon_ipc ? ses->tcon_ipc->tree_name : \"NONE\");\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tif (--ses->ses_count > 0) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\tspin_lock(&ses->ses_lock);\n\tif (ses->ses_status == SES_GOOD)\n\t\tses->ses_status = SES_EXITING;\n\tspin_unlock(&ses->ses_lock);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\t \n\tWARN_ON(ses->ses_count < 0);\n\n\tspin_lock(&ses->ses_lock);\n\tif (ses->ses_status == SES_EXITING && server->ops->logoff) {\n\t\tspin_unlock(&ses->ses_lock);\n\t\tcifs_free_ipc(ses);\n\t\txid = get_xid();\n\t\trc = server->ops->logoff(xid, ses);\n\t\tif (rc)\n\t\t\tcifs_server_dbg(VFS, \"%s: Session Logoff failure rc=%d\\n\",\n\t\t\t\t__func__, rc);\n\t\t_free_xid(xid);\n\t} else {\n\t\tspin_unlock(&ses->ses_lock);\n\t\tcifs_free_ipc(ses);\n\t}\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_del_init(&ses->smb_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tchan_count = ses->chan_count;\n\n\t \n\tif (chan_count > 1) {\n\t\tint i;\n\n\t\tfor (i = 1; i < chan_count; i++) {\n\t\t\tif (ses->chans[i].iface) {\n\t\t\t\tkref_put(&ses->chans[i].iface->refcount, release_iface);\n\t\t\t\tses->chans[i].iface = NULL;\n\t\t\t}\n\t\t\tcifs_put_tcp_session(ses->chans[i].server, 0);\n\t\t\tses->chans[i].server = NULL;\n\t\t}\n\t}\n\n\t \n\tif (ses->chans[0].iface) {\n\t\tkref_put(&ses->chans[0].iface->refcount, release_iface);\n\t\tses->chans[0].server = NULL;\n\t}\n\n\tsesInfoFree(ses);\n\tcifs_put_tcp_session(server, 0);\n}\n\n#ifdef CONFIG_KEYS\n\n \n#define CIFSCREDS_DESC_SIZE (7 + CIFS_MAX_DOMAINNAME_LEN + 1)\n\n \nstatic int\ncifs_set_cifscreds(struct smb3_fs_context *ctx, struct cifs_ses *ses)\n{\n\tint rc = 0;\n\tint is_domain = 0;\n\tconst char *delim, *payload;\n\tchar *desc;\n\tssize_t len;\n\tstruct key *key;\n\tstruct TCP_Server_Info *server = ses->server;\n\tstruct sockaddr_in *sa;\n\tstruct sockaddr_in6 *sa6;\n\tconst struct user_key_payload *upayload;\n\n\tdesc = kmalloc(CIFSCREDS_DESC_SIZE, GFP_KERNEL);\n\tif (!desc)\n\t\treturn -ENOMEM;\n\n\t \n\tswitch (server->dstaddr.ss_family) {\n\tcase AF_INET:\n\t\tsa = (struct sockaddr_in *)&server->dstaddr;\n\t\tsprintf(desc, \"cifs:a:%pI4\", &sa->sin_addr.s_addr);\n\t\tbreak;\n\tcase AF_INET6:\n\t\tsa6 = (struct sockaddr_in6 *)&server->dstaddr;\n\t\tsprintf(desc, \"cifs:a:%pI6c\", &sa6->sin6_addr.s6_addr);\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(FYI, \"Bad ss_family (%hu)\\n\",\n\t\t\t server->dstaddr.ss_family);\n\t\trc = -EINVAL;\n\t\tgoto out_err;\n\t}\n\n\tcifs_dbg(FYI, \"%s: desc=%s\\n\", __func__, desc);\n\tkey = request_key(&key_type_logon, desc, \"\");\n\tif (IS_ERR(key)) {\n\t\tif (!ses->domainName) {\n\t\t\tcifs_dbg(FYI, \"domainName is NULL\\n\");\n\t\t\trc = PTR_ERR(key);\n\t\t\tgoto out_err;\n\t\t}\n\n\t\t \n\t\tsprintf(desc, \"cifs:d:%s\", ses->domainName);\n\t\tcifs_dbg(FYI, \"%s: desc=%s\\n\", __func__, desc);\n\t\tkey = request_key(&key_type_logon, desc, \"\");\n\t\tif (IS_ERR(key)) {\n\t\t\trc = PTR_ERR(key);\n\t\t\tgoto out_err;\n\t\t}\n\t\tis_domain = 1;\n\t}\n\n\tdown_read(&key->sem);\n\tupayload = user_key_payload_locked(key);\n\tif (IS_ERR_OR_NULL(upayload)) {\n\t\trc = upayload ? PTR_ERR(upayload) : -EINVAL;\n\t\tgoto out_key_put;\n\t}\n\n\t \n\tpayload = upayload->data;\n\tdelim = strnchr(payload, upayload->datalen, ':');\n\tcifs_dbg(FYI, \"payload=%s\\n\", payload);\n\tif (!delim) {\n\t\tcifs_dbg(FYI, \"Unable to find ':' in payload (datalen=%d)\\n\",\n\t\t\t upayload->datalen);\n\t\trc = -EINVAL;\n\t\tgoto out_key_put;\n\t}\n\n\tlen = delim - payload;\n\tif (len > CIFS_MAX_USERNAME_LEN || len <= 0) {\n\t\tcifs_dbg(FYI, \"Bad value from username search (len=%zd)\\n\",\n\t\t\t len);\n\t\trc = -EINVAL;\n\t\tgoto out_key_put;\n\t}\n\n\tctx->username = kstrndup(payload, len, GFP_KERNEL);\n\tif (!ctx->username) {\n\t\tcifs_dbg(FYI, \"Unable to allocate %zd bytes for username\\n\",\n\t\t\t len);\n\t\trc = -ENOMEM;\n\t\tgoto out_key_put;\n\t}\n\tcifs_dbg(FYI, \"%s: username=%s\\n\", __func__, ctx->username);\n\n\tlen = key->datalen - (len + 1);\n\tif (len > CIFS_MAX_PASSWORD_LEN || len <= 0) {\n\t\tcifs_dbg(FYI, \"Bad len for password search (len=%zd)\\n\", len);\n\t\trc = -EINVAL;\n\t\tkfree(ctx->username);\n\t\tctx->username = NULL;\n\t\tgoto out_key_put;\n\t}\n\n\t++delim;\n\tctx->password = kstrndup(delim, len, GFP_KERNEL);\n\tif (!ctx->password) {\n\t\tcifs_dbg(FYI, \"Unable to allocate %zd bytes for password\\n\",\n\t\t\t len);\n\t\trc = -ENOMEM;\n\t\tkfree(ctx->username);\n\t\tctx->username = NULL;\n\t\tgoto out_key_put;\n\t}\n\n\t \n\tif (is_domain && ses->domainName) {\n\t\tctx->domainname = kstrdup(ses->domainName, GFP_KERNEL);\n\t\tif (!ctx->domainname) {\n\t\t\tcifs_dbg(FYI, \"Unable to allocate %zd bytes for domain\\n\",\n\t\t\t\t len);\n\t\t\trc = -ENOMEM;\n\t\t\tkfree(ctx->username);\n\t\t\tctx->username = NULL;\n\t\t\tkfree_sensitive(ctx->password);\n\t\t\tctx->password = NULL;\n\t\t\tgoto out_key_put;\n\t\t}\n\t}\n\n\tstrscpy(ctx->workstation_name, ses->workstation_name, sizeof(ctx->workstation_name));\n\nout_key_put:\n\tup_read(&key->sem);\n\tkey_put(key);\nout_err:\n\tkfree(desc);\n\tcifs_dbg(FYI, \"%s: returning %d\\n\", __func__, rc);\n\treturn rc;\n}\n#else  \nstatic inline int\ncifs_set_cifscreds(struct smb3_fs_context *ctx __attribute__((unused)),\n\t\t   struct cifs_ses *ses __attribute__((unused)))\n{\n\treturn -ENOSYS;\n}\n#endif  \n\n \nstruct cifs_ses *\ncifs_get_smb_ses(struct TCP_Server_Info *server, struct smb3_fs_context *ctx)\n{\n\tint rc = 0;\n\tunsigned int xid;\n\tstruct cifs_ses *ses;\n\tstruct sockaddr_in *addr = (struct sockaddr_in *)&server->dstaddr;\n\tstruct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)&server->dstaddr;\n\n\txid = get_xid();\n\n\tses = cifs_find_smb_ses(server, ctx);\n\tif (ses) {\n\t\tcifs_dbg(FYI, \"Existing smb sess found (status=%d)\\n\",\n\t\t\t ses->ses_status);\n\n\t\tspin_lock(&ses->chan_lock);\n\t\tif (cifs_chan_needs_reconnect(ses, server)) {\n\t\t\tspin_unlock(&ses->chan_lock);\n\t\t\tcifs_dbg(FYI, \"Session needs reconnect\\n\");\n\n\t\t\tmutex_lock(&ses->session_mutex);\n\t\t\trc = cifs_negotiate_protocol(xid, ses, server);\n\t\t\tif (rc) {\n\t\t\t\tmutex_unlock(&ses->session_mutex);\n\t\t\t\t \n\t\t\t\tcifs_put_smb_ses(ses);\n\t\t\t\tfree_xid(xid);\n\t\t\t\treturn ERR_PTR(rc);\n\t\t\t}\n\n\t\t\trc = cifs_setup_session(xid, ses, server,\n\t\t\t\t\t\tctx->local_nls);\n\t\t\tif (rc) {\n\t\t\t\tmutex_unlock(&ses->session_mutex);\n\t\t\t\t \n\t\t\t\tcifs_put_smb_ses(ses);\n\t\t\t\tfree_xid(xid);\n\t\t\t\treturn ERR_PTR(rc);\n\t\t\t}\n\t\t\tmutex_unlock(&ses->session_mutex);\n\n\t\t\tspin_lock(&ses->chan_lock);\n\t\t}\n\t\tspin_unlock(&ses->chan_lock);\n\n\t\t \n\t\tcifs_put_tcp_session(server, 0);\n\t\tfree_xid(xid);\n\t\treturn ses;\n\t}\n\n\trc = -ENOMEM;\n\n\tcifs_dbg(FYI, \"Existing smb sess not found\\n\");\n\tses = sesInfoAlloc();\n\tif (ses == NULL)\n\t\tgoto get_ses_fail;\n\n\t \n\tses->server = server;\n\tif (server->dstaddr.ss_family == AF_INET6)\n\t\tsprintf(ses->ip_addr, \"%pI6\", &addr6->sin6_addr);\n\telse\n\t\tsprintf(ses->ip_addr, \"%pI4\", &addr->sin_addr);\n\n\tif (ctx->username) {\n\t\tses->user_name = kstrdup(ctx->username, GFP_KERNEL);\n\t\tif (!ses->user_name)\n\t\t\tgoto get_ses_fail;\n\t}\n\n\t \n\tif (ctx->password) {\n\t\tses->password = kstrdup(ctx->password, GFP_KERNEL);\n\t\tif (!ses->password)\n\t\t\tgoto get_ses_fail;\n\t}\n\tif (ctx->domainname) {\n\t\tses->domainName = kstrdup(ctx->domainname, GFP_KERNEL);\n\t\tif (!ses->domainName)\n\t\t\tgoto get_ses_fail;\n\t}\n\n\tstrscpy(ses->workstation_name, ctx->workstation_name, sizeof(ses->workstation_name));\n\n\tif (ctx->domainauto)\n\t\tses->domainAuto = ctx->domainauto;\n\tses->cred_uid = ctx->cred_uid;\n\tses->linux_uid = ctx->linux_uid;\n\n\tses->sectype = ctx->sectype;\n\tses->sign = ctx->sign;\n\tses->local_nls = load_nls(ctx->local_nls->charset);\n\n\t \n\tspin_lock(&ses->chan_lock);\n\tses->chans[0].server = server;\n\tses->chan_count = 1;\n\tses->chan_max = ctx->multichannel ? ctx->max_channels:1;\n\tses->chans_need_reconnect = 1;\n\tspin_unlock(&ses->chan_lock);\n\n\tmutex_lock(&ses->session_mutex);\n\trc = cifs_negotiate_protocol(xid, ses, server);\n\tif (!rc)\n\t\trc = cifs_setup_session(xid, ses, server, ctx->local_nls);\n\tmutex_unlock(&ses->session_mutex);\n\n\t \n\tspin_lock(&ses->chan_lock);\n\tmemcpy(ses->chans[0].signkey, ses->smb3signingkey,\n\t       sizeof(ses->smb3signingkey));\n\tspin_unlock(&ses->chan_lock);\n\n\tif (rc)\n\t\tgoto get_ses_fail;\n\n\t \n\tspin_lock(&cifs_tcp_ses_lock);\n\tses->dfs_root_ses = ctx->dfs_root_ses;\n\tif (ses->dfs_root_ses)\n\t\tses->dfs_root_ses->ses_count++;\n\tlist_add(&ses->smb_ses_list, &server->smb_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tcifs_setup_ipc(ses, ctx);\n\n\tfree_xid(xid);\n\n\treturn ses;\n\nget_ses_fail:\n\tsesInfoFree(ses);\n\tfree_xid(xid);\n\treturn ERR_PTR(rc);\n}\n\n \nstatic int match_tcon(struct cifs_tcon *tcon, struct smb3_fs_context *ctx)\n{\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\n\tif (tcon->status == TID_EXITING)\n\t\treturn 0;\n\n\tif (tcon->origin_fullpath) {\n\t\tif (!ctx->source ||\n\t\t    !dfs_src_pathname_equal(ctx->source,\n\t\t\t\t\t    tcon->origin_fullpath))\n\t\t\treturn 0;\n\t} else if (!server->leaf_fullpath &&\n\t\t   strncmp(tcon->tree_name, ctx->UNC, MAX_TREE_SIZE)) {\n\t\treturn 0;\n\t}\n\tif (tcon->seal != ctx->seal)\n\t\treturn 0;\n\tif (tcon->snapshot_time != ctx->snapshot_time)\n\t\treturn 0;\n\tif (tcon->handle_timeout != ctx->handle_timeout)\n\t\treturn 0;\n\tif (tcon->no_lease != ctx->no_lease)\n\t\treturn 0;\n\tif (tcon->nodelete != ctx->nodelete)\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic struct cifs_tcon *\ncifs_find_tcon(struct cifs_ses *ses, struct smb3_fs_context *ctx)\n{\n\tstruct cifs_tcon *tcon;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each_entry(tcon, &ses->tcon_list, tcon_list) {\n\t\tspin_lock(&tcon->tc_lock);\n\t\tif (!match_tcon(tcon, ctx)) {\n\t\t\tspin_unlock(&tcon->tc_lock);\n\t\t\tcontinue;\n\t\t}\n\t\t++tcon->tc_count;\n\t\tspin_unlock(&tcon->tc_lock);\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn tcon;\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\treturn NULL;\n}\n\nvoid\ncifs_put_tcon(struct cifs_tcon *tcon)\n{\n\tunsigned int xid;\n\tstruct cifs_ses *ses;\n\n\t \n\tif (tcon == NULL || tcon->ipc)\n\t\treturn;\n\n\tses = tcon->ses;\n\tcifs_dbg(FYI, \"%s: tc_count=%d\\n\", __func__, tcon->tc_count);\n\tspin_lock(&cifs_tcp_ses_lock);\n\tspin_lock(&tcon->tc_lock);\n\tif (--tcon->tc_count > 0) {\n\t\tspin_unlock(&tcon->tc_lock);\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\n\t \n\tWARN_ON(tcon->tc_count < 0);\n\n\tlist_del_init(&tcon->tcon_list);\n\ttcon->status = TID_EXITING;\n\tspin_unlock(&tcon->tc_lock);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\t \n\tcancel_delayed_work_sync(&tcon->query_interfaces);\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\tcancel_delayed_work_sync(&tcon->dfs_cache_work);\n#endif\n\n\tif (tcon->use_witness) {\n\t\tint rc;\n\n\t\trc = cifs_swn_unregister(tcon);\n\t\tif (rc < 0) {\n\t\t\tcifs_dbg(VFS, \"%s: Failed to unregister for witness notifications: %d\\n\",\n\t\t\t\t\t__func__, rc);\n\t\t}\n\t}\n\n\txid = get_xid();\n\tif (ses->server->ops->tree_disconnect)\n\t\tses->server->ops->tree_disconnect(xid, tcon);\n\t_free_xid(xid);\n\n\tcifs_fscache_release_super_cookie(tcon);\n\ttconInfoFree(tcon);\n\tcifs_put_smb_ses(ses);\n}\n\n \nstatic struct cifs_tcon *\ncifs_get_tcon(struct cifs_ses *ses, struct smb3_fs_context *ctx)\n{\n\tstruct cifs_tcon *tcon;\n\tbool nohandlecache;\n\tint rc, xid;\n\n\ttcon = cifs_find_tcon(ses, ctx);\n\tif (tcon) {\n\t\t \n\t\tcifs_dbg(FYI, \"Found match on UNC path\\n\");\n\t\tcifs_put_smb_ses(ses);\n\t\treturn tcon;\n\t}\n\n\tif (!ses->server->ops->tree_connect) {\n\t\trc = -ENOSYS;\n\t\tgoto out_fail;\n\t}\n\n\tif (ses->server->dialect >= SMB20_PROT_ID &&\n\t    (ses->server->capabilities & SMB2_GLOBAL_CAP_DIRECTORY_LEASING))\n\t\tnohandlecache = ctx->nohandlecache;\n\telse\n\t\tnohandlecache = true;\n\ttcon = tcon_info_alloc(!nohandlecache);\n\tif (tcon == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto out_fail;\n\t}\n\ttcon->nohandlecache = nohandlecache;\n\n\tif (ctx->snapshot_time) {\n\t\tif (ses->server->vals->protocol_id == 0) {\n\t\t\tcifs_dbg(VFS,\n\t\t\t     \"Use SMB2 or later for snapshot mount option\\n\");\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto out_fail;\n\t\t} else\n\t\t\ttcon->snapshot_time = ctx->snapshot_time;\n\t}\n\n\tif (ctx->handle_timeout) {\n\t\tif (ses->server->vals->protocol_id == 0) {\n\t\t\tcifs_dbg(VFS,\n\t\t\t     \"Use SMB2.1 or later for handle timeout option\\n\");\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto out_fail;\n\t\t} else\n\t\t\ttcon->handle_timeout = ctx->handle_timeout;\n\t}\n\n\ttcon->ses = ses;\n\tif (ctx->password) {\n\t\ttcon->password = kstrdup(ctx->password, GFP_KERNEL);\n\t\tif (!tcon->password) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out_fail;\n\t\t}\n\t}\n\n\tif (ctx->seal) {\n\t\tif (ses->server->vals->protocol_id == 0) {\n\t\t\tcifs_dbg(VFS,\n\t\t\t\t \"SMB3 or later required for encryption\\n\");\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto out_fail;\n\t\t} else if (tcon->ses->server->capabilities &\n\t\t\t\t\tSMB2_GLOBAL_CAP_ENCRYPTION)\n\t\t\ttcon->seal = true;\n\t\telse {\n\t\t\tcifs_dbg(VFS, \"Encryption is not supported on share\\n\");\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto out_fail;\n\t\t}\n\t}\n\n\tif (ctx->linux_ext) {\n\t\tif (ses->server->posix_ext_supported) {\n\t\t\ttcon->posix_extensions = true;\n\t\t\tpr_warn_once(\"SMB3.11 POSIX Extensions are experimental\\n\");\n\t\t} else if ((ses->server->vals->protocol_id == SMB311_PROT_ID) ||\n\t\t    (strcmp(ses->server->vals->version_string,\n\t\t     SMB3ANY_VERSION_STRING) == 0) ||\n\t\t    (strcmp(ses->server->vals->version_string,\n\t\t     SMBDEFAULT_VERSION_STRING) == 0)) {\n\t\t\tcifs_dbg(VFS, \"Server does not support mounting with posix SMB3.11 extensions\\n\");\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto out_fail;\n\t\t} else {\n\t\t\tcifs_dbg(VFS, \"Check vers= mount option. SMB3.11 \"\n\t\t\t\t\"disabled but required for POSIX extensions\\n\");\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto out_fail;\n\t\t}\n\t}\n\n\txid = get_xid();\n\trc = ses->server->ops->tree_connect(xid, ses, ctx->UNC, tcon,\n\t\t\t\t\t    ctx->local_nls);\n\tfree_xid(xid);\n\tcifs_dbg(FYI, \"Tcon rc = %d\\n\", rc);\n\tif (rc)\n\t\tgoto out_fail;\n\n\ttcon->use_persistent = false;\n\t \n\tif (ctx->persistent) {\n\t\tif (ses->server->vals->protocol_id == 0) {\n\t\t\tcifs_dbg(VFS,\n\t\t\t     \"SMB3 or later required for persistent handles\\n\");\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto out_fail;\n\t\t} else if (ses->server->capabilities &\n\t\t\t   SMB2_GLOBAL_CAP_PERSISTENT_HANDLES)\n\t\t\ttcon->use_persistent = true;\n\t\telse   {\n\t\t\tcifs_dbg(VFS,\n\t\t\t\t\"Persistent handles not supported on share\\n\");\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto out_fail;\n\t\t}\n\t} else if ((tcon->capabilities & SMB2_SHARE_CAP_CONTINUOUS_AVAILABILITY)\n\t     && (ses->server->capabilities & SMB2_GLOBAL_CAP_PERSISTENT_HANDLES)\n\t     && (ctx->nopersistent == false)) {\n\t\tcifs_dbg(FYI, \"enabling persistent handles\\n\");\n\t\ttcon->use_persistent = true;\n\t} else if (ctx->resilient) {\n\t\tif (ses->server->vals->protocol_id == 0) {\n\t\t\tcifs_dbg(VFS,\n\t\t\t     \"SMB2.1 or later required for resilient handles\\n\");\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto out_fail;\n\t\t}\n\t\ttcon->use_resilient = true;\n\t}\n\n\ttcon->use_witness = false;\n\tif (IS_ENABLED(CONFIG_CIFS_SWN_UPCALL) && ctx->witness) {\n\t\tif (ses->server->vals->protocol_id >= SMB30_PROT_ID) {\n\t\t\tif (tcon->capabilities & SMB2_SHARE_CAP_CLUSTER) {\n\t\t\t\t \n\t\t\t\ttcon->use_witness = true;\n\t\t\t\t \n\t\t\t\trc = cifs_swn_register(tcon);\n\t\t\t\tif (rc < 0) {\n\t\t\t\t\tcifs_dbg(VFS, \"Failed to register for witness notifications: %d\\n\", rc);\n\t\t\t\t\tgoto out_fail;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tcifs_dbg(VFS, \"witness requested on mount but no CLUSTER capability on share\\n\");\n\t\t\t\trc = -EOPNOTSUPP;\n\t\t\t\tgoto out_fail;\n\t\t\t}\n\t\t} else {\n\t\t\tcifs_dbg(VFS, \"SMB3 or later required for witness option\\n\");\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto out_fail;\n\t\t}\n\t}\n\n\t \n\tif (tcon->share_flags & SMB2_SHAREFLAG_NO_CACHING) {\n\t\tif (ctx->cache_ro)\n\t\t\tcifs_dbg(VFS, \"cache=ro requested on mount but NO_CACHING flag set on share\\n\");\n\t\telse if (ctx->cache_rw)\n\t\t\tcifs_dbg(VFS, \"cache=singleclient requested on mount but NO_CACHING flag set on share\\n\");\n\t}\n\n\tif (ctx->no_lease) {\n\t\tif (ses->server->vals->protocol_id == 0) {\n\t\t\tcifs_dbg(VFS,\n\t\t\t\t\"SMB2 or later required for nolease option\\n\");\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto out_fail;\n\t\t} else\n\t\t\ttcon->no_lease = ctx->no_lease;\n\t}\n\n\t \n\ttcon->retry = ctx->retry;\n\ttcon->nocase = ctx->nocase;\n\ttcon->broken_sparse_sup = ctx->no_sparse;\n\ttcon->max_cached_dirs = ctx->max_cached_dirs;\n\ttcon->nodelete = ctx->nodelete;\n\ttcon->local_lease = ctx->local_lease;\n\tINIT_LIST_HEAD(&tcon->pending_opens);\n\ttcon->status = TID_GOOD;\n\n\tINIT_DELAYED_WORK(&tcon->query_interfaces,\n\t\t\t  smb2_query_server_interfaces);\n\tif (ses->server->dialect >= SMB30_PROT_ID &&\n\t    (ses->server->capabilities & SMB2_GLOBAL_CAP_MULTI_CHANNEL)) {\n\t\t \n\t\tqueue_delayed_work(cifsiod_wq, &tcon->query_interfaces,\n\t\t\t\t   (SMB_INTERFACE_POLL_INTERVAL * HZ));\n\t}\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\tINIT_DELAYED_WORK(&tcon->dfs_cache_work, dfs_cache_refresh);\n#endif\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_add(&tcon->tcon_list, &ses->tcon_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\treturn tcon;\n\nout_fail:\n\ttconInfoFree(tcon);\n\treturn ERR_PTR(rc);\n}\n\nvoid\ncifs_put_tlink(struct tcon_link *tlink)\n{\n\tif (!tlink || IS_ERR(tlink))\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&tlink->tl_count) ||\n\t    test_bit(TCON_LINK_IN_TREE, &tlink->tl_flags)) {\n\t\ttlink->tl_time = jiffies;\n\t\treturn;\n\t}\n\n\tif (!IS_ERR(tlink_tcon(tlink)))\n\t\tcifs_put_tcon(tlink_tcon(tlink));\n\tkfree(tlink);\n\treturn;\n}\n\nstatic int\ncompare_mount_options(struct super_block *sb, struct cifs_mnt_data *mnt_data)\n{\n\tstruct cifs_sb_info *old = CIFS_SB(sb);\n\tstruct cifs_sb_info *new = mnt_data->cifs_sb;\n\tunsigned int oldflags = old->mnt_cifs_flags & CIFS_MOUNT_MASK;\n\tunsigned int newflags = new->mnt_cifs_flags & CIFS_MOUNT_MASK;\n\n\tif ((sb->s_flags & CIFS_MS_MASK) != (mnt_data->flags & CIFS_MS_MASK))\n\t\treturn 0;\n\n\tif (old->mnt_cifs_serverino_autodisabled)\n\t\tnewflags &= ~CIFS_MOUNT_SERVER_INUM;\n\n\tif (oldflags != newflags)\n\t\treturn 0;\n\n\t \n\tif (new->ctx->wsize && new->ctx->wsize < old->ctx->wsize)\n\t\treturn 0;\n\n\tif (new->ctx->rsize && new->ctx->rsize < old->ctx->rsize)\n\t\treturn 0;\n\n\tif (!uid_eq(old->ctx->linux_uid, new->ctx->linux_uid) ||\n\t    !gid_eq(old->ctx->linux_gid, new->ctx->linux_gid))\n\t\treturn 0;\n\n\tif (old->ctx->file_mode != new->ctx->file_mode ||\n\t    old->ctx->dir_mode != new->ctx->dir_mode)\n\t\treturn 0;\n\n\tif (strcmp(old->local_nls->charset, new->local_nls->charset))\n\t\treturn 0;\n\n\tif (old->ctx->acregmax != new->ctx->acregmax)\n\t\treturn 0;\n\tif (old->ctx->acdirmax != new->ctx->acdirmax)\n\t\treturn 0;\n\tif (old->ctx->closetimeo != new->ctx->closetimeo)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic int match_prepath(struct super_block *sb,\n\t\t\t struct cifs_tcon *tcon,\n\t\t\t struct cifs_mnt_data *mnt_data)\n{\n\tstruct smb3_fs_context *ctx = mnt_data->ctx;\n\tstruct cifs_sb_info *old = CIFS_SB(sb);\n\tstruct cifs_sb_info *new = mnt_data->cifs_sb;\n\tbool old_set = (old->mnt_cifs_flags & CIFS_MOUNT_USE_PREFIX_PATH) &&\n\t\told->prepath;\n\tbool new_set = (new->mnt_cifs_flags & CIFS_MOUNT_USE_PREFIX_PATH) &&\n\t\tnew->prepath;\n\n\tif (tcon->origin_fullpath &&\n\t    dfs_src_pathname_equal(tcon->origin_fullpath, ctx->source))\n\t\treturn 1;\n\n\tif (old_set && new_set && !strcmp(new->prepath, old->prepath))\n\t\treturn 1;\n\telse if (!old_set && !new_set)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nint\ncifs_match_super(struct super_block *sb, void *data)\n{\n\tstruct cifs_mnt_data *mnt_data = data;\n\tstruct smb3_fs_context *ctx;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct TCP_Server_Info *tcp_srv;\n\tstruct cifs_ses *ses;\n\tstruct cifs_tcon *tcon;\n\tstruct tcon_link *tlink;\n\tint rc = 0;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tcifs_sb = CIFS_SB(sb);\n\n\t \n\tif (CIFS_MOUNT_SHUTDOWN & cifs_sb->mnt_cifs_flags) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn 0;\n\t}\n\n\ttlink = cifs_get_tlink(cifs_sb_master_tlink(cifs_sb));\n\tif (IS_ERR_OR_NULL(tlink)) {\n\t\tpr_warn_once(\"%s: skip super matching due to bad tlink(%p)\\n\",\n\t\t\t     __func__, tlink);\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn 0;\n\t}\n\ttcon = tlink_tcon(tlink);\n\tses = tcon->ses;\n\ttcp_srv = ses->server;\n\n\tctx = mnt_data->ctx;\n\n\tspin_lock(&tcp_srv->srv_lock);\n\tspin_lock(&ses->ses_lock);\n\tspin_lock(&ses->chan_lock);\n\tspin_lock(&tcon->tc_lock);\n\tif (!match_server(tcp_srv, ctx, true) ||\n\t    !match_session(ses, ctx) ||\n\t    !match_tcon(tcon, ctx) ||\n\t    !match_prepath(sb, tcon, mnt_data)) {\n\t\trc = 0;\n\t\tgoto out;\n\t}\n\n\trc = compare_mount_options(sb, mnt_data);\nout:\n\tspin_unlock(&tcon->tc_lock);\n\tspin_unlock(&ses->chan_lock);\n\tspin_unlock(&ses->ses_lock);\n\tspin_unlock(&tcp_srv->srv_lock);\n\n\tspin_unlock(&cifs_tcp_ses_lock);\n\tcifs_put_tlink(tlink);\n\treturn rc;\n}\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\nstatic struct lock_class_key cifs_key[2];\nstatic struct lock_class_key cifs_slock_key[2];\n\nstatic inline void\ncifs_reclassify_socket4(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tBUG_ON(!sock_allow_reclassification(sk));\n\tsock_lock_init_class_and_name(sk, \"slock-AF_INET-CIFS\",\n\t\t&cifs_slock_key[0], \"sk_lock-AF_INET-CIFS\", &cifs_key[0]);\n}\n\nstatic inline void\ncifs_reclassify_socket6(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tBUG_ON(!sock_allow_reclassification(sk));\n\tsock_lock_init_class_and_name(sk, \"slock-AF_INET6-CIFS\",\n\t\t&cifs_slock_key[1], \"sk_lock-AF_INET6-CIFS\", &cifs_key[1]);\n}\n#else\nstatic inline void\ncifs_reclassify_socket4(struct socket *sock)\n{\n}\n\nstatic inline void\ncifs_reclassify_socket6(struct socket *sock)\n{\n}\n#endif\n\n \nstatic void rfc1002mangle(char *target, char *source, unsigned int length)\n{\n\tunsigned int i, j;\n\n\tfor (i = 0, j = 0; i < (length); i++) {\n\t\t \n\t\ttarget[j] = 'A' + (0x0F & (source[i] >> 4));\n\t\ttarget[j+1] = 'A' + (0x0F & source[i]);\n\t\tj += 2;\n\t}\n\n}\n\nstatic int\nbind_socket(struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\tif (server->srcaddr.ss_family != AF_UNSPEC) {\n\t\t \n\t\tstruct socket *socket = server->ssocket;\n\t\trc = kernel_bind(socket,\n\t\t\t\t (struct sockaddr *) &server->srcaddr,\n\t\t\t\t sizeof(server->srcaddr));\n\t\tif (rc < 0) {\n\t\t\tstruct sockaddr_in *saddr4;\n\t\t\tstruct sockaddr_in6 *saddr6;\n\t\t\tsaddr4 = (struct sockaddr_in *)&server->srcaddr;\n\t\t\tsaddr6 = (struct sockaddr_in6 *)&server->srcaddr;\n\t\t\tif (saddr6->sin6_family == AF_INET6)\n\t\t\t\tcifs_server_dbg(VFS, \"Failed to bind to: %pI6c, error: %d\\n\",\n\t\t\t\t\t &saddr6->sin6_addr, rc);\n\t\t\telse\n\t\t\t\tcifs_server_dbg(VFS, \"Failed to bind to: %pI4, error: %d\\n\",\n\t\t\t\t\t &saddr4->sin_addr.s_addr, rc);\n\t\t}\n\t}\n\treturn rc;\n}\n\nstatic int\nip_rfc1001_connect(struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\t \n\tstruct rfc1002_session_packet req = {};\n\tstruct smb_hdr *smb_buf = (struct smb_hdr *)&req;\n\tunsigned int len;\n\n\treq.trailer.session_req.called_len = sizeof(req.trailer.session_req.called_name);\n\n\tif (server->server_RFC1001_name[0] != 0)\n\t\trfc1002mangle(req.trailer.session_req.called_name,\n\t\t\t      server->server_RFC1001_name,\n\t\t\t      RFC1001_NAME_LEN_WITH_NULL);\n\telse\n\t\trfc1002mangle(req.trailer.session_req.called_name,\n\t\t\t      DEFAULT_CIFS_CALLED_NAME,\n\t\t\t      RFC1001_NAME_LEN_WITH_NULL);\n\n\treq.trailer.session_req.calling_len = sizeof(req.trailer.session_req.calling_name);\n\n\t \n\tif (server->workstation_RFC1001_name[0] != 0)\n\t\trfc1002mangle(req.trailer.session_req.calling_name,\n\t\t\t      server->workstation_RFC1001_name,\n\t\t\t      RFC1001_NAME_LEN_WITH_NULL);\n\telse\n\t\trfc1002mangle(req.trailer.session_req.calling_name,\n\t\t\t      \"LINUX_CIFS_CLNT\",\n\t\t\t      RFC1001_NAME_LEN_WITH_NULL);\n\n\t \n\tlen = sizeof(req) - offsetof(struct rfc1002_session_packet, trailer.session_req);\n\n\tsmb_buf->smb_buf_length = cpu_to_be32((RFC1002_SESSION_REQUEST << 24) | len);\n\trc = smb_send(server, smb_buf, len);\n\t \n\tusleep_range(1000, 2000);\n\n\treturn rc;\n}\n\nstatic int\ngeneric_ip_connect(struct TCP_Server_Info *server)\n{\n\tstruct sockaddr *saddr;\n\tstruct socket *socket;\n\tint slen, sfamily;\n\t__be16 sport;\n\tint rc = 0;\n\n\tsaddr = (struct sockaddr *) &server->dstaddr;\n\n\tif (server->dstaddr.ss_family == AF_INET6) {\n\t\tstruct sockaddr_in6 *ipv6 = (struct sockaddr_in6 *)&server->dstaddr;\n\n\t\tsport = ipv6->sin6_port;\n\t\tslen = sizeof(struct sockaddr_in6);\n\t\tsfamily = AF_INET6;\n\t\tcifs_dbg(FYI, \"%s: connecting to [%pI6]:%d\\n\", __func__, &ipv6->sin6_addr,\n\t\t\t\tntohs(sport));\n\t} else {\n\t\tstruct sockaddr_in *ipv4 = (struct sockaddr_in *)&server->dstaddr;\n\n\t\tsport = ipv4->sin_port;\n\t\tslen = sizeof(struct sockaddr_in);\n\t\tsfamily = AF_INET;\n\t\tcifs_dbg(FYI, \"%s: connecting to %pI4:%d\\n\", __func__, &ipv4->sin_addr,\n\t\t\t\tntohs(sport));\n\t}\n\n\tif (server->ssocket) {\n\t\tsocket = server->ssocket;\n\t} else {\n\t\trc = __sock_create(cifs_net_ns(server), sfamily, SOCK_STREAM,\n\t\t\t\t   IPPROTO_TCP, &server->ssocket, 1);\n\t\tif (rc < 0) {\n\t\t\tcifs_server_dbg(VFS, \"Error %d creating socket\\n\", rc);\n\t\t\treturn rc;\n\t\t}\n\n\t\t \n\t\tcifs_dbg(FYI, \"Socket created\\n\");\n\t\tsocket = server->ssocket;\n\t\tsocket->sk->sk_allocation = GFP_NOFS;\n\t\tsocket->sk->sk_use_task_frag = false;\n\t\tif (sfamily == AF_INET6)\n\t\t\tcifs_reclassify_socket6(socket);\n\t\telse\n\t\t\tcifs_reclassify_socket4(socket);\n\t}\n\n\trc = bind_socket(server);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\tsocket->sk->sk_rcvtimeo = 7 * HZ;\n\tsocket->sk->sk_sndtimeo = 5 * HZ;\n\n\t \n\tif (server->noautotune) {\n\t\tif (socket->sk->sk_sndbuf < (200 * 1024))\n\t\t\tsocket->sk->sk_sndbuf = 200 * 1024;\n\t\tif (socket->sk->sk_rcvbuf < (140 * 1024))\n\t\t\tsocket->sk->sk_rcvbuf = 140 * 1024;\n\t}\n\n\tif (server->tcp_nodelay)\n\t\ttcp_sock_set_nodelay(socket->sk);\n\n\tcifs_dbg(FYI, \"sndbuf %d rcvbuf %d rcvtimeo 0x%lx\\n\",\n\t\t socket->sk->sk_sndbuf,\n\t\t socket->sk->sk_rcvbuf, socket->sk->sk_rcvtimeo);\n\n\trc = kernel_connect(socket, saddr, slen,\n\t\t\t    server->noblockcnt ? O_NONBLOCK : 0);\n\t \n\tif (server->noblockcnt && rc == -EINPROGRESS)\n\t\trc = 0;\n\tif (rc < 0) {\n\t\tcifs_dbg(FYI, \"Error %d connecting to server\\n\", rc);\n\t\ttrace_smb3_connect_err(server->hostname, server->conn_id, &server->dstaddr, rc);\n\t\tsock_release(socket);\n\t\tserver->ssocket = NULL;\n\t\treturn rc;\n\t}\n\ttrace_smb3_connect_done(server->hostname, server->conn_id, &server->dstaddr);\n\tif (sport == htons(RFC1001_PORT))\n\t\trc = ip_rfc1001_connect(server);\n\n\treturn rc;\n}\n\nstatic int\nip_connect(struct TCP_Server_Info *server)\n{\n\t__be16 *sport;\n\tstruct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)&server->dstaddr;\n\tstruct sockaddr_in *addr = (struct sockaddr_in *)&server->dstaddr;\n\n\tif (server->dstaddr.ss_family == AF_INET6)\n\t\tsport = &addr6->sin6_port;\n\telse\n\t\tsport = &addr->sin_port;\n\n\tif (*sport == 0) {\n\t\tint rc;\n\n\t\t \n\t\t*sport = htons(CIFS_PORT);\n\n\t\trc = generic_ip_connect(server);\n\t\tif (rc >= 0)\n\t\t\treturn rc;\n\n\t\t \n\t\t*sport = htons(RFC1001_PORT);\n\t}\n\n\treturn generic_ip_connect(server);\n}\n\n#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY\nvoid reset_cifs_unix_caps(unsigned int xid, struct cifs_tcon *tcon,\n\t\t\t  struct cifs_sb_info *cifs_sb, struct smb3_fs_context *ctx)\n{\n\t \n\t__u64 saved_cap = le64_to_cpu(tcon->fsUnixInfo.Capability);\n\n\tif (ctx && ctx->no_linux_ext) {\n\t\ttcon->fsUnixInfo.Capability = 0;\n\t\ttcon->unix_ext = 0;  \n\t\tcifs_dbg(FYI, \"Linux protocol extensions disabled\\n\");\n\t\treturn;\n\t} else if (ctx)\n\t\ttcon->unix_ext = 1;  \n\n\tif (!tcon->unix_ext) {\n\t\tcifs_dbg(FYI, \"Unix extensions disabled so not set on reconnect\\n\");\n\t\treturn;\n\t}\n\n\tif (!CIFSSMBQFSUnixInfo(xid, tcon)) {\n\t\t__u64 cap = le64_to_cpu(tcon->fsUnixInfo.Capability);\n\t\tcifs_dbg(FYI, \"unix caps which server supports %lld\\n\", cap);\n\t\t \n\t\tif (ctx == NULL) {\n\t\t\t \n\t\t\tif ((saved_cap & CIFS_UNIX_POSIX_ACL_CAP) == 0)\n\t\t\t\tcap &= ~CIFS_UNIX_POSIX_ACL_CAP;\n\t\t\tif ((saved_cap & CIFS_UNIX_POSIX_PATHNAMES_CAP) == 0) {\n\t\t\t\tif (cap & CIFS_UNIX_POSIX_PATHNAMES_CAP)\n\t\t\t\t\tcifs_dbg(VFS, \"POSIXPATH support change\\n\");\n\t\t\t\tcap &= ~CIFS_UNIX_POSIX_PATHNAMES_CAP;\n\t\t\t} else if ((cap & CIFS_UNIX_POSIX_PATHNAMES_CAP) == 0) {\n\t\t\t\tcifs_dbg(VFS, \"possible reconnect error\\n\");\n\t\t\t\tcifs_dbg(VFS, \"server disabled POSIX path support\\n\");\n\t\t\t}\n\t\t}\n\n\t\tif (cap & CIFS_UNIX_TRANSPORT_ENCRYPTION_MANDATORY_CAP)\n\t\t\tcifs_dbg(VFS, \"per-share encryption not supported yet\\n\");\n\n\t\tcap &= CIFS_UNIX_CAP_MASK;\n\t\tif (ctx && ctx->no_psx_acl)\n\t\t\tcap &= ~CIFS_UNIX_POSIX_ACL_CAP;\n\t\telse if (CIFS_UNIX_POSIX_ACL_CAP & cap) {\n\t\t\tcifs_dbg(FYI, \"negotiated posix acl support\\n\");\n\t\t\tif (cifs_sb)\n\t\t\t\tcifs_sb->mnt_cifs_flags |=\n\t\t\t\t\tCIFS_MOUNT_POSIXACL;\n\t\t}\n\n\t\tif (ctx && ctx->posix_paths == 0)\n\t\t\tcap &= ~CIFS_UNIX_POSIX_PATHNAMES_CAP;\n\t\telse if (cap & CIFS_UNIX_POSIX_PATHNAMES_CAP) {\n\t\t\tcifs_dbg(FYI, \"negotiate posix pathnames\\n\");\n\t\t\tif (cifs_sb)\n\t\t\t\tcifs_sb->mnt_cifs_flags |=\n\t\t\t\t\tCIFS_MOUNT_POSIX_PATHS;\n\t\t}\n\n\t\tcifs_dbg(FYI, \"Negotiate caps 0x%x\\n\", (int)cap);\n#ifdef CONFIG_CIFS_DEBUG2\n\t\tif (cap & CIFS_UNIX_FCNTL_CAP)\n\t\t\tcifs_dbg(FYI, \"FCNTL cap\\n\");\n\t\tif (cap & CIFS_UNIX_EXTATTR_CAP)\n\t\t\tcifs_dbg(FYI, \"EXTATTR cap\\n\");\n\t\tif (cap & CIFS_UNIX_POSIX_PATHNAMES_CAP)\n\t\t\tcifs_dbg(FYI, \"POSIX path cap\\n\");\n\t\tif (cap & CIFS_UNIX_XATTR_CAP)\n\t\t\tcifs_dbg(FYI, \"XATTR cap\\n\");\n\t\tif (cap & CIFS_UNIX_POSIX_ACL_CAP)\n\t\t\tcifs_dbg(FYI, \"POSIX ACL cap\\n\");\n\t\tif (cap & CIFS_UNIX_LARGE_READ_CAP)\n\t\t\tcifs_dbg(FYI, \"very large read cap\\n\");\n\t\tif (cap & CIFS_UNIX_LARGE_WRITE_CAP)\n\t\t\tcifs_dbg(FYI, \"very large write cap\\n\");\n\t\tif (cap & CIFS_UNIX_TRANSPORT_ENCRYPTION_CAP)\n\t\t\tcifs_dbg(FYI, \"transport encryption cap\\n\");\n\t\tif (cap & CIFS_UNIX_TRANSPORT_ENCRYPTION_MANDATORY_CAP)\n\t\t\tcifs_dbg(FYI, \"mandatory transport encryption cap\\n\");\n#endif  \n\t\tif (CIFSSMBSetFSUnixInfo(xid, tcon, cap)) {\n\t\t\tif (ctx == NULL)\n\t\t\t\tcifs_dbg(FYI, \"resetting capabilities failed\\n\");\n\t\t\telse\n\t\t\t\tcifs_dbg(VFS, \"Negotiating Unix capabilities with the server failed. Consider mounting with the Unix Extensions disabled if problems are found by specifying the nounix mount option.\\n\");\n\n\t\t}\n\t}\n}\n#endif  \n\nint cifs_setup_cifs_sb(struct cifs_sb_info *cifs_sb)\n{\n\tstruct smb3_fs_context *ctx = cifs_sb->ctx;\n\n\tINIT_DELAYED_WORK(&cifs_sb->prune_tlinks, cifs_prune_tlinks);\n\n\tspin_lock_init(&cifs_sb->tlink_tree_lock);\n\tcifs_sb->tlink_tree = RB_ROOT;\n\n\tcifs_dbg(FYI, \"file mode: %04ho  dir mode: %04ho\\n\",\n\t\t ctx->file_mode, ctx->dir_mode);\n\n\t \n\tif (ctx->iocharset == NULL) {\n\t\t \n\t\tcifs_sb->local_nls = load_nls_default();\n\t} else {\n\t\tcifs_sb->local_nls = load_nls(ctx->iocharset);\n\t\tif (cifs_sb->local_nls == NULL) {\n\t\t\tcifs_dbg(VFS, \"CIFS mount error: iocharset %s not found\\n\",\n\t\t\t\t ctx->iocharset);\n\t\t\treturn -ELIBACC;\n\t\t}\n\t}\n\tctx->local_nls = cifs_sb->local_nls;\n\n\tsmb3_update_mnt_flags(cifs_sb);\n\n\tif (ctx->direct_io)\n\t\tcifs_dbg(FYI, \"mounting share using direct i/o\\n\");\n\tif (ctx->cache_ro) {\n\t\tcifs_dbg(VFS, \"mounting share with read only caching. Ensure that the share will not be modified while in use.\\n\");\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_RO_CACHE;\n\t} else if (ctx->cache_rw) {\n\t\tcifs_dbg(VFS, \"mounting share in single client RW caching mode. Ensure that no other systems will be accessing the share.\\n\");\n\t\tcifs_sb->mnt_cifs_flags |= (CIFS_MOUNT_RO_CACHE |\n\t\t\t\t\t    CIFS_MOUNT_RW_CACHE);\n\t}\n\n\tif ((ctx->cifs_acl) && (ctx->dynperm))\n\t\tcifs_dbg(VFS, \"mount option dynperm ignored if cifsacl mount option supported\\n\");\n\n\tif (ctx->prepath) {\n\t\tcifs_sb->prepath = kstrdup(ctx->prepath, GFP_KERNEL);\n\t\tif (cifs_sb->prepath == NULL)\n\t\t\treturn -ENOMEM;\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_USE_PREFIX_PATH;\n\t}\n\n\treturn 0;\n}\n\n \nvoid cifs_mount_put_conns(struct cifs_mount_ctx *mnt_ctx)\n{\n\tint rc = 0;\n\n\tif (mnt_ctx->tcon)\n\t\tcifs_put_tcon(mnt_ctx->tcon);\n\telse if (mnt_ctx->ses)\n\t\tcifs_put_smb_ses(mnt_ctx->ses);\n\telse if (mnt_ctx->server)\n\t\tcifs_put_tcp_session(mnt_ctx->server, 0);\n\tmnt_ctx->cifs_sb->mnt_cifs_flags &= ~CIFS_MOUNT_POSIX_PATHS;\n\tfree_xid(mnt_ctx->xid);\n}\n\nint cifs_mount_get_session(struct cifs_mount_ctx *mnt_ctx)\n{\n\tstruct TCP_Server_Info *server = NULL;\n\tstruct smb3_fs_context *ctx;\n\tstruct cifs_ses *ses = NULL;\n\tunsigned int xid;\n\tint rc = 0;\n\n\txid = get_xid();\n\n\tif (WARN_ON_ONCE(!mnt_ctx || !mnt_ctx->fs_ctx)) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tctx = mnt_ctx->fs_ctx;\n\n\t \n\tserver = cifs_get_tcp_session(ctx, NULL);\n\tif (IS_ERR(server)) {\n\t\trc = PTR_ERR(server);\n\t\tserver = NULL;\n\t\tgoto out;\n\t}\n\n\t \n\tses = cifs_get_smb_ses(server, ctx);\n\tif (IS_ERR(ses)) {\n\t\trc = PTR_ERR(ses);\n\t\tses = NULL;\n\t\tgoto out;\n\t}\n\n\tif ((ctx->persistent == true) && (!(ses->server->capabilities &\n\t\t\t\t\t    SMB2_GLOBAL_CAP_PERSISTENT_HANDLES))) {\n\t\tcifs_server_dbg(VFS, \"persistent handles not supported by server\\n\");\n\t\trc = -EOPNOTSUPP;\n\t}\n\nout:\n\tmnt_ctx->xid = xid;\n\tmnt_ctx->server = server;\n\tmnt_ctx->ses = ses;\n\tmnt_ctx->tcon = NULL;\n\n\treturn rc;\n}\n\nint cifs_mount_get_tcon(struct cifs_mount_ctx *mnt_ctx)\n{\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct smb3_fs_context *ctx;\n\tstruct cifs_tcon *tcon = NULL;\n\tint rc = 0;\n\n\tif (WARN_ON_ONCE(!mnt_ctx || !mnt_ctx->server || !mnt_ctx->ses || !mnt_ctx->fs_ctx ||\n\t\t\t !mnt_ctx->cifs_sb)) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tserver = mnt_ctx->server;\n\tctx = mnt_ctx->fs_ctx;\n\tcifs_sb = mnt_ctx->cifs_sb;\n\n\t \n\ttcon = cifs_get_tcon(mnt_ctx->ses, ctx);\n\tif (IS_ERR(tcon)) {\n\t\trc = PTR_ERR(tcon);\n\t\ttcon = NULL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (tcon->posix_extensions)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_POSIX_PATHS;\n\n#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY\n\t \n\tif (cap_unix(tcon->ses)) {\n\t\t \n\t\treset_cifs_unix_caps(mnt_ctx->xid, tcon, cifs_sb, ctx);\n\t\tspin_lock(&tcon->ses->server->srv_lock);\n\t\tif ((tcon->ses->server->tcpStatus == CifsNeedReconnect) &&\n\t\t    (le64_to_cpu(tcon->fsUnixInfo.Capability) &\n\t\t     CIFS_UNIX_TRANSPORT_ENCRYPTION_MANDATORY_CAP)) {\n\t\t\tspin_unlock(&tcon->ses->server->srv_lock);\n\t\t\trc = -EACCES;\n\t\t\tgoto out;\n\t\t}\n\t\tspin_unlock(&tcon->ses->server->srv_lock);\n\t} else\n#endif  \n\t\ttcon->unix_ext = 0;  \n\n\t \n\tif (!tcon->pipe && server->ops->qfs_tcon) {\n\t\tserver->ops->qfs_tcon(mnt_ctx->xid, tcon, cifs_sb);\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_RO_CACHE) {\n\t\t\tif (tcon->fsDevInfo.DeviceCharacteristics &\n\t\t\t    cpu_to_le32(FILE_READ_ONLY_DEVICE))\n\t\t\t\tcifs_dbg(VFS, \"mounted to read only share\\n\");\n\t\t\telse if ((cifs_sb->mnt_cifs_flags &\n\t\t\t\t  CIFS_MOUNT_RW_CACHE) == 0)\n\t\t\t\tcifs_dbg(VFS, \"read only mount of RW share\\n\");\n\t\t\t \n\t\t}\n\t}\n\n\t \n\tif ((cifs_sb->ctx->wsize == 0) ||\n\t    (cifs_sb->ctx->wsize > server->ops->negotiate_wsize(tcon, ctx)))\n\t\tcifs_sb->ctx->wsize = server->ops->negotiate_wsize(tcon, ctx);\n\tif ((cifs_sb->ctx->rsize == 0) ||\n\t    (cifs_sb->ctx->rsize > server->ops->negotiate_rsize(tcon, ctx)))\n\t\tcifs_sb->ctx->rsize = server->ops->negotiate_rsize(tcon, ctx);\n\n\t \n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_FSCACHE)\n\t\tcifs_fscache_get_super_cookie(tcon);\n\nout:\n\tmnt_ctx->tcon = tcon;\n\treturn rc;\n}\n\nstatic int mount_setup_tlink(struct cifs_sb_info *cifs_sb, struct cifs_ses *ses,\n\t\t\t     struct cifs_tcon *tcon)\n{\n\tstruct tcon_link *tlink;\n\n\t \n\ttlink = kzalloc(sizeof(*tlink), GFP_KERNEL);\n\tif (tlink == NULL)\n\t\treturn -ENOMEM;\n\n\ttlink->tl_uid = ses->linux_uid;\n\ttlink->tl_tcon = tcon;\n\ttlink->tl_time = jiffies;\n\tset_bit(TCON_LINK_MASTER, &tlink->tl_flags);\n\tset_bit(TCON_LINK_IN_TREE, &tlink->tl_flags);\n\n\tcifs_sb->master_tlink = tlink;\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tqueue_delayed_work(cifsiod_wq, &cifs_sb->prune_tlinks,\n\t\t\t\tTLINK_IDLE_EXPIRE);\n\treturn 0;\n}\n\nstatic int\ncifs_are_all_path_components_accessible(struct TCP_Server_Info *server,\n\t\t\t\t\tunsigned int xid,\n\t\t\t\t\tstruct cifs_tcon *tcon,\n\t\t\t\t\tstruct cifs_sb_info *cifs_sb,\n\t\t\t\t\tchar *full_path,\n\t\t\t\t\tint added_treename)\n{\n\tint rc;\n\tchar *s;\n\tchar sep, tmp;\n\tint skip = added_treename ? 1 : 0;\n\n\tsep = CIFS_DIR_SEP(cifs_sb);\n\ts = full_path;\n\n\trc = server->ops->is_path_accessible(xid, tcon, cifs_sb, \"\");\n\twhile (rc == 0) {\n\t\t \n\t\twhile (*s == sep)\n\t\t\ts++;\n\t\tif (!*s)\n\t\t\tbreak;\n\t\t \n\t\twhile (*s && *s != sep)\n\t\t\ts++;\n\t\t \n\t\tif (skip) {\n\t\t\tskip = 0;\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\ttmp = *s;\n\t\t*s = 0;\n\t\trc = server->ops->is_path_accessible(xid, tcon, cifs_sb,\n\t\t\t\t\t\t     full_path);\n\t\t*s = tmp;\n\t}\n\treturn rc;\n}\n\n \nint cifs_is_path_remote(struct cifs_mount_ctx *mnt_ctx)\n{\n\tint rc;\n\tstruct cifs_sb_info *cifs_sb = mnt_ctx->cifs_sb;\n\tstruct TCP_Server_Info *server = mnt_ctx->server;\n\tunsigned int xid = mnt_ctx->xid;\n\tstruct cifs_tcon *tcon = mnt_ctx->tcon;\n\tstruct smb3_fs_context *ctx = mnt_ctx->fs_ctx;\n\tchar *full_path;\n\n\tif (!server->ops->is_path_accessible)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tfull_path = cifs_build_path_to_root(ctx, cifs_sb, tcon,\n\t\t\t\t\t    tcon->Flags & SMB_SHARE_IS_IN_DFS);\n\tif (full_path == NULL)\n\t\treturn -ENOMEM;\n\n\tcifs_dbg(FYI, \"%s: full_path: %s\\n\", __func__, full_path);\n\n\trc = server->ops->is_path_accessible(xid, tcon, cifs_sb,\n\t\t\t\t\t     full_path);\n\tif (rc != 0 && rc != -EREMOTE)\n\t\tgoto out;\n\n\tif (rc != -EREMOTE) {\n\t\trc = cifs_are_all_path_components_accessible(server, xid, tcon,\n\t\t\tcifs_sb, full_path, tcon->Flags & SMB_SHARE_IS_IN_DFS);\n\t\tif (rc != 0) {\n\t\t\tcifs_server_dbg(VFS, \"cannot query dirs between root and final path, enabling CIFS_MOUNT_USE_PREFIX_PATH\\n\");\n\t\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_USE_PREFIX_PATH;\n\t\t\trc = 0;\n\t\t}\n\t}\n\nout:\n\tkfree(full_path);\n\treturn rc;\n}\n\n#ifdef CONFIG_CIFS_DFS_UPCALL\nint cifs_mount(struct cifs_sb_info *cifs_sb, struct smb3_fs_context *ctx)\n{\n\tstruct cifs_mount_ctx mnt_ctx = { .cifs_sb = cifs_sb, .fs_ctx = ctx, };\n\tbool isdfs;\n\tint rc;\n\n\tINIT_LIST_HEAD(&mnt_ctx.dfs_ses_list);\n\n\trc = dfs_mount_share(&mnt_ctx, &isdfs);\n\tif (rc)\n\t\tgoto error;\n\tif (!isdfs)\n\t\tgoto out;\n\n\t \n\tcifs_autodisable_serverino(cifs_sb);\n\t \n\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_USE_PREFIX_PATH;\n\tkfree(cifs_sb->prepath);\n\tcifs_sb->prepath = ctx->prepath;\n\tctx->prepath = NULL;\n\nout:\n\tcifs_try_adding_channels(mnt_ctx.ses);\n\trc = mount_setup_tlink(cifs_sb, mnt_ctx.ses, mnt_ctx.tcon);\n\tif (rc)\n\t\tgoto error;\n\n\tfree_xid(mnt_ctx.xid);\n\treturn rc;\n\nerror:\n\tdfs_put_root_smb_sessions(&mnt_ctx.dfs_ses_list);\n\tcifs_mount_put_conns(&mnt_ctx);\n\treturn rc;\n}\n#else\nint cifs_mount(struct cifs_sb_info *cifs_sb, struct smb3_fs_context *ctx)\n{\n\tint rc = 0;\n\tstruct cifs_mount_ctx mnt_ctx = { .cifs_sb = cifs_sb, .fs_ctx = ctx, };\n\n\trc = cifs_mount_get_session(&mnt_ctx);\n\tif (rc)\n\t\tgoto error;\n\n\trc = cifs_mount_get_tcon(&mnt_ctx);\n\tif (rc)\n\t\tgoto error;\n\n\trc = cifs_is_path_remote(&mnt_ctx);\n\tif (rc == -EREMOTE)\n\t\trc = -EOPNOTSUPP;\n\tif (rc)\n\t\tgoto error;\n\n\trc = mount_setup_tlink(cifs_sb, mnt_ctx.ses, mnt_ctx.tcon);\n\tif (rc)\n\t\tgoto error;\n\n\tfree_xid(mnt_ctx.xid);\n\treturn rc;\n\nerror:\n\tcifs_mount_put_conns(&mnt_ctx);\n\treturn rc;\n}\n#endif\n\n \nint\nCIFSTCon(const unsigned int xid, struct cifs_ses *ses,\n\t const char *tree, struct cifs_tcon *tcon,\n\t const struct nls_table *nls_codepage)\n{\n\tstruct smb_hdr *smb_buffer;\n\tstruct smb_hdr *smb_buffer_response;\n\tTCONX_REQ *pSMB;\n\tTCONX_RSP *pSMBr;\n\tunsigned char *bcc_ptr;\n\tint rc = 0;\n\tint length;\n\t__u16 bytes_left, count;\n\n\tif (ses == NULL)\n\t\treturn -EIO;\n\n\tsmb_buffer = cifs_buf_get();\n\tif (smb_buffer == NULL)\n\t\treturn -ENOMEM;\n\n\tsmb_buffer_response = smb_buffer;\n\n\theader_assemble(smb_buffer, SMB_COM_TREE_CONNECT_ANDX,\n\t\t\tNULL   , 4   );\n\n\tsmb_buffer->Mid = get_next_mid(ses->server);\n\tsmb_buffer->Uid = ses->Suid;\n\tpSMB = (TCONX_REQ *) smb_buffer;\n\tpSMBr = (TCONX_RSP *) smb_buffer_response;\n\n\tpSMB->AndXCommand = 0xFF;\n\tpSMB->Flags = cpu_to_le16(TCON_EXTENDED_SECINFO);\n\tbcc_ptr = &pSMB->Password[0];\n\n\tpSMB->PasswordLength = cpu_to_le16(1);\t \n\t*bcc_ptr = 0;  \n\tbcc_ptr++;               \n\t \n\n\tif (ses->server->sign)\n\t\tsmb_buffer->Flags2 |= SMBFLG2_SECURITY_SIGNATURE;\n\n\tif (ses->capabilities & CAP_STATUS32) {\n\t\tsmb_buffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\t}\n\tif (ses->capabilities & CAP_DFS) {\n\t\tsmb_buffer->Flags2 |= SMBFLG2_DFS;\n\t}\n\tif (ses->capabilities & CAP_UNICODE) {\n\t\tsmb_buffer->Flags2 |= SMBFLG2_UNICODE;\n\t\tlength =\n\t\t    cifs_strtoUTF16((__le16 *) bcc_ptr, tree,\n\t\t\t6   *\n\t\t\t(  + 256  ), nls_codepage);\n\t\tbcc_ptr += 2 * length;\t \n\t\tbcc_ptr += 2;\t \n\t} else {\t\t \n\t\tstrcpy(bcc_ptr, tree);\n\t\tbcc_ptr += strlen(tree) + 1;\n\t}\n\tstrcpy(bcc_ptr, \"?????\");\n\tbcc_ptr += strlen(\"?????\");\n\tbcc_ptr += 1;\n\tcount = bcc_ptr - &pSMB->Password[0];\n\tbe32_add_cpu(&pSMB->hdr.smb_buf_length, count);\n\tpSMB->ByteCount = cpu_to_le16(count);\n\n\trc = SendReceive(xid, ses, smb_buffer, smb_buffer_response, &length,\n\t\t\t 0);\n\n\t \n\tif (rc == 0) {\n\t\tbool is_unicode;\n\n\t\ttcon->tid = smb_buffer_response->Tid;\n\t\tbcc_ptr = pByteArea(smb_buffer_response);\n\t\tbytes_left = get_bcc(smb_buffer_response);\n\t\tlength = strnlen(bcc_ptr, bytes_left - 2);\n\t\tif (smb_buffer->Flags2 & SMBFLG2_UNICODE)\n\t\t\tis_unicode = true;\n\t\telse\n\t\t\tis_unicode = false;\n\n\n\t\t \n\t\tif (length == 3) {\n\t\t\tif ((bcc_ptr[0] == 'I') && (bcc_ptr[1] == 'P') &&\n\t\t\t    (bcc_ptr[2] == 'C')) {\n\t\t\t\tcifs_dbg(FYI, \"IPC connection\\n\");\n\t\t\t\ttcon->ipc = true;\n\t\t\t\ttcon->pipe = true;\n\t\t\t}\n\t\t} else if (length == 2) {\n\t\t\tif ((bcc_ptr[0] == 'A') && (bcc_ptr[1] == ':')) {\n\t\t\t\t \n\t\t\t\tcifs_dbg(FYI, \"disk share connection\\n\");\n\t\t\t}\n\t\t}\n\t\tbcc_ptr += length + 1;\n\t\tbytes_left -= (length + 1);\n\t\tstrscpy(tcon->tree_name, tree, sizeof(tcon->tree_name));\n\n\t\t \n\t\tkfree(tcon->nativeFileSystem);\n\t\ttcon->nativeFileSystem = cifs_strndup_from_utf16(bcc_ptr,\n\t\t\t\t\t\t      bytes_left, is_unicode,\n\t\t\t\t\t\t      nls_codepage);\n\n\t\tcifs_dbg(FYI, \"nativeFileSystem=%s\\n\", tcon->nativeFileSystem);\n\n\t\tif ((smb_buffer_response->WordCount == 3) ||\n\t\t\t (smb_buffer_response->WordCount == 7))\n\t\t\t \n\t\t\ttcon->Flags = le16_to_cpu(pSMBr->OptionalSupport);\n\t\telse\n\t\t\ttcon->Flags = 0;\n\t\tcifs_dbg(FYI, \"Tcon flags: 0x%x\\n\", tcon->Flags);\n\t}\n\n\tcifs_buf_release(smb_buffer);\n\treturn rc;\n}\n\nstatic void delayed_free(struct rcu_head *p)\n{\n\tstruct cifs_sb_info *cifs_sb = container_of(p, struct cifs_sb_info, rcu);\n\n\tunload_nls(cifs_sb->local_nls);\n\tsmb3_cleanup_fs_context(cifs_sb->ctx);\n\tkfree(cifs_sb);\n}\n\nvoid\ncifs_umount(struct cifs_sb_info *cifs_sb)\n{\n\tstruct rb_root *root = &cifs_sb->tlink_tree;\n\tstruct rb_node *node;\n\tstruct tcon_link *tlink;\n\n\tcancel_delayed_work_sync(&cifs_sb->prune_tlinks);\n\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\twhile ((node = rb_first(root))) {\n\t\ttlink = rb_entry(node, struct tcon_link, tl_rbnode);\n\t\tcifs_get_tlink(tlink);\n\t\tclear_bit(TCON_LINK_IN_TREE, &tlink->tl_flags);\n\t\trb_erase(node, root);\n\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\tcifs_put_tlink(tlink);\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t}\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tkfree(cifs_sb->prepath);\n\tcall_rcu(&cifs_sb->rcu, delayed_free);\n}\n\nint\ncifs_negotiate_protocol(const unsigned int xid, struct cifs_ses *ses,\n\t\t\tstruct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\n\tif (!server->ops->need_neg || !server->ops->negotiate)\n\t\treturn -ENOSYS;\n\n\t \n\tspin_lock(&server->srv_lock);\n\tif (server->tcpStatus != CifsGood &&\n\t    server->tcpStatus != CifsNew &&\n\t    server->tcpStatus != CifsNeedNegotiate) {\n\t\tspin_unlock(&server->srv_lock);\n\t\treturn -EHOSTDOWN;\n\t}\n\n\tif (!server->ops->need_neg(server) &&\n\t    server->tcpStatus == CifsGood) {\n\t\tspin_unlock(&server->srv_lock);\n\t\treturn 0;\n\t}\n\n\tserver->tcpStatus = CifsInNegotiate;\n\tspin_unlock(&server->srv_lock);\n\n\trc = server->ops->negotiate(xid, ses, server);\n\tif (rc == 0) {\n\t\tspin_lock(&server->srv_lock);\n\t\tif (server->tcpStatus == CifsInNegotiate)\n\t\t\tserver->tcpStatus = CifsGood;\n\t\telse\n\t\t\trc = -EHOSTDOWN;\n\t\tspin_unlock(&server->srv_lock);\n\t} else {\n\t\tspin_lock(&server->srv_lock);\n\t\tif (server->tcpStatus == CifsInNegotiate)\n\t\t\tserver->tcpStatus = CifsNeedNegotiate;\n\t\tspin_unlock(&server->srv_lock);\n\t}\n\n\treturn rc;\n}\n\nint\ncifs_setup_session(const unsigned int xid, struct cifs_ses *ses,\n\t\t   struct TCP_Server_Info *server,\n\t\t   struct nls_table *nls_info)\n{\n\tint rc = -ENOSYS;\n\tstruct TCP_Server_Info *pserver = SERVER_IS_CHAN(server) ? server->primary_server : server;\n\tstruct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)&pserver->dstaddr;\n\tstruct sockaddr_in *addr = (struct sockaddr_in *)&pserver->dstaddr;\n\tbool is_binding = false;\n\n\tspin_lock(&ses->ses_lock);\n\tcifs_dbg(FYI, \"%s: channel connect bitmap: 0x%lx\\n\",\n\t\t __func__, ses->chans_need_reconnect);\n\n\tif (ses->ses_status != SES_GOOD &&\n\t    ses->ses_status != SES_NEW &&\n\t    ses->ses_status != SES_NEED_RECON) {\n\t\tspin_unlock(&ses->ses_lock);\n\t\treturn -EHOSTDOWN;\n\t}\n\n\t \n\tspin_lock(&ses->chan_lock);\n\tif (CIFS_ALL_CHANS_GOOD(ses)) {\n\t\tif (ses->ses_status == SES_NEED_RECON)\n\t\t\tses->ses_status = SES_GOOD;\n\t\tspin_unlock(&ses->chan_lock);\n\t\tspin_unlock(&ses->ses_lock);\n\t\treturn 0;\n\t}\n\n\tcifs_chan_set_in_reconnect(ses, server);\n\tis_binding = !CIFS_ALL_CHANS_NEED_RECONNECT(ses);\n\tspin_unlock(&ses->chan_lock);\n\n\tif (!is_binding) {\n\t\tses->ses_status = SES_IN_SETUP;\n\n\t\t \n\t\tses->iface_last_update = 0;\n\t}\n\tspin_unlock(&ses->ses_lock);\n\n\t \n\tif (server == pserver) {\n\t\tif (server->dstaddr.ss_family == AF_INET6)\n\t\t\tscnprintf(ses->ip_addr, sizeof(ses->ip_addr), \"%pI6\", &addr6->sin6_addr);\n\t\telse\n\t\t\tscnprintf(ses->ip_addr, sizeof(ses->ip_addr), \"%pI4\", &addr->sin_addr);\n\t}\n\n\tif (!is_binding) {\n\t\tses->capabilities = server->capabilities;\n\t\tif (!linuxExtEnabled)\n\t\t\tses->capabilities &= (~server->vals->cap_unix);\n\n\t\tif (ses->auth_key.response) {\n\t\t\tcifs_dbg(FYI, \"Free previous auth_key.response = %p\\n\",\n\t\t\t\t ses->auth_key.response);\n\t\t\tkfree_sensitive(ses->auth_key.response);\n\t\t\tses->auth_key.response = NULL;\n\t\t\tses->auth_key.len = 0;\n\t\t}\n\t}\n\n\tcifs_dbg(FYI, \"Security Mode: 0x%x Capabilities: 0x%x TimeAdjust: %d\\n\",\n\t\t server->sec_mode, server->capabilities, server->timeAdj);\n\n\tif (server->ops->sess_setup)\n\t\trc = server->ops->sess_setup(xid, ses, server, nls_info);\n\n\tif (rc) {\n\t\tcifs_server_dbg(VFS, \"Send error in SessSetup = %d\\n\", rc);\n\t\tspin_lock(&ses->ses_lock);\n\t\tif (ses->ses_status == SES_IN_SETUP)\n\t\t\tses->ses_status = SES_NEED_RECON;\n\t\tspin_lock(&ses->chan_lock);\n\t\tcifs_chan_clear_in_reconnect(ses, server);\n\t\tspin_unlock(&ses->chan_lock);\n\t\tspin_unlock(&ses->ses_lock);\n\t} else {\n\t\tspin_lock(&ses->ses_lock);\n\t\tif (ses->ses_status == SES_IN_SETUP)\n\t\t\tses->ses_status = SES_GOOD;\n\t\tspin_lock(&ses->chan_lock);\n\t\tcifs_chan_clear_in_reconnect(ses, server);\n\t\tcifs_chan_clear_need_reconnect(ses, server);\n\t\tspin_unlock(&ses->chan_lock);\n\t\tspin_unlock(&ses->ses_lock);\n\t}\n\n\treturn rc;\n}\n\nstatic int\ncifs_set_vol_auth(struct smb3_fs_context *ctx, struct cifs_ses *ses)\n{\n\tctx->sectype = ses->sectype;\n\n\t \n\tif (ctx->sectype == Kerberos)\n\t\treturn 0;\n\n\treturn cifs_set_cifscreds(ctx, ses);\n}\n\nstatic struct cifs_tcon *\ncifs_construct_tcon(struct cifs_sb_info *cifs_sb, kuid_t fsuid)\n{\n\tint rc;\n\tstruct cifs_tcon *master_tcon = cifs_sb_master_tcon(cifs_sb);\n\tstruct cifs_ses *ses;\n\tstruct cifs_tcon *tcon = NULL;\n\tstruct smb3_fs_context *ctx;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (ctx == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tctx->local_nls = cifs_sb->local_nls;\n\tctx->linux_uid = fsuid;\n\tctx->cred_uid = fsuid;\n\tctx->UNC = master_tcon->tree_name;\n\tctx->retry = master_tcon->retry;\n\tctx->nocase = master_tcon->nocase;\n\tctx->nohandlecache = master_tcon->nohandlecache;\n\tctx->local_lease = master_tcon->local_lease;\n\tctx->no_lease = master_tcon->no_lease;\n\tctx->resilient = master_tcon->use_resilient;\n\tctx->persistent = master_tcon->use_persistent;\n\tctx->handle_timeout = master_tcon->handle_timeout;\n\tctx->no_linux_ext = !master_tcon->unix_ext;\n\tctx->linux_ext = master_tcon->posix_extensions;\n\tctx->sectype = master_tcon->ses->sectype;\n\tctx->sign = master_tcon->ses->sign;\n\tctx->seal = master_tcon->seal;\n\tctx->witness = master_tcon->use_witness;\n\n\trc = cifs_set_vol_auth(ctx, master_tcon->ses);\n\tif (rc) {\n\t\ttcon = ERR_PTR(rc);\n\t\tgoto out;\n\t}\n\n\t \n\tspin_lock(&cifs_tcp_ses_lock);\n\t++master_tcon->ses->server->srv_count;\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tses = cifs_get_smb_ses(master_tcon->ses->server, ctx);\n\tif (IS_ERR(ses)) {\n\t\ttcon = (struct cifs_tcon *)ses;\n\t\tcifs_put_tcp_session(master_tcon->ses->server, 0);\n\t\tgoto out;\n\t}\n\n\ttcon = cifs_get_tcon(ses, ctx);\n\tif (IS_ERR(tcon)) {\n\t\tcifs_put_smb_ses(ses);\n\t\tgoto out;\n\t}\n\n#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY\n\tif (cap_unix(ses))\n\t\treset_cifs_unix_caps(0, tcon, NULL, ctx);\n#endif  \n\nout:\n\tkfree(ctx->username);\n\tkfree_sensitive(ctx->password);\n\tkfree(ctx);\n\n\treturn tcon;\n}\n\nstruct cifs_tcon *\ncifs_sb_master_tcon(struct cifs_sb_info *cifs_sb)\n{\n\treturn tlink_tcon(cifs_sb_master_tlink(cifs_sb));\n}\n\n \nstatic struct tcon_link *\ntlink_rb_search(struct rb_root *root, kuid_t uid)\n{\n\tstruct rb_node *node = root->rb_node;\n\tstruct tcon_link *tlink;\n\n\twhile (node) {\n\t\ttlink = rb_entry(node, struct tcon_link, tl_rbnode);\n\n\t\tif (uid_gt(tlink->tl_uid, uid))\n\t\t\tnode = node->rb_left;\n\t\telse if (uid_lt(tlink->tl_uid, uid))\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn tlink;\n\t}\n\treturn NULL;\n}\n\n \nstatic void\ntlink_rb_insert(struct rb_root *root, struct tcon_link *new_tlink)\n{\n\tstruct rb_node **new = &(root->rb_node), *parent = NULL;\n\tstruct tcon_link *tlink;\n\n\twhile (*new) {\n\t\ttlink = rb_entry(*new, struct tcon_link, tl_rbnode);\n\t\tparent = *new;\n\n\t\tif (uid_gt(tlink->tl_uid, new_tlink->tl_uid))\n\t\t\tnew = &((*new)->rb_left);\n\t\telse\n\t\t\tnew = &((*new)->rb_right);\n\t}\n\n\trb_link_node(&new_tlink->tl_rbnode, parent, new);\n\trb_insert_color(&new_tlink->tl_rbnode, root);\n}\n\n \nstruct tcon_link *\ncifs_sb_tlink(struct cifs_sb_info *cifs_sb)\n{\n\tint ret;\n\tkuid_t fsuid = current_fsuid();\n\tstruct tcon_link *tlink, *newtlink;\n\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\treturn cifs_get_tlink(cifs_sb_master_tlink(cifs_sb));\n\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\tif (tlink)\n\t\tcifs_get_tlink(tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tif (tlink == NULL) {\n\t\tnewtlink = kzalloc(sizeof(*tlink), GFP_KERNEL);\n\t\tif (newtlink == NULL)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tnewtlink->tl_uid = fsuid;\n\t\tnewtlink->tl_tcon = ERR_PTR(-EACCES);\n\t\tset_bit(TCON_LINK_PENDING, &newtlink->tl_flags);\n\t\tset_bit(TCON_LINK_IN_TREE, &newtlink->tl_flags);\n\t\tcifs_get_tlink(newtlink);\n\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t\t \n\t\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\t\tif (tlink) {\n\t\t\tcifs_get_tlink(tlink);\n\t\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\t\tkfree(newtlink);\n\t\t\tgoto wait_for_construction;\n\t\t}\n\t\ttlink = newtlink;\n\t\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t} else {\nwait_for_construction:\n\t\tret = wait_on_bit(&tlink->tl_flags, TCON_LINK_PENDING,\n\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (ret) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-ERESTARTSYS);\n\t\t}\n\n\t\t \n\t\tif (!IS_ERR(tlink->tl_tcon))\n\t\t\treturn tlink;\n\n\t\t \n\t\tif (time_before(jiffies, tlink->tl_time + TLINK_ERROR_EXPIRE)) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-EACCES);\n\t\t}\n\n\t\tif (test_and_set_bit(TCON_LINK_PENDING, &tlink->tl_flags))\n\t\t\tgoto wait_for_construction;\n\t}\n\n\ttlink->tl_tcon = cifs_construct_tcon(cifs_sb, fsuid);\n\tclear_bit(TCON_LINK_PENDING, &tlink->tl_flags);\n\twake_up_bit(&tlink->tl_flags, TCON_LINK_PENDING);\n\n\tif (IS_ERR(tlink->tl_tcon)) {\n\t\tcifs_put_tlink(tlink);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn tlink;\n}\n\n \nstatic void\ncifs_prune_tlinks(struct work_struct *work)\n{\n\tstruct cifs_sb_info *cifs_sb = container_of(work, struct cifs_sb_info,\n\t\t\t\t\t\t    prune_tlinks.work);\n\tstruct rb_root *root = &cifs_sb->tlink_tree;\n\tstruct rb_node *node;\n\tstruct rb_node *tmp;\n\tstruct tcon_link *tlink;\n\n\t \n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\tnode = rb_first(root);\n\twhile (node != NULL) {\n\t\ttmp = node;\n\t\tnode = rb_next(tmp);\n\t\ttlink = rb_entry(tmp, struct tcon_link, tl_rbnode);\n\n\t\tif (test_bit(TCON_LINK_MASTER, &tlink->tl_flags) ||\n\t\t    atomic_read(&tlink->tl_count) != 0 ||\n\t\t    time_after(tlink->tl_time + TLINK_IDLE_EXPIRE, jiffies))\n\t\t\tcontinue;\n\n\t\tcifs_get_tlink(tlink);\n\t\tclear_bit(TCON_LINK_IN_TREE, &tlink->tl_flags);\n\t\trb_erase(tmp, root);\n\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\tcifs_put_tlink(tlink);\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t}\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tqueue_delayed_work(cifsiod_wq, &cifs_sb->prune_tlinks,\n\t\t\t\tTLINK_IDLE_EXPIRE);\n}\n\n#ifndef CONFIG_CIFS_DFS_UPCALL\nint cifs_tree_connect(const unsigned int xid, struct cifs_tcon *tcon, const struct nls_table *nlsc)\n{\n\tint rc;\n\tconst struct smb_version_operations *ops = tcon->ses->server->ops;\n\n\t \n\tspin_lock(&tcon->tc_lock);\n\tif (tcon->status == TID_GOOD) {\n\t\tspin_unlock(&tcon->tc_lock);\n\t\treturn 0;\n\t}\n\n\tif (tcon->status != TID_NEW &&\n\t    tcon->status != TID_NEED_TCON) {\n\t\tspin_unlock(&tcon->tc_lock);\n\t\treturn -EHOSTDOWN;\n\t}\n\n\ttcon->status = TID_IN_TCON;\n\tspin_unlock(&tcon->tc_lock);\n\n\trc = ops->tree_connect(xid, tcon->ses, tcon->tree_name, tcon, nlsc);\n\tif (rc) {\n\t\tspin_lock(&tcon->tc_lock);\n\t\tif (tcon->status == TID_IN_TCON)\n\t\t\ttcon->status = TID_NEED_TCON;\n\t\tspin_unlock(&tcon->tc_lock);\n\t} else {\n\t\tspin_lock(&tcon->tc_lock);\n\t\tif (tcon->status == TID_IN_TCON)\n\t\t\ttcon->status = TID_GOOD;\n\t\ttcon->need_reconnect = false;\n\t\tspin_unlock(&tcon->tc_lock);\n\t}\n\n\treturn rc;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}