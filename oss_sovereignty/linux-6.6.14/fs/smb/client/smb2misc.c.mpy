{
  "module_name": "smb2misc.c",
  "hash_id": "3370439db8ef7dd0e28a1f0f11b3500da45c07b8c0445b4bce9fd8a367fe95b6",
  "original_prompt": "Ingested from linux-6.6.14/fs/smb/client/smb2misc.c",
  "human_readable_source": "\n \n#include <linux/ctype.h>\n#include \"cifsglob.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2status.h\"\n#include \"smb2glob.h\"\n#include \"nterr.h\"\n#include \"cached_dir.h\"\n\nstatic int\ncheck_smb2_hdr(struct smb2_hdr *shdr, __u64 mid)\n{\n\t__u64 wire_mid = le64_to_cpu(shdr->MessageId);\n\n\t \n\tif ((shdr->ProtocolId == SMB2_PROTO_NUMBER) &&\n\t    (mid == wire_mid)) {\n\t\tif (shdr->Flags & SMB2_FLAGS_SERVER_TO_REDIR)\n\t\t\treturn 0;\n\t\telse {\n\t\t\t \n\t\t\tif (shdr->Command == SMB2_OPLOCK_BREAK)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\tcifs_dbg(VFS, \"Received Request not response\\n\");\n\t\t}\n\t} else {  \n\t\tif (shdr->ProtocolId != SMB2_PROTO_NUMBER)\n\t\t\tcifs_dbg(VFS, \"Bad protocol string signature header %x\\n\",\n\t\t\t\t le32_to_cpu(shdr->ProtocolId));\n\t\tif (mid != wire_mid)\n\t\t\tcifs_dbg(VFS, \"Mids do not match: %llu and %llu\\n\",\n\t\t\t\t mid, wire_mid);\n\t}\n\tcifs_dbg(VFS, \"Bad SMB detected. The Mid=%llu\\n\", wire_mid);\n\treturn 1;\n}\n\n \nstatic const __le16 smb2_rsp_struct_sizes[NUMBER_OF_SMB2_COMMANDS] = {\n\t  cpu_to_le16(65),\n\t  cpu_to_le16(9),\n\t  cpu_to_le16(4),\n\t  cpu_to_le16(16),\n\t  cpu_to_le16(4),\n\t  cpu_to_le16(89),\n\t  cpu_to_le16(60),\n\t  cpu_to_le16(4),\n\t  cpu_to_le16(17),\n\t  cpu_to_le16(17),\n\t  cpu_to_le16(4),\n\t  cpu_to_le16(49),\n\t \n\t  cpu_to_le16(0),\n\t  cpu_to_le16(4),\n\t  cpu_to_le16(9),\n\t  cpu_to_le16(9),\n\t  cpu_to_le16(9),\n\t  cpu_to_le16(2),\n\t \n\t  cpu_to_le16(24)\n};\n\n#define SMB311_NEGPROT_BASE_SIZE (sizeof(struct smb2_hdr) + sizeof(struct smb2_negotiate_rsp))\n\nstatic __u32 get_neg_ctxt_len(struct smb2_hdr *hdr, __u32 len,\n\t\t\t      __u32 non_ctxlen)\n{\n\t__u16 neg_count;\n\t__u32 nc_offset, size_of_pad_before_neg_ctxts;\n\tstruct smb2_negotiate_rsp *pneg_rsp = (struct smb2_negotiate_rsp *)hdr;\n\n\t \n\tneg_count = le16_to_cpu(pneg_rsp->NegotiateContextCount);\n\tif ((neg_count == 0) ||\n\t   (pneg_rsp->DialectRevision != cpu_to_le16(SMB311_PROT_ID)))\n\t\treturn 0;\n\n\t \n\tnc_offset = le32_to_cpu(pneg_rsp->NegotiateContextOffset);\n\t \n\tif (nc_offset + 1 < non_ctxlen) {\n\t\tpr_warn_once(\"Invalid negotiate context offset %d\\n\", nc_offset);\n\t\treturn 0;\n\t} else if (nc_offset + 1 == non_ctxlen) {\n\t\tcifs_dbg(FYI, \"no SPNEGO security blob in negprot rsp\\n\");\n\t\tsize_of_pad_before_neg_ctxts = 0;\n\t} else if (non_ctxlen == SMB311_NEGPROT_BASE_SIZE + 1)\n\t\t \n\t\tsize_of_pad_before_neg_ctxts = nc_offset - non_ctxlen + 1;\n\telse\n\t\tsize_of_pad_before_neg_ctxts = nc_offset - non_ctxlen;\n\n\t \n\tif (len < nc_offset + (neg_count * sizeof(struct smb2_neg_context))) {\n\t\tpr_warn_once(\"negotiate context goes beyond end\\n\");\n\t\treturn 0;\n\t}\n\n\tcifs_dbg(FYI, \"length of negcontexts %d pad %d\\n\",\n\t\tlen - nc_offset, size_of_pad_before_neg_ctxts);\n\n\t \n\treturn (len - nc_offset) + size_of_pad_before_neg_ctxts;\n}\n\nint\nsmb2_check_message(char *buf, unsigned int len, struct TCP_Server_Info *server)\n{\n\tstruct TCP_Server_Info *pserver;\n\tstruct smb2_hdr *shdr = (struct smb2_hdr *)buf;\n\tstruct smb2_pdu *pdu = (struct smb2_pdu *)shdr;\n\tint hdr_size = sizeof(struct smb2_hdr);\n\tint pdu_size = sizeof(struct smb2_pdu);\n\tint command;\n\t__u32 calc_len;  \n\t__u64 mid;\n\n\t \n\tpserver = SERVER_IS_CHAN(server) ? server->primary_server : server;\n\n\t \n\tif (shdr->ProtocolId == SMB2_TRANSFORM_PROTO_NUM) {\n\t\tstruct smb2_transform_hdr *thdr =\n\t\t\t(struct smb2_transform_hdr *)buf;\n\t\tstruct cifs_ses *ses = NULL;\n\t\tstruct cifs_ses *iter;\n\n\t\t \n\t\tspin_lock(&cifs_tcp_ses_lock);\n\t\tlist_for_each_entry(iter, &pserver->smb_ses_list, smb_ses_list) {\n\t\t\tif (iter->Suid == le64_to_cpu(thdr->SessionId)) {\n\t\t\t\tses = iter;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\tif (!ses) {\n\t\t\tcifs_dbg(VFS, \"no decryption - session id not found\\n\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tmid = le64_to_cpu(shdr->MessageId);\n\tif (check_smb2_hdr(shdr, mid))\n\t\treturn 1;\n\n\tif (shdr->StructureSize != SMB2_HEADER_STRUCTURE_SIZE) {\n\t\tcifs_dbg(VFS, \"Invalid structure size %u\\n\",\n\t\t\t le16_to_cpu(shdr->StructureSize));\n\t\treturn 1;\n\t}\n\n\tcommand = le16_to_cpu(shdr->Command);\n\tif (command >= NUMBER_OF_SMB2_COMMANDS) {\n\t\tcifs_dbg(VFS, \"Invalid SMB2 command %d\\n\", command);\n\t\treturn 1;\n\t}\n\n\tif (len < pdu_size) {\n\t\tif ((len >= hdr_size)\n\t\t    && (shdr->Status != 0)) {\n\t\t\tpdu->StructureSize2 = 0;\n\t\t\t \n\t\t\treturn 0;\n\t\t} else {\n\t\t\tcifs_dbg(VFS, \"Length less than SMB header size\\n\");\n\t\t}\n\t\treturn 1;\n\t}\n\tif (len > CIFSMaxBufSize + MAX_SMB2_HDR_SIZE) {\n\t\tcifs_dbg(VFS, \"SMB length greater than maximum, mid=%llu\\n\",\n\t\t\t mid);\n\t\treturn 1;\n\t}\n\n\tif (smb2_rsp_struct_sizes[command] != pdu->StructureSize2) {\n\t\tif (command != SMB2_OPLOCK_BREAK_HE && (shdr->Status == 0 ||\n\t\t    pdu->StructureSize2 != SMB2_ERROR_STRUCTURE_SIZE2_LE)) {\n\t\t\t \n\t\t\tcifs_dbg(VFS, \"Invalid response size %u for command %d\\n\",\n\t\t\t\t le16_to_cpu(pdu->StructureSize2), command);\n\t\t\treturn 1;\n\t\t} else if (command == SMB2_OPLOCK_BREAK_HE\n\t\t\t   && (shdr->Status == 0)\n\t\t\t   && (le16_to_cpu(pdu->StructureSize2) != 44)\n\t\t\t   && (le16_to_cpu(pdu->StructureSize2) != 36)) {\n\t\t\t \n\t\t\tcifs_dbg(VFS, \"Invalid response size %d for oplock break\\n\",\n\t\t\t\t le16_to_cpu(pdu->StructureSize2));\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tcalc_len = smb2_calc_size(buf);\n\n\t \n\tif (command == SMB2_IOCTL_HE && calc_len == 0)\n\t\treturn 0;\n\n\tif (command == SMB2_NEGOTIATE_HE)\n\t\tcalc_len += get_neg_ctxt_len(shdr, len, calc_len);\n\n\tif (len != calc_len) {\n\t\t \n\t\tif (command == SMB2_CREATE_HE &&\n\t\t    shdr->Status == STATUS_STOPPED_ON_SYMLINK)\n\t\t\treturn 0;\n\t\t \n\t\tif (calc_len + 24 == len && command == SMB2_OPLOCK_BREAK_HE)\n\t\t\treturn 0;\n\t\t \n\t\tif (calc_len == len + 1)\n\t\t\treturn 0;\n\n\t\t \n\t\tif (ALIGN(calc_len, 8) == len)\n\t\t\treturn 0;\n\n\t\t \n\t\tif (calc_len < len)\n\t\t\treturn 0;\n\n\t\t \n\t\tif (unlikely(cifsFYI))\n\t\t\tcifs_dbg(FYI, \"Server response too short: calculated \"\n\t\t\t\t \"length %u doesn't match read length %u (cmd=%d, mid=%llu)\\n\",\n\t\t\t\t calc_len, len, command, mid);\n\t\telse\n\t\t\tpr_warn(\"Server response too short: calculated length \"\n\t\t\t\t\"%u doesn't match read length %u (cmd=%d, mid=%llu)\\n\",\n\t\t\t\tcalc_len, len, command, mid);\n\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \nstatic const bool has_smb2_data_area[NUMBER_OF_SMB2_COMMANDS] = {\n\t  true,\n\t  true,\n\t  false,\n\t \tfalse,\n\t  false,\n\t  true,\n\t  false,\n\t  false,\n\t \ttrue,\n\t  false,\n\t \tfalse,\n\t  true,\n\t  false,  \n\t  false,\n\t  true,\n\t  true,\n\t  true,\n\t  false,\n\t  false\n};\n\n \nchar *\nsmb2_get_data_area_len(int *off, int *len, struct smb2_hdr *shdr)\n{\n\tconst int max_off = 4096;\n\tconst int max_len = 128 * 1024;\n\n\t*off = 0;\n\t*len = 0;\n\n\t \n\tif (shdr->Status && shdr->Status != STATUS_MORE_PROCESSING_REQUIRED &&\n\t    (((struct smb2_err_rsp *)shdr)->StructureSize) ==\n\t\t\t\t\t\tSMB2_ERROR_STRUCTURE_SIZE2_LE)\n\t\treturn NULL;\n\n\t \n\tswitch (shdr->Command) {\n\tcase SMB2_NEGOTIATE:\n\t\t*off = le16_to_cpu(\n\t\t  ((struct smb2_negotiate_rsp *)shdr)->SecurityBufferOffset);\n\t\t*len = le16_to_cpu(\n\t\t  ((struct smb2_negotiate_rsp *)shdr)->SecurityBufferLength);\n\t\tbreak;\n\tcase SMB2_SESSION_SETUP:\n\t\t*off = le16_to_cpu(\n\t\t  ((struct smb2_sess_setup_rsp *)shdr)->SecurityBufferOffset);\n\t\t*len = le16_to_cpu(\n\t\t  ((struct smb2_sess_setup_rsp *)shdr)->SecurityBufferLength);\n\t\tbreak;\n\tcase SMB2_CREATE:\n\t\t*off = le32_to_cpu(\n\t\t    ((struct smb2_create_rsp *)shdr)->CreateContextsOffset);\n\t\t*len = le32_to_cpu(\n\t\t    ((struct smb2_create_rsp *)shdr)->CreateContextsLength);\n\t\tbreak;\n\tcase SMB2_QUERY_INFO:\n\t\t*off = le16_to_cpu(\n\t\t    ((struct smb2_query_info_rsp *)shdr)->OutputBufferOffset);\n\t\t*len = le32_to_cpu(\n\t\t    ((struct smb2_query_info_rsp *)shdr)->OutputBufferLength);\n\t\tbreak;\n\tcase SMB2_READ:\n\t\t \n\t\t*off = ((struct smb2_read_rsp *)shdr)->DataOffset;\n\t\t*len = le32_to_cpu(((struct smb2_read_rsp *)shdr)->DataLength);\n\t\tbreak;\n\tcase SMB2_QUERY_DIRECTORY:\n\t\t*off = le16_to_cpu(\n\t\t  ((struct smb2_query_directory_rsp *)shdr)->OutputBufferOffset);\n\t\t*len = le32_to_cpu(\n\t\t  ((struct smb2_query_directory_rsp *)shdr)->OutputBufferLength);\n\t\tbreak;\n\tcase SMB2_IOCTL:\n\t\t*off = le32_to_cpu(\n\t\t  ((struct smb2_ioctl_rsp *)shdr)->OutputOffset);\n\t\t*len = le32_to_cpu(\n\t\t  ((struct smb2_ioctl_rsp *)shdr)->OutputCount);\n\t\tbreak;\n\tcase SMB2_CHANGE_NOTIFY:\n\t\t*off = le16_to_cpu(\n\t\t  ((struct smb2_change_notify_rsp *)shdr)->OutputBufferOffset);\n\t\t*len = le32_to_cpu(\n\t\t  ((struct smb2_change_notify_rsp *)shdr)->OutputBufferLength);\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"no length check for command %d\\n\", le16_to_cpu(shdr->Command));\n\t\tbreak;\n\t}\n\n\t \n\tif (unlikely(*off < 0 || *off > max_off ||\n\t\t     *len < 0 || *len > max_len)) {\n\t\tcifs_dbg(VFS, \"%s: invalid data area (off=%d len=%d)\\n\",\n\t\t\t __func__, *off, *len);\n\t\t*off = 0;\n\t\t*len = 0;\n\t} else if (*off == 0) {\n\t\t*len = 0;\n\t}\n\n\t \n\tif (*off > 0 && *len > 0)\n\t\treturn (char *)shdr + *off;\n\treturn NULL;\n}\n\n \nunsigned int\nsmb2_calc_size(void *buf)\n{\n\tstruct smb2_pdu *pdu = buf;\n\tstruct smb2_hdr *shdr = &pdu->hdr;\n\tint offset;  \n\tint data_length;  \n\t \n\tint len = le16_to_cpu(shdr->StructureSize);\n\n\t \n\tlen += le16_to_cpu(pdu->StructureSize2);\n\n\tif (has_smb2_data_area[le16_to_cpu(shdr->Command)] == false)\n\t\tgoto calc_size_exit;\n\n\tsmb2_get_data_area_len(&offset, &data_length, shdr);\n\tcifs_dbg(FYI, \"SMB2 data length %d offset %d\\n\", data_length, offset);\n\n\tif (data_length > 0) {\n\t\t \n\t\tif (offset + 1 < len) {\n\t\t\tcifs_dbg(VFS, \"data area offset %d overlaps SMB2 header %d\\n\",\n\t\t\t\t offset + 1, len);\n\t\t\tdata_length = 0;\n\t\t} else {\n\t\t\tlen = offset + data_length;\n\t\t}\n\t}\ncalc_size_exit:\n\tcifs_dbg(FYI, \"SMB2 len %d\\n\", len);\n\treturn len;\n}\n\n \n__le16 *\ncifs_convert_path_to_utf16(const char *from, struct cifs_sb_info *cifs_sb)\n{\n\tint len;\n\tconst char *start_of_path;\n\t__le16 *to;\n\tint map_type;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SFM_CHR)\n\t\tmap_type = SFM_MAP_UNI_RSVD;\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\n\t\tmap_type = SFU_MAP_UNI_RSVD;\n\telse\n\t\tmap_type = NO_MAP_UNI_RSVD;\n\n\t \n\tif (from[0] == '\\\\')\n\t\tstart_of_path = from + 1;\n\n\t \n\telse if (cifs_sb_master_tlink(cifs_sb) &&\n\t\t cifs_sb_master_tcon(cifs_sb)->posix_extensions &&\n\t\t (from[0] == '/')) {\n\t\tstart_of_path = from + 1;\n\t} else\n\t\tstart_of_path = from;\n\n\tto = cifs_strndup_to_utf16(start_of_path, PATH_MAX, &len,\n\t\t\t\t   cifs_sb->local_nls, map_type);\n\treturn to;\n}\n\n__le32\nsmb2_get_lease_state(struct cifsInodeInfo *cinode)\n{\n\t__le32 lease = 0;\n\n\tif (CIFS_CACHE_WRITE(cinode))\n\t\tlease |= SMB2_LEASE_WRITE_CACHING_LE;\n\tif (CIFS_CACHE_HANDLE(cinode))\n\t\tlease |= SMB2_LEASE_HANDLE_CACHING_LE;\n\tif (CIFS_CACHE_READ(cinode))\n\t\tlease |= SMB2_LEASE_READ_CACHING_LE;\n\treturn lease;\n}\n\nstruct smb2_lease_break_work {\n\tstruct work_struct lease_break;\n\tstruct tcon_link *tlink;\n\t__u8 lease_key[16];\n\t__le32 lease_state;\n};\n\nstatic void\ncifs_ses_oplock_break(struct work_struct *work)\n{\n\tstruct smb2_lease_break_work *lw = container_of(work,\n\t\t\t\tstruct smb2_lease_break_work, lease_break);\n\tint rc = 0;\n\n\trc = SMB2_lease_break(0, tlink_tcon(lw->tlink), lw->lease_key,\n\t\t\t      lw->lease_state);\n\n\tcifs_dbg(FYI, \"Lease release rc %d\\n\", rc);\n\tcifs_put_tlink(lw->tlink);\n\tkfree(lw);\n}\n\nstatic void\nsmb2_queue_pending_open_break(struct tcon_link *tlink, __u8 *lease_key,\n\t\t\t      __le32 new_lease_state)\n{\n\tstruct smb2_lease_break_work *lw;\n\n\tlw = kmalloc(sizeof(struct smb2_lease_break_work), GFP_KERNEL);\n\tif (!lw) {\n\t\tcifs_put_tlink(tlink);\n\t\treturn;\n\t}\n\n\tINIT_WORK(&lw->lease_break, cifs_ses_oplock_break);\n\tlw->tlink = tlink;\n\tlw->lease_state = new_lease_state;\n\tmemcpy(lw->lease_key, lease_key, SMB2_LEASE_KEY_SIZE);\n\tqueue_work(cifsiod_wq, &lw->lease_break);\n}\n\nstatic bool\nsmb2_tcon_has_lease(struct cifs_tcon *tcon, struct smb2_lease_break *rsp)\n{\n\t__u8 lease_state;\n\tstruct cifsFileInfo *cfile;\n\tstruct cifsInodeInfo *cinode;\n\tint ack_req = le32_to_cpu(rsp->Flags &\n\t\t\t\t  SMB2_NOTIFY_BREAK_LEASE_FLAG_ACK_REQUIRED);\n\n\tlease_state = le32_to_cpu(rsp->NewLeaseState);\n\n\tlist_for_each_entry(cfile, &tcon->openFileList, tlist) {\n\t\tcinode = CIFS_I(d_inode(cfile->dentry));\n\n\t\tif (memcmp(cinode->lease_key, rsp->LeaseKey,\n\t\t\t\t\t\t\tSMB2_LEASE_KEY_SIZE))\n\t\t\tcontinue;\n\n\t\tcifs_dbg(FYI, \"found in the open list\\n\");\n\t\tcifs_dbg(FYI, \"lease key match, lease break 0x%x\\n\",\n\t\t\t lease_state);\n\n\t\tif (ack_req)\n\t\t\tcfile->oplock_break_cancelled = false;\n\t\telse\n\t\t\tcfile->oplock_break_cancelled = true;\n\n\t\tset_bit(CIFS_INODE_PENDING_OPLOCK_BREAK, &cinode->flags);\n\n\t\tcfile->oplock_epoch = le16_to_cpu(rsp->Epoch);\n\t\tcfile->oplock_level = lease_state;\n\n\t\tcifs_queue_oplock_break(cfile);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic struct cifs_pending_open *\nsmb2_tcon_find_pending_open_lease(struct cifs_tcon *tcon,\n\t\t\t\t  struct smb2_lease_break *rsp)\n{\n\t__u8 lease_state = le32_to_cpu(rsp->NewLeaseState);\n\tint ack_req = le32_to_cpu(rsp->Flags &\n\t\t\t\t  SMB2_NOTIFY_BREAK_LEASE_FLAG_ACK_REQUIRED);\n\tstruct cifs_pending_open *open;\n\tstruct cifs_pending_open *found = NULL;\n\n\tlist_for_each_entry(open, &tcon->pending_opens, olist) {\n\t\tif (memcmp(open->lease_key, rsp->LeaseKey,\n\t\t\t   SMB2_LEASE_KEY_SIZE))\n\t\t\tcontinue;\n\n\t\tif (!found && ack_req) {\n\t\t\tfound = open;\n\t\t}\n\n\t\tcifs_dbg(FYI, \"found in the pending open list\\n\");\n\t\tcifs_dbg(FYI, \"lease key match, lease break 0x%x\\n\",\n\t\t\t lease_state);\n\n\t\topen->oplock = lease_state;\n\t}\n\n\treturn found;\n}\n\nstatic bool\nsmb2_is_valid_lease_break(char *buffer, struct TCP_Server_Info *server)\n{\n\tstruct smb2_lease_break *rsp = (struct smb2_lease_break *)buffer;\n\tstruct TCP_Server_Info *pserver;\n\tstruct cifs_ses *ses;\n\tstruct cifs_tcon *tcon;\n\tstruct cifs_pending_open *open;\n\n\tcifs_dbg(FYI, \"Checking for lease break\\n\");\n\n\t \n\tpserver = SERVER_IS_CHAN(server) ? server->primary_server : server;\n\n\t \n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each_entry(ses, &pserver->smb_ses_list, smb_ses_list) {\n\t\tlist_for_each_entry(tcon, &ses->tcon_list, tcon_list) {\n\t\t\tspin_lock(&tcon->open_file_lock);\n\t\t\tcifs_stats_inc(\n\t\t\t\t       &tcon->stats.cifs_stats.num_oplock_brks);\n\t\t\tif (smb2_tcon_has_lease(tcon, rsp)) {\n\t\t\t\tspin_unlock(&tcon->open_file_lock);\n\t\t\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\topen = smb2_tcon_find_pending_open_lease(tcon,\n\t\t\t\t\t\t\t\t rsp);\n\t\t\tif (open) {\n\t\t\t\t__u8 lease_key[SMB2_LEASE_KEY_SIZE];\n\t\t\t\tstruct tcon_link *tlink;\n\n\t\t\t\ttlink = cifs_get_tlink(open->tlink);\n\t\t\t\tmemcpy(lease_key, open->lease_key,\n\t\t\t\t       SMB2_LEASE_KEY_SIZE);\n\t\t\t\tspin_unlock(&tcon->open_file_lock);\n\t\t\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\t\t\tsmb2_queue_pending_open_break(tlink,\n\t\t\t\t\t\t\t      lease_key,\n\t\t\t\t\t\t\t      rsp->NewLeaseState);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tspin_unlock(&tcon->open_file_lock);\n\n\t\t\tif (cached_dir_lease_break(tcon, rsp->LeaseKey)) {\n\t\t\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\tcifs_dbg(FYI, \"Can not process lease break - no lease matched\\n\");\n\ttrace_smb3_lease_not_found(le32_to_cpu(rsp->CurrentLeaseState),\n\t\t\t\t   le32_to_cpu(rsp->hdr.Id.SyncId.TreeId),\n\t\t\t\t   le64_to_cpu(rsp->hdr.SessionId),\n\t\t\t\t   *((u64 *)rsp->LeaseKey),\n\t\t\t\t   *((u64 *)&rsp->LeaseKey[8]));\n\n\treturn false;\n}\n\nbool\nsmb2_is_valid_oplock_break(char *buffer, struct TCP_Server_Info *server)\n{\n\tstruct smb2_oplock_break *rsp = (struct smb2_oplock_break *)buffer;\n\tstruct TCP_Server_Info *pserver;\n\tstruct cifs_ses *ses;\n\tstruct cifs_tcon *tcon;\n\tstruct cifsInodeInfo *cinode;\n\tstruct cifsFileInfo *cfile;\n\n\tcifs_dbg(FYI, \"Checking for oplock break\\n\");\n\n\tif (rsp->hdr.Command != SMB2_OPLOCK_BREAK)\n\t\treturn false;\n\n\tif (rsp->StructureSize !=\n\t\t\t\tsmb2_rsp_struct_sizes[SMB2_OPLOCK_BREAK_HE]) {\n\t\tif (le16_to_cpu(rsp->StructureSize) == 44)\n\t\t\treturn smb2_is_valid_lease_break(buffer, server);\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tcifs_dbg(FYI, \"oplock level 0x%x\\n\", rsp->OplockLevel);\n\n\t \n\tpserver = SERVER_IS_CHAN(server) ? server->primary_server : server;\n\n\t \n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each_entry(ses, &pserver->smb_ses_list, smb_ses_list) {\n\t\tlist_for_each_entry(tcon, &ses->tcon_list, tcon_list) {\n\n\t\t\tspin_lock(&tcon->open_file_lock);\n\t\t\tlist_for_each_entry(cfile, &tcon->openFileList, tlist) {\n\t\t\t\tif (rsp->PersistentFid !=\n\t\t\t\t    cfile->fid.persistent_fid ||\n\t\t\t\t    rsp->VolatileFid !=\n\t\t\t\t    cfile->fid.volatile_fid)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tcifs_dbg(FYI, \"file id match, oplock break\\n\");\n\t\t\t\tcifs_stats_inc(\n\t\t\t\t    &tcon->stats.cifs_stats.num_oplock_brks);\n\t\t\t\tcinode = CIFS_I(d_inode(cfile->dentry));\n\t\t\t\tspin_lock(&cfile->file_info_lock);\n\t\t\t\tif (!CIFS_CACHE_WRITE(cinode) &&\n\t\t\t\t    rsp->OplockLevel == SMB2_OPLOCK_LEVEL_NONE)\n\t\t\t\t\tcfile->oplock_break_cancelled = true;\n\t\t\t\telse\n\t\t\t\t\tcfile->oplock_break_cancelled = false;\n\n\t\t\t\tset_bit(CIFS_INODE_PENDING_OPLOCK_BREAK,\n\t\t\t\t\t&cinode->flags);\n\n\t\t\t\tcfile->oplock_epoch = 0;\n\t\t\t\tcfile->oplock_level = rsp->OplockLevel;\n\n\t\t\t\tspin_unlock(&cfile->file_info_lock);\n\n\t\t\t\tcifs_queue_oplock_break(cfile);\n\n\t\t\t\tspin_unlock(&tcon->open_file_lock);\n\t\t\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tspin_unlock(&tcon->open_file_lock);\n\t\t}\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\tcifs_dbg(FYI, \"No file id matched, oplock break ignored\\n\");\n\ttrace_smb3_oplock_not_found(0  , rsp->PersistentFid,\n\t\t\t\t  le32_to_cpu(rsp->hdr.Id.SyncId.TreeId),\n\t\t\t\t  le64_to_cpu(rsp->hdr.SessionId));\n\n\treturn true;\n}\n\nvoid\nsmb2_cancelled_close_fid(struct work_struct *work)\n{\n\tstruct close_cancelled_open *cancelled = container_of(work,\n\t\t\t\t\tstruct close_cancelled_open, work);\n\tstruct cifs_tcon *tcon = cancelled->tcon;\n\tint rc;\n\n\tif (cancelled->mid)\n\t\tcifs_tcon_dbg(VFS, \"Close unmatched open for MID:%llu\\n\",\n\t\t\t      cancelled->mid);\n\telse\n\t\tcifs_tcon_dbg(VFS, \"Close interrupted close\\n\");\n\n\trc = SMB2_close(0, tcon, cancelled->fid.persistent_fid,\n\t\t\tcancelled->fid.volatile_fid);\n\tif (rc)\n\t\tcifs_tcon_dbg(VFS, \"Close cancelled mid failed rc:%d\\n\", rc);\n\n\tcifs_put_tcon(tcon);\n\tkfree(cancelled);\n}\n\n \nstatic int\n__smb2_handle_cancelled_cmd(struct cifs_tcon *tcon, __u16 cmd, __u64 mid,\n\t\t\t    __u64 persistent_fid, __u64 volatile_fid)\n{\n\tstruct close_cancelled_open *cancelled;\n\n\tcancelled = kzalloc(sizeof(*cancelled), GFP_KERNEL);\n\tif (!cancelled)\n\t\treturn -ENOMEM;\n\n\tcancelled->fid.persistent_fid = persistent_fid;\n\tcancelled->fid.volatile_fid = volatile_fid;\n\tcancelled->tcon = tcon;\n\tcancelled->cmd = cmd;\n\tcancelled->mid = mid;\n\tINIT_WORK(&cancelled->work, smb2_cancelled_close_fid);\n\tWARN_ON(queue_work(cifsiod_wq, &cancelled->work) == false);\n\n\treturn 0;\n}\n\nint\nsmb2_handle_cancelled_close(struct cifs_tcon *tcon, __u64 persistent_fid,\n\t\t\t    __u64 volatile_fid)\n{\n\tint rc;\n\n\tcifs_dbg(FYI, \"%s: tc_count=%d\\n\", __func__, tcon->tc_count);\n\tspin_lock(&cifs_tcp_ses_lock);\n\tif (tcon->tc_count <= 0) {\n\t\tstruct TCP_Server_Info *server = NULL;\n\n\t\tWARN_ONCE(tcon->tc_count < 0, \"tcon refcount is negative\");\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\n\t\tif (tcon->ses)\n\t\t\tserver = tcon->ses->server;\n\n\t\tcifs_server_dbg(FYI, \"tid=0x%x: tcon is closing, skipping async close retry of fid %llu %llu\\n\",\n\t\t\t\ttcon->tid, persistent_fid, volatile_fid);\n\n\t\treturn 0;\n\t}\n\ttcon->tc_count++;\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\trc = __smb2_handle_cancelled_cmd(tcon, SMB2_CLOSE_HE, 0,\n\t\t\t\t\t persistent_fid, volatile_fid);\n\tif (rc)\n\t\tcifs_put_tcon(tcon);\n\n\treturn rc;\n}\n\nint\nsmb2_handle_cancelled_mid(struct mid_q_entry *mid, struct TCP_Server_Info *server)\n{\n\tstruct smb2_hdr *hdr = mid->resp_buf;\n\tstruct smb2_create_rsp *rsp = mid->resp_buf;\n\tstruct cifs_tcon *tcon;\n\tint rc;\n\n\tif ((mid->optype & CIFS_CP_CREATE_CLOSE_OP) || hdr->Command != SMB2_CREATE ||\n\t    hdr->Status != STATUS_SUCCESS)\n\t\treturn 0;\n\n\ttcon = smb2_find_smb_tcon(server, le64_to_cpu(hdr->SessionId),\n\t\t\t\t  le32_to_cpu(hdr->Id.SyncId.TreeId));\n\tif (!tcon)\n\t\treturn -ENOENT;\n\n\trc = __smb2_handle_cancelled_cmd(tcon,\n\t\t\t\t\t le16_to_cpu(hdr->Command),\n\t\t\t\t\t le64_to_cpu(hdr->MessageId),\n\t\t\t\t\t rsp->PersistentFileId,\n\t\t\t\t\t rsp->VolatileFileId);\n\tif (rc)\n\t\tcifs_put_tcon(tcon);\n\n\treturn rc;\n}\n\n \nint\nsmb311_update_preauth_hash(struct cifs_ses *ses, struct TCP_Server_Info *server,\n\t\t\t   struct kvec *iov, int nvec)\n{\n\tint i, rc;\n\tstruct smb2_hdr *hdr;\n\tstruct shash_desc *sha512 = NULL;\n\n\thdr = (struct smb2_hdr *)iov[0].iov_base;\n\t \n\tif (hdr->Command == SMB2_NEGOTIATE)\n\t\tgoto ok;\n\n\t \n\tif (server->dialect != SMB311_PROT_ID)\n\t\treturn 0;\n\n\tif (hdr->Command != SMB2_SESSION_SETUP)\n\t\treturn 0;\n\n\t \n\tif ((hdr->Flags & SMB2_FLAGS_SERVER_TO_REDIR)\n\t    && (hdr->Status == NT_STATUS_OK\n\t\t|| (hdr->Status !=\n\t\t    cpu_to_le32(NT_STATUS_MORE_PROCESSING_REQUIRED))))\n\t\treturn 0;\n\nok:\n\trc = smb311_crypto_shash_allocate(server);\n\tif (rc)\n\t\treturn rc;\n\n\tsha512 = server->secmech.sha512;\n\trc = crypto_shash_init(sha512);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not init sha512 shash\\n\", __func__);\n\t\treturn rc;\n\t}\n\n\trc = crypto_shash_update(sha512, ses->preauth_sha_hash,\n\t\t\t\t SMB2_PREAUTH_HASH_SIZE);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not update sha512 shash\\n\", __func__);\n\t\treturn rc;\n\t}\n\n\tfor (i = 0; i < nvec; i++) {\n\t\trc = crypto_shash_update(sha512, iov[i].iov_base, iov[i].iov_len);\n\t\tif (rc) {\n\t\t\tcifs_dbg(VFS, \"%s: Could not update sha512 shash\\n\",\n\t\t\t\t __func__);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = crypto_shash_final(sha512, ses->preauth_sha_hash);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not finalize sha512 shash\\n\",\n\t\t\t __func__);\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}