{
  "module_name": "smb2transport.c",
  "hash_id": "7077ea0bdf367c8eb43a3f2d5ca73551358c6cd441a7299d945e3a32acb1280e",
  "original_prompt": "Ingested from linux-6.6.14/fs/smb/client/smb2transport.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/net.h>\n#include <linux/delay.h>\n#include <linux/uaccess.h>\n#include <asm/processor.h>\n#include <linux/mempool.h>\n#include <linux/highmem.h>\n#include <crypto/aead.h>\n#include \"cifsglob.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"cifs_debug.h\"\n#include \"smb2status.h\"\n#include \"smb2glob.h\"\n\nstatic int\nsmb3_crypto_shash_allocate(struct TCP_Server_Info *server)\n{\n\tstruct cifs_secmech *p = &server->secmech;\n\tint rc;\n\n\trc = cifs_alloc_hash(\"hmac(sha256)\", &p->hmacsha256);\n\tif (rc)\n\t\tgoto err;\n\n\trc = cifs_alloc_hash(\"cmac(aes)\", &p->aes_cmac);\n\tif (rc)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tcifs_free_hash(&p->hmacsha256);\n\treturn rc;\n}\n\nint\nsmb311_crypto_shash_allocate(struct TCP_Server_Info *server)\n{\n\tstruct cifs_secmech *p = &server->secmech;\n\tint rc = 0;\n\n\trc = cifs_alloc_hash(\"hmac(sha256)\", &p->hmacsha256);\n\tif (rc)\n\t\treturn rc;\n\n\trc = cifs_alloc_hash(\"cmac(aes)\", &p->aes_cmac);\n\tif (rc)\n\t\tgoto err;\n\n\trc = cifs_alloc_hash(\"sha512\", &p->sha512);\n\tif (rc)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tcifs_free_hash(&p->aes_cmac);\n\tcifs_free_hash(&p->hmacsha256);\n\treturn rc;\n}\n\n\nstatic\nint smb2_get_sign_key(__u64 ses_id, struct TCP_Server_Info *server, u8 *key)\n{\n\tstruct cifs_chan *chan;\n\tstruct TCP_Server_Info *pserver;\n\tstruct cifs_ses *ses = NULL;\n\tint i;\n\tint rc = 0;\n\tbool is_binding = false;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\n\t \n\tpserver = SERVER_IS_CHAN(server) ? server->primary_server : server;\n\n\tlist_for_each_entry(ses, &pserver->smb_ses_list, smb_ses_list) {\n\t\tif (ses->Suid == ses_id)\n\t\t\tgoto found;\n\t}\n\ttrace_smb3_ses_not_found(ses_id);\n\tcifs_server_dbg(FYI, \"%s: Could not find session 0x%llx\\n\",\n\t\t\t__func__, ses_id);\n\trc = -ENOENT;\n\tgoto out;\n\nfound:\n\tspin_lock(&ses->ses_lock);\n\tspin_lock(&ses->chan_lock);\n\n\tis_binding = (cifs_chan_needs_reconnect(ses, server) &&\n\t\t      ses->ses_status == SES_GOOD);\n\tif (is_binding) {\n\t\t \n\t\tmemcpy(key, ses->smb3signingkey, SMB3_SIGN_KEY_SIZE);\n\t\tspin_unlock(&ses->chan_lock);\n\t\tspin_unlock(&ses->ses_lock);\n\t\tgoto out;\n\t}\n\n\t \n\n\tfor (i = 0; i < ses->chan_count; i++) {\n\t\tchan = ses->chans + i;\n\t\tif (chan->server == server) {\n\t\t\tmemcpy(key, chan->signkey, SMB3_SIGN_KEY_SIZE);\n\t\t\tspin_unlock(&ses->chan_lock);\n\t\t\tspin_unlock(&ses->ses_lock);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tspin_unlock(&ses->chan_lock);\n\tspin_unlock(&ses->ses_lock);\n\n\tcifs_dbg(VFS,\n\t\t \"%s: Could not find channel signing key for session 0x%llx\\n\",\n\t\t __func__, ses_id);\n\trc = -ENOENT;\n\nout:\n\tspin_unlock(&cifs_tcp_ses_lock);\n\treturn rc;\n}\n\nstatic struct cifs_ses *\nsmb2_find_smb_ses_unlocked(struct TCP_Server_Info *server, __u64 ses_id)\n{\n\tstruct TCP_Server_Info *pserver;\n\tstruct cifs_ses *ses;\n\n\t \n\tpserver = SERVER_IS_CHAN(server) ? server->primary_server : server;\n\n\tlist_for_each_entry(ses, &pserver->smb_ses_list, smb_ses_list) {\n\t\tif (ses->Suid != ses_id)\n\t\t\tcontinue;\n\n\t\tspin_lock(&ses->ses_lock);\n\t\tif (ses->ses_status == SES_EXITING) {\n\t\t\tspin_unlock(&ses->ses_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tcifs_smb_ses_inc_refcount(ses);\n\t\tspin_unlock(&ses->ses_lock);\n\t\treturn ses;\n\t}\n\n\treturn NULL;\n}\n\nstruct cifs_ses *\nsmb2_find_smb_ses(struct TCP_Server_Info *server, __u64 ses_id)\n{\n\tstruct cifs_ses *ses;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tses = smb2_find_smb_ses_unlocked(server, ses_id);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\treturn ses;\n}\n\nstatic struct cifs_tcon *\nsmb2_find_smb_sess_tcon_unlocked(struct cifs_ses *ses, __u32  tid)\n{\n\tstruct cifs_tcon *tcon;\n\n\tlist_for_each_entry(tcon, &ses->tcon_list, tcon_list) {\n\t\tif (tcon->tid != tid)\n\t\t\tcontinue;\n\t\t++tcon->tc_count;\n\t\treturn tcon;\n\t}\n\n\treturn NULL;\n}\n\n \n\nstruct cifs_tcon *\nsmb2_find_smb_tcon(struct TCP_Server_Info *server, __u64 ses_id, __u32  tid)\n{\n\tstruct cifs_ses *ses;\n\tstruct cifs_tcon *tcon;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tses = smb2_find_smb_ses_unlocked(server, ses_id);\n\tif (!ses) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn NULL;\n\t}\n\ttcon = smb2_find_smb_sess_tcon_unlocked(ses, tid);\n\tif (!tcon) {\n\t\tcifs_put_smb_ses(ses);\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn NULL;\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\t \n\tcifs_put_smb_ses(ses);\n\n\treturn tcon;\n}\n\nint\nsmb2_calc_signature(struct smb_rqst *rqst, struct TCP_Server_Info *server,\n\t\t\tbool allocate_crypto)\n{\n\tint rc;\n\tunsigned char smb2_signature[SMB2_HMACSHA256_SIZE];\n\tunsigned char *sigptr = smb2_signature;\n\tstruct kvec *iov = rqst->rq_iov;\n\tstruct smb2_hdr *shdr = (struct smb2_hdr *)iov[0].iov_base;\n\tstruct cifs_ses *ses;\n\tstruct shash_desc *shash = NULL;\n\tstruct smb_rqst drqst;\n\n\tses = smb2_find_smb_ses(server, le64_to_cpu(shdr->SessionId));\n\tif (unlikely(!ses)) {\n\t\tcifs_server_dbg(VFS, \"%s: Could not find session\\n\", __func__);\n\t\treturn -ENOENT;\n\t}\n\n\tmemset(smb2_signature, 0x0, SMB2_HMACSHA256_SIZE);\n\tmemset(shdr->Signature, 0x0, SMB2_SIGNATURE_SIZE);\n\n\tif (allocate_crypto) {\n\t\trc = cifs_alloc_hash(\"hmac(sha256)\", &shash);\n\t\tif (rc) {\n\t\t\tcifs_server_dbg(VFS,\n\t\t\t\t\t\"%s: sha256 alloc failed\\n\", __func__);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tshash = server->secmech.hmacsha256;\n\t}\n\n\trc = crypto_shash_setkey(shash->tfm, ses->auth_key.response,\n\t\t\tSMB2_NTLMV2_SESSKEY_SIZE);\n\tif (rc) {\n\t\tcifs_server_dbg(VFS,\n\t\t\t\t\"%s: Could not update with response\\n\",\n\t\t\t\t__func__);\n\t\tgoto out;\n\t}\n\n\trc = crypto_shash_init(shash);\n\tif (rc) {\n\t\tcifs_server_dbg(VFS, \"%s: Could not init sha256\", __func__);\n\t\tgoto out;\n\t}\n\n\t \n\tdrqst = *rqst;\n\tif (drqst.rq_nvec >= 2 && iov[0].iov_len == 4) {\n\t\trc = crypto_shash_update(shash, iov[0].iov_base,\n\t\t\t\t\t iov[0].iov_len);\n\t\tif (rc) {\n\t\t\tcifs_server_dbg(VFS,\n\t\t\t\t\t\"%s: Could not update with payload\\n\",\n\t\t\t\t\t__func__);\n\t\t\tgoto out;\n\t\t}\n\t\tdrqst.rq_iov++;\n\t\tdrqst.rq_nvec--;\n\t}\n\n\trc = __cifs_calc_signature(&drqst, server, sigptr, shash);\n\tif (!rc)\n\t\tmemcpy(shdr->Signature, sigptr, SMB2_SIGNATURE_SIZE);\n\nout:\n\tif (allocate_crypto)\n\t\tcifs_free_hash(&shash);\n\tif (ses)\n\t\tcifs_put_smb_ses(ses);\n\treturn rc;\n}\n\nstatic int generate_key(struct cifs_ses *ses, struct kvec label,\n\t\t\tstruct kvec context, __u8 *key, unsigned int key_size)\n{\n\tunsigned char zero = 0x0;\n\t__u8 i[4] = {0, 0, 0, 1};\n\t__u8 L128[4] = {0, 0, 0, 128};\n\t__u8 L256[4] = {0, 0, 1, 0};\n\tint rc = 0;\n\tunsigned char prfhash[SMB2_HMACSHA256_SIZE];\n\tunsigned char *hashptr = prfhash;\n\tstruct TCP_Server_Info *server = ses->server;\n\n\tmemset(prfhash, 0x0, SMB2_HMACSHA256_SIZE);\n\tmemset(key, 0x0, key_size);\n\n\trc = smb3_crypto_shash_allocate(server);\n\tif (rc) {\n\t\tcifs_server_dbg(VFS, \"%s: crypto alloc failed\\n\", __func__);\n\t\tgoto smb3signkey_ret;\n\t}\n\n\trc = crypto_shash_setkey(server->secmech.hmacsha256->tfm,\n\t\tses->auth_key.response, SMB2_NTLMV2_SESSKEY_SIZE);\n\tif (rc) {\n\t\tcifs_server_dbg(VFS, \"%s: Could not set with session key\\n\", __func__);\n\t\tgoto smb3signkey_ret;\n\t}\n\n\trc = crypto_shash_init(server->secmech.hmacsha256);\n\tif (rc) {\n\t\tcifs_server_dbg(VFS, \"%s: Could not init sign hmac\\n\", __func__);\n\t\tgoto smb3signkey_ret;\n\t}\n\n\trc = crypto_shash_update(server->secmech.hmacsha256, i, 4);\n\tif (rc) {\n\t\tcifs_server_dbg(VFS, \"%s: Could not update with n\\n\", __func__);\n\t\tgoto smb3signkey_ret;\n\t}\n\n\trc = crypto_shash_update(server->secmech.hmacsha256, label.iov_base, label.iov_len);\n\tif (rc) {\n\t\tcifs_server_dbg(VFS, \"%s: Could not update with label\\n\", __func__);\n\t\tgoto smb3signkey_ret;\n\t}\n\n\trc = crypto_shash_update(server->secmech.hmacsha256, &zero, 1);\n\tif (rc) {\n\t\tcifs_server_dbg(VFS, \"%s: Could not update with zero\\n\", __func__);\n\t\tgoto smb3signkey_ret;\n\t}\n\n\trc = crypto_shash_update(server->secmech.hmacsha256, context.iov_base, context.iov_len);\n\tif (rc) {\n\t\tcifs_server_dbg(VFS, \"%s: Could not update with context\\n\", __func__);\n\t\tgoto smb3signkey_ret;\n\t}\n\n\tif ((server->cipher_type == SMB2_ENCRYPTION_AES256_CCM) ||\n\t\t(server->cipher_type == SMB2_ENCRYPTION_AES256_GCM)) {\n\t\trc = crypto_shash_update(server->secmech.hmacsha256, L256, 4);\n\t} else {\n\t\trc = crypto_shash_update(server->secmech.hmacsha256, L128, 4);\n\t}\n\tif (rc) {\n\t\tcifs_server_dbg(VFS, \"%s: Could not update with L\\n\", __func__);\n\t\tgoto smb3signkey_ret;\n\t}\n\n\trc = crypto_shash_final(server->secmech.hmacsha256, hashptr);\n\tif (rc) {\n\t\tcifs_server_dbg(VFS, \"%s: Could not generate sha256 hash\\n\", __func__);\n\t\tgoto smb3signkey_ret;\n\t}\n\n\tmemcpy(key, hashptr, key_size);\n\nsmb3signkey_ret:\n\treturn rc;\n}\n\nstruct derivation {\n\tstruct kvec label;\n\tstruct kvec context;\n};\n\nstruct derivation_triplet {\n\tstruct derivation signing;\n\tstruct derivation encryption;\n\tstruct derivation decryption;\n};\n\nstatic int\ngenerate_smb3signingkey(struct cifs_ses *ses,\n\t\t\tstruct TCP_Server_Info *server,\n\t\t\tconst struct derivation_triplet *ptriplet)\n{\n\tint rc;\n\tbool is_binding = false;\n\tint chan_index = 0;\n\n\tspin_lock(&ses->ses_lock);\n\tspin_lock(&ses->chan_lock);\n\tis_binding = (cifs_chan_needs_reconnect(ses, server) &&\n\t\t      ses->ses_status == SES_GOOD);\n\n\tchan_index = cifs_ses_get_chan_index(ses, server);\n\t \n\tspin_unlock(&ses->chan_lock);\n\tspin_unlock(&ses->ses_lock);\n\n\t \n\n\tif (is_binding) {\n\t\trc = generate_key(ses, ptriplet->signing.label,\n\t\t\t\t  ptriplet->signing.context,\n\t\t\t\t  ses->chans[chan_index].signkey,\n\t\t\t\t  SMB3_SIGN_KEY_SIZE);\n\t\tif (rc)\n\t\t\treturn rc;\n\t} else {\n\t\trc = generate_key(ses, ptriplet->signing.label,\n\t\t\t\t  ptriplet->signing.context,\n\t\t\t\t  ses->smb3signingkey,\n\t\t\t\t  SMB3_SIGN_KEY_SIZE);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t \n\t\tspin_lock(&ses->chan_lock);\n\t\tmemcpy(ses->chans[chan_index].signkey, ses->smb3signingkey,\n\t\t       SMB3_SIGN_KEY_SIZE);\n\t\tspin_unlock(&ses->chan_lock);\n\n\t\trc = generate_key(ses, ptriplet->encryption.label,\n\t\t\t\t  ptriplet->encryption.context,\n\t\t\t\t  ses->smb3encryptionkey,\n\t\t\t\t  SMB3_ENC_DEC_KEY_SIZE);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\trc = generate_key(ses, ptriplet->decryption.label,\n\t\t\t\t  ptriplet->decryption.context,\n\t\t\t\t  ses->smb3decryptionkey,\n\t\t\t\t  SMB3_ENC_DEC_KEY_SIZE);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n#ifdef CONFIG_CIFS_DEBUG_DUMP_KEYS\n\tcifs_dbg(VFS, \"%s: dumping generated AES session keys\\n\", __func__);\n\t \n\tcifs_dbg(VFS, \"Session Id    %*ph\\n\", (int)sizeof(ses->Suid),\n\t\t\t&ses->Suid);\n\tcifs_dbg(VFS, \"Cipher type   %d\\n\", server->cipher_type);\n\tcifs_dbg(VFS, \"Session Key   %*ph\\n\",\n\t\t SMB2_NTLMV2_SESSKEY_SIZE, ses->auth_key.response);\n\tcifs_dbg(VFS, \"Signing Key   %*ph\\n\",\n\t\t SMB3_SIGN_KEY_SIZE, ses->smb3signingkey);\n\tif ((server->cipher_type == SMB2_ENCRYPTION_AES256_CCM) ||\n\t\t(server->cipher_type == SMB2_ENCRYPTION_AES256_GCM)) {\n\t\tcifs_dbg(VFS, \"ServerIn Key  %*ph\\n\",\n\t\t\t\tSMB3_GCM256_CRYPTKEY_SIZE, ses->smb3encryptionkey);\n\t\tcifs_dbg(VFS, \"ServerOut Key %*ph\\n\",\n\t\t\t\tSMB3_GCM256_CRYPTKEY_SIZE, ses->smb3decryptionkey);\n\t} else {\n\t\tcifs_dbg(VFS, \"ServerIn Key  %*ph\\n\",\n\t\t\t\tSMB3_GCM128_CRYPTKEY_SIZE, ses->smb3encryptionkey);\n\t\tcifs_dbg(VFS, \"ServerOut Key %*ph\\n\",\n\t\t\t\tSMB3_GCM128_CRYPTKEY_SIZE, ses->smb3decryptionkey);\n\t}\n#endif\n\treturn rc;\n}\n\nint\ngenerate_smb30signingkey(struct cifs_ses *ses,\n\t\t\t struct TCP_Server_Info *server)\n\n{\n\tstruct derivation_triplet triplet;\n\tstruct derivation *d;\n\n\td = &triplet.signing;\n\td->label.iov_base = \"SMB2AESCMAC\";\n\td->label.iov_len = 12;\n\td->context.iov_base = \"SmbSign\";\n\td->context.iov_len = 8;\n\n\td = &triplet.encryption;\n\td->label.iov_base = \"SMB2AESCCM\";\n\td->label.iov_len = 11;\n\td->context.iov_base = \"ServerIn \";\n\td->context.iov_len = 10;\n\n\td = &triplet.decryption;\n\td->label.iov_base = \"SMB2AESCCM\";\n\td->label.iov_len = 11;\n\td->context.iov_base = \"ServerOut\";\n\td->context.iov_len = 10;\n\n\treturn generate_smb3signingkey(ses, server, &triplet);\n}\n\nint\ngenerate_smb311signingkey(struct cifs_ses *ses,\n\t\t\t  struct TCP_Server_Info *server)\n\n{\n\tstruct derivation_triplet triplet;\n\tstruct derivation *d;\n\n\td = &triplet.signing;\n\td->label.iov_base = \"SMBSigningKey\";\n\td->label.iov_len = 14;\n\td->context.iov_base = ses->preauth_sha_hash;\n\td->context.iov_len = 64;\n\n\td = &triplet.encryption;\n\td->label.iov_base = \"SMBC2SCipherKey\";\n\td->label.iov_len = 16;\n\td->context.iov_base = ses->preauth_sha_hash;\n\td->context.iov_len = 64;\n\n\td = &triplet.decryption;\n\td->label.iov_base = \"SMBS2CCipherKey\";\n\td->label.iov_len = 16;\n\td->context.iov_base = ses->preauth_sha_hash;\n\td->context.iov_len = 64;\n\n\treturn generate_smb3signingkey(ses, server, &triplet);\n}\n\nint\nsmb3_calc_signature(struct smb_rqst *rqst, struct TCP_Server_Info *server,\n\t\t\tbool allocate_crypto)\n{\n\tint rc;\n\tunsigned char smb3_signature[SMB2_CMACAES_SIZE];\n\tunsigned char *sigptr = smb3_signature;\n\tstruct kvec *iov = rqst->rq_iov;\n\tstruct smb2_hdr *shdr = (struct smb2_hdr *)iov[0].iov_base;\n\tstruct shash_desc *shash = NULL;\n\tstruct smb_rqst drqst;\n\tu8 key[SMB3_SIGN_KEY_SIZE];\n\n\trc = smb2_get_sign_key(le64_to_cpu(shdr->SessionId), server, key);\n\tif (unlikely(rc)) {\n\t\tcifs_server_dbg(FYI, \"%s: Could not get signing key\\n\", __func__);\n\t\treturn rc;\n\t}\n\n\tif (allocate_crypto) {\n\t\trc = cifs_alloc_hash(\"cmac(aes)\", &shash);\n\t\tif (rc)\n\t\t\treturn rc;\n\t} else {\n\t\tshash = server->secmech.aes_cmac;\n\t}\n\n\tmemset(smb3_signature, 0x0, SMB2_CMACAES_SIZE);\n\tmemset(shdr->Signature, 0x0, SMB2_SIGNATURE_SIZE);\n\n\trc = crypto_shash_setkey(shash->tfm, key, SMB2_CMACAES_SIZE);\n\tif (rc) {\n\t\tcifs_server_dbg(VFS, \"%s: Could not set key for cmac aes\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\t \n\trc = crypto_shash_init(shash);\n\tif (rc) {\n\t\tcifs_server_dbg(VFS, \"%s: Could not init cmac aes\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\t \n\tdrqst = *rqst;\n\tif (drqst.rq_nvec >= 2 && iov[0].iov_len == 4) {\n\t\trc = crypto_shash_update(shash, iov[0].iov_base,\n\t\t\t\t\t iov[0].iov_len);\n\t\tif (rc) {\n\t\t\tcifs_server_dbg(VFS, \"%s: Could not update with payload\\n\",\n\t\t\t\t __func__);\n\t\t\tgoto out;\n\t\t}\n\t\tdrqst.rq_iov++;\n\t\tdrqst.rq_nvec--;\n\t}\n\n\trc = __cifs_calc_signature(&drqst, server, sigptr, shash);\n\tif (!rc)\n\t\tmemcpy(shdr->Signature, sigptr, SMB2_SIGNATURE_SIZE);\n\nout:\n\tif (allocate_crypto)\n\t\tcifs_free_hash(&shash);\n\treturn rc;\n}\n\n \nstatic int\nsmb2_sign_rqst(struct smb_rqst *rqst, struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\tstruct smb2_hdr *shdr;\n\tstruct smb2_sess_setup_req *ssr;\n\tbool is_binding;\n\tbool is_signed;\n\n\tshdr = (struct smb2_hdr *)rqst->rq_iov[0].iov_base;\n\tssr = (struct smb2_sess_setup_req *)shdr;\n\n\tis_binding = shdr->Command == SMB2_SESSION_SETUP &&\n\t\t(ssr->Flags & SMB2_SESSION_REQ_FLAG_BINDING);\n\tis_signed = shdr->Flags & SMB2_FLAGS_SIGNED;\n\n\tif (!is_signed)\n\t\treturn 0;\n\tspin_lock(&server->srv_lock);\n\tif (server->ops->need_neg &&\n\t    server->ops->need_neg(server)) {\n\t\tspin_unlock(&server->srv_lock);\n\t\treturn 0;\n\t}\n\tspin_unlock(&server->srv_lock);\n\tif (!is_binding && !server->session_estab) {\n\t\tstrncpy(shdr->Signature, \"BSRSPYL\", 8);\n\t\treturn 0;\n\t}\n\n\trc = server->ops->calc_signature(rqst, server, false);\n\n\treturn rc;\n}\n\nint\nsmb2_verify_signature(struct smb_rqst *rqst, struct TCP_Server_Info *server)\n{\n\tunsigned int rc;\n\tchar server_response_sig[SMB2_SIGNATURE_SIZE];\n\tstruct smb2_hdr *shdr =\n\t\t\t(struct smb2_hdr *)rqst->rq_iov[0].iov_base;\n\n\tif ((shdr->Command == SMB2_NEGOTIATE) ||\n\t    (shdr->Command == SMB2_SESSION_SETUP) ||\n\t    (shdr->Command == SMB2_OPLOCK_BREAK) ||\n\t    server->ignore_signature ||\n\t    (!server->session_estab))\n\t\treturn 0;\n\n\t \n\n\t \n\tif (memcmp(shdr->Signature, \"BSRSPYL \", 8) == 0)\n\t\tcifs_dbg(FYI, \"dummy signature received for smb command 0x%x\\n\",\n\t\t\t shdr->Command);\n\n\t \n\tmemcpy(server_response_sig, shdr->Signature, SMB2_SIGNATURE_SIZE);\n\n\tmemset(shdr->Signature, 0, SMB2_SIGNATURE_SIZE);\n\n\trc = server->ops->calc_signature(rqst, server, true);\n\n\tif (rc)\n\t\treturn rc;\n\n\tif (memcmp(server_response_sig, shdr->Signature, SMB2_SIGNATURE_SIZE)) {\n\t\tcifs_dbg(VFS, \"sign fail cmd 0x%x message id 0x%llx\\n\",\n\t\t\tshdr->Command, shdr->MessageId);\n\t\treturn -EACCES;\n\t} else\n\t\treturn 0;\n}\n\n \nstatic inline void\nsmb2_seq_num_into_buf(struct TCP_Server_Info *server,\n\t\t      struct smb2_hdr *shdr)\n{\n\tunsigned int i, num = le16_to_cpu(shdr->CreditCharge);\n\n\tshdr->MessageId = get_next_mid64(server);\n\t \n\tfor (i = 1; i < num; i++)\n\t\tget_next_mid(server);\n}\n\nstatic struct mid_q_entry *\nsmb2_mid_entry_alloc(const struct smb2_hdr *shdr,\n\t\t     struct TCP_Server_Info *server)\n{\n\tstruct mid_q_entry *temp;\n\tunsigned int credits = le16_to_cpu(shdr->CreditCharge);\n\n\tif (server == NULL) {\n\t\tcifs_dbg(VFS, \"Null TCP session in smb2_mid_entry_alloc\\n\");\n\t\treturn NULL;\n\t}\n\n\ttemp = mempool_alloc(cifs_mid_poolp, GFP_NOFS);\n\tmemset(temp, 0, sizeof(struct mid_q_entry));\n\tkref_init(&temp->refcount);\n\ttemp->mid = le64_to_cpu(shdr->MessageId);\n\ttemp->credits = credits > 0 ? credits : 1;\n\ttemp->pid = current->pid;\n\ttemp->command = shdr->Command;  \n\ttemp->when_alloc = jiffies;\n\ttemp->server = server;\n\n\t \n\tget_task_struct(current);\n\ttemp->creator = current;\n\ttemp->callback = cifs_wake_up_task;\n\ttemp->callback_data = current;\n\n\tatomic_inc(&mid_count);\n\ttemp->mid_state = MID_REQUEST_ALLOCATED;\n\ttrace_smb3_cmd_enter(le32_to_cpu(shdr->Id.SyncId.TreeId),\n\t\t\t     le64_to_cpu(shdr->SessionId),\n\t\t\t     le16_to_cpu(shdr->Command), temp->mid);\n\treturn temp;\n}\n\nstatic int\nsmb2_get_mid_entry(struct cifs_ses *ses, struct TCP_Server_Info *server,\n\t\t   struct smb2_hdr *shdr, struct mid_q_entry **mid)\n{\n\tspin_lock(&server->srv_lock);\n\tif (server->tcpStatus == CifsExiting) {\n\t\tspin_unlock(&server->srv_lock);\n\t\treturn -ENOENT;\n\t}\n\n\tif (server->tcpStatus == CifsNeedReconnect) {\n\t\tspin_unlock(&server->srv_lock);\n\t\tcifs_dbg(FYI, \"tcp session dead - return to caller to retry\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\tif (server->tcpStatus == CifsNeedNegotiate &&\n\t   shdr->Command != SMB2_NEGOTIATE) {\n\t\tspin_unlock(&server->srv_lock);\n\t\treturn -EAGAIN;\n\t}\n\tspin_unlock(&server->srv_lock);\n\n\tspin_lock(&ses->ses_lock);\n\tif (ses->ses_status == SES_NEW) {\n\t\tif ((shdr->Command != SMB2_SESSION_SETUP) &&\n\t\t    (shdr->Command != SMB2_NEGOTIATE)) {\n\t\t\tspin_unlock(&ses->ses_lock);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\t \n\t}\n\n\tif (ses->ses_status == SES_EXITING) {\n\t\tif (shdr->Command != SMB2_LOGOFF) {\n\t\t\tspin_unlock(&ses->ses_lock);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\t \n\t}\n\tspin_unlock(&ses->ses_lock);\n\n\t*mid = smb2_mid_entry_alloc(shdr, server);\n\tif (*mid == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock(&server->mid_lock);\n\tlist_add_tail(&(*mid)->qhead, &server->pending_mid_q);\n\tspin_unlock(&server->mid_lock);\n\n\treturn 0;\n}\n\nint\nsmb2_check_receive(struct mid_q_entry *mid, struct TCP_Server_Info *server,\n\t\t   bool log_error)\n{\n\tunsigned int len = mid->resp_buf_size;\n\tstruct kvec iov[1];\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = 1 };\n\n\tiov[0].iov_base = (char *)mid->resp_buf;\n\tiov[0].iov_len = len;\n\n\tdump_smb(mid->resp_buf, min_t(u32, 80, len));\n\t \n\tif (len > 24 && server->sign && !mid->decrypted) {\n\t\tint rc;\n\n\t\trc = smb2_verify_signature(&rqst, server);\n\t\tif (rc)\n\t\t\tcifs_server_dbg(VFS, \"SMB signature verification returned error = %d\\n\",\n\t\t\t\t rc);\n\t}\n\n\treturn map_smb2_to_linux_error(mid->resp_buf, log_error);\n}\n\nstruct mid_q_entry *\nsmb2_setup_request(struct cifs_ses *ses, struct TCP_Server_Info *server,\n\t\t   struct smb_rqst *rqst)\n{\n\tint rc;\n\tstruct smb2_hdr *shdr =\n\t\t\t(struct smb2_hdr *)rqst->rq_iov[0].iov_base;\n\tstruct mid_q_entry *mid;\n\n\tsmb2_seq_num_into_buf(server, shdr);\n\n\trc = smb2_get_mid_entry(ses, server, shdr, &mid);\n\tif (rc) {\n\t\trevert_current_mid_from_hdr(server, shdr);\n\t\treturn ERR_PTR(rc);\n\t}\n\n\trc = smb2_sign_rqst(rqst, server);\n\tif (rc) {\n\t\trevert_current_mid_from_hdr(server, shdr);\n\t\tdelete_mid(mid);\n\t\treturn ERR_PTR(rc);\n\t}\n\n\treturn mid;\n}\n\nstruct mid_q_entry *\nsmb2_setup_async_request(struct TCP_Server_Info *server, struct smb_rqst *rqst)\n{\n\tint rc;\n\tstruct smb2_hdr *shdr =\n\t\t\t(struct smb2_hdr *)rqst->rq_iov[0].iov_base;\n\tstruct mid_q_entry *mid;\n\n\tspin_lock(&server->srv_lock);\n\tif (server->tcpStatus == CifsNeedNegotiate &&\n\t   shdr->Command != SMB2_NEGOTIATE) {\n\t\tspin_unlock(&server->srv_lock);\n\t\treturn ERR_PTR(-EAGAIN);\n\t}\n\tspin_unlock(&server->srv_lock);\n\n\tsmb2_seq_num_into_buf(server, shdr);\n\n\tmid = smb2_mid_entry_alloc(shdr, server);\n\tif (mid == NULL) {\n\t\trevert_current_mid_from_hdr(server, shdr);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\trc = smb2_sign_rqst(rqst, server);\n\tif (rc) {\n\t\trevert_current_mid_from_hdr(server, shdr);\n\t\trelease_mid(mid);\n\t\treturn ERR_PTR(rc);\n\t}\n\n\treturn mid;\n}\n\nint\nsmb3_crypto_aead_allocate(struct TCP_Server_Info *server)\n{\n\tstruct crypto_aead *tfm;\n\n\tif (!server->secmech.enc) {\n\t\tif ((server->cipher_type == SMB2_ENCRYPTION_AES128_GCM) ||\n\t\t    (server->cipher_type == SMB2_ENCRYPTION_AES256_GCM))\n\t\t\ttfm = crypto_alloc_aead(\"gcm(aes)\", 0, 0);\n\t\telse\n\t\t\ttfm = crypto_alloc_aead(\"ccm(aes)\", 0, 0);\n\t\tif (IS_ERR(tfm)) {\n\t\t\tcifs_server_dbg(VFS, \"%s: Failed alloc encrypt aead\\n\",\n\t\t\t\t __func__);\n\t\t\treturn PTR_ERR(tfm);\n\t\t}\n\t\tserver->secmech.enc = tfm;\n\t}\n\n\tif (!server->secmech.dec) {\n\t\tif ((server->cipher_type == SMB2_ENCRYPTION_AES128_GCM) ||\n\t\t    (server->cipher_type == SMB2_ENCRYPTION_AES256_GCM))\n\t\t\ttfm = crypto_alloc_aead(\"gcm(aes)\", 0, 0);\n\t\telse\n\t\t\ttfm = crypto_alloc_aead(\"ccm(aes)\", 0, 0);\n\t\tif (IS_ERR(tfm)) {\n\t\t\tcrypto_free_aead(server->secmech.enc);\n\t\t\tserver->secmech.enc = NULL;\n\t\t\tcifs_server_dbg(VFS, \"%s: Failed to alloc decrypt aead\\n\",\n\t\t\t\t __func__);\n\t\t\treturn PTR_ERR(tfm);\n\t\t}\n\t\tserver->secmech.dec = tfm;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}