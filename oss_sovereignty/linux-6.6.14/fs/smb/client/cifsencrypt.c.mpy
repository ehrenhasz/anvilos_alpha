{
  "module_name": "cifsencrypt.c",
  "hash_id": "41c2f6f34060acdf0d3f111b057f208d539869393e21b795e9020fd8b74ac153",
  "original_prompt": "Ingested from linux-6.6.14/fs/smb/client/cifsencrypt.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include \"cifspdu.h\"\n#include \"cifsglob.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"ntlmssp.h\"\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/highmem.h>\n#include <linux/fips.h>\n#include \"../common/arc4.h\"\n#include <crypto/aead.h>\n\n \nstatic int cifs_shash_bvec(const struct iov_iter *iter, ssize_t maxsize,\n\t\t\t   struct shash_desc *shash)\n{\n\tconst struct bio_vec *bv = iter->bvec;\n\tunsigned long start = iter->iov_offset;\n\tunsigned int i;\n\tvoid *p;\n\tint ret;\n\n\tfor (i = 0; i < iter->nr_segs; i++) {\n\t\tsize_t off, len;\n\n\t\tlen = bv[i].bv_len;\n\t\tif (start >= len) {\n\t\t\tstart -= len;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlen = min_t(size_t, maxsize, len - start);\n\t\toff = bv[i].bv_offset + start;\n\n\t\tp = kmap_local_page(bv[i].bv_page);\n\t\tret = crypto_shash_update(shash, p + off, len);\n\t\tkunmap_local(p);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tmaxsize -= len;\n\t\tif (maxsize <= 0)\n\t\t\tbreak;\n\t\tstart = 0;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int cifs_shash_kvec(const struct iov_iter *iter, ssize_t maxsize,\n\t\t\t   struct shash_desc *shash)\n{\n\tconst struct kvec *kv = iter->kvec;\n\tunsigned long start = iter->iov_offset;\n\tunsigned int i;\n\tint ret;\n\n\tfor (i = 0; i < iter->nr_segs; i++) {\n\t\tsize_t len;\n\n\t\tlen = kv[i].iov_len;\n\t\tif (start >= len) {\n\t\t\tstart -= len;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlen = min_t(size_t, maxsize, len - start);\n\t\tret = crypto_shash_update(shash, kv[i].iov_base + start, len);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tmaxsize -= len;\n\n\t\tif (maxsize <= 0)\n\t\t\tbreak;\n\t\tstart = 0;\n\t}\n\n\treturn 0;\n}\n\n \nstatic ssize_t cifs_shash_xarray(const struct iov_iter *iter, ssize_t maxsize,\n\t\t\t\t struct shash_desc *shash)\n{\n\tstruct folio *folios[16], *folio;\n\tunsigned int nr, i, j, npages;\n\tloff_t start = iter->xarray_start + iter->iov_offset;\n\tpgoff_t last, index = start / PAGE_SIZE;\n\tssize_t ret = 0;\n\tsize_t len, offset, foffset;\n\tvoid *p;\n\n\tif (maxsize == 0)\n\t\treturn 0;\n\n\tlast = (start + maxsize - 1) / PAGE_SIZE;\n\tdo {\n\t\tnr = xa_extract(iter->xarray, (void **)folios, index, last,\n\t\t\t\tARRAY_SIZE(folios), XA_PRESENT);\n\t\tif (nr == 0)\n\t\t\treturn -EIO;\n\n\t\tfor (i = 0; i < nr; i++) {\n\t\t\tfolio = folios[i];\n\t\t\tnpages = folio_nr_pages(folio);\n\t\t\tfoffset = start - folio_pos(folio);\n\t\t\toffset = foffset % PAGE_SIZE;\n\t\t\tfor (j = foffset / PAGE_SIZE; j < npages; j++) {\n\t\t\t\tlen = min_t(size_t, maxsize, PAGE_SIZE - offset);\n\t\t\t\tp = kmap_local_page(folio_page(folio, j));\n\t\t\t\tret = crypto_shash_update(shash, p, len);\n\t\t\t\tkunmap_local(p);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn ret;\n\t\t\t\tmaxsize -= len;\n\t\t\t\tif (maxsize <= 0)\n\t\t\t\t\treturn 0;\n\t\t\t\tstart += len;\n\t\t\t\toffset = 0;\n\t\t\t\tindex++;\n\t\t\t}\n\t\t}\n\t} while (nr == ARRAY_SIZE(folios));\n\treturn 0;\n}\n\n \nstatic int cifs_shash_iter(const struct iov_iter *iter, size_t maxsize,\n\t\t\t   struct shash_desc *shash)\n{\n\tif (maxsize == 0)\n\t\treturn 0;\n\n\tswitch (iov_iter_type(iter)) {\n\tcase ITER_BVEC:\n\t\treturn cifs_shash_bvec(iter, maxsize, shash);\n\tcase ITER_KVEC:\n\t\treturn cifs_shash_kvec(iter, maxsize, shash);\n\tcase ITER_XARRAY:\n\t\treturn cifs_shash_xarray(iter, maxsize, shash);\n\tdefault:\n\t\tpr_err(\"cifs_shash_iter(%u) unsupported\\n\", iov_iter_type(iter));\n\t\tWARN_ON_ONCE(1);\n\t\treturn -EIO;\n\t}\n}\n\nint __cifs_calc_signature(struct smb_rqst *rqst,\n\t\t\t  struct TCP_Server_Info *server, char *signature,\n\t\t\t  struct shash_desc *shash)\n{\n\tint i;\n\tssize_t rc;\n\tstruct kvec *iov = rqst->rq_iov;\n\tint n_vec = rqst->rq_nvec;\n\n\t \n\tif (!is_smb1(server)) {\n\t\tif (iov[0].iov_len <= 4)\n\t\t\treturn -EIO;\n\t\ti = 0;\n\t} else {\n\t\tif (n_vec < 2 || iov[0].iov_len != 4)\n\t\t\treturn -EIO;\n\t\ti = 1;  \n\t}\n\n\tfor (; i < n_vec; i++) {\n\t\tif (iov[i].iov_len == 0)\n\t\t\tcontinue;\n\t\tif (iov[i].iov_base == NULL) {\n\t\t\tcifs_dbg(VFS, \"null iovec entry\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\trc = crypto_shash_update(shash,\n\t\t\t\t\t iov[i].iov_base, iov[i].iov_len);\n\t\tif (rc) {\n\t\t\tcifs_dbg(VFS, \"%s: Could not update with payload\\n\",\n\t\t\t\t __func__);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = cifs_shash_iter(&rqst->rq_iter, iov_iter_count(&rqst->rq_iter), shash);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = crypto_shash_final(shash, signature);\n\tif (rc)\n\t\tcifs_dbg(VFS, \"%s: Could not generate hash\\n\", __func__);\n\n\treturn rc;\n}\n\n \nstatic int cifs_calc_signature(struct smb_rqst *rqst,\n\t\t\tstruct TCP_Server_Info *server, char *signature)\n{\n\tint rc;\n\n\tif (!rqst->rq_iov || !signature || !server)\n\t\treturn -EINVAL;\n\n\trc = cifs_alloc_hash(\"md5\", &server->secmech.md5);\n\tif (rc)\n\t\treturn -1;\n\n\trc = crypto_shash_init(server->secmech.md5);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not init md5\\n\", __func__);\n\t\treturn rc;\n\t}\n\n\trc = crypto_shash_update(server->secmech.md5,\n\t\tserver->session_key.response, server->session_key.len);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not update with response\\n\", __func__);\n\t\treturn rc;\n\t}\n\n\treturn __cifs_calc_signature(rqst, server, signature, server->secmech.md5);\n}\n\n \nint cifs_sign_rqst(struct smb_rqst *rqst, struct TCP_Server_Info *server,\n\t\t   __u32 *pexpected_response_sequence_number)\n{\n\tint rc = 0;\n\tchar smb_signature[20];\n\tstruct smb_hdr *cifs_pdu = (struct smb_hdr *)rqst->rq_iov[0].iov_base;\n\n\tif (rqst->rq_iov[0].iov_len != 4 ||\n\t    rqst->rq_iov[0].iov_base + 4 != rqst->rq_iov[1].iov_base)\n\t\treturn -EIO;\n\n\tif ((cifs_pdu == NULL) || (server == NULL))\n\t\treturn -EINVAL;\n\n\tspin_lock(&server->srv_lock);\n\tif (!(cifs_pdu->Flags2 & SMBFLG2_SECURITY_SIGNATURE) ||\n\t    server->tcpStatus == CifsNeedNegotiate) {\n\t\tspin_unlock(&server->srv_lock);\n\t\treturn rc;\n\t}\n\tspin_unlock(&server->srv_lock);\n\n\tif (!server->session_estab) {\n\t\tmemcpy(cifs_pdu->Signature.SecuritySignature, \"BSRSPYL\", 8);\n\t\treturn rc;\n\t}\n\n\tcifs_pdu->Signature.Sequence.SequenceNumber =\n\t\t\t\tcpu_to_le32(server->sequence_number);\n\tcifs_pdu->Signature.Sequence.Reserved = 0;\n\n\t*pexpected_response_sequence_number = ++server->sequence_number;\n\t++server->sequence_number;\n\n\trc = cifs_calc_signature(rqst, server, smb_signature);\n\tif (rc)\n\t\tmemset(cifs_pdu->Signature.SecuritySignature, 0, 8);\n\telse\n\t\tmemcpy(cifs_pdu->Signature.SecuritySignature, smb_signature, 8);\n\n\treturn rc;\n}\n\nint cifs_sign_smbv(struct kvec *iov, int n_vec, struct TCP_Server_Info *server,\n\t\t   __u32 *pexpected_response_sequence)\n{\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = n_vec };\n\n\treturn cifs_sign_rqst(&rqst, server, pexpected_response_sequence);\n}\n\n \nint cifs_sign_smb(struct smb_hdr *cifs_pdu, struct TCP_Server_Info *server,\n\t\t  __u32 *pexpected_response_sequence_number)\n{\n\tstruct kvec iov[2];\n\n\tiov[0].iov_base = cifs_pdu;\n\tiov[0].iov_len = 4;\n\tiov[1].iov_base = (char *)cifs_pdu + 4;\n\tiov[1].iov_len = be32_to_cpu(cifs_pdu->smb_buf_length);\n\n\treturn cifs_sign_smbv(iov, 2, server,\n\t\t\t      pexpected_response_sequence_number);\n}\n\nint cifs_verify_signature(struct smb_rqst *rqst,\n\t\t\t  struct TCP_Server_Info *server,\n\t\t\t  __u32 expected_sequence_number)\n{\n\tunsigned int rc;\n\tchar server_response_sig[8];\n\tchar what_we_think_sig_should_be[20];\n\tstruct smb_hdr *cifs_pdu = (struct smb_hdr *)rqst->rq_iov[0].iov_base;\n\n\tif (rqst->rq_iov[0].iov_len != 4 ||\n\t    rqst->rq_iov[0].iov_base + 4 != rqst->rq_iov[1].iov_base)\n\t\treturn -EIO;\n\n\tif (cifs_pdu == NULL || server == NULL)\n\t\treturn -EINVAL;\n\n\tif (!server->session_estab)\n\t\treturn 0;\n\n\tif (cifs_pdu->Command == SMB_COM_LOCKING_ANDX) {\n\t\tstruct smb_com_lock_req *pSMB =\n\t\t\t(struct smb_com_lock_req *)cifs_pdu;\n\t\tif (pSMB->LockType & LOCKING_ANDX_OPLOCK_RELEASE)\n\t\t\treturn 0;\n\t}\n\n\t \n\n\t \n\tif (memcmp(cifs_pdu->Signature.SecuritySignature, \"BSRSPYL \", 8) == 0)\n\t\tcifs_dbg(FYI, \"dummy signature received for smb command 0x%x\\n\",\n\t\t\t cifs_pdu->Command);\n\n\t \n\tmemcpy(server_response_sig, cifs_pdu->Signature.SecuritySignature, 8);\n\n\tcifs_pdu->Signature.Sequence.SequenceNumber =\n\t\t\t\t\tcpu_to_le32(expected_sequence_number);\n\tcifs_pdu->Signature.Sequence.Reserved = 0;\n\n\tcifs_server_lock(server);\n\trc = cifs_calc_signature(rqst, server, what_we_think_sig_should_be);\n\tcifs_server_unlock(server);\n\n\tif (rc)\n\t\treturn rc;\n\n \n\n\tif (memcmp(server_response_sig, what_we_think_sig_should_be, 8))\n\t\treturn -EACCES;\n\telse\n\t\treturn 0;\n\n}\n\n \nstatic int\nbuild_avpair_blob(struct cifs_ses *ses, const struct nls_table *nls_cp)\n{\n\tunsigned int dlen;\n\tunsigned int size = 2 * sizeof(struct ntlmssp2_name);\n\tchar *defdmname = \"WORKGROUP\";\n\tunsigned char *blobptr;\n\tstruct ntlmssp2_name *attrptr;\n\n\tif (!ses->domainName) {\n\t\tses->domainName = kstrdup(defdmname, GFP_KERNEL);\n\t\tif (!ses->domainName)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tdlen = strlen(ses->domainName);\n\n\t \n\tkfree_sensitive(ses->auth_key.response);\n\tses->auth_key.len = size + 2 * dlen;\n\tses->auth_key.response = kzalloc(ses->auth_key.len, GFP_KERNEL);\n\tif (!ses->auth_key.response) {\n\t\tses->auth_key.len = 0;\n\t\treturn -ENOMEM;\n\t}\n\n\tblobptr = ses->auth_key.response;\n\tattrptr = (struct ntlmssp2_name *) blobptr;\n\n\t \n\tattrptr->type = cpu_to_le16(NTLMSSP_AV_NB_DOMAIN_NAME);\n\tattrptr->length = cpu_to_le16(2 * dlen);\n\tblobptr = (unsigned char *)attrptr + sizeof(struct ntlmssp2_name);\n\tcifs_strtoUTF16((__le16 *)blobptr, ses->domainName, dlen, nls_cp);\n\n\treturn 0;\n}\n\n \nstatic int\nfind_domain_name(struct cifs_ses *ses, const struct nls_table *nls_cp)\n{\n\tunsigned int attrsize;\n\tunsigned int type;\n\tunsigned int onesize = sizeof(struct ntlmssp2_name);\n\tunsigned char *blobptr;\n\tunsigned char *blobend;\n\tstruct ntlmssp2_name *attrptr;\n\n\tif (!ses->auth_key.len || !ses->auth_key.response)\n\t\treturn 0;\n\n\tblobptr = ses->auth_key.response;\n\tblobend = blobptr + ses->auth_key.len;\n\n\twhile (blobptr + onesize < blobend) {\n\t\tattrptr = (struct ntlmssp2_name *) blobptr;\n\t\ttype = le16_to_cpu(attrptr->type);\n\t\tif (type == NTLMSSP_AV_EOL)\n\t\t\tbreak;\n\t\tblobptr += 2;  \n\t\tattrsize = le16_to_cpu(attrptr->length);\n\t\tblobptr += 2;  \n\t\tif (blobptr + attrsize > blobend)\n\t\t\tbreak;\n\t\tif (type == NTLMSSP_AV_NB_DOMAIN_NAME) {\n\t\t\tif (!attrsize || attrsize >= CIFS_MAX_DOMAINNAME_LEN)\n\t\t\t\tbreak;\n\t\t\tif (!ses->domainName) {\n\t\t\t\tses->domainName =\n\t\t\t\t\tkmalloc(attrsize + 1, GFP_KERNEL);\n\t\t\t\tif (!ses->domainName)\n\t\t\t\t\t\treturn -ENOMEM;\n\t\t\t\tcifs_from_utf16(ses->domainName,\n\t\t\t\t\t(__le16 *)blobptr, attrsize, attrsize,\n\t\t\t\t\tnls_cp, NO_MAP_UNI_RSVD);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tblobptr += attrsize;  \n\t}\n\n\treturn 0;\n}\n\n \nstatic __le64\nfind_timestamp(struct cifs_ses *ses)\n{\n\tunsigned int attrsize;\n\tunsigned int type;\n\tunsigned int onesize = sizeof(struct ntlmssp2_name);\n\tunsigned char *blobptr;\n\tunsigned char *blobend;\n\tstruct ntlmssp2_name *attrptr;\n\tstruct timespec64 ts;\n\n\tif (!ses->auth_key.len || !ses->auth_key.response)\n\t\treturn 0;\n\n\tblobptr = ses->auth_key.response;\n\tblobend = blobptr + ses->auth_key.len;\n\n\twhile (blobptr + onesize < blobend) {\n\t\tattrptr = (struct ntlmssp2_name *) blobptr;\n\t\ttype = le16_to_cpu(attrptr->type);\n\t\tif (type == NTLMSSP_AV_EOL)\n\t\t\tbreak;\n\t\tblobptr += 2;  \n\t\tattrsize = le16_to_cpu(attrptr->length);\n\t\tblobptr += 2;  \n\t\tif (blobptr + attrsize > blobend)\n\t\t\tbreak;\n\t\tif (type == NTLMSSP_AV_TIMESTAMP) {\n\t\t\tif (attrsize == sizeof(u64))\n\t\t\t\treturn *((__le64 *)blobptr);\n\t\t}\n\t\tblobptr += attrsize;  \n\t}\n\n\tktime_get_real_ts64(&ts);\n\treturn cpu_to_le64(cifs_UnixTimeToNT(ts));\n}\n\nstatic int calc_ntlmv2_hash(struct cifs_ses *ses, char *ntlmv2_hash,\n\t\t\t    const struct nls_table *nls_cp)\n{\n\tint rc = 0;\n\tint len;\n\tchar nt_hash[CIFS_NTHASH_SIZE];\n\t__le16 *user;\n\twchar_t *domain;\n\twchar_t *server;\n\n\tif (!ses->server->secmech.hmacmd5) {\n\t\tcifs_dbg(VFS, \"%s: can't generate ntlmv2 hash\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\t \n\tE_md4hash(ses->password, nt_hash, nls_cp);\n\n\trc = crypto_shash_setkey(ses->server->secmech.hmacmd5->tfm, nt_hash,\n\t\t\t\tCIFS_NTHASH_SIZE);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not set NT Hash as a key\\n\", __func__);\n\t\treturn rc;\n\t}\n\n\trc = crypto_shash_init(ses->server->secmech.hmacmd5);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not init hmacmd5\\n\", __func__);\n\t\treturn rc;\n\t}\n\n\t \n\tlen = ses->user_name ? strlen(ses->user_name) : 0;\n\tuser = kmalloc(2 + (len * 2), GFP_KERNEL);\n\tif (user == NULL) {\n\t\trc = -ENOMEM;\n\t\treturn rc;\n\t}\n\n\tif (len) {\n\t\tlen = cifs_strtoUTF16(user, ses->user_name, len, nls_cp);\n\t\tUniStrupr(user);\n\t} else {\n\t\tmemset(user, '\\0', 2);\n\t}\n\n\trc = crypto_shash_update(ses->server->secmech.hmacmd5,\n\t\t\t\t(char *)user, 2 * len);\n\tkfree(user);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not update with user\\n\", __func__);\n\t\treturn rc;\n\t}\n\n\t \n\tif (ses->domainName) {\n\t\tlen = strlen(ses->domainName);\n\n\t\tdomain = kmalloc(2 + (len * 2), GFP_KERNEL);\n\t\tif (domain == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\treturn rc;\n\t\t}\n\t\tlen = cifs_strtoUTF16((__le16 *)domain, ses->domainName, len,\n\t\t\t\t      nls_cp);\n\t\trc =\n\t\tcrypto_shash_update(ses->server->secmech.hmacmd5,\n\t\t\t\t\t(char *)domain, 2 * len);\n\t\tkfree(domain);\n\t\tif (rc) {\n\t\t\tcifs_dbg(VFS, \"%s: Could not update with domain\\n\",\n\t\t\t\t __func__);\n\t\t\treturn rc;\n\t\t}\n\t} else {\n\t\t \n\t\tlen = strlen(ses->ip_addr);\n\n\t\tserver = kmalloc(2 + (len * 2), GFP_KERNEL);\n\t\tif (server == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\treturn rc;\n\t\t}\n\t\tlen = cifs_strtoUTF16((__le16 *)server, ses->ip_addr, len,\n\t\t\t\t\tnls_cp);\n\t\trc =\n\t\tcrypto_shash_update(ses->server->secmech.hmacmd5,\n\t\t\t\t\t(char *)server, 2 * len);\n\t\tkfree(server);\n\t\tif (rc) {\n\t\t\tcifs_dbg(VFS, \"%s: Could not update with server\\n\",\n\t\t\t\t __func__);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = crypto_shash_final(ses->server->secmech.hmacmd5,\n\t\t\t\t\tntlmv2_hash);\n\tif (rc)\n\t\tcifs_dbg(VFS, \"%s: Could not generate md5 hash\\n\", __func__);\n\n\treturn rc;\n}\n\nstatic int\nCalcNTLMv2_response(const struct cifs_ses *ses, char *ntlmv2_hash)\n{\n\tint rc;\n\tstruct ntlmv2_resp *ntlmv2 = (struct ntlmv2_resp *)\n\t    (ses->auth_key.response + CIFS_SESS_KEY_SIZE);\n\tunsigned int hash_len;\n\n\t \n\thash_len = ses->auth_key.len - (CIFS_SESS_KEY_SIZE +\n\t\toffsetof(struct ntlmv2_resp, challenge.key[0]));\n\n\tif (!ses->server->secmech.hmacmd5) {\n\t\tcifs_dbg(VFS, \"%s: can't generate ntlmv2 hash\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\trc = crypto_shash_setkey(ses->server->secmech.hmacmd5->tfm,\n\t\t\t\t ntlmv2_hash, CIFS_HMAC_MD5_HASH_SIZE);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not set NTLMV2 Hash as a key\\n\",\n\t\t\t __func__);\n\t\treturn rc;\n\t}\n\n\trc = crypto_shash_init(ses->server->secmech.hmacmd5);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not init hmacmd5\\n\", __func__);\n\t\treturn rc;\n\t}\n\n\tif (ses->server->negflavor == CIFS_NEGFLAVOR_EXTENDED)\n\t\tmemcpy(ntlmv2->challenge.key,\n\t\t       ses->ntlmssp->cryptkey, CIFS_SERVER_CHALLENGE_SIZE);\n\telse\n\t\tmemcpy(ntlmv2->challenge.key,\n\t\t       ses->server->cryptkey, CIFS_SERVER_CHALLENGE_SIZE);\n\trc = crypto_shash_update(ses->server->secmech.hmacmd5,\n\t\t\t\t ntlmv2->challenge.key, hash_len);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not update with response\\n\", __func__);\n\t\treturn rc;\n\t}\n\n\t \n\trc = crypto_shash_final(ses->server->secmech.hmacmd5,\n\t\t\t\tntlmv2->ntlmv2_hash);\n\tif (rc)\n\t\tcifs_dbg(VFS, \"%s: Could not generate md5 hash\\n\", __func__);\n\n\treturn rc;\n}\n\nint\nsetup_ntlmv2_rsp(struct cifs_ses *ses, const struct nls_table *nls_cp)\n{\n\tint rc;\n\tint baselen;\n\tunsigned int tilen;\n\tstruct ntlmv2_resp *ntlmv2;\n\tchar ntlmv2_hash[16];\n\tunsigned char *tiblob = NULL;  \n\t__le64 rsp_timestamp;\n\n\tif (nls_cp == NULL) {\n\t\tcifs_dbg(VFS, \"%s called with nls_cp==NULL\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ses->server->negflavor == CIFS_NEGFLAVOR_EXTENDED) {\n\t\tif (!ses->domainName) {\n\t\t\tif (ses->domainAuto) {\n\t\t\t\trc = find_domain_name(ses, nls_cp);\n\t\t\t\tif (rc) {\n\t\t\t\t\tcifs_dbg(VFS, \"error %d finding domain name\\n\",\n\t\t\t\t\t\t rc);\n\t\t\t\t\tgoto setup_ntlmv2_rsp_ret;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tses->domainName = kstrdup(\"\", GFP_KERNEL);\n\t\t\t}\n\t\t}\n\t} else {\n\t\trc = build_avpair_blob(ses, nls_cp);\n\t\tif (rc) {\n\t\t\tcifs_dbg(VFS, \"error %d building av pair blob\\n\", rc);\n\t\t\tgoto setup_ntlmv2_rsp_ret;\n\t\t}\n\t}\n\n\t \n\trsp_timestamp = find_timestamp(ses);\n\n\tbaselen = CIFS_SESS_KEY_SIZE + sizeof(struct ntlmv2_resp);\n\ttilen = ses->auth_key.len;\n\ttiblob = ses->auth_key.response;\n\n\tses->auth_key.response = kmalloc(baselen + tilen, GFP_KERNEL);\n\tif (!ses->auth_key.response) {\n\t\trc = -ENOMEM;\n\t\tses->auth_key.len = 0;\n\t\tgoto setup_ntlmv2_rsp_ret;\n\t}\n\tses->auth_key.len += baselen;\n\n\tntlmv2 = (struct ntlmv2_resp *)\n\t\t\t(ses->auth_key.response + CIFS_SESS_KEY_SIZE);\n\tntlmv2->blob_signature = cpu_to_le32(0x00000101);\n\tntlmv2->reserved = 0;\n\tntlmv2->time = rsp_timestamp;\n\n\tget_random_bytes(&ntlmv2->client_chal, sizeof(ntlmv2->client_chal));\n\tntlmv2->reserved2 = 0;\n\n\tmemcpy(ses->auth_key.response + baselen, tiblob, tilen);\n\n\tcifs_server_lock(ses->server);\n\n\trc = cifs_alloc_hash(\"hmac(md5)\", &ses->server->secmech.hmacmd5);\n\tif (rc) {\n\t\tgoto unlock;\n\t}\n\n\t \n\trc = calc_ntlmv2_hash(ses, ntlmv2_hash, nls_cp);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"Could not get v2 hash rc %d\\n\", rc);\n\t\tgoto unlock;\n\t}\n\n\t \n\trc = CalcNTLMv2_response(ses, ntlmv2_hash);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"Could not calculate CR1 rc: %d\\n\", rc);\n\t\tgoto unlock;\n\t}\n\n\t \n\trc = crypto_shash_setkey(ses->server->secmech.hmacmd5->tfm,\n\t\tntlmv2_hash, CIFS_HMAC_MD5_HASH_SIZE);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not set NTLMV2 Hash as a key\\n\",\n\t\t\t __func__);\n\t\tgoto unlock;\n\t}\n\n\trc = crypto_shash_init(ses->server->secmech.hmacmd5);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not init hmacmd5\\n\", __func__);\n\t\tgoto unlock;\n\t}\n\n\trc = crypto_shash_update(ses->server->secmech.hmacmd5,\n\t\tntlmv2->ntlmv2_hash,\n\t\tCIFS_HMAC_MD5_HASH_SIZE);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not update with response\\n\", __func__);\n\t\tgoto unlock;\n\t}\n\n\trc = crypto_shash_final(ses->server->secmech.hmacmd5,\n\t\tses->auth_key.response);\n\tif (rc)\n\t\tcifs_dbg(VFS, \"%s: Could not generate md5 hash\\n\", __func__);\n\nunlock:\n\tcifs_server_unlock(ses->server);\nsetup_ntlmv2_rsp_ret:\n\tkfree_sensitive(tiblob);\n\n\treturn rc;\n}\n\nint\ncalc_seckey(struct cifs_ses *ses)\n{\n\tunsigned char sec_key[CIFS_SESS_KEY_SIZE];  \n\tstruct arc4_ctx *ctx_arc4;\n\n\tif (fips_enabled)\n\t\treturn -ENODEV;\n\n\tget_random_bytes(sec_key, CIFS_SESS_KEY_SIZE);\n\n\tctx_arc4 = kmalloc(sizeof(*ctx_arc4), GFP_KERNEL);\n\tif (!ctx_arc4) {\n\t\tcifs_dbg(VFS, \"Could not allocate arc4 context\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tcifs_arc4_setkey(ctx_arc4, ses->auth_key.response, CIFS_SESS_KEY_SIZE);\n\tcifs_arc4_crypt(ctx_arc4, ses->ntlmssp->ciphertext, sec_key,\n\t\t\tCIFS_CPHTXT_SIZE);\n\n\t \n\tmemcpy(ses->auth_key.response, sec_key, CIFS_SESS_KEY_SIZE);\n\t \n\tses->auth_key.len = CIFS_SESS_KEY_SIZE;\n\n\tmemzero_explicit(sec_key, CIFS_SESS_KEY_SIZE);\n\tkfree_sensitive(ctx_arc4);\n\treturn 0;\n}\n\nvoid\ncifs_crypto_secmech_release(struct TCP_Server_Info *server)\n{\n\tcifs_free_hash(&server->secmech.aes_cmac);\n\tcifs_free_hash(&server->secmech.hmacsha256);\n\tcifs_free_hash(&server->secmech.md5);\n\tcifs_free_hash(&server->secmech.sha512);\n\tcifs_free_hash(&server->secmech.hmacmd5);\n\n\tif (server->secmech.enc) {\n\t\tcrypto_free_aead(server->secmech.enc);\n\t\tserver->secmech.enc = NULL;\n\t}\n\n\tif (server->secmech.dec) {\n\t\tcrypto_free_aead(server->secmech.dec);\n\t\tserver->secmech.dec = NULL;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}