{
  "module_name": "dir.c",
  "hash_id": "6c753fb19cad9c21731e89b1c33b524c6cb2982080da387318269b4f1010ab42",
  "original_prompt": "Ingested from linux-6.6.14/fs/smb/client/dir.c",
  "human_readable_source": "\n \n#include <linux/fs.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include \"cifsfs.h\"\n#include \"cifspdu.h\"\n#include \"cifsglob.h\"\n#include \"cifsproto.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_unicode.h\"\n#include \"fs_context.h\"\n#include \"cifs_ioctl.h\"\n#include \"fscache.h\"\n\nstatic void\nrenew_parental_timestamps(struct dentry *direntry)\n{\n\t \n\tdo {\n\t\tcifs_set_time(direntry, jiffies);\n\t\tdirentry = direntry->d_parent;\n\t} while (!IS_ROOT(direntry));\n}\n\nchar *\ncifs_build_path_to_root(struct smb3_fs_context *ctx, struct cifs_sb_info *cifs_sb,\n\t\t\tstruct cifs_tcon *tcon, int add_treename)\n{\n\tint pplen = ctx->prepath ? strlen(ctx->prepath) + 1 : 0;\n\tint dfsplen;\n\tchar *full_path = NULL;\n\n\t \n\tif (pplen == 0) {\n\t\tfull_path = kzalloc(1, GFP_KERNEL);\n\t\treturn full_path;\n\t}\n\n\tif (add_treename)\n\t\tdfsplen = strnlen(tcon->tree_name, MAX_TREE_SIZE + 1);\n\telse\n\t\tdfsplen = 0;\n\n\tfull_path = kmalloc(dfsplen + pplen + 1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn full_path;\n\n\tif (dfsplen)\n\t\tmemcpy(full_path, tcon->tree_name, dfsplen);\n\tfull_path[dfsplen] = CIFS_DIR_SEP(cifs_sb);\n\tmemcpy(full_path + dfsplen + 1, ctx->prepath, pplen);\n\tconvert_delimiter(full_path, CIFS_DIR_SEP(cifs_sb));\n\treturn full_path;\n}\n\n \nconst char *\nbuild_path_from_dentry(struct dentry *direntry, void *page)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(direntry->d_sb);\n\tstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\n\tbool prefix = tcon->Flags & SMB_SHARE_IS_IN_DFS;\n\n\treturn build_path_from_dentry_optional_prefix(direntry, page,\n\t\t\t\t\t\t      prefix);\n}\n\nchar *__build_path_from_dentry_optional_prefix(struct dentry *direntry, void *page,\n\t\t\t\t\t       const char *tree, int tree_len,\n\t\t\t\t\t       bool prefix)\n{\n\tint dfsplen;\n\tint pplen = 0;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(direntry->d_sb);\n\tchar dirsep = CIFS_DIR_SEP(cifs_sb);\n\tchar *s;\n\n\tif (unlikely(!page))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (prefix)\n\t\tdfsplen = strnlen(tree, tree_len + 1);\n\telse\n\t\tdfsplen = 0;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_USE_PREFIX_PATH)\n\t\tpplen = cifs_sb->prepath ? strlen(cifs_sb->prepath) + 1 : 0;\n\n\ts = dentry_path_raw(direntry, page, PATH_MAX);\n\tif (IS_ERR(s))\n\t\treturn s;\n\tif (!s[1])\t\n\t\ts++;\n\tif (s < (char *)page + pplen + dfsplen)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\tif (pplen) {\n\t\tcifs_dbg(FYI, \"using cifs_sb prepath <%s>\\n\", cifs_sb->prepath);\n\t\ts -= pplen;\n\t\tmemcpy(s + 1, cifs_sb->prepath, pplen - 1);\n\t\t*s = '/';\n\t}\n\tif (dirsep != '/') {\n\t\t \n\t\tchar *p;\n\n\t\tfor (p = s; *p; p++)\n\t\t\tif (*p == '/')\n\t\t\t\t*p = dirsep;\n\t}\n\tif (dfsplen) {\n\t\ts -= dfsplen;\n\t\tmemcpy(s, tree, dfsplen);\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < dfsplen; i++) {\n\t\t\t\tif (s[i] == '\\\\')\n\t\t\t\t\ts[i] = '/';\n\t\t\t}\n\t\t}\n\t}\n\treturn s;\n}\n\nchar *build_path_from_dentry_optional_prefix(struct dentry *direntry, void *page,\n\t\t\t\t\t     bool prefix)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(direntry->d_sb);\n\tstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\n\n\treturn __build_path_from_dentry_optional_prefix(direntry, page, tcon->tree_name,\n\t\t\t\t\t\t\tMAX_TREE_SIZE, prefix);\n}\n\n \nstatic int\ncheck_name(struct dentry *direntry, struct cifs_tcon *tcon)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(direntry->d_sb);\n\tint i;\n\n\tif (unlikely(tcon->fsAttrInfo.MaxPathNameComponentLength &&\n\t\t     direntry->d_name.len >\n\t\t     le32_to_cpu(tcon->fsAttrInfo.MaxPathNameComponentLength)))\n\t\treturn -ENAMETOOLONG;\n\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)) {\n\t\tfor (i = 0; i < direntry->d_name.len; i++) {\n\t\t\tif (direntry->d_name.name[i] == '\\\\') {\n\t\t\t\tcifs_dbg(FYI, \"Invalid file name\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n \n\nstatic int cifs_do_create(struct inode *inode, struct dentry *direntry, unsigned int xid,\n\t\t\t  struct tcon_link *tlink, unsigned int oflags, umode_t mode, __u32 *oplock,\n\t\t\t  struct cifs_fid *fid, struct cifs_open_info_data *buf)\n{\n\tint rc = -ENOENT;\n\tint create_options = CREATE_NOT_DIR;\n\tint desired_access;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct cifs_tcon *tcon = tlink_tcon(tlink);\n\tconst char *full_path;\n\tvoid *page = alloc_dentry_path();\n\tstruct inode *newinode = NULL;\n\tint disposition;\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tstruct cifs_open_parms oparms;\n\n\t*oplock = 0;\n\tif (tcon->ses->server->oplocks)\n\t\t*oplock = REQ_OPLOCK;\n\n\tfull_path = build_path_from_dentry(direntry, page);\n\tif (IS_ERR(full_path)) {\n\t\tfree_dentry_path(page);\n\t\treturn PTR_ERR(full_path);\n\t}\n\n#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY\n\tif (tcon->unix_ext && cap_unix(tcon->ses) && !tcon->broken_posix_open &&\n\t    (CIFS_UNIX_POSIX_PATH_OPS_CAP &\n\t\t\tle64_to_cpu(tcon->fsUnixInfo.Capability))) {\n\t\trc = cifs_posix_open(full_path, &newinode, inode->i_sb, mode,\n\t\t\t\t     oflags, oplock, &fid->netfid, xid);\n\t\tswitch (rc) {\n\t\tcase 0:\n\t\t\tif (newinode == NULL) {\n\t\t\t\t \n\t\t\t\tgoto cifs_create_get_file_info;\n\t\t\t}\n\n\t\t\tif (S_ISDIR(newinode->i_mode)) {\n\t\t\t\tCIFSSMBClose(xid, tcon, fid->netfid);\n\t\t\t\tiput(newinode);\n\t\t\t\trc = -EISDIR;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (!S_ISREG(newinode->i_mode)) {\n\t\t\t\t \n\t\t\t\tCIFSSMBClose(xid, tcon, fid->netfid);\n\t\t\t\tgoto cifs_create_get_file_info;\n\t\t\t}\n\t\t\t \n\t\t\tgoto cifs_create_set_dentry;\n\n\t\tcase -ENOENT:\n\t\t\tgoto cifs_create_get_file_info;\n\n\t\tcase -EIO:\n\t\tcase -EINVAL:\n\t\t\t \n\t\t\ttcon->broken_posix_open = true;\n\t\t\tbreak;\n\n\t\tcase -EREMOTE:\n\t\tcase -EOPNOTSUPP:\n\t\t\t \n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t}\n#endif  \n\n\tdesired_access = 0;\n\tif (OPEN_FMODE(oflags) & FMODE_READ)\n\t\tdesired_access |= GENERIC_READ;  \n\tif (OPEN_FMODE(oflags) & FMODE_WRITE)\n\t\tdesired_access |= GENERIC_WRITE;\n\n\tdisposition = FILE_OVERWRITE_IF;\n\tif ((oflags & (O_CREAT | O_EXCL)) == (O_CREAT | O_EXCL))\n\t\tdisposition = FILE_CREATE;\n\telse if ((oflags & (O_CREAT | O_TRUNC)) == (O_CREAT | O_TRUNC))\n\t\tdisposition = FILE_OVERWRITE_IF;\n\telse if ((oflags & O_CREAT) == O_CREAT)\n\t\tdisposition = FILE_OPEN_IF;\n\telse\n\t\tcifs_dbg(FYI, \"Create flag not set in create function\\n\");\n\n\t \n\n\tif (!server->ops->open) {\n\t\trc = -ENOSYS;\n\t\tgoto out;\n\t}\n\n\t \n\tif (!tcon->unix_ext && (mode & S_IWUGO) == 0)\n\t\tcreate_options |= CREATE_OPTION_READONLY;\n\n\toparms = (struct cifs_open_parms) {\n\t\t.tcon = tcon,\n\t\t.cifs_sb = cifs_sb,\n\t\t.desired_access = desired_access,\n\t\t.create_options = cifs_create_options(cifs_sb, create_options),\n\t\t.disposition = disposition,\n\t\t.path = full_path,\n\t\t.fid = fid,\n\t\t.mode = mode,\n\t};\n\trc = server->ops->open(xid, &oparms, oplock, buf);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"cifs_create returned 0x%x\\n\", rc);\n\t\tgoto out;\n\t}\n\n#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY\n\t \n\tif ((tcon->unix_ext) && (*oplock & CIFS_CREATE_ACTION)) {\n\t\tstruct cifs_unix_set_info_args args = {\n\t\t\t\t.mode\t= mode,\n\t\t\t\t.ctime\t= NO_CHANGE_64,\n\t\t\t\t.atime\t= NO_CHANGE_64,\n\t\t\t\t.mtime\t= NO_CHANGE_64,\n\t\t\t\t.device\t= 0,\n\t\t};\n\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SET_UID) {\n\t\t\targs.uid = current_fsuid();\n\t\t\tif (inode->i_mode & S_ISGID)\n\t\t\t\targs.gid = inode->i_gid;\n\t\t\telse\n\t\t\t\targs.gid = current_fsgid();\n\t\t} else {\n\t\t\targs.uid = INVALID_UID;  \n\t\t\targs.gid = INVALID_GID;  \n\t\t}\n\t\tCIFSSMBUnixSetFileInfo(xid, tcon, &args, fid->netfid,\n\t\t\t\t       current->tgid);\n\t} else {\n\t\t \n\t\t \n\n\t\t \n\t}\n\ncifs_create_get_file_info:\n\t \n\tif (tcon->unix_ext)\n\t\trc = cifs_get_inode_info_unix(&newinode, full_path, inode->i_sb,\n\t\t\t\t\t      xid);\n\telse {\n#else\n\t{\n#endif  \n\t\t \n\t\trc = cifs_get_inode_info(&newinode, full_path, buf, inode->i_sb, xid, fid);\n\t\tif (newinode) {\n\t\t\tif (server->ops->set_lease_key)\n\t\t\t\tserver->ops->set_lease_key(newinode, fid);\n\t\t\tif ((*oplock & CIFS_CREATE_ACTION) && S_ISREG(newinode->i_mode)) {\n\t\t\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DYNPERM)\n\t\t\t\t\tnewinode->i_mode = mode;\n\t\t\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SET_UID) {\n\t\t\t\t\tnewinode->i_uid = current_fsuid();\n\t\t\t\t\tif (inode->i_mode & S_ISGID)\n\t\t\t\t\t\tnewinode->i_gid = inode->i_gid;\n\t\t\t\t\telse\n\t\t\t\t\t\tnewinode->i_gid = current_fsgid();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY\ncifs_create_set_dentry:\n#endif  \n\tif (rc != 0) {\n\t\tcifs_dbg(FYI, \"Create worked, get_inode_info failed rc = %d\\n\",\n\t\t\t rc);\n\t\tgoto out_err;\n\t}\n\n\tif (newinode)\n\t\tif (S_ISDIR(newinode->i_mode)) {\n\t\t\trc = -EISDIR;\n\t\t\tgoto out_err;\n\t\t}\n\n\td_drop(direntry);\n\td_add(direntry, newinode);\n\nout:\n\tfree_dentry_path(page);\n\treturn rc;\n\nout_err:\n\tif (server->ops->close)\n\t\tserver->ops->close(xid, tcon, fid);\n\tif (newinode)\n\t\tiput(newinode);\n\tgoto out;\n}\n\nint\ncifs_atomic_open(struct inode *inode, struct dentry *direntry,\n\t\t struct file *file, unsigned oflags, umode_t mode)\n{\n\tint rc;\n\tunsigned int xid;\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_fid fid = {};\n\tstruct cifs_pending_open open;\n\t__u32 oplock;\n\tstruct cifsFileInfo *file_info;\n\tstruct cifs_open_info_data buf = {};\n\n\tif (unlikely(cifs_forced_shutdown(CIFS_SB(inode->i_sb))))\n\t\treturn -EIO;\n\n\t \n\tif (!(oflags & O_CREAT)) {\n\t\tstruct dentry *res;\n\n\t\t \n\t\tif (!d_in_lookup(direntry))\n\t\t\treturn -ENOENT;\n\n\t\tres = cifs_lookup(inode, direntry, 0);\n\t\tif (IS_ERR(res))\n\t\t\treturn PTR_ERR(res);\n\n\t\treturn finish_no_open(file, res);\n\t}\n\n\txid = get_xid();\n\n\tcifs_dbg(FYI, \"parent inode = 0x%p name is: %pd and dentry = 0x%p\\n\",\n\t\t inode, direntry, direntry);\n\n\ttlink = cifs_sb_tlink(CIFS_SB(inode->i_sb));\n\tif (IS_ERR(tlink)) {\n\t\trc = PTR_ERR(tlink);\n\t\tgoto out_free_xid;\n\t}\n\n\ttcon = tlink_tcon(tlink);\n\n\trc = check_name(direntry, tcon);\n\tif (rc)\n\t\tgoto out;\n\n\tserver = tcon->ses->server;\n\n\tif (server->ops->new_lease_key)\n\t\tserver->ops->new_lease_key(&fid);\n\n\tcifs_add_pending_open(&fid, tlink, &open);\n\n\trc = cifs_do_create(inode, direntry, xid, tlink, oflags, mode,\n\t\t\t    &oplock, &fid, &buf);\n\tif (rc) {\n\t\tcifs_del_pending_open(&open);\n\t\tgoto out;\n\t}\n\n\tif ((oflags & (O_CREAT | O_EXCL)) == (O_CREAT | O_EXCL))\n\t\tfile->f_mode |= FMODE_CREATED;\n\n\trc = finish_open(file, direntry, generic_file_open);\n\tif (rc) {\n\t\tif (server->ops->close)\n\t\t\tserver->ops->close(xid, tcon, &fid);\n\t\tcifs_del_pending_open(&open);\n\t\tgoto out;\n\t}\n\n\tif (file->f_flags & O_DIRECT &&\n\t    CIFS_SB(inode->i_sb)->mnt_cifs_flags & CIFS_MOUNT_STRICT_IO) {\n\t\tif (CIFS_SB(inode->i_sb)->mnt_cifs_flags & CIFS_MOUNT_NO_BRL)\n\t\t\tfile->f_op = &cifs_file_direct_nobrl_ops;\n\t\telse\n\t\t\tfile->f_op = &cifs_file_direct_ops;\n\t\t}\n\n\tfile_info = cifs_new_fileinfo(&fid, file, tlink, oplock, buf.symlink_target);\n\tif (file_info == NULL) {\n\t\tif (server->ops->close)\n\t\t\tserver->ops->close(xid, tcon, &fid);\n\t\tcifs_del_pending_open(&open);\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tfscache_use_cookie(cifs_inode_cookie(file_inode(file)),\n\t\t\t   file->f_mode & FMODE_WRITE);\n\nout:\n\tcifs_put_tlink(tlink);\nout_free_xid:\n\tfree_xid(xid);\n\tcifs_free_open_info(&buf);\n\treturn rc;\n}\n\nint cifs_create(struct mnt_idmap *idmap, struct inode *inode,\n\t\tstruct dentry *direntry, umode_t mode, bool excl)\n{\n\tint rc;\n\tunsigned int xid = get_xid();\n\t \n\tunsigned oflags = O_EXCL | O_CREAT | O_RDWR;\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_fid fid;\n\t__u32 oplock;\n\tstruct cifs_open_info_data buf = {};\n\n\tcifs_dbg(FYI, \"cifs_create parent inode = 0x%p name is: %pd and dentry = 0x%p\\n\",\n\t\t inode, direntry, direntry);\n\n\tif (unlikely(cifs_forced_shutdown(CIFS_SB(inode->i_sb)))) {\n\t\trc = -EIO;\n\t\tgoto out_free_xid;\n\t}\n\n\ttlink = cifs_sb_tlink(CIFS_SB(inode->i_sb));\n\trc = PTR_ERR(tlink);\n\tif (IS_ERR(tlink))\n\t\tgoto out_free_xid;\n\n\ttcon = tlink_tcon(tlink);\n\tserver = tcon->ses->server;\n\n\tif (server->ops->new_lease_key)\n\t\tserver->ops->new_lease_key(&fid);\n\n\trc = cifs_do_create(inode, direntry, xid, tlink, oflags, mode, &oplock, &fid, &buf);\n\tif (!rc && server->ops->close)\n\t\tserver->ops->close(xid, tcon, &fid);\n\n\tcifs_free_open_info(&buf);\n\tcifs_put_tlink(tlink);\nout_free_xid:\n\tfree_xid(xid);\n\treturn rc;\n}\n\nint cifs_mknod(struct mnt_idmap *idmap, struct inode *inode,\n\t       struct dentry *direntry, umode_t mode, dev_t device_number)\n{\n\tint rc = -EPERM;\n\tunsigned int xid;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *tcon;\n\tconst char *full_path;\n\tvoid *page;\n\n\tif (!old_valid_dev(device_number))\n\t\treturn -EINVAL;\n\n\tcifs_sb = CIFS_SB(inode->i_sb);\n\tif (unlikely(cifs_forced_shutdown(cifs_sb)))\n\t\treturn -EIO;\n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\n\tpage = alloc_dentry_path();\n\ttcon = tlink_tcon(tlink);\n\txid = get_xid();\n\n\tfull_path = build_path_from_dentry(direntry, page);\n\tif (IS_ERR(full_path)) {\n\t\trc = PTR_ERR(full_path);\n\t\tgoto mknod_out;\n\t}\n\n\trc = tcon->ses->server->ops->make_node(xid, inode, direntry, tcon,\n\t\t\t\t\t       full_path, mode,\n\t\t\t\t\t       device_number);\n\nmknod_out:\n\tfree_dentry_path(page);\n\tfree_xid(xid);\n\tcifs_put_tlink(tlink);\n\treturn rc;\n}\n\nstruct dentry *\ncifs_lookup(struct inode *parent_dir_inode, struct dentry *direntry,\n\t    unsigned int flags)\n{\n\tunsigned int xid;\n\tint rc = 0;  \n\tstruct cifs_sb_info *cifs_sb;\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *pTcon;\n\tstruct inode *newInode = NULL;\n\tconst char *full_path;\n\tvoid *page;\n\tint retry_count = 0;\n\n\txid = get_xid();\n\n\tcifs_dbg(FYI, \"parent inode = 0x%p name is: %pd and dentry = 0x%p\\n\",\n\t\t parent_dir_inode, direntry, direntry);\n\n\t \n\n\tcifs_sb = CIFS_SB(parent_dir_inode->i_sb);\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink)) {\n\t\tfree_xid(xid);\n\t\treturn ERR_CAST(tlink);\n\t}\n\tpTcon = tlink_tcon(tlink);\n\n\trc = check_name(direntry, pTcon);\n\tif (unlikely(rc)) {\n\t\tcifs_put_tlink(tlink);\n\t\tfree_xid(xid);\n\t\treturn ERR_PTR(rc);\n\t}\n\n\t \n\tpage = alloc_dentry_path();\n\tfull_path = build_path_from_dentry(direntry, page);\n\tif (IS_ERR(full_path)) {\n\t\tcifs_put_tlink(tlink);\n\t\tfree_xid(xid);\n\t\tfree_dentry_path(page);\n\t\treturn ERR_CAST(full_path);\n\t}\n\n\tif (d_really_is_positive(direntry)) {\n\t\tcifs_dbg(FYI, \"non-NULL inode in lookup\\n\");\n\t} else {\n\t\tcifs_dbg(FYI, \"NULL inode in lookup\\n\");\n\t}\n\tcifs_dbg(FYI, \"Full path: %s inode = 0x%p\\n\",\n\t\t full_path, d_inode(direntry));\n\nagain:\n\tif (pTcon->posix_extensions)\n\t\trc = smb311_posix_get_inode_info(&newInode, full_path, parent_dir_inode->i_sb, xid);\n\telse if (pTcon->unix_ext) {\n\t\trc = cifs_get_inode_info_unix(&newInode, full_path,\n\t\t\t\t\t      parent_dir_inode->i_sb, xid);\n\t} else {\n\t\trc = cifs_get_inode_info(&newInode, full_path, NULL,\n\t\t\t\tparent_dir_inode->i_sb, xid, NULL);\n\t}\n\n\tif (rc == 0) {\n\t\t \n\t\trenew_parental_timestamps(direntry);\n\t} else if (rc == -EAGAIN && retry_count++ < 10) {\n\t\tgoto again;\n\t} else if (rc == -ENOENT) {\n\t\tcifs_set_time(direntry, jiffies);\n\t\tnewInode = NULL;\n\t} else {\n\t\tif (rc != -EACCES) {\n\t\t\tcifs_dbg(FYI, \"Unexpected lookup error %d\\n\", rc);\n\t\t\t \n\t\t}\n\t\tnewInode = ERR_PTR(rc);\n\t}\n\tfree_dentry_path(page);\n\tcifs_put_tlink(tlink);\n\tfree_xid(xid);\n\treturn d_splice_alias(newInode, direntry);\n}\n\nstatic int\ncifs_d_revalidate(struct dentry *direntry, unsigned int flags)\n{\n\tstruct inode *inode;\n\tint rc;\n\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\tif (d_really_is_positive(direntry)) {\n\t\tinode = d_inode(direntry);\n\t\tif ((flags & LOOKUP_REVAL) && !CIFS_CACHE_READ(CIFS_I(inode)))\n\t\t\tCIFS_I(inode)->time = 0;  \n\n\t\trc = cifs_revalidate_dentry(direntry);\n\t\tif (rc) {\n\t\t\tcifs_dbg(FYI, \"cifs_revalidate_dentry failed with rc=%d\", rc);\n\t\t\tswitch (rc) {\n\t\t\tcase -ENOENT:\n\t\t\tcase -ESTALE:\n\t\t\t\t \n\t\t\t\treturn 0;\n\t\t\tdefault:\n\t\t\t\t \n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t \n\t\t\tif (IS_AUTOMOUNT(inode) &&\n\t\t\t   !(direntry->d_flags & DCACHE_NEED_AUTOMOUNT)) {\n\t\t\t\tspin_lock(&direntry->d_lock);\n\t\t\t\tdirentry->d_flags |= DCACHE_NEED_AUTOMOUNT;\n\t\t\t\tspin_unlock(&direntry->d_lock);\n\t\t\t}\n\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t \n\tif (!flags)\n\t\treturn 0;\n\n\t \n\tif (flags & (LOOKUP_CREATE | LOOKUP_RENAME_TARGET))\n\t\treturn 0;\n\n\tif (time_after(jiffies, cifs_get_time(direntry) + HZ) || !lookupCacheEnabled)\n\t\treturn 0;\n\n\treturn 1;\n}\n\n \n\nconst struct dentry_operations cifs_dentry_ops = {\n\t.d_revalidate = cifs_d_revalidate,\n\t.d_automount = cifs_d_automount,\n   \n};\n\nstatic int cifs_ci_hash(const struct dentry *dentry, struct qstr *q)\n{\n\tstruct nls_table *codepage = CIFS_SB(dentry->d_sb)->local_nls;\n\tunsigned long hash;\n\twchar_t c;\n\tint i, charlen;\n\n\thash = init_name_hash(dentry);\n\tfor (i = 0; i < q->len; i += charlen) {\n\t\tcharlen = codepage->char2uni(&q->name[i], q->len - i, &c);\n\t\t \n\t\tif (unlikely(charlen < 0))\n\t\t\treturn charlen;\n\t\thash = partial_name_hash(cifs_toupper(c), hash);\n\t}\n\tq->hash = end_name_hash(hash);\n\n\treturn 0;\n}\n\nstatic int cifs_ci_compare(const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name)\n{\n\tstruct nls_table *codepage = CIFS_SB(dentry->d_sb)->local_nls;\n\twchar_t c1, c2;\n\tint i, l1, l2;\n\n\t \n\tif (name->len != len)\n\t\treturn 1;\n\n\tfor (i = 0; i < len; i += l1) {\n\t\t \n\t\tl1 = codepage->char2uni(&str[i], len - i, &c1);\n\t\tl2 = codepage->char2uni(&name->name[i], name->len - i, &c2);\n\n\t\t \n\t\tif (unlikely(l1 < 0 && l2 < 0)) {\n\t\t\tif (str[i] != name->name[i])\n\t\t\t\treturn 1;\n\t\t\tl1 = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (l1 != l2)\n\t\t\treturn 1;\n\n\t\t \n\t\tif (cifs_toupper(c1) != cifs_toupper(c2))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nconst struct dentry_operations cifs_ci_dentry_ops = {\n\t.d_revalidate = cifs_d_revalidate,\n\t.d_hash = cifs_ci_hash,\n\t.d_compare = cifs_ci_compare,\n\t.d_automount = cifs_d_automount,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}