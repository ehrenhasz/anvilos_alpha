{
  "module_name": "cifs_unicode.c",
  "hash_id": "9ec02a0d28ea5ae84ac4f4b5dbeda89b49b5a309e3286870531d509e256e735e",
  "original_prompt": "Ingested from linux-6.6.14/fs/smb/client/cifs_unicode.c",
  "human_readable_source": "\n \n#include <linux/fs.h>\n#include <linux/slab.h>\n#include \"cifs_fs_sb.h\"\n#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifsglob.h\"\n#include \"cifs_debug.h\"\n\nint cifs_remap(struct cifs_sb_info *cifs_sb)\n{\n\tint map_type;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SFM_CHR)\n\t\tmap_type = SFM_MAP_UNI_RSVD;\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\n\t\tmap_type = SFU_MAP_UNI_RSVD;\n\telse\n\t\tmap_type = NO_MAP_UNI_RSVD;\n\n\treturn map_type;\n}\n\n \nstatic bool\nconvert_sfu_char(const __u16 src_char, char *target)\n{\n\t \n\tswitch (src_char) {\n\tcase UNI_COLON:\n\t\t*target = ':';\n\t\tbreak;\n\tcase UNI_ASTERISK:\n\t\t*target = '*';\n\t\tbreak;\n\tcase UNI_QUESTION:\n\t\t*target = '?';\n\t\tbreak;\n\tcase UNI_PIPE:\n\t\t*target = '|';\n\t\tbreak;\n\tcase UNI_GRTRTHAN:\n\t\t*target = '>';\n\t\tbreak;\n\tcase UNI_LESSTHAN:\n\t\t*target = '<';\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n \nstatic bool\nconvert_sfm_char(const __u16 src_char, char *target)\n{\n\tif (src_char >= 0xF001 && src_char <= 0xF01F) {\n\t\t*target = src_char - 0xF000;\n\t\treturn true;\n\t}\n\tswitch (src_char) {\n\tcase SFM_COLON:\n\t\t*target = ':';\n\t\tbreak;\n\tcase SFM_DOUBLEQUOTE:\n\t\t*target = '\"';\n\t\tbreak;\n\tcase SFM_ASTERISK:\n\t\t*target = '*';\n\t\tbreak;\n\tcase SFM_QUESTION:\n\t\t*target = '?';\n\t\tbreak;\n\tcase SFM_PIPE:\n\t\t*target = '|';\n\t\tbreak;\n\tcase SFM_GRTRTHAN:\n\t\t*target = '>';\n\t\tbreak;\n\tcase SFM_LESSTHAN:\n\t\t*target = '<';\n\t\tbreak;\n\tcase SFM_SPACE:\n\t\t*target = ' ';\n\t\tbreak;\n\tcase SFM_PERIOD:\n\t\t*target = '.';\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n\n \nstatic int\ncifs_mapchar(char *target, const __u16 *from, const struct nls_table *cp,\n\t     int maptype)\n{\n\tint len = 1;\n\t__u16 src_char;\n\n\tsrc_char = *from;\n\n\tif ((maptype == SFM_MAP_UNI_RSVD) && convert_sfm_char(src_char, target))\n\t\treturn len;\n\telse if ((maptype == SFU_MAP_UNI_RSVD) &&\n\t\t  convert_sfu_char(src_char, target))\n\t\treturn len;\n\n\t \n\tlen = cp->uni2char(src_char, target, NLS_MAX_CHARSET_SIZE);\n\tif (len <= 0)\n\t\tgoto surrogate_pair;\n\n\treturn len;\n\nsurrogate_pair:\n\t \n\tif (strcmp(cp->charset, \"utf8\"))\n\t\tgoto unknown;\n\tlen = utf16s_to_utf8s(from, 3, UTF16_LITTLE_ENDIAN, target, 6);\n\tif (len <= 0)\n\t\tgoto unknown;\n\treturn len;\n\nunknown:\n\t*target = '?';\n\tlen = 1;\n\treturn len;\n}\n\n \nint\ncifs_from_utf16(char *to, const __le16 *from, int tolen, int fromlen,\n\t\tconst struct nls_table *codepage, int map_type)\n{\n\tint i, charlen, safelen;\n\tint outlen = 0;\n\tint nullsize = nls_nullsize(codepage);\n\tint fromwords = fromlen / 2;\n\tchar tmp[NLS_MAX_CHARSET_SIZE];\n\t__u16 ftmp[3];\t\t \n\n\t \n\tsafelen = tolen - (NLS_MAX_CHARSET_SIZE + nullsize);\n\n\tfor (i = 0; i < fromwords; i++) {\n\t\tftmp[0] = get_unaligned_le16(&from[i]);\n\t\tif (ftmp[0] == 0)\n\t\t\tbreak;\n\t\tif (i + 1 < fromwords)\n\t\t\tftmp[1] = get_unaligned_le16(&from[i + 1]);\n\t\telse\n\t\t\tftmp[1] = 0;\n\t\tif (i + 2 < fromwords)\n\t\t\tftmp[2] = get_unaligned_le16(&from[i + 2]);\n\t\telse\n\t\t\tftmp[2] = 0;\n\n\t\t \n\t\tif (outlen >= safelen) {\n\t\t\tcharlen = cifs_mapchar(tmp, ftmp, codepage, map_type);\n\t\t\tif ((outlen + charlen) > (tolen - nullsize))\n\t\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tcharlen = cifs_mapchar(&to[outlen], ftmp, codepage, map_type);\n\t\toutlen += charlen;\n\n\t\t \n\t\tif (charlen == 4)\n\t\t\ti++;\n\t\telse if (charlen >= 5)\n\t\t\t \n\t\t\ti += 2;\n\t}\n\n\t \n\tfor (i = 0; i < nullsize; i++)\n\t\tto[outlen++] = 0;\n\n\treturn outlen;\n}\n\n \nint\ncifs_strtoUTF16(__le16 *to, const char *from, int len,\n\t      const struct nls_table *codepage)\n{\n\tint charlen;\n\tint i;\n\twchar_t wchar_to;  \n\n\t \n\tif (!strcmp(codepage->charset, \"utf8\")) {\n\t\t \n\t\ti  = utf8s_to_utf16s(from, len, UTF16_LITTLE_ENDIAN,\n\t\t\t\t       (wchar_t *) to, len);\n\n\t\t \n\t\tif (i >= 0)\n\t\t\tgoto success;\n\t\t \n\t}\n\n\tfor (i = 0; len && *from; i++, from += charlen, len -= charlen) {\n\t\tcharlen = codepage->char2uni(from, len, &wchar_to);\n\t\tif (charlen < 1) {\n\t\t\tcifs_dbg(VFS, \"strtoUTF16: char2uni of 0x%x returned %d\\n\",\n\t\t\t\t *from, charlen);\n\t\t\t \n\t\t\twchar_to = 0x003f;\n\t\t\tcharlen = 1;\n\t\t}\n\t\tput_unaligned_le16(wchar_to, &to[i]);\n\t}\n\nsuccess:\n\tput_unaligned_le16(0, &to[i]);\n\treturn i;\n}\n\n \nint\ncifs_utf16_bytes(const __le16 *from, int maxbytes,\n\t\tconst struct nls_table *codepage)\n{\n\tint i;\n\tint charlen, outlen = 0;\n\tint maxwords = maxbytes / 2;\n\tchar tmp[NLS_MAX_CHARSET_SIZE];\n\t__u16 ftmp[3];\n\n\tfor (i = 0; i < maxwords; i++) {\n\t\tftmp[0] = get_unaligned_le16(&from[i]);\n\t\tif (ftmp[0] == 0)\n\t\t\tbreak;\n\t\tif (i + 1 < maxwords)\n\t\t\tftmp[1] = get_unaligned_le16(&from[i + 1]);\n\t\telse\n\t\t\tftmp[1] = 0;\n\t\tif (i + 2 < maxwords)\n\t\t\tftmp[2] = get_unaligned_le16(&from[i + 2]);\n\t\telse\n\t\t\tftmp[2] = 0;\n\n\t\tcharlen = cifs_mapchar(tmp, ftmp, codepage, NO_MAP_UNI_RSVD);\n\t\toutlen += charlen;\n\t}\n\n\treturn outlen;\n}\n\n \nchar *\ncifs_strndup_from_utf16(const char *src, const int maxlen,\n\t\t\tconst bool is_unicode, const struct nls_table *codepage)\n{\n\tint len;\n\tchar *dst;\n\n\tif (is_unicode) {\n\t\tlen = cifs_utf16_bytes((__le16 *) src, maxlen, codepage);\n\t\tlen += nls_nullsize(codepage);\n\t\tdst = kmalloc(len, GFP_KERNEL);\n\t\tif (!dst)\n\t\t\treturn NULL;\n\t\tcifs_from_utf16(dst, (__le16 *) src, len, maxlen, codepage,\n\t\t\t\tNO_MAP_UNI_RSVD);\n\t} else {\n\t\tdst = kstrndup(src, maxlen, GFP_KERNEL);\n\t}\n\n\treturn dst;\n}\n\nstatic __le16 convert_to_sfu_char(char src_char)\n{\n\t__le16 dest_char;\n\n\tswitch (src_char) {\n\tcase ':':\n\t\tdest_char = cpu_to_le16(UNI_COLON);\n\t\tbreak;\n\tcase '*':\n\t\tdest_char = cpu_to_le16(UNI_ASTERISK);\n\t\tbreak;\n\tcase '?':\n\t\tdest_char = cpu_to_le16(UNI_QUESTION);\n\t\tbreak;\n\tcase '<':\n\t\tdest_char = cpu_to_le16(UNI_LESSTHAN);\n\t\tbreak;\n\tcase '>':\n\t\tdest_char = cpu_to_le16(UNI_GRTRTHAN);\n\t\tbreak;\n\tcase '|':\n\t\tdest_char = cpu_to_le16(UNI_PIPE);\n\t\tbreak;\n\tdefault:\n\t\tdest_char = 0;\n\t}\n\n\treturn dest_char;\n}\n\nstatic __le16 convert_to_sfm_char(char src_char, bool end_of_string)\n{\n\t__le16 dest_char;\n\n\tif (src_char >= 0x01 && src_char <= 0x1F) {\n\t\tdest_char = cpu_to_le16(src_char + 0xF000);\n\t\treturn dest_char;\n\t}\n\tswitch (src_char) {\n\tcase ':':\n\t\tdest_char = cpu_to_le16(SFM_COLON);\n\t\tbreak;\n\tcase '\"':\n\t\tdest_char = cpu_to_le16(SFM_DOUBLEQUOTE);\n\t\tbreak;\n\tcase '*':\n\t\tdest_char = cpu_to_le16(SFM_ASTERISK);\n\t\tbreak;\n\tcase '?':\n\t\tdest_char = cpu_to_le16(SFM_QUESTION);\n\t\tbreak;\n\tcase '<':\n\t\tdest_char = cpu_to_le16(SFM_LESSTHAN);\n\t\tbreak;\n\tcase '>':\n\t\tdest_char = cpu_to_le16(SFM_GRTRTHAN);\n\t\tbreak;\n\tcase '|':\n\t\tdest_char = cpu_to_le16(SFM_PIPE);\n\t\tbreak;\n\tcase '.':\n\t\tif (end_of_string)\n\t\t\tdest_char = cpu_to_le16(SFM_PERIOD);\n\t\telse\n\t\t\tdest_char = 0;\n\t\tbreak;\n\tcase ' ':\n\t\tif (end_of_string)\n\t\t\tdest_char = cpu_to_le16(SFM_SPACE);\n\t\telse\n\t\t\tdest_char = 0;\n\t\tbreak;\n\tdefault:\n\t\tdest_char = 0;\n\t}\n\n\treturn dest_char;\n}\n\n \nint\ncifsConvertToUTF16(__le16 *target, const char *source, int srclen,\n\t\t const struct nls_table *cp, int map_chars)\n{\n\tint i, charlen;\n\tint j = 0;\n\tchar src_char;\n\t__le16 dst_char;\n\twchar_t tmp;\n\twchar_t *wchar_to;\t \n\tint ret;\n\tunicode_t u;\n\n\tif (map_chars == NO_MAP_UNI_RSVD)\n\t\treturn cifs_strtoUTF16(target, source, PATH_MAX, cp);\n\n\twchar_to = kzalloc(6, GFP_KERNEL);\n\n\tfor (i = 0; i < srclen; j++) {\n\t\tsrc_char = source[i];\n\t\tcharlen = 1;\n\n\t\t \n\t\tif (src_char == 0)\n\t\t\tgoto ctoUTF16_out;\n\n\t\t \n\t\tif (map_chars == SFU_MAP_UNI_RSVD)\n\t\t\tdst_char = convert_to_sfu_char(src_char);\n\t\telse if (map_chars == SFM_MAP_UNI_RSVD) {\n\t\t\tbool end_of_string;\n\n\t\t\t \n\t\t\tif ((i == srclen - 1) || (source[i+1] == '\\\\'))\n\t\t\t\tend_of_string = true;\n\t\t\telse\n\t\t\t\tend_of_string = false;\n\n\t\t\tdst_char = convert_to_sfm_char(src_char, end_of_string);\n\t\t} else\n\t\t\tdst_char = 0;\n\t\t \n\t\tif (dst_char == 0) {\n\t\t\tcharlen = cp->char2uni(source + i, srclen - i, &tmp);\n\t\t\tdst_char = cpu_to_le16(tmp);\n\n\t\t\t \n\t\t\tif (charlen > 0)\n\t\t\t\tgoto ctoUTF16;\n\n\t\t\t \n\t\t\tif (strcmp(cp->charset, \"utf8\") || !wchar_to)\n\t\t\t\tgoto unknown;\n\t\t\tif (*(source + i) & 0x80) {\n\t\t\t\tcharlen = utf8_to_utf32(source + i, 6, &u);\n\t\t\t\tif (charlen < 0)\n\t\t\t\t\tgoto unknown;\n\t\t\t} else\n\t\t\t\tgoto unknown;\n\t\t\tret  = utf8s_to_utf16s(source + i, charlen,\n\t\t\t\t\t       UTF16_LITTLE_ENDIAN,\n\t\t\t\t\t       wchar_to, 6);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto unknown;\n\n\t\t\ti += charlen;\n\t\t\tdst_char = cpu_to_le16(*wchar_to);\n\t\t\tif (charlen <= 3)\n\t\t\t\t \n\t\t\t\tput_unaligned(dst_char, &target[j]);\n\t\t\telse if (charlen == 4) {\n\t\t\t\t \n\t\t\t\tput_unaligned(dst_char, &target[j]);\n\t\t\t\tdst_char = cpu_to_le16(*(wchar_to + 1));\n\t\t\t\tj++;\n\t\t\t\tput_unaligned(dst_char, &target[j]);\n\t\t\t} else if (charlen >= 5) {\n\t\t\t\t \n\t\t\t\tput_unaligned(dst_char, &target[j]);\n\t\t\t\tdst_char = cpu_to_le16(*(wchar_to + 1));\n\t\t\t\tj++;\n\t\t\t\tput_unaligned(dst_char, &target[j]);\n\t\t\t\tdst_char = cpu_to_le16(*(wchar_to + 2));\n\t\t\t\tj++;\n\t\t\t\tput_unaligned(dst_char, &target[j]);\n\t\t\t}\n\t\t\tcontinue;\n\nunknown:\n\t\t\tdst_char = cpu_to_le16(0x003f);\n\t\t\tcharlen = 1;\n\t\t}\n\nctoUTF16:\n\t\t \n\t\ti += charlen;\n\t\tput_unaligned(dst_char, &target[j]);\n\t}\n\nctoUTF16_out:\n\tput_unaligned(0, &target[j]);  \n\tkfree(wchar_to);\n\treturn j;\n}\n\n \n\nstatic int\ncifs_local_to_utf16_bytes(const char *from, int len,\n\t\t\t  const struct nls_table *codepage)\n{\n\tint charlen;\n\tint i;\n\twchar_t wchar_to;\n\n\tfor (i = 0; len && *from; i++, from += charlen, len -= charlen) {\n\t\tcharlen = codepage->char2uni(from, len, &wchar_to);\n\t\t \n\t\tif (charlen < 1)\n\t\t\tcharlen = 1;\n\t}\n\treturn 2 * i;  \n}\n\n \n__le16 *\ncifs_strndup_to_utf16(const char *src, const int maxlen, int *utf16_len,\n\t\t      const struct nls_table *cp, int remap)\n{\n\tint len;\n\t__le16 *dst;\n\n\tlen = cifs_local_to_utf16_bytes(src, maxlen, cp);\n\tlen += 2;  \n\tdst = kmalloc(len, GFP_KERNEL);\n\tif (!dst) {\n\t\t*utf16_len = 0;\n\t\treturn NULL;\n\t}\n\tcifsConvertToUTF16(dst, src, strlen(src), cp, remap);\n\t*utf16_len = len;\n\treturn dst;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}