{
  "module_name": "fscache.c",
  "hash_id": "b0738114d52991f33cff77b44964dfcc1d485ffea9824e56699acdfb51c379f2",
  "original_prompt": "Ingested from linux-6.6.14/fs/smb/client/fscache.c",
  "human_readable_source": "\n \n#include \"fscache.h\"\n#include \"cifsglob.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifsproto.h\"\n\nstatic void cifs_fscache_fill_volume_coherency(\n\tstruct cifs_tcon *tcon,\n\tstruct cifs_fscache_volume_coherency_data *cd)\n{\n\tmemset(cd, 0, sizeof(*cd));\n\tcd->resource_id\t\t= cpu_to_le64(tcon->resource_id);\n\tcd->vol_create_time\t= tcon->vol_create_time;\n\tcd->vol_serial_number\t= cpu_to_le32(tcon->vol_serial_number);\n}\n\nint cifs_fscache_get_super_cookie(struct cifs_tcon *tcon)\n{\n\tstruct cifs_fscache_volume_coherency_data cd;\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tstruct fscache_volume *vcookie;\n\tconst struct sockaddr *sa = (struct sockaddr *)&server->dstaddr;\n\tsize_t slen, i;\n\tchar *sharename;\n\tchar *key;\n\tint ret = -ENOMEM;\n\n\ttcon->fscache = NULL;\n\tswitch (sa->sa_family) {\n\tcase AF_INET:\n\tcase AF_INET6:\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"Unknown network family '%d'\\n\", sa->sa_family);\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(&key, 0, sizeof(key));\n\n\tsharename = extract_sharename(tcon->tree_name);\n\tif (IS_ERR(sharename)) {\n\t\tcifs_dbg(FYI, \"%s: couldn't extract sharename\\n\", __func__);\n\t\treturn PTR_ERR(sharename);\n\t}\n\n\tslen = strlen(sharename);\n\tfor (i = 0; i < slen; i++)\n\t\tif (sharename[i] == '/')\n\t\t\tsharename[i] = ';';\n\n\tkey = kasprintf(GFP_KERNEL, \"cifs,%pISpc,%s\", sa, sharename);\n\tif (!key)\n\t\tgoto out;\n\n\tcifs_fscache_fill_volume_coherency(tcon, &cd);\n\tvcookie = fscache_acquire_volume(key,\n\t\t\t\t\t NULL,  \n\t\t\t\t\t &cd, sizeof(cd));\n\tcifs_dbg(FYI, \"%s: (%s/0x%p)\\n\", __func__, key, vcookie);\n\tif (IS_ERR(vcookie)) {\n\t\tif (vcookie != ERR_PTR(-EBUSY)) {\n\t\t\tret = PTR_ERR(vcookie);\n\t\t\tgoto out_2;\n\t\t}\n\t\tpr_err(\"Cache volume key already in use (%s)\\n\", key);\n\t\tvcookie = NULL;\n\t}\n\n\ttcon->fscache = vcookie;\n\tret = 0;\nout_2:\n\tkfree(key);\nout:\n\tkfree(sharename);\n\treturn ret;\n}\n\nvoid cifs_fscache_release_super_cookie(struct cifs_tcon *tcon)\n{\n\tstruct cifs_fscache_volume_coherency_data cd;\n\n\tcifs_dbg(FYI, \"%s: (0x%p)\\n\", __func__, tcon->fscache);\n\n\tcifs_fscache_fill_volume_coherency(tcon, &cd);\n\tfscache_relinquish_volume(tcon->fscache, &cd, false);\n\ttcon->fscache = NULL;\n}\n\nvoid cifs_fscache_get_inode_cookie(struct inode *inode)\n{\n\tstruct cifs_fscache_inode_coherency_data cd;\n\tstruct cifsInodeInfo *cifsi = CIFS_I(inode);\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\n\n\tcifs_fscache_fill_coherency(&cifsi->netfs.inode, &cd);\n\n\tcifsi->netfs.cache =\n\t\tfscache_acquire_cookie(tcon->fscache, 0,\n\t\t\t\t       &cifsi->uniqueid, sizeof(cifsi->uniqueid),\n\t\t\t\t       &cd, sizeof(cd),\n\t\t\t\t       i_size_read(&cifsi->netfs.inode));\n\tif (cifsi->netfs.cache)\n\t\tmapping_set_release_always(inode->i_mapping);\n}\n\nvoid cifs_fscache_unuse_inode_cookie(struct inode *inode, bool update)\n{\n\tif (update) {\n\t\tstruct cifs_fscache_inode_coherency_data cd;\n\t\tloff_t i_size = i_size_read(inode);\n\n\t\tcifs_fscache_fill_coherency(inode, &cd);\n\t\tfscache_unuse_cookie(cifs_inode_cookie(inode), &cd, &i_size);\n\t} else {\n\t\tfscache_unuse_cookie(cifs_inode_cookie(inode), NULL, NULL);\n\t}\n}\n\nvoid cifs_fscache_release_inode_cookie(struct inode *inode)\n{\n\tstruct cifsInodeInfo *cifsi = CIFS_I(inode);\n\tstruct fscache_cookie *cookie = cifs_inode_cookie(inode);\n\n\tif (cookie) {\n\t\tcifs_dbg(FYI, \"%s: (0x%p)\\n\", __func__, cookie);\n\t\tfscache_relinquish_cookie(cookie, false);\n\t\tcifsi->netfs.cache = NULL;\n\t}\n}\n\n \nstatic int fscache_fallback_read_page(struct inode *inode, struct page *page)\n{\n\tstruct netfs_cache_resources cres;\n\tstruct fscache_cookie *cookie = cifs_inode_cookie(inode);\n\tstruct iov_iter iter;\n\tstruct bio_vec bvec;\n\tint ret;\n\n\tmemset(&cres, 0, sizeof(cres));\n\tbvec_set_page(&bvec, page, PAGE_SIZE, 0);\n\tiov_iter_bvec(&iter, ITER_DEST, &bvec, 1, PAGE_SIZE);\n\n\tret = fscache_begin_read_operation(&cres, cookie);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = fscache_read(&cres, page_offset(page), &iter, NETFS_READ_HOLE_FAIL,\n\t\t\t   NULL, NULL);\n\tfscache_end_operation(&cres);\n\treturn ret;\n}\n\n \nstatic int fscache_fallback_write_pages(struct inode *inode, loff_t start, size_t len,\n\t\t\t\t\tbool no_space_allocated_yet)\n{\n\tstruct netfs_cache_resources cres;\n\tstruct fscache_cookie *cookie = cifs_inode_cookie(inode);\n\tstruct iov_iter iter;\n\tint ret;\n\n\tmemset(&cres, 0, sizeof(cres));\n\tiov_iter_xarray(&iter, ITER_SOURCE, &inode->i_mapping->i_pages, start, len);\n\n\tret = fscache_begin_write_operation(&cres, cookie);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = cres.ops->prepare_write(&cres, &start, &len, i_size_read(inode),\n\t\t\t\t      no_space_allocated_yet);\n\tif (ret == 0)\n\t\tret = fscache_write(&cres, start, &iter, NULL, NULL);\n\tfscache_end_operation(&cres);\n\treturn ret;\n}\n\n \nint __cifs_readpage_from_fscache(struct inode *inode, struct page *page)\n{\n\tint ret;\n\n\tcifs_dbg(FYI, \"%s: (fsc:%p, p:%p, i:0x%p\\n\",\n\t\t __func__, cifs_inode_cookie(inode), page, inode);\n\n\tret = fscache_fallback_read_page(inode, page);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tSetPageUptodate(page);\n\treturn 0;\n}\n\nvoid __cifs_readahead_to_fscache(struct inode *inode, loff_t pos, size_t len)\n{\n\tcifs_dbg(FYI, \"%s: (fsc: %p, p: %llx, l: %zx, i: %p)\\n\",\n\t\t __func__, cifs_inode_cookie(inode), pos, len, inode);\n\n\tfscache_fallback_write_pages(inode, pos, len, true);\n}\n\n \nint __cifs_fscache_query_occupancy(struct inode *inode,\n\t\t\t\t   pgoff_t first, unsigned int nr_pages,\n\t\t\t\t   pgoff_t *_data_first,\n\t\t\t\t   unsigned int *_data_nr_pages)\n{\n\tstruct netfs_cache_resources cres;\n\tstruct fscache_cookie *cookie = cifs_inode_cookie(inode);\n\tloff_t start, data_start;\n\tsize_t len, data_len;\n\tint ret;\n\n\tret = fscache_begin_read_operation(&cres, cookie);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tstart = first * PAGE_SIZE;\n\tlen = nr_pages * PAGE_SIZE;\n\tret = cres.ops->query_occupancy(&cres, start, len, PAGE_SIZE,\n\t\t\t\t\t&data_start, &data_len);\n\tif (ret == 0) {\n\t\t*_data_first = data_start / PAGE_SIZE;\n\t\t*_data_nr_pages = len / PAGE_SIZE;\n\t}\n\n\tfscache_end_operation(&cres);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}