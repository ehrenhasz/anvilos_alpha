{
  "module_name": "cifs_swn.c",
  "hash_id": "d9667cb9dc1f69c179d022b25946e0ddf748dd1478fc270142d05dbfc8a42f87",
  "original_prompt": "Ingested from linux-6.6.14/fs/smb/client/cifs_swn.c",
  "human_readable_source": "\n \n\n#include <linux/kref.h>\n#include <net/genetlink.h>\n#include <uapi/linux/cifs/cifs_netlink.h>\n\n#include \"cifs_swn.h\"\n#include \"cifsglob.h\"\n#include \"cifsproto.h\"\n#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"netlink.h\"\n\nstatic DEFINE_IDR(cifs_swnreg_idr);\nstatic DEFINE_MUTEX(cifs_swnreg_idr_mutex);\n\nstruct cifs_swn_reg {\n\tint id;\n\tstruct kref ref_count;\n\n\tconst char *net_name;\n\tconst char *share_name;\n\tbool net_name_notify;\n\tbool share_name_notify;\n\tbool ip_notify;\n\n\tstruct cifs_tcon *tcon;\n};\n\nstatic int cifs_swn_auth_info_krb(struct cifs_tcon *tcon, struct sk_buff *skb)\n{\n\tint ret;\n\n\tret = nla_put_flag(skb, CIFS_GENL_ATTR_SWN_KRB_AUTH);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int cifs_swn_auth_info_ntlm(struct cifs_tcon *tcon, struct sk_buff *skb)\n{\n\tint ret;\n\n\tif (tcon->ses->user_name != NULL) {\n\t\tret = nla_put_string(skb, CIFS_GENL_ATTR_SWN_USER_NAME, tcon->ses->user_name);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (tcon->ses->password != NULL) {\n\t\tret = nla_put_string(skb, CIFS_GENL_ATTR_SWN_PASSWORD, tcon->ses->password);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (tcon->ses->domainName != NULL) {\n\t\tret = nla_put_string(skb, CIFS_GENL_ATTR_SWN_DOMAIN_NAME, tcon->ses->domainName);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int cifs_swn_send_register_message(struct cifs_swn_reg *swnreg)\n{\n\tstruct sk_buff *skb;\n\tstruct genlmsghdr *hdr;\n\tenum securityEnum authtype;\n\tstruct sockaddr_storage *addr;\n\tint ret;\n\n\tskb = genlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (skb == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\thdr = genlmsg_put(skb, 0, 0, &cifs_genl_family, 0, CIFS_GENL_CMD_SWN_REGISTER);\n\tif (hdr == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto nlmsg_fail;\n\t}\n\n\tret = nla_put_u32(skb, CIFS_GENL_ATTR_SWN_REGISTRATION_ID, swnreg->id);\n\tif (ret < 0)\n\t\tgoto nlmsg_fail;\n\n\tret = nla_put_string(skb, CIFS_GENL_ATTR_SWN_NET_NAME, swnreg->net_name);\n\tif (ret < 0)\n\t\tgoto nlmsg_fail;\n\n\tret = nla_put_string(skb, CIFS_GENL_ATTR_SWN_SHARE_NAME, swnreg->share_name);\n\tif (ret < 0)\n\t\tgoto nlmsg_fail;\n\n\t \n\tif (swnreg->tcon->ses->server->use_swn_dstaddr)\n\t\taddr = &swnreg->tcon->ses->server->swn_dstaddr;\n\telse\n\t\taddr = &swnreg->tcon->ses->server->dstaddr;\n\n\tret = nla_put(skb, CIFS_GENL_ATTR_SWN_IP, sizeof(struct sockaddr_storage), addr);\n\tif (ret < 0)\n\t\tgoto nlmsg_fail;\n\n\tif (swnreg->net_name_notify) {\n\t\tret = nla_put_flag(skb, CIFS_GENL_ATTR_SWN_NET_NAME_NOTIFY);\n\t\tif (ret < 0)\n\t\t\tgoto nlmsg_fail;\n\t}\n\n\tif (swnreg->share_name_notify) {\n\t\tret = nla_put_flag(skb, CIFS_GENL_ATTR_SWN_SHARE_NAME_NOTIFY);\n\t\tif (ret < 0)\n\t\t\tgoto nlmsg_fail;\n\t}\n\n\tif (swnreg->ip_notify) {\n\t\tret = nla_put_flag(skb, CIFS_GENL_ATTR_SWN_IP_NOTIFY);\n\t\tif (ret < 0)\n\t\t\tgoto nlmsg_fail;\n\t}\n\n\tauthtype = cifs_select_sectype(swnreg->tcon->ses->server, swnreg->tcon->ses->sectype);\n\tswitch (authtype) {\n\tcase Kerberos:\n\t\tret = cifs_swn_auth_info_krb(swnreg->tcon, skb);\n\t\tif (ret < 0) {\n\t\t\tcifs_dbg(VFS, \"%s: Failed to get kerberos auth info: %d\\n\", __func__, ret);\n\t\t\tgoto nlmsg_fail;\n\t\t}\n\t\tbreak;\n\tcase NTLMv2:\n\tcase RawNTLMSSP:\n\t\tret = cifs_swn_auth_info_ntlm(swnreg->tcon, skb);\n\t\tif (ret < 0) {\n\t\t\tcifs_dbg(VFS, \"%s: Failed to get NTLM auth info: %d\\n\", __func__, ret);\n\t\t\tgoto nlmsg_fail;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"%s: secType %d not supported!\\n\", __func__, authtype);\n\t\tret = -EINVAL;\n\t\tgoto nlmsg_fail;\n\t}\n\n\tgenlmsg_end(skb, hdr);\n\tgenlmsg_multicast(&cifs_genl_family, skb, 0, CIFS_GENL_MCGRP_SWN, GFP_ATOMIC);\n\n\tcifs_dbg(FYI, \"%s: Message to register for network name %s with id %d sent\\n\", __func__,\n\t\t\tswnreg->net_name, swnreg->id);\n\n\treturn 0;\n\nnlmsg_fail:\n\tgenlmsg_cancel(skb, hdr);\n\tnlmsg_free(skb);\nfail:\n\treturn ret;\n}\n\n \nstatic int cifs_swn_send_unregister_message(struct cifs_swn_reg *swnreg)\n{\n\tstruct sk_buff *skb;\n\tstruct genlmsghdr *hdr;\n\tint ret;\n\n\tskb = genlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(skb, 0, 0, &cifs_genl_family, 0, CIFS_GENL_CMD_SWN_UNREGISTER);\n\tif (hdr == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto nlmsg_fail;\n\t}\n\n\tret = nla_put_u32(skb, CIFS_GENL_ATTR_SWN_REGISTRATION_ID, swnreg->id);\n\tif (ret < 0)\n\t\tgoto nlmsg_fail;\n\n\tret = nla_put_string(skb, CIFS_GENL_ATTR_SWN_NET_NAME, swnreg->net_name);\n\tif (ret < 0)\n\t\tgoto nlmsg_fail;\n\n\tret = nla_put_string(skb, CIFS_GENL_ATTR_SWN_SHARE_NAME, swnreg->share_name);\n\tif (ret < 0)\n\t\tgoto nlmsg_fail;\n\n\tret = nla_put(skb, CIFS_GENL_ATTR_SWN_IP, sizeof(struct sockaddr_storage),\n\t\t\t&swnreg->tcon->ses->server->dstaddr);\n\tif (ret < 0)\n\t\tgoto nlmsg_fail;\n\n\tif (swnreg->net_name_notify) {\n\t\tret = nla_put_flag(skb, CIFS_GENL_ATTR_SWN_NET_NAME_NOTIFY);\n\t\tif (ret < 0)\n\t\t\tgoto nlmsg_fail;\n\t}\n\n\tif (swnreg->share_name_notify) {\n\t\tret = nla_put_flag(skb, CIFS_GENL_ATTR_SWN_SHARE_NAME_NOTIFY);\n\t\tif (ret < 0)\n\t\t\tgoto nlmsg_fail;\n\t}\n\n\tif (swnreg->ip_notify) {\n\t\tret = nla_put_flag(skb, CIFS_GENL_ATTR_SWN_IP_NOTIFY);\n\t\tif (ret < 0)\n\t\t\tgoto nlmsg_fail;\n\t}\n\n\tgenlmsg_end(skb, hdr);\n\tgenlmsg_multicast(&cifs_genl_family, skb, 0, CIFS_GENL_MCGRP_SWN, GFP_ATOMIC);\n\n\tcifs_dbg(FYI, \"%s: Message to unregister for network name %s with id %d sent\\n\", __func__,\n\t\t\tswnreg->net_name, swnreg->id);\n\n\treturn 0;\n\nnlmsg_fail:\n\tgenlmsg_cancel(skb, hdr);\n\tnlmsg_free(skb);\n\treturn ret;\n}\n\n \nstatic struct cifs_swn_reg *cifs_find_swn_reg(struct cifs_tcon *tcon)\n{\n\tstruct cifs_swn_reg *swnreg;\n\tint id;\n\tconst char *share_name;\n\tconst char *net_name;\n\n\tnet_name = extract_hostname(tcon->tree_name);\n\tif (IS_ERR(net_name)) {\n\t\tint ret;\n\n\t\tret = PTR_ERR(net_name);\n\t\tcifs_dbg(VFS, \"%s: failed to extract host name from target '%s': %d\\n\",\n\t\t\t\t__func__, tcon->tree_name, ret);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tshare_name = extract_sharename(tcon->tree_name);\n\tif (IS_ERR(share_name)) {\n\t\tint ret;\n\n\t\tret = PTR_ERR(share_name);\n\t\tcifs_dbg(VFS, \"%s: failed to extract share name from target '%s': %d\\n\",\n\t\t\t\t__func__, tcon->tree_name, ret);\n\t\tkfree(net_name);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tidr_for_each_entry(&cifs_swnreg_idr, swnreg, id) {\n\t\tif (strcasecmp(swnreg->net_name, net_name) != 0\n\t\t    || strcasecmp(swnreg->share_name, share_name) != 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tcifs_dbg(FYI, \"Existing swn registration for %s:%s found\\n\", swnreg->net_name,\n\t\t\t\tswnreg->share_name);\n\n\t\tkfree(net_name);\n\t\tkfree(share_name);\n\n\t\treturn swnreg;\n\t}\n\n\tkfree(net_name);\n\tkfree(share_name);\n\n\treturn ERR_PTR(-EEXIST);\n}\n\n \nstatic struct cifs_swn_reg *cifs_get_swn_reg(struct cifs_tcon *tcon)\n{\n\tstruct cifs_swn_reg *reg = NULL;\n\tint ret;\n\n\tmutex_lock(&cifs_swnreg_idr_mutex);\n\n\t \n\treg = cifs_find_swn_reg(tcon);\n\tif (!IS_ERR(reg)) {\n\t\tkref_get(&reg->ref_count);\n\t\tmutex_unlock(&cifs_swnreg_idr_mutex);\n\t\treturn reg;\n\t} else if (PTR_ERR(reg) != -EEXIST) {\n\t\tmutex_unlock(&cifs_swnreg_idr_mutex);\n\t\treturn reg;\n\t}\n\n\treg = kmalloc(sizeof(struct cifs_swn_reg), GFP_ATOMIC);\n\tif (reg == NULL) {\n\t\tmutex_unlock(&cifs_swnreg_idr_mutex);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tkref_init(&reg->ref_count);\n\n\treg->id = idr_alloc(&cifs_swnreg_idr, reg, 1, 0, GFP_ATOMIC);\n\tif (reg->id < 0) {\n\t\tcifs_dbg(FYI, \"%s: failed to allocate registration id\\n\", __func__);\n\t\tret = reg->id;\n\t\tgoto fail;\n\t}\n\n\treg->net_name = extract_hostname(tcon->tree_name);\n\tif (IS_ERR(reg->net_name)) {\n\t\tret = PTR_ERR(reg->net_name);\n\t\tcifs_dbg(VFS, \"%s: failed to extract host name from target: %d\\n\", __func__, ret);\n\t\tgoto fail_idr;\n\t}\n\n\treg->share_name = extract_sharename(tcon->tree_name);\n\tif (IS_ERR(reg->share_name)) {\n\t\tret = PTR_ERR(reg->share_name);\n\t\tcifs_dbg(VFS, \"%s: failed to extract share name from target: %d\\n\", __func__, ret);\n\t\tgoto fail_net_name;\n\t}\n\n\treg->net_name_notify = true;\n\treg->share_name_notify = true;\n\treg->ip_notify = (tcon->capabilities & SMB2_SHARE_CAP_SCALEOUT);\n\n\treg->tcon = tcon;\n\n\tmutex_unlock(&cifs_swnreg_idr_mutex);\n\n\treturn reg;\n\nfail_net_name:\n\tkfree(reg->net_name);\nfail_idr:\n\tidr_remove(&cifs_swnreg_idr, reg->id);\nfail:\n\tkfree(reg);\n\tmutex_unlock(&cifs_swnreg_idr_mutex);\n\treturn ERR_PTR(ret);\n}\n\nstatic void cifs_swn_reg_release(struct kref *ref)\n{\n\tstruct cifs_swn_reg *swnreg = container_of(ref, struct cifs_swn_reg, ref_count);\n\tint ret;\n\n\tret = cifs_swn_send_unregister_message(swnreg);\n\tif (ret < 0)\n\t\tcifs_dbg(VFS, \"%s: Failed to send unregister message: %d\\n\", __func__, ret);\n\n\tidr_remove(&cifs_swnreg_idr, swnreg->id);\n\tkfree(swnreg->net_name);\n\tkfree(swnreg->share_name);\n\tkfree(swnreg);\n}\n\nstatic void cifs_put_swn_reg(struct cifs_swn_reg *swnreg)\n{\n\tmutex_lock(&cifs_swnreg_idr_mutex);\n\tkref_put(&swnreg->ref_count, cifs_swn_reg_release);\n\tmutex_unlock(&cifs_swnreg_idr_mutex);\n}\n\nstatic int cifs_swn_resource_state_changed(struct cifs_swn_reg *swnreg, const char *name, int state)\n{\n\tswitch (state) {\n\tcase CIFS_SWN_RESOURCE_STATE_UNAVAILABLE:\n\t\tcifs_dbg(FYI, \"%s: resource name '%s' become unavailable\\n\", __func__, name);\n\t\tcifs_signal_cifsd_for_reconnect(swnreg->tcon->ses->server, true);\n\t\tbreak;\n\tcase CIFS_SWN_RESOURCE_STATE_AVAILABLE:\n\t\tcifs_dbg(FYI, \"%s: resource name '%s' become available\\n\", __func__, name);\n\t\tcifs_signal_cifsd_for_reconnect(swnreg->tcon->ses->server, true);\n\t\tbreak;\n\tcase CIFS_SWN_RESOURCE_STATE_UNKNOWN:\n\t\tcifs_dbg(FYI, \"%s: resource name '%s' changed to unknown state\\n\", __func__, name);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic bool cifs_sockaddr_equal(struct sockaddr_storage *addr1, struct sockaddr_storage *addr2)\n{\n\tif (addr1->ss_family != addr2->ss_family)\n\t\treturn false;\n\n\tif (addr1->ss_family == AF_INET) {\n\t\treturn (memcmp(&((const struct sockaddr_in *)addr1)->sin_addr,\n\t\t\t\t&((const struct sockaddr_in *)addr2)->sin_addr,\n\t\t\t\tsizeof(struct in_addr)) == 0);\n\t}\n\n\tif (addr1->ss_family == AF_INET6) {\n\t\treturn (memcmp(&((const struct sockaddr_in6 *)addr1)->sin6_addr,\n\t\t\t\t&((const struct sockaddr_in6 *)addr2)->sin6_addr,\n\t\t\t\tsizeof(struct in6_addr)) == 0);\n\t}\n\n\treturn false;\n}\n\nstatic int cifs_swn_store_swn_addr(const struct sockaddr_storage *new,\n\t\t\t\t   const struct sockaddr_storage *old,\n\t\t\t\t   struct sockaddr_storage *dst)\n{\n\t__be16 port = cpu_to_be16(CIFS_PORT);\n\n\tif (old->ss_family == AF_INET) {\n\t\tstruct sockaddr_in *ipv4 = (struct sockaddr_in *)old;\n\n\t\tport = ipv4->sin_port;\n\t} else if (old->ss_family == AF_INET6) {\n\t\tstruct sockaddr_in6 *ipv6 = (struct sockaddr_in6 *)old;\n\n\t\tport = ipv6->sin6_port;\n\t}\n\n\tif (new->ss_family == AF_INET) {\n\t\tstruct sockaddr_in *ipv4 = (struct sockaddr_in *)new;\n\n\t\tipv4->sin_port = port;\n\t} else if (new->ss_family == AF_INET6) {\n\t\tstruct sockaddr_in6 *ipv6 = (struct sockaddr_in6 *)new;\n\n\t\tipv6->sin6_port = port;\n\t}\n\n\t*dst = *new;\n\n\treturn 0;\n}\n\nstatic int cifs_swn_reconnect(struct cifs_tcon *tcon, struct sockaddr_storage *addr)\n{\n\tint ret = 0;\n\n\t \n\tcifs_server_lock(tcon->ses->server);\n\tif (cifs_sockaddr_equal(&tcon->ses->server->dstaddr, addr))\n\t\tgoto unlock;\n\n\tret = cifs_swn_store_swn_addr(addr, &tcon->ses->server->dstaddr,\n\t\t\t\t      &tcon->ses->server->swn_dstaddr);\n\tif (ret < 0) {\n\t\tcifs_dbg(VFS, \"%s: failed to store address: %d\\n\", __func__, ret);\n\t\tgoto unlock;\n\t}\n\ttcon->ses->server->use_swn_dstaddr = true;\n\n\t \n\tret = cifs_swn_unregister(tcon);\n\tif (ret < 0) {\n\t\tcifs_dbg(VFS, \"%s: Failed to unregister for witness notifications: %d\\n\",\n\t\t\t __func__, ret);\n\t\tgoto unlock;\n\t}\n\n\t \n\tret = cifs_swn_register(tcon);\n\tif (ret < 0) {\n\t\tcifs_dbg(VFS, \"%s: Failed to register for witness notifications: %d\\n\",\n\t\t\t __func__, ret);\n\t\tgoto unlock;\n\t}\n\n\tcifs_signal_cifsd_for_reconnect(tcon->ses->server, false);\n\nunlock:\n\tcifs_server_unlock(tcon->ses->server);\n\n\treturn ret;\n}\n\nstatic int cifs_swn_client_move(struct cifs_swn_reg *swnreg, struct sockaddr_storage *addr)\n{\n\tstruct sockaddr_in *ipv4 = (struct sockaddr_in *)addr;\n\tstruct sockaddr_in6 *ipv6 = (struct sockaddr_in6 *)addr;\n\n\tif (addr->ss_family == AF_INET)\n\t\tcifs_dbg(FYI, \"%s: move to %pI4\\n\", __func__, &ipv4->sin_addr);\n\telse if (addr->ss_family == AF_INET6)\n\t\tcifs_dbg(FYI, \"%s: move to %pI6\\n\", __func__, &ipv6->sin6_addr);\n\n\treturn cifs_swn_reconnect(swnreg->tcon, addr);\n}\n\nint cifs_swn_notify(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cifs_swn_reg *swnreg;\n\tchar name[256];\n\tint type;\n\n\tif (info->attrs[CIFS_GENL_ATTR_SWN_REGISTRATION_ID]) {\n\t\tint swnreg_id;\n\n\t\tswnreg_id = nla_get_u32(info->attrs[CIFS_GENL_ATTR_SWN_REGISTRATION_ID]);\n\t\tmutex_lock(&cifs_swnreg_idr_mutex);\n\t\tswnreg = idr_find(&cifs_swnreg_idr, swnreg_id);\n\t\tmutex_unlock(&cifs_swnreg_idr_mutex);\n\t\tif (swnreg == NULL) {\n\t\t\tcifs_dbg(FYI, \"%s: registration id %d not found\\n\", __func__, swnreg_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tcifs_dbg(FYI, \"%s: missing registration id attribute\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[CIFS_GENL_ATTR_SWN_NOTIFICATION_TYPE]) {\n\t\ttype = nla_get_u32(info->attrs[CIFS_GENL_ATTR_SWN_NOTIFICATION_TYPE]);\n\t} else {\n\t\tcifs_dbg(FYI, \"%s: missing notification type attribute\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (type) {\n\tcase CIFS_SWN_NOTIFICATION_RESOURCE_CHANGE: {\n\t\tint state;\n\n\t\tif (info->attrs[CIFS_GENL_ATTR_SWN_RESOURCE_NAME]) {\n\t\t\tnla_strscpy(name, info->attrs[CIFS_GENL_ATTR_SWN_RESOURCE_NAME],\n\t\t\t\t\tsizeof(name));\n\t\t} else {\n\t\t\tcifs_dbg(FYI, \"%s: missing resource name attribute\\n\", __func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (info->attrs[CIFS_GENL_ATTR_SWN_RESOURCE_STATE]) {\n\t\t\tstate = nla_get_u32(info->attrs[CIFS_GENL_ATTR_SWN_RESOURCE_STATE]);\n\t\t} else {\n\t\t\tcifs_dbg(FYI, \"%s: missing resource state attribute\\n\", __func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn cifs_swn_resource_state_changed(swnreg, name, state);\n\t}\n\tcase CIFS_SWN_NOTIFICATION_CLIENT_MOVE: {\n\t\tstruct sockaddr_storage addr;\n\n\t\tif (info->attrs[CIFS_GENL_ATTR_SWN_IP]) {\n\t\t\tnla_memcpy(&addr, info->attrs[CIFS_GENL_ATTR_SWN_IP], sizeof(addr));\n\t\t} else {\n\t\t\tcifs_dbg(FYI, \"%s: missing IP address attribute\\n\", __func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn cifs_swn_client_move(swnreg, &addr);\n\t}\n\tdefault:\n\t\tcifs_dbg(FYI, \"%s: unknown notification type %d\\n\", __func__, type);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nint cifs_swn_register(struct cifs_tcon *tcon)\n{\n\tstruct cifs_swn_reg *swnreg;\n\tint ret;\n\n\tswnreg = cifs_get_swn_reg(tcon);\n\tif (IS_ERR(swnreg))\n\t\treturn PTR_ERR(swnreg);\n\n\tret = cifs_swn_send_register_message(swnreg);\n\tif (ret < 0) {\n\t\tcifs_dbg(VFS, \"%s: Failed to send swn register message: %d\\n\", __func__, ret);\n\t\t \n\t}\n\n\treturn 0;\n}\n\nint cifs_swn_unregister(struct cifs_tcon *tcon)\n{\n\tstruct cifs_swn_reg *swnreg;\n\n\tmutex_lock(&cifs_swnreg_idr_mutex);\n\n\tswnreg = cifs_find_swn_reg(tcon);\n\tif (IS_ERR(swnreg)) {\n\t\tmutex_unlock(&cifs_swnreg_idr_mutex);\n\t\treturn PTR_ERR(swnreg);\n\t}\n\n\tmutex_unlock(&cifs_swnreg_idr_mutex);\n\n\tcifs_put_swn_reg(swnreg);\n\n\treturn 0;\n}\n\nvoid cifs_swn_dump(struct seq_file *m)\n{\n\tstruct cifs_swn_reg *swnreg;\n\tstruct sockaddr_in *sa;\n\tstruct sockaddr_in6 *sa6;\n\tint id;\n\n\tseq_puts(m, \"Witness registrations:\");\n\n\tmutex_lock(&cifs_swnreg_idr_mutex);\n\tidr_for_each_entry(&cifs_swnreg_idr, swnreg, id) {\n\t\tseq_printf(m, \"\\nId: %u Refs: %u Network name: '%s'%s Share name: '%s'%s Ip address: \",\n\t\t\t\tid, kref_read(&swnreg->ref_count),\n\t\t\t\tswnreg->net_name, swnreg->net_name_notify ? \"(y)\" : \"(n)\",\n\t\t\t\tswnreg->share_name, swnreg->share_name_notify ? \"(y)\" : \"(n)\");\n\t\tswitch (swnreg->tcon->ses->server->dstaddr.ss_family) {\n\t\tcase AF_INET:\n\t\t\tsa = (struct sockaddr_in *) &swnreg->tcon->ses->server->dstaddr;\n\t\t\tseq_printf(m, \"%pI4\", &sa->sin_addr.s_addr);\n\t\t\tbreak;\n\t\tcase AF_INET6:\n\t\t\tsa6 = (struct sockaddr_in6 *) &swnreg->tcon->ses->server->dstaddr;\n\t\t\tseq_printf(m, \"%pI6\", &sa6->sin6_addr.s6_addr);\n\t\t\tif (sa6->sin6_scope_id)\n\t\t\t\tseq_printf(m, \"%%%u\", sa6->sin6_scope_id);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tseq_puts(m, \"(unknown)\");\n\t\t}\n\t\tseq_printf(m, \"%s\", swnreg->ip_notify ? \"(y)\" : \"(n)\");\n\t}\n\tmutex_unlock(&cifs_swnreg_idr_mutex);\n\tseq_puts(m, \"\\n\");\n}\n\nvoid cifs_swn_check(void)\n{\n\tstruct cifs_swn_reg *swnreg;\n\tint id;\n\tint ret;\n\n\tmutex_lock(&cifs_swnreg_idr_mutex);\n\tidr_for_each_entry(&cifs_swnreg_idr, swnreg, id) {\n\t\tret = cifs_swn_send_register_message(swnreg);\n\t\tif (ret < 0)\n\t\t\tcifs_dbg(FYI, \"%s: Failed to send register message: %d\\n\", __func__, ret);\n\t}\n\tmutex_unlock(&cifs_swnreg_idr_mutex);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}