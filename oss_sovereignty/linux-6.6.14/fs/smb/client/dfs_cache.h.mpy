{
  "module_name": "dfs_cache.h",
  "hash_id": "0e3a276b7211eb4d3867ee589455cf9173febb0d7877d235d4e500a40fdc4eda",
  "original_prompt": "Ingested from linux-6.6.14/fs/smb/client/dfs_cache.h",
  "human_readable_source": " \n \n\n#ifndef _CIFS_DFS_CACHE_H\n#define _CIFS_DFS_CACHE_H\n\n#include <linux/nls.h>\n#include <linux/list.h>\n#include <linux/uuid.h>\n#include \"cifsglob.h\"\n\nextern struct workqueue_struct *dfscache_wq;\nextern atomic_t dfs_cache_ttl;\n\n#define DFS_CACHE_TGT_LIST_INIT(var) \\\n\t{ .tl_numtgts = 0, .tl_list = LIST_HEAD_INIT((var).tl_list), }\n\n#define DFS_CACHE_TGT_LIST(var) \\\n\tstruct dfs_cache_tgt_list var = DFS_CACHE_TGT_LIST_INIT(var)\n\nstruct dfs_cache_tgt_list {\n\tint tl_numtgts;\n\tstruct list_head tl_list;\n};\n\nstruct dfs_cache_tgt_iterator {\n\tchar *it_name;\n\tint it_path_consumed;\n\tstruct list_head it_list;\n};\n\nint dfs_cache_init(void);\nvoid dfs_cache_destroy(void);\nextern const struct proc_ops dfscache_proc_ops;\n\nint dfs_cache_find(const unsigned int xid, struct cifs_ses *ses, const struct nls_table *cp,\n\t\t   int remap, const char *path, struct dfs_info3_param *ref,\n\t\t   struct dfs_cache_tgt_list *tgt_list);\nint dfs_cache_noreq_find(const char *path, struct dfs_info3_param *ref,\n\t\t\t struct dfs_cache_tgt_list *tgt_list);\nvoid dfs_cache_noreq_update_tgthint(const char *path, const struct dfs_cache_tgt_iterator *it);\nint dfs_cache_get_tgt_referral(const char *path, const struct dfs_cache_tgt_iterator *it,\n\t\t\t       struct dfs_info3_param *ref);\nint dfs_cache_get_tgt_share(char *path, const struct dfs_cache_tgt_iterator *it, char **share,\n\t\t\t    char **prefix);\nchar *dfs_cache_canonical_path(const char *path, const struct nls_table *cp, int remap);\nint dfs_cache_remount_fs(struct cifs_sb_info *cifs_sb);\nvoid dfs_cache_refresh(struct work_struct *work);\n\nstatic inline struct dfs_cache_tgt_iterator *\ndfs_cache_get_next_tgt(struct dfs_cache_tgt_list *tl,\n\t\t       struct dfs_cache_tgt_iterator *it)\n{\n\tif (!tl || !tl->tl_numtgts || list_empty(&tl->tl_list) ||\n\t    !it || list_is_last(&it->it_list, &tl->tl_list))\n\t\treturn NULL;\n\treturn list_next_entry(it, it_list);\n}\n\nstatic inline struct dfs_cache_tgt_iterator *\ndfs_cache_get_tgt_iterator(struct dfs_cache_tgt_list *tl)\n{\n\tif (!tl)\n\t\treturn NULL;\n\treturn list_first_entry_or_null(&tl->tl_list,\n\t\t\t\t\tstruct dfs_cache_tgt_iterator,\n\t\t\t\t\tit_list);\n}\n\nstatic inline void dfs_cache_free_tgts(struct dfs_cache_tgt_list *tl)\n{\n\tstruct dfs_cache_tgt_iterator *it, *nit;\n\n\tif (!tl || !tl->tl_numtgts || list_empty(&tl->tl_list))\n\t\treturn;\n\tlist_for_each_entry_safe(it, nit, &tl->tl_list, it_list) {\n\t\tlist_del(&it->it_list);\n\t\tkfree(it->it_name);\n\t\tkfree(it);\n\t}\n\ttl->tl_numtgts = 0;\n}\n\nstatic inline const char *\ndfs_cache_get_tgt_name(const struct dfs_cache_tgt_iterator *it)\n{\n\treturn it ? it->it_name : NULL;\n}\n\nstatic inline int\ndfs_cache_get_nr_tgts(const struct dfs_cache_tgt_list *tl)\n{\n\treturn tl ? tl->tl_numtgts : 0;\n}\n\nstatic inline int dfs_cache_get_ttl(void)\n{\n\treturn atomic_read(&dfs_cache_ttl);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}