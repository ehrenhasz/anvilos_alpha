{
  "module_name": "file.c",
  "hash_id": "4bc07fe709390d71146598fba2b6cbf4cba690505732805c9733231285aa1519",
  "original_prompt": "Ingested from linux-6.6.14/fs/smb/client/file.c",
  "human_readable_source": "\n \n#include <linux/fs.h>\n#include <linux/filelock.h>\n#include <linux/backing-dev.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/pagemap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/delay.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <asm/div64.h>\n#include \"cifsfs.h\"\n#include \"cifspdu.h\"\n#include \"cifsglob.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_fs_sb.h\"\n#include \"fscache.h\"\n#include \"smbdirect.h\"\n#include \"fs_context.h\"\n#include \"cifs_ioctl.h\"\n#include \"cached_dir.h\"\n\n \nstatic void cifs_undirty_folios(struct inode *inode, loff_t start, unsigned int len)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct folio *folio;\n\tpgoff_t end;\n\n\tXA_STATE(xas, &mapping->i_pages, start / PAGE_SIZE);\n\n\trcu_read_lock();\n\n\tend = (start + len - 1) / PAGE_SIZE;\n\txas_for_each_marked(&xas, folio, end, PAGECACHE_TAG_DIRTY) {\n\t\tif (xas_retry(&xas, folio))\n\t\t\tcontinue;\n\t\txas_pause(&xas);\n\t\trcu_read_unlock();\n\t\tfolio_lock(folio);\n\t\tfolio_clear_dirty_for_io(folio);\n\t\tfolio_unlock(folio);\n\t\trcu_read_lock();\n\t}\n\n\trcu_read_unlock();\n}\n\n \nvoid cifs_pages_written_back(struct inode *inode, loff_t start, unsigned int len)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct folio *folio;\n\tpgoff_t end;\n\n\tXA_STATE(xas, &mapping->i_pages, start / PAGE_SIZE);\n\n\tif (!len)\n\t\treturn;\n\n\trcu_read_lock();\n\n\tend = (start + len - 1) / PAGE_SIZE;\n\txas_for_each(&xas, folio, end) {\n\t\tif (xas_retry(&xas, folio))\n\t\t\tcontinue;\n\t\tif (!folio_test_writeback(folio)) {\n\t\t\tWARN_ONCE(1, \"bad %x @%llx page %lx %lx\\n\",\n\t\t\t\t  len, start, folio_index(folio), end);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfolio_detach_private(folio);\n\t\tfolio_end_writeback(folio);\n\t}\n\n\trcu_read_unlock();\n}\n\n \nvoid cifs_pages_write_failed(struct inode *inode, loff_t start, unsigned int len)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct folio *folio;\n\tpgoff_t end;\n\n\tXA_STATE(xas, &mapping->i_pages, start / PAGE_SIZE);\n\n\tif (!len)\n\t\treturn;\n\n\trcu_read_lock();\n\n\tend = (start + len - 1) / PAGE_SIZE;\n\txas_for_each(&xas, folio, end) {\n\t\tif (xas_retry(&xas, folio))\n\t\t\tcontinue;\n\t\tif (!folio_test_writeback(folio)) {\n\t\t\tWARN_ONCE(1, \"bad %x @%llx page %lx %lx\\n\",\n\t\t\t\t  len, start, folio_index(folio), end);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfolio_set_error(folio);\n\t\tfolio_end_writeback(folio);\n\t}\n\n\trcu_read_unlock();\n}\n\n \nvoid cifs_pages_write_redirty(struct inode *inode, loff_t start, unsigned int len)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct folio *folio;\n\tpgoff_t end;\n\n\tXA_STATE(xas, &mapping->i_pages, start / PAGE_SIZE);\n\n\tif (!len)\n\t\treturn;\n\n\trcu_read_lock();\n\n\tend = (start + len - 1) / PAGE_SIZE;\n\txas_for_each(&xas, folio, end) {\n\t\tif (!folio_test_writeback(folio)) {\n\t\t\tWARN_ONCE(1, \"bad %x @%llx page %lx %lx\\n\",\n\t\t\t\t  len, start, folio_index(folio), end);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfilemap_dirty_folio(folio->mapping, folio);\n\t\tfolio_end_writeback(folio);\n\t}\n\n\trcu_read_unlock();\n}\n\n \nvoid\ncifs_mark_open_files_invalid(struct cifs_tcon *tcon)\n{\n\tstruct cifsFileInfo *open_file = NULL;\n\tstruct list_head *tmp;\n\tstruct list_head *tmp1;\n\n\t \n\tspin_lock(&tcon->tc_lock);\n\tif (tcon->status != TID_NEED_RECON) {\n\t\tspin_unlock(&tcon->tc_lock);\n\t\treturn;\n\t}\n\ttcon->status = TID_IN_FILES_INVALIDATE;\n\tspin_unlock(&tcon->tc_lock);\n\n\t \n\tspin_lock(&tcon->open_file_lock);\n\tlist_for_each_safe(tmp, tmp1, &tcon->openFileList) {\n\t\topen_file = list_entry(tmp, struct cifsFileInfo, tlist);\n\t\topen_file->invalidHandle = true;\n\t\topen_file->oplock_break_cancelled = true;\n\t}\n\tspin_unlock(&tcon->open_file_lock);\n\n\tinvalidate_all_cached_dirs(tcon);\n\tspin_lock(&tcon->tc_lock);\n\tif (tcon->status == TID_IN_FILES_INVALIDATE)\n\t\ttcon->status = TID_NEED_TCON;\n\tspin_unlock(&tcon->tc_lock);\n\n\t \n}\n\nstatic inline int cifs_convert_flags(unsigned int flags)\n{\n\tif ((flags & O_ACCMODE) == O_RDONLY)\n\t\treturn GENERIC_READ;\n\telse if ((flags & O_ACCMODE) == O_WRONLY)\n\t\treturn GENERIC_WRITE;\n\telse if ((flags & O_ACCMODE) == O_RDWR) {\n\t\t \n\t\t \n\t\treturn (GENERIC_READ | GENERIC_WRITE);\n\t}\n\n\treturn (READ_CONTROL | FILE_WRITE_ATTRIBUTES | FILE_READ_ATTRIBUTES |\n\t\tFILE_WRITE_EA | FILE_APPEND_DATA | FILE_WRITE_DATA |\n\t\tFILE_READ_DATA);\n}\n\n#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY\nstatic u32 cifs_posix_convert_flags(unsigned int flags)\n{\n\tu32 posix_flags = 0;\n\n\tif ((flags & O_ACCMODE) == O_RDONLY)\n\t\tposix_flags = SMB_O_RDONLY;\n\telse if ((flags & O_ACCMODE) == O_WRONLY)\n\t\tposix_flags = SMB_O_WRONLY;\n\telse if ((flags & O_ACCMODE) == O_RDWR)\n\t\tposix_flags = SMB_O_RDWR;\n\n\tif (flags & O_CREAT) {\n\t\tposix_flags |= SMB_O_CREAT;\n\t\tif (flags & O_EXCL)\n\t\t\tposix_flags |= SMB_O_EXCL;\n\t} else if (flags & O_EXCL)\n\t\tcifs_dbg(FYI, \"Application %s pid %d has incorrectly set O_EXCL flag but not O_CREAT on file open. Ignoring O_EXCL\\n\",\n\t\t\t current->comm, current->tgid);\n\n\tif (flags & O_TRUNC)\n\t\tposix_flags |= SMB_O_TRUNC;\n\t \n\tif (flags & O_DSYNC)\n\t\tposix_flags |= SMB_O_SYNC;\n\tif (flags & O_DIRECTORY)\n\t\tposix_flags |= SMB_O_DIRECTORY;\n\tif (flags & O_NOFOLLOW)\n\t\tposix_flags |= SMB_O_NOFOLLOW;\n\tif (flags & O_DIRECT)\n\t\tposix_flags |= SMB_O_DIRECT;\n\n\treturn posix_flags;\n}\n#endif  \n\nstatic inline int cifs_get_disposition(unsigned int flags)\n{\n\tif ((flags & (O_CREAT | O_EXCL)) == (O_CREAT | O_EXCL))\n\t\treturn FILE_CREATE;\n\telse if ((flags & (O_CREAT | O_TRUNC)) == (O_CREAT | O_TRUNC))\n\t\treturn FILE_OVERWRITE_IF;\n\telse if ((flags & O_CREAT) == O_CREAT)\n\t\treturn FILE_OPEN_IF;\n\telse if ((flags & O_TRUNC) == O_TRUNC)\n\t\treturn FILE_OVERWRITE;\n\telse\n\t\treturn FILE_OPEN;\n}\n\n#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY\nint cifs_posix_open(const char *full_path, struct inode **pinode,\n\t\t\tstruct super_block *sb, int mode, unsigned int f_flags,\n\t\t\t__u32 *poplock, __u16 *pnetfid, unsigned int xid)\n{\n\tint rc;\n\tFILE_UNIX_BASIC_INFO *presp_data;\n\t__u32 posix_flags = 0;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct cifs_fattr fattr;\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *tcon;\n\n\tcifs_dbg(FYI, \"posix open %s\\n\", full_path);\n\n\tpresp_data = kzalloc(sizeof(FILE_UNIX_BASIC_INFO), GFP_KERNEL);\n\tif (presp_data == NULL)\n\t\treturn -ENOMEM;\n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink)) {\n\t\trc = PTR_ERR(tlink);\n\t\tgoto posix_open_ret;\n\t}\n\n\ttcon = tlink_tcon(tlink);\n\tmode &= ~current_umask();\n\n\tposix_flags = cifs_posix_convert_flags(f_flags);\n\trc = CIFSPOSIXCreate(xid, tcon, posix_flags, mode, pnetfid, presp_data,\n\t\t\t     poplock, full_path, cifs_sb->local_nls,\n\t\t\t     cifs_remap(cifs_sb));\n\tcifs_put_tlink(tlink);\n\n\tif (rc)\n\t\tgoto posix_open_ret;\n\n\tif (presp_data->Type == cpu_to_le32(-1))\n\t\tgoto posix_open_ret;  \n\n\tif (!pinode)\n\t\tgoto posix_open_ret;  \n\n\tcifs_unix_basic_to_fattr(&fattr, presp_data, cifs_sb);\n\n\t \n\tif (*pinode == NULL) {\n\t\tcifs_fill_uniqueid(sb, &fattr);\n\t\t*pinode = cifs_iget(sb, &fattr);\n\t\tif (!*pinode) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto posix_open_ret;\n\t\t}\n\t} else {\n\t\tcifs_revalidate_mapping(*pinode);\n\t\trc = cifs_fattr_to_inode(*pinode, &fattr);\n\t}\n\nposix_open_ret:\n\tkfree(presp_data);\n\treturn rc;\n}\n#endif  \n\nstatic int cifs_nt_open(const char *full_path, struct inode *inode, struct cifs_sb_info *cifs_sb,\n\t\t\tstruct cifs_tcon *tcon, unsigned int f_flags, __u32 *oplock,\n\t\t\tstruct cifs_fid *fid, unsigned int xid, struct cifs_open_info_data *buf)\n{\n\tint rc;\n\tint desired_access;\n\tint disposition;\n\tint create_options = CREATE_NOT_DIR;\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tstruct cifs_open_parms oparms;\n\n\tif (!server->ops->open)\n\t\treturn -ENOSYS;\n\n\tdesired_access = cifs_convert_flags(f_flags);\n\n \n\n\tdisposition = cifs_get_disposition(f_flags);\n\n\t \n\n\t \n\tif (f_flags & O_SYNC)\n\t\tcreate_options |= CREATE_WRITE_THROUGH;\n\n\tif (f_flags & O_DIRECT)\n\t\tcreate_options |= CREATE_NO_BUFFER;\n\n\toparms = (struct cifs_open_parms) {\n\t\t.tcon = tcon,\n\t\t.cifs_sb = cifs_sb,\n\t\t.desired_access = desired_access,\n\t\t.create_options = cifs_create_options(cifs_sb, create_options),\n\t\t.disposition = disposition,\n\t\t.path = full_path,\n\t\t.fid = fid,\n\t};\n\n\trc = server->ops->open(xid, &oparms, oplock, buf);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tif (tcon->unix_ext)\n\t\trc = cifs_get_inode_info_unix(&inode, full_path, inode->i_sb,\n\t\t\t\t\t      xid);\n\telse\n\t\trc = cifs_get_inode_info(&inode, full_path, buf, inode->i_sb,\n\t\t\t\t\t xid, fid);\n\n\tif (rc) {\n\t\tserver->ops->close(xid, tcon, fid);\n\t\tif (rc == -ESTALE)\n\t\t\trc = -EOPENSTALE;\n\t}\n\n\treturn rc;\n}\n\nstatic bool\ncifs_has_mand_locks(struct cifsInodeInfo *cinode)\n{\n\tstruct cifs_fid_locks *cur;\n\tbool has_locks = false;\n\n\tdown_read(&cinode->lock_sem);\n\tlist_for_each_entry(cur, &cinode->llist, llist) {\n\t\tif (!list_empty(&cur->locks)) {\n\t\t\thas_locks = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tup_read(&cinode->lock_sem);\n\treturn has_locks;\n}\n\nvoid\ncifs_down_write(struct rw_semaphore *sem)\n{\n\twhile (!down_write_trylock(sem))\n\t\tmsleep(10);\n}\n\nstatic void cifsFileInfo_put_work(struct work_struct *work);\n\nstruct cifsFileInfo *cifs_new_fileinfo(struct cifs_fid *fid, struct file *file,\n\t\t\t\t       struct tcon_link *tlink, __u32 oplock,\n\t\t\t\t       const char *symlink_target)\n{\n\tstruct dentry *dentry = file_dentry(file);\n\tstruct inode *inode = d_inode(dentry);\n\tstruct cifsInodeInfo *cinode = CIFS_I(inode);\n\tstruct cifsFileInfo *cfile;\n\tstruct cifs_fid_locks *fdlocks;\n\tstruct cifs_tcon *tcon = tlink_tcon(tlink);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\n\tcfile = kzalloc(sizeof(struct cifsFileInfo), GFP_KERNEL);\n\tif (cfile == NULL)\n\t\treturn cfile;\n\n\tfdlocks = kzalloc(sizeof(struct cifs_fid_locks), GFP_KERNEL);\n\tif (!fdlocks) {\n\t\tkfree(cfile);\n\t\treturn NULL;\n\t}\n\n\tif (symlink_target) {\n\t\tcfile->symlink_target = kstrdup(symlink_target, GFP_KERNEL);\n\t\tif (!cfile->symlink_target) {\n\t\t\tkfree(fdlocks);\n\t\t\tkfree(cfile);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tINIT_LIST_HEAD(&fdlocks->locks);\n\tfdlocks->cfile = cfile;\n\tcfile->llist = fdlocks;\n\n\tcfile->count = 1;\n\tcfile->pid = current->tgid;\n\tcfile->uid = current_fsuid();\n\tcfile->dentry = dget(dentry);\n\tcfile->f_flags = file->f_flags;\n\tcfile->invalidHandle = false;\n\tcfile->deferred_close_scheduled = false;\n\tcfile->tlink = cifs_get_tlink(tlink);\n\tINIT_WORK(&cfile->oplock_break, cifs_oplock_break);\n\tINIT_WORK(&cfile->put, cifsFileInfo_put_work);\n\tINIT_DELAYED_WORK(&cfile->deferred, smb2_deferred_work_close);\n\tmutex_init(&cfile->fh_mutex);\n\tspin_lock_init(&cfile->file_info_lock);\n\n\tcifs_sb_active(inode->i_sb);\n\n\t \n\tif (server->ops->is_read_op(oplock) && cifs_has_mand_locks(cinode)) {\n\t\tcifs_dbg(FYI, \"Reset oplock val from read to None due to mand locks\\n\");\n\t\toplock = 0;\n\t}\n\n\tcifs_down_write(&cinode->lock_sem);\n\tlist_add(&fdlocks->llist, &cinode->llist);\n\tup_write(&cinode->lock_sem);\n\n\tspin_lock(&tcon->open_file_lock);\n\tif (fid->pending_open->oplock != CIFS_OPLOCK_NO_CHANGE && oplock)\n\t\toplock = fid->pending_open->oplock;\n\tlist_del(&fid->pending_open->olist);\n\n\tfid->purge_cache = false;\n\tserver->ops->set_fid(cfile, fid, oplock);\n\n\tlist_add(&cfile->tlist, &tcon->openFileList);\n\tatomic_inc(&tcon->num_local_opens);\n\n\t \n\tspin_lock(&cinode->open_file_lock);\n\tif (file->f_mode & FMODE_READ)\n\t\tlist_add(&cfile->flist, &cinode->openFileList);\n\telse\n\t\tlist_add_tail(&cfile->flist, &cinode->openFileList);\n\tspin_unlock(&cinode->open_file_lock);\n\tspin_unlock(&tcon->open_file_lock);\n\n\tif (fid->purge_cache)\n\t\tcifs_zap_mapping(inode);\n\n\tfile->private_data = cfile;\n\treturn cfile;\n}\n\nstruct cifsFileInfo *\ncifsFileInfo_get(struct cifsFileInfo *cifs_file)\n{\n\tspin_lock(&cifs_file->file_info_lock);\n\tcifsFileInfo_get_locked(cifs_file);\n\tspin_unlock(&cifs_file->file_info_lock);\n\treturn cifs_file;\n}\n\nstatic void cifsFileInfo_put_final(struct cifsFileInfo *cifs_file)\n{\n\tstruct inode *inode = d_inode(cifs_file->dentry);\n\tstruct cifsInodeInfo *cifsi = CIFS_I(inode);\n\tstruct cifsLockInfo *li, *tmp;\n\tstruct super_block *sb = inode->i_sb;\n\n\t \n\tcifs_down_write(&cifsi->lock_sem);\n\tlist_for_each_entry_safe(li, tmp, &cifs_file->llist->locks, llist) {\n\t\tlist_del(&li->llist);\n\t\tcifs_del_lock_waiters(li);\n\t\tkfree(li);\n\t}\n\tlist_del(&cifs_file->llist->llist);\n\tkfree(cifs_file->llist);\n\tup_write(&cifsi->lock_sem);\n\n\tcifs_put_tlink(cifs_file->tlink);\n\tdput(cifs_file->dentry);\n\tcifs_sb_deactive(sb);\n\tkfree(cifs_file->symlink_target);\n\tkfree(cifs_file);\n}\n\nstatic void cifsFileInfo_put_work(struct work_struct *work)\n{\n\tstruct cifsFileInfo *cifs_file = container_of(work,\n\t\t\tstruct cifsFileInfo, put);\n\n\tcifsFileInfo_put_final(cifs_file);\n}\n\n \nvoid cifsFileInfo_put(struct cifsFileInfo *cifs_file)\n{\n\t_cifsFileInfo_put(cifs_file, true, true);\n}\n\n \nvoid _cifsFileInfo_put(struct cifsFileInfo *cifs_file,\n\t\t       bool wait_oplock_handler, bool offload)\n{\n\tstruct inode *inode = d_inode(cifs_file->dentry);\n\tstruct cifs_tcon *tcon = tlink_tcon(cifs_file->tlink);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tstruct cifsInodeInfo *cifsi = CIFS_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct cifs_fid fid = {};\n\tstruct cifs_pending_open open;\n\tbool oplock_break_cancelled;\n\n\tspin_lock(&tcon->open_file_lock);\n\tspin_lock(&cifsi->open_file_lock);\n\tspin_lock(&cifs_file->file_info_lock);\n\tif (--cifs_file->count > 0) {\n\t\tspin_unlock(&cifs_file->file_info_lock);\n\t\tspin_unlock(&cifsi->open_file_lock);\n\t\tspin_unlock(&tcon->open_file_lock);\n\t\treturn;\n\t}\n\tspin_unlock(&cifs_file->file_info_lock);\n\n\tif (server->ops->get_lease_key)\n\t\tserver->ops->get_lease_key(inode, &fid);\n\n\t \n\tcifs_add_pending_open_locked(&fid, cifs_file->tlink, &open);\n\n\t \n\tlist_del(&cifs_file->flist);\n\tlist_del(&cifs_file->tlist);\n\tatomic_dec(&tcon->num_local_opens);\n\n\tif (list_empty(&cifsi->openFileList)) {\n\t\tcifs_dbg(FYI, \"closing last open instance for inode %p\\n\",\n\t\t\t d_inode(cifs_file->dentry));\n\t\t \n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_STRICT_IO)\n\t\t\tset_bit(CIFS_INO_INVALID_MAPPING, &cifsi->flags);\n\t\tcifs_set_oplock_level(cifsi, 0);\n\t}\n\n\tspin_unlock(&cifsi->open_file_lock);\n\tspin_unlock(&tcon->open_file_lock);\n\n\toplock_break_cancelled = wait_oplock_handler ?\n\t\tcancel_work_sync(&cifs_file->oplock_break) : false;\n\n\tif (!tcon->need_reconnect && !cifs_file->invalidHandle) {\n\t\tstruct TCP_Server_Info *server = tcon->ses->server;\n\t\tunsigned int xid;\n\n\t\txid = get_xid();\n\t\tif (server->ops->close_getattr)\n\t\t\tserver->ops->close_getattr(xid, tcon, cifs_file);\n\t\telse if (server->ops->close)\n\t\t\tserver->ops->close(xid, tcon, &cifs_file->fid);\n\t\t_free_xid(xid);\n\t}\n\n\tif (oplock_break_cancelled)\n\t\tcifs_done_oplock_break(cifsi);\n\n\tcifs_del_pending_open(&open);\n\n\tif (offload)\n\t\tqueue_work(fileinfo_put_wq, &cifs_file->put);\n\telse\n\t\tcifsFileInfo_put_final(cifs_file);\n}\n\nint cifs_open(struct inode *inode, struct file *file)\n\n{\n\tint rc = -EACCES;\n\tunsigned int xid;\n\t__u32 oplock;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_tcon *tcon;\n\tstruct tcon_link *tlink;\n\tstruct cifsFileInfo *cfile = NULL;\n\tvoid *page;\n\tconst char *full_path;\n\tbool posix_open_ok = false;\n\tstruct cifs_fid fid = {};\n\tstruct cifs_pending_open open;\n\tstruct cifs_open_info_data data = {};\n\n\txid = get_xid();\n\n\tcifs_sb = CIFS_SB(inode->i_sb);\n\tif (unlikely(cifs_forced_shutdown(cifs_sb))) {\n\t\tfree_xid(xid);\n\t\treturn -EIO;\n\t}\n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink)) {\n\t\tfree_xid(xid);\n\t\treturn PTR_ERR(tlink);\n\t}\n\ttcon = tlink_tcon(tlink);\n\tserver = tcon->ses->server;\n\n\tpage = alloc_dentry_path();\n\tfull_path = build_path_from_dentry(file_dentry(file), page);\n\tif (IS_ERR(full_path)) {\n\t\trc = PTR_ERR(full_path);\n\t\tgoto out;\n\t}\n\n\tcifs_dbg(FYI, \"inode = 0x%p file flags are 0x%x for %s\\n\",\n\t\t inode, file->f_flags, full_path);\n\n\tif (file->f_flags & O_DIRECT &&\n\t    cifs_sb->mnt_cifs_flags & CIFS_MOUNT_STRICT_IO) {\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_BRL)\n\t\t\tfile->f_op = &cifs_file_direct_nobrl_ops;\n\t\telse\n\t\t\tfile->f_op = &cifs_file_direct_ops;\n\t}\n\n\t \n\trc = cifs_get_readable_path(tcon, full_path, &cfile);\n\tif (rc == 0) {\n\t\tif (file->f_flags == cfile->f_flags) {\n\t\t\tfile->private_data = cfile;\n\t\t\tspin_lock(&CIFS_I(inode)->deferred_lock);\n\t\t\tcifs_del_deferred_close(cfile);\n\t\t\tspin_unlock(&CIFS_I(inode)->deferred_lock);\n\t\t\tgoto use_cache;\n\t\t} else {\n\t\t\t_cifsFileInfo_put(cfile, true, false);\n\t\t}\n\t}\n\n\tif (server->oplocks)\n\t\toplock = REQ_OPLOCK;\n\telse\n\t\toplock = 0;\n\n#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY\n\tif (!tcon->broken_posix_open && tcon->unix_ext &&\n\t    cap_unix(tcon->ses) && (CIFS_UNIX_POSIX_PATH_OPS_CAP &\n\t\t\t\tle64_to_cpu(tcon->fsUnixInfo.Capability))) {\n\t\t \n\t\trc = cifs_posix_open(full_path, &inode, inode->i_sb,\n\t\t\t\tcifs_sb->ctx->file_mode  ,\n\t\t\t\tfile->f_flags, &oplock, &fid.netfid, xid);\n\t\tif (rc == 0) {\n\t\t\tcifs_dbg(FYI, \"posix open succeeded\\n\");\n\t\t\tposix_open_ok = true;\n\t\t} else if ((rc == -EINVAL) || (rc == -EOPNOTSUPP)) {\n\t\t\tif (tcon->ses->serverNOS)\n\t\t\t\tcifs_dbg(VFS, \"server %s of type %s returned unexpected error on SMB posix open, disabling posix open support. Check if server update available.\\n\",\n\t\t\t\t\t tcon->ses->ip_addr,\n\t\t\t\t\t tcon->ses->serverNOS);\n\t\t\ttcon->broken_posix_open = true;\n\t\t} else if ((rc != -EIO) && (rc != -EREMOTE) &&\n\t\t\t (rc != -EOPNOTSUPP))  \n\t\t\tgoto out;\n\t\t \n\t}\n#endif  \n\n\tif (server->ops->get_lease_key)\n\t\tserver->ops->get_lease_key(inode, &fid);\n\n\tcifs_add_pending_open(&fid, tlink, &open);\n\n\tif (!posix_open_ok) {\n\t\tif (server->ops->get_lease_key)\n\t\t\tserver->ops->get_lease_key(inode, &fid);\n\n\t\trc = cifs_nt_open(full_path, inode, cifs_sb, tcon, file->f_flags, &oplock, &fid,\n\t\t\t\t  xid, &data);\n\t\tif (rc) {\n\t\t\tcifs_del_pending_open(&open);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tcfile = cifs_new_fileinfo(&fid, file, tlink, oplock, data.symlink_target);\n\tif (cfile == NULL) {\n\t\tif (server->ops->close)\n\t\t\tserver->ops->close(xid, tcon, &fid);\n\t\tcifs_del_pending_open(&open);\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY\n\tif ((oplock & CIFS_CREATE_ACTION) && !posix_open_ok && tcon->unix_ext) {\n\t\t \n\t\tstruct cifs_unix_set_info_args args = {\n\t\t\t.mode\t= inode->i_mode,\n\t\t\t.uid\t= INVALID_UID,  \n\t\t\t.gid\t= INVALID_GID,  \n\t\t\t.ctime\t= NO_CHANGE_64,\n\t\t\t.atime\t= NO_CHANGE_64,\n\t\t\t.mtime\t= NO_CHANGE_64,\n\t\t\t.device\t= 0,\n\t\t};\n\t\tCIFSSMBUnixSetFileInfo(xid, tcon, &args, fid.netfid,\n\t\t\t\t       cfile->pid);\n\t}\n#endif  \n\nuse_cache:\n\tfscache_use_cookie(cifs_inode_cookie(file_inode(file)),\n\t\t\t   file->f_mode & FMODE_WRITE);\n\tif (file->f_flags & O_DIRECT &&\n\t    (!((file->f_flags & O_ACCMODE) != O_RDONLY) ||\n\t     file->f_flags & O_APPEND))\n\t\tcifs_invalidate_cache(file_inode(file),\n\t\t\t\t      FSCACHE_INVAL_DIO_WRITE);\n\nout:\n\tfree_dentry_path(page);\n\tfree_xid(xid);\n\tcifs_put_tlink(tlink);\n\tcifs_free_open_info(&data);\n\treturn rc;\n}\n\n#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY\nstatic int cifs_push_posix_locks(struct cifsFileInfo *cfile);\n#endif  \n\n \nstatic int\ncifs_relock_file(struct cifsFileInfo *cfile)\n{\n\tstruct cifsInodeInfo *cinode = CIFS_I(d_inode(cfile->dentry));\n\tstruct cifs_tcon *tcon = tlink_tcon(cfile->tlink);\n\tint rc = 0;\n#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(cfile->dentry->d_sb);\n#endif  \n\n\tdown_read_nested(&cinode->lock_sem, SINGLE_DEPTH_NESTING);\n\tif (cinode->can_cache_brlcks) {\n\t\t \n\t\tup_read(&cinode->lock_sem);\n\t\treturn rc;\n\t}\n\n#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY\n\tif (cap_unix(tcon->ses) &&\n\t    (CIFS_UNIX_FCNTL_CAP & le64_to_cpu(tcon->fsUnixInfo.Capability)) &&\n\t    ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NOPOSIXBRL) == 0))\n\t\trc = cifs_push_posix_locks(cfile);\n\telse\n#endif  \n\t\trc = tcon->ses->server->ops->push_mand_locks(cfile);\n\n\tup_read(&cinode->lock_sem);\n\treturn rc;\n}\n\nstatic int\ncifs_reopen_file(struct cifsFileInfo *cfile, bool can_flush)\n{\n\tint rc = -EACCES;\n\tunsigned int xid;\n\t__u32 oplock;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tstruct cifsInodeInfo *cinode;\n\tstruct inode *inode;\n\tvoid *page;\n\tconst char *full_path;\n\tint desired_access;\n\tint disposition = FILE_OPEN;\n\tint create_options = CREATE_NOT_DIR;\n\tstruct cifs_open_parms oparms;\n\n\txid = get_xid();\n\tmutex_lock(&cfile->fh_mutex);\n\tif (!cfile->invalidHandle) {\n\t\tmutex_unlock(&cfile->fh_mutex);\n\t\tfree_xid(xid);\n\t\treturn 0;\n\t}\n\n\tinode = d_inode(cfile->dentry);\n\tcifs_sb = CIFS_SB(inode->i_sb);\n\ttcon = tlink_tcon(cfile->tlink);\n\tserver = tcon->ses->server;\n\n\t \n\tpage = alloc_dentry_path();\n\tfull_path = build_path_from_dentry(cfile->dentry, page);\n\tif (IS_ERR(full_path)) {\n\t\tmutex_unlock(&cfile->fh_mutex);\n\t\tfree_dentry_path(page);\n\t\tfree_xid(xid);\n\t\treturn PTR_ERR(full_path);\n\t}\n\n\tcifs_dbg(FYI, \"inode = 0x%p file flags 0x%x for %s\\n\",\n\t\t inode, cfile->f_flags, full_path);\n\n\tif (tcon->ses->server->oplocks)\n\t\toplock = REQ_OPLOCK;\n\telse\n\t\toplock = 0;\n\n#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY\n\tif (tcon->unix_ext && cap_unix(tcon->ses) &&\n\t    (CIFS_UNIX_POSIX_PATH_OPS_CAP &\n\t\t\t\tle64_to_cpu(tcon->fsUnixInfo.Capability))) {\n\t\t \n\t\tunsigned int oflags = cfile->f_flags &\n\t\t\t\t\t\t~(O_CREAT | O_EXCL | O_TRUNC);\n\n\t\trc = cifs_posix_open(full_path, NULL, inode->i_sb,\n\t\t\t\t     cifs_sb->ctx->file_mode  ,\n\t\t\t\t     oflags, &oplock, &cfile->fid.netfid, xid);\n\t\tif (rc == 0) {\n\t\t\tcifs_dbg(FYI, \"posix reopen succeeded\\n\");\n\t\t\toparms.reconnect = true;\n\t\t\tgoto reopen_success;\n\t\t}\n\t\t \n\t}\n#endif  \n\n\tdesired_access = cifs_convert_flags(cfile->f_flags);\n\n\t \n\tif (cfile->f_flags & O_SYNC)\n\t\tcreate_options |= CREATE_WRITE_THROUGH;\n\n\tif (cfile->f_flags & O_DIRECT)\n\t\tcreate_options |= CREATE_NO_BUFFER;\n\n\tif (server->ops->get_lease_key)\n\t\tserver->ops->get_lease_key(inode, &cfile->fid);\n\n\toparms = (struct cifs_open_parms) {\n\t\t.tcon = tcon,\n\t\t.cifs_sb = cifs_sb,\n\t\t.desired_access = desired_access,\n\t\t.create_options = cifs_create_options(cifs_sb, create_options),\n\t\t.disposition = disposition,\n\t\t.path = full_path,\n\t\t.fid = &cfile->fid,\n\t\t.reconnect = true,\n\t};\n\n\t \n\trc = server->ops->open(xid, &oparms, &oplock, NULL);\n\tif (rc == -ENOENT && oparms.reconnect == false) {\n\t\t \n\t\trc = server->ops->open(xid, &oparms, &oplock, NULL);\n\t\t \n\t\toparms.reconnect = true;\n\t}\n\n\tif (rc) {\n\t\tmutex_unlock(&cfile->fh_mutex);\n\t\tcifs_dbg(FYI, \"cifs_reopen returned 0x%x\\n\", rc);\n\t\tcifs_dbg(FYI, \"oplock: %d\\n\", oplock);\n\t\tgoto reopen_error_exit;\n\t}\n\n#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY\nreopen_success:\n#endif  \n\tcfile->invalidHandle = false;\n\tmutex_unlock(&cfile->fh_mutex);\n\tcinode = CIFS_I(inode);\n\n\tif (can_flush) {\n\t\trc = filemap_write_and_wait(inode->i_mapping);\n\t\tif (!is_interrupt_error(rc))\n\t\t\tmapping_set_error(inode->i_mapping, rc);\n\n\t\tif (tcon->posix_extensions)\n\t\t\trc = smb311_posix_get_inode_info(&inode, full_path, inode->i_sb, xid);\n\t\telse if (tcon->unix_ext)\n\t\t\trc = cifs_get_inode_info_unix(&inode, full_path,\n\t\t\t\t\t\t      inode->i_sb, xid);\n\t\telse\n\t\t\trc = cifs_get_inode_info(&inode, full_path, NULL,\n\t\t\t\t\t\t inode->i_sb, xid, NULL);\n\t}\n\t \n\n\t \n\tif (server->ops->is_read_op(oplock) && cifs_has_mand_locks(cinode)) {\n\t\tcifs_dbg(FYI, \"Reset oplock val from read to None due to mand locks\\n\");\n\t\toplock = 0;\n\t}\n\n\tserver->ops->set_fid(cfile, &cfile->fid, oplock);\n\tif (oparms.reconnect)\n\t\tcifs_relock_file(cfile);\n\nreopen_error_exit:\n\tfree_dentry_path(page);\n\tfree_xid(xid);\n\treturn rc;\n}\n\nvoid smb2_deferred_work_close(struct work_struct *work)\n{\n\tstruct cifsFileInfo *cfile = container_of(work,\n\t\t\tstruct cifsFileInfo, deferred.work);\n\n\tspin_lock(&CIFS_I(d_inode(cfile->dentry))->deferred_lock);\n\tcifs_del_deferred_close(cfile);\n\tcfile->deferred_close_scheduled = false;\n\tspin_unlock(&CIFS_I(d_inode(cfile->dentry))->deferred_lock);\n\t_cifsFileInfo_put(cfile, true, false);\n}\n\nint cifs_close(struct inode *inode, struct file *file)\n{\n\tstruct cifsFileInfo *cfile;\n\tstruct cifsInodeInfo *cinode = CIFS_I(inode);\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct cifs_deferred_close *dclose;\n\n\tcifs_fscache_unuse_inode_cookie(inode, file->f_mode & FMODE_WRITE);\n\n\tif (file->private_data != NULL) {\n\t\tcfile = file->private_data;\n\t\tfile->private_data = NULL;\n\t\tdclose = kmalloc(sizeof(struct cifs_deferred_close), GFP_KERNEL);\n\t\tif ((cifs_sb->ctx->closetimeo && cinode->oplock == CIFS_CACHE_RHW_FLG)\n\t\t    && cinode->lease_granted &&\n\t\t    !test_bit(CIFS_INO_CLOSE_ON_LOCK, &cinode->flags) &&\n\t\t    dclose) {\n\t\t\tif (test_and_clear_bit(CIFS_INO_MODIFIED_ATTR, &cinode->flags)) {\n\t\t\t\tinode_set_mtime_to_ts(inode,\n\t\t\t\t\t\t      inode_set_ctime_current(inode));\n\t\t\t}\n\t\t\tspin_lock(&cinode->deferred_lock);\n\t\t\tcifs_add_deferred_close(cfile, dclose);\n\t\t\tif (cfile->deferred_close_scheduled &&\n\t\t\t    delayed_work_pending(&cfile->deferred)) {\n\t\t\t\t \n\t\t\t\tif (!mod_delayed_work(deferredclose_wq,\n\t\t\t\t\t\t&cfile->deferred, cifs_sb->ctx->closetimeo))\n\t\t\t\t\tcifsFileInfo_get(cfile);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tqueue_delayed_work(deferredclose_wq,\n\t\t\t\t\t\t&cfile->deferred, cifs_sb->ctx->closetimeo);\n\t\t\t\tcfile->deferred_close_scheduled = true;\n\t\t\t\tspin_unlock(&cinode->deferred_lock);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tspin_unlock(&cinode->deferred_lock);\n\t\t\t_cifsFileInfo_put(cfile, true, false);\n\t\t} else {\n\t\t\t_cifsFileInfo_put(cfile, true, false);\n\t\t\tkfree(dclose);\n\t\t}\n\t}\n\n\t \n\treturn 0;\n}\n\nvoid\ncifs_reopen_persistent_handles(struct cifs_tcon *tcon)\n{\n\tstruct cifsFileInfo *open_file, *tmp;\n\tstruct list_head tmp_list;\n\n\tif (!tcon->use_persistent || !tcon->need_reopen_files)\n\t\treturn;\n\n\ttcon->need_reopen_files = false;\n\n\tcifs_dbg(FYI, \"Reopen persistent handles\\n\");\n\tINIT_LIST_HEAD(&tmp_list);\n\n\t \n\tspin_lock(&tcon->open_file_lock);\n\tlist_for_each_entry(open_file, &tcon->openFileList, tlist) {\n\t\tif (!open_file->invalidHandle)\n\t\t\tcontinue;\n\t\tcifsFileInfo_get(open_file);\n\t\tlist_add_tail(&open_file->rlist, &tmp_list);\n\t}\n\tspin_unlock(&tcon->open_file_lock);\n\n\tlist_for_each_entry_safe(open_file, tmp, &tmp_list, rlist) {\n\t\tif (cifs_reopen_file(open_file, false  ))\n\t\t\ttcon->need_reopen_files = true;\n\t\tlist_del_init(&open_file->rlist);\n\t\tcifsFileInfo_put(open_file);\n\t}\n}\n\nint cifs_closedir(struct inode *inode, struct file *file)\n{\n\tint rc = 0;\n\tunsigned int xid;\n\tstruct cifsFileInfo *cfile = file->private_data;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tchar *buf;\n\n\tcifs_dbg(FYI, \"Closedir inode = 0x%p\\n\", inode);\n\n\tif (cfile == NULL)\n\t\treturn rc;\n\n\txid = get_xid();\n\ttcon = tlink_tcon(cfile->tlink);\n\tserver = tcon->ses->server;\n\n\tcifs_dbg(FYI, \"Freeing private data in close dir\\n\");\n\tspin_lock(&cfile->file_info_lock);\n\tif (server->ops->dir_needs_close(cfile)) {\n\t\tcfile->invalidHandle = true;\n\t\tspin_unlock(&cfile->file_info_lock);\n\t\tif (server->ops->close_dir)\n\t\t\trc = server->ops->close_dir(xid, tcon, &cfile->fid);\n\t\telse\n\t\t\trc = -ENOSYS;\n\t\tcifs_dbg(FYI, \"Closing uncompleted readdir with rc %d\\n\", rc);\n\t\t \n\t\trc = 0;\n\t} else\n\t\tspin_unlock(&cfile->file_info_lock);\n\n\tbuf = cfile->srch_inf.ntwrk_buf_start;\n\tif (buf) {\n\t\tcifs_dbg(FYI, \"closedir free smb buf in srch struct\\n\");\n\t\tcfile->srch_inf.ntwrk_buf_start = NULL;\n\t\tif (cfile->srch_inf.smallBuf)\n\t\t\tcifs_small_buf_release(buf);\n\t\telse\n\t\t\tcifs_buf_release(buf);\n\t}\n\n\tcifs_put_tlink(cfile->tlink);\n\tkfree(file->private_data);\n\tfile->private_data = NULL;\n\t \n\tfree_xid(xid);\n\treturn rc;\n}\n\nstatic struct cifsLockInfo *\ncifs_lock_init(__u64 offset, __u64 length, __u8 type, __u16 flags)\n{\n\tstruct cifsLockInfo *lock =\n\t\tkmalloc(sizeof(struct cifsLockInfo), GFP_KERNEL);\n\tif (!lock)\n\t\treturn lock;\n\tlock->offset = offset;\n\tlock->length = length;\n\tlock->type = type;\n\tlock->pid = current->tgid;\n\tlock->flags = flags;\n\tINIT_LIST_HEAD(&lock->blist);\n\tinit_waitqueue_head(&lock->block_q);\n\treturn lock;\n}\n\nvoid\ncifs_del_lock_waiters(struct cifsLockInfo *lock)\n{\n\tstruct cifsLockInfo *li, *tmp;\n\tlist_for_each_entry_safe(li, tmp, &lock->blist, blist) {\n\t\tlist_del_init(&li->blist);\n\t\twake_up(&li->block_q);\n\t}\n}\n\n#define CIFS_LOCK_OP\t0\n#define CIFS_READ_OP\t1\n#define CIFS_WRITE_OP\t2\n\n \nstatic bool\ncifs_find_fid_lock_conflict(struct cifs_fid_locks *fdlocks, __u64 offset,\n\t\t\t    __u64 length, __u8 type, __u16 flags,\n\t\t\t    struct cifsFileInfo *cfile,\n\t\t\t    struct cifsLockInfo **conf_lock, int rw_check)\n{\n\tstruct cifsLockInfo *li;\n\tstruct cifsFileInfo *cur_cfile = fdlocks->cfile;\n\tstruct TCP_Server_Info *server = tlink_tcon(cfile->tlink)->ses->server;\n\n\tlist_for_each_entry(li, &fdlocks->locks, llist) {\n\t\tif (offset + length <= li->offset ||\n\t\t    offset >= li->offset + li->length)\n\t\t\tcontinue;\n\t\tif (rw_check != CIFS_LOCK_OP && current->tgid == li->pid &&\n\t\t    server->ops->compare_fids(cfile, cur_cfile)) {\n\t\t\t \n\t\t\tif (!(li->type & server->vals->shared_lock_type) ||\n\t\t\t    rw_check != CIFS_WRITE_OP)\n\t\t\t\tcontinue;\n\t\t}\n\t\tif ((type & server->vals->shared_lock_type) &&\n\t\t    ((server->ops->compare_fids(cfile, cur_cfile) &&\n\t\t     current->tgid == li->pid) || type == li->type))\n\t\t\tcontinue;\n\t\tif (rw_check == CIFS_LOCK_OP &&\n\t\t    (flags & FL_OFDLCK) && (li->flags & FL_OFDLCK) &&\n\t\t    server->ops->compare_fids(cfile, cur_cfile))\n\t\t\tcontinue;\n\t\tif (conf_lock)\n\t\t\t*conf_lock = li;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool\ncifs_find_lock_conflict(struct cifsFileInfo *cfile, __u64 offset, __u64 length,\n\t\t\t__u8 type, __u16 flags,\n\t\t\tstruct cifsLockInfo **conf_lock, int rw_check)\n{\n\tbool rc = false;\n\tstruct cifs_fid_locks *cur;\n\tstruct cifsInodeInfo *cinode = CIFS_I(d_inode(cfile->dentry));\n\n\tlist_for_each_entry(cur, &cinode->llist, llist) {\n\t\trc = cifs_find_fid_lock_conflict(cur, offset, length, type,\n\t\t\t\t\t\t flags, cfile, conf_lock,\n\t\t\t\t\t\t rw_check);\n\t\tif (rc)\n\t\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\n \nstatic int\ncifs_lock_test(struct cifsFileInfo *cfile, __u64 offset, __u64 length,\n\t       __u8 type, struct file_lock *flock)\n{\n\tint rc = 0;\n\tstruct cifsLockInfo *conf_lock;\n\tstruct cifsInodeInfo *cinode = CIFS_I(d_inode(cfile->dentry));\n\tstruct TCP_Server_Info *server = tlink_tcon(cfile->tlink)->ses->server;\n\tbool exist;\n\n\tdown_read(&cinode->lock_sem);\n\n\texist = cifs_find_lock_conflict(cfile, offset, length, type,\n\t\t\t\t\tflock->fl_flags, &conf_lock,\n\t\t\t\t\tCIFS_LOCK_OP);\n\tif (exist) {\n\t\tflock->fl_start = conf_lock->offset;\n\t\tflock->fl_end = conf_lock->offset + conf_lock->length - 1;\n\t\tflock->fl_pid = conf_lock->pid;\n\t\tif (conf_lock->type & server->vals->shared_lock_type)\n\t\t\tflock->fl_type = F_RDLCK;\n\t\telse\n\t\t\tflock->fl_type = F_WRLCK;\n\t} else if (!cinode->can_cache_brlcks)\n\t\trc = 1;\n\telse\n\t\tflock->fl_type = F_UNLCK;\n\n\tup_read(&cinode->lock_sem);\n\treturn rc;\n}\n\nstatic void\ncifs_lock_add(struct cifsFileInfo *cfile, struct cifsLockInfo *lock)\n{\n\tstruct cifsInodeInfo *cinode = CIFS_I(d_inode(cfile->dentry));\n\tcifs_down_write(&cinode->lock_sem);\n\tlist_add_tail(&lock->llist, &cfile->llist->locks);\n\tup_write(&cinode->lock_sem);\n}\n\n \nstatic int\ncifs_lock_add_if(struct cifsFileInfo *cfile, struct cifsLockInfo *lock,\n\t\t bool wait)\n{\n\tstruct cifsLockInfo *conf_lock;\n\tstruct cifsInodeInfo *cinode = CIFS_I(d_inode(cfile->dentry));\n\tbool exist;\n\tint rc = 0;\n\ntry_again:\n\texist = false;\n\tcifs_down_write(&cinode->lock_sem);\n\n\texist = cifs_find_lock_conflict(cfile, lock->offset, lock->length,\n\t\t\t\t\tlock->type, lock->flags, &conf_lock,\n\t\t\t\t\tCIFS_LOCK_OP);\n\tif (!exist && cinode->can_cache_brlcks) {\n\t\tlist_add_tail(&lock->llist, &cfile->llist->locks);\n\t\tup_write(&cinode->lock_sem);\n\t\treturn rc;\n\t}\n\n\tif (!exist)\n\t\trc = 1;\n\telse if (!wait)\n\t\trc = -EACCES;\n\telse {\n\t\tlist_add_tail(&lock->blist, &conf_lock->blist);\n\t\tup_write(&cinode->lock_sem);\n\t\trc = wait_event_interruptible(lock->block_q,\n\t\t\t\t\t(lock->blist.prev == &lock->blist) &&\n\t\t\t\t\t(lock->blist.next == &lock->blist));\n\t\tif (!rc)\n\t\t\tgoto try_again;\n\t\tcifs_down_write(&cinode->lock_sem);\n\t\tlist_del_init(&lock->blist);\n\t}\n\n\tup_write(&cinode->lock_sem);\n\treturn rc;\n}\n\n#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY\n \nstatic int\ncifs_posix_lock_test(struct file *file, struct file_lock *flock)\n{\n\tint rc = 0;\n\tstruct cifsInodeInfo *cinode = CIFS_I(file_inode(file));\n\tunsigned char saved_type = flock->fl_type;\n\n\tif ((flock->fl_flags & FL_POSIX) == 0)\n\t\treturn 1;\n\n\tdown_read(&cinode->lock_sem);\n\tposix_test_lock(file, flock);\n\n\tif (flock->fl_type == F_UNLCK && !cinode->can_cache_brlcks) {\n\t\tflock->fl_type = saved_type;\n\t\trc = 1;\n\t}\n\n\tup_read(&cinode->lock_sem);\n\treturn rc;\n}\n\n \nstatic int\ncifs_posix_lock_set(struct file *file, struct file_lock *flock)\n{\n\tstruct cifsInodeInfo *cinode = CIFS_I(file_inode(file));\n\tint rc = FILE_LOCK_DEFERRED + 1;\n\n\tif ((flock->fl_flags & FL_POSIX) == 0)\n\t\treturn rc;\n\n\tcifs_down_write(&cinode->lock_sem);\n\tif (!cinode->can_cache_brlcks) {\n\t\tup_write(&cinode->lock_sem);\n\t\treturn rc;\n\t}\n\n\trc = posix_lock_file(file, flock, NULL);\n\tup_write(&cinode->lock_sem);\n\treturn rc;\n}\n\nint\ncifs_push_mandatory_locks(struct cifsFileInfo *cfile)\n{\n\tunsigned int xid;\n\tint rc = 0, stored_rc;\n\tstruct cifsLockInfo *li, *tmp;\n\tstruct cifs_tcon *tcon;\n\tunsigned int num, max_num, max_buf;\n\tLOCKING_ANDX_RANGE *buf, *cur;\n\tstatic const int types[] = {\n\t\tLOCKING_ANDX_LARGE_FILES,\n\t\tLOCKING_ANDX_SHARED_LOCK | LOCKING_ANDX_LARGE_FILES\n\t};\n\tint i;\n\n\txid = get_xid();\n\ttcon = tlink_tcon(cfile->tlink);\n\n\t \n\tmax_buf = tcon->ses->server->maxBuf;\n\tif (max_buf < (sizeof(struct smb_hdr) + sizeof(LOCKING_ANDX_RANGE))) {\n\t\tfree_xid(xid);\n\t\treturn -EINVAL;\n\t}\n\n\tBUILD_BUG_ON(sizeof(struct smb_hdr) + sizeof(LOCKING_ANDX_RANGE) >\n\t\t     PAGE_SIZE);\n\tmax_buf = min_t(unsigned int, max_buf - sizeof(struct smb_hdr),\n\t\t\tPAGE_SIZE);\n\tmax_num = (max_buf - sizeof(struct smb_hdr)) /\n\t\t\t\t\t\tsizeof(LOCKING_ANDX_RANGE);\n\tbuf = kcalloc(max_num, sizeof(LOCKING_ANDX_RANGE), GFP_KERNEL);\n\tif (!buf) {\n\t\tfree_xid(xid);\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < 2; i++) {\n\t\tcur = buf;\n\t\tnum = 0;\n\t\tlist_for_each_entry_safe(li, tmp, &cfile->llist->locks, llist) {\n\t\t\tif (li->type != types[i])\n\t\t\t\tcontinue;\n\t\t\tcur->Pid = cpu_to_le16(li->pid);\n\t\t\tcur->LengthLow = cpu_to_le32((u32)li->length);\n\t\t\tcur->LengthHigh = cpu_to_le32((u32)(li->length>>32));\n\t\t\tcur->OffsetLow = cpu_to_le32((u32)li->offset);\n\t\t\tcur->OffsetHigh = cpu_to_le32((u32)(li->offset>>32));\n\t\t\tif (++num == max_num) {\n\t\t\t\tstored_rc = cifs_lockv(xid, tcon,\n\t\t\t\t\t\t       cfile->fid.netfid,\n\t\t\t\t\t\t       (__u8)li->type, 0, num,\n\t\t\t\t\t\t       buf);\n\t\t\t\tif (stored_rc)\n\t\t\t\t\trc = stored_rc;\n\t\t\t\tcur = buf;\n\t\t\t\tnum = 0;\n\t\t\t} else\n\t\t\t\tcur++;\n\t\t}\n\n\t\tif (num) {\n\t\t\tstored_rc = cifs_lockv(xid, tcon, cfile->fid.netfid,\n\t\t\t\t\t       (__u8)types[i], 0, num, buf);\n\t\t\tif (stored_rc)\n\t\t\t\trc = stored_rc;\n\t\t}\n\t}\n\n\tkfree(buf);\n\tfree_xid(xid);\n\treturn rc;\n}\n\nstatic __u32\nhash_lockowner(fl_owner_t owner)\n{\n\treturn cifs_lock_secret ^ hash32_ptr((const void *)owner);\n}\n#endif  \n\nstruct lock_to_push {\n\tstruct list_head llist;\n\t__u64 offset;\n\t__u64 length;\n\t__u32 pid;\n\t__u16 netfid;\n\t__u8 type;\n};\n\n#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY\nstatic int\ncifs_push_posix_locks(struct cifsFileInfo *cfile)\n{\n\tstruct inode *inode = d_inode(cfile->dentry);\n\tstruct cifs_tcon *tcon = tlink_tcon(cfile->tlink);\n\tstruct file_lock *flock;\n\tstruct file_lock_context *flctx = locks_inode_context(inode);\n\tunsigned int count = 0, i;\n\tint rc = 0, xid, type;\n\tstruct list_head locks_to_send, *el;\n\tstruct lock_to_push *lck, *tmp;\n\t__u64 length;\n\n\txid = get_xid();\n\n\tif (!flctx)\n\t\tgoto out;\n\n\tspin_lock(&flctx->flc_lock);\n\tlist_for_each(el, &flctx->flc_posix) {\n\t\tcount++;\n\t}\n\tspin_unlock(&flctx->flc_lock);\n\n\tINIT_LIST_HEAD(&locks_to_send);\n\n\t \n\tfor (i = 0; i < count; i++) {\n\t\tlck = kmalloc(sizeof(struct lock_to_push), GFP_KERNEL);\n\t\tif (!lck) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto err_out;\n\t\t}\n\t\tlist_add_tail(&lck->llist, &locks_to_send);\n\t}\n\n\tel = locks_to_send.next;\n\tspin_lock(&flctx->flc_lock);\n\tlist_for_each_entry(flock, &flctx->flc_posix, fl_list) {\n\t\tif (el == &locks_to_send) {\n\t\t\t \n\t\t\tcifs_dbg(VFS, \"Can't push all brlocks!\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tlength = cifs_flock_len(flock);\n\t\tif (flock->fl_type == F_RDLCK || flock->fl_type == F_SHLCK)\n\t\t\ttype = CIFS_RDLCK;\n\t\telse\n\t\t\ttype = CIFS_WRLCK;\n\t\tlck = list_entry(el, struct lock_to_push, llist);\n\t\tlck->pid = hash_lockowner(flock->fl_owner);\n\t\tlck->netfid = cfile->fid.netfid;\n\t\tlck->length = length;\n\t\tlck->type = type;\n\t\tlck->offset = flock->fl_start;\n\t}\n\tspin_unlock(&flctx->flc_lock);\n\n\tlist_for_each_entry_safe(lck, tmp, &locks_to_send, llist) {\n\t\tint stored_rc;\n\n\t\tstored_rc = CIFSSMBPosixLock(xid, tcon, lck->netfid, lck->pid,\n\t\t\t\t\t     lck->offset, lck->length, NULL,\n\t\t\t\t\t     lck->type, 0);\n\t\tif (stored_rc)\n\t\t\trc = stored_rc;\n\t\tlist_del(&lck->llist);\n\t\tkfree(lck);\n\t}\n\nout:\n\tfree_xid(xid);\n\treturn rc;\nerr_out:\n\tlist_for_each_entry_safe(lck, tmp, &locks_to_send, llist) {\n\t\tlist_del(&lck->llist);\n\t\tkfree(lck);\n\t}\n\tgoto out;\n}\n#endif  \n\nstatic int\ncifs_push_locks(struct cifsFileInfo *cfile)\n{\n\tstruct cifsInodeInfo *cinode = CIFS_I(d_inode(cfile->dentry));\n\tstruct cifs_tcon *tcon = tlink_tcon(cfile->tlink);\n\tint rc = 0;\n#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(cfile->dentry->d_sb);\n#endif  \n\n\t \n\tcifs_down_write(&cinode->lock_sem);\n\tif (!cinode->can_cache_brlcks) {\n\t\tup_write(&cinode->lock_sem);\n\t\treturn rc;\n\t}\n\n#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY\n\tif (cap_unix(tcon->ses) &&\n\t    (CIFS_UNIX_FCNTL_CAP & le64_to_cpu(tcon->fsUnixInfo.Capability)) &&\n\t    ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NOPOSIXBRL) == 0))\n\t\trc = cifs_push_posix_locks(cfile);\n\telse\n#endif  \n\t\trc = tcon->ses->server->ops->push_mand_locks(cfile);\n\n\tcinode->can_cache_brlcks = false;\n\tup_write(&cinode->lock_sem);\n\treturn rc;\n}\n\nstatic void\ncifs_read_flock(struct file_lock *flock, __u32 *type, int *lock, int *unlock,\n\t\tbool *wait_flag, struct TCP_Server_Info *server)\n{\n\tif (flock->fl_flags & FL_POSIX)\n\t\tcifs_dbg(FYI, \"Posix\\n\");\n\tif (flock->fl_flags & FL_FLOCK)\n\t\tcifs_dbg(FYI, \"Flock\\n\");\n\tif (flock->fl_flags & FL_SLEEP) {\n\t\tcifs_dbg(FYI, \"Blocking lock\\n\");\n\t\t*wait_flag = true;\n\t}\n\tif (flock->fl_flags & FL_ACCESS)\n\t\tcifs_dbg(FYI, \"Process suspended by mandatory locking - not implemented yet\\n\");\n\tif (flock->fl_flags & FL_LEASE)\n\t\tcifs_dbg(FYI, \"Lease on file - not implemented yet\\n\");\n\tif (flock->fl_flags &\n\t    (~(FL_POSIX | FL_FLOCK | FL_SLEEP |\n\t       FL_ACCESS | FL_LEASE | FL_CLOSE | FL_OFDLCK)))\n\t\tcifs_dbg(FYI, \"Unknown lock flags 0x%x\\n\", flock->fl_flags);\n\n\t*type = server->vals->large_lock_type;\n\tif (flock->fl_type == F_WRLCK) {\n\t\tcifs_dbg(FYI, \"F_WRLCK\\n\");\n\t\t*type |= server->vals->exclusive_lock_type;\n\t\t*lock = 1;\n\t} else if (flock->fl_type == F_UNLCK) {\n\t\tcifs_dbg(FYI, \"F_UNLCK\\n\");\n\t\t*type |= server->vals->unlock_lock_type;\n\t\t*unlock = 1;\n\t\t \n\t} else if (flock->fl_type == F_RDLCK) {\n\t\tcifs_dbg(FYI, \"F_RDLCK\\n\");\n\t\t*type |= server->vals->shared_lock_type;\n\t\t*lock = 1;\n\t} else if (flock->fl_type == F_EXLCK) {\n\t\tcifs_dbg(FYI, \"F_EXLCK\\n\");\n\t\t*type |= server->vals->exclusive_lock_type;\n\t\t*lock = 1;\n\t} else if (flock->fl_type == F_SHLCK) {\n\t\tcifs_dbg(FYI, \"F_SHLCK\\n\");\n\t\t*type |= server->vals->shared_lock_type;\n\t\t*lock = 1;\n\t} else\n\t\tcifs_dbg(FYI, \"Unknown type of lock\\n\");\n}\n\nstatic int\ncifs_getlk(struct file *file, struct file_lock *flock, __u32 type,\n\t   bool wait_flag, bool posix_lck, unsigned int xid)\n{\n\tint rc = 0;\n\t__u64 length = cifs_flock_len(flock);\n\tstruct cifsFileInfo *cfile = (struct cifsFileInfo *)file->private_data;\n\tstruct cifs_tcon *tcon = tlink_tcon(cfile->tlink);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY\n\t__u16 netfid = cfile->fid.netfid;\n\n\tif (posix_lck) {\n\t\tint posix_lock_type;\n\n\t\trc = cifs_posix_lock_test(file, flock);\n\t\tif (!rc)\n\t\t\treturn rc;\n\n\t\tif (type & server->vals->shared_lock_type)\n\t\t\tposix_lock_type = CIFS_RDLCK;\n\t\telse\n\t\t\tposix_lock_type = CIFS_WRLCK;\n\t\trc = CIFSSMBPosixLock(xid, tcon, netfid,\n\t\t\t\t      hash_lockowner(flock->fl_owner),\n\t\t\t\t      flock->fl_start, length, flock,\n\t\t\t\t      posix_lock_type, wait_flag);\n\t\treturn rc;\n\t}\n#endif  \n\n\trc = cifs_lock_test(cfile, flock->fl_start, length, type, flock);\n\tif (!rc)\n\t\treturn rc;\n\n\t \n\trc = server->ops->mand_lock(xid, cfile, flock->fl_start, length, type,\n\t\t\t\t    1, 0, false);\n\tif (rc == 0) {\n\t\trc = server->ops->mand_lock(xid, cfile, flock->fl_start, length,\n\t\t\t\t\t    type, 0, 1, false);\n\t\tflock->fl_type = F_UNLCK;\n\t\tif (rc != 0)\n\t\t\tcifs_dbg(VFS, \"Error unlocking previously locked range %d during test of lock\\n\",\n\t\t\t\t rc);\n\t\treturn 0;\n\t}\n\n\tif (type & server->vals->shared_lock_type) {\n\t\tflock->fl_type = F_WRLCK;\n\t\treturn 0;\n\t}\n\n\ttype &= ~server->vals->exclusive_lock_type;\n\n\trc = server->ops->mand_lock(xid, cfile, flock->fl_start, length,\n\t\t\t\t    type | server->vals->shared_lock_type,\n\t\t\t\t    1, 0, false);\n\tif (rc == 0) {\n\t\trc = server->ops->mand_lock(xid, cfile, flock->fl_start, length,\n\t\t\ttype | server->vals->shared_lock_type, 0, 1, false);\n\t\tflock->fl_type = F_RDLCK;\n\t\tif (rc != 0)\n\t\t\tcifs_dbg(VFS, \"Error unlocking previously locked range %d during test of lock\\n\",\n\t\t\t\t rc);\n\t} else\n\t\tflock->fl_type = F_WRLCK;\n\n\treturn 0;\n}\n\nvoid\ncifs_move_llist(struct list_head *source, struct list_head *dest)\n{\n\tstruct list_head *li, *tmp;\n\tlist_for_each_safe(li, tmp, source)\n\t\tlist_move(li, dest);\n}\n\nvoid\ncifs_free_llist(struct list_head *llist)\n{\n\tstruct cifsLockInfo *li, *tmp;\n\tlist_for_each_entry_safe(li, tmp, llist, llist) {\n\t\tcifs_del_lock_waiters(li);\n\t\tlist_del(&li->llist);\n\t\tkfree(li);\n\t}\n}\n\n#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY\nint\ncifs_unlock_range(struct cifsFileInfo *cfile, struct file_lock *flock,\n\t\t  unsigned int xid)\n{\n\tint rc = 0, stored_rc;\n\tstatic const int types[] = {\n\t\tLOCKING_ANDX_LARGE_FILES,\n\t\tLOCKING_ANDX_SHARED_LOCK | LOCKING_ANDX_LARGE_FILES\n\t};\n\tunsigned int i;\n\tunsigned int max_num, num, max_buf;\n\tLOCKING_ANDX_RANGE *buf, *cur;\n\tstruct cifs_tcon *tcon = tlink_tcon(cfile->tlink);\n\tstruct cifsInodeInfo *cinode = CIFS_I(d_inode(cfile->dentry));\n\tstruct cifsLockInfo *li, *tmp;\n\t__u64 length = cifs_flock_len(flock);\n\tstruct list_head tmp_llist;\n\n\tINIT_LIST_HEAD(&tmp_llist);\n\n\t \n\tmax_buf = tcon->ses->server->maxBuf;\n\tif (max_buf < (sizeof(struct smb_hdr) + sizeof(LOCKING_ANDX_RANGE)))\n\t\treturn -EINVAL;\n\n\tBUILD_BUG_ON(sizeof(struct smb_hdr) + sizeof(LOCKING_ANDX_RANGE) >\n\t\t     PAGE_SIZE);\n\tmax_buf = min_t(unsigned int, max_buf - sizeof(struct smb_hdr),\n\t\t\tPAGE_SIZE);\n\tmax_num = (max_buf - sizeof(struct smb_hdr)) /\n\t\t\t\t\t\tsizeof(LOCKING_ANDX_RANGE);\n\tbuf = kcalloc(max_num, sizeof(LOCKING_ANDX_RANGE), GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tcifs_down_write(&cinode->lock_sem);\n\tfor (i = 0; i < 2; i++) {\n\t\tcur = buf;\n\t\tnum = 0;\n\t\tlist_for_each_entry_safe(li, tmp, &cfile->llist->locks, llist) {\n\t\t\tif (flock->fl_start > li->offset ||\n\t\t\t    (flock->fl_start + length) <\n\t\t\t    (li->offset + li->length))\n\t\t\t\tcontinue;\n\t\t\tif (current->tgid != li->pid)\n\t\t\t\tcontinue;\n\t\t\tif (types[i] != li->type)\n\t\t\t\tcontinue;\n\t\t\tif (cinode->can_cache_brlcks) {\n\t\t\t\t \n\t\t\t\tlist_del(&li->llist);\n\t\t\t\tcifs_del_lock_waiters(li);\n\t\t\t\tkfree(li);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcur->Pid = cpu_to_le16(li->pid);\n\t\t\tcur->LengthLow = cpu_to_le32((u32)li->length);\n\t\t\tcur->LengthHigh = cpu_to_le32((u32)(li->length>>32));\n\t\t\tcur->OffsetLow = cpu_to_le32((u32)li->offset);\n\t\t\tcur->OffsetHigh = cpu_to_le32((u32)(li->offset>>32));\n\t\t\t \n\t\t\tlist_move(&li->llist, &tmp_llist);\n\t\t\tif (++num == max_num) {\n\t\t\t\tstored_rc = cifs_lockv(xid, tcon,\n\t\t\t\t\t\t       cfile->fid.netfid,\n\t\t\t\t\t\t       li->type, num, 0, buf);\n\t\t\t\tif (stored_rc) {\n\t\t\t\t\t \n\t\t\t\t\tcifs_move_llist(&tmp_llist,\n\t\t\t\t\t\t\t&cfile->llist->locks);\n\t\t\t\t\trc = stored_rc;\n\t\t\t\t} else\n\t\t\t\t\t \n\t\t\t\t\tcifs_free_llist(&tmp_llist);\n\t\t\t\tcur = buf;\n\t\t\t\tnum = 0;\n\t\t\t} else\n\t\t\t\tcur++;\n\t\t}\n\t\tif (num) {\n\t\t\tstored_rc = cifs_lockv(xid, tcon, cfile->fid.netfid,\n\t\t\t\t\t       types[i], num, 0, buf);\n\t\t\tif (stored_rc) {\n\t\t\t\tcifs_move_llist(&tmp_llist,\n\t\t\t\t\t\t&cfile->llist->locks);\n\t\t\t\trc = stored_rc;\n\t\t\t} else\n\t\t\t\tcifs_free_llist(&tmp_llist);\n\t\t}\n\t}\n\n\tup_write(&cinode->lock_sem);\n\tkfree(buf);\n\treturn rc;\n}\n#endif  \n\nstatic int\ncifs_setlk(struct file *file, struct file_lock *flock, __u32 type,\n\t   bool wait_flag, bool posix_lck, int lock, int unlock,\n\t   unsigned int xid)\n{\n\tint rc = 0;\n\t__u64 length = cifs_flock_len(flock);\n\tstruct cifsFileInfo *cfile = (struct cifsFileInfo *)file->private_data;\n\tstruct cifs_tcon *tcon = tlink_tcon(cfile->tlink);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tstruct inode *inode = d_inode(cfile->dentry);\n\n#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY\n\tif (posix_lck) {\n\t\tint posix_lock_type;\n\n\t\trc = cifs_posix_lock_set(file, flock);\n\t\tif (rc <= FILE_LOCK_DEFERRED)\n\t\t\treturn rc;\n\n\t\tif (type & server->vals->shared_lock_type)\n\t\t\tposix_lock_type = CIFS_RDLCK;\n\t\telse\n\t\t\tposix_lock_type = CIFS_WRLCK;\n\n\t\tif (unlock == 1)\n\t\t\tposix_lock_type = CIFS_UNLCK;\n\n\t\trc = CIFSSMBPosixLock(xid, tcon, cfile->fid.netfid,\n\t\t\t\t      hash_lockowner(flock->fl_owner),\n\t\t\t\t      flock->fl_start, length,\n\t\t\t\t      NULL, posix_lock_type, wait_flag);\n\t\tgoto out;\n\t}\n#endif  \n\tif (lock) {\n\t\tstruct cifsLockInfo *lock;\n\n\t\tlock = cifs_lock_init(flock->fl_start, length, type,\n\t\t\t\t      flock->fl_flags);\n\t\tif (!lock)\n\t\t\treturn -ENOMEM;\n\n\t\trc = cifs_lock_add_if(cfile, lock, wait_flag);\n\t\tif (rc < 0) {\n\t\t\tkfree(lock);\n\t\t\treturn rc;\n\t\t}\n\t\tif (!rc)\n\t\t\tgoto out;\n\n\t\t \n\t\tif (!CIFS_CACHE_WRITE(CIFS_I(inode)) &&\n\t\t\t\t\tCIFS_CACHE_READ(CIFS_I(inode))) {\n\t\t\tcifs_zap_mapping(inode);\n\t\t\tcifs_dbg(FYI, \"Set no oplock for inode=%p due to mand locks\\n\",\n\t\t\t\t inode);\n\t\t\tCIFS_I(inode)->oplock = 0;\n\t\t}\n\n\t\trc = server->ops->mand_lock(xid, cfile, flock->fl_start, length,\n\t\t\t\t\t    type, 1, 0, wait_flag);\n\t\tif (rc) {\n\t\t\tkfree(lock);\n\t\t\treturn rc;\n\t\t}\n\n\t\tcifs_lock_add(cfile, lock);\n\t} else if (unlock)\n\t\trc = server->ops->mand_unlock_range(cfile, flock, xid);\n\nout:\n\tif ((flock->fl_flags & FL_POSIX) || (flock->fl_flags & FL_FLOCK)) {\n\t\t \n\t\tif (rc) {\n\t\t\tcifs_dbg(VFS, \"%s failed rc=%d\\n\", __func__, rc);\n\t\t\tif (!(flock->fl_flags & FL_CLOSE))\n\t\t\t\treturn rc;\n\t\t}\n\t\trc = locks_lock_file_wait(file, flock);\n\t}\n\treturn rc;\n}\n\nint cifs_flock(struct file *file, int cmd, struct file_lock *fl)\n{\n\tint rc, xid;\n\tint lock = 0, unlock = 0;\n\tbool wait_flag = false;\n\tbool posix_lck = false;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct cifs_tcon *tcon;\n\tstruct cifsFileInfo *cfile;\n\t__u32 type;\n\n\txid = get_xid();\n\n\tif (!(fl->fl_flags & FL_FLOCK)) {\n\t\trc = -ENOLCK;\n\t\tfree_xid(xid);\n\t\treturn rc;\n\t}\n\n\tcfile = (struct cifsFileInfo *)file->private_data;\n\ttcon = tlink_tcon(cfile->tlink);\n\n\tcifs_read_flock(fl, &type, &lock, &unlock, &wait_flag,\n\t\t\ttcon->ses->server);\n\tcifs_sb = CIFS_FILE_SB(file);\n\n\tif (cap_unix(tcon->ses) &&\n\t    (CIFS_UNIX_FCNTL_CAP & le64_to_cpu(tcon->fsUnixInfo.Capability)) &&\n\t    ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NOPOSIXBRL) == 0))\n\t\tposix_lck = true;\n\n\tif (!lock && !unlock) {\n\t\t \n\t\trc = -EOPNOTSUPP;\n\t\tfree_xid(xid);\n\t\treturn rc;\n\t}\n\n\trc = cifs_setlk(file, fl, type, wait_flag, posix_lck, lock, unlock,\n\t\t\txid);\n\tfree_xid(xid);\n\treturn rc;\n\n\n}\n\nint cifs_lock(struct file *file, int cmd, struct file_lock *flock)\n{\n\tint rc, xid;\n\tint lock = 0, unlock = 0;\n\tbool wait_flag = false;\n\tbool posix_lck = false;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct cifs_tcon *tcon;\n\tstruct cifsFileInfo *cfile;\n\t__u32 type;\n\n\trc = -EACCES;\n\txid = get_xid();\n\n\tcifs_dbg(FYI, \"%s: %pD2 cmd=0x%x type=0x%x flags=0x%x r=%lld:%lld\\n\", __func__, file, cmd,\n\t\t flock->fl_flags, flock->fl_type, (long long)flock->fl_start,\n\t\t (long long)flock->fl_end);\n\n\tcfile = (struct cifsFileInfo *)file->private_data;\n\ttcon = tlink_tcon(cfile->tlink);\n\n\tcifs_read_flock(flock, &type, &lock, &unlock, &wait_flag,\n\t\t\ttcon->ses->server);\n\tcifs_sb = CIFS_FILE_SB(file);\n\tset_bit(CIFS_INO_CLOSE_ON_LOCK, &CIFS_I(d_inode(cfile->dentry))->flags);\n\n\tif (cap_unix(tcon->ses) &&\n\t    (CIFS_UNIX_FCNTL_CAP & le64_to_cpu(tcon->fsUnixInfo.Capability)) &&\n\t    ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NOPOSIXBRL) == 0))\n\t\tposix_lck = true;\n\t \n\tif (IS_GETLK(cmd)) {\n\t\trc = cifs_getlk(file, flock, type, wait_flag, posix_lck, xid);\n\t\tfree_xid(xid);\n\t\treturn rc;\n\t}\n\n\tif (!lock && !unlock) {\n\t\t \n\t\tfree_xid(xid);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\trc = cifs_setlk(file, flock, type, wait_flag, posix_lck, lock, unlock,\n\t\t\txid);\n\tfree_xid(xid);\n\treturn rc;\n}\n\n \nvoid\ncifs_update_eof(struct cifsInodeInfo *cifsi, loff_t offset,\n\t\t      unsigned int bytes_written)\n{\n\tloff_t end_of_write = offset + bytes_written;\n\n\tif (end_of_write > cifsi->server_eof)\n\t\tcifsi->server_eof = end_of_write;\n}\n\nstatic ssize_t\ncifs_write(struct cifsFileInfo *open_file, __u32 pid, const char *write_data,\n\t   size_t write_size, loff_t *offset)\n{\n\tint rc = 0;\n\tunsigned int bytes_written = 0;\n\tunsigned int total_written;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tunsigned int xid;\n\tstruct dentry *dentry = open_file->dentry;\n\tstruct cifsInodeInfo *cifsi = CIFS_I(d_inode(dentry));\n\tstruct cifs_io_parms io_parms = {0};\n\n\tcifs_dbg(FYI, \"write %zd bytes to offset %lld of %pd\\n\",\n\t\t write_size, *offset, dentry);\n\n\ttcon = tlink_tcon(open_file->tlink);\n\tserver = tcon->ses->server;\n\n\tif (!server->ops->sync_write)\n\t\treturn -ENOSYS;\n\n\txid = get_xid();\n\n\tfor (total_written = 0; write_size > total_written;\n\t     total_written += bytes_written) {\n\t\trc = -EAGAIN;\n\t\twhile (rc == -EAGAIN) {\n\t\t\tstruct kvec iov[2];\n\t\t\tunsigned int len;\n\n\t\t\tif (open_file->invalidHandle) {\n\t\t\t\t \n\t\t\t\trc = cifs_reopen_file(open_file, false);\n\t\t\t\tif (rc != 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlen = min(server->ops->wp_retry_size(d_inode(dentry)),\n\t\t\t\t  (unsigned int)write_size - total_written);\n\t\t\t \n\t\t\tiov[1].iov_base = (char *)write_data + total_written;\n\t\t\tiov[1].iov_len = len;\n\t\t\tio_parms.pid = pid;\n\t\t\tio_parms.tcon = tcon;\n\t\t\tio_parms.offset = *offset;\n\t\t\tio_parms.length = len;\n\t\t\trc = server->ops->sync_write(xid, &open_file->fid,\n\t\t\t\t\t&io_parms, &bytes_written, iov, 1);\n\t\t}\n\t\tif (rc || (bytes_written == 0)) {\n\t\t\tif (total_written)\n\t\t\t\tbreak;\n\t\t\telse {\n\t\t\t\tfree_xid(xid);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t} else {\n\t\t\tspin_lock(&d_inode(dentry)->i_lock);\n\t\t\tcifs_update_eof(cifsi, *offset, bytes_written);\n\t\t\tspin_unlock(&d_inode(dentry)->i_lock);\n\t\t\t*offset += bytes_written;\n\t\t}\n\t}\n\n\tcifs_stats_bytes_written(tcon, total_written);\n\n\tif (total_written > 0) {\n\t\tspin_lock(&d_inode(dentry)->i_lock);\n\t\tif (*offset > d_inode(dentry)->i_size) {\n\t\t\ti_size_write(d_inode(dentry), *offset);\n\t\t\td_inode(dentry)->i_blocks = (512 - 1 + *offset) >> 9;\n\t\t}\n\t\tspin_unlock(&d_inode(dentry)->i_lock);\n\t}\n\tmark_inode_dirty_sync(d_inode(dentry));\n\tfree_xid(xid);\n\treturn total_written;\n}\n\nstruct cifsFileInfo *find_readable_file(struct cifsInodeInfo *cifs_inode,\n\t\t\t\t\tbool fsuid_only)\n{\n\tstruct cifsFileInfo *open_file = NULL;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(cifs_inode->netfs.inode.i_sb);\n\n\t \n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\tfsuid_only = false;\n\n\tspin_lock(&cifs_inode->open_file_lock);\n\t \n\tlist_for_each_entry(open_file, &cifs_inode->openFileList, flist) {\n\t\tif (fsuid_only && !uid_eq(open_file->uid, current_fsuid()))\n\t\t\tcontinue;\n\t\tif (OPEN_FMODE(open_file->f_flags) & FMODE_READ) {\n\t\t\tif ((!open_file->invalidHandle)) {\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tcifsFileInfo_get(open_file);\n\t\t\t\tspin_unlock(&cifs_inode->open_file_lock);\n\t\t\t\treturn open_file;\n\t\t\t}  \n\t\t} else  \n\t\t\tbreak;  \n\t}\n\tspin_unlock(&cifs_inode->open_file_lock);\n\treturn NULL;\n}\n\n \nint\ncifs_get_writable_file(struct cifsInodeInfo *cifs_inode, int flags,\n\t\t       struct cifsFileInfo **ret_file)\n{\n\tstruct cifsFileInfo *open_file, *inv_file = NULL;\n\tstruct cifs_sb_info *cifs_sb;\n\tbool any_available = false;\n\tint rc = -EBADF;\n\tunsigned int refind = 0;\n\tbool fsuid_only = flags & FIND_WR_FSUID_ONLY;\n\tbool with_delete = flags & FIND_WR_WITH_DELETE;\n\t*ret_file = NULL;\n\n\t \n\n\tif (cifs_inode == NULL) {\n\t\tcifs_dbg(VFS, \"Null inode passed to cifs_writeable_file\\n\");\n\t\tdump_stack();\n\t\treturn rc;\n\t}\n\n\tcifs_sb = CIFS_SB(cifs_inode->netfs.inode.i_sb);\n\n\t \n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\tfsuid_only = false;\n\n\tspin_lock(&cifs_inode->open_file_lock);\nrefind_writable:\n\tif (refind > MAX_REOPEN_ATT) {\n\t\tspin_unlock(&cifs_inode->open_file_lock);\n\t\treturn rc;\n\t}\n\tlist_for_each_entry(open_file, &cifs_inode->openFileList, flist) {\n\t\tif (!any_available && open_file->pid != current->tgid)\n\t\t\tcontinue;\n\t\tif (fsuid_only && !uid_eq(open_file->uid, current_fsuid()))\n\t\t\tcontinue;\n\t\tif (with_delete && !(open_file->fid.access & DELETE))\n\t\t\tcontinue;\n\t\tif (OPEN_FMODE(open_file->f_flags) & FMODE_WRITE) {\n\t\t\tif (!open_file->invalidHandle) {\n\t\t\t\t \n\t\t\t\tcifsFileInfo_get(open_file);\n\t\t\t\tspin_unlock(&cifs_inode->open_file_lock);\n\t\t\t\t*ret_file = open_file;\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\tif (!inv_file)\n\t\t\t\t\tinv_file = open_file;\n\t\t\t}\n\t\t}\n\t}\n\t \n\tif (!any_available) {\n\t\tany_available = true;\n\t\tgoto refind_writable;\n\t}\n\n\tif (inv_file) {\n\t\tany_available = false;\n\t\tcifsFileInfo_get(inv_file);\n\t}\n\n\tspin_unlock(&cifs_inode->open_file_lock);\n\n\tif (inv_file) {\n\t\trc = cifs_reopen_file(inv_file, false);\n\t\tif (!rc) {\n\t\t\t*ret_file = inv_file;\n\t\t\treturn 0;\n\t\t}\n\n\t\tspin_lock(&cifs_inode->open_file_lock);\n\t\tlist_move_tail(&inv_file->flist, &cifs_inode->openFileList);\n\t\tspin_unlock(&cifs_inode->open_file_lock);\n\t\tcifsFileInfo_put(inv_file);\n\t\t++refind;\n\t\tinv_file = NULL;\n\t\tspin_lock(&cifs_inode->open_file_lock);\n\t\tgoto refind_writable;\n\t}\n\n\treturn rc;\n}\n\nstruct cifsFileInfo *\nfind_writable_file(struct cifsInodeInfo *cifs_inode, int flags)\n{\n\tstruct cifsFileInfo *cfile;\n\tint rc;\n\n\trc = cifs_get_writable_file(cifs_inode, flags, &cfile);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Couldn't find writable handle rc=%d\\n\", rc);\n\n\treturn cfile;\n}\n\nint\ncifs_get_writable_path(struct cifs_tcon *tcon, const char *name,\n\t\t       int flags,\n\t\t       struct cifsFileInfo **ret_file)\n{\n\tstruct cifsFileInfo *cfile;\n\tvoid *page = alloc_dentry_path();\n\n\t*ret_file = NULL;\n\n\tspin_lock(&tcon->open_file_lock);\n\tlist_for_each_entry(cfile, &tcon->openFileList, tlist) {\n\t\tstruct cifsInodeInfo *cinode;\n\t\tconst char *full_path = build_path_from_dentry(cfile->dentry, page);\n\t\tif (IS_ERR(full_path)) {\n\t\t\tspin_unlock(&tcon->open_file_lock);\n\t\t\tfree_dentry_path(page);\n\t\t\treturn PTR_ERR(full_path);\n\t\t}\n\t\tif (strcmp(full_path, name))\n\t\t\tcontinue;\n\n\t\tcinode = CIFS_I(d_inode(cfile->dentry));\n\t\tspin_unlock(&tcon->open_file_lock);\n\t\tfree_dentry_path(page);\n\t\treturn cifs_get_writable_file(cinode, flags, ret_file);\n\t}\n\n\tspin_unlock(&tcon->open_file_lock);\n\tfree_dentry_path(page);\n\treturn -ENOENT;\n}\n\nint\ncifs_get_readable_path(struct cifs_tcon *tcon, const char *name,\n\t\t       struct cifsFileInfo **ret_file)\n{\n\tstruct cifsFileInfo *cfile;\n\tvoid *page = alloc_dentry_path();\n\n\t*ret_file = NULL;\n\n\tspin_lock(&tcon->open_file_lock);\n\tlist_for_each_entry(cfile, &tcon->openFileList, tlist) {\n\t\tstruct cifsInodeInfo *cinode;\n\t\tconst char *full_path = build_path_from_dentry(cfile->dentry, page);\n\t\tif (IS_ERR(full_path)) {\n\t\t\tspin_unlock(&tcon->open_file_lock);\n\t\t\tfree_dentry_path(page);\n\t\t\treturn PTR_ERR(full_path);\n\t\t}\n\t\tif (strcmp(full_path, name))\n\t\t\tcontinue;\n\n\t\tcinode = CIFS_I(d_inode(cfile->dentry));\n\t\tspin_unlock(&tcon->open_file_lock);\n\t\tfree_dentry_path(page);\n\t\t*ret_file = find_readable_file(cinode, 0);\n\t\treturn *ret_file ? 0 : -ENOENT;\n\t}\n\n\tspin_unlock(&tcon->open_file_lock);\n\tfree_dentry_path(page);\n\treturn -ENOENT;\n}\n\nvoid\ncifs_writedata_release(struct kref *refcount)\n{\n\tstruct cifs_writedata *wdata = container_of(refcount,\n\t\t\t\t\tstruct cifs_writedata, refcount);\n#ifdef CONFIG_CIFS_SMB_DIRECT\n\tif (wdata->mr) {\n\t\tsmbd_deregister_mr(wdata->mr);\n\t\twdata->mr = NULL;\n\t}\n#endif\n\n\tif (wdata->cfile)\n\t\tcifsFileInfo_put(wdata->cfile);\n\n\tkfree(wdata);\n}\n\n \nstatic void\ncifs_writev_requeue(struct cifs_writedata *wdata)\n{\n\tint rc = 0;\n\tstruct inode *inode = d_inode(wdata->cfile->dentry);\n\tstruct TCP_Server_Info *server;\n\tunsigned int rest_len = wdata->bytes;\n\tloff_t fpos = wdata->offset;\n\n\tserver = tlink_tcon(wdata->cfile->tlink)->ses->server;\n\tdo {\n\t\tstruct cifs_writedata *wdata2;\n\t\tunsigned int wsize, cur_len;\n\n\t\twsize = server->ops->wp_retry_size(inode);\n\t\tif (wsize < rest_len) {\n\t\t\tif (wsize < PAGE_SIZE) {\n\t\t\t\trc = -EOPNOTSUPP;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcur_len = min(round_down(wsize, PAGE_SIZE), rest_len);\n\t\t} else {\n\t\t\tcur_len = rest_len;\n\t\t}\n\n\t\twdata2 = cifs_writedata_alloc(cifs_writev_complete);\n\t\tif (!wdata2) {\n\t\t\trc = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\twdata2->sync_mode = wdata->sync_mode;\n\t\twdata2->offset\t= fpos;\n\t\twdata2->bytes\t= cur_len;\n\t\twdata2->iter\t= wdata->iter;\n\n\t\tiov_iter_advance(&wdata2->iter, fpos - wdata->offset);\n\t\tiov_iter_truncate(&wdata2->iter, wdata2->bytes);\n\n\t\tif (iov_iter_is_xarray(&wdata2->iter))\n\t\t\t \n\t\t\tcifs_undirty_folios(inode, fpos, cur_len);\n\n\t\trc = cifs_get_writable_file(CIFS_I(inode), FIND_WR_ANY,\n\t\t\t\t\t    &wdata2->cfile);\n\t\tif (!wdata2->cfile) {\n\t\t\tcifs_dbg(VFS, \"No writable handle to retry writepages rc=%d\\n\",\n\t\t\t\t rc);\n\t\t\tif (!is_retryable_error(rc))\n\t\t\t\trc = -EBADF;\n\t\t} else {\n\t\t\twdata2->pid = wdata2->cfile->pid;\n\t\t\trc = server->ops->async_writev(wdata2,\n\t\t\t\t\t\t       cifs_writedata_release);\n\t\t}\n\n\t\tkref_put(&wdata2->refcount, cifs_writedata_release);\n\t\tif (rc) {\n\t\t\tif (is_retryable_error(rc))\n\t\t\t\tcontinue;\n\t\t\tfpos += cur_len;\n\t\t\trest_len -= cur_len;\n\t\t\tbreak;\n\t\t}\n\n\t\tfpos += cur_len;\n\t\trest_len -= cur_len;\n\t} while (rest_len > 0);\n\n\t \n\tif (iov_iter_is_xarray(&wdata->iter))\n\t\tcifs_pages_write_failed(inode, fpos, rest_len);\n\n\tif (rc != 0 && !is_retryable_error(rc))\n\t\tmapping_set_error(inode->i_mapping, rc);\n\tkref_put(&wdata->refcount, cifs_writedata_release);\n}\n\nvoid\ncifs_writev_complete(struct work_struct *work)\n{\n\tstruct cifs_writedata *wdata = container_of(work,\n\t\t\t\t\t\tstruct cifs_writedata, work);\n\tstruct inode *inode = d_inode(wdata->cfile->dentry);\n\n\tif (wdata->result == 0) {\n\t\tspin_lock(&inode->i_lock);\n\t\tcifs_update_eof(CIFS_I(inode), wdata->offset, wdata->bytes);\n\t\tspin_unlock(&inode->i_lock);\n\t\tcifs_stats_bytes_written(tlink_tcon(wdata->cfile->tlink),\n\t\t\t\t\t wdata->bytes);\n\t} else if (wdata->sync_mode == WB_SYNC_ALL && wdata->result == -EAGAIN)\n\t\treturn cifs_writev_requeue(wdata);\n\n\tif (wdata->result == -EAGAIN)\n\t\tcifs_pages_write_redirty(inode, wdata->offset, wdata->bytes);\n\telse if (wdata->result < 0)\n\t\tcifs_pages_write_failed(inode, wdata->offset, wdata->bytes);\n\telse\n\t\tcifs_pages_written_back(inode, wdata->offset, wdata->bytes);\n\n\tif (wdata->result != -EAGAIN)\n\t\tmapping_set_error(inode->i_mapping, wdata->result);\n\tkref_put(&wdata->refcount, cifs_writedata_release);\n}\n\nstruct cifs_writedata *cifs_writedata_alloc(work_func_t complete)\n{\n\tstruct cifs_writedata *wdata;\n\n\twdata = kzalloc(sizeof(*wdata), GFP_NOFS);\n\tif (wdata != NULL) {\n\t\tkref_init(&wdata->refcount);\n\t\tINIT_LIST_HEAD(&wdata->list);\n\t\tinit_completion(&wdata->done);\n\t\tINIT_WORK(&wdata->work, complete);\n\t}\n\treturn wdata;\n}\n\nstatic int cifs_partialpagewrite(struct page *page, unsigned from, unsigned to)\n{\n\tstruct address_space *mapping = page->mapping;\n\tloff_t offset = (loff_t)page->index << PAGE_SHIFT;\n\tchar *write_data;\n\tint rc = -EFAULT;\n\tint bytes_written = 0;\n\tstruct inode *inode;\n\tstruct cifsFileInfo *open_file;\n\n\tif (!mapping || !mapping->host)\n\t\treturn -EFAULT;\n\n\tinode = page->mapping->host;\n\n\toffset += (loff_t)from;\n\twrite_data = kmap(page);\n\twrite_data += from;\n\n\tif ((to > PAGE_SIZE) || (from > to)) {\n\t\tkunmap(page);\n\t\treturn -EIO;\n\t}\n\n\t \n\tif (offset > mapping->host->i_size) {\n\t\tkunmap(page);\n\t\treturn 0;  \n\t}\n\n\t \n\tif (mapping->host->i_size - offset < (loff_t)to)\n\t\tto = (unsigned)(mapping->host->i_size - offset);\n\n\trc = cifs_get_writable_file(CIFS_I(mapping->host), FIND_WR_ANY,\n\t\t\t\t    &open_file);\n\tif (!rc) {\n\t\tbytes_written = cifs_write(open_file, open_file->pid,\n\t\t\t\t\t   write_data, to - from, &offset);\n\t\tcifsFileInfo_put(open_file);\n\t\t \n\t\tsimple_inode_init_ts(inode);\n\t\tif ((bytes_written > 0) && (offset))\n\t\t\trc = 0;\n\t\telse if (bytes_written < 0)\n\t\t\trc = bytes_written;\n\t\telse\n\t\t\trc = -EFAULT;\n\t} else {\n\t\tcifs_dbg(FYI, \"No writable handle for write page rc=%d\\n\", rc);\n\t\tif (!is_retryable_error(rc))\n\t\t\trc = -EIO;\n\t}\n\n\tkunmap(page);\n\treturn rc;\n}\n\n \nstatic void cifs_extend_writeback(struct address_space *mapping,\n\t\t\t\t  long *_count,\n\t\t\t\t  loff_t start,\n\t\t\t\t  int max_pages,\n\t\t\t\t  size_t max_len,\n\t\t\t\t  unsigned int *_len)\n{\n\tstruct folio_batch batch;\n\tstruct folio *folio;\n\tunsigned int psize, nr_pages;\n\tsize_t len = *_len;\n\tpgoff_t index = (start + len) / PAGE_SIZE;\n\tbool stop = true;\n\tunsigned int i;\n\tXA_STATE(xas, &mapping->i_pages, index);\n\n\tfolio_batch_init(&batch);\n\n\tdo {\n\t\t \n\t\trcu_read_lock();\n\n\t\txas_for_each(&xas, folio, ULONG_MAX) {\n\t\t\tstop = true;\n\t\t\tif (xas_retry(&xas, folio))\n\t\t\t\tcontinue;\n\t\t\tif (xa_is_value(folio))\n\t\t\t\tbreak;\n\t\t\tif (folio_index(folio) != index)\n\t\t\t\tbreak;\n\t\t\tif (!folio_try_get_rcu(folio)) {\n\t\t\t\txas_reset(&xas);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnr_pages = folio_nr_pages(folio);\n\t\t\tif (nr_pages > max_pages)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tif (unlikely(folio != xas_reload(&xas))) {\n\t\t\t\tfolio_put(folio);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!folio_trylock(folio)) {\n\t\t\t\tfolio_put(folio);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!folio_test_dirty(folio) || folio_test_writeback(folio)) {\n\t\t\t\tfolio_unlock(folio);\n\t\t\t\tfolio_put(folio);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmax_pages -= nr_pages;\n\t\t\tpsize = folio_size(folio);\n\t\t\tlen += psize;\n\t\t\tstop = false;\n\t\t\tif (max_pages <= 0 || len >= max_len || *_count <= 0)\n\t\t\t\tstop = true;\n\n\t\t\tindex += nr_pages;\n\t\t\tif (!folio_batch_add(&batch, folio))\n\t\t\t\tbreak;\n\t\t\tif (stop)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (!stop)\n\t\t\txas_pause(&xas);\n\t\trcu_read_unlock();\n\n\t\t \n\t\tif (!folio_batch_count(&batch))\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < folio_batch_count(&batch); i++) {\n\t\t\tfolio = batch.folios[i];\n\t\t\t \n\t\t\tif (!folio_clear_dirty_for_io(folio))\n\t\t\t\tWARN_ON(1);\n\t\t\tif (folio_start_writeback(folio))\n\t\t\t\tWARN_ON(1);\n\n\t\t\t*_count -= folio_nr_pages(folio);\n\t\t\tfolio_unlock(folio);\n\t\t}\n\n\t\tfolio_batch_release(&batch);\n\t\tcond_resched();\n\t} while (!stop);\n\n\t*_len = len;\n}\n\n \nstatic ssize_t cifs_write_back_from_locked_folio(struct address_space *mapping,\n\t\t\t\t\t\t struct writeback_control *wbc,\n\t\t\t\t\t\t struct folio *folio,\n\t\t\t\t\t\t loff_t start, loff_t end)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_writedata *wdata;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct cifs_credits credits_on_stack;\n\tstruct cifs_credits *credits = &credits_on_stack;\n\tstruct cifsFileInfo *cfile = NULL;\n\tunsigned int xid, wsize, len;\n\tloff_t i_size = i_size_read(inode);\n\tsize_t max_len;\n\tlong count = wbc->nr_to_write;\n\tint rc;\n\n\t \n\tif (folio_start_writeback(folio))\n\t\tWARN_ON(1);\n\n\tcount -= folio_nr_pages(folio);\n\tlen = folio_size(folio);\n\n\txid = get_xid();\n\tserver = cifs_pick_channel(cifs_sb_master_tcon(cifs_sb)->ses);\n\n\trc = cifs_get_writable_file(CIFS_I(inode), FIND_WR_ANY, &cfile);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"No writable handle in writepages rc=%d\\n\", rc);\n\t\tgoto err_xid;\n\t}\n\n\trc = server->ops->wait_mtu_credits(server, cifs_sb->ctx->wsize,\n\t\t\t\t\t   &wsize, credits);\n\tif (rc != 0)\n\t\tgoto err_close;\n\n\twdata = cifs_writedata_alloc(cifs_writev_complete);\n\tif (!wdata) {\n\t\trc = -ENOMEM;\n\t\tgoto err_uncredit;\n\t}\n\n\twdata->sync_mode = wbc->sync_mode;\n\twdata->offset = folio_pos(folio);\n\twdata->pid = cfile->pid;\n\twdata->credits = credits_on_stack;\n\twdata->cfile = cfile;\n\twdata->server = server;\n\tcfile = NULL;\n\n\t \n\tif (start < i_size) {\n\t\t \n\t\tmax_len = wsize;\n\t\tmax_len = min_t(unsigned long long, max_len, end - start + 1);\n\t\tmax_len = min_t(unsigned long long, max_len, i_size - start);\n\n\t\tif (len < max_len) {\n\t\t\tint max_pages = INT_MAX;\n\n#ifdef CONFIG_CIFS_SMB_DIRECT\n\t\t\tif (server->smbd_conn)\n\t\t\t\tmax_pages = server->smbd_conn->max_frmr_depth;\n#endif\n\t\t\tmax_pages -= folio_nr_pages(folio);\n\n\t\t\tif (max_pages > 0)\n\t\t\t\tcifs_extend_writeback(mapping, &count, start,\n\t\t\t\t\t\t      max_pages, max_len, &len);\n\t\t}\n\t\tlen = min_t(loff_t, len, max_len);\n\t}\n\n\twdata->bytes = len;\n\n\t \n\tfolio_unlock(folio);\n\n\tif (start < i_size) {\n\t\tiov_iter_xarray(&wdata->iter, ITER_SOURCE, &mapping->i_pages,\n\t\t\t\tstart, len);\n\n\t\trc = adjust_credits(wdata->server, &wdata->credits, wdata->bytes);\n\t\tif (rc)\n\t\t\tgoto err_wdata;\n\n\t\tif (wdata->cfile->invalidHandle)\n\t\t\trc = -EAGAIN;\n\t\telse\n\t\t\trc = wdata->server->ops->async_writev(wdata,\n\t\t\t\t\t\t\t      cifs_writedata_release);\n\t\tif (rc >= 0) {\n\t\t\tkref_put(&wdata->refcount, cifs_writedata_release);\n\t\t\tgoto err_close;\n\t\t}\n\t} else {\n\t\t \n\t\tcifs_pages_written_back(inode, start, len);\n\t\trc = 0;\n\t}\n\nerr_wdata:\n\tkref_put(&wdata->refcount, cifs_writedata_release);\nerr_uncredit:\n\tadd_credits_and_wake_if(server, credits, 0);\nerr_close:\n\tif (cfile)\n\t\tcifsFileInfo_put(cfile);\nerr_xid:\n\tfree_xid(xid);\n\tif (rc == 0) {\n\t\twbc->nr_to_write = count;\n\t\trc = len;\n\t} else if (is_retryable_error(rc)) {\n\t\tcifs_pages_write_redirty(inode, start, len);\n\t} else {\n\t\tcifs_pages_write_failed(inode, start, len);\n\t\tmapping_set_error(mapping, rc);\n\t}\n\t \n\tset_bit(CIFS_INO_MODIFIED_ATTR, &CIFS_I(inode)->flags);\n\treturn rc;\n}\n\n \nstatic int cifs_writepages_region(struct address_space *mapping,\n\t\t\t\t  struct writeback_control *wbc,\n\t\t\t\t  loff_t start, loff_t end, loff_t *_next)\n{\n\tstruct folio_batch fbatch;\n\tint skips = 0;\n\n\tfolio_batch_init(&fbatch);\n\tdo {\n\t\tint nr;\n\t\tpgoff_t index = start / PAGE_SIZE;\n\n\t\tnr = filemap_get_folios_tag(mapping, &index, end / PAGE_SIZE,\n\t\t\t\t\t    PAGECACHE_TAG_DIRTY, &fbatch);\n\t\tif (!nr)\n\t\t\tbreak;\n\n\t\tfor (int i = 0; i < nr; i++) {\n\t\t\tssize_t ret;\n\t\t\tstruct folio *folio = fbatch.folios[i];\n\nredo_folio:\n\t\t\tstart = folio_pos(folio);  \n\n\t\t\t \n\t\t\tif (wbc->sync_mode != WB_SYNC_NONE) {\n\t\t\t\tret = folio_lock_killable(folio);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto write_error;\n\t\t\t} else {\n\t\t\t\tif (!folio_trylock(folio))\n\t\t\t\t\tgoto skip_write;\n\t\t\t}\n\n\t\t\tif (folio_mapping(folio) != mapping ||\n\t\t\t    !folio_test_dirty(folio)) {\n\t\t\t\tstart += folio_size(folio);\n\t\t\t\tfolio_unlock(folio);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (folio_test_writeback(folio) ||\n\t\t\t    folio_test_fscache(folio)) {\n\t\t\t\tfolio_unlock(folio);\n\t\t\t\tif (wbc->sync_mode == WB_SYNC_NONE)\n\t\t\t\t\tgoto skip_write;\n\n\t\t\t\tfolio_wait_writeback(folio);\n#ifdef CONFIG_CIFS_FSCACHE\n\t\t\t\tfolio_wait_fscache(folio);\n#endif\n\t\t\t\tgoto redo_folio;\n\t\t\t}\n\n\t\t\tif (!folio_clear_dirty_for_io(folio))\n\t\t\t\t \n\t\t\t\tWARN_ON(1);\n\n\t\t\tret = cifs_write_back_from_locked_folio(mapping, wbc, folio, start, end);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto write_error;\n\n\t\t\tstart += ret;\n\t\t\tcontinue;\n\nwrite_error:\n\t\t\tfolio_batch_release(&fbatch);\n\t\t\t*_next = start;\n\t\t\treturn ret;\n\nskip_write:\n\t\t\t \n\t\t\tif (skips >= 5 || need_resched()) {\n\t\t\t\tret = 0;\n\t\t\t\tgoto write_error;\n\t\t\t}\n\n\t\t\t \n\t\t\tskips++;\n\t\t\tstart += folio_size(folio);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfolio_batch_release(&fbatch);\t\t\n\t\tcond_resched();\n\t} while (wbc->nr_to_write > 0);\n\n\t*_next = start;\n\treturn 0;\n}\n\n \nstatic int cifs_writepages(struct address_space *mapping,\n\t\t\t   struct writeback_control *wbc)\n{\n\tloff_t start, next;\n\tint ret;\n\n\t \n\n\tif (wbc->range_cyclic) {\n\t\tstart = mapping->writeback_index * PAGE_SIZE;\n\t\tret = cifs_writepages_region(mapping, wbc, start, LLONG_MAX, &next);\n\t\tif (ret == 0) {\n\t\t\tmapping->writeback_index = next / PAGE_SIZE;\n\t\t\tif (start > 0 && wbc->nr_to_write > 0) {\n\t\t\t\tret = cifs_writepages_region(mapping, wbc, 0,\n\t\t\t\t\t\t\t     start, &next);\n\t\t\t\tif (ret == 0)\n\t\t\t\t\tmapping->writeback_index =\n\t\t\t\t\t\tnext / PAGE_SIZE;\n\t\t\t}\n\t\t}\n\t} else if (wbc->range_start == 0 && wbc->range_end == LLONG_MAX) {\n\t\tret = cifs_writepages_region(mapping, wbc, 0, LLONG_MAX, &next);\n\t\tif (wbc->nr_to_write > 0 && ret == 0)\n\t\t\tmapping->writeback_index = next / PAGE_SIZE;\n\t} else {\n\t\tret = cifs_writepages_region(mapping, wbc,\n\t\t\t\t\t     wbc->range_start, wbc->range_end, &next);\n\t}\n\n\treturn ret;\n}\n\nstatic int\ncifs_writepage_locked(struct page *page, struct writeback_control *wbc)\n{\n\tint rc;\n\tunsigned int xid;\n\n\txid = get_xid();\n \n\tget_page(page);\n\tif (!PageUptodate(page))\n\t\tcifs_dbg(FYI, \"ppw - page not up to date\\n\");\n\n\t \n\tset_page_writeback(page);\nretry_write:\n\trc = cifs_partialpagewrite(page, 0, PAGE_SIZE);\n\tif (is_retryable_error(rc)) {\n\t\tif (wbc->sync_mode == WB_SYNC_ALL && rc == -EAGAIN)\n\t\t\tgoto retry_write;\n\t\tredirty_page_for_writepage(wbc, page);\n\t} else if (rc != 0) {\n\t\tSetPageError(page);\n\t\tmapping_set_error(page->mapping, rc);\n\t} else {\n\t\tSetPageUptodate(page);\n\t}\n\tend_page_writeback(page);\n\tput_page(page);\n\tfree_xid(xid);\n\treturn rc;\n}\n\nstatic int cifs_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tint rc;\n\tstruct inode *inode = mapping->host;\n\tstruct cifsFileInfo *cfile = file->private_data;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(cfile->dentry->d_sb);\n\tstruct folio *folio = page_folio(page);\n\t__u32 pid;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_RWPIDFORWARD)\n\t\tpid = cfile->pid;\n\telse\n\t\tpid = current->tgid;\n\n\tcifs_dbg(FYI, \"write_end for page %p from pos %lld with %d bytes\\n\",\n\t\t page, pos, copied);\n\n\tif (folio_test_checked(folio)) {\n\t\tif (copied == len)\n\t\t\tfolio_mark_uptodate(folio);\n\t\tfolio_clear_checked(folio);\n\t} else if (!folio_test_uptodate(folio) && copied == PAGE_SIZE)\n\t\tfolio_mark_uptodate(folio);\n\n\tif (!folio_test_uptodate(folio)) {\n\t\tchar *page_data;\n\t\tunsigned offset = pos & (PAGE_SIZE - 1);\n\t\tunsigned int xid;\n\n\t\txid = get_xid();\n\t\t \n\t\t \n\t\tpage_data = kmap(page);\n\t\trc = cifs_write(cfile, pid, page_data + offset, copied, &pos);\n\t\t \n\t\tkunmap(page);\n\n\t\tfree_xid(xid);\n\t} else {\n\t\trc = copied;\n\t\tpos += copied;\n\t\tset_page_dirty(page);\n\t}\n\n\tif (rc > 0) {\n\t\tspin_lock(&inode->i_lock);\n\t\tif (pos > inode->i_size) {\n\t\t\ti_size_write(inode, pos);\n\t\t\tinode->i_blocks = (512 - 1 + pos) >> 9;\n\t\t}\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\n\tunlock_page(page);\n\tput_page(page);\n\t \n\tset_bit(CIFS_INO_MODIFIED_ATTR, &CIFS_I(inode)->flags);\n\n\treturn rc;\n}\n\nint cifs_strict_fsync(struct file *file, loff_t start, loff_t end,\n\t\t      int datasync)\n{\n\tunsigned int xid;\n\tint rc = 0;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tstruct cifsFileInfo *smbfile = file->private_data;\n\tstruct inode *inode = file_inode(file);\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\n\trc = file_write_and_wait_range(file, start, end);\n\tif (rc) {\n\t\ttrace_cifs_fsync_err(inode->i_ino, rc);\n\t\treturn rc;\n\t}\n\n\txid = get_xid();\n\n\tcifs_dbg(FYI, \"Sync file - name: %pD datasync: 0x%x\\n\",\n\t\t file, datasync);\n\n\tif (!CIFS_CACHE_READ(CIFS_I(inode))) {\n\t\trc = cifs_zap_mapping(inode);\n\t\tif (rc) {\n\t\t\tcifs_dbg(FYI, \"rc: %d during invalidate phase\\n\", rc);\n\t\t\trc = 0;  \n\t\t}\n\t}\n\n\ttcon = tlink_tcon(smbfile->tlink);\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NOSSYNC)) {\n\t\tserver = tcon->ses->server;\n\t\tif (server->ops->flush == NULL) {\n\t\t\trc = -ENOSYS;\n\t\t\tgoto strict_fsync_exit;\n\t\t}\n\n\t\tif ((OPEN_FMODE(smbfile->f_flags) & FMODE_WRITE) == 0) {\n\t\t\tsmbfile = find_writable_file(CIFS_I(inode), FIND_WR_ANY);\n\t\t\tif (smbfile) {\n\t\t\t\trc = server->ops->flush(xid, tcon, &smbfile->fid);\n\t\t\t\tcifsFileInfo_put(smbfile);\n\t\t\t} else\n\t\t\t\tcifs_dbg(FYI, \"ignore fsync for file not open for write\\n\");\n\t\t} else\n\t\t\trc = server->ops->flush(xid, tcon, &smbfile->fid);\n\t}\n\nstrict_fsync_exit:\n\tfree_xid(xid);\n\treturn rc;\n}\n\nint cifs_fsync(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tunsigned int xid;\n\tint rc = 0;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tstruct cifsFileInfo *smbfile = file->private_data;\n\tstruct inode *inode = file_inode(file);\n\tstruct cifs_sb_info *cifs_sb = CIFS_FILE_SB(file);\n\n\trc = file_write_and_wait_range(file, start, end);\n\tif (rc) {\n\t\ttrace_cifs_fsync_err(file_inode(file)->i_ino, rc);\n\t\treturn rc;\n\t}\n\n\txid = get_xid();\n\n\tcifs_dbg(FYI, \"Sync file - name: %pD datasync: 0x%x\\n\",\n\t\t file, datasync);\n\n\ttcon = tlink_tcon(smbfile->tlink);\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NOSSYNC)) {\n\t\tserver = tcon->ses->server;\n\t\tif (server->ops->flush == NULL) {\n\t\t\trc = -ENOSYS;\n\t\t\tgoto fsync_exit;\n\t\t}\n\n\t\tif ((OPEN_FMODE(smbfile->f_flags) & FMODE_WRITE) == 0) {\n\t\t\tsmbfile = find_writable_file(CIFS_I(inode), FIND_WR_ANY);\n\t\t\tif (smbfile) {\n\t\t\t\trc = server->ops->flush(xid, tcon, &smbfile->fid);\n\t\t\t\tcifsFileInfo_put(smbfile);\n\t\t\t} else\n\t\t\t\tcifs_dbg(FYI, \"ignore fsync for file not open for write\\n\");\n\t\t} else\n\t\t\trc = server->ops->flush(xid, tcon, &smbfile->fid);\n\t}\n\nfsync_exit:\n\tfree_xid(xid);\n\treturn rc;\n}\n\n \nint cifs_flush(struct file *file, fl_owner_t id)\n{\n\tstruct inode *inode = file_inode(file);\n\tint rc = 0;\n\n\tif (file->f_mode & FMODE_WRITE)\n\t\trc = filemap_write_and_wait(inode->i_mapping);\n\n\tcifs_dbg(FYI, \"Flush inode %p file %p rc %d\\n\", inode, file, rc);\n\tif (rc) {\n\t\t \n\t\trc = filemap_check_wb_err(file->f_mapping, 0);\n\t\ttrace_cifs_flush_err(inode->i_ino, rc);\n\t}\n\treturn rc;\n}\n\nstatic void\ncifs_uncached_writedata_release(struct kref *refcount)\n{\n\tstruct cifs_writedata *wdata = container_of(refcount,\n\t\t\t\t\tstruct cifs_writedata, refcount);\n\n\tkref_put(&wdata->ctx->refcount, cifs_aio_ctx_release);\n\tcifs_writedata_release(refcount);\n}\n\nstatic void collect_uncached_write_data(struct cifs_aio_ctx *ctx);\n\nstatic void\ncifs_uncached_writev_complete(struct work_struct *work)\n{\n\tstruct cifs_writedata *wdata = container_of(work,\n\t\t\t\t\tstruct cifs_writedata, work);\n\tstruct inode *inode = d_inode(wdata->cfile->dentry);\n\tstruct cifsInodeInfo *cifsi = CIFS_I(inode);\n\n\tspin_lock(&inode->i_lock);\n\tcifs_update_eof(cifsi, wdata->offset, wdata->bytes);\n\tif (cifsi->server_eof > inode->i_size)\n\t\ti_size_write(inode, cifsi->server_eof);\n\tspin_unlock(&inode->i_lock);\n\n\tcomplete(&wdata->done);\n\tcollect_uncached_write_data(wdata->ctx);\n\t \n\tkref_put(&wdata->refcount, cifs_uncached_writedata_release);\n}\n\nstatic int\ncifs_resend_wdata(struct cifs_writedata *wdata, struct list_head *wdata_list,\n\tstruct cifs_aio_ctx *ctx)\n{\n\tunsigned int wsize;\n\tstruct cifs_credits credits;\n\tint rc;\n\tstruct TCP_Server_Info *server = wdata->server;\n\n\tdo {\n\t\tif (wdata->cfile->invalidHandle) {\n\t\t\trc = cifs_reopen_file(wdata->cfile, false);\n\t\t\tif (rc == -EAGAIN)\n\t\t\t\tcontinue;\n\t\t\telse if (rc)\n\t\t\t\tbreak;\n\t\t}\n\n\n\t\t \n\t\tdo {\n\t\t\trc = server->ops->wait_mtu_credits(server, wdata->bytes,\n\t\t\t\t\t\t&wsize, &credits);\n\t\t\tif (rc)\n\t\t\t\tgoto fail;\n\n\t\t\tif (wsize < wdata->bytes) {\n\t\t\t\tadd_credits_and_wake_if(server, &credits, 0);\n\t\t\t\tmsleep(1000);\n\t\t\t}\n\t\t} while (wsize < wdata->bytes);\n\t\twdata->credits = credits;\n\n\t\trc = adjust_credits(server, &wdata->credits, wdata->bytes);\n\n\t\tif (!rc) {\n\t\t\tif (wdata->cfile->invalidHandle)\n\t\t\t\trc = -EAGAIN;\n\t\t\telse {\n#ifdef CONFIG_CIFS_SMB_DIRECT\n\t\t\t\tif (wdata->mr) {\n\t\t\t\t\twdata->mr->need_invalidate = true;\n\t\t\t\t\tsmbd_deregister_mr(wdata->mr);\n\t\t\t\t\twdata->mr = NULL;\n\t\t\t\t}\n#endif\n\t\t\t\trc = server->ops->async_writev(wdata,\n\t\t\t\t\tcifs_uncached_writedata_release);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (!rc) {\n\t\t\tlist_add_tail(&wdata->list, wdata_list);\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tadd_credits_and_wake_if(server, &wdata->credits, 0);\n\t} while (rc == -EAGAIN);\n\nfail:\n\tkref_put(&wdata->refcount, cifs_uncached_writedata_release);\n\treturn rc;\n}\n\n \nstatic size_t cifs_limit_bvec_subset(const struct iov_iter *iter, size_t max_size,\n\t\t\t\t     size_t max_segs, unsigned int *_nsegs)\n{\n\tconst struct bio_vec *bvecs = iter->bvec;\n\tunsigned int nbv = iter->nr_segs, ix = 0, nsegs = 0;\n\tsize_t len, span = 0, n = iter->count;\n\tsize_t skip = iter->iov_offset;\n\n\tif (WARN_ON(!iov_iter_is_bvec(iter)) || n == 0)\n\t\treturn 0;\n\n\twhile (n && ix < nbv && skip) {\n\t\tlen = bvecs[ix].bv_len;\n\t\tif (skip < len)\n\t\t\tbreak;\n\t\tskip -= len;\n\t\tn -= len;\n\t\tix++;\n\t}\n\n\twhile (n && ix < nbv) {\n\t\tlen = min3(n, bvecs[ix].bv_len - skip, max_size);\n\t\tspan += len;\n\t\tmax_size -= len;\n\t\tnsegs++;\n\t\tix++;\n\t\tif (max_size == 0 || nsegs >= max_segs)\n\t\t\tbreak;\n\t\tskip = 0;\n\t\tn -= len;\n\t}\n\n\t*_nsegs = nsegs;\n\treturn span;\n}\n\nstatic int\ncifs_write_from_iter(loff_t fpos, size_t len, struct iov_iter *from,\n\t\t     struct cifsFileInfo *open_file,\n\t\t     struct cifs_sb_info *cifs_sb, struct list_head *wdata_list,\n\t\t     struct cifs_aio_ctx *ctx)\n{\n\tint rc = 0;\n\tsize_t cur_len, max_len;\n\tstruct cifs_writedata *wdata;\n\tpid_t pid;\n\tstruct TCP_Server_Info *server;\n\tunsigned int xid, max_segs = INT_MAX;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_RWPIDFORWARD)\n\t\tpid = open_file->pid;\n\telse\n\t\tpid = current->tgid;\n\n\tserver = cifs_pick_channel(tlink_tcon(open_file->tlink)->ses);\n\txid = get_xid();\n\n#ifdef CONFIG_CIFS_SMB_DIRECT\n\tif (server->smbd_conn)\n\t\tmax_segs = server->smbd_conn->max_frmr_depth;\n#endif\n\n\tdo {\n\t\tstruct cifs_credits credits_on_stack;\n\t\tstruct cifs_credits *credits = &credits_on_stack;\n\t\tunsigned int wsize, nsegs = 0;\n\n\t\tif (signal_pending(current)) {\n\t\t\trc = -EINTR;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (open_file->invalidHandle) {\n\t\t\trc = cifs_reopen_file(open_file, false);\n\t\t\tif (rc == -EAGAIN)\n\t\t\t\tcontinue;\n\t\t\telse if (rc)\n\t\t\t\tbreak;\n\t\t}\n\n\t\trc = server->ops->wait_mtu_credits(server, cifs_sb->ctx->wsize,\n\t\t\t\t\t\t   &wsize, credits);\n\t\tif (rc)\n\t\t\tbreak;\n\n\t\tmax_len = min_t(const size_t, len, wsize);\n\t\tif (!max_len) {\n\t\t\trc = -EAGAIN;\n\t\t\tadd_credits_and_wake_if(server, credits, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\tcur_len = cifs_limit_bvec_subset(from, max_len, max_segs, &nsegs);\n\t\tcifs_dbg(FYI, \"write_from_iter len=%zx/%zx nsegs=%u/%lu/%u\\n\",\n\t\t\t cur_len, max_len, nsegs, from->nr_segs, max_segs);\n\t\tif (cur_len == 0) {\n\t\t\trc = -EIO;\n\t\t\tadd_credits_and_wake_if(server, credits, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\twdata = cifs_writedata_alloc(cifs_uncached_writev_complete);\n\t\tif (!wdata) {\n\t\t\trc = -ENOMEM;\n\t\t\tadd_credits_and_wake_if(server, credits, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\twdata->sync_mode = WB_SYNC_ALL;\n\t\twdata->offset\t= (__u64)fpos;\n\t\twdata->cfile\t= cifsFileInfo_get(open_file);\n\t\twdata->server\t= server;\n\t\twdata->pid\t= pid;\n\t\twdata->bytes\t= cur_len;\n\t\twdata->credits\t= credits_on_stack;\n\t\twdata->iter\t= *from;\n\t\twdata->ctx\t= ctx;\n\t\tkref_get(&ctx->refcount);\n\n\t\tiov_iter_truncate(&wdata->iter, cur_len);\n\n\t\trc = adjust_credits(server, &wdata->credits, wdata->bytes);\n\n\t\tif (!rc) {\n\t\t\tif (wdata->cfile->invalidHandle)\n\t\t\t\trc = -EAGAIN;\n\t\t\telse\n\t\t\t\trc = server->ops->async_writev(wdata,\n\t\t\t\t\tcifs_uncached_writedata_release);\n\t\t}\n\n\t\tif (rc) {\n\t\t\tadd_credits_and_wake_if(server, &wdata->credits, 0);\n\t\t\tkref_put(&wdata->refcount,\n\t\t\t\t cifs_uncached_writedata_release);\n\t\t\tif (rc == -EAGAIN)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\n\t\tlist_add_tail(&wdata->list, wdata_list);\n\t\tiov_iter_advance(from, cur_len);\n\t\tfpos += cur_len;\n\t\tlen -= cur_len;\n\t} while (len > 0);\n\n\tfree_xid(xid);\n\treturn rc;\n}\n\nstatic void collect_uncached_write_data(struct cifs_aio_ctx *ctx)\n{\n\tstruct cifs_writedata *wdata, *tmp;\n\tstruct cifs_tcon *tcon;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct dentry *dentry = ctx->cfile->dentry;\n\tssize_t rc;\n\n\ttcon = tlink_tcon(ctx->cfile->tlink);\n\tcifs_sb = CIFS_SB(dentry->d_sb);\n\n\tmutex_lock(&ctx->aio_mutex);\n\n\tif (list_empty(&ctx->list)) {\n\t\tmutex_unlock(&ctx->aio_mutex);\n\t\treturn;\n\t}\n\n\trc = ctx->rc;\n\t \nrestart_loop:\n\tlist_for_each_entry_safe(wdata, tmp, &ctx->list, list) {\n\t\tif (!rc) {\n\t\t\tif (!try_wait_for_completion(&wdata->done)) {\n\t\t\t\tmutex_unlock(&ctx->aio_mutex);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (wdata->result)\n\t\t\t\trc = wdata->result;\n\t\t\telse\n\t\t\t\tctx->total_len += wdata->bytes;\n\n\t\t\t \n\t\t\tif (rc == -EAGAIN) {\n\t\t\t\tstruct list_head tmp_list;\n\t\t\t\tstruct iov_iter tmp_from = ctx->iter;\n\n\t\t\t\tINIT_LIST_HEAD(&tmp_list);\n\t\t\t\tlist_del_init(&wdata->list);\n\n\t\t\t\tif (ctx->direct_io)\n\t\t\t\t\trc = cifs_resend_wdata(\n\t\t\t\t\t\twdata, &tmp_list, ctx);\n\t\t\t\telse {\n\t\t\t\t\tiov_iter_advance(&tmp_from,\n\t\t\t\t\t\t wdata->offset - ctx->pos);\n\n\t\t\t\t\trc = cifs_write_from_iter(wdata->offset,\n\t\t\t\t\t\twdata->bytes, &tmp_from,\n\t\t\t\t\t\tctx->cfile, cifs_sb, &tmp_list,\n\t\t\t\t\t\tctx);\n\n\t\t\t\t\tkref_put(&wdata->refcount,\n\t\t\t\t\t\tcifs_uncached_writedata_release);\n\t\t\t\t}\n\n\t\t\t\tlist_splice(&tmp_list, &ctx->list);\n\t\t\t\tgoto restart_loop;\n\t\t\t}\n\t\t}\n\t\tlist_del_init(&wdata->list);\n\t\tkref_put(&wdata->refcount, cifs_uncached_writedata_release);\n\t}\n\n\tcifs_stats_bytes_written(tcon, ctx->total_len);\n\tset_bit(CIFS_INO_INVALID_MAPPING, &CIFS_I(dentry->d_inode)->flags);\n\n\tctx->rc = (rc == 0) ? ctx->total_len : rc;\n\n\tmutex_unlock(&ctx->aio_mutex);\n\n\tif (ctx->iocb && ctx->iocb->ki_complete)\n\t\tctx->iocb->ki_complete(ctx->iocb, ctx->rc);\n\telse\n\t\tcomplete(&ctx->done);\n}\n\nstatic ssize_t __cifs_writev(\n\tstruct kiocb *iocb, struct iov_iter *from, bool direct)\n{\n\tstruct file *file = iocb->ki_filp;\n\tssize_t total_written = 0;\n\tstruct cifsFileInfo *cfile;\n\tstruct cifs_tcon *tcon;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct cifs_aio_ctx *ctx;\n\tint rc;\n\n\trc = generic_write_checks(iocb, from);\n\tif (rc <= 0)\n\t\treturn rc;\n\n\tcifs_sb = CIFS_FILE_SB(file);\n\tcfile = file->private_data;\n\ttcon = tlink_tcon(cfile->tlink);\n\n\tif (!tcon->ses->server->ops->async_writev)\n\t\treturn -ENOSYS;\n\n\tctx = cifs_aio_ctx_alloc();\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->cfile = cifsFileInfo_get(cfile);\n\n\tif (!is_sync_kiocb(iocb))\n\t\tctx->iocb = iocb;\n\n\tctx->pos = iocb->ki_pos;\n\tctx->direct_io = direct;\n\tctx->nr_pinned_pages = 0;\n\n\tif (user_backed_iter(from)) {\n\t\t \n\t\trc = netfs_extract_user_iter(from, iov_iter_count(from),\n\t\t\t\t\t     &ctx->iter, 0);\n\t\tif (rc < 0) {\n\t\t\tkref_put(&ctx->refcount, cifs_aio_ctx_release);\n\t\t\treturn rc;\n\t\t}\n\n\t\tctx->nr_pinned_pages = rc;\n\t\tctx->bv = (void *)ctx->iter.bvec;\n\t\tctx->bv_need_unpin = iov_iter_extract_will_pin(from);\n\t} else if ((iov_iter_is_bvec(from) || iov_iter_is_kvec(from)) &&\n\t\t   !is_sync_kiocb(iocb)) {\n\t\t \n\t\tctx->bv = (void *)dup_iter(&ctx->iter, from, GFP_KERNEL);\n\t\tif (!ctx->bv) {\n\t\t\tkref_put(&ctx->refcount, cifs_aio_ctx_release);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t} else {\n\t\t \n\t\tctx->iter = *from;\n\t}\n\n\tctx->len = iov_iter_count(&ctx->iter);\n\n\t \n\tmutex_lock(&ctx->aio_mutex);\n\n\trc = cifs_write_from_iter(iocb->ki_pos, ctx->len, &ctx->iter,\n\t\t\t\t  cfile, cifs_sb, &ctx->list, ctx);\n\n\t \n\tif (!list_empty(&ctx->list))\n\t\trc = 0;\n\n\tmutex_unlock(&ctx->aio_mutex);\n\n\tif (rc) {\n\t\tkref_put(&ctx->refcount, cifs_aio_ctx_release);\n\t\treturn rc;\n\t}\n\n\tif (!is_sync_kiocb(iocb)) {\n\t\tkref_put(&ctx->refcount, cifs_aio_ctx_release);\n\t\treturn -EIOCBQUEUED;\n\t}\n\n\trc = wait_for_completion_killable(&ctx->done);\n\tif (rc) {\n\t\tmutex_lock(&ctx->aio_mutex);\n\t\tctx->rc = rc = -EINTR;\n\t\ttotal_written = ctx->total_len;\n\t\tmutex_unlock(&ctx->aio_mutex);\n\t} else {\n\t\trc = ctx->rc;\n\t\ttotal_written = ctx->total_len;\n\t}\n\n\tkref_put(&ctx->refcount, cifs_aio_ctx_release);\n\n\tif (unlikely(!total_written))\n\t\treturn rc;\n\n\tiocb->ki_pos += total_written;\n\treturn total_written;\n}\n\nssize_t cifs_direct_writev(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\n\tcifs_revalidate_mapping(file->f_inode);\n\treturn __cifs_writev(iocb, from, true);\n}\n\nssize_t cifs_user_writev(struct kiocb *iocb, struct iov_iter *from)\n{\n\treturn __cifs_writev(iocb, from, false);\n}\n\nstatic ssize_t\ncifs_writev(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct cifsFileInfo *cfile = (struct cifsFileInfo *)file->private_data;\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct cifsInodeInfo *cinode = CIFS_I(inode);\n\tstruct TCP_Server_Info *server = tlink_tcon(cfile->tlink)->ses->server;\n\tssize_t rc;\n\n\tinode_lock(inode);\n\t \n\tdown_read(&cinode->lock_sem);\n\n\trc = generic_write_checks(iocb, from);\n\tif (rc <= 0)\n\t\tgoto out;\n\n\tif (!cifs_find_lock_conflict(cfile, iocb->ki_pos, iov_iter_count(from),\n\t\t\t\t     server->vals->exclusive_lock_type, 0,\n\t\t\t\t     NULL, CIFS_WRITE_OP))\n\t\trc = __generic_file_write_iter(iocb, from);\n\telse\n\t\trc = -EACCES;\nout:\n\tup_read(&cinode->lock_sem);\n\tinode_unlock(inode);\n\n\tif (rc > 0)\n\t\trc = generic_write_sync(iocb, rc);\n\treturn rc;\n}\n\nssize_t\ncifs_strict_writev(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct inode *inode = file_inode(iocb->ki_filp);\n\tstruct cifsInodeInfo *cinode = CIFS_I(inode);\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct cifsFileInfo *cfile = (struct cifsFileInfo *)\n\t\t\t\t\t\tiocb->ki_filp->private_data;\n\tstruct cifs_tcon *tcon = tlink_tcon(cfile->tlink);\n\tssize_t written;\n\n\twritten = cifs_get_writer(cinode);\n\tif (written)\n\t\treturn written;\n\n\tif (CIFS_CACHE_WRITE(cinode)) {\n\t\tif (cap_unix(tcon->ses) &&\n\t\t(CIFS_UNIX_FCNTL_CAP & le64_to_cpu(tcon->fsUnixInfo.Capability))\n\t\t  && ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NOPOSIXBRL) == 0)) {\n\t\t\twritten = generic_file_write_iter(iocb, from);\n\t\t\tgoto out;\n\t\t}\n\t\twritten = cifs_writev(iocb, from);\n\t\tgoto out;\n\t}\n\t \n\twritten = cifs_user_writev(iocb, from);\n\tif (CIFS_CACHE_READ(cinode)) {\n\t\t \n\t\tcifs_zap_mapping(inode);\n\t\tcifs_dbg(FYI, \"Set Oplock/Lease to NONE for inode=%p after write\\n\",\n\t\t\t inode);\n\t\tcinode->oplock = 0;\n\t}\nout:\n\tcifs_put_writer(cinode);\n\treturn written;\n}\n\nstatic struct cifs_readdata *cifs_readdata_alloc(work_func_t complete)\n{\n\tstruct cifs_readdata *rdata;\n\n\trdata = kzalloc(sizeof(*rdata), GFP_KERNEL);\n\tif (rdata) {\n\t\tkref_init(&rdata->refcount);\n\t\tINIT_LIST_HEAD(&rdata->list);\n\t\tinit_completion(&rdata->done);\n\t\tINIT_WORK(&rdata->work, complete);\n\t}\n\n\treturn rdata;\n}\n\nvoid\ncifs_readdata_release(struct kref *refcount)\n{\n\tstruct cifs_readdata *rdata = container_of(refcount,\n\t\t\t\t\tstruct cifs_readdata, refcount);\n\n\tif (rdata->ctx)\n\t\tkref_put(&rdata->ctx->refcount, cifs_aio_ctx_release);\n#ifdef CONFIG_CIFS_SMB_DIRECT\n\tif (rdata->mr) {\n\t\tsmbd_deregister_mr(rdata->mr);\n\t\trdata->mr = NULL;\n\t}\n#endif\n\tif (rdata->cfile)\n\t\tcifsFileInfo_put(rdata->cfile);\n\n\tkfree(rdata);\n}\n\nstatic void collect_uncached_read_data(struct cifs_aio_ctx *ctx);\n\nstatic void\ncifs_uncached_readv_complete(struct work_struct *work)\n{\n\tstruct cifs_readdata *rdata = container_of(work,\n\t\t\t\t\t\tstruct cifs_readdata, work);\n\n\tcomplete(&rdata->done);\n\tcollect_uncached_read_data(rdata->ctx);\n\t \n\tkref_put(&rdata->refcount, cifs_readdata_release);\n}\n\nstatic int cifs_resend_rdata(struct cifs_readdata *rdata,\n\t\t\tstruct list_head *rdata_list,\n\t\t\tstruct cifs_aio_ctx *ctx)\n{\n\tunsigned int rsize;\n\tstruct cifs_credits credits;\n\tint rc;\n\tstruct TCP_Server_Info *server;\n\n\t \n\tserver = rdata->server;\n\n\tdo {\n\t\tif (rdata->cfile->invalidHandle) {\n\t\t\trc = cifs_reopen_file(rdata->cfile, true);\n\t\t\tif (rc == -EAGAIN)\n\t\t\t\tcontinue;\n\t\t\telse if (rc)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tdo {\n\t\t\trc = server->ops->wait_mtu_credits(server, rdata->bytes,\n\t\t\t\t\t\t&rsize, &credits);\n\n\t\t\tif (rc)\n\t\t\t\tgoto fail;\n\n\t\t\tif (rsize < rdata->bytes) {\n\t\t\t\tadd_credits_and_wake_if(server, &credits, 0);\n\t\t\t\tmsleep(1000);\n\t\t\t}\n\t\t} while (rsize < rdata->bytes);\n\t\trdata->credits = credits;\n\n\t\trc = adjust_credits(server, &rdata->credits, rdata->bytes);\n\t\tif (!rc) {\n\t\t\tif (rdata->cfile->invalidHandle)\n\t\t\t\trc = -EAGAIN;\n\t\t\telse {\n#ifdef CONFIG_CIFS_SMB_DIRECT\n\t\t\t\tif (rdata->mr) {\n\t\t\t\t\trdata->mr->need_invalidate = true;\n\t\t\t\t\tsmbd_deregister_mr(rdata->mr);\n\t\t\t\t\trdata->mr = NULL;\n\t\t\t\t}\n#endif\n\t\t\t\trc = server->ops->async_readv(rdata);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (!rc) {\n\t\t\t \n\t\t\tlist_add_tail(&rdata->list, rdata_list);\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tadd_credits_and_wake_if(server, &rdata->credits, 0);\n\t} while (rc == -EAGAIN);\n\nfail:\n\tkref_put(&rdata->refcount, cifs_readdata_release);\n\treturn rc;\n}\n\nstatic int\ncifs_send_async_read(loff_t fpos, size_t len, struct cifsFileInfo *open_file,\n\t\t     struct cifs_sb_info *cifs_sb, struct list_head *rdata_list,\n\t\t     struct cifs_aio_ctx *ctx)\n{\n\tstruct cifs_readdata *rdata;\n\tunsigned int rsize, nsegs, max_segs = INT_MAX;\n\tstruct cifs_credits credits_on_stack;\n\tstruct cifs_credits *credits = &credits_on_stack;\n\tsize_t cur_len, max_len;\n\tint rc;\n\tpid_t pid;\n\tstruct TCP_Server_Info *server;\n\n\tserver = cifs_pick_channel(tlink_tcon(open_file->tlink)->ses);\n\n#ifdef CONFIG_CIFS_SMB_DIRECT\n\tif (server->smbd_conn)\n\t\tmax_segs = server->smbd_conn->max_frmr_depth;\n#endif\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_RWPIDFORWARD)\n\t\tpid = open_file->pid;\n\telse\n\t\tpid = current->tgid;\n\n\tdo {\n\t\tif (open_file->invalidHandle) {\n\t\t\trc = cifs_reopen_file(open_file, true);\n\t\t\tif (rc == -EAGAIN)\n\t\t\t\tcontinue;\n\t\t\telse if (rc)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (cifs_sb->ctx->rsize == 0)\n\t\t\tcifs_sb->ctx->rsize =\n\t\t\t\tserver->ops->negotiate_rsize(tlink_tcon(open_file->tlink),\n\t\t\t\t\t\t\t     cifs_sb->ctx);\n\n\t\trc = server->ops->wait_mtu_credits(server, cifs_sb->ctx->rsize,\n\t\t\t\t\t\t   &rsize, credits);\n\t\tif (rc)\n\t\t\tbreak;\n\n\t\tmax_len = min_t(size_t, len, rsize);\n\n\t\tcur_len = cifs_limit_bvec_subset(&ctx->iter, max_len,\n\t\t\t\t\t\t max_segs, &nsegs);\n\t\tcifs_dbg(FYI, \"read-to-iter len=%zx/%zx nsegs=%u/%lu/%u\\n\",\n\t\t\t cur_len, max_len, nsegs, ctx->iter.nr_segs, max_segs);\n\t\tif (cur_len == 0) {\n\t\t\trc = -EIO;\n\t\t\tadd_credits_and_wake_if(server, credits, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\trdata = cifs_readdata_alloc(cifs_uncached_readv_complete);\n\t\tif (!rdata) {\n\t\t\tadd_credits_and_wake_if(server, credits, 0);\n\t\t\trc = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\trdata->server\t= server;\n\t\trdata->cfile\t= cifsFileInfo_get(open_file);\n\t\trdata->offset\t= fpos;\n\t\trdata->bytes\t= cur_len;\n\t\trdata->pid\t= pid;\n\t\trdata->credits\t= credits_on_stack;\n\t\trdata->ctx\t= ctx;\n\t\tkref_get(&ctx->refcount);\n\n\t\trdata->iter\t= ctx->iter;\n\t\tiov_iter_truncate(&rdata->iter, cur_len);\n\n\t\trc = adjust_credits(server, &rdata->credits, rdata->bytes);\n\n\t\tif (!rc) {\n\t\t\tif (rdata->cfile->invalidHandle)\n\t\t\t\trc = -EAGAIN;\n\t\t\telse\n\t\t\t\trc = server->ops->async_readv(rdata);\n\t\t}\n\n\t\tif (rc) {\n\t\t\tadd_credits_and_wake_if(server, &rdata->credits, 0);\n\t\t\tkref_put(&rdata->refcount, cifs_readdata_release);\n\t\t\tif (rc == -EAGAIN)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\n\t\tlist_add_tail(&rdata->list, rdata_list);\n\t\tiov_iter_advance(&ctx->iter, cur_len);\n\t\tfpos += cur_len;\n\t\tlen -= cur_len;\n\t} while (len > 0);\n\n\treturn rc;\n}\n\nstatic void\ncollect_uncached_read_data(struct cifs_aio_ctx *ctx)\n{\n\tstruct cifs_readdata *rdata, *tmp;\n\tstruct cifs_sb_info *cifs_sb;\n\tint rc;\n\n\tcifs_sb = CIFS_SB(ctx->cfile->dentry->d_sb);\n\n\tmutex_lock(&ctx->aio_mutex);\n\n\tif (list_empty(&ctx->list)) {\n\t\tmutex_unlock(&ctx->aio_mutex);\n\t\treturn;\n\t}\n\n\trc = ctx->rc;\n\t \nagain:\n\tlist_for_each_entry_safe(rdata, tmp, &ctx->list, list) {\n\t\tif (!rc) {\n\t\t\tif (!try_wait_for_completion(&rdata->done)) {\n\t\t\t\tmutex_unlock(&ctx->aio_mutex);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (rdata->result == -EAGAIN) {\n\t\t\t\t \n\t\t\t\tstruct list_head tmp_list;\n\t\t\t\tunsigned int got_bytes = rdata->got_bytes;\n\n\t\t\t\tlist_del_init(&rdata->list);\n\t\t\t\tINIT_LIST_HEAD(&tmp_list);\n\n\t\t\t\tif (ctx->direct_io) {\n\t\t\t\t\t \n\t\t\t\t\trc = cifs_resend_rdata(\n\t\t\t\t\t\trdata,\n\t\t\t\t\t\t&tmp_list, ctx);\n\t\t\t\t} else {\n\t\t\t\t\trc = cifs_send_async_read(\n\t\t\t\t\t\trdata->offset + got_bytes,\n\t\t\t\t\t\trdata->bytes - got_bytes,\n\t\t\t\t\t\trdata->cfile, cifs_sb,\n\t\t\t\t\t\t&tmp_list, ctx);\n\n\t\t\t\t\tkref_put(&rdata->refcount,\n\t\t\t\t\t\tcifs_readdata_release);\n\t\t\t\t}\n\n\t\t\t\tlist_splice(&tmp_list, &ctx->list);\n\n\t\t\t\tgoto again;\n\t\t\t} else if (rdata->result)\n\t\t\t\trc = rdata->result;\n\n\t\t\t \n\t\t\tif (rdata->got_bytes && rdata->got_bytes < rdata->bytes)\n\t\t\t\trc = -ENODATA;\n\n\t\t\tctx->total_len += rdata->got_bytes;\n\t\t}\n\t\tlist_del_init(&rdata->list);\n\t\tkref_put(&rdata->refcount, cifs_readdata_release);\n\t}\n\n\t \n\tif (rc == -ENODATA)\n\t\trc = 0;\n\n\tctx->rc = (rc == 0) ? (ssize_t)ctx->total_len : rc;\n\n\tmutex_unlock(&ctx->aio_mutex);\n\n\tif (ctx->iocb && ctx->iocb->ki_complete)\n\t\tctx->iocb->ki_complete(ctx->iocb, ctx->rc);\n\telse\n\t\tcomplete(&ctx->done);\n}\n\nstatic ssize_t __cifs_readv(\n\tstruct kiocb *iocb, struct iov_iter *to, bool direct)\n{\n\tsize_t len;\n\tstruct file *file = iocb->ki_filp;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct cifsFileInfo *cfile;\n\tstruct cifs_tcon *tcon;\n\tssize_t rc, total_read = 0;\n\tloff_t offset = iocb->ki_pos;\n\tstruct cifs_aio_ctx *ctx;\n\n\tlen = iov_iter_count(to);\n\tif (!len)\n\t\treturn 0;\n\n\tcifs_sb = CIFS_FILE_SB(file);\n\tcfile = file->private_data;\n\ttcon = tlink_tcon(cfile->tlink);\n\n\tif (!tcon->ses->server->ops->async_readv)\n\t\treturn -ENOSYS;\n\n\tif ((file->f_flags & O_ACCMODE) == O_WRONLY)\n\t\tcifs_dbg(FYI, \"attempting read on write only file instance\\n\");\n\n\tctx = cifs_aio_ctx_alloc();\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->pos\t= offset;\n\tctx->direct_io\t= direct;\n\tctx->len\t= len;\n\tctx->cfile\t= cifsFileInfo_get(cfile);\n\tctx->nr_pinned_pages = 0;\n\n\tif (!is_sync_kiocb(iocb))\n\t\tctx->iocb = iocb;\n\n\tif (user_backed_iter(to)) {\n\t\t \n\t\trc = netfs_extract_user_iter(to, iov_iter_count(to),\n\t\t\t\t\t     &ctx->iter, 0);\n\t\tif (rc < 0) {\n\t\t\tkref_put(&ctx->refcount, cifs_aio_ctx_release);\n\t\t\treturn rc;\n\t\t}\n\n\t\tctx->nr_pinned_pages = rc;\n\t\tctx->bv = (void *)ctx->iter.bvec;\n\t\tctx->bv_need_unpin = iov_iter_extract_will_pin(to);\n\t\tctx->should_dirty = true;\n\t} else if ((iov_iter_is_bvec(to) || iov_iter_is_kvec(to)) &&\n\t\t   !is_sync_kiocb(iocb)) {\n\t\t \n\t\tctx->bv = (void *)dup_iter(&ctx->iter, to, GFP_KERNEL);\n\t\tif (!ctx->bv) {\n\t\t\tkref_put(&ctx->refcount, cifs_aio_ctx_release);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t} else {\n\t\t \n\t\tctx->iter = *to;\n\t}\n\n\tif (direct) {\n\t\trc = filemap_write_and_wait_range(file->f_inode->i_mapping,\n\t\t\t\t\t\t  offset, offset + len - 1);\n\t\tif (rc) {\n\t\t\tkref_put(&ctx->refcount, cifs_aio_ctx_release);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t}\n\n\t \n\tmutex_lock(&ctx->aio_mutex);\n\n\trc = cifs_send_async_read(offset, len, cfile, cifs_sb, &ctx->list, ctx);\n\n\t \n\tif (!list_empty(&ctx->list))\n\t\trc = 0;\n\n\tmutex_unlock(&ctx->aio_mutex);\n\n\tif (rc) {\n\t\tkref_put(&ctx->refcount, cifs_aio_ctx_release);\n\t\treturn rc;\n\t}\n\n\tif (!is_sync_kiocb(iocb)) {\n\t\tkref_put(&ctx->refcount, cifs_aio_ctx_release);\n\t\treturn -EIOCBQUEUED;\n\t}\n\n\trc = wait_for_completion_killable(&ctx->done);\n\tif (rc) {\n\t\tmutex_lock(&ctx->aio_mutex);\n\t\tctx->rc = rc = -EINTR;\n\t\ttotal_read = ctx->total_len;\n\t\tmutex_unlock(&ctx->aio_mutex);\n\t} else {\n\t\trc = ctx->rc;\n\t\ttotal_read = ctx->total_len;\n\t}\n\n\tkref_put(&ctx->refcount, cifs_aio_ctx_release);\n\n\tif (total_read) {\n\t\tiocb->ki_pos += total_read;\n\t\treturn total_read;\n\t}\n\treturn rc;\n}\n\nssize_t cifs_direct_readv(struct kiocb *iocb, struct iov_iter *to)\n{\n\treturn __cifs_readv(iocb, to, true);\n}\n\nssize_t cifs_user_readv(struct kiocb *iocb, struct iov_iter *to)\n{\n\treturn __cifs_readv(iocb, to, false);\n}\n\nssize_t\ncifs_strict_readv(struct kiocb *iocb, struct iov_iter *to)\n{\n\tstruct inode *inode = file_inode(iocb->ki_filp);\n\tstruct cifsInodeInfo *cinode = CIFS_I(inode);\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct cifsFileInfo *cfile = (struct cifsFileInfo *)\n\t\t\t\t\t\tiocb->ki_filp->private_data;\n\tstruct cifs_tcon *tcon = tlink_tcon(cfile->tlink);\n\tint rc = -EACCES;\n\n\t \n\tif (!CIFS_CACHE_READ(cinode))\n\t\treturn cifs_user_readv(iocb, to);\n\n\tif (cap_unix(tcon->ses) &&\n\t    (CIFS_UNIX_FCNTL_CAP & le64_to_cpu(tcon->fsUnixInfo.Capability)) &&\n\t    ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NOPOSIXBRL) == 0))\n\t\treturn generic_file_read_iter(iocb, to);\n\n\t \n\tdown_read(&cinode->lock_sem);\n\tif (!cifs_find_lock_conflict(cfile, iocb->ki_pos, iov_iter_count(to),\n\t\t\t\t     tcon->ses->server->vals->shared_lock_type,\n\t\t\t\t     0, NULL, CIFS_READ_OP))\n\t\trc = generic_file_read_iter(iocb, to);\n\tup_read(&cinode->lock_sem);\n\treturn rc;\n}\n\nstatic ssize_t\ncifs_read(struct file *file, char *read_data, size_t read_size, loff_t *offset)\n{\n\tint rc = -EACCES;\n\tunsigned int bytes_read = 0;\n\tunsigned int total_read;\n\tunsigned int current_read_size;\n\tunsigned int rsize;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tunsigned int xid;\n\tchar *cur_offset;\n\tstruct cifsFileInfo *open_file;\n\tstruct cifs_io_parms io_parms = {0};\n\tint buf_type = CIFS_NO_BUFFER;\n\t__u32 pid;\n\n\txid = get_xid();\n\tcifs_sb = CIFS_FILE_SB(file);\n\n\t \n\trsize = min_t(unsigned int, cifs_sb->ctx->rsize, CIFSMaxBufSize);\n\n\tif (file->private_data == NULL) {\n\t\trc = -EBADF;\n\t\tfree_xid(xid);\n\t\treturn rc;\n\t}\n\topen_file = file->private_data;\n\ttcon = tlink_tcon(open_file->tlink);\n\tserver = cifs_pick_channel(tcon->ses);\n\n\tif (!server->ops->sync_read) {\n\t\tfree_xid(xid);\n\t\treturn -ENOSYS;\n\t}\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_RWPIDFORWARD)\n\t\tpid = open_file->pid;\n\telse\n\t\tpid = current->tgid;\n\n\tif ((file->f_flags & O_ACCMODE) == O_WRONLY)\n\t\tcifs_dbg(FYI, \"attempting read on write only file instance\\n\");\n\n\tfor (total_read = 0, cur_offset = read_data; read_size > total_read;\n\t     total_read += bytes_read, cur_offset += bytes_read) {\n\t\tdo {\n\t\t\tcurrent_read_size = min_t(uint, read_size - total_read,\n\t\t\t\t\t\t  rsize);\n\t\t\t \n\t\t\tif (!(tcon->ses->capabilities &\n\t\t\t\ttcon->ses->server->vals->cap_large_files)) {\n\t\t\t\tcurrent_read_size = min_t(uint,\n\t\t\t\t\tcurrent_read_size, CIFSMaxBufSize);\n\t\t\t}\n\t\t\tif (open_file->invalidHandle) {\n\t\t\t\trc = cifs_reopen_file(open_file, true);\n\t\t\t\tif (rc != 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tio_parms.pid = pid;\n\t\t\tio_parms.tcon = tcon;\n\t\t\tio_parms.offset = *offset;\n\t\t\tio_parms.length = current_read_size;\n\t\t\tio_parms.server = server;\n\t\t\trc = server->ops->sync_read(xid, &open_file->fid, &io_parms,\n\t\t\t\t\t\t    &bytes_read, &cur_offset,\n\t\t\t\t\t\t    &buf_type);\n\t\t} while (rc == -EAGAIN);\n\n\t\tif (rc || (bytes_read == 0)) {\n\t\t\tif (total_read) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tfree_xid(xid);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t} else {\n\t\t\tcifs_stats_bytes_read(tcon, total_read);\n\t\t\t*offset += bytes_read;\n\t\t}\n\t}\n\tfree_xid(xid);\n\treturn total_read;\n}\n\n \nstatic vm_fault_t cifs_page_mkwrite(struct vm_fault *vmf)\n{\n\tstruct folio *folio = page_folio(vmf->page);\n\n\t \n#ifdef CONFIG_CIFS_FSCACHE\n\tif (folio_test_fscache(folio) &&\n\t    folio_wait_fscache_killable(folio) < 0)\n\t\treturn VM_FAULT_RETRY;\n#endif\n\n\tfolio_wait_writeback(folio);\n\n\tif (folio_lock_killable(folio) < 0)\n\t\treturn VM_FAULT_RETRY;\n\treturn VM_FAULT_LOCKED;\n}\n\nstatic const struct vm_operations_struct cifs_file_vm_ops = {\n\t.fault = filemap_fault,\n\t.map_pages = filemap_map_pages,\n\t.page_mkwrite = cifs_page_mkwrite,\n};\n\nint cifs_file_strict_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tint xid, rc = 0;\n\tstruct inode *inode = file_inode(file);\n\n\txid = get_xid();\n\n\tif (!CIFS_CACHE_READ(CIFS_I(inode)))\n\t\trc = cifs_zap_mapping(inode);\n\tif (!rc)\n\t\trc = generic_file_mmap(file, vma);\n\tif (!rc)\n\t\tvma->vm_ops = &cifs_file_vm_ops;\n\n\tfree_xid(xid);\n\treturn rc;\n}\n\nint cifs_file_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tint rc, xid;\n\n\txid = get_xid();\n\n\trc = cifs_revalidate_file(file);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Validation prior to mmap failed, error=%d\\n\",\n\t\t\t rc);\n\tif (!rc)\n\t\trc = generic_file_mmap(file, vma);\n\tif (!rc)\n\t\tvma->vm_ops = &cifs_file_vm_ops;\n\n\tfree_xid(xid);\n\treturn rc;\n}\n\n \nstatic void cifs_unlock_folios(struct address_space *mapping, pgoff_t first, pgoff_t last)\n{\n\tstruct folio *folio;\n\tXA_STATE(xas, &mapping->i_pages, first);\n\n\trcu_read_lock();\n\txas_for_each(&xas, folio, last) {\n\t\tfolio_unlock(folio);\n\t}\n\trcu_read_unlock();\n}\n\nstatic void cifs_readahead_complete(struct work_struct *work)\n{\n\tstruct cifs_readdata *rdata = container_of(work,\n\t\t\t\t\t\t   struct cifs_readdata, work);\n\tstruct folio *folio;\n\tpgoff_t last;\n\tbool good = rdata->result == 0 || (rdata->result == -EAGAIN && rdata->got_bytes);\n\n\tXA_STATE(xas, &rdata->mapping->i_pages, rdata->offset / PAGE_SIZE);\n\n\tif (good)\n\t\tcifs_readahead_to_fscache(rdata->mapping->host,\n\t\t\t\t\t  rdata->offset, rdata->bytes);\n\n\tif (iov_iter_count(&rdata->iter) > 0)\n\t\tiov_iter_zero(iov_iter_count(&rdata->iter), &rdata->iter);\n\n\tlast = (rdata->offset + rdata->bytes - 1) / PAGE_SIZE;\n\n\trcu_read_lock();\n\txas_for_each(&xas, folio, last) {\n\t\tif (good) {\n\t\t\tflush_dcache_folio(folio);\n\t\t\tfolio_mark_uptodate(folio);\n\t\t}\n\t\tfolio_unlock(folio);\n\t}\n\trcu_read_unlock();\n\n\tkref_put(&rdata->refcount, cifs_readdata_release);\n}\n\nstatic void cifs_readahead(struct readahead_control *ractl)\n{\n\tstruct cifsFileInfo *open_file = ractl->file->private_data;\n\tstruct cifs_sb_info *cifs_sb = CIFS_FILE_SB(ractl->file);\n\tstruct TCP_Server_Info *server;\n\tunsigned int xid, nr_pages, cache_nr_pages = 0;\n\tunsigned int ra_pages;\n\tpgoff_t next_cached = ULONG_MAX, ra_index;\n\tbool caching = fscache_cookie_enabled(cifs_inode_cookie(ractl->mapping->host)) &&\n\t\tcifs_inode_cookie(ractl->mapping->host)->cache_priv;\n\tbool check_cache = caching;\n\tpid_t pid;\n\tint rc = 0;\n\n\t \n\tra_pages = readahead_count(ractl);\n\tra_index = readahead_index(ractl);\n\n\txid = get_xid();\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_RWPIDFORWARD)\n\t\tpid = open_file->pid;\n\telse\n\t\tpid = current->tgid;\n\n\tserver = cifs_pick_channel(tlink_tcon(open_file->tlink)->ses);\n\n\tcifs_dbg(FYI, \"%s: file=%p mapping=%p num_pages=%u\\n\",\n\t\t __func__, ractl->file, ractl->mapping, ra_pages);\n\n\t \n\twhile ((nr_pages = ra_pages)) {\n\t\tunsigned int i, rsize;\n\t\tstruct cifs_readdata *rdata;\n\t\tstruct cifs_credits credits_on_stack;\n\t\tstruct cifs_credits *credits = &credits_on_stack;\n\t\tstruct folio *folio;\n\t\tpgoff_t fsize;\n\n\t\t \n\t\tif (caching) {\n\t\t\tif (check_cache) {\n\t\t\t\trc = cifs_fscache_query_occupancy(\n\t\t\t\t\tractl->mapping->host, ra_index, nr_pages,\n\t\t\t\t\t&next_cached, &cache_nr_pages);\n\t\t\t\tif (rc < 0)\n\t\t\t\t\tcaching = false;\n\t\t\t\tcheck_cache = false;\n\t\t\t}\n\n\t\t\tif (ra_index == next_cached) {\n\t\t\t\t \n\t\t\t\tfolio = readahead_folio(ractl);\n\t\t\t\tfsize = folio_nr_pages(folio);\n\t\t\t\tra_pages -= fsize;\n\t\t\t\tra_index += fsize;\n\t\t\t\tif (cifs_readpage_from_fscache(ractl->mapping->host,\n\t\t\t\t\t\t\t       &folio->page) < 0) {\n\t\t\t\t\t \n\t\t\t\t\tcaching = false;\n\t\t\t\t}\n\t\t\t\tfolio_unlock(folio);\n\t\t\t\tnext_cached += fsize;\n\t\t\t\tcache_nr_pages -= fsize;\n\t\t\t\tif (cache_nr_pages == 0)\n\t\t\t\t\tcheck_cache = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (open_file->invalidHandle) {\n\t\t\trc = cifs_reopen_file(open_file, true);\n\t\t\tif (rc) {\n\t\t\t\tif (rc == -EAGAIN)\n\t\t\t\t\tcontinue;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (cifs_sb->ctx->rsize == 0)\n\t\t\tcifs_sb->ctx->rsize =\n\t\t\t\tserver->ops->negotiate_rsize(tlink_tcon(open_file->tlink),\n\t\t\t\t\t\t\t     cifs_sb->ctx);\n\n\t\trc = server->ops->wait_mtu_credits(server, cifs_sb->ctx->rsize,\n\t\t\t\t\t\t   &rsize, credits);\n\t\tif (rc)\n\t\t\tbreak;\n\t\tnr_pages = min_t(size_t, rsize / PAGE_SIZE, ra_pages);\n\t\tif (next_cached != ULONG_MAX)\n\t\t\tnr_pages = min_t(size_t, nr_pages, next_cached - ra_index);\n\n\t\t \n\t\tif (unlikely(!nr_pages)) {\n\t\t\tadd_credits_and_wake_if(server, credits, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\trdata = cifs_readdata_alloc(cifs_readahead_complete);\n\t\tif (!rdata) {\n\t\t\t \n\t\t\tadd_credits_and_wake_if(server, credits, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\trdata->offset\t= ra_index * PAGE_SIZE;\n\t\trdata->bytes\t= nr_pages * PAGE_SIZE;\n\t\trdata->cfile\t= cifsFileInfo_get(open_file);\n\t\trdata->server\t= server;\n\t\trdata->mapping\t= ractl->mapping;\n\t\trdata->pid\t= pid;\n\t\trdata->credits\t= credits_on_stack;\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tif (!readahead_folio(ractl))\n\t\t\t\tWARN_ON(1);\n\t\t}\n\t\tra_pages -= nr_pages;\n\t\tra_index += nr_pages;\n\n\t\tiov_iter_xarray(&rdata->iter, ITER_DEST, &rdata->mapping->i_pages,\n\t\t\t\trdata->offset, rdata->bytes);\n\n\t\trc = adjust_credits(server, &rdata->credits, rdata->bytes);\n\t\tif (!rc) {\n\t\t\tif (rdata->cfile->invalidHandle)\n\t\t\t\trc = -EAGAIN;\n\t\t\telse\n\t\t\t\trc = server->ops->async_readv(rdata);\n\t\t}\n\n\t\tif (rc) {\n\t\t\tadd_credits_and_wake_if(server, &rdata->credits, 0);\n\t\t\tcifs_unlock_folios(rdata->mapping,\n\t\t\t\t\t   rdata->offset / PAGE_SIZE,\n\t\t\t\t\t   (rdata->offset + rdata->bytes - 1) / PAGE_SIZE);\n\t\t\t \n\t\t\tkref_put(&rdata->refcount, cifs_readdata_release);\n\t\t\tbreak;\n\t\t}\n\n\t\tkref_put(&rdata->refcount, cifs_readdata_release);\n\t}\n\n\tfree_xid(xid);\n}\n\n \nstatic int cifs_readpage_worker(struct file *file, struct page *page,\n\tloff_t *poffset)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct timespec64 atime, mtime;\n\tchar *read_data;\n\tint rc;\n\n\t \n\trc = cifs_readpage_from_fscache(inode, page);\n\tif (rc == 0)\n\t\tgoto read_complete;\n\n\tread_data = kmap(page);\n\t \n\n\trc = cifs_read(file, read_data, PAGE_SIZE, poffset);\n\n\tif (rc < 0)\n\t\tgoto io_error;\n\telse\n\t\tcifs_dbg(FYI, \"Bytes read %d\\n\", rc);\n\n\t \n\tatime = inode_set_atime_to_ts(inode, current_time(inode));\n\tmtime = inode_get_mtime(inode);\n\tif (timespec64_compare(&atime, &mtime) < 0)\n\t\tinode_set_atime_to_ts(inode, inode_get_mtime(inode));\n\n\tif (PAGE_SIZE > rc)\n\t\tmemset(read_data + rc, 0, PAGE_SIZE - rc);\n\n\tflush_dcache_page(page);\n\tSetPageUptodate(page);\n\trc = 0;\n\nio_error:\n\tkunmap(page);\n\nread_complete:\n\tunlock_page(page);\n\treturn rc;\n}\n\nstatic int cifs_read_folio(struct file *file, struct folio *folio)\n{\n\tstruct page *page = &folio->page;\n\tloff_t offset = page_file_offset(page);\n\tint rc = -EACCES;\n\tunsigned int xid;\n\n\txid = get_xid();\n\n\tif (file->private_data == NULL) {\n\t\trc = -EBADF;\n\t\tfree_xid(xid);\n\t\treturn rc;\n\t}\n\n\tcifs_dbg(FYI, \"read_folio %p at offset %d 0x%x\\n\",\n\t\t page, (int)offset, (int)offset);\n\n\trc = cifs_readpage_worker(file, page, &offset);\n\n\tfree_xid(xid);\n\treturn rc;\n}\n\nstatic int is_inode_writable(struct cifsInodeInfo *cifs_inode)\n{\n\tstruct cifsFileInfo *open_file;\n\n\tspin_lock(&cifs_inode->open_file_lock);\n\tlist_for_each_entry(open_file, &cifs_inode->openFileList, flist) {\n\t\tif (OPEN_FMODE(open_file->f_flags) & FMODE_WRITE) {\n\t\t\tspin_unlock(&cifs_inode->open_file_lock);\n\t\t\treturn 1;\n\t\t}\n\t}\n\tspin_unlock(&cifs_inode->open_file_lock);\n\treturn 0;\n}\n\n \nbool is_size_safe_to_change(struct cifsInodeInfo *cifsInode, __u64 end_of_file)\n{\n\tif (!cifsInode)\n\t\treturn true;\n\n\tif (is_inode_writable(cifsInode)) {\n\t\t \n\t\tstruct cifs_sb_info *cifs_sb;\n\n\t\tcifs_sb = CIFS_SB(cifsInode->netfs.inode.i_sb);\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DIRECT_IO) {\n\t\t\t \n\t\t\treturn true;\n\t\t}\n\n\t\tif (i_size_read(&cifsInode->netfs.inode) < end_of_file)\n\t\t\treturn true;\n\n\t\treturn false;\n\t} else\n\t\treturn true;\n}\n\nstatic int cifs_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len,\n\t\t\tstruct page **pagep, void **fsdata)\n{\n\tint oncethru = 0;\n\tpgoff_t index = pos >> PAGE_SHIFT;\n\tloff_t offset = pos & (PAGE_SIZE - 1);\n\tloff_t page_start = pos & PAGE_MASK;\n\tloff_t i_size;\n\tstruct page *page;\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"write_begin from %lld len %d\\n\", (long long)pos, len);\n\nstart:\n\tpage = grab_cache_page_write_begin(mapping, index);\n\tif (!page) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (PageUptodate(page))\n\t\tgoto out;\n\n\t \n\tif (len == PAGE_SIZE)\n\t\tgoto out;\n\n\t \n\tif (CIFS_CACHE_READ(CIFS_I(mapping->host))) {\n\t\ti_size = i_size_read(mapping->host);\n\t\tif (page_start >= i_size ||\n\t\t    (offset == 0 && (pos + len) >= i_size)) {\n\t\t\tzero_user_segments(page, 0, offset,\n\t\t\t\t\t   offset + len,\n\t\t\t\t\t   PAGE_SIZE);\n\t\t\t \n\t\t\tSetPageChecked(page);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif ((file->f_flags & O_ACCMODE) != O_WRONLY && !oncethru) {\n\t\t \n\t\tcifs_readpage_worker(file, page, &page_start);\n\t\tput_page(page);\n\t\toncethru = 1;\n\t\tgoto start;\n\t} else {\n\t\t \n\t}\nout:\n\t*pagep = page;\n\treturn rc;\n}\n\nstatic bool cifs_release_folio(struct folio *folio, gfp_t gfp)\n{\n\tif (folio_test_private(folio))\n\t\treturn 0;\n\tif (folio_test_fscache(folio)) {\n\t\tif (current_is_kswapd() || !(gfp & __GFP_FS))\n\t\t\treturn false;\n\t\tfolio_wait_fscache(folio);\n\t}\n\tfscache_note_page_release(cifs_inode_cookie(folio->mapping->host));\n\treturn true;\n}\n\nstatic void cifs_invalidate_folio(struct folio *folio, size_t offset,\n\t\t\t\t size_t length)\n{\n\tfolio_wait_fscache(folio);\n}\n\nstatic int cifs_launder_folio(struct folio *folio)\n{\n\tint rc = 0;\n\tloff_t range_start = folio_pos(folio);\n\tloff_t range_end = range_start + folio_size(folio);\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = WB_SYNC_ALL,\n\t\t.nr_to_write = 0,\n\t\t.range_start = range_start,\n\t\t.range_end = range_end,\n\t};\n\n\tcifs_dbg(FYI, \"Launder page: %lu\\n\", folio->index);\n\n\tif (folio_clear_dirty_for_io(folio))\n\t\trc = cifs_writepage_locked(&folio->page, &wbc);\n\n\tfolio_wait_fscache(folio);\n\treturn rc;\n}\n\nvoid cifs_oplock_break(struct work_struct *work)\n{\n\tstruct cifsFileInfo *cfile = container_of(work, struct cifsFileInfo,\n\t\t\t\t\t\t  oplock_break);\n\tstruct inode *inode = d_inode(cfile->dentry);\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct cifsInodeInfo *cinode = CIFS_I(inode);\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tstruct tcon_link *tlink;\n\tint rc = 0;\n\tbool purge_cache = false, oplock_break_cancelled;\n\t__u64 persistent_fid, volatile_fid;\n\t__u16 net_fid;\n\n\twait_on_bit(&cinode->flags, CIFS_INODE_PENDING_WRITERS,\n\t\t\tTASK_UNINTERRUPTIBLE);\n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink))\n\t\tgoto out;\n\ttcon = tlink_tcon(tlink);\n\tserver = tcon->ses->server;\n\n\tserver->ops->downgrade_oplock(server, cinode, cfile->oplock_level,\n\t\t\t\t      cfile->oplock_epoch, &purge_cache);\n\n\tif (!CIFS_CACHE_WRITE(cinode) && CIFS_CACHE_READ(cinode) &&\n\t\t\t\t\t\tcifs_has_mand_locks(cinode)) {\n\t\tcifs_dbg(FYI, \"Reset oplock to None for inode=%p due to mand locks\\n\",\n\t\t\t inode);\n\t\tcinode->oplock = 0;\n\t}\n\n\tif (inode && S_ISREG(inode->i_mode)) {\n\t\tif (CIFS_CACHE_READ(cinode))\n\t\t\tbreak_lease(inode, O_RDONLY);\n\t\telse\n\t\t\tbreak_lease(inode, O_WRONLY);\n\t\trc = filemap_fdatawrite(inode->i_mapping);\n\t\tif (!CIFS_CACHE_READ(cinode) || purge_cache) {\n\t\t\trc = filemap_fdatawait(inode->i_mapping);\n\t\t\tmapping_set_error(inode->i_mapping, rc);\n\t\t\tcifs_zap_mapping(inode);\n\t\t}\n\t\tcifs_dbg(FYI, \"Oplock flush inode %p rc %d\\n\", inode, rc);\n\t\tif (CIFS_CACHE_WRITE(cinode))\n\t\t\tgoto oplock_break_ack;\n\t}\n\n\trc = cifs_push_locks(cfile);\n\tif (rc)\n\t\tcifs_dbg(VFS, \"Push locks rc = %d\\n\", rc);\n\noplock_break_ack:\n\t \n\n\tif (!CIFS_CACHE_HANDLE(cinode) && !list_empty(&cinode->deferred_closes))\n\t\tcifs_close_deferred_file(cinode);\n\n\tpersistent_fid = cfile->fid.persistent_fid;\n\tvolatile_fid = cfile->fid.volatile_fid;\n\tnet_fid = cfile->fid.netfid;\n\toplock_break_cancelled = cfile->oplock_break_cancelled;\n\n\t_cifsFileInfo_put(cfile, false  , false);\n\t \n\tspin_lock(&cinode->open_file_lock);\n\t \n\tif (!oplock_break_cancelled && !list_empty(&cinode->openFileList)) {\n\t\tspin_unlock(&cinode->open_file_lock);\n\t\trc = server->ops->oplock_response(tcon, persistent_fid,\n\t\t\t\t\t\t  volatile_fid, net_fid, cinode);\n\t\tcifs_dbg(FYI, \"Oplock release rc = %d\\n\", rc);\n\t} else\n\t\tspin_unlock(&cinode->open_file_lock);\n\n\tcifs_put_tlink(tlink);\nout:\n\tcifs_done_oplock_break(cinode);\n}\n\n \nstatic ssize_t\ncifs_direct_io(struct kiocb *iocb, struct iov_iter *iter)\n{\n         \n        return -EINVAL;\n}\n\nstatic int cifs_swap_activate(struct swap_info_struct *sis,\n\t\t\t      struct file *swap_file, sector_t *span)\n{\n\tstruct cifsFileInfo *cfile = swap_file->private_data;\n\tstruct inode *inode = swap_file->f_mapping->host;\n\tunsigned long blocks;\n\tlong long isize;\n\n\tcifs_dbg(FYI, \"swap activate\\n\");\n\n\tif (!swap_file->f_mapping->a_ops->swap_rw)\n\t\t \n\t\treturn -EINVAL;\n\n\tspin_lock(&inode->i_lock);\n\tblocks = inode->i_blocks;\n\tisize = inode->i_size;\n\tspin_unlock(&inode->i_lock);\n\tif (blocks*512 < isize) {\n\t\tpr_warn(\"swap activate: swapfile has holes\\n\");\n\t\treturn -EINVAL;\n\t}\n\t*span = sis->pages;\n\n\tpr_warn_once(\"Swap support over SMB3 is experimental\\n\");\n\n\t \n\n\n\t \n\n\tif (cfile)\n\t\tcfile->swapfile = true;\n\t \n\n\tsis->flags |= SWP_FS_OPS;\n\treturn add_swap_extent(sis, 0, sis->max, 0);\n}\n\nstatic void cifs_swap_deactivate(struct file *file)\n{\n\tstruct cifsFileInfo *cfile = file->private_data;\n\n\tcifs_dbg(FYI, \"swap deactivate\\n\");\n\n\t \n\n\tif (cfile)\n\t\tcfile->swapfile = false;\n\n\t \n}\n\n \n#ifdef CONFIG_CIFS_FSCACHE\nstatic bool cifs_dirty_folio(struct address_space *mapping, struct folio *folio)\n{\n\treturn fscache_dirty_folio(mapping, folio,\n\t\t\t\t\tcifs_inode_cookie(mapping->host));\n}\n#else\n#define cifs_dirty_folio filemap_dirty_folio\n#endif\n\nconst struct address_space_operations cifs_addr_ops = {\n\t.read_folio = cifs_read_folio,\n\t.readahead = cifs_readahead,\n\t.writepages = cifs_writepages,\n\t.write_begin = cifs_write_begin,\n\t.write_end = cifs_write_end,\n\t.dirty_folio = cifs_dirty_folio,\n\t.release_folio = cifs_release_folio,\n\t.direct_IO = cifs_direct_io,\n\t.invalidate_folio = cifs_invalidate_folio,\n\t.launder_folio = cifs_launder_folio,\n\t.migrate_folio = filemap_migrate_folio,\n\t \n\t.swap_activate = cifs_swap_activate,\n\t.swap_deactivate = cifs_swap_deactivate,\n};\n\n \nconst struct address_space_operations cifs_addr_ops_smallbuf = {\n\t.read_folio = cifs_read_folio,\n\t.writepages = cifs_writepages,\n\t.write_begin = cifs_write_begin,\n\t.write_end = cifs_write_end,\n\t.dirty_folio = cifs_dirty_folio,\n\t.release_folio = cifs_release_folio,\n\t.invalidate_folio = cifs_invalidate_folio,\n\t.launder_folio = cifs_launder_folio,\n\t.migrate_folio = filemap_migrate_folio,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}