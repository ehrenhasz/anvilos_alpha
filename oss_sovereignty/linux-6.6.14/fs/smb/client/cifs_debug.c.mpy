{
  "module_name": "cifs_debug.c",
  "hash_id": "381c17f3a0c002cd8262c2f5510534738afb59de655ea6f7064e57e23bf327e3",
  "original_prompt": "Ingested from linux-6.6.14/fs/smb/client/cifs_debug.c",
  "human_readable_source": "\n \n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/kstrtox.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <uapi/linux/ethtool.h>\n#include \"cifspdu.h\"\n#include \"cifsglob.h\"\n#include \"cifsproto.h\"\n#include \"cifs_debug.h\"\n#include \"cifsfs.h\"\n#include \"fs_context.h\"\n#ifdef CONFIG_CIFS_DFS_UPCALL\n#include \"dfs_cache.h\"\n#endif\n#ifdef CONFIG_CIFS_SMB_DIRECT\n#include \"smbdirect.h\"\n#endif\n#include \"cifs_swn.h\"\n\nvoid\ncifs_dump_mem(char *label, void *data, int length)\n{\n\tpr_debug(\"%s: dump of %d bytes of data at 0x%p\\n\", label, length, data);\n\tprint_hex_dump(KERN_DEBUG, \"\", DUMP_PREFIX_OFFSET, 16, 4,\n\t\t       data, length, true);\n}\n\nvoid cifs_dump_detail(void *buf, struct TCP_Server_Info *server)\n{\n#ifdef CONFIG_CIFS_DEBUG2\n\tstruct smb_hdr *smb = buf;\n\n\tcifs_dbg(VFS, \"Cmd: %d Err: 0x%x Flags: 0x%x Flgs2: 0x%x Mid: %d Pid: %d Wct: %d\\n\",\n\t\t smb->Command, smb->Status.CifsError, smb->Flags,\n\t\t smb->Flags2, smb->Mid, smb->Pid, smb->WordCount);\n\tif (!server->ops->check_message(buf, server->total_read, server)) {\n\t\tcifs_dbg(VFS, \"smb buf %p len %u\\n\", smb,\n\t\t\t server->ops->calc_smb_size(smb));\n\t}\n#endif  \n}\n\nvoid cifs_dump_mids(struct TCP_Server_Info *server)\n{\n#ifdef CONFIG_CIFS_DEBUG2\n\tstruct mid_q_entry *mid_entry;\n\n\tif (server == NULL)\n\t\treturn;\n\n\tcifs_dbg(VFS, \"Dump pending requests:\\n\");\n\tspin_lock(&server->mid_lock);\n\tlist_for_each_entry(mid_entry, &server->pending_mid_q, qhead) {\n\t\tcifs_dbg(VFS, \"State: %d Cmd: %d Pid: %d Cbdata: %p Mid %llu\\n\",\n\t\t\t mid_entry->mid_state,\n\t\t\t le16_to_cpu(mid_entry->command),\n\t\t\t mid_entry->pid,\n\t\t\t mid_entry->callback_data,\n\t\t\t mid_entry->mid);\n#ifdef CONFIG_CIFS_STATS2\n\t\tcifs_dbg(VFS, \"IsLarge: %d buf: %p time rcv: %ld now: %ld\\n\",\n\t\t\t mid_entry->large_buf,\n\t\t\t mid_entry->resp_buf,\n\t\t\t mid_entry->when_received,\n\t\t\t jiffies);\n#endif  \n\t\tcifs_dbg(VFS, \"IsMult: %d IsEnd: %d\\n\",\n\t\t\t mid_entry->multiRsp, mid_entry->multiEnd);\n\t\tif (mid_entry->resp_buf) {\n\t\t\tcifs_dump_detail(mid_entry->resp_buf, server);\n\t\t\tcifs_dump_mem(\"existing buf: \",\n\t\t\t\tmid_entry->resp_buf, 62);\n\t\t}\n\t}\n\tspin_unlock(&server->mid_lock);\n#endif  \n}\n\n#ifdef CONFIG_PROC_FS\nstatic void cifs_debug_tcon(struct seq_file *m, struct cifs_tcon *tcon)\n{\n\t__u32 dev_type = le32_to_cpu(tcon->fsDevInfo.DeviceType);\n\n\tseq_printf(m, \"%s Mounts: %d \", tcon->tree_name, tcon->tc_count);\n\tif (tcon->nativeFileSystem)\n\t\tseq_printf(m, \"Type: %s \", tcon->nativeFileSystem);\n\tseq_printf(m, \"DevInfo: 0x%x Attributes: 0x%x\\n\\tPathComponentMax: %d Status: %d\",\n\t\t   le32_to_cpu(tcon->fsDevInfo.DeviceCharacteristics),\n\t\t   le32_to_cpu(tcon->fsAttrInfo.Attributes),\n\t\t   le32_to_cpu(tcon->fsAttrInfo.MaxPathNameComponentLength),\n\t\t   tcon->status);\n\tif (dev_type == FILE_DEVICE_DISK)\n\t\tseq_puts(m, \" type: DISK \");\n\telse if (dev_type == FILE_DEVICE_CD_ROM)\n\t\tseq_puts(m, \" type: CDROM \");\n\telse\n\t\tseq_printf(m, \" type: %d \", dev_type);\n\n\tseq_printf(m, \"Serial Number: 0x%x\", tcon->vol_serial_number);\n\n\tif ((tcon->seal) ||\n\t    (tcon->ses->session_flags & SMB2_SESSION_FLAG_ENCRYPT_DATA) ||\n\t    (tcon->share_flags & SHI1005_FLAGS_ENCRYPT_DATA))\n\t\tseq_puts(m, \" encrypted\");\n\tif (tcon->nocase)\n\t\tseq_printf(m, \" nocase\");\n\tif (tcon->unix_ext)\n\t\tseq_printf(m, \" POSIX Extensions\");\n\tif (tcon->ses->server->ops->dump_share_caps)\n\t\ttcon->ses->server->ops->dump_share_caps(m, tcon);\n\tif (tcon->use_witness)\n\t\tseq_puts(m, \" Witness\");\n\tif (tcon->broken_sparse_sup)\n\t\tseq_puts(m, \" nosparse\");\n\tif (tcon->need_reconnect)\n\t\tseq_puts(m, \"\\tDISCONNECTED \");\n\tspin_lock(&tcon->tc_lock);\n\tif (tcon->origin_fullpath) {\n\t\tseq_printf(m, \"\\n\\tDFS origin fullpath: %s\",\n\t\t\t   tcon->origin_fullpath);\n\t}\n\tspin_unlock(&tcon->tc_lock);\n\tseq_putc(m, '\\n');\n}\n\nstatic void\ncifs_dump_channel(struct seq_file *m, int i, struct cifs_chan *chan)\n{\n\tstruct TCP_Server_Info *server = chan->server;\n\n\tseq_printf(m, \"\\n\\n\\t\\tChannel: %d ConnectionId: 0x%llx\"\n\t\t   \"\\n\\t\\tNumber of credits: %d,%d,%d Dialect 0x%x\"\n\t\t   \"\\n\\t\\tTCP status: %d Instance: %d\"\n\t\t   \"\\n\\t\\tLocal Users To Server: %d SecMode: 0x%x Req On Wire: %d\"\n\t\t   \"\\n\\t\\tIn Send: %d In MaxReq Wait: %d\",\n\t\t   i+1, server->conn_id,\n\t\t   server->credits,\n\t\t   server->echo_credits,\n\t\t   server->oplock_credits,\n\t\t   server->dialect,\n\t\t   server->tcpStatus,\n\t\t   server->reconnect_instance,\n\t\t   server->srv_count,\n\t\t   server->sec_mode,\n\t\t   in_flight(server),\n\t\t   atomic_read(&server->in_send),\n\t\t   atomic_read(&server->num_waiters));\n#ifdef CONFIG_NET_NS\n\tif (server->net)\n\t\tseq_printf(m, \" Net namespace: %u \", server->net->ns.inum);\n#endif  \n\n}\n\nstatic inline const char *smb_speed_to_str(size_t bps)\n{\n\tsize_t mbps = bps / 1000 / 1000;\n\n\tswitch (mbps) {\n\tcase SPEED_10:\n\t\treturn \"10Mbps\";\n\tcase SPEED_100:\n\t\treturn \"100Mbps\";\n\tcase SPEED_1000:\n\t\treturn \"1Gbps\";\n\tcase SPEED_2500:\n\t\treturn \"2.5Gbps\";\n\tcase SPEED_5000:\n\t\treturn \"5Gbps\";\n\tcase SPEED_10000:\n\t\treturn \"10Gbps\";\n\tcase SPEED_14000:\n\t\treturn \"14Gbps\";\n\tcase SPEED_20000:\n\t\treturn \"20Gbps\";\n\tcase SPEED_25000:\n\t\treturn \"25Gbps\";\n\tcase SPEED_40000:\n\t\treturn \"40Gbps\";\n\tcase SPEED_50000:\n\t\treturn \"50Gbps\";\n\tcase SPEED_56000:\n\t\treturn \"56Gbps\";\n\tcase SPEED_100000:\n\t\treturn \"100Gbps\";\n\tcase SPEED_200000:\n\t\treturn \"200Gbps\";\n\tcase SPEED_400000:\n\t\treturn \"400Gbps\";\n\tcase SPEED_800000:\n\t\treturn \"800Gbps\";\n\tdefault:\n\t\treturn \"Unknown\";\n\t}\n}\n\nstatic void\ncifs_dump_iface(struct seq_file *m, struct cifs_server_iface *iface)\n{\n\tstruct sockaddr_in *ipv4 = (struct sockaddr_in *)&iface->sockaddr;\n\tstruct sockaddr_in6 *ipv6 = (struct sockaddr_in6 *)&iface->sockaddr;\n\n\tseq_printf(m, \"\\tSpeed: %s\\n\", smb_speed_to_str(iface->speed));\n\tseq_puts(m, \"\\t\\tCapabilities: \");\n\tif (iface->rdma_capable)\n\t\tseq_puts(m, \"rdma \");\n\tif (iface->rss_capable)\n\t\tseq_puts(m, \"rss \");\n\tif (!iface->rdma_capable && !iface->rss_capable)\n\t\tseq_puts(m, \"None\");\n\tseq_putc(m, '\\n');\n\tif (iface->sockaddr.ss_family == AF_INET)\n\t\tseq_printf(m, \"\\t\\tIPv4: %pI4\\n\", &ipv4->sin_addr);\n\telse if (iface->sockaddr.ss_family == AF_INET6)\n\t\tseq_printf(m, \"\\t\\tIPv6: %pI6\\n\", &ipv6->sin6_addr);\n\tif (!iface->is_active)\n\t\tseq_puts(m, \"\\t\\t[for-cleanup]\\n\");\n}\n\nstatic int cifs_debug_files_proc_show(struct seq_file *m, void *v)\n{\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses;\n\tstruct cifs_tcon *tcon;\n\tstruct cifsFileInfo *cfile;\n\n\tseq_puts(m, \"# Version:1\\n\");\n\tseq_puts(m, \"# Format:\\n\");\n\tseq_puts(m, \"# <tree id> <ses id> <persistent fid> <flags> <count> <pid> <uid>\");\n#ifdef CONFIG_CIFS_DEBUG2\n\tseq_printf(m, \" <filename> <mid>\\n\");\n#else\n\tseq_printf(m, \" <filename>\\n\");\n#endif  \n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each_entry(server, &cifs_tcp_ses_list, tcp_ses_list) {\n\t\tlist_for_each_entry(ses, &server->smb_ses_list, smb_ses_list) {\n\t\t\tlist_for_each_entry(tcon, &ses->tcon_list, tcon_list) {\n\t\t\t\tspin_lock(&tcon->open_file_lock);\n\t\t\t\tlist_for_each_entry(cfile, &tcon->openFileList, tlist) {\n\t\t\t\t\tseq_printf(m,\n\t\t\t\t\t\t\"0x%x 0x%llx 0x%llx 0x%x %d %d %d %pd\",\n\t\t\t\t\t\ttcon->tid,\n\t\t\t\t\t\tses->Suid,\n\t\t\t\t\t\tcfile->fid.persistent_fid,\n\t\t\t\t\t\tcfile->f_flags,\n\t\t\t\t\t\tcfile->count,\n\t\t\t\t\t\tcfile->pid,\n\t\t\t\t\t\tfrom_kuid(&init_user_ns, cfile->uid),\n\t\t\t\t\t\tcfile->dentry);\n#ifdef CONFIG_CIFS_DEBUG2\n\t\t\t\t\tseq_printf(m, \" %llu\\n\", cfile->fid.mid);\n#else\n\t\t\t\t\tseq_printf(m, \"\\n\");\n#endif  \n\t\t\t\t}\n\t\t\t\tspin_unlock(&tcon->open_file_lock);\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\tseq_putc(m, '\\n');\n\treturn 0;\n}\n\nstatic int cifs_debug_data_proc_show(struct seq_file *m, void *v)\n{\n\tstruct mid_q_entry *mid_entry;\n\tstruct TCP_Server_Info *server;\n\tstruct TCP_Server_Info *chan_server;\n\tstruct cifs_ses *ses;\n\tstruct cifs_tcon *tcon;\n\tstruct cifs_server_iface *iface;\n\tsize_t iface_weight = 0, iface_min_speed = 0;\n\tstruct cifs_server_iface *last_iface = NULL;\n\tint c, i, j;\n\n\tseq_puts(m,\n\t\t    \"Display Internal CIFS Data Structures for Debugging\\n\"\n\t\t    \"---------------------------------------------------\\n\");\n\tseq_printf(m, \"CIFS Version %s\\n\", CIFS_VERSION);\n\tseq_printf(m, \"Features:\");\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\tseq_printf(m, \" DFS\");\n#endif\n#ifdef CONFIG_CIFS_FSCACHE\n\tseq_printf(m, \",FSCACHE\");\n#endif\n#ifdef CONFIG_CIFS_SMB_DIRECT\n\tseq_printf(m, \",SMB_DIRECT\");\n#endif\n#ifdef CONFIG_CIFS_STATS2\n\tseq_printf(m, \",STATS2\");\n#else\n\tseq_printf(m, \",STATS\");\n#endif\n#ifdef CONFIG_CIFS_DEBUG2\n\tseq_printf(m, \",DEBUG2\");\n#elif defined(CONFIG_CIFS_DEBUG)\n\tseq_printf(m, \",DEBUG\");\n#endif\n#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY\n\tseq_printf(m, \",ALLOW_INSECURE_LEGACY\");\n#endif\n#ifdef CONFIG_CIFS_POSIX\n\tseq_printf(m, \",CIFS_POSIX\");\n#endif\n#ifdef CONFIG_CIFS_UPCALL\n\tseq_printf(m, \",UPCALL(SPNEGO)\");\n#endif\n#ifdef CONFIG_CIFS_XATTR\n\tseq_printf(m, \",XATTR\");\n#endif\n\tseq_printf(m, \",ACL\");\n#ifdef CONFIG_CIFS_SWN_UPCALL\n\tseq_puts(m, \",WITNESS\");\n#endif\n\tseq_putc(m, '\\n');\n\tseq_printf(m, \"CIFSMaxBufSize: %d\\n\", CIFSMaxBufSize);\n\tseq_printf(m, \"Active VFS Requests: %d\\n\", GlobalTotalActiveXid);\n\n\tseq_printf(m, \"\\nServers: \");\n\n\tc = 0;\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each_entry(server, &cifs_tcp_ses_list, tcp_ses_list) {\n\t\t \n\t\tif (SERVER_IS_CHAN(server))\n\t\t\tcontinue;\n\n\t\tc++;\n\t\tseq_printf(m, \"\\n%d) ConnectionId: 0x%llx \",\n\t\t\tc, server->conn_id);\n\n\t\tspin_lock(&server->srv_lock);\n\t\tif (server->hostname)\n\t\t\tseq_printf(m, \"Hostname: %s \", server->hostname);\n\t\tseq_printf(m, \"\\nClientGUID: %pUL\", server->client_guid);\n\t\tspin_unlock(&server->srv_lock);\n#ifdef CONFIG_CIFS_SMB_DIRECT\n\t\tif (!server->rdma)\n\t\t\tgoto skip_rdma;\n\n\t\tif (!server->smbd_conn) {\n\t\t\tseq_printf(m, \"\\nSMBDirect transport not available\");\n\t\t\tgoto skip_rdma;\n\t\t}\n\n\t\tseq_printf(m, \"\\nSMBDirect (in hex) protocol version: %x \"\n\t\t\t\"transport status: %x\",\n\t\t\tserver->smbd_conn->protocol,\n\t\t\tserver->smbd_conn->transport_status);\n\t\tseq_printf(m, \"\\nConn receive_credit_max: %x \"\n\t\t\t\"send_credit_target: %x max_send_size: %x\",\n\t\t\tserver->smbd_conn->receive_credit_max,\n\t\t\tserver->smbd_conn->send_credit_target,\n\t\t\tserver->smbd_conn->max_send_size);\n\t\tseq_printf(m, \"\\nConn max_fragmented_recv_size: %x \"\n\t\t\t\"max_fragmented_send_size: %x max_receive_size:%x\",\n\t\t\tserver->smbd_conn->max_fragmented_recv_size,\n\t\t\tserver->smbd_conn->max_fragmented_send_size,\n\t\t\tserver->smbd_conn->max_receive_size);\n\t\tseq_printf(m, \"\\nConn keep_alive_interval: %x \"\n\t\t\t\"max_readwrite_size: %x rdma_readwrite_threshold: %x\",\n\t\t\tserver->smbd_conn->keep_alive_interval,\n\t\t\tserver->smbd_conn->max_readwrite_size,\n\t\t\tserver->smbd_conn->rdma_readwrite_threshold);\n\t\tseq_printf(m, \"\\nDebug count_get_receive_buffer: %x \"\n\t\t\t\"count_put_receive_buffer: %x count_send_empty: %x\",\n\t\t\tserver->smbd_conn->count_get_receive_buffer,\n\t\t\tserver->smbd_conn->count_put_receive_buffer,\n\t\t\tserver->smbd_conn->count_send_empty);\n\t\tseq_printf(m, \"\\nRead Queue count_reassembly_queue: %x \"\n\t\t\t\"count_enqueue_reassembly_queue: %x \"\n\t\t\t\"count_dequeue_reassembly_queue: %x \"\n\t\t\t\"fragment_reassembly_remaining: %x \"\n\t\t\t\"reassembly_data_length: %x \"\n\t\t\t\"reassembly_queue_length: %x\",\n\t\t\tserver->smbd_conn->count_reassembly_queue,\n\t\t\tserver->smbd_conn->count_enqueue_reassembly_queue,\n\t\t\tserver->smbd_conn->count_dequeue_reassembly_queue,\n\t\t\tserver->smbd_conn->fragment_reassembly_remaining,\n\t\t\tserver->smbd_conn->reassembly_data_length,\n\t\t\tserver->smbd_conn->reassembly_queue_length);\n\t\tseq_printf(m, \"\\nCurrent Credits send_credits: %x \"\n\t\t\t\"receive_credits: %x receive_credit_target: %x\",\n\t\t\tatomic_read(&server->smbd_conn->send_credits),\n\t\t\tatomic_read(&server->smbd_conn->receive_credits),\n\t\t\tserver->smbd_conn->receive_credit_target);\n\t\tseq_printf(m, \"\\nPending send_pending: %x \",\n\t\t\tatomic_read(&server->smbd_conn->send_pending));\n\t\tseq_printf(m, \"\\nReceive buffers count_receive_queue: %x \"\n\t\t\t\"count_empty_packet_queue: %x\",\n\t\t\tserver->smbd_conn->count_receive_queue,\n\t\t\tserver->smbd_conn->count_empty_packet_queue);\n\t\tseq_printf(m, \"\\nMR responder_resources: %x \"\n\t\t\t\"max_frmr_depth: %x mr_type: %x\",\n\t\t\tserver->smbd_conn->responder_resources,\n\t\t\tserver->smbd_conn->max_frmr_depth,\n\t\t\tserver->smbd_conn->mr_type);\n\t\tseq_printf(m, \"\\nMR mr_ready_count: %x mr_used_count: %x\",\n\t\t\tatomic_read(&server->smbd_conn->mr_ready_count),\n\t\t\tatomic_read(&server->smbd_conn->mr_used_count));\nskip_rdma:\n#endif\n\t\tseq_printf(m, \"\\nNumber of credits: %d,%d,%d Dialect 0x%x\",\n\t\t\tserver->credits,\n\t\t\tserver->echo_credits,\n\t\t\tserver->oplock_credits,\n\t\t\tserver->dialect);\n\t\tif (server->compress_algorithm == SMB3_COMPRESS_LZNT1)\n\t\t\tseq_printf(m, \" COMPRESS_LZNT1\");\n\t\telse if (server->compress_algorithm == SMB3_COMPRESS_LZ77)\n\t\t\tseq_printf(m, \" COMPRESS_LZ77\");\n\t\telse if (server->compress_algorithm == SMB3_COMPRESS_LZ77_HUFF)\n\t\t\tseq_printf(m, \" COMPRESS_LZ77_HUFF\");\n\t\tif (server->sign)\n\t\t\tseq_printf(m, \" signed\");\n\t\tif (server->posix_ext_supported)\n\t\t\tseq_printf(m, \" posix\");\n\t\tif (server->nosharesock)\n\t\t\tseq_printf(m, \" nosharesock\");\n\n\t\tif (server->rdma)\n\t\t\tseq_printf(m, \"\\nRDMA \");\n\t\tseq_printf(m, \"\\nTCP status: %d Instance: %d\"\n\t\t\t\t\"\\nLocal Users To Server: %d SecMode: 0x%x Req On Wire: %d\",\n\t\t\t\tserver->tcpStatus,\n\t\t\t\tserver->reconnect_instance,\n\t\t\t\tserver->srv_count,\n\t\t\t\tserver->sec_mode, in_flight(server));\n#ifdef CONFIG_NET_NS\n\t\tif (server->net)\n\t\t\tseq_printf(m, \" Net namespace: %u \", server->net->ns.inum);\n#endif  \n\n\t\tseq_printf(m, \"\\nIn Send: %d In MaxReq Wait: %d\",\n\t\t\t\tatomic_read(&server->in_send),\n\t\t\t\tatomic_read(&server->num_waiters));\n\n\t\tif (server->leaf_fullpath) {\n\t\t\tseq_printf(m, \"\\nDFS leaf full path: %s\",\n\t\t\t\t   server->leaf_fullpath);\n\t\t}\n\n\t\tseq_printf(m, \"\\n\\n\\tSessions: \");\n\t\ti = 0;\n\t\tlist_for_each_entry(ses, &server->smb_ses_list, smb_ses_list) {\n\t\t\tspin_lock(&ses->ses_lock);\n\t\t\tif (ses->ses_status == SES_EXITING) {\n\t\t\t\tspin_unlock(&ses->ses_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ti++;\n\t\t\tif ((ses->serverDomain == NULL) ||\n\t\t\t\t(ses->serverOS == NULL) ||\n\t\t\t\t(ses->serverNOS == NULL)) {\n\t\t\t\tseq_printf(m, \"\\n\\t%d) Address: %s Uses: %d Capability: 0x%x\\tSession Status: %d \",\n\t\t\t\t\ti, ses->ip_addr, ses->ses_count,\n\t\t\t\t\tses->capabilities, ses->ses_status);\n\t\t\t\tif (ses->session_flags & SMB2_SESSION_FLAG_IS_GUEST)\n\t\t\t\t\tseq_printf(m, \"Guest \");\n\t\t\t\telse if (ses->session_flags & SMB2_SESSION_FLAG_IS_NULL)\n\t\t\t\t\tseq_printf(m, \"Anonymous \");\n\t\t\t} else {\n\t\t\t\tseq_printf(m,\n\t\t\t\t    \"\\n\\t%d) Name: %s  Domain: %s Uses: %d OS: %s \"\n\t\t\t\t    \"\\n\\tNOS: %s\\tCapability: 0x%x\"\n\t\t\t\t\t\"\\n\\tSMB session status: %d \",\n\t\t\t\ti, ses->ip_addr, ses->serverDomain,\n\t\t\t\tses->ses_count, ses->serverOS, ses->serverNOS,\n\t\t\t\tses->capabilities, ses->ses_status);\n\t\t\t}\n\t\t\tspin_unlock(&ses->ses_lock);\n\n\t\t\tseq_printf(m, \"\\n\\tSecurity type: %s \",\n\t\t\t\tget_security_type_str(server->ops->select_sectype(server, ses->sectype)));\n\n\t\t\t \n\t\t\tseq_printf(m, \" SessionId: 0x%llx\", ses->Suid);\n\t\t\tif (ses->session_flags & SMB2_SESSION_FLAG_ENCRYPT_DATA) {\n\t\t\t\tseq_puts(m, \" encrypted\");\n\t\t\t\t \n\t\t\t\tif (server->cipher_type == SMB2_ENCRYPTION_AES256_GCM)\n\t\t\t\t\tseq_puts(m, \"(gcm256)\");\n\t\t\t}\n\t\t\tif (ses->sign)\n\t\t\t\tseq_puts(m, \" signed\");\n\n\t\t\tseq_printf(m, \"\\n\\tUser: %d Cred User: %d\",\n\t\t\t\t   from_kuid(&init_user_ns, ses->linux_uid),\n\t\t\t\t   from_kuid(&init_user_ns, ses->cred_uid));\n\n\t\t\tif (ses->dfs_root_ses) {\n\t\t\t\tseq_printf(m, \"\\n\\tDFS root session id: 0x%llx\",\n\t\t\t\t\t   ses->dfs_root_ses->Suid);\n\t\t\t}\n\n\t\t\tspin_lock(&ses->chan_lock);\n\t\t\tif (CIFS_CHAN_NEEDS_RECONNECT(ses, 0))\n\t\t\t\tseq_puts(m, \"\\tPrimary channel: DISCONNECTED \");\n\t\t\tif (CIFS_CHAN_IN_RECONNECT(ses, 0))\n\t\t\t\tseq_puts(m, \"\\t[RECONNECTING] \");\n\n\t\t\tif (ses->chan_count > 1) {\n\t\t\t\tseq_printf(m, \"\\n\\n\\tExtra Channels: %zu \",\n\t\t\t\t\t   ses->chan_count-1);\n\t\t\t\tfor (j = 1; j < ses->chan_count; j++) {\n\t\t\t\t\tcifs_dump_channel(m, j, &ses->chans[j]);\n\t\t\t\t\tif (CIFS_CHAN_NEEDS_RECONNECT(ses, j))\n\t\t\t\t\t\tseq_puts(m, \"\\tDISCONNECTED \");\n\t\t\t\t\tif (CIFS_CHAN_IN_RECONNECT(ses, j))\n\t\t\t\t\t\tseq_puts(m, \"\\t[RECONNECTING] \");\n\t\t\t\t}\n\t\t\t}\n\t\t\tspin_unlock(&ses->chan_lock);\n\n\t\t\tseq_puts(m, \"\\n\\n\\tShares: \");\n\t\t\tj = 0;\n\n\t\t\tseq_printf(m, \"\\n\\t%d) IPC: \", j);\n\t\t\tif (ses->tcon_ipc)\n\t\t\t\tcifs_debug_tcon(m, ses->tcon_ipc);\n\t\t\telse\n\t\t\t\tseq_puts(m, \"none\\n\");\n\n\t\t\tlist_for_each_entry(tcon, &ses->tcon_list, tcon_list) {\n\t\t\t\t++j;\n\t\t\t\tseq_printf(m, \"\\n\\t%d) \", j);\n\t\t\t\tcifs_debug_tcon(m, tcon);\n\t\t\t}\n\n\t\t\tspin_lock(&ses->iface_lock);\n\t\t\tif (ses->iface_count)\n\t\t\t\tseq_printf(m, \"\\n\\n\\tServer interfaces: %zu\"\n\t\t\t\t\t   \"\\tLast updated: %lu seconds ago\",\n\t\t\t\t\t   ses->iface_count,\n\t\t\t\t\t   (jiffies - ses->iface_last_update) / HZ);\n\n\t\t\tlast_iface = list_last_entry(&ses->iface_list,\n\t\t\t\t\t\t     struct cifs_server_iface,\n\t\t\t\t\t\t     iface_head);\n\t\t\tiface_min_speed = last_iface->speed;\n\n\t\t\tj = 0;\n\t\t\tlist_for_each_entry(iface, &ses->iface_list,\n\t\t\t\t\t\t iface_head) {\n\t\t\t\tseq_printf(m, \"\\n\\t%d)\", ++j);\n\t\t\t\tcifs_dump_iface(m, iface);\n\n\t\t\t\tiface_weight = iface->speed / iface_min_speed;\n\t\t\t\tseq_printf(m, \"\\t\\tWeight (cur,total): (%zu,%zu)\"\n\t\t\t\t\t   \"\\n\\t\\tAllocated channels: %u\\n\",\n\t\t\t\t\t   iface->weight_fulfilled,\n\t\t\t\t\t   iface_weight,\n\t\t\t\t\t   iface->num_channels);\n\n\t\t\t\tif (is_ses_using_iface(ses, iface))\n\t\t\t\t\tseq_puts(m, \"\\t\\t[CONNECTED]\\n\");\n\t\t\t}\n\t\t\tspin_unlock(&ses->iface_lock);\n\n\t\t\tseq_puts(m, \"\\n\\n\\tMIDs: \");\n\t\t\tspin_lock(&ses->chan_lock);\n\t\t\tfor (j = 0; j < ses->chan_count; j++) {\n\t\t\t\tchan_server = ses->chans[j].server;\n\t\t\t\tif (!chan_server)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (list_empty(&chan_server->pending_mid_q))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tseq_printf(m, \"\\n\\tServer ConnectionId: 0x%llx\",\n\t\t\t\t\t   chan_server->conn_id);\n\t\t\t\tspin_lock(&chan_server->mid_lock);\n\t\t\t\tlist_for_each_entry(mid_entry, &chan_server->pending_mid_q, qhead) {\n\t\t\t\t\tseq_printf(m, \"\\n\\t\\tState: %d com: %d pid: %d cbdata: %p mid %llu\",\n\t\t\t\t\t\t   mid_entry->mid_state,\n\t\t\t\t\t\t   le16_to_cpu(mid_entry->command),\n\t\t\t\t\t\t   mid_entry->pid,\n\t\t\t\t\t\t   mid_entry->callback_data,\n\t\t\t\t\t\t   mid_entry->mid);\n\t\t\t\t}\n\t\t\t\tspin_unlock(&chan_server->mid_lock);\n\t\t\t}\n\t\t\tspin_unlock(&ses->chan_lock);\n\t\t\tseq_puts(m, \"\\n--\\n\");\n\t\t}\n\t\tif (i == 0)\n\t\t\tseq_printf(m, \"\\n\\t\\t[NONE]\");\n\t}\n\tif (c == 0)\n\t\tseq_printf(m, \"\\n\\t[NONE]\");\n\n\tspin_unlock(&cifs_tcp_ses_lock);\n\tseq_putc(m, '\\n');\n\tcifs_swn_dump(m);\n\n\t \n\treturn 0;\n}\n\nstatic ssize_t cifs_stats_proc_write(struct file *file,\n\t\tconst char __user *buffer, size_t count, loff_t *ppos)\n{\n\tbool bv;\n\tint rc;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses;\n\tstruct cifs_tcon *tcon;\n\n\trc = kstrtobool_from_user(buffer, count, &bv);\n\tif (rc == 0) {\n#ifdef CONFIG_CIFS_STATS2\n\t\tint i;\n\n\t\tatomic_set(&total_buf_alloc_count, 0);\n\t\tatomic_set(&total_small_buf_alloc_count, 0);\n#endif  \n\t\tatomic_set(&tcpSesReconnectCount, 0);\n\t\tatomic_set(&tconInfoReconnectCount, 0);\n\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tGlobalMaxActiveXid = 0;\n\t\tGlobalCurrentXid = 0;\n\t\tspin_unlock(&GlobalMid_Lock);\n\t\tspin_lock(&cifs_tcp_ses_lock);\n\t\tlist_for_each_entry(server, &cifs_tcp_ses_list, tcp_ses_list) {\n\t\t\tserver->max_in_flight = 0;\n#ifdef CONFIG_CIFS_STATS2\n\t\t\tfor (i = 0; i < NUMBER_OF_SMB2_COMMANDS; i++) {\n\t\t\t\tatomic_set(&server->num_cmds[i], 0);\n\t\t\t\tatomic_set(&server->smb2slowcmd[i], 0);\n\t\t\t\tserver->time_per_cmd[i] = 0;\n\t\t\t\tserver->slowest_cmd[i] = 0;\n\t\t\t\tserver->fastest_cmd[0] = 0;\n\t\t\t}\n#endif  \n\t\t\tlist_for_each_entry(ses, &server->smb_ses_list, smb_ses_list) {\n\t\t\t\tlist_for_each_entry(tcon, &ses->tcon_list, tcon_list) {\n\t\t\t\t\tatomic_set(&tcon->num_smbs_sent, 0);\n\t\t\t\t\tspin_lock(&tcon->stat_lock);\n\t\t\t\t\ttcon->bytes_read = 0;\n\t\t\t\t\ttcon->bytes_written = 0;\n\t\t\t\t\tspin_unlock(&tcon->stat_lock);\n\t\t\t\t\tif (server->ops->clear_stats)\n\t\t\t\t\t\tserver->ops->clear_stats(tcon);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t} else {\n\t\treturn rc;\n\t}\n\n\treturn count;\n}\n\nstatic int cifs_stats_proc_show(struct seq_file *m, void *v)\n{\n\tint i;\n#ifdef CONFIG_CIFS_STATS2\n\tint j;\n#endif  \n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses;\n\tstruct cifs_tcon *tcon;\n\n\tseq_printf(m, \"Resources in use\\nCIFS Session: %d\\n\",\n\t\t\tsesInfoAllocCount.counter);\n\tseq_printf(m, \"Share (unique mount targets): %d\\n\",\n\t\t\ttconInfoAllocCount.counter);\n\tseq_printf(m, \"SMB Request/Response Buffer: %d Pool size: %d\\n\",\n\t\t\tbuf_alloc_count.counter,\n\t\t\tcifs_min_rcv + tcpSesAllocCount.counter);\n\tseq_printf(m, \"SMB Small Req/Resp Buffer: %d Pool size: %d\\n\",\n\t\t\tsmall_buf_alloc_count.counter, cifs_min_small);\n#ifdef CONFIG_CIFS_STATS2\n\tseq_printf(m, \"Total Large %d Small %d Allocations\\n\",\n\t\t\t\tatomic_read(&total_buf_alloc_count),\n\t\t\t\tatomic_read(&total_small_buf_alloc_count));\n#endif  \n\n\tseq_printf(m, \"Operations (MIDs): %d\\n\", atomic_read(&mid_count));\n\tseq_printf(m,\n\t\t\"\\n%d session %d share reconnects\\n\",\n\t\ttcpSesReconnectCount.counter, tconInfoReconnectCount.counter);\n\n\tseq_printf(m,\n\t\t\"Total vfs operations: %d maximum at one time: %d\\n\",\n\t\tGlobalCurrentXid, GlobalMaxActiveXid);\n\n\ti = 0;\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each_entry(server, &cifs_tcp_ses_list, tcp_ses_list) {\n\t\tseq_printf(m, \"\\nMax requests in flight: %d\", server->max_in_flight);\n#ifdef CONFIG_CIFS_STATS2\n\t\tseq_puts(m, \"\\nTotal time spent processing by command. Time \");\n\t\tseq_printf(m, \"units are jiffies (%d per second)\\n\", HZ);\n\t\tseq_puts(m, \"  SMB3 CMD\\tNumber\\tTotal Time\\tFastest\\tSlowest\\n\");\n\t\tseq_puts(m, \"  --------\\t------\\t----------\\t-------\\t-------\\n\");\n\t\tfor (j = 0; j < NUMBER_OF_SMB2_COMMANDS; j++)\n\t\t\tseq_printf(m, \"  %d\\t\\t%d\\t%llu\\t\\t%u\\t%u\\n\", j,\n\t\t\t\tatomic_read(&server->num_cmds[j]),\n\t\t\t\tserver->time_per_cmd[j],\n\t\t\t\tserver->fastest_cmd[j],\n\t\t\t\tserver->slowest_cmd[j]);\n\t\tfor (j = 0; j < NUMBER_OF_SMB2_COMMANDS; j++)\n\t\t\tif (atomic_read(&server->smb2slowcmd[j])) {\n\t\t\t\tspin_lock(&server->srv_lock);\n\t\t\t\tseq_printf(m, \"  %d slow responses from %s for command %d\\n\",\n\t\t\t\t\tatomic_read(&server->smb2slowcmd[j]),\n\t\t\t\t\tserver->hostname, j);\n\t\t\t\tspin_unlock(&server->srv_lock);\n\t\t\t}\n#endif  \n\t\tlist_for_each_entry(ses, &server->smb_ses_list, smb_ses_list) {\n\t\t\tlist_for_each_entry(tcon, &ses->tcon_list, tcon_list) {\n\t\t\t\ti++;\n\t\t\t\tseq_printf(m, \"\\n%d) %s\", i, tcon->tree_name);\n\t\t\t\tif (tcon->need_reconnect)\n\t\t\t\t\tseq_puts(m, \"\\tDISCONNECTED \");\n\t\t\t\tseq_printf(m, \"\\nSMBs: %d\",\n\t\t\t\t\t   atomic_read(&tcon->num_smbs_sent));\n\t\t\t\tif (server->ops->print_stats)\n\t\t\t\t\tserver->ops->print_stats(m, tcon);\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tseq_putc(m, '\\n');\n\treturn 0;\n}\n\nstatic int cifs_stats_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, cifs_stats_proc_show, NULL);\n}\n\nstatic const struct proc_ops cifs_stats_proc_ops = {\n\t.proc_open\t= cifs_stats_proc_open,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_release\t= single_release,\n\t.proc_write\t= cifs_stats_proc_write,\n};\n\n#ifdef CONFIG_CIFS_SMB_DIRECT\n#define PROC_FILE_DEFINE(name) \\\nstatic ssize_t name##_write(struct file *file, const char __user *buffer, \\\n\tsize_t count, loff_t *ppos) \\\n{ \\\n\tint rc; \\\n\trc = kstrtoint_from_user(buffer, count, 10, & name); \\\n\tif (rc) \\\n\t\treturn rc; \\\n\treturn count; \\\n} \\\nstatic int name##_proc_show(struct seq_file *m, void *v) \\\n{ \\\n\tseq_printf(m, \"%d\\n\", name ); \\\n\treturn 0; \\\n} \\\nstatic int name##_open(struct inode *inode, struct file *file) \\\n{ \\\n\treturn single_open(file, name##_proc_show, NULL); \\\n} \\\n\\\nstatic const struct proc_ops cifs_##name##_proc_fops = { \\\n\t.proc_open\t= name##_open, \\\n\t.proc_read\t= seq_read, \\\n\t.proc_lseek\t= seq_lseek, \\\n\t.proc_release\t= single_release, \\\n\t.proc_write\t= name##_write, \\\n}\n\nPROC_FILE_DEFINE(rdma_readwrite_threshold);\nPROC_FILE_DEFINE(smbd_max_frmr_depth);\nPROC_FILE_DEFINE(smbd_keep_alive_interval);\nPROC_FILE_DEFINE(smbd_max_receive_size);\nPROC_FILE_DEFINE(smbd_max_fragmented_recv_size);\nPROC_FILE_DEFINE(smbd_max_send_size);\nPROC_FILE_DEFINE(smbd_send_credit_target);\nPROC_FILE_DEFINE(smbd_receive_credit_max);\n#endif\n\nstatic struct proc_dir_entry *proc_fs_cifs;\nstatic const struct proc_ops cifsFYI_proc_ops;\nstatic const struct proc_ops cifs_lookup_cache_proc_ops;\nstatic const struct proc_ops traceSMB_proc_ops;\nstatic const struct proc_ops cifs_security_flags_proc_ops;\nstatic const struct proc_ops cifs_linux_ext_proc_ops;\nstatic const struct proc_ops cifs_mount_params_proc_ops;\n\nvoid\ncifs_proc_init(void)\n{\n\tproc_fs_cifs = proc_mkdir(\"fs/cifs\", NULL);\n\tif (proc_fs_cifs == NULL)\n\t\treturn;\n\n\tproc_create_single(\"DebugData\", 0, proc_fs_cifs,\n\t\t\tcifs_debug_data_proc_show);\n\n\tproc_create_single(\"open_files\", 0400, proc_fs_cifs,\n\t\t\tcifs_debug_files_proc_show);\n\n\tproc_create(\"Stats\", 0644, proc_fs_cifs, &cifs_stats_proc_ops);\n\tproc_create(\"cifsFYI\", 0644, proc_fs_cifs, &cifsFYI_proc_ops);\n\tproc_create(\"traceSMB\", 0644, proc_fs_cifs, &traceSMB_proc_ops);\n\tproc_create(\"LinuxExtensionsEnabled\", 0644, proc_fs_cifs,\n\t\t    &cifs_linux_ext_proc_ops);\n\tproc_create(\"SecurityFlags\", 0644, proc_fs_cifs,\n\t\t    &cifs_security_flags_proc_ops);\n\tproc_create(\"LookupCacheEnabled\", 0644, proc_fs_cifs,\n\t\t    &cifs_lookup_cache_proc_ops);\n\n\tproc_create(\"mount_params\", 0444, proc_fs_cifs, &cifs_mount_params_proc_ops);\n\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\tproc_create(\"dfscache\", 0644, proc_fs_cifs, &dfscache_proc_ops);\n#endif\n\n#ifdef CONFIG_CIFS_SMB_DIRECT\n\tproc_create(\"rdma_readwrite_threshold\", 0644, proc_fs_cifs,\n\t\t&cifs_rdma_readwrite_threshold_proc_fops);\n\tproc_create(\"smbd_max_frmr_depth\", 0644, proc_fs_cifs,\n\t\t&cifs_smbd_max_frmr_depth_proc_fops);\n\tproc_create(\"smbd_keep_alive_interval\", 0644, proc_fs_cifs,\n\t\t&cifs_smbd_keep_alive_interval_proc_fops);\n\tproc_create(\"smbd_max_receive_size\", 0644, proc_fs_cifs,\n\t\t&cifs_smbd_max_receive_size_proc_fops);\n\tproc_create(\"smbd_max_fragmented_recv_size\", 0644, proc_fs_cifs,\n\t\t&cifs_smbd_max_fragmented_recv_size_proc_fops);\n\tproc_create(\"smbd_max_send_size\", 0644, proc_fs_cifs,\n\t\t&cifs_smbd_max_send_size_proc_fops);\n\tproc_create(\"smbd_send_credit_target\", 0644, proc_fs_cifs,\n\t\t&cifs_smbd_send_credit_target_proc_fops);\n\tproc_create(\"smbd_receive_credit_max\", 0644, proc_fs_cifs,\n\t\t&cifs_smbd_receive_credit_max_proc_fops);\n#endif\n}\n\nvoid\ncifs_proc_clean(void)\n{\n\tif (proc_fs_cifs == NULL)\n\t\treturn;\n\n\tremove_proc_entry(\"DebugData\", proc_fs_cifs);\n\tremove_proc_entry(\"open_files\", proc_fs_cifs);\n\tremove_proc_entry(\"cifsFYI\", proc_fs_cifs);\n\tremove_proc_entry(\"traceSMB\", proc_fs_cifs);\n\tremove_proc_entry(\"Stats\", proc_fs_cifs);\n\tremove_proc_entry(\"SecurityFlags\", proc_fs_cifs);\n\tremove_proc_entry(\"LinuxExtensionsEnabled\", proc_fs_cifs);\n\tremove_proc_entry(\"LookupCacheEnabled\", proc_fs_cifs);\n\tremove_proc_entry(\"mount_params\", proc_fs_cifs);\n\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\tremove_proc_entry(\"dfscache\", proc_fs_cifs);\n#endif\n#ifdef CONFIG_CIFS_SMB_DIRECT\n\tremove_proc_entry(\"rdma_readwrite_threshold\", proc_fs_cifs);\n\tremove_proc_entry(\"smbd_max_frmr_depth\", proc_fs_cifs);\n\tremove_proc_entry(\"smbd_keep_alive_interval\", proc_fs_cifs);\n\tremove_proc_entry(\"smbd_max_receive_size\", proc_fs_cifs);\n\tremove_proc_entry(\"smbd_max_fragmented_recv_size\", proc_fs_cifs);\n\tremove_proc_entry(\"smbd_max_send_size\", proc_fs_cifs);\n\tremove_proc_entry(\"smbd_send_credit_target\", proc_fs_cifs);\n\tremove_proc_entry(\"smbd_receive_credit_max\", proc_fs_cifs);\n#endif\n\tremove_proc_entry(\"fs/cifs\", NULL);\n}\n\nstatic int cifsFYI_proc_show(struct seq_file *m, void *v)\n{\n\tseq_printf(m, \"%d\\n\", cifsFYI);\n\treturn 0;\n}\n\nstatic int cifsFYI_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, cifsFYI_proc_show, NULL);\n}\n\nstatic ssize_t cifsFYI_proc_write(struct file *file, const char __user *buffer,\n\t\tsize_t count, loff_t *ppos)\n{\n\tchar c[2] = { '\\0' };\n\tbool bv;\n\tint rc;\n\n\trc = get_user(c[0], buffer);\n\tif (rc)\n\t\treturn rc;\n\tif (kstrtobool(c, &bv) == 0)\n\t\tcifsFYI = bv;\n\telse if ((c[0] > '1') && (c[0] <= '9'))\n\t\tcifsFYI = (int) (c[0] - '0');  \n\telse\n\t\treturn -EINVAL;\n\n\treturn count;\n}\n\nstatic const struct proc_ops cifsFYI_proc_ops = {\n\t.proc_open\t= cifsFYI_proc_open,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_release\t= single_release,\n\t.proc_write\t= cifsFYI_proc_write,\n};\n\nstatic int cifs_linux_ext_proc_show(struct seq_file *m, void *v)\n{\n\tseq_printf(m, \"%d\\n\", linuxExtEnabled);\n\treturn 0;\n}\n\nstatic int cifs_linux_ext_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, cifs_linux_ext_proc_show, NULL);\n}\n\nstatic ssize_t cifs_linux_ext_proc_write(struct file *file,\n\t\tconst char __user *buffer, size_t count, loff_t *ppos)\n{\n\tint rc;\n\n\trc = kstrtobool_from_user(buffer, count, &linuxExtEnabled);\n\tif (rc)\n\t\treturn rc;\n\n\treturn count;\n}\n\nstatic const struct proc_ops cifs_linux_ext_proc_ops = {\n\t.proc_open\t= cifs_linux_ext_proc_open,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_release\t= single_release,\n\t.proc_write\t= cifs_linux_ext_proc_write,\n};\n\nstatic int cifs_lookup_cache_proc_show(struct seq_file *m, void *v)\n{\n\tseq_printf(m, \"%d\\n\", lookupCacheEnabled);\n\treturn 0;\n}\n\nstatic int cifs_lookup_cache_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, cifs_lookup_cache_proc_show, NULL);\n}\n\nstatic ssize_t cifs_lookup_cache_proc_write(struct file *file,\n\t\tconst char __user *buffer, size_t count, loff_t *ppos)\n{\n\tint rc;\n\n\trc = kstrtobool_from_user(buffer, count, &lookupCacheEnabled);\n\tif (rc)\n\t\treturn rc;\n\n\treturn count;\n}\n\nstatic const struct proc_ops cifs_lookup_cache_proc_ops = {\n\t.proc_open\t= cifs_lookup_cache_proc_open,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_release\t= single_release,\n\t.proc_write\t= cifs_lookup_cache_proc_write,\n};\n\nstatic int traceSMB_proc_show(struct seq_file *m, void *v)\n{\n\tseq_printf(m, \"%d\\n\", traceSMB);\n\treturn 0;\n}\n\nstatic int traceSMB_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, traceSMB_proc_show, NULL);\n}\n\nstatic ssize_t traceSMB_proc_write(struct file *file, const char __user *buffer,\n\t\tsize_t count, loff_t *ppos)\n{\n\tint rc;\n\n\trc = kstrtobool_from_user(buffer, count, &traceSMB);\n\tif (rc)\n\t\treturn rc;\n\n\treturn count;\n}\n\nstatic const struct proc_ops traceSMB_proc_ops = {\n\t.proc_open\t= traceSMB_proc_open,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_release\t= single_release,\n\t.proc_write\t= traceSMB_proc_write,\n};\n\nstatic int cifs_security_flags_proc_show(struct seq_file *m, void *v)\n{\n\tseq_printf(m, \"0x%x\\n\", global_secflags);\n\treturn 0;\n}\n\nstatic int cifs_security_flags_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, cifs_security_flags_proc_show, NULL);\n}\n\n \nstatic void\ncifs_security_flags_handle_must_flags(unsigned int *flags)\n{\n\tunsigned int signflags = *flags & CIFSSEC_MUST_SIGN;\n\n\tif ((*flags & CIFSSEC_MUST_KRB5) == CIFSSEC_MUST_KRB5)\n\t\t*flags = CIFSSEC_MUST_KRB5;\n\telse if ((*flags & CIFSSEC_MUST_NTLMSSP) == CIFSSEC_MUST_NTLMSSP)\n\t\t*flags = CIFSSEC_MUST_NTLMSSP;\n\telse if ((*flags & CIFSSEC_MUST_NTLMV2) == CIFSSEC_MUST_NTLMV2)\n\t\t*flags = CIFSSEC_MUST_NTLMV2;\n\n\t*flags |= signflags;\n}\n\nstatic ssize_t cifs_security_flags_proc_write(struct file *file,\n\t\tconst char __user *buffer, size_t count, loff_t *ppos)\n{\n\tint rc;\n\tunsigned int flags;\n\tchar flags_string[12];\n\tbool bv;\n\n\tif ((count < 1) || (count > 11))\n\t\treturn -EINVAL;\n\n\tmemset(flags_string, 0, 12);\n\n\tif (copy_from_user(flags_string, buffer, count))\n\t\treturn -EFAULT;\n\n\tif (count < 3) {\n\t\t \n\t\tif (kstrtobool(flags_string, &bv) == 0) {\n\t\t\tglobal_secflags = bv ? CIFSSEC_MAX : CIFSSEC_DEF;\n\t\t\treturn count;\n\t\t} else if (!isdigit(flags_string[0])) {\n\t\t\tcifs_dbg(VFS, \"Invalid SecurityFlags: %s\\n\",\n\t\t\t\t\tflags_string);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\trc = kstrtouint(flags_string, 0, &flags);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"Invalid SecurityFlags: %s\\n\",\n\t\t\t\tflags_string);\n\t\treturn rc;\n\t}\n\n\tcifs_dbg(FYI, \"sec flags 0x%x\\n\", flags);\n\n\tif (flags == 0)  {\n\t\tcifs_dbg(VFS, \"Invalid SecurityFlags: %s\\n\", flags_string);\n\t\treturn -EINVAL;\n\t}\n\n\tif (flags & ~CIFSSEC_MASK) {\n\t\tcifs_dbg(VFS, \"Unsupported security flags: 0x%x\\n\",\n\t\t\t flags & ~CIFSSEC_MASK);\n\t\treturn -EINVAL;\n\t}\n\n\tcifs_security_flags_handle_must_flags(&flags);\n\n\t \n\tglobal_secflags = flags;\n\tif (global_secflags & CIFSSEC_MUST_SIGN) {\n\t\t \n\t\tglobal_secflags |= CIFSSEC_MAY_SIGN;\n\t\tcifs_dbg(FYI, \"packet signing now required\\n\");\n\t} else if ((global_secflags & CIFSSEC_MAY_SIGN) == 0) {\n\t\tcifs_dbg(FYI, \"packet signing disabled\\n\");\n\t}\n\t \n\treturn count;\n}\n\nstatic const struct proc_ops cifs_security_flags_proc_ops = {\n\t.proc_open\t= cifs_security_flags_proc_open,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_release\t= single_release,\n\t.proc_write\t= cifs_security_flags_proc_write,\n};\n\n \nstatic int cifs_mount_params_proc_show(struct seq_file *m, void *v)\n{\n\tconst struct fs_parameter_spec *p;\n\tconst char *type;\n\n\tfor (p = smb3_fs_parameters; p->name; p++) {\n\t\t \n\t\tif (!p->type) {\n\t\t\tif (p->flags == fs_param_neg_with_no)\n\t\t\t\ttype = \"noflag\";\n\t\t\telse\n\t\t\t\ttype = \"flag\";\n\t\t} else if (p->type == fs_param_is_bool)\n\t\t\ttype = \"bool\";\n\t\telse if (p->type == fs_param_is_u32)\n\t\t\ttype = \"u32\";\n\t\telse if (p->type == fs_param_is_u64)\n\t\t\ttype = \"u64\";\n\t\telse if (p->type == fs_param_is_string)\n\t\t\ttype = \"string\";\n\t\telse\n\t\t\ttype = \"unknown\";\n\n\t\tseq_printf(m, \"%s:%s\\n\", p->name, type);\n\t}\n\n\treturn 0;\n}\n\nstatic int cifs_mount_params_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, cifs_mount_params_proc_show, NULL);\n}\n\nstatic const struct proc_ops cifs_mount_params_proc_ops = {\n\t.proc_open\t= cifs_mount_params_proc_open,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_release\t= single_release,\n\t \n\t \n};\n\n#else\ninline void cifs_proc_init(void)\n{\n}\n\ninline void cifs_proc_clean(void)\n{\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}