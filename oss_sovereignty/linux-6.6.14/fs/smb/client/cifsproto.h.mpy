{
  "module_name": "cifsproto.h",
  "hash_id": "8b633d0ad37c8f6a64478b41dd1a5752e7481f8e520cd7bde4bcc4757bc17980",
  "original_prompt": "Ingested from linux-6.6.14/fs/smb/client/cifsproto.h",
  "human_readable_source": " \n \n#ifndef _CIFSPROTO_H\n#define _CIFSPROTO_H\n#include <linux/nls.h>\n#include <linux/ctype.h>\n#include \"trace.h\"\n#ifdef CONFIG_CIFS_DFS_UPCALL\n#include \"dfs_cache.h\"\n#endif\n\nstruct statfs;\nstruct smb_rqst;\nstruct smb3_fs_context;\n\n \n\nextern struct smb_hdr *cifs_buf_get(void);\nextern void cifs_buf_release(void *);\nextern struct smb_hdr *cifs_small_buf_get(void);\nextern void cifs_small_buf_release(void *);\nextern void free_rsp_buf(int, void *);\nextern int smb_send(struct TCP_Server_Info *, struct smb_hdr *,\n\t\t\tunsigned int  );\nextern unsigned int _get_xid(void);\nextern void _free_xid(unsigned int);\n#define get_xid()\t\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tunsigned int __xid = _get_xid();\t\t\t\t\\\n\tcifs_dbg(FYI, \"VFS: in %s as Xid: %u with uid: %d\\n\",\t\t\\\n\t\t __func__, __xid,\t\t\t\t\t\\\n\t\t from_kuid(&init_user_ns, current_fsuid()));\t\t\\\n\ttrace_smb3_enter(__xid, __func__);\t\t\t\t\\\n\t__xid;\t\t\t\t\t\t\t\t\\\n})\n\n#define free_xid(curr_xid)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\t_free_xid(curr_xid);\t\t\t\t\t\t\\\n\tcifs_dbg(FYI, \"VFS: leaving %s (xid = %u) rc = %d\\n\",\t\t\\\n\t\t __func__, curr_xid, (int)rc);\t\t\t\t\\\n\tif (rc)\t\t\t\t\t\t\t\t\\\n\t\ttrace_smb3_exit_err(curr_xid, __func__, (int)rc);\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\ttrace_smb3_exit_done(curr_xid, __func__);\t\t\\\n} while (0)\nextern int init_cifs_idmap(void);\nextern void exit_cifs_idmap(void);\nextern int init_cifs_spnego(void);\nextern void exit_cifs_spnego(void);\nextern const char *build_path_from_dentry(struct dentry *, void *);\nchar *__build_path_from_dentry_optional_prefix(struct dentry *direntry, void *page,\n\t\t\t\t\t       const char *tree, int tree_len,\n\t\t\t\t\t       bool prefix);\nextern char *build_path_from_dentry_optional_prefix(struct dentry *direntry,\n\t\t\t\t\t\t    void *page, bool prefix);\nstatic inline void *alloc_dentry_path(void)\n{\n\treturn __getname();\n}\n\nstatic inline void free_dentry_path(void *page)\n{\n\tif (page)\n\t\t__putname(page);\n}\n\nextern char *cifs_build_path_to_root(struct smb3_fs_context *ctx,\n\t\t\t\t     struct cifs_sb_info *cifs_sb,\n\t\t\t\t     struct cifs_tcon *tcon,\n\t\t\t\t     int add_treename);\nextern char *build_wildcard_path_from_dentry(struct dentry *direntry);\nchar *cifs_build_devname(char *nodename, const char *prepath);\nextern void delete_mid(struct mid_q_entry *mid);\nvoid __release_mid(struct kref *refcount);\nextern void cifs_wake_up_task(struct mid_q_entry *mid);\nextern int cifs_handle_standard(struct TCP_Server_Info *server,\n\t\t\t\tstruct mid_q_entry *mid);\nextern char *smb3_fs_context_fullpath(const struct smb3_fs_context *ctx,\n\t\t\t\t      char dirsep);\nextern int smb3_parse_devname(const char *devname, struct smb3_fs_context *ctx);\nextern int smb3_parse_opt(const char *options, const char *key, char **val);\nextern int cifs_ipaddr_cmp(struct sockaddr *srcaddr, struct sockaddr *rhs);\nextern bool cifs_match_ipaddr(struct sockaddr *srcaddr, struct sockaddr *rhs);\nextern int cifs_discard_remaining_data(struct TCP_Server_Info *server);\nextern int cifs_call_async(struct TCP_Server_Info *server,\n\t\t\tstruct smb_rqst *rqst,\n\t\t\tmid_receive_t *receive, mid_callback_t *callback,\n\t\t\tmid_handle_t *handle, void *cbdata, const int flags,\n\t\t\tconst struct cifs_credits *exist_credits);\nextern struct TCP_Server_Info *cifs_pick_channel(struct cifs_ses *ses);\nextern int cifs_send_recv(const unsigned int xid, struct cifs_ses *ses,\n\t\t\t  struct TCP_Server_Info *server,\n\t\t\t  struct smb_rqst *rqst, int *resp_buf_type,\n\t\t\t  const int flags, struct kvec *resp_iov);\nextern int compound_send_recv(const unsigned int xid, struct cifs_ses *ses,\n\t\t\t      struct TCP_Server_Info *server,\n\t\t\t      const int flags, const int num_rqst,\n\t\t\t      struct smb_rqst *rqst, int *resp_buf_type,\n\t\t\t      struct kvec *resp_iov);\nextern int SendReceive(const unsigned int   , struct cifs_ses *,\n\t\t\tstruct smb_hdr *   ,\n\t\t\tstruct smb_hdr *   ,\n\t\t\tint *   , const int);\nextern int SendReceiveNoRsp(const unsigned int xid, struct cifs_ses *ses,\n\t\t\t    char *in_buf, int flags);\nextern struct mid_q_entry *cifs_setup_request(struct cifs_ses *,\n\t\t\t\tstruct TCP_Server_Info *,\n\t\t\t\tstruct smb_rqst *);\nextern struct mid_q_entry *cifs_setup_async_request(struct TCP_Server_Info *,\n\t\t\t\t\t\tstruct smb_rqst *);\nextern int cifs_check_receive(struct mid_q_entry *mid,\n\t\t\tstruct TCP_Server_Info *server, bool log_error);\nextern int cifs_wait_mtu_credits(struct TCP_Server_Info *server,\n\t\t\t\t unsigned int size, unsigned int *num,\n\t\t\t\t struct cifs_credits *credits);\nextern int SendReceive2(const unsigned int   , struct cifs_ses *,\n\t\t\tstruct kvec *, int  ,\n\t\t\tint *  , const int flags,\n\t\t\tstruct kvec *  );\nextern int SendReceiveBlockingLock(const unsigned int xid,\n\t\t\tstruct cifs_tcon *ptcon,\n\t\t\tstruct smb_hdr *in_buf,\n\t\t\tstruct smb_hdr *out_buf,\n\t\t\tint *bytes_returned);\nvoid\ncifs_signal_cifsd_for_reconnect(struct TCP_Server_Info *server,\n\t\t\t\t      bool all_channels);\nvoid\ncifs_mark_tcp_ses_conns_for_reconnect(struct TCP_Server_Info *server,\n\t\t\t\t      bool mark_smb_session);\nextern int cifs_reconnect(struct TCP_Server_Info *server,\n\t\t\t  bool mark_smb_session);\nextern int checkSMB(char *buf, unsigned int len, struct TCP_Server_Info *srvr);\nextern bool is_valid_oplock_break(char *, struct TCP_Server_Info *);\nextern bool backup_cred(struct cifs_sb_info *);\nextern bool is_size_safe_to_change(struct cifsInodeInfo *, __u64 eof);\nextern void cifs_update_eof(struct cifsInodeInfo *cifsi, loff_t offset,\n\t\t\t    unsigned int bytes_written);\nextern struct cifsFileInfo *find_writable_file(struct cifsInodeInfo *, int);\nextern int cifs_get_writable_file(struct cifsInodeInfo *cifs_inode,\n\t\t\t\t  int flags,\n\t\t\t\t  struct cifsFileInfo **ret_file);\nextern int cifs_get_writable_path(struct cifs_tcon *tcon, const char *name,\n\t\t\t\t  int flags,\n\t\t\t\t  struct cifsFileInfo **ret_file);\nextern struct cifsFileInfo *find_readable_file(struct cifsInodeInfo *, bool);\nextern int cifs_get_readable_path(struct cifs_tcon *tcon, const char *name,\n\t\t\t\t  struct cifsFileInfo **ret_file);\nextern unsigned int smbCalcSize(void *buf);\nextern int decode_negTokenInit(unsigned char *security_blob, int length,\n\t\t\tstruct TCP_Server_Info *server);\nextern int cifs_convert_address(struct sockaddr *dst, const char *src, int len);\nextern void cifs_set_port(struct sockaddr *addr, const unsigned short int port);\nextern int map_smb_to_linux_error(char *buf, bool logErr);\nextern int map_and_check_smb_error(struct mid_q_entry *mid, bool logErr);\nextern void header_assemble(struct smb_hdr *, char   ,\n\t\t\t    const struct cifs_tcon *, int  );\nextern int small_smb_init_no_tc(const int smb_cmd, const int wct,\n\t\t\t\tstruct cifs_ses *ses,\n\t\t\t\tvoid **request_buf);\nextern enum securityEnum select_sectype(struct TCP_Server_Info *server,\n\t\t\t\tenum securityEnum requested);\nextern int CIFS_SessSetup(const unsigned int xid, struct cifs_ses *ses,\n\t\t\t  struct TCP_Server_Info *server,\n\t\t\t  const struct nls_table *nls_cp);\nextern struct timespec64 cifs_NTtimeToUnix(__le64 utc_nanoseconds_since_1601);\nextern u64 cifs_UnixTimeToNT(struct timespec64);\nextern struct timespec64 cnvrtDosUnixTm(__le16 le_date, __le16 le_time,\n\t\t\t\t      int offset);\nextern void cifs_set_oplock_level(struct cifsInodeInfo *cinode, __u32 oplock);\nextern int cifs_get_writer(struct cifsInodeInfo *cinode);\nextern void cifs_put_writer(struct cifsInodeInfo *cinode);\nextern void cifs_done_oplock_break(struct cifsInodeInfo *cinode);\nextern int cifs_unlock_range(struct cifsFileInfo *cfile,\n\t\t\t     struct file_lock *flock, const unsigned int xid);\nextern int cifs_push_mandatory_locks(struct cifsFileInfo *cfile);\n\nextern void cifs_down_write(struct rw_semaphore *sem);\nstruct cifsFileInfo *cifs_new_fileinfo(struct cifs_fid *fid, struct file *file,\n\t\t\t\t       struct tcon_link *tlink, __u32 oplock,\n\t\t\t\t       const char *symlink_target);\nextern int cifs_posix_open(const char *full_path, struct inode **inode,\n\t\t\t   struct super_block *sb, int mode,\n\t\t\t   unsigned int f_flags, __u32 *oplock, __u16 *netfid,\n\t\t\t   unsigned int xid);\nvoid cifs_fill_uniqueid(struct super_block *sb, struct cifs_fattr *fattr);\nextern void cifs_unix_basic_to_fattr(struct cifs_fattr *fattr,\n\t\t\t\t     FILE_UNIX_BASIC_INFO *info,\n\t\t\t\t     struct cifs_sb_info *cifs_sb);\nextern void cifs_dir_info_to_fattr(struct cifs_fattr *, FILE_DIRECTORY_INFO *,\n\t\t\t\t\tstruct cifs_sb_info *);\nextern int cifs_fattr_to_inode(struct inode *inode, struct cifs_fattr *fattr);\nextern struct inode *cifs_iget(struct super_block *sb,\n\t\t\t       struct cifs_fattr *fattr);\n\nint cifs_get_inode_info(struct inode **inode, const char *full_path,\n\t\t\tstruct cifs_open_info_data *data, struct super_block *sb, int xid,\n\t\t\tconst struct cifs_fid *fid);\nbool cifs_reparse_point_to_fattr(struct cifs_sb_info *cifs_sb,\n\t\t\t\t struct cifs_fattr *fattr,\n\t\t\t\t struct cifs_open_info_data *data);\nextern int smb311_posix_get_inode_info(struct inode **pinode, const char *search_path,\n\t\t\tstruct super_block *sb, unsigned int xid);\nextern int cifs_get_inode_info_unix(struct inode **pinode,\n\t\t\tconst unsigned char *search_path,\n\t\t\tstruct super_block *sb, unsigned int xid);\nextern int cifs_set_file_info(struct inode *inode, struct iattr *attrs,\n\t\t\t      unsigned int xid, const char *full_path, __u32 dosattr);\nextern int cifs_rename_pending_delete(const char *full_path,\n\t\t\t\t      struct dentry *dentry,\n\t\t\t\t      const unsigned int xid);\nextern int sid_to_id(struct cifs_sb_info *cifs_sb, struct cifs_sid *psid,\n\t\t\t\tstruct cifs_fattr *fattr, uint sidtype);\nextern int cifs_acl_to_fattr(struct cifs_sb_info *cifs_sb,\n\t\t\t      struct cifs_fattr *fattr, struct inode *inode,\n\t\t\t      bool get_mode_from_special_sid,\n\t\t\t      const char *path, const struct cifs_fid *pfid);\nextern int id_mode_to_cifs_acl(struct inode *inode, const char *path, __u64 *pnmode,\n\t\t\t\t\tkuid_t uid, kgid_t gid);\nextern struct cifs_ntsd *get_cifs_acl(struct cifs_sb_info *, struct inode *,\n\t\t\t\t      const char *, u32 *, u32);\nextern struct cifs_ntsd *get_cifs_acl_by_fid(struct cifs_sb_info *,\n\t\t\t\tconst struct cifs_fid *, u32 *, u32);\nextern struct posix_acl *cifs_get_acl(struct mnt_idmap *idmap,\n\t\t\t\t      struct dentry *dentry, int type);\nextern int cifs_set_acl(struct mnt_idmap *idmap,\n\t\t\tstruct dentry *dentry, struct posix_acl *acl, int type);\nextern int set_cifs_acl(struct cifs_ntsd *, __u32, struct inode *,\n\t\t\t\tconst char *, int);\nextern unsigned int setup_authusers_ACE(struct cifs_ace *pace);\nextern unsigned int setup_special_mode_ACE(struct cifs_ace *pace, __u64 nmode);\nextern unsigned int setup_special_user_owner_ACE(struct cifs_ace *pace);\n\nextern void dequeue_mid(struct mid_q_entry *mid, bool malformed);\nextern int cifs_read_from_socket(struct TCP_Server_Info *server, char *buf,\n\t\t\t         unsigned int to_read);\nextern ssize_t cifs_discard_from_socket(struct TCP_Server_Info *server,\n\t\t\t\t\tsize_t to_read);\nextern int cifs_read_page_from_socket(struct TCP_Server_Info *server,\n\t\t\t\t\tstruct page *page,\n\t\t\t\t\tunsigned int page_offset,\n\t\t\t\t\tunsigned int to_read);\nint cifs_read_iter_from_socket(struct TCP_Server_Info *server,\n\t\t\t       struct iov_iter *iter,\n\t\t\t       unsigned int to_read);\nextern int cifs_setup_cifs_sb(struct cifs_sb_info *cifs_sb);\nvoid cifs_mount_put_conns(struct cifs_mount_ctx *mnt_ctx);\nint cifs_mount_get_session(struct cifs_mount_ctx *mnt_ctx);\nint cifs_is_path_remote(struct cifs_mount_ctx *mnt_ctx);\nint cifs_mount_get_tcon(struct cifs_mount_ctx *mnt_ctx);\nextern int cifs_match_super(struct super_block *, void *);\nextern int cifs_mount(struct cifs_sb_info *cifs_sb, struct smb3_fs_context *ctx);\nextern void cifs_umount(struct cifs_sb_info *);\nextern void cifs_mark_open_files_invalid(struct cifs_tcon *tcon);\nextern void cifs_reopen_persistent_handles(struct cifs_tcon *tcon);\n\nextern bool cifs_find_lock_conflict(struct cifsFileInfo *cfile, __u64 offset,\n\t\t\t\t    __u64 length, __u8 type, __u16 flags,\n\t\t\t\t    struct cifsLockInfo **conf_lock,\n\t\t\t\t    int rw_check);\nextern void cifs_add_pending_open(struct cifs_fid *fid,\n\t\t\t\t  struct tcon_link *tlink,\n\t\t\t\t  struct cifs_pending_open *open);\nextern void cifs_add_pending_open_locked(struct cifs_fid *fid,\n\t\t\t\t\t struct tcon_link *tlink,\n\t\t\t\t\t struct cifs_pending_open *open);\nextern void cifs_del_pending_open(struct cifs_pending_open *open);\n\nextern bool cifs_is_deferred_close(struct cifsFileInfo *cfile,\n\t\t\t\tstruct cifs_deferred_close **dclose);\n\nextern void cifs_add_deferred_close(struct cifsFileInfo *cfile,\n\t\t\t\tstruct cifs_deferred_close *dclose);\n\nextern void cifs_del_deferred_close(struct cifsFileInfo *cfile);\n\nextern void cifs_close_deferred_file(struct cifsInodeInfo *cifs_inode);\n\nextern void cifs_close_all_deferred_files(struct cifs_tcon *cifs_tcon);\n\nextern void cifs_close_deferred_file_under_dentry(struct cifs_tcon *cifs_tcon,\n\t\t\t\tconst char *path);\nextern struct TCP_Server_Info *\ncifs_get_tcp_session(struct smb3_fs_context *ctx,\n\t\t     struct TCP_Server_Info *primary_server);\nextern void cifs_put_tcp_session(struct TCP_Server_Info *server,\n\t\t\t\t int from_reconnect);\nextern void cifs_put_tcon(struct cifs_tcon *tcon);\n\nextern void cifs_release_automount_timer(void);\n\nvoid cifs_proc_init(void);\nvoid cifs_proc_clean(void);\n\nextern void cifs_move_llist(struct list_head *source, struct list_head *dest);\nextern void cifs_free_llist(struct list_head *llist);\nextern void cifs_del_lock_waiters(struct cifsLockInfo *lock);\n\nextern int cifs_tree_connect(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\t     const struct nls_table *nlsc);\n\nextern int cifs_negotiate_protocol(const unsigned int xid,\n\t\t\t\t   struct cifs_ses *ses,\n\t\t\t\t   struct TCP_Server_Info *server);\nextern int cifs_setup_session(const unsigned int xid, struct cifs_ses *ses,\n\t\t\t      struct TCP_Server_Info *server,\n\t\t\t      struct nls_table *nls_info);\nextern int cifs_enable_signing(struct TCP_Server_Info *server, bool mnt_sign_required);\nextern int CIFSSMBNegotiate(const unsigned int xid,\n\t\t\t    struct cifs_ses *ses,\n\t\t\t    struct TCP_Server_Info *server);\n\nextern int CIFSTCon(const unsigned int xid, struct cifs_ses *ses,\n\t\t    const char *tree, struct cifs_tcon *tcon,\n\t\t    const struct nls_table *);\n\nextern int CIFSFindFirst(const unsigned int xid, struct cifs_tcon *tcon,\n\t\tconst char *searchName, struct cifs_sb_info *cifs_sb,\n\t\t__u16 *searchHandle, __u16 search_flags,\n\t\tstruct cifs_search_info *psrch_inf,\n\t\tbool msearch);\n\nextern int CIFSFindNext(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t__u16 searchHandle, __u16 search_flags,\n\t\tstruct cifs_search_info *psrch_inf);\n\nextern int CIFSFindClose(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\tconst __u16 search_handle);\n\nextern int CIFSSMBQFileInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\tu16 netfid, FILE_ALL_INFO *pFindData);\nextern int CIFSSMBQPathInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\t    const char *search_Name, FILE_ALL_INFO *data,\n\t\t\t    int legacy  ,\n\t\t\t    const struct nls_table *nls_codepage, int remap);\nextern int SMBQueryInformation(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\t       const char *search_name, FILE_ALL_INFO *data,\n\t\t\t       const struct nls_table *nls_codepage, int remap);\n\nextern int CIFSSMBUnixQFileInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\tu16 netfid, FILE_UNIX_BASIC_INFO *pFindData);\nextern int CIFSSMBUnixQPathInfo(const unsigned int xid,\n\t\t\tstruct cifs_tcon *tcon,\n\t\t\tconst unsigned char *searchName,\n\t\t\tFILE_UNIX_BASIC_INFO *pFindData,\n\t\t\tconst struct nls_table *nls_codepage, int remap);\n\nextern int CIFSGetDFSRefer(const unsigned int xid, struct cifs_ses *ses,\n\t\t\t   const char *search_name,\n\t\t\t   struct dfs_info3_param **target_nodes,\n\t\t\t   unsigned int *num_of_nodes,\n\t\t\t   const struct nls_table *nls_codepage, int remap);\n\nextern int parse_dfs_referrals(struct get_dfs_referral_rsp *rsp, u32 rsp_size,\n\t\t\t       unsigned int *num_of_nodes,\n\t\t\t       struct dfs_info3_param **target_nodes,\n\t\t\t       const struct nls_table *nls_codepage, int remap,\n\t\t\t       const char *searchName, bool is_unicode);\nextern void reset_cifs_unix_caps(unsigned int xid, struct cifs_tcon *tcon,\n\t\t\t\t struct cifs_sb_info *cifs_sb,\n\t\t\t\t struct smb3_fs_context *ctx);\nextern int CIFSSMBQFSInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\tstruct kstatfs *FSData);\nextern int SMBOldQFSInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\tstruct kstatfs *FSData);\nextern int CIFSSMBSetFSUnixInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\t__u64 cap);\n\nextern int CIFSSMBQFSAttributeInfo(const unsigned int xid,\n\t\t\tstruct cifs_tcon *tcon);\nextern int CIFSSMBQFSDeviceInfo(const unsigned int xid, struct cifs_tcon *tcon);\nextern int CIFSSMBQFSUnixInfo(const unsigned int xid, struct cifs_tcon *tcon);\nextern int CIFSSMBQFSPosixInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\tstruct kstatfs *FSData);\n\nextern int CIFSSMBSetPathInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\tconst char *fileName, const FILE_BASIC_INFO *data,\n\t\t\tconst struct nls_table *nls_codepage,\n\t\t\tstruct cifs_sb_info *cifs_sb);\nextern int CIFSSMBSetFileInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\tconst FILE_BASIC_INFO *data, __u16 fid,\n\t\t\t__u32 pid_of_opener);\nextern int CIFSSMBSetFileDisposition(const unsigned int xid,\n\t\t\t\t     struct cifs_tcon *tcon,\n\t\t\t\t     bool delete_file, __u16 fid,\n\t\t\t\t     __u32 pid_of_opener);\nextern int CIFSSMBSetEOF(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\t const char *file_name, __u64 size,\n\t\t\t struct cifs_sb_info *cifs_sb, bool set_allocation);\nextern int CIFSSMBSetFileSize(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\t      struct cifsFileInfo *cfile, __u64 size,\n\t\t\t      bool set_allocation);\n\nstruct cifs_unix_set_info_args {\n\t__u64\tctime;\n\t__u64\tatime;\n\t__u64\tmtime;\n\t__u64\tmode;\n\tkuid_t\tuid;\n\tkgid_t\tgid;\n\tdev_t\tdevice;\n};\n\nextern int CIFSSMBUnixSetFileInfo(const unsigned int xid,\n\t\t\t\t  struct cifs_tcon *tcon,\n\t\t\t\t  const struct cifs_unix_set_info_args *args,\n\t\t\t\t  u16 fid, u32 pid_of_opener);\n\nextern int CIFSSMBUnixSetPathInfo(const unsigned int xid,\n\t\t\t\t  struct cifs_tcon *tcon, const char *file_name,\n\t\t\t\t  const struct cifs_unix_set_info_args *args,\n\t\t\t\t  const struct nls_table *nls_codepage,\n\t\t\t\t  int remap);\n\nextern int CIFSSMBMkDir(const unsigned int xid, struct inode *inode,\n\t\t\tumode_t mode, struct cifs_tcon *tcon,\n\t\t\tconst char *name, struct cifs_sb_info *cifs_sb);\nextern int CIFSSMBRmDir(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\tconst char *name, struct cifs_sb_info *cifs_sb);\nextern int CIFSPOSIXDelFile(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\tconst char *name, __u16 type,\n\t\t\tconst struct nls_table *nls_codepage,\n\t\t\tint remap_special_chars);\nextern int CIFSSMBDelFile(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\t  const char *name, struct cifs_sb_info *cifs_sb);\nextern int CIFSSMBRename(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\t const char *from_name, const char *to_name,\n\t\t\t struct cifs_sb_info *cifs_sb);\nextern int CIFSSMBRenameOpenFile(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\t\t int netfid, const char *target_name,\n\t\t\t\t const struct nls_table *nls_codepage,\n\t\t\t\t int remap_special_chars);\nextern int CIFSCreateHardLink(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\t      const char *from_name, const char *to_name,\n\t\t\t      struct cifs_sb_info *cifs_sb);\nextern int CIFSUnixCreateHardLink(const unsigned int xid,\n\t\t\tstruct cifs_tcon *tcon,\n\t\t\tconst char *fromName, const char *toName,\n\t\t\tconst struct nls_table *nls_codepage,\n\t\t\tint remap_special_chars);\nextern int CIFSUnixCreateSymLink(const unsigned int xid,\n\t\t\tstruct cifs_tcon *tcon,\n\t\t\tconst char *fromName, const char *toName,\n\t\t\tconst struct nls_table *nls_codepage, int remap);\nextern int CIFSSMBUnixQuerySymLink(const unsigned int xid,\n\t\t\tstruct cifs_tcon *tcon,\n\t\t\tconst unsigned char *searchName, char **syminfo,\n\t\t\tconst struct nls_table *nls_codepage, int remap);\nextern int cifs_query_reparse_point(const unsigned int xid,\n\t\t\t\t    struct cifs_tcon *tcon,\n\t\t\t\t    struct cifs_sb_info *cifs_sb,\n\t\t\t\t    const char *full_path,\n\t\t\t\t    u32 *tag, struct kvec *rsp,\n\t\t\t\t    int *rsp_buftype);\nextern int CIFSSMBQuerySymLink(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\t       __u16 fid, char **symlinkinfo,\n\t\t\t       const struct nls_table *nls_codepage);\nextern int CIFSSMB_set_compression(const unsigned int xid,\n\t\t\t\t   struct cifs_tcon *tcon, __u16 fid);\nextern int CIFS_open(const unsigned int xid, struct cifs_open_parms *oparms,\n\t\t     int *oplock, FILE_ALL_INFO *buf);\nextern int SMBLegacyOpen(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\tconst char *fileName, const int disposition,\n\t\t\tconst int access_flags, const int omode,\n\t\t\t__u16 *netfid, int *pOplock, FILE_ALL_INFO *,\n\t\t\tconst struct nls_table *nls_codepage, int remap);\nextern int CIFSPOSIXCreate(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\tu32 posix_flags, __u64 mode, __u16 *netfid,\n\t\t\tFILE_UNIX_BASIC_INFO *pRetData,\n\t\t\t__u32 *pOplock, const char *name,\n\t\t\tconst struct nls_table *nls_codepage, int remap);\nextern int CIFSSMBClose(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\tconst int smb_file_id);\n\nextern int CIFSSMBFlush(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\tconst int smb_file_id);\n\nextern int CIFSSMBRead(const unsigned int xid, struct cifs_io_parms *io_parms,\n\t\t\tunsigned int *nbytes, char **buf,\n\t\t\tint *return_buf_type);\nextern int CIFSSMBWrite(const unsigned int xid, struct cifs_io_parms *io_parms,\n\t\t\tunsigned int *nbytes, const char *buf);\nextern int CIFSSMBWrite2(const unsigned int xid, struct cifs_io_parms *io_parms,\n\t\t\tunsigned int *nbytes, struct kvec *iov, const int nvec);\nextern int CIFSGetSrvInodeNumber(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\t\t const char *search_name, __u64 *inode_number,\n\t\t\t\t const struct nls_table *nls_codepage,\n\t\t\t\t int remap);\n\nextern int cifs_lockv(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t      const __u16 netfid, const __u8 lock_type,\n\t\t      const __u32 num_unlock, const __u32 num_lock,\n\t\t      LOCKING_ANDX_RANGE *buf);\nextern int CIFSSMBLock(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\tconst __u16 netfid, const __u32 netpid, const __u64 len,\n\t\t\tconst __u64 offset, const __u32 numUnlock,\n\t\t\tconst __u32 numLock, const __u8 lockType,\n\t\t\tconst bool waitFlag, const __u8 oplock_level);\nextern int CIFSSMBPosixLock(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\tconst __u16 smb_file_id, const __u32 netpid,\n\t\t\tconst loff_t start_offset, const __u64 len,\n\t\t\tstruct file_lock *, const __u16 lock_type,\n\t\t\tconst bool waitFlag);\nextern int CIFSSMBTDis(const unsigned int xid, struct cifs_tcon *tcon);\nextern int CIFSSMBEcho(struct TCP_Server_Info *server);\nextern int CIFSSMBLogoff(const unsigned int xid, struct cifs_ses *ses);\n\nextern struct cifs_ses *sesInfoAlloc(void);\nextern void sesInfoFree(struct cifs_ses *);\nextern struct cifs_tcon *tcon_info_alloc(bool dir_leases_enabled);\nextern void tconInfoFree(struct cifs_tcon *);\n\nextern int cifs_sign_rqst(struct smb_rqst *rqst, struct TCP_Server_Info *server,\n\t\t   __u32 *pexpected_response_sequence_number);\nextern int cifs_sign_smbv(struct kvec *iov, int n_vec, struct TCP_Server_Info *,\n\t\t\t  __u32 *);\nextern int cifs_sign_smb(struct smb_hdr *, struct TCP_Server_Info *, __u32 *);\nextern int cifs_verify_signature(struct smb_rqst *rqst,\n\t\t\t\t struct TCP_Server_Info *server,\n\t\t\t\t__u32 expected_sequence_number);\nextern int setup_ntlmv2_rsp(struct cifs_ses *, const struct nls_table *);\nextern void cifs_crypto_secmech_release(struct TCP_Server_Info *server);\nextern int calc_seckey(struct cifs_ses *);\nextern int generate_smb30signingkey(struct cifs_ses *ses,\n\t\t\t\t    struct TCP_Server_Info *server);\nextern int generate_smb311signingkey(struct cifs_ses *ses,\n\t\t\t\t     struct TCP_Server_Info *server);\n\n#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY\nextern int CIFSSMBCopy(unsigned int xid,\n\t\t\tstruct cifs_tcon *source_tcon,\n\t\t\tconst char *fromName,\n\t\t\tconst __u16 target_tid,\n\t\t\tconst char *toName, const int flags,\n\t\t\tconst struct nls_table *nls_codepage,\n\t\t\tint remap_special_chars);\nextern ssize_t CIFSSMBQAllEAs(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\tconst unsigned char *searchName,\n\t\t\tconst unsigned char *ea_name, char *EAData,\n\t\t\tsize_t bufsize, struct cifs_sb_info *cifs_sb);\nextern int CIFSSMBSetEA(const unsigned int xid, struct cifs_tcon *tcon,\n\t\tconst char *fileName, const char *ea_name,\n\t\tconst void *ea_value, const __u16 ea_value_len,\n\t\tconst struct nls_table *nls_codepage,\n\t\tstruct cifs_sb_info *cifs_sb);\nextern int CIFSSMBGetCIFSACL(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\t__u16 fid, struct cifs_ntsd **acl_inf, __u32 *buflen);\nextern int CIFSSMBSetCIFSACL(const unsigned int, struct cifs_tcon *, __u16,\n\t\t\tstruct cifs_ntsd *, __u32, int);\nextern int cifs_do_get_acl(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\t   const unsigned char *searchName,\n\t\t\t   struct posix_acl **acl, const int acl_type,\n\t\t\t   const struct nls_table *nls_codepage, int remap);\nextern int cifs_do_set_acl(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\t   const unsigned char *fileName,\n\t\t\t   const struct posix_acl *acl, const int acl_type,\n\t\t\t   const struct nls_table *nls_codepage, int remap);\nextern int CIFSGetExtAttr(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\tconst int netfid, __u64 *pExtAttrBits, __u64 *pMask);\n#endif  \nextern void cifs_autodisable_serverino(struct cifs_sb_info *cifs_sb);\nextern bool couldbe_mf_symlink(const struct cifs_fattr *fattr);\nextern int check_mf_symlink(unsigned int xid, struct cifs_tcon *tcon,\n\t\t\t      struct cifs_sb_info *cifs_sb,\n\t\t\t      struct cifs_fattr *fattr,\n\t\t\t      const unsigned char *path);\nextern int E_md4hash(const unsigned char *passwd, unsigned char *p16,\n\t\t\tconst struct nls_table *codepage);\n\nextern struct TCP_Server_Info *\ncifs_find_tcp_session(struct smb3_fs_context *ctx);\n\nvoid __cifs_put_smb_ses(struct cifs_ses *ses);\n\nextern struct cifs_ses *\ncifs_get_smb_ses(struct TCP_Server_Info *server, struct smb3_fs_context *ctx);\n\nvoid cifs_readdata_release(struct kref *refcount);\nint cifs_async_readv(struct cifs_readdata *rdata);\nint cifs_readv_receive(struct TCP_Server_Info *server, struct mid_q_entry *mid);\n\nint cifs_async_writev(struct cifs_writedata *wdata,\n\t\t      void (*release)(struct kref *kref));\nvoid cifs_writev_complete(struct work_struct *work);\nstruct cifs_writedata *cifs_writedata_alloc(work_func_t complete);\nvoid cifs_writedata_release(struct kref *refcount);\nint cifs_query_mf_symlink(unsigned int xid, struct cifs_tcon *tcon,\n\t\t\t  struct cifs_sb_info *cifs_sb,\n\t\t\t  const unsigned char *path, char *pbuf,\n\t\t\t  unsigned int *pbytes_read);\nint cifs_create_mf_symlink(unsigned int xid, struct cifs_tcon *tcon,\n\t\t\t   struct cifs_sb_info *cifs_sb,\n\t\t\t   const unsigned char *path, char *pbuf,\n\t\t\t   unsigned int *pbytes_written);\nint __cifs_calc_signature(struct smb_rqst *rqst,\n\t\t\tstruct TCP_Server_Info *server, char *signature,\n\t\t\tstruct shash_desc *shash);\nenum securityEnum cifs_select_sectype(struct TCP_Server_Info *,\n\t\t\t\t\tenum securityEnum);\nstruct cifs_aio_ctx *cifs_aio_ctx_alloc(void);\nvoid cifs_aio_ctx_release(struct kref *refcount);\n\nint cifs_alloc_hash(const char *name, struct shash_desc **sdesc);\nvoid cifs_free_hash(struct shash_desc **sdesc);\n\nstruct cifs_chan *\ncifs_ses_find_chan(struct cifs_ses *ses, struct TCP_Server_Info *server);\nint cifs_try_adding_channels(struct cifs_ses *ses);\nbool is_server_using_iface(struct TCP_Server_Info *server,\n\t\t\t   struct cifs_server_iface *iface);\nbool is_ses_using_iface(struct cifs_ses *ses, struct cifs_server_iface *iface);\nvoid cifs_ses_mark_for_reconnect(struct cifs_ses *ses);\n\nunsigned int\ncifs_ses_get_chan_index(struct cifs_ses *ses,\n\t\t\tstruct TCP_Server_Info *server);\nvoid\ncifs_chan_set_in_reconnect(struct cifs_ses *ses,\n\t\t\t     struct TCP_Server_Info *server);\nvoid\ncifs_chan_clear_in_reconnect(struct cifs_ses *ses,\n\t\t\t       struct TCP_Server_Info *server);\nbool\ncifs_chan_in_reconnect(struct cifs_ses *ses,\n\t\t\t  struct TCP_Server_Info *server);\nvoid\ncifs_chan_set_need_reconnect(struct cifs_ses *ses,\n\t\t\t     struct TCP_Server_Info *server);\nvoid\ncifs_chan_clear_need_reconnect(struct cifs_ses *ses,\n\t\t\t       struct TCP_Server_Info *server);\nbool\ncifs_chan_needs_reconnect(struct cifs_ses *ses,\n\t\t\t  struct TCP_Server_Info *server);\nbool\ncifs_chan_is_iface_active(struct cifs_ses *ses,\n\t\t\t  struct TCP_Server_Info *server);\nint\ncifs_chan_update_iface(struct cifs_ses *ses, struct TCP_Server_Info *server);\nint\nSMB3_request_interfaces(const unsigned int xid, struct cifs_tcon *tcon, bool in_mount);\n\nvoid extract_unc_hostname(const char *unc, const char **h, size_t *len);\nint copy_path_name(char *dst, const char *src);\nint smb2_parse_query_directory(struct cifs_tcon *tcon, struct kvec *rsp_iov,\n\t\t\t       int resp_buftype,\n\t\t\t       struct cifs_search_info *srch_inf);\n\nstruct super_block *cifs_get_dfs_tcon_super(struct cifs_tcon *tcon);\nvoid cifs_put_tcp_super(struct super_block *sb);\nint cifs_update_super_prepath(struct cifs_sb_info *cifs_sb, char *prefix);\nchar *extract_hostname(const char *unc);\nchar *extract_sharename(const char *unc);\nint parse_reparse_point(struct reparse_data_buffer *buf,\n\t\t\tu32 plen, struct cifs_sb_info *cifs_sb,\n\t\t\tbool unicode, struct cifs_open_info_data *data);\n\n#ifdef CONFIG_CIFS_DFS_UPCALL\nstatic inline int get_dfs_path(const unsigned int xid, struct cifs_ses *ses,\n\t\t\t       const char *old_path,\n\t\t\t       const struct nls_table *nls_codepage,\n\t\t\t       struct dfs_info3_param *referral, int remap)\n{\n\treturn dfs_cache_find(xid, ses, nls_codepage, remap, old_path,\n\t\t\t      referral, NULL);\n}\n\nint match_target_ip(struct TCP_Server_Info *server,\n\t\t    const char *share, size_t share_len,\n\t\t    bool *result);\nint cifs_inval_name_dfs_link_error(const unsigned int xid,\n\t\t\t\t   struct cifs_tcon *tcon,\n\t\t\t\t   struct cifs_sb_info *cifs_sb,\n\t\t\t\t   const char *full_path,\n\t\t\t\t   bool *islink);\n#else\nstatic inline int cifs_inval_name_dfs_link_error(const unsigned int xid,\n\t\t\t\t   struct cifs_tcon *tcon,\n\t\t\t\t   struct cifs_sb_info *cifs_sb,\n\t\t\t\t   const char *full_path,\n\t\t\t\t   bool *islink)\n{\n\t*islink = false;\n\treturn 0;\n}\n#endif\n\nstatic inline int cifs_create_options(struct cifs_sb_info *cifs_sb, int options)\n{\n\tif (cifs_sb && (backup_cred(cifs_sb)))\n\t\treturn options | CREATE_OPEN_BACKUP_INTENT;\n\telse\n\t\treturn options;\n}\n\nstruct super_block *cifs_get_tcon_super(struct cifs_tcon *tcon);\nvoid cifs_put_tcon_super(struct super_block *sb);\nint cifs_wait_for_server_reconnect(struct TCP_Server_Info *server, bool retry);\n\n \nstatic inline void cifs_put_smb_ses(struct cifs_ses *ses)\n{\n\tstruct cifs_ses *rses = ses->dfs_root_ses;\n\n\t__cifs_put_smb_ses(ses);\n\tif (rses)\n\t\t__cifs_put_smb_ses(rses);\n}\n\n \nstatic inline void cifs_smb_ses_inc_refcount(struct cifs_ses *ses)\n{\n\tlockdep_assert_held(&cifs_tcp_ses_lock);\n\n\tses->ses_count++;\n\tif (ses->dfs_root_ses)\n\t\tses->dfs_root_ses->ses_count++;\n}\n\nstatic inline bool dfs_src_pathname_equal(const char *s1, const char *s2)\n{\n\tif (strlen(s1) != strlen(s2))\n\t\treturn false;\n\tfor (; *s1; s1++, s2++) {\n\t\tif (*s1 == '/' || *s1 == '\\\\') {\n\t\t\tif (*s2 != '/' && *s2 != '\\\\')\n\t\t\t\treturn false;\n\t\t} else if (tolower(*s1) != tolower(*s2))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic inline void release_mid(struct mid_q_entry *mid)\n{\n\tkref_put(&mid->refcount, __release_mid);\n}\n\n#endif\t\t\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}