{
  "module_name": "cached_dir.c",
  "hash_id": "1fe909e4bcb9154efbee741d4c66cec9e4cc960cddcb9f31d5cc50ce63c232dd",
  "original_prompt": "Ingested from linux-6.6.14/fs/smb/client/cached_dir.c",
  "human_readable_source": "\n \n\n#include <linux/namei.h>\n#include \"cifsglob.h\"\n#include \"cifsproto.h\"\n#include \"cifs_debug.h\"\n#include \"smb2proto.h\"\n#include \"cached_dir.h\"\n\nstatic struct cached_fid *init_cached_dir(const char *path);\nstatic void free_cached_dir(struct cached_fid *cfid);\nstatic void smb2_close_cached_fid(struct kref *ref);\nstatic void cfids_laundromat_worker(struct work_struct *work);\n\nstatic struct cached_fid *find_or_create_cached_dir(struct cached_fids *cfids,\n\t\t\t\t\t\t    const char *path,\n\t\t\t\t\t\t    bool lookup_only,\n\t\t\t\t\t\t    __u32 max_cached_dirs)\n{\n\tstruct cached_fid *cfid;\n\n\tspin_lock(&cfids->cfid_list_lock);\n\tlist_for_each_entry(cfid, &cfids->entries, entry) {\n\t\tif (!strcmp(cfid->path, path)) {\n\t\t\t \n\t\t\tif (!cfid->time || !cfid->has_lease) {\n\t\t\t\tspin_unlock(&cfids->cfid_list_lock);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tkref_get(&cfid->refcount);\n\t\t\tspin_unlock(&cfids->cfid_list_lock);\n\t\t\treturn cfid;\n\t\t}\n\t}\n\tif (lookup_only) {\n\t\tspin_unlock(&cfids->cfid_list_lock);\n\t\treturn NULL;\n\t}\n\tif (cfids->num_entries >= max_cached_dirs) {\n\t\tspin_unlock(&cfids->cfid_list_lock);\n\t\treturn NULL;\n\t}\n\tcfid = init_cached_dir(path);\n\tif (cfid == NULL) {\n\t\tspin_unlock(&cfids->cfid_list_lock);\n\t\treturn NULL;\n\t}\n\tcfid->cfids = cfids;\n\tcfids->num_entries++;\n\tlist_add(&cfid->entry, &cfids->entries);\n\tcfid->on_list = true;\n\tkref_get(&cfid->refcount);\n\tspin_unlock(&cfids->cfid_list_lock);\n\treturn cfid;\n}\n\nstatic struct dentry *\npath_to_dentry(struct cifs_sb_info *cifs_sb, const char *path)\n{\n\tstruct dentry *dentry;\n\tconst char *s, *p;\n\tchar sep;\n\n\tsep = CIFS_DIR_SEP(cifs_sb);\n\tdentry = dget(cifs_sb->root);\n\ts = path;\n\n\tdo {\n\t\tstruct inode *dir = d_inode(dentry);\n\t\tstruct dentry *child;\n\n\t\tif (!S_ISDIR(dir->i_mode)) {\n\t\t\tdput(dentry);\n\t\t\tdentry = ERR_PTR(-ENOTDIR);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\twhile (*s == sep)\n\t\t\ts++;\n\t\tif (!*s)\n\t\t\tbreak;\n\t\tp = s++;\n\t\t \n\t\twhile (*s && *s != sep)\n\t\t\ts++;\n\n\t\tchild = lookup_positive_unlocked(p, dentry, s - p);\n\t\tdput(dentry);\n\t\tdentry = child;\n\t} while (!IS_ERR(dentry));\n\treturn dentry;\n}\n\nstatic const char *path_no_prefix(struct cifs_sb_info *cifs_sb,\n\t\t\t\t  const char *path)\n{\n\tsize_t len = 0;\n\n\tif (!*path)\n\t\treturn path;\n\n\tif ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_USE_PREFIX_PATH) &&\n\t    cifs_sb->prepath) {\n\t\tlen = strlen(cifs_sb->prepath) + 1;\n\t\tif (unlikely(len > strlen(path)))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t}\n\treturn path + len;\n}\n\n \nint open_cached_dir(unsigned int xid, struct cifs_tcon *tcon,\n\t\t    const char *path,\n\t\t    struct cifs_sb_info *cifs_sb,\n\t\t    bool lookup_only, struct cached_fid **ret_cfid)\n{\n\tstruct cifs_ses *ses;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_open_parms oparms;\n\tstruct smb2_create_rsp *o_rsp = NULL;\n\tstruct smb2_query_info_rsp *qi_rsp = NULL;\n\tint resp_buftype[2];\n\tstruct smb_rqst rqst[2];\n\tstruct kvec rsp_iov[2];\n\tstruct kvec open_iov[SMB2_CREATE_IOV_SIZE];\n\tstruct kvec qi_iov[1];\n\tint rc, flags = 0;\n\t__le16 *utf16_path = NULL;\n\tu8 oplock = SMB2_OPLOCK_LEVEL_II;\n\tstruct cifs_fid *pfid;\n\tstruct dentry *dentry = NULL;\n\tstruct cached_fid *cfid;\n\tstruct cached_fids *cfids;\n\tconst char *npath;\n\n\tif (tcon == NULL || tcon->cfids == NULL || tcon->nohandlecache ||\n\t    is_smb1_server(tcon->ses->server) || (dir_cache_timeout == 0))\n\t\treturn -EOPNOTSUPP;\n\n\tses = tcon->ses;\n\tserver = ses->server;\n\tcfids = tcon->cfids;\n\n\tif (!server->ops->new_lease_key)\n\t\treturn -EIO;\n\n\tif (cifs_sb->root == NULL)\n\t\treturn -ENOENT;\n\n\tutf16_path = cifs_convert_path_to_utf16(path, cifs_sb);\n\tif (!utf16_path)\n\t\treturn -ENOMEM;\n\n\tcfid = find_or_create_cached_dir(cfids, path, lookup_only, tcon->max_cached_dirs);\n\tif (cfid == NULL) {\n\t\tkfree(utf16_path);\n\t\treturn -ENOENT;\n\t}\n\t \n\tspin_lock(&cfids->cfid_list_lock);\n\tif (cfid->has_lease) {\n\t\tspin_unlock(&cfids->cfid_list_lock);\n\t\t*ret_cfid = cfid;\n\t\tkfree(utf16_path);\n\t\treturn 0;\n\t}\n\tspin_unlock(&cfids->cfid_list_lock);\n\n\t \n\tnpath = path_no_prefix(cifs_sb, path);\n\tif (IS_ERR(npath)) {\n\t\trc = PTR_ERR(npath);\n\t\tgoto out;\n\t}\n\n\tif (!npath[0]) {\n\t\tdentry = dget(cifs_sb->root);\n\t} else {\n\t\tdentry = path_to_dentry(cifs_sb, npath);\n\t\tif (IS_ERR(dentry)) {\n\t\t\trc = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tcfid->dentry = dentry;\n\n\t \n\tif (smb3_encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\tpfid = &cfid->fid;\n\tserver->ops->new_lease_key(pfid);\n\n\tmemset(rqst, 0, sizeof(rqst));\n\tresp_buftype[0] = resp_buftype[1] = CIFS_NO_BUFFER;\n\tmemset(rsp_iov, 0, sizeof(rsp_iov));\n\n\t \n\tmemset(&open_iov, 0, sizeof(open_iov));\n\trqst[0].rq_iov = open_iov;\n\trqst[0].rq_nvec = SMB2_CREATE_IOV_SIZE;\n\n\toparms = (struct cifs_open_parms) {\n\t\t.tcon = tcon,\n\t\t.path = path,\n\t\t.create_options = cifs_create_options(cifs_sb, CREATE_NOT_FILE),\n\t\t.desired_access =  FILE_READ_DATA | FILE_READ_ATTRIBUTES,\n\t\t.disposition = FILE_OPEN,\n\t\t.fid = pfid,\n\t};\n\n\trc = SMB2_open_init(tcon, server,\n\t\t\t    &rqst[0], &oplock, &oparms, utf16_path);\n\tif (rc)\n\t\tgoto oshr_free;\n\tsmb2_set_next_command(tcon, &rqst[0]);\n\n\tmemset(&qi_iov, 0, sizeof(qi_iov));\n\trqst[1].rq_iov = qi_iov;\n\trqst[1].rq_nvec = 1;\n\n\trc = SMB2_query_info_init(tcon, server,\n\t\t\t\t  &rqst[1], COMPOUND_FID,\n\t\t\t\t  COMPOUND_FID, FILE_ALL_INFORMATION,\n\t\t\t\t  SMB2_O_INFO_FILE, 0,\n\t\t\t\t  sizeof(struct smb2_file_all_info) +\n\t\t\t\t  PATH_MAX * 2, 0, NULL);\n\tif (rc)\n\t\tgoto oshr_free;\n\n\tsmb2_set_related(&rqst[1]);\n\n\t \n\tcfid->has_lease = true;\n\n\trc = compound_send_recv(xid, ses, server,\n\t\t\t\tflags, 2, rqst,\n\t\t\t\tresp_buftype, rsp_iov);\n\tif (rc) {\n\t\tif (rc == -EREMCHG) {\n\t\t\ttcon->need_reconnect = true;\n\t\t\tpr_warn_once(\"server share %s deleted\\n\",\n\t\t\t\t     tcon->tree_name);\n\t\t}\n\t\tgoto oshr_free;\n\t}\n\tcfid->tcon = tcon;\n\tcfid->is_open = true;\n\n\tspin_lock(&cfids->cfid_list_lock);\n\n\to_rsp = (struct smb2_create_rsp *)rsp_iov[0].iov_base;\n\toparms.fid->persistent_fid = o_rsp->PersistentFileId;\n\toparms.fid->volatile_fid = o_rsp->VolatileFileId;\n#ifdef CONFIG_CIFS_DEBUG2\n\toparms.fid->mid = le64_to_cpu(o_rsp->hdr.MessageId);\n#endif  \n\n\n\tif (o_rsp->OplockLevel != SMB2_OPLOCK_LEVEL_LEASE) {\n\t\tspin_unlock(&cfids->cfid_list_lock);\n\t\trc = -EINVAL;\n\t\tgoto oshr_free;\n\t}\n\n\trc = smb2_parse_contexts(server, rsp_iov,\n\t\t\t\t &oparms.fid->epoch,\n\t\t\t\t oparms.fid->lease_key,\n\t\t\t\t &oplock, NULL, NULL);\n\tif (rc) {\n\t\tspin_unlock(&cfids->cfid_list_lock);\n\t\tgoto oshr_free;\n\t}\n\n\trc = -EINVAL;\n\tif (!(oplock & SMB2_LEASE_READ_CACHING_HE)) {\n\t\tspin_unlock(&cfids->cfid_list_lock);\n\t\tgoto oshr_free;\n\t}\n\tqi_rsp = (struct smb2_query_info_rsp *)rsp_iov[1].iov_base;\n\tif (le32_to_cpu(qi_rsp->OutputBufferLength) < sizeof(struct smb2_file_all_info)) {\n\t\tspin_unlock(&cfids->cfid_list_lock);\n\t\tgoto oshr_free;\n\t}\n\tif (!smb2_validate_and_copy_iov(\n\t\t\t\tle16_to_cpu(qi_rsp->OutputBufferOffset),\n\t\t\t\tsizeof(struct smb2_file_all_info),\n\t\t\t\t&rsp_iov[1], sizeof(struct smb2_file_all_info),\n\t\t\t\t(char *)&cfid->file_all_info))\n\t\tcfid->file_all_info_is_valid = true;\n\n\tcfid->time = jiffies;\n\tspin_unlock(&cfids->cfid_list_lock);\n\t \n\trc = 0;\n\noshr_free:\n\tSMB2_open_free(&rqst[0]);\n\tSMB2_query_info_free(&rqst[1]);\n\tfree_rsp_buf(resp_buftype[0], rsp_iov[0].iov_base);\n\tfree_rsp_buf(resp_buftype[1], rsp_iov[1].iov_base);\n\tif (rc) {\n\t\tspin_lock(&cfids->cfid_list_lock);\n\t\tif (cfid->on_list) {\n\t\t\tlist_del(&cfid->entry);\n\t\t\tcfid->on_list = false;\n\t\t\tcfids->num_entries--;\n\t\t}\n\t\tif (cfid->has_lease) {\n\t\t\t \n\t\t\tcfid->has_lease = false;\n\t\t\tspin_unlock(&cfids->cfid_list_lock);\n\t\t\tkref_put(&cfid->refcount, smb2_close_cached_fid);\n\t\t\tgoto out;\n\t\t}\n\t\tspin_unlock(&cfids->cfid_list_lock);\n\t}\nout:\n\tif (rc) {\n\t\tif (cfid->is_open)\n\t\t\tSMB2_close(0, cfid->tcon, cfid->fid.persistent_fid,\n\t\t\t\t   cfid->fid.volatile_fid);\n\t\tfree_cached_dir(cfid);\n\t} else {\n\t\t*ret_cfid = cfid;\n\t\tatomic_inc(&tcon->num_remote_opens);\n\t}\n\tkfree(utf16_path);\n\treturn rc;\n}\n\nint open_cached_dir_by_dentry(struct cifs_tcon *tcon,\n\t\t\t      struct dentry *dentry,\n\t\t\t      struct cached_fid **ret_cfid)\n{\n\tstruct cached_fid *cfid;\n\tstruct cached_fids *cfids = tcon->cfids;\n\n\tif (cfids == NULL)\n\t\treturn -ENOENT;\n\n\tspin_lock(&cfids->cfid_list_lock);\n\tlist_for_each_entry(cfid, &cfids->entries, entry) {\n\t\tif (dentry && cfid->dentry == dentry) {\n\t\t\tcifs_dbg(FYI, \"found a cached root file handle by dentry\\n\");\n\t\t\tkref_get(&cfid->refcount);\n\t\t\t*ret_cfid = cfid;\n\t\t\tspin_unlock(&cfids->cfid_list_lock);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tspin_unlock(&cfids->cfid_list_lock);\n\treturn -ENOENT;\n}\n\nstatic void\nsmb2_close_cached_fid(struct kref *ref)\n{\n\tstruct cached_fid *cfid = container_of(ref, struct cached_fid,\n\t\t\t\t\t       refcount);\n\n\tspin_lock(&cfid->cfids->cfid_list_lock);\n\tif (cfid->on_list) {\n\t\tlist_del(&cfid->entry);\n\t\tcfid->on_list = false;\n\t\tcfid->cfids->num_entries--;\n\t}\n\tspin_unlock(&cfid->cfids->cfid_list_lock);\n\n\tdput(cfid->dentry);\n\tcfid->dentry = NULL;\n\n\tif (cfid->is_open) {\n\t\tSMB2_close(0, cfid->tcon, cfid->fid.persistent_fid,\n\t\t\t   cfid->fid.volatile_fid);\n\t\tatomic_dec(&cfid->tcon->num_remote_opens);\n\t}\n\n\tfree_cached_dir(cfid);\n}\n\nvoid drop_cached_dir_by_name(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\t     const char *name, struct cifs_sb_info *cifs_sb)\n{\n\tstruct cached_fid *cfid = NULL;\n\tint rc;\n\n\trc = open_cached_dir(xid, tcon, name, cifs_sb, true, &cfid);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"no cached dir found for rmdir(%s)\\n\", name);\n\t\treturn;\n\t}\n\tspin_lock(&cfid->cfids->cfid_list_lock);\n\tif (cfid->has_lease) {\n\t\tcfid->has_lease = false;\n\t\tkref_put(&cfid->refcount, smb2_close_cached_fid);\n\t}\n\tspin_unlock(&cfid->cfids->cfid_list_lock);\n\tclose_cached_dir(cfid);\n}\n\n\nvoid close_cached_dir(struct cached_fid *cfid)\n{\n\tkref_put(&cfid->refcount, smb2_close_cached_fid);\n}\n\n \nvoid close_all_cached_dirs(struct cifs_sb_info *cifs_sb)\n{\n\tstruct rb_root *root = &cifs_sb->tlink_tree;\n\tstruct rb_node *node;\n\tstruct cached_fid *cfid;\n\tstruct cifs_tcon *tcon;\n\tstruct tcon_link *tlink;\n\tstruct cached_fids *cfids;\n\n\tfor (node = rb_first(root); node; node = rb_next(node)) {\n\t\ttlink = rb_entry(node, struct tcon_link, tl_rbnode);\n\t\ttcon = tlink_tcon(tlink);\n\t\tif (IS_ERR(tcon))\n\t\t\tcontinue;\n\t\tcfids = tcon->cfids;\n\t\tif (cfids == NULL)\n\t\t\tcontinue;\n\t\tlist_for_each_entry(cfid, &cfids->entries, entry) {\n\t\t\tdput(cfid->dentry);\n\t\t\tcfid->dentry = NULL;\n\t\t}\n\t}\n}\n\n \nvoid invalidate_all_cached_dirs(struct cifs_tcon *tcon)\n{\n\tstruct cached_fids *cfids = tcon->cfids;\n\tstruct cached_fid *cfid, *q;\n\tLIST_HEAD(entry);\n\n\tif (cfids == NULL)\n\t\treturn;\n\n\tspin_lock(&cfids->cfid_list_lock);\n\tlist_for_each_entry_safe(cfid, q, &cfids->entries, entry) {\n\t\tlist_move(&cfid->entry, &entry);\n\t\tcfids->num_entries--;\n\t\tcfid->is_open = false;\n\t\tcfid->on_list = false;\n\t\t \n\t\tkref_get(&cfid->refcount);\n\t}\n\tspin_unlock(&cfids->cfid_list_lock);\n\n\tlist_for_each_entry_safe(cfid, q, &entry, entry) {\n\t\tlist_del(&cfid->entry);\n\t\tcancel_work_sync(&cfid->lease_break);\n\t\tif (cfid->has_lease) {\n\t\t\t \n\t\t\tspin_lock(&cfids->cfid_list_lock);\n\t\t\tcfid->has_lease = false;\n\t\t\tspin_unlock(&cfids->cfid_list_lock);\n\t\t\tkref_put(&cfid->refcount, smb2_close_cached_fid);\n\t\t}\n\t\t \n\t\tkref_put(&cfid->refcount, smb2_close_cached_fid);\n\t}\n}\n\nstatic void\nsmb2_cached_lease_break(struct work_struct *work)\n{\n\tstruct cached_fid *cfid = container_of(work,\n\t\t\t\tstruct cached_fid, lease_break);\n\n\tspin_lock(&cfid->cfids->cfid_list_lock);\n\tcfid->has_lease = false;\n\tspin_unlock(&cfid->cfids->cfid_list_lock);\n\tkref_put(&cfid->refcount, smb2_close_cached_fid);\n}\n\nint cached_dir_lease_break(struct cifs_tcon *tcon, __u8 lease_key[16])\n{\n\tstruct cached_fids *cfids = tcon->cfids;\n\tstruct cached_fid *cfid;\n\n\tif (cfids == NULL)\n\t\treturn false;\n\n\tspin_lock(&cfids->cfid_list_lock);\n\tlist_for_each_entry(cfid, &cfids->entries, entry) {\n\t\tif (cfid->has_lease &&\n\t\t    !memcmp(lease_key,\n\t\t\t    cfid->fid.lease_key,\n\t\t\t    SMB2_LEASE_KEY_SIZE)) {\n\t\t\tcfid->time = 0;\n\t\t\t \n\t\t\tlist_del(&cfid->entry);\n\t\t\tcfid->on_list = false;\n\t\t\tcfids->num_entries--;\n\n\t\t\tqueue_work(cifsiod_wq,\n\t\t\t\t   &cfid->lease_break);\n\t\t\tspin_unlock(&cfids->cfid_list_lock);\n\t\t\treturn true;\n\t\t}\n\t}\n\tspin_unlock(&cfids->cfid_list_lock);\n\treturn false;\n}\n\nstatic struct cached_fid *init_cached_dir(const char *path)\n{\n\tstruct cached_fid *cfid;\n\n\tcfid = kzalloc(sizeof(*cfid), GFP_ATOMIC);\n\tif (!cfid)\n\t\treturn NULL;\n\tcfid->path = kstrdup(path, GFP_ATOMIC);\n\tif (!cfid->path) {\n\t\tkfree(cfid);\n\t\treturn NULL;\n\t}\n\n\tINIT_WORK(&cfid->lease_break, smb2_cached_lease_break);\n\tINIT_LIST_HEAD(&cfid->entry);\n\tINIT_LIST_HEAD(&cfid->dirents.entries);\n\tmutex_init(&cfid->dirents.de_mutex);\n\tspin_lock_init(&cfid->fid_lock);\n\tkref_init(&cfid->refcount);\n\treturn cfid;\n}\n\nstatic void free_cached_dir(struct cached_fid *cfid)\n{\n\tstruct cached_dirent *dirent, *q;\n\n\tdput(cfid->dentry);\n\tcfid->dentry = NULL;\n\n\t \n\tlist_for_each_entry_safe(dirent, q, &cfid->dirents.entries, entry) {\n\t\tlist_del(&dirent->entry);\n\t\tkfree(dirent->name);\n\t\tkfree(dirent);\n\t}\n\n\tkfree(cfid->path);\n\tcfid->path = NULL;\n\tkfree(cfid);\n}\n\nstatic void cfids_laundromat_worker(struct work_struct *work)\n{\n\tstruct cached_fids *cfids;\n\tstruct cached_fid *cfid, *q;\n\tLIST_HEAD(entry);\n\n\tcfids = container_of(work, struct cached_fids, laundromat_work.work);\n\n\tspin_lock(&cfids->cfid_list_lock);\n\tlist_for_each_entry_safe(cfid, q, &cfids->entries, entry) {\n\t\tif (cfid->time &&\n\t\t    time_after(jiffies, cfid->time + HZ * dir_cache_timeout)) {\n\t\t\tcfid->on_list = false;\n\t\t\tlist_move(&cfid->entry, &entry);\n\t\t\tcfids->num_entries--;\n\t\t\t \n\t\t\tkref_get(&cfid->refcount);\n\t\t}\n\t}\n\tspin_unlock(&cfids->cfid_list_lock);\n\n\tlist_for_each_entry_safe(cfid, q, &entry, entry) {\n\t\tlist_del(&cfid->entry);\n\t\t \n\t\tcancel_work_sync(&cfid->lease_break);\n\t\tif (cfid->has_lease) {\n\t\t\t \n\t\t\tspin_lock(&cfids->cfid_list_lock);\n\t\t\tcfid->has_lease = false;\n\t\t\tspin_unlock(&cfids->cfid_list_lock);\n\t\t\tkref_put(&cfid->refcount, smb2_close_cached_fid);\n\t\t}\n\t\t \n\t\tkref_put(&cfid->refcount, smb2_close_cached_fid);\n\t}\n\tqueue_delayed_work(cifsiod_wq, &cfids->laundromat_work,\n\t\t\t   dir_cache_timeout * HZ);\n}\n\nstruct cached_fids *init_cached_dirs(void)\n{\n\tstruct cached_fids *cfids;\n\n\tcfids = kzalloc(sizeof(*cfids), GFP_KERNEL);\n\tif (!cfids)\n\t\treturn NULL;\n\tspin_lock_init(&cfids->cfid_list_lock);\n\tINIT_LIST_HEAD(&cfids->entries);\n\n\tINIT_DELAYED_WORK(&cfids->laundromat_work, cfids_laundromat_worker);\n\tqueue_delayed_work(cifsiod_wq, &cfids->laundromat_work,\n\t\t\t   dir_cache_timeout * HZ);\n\n\treturn cfids;\n}\n\n \nvoid free_cached_dirs(struct cached_fids *cfids)\n{\n\tstruct cached_fid *cfid, *q;\n\tLIST_HEAD(entry);\n\n\tif (cfids == NULL)\n\t\treturn;\n\n\tcancel_delayed_work_sync(&cfids->laundromat_work);\n\n\tspin_lock(&cfids->cfid_list_lock);\n\tlist_for_each_entry_safe(cfid, q, &cfids->entries, entry) {\n\t\tcfid->on_list = false;\n\t\tcfid->is_open = false;\n\t\tlist_move(&cfid->entry, &entry);\n\t}\n\tspin_unlock(&cfids->cfid_list_lock);\n\n\tlist_for_each_entry_safe(cfid, q, &entry, entry) {\n\t\tlist_del(&cfid->entry);\n\t\tfree_cached_dir(cfid);\n\t}\n\n\tkfree(cfids);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}