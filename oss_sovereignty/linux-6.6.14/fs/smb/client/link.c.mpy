{
  "module_name": "link.c",
  "hash_id": "e2e029bc8ba5081e2fd542eb4beefe9f10878d0525449cc308695ac15dced871",
  "original_prompt": "Ingested from linux-6.6.14/fs/smb/client/link.c",
  "human_readable_source": "\n \n#include <linux/fs.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include \"cifsfs.h\"\n#include \"cifspdu.h\"\n#include \"cifsglob.h\"\n#include \"cifsproto.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifs_ioctl.h\"\n\n \n\n#define CIFS_MF_SYMLINK_LEN_OFFSET (4+1)\n#define CIFS_MF_SYMLINK_MD5_OFFSET (CIFS_MF_SYMLINK_LEN_OFFSET+(4+1))\n#define CIFS_MF_SYMLINK_LINK_OFFSET (CIFS_MF_SYMLINK_MD5_OFFSET+(32+1))\n#define CIFS_MF_SYMLINK_LINK_MAXLEN (1024)\n#define CIFS_MF_SYMLINK_FILE_SIZE \\\n\t(CIFS_MF_SYMLINK_LINK_OFFSET + CIFS_MF_SYMLINK_LINK_MAXLEN)\n\n#define CIFS_MF_SYMLINK_LEN_FORMAT \"XSym\\n%04u\\n\"\n#define CIFS_MF_SYMLINK_MD5_FORMAT \"%16phN\\n\"\n#define CIFS_MF_SYMLINK_MD5_ARGS(md5_hash) md5_hash\n\nstatic int\nsymlink_hash(unsigned int link_len, const char *link_str, u8 *md5_hash)\n{\n\tint rc;\n\tstruct shash_desc *md5 = NULL;\n\n\trc = cifs_alloc_hash(\"md5\", &md5);\n\tif (rc)\n\t\tgoto symlink_hash_err;\n\n\trc = crypto_shash_init(md5);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not init md5 shash\\n\", __func__);\n\t\tgoto symlink_hash_err;\n\t}\n\trc = crypto_shash_update(md5, link_str, link_len);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not update with link_str\\n\", __func__);\n\t\tgoto symlink_hash_err;\n\t}\n\trc = crypto_shash_final(md5, md5_hash);\n\tif (rc)\n\t\tcifs_dbg(VFS, \"%s: Could not generate md5 hash\\n\", __func__);\n\nsymlink_hash_err:\n\tcifs_free_hash(&md5);\n\treturn rc;\n}\n\nstatic int\nparse_mf_symlink(const u8 *buf, unsigned int buf_len, unsigned int *_link_len,\n\t\t char **_link_str)\n{\n\tint rc;\n\tunsigned int link_len;\n\tconst char *md5_str1;\n\tconst char *link_str;\n\tu8 md5_hash[16];\n\tchar md5_str2[34];\n\n\tif (buf_len != CIFS_MF_SYMLINK_FILE_SIZE)\n\t\treturn -EINVAL;\n\n\tmd5_str1 = (const char *)&buf[CIFS_MF_SYMLINK_MD5_OFFSET];\n\tlink_str = (const char *)&buf[CIFS_MF_SYMLINK_LINK_OFFSET];\n\n\trc = sscanf(buf, CIFS_MF_SYMLINK_LEN_FORMAT, &link_len);\n\tif (rc != 1)\n\t\treturn -EINVAL;\n\n\tif (link_len > CIFS_MF_SYMLINK_LINK_MAXLEN)\n\t\treturn -EINVAL;\n\n\trc = symlink_hash(link_len, link_str, md5_hash);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s: MD5 hash failure: %d\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\n\tscnprintf(md5_str2, sizeof(md5_str2),\n\t\t  CIFS_MF_SYMLINK_MD5_FORMAT,\n\t\t  CIFS_MF_SYMLINK_MD5_ARGS(md5_hash));\n\n\tif (strncmp(md5_str1, md5_str2, 17) != 0)\n\t\treturn -EINVAL;\n\n\tif (_link_str) {\n\t\t*_link_str = kstrndup(link_str, link_len, GFP_KERNEL);\n\t\tif (!*_link_str)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t*_link_len = link_len;\n\treturn 0;\n}\n\nstatic int\nformat_mf_symlink(u8 *buf, unsigned int buf_len, const char *link_str)\n{\n\tint rc;\n\tunsigned int link_len;\n\tunsigned int ofs;\n\tu8 md5_hash[16];\n\n\tif (buf_len != CIFS_MF_SYMLINK_FILE_SIZE)\n\t\treturn -EINVAL;\n\n\tlink_len = strlen(link_str);\n\n\tif (link_len > CIFS_MF_SYMLINK_LINK_MAXLEN)\n\t\treturn -ENAMETOOLONG;\n\n\trc = symlink_hash(link_len, link_str, md5_hash);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s: MD5 hash failure: %d\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\n\tscnprintf(buf, buf_len,\n\t\t  CIFS_MF_SYMLINK_LEN_FORMAT CIFS_MF_SYMLINK_MD5_FORMAT,\n\t\t  link_len,\n\t\t  CIFS_MF_SYMLINK_MD5_ARGS(md5_hash));\n\n\tofs = CIFS_MF_SYMLINK_LINK_OFFSET;\n\tmemcpy(buf + ofs, link_str, link_len);\n\n\tofs += link_len;\n\tif (ofs < CIFS_MF_SYMLINK_FILE_SIZE) {\n\t\tbuf[ofs] = '\\n';\n\t\tofs++;\n\t}\n\n\twhile (ofs < CIFS_MF_SYMLINK_FILE_SIZE) {\n\t\tbuf[ofs] = ' ';\n\t\tofs++;\n\t}\n\n\treturn 0;\n}\n\nbool\ncouldbe_mf_symlink(const struct cifs_fattr *fattr)\n{\n\tif (!S_ISREG(fattr->cf_mode))\n\t\t \n\t\treturn false;\n\n\tif (fattr->cf_eof != CIFS_MF_SYMLINK_FILE_SIZE)\n\t\t \n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int\ncreate_mf_symlink(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t  struct cifs_sb_info *cifs_sb, const char *fromName,\n\t\t  const char *toName)\n{\n\tint rc;\n\tu8 *buf;\n\tunsigned int bytes_written = 0;\n\n\tbuf = kmalloc(CIFS_MF_SYMLINK_FILE_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\trc = format_mf_symlink(buf, CIFS_MF_SYMLINK_FILE_SIZE, toName);\n\tif (rc)\n\t\tgoto out;\n\n\tif (tcon->ses->server->ops->create_mf_symlink)\n\t\trc = tcon->ses->server->ops->create_mf_symlink(xid, tcon,\n\t\t\t\t\tcifs_sb, fromName, buf, &bytes_written);\n\telse\n\t\trc = -EOPNOTSUPP;\n\n\tif (rc)\n\t\tgoto out;\n\n\tif (bytes_written != CIFS_MF_SYMLINK_FILE_SIZE)\n\t\trc = -EIO;\nout:\n\tkfree(buf);\n\treturn rc;\n}\n\nint\ncheck_mf_symlink(unsigned int xid, struct cifs_tcon *tcon,\n\t\t struct cifs_sb_info *cifs_sb, struct cifs_fattr *fattr,\n\t\t const unsigned char *path)\n{\n\tint rc;\n\tu8 *buf = NULL;\n\tunsigned int link_len = 0;\n\tunsigned int bytes_read = 0;\n\tchar *symlink = NULL;\n\n\tif (!couldbe_mf_symlink(fattr))\n\t\t \n\t\treturn 0;\n\n\tbuf = kmalloc(CIFS_MF_SYMLINK_FILE_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tif (tcon->ses->server->ops->query_mf_symlink)\n\t\trc = tcon->ses->server->ops->query_mf_symlink(xid, tcon,\n\t\t\t\t\t      cifs_sb, path, buf, &bytes_read);\n\telse\n\t\trc = -ENOSYS;\n\n\tif (rc)\n\t\tgoto out;\n\n\tif (bytes_read == 0)  \n\t\tgoto out;\n\n\trc = parse_mf_symlink(buf, bytes_read, &link_len, &symlink);\n\tif (rc == -EINVAL) {\n\t\t \n\t\trc = 0;\n\t\tgoto out;\n\t}\n\n\tif (rc != 0)\n\t\tgoto out;\n\n\t \n\tfattr->cf_eof = link_len;\n\tfattr->cf_mode &= ~S_IFMT;\n\tfattr->cf_mode |= S_IFLNK | S_IRWXU | S_IRWXG | S_IRWXO;\n\tfattr->cf_dtype = DT_LNK;\n\tfattr->cf_symlink_target = symlink;\nout:\n\tkfree(buf);\n\treturn rc;\n}\n\n#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY\n \n\nint\ncifs_query_mf_symlink(unsigned int xid, struct cifs_tcon *tcon,\n\t\t      struct cifs_sb_info *cifs_sb, const unsigned char *path,\n\t\t      char *pbuf, unsigned int *pbytes_read)\n{\n\tint rc;\n\tint oplock = 0;\n\tstruct cifs_fid fid;\n\tstruct cifs_open_parms oparms;\n\tstruct cifs_io_parms io_parms = {0};\n\tint buf_type = CIFS_NO_BUFFER;\n\tFILE_ALL_INFO file_info;\n\n\toparms = (struct cifs_open_parms) {\n\t\t.tcon = tcon,\n\t\t.cifs_sb = cifs_sb,\n\t\t.desired_access = GENERIC_READ,\n\t\t.create_options = cifs_create_options(cifs_sb, CREATE_NOT_DIR),\n\t\t.disposition = FILE_OPEN,\n\t\t.path = path,\n\t\t.fid = &fid,\n\t};\n\n\trc = CIFS_open(xid, &oparms, &oplock, &file_info);\n\tif (rc)\n\t\treturn rc;\n\n\tif (file_info.EndOfFile != cpu_to_le64(CIFS_MF_SYMLINK_FILE_SIZE)) {\n\t\trc = -ENOENT;\n\t\t \n\t\tgoto out;\n\t}\n\n\tio_parms.netfid = fid.netfid;\n\tio_parms.pid = current->tgid;\n\tio_parms.tcon = tcon;\n\tio_parms.offset = 0;\n\tio_parms.length = CIFS_MF_SYMLINK_FILE_SIZE;\n\n\trc = CIFSSMBRead(xid, &io_parms, pbytes_read, &pbuf, &buf_type);\nout:\n\tCIFSSMBClose(xid, tcon, fid.netfid);\n\treturn rc;\n}\n\nint\ncifs_create_mf_symlink(unsigned int xid, struct cifs_tcon *tcon,\n\t\t       struct cifs_sb_info *cifs_sb, const unsigned char *path,\n\t\t       char *pbuf, unsigned int *pbytes_written)\n{\n\tint rc;\n\tint oplock = 0;\n\tstruct cifs_fid fid;\n\tstruct cifs_open_parms oparms;\n\tstruct cifs_io_parms io_parms = {0};\n\n\toparms = (struct cifs_open_parms) {\n\t\t.tcon = tcon,\n\t\t.cifs_sb = cifs_sb,\n\t\t.desired_access = GENERIC_WRITE,\n\t\t.create_options = cifs_create_options(cifs_sb, CREATE_NOT_DIR),\n\t\t.disposition = FILE_CREATE,\n\t\t.path = path,\n\t\t.fid = &fid,\n\t};\n\n\trc = CIFS_open(xid, &oparms, &oplock, NULL);\n\tif (rc)\n\t\treturn rc;\n\n\tio_parms.netfid = fid.netfid;\n\tio_parms.pid = current->tgid;\n\tio_parms.tcon = tcon;\n\tio_parms.offset = 0;\n\tio_parms.length = CIFS_MF_SYMLINK_FILE_SIZE;\n\n\trc = CIFSSMBWrite(xid, &io_parms, pbytes_written, pbuf);\n\tCIFSSMBClose(xid, tcon, fid.netfid);\n\treturn rc;\n}\n#endif  \n\n \nint\nsmb3_query_mf_symlink(unsigned int xid, struct cifs_tcon *tcon,\n\t\t      struct cifs_sb_info *cifs_sb, const unsigned char *path,\n\t\t      char *pbuf, unsigned int *pbytes_read)\n{\n\tint rc;\n\tstruct cifs_fid fid;\n\tstruct cifs_open_parms oparms;\n\tstruct cifs_io_parms io_parms = {0};\n\tint buf_type = CIFS_NO_BUFFER;\n\t__le16 *utf16_path;\n\t__u8 oplock = SMB2_OPLOCK_LEVEL_NONE;\n\tstruct smb2_file_all_info *pfile_info = NULL;\n\n\toparms = (struct cifs_open_parms) {\n\t\t.tcon = tcon,\n\t\t.cifs_sb = cifs_sb,\n\t\t.path = path,\n\t\t.desired_access = GENERIC_READ,\n\t\t.create_options = cifs_create_options(cifs_sb, CREATE_NOT_DIR),\n\t\t.disposition = FILE_OPEN,\n\t\t.fid = &fid,\n\t};\n\n\tutf16_path = cifs_convert_path_to_utf16(path, cifs_sb);\n\tif (utf16_path == NULL)\n\t\treturn -ENOMEM;\n\n\tpfile_info = kzalloc(sizeof(struct smb2_file_all_info) + PATH_MAX * 2,\n\t\t\t     GFP_KERNEL);\n\n\tif (pfile_info == NULL) {\n\t\tkfree(utf16_path);\n\t\treturn  -ENOMEM;\n\t}\n\n\trc = SMB2_open(xid, &oparms, utf16_path, &oplock, pfile_info, NULL,\n\t\t       NULL, NULL);\n\tif (rc)\n\t\tgoto qmf_out_open_fail;\n\n\tif (pfile_info->EndOfFile != cpu_to_le64(CIFS_MF_SYMLINK_FILE_SIZE)) {\n\t\t \n\t\trc = -ENOENT;  \n\t\tgoto qmf_out;\n\t}\n\n\tio_parms.netfid = fid.netfid;\n\tio_parms.pid = current->tgid;\n\tio_parms.tcon = tcon;\n\tio_parms.offset = 0;\n\tio_parms.length = CIFS_MF_SYMLINK_FILE_SIZE;\n\tio_parms.persistent_fid = fid.persistent_fid;\n\tio_parms.volatile_fid = fid.volatile_fid;\n\trc = SMB2_read(xid, &io_parms, pbytes_read, &pbuf, &buf_type);\nqmf_out:\n\tSMB2_close(xid, tcon, fid.persistent_fid, fid.volatile_fid);\nqmf_out_open_fail:\n\tkfree(utf16_path);\n\tkfree(pfile_info);\n\treturn rc;\n}\n\nint\nsmb3_create_mf_symlink(unsigned int xid, struct cifs_tcon *tcon,\n\t\t       struct cifs_sb_info *cifs_sb, const unsigned char *path,\n\t\t       char *pbuf, unsigned int *pbytes_written)\n{\n\tint rc;\n\tstruct cifs_fid fid;\n\tstruct cifs_open_parms oparms;\n\tstruct cifs_io_parms io_parms = {0};\n\t__le16 *utf16_path;\n\t__u8 oplock = SMB2_OPLOCK_LEVEL_NONE;\n\tstruct kvec iov[2];\n\n\tcifs_dbg(FYI, \"%s: path: %s\\n\", __func__, path);\n\n\tutf16_path = cifs_convert_path_to_utf16(path, cifs_sb);\n\tif (!utf16_path)\n\t\treturn -ENOMEM;\n\n\toparms = (struct cifs_open_parms) {\n\t\t.tcon = tcon,\n\t\t.cifs_sb = cifs_sb,\n\t\t.path = path,\n\t\t.desired_access = GENERIC_WRITE,\n\t\t.create_options = cifs_create_options(cifs_sb, CREATE_NOT_DIR),\n\t\t.disposition = FILE_CREATE,\n\t\t.fid = &fid,\n\t\t.mode = 0644,\n\t};\n\n\trc = SMB2_open(xid, &oparms, utf16_path, &oplock, NULL, NULL,\n\t\t       NULL, NULL);\n\tif (rc) {\n\t\tkfree(utf16_path);\n\t\treturn rc;\n\t}\n\n\tio_parms.netfid = fid.netfid;\n\tio_parms.pid = current->tgid;\n\tio_parms.tcon = tcon;\n\tio_parms.offset = 0;\n\tio_parms.length = CIFS_MF_SYMLINK_FILE_SIZE;\n\tio_parms.persistent_fid = fid.persistent_fid;\n\tio_parms.volatile_fid = fid.volatile_fid;\n\n\t \n\tiov[1].iov_base = pbuf;\n\tiov[1].iov_len = CIFS_MF_SYMLINK_FILE_SIZE;\n\n\trc = SMB2_write(xid, &io_parms, pbytes_written, iov, 1);\n\n\t \n\tif ((rc == 0) && (*pbytes_written != CIFS_MF_SYMLINK_FILE_SIZE))\n\t\trc = -EIO;\n\n\tSMB2_close(xid, tcon, fid.persistent_fid, fid.volatile_fid);\n\n\tkfree(utf16_path);\n\treturn rc;\n}\n\n \n\nint\ncifs_hardlink(struct dentry *old_file, struct inode *inode,\n\t      struct dentry *direntry)\n{\n\tint rc = -EACCES;\n\tunsigned int xid;\n\tconst char *from_name, *to_name;\n\tvoid *page1, *page2;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tstruct cifsInodeInfo *cifsInode;\n\n\tif (unlikely(cifs_forced_shutdown(cifs_sb)))\n\t\treturn -EIO;\n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\ttcon = tlink_tcon(tlink);\n\n\txid = get_xid();\n\tpage1 = alloc_dentry_path();\n\tpage2 = alloc_dentry_path();\n\n\tfrom_name = build_path_from_dentry(old_file, page1);\n\tif (IS_ERR(from_name)) {\n\t\trc = PTR_ERR(from_name);\n\t\tgoto cifs_hl_exit;\n\t}\n\tto_name = build_path_from_dentry(direntry, page2);\n\tif (IS_ERR(to_name)) {\n\t\trc = PTR_ERR(to_name);\n\t\tgoto cifs_hl_exit;\n\t}\n\n#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY\n\tif (tcon->unix_ext)\n\t\trc = CIFSUnixCreateHardLink(xid, tcon, from_name, to_name,\n\t\t\t\t\t    cifs_sb->local_nls,\n\t\t\t\t\t    cifs_remap(cifs_sb));\n\telse {\n#else\n\t{\n#endif  \n\t\tserver = tcon->ses->server;\n\t\tif (!server->ops->create_hardlink) {\n\t\t\trc = -ENOSYS;\n\t\t\tgoto cifs_hl_exit;\n\t\t}\n\t\trc = server->ops->create_hardlink(xid, tcon, from_name, to_name,\n\t\t\t\t\t\t  cifs_sb);\n\t\tif ((rc == -EIO) || (rc == -EINVAL))\n\t\t\trc = -EOPNOTSUPP;\n\t}\n\n\td_drop(direntry);\t \n\n\t \n\tif (d_really_is_positive(old_file)) {\n\t\tcifsInode = CIFS_I(d_inode(old_file));\n\t\tif (rc == 0) {\n\t\t\tspin_lock(&d_inode(old_file)->i_lock);\n\t\t\tinc_nlink(d_inode(old_file));\n\t\t\tspin_unlock(&d_inode(old_file)->i_lock);\n\n\t\t\t \n\t\t}\n\t\t \n\t\tcifsInode->time = 0;\n\n\t\t \n\t}\n\ncifs_hl_exit:\n\tfree_dentry_path(page1);\n\tfree_dentry_path(page2);\n\tfree_xid(xid);\n\tcifs_put_tlink(tlink);\n\treturn rc;\n}\n\nint\ncifs_symlink(struct mnt_idmap *idmap, struct inode *inode,\n\t     struct dentry *direntry, const char *symname)\n{\n\tint rc = -EOPNOTSUPP;\n\tunsigned int xid;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *pTcon;\n\tconst char *full_path;\n\tvoid *page;\n\tstruct inode *newinode = NULL;\n\n\tif (unlikely(cifs_forced_shutdown(cifs_sb)))\n\t\treturn -EIO;\n\n\tpage = alloc_dentry_path();\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\txid = get_xid();\n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink)) {\n\t\trc = PTR_ERR(tlink);\n\t\tgoto symlink_exit;\n\t}\n\tpTcon = tlink_tcon(tlink);\n\n\tfull_path = build_path_from_dentry(direntry, page);\n\tif (IS_ERR(full_path)) {\n\t\trc = PTR_ERR(full_path);\n\t\tgoto symlink_exit;\n\t}\n\n\tcifs_dbg(FYI, \"Full path: %s\\n\", full_path);\n\tcifs_dbg(FYI, \"symname is %s\\n\", symname);\n\n\t \n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MF_SYMLINKS)\n\t\trc = create_mf_symlink(xid, pTcon, cifs_sb, full_path, symname);\n#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY\n\telse if (pTcon->unix_ext)\n\t\trc = CIFSUnixCreateSymLink(xid, pTcon, full_path, symname,\n\t\t\t\t\t   cifs_sb->local_nls,\n\t\t\t\t\t   cifs_remap(cifs_sb));\n#endif  \n\t \n\n\tif (rc == 0) {\n\t\tif (pTcon->posix_extensions)\n\t\t\trc = smb311_posix_get_inode_info(&newinode, full_path, inode->i_sb, xid);\n\t\telse if (pTcon->unix_ext)\n\t\t\trc = cifs_get_inode_info_unix(&newinode, full_path,\n\t\t\t\t\t\t      inode->i_sb, xid);\n\t\telse\n\t\t\trc = cifs_get_inode_info(&newinode, full_path, NULL,\n\t\t\t\t\t\t inode->i_sb, xid, NULL);\n\n\t\tif (rc != 0) {\n\t\t\tcifs_dbg(FYI, \"Create symlink ok, getinodeinfo fail rc = %d\\n\",\n\t\t\t\t rc);\n\t\t} else {\n\t\t\td_instantiate(direntry, newinode);\n\t\t}\n\t}\nsymlink_exit:\n\tfree_dentry_path(page);\n\tcifs_put_tlink(tlink);\n\tfree_xid(xid);\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}