{
  "module_name": "misc.c",
  "hash_id": "dfe40fffd6562a4f3fa5d9909a83c1aaa98c24ce4a457d0b79fcf5af37fad02c",
  "original_prompt": "Ingested from linux-6.6.14/fs/smb/client/misc.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/mempool.h>\n#include <linux/vmalloc.h>\n#include \"cifspdu.h\"\n#include \"cifsglob.h\"\n#include \"cifsproto.h\"\n#include \"cifs_debug.h\"\n#include \"smberr.h\"\n#include \"nterr.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2pdu.h\"\n#include \"cifsfs.h\"\n#ifdef CONFIG_CIFS_DFS_UPCALL\n#include \"dns_resolve.h\"\n#include \"dfs_cache.h\"\n#include \"dfs.h\"\n#endif\n#include \"fs_context.h\"\n#include \"cached_dir.h\"\n\nextern mempool_t *cifs_sm_req_poolp;\nextern mempool_t *cifs_req_poolp;\n\n \n\nunsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t \n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}\n\nvoid\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t \n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}\n\nstruct cifs_ses *\nsesInfoAlloc(void)\n{\n\tstruct cifs_ses *ret_buf;\n\n\tret_buf = kzalloc(sizeof(struct cifs_ses), GFP_KERNEL);\n\tif (ret_buf) {\n\t\tatomic_inc(&sesInfoAllocCount);\n\t\tspin_lock_init(&ret_buf->ses_lock);\n\t\tret_buf->ses_status = SES_NEW;\n\t\t++ret_buf->ses_count;\n\t\tINIT_LIST_HEAD(&ret_buf->smb_ses_list);\n\t\tINIT_LIST_HEAD(&ret_buf->tcon_list);\n\t\tmutex_init(&ret_buf->session_mutex);\n\t\tspin_lock_init(&ret_buf->iface_lock);\n\t\tINIT_LIST_HEAD(&ret_buf->iface_list);\n\t\tspin_lock_init(&ret_buf->chan_lock);\n\t}\n\treturn ret_buf;\n}\n\nvoid\nsesInfoFree(struct cifs_ses *buf_to_free)\n{\n\tstruct cifs_server_iface *iface = NULL, *niface = NULL;\n\n\tif (buf_to_free == NULL) {\n\t\tcifs_dbg(FYI, \"Null buffer passed to sesInfoFree\\n\");\n\t\treturn;\n\t}\n\n\tunload_nls(buf_to_free->local_nls);\n\tatomic_dec(&sesInfoAllocCount);\n\tkfree(buf_to_free->serverOS);\n\tkfree(buf_to_free->serverDomain);\n\tkfree(buf_to_free->serverNOS);\n\tkfree_sensitive(buf_to_free->password);\n\tkfree(buf_to_free->user_name);\n\tkfree(buf_to_free->domainName);\n\tkfree_sensitive(buf_to_free->auth_key.response);\n\tspin_lock(&buf_to_free->iface_lock);\n\tlist_for_each_entry_safe(iface, niface, &buf_to_free->iface_list,\n\t\t\t\t iface_head)\n\t\tkref_put(&iface->refcount, release_iface);\n\tspin_unlock(&buf_to_free->iface_lock);\n\tkfree_sensitive(buf_to_free);\n}\n\nstruct cifs_tcon *\ntcon_info_alloc(bool dir_leases_enabled)\n{\n\tstruct cifs_tcon *ret_buf;\n\n\tret_buf = kzalloc(sizeof(*ret_buf), GFP_KERNEL);\n\tif (!ret_buf)\n\t\treturn NULL;\n\n\tif (dir_leases_enabled == true) {\n\t\tret_buf->cfids = init_cached_dirs();\n\t\tif (!ret_buf->cfids) {\n\t\t\tkfree(ret_buf);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\t \n\n\tatomic_inc(&tconInfoAllocCount);\n\tret_buf->status = TID_NEW;\n\t++ret_buf->tc_count;\n\tspin_lock_init(&ret_buf->tc_lock);\n\tINIT_LIST_HEAD(&ret_buf->openFileList);\n\tINIT_LIST_HEAD(&ret_buf->tcon_list);\n\tspin_lock_init(&ret_buf->open_file_lock);\n\tspin_lock_init(&ret_buf->stat_lock);\n\tatomic_set(&ret_buf->num_local_opens, 0);\n\tatomic_set(&ret_buf->num_remote_opens, 0);\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\tINIT_LIST_HEAD(&ret_buf->dfs_ses_list);\n#endif\n\n\treturn ret_buf;\n}\n\nvoid\ntconInfoFree(struct cifs_tcon *tcon)\n{\n\tif (tcon == NULL) {\n\t\tcifs_dbg(FYI, \"Null buffer passed to tconInfoFree\\n\");\n\t\treturn;\n\t}\n\tfree_cached_dirs(tcon->cfids);\n\tatomic_dec(&tconInfoAllocCount);\n\tkfree(tcon->nativeFileSystem);\n\tkfree_sensitive(tcon->password);\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\tdfs_put_root_smb_sessions(&tcon->dfs_ses_list);\n#endif\n\tkfree(tcon->origin_fullpath);\n\tkfree(tcon);\n}\n\nstruct smb_hdr *\ncifs_buf_get(void)\n{\n\tstruct smb_hdr *ret_buf = NULL;\n\t \n\tsize_t buf_size = sizeof(struct smb2_hdr);\n\n\t \n\tret_buf = mempool_alloc(cifs_req_poolp, GFP_NOFS);\n\n\t \n\t \n\tmemset(ret_buf, 0, buf_size + 3);\n\tatomic_inc(&buf_alloc_count);\n#ifdef CONFIG_CIFS_STATS2\n\tatomic_inc(&total_buf_alloc_count);\n#endif  \n\n\treturn ret_buf;\n}\n\nvoid\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t \n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&buf_alloc_count);\n\treturn;\n}\n\nstruct smb_hdr *\ncifs_small_buf_get(void)\n{\n\tstruct smb_hdr *ret_buf = NULL;\n\n \n\tret_buf = mempool_alloc(cifs_sm_req_poolp, GFP_NOFS);\n\t \n\t \n\tatomic_inc(&small_buf_alloc_count);\n#ifdef CONFIG_CIFS_STATS2\n\tatomic_inc(&total_small_buf_alloc_count);\n#endif  \n\n\treturn ret_buf;\n}\n\nvoid\ncifs_small_buf_release(void *buf_to_free)\n{\n\n\tif (buf_to_free == NULL) {\n\t\tcifs_dbg(FYI, \"Null buffer passed to cifs_small_buf_release\\n\");\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_sm_req_poolp);\n\n\tatomic_dec(&small_buf_alloc_count);\n\treturn;\n}\n\nvoid\nfree_rsp_buf(int resp_buftype, void *rsp)\n{\n\tif (resp_buftype == CIFS_SMALL_BUFFER)\n\t\tcifs_small_buf_release(rsp);\n\telse if (resp_buftype == CIFS_LARGE_BUFFER)\n\t\tcifs_buf_release(rsp);\n}\n\n \nvoid\nheader_assemble(struct smb_hdr *buffer, char smb_command   ,\n\t\tconst struct cifs_tcon *treeCon, int word_count\n\t\t )\n{\n\tchar *temp = (char *) buffer;\n\n\tmemset(temp, 0, 256);  \n\n\tbuffer->smb_buf_length = cpu_to_be32(\n\t    (2 * word_count) + sizeof(struct smb_hdr) -\n\t    4    +\n\t    2  ) ;\n\n\tbuffer->Protocol[0] = 0xFF;\n\tbuffer->Protocol[1] = 'S';\n\tbuffer->Protocol[2] = 'M';\n\tbuffer->Protocol[3] = 'B';\n\tbuffer->Command = smb_command;\n\tbuffer->Flags = 0x00;\t \n\tbuffer->Flags2 = SMBFLG2_KNOWS_LONG_NAMES;\n\tbuffer->Pid = cpu_to_le16((__u16)current->tgid);\n\tbuffer->PidHigh = cpu_to_le16((__u16)(current->tgid >> 16));\n\tif (treeCon) {\n\t\tbuffer->Tid = treeCon->tid;\n\t\tif (treeCon->ses) {\n\t\t\tif (treeCon->ses->capabilities & CAP_UNICODE)\n\t\t\t\tbuffer->Flags2 |= SMBFLG2_UNICODE;\n\t\t\tif (treeCon->ses->capabilities & CAP_STATUS32)\n\t\t\t\tbuffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\n\t\t\t \n\t\t\tbuffer->Uid = treeCon->ses->Suid;\n\t\t\tif (treeCon->ses->server)\n\t\t\t\tbuffer->Mid = get_next_mid(treeCon->ses->server);\n\t\t}\n\t\tif (treeCon->Flags & SMB_SHARE_IS_IN_DFS)\n\t\t\tbuffer->Flags2 |= SMBFLG2_DFS;\n\t\tif (treeCon->nocase)\n\t\t\tbuffer->Flags  |= SMBFLG_CASELESS;\n\t\tif ((treeCon->ses) && (treeCon->ses->server))\n\t\t\tif (treeCon->ses->server->sign)\n\t\t\t\tbuffer->Flags2 |= SMBFLG2_SECURITY_SIGNATURE;\n\t}\n\n \n\tbuffer->WordCount = (char) word_count;\n\treturn;\n}\n\nstatic int\ncheck_smb_hdr(struct smb_hdr *smb)\n{\n\t \n\tif (*(__le32 *) smb->Protocol != cpu_to_le32(0x424d53ff)) {\n\t\tcifs_dbg(VFS, \"Bad protocol string signature header 0x%x\\n\",\n\t\t\t *(unsigned int *)smb->Protocol);\n\t\treturn 1;\n\t}\n\n\t \n\tif (smb->Flags & SMBFLG_RESPONSE)\n\t\treturn 0;\n\n\t \n\tif (smb->Command == SMB_COM_LOCKING_ANDX)\n\t\treturn 0;\n\n\tcifs_dbg(VFS, \"Server sent request, not response. mid=%u\\n\",\n\t\t get_mid(smb));\n\treturn 1;\n}\n\nint\ncheckSMB(char *buf, unsigned int total_read, struct TCP_Server_Info *server)\n{\n\tstruct smb_hdr *smb = (struct smb_hdr *)buf;\n\t__u32 rfclen = be32_to_cpu(smb->smb_buf_length);\n\t__u32 clc_len;   \n\tcifs_dbg(FYI, \"checkSMB Length: 0x%x, smb_buf_length: 0x%x\\n\",\n\t\t total_read, rfclen);\n\n\t \n\tif (total_read < 2 + sizeof(struct smb_hdr)) {\n\t\tif ((total_read >= sizeof(struct smb_hdr) - 1)\n\t\t\t    && (smb->Status.CifsError != 0)) {\n\t\t\t \n\t\t\tsmb->WordCount = 0;\n\t\t\t \n\t\t\treturn 0;\n\t\t} else if ((total_read == sizeof(struct smb_hdr) + 1) &&\n\t\t\t\t(smb->WordCount == 0)) {\n\t\t\tchar *tmp = (char *)smb;\n\t\t\t \n\t\t\t \n\t\t\tif (tmp[sizeof(struct smb_hdr)] == 0) {\n\t\t\t\t \n\t\t\t\t \n\t\t\t\ttmp[sizeof(struct smb_hdr)+1] = 0;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcifs_dbg(VFS, \"rcvd invalid byte count (bcc)\\n\");\n\t\t} else {\n\t\t\tcifs_dbg(VFS, \"Length less than smb header size\\n\");\n\t\t}\n\t\treturn -EIO;\n\t} else if (total_read < sizeof(*smb) + 2 * smb->WordCount) {\n\t\tcifs_dbg(VFS, \"%s: can't read BCC due to invalid WordCount(%u)\\n\",\n\t\t\t __func__, smb->WordCount);\n\t\treturn -EIO;\n\t}\n\n\t \n\tif (check_smb_hdr(smb))\n\t\treturn -EIO;\n\tclc_len = smbCalcSize(smb);\n\n\tif (4 + rfclen != total_read) {\n\t\tcifs_dbg(VFS, \"Length read does not match RFC1001 length %d\\n\",\n\t\t\t rfclen);\n\t\treturn -EIO;\n\t}\n\n\tif (4 + rfclen != clc_len) {\n\t\t__u16 mid = get_mid(smb);\n\t\t \n\t\tif ((rfclen > 64 * 1024) && (rfclen > clc_len)) {\n\t\t\t \n\t\t\tif (((4 + rfclen) & 0xFFFF) == (clc_len & 0xFFFF))\n\t\t\t\treturn 0;  \n\t\t}\n\t\tcifs_dbg(FYI, \"Calculated size %u vs length %u mismatch for mid=%u\\n\",\n\t\t\t clc_len, 4 + rfclen, mid);\n\n\t\tif (4 + rfclen < clc_len) {\n\t\t\tcifs_dbg(VFS, \"RFC1001 size %u smaller than SMB for mid=%u\\n\",\n\t\t\t\t rfclen, mid);\n\t\t\treturn -EIO;\n\t\t} else if (rfclen > clc_len + 512) {\n\t\t\t \n\t\t\tcifs_dbg(VFS, \"RFC1001 size %u more than 512 bytes larger than SMB for mid=%u\\n\",\n\t\t\t\t rfclen, mid);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\treturn 0;\n}\n\nbool\nis_valid_oplock_break(char *buffer, struct TCP_Server_Info *srv)\n{\n\tstruct smb_hdr *buf = (struct smb_hdr *)buffer;\n\tstruct smb_com_lock_req *pSMB = (struct smb_com_lock_req *)buf;\n\tstruct TCP_Server_Info *pserver;\n\tstruct cifs_ses *ses;\n\tstruct cifs_tcon *tcon;\n\tstruct cifsInodeInfo *pCifsInode;\n\tstruct cifsFileInfo *netfile;\n\n\tcifs_dbg(FYI, \"Checking for oplock break or dnotify response\\n\");\n\tif ((pSMB->hdr.Command == SMB_COM_NT_TRANSACT) &&\n\t   (pSMB->hdr.Flags & SMBFLG_RESPONSE)) {\n\t\tstruct smb_com_transaction_change_notify_rsp *pSMBr =\n\t\t\t(struct smb_com_transaction_change_notify_rsp *)buf;\n\t\tstruct file_notify_information *pnotify;\n\t\t__u32 data_offset = 0;\n\t\tsize_t len = srv->total_read - sizeof(pSMBr->hdr.smb_buf_length);\n\n\t\tif (get_bcc(buf) > sizeof(struct file_notify_information)) {\n\t\t\tdata_offset = le32_to_cpu(pSMBr->DataOffset);\n\n\t\t\tif (data_offset >\n\t\t\t    len - sizeof(struct file_notify_information)) {\n\t\t\t\tcifs_dbg(FYI, \"Invalid data_offset %u\\n\",\n\t\t\t\t\t data_offset);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tpnotify = (struct file_notify_information *)\n\t\t\t\t((char *)&pSMBr->hdr.Protocol + data_offset);\n\t\t\tcifs_dbg(FYI, \"dnotify on %s Action: 0x%x\\n\",\n\t\t\t\t pnotify->FileName, pnotify->Action);\n\t\t\t \n\t\t\treturn true;\n\t\t}\n\t\tif (pSMBr->hdr.Status.CifsError) {\n\t\t\tcifs_dbg(FYI, \"notify err 0x%x\\n\",\n\t\t\t\t pSMBr->hdr.Status.CifsError);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tif (pSMB->hdr.Command != SMB_COM_LOCKING_ANDX)\n\t\treturn false;\n\tif (pSMB->hdr.Flags & SMBFLG_RESPONSE) {\n\t\t \n\t\tif ((NT_STATUS_INVALID_HANDLE) ==\n\t\t   le32_to_cpu(pSMB->hdr.Status.CifsError)) {\n\t\t\tcifs_dbg(FYI, \"Invalid handle on oplock break\\n\");\n\t\t\treturn true;\n\t\t} else if (ERRbadfid ==\n\t\t   le16_to_cpu(pSMB->hdr.Status.DosError.Error)) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;  \n\t\t}\n\t}\n\tif (pSMB->hdr.WordCount != 8)\n\t\treturn false;\n\n\tcifs_dbg(FYI, \"oplock type 0x%x level 0x%x\\n\",\n\t\t pSMB->LockType, pSMB->OplockLevel);\n\tif (!(pSMB->LockType & LOCKING_ANDX_OPLOCK_RELEASE))\n\t\treturn false;\n\n\t \n\tpserver = SERVER_IS_CHAN(srv) ? srv->primary_server : srv;\n\n\t \n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each_entry(ses, &pserver->smb_ses_list, smb_ses_list) {\n\t\tlist_for_each_entry(tcon, &ses->tcon_list, tcon_list) {\n\t\t\tif (tcon->tid != buf->Tid)\n\t\t\t\tcontinue;\n\n\t\t\tcifs_stats_inc(&tcon->stats.cifs_stats.num_oplock_brks);\n\t\t\tspin_lock(&tcon->open_file_lock);\n\t\t\tlist_for_each_entry(netfile, &tcon->openFileList, tlist) {\n\t\t\t\tif (pSMB->Fid != netfile->fid.netfid)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tcifs_dbg(FYI, \"file id match, oplock break\\n\");\n\t\t\t\tpCifsInode = CIFS_I(d_inode(netfile->dentry));\n\n\t\t\t\tset_bit(CIFS_INODE_PENDING_OPLOCK_BREAK,\n\t\t\t\t\t&pCifsInode->flags);\n\n\t\t\t\tnetfile->oplock_epoch = 0;\n\t\t\t\tnetfile->oplock_level = pSMB->OplockLevel;\n\t\t\t\tnetfile->oplock_break_cancelled = false;\n\t\t\t\tcifs_queue_oplock_break(netfile);\n\n\t\t\t\tspin_unlock(&tcon->open_file_lock);\n\t\t\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tspin_unlock(&tcon->open_file_lock);\n\t\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\t\tcifs_dbg(FYI, \"No matching file for oplock break\\n\");\n\t\t\treturn true;\n\t\t}\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\tcifs_dbg(FYI, \"Can not process oplock break for non-existent connection\\n\");\n\treturn true;\n}\n\nvoid\ndump_smb(void *buf, int smb_buf_length)\n{\n\tif (traceSMB == 0)\n\t\treturn;\n\n\tprint_hex_dump(KERN_DEBUG, \"\", DUMP_PREFIX_NONE, 8, 2, buf,\n\t\t       smb_buf_length, true);\n}\n\nvoid\ncifs_autodisable_serverino(struct cifs_sb_info *cifs_sb)\n{\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM) {\n\t\tstruct cifs_tcon *tcon = NULL;\n\n\t\tif (cifs_sb->master_tlink)\n\t\t\ttcon = cifs_sb_master_tcon(cifs_sb);\n\n\t\tcifs_sb->mnt_cifs_flags &= ~CIFS_MOUNT_SERVER_INUM;\n\t\tcifs_sb->mnt_cifs_serverino_autodisabled = true;\n\t\tcifs_dbg(VFS, \"Autodisabling the use of server inode numbers on %s\\n\",\n\t\t\t tcon ? tcon->tree_name : \"new server\");\n\t\tcifs_dbg(VFS, \"The server doesn't seem to support them properly or the files might be on different servers (DFS)\\n\");\n\t\tcifs_dbg(VFS, \"Hardlinks will not be recognized on this mount. Consider mounting with the \\\"noserverino\\\" option to silence this message.\\n\");\n\n\t}\n}\n\nvoid cifs_set_oplock_level(struct cifsInodeInfo *cinode, __u32 oplock)\n{\n\toplock &= 0xF;\n\n\tif (oplock == OPLOCK_EXCLUSIVE) {\n\t\tcinode->oplock = CIFS_CACHE_WRITE_FLG | CIFS_CACHE_READ_FLG;\n\t\tcifs_dbg(FYI, \"Exclusive Oplock granted on inode %p\\n\",\n\t\t\t &cinode->netfs.inode);\n\t} else if (oplock == OPLOCK_READ) {\n\t\tcinode->oplock = CIFS_CACHE_READ_FLG;\n\t\tcifs_dbg(FYI, \"Level II Oplock granted on inode %p\\n\",\n\t\t\t &cinode->netfs.inode);\n\t} else\n\t\tcinode->oplock = 0;\n}\n\n \nint cifs_get_writer(struct cifsInodeInfo *cinode)\n{\n\tint rc;\n\nstart:\n\trc = wait_on_bit(&cinode->flags, CIFS_INODE_PENDING_OPLOCK_BREAK,\n\t\t\t TASK_KILLABLE);\n\tif (rc)\n\t\treturn rc;\n\n\tspin_lock(&cinode->writers_lock);\n\tif (!cinode->writers)\n\t\tset_bit(CIFS_INODE_PENDING_WRITERS, &cinode->flags);\n\tcinode->writers++;\n\t \n\tif (test_bit(CIFS_INODE_PENDING_OPLOCK_BREAK, &cinode->flags)) {\n\t\tcinode->writers--;\n\t\tif (cinode->writers == 0) {\n\t\t\tclear_bit(CIFS_INODE_PENDING_WRITERS, &cinode->flags);\n\t\t\twake_up_bit(&cinode->flags, CIFS_INODE_PENDING_WRITERS);\n\t\t}\n\t\tspin_unlock(&cinode->writers_lock);\n\t\tgoto start;\n\t}\n\tspin_unlock(&cinode->writers_lock);\n\treturn 0;\n}\n\nvoid cifs_put_writer(struct cifsInodeInfo *cinode)\n{\n\tspin_lock(&cinode->writers_lock);\n\tcinode->writers--;\n\tif (cinode->writers == 0) {\n\t\tclear_bit(CIFS_INODE_PENDING_WRITERS, &cinode->flags);\n\t\twake_up_bit(&cinode->flags, CIFS_INODE_PENDING_WRITERS);\n\t}\n\tspin_unlock(&cinode->writers_lock);\n}\n\n \nvoid cifs_queue_oplock_break(struct cifsFileInfo *cfile)\n{\n\t \n\tcifsFileInfo_get(cfile);\n\n\tqueue_work(cifsoplockd_wq, &cfile->oplock_break);\n}\n\nvoid cifs_done_oplock_break(struct cifsInodeInfo *cinode)\n{\n\tclear_bit(CIFS_INODE_PENDING_OPLOCK_BREAK, &cinode->flags);\n\twake_up_bit(&cinode->flags, CIFS_INODE_PENDING_OPLOCK_BREAK);\n}\n\nbool\nbackup_cred(struct cifs_sb_info *cifs_sb)\n{\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPUID) {\n\t\tif (uid_eq(cifs_sb->ctx->backupuid, current_fsuid()))\n\t\t\treturn true;\n\t}\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPGID) {\n\t\tif (in_group_p(cifs_sb->ctx->backupgid))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nvoid\ncifs_del_pending_open(struct cifs_pending_open *open)\n{\n\tspin_lock(&tlink_tcon(open->tlink)->open_file_lock);\n\tlist_del(&open->olist);\n\tspin_unlock(&tlink_tcon(open->tlink)->open_file_lock);\n}\n\nvoid\ncifs_add_pending_open_locked(struct cifs_fid *fid, struct tcon_link *tlink,\n\t\t\t     struct cifs_pending_open *open)\n{\n\tmemcpy(open->lease_key, fid->lease_key, SMB2_LEASE_KEY_SIZE);\n\topen->oplock = CIFS_OPLOCK_NO_CHANGE;\n\topen->tlink = tlink;\n\tfid->pending_open = open;\n\tlist_add_tail(&open->olist, &tlink_tcon(tlink)->pending_opens);\n}\n\nvoid\ncifs_add_pending_open(struct cifs_fid *fid, struct tcon_link *tlink,\n\t\t      struct cifs_pending_open *open)\n{\n\tspin_lock(&tlink_tcon(tlink)->open_file_lock);\n\tcifs_add_pending_open_locked(fid, tlink, open);\n\tspin_unlock(&tlink_tcon(open->tlink)->open_file_lock);\n}\n\n \nbool\ncifs_is_deferred_close(struct cifsFileInfo *cfile, struct cifs_deferred_close **pdclose)\n{\n\tstruct cifs_deferred_close *dclose;\n\n\tlist_for_each_entry(dclose, &CIFS_I(d_inode(cfile->dentry))->deferred_closes, dlist) {\n\t\tif ((dclose->netfid == cfile->fid.netfid) &&\n\t\t\t(dclose->persistent_fid == cfile->fid.persistent_fid) &&\n\t\t\t(dclose->volatile_fid == cfile->fid.volatile_fid)) {\n\t\t\t*pdclose = dclose;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n \nvoid\ncifs_add_deferred_close(struct cifsFileInfo *cfile, struct cifs_deferred_close *dclose)\n{\n\tbool is_deferred = false;\n\tstruct cifs_deferred_close *pdclose;\n\n\tis_deferred = cifs_is_deferred_close(cfile, &pdclose);\n\tif (is_deferred) {\n\t\tkfree(dclose);\n\t\treturn;\n\t}\n\n\tdclose->tlink = cfile->tlink;\n\tdclose->netfid = cfile->fid.netfid;\n\tdclose->persistent_fid = cfile->fid.persistent_fid;\n\tdclose->volatile_fid = cfile->fid.volatile_fid;\n\tlist_add_tail(&dclose->dlist, &CIFS_I(d_inode(cfile->dentry))->deferred_closes);\n}\n\n \nvoid\ncifs_del_deferred_close(struct cifsFileInfo *cfile)\n{\n\tbool is_deferred = false;\n\tstruct cifs_deferred_close *dclose;\n\n\tis_deferred = cifs_is_deferred_close(cfile, &dclose);\n\tif (!is_deferred)\n\t\treturn;\n\tlist_del(&dclose->dlist);\n\tkfree(dclose);\n}\n\nvoid\ncifs_close_deferred_file(struct cifsInodeInfo *cifs_inode)\n{\n\tstruct cifsFileInfo *cfile = NULL;\n\tstruct file_list *tmp_list, *tmp_next_list;\n\tstruct list_head file_head;\n\n\tif (cifs_inode == NULL)\n\t\treturn;\n\n\tINIT_LIST_HEAD(&file_head);\n\tspin_lock(&cifs_inode->open_file_lock);\n\tlist_for_each_entry(cfile, &cifs_inode->openFileList, flist) {\n\t\tif (delayed_work_pending(&cfile->deferred)) {\n\t\t\tif (cancel_delayed_work(&cfile->deferred)) {\n\t\t\t\tspin_lock(&cifs_inode->deferred_lock);\n\t\t\t\tcifs_del_deferred_close(cfile);\n\t\t\t\tspin_unlock(&cifs_inode->deferred_lock);\n\n\t\t\t\ttmp_list = kmalloc(sizeof(struct file_list), GFP_ATOMIC);\n\t\t\t\tif (tmp_list == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\ttmp_list->cfile = cfile;\n\t\t\t\tlist_add_tail(&tmp_list->list, &file_head);\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock(&cifs_inode->open_file_lock);\n\n\tlist_for_each_entry_safe(tmp_list, tmp_next_list, &file_head, list) {\n\t\t_cifsFileInfo_put(tmp_list->cfile, false, false);\n\t\tlist_del(&tmp_list->list);\n\t\tkfree(tmp_list);\n\t}\n}\n\nvoid\ncifs_close_all_deferred_files(struct cifs_tcon *tcon)\n{\n\tstruct cifsFileInfo *cfile;\n\tstruct file_list *tmp_list, *tmp_next_list;\n\tstruct list_head file_head;\n\n\tINIT_LIST_HEAD(&file_head);\n\tspin_lock(&tcon->open_file_lock);\n\tlist_for_each_entry(cfile, &tcon->openFileList, tlist) {\n\t\tif (delayed_work_pending(&cfile->deferred)) {\n\t\t\tif (cancel_delayed_work(&cfile->deferred)) {\n\t\t\t\tspin_lock(&CIFS_I(d_inode(cfile->dentry))->deferred_lock);\n\t\t\t\tcifs_del_deferred_close(cfile);\n\t\t\t\tspin_unlock(&CIFS_I(d_inode(cfile->dentry))->deferred_lock);\n\n\t\t\t\ttmp_list = kmalloc(sizeof(struct file_list), GFP_ATOMIC);\n\t\t\t\tif (tmp_list == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\ttmp_list->cfile = cfile;\n\t\t\t\tlist_add_tail(&tmp_list->list, &file_head);\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock(&tcon->open_file_lock);\n\n\tlist_for_each_entry_safe(tmp_list, tmp_next_list, &file_head, list) {\n\t\t_cifsFileInfo_put(tmp_list->cfile, true, false);\n\t\tlist_del(&tmp_list->list);\n\t\tkfree(tmp_list);\n\t}\n}\nvoid\ncifs_close_deferred_file_under_dentry(struct cifs_tcon *tcon, const char *path)\n{\n\tstruct cifsFileInfo *cfile;\n\tstruct file_list *tmp_list, *tmp_next_list;\n\tstruct list_head file_head;\n\tvoid *page;\n\tconst char *full_path;\n\n\tINIT_LIST_HEAD(&file_head);\n\tpage = alloc_dentry_path();\n\tspin_lock(&tcon->open_file_lock);\n\tlist_for_each_entry(cfile, &tcon->openFileList, tlist) {\n\t\tfull_path = build_path_from_dentry(cfile->dentry, page);\n\t\tif (strstr(full_path, path)) {\n\t\t\tif (delayed_work_pending(&cfile->deferred)) {\n\t\t\t\tif (cancel_delayed_work(&cfile->deferred)) {\n\t\t\t\t\tspin_lock(&CIFS_I(d_inode(cfile->dentry))->deferred_lock);\n\t\t\t\t\tcifs_del_deferred_close(cfile);\n\t\t\t\t\tspin_unlock(&CIFS_I(d_inode(cfile->dentry))->deferred_lock);\n\n\t\t\t\t\ttmp_list = kmalloc(sizeof(struct file_list), GFP_ATOMIC);\n\t\t\t\t\tif (tmp_list == NULL)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\ttmp_list->cfile = cfile;\n\t\t\t\t\tlist_add_tail(&tmp_list->list, &file_head);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock(&tcon->open_file_lock);\n\n\tlist_for_each_entry_safe(tmp_list, tmp_next_list, &file_head, list) {\n\t\t_cifsFileInfo_put(tmp_list->cfile, true, false);\n\t\tlist_del(&tmp_list->list);\n\t\tkfree(tmp_list);\n\t}\n\tfree_dentry_path(page);\n}\n\n \nint\nparse_dfs_referrals(struct get_dfs_referral_rsp *rsp, u32 rsp_size,\n\t\t    unsigned int *num_of_nodes,\n\t\t    struct dfs_info3_param **target_nodes,\n\t\t    const struct nls_table *nls_codepage, int remap,\n\t\t    const char *searchName, bool is_unicode)\n{\n\tint i, rc = 0;\n\tchar *data_end;\n\tstruct dfs_referral_level_3 *ref;\n\n\t*num_of_nodes = le16_to_cpu(rsp->NumberOfReferrals);\n\n\tif (*num_of_nodes < 1) {\n\t\tcifs_dbg(VFS, \"num_referrals: must be at least > 0, but we get num_referrals = %d\\n\",\n\t\t\t *num_of_nodes);\n\t\trc = -EINVAL;\n\t\tgoto parse_DFS_referrals_exit;\n\t}\n\n\tref = (struct dfs_referral_level_3 *) &(rsp->referrals);\n\tif (ref->VersionNumber != cpu_to_le16(3)) {\n\t\tcifs_dbg(VFS, \"Referrals of V%d version are not supported, should be V3\\n\",\n\t\t\t le16_to_cpu(ref->VersionNumber));\n\t\trc = -EINVAL;\n\t\tgoto parse_DFS_referrals_exit;\n\t}\n\n\t \n\tdata_end = (char *)rsp + rsp_size;\n\n\tcifs_dbg(FYI, \"num_referrals: %d dfs flags: 0x%x ...\\n\",\n\t\t *num_of_nodes, le32_to_cpu(rsp->DFSFlags));\n\n\t*target_nodes = kcalloc(*num_of_nodes, sizeof(struct dfs_info3_param),\n\t\t\t\tGFP_KERNEL);\n\tif (*target_nodes == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto parse_DFS_referrals_exit;\n\t}\n\n\t \n\tfor (i = 0; i < *num_of_nodes; i++) {\n\t\tchar *temp;\n\t\tint max_len;\n\t\tstruct dfs_info3_param *node = (*target_nodes)+i;\n\n\t\tnode->flags = le32_to_cpu(rsp->DFSFlags);\n\t\tif (is_unicode) {\n\t\t\t__le16 *tmp = kmalloc(strlen(searchName)*2 + 2,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (tmp == NULL) {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto parse_DFS_referrals_exit;\n\t\t\t}\n\t\t\tcifsConvertToUTF16((__le16 *) tmp, searchName,\n\t\t\t\t\t   PATH_MAX, nls_codepage, remap);\n\t\t\tnode->path_consumed = cifs_utf16_bytes(tmp,\n\t\t\t\t\tle16_to_cpu(rsp->PathConsumed),\n\t\t\t\t\tnls_codepage);\n\t\t\tkfree(tmp);\n\t\t} else\n\t\t\tnode->path_consumed = le16_to_cpu(rsp->PathConsumed);\n\n\t\tnode->server_type = le16_to_cpu(ref->ServerType);\n\t\tnode->ref_flag = le16_to_cpu(ref->ReferralEntryFlags);\n\n\t\t \n\t\ttemp = (char *)ref + le16_to_cpu(ref->DfsPathOffset);\n\t\tmax_len = data_end - temp;\n\t\tnode->path_name = cifs_strndup_from_utf16(temp, max_len,\n\t\t\t\t\t\tis_unicode, nls_codepage);\n\t\tif (!node->path_name) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto parse_DFS_referrals_exit;\n\t\t}\n\n\t\t \n\t\ttemp = (char *)ref + le16_to_cpu(ref->NetworkAddressOffset);\n\t\tmax_len = data_end - temp;\n\t\tnode->node_name = cifs_strndup_from_utf16(temp, max_len,\n\t\t\t\t\t\tis_unicode, nls_codepage);\n\t\tif (!node->node_name) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto parse_DFS_referrals_exit;\n\t\t}\n\n\t\tnode->ttl = le32_to_cpu(ref->TimeToLive);\n\n\t\tref++;\n\t}\n\nparse_DFS_referrals_exit:\n\tif (rc) {\n\t\tfree_dfs_info_array(*target_nodes, *num_of_nodes);\n\t\t*target_nodes = NULL;\n\t\t*num_of_nodes = 0;\n\t}\n\treturn rc;\n}\n\nstruct cifs_aio_ctx *\ncifs_aio_ctx_alloc(void)\n{\n\tstruct cifs_aio_ctx *ctx;\n\n\t \n\tctx = kzalloc(sizeof(struct cifs_aio_ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&ctx->list);\n\tmutex_init(&ctx->aio_mutex);\n\tinit_completion(&ctx->done);\n\tkref_init(&ctx->refcount);\n\treturn ctx;\n}\n\nvoid\ncifs_aio_ctx_release(struct kref *refcount)\n{\n\tstruct cifs_aio_ctx *ctx = container_of(refcount,\n\t\t\t\t\tstruct cifs_aio_ctx, refcount);\n\n\tcifsFileInfo_put(ctx->cfile);\n\n\t \n\tif (ctx->bv) {\n\t\tif (ctx->should_dirty || ctx->bv_need_unpin) {\n\t\t\tunsigned int i;\n\n\t\t\tfor (i = 0; i < ctx->nr_pinned_pages; i++) {\n\t\t\t\tstruct page *page = ctx->bv[i].bv_page;\n\n\t\t\t\tif (ctx->should_dirty)\n\t\t\t\t\tset_page_dirty(page);\n\t\t\t\tif (ctx->bv_need_unpin)\n\t\t\t\t\tunpin_user_page(page);\n\t\t\t}\n\t\t}\n\t\tkvfree(ctx->bv);\n\t}\n\n\tkfree(ctx);\n}\n\n \nint\ncifs_alloc_hash(const char *name, struct shash_desc **sdesc)\n{\n\tint rc = 0;\n\tstruct crypto_shash *alg = NULL;\n\n\tif (*sdesc)\n\t\treturn 0;\n\n\talg = crypto_alloc_shash(name, 0, 0);\n\tif (IS_ERR(alg)) {\n\t\tcifs_dbg(VFS, \"Could not allocate shash TFM '%s'\\n\", name);\n\t\trc = PTR_ERR(alg);\n\t\t*sdesc = NULL;\n\t\treturn rc;\n\t}\n\n\t*sdesc = kmalloc(sizeof(struct shash_desc) + crypto_shash_descsize(alg), GFP_KERNEL);\n\tif (*sdesc == NULL) {\n\t\tcifs_dbg(VFS, \"no memory left to allocate shash TFM '%s'\\n\", name);\n\t\tcrypto_free_shash(alg);\n\t\treturn -ENOMEM;\n\t}\n\n\t(*sdesc)->tfm = alg;\n\treturn 0;\n}\n\n \nvoid\ncifs_free_hash(struct shash_desc **sdesc)\n{\n\tif (unlikely(!sdesc) || !*sdesc)\n\t\treturn;\n\n\tif ((*sdesc)->tfm) {\n\t\tcrypto_free_shash((*sdesc)->tfm);\n\t\t(*sdesc)->tfm = NULL;\n\t}\n\n\tkfree_sensitive(*sdesc);\n\t*sdesc = NULL;\n}\n\nvoid extract_unc_hostname(const char *unc, const char **h, size_t *len)\n{\n\tconst char *end;\n\n\t \n\twhile (*unc && (*unc == '\\\\' || *unc == '/'))\n\t\tunc++;\n\n\tend = unc;\n\n\twhile (*end && !(*end == '\\\\' || *end == '/'))\n\t\tend++;\n\n\t*h = unc;\n\t*len = end - unc;\n}\n\n \nint copy_path_name(char *dst, const char *src)\n{\n\tint name_len;\n\n\t \n\tname_len = strscpy(dst, src, PATH_MAX);\n\tif (WARN_ON_ONCE(name_len < 0))\n\t\tname_len = PATH_MAX-1;\n\n\t \n\tname_len++;\n\treturn name_len;\n}\n\nstruct super_cb_data {\n\tvoid *data;\n\tstruct super_block *sb;\n};\n\nstatic void tcon_super_cb(struct super_block *sb, void *arg)\n{\n\tstruct super_cb_data *sd = arg;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct cifs_tcon *t1 = sd->data, *t2;\n\n\tif (sd->sb)\n\t\treturn;\n\n\tcifs_sb = CIFS_SB(sb);\n\tt2 = cifs_sb_master_tcon(cifs_sb);\n\n\tspin_lock(&t2->tc_lock);\n\tif (t1->ses == t2->ses &&\n\t    t1->ses->server == t2->ses->server &&\n\t    t2->origin_fullpath &&\n\t    dfs_src_pathname_equal(t2->origin_fullpath, t1->origin_fullpath))\n\t\tsd->sb = sb;\n\tspin_unlock(&t2->tc_lock);\n}\n\nstatic struct super_block *__cifs_get_super(void (*f)(struct super_block *, void *),\n\t\t\t\t\t    void *data)\n{\n\tstruct super_cb_data sd = {\n\t\t.data = data,\n\t\t.sb = NULL,\n\t};\n\tstruct file_system_type **fs_type = (struct file_system_type *[]) {\n\t\t&cifs_fs_type, &smb3_fs_type, NULL,\n\t};\n\n\tfor (; *fs_type; fs_type++) {\n\t\titerate_supers_type(*fs_type, f, &sd);\n\t\tif (sd.sb) {\n\t\t\t \n\t\t\tcifs_sb_active(sd.sb);\n\t\t\treturn sd.sb;\n\t\t}\n\t}\n\tpr_warn_once(\"%s: could not find dfs superblock\\n\", __func__);\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic void __cifs_put_super(struct super_block *sb)\n{\n\tif (!IS_ERR_OR_NULL(sb))\n\t\tcifs_sb_deactive(sb);\n}\n\nstruct super_block *cifs_get_dfs_tcon_super(struct cifs_tcon *tcon)\n{\n\tspin_lock(&tcon->tc_lock);\n\tif (!tcon->origin_fullpath) {\n\t\tspin_unlock(&tcon->tc_lock);\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\tspin_unlock(&tcon->tc_lock);\n\treturn __cifs_get_super(tcon_super_cb, tcon);\n}\n\nvoid cifs_put_tcp_super(struct super_block *sb)\n{\n\t__cifs_put_super(sb);\n}\n\n#ifdef CONFIG_CIFS_DFS_UPCALL\nint match_target_ip(struct TCP_Server_Info *server,\n\t\t    const char *share, size_t share_len,\n\t\t    bool *result)\n{\n\tint rc;\n\tchar *target;\n\tstruct sockaddr_storage ss;\n\n\t*result = false;\n\n\ttarget = kzalloc(share_len + 3, GFP_KERNEL);\n\tif (!target)\n\t\treturn -ENOMEM;\n\n\tscnprintf(target, share_len + 3, \"\\\\\\\\%.*s\", (int)share_len, share);\n\n\tcifs_dbg(FYI, \"%s: target name: %s\\n\", __func__, target + 2);\n\n\trc = dns_resolve_server_name_to_ip(target, (struct sockaddr *)&ss, NULL);\n\tkfree(target);\n\n\tif (rc < 0)\n\t\treturn rc;\n\n\tspin_lock(&server->srv_lock);\n\t*result = cifs_match_ipaddr((struct sockaddr *)&server->dstaddr, (struct sockaddr *)&ss);\n\tspin_unlock(&server->srv_lock);\n\tcifs_dbg(FYI, \"%s: ip addresses match: %u\\n\", __func__, *result);\n\treturn 0;\n}\n\nint cifs_update_super_prepath(struct cifs_sb_info *cifs_sb, char *prefix)\n{\n\tint rc;\n\n\tkfree(cifs_sb->prepath);\n\tcifs_sb->prepath = NULL;\n\n\tif (prefix && *prefix) {\n\t\tcifs_sb->prepath = cifs_sanitize_prepath(prefix, GFP_ATOMIC);\n\t\tif (IS_ERR(cifs_sb->prepath)) {\n\t\t\trc = PTR_ERR(cifs_sb->prepath);\n\t\t\tcifs_sb->prepath = NULL;\n\t\t\treturn rc;\n\t\t}\n\t\tif (cifs_sb->prepath)\n\t\t\tconvert_delimiter(cifs_sb->prepath, CIFS_DIR_SEP(cifs_sb));\n\t}\n\n\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_USE_PREFIX_PATH;\n\treturn 0;\n}\n\n \nint cifs_inval_name_dfs_link_error(const unsigned int xid,\n\t\t\t\t   struct cifs_tcon *tcon,\n\t\t\t\t   struct cifs_sb_info *cifs_sb,\n\t\t\t\t   const char *full_path,\n\t\t\t\t   bool *islink)\n{\n\tstruct cifs_ses *ses = tcon->ses;\n\tsize_t len;\n\tchar *path;\n\tchar *ref_path;\n\n\t*islink = false;\n\n\t \n\tif (strlen(full_path) < 2 || !cifs_sb ||\n\t    (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_DFS) ||\n\t    !is_tcon_dfs(tcon))\n\t\treturn 0;\n\n\tspin_lock(&tcon->tc_lock);\n\tif (!tcon->origin_fullpath) {\n\t\tspin_unlock(&tcon->tc_lock);\n\t\treturn 0;\n\t}\n\tspin_unlock(&tcon->tc_lock);\n\n\t \n\tlen = strnlen(tcon->tree_name, MAX_TREE_SIZE + 1) + strlen(full_path) + 1;\n\tpath = kmalloc(len, GFP_KERNEL);\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tscnprintf(path, len, \"%s%s\", tcon->tree_name, full_path);\n\tref_path = dfs_cache_canonical_path(path + 1, cifs_sb->local_nls,\n\t\t\t\t\t    cifs_remap(cifs_sb));\n\tkfree(path);\n\n\tif (IS_ERR(ref_path)) {\n\t\tif (PTR_ERR(ref_path) != -EINVAL)\n\t\t\treturn PTR_ERR(ref_path);\n\t} else {\n\t\tstruct dfs_info3_param *refs = NULL;\n\t\tint num_refs = 0;\n\n\t\t \n\t\tses = CIFS_DFS_ROOT_SES(ses);\n\t\tif (ses->server->ops->get_dfs_refer &&\n\t\t    !ses->server->ops->get_dfs_refer(xid, ses, ref_path, &refs,\n\t\t\t\t\t\t     &num_refs, cifs_sb->local_nls,\n\t\t\t\t\t\t     cifs_remap(cifs_sb)))\n\t\t\t*islink = refs[0].server_type == DFS_TYPE_LINK;\n\t\tfree_dfs_info_array(refs, num_refs);\n\t\tkfree(ref_path);\n\t}\n\treturn 0;\n}\n#endif\n\nint cifs_wait_for_server_reconnect(struct TCP_Server_Info *server, bool retry)\n{\n\tint timeout = 10;\n\tint rc;\n\n\tspin_lock(&server->srv_lock);\n\tif (server->tcpStatus != CifsNeedReconnect) {\n\t\tspin_unlock(&server->srv_lock);\n\t\treturn 0;\n\t}\n\ttimeout *= server->nr_targets;\n\tspin_unlock(&server->srv_lock);\n\n\t \n\tdo {\n\t\trc = wait_event_interruptible_timeout(server->response_q,\n\t\t\t\t\t\t      (server->tcpStatus != CifsNeedReconnect),\n\t\t\t\t\t\t      timeout * HZ);\n\t\tif (rc < 0) {\n\t\t\tcifs_dbg(FYI, \"%s: aborting reconnect due to received signal\\n\",\n\t\t\t\t __func__);\n\t\t\treturn -ERESTARTSYS;\n\t\t}\n\n\t\t \n\t\tspin_lock(&server->srv_lock);\n\t\tif (server->tcpStatus != CifsNeedReconnect) {\n\t\t\tspin_unlock(&server->srv_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tspin_unlock(&server->srv_lock);\n\t} while (retry);\n\n\tcifs_dbg(FYI, \"%s: gave up waiting on reconnect\\n\", __func__);\n\treturn -EHOSTDOWN;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}