{
  "module_name": "smb1ops.c",
  "hash_id": "80a59c71737c7a99d89147b398846f5fe5329fc18c7cde0fa4d21e015fa644bd",
  "original_prompt": "Ingested from linux-6.6.14/fs/smb/client/smb1ops.c",
  "human_readable_source": "\n \n\n#include <linux/pagemap.h>\n#include <linux/vfs.h>\n#include <uapi/linux/magic.h>\n#include \"cifsglob.h\"\n#include \"cifsproto.h\"\n#include \"cifs_debug.h\"\n#include \"cifspdu.h\"\n#include \"cifs_unicode.h\"\n#include \"fs_context.h\"\n\n \nstatic int\nsend_nt_cancel(struct TCP_Server_Info *server, struct smb_rqst *rqst,\n\t       struct mid_q_entry *mid)\n{\n\tint rc = 0;\n\tstruct smb_hdr *in_buf = (struct smb_hdr *)rqst->rq_iov[0].iov_base;\n\n\t \n\tin_buf->smb_buf_length = cpu_to_be32(sizeof(struct smb_hdr) - 4  + 2);\n\tin_buf->Command = SMB_COM_NT_CANCEL;\n\tin_buf->WordCount = 0;\n\tput_bcc(0, in_buf);\n\n\tcifs_server_lock(server);\n\trc = cifs_sign_smb(in_buf, server, &mid->sequence_number);\n\tif (rc) {\n\t\tcifs_server_unlock(server);\n\t\treturn rc;\n\t}\n\n\t \n\t--server->sequence_number;\n\trc = smb_send(server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tif (rc < 0)\n\t\tserver->sequence_number--;\n\n\tcifs_server_unlock(server);\n\n\tcifs_dbg(FYI, \"issued NT_CANCEL for mid %u, rc = %d\\n\",\n\t\t get_mid(in_buf), rc);\n\n\treturn rc;\n}\n\nstatic bool\ncifs_compare_fids(struct cifsFileInfo *ob1, struct cifsFileInfo *ob2)\n{\n\treturn ob1->fid.netfid == ob2->fid.netfid;\n}\n\nstatic unsigned int\ncifs_read_data_offset(char *buf)\n{\n\tREAD_RSP *rsp = (READ_RSP *)buf;\n\treturn le16_to_cpu(rsp->DataOffset);\n}\n\nstatic unsigned int\ncifs_read_data_length(char *buf, bool in_remaining)\n{\n\tREAD_RSP *rsp = (READ_RSP *)buf;\n\t \n\tWARN_ON(in_remaining);\n\treturn (le16_to_cpu(rsp->DataLengthHigh) << 16) +\n\t       le16_to_cpu(rsp->DataLength);\n}\n\nstatic struct mid_q_entry *\ncifs_find_mid(struct TCP_Server_Info *server, char *buffer)\n{\n\tstruct smb_hdr *buf = (struct smb_hdr *)buffer;\n\tstruct mid_q_entry *mid;\n\n\tspin_lock(&server->mid_lock);\n\tlist_for_each_entry(mid, &server->pending_mid_q, qhead) {\n\t\tif (compare_mid(mid->mid, buf) &&\n\t\t    mid->mid_state == MID_REQUEST_SUBMITTED &&\n\t\t    le16_to_cpu(mid->command) == buf->Command) {\n\t\t\tkref_get(&mid->refcount);\n\t\t\tspin_unlock(&server->mid_lock);\n\t\t\treturn mid;\n\t\t}\n\t}\n\tspin_unlock(&server->mid_lock);\n\treturn NULL;\n}\n\nstatic void\ncifs_add_credits(struct TCP_Server_Info *server,\n\t\t const struct cifs_credits *credits, const int optype)\n{\n\tspin_lock(&server->req_lock);\n\tserver->credits += credits->value;\n\tserver->in_flight--;\n\tspin_unlock(&server->req_lock);\n\twake_up(&server->request_q);\n}\n\nstatic void\ncifs_set_credits(struct TCP_Server_Info *server, const int val)\n{\n\tspin_lock(&server->req_lock);\n\tserver->credits = val;\n\tserver->oplocks = val > 1 ? enable_oplocks : false;\n\tspin_unlock(&server->req_lock);\n}\n\nstatic int *\ncifs_get_credits_field(struct TCP_Server_Info *server, const int optype)\n{\n\treturn &server->credits;\n}\n\nstatic unsigned int\ncifs_get_credits(struct mid_q_entry *mid)\n{\n\treturn 1;\n}\n\n \nstatic __u64\ncifs_get_next_mid(struct TCP_Server_Info *server)\n{\n\t__u64 mid = 0;\n\t__u16 last_mid, cur_mid;\n\tbool collision, reconnect = false;\n\n\tspin_lock(&server->mid_lock);\n\n\t \n\tcur_mid = (__u16)((server->CurrentMid) & 0xffff);\n\t \n\tlast_mid = cur_mid;\n\tcur_mid++;\n\t \n\tif (cur_mid == 0xffff)\n\t\tcur_mid++;\n\n\t \n\twhile (cur_mid != last_mid) {\n\t\tstruct mid_q_entry *mid_entry;\n\t\tunsigned int num_mids;\n\n\t\tcollision = false;\n\t\tif (cur_mid == 0)\n\t\t\tcur_mid++;\n\n\t\tnum_mids = 0;\n\t\tlist_for_each_entry(mid_entry, &server->pending_mid_q, qhead) {\n\t\t\t++num_mids;\n\t\t\tif (mid_entry->mid == cur_mid &&\n\t\t\t    mid_entry->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t\t \n\t\t\t\tcollision = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (num_mids > 32768)\n\t\t\treconnect = true;\n\n\t\tif (!collision) {\n\t\t\tmid = (__u64)cur_mid;\n\t\t\tserver->CurrentMid = mid;\n\t\t\tbreak;\n\t\t}\n\t\tcur_mid++;\n\t}\n\tspin_unlock(&server->mid_lock);\n\n\tif (reconnect) {\n\t\tcifs_signal_cifsd_for_reconnect(server, false);\n\t}\n\n\treturn mid;\n}\n\n \nstatic int\ncheck2ndT2(char *buf)\n{\n\tstruct smb_hdr *pSMB = (struct smb_hdr *)buf;\n\tstruct smb_t2_rsp *pSMBt;\n\tint remaining;\n\t__u16 total_data_size, data_in_this_rsp;\n\n\tif (pSMB->Command != SMB_COM_TRANSACTION2)\n\t\treturn 0;\n\n\t \n\t \n\tif (pSMB->WordCount != 10) {  \n\t\tcifs_dbg(FYI, \"Invalid transact2 word count\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpSMBt = (struct smb_t2_rsp *)pSMB;\n\n\ttotal_data_size = get_unaligned_le16(&pSMBt->t2_rsp.TotalDataCount);\n\tdata_in_this_rsp = get_unaligned_le16(&pSMBt->t2_rsp.DataCount);\n\n\tif (total_data_size == data_in_this_rsp)\n\t\treturn 0;\n\telse if (total_data_size < data_in_this_rsp) {\n\t\tcifs_dbg(FYI, \"total data %d smaller than data in frame %d\\n\",\n\t\t\t total_data_size, data_in_this_rsp);\n\t\treturn -EINVAL;\n\t}\n\n\tremaining = total_data_size - data_in_this_rsp;\n\n\tcifs_dbg(FYI, \"missing %d bytes from transact2, check next response\\n\",\n\t\t remaining);\n\tif (total_data_size > CIFSMaxBufSize) {\n\t\tcifs_dbg(VFS, \"TotalDataSize %d is over maximum buffer %d\\n\",\n\t\t\t total_data_size, CIFSMaxBufSize);\n\t\treturn -EINVAL;\n\t}\n\treturn remaining;\n}\n\nstatic int\ncoalesce_t2(char *second_buf, struct smb_hdr *target_hdr)\n{\n\tstruct smb_t2_rsp *pSMBs = (struct smb_t2_rsp *)second_buf;\n\tstruct smb_t2_rsp *pSMBt  = (struct smb_t2_rsp *)target_hdr;\n\tchar *data_area_of_tgt;\n\tchar *data_area_of_src;\n\tint remaining;\n\tunsigned int byte_count, total_in_tgt;\n\t__u16 tgt_total_cnt, src_total_cnt, total_in_src;\n\n\tsrc_total_cnt = get_unaligned_le16(&pSMBs->t2_rsp.TotalDataCount);\n\ttgt_total_cnt = get_unaligned_le16(&pSMBt->t2_rsp.TotalDataCount);\n\n\tif (tgt_total_cnt != src_total_cnt)\n\t\tcifs_dbg(FYI, \"total data count of primary and secondary t2 differ source=%hu target=%hu\\n\",\n\t\t\t src_total_cnt, tgt_total_cnt);\n\n\ttotal_in_tgt = get_unaligned_le16(&pSMBt->t2_rsp.DataCount);\n\n\tremaining = tgt_total_cnt - total_in_tgt;\n\n\tif (remaining < 0) {\n\t\tcifs_dbg(FYI, \"Server sent too much data. tgt_total_cnt=%hu total_in_tgt=%u\\n\",\n\t\t\t tgt_total_cnt, total_in_tgt);\n\t\treturn -EPROTO;\n\t}\n\n\tif (remaining == 0) {\n\t\t \n\t\tcifs_dbg(FYI, \"no more data remains\\n\");\n\t\treturn 0;\n\t}\n\n\ttotal_in_src = get_unaligned_le16(&pSMBs->t2_rsp.DataCount);\n\tif (remaining < total_in_src)\n\t\tcifs_dbg(FYI, \"transact2 2nd response contains too much data\\n\");\n\n\t \n\tdata_area_of_tgt = (char *)&pSMBt->hdr.Protocol +\n\t\t\t\tget_unaligned_le16(&pSMBt->t2_rsp.DataOffset);\n\n\t \n\tdata_area_of_src = (char *)&pSMBs->hdr.Protocol +\n\t\t\t\tget_unaligned_le16(&pSMBs->t2_rsp.DataOffset);\n\n\tdata_area_of_tgt += total_in_tgt;\n\n\ttotal_in_tgt += total_in_src;\n\t \n\tif (total_in_tgt > USHRT_MAX) {\n\t\tcifs_dbg(FYI, \"coalesced DataCount too large (%u)\\n\",\n\t\t\t total_in_tgt);\n\t\treturn -EPROTO;\n\t}\n\tput_unaligned_le16(total_in_tgt, &pSMBt->t2_rsp.DataCount);\n\n\t \n\tbyte_count = get_bcc(target_hdr);\n\tbyte_count += total_in_src;\n\t \n\tif (byte_count > USHRT_MAX) {\n\t\tcifs_dbg(FYI, \"coalesced BCC too large (%u)\\n\", byte_count);\n\t\treturn -EPROTO;\n\t}\n\tput_bcc(byte_count, target_hdr);\n\n\tbyte_count = be32_to_cpu(target_hdr->smb_buf_length);\n\tbyte_count += total_in_src;\n\t \n\tif (byte_count > CIFSMaxBufSize + MAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(FYI, \"coalesced BCC exceeds buffer size (%u)\\n\",\n\t\t\t byte_count);\n\t\treturn -ENOBUFS;\n\t}\n\ttarget_hdr->smb_buf_length = cpu_to_be32(byte_count);\n\n\t \n\tmemcpy(data_area_of_tgt, data_area_of_src, total_in_src);\n\n\tif (remaining != total_in_src) {\n\t\t \n\t\tcifs_dbg(FYI, \"waiting for more secondary responses\\n\");\n\t\treturn 1;\n\t}\n\n\t \n\tcifs_dbg(FYI, \"found the last secondary response\\n\");\n\treturn 0;\n}\n\nstatic void\ncifs_downgrade_oplock(struct TCP_Server_Info *server,\n\t\t      struct cifsInodeInfo *cinode, __u32 oplock,\n\t\t      unsigned int epoch, bool *purge_cache)\n{\n\tcifs_set_oplock_level(cinode, oplock);\n}\n\nstatic bool\ncifs_check_trans2(struct mid_q_entry *mid, struct TCP_Server_Info *server,\n\t\t  char *buf, int malformed)\n{\n\tif (malformed)\n\t\treturn false;\n\tif (check2ndT2(buf) <= 0)\n\t\treturn false;\n\tmid->multiRsp = true;\n\tif (mid->resp_buf) {\n\t\t \n\t\tmalformed = coalesce_t2(buf, mid->resp_buf);\n\t\tif (malformed > 0)\n\t\t\treturn true;\n\t\t \n\t\tmid->multiEnd = true;\n\t\tdequeue_mid(mid, malformed);\n\t\treturn true;\n\t}\n\tif (!server->large_buf) {\n\t\t \n\t\tcifs_dbg(VFS, \"1st trans2 resp needs bigbuf\\n\");\n\t} else {\n\t\t \n\t\tmid->resp_buf = buf;\n\t\tmid->large_buf = true;\n\t\tserver->bigbuf = NULL;\n\t}\n\treturn true;\n}\n\nstatic bool\ncifs_need_neg(struct TCP_Server_Info *server)\n{\n\treturn server->maxBuf == 0;\n}\n\nstatic int\ncifs_negotiate(const unsigned int xid,\n\t       struct cifs_ses *ses,\n\t       struct TCP_Server_Info *server)\n{\n\tint rc;\n\trc = CIFSSMBNegotiate(xid, ses, server);\n\tif (rc == -EAGAIN) {\n\t\t \n\t\tset_credits(server, 1);\n\t\trc = CIFSSMBNegotiate(xid, ses, server);\n\t\tif (rc == -EAGAIN)\n\t\t\trc = -EHOSTDOWN;\n\t}\n\treturn rc;\n}\n\nstatic unsigned int\ncifs_negotiate_wsize(struct cifs_tcon *tcon, struct smb3_fs_context *ctx)\n{\n\t__u64 unix_cap = le64_to_cpu(tcon->fsUnixInfo.Capability);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tunsigned int wsize;\n\n\t \n\tif (ctx->wsize)\n\t\twsize = ctx->wsize;\n\telse if (tcon->unix_ext && (unix_cap & CIFS_UNIX_LARGE_WRITE_CAP))\n\t\twsize = CIFS_DEFAULT_IOSIZE;\n\telse\n\t\twsize = CIFS_DEFAULT_NON_POSIX_WSIZE;\n\n\t \n\tif (!tcon->unix_ext || !(unix_cap & CIFS_UNIX_LARGE_WRITE_CAP))\n\t\twsize = min_t(unsigned int, wsize, CIFS_MAX_RFC1002_WSIZE);\n\n\t \n\tif (!(server->capabilities & CAP_LARGE_WRITE_X) ||\n\t    (!(server->capabilities & CAP_UNIX) && server->sign))\n\t\twsize = min_t(unsigned int, wsize,\n\t\t\t\tserver->maxBuf - sizeof(WRITE_REQ) + 4);\n\n\t \n\twsize = min_t(unsigned int, wsize, CIFS_MAX_WSIZE);\n\n\treturn wsize;\n}\n\nstatic unsigned int\ncifs_negotiate_rsize(struct cifs_tcon *tcon, struct smb3_fs_context *ctx)\n{\n\t__u64 unix_cap = le64_to_cpu(tcon->fsUnixInfo.Capability);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tunsigned int rsize, defsize;\n\n\t \n\tif (tcon->unix_ext && (unix_cap & CIFS_UNIX_LARGE_READ_CAP))\n\t\tdefsize = CIFS_DEFAULT_IOSIZE;\n\telse if (server->capabilities & CAP_LARGE_READ_X)\n\t\tdefsize = CIFS_DEFAULT_NON_POSIX_RSIZE;\n\telse\n\t\tdefsize = server->maxBuf - sizeof(READ_RSP);\n\n\trsize = ctx->rsize ? ctx->rsize : defsize;\n\n\t \n\tif (!(server->capabilities & CAP_LARGE_READ_X))\n\t\trsize = min_t(unsigned int, CIFSMaxBufSize, rsize);\n\n\t \n\trsize = min_t(unsigned int, rsize, CIFS_MAX_RSIZE);\n\n\treturn rsize;\n}\n\nstatic void\ncifs_qfs_tcon(const unsigned int xid, struct cifs_tcon *tcon,\n\t      struct cifs_sb_info *cifs_sb)\n{\n\tCIFSSMBQFSDeviceInfo(xid, tcon);\n\tCIFSSMBQFSAttributeInfo(xid, tcon);\n}\n\nstatic int\ncifs_is_path_accessible(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\tstruct cifs_sb_info *cifs_sb, const char *full_path)\n{\n\tint rc;\n\tFILE_ALL_INFO *file_info;\n\n\tfile_info = kmalloc(sizeof(FILE_ALL_INFO), GFP_KERNEL);\n\tif (file_info == NULL)\n\t\treturn -ENOMEM;\n\n\trc = CIFSSMBQPathInfo(xid, tcon, full_path, file_info,\n\t\t\t      0  , cifs_sb->local_nls,\n\t\t\t      cifs_remap(cifs_sb));\n\n\tif (rc == -EOPNOTSUPP || rc == -EINVAL)\n\t\trc = SMBQueryInformation(xid, tcon, full_path, file_info,\n\t\t\t\tcifs_sb->local_nls, cifs_remap(cifs_sb));\n\tkfree(file_info);\n\treturn rc;\n}\n\nstatic int cifs_query_path_info(const unsigned int xid,\n\t\t\t\tstruct cifs_tcon *tcon,\n\t\t\t\tstruct cifs_sb_info *cifs_sb,\n\t\t\t\tconst char *full_path,\n\t\t\t\tstruct cifs_open_info_data *data)\n{\n\tint rc;\n\tFILE_ALL_INFO fi = {};\n\n\tdata->symlink = false;\n\tdata->adjust_tz = false;\n\n\t \n\trc = CIFSSMBQPathInfo(xid, tcon, full_path, &fi, 0  , cifs_sb->local_nls,\n\t\t\t      cifs_remap(cifs_sb));\n\t \n\tif ((rc == -EOPNOTSUPP) || (rc == -EINVAL)) {\n\t\trc = SMBQueryInformation(xid, tcon, full_path, &fi, cifs_sb->local_nls,\n\t\t\t\t\t cifs_remap(cifs_sb));\n\t\tdata->adjust_tz = true;\n\t}\n\n\tif (!rc) {\n\t\tint tmprc;\n\t\tint oplock = 0;\n\t\tstruct cifs_fid fid;\n\t\tstruct cifs_open_parms oparms;\n\n\t\tmove_cifs_info_to_smb2(&data->fi, &fi);\n\n\t\tif (!(le32_to_cpu(fi.Attributes) & ATTR_REPARSE))\n\t\t\treturn 0;\n\n\t\toparms = (struct cifs_open_parms) {\n\t\t\t.tcon = tcon,\n\t\t\t.cifs_sb = cifs_sb,\n\t\t\t.desired_access = FILE_READ_ATTRIBUTES,\n\t\t\t.create_options = cifs_create_options(cifs_sb, 0),\n\t\t\t.disposition = FILE_OPEN,\n\t\t\t.path = full_path,\n\t\t\t.fid = &fid,\n\t\t};\n\n\t\t \n\t\ttmprc = CIFS_open(xid, &oparms, &oplock, NULL);\n\t\tif (tmprc == -EOPNOTSUPP)\n\t\t\tdata->symlink = true;\n\t\telse if (tmprc == 0)\n\t\t\tCIFSSMBClose(xid, tcon, fid.netfid);\n\t}\n\n\treturn rc;\n}\n\nstatic int cifs_get_srv_inum(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\t     struct cifs_sb_info *cifs_sb, const char *full_path,\n\t\t\t     u64 *uniqueid, struct cifs_open_info_data *unused)\n{\n\t \n\treturn CIFSGetSrvInodeNumber(xid, tcon, full_path, uniqueid,\n\t\t\t\t     cifs_sb->local_nls,\n\t\t\t\t     cifs_remap(cifs_sb));\n}\n\nstatic int cifs_query_file_info(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\t\tstruct cifsFileInfo *cfile, struct cifs_open_info_data *data)\n{\n\tint rc;\n\tFILE_ALL_INFO fi = {};\n\n\tif (cfile->symlink_target) {\n\t\tdata->symlink_target = kstrdup(cfile->symlink_target, GFP_KERNEL);\n\t\tif (!data->symlink_target)\n\t\t\treturn -ENOMEM;\n\t}\n\n\trc = CIFSSMBQFileInfo(xid, tcon, cfile->fid.netfid, &fi);\n\tif (!rc)\n\t\tmove_cifs_info_to_smb2(&data->fi, &fi);\n\treturn rc;\n}\n\nstatic void\ncifs_clear_stats(struct cifs_tcon *tcon)\n{\n\tatomic_set(&tcon->stats.cifs_stats.num_writes, 0);\n\tatomic_set(&tcon->stats.cifs_stats.num_reads, 0);\n\tatomic_set(&tcon->stats.cifs_stats.num_flushes, 0);\n\tatomic_set(&tcon->stats.cifs_stats.num_oplock_brks, 0);\n\tatomic_set(&tcon->stats.cifs_stats.num_opens, 0);\n\tatomic_set(&tcon->stats.cifs_stats.num_posixopens, 0);\n\tatomic_set(&tcon->stats.cifs_stats.num_posixmkdirs, 0);\n\tatomic_set(&tcon->stats.cifs_stats.num_closes, 0);\n\tatomic_set(&tcon->stats.cifs_stats.num_deletes, 0);\n\tatomic_set(&tcon->stats.cifs_stats.num_mkdirs, 0);\n\tatomic_set(&tcon->stats.cifs_stats.num_rmdirs, 0);\n\tatomic_set(&tcon->stats.cifs_stats.num_renames, 0);\n\tatomic_set(&tcon->stats.cifs_stats.num_t2renames, 0);\n\tatomic_set(&tcon->stats.cifs_stats.num_ffirst, 0);\n\tatomic_set(&tcon->stats.cifs_stats.num_fnext, 0);\n\tatomic_set(&tcon->stats.cifs_stats.num_fclose, 0);\n\tatomic_set(&tcon->stats.cifs_stats.num_hardlinks, 0);\n\tatomic_set(&tcon->stats.cifs_stats.num_symlinks, 0);\n\tatomic_set(&tcon->stats.cifs_stats.num_locks, 0);\n\tatomic_set(&tcon->stats.cifs_stats.num_acl_get, 0);\n\tatomic_set(&tcon->stats.cifs_stats.num_acl_set, 0);\n}\n\nstatic void\ncifs_print_stats(struct seq_file *m, struct cifs_tcon *tcon)\n{\n\tseq_printf(m, \" Oplocks breaks: %d\",\n\t\t   atomic_read(&tcon->stats.cifs_stats.num_oplock_brks));\n\tseq_printf(m, \"\\nReads:  %d Bytes: %llu\",\n\t\t   atomic_read(&tcon->stats.cifs_stats.num_reads),\n\t\t   (long long)(tcon->bytes_read));\n\tseq_printf(m, \"\\nWrites: %d Bytes: %llu\",\n\t\t   atomic_read(&tcon->stats.cifs_stats.num_writes),\n\t\t   (long long)(tcon->bytes_written));\n\tseq_printf(m, \"\\nFlushes: %d\",\n\t\t   atomic_read(&tcon->stats.cifs_stats.num_flushes));\n\tseq_printf(m, \"\\nLocks: %d HardLinks: %d Symlinks: %d\",\n\t\t   atomic_read(&tcon->stats.cifs_stats.num_locks),\n\t\t   atomic_read(&tcon->stats.cifs_stats.num_hardlinks),\n\t\t   atomic_read(&tcon->stats.cifs_stats.num_symlinks));\n\tseq_printf(m, \"\\nOpens: %d Closes: %d Deletes: %d\",\n\t\t   atomic_read(&tcon->stats.cifs_stats.num_opens),\n\t\t   atomic_read(&tcon->stats.cifs_stats.num_closes),\n\t\t   atomic_read(&tcon->stats.cifs_stats.num_deletes));\n\tseq_printf(m, \"\\nPosix Opens: %d Posix Mkdirs: %d\",\n\t\t   atomic_read(&tcon->stats.cifs_stats.num_posixopens),\n\t\t   atomic_read(&tcon->stats.cifs_stats.num_posixmkdirs));\n\tseq_printf(m, \"\\nMkdirs: %d Rmdirs: %d\",\n\t\t   atomic_read(&tcon->stats.cifs_stats.num_mkdirs),\n\t\t   atomic_read(&tcon->stats.cifs_stats.num_rmdirs));\n\tseq_printf(m, \"\\nRenames: %d T2 Renames %d\",\n\t\t   atomic_read(&tcon->stats.cifs_stats.num_renames),\n\t\t   atomic_read(&tcon->stats.cifs_stats.num_t2renames));\n\tseq_printf(m, \"\\nFindFirst: %d FNext %d FClose %d\",\n\t\t   atomic_read(&tcon->stats.cifs_stats.num_ffirst),\n\t\t   atomic_read(&tcon->stats.cifs_stats.num_fnext),\n\t\t   atomic_read(&tcon->stats.cifs_stats.num_fclose));\n}\n\nstatic void\ncifs_mkdir_setinfo(struct inode *inode, const char *full_path,\n\t\t   struct cifs_sb_info *cifs_sb, struct cifs_tcon *tcon,\n\t\t   const unsigned int xid)\n{\n\tFILE_BASIC_INFO info;\n\tstruct cifsInodeInfo *cifsInode;\n\tu32 dosattrs;\n\tint rc;\n\n\tmemset(&info, 0, sizeof(info));\n\tcifsInode = CIFS_I(inode);\n\tdosattrs = cifsInode->cifsAttrs|ATTR_READONLY;\n\tinfo.Attributes = cpu_to_le32(dosattrs);\n\trc = CIFSSMBSetPathInfo(xid, tcon, full_path, &info, cifs_sb->local_nls,\n\t\t\t\tcifs_sb);\n\tif (rc == 0)\n\t\tcifsInode->cifsAttrs = dosattrs;\n}\n\nstatic int cifs_open_file(const unsigned int xid, struct cifs_open_parms *oparms, __u32 *oplock,\n\t\t\t  void *buf)\n{\n\tstruct cifs_open_info_data *data = buf;\n\tFILE_ALL_INFO fi = {};\n\tint rc;\n\n\tif (!(oparms->tcon->ses->capabilities & CAP_NT_SMBS))\n\t\trc = SMBLegacyOpen(xid, oparms->tcon, oparms->path,\n\t\t\t\t   oparms->disposition,\n\t\t\t\t   oparms->desired_access,\n\t\t\t\t   oparms->create_options,\n\t\t\t\t   &oparms->fid->netfid, oplock, &fi,\n\t\t\t\t   oparms->cifs_sb->local_nls,\n\t\t\t\t   cifs_remap(oparms->cifs_sb));\n\telse\n\t\trc = CIFS_open(xid, oparms, oplock, &fi);\n\n\tif (!rc && data)\n\t\tmove_cifs_info_to_smb2(&data->fi, &fi);\n\n\treturn rc;\n}\n\nstatic void\ncifs_set_fid(struct cifsFileInfo *cfile, struct cifs_fid *fid, __u32 oplock)\n{\n\tstruct cifsInodeInfo *cinode = CIFS_I(d_inode(cfile->dentry));\n\tcfile->fid.netfid = fid->netfid;\n\tcifs_set_oplock_level(cinode, oplock);\n\tcinode->can_cache_brlcks = CIFS_CACHE_WRITE(cinode);\n}\n\nstatic void\ncifs_close_file(const unsigned int xid, struct cifs_tcon *tcon,\n\t\tstruct cifs_fid *fid)\n{\n\tCIFSSMBClose(xid, tcon, fid->netfid);\n}\n\nstatic int\ncifs_flush_file(const unsigned int xid, struct cifs_tcon *tcon,\n\t\tstruct cifs_fid *fid)\n{\n\treturn CIFSSMBFlush(xid, tcon, fid->netfid);\n}\n\nstatic int\ncifs_sync_read(const unsigned int xid, struct cifs_fid *pfid,\n\t       struct cifs_io_parms *parms, unsigned int *bytes_read,\n\t       char **buf, int *buf_type)\n{\n\tparms->netfid = pfid->netfid;\n\treturn CIFSSMBRead(xid, parms, bytes_read, buf, buf_type);\n}\n\nstatic int\ncifs_sync_write(const unsigned int xid, struct cifs_fid *pfid,\n\t\tstruct cifs_io_parms *parms, unsigned int *written,\n\t\tstruct kvec *iov, unsigned long nr_segs)\n{\n\n\tparms->netfid = pfid->netfid;\n\treturn CIFSSMBWrite2(xid, parms, written, iov, nr_segs);\n}\n\nstatic int\nsmb_set_file_info(struct inode *inode, const char *full_path,\n\t\t  FILE_BASIC_INFO *buf, const unsigned int xid)\n{\n\tint oplock = 0;\n\tint rc;\n\t__u32 netpid;\n\tstruct cifs_fid fid;\n\tstruct cifs_open_parms oparms;\n\tstruct cifsFileInfo *open_file;\n\tstruct cifsInodeInfo *cinode = CIFS_I(inode);\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct tcon_link *tlink = NULL;\n\tstruct cifs_tcon *tcon;\n\n\t \n\topen_file = find_writable_file(cinode, FIND_WR_FSUID_ONLY);\n\tif (open_file) {\n\t\tfid.netfid = open_file->fid.netfid;\n\t\tnetpid = open_file->pid;\n\t\ttcon = tlink_tcon(open_file->tlink);\n\t\tgoto set_via_filehandle;\n\t}\n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink)) {\n\t\trc = PTR_ERR(tlink);\n\t\ttlink = NULL;\n\t\tgoto out;\n\t}\n\ttcon = tlink_tcon(tlink);\n\n\trc = CIFSSMBSetPathInfo(xid, tcon, full_path, buf, cifs_sb->local_nls,\n\t\t\t\tcifs_sb);\n\tif (rc == 0) {\n\t\tcinode->cifsAttrs = le32_to_cpu(buf->Attributes);\n\t\tgoto out;\n\t} else if (rc != -EOPNOTSUPP && rc != -EINVAL) {\n\t\tgoto out;\n\t}\n\n\toparms = (struct cifs_open_parms) {\n\t\t.tcon = tcon,\n\t\t.cifs_sb = cifs_sb,\n\t\t.desired_access = SYNCHRONIZE | FILE_WRITE_ATTRIBUTES,\n\t\t.create_options = cifs_create_options(cifs_sb, CREATE_NOT_DIR),\n\t\t.disposition = FILE_OPEN,\n\t\t.path = full_path,\n\t\t.fid = &fid,\n\t};\n\n\tcifs_dbg(FYI, \"calling SetFileInfo since SetPathInfo for times not supported by this server\\n\");\n\trc = CIFS_open(xid, &oparms, &oplock, NULL);\n\tif (rc != 0) {\n\t\tif (rc == -EIO)\n\t\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tnetpid = current->tgid;\n\nset_via_filehandle:\n\trc = CIFSSMBSetFileInfo(xid, tcon, buf, fid.netfid, netpid);\n\tif (!rc)\n\t\tcinode->cifsAttrs = le32_to_cpu(buf->Attributes);\n\n\tif (open_file == NULL)\n\t\tCIFSSMBClose(xid, tcon, fid.netfid);\n\telse\n\t\tcifsFileInfo_put(open_file);\nout:\n\tif (tlink != NULL)\n\t\tcifs_put_tlink(tlink);\n\treturn rc;\n}\n\nstatic int\ncifs_set_compression(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   struct cifsFileInfo *cfile)\n{\n\treturn CIFSSMB_set_compression(xid, tcon, cfile->fid.netfid);\n}\n\nstatic int\ncifs_query_dir_first(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t     const char *path, struct cifs_sb_info *cifs_sb,\n\t\t     struct cifs_fid *fid, __u16 search_flags,\n\t\t     struct cifs_search_info *srch_inf)\n{\n\tint rc;\n\n\trc = CIFSFindFirst(xid, tcon, path, cifs_sb,\n\t\t\t   &fid->netfid, search_flags, srch_inf, true);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"find first failed=%d\\n\", rc);\n\treturn rc;\n}\n\nstatic int\ncifs_query_dir_next(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t    struct cifs_fid *fid, __u16 search_flags,\n\t\t    struct cifs_search_info *srch_inf)\n{\n\treturn CIFSFindNext(xid, tcon, fid->netfid, search_flags, srch_inf);\n}\n\nstatic int\ncifs_close_dir(const unsigned int xid, struct cifs_tcon *tcon,\n\t       struct cifs_fid *fid)\n{\n\treturn CIFSFindClose(xid, tcon, fid->netfid);\n}\n\nstatic int\ncifs_oplock_response(struct cifs_tcon *tcon, __u64 persistent_fid,\n\t\t__u64 volatile_fid, __u16 net_fid, struct cifsInodeInfo *cinode)\n{\n\treturn CIFSSMBLock(0, tcon, net_fid, current->tgid, 0, 0, 0, 0,\n\t\t\t   LOCKING_ANDX_OPLOCK_RELEASE, false, CIFS_CACHE_READ(cinode) ? 1 : 0);\n}\n\nstatic int\ncifs_queryfs(const unsigned int xid, struct cifs_tcon *tcon,\n\t     struct cifs_sb_info *cifs_sb, struct kstatfs *buf)\n{\n\tint rc = -EOPNOTSUPP;\n\n\tbuf->f_type = CIFS_SUPER_MAGIC;\n\n\t \n\tif ((tcon->ses->capabilities & CAP_UNIX) &&\n\t    (CIFS_POSIX_EXTENSIONS & le64_to_cpu(tcon->fsUnixInfo.Capability)))\n\t\trc = CIFSSMBQFSPosixInfo(xid, tcon, buf);\n\n\t \n\tif (rc && (tcon->ses->capabilities & CAP_NT_SMBS))\n\t\trc = CIFSSMBQFSInfo(xid, tcon, buf);\n\n\t \n\tif (rc)\n\t\trc = SMBOldQFSInfo(xid, tcon, buf);\n\treturn rc;\n}\n\nstatic int\ncifs_mand_lock(const unsigned int xid, struct cifsFileInfo *cfile, __u64 offset,\n\t       __u64 length, __u32 type, int lock, int unlock, bool wait)\n{\n\treturn CIFSSMBLock(xid, tlink_tcon(cfile->tlink), cfile->fid.netfid,\n\t\t\t   current->tgid, length, offset, unlock, lock,\n\t\t\t   (__u8)type, wait, 0);\n}\n\nstatic int\ncifs_unix_dfs_readlink(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t       const unsigned char *searchName, char **symlinkinfo,\n\t\t       const struct nls_table *nls_codepage)\n{\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\tint rc;\n\tstruct dfs_info3_param referral = {0};\n\n\trc = get_dfs_path(xid, tcon->ses, searchName, nls_codepage, &referral,\n\t\t\t  0);\n\n\tif (!rc) {\n\t\t*symlinkinfo = kstrdup(referral.node_name, GFP_KERNEL);\n\t\tfree_dfs_info_param(&referral);\n\t\tif (!*symlinkinfo)\n\t\t\trc = -ENOMEM;\n\t}\n\treturn rc;\n#else  \n\treturn -EREMOTE;\n#endif\n}\n\nstatic int cifs_query_symlink(const unsigned int xid,\n\t\t\t      struct cifs_tcon *tcon,\n\t\t\t      struct cifs_sb_info *cifs_sb,\n\t\t\t      const char *full_path,\n\t\t\t      char **target_path)\n{\n\tint rc;\n\n\tcifs_tcon_dbg(FYI, \"%s: path=%s\\n\", __func__, full_path);\n\n\tif (!cap_unix(tcon->ses))\n\t\treturn -EOPNOTSUPP;\n\n\trc = CIFSSMBUnixQuerySymLink(xid, tcon, full_path, target_path,\n\t\t\t\t     cifs_sb->local_nls, cifs_remap(cifs_sb));\n\tif (rc == -EREMOTE)\n\t\trc = cifs_unix_dfs_readlink(xid, tcon, full_path,\n\t\t\t\t\t    target_path, cifs_sb->local_nls);\n\treturn rc;\n}\n\nstatic int cifs_parse_reparse_point(struct cifs_sb_info *cifs_sb,\n\t\t\t\t    struct kvec *rsp_iov,\n\t\t\t\t    struct cifs_open_info_data *data)\n{\n\tstruct reparse_data_buffer *buf;\n\tTRANSACT_IOCTL_RSP *io = rsp_iov->iov_base;\n\tbool unicode = !!(io->hdr.Flags2 & SMBFLG2_UNICODE);\n\tu32 plen = le16_to_cpu(io->ByteCount);\n\n\tbuf = (struct reparse_data_buffer *)((__u8 *)&io->hdr.Protocol +\n\t\t\t\t\t     le32_to_cpu(io->DataOffset));\n\treturn parse_reparse_point(buf, plen, cifs_sb, unicode, data);\n}\n\nstatic bool\ncifs_is_read_op(__u32 oplock)\n{\n\treturn oplock == OPLOCK_READ;\n}\n\nstatic unsigned int\ncifs_wp_retry_size(struct inode *inode)\n{\n\treturn CIFS_SB(inode->i_sb)->ctx->wsize;\n}\n\nstatic bool\ncifs_dir_needs_close(struct cifsFileInfo *cfile)\n{\n\treturn !cfile->srch_inf.endOfSearch && !cfile->invalidHandle;\n}\n\nstatic bool\ncifs_can_echo(struct TCP_Server_Info *server)\n{\n\tif (server->tcpStatus == CifsGood)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int\ncifs_make_node(unsigned int xid, struct inode *inode,\n\t       struct dentry *dentry, struct cifs_tcon *tcon,\n\t       const char *full_path, umode_t mode, dev_t dev)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct inode *newinode = NULL;\n\tint rc = -EPERM;\n\tstruct cifs_open_info_data buf = {};\n\tstruct cifs_io_parms io_parms;\n\t__u32 oplock = 0;\n\tstruct cifs_fid fid;\n\tstruct cifs_open_parms oparms;\n\tunsigned int bytes_written;\n\tstruct win_dev *pdev;\n\tstruct kvec iov[2];\n\n\tif (tcon->unix_ext) {\n\t\t \n\t\tstruct cifs_unix_set_info_args args = {\n\t\t\t.mode\t= mode & ~current_umask(),\n\t\t\t.ctime\t= NO_CHANGE_64,\n\t\t\t.atime\t= NO_CHANGE_64,\n\t\t\t.mtime\t= NO_CHANGE_64,\n\t\t\t.device\t= dev,\n\t\t};\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SET_UID) {\n\t\t\targs.uid = current_fsuid();\n\t\t\targs.gid = current_fsgid();\n\t\t} else {\n\t\t\targs.uid = INVALID_UID;  \n\t\t\targs.gid = INVALID_GID;  \n\t\t}\n\t\trc = CIFSSMBUnixSetPathInfo(xid, tcon, full_path, &args,\n\t\t\t\t\t    cifs_sb->local_nls,\n\t\t\t\t\t    cifs_remap(cifs_sb));\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\trc = cifs_get_inode_info_unix(&newinode, full_path,\n\t\t\t\t\t      inode->i_sb, xid);\n\n\t\tif (rc == 0)\n\t\t\td_instantiate(dentry, newinode);\n\t\treturn rc;\n\t}\n\n\t \n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_UNX_EMUL))\n\t\treturn rc;\n\n\tif (!S_ISCHR(mode) && !S_ISBLK(mode))\n\t\treturn rc;\n\n\tcifs_dbg(FYI, \"sfu compat create special file\\n\");\n\n\toparms = (struct cifs_open_parms) {\n\t\t.tcon = tcon,\n\t\t.cifs_sb = cifs_sb,\n\t\t.desired_access = GENERIC_WRITE,\n\t\t.create_options = cifs_create_options(cifs_sb, CREATE_NOT_DIR |\n\t\t\t\t\t\t      CREATE_OPTION_SPECIAL),\n\t\t.disposition = FILE_CREATE,\n\t\t.path = full_path,\n\t\t.fid = &fid,\n\t};\n\n\tif (tcon->ses->server->oplocks)\n\t\toplock = REQ_OPLOCK;\n\telse\n\t\toplock = 0;\n\trc = tcon->ses->server->ops->open(xid, &oparms, &oplock, &buf);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\n\tpdev = (struct win_dev *)&buf.fi;\n\tio_parms.pid = current->tgid;\n\tio_parms.tcon = tcon;\n\tio_parms.offset = 0;\n\tio_parms.length = sizeof(struct win_dev);\n\tiov[1].iov_base = &buf.fi;\n\tiov[1].iov_len = sizeof(struct win_dev);\n\tif (S_ISCHR(mode)) {\n\t\tmemcpy(pdev->type, \"IntxCHR\", 8);\n\t\tpdev->major = cpu_to_le64(MAJOR(dev));\n\t\tpdev->minor = cpu_to_le64(MINOR(dev));\n\t\trc = tcon->ses->server->ops->sync_write(xid, &fid, &io_parms,\n\t\t\t\t\t\t\t&bytes_written, iov, 1);\n\t} else if (S_ISBLK(mode)) {\n\t\tmemcpy(pdev->type, \"IntxBLK\", 8);\n\t\tpdev->major = cpu_to_le64(MAJOR(dev));\n\t\tpdev->minor = cpu_to_le64(MINOR(dev));\n\t\trc = tcon->ses->server->ops->sync_write(xid, &fid, &io_parms,\n\t\t\t\t\t\t\t&bytes_written, iov, 1);\n\t}\n\ttcon->ses->server->ops->close(xid, tcon, &fid);\n\td_drop(dentry);\n\n\t \n\n\tcifs_free_open_info(&buf);\n\treturn rc;\n}\n\n\n\nstruct smb_version_operations smb1_operations = {\n\t.send_cancel = send_nt_cancel,\n\t.compare_fids = cifs_compare_fids,\n\t.setup_request = cifs_setup_request,\n\t.setup_async_request = cifs_setup_async_request,\n\t.check_receive = cifs_check_receive,\n\t.add_credits = cifs_add_credits,\n\t.set_credits = cifs_set_credits,\n\t.get_credits_field = cifs_get_credits_field,\n\t.get_credits = cifs_get_credits,\n\t.wait_mtu_credits = cifs_wait_mtu_credits,\n\t.get_next_mid = cifs_get_next_mid,\n\t.read_data_offset = cifs_read_data_offset,\n\t.read_data_length = cifs_read_data_length,\n\t.map_error = map_smb_to_linux_error,\n\t.find_mid = cifs_find_mid,\n\t.check_message = checkSMB,\n\t.dump_detail = cifs_dump_detail,\n\t.clear_stats = cifs_clear_stats,\n\t.print_stats = cifs_print_stats,\n\t.is_oplock_break = is_valid_oplock_break,\n\t.downgrade_oplock = cifs_downgrade_oplock,\n\t.check_trans2 = cifs_check_trans2,\n\t.need_neg = cifs_need_neg,\n\t.negotiate = cifs_negotiate,\n\t.negotiate_wsize = cifs_negotiate_wsize,\n\t.negotiate_rsize = cifs_negotiate_rsize,\n\t.sess_setup = CIFS_SessSetup,\n\t.logoff = CIFSSMBLogoff,\n\t.tree_connect = CIFSTCon,\n\t.tree_disconnect = CIFSSMBTDis,\n\t.get_dfs_refer = CIFSGetDFSRefer,\n\t.qfs_tcon = cifs_qfs_tcon,\n\t.is_path_accessible = cifs_is_path_accessible,\n\t.can_echo = cifs_can_echo,\n\t.query_path_info = cifs_query_path_info,\n\t.query_reparse_point = cifs_query_reparse_point,\n\t.query_file_info = cifs_query_file_info,\n\t.get_srv_inum = cifs_get_srv_inum,\n\t.set_path_size = CIFSSMBSetEOF,\n\t.set_file_size = CIFSSMBSetFileSize,\n\t.set_file_info = smb_set_file_info,\n\t.set_compression = cifs_set_compression,\n\t.echo = CIFSSMBEcho,\n\t.mkdir = CIFSSMBMkDir,\n\t.mkdir_setinfo = cifs_mkdir_setinfo,\n\t.rmdir = CIFSSMBRmDir,\n\t.unlink = CIFSSMBDelFile,\n\t.rename_pending_delete = cifs_rename_pending_delete,\n\t.rename = CIFSSMBRename,\n\t.create_hardlink = CIFSCreateHardLink,\n\t.query_symlink = cifs_query_symlink,\n\t.parse_reparse_point = cifs_parse_reparse_point,\n\t.open = cifs_open_file,\n\t.set_fid = cifs_set_fid,\n\t.close = cifs_close_file,\n\t.flush = cifs_flush_file,\n\t.async_readv = cifs_async_readv,\n\t.async_writev = cifs_async_writev,\n\t.sync_read = cifs_sync_read,\n\t.sync_write = cifs_sync_write,\n\t.query_dir_first = cifs_query_dir_first,\n\t.query_dir_next = cifs_query_dir_next,\n\t.close_dir = cifs_close_dir,\n\t.calc_smb_size = smbCalcSize,\n\t.oplock_response = cifs_oplock_response,\n\t.queryfs = cifs_queryfs,\n\t.mand_lock = cifs_mand_lock,\n\t.mand_unlock_range = cifs_unlock_range,\n\t.push_mand_locks = cifs_push_mandatory_locks,\n\t.query_mf_symlink = cifs_query_mf_symlink,\n\t.create_mf_symlink = cifs_create_mf_symlink,\n\t.is_read_op = cifs_is_read_op,\n\t.wp_retry_size = cifs_wp_retry_size,\n\t.dir_needs_close = cifs_dir_needs_close,\n\t.select_sectype = cifs_select_sectype,\n#ifdef CONFIG_CIFS_XATTR\n\t.query_all_EAs = CIFSSMBQAllEAs,\n\t.set_EA = CIFSSMBSetEA,\n#endif  \n\t.get_acl = get_cifs_acl,\n\t.get_acl_by_fid = get_cifs_acl_by_fid,\n\t.set_acl = set_cifs_acl,\n\t.make_node = cifs_make_node,\n};\n\nstruct smb_version_values smb1_values = {\n\t.version_string = SMB1_VERSION_STRING,\n\t.protocol_id = SMB10_PROT_ID,\n\t.large_lock_type = LOCKING_ANDX_LARGE_FILES,\n\t.exclusive_lock_type = 0,\n\t.shared_lock_type = LOCKING_ANDX_SHARED_LOCK,\n\t.unlock_lock_type = 0,\n\t.header_preamble_size = 4,\n\t.header_size = sizeof(struct smb_hdr),\n\t.max_header_size = MAX_CIFS_HDR_SIZE,\n\t.read_rsp_size = sizeof(READ_RSP),\n\t.lock_cmd = cpu_to_le16(SMB_COM_LOCKING_ANDX),\n\t.cap_unix = CAP_UNIX,\n\t.cap_nt_find = CAP_NT_SMBS | CAP_NT_FIND,\n\t.cap_large_files = CAP_LARGE_FILES,\n\t.signing_enabled = SECMODE_SIGN_ENABLED,\n\t.signing_required = SECMODE_SIGN_REQUIRED,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}