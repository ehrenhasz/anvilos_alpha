{
  "module_name": "unicode.c",
  "hash_id": "8709150a5ff9febdec7c9c6b95fad654c0000769450afdd53d9047f47a60be46",
  "original_prompt": "Ingested from linux-6.6.14/fs/smb/server/unicode.c",
  "human_readable_source": "\n \n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <asm/unaligned.h>\n#include \"glob.h\"\n#include \"unicode.h\"\n#include \"smb_common.h\"\n\n \nstatic int\ncifs_mapchar(char *target, const __u16 *from, const struct nls_table *cp,\n\t     bool mapchar)\n{\n\tint len = 1;\n\t__u16 src_char;\n\n\tsrc_char = *from;\n\n\tif (!mapchar)\n\t\tgoto cp_convert;\n\n\t \n\tswitch (src_char) {\n\tcase UNI_COLON:\n\t\t*target = ':';\n\t\tbreak;\n\tcase UNI_ASTERISK:\n\t\t*target = '*';\n\t\tbreak;\n\tcase UNI_QUESTION:\n\t\t*target = '?';\n\t\tbreak;\n\tcase UNI_PIPE:\n\t\t*target = '|';\n\t\tbreak;\n\tcase UNI_GRTRTHAN:\n\t\t*target = '>';\n\t\tbreak;\n\tcase UNI_LESSTHAN:\n\t\t*target = '<';\n\t\tbreak;\n\tdefault:\n\t\tgoto cp_convert;\n\t}\n\nout:\n\treturn len;\n\ncp_convert:\n\tlen = cp->uni2char(src_char, target, NLS_MAX_CHARSET_SIZE);\n\tif (len <= 0)\n\t\tgoto surrogate_pair;\n\n\tgoto out;\n\nsurrogate_pair:\n\t \n\tif (strcmp(cp->charset, \"utf8\"))\n\t\tgoto unknown;\n\tlen = utf16s_to_utf8s(from, 3, UTF16_LITTLE_ENDIAN, target, 6);\n\tif (len <= 0)\n\t\tgoto unknown;\n\treturn len;\n\nunknown:\n\t*target = '?';\n\tlen = 1;\n\tgoto out;\n}\n\n \nstatic int smb_utf16_bytes(const __le16 *from, int maxbytes,\n\t\t\t   const struct nls_table *codepage)\n{\n\tint i, j;\n\tint charlen, outlen = 0;\n\tint maxwords = maxbytes / 2;\n\tchar tmp[NLS_MAX_CHARSET_SIZE];\n\t__u16 ftmp[3];\n\n\tfor (i = 0; i < maxwords; i++) {\n\t\tftmp[0] = get_unaligned_le16(&from[i]);\n\t\tif (ftmp[0] == 0)\n\t\t\tbreak;\n\t\tfor (j = 1; j <= 2; j++) {\n\t\t\tif (i + j < maxwords)\n\t\t\t\tftmp[j] = get_unaligned_le16(&from[i + j]);\n\t\t\telse\n\t\t\t\tftmp[j] = 0;\n\t\t}\n\n\t\tcharlen = cifs_mapchar(tmp, ftmp, codepage, 0);\n\t\tif (charlen > 0)\n\t\t\toutlen += charlen;\n\t\telse\n\t\t\toutlen++;\n\t}\n\n\treturn outlen;\n}\n\n \nstatic int smb_from_utf16(char *to, const __le16 *from, int tolen, int fromlen,\n\t\t\t  const struct nls_table *codepage, bool mapchar)\n{\n\tint i, j, charlen, safelen;\n\tint outlen = 0;\n\tint nullsize = nls_nullsize(codepage);\n\tint fromwords = fromlen / 2;\n\tchar tmp[NLS_MAX_CHARSET_SIZE];\n\t__u16 ftmp[3];\t \n\n\t \n\tsafelen = tolen - (NLS_MAX_CHARSET_SIZE + nullsize);\n\n\tfor (i = 0; i < fromwords; i++) {\n\t\tftmp[0] = get_unaligned_le16(&from[i]);\n\t\tif (ftmp[0] == 0)\n\t\t\tbreak;\n\t\tfor (j = 1; j <= 2; j++) {\n\t\t\tif (i + j < fromwords)\n\t\t\t\tftmp[j] = get_unaligned_le16(&from[i + j]);\n\t\t\telse\n\t\t\t\tftmp[j] = 0;\n\t\t}\n\n\t\t \n\t\tif (outlen >= safelen) {\n\t\t\tcharlen = cifs_mapchar(tmp, ftmp, codepage, mapchar);\n\t\t\tif ((outlen + charlen) > (tolen - nullsize))\n\t\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tcharlen = cifs_mapchar(&to[outlen], ftmp, codepage, mapchar);\n\t\toutlen += charlen;\n\n\t\t \n\t\tif (charlen == 4)\n\t\t\ti++;\n\t\telse if (charlen >= 5)\n\t\t\t \n\t\t\ti += 2;\n\t}\n\n\t \n\tfor (i = 0; i < nullsize; i++)\n\t\tto[outlen++] = 0;\n\n\treturn outlen;\n}\n\n \nint smb_strtoUTF16(__le16 *to, const char *from, int len,\n\t\t   const struct nls_table *codepage)\n{\n\tint charlen;\n\tint i;\n\twchar_t wchar_to;  \n\n\t \n\tif (!strcmp(codepage->charset, \"utf8\")) {\n\t\t \n\t\ti  = utf8s_to_utf16s(from, len, UTF16_LITTLE_ENDIAN,\n\t\t\t\t     (wchar_t *)to, len);\n\n\t\t \n\t\tif (i >= 0)\n\t\t\tgoto success;\n\t\t \n\t}\n\n\tfor (i = 0; len > 0 && *from; i++, from += charlen, len -= charlen) {\n\t\tcharlen = codepage->char2uni(from, len, &wchar_to);\n\t\tif (charlen < 1) {\n\t\t\t \n\t\t\twchar_to = 0x003f;\n\t\t\tcharlen = 1;\n\t\t}\n\t\tput_unaligned_le16(wchar_to, &to[i]);\n\t}\n\nsuccess:\n\tput_unaligned_le16(0, &to[i]);\n\treturn i;\n}\n\n \nchar *smb_strndup_from_utf16(const char *src, const int maxlen,\n\t\t\t     const bool is_unicode,\n\t\t\t     const struct nls_table *codepage)\n{\n\tint len, ret;\n\tchar *dst;\n\n\tif (is_unicode) {\n\t\tlen = smb_utf16_bytes((__le16 *)src, maxlen, codepage);\n\t\tlen += nls_nullsize(codepage);\n\t\tdst = kmalloc(len, GFP_KERNEL);\n\t\tif (!dst)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tret = smb_from_utf16(dst, (__le16 *)src, len, maxlen, codepage,\n\t\t\t\t     false);\n\t\tif (ret < 0) {\n\t\t\tkfree(dst);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t} else {\n\t\tlen = strnlen(src, maxlen);\n\t\tlen++;\n\t\tdst = kmalloc(len, GFP_KERNEL);\n\t\tif (!dst)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tstrscpy(dst, src, len);\n\t}\n\n\treturn dst;\n}\n\n \n \nint smbConvertToUTF16(__le16 *target, const char *source, int srclen,\n\t\t      const struct nls_table *cp, int mapchars)\n{\n\tint i, j, charlen;\n\tchar src_char;\n\t__le16 dst_char;\n\twchar_t tmp;\n\twchar_t wchar_to[6];\t \n\tint ret;\n\tunicode_t u;\n\n\tif (!mapchars)\n\t\treturn smb_strtoUTF16(target, source, srclen, cp);\n\n\tfor (i = 0, j = 0; i < srclen; j++) {\n\t\tsrc_char = source[i];\n\t\tcharlen = 1;\n\t\tswitch (src_char) {\n\t\tcase 0:\n\t\t\tput_unaligned(0, &target[j]);\n\t\t\treturn j;\n\t\tcase ':':\n\t\t\tdst_char = cpu_to_le16(UNI_COLON);\n\t\t\tbreak;\n\t\tcase '*':\n\t\t\tdst_char = cpu_to_le16(UNI_ASTERISK);\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\tdst_char = cpu_to_le16(UNI_QUESTION);\n\t\t\tbreak;\n\t\tcase '<':\n\t\t\tdst_char = cpu_to_le16(UNI_LESSTHAN);\n\t\t\tbreak;\n\t\tcase '>':\n\t\t\tdst_char = cpu_to_le16(UNI_GRTRTHAN);\n\t\t\tbreak;\n\t\tcase '|':\n\t\t\tdst_char = cpu_to_le16(UNI_PIPE);\n\t\t\tbreak;\n\t\t \n\t\tdefault:\n\t\t\tcharlen = cp->char2uni(source + i, srclen - i, &tmp);\n\t\t\tdst_char = cpu_to_le16(tmp);\n\n\t\t\t \n\t\t\tif (charlen > 0)\n\t\t\t\tgoto ctoUTF16;\n\n\t\t\t \n\t\t\tif (strcmp(cp->charset, \"utf8\"))\n\t\t\t\tgoto unknown;\n\t\t\tif (*(source + i) & 0x80) {\n\t\t\t\tcharlen = utf8_to_utf32(source + i, 6, &u);\n\t\t\t\tif (charlen < 0)\n\t\t\t\t\tgoto unknown;\n\t\t\t} else\n\t\t\t\tgoto unknown;\n\t\t\tret  = utf8s_to_utf16s(source + i, charlen,\n\t\t\t\t\tUTF16_LITTLE_ENDIAN,\n\t\t\t\t\twchar_to, 6);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto unknown;\n\n\t\t\ti += charlen;\n\t\t\tdst_char = cpu_to_le16(*wchar_to);\n\t\t\tif (charlen <= 3)\n\t\t\t\t \n\t\t\t\tput_unaligned(dst_char, &target[j]);\n\t\t\telse if (charlen == 4) {\n\t\t\t\t \n\t\t\t\tput_unaligned(dst_char, &target[j]);\n\t\t\t\tdst_char = cpu_to_le16(*(wchar_to + 1));\n\t\t\t\tj++;\n\t\t\t\tput_unaligned(dst_char, &target[j]);\n\t\t\t} else if (charlen >= 5) {\n\t\t\t\t \n\t\t\t\tput_unaligned(dst_char, &target[j]);\n\t\t\t\tdst_char = cpu_to_le16(*(wchar_to + 1));\n\t\t\t\tj++;\n\t\t\t\tput_unaligned(dst_char, &target[j]);\n\t\t\t\tdst_char = cpu_to_le16(*(wchar_to + 2));\n\t\t\t\tj++;\n\t\t\t\tput_unaligned(dst_char, &target[j]);\n\t\t\t}\n\t\t\tcontinue;\n\nunknown:\n\t\t\tdst_char = cpu_to_le16(0x003f);\n\t\t\tcharlen = 1;\n\t\t}\n\nctoUTF16:\n\t\t \n\t\ti += charlen;\n\t\tput_unaligned(dst_char, &target[j]);\n\t}\n\n\treturn j;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}