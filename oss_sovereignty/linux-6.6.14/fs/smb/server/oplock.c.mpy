{
  "module_name": "oplock.c",
  "hash_id": "08f81abaf10278295d5b5916fe0bfb9b837b6e824978526f7037bcba6de56685",
  "original_prompt": "Ingested from linux-6.6.14/fs/smb/server/oplock.c",
  "human_readable_source": "\n \n\n#include <linux/moduleparam.h>\n\n#include \"glob.h\"\n#include \"oplock.h\"\n\n#include \"smb_common.h\"\n#include \"smbstatus.h\"\n#include \"connection.h\"\n#include \"mgmt/user_session.h\"\n#include \"mgmt/share_config.h\"\n#include \"mgmt/tree_connect.h\"\n\nstatic LIST_HEAD(lease_table_list);\nstatic DEFINE_RWLOCK(lease_list_lock);\n\n \nstatic struct oplock_info *alloc_opinfo(struct ksmbd_work *work,\n\t\t\t\t\tu64 id, __u16 Tid)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct ksmbd_session *sess = work->sess;\n\tstruct oplock_info *opinfo;\n\n\topinfo = kzalloc(sizeof(struct oplock_info), GFP_KERNEL);\n\tif (!opinfo)\n\t\treturn NULL;\n\n\topinfo->sess = sess;\n\topinfo->conn = conn;\n\topinfo->level = SMB2_OPLOCK_LEVEL_NONE;\n\topinfo->op_state = OPLOCK_STATE_NONE;\n\topinfo->pending_break = 0;\n\topinfo->fid = id;\n\topinfo->Tid = Tid;\n\tINIT_LIST_HEAD(&opinfo->op_entry);\n\tINIT_LIST_HEAD(&opinfo->interim_list);\n\tinit_waitqueue_head(&opinfo->oplock_q);\n\tinit_waitqueue_head(&opinfo->oplock_brk);\n\tatomic_set(&opinfo->refcount, 1);\n\tatomic_set(&opinfo->breaking_cnt, 0);\n\n\treturn opinfo;\n}\n\nstatic void lease_add_list(struct oplock_info *opinfo)\n{\n\tstruct lease_table *lb = opinfo->o_lease->l_lb;\n\n\tspin_lock(&lb->lb_lock);\n\tlist_add_rcu(&opinfo->lease_entry, &lb->lease_list);\n\tspin_unlock(&lb->lb_lock);\n}\n\nstatic void lease_del_list(struct oplock_info *opinfo)\n{\n\tstruct lease_table *lb = opinfo->o_lease->l_lb;\n\n\tif (!lb)\n\t\treturn;\n\n\tspin_lock(&lb->lb_lock);\n\tif (list_empty(&opinfo->lease_entry)) {\n\t\tspin_unlock(&lb->lb_lock);\n\t\treturn;\n\t}\n\n\tlist_del_init(&opinfo->lease_entry);\n\topinfo->o_lease->l_lb = NULL;\n\tspin_unlock(&lb->lb_lock);\n}\n\nstatic void lb_add(struct lease_table *lb)\n{\n\twrite_lock(&lease_list_lock);\n\tlist_add(&lb->l_entry, &lease_table_list);\n\twrite_unlock(&lease_list_lock);\n}\n\nstatic int alloc_lease(struct oplock_info *opinfo, struct lease_ctx_info *lctx)\n{\n\tstruct lease *lease;\n\n\tlease = kmalloc(sizeof(struct lease), GFP_KERNEL);\n\tif (!lease)\n\t\treturn -ENOMEM;\n\n\tmemcpy(lease->lease_key, lctx->lease_key, SMB2_LEASE_KEY_SIZE);\n\tlease->state = lctx->req_state;\n\tlease->new_state = 0;\n\tlease->flags = lctx->flags;\n\tlease->duration = lctx->duration;\n\tlease->is_dir = lctx->is_dir;\n\tmemcpy(lease->parent_lease_key, lctx->parent_lease_key, SMB2_LEASE_KEY_SIZE);\n\tlease->version = lctx->version;\n\tlease->epoch = le16_to_cpu(lctx->epoch);\n\tINIT_LIST_HEAD(&opinfo->lease_entry);\n\topinfo->o_lease = lease;\n\n\treturn 0;\n}\n\nstatic void free_lease(struct oplock_info *opinfo)\n{\n\tstruct lease *lease;\n\n\tlease = opinfo->o_lease;\n\tkfree(lease);\n}\n\nstatic void free_opinfo(struct oplock_info *opinfo)\n{\n\tif (opinfo->is_lease)\n\t\tfree_lease(opinfo);\n\tkfree(opinfo);\n}\n\nstatic inline void opinfo_free_rcu(struct rcu_head *rcu_head)\n{\n\tstruct oplock_info *opinfo;\n\n\topinfo = container_of(rcu_head, struct oplock_info, rcu_head);\n\tfree_opinfo(opinfo);\n}\n\nstruct oplock_info *opinfo_get(struct ksmbd_file *fp)\n{\n\tstruct oplock_info *opinfo;\n\n\trcu_read_lock();\n\topinfo = rcu_dereference(fp->f_opinfo);\n\tif (opinfo && !atomic_inc_not_zero(&opinfo->refcount))\n\t\topinfo = NULL;\n\trcu_read_unlock();\n\n\treturn opinfo;\n}\n\nstatic struct oplock_info *opinfo_get_list(struct ksmbd_inode *ci)\n{\n\tstruct oplock_info *opinfo;\n\n\tif (list_empty(&ci->m_op_list))\n\t\treturn NULL;\n\n\trcu_read_lock();\n\topinfo = list_first_or_null_rcu(&ci->m_op_list, struct oplock_info,\n\t\t\t\t\top_entry);\n\tif (opinfo) {\n\t\tif (!atomic_inc_not_zero(&opinfo->refcount))\n\t\t\topinfo = NULL;\n\t\telse {\n\t\t\tatomic_inc(&opinfo->conn->r_count);\n\t\t\tif (ksmbd_conn_releasing(opinfo->conn)) {\n\t\t\t\tatomic_dec(&opinfo->conn->r_count);\n\t\t\t\tatomic_dec(&opinfo->refcount);\n\t\t\t\topinfo = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\treturn opinfo;\n}\n\nstatic void opinfo_conn_put(struct oplock_info *opinfo)\n{\n\tstruct ksmbd_conn *conn;\n\n\tif (!opinfo)\n\t\treturn;\n\n\tconn = opinfo->conn;\n\t \n\tif (!atomic_dec_return(&conn->r_count) && waitqueue_active(&conn->r_count_q))\n\t\twake_up(&conn->r_count_q);\n\topinfo_put(opinfo);\n}\n\nvoid opinfo_put(struct oplock_info *opinfo)\n{\n\tif (!atomic_dec_and_test(&opinfo->refcount))\n\t\treturn;\n\n\tcall_rcu(&opinfo->rcu_head, opinfo_free_rcu);\n}\n\nstatic void opinfo_add(struct oplock_info *opinfo)\n{\n\tstruct ksmbd_inode *ci = opinfo->o_fp->f_ci;\n\n\twrite_lock(&ci->m_lock);\n\tlist_add_rcu(&opinfo->op_entry, &ci->m_op_list);\n\twrite_unlock(&ci->m_lock);\n}\n\nstatic void opinfo_del(struct oplock_info *opinfo)\n{\n\tstruct ksmbd_inode *ci = opinfo->o_fp->f_ci;\n\n\tif (opinfo->is_lease) {\n\t\twrite_lock(&lease_list_lock);\n\t\tlease_del_list(opinfo);\n\t\twrite_unlock(&lease_list_lock);\n\t}\n\twrite_lock(&ci->m_lock);\n\tlist_del_rcu(&opinfo->op_entry);\n\twrite_unlock(&ci->m_lock);\n}\n\nstatic unsigned long opinfo_count(struct ksmbd_file *fp)\n{\n\tif (ksmbd_stream_fd(fp))\n\t\treturn atomic_read(&fp->f_ci->sop_count);\n\telse\n\t\treturn atomic_read(&fp->f_ci->op_count);\n}\n\nstatic void opinfo_count_inc(struct ksmbd_file *fp)\n{\n\tif (ksmbd_stream_fd(fp))\n\t\treturn atomic_inc(&fp->f_ci->sop_count);\n\telse\n\t\treturn atomic_inc(&fp->f_ci->op_count);\n}\n\nstatic void opinfo_count_dec(struct ksmbd_file *fp)\n{\n\tif (ksmbd_stream_fd(fp))\n\t\treturn atomic_dec(&fp->f_ci->sop_count);\n\telse\n\t\treturn atomic_dec(&fp->f_ci->op_count);\n}\n\n \nint opinfo_write_to_read(struct oplock_info *opinfo)\n{\n\tstruct lease *lease = opinfo->o_lease;\n\n\tif (!(opinfo->level == SMB2_OPLOCK_LEVEL_BATCH ||\n\t      opinfo->level == SMB2_OPLOCK_LEVEL_EXCLUSIVE)) {\n\t\tpr_err(\"bad oplock(0x%x)\\n\", opinfo->level);\n\t\tif (opinfo->is_lease)\n\t\t\tpr_err(\"lease state(0x%x)\\n\", lease->state);\n\t\treturn -EINVAL;\n\t}\n\topinfo->level = SMB2_OPLOCK_LEVEL_II;\n\n\tif (opinfo->is_lease)\n\t\tlease->state = lease->new_state;\n\treturn 0;\n}\n\n \nint opinfo_read_handle_to_read(struct oplock_info *opinfo)\n{\n\tstruct lease *lease = opinfo->o_lease;\n\n\tlease->state = lease->new_state;\n\topinfo->level = SMB2_OPLOCK_LEVEL_II;\n\treturn 0;\n}\n\n \nint opinfo_write_to_none(struct oplock_info *opinfo)\n{\n\tstruct lease *lease = opinfo->o_lease;\n\n\tif (!(opinfo->level == SMB2_OPLOCK_LEVEL_BATCH ||\n\t      opinfo->level == SMB2_OPLOCK_LEVEL_EXCLUSIVE)) {\n\t\tpr_err(\"bad oplock(0x%x)\\n\", opinfo->level);\n\t\tif (opinfo->is_lease)\n\t\t\tpr_err(\"lease state(0x%x)\\n\", lease->state);\n\t\treturn -EINVAL;\n\t}\n\topinfo->level = SMB2_OPLOCK_LEVEL_NONE;\n\tif (opinfo->is_lease)\n\t\tlease->state = lease->new_state;\n\treturn 0;\n}\n\n \nint opinfo_read_to_none(struct oplock_info *opinfo)\n{\n\tstruct lease *lease = opinfo->o_lease;\n\n\tif (opinfo->level != SMB2_OPLOCK_LEVEL_II) {\n\t\tpr_err(\"bad oplock(0x%x)\\n\", opinfo->level);\n\t\tif (opinfo->is_lease)\n\t\t\tpr_err(\"lease state(0x%x)\\n\", lease->state);\n\t\treturn -EINVAL;\n\t}\n\topinfo->level = SMB2_OPLOCK_LEVEL_NONE;\n\tif (opinfo->is_lease)\n\t\tlease->state = lease->new_state;\n\treturn 0;\n}\n\n \nint lease_read_to_write(struct oplock_info *opinfo)\n{\n\tstruct lease *lease = opinfo->o_lease;\n\n\tif (!(lease->state & SMB2_LEASE_READ_CACHING_LE)) {\n\t\tksmbd_debug(OPLOCK, \"bad lease state(0x%x)\\n\", lease->state);\n\t\treturn -EINVAL;\n\t}\n\n\tlease->new_state = SMB2_LEASE_NONE_LE;\n\tlease->state |= SMB2_LEASE_WRITE_CACHING_LE;\n\tif (lease->state & SMB2_LEASE_HANDLE_CACHING_LE)\n\t\topinfo->level = SMB2_OPLOCK_LEVEL_BATCH;\n\telse\n\t\topinfo->level = SMB2_OPLOCK_LEVEL_EXCLUSIVE;\n\treturn 0;\n}\n\n \nstatic int lease_none_upgrade(struct oplock_info *opinfo, __le32 new_state)\n{\n\tstruct lease *lease = opinfo->o_lease;\n\n\tif (!(lease->state == SMB2_LEASE_NONE_LE)) {\n\t\tksmbd_debug(OPLOCK, \"bad lease state(0x%x)\\n\", lease->state);\n\t\treturn -EINVAL;\n\t}\n\n\tlease->new_state = SMB2_LEASE_NONE_LE;\n\tlease->state = new_state;\n\tif (lease->state & SMB2_LEASE_HANDLE_CACHING_LE)\n\t\tif (lease->state & SMB2_LEASE_WRITE_CACHING_LE)\n\t\t\topinfo->level = SMB2_OPLOCK_LEVEL_BATCH;\n\t\telse\n\t\t\topinfo->level = SMB2_OPLOCK_LEVEL_II;\n\telse if (lease->state & SMB2_LEASE_WRITE_CACHING_LE)\n\t\topinfo->level = SMB2_OPLOCK_LEVEL_EXCLUSIVE;\n\telse if (lease->state & SMB2_LEASE_READ_CACHING_LE)\n\t\topinfo->level = SMB2_OPLOCK_LEVEL_II;\n\n\treturn 0;\n}\n\n \nvoid close_id_del_oplock(struct ksmbd_file *fp)\n{\n\tstruct oplock_info *opinfo;\n\n\tif (fp->reserve_lease_break)\n\t\tsmb_lazy_parent_lease_break_close(fp);\n\n\topinfo = opinfo_get(fp);\n\tif (!opinfo)\n\t\treturn;\n\n\topinfo_del(opinfo);\n\n\trcu_assign_pointer(fp->f_opinfo, NULL);\n\tif (opinfo->op_state == OPLOCK_ACK_WAIT) {\n\t\topinfo->op_state = OPLOCK_CLOSING;\n\t\twake_up_interruptible_all(&opinfo->oplock_q);\n\t\tif (opinfo->is_lease) {\n\t\t\tatomic_set(&opinfo->breaking_cnt, 0);\n\t\t\twake_up_interruptible_all(&opinfo->oplock_brk);\n\t\t}\n\t}\n\n\topinfo_count_dec(fp);\n\tatomic_dec(&opinfo->refcount);\n\topinfo_put(opinfo);\n}\n\n \nstatic void grant_write_oplock(struct oplock_info *opinfo_new, int req_oplock,\n\t\t\t       struct lease_ctx_info *lctx)\n{\n\tstruct lease *lease = opinfo_new->o_lease;\n\n\tif (req_oplock == SMB2_OPLOCK_LEVEL_BATCH)\n\t\topinfo_new->level = SMB2_OPLOCK_LEVEL_BATCH;\n\telse\n\t\topinfo_new->level = SMB2_OPLOCK_LEVEL_EXCLUSIVE;\n\n\tif (lctx) {\n\t\tlease->state = lctx->req_state;\n\t\tmemcpy(lease->lease_key, lctx->lease_key, SMB2_LEASE_KEY_SIZE);\n\t}\n}\n\n \nstatic void grant_read_oplock(struct oplock_info *opinfo_new,\n\t\t\t      struct lease_ctx_info *lctx)\n{\n\tstruct lease *lease = opinfo_new->o_lease;\n\n\topinfo_new->level = SMB2_OPLOCK_LEVEL_II;\n\n\tif (lctx) {\n\t\tlease->state = SMB2_LEASE_READ_CACHING_LE;\n\t\tif (lctx->req_state & SMB2_LEASE_HANDLE_CACHING_LE)\n\t\t\tlease->state |= SMB2_LEASE_HANDLE_CACHING_LE;\n\t\tmemcpy(lease->lease_key, lctx->lease_key, SMB2_LEASE_KEY_SIZE);\n\t}\n}\n\n \nstatic void grant_none_oplock(struct oplock_info *opinfo_new,\n\t\t\t      struct lease_ctx_info *lctx)\n{\n\tstruct lease *lease = opinfo_new->o_lease;\n\n\topinfo_new->level = SMB2_OPLOCK_LEVEL_NONE;\n\n\tif (lctx) {\n\t\tlease->state = 0;\n\t\tmemcpy(lease->lease_key, lctx->lease_key, SMB2_LEASE_KEY_SIZE);\n\t}\n}\n\nstatic inline int compare_guid_key(struct oplock_info *opinfo,\n\t\t\t\t   const char *guid1, const char *key1)\n{\n\tconst char *guid2, *key2;\n\n\tguid2 = opinfo->conn->ClientGUID;\n\tkey2 = opinfo->o_lease->lease_key;\n\tif (!memcmp(guid1, guid2, SMB2_CLIENT_GUID_SIZE) &&\n\t    !memcmp(key1, key2, SMB2_LEASE_KEY_SIZE))\n\t\treturn 1;\n\n\treturn 0;\n}\n\n \nstatic struct oplock_info *same_client_has_lease(struct ksmbd_inode *ci,\n\t\t\t\t\t\t char *client_guid,\n\t\t\t\t\t\t struct lease_ctx_info *lctx)\n{\n\tint ret;\n\tstruct lease *lease;\n\tstruct oplock_info *opinfo;\n\tstruct oplock_info *m_opinfo = NULL;\n\n\tif (!lctx)\n\t\treturn NULL;\n\n\t \n\tread_lock(&ci->m_lock);\n\tlist_for_each_entry(opinfo, &ci->m_op_list, op_entry) {\n\t\tif (!opinfo->is_lease)\n\t\t\tcontinue;\n\t\tread_unlock(&ci->m_lock);\n\t\tlease = opinfo->o_lease;\n\n\t\tret = compare_guid_key(opinfo, client_guid, lctx->lease_key);\n\t\tif (ret) {\n\t\t\tm_opinfo = opinfo;\n\t\t\t \n\t\t\tif (atomic_read(&opinfo->breaking_cnt)) {\n\t\t\t\tread_lock(&ci->m_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tif ((atomic_read(&ci->op_count) +\n\t\t\t     atomic_read(&ci->sop_count)) == 1) {\n\t\t\t\tif (lease->state != SMB2_LEASE_NONE_LE &&\n\t\t\t\t    lease->state == (lctx->req_state & lease->state)) {\n\t\t\t\t\tlease->state |= lctx->req_state;\n\t\t\t\t\tif (lctx->req_state &\n\t\t\t\t\t\tSMB2_LEASE_WRITE_CACHING_LE)\n\t\t\t\t\t\tlease_read_to_write(opinfo);\n\n\t\t\t\t}\n\t\t\t} else if ((atomic_read(&ci->op_count) +\n\t\t\t\t    atomic_read(&ci->sop_count)) > 1) {\n\t\t\t\tif (lctx->req_state ==\n\t\t\t\t    (SMB2_LEASE_READ_CACHING_LE |\n\t\t\t\t     SMB2_LEASE_HANDLE_CACHING_LE))\n\t\t\t\t\tlease->state = lctx->req_state;\n\t\t\t}\n\n\t\t\tif (lctx->req_state && lease->state ==\n\t\t\t    SMB2_LEASE_NONE_LE)\n\t\t\t\tlease_none_upgrade(opinfo, lctx->req_state);\n\t\t}\n\t\tread_lock(&ci->m_lock);\n\t}\n\tread_unlock(&ci->m_lock);\n\n\treturn m_opinfo;\n}\n\nstatic void wait_for_break_ack(struct oplock_info *opinfo)\n{\n\tint rc = 0;\n\n\trc = wait_event_interruptible_timeout(opinfo->oplock_q,\n\t\t\t\t\t      opinfo->op_state == OPLOCK_STATE_NONE ||\n\t\t\t\t\t      opinfo->op_state == OPLOCK_CLOSING,\n\t\t\t\t\t      OPLOCK_WAIT_TIME);\n\n\t \n\tif (!rc) {\n\t\tif (opinfo->is_lease)\n\t\t\topinfo->o_lease->state = SMB2_LEASE_NONE_LE;\n\t\topinfo->level = SMB2_OPLOCK_LEVEL_NONE;\n\t\topinfo->op_state = OPLOCK_STATE_NONE;\n\t}\n}\n\nstatic void wake_up_oplock_break(struct oplock_info *opinfo)\n{\n\tclear_bit_unlock(0, &opinfo->pending_break);\n\t \n\tsmp_mb__after_atomic();\n\twake_up_bit(&opinfo->pending_break, 0);\n}\n\nstatic int oplock_break_pending(struct oplock_info *opinfo, int req_op_level)\n{\n\twhile (test_and_set_bit(0, &opinfo->pending_break)) {\n\t\twait_on_bit(&opinfo->pending_break, 0, TASK_UNINTERRUPTIBLE);\n\n\t\t \n\t\topinfo->open_trunc = 0;\n\n\t\tif (opinfo->op_state == OPLOCK_CLOSING)\n\t\t\treturn -ENOENT;\n\t\telse if (!opinfo->is_lease && opinfo->level <= req_op_level)\n\t\t\treturn 1;\n\t}\n\n\tif (!opinfo->is_lease && opinfo->level <= req_op_level) {\n\t\twake_up_oplock_break(opinfo);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \nstatic void __smb2_oplock_break_noti(struct work_struct *wk)\n{\n\tstruct smb2_oplock_break *rsp = NULL;\n\tstruct ksmbd_work *work = container_of(wk, struct ksmbd_work, work);\n\tstruct oplock_break_info *br_info = work->request_buf;\n\tstruct smb2_hdr *rsp_hdr;\n\tstruct ksmbd_file *fp;\n\n\tfp = ksmbd_lookup_durable_fd(br_info->fid);\n\tif (!fp)\n\t\tgoto out;\n\n\tif (allocate_interim_rsp_buf(work)) {\n\t\tpr_err(\"smb2_allocate_rsp_buf failed! \");\n\t\tksmbd_fd_put(work, fp);\n\t\tgoto out;\n\t}\n\n\trsp_hdr = smb2_get_msg(work->response_buf);\n\tmemset(rsp_hdr, 0, sizeof(struct smb2_hdr) + 2);\n\trsp_hdr->ProtocolId = SMB2_PROTO_NUMBER;\n\trsp_hdr->StructureSize = SMB2_HEADER_STRUCTURE_SIZE;\n\trsp_hdr->CreditRequest = cpu_to_le16(0);\n\trsp_hdr->Command = SMB2_OPLOCK_BREAK;\n\trsp_hdr->Flags = (SMB2_FLAGS_SERVER_TO_REDIR);\n\trsp_hdr->NextCommand = 0;\n\trsp_hdr->MessageId = cpu_to_le64(-1);\n\trsp_hdr->Id.SyncId.ProcessId = 0;\n\trsp_hdr->Id.SyncId.TreeId = 0;\n\trsp_hdr->SessionId = 0;\n\tmemset(rsp_hdr->Signature, 0, 16);\n\n\trsp = smb2_get_msg(work->response_buf);\n\n\trsp->StructureSize = cpu_to_le16(24);\n\tif (!br_info->open_trunc &&\n\t    (br_info->level == SMB2_OPLOCK_LEVEL_BATCH ||\n\t     br_info->level == SMB2_OPLOCK_LEVEL_EXCLUSIVE))\n\t\trsp->OplockLevel = SMB2_OPLOCK_LEVEL_II;\n\telse\n\t\trsp->OplockLevel = SMB2_OPLOCK_LEVEL_NONE;\n\trsp->Reserved = 0;\n\trsp->Reserved2 = 0;\n\trsp->PersistentFid = fp->persistent_id;\n\trsp->VolatileFid = fp->volatile_id;\n\n\tksmbd_fd_put(work, fp);\n\tif (ksmbd_iov_pin_rsp(work, (void *)rsp,\n\t\t\t      sizeof(struct smb2_oplock_break)))\n\t\tgoto out;\n\n\tksmbd_debug(OPLOCK,\n\t\t    \"sending oplock break v_id %llu p_id = %llu lock level = %d\\n\",\n\t\t    rsp->VolatileFid, rsp->PersistentFid, rsp->OplockLevel);\n\n\tksmbd_conn_write(work);\n\nout:\n\tksmbd_free_work_struct(work);\n}\n\n \nstatic int smb2_oplock_break_noti(struct oplock_info *opinfo)\n{\n\tstruct ksmbd_conn *conn = opinfo->conn;\n\tstruct oplock_break_info *br_info;\n\tint ret = 0;\n\tstruct ksmbd_work *work = ksmbd_alloc_work_struct();\n\n\tif (!work)\n\t\treturn -ENOMEM;\n\n\tbr_info = kmalloc(sizeof(struct oplock_break_info), GFP_KERNEL);\n\tif (!br_info) {\n\t\tksmbd_free_work_struct(work);\n\t\treturn -ENOMEM;\n\t}\n\n\tbr_info->level = opinfo->level;\n\tbr_info->fid = opinfo->fid;\n\tbr_info->open_trunc = opinfo->open_trunc;\n\n\twork->request_buf = (char *)br_info;\n\twork->conn = conn;\n\twork->sess = opinfo->sess;\n\n\tif (opinfo->op_state == OPLOCK_ACK_WAIT) {\n\t\tINIT_WORK(&work->work, __smb2_oplock_break_noti);\n\t\tksmbd_queue_work(work);\n\n\t\twait_for_break_ack(opinfo);\n\t} else {\n\t\t__smb2_oplock_break_noti(&work->work);\n\t\tif (opinfo->level == SMB2_OPLOCK_LEVEL_II)\n\t\t\topinfo->level = SMB2_OPLOCK_LEVEL_NONE;\n\t}\n\treturn ret;\n}\n\n \nstatic void __smb2_lease_break_noti(struct work_struct *wk)\n{\n\tstruct smb2_lease_break *rsp = NULL;\n\tstruct ksmbd_work *work = container_of(wk, struct ksmbd_work, work);\n\tstruct lease_break_info *br_info = work->request_buf;\n\tstruct smb2_hdr *rsp_hdr;\n\n\tif (allocate_interim_rsp_buf(work)) {\n\t\tksmbd_debug(OPLOCK, \"smb2_allocate_rsp_buf failed! \");\n\t\tgoto out;\n\t}\n\n\trsp_hdr = smb2_get_msg(work->response_buf);\n\tmemset(rsp_hdr, 0, sizeof(struct smb2_hdr) + 2);\n\trsp_hdr->ProtocolId = SMB2_PROTO_NUMBER;\n\trsp_hdr->StructureSize = SMB2_HEADER_STRUCTURE_SIZE;\n\trsp_hdr->CreditRequest = cpu_to_le16(0);\n\trsp_hdr->Command = SMB2_OPLOCK_BREAK;\n\trsp_hdr->Flags = (SMB2_FLAGS_SERVER_TO_REDIR);\n\trsp_hdr->NextCommand = 0;\n\trsp_hdr->MessageId = cpu_to_le64(-1);\n\trsp_hdr->Id.SyncId.ProcessId = 0;\n\trsp_hdr->Id.SyncId.TreeId = 0;\n\trsp_hdr->SessionId = 0;\n\tmemset(rsp_hdr->Signature, 0, 16);\n\n\trsp = smb2_get_msg(work->response_buf);\n\trsp->StructureSize = cpu_to_le16(44);\n\trsp->Epoch = br_info->epoch;\n\trsp->Flags = 0;\n\n\tif (br_info->curr_state & (SMB2_LEASE_WRITE_CACHING_LE |\n\t\t\tSMB2_LEASE_HANDLE_CACHING_LE))\n\t\trsp->Flags = SMB2_NOTIFY_BREAK_LEASE_FLAG_ACK_REQUIRED;\n\n\tmemcpy(rsp->LeaseKey, br_info->lease_key, SMB2_LEASE_KEY_SIZE);\n\trsp->CurrentLeaseState = br_info->curr_state;\n\trsp->NewLeaseState = br_info->new_state;\n\trsp->BreakReason = 0;\n\trsp->AccessMaskHint = 0;\n\trsp->ShareMaskHint = 0;\n\n\tif (ksmbd_iov_pin_rsp(work, (void *)rsp,\n\t\t\t      sizeof(struct smb2_lease_break)))\n\t\tgoto out;\n\n\tksmbd_conn_write(work);\n\nout:\n\tksmbd_free_work_struct(work);\n}\n\n \nstatic int smb2_lease_break_noti(struct oplock_info *opinfo)\n{\n\tstruct ksmbd_conn *conn = opinfo->conn;\n\tstruct list_head *tmp, *t;\n\tstruct ksmbd_work *work;\n\tstruct lease_break_info *br_info;\n\tstruct lease *lease = opinfo->o_lease;\n\n\twork = ksmbd_alloc_work_struct();\n\tif (!work)\n\t\treturn -ENOMEM;\n\n\tbr_info = kmalloc(sizeof(struct lease_break_info), GFP_KERNEL);\n\tif (!br_info) {\n\t\tksmbd_free_work_struct(work);\n\t\treturn -ENOMEM;\n\t}\n\n\tbr_info->curr_state = lease->state;\n\tbr_info->new_state = lease->new_state;\n\tif (lease->version == 2)\n\t\tbr_info->epoch = cpu_to_le16(++lease->epoch);\n\telse\n\t\tbr_info->epoch = 0;\n\tmemcpy(br_info->lease_key, lease->lease_key, SMB2_LEASE_KEY_SIZE);\n\n\twork->request_buf = (char *)br_info;\n\twork->conn = conn;\n\twork->sess = opinfo->sess;\n\n\tif (opinfo->op_state == OPLOCK_ACK_WAIT) {\n\t\tlist_for_each_safe(tmp, t, &opinfo->interim_list) {\n\t\t\tstruct ksmbd_work *in_work;\n\n\t\t\tin_work = list_entry(tmp, struct ksmbd_work,\n\t\t\t\t\t     interim_entry);\n\t\t\tsetup_async_work(in_work, NULL, NULL);\n\t\t\tsmb2_send_interim_resp(in_work, STATUS_PENDING);\n\t\t\tlist_del_init(&in_work->interim_entry);\n\t\t\trelease_async_work(in_work);\n\t\t}\n\t\tINIT_WORK(&work->work, __smb2_lease_break_noti);\n\t\tksmbd_queue_work(work);\n\t\twait_for_break_ack(opinfo);\n\t} else {\n\t\t__smb2_lease_break_noti(&work->work);\n\t\tif (opinfo->o_lease->new_state == SMB2_LEASE_NONE_LE) {\n\t\t\topinfo->level = SMB2_OPLOCK_LEVEL_NONE;\n\t\t\topinfo->o_lease->state = SMB2_LEASE_NONE_LE;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void wait_lease_breaking(struct oplock_info *opinfo)\n{\n\tif (!opinfo->is_lease)\n\t\treturn;\n\n\twake_up_interruptible_all(&opinfo->oplock_brk);\n\tif (atomic_read(&opinfo->breaking_cnt)) {\n\t\tint ret = 0;\n\n\t\tret = wait_event_interruptible_timeout(opinfo->oplock_brk,\n\t\t\t\t\t\t       atomic_read(&opinfo->breaking_cnt) == 0,\n\t\t\t\t\t\t       HZ);\n\t\tif (!ret)\n\t\t\tatomic_set(&opinfo->breaking_cnt, 0);\n\t}\n}\n\nstatic int oplock_break(struct oplock_info *brk_opinfo, int req_op_level)\n{\n\tint err = 0;\n\n\t \n\tksmbd_debug(OPLOCK,\n\t\t    \"request to send oplock(level : 0x%x) break notification\\n\",\n\t\t    brk_opinfo->level);\n\n\tif (brk_opinfo->is_lease) {\n\t\tstruct lease *lease = brk_opinfo->o_lease;\n\n\t\tatomic_inc(&brk_opinfo->breaking_cnt);\n\n\t\terr = oplock_break_pending(brk_opinfo, req_op_level);\n\t\tif (err)\n\t\t\treturn err < 0 ? err : 0;\n\n\t\tif (brk_opinfo->open_trunc) {\n\t\t\t \n\t\t\tlease->new_state = SMB2_LEASE_NONE_LE;\n\t\t} else {\n\t\t\tif (lease->state & SMB2_LEASE_WRITE_CACHING_LE) {\n\t\t\t\tif (lease->state & SMB2_LEASE_HANDLE_CACHING_LE)\n\t\t\t\t\tlease->new_state =\n\t\t\t\t\t\tSMB2_LEASE_READ_CACHING_LE |\n\t\t\t\t\t\tSMB2_LEASE_HANDLE_CACHING_LE;\n\t\t\t\telse\n\t\t\t\t\tlease->new_state =\n\t\t\t\t\t\tSMB2_LEASE_READ_CACHING_LE;\n\t\t\t} else {\n\t\t\t\tif (lease->state & SMB2_LEASE_HANDLE_CACHING_LE &&\n\t\t\t\t\t\t!lease->is_dir)\n\t\t\t\t\tlease->new_state =\n\t\t\t\t\t\tSMB2_LEASE_READ_CACHING_LE;\n\t\t\t\telse\n\t\t\t\t\tlease->new_state = SMB2_LEASE_NONE_LE;\n\t\t\t}\n\t\t}\n\n\t\tif (lease->state & (SMB2_LEASE_WRITE_CACHING_LE |\n\t\t\t\tSMB2_LEASE_HANDLE_CACHING_LE))\n\t\t\tbrk_opinfo->op_state = OPLOCK_ACK_WAIT;\n\t\telse\n\t\t\tatomic_dec(&brk_opinfo->breaking_cnt);\n\t} else {\n\t\terr = oplock_break_pending(brk_opinfo, req_op_level);\n\t\tif (err)\n\t\t\treturn err < 0 ? err : 0;\n\n\t\tif (brk_opinfo->level == SMB2_OPLOCK_LEVEL_BATCH ||\n\t\t    brk_opinfo->level == SMB2_OPLOCK_LEVEL_EXCLUSIVE)\n\t\t\tbrk_opinfo->op_state = OPLOCK_ACK_WAIT;\n\t}\n\n\tif (brk_opinfo->is_lease)\n\t\terr = smb2_lease_break_noti(brk_opinfo);\n\telse\n\t\terr = smb2_oplock_break_noti(brk_opinfo);\n\n\tksmbd_debug(OPLOCK, \"oplock granted = %d\\n\", brk_opinfo->level);\n\tif (brk_opinfo->op_state == OPLOCK_CLOSING)\n\t\terr = -ENOENT;\n\twake_up_oplock_break(brk_opinfo);\n\n\twait_lease_breaking(brk_opinfo);\n\n\treturn err;\n}\n\nvoid destroy_lease_table(struct ksmbd_conn *conn)\n{\n\tstruct lease_table *lb, *lbtmp;\n\tstruct oplock_info *opinfo;\n\n\twrite_lock(&lease_list_lock);\n\tif (list_empty(&lease_table_list)) {\n\t\twrite_unlock(&lease_list_lock);\n\t\treturn;\n\t}\n\n\tlist_for_each_entry_safe(lb, lbtmp, &lease_table_list, l_entry) {\n\t\tif (conn && memcmp(lb->client_guid, conn->ClientGUID,\n\t\t\t\t   SMB2_CLIENT_GUID_SIZE))\n\t\t\tcontinue;\nagain:\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(opinfo, &lb->lease_list,\n\t\t\t\t\tlease_entry) {\n\t\t\trcu_read_unlock();\n\t\t\tlease_del_list(opinfo);\n\t\t\tgoto again;\n\t\t}\n\t\trcu_read_unlock();\n\t\tlist_del(&lb->l_entry);\n\t\tkfree(lb);\n\t}\n\twrite_unlock(&lease_list_lock);\n}\n\nint find_same_lease_key(struct ksmbd_session *sess, struct ksmbd_inode *ci,\n\t\t\tstruct lease_ctx_info *lctx)\n{\n\tstruct oplock_info *opinfo;\n\tint err = 0;\n\tstruct lease_table *lb;\n\n\tif (!lctx)\n\t\treturn err;\n\n\tread_lock(&lease_list_lock);\n\tif (list_empty(&lease_table_list)) {\n\t\tread_unlock(&lease_list_lock);\n\t\treturn 0;\n\t}\n\n\tlist_for_each_entry(lb, &lease_table_list, l_entry) {\n\t\tif (!memcmp(lb->client_guid, sess->ClientGUID,\n\t\t\t    SMB2_CLIENT_GUID_SIZE))\n\t\t\tgoto found;\n\t}\n\tread_unlock(&lease_list_lock);\n\n\treturn 0;\n\nfound:\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(opinfo, &lb->lease_list, lease_entry) {\n\t\tif (!atomic_inc_not_zero(&opinfo->refcount))\n\t\t\tcontinue;\n\t\trcu_read_unlock();\n\t\tif (opinfo->o_fp->f_ci == ci)\n\t\t\tgoto op_next;\n\t\terr = compare_guid_key(opinfo, sess->ClientGUID,\n\t\t\t\t       lctx->lease_key);\n\t\tif (err) {\n\t\t\terr = -EINVAL;\n\t\t\tksmbd_debug(OPLOCK,\n\t\t\t\t    \"found same lease key is already used in other files\\n\");\n\t\t\topinfo_put(opinfo);\n\t\t\tgoto out;\n\t\t}\nop_next:\n\t\topinfo_put(opinfo);\n\t\trcu_read_lock();\n\t}\n\trcu_read_unlock();\n\nout:\n\tread_unlock(&lease_list_lock);\n\treturn err;\n}\n\nstatic void copy_lease(struct oplock_info *op1, struct oplock_info *op2)\n{\n\tstruct lease *lease1 = op1->o_lease;\n\tstruct lease *lease2 = op2->o_lease;\n\n\top2->level = op1->level;\n\tlease2->state = lease1->state;\n\tmemcpy(lease2->lease_key, lease1->lease_key,\n\t       SMB2_LEASE_KEY_SIZE);\n\tlease2->duration = lease1->duration;\n\tlease2->flags = lease1->flags;\n\tlease2->epoch = lease1->epoch++;\n}\n\nstatic int add_lease_global_list(struct oplock_info *opinfo)\n{\n\tstruct lease_table *lb;\n\n\tread_lock(&lease_list_lock);\n\tlist_for_each_entry(lb, &lease_table_list, l_entry) {\n\t\tif (!memcmp(lb->client_guid, opinfo->conn->ClientGUID,\n\t\t\t    SMB2_CLIENT_GUID_SIZE)) {\n\t\t\topinfo->o_lease->l_lb = lb;\n\t\t\tlease_add_list(opinfo);\n\t\t\tread_unlock(&lease_list_lock);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tread_unlock(&lease_list_lock);\n\n\tlb = kmalloc(sizeof(struct lease_table), GFP_KERNEL);\n\tif (!lb)\n\t\treturn -ENOMEM;\n\n\tmemcpy(lb->client_guid, opinfo->conn->ClientGUID,\n\t       SMB2_CLIENT_GUID_SIZE);\n\tINIT_LIST_HEAD(&lb->lease_list);\n\tspin_lock_init(&lb->lb_lock);\n\topinfo->o_lease->l_lb = lb;\n\tlease_add_list(opinfo);\n\tlb_add(lb);\n\treturn 0;\n}\n\nstatic void set_oplock_level(struct oplock_info *opinfo, int level,\n\t\t\t     struct lease_ctx_info *lctx)\n{\n\tswitch (level) {\n\tcase SMB2_OPLOCK_LEVEL_BATCH:\n\tcase SMB2_OPLOCK_LEVEL_EXCLUSIVE:\n\t\tgrant_write_oplock(opinfo, level, lctx);\n\t\tbreak;\n\tcase SMB2_OPLOCK_LEVEL_II:\n\t\tgrant_read_oplock(opinfo, lctx);\n\t\tbreak;\n\tdefault:\n\t\tgrant_none_oplock(opinfo, lctx);\n\t\tbreak;\n\t}\n}\n\nvoid smb_send_parent_lease_break_noti(struct ksmbd_file *fp,\n\t\t\t\t      struct lease_ctx_info *lctx)\n{\n\tstruct oplock_info *opinfo;\n\tstruct ksmbd_inode *p_ci = NULL;\n\n\tif (lctx->version != 2)\n\t\treturn;\n\n\tp_ci = ksmbd_inode_lookup_lock(fp->filp->f_path.dentry->d_parent);\n\tif (!p_ci)\n\t\treturn;\n\n\tread_lock(&p_ci->m_lock);\n\tlist_for_each_entry(opinfo, &p_ci->m_op_list, op_entry) {\n\t\tif (!opinfo->is_lease)\n\t\t\tcontinue;\n\n\t\tif (opinfo->o_lease->state != SMB2_OPLOCK_LEVEL_NONE &&\n\t\t    (!(lctx->flags & SMB2_LEASE_FLAG_PARENT_LEASE_KEY_SET_LE) ||\n\t\t     !compare_guid_key(opinfo, fp->conn->ClientGUID,\n\t\t\t\t      lctx->parent_lease_key))) {\n\t\t\tif (!atomic_inc_not_zero(&opinfo->refcount))\n\t\t\t\tcontinue;\n\n\t\t\tatomic_inc(&opinfo->conn->r_count);\n\t\t\tif (ksmbd_conn_releasing(opinfo->conn)) {\n\t\t\t\tatomic_dec(&opinfo->conn->r_count);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tread_unlock(&p_ci->m_lock);\n\t\t\toplock_break(opinfo, SMB2_OPLOCK_LEVEL_NONE);\n\t\t\topinfo_conn_put(opinfo);\n\t\t\tread_lock(&p_ci->m_lock);\n\t\t}\n\t}\n\tread_unlock(&p_ci->m_lock);\n\n\tksmbd_inode_put(p_ci);\n}\n\nvoid smb_lazy_parent_lease_break_close(struct ksmbd_file *fp)\n{\n\tstruct oplock_info *opinfo;\n\tstruct ksmbd_inode *p_ci = NULL;\n\n\trcu_read_lock();\n\topinfo = rcu_dereference(fp->f_opinfo);\n\trcu_read_unlock();\n\n\tif (!opinfo->is_lease || opinfo->o_lease->version != 2)\n\t\treturn;\n\n\tp_ci = ksmbd_inode_lookup_lock(fp->filp->f_path.dentry->d_parent);\n\tif (!p_ci)\n\t\treturn;\n\n\tread_lock(&p_ci->m_lock);\n\tlist_for_each_entry(opinfo, &p_ci->m_op_list, op_entry) {\n\t\tif (!opinfo->is_lease)\n\t\t\tcontinue;\n\n\t\tif (opinfo->o_lease->state != SMB2_OPLOCK_LEVEL_NONE) {\n\t\t\tif (!atomic_inc_not_zero(&opinfo->refcount))\n\t\t\t\tcontinue;\n\n\t\t\tatomic_inc(&opinfo->conn->r_count);\n\t\t\tif (ksmbd_conn_releasing(opinfo->conn)) {\n\t\t\t\tatomic_dec(&opinfo->conn->r_count);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tread_unlock(&p_ci->m_lock);\n\t\t\toplock_break(opinfo, SMB2_OPLOCK_LEVEL_NONE);\n\t\t\topinfo_conn_put(opinfo);\n\t\t\tread_lock(&p_ci->m_lock);\n\t\t}\n\t}\n\tread_unlock(&p_ci->m_lock);\n\n\tksmbd_inode_put(p_ci);\n}\n\n \nint smb_grant_oplock(struct ksmbd_work *work, int req_op_level, u64 pid,\n\t\t     struct ksmbd_file *fp, __u16 tid,\n\t\t     struct lease_ctx_info *lctx, int share_ret)\n{\n\tstruct ksmbd_session *sess = work->sess;\n\tint err = 0;\n\tstruct oplock_info *opinfo = NULL, *prev_opinfo = NULL;\n\tstruct ksmbd_inode *ci = fp->f_ci;\n\tbool prev_op_has_lease;\n\t__le32 prev_op_state = 0;\n\n\t \n\tif (S_ISDIR(file_inode(fp->filp)->i_mode)) {\n\t\tif (!lctx || lctx->version != 2)\n\t\t\treturn 0;\n\t}\n\n\topinfo = alloc_opinfo(work, pid, tid);\n\tif (!opinfo)\n\t\treturn -ENOMEM;\n\n\tif (lctx) {\n\t\terr = alloc_lease(opinfo, lctx);\n\t\tif (err)\n\t\t\tgoto err_out;\n\t\topinfo->is_lease = 1;\n\t}\n\n\t \n\tif (!opinfo_count(fp))\n\t\tgoto set_lev;\n\n\t \n\tif (fp->attrib_only && fp->cdoption != FILE_OVERWRITE_IF_LE &&\n\t    fp->cdoption != FILE_OVERWRITE_LE &&\n\t    fp->cdoption != FILE_SUPERSEDE_LE) {\n\t\treq_op_level = SMB2_OPLOCK_LEVEL_NONE;\n\t\tgoto set_lev;\n\t}\n\n\tif (lctx) {\n\t\tstruct oplock_info *m_opinfo;\n\n\t\t \n\t\tm_opinfo = same_client_has_lease(ci, sess->ClientGUID,\n\t\t\t\t\t\t lctx);\n\t\tif (m_opinfo) {\n\t\t\tcopy_lease(m_opinfo, opinfo);\n\t\t\tif (atomic_read(&m_opinfo->breaking_cnt))\n\t\t\t\topinfo->o_lease->flags =\n\t\t\t\t\tSMB2_LEASE_FLAG_BREAK_IN_PROGRESS_LE;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tprev_opinfo = opinfo_get_list(ci);\n\tif (!prev_opinfo ||\n\t    (prev_opinfo->level == SMB2_OPLOCK_LEVEL_NONE && lctx)) {\n\t\topinfo_conn_put(prev_opinfo);\n\t\tgoto set_lev;\n\t}\n\tprev_op_has_lease = prev_opinfo->is_lease;\n\tif (prev_op_has_lease)\n\t\tprev_op_state = prev_opinfo->o_lease->state;\n\n\tif (share_ret < 0 &&\n\t    prev_opinfo->level == SMB2_OPLOCK_LEVEL_EXCLUSIVE) {\n\t\terr = share_ret;\n\t\topinfo_conn_put(prev_opinfo);\n\t\tgoto err_out;\n\t}\n\n\tif (prev_opinfo->level != SMB2_OPLOCK_LEVEL_BATCH &&\n\t    prev_opinfo->level != SMB2_OPLOCK_LEVEL_EXCLUSIVE) {\n\t\topinfo_conn_put(prev_opinfo);\n\t\tgoto op_break_not_needed;\n\t}\n\n\tlist_add(&work->interim_entry, &prev_opinfo->interim_list);\n\terr = oplock_break(prev_opinfo, SMB2_OPLOCK_LEVEL_II);\n\topinfo_conn_put(prev_opinfo);\n\tif (err == -ENOENT)\n\t\tgoto set_lev;\n\t \n\telse if (err < 0)\n\t\tgoto err_out;\n\nop_break_not_needed:\n\tif (share_ret < 0) {\n\t\terr = share_ret;\n\t\tgoto err_out;\n\t}\n\n\tif (req_op_level != SMB2_OPLOCK_LEVEL_NONE)\n\t\treq_op_level = SMB2_OPLOCK_LEVEL_II;\n\n\t \n\tif (prev_op_has_lease && !lctx)\n\t\tif (prev_op_state & SMB2_LEASE_HANDLE_CACHING_LE)\n\t\t\treq_op_level = SMB2_OPLOCK_LEVEL_NONE;\n\n\tif (!prev_op_has_lease && lctx) {\n\t\treq_op_level = SMB2_OPLOCK_LEVEL_II;\n\t\tlctx->req_state = SMB2_LEASE_READ_CACHING_LE;\n\t}\n\nset_lev:\n\tset_oplock_level(opinfo, req_op_level, lctx);\n\nout:\n\trcu_assign_pointer(fp->f_opinfo, opinfo);\n\topinfo->o_fp = fp;\n\n\topinfo_count_inc(fp);\n\topinfo_add(opinfo);\n\tif (opinfo->is_lease) {\n\t\terr = add_lease_global_list(opinfo);\n\t\tif (err)\n\t\t\tgoto err_out;\n\t}\n\n\treturn 0;\nerr_out:\n\tfree_opinfo(opinfo);\n\treturn err;\n}\n\n \nstatic void smb_break_all_write_oplock(struct ksmbd_work *work,\n\t\t\t\t       struct ksmbd_file *fp, int is_trunc)\n{\n\tstruct oplock_info *brk_opinfo;\n\n\tbrk_opinfo = opinfo_get_list(fp->f_ci);\n\tif (!brk_opinfo)\n\t\treturn;\n\tif (brk_opinfo->level != SMB2_OPLOCK_LEVEL_BATCH &&\n\t    brk_opinfo->level != SMB2_OPLOCK_LEVEL_EXCLUSIVE) {\n\t\topinfo_conn_put(brk_opinfo);\n\t\treturn;\n\t}\n\n\tbrk_opinfo->open_trunc = is_trunc;\n\tlist_add(&work->interim_entry, &brk_opinfo->interim_list);\n\toplock_break(brk_opinfo, SMB2_OPLOCK_LEVEL_II);\n\topinfo_conn_put(brk_opinfo);\n}\n\n \nvoid smb_break_all_levII_oplock(struct ksmbd_work *work, struct ksmbd_file *fp,\n\t\t\t\tint is_trunc)\n{\n\tstruct oplock_info *op, *brk_op;\n\tstruct ksmbd_inode *ci;\n\tstruct ksmbd_conn *conn = work->conn;\n\n\tif (!test_share_config_flag(work->tcon->share_conf,\n\t\t\t\t    KSMBD_SHARE_FLAG_OPLOCKS))\n\t\treturn;\n\n\tci = fp->f_ci;\n\top = opinfo_get(fp);\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(brk_op, &ci->m_op_list, op_entry) {\n\t\tif (!atomic_inc_not_zero(&brk_op->refcount))\n\t\t\tcontinue;\n\n\t\tatomic_inc(&brk_op->conn->r_count);\n\t\tif (ksmbd_conn_releasing(brk_op->conn)) {\n\t\t\tatomic_dec(&brk_op->conn->r_count);\n\t\t\tcontinue;\n\t\t}\n\n\t\trcu_read_unlock();\n\t\tif (brk_op->is_lease && (brk_op->o_lease->state &\n\t\t    (~(SMB2_LEASE_READ_CACHING_LE |\n\t\t\t\tSMB2_LEASE_HANDLE_CACHING_LE)))) {\n\t\t\tksmbd_debug(OPLOCK, \"unexpected lease state(0x%x)\\n\",\n\t\t\t\t    brk_op->o_lease->state);\n\t\t\tgoto next;\n\t\t} else if (brk_op->level !=\n\t\t\t\tSMB2_OPLOCK_LEVEL_II) {\n\t\t\tksmbd_debug(OPLOCK, \"unexpected oplock(0x%x)\\n\",\n\t\t\t\t    brk_op->level);\n\t\t\tgoto next;\n\t\t}\n\n\t\t \n\t\tif (brk_op->is_lease &&\n\t\t    brk_op->o_lease->new_state == SMB2_LEASE_NONE_LE &&\n\t\t    atomic_read(&brk_op->breaking_cnt))\n\t\t\tgoto next;\n\n\t\tif (op && op->is_lease && brk_op->is_lease &&\n\t\t    !memcmp(conn->ClientGUID, brk_op->conn->ClientGUID,\n\t\t\t    SMB2_CLIENT_GUID_SIZE) &&\n\t\t    !memcmp(op->o_lease->lease_key, brk_op->o_lease->lease_key,\n\t\t\t    SMB2_LEASE_KEY_SIZE))\n\t\t\tgoto next;\n\t\tbrk_op->open_trunc = is_trunc;\n\t\toplock_break(brk_op, SMB2_OPLOCK_LEVEL_NONE);\nnext:\n\t\topinfo_conn_put(brk_op);\n\t\trcu_read_lock();\n\t}\n\trcu_read_unlock();\n\n\tif (op)\n\t\topinfo_put(op);\n}\n\n \nvoid smb_break_all_oplock(struct ksmbd_work *work, struct ksmbd_file *fp)\n{\n\tif (!test_share_config_flag(work->tcon->share_conf,\n\t\t\t\t    KSMBD_SHARE_FLAG_OPLOCKS))\n\t\treturn;\n\n\tsmb_break_all_write_oplock(work, fp, 1);\n\tsmb_break_all_levII_oplock(work, fp, 1);\n}\n\n \n__u8 smb2_map_lease_to_oplock(__le32 lease_state)\n{\n\tif (lease_state == (SMB2_LEASE_HANDLE_CACHING_LE |\n\t\t\t    SMB2_LEASE_READ_CACHING_LE |\n\t\t\t    SMB2_LEASE_WRITE_CACHING_LE)) {\n\t\treturn SMB2_OPLOCK_LEVEL_BATCH;\n\t} else if (lease_state != SMB2_LEASE_WRITE_CACHING_LE &&\n\t\t lease_state & SMB2_LEASE_WRITE_CACHING_LE) {\n\t\tif (!(lease_state & SMB2_LEASE_HANDLE_CACHING_LE))\n\t\t\treturn SMB2_OPLOCK_LEVEL_EXCLUSIVE;\n\t} else if (lease_state & SMB2_LEASE_READ_CACHING_LE) {\n\t\treturn SMB2_OPLOCK_LEVEL_II;\n\t}\n\treturn 0;\n}\n\n \nvoid create_lease_buf(u8 *rbuf, struct lease *lease)\n{\n\tif (lease->version == 2) {\n\t\tstruct create_lease_v2 *buf = (struct create_lease_v2 *)rbuf;\n\n\t\tmemset(buf, 0, sizeof(struct create_lease_v2));\n\t\tmemcpy(buf->lcontext.LeaseKey, lease->lease_key,\n\t\t       SMB2_LEASE_KEY_SIZE);\n\t\tbuf->lcontext.LeaseFlags = lease->flags;\n\t\tbuf->lcontext.Epoch = cpu_to_le16(++lease->epoch);\n\t\tbuf->lcontext.LeaseState = lease->state;\n\t\tmemcpy(buf->lcontext.ParentLeaseKey, lease->parent_lease_key,\n\t\t       SMB2_LEASE_KEY_SIZE);\n\t\tbuf->ccontext.DataOffset = cpu_to_le16(offsetof\n\t\t\t\t(struct create_lease_v2, lcontext));\n\t\tbuf->ccontext.DataLength = cpu_to_le32(sizeof(struct lease_context_v2));\n\t\tbuf->ccontext.NameOffset = cpu_to_le16(offsetof\n\t\t\t\t(struct create_lease_v2, Name));\n\t\tbuf->ccontext.NameLength = cpu_to_le16(4);\n\t\tbuf->Name[0] = 'R';\n\t\tbuf->Name[1] = 'q';\n\t\tbuf->Name[2] = 'L';\n\t\tbuf->Name[3] = 's';\n\t} else {\n\t\tstruct create_lease *buf = (struct create_lease *)rbuf;\n\n\t\tmemset(buf, 0, sizeof(struct create_lease));\n\t\tmemcpy(buf->lcontext.LeaseKey, lease->lease_key, SMB2_LEASE_KEY_SIZE);\n\t\tbuf->lcontext.LeaseFlags = lease->flags;\n\t\tbuf->lcontext.LeaseState = lease->state;\n\t\tbuf->ccontext.DataOffset = cpu_to_le16(offsetof\n\t\t\t\t(struct create_lease, lcontext));\n\t\tbuf->ccontext.DataLength = cpu_to_le32(sizeof(struct lease_context));\n\t\tbuf->ccontext.NameOffset = cpu_to_le16(offsetof\n\t\t\t\t(struct create_lease, Name));\n\t\tbuf->ccontext.NameLength = cpu_to_le16(4);\n\t\tbuf->Name[0] = 'R';\n\t\tbuf->Name[1] = 'q';\n\t\tbuf->Name[2] = 'L';\n\t\tbuf->Name[3] = 's';\n\t}\n}\n\n \nstruct lease_ctx_info *parse_lease_state(void *open_req, bool is_dir)\n{\n\tstruct create_context *cc;\n\tstruct smb2_create_req *req = (struct smb2_create_req *)open_req;\n\tstruct lease_ctx_info *lreq;\n\n\tcc = smb2_find_context_vals(req, SMB2_CREATE_REQUEST_LEASE, 4);\n\tif (IS_ERR_OR_NULL(cc))\n\t\treturn NULL;\n\n\tlreq = kzalloc(sizeof(struct lease_ctx_info), GFP_KERNEL);\n\tif (!lreq)\n\t\treturn NULL;\n\n\tif (sizeof(struct lease_context_v2) == le32_to_cpu(cc->DataLength)) {\n\t\tstruct create_lease_v2 *lc = (struct create_lease_v2 *)cc;\n\n\t\tmemcpy(lreq->lease_key, lc->lcontext.LeaseKey, SMB2_LEASE_KEY_SIZE);\n\t\tif (is_dir) {\n\t\t\tlreq->req_state = lc->lcontext.LeaseState &\n\t\t\t\t~SMB2_LEASE_WRITE_CACHING_LE;\n\t\t\tlreq->is_dir = true;\n\t\t} else\n\t\t\tlreq->req_state = lc->lcontext.LeaseState;\n\t\tlreq->flags = lc->lcontext.LeaseFlags;\n\t\tlreq->epoch = lc->lcontext.Epoch;\n\t\tlreq->duration = lc->lcontext.LeaseDuration;\n\t\tmemcpy(lreq->parent_lease_key, lc->lcontext.ParentLeaseKey,\n\t\t\t\tSMB2_LEASE_KEY_SIZE);\n\t\tlreq->version = 2;\n\t} else {\n\t\tstruct create_lease *lc = (struct create_lease *)cc;\n\n\t\tmemcpy(lreq->lease_key, lc->lcontext.LeaseKey, SMB2_LEASE_KEY_SIZE);\n\t\tlreq->req_state = lc->lcontext.LeaseState;\n\t\tlreq->flags = lc->lcontext.LeaseFlags;\n\t\tlreq->duration = lc->lcontext.LeaseDuration;\n\t\tlreq->version = 1;\n\t}\n\treturn lreq;\n}\n\n \nstruct create_context *smb2_find_context_vals(void *open_req, const char *tag, int tag_len)\n{\n\tstruct create_context *cc;\n\tunsigned int next = 0;\n\tchar *name;\n\tstruct smb2_create_req *req = (struct smb2_create_req *)open_req;\n\tunsigned int remain_len, name_off, name_len, value_off, value_len,\n\t\t     cc_len;\n\n\t \n\tcc = (struct create_context *)((char *)req +\n\t\t\t\t       le32_to_cpu(req->CreateContextsOffset));\n\tremain_len = le32_to_cpu(req->CreateContextsLength);\n\tdo {\n\t\tcc = (struct create_context *)((char *)cc + next);\n\t\tif (remain_len < offsetof(struct create_context, Buffer))\n\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\tnext = le32_to_cpu(cc->Next);\n\t\tname_off = le16_to_cpu(cc->NameOffset);\n\t\tname_len = le16_to_cpu(cc->NameLength);\n\t\tvalue_off = le16_to_cpu(cc->DataOffset);\n\t\tvalue_len = le32_to_cpu(cc->DataLength);\n\t\tcc_len = next ? next : remain_len;\n\n\t\tif ((next & 0x7) != 0 ||\n\t\t    next > remain_len ||\n\t\t    name_off != offsetof(struct create_context, Buffer) ||\n\t\t    name_len < 4 ||\n\t\t    name_off + name_len > cc_len ||\n\t\t    (value_off & 0x7) != 0 ||\n\t\t    (value_len && value_off < name_off + (name_len < 8 ? 8 : name_len)) ||\n\t\t    ((u64)value_off + value_len > cc_len))\n\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\tname = (char *)cc + name_off;\n\t\tif (name_len == tag_len && !memcmp(name, tag, name_len))\n\t\t\treturn cc;\n\n\t\tremain_len -= next;\n\t} while (next != 0);\n\n\treturn NULL;\n}\n\n \nvoid create_durable_rsp_buf(char *cc)\n{\n\tstruct create_durable_rsp *buf;\n\n\tbuf = (struct create_durable_rsp *)cc;\n\tmemset(buf, 0, sizeof(struct create_durable_rsp));\n\tbuf->ccontext.DataOffset = cpu_to_le16(offsetof\n\t\t\t(struct create_durable_rsp, Data));\n\tbuf->ccontext.DataLength = cpu_to_le32(8);\n\tbuf->ccontext.NameOffset = cpu_to_le16(offsetof\n\t\t\t(struct create_durable_rsp, Name));\n\tbuf->ccontext.NameLength = cpu_to_le16(4);\n\t \n\tbuf->Name[0] = 'D';\n\tbuf->Name[1] = 'H';\n\tbuf->Name[2] = 'n';\n\tbuf->Name[3] = 'Q';\n}\n\n \nvoid create_durable_v2_rsp_buf(char *cc, struct ksmbd_file *fp)\n{\n\tstruct create_durable_v2_rsp *buf;\n\n\tbuf = (struct create_durable_v2_rsp *)cc;\n\tmemset(buf, 0, sizeof(struct create_durable_rsp));\n\tbuf->ccontext.DataOffset = cpu_to_le16(offsetof\n\t\t\t(struct create_durable_rsp, Data));\n\tbuf->ccontext.DataLength = cpu_to_le32(8);\n\tbuf->ccontext.NameOffset = cpu_to_le16(offsetof\n\t\t\t(struct create_durable_rsp, Name));\n\tbuf->ccontext.NameLength = cpu_to_le16(4);\n\t \n\tbuf->Name[0] = 'D';\n\tbuf->Name[1] = 'H';\n\tbuf->Name[2] = '2';\n\tbuf->Name[3] = 'Q';\n\n\tbuf->Timeout = cpu_to_le32(fp->durable_timeout);\n}\n\n \nvoid create_mxac_rsp_buf(char *cc, int maximal_access)\n{\n\tstruct create_mxac_rsp *buf;\n\n\tbuf = (struct create_mxac_rsp *)cc;\n\tmemset(buf, 0, sizeof(struct create_mxac_rsp));\n\tbuf->ccontext.DataOffset = cpu_to_le16(offsetof\n\t\t\t(struct create_mxac_rsp, QueryStatus));\n\tbuf->ccontext.DataLength = cpu_to_le32(8);\n\tbuf->ccontext.NameOffset = cpu_to_le16(offsetof\n\t\t\t(struct create_mxac_rsp, Name));\n\tbuf->ccontext.NameLength = cpu_to_le16(4);\n\t \n\tbuf->Name[0] = 'M';\n\tbuf->Name[1] = 'x';\n\tbuf->Name[2] = 'A';\n\tbuf->Name[3] = 'c';\n\n\tbuf->QueryStatus = STATUS_SUCCESS;\n\tbuf->MaximalAccess = cpu_to_le32(maximal_access);\n}\n\nvoid create_disk_id_rsp_buf(char *cc, __u64 file_id, __u64 vol_id)\n{\n\tstruct create_disk_id_rsp *buf;\n\n\tbuf = (struct create_disk_id_rsp *)cc;\n\tmemset(buf, 0, sizeof(struct create_disk_id_rsp));\n\tbuf->ccontext.DataOffset = cpu_to_le16(offsetof\n\t\t\t(struct create_disk_id_rsp, DiskFileId));\n\tbuf->ccontext.DataLength = cpu_to_le32(32);\n\tbuf->ccontext.NameOffset = cpu_to_le16(offsetof\n\t\t\t(struct create_mxac_rsp, Name));\n\tbuf->ccontext.NameLength = cpu_to_le16(4);\n\t \n\tbuf->Name[0] = 'Q';\n\tbuf->Name[1] = 'F';\n\tbuf->Name[2] = 'i';\n\tbuf->Name[3] = 'd';\n\n\tbuf->DiskFileId = cpu_to_le64(file_id);\n\tbuf->VolumeId = cpu_to_le64(vol_id);\n}\n\n \nvoid create_posix_rsp_buf(char *cc, struct ksmbd_file *fp)\n{\n\tstruct create_posix_rsp *buf;\n\tstruct inode *inode = file_inode(fp->filp);\n\tstruct mnt_idmap *idmap = file_mnt_idmap(fp->filp);\n\tvfsuid_t vfsuid = i_uid_into_vfsuid(idmap, inode);\n\tvfsgid_t vfsgid = i_gid_into_vfsgid(idmap, inode);\n\n\tbuf = (struct create_posix_rsp *)cc;\n\tmemset(buf, 0, sizeof(struct create_posix_rsp));\n\tbuf->ccontext.DataOffset = cpu_to_le16(offsetof\n\t\t\t(struct create_posix_rsp, nlink));\n\t \n\tbuf->ccontext.DataLength = cpu_to_le32(56);\n\tbuf->ccontext.NameOffset = cpu_to_le16(offsetof\n\t\t\t(struct create_posix_rsp, Name));\n\tbuf->ccontext.NameLength = cpu_to_le16(POSIX_CTXT_DATA_LEN);\n\t \n\tbuf->Name[0] = 0x93;\n\tbuf->Name[1] = 0xAD;\n\tbuf->Name[2] = 0x25;\n\tbuf->Name[3] = 0x50;\n\tbuf->Name[4] = 0x9C;\n\tbuf->Name[5] = 0xB4;\n\tbuf->Name[6] = 0x11;\n\tbuf->Name[7] = 0xE7;\n\tbuf->Name[8] = 0xB4;\n\tbuf->Name[9] = 0x23;\n\tbuf->Name[10] = 0x83;\n\tbuf->Name[11] = 0xDE;\n\tbuf->Name[12] = 0x96;\n\tbuf->Name[13] = 0x8B;\n\tbuf->Name[14] = 0xCD;\n\tbuf->Name[15] = 0x7C;\n\n\tbuf->nlink = cpu_to_le32(inode->i_nlink);\n\tbuf->reparse_tag = cpu_to_le32(fp->volatile_id);\n\tbuf->mode = cpu_to_le32(inode->i_mode & 0777);\n\t \n\tid_to_sid(from_kuid_munged(&init_user_ns, vfsuid_into_kuid(vfsuid)),\n\t\t  SIDOWNER, (struct smb_sid *)&buf->SidBuffer[0]);\n\tid_to_sid(from_kgid_munged(&init_user_ns, vfsgid_into_kgid(vfsgid)),\n\t\t  SIDUNIX_GROUP, (struct smb_sid *)&buf->SidBuffer[28]);\n}\n\n \n \nstruct oplock_info *lookup_lease_in_table(struct ksmbd_conn *conn,\n\t\t\t\t\t  char *lease_key)\n{\n\tstruct oplock_info *opinfo = NULL, *ret_op = NULL;\n\tstruct lease_table *lt;\n\tint ret;\n\n\tread_lock(&lease_list_lock);\n\tlist_for_each_entry(lt, &lease_table_list, l_entry) {\n\t\tif (!memcmp(lt->client_guid, conn->ClientGUID,\n\t\t\t    SMB2_CLIENT_GUID_SIZE))\n\t\t\tgoto found;\n\t}\n\n\tread_unlock(&lease_list_lock);\n\treturn NULL;\n\nfound:\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(opinfo, &lt->lease_list, lease_entry) {\n\t\tif (!atomic_inc_not_zero(&opinfo->refcount))\n\t\t\tcontinue;\n\t\trcu_read_unlock();\n\t\tif (!opinfo->op_state || opinfo->op_state == OPLOCK_CLOSING)\n\t\t\tgoto op_next;\n\t\tif (!(opinfo->o_lease->state &\n\t\t      (SMB2_LEASE_HANDLE_CACHING_LE |\n\t\t       SMB2_LEASE_WRITE_CACHING_LE)))\n\t\t\tgoto op_next;\n\t\tret = compare_guid_key(opinfo, conn->ClientGUID,\n\t\t\t\t       lease_key);\n\t\tif (ret) {\n\t\t\tksmbd_debug(OPLOCK, \"found opinfo\\n\");\n\t\t\tret_op = opinfo;\n\t\t\tgoto out;\n\t\t}\nop_next:\n\t\topinfo_put(opinfo);\n\t\trcu_read_lock();\n\t}\n\trcu_read_unlock();\n\nout:\n\tread_unlock(&lease_list_lock);\n\treturn ret_op;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}