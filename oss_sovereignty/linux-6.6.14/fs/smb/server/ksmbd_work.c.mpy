{
  "module_name": "ksmbd_work.c",
  "hash_id": "ff2e77f6197969f098894aaf47a3cd9b5cab231daa2e5ebc270e74e303efcf33",
  "original_prompt": "Ingested from linux-6.6.14/fs/smb/server/ksmbd_work.c",
  "human_readable_source": "\n \n\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n\n#include \"server.h\"\n#include \"connection.h\"\n#include \"ksmbd_work.h\"\n#include \"mgmt/ksmbd_ida.h\"\n\nstatic struct kmem_cache *work_cache;\nstatic struct workqueue_struct *ksmbd_wq;\n\nstruct ksmbd_work *ksmbd_alloc_work_struct(void)\n{\n\tstruct ksmbd_work *work = kmem_cache_zalloc(work_cache, GFP_KERNEL);\n\n\tif (work) {\n\t\twork->compound_fid = KSMBD_NO_FID;\n\t\twork->compound_pfid = KSMBD_NO_FID;\n\t\tINIT_LIST_HEAD(&work->request_entry);\n\t\tINIT_LIST_HEAD(&work->async_request_entry);\n\t\tINIT_LIST_HEAD(&work->fp_entry);\n\t\tINIT_LIST_HEAD(&work->interim_entry);\n\t\tINIT_LIST_HEAD(&work->aux_read_list);\n\t\twork->iov_alloc_cnt = 4;\n\t\twork->iov = kcalloc(work->iov_alloc_cnt, sizeof(struct kvec),\n\t\t\t\t    GFP_KERNEL);\n\t\tif (!work->iov) {\n\t\t\tkmem_cache_free(work_cache, work);\n\t\t\twork = NULL;\n\t\t}\n\t}\n\treturn work;\n}\n\nvoid ksmbd_free_work_struct(struct ksmbd_work *work)\n{\n\tstruct aux_read *ar, *tmp;\n\n\tWARN_ON(work->saved_cred != NULL);\n\n\tkvfree(work->response_buf);\n\n\tlist_for_each_entry_safe(ar, tmp, &work->aux_read_list, entry) {\n\t\tkvfree(ar->buf);\n\t\tlist_del(&ar->entry);\n\t\tkfree(ar);\n\t}\n\n\tkfree(work->tr_buf);\n\tkvfree(work->request_buf);\n\tkfree(work->iov);\n\tif (!list_empty(&work->interim_entry))\n\t\tlist_del(&work->interim_entry);\n\n\tif (work->async_id)\n\t\tksmbd_release_id(&work->conn->async_ida, work->async_id);\n\tkmem_cache_free(work_cache, work);\n}\n\nvoid ksmbd_work_pool_destroy(void)\n{\n\tkmem_cache_destroy(work_cache);\n}\n\nint ksmbd_work_pool_init(void)\n{\n\twork_cache = kmem_cache_create(\"ksmbd_work_cache\",\n\t\t\t\t       sizeof(struct ksmbd_work), 0,\n\t\t\t\t       SLAB_HWCACHE_ALIGN, NULL);\n\tif (!work_cache)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nint ksmbd_workqueue_init(void)\n{\n\tksmbd_wq = alloc_workqueue(\"ksmbd-io\", 0, 0);\n\tif (!ksmbd_wq)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nvoid ksmbd_workqueue_destroy(void)\n{\n\tdestroy_workqueue(ksmbd_wq);\n\tksmbd_wq = NULL;\n}\n\nbool ksmbd_queue_work(struct ksmbd_work *work)\n{\n\treturn queue_work(ksmbd_wq, &work->work);\n}\n\nstatic inline void __ksmbd_iov_pin(struct ksmbd_work *work, void *ib,\n\t\t\t\t   unsigned int ib_len)\n{\n\twork->iov[++work->iov_idx].iov_base = ib;\n\twork->iov[work->iov_idx].iov_len = ib_len;\n\twork->iov_cnt++;\n}\n\nstatic int __ksmbd_iov_pin_rsp(struct ksmbd_work *work, void *ib, int len,\n\t\t\t       void *aux_buf, unsigned int aux_size)\n{\n\tstruct aux_read *ar = NULL;\n\tint need_iov_cnt = 1;\n\n\tif (aux_size) {\n\t\tneed_iov_cnt++;\n\t\tar = kmalloc(sizeof(struct aux_read), GFP_KERNEL);\n\t\tif (!ar)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (work->iov_alloc_cnt < work->iov_cnt + need_iov_cnt) {\n\t\tstruct kvec *new;\n\n\t\twork->iov_alloc_cnt += 4;\n\t\tnew = krealloc(work->iov,\n\t\t\t       sizeof(struct kvec) * work->iov_alloc_cnt,\n\t\t\t       GFP_KERNEL | __GFP_ZERO);\n\t\tif (!new) {\n\t\t\tkfree(ar);\n\t\t\twork->iov_alloc_cnt -= 4;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\twork->iov = new;\n\t}\n\n\t \n\tif (!work->iov_idx) {\n\t\twork->iov[work->iov_idx].iov_base = work->response_buf;\n\t\t*(__be32 *)work->iov[0].iov_base = 0;\n\t\twork->iov[work->iov_idx].iov_len = 4;\n\t\twork->iov_cnt++;\n\t}\n\n\t__ksmbd_iov_pin(work, ib, len);\n\tinc_rfc1001_len(work->iov[0].iov_base, len);\n\n\tif (aux_size) {\n\t\t__ksmbd_iov_pin(work, aux_buf, aux_size);\n\t\tinc_rfc1001_len(work->iov[0].iov_base, aux_size);\n\n\t\tar->buf = aux_buf;\n\t\tlist_add(&ar->entry, &work->aux_read_list);\n\t}\n\n\treturn 0;\n}\n\nint ksmbd_iov_pin_rsp(struct ksmbd_work *work, void *ib, int len)\n{\n\treturn __ksmbd_iov_pin_rsp(work, ib, len, NULL, 0);\n}\n\nint ksmbd_iov_pin_rsp_read(struct ksmbd_work *work, void *ib, int len,\n\t\t\t   void *aux_buf, unsigned int aux_size)\n{\n\treturn __ksmbd_iov_pin_rsp(work, ib, len, aux_buf, aux_size);\n}\n\nint allocate_interim_rsp_buf(struct ksmbd_work *work)\n{\n\twork->response_buf = kzalloc(MAX_CIFS_SMALL_BUFFER_SIZE, GFP_KERNEL);\n\tif (!work->response_buf)\n\t\treturn -ENOMEM;\n\twork->response_sz = MAX_CIFS_SMALL_BUFFER_SIZE;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}