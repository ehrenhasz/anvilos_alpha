{
  "module_name": "vfs_cache.h",
  "hash_id": "bc8cc9fee2cdd3be75160b4c8c1a56df0e6c86582b4e798e4bffc2ca31c470ab",
  "original_prompt": "Ingested from linux-6.6.14/fs/smb/server/vfs_cache.h",
  "human_readable_source": " \n \n\n#ifndef __VFS_CACHE_H__\n#define __VFS_CACHE_H__\n\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/idr.h>\n#include <linux/workqueue.h>\n\n#include \"vfs.h\"\n\n \n#define\tFILE_GENERIC_ALL\t0x1F01FF\n#define\tFILE_GENERIC_READ\t0x120089\n#define\tFILE_GENERIC_WRITE\t0x120116\n#define\tFILE_GENERIC_EXECUTE\t0X1200a0\n\n#define KSMBD_START_FID\t\t0\n#define KSMBD_NO_FID\t\t(INT_MAX)\n#define SMB2_NO_FID\t\t(0xFFFFFFFFFFFFFFFFULL)\n\nstruct ksmbd_conn;\nstruct ksmbd_session;\n\nstruct ksmbd_lock {\n\tstruct file_lock *fl;\n\tstruct list_head clist;\n\tstruct list_head flist;\n\tstruct list_head llist;\n\tunsigned int flags;\n\tint cmd;\n\tint zero_len;\n\tunsigned long long start;\n\tunsigned long long end;\n};\n\nstruct stream {\n\tchar *name;\n\tssize_t size;\n};\n\nstruct ksmbd_inode {\n\trwlock_t\t\t\tm_lock;\n\tatomic_t\t\t\tm_count;\n\tatomic_t\t\t\top_count;\n\t \n\tatomic_t\t\t\tsop_count;\n\tstruct dentry\t\t\t*m_de;\n\tunsigned int\t\t\tm_flags;\n\tstruct hlist_node\t\tm_hash;\n\tstruct list_head\t\tm_fp_list;\n\tstruct list_head\t\tm_op_list;\n\tstruct oplock_info\t\t*m_opinfo;\n\t__le32\t\t\t\tm_fattr;\n};\n\nenum {\n\tFP_NEW = 0,\n\tFP_INITED,\n\tFP_CLOSED\n};\n\nstruct ksmbd_file {\n\tstruct file\t\t\t*filp;\n\tu64\t\t\t\tpersistent_id;\n\tu64\t\t\t\tvolatile_id;\n\n\tspinlock_t\t\t\tf_lock;\n\n\tstruct ksmbd_inode\t\t*f_ci;\n\tstruct ksmbd_inode\t\t*f_parent_ci;\n\tstruct oplock_info __rcu\t*f_opinfo;\n\tstruct ksmbd_conn\t\t*conn;\n\tstruct ksmbd_tree_connect\t*tcon;\n\n\tatomic_t\t\t\trefcount;\n\t__le32\t\t\t\tdaccess;\n\t__le32\t\t\t\tsaccess;\n\t__le32\t\t\t\tcoption;\n\t__le32\t\t\t\tcdoption;\n\t__u64\t\t\t\tcreate_time;\n\t__u64\t\t\t\titime;\n\n\tbool\t\t\t\tis_nt_open;\n\tbool\t\t\t\tattrib_only;\n\n\tchar\t\t\t\tclient_guid[16];\n\tchar\t\t\t\tcreate_guid[16];\n\tchar\t\t\t\tapp_instance_id[16];\n\n\tstruct stream\t\t\tstream;\n\tstruct list_head\t\tnode;\n\tstruct list_head\t\tblocked_works;\n\tstruct list_head\t\tlock_list;\n\n\tint\t\t\t\tdurable_timeout;\n\n\t \n\tstruct ksmbd_readdir_data\treaddir_data;\n\tint\t\t\t\tdot_dotdot[2];\n\tunsigned int\t\t\tf_state;\n\tbool\t\t\t\treserve_lease_break;\n};\n\nstatic inline void set_ctx_actor(struct dir_context *ctx,\n\t\t\t\t filldir_t actor)\n{\n\tctx->actor = actor;\n}\n\n#define KSMBD_NR_OPEN_DEFAULT BITS_PER_LONG\n\nstruct ksmbd_file_table {\n\trwlock_t\t\tlock;\n\tstruct idr\t\t*idr;\n};\n\nstatic inline bool has_file_id(u64 id)\n{\n\treturn id < KSMBD_NO_FID;\n}\n\nstatic inline bool ksmbd_stream_fd(struct ksmbd_file *fp)\n{\n\treturn fp->stream.name != NULL;\n}\n\nint ksmbd_init_file_table(struct ksmbd_file_table *ft);\nvoid ksmbd_destroy_file_table(struct ksmbd_file_table *ft);\nint ksmbd_close_fd(struct ksmbd_work *work, u64 id);\nstruct ksmbd_file *ksmbd_lookup_fd_fast(struct ksmbd_work *work, u64 id);\nstruct ksmbd_file *ksmbd_lookup_foreign_fd(struct ksmbd_work *work, u64 id);\nstruct ksmbd_file *ksmbd_lookup_fd_slow(struct ksmbd_work *work, u64 id,\n\t\t\t\t\tu64 pid);\nvoid ksmbd_fd_put(struct ksmbd_work *work, struct ksmbd_file *fp);\nstruct ksmbd_inode *ksmbd_inode_lookup_lock(struct dentry *d);\nvoid ksmbd_inode_put(struct ksmbd_inode *ci);\nstruct ksmbd_file *ksmbd_lookup_durable_fd(unsigned long long id);\nstruct ksmbd_file *ksmbd_lookup_fd_cguid(char *cguid);\nstruct ksmbd_file *ksmbd_lookup_fd_inode(struct dentry *dentry);\nunsigned int ksmbd_open_durable_fd(struct ksmbd_file *fp);\nstruct ksmbd_file *ksmbd_open_fd(struct ksmbd_work *work, struct file *filp);\nvoid ksmbd_close_tree_conn_fds(struct ksmbd_work *work);\nvoid ksmbd_close_session_fds(struct ksmbd_work *work);\nint ksmbd_close_inode_fds(struct ksmbd_work *work, struct inode *inode);\nint ksmbd_init_global_file_table(void);\nvoid ksmbd_free_global_file_table(void);\nvoid ksmbd_set_fd_limit(unsigned long limit);\nvoid ksmbd_update_fstate(struct ksmbd_file_table *ft, struct ksmbd_file *fp,\n\t\t\t unsigned int state);\n\n \nint __init ksmbd_inode_hash_init(void);\nvoid ksmbd_release_inode_hash(void);\n\nenum KSMBD_INODE_STATUS {\n\tKSMBD_INODE_STATUS_OK,\n\tKSMBD_INODE_STATUS_UNKNOWN,\n\tKSMBD_INODE_STATUS_PENDING_DELETE,\n};\n\nint ksmbd_query_inode_status(struct dentry *dentry);\nbool ksmbd_inode_pending_delete(struct ksmbd_file *fp);\nvoid ksmbd_set_inode_pending_delete(struct ksmbd_file *fp);\nvoid ksmbd_clear_inode_pending_delete(struct ksmbd_file *fp);\nvoid ksmbd_fd_set_delete_on_close(struct ksmbd_file *fp,\n\t\t\t\t  int file_info);\nint ksmbd_init_file_cache(void);\nvoid ksmbd_exit_file_cache(void);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}