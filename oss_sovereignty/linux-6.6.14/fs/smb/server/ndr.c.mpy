{
  "module_name": "ndr.c",
  "hash_id": "6c9bc8efbfb1dd5b7ff24c09b4646b351f1a7c99f789597c5878c2c49cc2e315",
  "original_prompt": "Ingested from linux-6.6.14/fs/smb/server/ndr.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n\n#include \"glob.h\"\n#include \"ndr.h\"\n\nstatic inline char *ndr_get_field(struct ndr *n)\n{\n\treturn n->data + n->offset;\n}\n\nstatic int try_to_realloc_ndr_blob(struct ndr *n, size_t sz)\n{\n\tchar *data;\n\n\tdata = krealloc(n->data, n->offset + sz + 1024, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tn->data = data;\n\tn->length += 1024;\n\tmemset(n->data + n->offset, 0, 1024);\n\treturn 0;\n}\n\nstatic int ndr_write_int16(struct ndr *n, __u16 value)\n{\n\tif (n->length <= n->offset + sizeof(value)) {\n\t\tint ret;\n\n\t\tret = try_to_realloc_ndr_blob(n, sizeof(value));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t*(__le16 *)ndr_get_field(n) = cpu_to_le16(value);\n\tn->offset += sizeof(value);\n\treturn 0;\n}\n\nstatic int ndr_write_int32(struct ndr *n, __u32 value)\n{\n\tif (n->length <= n->offset + sizeof(value)) {\n\t\tint ret;\n\n\t\tret = try_to_realloc_ndr_blob(n, sizeof(value));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t*(__le32 *)ndr_get_field(n) = cpu_to_le32(value);\n\tn->offset += sizeof(value);\n\treturn 0;\n}\n\nstatic int ndr_write_int64(struct ndr *n, __u64 value)\n{\n\tif (n->length <= n->offset + sizeof(value)) {\n\t\tint ret;\n\n\t\tret = try_to_realloc_ndr_blob(n, sizeof(value));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t*(__le64 *)ndr_get_field(n) = cpu_to_le64(value);\n\tn->offset += sizeof(value);\n\treturn 0;\n}\n\nstatic int ndr_write_bytes(struct ndr *n, void *value, size_t sz)\n{\n\tif (n->length <= n->offset + sz) {\n\t\tint ret;\n\n\t\tret = try_to_realloc_ndr_blob(n, sz);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tmemcpy(ndr_get_field(n), value, sz);\n\tn->offset += sz;\n\treturn 0;\n}\n\nstatic int ndr_write_string(struct ndr *n, char *value)\n{\n\tsize_t sz;\n\n\tsz = strlen(value) + 1;\n\tif (n->length <= n->offset + sz) {\n\t\tint ret;\n\n\t\tret = try_to_realloc_ndr_blob(n, sz);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tmemcpy(ndr_get_field(n), value, sz);\n\tn->offset += sz;\n\tn->offset = ALIGN(n->offset, 2);\n\treturn 0;\n}\n\nstatic int ndr_read_string(struct ndr *n, void *value, size_t sz)\n{\n\tint len;\n\n\tif (n->offset + sz > n->length)\n\t\treturn -EINVAL;\n\n\tlen = strnlen(ndr_get_field(n), sz);\n\tif (value)\n\t\tmemcpy(value, ndr_get_field(n), len);\n\tlen++;\n\tn->offset += len;\n\tn->offset = ALIGN(n->offset, 2);\n\treturn 0;\n}\n\nstatic int ndr_read_bytes(struct ndr *n, void *value, size_t sz)\n{\n\tif (n->offset + sz > n->length)\n\t\treturn -EINVAL;\n\n\tif (value)\n\t\tmemcpy(value, ndr_get_field(n), sz);\n\tn->offset += sz;\n\treturn 0;\n}\n\nstatic int ndr_read_int16(struct ndr *n, __u16 *value)\n{\n\tif (n->offset + sizeof(__u16) > n->length)\n\t\treturn -EINVAL;\n\n\tif (value)\n\t\t*value = le16_to_cpu(*(__le16 *)ndr_get_field(n));\n\tn->offset += sizeof(__u16);\n\treturn 0;\n}\n\nstatic int ndr_read_int32(struct ndr *n, __u32 *value)\n{\n\tif (n->offset + sizeof(__u32) > n->length)\n\t\treturn -EINVAL;\n\n\tif (value)\n\t\t*value = le32_to_cpu(*(__le32 *)ndr_get_field(n));\n\tn->offset += sizeof(__u32);\n\treturn 0;\n}\n\nstatic int ndr_read_int64(struct ndr *n, __u64 *value)\n{\n\tif (n->offset + sizeof(__u64) > n->length)\n\t\treturn -EINVAL;\n\n\tif (value)\n\t\t*value = le64_to_cpu(*(__le64 *)ndr_get_field(n));\n\tn->offset += sizeof(__u64);\n\treturn 0;\n}\n\nint ndr_encode_dos_attr(struct ndr *n, struct xattr_dos_attrib *da)\n{\n\tchar hex_attr[12] = {0};\n\tint ret;\n\n\tn->offset = 0;\n\tn->length = 1024;\n\tn->data = kzalloc(n->length, GFP_KERNEL);\n\tif (!n->data)\n\t\treturn -ENOMEM;\n\n\tif (da->version == 3) {\n\t\tsnprintf(hex_attr, 10, \"0x%x\", da->attr);\n\t\tret = ndr_write_string(n, hex_attr);\n\t} else {\n\t\tret = ndr_write_string(n, \"\");\n\t}\n\tif (ret)\n\t\treturn ret;\n\n\tret = ndr_write_int16(n, da->version);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ndr_write_int32(n, da->version);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ndr_write_int32(n, da->flags);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ndr_write_int32(n, da->attr);\n\tif (ret)\n\t\treturn ret;\n\n\tif (da->version == 3) {\n\t\tret = ndr_write_int32(n, da->ea_size);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = ndr_write_int64(n, da->size);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = ndr_write_int64(n, da->alloc_size);\n\t} else {\n\t\tret = ndr_write_int64(n, da->itime);\n\t}\n\tif (ret)\n\t\treturn ret;\n\n\tret = ndr_write_int64(n, da->create_time);\n\tif (ret)\n\t\treturn ret;\n\n\tif (da->version == 3)\n\t\tret = ndr_write_int64(n, da->change_time);\n\treturn ret;\n}\n\nint ndr_decode_dos_attr(struct ndr *n, struct xattr_dos_attrib *da)\n{\n\tchar hex_attr[12];\n\tunsigned int version2;\n\tint ret;\n\n\tn->offset = 0;\n\tret = ndr_read_string(n, hex_attr, sizeof(hex_attr));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ndr_read_int16(n, &da->version);\n\tif (ret)\n\t\treturn ret;\n\n\tif (da->version != 3 && da->version != 4) {\n\t\tksmbd_debug(VFS, \"v%d version is not supported\\n\", da->version);\n\t\treturn -EINVAL;\n\t}\n\n\tret = ndr_read_int32(n, &version2);\n\tif (ret)\n\t\treturn ret;\n\n\tif (da->version != version2) {\n\t\tksmbd_debug(VFS, \"ndr version mismatched(version: %d, version2: %d)\\n\",\n\t\t       da->version, version2);\n\t\treturn -EINVAL;\n\t}\n\n\tret = ndr_read_int32(n, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ndr_read_int32(n, &da->attr);\n\tif (ret)\n\t\treturn ret;\n\n\tif (da->version == 4) {\n\t\tret = ndr_read_int64(n, &da->itime);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = ndr_read_int64(n, &da->create_time);\n\t} else {\n\t\tret = ndr_read_int32(n, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = ndr_read_int64(n, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = ndr_read_int64(n, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = ndr_read_int64(n, &da->create_time);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = ndr_read_int64(n, NULL);\n\t}\n\n\treturn ret;\n}\n\nstatic int ndr_encode_posix_acl_entry(struct ndr *n, struct xattr_smb_acl *acl)\n{\n\tint i, ret;\n\n\tret = ndr_write_int32(n, acl->count);\n\tif (ret)\n\t\treturn ret;\n\n\tn->offset = ALIGN(n->offset, 8);\n\tret = ndr_write_int32(n, acl->count);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ndr_write_int32(n, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < acl->count; i++) {\n\t\tn->offset = ALIGN(n->offset, 8);\n\t\tret = ndr_write_int16(n, acl->entries[i].type);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = ndr_write_int16(n, acl->entries[i].type);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (acl->entries[i].type == SMB_ACL_USER) {\n\t\t\tn->offset = ALIGN(n->offset, 8);\n\t\t\tret = ndr_write_int64(n, acl->entries[i].uid);\n\t\t} else if (acl->entries[i].type == SMB_ACL_GROUP) {\n\t\t\tn->offset = ALIGN(n->offset, 8);\n\t\t\tret = ndr_write_int64(n, acl->entries[i].gid);\n\t\t}\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = ndr_write_int32(n, acl->entries[i].perm);\n\t}\n\n\treturn ret;\n}\n\nint ndr_encode_posix_acl(struct ndr *n,\n\t\t\t struct mnt_idmap *idmap,\n\t\t\t struct inode *inode,\n\t\t\t struct xattr_smb_acl *acl,\n\t\t\t struct xattr_smb_acl *def_acl)\n{\n\tunsigned int ref_id = 0x00020000;\n\tint ret;\n\tvfsuid_t vfsuid;\n\tvfsgid_t vfsgid;\n\n\tn->offset = 0;\n\tn->length = 1024;\n\tn->data = kzalloc(n->length, GFP_KERNEL);\n\tif (!n->data)\n\t\treturn -ENOMEM;\n\n\tif (acl) {\n\t\t \n\t\tret = ndr_write_int32(n, ref_id);\n\t\tref_id += 4;\n\t} else {\n\t\tret = ndr_write_int32(n, 0);\n\t}\n\tif (ret)\n\t\treturn ret;\n\n\tif (def_acl) {\n\t\t \n\t\tret = ndr_write_int32(n, ref_id);\n\t\tref_id += 4;\n\t} else {\n\t\tret = ndr_write_int32(n, 0);\n\t}\n\tif (ret)\n\t\treturn ret;\n\n\tvfsuid = i_uid_into_vfsuid(idmap, inode);\n\tret = ndr_write_int64(n, from_kuid(&init_user_ns, vfsuid_into_kuid(vfsuid)));\n\tif (ret)\n\t\treturn ret;\n\tvfsgid = i_gid_into_vfsgid(idmap, inode);\n\tret = ndr_write_int64(n, from_kgid(&init_user_ns, vfsgid_into_kgid(vfsgid)));\n\tif (ret)\n\t\treturn ret;\n\tret = ndr_write_int32(n, inode->i_mode);\n\tif (ret)\n\t\treturn ret;\n\n\tif (acl) {\n\t\tret = ndr_encode_posix_acl_entry(n, acl);\n\t\tif (def_acl && !ret)\n\t\t\tret = ndr_encode_posix_acl_entry(n, def_acl);\n\t}\n\treturn ret;\n}\n\nint ndr_encode_v4_ntacl(struct ndr *n, struct xattr_ntacl *acl)\n{\n\tunsigned int ref_id = 0x00020004;\n\tint ret;\n\n\tn->offset = 0;\n\tn->length = 2048;\n\tn->data = kzalloc(n->length, GFP_KERNEL);\n\tif (!n->data)\n\t\treturn -ENOMEM;\n\n\tret = ndr_write_int16(n, acl->version);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ndr_write_int32(n, acl->version);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ndr_write_int16(n, 2);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ndr_write_int32(n, ref_id);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = ndr_write_int16(n, acl->hash_type);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ndr_write_bytes(n, acl->hash, XATTR_SD_HASH_SIZE);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ndr_write_bytes(n, acl->desc, acl->desc_len);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ndr_write_int64(n, acl->current_time);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ndr_write_bytes(n, acl->posix_acl_hash, XATTR_SD_HASH_SIZE);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = ndr_write_bytes(n, acl->sd_buf, acl->sd_size);\n\treturn ret;\n}\n\nint ndr_decode_v4_ntacl(struct ndr *n, struct xattr_ntacl *acl)\n{\n\tunsigned int version2;\n\tint ret;\n\n\tn->offset = 0;\n\tret = ndr_read_int16(n, &acl->version);\n\tif (ret)\n\t\treturn ret;\n\tif (acl->version != 4) {\n\t\tksmbd_debug(VFS, \"v%d version is not supported\\n\", acl->version);\n\t\treturn -EINVAL;\n\t}\n\n\tret = ndr_read_int32(n, &version2);\n\tif (ret)\n\t\treturn ret;\n\tif (acl->version != version2) {\n\t\tksmbd_debug(VFS, \"ndr version mismatched(version: %d, version2: %d)\\n\",\n\t\t       acl->version, version2);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = ndr_read_int16(n, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = ndr_read_int32(n, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ndr_read_int16(n, &acl->hash_type);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ndr_read_bytes(n, acl->hash, XATTR_SD_HASH_SIZE);\n\tif (ret)\n\t\treturn ret;\n\n\tndr_read_bytes(n, acl->desc, 10);\n\tif (strncmp(acl->desc, \"posix_acl\", 9)) {\n\t\tpr_err(\"Invalid acl description : %s\\n\", acl->desc);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = ndr_read_int64(n, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = ndr_read_bytes(n, acl->posix_acl_hash, XATTR_SD_HASH_SIZE);\n\tif (ret)\n\t\treturn ret;\n\n\tacl->sd_size = n->length - n->offset;\n\tacl->sd_buf = kzalloc(acl->sd_size, GFP_KERNEL);\n\tif (!acl->sd_buf)\n\t\treturn -ENOMEM;\n\n\tret = ndr_read_bytes(n, acl->sd_buf, acl->sd_size);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}