{
  "module_name": "connection.c",
  "hash_id": "526dd9bf49f9266858d20ee371cb1e294947318b6e58f31fe4b1ab6889dc6e29",
  "original_prompt": "Ingested from linux-6.6.14/fs/smb/server/connection.c",
  "human_readable_source": "\n \n\n#include <linux/mutex.h>\n#include <linux/freezer.h>\n#include <linux/module.h>\n\n#include \"server.h\"\n#include \"smb_common.h\"\n#include \"mgmt/ksmbd_ida.h\"\n#include \"connection.h\"\n#include \"transport_tcp.h\"\n#include \"transport_rdma.h\"\n\nstatic DEFINE_MUTEX(init_lock);\n\nstatic struct ksmbd_conn_ops default_conn_ops;\n\nLIST_HEAD(conn_list);\nDECLARE_RWSEM(conn_list_lock);\n\n \nvoid ksmbd_conn_free(struct ksmbd_conn *conn)\n{\n\tdown_write(&conn_list_lock);\n\tlist_del(&conn->conns_list);\n\tup_write(&conn_list_lock);\n\n\txa_destroy(&conn->sessions);\n\tkvfree(conn->request_buf);\n\tkfree(conn->preauth_info);\n\tkfree(conn);\n}\n\n \nstruct ksmbd_conn *ksmbd_conn_alloc(void)\n{\n\tstruct ksmbd_conn *conn;\n\n\tconn = kzalloc(sizeof(struct ksmbd_conn), GFP_KERNEL);\n\tif (!conn)\n\t\treturn NULL;\n\n\tconn->need_neg = true;\n\tksmbd_conn_set_new(conn);\n\tconn->local_nls = load_nls(\"utf8\");\n\tif (!conn->local_nls)\n\t\tconn->local_nls = load_nls_default();\n\tif (IS_ENABLED(CONFIG_UNICODE))\n\t\tconn->um = utf8_load(UNICODE_AGE(12, 1, 0));\n\telse\n\t\tconn->um = ERR_PTR(-EOPNOTSUPP);\n\tif (IS_ERR(conn->um))\n\t\tconn->um = NULL;\n\tatomic_set(&conn->req_running, 0);\n\tatomic_set(&conn->r_count, 0);\n\tconn->total_credits = 1;\n\tconn->outstanding_credits = 0;\n\n\tinit_waitqueue_head(&conn->req_running_q);\n\tinit_waitqueue_head(&conn->r_count_q);\n\tINIT_LIST_HEAD(&conn->conns_list);\n\tINIT_LIST_HEAD(&conn->requests);\n\tINIT_LIST_HEAD(&conn->async_requests);\n\tspin_lock_init(&conn->request_lock);\n\tspin_lock_init(&conn->credits_lock);\n\tida_init(&conn->async_ida);\n\txa_init(&conn->sessions);\n\n\tspin_lock_init(&conn->llist_lock);\n\tINIT_LIST_HEAD(&conn->lock_list);\n\n\tinit_rwsem(&conn->session_lock);\n\n\tdown_write(&conn_list_lock);\n\tlist_add(&conn->conns_list, &conn_list);\n\tup_write(&conn_list_lock);\n\treturn conn;\n}\n\nbool ksmbd_conn_lookup_dialect(struct ksmbd_conn *c)\n{\n\tstruct ksmbd_conn *t;\n\tbool ret = false;\n\n\tdown_read(&conn_list_lock);\n\tlist_for_each_entry(t, &conn_list, conns_list) {\n\t\tif (memcmp(t->ClientGUID, c->ClientGUID, SMB2_CLIENT_GUID_SIZE))\n\t\t\tcontinue;\n\n\t\tret = true;\n\t\tbreak;\n\t}\n\tup_read(&conn_list_lock);\n\treturn ret;\n}\n\nvoid ksmbd_conn_enqueue_request(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct list_head *requests_queue = NULL;\n\n\tif (conn->ops->get_cmd_val(work) != SMB2_CANCEL_HE)\n\t\trequests_queue = &conn->requests;\n\n\tif (requests_queue) {\n\t\tatomic_inc(&conn->req_running);\n\t\tspin_lock(&conn->request_lock);\n\t\tlist_add_tail(&work->request_entry, requests_queue);\n\t\tspin_unlock(&conn->request_lock);\n\t}\n}\n\nvoid ksmbd_conn_try_dequeue_request(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\n\tif (list_empty(&work->request_entry) &&\n\t    list_empty(&work->async_request_entry))\n\t\treturn;\n\n\tatomic_dec(&conn->req_running);\n\tspin_lock(&conn->request_lock);\n\tlist_del_init(&work->request_entry);\n\tspin_unlock(&conn->request_lock);\n\tif (work->asynchronous)\n\t\trelease_async_work(work);\n\n\twake_up_all(&conn->req_running_q);\n}\n\nvoid ksmbd_conn_lock(struct ksmbd_conn *conn)\n{\n\tmutex_lock(&conn->srv_mutex);\n}\n\nvoid ksmbd_conn_unlock(struct ksmbd_conn *conn)\n{\n\tmutex_unlock(&conn->srv_mutex);\n}\n\nvoid ksmbd_all_conn_set_status(u64 sess_id, u32 status)\n{\n\tstruct ksmbd_conn *conn;\n\n\tdown_read(&conn_list_lock);\n\tlist_for_each_entry(conn, &conn_list, conns_list) {\n\t\tif (conn->binding || xa_load(&conn->sessions, sess_id))\n\t\t\tWRITE_ONCE(conn->status, status);\n\t}\n\tup_read(&conn_list_lock);\n}\n\nvoid ksmbd_conn_wait_idle(struct ksmbd_conn *conn, u64 sess_id)\n{\n\twait_event(conn->req_running_q, atomic_read(&conn->req_running) < 2);\n}\n\nint ksmbd_conn_write(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tint sent;\n\n\tif (!work->response_buf) {\n\t\tpr_err(\"NULL response header\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (work->send_no_response)\n\t\treturn 0;\n\n\tif (!work->iov_idx)\n\t\treturn -EINVAL;\n\n\tksmbd_conn_lock(conn);\n\tsent = conn->transport->ops->writev(conn->transport, work->iov,\n\t\t\twork->iov_cnt,\n\t\t\tget_rfc1002_len(work->iov[0].iov_base) + 4,\n\t\t\twork->need_invalidate_rkey,\n\t\t\twork->remote_key);\n\tksmbd_conn_unlock(conn);\n\n\tif (sent < 0) {\n\t\tpr_err(\"Failed to send message: %d\\n\", sent);\n\t\treturn sent;\n\t}\n\n\treturn 0;\n}\n\nint ksmbd_conn_rdma_read(struct ksmbd_conn *conn,\n\t\t\t void *buf, unsigned int buflen,\n\t\t\t struct smb2_buffer_desc_v1 *desc,\n\t\t\t unsigned int desc_len)\n{\n\tint ret = -EINVAL;\n\n\tif (conn->transport->ops->rdma_read)\n\t\tret = conn->transport->ops->rdma_read(conn->transport,\n\t\t\t\t\t\t      buf, buflen,\n\t\t\t\t\t\t      desc, desc_len);\n\treturn ret;\n}\n\nint ksmbd_conn_rdma_write(struct ksmbd_conn *conn,\n\t\t\t  void *buf, unsigned int buflen,\n\t\t\t  struct smb2_buffer_desc_v1 *desc,\n\t\t\t  unsigned int desc_len)\n{\n\tint ret = -EINVAL;\n\n\tif (conn->transport->ops->rdma_write)\n\t\tret = conn->transport->ops->rdma_write(conn->transport,\n\t\t\t\t\t\t       buf, buflen,\n\t\t\t\t\t\t       desc, desc_len);\n\treturn ret;\n}\n\nbool ksmbd_conn_alive(struct ksmbd_conn *conn)\n{\n\tif (!ksmbd_server_running())\n\t\treturn false;\n\n\tif (ksmbd_conn_exiting(conn))\n\t\treturn false;\n\n\tif (kthread_should_stop())\n\t\treturn false;\n\n\tif (atomic_read(&conn->stats.open_files_count) > 0)\n\t\treturn true;\n\n\t \n\tif (server_conf.deadtime > 0 &&\n\t    time_after(jiffies, conn->last_active + server_conf.deadtime)) {\n\t\tksmbd_debug(CONN, \"No response from client in %lu minutes\\n\",\n\t\t\t    server_conf.deadtime / SMB_ECHO_INTERVAL);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n#define SMB1_MIN_SUPPORTED_HEADER_SIZE (sizeof(struct smb_hdr))\n#define SMB2_MIN_SUPPORTED_HEADER_SIZE (sizeof(struct smb2_hdr) + 4)\n\n \nint ksmbd_conn_handler_loop(void *p)\n{\n\tstruct ksmbd_conn *conn = (struct ksmbd_conn *)p;\n\tstruct ksmbd_transport *t = conn->transport;\n\tunsigned int pdu_size, max_allowed_pdu_size;\n\tchar hdr_buf[4] = {0,};\n\tint size;\n\n\tmutex_init(&conn->srv_mutex);\n\t__module_get(THIS_MODULE);\n\n\tif (t->ops->prepare && t->ops->prepare(t))\n\t\tgoto out;\n\n\tconn->last_active = jiffies;\n\twhile (ksmbd_conn_alive(conn)) {\n\t\tif (try_to_freeze())\n\t\t\tcontinue;\n\n\t\tkvfree(conn->request_buf);\n\t\tconn->request_buf = NULL;\n\n\t\tsize = t->ops->read(t, hdr_buf, sizeof(hdr_buf), -1);\n\t\tif (size != sizeof(hdr_buf))\n\t\t\tbreak;\n\n\t\tpdu_size = get_rfc1002_len(hdr_buf);\n\t\tksmbd_debug(CONN, \"RFC1002 header %u bytes\\n\", pdu_size);\n\n\t\tif (ksmbd_conn_good(conn))\n\t\t\tmax_allowed_pdu_size =\n\t\t\t\tSMB3_MAX_MSGSIZE + conn->vals->max_write_size;\n\t\telse\n\t\t\tmax_allowed_pdu_size = SMB3_MAX_MSGSIZE;\n\n\t\tif (pdu_size > max_allowed_pdu_size) {\n\t\t\tpr_err_ratelimited(\"PDU length(%u) exceeded maximum allowed pdu size(%u) on connection(%d)\\n\",\n\t\t\t\t\tpdu_size, max_allowed_pdu_size,\n\t\t\t\t\tREAD_ONCE(conn->status));\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (pdu_size > MAX_STREAM_PROT_LEN)\n\t\t\tbreak;\n\n\t\tif (pdu_size < SMB1_MIN_SUPPORTED_HEADER_SIZE)\n\t\t\tbreak;\n\n\t\t \n\t\t \n\t\tsize = pdu_size + 4 + 1;\n\t\tconn->request_buf = kvmalloc(size, GFP_KERNEL);\n\t\tif (!conn->request_buf)\n\t\t\tbreak;\n\n\t\tmemcpy(conn->request_buf, hdr_buf, sizeof(hdr_buf));\n\n\t\t \n\t\tsize = t->ops->read(t, conn->request_buf + 4, pdu_size, 2);\n\t\tif (size < 0) {\n\t\t\tpr_err(\"sock_read failed: %d\\n\", size);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (size != pdu_size) {\n\t\t\tpr_err(\"PDU error. Read: %d, Expected: %d\\n\",\n\t\t\t       size, pdu_size);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!ksmbd_smb_request(conn))\n\t\t\tbreak;\n\n\t\tif (((struct smb2_hdr *)smb2_get_msg(conn->request_buf))->ProtocolId ==\n\t\t    SMB2_PROTO_NUMBER) {\n\t\t\tif (pdu_size < SMB2_MIN_SUPPORTED_HEADER_SIZE)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (!default_conn_ops.process_fn) {\n\t\t\tpr_err(\"No connection request callback\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (default_conn_ops.process_fn(conn)) {\n\t\t\tpr_err(\"Cannot handle request\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\tksmbd_conn_set_releasing(conn);\n\t \n\twait_event(conn->r_count_q, atomic_read(&conn->r_count) == 0);\n\n\tif (IS_ENABLED(CONFIG_UNICODE))\n\t\tutf8_unload(conn->um);\n\tunload_nls(conn->local_nls);\n\tif (default_conn_ops.terminate_fn)\n\t\tdefault_conn_ops.terminate_fn(conn);\n\tt->ops->disconnect(t);\n\tmodule_put(THIS_MODULE);\n\treturn 0;\n}\n\nvoid ksmbd_conn_init_server_callbacks(struct ksmbd_conn_ops *ops)\n{\n\tdefault_conn_ops.process_fn = ops->process_fn;\n\tdefault_conn_ops.terminate_fn = ops->terminate_fn;\n}\n\nint ksmbd_conn_transport_init(void)\n{\n\tint ret;\n\n\tmutex_lock(&init_lock);\n\tret = ksmbd_tcp_init();\n\tif (ret) {\n\t\tpr_err(\"Failed to init TCP subsystem: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = ksmbd_rdma_init();\n\tif (ret) {\n\t\tpr_err(\"Failed to init RDMA subsystem: %d\\n\", ret);\n\t\tgoto out;\n\t}\nout:\n\tmutex_unlock(&init_lock);\n\treturn ret;\n}\n\nstatic void stop_sessions(void)\n{\n\tstruct ksmbd_conn *conn;\n\tstruct ksmbd_transport *t;\n\nagain:\n\tdown_read(&conn_list_lock);\n\tlist_for_each_entry(conn, &conn_list, conns_list) {\n\t\tt = conn->transport;\n\t\tksmbd_conn_set_exiting(conn);\n\t\tif (t->ops->shutdown) {\n\t\t\tup_read(&conn_list_lock);\n\t\t\tt->ops->shutdown(t);\n\t\t\tdown_read(&conn_list_lock);\n\t\t}\n\t}\n\tup_read(&conn_list_lock);\n\n\tif (!list_empty(&conn_list)) {\n\t\tschedule_timeout_interruptible(HZ / 10);  \n\t\tgoto again;\n\t}\n}\n\nvoid ksmbd_conn_transport_destroy(void)\n{\n\tmutex_lock(&init_lock);\n\tksmbd_tcp_destroy();\n\tksmbd_rdma_destroy();\n\tstop_sessions();\n\tmutex_unlock(&init_lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}