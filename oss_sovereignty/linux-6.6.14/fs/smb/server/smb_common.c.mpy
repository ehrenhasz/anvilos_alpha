{
  "module_name": "smb_common.c",
  "hash_id": "e43db0fc3cb8b6465ab7049cbbd25b4e21649b330e876a28e2848cb68f7ba968",
  "original_prompt": "Ingested from linux-6.6.14/fs/smb/server/smb_common.c",
  "human_readable_source": "\n \n\n#include <linux/user_namespace.h>\n\n#include \"smb_common.h\"\n#include \"server.h\"\n#include \"misc.h\"\n#include \"smbstatus.h\"\n#include \"connection.h\"\n#include \"ksmbd_work.h\"\n#include \"mgmt/user_session.h\"\n#include \"mgmt/user_config.h\"\n#include \"mgmt/tree_connect.h\"\n#include \"mgmt/share_config.h\"\n\n \nstatic const char basechars[43] = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_-!@#$%\";\n#define MANGLE_BASE (sizeof(basechars) / sizeof(char) - 1)\n#define MAGIC_CHAR '~'\n#define PERIOD '.'\n#define mangle(V) ((char)(basechars[(V) % MANGLE_BASE]))\n\nstruct smb_protocol {\n\tint\t\tindex;\n\tchar\t\t*name;\n\tchar\t\t*prot;\n\t__u16\t\tprot_id;\n};\n\nstatic struct smb_protocol smb1_protos[] = {\n\t{\n\t\tSMB21_PROT,\n\t\t\"\\2SMB 2.1\",\n\t\t\"SMB2_10\",\n\t\tSMB21_PROT_ID\n\t},\n\t{\n\t\tSMB2X_PROT,\n\t\t\"\\2SMB 2.???\",\n\t\t\"SMB2_22\",\n\t\tSMB2X_PROT_ID\n\t},\n};\n\nstatic struct smb_protocol smb2_protos[] = {\n\t{\n\t\tSMB21_PROT,\n\t\t\"\\2SMB 2.1\",\n\t\t\"SMB2_10\",\n\t\tSMB21_PROT_ID\n\t},\n\t{\n\t\tSMB30_PROT,\n\t\t\"\\2SMB 3.0\",\n\t\t\"SMB3_00\",\n\t\tSMB30_PROT_ID\n\t},\n\t{\n\t\tSMB302_PROT,\n\t\t\"\\2SMB 3.02\",\n\t\t\"SMB3_02\",\n\t\tSMB302_PROT_ID\n\t},\n\t{\n\t\tSMB311_PROT,\n\t\t\"\\2SMB 3.1.1\",\n\t\t\"SMB3_11\",\n\t\tSMB311_PROT_ID\n\t},\n};\n\nunsigned int ksmbd_server_side_copy_max_chunk_count(void)\n{\n\treturn 256;\n}\n\nunsigned int ksmbd_server_side_copy_max_chunk_size(void)\n{\n\treturn (2U << 30) - 1;\n}\n\nunsigned int ksmbd_server_side_copy_max_total_size(void)\n{\n\treturn (2U << 30) - 1;\n}\n\ninline int ksmbd_min_protocol(void)\n{\n\treturn SMB21_PROT;\n}\n\ninline int ksmbd_max_protocol(void)\n{\n\treturn SMB311_PROT;\n}\n\nint ksmbd_lookup_protocol_idx(char *str)\n{\n\tint offt = ARRAY_SIZE(smb1_protos) - 1;\n\tint len = strlen(str);\n\n\twhile (offt >= 0) {\n\t\tif (!strncmp(str, smb1_protos[offt].prot, len)) {\n\t\t\tksmbd_debug(SMB, \"selected %s dialect idx = %d\\n\",\n\t\t\t\t    smb1_protos[offt].prot, offt);\n\t\t\treturn smb1_protos[offt].index;\n\t\t}\n\t\tofft--;\n\t}\n\n\tofft = ARRAY_SIZE(smb2_protos) - 1;\n\twhile (offt >= 0) {\n\t\tif (!strncmp(str, smb2_protos[offt].prot, len)) {\n\t\t\tksmbd_debug(SMB, \"selected %s dialect idx = %d\\n\",\n\t\t\t\t    smb2_protos[offt].prot, offt);\n\t\t\treturn smb2_protos[offt].index;\n\t\t}\n\t\tofft--;\n\t}\n\treturn -1;\n}\n\n \nint ksmbd_verify_smb_message(struct ksmbd_work *work)\n{\n\tstruct smb2_hdr *smb2_hdr = ksmbd_req_buf_next(work);\n\tstruct smb_hdr *hdr;\n\n\tif (smb2_hdr->ProtocolId == SMB2_PROTO_NUMBER)\n\t\treturn ksmbd_smb2_check_message(work);\n\n\thdr = work->request_buf;\n\tif (*(__le32 *)hdr->Protocol == SMB1_PROTO_NUMBER &&\n\t    hdr->Command == SMB_COM_NEGOTIATE) {\n\t\twork->conn->outstanding_credits++;\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\n \nbool ksmbd_smb_request(struct ksmbd_conn *conn)\n{\n\t__le32 *proto;\n\n\tif (conn->request_buf[0] != 0)\n\t\treturn false;\n\n\tproto = (__le32 *)smb2_get_msg(conn->request_buf);\n\tif (*proto == SMB2_COMPRESSION_TRANSFORM_ID) {\n\t\tpr_err_ratelimited(\"smb2 compression not support yet\");\n\t\treturn false;\n\t}\n\n\tif (*proto != SMB1_PROTO_NUMBER &&\n\t    *proto != SMB2_PROTO_NUMBER &&\n\t    *proto != SMB2_TRANSFORM_PROTO_NUM)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool supported_protocol(int idx)\n{\n\tif (idx == SMB2X_PROT &&\n\t    (server_conf.min_protocol >= SMB21_PROT ||\n\t     server_conf.max_protocol <= SMB311_PROT))\n\t\treturn true;\n\n\treturn (server_conf.min_protocol <= idx &&\n\t\tidx <= server_conf.max_protocol);\n}\n\nstatic char *next_dialect(char *dialect, int *next_off, int bcount)\n{\n\tdialect = dialect + *next_off;\n\t*next_off = strnlen(dialect, bcount);\n\tif (dialect[*next_off] != '\\0')\n\t\treturn NULL;\n\treturn dialect;\n}\n\nstatic int ksmbd_lookup_dialect_by_name(char *cli_dialects, __le16 byte_count)\n{\n\tint i, seq_num, bcount, next;\n\tchar *dialect;\n\n\tfor (i = ARRAY_SIZE(smb1_protos) - 1; i >= 0; i--) {\n\t\tseq_num = 0;\n\t\tnext = 0;\n\t\tdialect = cli_dialects;\n\t\tbcount = le16_to_cpu(byte_count);\n\t\tdo {\n\t\t\tdialect = next_dialect(dialect, &next, bcount);\n\t\t\tif (!dialect)\n\t\t\t\tbreak;\n\t\t\tksmbd_debug(SMB, \"client requested dialect %s\\n\",\n\t\t\t\t    dialect);\n\t\t\tif (!strcmp(dialect, smb1_protos[i].name)) {\n\t\t\t\tif (supported_protocol(smb1_protos[i].index)) {\n\t\t\t\t\tksmbd_debug(SMB,\n\t\t\t\t\t\t    \"selected %s dialect\\n\",\n\t\t\t\t\t\t    smb1_protos[i].name);\n\t\t\t\t\tif (smb1_protos[i].index == SMB1_PROT)\n\t\t\t\t\t\treturn seq_num;\n\t\t\t\t\treturn smb1_protos[i].prot_id;\n\t\t\t\t}\n\t\t\t}\n\t\t\tseq_num++;\n\t\t\tbcount -= (++next);\n\t\t} while (bcount > 0);\n\t}\n\n\treturn BAD_PROT_ID;\n}\n\nint ksmbd_lookup_dialect_by_id(__le16 *cli_dialects, __le16 dialects_count)\n{\n\tint i;\n\tint count;\n\n\tfor (i = ARRAY_SIZE(smb2_protos) - 1; i >= 0; i--) {\n\t\tcount = le16_to_cpu(dialects_count);\n\t\twhile (--count >= 0) {\n\t\t\tksmbd_debug(SMB, \"client requested dialect 0x%x\\n\",\n\t\t\t\t    le16_to_cpu(cli_dialects[count]));\n\t\t\tif (le16_to_cpu(cli_dialects[count]) !=\n\t\t\t\t\tsmb2_protos[i].prot_id)\n\t\t\t\tcontinue;\n\n\t\t\tif (supported_protocol(smb2_protos[i].index)) {\n\t\t\t\tksmbd_debug(SMB, \"selected %s dialect\\n\",\n\t\t\t\t\t    smb2_protos[i].name);\n\t\t\t\treturn smb2_protos[i].prot_id;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn BAD_PROT_ID;\n}\n\nstatic int ksmbd_negotiate_smb_dialect(void *buf)\n{\n\tint smb_buf_length = get_rfc1002_len(buf);\n\t__le32 proto = ((struct smb2_hdr *)smb2_get_msg(buf))->ProtocolId;\n\n\tif (proto == SMB2_PROTO_NUMBER) {\n\t\tstruct smb2_negotiate_req *req;\n\t\tint smb2_neg_size =\n\t\t\toffsetof(struct smb2_negotiate_req, Dialects);\n\n\t\treq = (struct smb2_negotiate_req *)smb2_get_msg(buf);\n\t\tif (smb2_neg_size > smb_buf_length)\n\t\t\tgoto err_out;\n\n\t\tif (struct_size(req, Dialects, le16_to_cpu(req->DialectCount)) >\n\t\t    smb_buf_length)\n\t\t\tgoto err_out;\n\n\t\treturn ksmbd_lookup_dialect_by_id(req->Dialects,\n\t\t\t\t\t\t  req->DialectCount);\n\t}\n\n\tproto = *(__le32 *)((struct smb_hdr *)buf)->Protocol;\n\tif (proto == SMB1_PROTO_NUMBER) {\n\t\tstruct smb_negotiate_req *req;\n\n\t\treq = (struct smb_negotiate_req *)buf;\n\t\tif (le16_to_cpu(req->ByteCount) < 2)\n\t\t\tgoto err_out;\n\n\t\tif (offsetof(struct smb_negotiate_req, DialectsArray) - 4 +\n\t\t\tle16_to_cpu(req->ByteCount) > smb_buf_length) {\n\t\t\tgoto err_out;\n\t\t}\n\n\t\treturn ksmbd_lookup_dialect_by_name(req->DialectsArray,\n\t\t\t\t\t\t    req->ByteCount);\n\t}\n\nerr_out:\n\treturn BAD_PROT_ID;\n}\n\n#define SMB_COM_NEGOTIATE_EX\t0x0\n\n \nstatic u16 get_smb1_cmd_val(struct ksmbd_work *work)\n{\n\treturn SMB_COM_NEGOTIATE_EX;\n}\n\n \nstatic int init_smb1_rsp_hdr(struct ksmbd_work *work)\n{\n\tstruct smb_hdr *rsp_hdr = (struct smb_hdr *)work->response_buf;\n\tstruct smb_hdr *rcv_hdr = (struct smb_hdr *)work->request_buf;\n\n\trsp_hdr->Command = SMB_COM_NEGOTIATE;\n\t*(__le32 *)rsp_hdr->Protocol = SMB1_PROTO_NUMBER;\n\trsp_hdr->Flags = SMBFLG_RESPONSE;\n\trsp_hdr->Flags2 = SMBFLG2_UNICODE | SMBFLG2_ERR_STATUS |\n\t\tSMBFLG2_EXT_SEC | SMBFLG2_IS_LONG_NAME;\n\trsp_hdr->Pid = rcv_hdr->Pid;\n\trsp_hdr->Mid = rcv_hdr->Mid;\n\treturn 0;\n}\n\n \nstatic int smb1_check_user_session(struct ksmbd_work *work)\n{\n\tunsigned int cmd = work->conn->ops->get_cmd_val(work);\n\n\tif (cmd == SMB_COM_NEGOTIATE_EX)\n\t\treturn 0;\n\n\treturn -EINVAL;\n}\n\n \nstatic int smb1_allocate_rsp_buf(struct ksmbd_work *work)\n{\n\twork->response_buf = kzalloc(MAX_CIFS_SMALL_BUFFER_SIZE,\n\t\t\tGFP_KERNEL);\n\twork->response_sz = MAX_CIFS_SMALL_BUFFER_SIZE;\n\n\tif (!work->response_buf) {\n\t\tpr_err(\"Failed to allocate %u bytes buffer\\n\",\n\t\t\t\tMAX_CIFS_SMALL_BUFFER_SIZE);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void set_smb1_rsp_status(struct ksmbd_work *work, __le32 err)\n{\n\twork->send_no_response = 1;\n}\n\nstatic struct smb_version_ops smb1_server_ops = {\n\t.get_cmd_val = get_smb1_cmd_val,\n\t.init_rsp_hdr = init_smb1_rsp_hdr,\n\t.allocate_rsp_buf = smb1_allocate_rsp_buf,\n\t.check_user_session = smb1_check_user_session,\n\t.set_rsp_status = set_smb1_rsp_status,\n};\n\nstatic int smb1_negotiate(struct ksmbd_work *work)\n{\n\treturn ksmbd_smb_negotiate_common(work, SMB_COM_NEGOTIATE);\n}\n\nstatic struct smb_version_cmds smb1_server_cmds[1] = {\n\t[SMB_COM_NEGOTIATE_EX]\t= { .proc = smb1_negotiate, },\n};\n\nstatic int init_smb1_server(struct ksmbd_conn *conn)\n{\n\tconn->ops = &smb1_server_ops;\n\tconn->cmds = smb1_server_cmds;\n\tconn->max_cmds = ARRAY_SIZE(smb1_server_cmds);\n\treturn 0;\n}\n\nint ksmbd_init_smb_server(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\t__le32 proto;\n\n\tproto = *(__le32 *)((struct smb_hdr *)work->request_buf)->Protocol;\n\tif (conn->need_neg == false) {\n\t\tif (proto == SMB1_PROTO_NUMBER)\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\t}\n\n\tif (proto == SMB1_PROTO_NUMBER)\n\t\treturn init_smb1_server(conn);\n\treturn init_smb3_11_server(conn);\n}\n\nint ksmbd_populate_dot_dotdot_entries(struct ksmbd_work *work, int info_level,\n\t\t\t\t      struct ksmbd_file *dir,\n\t\t\t\t      struct ksmbd_dir_info *d_info,\n\t\t\t\t      char *search_pattern,\n\t\t\t\t      int (*fn)(struct ksmbd_conn *, int,\n\t\t\t\t\t\tstruct ksmbd_dir_info *,\n\t\t\t\t\t\tstruct ksmbd_kstat *))\n{\n\tint i, rc = 0;\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct mnt_idmap *idmap = file_mnt_idmap(dir->filp);\n\n\tfor (i = 0; i < 2; i++) {\n\t\tstruct kstat kstat;\n\t\tstruct ksmbd_kstat ksmbd_kstat;\n\t\tstruct dentry *dentry;\n\n\t\tif (!dir->dot_dotdot[i]) {  \n\t\t\tif (i == 0) {\n\t\t\t\td_info->name = \".\";\n\t\t\t\td_info->name_len = 1;\n\t\t\t\tdentry = dir->filp->f_path.dentry;\n\t\t\t} else {\n\t\t\t\td_info->name = \"..\";\n\t\t\t\td_info->name_len = 2;\n\t\t\t\tdentry = dir->filp->f_path.dentry->d_parent;\n\t\t\t}\n\n\t\t\tif (!match_pattern(d_info->name, d_info->name_len,\n\t\t\t\t\t   search_pattern)) {\n\t\t\t\tdir->dot_dotdot[i] = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tksmbd_kstat.kstat = &kstat;\n\t\t\tksmbd_vfs_fill_dentry_attrs(work,\n\t\t\t\t\t\t    idmap,\n\t\t\t\t\t\t    dentry,\n\t\t\t\t\t\t    &ksmbd_kstat);\n\t\t\trc = fn(conn, info_level, d_info, &ksmbd_kstat);\n\t\t\tif (rc)\n\t\t\t\tbreak;\n\t\t\tif (d_info->out_buf_len <= 0)\n\t\t\t\tbreak;\n\n\t\t\tdir->dot_dotdot[i] = 1;\n\t\t\tif (d_info->flags & SMB2_RETURN_SINGLE_ENTRY) {\n\t\t\t\td_info->out_buf_len = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn rc;\n}\n\n \nint ksmbd_extract_shortname(struct ksmbd_conn *conn, const char *longname,\n\t\t\t    char *shortname)\n{\n\tconst char *p;\n\tchar base[9], extension[4];\n\tchar out[13] = {0};\n\tint baselen = 0;\n\tint extlen = 0, len = 0;\n\tunsigned int csum = 0;\n\tconst unsigned char *ptr;\n\tbool dot_present = true;\n\n\tp = longname;\n\tif ((*p == '.') || (!(strcmp(p, \"..\")))) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tp = strrchr(longname, '.');\n\tif (p == longname) {  \n\t\tstrscpy(extension, \"___\", strlen(\"___\"));\n\t} else {\n\t\tif (p) {\n\t\t\tp++;\n\t\t\twhile (*p && extlen < 3) {\n\t\t\t\tif (*p != '.')\n\t\t\t\t\textension[extlen++] = toupper(*p);\n\t\t\t\tp++;\n\t\t\t}\n\t\t\textension[extlen] = '\\0';\n\t\t} else {\n\t\t\tdot_present = false;\n\t\t}\n\t}\n\n\tp = longname;\n\tif (*p == '.') {\n\t\tp++;\n\t\tlongname++;\n\t}\n\twhile (*p && (baselen < 5)) {\n\t\tif (*p != '.')\n\t\t\tbase[baselen++] = toupper(*p);\n\t\tp++;\n\t}\n\n\tbase[baselen] = MAGIC_CHAR;\n\tmemcpy(out, base, baselen + 1);\n\n\tptr = longname;\n\tlen = strlen(longname);\n\tfor (; len > 0; len--, ptr++)\n\t\tcsum += *ptr;\n\n\tcsum = csum % (MANGLE_BASE * MANGLE_BASE);\n\tout[baselen + 1] = mangle(csum / MANGLE_BASE);\n\tout[baselen + 2] = mangle(csum);\n\tout[baselen + 3] = PERIOD;\n\n\tif (dot_present)\n\t\tmemcpy(out + baselen + 4, extension, 4);\n\telse\n\t\tout[baselen + 4] = '\\0';\n\tsmbConvertToUTF16((__le16 *)shortname, out, PATH_MAX,\n\t\t\t  conn->local_nls, 0);\n\tlen = strlen(out) * 2;\n\treturn len;\n}\n\nstatic int __smb2_negotiate(struct ksmbd_conn *conn)\n{\n\treturn (conn->dialect >= SMB20_PROT_ID &&\n\t\tconn->dialect <= SMB311_PROT_ID);\n}\n\nstatic int smb_handle_negotiate(struct ksmbd_work *work)\n{\n\tstruct smb_negotiate_rsp *neg_rsp = work->response_buf;\n\n\tksmbd_debug(SMB, \"Unsupported SMB1 protocol\\n\");\n\n\tif (ksmbd_iov_pin_rsp(work, (void *)neg_rsp,\n\t\t\t      sizeof(struct smb_negotiate_rsp) - 4))\n\t\treturn -ENOMEM;\n\n\tneg_rsp->hdr.Status.CifsError = STATUS_SUCCESS;\n\tneg_rsp->hdr.WordCount = 1;\n\tneg_rsp->DialectIndex = cpu_to_le16(work->conn->dialect);\n\tneg_rsp->ByteCount = 0;\n\treturn 0;\n}\n\nint ksmbd_smb_negotiate_common(struct ksmbd_work *work, unsigned int command)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tint ret;\n\n\tconn->dialect =\n\t\tksmbd_negotiate_smb_dialect(work->request_buf);\n\tksmbd_debug(SMB, \"conn->dialect 0x%x\\n\", conn->dialect);\n\n\tif (command == SMB2_NEGOTIATE_HE) {\n\t\tret = smb2_handle_negotiate(work);\n\t\treturn ret;\n\t}\n\n\tif (command == SMB_COM_NEGOTIATE) {\n\t\tif (__smb2_negotiate(conn)) {\n\t\t\tinit_smb3_11_server(conn);\n\t\t\tinit_smb2_neg_rsp(work);\n\t\t\tksmbd_debug(SMB, \"Upgrade to SMB2 negotiation\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\treturn smb_handle_negotiate(work);\n\t}\n\n\tpr_err(\"Unknown SMB negotiation command: %u\\n\", command);\n\treturn -EINVAL;\n}\n\nenum SHARED_MODE_ERRORS {\n\tSHARE_DELETE_ERROR,\n\tSHARE_READ_ERROR,\n\tSHARE_WRITE_ERROR,\n\tFILE_READ_ERROR,\n\tFILE_WRITE_ERROR,\n\tFILE_DELETE_ERROR,\n};\n\nstatic const char * const shared_mode_errors[] = {\n\t\"Current access mode does not permit SHARE_DELETE\",\n\t\"Current access mode does not permit SHARE_READ\",\n\t\"Current access mode does not permit SHARE_WRITE\",\n\t\"Desired access mode does not permit FILE_READ\",\n\t\"Desired access mode does not permit FILE_WRITE\",\n\t\"Desired access mode does not permit FILE_DELETE\",\n};\n\nstatic void smb_shared_mode_error(int error, struct ksmbd_file *prev_fp,\n\t\t\t\t  struct ksmbd_file *curr_fp)\n{\n\tksmbd_debug(SMB, \"%s\\n\", shared_mode_errors[error]);\n\tksmbd_debug(SMB, \"Current mode: 0x%x Desired mode: 0x%x\\n\",\n\t\t    prev_fp->saccess, curr_fp->daccess);\n}\n\nint ksmbd_smb_check_shared_mode(struct file *filp, struct ksmbd_file *curr_fp)\n{\n\tint rc = 0;\n\tstruct ksmbd_file *prev_fp;\n\n\t \n\tread_lock(&curr_fp->f_ci->m_lock);\n\tlist_for_each_entry(prev_fp, &curr_fp->f_ci->m_fp_list, node) {\n\t\tif (file_inode(filp) != file_inode(prev_fp->filp))\n\t\t\tcontinue;\n\n\t\tif (filp == prev_fp->filp)\n\t\t\tcontinue;\n\n\t\tif (ksmbd_stream_fd(prev_fp) && ksmbd_stream_fd(curr_fp))\n\t\t\tif (strcmp(prev_fp->stream.name, curr_fp->stream.name))\n\t\t\t\tcontinue;\n\n\t\tif (prev_fp->attrib_only != curr_fp->attrib_only)\n\t\t\tcontinue;\n\n\t\tif (!(prev_fp->saccess & FILE_SHARE_DELETE_LE) &&\n\t\t    curr_fp->daccess & FILE_DELETE_LE) {\n\t\t\tsmb_shared_mode_error(SHARE_DELETE_ERROR,\n\t\t\t\t\t      prev_fp,\n\t\t\t\t\t      curr_fp);\n\t\t\trc = -EPERM;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (ksmbd_stream_fd(prev_fp) && !ksmbd_stream_fd(curr_fp))\n\t\t\tcontinue;\n\n\t\tif (!(prev_fp->saccess & FILE_SHARE_READ_LE) &&\n\t\t    curr_fp->daccess & (FILE_EXECUTE_LE | FILE_READ_DATA_LE)) {\n\t\t\tsmb_shared_mode_error(SHARE_READ_ERROR,\n\t\t\t\t\t      prev_fp,\n\t\t\t\t\t      curr_fp);\n\t\t\trc = -EPERM;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!(prev_fp->saccess & FILE_SHARE_WRITE_LE) &&\n\t\t    curr_fp->daccess & (FILE_WRITE_DATA_LE | FILE_APPEND_DATA_LE)) {\n\t\t\tsmb_shared_mode_error(SHARE_WRITE_ERROR,\n\t\t\t\t\t      prev_fp,\n\t\t\t\t\t      curr_fp);\n\t\t\trc = -EPERM;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (prev_fp->daccess & (FILE_EXECUTE_LE | FILE_READ_DATA_LE) &&\n\t\t    !(curr_fp->saccess & FILE_SHARE_READ_LE)) {\n\t\t\tsmb_shared_mode_error(FILE_READ_ERROR,\n\t\t\t\t\t      prev_fp,\n\t\t\t\t\t      curr_fp);\n\t\t\trc = -EPERM;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (prev_fp->daccess & (FILE_WRITE_DATA_LE | FILE_APPEND_DATA_LE) &&\n\t\t    !(curr_fp->saccess & FILE_SHARE_WRITE_LE)) {\n\t\t\tsmb_shared_mode_error(FILE_WRITE_ERROR,\n\t\t\t\t\t      prev_fp,\n\t\t\t\t\t      curr_fp);\n\t\t\trc = -EPERM;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (prev_fp->daccess & FILE_DELETE_LE &&\n\t\t    !(curr_fp->saccess & FILE_SHARE_DELETE_LE)) {\n\t\t\tsmb_shared_mode_error(FILE_DELETE_ERROR,\n\t\t\t\t\t      prev_fp,\n\t\t\t\t\t      curr_fp);\n\t\t\trc = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t}\n\tread_unlock(&curr_fp->f_ci->m_lock);\n\n\treturn rc;\n}\n\nbool is_asterisk(char *p)\n{\n\treturn p && p[0] == '*';\n}\n\nint ksmbd_override_fsids(struct ksmbd_work *work)\n{\n\tstruct ksmbd_session *sess = work->sess;\n\tstruct ksmbd_share_config *share = work->tcon->share_conf;\n\tstruct cred *cred;\n\tstruct group_info *gi;\n\tunsigned int uid;\n\tunsigned int gid;\n\n\tuid = user_uid(sess->user);\n\tgid = user_gid(sess->user);\n\tif (share->force_uid != KSMBD_SHARE_INVALID_UID)\n\t\tuid = share->force_uid;\n\tif (share->force_gid != KSMBD_SHARE_INVALID_GID)\n\t\tgid = share->force_gid;\n\n\tcred = prepare_kernel_cred(&init_task);\n\tif (!cred)\n\t\treturn -ENOMEM;\n\n\tcred->fsuid = make_kuid(&init_user_ns, uid);\n\tcred->fsgid = make_kgid(&init_user_ns, gid);\n\n\tgi = groups_alloc(0);\n\tif (!gi) {\n\t\tabort_creds(cred);\n\t\treturn -ENOMEM;\n\t}\n\tset_groups(cred, gi);\n\tput_group_info(gi);\n\n\tif (!uid_eq(cred->fsuid, GLOBAL_ROOT_UID))\n\t\tcred->cap_effective = cap_drop_fs_set(cred->cap_effective);\n\n\tWARN_ON(work->saved_cred);\n\twork->saved_cred = override_creds(cred);\n\tif (!work->saved_cred) {\n\t\tabort_creds(cred);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nvoid ksmbd_revert_fsids(struct ksmbd_work *work)\n{\n\tconst struct cred *cred;\n\n\tWARN_ON(!work->saved_cred);\n\n\tcred = current_cred();\n\trevert_creds(work->saved_cred);\n\tput_cred(cred);\n\twork->saved_cred = NULL;\n}\n\n__le32 smb_map_generic_desired_access(__le32 daccess)\n{\n\tif (daccess & FILE_GENERIC_READ_LE) {\n\t\tdaccess |= cpu_to_le32(GENERIC_READ_FLAGS);\n\t\tdaccess &= ~FILE_GENERIC_READ_LE;\n\t}\n\n\tif (daccess & FILE_GENERIC_WRITE_LE) {\n\t\tdaccess |= cpu_to_le32(GENERIC_WRITE_FLAGS);\n\t\tdaccess &= ~FILE_GENERIC_WRITE_LE;\n\t}\n\n\tif (daccess & FILE_GENERIC_EXECUTE_LE) {\n\t\tdaccess |= cpu_to_le32(GENERIC_EXECUTE_FLAGS);\n\t\tdaccess &= ~FILE_GENERIC_EXECUTE_LE;\n\t}\n\n\tif (daccess & FILE_GENERIC_ALL_LE) {\n\t\tdaccess |= cpu_to_le32(GENERIC_ALL_FLAGS);\n\t\tdaccess &= ~FILE_GENERIC_ALL_LE;\n\t}\n\n\treturn daccess;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}