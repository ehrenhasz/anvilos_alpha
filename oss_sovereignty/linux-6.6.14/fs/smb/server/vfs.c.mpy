{
  "module_name": "vfs.c",
  "hash_id": "ff301651834a36c61b82f8c282d5ba3c14e1875287929fb10bb737e4f607eea5",
  "original_prompt": "Ingested from linux-6.6.14/fs/smb/server/vfs.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/filelock.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/xattr.h>\n#include <linux/falloc.h>\n#include <linux/fsnotify.h>\n#include <linux/dcache.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/xacct.h>\n#include <linux/crc32c.h>\n#include <linux/namei.h>\n\n#include \"glob.h\"\n#include \"oplock.h\"\n#include \"connection.h\"\n#include \"vfs.h\"\n#include \"vfs_cache.h\"\n#include \"smbacl.h\"\n#include \"ndr.h\"\n#include \"auth.h\"\n#include \"misc.h\"\n\n#include \"smb_common.h\"\n#include \"mgmt/share_config.h\"\n#include \"mgmt/tree_connect.h\"\n#include \"mgmt/user_session.h\"\n#include \"mgmt/user_config.h\"\n\nstatic void ksmbd_vfs_inherit_owner(struct ksmbd_work *work,\n\t\t\t\t    struct inode *parent_inode,\n\t\t\t\t    struct inode *inode)\n{\n\tif (!test_share_config_flag(work->tcon->share_conf,\n\t\t\t\t    KSMBD_SHARE_FLAG_INHERIT_OWNER))\n\t\treturn;\n\n\ti_uid_write(inode, i_uid_read(parent_inode));\n}\n\n \nint ksmbd_vfs_lock_parent(struct dentry *parent, struct dentry *child)\n{\n\tinode_lock_nested(d_inode(parent), I_MUTEX_PARENT);\n\tif (child->d_parent != parent) {\n\t\tinode_unlock(d_inode(parent));\n\t\treturn -ENOENT;\n\t}\n\n\treturn 0;\n}\n\nstatic int ksmbd_vfs_path_lookup_locked(struct ksmbd_share_config *share_conf,\n\t\t\t\t\tchar *pathname, unsigned int flags,\n\t\t\t\t\tstruct path *parent_path,\n\t\t\t\t\tstruct path *path)\n{\n\tstruct qstr last;\n\tstruct filename *filename;\n\tstruct path *root_share_path = &share_conf->vfs_path;\n\tint err, type;\n\tstruct dentry *d;\n\n\tif (pathname[0] == '\\0') {\n\t\tpathname = share_conf->path;\n\t\troot_share_path = NULL;\n\t} else {\n\t\tflags |= LOOKUP_BENEATH;\n\t}\n\n\tfilename = getname_kernel(pathname);\n\tif (IS_ERR(filename))\n\t\treturn PTR_ERR(filename);\n\n\terr = vfs_path_parent_lookup(filename, flags,\n\t\t\t\t     parent_path, &last, &type,\n\t\t\t\t     root_share_path);\n\tif (err) {\n\t\tputname(filename);\n\t\treturn err;\n\t}\n\n\tif (unlikely(type != LAST_NORM)) {\n\t\tpath_put(parent_path);\n\t\tputname(filename);\n\t\treturn -ENOENT;\n\t}\n\n\terr = mnt_want_write(parent_path->mnt);\n\tif (err) {\n\t\tpath_put(parent_path);\n\t\tputname(filename);\n\t\treturn -ENOENT;\n\t}\n\n\tinode_lock_nested(parent_path->dentry->d_inode, I_MUTEX_PARENT);\n\td = lookup_one_qstr_excl(&last, parent_path->dentry, 0);\n\tif (IS_ERR(d))\n\t\tgoto err_out;\n\n\tif (d_is_negative(d)) {\n\t\tdput(d);\n\t\tgoto err_out;\n\t}\n\n\tpath->dentry = d;\n\tpath->mnt = mntget(parent_path->mnt);\n\n\tif (test_share_config_flag(share_conf, KSMBD_SHARE_FLAG_CROSSMNT)) {\n\t\terr = follow_down(path, 0);\n\t\tif (err < 0) {\n\t\t\tpath_put(path);\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\tputname(filename);\n\treturn 0;\n\nerr_out:\n\tinode_unlock(d_inode(parent_path->dentry));\n\tmnt_drop_write(parent_path->mnt);\n\tpath_put(parent_path);\n\tputname(filename);\n\treturn -ENOENT;\n}\n\nvoid ksmbd_vfs_query_maximal_access(struct mnt_idmap *idmap,\n\t\t\t\t   struct dentry *dentry, __le32 *daccess)\n{\n\t*daccess = cpu_to_le32(FILE_READ_ATTRIBUTES | READ_CONTROL);\n\n\tif (!inode_permission(idmap, d_inode(dentry), MAY_OPEN | MAY_WRITE))\n\t\t*daccess |= cpu_to_le32(WRITE_DAC | WRITE_OWNER | SYNCHRONIZE |\n\t\t\t\tFILE_WRITE_DATA | FILE_APPEND_DATA |\n\t\t\t\tFILE_WRITE_EA | FILE_WRITE_ATTRIBUTES |\n\t\t\t\tFILE_DELETE_CHILD);\n\n\tif (!inode_permission(idmap, d_inode(dentry), MAY_OPEN | MAY_READ))\n\t\t*daccess |= FILE_READ_DATA_LE | FILE_READ_EA_LE;\n\n\tif (!inode_permission(idmap, d_inode(dentry), MAY_OPEN | MAY_EXEC))\n\t\t*daccess |= FILE_EXECUTE_LE;\n\n\tif (!inode_permission(idmap, d_inode(dentry->d_parent), MAY_EXEC | MAY_WRITE))\n\t\t*daccess |= FILE_DELETE_LE;\n}\n\n \nint ksmbd_vfs_create(struct ksmbd_work *work, const char *name, umode_t mode)\n{\n\tstruct path path;\n\tstruct dentry *dentry;\n\tint err;\n\n\tdentry = ksmbd_vfs_kern_path_create(work, name,\n\t\t\t\t\t    LOOKUP_NO_SYMLINKS, &path);\n\tif (IS_ERR(dentry)) {\n\t\terr = PTR_ERR(dentry);\n\t\tif (err != -ENOENT)\n\t\t\tpr_err(\"path create failed for %s, err %d\\n\",\n\t\t\t       name, err);\n\t\treturn err;\n\t}\n\n\tmode |= S_IFREG;\n\terr = vfs_create(mnt_idmap(path.mnt), d_inode(path.dentry),\n\t\t\t dentry, mode, true);\n\tif (!err) {\n\t\tksmbd_vfs_inherit_owner(work, d_inode(path.dentry),\n\t\t\t\t\td_inode(dentry));\n\t} else {\n\t\tpr_err(\"File(%s): creation failed (err:%d)\\n\", name, err);\n\t}\n\n\tdone_path_create(&path, dentry);\n\treturn err;\n}\n\n \nint ksmbd_vfs_mkdir(struct ksmbd_work *work, const char *name, umode_t mode)\n{\n\tstruct mnt_idmap *idmap;\n\tstruct path path;\n\tstruct dentry *dentry;\n\tint err;\n\n\tdentry = ksmbd_vfs_kern_path_create(work, name,\n\t\t\t\t\t    LOOKUP_NO_SYMLINKS | LOOKUP_DIRECTORY,\n\t\t\t\t\t    &path);\n\tif (IS_ERR(dentry)) {\n\t\terr = PTR_ERR(dentry);\n\t\tif (err != -EEXIST)\n\t\t\tksmbd_debug(VFS, \"path create failed for %s, err %d\\n\",\n\t\t\t\t    name, err);\n\t\treturn err;\n\t}\n\n\tidmap = mnt_idmap(path.mnt);\n\tmode |= S_IFDIR;\n\terr = vfs_mkdir(idmap, d_inode(path.dentry), dentry, mode);\n\tif (!err && d_unhashed(dentry)) {\n\t\tstruct dentry *d;\n\n\t\td = lookup_one(idmap, dentry->d_name.name, dentry->d_parent,\n\t\t\t       dentry->d_name.len);\n\t\tif (IS_ERR(d)) {\n\t\t\terr = PTR_ERR(d);\n\t\t\tgoto out_err;\n\t\t}\n\t\tif (unlikely(d_is_negative(d))) {\n\t\t\tdput(d);\n\t\t\terr = -ENOENT;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tksmbd_vfs_inherit_owner(work, d_inode(path.dentry), d_inode(d));\n\t\tdput(d);\n\t}\n\nout_err:\n\tdone_path_create(&path, dentry);\n\tif (err)\n\t\tpr_err(\"mkdir(%s): creation failed (err:%d)\\n\", name, err);\n\treturn err;\n}\n\nstatic ssize_t ksmbd_vfs_getcasexattr(struct mnt_idmap *idmap,\n\t\t\t\t      struct dentry *dentry, char *attr_name,\n\t\t\t\t      int attr_name_len, char **attr_value)\n{\n\tchar *name, *xattr_list = NULL;\n\tssize_t value_len = -ENOENT, xattr_list_len;\n\n\txattr_list_len = ksmbd_vfs_listxattr(dentry, &xattr_list);\n\tif (xattr_list_len <= 0)\n\t\tgoto out;\n\n\tfor (name = xattr_list; name - xattr_list < xattr_list_len;\n\t\t\tname += strlen(name) + 1) {\n\t\tksmbd_debug(VFS, \"%s, len %zd\\n\", name, strlen(name));\n\t\tif (strncasecmp(attr_name, name, attr_name_len))\n\t\t\tcontinue;\n\n\t\tvalue_len = ksmbd_vfs_getxattr(idmap,\n\t\t\t\t\t       dentry,\n\t\t\t\t\t       name,\n\t\t\t\t\t       attr_value);\n\t\tif (value_len < 0)\n\t\t\tpr_err(\"failed to get xattr in file\\n\");\n\t\tbreak;\n\t}\n\nout:\n\tkvfree(xattr_list);\n\treturn value_len;\n}\n\nstatic int ksmbd_vfs_stream_read(struct ksmbd_file *fp, char *buf, loff_t *pos,\n\t\t\t\t size_t count)\n{\n\tssize_t v_len;\n\tchar *stream_buf = NULL;\n\n\tksmbd_debug(VFS, \"read stream data pos : %llu, count : %zd\\n\",\n\t\t    *pos, count);\n\n\tv_len = ksmbd_vfs_getcasexattr(file_mnt_idmap(fp->filp),\n\t\t\t\t       fp->filp->f_path.dentry,\n\t\t\t\t       fp->stream.name,\n\t\t\t\t       fp->stream.size,\n\t\t\t\t       &stream_buf);\n\tif ((int)v_len <= 0)\n\t\treturn (int)v_len;\n\n\tif (v_len <= *pos) {\n\t\tcount = -EINVAL;\n\t\tgoto free_buf;\n\t}\n\n\tif (v_len - *pos < count)\n\t\tcount = v_len - *pos;\n\n\tmemcpy(buf, &stream_buf[*pos], count);\n\nfree_buf:\n\tkvfree(stream_buf);\n\treturn count;\n}\n\n \nstatic int check_lock_range(struct file *filp, loff_t start, loff_t end,\n\t\t\t    unsigned char type)\n{\n\tstruct file_lock *flock;\n\tstruct file_lock_context *ctx = locks_inode_context(file_inode(filp));\n\tint error = 0;\n\n\tif (!ctx || list_empty_careful(&ctx->flc_posix))\n\t\treturn 0;\n\n\tspin_lock(&ctx->flc_lock);\n\tlist_for_each_entry(flock, &ctx->flc_posix, fl_list) {\n\t\t \n\t\tif (flock->fl_end >= start && end >= flock->fl_start) {\n\t\t\tif (flock->fl_type == F_RDLCK) {\n\t\t\t\tif (type == WRITE) {\n\t\t\t\t\tpr_err(\"not allow write by shared lock\\n\");\n\t\t\t\t\terror = 1;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t} else if (flock->fl_type == F_WRLCK) {\n\t\t\t\t \n\t\t\t\tif (flock->fl_file != filp) {\n\t\t\t\t\terror = 1;\n\t\t\t\t\tpr_err(\"not allow rw access by exclusive lock from other opens\\n\");\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nout:\n\tspin_unlock(&ctx->flc_lock);\n\treturn error;\n}\n\n \nint ksmbd_vfs_read(struct ksmbd_work *work, struct ksmbd_file *fp, size_t count,\n\t\t   loff_t *pos, char *rbuf)\n{\n\tstruct file *filp = fp->filp;\n\tssize_t nbytes = 0;\n\tstruct inode *inode = file_inode(filp);\n\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn -EISDIR;\n\n\tif (unlikely(count == 0))\n\t\treturn 0;\n\n\tif (work->conn->connection_type) {\n\t\tif (!(fp->daccess & (FILE_READ_DATA_LE | FILE_EXECUTE_LE))) {\n\t\t\tpr_err(\"no right to read(%pD)\\n\", fp->filp);\n\t\t\treturn -EACCES;\n\t\t}\n\t}\n\n\tif (ksmbd_stream_fd(fp))\n\t\treturn ksmbd_vfs_stream_read(fp, rbuf, pos, count);\n\n\tif (!work->tcon->posix_extensions) {\n\t\tint ret;\n\n\t\tret = check_lock_range(filp, *pos, *pos + count - 1, READ);\n\t\tif (ret) {\n\t\t\tpr_err(\"unable to read due to lock\\n\");\n\t\t\treturn -EAGAIN;\n\t\t}\n\t}\n\n\tnbytes = kernel_read(filp, rbuf, count, pos);\n\tif (nbytes < 0) {\n\t\tpr_err(\"smb read failed, err = %zd\\n\", nbytes);\n\t\treturn nbytes;\n\t}\n\n\tfilp->f_pos = *pos;\n\treturn nbytes;\n}\n\nstatic int ksmbd_vfs_stream_write(struct ksmbd_file *fp, char *buf, loff_t *pos,\n\t\t\t\t  size_t count)\n{\n\tchar *stream_buf = NULL, *wbuf;\n\tstruct mnt_idmap *idmap = file_mnt_idmap(fp->filp);\n\tsize_t size;\n\tssize_t v_len;\n\tint err = 0;\n\n\tksmbd_debug(VFS, \"write stream data pos : %llu, count : %zd\\n\",\n\t\t    *pos, count);\n\n\tsize = *pos + count;\n\tif (size > XATTR_SIZE_MAX) {\n\t\tsize = XATTR_SIZE_MAX;\n\t\tcount = (*pos + count) - XATTR_SIZE_MAX;\n\t}\n\n\tv_len = ksmbd_vfs_getcasexattr(idmap,\n\t\t\t\t       fp->filp->f_path.dentry,\n\t\t\t\t       fp->stream.name,\n\t\t\t\t       fp->stream.size,\n\t\t\t\t       &stream_buf);\n\tif (v_len < 0) {\n\t\tpr_err(\"not found stream in xattr : %zd\\n\", v_len);\n\t\terr = v_len;\n\t\tgoto out;\n\t}\n\n\tif (v_len < size) {\n\t\twbuf = kvzalloc(size, GFP_KERNEL);\n\t\tif (!wbuf) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (v_len > 0)\n\t\t\tmemcpy(wbuf, stream_buf, v_len);\n\t\tkvfree(stream_buf);\n\t\tstream_buf = wbuf;\n\t}\n\n\tmemcpy(&stream_buf[*pos], buf, count);\n\n\terr = ksmbd_vfs_setxattr(idmap,\n\t\t\t\t &fp->filp->f_path,\n\t\t\t\t fp->stream.name,\n\t\t\t\t (void *)stream_buf,\n\t\t\t\t size,\n\t\t\t\t 0,\n\t\t\t\t true);\n\tif (err < 0)\n\t\tgoto out;\n\n\tfp->filp->f_pos = *pos;\n\terr = 0;\nout:\n\tkvfree(stream_buf);\n\treturn err;\n}\n\n \nint ksmbd_vfs_write(struct ksmbd_work *work, struct ksmbd_file *fp,\n\t\t    char *buf, size_t count, loff_t *pos, bool sync,\n\t\t    ssize_t *written)\n{\n\tstruct file *filp;\n\tloff_t\toffset = *pos;\n\tint err = 0;\n\n\tif (work->conn->connection_type) {\n\t\tif (!(fp->daccess & FILE_WRITE_DATA_LE)) {\n\t\t\tpr_err(\"no right to write(%pD)\\n\", fp->filp);\n\t\t\terr = -EACCES;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfilp = fp->filp;\n\n\tif (ksmbd_stream_fd(fp)) {\n\t\terr = ksmbd_vfs_stream_write(fp, buf, pos, count);\n\t\tif (!err)\n\t\t\t*written = count;\n\t\tgoto out;\n\t}\n\n\tif (!work->tcon->posix_extensions) {\n\t\terr = check_lock_range(filp, *pos, *pos + count - 1, WRITE);\n\t\tif (err) {\n\t\t\tpr_err(\"unable to write due to lock\\n\");\n\t\t\terr = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tfp->reserve_lease_break = true;\n\n\t \n\tsmb_break_all_levII_oplock(work, fp, 1);\n\n\terr = kernel_write(filp, buf, count, pos);\n\tif (err < 0) {\n\t\tksmbd_debug(VFS, \"smb write failed, err = %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\tfilp->f_pos = *pos;\n\t*written = err;\n\terr = 0;\n\tif (sync) {\n\t\terr = vfs_fsync_range(filp, offset, offset + *written, 0);\n\t\tif (err < 0)\n\t\t\tpr_err(\"fsync failed for filename = %pD, err = %d\\n\",\n\t\t\t       fp->filp, err);\n\t}\n\nout:\n\treturn err;\n}\n\n \nint ksmbd_vfs_getattr(const struct path *path, struct kstat *stat)\n{\n\tint err;\n\n\terr = vfs_getattr(path, stat, STATX_BTIME, AT_STATX_SYNC_AS_STAT);\n\tif (err)\n\t\tpr_err(\"getattr failed, err %d\\n\", err);\n\treturn err;\n}\n\n \nint ksmbd_vfs_fsync(struct ksmbd_work *work, u64 fid, u64 p_id)\n{\n\tstruct ksmbd_file *fp;\n\tint err;\n\n\tfp = ksmbd_lookup_fd_slow(work, fid, p_id);\n\tif (!fp) {\n\t\tpr_err(\"failed to get filp for fid %llu\\n\", fid);\n\t\treturn -ENOENT;\n\t}\n\terr = vfs_fsync(fp->filp, 0);\n\tif (err < 0)\n\t\tpr_err(\"smb fsync failed, err = %d\\n\", err);\n\tksmbd_fd_put(work, fp);\n\treturn err;\n}\n\n \nint ksmbd_vfs_remove_file(struct ksmbd_work *work, const struct path *path)\n{\n\tstruct mnt_idmap *idmap;\n\tstruct dentry *parent = path->dentry->d_parent;\n\tint err;\n\n\tif (ksmbd_override_fsids(work))\n\t\treturn -ENOMEM;\n\n\tif (!d_inode(path->dentry)->i_nlink) {\n\t\terr = -ENOENT;\n\t\tgoto out_err;\n\t}\n\n\tidmap = mnt_idmap(path->mnt);\n\tif (S_ISDIR(d_inode(path->dentry)->i_mode)) {\n\t\terr = vfs_rmdir(idmap, d_inode(parent), path->dentry);\n\t\tif (err && err != -ENOTEMPTY)\n\t\t\tksmbd_debug(VFS, \"rmdir failed, err %d\\n\", err);\n\t} else {\n\t\terr = vfs_unlink(idmap, d_inode(parent), path->dentry, NULL);\n\t\tif (err)\n\t\t\tksmbd_debug(VFS, \"unlink failed, err %d\\n\", err);\n\t}\n\nout_err:\n\tksmbd_revert_fsids(work);\n\treturn err;\n}\n\n \nint ksmbd_vfs_link(struct ksmbd_work *work, const char *oldname,\n\t\t   const char *newname)\n{\n\tstruct path oldpath, newpath;\n\tstruct dentry *dentry;\n\tint err;\n\n\tif (ksmbd_override_fsids(work))\n\t\treturn -ENOMEM;\n\n\terr = kern_path(oldname, LOOKUP_NO_SYMLINKS, &oldpath);\n\tif (err) {\n\t\tpr_err(\"cannot get linux path for %s, err = %d\\n\",\n\t\t       oldname, err);\n\t\tgoto out1;\n\t}\n\n\tdentry = ksmbd_vfs_kern_path_create(work, newname,\n\t\t\t\t\t    LOOKUP_NO_SYMLINKS | LOOKUP_REVAL,\n\t\t\t\t\t    &newpath);\n\tif (IS_ERR(dentry)) {\n\t\terr = PTR_ERR(dentry);\n\t\tpr_err(\"path create err for %s, err %d\\n\", newname, err);\n\t\tgoto out2;\n\t}\n\n\terr = -EXDEV;\n\tif (oldpath.mnt != newpath.mnt) {\n\t\tpr_err(\"vfs_link failed err %d\\n\", err);\n\t\tgoto out3;\n\t}\n\n\terr = vfs_link(oldpath.dentry, mnt_idmap(newpath.mnt),\n\t\t       d_inode(newpath.dentry),\n\t\t       dentry, NULL);\n\tif (err)\n\t\tksmbd_debug(VFS, \"vfs_link failed err %d\\n\", err);\n\nout3:\n\tdone_path_create(&newpath, dentry);\nout2:\n\tpath_put(&oldpath);\nout1:\n\tksmbd_revert_fsids(work);\n\treturn err;\n}\n\nint ksmbd_vfs_rename(struct ksmbd_work *work, const struct path *old_path,\n\t\t     char *newname, int flags)\n{\n\tstruct dentry *old_parent, *new_dentry, *trap;\n\tstruct dentry *old_child = old_path->dentry;\n\tstruct path new_path;\n\tstruct qstr new_last;\n\tstruct renamedata rd;\n\tstruct filename *to;\n\tstruct ksmbd_share_config *share_conf = work->tcon->share_conf;\n\tstruct ksmbd_file *parent_fp;\n\tint new_type;\n\tint err, lookup_flags = LOOKUP_NO_SYMLINKS;\n\n\tif (ksmbd_override_fsids(work))\n\t\treturn -ENOMEM;\n\n\tto = getname_kernel(newname);\n\tif (IS_ERR(to)) {\n\t\terr = PTR_ERR(to);\n\t\tgoto revert_fsids;\n\t}\n\nretry:\n\terr = vfs_path_parent_lookup(to, lookup_flags | LOOKUP_BENEATH,\n\t\t\t\t     &new_path, &new_last, &new_type,\n\t\t\t\t     &share_conf->vfs_path);\n\tif (err)\n\t\tgoto out1;\n\n\tif (old_path->mnt != new_path.mnt) {\n\t\terr = -EXDEV;\n\t\tgoto out2;\n\t}\n\n\terr = mnt_want_write(old_path->mnt);\n\tif (err)\n\t\tgoto out2;\n\n\ttrap = lock_rename_child(old_child, new_path.dentry);\n\n\told_parent = dget(old_child->d_parent);\n\tif (d_unhashed(old_child)) {\n\t\terr = -EINVAL;\n\t\tgoto out3;\n\t}\n\n\tparent_fp = ksmbd_lookup_fd_inode(old_child->d_parent);\n\tif (parent_fp) {\n\t\tif (parent_fp->daccess & FILE_DELETE_LE) {\n\t\t\tpr_err(\"parent dir is opened with delete access\\n\");\n\t\t\terr = -ESHARE;\n\t\t\tksmbd_fd_put(work, parent_fp);\n\t\t\tgoto out3;\n\t\t}\n\t\tksmbd_fd_put(work, parent_fp);\n\t}\n\n\tnew_dentry = lookup_one_qstr_excl(&new_last, new_path.dentry,\n\t\t\t\t\t  lookup_flags | LOOKUP_RENAME_TARGET);\n\tif (IS_ERR(new_dentry)) {\n\t\terr = PTR_ERR(new_dentry);\n\t\tgoto out3;\n\t}\n\n\tif (d_is_symlink(new_dentry)) {\n\t\terr = -EACCES;\n\t\tgoto out4;\n\t}\n\n\tif ((flags & RENAME_NOREPLACE) && d_is_positive(new_dentry)) {\n\t\terr = -EEXIST;\n\t\tgoto out4;\n\t}\n\n\tif (old_child == trap) {\n\t\terr = -EINVAL;\n\t\tgoto out4;\n\t}\n\n\tif (new_dentry == trap) {\n\t\terr = -ENOTEMPTY;\n\t\tgoto out4;\n\t}\n\n\trd.old_mnt_idmap\t= mnt_idmap(old_path->mnt),\n\trd.old_dir\t\t= d_inode(old_parent),\n\trd.old_dentry\t\t= old_child,\n\trd.new_mnt_idmap\t= mnt_idmap(new_path.mnt),\n\trd.new_dir\t\t= new_path.dentry->d_inode,\n\trd.new_dentry\t\t= new_dentry,\n\trd.flags\t\t= flags,\n\trd.delegated_inode\t= NULL,\n\terr = vfs_rename(&rd);\n\tif (err)\n\t\tksmbd_debug(VFS, \"vfs_rename failed err %d\\n\", err);\n\nout4:\n\tdput(new_dentry);\nout3:\n\tdput(old_parent);\n\tunlock_rename(old_parent, new_path.dentry);\n\tmnt_drop_write(old_path->mnt);\nout2:\n\tpath_put(&new_path);\n\n\tif (retry_estale(err, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\nout1:\n\tputname(to);\nrevert_fsids:\n\tksmbd_revert_fsids(work);\n\treturn err;\n}\n\n \nint ksmbd_vfs_truncate(struct ksmbd_work *work,\n\t\t       struct ksmbd_file *fp, loff_t size)\n{\n\tint err = 0;\n\tstruct file *filp;\n\n\tfilp = fp->filp;\n\n\t \n\tsmb_break_all_levII_oplock(work, fp, 1);\n\n\tif (!work->tcon->posix_extensions) {\n\t\tstruct inode *inode = file_inode(filp);\n\n\t\tif (size < inode->i_size) {\n\t\t\terr = check_lock_range(filp, size,\n\t\t\t\t\t       inode->i_size - 1, WRITE);\n\t\t} else {\n\t\t\terr = check_lock_range(filp, inode->i_size,\n\t\t\t\t\t       size - 1, WRITE);\n\t\t}\n\n\t\tif (err) {\n\t\t\tpr_err(\"failed due to lock\\n\");\n\t\t\treturn -EAGAIN;\n\t\t}\n\t}\n\n\terr = vfs_truncate(&filp->f_path, size);\n\tif (err)\n\t\tpr_err(\"truncate failed, err %d\\n\", err);\n\treturn err;\n}\n\n \nssize_t ksmbd_vfs_listxattr(struct dentry *dentry, char **list)\n{\n\tssize_t size;\n\tchar *vlist = NULL;\n\n\tsize = vfs_listxattr(dentry, NULL, 0);\n\tif (size <= 0)\n\t\treturn size;\n\n\tvlist = kvzalloc(size, GFP_KERNEL);\n\tif (!vlist)\n\t\treturn -ENOMEM;\n\n\t*list = vlist;\n\tsize = vfs_listxattr(dentry, vlist, size);\n\tif (size < 0) {\n\t\tksmbd_debug(VFS, \"listxattr failed\\n\");\n\t\tkvfree(vlist);\n\t\t*list = NULL;\n\t}\n\n\treturn size;\n}\n\nstatic ssize_t ksmbd_vfs_xattr_len(struct mnt_idmap *idmap,\n\t\t\t\t   struct dentry *dentry, char *xattr_name)\n{\n\treturn vfs_getxattr(idmap, dentry, xattr_name, NULL, 0);\n}\n\n \nssize_t ksmbd_vfs_getxattr(struct mnt_idmap *idmap,\n\t\t\t   struct dentry *dentry,\n\t\t\t   char *xattr_name, char **xattr_buf)\n{\n\tssize_t xattr_len;\n\tchar *buf;\n\n\t*xattr_buf = NULL;\n\txattr_len = ksmbd_vfs_xattr_len(idmap, dentry, xattr_name);\n\tif (xattr_len < 0)\n\t\treturn xattr_len;\n\n\tbuf = kmalloc(xattr_len + 1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\txattr_len = vfs_getxattr(idmap, dentry, xattr_name,\n\t\t\t\t (void *)buf, xattr_len);\n\tif (xattr_len > 0)\n\t\t*xattr_buf = buf;\n\telse\n\t\tkfree(buf);\n\treturn xattr_len;\n}\n\n \nint ksmbd_vfs_setxattr(struct mnt_idmap *idmap,\n\t\t       const struct path *path, const char *attr_name,\n\t\t       void *attr_value, size_t attr_size, int flags,\n\t\t       bool get_write)\n{\n\tint err;\n\n\tif (get_write == true) {\n\t\terr = mnt_want_write(path->mnt);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = vfs_setxattr(idmap,\n\t\t\t   path->dentry,\n\t\t\t   attr_name,\n\t\t\t   attr_value,\n\t\t\t   attr_size,\n\t\t\t   flags);\n\tif (err)\n\t\tksmbd_debug(VFS, \"setxattr failed, err %d\\n\", err);\n\tif (get_write == true)\n\t\tmnt_drop_write(path->mnt);\n\treturn err;\n}\n\n \nvoid ksmbd_vfs_set_fadvise(struct file *filp, __le32 option)\n{\n\tstruct address_space *mapping;\n\n\tmapping = filp->f_mapping;\n\n\tif (!option || !mapping)\n\t\treturn;\n\n\tif (option & FILE_WRITE_THROUGH_LE) {\n\t\tfilp->f_flags |= O_SYNC;\n\t} else if (option & FILE_SEQUENTIAL_ONLY_LE) {\n\t\tfilp->f_ra.ra_pages = inode_to_bdi(mapping->host)->ra_pages * 2;\n\t\tspin_lock(&filp->f_lock);\n\t\tfilp->f_mode &= ~FMODE_RANDOM;\n\t\tspin_unlock(&filp->f_lock);\n\t} else if (option & FILE_RANDOM_ACCESS_LE) {\n\t\tspin_lock(&filp->f_lock);\n\t\tfilp->f_mode |= FMODE_RANDOM;\n\t\tspin_unlock(&filp->f_lock);\n\t}\n}\n\nint ksmbd_vfs_zero_data(struct ksmbd_work *work, struct ksmbd_file *fp,\n\t\t\tloff_t off, loff_t len)\n{\n\tsmb_break_all_levII_oplock(work, fp, 1);\n\tif (fp->f_ci->m_fattr & FILE_ATTRIBUTE_SPARSE_FILE_LE)\n\t\treturn vfs_fallocate(fp->filp,\n\t\t\t\t     FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE,\n\t\t\t\t     off, len);\n\n\treturn vfs_fallocate(fp->filp,\n\t\t\t     FALLOC_FL_ZERO_RANGE | FALLOC_FL_KEEP_SIZE,\n\t\t\t     off, len);\n}\n\nint ksmbd_vfs_fqar_lseek(struct ksmbd_file *fp, loff_t start, loff_t length,\n\t\t\t struct file_allocated_range_buffer *ranges,\n\t\t\t unsigned int in_count, unsigned int *out_count)\n{\n\tstruct file *f = fp->filp;\n\tstruct inode *inode = file_inode(fp->filp);\n\tloff_t maxbytes = (u64)inode->i_sb->s_maxbytes, end;\n\tloff_t extent_start, extent_end;\n\tint ret = 0;\n\n\tif (start > maxbytes)\n\t\treturn -EFBIG;\n\n\tif (!in_count)\n\t\treturn 0;\n\n\t \n\tif (length > maxbytes || (maxbytes - length) < start)\n\t\tlength = maxbytes - start;\n\n\tif (start + length > inode->i_size)\n\t\tlength = inode->i_size - start;\n\n\t*out_count = 0;\n\tend = start + length;\n\twhile (start < end && *out_count < in_count) {\n\t\textent_start = vfs_llseek(f, start, SEEK_DATA);\n\t\tif (extent_start < 0) {\n\t\t\tif (extent_start != -ENXIO)\n\t\t\t\tret = (int)extent_start;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (extent_start >= end)\n\t\t\tbreak;\n\n\t\textent_end = vfs_llseek(f, extent_start, SEEK_HOLE);\n\t\tif (extent_end < 0) {\n\t\t\tif (extent_end != -ENXIO)\n\t\t\t\tret = (int)extent_end;\n\t\t\tbreak;\n\t\t} else if (extent_start >= extent_end) {\n\t\t\tbreak;\n\t\t}\n\n\t\tranges[*out_count].file_offset = cpu_to_le64(extent_start);\n\t\tranges[(*out_count)++].length =\n\t\t\tcpu_to_le64(min(extent_end, end) - extent_start);\n\n\t\tstart = extent_end;\n\t}\n\n\treturn ret;\n}\n\nint ksmbd_vfs_remove_xattr(struct mnt_idmap *idmap,\n\t\t\t   const struct path *path, char *attr_name)\n{\n\tint err;\n\n\terr = mnt_want_write(path->mnt);\n\tif (err)\n\t\treturn err;\n\n\terr = vfs_removexattr(idmap, path->dentry, attr_name);\n\tmnt_drop_write(path->mnt);\n\n\treturn err;\n}\n\nint ksmbd_vfs_unlink(struct file *filp)\n{\n\tint err = 0;\n\tstruct dentry *dir, *dentry = filp->f_path.dentry;\n\tstruct mnt_idmap *idmap = file_mnt_idmap(filp);\n\n\terr = mnt_want_write(filp->f_path.mnt);\n\tif (err)\n\t\treturn err;\n\n\tdir = dget_parent(dentry);\n\terr = ksmbd_vfs_lock_parent(dir, dentry);\n\tif (err)\n\t\tgoto out;\n\tdget(dentry);\n\n\tif (S_ISDIR(d_inode(dentry)->i_mode))\n\t\terr = vfs_rmdir(idmap, d_inode(dir), dentry);\n\telse\n\t\terr = vfs_unlink(idmap, d_inode(dir), dentry, NULL);\n\n\tdput(dentry);\n\tinode_unlock(d_inode(dir));\n\tif (err)\n\t\tksmbd_debug(VFS, \"failed to delete, err %d\\n\", err);\nout:\n\tdput(dir);\n\tmnt_drop_write(filp->f_path.mnt);\n\n\treturn err;\n}\n\nstatic bool __dir_empty(struct dir_context *ctx, const char *name, int namlen,\n\t\t       loff_t offset, u64 ino, unsigned int d_type)\n{\n\tstruct ksmbd_readdir_data *buf;\n\n\tbuf = container_of(ctx, struct ksmbd_readdir_data, ctx);\n\tbuf->dirent_count++;\n\n\treturn buf->dirent_count <= 2;\n}\n\n \nint ksmbd_vfs_empty_dir(struct ksmbd_file *fp)\n{\n\tint err;\n\tstruct ksmbd_readdir_data readdir_data;\n\n\tmemset(&readdir_data, 0, sizeof(struct ksmbd_readdir_data));\n\n\tset_ctx_actor(&readdir_data.ctx, __dir_empty);\n\treaddir_data.dirent_count = 0;\n\n\terr = iterate_dir(fp->filp, &readdir_data.ctx);\n\tif (readdir_data.dirent_count > 2)\n\t\terr = -ENOTEMPTY;\n\telse\n\t\terr = 0;\n\treturn err;\n}\n\nstatic bool __caseless_lookup(struct dir_context *ctx, const char *name,\n\t\t\t     int namlen, loff_t offset, u64 ino,\n\t\t\t     unsigned int d_type)\n{\n\tstruct ksmbd_readdir_data *buf;\n\tint cmp = -EINVAL;\n\n\tbuf = container_of(ctx, struct ksmbd_readdir_data, ctx);\n\n\tif (buf->used != namlen)\n\t\treturn true;\n\tif (IS_ENABLED(CONFIG_UNICODE) && buf->um) {\n\t\tconst struct qstr q_buf = {.name = buf->private,\n\t\t\t\t\t   .len = buf->used};\n\t\tconst struct qstr q_name = {.name = name,\n\t\t\t\t\t    .len = namlen};\n\n\t\tcmp = utf8_strncasecmp(buf->um, &q_buf, &q_name);\n\t}\n\tif (cmp < 0)\n\t\tcmp = strncasecmp((char *)buf->private, name, namlen);\n\tif (!cmp) {\n\t\tmemcpy((char *)buf->private, name, namlen);\n\t\tbuf->dirent_count = 1;\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n \nstatic int ksmbd_vfs_lookup_in_dir(const struct path *dir, char *name,\n\t\t\t\t   size_t namelen, struct unicode_map *um)\n{\n\tint ret;\n\tstruct file *dfilp;\n\tint flags = O_RDONLY | O_LARGEFILE;\n\tstruct ksmbd_readdir_data readdir_data = {\n\t\t.ctx.actor\t= __caseless_lookup,\n\t\t.private\t= name,\n\t\t.used\t\t= namelen,\n\t\t.dirent_count\t= 0,\n\t\t.um\t\t= um,\n\t};\n\n\tdfilp = dentry_open(dir, flags, current_cred());\n\tif (IS_ERR(dfilp))\n\t\treturn PTR_ERR(dfilp);\n\n\tret = iterate_dir(dfilp, &readdir_data.ctx);\n\tif (readdir_data.dirent_count > 0)\n\t\tret = 0;\n\tfput(dfilp);\n\treturn ret;\n}\n\n \nint ksmbd_vfs_kern_path_locked(struct ksmbd_work *work, char *name,\n\t\t\t       unsigned int flags, struct path *parent_path,\n\t\t\t       struct path *path, bool caseless)\n{\n\tstruct ksmbd_share_config *share_conf = work->tcon->share_conf;\n\tint err;\n\n\terr = ksmbd_vfs_path_lookup_locked(share_conf, name, flags, parent_path,\n\t\t\t\t\t   path);\n\tif (!err)\n\t\treturn 0;\n\n\tif (caseless) {\n\t\tchar *filepath;\n\t\tsize_t path_len, remain_len;\n\n\t\tfilepath = kstrdup(name, GFP_KERNEL);\n\t\tif (!filepath)\n\t\t\treturn -ENOMEM;\n\n\t\tpath_len = strlen(filepath);\n\t\tremain_len = path_len;\n\n\t\t*parent_path = share_conf->vfs_path;\n\t\tpath_get(parent_path);\n\n\t\twhile (d_can_lookup(parent_path->dentry)) {\n\t\t\tchar *filename = filepath + path_len - remain_len;\n\t\t\tchar *next = strchrnul(filename, '/');\n\t\t\tsize_t filename_len = next - filename;\n\t\t\tbool is_last = !next[0];\n\n\t\t\tif (filename_len == 0)\n\t\t\t\tbreak;\n\n\t\t\terr = ksmbd_vfs_lookup_in_dir(parent_path, filename,\n\t\t\t\t\t\t      filename_len,\n\t\t\t\t\t\t      work->conn->um);\n\t\t\tif (err)\n\t\t\t\tgoto out2;\n\n\t\t\tnext[0] = '\\0';\n\n\t\t\terr = vfs_path_lookup(share_conf->vfs_path.dentry,\n\t\t\t\t\t      share_conf->vfs_path.mnt,\n\t\t\t\t\t      filepath,\n\t\t\t\t\t      flags,\n\t\t\t\t\t      path);\n\t\t\tif (err)\n\t\t\t\tgoto out2;\n\t\t\telse if (is_last)\n\t\t\t\tgoto out1;\n\t\t\tpath_put(parent_path);\n\t\t\t*parent_path = *path;\n\n\t\t\tnext[0] = '/';\n\t\t\tremain_len -= filename_len + 1;\n\t\t}\n\n\t\terr = -EINVAL;\nout2:\n\t\tpath_put(parent_path);\nout1:\n\t\tkfree(filepath);\n\t}\n\n\tif (!err) {\n\t\terr = mnt_want_write(parent_path->mnt);\n\t\tif (err) {\n\t\t\tpath_put(path);\n\t\t\tpath_put(parent_path);\n\t\t\treturn err;\n\t\t}\n\n\t\terr = ksmbd_vfs_lock_parent(parent_path->dentry, path->dentry);\n\t\tif (err) {\n\t\t\tpath_put(path);\n\t\t\tpath_put(parent_path);\n\t\t}\n\t}\n\treturn err;\n}\n\nvoid ksmbd_vfs_kern_path_unlock(struct path *parent_path, struct path *path)\n{\n\tinode_unlock(d_inode(parent_path->dentry));\n\tmnt_drop_write(parent_path->mnt);\n\tpath_put(path);\n\tpath_put(parent_path);\n}\n\nstruct dentry *ksmbd_vfs_kern_path_create(struct ksmbd_work *work,\n\t\t\t\t\t  const char *name,\n\t\t\t\t\t  unsigned int flags,\n\t\t\t\t\t  struct path *path)\n{\n\tchar *abs_name;\n\tstruct dentry *dent;\n\n\tabs_name = convert_to_unix_name(work->tcon->share_conf, name);\n\tif (!abs_name)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdent = kern_path_create(AT_FDCWD, abs_name, path, flags);\n\tkfree(abs_name);\n\treturn dent;\n}\n\nint ksmbd_vfs_remove_acl_xattrs(struct mnt_idmap *idmap,\n\t\t\t\tconst struct path *path)\n{\n\tchar *name, *xattr_list = NULL;\n\tssize_t xattr_list_len;\n\tint err = 0;\n\n\txattr_list_len = ksmbd_vfs_listxattr(path->dentry, &xattr_list);\n\tif (xattr_list_len < 0) {\n\t\tgoto out;\n\t} else if (!xattr_list_len) {\n\t\tksmbd_debug(SMB, \"empty xattr in the file\\n\");\n\t\tgoto out;\n\t}\n\n\terr = mnt_want_write(path->mnt);\n\tif (err)\n\t\tgoto out;\n\n\tfor (name = xattr_list; name - xattr_list < xattr_list_len;\n\t     name += strlen(name) + 1) {\n\t\tksmbd_debug(SMB, \"%s, len %zd\\n\", name, strlen(name));\n\n\t\tif (!strncmp(name, XATTR_NAME_POSIX_ACL_ACCESS,\n\t\t\t     sizeof(XATTR_NAME_POSIX_ACL_ACCESS) - 1) ||\n\t\t    !strncmp(name, XATTR_NAME_POSIX_ACL_DEFAULT,\n\t\t\t     sizeof(XATTR_NAME_POSIX_ACL_DEFAULT) - 1)) {\n\t\t\terr = vfs_remove_acl(idmap, path->dentry, name);\n\t\t\tif (err)\n\t\t\t\tksmbd_debug(SMB,\n\t\t\t\t\t    \"remove acl xattr failed : %s\\n\", name);\n\t\t}\n\t}\n\tmnt_drop_write(path->mnt);\n\nout:\n\tkvfree(xattr_list);\n\treturn err;\n}\n\nint ksmbd_vfs_remove_sd_xattrs(struct mnt_idmap *idmap, const struct path *path)\n{\n\tchar *name, *xattr_list = NULL;\n\tssize_t xattr_list_len;\n\tint err = 0;\n\n\txattr_list_len = ksmbd_vfs_listxattr(path->dentry, &xattr_list);\n\tif (xattr_list_len < 0) {\n\t\tgoto out;\n\t} else if (!xattr_list_len) {\n\t\tksmbd_debug(SMB, \"empty xattr in the file\\n\");\n\t\tgoto out;\n\t}\n\n\tfor (name = xattr_list; name - xattr_list < xattr_list_len;\n\t\t\tname += strlen(name) + 1) {\n\t\tksmbd_debug(SMB, \"%s, len %zd\\n\", name, strlen(name));\n\n\t\tif (!strncmp(name, XATTR_NAME_SD, XATTR_NAME_SD_LEN)) {\n\t\t\terr = ksmbd_vfs_remove_xattr(idmap, path, name);\n\t\t\tif (err)\n\t\t\t\tksmbd_debug(SMB, \"remove xattr failed : %s\\n\", name);\n\t\t}\n\t}\nout:\n\tkvfree(xattr_list);\n\treturn err;\n}\n\nstatic struct xattr_smb_acl *ksmbd_vfs_make_xattr_posix_acl(struct mnt_idmap *idmap,\n\t\t\t\t\t\t\t    struct inode *inode,\n\t\t\t\t\t\t\t    int acl_type)\n{\n\tstruct xattr_smb_acl *smb_acl = NULL;\n\tstruct posix_acl *posix_acls;\n\tstruct posix_acl_entry *pa_entry;\n\tstruct xattr_acl_entry *xa_entry;\n\tint i;\n\n\tif (!IS_ENABLED(CONFIG_FS_POSIX_ACL))\n\t\treturn NULL;\n\n\tposix_acls = get_inode_acl(inode, acl_type);\n\tif (IS_ERR_OR_NULL(posix_acls))\n\t\treturn NULL;\n\n\tsmb_acl = kzalloc(sizeof(struct xattr_smb_acl) +\n\t\t\t  sizeof(struct xattr_acl_entry) * posix_acls->a_count,\n\t\t\t  GFP_KERNEL);\n\tif (!smb_acl)\n\t\tgoto out;\n\n\tsmb_acl->count = posix_acls->a_count;\n\tpa_entry = posix_acls->a_entries;\n\txa_entry = smb_acl->entries;\n\tfor (i = 0; i < posix_acls->a_count; i++, pa_entry++, xa_entry++) {\n\t\tswitch (pa_entry->e_tag) {\n\t\tcase ACL_USER:\n\t\t\txa_entry->type = SMB_ACL_USER;\n\t\t\txa_entry->uid = posix_acl_uid_translate(idmap, pa_entry);\n\t\t\tbreak;\n\t\tcase ACL_USER_OBJ:\n\t\t\txa_entry->type = SMB_ACL_USER_OBJ;\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\txa_entry->type = SMB_ACL_GROUP;\n\t\t\txa_entry->gid = posix_acl_gid_translate(idmap, pa_entry);\n\t\t\tbreak;\n\t\tcase ACL_GROUP_OBJ:\n\t\t\txa_entry->type = SMB_ACL_GROUP_OBJ;\n\t\t\tbreak;\n\t\tcase ACL_OTHER:\n\t\t\txa_entry->type = SMB_ACL_OTHER;\n\t\t\tbreak;\n\t\tcase ACL_MASK:\n\t\t\txa_entry->type = SMB_ACL_MASK;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"unknown type : 0x%x\\n\", pa_entry->e_tag);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (pa_entry->e_perm & ACL_READ)\n\t\t\txa_entry->perm |= SMB_ACL_READ;\n\t\tif (pa_entry->e_perm & ACL_WRITE)\n\t\t\txa_entry->perm |= SMB_ACL_WRITE;\n\t\tif (pa_entry->e_perm & ACL_EXECUTE)\n\t\t\txa_entry->perm |= SMB_ACL_EXECUTE;\n\t}\nout:\n\tposix_acl_release(posix_acls);\n\treturn smb_acl;\n}\n\nint ksmbd_vfs_set_sd_xattr(struct ksmbd_conn *conn,\n\t\t\t   struct mnt_idmap *idmap,\n\t\t\t   const struct path *path,\n\t\t\t   struct smb_ntsd *pntsd, int len,\n\t\t\t   bool get_write)\n{\n\tint rc;\n\tstruct ndr sd_ndr = {0}, acl_ndr = {0};\n\tstruct xattr_ntacl acl = {0};\n\tstruct xattr_smb_acl *smb_acl, *def_smb_acl = NULL;\n\tstruct dentry *dentry = path->dentry;\n\tstruct inode *inode = d_inode(dentry);\n\n\tacl.version = 4;\n\tacl.hash_type = XATTR_SD_HASH_TYPE_SHA256;\n\tacl.current_time = ksmbd_UnixTimeToNT(current_time(inode));\n\n\tmemcpy(acl.desc, \"posix_acl\", 9);\n\tacl.desc_len = 10;\n\n\tpntsd->osidoffset =\n\t\tcpu_to_le32(le32_to_cpu(pntsd->osidoffset) + NDR_NTSD_OFFSETOF);\n\tpntsd->gsidoffset =\n\t\tcpu_to_le32(le32_to_cpu(pntsd->gsidoffset) + NDR_NTSD_OFFSETOF);\n\tpntsd->dacloffset =\n\t\tcpu_to_le32(le32_to_cpu(pntsd->dacloffset) + NDR_NTSD_OFFSETOF);\n\n\tacl.sd_buf = (char *)pntsd;\n\tacl.sd_size = len;\n\n\trc = ksmbd_gen_sd_hash(conn, acl.sd_buf, acl.sd_size, acl.hash);\n\tif (rc) {\n\t\tpr_err(\"failed to generate hash for ndr acl\\n\");\n\t\treturn rc;\n\t}\n\n\tsmb_acl = ksmbd_vfs_make_xattr_posix_acl(idmap, inode,\n\t\t\t\t\t\t ACL_TYPE_ACCESS);\n\tif (S_ISDIR(inode->i_mode))\n\t\tdef_smb_acl = ksmbd_vfs_make_xattr_posix_acl(idmap, inode,\n\t\t\t\t\t\t\t     ACL_TYPE_DEFAULT);\n\n\trc = ndr_encode_posix_acl(&acl_ndr, idmap, inode,\n\t\t\t\t  smb_acl, def_smb_acl);\n\tif (rc) {\n\t\tpr_err(\"failed to encode ndr to posix acl\\n\");\n\t\tgoto out;\n\t}\n\n\trc = ksmbd_gen_sd_hash(conn, acl_ndr.data, acl_ndr.offset,\n\t\t\t       acl.posix_acl_hash);\n\tif (rc) {\n\t\tpr_err(\"failed to generate hash for ndr acl\\n\");\n\t\tgoto out;\n\t}\n\n\trc = ndr_encode_v4_ntacl(&sd_ndr, &acl);\n\tif (rc) {\n\t\tpr_err(\"failed to encode ndr to posix acl\\n\");\n\t\tgoto out;\n\t}\n\n\trc = ksmbd_vfs_setxattr(idmap, path,\n\t\t\t\tXATTR_NAME_SD, sd_ndr.data,\n\t\t\t\tsd_ndr.offset, 0, get_write);\n\tif (rc < 0)\n\t\tpr_err(\"Failed to store XATTR ntacl :%d\\n\", rc);\n\n\tkfree(sd_ndr.data);\nout:\n\tkfree(acl_ndr.data);\n\tkfree(smb_acl);\n\tkfree(def_smb_acl);\n\treturn rc;\n}\n\nint ksmbd_vfs_get_sd_xattr(struct ksmbd_conn *conn,\n\t\t\t   struct mnt_idmap *idmap,\n\t\t\t   struct dentry *dentry,\n\t\t\t   struct smb_ntsd **pntsd)\n{\n\tint rc;\n\tstruct ndr n;\n\tstruct inode *inode = d_inode(dentry);\n\tstruct ndr acl_ndr = {0};\n\tstruct xattr_ntacl acl;\n\tstruct xattr_smb_acl *smb_acl = NULL, *def_smb_acl = NULL;\n\t__u8 cmp_hash[XATTR_SD_HASH_SIZE] = {0};\n\n\trc = ksmbd_vfs_getxattr(idmap, dentry, XATTR_NAME_SD, &n.data);\n\tif (rc <= 0)\n\t\treturn rc;\n\n\tn.length = rc;\n\trc = ndr_decode_v4_ntacl(&n, &acl);\n\tif (rc)\n\t\tgoto free_n_data;\n\n\tsmb_acl = ksmbd_vfs_make_xattr_posix_acl(idmap, inode,\n\t\t\t\t\t\t ACL_TYPE_ACCESS);\n\tif (S_ISDIR(inode->i_mode))\n\t\tdef_smb_acl = ksmbd_vfs_make_xattr_posix_acl(idmap, inode,\n\t\t\t\t\t\t\t     ACL_TYPE_DEFAULT);\n\n\trc = ndr_encode_posix_acl(&acl_ndr, idmap, inode, smb_acl,\n\t\t\t\t  def_smb_acl);\n\tif (rc) {\n\t\tpr_err(\"failed to encode ndr to posix acl\\n\");\n\t\tgoto out_free;\n\t}\n\n\trc = ksmbd_gen_sd_hash(conn, acl_ndr.data, acl_ndr.offset, cmp_hash);\n\tif (rc) {\n\t\tpr_err(\"failed to generate hash for ndr acl\\n\");\n\t\tgoto out_free;\n\t}\n\n\tif (memcmp(cmp_hash, acl.posix_acl_hash, XATTR_SD_HASH_SIZE)) {\n\t\tpr_err(\"hash value diff\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\t*pntsd = acl.sd_buf;\n\tif (acl.sd_size < sizeof(struct smb_ntsd)) {\n\t\tpr_err(\"sd size is invalid\\n\");\n\t\tgoto out_free;\n\t}\n\n\t(*pntsd)->osidoffset = cpu_to_le32(le32_to_cpu((*pntsd)->osidoffset) -\n\t\t\t\t\t   NDR_NTSD_OFFSETOF);\n\t(*pntsd)->gsidoffset = cpu_to_le32(le32_to_cpu((*pntsd)->gsidoffset) -\n\t\t\t\t\t   NDR_NTSD_OFFSETOF);\n\t(*pntsd)->dacloffset = cpu_to_le32(le32_to_cpu((*pntsd)->dacloffset) -\n\t\t\t\t\t   NDR_NTSD_OFFSETOF);\n\n\trc = acl.sd_size;\nout_free:\n\tkfree(acl_ndr.data);\n\tkfree(smb_acl);\n\tkfree(def_smb_acl);\n\tif (rc < 0) {\n\t\tkfree(acl.sd_buf);\n\t\t*pntsd = NULL;\n\t}\n\nfree_n_data:\n\tkfree(n.data);\n\treturn rc;\n}\n\nint ksmbd_vfs_set_dos_attrib_xattr(struct mnt_idmap *idmap,\n\t\t\t\t   const struct path *path,\n\t\t\t\t   struct xattr_dos_attrib *da,\n\t\t\t\t   bool get_write)\n{\n\tstruct ndr n;\n\tint err;\n\n\terr = ndr_encode_dos_attr(&n, da);\n\tif (err)\n\t\treturn err;\n\n\terr = ksmbd_vfs_setxattr(idmap, path, XATTR_NAME_DOS_ATTRIBUTE,\n\t\t\t\t (void *)n.data, n.offset, 0, get_write);\n\tif (err)\n\t\tksmbd_debug(SMB, \"failed to store dos attribute in xattr\\n\");\n\tkfree(n.data);\n\n\treturn err;\n}\n\nint ksmbd_vfs_get_dos_attrib_xattr(struct mnt_idmap *idmap,\n\t\t\t\t   struct dentry *dentry,\n\t\t\t\t   struct xattr_dos_attrib *da)\n{\n\tstruct ndr n;\n\tint err;\n\n\terr = ksmbd_vfs_getxattr(idmap, dentry, XATTR_NAME_DOS_ATTRIBUTE,\n\t\t\t\t (char **)&n.data);\n\tif (err > 0) {\n\t\tn.length = err;\n\t\tif (ndr_decode_dos_attr(&n, da))\n\t\t\terr = -EINVAL;\n\t\tkfree(n.data);\n\t} else {\n\t\tksmbd_debug(SMB, \"failed to load dos attribute in xattr\\n\");\n\t}\n\n\treturn err;\n}\n\n \nvoid *ksmbd_vfs_init_kstat(char **p, struct ksmbd_kstat *ksmbd_kstat)\n{\n\tstruct file_directory_info *info = (struct file_directory_info *)(*p);\n\tstruct kstat *kstat = ksmbd_kstat->kstat;\n\tu64 time;\n\n\tinfo->FileIndex = 0;\n\tinfo->CreationTime = cpu_to_le64(ksmbd_kstat->create_time);\n\ttime = ksmbd_UnixTimeToNT(kstat->atime);\n\tinfo->LastAccessTime = cpu_to_le64(time);\n\ttime = ksmbd_UnixTimeToNT(kstat->mtime);\n\tinfo->LastWriteTime = cpu_to_le64(time);\n\ttime = ksmbd_UnixTimeToNT(kstat->ctime);\n\tinfo->ChangeTime = cpu_to_le64(time);\n\n\tif (ksmbd_kstat->file_attributes & FILE_ATTRIBUTE_DIRECTORY_LE) {\n\t\tinfo->EndOfFile = 0;\n\t\tinfo->AllocationSize = 0;\n\t} else {\n\t\tinfo->EndOfFile = cpu_to_le64(kstat->size);\n\t\tinfo->AllocationSize = cpu_to_le64(kstat->blocks << 9);\n\t}\n\tinfo->ExtFileAttributes = ksmbd_kstat->file_attributes;\n\n\treturn info;\n}\n\nint ksmbd_vfs_fill_dentry_attrs(struct ksmbd_work *work,\n\t\t\t\tstruct mnt_idmap *idmap,\n\t\t\t\tstruct dentry *dentry,\n\t\t\t\tstruct ksmbd_kstat *ksmbd_kstat)\n{\n\tu64 time;\n\tint rc;\n\n\tgeneric_fillattr(idmap, STATX_BASIC_STATS, d_inode(dentry),\n\t\t\t ksmbd_kstat->kstat);\n\n\ttime = ksmbd_UnixTimeToNT(ksmbd_kstat->kstat->ctime);\n\tksmbd_kstat->create_time = time;\n\n\t \n\tif (S_ISDIR(ksmbd_kstat->kstat->mode))\n\t\tksmbd_kstat->file_attributes = FILE_ATTRIBUTE_DIRECTORY_LE;\n\telse\n\t\tksmbd_kstat->file_attributes = FILE_ATTRIBUTE_ARCHIVE_LE;\n\n\tif (test_share_config_flag(work->tcon->share_conf,\n\t\t\t\t   KSMBD_SHARE_FLAG_STORE_DOS_ATTRS)) {\n\t\tstruct xattr_dos_attrib da;\n\n\t\trc = ksmbd_vfs_get_dos_attrib_xattr(idmap, dentry, &da);\n\t\tif (rc > 0) {\n\t\t\tksmbd_kstat->file_attributes = cpu_to_le32(da.attr);\n\t\t\tksmbd_kstat->create_time = da.create_time;\n\t\t} else {\n\t\t\tksmbd_debug(VFS, \"fail to load dos attribute.\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nssize_t ksmbd_vfs_casexattr_len(struct mnt_idmap *idmap,\n\t\t\t\tstruct dentry *dentry, char *attr_name,\n\t\t\t\tint attr_name_len)\n{\n\tchar *name, *xattr_list = NULL;\n\tssize_t value_len = -ENOENT, xattr_list_len;\n\n\txattr_list_len = ksmbd_vfs_listxattr(dentry, &xattr_list);\n\tif (xattr_list_len <= 0)\n\t\tgoto out;\n\n\tfor (name = xattr_list; name - xattr_list < xattr_list_len;\n\t\t\tname += strlen(name) + 1) {\n\t\tksmbd_debug(VFS, \"%s, len %zd\\n\", name, strlen(name));\n\t\tif (strncasecmp(attr_name, name, attr_name_len))\n\t\t\tcontinue;\n\n\t\tvalue_len = ksmbd_vfs_xattr_len(idmap, dentry, name);\n\t\tbreak;\n\t}\n\nout:\n\tkvfree(xattr_list);\n\treturn value_len;\n}\n\nint ksmbd_vfs_xattr_stream_name(char *stream_name, char **xattr_stream_name,\n\t\t\t\tsize_t *xattr_stream_name_size, int s_type)\n{\n\tchar *type, *buf;\n\n\tif (s_type == DIR_STREAM)\n\t\ttype = \":$INDEX_ALLOCATION\";\n\telse\n\t\ttype = \":$DATA\";\n\n\tbuf = kasprintf(GFP_KERNEL, \"%s%s%s\",\n\t\t\tXATTR_NAME_STREAM, stream_name,\ttype);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t*xattr_stream_name = buf;\n\t*xattr_stream_name_size = strlen(buf) + 1;\n\n\treturn 0;\n}\n\nint ksmbd_vfs_copy_file_ranges(struct ksmbd_work *work,\n\t\t\t       struct ksmbd_file *src_fp,\n\t\t\t       struct ksmbd_file *dst_fp,\n\t\t\t       struct srv_copychunk *chunks,\n\t\t\t       unsigned int chunk_count,\n\t\t\t       unsigned int *chunk_count_written,\n\t\t\t       unsigned int *chunk_size_written,\n\t\t\t       loff_t *total_size_written)\n{\n\tunsigned int i;\n\tloff_t src_off, dst_off, src_file_size;\n\tsize_t len;\n\tint ret;\n\n\t*chunk_count_written = 0;\n\t*chunk_size_written = 0;\n\t*total_size_written = 0;\n\n\tif (!(src_fp->daccess & (FILE_READ_DATA_LE | FILE_EXECUTE_LE))) {\n\t\tpr_err(\"no right to read(%pD)\\n\", src_fp->filp);\n\t\treturn -EACCES;\n\t}\n\tif (!(dst_fp->daccess & (FILE_WRITE_DATA_LE | FILE_APPEND_DATA_LE))) {\n\t\tpr_err(\"no right to write(%pD)\\n\", dst_fp->filp);\n\t\treturn -EACCES;\n\t}\n\n\tif (ksmbd_stream_fd(src_fp) || ksmbd_stream_fd(dst_fp))\n\t\treturn -EBADF;\n\n\tsmb_break_all_levII_oplock(work, dst_fp, 1);\n\n\tif (!work->tcon->posix_extensions) {\n\t\tfor (i = 0; i < chunk_count; i++) {\n\t\t\tsrc_off = le64_to_cpu(chunks[i].SourceOffset);\n\t\t\tdst_off = le64_to_cpu(chunks[i].TargetOffset);\n\t\t\tlen = le32_to_cpu(chunks[i].Length);\n\n\t\t\tif (check_lock_range(src_fp->filp, src_off,\n\t\t\t\t\t     src_off + len - 1, READ))\n\t\t\t\treturn -EAGAIN;\n\t\t\tif (check_lock_range(dst_fp->filp, dst_off,\n\t\t\t\t\t     dst_off + len - 1, WRITE))\n\t\t\t\treturn -EAGAIN;\n\t\t}\n\t}\n\n\tsrc_file_size = i_size_read(file_inode(src_fp->filp));\n\n\tfor (i = 0; i < chunk_count; i++) {\n\t\tsrc_off = le64_to_cpu(chunks[i].SourceOffset);\n\t\tdst_off = le64_to_cpu(chunks[i].TargetOffset);\n\t\tlen = le32_to_cpu(chunks[i].Length);\n\n\t\tif (src_off + len > src_file_size)\n\t\t\treturn -E2BIG;\n\n\t\tret = vfs_copy_file_range(src_fp->filp, src_off,\n\t\t\t\t\t  dst_fp->filp, dst_off, len, 0);\n\t\tif (ret == -EOPNOTSUPP || ret == -EXDEV)\n\t\t\tret = vfs_copy_file_range(src_fp->filp, src_off,\n\t\t\t\t\t\t  dst_fp->filp, dst_off, len,\n\t\t\t\t\t\t  COPY_FILE_SPLICE);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t*chunk_count_written += 1;\n\t\t*total_size_written += ret;\n\t}\n\treturn 0;\n}\n\nvoid ksmbd_vfs_posix_lock_wait(struct file_lock *flock)\n{\n\twait_event(flock->fl_wait, !flock->fl_blocker);\n}\n\nint ksmbd_vfs_posix_lock_wait_timeout(struct file_lock *flock, long timeout)\n{\n\treturn wait_event_interruptible_timeout(flock->fl_wait,\n\t\t\t\t\t\t!flock->fl_blocker,\n\t\t\t\t\t\ttimeout);\n}\n\nvoid ksmbd_vfs_posix_lock_unblock(struct file_lock *flock)\n{\n\tlocks_delete_block(flock);\n}\n\nint ksmbd_vfs_set_init_posix_acl(struct mnt_idmap *idmap,\n\t\t\t\t struct path *path)\n{\n\tstruct posix_acl_state acl_state;\n\tstruct posix_acl *acls;\n\tstruct dentry *dentry = path->dentry;\n\tstruct inode *inode = d_inode(dentry);\n\tint rc;\n\n\tif (!IS_ENABLED(CONFIG_FS_POSIX_ACL))\n\t\treturn -EOPNOTSUPP;\n\n\tksmbd_debug(SMB, \"Set posix acls\\n\");\n\trc = init_acl_state(&acl_state, 1);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tacl_state.owner.allow = (inode->i_mode & 0700) >> 6;\n\tacl_state.group.allow = (inode->i_mode & 0070) >> 3;\n\tacl_state.other.allow = inode->i_mode & 0007;\n\tacl_state.users->aces[acl_state.users->n].uid = inode->i_uid;\n\tacl_state.users->aces[acl_state.users->n++].perms.allow =\n\t\tacl_state.owner.allow;\n\tacl_state.groups->aces[acl_state.groups->n].gid = inode->i_gid;\n\tacl_state.groups->aces[acl_state.groups->n++].perms.allow =\n\t\tacl_state.group.allow;\n\tacl_state.mask.allow = 0x07;\n\n\tacls = posix_acl_alloc(6, GFP_KERNEL);\n\tif (!acls) {\n\t\tfree_acl_state(&acl_state);\n\t\treturn -ENOMEM;\n\t}\n\tposix_state_to_acl(&acl_state, acls->a_entries);\n\n\trc = set_posix_acl(idmap, dentry, ACL_TYPE_ACCESS, acls);\n\tif (rc < 0)\n\t\tksmbd_debug(SMB, \"Set posix acl(ACL_TYPE_ACCESS) failed, rc : %d\\n\",\n\t\t\t    rc);\n\telse if (S_ISDIR(inode->i_mode)) {\n\t\tposix_state_to_acl(&acl_state, acls->a_entries);\n\t\trc = set_posix_acl(idmap, dentry, ACL_TYPE_DEFAULT, acls);\n\t\tif (rc < 0)\n\t\t\tksmbd_debug(SMB, \"Set posix acl(ACL_TYPE_DEFAULT) failed, rc : %d\\n\",\n\t\t\t\t    rc);\n\t}\n\n\tfree_acl_state(&acl_state);\n\tposix_acl_release(acls);\n\treturn rc;\n}\n\nint ksmbd_vfs_inherit_posix_acl(struct mnt_idmap *idmap,\n\t\t\t\tstruct path *path, struct inode *parent_inode)\n{\n\tstruct posix_acl *acls;\n\tstruct posix_acl_entry *pace;\n\tstruct dentry *dentry = path->dentry;\n\tstruct inode *inode = d_inode(dentry);\n\tint rc, i;\n\n\tif (!IS_ENABLED(CONFIG_FS_POSIX_ACL))\n\t\treturn -EOPNOTSUPP;\n\n\tacls = get_inode_acl(parent_inode, ACL_TYPE_DEFAULT);\n\tif (IS_ERR_OR_NULL(acls))\n\t\treturn -ENOENT;\n\tpace = acls->a_entries;\n\n\tfor (i = 0; i < acls->a_count; i++, pace++) {\n\t\tif (pace->e_tag == ACL_MASK) {\n\t\t\tpace->e_perm = 0x07;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trc = set_posix_acl(idmap, dentry, ACL_TYPE_ACCESS, acls);\n\tif (rc < 0)\n\t\tksmbd_debug(SMB, \"Set posix acl(ACL_TYPE_ACCESS) failed, rc : %d\\n\",\n\t\t\t    rc);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\trc = set_posix_acl(idmap, dentry, ACL_TYPE_DEFAULT,\n\t\t\t\t   acls);\n\t\tif (rc < 0)\n\t\t\tksmbd_debug(SMB, \"Set posix acl(ACL_TYPE_DEFAULT) failed, rc : %d\\n\",\n\t\t\t\t    rc);\n\t}\n\n\tposix_acl_release(acls);\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}