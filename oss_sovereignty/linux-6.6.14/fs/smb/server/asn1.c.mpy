{
  "module_name": "asn1.c",
  "hash_id": "e459c4c19e592d28548507daa06ef28b468836c423e1487c3b593c8c7ef30948",
  "original_prompt": "Ingested from linux-6.6.14/fs/smb/server/asn1.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/oid_registry.h>\n\n#include \"glob.h\"\n\n#include \"asn1.h\"\n#include \"connection.h\"\n#include \"auth.h\"\n#include \"ksmbd_spnego_negtokeninit.asn1.h\"\n#include \"ksmbd_spnego_negtokentarg.asn1.h\"\n\n#define NTLMSSP_OID_LEN  10\n\nstatic char NTLMSSP_OID_STR[NTLMSSP_OID_LEN] = { 0x2b, 0x06, 0x01, 0x04, 0x01,\n\t0x82, 0x37, 0x02, 0x02, 0x0a };\n\nint\nksmbd_decode_negTokenInit(unsigned char *security_blob, int length,\n\t\t\t  struct ksmbd_conn *conn)\n{\n\treturn asn1_ber_decoder(&ksmbd_spnego_negtokeninit_decoder, conn,\n\t\t\t\tsecurity_blob, length);\n}\n\nint\nksmbd_decode_negTokenTarg(unsigned char *security_blob, int length,\n\t\t\t  struct ksmbd_conn *conn)\n{\n\treturn asn1_ber_decoder(&ksmbd_spnego_negtokentarg_decoder, conn,\n\t\t\t\tsecurity_blob, length);\n}\n\nstatic int compute_asn_hdr_len_bytes(int len)\n{\n\tif (len > 0xFFFFFF)\n\t\treturn 4;\n\telse if (len > 0xFFFF)\n\t\treturn 3;\n\telse if (len > 0xFF)\n\t\treturn 2;\n\telse if (len > 0x7F)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nstatic void encode_asn_tag(char *buf, unsigned int *ofs, char tag, char seq,\n\t\t\t   int length)\n{\n\tint i;\n\tint index = *ofs;\n\tchar hdr_len = compute_asn_hdr_len_bytes(length);\n\tint len = length + 2 + hdr_len;\n\n\t \n\tbuf[index++] = tag;\n\n\tif (!hdr_len) {\n\t\tbuf[index++] = len;\n\t} else {\n\t\tbuf[index++] = 0x80 | hdr_len;\n\t\tfor (i = hdr_len - 1; i >= 0; i--)\n\t\t\tbuf[index++] = (len >> (i * 8)) & 0xFF;\n\t}\n\n\t \n\tlen = len - (index - *ofs);\n\tbuf[index++] = seq;\n\n\tif (!hdr_len) {\n\t\tbuf[index++] = len;\n\t} else {\n\t\tbuf[index++] = 0x80 | hdr_len;\n\t\tfor (i = hdr_len - 1; i >= 0; i--)\n\t\t\tbuf[index++] = (len >> (i * 8)) & 0xFF;\n\t}\n\n\t*ofs += (index - *ofs);\n}\n\nint build_spnego_ntlmssp_neg_blob(unsigned char **pbuffer, u16 *buflen,\n\t\t\t\t  char *ntlm_blob, int ntlm_blob_len)\n{\n\tchar *buf;\n\tunsigned int ofs = 0;\n\tint neg_result_len = 4 + compute_asn_hdr_len_bytes(1) * 2 + 1;\n\tint oid_len = 4 + compute_asn_hdr_len_bytes(NTLMSSP_OID_LEN) * 2 +\n\t\tNTLMSSP_OID_LEN;\n\tint ntlmssp_len = 4 + compute_asn_hdr_len_bytes(ntlm_blob_len) * 2 +\n\t\tntlm_blob_len;\n\tint total_len = 4 + compute_asn_hdr_len_bytes(neg_result_len +\n\t\t\toid_len + ntlmssp_len) * 2 +\n\t\t\tneg_result_len + oid_len + ntlmssp_len;\n\n\tbuf = kmalloc(total_len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t \n\tencode_asn_tag(buf, &ofs, 0xa1, 0x30, neg_result_len + oid_len +\n\t\t\tntlmssp_len);\n\n\t \n\tencode_asn_tag(buf, &ofs, 0xa0, 0x0a, 1);\n\tbuf[ofs++] = 1;\n\n\t \n\tencode_asn_tag(buf, &ofs, 0xa1, 0x06, NTLMSSP_OID_LEN);\n\tmemcpy(buf + ofs, NTLMSSP_OID_STR, NTLMSSP_OID_LEN);\n\tofs += NTLMSSP_OID_LEN;\n\n\t \n\tencode_asn_tag(buf, &ofs, 0xa2, 0x04, ntlm_blob_len);\n\tmemcpy(buf + ofs, ntlm_blob, ntlm_blob_len);\n\tofs += ntlm_blob_len;\n\n\t*pbuffer = buf;\n\t*buflen = total_len;\n\treturn 0;\n}\n\nint build_spnego_ntlmssp_auth_blob(unsigned char **pbuffer, u16 *buflen,\n\t\t\t\t   int neg_result)\n{\n\tchar *buf;\n\tunsigned int ofs = 0;\n\tint neg_result_len = 4 + compute_asn_hdr_len_bytes(1) * 2 + 1;\n\tint total_len = 4 + compute_asn_hdr_len_bytes(neg_result_len) * 2 +\n\t\tneg_result_len;\n\n\tbuf = kmalloc(total_len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t \n\tencode_asn_tag(buf, &ofs, 0xa1, 0x30, neg_result_len);\n\n\t \n\tencode_asn_tag(buf, &ofs, 0xa0, 0x0a, 1);\n\tif (neg_result)\n\t\tbuf[ofs++] = 2;\n\telse\n\t\tbuf[ofs++] = 0;\n\n\t*pbuffer = buf;\n\t*buflen = total_len;\n\treturn 0;\n}\n\nint ksmbd_gssapi_this_mech(void *context, size_t hdrlen, unsigned char tag,\n\t\t\t   const void *value, size_t vlen)\n{\n\tenum OID oid;\n\n\toid = look_up_OID(value, vlen);\n\tif (oid != OID_spnego) {\n\t\tchar buf[50];\n\n\t\tsprint_oid(value, vlen, buf, sizeof(buf));\n\t\tksmbd_debug(AUTH, \"Unexpected OID: %s\\n\", buf);\n\t\treturn -EBADMSG;\n\t}\n\n\treturn 0;\n}\n\nint ksmbd_neg_token_init_mech_type(void *context, size_t hdrlen,\n\t\t\t\t   unsigned char tag, const void *value,\n\t\t\t\t   size_t vlen)\n{\n\tstruct ksmbd_conn *conn = context;\n\tenum OID oid;\n\tint mech_type;\n\n\toid = look_up_OID(value, vlen);\n\tif (oid == OID_ntlmssp) {\n\t\tmech_type = KSMBD_AUTH_NTLMSSP;\n\t} else if (oid == OID_mskrb5) {\n\t\tmech_type = KSMBD_AUTH_MSKRB5;\n\t} else if (oid == OID_krb5) {\n\t\tmech_type = KSMBD_AUTH_KRB5;\n\t} else if (oid == OID_krb5u2u) {\n\t\tmech_type = KSMBD_AUTH_KRB5U2U;\n\t} else {\n\t\tchar buf[50];\n\n\t\tsprint_oid(value, vlen, buf, sizeof(buf));\n\t\tksmbd_debug(AUTH, \"Unexpected OID: %s\\n\", buf);\n\t\treturn -EBADMSG;\n\t}\n\n\tconn->auth_mechs |= mech_type;\n\tif (conn->preferred_auth_mech == 0)\n\t\tconn->preferred_auth_mech = mech_type;\n\n\treturn 0;\n}\n\nstatic int ksmbd_neg_token_alloc(void *context, size_t hdrlen,\n\t\t\t\t unsigned char tag, const void *value,\n\t\t\t\t size_t vlen)\n{\n\tstruct ksmbd_conn *conn = context;\n\n\tif (!vlen)\n\t\treturn -EINVAL;\n\n\tconn->mechToken = kmemdup_nul(value, vlen, GFP_KERNEL);\n\tif (!conn->mechToken)\n\t\treturn -ENOMEM;\n\n\tconn->mechTokenLen = (unsigned int)vlen;\n\n\treturn 0;\n}\n\nint ksmbd_neg_token_init_mech_token(void *context, size_t hdrlen,\n\t\t\t\t    unsigned char tag, const void *value,\n\t\t\t\t    size_t vlen)\n{\n\treturn ksmbd_neg_token_alloc(context, hdrlen, tag, value, vlen);\n}\n\nint ksmbd_neg_token_targ_resp_token(void *context, size_t hdrlen,\n\t\t\t\t    unsigned char tag, const void *value,\n\t\t\t\t    size_t vlen)\n{\n\treturn ksmbd_neg_token_alloc(context, hdrlen, tag, value, vlen);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}