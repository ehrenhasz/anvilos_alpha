{
  "module_name": "connection.h",
  "hash_id": "7163c755e9f3013f6678fad9cdd44b00966f33036f46e2fbe3fec9f37680b1c4",
  "original_prompt": "Ingested from linux-6.6.14/fs/smb/server/connection.h",
  "human_readable_source": " \n \n\n#ifndef __KSMBD_CONNECTION_H__\n#define __KSMBD_CONNECTION_H__\n\n#include <linux/list.h>\n#include <linux/ip.h>\n#include <net/sock.h>\n#include <net/tcp.h>\n#include <net/inet_connection_sock.h>\n#include <net/request_sock.h>\n#include <linux/kthread.h>\n#include <linux/nls.h>\n#include <linux/unicode.h>\n\n#include \"smb_common.h\"\n#include \"ksmbd_work.h\"\n\n#define KSMBD_SOCKET_BACKLOG\t\t16\n\nenum {\n\tKSMBD_SESS_NEW = 0,\n\tKSMBD_SESS_GOOD,\n\tKSMBD_SESS_EXITING,\n\tKSMBD_SESS_NEED_RECONNECT,\n\tKSMBD_SESS_NEED_NEGOTIATE,\n\tKSMBD_SESS_RELEASING\n};\n\nstruct ksmbd_stats {\n\tatomic_t\t\t\topen_files_count;\n\tatomic64_t\t\t\trequest_served;\n};\n\nstruct ksmbd_transport;\n\nstruct ksmbd_conn {\n\tstruct smb_version_values\t*vals;\n\tstruct smb_version_ops\t\t*ops;\n\tstruct smb_version_cmds\t\t*cmds;\n\tunsigned int\t\t\tmax_cmds;\n\tstruct mutex\t\t\tsrv_mutex;\n\tint\t\t\t\tstatus;\n\tunsigned int\t\t\tcli_cap;\n\tchar\t\t\t\t*request_buf;\n\tstruct ksmbd_transport\t\t*transport;\n\tstruct nls_table\t\t*local_nls;\n\tstruct unicode_map\t\t*um;\n\tstruct list_head\t\tconns_list;\n\tstruct rw_semaphore\t\tsession_lock;\n\t \n\tstruct xarray\t\t\tsessions;\n\tunsigned long\t\t\tlast_active;\n\t \n\tatomic_t\t\t\treq_running;\n\t \n\tatomic_t\t\t\tr_count;\n\tunsigned int\t\t\ttotal_credits;\n\tunsigned int\t\t\toutstanding_credits;\n\tspinlock_t\t\t\tcredits_lock;\n\twait_queue_head_t\t\treq_running_q;\n\twait_queue_head_t\t\tr_count_q;\n\t \n\tspinlock_t\t\t\trequest_lock;\n\tstruct list_head\t\trequests;\n\tstruct list_head\t\tasync_requests;\n\tint\t\t\t\tconnection_type;\n\tstruct ksmbd_stats\t\tstats;\n\tchar\t\t\t\tClientGUID[SMB2_CLIENT_GUID_SIZE];\n\tstruct ntlmssp_auth\t\tntlmssp;\n\n\tspinlock_t\t\t\tllist_lock;\n\tstruct list_head\t\tlock_list;\n\n\tstruct preauth_integrity_info\t*preauth_info;\n\n\tbool\t\t\t\tneed_neg;\n\tunsigned int\t\t\tauth_mechs;\n\tunsigned int\t\t\tpreferred_auth_mech;\n\tbool\t\t\t\tsign;\n\tbool\t\t\t\tuse_spnego:1;\n\t__u16\t\t\t\tcli_sec_mode;\n\t__u16\t\t\t\tsrv_sec_mode;\n\t \n\t__u16\t\t\t\tdialect;\n\n\tchar\t\t\t\t*mechToken;\n\tunsigned int\t\t\tmechTokenLen;\n\n\tstruct ksmbd_conn_ops\t*conn_ops;\n\n\t \n\tstruct list_head\t\tpreauth_sess_table;\n\n\tstruct sockaddr_storage\t\tpeer_addr;\n\n\t \n\tstruct ida\t\t\tasync_ida;\n\n\t__le16\t\t\t\tcipher_type;\n\t__le16\t\t\t\tcompress_algorithm;\n\tbool\t\t\t\tposix_ext_supported;\n\tbool\t\t\t\tsigning_negotiated;\n\t__le16\t\t\t\tsigning_algorithm;\n\tbool\t\t\t\tbinding;\n};\n\nstruct ksmbd_conn_ops {\n\tint\t(*process_fn)(struct ksmbd_conn *conn);\n\tint\t(*terminate_fn)(struct ksmbd_conn *conn);\n};\n\nstruct ksmbd_transport_ops {\n\tint (*prepare)(struct ksmbd_transport *t);\n\tvoid (*disconnect)(struct ksmbd_transport *t);\n\tvoid (*shutdown)(struct ksmbd_transport *t);\n\tint (*read)(struct ksmbd_transport *t, char *buf,\n\t\t    unsigned int size, int max_retries);\n\tint (*writev)(struct ksmbd_transport *t, struct kvec *iovs, int niov,\n\t\t      int size, bool need_invalidate_rkey,\n\t\t      unsigned int remote_key);\n\tint (*rdma_read)(struct ksmbd_transport *t,\n\t\t\t void *buf, unsigned int len,\n\t\t\t struct smb2_buffer_desc_v1 *desc,\n\t\t\t unsigned int desc_len);\n\tint (*rdma_write)(struct ksmbd_transport *t,\n\t\t\t  void *buf, unsigned int len,\n\t\t\t  struct smb2_buffer_desc_v1 *desc,\n\t\t\t  unsigned int desc_len);\n};\n\nstruct ksmbd_transport {\n\tstruct ksmbd_conn\t\t*conn;\n\tstruct ksmbd_transport_ops\t*ops;\n};\n\n#define KSMBD_TCP_RECV_TIMEOUT\t(7 * HZ)\n#define KSMBD_TCP_SEND_TIMEOUT\t(5 * HZ)\n#define KSMBD_TCP_PEER_SOCKADDR(c)\t((struct sockaddr *)&((c)->peer_addr))\n\nextern struct list_head conn_list;\nextern struct rw_semaphore conn_list_lock;\n\nbool ksmbd_conn_alive(struct ksmbd_conn *conn);\nvoid ksmbd_conn_wait_idle(struct ksmbd_conn *conn, u64 sess_id);\nstruct ksmbd_conn *ksmbd_conn_alloc(void);\nvoid ksmbd_conn_free(struct ksmbd_conn *conn);\nbool ksmbd_conn_lookup_dialect(struct ksmbd_conn *c);\nint ksmbd_conn_write(struct ksmbd_work *work);\nint ksmbd_conn_rdma_read(struct ksmbd_conn *conn,\n\t\t\t void *buf, unsigned int buflen,\n\t\t\t struct smb2_buffer_desc_v1 *desc,\n\t\t\t unsigned int desc_len);\nint ksmbd_conn_rdma_write(struct ksmbd_conn *conn,\n\t\t\t  void *buf, unsigned int buflen,\n\t\t\t  struct smb2_buffer_desc_v1 *desc,\n\t\t\t  unsigned int desc_len);\nvoid ksmbd_conn_enqueue_request(struct ksmbd_work *work);\nvoid ksmbd_conn_try_dequeue_request(struct ksmbd_work *work);\nvoid ksmbd_conn_init_server_callbacks(struct ksmbd_conn_ops *ops);\nint ksmbd_conn_handler_loop(void *p);\nint ksmbd_conn_transport_init(void);\nvoid ksmbd_conn_transport_destroy(void);\nvoid ksmbd_conn_lock(struct ksmbd_conn *conn);\nvoid ksmbd_conn_unlock(struct ksmbd_conn *conn);\n\n \nstatic inline bool ksmbd_conn_good(struct ksmbd_conn *conn)\n{\n\treturn READ_ONCE(conn->status) == KSMBD_SESS_GOOD;\n}\n\nstatic inline bool ksmbd_conn_need_negotiate(struct ksmbd_conn *conn)\n{\n\treturn READ_ONCE(conn->status) == KSMBD_SESS_NEED_NEGOTIATE;\n}\n\nstatic inline bool ksmbd_conn_need_reconnect(struct ksmbd_conn *conn)\n{\n\treturn READ_ONCE(conn->status) == KSMBD_SESS_NEED_RECONNECT;\n}\n\nstatic inline bool ksmbd_conn_exiting(struct ksmbd_conn *conn)\n{\n\treturn READ_ONCE(conn->status) == KSMBD_SESS_EXITING;\n}\n\nstatic inline bool ksmbd_conn_releasing(struct ksmbd_conn *conn)\n{\n\treturn READ_ONCE(conn->status) == KSMBD_SESS_RELEASING;\n}\n\nstatic inline void ksmbd_conn_set_new(struct ksmbd_conn *conn)\n{\n\tWRITE_ONCE(conn->status, KSMBD_SESS_NEW);\n}\n\nstatic inline void ksmbd_conn_set_good(struct ksmbd_conn *conn)\n{\n\tWRITE_ONCE(conn->status, KSMBD_SESS_GOOD);\n}\n\nstatic inline void ksmbd_conn_set_need_negotiate(struct ksmbd_conn *conn)\n{\n\tWRITE_ONCE(conn->status, KSMBD_SESS_NEED_NEGOTIATE);\n}\n\nstatic inline void ksmbd_conn_set_need_reconnect(struct ksmbd_conn *conn)\n{\n\tWRITE_ONCE(conn->status, KSMBD_SESS_NEED_RECONNECT);\n}\n\nstatic inline void ksmbd_conn_set_exiting(struct ksmbd_conn *conn)\n{\n\tWRITE_ONCE(conn->status, KSMBD_SESS_EXITING);\n}\n\nstatic inline void ksmbd_conn_set_releasing(struct ksmbd_conn *conn)\n{\n\tWRITE_ONCE(conn->status, KSMBD_SESS_RELEASING);\n}\n\nvoid ksmbd_all_conn_set_status(u64 sess_id, u32 status);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}