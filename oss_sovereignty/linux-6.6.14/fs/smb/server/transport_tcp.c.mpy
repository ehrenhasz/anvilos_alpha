{
  "module_name": "transport_tcp.c",
  "hash_id": "c3bc60d139e621b98a3b9eb355d71ab67e6e9f4f34f35c6a55f0d48fb65e481b",
  "original_prompt": "Ingested from linux-6.6.14/fs/smb/server/transport_tcp.c",
  "human_readable_source": "\n \n\n#include <linux/freezer.h>\n\n#include \"smb_common.h\"\n#include \"server.h\"\n#include \"auth.h\"\n#include \"connection.h\"\n#include \"transport_tcp.h\"\n\n#define IFACE_STATE_DOWN\t\tBIT(0)\n#define IFACE_STATE_CONFIGURED\t\tBIT(1)\n\nstatic atomic_t active_num_conn;\n\nstruct interface {\n\tstruct task_struct\t*ksmbd_kthread;\n\tstruct socket\t\t*ksmbd_socket;\n\tstruct list_head\tentry;\n\tchar\t\t\t*name;\n\tstruct mutex\t\tsock_release_lock;\n\tint\t\t\tstate;\n};\n\nstatic LIST_HEAD(iface_list);\n\nstatic int bind_additional_ifaces;\n\nstruct tcp_transport {\n\tstruct ksmbd_transport\t\ttransport;\n\tstruct socket\t\t\t*sock;\n\tstruct kvec\t\t\t*iov;\n\tunsigned int\t\t\tnr_iov;\n};\n\nstatic struct ksmbd_transport_ops ksmbd_tcp_transport_ops;\n\nstatic void tcp_stop_kthread(struct task_struct *kthread);\nstatic struct interface *alloc_iface(char *ifname);\n\n#define KSMBD_TRANS(t)\t(&(t)->transport)\n#define TCP_TRANS(t)\t((struct tcp_transport *)container_of(t, \\\n\t\t\t\tstruct tcp_transport, transport))\n\nstatic inline void ksmbd_tcp_nodelay(struct socket *sock)\n{\n\ttcp_sock_set_nodelay(sock->sk);\n}\n\nstatic inline void ksmbd_tcp_reuseaddr(struct socket *sock)\n{\n\tsock_set_reuseaddr(sock->sk);\n}\n\nstatic inline void ksmbd_tcp_rcv_timeout(struct socket *sock, s64 secs)\n{\n\tlock_sock(sock->sk);\n\tif (secs && secs < MAX_SCHEDULE_TIMEOUT / HZ - 1)\n\t\tsock->sk->sk_rcvtimeo = secs * HZ;\n\telse\n\t\tsock->sk->sk_rcvtimeo = MAX_SCHEDULE_TIMEOUT;\n\trelease_sock(sock->sk);\n}\n\nstatic inline void ksmbd_tcp_snd_timeout(struct socket *sock, s64 secs)\n{\n\tsock_set_sndtimeo(sock->sk, secs);\n}\n\nstatic struct tcp_transport *alloc_transport(struct socket *client_sk)\n{\n\tstruct tcp_transport *t;\n\tstruct ksmbd_conn *conn;\n\n\tt = kzalloc(sizeof(*t), GFP_KERNEL);\n\tif (!t)\n\t\treturn NULL;\n\tt->sock = client_sk;\n\n\tconn = ksmbd_conn_alloc();\n\tif (!conn) {\n\t\tkfree(t);\n\t\treturn NULL;\n\t}\n\n\tconn->transport = KSMBD_TRANS(t);\n\tKSMBD_TRANS(t)->conn = conn;\n\tKSMBD_TRANS(t)->ops = &ksmbd_tcp_transport_ops;\n\treturn t;\n}\n\nstatic void free_transport(struct tcp_transport *t)\n{\n\tkernel_sock_shutdown(t->sock, SHUT_RDWR);\n\tsock_release(t->sock);\n\tt->sock = NULL;\n\n\tksmbd_conn_free(KSMBD_TRANS(t)->conn);\n\tkfree(t->iov);\n\tkfree(t);\n}\n\n \nstatic unsigned int kvec_array_init(struct kvec *new, struct kvec *iov,\n\t\t\t\t    unsigned int nr_segs, size_t bytes)\n{\n\tsize_t base = 0;\n\n\twhile (bytes || !iov->iov_len) {\n\t\tint copy = min(bytes, iov->iov_len);\n\n\t\tbytes -= copy;\n\t\tbase += copy;\n\t\tif (iov->iov_len == base) {\n\t\t\tiov++;\n\t\t\tnr_segs--;\n\t\t\tbase = 0;\n\t\t}\n\t}\n\n\tmemcpy(new, iov, sizeof(*iov) * nr_segs);\n\tnew->iov_base += base;\n\tnew->iov_len -= base;\n\treturn nr_segs;\n}\n\n \nstatic struct kvec *get_conn_iovec(struct tcp_transport *t, unsigned int nr_segs)\n{\n\tstruct kvec *new_iov;\n\n\tif (t->iov && nr_segs <= t->nr_iov)\n\t\treturn t->iov;\n\n\t \n\tnew_iov = kmalloc_array(nr_segs, sizeof(*new_iov), GFP_KERNEL);\n\tif (new_iov) {\n\t\tkfree(t->iov);\n\t\tt->iov = new_iov;\n\t\tt->nr_iov = nr_segs;\n\t}\n\treturn new_iov;\n}\n\nstatic unsigned short ksmbd_tcp_get_port(const struct sockaddr *sa)\n{\n\tswitch (sa->sa_family) {\n\tcase AF_INET:\n\t\treturn ntohs(((struct sockaddr_in *)sa)->sin_port);\n\tcase AF_INET6:\n\t\treturn ntohs(((struct sockaddr_in6 *)sa)->sin6_port);\n\t}\n\treturn 0;\n}\n\n \nstatic int ksmbd_tcp_new_connection(struct socket *client_sk)\n{\n\tstruct sockaddr *csin;\n\tint rc = 0;\n\tstruct tcp_transport *t;\n\tstruct task_struct *handler;\n\n\tt = alloc_transport(client_sk);\n\tif (!t) {\n\t\tsock_release(client_sk);\n\t\treturn -ENOMEM;\n\t}\n\n\tcsin = KSMBD_TCP_PEER_SOCKADDR(KSMBD_TRANS(t)->conn);\n\tif (kernel_getpeername(client_sk, csin) < 0) {\n\t\tpr_err(\"client ip resolution failed\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out_error;\n\t}\n\n\thandler = kthread_run(ksmbd_conn_handler_loop,\n\t\t\t      KSMBD_TRANS(t)->conn,\n\t\t\t      \"ksmbd:%u\",\n\t\t\t      ksmbd_tcp_get_port(csin));\n\tif (IS_ERR(handler)) {\n\t\tpr_err(\"cannot start conn thread\\n\");\n\t\trc = PTR_ERR(handler);\n\t\tfree_transport(t);\n\t}\n\treturn rc;\n\nout_error:\n\tfree_transport(t);\n\treturn rc;\n}\n\n \nstatic int ksmbd_kthread_fn(void *p)\n{\n\tstruct socket *client_sk = NULL;\n\tstruct interface *iface = (struct interface *)p;\n\tint ret;\n\n\twhile (!kthread_should_stop()) {\n\t\tmutex_lock(&iface->sock_release_lock);\n\t\tif (!iface->ksmbd_socket) {\n\t\t\tmutex_unlock(&iface->sock_release_lock);\n\t\t\tbreak;\n\t\t}\n\t\tret = kernel_accept(iface->ksmbd_socket, &client_sk,\n\t\t\t\t    SOCK_NONBLOCK);\n\t\tmutex_unlock(&iface->sock_release_lock);\n\t\tif (ret) {\n\t\t\tif (ret == -EAGAIN)\n\t\t\t\t \n\t\t\t\tschedule_timeout_interruptible(HZ / 10);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (server_conf.max_connections &&\n\t\t    atomic_inc_return(&active_num_conn) >= server_conf.max_connections) {\n\t\t\tpr_info_ratelimited(\"Limit the maximum number of connections(%u)\\n\",\n\t\t\t\t\t    atomic_read(&active_num_conn));\n\t\t\tatomic_dec(&active_num_conn);\n\t\t\tsock_release(client_sk);\n\t\t\tcontinue;\n\t\t}\n\n\t\tksmbd_debug(CONN, \"connect success: accepted new connection\\n\");\n\t\tclient_sk->sk->sk_rcvtimeo = KSMBD_TCP_RECV_TIMEOUT;\n\t\tclient_sk->sk->sk_sndtimeo = KSMBD_TCP_SEND_TIMEOUT;\n\n\t\tksmbd_tcp_new_connection(client_sk);\n\t}\n\n\tksmbd_debug(CONN, \"releasing socket\\n\");\n\treturn 0;\n}\n\n \nstatic int ksmbd_tcp_run_kthread(struct interface *iface)\n{\n\tint rc;\n\tstruct task_struct *kthread;\n\n\tkthread = kthread_run(ksmbd_kthread_fn, (void *)iface, \"ksmbd-%s\",\n\t\t\t      iface->name);\n\tif (IS_ERR(kthread)) {\n\t\trc = PTR_ERR(kthread);\n\t\treturn rc;\n\t}\n\tiface->ksmbd_kthread = kthread;\n\n\treturn 0;\n}\n\n \nstatic int ksmbd_tcp_readv(struct tcp_transport *t, struct kvec *iov_orig,\n\t\t\t   unsigned int nr_segs, unsigned int to_read,\n\t\t\t   int max_retries)\n{\n\tint length = 0;\n\tint total_read;\n\tunsigned int segs;\n\tstruct msghdr ksmbd_msg;\n\tstruct kvec *iov;\n\tstruct ksmbd_conn *conn = KSMBD_TRANS(t)->conn;\n\n\tiov = get_conn_iovec(t, nr_segs);\n\tif (!iov)\n\t\treturn -ENOMEM;\n\n\tksmbd_msg.msg_control = NULL;\n\tksmbd_msg.msg_controllen = 0;\n\n\tfor (total_read = 0; to_read; total_read += length, to_read -= length) {\n\t\ttry_to_freeze();\n\n\t\tif (!ksmbd_conn_alive(conn)) {\n\t\t\ttotal_read = -ESHUTDOWN;\n\t\t\tbreak;\n\t\t}\n\t\tsegs = kvec_array_init(iov, iov_orig, nr_segs, total_read);\n\n\t\tlength = kernel_recvmsg(t->sock, &ksmbd_msg,\n\t\t\t\t\tiov, segs, to_read, 0);\n\n\t\tif (length == -EINTR) {\n\t\t\ttotal_read = -ESHUTDOWN;\n\t\t\tbreak;\n\t\t} else if (ksmbd_conn_need_reconnect(conn)) {\n\t\t\ttotal_read = -EAGAIN;\n\t\t\tbreak;\n\t\t} else if (length == -ERESTARTSYS || length == -EAGAIN) {\n\t\t\t \n\t\t\tif (max_retries == 0) {\n\t\t\t\ttotal_read = length;\n\t\t\t\tbreak;\n\t\t\t} else if (max_retries > 0) {\n\t\t\t\tmax_retries--;\n\t\t\t}\n\n\t\t\tusleep_range(1000, 2000);\n\t\t\tlength = 0;\n\t\t\tcontinue;\n\t\t} else if (length <= 0) {\n\t\t\ttotal_read = length;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn total_read;\n}\n\n \nstatic int ksmbd_tcp_read(struct ksmbd_transport *t, char *buf,\n\t\t\t  unsigned int to_read, int max_retries)\n{\n\tstruct kvec iov;\n\n\tiov.iov_base = buf;\n\tiov.iov_len = to_read;\n\n\treturn ksmbd_tcp_readv(TCP_TRANS(t), &iov, 1, to_read, max_retries);\n}\n\nstatic int ksmbd_tcp_writev(struct ksmbd_transport *t, struct kvec *iov,\n\t\t\t    int nvecs, int size, bool need_invalidate,\n\t\t\t    unsigned int remote_key)\n\n{\n\tstruct msghdr smb_msg = {.msg_flags = MSG_NOSIGNAL};\n\n\treturn kernel_sendmsg(TCP_TRANS(t)->sock, &smb_msg, iov, nvecs, size);\n}\n\nstatic void ksmbd_tcp_disconnect(struct ksmbd_transport *t)\n{\n\tfree_transport(TCP_TRANS(t));\n\tif (server_conf.max_connections)\n\t\tatomic_dec(&active_num_conn);\n}\n\nstatic void tcp_destroy_socket(struct socket *ksmbd_socket)\n{\n\tint ret;\n\n\tif (!ksmbd_socket)\n\t\treturn;\n\n\t \n\tksmbd_tcp_rcv_timeout(ksmbd_socket, 0);\n\tksmbd_tcp_snd_timeout(ksmbd_socket, 0);\n\n\tret = kernel_sock_shutdown(ksmbd_socket, SHUT_RDWR);\n\tif (ret)\n\t\tpr_err(\"Failed to shutdown socket: %d\\n\", ret);\n\tsock_release(ksmbd_socket);\n}\n\n \nstatic int create_socket(struct interface *iface)\n{\n\tint ret;\n\tstruct sockaddr_in6 sin6;\n\tstruct sockaddr_in sin;\n\tstruct socket *ksmbd_socket;\n\tbool ipv4 = false;\n\n\tret = sock_create(PF_INET6, SOCK_STREAM, IPPROTO_TCP, &ksmbd_socket);\n\tif (ret) {\n\t\tif (ret != -EAFNOSUPPORT)\n\t\t\tpr_err(\"Can't create socket for ipv6, fallback to ipv4: %d\\n\", ret);\n\t\tret = sock_create(PF_INET, SOCK_STREAM, IPPROTO_TCP,\n\t\t\t\t  &ksmbd_socket);\n\t\tif (ret) {\n\t\t\tpr_err(\"Can't create socket for ipv4: %d\\n\", ret);\n\t\t\tgoto out_clear;\n\t\t}\n\n\t\tsin.sin_family = PF_INET;\n\t\tsin.sin_addr.s_addr = htonl(INADDR_ANY);\n\t\tsin.sin_port = htons(server_conf.tcp_port);\n\t\tipv4 = true;\n\t} else {\n\t\tsin6.sin6_family = PF_INET6;\n\t\tsin6.sin6_addr = in6addr_any;\n\t\tsin6.sin6_port = htons(server_conf.tcp_port);\n\t}\n\n\tksmbd_tcp_nodelay(ksmbd_socket);\n\tksmbd_tcp_reuseaddr(ksmbd_socket);\n\n\tret = sock_setsockopt(ksmbd_socket,\n\t\t\t      SOL_SOCKET,\n\t\t\t      SO_BINDTODEVICE,\n\t\t\t      KERNEL_SOCKPTR(iface->name),\n\t\t\t      strlen(iface->name));\n\tif (ret != -ENODEV && ret < 0) {\n\t\tpr_err(\"Failed to set SO_BINDTODEVICE: %d\\n\", ret);\n\t\tgoto out_error;\n\t}\n\n\tif (ipv4)\n\t\tret = kernel_bind(ksmbd_socket, (struct sockaddr *)&sin,\n\t\t\t\t  sizeof(sin));\n\telse\n\t\tret = kernel_bind(ksmbd_socket, (struct sockaddr *)&sin6,\n\t\t\t\t  sizeof(sin6));\n\tif (ret) {\n\t\tpr_err(\"Failed to bind socket: %d\\n\", ret);\n\t\tgoto out_error;\n\t}\n\n\tksmbd_socket->sk->sk_rcvtimeo = KSMBD_TCP_RECV_TIMEOUT;\n\tksmbd_socket->sk->sk_sndtimeo = KSMBD_TCP_SEND_TIMEOUT;\n\n\tret = kernel_listen(ksmbd_socket, KSMBD_SOCKET_BACKLOG);\n\tif (ret) {\n\t\tpr_err(\"Port listen() error: %d\\n\", ret);\n\t\tgoto out_error;\n\t}\n\n\tiface->ksmbd_socket = ksmbd_socket;\n\tret = ksmbd_tcp_run_kthread(iface);\n\tif (ret) {\n\t\tpr_err(\"Can't start ksmbd main kthread: %d\\n\", ret);\n\t\tgoto out_error;\n\t}\n\tiface->state = IFACE_STATE_CONFIGURED;\n\n\treturn 0;\n\nout_error:\n\ttcp_destroy_socket(ksmbd_socket);\nout_clear:\n\tiface->ksmbd_socket = NULL;\n\treturn ret;\n}\n\nstatic int ksmbd_netdev_event(struct notifier_block *nb, unsigned long event,\n\t\t\t      void *ptr)\n{\n\tstruct net_device *netdev = netdev_notifier_info_to_dev(ptr);\n\tstruct interface *iface;\n\tint ret, found = 0;\n\n\tswitch (event) {\n\tcase NETDEV_UP:\n\t\tif (netif_is_bridge_port(netdev))\n\t\t\treturn NOTIFY_OK;\n\n\t\tlist_for_each_entry(iface, &iface_list, entry) {\n\t\t\tif (!strcmp(iface->name, netdev->name)) {\n\t\t\t\tfound = 1;\n\t\t\t\tif (iface->state != IFACE_STATE_DOWN)\n\t\t\t\t\tbreak;\n\t\t\t\tret = create_socket(iface);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn NOTIFY_OK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found && bind_additional_ifaces) {\n\t\t\tiface = alloc_iface(kstrdup(netdev->name, GFP_KERNEL));\n\t\t\tif (!iface)\n\t\t\t\treturn NOTIFY_OK;\n\t\t\tret = create_socket(iface);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase NETDEV_DOWN:\n\t\tlist_for_each_entry(iface, &iface_list, entry) {\n\t\t\tif (!strcmp(iface->name, netdev->name) &&\n\t\t\t    iface->state == IFACE_STATE_CONFIGURED) {\n\t\t\t\ttcp_stop_kthread(iface->ksmbd_kthread);\n\t\t\t\tiface->ksmbd_kthread = NULL;\n\t\t\t\tmutex_lock(&iface->sock_release_lock);\n\t\t\t\ttcp_destroy_socket(iface->ksmbd_socket);\n\t\t\t\tiface->ksmbd_socket = NULL;\n\t\t\t\tmutex_unlock(&iface->sock_release_lock);\n\n\t\t\t\tiface->state = IFACE_STATE_DOWN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block ksmbd_netdev_notifier = {\n\t.notifier_call = ksmbd_netdev_event,\n};\n\nint ksmbd_tcp_init(void)\n{\n\tregister_netdevice_notifier(&ksmbd_netdev_notifier);\n\n\treturn 0;\n}\n\nstatic void tcp_stop_kthread(struct task_struct *kthread)\n{\n\tint ret;\n\n\tif (!kthread)\n\t\treturn;\n\n\tret = kthread_stop(kthread);\n\tif (ret)\n\t\tpr_err(\"failed to stop forker thread\\n\");\n}\n\nvoid ksmbd_tcp_destroy(void)\n{\n\tstruct interface *iface, *tmp;\n\n\tunregister_netdevice_notifier(&ksmbd_netdev_notifier);\n\n\tlist_for_each_entry_safe(iface, tmp, &iface_list, entry) {\n\t\tlist_del(&iface->entry);\n\t\tkfree(iface->name);\n\t\tkfree(iface);\n\t}\n}\n\nstatic struct interface *alloc_iface(char *ifname)\n{\n\tstruct interface *iface;\n\n\tif (!ifname)\n\t\treturn NULL;\n\n\tiface = kzalloc(sizeof(struct interface), GFP_KERNEL);\n\tif (!iface) {\n\t\tkfree(ifname);\n\t\treturn NULL;\n\t}\n\n\tiface->name = ifname;\n\tiface->state = IFACE_STATE_DOWN;\n\tlist_add(&iface->entry, &iface_list);\n\tmutex_init(&iface->sock_release_lock);\n\treturn iface;\n}\n\nint ksmbd_tcp_set_interfaces(char *ifc_list, int ifc_list_sz)\n{\n\tint sz = 0;\n\n\tif (!ifc_list_sz) {\n\t\tstruct net_device *netdev;\n\n\t\trtnl_lock();\n\t\tfor_each_netdev(&init_net, netdev) {\n\t\t\tif (netif_is_bridge_port(netdev))\n\t\t\t\tcontinue;\n\t\t\tif (!alloc_iface(kstrdup(netdev->name, GFP_KERNEL)))\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\trtnl_unlock();\n\t\tbind_additional_ifaces = 1;\n\t\treturn 0;\n\t}\n\n\twhile (ifc_list_sz > 0) {\n\t\tif (!alloc_iface(kstrdup(ifc_list, GFP_KERNEL)))\n\t\t\treturn -ENOMEM;\n\n\t\tsz = strlen(ifc_list);\n\t\tif (!sz)\n\t\t\tbreak;\n\n\t\tifc_list += sz + 1;\n\t\tifc_list_sz -= (sz + 1);\n\t}\n\n\tbind_additional_ifaces = 0;\n\n\treturn 0;\n}\n\nstatic struct ksmbd_transport_ops ksmbd_tcp_transport_ops = {\n\t.read\t\t= ksmbd_tcp_read,\n\t.writev\t\t= ksmbd_tcp_writev,\n\t.disconnect\t= ksmbd_tcp_disconnect,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}