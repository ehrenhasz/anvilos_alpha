{
  "module_name": "server.c",
  "hash_id": "ed9c2e84dd8a41af5f1c7860081e1b2f1abba2178df2119afdc2f3b5c73252e5",
  "original_prompt": "Ingested from linux-6.6.14/fs/smb/server/server.c",
  "human_readable_source": "\n \n\n#include \"glob.h\"\n#include \"oplock.h\"\n#include \"misc.h\"\n#include <linux/sched/signal.h>\n#include <linux/workqueue.h>\n#include <linux/sysfs.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n\n#include \"server.h\"\n#include \"smb_common.h\"\n#include \"smbstatus.h\"\n#include \"connection.h\"\n#include \"transport_ipc.h\"\n#include \"mgmt/user_session.h\"\n#include \"crypto_ctx.h\"\n#include \"auth.h\"\n\nint ksmbd_debug_types;\n\nstruct ksmbd_server_config server_conf;\n\nenum SERVER_CTRL_TYPE {\n\tSERVER_CTRL_TYPE_INIT,\n\tSERVER_CTRL_TYPE_RESET,\n};\n\nstruct server_ctrl_struct {\n\tint\t\t\ttype;\n\tstruct work_struct\tctrl_work;\n};\n\nstatic DEFINE_MUTEX(ctrl_lock);\n\nstatic int ___server_conf_set(int idx, char *val)\n{\n\tif (idx >= ARRAY_SIZE(server_conf.conf))\n\t\treturn -EINVAL;\n\n\tif (!val || val[0] == 0x00)\n\t\treturn -EINVAL;\n\n\tkfree(server_conf.conf[idx]);\n\tserver_conf.conf[idx] = kstrdup(val, GFP_KERNEL);\n\tif (!server_conf.conf[idx])\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nint ksmbd_set_netbios_name(char *v)\n{\n\treturn ___server_conf_set(SERVER_CONF_NETBIOS_NAME, v);\n}\n\nint ksmbd_set_server_string(char *v)\n{\n\treturn ___server_conf_set(SERVER_CONF_SERVER_STRING, v);\n}\n\nint ksmbd_set_work_group(char *v)\n{\n\treturn ___server_conf_set(SERVER_CONF_WORK_GROUP, v);\n}\n\nchar *ksmbd_netbios_name(void)\n{\n\treturn server_conf.conf[SERVER_CONF_NETBIOS_NAME];\n}\n\nchar *ksmbd_server_string(void)\n{\n\treturn server_conf.conf[SERVER_CONF_SERVER_STRING];\n}\n\nchar *ksmbd_work_group(void)\n{\n\treturn server_conf.conf[SERVER_CONF_WORK_GROUP];\n}\n\n \nstatic inline int check_conn_state(struct ksmbd_work *work)\n{\n\tstruct smb_hdr *rsp_hdr;\n\n\tif (ksmbd_conn_exiting(work->conn) ||\n\t    ksmbd_conn_need_reconnect(work->conn)) {\n\t\trsp_hdr = work->response_buf;\n\t\trsp_hdr->Status.CifsError = STATUS_CONNECTION_DISCONNECTED;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n#define SERVER_HANDLER_CONTINUE\t\t0\n#define SERVER_HANDLER_ABORT\t\t1\n\nstatic int __process_request(struct ksmbd_work *work, struct ksmbd_conn *conn,\n\t\t\t     u16 *cmd)\n{\n\tstruct smb_version_cmds *cmds;\n\tu16 command;\n\tint ret;\n\n\tif (check_conn_state(work))\n\t\treturn SERVER_HANDLER_CONTINUE;\n\n\tif (ksmbd_verify_smb_message(work)) {\n\t\tconn->ops->set_rsp_status(work, STATUS_INVALID_PARAMETER);\n\t\treturn SERVER_HANDLER_ABORT;\n\t}\n\n\tcommand = conn->ops->get_cmd_val(work);\n\t*cmd = command;\n\nandx_again:\n\tif (command >= conn->max_cmds) {\n\t\tconn->ops->set_rsp_status(work, STATUS_INVALID_PARAMETER);\n\t\treturn SERVER_HANDLER_CONTINUE;\n\t}\n\n\tcmds = &conn->cmds[command];\n\tif (!cmds->proc) {\n\t\tksmbd_debug(SMB, \"*** not implemented yet cmd = %x\\n\", command);\n\t\tconn->ops->set_rsp_status(work, STATUS_NOT_IMPLEMENTED);\n\t\treturn SERVER_HANDLER_CONTINUE;\n\t}\n\n\tif (work->sess && conn->ops->is_sign_req(work, command)) {\n\t\tret = conn->ops->check_sign_req(work);\n\t\tif (!ret) {\n\t\t\tconn->ops->set_rsp_status(work, STATUS_ACCESS_DENIED);\n\t\t\treturn SERVER_HANDLER_CONTINUE;\n\t\t}\n\t}\n\n\tret = cmds->proc(work);\n\n\tif (ret < 0)\n\t\tksmbd_debug(CONN, \"Failed to process %u [%d]\\n\", command, ret);\n\t \n\telse if (ret > 0) {\n\t\tcommand = ret;\n\t\t*cmd = command;\n\t\tgoto andx_again;\n\t}\n\n\tif (work->send_no_response)\n\t\treturn SERVER_HANDLER_ABORT;\n\treturn SERVER_HANDLER_CONTINUE;\n}\n\nstatic void __handle_ksmbd_work(struct ksmbd_work *work,\n\t\t\t\tstruct ksmbd_conn *conn)\n{\n\tu16 command = 0;\n\tint rc;\n\tbool is_chained = false;\n\n\tif (conn->ops->allocate_rsp_buf(work))\n\t\treturn;\n\n\tif (conn->ops->is_transform_hdr &&\n\t    conn->ops->is_transform_hdr(work->request_buf)) {\n\t\trc = conn->ops->decrypt_req(work);\n\t\tif (rc < 0) {\n\t\t\tconn->ops->set_rsp_status(work, STATUS_DATA_ERROR);\n\t\t\tgoto send;\n\t\t}\n\n\t\twork->encrypted = true;\n\t}\n\n\trc = conn->ops->init_rsp_hdr(work);\n\tif (rc) {\n\t\t \n\t\tconn->ops->set_rsp_status(work, STATUS_INVALID_HANDLE);\n\t\tgoto send;\n\t}\n\n\tdo {\n\t\tif (conn->ops->check_user_session) {\n\t\t\trc = conn->ops->check_user_session(work);\n\t\t\tif (rc < 0) {\n\t\t\t\tif (rc == -EINVAL)\n\t\t\t\t\tconn->ops->set_rsp_status(work,\n\t\t\t\t\t\tSTATUS_INVALID_PARAMETER);\n\t\t\t\telse\n\t\t\t\t\tconn->ops->set_rsp_status(work,\n\t\t\t\t\t\tSTATUS_USER_SESSION_DELETED);\n\t\t\t\tgoto send;\n\t\t\t} else if (rc > 0) {\n\t\t\t\trc = conn->ops->get_ksmbd_tcon(work);\n\t\t\t\tif (rc < 0) {\n\t\t\t\t\tif (rc == -EINVAL)\n\t\t\t\t\t\tconn->ops->set_rsp_status(work,\n\t\t\t\t\t\t\tSTATUS_INVALID_PARAMETER);\n\t\t\t\t\telse\n\t\t\t\t\t\tconn->ops->set_rsp_status(work,\n\t\t\t\t\t\t\tSTATUS_NETWORK_NAME_DELETED);\n\t\t\t\t\tgoto send;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\trc = __process_request(work, conn, &command);\n\t\tif (rc == SERVER_HANDLER_ABORT)\n\t\t\tbreak;\n\n\t\t \n\t\tif (conn->ops->set_rsp_credits) {\n\t\t\tspin_lock(&conn->credits_lock);\n\t\t\trc = conn->ops->set_rsp_credits(work);\n\t\t\tspin_unlock(&conn->credits_lock);\n\t\t\tif (rc < 0) {\n\t\t\t\tconn->ops->set_rsp_status(work,\n\t\t\t\t\tSTATUS_INVALID_PARAMETER);\n\t\t\t\tgoto send;\n\t\t\t}\n\t\t}\n\n\t\tis_chained = is_chained_smb2_message(work);\n\n\t\tif (work->sess &&\n\t\t    (work->sess->sign || smb3_11_final_sess_setup_resp(work) ||\n\t\t     conn->ops->is_sign_req(work, command)))\n\t\t\tconn->ops->set_sign_rsp(work);\n\t} while (is_chained == true);\n\nsend:\n\tif (work->tcon)\n\t\tksmbd_tree_connect_put(work->tcon);\n\tsmb3_preauth_hash_rsp(work);\n\tif (work->sess && work->sess->enc && work->encrypted &&\n\t    conn->ops->encrypt_resp) {\n\t\trc = conn->ops->encrypt_resp(work);\n\t\tif (rc < 0)\n\t\t\tconn->ops->set_rsp_status(work, STATUS_DATA_ERROR);\n\t}\n\n\tksmbd_conn_write(work);\n}\n\n \nstatic void handle_ksmbd_work(struct work_struct *wk)\n{\n\tstruct ksmbd_work *work = container_of(wk, struct ksmbd_work, work);\n\tstruct ksmbd_conn *conn = work->conn;\n\n\tatomic64_inc(&conn->stats.request_served);\n\n\t__handle_ksmbd_work(work, conn);\n\n\tksmbd_conn_try_dequeue_request(work);\n\tksmbd_free_work_struct(work);\n\t \n\tif (!atomic_dec_return(&conn->r_count) && waitqueue_active(&conn->r_count_q))\n\t\twake_up(&conn->r_count_q);\n}\n\n \nstatic int queue_ksmbd_work(struct ksmbd_conn *conn)\n{\n\tstruct ksmbd_work *work;\n\tint err;\n\n\twork = ksmbd_alloc_work_struct();\n\tif (!work) {\n\t\tpr_err(\"allocation for work failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\twork->conn = conn;\n\twork->request_buf = conn->request_buf;\n\tconn->request_buf = NULL;\n\n\terr = ksmbd_init_smb_server(work);\n\tif (err) {\n\t\tksmbd_free_work_struct(work);\n\t\treturn 0;\n\t}\n\n\tksmbd_conn_enqueue_request(work);\n\tatomic_inc(&conn->r_count);\n\t \n\tconn->last_active = jiffies;\n\tINIT_WORK(&work->work, handle_ksmbd_work);\n\tksmbd_queue_work(work);\n\treturn 0;\n}\n\nstatic int ksmbd_server_process_request(struct ksmbd_conn *conn)\n{\n\treturn queue_ksmbd_work(conn);\n}\n\nstatic int ksmbd_server_terminate_conn(struct ksmbd_conn *conn)\n{\n\tksmbd_sessions_deregister(conn);\n\tdestroy_lease_table(conn);\n\treturn 0;\n}\n\nstatic void ksmbd_server_tcp_callbacks_init(void)\n{\n\tstruct ksmbd_conn_ops ops;\n\n\tops.process_fn = ksmbd_server_process_request;\n\tops.terminate_fn = ksmbd_server_terminate_conn;\n\n\tksmbd_conn_init_server_callbacks(&ops);\n}\n\nstatic void server_conf_free(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(server_conf.conf); i++) {\n\t\tkfree(server_conf.conf[i]);\n\t\tserver_conf.conf[i] = NULL;\n\t}\n}\n\nstatic int server_conf_init(void)\n{\n\tWRITE_ONCE(server_conf.state, SERVER_STATE_STARTING_UP);\n\tserver_conf.enforced_signing = 0;\n\tserver_conf.min_protocol = ksmbd_min_protocol();\n\tserver_conf.max_protocol = ksmbd_max_protocol();\n\tserver_conf.auth_mechs = KSMBD_AUTH_NTLMSSP;\n#ifdef CONFIG_SMB_SERVER_KERBEROS5\n\tserver_conf.auth_mechs |= KSMBD_AUTH_KRB5 |\n\t\t\t\tKSMBD_AUTH_MSKRB5;\n#endif\n\treturn 0;\n}\n\nstatic void server_ctrl_handle_init(struct server_ctrl_struct *ctrl)\n{\n\tint ret;\n\n\tret = ksmbd_conn_transport_init();\n\tif (ret) {\n\t\tserver_queue_ctrl_reset_work();\n\t\treturn;\n\t}\n\n\tWRITE_ONCE(server_conf.state, SERVER_STATE_RUNNING);\n}\n\nstatic void server_ctrl_handle_reset(struct server_ctrl_struct *ctrl)\n{\n\tksmbd_ipc_soft_reset();\n\tksmbd_conn_transport_destroy();\n\tserver_conf_free();\n\tserver_conf_init();\n\tWRITE_ONCE(server_conf.state, SERVER_STATE_STARTING_UP);\n}\n\nstatic void server_ctrl_handle_work(struct work_struct *work)\n{\n\tstruct server_ctrl_struct *ctrl;\n\n\tctrl = container_of(work, struct server_ctrl_struct, ctrl_work);\n\n\tmutex_lock(&ctrl_lock);\n\tswitch (ctrl->type) {\n\tcase SERVER_CTRL_TYPE_INIT:\n\t\tserver_ctrl_handle_init(ctrl);\n\t\tbreak;\n\tcase SERVER_CTRL_TYPE_RESET:\n\t\tserver_ctrl_handle_reset(ctrl);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Unknown server work type: %d\\n\", ctrl->type);\n\t}\n\tmutex_unlock(&ctrl_lock);\n\tkfree(ctrl);\n\tmodule_put(THIS_MODULE);\n}\n\nstatic int __queue_ctrl_work(int type)\n{\n\tstruct server_ctrl_struct *ctrl;\n\n\tctrl = kmalloc(sizeof(struct server_ctrl_struct), GFP_KERNEL);\n\tif (!ctrl)\n\t\treturn -ENOMEM;\n\n\t__module_get(THIS_MODULE);\n\tctrl->type = type;\n\tINIT_WORK(&ctrl->ctrl_work, server_ctrl_handle_work);\n\tqueue_work(system_long_wq, &ctrl->ctrl_work);\n\treturn 0;\n}\n\nint server_queue_ctrl_init_work(void)\n{\n\treturn __queue_ctrl_work(SERVER_CTRL_TYPE_INIT);\n}\n\nint server_queue_ctrl_reset_work(void)\n{\n\treturn __queue_ctrl_work(SERVER_CTRL_TYPE_RESET);\n}\n\nstatic ssize_t stats_show(const struct class *class, const struct class_attribute *attr,\n\t\t\t  char *buf)\n{\n\t \n\tstatic int stats_version = 2;\n\tstatic const char * const state[] = {\n\t\t\"startup\",\n\t\t\"running\",\n\t\t\"reset\",\n\t\t\"shutdown\"\n\t};\n\treturn sysfs_emit(buf, \"%d %s %d %lu\\n\", stats_version,\n\t\t\t  state[server_conf.state], server_conf.tcp_port,\n\t\t\t  server_conf.ipc_last_active / HZ);\n}\n\nstatic ssize_t kill_server_store(const struct class *class,\n\t\t\t\t const struct class_attribute *attr, const char *buf,\n\t\t\t\t size_t len)\n{\n\tif (!sysfs_streq(buf, \"hard\"))\n\t\treturn len;\n\n\tpr_info(\"kill command received\\n\");\n\tmutex_lock(&ctrl_lock);\n\tWRITE_ONCE(server_conf.state, SERVER_STATE_RESETTING);\n\t__module_get(THIS_MODULE);\n\tserver_ctrl_handle_reset(NULL);\n\tmodule_put(THIS_MODULE);\n\tmutex_unlock(&ctrl_lock);\n\treturn len;\n}\n\nstatic const char * const debug_type_strings[] = {\"smb\", \"auth\", \"vfs\",\n\t\t\t\t\t\t  \"oplock\", \"ipc\", \"conn\",\n\t\t\t\t\t\t  \"rdma\"};\n\nstatic ssize_t debug_show(const struct class *class, const struct class_attribute *attr,\n\t\t\t  char *buf)\n{\n\tssize_t sz = 0;\n\tint i, pos = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(debug_type_strings); i++) {\n\t\tif ((ksmbd_debug_types >> i) & 1) {\n\t\t\tpos = sysfs_emit_at(buf, sz, \"[%s] \", debug_type_strings[i]);\n\t\t} else {\n\t\t\tpos = sysfs_emit_at(buf, sz, \"%s \", debug_type_strings[i]);\n\t\t}\n\t\tsz += pos;\n\t}\n\tsz += sysfs_emit_at(buf, sz, \"\\n\");\n\treturn sz;\n}\n\nstatic ssize_t debug_store(const struct class *class, const struct class_attribute *attr,\n\t\t\t   const char *buf, size_t len)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(debug_type_strings); i++) {\n\t\tif (sysfs_streq(buf, \"all\")) {\n\t\t\tif (ksmbd_debug_types == KSMBD_DEBUG_ALL)\n\t\t\t\tksmbd_debug_types = 0;\n\t\t\telse\n\t\t\t\tksmbd_debug_types = KSMBD_DEBUG_ALL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (sysfs_streq(buf, debug_type_strings[i])) {\n\t\t\tif (ksmbd_debug_types & (1 << i))\n\t\t\t\tksmbd_debug_types &= ~(1 << i);\n\t\t\telse\n\t\t\t\tksmbd_debug_types |= (1 << i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn len;\n}\n\nstatic CLASS_ATTR_RO(stats);\nstatic CLASS_ATTR_WO(kill_server);\nstatic CLASS_ATTR_RW(debug);\n\nstatic struct attribute *ksmbd_control_class_attrs[] = {\n\t&class_attr_stats.attr,\n\t&class_attr_kill_server.attr,\n\t&class_attr_debug.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(ksmbd_control_class);\n\nstatic struct class ksmbd_control_class = {\n\t.name\t\t= \"ksmbd-control\",\n\t.class_groups\t= ksmbd_control_class_groups,\n};\n\nstatic int ksmbd_server_shutdown(void)\n{\n\tWRITE_ONCE(server_conf.state, SERVER_STATE_SHUTTING_DOWN);\n\n\tclass_unregister(&ksmbd_control_class);\n\tksmbd_workqueue_destroy();\n\tksmbd_ipc_release();\n\tksmbd_conn_transport_destroy();\n\tksmbd_crypto_destroy();\n\tksmbd_free_global_file_table();\n\tdestroy_lease_table(NULL);\n\tksmbd_work_pool_destroy();\n\tksmbd_exit_file_cache();\n\tserver_conf_free();\n\treturn 0;\n}\n\nstatic int __init ksmbd_server_init(void)\n{\n\tint ret;\n\n\tret = class_register(&ksmbd_control_class);\n\tif (ret) {\n\t\tpr_err(\"Unable to register ksmbd-control class\\n\");\n\t\treturn ret;\n\t}\n\n\tksmbd_server_tcp_callbacks_init();\n\n\tret = server_conf_init();\n\tif (ret)\n\t\tgoto err_unregister;\n\n\tret = ksmbd_work_pool_init();\n\tif (ret)\n\t\tgoto err_unregister;\n\n\tret = ksmbd_init_file_cache();\n\tif (ret)\n\t\tgoto err_destroy_work_pools;\n\n\tret = ksmbd_ipc_init();\n\tif (ret)\n\t\tgoto err_exit_file_cache;\n\n\tret = ksmbd_init_global_file_table();\n\tif (ret)\n\t\tgoto err_ipc_release;\n\n\tret = ksmbd_inode_hash_init();\n\tif (ret)\n\t\tgoto err_destroy_file_table;\n\n\tret = ksmbd_crypto_create();\n\tif (ret)\n\t\tgoto err_release_inode_hash;\n\n\tret = ksmbd_workqueue_init();\n\tif (ret)\n\t\tgoto err_crypto_destroy;\n\n\treturn 0;\n\nerr_crypto_destroy:\n\tksmbd_crypto_destroy();\nerr_release_inode_hash:\n\tksmbd_release_inode_hash();\nerr_destroy_file_table:\n\tksmbd_free_global_file_table();\nerr_ipc_release:\n\tksmbd_ipc_release();\nerr_exit_file_cache:\n\tksmbd_exit_file_cache();\nerr_destroy_work_pools:\n\tksmbd_work_pool_destroy();\nerr_unregister:\n\tclass_unregister(&ksmbd_control_class);\n\n\treturn ret;\n}\n\n \nstatic void __exit ksmbd_server_exit(void)\n{\n\tksmbd_server_shutdown();\n\trcu_barrier();\n\tksmbd_release_inode_hash();\n}\n\nMODULE_AUTHOR(\"Namjae Jeon <linkinjeon@kernel.org>\");\nMODULE_VERSION(KSMBD_VERSION);\nMODULE_DESCRIPTION(\"Linux kernel CIFS/SMB SERVER\");\nMODULE_LICENSE(\"GPL\");\nMODULE_SOFTDEP(\"pre: ecb\");\nMODULE_SOFTDEP(\"pre: hmac\");\nMODULE_SOFTDEP(\"pre: md5\");\nMODULE_SOFTDEP(\"pre: nls\");\nMODULE_SOFTDEP(\"pre: aes\");\nMODULE_SOFTDEP(\"pre: cmac\");\nMODULE_SOFTDEP(\"pre: sha256\");\nMODULE_SOFTDEP(\"pre: sha512\");\nMODULE_SOFTDEP(\"pre: aead2\");\nMODULE_SOFTDEP(\"pre: ccm\");\nMODULE_SOFTDEP(\"pre: gcm\");\nMODULE_SOFTDEP(\"pre: crc32\");\nmodule_init(ksmbd_server_init)\nmodule_exit(ksmbd_server_exit)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}