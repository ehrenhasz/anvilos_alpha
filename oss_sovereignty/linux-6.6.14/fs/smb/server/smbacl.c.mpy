{
  "module_name": "smbacl.c",
  "hash_id": "79dae0d4b7d39888066331ee9a8cf81a8ac46f423111f5da3da21b0bc23b64d1",
  "original_prompt": "Ingested from linux-6.6.14/fs/smb/server/smbacl.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/mnt_idmapping.h>\n\n#include \"smbacl.h\"\n#include \"smb_common.h\"\n#include \"server.h\"\n#include \"misc.h\"\n#include \"mgmt/share_config.h\"\n\nstatic const struct smb_sid domain = {1, 4, {0, 0, 0, 0, 0, 5},\n\t{cpu_to_le32(21), cpu_to_le32(1), cpu_to_le32(2), cpu_to_le32(3),\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} };\n\n \nstatic const struct smb_sid creator_owner = {\n\t1, 1, {0, 0, 0, 0, 0, 3}, {0} };\n \nstatic const struct smb_sid creator_group = {\n\t1, 1, {0, 0, 0, 0, 0, 3}, {cpu_to_le32(1)} };\n\n \nstatic const struct smb_sid sid_everyone = {\n\t1, 1, {0, 0, 0, 0, 0, 1}, {0} };\n \nstatic const struct smb_sid sid_authusers = {\n\t1, 1, {0, 0, 0, 0, 0, 5}, {cpu_to_le32(11)} };\n\n \nstatic const struct smb_sid sid_unix_users = {1, 1, {0, 0, 0, 0, 0, 22},\n\t\t{cpu_to_le32(1), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} };\n\n \nstatic const struct smb_sid sid_unix_groups = { 1, 1, {0, 0, 0, 0, 0, 22},\n\t\t{cpu_to_le32(2), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} };\n\n \n\n \n\n \nstatic const struct smb_sid sid_unix_NFS_users = { 1, 2, {0, 0, 0, 0, 0, 5},\n\t{cpu_to_le32(88),\n\t cpu_to_le32(1), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} };\n\n \nstatic const struct smb_sid sid_unix_NFS_groups = { 1, 2, {0, 0, 0, 0, 0, 5},\n\t{cpu_to_le32(88),\n\t cpu_to_le32(2), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} };\n\n \nstatic const struct smb_sid sid_unix_NFS_mode = { 1, 2, {0, 0, 0, 0, 0, 5},\n\t{cpu_to_le32(88),\n\t cpu_to_le32(3), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} };\n\n \nint compare_sids(const struct smb_sid *ctsid, const struct smb_sid *cwsid)\n{\n\tint i;\n\tint num_subauth, num_sat, num_saw;\n\n\tif (!ctsid || !cwsid)\n\t\treturn 1;\n\n\t \n\tif (ctsid->revision != cwsid->revision) {\n\t\tif (ctsid->revision > cwsid->revision)\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn -1;\n\t}\n\n\t \n\tfor (i = 0; i < NUM_AUTHS; ++i) {\n\t\tif (ctsid->authority[i] != cwsid->authority[i]) {\n\t\t\tif (ctsid->authority[i] > cwsid->authority[i])\n\t\t\t\treturn 1;\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\t \n\tnum_sat = ctsid->num_subauth;\n\tnum_saw = cwsid->num_subauth;\n\tnum_subauth = min(num_sat, num_saw);\n\tif (num_subauth) {\n\t\tfor (i = 0; i < num_subauth; ++i) {\n\t\t\tif (ctsid->sub_auth[i] != cwsid->sub_auth[i]) {\n\t\t\t\tif (le32_to_cpu(ctsid->sub_auth[i]) >\n\t\t\t\t    le32_to_cpu(cwsid->sub_auth[i]))\n\t\t\t\t\treturn 1;\n\t\t\t\telse\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;  \n}\n\nstatic void smb_copy_sid(struct smb_sid *dst, const struct smb_sid *src)\n{\n\tint i;\n\n\tdst->revision = src->revision;\n\tdst->num_subauth = min_t(u8, src->num_subauth, SID_MAX_SUB_AUTHORITIES);\n\tfor (i = 0; i < NUM_AUTHS; ++i)\n\t\tdst->authority[i] = src->authority[i];\n\tfor (i = 0; i < dst->num_subauth; ++i)\n\t\tdst->sub_auth[i] = src->sub_auth[i];\n}\n\n \nstatic umode_t access_flags_to_mode(struct smb_fattr *fattr, __le32 ace_flags,\n\t\t\t\t    int type)\n{\n\t__u32 flags = le32_to_cpu(ace_flags);\n\tumode_t mode = 0;\n\n\tif (flags & GENERIC_ALL) {\n\t\tmode = 0777;\n\t\tksmbd_debug(SMB, \"all perms\\n\");\n\t\treturn mode;\n\t}\n\n\tif ((flags & GENERIC_READ) || (flags & FILE_READ_RIGHTS))\n\t\tmode = 0444;\n\tif ((flags & GENERIC_WRITE) || (flags & FILE_WRITE_RIGHTS)) {\n\t\tmode |= 0222;\n\t\tif (S_ISDIR(fattr->cf_mode))\n\t\t\tmode |= 0111;\n\t}\n\tif ((flags & GENERIC_EXECUTE) || (flags & FILE_EXEC_RIGHTS))\n\t\tmode |= 0111;\n\n\tif (type == ACCESS_DENIED_ACE_TYPE || type == ACCESS_DENIED_OBJECT_ACE_TYPE)\n\t\tmode = ~mode;\n\n\tksmbd_debug(SMB, \"access flags 0x%x mode now %04o\\n\", flags, mode);\n\n\treturn mode;\n}\n\n \nstatic void mode_to_access_flags(umode_t mode, umode_t bits_to_use,\n\t\t\t\t __u32 *pace_flags)\n{\n\t \n\t*pace_flags = 0x0;\n\n\t \n\tmode &= bits_to_use;\n\n\t \n\tif (mode & 0444)\n\t\t*pace_flags |= SET_FILE_READ_RIGHTS;\n\tif (mode & 0222)\n\t\t*pace_flags |= FILE_WRITE_RIGHTS;\n\tif (mode & 0111)\n\t\t*pace_flags |= SET_FILE_EXEC_RIGHTS;\n\n\tksmbd_debug(SMB, \"mode: %o, access flags now 0x%x\\n\",\n\t\t    mode, *pace_flags);\n}\n\nstatic __u16 fill_ace_for_sid(struct smb_ace *pntace,\n\t\t\t      const struct smb_sid *psid, int type, int flags,\n\t\t\t      umode_t mode, umode_t bits)\n{\n\tint i;\n\t__u16 size = 0;\n\t__u32 access_req = 0;\n\n\tpntace->type = type;\n\tpntace->flags = flags;\n\tmode_to_access_flags(mode, bits, &access_req);\n\tif (!access_req)\n\t\taccess_req = SET_MINIMUM_RIGHTS;\n\tpntace->access_req = cpu_to_le32(access_req);\n\n\tpntace->sid.revision = psid->revision;\n\tpntace->sid.num_subauth = psid->num_subauth;\n\tfor (i = 0; i < NUM_AUTHS; i++)\n\t\tpntace->sid.authority[i] = psid->authority[i];\n\tfor (i = 0; i < psid->num_subauth; i++)\n\t\tpntace->sid.sub_auth[i] = psid->sub_auth[i];\n\n\tsize = 1 + 1 + 2 + 4 + 1 + 1 + 6 + (psid->num_subauth * 4);\n\tpntace->size = cpu_to_le16(size);\n\n\treturn size;\n}\n\nvoid id_to_sid(unsigned int cid, uint sidtype, struct smb_sid *ssid)\n{\n\tswitch (sidtype) {\n\tcase SIDOWNER:\n\t\tsmb_copy_sid(ssid, &server_conf.domain_sid);\n\t\tbreak;\n\tcase SIDUNIX_USER:\n\t\tsmb_copy_sid(ssid, &sid_unix_users);\n\t\tbreak;\n\tcase SIDUNIX_GROUP:\n\t\tsmb_copy_sid(ssid, &sid_unix_groups);\n\t\tbreak;\n\tcase SIDCREATOR_OWNER:\n\t\tsmb_copy_sid(ssid, &creator_owner);\n\t\treturn;\n\tcase SIDCREATOR_GROUP:\n\t\tsmb_copy_sid(ssid, &creator_group);\n\t\treturn;\n\tcase SIDNFS_USER:\n\t\tsmb_copy_sid(ssid, &sid_unix_NFS_users);\n\t\tbreak;\n\tcase SIDNFS_GROUP:\n\t\tsmb_copy_sid(ssid, &sid_unix_NFS_groups);\n\t\tbreak;\n\tcase SIDNFS_MODE:\n\t\tsmb_copy_sid(ssid, &sid_unix_NFS_mode);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\t \n\tssid->sub_auth[ssid->num_subauth] = cpu_to_le32(cid);\n\tssid->num_subauth++;\n}\n\nstatic int sid_to_id(struct mnt_idmap *idmap,\n\t\t     struct smb_sid *psid, uint sidtype,\n\t\t     struct smb_fattr *fattr)\n{\n\tint rc = -EINVAL;\n\n\t \n\tif (unlikely(psid->num_subauth > SID_MAX_SUB_AUTHORITIES)) {\n\t\tpr_err(\"%s: %u subauthorities is too many!\\n\",\n\t\t       __func__, psid->num_subauth);\n\t\treturn -EIO;\n\t}\n\n\tif (sidtype == SIDOWNER) {\n\t\tkuid_t uid;\n\t\tuid_t id;\n\n\t\tid = le32_to_cpu(psid->sub_auth[psid->num_subauth - 1]);\n\t\tuid = KUIDT_INIT(id);\n\t\tuid = from_vfsuid(idmap, &init_user_ns, VFSUIDT_INIT(uid));\n\t\tif (uid_valid(uid)) {\n\t\t\tfattr->cf_uid = uid;\n\t\t\trc = 0;\n\t\t}\n\t} else {\n\t\tkgid_t gid;\n\t\tgid_t id;\n\n\t\tid = le32_to_cpu(psid->sub_auth[psid->num_subauth - 1]);\n\t\tgid = KGIDT_INIT(id);\n\t\tgid = from_vfsgid(idmap, &init_user_ns, VFSGIDT_INIT(gid));\n\t\tif (gid_valid(gid)) {\n\t\t\tfattr->cf_gid = gid;\n\t\t\trc = 0;\n\t\t}\n\t}\n\n\treturn rc;\n}\n\nvoid posix_state_to_acl(struct posix_acl_state *state,\n\t\t\tstruct posix_acl_entry *pace)\n{\n\tint i;\n\n\tpace->e_tag = ACL_USER_OBJ;\n\tpace->e_perm = state->owner.allow;\n\tfor (i = 0; i < state->users->n; i++) {\n\t\tpace++;\n\t\tpace->e_tag = ACL_USER;\n\t\tpace->e_uid = state->users->aces[i].uid;\n\t\tpace->e_perm = state->users->aces[i].perms.allow;\n\t}\n\n\tpace++;\n\tpace->e_tag = ACL_GROUP_OBJ;\n\tpace->e_perm = state->group.allow;\n\n\tfor (i = 0; i < state->groups->n; i++) {\n\t\tpace++;\n\t\tpace->e_tag = ACL_GROUP;\n\t\tpace->e_gid = state->groups->aces[i].gid;\n\t\tpace->e_perm = state->groups->aces[i].perms.allow;\n\t}\n\n\tif (state->users->n || state->groups->n) {\n\t\tpace++;\n\t\tpace->e_tag = ACL_MASK;\n\t\tpace->e_perm = state->mask.allow;\n\t}\n\n\tpace++;\n\tpace->e_tag = ACL_OTHER;\n\tpace->e_perm = state->other.allow;\n}\n\nint init_acl_state(struct posix_acl_state *state, int cnt)\n{\n\tint alloc;\n\n\tmemset(state, 0, sizeof(struct posix_acl_state));\n\t \n\talloc = sizeof(struct posix_ace_state_array)\n\t\t+ cnt * sizeof(struct posix_user_ace_state);\n\tstate->users = kzalloc(alloc, GFP_KERNEL);\n\tif (!state->users)\n\t\treturn -ENOMEM;\n\tstate->groups = kzalloc(alloc, GFP_KERNEL);\n\tif (!state->groups) {\n\t\tkfree(state->users);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nvoid free_acl_state(struct posix_acl_state *state)\n{\n\tkfree(state->users);\n\tkfree(state->groups);\n}\n\nstatic void parse_dacl(struct mnt_idmap *idmap,\n\t\t       struct smb_acl *pdacl, char *end_of_acl,\n\t\t       struct smb_sid *pownersid, struct smb_sid *pgrpsid,\n\t\t       struct smb_fattr *fattr)\n{\n\tint i, ret;\n\tint num_aces = 0;\n\tunsigned int acl_size;\n\tchar *acl_base;\n\tstruct smb_ace **ppace;\n\tstruct posix_acl_entry *cf_pace, *cf_pdace;\n\tstruct posix_acl_state acl_state, default_acl_state;\n\tumode_t mode = 0, acl_mode;\n\tbool owner_found = false, group_found = false, others_found = false;\n\n\tif (!pdacl)\n\t\treturn;\n\n\t \n\tif (end_of_acl < (char *)pdacl + sizeof(struct smb_acl) ||\n\t    end_of_acl < (char *)pdacl + le16_to_cpu(pdacl->size)) {\n\t\tpr_err(\"ACL too small to parse DACL\\n\");\n\t\treturn;\n\t}\n\n\tksmbd_debug(SMB, \"DACL revision %d size %d num aces %d\\n\",\n\t\t    le16_to_cpu(pdacl->revision), le16_to_cpu(pdacl->size),\n\t\t    le32_to_cpu(pdacl->num_aces));\n\n\tacl_base = (char *)pdacl;\n\tacl_size = sizeof(struct smb_acl);\n\n\tnum_aces = le32_to_cpu(pdacl->num_aces);\n\tif (num_aces <= 0)\n\t\treturn;\n\n\tif (num_aces > ULONG_MAX / sizeof(struct smb_ace *))\n\t\treturn;\n\n\tret = init_acl_state(&acl_state, num_aces);\n\tif (ret)\n\t\treturn;\n\tret = init_acl_state(&default_acl_state, num_aces);\n\tif (ret) {\n\t\tfree_acl_state(&acl_state);\n\t\treturn;\n\t}\n\n\tppace = kmalloc_array(num_aces, sizeof(struct smb_ace *), GFP_KERNEL);\n\tif (!ppace) {\n\t\tfree_acl_state(&default_acl_state);\n\t\tfree_acl_state(&acl_state);\n\t\treturn;\n\t}\n\n\t \n\tfor (i = 0; i < num_aces; ++i) {\n\t\tif (end_of_acl - acl_base < acl_size)\n\t\t\tbreak;\n\n\t\tppace[i] = (struct smb_ace *)(acl_base + acl_size);\n\t\tacl_base = (char *)ppace[i];\n\t\tacl_size = offsetof(struct smb_ace, sid) +\n\t\t\toffsetof(struct smb_sid, sub_auth);\n\n\t\tif (end_of_acl - acl_base < acl_size ||\n\t\t    ppace[i]->sid.num_subauth > SID_MAX_SUB_AUTHORITIES ||\n\t\t    (end_of_acl - acl_base <\n\t\t     acl_size + sizeof(__le32) * ppace[i]->sid.num_subauth) ||\n\t\t    (le16_to_cpu(ppace[i]->size) <\n\t\t     acl_size + sizeof(__le32) * ppace[i]->sid.num_subauth))\n\t\t\tbreak;\n\n\t\tacl_size = le16_to_cpu(ppace[i]->size);\n\t\tppace[i]->access_req =\n\t\t\tsmb_map_generic_desired_access(ppace[i]->access_req);\n\n\t\tif (!(compare_sids(&ppace[i]->sid, &sid_unix_NFS_mode))) {\n\t\t\tfattr->cf_mode =\n\t\t\t\tle32_to_cpu(ppace[i]->sid.sub_auth[2]);\n\t\t\tbreak;\n\t\t} else if (!compare_sids(&ppace[i]->sid, pownersid)) {\n\t\t\tacl_mode = access_flags_to_mode(fattr,\n\t\t\t\t\t\t\tppace[i]->access_req,\n\t\t\t\t\t\t\tppace[i]->type);\n\t\t\tacl_mode &= 0700;\n\n\t\t\tif (!owner_found) {\n\t\t\t\tmode &= ~(0700);\n\t\t\t\tmode |= acl_mode;\n\t\t\t}\n\t\t\towner_found = true;\n\t\t} else if (!compare_sids(&ppace[i]->sid, pgrpsid) ||\n\t\t\t   ppace[i]->sid.sub_auth[ppace[i]->sid.num_subauth - 1] ==\n\t\t\t    DOMAIN_USER_RID_LE) {\n\t\t\tacl_mode = access_flags_to_mode(fattr,\n\t\t\t\t\t\t\tppace[i]->access_req,\n\t\t\t\t\t\t\tppace[i]->type);\n\t\t\tacl_mode &= 0070;\n\t\t\tif (!group_found) {\n\t\t\t\tmode &= ~(0070);\n\t\t\t\tmode |= acl_mode;\n\t\t\t}\n\t\t\tgroup_found = true;\n\t\t} else if (!compare_sids(&ppace[i]->sid, &sid_everyone)) {\n\t\t\tacl_mode = access_flags_to_mode(fattr,\n\t\t\t\t\t\t\tppace[i]->access_req,\n\t\t\t\t\t\t\tppace[i]->type);\n\t\t\tacl_mode &= 0007;\n\t\t\tif (!others_found) {\n\t\t\t\tmode &= ~(0007);\n\t\t\t\tmode |= acl_mode;\n\t\t\t}\n\t\t\tothers_found = true;\n\t\t} else if (!compare_sids(&ppace[i]->sid, &creator_owner)) {\n\t\t\tcontinue;\n\t\t} else if (!compare_sids(&ppace[i]->sid, &creator_group)) {\n\t\t\tcontinue;\n\t\t} else if (!compare_sids(&ppace[i]->sid, &sid_authusers)) {\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tstruct smb_fattr temp_fattr;\n\n\t\t\tacl_mode = access_flags_to_mode(fattr, ppace[i]->access_req,\n\t\t\t\t\t\t\tppace[i]->type);\n\t\t\ttemp_fattr.cf_uid = INVALID_UID;\n\t\t\tret = sid_to_id(idmap, &ppace[i]->sid, SIDOWNER, &temp_fattr);\n\t\t\tif (ret || uid_eq(temp_fattr.cf_uid, INVALID_UID)) {\n\t\t\t\tpr_err(\"%s: Error %d mapping Owner SID to uid\\n\",\n\t\t\t\t       __func__, ret);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tacl_state.owner.allow = ((acl_mode & 0700) >> 6) | 0004;\n\t\t\tacl_state.users->aces[acl_state.users->n].uid =\n\t\t\t\ttemp_fattr.cf_uid;\n\t\t\tacl_state.users->aces[acl_state.users->n++].perms.allow =\n\t\t\t\t((acl_mode & 0700) >> 6) | 0004;\n\t\t\tdefault_acl_state.owner.allow = ((acl_mode & 0700) >> 6) | 0004;\n\t\t\tdefault_acl_state.users->aces[default_acl_state.users->n].uid =\n\t\t\t\ttemp_fattr.cf_uid;\n\t\t\tdefault_acl_state.users->aces[default_acl_state.users->n++].perms.allow =\n\t\t\t\t((acl_mode & 0700) >> 6) | 0004;\n\t\t}\n\t}\n\tkfree(ppace);\n\n\tif (owner_found) {\n\t\t \n\t\tacl_state.owner.allow = ((mode & 0700) >> 6) | 0004;\n\t\tacl_state.users->aces[acl_state.users->n].uid = fattr->cf_uid;\n\t\tacl_state.users->aces[acl_state.users->n++].perms.allow =\n\t\t\t((mode & 0700) >> 6) | 0004;\n\t\tdefault_acl_state.owner.allow = ((mode & 0700) >> 6) | 0004;\n\t\tdefault_acl_state.users->aces[default_acl_state.users->n].uid =\n\t\t\tfattr->cf_uid;\n\t\tdefault_acl_state.users->aces[default_acl_state.users->n++].perms.allow =\n\t\t\t((mode & 0700) >> 6) | 0004;\n\t}\n\n\tif (group_found) {\n\t\tacl_state.group.allow = (mode & 0070) >> 3;\n\t\tacl_state.groups->aces[acl_state.groups->n].gid =\n\t\t\tfattr->cf_gid;\n\t\tacl_state.groups->aces[acl_state.groups->n++].perms.allow =\n\t\t\t(mode & 0070) >> 3;\n\t\tdefault_acl_state.group.allow = (mode & 0070) >> 3;\n\t\tdefault_acl_state.groups->aces[default_acl_state.groups->n].gid =\n\t\t\tfattr->cf_gid;\n\t\tdefault_acl_state.groups->aces[default_acl_state.groups->n++].perms.allow =\n\t\t\t(mode & 0070) >> 3;\n\t}\n\n\tif (others_found) {\n\t\tfattr->cf_mode &= ~(0007);\n\t\tfattr->cf_mode |= mode & 0007;\n\n\t\tacl_state.other.allow = mode & 0007;\n\t\tdefault_acl_state.other.allow = mode & 0007;\n\t}\n\n\tif (acl_state.users->n || acl_state.groups->n) {\n\t\tacl_state.mask.allow = 0x07;\n\n\t\tif (IS_ENABLED(CONFIG_FS_POSIX_ACL)) {\n\t\t\tfattr->cf_acls =\n\t\t\t\tposix_acl_alloc(acl_state.users->n +\n\t\t\t\t\tacl_state.groups->n + 4, GFP_KERNEL);\n\t\t\tif (fattr->cf_acls) {\n\t\t\t\tcf_pace = fattr->cf_acls->a_entries;\n\t\t\t\tposix_state_to_acl(&acl_state, cf_pace);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (default_acl_state.users->n || default_acl_state.groups->n) {\n\t\tdefault_acl_state.mask.allow = 0x07;\n\n\t\tif (IS_ENABLED(CONFIG_FS_POSIX_ACL)) {\n\t\t\tfattr->cf_dacls =\n\t\t\t\tposix_acl_alloc(default_acl_state.users->n +\n\t\t\t\tdefault_acl_state.groups->n + 4, GFP_KERNEL);\n\t\t\tif (fattr->cf_dacls) {\n\t\t\t\tcf_pdace = fattr->cf_dacls->a_entries;\n\t\t\t\tposix_state_to_acl(&default_acl_state, cf_pdace);\n\t\t\t}\n\t\t}\n\t}\n\tfree_acl_state(&acl_state);\n\tfree_acl_state(&default_acl_state);\n}\n\nstatic void set_posix_acl_entries_dacl(struct mnt_idmap *idmap,\n\t\t\t\t       struct smb_ace *pndace,\n\t\t\t\t       struct smb_fattr *fattr, u32 *num_aces,\n\t\t\t\t       u16 *size, u32 nt_aces_num)\n{\n\tstruct posix_acl_entry *pace;\n\tstruct smb_sid *sid;\n\tstruct smb_ace *ntace;\n\tint i, j;\n\n\tif (!fattr->cf_acls)\n\t\tgoto posix_default_acl;\n\n\tpace = fattr->cf_acls->a_entries;\n\tfor (i = 0; i < fattr->cf_acls->a_count; i++, pace++) {\n\t\tint flags = 0;\n\n\t\tsid = kmalloc(sizeof(struct smb_sid), GFP_KERNEL);\n\t\tif (!sid)\n\t\t\tbreak;\n\n\t\tif (pace->e_tag == ACL_USER) {\n\t\t\tuid_t uid;\n\t\t\tunsigned int sid_type = SIDOWNER;\n\n\t\t\tuid = posix_acl_uid_translate(idmap, pace);\n\t\t\tif (!uid)\n\t\t\t\tsid_type = SIDUNIX_USER;\n\t\t\tid_to_sid(uid, sid_type, sid);\n\t\t} else if (pace->e_tag == ACL_GROUP) {\n\t\t\tgid_t gid;\n\n\t\t\tgid = posix_acl_gid_translate(idmap, pace);\n\t\t\tid_to_sid(gid, SIDUNIX_GROUP, sid);\n\t\t} else if (pace->e_tag == ACL_OTHER && !nt_aces_num) {\n\t\t\tsmb_copy_sid(sid, &sid_everyone);\n\t\t} else {\n\t\t\tkfree(sid);\n\t\t\tcontinue;\n\t\t}\n\t\tntace = pndace;\n\t\tfor (j = 0; j < nt_aces_num; j++) {\n\t\t\tif (ntace->sid.sub_auth[ntace->sid.num_subauth - 1] ==\n\t\t\t\t\tsid->sub_auth[sid->num_subauth - 1])\n\t\t\t\tgoto pass_same_sid;\n\t\t\tntace = (struct smb_ace *)((char *)ntace +\n\t\t\t\t\tle16_to_cpu(ntace->size));\n\t\t}\n\n\t\tif (S_ISDIR(fattr->cf_mode) && pace->e_tag == ACL_OTHER)\n\t\t\tflags = 0x03;\n\n\t\tntace = (struct smb_ace *)((char *)pndace + *size);\n\t\t*size += fill_ace_for_sid(ntace, sid, ACCESS_ALLOWED, flags,\n\t\t\t\tpace->e_perm, 0777);\n\t\t(*num_aces)++;\n\t\tif (pace->e_tag == ACL_USER)\n\t\t\tntace->access_req |=\n\t\t\t\tFILE_DELETE_LE | FILE_DELETE_CHILD_LE;\n\n\t\tif (S_ISDIR(fattr->cf_mode) &&\n\t\t    (pace->e_tag == ACL_USER || pace->e_tag == ACL_GROUP)) {\n\t\t\tntace = (struct smb_ace *)((char *)pndace + *size);\n\t\t\t*size += fill_ace_for_sid(ntace, sid, ACCESS_ALLOWED,\n\t\t\t\t\t0x03, pace->e_perm, 0777);\n\t\t\t(*num_aces)++;\n\t\t\tif (pace->e_tag == ACL_USER)\n\t\t\t\tntace->access_req |=\n\t\t\t\t\tFILE_DELETE_LE | FILE_DELETE_CHILD_LE;\n\t\t}\n\npass_same_sid:\n\t\tkfree(sid);\n\t}\n\n\tif (nt_aces_num)\n\t\treturn;\n\nposix_default_acl:\n\tif (!fattr->cf_dacls)\n\t\treturn;\n\n\tpace = fattr->cf_dacls->a_entries;\n\tfor (i = 0; i < fattr->cf_dacls->a_count; i++, pace++) {\n\t\tsid = kmalloc(sizeof(struct smb_sid), GFP_KERNEL);\n\t\tif (!sid)\n\t\t\tbreak;\n\n\t\tif (pace->e_tag == ACL_USER) {\n\t\t\tuid_t uid;\n\n\t\t\tuid = posix_acl_uid_translate(idmap, pace);\n\t\t\tid_to_sid(uid, SIDCREATOR_OWNER, sid);\n\t\t} else if (pace->e_tag == ACL_GROUP) {\n\t\t\tgid_t gid;\n\n\t\t\tgid = posix_acl_gid_translate(idmap, pace);\n\t\t\tid_to_sid(gid, SIDCREATOR_GROUP, sid);\n\t\t} else {\n\t\t\tkfree(sid);\n\t\t\tcontinue;\n\t\t}\n\n\t\tntace = (struct smb_ace *)((char *)pndace + *size);\n\t\t*size += fill_ace_for_sid(ntace, sid, ACCESS_ALLOWED, 0x0b,\n\t\t\t\tpace->e_perm, 0777);\n\t\t(*num_aces)++;\n\t\tif (pace->e_tag == ACL_USER)\n\t\t\tntace->access_req |=\n\t\t\t\tFILE_DELETE_LE | FILE_DELETE_CHILD_LE;\n\t\tkfree(sid);\n\t}\n}\n\nstatic void set_ntacl_dacl(struct mnt_idmap *idmap,\n\t\t\t   struct smb_acl *pndacl,\n\t\t\t   struct smb_acl *nt_dacl,\n\t\t\t   unsigned int aces_size,\n\t\t\t   const struct smb_sid *pownersid,\n\t\t\t   const struct smb_sid *pgrpsid,\n\t\t\t   struct smb_fattr *fattr)\n{\n\tstruct smb_ace *ntace, *pndace;\n\tint nt_num_aces = le32_to_cpu(nt_dacl->num_aces), num_aces = 0;\n\tunsigned short size = 0;\n\tint i;\n\n\tpndace = (struct smb_ace *)((char *)pndacl + sizeof(struct smb_acl));\n\tif (nt_num_aces) {\n\t\tntace = (struct smb_ace *)((char *)nt_dacl + sizeof(struct smb_acl));\n\t\tfor (i = 0; i < nt_num_aces; i++) {\n\t\t\tunsigned short nt_ace_size;\n\n\t\t\tif (offsetof(struct smb_ace, access_req) > aces_size)\n\t\t\t\tbreak;\n\n\t\t\tnt_ace_size = le16_to_cpu(ntace->size);\n\t\t\tif (nt_ace_size > aces_size)\n\t\t\t\tbreak;\n\n\t\t\tmemcpy((char *)pndace + size, ntace, nt_ace_size);\n\t\t\tsize += nt_ace_size;\n\t\t\taces_size -= nt_ace_size;\n\t\t\tntace = (struct smb_ace *)((char *)ntace + nt_ace_size);\n\t\t\tnum_aces++;\n\t\t}\n\t}\n\n\tset_posix_acl_entries_dacl(idmap, pndace, fattr,\n\t\t\t\t   &num_aces, &size, nt_num_aces);\n\tpndacl->num_aces = cpu_to_le32(num_aces);\n\tpndacl->size = cpu_to_le16(le16_to_cpu(pndacl->size) + size);\n}\n\nstatic void set_mode_dacl(struct mnt_idmap *idmap,\n\t\t\t  struct smb_acl *pndacl, struct smb_fattr *fattr)\n{\n\tstruct smb_ace *pace, *pndace;\n\tu32 num_aces = 0;\n\tu16 size = 0, ace_size = 0;\n\tuid_t uid;\n\tconst struct smb_sid *sid;\n\n\tpace = pndace = (struct smb_ace *)((char *)pndacl + sizeof(struct smb_acl));\n\n\tif (fattr->cf_acls) {\n\t\tset_posix_acl_entries_dacl(idmap, pndace, fattr,\n\t\t\t\t\t   &num_aces, &size, num_aces);\n\t\tgoto out;\n\t}\n\n\t \n\tuid = from_kuid(&init_user_ns, fattr->cf_uid);\n\tif (uid)\n\t\tsid = &server_conf.domain_sid;\n\telse\n\t\tsid = &sid_unix_users;\n\tace_size = fill_ace_for_sid(pace, sid, ACCESS_ALLOWED, 0,\n\t\t\t\t    fattr->cf_mode, 0700);\n\tpace->sid.sub_auth[pace->sid.num_subauth++] = cpu_to_le32(uid);\n\tpace->size = cpu_to_le16(ace_size + 4);\n\tsize += le16_to_cpu(pace->size);\n\tpace = (struct smb_ace *)((char *)pndace + size);\n\n\t \n\tace_size = fill_ace_for_sid(pace, &sid_unix_groups,\n\t\t\t\t    ACCESS_ALLOWED, 0, fattr->cf_mode, 0070);\n\tpace->sid.sub_auth[pace->sid.num_subauth++] =\n\t\tcpu_to_le32(from_kgid(&init_user_ns, fattr->cf_gid));\n\tpace->size = cpu_to_le16(ace_size + 4);\n\tsize += le16_to_cpu(pace->size);\n\tpace = (struct smb_ace *)((char *)pndace + size);\n\tnum_aces = 3;\n\n\tif (S_ISDIR(fattr->cf_mode)) {\n\t\tpace = (struct smb_ace *)((char *)pndace + size);\n\n\t\t \n\t\tsize += fill_ace_for_sid(pace, &creator_owner, ACCESS_ALLOWED,\n\t\t\t\t\t 0x0b, fattr->cf_mode, 0700);\n\t\tpace = (struct smb_ace *)((char *)pndace + size);\n\n\t\t \n\t\tsize += fill_ace_for_sid(pace, &creator_group, ACCESS_ALLOWED,\n\t\t\t\t\t 0x0b, fattr->cf_mode, 0070);\n\t\tpace = (struct smb_ace *)((char *)pndace + size);\n\t\tnum_aces = 5;\n\t}\n\n\t \n\tsize += fill_ace_for_sid(pace, &sid_everyone, ACCESS_ALLOWED, 0,\n\t\t\t\t fattr->cf_mode, 0007);\n\nout:\n\tpndacl->num_aces = cpu_to_le32(num_aces);\n\tpndacl->size = cpu_to_le16(le16_to_cpu(pndacl->size) + size);\n}\n\nstatic int parse_sid(struct smb_sid *psid, char *end_of_acl)\n{\n\t \n\tif (end_of_acl < (char *)psid + 8) {\n\t\tpr_err(\"ACL too small to parse SID %p\\n\", psid);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nint parse_sec_desc(struct mnt_idmap *idmap, struct smb_ntsd *pntsd,\n\t\t   int acl_len, struct smb_fattr *fattr)\n{\n\tint rc = 0;\n\tstruct smb_sid *owner_sid_ptr, *group_sid_ptr;\n\tstruct smb_acl *dacl_ptr;  \n\tchar *end_of_acl = ((char *)pntsd) + acl_len;\n\t__u32 dacloffset;\n\tint pntsd_type;\n\n\tif (!pntsd)\n\t\treturn -EIO;\n\n\tif (acl_len < sizeof(struct smb_ntsd))\n\t\treturn -EINVAL;\n\n\towner_sid_ptr = (struct smb_sid *)((char *)pntsd +\n\t\t\tle32_to_cpu(pntsd->osidoffset));\n\tgroup_sid_ptr = (struct smb_sid *)((char *)pntsd +\n\t\t\tle32_to_cpu(pntsd->gsidoffset));\n\tdacloffset = le32_to_cpu(pntsd->dacloffset);\n\tdacl_ptr = (struct smb_acl *)((char *)pntsd + dacloffset);\n\tksmbd_debug(SMB,\n\t\t    \"revision %d type 0x%x ooffset 0x%x goffset 0x%x sacloffset 0x%x dacloffset 0x%x\\n\",\n\t\t    pntsd->revision, pntsd->type, le32_to_cpu(pntsd->osidoffset),\n\t\t    le32_to_cpu(pntsd->gsidoffset),\n\t\t    le32_to_cpu(pntsd->sacloffset), dacloffset);\n\n\tpntsd_type = le16_to_cpu(pntsd->type);\n\tif (!(pntsd_type & DACL_PRESENT)) {\n\t\tksmbd_debug(SMB, \"DACL_PRESENT in DACL type is not set\\n\");\n\t\treturn rc;\n\t}\n\n\tpntsd->type = cpu_to_le16(DACL_PRESENT);\n\n\tif (pntsd->osidoffset) {\n\t\trc = parse_sid(owner_sid_ptr, end_of_acl);\n\t\tif (rc) {\n\t\t\tpr_err(\"%s: Error %d parsing Owner SID\\n\", __func__, rc);\n\t\t\treturn rc;\n\t\t}\n\n\t\trc = sid_to_id(idmap, owner_sid_ptr, SIDOWNER, fattr);\n\t\tif (rc) {\n\t\t\tpr_err(\"%s: Error %d mapping Owner SID to uid\\n\",\n\t\t\t       __func__, rc);\n\t\t\towner_sid_ptr = NULL;\n\t\t}\n\t}\n\n\tif (pntsd->gsidoffset) {\n\t\trc = parse_sid(group_sid_ptr, end_of_acl);\n\t\tif (rc) {\n\t\t\tpr_err(\"%s: Error %d mapping Owner SID to gid\\n\",\n\t\t\t       __func__, rc);\n\t\t\treturn rc;\n\t\t}\n\t\trc = sid_to_id(idmap, group_sid_ptr, SIDUNIX_GROUP, fattr);\n\t\tif (rc) {\n\t\t\tpr_err(\"%s: Error %d mapping Group SID to gid\\n\",\n\t\t\t       __func__, rc);\n\t\t\tgroup_sid_ptr = NULL;\n\t\t}\n\t}\n\n\tif ((pntsd_type & (DACL_AUTO_INHERITED | DACL_AUTO_INHERIT_REQ)) ==\n\t    (DACL_AUTO_INHERITED | DACL_AUTO_INHERIT_REQ))\n\t\tpntsd->type |= cpu_to_le16(DACL_AUTO_INHERITED);\n\tif (pntsd_type & DACL_PROTECTED)\n\t\tpntsd->type |= cpu_to_le16(DACL_PROTECTED);\n\n\tif (dacloffset) {\n\t\tparse_dacl(idmap, dacl_ptr, end_of_acl,\n\t\t\t   owner_sid_ptr, group_sid_ptr, fattr);\n\t}\n\n\treturn 0;\n}\n\n \nint build_sec_desc(struct mnt_idmap *idmap,\n\t\t   struct smb_ntsd *pntsd, struct smb_ntsd *ppntsd,\n\t\t   int ppntsd_size, int addition_info, __u32 *secdesclen,\n\t\t   struct smb_fattr *fattr)\n{\n\tint rc = 0;\n\t__u32 offset;\n\tstruct smb_sid *owner_sid_ptr, *group_sid_ptr;\n\tstruct smb_sid *nowner_sid_ptr, *ngroup_sid_ptr;\n\tstruct smb_acl *dacl_ptr = NULL;  \n\tuid_t uid;\n\tgid_t gid;\n\tunsigned int sid_type = SIDOWNER;\n\n\tnowner_sid_ptr = kmalloc(sizeof(struct smb_sid), GFP_KERNEL);\n\tif (!nowner_sid_ptr)\n\t\treturn -ENOMEM;\n\n\tuid = from_kuid(&init_user_ns, fattr->cf_uid);\n\tif (!uid)\n\t\tsid_type = SIDUNIX_USER;\n\tid_to_sid(uid, sid_type, nowner_sid_ptr);\n\n\tngroup_sid_ptr = kmalloc(sizeof(struct smb_sid), GFP_KERNEL);\n\tif (!ngroup_sid_ptr) {\n\t\tkfree(nowner_sid_ptr);\n\t\treturn -ENOMEM;\n\t}\n\n\tgid = from_kgid(&init_user_ns, fattr->cf_gid);\n\tid_to_sid(gid, SIDUNIX_GROUP, ngroup_sid_ptr);\n\n\toffset = sizeof(struct smb_ntsd);\n\tpntsd->sacloffset = 0;\n\tpntsd->revision = cpu_to_le16(1);\n\tpntsd->type = cpu_to_le16(SELF_RELATIVE);\n\tif (ppntsd)\n\t\tpntsd->type |= ppntsd->type;\n\n\tif (addition_info & OWNER_SECINFO) {\n\t\tpntsd->osidoffset = cpu_to_le32(offset);\n\t\towner_sid_ptr = (struct smb_sid *)((char *)pntsd + offset);\n\t\tsmb_copy_sid(owner_sid_ptr, nowner_sid_ptr);\n\t\toffset += 1 + 1 + 6 + (nowner_sid_ptr->num_subauth * 4);\n\t}\n\n\tif (addition_info & GROUP_SECINFO) {\n\t\tpntsd->gsidoffset = cpu_to_le32(offset);\n\t\tgroup_sid_ptr = (struct smb_sid *)((char *)pntsd + offset);\n\t\tsmb_copy_sid(group_sid_ptr, ngroup_sid_ptr);\n\t\toffset += 1 + 1 + 6 + (ngroup_sid_ptr->num_subauth * 4);\n\t}\n\n\tif (addition_info & DACL_SECINFO) {\n\t\tpntsd->type |= cpu_to_le16(DACL_PRESENT);\n\t\tdacl_ptr = (struct smb_acl *)((char *)pntsd + offset);\n\t\tdacl_ptr->revision = cpu_to_le16(2);\n\t\tdacl_ptr->size = cpu_to_le16(sizeof(struct smb_acl));\n\t\tdacl_ptr->num_aces = 0;\n\n\t\tif (!ppntsd) {\n\t\t\tset_mode_dacl(idmap, dacl_ptr, fattr);\n\t\t} else {\n\t\t\tstruct smb_acl *ppdacl_ptr;\n\t\t\tunsigned int dacl_offset = le32_to_cpu(ppntsd->dacloffset);\n\t\t\tint ppdacl_size, ntacl_size = ppntsd_size - dacl_offset;\n\n\t\t\tif (!dacl_offset ||\n\t\t\t    (dacl_offset + sizeof(struct smb_acl) > ppntsd_size))\n\t\t\t\tgoto out;\n\n\t\t\tppdacl_ptr = (struct smb_acl *)((char *)ppntsd + dacl_offset);\n\t\t\tppdacl_size = le16_to_cpu(ppdacl_ptr->size);\n\t\t\tif (ppdacl_size > ntacl_size ||\n\t\t\t    ppdacl_size < sizeof(struct smb_acl))\n\t\t\t\tgoto out;\n\n\t\t\tset_ntacl_dacl(idmap, dacl_ptr, ppdacl_ptr,\n\t\t\t\t       ntacl_size - sizeof(struct smb_acl),\n\t\t\t\t       nowner_sid_ptr, ngroup_sid_ptr,\n\t\t\t\t       fattr);\n\t\t}\n\t\tpntsd->dacloffset = cpu_to_le32(offset);\n\t\toffset += le16_to_cpu(dacl_ptr->size);\n\t}\n\nout:\n\tkfree(nowner_sid_ptr);\n\tkfree(ngroup_sid_ptr);\n\t*secdesclen = offset;\n\treturn rc;\n}\n\nstatic void smb_set_ace(struct smb_ace *ace, const struct smb_sid *sid, u8 type,\n\t\t\tu8 flags, __le32 access_req)\n{\n\tace->type = type;\n\tace->flags = flags;\n\tace->access_req = access_req;\n\tsmb_copy_sid(&ace->sid, sid);\n\tace->size = cpu_to_le16(1 + 1 + 2 + 4 + 1 + 1 + 6 + (sid->num_subauth * 4));\n}\n\nint smb_inherit_dacl(struct ksmbd_conn *conn,\n\t\t     const struct path *path,\n\t\t     unsigned int uid, unsigned int gid)\n{\n\tconst struct smb_sid *psid, *creator = NULL;\n\tstruct smb_ace *parent_aces, *aces;\n\tstruct smb_acl *parent_pdacl;\n\tstruct smb_ntsd *parent_pntsd = NULL;\n\tstruct smb_sid owner_sid, group_sid;\n\tstruct dentry *parent = path->dentry->d_parent;\n\tstruct mnt_idmap *idmap = mnt_idmap(path->mnt);\n\tint inherited_flags = 0, flags = 0, i, ace_cnt = 0, nt_size = 0, pdacl_size;\n\tint rc = 0, num_aces, dacloffset, pntsd_type, pntsd_size, acl_len, aces_size;\n\tchar *aces_base;\n\tbool is_dir = S_ISDIR(d_inode(path->dentry)->i_mode);\n\n\tpntsd_size = ksmbd_vfs_get_sd_xattr(conn, idmap,\n\t\t\t\t\t    parent, &parent_pntsd);\n\tif (pntsd_size <= 0)\n\t\treturn -ENOENT;\n\tdacloffset = le32_to_cpu(parent_pntsd->dacloffset);\n\tif (!dacloffset || (dacloffset + sizeof(struct smb_acl) > pntsd_size)) {\n\t\trc = -EINVAL;\n\t\tgoto free_parent_pntsd;\n\t}\n\n\tparent_pdacl = (struct smb_acl *)((char *)parent_pntsd + dacloffset);\n\tacl_len = pntsd_size - dacloffset;\n\tnum_aces = le32_to_cpu(parent_pdacl->num_aces);\n\tpntsd_type = le16_to_cpu(parent_pntsd->type);\n\tpdacl_size = le16_to_cpu(parent_pdacl->size);\n\n\tif (pdacl_size > acl_len || pdacl_size < sizeof(struct smb_acl)) {\n\t\trc = -EINVAL;\n\t\tgoto free_parent_pntsd;\n\t}\n\n\taces_base = kmalloc(sizeof(struct smb_ace) * num_aces * 2, GFP_KERNEL);\n\tif (!aces_base) {\n\t\trc = -ENOMEM;\n\t\tgoto free_parent_pntsd;\n\t}\n\n\taces = (struct smb_ace *)aces_base;\n\tparent_aces = (struct smb_ace *)((char *)parent_pdacl +\n\t\t\tsizeof(struct smb_acl));\n\taces_size = acl_len - sizeof(struct smb_acl);\n\n\tif (pntsd_type & DACL_AUTO_INHERITED)\n\t\tinherited_flags = INHERITED_ACE;\n\n\tfor (i = 0; i < num_aces; i++) {\n\t\tint pace_size;\n\n\t\tif (offsetof(struct smb_ace, access_req) > aces_size)\n\t\t\tbreak;\n\n\t\tpace_size = le16_to_cpu(parent_aces->size);\n\t\tif (pace_size > aces_size)\n\t\t\tbreak;\n\n\t\taces_size -= pace_size;\n\n\t\tflags = parent_aces->flags;\n\t\tif (!smb_inherit_flags(flags, is_dir))\n\t\t\tgoto pass;\n\t\tif (is_dir) {\n\t\t\tflags &= ~(INHERIT_ONLY_ACE | INHERITED_ACE);\n\t\t\tif (!(flags & CONTAINER_INHERIT_ACE))\n\t\t\t\tflags |= INHERIT_ONLY_ACE;\n\t\t\tif (flags & NO_PROPAGATE_INHERIT_ACE)\n\t\t\t\tflags = 0;\n\t\t} else {\n\t\t\tflags = 0;\n\t\t}\n\n\t\tif (!compare_sids(&creator_owner, &parent_aces->sid)) {\n\t\t\tcreator = &creator_owner;\n\t\t\tid_to_sid(uid, SIDOWNER, &owner_sid);\n\t\t\tpsid = &owner_sid;\n\t\t} else if (!compare_sids(&creator_group, &parent_aces->sid)) {\n\t\t\tcreator = &creator_group;\n\t\t\tid_to_sid(gid, SIDUNIX_GROUP, &group_sid);\n\t\t\tpsid = &group_sid;\n\t\t} else {\n\t\t\tcreator = NULL;\n\t\t\tpsid = &parent_aces->sid;\n\t\t}\n\n\t\tif (is_dir && creator && flags & CONTAINER_INHERIT_ACE) {\n\t\t\tsmb_set_ace(aces, psid, parent_aces->type, inherited_flags,\n\t\t\t\t    parent_aces->access_req);\n\t\t\tnt_size += le16_to_cpu(aces->size);\n\t\t\tace_cnt++;\n\t\t\taces = (struct smb_ace *)((char *)aces + le16_to_cpu(aces->size));\n\t\t\tflags |= INHERIT_ONLY_ACE;\n\t\t\tpsid = creator;\n\t\t} else if (is_dir && !(parent_aces->flags & NO_PROPAGATE_INHERIT_ACE)) {\n\t\t\tpsid = &parent_aces->sid;\n\t\t}\n\n\t\tsmb_set_ace(aces, psid, parent_aces->type, flags | inherited_flags,\n\t\t\t    parent_aces->access_req);\n\t\tnt_size += le16_to_cpu(aces->size);\n\t\taces = (struct smb_ace *)((char *)aces + le16_to_cpu(aces->size));\n\t\tace_cnt++;\npass:\n\t\tparent_aces = (struct smb_ace *)((char *)parent_aces + pace_size);\n\t}\n\n\tif (nt_size > 0) {\n\t\tstruct smb_ntsd *pntsd;\n\t\tstruct smb_acl *pdacl;\n\t\tstruct smb_sid *powner_sid = NULL, *pgroup_sid = NULL;\n\t\tint powner_sid_size = 0, pgroup_sid_size = 0, pntsd_size;\n\t\tint pntsd_alloc_size;\n\n\t\tif (parent_pntsd->osidoffset) {\n\t\t\tpowner_sid = (struct smb_sid *)((char *)parent_pntsd +\n\t\t\t\t\tle32_to_cpu(parent_pntsd->osidoffset));\n\t\t\tpowner_sid_size = 1 + 1 + 6 + (powner_sid->num_subauth * 4);\n\t\t}\n\t\tif (parent_pntsd->gsidoffset) {\n\t\t\tpgroup_sid = (struct smb_sid *)((char *)parent_pntsd +\n\t\t\t\t\tle32_to_cpu(parent_pntsd->gsidoffset));\n\t\t\tpgroup_sid_size = 1 + 1 + 6 + (pgroup_sid->num_subauth * 4);\n\t\t}\n\n\t\tpntsd_alloc_size = sizeof(struct smb_ntsd) + powner_sid_size +\n\t\t\tpgroup_sid_size + sizeof(struct smb_acl) + nt_size;\n\n\t\tpntsd = kzalloc(pntsd_alloc_size, GFP_KERNEL);\n\t\tif (!pntsd) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto free_aces_base;\n\t\t}\n\n\t\tpntsd->revision = cpu_to_le16(1);\n\t\tpntsd->type = cpu_to_le16(SELF_RELATIVE | DACL_PRESENT);\n\t\tif (le16_to_cpu(parent_pntsd->type) & DACL_AUTO_INHERITED)\n\t\t\tpntsd->type |= cpu_to_le16(DACL_AUTO_INHERITED);\n\t\tpntsd_size = sizeof(struct smb_ntsd);\n\t\tpntsd->osidoffset = parent_pntsd->osidoffset;\n\t\tpntsd->gsidoffset = parent_pntsd->gsidoffset;\n\t\tpntsd->dacloffset = parent_pntsd->dacloffset;\n\n\t\tif ((u64)le32_to_cpu(pntsd->osidoffset) + powner_sid_size >\n\t\t    pntsd_alloc_size) {\n\t\t\trc = -EINVAL;\n\t\t\tkfree(pntsd);\n\t\t\tgoto free_aces_base;\n\t\t}\n\n\t\tif ((u64)le32_to_cpu(pntsd->gsidoffset) + pgroup_sid_size >\n\t\t    pntsd_alloc_size) {\n\t\t\trc = -EINVAL;\n\t\t\tkfree(pntsd);\n\t\t\tgoto free_aces_base;\n\t\t}\n\n\t\tif ((u64)le32_to_cpu(pntsd->dacloffset) + sizeof(struct smb_acl) + nt_size >\n\t\t    pntsd_alloc_size) {\n\t\t\trc = -EINVAL;\n\t\t\tkfree(pntsd);\n\t\t\tgoto free_aces_base;\n\t\t}\n\n\t\tif (pntsd->osidoffset) {\n\t\t\tstruct smb_sid *owner_sid = (struct smb_sid *)((char *)pntsd +\n\t\t\t\t\tle32_to_cpu(pntsd->osidoffset));\n\t\t\tmemcpy(owner_sid, powner_sid, powner_sid_size);\n\t\t\tpntsd_size += powner_sid_size;\n\t\t}\n\n\t\tif (pntsd->gsidoffset) {\n\t\t\tstruct smb_sid *group_sid = (struct smb_sid *)((char *)pntsd +\n\t\t\t\t\tle32_to_cpu(pntsd->gsidoffset));\n\t\t\tmemcpy(group_sid, pgroup_sid, pgroup_sid_size);\n\t\t\tpntsd_size += pgroup_sid_size;\n\t\t}\n\n\t\tif (pntsd->dacloffset) {\n\t\t\tstruct smb_ace *pace;\n\n\t\t\tpdacl = (struct smb_acl *)((char *)pntsd + le32_to_cpu(pntsd->dacloffset));\n\t\t\tpdacl->revision = cpu_to_le16(2);\n\t\t\tpdacl->size = cpu_to_le16(sizeof(struct smb_acl) + nt_size);\n\t\t\tpdacl->num_aces = cpu_to_le32(ace_cnt);\n\t\t\tpace = (struct smb_ace *)((char *)pdacl + sizeof(struct smb_acl));\n\t\t\tmemcpy(pace, aces_base, nt_size);\n\t\t\tpntsd_size += sizeof(struct smb_acl) + nt_size;\n\t\t}\n\n\t\tksmbd_vfs_set_sd_xattr(conn, idmap, path, pntsd, pntsd_size, false);\n\t\tkfree(pntsd);\n\t}\n\nfree_aces_base:\n\tkfree(aces_base);\nfree_parent_pntsd:\n\tkfree(parent_pntsd);\n\treturn rc;\n}\n\nbool smb_inherit_flags(int flags, bool is_dir)\n{\n\tif (!is_dir)\n\t\treturn (flags & OBJECT_INHERIT_ACE) != 0;\n\n\tif (flags & OBJECT_INHERIT_ACE && !(flags & NO_PROPAGATE_INHERIT_ACE))\n\t\treturn true;\n\n\tif (flags & CONTAINER_INHERIT_ACE)\n\t\treturn true;\n\treturn false;\n}\n\nint smb_check_perm_dacl(struct ksmbd_conn *conn, const struct path *path,\n\t\t\t__le32 *pdaccess, int uid)\n{\n\tstruct mnt_idmap *idmap = mnt_idmap(path->mnt);\n\tstruct smb_ntsd *pntsd = NULL;\n\tstruct smb_acl *pdacl;\n\tstruct posix_acl *posix_acls;\n\tint rc = 0, pntsd_size, acl_size, aces_size, pdacl_size, dacl_offset;\n\tstruct smb_sid sid;\n\tint granted = le32_to_cpu(*pdaccess & ~FILE_MAXIMAL_ACCESS_LE);\n\tstruct smb_ace *ace;\n\tint i, found = 0;\n\tunsigned int access_bits = 0;\n\tstruct smb_ace *others_ace = NULL;\n\tstruct posix_acl_entry *pa_entry;\n\tunsigned int sid_type = SIDOWNER;\n\tunsigned short ace_size;\n\n\tksmbd_debug(SMB, \"check permission using windows acl\\n\");\n\tpntsd_size = ksmbd_vfs_get_sd_xattr(conn, idmap,\n\t\t\t\t\t    path->dentry, &pntsd);\n\tif (pntsd_size <= 0 || !pntsd)\n\t\tgoto err_out;\n\n\tdacl_offset = le32_to_cpu(pntsd->dacloffset);\n\tif (!dacl_offset ||\n\t    (dacl_offset + sizeof(struct smb_acl) > pntsd_size))\n\t\tgoto err_out;\n\n\tpdacl = (struct smb_acl *)((char *)pntsd + le32_to_cpu(pntsd->dacloffset));\n\tacl_size = pntsd_size - dacl_offset;\n\tpdacl_size = le16_to_cpu(pdacl->size);\n\n\tif (pdacl_size > acl_size || pdacl_size < sizeof(struct smb_acl))\n\t\tgoto err_out;\n\n\tif (!pdacl->num_aces) {\n\t\tif (!(pdacl_size - sizeof(struct smb_acl)) &&\n\t\t    *pdaccess & ~(FILE_READ_CONTROL_LE | FILE_WRITE_DAC_LE)) {\n\t\t\trc = -EACCES;\n\t\t\tgoto err_out;\n\t\t}\n\t\tgoto err_out;\n\t}\n\n\tif (*pdaccess & FILE_MAXIMAL_ACCESS_LE) {\n\t\tgranted = READ_CONTROL | WRITE_DAC | FILE_READ_ATTRIBUTES |\n\t\t\tDELETE;\n\n\t\tace = (struct smb_ace *)((char *)pdacl + sizeof(struct smb_acl));\n\t\taces_size = acl_size - sizeof(struct smb_acl);\n\t\tfor (i = 0; i < le32_to_cpu(pdacl->num_aces); i++) {\n\t\t\tif (offsetof(struct smb_ace, access_req) > aces_size)\n\t\t\t\tbreak;\n\t\t\tace_size = le16_to_cpu(ace->size);\n\t\t\tif (ace_size > aces_size)\n\t\t\t\tbreak;\n\t\t\taces_size -= ace_size;\n\t\t\tgranted |= le32_to_cpu(ace->access_req);\n\t\t\tace = (struct smb_ace *)((char *)ace + le16_to_cpu(ace->size));\n\t\t}\n\n\t\tif (!pdacl->num_aces)\n\t\t\tgranted = GENERIC_ALL_FLAGS;\n\t}\n\n\tif (!uid)\n\t\tsid_type = SIDUNIX_USER;\n\tid_to_sid(uid, sid_type, &sid);\n\n\tace = (struct smb_ace *)((char *)pdacl + sizeof(struct smb_acl));\n\taces_size = acl_size - sizeof(struct smb_acl);\n\tfor (i = 0; i < le32_to_cpu(pdacl->num_aces); i++) {\n\t\tif (offsetof(struct smb_ace, access_req) > aces_size)\n\t\t\tbreak;\n\t\tace_size = le16_to_cpu(ace->size);\n\t\tif (ace_size > aces_size)\n\t\t\tbreak;\n\t\taces_size -= ace_size;\n\n\t\tif (!compare_sids(&sid, &ace->sid) ||\n\t\t    !compare_sids(&sid_unix_NFS_mode, &ace->sid)) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (!compare_sids(&sid_everyone, &ace->sid))\n\t\t\tothers_ace = ace;\n\n\t\tace = (struct smb_ace *)((char *)ace + le16_to_cpu(ace->size));\n\t}\n\n\tif (*pdaccess & FILE_MAXIMAL_ACCESS_LE && found) {\n\t\tgranted = READ_CONTROL | WRITE_DAC | FILE_READ_ATTRIBUTES |\n\t\t\tDELETE;\n\n\t\tgranted |= le32_to_cpu(ace->access_req);\n\n\t\tif (!pdacl->num_aces)\n\t\t\tgranted = GENERIC_ALL_FLAGS;\n\t}\n\n\tif (IS_ENABLED(CONFIG_FS_POSIX_ACL)) {\n\t\tposix_acls = get_inode_acl(d_inode(path->dentry), ACL_TYPE_ACCESS);\n\t\tif (!IS_ERR_OR_NULL(posix_acls) && !found) {\n\t\t\tunsigned int id = -1;\n\n\t\t\tpa_entry = posix_acls->a_entries;\n\t\t\tfor (i = 0; i < posix_acls->a_count; i++, pa_entry++) {\n\t\t\t\tif (pa_entry->e_tag == ACL_USER)\n\t\t\t\t\tid = posix_acl_uid_translate(idmap, pa_entry);\n\t\t\t\telse if (pa_entry->e_tag == ACL_GROUP)\n\t\t\t\t\tid = posix_acl_gid_translate(idmap, pa_entry);\n\t\t\t\telse\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (id == uid) {\n\t\t\t\t\tmode_to_access_flags(pa_entry->e_perm,\n\t\t\t\t\t\t\t     0777,\n\t\t\t\t\t\t\t     &access_bits);\n\t\t\t\t\tif (!access_bits)\n\t\t\t\t\t\taccess_bits =\n\t\t\t\t\t\t\tSET_MINIMUM_RIGHTS;\n\t\t\t\t\tposix_acl_release(posix_acls);\n\t\t\t\t\tgoto check_access_bits;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!IS_ERR_OR_NULL(posix_acls))\n\t\t\tposix_acl_release(posix_acls);\n\t}\n\n\tif (!found) {\n\t\tif (others_ace) {\n\t\t\tace = others_ace;\n\t\t} else {\n\t\t\tksmbd_debug(SMB, \"Can't find corresponding sid\\n\");\n\t\t\trc = -EACCES;\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\tswitch (ace->type) {\n\tcase ACCESS_ALLOWED_ACE_TYPE:\n\t\taccess_bits = le32_to_cpu(ace->access_req);\n\t\tbreak;\n\tcase ACCESS_DENIED_ACE_TYPE:\n\tcase ACCESS_DENIED_CALLBACK_ACE_TYPE:\n\t\taccess_bits = le32_to_cpu(~ace->access_req);\n\t\tbreak;\n\t}\n\ncheck_access_bits:\n\tif (granted &\n\t    ~(access_bits | FILE_READ_ATTRIBUTES | READ_CONTROL | WRITE_DAC | DELETE)) {\n\t\tksmbd_debug(SMB, \"Access denied with winACL, granted : %x, access_req : %x\\n\",\n\t\t\t    granted, le32_to_cpu(ace->access_req));\n\t\trc = -EACCES;\n\t\tgoto err_out;\n\t}\n\n\t*pdaccess = cpu_to_le32(granted);\nerr_out:\n\tkfree(pntsd);\n\treturn rc;\n}\n\nint set_info_sec(struct ksmbd_conn *conn, struct ksmbd_tree_connect *tcon,\n\t\t const struct path *path, struct smb_ntsd *pntsd, int ntsd_len,\n\t\t bool type_check, bool get_write)\n{\n\tint rc;\n\tstruct smb_fattr fattr = {{0}};\n\tstruct inode *inode = d_inode(path->dentry);\n\tstruct mnt_idmap *idmap = mnt_idmap(path->mnt);\n\tstruct iattr newattrs;\n\n\tfattr.cf_uid = INVALID_UID;\n\tfattr.cf_gid = INVALID_GID;\n\tfattr.cf_mode = inode->i_mode;\n\n\trc = parse_sec_desc(idmap, pntsd, ntsd_len, &fattr);\n\tif (rc)\n\t\tgoto out;\n\n\tnewattrs.ia_valid = ATTR_CTIME;\n\tif (!uid_eq(fattr.cf_uid, INVALID_UID)) {\n\t\tnewattrs.ia_valid |= ATTR_UID;\n\t\tnewattrs.ia_uid = fattr.cf_uid;\n\t}\n\tif (!gid_eq(fattr.cf_gid, INVALID_GID)) {\n\t\tnewattrs.ia_valid |= ATTR_GID;\n\t\tnewattrs.ia_gid = fattr.cf_gid;\n\t}\n\tnewattrs.ia_valid |= ATTR_MODE;\n\tnewattrs.ia_mode = (inode->i_mode & ~0777) | (fattr.cf_mode & 0777);\n\n\tksmbd_vfs_remove_acl_xattrs(idmap, path);\n\t \n\tif (IS_ENABLED(CONFIG_FS_POSIX_ACL) && fattr.cf_dacls) {\n\t\trc = set_posix_acl(idmap, path->dentry,\n\t\t\t\t   ACL_TYPE_ACCESS, fattr.cf_acls);\n\t\tif (rc < 0)\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"Set posix acl(ACL_TYPE_ACCESS) failed, rc : %d\\n\",\n\t\t\t\t    rc);\n\t\tif (S_ISDIR(inode->i_mode) && fattr.cf_dacls) {\n\t\t\trc = set_posix_acl(idmap, path->dentry,\n\t\t\t\t\t   ACL_TYPE_DEFAULT, fattr.cf_dacls);\n\t\t\tif (rc)\n\t\t\t\tksmbd_debug(SMB,\n\t\t\t\t\t    \"Set posix acl(ACL_TYPE_DEFAULT) failed, rc : %d\\n\",\n\t\t\t\t\t    rc);\n\t\t}\n\t}\n\n\tinode_lock(inode);\n\trc = notify_change(idmap, path->dentry, &newattrs, NULL);\n\tinode_unlock(inode);\n\tif (rc)\n\t\tgoto out;\n\n\t \n\tif (type_check && !(le16_to_cpu(pntsd->type) & DACL_PRESENT))\n\t\tgoto out;\n\n\tif (test_share_config_flag(tcon->share_conf, KSMBD_SHARE_FLAG_ACL_XATTR)) {\n\t\t \n\t\tksmbd_vfs_remove_sd_xattrs(idmap, path);\n\t\tksmbd_vfs_set_sd_xattr(conn, idmap, path, pntsd, ntsd_len,\n\t\t\t\tget_write);\n\t}\n\nout:\n\tposix_acl_release(fattr.cf_acls);\n\tposix_acl_release(fattr.cf_dacls);\n\treturn rc;\n}\n\nvoid ksmbd_init_domain(u32 *sub_auth)\n{\n\tint i;\n\n\tmemcpy(&server_conf.domain_sid, &domain, sizeof(struct smb_sid));\n\tfor (i = 0; i < 3; ++i)\n\t\tserver_conf.domain_sid.sub_auth[i + 1] = cpu_to_le32(sub_auth[i]);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}