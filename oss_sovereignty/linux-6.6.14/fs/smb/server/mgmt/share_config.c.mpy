{
  "module_name": "share_config.c",
  "hash_id": "70d9cd4655ef7d9a8a37285dd69346a199980d4dfb3dbe849849abaa97a2211d",
  "original_prompt": "Ingested from linux-6.6.14/fs/smb/server/mgmt/share_config.c",
  "human_readable_source": "\n \n\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\n#include \"share_config.h\"\n#include \"user_config.h\"\n#include \"user_session.h\"\n#include \"../transport_ipc.h\"\n#include \"../misc.h\"\n\n#define SHARE_HASH_BITS\t\t3\nstatic DEFINE_HASHTABLE(shares_table, SHARE_HASH_BITS);\nstatic DECLARE_RWSEM(shares_table_lock);\n\nstruct ksmbd_veto_pattern {\n\tchar\t\t\t*pattern;\n\tstruct list_head\tlist;\n};\n\nstatic unsigned int share_name_hash(const char *name)\n{\n\treturn jhash(name, strlen(name), 0);\n}\n\nstatic void kill_share(struct ksmbd_share_config *share)\n{\n\twhile (!list_empty(&share->veto_list)) {\n\t\tstruct ksmbd_veto_pattern *p;\n\n\t\tp = list_entry(share->veto_list.next,\n\t\t\t       struct ksmbd_veto_pattern,\n\t\t\t       list);\n\t\tlist_del(&p->list);\n\t\tkfree(p->pattern);\n\t\tkfree(p);\n\t}\n\n\tif (share->path)\n\t\tpath_put(&share->vfs_path);\n\tkfree(share->name);\n\tkfree(share->path);\n\tkfree(share);\n}\n\nvoid ksmbd_share_config_del(struct ksmbd_share_config *share)\n{\n\tdown_write(&shares_table_lock);\n\thash_del(&share->hlist);\n\tup_write(&shares_table_lock);\n}\n\nvoid __ksmbd_share_config_put(struct ksmbd_share_config *share)\n{\n\tksmbd_share_config_del(share);\n\tkill_share(share);\n}\n\nstatic struct ksmbd_share_config *\n__get_share_config(struct ksmbd_share_config *share)\n{\n\tif (!atomic_inc_not_zero(&share->refcount))\n\t\treturn NULL;\n\treturn share;\n}\n\nstatic struct ksmbd_share_config *__share_lookup(const char *name)\n{\n\tstruct ksmbd_share_config *share;\n\tunsigned int key = share_name_hash(name);\n\n\thash_for_each_possible(shares_table, share, hlist, key) {\n\t\tif (!strcmp(name, share->name))\n\t\t\treturn share;\n\t}\n\treturn NULL;\n}\n\nstatic int parse_veto_list(struct ksmbd_share_config *share,\n\t\t\t   char *veto_list,\n\t\t\t   int veto_list_sz)\n{\n\tint sz = 0;\n\n\tif (!veto_list_sz)\n\t\treturn 0;\n\n\twhile (veto_list_sz > 0) {\n\t\tstruct ksmbd_veto_pattern *p;\n\n\t\tsz = strlen(veto_list);\n\t\tif (!sz)\n\t\t\tbreak;\n\n\t\tp = kzalloc(sizeof(struct ksmbd_veto_pattern), GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\n\t\tp->pattern = kstrdup(veto_list, GFP_KERNEL);\n\t\tif (!p->pattern) {\n\t\t\tkfree(p);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tlist_add(&p->list, &share->veto_list);\n\n\t\tveto_list += sz + 1;\n\t\tveto_list_sz -= (sz + 1);\n\t}\n\n\treturn 0;\n}\n\nstatic struct ksmbd_share_config *share_config_request(struct unicode_map *um,\n\t\t\t\t\t\t       const char *name)\n{\n\tstruct ksmbd_share_config_response *resp;\n\tstruct ksmbd_share_config *share = NULL;\n\tstruct ksmbd_share_config *lookup;\n\tint ret;\n\n\tresp = ksmbd_ipc_share_config_request(name);\n\tif (!resp)\n\t\treturn NULL;\n\n\tif (resp->flags == KSMBD_SHARE_FLAG_INVALID)\n\t\tgoto out;\n\n\tif (*resp->share_name) {\n\t\tchar *cf_resp_name;\n\t\tbool equal;\n\n\t\tcf_resp_name = ksmbd_casefold_sharename(um, resp->share_name);\n\t\tif (IS_ERR(cf_resp_name))\n\t\t\tgoto out;\n\t\tequal = !strcmp(cf_resp_name, name);\n\t\tkfree(cf_resp_name);\n\t\tif (!equal)\n\t\t\tgoto out;\n\t}\n\n\tshare = kzalloc(sizeof(struct ksmbd_share_config), GFP_KERNEL);\n\tif (!share)\n\t\tgoto out;\n\n\tshare->flags = resp->flags;\n\tatomic_set(&share->refcount, 1);\n\tINIT_LIST_HEAD(&share->veto_list);\n\tshare->name = kstrdup(name, GFP_KERNEL);\n\n\tif (!test_share_config_flag(share, KSMBD_SHARE_FLAG_PIPE)) {\n\t\tshare->path = kstrdup(ksmbd_share_config_path(resp),\n\t\t\t\t      GFP_KERNEL);\n\t\tif (share->path)\n\t\t\tshare->path_sz = strlen(share->path);\n\t\tshare->create_mask = resp->create_mask;\n\t\tshare->directory_mask = resp->directory_mask;\n\t\tshare->force_create_mode = resp->force_create_mode;\n\t\tshare->force_directory_mode = resp->force_directory_mode;\n\t\tshare->force_uid = resp->force_uid;\n\t\tshare->force_gid = resp->force_gid;\n\t\tret = parse_veto_list(share,\n\t\t\t\t      KSMBD_SHARE_CONFIG_VETO_LIST(resp),\n\t\t\t\t      resp->veto_list_sz);\n\t\tif (!ret && share->path) {\n\t\t\tret = kern_path(share->path, 0, &share->vfs_path);\n\t\t\tif (ret) {\n\t\t\t\tksmbd_debug(SMB, \"failed to access '%s'\\n\",\n\t\t\t\t\t    share->path);\n\t\t\t\t \n\t\t\t\tkfree(share->path);\n\t\t\t\tshare->path = NULL;\n\t\t\t}\n\t\t}\n\t\tif (ret || !share->name) {\n\t\t\tkill_share(share);\n\t\t\tshare = NULL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tdown_write(&shares_table_lock);\n\tlookup = __share_lookup(name);\n\tif (lookup)\n\t\tlookup = __get_share_config(lookup);\n\tif (!lookup) {\n\t\thash_add(shares_table, &share->hlist, share_name_hash(name));\n\t} else {\n\t\tkill_share(share);\n\t\tshare = lookup;\n\t}\n\tup_write(&shares_table_lock);\n\nout:\n\tkvfree(resp);\n\treturn share;\n}\n\nstruct ksmbd_share_config *ksmbd_share_config_get(struct unicode_map *um,\n\t\t\t\t\t\t  const char *name)\n{\n\tstruct ksmbd_share_config *share;\n\n\tdown_read(&shares_table_lock);\n\tshare = __share_lookup(name);\n\tif (share)\n\t\tshare = __get_share_config(share);\n\tup_read(&shares_table_lock);\n\n\tif (share)\n\t\treturn share;\n\treturn share_config_request(um, name);\n}\n\nbool ksmbd_share_veto_filename(struct ksmbd_share_config *share,\n\t\t\t       const char *filename)\n{\n\tstruct ksmbd_veto_pattern *p;\n\n\tlist_for_each_entry(p, &share->veto_list, list) {\n\t\tif (match_wildcard(p->pattern, filename))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}