{
  "module_name": "tree_connect.c",
  "hash_id": "1fd7e2dc7894aaffc1d6abb45a4613cd29eec3af6fdb04d679da3c01fb37d285",
  "original_prompt": "Ingested from linux-6.6.14/fs/smb/server/mgmt/tree_connect.c",
  "human_readable_source": "\n \n\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/xarray.h>\n\n#include \"../transport_ipc.h\"\n#include \"../connection.h\"\n\n#include \"tree_connect.h\"\n#include \"user_config.h\"\n#include \"share_config.h\"\n#include \"user_session.h\"\n\nstruct ksmbd_tree_conn_status\nksmbd_tree_conn_connect(struct ksmbd_conn *conn, struct ksmbd_session *sess,\n\t\t\tconst char *share_name)\n{\n\tstruct ksmbd_tree_conn_status status = {-ENOENT, NULL};\n\tstruct ksmbd_tree_connect_response *resp = NULL;\n\tstruct ksmbd_share_config *sc;\n\tstruct ksmbd_tree_connect *tree_conn = NULL;\n\tstruct sockaddr *peer_addr;\n\tint ret;\n\n\tsc = ksmbd_share_config_get(conn->um, share_name);\n\tif (!sc)\n\t\treturn status;\n\n\ttree_conn = kzalloc(sizeof(struct ksmbd_tree_connect), GFP_KERNEL);\n\tif (!tree_conn) {\n\t\tstatus.ret = -ENOMEM;\n\t\tgoto out_error;\n\t}\n\n\ttree_conn->id = ksmbd_acquire_tree_conn_id(sess);\n\tif (tree_conn->id < 0) {\n\t\tstatus.ret = -EINVAL;\n\t\tgoto out_error;\n\t}\n\n\tpeer_addr = KSMBD_TCP_PEER_SOCKADDR(conn);\n\tresp = ksmbd_ipc_tree_connect_request(sess,\n\t\t\t\t\t      sc,\n\t\t\t\t\t      tree_conn,\n\t\t\t\t\t      peer_addr);\n\tif (!resp) {\n\t\tstatus.ret = -EINVAL;\n\t\tgoto out_error;\n\t}\n\n\tstatus.ret = resp->status;\n\tif (status.ret != KSMBD_TREE_CONN_STATUS_OK)\n\t\tgoto out_error;\n\n\ttree_conn->flags = resp->connection_flags;\n\tif (test_tree_conn_flag(tree_conn, KSMBD_TREE_CONN_FLAG_UPDATE)) {\n\t\tstruct ksmbd_share_config *new_sc;\n\n\t\tksmbd_share_config_del(sc);\n\t\tnew_sc = ksmbd_share_config_get(conn->um, share_name);\n\t\tif (!new_sc) {\n\t\t\tpr_err(\"Failed to update stale share config\\n\");\n\t\t\tstatus.ret = -ESTALE;\n\t\t\tgoto out_error;\n\t\t}\n\t\tksmbd_share_config_put(sc);\n\t\tsc = new_sc;\n\t}\n\n\ttree_conn->user = sess->user;\n\ttree_conn->share_conf = sc;\n\ttree_conn->t_state = TREE_NEW;\n\tstatus.tree_conn = tree_conn;\n\tatomic_set(&tree_conn->refcount, 1);\n\tinit_waitqueue_head(&tree_conn->refcount_q);\n\n\tret = xa_err(xa_store(&sess->tree_conns, tree_conn->id, tree_conn,\n\t\t\t      GFP_KERNEL));\n\tif (ret) {\n\t\tstatus.ret = -ENOMEM;\n\t\tgoto out_error;\n\t}\n\tkvfree(resp);\n\treturn status;\n\nout_error:\n\tif (tree_conn)\n\t\tksmbd_release_tree_conn_id(sess, tree_conn->id);\n\tksmbd_share_config_put(sc);\n\tkfree(tree_conn);\n\tkvfree(resp);\n\treturn status;\n}\n\nvoid ksmbd_tree_connect_put(struct ksmbd_tree_connect *tcon)\n{\n\t \n\tif (!atomic_dec_return(&tcon->refcount) &&\n\t    waitqueue_active(&tcon->refcount_q))\n\t\twake_up(&tcon->refcount_q);\n}\n\nint ksmbd_tree_conn_disconnect(struct ksmbd_session *sess,\n\t\t\t       struct ksmbd_tree_connect *tree_conn)\n{\n\tint ret;\n\n\twrite_lock(&sess->tree_conns_lock);\n\txa_erase(&sess->tree_conns, tree_conn->id);\n\twrite_unlock(&sess->tree_conns_lock);\n\n\tif (!atomic_dec_and_test(&tree_conn->refcount))\n\t\twait_event(tree_conn->refcount_q,\n\t\t\t   atomic_read(&tree_conn->refcount) == 0);\n\n\tret = ksmbd_ipc_tree_disconnect_request(sess->id, tree_conn->id);\n\tksmbd_release_tree_conn_id(sess, tree_conn->id);\n\tksmbd_share_config_put(tree_conn->share_conf);\n\tkfree(tree_conn);\n\treturn ret;\n}\n\nstruct ksmbd_tree_connect *ksmbd_tree_conn_lookup(struct ksmbd_session *sess,\n\t\t\t\t\t\t  unsigned int id)\n{\n\tstruct ksmbd_tree_connect *tcon;\n\n\tread_lock(&sess->tree_conns_lock);\n\ttcon = xa_load(&sess->tree_conns, id);\n\tif (tcon) {\n\t\tif (tcon->t_state != TREE_CONNECTED)\n\t\t\ttcon = NULL;\n\t\telse if (!atomic_inc_not_zero(&tcon->refcount))\n\t\t\ttcon = NULL;\n\t}\n\tread_unlock(&sess->tree_conns_lock);\n\n\treturn tcon;\n}\n\nint ksmbd_tree_conn_session_logoff(struct ksmbd_session *sess)\n{\n\tint ret = 0;\n\tstruct ksmbd_tree_connect *tc;\n\tunsigned long id;\n\n\tif (!sess)\n\t\treturn -EINVAL;\n\n\txa_for_each(&sess->tree_conns, id, tc) {\n\t\twrite_lock(&sess->tree_conns_lock);\n\t\tif (tc->t_state == TREE_DISCONNECTED) {\n\t\t\twrite_unlock(&sess->tree_conns_lock);\n\t\t\tret = -ENOENT;\n\t\t\tcontinue;\n\t\t}\n\t\ttc->t_state = TREE_DISCONNECTED;\n\t\twrite_unlock(&sess->tree_conns_lock);\n\n\t\tret |= ksmbd_tree_conn_disconnect(sess, tc);\n\t}\n\txa_destroy(&sess->tree_conns);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}