{
  "module_name": "user_session.c",
  "hash_id": "b32546336681211136423fc6638df79033547b818661205b8d8a5e9e1ce17480",
  "original_prompt": "Ingested from linux-6.6.14/fs/smb/server/mgmt/user_session.c",
  "human_readable_source": "\n \n\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/xarray.h>\n\n#include \"ksmbd_ida.h\"\n#include \"user_session.h\"\n#include \"user_config.h\"\n#include \"tree_connect.h\"\n#include \"../transport_ipc.h\"\n#include \"../connection.h\"\n#include \"../vfs_cache.h\"\n\nstatic DEFINE_IDA(session_ida);\n\n#define SESSION_HASH_BITS\t\t3\nstatic DEFINE_HASHTABLE(sessions_table, SESSION_HASH_BITS);\nstatic DECLARE_RWSEM(sessions_table_lock);\n\nstruct ksmbd_session_rpc {\n\tint\t\t\tid;\n\tunsigned int\t\tmethod;\n};\n\nstatic void free_channel_list(struct ksmbd_session *sess)\n{\n\tstruct channel *chann;\n\tunsigned long index;\n\n\txa_for_each(&sess->ksmbd_chann_list, index, chann) {\n\t\txa_erase(&sess->ksmbd_chann_list, index);\n\t\tkfree(chann);\n\t}\n\n\txa_destroy(&sess->ksmbd_chann_list);\n}\n\nstatic void __session_rpc_close(struct ksmbd_session *sess,\n\t\t\t\tstruct ksmbd_session_rpc *entry)\n{\n\tstruct ksmbd_rpc_command *resp;\n\n\tresp = ksmbd_rpc_close(sess, entry->id);\n\tif (!resp)\n\t\tpr_err(\"Unable to close RPC pipe %d\\n\", entry->id);\n\n\tkvfree(resp);\n\tksmbd_rpc_id_free(entry->id);\n\tkfree(entry);\n}\n\nstatic void ksmbd_session_rpc_clear_list(struct ksmbd_session *sess)\n{\n\tstruct ksmbd_session_rpc *entry;\n\tlong index;\n\n\txa_for_each(&sess->rpc_handle_list, index, entry) {\n\t\txa_erase(&sess->rpc_handle_list, index);\n\t\t__session_rpc_close(sess, entry);\n\t}\n\n\txa_destroy(&sess->rpc_handle_list);\n}\n\nstatic int __rpc_method(char *rpc_name)\n{\n\tif (!strcmp(rpc_name, \"\\\\srvsvc\") || !strcmp(rpc_name, \"srvsvc\"))\n\t\treturn KSMBD_RPC_SRVSVC_METHOD_INVOKE;\n\n\tif (!strcmp(rpc_name, \"\\\\wkssvc\") || !strcmp(rpc_name, \"wkssvc\"))\n\t\treturn KSMBD_RPC_WKSSVC_METHOD_INVOKE;\n\n\tif (!strcmp(rpc_name, \"LANMAN\") || !strcmp(rpc_name, \"lanman\"))\n\t\treturn KSMBD_RPC_RAP_METHOD;\n\n\tif (!strcmp(rpc_name, \"\\\\samr\") || !strcmp(rpc_name, \"samr\"))\n\t\treturn KSMBD_RPC_SAMR_METHOD_INVOKE;\n\n\tif (!strcmp(rpc_name, \"\\\\lsarpc\") || !strcmp(rpc_name, \"lsarpc\"))\n\t\treturn KSMBD_RPC_LSARPC_METHOD_INVOKE;\n\n\tpr_err(\"Unsupported RPC: %s\\n\", rpc_name);\n\treturn 0;\n}\n\nint ksmbd_session_rpc_open(struct ksmbd_session *sess, char *rpc_name)\n{\n\tstruct ksmbd_session_rpc *entry;\n\tstruct ksmbd_rpc_command *resp;\n\tint method;\n\n\tmethod = __rpc_method(rpc_name);\n\tif (!method)\n\t\treturn -EINVAL;\n\n\tentry = kzalloc(sizeof(struct ksmbd_session_rpc), GFP_KERNEL);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tentry->method = method;\n\tentry->id = ksmbd_ipc_id_alloc();\n\tif (entry->id < 0)\n\t\tgoto free_entry;\n\txa_store(&sess->rpc_handle_list, entry->id, entry, GFP_KERNEL);\n\n\tresp = ksmbd_rpc_open(sess, entry->id);\n\tif (!resp)\n\t\tgoto free_id;\n\n\tkvfree(resp);\n\treturn entry->id;\nfree_id:\n\txa_erase(&sess->rpc_handle_list, entry->id);\n\tksmbd_rpc_id_free(entry->id);\nfree_entry:\n\tkfree(entry);\n\treturn -EINVAL;\n}\n\nvoid ksmbd_session_rpc_close(struct ksmbd_session *sess, int id)\n{\n\tstruct ksmbd_session_rpc *entry;\n\n\tentry = xa_erase(&sess->rpc_handle_list, id);\n\tif (entry)\n\t\t__session_rpc_close(sess, entry);\n}\n\nint ksmbd_session_rpc_method(struct ksmbd_session *sess, int id)\n{\n\tstruct ksmbd_session_rpc *entry;\n\n\tentry = xa_load(&sess->rpc_handle_list, id);\n\treturn entry ? entry->method : 0;\n}\n\nvoid ksmbd_session_destroy(struct ksmbd_session *sess)\n{\n\tif (!sess)\n\t\treturn;\n\n\tif (sess->user)\n\t\tksmbd_free_user(sess->user);\n\n\tksmbd_tree_conn_session_logoff(sess);\n\tksmbd_destroy_file_table(&sess->file_table);\n\tksmbd_session_rpc_clear_list(sess);\n\tfree_channel_list(sess);\n\tkfree(sess->Preauth_HashValue);\n\tksmbd_release_id(&session_ida, sess->id);\n\tkfree(sess);\n}\n\nstatic struct ksmbd_session *__session_lookup(unsigned long long id)\n{\n\tstruct ksmbd_session *sess;\n\n\thash_for_each_possible(sessions_table, sess, hlist, id) {\n\t\tif (id == sess->id) {\n\t\t\tsess->last_active = jiffies;\n\t\t\treturn sess;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic void ksmbd_expire_session(struct ksmbd_conn *conn)\n{\n\tunsigned long id;\n\tstruct ksmbd_session *sess;\n\n\tdown_write(&conn->session_lock);\n\txa_for_each(&conn->sessions, id, sess) {\n\t\tif (sess->state != SMB2_SESSION_VALID ||\n\t\t    time_after(jiffies,\n\t\t\t       sess->last_active + SMB2_SESSION_TIMEOUT)) {\n\t\t\txa_erase(&conn->sessions, sess->id);\n\t\t\thash_del(&sess->hlist);\n\t\t\tksmbd_session_destroy(sess);\n\t\t\tcontinue;\n\t\t}\n\t}\n\tup_write(&conn->session_lock);\n}\n\nint ksmbd_session_register(struct ksmbd_conn *conn,\n\t\t\t   struct ksmbd_session *sess)\n{\n\tsess->dialect = conn->dialect;\n\tmemcpy(sess->ClientGUID, conn->ClientGUID, SMB2_CLIENT_GUID_SIZE);\n\tksmbd_expire_session(conn);\n\treturn xa_err(xa_store(&conn->sessions, sess->id, sess, GFP_KERNEL));\n}\n\nstatic int ksmbd_chann_del(struct ksmbd_conn *conn, struct ksmbd_session *sess)\n{\n\tstruct channel *chann;\n\n\tchann = xa_erase(&sess->ksmbd_chann_list, (long)conn);\n\tif (!chann)\n\t\treturn -ENOENT;\n\n\tkfree(chann);\n\treturn 0;\n}\n\nvoid ksmbd_sessions_deregister(struct ksmbd_conn *conn)\n{\n\tstruct ksmbd_session *sess;\n\tunsigned long id;\n\n\tdown_write(&sessions_table_lock);\n\tif (conn->binding) {\n\t\tint bkt;\n\t\tstruct hlist_node *tmp;\n\n\t\thash_for_each_safe(sessions_table, bkt, tmp, sess, hlist) {\n\t\t\tif (!ksmbd_chann_del(conn, sess) &&\n\t\t\t    xa_empty(&sess->ksmbd_chann_list)) {\n\t\t\t\thash_del(&sess->hlist);\n\t\t\t\tksmbd_session_destroy(sess);\n\t\t\t}\n\t\t}\n\t}\n\tup_write(&sessions_table_lock);\n\n\tdown_write(&conn->session_lock);\n\txa_for_each(&conn->sessions, id, sess) {\n\t\tunsigned long chann_id;\n\t\tstruct channel *chann;\n\n\t\txa_for_each(&sess->ksmbd_chann_list, chann_id, chann) {\n\t\t\tif (chann->conn != conn)\n\t\t\t\tksmbd_conn_set_exiting(chann->conn);\n\t\t}\n\n\t\tksmbd_chann_del(conn, sess);\n\t\tif (xa_empty(&sess->ksmbd_chann_list)) {\n\t\t\txa_erase(&conn->sessions, sess->id);\n\t\t\thash_del(&sess->hlist);\n\t\t\tksmbd_session_destroy(sess);\n\t\t}\n\t}\n\tup_write(&conn->session_lock);\n}\n\nstruct ksmbd_session *ksmbd_session_lookup(struct ksmbd_conn *conn,\n\t\t\t\t\t   unsigned long long id)\n{\n\tstruct ksmbd_session *sess;\n\n\tdown_read(&conn->session_lock);\n\tsess = xa_load(&conn->sessions, id);\n\tif (sess)\n\t\tsess->last_active = jiffies;\n\tup_read(&conn->session_lock);\n\treturn sess;\n}\n\nstruct ksmbd_session *ksmbd_session_lookup_slowpath(unsigned long long id)\n{\n\tstruct ksmbd_session *sess;\n\n\tdown_read(&sessions_table_lock);\n\tsess = __session_lookup(id);\n\tif (sess)\n\t\tsess->last_active = jiffies;\n\tup_read(&sessions_table_lock);\n\n\treturn sess;\n}\n\nstruct ksmbd_session *ksmbd_session_lookup_all(struct ksmbd_conn *conn,\n\t\t\t\t\t       unsigned long long id)\n{\n\tstruct ksmbd_session *sess;\n\n\tsess = ksmbd_session_lookup(conn, id);\n\tif (!sess && conn->binding)\n\t\tsess = ksmbd_session_lookup_slowpath(id);\n\tif (sess && sess->state != SMB2_SESSION_VALID)\n\t\tsess = NULL;\n\treturn sess;\n}\n\nstruct preauth_session *ksmbd_preauth_session_alloc(struct ksmbd_conn *conn,\n\t\t\t\t\t\t    u64 sess_id)\n{\n\tstruct preauth_session *sess;\n\n\tsess = kmalloc(sizeof(struct preauth_session), GFP_KERNEL);\n\tif (!sess)\n\t\treturn NULL;\n\n\tsess->id = sess_id;\n\tmemcpy(sess->Preauth_HashValue, conn->preauth_info->Preauth_HashValue,\n\t       PREAUTH_HASHVALUE_SIZE);\n\tlist_add(&sess->preauth_entry, &conn->preauth_sess_table);\n\n\treturn sess;\n}\n\nstatic bool ksmbd_preauth_session_id_match(struct preauth_session *sess,\n\t\t\t\t\t   unsigned long long id)\n{\n\treturn sess->id == id;\n}\n\nstruct preauth_session *ksmbd_preauth_session_lookup(struct ksmbd_conn *conn,\n\t\t\t\t\t\t     unsigned long long id)\n{\n\tstruct preauth_session *sess = NULL;\n\n\tlist_for_each_entry(sess, &conn->preauth_sess_table, preauth_entry) {\n\t\tif (ksmbd_preauth_session_id_match(sess, id))\n\t\t\treturn sess;\n\t}\n\treturn NULL;\n}\n\nstatic int __init_smb2_session(struct ksmbd_session *sess)\n{\n\tint id = ksmbd_acquire_smb2_uid(&session_ida);\n\n\tif (id < 0)\n\t\treturn -EINVAL;\n\tsess->id = id;\n\treturn 0;\n}\n\nstatic struct ksmbd_session *__session_create(int protocol)\n{\n\tstruct ksmbd_session *sess;\n\tint ret;\n\n\tif (protocol != CIFDS_SESSION_FLAG_SMB2)\n\t\treturn NULL;\n\n\tsess = kzalloc(sizeof(struct ksmbd_session), GFP_KERNEL);\n\tif (!sess)\n\t\treturn NULL;\n\n\tif (ksmbd_init_file_table(&sess->file_table))\n\t\tgoto error;\n\n\tsess->last_active = jiffies;\n\tsess->state = SMB2_SESSION_IN_PROGRESS;\n\tset_session_flag(sess, protocol);\n\txa_init(&sess->tree_conns);\n\txa_init(&sess->ksmbd_chann_list);\n\txa_init(&sess->rpc_handle_list);\n\tsess->sequence_number = 1;\n\trwlock_init(&sess->tree_conns_lock);\n\n\tret = __init_smb2_session(sess);\n\tif (ret)\n\t\tgoto error;\n\n\tida_init(&sess->tree_conn_ida);\n\n\tdown_write(&sessions_table_lock);\n\thash_add(sessions_table, &sess->hlist, sess->id);\n\tup_write(&sessions_table_lock);\n\n\treturn sess;\n\nerror:\n\tksmbd_session_destroy(sess);\n\treturn NULL;\n}\n\nstruct ksmbd_session *ksmbd_smb2_session_create(void)\n{\n\treturn __session_create(CIFDS_SESSION_FLAG_SMB2);\n}\n\nint ksmbd_acquire_tree_conn_id(struct ksmbd_session *sess)\n{\n\tint id = -EINVAL;\n\n\tif (test_session_flag(sess, CIFDS_SESSION_FLAG_SMB2))\n\t\tid = ksmbd_acquire_smb2_tid(&sess->tree_conn_ida);\n\n\treturn id;\n}\n\nvoid ksmbd_release_tree_conn_id(struct ksmbd_session *sess, int id)\n{\n\tif (id >= 0)\n\t\tksmbd_release_id(&sess->tree_conn_ida, id);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}