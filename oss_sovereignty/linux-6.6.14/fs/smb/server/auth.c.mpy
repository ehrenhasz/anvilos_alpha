{
  "module_name": "auth.c",
  "hash_id": "6362751ec798467d0b88055aaf1cf7428f905c288738d19dde96f8d26cd6e236",
  "original_prompt": "Ingested from linux-6.6.14/fs/smb/server/auth.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/xattr.h>\n#include <crypto/hash.h>\n#include <crypto/aead.h>\n#include <linux/random.h>\n#include <linux/scatterlist.h>\n\n#include \"auth.h\"\n#include \"glob.h\"\n\n#include <linux/fips.h>\n#include <crypto/des.h>\n\n#include \"server.h\"\n#include \"smb_common.h\"\n#include \"connection.h\"\n#include \"mgmt/user_session.h\"\n#include \"mgmt/user_config.h\"\n#include \"crypto_ctx.h\"\n#include \"transport_ipc.h\"\n#include \"../common/arc4.h\"\n\n \nstatic char NEGOTIATE_GSS_HEADER[AUTH_GSS_LENGTH] = {\n#ifdef CONFIG_SMB_SERVER_KERBEROS5\n\t0x60, 0x5e, 0x06, 0x06, 0x2b, 0x06, 0x01, 0x05,\n\t0x05, 0x02, 0xa0, 0x54, 0x30, 0x52, 0xa0, 0x24,\n\t0x30, 0x22, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86,\n\t0xf7, 0x12, 0x01, 0x02, 0x02, 0x06, 0x09, 0x2a,\n\t0x86, 0x48, 0x82, 0xf7, 0x12, 0x01, 0x02, 0x02,\n\t0x06, 0x0a, 0x2b, 0x06, 0x01, 0x04, 0x01, 0x82,\n\t0x37, 0x02, 0x02, 0x0a, 0xa3, 0x2a, 0x30, 0x28,\n\t0xa0, 0x26, 0x1b, 0x24, 0x6e, 0x6f, 0x74, 0x5f,\n\t0x64, 0x65, 0x66, 0x69, 0x6e, 0x65, 0x64, 0x5f,\n\t0x69, 0x6e, 0x5f, 0x52, 0x46, 0x43, 0x34, 0x31,\n\t0x37, 0x38, 0x40, 0x70, 0x6c, 0x65, 0x61, 0x73,\n\t0x65, 0x5f, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65\n#else\n\t0x60, 0x48, 0x06, 0x06, 0x2b, 0x06, 0x01, 0x05,\n\t0x05, 0x02, 0xa0, 0x3e, 0x30, 0x3c, 0xa0, 0x0e,\n\t0x30, 0x0c, 0x06, 0x0a, 0x2b, 0x06, 0x01, 0x04,\n\t0x01, 0x82, 0x37, 0x02, 0x02, 0x0a, 0xa3, 0x2a,\n\t0x30, 0x28, 0xa0, 0x26, 0x1b, 0x24, 0x6e, 0x6f,\n\t0x74, 0x5f, 0x64, 0x65, 0x66, 0x69, 0x6e, 0x65,\n\t0x64, 0x5f, 0x69, 0x6e, 0x5f, 0x52, 0x46, 0x43,\n\t0x34, 0x31, 0x37, 0x38, 0x40, 0x70, 0x6c, 0x65,\n\t0x61, 0x73, 0x65, 0x5f, 0x69, 0x67, 0x6e, 0x6f,\n\t0x72, 0x65\n#endif\n};\n\nvoid ksmbd_copy_gss_neg_header(void *buf)\n{\n\tmemcpy(buf, NEGOTIATE_GSS_HEADER, AUTH_GSS_LENGTH);\n}\n\n \nstatic int ksmbd_gen_sess_key(struct ksmbd_session *sess, char *hash,\n\t\t\t      char *hmac)\n{\n\tstruct ksmbd_crypto_ctx *ctx;\n\tint rc;\n\n\tctx = ksmbd_crypto_ctx_find_hmacmd5();\n\tif (!ctx) {\n\t\tksmbd_debug(AUTH, \"could not crypto alloc hmacmd5\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\trc = crypto_shash_setkey(CRYPTO_HMACMD5_TFM(ctx),\n\t\t\t\t hash,\n\t\t\t\t CIFS_HMAC_MD5_HASH_SIZE);\n\tif (rc) {\n\t\tksmbd_debug(AUTH, \"hmacmd5 set key fail error %d\\n\", rc);\n\t\tgoto out;\n\t}\n\n\trc = crypto_shash_init(CRYPTO_HMACMD5(ctx));\n\tif (rc) {\n\t\tksmbd_debug(AUTH, \"could not init hmacmd5 error %d\\n\", rc);\n\t\tgoto out;\n\t}\n\n\trc = crypto_shash_update(CRYPTO_HMACMD5(ctx),\n\t\t\t\t hmac,\n\t\t\t\t SMB2_NTLMV2_SESSKEY_SIZE);\n\tif (rc) {\n\t\tksmbd_debug(AUTH, \"Could not update with response error %d\\n\", rc);\n\t\tgoto out;\n\t}\n\n\trc = crypto_shash_final(CRYPTO_HMACMD5(ctx), sess->sess_key);\n\tif (rc) {\n\t\tksmbd_debug(AUTH, \"Could not generate hmacmd5 hash error %d\\n\", rc);\n\t\tgoto out;\n\t}\n\nout:\n\tksmbd_release_crypto_ctx(ctx);\n\treturn rc;\n}\n\nstatic int calc_ntlmv2_hash(struct ksmbd_conn *conn, struct ksmbd_session *sess,\n\t\t\t    char *ntlmv2_hash, char *dname)\n{\n\tint ret, len, conv_len;\n\twchar_t *domain = NULL;\n\t__le16 *uniname = NULL;\n\tstruct ksmbd_crypto_ctx *ctx;\n\n\tctx = ksmbd_crypto_ctx_find_hmacmd5();\n\tif (!ctx) {\n\t\tksmbd_debug(AUTH, \"can't generate ntlmv2 hash\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = crypto_shash_setkey(CRYPTO_HMACMD5_TFM(ctx),\n\t\t\t\t  user_passkey(sess->user),\n\t\t\t\t  CIFS_ENCPWD_SIZE);\n\tif (ret) {\n\t\tksmbd_debug(AUTH, \"Could not set NT Hash as a key\\n\");\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_init(CRYPTO_HMACMD5(ctx));\n\tif (ret) {\n\t\tksmbd_debug(AUTH, \"could not init hmacmd5\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tlen = strlen(user_name(sess->user));\n\tuniname = kzalloc(2 + UNICODE_LEN(len), GFP_KERNEL);\n\tif (!uniname) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tconv_len = smb_strtoUTF16(uniname, user_name(sess->user), len,\n\t\t\t\t  conn->local_nls);\n\tif (conv_len < 0 || conv_len > len) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tUniStrupr(uniname);\n\n\tret = crypto_shash_update(CRYPTO_HMACMD5(ctx),\n\t\t\t\t  (char *)uniname,\n\t\t\t\t  UNICODE_LEN(conv_len));\n\tif (ret) {\n\t\tksmbd_debug(AUTH, \"Could not update with user\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tlen = strlen(dname);\n\tdomain = kzalloc(2 + UNICODE_LEN(len), GFP_KERNEL);\n\tif (!domain) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tconv_len = smb_strtoUTF16((__le16 *)domain, dname, len,\n\t\t\t\t  conn->local_nls);\n\tif (conv_len < 0 || conv_len > len) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_update(CRYPTO_HMACMD5(ctx),\n\t\t\t\t  (char *)domain,\n\t\t\t\t  UNICODE_LEN(conv_len));\n\tif (ret) {\n\t\tksmbd_debug(AUTH, \"Could not update with domain\\n\");\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_final(CRYPTO_HMACMD5(ctx), ntlmv2_hash);\n\tif (ret)\n\t\tksmbd_debug(AUTH, \"Could not generate md5 hash\\n\");\nout:\n\tkfree(uniname);\n\tkfree(domain);\n\tksmbd_release_crypto_ctx(ctx);\n\treturn ret;\n}\n\n \nint ksmbd_auth_ntlmv2(struct ksmbd_conn *conn, struct ksmbd_session *sess,\n\t\t      struct ntlmv2_resp *ntlmv2, int blen, char *domain_name,\n\t\t      char *cryptkey)\n{\n\tchar ntlmv2_hash[CIFS_ENCPWD_SIZE];\n\tchar ntlmv2_rsp[CIFS_HMAC_MD5_HASH_SIZE];\n\tstruct ksmbd_crypto_ctx *ctx = NULL;\n\tchar *construct = NULL;\n\tint rc, len;\n\n\trc = calc_ntlmv2_hash(conn, sess, ntlmv2_hash, domain_name);\n\tif (rc) {\n\t\tksmbd_debug(AUTH, \"could not get v2 hash rc %d\\n\", rc);\n\t\tgoto out;\n\t}\n\n\tctx = ksmbd_crypto_ctx_find_hmacmd5();\n\tif (!ctx) {\n\t\tksmbd_debug(AUTH, \"could not crypto alloc hmacmd5\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\trc = crypto_shash_setkey(CRYPTO_HMACMD5_TFM(ctx),\n\t\t\t\t ntlmv2_hash,\n\t\t\t\t CIFS_HMAC_MD5_HASH_SIZE);\n\tif (rc) {\n\t\tksmbd_debug(AUTH, \"Could not set NTLMV2 Hash as a key\\n\");\n\t\tgoto out;\n\t}\n\n\trc = crypto_shash_init(CRYPTO_HMACMD5(ctx));\n\tif (rc) {\n\t\tksmbd_debug(AUTH, \"Could not init hmacmd5\\n\");\n\t\tgoto out;\n\t}\n\n\tlen = CIFS_CRYPTO_KEY_SIZE + blen;\n\tconstruct = kzalloc(len, GFP_KERNEL);\n\tif (!construct) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmemcpy(construct, cryptkey, CIFS_CRYPTO_KEY_SIZE);\n\tmemcpy(construct + CIFS_CRYPTO_KEY_SIZE, &ntlmv2->blob_signature, blen);\n\n\trc = crypto_shash_update(CRYPTO_HMACMD5(ctx), construct, len);\n\tif (rc) {\n\t\tksmbd_debug(AUTH, \"Could not update with response\\n\");\n\t\tgoto out;\n\t}\n\n\trc = crypto_shash_final(CRYPTO_HMACMD5(ctx), ntlmv2_rsp);\n\tif (rc) {\n\t\tksmbd_debug(AUTH, \"Could not generate md5 hash\\n\");\n\t\tgoto out;\n\t}\n\tksmbd_release_crypto_ctx(ctx);\n\tctx = NULL;\n\n\trc = ksmbd_gen_sess_key(sess, ntlmv2_hash, ntlmv2_rsp);\n\tif (rc) {\n\t\tksmbd_debug(AUTH, \"Could not generate sess key\\n\");\n\t\tgoto out;\n\t}\n\n\tif (memcmp(ntlmv2->ntlmv2_hash, ntlmv2_rsp, CIFS_HMAC_MD5_HASH_SIZE) != 0)\n\t\trc = -EINVAL;\nout:\n\tif (ctx)\n\t\tksmbd_release_crypto_ctx(ctx);\n\tkfree(construct);\n\treturn rc;\n}\n\n \nint ksmbd_decode_ntlmssp_auth_blob(struct authenticate_message *authblob,\n\t\t\t\t   int blob_len, struct ksmbd_conn *conn,\n\t\t\t\t   struct ksmbd_session *sess)\n{\n\tchar *domain_name;\n\tunsigned int nt_off, dn_off;\n\tunsigned short nt_len, dn_len;\n\tint ret;\n\n\tif (blob_len < sizeof(struct authenticate_message)) {\n\t\tksmbd_debug(AUTH, \"negotiate blob len %d too small\\n\",\n\t\t\t    blob_len);\n\t\treturn -EINVAL;\n\t}\n\n\tif (memcmp(authblob->Signature, \"NTLMSSP\", 8)) {\n\t\tksmbd_debug(AUTH, \"blob signature incorrect %s\\n\",\n\t\t\t    authblob->Signature);\n\t\treturn -EINVAL;\n\t}\n\n\tnt_off = le32_to_cpu(authblob->NtChallengeResponse.BufferOffset);\n\tnt_len = le16_to_cpu(authblob->NtChallengeResponse.Length);\n\tdn_off = le32_to_cpu(authblob->DomainName.BufferOffset);\n\tdn_len = le16_to_cpu(authblob->DomainName.Length);\n\n\tif (blob_len < (u64)dn_off + dn_len || blob_len < (u64)nt_off + nt_len ||\n\t    nt_len < CIFS_ENCPWD_SIZE)\n\t\treturn -EINVAL;\n\n\t \n\tdomain_name = smb_strndup_from_utf16((const char *)authblob + dn_off,\n\t\t\t\t\t     dn_len, true, conn->local_nls);\n\tif (IS_ERR(domain_name))\n\t\treturn PTR_ERR(domain_name);\n\n\t \n\tksmbd_debug(AUTH, \"decode_ntlmssp_authenticate_blob dname%s\\n\",\n\t\t    domain_name);\n\tret = ksmbd_auth_ntlmv2(conn, sess,\n\t\t\t\t(struct ntlmv2_resp *)((char *)authblob + nt_off),\n\t\t\t\tnt_len - CIFS_ENCPWD_SIZE,\n\t\t\t\tdomain_name, conn->ntlmssp.cryptkey);\n\tkfree(domain_name);\n\n\t \n\tif (conn->ntlmssp.client_flags & NTLMSSP_NEGOTIATE_KEY_XCH) {\n\t\tstruct arc4_ctx *ctx_arc4;\n\t\tunsigned int sess_key_off, sess_key_len;\n\n\t\tsess_key_off = le32_to_cpu(authblob->SessionKey.BufferOffset);\n\t\tsess_key_len = le16_to_cpu(authblob->SessionKey.Length);\n\n\t\tif (blob_len < (u64)sess_key_off + sess_key_len)\n\t\t\treturn -EINVAL;\n\n\t\tif (sess_key_len > CIFS_KEY_SIZE)\n\t\t\treturn -EINVAL;\n\n\t\tctx_arc4 = kmalloc(sizeof(*ctx_arc4), GFP_KERNEL);\n\t\tif (!ctx_arc4)\n\t\t\treturn -ENOMEM;\n\n\t\tcifs_arc4_setkey(ctx_arc4, sess->sess_key,\n\t\t\t\t SMB2_NTLMV2_SESSKEY_SIZE);\n\t\tcifs_arc4_crypt(ctx_arc4, sess->sess_key,\n\t\t\t\t(char *)authblob + sess_key_off, sess_key_len);\n\t\tkfree_sensitive(ctx_arc4);\n\t}\n\n\treturn ret;\n}\n\n \nint ksmbd_decode_ntlmssp_neg_blob(struct negotiate_message *negblob,\n\t\t\t\t  int blob_len, struct ksmbd_conn *conn)\n{\n\tif (blob_len < sizeof(struct negotiate_message)) {\n\t\tksmbd_debug(AUTH, \"negotiate blob len %d too small\\n\",\n\t\t\t    blob_len);\n\t\treturn -EINVAL;\n\t}\n\n\tif (memcmp(negblob->Signature, \"NTLMSSP\", 8)) {\n\t\tksmbd_debug(AUTH, \"blob signature incorrect %s\\n\",\n\t\t\t    negblob->Signature);\n\t\treturn -EINVAL;\n\t}\n\n\tconn->ntlmssp.client_flags = le32_to_cpu(negblob->NegotiateFlags);\n\treturn 0;\n}\n\n \nunsigned int\nksmbd_build_ntlmssp_challenge_blob(struct challenge_message *chgblob,\n\t\t\t\t   struct ksmbd_conn *conn)\n{\n\tstruct target_info *tinfo;\n\twchar_t *name;\n\t__u8 *target_name;\n\tunsigned int flags, blob_off, blob_len, type, target_info_len = 0;\n\tint len, uni_len, conv_len;\n\tint cflags = conn->ntlmssp.client_flags;\n\n\tmemcpy(chgblob->Signature, NTLMSSP_SIGNATURE, 8);\n\tchgblob->MessageType = NtLmChallenge;\n\n\tflags = NTLMSSP_NEGOTIATE_UNICODE |\n\t\tNTLMSSP_NEGOTIATE_NTLM | NTLMSSP_TARGET_TYPE_SERVER |\n\t\tNTLMSSP_NEGOTIATE_TARGET_INFO;\n\n\tif (cflags & NTLMSSP_NEGOTIATE_SIGN) {\n\t\tflags |= NTLMSSP_NEGOTIATE_SIGN;\n\t\tflags |= cflags & (NTLMSSP_NEGOTIATE_128 |\n\t\t\t\t   NTLMSSP_NEGOTIATE_56);\n\t}\n\n\tif (cflags & NTLMSSP_NEGOTIATE_SEAL && smb3_encryption_negotiated(conn))\n\t\tflags |= NTLMSSP_NEGOTIATE_SEAL;\n\n\tif (cflags & NTLMSSP_NEGOTIATE_ALWAYS_SIGN)\n\t\tflags |= NTLMSSP_NEGOTIATE_ALWAYS_SIGN;\n\n\tif (cflags & NTLMSSP_REQUEST_TARGET)\n\t\tflags |= NTLMSSP_REQUEST_TARGET;\n\n\tif (conn->use_spnego &&\n\t    (cflags & NTLMSSP_NEGOTIATE_EXTENDED_SEC))\n\t\tflags |= NTLMSSP_NEGOTIATE_EXTENDED_SEC;\n\n\tif (cflags & NTLMSSP_NEGOTIATE_KEY_XCH)\n\t\tflags |= NTLMSSP_NEGOTIATE_KEY_XCH;\n\n\tchgblob->NegotiateFlags = cpu_to_le32(flags);\n\tlen = strlen(ksmbd_netbios_name());\n\tname = kmalloc(2 + UNICODE_LEN(len), GFP_KERNEL);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tconv_len = smb_strtoUTF16((__le16 *)name, ksmbd_netbios_name(), len,\n\t\t\t\t  conn->local_nls);\n\tif (conv_len < 0 || conv_len > len) {\n\t\tkfree(name);\n\t\treturn -EINVAL;\n\t}\n\n\tuni_len = UNICODE_LEN(conv_len);\n\n\tblob_off = sizeof(struct challenge_message);\n\tblob_len = blob_off + uni_len;\n\n\tchgblob->TargetName.Length = cpu_to_le16(uni_len);\n\tchgblob->TargetName.MaximumLength = cpu_to_le16(uni_len);\n\tchgblob->TargetName.BufferOffset = cpu_to_le32(blob_off);\n\n\t \n\tget_random_bytes(conn->ntlmssp.cryptkey, sizeof(__u64));\n\tmemcpy(chgblob->Challenge, conn->ntlmssp.cryptkey,\n\t       CIFS_CRYPTO_KEY_SIZE);\n\n\t \n\tchgblob->TargetInfoArray.BufferOffset = cpu_to_le32(blob_len);\n\n\ttarget_name = (__u8 *)chgblob + blob_off;\n\tmemcpy(target_name, name, uni_len);\n\ttinfo = (struct target_info *)(target_name + uni_len);\n\n\tchgblob->TargetInfoArray.Length = 0;\n\t \n\tfor (type = NTLMSSP_AV_NB_COMPUTER_NAME;\n\t     type <= NTLMSSP_AV_DNS_DOMAIN_NAME; type++) {\n\t\ttinfo->Type = cpu_to_le16(type);\n\t\ttinfo->Length = cpu_to_le16(uni_len);\n\t\tmemcpy(tinfo->Content, name, uni_len);\n\t\ttinfo = (struct target_info *)((char *)tinfo + 4 + uni_len);\n\t\ttarget_info_len += 4 + uni_len;\n\t}\n\n\t \n\ttinfo->Type = 0;\n\ttinfo->Length = 0;\n\ttarget_info_len += 4;\n\n\tchgblob->TargetInfoArray.Length = cpu_to_le16(target_info_len);\n\tchgblob->TargetInfoArray.MaximumLength = cpu_to_le16(target_info_len);\n\tblob_len += target_info_len;\n\tkfree(name);\n\tksmbd_debug(AUTH, \"NTLMSSP SecurityBufferLength %d\\n\", blob_len);\n\treturn blob_len;\n}\n\n#ifdef CONFIG_SMB_SERVER_KERBEROS5\nint ksmbd_krb5_authenticate(struct ksmbd_session *sess, char *in_blob,\n\t\t\t    int in_len, char *out_blob, int *out_len)\n{\n\tstruct ksmbd_spnego_authen_response *resp;\n\tstruct ksmbd_user *user = NULL;\n\tint retval;\n\n\tresp = ksmbd_ipc_spnego_authen_request(in_blob, in_len);\n\tif (!resp) {\n\t\tksmbd_debug(AUTH, \"SPNEGO_AUTHEN_REQUEST failure\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!(resp->login_response.status & KSMBD_USER_FLAG_OK)) {\n\t\tksmbd_debug(AUTH, \"krb5 authentication failure\\n\");\n\t\tretval = -EPERM;\n\t\tgoto out;\n\t}\n\n\tif (*out_len <= resp->spnego_blob_len) {\n\t\tksmbd_debug(AUTH, \"buf len %d, but blob len %d\\n\",\n\t\t\t    *out_len, resp->spnego_blob_len);\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (resp->session_key_len > sizeof(sess->sess_key)) {\n\t\tksmbd_debug(AUTH, \"session key is too long\\n\");\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tuser = ksmbd_alloc_user(&resp->login_response);\n\tif (!user) {\n\t\tksmbd_debug(AUTH, \"login failure\\n\");\n\t\tretval = -ENOMEM;\n\t\tgoto out;\n\t}\n\tsess->user = user;\n\n\tmemcpy(sess->sess_key, resp->payload, resp->session_key_len);\n\tmemcpy(out_blob, resp->payload + resp->session_key_len,\n\t       resp->spnego_blob_len);\n\t*out_len = resp->spnego_blob_len;\n\tretval = 0;\nout:\n\tkvfree(resp);\n\treturn retval;\n}\n#else\nint ksmbd_krb5_authenticate(struct ksmbd_session *sess, char *in_blob,\n\t\t\t    int in_len, char *out_blob, int *out_len)\n{\n\treturn -EOPNOTSUPP;\n}\n#endif\n\n \nint ksmbd_sign_smb2_pdu(struct ksmbd_conn *conn, char *key, struct kvec *iov,\n\t\t\tint n_vec, char *sig)\n{\n\tstruct ksmbd_crypto_ctx *ctx;\n\tint rc, i;\n\n\tctx = ksmbd_crypto_ctx_find_hmacsha256();\n\tif (!ctx) {\n\t\tksmbd_debug(AUTH, \"could not crypto alloc hmacmd5\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\trc = crypto_shash_setkey(CRYPTO_HMACSHA256_TFM(ctx),\n\t\t\t\t key,\n\t\t\t\t SMB2_NTLMV2_SESSKEY_SIZE);\n\tif (rc)\n\t\tgoto out;\n\n\trc = crypto_shash_init(CRYPTO_HMACSHA256(ctx));\n\tif (rc) {\n\t\tksmbd_debug(AUTH, \"hmacsha256 init error %d\\n\", rc);\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < n_vec; i++) {\n\t\trc = crypto_shash_update(CRYPTO_HMACSHA256(ctx),\n\t\t\t\t\t iov[i].iov_base,\n\t\t\t\t\t iov[i].iov_len);\n\t\tif (rc) {\n\t\t\tksmbd_debug(AUTH, \"hmacsha256 update error %d\\n\", rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\trc = crypto_shash_final(CRYPTO_HMACSHA256(ctx), sig);\n\tif (rc)\n\t\tksmbd_debug(AUTH, \"hmacsha256 generation error %d\\n\", rc);\nout:\n\tksmbd_release_crypto_ctx(ctx);\n\treturn rc;\n}\n\n \nint ksmbd_sign_smb3_pdu(struct ksmbd_conn *conn, char *key, struct kvec *iov,\n\t\t\tint n_vec, char *sig)\n{\n\tstruct ksmbd_crypto_ctx *ctx;\n\tint rc, i;\n\n\tctx = ksmbd_crypto_ctx_find_cmacaes();\n\tif (!ctx) {\n\t\tksmbd_debug(AUTH, \"could not crypto alloc cmac\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\trc = crypto_shash_setkey(CRYPTO_CMACAES_TFM(ctx),\n\t\t\t\t key,\n\t\t\t\t SMB2_CMACAES_SIZE);\n\tif (rc)\n\t\tgoto out;\n\n\trc = crypto_shash_init(CRYPTO_CMACAES(ctx));\n\tif (rc) {\n\t\tksmbd_debug(AUTH, \"cmaces init error %d\\n\", rc);\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < n_vec; i++) {\n\t\trc = crypto_shash_update(CRYPTO_CMACAES(ctx),\n\t\t\t\t\t iov[i].iov_base,\n\t\t\t\t\t iov[i].iov_len);\n\t\tif (rc) {\n\t\t\tksmbd_debug(AUTH, \"cmaces update error %d\\n\", rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\trc = crypto_shash_final(CRYPTO_CMACAES(ctx), sig);\n\tif (rc)\n\t\tksmbd_debug(AUTH, \"cmaces generation error %d\\n\", rc);\nout:\n\tksmbd_release_crypto_ctx(ctx);\n\treturn rc;\n}\n\nstruct derivation {\n\tstruct kvec label;\n\tstruct kvec context;\n\tbool binding;\n};\n\nstatic int generate_key(struct ksmbd_conn *conn, struct ksmbd_session *sess,\n\t\t\tstruct kvec label, struct kvec context, __u8 *key,\n\t\t\tunsigned int key_size)\n{\n\tunsigned char zero = 0x0;\n\t__u8 i[4] = {0, 0, 0, 1};\n\t__u8 L128[4] = {0, 0, 0, 128};\n\t__u8 L256[4] = {0, 0, 1, 0};\n\tint rc;\n\tunsigned char prfhash[SMB2_HMACSHA256_SIZE];\n\tunsigned char *hashptr = prfhash;\n\tstruct ksmbd_crypto_ctx *ctx;\n\n\tmemset(prfhash, 0x0, SMB2_HMACSHA256_SIZE);\n\tmemset(key, 0x0, key_size);\n\n\tctx = ksmbd_crypto_ctx_find_hmacsha256();\n\tif (!ctx) {\n\t\tksmbd_debug(AUTH, \"could not crypto alloc hmacmd5\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\trc = crypto_shash_setkey(CRYPTO_HMACSHA256_TFM(ctx),\n\t\t\t\t sess->sess_key,\n\t\t\t\t SMB2_NTLMV2_SESSKEY_SIZE);\n\tif (rc)\n\t\tgoto smb3signkey_ret;\n\n\trc = crypto_shash_init(CRYPTO_HMACSHA256(ctx));\n\tif (rc) {\n\t\tksmbd_debug(AUTH, \"hmacsha256 init error %d\\n\", rc);\n\t\tgoto smb3signkey_ret;\n\t}\n\n\trc = crypto_shash_update(CRYPTO_HMACSHA256(ctx), i, 4);\n\tif (rc) {\n\t\tksmbd_debug(AUTH, \"could not update with n\\n\");\n\t\tgoto smb3signkey_ret;\n\t}\n\n\trc = crypto_shash_update(CRYPTO_HMACSHA256(ctx),\n\t\t\t\t label.iov_base,\n\t\t\t\t label.iov_len);\n\tif (rc) {\n\t\tksmbd_debug(AUTH, \"could not update with label\\n\");\n\t\tgoto smb3signkey_ret;\n\t}\n\n\trc = crypto_shash_update(CRYPTO_HMACSHA256(ctx), &zero, 1);\n\tif (rc) {\n\t\tksmbd_debug(AUTH, \"could not update with zero\\n\");\n\t\tgoto smb3signkey_ret;\n\t}\n\n\trc = crypto_shash_update(CRYPTO_HMACSHA256(ctx),\n\t\t\t\t context.iov_base,\n\t\t\t\t context.iov_len);\n\tif (rc) {\n\t\tksmbd_debug(AUTH, \"could not update with context\\n\");\n\t\tgoto smb3signkey_ret;\n\t}\n\n\tif (key_size == SMB3_ENC_DEC_KEY_SIZE &&\n\t    (conn->cipher_type == SMB2_ENCRYPTION_AES256_CCM ||\n\t     conn->cipher_type == SMB2_ENCRYPTION_AES256_GCM))\n\t\trc = crypto_shash_update(CRYPTO_HMACSHA256(ctx), L256, 4);\n\telse\n\t\trc = crypto_shash_update(CRYPTO_HMACSHA256(ctx), L128, 4);\n\tif (rc) {\n\t\tksmbd_debug(AUTH, \"could not update with L\\n\");\n\t\tgoto smb3signkey_ret;\n\t}\n\n\trc = crypto_shash_final(CRYPTO_HMACSHA256(ctx), hashptr);\n\tif (rc) {\n\t\tksmbd_debug(AUTH, \"Could not generate hmacmd5 hash error %d\\n\",\n\t\t\t    rc);\n\t\tgoto smb3signkey_ret;\n\t}\n\n\tmemcpy(key, hashptr, key_size);\n\nsmb3signkey_ret:\n\tksmbd_release_crypto_ctx(ctx);\n\treturn rc;\n}\n\nstatic int generate_smb3signingkey(struct ksmbd_session *sess,\n\t\t\t\t   struct ksmbd_conn *conn,\n\t\t\t\t   const struct derivation *signing)\n{\n\tint rc;\n\tstruct channel *chann;\n\tchar *key;\n\n\tchann = lookup_chann_list(sess, conn);\n\tif (!chann)\n\t\treturn 0;\n\n\tif (conn->dialect >= SMB30_PROT_ID && signing->binding)\n\t\tkey = chann->smb3signingkey;\n\telse\n\t\tkey = sess->smb3signingkey;\n\n\trc = generate_key(conn, sess, signing->label, signing->context, key,\n\t\t\t  SMB3_SIGN_KEY_SIZE);\n\tif (rc)\n\t\treturn rc;\n\n\tif (!(conn->dialect >= SMB30_PROT_ID && signing->binding))\n\t\tmemcpy(chann->smb3signingkey, key, SMB3_SIGN_KEY_SIZE);\n\n\tksmbd_debug(AUTH, \"dumping generated AES signing keys\\n\");\n\tksmbd_debug(AUTH, \"Session Id    %llu\\n\", sess->id);\n\tksmbd_debug(AUTH, \"Session Key   %*ph\\n\",\n\t\t    SMB2_NTLMV2_SESSKEY_SIZE, sess->sess_key);\n\tksmbd_debug(AUTH, \"Signing Key   %*ph\\n\",\n\t\t    SMB3_SIGN_KEY_SIZE, key);\n\treturn 0;\n}\n\nint ksmbd_gen_smb30_signingkey(struct ksmbd_session *sess,\n\t\t\t       struct ksmbd_conn *conn)\n{\n\tstruct derivation d;\n\n\td.label.iov_base = \"SMB2AESCMAC\";\n\td.label.iov_len = 12;\n\td.context.iov_base = \"SmbSign\";\n\td.context.iov_len = 8;\n\td.binding = conn->binding;\n\n\treturn generate_smb3signingkey(sess, conn, &d);\n}\n\nint ksmbd_gen_smb311_signingkey(struct ksmbd_session *sess,\n\t\t\t\tstruct ksmbd_conn *conn)\n{\n\tstruct derivation d;\n\n\td.label.iov_base = \"SMBSigningKey\";\n\td.label.iov_len = 14;\n\tif (conn->binding) {\n\t\tstruct preauth_session *preauth_sess;\n\n\t\tpreauth_sess = ksmbd_preauth_session_lookup(conn, sess->id);\n\t\tif (!preauth_sess)\n\t\t\treturn -ENOENT;\n\t\td.context.iov_base = preauth_sess->Preauth_HashValue;\n\t} else {\n\t\td.context.iov_base = sess->Preauth_HashValue;\n\t}\n\td.context.iov_len = 64;\n\td.binding = conn->binding;\n\n\treturn generate_smb3signingkey(sess, conn, &d);\n}\n\nstruct derivation_twin {\n\tstruct derivation encryption;\n\tstruct derivation decryption;\n};\n\nstatic int generate_smb3encryptionkey(struct ksmbd_conn *conn,\n\t\t\t\t      struct ksmbd_session *sess,\n\t\t\t\t      const struct derivation_twin *ptwin)\n{\n\tint rc;\n\n\trc = generate_key(conn, sess, ptwin->encryption.label,\n\t\t\t  ptwin->encryption.context, sess->smb3encryptionkey,\n\t\t\t  SMB3_ENC_DEC_KEY_SIZE);\n\tif (rc)\n\t\treturn rc;\n\n\trc = generate_key(conn, sess, ptwin->decryption.label,\n\t\t\t  ptwin->decryption.context,\n\t\t\t  sess->smb3decryptionkey, SMB3_ENC_DEC_KEY_SIZE);\n\tif (rc)\n\t\treturn rc;\n\n\tksmbd_debug(AUTH, \"dumping generated AES encryption keys\\n\");\n\tksmbd_debug(AUTH, \"Cipher type   %d\\n\", conn->cipher_type);\n\tksmbd_debug(AUTH, \"Session Id    %llu\\n\", sess->id);\n\tksmbd_debug(AUTH, \"Session Key   %*ph\\n\",\n\t\t    SMB2_NTLMV2_SESSKEY_SIZE, sess->sess_key);\n\tif (conn->cipher_type == SMB2_ENCRYPTION_AES256_CCM ||\n\t    conn->cipher_type == SMB2_ENCRYPTION_AES256_GCM) {\n\t\tksmbd_debug(AUTH, \"ServerIn Key  %*ph\\n\",\n\t\t\t    SMB3_GCM256_CRYPTKEY_SIZE, sess->smb3encryptionkey);\n\t\tksmbd_debug(AUTH, \"ServerOut Key %*ph\\n\",\n\t\t\t    SMB3_GCM256_CRYPTKEY_SIZE, sess->smb3decryptionkey);\n\t} else {\n\t\tksmbd_debug(AUTH, \"ServerIn Key  %*ph\\n\",\n\t\t\t    SMB3_GCM128_CRYPTKEY_SIZE, sess->smb3encryptionkey);\n\t\tksmbd_debug(AUTH, \"ServerOut Key %*ph\\n\",\n\t\t\t    SMB3_GCM128_CRYPTKEY_SIZE, sess->smb3decryptionkey);\n\t}\n\treturn 0;\n}\n\nint ksmbd_gen_smb30_encryptionkey(struct ksmbd_conn *conn,\n\t\t\t\t  struct ksmbd_session *sess)\n{\n\tstruct derivation_twin twin;\n\tstruct derivation *d;\n\n\td = &twin.encryption;\n\td->label.iov_base = \"SMB2AESCCM\";\n\td->label.iov_len = 11;\n\td->context.iov_base = \"ServerOut\";\n\td->context.iov_len = 10;\n\n\td = &twin.decryption;\n\td->label.iov_base = \"SMB2AESCCM\";\n\td->label.iov_len = 11;\n\td->context.iov_base = \"ServerIn \";\n\td->context.iov_len = 10;\n\n\treturn generate_smb3encryptionkey(conn, sess, &twin);\n}\n\nint ksmbd_gen_smb311_encryptionkey(struct ksmbd_conn *conn,\n\t\t\t\t   struct ksmbd_session *sess)\n{\n\tstruct derivation_twin twin;\n\tstruct derivation *d;\n\n\td = &twin.encryption;\n\td->label.iov_base = \"SMBS2CCipherKey\";\n\td->label.iov_len = 16;\n\td->context.iov_base = sess->Preauth_HashValue;\n\td->context.iov_len = 64;\n\n\td = &twin.decryption;\n\td->label.iov_base = \"SMBC2SCipherKey\";\n\td->label.iov_len = 16;\n\td->context.iov_base = sess->Preauth_HashValue;\n\td->context.iov_len = 64;\n\n\treturn generate_smb3encryptionkey(conn, sess, &twin);\n}\n\nint ksmbd_gen_preauth_integrity_hash(struct ksmbd_conn *conn, char *buf,\n\t\t\t\t     __u8 *pi_hash)\n{\n\tint rc;\n\tstruct smb2_hdr *rcv_hdr = smb2_get_msg(buf);\n\tchar *all_bytes_msg = (char *)&rcv_hdr->ProtocolId;\n\tint msg_size = get_rfc1002_len(buf);\n\tstruct ksmbd_crypto_ctx *ctx = NULL;\n\n\tif (conn->preauth_info->Preauth_HashId !=\n\t    SMB2_PREAUTH_INTEGRITY_SHA512)\n\t\treturn -EINVAL;\n\n\tctx = ksmbd_crypto_ctx_find_sha512();\n\tif (!ctx) {\n\t\tksmbd_debug(AUTH, \"could not alloc sha512\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\trc = crypto_shash_init(CRYPTO_SHA512(ctx));\n\tif (rc) {\n\t\tksmbd_debug(AUTH, \"could not init shashn\");\n\t\tgoto out;\n\t}\n\n\trc = crypto_shash_update(CRYPTO_SHA512(ctx), pi_hash, 64);\n\tif (rc) {\n\t\tksmbd_debug(AUTH, \"could not update with n\\n\");\n\t\tgoto out;\n\t}\n\n\trc = crypto_shash_update(CRYPTO_SHA512(ctx), all_bytes_msg, msg_size);\n\tif (rc) {\n\t\tksmbd_debug(AUTH, \"could not update with n\\n\");\n\t\tgoto out;\n\t}\n\n\trc = crypto_shash_final(CRYPTO_SHA512(ctx), pi_hash);\n\tif (rc) {\n\t\tksmbd_debug(AUTH, \"Could not generate hash err : %d\\n\", rc);\n\t\tgoto out;\n\t}\nout:\n\tksmbd_release_crypto_ctx(ctx);\n\treturn rc;\n}\n\nint ksmbd_gen_sd_hash(struct ksmbd_conn *conn, char *sd_buf, int len,\n\t\t      __u8 *pi_hash)\n{\n\tint rc;\n\tstruct ksmbd_crypto_ctx *ctx = NULL;\n\n\tctx = ksmbd_crypto_ctx_find_sha256();\n\tif (!ctx) {\n\t\tksmbd_debug(AUTH, \"could not alloc sha256\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\trc = crypto_shash_init(CRYPTO_SHA256(ctx));\n\tif (rc) {\n\t\tksmbd_debug(AUTH, \"could not init shashn\");\n\t\tgoto out;\n\t}\n\n\trc = crypto_shash_update(CRYPTO_SHA256(ctx), sd_buf, len);\n\tif (rc) {\n\t\tksmbd_debug(AUTH, \"could not update with n\\n\");\n\t\tgoto out;\n\t}\n\n\trc = crypto_shash_final(CRYPTO_SHA256(ctx), pi_hash);\n\tif (rc) {\n\t\tksmbd_debug(AUTH, \"Could not generate hash err : %d\\n\", rc);\n\t\tgoto out;\n\t}\nout:\n\tksmbd_release_crypto_ctx(ctx);\n\treturn rc;\n}\n\nstatic int ksmbd_get_encryption_key(struct ksmbd_work *work, __u64 ses_id,\n\t\t\t\t    int enc, u8 *key)\n{\n\tstruct ksmbd_session *sess;\n\tu8 *ses_enc_key;\n\n\tif (enc)\n\t\tsess = work->sess;\n\telse\n\t\tsess = ksmbd_session_lookup_all(work->conn, ses_id);\n\tif (!sess)\n\t\treturn -EINVAL;\n\n\tses_enc_key = enc ? sess->smb3encryptionkey :\n\t\tsess->smb3decryptionkey;\n\tmemcpy(key, ses_enc_key, SMB3_ENC_DEC_KEY_SIZE);\n\n\treturn 0;\n}\n\nstatic inline void smb2_sg_set_buf(struct scatterlist *sg, const void *buf,\n\t\t\t\t   unsigned int buflen)\n{\n\tvoid *addr;\n\n\tif (is_vmalloc_addr(buf))\n\t\taddr = vmalloc_to_page(buf);\n\telse\n\t\taddr = virt_to_page(buf);\n\tsg_set_page(sg, addr, buflen, offset_in_page(buf));\n}\n\nstatic struct scatterlist *ksmbd_init_sg(struct kvec *iov, unsigned int nvec,\n\t\t\t\t\t u8 *sign)\n{\n\tstruct scatterlist *sg;\n\tunsigned int assoc_data_len = sizeof(struct smb2_transform_hdr) - 20;\n\tint i, *nr_entries, total_entries = 0, sg_idx = 0;\n\n\tif (!nvec)\n\t\treturn NULL;\n\n\tnr_entries = kcalloc(nvec, sizeof(int), GFP_KERNEL);\n\tif (!nr_entries)\n\t\treturn NULL;\n\n\tfor (i = 0; i < nvec - 1; i++) {\n\t\tunsigned long kaddr = (unsigned long)iov[i + 1].iov_base;\n\n\t\tif (is_vmalloc_addr(iov[i + 1].iov_base)) {\n\t\t\tnr_entries[i] = ((kaddr + iov[i + 1].iov_len +\n\t\t\t\t\tPAGE_SIZE - 1) >> PAGE_SHIFT) -\n\t\t\t\t(kaddr >> PAGE_SHIFT);\n\t\t} else {\n\t\t\tnr_entries[i]++;\n\t\t}\n\t\ttotal_entries += nr_entries[i];\n\t}\n\n\t \n\ttotal_entries += 2;\n\n\tsg = kmalloc_array(total_entries, sizeof(struct scatterlist), GFP_KERNEL);\n\tif (!sg) {\n\t\tkfree(nr_entries);\n\t\treturn NULL;\n\t}\n\n\tsg_init_table(sg, total_entries);\n\tsmb2_sg_set_buf(&sg[sg_idx++], iov[0].iov_base + 24, assoc_data_len);\n\tfor (i = 0; i < nvec - 1; i++) {\n\t\tvoid *data = iov[i + 1].iov_base;\n\t\tint len = iov[i + 1].iov_len;\n\n\t\tif (is_vmalloc_addr(data)) {\n\t\t\tint j, offset = offset_in_page(data);\n\n\t\t\tfor (j = 0; j < nr_entries[i]; j++) {\n\t\t\t\tunsigned int bytes = PAGE_SIZE - offset;\n\n\t\t\t\tif (!len)\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (bytes > len)\n\t\t\t\t\tbytes = len;\n\n\t\t\t\tsg_set_page(&sg[sg_idx++],\n\t\t\t\t\t    vmalloc_to_page(data), bytes,\n\t\t\t\t\t    offset_in_page(data));\n\n\t\t\t\tdata += bytes;\n\t\t\t\tlen -= bytes;\n\t\t\t\toffset = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tsg_set_page(&sg[sg_idx++], virt_to_page(data), len,\n\t\t\t\t    offset_in_page(data));\n\t\t}\n\t}\n\tsmb2_sg_set_buf(&sg[sg_idx], sign, SMB2_SIGNATURE_SIZE);\n\tkfree(nr_entries);\n\treturn sg;\n}\n\nint ksmbd_crypt_message(struct ksmbd_work *work, struct kvec *iov,\n\t\t\tunsigned int nvec, int enc)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct smb2_transform_hdr *tr_hdr = smb2_get_msg(iov[0].iov_base);\n\tunsigned int assoc_data_len = sizeof(struct smb2_transform_hdr) - 20;\n\tint rc;\n\tstruct scatterlist *sg;\n\tu8 sign[SMB2_SIGNATURE_SIZE] = {};\n\tu8 key[SMB3_ENC_DEC_KEY_SIZE];\n\tstruct aead_request *req;\n\tchar *iv;\n\tunsigned int iv_len;\n\tstruct crypto_aead *tfm;\n\tunsigned int crypt_len = le32_to_cpu(tr_hdr->OriginalMessageSize);\n\tstruct ksmbd_crypto_ctx *ctx;\n\n\trc = ksmbd_get_encryption_key(work,\n\t\t\t\t      le64_to_cpu(tr_hdr->SessionId),\n\t\t\t\t      enc,\n\t\t\t\t      key);\n\tif (rc) {\n\t\tpr_err(\"Could not get %scryption key\\n\", enc ? \"en\" : \"de\");\n\t\treturn rc;\n\t}\n\n\tif (conn->cipher_type == SMB2_ENCRYPTION_AES128_GCM ||\n\t    conn->cipher_type == SMB2_ENCRYPTION_AES256_GCM)\n\t\tctx = ksmbd_crypto_ctx_find_gcm();\n\telse\n\t\tctx = ksmbd_crypto_ctx_find_ccm();\n\tif (!ctx) {\n\t\tpr_err(\"crypto alloc failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (conn->cipher_type == SMB2_ENCRYPTION_AES128_GCM ||\n\t    conn->cipher_type == SMB2_ENCRYPTION_AES256_GCM)\n\t\ttfm = CRYPTO_GCM(ctx);\n\telse\n\t\ttfm = CRYPTO_CCM(ctx);\n\n\tif (conn->cipher_type == SMB2_ENCRYPTION_AES256_CCM ||\n\t    conn->cipher_type == SMB2_ENCRYPTION_AES256_GCM)\n\t\trc = crypto_aead_setkey(tfm, key, SMB3_GCM256_CRYPTKEY_SIZE);\n\telse\n\t\trc = crypto_aead_setkey(tfm, key, SMB3_GCM128_CRYPTKEY_SIZE);\n\tif (rc) {\n\t\tpr_err(\"Failed to set aead key %d\\n\", rc);\n\t\tgoto free_ctx;\n\t}\n\n\trc = crypto_aead_setauthsize(tfm, SMB2_SIGNATURE_SIZE);\n\tif (rc) {\n\t\tpr_err(\"Failed to set authsize %d\\n\", rc);\n\t\tgoto free_ctx;\n\t}\n\n\treq = aead_request_alloc(tfm, GFP_KERNEL);\n\tif (!req) {\n\t\trc = -ENOMEM;\n\t\tgoto free_ctx;\n\t}\n\n\tif (!enc) {\n\t\tmemcpy(sign, &tr_hdr->Signature, SMB2_SIGNATURE_SIZE);\n\t\tcrypt_len += SMB2_SIGNATURE_SIZE;\n\t}\n\n\tsg = ksmbd_init_sg(iov, nvec, sign);\n\tif (!sg) {\n\t\tpr_err(\"Failed to init sg\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto free_req;\n\t}\n\n\tiv_len = crypto_aead_ivsize(tfm);\n\tiv = kzalloc(iv_len, GFP_KERNEL);\n\tif (!iv) {\n\t\trc = -ENOMEM;\n\t\tgoto free_sg;\n\t}\n\n\tif (conn->cipher_type == SMB2_ENCRYPTION_AES128_GCM ||\n\t    conn->cipher_type == SMB2_ENCRYPTION_AES256_GCM) {\n\t\tmemcpy(iv, (char *)tr_hdr->Nonce, SMB3_AES_GCM_NONCE);\n\t} else {\n\t\tiv[0] = 3;\n\t\tmemcpy(iv + 1, (char *)tr_hdr->Nonce, SMB3_AES_CCM_NONCE);\n\t}\n\n\taead_request_set_crypt(req, sg, sg, crypt_len, iv);\n\taead_request_set_ad(req, assoc_data_len);\n\taead_request_set_callback(req, CRYPTO_TFM_REQ_MAY_SLEEP, NULL, NULL);\n\n\tif (enc)\n\t\trc = crypto_aead_encrypt(req);\n\telse\n\t\trc = crypto_aead_decrypt(req);\n\tif (rc)\n\t\tgoto free_iv;\n\n\tif (enc)\n\t\tmemcpy(&tr_hdr->Signature, sign, SMB2_SIGNATURE_SIZE);\n\nfree_iv:\n\tkfree(iv);\nfree_sg:\n\tkfree(sg);\nfree_req:\n\tkfree(req);\nfree_ctx:\n\tksmbd_release_crypto_ctx(ctx);\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}