{
  "module_name": "smb2misc.c",
  "hash_id": "eae839e5753a7c1afcef1bb53963d11c739db3b5a4d8f99cf48a223ad2a25628",
  "original_prompt": "Ingested from linux-6.6.14/fs/smb/server/smb2misc.c",
  "human_readable_source": "\n \n\n#include \"glob.h\"\n#include \"nterr.h\"\n#include \"smb_common.h\"\n#include \"smbstatus.h\"\n#include \"mgmt/user_session.h\"\n#include \"connection.h\"\n\nstatic int check_smb2_hdr(struct smb2_hdr *hdr)\n{\n\t \n\tif (hdr->Flags & SMB2_FLAGS_SERVER_TO_REDIR)\n\t\treturn 1;\n\treturn 0;\n}\n\n \nstatic const __le16 smb2_req_struct_sizes[NUMBER_OF_SMB2_COMMANDS] = {\n\t  cpu_to_le16(36),\n\t  cpu_to_le16(25),\n\t  cpu_to_le16(4),\n\t  cpu_to_le16(9),\n\t  cpu_to_le16(4),\n\t  cpu_to_le16(57),\n\t  cpu_to_le16(24),\n\t  cpu_to_le16(24),\n\t  cpu_to_le16(49),\n\t  cpu_to_le16(49),\n\t  cpu_to_le16(48),\n\t  cpu_to_le16(57),\n\t  cpu_to_le16(4),\n\t  cpu_to_le16(4),\n\t  cpu_to_le16(33),\n\t  cpu_to_le16(32),\n\t  cpu_to_le16(41),\n\t  cpu_to_le16(33),\n\t \n\t  cpu_to_le16(36)\n};\n\n \nstatic const bool has_smb2_data_area[NUMBER_OF_SMB2_COMMANDS] = {\n\t  true,\n\t  true,\n\t  false,\n\t \ttrue,\n\t  false,\n\t  true,\n\t  false,\n\t  false,\n\t \ttrue,\n\t  true,\n\t \ttrue,\n\t  true,\n\t  false,  \n\t  false,\n\t  true,\n\t  false,\n\t  true,\n\t  true,\n\t  false\n};\n\n \nstatic int smb2_get_data_area_len(unsigned int *off, unsigned int *len,\n\t\t\t\t  struct smb2_hdr *hdr)\n{\n\tint ret = 0;\n\n\t*off = 0;\n\t*len = 0;\n\n\t \n\tswitch (hdr->Command) {\n\tcase SMB2_SESSION_SETUP:\n\t\t*off = le16_to_cpu(((struct smb2_sess_setup_req *)hdr)->SecurityBufferOffset);\n\t\t*len = le16_to_cpu(((struct smb2_sess_setup_req *)hdr)->SecurityBufferLength);\n\t\tbreak;\n\tcase SMB2_TREE_CONNECT:\n\t\t*off = le16_to_cpu(((struct smb2_tree_connect_req *)hdr)->PathOffset);\n\t\t*len = le16_to_cpu(((struct smb2_tree_connect_req *)hdr)->PathLength);\n\t\tbreak;\n\tcase SMB2_CREATE:\n\t{\n\t\tunsigned short int name_off =\n\t\t\tle16_to_cpu(((struct smb2_create_req *)hdr)->NameOffset);\n\t\tunsigned short int name_len =\n\t\t\tle16_to_cpu(((struct smb2_create_req *)hdr)->NameLength);\n\n\t\tif (((struct smb2_create_req *)hdr)->CreateContextsLength) {\n\t\t\t*off = le32_to_cpu(((struct smb2_create_req *)\n\t\t\t\thdr)->CreateContextsOffset);\n\t\t\t*len = le32_to_cpu(((struct smb2_create_req *)\n\t\t\t\thdr)->CreateContextsLength);\n\t\t\tif (!name_len)\n\t\t\t\tbreak;\n\n\t\t\tif (name_off + name_len < (u64)*off + *len)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t*off = name_off;\n\t\t*len = name_len;\n\t\tbreak;\n\t}\n\tcase SMB2_QUERY_INFO:\n\t\t*off = le16_to_cpu(((struct smb2_query_info_req *)hdr)->InputBufferOffset);\n\t\t*len = le32_to_cpu(((struct smb2_query_info_req *)hdr)->InputBufferLength);\n\t\tbreak;\n\tcase SMB2_SET_INFO:\n\t\t*off = le16_to_cpu(((struct smb2_set_info_req *)hdr)->BufferOffset);\n\t\t*len = le32_to_cpu(((struct smb2_set_info_req *)hdr)->BufferLength);\n\t\tbreak;\n\tcase SMB2_READ:\n\t\t*off = le16_to_cpu(((struct smb2_read_req *)hdr)->ReadChannelInfoOffset);\n\t\t*len = le16_to_cpu(((struct smb2_read_req *)hdr)->ReadChannelInfoLength);\n\t\tbreak;\n\tcase SMB2_WRITE:\n\t\tif (((struct smb2_write_req *)hdr)->DataOffset ||\n\t\t    ((struct smb2_write_req *)hdr)->Length) {\n\t\t\t*off = max_t(unsigned int,\n\t\t\t\t     le16_to_cpu(((struct smb2_write_req *)hdr)->DataOffset),\n\t\t\t\t     offsetof(struct smb2_write_req, Buffer));\n\t\t\t*len = le32_to_cpu(((struct smb2_write_req *)hdr)->Length);\n\t\t\tbreak;\n\t\t}\n\n\t\t*off = le16_to_cpu(((struct smb2_write_req *)hdr)->WriteChannelInfoOffset);\n\t\t*len = le16_to_cpu(((struct smb2_write_req *)hdr)->WriteChannelInfoLength);\n\t\tbreak;\n\tcase SMB2_QUERY_DIRECTORY:\n\t\t*off = le16_to_cpu(((struct smb2_query_directory_req *)hdr)->FileNameOffset);\n\t\t*len = le16_to_cpu(((struct smb2_query_directory_req *)hdr)->FileNameLength);\n\t\tbreak;\n\tcase SMB2_LOCK:\n\t{\n\t\tunsigned short lock_count;\n\n\t\tlock_count = le16_to_cpu(((struct smb2_lock_req *)hdr)->LockCount);\n\t\tif (lock_count > 0) {\n\t\t\t*off = offsetof(struct smb2_lock_req, locks);\n\t\t\t*len = sizeof(struct smb2_lock_element) * lock_count;\n\t\t}\n\t\tbreak;\n\t}\n\tcase SMB2_IOCTL:\n\t\t*off = le32_to_cpu(((struct smb2_ioctl_req *)hdr)->InputOffset);\n\t\t*len = le32_to_cpu(((struct smb2_ioctl_req *)hdr)->InputCount);\n\t\tbreak;\n\tdefault:\n\t\tksmbd_debug(SMB, \"no length check for command\\n\");\n\t\tbreak;\n\t}\n\n\tif (*off > 4096) {\n\t\tksmbd_debug(SMB, \"offset %d too large\\n\", *off);\n\t\tret = -EINVAL;\n\t} else if ((u64)*off + *len > MAX_STREAM_PROT_LEN) {\n\t\tksmbd_debug(SMB, \"Request is larger than maximum stream protocol length(%u): %llu\\n\",\n\t\t\t    MAX_STREAM_PROT_LEN, (u64)*off + *len);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int smb2_calc_size(void *buf, unsigned int *len)\n{\n\tstruct smb2_pdu *pdu = (struct smb2_pdu *)buf;\n\tstruct smb2_hdr *hdr = &pdu->hdr;\n\tunsigned int offset;  \n\tunsigned int data_length;  \n\tint ret;\n\n\t \n\t*len = le16_to_cpu(hdr->StructureSize);\n\n\t \n\t*len += le16_to_cpu(pdu->StructureSize2);\n\t \n\tif (hdr->Command == SMB2_LOCK)\n\t\t*len -= sizeof(struct smb2_lock_element);\n\n\tif (has_smb2_data_area[le16_to_cpu(hdr->Command)] == false)\n\t\tgoto calc_size_exit;\n\n\tret = smb2_get_data_area_len(&offset, &data_length, hdr);\n\tif (ret)\n\t\treturn ret;\n\tksmbd_debug(SMB, \"SMB2 data length %u offset %u\\n\", data_length,\n\t\t    offset);\n\n\tif (data_length > 0) {\n\t\t \n\t\tif (offset + 1 < *len) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"data area offset %d overlaps SMB2 header %u\\n\",\n\t\t\t\t    offset + 1, *len);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t*len = offset + data_length;\n\t}\n\ncalc_size_exit:\n\tksmbd_debug(SMB, \"SMB2 len %u\\n\", *len);\n\treturn 0;\n}\n\nstatic inline int smb2_query_info_req_len(struct smb2_query_info_req *h)\n{\n\treturn le32_to_cpu(h->InputBufferLength) +\n\t\tle32_to_cpu(h->OutputBufferLength);\n}\n\nstatic inline int smb2_set_info_req_len(struct smb2_set_info_req *h)\n{\n\treturn le32_to_cpu(h->BufferLength);\n}\n\nstatic inline int smb2_read_req_len(struct smb2_read_req *h)\n{\n\treturn le32_to_cpu(h->Length);\n}\n\nstatic inline int smb2_write_req_len(struct smb2_write_req *h)\n{\n\treturn le32_to_cpu(h->Length);\n}\n\nstatic inline int smb2_query_dir_req_len(struct smb2_query_directory_req *h)\n{\n\treturn le32_to_cpu(h->OutputBufferLength);\n}\n\nstatic inline int smb2_ioctl_req_len(struct smb2_ioctl_req *h)\n{\n\treturn le32_to_cpu(h->InputCount) +\n\t\tle32_to_cpu(h->OutputCount);\n}\n\nstatic inline int smb2_ioctl_resp_len(struct smb2_ioctl_req *h)\n{\n\treturn le32_to_cpu(h->MaxInputResponse) +\n\t\tle32_to_cpu(h->MaxOutputResponse);\n}\n\nstatic int smb2_validate_credit_charge(struct ksmbd_conn *conn,\n\t\t\t\t       struct smb2_hdr *hdr)\n{\n\tunsigned int req_len = 0, expect_resp_len = 0, calc_credit_num, max_len;\n\tunsigned short credit_charge = le16_to_cpu(hdr->CreditCharge);\n\tvoid *__hdr = hdr;\n\tint ret = 0;\n\n\tswitch (hdr->Command) {\n\tcase SMB2_QUERY_INFO:\n\t\treq_len = smb2_query_info_req_len(__hdr);\n\t\tbreak;\n\tcase SMB2_SET_INFO:\n\t\treq_len = smb2_set_info_req_len(__hdr);\n\t\tbreak;\n\tcase SMB2_READ:\n\t\treq_len = smb2_read_req_len(__hdr);\n\t\tbreak;\n\tcase SMB2_WRITE:\n\t\treq_len = smb2_write_req_len(__hdr);\n\t\tbreak;\n\tcase SMB2_QUERY_DIRECTORY:\n\t\treq_len = smb2_query_dir_req_len(__hdr);\n\t\tbreak;\n\tcase SMB2_IOCTL:\n\t\treq_len = smb2_ioctl_req_len(__hdr);\n\t\texpect_resp_len = smb2_ioctl_resp_len(__hdr);\n\t\tbreak;\n\tcase SMB2_CANCEL:\n\t\treturn 0;\n\tdefault:\n\t\treq_len = 1;\n\t\tbreak;\n\t}\n\n\tcredit_charge = max_t(unsigned short, credit_charge, 1);\n\tmax_len = max_t(unsigned int, req_len, expect_resp_len);\n\tcalc_credit_num = DIV_ROUND_UP(max_len, SMB2_MAX_BUFFER_SIZE);\n\n\tif (credit_charge < calc_credit_num) {\n\t\tksmbd_debug(SMB, \"Insufficient credit charge, given: %d, needed: %d\\n\",\n\t\t\t    credit_charge, calc_credit_num);\n\t\treturn 1;\n\t} else if (credit_charge > conn->vals->max_credits) {\n\t\tksmbd_debug(SMB, \"Too large credit charge: %d\\n\", credit_charge);\n\t\treturn 1;\n\t}\n\n\tspin_lock(&conn->credits_lock);\n\tif (credit_charge > conn->total_credits) {\n\t\tksmbd_debug(SMB, \"Insufficient credits granted, given: %u, granted: %u\\n\",\n\t\t\t    credit_charge, conn->total_credits);\n\t\tret = 1;\n\t}\n\n\tif ((u64)conn->outstanding_credits + credit_charge > conn->total_credits) {\n\t\tksmbd_debug(SMB, \"Limits exceeding the maximum allowable outstanding requests, given : %u, pending : %u\\n\",\n\t\t\t    credit_charge, conn->outstanding_credits);\n\t\tret = 1;\n\t} else\n\t\tconn->outstanding_credits += credit_charge;\n\n\tspin_unlock(&conn->credits_lock);\n\n\treturn ret;\n}\n\nint ksmbd_smb2_check_message(struct ksmbd_work *work)\n{\n\tstruct smb2_pdu *pdu = ksmbd_req_buf_next(work);\n\tstruct smb2_hdr *hdr = &pdu->hdr;\n\tint command;\n\t__u32 clc_len;   \n\t__u32 len = get_rfc1002_len(work->request_buf);\n\t__u32 req_struct_size, next_cmd = le32_to_cpu(hdr->NextCommand);\n\n\tif ((u64)work->next_smb2_rcv_hdr_off + next_cmd > len) {\n\t\tpr_err(\"next command(%u) offset exceeds smb msg size\\n\",\n\t\t\t\tnext_cmd);\n\t\treturn 1;\n\t}\n\n\tif (next_cmd > 0)\n\t\tlen = next_cmd;\n\telse if (work->next_smb2_rcv_hdr_off)\n\t\tlen -= work->next_smb2_rcv_hdr_off;\n\n\tif (check_smb2_hdr(hdr))\n\t\treturn 1;\n\n\tif (hdr->StructureSize != SMB2_HEADER_STRUCTURE_SIZE) {\n\t\tksmbd_debug(SMB, \"Illegal structure size %u\\n\",\n\t\t\t    le16_to_cpu(hdr->StructureSize));\n\t\treturn 1;\n\t}\n\n\tcommand = le16_to_cpu(hdr->Command);\n\tif (command >= NUMBER_OF_SMB2_COMMANDS) {\n\t\tksmbd_debug(SMB, \"Illegal SMB2 command %d\\n\", command);\n\t\treturn 1;\n\t}\n\n\tif (smb2_req_struct_sizes[command] != pdu->StructureSize2) {\n\t\tif (!(command == SMB2_OPLOCK_BREAK_HE &&\n\t\t    (le16_to_cpu(pdu->StructureSize2) == OP_BREAK_STRUCT_SIZE_20 ||\n\t\t    le16_to_cpu(pdu->StructureSize2) == OP_BREAK_STRUCT_SIZE_21))) {\n\t\t\t \n\t\t\tksmbd_debug(SMB,\n\t\t\t\t\"Illegal request size %u for command %d\\n\",\n\t\t\t\tle16_to_cpu(pdu->StructureSize2), command);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treq_struct_size = le16_to_cpu(pdu->StructureSize2) +\n\t\t__SMB2_HEADER_STRUCTURE_SIZE;\n\tif (command == SMB2_LOCK_HE)\n\t\treq_struct_size -= sizeof(struct smb2_lock_element);\n\n\tif (req_struct_size > len + 1)\n\t\treturn 1;\n\n\tif (smb2_calc_size(hdr, &clc_len))\n\t\treturn 1;\n\n\tif (len != clc_len) {\n\t\t \n\t\tif (clc_len == len + 1)\n\t\t\tgoto validate_credit;\n\n\t\t \n\t\tif (ALIGN(clc_len, 8) == len)\n\t\t\tgoto validate_credit;\n\n\t\t \n\t\tif (command == SMB2_NEGOTIATE_HE)\n\t\t\tgoto validate_credit;\n\n\t\t \n\t\tif (clc_len < len && (len - clc_len) <= 8)\n\t\t\tgoto validate_credit;\n\n\t\tpr_err_ratelimited(\n\t\t\t    \"cli req too short, len %d not %d. cmd:%d mid:%llu\\n\",\n\t\t\t    len, clc_len, command,\n\t\t\t    le64_to_cpu(hdr->MessageId));\n\n\t\treturn 1;\n\t}\n\nvalidate_credit:\n\tif ((work->conn->vals->capabilities & SMB2_GLOBAL_CAP_LARGE_MTU) &&\n\t    smb2_validate_credit_charge(work->conn, hdr))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nint smb2_negotiate_request(struct ksmbd_work *work)\n{\n\treturn ksmbd_smb_negotiate_common(work, SMB2_NEGOTIATE_HE);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}