{
  "module_name": "transport_ipc.c",
  "hash_id": "333663a2aa04667ca34282e9cfbb59041724854934d8454e92049ef924a1524c",
  "original_prompt": "Ingested from linux-6.6.14/fs/smb/server/transport_ipc.c",
  "human_readable_source": "\n \n\n#include <linux/jhash.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/wait.h>\n#include <linux/hashtable.h>\n#include <net/net_namespace.h>\n#include <net/genetlink.h>\n#include <linux/socket.h>\n#include <linux/workqueue.h>\n\n#include \"vfs_cache.h\"\n#include \"transport_ipc.h\"\n#include \"server.h\"\n#include \"smb_common.h\"\n\n#include \"mgmt/user_config.h\"\n#include \"mgmt/share_config.h\"\n#include \"mgmt/user_session.h\"\n#include \"mgmt/tree_connect.h\"\n#include \"mgmt/ksmbd_ida.h\"\n#include \"connection.h\"\n#include \"transport_tcp.h\"\n#include \"transport_rdma.h\"\n\n#define IPC_WAIT_TIMEOUT\t(2 * HZ)\n\n#define IPC_MSG_HASH_BITS\t3\nstatic DEFINE_HASHTABLE(ipc_msg_table, IPC_MSG_HASH_BITS);\nstatic DECLARE_RWSEM(ipc_msg_table_lock);\nstatic DEFINE_MUTEX(startup_lock);\n\nstatic DEFINE_IDA(ipc_ida);\n\nstatic unsigned int ksmbd_tools_pid;\n\nstatic bool ksmbd_ipc_validate_version(struct genl_info *m)\n{\n\tif (m->genlhdr->version != KSMBD_GENL_VERSION) {\n\t\tpr_err(\"%s. ksmbd: %d, kernel module: %d. %s.\\n\",\n\t\t       \"Daemon and kernel module version mismatch\",\n\t\t       m->genlhdr->version,\n\t\t       KSMBD_GENL_VERSION,\n\t\t       \"User-space ksmbd should terminate\");\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstruct ksmbd_ipc_msg {\n\tunsigned int\t\ttype;\n\tunsigned int\t\tsz;\n\tunsigned char\t\tpayload[];\n};\n\nstruct ipc_msg_table_entry {\n\tunsigned int\t\thandle;\n\tunsigned int\t\ttype;\n\twait_queue_head_t\twait;\n\tstruct hlist_node\tipc_table_hlist;\n\n\tvoid\t\t\t*response;\n};\n\nstatic struct delayed_work ipc_timer_work;\n\nstatic int handle_startup_event(struct sk_buff *skb, struct genl_info *info);\nstatic int handle_unsupported_event(struct sk_buff *skb, struct genl_info *info);\nstatic int handle_generic_event(struct sk_buff *skb, struct genl_info *info);\nstatic int ksmbd_ipc_heartbeat_request(void);\n\nstatic const struct nla_policy ksmbd_nl_policy[KSMBD_EVENT_MAX] = {\n\t[KSMBD_EVENT_UNSPEC] = {\n\t\t.len = 0,\n\t},\n\t[KSMBD_EVENT_HEARTBEAT_REQUEST] = {\n\t\t.len = sizeof(struct ksmbd_heartbeat),\n\t},\n\t[KSMBD_EVENT_STARTING_UP] = {\n\t\t.len = sizeof(struct ksmbd_startup_request),\n\t},\n\t[KSMBD_EVENT_SHUTTING_DOWN] = {\n\t\t.len = sizeof(struct ksmbd_shutdown_request),\n\t},\n\t[KSMBD_EVENT_LOGIN_REQUEST] = {\n\t\t.len = sizeof(struct ksmbd_login_request),\n\t},\n\t[KSMBD_EVENT_LOGIN_RESPONSE] = {\n\t\t.len = sizeof(struct ksmbd_login_response),\n\t},\n\t[KSMBD_EVENT_SHARE_CONFIG_REQUEST] = {\n\t\t.len = sizeof(struct ksmbd_share_config_request),\n\t},\n\t[KSMBD_EVENT_SHARE_CONFIG_RESPONSE] = {\n\t\t.len = sizeof(struct ksmbd_share_config_response),\n\t},\n\t[KSMBD_EVENT_TREE_CONNECT_REQUEST] = {\n\t\t.len = sizeof(struct ksmbd_tree_connect_request),\n\t},\n\t[KSMBD_EVENT_TREE_CONNECT_RESPONSE] = {\n\t\t.len = sizeof(struct ksmbd_tree_connect_response),\n\t},\n\t[KSMBD_EVENT_TREE_DISCONNECT_REQUEST] = {\n\t\t.len = sizeof(struct ksmbd_tree_disconnect_request),\n\t},\n\t[KSMBD_EVENT_LOGOUT_REQUEST] = {\n\t\t.len = sizeof(struct ksmbd_logout_request),\n\t},\n\t[KSMBD_EVENT_RPC_REQUEST] = {\n\t},\n\t[KSMBD_EVENT_RPC_RESPONSE] = {\n\t},\n\t[KSMBD_EVENT_SPNEGO_AUTHEN_REQUEST] = {\n\t},\n\t[KSMBD_EVENT_SPNEGO_AUTHEN_RESPONSE] = {\n\t},\n};\n\nstatic struct genl_ops ksmbd_genl_ops[] = {\n\t{\n\t\t.cmd\t= KSMBD_EVENT_UNSPEC,\n\t\t.doit\t= handle_unsupported_event,\n\t},\n\t{\n\t\t.cmd\t= KSMBD_EVENT_HEARTBEAT_REQUEST,\n\t\t.doit\t= handle_unsupported_event,\n\t},\n\t{\n\t\t.cmd\t= KSMBD_EVENT_STARTING_UP,\n\t\t.doit\t= handle_startup_event,\n\t},\n\t{\n\t\t.cmd\t= KSMBD_EVENT_SHUTTING_DOWN,\n\t\t.doit\t= handle_unsupported_event,\n\t},\n\t{\n\t\t.cmd\t= KSMBD_EVENT_LOGIN_REQUEST,\n\t\t.doit\t= handle_unsupported_event,\n\t},\n\t{\n\t\t.cmd\t= KSMBD_EVENT_LOGIN_RESPONSE,\n\t\t.doit\t= handle_generic_event,\n\t},\n\t{\n\t\t.cmd\t= KSMBD_EVENT_SHARE_CONFIG_REQUEST,\n\t\t.doit\t= handle_unsupported_event,\n\t},\n\t{\n\t\t.cmd\t= KSMBD_EVENT_SHARE_CONFIG_RESPONSE,\n\t\t.doit\t= handle_generic_event,\n\t},\n\t{\n\t\t.cmd\t= KSMBD_EVENT_TREE_CONNECT_REQUEST,\n\t\t.doit\t= handle_unsupported_event,\n\t},\n\t{\n\t\t.cmd\t= KSMBD_EVENT_TREE_CONNECT_RESPONSE,\n\t\t.doit\t= handle_generic_event,\n\t},\n\t{\n\t\t.cmd\t= KSMBD_EVENT_TREE_DISCONNECT_REQUEST,\n\t\t.doit\t= handle_unsupported_event,\n\t},\n\t{\n\t\t.cmd\t= KSMBD_EVENT_LOGOUT_REQUEST,\n\t\t.doit\t= handle_unsupported_event,\n\t},\n\t{\n\t\t.cmd\t= KSMBD_EVENT_RPC_REQUEST,\n\t\t.doit\t= handle_unsupported_event,\n\t},\n\t{\n\t\t.cmd\t= KSMBD_EVENT_RPC_RESPONSE,\n\t\t.doit\t= handle_generic_event,\n\t},\n\t{\n\t\t.cmd\t= KSMBD_EVENT_SPNEGO_AUTHEN_REQUEST,\n\t\t.doit\t= handle_unsupported_event,\n\t},\n\t{\n\t\t.cmd\t= KSMBD_EVENT_SPNEGO_AUTHEN_RESPONSE,\n\t\t.doit\t= handle_generic_event,\n\t},\n};\n\nstatic struct genl_family ksmbd_genl_family = {\n\t.name\t\t= KSMBD_GENL_NAME,\n\t.version\t= KSMBD_GENL_VERSION,\n\t.hdrsize\t= 0,\n\t.maxattr\t= KSMBD_EVENT_MAX,\n\t.netnsok\t= true,\n\t.module\t\t= THIS_MODULE,\n\t.ops\t\t= ksmbd_genl_ops,\n\t.n_ops\t\t= ARRAY_SIZE(ksmbd_genl_ops),\n\t.resv_start_op\t= KSMBD_EVENT_SPNEGO_AUTHEN_RESPONSE + 1,\n};\n\nstatic void ksmbd_nl_init_fixup(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ksmbd_genl_ops); i++)\n\t\tksmbd_genl_ops[i].validate = GENL_DONT_VALIDATE_STRICT |\n\t\t\t\t\t\tGENL_DONT_VALIDATE_DUMP;\n\n\tksmbd_genl_family.policy = ksmbd_nl_policy;\n}\n\nstatic int rpc_context_flags(struct ksmbd_session *sess)\n{\n\tif (user_guest(sess->user))\n\t\treturn KSMBD_RPC_RESTRICTED_CONTEXT;\n\treturn 0;\n}\n\nstatic void ipc_update_last_active(void)\n{\n\tif (server_conf.ipc_timeout)\n\t\tserver_conf.ipc_last_active = jiffies;\n}\n\nstatic struct ksmbd_ipc_msg *ipc_msg_alloc(size_t sz)\n{\n\tstruct ksmbd_ipc_msg *msg;\n\tsize_t msg_sz = sz + sizeof(struct ksmbd_ipc_msg);\n\n\tmsg = kvzalloc(msg_sz, GFP_KERNEL);\n\tif (msg)\n\t\tmsg->sz = sz;\n\treturn msg;\n}\n\nstatic void ipc_msg_free(struct ksmbd_ipc_msg *msg)\n{\n\tkvfree(msg);\n}\n\nstatic void ipc_msg_handle_free(int handle)\n{\n\tif (handle >= 0)\n\t\tksmbd_release_id(&ipc_ida, handle);\n}\n\nstatic int handle_response(int type, void *payload, size_t sz)\n{\n\tunsigned int handle = *(unsigned int *)payload;\n\tstruct ipc_msg_table_entry *entry;\n\tint ret = 0;\n\n\tipc_update_last_active();\n\tdown_read(&ipc_msg_table_lock);\n\thash_for_each_possible(ipc_msg_table, entry, ipc_table_hlist, handle) {\n\t\tif (handle != entry->handle)\n\t\t\tcontinue;\n\n\t\tentry->response = NULL;\n\t\t \n\t\tif (entry->type + 1 != type) {\n\t\t\tpr_err(\"Waiting for IPC type %d, got %d. Ignore.\\n\",\n\t\t\t       entry->type + 1, type);\n\t\t}\n\n\t\tentry->response = kvzalloc(sz, GFP_KERNEL);\n\t\tif (!entry->response) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tmemcpy(entry->response, payload, sz);\n\t\twake_up_interruptible(&entry->wait);\n\t\tret = 0;\n\t\tbreak;\n\t}\n\tup_read(&ipc_msg_table_lock);\n\n\treturn ret;\n}\n\nstatic int ipc_server_config_on_startup(struct ksmbd_startup_request *req)\n{\n\tint ret;\n\n\tksmbd_set_fd_limit(req->file_max);\n\tserver_conf.flags = req->flags;\n\tserver_conf.signing = req->signing;\n\tserver_conf.tcp_port = req->tcp_port;\n\tserver_conf.ipc_timeout = req->ipc_timeout * HZ;\n\tserver_conf.deadtime = req->deadtime * SMB_ECHO_INTERVAL;\n\tserver_conf.share_fake_fscaps = req->share_fake_fscaps;\n\tksmbd_init_domain(req->sub_auth);\n\n\tif (req->smb2_max_read)\n\t\tinit_smb2_max_read_size(req->smb2_max_read);\n\tif (req->smb2_max_write)\n\t\tinit_smb2_max_write_size(req->smb2_max_write);\n\tif (req->smb2_max_trans)\n\t\tinit_smb2_max_trans_size(req->smb2_max_trans);\n\tif (req->smb2_max_credits)\n\t\tinit_smb2_max_credits(req->smb2_max_credits);\n\tif (req->smbd_max_io_size)\n\t\tinit_smbd_max_io_size(req->smbd_max_io_size);\n\n\tif (req->max_connections)\n\t\tserver_conf.max_connections = req->max_connections;\n\n\tret = ksmbd_set_netbios_name(req->netbios_name);\n\tret |= ksmbd_set_server_string(req->server_string);\n\tret |= ksmbd_set_work_group(req->work_group);\n\tret |= ksmbd_tcp_set_interfaces(KSMBD_STARTUP_CONFIG_INTERFACES(req),\n\t\t\t\t\treq->ifc_list_sz);\n\tif (ret) {\n\t\tpr_err(\"Server configuration error: %s %s %s\\n\",\n\t\t       req->netbios_name, req->server_string,\n\t\t       req->work_group);\n\t\treturn ret;\n\t}\n\n\tif (req->min_prot[0]) {\n\t\tret = ksmbd_lookup_protocol_idx(req->min_prot);\n\t\tif (ret >= 0)\n\t\t\tserver_conf.min_protocol = ret;\n\t}\n\tif (req->max_prot[0]) {\n\t\tret = ksmbd_lookup_protocol_idx(req->max_prot);\n\t\tif (ret >= 0)\n\t\t\tserver_conf.max_protocol = ret;\n\t}\n\n\tif (server_conf.ipc_timeout)\n\t\tschedule_delayed_work(&ipc_timer_work, server_conf.ipc_timeout);\n\treturn 0;\n}\n\nstatic int handle_startup_event(struct sk_buff *skb, struct genl_info *info)\n{\n\tint ret = 0;\n\n#ifdef CONFIG_SMB_SERVER_CHECK_CAP_NET_ADMIN\n\tif (!netlink_capable(skb, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n#endif\n\n\tif (!ksmbd_ipc_validate_version(info))\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[KSMBD_EVENT_STARTING_UP])\n\t\treturn -EINVAL;\n\n\tmutex_lock(&startup_lock);\n\tif (!ksmbd_server_configurable()) {\n\t\tmutex_unlock(&startup_lock);\n\t\tpr_err(\"Server reset is in progress, can't start daemon\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (ksmbd_tools_pid) {\n\t\tif (ksmbd_ipc_heartbeat_request() == 0) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tpr_err(\"Reconnect to a new user space daemon\\n\");\n\t} else {\n\t\tstruct ksmbd_startup_request *req;\n\n\t\treq = nla_data(info->attrs[info->genlhdr->cmd]);\n\t\tret = ipc_server_config_on_startup(req);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tserver_queue_ctrl_init_work();\n\t}\n\n\tksmbd_tools_pid = info->snd_portid;\n\tipc_update_last_active();\n\nout:\n\tmutex_unlock(&startup_lock);\n\treturn ret;\n}\n\nstatic int handle_unsupported_event(struct sk_buff *skb, struct genl_info *info)\n{\n\tpr_err(\"Unknown IPC event: %d, ignore.\\n\", info->genlhdr->cmd);\n\treturn -EINVAL;\n}\n\nstatic int handle_generic_event(struct sk_buff *skb, struct genl_info *info)\n{\n\tvoid *payload;\n\tint sz;\n\tint type = info->genlhdr->cmd;\n\n#ifdef CONFIG_SMB_SERVER_CHECK_CAP_NET_ADMIN\n\tif (!netlink_capable(skb, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n#endif\n\n\tif (type >= KSMBD_EVENT_MAX) {\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!ksmbd_ipc_validate_version(info))\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[type])\n\t\treturn -EINVAL;\n\n\tpayload = nla_data(info->attrs[info->genlhdr->cmd]);\n\tsz = nla_len(info->attrs[info->genlhdr->cmd]);\n\treturn handle_response(type, payload, sz);\n}\n\nstatic int ipc_msg_send(struct ksmbd_ipc_msg *msg)\n{\n\tstruct genlmsghdr *nlh;\n\tstruct sk_buff *skb;\n\tint ret = -EINVAL;\n\n\tif (!ksmbd_tools_pid)\n\t\treturn ret;\n\n\tskb = genlmsg_new(msg->sz, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tnlh = genlmsg_put(skb, 0, 0, &ksmbd_genl_family, 0, msg->type);\n\tif (!nlh)\n\t\tgoto out;\n\n\tret = nla_put(skb, msg->type, msg->sz, msg->payload);\n\tif (ret) {\n\t\tgenlmsg_cancel(skb, nlh);\n\t\tgoto out;\n\t}\n\n\tgenlmsg_end(skb, nlh);\n\tret = genlmsg_unicast(&init_net, skb, ksmbd_tools_pid);\n\tif (!ret)\n\t\tipc_update_last_active();\n\treturn ret;\n\nout:\n\tnlmsg_free(skb);\n\treturn ret;\n}\n\nstatic void *ipc_msg_send_request(struct ksmbd_ipc_msg *msg, unsigned int handle)\n{\n\tstruct ipc_msg_table_entry entry;\n\tint ret;\n\n\tif ((int)handle < 0)\n\t\treturn NULL;\n\n\tentry.type = msg->type;\n\tentry.response = NULL;\n\tinit_waitqueue_head(&entry.wait);\n\n\tdown_write(&ipc_msg_table_lock);\n\tentry.handle = handle;\n\thash_add(ipc_msg_table, &entry.ipc_table_hlist, entry.handle);\n\tup_write(&ipc_msg_table_lock);\n\n\tret = ipc_msg_send(msg);\n\tif (ret)\n\t\tgoto out;\n\n\tret = wait_event_interruptible_timeout(entry.wait,\n\t\t\t\t\t       entry.response != NULL,\n\t\t\t\t\t       IPC_WAIT_TIMEOUT);\nout:\n\tdown_write(&ipc_msg_table_lock);\n\thash_del(&entry.ipc_table_hlist);\n\tup_write(&ipc_msg_table_lock);\n\treturn entry.response;\n}\n\nstatic int ksmbd_ipc_heartbeat_request(void)\n{\n\tstruct ksmbd_ipc_msg *msg;\n\tint ret;\n\n\tmsg = ipc_msg_alloc(sizeof(struct ksmbd_heartbeat));\n\tif (!msg)\n\t\treturn -EINVAL;\n\n\tmsg->type = KSMBD_EVENT_HEARTBEAT_REQUEST;\n\tret = ipc_msg_send(msg);\n\tipc_msg_free(msg);\n\treturn ret;\n}\n\nstruct ksmbd_login_response *ksmbd_ipc_login_request(const char *account)\n{\n\tstruct ksmbd_ipc_msg *msg;\n\tstruct ksmbd_login_request *req;\n\tstruct ksmbd_login_response *resp;\n\n\tif (strlen(account) >= KSMBD_REQ_MAX_ACCOUNT_NAME_SZ)\n\t\treturn NULL;\n\n\tmsg = ipc_msg_alloc(sizeof(struct ksmbd_login_request));\n\tif (!msg)\n\t\treturn NULL;\n\n\tmsg->type = KSMBD_EVENT_LOGIN_REQUEST;\n\treq = (struct ksmbd_login_request *)msg->payload;\n\treq->handle = ksmbd_acquire_id(&ipc_ida);\n\tstrscpy(req->account, account, KSMBD_REQ_MAX_ACCOUNT_NAME_SZ);\n\n\tresp = ipc_msg_send_request(msg, req->handle);\n\tipc_msg_handle_free(req->handle);\n\tipc_msg_free(msg);\n\treturn resp;\n}\n\nstruct ksmbd_spnego_authen_response *\nksmbd_ipc_spnego_authen_request(const char *spnego_blob, int blob_len)\n{\n\tstruct ksmbd_ipc_msg *msg;\n\tstruct ksmbd_spnego_authen_request *req;\n\tstruct ksmbd_spnego_authen_response *resp;\n\n\tmsg = ipc_msg_alloc(sizeof(struct ksmbd_spnego_authen_request) +\n\t\t\tblob_len + 1);\n\tif (!msg)\n\t\treturn NULL;\n\n\tmsg->type = KSMBD_EVENT_SPNEGO_AUTHEN_REQUEST;\n\treq = (struct ksmbd_spnego_authen_request *)msg->payload;\n\treq->handle = ksmbd_acquire_id(&ipc_ida);\n\treq->spnego_blob_len = blob_len;\n\tmemcpy(req->spnego_blob, spnego_blob, blob_len);\n\n\tresp = ipc_msg_send_request(msg, req->handle);\n\tipc_msg_handle_free(req->handle);\n\tipc_msg_free(msg);\n\treturn resp;\n}\n\nstruct ksmbd_tree_connect_response *\nksmbd_ipc_tree_connect_request(struct ksmbd_session *sess,\n\t\t\t       struct ksmbd_share_config *share,\n\t\t\t       struct ksmbd_tree_connect *tree_conn,\n\t\t\t       struct sockaddr *peer_addr)\n{\n\tstruct ksmbd_ipc_msg *msg;\n\tstruct ksmbd_tree_connect_request *req;\n\tstruct ksmbd_tree_connect_response *resp;\n\n\tif (strlen(user_name(sess->user)) >= KSMBD_REQ_MAX_ACCOUNT_NAME_SZ)\n\t\treturn NULL;\n\n\tif (strlen(share->name) >= KSMBD_REQ_MAX_SHARE_NAME)\n\t\treturn NULL;\n\n\tmsg = ipc_msg_alloc(sizeof(struct ksmbd_tree_connect_request));\n\tif (!msg)\n\t\treturn NULL;\n\n\tmsg->type = KSMBD_EVENT_TREE_CONNECT_REQUEST;\n\treq = (struct ksmbd_tree_connect_request *)msg->payload;\n\n\treq->handle = ksmbd_acquire_id(&ipc_ida);\n\treq->account_flags = sess->user->flags;\n\treq->session_id = sess->id;\n\treq->connect_id = tree_conn->id;\n\tstrscpy(req->account, user_name(sess->user), KSMBD_REQ_MAX_ACCOUNT_NAME_SZ);\n\tstrscpy(req->share, share->name, KSMBD_REQ_MAX_SHARE_NAME);\n\tsnprintf(req->peer_addr, sizeof(req->peer_addr), \"%pIS\", peer_addr);\n\n\tif (peer_addr->sa_family == AF_INET6)\n\t\treq->flags |= KSMBD_TREE_CONN_FLAG_REQUEST_IPV6;\n\tif (test_session_flag(sess, CIFDS_SESSION_FLAG_SMB2))\n\t\treq->flags |= KSMBD_TREE_CONN_FLAG_REQUEST_SMB2;\n\n\tresp = ipc_msg_send_request(msg, req->handle);\n\tipc_msg_handle_free(req->handle);\n\tipc_msg_free(msg);\n\treturn resp;\n}\n\nint ksmbd_ipc_tree_disconnect_request(unsigned long long session_id,\n\t\t\t\t      unsigned long long connect_id)\n{\n\tstruct ksmbd_ipc_msg *msg;\n\tstruct ksmbd_tree_disconnect_request *req;\n\tint ret;\n\n\tmsg = ipc_msg_alloc(sizeof(struct ksmbd_tree_disconnect_request));\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tmsg->type = KSMBD_EVENT_TREE_DISCONNECT_REQUEST;\n\treq = (struct ksmbd_tree_disconnect_request *)msg->payload;\n\treq->session_id = session_id;\n\treq->connect_id = connect_id;\n\n\tret = ipc_msg_send(msg);\n\tipc_msg_free(msg);\n\treturn ret;\n}\n\nint ksmbd_ipc_logout_request(const char *account, int flags)\n{\n\tstruct ksmbd_ipc_msg *msg;\n\tstruct ksmbd_logout_request *req;\n\tint ret;\n\n\tif (strlen(account) >= KSMBD_REQ_MAX_ACCOUNT_NAME_SZ)\n\t\treturn -EINVAL;\n\n\tmsg = ipc_msg_alloc(sizeof(struct ksmbd_logout_request));\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tmsg->type = KSMBD_EVENT_LOGOUT_REQUEST;\n\treq = (struct ksmbd_logout_request *)msg->payload;\n\treq->account_flags = flags;\n\tstrscpy(req->account, account, KSMBD_REQ_MAX_ACCOUNT_NAME_SZ);\n\n\tret = ipc_msg_send(msg);\n\tipc_msg_free(msg);\n\treturn ret;\n}\n\nstruct ksmbd_share_config_response *\nksmbd_ipc_share_config_request(const char *name)\n{\n\tstruct ksmbd_ipc_msg *msg;\n\tstruct ksmbd_share_config_request *req;\n\tstruct ksmbd_share_config_response *resp;\n\n\tif (strlen(name) >= KSMBD_REQ_MAX_SHARE_NAME)\n\t\treturn NULL;\n\n\tmsg = ipc_msg_alloc(sizeof(struct ksmbd_share_config_request));\n\tif (!msg)\n\t\treturn NULL;\n\n\tmsg->type = KSMBD_EVENT_SHARE_CONFIG_REQUEST;\n\treq = (struct ksmbd_share_config_request *)msg->payload;\n\treq->handle = ksmbd_acquire_id(&ipc_ida);\n\tstrscpy(req->share_name, name, KSMBD_REQ_MAX_SHARE_NAME);\n\n\tresp = ipc_msg_send_request(msg, req->handle);\n\tipc_msg_handle_free(req->handle);\n\tipc_msg_free(msg);\n\treturn resp;\n}\n\nstruct ksmbd_rpc_command *ksmbd_rpc_open(struct ksmbd_session *sess, int handle)\n{\n\tstruct ksmbd_ipc_msg *msg;\n\tstruct ksmbd_rpc_command *req;\n\tstruct ksmbd_rpc_command *resp;\n\n\tmsg = ipc_msg_alloc(sizeof(struct ksmbd_rpc_command));\n\tif (!msg)\n\t\treturn NULL;\n\n\tmsg->type = KSMBD_EVENT_RPC_REQUEST;\n\treq = (struct ksmbd_rpc_command *)msg->payload;\n\treq->handle = handle;\n\treq->flags = ksmbd_session_rpc_method(sess, handle);\n\treq->flags |= KSMBD_RPC_OPEN_METHOD;\n\treq->payload_sz = 0;\n\n\tresp = ipc_msg_send_request(msg, req->handle);\n\tipc_msg_free(msg);\n\treturn resp;\n}\n\nstruct ksmbd_rpc_command *ksmbd_rpc_close(struct ksmbd_session *sess, int handle)\n{\n\tstruct ksmbd_ipc_msg *msg;\n\tstruct ksmbd_rpc_command *req;\n\tstruct ksmbd_rpc_command *resp;\n\n\tmsg = ipc_msg_alloc(sizeof(struct ksmbd_rpc_command));\n\tif (!msg)\n\t\treturn NULL;\n\n\tmsg->type = KSMBD_EVENT_RPC_REQUEST;\n\treq = (struct ksmbd_rpc_command *)msg->payload;\n\treq->handle = handle;\n\treq->flags = ksmbd_session_rpc_method(sess, handle);\n\treq->flags |= KSMBD_RPC_CLOSE_METHOD;\n\treq->payload_sz = 0;\n\n\tresp = ipc_msg_send_request(msg, req->handle);\n\tipc_msg_free(msg);\n\treturn resp;\n}\n\nstruct ksmbd_rpc_command *ksmbd_rpc_write(struct ksmbd_session *sess, int handle,\n\t\t\t\t\t  void *payload, size_t payload_sz)\n{\n\tstruct ksmbd_ipc_msg *msg;\n\tstruct ksmbd_rpc_command *req;\n\tstruct ksmbd_rpc_command *resp;\n\n\tmsg = ipc_msg_alloc(sizeof(struct ksmbd_rpc_command) + payload_sz + 1);\n\tif (!msg)\n\t\treturn NULL;\n\n\tmsg->type = KSMBD_EVENT_RPC_REQUEST;\n\treq = (struct ksmbd_rpc_command *)msg->payload;\n\treq->handle = handle;\n\treq->flags = ksmbd_session_rpc_method(sess, handle);\n\treq->flags |= rpc_context_flags(sess);\n\treq->flags |= KSMBD_RPC_WRITE_METHOD;\n\treq->payload_sz = payload_sz;\n\tmemcpy(req->payload, payload, payload_sz);\n\n\tresp = ipc_msg_send_request(msg, req->handle);\n\tipc_msg_free(msg);\n\treturn resp;\n}\n\nstruct ksmbd_rpc_command *ksmbd_rpc_read(struct ksmbd_session *sess, int handle)\n{\n\tstruct ksmbd_ipc_msg *msg;\n\tstruct ksmbd_rpc_command *req;\n\tstruct ksmbd_rpc_command *resp;\n\n\tmsg = ipc_msg_alloc(sizeof(struct ksmbd_rpc_command));\n\tif (!msg)\n\t\treturn NULL;\n\n\tmsg->type = KSMBD_EVENT_RPC_REQUEST;\n\treq = (struct ksmbd_rpc_command *)msg->payload;\n\treq->handle = handle;\n\treq->flags = ksmbd_session_rpc_method(sess, handle);\n\treq->flags |= rpc_context_flags(sess);\n\treq->flags |= KSMBD_RPC_READ_METHOD;\n\treq->payload_sz = 0;\n\n\tresp = ipc_msg_send_request(msg, req->handle);\n\tipc_msg_free(msg);\n\treturn resp;\n}\n\nstruct ksmbd_rpc_command *ksmbd_rpc_ioctl(struct ksmbd_session *sess, int handle,\n\t\t\t\t\t  void *payload, size_t payload_sz)\n{\n\tstruct ksmbd_ipc_msg *msg;\n\tstruct ksmbd_rpc_command *req;\n\tstruct ksmbd_rpc_command *resp;\n\n\tmsg = ipc_msg_alloc(sizeof(struct ksmbd_rpc_command) + payload_sz + 1);\n\tif (!msg)\n\t\treturn NULL;\n\n\tmsg->type = KSMBD_EVENT_RPC_REQUEST;\n\treq = (struct ksmbd_rpc_command *)msg->payload;\n\treq->handle = handle;\n\treq->flags = ksmbd_session_rpc_method(sess, handle);\n\treq->flags |= rpc_context_flags(sess);\n\treq->flags |= KSMBD_RPC_IOCTL_METHOD;\n\treq->payload_sz = payload_sz;\n\tmemcpy(req->payload, payload, payload_sz);\n\n\tresp = ipc_msg_send_request(msg, req->handle);\n\tipc_msg_free(msg);\n\treturn resp;\n}\n\nstruct ksmbd_rpc_command *ksmbd_rpc_rap(struct ksmbd_session *sess, void *payload,\n\t\t\t\t\tsize_t payload_sz)\n{\n\tstruct ksmbd_ipc_msg *msg;\n\tstruct ksmbd_rpc_command *req;\n\tstruct ksmbd_rpc_command *resp;\n\n\tmsg = ipc_msg_alloc(sizeof(struct ksmbd_rpc_command) + payload_sz + 1);\n\tif (!msg)\n\t\treturn NULL;\n\n\tmsg->type = KSMBD_EVENT_RPC_REQUEST;\n\treq = (struct ksmbd_rpc_command *)msg->payload;\n\treq->handle = ksmbd_acquire_id(&ipc_ida);\n\treq->flags = rpc_context_flags(sess);\n\treq->flags |= KSMBD_RPC_RAP_METHOD;\n\treq->payload_sz = payload_sz;\n\tmemcpy(req->payload, payload, payload_sz);\n\n\tresp = ipc_msg_send_request(msg, req->handle);\n\tipc_msg_handle_free(req->handle);\n\tipc_msg_free(msg);\n\treturn resp;\n}\n\nstatic int __ipc_heartbeat(void)\n{\n\tunsigned long delta;\n\n\tif (!ksmbd_server_running())\n\t\treturn 0;\n\n\tif (time_after(jiffies, server_conf.ipc_last_active)) {\n\t\tdelta = (jiffies - server_conf.ipc_last_active);\n\t} else {\n\t\tipc_update_last_active();\n\t\tschedule_delayed_work(&ipc_timer_work,\n\t\t\t\t      server_conf.ipc_timeout);\n\t\treturn 0;\n\t}\n\n\tif (delta < server_conf.ipc_timeout) {\n\t\tschedule_delayed_work(&ipc_timer_work,\n\t\t\t\t      server_conf.ipc_timeout - delta);\n\t\treturn 0;\n\t}\n\n\tif (ksmbd_ipc_heartbeat_request() == 0) {\n\t\tschedule_delayed_work(&ipc_timer_work,\n\t\t\t\t      server_conf.ipc_timeout);\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&startup_lock);\n\tWRITE_ONCE(server_conf.state, SERVER_STATE_RESETTING);\n\tserver_conf.ipc_last_active = 0;\n\tksmbd_tools_pid = 0;\n\tpr_err(\"No IPC daemon response for %lus\\n\", delta / HZ);\n\tmutex_unlock(&startup_lock);\n\treturn -EINVAL;\n}\n\nstatic void ipc_timer_heartbeat(struct work_struct *w)\n{\n\tif (__ipc_heartbeat())\n\t\tserver_queue_ctrl_reset_work();\n}\n\nint ksmbd_ipc_id_alloc(void)\n{\n\treturn ksmbd_acquire_id(&ipc_ida);\n}\n\nvoid ksmbd_rpc_id_free(int handle)\n{\n\tksmbd_release_id(&ipc_ida, handle);\n}\n\nvoid ksmbd_ipc_release(void)\n{\n\tcancel_delayed_work_sync(&ipc_timer_work);\n\tgenl_unregister_family(&ksmbd_genl_family);\n}\n\nvoid ksmbd_ipc_soft_reset(void)\n{\n\tmutex_lock(&startup_lock);\n\tksmbd_tools_pid = 0;\n\tcancel_delayed_work_sync(&ipc_timer_work);\n\tmutex_unlock(&startup_lock);\n}\n\nint ksmbd_ipc_init(void)\n{\n\tint ret = 0;\n\n\tksmbd_nl_init_fixup();\n\tINIT_DELAYED_WORK(&ipc_timer_work, ipc_timer_heartbeat);\n\n\tret = genl_register_family(&ksmbd_genl_family);\n\tif (ret) {\n\t\tpr_err(\"Failed to register KSMBD netlink interface %d\\n\", ret);\n\t\tcancel_delayed_work_sync(&ipc_timer_work);\n\t}\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}