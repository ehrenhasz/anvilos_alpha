{
  "module_name": "misc.c",
  "hash_id": "5d5dea4e25415005ea1bad0dd405772e18aaa3c0f91d5a3ccd8a28a63e249cbf",
  "original_prompt": "Ingested from linux-6.6.14/fs/smb/server/misc.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/unicode.h>\n\n#include \"misc.h\"\n#include \"smb_common.h\"\n#include \"connection.h\"\n#include \"vfs.h\"\n\n#include \"mgmt/share_config.h\"\n\n \nint match_pattern(const char *str, size_t len, const char *pattern)\n{\n\tconst char *s = str;\n\tconst char *p = pattern;\n\tbool star = false;\n\n\twhile (*s && len) {\n\t\tswitch (*p) {\n\t\tcase '?':\n\t\t\ts++;\n\t\t\tlen--;\n\t\t\tp++;\n\t\t\tbreak;\n\t\tcase '*':\n\t\t\tstar = true;\n\t\t\tstr = s;\n\t\t\tif (!*++p)\n\t\t\t\treturn true;\n\t\t\tpattern = p;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (tolower(*s) == tolower(*p)) {\n\t\t\t\ts++;\n\t\t\t\tlen--;\n\t\t\t\tp++;\n\t\t\t} else {\n\t\t\t\tif (!star)\n\t\t\t\t\treturn false;\n\t\t\t\tstr++;\n\t\t\t\ts = str;\n\t\t\t\tp = pattern;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (*p == '*')\n\t\t++p;\n\treturn !*p;\n}\n\n \nstatic inline int is_char_allowed(char ch)\n{\n\t \n\tif (!(ch & 0x80) &&\n\t    (ch <= 0x1f ||\n\t     ch == '?' || ch == '\"' || ch == '<' ||\n\t     ch == '>' || ch == '|' || ch == '*'))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nint ksmbd_validate_filename(char *filename)\n{\n\twhile (*filename) {\n\t\tchar c = *filename;\n\n\t\tfilename++;\n\t\tif (!is_char_allowed(c)) {\n\t\t\tksmbd_debug(VFS, \"File name validation failed: 0x%x\\n\", c);\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ksmbd_validate_stream_name(char *stream_name)\n{\n\twhile (*stream_name) {\n\t\tchar c = *stream_name;\n\n\t\tstream_name++;\n\t\tif (c == '/' || c == ':' || c == '\\\\') {\n\t\t\tpr_err(\"Stream name validation failed: %c\\n\", c);\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint parse_stream_name(char *filename, char **stream_name, int *s_type)\n{\n\tchar *stream_type;\n\tchar *s_name;\n\tint rc = 0;\n\n\ts_name = filename;\n\tfilename = strsep(&s_name, \":\");\n\tksmbd_debug(SMB, \"filename : %s, streams : %s\\n\", filename, s_name);\n\tif (strchr(s_name, ':')) {\n\t\tstream_type = s_name;\n\t\ts_name = strsep(&stream_type, \":\");\n\n\t\trc = ksmbd_validate_stream_name(s_name);\n\t\tif (rc < 0) {\n\t\t\trc = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tksmbd_debug(SMB, \"stream name : %s, stream type : %s\\n\", s_name,\n\t\t\t    stream_type);\n\t\tif (!strncasecmp(\"$data\", stream_type, 5))\n\t\t\t*s_type = DATA_STREAM;\n\t\telse if (!strncasecmp(\"$index_allocation\", stream_type, 17))\n\t\t\t*s_type = DIR_STREAM;\n\t\telse\n\t\t\trc = -ENOENT;\n\t}\n\n\t*stream_name = s_name;\nout:\n\treturn rc;\n}\n\n \n\nchar *convert_to_nt_pathname(struct ksmbd_share_config *share,\n\t\t\t     const struct path *path)\n{\n\tchar *pathname, *ab_pathname, *nt_pathname;\n\tint share_path_len = share->path_sz;\n\n\tpathname = kmalloc(PATH_MAX, GFP_KERNEL);\n\tif (!pathname)\n\t\treturn ERR_PTR(-EACCES);\n\n\tab_pathname = d_path(path, pathname, PATH_MAX);\n\tif (IS_ERR(ab_pathname)) {\n\t\tnt_pathname = ERR_PTR(-EACCES);\n\t\tgoto free_pathname;\n\t}\n\n\tif (strncmp(ab_pathname, share->path, share_path_len)) {\n\t\tnt_pathname = ERR_PTR(-EACCES);\n\t\tgoto free_pathname;\n\t}\n\n\tnt_pathname = kzalloc(strlen(&ab_pathname[share_path_len]) + 2, GFP_KERNEL);\n\tif (!nt_pathname) {\n\t\tnt_pathname = ERR_PTR(-ENOMEM);\n\t\tgoto free_pathname;\n\t}\n\tif (ab_pathname[share_path_len] == '\\0')\n\t\tstrcpy(nt_pathname, \"/\");\n\tstrcat(nt_pathname, &ab_pathname[share_path_len]);\n\n\tksmbd_conv_path_to_windows(nt_pathname);\n\nfree_pathname:\n\tkfree(pathname);\n\treturn nt_pathname;\n}\n\nint get_nlink(struct kstat *st)\n{\n\tint nlink;\n\n\tnlink = st->nlink;\n\tif (S_ISDIR(st->mode))\n\t\tnlink--;\n\n\treturn nlink;\n}\n\nvoid ksmbd_conv_path_to_unix(char *path)\n{\n\tstrreplace(path, '\\\\', '/');\n}\n\nvoid ksmbd_strip_last_slash(char *path)\n{\n\tint len = strlen(path);\n\n\twhile (len && path[len - 1] == '/') {\n\t\tpath[len - 1] = '\\0';\n\t\tlen--;\n\t}\n}\n\nvoid ksmbd_conv_path_to_windows(char *path)\n{\n\tstrreplace(path, '/', '\\\\');\n}\n\nchar *ksmbd_casefold_sharename(struct unicode_map *um, const char *name)\n{\n\tchar *cf_name;\n\tint cf_len;\n\n\tcf_name = kzalloc(KSMBD_REQ_MAX_SHARE_NAME, GFP_KERNEL);\n\tif (!cf_name)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (IS_ENABLED(CONFIG_UNICODE) && um) {\n\t\tconst struct qstr q_name = {.name = name, .len = strlen(name)};\n\n\t\tcf_len = utf8_casefold(um, &q_name, cf_name,\n\t\t\t\t       KSMBD_REQ_MAX_SHARE_NAME);\n\t\tif (cf_len < 0)\n\t\t\tgoto out_ascii;\n\n\t\treturn cf_name;\n\t}\n\nout_ascii:\n\tcf_len = strscpy(cf_name, name, KSMBD_REQ_MAX_SHARE_NAME);\n\tif (cf_len < 0) {\n\t\tkfree(cf_name);\n\t\treturn ERR_PTR(-E2BIG);\n\t}\n\n\tfor (; *cf_name; ++cf_name)\n\t\t*cf_name = isascii(*cf_name) ? tolower(*cf_name) : *cf_name;\n\treturn cf_name - cf_len;\n}\n\n \nchar *ksmbd_extract_sharename(struct unicode_map *um, const char *treename)\n{\n\tconst char *name = treename, *pos = strrchr(name, '\\\\');\n\n\tif (pos)\n\t\tname = (pos + 1);\n\n\t \n\treturn ksmbd_casefold_sharename(um, name);\n}\n\n \nchar *convert_to_unix_name(struct ksmbd_share_config *share, const char *name)\n{\n\tint no_slash = 0, name_len, path_len;\n\tchar *new_name;\n\n\tif (name[0] == '/')\n\t\tname++;\n\n\tpath_len = share->path_sz;\n\tname_len = strlen(name);\n\tnew_name = kmalloc(path_len + name_len + 2, GFP_KERNEL);\n\tif (!new_name)\n\t\treturn new_name;\n\n\tmemcpy(new_name, share->path, path_len);\n\tif (new_name[path_len - 1] != '/') {\n\t\tnew_name[path_len] = '/';\n\t\tno_slash = 1;\n\t}\n\n\tmemcpy(new_name + path_len + no_slash, name, name_len);\n\tpath_len += name_len + no_slash;\n\tnew_name[path_len] = 0x00;\n\treturn new_name;\n}\n\nchar *ksmbd_convert_dir_info_name(struct ksmbd_dir_info *d_info,\n\t\t\t\t  const struct nls_table *local_nls,\n\t\t\t\t  int *conv_len)\n{\n\tchar *conv;\n\tint  sz = min(4 * d_info->name_len, PATH_MAX);\n\n\tif (!sz)\n\t\treturn NULL;\n\n\tconv = kmalloc(sz, GFP_KERNEL);\n\tif (!conv)\n\t\treturn NULL;\n\n\t \n\t*conv_len = smbConvertToUTF16((__le16 *)conv, d_info->name,\n\t\t\t\t      d_info->name_len, local_nls, 0);\n\t*conv_len *= 2;\n\n\t \n\tconv[*conv_len] = 0x00;\n\tconv[*conv_len + 1] = 0x00;\n\treturn conv;\n}\n\n \nstruct timespec64 ksmbd_NTtimeToUnix(__le64 ntutc)\n{\n\tstruct timespec64 ts;\n\n\t \n\ts64 t = le64_to_cpu(ntutc) - NTFS_TIME_OFFSET;\n\tu64 abs_t;\n\n\t \n\tif (t < 0) {\n\t\tabs_t = -t;\n\t\tts.tv_nsec = do_div(abs_t, 10000000) * 100;\n\t\tts.tv_nsec = -ts.tv_nsec;\n\t\tts.tv_sec = -abs_t;\n\t} else {\n\t\tabs_t = t;\n\t\tts.tv_nsec = do_div(abs_t, 10000000) * 100;\n\t\tts.tv_sec = abs_t;\n\t}\n\n\treturn ts;\n}\n\n \ninline u64 ksmbd_UnixTimeToNT(struct timespec64 t)\n{\n\t \n\treturn (u64)t.tv_sec * 10000000 + t.tv_nsec / 100 + NTFS_TIME_OFFSET;\n}\n\ninline long long ksmbd_systime(void)\n{\n\tstruct timespec64\tts;\n\n\tktime_get_real_ts64(&ts);\n\treturn ksmbd_UnixTimeToNT(ts);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}