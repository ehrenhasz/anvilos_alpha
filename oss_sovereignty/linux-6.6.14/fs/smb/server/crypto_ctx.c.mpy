{
  "module_name": "crypto_ctx.c",
  "hash_id": "56ea94d09ba5692e231a10ac561bc5a72a45ff8bedad11b5c6aaa7ae66ad4995",
  "original_prompt": "Ingested from linux-6.6.14/fs/smb/server/crypto_ctx.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\n#include \"glob.h\"\n#include \"crypto_ctx.h\"\n\nstruct crypto_ctx_list {\n\tspinlock_t\t\tctx_lock;\n\tint\t\t\tavail_ctx;\n\tstruct list_head\tidle_ctx;\n\twait_queue_head_t\tctx_wait;\n};\n\nstatic struct crypto_ctx_list ctx_list;\n\nstatic inline void free_aead(struct crypto_aead *aead)\n{\n\tif (aead)\n\t\tcrypto_free_aead(aead);\n}\n\nstatic void free_shash(struct shash_desc *shash)\n{\n\tif (shash) {\n\t\tcrypto_free_shash(shash->tfm);\n\t\tkfree(shash);\n\t}\n}\n\nstatic struct crypto_aead *alloc_aead(int id)\n{\n\tstruct crypto_aead *tfm = NULL;\n\n\tswitch (id) {\n\tcase CRYPTO_AEAD_AES_GCM:\n\t\ttfm = crypto_alloc_aead(\"gcm(aes)\", 0, 0);\n\t\tbreak;\n\tcase CRYPTO_AEAD_AES_CCM:\n\t\ttfm = crypto_alloc_aead(\"ccm(aes)\", 0, 0);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Does not support encrypt ahead(id : %d)\\n\", id);\n\t\treturn NULL;\n\t}\n\n\tif (IS_ERR(tfm)) {\n\t\tpr_err(\"Failed to alloc encrypt aead : %ld\\n\", PTR_ERR(tfm));\n\t\treturn NULL;\n\t}\n\n\treturn tfm;\n}\n\nstatic struct shash_desc *alloc_shash_desc(int id)\n{\n\tstruct crypto_shash *tfm = NULL;\n\tstruct shash_desc *shash;\n\n\tswitch (id) {\n\tcase CRYPTO_SHASH_HMACMD5:\n\t\ttfm = crypto_alloc_shash(\"hmac(md5)\", 0, 0);\n\t\tbreak;\n\tcase CRYPTO_SHASH_HMACSHA256:\n\t\ttfm = crypto_alloc_shash(\"hmac(sha256)\", 0, 0);\n\t\tbreak;\n\tcase CRYPTO_SHASH_CMACAES:\n\t\ttfm = crypto_alloc_shash(\"cmac(aes)\", 0, 0);\n\t\tbreak;\n\tcase CRYPTO_SHASH_SHA256:\n\t\ttfm = crypto_alloc_shash(\"sha256\", 0, 0);\n\t\tbreak;\n\tcase CRYPTO_SHASH_SHA512:\n\t\ttfm = crypto_alloc_shash(\"sha512\", 0, 0);\n\t\tbreak;\n\tdefault:\n\t\treturn NULL;\n\t}\n\n\tif (IS_ERR(tfm))\n\t\treturn NULL;\n\n\tshash = kzalloc(sizeof(*shash) + crypto_shash_descsize(tfm),\n\t\t\tGFP_KERNEL);\n\tif (!shash)\n\t\tcrypto_free_shash(tfm);\n\telse\n\t\tshash->tfm = tfm;\n\treturn shash;\n}\n\nstatic void ctx_free(struct ksmbd_crypto_ctx *ctx)\n{\n\tint i;\n\n\tfor (i = 0; i < CRYPTO_SHASH_MAX; i++)\n\t\tfree_shash(ctx->desc[i]);\n\tfor (i = 0; i < CRYPTO_AEAD_MAX; i++)\n\t\tfree_aead(ctx->ccmaes[i]);\n\tkfree(ctx);\n}\n\nstatic struct ksmbd_crypto_ctx *ksmbd_find_crypto_ctx(void)\n{\n\tstruct ksmbd_crypto_ctx *ctx;\n\n\twhile (1) {\n\t\tspin_lock(&ctx_list.ctx_lock);\n\t\tif (!list_empty(&ctx_list.idle_ctx)) {\n\t\t\tctx = list_entry(ctx_list.idle_ctx.next,\n\t\t\t\t\t struct ksmbd_crypto_ctx,\n\t\t\t\t\t list);\n\t\t\tlist_del(&ctx->list);\n\t\t\tspin_unlock(&ctx_list.ctx_lock);\n\t\t\treturn ctx;\n\t\t}\n\n\t\tif (ctx_list.avail_ctx > num_online_cpus()) {\n\t\t\tspin_unlock(&ctx_list.ctx_lock);\n\t\t\twait_event(ctx_list.ctx_wait,\n\t\t\t\t   !list_empty(&ctx_list.idle_ctx));\n\t\t\tcontinue;\n\t\t}\n\n\t\tctx_list.avail_ctx++;\n\t\tspin_unlock(&ctx_list.ctx_lock);\n\n\t\tctx = kzalloc(sizeof(struct ksmbd_crypto_ctx), GFP_KERNEL);\n\t\tif (!ctx) {\n\t\t\tspin_lock(&ctx_list.ctx_lock);\n\t\t\tctx_list.avail_ctx--;\n\t\t\tspin_unlock(&ctx_list.ctx_lock);\n\t\t\twait_event(ctx_list.ctx_wait,\n\t\t\t\t   !list_empty(&ctx_list.idle_ctx));\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\treturn ctx;\n}\n\nvoid ksmbd_release_crypto_ctx(struct ksmbd_crypto_ctx *ctx)\n{\n\tif (!ctx)\n\t\treturn;\n\n\tspin_lock(&ctx_list.ctx_lock);\n\tif (ctx_list.avail_ctx <= num_online_cpus()) {\n\t\tlist_add(&ctx->list, &ctx_list.idle_ctx);\n\t\tspin_unlock(&ctx_list.ctx_lock);\n\t\twake_up(&ctx_list.ctx_wait);\n\t\treturn;\n\t}\n\n\tctx_list.avail_ctx--;\n\tspin_unlock(&ctx_list.ctx_lock);\n\tctx_free(ctx);\n}\n\nstatic struct ksmbd_crypto_ctx *____crypto_shash_ctx_find(int id)\n{\n\tstruct ksmbd_crypto_ctx *ctx;\n\n\tif (id >= CRYPTO_SHASH_MAX)\n\t\treturn NULL;\n\n\tctx = ksmbd_find_crypto_ctx();\n\tif (ctx->desc[id])\n\t\treturn ctx;\n\n\tctx->desc[id] = alloc_shash_desc(id);\n\tif (ctx->desc[id])\n\t\treturn ctx;\n\tksmbd_release_crypto_ctx(ctx);\n\treturn NULL;\n}\n\nstruct ksmbd_crypto_ctx *ksmbd_crypto_ctx_find_hmacmd5(void)\n{\n\treturn ____crypto_shash_ctx_find(CRYPTO_SHASH_HMACMD5);\n}\n\nstruct ksmbd_crypto_ctx *ksmbd_crypto_ctx_find_hmacsha256(void)\n{\n\treturn ____crypto_shash_ctx_find(CRYPTO_SHASH_HMACSHA256);\n}\n\nstruct ksmbd_crypto_ctx *ksmbd_crypto_ctx_find_cmacaes(void)\n{\n\treturn ____crypto_shash_ctx_find(CRYPTO_SHASH_CMACAES);\n}\n\nstruct ksmbd_crypto_ctx *ksmbd_crypto_ctx_find_sha256(void)\n{\n\treturn ____crypto_shash_ctx_find(CRYPTO_SHASH_SHA256);\n}\n\nstruct ksmbd_crypto_ctx *ksmbd_crypto_ctx_find_sha512(void)\n{\n\treturn ____crypto_shash_ctx_find(CRYPTO_SHASH_SHA512);\n}\n\nstatic struct ksmbd_crypto_ctx *____crypto_aead_ctx_find(int id)\n{\n\tstruct ksmbd_crypto_ctx *ctx;\n\n\tif (id >= CRYPTO_AEAD_MAX)\n\t\treturn NULL;\n\n\tctx = ksmbd_find_crypto_ctx();\n\tif (ctx->ccmaes[id])\n\t\treturn ctx;\n\n\tctx->ccmaes[id] = alloc_aead(id);\n\tif (ctx->ccmaes[id])\n\t\treturn ctx;\n\tksmbd_release_crypto_ctx(ctx);\n\treturn NULL;\n}\n\nstruct ksmbd_crypto_ctx *ksmbd_crypto_ctx_find_gcm(void)\n{\n\treturn ____crypto_aead_ctx_find(CRYPTO_AEAD_AES_GCM);\n}\n\nstruct ksmbd_crypto_ctx *ksmbd_crypto_ctx_find_ccm(void)\n{\n\treturn ____crypto_aead_ctx_find(CRYPTO_AEAD_AES_CCM);\n}\n\nvoid ksmbd_crypto_destroy(void)\n{\n\tstruct ksmbd_crypto_ctx *ctx;\n\n\twhile (!list_empty(&ctx_list.idle_ctx)) {\n\t\tctx = list_entry(ctx_list.idle_ctx.next,\n\t\t\t\t struct ksmbd_crypto_ctx,\n\t\t\t\t list);\n\t\tlist_del(&ctx->list);\n\t\tctx_free(ctx);\n\t}\n}\n\nint ksmbd_crypto_create(void)\n{\n\tstruct ksmbd_crypto_ctx *ctx;\n\n\tspin_lock_init(&ctx_list.ctx_lock);\n\tINIT_LIST_HEAD(&ctx_list.idle_ctx);\n\tinit_waitqueue_head(&ctx_list.ctx_wait);\n\tctx_list.avail_ctx = 1;\n\n\tctx = kzalloc(sizeof(struct ksmbd_crypto_ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\tlist_add(&ctx->list, &ctx_list.idle_ctx);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}