{
  "module_name": "locks.c",
  "hash_id": "834b081828de3fdc8db5df35f091f2b8365d0e95b36eb7680fc65e89aa678d25",
  "original_prompt": "Ingested from linux-6.6.14/fs/locks.c",
  "human_readable_source": "\n \n\n#include <linux/capability.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/filelock.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/time.h>\n#include <linux/rcupdate.h>\n#include <linux/pid_namespace.h>\n#include <linux/hashtable.h>\n#include <linux/percpu.h>\n#include <linux/sysctl.h>\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/filelock.h>\n\n#include <linux/uaccess.h>\n\n#define IS_POSIX(fl)\t(fl->fl_flags & FL_POSIX)\n#define IS_FLOCK(fl)\t(fl->fl_flags & FL_FLOCK)\n#define IS_LEASE(fl)\t(fl->fl_flags & (FL_LEASE|FL_DELEG|FL_LAYOUT))\n#define IS_OFDLCK(fl)\t(fl->fl_flags & FL_OFDLCK)\n#define IS_REMOTELCK(fl)\t(fl->fl_pid <= 0)\n\nstatic bool lease_breaking(struct file_lock *fl)\n{\n\treturn fl->fl_flags & (FL_UNLOCK_PENDING | FL_DOWNGRADE_PENDING);\n}\n\nstatic int target_leasetype(struct file_lock *fl)\n{\n\tif (fl->fl_flags & FL_UNLOCK_PENDING)\n\t\treturn F_UNLCK;\n\tif (fl->fl_flags & FL_DOWNGRADE_PENDING)\n\t\treturn F_RDLCK;\n\treturn fl->fl_type;\n}\n\nstatic int leases_enable = 1;\nstatic int lease_break_time = 45;\n\n#ifdef CONFIG_SYSCTL\nstatic struct ctl_table locks_sysctls[] = {\n\t{\n\t\t.procname\t= \"leases-enable\",\n\t\t.data\t\t= &leases_enable,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#ifdef CONFIG_MMU\n\t{\n\t\t.procname\t= \"lease-break-time\",\n\t\t.data\t\t= &lease_break_time,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif  \n\t{}\n};\n\nstatic int __init init_fs_locks_sysctls(void)\n{\n\tregister_sysctl_init(\"fs\", locks_sysctls);\n\treturn 0;\n}\nearly_initcall(init_fs_locks_sysctls);\n#endif  \n\n \nstruct file_lock_list_struct {\n\tspinlock_t\t\tlock;\n\tstruct hlist_head\thlist;\n};\nstatic DEFINE_PER_CPU(struct file_lock_list_struct, file_lock_list);\nDEFINE_STATIC_PERCPU_RWSEM(file_rwsem);\n\n\n \n#define BLOCKED_HASH_BITS\t7\nstatic DEFINE_HASHTABLE(blocked_hash, BLOCKED_HASH_BITS);\n\n \nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic struct kmem_cache *flctx_cache __read_mostly;\nstatic struct kmem_cache *filelock_cache __read_mostly;\n\nstatic struct file_lock_context *\nlocks_get_lock_context(struct inode *inode, int type)\n{\n\tstruct file_lock_context *ctx;\n\n\t \n\tctx = locks_inode_context(inode);\n\tif (likely(ctx) || type == F_UNLCK)\n\t\tgoto out;\n\n\tctx = kmem_cache_alloc(flctx_cache, GFP_KERNEL);\n\tif (!ctx)\n\t\tgoto out;\n\n\tspin_lock_init(&ctx->flc_lock);\n\tINIT_LIST_HEAD(&ctx->flc_flock);\n\tINIT_LIST_HEAD(&ctx->flc_posix);\n\tINIT_LIST_HEAD(&ctx->flc_lease);\n\n\t \n\tif (cmpxchg(&inode->i_flctx, NULL, ctx)) {\n\t\tkmem_cache_free(flctx_cache, ctx);\n\t\tctx = locks_inode_context(inode);\n\t}\nout:\n\ttrace_locks_get_lock_context(inode, type, ctx);\n\treturn ctx;\n}\n\nstatic void\nlocks_dump_ctx_list(struct list_head *list, char *list_type)\n{\n\tstruct file_lock *fl;\n\n\tlist_for_each_entry(fl, list, fl_list) {\n\t\tpr_warn(\"%s: fl_owner=%p fl_flags=0x%x fl_type=0x%x fl_pid=%u\\n\", list_type, fl->fl_owner, fl->fl_flags, fl->fl_type, fl->fl_pid);\n\t}\n}\n\nstatic void\nlocks_check_ctx_lists(struct inode *inode)\n{\n\tstruct file_lock_context *ctx = inode->i_flctx;\n\n\tif (unlikely(!list_empty(&ctx->flc_flock) ||\n\t\t     !list_empty(&ctx->flc_posix) ||\n\t\t     !list_empty(&ctx->flc_lease))) {\n\t\tpr_warn(\"Leaked locks on dev=0x%x:0x%x ino=0x%lx:\\n\",\n\t\t\tMAJOR(inode->i_sb->s_dev), MINOR(inode->i_sb->s_dev),\n\t\t\tinode->i_ino);\n\t\tlocks_dump_ctx_list(&ctx->flc_flock, \"FLOCK\");\n\t\tlocks_dump_ctx_list(&ctx->flc_posix, \"POSIX\");\n\t\tlocks_dump_ctx_list(&ctx->flc_lease, \"LEASE\");\n\t}\n}\n\nstatic void\nlocks_check_ctx_file_list(struct file *filp, struct list_head *list,\n\t\t\t\tchar *list_type)\n{\n\tstruct file_lock *fl;\n\tstruct inode *inode = file_inode(filp);\n\n\tlist_for_each_entry(fl, list, fl_list)\n\t\tif (fl->fl_file == filp)\n\t\t\tpr_warn(\"Leaked %s lock on dev=0x%x:0x%x ino=0x%lx \"\n\t\t\t\t\" fl_owner=%p fl_flags=0x%x fl_type=0x%x fl_pid=%u\\n\",\n\t\t\t\tlist_type, MAJOR(inode->i_sb->s_dev),\n\t\t\t\tMINOR(inode->i_sb->s_dev), inode->i_ino,\n\t\t\t\tfl->fl_owner, fl->fl_flags, fl->fl_type, fl->fl_pid);\n}\n\nvoid\nlocks_free_lock_context(struct inode *inode)\n{\n\tstruct file_lock_context *ctx = locks_inode_context(inode);\n\n\tif (unlikely(ctx)) {\n\t\tlocks_check_ctx_lists(inode);\n\t\tkmem_cache_free(flctx_cache, ctx);\n\t}\n}\n\nstatic void locks_init_lock_heads(struct file_lock *fl)\n{\n\tINIT_HLIST_NODE(&fl->fl_link);\n\tINIT_LIST_HEAD(&fl->fl_list);\n\tINIT_LIST_HEAD(&fl->fl_blocked_requests);\n\tINIT_LIST_HEAD(&fl->fl_blocked_member);\n\tinit_waitqueue_head(&fl->fl_wait);\n}\n\n \nstruct file_lock *locks_alloc_lock(void)\n{\n\tstruct file_lock *fl = kmem_cache_zalloc(filelock_cache, GFP_KERNEL);\n\n\tif (fl)\n\t\tlocks_init_lock_heads(fl);\n\n\treturn fl;\n}\nEXPORT_SYMBOL_GPL(locks_alloc_lock);\n\nvoid locks_release_private(struct file_lock *fl)\n{\n\tBUG_ON(waitqueue_active(&fl->fl_wait));\n\tBUG_ON(!list_empty(&fl->fl_list));\n\tBUG_ON(!list_empty(&fl->fl_blocked_requests));\n\tBUG_ON(!list_empty(&fl->fl_blocked_member));\n\tBUG_ON(!hlist_unhashed(&fl->fl_link));\n\n\tif (fl->fl_ops) {\n\t\tif (fl->fl_ops->fl_release_private)\n\t\t\tfl->fl_ops->fl_release_private(fl);\n\t\tfl->fl_ops = NULL;\n\t}\n\n\tif (fl->fl_lmops) {\n\t\tif (fl->fl_lmops->lm_put_owner) {\n\t\t\tfl->fl_lmops->lm_put_owner(fl->fl_owner);\n\t\t\tfl->fl_owner = NULL;\n\t\t}\n\t\tfl->fl_lmops = NULL;\n\t}\n}\nEXPORT_SYMBOL_GPL(locks_release_private);\n\n \nbool locks_owner_has_blockers(struct file_lock_context *flctx,\n\t\tfl_owner_t owner)\n{\n\tstruct file_lock *fl;\n\n\tspin_lock(&flctx->flc_lock);\n\tlist_for_each_entry(fl, &flctx->flc_posix, fl_list) {\n\t\tif (fl->fl_owner != owner)\n\t\t\tcontinue;\n\t\tif (!list_empty(&fl->fl_blocked_requests)) {\n\t\t\tspin_unlock(&flctx->flc_lock);\n\t\t\treturn true;\n\t\t}\n\t}\n\tspin_unlock(&flctx->flc_lock);\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(locks_owner_has_blockers);\n\n \nvoid locks_free_lock(struct file_lock *fl)\n{\n\tlocks_release_private(fl);\n\tkmem_cache_free(filelock_cache, fl);\n}\nEXPORT_SYMBOL(locks_free_lock);\n\nstatic void\nlocks_dispose_list(struct list_head *dispose)\n{\n\tstruct file_lock *fl;\n\n\twhile (!list_empty(dispose)) {\n\t\tfl = list_first_entry(dispose, struct file_lock, fl_list);\n\t\tlist_del_init(&fl->fl_list);\n\t\tlocks_free_lock(fl);\n\t}\n}\n\nvoid locks_init_lock(struct file_lock *fl)\n{\n\tmemset(fl, 0, sizeof(struct file_lock));\n\tlocks_init_lock_heads(fl);\n}\nEXPORT_SYMBOL(locks_init_lock);\n\n \nvoid locks_copy_conflock(struct file_lock *new, struct file_lock *fl)\n{\n\tnew->fl_owner = fl->fl_owner;\n\tnew->fl_pid = fl->fl_pid;\n\tnew->fl_file = NULL;\n\tnew->fl_flags = fl->fl_flags;\n\tnew->fl_type = fl->fl_type;\n\tnew->fl_start = fl->fl_start;\n\tnew->fl_end = fl->fl_end;\n\tnew->fl_lmops = fl->fl_lmops;\n\tnew->fl_ops = NULL;\n\n\tif (fl->fl_lmops) {\n\t\tif (fl->fl_lmops->lm_get_owner)\n\t\t\tfl->fl_lmops->lm_get_owner(fl->fl_owner);\n\t}\n}\nEXPORT_SYMBOL(locks_copy_conflock);\n\nvoid locks_copy_lock(struct file_lock *new, struct file_lock *fl)\n{\n\t \n\tWARN_ON_ONCE(new->fl_ops);\n\n\tlocks_copy_conflock(new, fl);\n\n\tnew->fl_file = fl->fl_file;\n\tnew->fl_ops = fl->fl_ops;\n\n\tif (fl->fl_ops) {\n\t\tif (fl->fl_ops->fl_copy_lock)\n\t\t\tfl->fl_ops->fl_copy_lock(new, fl);\n\t}\n}\nEXPORT_SYMBOL(locks_copy_lock);\n\nstatic void locks_move_blocks(struct file_lock *new, struct file_lock *fl)\n{\n\tstruct file_lock *f;\n\n\t \n\tif (list_empty(&fl->fl_blocked_requests))\n\t\treturn;\n\tspin_lock(&blocked_lock_lock);\n\tlist_splice_init(&fl->fl_blocked_requests, &new->fl_blocked_requests);\n\tlist_for_each_entry(f, &new->fl_blocked_requests, fl_blocked_member)\n\t\tf->fl_blocker = new;\n\tspin_unlock(&blocked_lock_lock);\n}\n\nstatic inline int flock_translate_cmd(int cmd) {\n\tswitch (cmd) {\n\tcase LOCK_SH:\n\t\treturn F_RDLCK;\n\tcase LOCK_EX:\n\t\treturn F_WRLCK;\n\tcase LOCK_UN:\n\t\treturn F_UNLCK;\n\t}\n\treturn -EINVAL;\n}\n\n \nstatic void flock_make_lock(struct file *filp, struct file_lock *fl, int type)\n{\n\tlocks_init_lock(fl);\n\n\tfl->fl_file = filp;\n\tfl->fl_owner = filp;\n\tfl->fl_pid = current->tgid;\n\tfl->fl_flags = FL_FLOCK;\n\tfl->fl_type = type;\n\tfl->fl_end = OFFSET_MAX;\n}\n\nstatic int assign_type(struct file_lock *fl, int type)\n{\n\tswitch (type) {\n\tcase F_RDLCK:\n\tcase F_WRLCK:\n\tcase F_UNLCK:\n\t\tfl->fl_type = type;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int flock64_to_posix_lock(struct file *filp, struct file_lock *fl,\n\t\t\t\t struct flock64 *l)\n{\n\tswitch (l->l_whence) {\n\tcase SEEK_SET:\n\t\tfl->fl_start = 0;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\tfl->fl_start = filp->f_pos;\n\t\tbreak;\n\tcase SEEK_END:\n\t\tfl->fl_start = i_size_read(file_inode(filp));\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (l->l_start > OFFSET_MAX - fl->fl_start)\n\t\treturn -EOVERFLOW;\n\tfl->fl_start += l->l_start;\n\tif (fl->fl_start < 0)\n\t\treturn -EINVAL;\n\n\t \n\tif (l->l_len > 0) {\n\t\tif (l->l_len - 1 > OFFSET_MAX - fl->fl_start)\n\t\t\treturn -EOVERFLOW;\n\t\tfl->fl_end = fl->fl_start + (l->l_len - 1);\n\n\t} else if (l->l_len < 0) {\n\t\tif (fl->fl_start + l->l_len < 0)\n\t\t\treturn -EINVAL;\n\t\tfl->fl_end = fl->fl_start - 1;\n\t\tfl->fl_start += l->l_len;\n\t} else\n\t\tfl->fl_end = OFFSET_MAX;\n\n\tfl->fl_owner = current->files;\n\tfl->fl_pid = current->tgid;\n\tfl->fl_file = filp;\n\tfl->fl_flags = FL_POSIX;\n\tfl->fl_ops = NULL;\n\tfl->fl_lmops = NULL;\n\n\treturn assign_type(fl, l->l_type);\n}\n\n \nstatic int flock_to_posix_lock(struct file *filp, struct file_lock *fl,\n\t\t\t       struct flock *l)\n{\n\tstruct flock64 ll = {\n\t\t.l_type = l->l_type,\n\t\t.l_whence = l->l_whence,\n\t\t.l_start = l->l_start,\n\t\t.l_len = l->l_len,\n\t};\n\n\treturn flock64_to_posix_lock(filp, fl, &ll);\n}\n\n \nstatic bool\nlease_break_callback(struct file_lock *fl)\n{\n\tkill_fasync(&fl->fl_fasync, SIGIO, POLL_MSG);\n\treturn false;\n}\n\nstatic void\nlease_setup(struct file_lock *fl, void **priv)\n{\n\tstruct file *filp = fl->fl_file;\n\tstruct fasync_struct *fa = *priv;\n\n\t \n\tif (!fasync_insert_entry(fa->fa_fd, filp, &fl->fl_fasync, fa))\n\t\t*priv = NULL;\n\n\t__f_setown(filp, task_pid(current), PIDTYPE_TGID, 0);\n}\n\nstatic const struct lock_manager_operations lease_manager_ops = {\n\t.lm_break = lease_break_callback,\n\t.lm_change = lease_modify,\n\t.lm_setup = lease_setup,\n};\n\n \nstatic int lease_init(struct file *filp, int type, struct file_lock *fl)\n{\n\tif (assign_type(fl, type) != 0)\n\t\treturn -EINVAL;\n\n\tfl->fl_owner = filp;\n\tfl->fl_pid = current->tgid;\n\n\tfl->fl_file = filp;\n\tfl->fl_flags = FL_LEASE;\n\tfl->fl_start = 0;\n\tfl->fl_end = OFFSET_MAX;\n\tfl->fl_ops = NULL;\n\tfl->fl_lmops = &lease_manager_ops;\n\treturn 0;\n}\n\n \nstatic struct file_lock *lease_alloc(struct file *filp, int type)\n{\n\tstruct file_lock *fl = locks_alloc_lock();\n\tint error = -ENOMEM;\n\n\tif (fl == NULL)\n\t\treturn ERR_PTR(error);\n\n\terror = lease_init(filp, type, fl);\n\tif (error) {\n\t\tlocks_free_lock(fl);\n\t\treturn ERR_PTR(error);\n\t}\n\treturn fl;\n}\n\n \nstatic inline int locks_overlap(struct file_lock *fl1, struct file_lock *fl2)\n{\n\treturn ((fl1->fl_end >= fl2->fl_start) &&\n\t\t(fl2->fl_end >= fl1->fl_start));\n}\n\n \nstatic int posix_same_owner(struct file_lock *fl1, struct file_lock *fl2)\n{\n\treturn fl1->fl_owner == fl2->fl_owner;\n}\n\n \nstatic void locks_insert_global_locks(struct file_lock *fl)\n{\n\tstruct file_lock_list_struct *fll = this_cpu_ptr(&file_lock_list);\n\n\tpercpu_rwsem_assert_held(&file_rwsem);\n\n\tspin_lock(&fll->lock);\n\tfl->fl_link_cpu = smp_processor_id();\n\thlist_add_head(&fl->fl_link, &fll->hlist);\n\tspin_unlock(&fll->lock);\n}\n\n \nstatic void locks_delete_global_locks(struct file_lock *fl)\n{\n\tstruct file_lock_list_struct *fll;\n\n\tpercpu_rwsem_assert_held(&file_rwsem);\n\n\t \n\tif (hlist_unhashed(&fl->fl_link))\n\t\treturn;\n\n\tfll = per_cpu_ptr(&file_lock_list, fl->fl_link_cpu);\n\tspin_lock(&fll->lock);\n\thlist_del_init(&fl->fl_link);\n\tspin_unlock(&fll->lock);\n}\n\nstatic unsigned long\nposix_owner_key(struct file_lock *fl)\n{\n\treturn (unsigned long)fl->fl_owner;\n}\n\nstatic void locks_insert_global_blocked(struct file_lock *waiter)\n{\n\tlockdep_assert_held(&blocked_lock_lock);\n\n\thash_add(blocked_hash, &waiter->fl_link, posix_owner_key(waiter));\n}\n\nstatic void locks_delete_global_blocked(struct file_lock *waiter)\n{\n\tlockdep_assert_held(&blocked_lock_lock);\n\n\thash_del(&waiter->fl_link);\n}\n\n \nstatic void __locks_delete_block(struct file_lock *waiter)\n{\n\tlocks_delete_global_blocked(waiter);\n\tlist_del_init(&waiter->fl_blocked_member);\n}\n\nstatic void __locks_wake_up_blocks(struct file_lock *blocker)\n{\n\twhile (!list_empty(&blocker->fl_blocked_requests)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_blocked_requests,\n\t\t\t\t\t  struct file_lock, fl_blocked_member);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\n\t\t \n\t\tsmp_store_release(&waiter->fl_blocker, NULL);\n\t}\n}\n\n \nint locks_delete_block(struct file_lock *waiter)\n{\n\tint status = -ENOENT;\n\n\t \n\tif (!smp_load_acquire(&waiter->fl_blocker) &&\n\t    list_empty(&waiter->fl_blocked_requests))\n\t\treturn status;\n\n\tspin_lock(&blocked_lock_lock);\n\tif (waiter->fl_blocker)\n\t\tstatus = 0;\n\t__locks_wake_up_blocks(waiter);\n\t__locks_delete_block(waiter);\n\n\t \n\tsmp_store_release(&waiter->fl_blocker, NULL);\n\tspin_unlock(&blocked_lock_lock);\n\treturn status;\n}\nEXPORT_SYMBOL(locks_delete_block);\n\n \nstatic void __locks_insert_block(struct file_lock *blocker,\n\t\t\t\t struct file_lock *waiter,\n\t\t\t\t bool conflict(struct file_lock *,\n\t\t\t\t\t       struct file_lock *))\n{\n\tstruct file_lock *fl;\n\tBUG_ON(!list_empty(&waiter->fl_blocked_member));\n\nnew_blocker:\n\tlist_for_each_entry(fl, &blocker->fl_blocked_requests, fl_blocked_member)\n\t\tif (conflict(fl, waiter)) {\n\t\t\tblocker =  fl;\n\t\t\tgoto new_blocker;\n\t\t}\n\twaiter->fl_blocker = blocker;\n\tlist_add_tail(&waiter->fl_blocked_member, &blocker->fl_blocked_requests);\n\tif (IS_POSIX(blocker) && !IS_OFDLCK(blocker))\n\t\tlocks_insert_global_blocked(waiter);\n\n\t \n\t__locks_wake_up_blocks(waiter);\n}\n\n \nstatic void locks_insert_block(struct file_lock *blocker,\n\t\t\t       struct file_lock *waiter,\n\t\t\t       bool conflict(struct file_lock *,\n\t\t\t\t\t     struct file_lock *))\n{\n\tspin_lock(&blocked_lock_lock);\n\t__locks_insert_block(blocker, waiter, conflict);\n\tspin_unlock(&blocked_lock_lock);\n}\n\n \nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t \n\tif (list_empty(&blocker->fl_blocked_requests))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\t__locks_wake_up_blocks(blocker);\n\tspin_unlock(&blocked_lock_lock);\n}\n\nstatic void\nlocks_insert_lock_ctx(struct file_lock *fl, struct list_head *before)\n{\n\tlist_add_tail(&fl->fl_list, before);\n\tlocks_insert_global_locks(fl);\n}\n\nstatic void\nlocks_unlink_lock_ctx(struct file_lock *fl)\n{\n\tlocks_delete_global_locks(fl);\n\tlist_del_init(&fl->fl_list);\n\tlocks_wake_up_blocks(fl);\n}\n\nstatic void\nlocks_delete_lock_ctx(struct file_lock *fl, struct list_head *dispose)\n{\n\tlocks_unlink_lock_ctx(fl);\n\tif (dispose)\n\t\tlist_add(&fl->fl_list, dispose);\n\telse\n\t\tlocks_free_lock(fl);\n}\n\n \nstatic bool locks_conflict(struct file_lock *caller_fl,\n\t\t\t   struct file_lock *sys_fl)\n{\n\tif (sys_fl->fl_type == F_WRLCK)\n\t\treturn true;\n\tif (caller_fl->fl_type == F_WRLCK)\n\t\treturn true;\n\treturn false;\n}\n\n \nstatic bool posix_locks_conflict(struct file_lock *caller_fl,\n\t\t\t\t struct file_lock *sys_fl)\n{\n\t \n\tif (posix_same_owner(caller_fl, sys_fl))\n\t\treturn false;\n\n\t \n\tif (!locks_overlap(caller_fl, sys_fl))\n\t\treturn false;\n\n\treturn locks_conflict(caller_fl, sys_fl);\n}\n\n \nstatic bool posix_test_locks_conflict(struct file_lock *caller_fl,\n\t\t\t\t      struct file_lock *sys_fl)\n{\n\t \n\tif (caller_fl->fl_type == F_UNLCK) {\n\t\tif (!posix_same_owner(caller_fl, sys_fl))\n\t\t\treturn false;\n\t\treturn locks_overlap(caller_fl, sys_fl);\n\t}\n\treturn posix_locks_conflict(caller_fl, sys_fl);\n}\n\n \nstatic bool flock_locks_conflict(struct file_lock *caller_fl,\n\t\t\t\t struct file_lock *sys_fl)\n{\n\t \n\tif (caller_fl->fl_file == sys_fl->fl_file)\n\t\treturn false;\n\n\treturn locks_conflict(caller_fl, sys_fl);\n}\n\nvoid\nposix_test_lock(struct file *filp, struct file_lock *fl)\n{\n\tstruct file_lock *cfl;\n\tstruct file_lock_context *ctx;\n\tstruct inode *inode = file_inode(filp);\n\tvoid *owner;\n\tvoid (*func)(void);\n\n\tctx = locks_inode_context(inode);\n\tif (!ctx || list_empty_careful(&ctx->flc_posix)) {\n\t\tfl->fl_type = F_UNLCK;\n\t\treturn;\n\t}\n\nretry:\n\tspin_lock(&ctx->flc_lock);\n\tlist_for_each_entry(cfl, &ctx->flc_posix, fl_list) {\n\t\tif (!posix_test_locks_conflict(fl, cfl))\n\t\t\tcontinue;\n\t\tif (cfl->fl_lmops && cfl->fl_lmops->lm_lock_expirable\n\t\t\t&& (*cfl->fl_lmops->lm_lock_expirable)(cfl)) {\n\t\t\towner = cfl->fl_lmops->lm_mod_owner;\n\t\t\tfunc = cfl->fl_lmops->lm_expire_lock;\n\t\t\t__module_get(owner);\n\t\t\tspin_unlock(&ctx->flc_lock);\n\t\t\t(*func)();\n\t\t\tmodule_put(owner);\n\t\t\tgoto retry;\n\t\t}\n\t\tlocks_copy_conflock(fl, cfl);\n\t\tgoto out;\n\t}\n\tfl->fl_type = F_UNLCK;\nout:\n\tspin_unlock(&ctx->flc_lock);\n\treturn;\n}\nEXPORT_SYMBOL(posix_test_lock);\n\n \n\n#define MAX_DEADLK_ITERATIONS 10\n\n \nstatic struct file_lock *what_owner_is_waiting_for(struct file_lock *block_fl)\n{\n\tstruct file_lock *fl;\n\n\thash_for_each_possible(blocked_hash, fl, fl_link, posix_owner_key(block_fl)) {\n\t\tif (posix_same_owner(fl, block_fl)) {\n\t\t\twhile (fl->fl_blocker)\n\t\t\t\tfl = fl->fl_blocker;\n\t\t\treturn fl;\n\t\t}\n\t}\n\treturn NULL;\n}\n\n \nstatic int posix_locks_deadlock(struct file_lock *caller_fl,\n\t\t\t\tstruct file_lock *block_fl)\n{\n\tint i = 0;\n\n\tlockdep_assert_held(&blocked_lock_lock);\n\n\t \n\tif (IS_OFDLCK(caller_fl))\n\t\treturn 0;\n\n\twhile ((block_fl = what_owner_is_waiting_for(block_fl))) {\n\t\tif (i++ > MAX_DEADLK_ITERATIONS)\n\t\t\treturn 0;\n\t\tif (posix_same_owner(caller_fl, block_fl))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \nstatic int flock_lock_inode(struct inode *inode, struct file_lock *request)\n{\n\tstruct file_lock *new_fl = NULL;\n\tstruct file_lock *fl;\n\tstruct file_lock_context *ctx;\n\tint error = 0;\n\tbool found = false;\n\tLIST_HEAD(dispose);\n\n\tctx = locks_get_lock_context(inode, request->fl_type);\n\tif (!ctx) {\n\t\tif (request->fl_type != F_UNLCK)\n\t\t\treturn -ENOMEM;\n\t\treturn (request->fl_flags & FL_EXISTS) ? -ENOENT : 0;\n\t}\n\n\tif (!(request->fl_flags & FL_ACCESS) && (request->fl_type != F_UNLCK)) {\n\t\tnew_fl = locks_alloc_lock();\n\t\tif (!new_fl)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tpercpu_down_read(&file_rwsem);\n\tspin_lock(&ctx->flc_lock);\n\tif (request->fl_flags & FL_ACCESS)\n\t\tgoto find_conflict;\n\n\tlist_for_each_entry(fl, &ctx->flc_flock, fl_list) {\n\t\tif (request->fl_file != fl->fl_file)\n\t\t\tcontinue;\n\t\tif (request->fl_type == fl->fl_type)\n\t\t\tgoto out;\n\t\tfound = true;\n\t\tlocks_delete_lock_ctx(fl, &dispose);\n\t\tbreak;\n\t}\n\n\tif (request->fl_type == F_UNLCK) {\n\t\tif ((request->fl_flags & FL_EXISTS) && !found)\n\t\t\terror = -ENOENT;\n\t\tgoto out;\n\t}\n\nfind_conflict:\n\tlist_for_each_entry(fl, &ctx->flc_flock, fl_list) {\n\t\tif (!flock_locks_conflict(request, fl))\n\t\t\tcontinue;\n\t\terror = -EAGAIN;\n\t\tif (!(request->fl_flags & FL_SLEEP))\n\t\t\tgoto out;\n\t\terror = FILE_LOCK_DEFERRED;\n\t\tlocks_insert_block(fl, request, flock_locks_conflict);\n\t\tgoto out;\n\t}\n\tif (request->fl_flags & FL_ACCESS)\n\t\tgoto out;\n\tlocks_copy_lock(new_fl, request);\n\tlocks_move_blocks(new_fl, request);\n\tlocks_insert_lock_ctx(new_fl, &ctx->flc_flock);\n\tnew_fl = NULL;\n\terror = 0;\n\nout:\n\tspin_unlock(&ctx->flc_lock);\n\tpercpu_up_read(&file_rwsem);\n\tif (new_fl)\n\t\tlocks_free_lock(new_fl);\n\tlocks_dispose_list(&dispose);\n\ttrace_flock_lock_inode(inode, request, error);\n\treturn error;\n}\n\nstatic int posix_lock_inode(struct inode *inode, struct file_lock *request,\n\t\t\t    struct file_lock *conflock)\n{\n\tstruct file_lock *fl, *tmp;\n\tstruct file_lock *new_fl = NULL;\n\tstruct file_lock *new_fl2 = NULL;\n\tstruct file_lock *left = NULL;\n\tstruct file_lock *right = NULL;\n\tstruct file_lock_context *ctx;\n\tint error;\n\tbool added = false;\n\tLIST_HEAD(dispose);\n\tvoid *owner;\n\tvoid (*func)(void);\n\n\tctx = locks_get_lock_context(inode, request->fl_type);\n\tif (!ctx)\n\t\treturn (request->fl_type == F_UNLCK) ? 0 : -ENOMEM;\n\n\t \n\tif (!(request->fl_flags & FL_ACCESS) &&\n\t    (request->fl_type != F_UNLCK ||\n\t     request->fl_start != 0 || request->fl_end != OFFSET_MAX)) {\n\t\tnew_fl = locks_alloc_lock();\n\t\tnew_fl2 = locks_alloc_lock();\n\t}\n\nretry:\n\tpercpu_down_read(&file_rwsem);\n\tspin_lock(&ctx->flc_lock);\n\t \n\tif (request->fl_type != F_UNLCK) {\n\t\tlist_for_each_entry(fl, &ctx->flc_posix, fl_list) {\n\t\t\tif (!posix_locks_conflict(request, fl))\n\t\t\t\tcontinue;\n\t\t\tif (fl->fl_lmops && fl->fl_lmops->lm_lock_expirable\n\t\t\t\t&& (*fl->fl_lmops->lm_lock_expirable)(fl)) {\n\t\t\t\towner = fl->fl_lmops->lm_mod_owner;\n\t\t\t\tfunc = fl->fl_lmops->lm_expire_lock;\n\t\t\t\t__module_get(owner);\n\t\t\t\tspin_unlock(&ctx->flc_lock);\n\t\t\t\tpercpu_up_read(&file_rwsem);\n\t\t\t\t(*func)();\n\t\t\t\tmodule_put(owner);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\tif (conflock)\n\t\t\t\tlocks_copy_conflock(conflock, fl);\n\t\t\terror = -EAGAIN;\n\t\t\tif (!(request->fl_flags & FL_SLEEP))\n\t\t\t\tgoto out;\n\t\t\t \n\t\t\terror = -EDEADLK;\n\t\t\tspin_lock(&blocked_lock_lock);\n\t\t\t \n\t\t\t__locks_wake_up_blocks(request);\n\t\t\tif (likely(!posix_locks_deadlock(request, fl))) {\n\t\t\t\terror = FILE_LOCK_DEFERRED;\n\t\t\t\t__locks_insert_block(fl, request,\n\t\t\t\t\t\t     posix_locks_conflict);\n\t\t\t}\n\t\t\tspin_unlock(&blocked_lock_lock);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\terror = 0;\n\tif (request->fl_flags & FL_ACCESS)\n\t\tgoto out;\n\n\t \n\tlist_for_each_entry(fl, &ctx->flc_posix, fl_list) {\n\t\tif (posix_same_owner(request, fl))\n\t\t\tbreak;\n\t}\n\n\t \n\tlist_for_each_entry_safe_from(fl, tmp, &ctx->flc_posix, fl_list) {\n\t\tif (!posix_same_owner(request, fl))\n\t\t\tbreak;\n\n\t\t \n\t\tif (request->fl_type == fl->fl_type) {\n\t\t\t \n\t\t\tif (fl->fl_end < request->fl_start - 1)\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tif (fl->fl_start - 1 > request->fl_end)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tif (fl->fl_start > request->fl_start)\n\t\t\t\tfl->fl_start = request->fl_start;\n\t\t\telse\n\t\t\t\trequest->fl_start = fl->fl_start;\n\t\t\tif (fl->fl_end < request->fl_end)\n\t\t\t\tfl->fl_end = request->fl_end;\n\t\t\telse\n\t\t\t\trequest->fl_end = fl->fl_end;\n\t\t\tif (added) {\n\t\t\t\tlocks_delete_lock_ctx(fl, &dispose);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trequest = fl;\n\t\t\tadded = true;\n\t\t} else {\n\t\t\t \n\t\t\tif (fl->fl_end < request->fl_start)\n\t\t\t\tcontinue;\n\t\t\tif (fl->fl_start > request->fl_end)\n\t\t\t\tbreak;\n\t\t\tif (request->fl_type == F_UNLCK)\n\t\t\t\tadded = true;\n\t\t\tif (fl->fl_start < request->fl_start)\n\t\t\t\tleft = fl;\n\t\t\t \n\t\t\tif (fl->fl_end > request->fl_end) {\n\t\t\t\tright = fl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (fl->fl_start >= request->fl_start) {\n\t\t\t\t \n\t\t\t\tif (added) {\n\t\t\t\t\tlocks_delete_lock_ctx(fl, &dispose);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\terror = -ENOLCK;\n\t\t\t\tif (!new_fl)\n\t\t\t\t\tgoto out;\n\t\t\t\tlocks_copy_lock(new_fl, request);\n\t\t\t\tlocks_move_blocks(new_fl, request);\n\t\t\t\trequest = new_fl;\n\t\t\t\tnew_fl = NULL;\n\t\t\t\tlocks_insert_lock_ctx(request, &fl->fl_list);\n\t\t\t\tlocks_delete_lock_ctx(fl, &dispose);\n\t\t\t\tadded = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\terror = -ENOLCK;  \n\tif (right && left == right && !new_fl2)\n\t\tgoto out;\n\n\terror = 0;\n\tif (!added) {\n\t\tif (request->fl_type == F_UNLCK) {\n\t\t\tif (request->fl_flags & FL_EXISTS)\n\t\t\t\terror = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!new_fl) {\n\t\t\terror = -ENOLCK;\n\t\t\tgoto out;\n\t\t}\n\t\tlocks_copy_lock(new_fl, request);\n\t\tlocks_move_blocks(new_fl, request);\n\t\tlocks_insert_lock_ctx(new_fl, &fl->fl_list);\n\t\tfl = new_fl;\n\t\tnew_fl = NULL;\n\t}\n\tif (right) {\n\t\tif (left == right) {\n\t\t\t \n\t\t\tleft = new_fl2;\n\t\t\tnew_fl2 = NULL;\n\t\t\tlocks_copy_lock(left, right);\n\t\t\tlocks_insert_lock_ctx(left, &fl->fl_list);\n\t\t}\n\t\tright->fl_start = request->fl_end + 1;\n\t\tlocks_wake_up_blocks(right);\n\t}\n\tif (left) {\n\t\tleft->fl_end = request->fl_start - 1;\n\t\tlocks_wake_up_blocks(left);\n\t}\n out:\n\tspin_unlock(&ctx->flc_lock);\n\tpercpu_up_read(&file_rwsem);\n\ttrace_posix_lock_inode(inode, request, error);\n\t \n\tif (new_fl)\n\t\tlocks_free_lock(new_fl);\n\tif (new_fl2)\n\t\tlocks_free_lock(new_fl2);\n\tlocks_dispose_list(&dispose);\n\n\treturn error;\n}\n\n \nint posix_lock_file(struct file *filp, struct file_lock *fl,\n\t\t\tstruct file_lock *conflock)\n{\n\treturn posix_lock_inode(file_inode(filp), fl, conflock);\n}\nEXPORT_SYMBOL(posix_lock_file);\n\n \nstatic int posix_lock_inode_wait(struct inode *inode, struct file_lock *fl)\n{\n\tint error;\n\tmight_sleep ();\n\tfor (;;) {\n\t\terror = posix_lock_inode(inode, fl, NULL);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait,\n\t\t\t\t\tlist_empty(&fl->fl_blocked_member));\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\tlocks_delete_block(fl);\n\treturn error;\n}\n\nstatic void lease_clear_pending(struct file_lock *fl, int arg)\n{\n\tswitch (arg) {\n\tcase F_UNLCK:\n\t\tfl->fl_flags &= ~FL_UNLOCK_PENDING;\n\t\tfallthrough;\n\tcase F_RDLCK:\n\t\tfl->fl_flags &= ~FL_DOWNGRADE_PENDING;\n\t}\n}\n\n \nint lease_modify(struct file_lock *fl, int arg, struct list_head *dispose)\n{\n\tint error = assign_type(fl, arg);\n\n\tif (error)\n\t\treturn error;\n\tlease_clear_pending(fl, arg);\n\tlocks_wake_up_blocks(fl);\n\tif (arg == F_UNLCK) {\n\t\tstruct file *filp = fl->fl_file;\n\n\t\tf_delown(filp);\n\t\tfilp->f_owner.signum = 0;\n\t\tfasync_helper(0, fl->fl_file, 0, &fl->fl_fasync);\n\t\tif (fl->fl_fasync != NULL) {\n\t\t\tprintk(KERN_ERR \"locks_delete_lock: fasync == %p\\n\", fl->fl_fasync);\n\t\t\tfl->fl_fasync = NULL;\n\t\t}\n\t\tlocks_delete_lock_ctx(fl, dispose);\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(lease_modify);\n\nstatic bool past_time(unsigned long then)\n{\n\tif (!then)\n\t\t \n\t\treturn false;\n\treturn time_after(jiffies, then);\n}\n\nstatic void time_out_leases(struct inode *inode, struct list_head *dispose)\n{\n\tstruct file_lock_context *ctx = inode->i_flctx;\n\tstruct file_lock *fl, *tmp;\n\n\tlockdep_assert_held(&ctx->flc_lock);\n\n\tlist_for_each_entry_safe(fl, tmp, &ctx->flc_lease, fl_list) {\n\t\ttrace_time_out_leases(inode, fl);\n\t\tif (past_time(fl->fl_downgrade_time))\n\t\t\tlease_modify(fl, F_RDLCK, dispose);\n\t\tif (past_time(fl->fl_break_time))\n\t\t\tlease_modify(fl, F_UNLCK, dispose);\n\t}\n}\n\nstatic bool leases_conflict(struct file_lock *lease, struct file_lock *breaker)\n{\n\tbool rc;\n\n\tif (lease->fl_lmops->lm_breaker_owns_lease\n\t\t\t&& lease->fl_lmops->lm_breaker_owns_lease(lease))\n\t\treturn false;\n\tif ((breaker->fl_flags & FL_LAYOUT) != (lease->fl_flags & FL_LAYOUT)) {\n\t\trc = false;\n\t\tgoto trace;\n\t}\n\tif ((breaker->fl_flags & FL_DELEG) && (lease->fl_flags & FL_LEASE)) {\n\t\trc = false;\n\t\tgoto trace;\n\t}\n\n\trc = locks_conflict(breaker, lease);\ntrace:\n\ttrace_leases_conflict(rc, lease, breaker);\n\treturn rc;\n}\n\nstatic bool\nany_leases_conflict(struct inode *inode, struct file_lock *breaker)\n{\n\tstruct file_lock_context *ctx = inode->i_flctx;\n\tstruct file_lock *fl;\n\n\tlockdep_assert_held(&ctx->flc_lock);\n\n\tlist_for_each_entry(fl, &ctx->flc_lease, fl_list) {\n\t\tif (leases_conflict(fl, breaker))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nint __break_lease(struct inode *inode, unsigned int mode, unsigned int type)\n{\n\tint error = 0;\n\tstruct file_lock_context *ctx;\n\tstruct file_lock *new_fl, *fl, *tmp;\n\tunsigned long break_time;\n\tint want_write = (mode & O_ACCMODE) != O_RDONLY;\n\tLIST_HEAD(dispose);\n\n\tnew_fl = lease_alloc(NULL, want_write ? F_WRLCK : F_RDLCK);\n\tif (IS_ERR(new_fl))\n\t\treturn PTR_ERR(new_fl);\n\tnew_fl->fl_flags = type;\n\n\t \n\tctx = locks_inode_context(inode);\n\tif (!ctx) {\n\t\tWARN_ON_ONCE(1);\n\t\tgoto free_lock;\n\t}\n\n\tpercpu_down_read(&file_rwsem);\n\tspin_lock(&ctx->flc_lock);\n\n\ttime_out_leases(inode, &dispose);\n\n\tif (!any_leases_conflict(inode, new_fl))\n\t\tgoto out;\n\n\tbreak_time = 0;\n\tif (lease_break_time > 0) {\n\t\tbreak_time = jiffies + lease_break_time * HZ;\n\t\tif (break_time == 0)\n\t\t\tbreak_time++;\t \n\t}\n\n\tlist_for_each_entry_safe(fl, tmp, &ctx->flc_lease, fl_list) {\n\t\tif (!leases_conflict(fl, new_fl))\n\t\t\tcontinue;\n\t\tif (want_write) {\n\t\t\tif (fl->fl_flags & FL_UNLOCK_PENDING)\n\t\t\t\tcontinue;\n\t\t\tfl->fl_flags |= FL_UNLOCK_PENDING;\n\t\t\tfl->fl_break_time = break_time;\n\t\t} else {\n\t\t\tif (lease_breaking(fl))\n\t\t\t\tcontinue;\n\t\t\tfl->fl_flags |= FL_DOWNGRADE_PENDING;\n\t\t\tfl->fl_downgrade_time = break_time;\n\t\t}\n\t\tif (fl->fl_lmops->lm_break(fl))\n\t\t\tlocks_delete_lock_ctx(fl, &dispose);\n\t}\n\n\tif (list_empty(&ctx->flc_lease))\n\t\tgoto out;\n\n\tif (mode & O_NONBLOCK) {\n\t\ttrace_break_lease_noblock(inode, new_fl);\n\t\terror = -EWOULDBLOCK;\n\t\tgoto out;\n\t}\n\nrestart:\n\tfl = list_first_entry(&ctx->flc_lease, struct file_lock, fl_list);\n\tbreak_time = fl->fl_break_time;\n\tif (break_time != 0)\n\t\tbreak_time -= jiffies;\n\tif (break_time == 0)\n\t\tbreak_time++;\n\tlocks_insert_block(fl, new_fl, leases_conflict);\n\ttrace_break_lease_block(inode, new_fl);\n\tspin_unlock(&ctx->flc_lock);\n\tpercpu_up_read(&file_rwsem);\n\n\tlocks_dispose_list(&dispose);\n\terror = wait_event_interruptible_timeout(new_fl->fl_wait,\n\t\t\t\t\tlist_empty(&new_fl->fl_blocked_member),\n\t\t\t\t\tbreak_time);\n\n\tpercpu_down_read(&file_rwsem);\n\tspin_lock(&ctx->flc_lock);\n\ttrace_break_lease_unblock(inode, new_fl);\n\tlocks_delete_block(new_fl);\n\tif (error >= 0) {\n\t\t \n\t\tif (error == 0)\n\t\t\ttime_out_leases(inode, &dispose);\n\t\tif (any_leases_conflict(inode, new_fl))\n\t\t\tgoto restart;\n\t\terror = 0;\n\t}\nout:\n\tspin_unlock(&ctx->flc_lock);\n\tpercpu_up_read(&file_rwsem);\n\tlocks_dispose_list(&dispose);\nfree_lock:\n\tlocks_free_lock(new_fl);\n\treturn error;\n}\nEXPORT_SYMBOL(__break_lease);\n\n \nvoid lease_get_mtime(struct inode *inode, struct timespec64 *time)\n{\n\tbool has_lease = false;\n\tstruct file_lock_context *ctx;\n\tstruct file_lock *fl;\n\n\tctx = locks_inode_context(inode);\n\tif (ctx && !list_empty_careful(&ctx->flc_lease)) {\n\t\tspin_lock(&ctx->flc_lock);\n\t\tfl = list_first_entry_or_null(&ctx->flc_lease,\n\t\t\t\t\t      struct file_lock, fl_list);\n\t\tif (fl && (fl->fl_type == F_WRLCK))\n\t\t\thas_lease = true;\n\t\tspin_unlock(&ctx->flc_lock);\n\t}\n\n\tif (has_lease)\n\t\t*time = current_time(inode);\n}\nEXPORT_SYMBOL(lease_get_mtime);\n\n \nint fcntl_getlease(struct file *filp)\n{\n\tstruct file_lock *fl;\n\tstruct inode *inode = file_inode(filp);\n\tstruct file_lock_context *ctx;\n\tint type = F_UNLCK;\n\tLIST_HEAD(dispose);\n\n\tctx = locks_inode_context(inode);\n\tif (ctx && !list_empty_careful(&ctx->flc_lease)) {\n\t\tpercpu_down_read(&file_rwsem);\n\t\tspin_lock(&ctx->flc_lock);\n\t\ttime_out_leases(inode, &dispose);\n\t\tlist_for_each_entry(fl, &ctx->flc_lease, fl_list) {\n\t\t\tif (fl->fl_file != filp)\n\t\t\t\tcontinue;\n\t\t\ttype = target_leasetype(fl);\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&ctx->flc_lock);\n\t\tpercpu_up_read(&file_rwsem);\n\n\t\tlocks_dispose_list(&dispose);\n\t}\n\treturn type;\n}\n\n \nstatic int\ncheck_conflicting_open(struct file *filp, const int arg, int flags)\n{\n\tstruct inode *inode = file_inode(filp);\n\tint self_wcount = 0, self_rcount = 0;\n\n\tif (flags & FL_LAYOUT)\n\t\treturn 0;\n\tif (flags & FL_DELEG)\n\t\t \n\t\treturn 0;\n\n\tif (arg == F_RDLCK)\n\t\treturn inode_is_open_for_write(inode) ? -EAGAIN : 0;\n\telse if (arg != F_WRLCK)\n\t\treturn 0;\n\n\t \n\tif (filp->f_mode & FMODE_WRITE)\n\t\tself_wcount = 1;\n\telse if (filp->f_mode & FMODE_READ)\n\t\tself_rcount = 1;\n\n\tif (atomic_read(&inode->i_writecount) != self_wcount ||\n\t    atomic_read(&inode->i_readcount) != self_rcount)\n\t\treturn -EAGAIN;\n\n\treturn 0;\n}\n\nstatic int\ngeneric_add_lease(struct file *filp, int arg, struct file_lock **flp, void **priv)\n{\n\tstruct file_lock *fl, *my_fl = NULL, *lease;\n\tstruct inode *inode = file_inode(filp);\n\tstruct file_lock_context *ctx;\n\tbool is_deleg = (*flp)->fl_flags & FL_DELEG;\n\tint error;\n\tLIST_HEAD(dispose);\n\n\tlease = *flp;\n\ttrace_generic_add_lease(inode, lease);\n\n\t \n\tctx = locks_get_lock_context(inode, arg);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\t \n\tif (is_deleg && !inode_trylock(inode))\n\t\treturn -EAGAIN;\n\n\tpercpu_down_read(&file_rwsem);\n\tspin_lock(&ctx->flc_lock);\n\ttime_out_leases(inode, &dispose);\n\terror = check_conflicting_open(filp, arg, lease->fl_flags);\n\tif (error)\n\t\tgoto out;\n\n\t \n\terror = -EAGAIN;\n\tlist_for_each_entry(fl, &ctx->flc_lease, fl_list) {\n\t\tif (fl->fl_file == filp &&\n\t\t    fl->fl_owner == lease->fl_owner) {\n\t\t\tmy_fl = fl;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (arg == F_WRLCK)\n\t\t\tgoto out;\n\t\t \n\t\tif (fl->fl_flags & FL_UNLOCK_PENDING)\n\t\t\tgoto out;\n\t}\n\n\tif (my_fl != NULL) {\n\t\tlease = my_fl;\n\t\terror = lease->fl_lmops->lm_change(lease, arg, &dispose);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tgoto out_setup;\n\t}\n\n\terror = -EINVAL;\n\tif (!leases_enable)\n\t\tgoto out;\n\n\tlocks_insert_lock_ctx(lease, &ctx->flc_lease);\n\t \n\tsmp_mb();\n\terror = check_conflicting_open(filp, arg, lease->fl_flags);\n\tif (error) {\n\t\tlocks_unlink_lock_ctx(lease);\n\t\tgoto out;\n\t}\n\nout_setup:\n\tif (lease->fl_lmops->lm_setup)\n\t\tlease->fl_lmops->lm_setup(lease, priv);\nout:\n\tspin_unlock(&ctx->flc_lock);\n\tpercpu_up_read(&file_rwsem);\n\tlocks_dispose_list(&dispose);\n\tif (is_deleg)\n\t\tinode_unlock(inode);\n\tif (!error && !my_fl)\n\t\t*flp = NULL;\n\treturn error;\n}\n\nstatic int generic_delete_lease(struct file *filp, void *owner)\n{\n\tint error = -EAGAIN;\n\tstruct file_lock *fl, *victim = NULL;\n\tstruct inode *inode = file_inode(filp);\n\tstruct file_lock_context *ctx;\n\tLIST_HEAD(dispose);\n\n\tctx = locks_inode_context(inode);\n\tif (!ctx) {\n\t\ttrace_generic_delete_lease(inode, NULL);\n\t\treturn error;\n\t}\n\n\tpercpu_down_read(&file_rwsem);\n\tspin_lock(&ctx->flc_lock);\n\tlist_for_each_entry(fl, &ctx->flc_lease, fl_list) {\n\t\tif (fl->fl_file == filp &&\n\t\t    fl->fl_owner == owner) {\n\t\t\tvictim = fl;\n\t\t\tbreak;\n\t\t}\n\t}\n\ttrace_generic_delete_lease(inode, victim);\n\tif (victim)\n\t\terror = fl->fl_lmops->lm_change(victim, F_UNLCK, &dispose);\n\tspin_unlock(&ctx->flc_lock);\n\tpercpu_up_read(&file_rwsem);\n\tlocks_dispose_list(&dispose);\n\treturn error;\n}\n\n \nint generic_setlease(struct file *filp, int arg, struct file_lock **flp,\n\t\t\tvoid **priv)\n{\n\tstruct inode *inode = file_inode(filp);\n\tvfsuid_t vfsuid = i_uid_into_vfsuid(file_mnt_idmap(filp), inode);\n\tint error;\n\n\tif ((!vfsuid_eq_kuid(vfsuid, current_fsuid())) && !capable(CAP_LEASE))\n\t\treturn -EACCES;\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\terror = security_file_lock(filp, arg);\n\tif (error)\n\t\treturn error;\n\n\tswitch (arg) {\n\tcase F_UNLCK:\n\t\treturn generic_delete_lease(filp, *priv);\n\tcase F_RDLCK:\n\tcase F_WRLCK:\n\t\tif (!(*flp)->fl_lmops->lm_break) {\n\t\t\tWARN_ON_ONCE(1);\n\t\t\treturn -ENOLCK;\n\t\t}\n\n\t\treturn generic_add_lease(filp, arg, flp, priv);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\nEXPORT_SYMBOL(generic_setlease);\n\n \nstatic struct srcu_notifier_head lease_notifier_chain;\n\nstatic inline void\nlease_notifier_chain_init(void)\n{\n\tsrcu_init_notifier_head(&lease_notifier_chain);\n}\n\nstatic inline void\nsetlease_notifier(int arg, struct file_lock *lease)\n{\n\tif (arg != F_UNLCK)\n\t\tsrcu_notifier_call_chain(&lease_notifier_chain, arg, lease);\n}\n\nint lease_register_notifier(struct notifier_block *nb)\n{\n\treturn srcu_notifier_chain_register(&lease_notifier_chain, nb);\n}\nEXPORT_SYMBOL_GPL(lease_register_notifier);\n\nvoid lease_unregister_notifier(struct notifier_block *nb)\n{\n\tsrcu_notifier_chain_unregister(&lease_notifier_chain, nb);\n}\nEXPORT_SYMBOL_GPL(lease_unregister_notifier);\n\n \nint\nvfs_setlease(struct file *filp, int arg, struct file_lock **lease, void **priv)\n{\n\tif (lease)\n\t\tsetlease_notifier(arg, *lease);\n\tif (filp->f_op->setlease)\n\t\treturn filp->f_op->setlease(filp, arg, lease, priv);\n\telse\n\t\treturn generic_setlease(filp, arg, lease, priv);\n}\nEXPORT_SYMBOL_GPL(vfs_setlease);\n\nstatic int do_fcntl_add_lease(unsigned int fd, struct file *filp, int arg)\n{\n\tstruct file_lock *fl;\n\tstruct fasync_struct *new;\n\tint error;\n\n\tfl = lease_alloc(filp, arg);\n\tif (IS_ERR(fl))\n\t\treturn PTR_ERR(fl);\n\n\tnew = fasync_alloc();\n\tif (!new) {\n\t\tlocks_free_lock(fl);\n\t\treturn -ENOMEM;\n\t}\n\tnew->fa_fd = fd;\n\n\terror = vfs_setlease(filp, arg, &fl, (void **)&new);\n\tif (fl)\n\t\tlocks_free_lock(fl);\n\tif (new)\n\t\tfasync_free(new);\n\treturn error;\n}\n\n \nint fcntl_setlease(unsigned int fd, struct file *filp, int arg)\n{\n\tif (arg == F_UNLCK)\n\t\treturn vfs_setlease(filp, F_UNLCK, NULL, (void **)&filp);\n\treturn do_fcntl_add_lease(fd, filp, arg);\n}\n\n \nstatic int flock_lock_inode_wait(struct inode *inode, struct file_lock *fl)\n{\n\tint error;\n\tmight_sleep();\n\tfor (;;) {\n\t\terror = flock_lock_inode(inode, fl);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait,\n\t\t\t\tlist_empty(&fl->fl_blocked_member));\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\tlocks_delete_block(fl);\n\treturn error;\n}\n\n \nint locks_lock_inode_wait(struct inode *inode, struct file_lock *fl)\n{\n\tint res = 0;\n\tswitch (fl->fl_flags & (FL_POSIX|FL_FLOCK)) {\n\t\tcase FL_POSIX:\n\t\t\tres = posix_lock_inode_wait(inode, fl);\n\t\t\tbreak;\n\t\tcase FL_FLOCK:\n\t\t\tres = flock_lock_inode_wait(inode, fl);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t}\n\treturn res;\n}\nEXPORT_SYMBOL(locks_lock_inode_wait);\n\n \nSYSCALL_DEFINE2(flock, unsigned int, fd, unsigned int, cmd)\n{\n\tint can_sleep, error, type;\n\tstruct file_lock fl;\n\tstruct fd f;\n\n\t \n\tif (cmd & LOCK_MAND) {\n\t\tpr_warn_once(\"%s(%d): Attempt to set a LOCK_MAND lock via flock(2). This support has been removed and the request ignored.\\n\", current->comm, current->pid);\n\t\treturn 0;\n\t}\n\n\ttype = flock_translate_cmd(cmd & ~LOCK_NB);\n\tif (type < 0)\n\t\treturn type;\n\n\terror = -EBADF;\n\tf = fdget(fd);\n\tif (!f.file)\n\t\treturn error;\n\n\tif (type != F_UNLCK && !(f.file->f_mode & (FMODE_READ | FMODE_WRITE)))\n\t\tgoto out_putf;\n\n\tflock_make_lock(f.file, &fl, type);\n\n\terror = security_file_lock(f.file, fl.fl_type);\n\tif (error)\n\t\tgoto out_putf;\n\n\tcan_sleep = !(cmd & LOCK_NB);\n\tif (can_sleep)\n\t\tfl.fl_flags |= FL_SLEEP;\n\n\tif (f.file->f_op->flock)\n\t\terror = f.file->f_op->flock(f.file,\n\t\t\t\t\t    (can_sleep) ? F_SETLKW : F_SETLK,\n\t\t\t\t\t    &fl);\n\telse\n\t\terror = locks_lock_file_wait(f.file, &fl);\n\n\tlocks_release_private(&fl);\n out_putf:\n\tfdput(f);\n\n\treturn error;\n}\n\n \nint vfs_test_lock(struct file *filp, struct file_lock *fl)\n{\n\tWARN_ON_ONCE(filp != fl->fl_file);\n\tif (filp->f_op->lock)\n\t\treturn filp->f_op->lock(filp, F_GETLK, fl);\n\tposix_test_lock(filp, fl);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(vfs_test_lock);\n\n \nstatic pid_t locks_translate_pid(struct file_lock *fl, struct pid_namespace *ns)\n{\n\tpid_t vnr;\n\tstruct pid *pid;\n\n\tif (IS_OFDLCK(fl))\n\t\treturn -1;\n\tif (IS_REMOTELCK(fl))\n\t\treturn fl->fl_pid;\n\t \n\tif (ns == &init_pid_ns)\n\t\treturn (pid_t)fl->fl_pid;\n\n\trcu_read_lock();\n\tpid = find_pid_ns(fl->fl_pid, &init_pid_ns);\n\tvnr = pid_nr_ns(pid, ns);\n\trcu_read_unlock();\n\treturn vnr;\n}\n\nstatic int posix_lock_to_flock(struct flock *flock, struct file_lock *fl)\n{\n\tflock->l_pid = locks_translate_pid(fl, task_active_pid_ns(current));\n#if BITS_PER_LONG == 32\n\t \n\tif (fl->fl_start > OFFT_OFFSET_MAX)\n\t\treturn -EOVERFLOW;\n\tif (fl->fl_end != OFFSET_MAX && fl->fl_end > OFFT_OFFSET_MAX)\n\t\treturn -EOVERFLOW;\n#endif\n\tflock->l_start = fl->fl_start;\n\tflock->l_len = fl->fl_end == OFFSET_MAX ? 0 :\n\t\tfl->fl_end - fl->fl_start + 1;\n\tflock->l_whence = 0;\n\tflock->l_type = fl->fl_type;\n\treturn 0;\n}\n\n#if BITS_PER_LONG == 32\nstatic void posix_lock_to_flock64(struct flock64 *flock, struct file_lock *fl)\n{\n\tflock->l_pid = locks_translate_pid(fl, task_active_pid_ns(current));\n\tflock->l_start = fl->fl_start;\n\tflock->l_len = fl->fl_end == OFFSET_MAX ? 0 :\n\t\tfl->fl_end - fl->fl_start + 1;\n\tflock->l_whence = 0;\n\tflock->l_type = fl->fl_type;\n}\n#endif\n\n \nint fcntl_getlk(struct file *filp, unsigned int cmd, struct flock *flock)\n{\n\tstruct file_lock *fl;\n\tint error;\n\n\tfl = locks_alloc_lock();\n\tif (fl == NULL)\n\t\treturn -ENOMEM;\n\terror = -EINVAL;\n\tif (cmd != F_OFD_GETLK && flock->l_type != F_RDLCK\n\t\t\t&& flock->l_type != F_WRLCK)\n\t\tgoto out;\n\n\terror = flock_to_posix_lock(filp, fl, flock);\n\tif (error)\n\t\tgoto out;\n\n\tif (cmd == F_OFD_GETLK) {\n\t\terror = -EINVAL;\n\t\tif (flock->l_pid != 0)\n\t\t\tgoto out;\n\n\t\tfl->fl_flags |= FL_OFDLCK;\n\t\tfl->fl_owner = filp;\n\t}\n\n\terror = vfs_test_lock(filp, fl);\n\tif (error)\n\t\tgoto out;\n\n\tflock->l_type = fl->fl_type;\n\tif (fl->fl_type != F_UNLCK) {\n\t\terror = posix_lock_to_flock(flock, fl);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\nout:\n\tlocks_free_lock(fl);\n\treturn error;\n}\n\n \nint vfs_lock_file(struct file *filp, unsigned int cmd, struct file_lock *fl, struct file_lock *conf)\n{\n\tWARN_ON_ONCE(filp != fl->fl_file);\n\tif (filp->f_op->lock)\n\t\treturn filp->f_op->lock(filp, cmd, fl);\n\telse\n\t\treturn posix_lock_file(filp, fl, conf);\n}\nEXPORT_SYMBOL_GPL(vfs_lock_file);\n\nstatic int do_lock_file_wait(struct file *filp, unsigned int cmd,\n\t\t\t     struct file_lock *fl)\n{\n\tint error;\n\n\terror = security_file_lock(filp, fl->fl_type);\n\tif (error)\n\t\treturn error;\n\n\tfor (;;) {\n\t\terror = vfs_lock_file(filp, cmd, fl, NULL);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait,\n\t\t\t\t\tlist_empty(&fl->fl_blocked_member));\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\tlocks_delete_block(fl);\n\n\treturn error;\n}\n\n \nstatic int\ncheck_fmode_for_setlk(struct file_lock *fl)\n{\n\tswitch (fl->fl_type) {\n\tcase F_RDLCK:\n\t\tif (!(fl->fl_file->f_mode & FMODE_READ))\n\t\t\treturn -EBADF;\n\t\tbreak;\n\tcase F_WRLCK:\n\t\tif (!(fl->fl_file->f_mode & FMODE_WRITE))\n\t\t\treturn -EBADF;\n\t}\n\treturn 0;\n}\n\n \nint fcntl_setlk(unsigned int fd, struct file *filp, unsigned int cmd,\n\t\tstruct flock *flock)\n{\n\tstruct file_lock *file_lock = locks_alloc_lock();\n\tstruct inode *inode = file_inode(filp);\n\tstruct file *f;\n\tint error;\n\n\tif (file_lock == NULL)\n\t\treturn -ENOLCK;\n\n\terror = flock_to_posix_lock(filp, file_lock, flock);\n\tif (error)\n\t\tgoto out;\n\n\terror = check_fmode_for_setlk(file_lock);\n\tif (error)\n\t\tgoto out;\n\n\t \n\tswitch (cmd) {\n\tcase F_OFD_SETLK:\n\t\terror = -EINVAL;\n\t\tif (flock->l_pid != 0)\n\t\t\tgoto out;\n\n\t\tcmd = F_SETLK;\n\t\tfile_lock->fl_flags |= FL_OFDLCK;\n\t\tfile_lock->fl_owner = filp;\n\t\tbreak;\n\tcase F_OFD_SETLKW:\n\t\terror = -EINVAL;\n\t\tif (flock->l_pid != 0)\n\t\t\tgoto out;\n\n\t\tcmd = F_SETLKW;\n\t\tfile_lock->fl_flags |= FL_OFDLCK;\n\t\tfile_lock->fl_owner = filp;\n\t\tfallthrough;\n\tcase F_SETLKW:\n\t\tfile_lock->fl_flags |= FL_SLEEP;\n\t}\n\n\terror = do_lock_file_wait(filp, cmd, file_lock);\n\n\t \n\tif (!error && file_lock->fl_type != F_UNLCK &&\n\t    !(file_lock->fl_flags & FL_OFDLCK)) {\n\t\tstruct files_struct *files = current->files;\n\t\t \n\t\tspin_lock(&files->file_lock);\n\t\tf = files_lookup_fd_locked(files, fd);\n\t\tspin_unlock(&files->file_lock);\n\t\tif (f != filp) {\n\t\t\tfile_lock->fl_type = F_UNLCK;\n\t\t\terror = do_lock_file_wait(filp, cmd, file_lock);\n\t\t\tWARN_ON_ONCE(error);\n\t\t\terror = -EBADF;\n\t\t}\n\t}\nout:\n\ttrace_fcntl_setlk(inode, file_lock, error);\n\tlocks_free_lock(file_lock);\n\treturn error;\n}\n\n#if BITS_PER_LONG == 32\n \nint fcntl_getlk64(struct file *filp, unsigned int cmd, struct flock64 *flock)\n{\n\tstruct file_lock *fl;\n\tint error;\n\n\tfl = locks_alloc_lock();\n\tif (fl == NULL)\n\t\treturn -ENOMEM;\n\n\terror = -EINVAL;\n\tif (cmd != F_OFD_GETLK && flock->l_type != F_RDLCK\n\t\t\t&& flock->l_type != F_WRLCK)\n\t\tgoto out;\n\n\terror = flock64_to_posix_lock(filp, fl, flock);\n\tif (error)\n\t\tgoto out;\n\n\tif (cmd == F_OFD_GETLK) {\n\t\terror = -EINVAL;\n\t\tif (flock->l_pid != 0)\n\t\t\tgoto out;\n\n\t\tfl->fl_flags |= FL_OFDLCK;\n\t\tfl->fl_owner = filp;\n\t}\n\n\terror = vfs_test_lock(filp, fl);\n\tif (error)\n\t\tgoto out;\n\n\tflock->l_type = fl->fl_type;\n\tif (fl->fl_type != F_UNLCK)\n\t\tposix_lock_to_flock64(flock, fl);\n\nout:\n\tlocks_free_lock(fl);\n\treturn error;\n}\n\n \nint fcntl_setlk64(unsigned int fd, struct file *filp, unsigned int cmd,\n\t\tstruct flock64 *flock)\n{\n\tstruct file_lock *file_lock = locks_alloc_lock();\n\tstruct file *f;\n\tint error;\n\n\tif (file_lock == NULL)\n\t\treturn -ENOLCK;\n\n\terror = flock64_to_posix_lock(filp, file_lock, flock);\n\tif (error)\n\t\tgoto out;\n\n\terror = check_fmode_for_setlk(file_lock);\n\tif (error)\n\t\tgoto out;\n\n\t \n\tswitch (cmd) {\n\tcase F_OFD_SETLK:\n\t\terror = -EINVAL;\n\t\tif (flock->l_pid != 0)\n\t\t\tgoto out;\n\n\t\tcmd = F_SETLK64;\n\t\tfile_lock->fl_flags |= FL_OFDLCK;\n\t\tfile_lock->fl_owner = filp;\n\t\tbreak;\n\tcase F_OFD_SETLKW:\n\t\terror = -EINVAL;\n\t\tif (flock->l_pid != 0)\n\t\t\tgoto out;\n\n\t\tcmd = F_SETLKW64;\n\t\tfile_lock->fl_flags |= FL_OFDLCK;\n\t\tfile_lock->fl_owner = filp;\n\t\tfallthrough;\n\tcase F_SETLKW64:\n\t\tfile_lock->fl_flags |= FL_SLEEP;\n\t}\n\n\terror = do_lock_file_wait(filp, cmd, file_lock);\n\n\t \n\tif (!error && file_lock->fl_type != F_UNLCK &&\n\t    !(file_lock->fl_flags & FL_OFDLCK)) {\n\t\tstruct files_struct *files = current->files;\n\t\t \n\t\tspin_lock(&files->file_lock);\n\t\tf = files_lookup_fd_locked(files, fd);\n\t\tspin_unlock(&files->file_lock);\n\t\tif (f != filp) {\n\t\t\tfile_lock->fl_type = F_UNLCK;\n\t\t\terror = do_lock_file_wait(filp, cmd, file_lock);\n\t\t\tWARN_ON_ONCE(error);\n\t\t\terror = -EBADF;\n\t\t}\n\t}\nout:\n\tlocks_free_lock(file_lock);\n\treturn error;\n}\n#endif  \n\n \nvoid locks_remove_posix(struct file *filp, fl_owner_t owner)\n{\n\tint error;\n\tstruct inode *inode = file_inode(filp);\n\tstruct file_lock lock;\n\tstruct file_lock_context *ctx;\n\n\t \n\tctx = locks_inode_context(inode);\n\tif (!ctx || list_empty(&ctx->flc_posix))\n\t\treturn;\n\n\tlocks_init_lock(&lock);\n\tlock.fl_type = F_UNLCK;\n\tlock.fl_flags = FL_POSIX | FL_CLOSE;\n\tlock.fl_start = 0;\n\tlock.fl_end = OFFSET_MAX;\n\tlock.fl_owner = owner;\n\tlock.fl_pid = current->tgid;\n\tlock.fl_file = filp;\n\tlock.fl_ops = NULL;\n\tlock.fl_lmops = NULL;\n\n\terror = vfs_lock_file(filp, F_SETLK, &lock, NULL);\n\n\tif (lock.fl_ops && lock.fl_ops->fl_release_private)\n\t\tlock.fl_ops->fl_release_private(&lock);\n\ttrace_locks_remove_posix(inode, &lock, error);\n}\nEXPORT_SYMBOL(locks_remove_posix);\n\n \nstatic void\nlocks_remove_flock(struct file *filp, struct file_lock_context *flctx)\n{\n\tstruct file_lock fl;\n\tstruct inode *inode = file_inode(filp);\n\n\tif (list_empty(&flctx->flc_flock))\n\t\treturn;\n\n\tflock_make_lock(filp, &fl, F_UNLCK);\n\tfl.fl_flags |= FL_CLOSE;\n\n\tif (filp->f_op->flock)\n\t\tfilp->f_op->flock(filp, F_SETLKW, &fl);\n\telse\n\t\tflock_lock_inode(inode, &fl);\n\n\tif (fl.fl_ops && fl.fl_ops->fl_release_private)\n\t\tfl.fl_ops->fl_release_private(&fl);\n}\n\n \nstatic void\nlocks_remove_lease(struct file *filp, struct file_lock_context *ctx)\n{\n\tstruct file_lock *fl, *tmp;\n\tLIST_HEAD(dispose);\n\n\tif (list_empty(&ctx->flc_lease))\n\t\treturn;\n\n\tpercpu_down_read(&file_rwsem);\n\tspin_lock(&ctx->flc_lock);\n\tlist_for_each_entry_safe(fl, tmp, &ctx->flc_lease, fl_list)\n\t\tif (filp == fl->fl_file)\n\t\t\tlease_modify(fl, F_UNLCK, &dispose);\n\tspin_unlock(&ctx->flc_lock);\n\tpercpu_up_read(&file_rwsem);\n\n\tlocks_dispose_list(&dispose);\n}\n\n \nvoid locks_remove_file(struct file *filp)\n{\n\tstruct file_lock_context *ctx;\n\n\tctx = locks_inode_context(file_inode(filp));\n\tif (!ctx)\n\t\treturn;\n\n\t \n\tlocks_remove_posix(filp, filp);\n\n\t \n\tlocks_remove_flock(filp, ctx);\n\n\t \n\tlocks_remove_lease(filp, ctx);\n\n\tspin_lock(&ctx->flc_lock);\n\tlocks_check_ctx_file_list(filp, &ctx->flc_posix, \"POSIX\");\n\tlocks_check_ctx_file_list(filp, &ctx->flc_flock, \"FLOCK\");\n\tlocks_check_ctx_file_list(filp, &ctx->flc_lease, \"LEASE\");\n\tspin_unlock(&ctx->flc_lock);\n}\n\n \nint vfs_cancel_lock(struct file *filp, struct file_lock *fl)\n{\n\tWARN_ON_ONCE(filp != fl->fl_file);\n\tif (filp->f_op->lock)\n\t\treturn filp->f_op->lock(filp, F_CANCELLK, fl);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(vfs_cancel_lock);\n\n \nbool vfs_inode_has_locks(struct inode *inode)\n{\n\tstruct file_lock_context *ctx;\n\tbool ret;\n\n\tctx = locks_inode_context(inode);\n\tif (!ctx)\n\t\treturn false;\n\n\tspin_lock(&ctx->flc_lock);\n\tret = !list_empty(&ctx->flc_posix) || !list_empty(&ctx->flc_flock);\n\tspin_unlock(&ctx->flc_lock);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(vfs_inode_has_locks);\n\n#ifdef CONFIG_PROC_FS\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n\nstruct locks_iterator {\n\tint\tli_cpu;\n\tloff_t\tli_pos;\n};\n\nstatic void lock_get_status(struct seq_file *f, struct file_lock *fl,\n\t\t\t    loff_t id, char *pfx, int repeat)\n{\n\tstruct inode *inode = NULL;\n\tunsigned int fl_pid;\n\tstruct pid_namespace *proc_pidns = proc_pid_ns(file_inode(f->file)->i_sb);\n\tint type;\n\n\tfl_pid = locks_translate_pid(fl, proc_pidns);\n\t \n\n\tif (fl->fl_file != NULL)\n\t\tinode = file_inode(fl->fl_file);\n\n\tseq_printf(f, \"%lld: \", id);\n\n\tif (repeat)\n\t\tseq_printf(f, \"%*s\", repeat - 1 + (int)strlen(pfx), pfx);\n\n\tif (IS_POSIX(fl)) {\n\t\tif (fl->fl_flags & FL_ACCESS)\n\t\t\tseq_puts(f, \"ACCESS\");\n\t\telse if (IS_OFDLCK(fl))\n\t\t\tseq_puts(f, \"OFDLCK\");\n\t\telse\n\t\t\tseq_puts(f, \"POSIX \");\n\n\t\tseq_printf(f, \" %s \",\n\t\t\t     (inode == NULL) ? \"*NOINODE*\" : \"ADVISORY \");\n\t} else if (IS_FLOCK(fl)) {\n\t\tseq_puts(f, \"FLOCK  ADVISORY  \");\n\t} else if (IS_LEASE(fl)) {\n\t\tif (fl->fl_flags & FL_DELEG)\n\t\t\tseq_puts(f, \"DELEG  \");\n\t\telse\n\t\t\tseq_puts(f, \"LEASE  \");\n\n\t\tif (lease_breaking(fl))\n\t\t\tseq_puts(f, \"BREAKING  \");\n\t\telse if (fl->fl_file)\n\t\t\tseq_puts(f, \"ACTIVE    \");\n\t\telse\n\t\t\tseq_puts(f, \"BREAKER   \");\n\t} else {\n\t\tseq_puts(f, \"UNKNOWN UNKNOWN  \");\n\t}\n\ttype = IS_LEASE(fl) ? target_leasetype(fl) : fl->fl_type;\n\n\tseq_printf(f, \"%s \", (type == F_WRLCK) ? \"WRITE\" :\n\t\t\t     (type == F_RDLCK) ? \"READ\" : \"UNLCK\");\n\tif (inode) {\n\t\t \n\t\tseq_printf(f, \"%d %02x:%02x:%lu \", fl_pid,\n\t\t\t\tMAJOR(inode->i_sb->s_dev),\n\t\t\t\tMINOR(inode->i_sb->s_dev), inode->i_ino);\n\t} else {\n\t\tseq_printf(f, \"%d <none>:0 \", fl_pid);\n\t}\n\tif (IS_POSIX(fl)) {\n\t\tif (fl->fl_end == OFFSET_MAX)\n\t\t\tseq_printf(f, \"%Ld EOF\\n\", fl->fl_start);\n\t\telse\n\t\t\tseq_printf(f, \"%Ld %Ld\\n\", fl->fl_start, fl->fl_end);\n\t} else {\n\t\tseq_puts(f, \"0 EOF\\n\");\n\t}\n}\n\nstatic struct file_lock *get_next_blocked_member(struct file_lock *node)\n{\n\tstruct file_lock *tmp;\n\n\t \n\tif (node == NULL || node->fl_blocker == NULL)\n\t\treturn NULL;\n\n\t \n\ttmp = list_next_entry(node, fl_blocked_member);\n\tif (list_entry_is_head(tmp, &node->fl_blocker->fl_blocked_requests, fl_blocked_member)\n\t\t|| tmp == node) {\n\t\treturn NULL;\n\t}\n\n\treturn tmp;\n}\n\nstatic int locks_show(struct seq_file *f, void *v)\n{\n\tstruct locks_iterator *iter = f->private;\n\tstruct file_lock *cur, *tmp;\n\tstruct pid_namespace *proc_pidns = proc_pid_ns(file_inode(f->file)->i_sb);\n\tint level = 0;\n\n\tcur = hlist_entry(v, struct file_lock, fl_link);\n\n\tif (locks_translate_pid(cur, proc_pidns) == 0)\n\t\treturn 0;\n\n\t \n\twhile (cur != NULL) {\n\t\tif (level)\n\t\t\tlock_get_status(f, cur, iter->li_pos, \"-> \", level);\n\t\telse\n\t\t\tlock_get_status(f, cur, iter->li_pos, \"\", level);\n\n\t\tif (!list_empty(&cur->fl_blocked_requests)) {\n\t\t\t \n\t\t\tcur = list_first_entry_or_null(&cur->fl_blocked_requests,\n\t\t\t\tstruct file_lock, fl_blocked_member);\n\t\t\tlevel++;\n\t\t} else {\n\t\t\t \n\t\t\ttmp = get_next_blocked_member(cur);\n\t\t\t \n\t\t\twhile (tmp == NULL && cur->fl_blocker != NULL) {\n\t\t\t\tcur = cur->fl_blocker;\n\t\t\t\tlevel--;\n\t\t\t\ttmp = get_next_blocked_member(cur);\n\t\t\t}\n\t\t\tcur = tmp;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void __show_fd_locks(struct seq_file *f,\n\t\t\tstruct list_head *head, int *id,\n\t\t\tstruct file *filp, struct files_struct *files)\n{\n\tstruct file_lock *fl;\n\n\tlist_for_each_entry(fl, head, fl_list) {\n\n\t\tif (filp != fl->fl_file)\n\t\t\tcontinue;\n\t\tif (fl->fl_owner != files &&\n\t\t    fl->fl_owner != filp)\n\t\t\tcontinue;\n\n\t\t(*id)++;\n\t\tseq_puts(f, \"lock:\\t\");\n\t\tlock_get_status(f, fl, *id, \"\", 0);\n\t}\n}\n\nvoid show_fd_locks(struct seq_file *f,\n\t\t  struct file *filp, struct files_struct *files)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct file_lock_context *ctx;\n\tint id = 0;\n\n\tctx = locks_inode_context(inode);\n\tif (!ctx)\n\t\treturn;\n\n\tspin_lock(&ctx->flc_lock);\n\t__show_fd_locks(f, &ctx->flc_flock, &id, filp, files);\n\t__show_fd_locks(f, &ctx->flc_posix, &id, filp, files);\n\t__show_fd_locks(f, &ctx->flc_lease, &id, filp, files);\n\tspin_unlock(&ctx->flc_lock);\n}\n\nstatic void *locks_start(struct seq_file *f, loff_t *pos)\n\t__acquires(&blocked_lock_lock)\n{\n\tstruct locks_iterator *iter = f->private;\n\n\titer->li_pos = *pos + 1;\n\tpercpu_down_write(&file_rwsem);\n\tspin_lock(&blocked_lock_lock);\n\treturn seq_hlist_start_percpu(&file_lock_list.hlist, &iter->li_cpu, *pos);\n}\n\nstatic void *locks_next(struct seq_file *f, void *v, loff_t *pos)\n{\n\tstruct locks_iterator *iter = f->private;\n\n\t++iter->li_pos;\n\treturn seq_hlist_next_percpu(v, &file_lock_list.hlist, &iter->li_cpu, pos);\n}\n\nstatic void locks_stop(struct seq_file *f, void *v)\n\t__releases(&blocked_lock_lock)\n{\n\tspin_unlock(&blocked_lock_lock);\n\tpercpu_up_write(&file_rwsem);\n}\n\nstatic const struct seq_operations locks_seq_operations = {\n\t.start\t= locks_start,\n\t.next\t= locks_next,\n\t.stop\t= locks_stop,\n\t.show\t= locks_show,\n};\n\nstatic int __init proc_locks_init(void)\n{\n\tproc_create_seq_private(\"locks\", 0, NULL, &locks_seq_operations,\n\t\t\tsizeof(struct locks_iterator), NULL);\n\treturn 0;\n}\nfs_initcall(proc_locks_init);\n#endif\n\nstatic int __init filelock_init(void)\n{\n\tint i;\n\n\tflctx_cache = kmem_cache_create(\"file_lock_ctx\",\n\t\t\tsizeof(struct file_lock_context), 0, SLAB_PANIC, NULL);\n\n\tfilelock_cache = kmem_cache_create(\"file_lock_cache\",\n\t\t\tsizeof(struct file_lock), 0, SLAB_PANIC, NULL);\n\n\tfor_each_possible_cpu(i) {\n\t\tstruct file_lock_list_struct *fll = per_cpu_ptr(&file_lock_list, i);\n\n\t\tspin_lock_init(&fll->lock);\n\t\tINIT_HLIST_HEAD(&fll->hlist);\n\t}\n\n\tlease_notifier_chain_init();\n\treturn 0;\n}\ncore_initcall(filelock_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}