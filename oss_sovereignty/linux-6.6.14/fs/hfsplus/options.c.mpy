{
  "module_name": "options.c",
  "hash_id": "731c4e5454f55f6c961810737581f34d0a7ce7c376e6cd3e0e928d68616832e6",
  "original_prompt": "Ingested from linux-6.6.14/fs/hfsplus/options.c",
  "human_readable_source": "\n \n\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/nls.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include \"hfsplus_fs.h\"\n\nenum {\n\topt_creator, opt_type,\n\topt_umask, opt_uid, opt_gid,\n\topt_part, opt_session, opt_nls,\n\topt_nodecompose, opt_decompose,\n\topt_barrier, opt_nobarrier,\n\topt_force, opt_err\n};\n\nstatic const match_table_t tokens = {\n\t{ opt_creator, \"creator=%s\" },\n\t{ opt_type, \"type=%s\" },\n\t{ opt_umask, \"umask=%o\" },\n\t{ opt_uid, \"uid=%u\" },\n\t{ opt_gid, \"gid=%u\" },\n\t{ opt_part, \"part=%u\" },\n\t{ opt_session, \"session=%u\" },\n\t{ opt_nls, \"nls=%s\" },\n\t{ opt_decompose, \"decompose\" },\n\t{ opt_nodecompose, \"nodecompose\" },\n\t{ opt_barrier, \"barrier\" },\n\t{ opt_nobarrier, \"nobarrier\" },\n\t{ opt_force, \"force\" },\n\t{ opt_err, NULL }\n};\n\n \nvoid hfsplus_fill_defaults(struct hfsplus_sb_info *opts)\n{\n\tif (!opts)\n\t\treturn;\n\n\topts->creator = HFSPLUS_DEF_CR_TYPE;\n\topts->type = HFSPLUS_DEF_CR_TYPE;\n\topts->umask = current_umask();\n\topts->uid = current_uid();\n\topts->gid = current_gid();\n\topts->part = -1;\n\topts->session = -1;\n}\n\n \nstatic inline int match_fourchar(substring_t *arg, u32 *result)\n{\n\tif (arg->to - arg->from != 4)\n\t\treturn -EINVAL;\n\tmemcpy(result, arg->from, 4);\n\treturn 0;\n}\n\nint hfsplus_parse_options_remount(char *input, int *force)\n{\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint token;\n\n\tif (!input)\n\t\treturn 1;\n\n\twhile ((p = strsep(&input, \",\")) != NULL) {\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase opt_force:\n\t\t\t*force = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 1;\n}\n\n \n \nint hfsplus_parse_options(char *input, struct hfsplus_sb_info *sbi)\n{\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint tmp, token;\n\n\tif (!input)\n\t\tgoto done;\n\n\twhile ((p = strsep(&input, \",\")) != NULL) {\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase opt_creator:\n\t\t\tif (match_fourchar(&args[0], &sbi->creator)) {\n\t\t\t\tpr_err(\"creator requires a 4 character value\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase opt_type:\n\t\t\tif (match_fourchar(&args[0], &sbi->type)) {\n\t\t\t\tpr_err(\"type requires a 4 character value\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase opt_umask:\n\t\t\tif (match_octal(&args[0], &tmp)) {\n\t\t\t\tpr_err(\"umask requires a value\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tsbi->umask = (umode_t)tmp;\n\t\t\tbreak;\n\t\tcase opt_uid:\n\t\t\tif (match_int(&args[0], &tmp)) {\n\t\t\t\tpr_err(\"uid requires an argument\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tsbi->uid = make_kuid(current_user_ns(), (uid_t)tmp);\n\t\t\tif (!uid_valid(sbi->uid)) {\n\t\t\t\tpr_err(\"invalid uid specified\\n\");\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\tset_bit(HFSPLUS_SB_UID, &sbi->flags);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase opt_gid:\n\t\t\tif (match_int(&args[0], &tmp)) {\n\t\t\t\tpr_err(\"gid requires an argument\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tsbi->gid = make_kgid(current_user_ns(), (gid_t)tmp);\n\t\t\tif (!gid_valid(sbi->gid)) {\n\t\t\t\tpr_err(\"invalid gid specified\\n\");\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\tset_bit(HFSPLUS_SB_GID, &sbi->flags);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase opt_part:\n\t\t\tif (match_int(&args[0], &sbi->part)) {\n\t\t\t\tpr_err(\"part requires an argument\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase opt_session:\n\t\t\tif (match_int(&args[0], &sbi->session)) {\n\t\t\t\tpr_err(\"session requires an argument\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase opt_nls:\n\t\t\tif (sbi->nls) {\n\t\t\t\tpr_err(\"unable to change nls mapping\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tp = match_strdup(&args[0]);\n\t\t\tif (p)\n\t\t\t\tsbi->nls = load_nls(p);\n\t\t\tif (!sbi->nls) {\n\t\t\t\tpr_err(\"unable to load nls mapping \\\"%s\\\"\\n\",\n\t\t\t\t       p);\n\t\t\t\tkfree(p);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\tcase opt_decompose:\n\t\t\tclear_bit(HFSPLUS_SB_NODECOMPOSE, &sbi->flags);\n\t\t\tbreak;\n\t\tcase opt_nodecompose:\n\t\t\tset_bit(HFSPLUS_SB_NODECOMPOSE, &sbi->flags);\n\t\t\tbreak;\n\t\tcase opt_barrier:\n\t\t\tclear_bit(HFSPLUS_SB_NOBARRIER, &sbi->flags);\n\t\t\tbreak;\n\t\tcase opt_nobarrier:\n\t\t\tset_bit(HFSPLUS_SB_NOBARRIER, &sbi->flags);\n\t\t\tbreak;\n\t\tcase opt_force:\n\t\t\tset_bit(HFSPLUS_SB_FORCE, &sbi->flags);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\ndone:\n\tif (!sbi->nls) {\n\t\t \n\t\tsbi->nls = load_nls(\"utf8\");\n\t\tif (!sbi->nls)\n\t\t\tsbi->nls = load_nls_default();\n\t\tif (!sbi->nls)\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nint hfsplus_show_options(struct seq_file *seq, struct dentry *root)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(root->d_sb);\n\n\tif (sbi->creator != HFSPLUS_DEF_CR_TYPE)\n\t\tseq_show_option_n(seq, \"creator\", (char *)&sbi->creator, 4);\n\tif (sbi->type != HFSPLUS_DEF_CR_TYPE)\n\t\tseq_show_option_n(seq, \"type\", (char *)&sbi->type, 4);\n\tseq_printf(seq, \",umask=%o,uid=%u,gid=%u\", sbi->umask,\n\t\t\tfrom_kuid_munged(&init_user_ns, sbi->uid),\n\t\t\tfrom_kgid_munged(&init_user_ns, sbi->gid));\n\tif (sbi->part >= 0)\n\t\tseq_printf(seq, \",part=%u\", sbi->part);\n\tif (sbi->session >= 0)\n\t\tseq_printf(seq, \",session=%u\", sbi->session);\n\tif (sbi->nls)\n\t\tseq_printf(seq, \",nls=%s\", sbi->nls->charset);\n\tif (test_bit(HFSPLUS_SB_NODECOMPOSE, &sbi->flags))\n\t\tseq_puts(seq, \",nodecompose\");\n\tif (test_bit(HFSPLUS_SB_NOBARRIER, &sbi->flags))\n\t\tseq_puts(seq, \",nobarrier\");\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}