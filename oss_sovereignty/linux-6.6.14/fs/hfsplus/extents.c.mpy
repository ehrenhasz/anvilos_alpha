{
  "module_name": "extents.c",
  "hash_id": "bf79a8bc9647b3f972f424aacf47f30920dd45fd9667e350cf784e606b1cadab",
  "original_prompt": "Ingested from linux-6.6.14/fs/hfsplus/extents.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n\n#include \"hfsplus_fs.h\"\n#include \"hfsplus_raw.h\"\n\n \nint hfsplus_ext_cmp_key(const hfsplus_btree_key *k1,\n\t\t\tconst hfsplus_btree_key *k2)\n{\n\t__be32 k1id, k2id;\n\t__be32 k1s, k2s;\n\n\tk1id = k1->ext.cnid;\n\tk2id = k2->ext.cnid;\n\tif (k1id != k2id)\n\t\treturn be32_to_cpu(k1id) < be32_to_cpu(k2id) ? -1 : 1;\n\n\tif (k1->ext.fork_type != k2->ext.fork_type)\n\t\treturn k1->ext.fork_type < k2->ext.fork_type ? -1 : 1;\n\n\tk1s = k1->ext.start_block;\n\tk2s = k2->ext.start_block;\n\tif (k1s == k2s)\n\t\treturn 0;\n\treturn be32_to_cpu(k1s) < be32_to_cpu(k2s) ? -1 : 1;\n}\n\nstatic void hfsplus_ext_build_key(hfsplus_btree_key *key, u32 cnid,\n\t\t\t\t  u32 block, u8 type)\n{\n\tkey->key_len = cpu_to_be16(HFSPLUS_EXT_KEYLEN - 2);\n\tkey->ext.cnid = cpu_to_be32(cnid);\n\tkey->ext.start_block = cpu_to_be32(block);\n\tkey->ext.fork_type = type;\n\tkey->ext.pad = 0;\n}\n\nstatic u32 hfsplus_ext_find_block(struct hfsplus_extent *ext, u32 off)\n{\n\tint i;\n\tu32 count;\n\n\tfor (i = 0; i < 8; ext++, i++) {\n\t\tcount = be32_to_cpu(ext->block_count);\n\t\tif (off < count)\n\t\t\treturn be32_to_cpu(ext->start_block) + off;\n\t\toff -= count;\n\t}\n\t \n\treturn 0;\n}\n\nstatic int hfsplus_ext_block_count(struct hfsplus_extent *ext)\n{\n\tint i;\n\tu32 count = 0;\n\n\tfor (i = 0; i < 8; ext++, i++)\n\t\tcount += be32_to_cpu(ext->block_count);\n\treturn count;\n}\n\nstatic u32 hfsplus_ext_lastblock(struct hfsplus_extent *ext)\n{\n\tint i;\n\n\text += 7;\n\tfor (i = 0; i < 7; ext--, i++)\n\t\tif (ext->block_count)\n\t\t\tbreak;\n\treturn be32_to_cpu(ext->start_block) + be32_to_cpu(ext->block_count);\n}\n\nstatic int __hfsplus_ext_write_extent(struct inode *inode,\n\t\tstruct hfs_find_data *fd)\n{\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tint res;\n\n\tWARN_ON(!mutex_is_locked(&hip->extents_lock));\n\n\thfsplus_ext_build_key(fd->search_key, inode->i_ino, hip->cached_start,\n\t\t\t      HFSPLUS_IS_RSRC(inode) ?\n\t\t\t\tHFSPLUS_TYPE_RSRC : HFSPLUS_TYPE_DATA);\n\n\tres = hfs_brec_find(fd, hfs_find_rec_by_key);\n\tif (hip->extent_state & HFSPLUS_EXT_NEW) {\n\t\tif (res != -ENOENT)\n\t\t\treturn res;\n\t\t \n\t\tres = hfs_bmap_reserve(fd->tree, fd->tree->depth + 1);\n\t\tif (res)\n\t\t\treturn res;\n\t\thfs_brec_insert(fd, hip->cached_extents,\n\t\t\t\tsizeof(hfsplus_extent_rec));\n\t\thip->extent_state &= ~(HFSPLUS_EXT_DIRTY | HFSPLUS_EXT_NEW);\n\t} else {\n\t\tif (res)\n\t\t\treturn res;\n\t\thfs_bnode_write(fd->bnode, hip->cached_extents,\n\t\t\t\tfd->entryoffset, fd->entrylength);\n\t\thip->extent_state &= ~HFSPLUS_EXT_DIRTY;\n\t}\n\n\t \n\tset_bit(HFSPLUS_I_EXT_DIRTY, &hip->flags);\n\n\treturn 0;\n}\n\nstatic int hfsplus_ext_write_extent_locked(struct inode *inode)\n{\n\tint res = 0;\n\n\tif (HFSPLUS_I(inode)->extent_state & HFSPLUS_EXT_DIRTY) {\n\t\tstruct hfs_find_data fd;\n\n\t\tres = hfs_find_init(HFSPLUS_SB(inode->i_sb)->ext_tree, &fd);\n\t\tif (res)\n\t\t\treturn res;\n\t\tres = __hfsplus_ext_write_extent(inode, &fd);\n\t\thfs_find_exit(&fd);\n\t}\n\treturn res;\n}\n\nint hfsplus_ext_write_extent(struct inode *inode)\n{\n\tint res;\n\n\tmutex_lock(&HFSPLUS_I(inode)->extents_lock);\n\tres = hfsplus_ext_write_extent_locked(inode);\n\tmutex_unlock(&HFSPLUS_I(inode)->extents_lock);\n\n\treturn res;\n}\n\nstatic inline int __hfsplus_ext_read_extent(struct hfs_find_data *fd,\n\t\t\t\t\t    struct hfsplus_extent *extent,\n\t\t\t\t\t    u32 cnid, u32 block, u8 type)\n{\n\tint res;\n\n\thfsplus_ext_build_key(fd->search_key, cnid, block, type);\n\tfd->key->ext.cnid = 0;\n\tres = hfs_brec_find(fd, hfs_find_rec_by_key);\n\tif (res && res != -ENOENT)\n\t\treturn res;\n\tif (fd->key->ext.cnid != fd->search_key->ext.cnid ||\n\t    fd->key->ext.fork_type != fd->search_key->ext.fork_type)\n\t\treturn -ENOENT;\n\tif (fd->entrylength != sizeof(hfsplus_extent_rec))\n\t\treturn -EIO;\n\thfs_bnode_read(fd->bnode, extent, fd->entryoffset,\n\t\tsizeof(hfsplus_extent_rec));\n\treturn 0;\n}\n\nstatic inline int __hfsplus_ext_cache_extent(struct hfs_find_data *fd,\n\t\tstruct inode *inode, u32 block)\n{\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tint res;\n\n\tWARN_ON(!mutex_is_locked(&hip->extents_lock));\n\n\tif (hip->extent_state & HFSPLUS_EXT_DIRTY) {\n\t\tres = __hfsplus_ext_write_extent(inode, fd);\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\n\tres = __hfsplus_ext_read_extent(fd, hip->cached_extents, inode->i_ino,\n\t\t\t\t\tblock, HFSPLUS_IS_RSRC(inode) ?\n\t\t\t\t\t\tHFSPLUS_TYPE_RSRC :\n\t\t\t\t\t\tHFSPLUS_TYPE_DATA);\n\tif (!res) {\n\t\thip->cached_start = be32_to_cpu(fd->key->ext.start_block);\n\t\thip->cached_blocks =\n\t\t\thfsplus_ext_block_count(hip->cached_extents);\n\t} else {\n\t\thip->cached_start = hip->cached_blocks = 0;\n\t\thip->extent_state &= ~(HFSPLUS_EXT_DIRTY | HFSPLUS_EXT_NEW);\n\t}\n\treturn res;\n}\n\nstatic int hfsplus_ext_read_extent(struct inode *inode, u32 block)\n{\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tstruct hfs_find_data fd;\n\tint res;\n\n\tif (block >= hip->cached_start &&\n\t    block < hip->cached_start + hip->cached_blocks)\n\t\treturn 0;\n\n\tres = hfs_find_init(HFSPLUS_SB(inode->i_sb)->ext_tree, &fd);\n\tif (!res) {\n\t\tres = __hfsplus_ext_cache_extent(&fd, inode, block);\n\t\thfs_find_exit(&fd);\n\t}\n\treturn res;\n}\n\n \nint hfsplus_get_block(struct inode *inode, sector_t iblock,\n\t\t      struct buffer_head *bh_result, int create)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tint res = -EIO;\n\tu32 ablock, dblock, mask;\n\tsector_t sector;\n\tint was_dirty = 0;\n\n\t \n\tablock = iblock >> sbi->fs_shift;\n\n\tif (iblock >= hip->fs_blocks) {\n\t\tif (!create)\n\t\t\treturn 0;\n\t\tif (iblock > hip->fs_blocks)\n\t\t\treturn -EIO;\n\t\tif (ablock >= hip->alloc_blocks) {\n\t\t\tres = hfsplus_file_extend(inode, false);\n\t\t\tif (res)\n\t\t\t\treturn res;\n\t\t}\n\t} else\n\t\tcreate = 0;\n\n\tif (ablock < hip->first_blocks) {\n\t\tdblock = hfsplus_ext_find_block(hip->first_extents, ablock);\n\t\tgoto done;\n\t}\n\n\tif (inode->i_ino == HFSPLUS_EXT_CNID)\n\t\treturn -EIO;\n\n\tmutex_lock(&hip->extents_lock);\n\n\t \n\twas_dirty = (hip->extent_state & HFSPLUS_EXT_DIRTY);\n\tres = hfsplus_ext_read_extent(inode, ablock);\n\tif (res) {\n\t\tmutex_unlock(&hip->extents_lock);\n\t\treturn -EIO;\n\t}\n\tdblock = hfsplus_ext_find_block(hip->cached_extents,\n\t\t\t\t\tablock - hip->cached_start);\n\tmutex_unlock(&hip->extents_lock);\n\ndone:\n\thfs_dbg(EXTENT, \"get_block(%lu): %llu - %u\\n\",\n\t\tinode->i_ino, (long long)iblock, dblock);\n\n\tmask = (1 << sbi->fs_shift) - 1;\n\tsector = ((sector_t)dblock << sbi->fs_shift) +\n\t\t  sbi->blockoffset + (iblock & mask);\n\tmap_bh(bh_result, sb, sector);\n\n\tif (create) {\n\t\tset_buffer_new(bh_result);\n\t\thip->phys_size += sb->s_blocksize;\n\t\thip->fs_blocks++;\n\t\tinode_add_bytes(inode, sb->s_blocksize);\n\t}\n\tif (create || was_dirty)\n\t\tmark_inode_dirty(inode);\n\treturn 0;\n}\n\nstatic void hfsplus_dump_extent(struct hfsplus_extent *extent)\n{\n\tint i;\n\n\thfs_dbg(EXTENT, \"   \");\n\tfor (i = 0; i < 8; i++)\n\t\thfs_dbg_cont(EXTENT, \" %u:%u\",\n\t\t\t     be32_to_cpu(extent[i].start_block),\n\t\t\t     be32_to_cpu(extent[i].block_count));\n\thfs_dbg_cont(EXTENT, \"\\n\");\n}\n\nstatic int hfsplus_add_extent(struct hfsplus_extent *extent, u32 offset,\n\t\t\t      u32 alloc_block, u32 block_count)\n{\n\tu32 count, start;\n\tint i;\n\n\thfsplus_dump_extent(extent);\n\tfor (i = 0; i < 8; extent++, i++) {\n\t\tcount = be32_to_cpu(extent->block_count);\n\t\tif (offset == count) {\n\t\t\tstart = be32_to_cpu(extent->start_block);\n\t\t\tif (alloc_block != start + count) {\n\t\t\t\tif (++i >= 8)\n\t\t\t\t\treturn -ENOSPC;\n\t\t\t\textent++;\n\t\t\t\textent->start_block = cpu_to_be32(alloc_block);\n\t\t\t} else\n\t\t\t\tblock_count += count;\n\t\t\textent->block_count = cpu_to_be32(block_count);\n\t\t\treturn 0;\n\t\t} else if (offset < count)\n\t\t\tbreak;\n\t\toffset -= count;\n\t}\n\t \n\treturn -EIO;\n}\n\nstatic int hfsplus_free_extents(struct super_block *sb,\n\t\t\t\tstruct hfsplus_extent *extent,\n\t\t\t\tu32 offset, u32 block_nr)\n{\n\tu32 count, start;\n\tint i;\n\tint err = 0;\n\n\t \n\tWARN_ON(mutex_is_locked(&HFSPLUS_SB(sb)->ext_tree->tree_lock));\n\n\thfsplus_dump_extent(extent);\n\tfor (i = 0; i < 8; extent++, i++) {\n\t\tcount = be32_to_cpu(extent->block_count);\n\t\tif (offset == count)\n\t\t\tgoto found;\n\t\telse if (offset < count)\n\t\t\tbreak;\n\t\toffset -= count;\n\t}\n\t \n\treturn -EIO;\nfound:\n\tfor (;;) {\n\t\tstart = be32_to_cpu(extent->start_block);\n\t\tif (count <= block_nr) {\n\t\t\terr = hfsplus_block_free(sb, start, count);\n\t\t\tif (err) {\n\t\t\t\tpr_err(\"can't free extent\\n\");\n\t\t\t\thfs_dbg(EXTENT, \" start: %u count: %u\\n\",\n\t\t\t\t\tstart, count);\n\t\t\t}\n\t\t\textent->block_count = 0;\n\t\t\textent->start_block = 0;\n\t\t\tblock_nr -= count;\n\t\t} else {\n\t\t\tcount -= block_nr;\n\t\t\terr = hfsplus_block_free(sb, start + count, block_nr);\n\t\t\tif (err) {\n\t\t\t\tpr_err(\"can't free extent\\n\");\n\t\t\t\thfs_dbg(EXTENT, \" start: %u count: %u\\n\",\n\t\t\t\t\tstart, count);\n\t\t\t}\n\t\t\textent->block_count = cpu_to_be32(count);\n\t\t\tblock_nr = 0;\n\t\t}\n\t\tif (!block_nr || !i) {\n\t\t\t \n\t\t\treturn err;\n\t\t}\n\t\ti--;\n\t\textent--;\n\t\tcount = be32_to_cpu(extent->block_count);\n\t}\n}\n\nint hfsplus_free_fork(struct super_block *sb, u32 cnid,\n\t\tstruct hfsplus_fork_raw *fork, int type)\n{\n\tstruct hfs_find_data fd;\n\thfsplus_extent_rec ext_entry;\n\tu32 total_blocks, blocks, start;\n\tint res, i;\n\n\ttotal_blocks = be32_to_cpu(fork->total_blocks);\n\tif (!total_blocks)\n\t\treturn 0;\n\n\tblocks = 0;\n\tfor (i = 0; i < 8; i++)\n\t\tblocks += be32_to_cpu(fork->extents[i].block_count);\n\n\tres = hfsplus_free_extents(sb, fork->extents, blocks, blocks);\n\tif (res)\n\t\treturn res;\n\tif (total_blocks == blocks)\n\t\treturn 0;\n\n\tres = hfs_find_init(HFSPLUS_SB(sb)->ext_tree, &fd);\n\tif (res)\n\t\treturn res;\n\tdo {\n\t\tres = __hfsplus_ext_read_extent(&fd, ext_entry, cnid,\n\t\t\t\t\t\ttotal_blocks, type);\n\t\tif (res)\n\t\t\tbreak;\n\t\tstart = be32_to_cpu(fd.key->ext.start_block);\n\t\thfs_brec_remove(&fd);\n\n\t\tmutex_unlock(&fd.tree->tree_lock);\n\t\thfsplus_free_extents(sb, ext_entry, total_blocks - start,\n\t\t\t\t     total_blocks);\n\t\ttotal_blocks = start;\n\t\tmutex_lock(&fd.tree->tree_lock);\n\t} while (total_blocks > blocks);\n\thfs_find_exit(&fd);\n\n\treturn res;\n}\n\nint hfsplus_file_extend(struct inode *inode, bool zeroout)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tu32 start, len, goal;\n\tint res;\n\n\tif (sbi->alloc_file->i_size * 8 <\n\t    sbi->total_blocks - sbi->free_blocks + 8) {\n\t\t \n\t\tpr_err_ratelimited(\"extend alloc file! (%llu,%u,%u)\\n\",\n\t\t\t\t   sbi->alloc_file->i_size * 8,\n\t\t\t\t   sbi->total_blocks, sbi->free_blocks);\n\t\treturn -ENOSPC;\n\t}\n\n\tmutex_lock(&hip->extents_lock);\n\tif (hip->alloc_blocks == hip->first_blocks)\n\t\tgoal = hfsplus_ext_lastblock(hip->first_extents);\n\telse {\n\t\tres = hfsplus_ext_read_extent(inode, hip->alloc_blocks);\n\t\tif (res)\n\t\t\tgoto out;\n\t\tgoal = hfsplus_ext_lastblock(hip->cached_extents);\n\t}\n\n\tlen = hip->clump_blocks;\n\tstart = hfsplus_block_allocate(sb, sbi->total_blocks, goal, &len);\n\tif (start >= sbi->total_blocks) {\n\t\tstart = hfsplus_block_allocate(sb, goal, 0, &len);\n\t\tif (start >= goal) {\n\t\t\tres = -ENOSPC;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (zeroout) {\n\t\tres = sb_issue_zeroout(sb, start, len, GFP_NOFS);\n\t\tif (res)\n\t\t\tgoto out;\n\t}\n\n\thfs_dbg(EXTENT, \"extend %lu: %u,%u\\n\", inode->i_ino, start, len);\n\n\tif (hip->alloc_blocks <= hip->first_blocks) {\n\t\tif (!hip->first_blocks) {\n\t\t\thfs_dbg(EXTENT, \"first extents\\n\");\n\t\t\t \n\t\t\thip->first_extents[0].start_block = cpu_to_be32(start);\n\t\t\thip->first_extents[0].block_count = cpu_to_be32(len);\n\t\t\tres = 0;\n\t\t} else {\n\t\t\t \n\t\t\tres = hfsplus_add_extent(hip->first_extents,\n\t\t\t\t\t\t hip->alloc_blocks,\n\t\t\t\t\t\t start, len);\n\t\t\tif (res == -ENOSPC)\n\t\t\t\tgoto insert_extent;\n\t\t}\n\t\tif (!res) {\n\t\t\thfsplus_dump_extent(hip->first_extents);\n\t\t\thip->first_blocks += len;\n\t\t}\n\t} else {\n\t\tres = hfsplus_add_extent(hip->cached_extents,\n\t\t\t\t\t hip->alloc_blocks - hip->cached_start,\n\t\t\t\t\t start, len);\n\t\tif (!res) {\n\t\t\thfsplus_dump_extent(hip->cached_extents);\n\t\t\thip->extent_state |= HFSPLUS_EXT_DIRTY;\n\t\t\thip->cached_blocks += len;\n\t\t} else if (res == -ENOSPC)\n\t\t\tgoto insert_extent;\n\t}\nout:\n\tif (!res) {\n\t\thip->alloc_blocks += len;\n\t\tmutex_unlock(&hip->extents_lock);\n\t\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_ALLOC_DIRTY);\n\t\treturn 0;\n\t}\n\tmutex_unlock(&hip->extents_lock);\n\treturn res;\n\ninsert_extent:\n\thfs_dbg(EXTENT, \"insert new extent\\n\");\n\tres = hfsplus_ext_write_extent_locked(inode);\n\tif (res)\n\t\tgoto out;\n\n\tmemset(hip->cached_extents, 0, sizeof(hfsplus_extent_rec));\n\thip->cached_extents[0].start_block = cpu_to_be32(start);\n\thip->cached_extents[0].block_count = cpu_to_be32(len);\n\thfsplus_dump_extent(hip->cached_extents);\n\thip->extent_state |= HFSPLUS_EXT_DIRTY | HFSPLUS_EXT_NEW;\n\thip->cached_start = hip->alloc_blocks;\n\thip->cached_blocks = len;\n\n\tres = 0;\n\tgoto out;\n}\n\nvoid hfsplus_file_truncate(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tstruct hfs_find_data fd;\n\tu32 alloc_cnt, blk_cnt, start;\n\tint res;\n\n\thfs_dbg(INODE, \"truncate: %lu, %llu -> %llu\\n\",\n\t\tinode->i_ino, (long long)hip->phys_size, inode->i_size);\n\n\tif (inode->i_size > hip->phys_size) {\n\t\tstruct address_space *mapping = inode->i_mapping;\n\t\tstruct page *page;\n\t\tvoid *fsdata = NULL;\n\t\tloff_t size = inode->i_size;\n\n\t\tres = hfsplus_write_begin(NULL, mapping, size, 0,\n\t\t\t\t\t  &page, &fsdata);\n\t\tif (res)\n\t\t\treturn;\n\t\tres = generic_write_end(NULL, mapping, size, 0, 0,\n\t\t\t\t\tpage, fsdata);\n\t\tif (res < 0)\n\t\t\treturn;\n\t\tmark_inode_dirty(inode);\n\t\treturn;\n\t} else if (inode->i_size == hip->phys_size)\n\t\treturn;\n\n\tblk_cnt = (inode->i_size + HFSPLUS_SB(sb)->alloc_blksz - 1) >>\n\t\t\tHFSPLUS_SB(sb)->alloc_blksz_shift;\n\n\tmutex_lock(&hip->extents_lock);\n\n\talloc_cnt = hip->alloc_blocks;\n\tif (blk_cnt == alloc_cnt)\n\t\tgoto out_unlock;\n\n\tres = hfs_find_init(HFSPLUS_SB(sb)->ext_tree, &fd);\n\tif (res) {\n\t\tmutex_unlock(&hip->extents_lock);\n\t\t \n\t\treturn;\n\t}\n\twhile (1) {\n\t\tif (alloc_cnt == hip->first_blocks) {\n\t\t\tmutex_unlock(&fd.tree->tree_lock);\n\t\t\thfsplus_free_extents(sb, hip->first_extents,\n\t\t\t\t\t     alloc_cnt, alloc_cnt - blk_cnt);\n\t\t\thfsplus_dump_extent(hip->first_extents);\n\t\t\thip->first_blocks = blk_cnt;\n\t\t\tmutex_lock(&fd.tree->tree_lock);\n\t\t\tbreak;\n\t\t}\n\t\tres = __hfsplus_ext_cache_extent(&fd, inode, alloc_cnt);\n\t\tif (res)\n\t\t\tbreak;\n\n\t\tstart = hip->cached_start;\n\t\tif (blk_cnt <= start)\n\t\t\thfs_brec_remove(&fd);\n\t\tmutex_unlock(&fd.tree->tree_lock);\n\t\thfsplus_free_extents(sb, hip->cached_extents,\n\t\t\t\t     alloc_cnt - start, alloc_cnt - blk_cnt);\n\t\thfsplus_dump_extent(hip->cached_extents);\n\t\tmutex_lock(&fd.tree->tree_lock);\n\t\tif (blk_cnt > start) {\n\t\t\thip->extent_state |= HFSPLUS_EXT_DIRTY;\n\t\t\tbreak;\n\t\t}\n\t\talloc_cnt = start;\n\t\thip->cached_start = hip->cached_blocks = 0;\n\t\thip->extent_state &= ~(HFSPLUS_EXT_DIRTY | HFSPLUS_EXT_NEW);\n\t}\n\thfs_find_exit(&fd);\n\n\thip->alloc_blocks = blk_cnt;\nout_unlock:\n\tmutex_unlock(&hip->extents_lock);\n\thip->phys_size = inode->i_size;\n\thip->fs_blocks = (inode->i_size + sb->s_blocksize - 1) >>\n\t\tsb->s_blocksize_bits;\n\tinode_set_bytes(inode, hip->fs_blocks << sb->s_blocksize_bits);\n\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_ALLOC_DIRTY);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}