{
  "module_name": "bfind.c",
  "hash_id": "767eb6005cec2289212523e1abff789ffeacb4055d82b28e150c46108b893cb8",
  "original_prompt": "Ingested from linux-6.6.14/fs/hfsplus/bfind.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include \"hfsplus_fs.h\"\n\nint hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tswitch (tree->cnid) {\n\tcase HFSPLUS_CAT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, CATALOG_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_EXT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, EXTENTS_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, ATTR_BTREE_MUTEX);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn 0;\n}\n\nvoid hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}\n\nint hfs_find_1st_rec_by_cnid(struct hfs_bnode *bnode,\n\t\t\t\tstruct hfs_find_data *fd,\n\t\t\t\tint *begin,\n\t\t\t\tint *end,\n\t\t\t\tint *cur_rec)\n{\n\t__be32 cur_cnid;\n\t__be32 search_cnid;\n\n\tif (bnode->tree->cnid == HFSPLUS_EXT_CNID) {\n\t\tcur_cnid = fd->key->ext.cnid;\n\t\tsearch_cnid = fd->search_key->ext.cnid;\n\t} else if (bnode->tree->cnid == HFSPLUS_CAT_CNID) {\n\t\tcur_cnid = fd->key->cat.parent;\n\t\tsearch_cnid = fd->search_key->cat.parent;\n\t} else if (bnode->tree->cnid == HFSPLUS_ATTR_CNID) {\n\t\tcur_cnid = fd->key->attr.cnid;\n\t\tsearch_cnid = fd->search_key->attr.cnid;\n\t} else {\n\t\tcur_cnid = 0;\t \n\t\tsearch_cnid = 0;\n\t\tBUG();\n\t}\n\n\tif (cur_cnid == search_cnid) {\n\t\t(*end) = (*cur_rec);\n\t\tif ((*begin) == (*end))\n\t\t\treturn 1;\n\t} else {\n\t\tif (be32_to_cpu(cur_cnid) < be32_to_cpu(search_cnid))\n\t\t\t(*begin) = (*cur_rec) + 1;\n\t\telse\n\t\t\t(*end) = (*cur_rec) - 1;\n\t}\n\n\treturn 0;\n}\n\nint hfs_find_rec_by_key(struct hfs_bnode *bnode,\n\t\t\t\tstruct hfs_find_data *fd,\n\t\t\t\tint *begin,\n\t\t\t\tint *end,\n\t\t\t\tint *cur_rec)\n{\n\tint cmpval;\n\n\tcmpval = bnode->tree->keycmp(fd->key, fd->search_key);\n\tif (!cmpval) {\n\t\t(*end) = (*cur_rec);\n\t\treturn 1;\n\t}\n\tif (cmpval < 0)\n\t\t(*begin) = (*cur_rec) + 1;\n\telse\n\t\t*(end) = (*cur_rec) - 1;\n\n\treturn 0;\n}\n\n \nint __hfs_brec_find(struct hfs_bnode *bnode, struct hfs_find_data *fd,\n\t\t\t\t\tsearch_strategy_t rec_found)\n{\n\tu16 off, len, keylen;\n\tint rec;\n\tint b, e;\n\tint res;\n\n\tBUG_ON(!rec_found);\n\tb = 0;\n\te = bnode->num_recs - 1;\n\tres = -ENOENT;\n\tdo {\n\t\trec = (e + b) / 2;\n\t\tlen = hfs_brec_lenoff(bnode, rec, &off);\n\t\tkeylen = hfs_brec_keylen(bnode, rec);\n\t\tif (keylen == 0) {\n\t\t\tres = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\t\thfs_bnode_read(bnode, fd->key, off, keylen);\n\t\tif (rec_found(bnode, fd, &b, &e, &rec)) {\n\t\t\tres = 0;\n\t\t\tgoto done;\n\t\t}\n\t} while (b <= e);\n\n\tif (rec != e && e >= 0) {\n\t\tlen = hfs_brec_lenoff(bnode, e, &off);\n\t\tkeylen = hfs_brec_keylen(bnode, e);\n\t\tif (keylen == 0) {\n\t\t\tres = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\t\thfs_bnode_read(bnode, fd->key, off, keylen);\n\t}\n\ndone:\n\tfd->record = e;\n\tfd->keyoffset = off;\n\tfd->keylength = keylen;\n\tfd->entryoffset = off + keylen;\n\tfd->entrylength = len - keylen;\n\nfail:\n\treturn res;\n}\n\n \n \nint hfs_brec_find(struct hfs_find_data *fd, search_strategy_t do_key_compare)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *bnode;\n\tu32 nidx, parent;\n\t__be32 data;\n\tint height, res;\n\n\ttree = fd->tree;\n\tif (fd->bnode)\n\t\thfs_bnode_put(fd->bnode);\n\tfd->bnode = NULL;\n\tnidx = tree->root;\n\tif (!nidx)\n\t\treturn -ENOENT;\n\theight = tree->depth;\n\tres = 0;\n\tparent = 0;\n\tfor (;;) {\n\t\tbnode = hfs_bnode_find(tree, nidx);\n\t\tif (IS_ERR(bnode)) {\n\t\t\tres = PTR_ERR(bnode);\n\t\t\tbnode = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (bnode->height != height)\n\t\t\tgoto invalid;\n\t\tif (bnode->type != (--height ? HFS_NODE_INDEX : HFS_NODE_LEAF))\n\t\t\tgoto invalid;\n\t\tbnode->parent = parent;\n\n\t\tres = __hfs_brec_find(bnode, fd, do_key_compare);\n\t\tif (!height)\n\t\t\tbreak;\n\t\tif (fd->record < 0)\n\t\t\tgoto release;\n\n\t\tparent = nidx;\n\t\thfs_bnode_read(bnode, &data, fd->entryoffset, 4);\n\t\tnidx = be32_to_cpu(data);\n\t\thfs_bnode_put(bnode);\n\t}\n\tfd->bnode = bnode;\n\treturn res;\n\ninvalid:\n\tpr_err(\"inconsistency in B*Tree (%d,%d,%d,%u,%u)\\n\",\n\t\theight, bnode->height, bnode->type, nidx, parent);\n\tres = -EIO;\nrelease:\n\thfs_bnode_put(bnode);\n\treturn res;\n}\n\nint hfs_brec_read(struct hfs_find_data *fd, void *rec, int rec_len)\n{\n\tint res;\n\n\tres = hfs_brec_find(fd, hfs_find_rec_by_key);\n\tif (res)\n\t\treturn res;\n\tif (fd->entrylength > rec_len)\n\t\treturn -EINVAL;\n\thfs_bnode_read(fd->bnode, rec, fd->entryoffset, fd->entrylength);\n\treturn 0;\n}\n\nint hfs_brec_goto(struct hfs_find_data *fd, int cnt)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *bnode;\n\tint idx, res = 0;\n\tu16 off, len, keylen;\n\n\tbnode = fd->bnode;\n\ttree = bnode->tree;\n\n\tif (cnt < 0) {\n\t\tcnt = -cnt;\n\t\twhile (cnt > fd->record) {\n\t\t\tcnt -= fd->record + 1;\n\t\t\tfd->record = bnode->num_recs - 1;\n\t\t\tidx = bnode->prev;\n\t\t\tif (!idx) {\n\t\t\t\tres = -ENOENT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\thfs_bnode_put(bnode);\n\t\t\tbnode = hfs_bnode_find(tree, idx);\n\t\t\tif (IS_ERR(bnode)) {\n\t\t\t\tres = PTR_ERR(bnode);\n\t\t\t\tbnode = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tfd->record -= cnt;\n\t} else {\n\t\twhile (cnt >= bnode->num_recs - fd->record) {\n\t\t\tcnt -= bnode->num_recs - fd->record;\n\t\t\tfd->record = 0;\n\t\t\tidx = bnode->next;\n\t\t\tif (!idx) {\n\t\t\t\tres = -ENOENT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\thfs_bnode_put(bnode);\n\t\t\tbnode = hfs_bnode_find(tree, idx);\n\t\t\tif (IS_ERR(bnode)) {\n\t\t\t\tres = PTR_ERR(bnode);\n\t\t\t\tbnode = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tfd->record += cnt;\n\t}\n\n\tlen = hfs_brec_lenoff(bnode, fd->record, &off);\n\tkeylen = hfs_brec_keylen(bnode, fd->record);\n\tif (keylen == 0) {\n\t\tres = -EINVAL;\n\t\tgoto out;\n\t}\n\tfd->keyoffset = off;\n\tfd->keylength = keylen;\n\tfd->entryoffset = off + keylen;\n\tfd->entrylength = len - keylen;\n\thfs_bnode_read(bnode, fd->key, off, keylen);\nout:\n\tfd->bnode = bnode;\n\treturn res;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}