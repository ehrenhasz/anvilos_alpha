{
  "module_name": "unicode.c",
  "hash_id": "1fc3c9bbf3736f05a7276253efbe731f6ef587010027ed5863a07c8d22858353",
  "original_prompt": "Ingested from linux-6.6.14/fs/hfsplus/unicode.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/nls.h>\n#include \"hfsplus_fs.h\"\n#include \"hfsplus_raw.h\"\n\n \n \nstatic inline u16 case_fold(u16 c)\n{\n\tu16 tmp;\n\n\ttmp = hfsplus_case_fold_table[c >> 8];\n\tif (tmp)\n\t\ttmp = hfsplus_case_fold_table[tmp + (c & 0xff)];\n\telse\n\t\ttmp = c;\n\treturn tmp;\n}\n\n \nint hfsplus_strcasecmp(const struct hfsplus_unistr *s1,\n\t\t       const struct hfsplus_unistr *s2)\n{\n\tu16 len1, len2, c1, c2;\n\tconst hfsplus_unichr *p1, *p2;\n\n\tlen1 = be16_to_cpu(s1->length);\n\tlen2 = be16_to_cpu(s2->length);\n\tp1 = s1->unicode;\n\tp2 = s2->unicode;\n\n\twhile (1) {\n\t\tc1 = c2 = 0;\n\n\t\twhile (len1 && !c1) {\n\t\t\tc1 = case_fold(be16_to_cpu(*p1));\n\t\t\tp1++;\n\t\t\tlen1--;\n\t\t}\n\t\twhile (len2 && !c2) {\n\t\t\tc2 = case_fold(be16_to_cpu(*p2));\n\t\t\tp2++;\n\t\t\tlen2--;\n\t\t}\n\n\t\tif (c1 != c2)\n\t\t\treturn (c1 < c2) ? -1 : 1;\n\t\tif (!c1 && !c2)\n\t\t\treturn 0;\n\t}\n}\n\n \nint hfsplus_strcmp(const struct hfsplus_unistr *s1,\n\t\t   const struct hfsplus_unistr *s2)\n{\n\tu16 len1, len2, c1, c2;\n\tconst hfsplus_unichr *p1, *p2;\n\tint len;\n\n\tlen1 = be16_to_cpu(s1->length);\n\tlen2 = be16_to_cpu(s2->length);\n\tp1 = s1->unicode;\n\tp2 = s2->unicode;\n\n\tfor (len = min(len1, len2); len > 0; len--) {\n\t\tc1 = be16_to_cpu(*p1);\n\t\tc2 = be16_to_cpu(*p2);\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tp1++;\n\t\tp2++;\n\t}\n\n\treturn len1 < len2 ? -1 :\n\t       len1 > len2 ? 1 : 0;\n}\n\n\n#define Hangul_SBase\t0xac00\n#define Hangul_LBase\t0x1100\n#define Hangul_VBase\t0x1161\n#define Hangul_TBase\t0x11a7\n#define Hangul_SCount\t11172\n#define Hangul_LCount\t19\n#define Hangul_VCount\t21\n#define Hangul_TCount\t28\n#define Hangul_NCount\t(Hangul_VCount * Hangul_TCount)\n\n\nstatic u16 *hfsplus_compose_lookup(u16 *p, u16 cc)\n{\n\tint i, s, e;\n\n\ts = 1;\n\te = p[1];\n\tif (!e || cc < p[s * 2] || cc > p[e * 2])\n\t\treturn NULL;\n\tdo {\n\t\ti = (s + e) / 2;\n\t\tif (cc > p[i * 2])\n\t\t\ts = i + 1;\n\t\telse if (cc < p[i * 2])\n\t\t\te = i - 1;\n\t\telse\n\t\t\treturn hfsplus_compose_table + p[i * 2 + 1];\n\t} while (s <= e);\n\treturn NULL;\n}\n\nint hfsplus_uni2asc(struct super_block *sb,\n\t\tconst struct hfsplus_unistr *ustr,\n\t\tchar *astr, int *len_p)\n{\n\tconst hfsplus_unichr *ip;\n\tstruct nls_table *nls = HFSPLUS_SB(sb)->nls;\n\tu8 *op;\n\tu16 cc, c0, c1;\n\tu16 *ce1, *ce2;\n\tint i, len, ustrlen, res, compose;\n\n\top = astr;\n\tip = ustr->unicode;\n\tustrlen = be16_to_cpu(ustr->length);\n\tlen = *len_p;\n\tce1 = NULL;\n\tcompose = !test_bit(HFSPLUS_SB_NODECOMPOSE, &HFSPLUS_SB(sb)->flags);\n\n\twhile (ustrlen > 0) {\n\t\tc0 = be16_to_cpu(*ip++);\n\t\tustrlen--;\n\t\t \n\t\tif (likely(compose))\n\t\t\tce1 = hfsplus_compose_lookup(hfsplus_compose_table, c0);\n\t\tif (ce1)\n\t\t\tcc = ce1[0];\n\t\telse\n\t\t\tcc = 0;\n\t\tif (cc) {\n\t\t\t \n\t\t\tif (cc != 0xffff)\n\t\t\t\tgoto done;\n\t\t\tif (!ustrlen)\n\t\t\t\tgoto same;\n\t\t\tc1 = be16_to_cpu(*ip) - Hangul_VBase;\n\t\t\tif (c1 < Hangul_VCount) {\n\t\t\t\t \n\t\t\t\tcc = (c0 - Hangul_LBase) * Hangul_VCount;\n\t\t\t\tcc = (cc + c1) * Hangul_TCount;\n\t\t\t\tcc += Hangul_SBase;\n\t\t\t\tip++;\n\t\t\t\tustrlen--;\n\t\t\t\tif (!ustrlen)\n\t\t\t\t\tgoto done;\n\t\t\t\tc1 = be16_to_cpu(*ip) - Hangul_TBase;\n\t\t\t\tif (c1 > 0 && c1 < Hangul_TCount) {\n\t\t\t\t\tcc += c1;\n\t\t\t\t\tip++;\n\t\t\t\t\tustrlen--;\n\t\t\t\t}\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t\twhile (1) {\n\t\t\t \n\t\t\tif (!ustrlen)\n\t\t\t\tgoto same;\n\t\t\tc1 = be16_to_cpu(*ip);\n\t\t\tif (likely(compose))\n\t\t\t\tce1 = hfsplus_compose_lookup(\n\t\t\t\t\thfsplus_compose_table, c1);\n\t\t\tif (ce1)\n\t\t\t\tbreak;\n\t\t\tswitch (c0) {\n\t\t\tcase 0:\n\t\t\t\tc0 = 0x2400;\n\t\t\t\tbreak;\n\t\t\tcase '/':\n\t\t\t\tc0 = ':';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tres = nls->uni2char(c0, op, len);\n\t\t\tif (res < 0) {\n\t\t\t\tif (res == -ENAMETOOLONG)\n\t\t\t\t\tgoto out;\n\t\t\t\t*op = '?';\n\t\t\t\tres = 1;\n\t\t\t}\n\t\t\top += res;\n\t\t\tlen -= res;\n\t\t\tc0 = c1;\n\t\t\tip++;\n\t\t\tustrlen--;\n\t\t}\n\t\tce2 = hfsplus_compose_lookup(ce1, c0);\n\t\tif (ce2) {\n\t\t\ti = 1;\n\t\t\twhile (i < ustrlen) {\n\t\t\t\tce1 = hfsplus_compose_lookup(ce2,\n\t\t\t\t\tbe16_to_cpu(ip[i]));\n\t\t\t\tif (!ce1)\n\t\t\t\t\tbreak;\n\t\t\t\ti++;\n\t\t\t\tce2 = ce1;\n\t\t\t}\n\t\t\tcc = ce2[0];\n\t\t\tif (cc) {\n\t\t\t\tip += i;\n\t\t\t\tustrlen -= i;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\nsame:\n\t\tswitch (c0) {\n\t\tcase 0:\n\t\t\tcc = 0x2400;\n\t\t\tbreak;\n\t\tcase '/':\n\t\t\tcc = ':';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcc = c0;\n\t\t}\ndone:\n\t\tres = nls->uni2char(cc, op, len);\n\t\tif (res < 0) {\n\t\t\tif (res == -ENAMETOOLONG)\n\t\t\t\tgoto out;\n\t\t\t*op = '?';\n\t\t\tres = 1;\n\t\t}\n\t\top += res;\n\t\tlen -= res;\n\t}\n\tres = 0;\nout:\n\t*len_p = (char *)op - astr;\n\treturn res;\n}\n\n \nstatic inline int asc2unichar(struct super_block *sb, const char *astr, int len,\n\t\t\t      wchar_t *uc)\n{\n\tint size = HFSPLUS_SB(sb)->nls->char2uni(astr, len, uc);\n\tif (size <= 0) {\n\t\t*uc = '?';\n\t\tsize = 1;\n\t}\n\tswitch (*uc) {\n\tcase 0x2400:\n\t\t*uc = 0;\n\t\tbreak;\n\tcase ':':\n\t\t*uc = '/';\n\t\tbreak;\n\t}\n\treturn size;\n}\n\n \nstatic u16 *hfsplus_decompose_nonhangul(wchar_t uc, int *size)\n{\n\tint off;\n\n\toff = hfsplus_decompose_table[(uc >> 12) & 0xf];\n\tif (off == 0 || off == 0xffff)\n\t\treturn NULL;\n\n\toff = hfsplus_decompose_table[off + ((uc >> 8) & 0xf)];\n\tif (!off)\n\t\treturn NULL;\n\n\toff = hfsplus_decompose_table[off + ((uc >> 4) & 0xf)];\n\tif (!off)\n\t\treturn NULL;\n\n\toff = hfsplus_decompose_table[off + (uc & 0xf)];\n\t*size = off & 3;\n\tif (*size == 0)\n\t\treturn NULL;\n\treturn hfsplus_decompose_table + (off / 4);\n}\n\n \nstatic int hfsplus_try_decompose_hangul(wchar_t uc, u16 *result)\n{\n\tint index;\n\tint l, v, t;\n\n\tindex = uc - Hangul_SBase;\n\tif (index < 0 || index >= Hangul_SCount)\n\t\treturn 0;\n\n\tl = Hangul_LBase + index / Hangul_NCount;\n\tv = Hangul_VBase + (index % Hangul_NCount) / Hangul_TCount;\n\tt = Hangul_TBase + index % Hangul_TCount;\n\n\tresult[0] = l;\n\tresult[1] = v;\n\tif (t != Hangul_TBase) {\n\t\tresult[2] = t;\n\t\treturn 3;\n\t}\n\treturn 2;\n}\n\n \nstatic u16 *decompose_unichar(wchar_t uc, int *size, u16 *hangul_buffer)\n{\n\tu16 *result;\n\n\t \n\tresult = hangul_buffer;\n\t*size = hfsplus_try_decompose_hangul(uc, result);\n\tif (*size == 0)\n\t\tresult = hfsplus_decompose_nonhangul(uc, size);\n\treturn result;\n}\n\nint hfsplus_asc2uni(struct super_block *sb,\n\t\t    struct hfsplus_unistr *ustr, int max_unistr_len,\n\t\t    const char *astr, int len)\n{\n\tint size, dsize, decompose;\n\tu16 *dstr, outlen = 0;\n\twchar_t c;\n\tu16 dhangul[3];\n\n\tdecompose = !test_bit(HFSPLUS_SB_NODECOMPOSE, &HFSPLUS_SB(sb)->flags);\n\twhile (outlen < max_unistr_len && len > 0) {\n\t\tsize = asc2unichar(sb, astr, len, &c);\n\n\t\tif (decompose)\n\t\t\tdstr = decompose_unichar(c, &dsize, dhangul);\n\t\telse\n\t\t\tdstr = NULL;\n\t\tif (dstr) {\n\t\t\tif (outlen + dsize > max_unistr_len)\n\t\t\t\tbreak;\n\t\t\tdo {\n\t\t\t\tustr->unicode[outlen++] = cpu_to_be16(*dstr++);\n\t\t\t} while (--dsize > 0);\n\t\t} else\n\t\t\tustr->unicode[outlen++] = cpu_to_be16(c);\n\n\t\tastr += size;\n\t\tlen -= size;\n\t}\n\tustr->length = cpu_to_be16(outlen);\n\tif (len > 0)\n\t\treturn -ENAMETOOLONG;\n\treturn 0;\n}\n\n \nint hfsplus_hash_dentry(const struct dentry *dentry, struct qstr *str)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tconst char *astr;\n\tconst u16 *dstr;\n\tint casefold, decompose, size, len;\n\tunsigned long hash;\n\twchar_t c;\n\tu16 c2;\n\tu16 dhangul[3];\n\n\tcasefold = test_bit(HFSPLUS_SB_CASEFOLD, &HFSPLUS_SB(sb)->flags);\n\tdecompose = !test_bit(HFSPLUS_SB_NODECOMPOSE, &HFSPLUS_SB(sb)->flags);\n\thash = init_name_hash(dentry);\n\tastr = str->name;\n\tlen = str->len;\n\twhile (len > 0) {\n\t\tint dsize;\n\t\tsize = asc2unichar(sb, astr, len, &c);\n\t\tastr += size;\n\t\tlen -= size;\n\n\t\tif (decompose)\n\t\t\tdstr = decompose_unichar(c, &dsize, dhangul);\n\t\telse\n\t\t\tdstr = NULL;\n\t\tif (dstr) {\n\t\t\tdo {\n\t\t\t\tc2 = *dstr++;\n\t\t\t\tif (casefold)\n\t\t\t\t\tc2 = case_fold(c2);\n\t\t\t\tif (!casefold || c2)\n\t\t\t\t\thash = partial_name_hash(c2, hash);\n\t\t\t} while (--dsize > 0);\n\t\t} else {\n\t\t\tc2 = c;\n\t\t\tif (casefold)\n\t\t\t\tc2 = case_fold(c2);\n\t\t\tif (!casefold || c2)\n\t\t\t\thash = partial_name_hash(c2, hash);\n\t\t}\n\t}\n\tstr->hash = end_name_hash(hash);\n\n\treturn 0;\n}\n\n \nint hfsplus_compare_dentry(const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tint casefold, decompose, size;\n\tint dsize1, dsize2, len1, len2;\n\tconst u16 *dstr1, *dstr2;\n\tconst char *astr1, *astr2;\n\tu16 c1, c2;\n\twchar_t c;\n\tu16 dhangul_1[3], dhangul_2[3];\n\n\tcasefold = test_bit(HFSPLUS_SB_CASEFOLD, &HFSPLUS_SB(sb)->flags);\n\tdecompose = !test_bit(HFSPLUS_SB_NODECOMPOSE, &HFSPLUS_SB(sb)->flags);\n\tastr1 = str;\n\tlen1 = len;\n\tastr2 = name->name;\n\tlen2 = name->len;\n\tdsize1 = dsize2 = 0;\n\tdstr1 = dstr2 = NULL;\n\n\twhile (len1 > 0 && len2 > 0) {\n\t\tif (!dsize1) {\n\t\t\tsize = asc2unichar(sb, astr1, len1, &c);\n\t\t\tastr1 += size;\n\t\t\tlen1 -= size;\n\n\t\t\tif (decompose)\n\t\t\t\tdstr1 = decompose_unichar(c, &dsize1,\n\t\t\t\t\t\t\t  dhangul_1);\n\t\t\tif (!decompose || !dstr1) {\n\t\t\t\tc1 = c;\n\t\t\t\tdstr1 = &c1;\n\t\t\t\tdsize1 = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (!dsize2) {\n\t\t\tsize = asc2unichar(sb, astr2, len2, &c);\n\t\t\tastr2 += size;\n\t\t\tlen2 -= size;\n\n\t\t\tif (decompose)\n\t\t\t\tdstr2 = decompose_unichar(c, &dsize2,\n\t\t\t\t\t\t\t  dhangul_2);\n\t\t\tif (!decompose || !dstr2) {\n\t\t\t\tc2 = c;\n\t\t\t\tdstr2 = &c2;\n\t\t\t\tdsize2 = 1;\n\t\t\t}\n\t\t}\n\n\t\tc1 = *dstr1;\n\t\tc2 = *dstr2;\n\t\tif (casefold) {\n\t\t\tc1 = case_fold(c1);\n\t\t\tif (!c1) {\n\t\t\t\tdstr1++;\n\t\t\t\tdsize1--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tc2 = case_fold(c2);\n\t\t\tif (!c2) {\n\t\t\t\tdstr2++;\n\t\t\t\tdsize2--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (c1 < c2)\n\t\t\treturn -1;\n\t\telse if (c1 > c2)\n\t\t\treturn 1;\n\n\t\tdstr1++;\n\t\tdsize1--;\n\t\tdstr2++;\n\t\tdsize2--;\n\t}\n\n\tif (len1 < len2)\n\t\treturn -1;\n\tif (len1 > len2)\n\t\treturn 1;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}