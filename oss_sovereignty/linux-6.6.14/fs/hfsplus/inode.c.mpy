{
  "module_name": "inode.c",
  "hash_id": "08d223724e271f05acab51eb3b3b6fb404bd57efd336ea4f8396bd1488f128d9",
  "original_prompt": "Ingested from linux-6.6.14/fs/hfsplus/inode.c",
  "human_readable_source": "\n \n\n#include <linux/blkdev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/sched.h>\n#include <linux/cred.h>\n#include <linux/uio.h>\n#include <linux/fileattr.h>\n\n#include \"hfsplus_fs.h\"\n#include \"hfsplus_raw.h\"\n#include \"xattr.h\"\n\nstatic int hfsplus_read_folio(struct file *file, struct folio *folio)\n{\n\treturn block_read_full_folio(folio, hfsplus_get_block);\n}\n\nstatic int hfsplus_writepage(struct page *page, struct writeback_control *wbc)\n{\n\treturn block_write_full_page(page, hfsplus_get_block, wbc);\n}\n\nstatic void hfsplus_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\thfsplus_file_truncate(inode);\n\t}\n}\n\nint hfsplus_write_begin(struct file *file, struct address_space *mapping,\n\t\tloff_t pos, unsigned len, struct page **pagep, void **fsdata)\n{\n\tint ret;\n\n\t*pagep = NULL;\n\tret = cont_write_begin(file, mapping, pos, len, pagep, fsdata,\n\t\t\t\thfsplus_get_block,\n\t\t\t\t&HFSPLUS_I(mapping->host)->phys_size);\n\tif (unlikely(ret))\n\t\thfsplus_write_failed(mapping, pos + len);\n\n\treturn ret;\n}\n\nstatic sector_t hfsplus_bmap(struct address_space *mapping, sector_t block)\n{\n\treturn generic_block_bmap(mapping, block, hfsplus_get_block);\n}\n\nstatic bool hfsplus_release_folio(struct folio *folio, gfp_t mask)\n{\n\tstruct inode *inode = folio->mapping->host;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *node;\n\tu32 nidx;\n\tint i;\n\tbool res = true;\n\n\tswitch (inode->i_ino) {\n\tcase HFSPLUS_EXT_CNID:\n\t\ttree = HFSPLUS_SB(sb)->ext_tree;\n\t\tbreak;\n\tcase HFSPLUS_CAT_CNID:\n\t\ttree = HFSPLUS_SB(sb)->cat_tree;\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\ttree = HFSPLUS_SB(sb)->attr_tree;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\treturn false;\n\t}\n\tif (!tree)\n\t\treturn false;\n\tif (tree->node_size >= PAGE_SIZE) {\n\t\tnidx = folio->index >>\n\t\t\t(tree->node_size_shift - PAGE_SHIFT);\n\t\tspin_lock(&tree->hash_lock);\n\t\tnode = hfs_bnode_findhash(tree, nidx);\n\t\tif (!node)\n\t\t\t;\n\t\telse if (atomic_read(&node->refcnt))\n\t\t\tres = false;\n\t\tif (res && node) {\n\t\t\thfs_bnode_unhash(node);\n\t\t\thfs_bnode_free(node);\n\t\t}\n\t\tspin_unlock(&tree->hash_lock);\n\t} else {\n\t\tnidx = folio->index <<\n\t\t\t(PAGE_SHIFT - tree->node_size_shift);\n\t\ti = 1 << (PAGE_SHIFT - tree->node_size_shift);\n\t\tspin_lock(&tree->hash_lock);\n\t\tdo {\n\t\t\tnode = hfs_bnode_findhash(tree, nidx++);\n\t\t\tif (!node)\n\t\t\t\tcontinue;\n\t\t\tif (atomic_read(&node->refcnt)) {\n\t\t\t\tres = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\thfs_bnode_unhash(node);\n\t\t\thfs_bnode_free(node);\n\t\t} while (--i && nidx < tree->node_count);\n\t\tspin_unlock(&tree->hash_lock);\n\t}\n\treturn res ? try_to_free_buffers(folio) : false;\n}\n\nstatic ssize_t hfsplus_direct_IO(struct kiocb *iocb, struct iov_iter *iter)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tsize_t count = iov_iter_count(iter);\n\tssize_t ret;\n\n\tret = blockdev_direct_IO(iocb, inode, iter, hfsplus_get_block);\n\n\t \n\tif (unlikely(iov_iter_rw(iter) == WRITE && ret < 0)) {\n\t\tloff_t isize = i_size_read(inode);\n\t\tloff_t end = iocb->ki_pos + count;\n\n\t\tif (end > isize)\n\t\t\thfsplus_write_failed(mapping, end);\n\t}\n\n\treturn ret;\n}\n\nstatic int hfsplus_writepages(struct address_space *mapping,\n\t\t\t      struct writeback_control *wbc)\n{\n\treturn mpage_writepages(mapping, wbc, hfsplus_get_block);\n}\n\nconst struct address_space_operations hfsplus_btree_aops = {\n\t.dirty_folio\t= block_dirty_folio,\n\t.invalidate_folio = block_invalidate_folio,\n\t.read_folio\t= hfsplus_read_folio,\n\t.writepage\t= hfsplus_writepage,\n\t.write_begin\t= hfsplus_write_begin,\n\t.write_end\t= generic_write_end,\n\t.bmap\t\t= hfsplus_bmap,\n\t.release_folio\t= hfsplus_release_folio,\n};\n\nconst struct address_space_operations hfsplus_aops = {\n\t.dirty_folio\t= block_dirty_folio,\n\t.invalidate_folio = block_invalidate_folio,\n\t.read_folio\t= hfsplus_read_folio,\n\t.write_begin\t= hfsplus_write_begin,\n\t.write_end\t= generic_write_end,\n\t.bmap\t\t= hfsplus_bmap,\n\t.direct_IO\t= hfsplus_direct_IO,\n\t.writepages\t= hfsplus_writepages,\n\t.migrate_folio\t= buffer_migrate_folio,\n};\n\nconst struct dentry_operations hfsplus_dentry_operations = {\n\t.d_hash       = hfsplus_hash_dentry,\n\t.d_compare    = hfsplus_compare_dentry,\n};\n\nstatic void hfsplus_get_perms(struct inode *inode,\n\t\tstruct hfsplus_perm *perms, int dir)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(inode->i_sb);\n\tu16 mode;\n\n\tmode = be16_to_cpu(perms->mode);\n\n\ti_uid_write(inode, be32_to_cpu(perms->owner));\n\tif ((test_bit(HFSPLUS_SB_UID, &sbi->flags)) || (!i_uid_read(inode) && !mode))\n\t\tinode->i_uid = sbi->uid;\n\n\ti_gid_write(inode, be32_to_cpu(perms->group));\n\tif ((test_bit(HFSPLUS_SB_GID, &sbi->flags)) || (!i_gid_read(inode) && !mode))\n\t\tinode->i_gid = sbi->gid;\n\n\tif (dir) {\n\t\tmode = mode ? (mode & S_IALLUGO) : (S_IRWXUGO & ~(sbi->umask));\n\t\tmode |= S_IFDIR;\n\t} else if (!mode)\n\t\tmode = S_IFREG | ((S_IRUGO|S_IWUGO) & ~(sbi->umask));\n\tinode->i_mode = mode;\n\n\tHFSPLUS_I(inode)->userflags = perms->userflags;\n\tif (perms->rootflags & HFSPLUS_FLG_IMMUTABLE)\n\t\tinode->i_flags |= S_IMMUTABLE;\n\telse\n\t\tinode->i_flags &= ~S_IMMUTABLE;\n\tif (perms->rootflags & HFSPLUS_FLG_APPEND)\n\t\tinode->i_flags |= S_APPEND;\n\telse\n\t\tinode->i_flags &= ~S_APPEND;\n}\n\nstatic int hfsplus_file_open(struct inode *inode, struct file *file)\n{\n\tif (HFSPLUS_IS_RSRC(inode))\n\t\tinode = HFSPLUS_I(inode)->rsrc_inode;\n\tif (!(file->f_flags & O_LARGEFILE) && i_size_read(inode) > MAX_NON_LFS)\n\t\treturn -EOVERFLOW;\n\tatomic_inc(&HFSPLUS_I(inode)->opencnt);\n\treturn 0;\n}\n\nstatic int hfsplus_file_release(struct inode *inode, struct file *file)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (HFSPLUS_IS_RSRC(inode))\n\t\tinode = HFSPLUS_I(inode)->rsrc_inode;\n\tif (atomic_dec_and_test(&HFSPLUS_I(inode)->opencnt)) {\n\t\tinode_lock(inode);\n\t\thfsplus_file_truncate(inode);\n\t\tif (inode->i_flags & S_DEAD) {\n\t\t\thfsplus_delete_cat(inode->i_ino,\n\t\t\t\t\t   HFSPLUS_SB(sb)->hidden_dir, NULL);\n\t\t\thfsplus_delete_inode(inode);\n\t\t}\n\t\tinode_unlock(inode);\n\t}\n\treturn 0;\n}\n\nstatic int hfsplus_setattr(struct mnt_idmap *idmap,\n\t\t\t   struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tint error;\n\n\terror = setattr_prepare(&nop_mnt_idmap, dentry, attr);\n\tif (error)\n\t\treturn error;\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size != i_size_read(inode)) {\n\t\tinode_dio_wait(inode);\n\t\tif (attr->ia_size > inode->i_size) {\n\t\t\terror = generic_cont_expand_simple(inode,\n\t\t\t\t\t\t\t   attr->ia_size);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\ttruncate_setsize(inode, attr->ia_size);\n\t\thfsplus_file_truncate(inode);\n\t\tinode->i_mtime = inode_set_ctime_current(inode);\n\t}\n\n\tsetattr_copy(&nop_mnt_idmap, inode, attr);\n\tmark_inode_dirty(inode);\n\n\treturn 0;\n}\n\nint hfsplus_getattr(struct mnt_idmap *idmap, const struct path *path,\n\t\t    struct kstat *stat, u32 request_mask,\n\t\t    unsigned int query_flags)\n{\n\tstruct inode *inode = d_inode(path->dentry);\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\n\tif (request_mask & STATX_BTIME) {\n\t\tstat->result_mask |= STATX_BTIME;\n\t\tstat->btime = hfsp_mt2ut(hip->create_date);\n\t}\n\n\tif (inode->i_flags & S_APPEND)\n\t\tstat->attributes |= STATX_ATTR_APPEND;\n\tif (inode->i_flags & S_IMMUTABLE)\n\t\tstat->attributes |= STATX_ATTR_IMMUTABLE;\n\tif (hip->userflags & HFSPLUS_FLG_NODUMP)\n\t\tstat->attributes |= STATX_ATTR_NODUMP;\n\n\tstat->attributes_mask |= STATX_ATTR_APPEND | STATX_ATTR_IMMUTABLE |\n\t\t\t\t STATX_ATTR_NODUMP;\n\n\tgeneric_fillattr(&nop_mnt_idmap, request_mask, inode, stat);\n\treturn 0;\n}\n\nint hfsplus_file_fsync(struct file *file, loff_t start, loff_t end,\n\t\t       int datasync)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(inode->i_sb);\n\tint error = 0, error2;\n\n\terror = file_write_and_wait_range(file, start, end);\n\tif (error)\n\t\treturn error;\n\tinode_lock(inode);\n\n\t \n\tsync_inode_metadata(inode, 1);\n\n\t \n\tif (test_and_clear_bit(HFSPLUS_I_CAT_DIRTY, &hip->flags))\n\t\terror = filemap_write_and_wait(sbi->cat_tree->inode->i_mapping);\n\n\tif (test_and_clear_bit(HFSPLUS_I_EXT_DIRTY, &hip->flags)) {\n\t\terror2 =\n\t\t\tfilemap_write_and_wait(sbi->ext_tree->inode->i_mapping);\n\t\tif (!error)\n\t\t\terror = error2;\n\t}\n\n\tif (test_and_clear_bit(HFSPLUS_I_ATTR_DIRTY, &hip->flags)) {\n\t\tif (sbi->attr_tree) {\n\t\t\terror2 =\n\t\t\t\tfilemap_write_and_wait(\n\t\t\t\t\t    sbi->attr_tree->inode->i_mapping);\n\t\t\tif (!error)\n\t\t\t\terror = error2;\n\t\t} else {\n\t\t\tpr_err(\"sync non-existent attributes tree\\n\");\n\t\t}\n\t}\n\n\tif (test_and_clear_bit(HFSPLUS_I_ALLOC_DIRTY, &hip->flags)) {\n\t\terror2 = filemap_write_and_wait(sbi->alloc_file->i_mapping);\n\t\tif (!error)\n\t\t\terror = error2;\n\t}\n\n\tif (!test_bit(HFSPLUS_SB_NOBARRIER, &sbi->flags))\n\t\tblkdev_issue_flush(inode->i_sb->s_bdev);\n\n\tinode_unlock(inode);\n\n\treturn error;\n}\n\nstatic const struct inode_operations hfsplus_file_inode_operations = {\n\t.setattr\t= hfsplus_setattr,\n\t.getattr\t= hfsplus_getattr,\n\t.listxattr\t= hfsplus_listxattr,\n\t.fileattr_get\t= hfsplus_fileattr_get,\n\t.fileattr_set\t= hfsplus_fileattr_set,\n};\n\nstatic const struct file_operations hfsplus_file_operations = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read_iter\t= generic_file_read_iter,\n\t.write_iter\t= generic_file_write_iter,\n\t.mmap\t\t= generic_file_mmap,\n\t.splice_read\t= filemap_splice_read,\n\t.fsync\t\t= hfsplus_file_fsync,\n\t.open\t\t= hfsplus_file_open,\n\t.release\t= hfsplus_file_release,\n\t.unlocked_ioctl = hfsplus_ioctl,\n};\n\nstruct inode *hfsplus_new_inode(struct super_block *sb, struct inode *dir,\n\t\t\t\tumode_t mode)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tstruct inode *inode = new_inode(sb);\n\tstruct hfsplus_inode_info *hip;\n\n\tif (!inode)\n\t\treturn NULL;\n\n\tinode->i_ino = sbi->next_cnid++;\n\tinode_init_owner(&nop_mnt_idmap, inode, dir, mode);\n\tset_nlink(inode, 1);\n\tinode->i_mtime = inode->i_atime = inode_set_ctime_current(inode);\n\n\thip = HFSPLUS_I(inode);\n\tINIT_LIST_HEAD(&hip->open_dir_list);\n\tspin_lock_init(&hip->open_dir_lock);\n\tmutex_init(&hip->extents_lock);\n\tatomic_set(&hip->opencnt, 0);\n\thip->extent_state = 0;\n\thip->flags = 0;\n\thip->userflags = 0;\n\thip->subfolders = 0;\n\tmemset(hip->first_extents, 0, sizeof(hfsplus_extent_rec));\n\tmemset(hip->cached_extents, 0, sizeof(hfsplus_extent_rec));\n\thip->alloc_blocks = 0;\n\thip->first_blocks = 0;\n\thip->cached_start = 0;\n\thip->cached_blocks = 0;\n\thip->phys_size = 0;\n\thip->fs_blocks = 0;\n\thip->rsrc_inode = NULL;\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_size = 2;\n\t\tsbi->folder_count++;\n\t\tinode->i_op = &hfsplus_dir_inode_operations;\n\t\tinode->i_fop = &hfsplus_dir_operations;\n\t} else if (S_ISREG(inode->i_mode)) {\n\t\tsbi->file_count++;\n\t\tinode->i_op = &hfsplus_file_inode_operations;\n\t\tinode->i_fop = &hfsplus_file_operations;\n\t\tinode->i_mapping->a_ops = &hfsplus_aops;\n\t\thip->clump_blocks = sbi->data_clump_blocks;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tsbi->file_count++;\n\t\tinode->i_op = &page_symlink_inode_operations;\n\t\tinode_nohighmem(inode);\n\t\tinode->i_mapping->a_ops = &hfsplus_aops;\n\t\thip->clump_blocks = 1;\n\t} else\n\t\tsbi->file_count++;\n\tinsert_inode_hash(inode);\n\tmark_inode_dirty(inode);\n\thfsplus_mark_mdb_dirty(sb);\n\n\treturn inode;\n}\n\nvoid hfsplus_delete_inode(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tHFSPLUS_SB(sb)->folder_count--;\n\t\thfsplus_mark_mdb_dirty(sb);\n\t\treturn;\n\t}\n\tHFSPLUS_SB(sb)->file_count--;\n\tif (S_ISREG(inode->i_mode)) {\n\t\tif (!inode->i_nlink) {\n\t\t\tinode->i_size = 0;\n\t\t\thfsplus_file_truncate(inode);\n\t\t}\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_size = 0;\n\t\thfsplus_file_truncate(inode);\n\t}\n\thfsplus_mark_mdb_dirty(sb);\n}\n\nvoid hfsplus_inode_read_fork(struct inode *inode, struct hfsplus_fork_raw *fork)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tu32 count;\n\tint i;\n\n\tmemcpy(&hip->first_extents, &fork->extents, sizeof(hfsplus_extent_rec));\n\tfor (count = 0, i = 0; i < 8; i++)\n\t\tcount += be32_to_cpu(fork->extents[i].block_count);\n\thip->first_blocks = count;\n\tmemset(hip->cached_extents, 0, sizeof(hfsplus_extent_rec));\n\thip->cached_start = 0;\n\thip->cached_blocks = 0;\n\n\thip->alloc_blocks = be32_to_cpu(fork->total_blocks);\n\thip->phys_size = inode->i_size = be64_to_cpu(fork->total_size);\n\thip->fs_blocks =\n\t\t(inode->i_size + sb->s_blocksize - 1) >> sb->s_blocksize_bits;\n\tinode_set_bytes(inode, hip->fs_blocks << sb->s_blocksize_bits);\n\thip->clump_blocks =\n\t\tbe32_to_cpu(fork->clump_size) >> sbi->alloc_blksz_shift;\n\tif (!hip->clump_blocks) {\n\t\thip->clump_blocks = HFSPLUS_IS_RSRC(inode) ?\n\t\t\tsbi->rsrc_clump_blocks :\n\t\t\tsbi->data_clump_blocks;\n\t}\n}\n\nvoid hfsplus_inode_write_fork(struct inode *inode,\n\t\tstruct hfsplus_fork_raw *fork)\n{\n\tmemcpy(&fork->extents, &HFSPLUS_I(inode)->first_extents,\n\t       sizeof(hfsplus_extent_rec));\n\tfork->total_size = cpu_to_be64(inode->i_size);\n\tfork->total_blocks = cpu_to_be32(HFSPLUS_I(inode)->alloc_blocks);\n}\n\nint hfsplus_cat_read_inode(struct inode *inode, struct hfs_find_data *fd)\n{\n\thfsplus_cat_entry entry;\n\tint res = 0;\n\tu16 type;\n\n\ttype = hfs_bnode_read_u16(fd->bnode, fd->entryoffset);\n\n\tHFSPLUS_I(inode)->linkid = 0;\n\tif (type == HFSPLUS_FOLDER) {\n\t\tstruct hfsplus_cat_folder *folder = &entry.folder;\n\n\t\tif (fd->entrylength < sizeof(struct hfsplus_cat_folder)) {\n\t\t\tpr_err(\"bad catalog folder entry\\n\");\n\t\t\tres = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\thfs_bnode_read(fd->bnode, &entry, fd->entryoffset,\n\t\t\t\t\tsizeof(struct hfsplus_cat_folder));\n\t\thfsplus_get_perms(inode, &folder->permissions, 1);\n\t\tset_nlink(inode, 1);\n\t\tinode->i_size = 2 + be32_to_cpu(folder->valence);\n\t\tinode->i_atime = hfsp_mt2ut(folder->access_date);\n\t\tinode->i_mtime = hfsp_mt2ut(folder->content_mod_date);\n\t\tinode_set_ctime_to_ts(inode,\n\t\t\t\t      hfsp_mt2ut(folder->attribute_mod_date));\n\t\tHFSPLUS_I(inode)->create_date = folder->create_date;\n\t\tHFSPLUS_I(inode)->fs_blocks = 0;\n\t\tif (folder->flags & cpu_to_be16(HFSPLUS_HAS_FOLDER_COUNT)) {\n\t\t\tHFSPLUS_I(inode)->subfolders =\n\t\t\t\tbe32_to_cpu(folder->subfolders);\n\t\t}\n\t\tinode->i_op = &hfsplus_dir_inode_operations;\n\t\tinode->i_fop = &hfsplus_dir_operations;\n\t} else if (type == HFSPLUS_FILE) {\n\t\tstruct hfsplus_cat_file *file = &entry.file;\n\n\t\tif (fd->entrylength < sizeof(struct hfsplus_cat_file)) {\n\t\t\tpr_err(\"bad catalog file entry\\n\");\n\t\t\tres = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\thfs_bnode_read(fd->bnode, &entry, fd->entryoffset,\n\t\t\t\t\tsizeof(struct hfsplus_cat_file));\n\n\t\thfsplus_inode_read_fork(inode, HFSPLUS_IS_RSRC(inode) ?\n\t\t\t\t\t&file->rsrc_fork : &file->data_fork);\n\t\thfsplus_get_perms(inode, &file->permissions, 0);\n\t\tset_nlink(inode, 1);\n\t\tif (S_ISREG(inode->i_mode)) {\n\t\t\tif (file->permissions.dev)\n\t\t\t\tset_nlink(inode,\n\t\t\t\t\t  be32_to_cpu(file->permissions.dev));\n\t\t\tinode->i_op = &hfsplus_file_inode_operations;\n\t\t\tinode->i_fop = &hfsplus_file_operations;\n\t\t\tinode->i_mapping->a_ops = &hfsplus_aops;\n\t\t} else if (S_ISLNK(inode->i_mode)) {\n\t\t\tinode->i_op = &page_symlink_inode_operations;\n\t\t\tinode_nohighmem(inode);\n\t\t\tinode->i_mapping->a_ops = &hfsplus_aops;\n\t\t} else {\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t\t\t   be32_to_cpu(file->permissions.dev));\n\t\t}\n\t\tinode->i_atime = hfsp_mt2ut(file->access_date);\n\t\tinode->i_mtime = hfsp_mt2ut(file->content_mod_date);\n\t\tinode_set_ctime_to_ts(inode,\n\t\t\t\t      hfsp_mt2ut(file->attribute_mod_date));\n\t\tHFSPLUS_I(inode)->create_date = file->create_date;\n\t} else {\n\t\tpr_err(\"bad catalog entry used to create inode\\n\");\n\t\tres = -EIO;\n\t}\nout:\n\treturn res;\n}\n\nint hfsplus_cat_write_inode(struct inode *inode)\n{\n\tstruct inode *main_inode = inode;\n\tstruct hfs_find_data fd;\n\thfsplus_cat_entry entry;\n\tint res = 0;\n\n\tif (HFSPLUS_IS_RSRC(inode))\n\t\tmain_inode = HFSPLUS_I(inode)->rsrc_inode;\n\n\tif (!main_inode->i_nlink)\n\t\treturn 0;\n\n\tif (hfs_find_init(HFSPLUS_SB(main_inode->i_sb)->cat_tree, &fd))\n\t\t \n\t\treturn -EIO;\n\n\tif (hfsplus_find_cat(main_inode->i_sb, main_inode->i_ino, &fd))\n\t\t \n\t\tgoto out;\n\n\tif (S_ISDIR(main_inode->i_mode)) {\n\t\tstruct hfsplus_cat_folder *folder = &entry.folder;\n\n\t\tif (fd.entrylength < sizeof(struct hfsplus_cat_folder)) {\n\t\t\tpr_err(\"bad catalog folder entry\\n\");\n\t\t\tres = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\thfs_bnode_read(fd.bnode, &entry, fd.entryoffset,\n\t\t\t\t\tsizeof(struct hfsplus_cat_folder));\n\t\t \n\t\thfsplus_cat_set_perms(inode, &folder->permissions);\n\t\tfolder->access_date = hfsp_ut2mt(inode->i_atime);\n\t\tfolder->content_mod_date = hfsp_ut2mt(inode->i_mtime);\n\t\tfolder->attribute_mod_date = hfsp_ut2mt(inode_get_ctime(inode));\n\t\tfolder->valence = cpu_to_be32(inode->i_size - 2);\n\t\tif (folder->flags & cpu_to_be16(HFSPLUS_HAS_FOLDER_COUNT)) {\n\t\t\tfolder->subfolders =\n\t\t\t\tcpu_to_be32(HFSPLUS_I(inode)->subfolders);\n\t\t}\n\t\thfs_bnode_write(fd.bnode, &entry, fd.entryoffset,\n\t\t\t\t\t sizeof(struct hfsplus_cat_folder));\n\t} else if (HFSPLUS_IS_RSRC(inode)) {\n\t\tstruct hfsplus_cat_file *file = &entry.file;\n\t\thfs_bnode_read(fd.bnode, &entry, fd.entryoffset,\n\t\t\t       sizeof(struct hfsplus_cat_file));\n\t\thfsplus_inode_write_fork(inode, &file->rsrc_fork);\n\t\thfs_bnode_write(fd.bnode, &entry, fd.entryoffset,\n\t\t\t\tsizeof(struct hfsplus_cat_file));\n\t} else {\n\t\tstruct hfsplus_cat_file *file = &entry.file;\n\n\t\tif (fd.entrylength < sizeof(struct hfsplus_cat_file)) {\n\t\t\tpr_err(\"bad catalog file entry\\n\");\n\t\t\tres = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\thfs_bnode_read(fd.bnode, &entry, fd.entryoffset,\n\t\t\t\t\tsizeof(struct hfsplus_cat_file));\n\t\thfsplus_inode_write_fork(inode, &file->data_fork);\n\t\thfsplus_cat_set_perms(inode, &file->permissions);\n\t\tif (HFSPLUS_FLG_IMMUTABLE &\n\t\t\t\t(file->permissions.rootflags |\n\t\t\t\t\tfile->permissions.userflags))\n\t\t\tfile->flags |= cpu_to_be16(HFSPLUS_FILE_LOCKED);\n\t\telse\n\t\t\tfile->flags &= cpu_to_be16(~HFSPLUS_FILE_LOCKED);\n\t\tfile->access_date = hfsp_ut2mt(inode->i_atime);\n\t\tfile->content_mod_date = hfsp_ut2mt(inode->i_mtime);\n\t\tfile->attribute_mod_date = hfsp_ut2mt(inode_get_ctime(inode));\n\t\thfs_bnode_write(fd.bnode, &entry, fd.entryoffset,\n\t\t\t\t\t sizeof(struct hfsplus_cat_file));\n\t}\n\n\tset_bit(HFSPLUS_I_CAT_DIRTY, &HFSPLUS_I(inode)->flags);\nout:\n\thfs_find_exit(&fd);\n\treturn res;\n}\n\nint hfsplus_fileattr_get(struct dentry *dentry, struct fileattr *fa)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tunsigned int flags = 0;\n\n\tif (inode->i_flags & S_IMMUTABLE)\n\t\tflags |= FS_IMMUTABLE_FL;\n\tif (inode->i_flags & S_APPEND)\n\t\tflags |= FS_APPEND_FL;\n\tif (hip->userflags & HFSPLUS_FLG_NODUMP)\n\t\tflags |= FS_NODUMP_FL;\n\n\tfileattr_fill_flags(fa, flags);\n\n\treturn 0;\n}\n\nint hfsplus_fileattr_set(struct mnt_idmap *idmap,\n\t\t\t struct dentry *dentry, struct fileattr *fa)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tunsigned int new_fl = 0;\n\n\tif (fileattr_has_fsx(fa))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (fa->flags & ~(FS_IMMUTABLE_FL|FS_APPEND_FL|FS_NODUMP_FL))\n\t\treturn -EOPNOTSUPP;\n\n\tif (fa->flags & FS_IMMUTABLE_FL)\n\t\tnew_fl |= S_IMMUTABLE;\n\n\tif (fa->flags & FS_APPEND_FL)\n\t\tnew_fl |= S_APPEND;\n\n\tinode_set_flags(inode, new_fl, S_IMMUTABLE | S_APPEND);\n\n\tif (fa->flags & FS_NODUMP_FL)\n\t\thip->userflags |= HFSPLUS_FLG_NODUMP;\n\telse\n\t\thip->userflags &= ~HFSPLUS_FLG_NODUMP;\n\n\tinode_set_ctime_current(inode);\n\tmark_inode_dirty(inode);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}