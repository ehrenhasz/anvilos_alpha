{
  "module_name": "bnode.c",
  "hash_id": "38a940f5cb80b697ad59235548f4ee72baea41879e6cce1d3e5d922932b3befe",
  "original_prompt": "Ingested from linux-6.6.14/fs/hfsplus/bnode.c",
  "human_readable_source": "\n \n\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/swap.h>\n\n#include \"hfsplus_fs.h\"\n#include \"hfsplus_raw.h\"\n\n \nvoid hfs_bnode_read(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_SHIFT);\n\toff &= ~PAGE_MASK;\n\n\tl = min_t(int, len, PAGE_SIZE - off);\n\tmemcpy_from_page(buf, *pagep, off, l);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_SIZE);\n\t\tmemcpy_from_page(buf, *++pagep, 0, l);\n\t}\n}\n\nu16 hfs_bnode_read_u16(struct hfs_bnode *node, int off)\n{\n\t__be16 data;\n\t \n\thfs_bnode_read(node, &data, off, 2);\n\treturn be16_to_cpu(data);\n}\n\nu8 hfs_bnode_read_u8(struct hfs_bnode *node, int off)\n{\n\tu8 data;\n\t \n\thfs_bnode_read(node, &data, off, 1);\n\treturn data;\n}\n\nvoid hfs_bnode_read_key(struct hfs_bnode *node, void *key, int off)\n{\n\tstruct hfs_btree *tree;\n\tint key_len;\n\n\ttree = node->tree;\n\tif (node->type == HFS_NODE_LEAF ||\n\t    tree->attributes & HFS_TREE_VARIDXKEYS ||\n\t    node->tree->cnid == HFSPLUS_ATTR_CNID)\n\t\tkey_len = hfs_bnode_read_u16(node, off) + 2;\n\telse\n\t\tkey_len = tree->max_key_len + 2;\n\n\thfs_bnode_read(node, key, off, key_len);\n}\n\nvoid hfs_bnode_write(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_SHIFT);\n\toff &= ~PAGE_MASK;\n\n\tl = min_t(int, len, PAGE_SIZE - off);\n\tmemcpy_to_page(*pagep, off, buf, l);\n\tset_page_dirty(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_SIZE);\n\t\tmemcpy_to_page(*++pagep, 0, buf, l);\n\t\tset_page_dirty(*pagep);\n\t}\n}\n\nvoid hfs_bnode_write_u16(struct hfs_bnode *node, int off, u16 data)\n{\n\t__be16 v = cpu_to_be16(data);\n\t \n\thfs_bnode_write(node, &v, off, 2);\n}\n\nvoid hfs_bnode_clear(struct hfs_bnode *node, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_SHIFT);\n\toff &= ~PAGE_MASK;\n\n\tl = min_t(int, len, PAGE_SIZE - off);\n\tmemzero_page(*pagep, off, l);\n\tset_page_dirty(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tl = min_t(int, len, PAGE_SIZE);\n\t\tmemzero_page(*++pagep, 0, l);\n\t\tset_page_dirty(*pagep);\n\t}\n}\n\nvoid hfs_bnode_copy(struct hfs_bnode *dst_node, int dst,\n\t\t    struct hfs_bnode *src_node, int src, int len)\n{\n\tstruct page **src_page, **dst_page;\n\tint l;\n\n\thfs_dbg(BNODE_MOD, \"copybytes: %u,%u,%u\\n\", dst, src, len);\n\tif (!len)\n\t\treturn;\n\tsrc += src_node->page_offset;\n\tdst += dst_node->page_offset;\n\tsrc_page = src_node->page + (src >> PAGE_SHIFT);\n\tsrc &= ~PAGE_MASK;\n\tdst_page = dst_node->page + (dst >> PAGE_SHIFT);\n\tdst &= ~PAGE_MASK;\n\n\tif (src == dst) {\n\t\tl = min_t(int, len, PAGE_SIZE - src);\n\t\tmemcpy_page(*dst_page, src, *src_page, src, l);\n\t\tset_page_dirty(*dst_page);\n\n\t\twhile ((len -= l) != 0) {\n\t\t\tl = min_t(int, len, PAGE_SIZE);\n\t\t\tmemcpy_page(*++dst_page, 0, *++src_page, 0, l);\n\t\t\tset_page_dirty(*dst_page);\n\t\t}\n\t} else {\n\t\tvoid *src_ptr, *dst_ptr;\n\n\t\tdo {\n\t\t\tdst_ptr = kmap_local_page(*dst_page) + dst;\n\t\t\tsrc_ptr = kmap_local_page(*src_page) + src;\n\t\t\tif (PAGE_SIZE - src < PAGE_SIZE - dst) {\n\t\t\t\tl = PAGE_SIZE - src;\n\t\t\t\tsrc = 0;\n\t\t\t\tdst += l;\n\t\t\t} else {\n\t\t\t\tl = PAGE_SIZE - dst;\n\t\t\t\tsrc += l;\n\t\t\t\tdst = 0;\n\t\t\t}\n\t\t\tl = min(len, l);\n\t\t\tmemcpy(dst_ptr, src_ptr, l);\n\t\t\tkunmap_local(src_ptr);\n\t\t\tset_page_dirty(*dst_page);\n\t\t\tkunmap_local(dst_ptr);\n\t\t\tif (!dst)\n\t\t\t\tdst_page++;\n\t\t\telse\n\t\t\t\tsrc_page++;\n\t\t} while ((len -= l));\n\t}\n}\n\nvoid hfs_bnode_move(struct hfs_bnode *node, int dst, int src, int len)\n{\n\tstruct page **src_page, **dst_page;\n\tvoid *src_ptr, *dst_ptr;\n\tint l;\n\n\thfs_dbg(BNODE_MOD, \"movebytes: %u,%u,%u\\n\", dst, src, len);\n\tif (!len)\n\t\treturn;\n\tsrc += node->page_offset;\n\tdst += node->page_offset;\n\tif (dst > src) {\n\t\tsrc += len - 1;\n\t\tsrc_page = node->page + (src >> PAGE_SHIFT);\n\t\tsrc = (src & ~PAGE_MASK) + 1;\n\t\tdst += len - 1;\n\t\tdst_page = node->page + (dst >> PAGE_SHIFT);\n\t\tdst = (dst & ~PAGE_MASK) + 1;\n\n\t\tif (src == dst) {\n\t\t\twhile (src < len) {\n\t\t\t\tdst_ptr = kmap_local_page(*dst_page);\n\t\t\t\tsrc_ptr = kmap_local_page(*src_page);\n\t\t\t\tmemmove(dst_ptr, src_ptr, src);\n\t\t\t\tkunmap_local(src_ptr);\n\t\t\t\tset_page_dirty(*dst_page);\n\t\t\t\tkunmap_local(dst_ptr);\n\t\t\t\tlen -= src;\n\t\t\t\tsrc = PAGE_SIZE;\n\t\t\t\tsrc_page--;\n\t\t\t\tdst_page--;\n\t\t\t}\n\t\t\tsrc -= len;\n\t\t\tdst_ptr = kmap_local_page(*dst_page);\n\t\t\tsrc_ptr = kmap_local_page(*src_page);\n\t\t\tmemmove(dst_ptr + src, src_ptr + src, len);\n\t\t\tkunmap_local(src_ptr);\n\t\t\tset_page_dirty(*dst_page);\n\t\t\tkunmap_local(dst_ptr);\n\t\t} else {\n\t\t\tdo {\n\t\t\t\tdst_ptr = kmap_local_page(*dst_page) + dst;\n\t\t\t\tsrc_ptr = kmap_local_page(*src_page) + src;\n\t\t\t\tif (src < dst) {\n\t\t\t\t\tl = src;\n\t\t\t\t\tsrc = PAGE_SIZE;\n\t\t\t\t\tdst -= l;\n\t\t\t\t} else {\n\t\t\t\t\tl = dst;\n\t\t\t\t\tsrc -= l;\n\t\t\t\t\tdst = PAGE_SIZE;\n\t\t\t\t}\n\t\t\t\tl = min(len, l);\n\t\t\t\tmemmove(dst_ptr - l, src_ptr - l, l);\n\t\t\t\tkunmap_local(src_ptr);\n\t\t\t\tset_page_dirty(*dst_page);\n\t\t\t\tkunmap_local(dst_ptr);\n\t\t\t\tif (dst == PAGE_SIZE)\n\t\t\t\t\tdst_page--;\n\t\t\t\telse\n\t\t\t\t\tsrc_page--;\n\t\t\t} while ((len -= l));\n\t\t}\n\t} else {\n\t\tsrc_page = node->page + (src >> PAGE_SHIFT);\n\t\tsrc &= ~PAGE_MASK;\n\t\tdst_page = node->page + (dst >> PAGE_SHIFT);\n\t\tdst &= ~PAGE_MASK;\n\n\t\tif (src == dst) {\n\t\t\tl = min_t(int, len, PAGE_SIZE - src);\n\n\t\t\tdst_ptr = kmap_local_page(*dst_page) + src;\n\t\t\tsrc_ptr = kmap_local_page(*src_page) + src;\n\t\t\tmemmove(dst_ptr, src_ptr, l);\n\t\t\tkunmap_local(src_ptr);\n\t\t\tset_page_dirty(*dst_page);\n\t\t\tkunmap_local(dst_ptr);\n\n\t\t\twhile ((len -= l) != 0) {\n\t\t\t\tl = min_t(int, len, PAGE_SIZE);\n\t\t\t\tdst_ptr = kmap_local_page(*++dst_page);\n\t\t\t\tsrc_ptr = kmap_local_page(*++src_page);\n\t\t\t\tmemmove(dst_ptr, src_ptr, l);\n\t\t\t\tkunmap_local(src_ptr);\n\t\t\t\tset_page_dirty(*dst_page);\n\t\t\t\tkunmap_local(dst_ptr);\n\t\t\t}\n\t\t} else {\n\t\t\tdo {\n\t\t\t\tdst_ptr = kmap_local_page(*dst_page) + dst;\n\t\t\t\tsrc_ptr = kmap_local_page(*src_page) + src;\n\t\t\t\tif (PAGE_SIZE - src <\n\t\t\t\t\t\tPAGE_SIZE - dst) {\n\t\t\t\t\tl = PAGE_SIZE - src;\n\t\t\t\t\tsrc = 0;\n\t\t\t\t\tdst += l;\n\t\t\t\t} else {\n\t\t\t\t\tl = PAGE_SIZE - dst;\n\t\t\t\t\tsrc += l;\n\t\t\t\t\tdst = 0;\n\t\t\t\t}\n\t\t\t\tl = min(len, l);\n\t\t\t\tmemmove(dst_ptr, src_ptr, l);\n\t\t\t\tkunmap_local(src_ptr);\n\t\t\t\tset_page_dirty(*dst_page);\n\t\t\t\tkunmap_local(dst_ptr);\n\t\t\t\tif (!dst)\n\t\t\t\t\tdst_page++;\n\t\t\t\telse\n\t\t\t\t\tsrc_page++;\n\t\t\t} while ((len -= l));\n\t\t}\n\t}\n}\n\nvoid hfs_bnode_dump(struct hfs_bnode *node)\n{\n\tstruct hfs_bnode_desc desc;\n\t__be32 cnid;\n\tint i, off, key_off;\n\n\thfs_dbg(BNODE_MOD, \"bnode: %d\\n\", node->this);\n\thfs_bnode_read(node, &desc, 0, sizeof(desc));\n\thfs_dbg(BNODE_MOD, \"%d, %d, %d, %d, %d\\n\",\n\t\tbe32_to_cpu(desc.next), be32_to_cpu(desc.prev),\n\t\tdesc.type, desc.height, be16_to_cpu(desc.num_recs));\n\n\toff = node->tree->node_size - 2;\n\tfor (i = be16_to_cpu(desc.num_recs); i >= 0; off -= 2, i--) {\n\t\tkey_off = hfs_bnode_read_u16(node, off);\n\t\thfs_dbg(BNODE_MOD, \" %d\", key_off);\n\t\tif (i && node->type == HFS_NODE_INDEX) {\n\t\t\tint tmp;\n\n\t\t\tif (node->tree->attributes & HFS_TREE_VARIDXKEYS ||\n\t\t\t\t\tnode->tree->cnid == HFSPLUS_ATTR_CNID)\n\t\t\t\ttmp = hfs_bnode_read_u16(node, key_off) + 2;\n\t\t\telse\n\t\t\t\ttmp = node->tree->max_key_len + 2;\n\t\t\thfs_dbg_cont(BNODE_MOD, \" (%d\", tmp);\n\t\t\thfs_bnode_read(node, &cnid, key_off + tmp, 4);\n\t\t\thfs_dbg_cont(BNODE_MOD, \",%d)\", be32_to_cpu(cnid));\n\t\t} else if (i && node->type == HFS_NODE_LEAF) {\n\t\t\tint tmp;\n\n\t\t\ttmp = hfs_bnode_read_u16(node, key_off);\n\t\t\thfs_dbg_cont(BNODE_MOD, \" (%d)\", tmp);\n\t\t}\n\t}\n\thfs_dbg_cont(BNODE_MOD, \"\\n\");\n}\n\nvoid hfs_bnode_unlink(struct hfs_bnode *node)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *tmp;\n\t__be32 cnid;\n\n\ttree = node->tree;\n\tif (node->prev) {\n\t\ttmp = hfs_bnode_find(tree, node->prev);\n\t\tif (IS_ERR(tmp))\n\t\t\treturn;\n\t\ttmp->next = node->next;\n\t\tcnid = cpu_to_be32(tmp->next);\n\t\thfs_bnode_write(tmp, &cnid,\n\t\t\toffsetof(struct hfs_bnode_desc, next), 4);\n\t\thfs_bnode_put(tmp);\n\t} else if (node->type == HFS_NODE_LEAF)\n\t\ttree->leaf_head = node->next;\n\n\tif (node->next) {\n\t\ttmp = hfs_bnode_find(tree, node->next);\n\t\tif (IS_ERR(tmp))\n\t\t\treturn;\n\t\ttmp->prev = node->prev;\n\t\tcnid = cpu_to_be32(tmp->prev);\n\t\thfs_bnode_write(tmp, &cnid,\n\t\t\toffsetof(struct hfs_bnode_desc, prev), 4);\n\t\thfs_bnode_put(tmp);\n\t} else if (node->type == HFS_NODE_LEAF)\n\t\ttree->leaf_tail = node->prev;\n\n\t \n\tif (!node->prev && !node->next)\n\t\thfs_dbg(BNODE_MOD, \"hfs_btree_del_level\\n\");\n\tif (!node->parent) {\n\t\ttree->root = 0;\n\t\ttree->depth = 0;\n\t}\n\tset_bit(HFS_BNODE_DELETED, &node->flags);\n}\n\nstatic inline int hfs_bnode_hash(u32 num)\n{\n\tnum = (num >> 16) + num;\n\tnum += num >> 8;\n\treturn num & (NODE_HASH_SIZE - 1);\n}\n\nstruct hfs_bnode *hfs_bnode_findhash(struct hfs_btree *tree, u32 cnid)\n{\n\tstruct hfs_bnode *node;\n\n\tif (cnid >= tree->node_count) {\n\t\tpr_err(\"request for non-existent node %d in B*Tree\\n\",\n\t\t       cnid);\n\t\treturn NULL;\n\t}\n\n\tfor (node = tree->node_hash[hfs_bnode_hash(cnid)];\n\t\t\tnode; node = node->next_hash)\n\t\tif (node->this == cnid)\n\t\t\treturn node;\n\treturn NULL;\n}\n\nstatic struct hfs_bnode *__hfs_bnode_create(struct hfs_btree *tree, u32 cnid)\n{\n\tstruct hfs_bnode *node, *node2;\n\tstruct address_space *mapping;\n\tstruct page *page;\n\tint size, block, i, hash;\n\tloff_t off;\n\n\tif (cnid >= tree->node_count) {\n\t\tpr_err(\"request for non-existent node %d in B*Tree\\n\",\n\t\t       cnid);\n\t\treturn NULL;\n\t}\n\n\tsize = sizeof(struct hfs_bnode) + tree->pages_per_bnode *\n\t\tsizeof(struct page *);\n\tnode = kzalloc(size, GFP_KERNEL);\n\tif (!node)\n\t\treturn NULL;\n\tnode->tree = tree;\n\tnode->this = cnid;\n\tset_bit(HFS_BNODE_NEW, &node->flags);\n\tatomic_set(&node->refcnt, 1);\n\thfs_dbg(BNODE_REFS, \"new_node(%d:%d): 1\\n\",\n\t\tnode->tree->cnid, node->this);\n\tinit_waitqueue_head(&node->lock_wq);\n\tspin_lock(&tree->hash_lock);\n\tnode2 = hfs_bnode_findhash(tree, cnid);\n\tif (!node2) {\n\t\thash = hfs_bnode_hash(cnid);\n\t\tnode->next_hash = tree->node_hash[hash];\n\t\ttree->node_hash[hash] = node;\n\t\ttree->node_hash_cnt++;\n\t} else {\n\t\tspin_unlock(&tree->hash_lock);\n\t\tkfree(node);\n\t\twait_event(node2->lock_wq,\n\t\t\t!test_bit(HFS_BNODE_NEW, &node2->flags));\n\t\treturn node2;\n\t}\n\tspin_unlock(&tree->hash_lock);\n\n\tmapping = tree->inode->i_mapping;\n\toff = (loff_t)cnid << tree->node_size_shift;\n\tblock = off >> PAGE_SHIFT;\n\tnode->page_offset = off & ~PAGE_MASK;\n\tfor (i = 0; i < tree->pages_per_bnode; block++, i++) {\n\t\tpage = read_mapping_page(mapping, block, NULL);\n\t\tif (IS_ERR(page))\n\t\t\tgoto fail;\n\t\tnode->page[i] = page;\n\t}\n\n\treturn node;\nfail:\n\tset_bit(HFS_BNODE_ERROR, &node->flags);\n\treturn node;\n}\n\nvoid hfs_bnode_unhash(struct hfs_bnode *node)\n{\n\tstruct hfs_bnode **p;\n\n\thfs_dbg(BNODE_REFS, \"remove_node(%d:%d): %d\\n\",\n\t\tnode->tree->cnid, node->this, atomic_read(&node->refcnt));\n\tfor (p = &node->tree->node_hash[hfs_bnode_hash(node->this)];\n\t     *p && *p != node; p = &(*p)->next_hash)\n\t\t;\n\tBUG_ON(!*p);\n\t*p = node->next_hash;\n\tnode->tree->node_hash_cnt--;\n}\n\n \nstruct hfs_bnode *hfs_bnode_find(struct hfs_btree *tree, u32 num)\n{\n\tstruct hfs_bnode *node;\n\tstruct hfs_bnode_desc *desc;\n\tint i, rec_off, off, next_off;\n\tint entry_size, key_size;\n\n\tspin_lock(&tree->hash_lock);\n\tnode = hfs_bnode_findhash(tree, num);\n\tif (node) {\n\t\thfs_bnode_get(node);\n\t\tspin_unlock(&tree->hash_lock);\n\t\twait_event(node->lock_wq,\n\t\t\t!test_bit(HFS_BNODE_NEW, &node->flags));\n\t\tif (test_bit(HFS_BNODE_ERROR, &node->flags))\n\t\t\tgoto node_error;\n\t\treturn node;\n\t}\n\tspin_unlock(&tree->hash_lock);\n\tnode = __hfs_bnode_create(tree, num);\n\tif (!node)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (test_bit(HFS_BNODE_ERROR, &node->flags))\n\t\tgoto node_error;\n\tif (!test_bit(HFS_BNODE_NEW, &node->flags))\n\t\treturn node;\n\n\tdesc = (struct hfs_bnode_desc *)(kmap_local_page(node->page[0]) +\n\t\t\t\t\t\t\t node->page_offset);\n\tnode->prev = be32_to_cpu(desc->prev);\n\tnode->next = be32_to_cpu(desc->next);\n\tnode->num_recs = be16_to_cpu(desc->num_recs);\n\tnode->type = desc->type;\n\tnode->height = desc->height;\n\tkunmap_local(desc);\n\n\tswitch (node->type) {\n\tcase HFS_NODE_HEADER:\n\tcase HFS_NODE_MAP:\n\t\tif (node->height != 0)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tcase HFS_NODE_LEAF:\n\t\tif (node->height != 1)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tcase HFS_NODE_INDEX:\n\t\tif (node->height <= 1 || node->height > tree->depth)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tdefault:\n\t\tgoto node_error;\n\t}\n\n\trec_off = tree->node_size - 2;\n\toff = hfs_bnode_read_u16(node, rec_off);\n\tif (off != sizeof(struct hfs_bnode_desc))\n\t\tgoto node_error;\n\tfor (i = 1; i <= node->num_recs; off = next_off, i++) {\n\t\trec_off -= 2;\n\t\tnext_off = hfs_bnode_read_u16(node, rec_off);\n\t\tif (next_off <= off ||\n\t\t    next_off > tree->node_size ||\n\t\t    next_off & 1)\n\t\t\tgoto node_error;\n\t\tentry_size = next_off - off;\n\t\tif (node->type != HFS_NODE_INDEX &&\n\t\t    node->type != HFS_NODE_LEAF)\n\t\t\tcontinue;\n\t\tkey_size = hfs_bnode_read_u16(node, off) + 2;\n\t\tif (key_size >= entry_size || key_size & 1)\n\t\t\tgoto node_error;\n\t}\n\tclear_bit(HFS_BNODE_NEW, &node->flags);\n\twake_up(&node->lock_wq);\n\treturn node;\n\nnode_error:\n\tset_bit(HFS_BNODE_ERROR, &node->flags);\n\tclear_bit(HFS_BNODE_NEW, &node->flags);\n\twake_up(&node->lock_wq);\n\thfs_bnode_put(node);\n\treturn ERR_PTR(-EIO);\n}\n\nvoid hfs_bnode_free(struct hfs_bnode *node)\n{\n\tint i;\n\n\tfor (i = 0; i < node->tree->pages_per_bnode; i++)\n\t\tif (node->page[i])\n\t\t\tput_page(node->page[i]);\n\tkfree(node);\n}\n\nstruct hfs_bnode *hfs_bnode_create(struct hfs_btree *tree, u32 num)\n{\n\tstruct hfs_bnode *node;\n\tstruct page **pagep;\n\tint i;\n\n\tspin_lock(&tree->hash_lock);\n\tnode = hfs_bnode_findhash(tree, num);\n\tspin_unlock(&tree->hash_lock);\n\tif (node) {\n\t\tpr_crit(\"new node %u already hashed?\\n\", num);\n\t\tWARN_ON(1);\n\t\treturn node;\n\t}\n\tnode = __hfs_bnode_create(tree, num);\n\tif (!node)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (test_bit(HFS_BNODE_ERROR, &node->flags)) {\n\t\thfs_bnode_put(node);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\tpagep = node->page;\n\tmemzero_page(*pagep, node->page_offset,\n\t\t     min_t(int, PAGE_SIZE, tree->node_size));\n\tset_page_dirty(*pagep);\n\tfor (i = 1; i < tree->pages_per_bnode; i++) {\n\t\tmemzero_page(*++pagep, 0, PAGE_SIZE);\n\t\tset_page_dirty(*pagep);\n\t}\n\tclear_bit(HFS_BNODE_NEW, &node->flags);\n\twake_up(&node->lock_wq);\n\n\treturn node;\n}\n\nvoid hfs_bnode_get(struct hfs_bnode *node)\n{\n\tif (node) {\n\t\tatomic_inc(&node->refcnt);\n\t\thfs_dbg(BNODE_REFS, \"get_node(%d:%d): %d\\n\",\n\t\t\tnode->tree->cnid, node->this,\n\t\t\tatomic_read(&node->refcnt));\n\t}\n}\n\n \nvoid hfs_bnode_put(struct hfs_bnode *node)\n{\n\tif (node) {\n\t\tstruct hfs_btree *tree = node->tree;\n\t\tint i;\n\n\t\thfs_dbg(BNODE_REFS, \"put_node(%d:%d): %d\\n\",\n\t\t\tnode->tree->cnid, node->this,\n\t\t\tatomic_read(&node->refcnt));\n\t\tBUG_ON(!atomic_read(&node->refcnt));\n\t\tif (!atomic_dec_and_lock(&node->refcnt, &tree->hash_lock))\n\t\t\treturn;\n\t\tfor (i = 0; i < tree->pages_per_bnode; i++) {\n\t\t\tif (!node->page[i])\n\t\t\t\tcontinue;\n\t\t\tmark_page_accessed(node->page[i]);\n\t\t}\n\n\t\tif (test_bit(HFS_BNODE_DELETED, &node->flags)) {\n\t\t\thfs_bnode_unhash(node);\n\t\t\tspin_unlock(&tree->hash_lock);\n\t\t\tif (hfs_bnode_need_zeroout(tree))\n\t\t\t\thfs_bnode_clear(node, 0, tree->node_size);\n\t\t\thfs_bmap_free(node);\n\t\t\thfs_bnode_free(node);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock(&tree->hash_lock);\n\t}\n}\n\n \nbool hfs_bnode_need_zeroout(struct hfs_btree *tree)\n{\n\tstruct super_block *sb = tree->inode->i_sb;\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tconst u32 volume_attr = be32_to_cpu(sbi->s_vhdr->attributes);\n\n\treturn tree->cnid == HFSPLUS_CAT_CNID &&\n\t\tvolume_attr & HFSPLUS_VOL_UNUSED_NODE_FIX;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}