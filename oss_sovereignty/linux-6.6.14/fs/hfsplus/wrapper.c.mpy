{
  "module_name": "wrapper.c",
  "hash_id": "5658c59b7f9307d03ffbc33c16936c8c71f3e3b568648d225af7f056f582bbdb",
  "original_prompt": "Ingested from linux-6.6.14/fs/hfsplus/wrapper.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/blkdev.h>\n#include <linux/cdrom.h>\n#include <asm/unaligned.h>\n\n#include \"hfsplus_fs.h\"\n#include \"hfsplus_raw.h\"\n\nstruct hfsplus_wd {\n\tu32 ablk_size;\n\tu16 ablk_start;\n\tu16 embed_start;\n\tu16 embed_count;\n};\n\n \nint hfsplus_submit_bio(struct super_block *sb, sector_t sector,\n\t\t       void *buf, void **data, blk_opf_t opf)\n{\n\tconst enum req_op op = opf & REQ_OP_MASK;\n\tstruct bio *bio;\n\tint ret = 0;\n\tu64 io_size;\n\tloff_t start;\n\tint offset;\n\n\t \n\tio_size = hfsplus_min_io_size(sb);\n\tstart = (loff_t)sector << HFSPLUS_SECTOR_SHIFT;\n\toffset = start & (io_size - 1);\n\tsector &= ~((io_size >> HFSPLUS_SECTOR_SHIFT) - 1);\n\n\tbio = bio_alloc(sb->s_bdev, 1, opf, GFP_NOIO);\n\tbio->bi_iter.bi_sector = sector;\n\n\tif (op != REQ_OP_WRITE && data)\n\t\t*data = (u8 *)buf + offset;\n\n\twhile (io_size > 0) {\n\t\tunsigned int page_offset = offset_in_page(buf);\n\t\tunsigned int len = min_t(unsigned int, PAGE_SIZE - page_offset,\n\t\t\t\t\t io_size);\n\n\t\tret = bio_add_page(bio, virt_to_page(buf), len, page_offset);\n\t\tif (ret != len) {\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tio_size -= len;\n\t\tbuf = (u8 *)buf + len;\n\t}\n\n\tret = submit_bio_wait(bio);\nout:\n\tbio_put(bio);\n\treturn ret < 0 ? ret : 0;\n}\n\nstatic int hfsplus_read_mdb(void *bufptr, struct hfsplus_wd *wd)\n{\n\tu32 extent;\n\tu16 attrib;\n\t__be16 sig;\n\n\tsig = *(__be16 *)(bufptr + HFSP_WRAPOFF_EMBEDSIG);\n\tif (sig != cpu_to_be16(HFSPLUS_VOLHEAD_SIG) &&\n\t    sig != cpu_to_be16(HFSPLUS_VOLHEAD_SIGX))\n\t\treturn 0;\n\n\tattrib = be16_to_cpu(*(__be16 *)(bufptr + HFSP_WRAPOFF_ATTRIB));\n\tif (!(attrib & HFSP_WRAP_ATTRIB_SLOCK) ||\n\t   !(attrib & HFSP_WRAP_ATTRIB_SPARED))\n\t\treturn 0;\n\n\twd->ablk_size =\n\t\tbe32_to_cpu(*(__be32 *)(bufptr + HFSP_WRAPOFF_ABLKSIZE));\n\tif (wd->ablk_size < HFSPLUS_SECTOR_SIZE)\n\t\treturn 0;\n\tif (wd->ablk_size % HFSPLUS_SECTOR_SIZE)\n\t\treturn 0;\n\twd->ablk_start =\n\t\tbe16_to_cpu(*(__be16 *)(bufptr + HFSP_WRAPOFF_ABLKSTART));\n\n\textent = get_unaligned_be32(bufptr + HFSP_WRAPOFF_EMBEDEXT);\n\twd->embed_start = (extent >> 16) & 0xFFFF;\n\twd->embed_count = extent & 0xFFFF;\n\n\treturn 1;\n}\n\nstatic int hfsplus_get_last_session(struct super_block *sb,\n\t\t\t\t    sector_t *start, sector_t *size)\n{\n\tstruct cdrom_device_info *cdi = disk_to_cdi(sb->s_bdev->bd_disk);\n\n\t \n\t*start = 0;\n\t*size = bdev_nr_sectors(sb->s_bdev);\n\n\tif (HFSPLUS_SB(sb)->session >= 0) {\n\t\tstruct cdrom_tocentry te;\n\n\t\tif (!cdi)\n\t\t\treturn -EINVAL;\n\n\t\tte.cdte_track = HFSPLUS_SB(sb)->session;\n\t\tte.cdte_format = CDROM_LBA;\n\t\tif (cdrom_read_tocentry(cdi, &te) ||\n\t\t    (te.cdte_ctrl & CDROM_DATA_TRACK) != 4) {\n\t\t\tpr_err(\"invalid session number or type of track\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*start = (sector_t)te.cdte_addr.lba << 2;\n\t} else if (cdi) {\n\t\tstruct cdrom_multisession ms_info;\n\n\t\tms_info.addr_format = CDROM_LBA;\n\t\tif (cdrom_multisession(cdi, &ms_info) == 0 && ms_info.xa_flag)\n\t\t\t*start = (sector_t)ms_info.addr.lba << 2;\n\t}\n\n\treturn 0;\n}\n\n \n \nint hfsplus_read_wrapper(struct super_block *sb)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tstruct hfsplus_wd wd;\n\tsector_t part_start, part_size;\n\tu32 blocksize;\n\tint error = 0;\n\n\terror = -EINVAL;\n\tblocksize = sb_min_blocksize(sb, HFSPLUS_SECTOR_SIZE);\n\tif (!blocksize)\n\t\tgoto out;\n\n\tif (hfsplus_get_last_session(sb, &part_start, &part_size))\n\t\tgoto out;\n\n\terror = -ENOMEM;\n\tsbi->s_vhdr_buf = kmalloc(hfsplus_min_io_size(sb), GFP_KERNEL);\n\tif (!sbi->s_vhdr_buf)\n\t\tgoto out;\n\tsbi->s_backup_vhdr_buf = kmalloc(hfsplus_min_io_size(sb), GFP_KERNEL);\n\tif (!sbi->s_backup_vhdr_buf)\n\t\tgoto out_free_vhdr;\n\nreread:\n\terror = hfsplus_submit_bio(sb, part_start + HFSPLUS_VOLHEAD_SECTOR,\n\t\t\t\t   sbi->s_vhdr_buf, (void **)&sbi->s_vhdr,\n\t\t\t\t   REQ_OP_READ);\n\tif (error)\n\t\tgoto out_free_backup_vhdr;\n\n\terror = -EINVAL;\n\tswitch (sbi->s_vhdr->signature) {\n\tcase cpu_to_be16(HFSPLUS_VOLHEAD_SIGX):\n\t\tset_bit(HFSPLUS_SB_HFSX, &sbi->flags);\n\t\tfallthrough;\n\tcase cpu_to_be16(HFSPLUS_VOLHEAD_SIG):\n\t\tbreak;\n\tcase cpu_to_be16(HFSP_WRAP_MAGIC):\n\t\tif (!hfsplus_read_mdb(sbi->s_vhdr, &wd))\n\t\t\tgoto out_free_backup_vhdr;\n\t\twd.ablk_size >>= HFSPLUS_SECTOR_SHIFT;\n\t\tpart_start += (sector_t)wd.ablk_start +\n\t\t\t       (sector_t)wd.embed_start * wd.ablk_size;\n\t\tpart_size = (sector_t)wd.embed_count * wd.ablk_size;\n\t\tgoto reread;\n\tdefault:\n\t\t \n\t\tif (hfs_part_find(sb, &part_start, &part_size))\n\t\t\tgoto out_free_backup_vhdr;\n\t\tgoto reread;\n\t}\n\n\terror = hfsplus_submit_bio(sb, part_start + part_size - 2,\n\t\t\t\t   sbi->s_backup_vhdr_buf,\n\t\t\t\t   (void **)&sbi->s_backup_vhdr, REQ_OP_READ);\n\tif (error)\n\t\tgoto out_free_backup_vhdr;\n\n\terror = -EINVAL;\n\tif (sbi->s_backup_vhdr->signature != sbi->s_vhdr->signature) {\n\t\tpr_warn(\"invalid secondary volume header\\n\");\n\t\tgoto out_free_backup_vhdr;\n\t}\n\n\tblocksize = be32_to_cpu(sbi->s_vhdr->blocksize);\n\n\t \n\tif (blocksize < HFSPLUS_SECTOR_SIZE || ((blocksize - 1) & blocksize))\n\t\tgoto out_free_backup_vhdr;\n\tsbi->alloc_blksz = blocksize;\n\tsbi->alloc_blksz_shift = ilog2(blocksize);\n\tblocksize = min_t(u32, sbi->alloc_blksz, PAGE_SIZE);\n\n\t \n\twhile (part_start & ((blocksize >> HFSPLUS_SECTOR_SHIFT) - 1))\n\t\tblocksize >>= 1;\n\n\tif (sb_set_blocksize(sb, blocksize) != blocksize) {\n\t\tpr_err(\"unable to set blocksize to %u!\\n\", blocksize);\n\t\tgoto out_free_backup_vhdr;\n\t}\n\n\tsbi->blockoffset =\n\t\tpart_start >> (sb->s_blocksize_bits - HFSPLUS_SECTOR_SHIFT);\n\tsbi->part_start = part_start;\n\tsbi->sect_count = part_size;\n\tsbi->fs_shift = sbi->alloc_blksz_shift - sb->s_blocksize_bits;\n\treturn 0;\n\nout_free_backup_vhdr:\n\tkfree(sbi->s_backup_vhdr_buf);\nout_free_vhdr:\n\tkfree(sbi->s_vhdr_buf);\nout:\n\treturn error;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}