{
  "module_name": "super.c",
  "hash_id": "efcb08edd2ff287216fc0ce0fac79fb5a7a80e52563984203d9024aa6416c73c",
  "original_prompt": "Ingested from linux-6.6.14/fs/hfsplus/super.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/nls.h>\n\nstatic struct inode *hfsplus_alloc_inode(struct super_block *sb);\nstatic void hfsplus_free_inode(struct inode *inode);\n\n#include \"hfsplus_fs.h\"\n#include \"xattr.h\"\n\nstatic int hfsplus_system_read_inode(struct inode *inode)\n{\n\tstruct hfsplus_vh *vhdr = HFSPLUS_SB(inode->i_sb)->s_vhdr;\n\n\tswitch (inode->i_ino) {\n\tcase HFSPLUS_EXT_CNID:\n\t\thfsplus_inode_read_fork(inode, &vhdr->ext_file);\n\t\tinode->i_mapping->a_ops = &hfsplus_btree_aops;\n\t\tbreak;\n\tcase HFSPLUS_CAT_CNID:\n\t\thfsplus_inode_read_fork(inode, &vhdr->cat_file);\n\t\tinode->i_mapping->a_ops = &hfsplus_btree_aops;\n\t\tbreak;\n\tcase HFSPLUS_ALLOC_CNID:\n\t\thfsplus_inode_read_fork(inode, &vhdr->alloc_file);\n\t\tinode->i_mapping->a_ops = &hfsplus_aops;\n\t\tbreak;\n\tcase HFSPLUS_START_CNID:\n\t\thfsplus_inode_read_fork(inode, &vhdr->start_file);\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\thfsplus_inode_read_fork(inode, &vhdr->attr_file);\n\t\tinode->i_mapping->a_ops = &hfsplus_btree_aops;\n\t\tbreak;\n\tdefault:\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstruct inode *hfsplus_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct hfs_find_data fd;\n\tstruct inode *inode;\n\tint err;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tINIT_LIST_HEAD(&HFSPLUS_I(inode)->open_dir_list);\n\tspin_lock_init(&HFSPLUS_I(inode)->open_dir_lock);\n\tmutex_init(&HFSPLUS_I(inode)->extents_lock);\n\tHFSPLUS_I(inode)->flags = 0;\n\tHFSPLUS_I(inode)->extent_state = 0;\n\tHFSPLUS_I(inode)->rsrc_inode = NULL;\n\tatomic_set(&HFSPLUS_I(inode)->opencnt, 0);\n\n\tif (inode->i_ino >= HFSPLUS_FIRSTUSER_CNID ||\n\t    inode->i_ino == HFSPLUS_ROOT_CNID) {\n\t\terr = hfs_find_init(HFSPLUS_SB(inode->i_sb)->cat_tree, &fd);\n\t\tif (!err) {\n\t\t\terr = hfsplus_find_cat(inode->i_sb, inode->i_ino, &fd);\n\t\t\tif (!err)\n\t\t\t\terr = hfsplus_cat_read_inode(inode, &fd);\n\t\t\thfs_find_exit(&fd);\n\t\t}\n\t} else {\n\t\terr = hfsplus_system_read_inode(inode);\n\t}\n\n\tif (err) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tunlock_new_inode(inode);\n\treturn inode;\n}\n\nstatic int hfsplus_system_write_inode(struct inode *inode)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(inode->i_sb);\n\tstruct hfsplus_vh *vhdr = sbi->s_vhdr;\n\tstruct hfsplus_fork_raw *fork;\n\tstruct hfs_btree *tree = NULL;\n\n\tswitch (inode->i_ino) {\n\tcase HFSPLUS_EXT_CNID:\n\t\tfork = &vhdr->ext_file;\n\t\ttree = sbi->ext_tree;\n\t\tbreak;\n\tcase HFSPLUS_CAT_CNID:\n\t\tfork = &vhdr->cat_file;\n\t\ttree = sbi->cat_tree;\n\t\tbreak;\n\tcase HFSPLUS_ALLOC_CNID:\n\t\tfork = &vhdr->alloc_file;\n\t\tbreak;\n\tcase HFSPLUS_START_CNID:\n\t\tfork = &vhdr->start_file;\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\tfork = &vhdr->attr_file;\n\t\ttree = sbi->attr_tree;\n\t\tbreak;\n\tdefault:\n\t\treturn -EIO;\n\t}\n\n\tif (fork->total_size != cpu_to_be64(inode->i_size)) {\n\t\tset_bit(HFSPLUS_SB_WRITEBACKUP, &sbi->flags);\n\t\thfsplus_mark_mdb_dirty(inode->i_sb);\n\t}\n\thfsplus_inode_write_fork(inode, fork);\n\tif (tree) {\n\t\tint err = hfs_btree_write(tree);\n\n\t\tif (err) {\n\t\t\tpr_err(\"b-tree write err: %d, ino %lu\\n\",\n\t\t\t       err, inode->i_ino);\n\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int hfsplus_write_inode(struct inode *inode,\n\t\tstruct writeback_control *wbc)\n{\n\tint err;\n\n\thfs_dbg(INODE, \"hfsplus_write_inode: %lu\\n\", inode->i_ino);\n\n\terr = hfsplus_ext_write_extent(inode);\n\tif (err)\n\t\treturn err;\n\n\tif (inode->i_ino >= HFSPLUS_FIRSTUSER_CNID ||\n\t    inode->i_ino == HFSPLUS_ROOT_CNID)\n\t\treturn hfsplus_cat_write_inode(inode);\n\telse\n\t\treturn hfsplus_system_write_inode(inode);\n}\n\nstatic void hfsplus_evict_inode(struct inode *inode)\n{\n\thfs_dbg(INODE, \"hfsplus_evict_inode: %lu\\n\", inode->i_ino);\n\ttruncate_inode_pages_final(&inode->i_data);\n\tclear_inode(inode);\n\tif (HFSPLUS_IS_RSRC(inode)) {\n\t\tHFSPLUS_I(HFSPLUS_I(inode)->rsrc_inode)->rsrc_inode = NULL;\n\t\tiput(HFSPLUS_I(inode)->rsrc_inode);\n\t}\n}\n\nstatic int hfsplus_sync_fs(struct super_block *sb, int wait)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tstruct hfsplus_vh *vhdr = sbi->s_vhdr;\n\tint write_backup = 0;\n\tint error, error2;\n\n\tif (!wait)\n\t\treturn 0;\n\n\thfs_dbg(SUPER, \"hfsplus_sync_fs\\n\");\n\n\t \n\terror = filemap_write_and_wait(sbi->cat_tree->inode->i_mapping);\n\terror2 = filemap_write_and_wait(sbi->ext_tree->inode->i_mapping);\n\tif (!error)\n\t\terror = error2;\n\tif (sbi->attr_tree) {\n\t\terror2 =\n\t\t    filemap_write_and_wait(sbi->attr_tree->inode->i_mapping);\n\t\tif (!error)\n\t\t\terror = error2;\n\t}\n\terror2 = filemap_write_and_wait(sbi->alloc_file->i_mapping);\n\tif (!error)\n\t\terror = error2;\n\n\tmutex_lock(&sbi->vh_mutex);\n\tmutex_lock(&sbi->alloc_mutex);\n\tvhdr->free_blocks = cpu_to_be32(sbi->free_blocks);\n\tvhdr->next_cnid = cpu_to_be32(sbi->next_cnid);\n\tvhdr->folder_count = cpu_to_be32(sbi->folder_count);\n\tvhdr->file_count = cpu_to_be32(sbi->file_count);\n\n\tif (test_and_clear_bit(HFSPLUS_SB_WRITEBACKUP, &sbi->flags)) {\n\t\tmemcpy(sbi->s_backup_vhdr, sbi->s_vhdr, sizeof(*sbi->s_vhdr));\n\t\twrite_backup = 1;\n\t}\n\n\terror2 = hfsplus_submit_bio(sb,\n\t\t\t\t   sbi->part_start + HFSPLUS_VOLHEAD_SECTOR,\n\t\t\t\t   sbi->s_vhdr_buf, NULL, REQ_OP_WRITE |\n\t\t\t\t   REQ_SYNC);\n\tif (!error)\n\t\terror = error2;\n\tif (!write_backup)\n\t\tgoto out;\n\n\terror2 = hfsplus_submit_bio(sb,\n\t\t\t\t  sbi->part_start + sbi->sect_count - 2,\n\t\t\t\t  sbi->s_backup_vhdr_buf, NULL, REQ_OP_WRITE |\n\t\t\t\t  REQ_SYNC);\n\tif (!error)\n\t\terror2 = error;\nout:\n\tmutex_unlock(&sbi->alloc_mutex);\n\tmutex_unlock(&sbi->vh_mutex);\n\n\tif (!test_bit(HFSPLUS_SB_NOBARRIER, &sbi->flags))\n\t\tblkdev_issue_flush(sb->s_bdev);\n\n\treturn error;\n}\n\nstatic void delayed_sync_fs(struct work_struct *work)\n{\n\tint err;\n\tstruct hfsplus_sb_info *sbi;\n\n\tsbi = container_of(work, struct hfsplus_sb_info, sync_work.work);\n\n\tspin_lock(&sbi->work_lock);\n\tsbi->work_queued = 0;\n\tspin_unlock(&sbi->work_lock);\n\n\terr = hfsplus_sync_fs(sbi->alloc_file->i_sb, 1);\n\tif (err)\n\t\tpr_err(\"delayed sync fs err %d\\n\", err);\n}\n\nvoid hfsplus_mark_mdb_dirty(struct super_block *sb)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tunsigned long delay;\n\n\tif (sb_rdonly(sb))\n\t\treturn;\n\n\tspin_lock(&sbi->work_lock);\n\tif (!sbi->work_queued) {\n\t\tdelay = msecs_to_jiffies(dirty_writeback_interval * 10);\n\t\tqueue_delayed_work(system_long_wq, &sbi->sync_work, delay);\n\t\tsbi->work_queued = 1;\n\t}\n\tspin_unlock(&sbi->work_lock);\n}\n\nstatic void hfsplus_put_super(struct super_block *sb)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\n\thfs_dbg(SUPER, \"hfsplus_put_super\\n\");\n\n\tcancel_delayed_work_sync(&sbi->sync_work);\n\n\tif (!sb_rdonly(sb) && sbi->s_vhdr) {\n\t\tstruct hfsplus_vh *vhdr = sbi->s_vhdr;\n\n\t\tvhdr->modify_date = hfsp_now2mt();\n\t\tvhdr->attributes |= cpu_to_be32(HFSPLUS_VOL_UNMNT);\n\t\tvhdr->attributes &= cpu_to_be32(~HFSPLUS_VOL_INCNSTNT);\n\n\t\thfsplus_sync_fs(sb, 1);\n\t}\n\n\tiput(sbi->alloc_file);\n\tiput(sbi->hidden_dir);\n\thfs_btree_close(sbi->attr_tree);\n\thfs_btree_close(sbi->cat_tree);\n\thfs_btree_close(sbi->ext_tree);\n\tkfree(sbi->s_vhdr_buf);\n\tkfree(sbi->s_backup_vhdr_buf);\n\tunload_nls(sbi->nls);\n\tkfree(sb->s_fs_info);\n\tsb->s_fs_info = NULL;\n}\n\nstatic int hfsplus_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tu64 id = huge_encode_dev(sb->s_bdev->bd_dev);\n\n\tbuf->f_type = HFSPLUS_SUPER_MAGIC;\n\tbuf->f_bsize = sb->s_blocksize;\n\tbuf->f_blocks = sbi->total_blocks << sbi->fs_shift;\n\tbuf->f_bfree = sbi->free_blocks << sbi->fs_shift;\n\tbuf->f_bavail = buf->f_bfree;\n\tbuf->f_files = 0xFFFFFFFF;\n\tbuf->f_ffree = 0xFFFFFFFF - sbi->next_cnid;\n\tbuf->f_fsid = u64_to_fsid(id);\n\tbuf->f_namelen = HFSPLUS_MAX_STRLEN;\n\n\treturn 0;\n}\n\nstatic int hfsplus_remount(struct super_block *sb, int *flags, char *data)\n{\n\tsync_filesystem(sb);\n\tif ((bool)(*flags & SB_RDONLY) == sb_rdonly(sb))\n\t\treturn 0;\n\tif (!(*flags & SB_RDONLY)) {\n\t\tstruct hfsplus_vh *vhdr = HFSPLUS_SB(sb)->s_vhdr;\n\t\tint force = 0;\n\n\t\tif (!hfsplus_parse_options_remount(data, &force))\n\t\t\treturn -EINVAL;\n\n\t\tif (!(vhdr->attributes & cpu_to_be32(HFSPLUS_VOL_UNMNT))) {\n\t\t\tpr_warn(\"filesystem was not cleanly unmounted, running fsck.hfsplus is recommended.  leaving read-only.\\n\");\n\t\t\tsb->s_flags |= SB_RDONLY;\n\t\t\t*flags |= SB_RDONLY;\n\t\t} else if (force) {\n\t\t\t \n\t\t} else if (vhdr->attributes &\n\t\t\t\tcpu_to_be32(HFSPLUS_VOL_SOFTLOCK)) {\n\t\t\tpr_warn(\"filesystem is marked locked, leaving read-only.\\n\");\n\t\t\tsb->s_flags |= SB_RDONLY;\n\t\t\t*flags |= SB_RDONLY;\n\t\t} else if (vhdr->attributes &\n\t\t\t\tcpu_to_be32(HFSPLUS_VOL_JOURNALED)) {\n\t\t\tpr_warn(\"filesystem is marked journaled, leaving read-only.\\n\");\n\t\t\tsb->s_flags |= SB_RDONLY;\n\t\t\t*flags |= SB_RDONLY;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic const struct super_operations hfsplus_sops = {\n\t.alloc_inode\t= hfsplus_alloc_inode,\n\t.free_inode\t= hfsplus_free_inode,\n\t.write_inode\t= hfsplus_write_inode,\n\t.evict_inode\t= hfsplus_evict_inode,\n\t.put_super\t= hfsplus_put_super,\n\t.sync_fs\t= hfsplus_sync_fs,\n\t.statfs\t\t= hfsplus_statfs,\n\t.remount_fs\t= hfsplus_remount,\n\t.show_options\t= hfsplus_show_options,\n};\n\nstatic int hfsplus_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct hfsplus_vh *vhdr;\n\tstruct hfsplus_sb_info *sbi;\n\thfsplus_cat_entry entry;\n\tstruct hfs_find_data fd;\n\tstruct inode *root, *inode;\n\tstruct qstr str;\n\tstruct nls_table *nls = NULL;\n\tu64 last_fs_block, last_fs_page;\n\tint err;\n\n\terr = -ENOMEM;\n\tsbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\tif (!sbi)\n\t\tgoto out;\n\n\tsb->s_fs_info = sbi;\n\tmutex_init(&sbi->alloc_mutex);\n\tmutex_init(&sbi->vh_mutex);\n\tspin_lock_init(&sbi->work_lock);\n\tINIT_DELAYED_WORK(&sbi->sync_work, delayed_sync_fs);\n\thfsplus_fill_defaults(sbi);\n\n\terr = -EINVAL;\n\tif (!hfsplus_parse_options(data, sbi)) {\n\t\tpr_err(\"unable to parse mount options\\n\");\n\t\tgoto out_unload_nls;\n\t}\n\n\t \n\tnls = sbi->nls;\n\tsbi->nls = load_nls(\"utf8\");\n\tif (!sbi->nls) {\n\t\tpr_err(\"unable to load nls for utf8\\n\");\n\t\tgoto out_unload_nls;\n\t}\n\n\t \n\tif (hfsplus_read_wrapper(sb)) {\n\t\tif (!silent)\n\t\t\tpr_warn(\"unable to find HFS+ superblock\\n\");\n\t\tgoto out_unload_nls;\n\t}\n\tvhdr = sbi->s_vhdr;\n\n\t \n\tsb->s_magic = HFSPLUS_VOLHEAD_SIG;\n\tif (be16_to_cpu(vhdr->version) < HFSPLUS_MIN_VERSION ||\n\t    be16_to_cpu(vhdr->version) > HFSPLUS_CURRENT_VERSION) {\n\t\tpr_err(\"wrong filesystem version\\n\");\n\t\tgoto out_free_vhdr;\n\t}\n\tsbi->total_blocks = be32_to_cpu(vhdr->total_blocks);\n\tsbi->free_blocks = be32_to_cpu(vhdr->free_blocks);\n\tsbi->next_cnid = be32_to_cpu(vhdr->next_cnid);\n\tsbi->file_count = be32_to_cpu(vhdr->file_count);\n\tsbi->folder_count = be32_to_cpu(vhdr->folder_count);\n\tsbi->data_clump_blocks =\n\t\tbe32_to_cpu(vhdr->data_clump_sz) >> sbi->alloc_blksz_shift;\n\tif (!sbi->data_clump_blocks)\n\t\tsbi->data_clump_blocks = 1;\n\tsbi->rsrc_clump_blocks =\n\t\tbe32_to_cpu(vhdr->rsrc_clump_sz) >> sbi->alloc_blksz_shift;\n\tif (!sbi->rsrc_clump_blocks)\n\t\tsbi->rsrc_clump_blocks = 1;\n\n\terr = -EFBIG;\n\tlast_fs_block = sbi->total_blocks - 1;\n\tlast_fs_page = (last_fs_block << sbi->alloc_blksz_shift) >>\n\t\t\tPAGE_SHIFT;\n\n\tif ((last_fs_block > (sector_t)(~0ULL) >> (sbi->alloc_blksz_shift - 9)) ||\n\t    (last_fs_page > (pgoff_t)(~0ULL))) {\n\t\tpr_err(\"filesystem size too large\\n\");\n\t\tgoto out_free_vhdr;\n\t}\n\n\t \n\tsb->s_op = &hfsplus_sops;\n\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\n\tif (!(vhdr->attributes & cpu_to_be32(HFSPLUS_VOL_UNMNT))) {\n\t\tpr_warn(\"Filesystem was not cleanly unmounted, running fsck.hfsplus is recommended.  mounting read-only.\\n\");\n\t\tsb->s_flags |= SB_RDONLY;\n\t} else if (test_and_clear_bit(HFSPLUS_SB_FORCE, &sbi->flags)) {\n\t\t \n\t} else if (vhdr->attributes & cpu_to_be32(HFSPLUS_VOL_SOFTLOCK)) {\n\t\tpr_warn(\"Filesystem is marked locked, mounting read-only.\\n\");\n\t\tsb->s_flags |= SB_RDONLY;\n\t} else if ((vhdr->attributes & cpu_to_be32(HFSPLUS_VOL_JOURNALED)) &&\n\t\t\t!sb_rdonly(sb)) {\n\t\tpr_warn(\"write access to a journaled filesystem is not supported, use the force option at your own risk, mounting read-only.\\n\");\n\t\tsb->s_flags |= SB_RDONLY;\n\t}\n\n\terr = -EINVAL;\n\n\t \n\tsbi->ext_tree = hfs_btree_open(sb, HFSPLUS_EXT_CNID);\n\tif (!sbi->ext_tree) {\n\t\tpr_err(\"failed to load extents file\\n\");\n\t\tgoto out_free_vhdr;\n\t}\n\tsbi->cat_tree = hfs_btree_open(sb, HFSPLUS_CAT_CNID);\n\tif (!sbi->cat_tree) {\n\t\tpr_err(\"failed to load catalog file\\n\");\n\t\tgoto out_close_ext_tree;\n\t}\n\tatomic_set(&sbi->attr_tree_state, HFSPLUS_EMPTY_ATTR_TREE);\n\tif (vhdr->attr_file.total_blocks != 0) {\n\t\tsbi->attr_tree = hfs_btree_open(sb, HFSPLUS_ATTR_CNID);\n\t\tif (!sbi->attr_tree) {\n\t\t\tpr_err(\"failed to load attributes file\\n\");\n\t\t\tgoto out_close_cat_tree;\n\t\t}\n\t\tatomic_set(&sbi->attr_tree_state, HFSPLUS_VALID_ATTR_TREE);\n\t}\n\tsb->s_xattr = hfsplus_xattr_handlers;\n\n\tinode = hfsplus_iget(sb, HFSPLUS_ALLOC_CNID);\n\tif (IS_ERR(inode)) {\n\t\tpr_err(\"failed to load allocation file\\n\");\n\t\terr = PTR_ERR(inode);\n\t\tgoto out_close_attr_tree;\n\t}\n\tsbi->alloc_file = inode;\n\n\t \n\troot = hfsplus_iget(sb, HFSPLUS_ROOT_CNID);\n\tif (IS_ERR(root)) {\n\t\tpr_err(\"failed to load root directory\\n\");\n\t\terr = PTR_ERR(root);\n\t\tgoto out_put_alloc_file;\n\t}\n\n\tsb->s_d_op = &hfsplus_dentry_operations;\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\terr = -ENOMEM;\n\t\tgoto out_put_alloc_file;\n\t}\n\n\tstr.len = sizeof(HFSP_HIDDENDIR_NAME) - 1;\n\tstr.name = HFSP_HIDDENDIR_NAME;\n\terr = hfs_find_init(sbi->cat_tree, &fd);\n\tif (err)\n\t\tgoto out_put_root;\n\terr = hfsplus_cat_build_key(sb, fd.search_key, HFSPLUS_ROOT_CNID, &str);\n\tif (unlikely(err < 0))\n\t\tgoto out_put_root;\n\tif (!hfs_brec_read(&fd, &entry, sizeof(entry))) {\n\t\thfs_find_exit(&fd);\n\t\tif (entry.type != cpu_to_be16(HFSPLUS_FOLDER)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_put_root;\n\t\t}\n\t\tinode = hfsplus_iget(sb, be32_to_cpu(entry.folder.id));\n\t\tif (IS_ERR(inode)) {\n\t\t\terr = PTR_ERR(inode);\n\t\t\tgoto out_put_root;\n\t\t}\n\t\tsbi->hidden_dir = inode;\n\t} else\n\t\thfs_find_exit(&fd);\n\n\tif (!sb_rdonly(sb)) {\n\t\t \n\t\tvhdr->last_mount_vers = cpu_to_be32(HFSP_MOUNT_VERSION);\n\t\tvhdr->modify_date = hfsp_now2mt();\n\t\tbe32_add_cpu(&vhdr->write_count, 1);\n\t\tvhdr->attributes &= cpu_to_be32(~HFSPLUS_VOL_UNMNT);\n\t\tvhdr->attributes |= cpu_to_be32(HFSPLUS_VOL_INCNSTNT);\n\t\thfsplus_sync_fs(sb, 1);\n\n\t\tif (!sbi->hidden_dir) {\n\t\t\tmutex_lock(&sbi->vh_mutex);\n\t\t\tsbi->hidden_dir = hfsplus_new_inode(sb, root, S_IFDIR);\n\t\t\tif (!sbi->hidden_dir) {\n\t\t\t\tmutex_unlock(&sbi->vh_mutex);\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out_put_root;\n\t\t\t}\n\t\t\terr = hfsplus_create_cat(sbi->hidden_dir->i_ino, root,\n\t\t\t\t\t\t &str, sbi->hidden_dir);\n\t\t\tif (err) {\n\t\t\t\tmutex_unlock(&sbi->vh_mutex);\n\t\t\t\tgoto out_put_hidden_dir;\n\t\t\t}\n\n\t\t\terr = hfsplus_init_security(sbi->hidden_dir,\n\t\t\t\t\t\t\troot, &str);\n\t\t\tif (err == -EOPNOTSUPP)\n\t\t\t\terr = 0;  \n\t\t\telse if (err) {\n\t\t\t\t \n\t\t\t\thfsplus_delete_cat(sbi->hidden_dir->i_ino,\n\t\t\t\t\t\t\troot, &str);\n\t\t\t\tmutex_unlock(&sbi->vh_mutex);\n\t\t\t\tgoto out_put_hidden_dir;\n\t\t\t}\n\n\t\t\tmutex_unlock(&sbi->vh_mutex);\n\t\t\thfsplus_mark_inode_dirty(sbi->hidden_dir,\n\t\t\t\t\t\t HFSPLUS_I_CAT_DIRTY);\n\t\t}\n\t}\n\n\tunload_nls(sbi->nls);\n\tsbi->nls = nls;\n\treturn 0;\n\nout_put_hidden_dir:\n\tcancel_delayed_work_sync(&sbi->sync_work);\n\tiput(sbi->hidden_dir);\nout_put_root:\n\tdput(sb->s_root);\n\tsb->s_root = NULL;\nout_put_alloc_file:\n\tiput(sbi->alloc_file);\nout_close_attr_tree:\n\thfs_btree_close(sbi->attr_tree);\nout_close_cat_tree:\n\thfs_btree_close(sbi->cat_tree);\nout_close_ext_tree:\n\thfs_btree_close(sbi->ext_tree);\nout_free_vhdr:\n\tkfree(sbi->s_vhdr_buf);\n\tkfree(sbi->s_backup_vhdr_buf);\nout_unload_nls:\n\tunload_nls(sbi->nls);\n\tunload_nls(nls);\n\tkfree(sbi);\nout:\n\treturn err;\n}\n\nMODULE_AUTHOR(\"Brad Boyer\");\nMODULE_DESCRIPTION(\"Extended Macintosh Filesystem\");\nMODULE_LICENSE(\"GPL\");\n\nstatic struct kmem_cache *hfsplus_inode_cachep;\n\nstatic struct inode *hfsplus_alloc_inode(struct super_block *sb)\n{\n\tstruct hfsplus_inode_info *i;\n\n\ti = alloc_inode_sb(sb, hfsplus_inode_cachep, GFP_KERNEL);\n\treturn i ? &i->vfs_inode : NULL;\n}\n\nstatic void hfsplus_free_inode(struct inode *inode)\n{\n\tkmem_cache_free(hfsplus_inode_cachep, HFSPLUS_I(inode));\n}\n\n#define HFSPLUS_INODE_SIZE\tsizeof(struct hfsplus_inode_info)\n\nstatic struct dentry *hfsplus_mount(struct file_system_type *fs_type,\n\t\t\t  int flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, hfsplus_fill_super);\n}\n\nstatic struct file_system_type hfsplus_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"hfsplus\",\n\t.mount\t\t= hfsplus_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\nMODULE_ALIAS_FS(\"hfsplus\");\n\nstatic void hfsplus_init_once(void *p)\n{\n\tstruct hfsplus_inode_info *i = p;\n\n\tinode_init_once(&i->vfs_inode);\n}\n\nstatic int __init init_hfsplus_fs(void)\n{\n\tint err;\n\n\thfsplus_inode_cachep = kmem_cache_create(\"hfsplus_icache\",\n\t\tHFSPLUS_INODE_SIZE, 0, SLAB_HWCACHE_ALIGN|SLAB_ACCOUNT,\n\t\thfsplus_init_once);\n\tif (!hfsplus_inode_cachep)\n\t\treturn -ENOMEM;\n\terr = hfsplus_create_attr_tree_cache();\n\tif (err)\n\t\tgoto destroy_inode_cache;\n\terr = register_filesystem(&hfsplus_fs_type);\n\tif (err)\n\t\tgoto destroy_attr_tree_cache;\n\treturn 0;\n\ndestroy_attr_tree_cache:\n\thfsplus_destroy_attr_tree_cache();\n\ndestroy_inode_cache:\n\tkmem_cache_destroy(hfsplus_inode_cachep);\n\n\treturn err;\n}\n\nstatic void __exit exit_hfsplus_fs(void)\n{\n\tunregister_filesystem(&hfsplus_fs_type);\n\n\t \n\trcu_barrier();\n\thfsplus_destroy_attr_tree_cache();\n\tkmem_cache_destroy(hfsplus_inode_cachep);\n}\n\nmodule_init(init_hfsplus_fs)\nmodule_exit(exit_hfsplus_fs)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}