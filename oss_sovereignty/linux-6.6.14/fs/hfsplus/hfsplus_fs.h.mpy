{
  "module_name": "hfsplus_fs.h",
  "hash_id": "b25406c20be3e557c29ca4b19f4586e3d6f59f1ed73897ac185704f5e4f5cd90",
  "original_prompt": "Ingested from linux-6.6.14/fs/hfsplus/hfsplus_fs.h",
  "human_readable_source": " \n \n\n#ifndef _LINUX_HFSPLUS_FS_H\n#define _LINUX_HFSPLUS_FS_H\n\n#ifdef pr_fmt\n#undef pr_fmt\n#endif\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include \"hfsplus_raw.h\"\n\n#define DBG_BNODE_REFS\t0x00000001\n#define DBG_BNODE_MOD\t0x00000002\n#define DBG_CAT_MOD\t0x00000004\n#define DBG_INODE\t0x00000008\n#define DBG_SUPER\t0x00000010\n#define DBG_EXTENT\t0x00000020\n#define DBG_BITMAP\t0x00000040\n#define DBG_ATTR_MOD\t0x00000080\n\n#if 0\n#define DBG_MASK\t(DBG_EXTENT|DBG_INODE|DBG_BNODE_MOD)\n#define DBG_MASK\t(DBG_BNODE_MOD|DBG_CAT_MOD|DBG_INODE)\n#define DBG_MASK\t(DBG_CAT_MOD|DBG_BNODE_REFS|DBG_INODE|DBG_EXTENT)\n#endif\n#define DBG_MASK\t(0)\n\n#define hfs_dbg(flg, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif (DBG_##flg & DBG_MASK)\t\t\t\t\\\n\t\tprintk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__);\t\\\n} while (0)\n\n#define hfs_dbg_cont(flg, fmt, ...)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif (DBG_##flg & DBG_MASK)\t\t\t\t\\\n\t\tpr_cont(fmt, ##__VA_ARGS__);\t\t\t\\\n} while (0)\n\n \n#define HFSPLUS_DEF_CR_TYPE    0x3F3F3F3F   \n\n#define HFSPLUS_TYPE_DATA 0x00\n#define HFSPLUS_TYPE_RSRC 0xFF\n\ntypedef int (*btree_keycmp)(const hfsplus_btree_key *,\n\t\tconst hfsplus_btree_key *);\n\n#define NODE_HASH_SIZE\t256\n\n \nenum hfsplus_btree_mutex_classes {\n\tCATALOG_BTREE_MUTEX,\n\tEXTENTS_BTREE_MUTEX,\n\tATTR_BTREE_MUTEX,\n};\n\n \nstruct hfs_btree {\n\tstruct super_block *sb;\n\tstruct inode *inode;\n\tbtree_keycmp keycmp;\n\n\tu32 cnid;\n\tu32 root;\n\tu32 leaf_count;\n\tu32 leaf_head;\n\tu32 leaf_tail;\n\tu32 node_count;\n\tu32 free_nodes;\n\tu32 attributes;\n\n\tunsigned int node_size;\n\tunsigned int node_size_shift;\n\tunsigned int max_key_len;\n\tunsigned int depth;\n\n\tstruct mutex tree_lock;\n\n\tunsigned int pages_per_bnode;\n\tspinlock_t hash_lock;\n\tstruct hfs_bnode *node_hash[NODE_HASH_SIZE];\n\tint node_hash_cnt;\n};\n\nstruct page;\n\n \nstruct hfs_bnode {\n\tstruct hfs_btree *tree;\n\n\tu32 prev;\n\tu32 this;\n\tu32 next;\n\tu32 parent;\n\n\tu16 num_recs;\n\tu8 type;\n\tu8 height;\n\n\tstruct hfs_bnode *next_hash;\n\tunsigned long flags;\n\twait_queue_head_t lock_wq;\n\tatomic_t refcnt;\n\tunsigned int page_offset;\n\tstruct page *page[];\n};\n\n#define HFS_BNODE_LOCK\t\t0\n#define HFS_BNODE_ERROR\t\t1\n#define HFS_BNODE_NEW\t\t2\n#define HFS_BNODE_DIRTY\t\t3\n#define HFS_BNODE_DELETED\t4\n\n \n#define HFSPLUS_EMPTY_ATTR_TREE\t\t0\n#define HFSPLUS_CREATING_ATTR_TREE\t1\n#define HFSPLUS_VALID_ATTR_TREE\t\t2\n#define HFSPLUS_FAILED_ATTR_TREE\t3\n\n \n\nstruct hfsplus_vh;\nstruct hfs_btree;\n\nstruct hfsplus_sb_info {\n\tvoid *s_vhdr_buf;\n\tstruct hfsplus_vh *s_vhdr;\n\tvoid *s_backup_vhdr_buf;\n\tstruct hfsplus_vh *s_backup_vhdr;\n\tstruct hfs_btree *ext_tree;\n\tstruct hfs_btree *cat_tree;\n\tstruct hfs_btree *attr_tree;\n\tatomic_t attr_tree_state;\n\tstruct inode *alloc_file;\n\tstruct inode *hidden_dir;\n\tstruct nls_table *nls;\n\n\t \n\tu32 blockoffset;\n\tsector_t part_start;\n\tsector_t sect_count;\n\tint fs_shift;\n\n\t \n\tu32 alloc_blksz;\n\tint alloc_blksz_shift;\n\tu32 total_blocks;\n\tu32 data_clump_blocks, rsrc_clump_blocks;\n\n\t \n\tu32 free_blocks;\n\tstruct mutex alloc_mutex;\n\n\t \n\tu32 next_cnid;\n\tu32 file_count;\n\tu32 folder_count;\n\tstruct mutex vh_mutex;\n\n\t \n\tu32 creator;\n\tu32 type;\n\n\tumode_t umask;\n\tkuid_t uid;\n\tkgid_t gid;\n\n\tint part, session;\n\tunsigned long flags;\n\n\tint work_queued;                \n\tstruct delayed_work sync_work;  \n\tspinlock_t work_lock;           \n};\n\n#define HFSPLUS_SB_WRITEBACKUP\t0\n#define HFSPLUS_SB_NODECOMPOSE\t1\n#define HFSPLUS_SB_FORCE\t2\n#define HFSPLUS_SB_HFSX\t\t3\n#define HFSPLUS_SB_CASEFOLD\t4\n#define HFSPLUS_SB_NOBARRIER\t5\n#define HFSPLUS_SB_UID\t\t6\n#define HFSPLUS_SB_GID\t\t7\n\nstatic inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}\n\n\nstruct hfsplus_inode_info {\n\tatomic_t opencnt;\n\n\t \n\tu32 first_blocks;\n\tu32 clump_blocks;\n\tu32 alloc_blocks;\n\tu32 cached_start;\n\tu32 cached_blocks;\n\thfsplus_extent_rec first_extents;\n\thfsplus_extent_rec cached_extents;\n\tunsigned int extent_state;\n\tstruct mutex extents_lock;\n\n\t \n\tstruct inode *rsrc_inode;\n\t__be32 create_date;\n\n\t \n\tu32 linkid;\n\n\t \n\tunsigned long flags;\n\n\t \n\tsector_t fs_blocks;\n\tu8 userflags;\t\t \n\tu32 subfolders;\t\t \n\tstruct list_head open_dir_list;\n\tspinlock_t open_dir_lock;\n\tloff_t phys_size;\n\n\tstruct inode vfs_inode;\n};\n\n#define HFSPLUS_EXT_DIRTY\t0x0001\n#define HFSPLUS_EXT_NEW\t\t0x0002\n\n#define HFSPLUS_I_RSRC\t\t0\t \n#define HFSPLUS_I_CAT_DIRTY\t1\t \n#define HFSPLUS_I_EXT_DIRTY\t2\t \n#define HFSPLUS_I_ALLOC_DIRTY\t3\t \n#define HFSPLUS_I_ATTR_DIRTY\t4\t \n\n#define HFSPLUS_IS_RSRC(inode) \\\n\ttest_bit(HFSPLUS_I_RSRC, &HFSPLUS_I(inode)->flags)\n\nstatic inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct hfsplus_inode_info, vfs_inode);\n}\n\n \nstatic inline void hfsplus_mark_inode_dirty(struct inode *inode,\n\t\tunsigned int flag)\n{\n\tset_bit(flag, &HFSPLUS_I(inode)->flags);\n\tmark_inode_dirty(inode);\n}\n\nstruct hfs_find_data {\n\t \n\thfsplus_btree_key *search_key;\n\thfsplus_btree_key *key;\n\t \n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *bnode;\n\t \n\tint record;\n\tint keyoffset, keylength;\n\tint entryoffset, entrylength;\n};\n\nstruct hfsplus_readdir_data {\n\tstruct list_head list;\n\tstruct file *file;\n\tstruct hfsplus_cat_key key;\n};\n\n \nstatic inline unsigned short hfsplus_min_io_size(struct super_block *sb)\n{\n\treturn max_t(unsigned short, bdev_logical_block_size(sb->s_bdev),\n\t\t     HFSPLUS_SECTOR_SIZE);\n}\n\n#define hfs_btree_open hfsplus_btree_open\n#define hfs_btree_close hfsplus_btree_close\n#define hfs_btree_write hfsplus_btree_write\n#define hfs_bmap_reserve hfsplus_bmap_reserve\n#define hfs_bmap_alloc hfsplus_bmap_alloc\n#define hfs_bmap_free hfsplus_bmap_free\n#define hfs_bnode_read hfsplus_bnode_read\n#define hfs_bnode_read_u16 hfsplus_bnode_read_u16\n#define hfs_bnode_read_u8 hfsplus_bnode_read_u8\n#define hfs_bnode_read_key hfsplus_bnode_read_key\n#define hfs_bnode_write hfsplus_bnode_write\n#define hfs_bnode_write_u16 hfsplus_bnode_write_u16\n#define hfs_bnode_clear hfsplus_bnode_clear\n#define hfs_bnode_copy hfsplus_bnode_copy\n#define hfs_bnode_move hfsplus_bnode_move\n#define hfs_bnode_dump hfsplus_bnode_dump\n#define hfs_bnode_unlink hfsplus_bnode_unlink\n#define hfs_bnode_findhash hfsplus_bnode_findhash\n#define hfs_bnode_find hfsplus_bnode_find\n#define hfs_bnode_unhash hfsplus_bnode_unhash\n#define hfs_bnode_free hfsplus_bnode_free\n#define hfs_bnode_create hfsplus_bnode_create\n#define hfs_bnode_get hfsplus_bnode_get\n#define hfs_bnode_put hfsplus_bnode_put\n#define hfs_brec_lenoff hfsplus_brec_lenoff\n#define hfs_brec_keylen hfsplus_brec_keylen\n#define hfs_brec_insert hfsplus_brec_insert\n#define hfs_brec_remove hfsplus_brec_remove\n#define hfs_find_init hfsplus_find_init\n#define hfs_find_exit hfsplus_find_exit\n#define __hfs_brec_find __hfsplus_brec_find\n#define hfs_brec_find hfsplus_brec_find\n#define hfs_brec_read hfsplus_brec_read\n#define hfs_brec_goto hfsplus_brec_goto\n#define hfs_part_find hfsplus_part_find\n\n \n#define HFSPLUS_IOC_BLESS _IO('h', 0x80)\n\ntypedef int (*search_strategy_t)(struct hfs_bnode *,\n\t\t\t\tstruct hfs_find_data *,\n\t\t\t\tint *, int *, int *);\n\n \n\n \nint __init hfsplus_create_attr_tree_cache(void);\nvoid hfsplus_destroy_attr_tree_cache(void);\nint hfsplus_attr_bin_cmp_key(const hfsplus_btree_key *k1,\n\t\t\t     const hfsplus_btree_key *k2);\nint hfsplus_attr_build_key(struct super_block *sb, hfsplus_btree_key *key,\n\t\t\t   u32 cnid, const char *name);\nhfsplus_attr_entry *hfsplus_alloc_attr_entry(void);\nvoid hfsplus_destroy_attr_entry(hfsplus_attr_entry *entry);\nint hfsplus_find_attr(struct super_block *sb, u32 cnid, const char *name,\n\t\t      struct hfs_find_data *fd);\nint hfsplus_attr_exists(struct inode *inode, const char *name);\nint hfsplus_create_attr(struct inode *inode, const char *name,\n\t\t\tconst void *value, size_t size);\nint hfsplus_delete_attr(struct inode *inode, const char *name);\nint hfsplus_delete_all_attrs(struct inode *dir, u32 cnid);\n\n \nint hfsplus_block_allocate(struct super_block *sb, u32 size, u32 offset,\n\t\t\t   u32 *max);\nint hfsplus_block_free(struct super_block *sb, u32 offset, u32 count);\n\n \nu32 hfsplus_calc_btree_clump_size(u32 block_size, u32 node_size, u64 sectors,\n\t\t\t\t  int file_id);\nstruct hfs_btree *hfs_btree_open(struct super_block *sb, u32 id);\nvoid hfs_btree_close(struct hfs_btree *tree);\nint hfs_btree_write(struct hfs_btree *tree);\nint hfs_bmap_reserve(struct hfs_btree *tree, int rsvd_nodes);\nstruct hfs_bnode *hfs_bmap_alloc(struct hfs_btree *tree);\nvoid hfs_bmap_free(struct hfs_bnode *node);\n\n \nvoid hfs_bnode_read(struct hfs_bnode *node, void *buf, int off, int len);\nu16 hfs_bnode_read_u16(struct hfs_bnode *node, int off);\nu8 hfs_bnode_read_u8(struct hfs_bnode *node, int off);\nvoid hfs_bnode_read_key(struct hfs_bnode *node, void *key, int off);\nvoid hfs_bnode_write(struct hfs_bnode *node, void *buf, int off, int len);\nvoid hfs_bnode_write_u16(struct hfs_bnode *node, int off, u16 data);\nvoid hfs_bnode_clear(struct hfs_bnode *node, int off, int len);\nvoid hfs_bnode_copy(struct hfs_bnode *dst_node, int dst,\n\t\t    struct hfs_bnode *src_node, int src, int len);\nvoid hfs_bnode_move(struct hfs_bnode *node, int dst, int src, int len);\nvoid hfs_bnode_dump(struct hfs_bnode *node);\nvoid hfs_bnode_unlink(struct hfs_bnode *node);\nstruct hfs_bnode *hfs_bnode_findhash(struct hfs_btree *tree, u32 cnid);\nvoid hfs_bnode_unhash(struct hfs_bnode *node);\nstruct hfs_bnode *hfs_bnode_find(struct hfs_btree *tree, u32 num);\nvoid hfs_bnode_free(struct hfs_bnode *node);\nstruct hfs_bnode *hfs_bnode_create(struct hfs_btree *tree, u32 num);\nvoid hfs_bnode_get(struct hfs_bnode *node);\nvoid hfs_bnode_put(struct hfs_bnode *node);\nbool hfs_bnode_need_zeroout(struct hfs_btree *tree);\n\n \nu16 hfs_brec_lenoff(struct hfs_bnode *node, u16 rec, u16 *off);\nu16 hfs_brec_keylen(struct hfs_bnode *node, u16 rec);\nint hfs_brec_insert(struct hfs_find_data *fd, void *entry, int entry_len);\nint hfs_brec_remove(struct hfs_find_data *fd);\n\n \nint hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd);\nvoid hfs_find_exit(struct hfs_find_data *fd);\nint hfs_find_1st_rec_by_cnid(struct hfs_bnode *bnode, struct hfs_find_data *fd,\n\t\t\t     int *begin, int *end, int *cur_rec);\nint hfs_find_rec_by_key(struct hfs_bnode *bnode, struct hfs_find_data *fd,\n\t\t\tint *begin, int *end, int *cur_rec);\nint __hfs_brec_find(struct hfs_bnode *bnode, struct hfs_find_data *fd,\n\t\t    search_strategy_t rec_found);\nint hfs_brec_find(struct hfs_find_data *fd, search_strategy_t do_key_compare);\nint hfs_brec_read(struct hfs_find_data *fd, void *rec, int rec_len);\nint hfs_brec_goto(struct hfs_find_data *fd, int cnt);\n\n \nint hfsplus_cat_case_cmp_key(const hfsplus_btree_key *k1,\n\t\t\t     const hfsplus_btree_key *k2);\nint hfsplus_cat_bin_cmp_key(const hfsplus_btree_key *k1,\n\t\t\t    const hfsplus_btree_key *k2);\nint hfsplus_cat_build_key(struct super_block *sb, hfsplus_btree_key *key,\n\t\t\t   u32 parent, const struct qstr *str);\nvoid hfsplus_cat_build_key_with_cnid(struct super_block *sb,\n\t\t\t\t     hfsplus_btree_key *key, u32 parent);\nvoid hfsplus_cat_set_perms(struct inode *inode, struct hfsplus_perm *perms);\nint hfsplus_find_cat(struct super_block *sb, u32 cnid,\n\t\t     struct hfs_find_data *fd);\nint hfsplus_create_cat(u32 cnid, struct inode *dir, const struct qstr *str,\n\t\t       struct inode *inode);\nint hfsplus_delete_cat(u32 cnid, struct inode *dir, const struct qstr *str);\nint hfsplus_rename_cat(u32 cnid, struct inode *src_dir, const struct qstr *src_name,\n\t\t       struct inode *dst_dir, const struct qstr *dst_name);\n\n \nextern const struct inode_operations hfsplus_dir_inode_operations;\nextern const struct file_operations hfsplus_dir_operations;\n\n \nint hfsplus_ext_cmp_key(const hfsplus_btree_key *k1,\n\t\t\tconst hfsplus_btree_key *k2);\nint hfsplus_ext_write_extent(struct inode *inode);\nint hfsplus_get_block(struct inode *inode, sector_t iblock,\n\t\t      struct buffer_head *bh_result, int create);\nint hfsplus_free_fork(struct super_block *sb, u32 cnid,\n\t\t      struct hfsplus_fork_raw *fork, int type);\nint hfsplus_file_extend(struct inode *inode, bool zeroout);\nvoid hfsplus_file_truncate(struct inode *inode);\n\n \nextern const struct address_space_operations hfsplus_aops;\nextern const struct address_space_operations hfsplus_btree_aops;\nextern const struct dentry_operations hfsplus_dentry_operations;\n\nint hfsplus_write_begin(struct file *file, struct address_space *mapping,\n\t\tloff_t pos, unsigned len, struct page **pagep, void **fsdata);\nstruct inode *hfsplus_new_inode(struct super_block *sb, struct inode *dir,\n\t\t\t\tumode_t mode);\nvoid hfsplus_delete_inode(struct inode *inode);\nvoid hfsplus_inode_read_fork(struct inode *inode,\n\t\t\t     struct hfsplus_fork_raw *fork);\nvoid hfsplus_inode_write_fork(struct inode *inode,\n\t\t\t      struct hfsplus_fork_raw *fork);\nint hfsplus_cat_read_inode(struct inode *inode, struct hfs_find_data *fd);\nint hfsplus_cat_write_inode(struct inode *inode);\nint hfsplus_getattr(struct mnt_idmap *idmap, const struct path *path,\n\t\t    struct kstat *stat, u32 request_mask,\n\t\t    unsigned int query_flags);\nint hfsplus_file_fsync(struct file *file, loff_t start, loff_t end,\n\t\t       int datasync);\nint hfsplus_fileattr_get(struct dentry *dentry, struct fileattr *fa);\nint hfsplus_fileattr_set(struct mnt_idmap *idmap,\n\t\t\t struct dentry *dentry, struct fileattr *fa);\n\n \nlong hfsplus_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);\n\n \nvoid hfsplus_fill_defaults(struct hfsplus_sb_info *opts);\nint hfsplus_parse_options_remount(char *input, int *force);\nint hfsplus_parse_options(char *input, struct hfsplus_sb_info *sbi);\nint hfsplus_show_options(struct seq_file *seq, struct dentry *root);\n\n \nint hfs_part_find(struct super_block *sb, sector_t *part_start,\n\t\t  sector_t *part_size);\n\n \nstruct inode *hfsplus_iget(struct super_block *sb, unsigned long ino);\nvoid hfsplus_mark_mdb_dirty(struct super_block *sb);\n\n \nextern u16 hfsplus_case_fold_table[];\nextern u16 hfsplus_decompose_table[];\nextern u16 hfsplus_compose_table[];\n\n \nint hfsplus_strcasecmp(const struct hfsplus_unistr *s1,\n\t\t       const struct hfsplus_unistr *s2);\nint hfsplus_strcmp(const struct hfsplus_unistr *s1,\n\t\t   const struct hfsplus_unistr *s2);\nint hfsplus_uni2asc(struct super_block *sb, const struct hfsplus_unistr *ustr,\n\t\t    char *astr, int *len_p);\nint hfsplus_asc2uni(struct super_block *sb, struct hfsplus_unistr *ustr,\n\t\t    int max_unistr_len, const char *astr, int len);\nint hfsplus_hash_dentry(const struct dentry *dentry, struct qstr *str);\nint hfsplus_compare_dentry(const struct dentry *dentry, unsigned int len,\n\t\t\t   const char *str, const struct qstr *name);\n\n \nint hfsplus_submit_bio(struct super_block *sb, sector_t sector, void *buf,\n\t\t       void **data, blk_opf_t opf);\nint hfsplus_read_wrapper(struct super_block *sb);\n\n \n#define HFSPLUS_UTC_OFFSET 2082844800U\n\nstatic inline time64_t __hfsp_mt2ut(__be32 mt)\n{\n\ttime64_t ut = (u32)(be32_to_cpu(mt) - HFSPLUS_UTC_OFFSET);\n\n\treturn ut;\n}\n\nstatic inline __be32 __hfsp_ut2mt(time64_t ut)\n{\n\treturn cpu_to_be32(lower_32_bits(ut) + HFSPLUS_UTC_OFFSET);\n}\n\n \n#define hfsp_mt2ut(t)\t\t(struct timespec64){ .tv_sec = __hfsp_mt2ut(t) }\n#define hfsp_ut2mt(t)\t\t__hfsp_ut2mt((t).tv_sec)\n#define hfsp_now2mt()\t\t__hfsp_ut2mt(ktime_get_real_seconds())\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}