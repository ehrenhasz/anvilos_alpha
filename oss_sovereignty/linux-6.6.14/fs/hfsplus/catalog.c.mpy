{
  "module_name": "catalog.c",
  "hash_id": "3bf85233ec224fb3f4c6e85c5ff207d7c4ab1c308947f28633914e2da348e959",
  "original_prompt": "Ingested from linux-6.6.14/fs/hfsplus/catalog.c",
  "human_readable_source": "\n \n\n\n#include \"hfsplus_fs.h\"\n#include \"hfsplus_raw.h\"\n\nint hfsplus_cat_case_cmp_key(const hfsplus_btree_key *k1,\n\t\t\t     const hfsplus_btree_key *k2)\n{\n\t__be32 k1p, k2p;\n\n\tk1p = k1->cat.parent;\n\tk2p = k2->cat.parent;\n\tif (k1p != k2p)\n\t\treturn be32_to_cpu(k1p) < be32_to_cpu(k2p) ? -1 : 1;\n\n\treturn hfsplus_strcasecmp(&k1->cat.name, &k2->cat.name);\n}\n\nint hfsplus_cat_bin_cmp_key(const hfsplus_btree_key *k1,\n\t\t\t    const hfsplus_btree_key *k2)\n{\n\t__be32 k1p, k2p;\n\n\tk1p = k1->cat.parent;\n\tk2p = k2->cat.parent;\n\tif (k1p != k2p)\n\t\treturn be32_to_cpu(k1p) < be32_to_cpu(k2p) ? -1 : 1;\n\n\treturn hfsplus_strcmp(&k1->cat.name, &k2->cat.name);\n}\n\n \nint hfsplus_cat_build_key(struct super_block *sb,\n\t\thfsplus_btree_key *key, u32 parent, const struct qstr *str)\n{\n\tint len, err;\n\n\tkey->cat.parent = cpu_to_be32(parent);\n\terr = hfsplus_asc2uni(sb, &key->cat.name, HFSPLUS_MAX_STRLEN,\n\t\t\tstr->name, str->len);\n\tif (unlikely(err < 0))\n\t\treturn err;\n\n\tlen = be16_to_cpu(key->cat.name.length);\n\tkey->key_len = cpu_to_be16(6 + 2 * len);\n\treturn 0;\n}\n\n \nvoid hfsplus_cat_build_key_with_cnid(struct super_block *sb,\n\t\t\thfsplus_btree_key *key, u32 parent)\n{\n\tkey->cat.parent = cpu_to_be32(parent);\n\tkey->cat.name.length = 0;\n\tkey->key_len = cpu_to_be16(6);\n}\n\nstatic void hfsplus_cat_build_key_uni(hfsplus_btree_key *key, u32 parent,\n\t\t\t\t      struct hfsplus_unistr *name)\n{\n\tint ustrlen;\n\n\tustrlen = be16_to_cpu(name->length);\n\tkey->cat.parent = cpu_to_be32(parent);\n\tkey->cat.name.length = cpu_to_be16(ustrlen);\n\tustrlen *= 2;\n\tmemcpy(key->cat.name.unicode, name->unicode, ustrlen);\n\tkey->key_len = cpu_to_be16(6 + ustrlen);\n}\n\nvoid hfsplus_cat_set_perms(struct inode *inode, struct hfsplus_perm *perms)\n{\n\tif (inode->i_flags & S_IMMUTABLE)\n\t\tperms->rootflags |= HFSPLUS_FLG_IMMUTABLE;\n\telse\n\t\tperms->rootflags &= ~HFSPLUS_FLG_IMMUTABLE;\n\tif (inode->i_flags & S_APPEND)\n\t\tperms->rootflags |= HFSPLUS_FLG_APPEND;\n\telse\n\t\tperms->rootflags &= ~HFSPLUS_FLG_APPEND;\n\n\tperms->userflags = HFSPLUS_I(inode)->userflags;\n\tperms->mode = cpu_to_be16(inode->i_mode);\n\tperms->owner = cpu_to_be32(i_uid_read(inode));\n\tperms->group = cpu_to_be32(i_gid_read(inode));\n\n\tif (S_ISREG(inode->i_mode))\n\t\tperms->dev = cpu_to_be32(inode->i_nlink);\n\telse if (S_ISBLK(inode->i_mode) || S_ISCHR(inode->i_mode))\n\t\tperms->dev = cpu_to_be32(inode->i_rdev);\n\telse\n\t\tperms->dev = 0;\n}\n\nstatic int hfsplus_cat_build_record(hfsplus_cat_entry *entry,\n\t\tu32 cnid, struct inode *inode)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(inode->i_sb);\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct hfsplus_cat_folder *folder;\n\n\t\tfolder = &entry->folder;\n\t\tmemset(folder, 0, sizeof(*folder));\n\t\tfolder->type = cpu_to_be16(HFSPLUS_FOLDER);\n\t\tif (test_bit(HFSPLUS_SB_HFSX, &sbi->flags))\n\t\t\tfolder->flags |= cpu_to_be16(HFSPLUS_HAS_FOLDER_COUNT);\n\t\tfolder->id = cpu_to_be32(inode->i_ino);\n\t\tHFSPLUS_I(inode)->create_date =\n\t\t\tfolder->create_date =\n\t\t\tfolder->content_mod_date =\n\t\t\tfolder->attribute_mod_date =\n\t\t\tfolder->access_date = hfsp_now2mt();\n\t\thfsplus_cat_set_perms(inode, &folder->permissions);\n\t\tif (inode == sbi->hidden_dir)\n\t\t\t \n\t\t\tfolder->user_info.frFlags = cpu_to_be16(0x5000);\n\t\treturn sizeof(*folder);\n\t} else {\n\t\tstruct hfsplus_cat_file *file;\n\n\t\tfile = &entry->file;\n\t\tmemset(file, 0, sizeof(*file));\n\t\tfile->type = cpu_to_be16(HFSPLUS_FILE);\n\t\tfile->flags = cpu_to_be16(HFSPLUS_FILE_THREAD_EXISTS);\n\t\tfile->id = cpu_to_be32(cnid);\n\t\tHFSPLUS_I(inode)->create_date =\n\t\t\tfile->create_date =\n\t\t\tfile->content_mod_date =\n\t\t\tfile->attribute_mod_date =\n\t\t\tfile->access_date = hfsp_now2mt();\n\t\tif (cnid == inode->i_ino) {\n\t\t\thfsplus_cat_set_perms(inode, &file->permissions);\n\t\t\tif (S_ISLNK(inode->i_mode)) {\n\t\t\t\tfile->user_info.fdType =\n\t\t\t\t\tcpu_to_be32(HFSP_SYMLINK_TYPE);\n\t\t\t\tfile->user_info.fdCreator =\n\t\t\t\t\tcpu_to_be32(HFSP_SYMLINK_CREATOR);\n\t\t\t} else {\n\t\t\t\tfile->user_info.fdType =\n\t\t\t\t\tcpu_to_be32(sbi->type);\n\t\t\t\tfile->user_info.fdCreator =\n\t\t\t\t\tcpu_to_be32(sbi->creator);\n\t\t\t}\n\t\t\tif (HFSPLUS_FLG_IMMUTABLE &\n\t\t\t\t\t(file->permissions.rootflags |\n\t\t\t\t\tfile->permissions.userflags))\n\t\t\t\tfile->flags |=\n\t\t\t\t\tcpu_to_be16(HFSPLUS_FILE_LOCKED);\n\t\t} else {\n\t\t\tfile->user_info.fdType =\n\t\t\t\tcpu_to_be32(HFSP_HARDLINK_TYPE);\n\t\t\tfile->user_info.fdCreator =\n\t\t\t\tcpu_to_be32(HFSP_HFSPLUS_CREATOR);\n\t\t\tfile->user_info.fdFlags =\n\t\t\t\tcpu_to_be16(0x100);\n\t\t\tfile->create_date =\n\t\t\t\tHFSPLUS_I(sbi->hidden_dir)->create_date;\n\t\t\tfile->permissions.dev =\n\t\t\t\tcpu_to_be32(HFSPLUS_I(inode)->linkid);\n\t\t}\n\t\treturn sizeof(*file);\n\t}\n}\n\nstatic int hfsplus_fill_cat_thread(struct super_block *sb,\n\t\t\t\t   hfsplus_cat_entry *entry, int type,\n\t\t\t\t   u32 parentid, const struct qstr *str)\n{\n\tint err;\n\n\tentry->type = cpu_to_be16(type);\n\tentry->thread.reserved = 0;\n\tentry->thread.parentID = cpu_to_be32(parentid);\n\terr = hfsplus_asc2uni(sb, &entry->thread.nodeName, HFSPLUS_MAX_STRLEN,\n\t\t\t\tstr->name, str->len);\n\tif (unlikely(err < 0))\n\t\treturn err;\n\n\treturn 10 + be16_to_cpu(entry->thread.nodeName.length) * 2;\n}\n\n \nint hfsplus_find_cat(struct super_block *sb, u32 cnid,\n\t\t     struct hfs_find_data *fd)\n{\n\thfsplus_cat_entry tmp;\n\tint err;\n\tu16 type;\n\n\thfsplus_cat_build_key_with_cnid(sb, fd->search_key, cnid);\n\terr = hfs_brec_read(fd, &tmp, sizeof(hfsplus_cat_entry));\n\tif (err)\n\t\treturn err;\n\n\ttype = be16_to_cpu(tmp.type);\n\tif (type != HFSPLUS_FOLDER_THREAD && type != HFSPLUS_FILE_THREAD) {\n\t\tpr_err(\"found bad thread record in catalog\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (be16_to_cpu(tmp.thread.nodeName.length) > 255) {\n\t\tpr_err(\"catalog name length corrupted\\n\");\n\t\treturn -EIO;\n\t}\n\n\thfsplus_cat_build_key_uni(fd->search_key,\n\t\tbe32_to_cpu(tmp.thread.parentID),\n\t\t&tmp.thread.nodeName);\n\treturn hfs_brec_find(fd, hfs_find_rec_by_key);\n}\n\nstatic void hfsplus_subfolders_inc(struct inode *dir)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(dir->i_sb);\n\n\tif (test_bit(HFSPLUS_SB_HFSX, &sbi->flags)) {\n\t\t \n\t\tHFSPLUS_I(dir)->subfolders++;\n\t}\n}\n\nstatic void hfsplus_subfolders_dec(struct inode *dir)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(dir->i_sb);\n\n\tif (test_bit(HFSPLUS_SB_HFSX, &sbi->flags)) {\n\t\t \n\t\tif (HFSPLUS_I(dir)->subfolders)\n\t\t\tHFSPLUS_I(dir)->subfolders--;\n\t}\n}\n\nint hfsplus_create_cat(u32 cnid, struct inode *dir,\n\t\tconst struct qstr *str, struct inode *inode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct hfs_find_data fd;\n\thfsplus_cat_entry entry;\n\tint entry_size;\n\tint err;\n\n\thfs_dbg(CAT_MOD, \"create_cat: %s,%u(%d)\\n\",\n\t\tstr->name, cnid, inode->i_nlink);\n\terr = hfs_find_init(HFSPLUS_SB(sb)->cat_tree, &fd);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = hfs_bmap_reserve(fd.tree, 2 * fd.tree->depth);\n\tif (err)\n\t\tgoto err2;\n\n\thfsplus_cat_build_key_with_cnid(sb, fd.search_key, cnid);\n\tentry_size = hfsplus_fill_cat_thread(sb, &entry,\n\t\tS_ISDIR(inode->i_mode) ?\n\t\t\tHFSPLUS_FOLDER_THREAD : HFSPLUS_FILE_THREAD,\n\t\tdir->i_ino, str);\n\tif (unlikely(entry_size < 0)) {\n\t\terr = entry_size;\n\t\tgoto err2;\n\t}\n\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto err2;\n\t}\n\terr = hfs_brec_insert(&fd, &entry, entry_size);\n\tif (err)\n\t\tgoto err2;\n\n\terr = hfsplus_cat_build_key(sb, fd.search_key, dir->i_ino, str);\n\tif (unlikely(err))\n\t\tgoto err1;\n\n\tentry_size = hfsplus_cat_build_record(&entry, cnid, inode);\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err != -ENOENT) {\n\t\t \n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto err1;\n\t}\n\terr = hfs_brec_insert(&fd, &entry, entry_size);\n\tif (err)\n\t\tgoto err1;\n\n\tdir->i_size++;\n\tif (S_ISDIR(inode->i_mode))\n\t\thfsplus_subfolders_inc(dir);\n\tdir->i_mtime = inode_set_ctime_current(dir);\n\thfsplus_mark_inode_dirty(dir, HFSPLUS_I_CAT_DIRTY);\n\n\thfs_find_exit(&fd);\n\treturn 0;\n\nerr1:\n\thfsplus_cat_build_key_with_cnid(sb, fd.search_key, cnid);\n\tif (!hfs_brec_find(&fd, hfs_find_rec_by_key))\n\t\thfs_brec_remove(&fd);\nerr2:\n\thfs_find_exit(&fd);\n\treturn err;\n}\n\nint hfsplus_delete_cat(u32 cnid, struct inode *dir, const struct qstr *str)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct hfs_find_data fd;\n\tstruct hfsplus_fork_raw fork;\n\tstruct list_head *pos;\n\tint err, off;\n\tu16 type;\n\n\thfs_dbg(CAT_MOD, \"delete_cat: %s,%u\\n\", str ? str->name : NULL, cnid);\n\terr = hfs_find_init(HFSPLUS_SB(sb)->cat_tree, &fd);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = hfs_bmap_reserve(fd.tree, 2 * (int)fd.tree->depth - 2);\n\tif (err)\n\t\tgoto out;\n\n\tif (!str) {\n\t\tint len;\n\n\t\thfsplus_cat_build_key_with_cnid(sb, fd.search_key, cnid);\n\t\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\toff = fd.entryoffset +\n\t\t\toffsetof(struct hfsplus_cat_thread, nodeName);\n\t\tfd.search_key->cat.parent = cpu_to_be32(dir->i_ino);\n\t\thfs_bnode_read(fd.bnode,\n\t\t\t&fd.search_key->cat.name.length, off, 2);\n\t\tlen = be16_to_cpu(fd.search_key->cat.name.length) * 2;\n\t\thfs_bnode_read(fd.bnode,\n\t\t\t&fd.search_key->cat.name.unicode,\n\t\t\toff + 2, len);\n\t\tfd.search_key->key_len = cpu_to_be16(6 + len);\n\t} else {\n\t\terr = hfsplus_cat_build_key(sb, fd.search_key, dir->i_ino, str);\n\t\tif (unlikely(err))\n\t\t\tgoto out;\n\t}\n\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\n\ttype = hfs_bnode_read_u16(fd.bnode, fd.entryoffset);\n\tif (type == HFSPLUS_FILE) {\n#if 0\n\t\toff = fd.entryoffset + offsetof(hfsplus_cat_file, data_fork);\n\t\thfs_bnode_read(fd.bnode, &fork, off, sizeof(fork));\n\t\thfsplus_free_fork(sb, cnid, &fork, HFSPLUS_TYPE_DATA);\n#endif\n\n\t\toff = fd.entryoffset +\n\t\t\toffsetof(struct hfsplus_cat_file, rsrc_fork);\n\t\thfs_bnode_read(fd.bnode, &fork, off, sizeof(fork));\n\t\thfsplus_free_fork(sb, cnid, &fork, HFSPLUS_TYPE_RSRC);\n\t}\n\n\t \n\tspin_lock(&HFSPLUS_I(dir)->open_dir_lock);\n\tlist_for_each(pos, &HFSPLUS_I(dir)->open_dir_list) {\n\t\tstruct hfsplus_readdir_data *rd =\n\t\t\tlist_entry(pos, struct hfsplus_readdir_data, list);\n\t\tif (fd.tree->keycmp(fd.search_key, (void *)&rd->key) < 0)\n\t\t\trd->file->f_pos--;\n\t}\n\tspin_unlock(&HFSPLUS_I(dir)->open_dir_lock);\n\n\terr = hfs_brec_remove(&fd);\n\tif (err)\n\t\tgoto out;\n\n\thfsplus_cat_build_key_with_cnid(sb, fd.search_key, cnid);\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\n\terr = hfs_brec_remove(&fd);\n\tif (err)\n\t\tgoto out;\n\n\tdir->i_size--;\n\tif (type == HFSPLUS_FOLDER)\n\t\thfsplus_subfolders_dec(dir);\n\tdir->i_mtime = inode_set_ctime_current(dir);\n\thfsplus_mark_inode_dirty(dir, HFSPLUS_I_CAT_DIRTY);\n\n\tif (type == HFSPLUS_FILE || type == HFSPLUS_FOLDER) {\n\t\tif (HFSPLUS_SB(sb)->attr_tree)\n\t\t\thfsplus_delete_all_attrs(dir, cnid);\n\t}\n\nout:\n\thfs_find_exit(&fd);\n\n\treturn err;\n}\n\nint hfsplus_rename_cat(u32 cnid,\n\t\t       struct inode *src_dir, const struct qstr *src_name,\n\t\t       struct inode *dst_dir, const struct qstr *dst_name)\n{\n\tstruct super_block *sb = src_dir->i_sb;\n\tstruct hfs_find_data src_fd, dst_fd;\n\thfsplus_cat_entry entry;\n\tint entry_size, type;\n\tint err;\n\n\thfs_dbg(CAT_MOD, \"rename_cat: %u - %lu,%s - %lu,%s\\n\",\n\t\tcnid, src_dir->i_ino, src_name->name,\n\t\tdst_dir->i_ino, dst_name->name);\n\terr = hfs_find_init(HFSPLUS_SB(sb)->cat_tree, &src_fd);\n\tif (err)\n\t\treturn err;\n\tdst_fd = src_fd;\n\n\t \n\terr = hfs_bmap_reserve(src_fd.tree, 4 * (int)src_fd.tree->depth - 1);\n\tif (err)\n\t\tgoto out;\n\n\t \n\terr = hfsplus_cat_build_key(sb, src_fd.search_key,\n\t\t\tsrc_dir->i_ino, src_name);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\terr = hfs_brec_find(&src_fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\tif (src_fd.entrylength > sizeof(entry) || src_fd.entrylength < 0) {\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\n\thfs_bnode_read(src_fd.bnode, &entry, src_fd.entryoffset,\n\t\t\t\tsrc_fd.entrylength);\n\ttype = be16_to_cpu(entry.type);\n\n\t \n\terr = hfsplus_cat_build_key(sb, dst_fd.search_key,\n\t\t\tdst_dir->i_ino, dst_name);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\terr = hfs_brec_find(&dst_fd, hfs_find_rec_by_key);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto out;\n\t}\n\n\terr = hfs_brec_insert(&dst_fd, &entry, src_fd.entrylength);\n\tif (err)\n\t\tgoto out;\n\tdst_dir->i_size++;\n\tif (type == HFSPLUS_FOLDER)\n\t\thfsplus_subfolders_inc(dst_dir);\n\tdst_dir->i_mtime = inode_set_ctime_current(dst_dir);\n\n\t \n\terr = hfsplus_cat_build_key(sb, src_fd.search_key,\n\t\t\tsrc_dir->i_ino, src_name);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\terr = hfs_brec_find(&src_fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\terr = hfs_brec_remove(&src_fd);\n\tif (err)\n\t\tgoto out;\n\tsrc_dir->i_size--;\n\tif (type == HFSPLUS_FOLDER)\n\t\thfsplus_subfolders_dec(src_dir);\n\tsrc_dir->i_mtime = inode_set_ctime_current(src_dir);\n\n\t \n\thfsplus_cat_build_key_with_cnid(sb, src_fd.search_key, cnid);\n\terr = hfs_brec_find(&src_fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\ttype = hfs_bnode_read_u16(src_fd.bnode, src_fd.entryoffset);\n\terr = hfs_brec_remove(&src_fd);\n\tif (err)\n\t\tgoto out;\n\n\t \n\thfsplus_cat_build_key_with_cnid(sb, dst_fd.search_key, cnid);\n\tentry_size = hfsplus_fill_cat_thread(sb, &entry, type,\n\t\tdst_dir->i_ino, dst_name);\n\tif (unlikely(entry_size < 0)) {\n\t\terr = entry_size;\n\t\tgoto out;\n\t}\n\n\terr = hfs_brec_find(&dst_fd, hfs_find_rec_by_key);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto out;\n\t}\n\terr = hfs_brec_insert(&dst_fd, &entry, entry_size);\n\n\thfsplus_mark_inode_dirty(dst_dir, HFSPLUS_I_CAT_DIRTY);\n\thfsplus_mark_inode_dirty(src_dir, HFSPLUS_I_CAT_DIRTY);\nout:\n\thfs_bnode_put(dst_fd.bnode);\n\thfs_find_exit(&src_fd);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}