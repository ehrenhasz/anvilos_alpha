{
  "module_name": "xattr.c",
  "hash_id": "83f3281d4aa530a3678567d26ff5384e374d389aa5577741e4e1108662a9fe4e",
  "original_prompt": "Ingested from linux-6.6.14/fs/hfsplus/xattr.c",
  "human_readable_source": "\n \n\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include \"xattr.h\"\n\nstatic int hfsplus_removexattr(struct inode *inode, const char *name);\n\nconst struct xattr_handler *hfsplus_xattr_handlers[] = {\n\t&hfsplus_xattr_osx_handler,\n\t&hfsplus_xattr_user_handler,\n\t&hfsplus_xattr_trusted_handler,\n\t&hfsplus_xattr_security_handler,\n\tNULL\n};\n\nstatic int strcmp_xattr_finder_info(const char *name)\n{\n\tif (name) {\n\t\treturn strncmp(name, HFSPLUS_XATTR_FINDER_INFO_NAME,\n\t\t\t\tsizeof(HFSPLUS_XATTR_FINDER_INFO_NAME));\n\t}\n\treturn -1;\n}\n\nstatic int strcmp_xattr_acl(const char *name)\n{\n\tif (name) {\n\t\treturn strncmp(name, HFSPLUS_XATTR_ACL_NAME,\n\t\t\t\tsizeof(HFSPLUS_XATTR_ACL_NAME));\n\t}\n\treturn -1;\n}\n\nstatic bool is_known_namespace(const char *name)\n{\n\tif (strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_SECURITY_PREFIX, XATTR_SECURITY_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void hfsplus_init_header_node(struct inode *attr_file,\n\t\t\t\t\tu32 clump_size,\n\t\t\t\t\tchar *buf, u16 node_size)\n{\n\tstruct hfs_bnode_desc *desc;\n\tstruct hfs_btree_header_rec *head;\n\tu16 offset;\n\t__be16 *rec_offsets;\n\tu32 hdr_node_map_rec_bits;\n\tchar *bmp;\n\tu32 used_nodes;\n\tu32 used_bmp_bytes;\n\tu64 tmp;\n\n\thfs_dbg(ATTR_MOD, \"init_hdr_attr_file: clump %u, node_size %u\\n\",\n\t\tclump_size, node_size);\n\n\t \n\trec_offsets = (__be16 *)(buf + node_size);\n\n\tdesc = (struct hfs_bnode_desc *)buf;\n\tdesc->type = HFS_NODE_HEADER;\n\tdesc->num_recs = cpu_to_be16(HFSPLUS_BTREE_HDR_NODE_RECS_COUNT);\n\toffset = sizeof(struct hfs_bnode_desc);\n\t*--rec_offsets = cpu_to_be16(offset);\n\n\thead = (struct hfs_btree_header_rec *)(buf + offset);\n\thead->node_size = cpu_to_be16(node_size);\n\ttmp = i_size_read(attr_file);\n\tdo_div(tmp, node_size);\n\thead->node_count = cpu_to_be32(tmp);\n\thead->free_nodes = cpu_to_be32(be32_to_cpu(head->node_count) - 1);\n\thead->clump_size = cpu_to_be32(clump_size);\n\thead->attributes |= cpu_to_be32(HFS_TREE_BIGKEYS | HFS_TREE_VARIDXKEYS);\n\thead->max_key_len = cpu_to_be16(HFSPLUS_ATTR_KEYLEN - sizeof(u16));\n\toffset += sizeof(struct hfs_btree_header_rec);\n\t*--rec_offsets = cpu_to_be16(offset);\n\toffset += HFSPLUS_BTREE_HDR_USER_BYTES;\n\t*--rec_offsets = cpu_to_be16(offset);\n\n\thdr_node_map_rec_bits = 8 * (node_size - offset - (4 * sizeof(u16)));\n\tif (be32_to_cpu(head->node_count) > hdr_node_map_rec_bits) {\n\t\tu32 map_node_bits;\n\t\tu32 map_nodes;\n\n\t\tdesc->next = cpu_to_be32(be32_to_cpu(head->leaf_tail) + 1);\n\t\tmap_node_bits = 8 * (node_size - sizeof(struct hfs_bnode_desc) -\n\t\t\t\t\t(2 * sizeof(u16)) - 2);\n\t\tmap_nodes = (be32_to_cpu(head->node_count) -\n\t\t\t\thdr_node_map_rec_bits +\n\t\t\t\t(map_node_bits - 1)) / map_node_bits;\n\t\tbe32_add_cpu(&head->free_nodes, 0 - map_nodes);\n\t}\n\n\tbmp = buf + offset;\n\tused_nodes =\n\t\tbe32_to_cpu(head->node_count) - be32_to_cpu(head->free_nodes);\n\tused_bmp_bytes = used_nodes / 8;\n\tif (used_bmp_bytes) {\n\t\tmemset(bmp, 0xFF, used_bmp_bytes);\n\t\tbmp += used_bmp_bytes;\n\t\tused_nodes %= 8;\n\t}\n\t*bmp = ~(0xFF >> used_nodes);\n\toffset += hdr_node_map_rec_bits / 8;\n\t*--rec_offsets = cpu_to_be16(offset);\n}\n\nstatic int hfsplus_create_attributes_file(struct super_block *sb)\n{\n\tint err = 0;\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tstruct inode *attr_file;\n\tstruct hfsplus_inode_info *hip;\n\tu32 clump_size;\n\tu16 node_size = HFSPLUS_ATTR_TREE_NODE_SIZE;\n\tchar *buf;\n\tint index, written;\n\tstruct address_space *mapping;\n\tstruct page *page;\n\tint old_state = HFSPLUS_EMPTY_ATTR_TREE;\n\n\thfs_dbg(ATTR_MOD, \"create_attr_file: ino %d\\n\", HFSPLUS_ATTR_CNID);\n\ncheck_attr_tree_state_again:\n\tswitch (atomic_read(&sbi->attr_tree_state)) {\n\tcase HFSPLUS_EMPTY_ATTR_TREE:\n\t\tif (old_state != atomic_cmpxchg(&sbi->attr_tree_state,\n\t\t\t\t\t\told_state,\n\t\t\t\t\t\tHFSPLUS_CREATING_ATTR_TREE))\n\t\t\tgoto check_attr_tree_state_again;\n\t\tbreak;\n\tcase HFSPLUS_CREATING_ATTR_TREE:\n\t\t \n\t\treturn -EAGAIN;\n\tcase HFSPLUS_VALID_ATTR_TREE:\n\t\treturn 0;\n\tcase HFSPLUS_FAILED_ATTR_TREE:\n\t\treturn -EOPNOTSUPP;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tattr_file = hfsplus_iget(sb, HFSPLUS_ATTR_CNID);\n\tif (IS_ERR(attr_file)) {\n\t\tpr_err(\"failed to load attributes file\\n\");\n\t\treturn PTR_ERR(attr_file);\n\t}\n\n\tBUG_ON(i_size_read(attr_file) != 0);\n\n\thip = HFSPLUS_I(attr_file);\n\n\tclump_size = hfsplus_calc_btree_clump_size(sb->s_blocksize,\n\t\t\t\t\t\t    node_size,\n\t\t\t\t\t\t    sbi->sect_count,\n\t\t\t\t\t\t    HFSPLUS_ATTR_CNID);\n\n\tmutex_lock(&hip->extents_lock);\n\thip->clump_blocks = clump_size >> sbi->alloc_blksz_shift;\n\tmutex_unlock(&hip->extents_lock);\n\n\tif (sbi->free_blocks <= (hip->clump_blocks << 1)) {\n\t\terr = -ENOSPC;\n\t\tgoto end_attr_file_creation;\n\t}\n\n\twhile (hip->alloc_blocks < hip->clump_blocks) {\n\t\terr = hfsplus_file_extend(attr_file, false);\n\t\tif (unlikely(err)) {\n\t\t\tpr_err(\"failed to extend attributes file\\n\");\n\t\t\tgoto end_attr_file_creation;\n\t\t}\n\t\thip->phys_size = attr_file->i_size =\n\t\t\t(loff_t)hip->alloc_blocks << sbi->alloc_blksz_shift;\n\t\thip->fs_blocks = hip->alloc_blocks << sbi->fs_shift;\n\t\tinode_set_bytes(attr_file, attr_file->i_size);\n\t}\n\n\tbuf = kzalloc(node_size, GFP_NOFS);\n\tif (!buf) {\n\t\terr = -ENOMEM;\n\t\tgoto end_attr_file_creation;\n\t}\n\n\thfsplus_init_header_node(attr_file, clump_size, buf, node_size);\n\n\tmapping = attr_file->i_mapping;\n\n\tindex = 0;\n\twritten = 0;\n\tfor (; written < node_size; index++, written += PAGE_SIZE) {\n\t\tvoid *kaddr;\n\n\t\tpage = read_mapping_page(mapping, index, NULL);\n\t\tif (IS_ERR(page)) {\n\t\t\terr = PTR_ERR(page);\n\t\t\tgoto failed_header_node_init;\n\t\t}\n\n\t\tkaddr = kmap_atomic(page);\n\t\tmemcpy(kaddr, buf + written,\n\t\t\tmin_t(size_t, PAGE_SIZE, node_size - written));\n\t\tkunmap_atomic(kaddr);\n\n\t\tset_page_dirty(page);\n\t\tput_page(page);\n\t}\n\n\thfsplus_mark_inode_dirty(attr_file, HFSPLUS_I_ATTR_DIRTY);\n\n\tsbi->attr_tree = hfs_btree_open(sb, HFSPLUS_ATTR_CNID);\n\tif (!sbi->attr_tree)\n\t\tpr_err(\"failed to load attributes file\\n\");\n\nfailed_header_node_init:\n\tkfree(buf);\n\nend_attr_file_creation:\n\tiput(attr_file);\n\n\tif (!err)\n\t\tatomic_set(&sbi->attr_tree_state, HFSPLUS_VALID_ATTR_TREE);\n\telse if (err == -ENOSPC)\n\t\tatomic_set(&sbi->attr_tree_state, HFSPLUS_EMPTY_ATTR_TREE);\n\telse\n\t\tatomic_set(&sbi->attr_tree_state, HFSPLUS_FAILED_ATTR_TREE);\n\n\treturn err;\n}\n\nint __hfsplus_setxattr(struct inode *inode, const char *name,\n\t\t\tconst void *value, size_t size, int flags)\n{\n\tint err;\n\tstruct hfs_find_data cat_fd;\n\thfsplus_cat_entry entry;\n\tu16 cat_entry_flags, cat_entry_type;\n\tu16 folder_finderinfo_len = sizeof(struct DInfo) +\n\t\t\t\t\tsizeof(struct DXInfo);\n\tu16 file_finderinfo_len = sizeof(struct FInfo) +\n\t\t\t\t\tsizeof(struct FXInfo);\n\n\tif ((!S_ISREG(inode->i_mode) &&\n\t\t\t!S_ISDIR(inode->i_mode)) ||\n\t\t\t\tHFSPLUS_IS_RSRC(inode))\n\t\treturn -EOPNOTSUPP;\n\n\tif (value == NULL)\n\t\treturn hfsplus_removexattr(inode, name);\n\n\terr = hfs_find_init(HFSPLUS_SB(inode->i_sb)->cat_tree, &cat_fd);\n\tif (err) {\n\t\tpr_err(\"can't init xattr find struct\\n\");\n\t\treturn err;\n\t}\n\n\terr = hfsplus_find_cat(inode->i_sb, inode->i_ino, &cat_fd);\n\tif (err) {\n\t\tpr_err(\"catalog searching failed\\n\");\n\t\tgoto end_setxattr;\n\t}\n\n\tif (!strcmp_xattr_finder_info(name)) {\n\t\tif (flags & XATTR_CREATE) {\n\t\t\tpr_err(\"xattr exists yet\\n\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto end_setxattr;\n\t\t}\n\t\thfs_bnode_read(cat_fd.bnode, &entry, cat_fd.entryoffset,\n\t\t\t\t\tsizeof(hfsplus_cat_entry));\n\t\tif (be16_to_cpu(entry.type) == HFSPLUS_FOLDER) {\n\t\t\tif (size == folder_finderinfo_len) {\n\t\t\t\tmemcpy(&entry.folder.info, value,\n\t\t\t\t\t\tfolder_finderinfo_len);\n\t\t\t\thfs_bnode_write(cat_fd.bnode, &entry,\n\t\t\t\t\tcat_fd.entryoffset,\n\t\t\t\t\tsizeof(struct hfsplus_cat_folder));\n\t\t\t\thfsplus_mark_inode_dirty(inode,\n\t\t\t\t\t\tHFSPLUS_I_CAT_DIRTY);\n\t\t\t} else {\n\t\t\t\terr = -ERANGE;\n\t\t\t\tgoto end_setxattr;\n\t\t\t}\n\t\t} else if (be16_to_cpu(entry.type) == HFSPLUS_FILE) {\n\t\t\tif (size == file_finderinfo_len) {\n\t\t\t\tmemcpy(&entry.file.info, value,\n\t\t\t\t\t\tfile_finderinfo_len);\n\t\t\t\thfs_bnode_write(cat_fd.bnode, &entry,\n\t\t\t\t\tcat_fd.entryoffset,\n\t\t\t\t\tsizeof(struct hfsplus_cat_file));\n\t\t\t\thfsplus_mark_inode_dirty(inode,\n\t\t\t\t\t\tHFSPLUS_I_CAT_DIRTY);\n\t\t\t} else {\n\t\t\t\terr = -ERANGE;\n\t\t\t\tgoto end_setxattr;\n\t\t\t}\n\t\t} else {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto end_setxattr;\n\t\t}\n\t\tgoto end_setxattr;\n\t}\n\n\tif (!HFSPLUS_SB(inode->i_sb)->attr_tree) {\n\t\terr = hfsplus_create_attributes_file(inode->i_sb);\n\t\tif (unlikely(err))\n\t\t\tgoto end_setxattr;\n\t}\n\n\tif (hfsplus_attr_exists(inode, name)) {\n\t\tif (flags & XATTR_CREATE) {\n\t\t\tpr_err(\"xattr exists yet\\n\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto end_setxattr;\n\t\t}\n\t\terr = hfsplus_delete_attr(inode, name);\n\t\tif (err)\n\t\t\tgoto end_setxattr;\n\t\terr = hfsplus_create_attr(inode, name, value, size);\n\t\tif (err)\n\t\t\tgoto end_setxattr;\n\t} else {\n\t\tif (flags & XATTR_REPLACE) {\n\t\t\tpr_err(\"cannot replace xattr\\n\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto end_setxattr;\n\t\t}\n\t\terr = hfsplus_create_attr(inode, name, value, size);\n\t\tif (err)\n\t\t\tgoto end_setxattr;\n\t}\n\n\tcat_entry_type = hfs_bnode_read_u16(cat_fd.bnode, cat_fd.entryoffset);\n\tif (cat_entry_type == HFSPLUS_FOLDER) {\n\t\tcat_entry_flags = hfs_bnode_read_u16(cat_fd.bnode,\n\t\t\t\t    cat_fd.entryoffset +\n\t\t\t\t    offsetof(struct hfsplus_cat_folder, flags));\n\t\tcat_entry_flags |= HFSPLUS_XATTR_EXISTS;\n\t\tif (!strcmp_xattr_acl(name))\n\t\t\tcat_entry_flags |= HFSPLUS_ACL_EXISTS;\n\t\thfs_bnode_write_u16(cat_fd.bnode, cat_fd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_cat_folder, flags),\n\t\t\t\tcat_entry_flags);\n\t\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_CAT_DIRTY);\n\t} else if (cat_entry_type == HFSPLUS_FILE) {\n\t\tcat_entry_flags = hfs_bnode_read_u16(cat_fd.bnode,\n\t\t\t\t    cat_fd.entryoffset +\n\t\t\t\t    offsetof(struct hfsplus_cat_file, flags));\n\t\tcat_entry_flags |= HFSPLUS_XATTR_EXISTS;\n\t\tif (!strcmp_xattr_acl(name))\n\t\t\tcat_entry_flags |= HFSPLUS_ACL_EXISTS;\n\t\thfs_bnode_write_u16(cat_fd.bnode, cat_fd.entryoffset +\n\t\t\t\t    offsetof(struct hfsplus_cat_file, flags),\n\t\t\t\t    cat_entry_flags);\n\t\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_CAT_DIRTY);\n\t} else {\n\t\tpr_err(\"invalid catalog entry type\\n\");\n\t\terr = -EIO;\n\t\tgoto end_setxattr;\n\t}\n\nend_setxattr:\n\thfs_find_exit(&cat_fd);\n\treturn err;\n}\n\nstatic int name_len(const char *xattr_name, int xattr_name_len)\n{\n\tint len = xattr_name_len + 1;\n\n\tif (!is_known_namespace(xattr_name))\n\t\tlen += XATTR_MAC_OSX_PREFIX_LEN;\n\n\treturn len;\n}\n\nstatic int copy_name(char *buffer, const char *xattr_name, int name_len)\n{\n\tint len = name_len;\n\tint offset = 0;\n\n\tif (!is_known_namespace(xattr_name)) {\n\t\tmemcpy(buffer, XATTR_MAC_OSX_PREFIX, XATTR_MAC_OSX_PREFIX_LEN);\n\t\toffset += XATTR_MAC_OSX_PREFIX_LEN;\n\t\tlen += XATTR_MAC_OSX_PREFIX_LEN;\n\t}\n\n\tstrncpy(buffer + offset, xattr_name, name_len);\n\tmemset(buffer + offset + name_len, 0, 1);\n\tlen += 1;\n\n\treturn len;\n}\n\nint hfsplus_setxattr(struct inode *inode, const char *name,\n\t\t     const void *value, size_t size, int flags,\n\t\t     const char *prefix, size_t prefixlen)\n{\n\tchar *xattr_name;\n\tint res;\n\n\txattr_name = kmalloc(NLS_MAX_CHARSET_SIZE * HFSPLUS_ATTR_MAX_STRLEN + 1,\n\t\tGFP_KERNEL);\n\tif (!xattr_name)\n\t\treturn -ENOMEM;\n\tstrcpy(xattr_name, prefix);\n\tstrcpy(xattr_name + prefixlen, name);\n\tres = __hfsplus_setxattr(inode, xattr_name, value, size, flags);\n\tkfree(xattr_name);\n\treturn res;\n}\n\nstatic ssize_t hfsplus_getxattr_finder_info(struct inode *inode,\n\t\t\t\t\t\tvoid *value, size_t size)\n{\n\tssize_t res = 0;\n\tstruct hfs_find_data fd;\n\tu16 entry_type;\n\tu16 folder_rec_len = sizeof(struct DInfo) + sizeof(struct DXInfo);\n\tu16 file_rec_len = sizeof(struct FInfo) + sizeof(struct FXInfo);\n\tu16 record_len = max(folder_rec_len, file_rec_len);\n\tu8 folder_finder_info[sizeof(struct DInfo) + sizeof(struct DXInfo)];\n\tu8 file_finder_info[sizeof(struct FInfo) + sizeof(struct FXInfo)];\n\n\tif (size >= record_len) {\n\t\tres = hfs_find_init(HFSPLUS_SB(inode->i_sb)->cat_tree, &fd);\n\t\tif (res) {\n\t\t\tpr_err(\"can't init xattr find struct\\n\");\n\t\t\treturn res;\n\t\t}\n\t\tres = hfsplus_find_cat(inode->i_sb, inode->i_ino, &fd);\n\t\tif (res)\n\t\t\tgoto end_getxattr_finder_info;\n\t\tentry_type = hfs_bnode_read_u16(fd.bnode, fd.entryoffset);\n\n\t\tif (entry_type == HFSPLUS_FOLDER) {\n\t\t\thfs_bnode_read(fd.bnode, folder_finder_info,\n\t\t\t\tfd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_cat_folder, user_info),\n\t\t\t\tfolder_rec_len);\n\t\t\tmemcpy(value, folder_finder_info, folder_rec_len);\n\t\t\tres = folder_rec_len;\n\t\t} else if (entry_type == HFSPLUS_FILE) {\n\t\t\thfs_bnode_read(fd.bnode, file_finder_info,\n\t\t\t\tfd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_cat_file, user_info),\n\t\t\t\tfile_rec_len);\n\t\t\tmemcpy(value, file_finder_info, file_rec_len);\n\t\t\tres = file_rec_len;\n\t\t} else {\n\t\t\tres = -EOPNOTSUPP;\n\t\t\tgoto end_getxattr_finder_info;\n\t\t}\n\t} else\n\t\tres = size ? -ERANGE : record_len;\n\nend_getxattr_finder_info:\n\tif (size >= record_len)\n\t\thfs_find_exit(&fd);\n\treturn res;\n}\n\nssize_t __hfsplus_getxattr(struct inode *inode, const char *name,\n\t\t\t void *value, size_t size)\n{\n\tstruct hfs_find_data fd;\n\thfsplus_attr_entry *entry;\n\t__be32 xattr_record_type;\n\tu32 record_type;\n\tu16 record_length = 0;\n\tssize_t res;\n\n\tif ((!S_ISREG(inode->i_mode) &&\n\t\t\t!S_ISDIR(inode->i_mode)) ||\n\t\t\t\tHFSPLUS_IS_RSRC(inode))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!strcmp_xattr_finder_info(name))\n\t\treturn hfsplus_getxattr_finder_info(inode, value, size);\n\n\tif (!HFSPLUS_SB(inode->i_sb)->attr_tree)\n\t\treturn -EOPNOTSUPP;\n\n\tentry = hfsplus_alloc_attr_entry();\n\tif (!entry) {\n\t\tpr_err(\"can't allocate xattr entry\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tres = hfs_find_init(HFSPLUS_SB(inode->i_sb)->attr_tree, &fd);\n\tif (res) {\n\t\tpr_err(\"can't init xattr find struct\\n\");\n\t\tgoto failed_getxattr_init;\n\t}\n\n\tres = hfsplus_find_attr(inode->i_sb, inode->i_ino, name, &fd);\n\tif (res) {\n\t\tif (res == -ENOENT)\n\t\t\tres = -ENODATA;\n\t\telse\n\t\t\tpr_err(\"xattr searching failed\\n\");\n\t\tgoto out;\n\t}\n\n\thfs_bnode_read(fd.bnode, &xattr_record_type,\n\t\t\tfd.entryoffset, sizeof(xattr_record_type));\n\trecord_type = be32_to_cpu(xattr_record_type);\n\tif (record_type == HFSPLUS_ATTR_INLINE_DATA) {\n\t\trecord_length = hfs_bnode_read_u16(fd.bnode,\n\t\t\t\tfd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_attr_inline_data,\n\t\t\t\tlength));\n\t\tif (record_length > HFSPLUS_MAX_INLINE_DATA_SIZE) {\n\t\t\tpr_err(\"invalid xattr record size\\n\");\n\t\t\tres = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t} else if (record_type == HFSPLUS_ATTR_FORK_DATA ||\n\t\t\trecord_type == HFSPLUS_ATTR_EXTENTS) {\n\t\tpr_err(\"only inline data xattr are supported\\n\");\n\t\tres = -EOPNOTSUPP;\n\t\tgoto out;\n\t} else {\n\t\tpr_err(\"invalid xattr record\\n\");\n\t\tres = -EIO;\n\t\tgoto out;\n\t}\n\n\tif (size) {\n\t\thfs_bnode_read(fd.bnode, entry, fd.entryoffset,\n\t\t\t\toffsetof(struct hfsplus_attr_inline_data,\n\t\t\t\t\traw_bytes) + record_length);\n\t}\n\n\tif (size >= record_length) {\n\t\tmemcpy(value, entry->inline_data.raw_bytes, record_length);\n\t\tres = record_length;\n\t} else\n\t\tres = size ? -ERANGE : record_length;\n\nout:\n\thfs_find_exit(&fd);\n\nfailed_getxattr_init:\n\thfsplus_destroy_attr_entry(entry);\n\treturn res;\n}\n\nssize_t hfsplus_getxattr(struct inode *inode, const char *name,\n\t\t\t void *value, size_t size,\n\t\t\t const char *prefix, size_t prefixlen)\n{\n\tint res;\n\tchar *xattr_name;\n\n\txattr_name = kmalloc(NLS_MAX_CHARSET_SIZE * HFSPLUS_ATTR_MAX_STRLEN + 1,\n\t\t\t     GFP_KERNEL);\n\tif (!xattr_name)\n\t\treturn -ENOMEM;\n\n\tstrcpy(xattr_name, prefix);\n\tstrcpy(xattr_name + prefixlen, name);\n\n\tres = __hfsplus_getxattr(inode, xattr_name, value, size);\n\tkfree(xattr_name);\n\treturn res;\n\n}\n\nstatic inline int can_list(const char *xattr_name)\n{\n\tif (!xattr_name)\n\t\treturn 0;\n\n\treturn strncmp(xattr_name, XATTR_TRUSTED_PREFIX,\n\t\t\tXATTR_TRUSTED_PREFIX_LEN) ||\n\t\t\t\tcapable(CAP_SYS_ADMIN);\n}\n\nstatic ssize_t hfsplus_listxattr_finder_info(struct dentry *dentry,\n\t\t\t\t\t\tchar *buffer, size_t size)\n{\n\tssize_t res;\n\tstruct inode *inode = d_inode(dentry);\n\tstruct hfs_find_data fd;\n\tu16 entry_type;\n\tu8 folder_finder_info[sizeof(struct DInfo) + sizeof(struct DXInfo)];\n\tu8 file_finder_info[sizeof(struct FInfo) + sizeof(struct FXInfo)];\n\tunsigned long len, found_bit;\n\tint xattr_name_len, symbols_count;\n\n\tres = hfs_find_init(HFSPLUS_SB(inode->i_sb)->cat_tree, &fd);\n\tif (res) {\n\t\tpr_err(\"can't init xattr find struct\\n\");\n\t\treturn res;\n\t}\n\n\tres = hfsplus_find_cat(inode->i_sb, inode->i_ino, &fd);\n\tif (res)\n\t\tgoto end_listxattr_finder_info;\n\n\tentry_type = hfs_bnode_read_u16(fd.bnode, fd.entryoffset);\n\tif (entry_type == HFSPLUS_FOLDER) {\n\t\tlen = sizeof(struct DInfo) + sizeof(struct DXInfo);\n\t\thfs_bnode_read(fd.bnode, folder_finder_info,\n\t\t\t\tfd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_cat_folder, user_info),\n\t\t\t\tlen);\n\t\tfound_bit = find_first_bit((void *)folder_finder_info, len*8);\n\t} else if (entry_type == HFSPLUS_FILE) {\n\t\tlen = sizeof(struct FInfo) + sizeof(struct FXInfo);\n\t\thfs_bnode_read(fd.bnode, file_finder_info,\n\t\t\t\tfd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_cat_file, user_info),\n\t\t\t\tlen);\n\t\tfound_bit = find_first_bit((void *)file_finder_info, len*8);\n\t} else {\n\t\tres = -EOPNOTSUPP;\n\t\tgoto end_listxattr_finder_info;\n\t}\n\n\tif (found_bit >= (len*8))\n\t\tres = 0;\n\telse {\n\t\tsymbols_count = sizeof(HFSPLUS_XATTR_FINDER_INFO_NAME) - 1;\n\t\txattr_name_len =\n\t\t\tname_len(HFSPLUS_XATTR_FINDER_INFO_NAME, symbols_count);\n\t\tif (!buffer || !size) {\n\t\t\tif (can_list(HFSPLUS_XATTR_FINDER_INFO_NAME))\n\t\t\t\tres = xattr_name_len;\n\t\t} else if (can_list(HFSPLUS_XATTR_FINDER_INFO_NAME)) {\n\t\t\tif (size < xattr_name_len)\n\t\t\t\tres = -ERANGE;\n\t\t\telse {\n\t\t\t\tres = copy_name(buffer,\n\t\t\t\t\t\tHFSPLUS_XATTR_FINDER_INFO_NAME,\n\t\t\t\t\t\tsymbols_count);\n\t\t\t}\n\t\t}\n\t}\n\nend_listxattr_finder_info:\n\thfs_find_exit(&fd);\n\n\treturn res;\n}\n\nssize_t hfsplus_listxattr(struct dentry *dentry, char *buffer, size_t size)\n{\n\tssize_t err;\n\tssize_t res;\n\tstruct inode *inode = d_inode(dentry);\n\tstruct hfs_find_data fd;\n\tstruct hfsplus_attr_key attr_key;\n\tchar *strbuf;\n\tint xattr_name_len;\n\n\tif ((!S_ISREG(inode->i_mode) &&\n\t\t\t!S_ISDIR(inode->i_mode)) ||\n\t\t\t\tHFSPLUS_IS_RSRC(inode))\n\t\treturn -EOPNOTSUPP;\n\n\tres = hfsplus_listxattr_finder_info(dentry, buffer, size);\n\tif (res < 0)\n\t\treturn res;\n\telse if (!HFSPLUS_SB(inode->i_sb)->attr_tree)\n\t\treturn (res == 0) ? -EOPNOTSUPP : res;\n\n\terr = hfs_find_init(HFSPLUS_SB(inode->i_sb)->attr_tree, &fd);\n\tif (err) {\n\t\tpr_err(\"can't init xattr find struct\\n\");\n\t\treturn err;\n\t}\n\n\tstrbuf = kmalloc(NLS_MAX_CHARSET_SIZE * HFSPLUS_ATTR_MAX_STRLEN +\n\t\t\tXATTR_MAC_OSX_PREFIX_LEN + 1, GFP_KERNEL);\n\tif (!strbuf) {\n\t\tres = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\terr = hfsplus_find_attr(inode->i_sb, inode->i_ino, NULL, &fd);\n\tif (err) {\n\t\tif (err == -ENOENT) {\n\t\t\tif (res == 0)\n\t\t\t\tres = -ENODATA;\n\t\t\tgoto end_listxattr;\n\t\t} else {\n\t\t\tres = err;\n\t\t\tgoto end_listxattr;\n\t\t}\n\t}\n\n\tfor (;;) {\n\t\tu16 key_len = hfs_bnode_read_u16(fd.bnode, fd.keyoffset);\n\n\t\tif (key_len == 0 || key_len > fd.tree->max_key_len) {\n\t\t\tpr_err(\"invalid xattr key length: %d\\n\", key_len);\n\t\t\tres = -EIO;\n\t\t\tgoto end_listxattr;\n\t\t}\n\n\t\thfs_bnode_read(fd.bnode, &attr_key,\n\t\t\t\tfd.keyoffset, key_len + sizeof(key_len));\n\n\t\tif (be32_to_cpu(attr_key.cnid) != inode->i_ino)\n\t\t\tgoto end_listxattr;\n\n\t\txattr_name_len = NLS_MAX_CHARSET_SIZE * HFSPLUS_ATTR_MAX_STRLEN;\n\t\tif (hfsplus_uni2asc(inode->i_sb,\n\t\t\t(const struct hfsplus_unistr *)&fd.key->attr.key_name,\n\t\t\t\t\tstrbuf, &xattr_name_len)) {\n\t\t\tpr_err(\"unicode conversion failed\\n\");\n\t\t\tres = -EIO;\n\t\t\tgoto end_listxattr;\n\t\t}\n\n\t\tif (!buffer || !size) {\n\t\t\tif (can_list(strbuf))\n\t\t\t\tres += name_len(strbuf, xattr_name_len);\n\t\t} else if (can_list(strbuf)) {\n\t\t\tif (size < (res + name_len(strbuf, xattr_name_len))) {\n\t\t\t\tres = -ERANGE;\n\t\t\t\tgoto end_listxattr;\n\t\t\t} else\n\t\t\t\tres += copy_name(buffer + res,\n\t\t\t\t\t\tstrbuf, xattr_name_len);\n\t\t}\n\n\t\tif (hfs_brec_goto(&fd, 1))\n\t\t\tgoto end_listxattr;\n\t}\n\nend_listxattr:\n\tkfree(strbuf);\nout:\n\thfs_find_exit(&fd);\n\treturn res;\n}\n\nstatic int hfsplus_removexattr(struct inode *inode, const char *name)\n{\n\tint err;\n\tstruct hfs_find_data cat_fd;\n\tu16 flags;\n\tu16 cat_entry_type;\n\tint is_xattr_acl_deleted;\n\tint is_all_xattrs_deleted;\n\n\tif (!HFSPLUS_SB(inode->i_sb)->attr_tree)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!strcmp_xattr_finder_info(name))\n\t\treturn -EOPNOTSUPP;\n\n\terr = hfs_find_init(HFSPLUS_SB(inode->i_sb)->cat_tree, &cat_fd);\n\tif (err) {\n\t\tpr_err(\"can't init xattr find struct\\n\");\n\t\treturn err;\n\t}\n\n\terr = hfsplus_find_cat(inode->i_sb, inode->i_ino, &cat_fd);\n\tif (err) {\n\t\tpr_err(\"catalog searching failed\\n\");\n\t\tgoto end_removexattr;\n\t}\n\n\terr = hfsplus_delete_attr(inode, name);\n\tif (err)\n\t\tgoto end_removexattr;\n\n\tis_xattr_acl_deleted = !strcmp_xattr_acl(name);\n\tis_all_xattrs_deleted = !hfsplus_attr_exists(inode, NULL);\n\n\tif (!is_xattr_acl_deleted && !is_all_xattrs_deleted)\n\t\tgoto end_removexattr;\n\n\tcat_entry_type = hfs_bnode_read_u16(cat_fd.bnode, cat_fd.entryoffset);\n\n\tif (cat_entry_type == HFSPLUS_FOLDER) {\n\t\tflags = hfs_bnode_read_u16(cat_fd.bnode, cat_fd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_cat_folder, flags));\n\t\tif (is_xattr_acl_deleted)\n\t\t\tflags &= ~HFSPLUS_ACL_EXISTS;\n\t\tif (is_all_xattrs_deleted)\n\t\t\tflags &= ~HFSPLUS_XATTR_EXISTS;\n\t\thfs_bnode_write_u16(cat_fd.bnode, cat_fd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_cat_folder, flags),\n\t\t\t\tflags);\n\t\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_CAT_DIRTY);\n\t} else if (cat_entry_type == HFSPLUS_FILE) {\n\t\tflags = hfs_bnode_read_u16(cat_fd.bnode, cat_fd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_cat_file, flags));\n\t\tif (is_xattr_acl_deleted)\n\t\t\tflags &= ~HFSPLUS_ACL_EXISTS;\n\t\tif (is_all_xattrs_deleted)\n\t\t\tflags &= ~HFSPLUS_XATTR_EXISTS;\n\t\thfs_bnode_write_u16(cat_fd.bnode, cat_fd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_cat_file, flags),\n\t\t\t\tflags);\n\t\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_CAT_DIRTY);\n\t} else {\n\t\tpr_err(\"invalid catalog entry type\\n\");\n\t\terr = -EIO;\n\t\tgoto end_removexattr;\n\t}\n\nend_removexattr:\n\thfs_find_exit(&cat_fd);\n\treturn err;\n}\n\nstatic int hfsplus_osx_getxattr(const struct xattr_handler *handler,\n\t\t\t\tstruct dentry *unused, struct inode *inode,\n\t\t\t\tconst char *name, void *buffer, size_t size)\n{\n\t \n\tif (is_known_namespace(name))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\treturn __hfsplus_getxattr(inode, name, buffer, size);\n}\n\nstatic int hfsplus_osx_setxattr(const struct xattr_handler *handler,\n\t\t\t\tstruct mnt_idmap *idmap,\n\t\t\t\tstruct dentry *unused, struct inode *inode,\n\t\t\t\tconst char *name, const void *buffer,\n\t\t\t\tsize_t size, int flags)\n{\n\t \n\tif (is_known_namespace(name))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\treturn __hfsplus_setxattr(inode, name, buffer, size, flags);\n}\n\nconst struct xattr_handler hfsplus_xattr_osx_handler = {\n\t.prefix\t= XATTR_MAC_OSX_PREFIX,\n\t.get\t= hfsplus_osx_getxattr,\n\t.set\t= hfsplus_osx_setxattr,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}