{
  "module_name": "part_tbl.c",
  "hash_id": "427366919386bf18d6dfb63c3d387df515aefd6487277358bc52dcefc6ea08b5",
  "original_prompt": "Ingested from linux-6.6.14/fs/hfsplus/part_tbl.c",
  "human_readable_source": " \n\n#include <linux/slab.h>\n#include \"hfsplus_fs.h\"\n\n \n#define HFS_DD_BLK\t\t0  \n#define HFS_PMAP_BLK\t\t1  \n#define HFS_MDB_BLK\t\t2  \n\n \n#define HFS_DRVR_DESC_MAGIC\t0x4552  \n#define HFS_OLD_PMAP_MAGIC\t0x5453  \n#define HFS_NEW_PMAP_MAGIC\t0x504D  \n#define HFS_SUPER_MAGIC\t\t0x4244  \n#define HFS_MFS_SUPER_MAGIC\t0xD2D7  \n\n \nstruct new_pmap {\n\t__be16\tpmSig;\t\t \n\t__be16\treSigPad;\t \n\t__be32\tpmMapBlkCnt;\t \n\t__be32\tpmPyPartStart;\t \n\t__be32\tpmPartBlkCnt;\t \n\tu8\tpmPartName[32];\t \n\tu8\tpmPartType[32];\t \n\t \n} __packed;\n\n \nstruct old_pmap {\n\t__be16\t\tpdSig;\t \n\tstruct old_pmap_entry {\n\t\t__be32\tpdStart;\n\t\t__be32\tpdSize;\n\t\t__be32\tpdFSID;\n\t}\tpdEntry[42];\n} __packed;\n\nstatic int hfs_parse_old_pmap(struct super_block *sb, struct old_pmap *pm,\n\t\tsector_t *part_start, sector_t *part_size)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tint i;\n\n\tfor (i = 0; i < 42; i++) {\n\t\tstruct old_pmap_entry *p = &pm->pdEntry[i];\n\n\t\tif (p->pdStart && p->pdSize &&\n\t\t    p->pdFSID == cpu_to_be32(0x54465331)  &&\n\t\t    (sbi->part < 0 || sbi->part == i)) {\n\t\t\t*part_start += be32_to_cpu(p->pdStart);\n\t\t\t*part_size = be32_to_cpu(p->pdSize);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -ENOENT;\n}\n\nstatic int hfs_parse_new_pmap(struct super_block *sb, void *buf,\n\t\tstruct new_pmap *pm, sector_t *part_start, sector_t *part_size)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tint size = be32_to_cpu(pm->pmMapBlkCnt);\n\tint buf_size = hfsplus_min_io_size(sb);\n\tint res;\n\tint i = 0;\n\n\tdo {\n\t\tif (!memcmp(pm->pmPartType, \"Apple_HFS\", 9) &&\n\t\t    (sbi->part < 0 || sbi->part == i)) {\n\t\t\t*part_start += be32_to_cpu(pm->pmPyPartStart);\n\t\t\t*part_size = be32_to_cpu(pm->pmPartBlkCnt);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (++i >= size)\n\t\t\treturn -ENOENT;\n\n\t\tpm = (struct new_pmap *)((u8 *)pm + HFSPLUS_SECTOR_SIZE);\n\t\tif ((u8 *)pm - (u8 *)buf >= buf_size) {\n\t\t\tres = hfsplus_submit_bio(sb,\n\t\t\t\t\t\t *part_start + HFS_PMAP_BLK + i,\n\t\t\t\t\t\t buf, (void **)&pm, REQ_OP_READ);\n\t\t\tif (res)\n\t\t\t\treturn res;\n\t\t}\n\t} while (pm->pmSig == cpu_to_be16(HFS_NEW_PMAP_MAGIC));\n\n\treturn -ENOENT;\n}\n\n \nint hfs_part_find(struct super_block *sb,\n\t\tsector_t *part_start, sector_t *part_size)\n{\n\tvoid *buf, *data;\n\tint res;\n\n\tbuf = kmalloc(hfsplus_min_io_size(sb), GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tres = hfsplus_submit_bio(sb, *part_start + HFS_PMAP_BLK,\n\t\t\t\t buf, &data, REQ_OP_READ);\n\tif (res)\n\t\tgoto out;\n\n\tswitch (be16_to_cpu(*((__be16 *)data))) {\n\tcase HFS_OLD_PMAP_MAGIC:\n\t\tres = hfs_parse_old_pmap(sb, data, part_start, part_size);\n\t\tbreak;\n\tcase HFS_NEW_PMAP_MAGIC:\n\t\tres = hfs_parse_new_pmap(sb, buf, data, part_start, part_size);\n\t\tbreak;\n\tdefault:\n\t\tres = -ENOENT;\n\t\tbreak;\n\t}\nout:\n\tkfree(buf);\n\treturn res;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}