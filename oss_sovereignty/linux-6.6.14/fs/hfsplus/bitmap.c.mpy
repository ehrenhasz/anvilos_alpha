{
  "module_name": "bitmap.c",
  "hash_id": "e39dbe6770bdd162655adec11d1e07f07ea28b3c51964a80cee1e5fe6beccb6e",
  "original_prompt": "Ingested from linux-6.6.14/fs/hfsplus/bitmap.c",
  "human_readable_source": "\n \n\n#include <linux/pagemap.h>\n\n#include \"hfsplus_fs.h\"\n#include \"hfsplus_raw.h\"\n\n#define PAGE_CACHE_BITS\t(PAGE_SIZE * 8)\n\nint hfsplus_block_allocate(struct super_block *sb, u32 size,\n\t\tu32 offset, u32 *max)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tstruct page *page;\n\tstruct address_space *mapping;\n\t__be32 *pptr, *curr, *end;\n\tu32 mask, start, len, n;\n\t__be32 val;\n\tint i;\n\n\tlen = *max;\n\tif (!len)\n\t\treturn size;\n\n\thfs_dbg(BITMAP, \"block_allocate: %u,%u,%u\\n\", size, offset, len);\n\tmutex_lock(&sbi->alloc_mutex);\n\tmapping = sbi->alloc_file->i_mapping;\n\tpage = read_mapping_page(mapping, offset / PAGE_CACHE_BITS, NULL);\n\tif (IS_ERR(page)) {\n\t\tstart = size;\n\t\tgoto out;\n\t}\n\tpptr = kmap_local_page(page);\n\tcurr = pptr + (offset & (PAGE_CACHE_BITS - 1)) / 32;\n\ti = offset % 32;\n\toffset &= ~(PAGE_CACHE_BITS - 1);\n\tif ((size ^ offset) / PAGE_CACHE_BITS)\n\t\tend = pptr + PAGE_CACHE_BITS / 32;\n\telse\n\t\tend = pptr + ((size + 31) & (PAGE_CACHE_BITS - 1)) / 32;\n\n\t \n\tval = *curr;\n\tif (~val) {\n\t\tn = be32_to_cpu(val);\n\t\tmask = (1U << 31) >> i;\n\t\tfor (; i < 32; mask >>= 1, i++) {\n\t\t\tif (!(n & mask))\n\t\t\t\tgoto found;\n\t\t}\n\t}\n\tcurr++;\n\n\t \n\twhile (1) {\n\t\twhile (curr < end) {\n\t\t\tval = *curr;\n\t\t\tif (~val) {\n\t\t\t\tn = be32_to_cpu(val);\n\t\t\t\tmask = 1 << 31;\n\t\t\t\tfor (i = 0; i < 32; mask >>= 1, i++) {\n\t\t\t\t\tif (!(n & mask))\n\t\t\t\t\t\tgoto found;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurr++;\n\t\t}\n\t\tkunmap_local(pptr);\n\t\toffset += PAGE_CACHE_BITS;\n\t\tif (offset >= size)\n\t\t\tbreak;\n\t\tpage = read_mapping_page(mapping, offset / PAGE_CACHE_BITS,\n\t\t\t\t\t NULL);\n\t\tif (IS_ERR(page)) {\n\t\t\tstart = size;\n\t\t\tgoto out;\n\t\t}\n\t\tcurr = pptr = kmap_local_page(page);\n\t\tif ((size ^ offset) / PAGE_CACHE_BITS)\n\t\t\tend = pptr + PAGE_CACHE_BITS / 32;\n\t\telse\n\t\t\tend = pptr + ((size + 31) & (PAGE_CACHE_BITS - 1)) / 32;\n\t}\n\thfs_dbg(BITMAP, \"bitmap full\\n\");\n\tstart = size;\n\tgoto out;\n\nfound:\n\tstart = offset + (curr - pptr) * 32 + i;\n\tif (start >= size) {\n\t\thfs_dbg(BITMAP, \"bitmap full\\n\");\n\t\tgoto out;\n\t}\n\t \n\tlen = min(size - start, len);\n\twhile (1) {\n\t\tn |= mask;\n\t\tif (++i >= 32)\n\t\t\tbreak;\n\t\tmask >>= 1;\n\t\tif (!--len || n & mask)\n\t\t\tgoto done;\n\t}\n\tif (!--len)\n\t\tgoto done;\n\t*curr++ = cpu_to_be32(n);\n\t \n\twhile (1) {\n\t\twhile (curr < end) {\n\t\t\tn = be32_to_cpu(*curr);\n\t\t\tif (len < 32)\n\t\t\t\tgoto last;\n\t\t\tif (n) {\n\t\t\t\tlen = 32;\n\t\t\t\tgoto last;\n\t\t\t}\n\t\t\t*curr++ = cpu_to_be32(0xffffffff);\n\t\t\tlen -= 32;\n\t\t}\n\t\tset_page_dirty(page);\n\t\tkunmap_local(pptr);\n\t\toffset += PAGE_CACHE_BITS;\n\t\tpage = read_mapping_page(mapping, offset / PAGE_CACHE_BITS,\n\t\t\t\t\t NULL);\n\t\tif (IS_ERR(page)) {\n\t\t\tstart = size;\n\t\t\tgoto out;\n\t\t}\n\t\tpptr = kmap_local_page(page);\n\t\tcurr = pptr;\n\t\tend = pptr + PAGE_CACHE_BITS / 32;\n\t}\nlast:\n\t \n\tmask = 1U << 31;\n\tfor (i = 0; i < len; i++) {\n\t\tif (n & mask)\n\t\t\tbreak;\n\t\tn |= mask;\n\t\tmask >>= 1;\n\t}\ndone:\n\t*curr = cpu_to_be32(n);\n\tset_page_dirty(page);\n\tkunmap_local(pptr);\n\t*max = offset + (curr - pptr) * 32 + i - start;\n\tsbi->free_blocks -= *max;\n\thfsplus_mark_mdb_dirty(sb);\n\thfs_dbg(BITMAP, \"-> %u,%u\\n\", start, *max);\nout:\n\tmutex_unlock(&sbi->alloc_mutex);\n\treturn start;\n}\n\nint hfsplus_block_free(struct super_block *sb, u32 offset, u32 count)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tstruct page *page;\n\tstruct address_space *mapping;\n\t__be32 *pptr, *curr, *end;\n\tu32 mask, len, pnr;\n\tint i;\n\n\t \n\tif (!count)\n\t\treturn 0;\n\n\thfs_dbg(BITMAP, \"block_free: %u,%u\\n\", offset, count);\n\t \n\tif ((offset + count) > sbi->total_blocks)\n\t\treturn -ENOENT;\n\n\tmutex_lock(&sbi->alloc_mutex);\n\tmapping = sbi->alloc_file->i_mapping;\n\tpnr = offset / PAGE_CACHE_BITS;\n\tpage = read_mapping_page(mapping, pnr, NULL);\n\tif (IS_ERR(page))\n\t\tgoto kaboom;\n\tpptr = kmap_local_page(page);\n\tcurr = pptr + (offset & (PAGE_CACHE_BITS - 1)) / 32;\n\tend = pptr + PAGE_CACHE_BITS / 32;\n\tlen = count;\n\n\t \n\ti = offset % 32;\n\tif (i) {\n\t\tint j = 32 - i;\n\t\tmask = 0xffffffffU << j;\n\t\tif (j > count) {\n\t\t\tmask |= 0xffffffffU >> (i + count);\n\t\t\t*curr++ &= cpu_to_be32(mask);\n\t\t\tgoto out;\n\t\t}\n\t\t*curr++ &= cpu_to_be32(mask);\n\t\tcount -= j;\n\t}\n\n\t \n\twhile (1) {\n\t\twhile (curr < end) {\n\t\t\tif (count < 32)\n\t\t\t\tgoto done;\n\t\t\t*curr++ = 0;\n\t\t\tcount -= 32;\n\t\t}\n\t\tif (!count)\n\t\t\tbreak;\n\t\tset_page_dirty(page);\n\t\tkunmap_local(pptr);\n\t\tpage = read_mapping_page(mapping, ++pnr, NULL);\n\t\tif (IS_ERR(page))\n\t\t\tgoto kaboom;\n\t\tpptr = kmap_local_page(page);\n\t\tcurr = pptr;\n\t\tend = pptr + PAGE_CACHE_BITS / 32;\n\t}\ndone:\n\t \n\tif (count) {\n\t\tmask = 0xffffffffU >> count;\n\t\t*curr &= cpu_to_be32(mask);\n\t}\nout:\n\tset_page_dirty(page);\n\tkunmap_local(pptr);\n\tsbi->free_blocks += len;\n\thfsplus_mark_mdb_dirty(sb);\n\tmutex_unlock(&sbi->alloc_mutex);\n\n\treturn 0;\n\nkaboom:\n\tpr_crit(\"unable to mark blocks free: error %ld\\n\", PTR_ERR(page));\n\tmutex_unlock(&sbi->alloc_mutex);\n\n\treturn -EIO;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}