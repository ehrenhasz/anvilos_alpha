{
  "module_name": "dir.c",
  "hash_id": "80d8c674ddb607a36f5ade96354a59fd360b30c3251f0d1ac5a8d8dc4bebb2e5",
  "original_prompt": "Ingested from linux-6.6.14/fs/hfsplus/dir.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/nls.h>\n\n#include \"hfsplus_fs.h\"\n#include \"hfsplus_raw.h\"\n#include \"xattr.h\"\n\nstatic inline void hfsplus_instantiate(struct dentry *dentry,\n\t\t\t\t       struct inode *inode, u32 cnid)\n{\n\tdentry->d_fsdata = (void *)(unsigned long)cnid;\n\td_instantiate(dentry, inode);\n}\n\n \nstatic struct dentry *hfsplus_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t     unsigned int flags)\n{\n\tstruct inode *inode = NULL;\n\tstruct hfs_find_data fd;\n\tstruct super_block *sb;\n\thfsplus_cat_entry entry;\n\tint err;\n\tu32 cnid, linkid = 0;\n\tu16 type;\n\n\tsb = dir->i_sb;\n\n\tdentry->d_fsdata = NULL;\n\terr = hfs_find_init(HFSPLUS_SB(sb)->cat_tree, &fd);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\terr = hfsplus_cat_build_key(sb, fd.search_key, dir->i_ino,\n\t\t\t&dentry->d_name);\n\tif (unlikely(err < 0))\n\t\tgoto fail;\nagain:\n\terr = hfs_brec_read(&fd, &entry, sizeof(entry));\n\tif (err) {\n\t\tif (err == -ENOENT) {\n\t\t\thfs_find_exit(&fd);\n\t\t\t \n\t\t\tinode = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tgoto fail;\n\t}\n\ttype = be16_to_cpu(entry.type);\n\tif (type == HFSPLUS_FOLDER) {\n\t\tif (fd.entrylength < sizeof(struct hfsplus_cat_folder)) {\n\t\t\terr = -EIO;\n\t\t\tgoto fail;\n\t\t}\n\t\tcnid = be32_to_cpu(entry.folder.id);\n\t\tdentry->d_fsdata = (void *)(unsigned long)cnid;\n\t} else if (type == HFSPLUS_FILE) {\n\t\tif (fd.entrylength < sizeof(struct hfsplus_cat_file)) {\n\t\t\terr = -EIO;\n\t\t\tgoto fail;\n\t\t}\n\t\tcnid = be32_to_cpu(entry.file.id);\n\t\tif (entry.file.user_info.fdType ==\n\t\t\t\tcpu_to_be32(HFSP_HARDLINK_TYPE) &&\n\t\t\t\tentry.file.user_info.fdCreator ==\n\t\t\t\tcpu_to_be32(HFSP_HFSPLUS_CREATOR) &&\n\t\t\t\tHFSPLUS_SB(sb)->hidden_dir &&\n\t\t\t\t(entry.file.create_date ==\n\t\t\t\t\tHFSPLUS_I(HFSPLUS_SB(sb)->hidden_dir)->\n\t\t\t\t\t\tcreate_date ||\n\t\t\t\tentry.file.create_date ==\n\t\t\t\t\tHFSPLUS_I(d_inode(sb->s_root))->\n\t\t\t\t\t\tcreate_date)) {\n\t\t\tstruct qstr str;\n\t\t\tchar name[32];\n\n\t\t\tif (dentry->d_fsdata) {\n\t\t\t\t \n\t\t\t\tcnid = (unsigned long)dentry->d_fsdata;\n\t\t\t\tlinkid = 0;\n\t\t\t} else {\n\t\t\t\tdentry->d_fsdata = (void *)(unsigned long)cnid;\n\t\t\t\tlinkid =\n\t\t\t\t\tbe32_to_cpu(entry.file.permissions.dev);\n\t\t\t\tstr.len = sprintf(name, \"iNode%d\", linkid);\n\t\t\t\tstr.name = name;\n\t\t\t\terr = hfsplus_cat_build_key(sb, fd.search_key,\n\t\t\t\t\tHFSPLUS_SB(sb)->hidden_dir->i_ino,\n\t\t\t\t\t&str);\n\t\t\t\tif (unlikely(err < 0))\n\t\t\t\t\tgoto fail;\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t} else if (!dentry->d_fsdata)\n\t\t\tdentry->d_fsdata = (void *)(unsigned long)cnid;\n\t} else {\n\t\tpr_err(\"invalid catalog entry type in lookup\\n\");\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\thfs_find_exit(&fd);\n\tinode = hfsplus_iget(dir->i_sb, cnid);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\tif (S_ISREG(inode->i_mode))\n\t\tHFSPLUS_I(inode)->linkid = linkid;\nout:\n\treturn d_splice_alias(inode, dentry);\nfail:\n\thfs_find_exit(&fd);\n\treturn ERR_PTR(err);\n}\n\nstatic int hfsplus_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct super_block *sb = inode->i_sb;\n\tint len, err;\n\tchar *strbuf;\n\thfsplus_cat_entry entry;\n\tstruct hfs_find_data fd;\n\tstruct hfsplus_readdir_data *rd;\n\tu16 type;\n\n\tif (file->f_pos >= inode->i_size)\n\t\treturn 0;\n\n\terr = hfs_find_init(HFSPLUS_SB(sb)->cat_tree, &fd);\n\tif (err)\n\t\treturn err;\n\tstrbuf = kmalloc(NLS_MAX_CHARSET_SIZE * HFSPLUS_MAX_STRLEN + 1, GFP_KERNEL);\n\tif (!strbuf) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\thfsplus_cat_build_key_with_cnid(sb, fd.search_key, inode->i_ino);\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\n\tif (ctx->pos == 0) {\n\t\t \n\t\tif (!dir_emit_dot(file, ctx))\n\t\t\tgoto out;\n\t\tctx->pos = 1;\n\t}\n\tif (ctx->pos == 1) {\n\t\tif (fd.entrylength > sizeof(entry) || fd.entrylength < 0) {\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\thfs_bnode_read(fd.bnode, &entry, fd.entryoffset,\n\t\t\tfd.entrylength);\n\t\tif (be16_to_cpu(entry.type) != HFSPLUS_FOLDER_THREAD) {\n\t\t\tpr_err(\"bad catalog folder thread\\n\");\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tif (fd.entrylength < HFSPLUS_MIN_THREAD_SZ) {\n\t\t\tpr_err(\"truncated catalog thread\\n\");\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!dir_emit(ctx, \"..\", 2,\n\t\t\t    be32_to_cpu(entry.thread.parentID), DT_DIR))\n\t\t\tgoto out;\n\t\tctx->pos = 2;\n\t}\n\tif (ctx->pos >= inode->i_size)\n\t\tgoto out;\n\terr = hfs_brec_goto(&fd, ctx->pos - 1);\n\tif (err)\n\t\tgoto out;\n\tfor (;;) {\n\t\tif (be32_to_cpu(fd.key->cat.parent) != inode->i_ino) {\n\t\t\tpr_err(\"walked past end of dir\\n\");\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (fd.entrylength > sizeof(entry) || fd.entrylength < 0) {\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\thfs_bnode_read(fd.bnode, &entry, fd.entryoffset,\n\t\t\tfd.entrylength);\n\t\ttype = be16_to_cpu(entry.type);\n\t\tlen = NLS_MAX_CHARSET_SIZE * HFSPLUS_MAX_STRLEN;\n\t\terr = hfsplus_uni2asc(sb, &fd.key->cat.name, strbuf, &len);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (type == HFSPLUS_FOLDER) {\n\t\t\tif (fd.entrylength <\n\t\t\t\t\tsizeof(struct hfsplus_cat_folder)) {\n\t\t\t\tpr_err(\"small dir entry\\n\");\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (HFSPLUS_SB(sb)->hidden_dir &&\n\t\t\t    HFSPLUS_SB(sb)->hidden_dir->i_ino ==\n\t\t\t\t\tbe32_to_cpu(entry.folder.id))\n\t\t\t\tgoto next;\n\t\t\tif (!dir_emit(ctx, strbuf, len,\n\t\t\t\t    be32_to_cpu(entry.folder.id), DT_DIR))\n\t\t\t\tbreak;\n\t\t} else if (type == HFSPLUS_FILE) {\n\t\t\tu16 mode;\n\t\t\tunsigned type = DT_UNKNOWN;\n\n\t\t\tif (fd.entrylength < sizeof(struct hfsplus_cat_file)) {\n\t\t\t\tpr_err(\"small file entry\\n\");\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tmode = be16_to_cpu(entry.file.permissions.mode);\n\t\t\tif (S_ISREG(mode))\n\t\t\t\ttype = DT_REG;\n\t\t\telse if (S_ISLNK(mode))\n\t\t\t\ttype = DT_LNK;\n\t\t\telse if (S_ISFIFO(mode))\n\t\t\t\ttype = DT_FIFO;\n\t\t\telse if (S_ISCHR(mode))\n\t\t\t\ttype = DT_CHR;\n\t\t\telse if (S_ISBLK(mode))\n\t\t\t\ttype = DT_BLK;\n\t\t\telse if (S_ISSOCK(mode))\n\t\t\t\ttype = DT_SOCK;\n\n\t\t\tif (!dir_emit(ctx, strbuf, len,\n\t\t\t\t      be32_to_cpu(entry.file.id), type))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tpr_err(\"bad catalog entry type\\n\");\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\nnext:\n\t\tctx->pos++;\n\t\tif (ctx->pos >= inode->i_size)\n\t\t\tgoto out;\n\t\terr = hfs_brec_goto(&fd, 1);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\trd = file->private_data;\n\tif (!rd) {\n\t\trd = kmalloc(sizeof(struct hfsplus_readdir_data), GFP_KERNEL);\n\t\tif (!rd) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tfile->private_data = rd;\n\t\trd->file = file;\n\t\tspin_lock(&HFSPLUS_I(inode)->open_dir_lock);\n\t\tlist_add(&rd->list, &HFSPLUS_I(inode)->open_dir_list);\n\t\tspin_unlock(&HFSPLUS_I(inode)->open_dir_lock);\n\t}\n\t \n\tmemcpy(&rd->key, fd.key, sizeof(struct hfsplus_cat_key));\nout:\n\tkfree(strbuf);\n\thfs_find_exit(&fd);\n\treturn err;\n}\n\nstatic int hfsplus_dir_release(struct inode *inode, struct file *file)\n{\n\tstruct hfsplus_readdir_data *rd = file->private_data;\n\tif (rd) {\n\t\tspin_lock(&HFSPLUS_I(inode)->open_dir_lock);\n\t\tlist_del(&rd->list);\n\t\tspin_unlock(&HFSPLUS_I(inode)->open_dir_lock);\n\t\tkfree(rd);\n\t}\n\treturn 0;\n}\n\nstatic int hfsplus_link(struct dentry *src_dentry, struct inode *dst_dir,\n\t\t\tstruct dentry *dst_dentry)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(dst_dir->i_sb);\n\tstruct inode *inode = d_inode(src_dentry);\n\tstruct inode *src_dir = d_inode(src_dentry->d_parent);\n\tstruct qstr str;\n\tchar name[32];\n\tu32 cnid, id;\n\tint res;\n\n\tif (HFSPLUS_IS_RSRC(inode))\n\t\treturn -EPERM;\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EPERM;\n\n\tmutex_lock(&sbi->vh_mutex);\n\tif (inode->i_ino == (u32)(unsigned long)src_dentry->d_fsdata) {\n\t\tfor (;;) {\n\t\t\tget_random_bytes(&id, sizeof(cnid));\n\t\t\tid &= 0x3fffffff;\n\t\t\tstr.name = name;\n\t\t\tstr.len = sprintf(name, \"iNode%d\", id);\n\t\t\tres = hfsplus_rename_cat(inode->i_ino,\n\t\t\t\t\t\t src_dir, &src_dentry->d_name,\n\t\t\t\t\t\t sbi->hidden_dir, &str);\n\t\t\tif (!res)\n\t\t\t\tbreak;\n\t\t\tif (res != -EEXIST)\n\t\t\t\tgoto out;\n\t\t}\n\t\tHFSPLUS_I(inode)->linkid = id;\n\t\tcnid = sbi->next_cnid++;\n\t\tsrc_dentry->d_fsdata = (void *)(unsigned long)cnid;\n\t\tres = hfsplus_create_cat(cnid, src_dir,\n\t\t\t&src_dentry->d_name, inode);\n\t\tif (res)\n\t\t\t \n\t\t\tgoto out;\n\t\tsbi->file_count++;\n\t}\n\tcnid = sbi->next_cnid++;\n\tres = hfsplus_create_cat(cnid, dst_dir, &dst_dentry->d_name, inode);\n\tif (res)\n\t\tgoto out;\n\n\tinc_nlink(inode);\n\thfsplus_instantiate(dst_dentry, inode, cnid);\n\tihold(inode);\n\tinode_set_ctime_current(inode);\n\tmark_inode_dirty(inode);\n\tsbi->file_count++;\n\thfsplus_mark_mdb_dirty(dst_dir->i_sb);\nout:\n\tmutex_unlock(&sbi->vh_mutex);\n\treturn res;\n}\n\nstatic int hfsplus_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(dir->i_sb);\n\tstruct inode *inode = d_inode(dentry);\n\tstruct qstr str;\n\tchar name[32];\n\tu32 cnid;\n\tint res;\n\n\tif (HFSPLUS_IS_RSRC(inode))\n\t\treturn -EPERM;\n\n\tmutex_lock(&sbi->vh_mutex);\n\tcnid = (u32)(unsigned long)dentry->d_fsdata;\n\tif (inode->i_ino == cnid &&\n\t    atomic_read(&HFSPLUS_I(inode)->opencnt)) {\n\t\tstr.name = name;\n\t\tstr.len = sprintf(name, \"temp%lu\", inode->i_ino);\n\t\tres = hfsplus_rename_cat(inode->i_ino,\n\t\t\t\t\t dir, &dentry->d_name,\n\t\t\t\t\t sbi->hidden_dir, &str);\n\t\tif (!res) {\n\t\t\tinode->i_flags |= S_DEAD;\n\t\t\tdrop_nlink(inode);\n\t\t}\n\t\tgoto out;\n\t}\n\tres = hfsplus_delete_cat(cnid, dir, &dentry->d_name);\n\tif (res)\n\t\tgoto out;\n\n\tif (inode->i_nlink > 0)\n\t\tdrop_nlink(inode);\n\tif (inode->i_ino == cnid)\n\t\tclear_nlink(inode);\n\tif (!inode->i_nlink) {\n\t\tif (inode->i_ino != cnid) {\n\t\t\tsbi->file_count--;\n\t\t\tif (!atomic_read(&HFSPLUS_I(inode)->opencnt)) {\n\t\t\t\tres = hfsplus_delete_cat(inode->i_ino,\n\t\t\t\t\t\t\t sbi->hidden_dir,\n\t\t\t\t\t\t\t NULL);\n\t\t\t\tif (!res)\n\t\t\t\t\thfsplus_delete_inode(inode);\n\t\t\t} else\n\t\t\t\tinode->i_flags |= S_DEAD;\n\t\t} else\n\t\t\thfsplus_delete_inode(inode);\n\t} else\n\t\tsbi->file_count--;\n\tinode_set_ctime_current(inode);\n\tmark_inode_dirty(inode);\nout:\n\tmutex_unlock(&sbi->vh_mutex);\n\treturn res;\n}\n\nstatic int hfsplus_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(dir->i_sb);\n\tstruct inode *inode = d_inode(dentry);\n\tint res;\n\n\tif (inode->i_size != 2)\n\t\treturn -ENOTEMPTY;\n\n\tmutex_lock(&sbi->vh_mutex);\n\tres = hfsplus_delete_cat(inode->i_ino, dir, &dentry->d_name);\n\tif (res)\n\t\tgoto out;\n\tclear_nlink(inode);\n\tinode_set_ctime_current(inode);\n\thfsplus_delete_inode(inode);\n\tmark_inode_dirty(inode);\nout:\n\tmutex_unlock(&sbi->vh_mutex);\n\treturn res;\n}\n\nstatic int hfsplus_symlink(struct mnt_idmap *idmap, struct inode *dir,\n\t\t\t   struct dentry *dentry, const char *symname)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(dir->i_sb);\n\tstruct inode *inode;\n\tint res = -ENOMEM;\n\n\tmutex_lock(&sbi->vh_mutex);\n\tinode = hfsplus_new_inode(dir->i_sb, dir, S_IFLNK | S_IRWXUGO);\n\tif (!inode)\n\t\tgoto out;\n\n\tres = page_symlink(inode, symname, strlen(symname) + 1);\n\tif (res)\n\t\tgoto out_err;\n\n\tres = hfsplus_create_cat(inode->i_ino, dir, &dentry->d_name, inode);\n\tif (res)\n\t\tgoto out_err;\n\n\tres = hfsplus_init_security(inode, dir, &dentry->d_name);\n\tif (res == -EOPNOTSUPP)\n\t\tres = 0;  \n\telse if (res) {\n\t\t \n\t\thfsplus_delete_cat(inode->i_ino, dir, &dentry->d_name);\n\t\tgoto out_err;\n\t}\n\n\thfsplus_instantiate(dentry, inode, inode->i_ino);\n\tmark_inode_dirty(inode);\n\tgoto out;\n\nout_err:\n\tclear_nlink(inode);\n\thfsplus_delete_inode(inode);\n\tiput(inode);\nout:\n\tmutex_unlock(&sbi->vh_mutex);\n\treturn res;\n}\n\nstatic int hfsplus_mknod(struct mnt_idmap *idmap, struct inode *dir,\n\t\t\t struct dentry *dentry, umode_t mode, dev_t rdev)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(dir->i_sb);\n\tstruct inode *inode;\n\tint res = -ENOMEM;\n\n\tmutex_lock(&sbi->vh_mutex);\n\tinode = hfsplus_new_inode(dir->i_sb, dir, mode);\n\tif (!inode)\n\t\tgoto out;\n\n\tif (S_ISBLK(mode) || S_ISCHR(mode) || S_ISFIFO(mode) || S_ISSOCK(mode))\n\t\tinit_special_inode(inode, mode, rdev);\n\n\tres = hfsplus_create_cat(inode->i_ino, dir, &dentry->d_name, inode);\n\tif (res)\n\t\tgoto failed_mknod;\n\n\tres = hfsplus_init_security(inode, dir, &dentry->d_name);\n\tif (res == -EOPNOTSUPP)\n\t\tres = 0;  \n\telse if (res) {\n\t\t \n\t\thfsplus_delete_cat(inode->i_ino, dir, &dentry->d_name);\n\t\tgoto failed_mknod;\n\t}\n\n\thfsplus_instantiate(dentry, inode, inode->i_ino);\n\tmark_inode_dirty(inode);\n\tgoto out;\n\nfailed_mknod:\n\tclear_nlink(inode);\n\thfsplus_delete_inode(inode);\n\tiput(inode);\nout:\n\tmutex_unlock(&sbi->vh_mutex);\n\treturn res;\n}\n\nstatic int hfsplus_create(struct mnt_idmap *idmap, struct inode *dir,\n\t\t\t  struct dentry *dentry, umode_t mode, bool excl)\n{\n\treturn hfsplus_mknod(&nop_mnt_idmap, dir, dentry, mode, 0);\n}\n\nstatic int hfsplus_mkdir(struct mnt_idmap *idmap, struct inode *dir,\n\t\t\t struct dentry *dentry, umode_t mode)\n{\n\treturn hfsplus_mknod(&nop_mnt_idmap, dir, dentry, mode | S_IFDIR, 0);\n}\n\nstatic int hfsplus_rename(struct mnt_idmap *idmap,\n\t\t\t  struct inode *old_dir, struct dentry *old_dentry,\n\t\t\t  struct inode *new_dir, struct dentry *new_dentry,\n\t\t\t  unsigned int flags)\n{\n\tint res;\n\n\tif (flags & ~RENAME_NOREPLACE)\n\t\treturn -EINVAL;\n\n\t \n\tif (d_really_is_positive(new_dentry)) {\n\t\tif (d_is_dir(new_dentry))\n\t\t\tres = hfsplus_rmdir(new_dir, new_dentry);\n\t\telse\n\t\t\tres = hfsplus_unlink(new_dir, new_dentry);\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\n\tres = hfsplus_rename_cat((u32)(unsigned long)old_dentry->d_fsdata,\n\t\t\t\t old_dir, &old_dentry->d_name,\n\t\t\t\t new_dir, &new_dentry->d_name);\n\tif (!res)\n\t\tnew_dentry->d_fsdata = old_dentry->d_fsdata;\n\treturn res;\n}\n\nconst struct inode_operations hfsplus_dir_inode_operations = {\n\t.lookup\t\t\t= hfsplus_lookup,\n\t.create\t\t\t= hfsplus_create,\n\t.link\t\t\t= hfsplus_link,\n\t.unlink\t\t\t= hfsplus_unlink,\n\t.mkdir\t\t\t= hfsplus_mkdir,\n\t.rmdir\t\t\t= hfsplus_rmdir,\n\t.symlink\t\t= hfsplus_symlink,\n\t.mknod\t\t\t= hfsplus_mknod,\n\t.rename\t\t\t= hfsplus_rename,\n\t.getattr\t\t= hfsplus_getattr,\n\t.listxattr\t\t= hfsplus_listxattr,\n\t.fileattr_get\t\t= hfsplus_fileattr_get,\n\t.fileattr_set\t\t= hfsplus_fileattr_set,\n};\n\nconst struct file_operations hfsplus_dir_operations = {\n\t.fsync\t\t= hfsplus_file_fsync,\n\t.read\t\t= generic_read_dir,\n\t.iterate_shared\t= hfsplus_readdir,\n\t.unlocked_ioctl = hfsplus_ioctl,\n\t.llseek\t\t= generic_file_llseek,\n\t.release\t= hfsplus_dir_release,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}