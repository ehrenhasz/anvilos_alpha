{
  "module_name": "attributes.c",
  "hash_id": "38d50a849794bc5bc981c8011cc5c03b97d8430c4d5ba1884ca19e7209510ade",
  "original_prompt": "Ingested from linux-6.6.14/fs/hfsplus/attributes.c",
  "human_readable_source": "\n \n\n#include \"hfsplus_fs.h\"\n#include \"hfsplus_raw.h\"\n\nstatic struct kmem_cache *hfsplus_attr_tree_cachep;\n\nint __init hfsplus_create_attr_tree_cache(void)\n{\n\tif (hfsplus_attr_tree_cachep)\n\t\treturn -EEXIST;\n\n\thfsplus_attr_tree_cachep =\n\t\tkmem_cache_create(\"hfsplus_attr_cache\",\n\t\t\tsizeof(hfsplus_attr_entry), 0,\n\t\t\tSLAB_HWCACHE_ALIGN, NULL);\n\tif (!hfsplus_attr_tree_cachep)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nvoid hfsplus_destroy_attr_tree_cache(void)\n{\n\tkmem_cache_destroy(hfsplus_attr_tree_cachep);\n}\n\nint hfsplus_attr_bin_cmp_key(const hfsplus_btree_key *k1,\n\t\t\t\tconst hfsplus_btree_key *k2)\n{\n\t__be32 k1_cnid, k2_cnid;\n\n\tk1_cnid = k1->attr.cnid;\n\tk2_cnid = k2->attr.cnid;\n\tif (k1_cnid != k2_cnid)\n\t\treturn be32_to_cpu(k1_cnid) < be32_to_cpu(k2_cnid) ? -1 : 1;\n\n\treturn hfsplus_strcmp(\n\t\t\t(const struct hfsplus_unistr *)&k1->attr.key_name,\n\t\t\t(const struct hfsplus_unistr *)&k2->attr.key_name);\n}\n\nint hfsplus_attr_build_key(struct super_block *sb, hfsplus_btree_key *key,\n\t\t\tu32 cnid, const char *name)\n{\n\tint len;\n\n\tmemset(key, 0, sizeof(struct hfsplus_attr_key));\n\tkey->attr.cnid = cpu_to_be32(cnid);\n\tif (name) {\n\t\tint res = hfsplus_asc2uni(sb,\n\t\t\t\t(struct hfsplus_unistr *)&key->attr.key_name,\n\t\t\t\tHFSPLUS_ATTR_MAX_STRLEN, name, strlen(name));\n\t\tif (res)\n\t\t\treturn res;\n\t\tlen = be16_to_cpu(key->attr.key_name.length);\n\t} else {\n\t\tkey->attr.key_name.length = 0;\n\t\tlen = 0;\n\t}\n\n\t \n\tkey->key_len =\n\t\tcpu_to_be16(offsetof(struct hfsplus_attr_key, key_name) +\n\t\t\t\t2 * len);\n\n\treturn 0;\n}\n\nhfsplus_attr_entry *hfsplus_alloc_attr_entry(void)\n{\n\treturn kmem_cache_alloc(hfsplus_attr_tree_cachep, GFP_KERNEL);\n}\n\nvoid hfsplus_destroy_attr_entry(hfsplus_attr_entry *entry)\n{\n\tif (entry)\n\t\tkmem_cache_free(hfsplus_attr_tree_cachep, entry);\n}\n\n#define HFSPLUS_INVALID_ATTR_RECORD -1\n\nstatic int hfsplus_attr_build_record(hfsplus_attr_entry *entry, int record_type,\n\t\t\t\tu32 cnid, const void *value, size_t size)\n{\n\tif (record_type == HFSPLUS_ATTR_FORK_DATA) {\n\t\t \n\t\tmemset(entry, 0, sizeof(*entry));\n\t\treturn sizeof(struct hfsplus_attr_fork_data);\n\t} else if (record_type == HFSPLUS_ATTR_EXTENTS) {\n\t\t \n\t\tmemset(entry, 0, sizeof(*entry));\n\t\treturn sizeof(struct hfsplus_attr_extents);\n\t} else if (record_type == HFSPLUS_ATTR_INLINE_DATA) {\n\t\tu16 len;\n\n\t\tmemset(entry, 0, sizeof(struct hfsplus_attr_inline_data));\n\t\tentry->inline_data.record_type = cpu_to_be32(record_type);\n\t\tif (size <= HFSPLUS_MAX_INLINE_DATA_SIZE)\n\t\t\tlen = size;\n\t\telse\n\t\t\treturn HFSPLUS_INVALID_ATTR_RECORD;\n\t\tentry->inline_data.length = cpu_to_be16(len);\n\t\tmemcpy(entry->inline_data.raw_bytes, value, len);\n\t\t \n\t\tlen = round_up(len, 2);\n\t\treturn offsetof(struct hfsplus_attr_inline_data, raw_bytes) +\n\t\t\t\t\tlen;\n\t} else  \n\t\tmemset(entry, 0, sizeof(*entry));\n\n\treturn HFSPLUS_INVALID_ATTR_RECORD;\n}\n\nint hfsplus_find_attr(struct super_block *sb, u32 cnid,\n\t\t\tconst char *name, struct hfs_find_data *fd)\n{\n\tint err = 0;\n\n\thfs_dbg(ATTR_MOD, \"find_attr: %s,%d\\n\", name ? name : NULL, cnid);\n\n\tif (!HFSPLUS_SB(sb)->attr_tree) {\n\t\tpr_err(\"attributes file doesn't exist\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (name) {\n\t\terr = hfsplus_attr_build_key(sb, fd->search_key, cnid, name);\n\t\tif (err)\n\t\t\tgoto failed_find_attr;\n\t\terr = hfs_brec_find(fd, hfs_find_rec_by_key);\n\t\tif (err)\n\t\t\tgoto failed_find_attr;\n\t} else {\n\t\terr = hfsplus_attr_build_key(sb, fd->search_key, cnid, NULL);\n\t\tif (err)\n\t\t\tgoto failed_find_attr;\n\t\terr = hfs_brec_find(fd, hfs_find_1st_rec_by_cnid);\n\t\tif (err)\n\t\t\tgoto failed_find_attr;\n\t}\n\nfailed_find_attr:\n\treturn err;\n}\n\nint hfsplus_attr_exists(struct inode *inode, const char *name)\n{\n\tint err = 0;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfs_find_data fd;\n\n\tif (!HFSPLUS_SB(sb)->attr_tree)\n\t\treturn 0;\n\n\terr = hfs_find_init(HFSPLUS_SB(sb)->attr_tree, &fd);\n\tif (err)\n\t\treturn 0;\n\n\terr = hfsplus_find_attr(sb, inode->i_ino, name, &fd);\n\tif (err)\n\t\tgoto attr_not_found;\n\n\thfs_find_exit(&fd);\n\treturn 1;\n\nattr_not_found:\n\thfs_find_exit(&fd);\n\treturn 0;\n}\n\nint hfsplus_create_attr(struct inode *inode,\n\t\t\t\tconst char *name,\n\t\t\t\tconst void *value, size_t size)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfs_find_data fd;\n\thfsplus_attr_entry *entry_ptr;\n\tint entry_size;\n\tint err;\n\n\thfs_dbg(ATTR_MOD, \"create_attr: %s,%ld\\n\",\n\t\tname ? name : NULL, inode->i_ino);\n\n\tif (!HFSPLUS_SB(sb)->attr_tree) {\n\t\tpr_err(\"attributes file doesn't exist\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tentry_ptr = hfsplus_alloc_attr_entry();\n\tif (!entry_ptr)\n\t\treturn -ENOMEM;\n\n\terr = hfs_find_init(HFSPLUS_SB(sb)->attr_tree, &fd);\n\tif (err)\n\t\tgoto failed_init_create_attr;\n\n\t \n\terr = hfs_bmap_reserve(fd.tree, fd.tree->depth + 1);\n\tif (err)\n\t\tgoto failed_create_attr;\n\n\tif (name) {\n\t\terr = hfsplus_attr_build_key(sb, fd.search_key,\n\t\t\t\t\t\tinode->i_ino, name);\n\t\tif (err)\n\t\t\tgoto failed_create_attr;\n\t} else {\n\t\terr = -EINVAL;\n\t\tgoto failed_create_attr;\n\t}\n\n\t \n\tentry_size = hfsplus_attr_build_record(entry_ptr,\n\t\t\t\t\tHFSPLUS_ATTR_INLINE_DATA,\n\t\t\t\t\tinode->i_ino,\n\t\t\t\t\tvalue, size);\n\tif (entry_size == HFSPLUS_INVALID_ATTR_RECORD) {\n\t\terr = -EINVAL;\n\t\tgoto failed_create_attr;\n\t}\n\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto failed_create_attr;\n\t}\n\n\terr = hfs_brec_insert(&fd, entry_ptr, entry_size);\n\tif (err)\n\t\tgoto failed_create_attr;\n\n\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_ATTR_DIRTY);\n\nfailed_create_attr:\n\thfs_find_exit(&fd);\n\nfailed_init_create_attr:\n\thfsplus_destroy_attr_entry(entry_ptr);\n\treturn err;\n}\n\nstatic int __hfsplus_delete_attr(struct inode *inode, u32 cnid,\n\t\t\t\t\tstruct hfs_find_data *fd)\n{\n\tint err = 0;\n\t__be32 found_cnid, record_type;\n\n\thfs_bnode_read(fd->bnode, &found_cnid,\n\t\t\tfd->keyoffset +\n\t\t\toffsetof(struct hfsplus_attr_key, cnid),\n\t\t\tsizeof(__be32));\n\tif (cnid != be32_to_cpu(found_cnid))\n\t\treturn -ENOENT;\n\n\thfs_bnode_read(fd->bnode, &record_type,\n\t\t\tfd->entryoffset, sizeof(record_type));\n\n\tswitch (be32_to_cpu(record_type)) {\n\tcase HFSPLUS_ATTR_INLINE_DATA:\n\t\t \n\t\tbreak;\n\tcase HFSPLUS_ATTR_FORK_DATA:\n\tcase HFSPLUS_ATTR_EXTENTS:\n\t\tpr_err(\"only inline data xattr are supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\tdefault:\n\t\tpr_err(\"invalid extended attribute record\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\t \n\thfs_bnode_read(fd->bnode, fd->search_key,\n\t\t\tfd->keyoffset, fd->keylength);\n\n\terr = hfs_brec_remove(fd);\n\tif (err)\n\t\treturn err;\n\n\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_ATTR_DIRTY);\n\treturn err;\n}\n\nint hfsplus_delete_attr(struct inode *inode, const char *name)\n{\n\tint err = 0;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfs_find_data fd;\n\n\thfs_dbg(ATTR_MOD, \"delete_attr: %s,%ld\\n\",\n\t\tname ? name : NULL, inode->i_ino);\n\n\tif (!HFSPLUS_SB(sb)->attr_tree) {\n\t\tpr_err(\"attributes file doesn't exist\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = hfs_find_init(HFSPLUS_SB(sb)->attr_tree, &fd);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = hfs_bmap_reserve(fd.tree, fd.tree->depth);\n\tif (err)\n\t\tgoto out;\n\n\tif (name) {\n\t\terr = hfsplus_attr_build_key(sb, fd.search_key,\n\t\t\t\t\t\tinode->i_ino, name);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\tpr_err(\"invalid extended attribute name\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\n\terr = __hfsplus_delete_attr(inode, inode->i_ino, &fd);\n\tif (err)\n\t\tgoto out;\n\nout:\n\thfs_find_exit(&fd);\n\treturn err;\n}\n\nint hfsplus_delete_all_attrs(struct inode *dir, u32 cnid)\n{\n\tint err = 0;\n\tstruct hfs_find_data fd;\n\n\thfs_dbg(ATTR_MOD, \"delete_all_attrs: %d\\n\", cnid);\n\n\tif (!HFSPLUS_SB(dir->i_sb)->attr_tree) {\n\t\tpr_err(\"attributes file doesn't exist\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = hfs_find_init(HFSPLUS_SB(dir->i_sb)->attr_tree, &fd);\n\tif (err)\n\t\treturn err;\n\n\tfor (;;) {\n\t\terr = hfsplus_find_attr(dir->i_sb, cnid, NULL, &fd);\n\t\tif (err) {\n\t\t\tif (err != -ENOENT)\n\t\t\t\tpr_err(\"xattr search failed\\n\");\n\t\t\tgoto end_delete_all;\n\t\t}\n\n\t\terr = __hfsplus_delete_attr(dir, cnid, &fd);\n\t\tif (err)\n\t\t\tgoto end_delete_all;\n\t}\n\nend_delete_all:\n\thfs_find_exit(&fd);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}