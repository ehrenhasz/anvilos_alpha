{
  "module_name": "btree.c",
  "hash_id": "e1e60f3d054b5439d93196f135c08df5b52b3afde724cdd659998307b7ec22cf",
  "original_prompt": "Ingested from linux-6.6.14/fs/hfsplus/btree.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/log2.h>\n\n#include \"hfsplus_fs.h\"\n#include \"hfsplus_raw.h\"\n\n \n#define CLUMP_ENTRIES\t15\n\nstatic short clumptbl[CLUMP_ENTRIES * 3] = {\n \n\t \t  4,\t\t  4,\t\t 4,\n\t \t  6,\t\t  6,\t\t 4,\n\t \t  8,\t\t  8,\t\t 4,\n\t \t 11,\t\t 11,\t\t 5,\n\t \n\t \t 64,\t\t 32,\t\t 5,\n\t \t 84,\t\t 49,\t\t 6,\n\t \t111,\t\t 74,\t\t 7,\n\t \t147,\t\t111,\t\t 8,\n\t \t194,\t\t169,\t\t 9,\n\t \t256,\t\t256,\t\t11,\n\t \t294,\t\t294,\t\t14,\n\t \t338,\t\t338,\t\t16,\n\t \t388,\t\t388,\t\t20,\n\t \t446,\t\t446,\t\t25,\n\t \t512,\t\t512,\t\t32\n};\n\nu32 hfsplus_calc_btree_clump_size(u32 block_size, u32 node_size,\n\t\t\t\t\tu64 sectors, int file_id)\n{\n\tu32 mod = max(node_size, block_size);\n\tu32 clump_size;\n\tint column;\n\tint i;\n\n\t \n\tswitch (file_id) {\n\tcase HFSPLUS_ATTR_CNID:\n\t\tcolumn = 0;\n\t\tbreak;\n\tcase HFSPLUS_CAT_CNID:\n\t\tcolumn = 1;\n\t\tbreak;\n\tdefault:\n\t\tcolumn = 2;\n\t\tbreak;\n\t}\n\n\t \n\tif (sectors < 0x200000) {\n\t\tclump_size = sectors << 2;\t \n\t\tif (clump_size < (8 * node_size))\n\t\t\tclump_size = 8 * node_size;\n\t} else {\n\t\t \n\t\tfor (i = 0, sectors = sectors >> 22;\n\t\t     sectors && (i < CLUMP_ENTRIES - 1);\n\t\t     ++i, sectors = sectors >> 1) {\n\t\t\t \n\t\t}\n\n\t\tclump_size = clumptbl[column + (i) * 3] * 1024 * 1024;\n\t}\n\n\t \n\tclump_size /= mod;\n\tclump_size *= mod;\n\n\t \n\tif (clump_size == 0)\n\t\tclump_size = mod;\n\n\treturn clump_size;\n}\n\n \nstruct hfs_btree *hfs_btree_open(struct super_block *sb, u32 id)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_btree_header_rec *head;\n\tstruct address_space *mapping;\n\tstruct inode *inode;\n\tstruct page *page;\n\tunsigned int size;\n\n\ttree = kzalloc(sizeof(*tree), GFP_KERNEL);\n\tif (!tree)\n\t\treturn NULL;\n\n\tmutex_init(&tree->tree_lock);\n\tspin_lock_init(&tree->hash_lock);\n\ttree->sb = sb;\n\ttree->cnid = id;\n\tinode = hfsplus_iget(sb, id);\n\tif (IS_ERR(inode))\n\t\tgoto free_tree;\n\ttree->inode = inode;\n\n\tif (!HFSPLUS_I(tree->inode)->first_blocks) {\n\t\tpr_err(\"invalid btree extent records (0 size)\\n\");\n\t\tgoto free_inode;\n\t}\n\n\tmapping = tree->inode->i_mapping;\n\tpage = read_mapping_page(mapping, 0, NULL);\n\tif (IS_ERR(page))\n\t\tgoto free_inode;\n\n\t \n\thead = (struct hfs_btree_header_rec *)(kmap_local_page(page) +\n\t\tsizeof(struct hfs_bnode_desc));\n\ttree->root = be32_to_cpu(head->root);\n\ttree->leaf_count = be32_to_cpu(head->leaf_count);\n\ttree->leaf_head = be32_to_cpu(head->leaf_head);\n\ttree->leaf_tail = be32_to_cpu(head->leaf_tail);\n\ttree->node_count = be32_to_cpu(head->node_count);\n\ttree->free_nodes = be32_to_cpu(head->free_nodes);\n\ttree->attributes = be32_to_cpu(head->attributes);\n\ttree->node_size = be16_to_cpu(head->node_size);\n\ttree->max_key_len = be16_to_cpu(head->max_key_len);\n\ttree->depth = be16_to_cpu(head->depth);\n\n\t \n\tswitch (id) {\n\tcase HFSPLUS_EXT_CNID:\n\t\tif (tree->max_key_len != HFSPLUS_EXT_KEYLEN - sizeof(u16)) {\n\t\t\tpr_err(\"invalid extent max_key_len %d\\n\",\n\t\t\t\ttree->max_key_len);\n\t\t\tgoto fail_page;\n\t\t}\n\t\tif (tree->attributes & HFS_TREE_VARIDXKEYS) {\n\t\t\tpr_err(\"invalid extent btree flag\\n\");\n\t\t\tgoto fail_page;\n\t\t}\n\n\t\ttree->keycmp = hfsplus_ext_cmp_key;\n\t\tbreak;\n\tcase HFSPLUS_CAT_CNID:\n\t\tif (tree->max_key_len != HFSPLUS_CAT_KEYLEN - sizeof(u16)) {\n\t\t\tpr_err(\"invalid catalog max_key_len %d\\n\",\n\t\t\t\ttree->max_key_len);\n\t\t\tgoto fail_page;\n\t\t}\n\t\tif (!(tree->attributes & HFS_TREE_VARIDXKEYS)) {\n\t\t\tpr_err(\"invalid catalog btree flag\\n\");\n\t\t\tgoto fail_page;\n\t\t}\n\n\t\tif (test_bit(HFSPLUS_SB_HFSX, &HFSPLUS_SB(sb)->flags) &&\n\t\t    (head->key_type == HFSPLUS_KEY_BINARY))\n\t\t\ttree->keycmp = hfsplus_cat_bin_cmp_key;\n\t\telse {\n\t\t\ttree->keycmp = hfsplus_cat_case_cmp_key;\n\t\t\tset_bit(HFSPLUS_SB_CASEFOLD, &HFSPLUS_SB(sb)->flags);\n\t\t}\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\tif (tree->max_key_len != HFSPLUS_ATTR_KEYLEN - sizeof(u16)) {\n\t\t\tpr_err(\"invalid attributes max_key_len %d\\n\",\n\t\t\t\ttree->max_key_len);\n\t\t\tgoto fail_page;\n\t\t}\n\t\ttree->keycmp = hfsplus_attr_bin_cmp_key;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"unknown B*Tree requested\\n\");\n\t\tgoto fail_page;\n\t}\n\n\tif (!(tree->attributes & HFS_TREE_BIGKEYS)) {\n\t\tpr_err(\"invalid btree flag\\n\");\n\t\tgoto fail_page;\n\t}\n\n\tsize = tree->node_size;\n\tif (!is_power_of_2(size))\n\t\tgoto fail_page;\n\tif (!tree->node_count)\n\t\tgoto fail_page;\n\n\ttree->node_size_shift = ffs(size) - 1;\n\n\ttree->pages_per_bnode =\n\t\t(tree->node_size + PAGE_SIZE - 1) >>\n\t\tPAGE_SHIFT;\n\n\tkunmap_local(head);\n\tput_page(page);\n\treturn tree;\n\n fail_page:\n\tkunmap_local(head);\n\tput_page(page);\n free_inode:\n\ttree->inode->i_mapping->a_ops = &hfsplus_aops;\n\tiput(tree->inode);\n free_tree:\n\tkfree(tree);\n\treturn NULL;\n}\n\n \nvoid hfs_btree_close(struct hfs_btree *tree)\n{\n\tstruct hfs_bnode *node;\n\tint i;\n\n\tif (!tree)\n\t\treturn;\n\n\tfor (i = 0; i < NODE_HASH_SIZE; i++) {\n\t\twhile ((node = tree->node_hash[i])) {\n\t\t\ttree->node_hash[i] = node->next_hash;\n\t\t\tif (atomic_read(&node->refcnt))\n\t\t\t\tpr_crit(\"node %d:%d \"\n\t\t\t\t\t\t\"still has %d user(s)!\\n\",\n\t\t\t\t\tnode->tree->cnid, node->this,\n\t\t\t\t\tatomic_read(&node->refcnt));\n\t\t\thfs_bnode_free(node);\n\t\t\ttree->node_hash_cnt--;\n\t\t}\n\t}\n\tiput(tree->inode);\n\tkfree(tree);\n}\n\nint hfs_btree_write(struct hfs_btree *tree)\n{\n\tstruct hfs_btree_header_rec *head;\n\tstruct hfs_bnode *node;\n\tstruct page *page;\n\n\tnode = hfs_bnode_find(tree, 0);\n\tif (IS_ERR(node))\n\t\t \n\t\treturn -EIO;\n\t \n\tpage = node->page[0];\n\thead = (struct hfs_btree_header_rec *)(kmap_local_page(page) +\n\t\tsizeof(struct hfs_bnode_desc));\n\n\thead->root = cpu_to_be32(tree->root);\n\thead->leaf_count = cpu_to_be32(tree->leaf_count);\n\thead->leaf_head = cpu_to_be32(tree->leaf_head);\n\thead->leaf_tail = cpu_to_be32(tree->leaf_tail);\n\thead->node_count = cpu_to_be32(tree->node_count);\n\thead->free_nodes = cpu_to_be32(tree->free_nodes);\n\thead->attributes = cpu_to_be32(tree->attributes);\n\thead->depth = cpu_to_be16(tree->depth);\n\n\tkunmap_local(head);\n\tset_page_dirty(page);\n\thfs_bnode_put(node);\n\treturn 0;\n}\n\nstatic struct hfs_bnode *hfs_bmap_new_bmap(struct hfs_bnode *prev, u32 idx)\n{\n\tstruct hfs_btree *tree = prev->tree;\n\tstruct hfs_bnode *node;\n\tstruct hfs_bnode_desc desc;\n\t__be32 cnid;\n\n\tnode = hfs_bnode_create(tree, idx);\n\tif (IS_ERR(node))\n\t\treturn node;\n\n\ttree->free_nodes--;\n\tprev->next = idx;\n\tcnid = cpu_to_be32(idx);\n\thfs_bnode_write(prev, &cnid, offsetof(struct hfs_bnode_desc, next), 4);\n\n\tnode->type = HFS_NODE_MAP;\n\tnode->num_recs = 1;\n\thfs_bnode_clear(node, 0, tree->node_size);\n\tdesc.next = 0;\n\tdesc.prev = 0;\n\tdesc.type = HFS_NODE_MAP;\n\tdesc.height = 0;\n\tdesc.num_recs = cpu_to_be16(1);\n\tdesc.reserved = 0;\n\thfs_bnode_write(node, &desc, 0, sizeof(desc));\n\thfs_bnode_write_u16(node, 14, 0x8000);\n\thfs_bnode_write_u16(node, tree->node_size - 2, 14);\n\thfs_bnode_write_u16(node, tree->node_size - 4, tree->node_size - 6);\n\n\treturn node;\n}\n\n \nint hfs_bmap_reserve(struct hfs_btree *tree, int rsvd_nodes)\n{\n\tstruct inode *inode = tree->inode;\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tu32 count;\n\tint res;\n\n\tif (rsvd_nodes <= 0)\n\t\treturn 0;\n\n\twhile (tree->free_nodes < rsvd_nodes) {\n\t\tres = hfsplus_file_extend(inode, hfs_bnode_need_zeroout(tree));\n\t\tif (res)\n\t\t\treturn res;\n\t\thip->phys_size = inode->i_size =\n\t\t\t(loff_t)hip->alloc_blocks <<\n\t\t\t\tHFSPLUS_SB(tree->sb)->alloc_blksz_shift;\n\t\thip->fs_blocks =\n\t\t\thip->alloc_blocks << HFSPLUS_SB(tree->sb)->fs_shift;\n\t\tinode_set_bytes(inode, inode->i_size);\n\t\tcount = inode->i_size >> tree->node_size_shift;\n\t\ttree->free_nodes += count - tree->node_count;\n\t\ttree->node_count = count;\n\t}\n\treturn 0;\n}\n\nstruct hfs_bnode *hfs_bmap_alloc(struct hfs_btree *tree)\n{\n\tstruct hfs_bnode *node, *next_node;\n\tstruct page **pagep;\n\tu32 nidx, idx;\n\tunsigned off;\n\tu16 off16;\n\tu16 len;\n\tu8 *data, byte, m;\n\tint i, res;\n\n\tres = hfs_bmap_reserve(tree, 1);\n\tif (res)\n\t\treturn ERR_PTR(res);\n\n\tnidx = 0;\n\tnode = hfs_bnode_find(tree, nidx);\n\tif (IS_ERR(node))\n\t\treturn node;\n\tlen = hfs_brec_lenoff(node, 2, &off16);\n\toff = off16;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_SHIFT);\n\tdata = kmap_local_page(*pagep);\n\toff &= ~PAGE_MASK;\n\tidx = 0;\n\n\tfor (;;) {\n\t\twhile (len) {\n\t\t\tbyte = data[off];\n\t\t\tif (byte != 0xff) {\n\t\t\t\tfor (m = 0x80, i = 0; i < 8; m >>= 1, i++) {\n\t\t\t\t\tif (!(byte & m)) {\n\t\t\t\t\t\tidx += i;\n\t\t\t\t\t\tdata[off] |= m;\n\t\t\t\t\t\tset_page_dirty(*pagep);\n\t\t\t\t\t\tkunmap_local(data);\n\t\t\t\t\t\ttree->free_nodes--;\n\t\t\t\t\t\tmark_inode_dirty(tree->inode);\n\t\t\t\t\t\thfs_bnode_put(node);\n\t\t\t\t\t\treturn hfs_bnode_create(tree,\n\t\t\t\t\t\t\tidx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (++off >= PAGE_SIZE) {\n\t\t\t\tkunmap_local(data);\n\t\t\t\tdata = kmap_local_page(*++pagep);\n\t\t\t\toff = 0;\n\t\t\t}\n\t\t\tidx += 8;\n\t\t\tlen--;\n\t\t}\n\t\tkunmap_local(data);\n\t\tnidx = node->next;\n\t\tif (!nidx) {\n\t\t\thfs_dbg(BNODE_MOD, \"create new bmap node\\n\");\n\t\t\tnext_node = hfs_bmap_new_bmap(node, idx);\n\t\t} else\n\t\t\tnext_node = hfs_bnode_find(tree, nidx);\n\t\thfs_bnode_put(node);\n\t\tif (IS_ERR(next_node))\n\t\t\treturn next_node;\n\t\tnode = next_node;\n\n\t\tlen = hfs_brec_lenoff(node, 0, &off16);\n\t\toff = off16;\n\t\toff += node->page_offset;\n\t\tpagep = node->page + (off >> PAGE_SHIFT);\n\t\tdata = kmap_local_page(*pagep);\n\t\toff &= ~PAGE_MASK;\n\t}\n}\n\nvoid hfs_bmap_free(struct hfs_bnode *node)\n{\n\tstruct hfs_btree *tree;\n\tstruct page *page;\n\tu16 off, len;\n\tu32 nidx;\n\tu8 *data, byte, m;\n\n\thfs_dbg(BNODE_MOD, \"btree_free_node: %u\\n\", node->this);\n\tBUG_ON(!node->this);\n\ttree = node->tree;\n\tnidx = node->this;\n\tnode = hfs_bnode_find(tree, 0);\n\tif (IS_ERR(node))\n\t\treturn;\n\tlen = hfs_brec_lenoff(node, 2, &off);\n\twhile (nidx >= len * 8) {\n\t\tu32 i;\n\n\t\tnidx -= len * 8;\n\t\ti = node->next;\n\t\tif (!i) {\n\t\t\t ;\n\t\t\tpr_crit(\"unable to free bnode %u. \"\n\t\t\t\t\t\"bmap not found!\\n\",\n\t\t\t\tnode->this);\n\t\t\thfs_bnode_put(node);\n\t\t\treturn;\n\t\t}\n\t\thfs_bnode_put(node);\n\t\tnode = hfs_bnode_find(tree, i);\n\t\tif (IS_ERR(node))\n\t\t\treturn;\n\t\tif (node->type != HFS_NODE_MAP) {\n\t\t\t ;\n\t\t\tpr_crit(\"invalid bmap found! \"\n\t\t\t\t\t\"(%u,%d)\\n\",\n\t\t\t\tnode->this, node->type);\n\t\t\thfs_bnode_put(node);\n\t\t\treturn;\n\t\t}\n\t\tlen = hfs_brec_lenoff(node, 0, &off);\n\t}\n\toff += node->page_offset + nidx / 8;\n\tpage = node->page[off >> PAGE_SHIFT];\n\tdata = kmap_local_page(page);\n\toff &= ~PAGE_MASK;\n\tm = 1 << (~nidx & 7);\n\tbyte = data[off];\n\tif (!(byte & m)) {\n\t\tpr_crit(\"trying to free free bnode \"\n\t\t\t\t\"%u(%d)\\n\",\n\t\t\tnode->this, node->type);\n\t\tkunmap_local(data);\n\t\thfs_bnode_put(node);\n\t\treturn;\n\t}\n\tdata[off] = byte & ~m;\n\tset_page_dirty(page);\n\tkunmap_local(data);\n\thfs_bnode_put(node);\n\ttree->free_nodes++;\n\tmark_inode_dirty(tree->inode);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}