{
  "module_name": "super.c",
  "hash_id": "5fcc7178d4de8f44f92c686f0bd599692d37d27822e4e6492154b3fa55ed6ff9",
  "original_prompt": "Ingested from linux-6.6.14/fs/romfs/super.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/statfs.h>\n#include <linux/mtd/super.h>\n#include <linux/ctype.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/major.h>\n#include \"internal.h\"\n\nstatic struct kmem_cache *romfs_inode_cachep;\n\nstatic const umode_t romfs_modemap[8] = {\n\t0,\t\t\t \n\tS_IFDIR  | 0644,\t \n\tS_IFREG  | 0644,\t \n\tS_IFLNK  | 0777,\t \n\tS_IFBLK  | 0600,\t \n\tS_IFCHR  | 0600,\t \n\tS_IFSOCK | 0644,\t \n\tS_IFIFO  | 0644\t\t \n};\n\nstatic const unsigned char romfs_dtype_table[] = {\n\tDT_UNKNOWN, DT_DIR, DT_REG, DT_LNK, DT_BLK, DT_CHR, DT_SOCK, DT_FIFO\n};\n\nstatic struct inode *romfs_iget(struct super_block *sb, unsigned long pos);\n\n \nstatic int romfs_read_folio(struct file *file, struct folio *folio)\n{\n\tstruct page *page = &folio->page;\n\tstruct inode *inode = page->mapping->host;\n\tloff_t offset, size;\n\tunsigned long fillsize, pos;\n\tvoid *buf;\n\tint ret;\n\n\tbuf = kmap(page);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t \n\toffset = page_offset(page);\n\tsize = i_size_read(inode);\n\tfillsize = 0;\n\tret = 0;\n\tif (offset < size) {\n\t\tsize -= offset;\n\t\tfillsize = size > PAGE_SIZE ? PAGE_SIZE : size;\n\n\t\tpos = ROMFS_I(inode)->i_dataoffset + offset;\n\n\t\tret = romfs_dev_read(inode->i_sb, pos, buf, fillsize);\n\t\tif (ret < 0) {\n\t\t\tSetPageError(page);\n\t\t\tfillsize = 0;\n\t\t\tret = -EIO;\n\t\t}\n\t}\n\n\tif (fillsize < PAGE_SIZE)\n\t\tmemset(buf + fillsize, 0, PAGE_SIZE - fillsize);\n\tif (ret == 0)\n\t\tSetPageUptodate(page);\n\n\tflush_dcache_page(page);\n\tkunmap(page);\n\tunlock_page(page);\n\treturn ret;\n}\n\nstatic const struct address_space_operations romfs_aops = {\n\t.read_folio\t= romfs_read_folio\n};\n\n \nstatic int romfs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *i = file_inode(file);\n\tstruct romfs_inode ri;\n\tunsigned long offset, maxoff;\n\tint j, ino, nextfh;\n\tchar fsname[ROMFS_MAXFN];\t \n\tint ret;\n\n\tmaxoff = romfs_maxsize(i->i_sb);\n\n\toffset = ctx->pos;\n\tif (!offset) {\n\t\toffset = i->i_ino & ROMFH_MASK;\n\t\tret = romfs_dev_read(i->i_sb, offset, &ri, ROMFH_SIZE);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\toffset = be32_to_cpu(ri.spec) & ROMFH_MASK;\n\t}\n\n\t \n\tfor (;;) {\n\t\tif (!offset || offset >= maxoff) {\n\t\t\toffset = maxoff;\n\t\t\tctx->pos = offset;\n\t\t\tgoto out;\n\t\t}\n\t\tctx->pos = offset;\n\n\t\t \n\t\tret = romfs_dev_read(i->i_sb, offset, &ri, ROMFH_SIZE);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tj = romfs_dev_strnlen(i->i_sb, offset + ROMFH_SIZE,\n\t\t\t\t      sizeof(fsname) - 1);\n\t\tif (j < 0)\n\t\t\tgoto out;\n\n\t\tret = romfs_dev_read(i->i_sb, offset + ROMFH_SIZE, fsname, j);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tfsname[j] = '\\0';\n\n\t\tino = offset;\n\t\tnextfh = be32_to_cpu(ri.next);\n\t\tif ((nextfh & ROMFH_TYPE) == ROMFH_HRD)\n\t\t\tino = be32_to_cpu(ri.spec);\n\t\tif (!dir_emit(ctx, fsname, j, ino,\n\t\t\t    romfs_dtype_table[nextfh & ROMFH_TYPE]))\n\t\t\tgoto out;\n\n\t\toffset = nextfh & ROMFH_MASK;\n\t}\nout:\n\treturn 0;\n}\n\n \nstatic struct dentry *romfs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t   unsigned int flags)\n{\n\tunsigned long offset, maxoff;\n\tstruct inode *inode = NULL;\n\tstruct romfs_inode ri;\n\tconst char *name;\t\t \n\tint len, ret;\n\n\toffset = dir->i_ino & ROMFH_MASK;\n\tret = romfs_dev_read(dir->i_sb, offset, &ri, ROMFH_SIZE);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t \n\tmaxoff = romfs_maxsize(dir->i_sb);\n\toffset = be32_to_cpu(ri.spec) & ROMFH_MASK;\n\n\tname = dentry->d_name.name;\n\tlen = dentry->d_name.len;\n\n\tfor (;;) {\n\t\tif (!offset || offset >= maxoff)\n\t\t\tbreak;\n\n\t\tret = romfs_dev_read(dir->i_sb, offset, &ri, sizeof(ri));\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\n\t\t \n\t\tret = romfs_dev_strcmp(dir->i_sb, offset + ROMFH_SIZE, name,\n\t\t\t\t       len);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tif (ret == 1) {\n\t\t\t \n\t\t\tif ((be32_to_cpu(ri.next) & ROMFH_TYPE) == ROMFH_HRD)\n\t\t\t\toffset = be32_to_cpu(ri.spec) & ROMFH_MASK;\n\t\t\tinode = romfs_iget(dir->i_sb, offset);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\toffset = be32_to_cpu(ri.next) & ROMFH_MASK;\n\t}\n\n\treturn d_splice_alias(inode, dentry);\nerror:\n\treturn ERR_PTR(ret);\n}\n\nstatic const struct file_operations romfs_dir_operations = {\n\t.read\t\t= generic_read_dir,\n\t.iterate_shared\t= romfs_readdir,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic const struct inode_operations romfs_dir_inode_operations = {\n\t.lookup\t\t= romfs_lookup,\n};\n\n \nstatic struct inode *romfs_iget(struct super_block *sb, unsigned long pos)\n{\n\tstruct romfs_inode_info *inode;\n\tstruct romfs_inode ri;\n\tstruct inode *i;\n\tunsigned long nlen;\n\tunsigned nextfh;\n\tint ret;\n\tumode_t mode;\n\n\t \n\tfor (;;) {\n\t\tret = romfs_dev_read(sb, pos, &ri, sizeof(ri));\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\n\t\t \n\n\t\tnextfh = be32_to_cpu(ri.next);\n\t\tif ((nextfh & ROMFH_TYPE) != ROMFH_HRD)\n\t\t\tbreak;\n\n\t\tpos = be32_to_cpu(ri.spec) & ROMFH_MASK;\n\t}\n\n\t \n\tnlen = romfs_dev_strnlen(sb, pos + ROMFH_SIZE, ROMFS_MAXFN);\n\tif (IS_ERR_VALUE(nlen))\n\t\tgoto eio;\n\n\t \n\ti = iget_locked(sb, pos);\n\tif (!i)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!(i->i_state & I_NEW))\n\t\treturn i;\n\n\t \n\tinode = ROMFS_I(i);\n\tinode->i_metasize = (ROMFH_SIZE + nlen + 1 + ROMFH_PAD) & ROMFH_MASK;\n\tinode->i_dataoffset = pos + inode->i_metasize;\n\n\tset_nlink(i, 1);\t\t \n\ti->i_size = be32_to_cpu(ri.size);\n\ti->i_mtime = i->i_atime = inode_set_ctime(i, 0, 0);\n\n\t \n\tmode = romfs_modemap[nextfh & ROMFH_TYPE];\n\n\tswitch (nextfh & ROMFH_TYPE) {\n\tcase ROMFH_DIR:\n\t\ti->i_size = ROMFS_I(i)->i_metasize;\n\t\ti->i_op = &romfs_dir_inode_operations;\n\t\ti->i_fop = &romfs_dir_operations;\n\t\tif (nextfh & ROMFH_EXEC)\n\t\t\tmode |= S_IXUGO;\n\t\tbreak;\n\tcase ROMFH_REG:\n\t\ti->i_fop = &romfs_ro_fops;\n\t\ti->i_data.a_ops = &romfs_aops;\n\t\tif (nextfh & ROMFH_EXEC)\n\t\t\tmode |= S_IXUGO;\n\t\tbreak;\n\tcase ROMFH_SYM:\n\t\ti->i_op = &page_symlink_inode_operations;\n\t\tinode_nohighmem(i);\n\t\ti->i_data.a_ops = &romfs_aops;\n\t\tmode |= S_IRWXUGO;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tnextfh = be32_to_cpu(ri.spec);\n\t\tinit_special_inode(i, mode, MKDEV(nextfh >> 16,\n\t\t\t\t\t\t  nextfh & 0xffff));\n\t\tbreak;\n\t}\n\n\ti->i_mode = mode;\n\ti->i_blocks = (i->i_size + 511) >> 9;\n\n\tunlock_new_inode(i);\n\treturn i;\n\neio:\n\tret = -EIO;\nerror:\n\tpr_err(\"read error for inode 0x%lx\\n\", pos);\n\treturn ERR_PTR(ret);\n}\n\n \nstatic struct inode *romfs_alloc_inode(struct super_block *sb)\n{\n\tstruct romfs_inode_info *inode;\n\n\tinode = alloc_inode_sb(sb, romfs_inode_cachep, GFP_KERNEL);\n\treturn inode ? &inode->vfs_inode : NULL;\n}\n\n \nstatic void romfs_free_inode(struct inode *inode)\n{\n\tkmem_cache_free(romfs_inode_cachep, ROMFS_I(inode));\n}\n\n \nstatic int romfs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tu64 id = 0;\n\n\t \n\tif (sb->s_bdev)\n\t\tid = huge_encode_dev(sb->s_bdev->bd_dev);\n\telse if (sb->s_dev)\n\t\tid = huge_encode_dev(sb->s_dev);\n\n\tbuf->f_type = ROMFS_MAGIC;\n\tbuf->f_namelen = ROMFS_MAXFN;\n\tbuf->f_bsize = ROMBSIZE;\n\tbuf->f_bfree = buf->f_bavail = buf->f_ffree;\n\tbuf->f_blocks =\n\t\t(romfs_maxsize(dentry->d_sb) + ROMBSIZE - 1) >> ROMBSBITS;\n\tbuf->f_fsid = u64_to_fsid(id);\n\treturn 0;\n}\n\n \nstatic int romfs_reconfigure(struct fs_context *fc)\n{\n\tsync_filesystem(fc->root->d_sb);\n\tfc->sb_flags |= SB_RDONLY;\n\treturn 0;\n}\n\nstatic const struct super_operations romfs_super_ops = {\n\t.alloc_inode\t= romfs_alloc_inode,\n\t.free_inode\t= romfs_free_inode,\n\t.statfs\t\t= romfs_statfs,\n};\n\n \nstatic __u32 romfs_checksum(const void *data, int size)\n{\n\tconst __be32 *ptr = data;\n\t__u32 sum;\n\n\tsum = 0;\n\tsize >>= 2;\n\twhile (size > 0) {\n\t\tsum += be32_to_cpu(*ptr++);\n\t\tsize--;\n\t}\n\treturn sum;\n}\n\n \nstatic int romfs_fill_super(struct super_block *sb, struct fs_context *fc)\n{\n\tstruct romfs_super_block *rsb;\n\tstruct inode *root;\n\tunsigned long pos, img_size;\n\tconst char *storage;\n\tsize_t len;\n\tint ret;\n\n#ifdef CONFIG_BLOCK\n\tif (!sb->s_mtd) {\n\t\tsb_set_blocksize(sb, ROMBSIZE);\n\t} else {\n\t\tsb->s_blocksize = ROMBSIZE;\n\t\tsb->s_blocksize_bits = blksize_bits(ROMBSIZE);\n\t}\n#endif\n\n\tsb->s_maxbytes = 0xFFFFFFFF;\n\tsb->s_magic = ROMFS_MAGIC;\n\tsb->s_flags |= SB_RDONLY | SB_NOATIME;\n\tsb->s_time_min = 0;\n\tsb->s_time_max = 0;\n\tsb->s_op = &romfs_super_ops;\n\n#ifdef CONFIG_ROMFS_ON_MTD\n\t \n\tif (sb->s_mtd)\n\t\tsb->s_dev = MKDEV(MTD_BLOCK_MAJOR, sb->s_mtd->index);\n#endif\n\t \n\trsb = kmalloc(512, GFP_KERNEL);\n\tif (!rsb)\n\t\treturn -ENOMEM;\n\n\tsb->s_fs_info = (void *) 512;\n\tret = romfs_dev_read(sb, 0, rsb, 512);\n\tif (ret < 0)\n\t\tgoto error_rsb;\n\n\timg_size = be32_to_cpu(rsb->size);\n\n\tif (sb->s_mtd && img_size > sb->s_mtd->size)\n\t\tgoto error_rsb_inval;\n\n\tsb->s_fs_info = (void *) img_size;\n\n\tif (rsb->word0 != ROMSB_WORD0 || rsb->word1 != ROMSB_WORD1 ||\n\t    img_size < ROMFH_SIZE) {\n\t\tif (!(fc->sb_flags & SB_SILENT))\n\t\t\terrorf(fc, \"VFS: Can't find a romfs filesystem on dev %s.\\n\",\n\t\t\t       sb->s_id);\n\t\tgoto error_rsb_inval;\n\t}\n\n\tif (romfs_checksum(rsb, min_t(size_t, img_size, 512))) {\n\t\tpr_err(\"bad initial checksum on dev %s.\\n\", sb->s_id);\n\t\tgoto error_rsb_inval;\n\t}\n\n\tstorage = sb->s_mtd ? \"MTD\" : \"the block layer\";\n\n\tlen = strnlen(rsb->name, ROMFS_MAXFN);\n\tif (!(fc->sb_flags & SB_SILENT))\n\t\tpr_notice(\"Mounting image '%*.*s' through %s\\n\",\n\t\t\t  (unsigned) len, (unsigned) len, rsb->name, storage);\n\n\tkfree(rsb);\n\trsb = NULL;\n\n\t \n\tpos = (ROMFH_SIZE + len + 1 + ROMFH_PAD) & ROMFH_MASK;\n\n\troot = romfs_iget(sb, pos);\n\tif (IS_ERR(root))\n\t\treturn PTR_ERR(root);\n\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n\nerror_rsb_inval:\n\tret = -EINVAL;\nerror_rsb:\n\tkfree(rsb);\n\treturn ret;\n}\n\n \nstatic int romfs_get_tree(struct fs_context *fc)\n{\n\tint ret = -EINVAL;\n\n#ifdef CONFIG_ROMFS_ON_MTD\n\tret = get_tree_mtd(fc, romfs_fill_super);\n#endif\n#ifdef CONFIG_ROMFS_ON_BLOCK\n\tif (ret == -EINVAL)\n\t\tret = get_tree_bdev(fc, romfs_fill_super);\n#endif\n\treturn ret;\n}\n\nstatic const struct fs_context_operations romfs_context_ops = {\n\t.get_tree\t= romfs_get_tree,\n\t.reconfigure\t= romfs_reconfigure,\n};\n\n \nstatic int romfs_init_fs_context(struct fs_context *fc)\n{\n\tfc->ops = &romfs_context_ops;\n\treturn 0;\n}\n\n \nstatic void romfs_kill_sb(struct super_block *sb)\n{\n\tgeneric_shutdown_super(sb);\n\n#ifdef CONFIG_ROMFS_ON_MTD\n\tif (sb->s_mtd) {\n\t\tput_mtd_device(sb->s_mtd);\n\t\tsb->s_mtd = NULL;\n\t}\n#endif\n#ifdef CONFIG_ROMFS_ON_BLOCK\n\tif (sb->s_bdev) {\n\t\tsync_blockdev(sb->s_bdev);\n\t\tblkdev_put(sb->s_bdev, sb);\n\t}\n#endif\n}\n\nstatic struct file_system_type romfs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"romfs\",\n\t.init_fs_context = romfs_init_fs_context,\n\t.kill_sb\t= romfs_kill_sb,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\nMODULE_ALIAS_FS(\"romfs\");\n\n \nstatic void romfs_i_init_once(void *_inode)\n{\n\tstruct romfs_inode_info *inode = _inode;\n\n\tinode_init_once(&inode->vfs_inode);\n}\n\n \nstatic int __init init_romfs_fs(void)\n{\n\tint ret;\n\n\tpr_info(\"ROMFS MTD (C) 2007 Red Hat, Inc.\\n\");\n\n\tromfs_inode_cachep =\n\t\tkmem_cache_create(\"romfs_i\",\n\t\t\t\t  sizeof(struct romfs_inode_info), 0,\n\t\t\t\t  SLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD |\n\t\t\t\t  SLAB_ACCOUNT, romfs_i_init_once);\n\n\tif (!romfs_inode_cachep) {\n\t\tpr_err(\"Failed to initialise inode cache\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tret = register_filesystem(&romfs_fs_type);\n\tif (ret) {\n\t\tpr_err(\"Failed to register filesystem\\n\");\n\t\tgoto error_register;\n\t}\n\treturn 0;\n\nerror_register:\n\tkmem_cache_destroy(romfs_inode_cachep);\n\treturn ret;\n}\n\n \nstatic void __exit exit_romfs_fs(void)\n{\n\tunregister_filesystem(&romfs_fs_type);\n\t \n\trcu_barrier();\n\tkmem_cache_destroy(romfs_inode_cachep);\n}\n\nmodule_init(init_romfs_fs);\nmodule_exit(exit_romfs_fs);\n\nMODULE_DESCRIPTION(\"Direct-MTD Capable RomFS\");\nMODULE_AUTHOR(\"Red Hat, Inc.\");\nMODULE_LICENSE(\"GPL\");  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}