{
  "module_name": "ast.c",
  "hash_id": "60efa7c99546a31110c8d16e473eee179ad55034700673cb7167eab3b142e04b",
  "original_prompt": "Ingested from linux-6.6.14/fs/dlm/ast.c",
  "human_readable_source": "\n \n\n#include <trace/events/dlm.h>\n\n#include \"dlm_internal.h\"\n#include \"memory.h\"\n#include \"lock.h\"\n#include \"user.h\"\n#include \"ast.h\"\n\nvoid dlm_release_callback(struct kref *ref)\n{\n\tstruct dlm_callback *cb = container_of(ref, struct dlm_callback, ref);\n\n\tdlm_free_cb(cb);\n}\n\nvoid dlm_callback_set_last_ptr(struct dlm_callback **from,\n\t\t\t       struct dlm_callback *to)\n{\n\tif (*from)\n\t\tkref_put(&(*from)->ref, dlm_release_callback);\n\n\tif (to)\n\t\tkref_get(&to->ref);\n\n\t*from = to;\n}\n\nint dlm_enqueue_lkb_callback(struct dlm_lkb *lkb, uint32_t flags, int mode,\n\t\t\t     int status, uint32_t sbflags)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\tint rv = DLM_ENQUEUE_CALLBACK_SUCCESS;\n\tstruct dlm_callback *cb;\n\tint prev_mode;\n\n\tif (flags & DLM_CB_BAST) {\n\t\t \n\t\tif (lkb->lkb_last_cast) {\n\t\t\tif (dlm_modes_compat(mode, lkb->lkb_last_cast->mode)) {\n\t\t\t\tlog_debug(ls, \"skip %x bast mode %d for cast mode %d\",\n\t\t\t\t\t  lkb->lkb_id, mode,\n\t\t\t\t\t  lkb->lkb_last_cast->mode);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (lkb->lkb_last_cb && lkb->lkb_last_cb->flags & DLM_CB_BAST) {\n\t\t\tprev_mode = lkb->lkb_last_cb->mode;\n\n\t\t\tif ((prev_mode == mode) ||\n\t\t\t    (prev_mode > mode && prev_mode > DLM_LOCK_PR)) {\n\t\t\t\tlog_debug(ls, \"skip %x add bast mode %d for bast mode %d\",\n\t\t\t\t\t  lkb->lkb_id, mode, prev_mode);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tcb = dlm_allocate_cb();\n\tif (!cb) {\n\t\trv = DLM_ENQUEUE_CALLBACK_FAILURE;\n\t\tgoto out;\n\t}\n\n\tcb->flags = flags;\n\tcb->mode = mode;\n\tcb->sb_status = status;\n\tcb->sb_flags = (sbflags & 0x000000FF);\n\tkref_init(&cb->ref);\n\tif (!test_and_set_bit(DLM_IFL_CB_PENDING_BIT, &lkb->lkb_iflags))\n\t\trv = DLM_ENQUEUE_CALLBACK_NEED_SCHED;\n\n\tlist_add_tail(&cb->list, &lkb->lkb_callbacks);\n\n\tif (flags & DLM_CB_CAST)\n\t\tdlm_callback_set_last_ptr(&lkb->lkb_last_cast, cb);\n\n\tdlm_callback_set_last_ptr(&lkb->lkb_last_cb, cb);\n\n out:\n\treturn rv;\n}\n\nint dlm_dequeue_lkb_callback(struct dlm_lkb *lkb, struct dlm_callback **cb)\n{\n\t \n\t*cb = list_first_entry_or_null(&lkb->lkb_callbacks,\n\t\t\t\t       struct dlm_callback, list);\n\tif (!*cb)\n\t\treturn DLM_DEQUEUE_CALLBACK_EMPTY;\n\n\t \n\tlist_del(&(*cb)->list);\n\tif (list_empty(&lkb->lkb_callbacks))\n\t\treturn DLM_DEQUEUE_CALLBACK_LAST;\n\n\treturn DLM_DEQUEUE_CALLBACK_SUCCESS;\n}\n\nvoid dlm_add_cb(struct dlm_lkb *lkb, uint32_t flags, int mode, int status,\n\t\tuint32_t sbflags)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\tint rv;\n\n\tif (test_bit(DLM_DFL_USER_BIT, &lkb->lkb_dflags)) {\n\t\tdlm_user_add_ast(lkb, flags, mode, status, sbflags);\n\t\treturn;\n\t}\n\n\tspin_lock(&lkb->lkb_cb_lock);\n\trv = dlm_enqueue_lkb_callback(lkb, flags, mode, status, sbflags);\n\tswitch (rv) {\n\tcase DLM_ENQUEUE_CALLBACK_NEED_SCHED:\n\t\tkref_get(&lkb->lkb_ref);\n\n\t\tspin_lock(&ls->ls_cb_lock);\n\t\tif (test_bit(LSFL_CB_DELAY, &ls->ls_flags)) {\n\t\t\tlist_add(&lkb->lkb_cb_list, &ls->ls_cb_delay);\n\t\t} else {\n\t\t\tqueue_work(ls->ls_callback_wq, &lkb->lkb_cb_work);\n\t\t}\n\t\tspin_unlock(&ls->ls_cb_lock);\n\t\tbreak;\n\tcase DLM_ENQUEUE_CALLBACK_FAILURE:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\tcase DLM_ENQUEUE_CALLBACK_SUCCESS:\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\tspin_unlock(&lkb->lkb_cb_lock);\n}\n\nvoid dlm_callback_work(struct work_struct *work)\n{\n\tstruct dlm_lkb *lkb = container_of(work, struct dlm_lkb, lkb_cb_work);\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\tvoid (*castfn) (void *astparam);\n\tvoid (*bastfn) (void *astparam, int mode);\n\tstruct dlm_callback *cb;\n\tint rv;\n\n\tspin_lock(&lkb->lkb_cb_lock);\n\trv = dlm_dequeue_lkb_callback(lkb, &cb);\n\tif (WARN_ON_ONCE(rv == DLM_DEQUEUE_CALLBACK_EMPTY)) {\n\t\tclear_bit(DLM_IFL_CB_PENDING_BIT, &lkb->lkb_iflags);\n\t\tspin_unlock(&lkb->lkb_cb_lock);\n\t\tgoto out;\n\t}\n\tspin_unlock(&lkb->lkb_cb_lock);\n\n\tfor (;;) {\n\t\tcastfn = lkb->lkb_astfn;\n\t\tbastfn = lkb->lkb_bastfn;\n\n\t\tif (cb->flags & DLM_CB_BAST) {\n\t\t\ttrace_dlm_bast(ls, lkb, cb->mode);\n\t\t\tlkb->lkb_last_bast_time = ktime_get();\n\t\t\tlkb->lkb_last_bast_mode = cb->mode;\n\t\t\tbastfn(lkb->lkb_astparam, cb->mode);\n\t\t} else if (cb->flags & DLM_CB_CAST) {\n\t\t\tlkb->lkb_lksb->sb_status = cb->sb_status;\n\t\t\tlkb->lkb_lksb->sb_flags = cb->sb_flags;\n\t\t\ttrace_dlm_ast(ls, lkb);\n\t\t\tlkb->lkb_last_cast_time = ktime_get();\n\t\t\tcastfn(lkb->lkb_astparam);\n\t\t}\n\n\t\tkref_put(&cb->ref, dlm_release_callback);\n\n\t\tspin_lock(&lkb->lkb_cb_lock);\n\t\trv = dlm_dequeue_lkb_callback(lkb, &cb);\n\t\tif (rv == DLM_DEQUEUE_CALLBACK_EMPTY) {\n\t\t\tclear_bit(DLM_IFL_CB_PENDING_BIT, &lkb->lkb_iflags);\n\t\t\tspin_unlock(&lkb->lkb_cb_lock);\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&lkb->lkb_cb_lock);\n\t}\n\nout:\n\t \n\tdlm_put_lkb(lkb);\n}\n\nint dlm_callback_start(struct dlm_ls *ls)\n{\n\tls->ls_callback_wq = alloc_workqueue(\"dlm_callback\",\n\t\t\t\t\t     WQ_HIGHPRI | WQ_MEM_RECLAIM, 0);\n\tif (!ls->ls_callback_wq) {\n\t\tlog_print(\"can't start dlm_callback workqueue\");\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nvoid dlm_callback_stop(struct dlm_ls *ls)\n{\n\tif (ls->ls_callback_wq)\n\t\tdestroy_workqueue(ls->ls_callback_wq);\n}\n\nvoid dlm_callback_suspend(struct dlm_ls *ls)\n{\n\tif (ls->ls_callback_wq) {\n\t\tspin_lock(&ls->ls_cb_lock);\n\t\tset_bit(LSFL_CB_DELAY, &ls->ls_flags);\n\t\tspin_unlock(&ls->ls_cb_lock);\n\n\t\tflush_workqueue(ls->ls_callback_wq);\n\t}\n}\n\n#define MAX_CB_QUEUE 25\n\nvoid dlm_callback_resume(struct dlm_ls *ls)\n{\n\tstruct dlm_lkb *lkb, *safe;\n\tint count = 0, sum = 0;\n\tbool empty;\n\n\tif (!ls->ls_callback_wq)\n\t\treturn;\n\nmore:\n\tspin_lock(&ls->ls_cb_lock);\n\tlist_for_each_entry_safe(lkb, safe, &ls->ls_cb_delay, lkb_cb_list) {\n\t\tlist_del_init(&lkb->lkb_cb_list);\n\t\tqueue_work(ls->ls_callback_wq, &lkb->lkb_cb_work);\n\t\tcount++;\n\t\tif (count == MAX_CB_QUEUE)\n\t\t\tbreak;\n\t}\n\tempty = list_empty(&ls->ls_cb_delay);\n\tif (empty)\n\t\tclear_bit(LSFL_CB_DELAY, &ls->ls_flags);\n\tspin_unlock(&ls->ls_cb_lock);\n\n\tsum += count;\n\tif (!empty) {\n\t\tcount = 0;\n\t\tcond_resched();\n\t\tgoto more;\n\t}\n\n\tif (sum)\n\t\tlog_rinfo(ls, \"%s %d\", __func__, sum);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}