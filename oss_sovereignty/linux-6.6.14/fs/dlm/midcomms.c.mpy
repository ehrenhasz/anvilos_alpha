{
  "module_name": "midcomms.c",
  "hash_id": "608303c723866781bd99dae468e57fbaf96417cc1392e9b072d6237967eb379f",
  "original_prompt": "Ingested from linux-6.6.14/fs/dlm/midcomms.c",
  "human_readable_source": "\n \n\n \n\n \n#define DLM_DEBUG_FENCE_TERMINATION\t0\n\n#include <trace/events/dlm.h>\n#include <net/tcp.h>\n\n#include \"dlm_internal.h\"\n#include \"lowcomms.h\"\n#include \"config.h\"\n#include \"memory.h\"\n#include \"lock.h\"\n#include \"util.h\"\n#include \"midcomms.h\"\n\n \n#define DLM_SEQ_INIT\t\t0\n \n#define DLM_SHUTDOWN_TIMEOUT\tmsecs_to_jiffies(5000)\n#define DLM_VERSION_NOT_SET\t0\n#define DLM_SEND_ACK_BACK_MSG_THRESHOLD 32\n#define DLM_RECV_ACK_BACK_MSG_THRESHOLD (DLM_SEND_ACK_BACK_MSG_THRESHOLD * 8)\n\nstruct midcomms_node {\n\tint nodeid;\n\tuint32_t version;\n\tatomic_t seq_send;\n\tatomic_t seq_next;\n\t \n\tstruct list_head send_queue;\n\tspinlock_t send_queue_lock;\n\tatomic_t send_queue_cnt;\n#define DLM_NODE_FLAG_CLOSE\t1\n#define DLM_NODE_FLAG_STOP_TX\t2\n#define DLM_NODE_FLAG_STOP_RX\t3\n\tatomic_t ulp_delivered;\n\tunsigned long flags;\n\twait_queue_head_t shutdown_wait;\n\n\t \n#define DLM_CLOSED\t1\n#define DLM_ESTABLISHED\t2\n#define DLM_FIN_WAIT1\t3\n#define DLM_FIN_WAIT2\t4\n#define DLM_CLOSE_WAIT\t5\n#define DLM_LAST_ACK\t6\n#define DLM_CLOSING\t7\n\tint state;\n\tspinlock_t state_lock;\n\n\t \n\tint users;\n\n\t \n\tvoid *debugfs;\n\n\tstruct hlist_node hlist;\n\tstruct rcu_head rcu;\n};\n\nstruct dlm_mhandle {\n\tconst union dlm_packet *inner_p;\n\tstruct midcomms_node *node;\n\tstruct dlm_opts *opts;\n\tstruct dlm_msg *msg;\n\tbool committed;\n\tuint32_t seq;\n\n\tvoid (*ack_rcv)(struct midcomms_node *node);\n\n\t \n\tint idx;\n\n\tstruct list_head list;\n\tstruct rcu_head rcu;\n};\n\nstatic struct hlist_head node_hash[CONN_HASH_SIZE];\nstatic DEFINE_SPINLOCK(nodes_lock);\nDEFINE_STATIC_SRCU(nodes_srcu);\n\n \nstatic DEFINE_MUTEX(close_lock);\n\nstruct kmem_cache *dlm_midcomms_cache_create(void)\n{\n\treturn kmem_cache_create(\"dlm_mhandle\", sizeof(struct dlm_mhandle),\n\t\t\t\t 0, 0, NULL);\n}\n\nstatic inline const char *dlm_state_str(int state)\n{\n\tswitch (state) {\n\tcase DLM_CLOSED:\n\t\treturn \"CLOSED\";\n\tcase DLM_ESTABLISHED:\n\t\treturn \"ESTABLISHED\";\n\tcase DLM_FIN_WAIT1:\n\t\treturn \"FIN_WAIT1\";\n\tcase DLM_FIN_WAIT2:\n\t\treturn \"FIN_WAIT2\";\n\tcase DLM_CLOSE_WAIT:\n\t\treturn \"CLOSE_WAIT\";\n\tcase DLM_LAST_ACK:\n\t\treturn \"LAST_ACK\";\n\tcase DLM_CLOSING:\n\t\treturn \"CLOSING\";\n\tdefault:\n\t\treturn \"UNKNOWN\";\n\t}\n}\n\nconst char *dlm_midcomms_state(struct midcomms_node *node)\n{\n\treturn dlm_state_str(node->state);\n}\n\nunsigned long dlm_midcomms_flags(struct midcomms_node *node)\n{\n\treturn node->flags;\n}\n\nint dlm_midcomms_send_queue_cnt(struct midcomms_node *node)\n{\n\treturn atomic_read(&node->send_queue_cnt);\n}\n\nuint32_t dlm_midcomms_version(struct midcomms_node *node)\n{\n\treturn node->version;\n}\n\nstatic struct midcomms_node *__find_node(int nodeid, int r)\n{\n\tstruct midcomms_node *node;\n\n\thlist_for_each_entry_rcu(node, &node_hash[r], hlist) {\n\t\tif (node->nodeid == nodeid)\n\t\t\treturn node;\n\t}\n\n\treturn NULL;\n}\n\nstatic void dlm_mhandle_release(struct rcu_head *rcu)\n{\n\tstruct dlm_mhandle *mh = container_of(rcu, struct dlm_mhandle, rcu);\n\n\tdlm_lowcomms_put_msg(mh->msg);\n\tdlm_free_mhandle(mh);\n}\n\nstatic void dlm_mhandle_delete(struct midcomms_node *node,\n\t\t\t       struct dlm_mhandle *mh)\n{\n\tlist_del_rcu(&mh->list);\n\tatomic_dec(&node->send_queue_cnt);\n\tcall_rcu(&mh->rcu, dlm_mhandle_release);\n}\n\nstatic void dlm_send_queue_flush(struct midcomms_node *node)\n{\n\tstruct dlm_mhandle *mh;\n\n\tpr_debug(\"flush midcomms send queue of node %d\\n\", node->nodeid);\n\n\trcu_read_lock();\n\tspin_lock_bh(&node->send_queue_lock);\n\tlist_for_each_entry_rcu(mh, &node->send_queue, list) {\n\t\tdlm_mhandle_delete(node, mh);\n\t}\n\tspin_unlock_bh(&node->send_queue_lock);\n\trcu_read_unlock();\n}\n\nstatic void midcomms_node_reset(struct midcomms_node *node)\n{\n\tpr_debug(\"reset node %d\\n\", node->nodeid);\n\n\tatomic_set(&node->seq_next, DLM_SEQ_INIT);\n\tatomic_set(&node->seq_send, DLM_SEQ_INIT);\n\tatomic_set(&node->ulp_delivered, 0);\n\tnode->version = DLM_VERSION_NOT_SET;\n\tnode->flags = 0;\n\n\tdlm_send_queue_flush(node);\n\tnode->state = DLM_CLOSED;\n\twake_up(&node->shutdown_wait);\n}\n\nstatic struct midcomms_node *nodeid2node(int nodeid)\n{\n\treturn __find_node(nodeid, nodeid_hash(nodeid));\n}\n\nint dlm_midcomms_addr(int nodeid, struct sockaddr_storage *addr, int len)\n{\n\tint ret, idx, r = nodeid_hash(nodeid);\n\tstruct midcomms_node *node;\n\n\tret = dlm_lowcomms_addr(nodeid, addr, len);\n\tif (ret)\n\t\treturn ret;\n\n\tidx = srcu_read_lock(&nodes_srcu);\n\tnode = __find_node(nodeid, r);\n\tif (node) {\n\t\tsrcu_read_unlock(&nodes_srcu, idx);\n\t\treturn 0;\n\t}\n\tsrcu_read_unlock(&nodes_srcu, idx);\n\n\tnode = kmalloc(sizeof(*node), GFP_NOFS);\n\tif (!node)\n\t\treturn -ENOMEM;\n\n\tnode->nodeid = nodeid;\n\tspin_lock_init(&node->state_lock);\n\tspin_lock_init(&node->send_queue_lock);\n\tatomic_set(&node->send_queue_cnt, 0);\n\tINIT_LIST_HEAD(&node->send_queue);\n\tinit_waitqueue_head(&node->shutdown_wait);\n\tnode->users = 0;\n\tmidcomms_node_reset(node);\n\n\tspin_lock(&nodes_lock);\n\thlist_add_head_rcu(&node->hlist, &node_hash[r]);\n\tspin_unlock(&nodes_lock);\n\n\tnode->debugfs = dlm_create_debug_comms_file(nodeid, node);\n\treturn 0;\n}\n\nstatic int dlm_send_ack(int nodeid, uint32_t seq)\n{\n\tint mb_len = sizeof(struct dlm_header);\n\tstruct dlm_header *m_header;\n\tstruct dlm_msg *msg;\n\tchar *ppc;\n\n\tmsg = dlm_lowcomms_new_msg(nodeid, mb_len, GFP_ATOMIC, &ppc,\n\t\t\t\t   NULL, NULL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tm_header = (struct dlm_header *)ppc;\n\n\tm_header->h_version = cpu_to_le32(DLM_HEADER_MAJOR | DLM_HEADER_MINOR);\n\tm_header->h_nodeid = cpu_to_le32(dlm_our_nodeid());\n\tm_header->h_length = cpu_to_le16(mb_len);\n\tm_header->h_cmd = DLM_ACK;\n\tm_header->u.h_seq = cpu_to_le32(seq);\n\n\tdlm_lowcomms_commit_msg(msg);\n\tdlm_lowcomms_put_msg(msg);\n\n\treturn 0;\n}\n\nstatic void dlm_send_ack_threshold(struct midcomms_node *node,\n\t\t\t\t   uint32_t threshold)\n{\n\tuint32_t oval, nval;\n\tbool send_ack;\n\n\t \n\tdo {\n\t\toval = atomic_read(&node->ulp_delivered);\n\t\tsend_ack = (oval > threshold);\n\t\t \n\t\tif (!send_ack)\n\t\t\tbreak;\n\n\t\tnval = 0;\n\t\t \n\t} while (atomic_cmpxchg(&node->ulp_delivered, oval, nval) != oval);\n\n\tif (send_ack)\n\t\tdlm_send_ack(node->nodeid, atomic_read(&node->seq_next));\n}\n\nstatic int dlm_send_fin(struct midcomms_node *node,\n\t\t\tvoid (*ack_rcv)(struct midcomms_node *node))\n{\n\tint mb_len = sizeof(struct dlm_header);\n\tstruct dlm_header *m_header;\n\tstruct dlm_mhandle *mh;\n\tchar *ppc;\n\n\tmh = dlm_midcomms_get_mhandle(node->nodeid, mb_len, GFP_ATOMIC, &ppc);\n\tif (!mh)\n\t\treturn -ENOMEM;\n\n\tset_bit(DLM_NODE_FLAG_STOP_TX, &node->flags);\n\tmh->ack_rcv = ack_rcv;\n\n\tm_header = (struct dlm_header *)ppc;\n\n\tm_header->h_version = cpu_to_le32(DLM_HEADER_MAJOR | DLM_HEADER_MINOR);\n\tm_header->h_nodeid = cpu_to_le32(dlm_our_nodeid());\n\tm_header->h_length = cpu_to_le16(mb_len);\n\tm_header->h_cmd = DLM_FIN;\n\n\tpr_debug(\"sending fin msg to node %d\\n\", node->nodeid);\n\tdlm_midcomms_commit_mhandle(mh, NULL, 0);\n\n\treturn 0;\n}\n\nstatic void dlm_receive_ack(struct midcomms_node *node, uint32_t seq)\n{\n\tstruct dlm_mhandle *mh;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(mh, &node->send_queue, list) {\n\t\tif (before(mh->seq, seq)) {\n\t\t\tif (mh->ack_rcv)\n\t\t\t\tmh->ack_rcv(node);\n\t\t} else {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_lock_bh(&node->send_queue_lock);\n\tlist_for_each_entry_rcu(mh, &node->send_queue, list) {\n\t\tif (before(mh->seq, seq)) {\n\t\t\tdlm_mhandle_delete(node, mh);\n\t\t} else {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_bh(&node->send_queue_lock);\n\trcu_read_unlock();\n}\n\nstatic void dlm_pas_fin_ack_rcv(struct midcomms_node *node)\n{\n\tspin_lock(&node->state_lock);\n\tpr_debug(\"receive passive fin ack from node %d with state %s\\n\",\n\t\t node->nodeid, dlm_state_str(node->state));\n\n\tswitch (node->state) {\n\tcase DLM_LAST_ACK:\n\t\t \n\t\tmidcomms_node_reset(node);\n\t\tbreak;\n\tcase DLM_CLOSED:\n\t\t \n\t\twake_up(&node->shutdown_wait);\n\t\tbreak;\n\tdefault:\n\t\tspin_unlock(&node->state_lock);\n\t\tlog_print(\"%s: unexpected state: %d\",\n\t\t\t  __func__, node->state);\n\t\tWARN_ON_ONCE(1);\n\t\treturn;\n\t}\n\tspin_unlock(&node->state_lock);\n}\n\nstatic void dlm_receive_buffer_3_2_trace(uint32_t seq,\n\t\t\t\t\t const union dlm_packet *p)\n{\n\tswitch (p->header.h_cmd) {\n\tcase DLM_MSG:\n\t\ttrace_dlm_recv_message(dlm_our_nodeid(), seq, &p->message);\n\t\tbreak;\n\tcase DLM_RCOM:\n\t\ttrace_dlm_recv_rcom(dlm_our_nodeid(), seq, &p->rcom);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void dlm_midcomms_receive_buffer(const union dlm_packet *p,\n\t\t\t\t\tstruct midcomms_node *node,\n\t\t\t\t\tuint32_t seq)\n{\n\tbool is_expected_seq;\n\tuint32_t oval, nval;\n\n\tdo {\n\t\toval = atomic_read(&node->seq_next);\n\t\tis_expected_seq = (oval == seq);\n\t\tif (!is_expected_seq)\n\t\t\tbreak;\n\n\t\tnval = oval + 1;\n\t} while (atomic_cmpxchg(&node->seq_next, oval, nval) != oval);\n\n\tif (is_expected_seq) {\n\t\tswitch (p->header.h_cmd) {\n\t\tcase DLM_FIN:\n\t\t\tspin_lock(&node->state_lock);\n\t\t\tpr_debug(\"receive fin msg from node %d with state %s\\n\",\n\t\t\t\t node->nodeid, dlm_state_str(node->state));\n\n\t\t\tswitch (node->state) {\n\t\t\tcase DLM_ESTABLISHED:\n\t\t\t\tdlm_send_ack(node->nodeid, nval);\n\n\t\t\t\t \n\t\t\t\tif (node->users == 0) {\n\t\t\t\t\tnode->state = DLM_LAST_ACK;\n\t\t\t\t\tpr_debug(\"switch node %d to state %s case 1\\n\",\n\t\t\t\t\t\t node->nodeid, dlm_state_str(node->state));\n\t\t\t\t\tset_bit(DLM_NODE_FLAG_STOP_RX, &node->flags);\n\t\t\t\t\tdlm_send_fin(node, dlm_pas_fin_ack_rcv);\n\t\t\t\t} else {\n\t\t\t\t\tnode->state = DLM_CLOSE_WAIT;\n\t\t\t\t\tpr_debug(\"switch node %d to state %s\\n\",\n\t\t\t\t\t\t node->nodeid, dlm_state_str(node->state));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase DLM_FIN_WAIT1:\n\t\t\t\tdlm_send_ack(node->nodeid, nval);\n\t\t\t\tnode->state = DLM_CLOSING;\n\t\t\t\tset_bit(DLM_NODE_FLAG_STOP_RX, &node->flags);\n\t\t\t\tpr_debug(\"switch node %d to state %s\\n\",\n\t\t\t\t\t node->nodeid, dlm_state_str(node->state));\n\t\t\t\tbreak;\n\t\t\tcase DLM_FIN_WAIT2:\n\t\t\t\tdlm_send_ack(node->nodeid, nval);\n\t\t\t\tmidcomms_node_reset(node);\n\t\t\t\tpr_debug(\"switch node %d to state %s\\n\",\n\t\t\t\t\t node->nodeid, dlm_state_str(node->state));\n\t\t\t\tbreak;\n\t\t\tcase DLM_LAST_ACK:\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tspin_unlock(&node->state_lock);\n\t\t\t\tlog_print(\"%s: unexpected state: %d\",\n\t\t\t\t\t  __func__, node->state);\n\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tspin_unlock(&node->state_lock);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ON_ONCE(test_bit(DLM_NODE_FLAG_STOP_RX, &node->flags));\n\t\t\tdlm_receive_buffer_3_2_trace(seq, p);\n\t\t\tdlm_receive_buffer(p, node->nodeid);\n\t\t\tatomic_inc(&node->ulp_delivered);\n\t\t\t \n\t\t\tdlm_send_ack_threshold(node, DLM_RECV_ACK_BACK_MSG_THRESHOLD);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t \n\t\tif (seq < oval)\n\t\t\tdlm_send_ack(node->nodeid, oval);\n\n\t\tlog_print_ratelimited(\"ignore dlm msg because seq mismatch, seq: %u, expected: %u, nodeid: %d\",\n\t\t\t\t      seq, oval, node->nodeid);\n\t}\n}\n\nstatic int dlm_opts_check_msglen(const union dlm_packet *p, uint16_t msglen,\n\t\t\t\t int nodeid)\n{\n\tint len = msglen;\n\n\t \n\tif (len < sizeof(struct dlm_opts))\n\t\treturn -1;\n\tlen -= sizeof(struct dlm_opts);\n\n\tif (len < le16_to_cpu(p->opts.o_optlen))\n\t\treturn -1;\n\tlen -= le16_to_cpu(p->opts.o_optlen);\n\n\tswitch (p->opts.o_nextcmd) {\n\tcase DLM_FIN:\n\t\tif (len < sizeof(struct dlm_header)) {\n\t\t\tlog_print(\"fin too small: %d, will skip this message from node %d\",\n\t\t\t\t  len, nodeid);\n\t\t\treturn -1;\n\t\t}\n\n\t\tbreak;\n\tcase DLM_MSG:\n\t\tif (len < sizeof(struct dlm_message)) {\n\t\t\tlog_print(\"msg too small: %d, will skip this message from node %d\",\n\t\t\t\t  msglen, nodeid);\n\t\t\treturn -1;\n\t\t}\n\n\t\tbreak;\n\tcase DLM_RCOM:\n\t\tif (len < sizeof(struct dlm_rcom)) {\n\t\t\tlog_print(\"rcom msg too small: %d, will skip this message from node %d\",\n\t\t\t\t  len, nodeid);\n\t\t\treturn -1;\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\tlog_print(\"unsupported o_nextcmd received: %u, will skip this message from node %d\",\n\t\t\t  p->opts.o_nextcmd, nodeid);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic void dlm_midcomms_receive_buffer_3_2(const union dlm_packet *p, int nodeid)\n{\n\tuint16_t msglen = le16_to_cpu(p->header.h_length);\n\tstruct midcomms_node *node;\n\tuint32_t seq;\n\tint ret, idx;\n\n\tidx = srcu_read_lock(&nodes_srcu);\n\tnode = nodeid2node(nodeid);\n\tif (WARN_ON_ONCE(!node))\n\t\tgoto out;\n\n\tswitch (node->version) {\n\tcase DLM_VERSION_NOT_SET:\n\t\tnode->version = DLM_VERSION_3_2;\n\t\twake_up(&node->shutdown_wait);\n\t\tlog_print(\"version 0x%08x for node %d detected\", DLM_VERSION_3_2,\n\t\t\t  node->nodeid);\n\n\t\tspin_lock(&node->state_lock);\n\t\tswitch (node->state) {\n\t\tcase DLM_CLOSED:\n\t\t\tnode->state = DLM_ESTABLISHED;\n\t\t\tpr_debug(\"switch node %d to state %s\\n\",\n\t\t\t\t node->nodeid, dlm_state_str(node->state));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&node->state_lock);\n\n\t\tbreak;\n\tcase DLM_VERSION_3_2:\n\t\tbreak;\n\tdefault:\n\t\tlog_print_ratelimited(\"version mismatch detected, assumed 0x%08x but node %d has 0x%08x\",\n\t\t\t\t      DLM_VERSION_3_2, node->nodeid, node->version);\n\t\tgoto out;\n\t}\n\n\tswitch (p->header.h_cmd) {\n\tcase DLM_RCOM:\n\t\t \n\t\tswitch (p->rcom.rc_type) {\n\t\tcase cpu_to_le32(DLM_RCOM_NAMES):\n\t\t\tfallthrough;\n\t\tcase cpu_to_le32(DLM_RCOM_NAMES_REPLY):\n\t\t\tfallthrough;\n\t\tcase cpu_to_le32(DLM_RCOM_STATUS):\n\t\t\tfallthrough;\n\t\tcase cpu_to_le32(DLM_RCOM_STATUS_REPLY):\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_print(\"unsupported rcom type received: %u, will skip this message from node %d\",\n\t\t\t\t  le32_to_cpu(p->rcom.rc_type), nodeid);\n\t\t\tgoto out;\n\t\t}\n\n\t\tWARN_ON_ONCE(test_bit(DLM_NODE_FLAG_STOP_RX, &node->flags));\n\t\tdlm_receive_buffer(p, nodeid);\n\t\tbreak;\n\tcase DLM_OPTS:\n\t\tseq = le32_to_cpu(p->header.u.h_seq);\n\n\t\tret = dlm_opts_check_msglen(p, msglen, nodeid);\n\t\tif (ret < 0) {\n\t\t\tlog_print(\"opts msg too small: %u, will skip this message from node %d\",\n\t\t\t\t  msglen, nodeid);\n\t\t\tgoto out;\n\t\t}\n\n\t\tp = (union dlm_packet *)((unsigned char *)p->opts.o_opts +\n\t\t\t\t\t le16_to_cpu(p->opts.o_optlen));\n\n\t\t \n\t\tmsglen = le16_to_cpu(p->header.h_length);\n\t\tswitch (p->header.h_cmd) {\n\t\tcase DLM_RCOM:\n\t\t\tif (msglen < sizeof(struct dlm_rcom)) {\n\t\t\t\tlog_print(\"inner rcom msg too small: %u, will skip this message from node %d\",\n\t\t\t\t\t  msglen, nodeid);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase DLM_MSG:\n\t\t\tif (msglen < sizeof(struct dlm_message)) {\n\t\t\t\tlog_print(\"inner msg too small: %u, will skip this message from node %d\",\n\t\t\t\t\t  msglen, nodeid);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase DLM_FIN:\n\t\t\tif (msglen < sizeof(struct dlm_header)) {\n\t\t\t\tlog_print(\"inner fin too small: %u, will skip this message from node %d\",\n\t\t\t\t\t  msglen, nodeid);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_print(\"unsupported inner h_cmd received: %u, will skip this message from node %d\",\n\t\t\t\t  msglen, nodeid);\n\t\t\tgoto out;\n\t\t}\n\n\t\tdlm_midcomms_receive_buffer(p, node, seq);\n\t\tbreak;\n\tcase DLM_ACK:\n\t\tseq = le32_to_cpu(p->header.u.h_seq);\n\t\tdlm_receive_ack(node, seq);\n\t\tbreak;\n\tdefault:\n\t\tlog_print(\"unsupported h_cmd received: %u, will skip this message from node %d\",\n\t\t\t  p->header.h_cmd, nodeid);\n\t\tbreak;\n\t}\n\nout:\n\tsrcu_read_unlock(&nodes_srcu, idx);\n}\n\nstatic void dlm_midcomms_receive_buffer_3_1(const union dlm_packet *p, int nodeid)\n{\n\tuint16_t msglen = le16_to_cpu(p->header.h_length);\n\tstruct midcomms_node *node;\n\tint idx;\n\n\tidx = srcu_read_lock(&nodes_srcu);\n\tnode = nodeid2node(nodeid);\n\tif (WARN_ON_ONCE(!node)) {\n\t\tsrcu_read_unlock(&nodes_srcu, idx);\n\t\treturn;\n\t}\n\n\tswitch (node->version) {\n\tcase DLM_VERSION_NOT_SET:\n\t\tnode->version = DLM_VERSION_3_1;\n\t\twake_up(&node->shutdown_wait);\n\t\tlog_print(\"version 0x%08x for node %d detected\", DLM_VERSION_3_1,\n\t\t\t  node->nodeid);\n\t\tbreak;\n\tcase DLM_VERSION_3_1:\n\t\tbreak;\n\tdefault:\n\t\tlog_print_ratelimited(\"version mismatch detected, assumed 0x%08x but node %d has 0x%08x\",\n\t\t\t\t      DLM_VERSION_3_1, node->nodeid, node->version);\n\t\tsrcu_read_unlock(&nodes_srcu, idx);\n\t\treturn;\n\t}\n\tsrcu_read_unlock(&nodes_srcu, idx);\n\n\tswitch (p->header.h_cmd) {\n\tcase DLM_RCOM:\n\t\t \n\t\tbreak;\n\tcase DLM_MSG:\n\t\tif (msglen < sizeof(struct dlm_message)) {\n\t\t\tlog_print(\"msg too small: %u, will skip this message from node %d\",\n\t\t\t\t  msglen, nodeid);\n\t\t\treturn;\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\tlog_print(\"unsupported h_cmd received: %u, will skip this message from node %d\",\n\t\t\t  p->header.h_cmd, nodeid);\n\t\treturn;\n\t}\n\n\tdlm_receive_buffer(p, nodeid);\n}\n\nint dlm_validate_incoming_buffer(int nodeid, unsigned char *buf, int len)\n{\n\tconst unsigned char *ptr = buf;\n\tconst struct dlm_header *hd;\n\tuint16_t msglen;\n\tint ret = 0;\n\n\twhile (len >= sizeof(struct dlm_header)) {\n\t\thd = (struct dlm_header *)ptr;\n\n\t\t \n\t\tmsglen = le16_to_cpu(hd->h_length);\n\t\tif (msglen > DLM_MAX_SOCKET_BUFSIZE ||\n\t\t    msglen < sizeof(struct dlm_header)) {\n\t\t\tlog_print(\"received invalid length header: %u from node %d, will abort message parsing\",\n\t\t\t\t  msglen, nodeid);\n\t\t\treturn -EBADMSG;\n\t\t}\n\n\t\t \n\t\tif (msglen > len)\n\t\t\tbreak;\n\n\t\tret += msglen;\n\t\tlen -= msglen;\n\t\tptr += msglen;\n\t}\n\n\treturn ret;\n}\n\n \nint dlm_process_incoming_buffer(int nodeid, unsigned char *buf, int len)\n{\n\tconst unsigned char *ptr = buf;\n\tconst struct dlm_header *hd;\n\tuint16_t msglen;\n\tint ret = 0;\n\n\twhile (len >= sizeof(struct dlm_header)) {\n\t\thd = (struct dlm_header *)ptr;\n\n\t\tmsglen = le16_to_cpu(hd->h_length);\n\t\tif (msglen > len)\n\t\t\tbreak;\n\n\t\tswitch (hd->h_version) {\n\t\tcase cpu_to_le32(DLM_VERSION_3_1):\n\t\t\tdlm_midcomms_receive_buffer_3_1((const union dlm_packet *)ptr, nodeid);\n\t\t\tbreak;\n\t\tcase cpu_to_le32(DLM_VERSION_3_2):\n\t\t\tdlm_midcomms_receive_buffer_3_2((const union dlm_packet *)ptr, nodeid);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_print(\"received invalid version header: %u from node %d, will skip this message\",\n\t\t\t\t  le32_to_cpu(hd->h_version), nodeid);\n\t\t\tbreak;\n\t\t}\n\n\t\tret += msglen;\n\t\tlen -= msglen;\n\t\tptr += msglen;\n\t}\n\n\treturn ret;\n}\n\nvoid dlm_midcomms_unack_msg_resend(int nodeid)\n{\n\tstruct midcomms_node *node;\n\tstruct dlm_mhandle *mh;\n\tint idx, ret;\n\n\tidx = srcu_read_lock(&nodes_srcu);\n\tnode = nodeid2node(nodeid);\n\tif (WARN_ON_ONCE(!node)) {\n\t\tsrcu_read_unlock(&nodes_srcu, idx);\n\t\treturn;\n\t}\n\n\t \n\tswitch (node->version) {\n\tcase DLM_VERSION_3_2:\n\t\tbreak;\n\tdefault:\n\t\tsrcu_read_unlock(&nodes_srcu, idx);\n\t\treturn;\n\t}\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(mh, &node->send_queue, list) {\n\t\tif (!mh->committed)\n\t\t\tcontinue;\n\n\t\tret = dlm_lowcomms_resend_msg(mh->msg);\n\t\tif (!ret)\n\t\t\tlog_print_ratelimited(\"retransmit dlm msg, seq %u, nodeid %d\",\n\t\t\t\t\t      mh->seq, node->nodeid);\n\t}\n\trcu_read_unlock();\n\tsrcu_read_unlock(&nodes_srcu, idx);\n}\n\nstatic void dlm_fill_opts_header(struct dlm_opts *opts, uint16_t inner_len,\n\t\t\t\t uint32_t seq)\n{\n\topts->o_header.h_cmd = DLM_OPTS;\n\topts->o_header.h_version = cpu_to_le32(DLM_HEADER_MAJOR | DLM_HEADER_MINOR);\n\topts->o_header.h_nodeid = cpu_to_le32(dlm_our_nodeid());\n\topts->o_header.h_length = cpu_to_le16(DLM_MIDCOMMS_OPT_LEN + inner_len);\n\topts->o_header.u.h_seq = cpu_to_le32(seq);\n}\n\nstatic void midcomms_new_msg_cb(void *data)\n{\n\tstruct dlm_mhandle *mh = data;\n\n\tatomic_inc(&mh->node->send_queue_cnt);\n\n\tspin_lock_bh(&mh->node->send_queue_lock);\n\tlist_add_tail_rcu(&mh->list, &mh->node->send_queue);\n\tspin_unlock_bh(&mh->node->send_queue_lock);\n\n\tmh->seq = atomic_fetch_inc(&mh->node->seq_send);\n}\n\nstatic struct dlm_msg *dlm_midcomms_get_msg_3_2(struct dlm_mhandle *mh, int nodeid,\n\t\t\t\t\t\tint len, gfp_t allocation, char **ppc)\n{\n\tstruct dlm_opts *opts;\n\tstruct dlm_msg *msg;\n\n\tmsg = dlm_lowcomms_new_msg(nodeid, len + DLM_MIDCOMMS_OPT_LEN,\n\t\t\t\t   allocation, ppc, midcomms_new_msg_cb, mh);\n\tif (!msg)\n\t\treturn NULL;\n\n\topts = (struct dlm_opts *)*ppc;\n\tmh->opts = opts;\n\n\t \n\tdlm_fill_opts_header(opts, len, mh->seq);\n\n\t*ppc += sizeof(*opts);\n\tmh->inner_p = (const union dlm_packet *)*ppc;\n\treturn msg;\n}\n\n \n#ifndef __CHECKER__\nstruct dlm_mhandle *dlm_midcomms_get_mhandle(int nodeid, int len,\n\t\t\t\t\t     gfp_t allocation, char **ppc)\n{\n\tstruct midcomms_node *node;\n\tstruct dlm_mhandle *mh;\n\tstruct dlm_msg *msg;\n\tint idx;\n\n\tidx = srcu_read_lock(&nodes_srcu);\n\tnode = nodeid2node(nodeid);\n\tif (WARN_ON_ONCE(!node))\n\t\tgoto err;\n\n\t \n\tWARN_ON_ONCE(test_bit(DLM_NODE_FLAG_STOP_TX, &node->flags));\n\n\tmh = dlm_allocate_mhandle(allocation);\n\tif (!mh)\n\t\tgoto err;\n\n\tmh->committed = false;\n\tmh->ack_rcv = NULL;\n\tmh->idx = idx;\n\tmh->node = node;\n\n\tswitch (node->version) {\n\tcase DLM_VERSION_3_1:\n\t\tmsg = dlm_lowcomms_new_msg(nodeid, len, allocation, ppc,\n\t\t\t\t\t   NULL, NULL);\n\t\tif (!msg) {\n\t\t\tdlm_free_mhandle(mh);\n\t\t\tgoto err;\n\t\t}\n\n\t\tbreak;\n\tcase DLM_VERSION_3_2:\n\t\t \n\t\tdlm_send_ack_threshold(node, DLM_SEND_ACK_BACK_MSG_THRESHOLD);\n\n\t\tmsg = dlm_midcomms_get_msg_3_2(mh, nodeid, len, allocation,\n\t\t\t\t\t       ppc);\n\t\tif (!msg) {\n\t\t\tdlm_free_mhandle(mh);\n\t\t\tgoto err;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdlm_free_mhandle(mh);\n\t\tWARN_ON_ONCE(1);\n\t\tgoto err;\n\t}\n\n\tmh->msg = msg;\n\n\t \n\treturn mh;\n\nerr:\n\tsrcu_read_unlock(&nodes_srcu, idx);\n\treturn NULL;\n}\n#endif\n\nstatic void dlm_midcomms_commit_msg_3_2_trace(const struct dlm_mhandle *mh,\n\t\t\t\t\t      const void *name, int namelen)\n{\n\tswitch (mh->inner_p->header.h_cmd) {\n\tcase DLM_MSG:\n\t\ttrace_dlm_send_message(mh->node->nodeid, mh->seq,\n\t\t\t\t       &mh->inner_p->message,\n\t\t\t\t       name, namelen);\n\t\tbreak;\n\tcase DLM_RCOM:\n\t\ttrace_dlm_send_rcom(mh->node->nodeid, mh->seq,\n\t\t\t\t    &mh->inner_p->rcom);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n}\n\nstatic void dlm_midcomms_commit_msg_3_2(struct dlm_mhandle *mh,\n\t\t\t\t\tconst void *name, int namelen)\n{\n\t \n\tmh->opts->o_nextcmd = mh->inner_p->header.h_cmd;\n\tmh->committed = true;\n\tdlm_midcomms_commit_msg_3_2_trace(mh, name, namelen);\n\tdlm_lowcomms_commit_msg(mh->msg);\n}\n\n \n#ifndef __CHECKER__\nvoid dlm_midcomms_commit_mhandle(struct dlm_mhandle *mh,\n\t\t\t\t const void *name, int namelen)\n{\n\n\tswitch (mh->node->version) {\n\tcase DLM_VERSION_3_1:\n\t\tsrcu_read_unlock(&nodes_srcu, mh->idx);\n\n\t\tdlm_lowcomms_commit_msg(mh->msg);\n\t\tdlm_lowcomms_put_msg(mh->msg);\n\t\t \n\t\tdlm_free_mhandle(mh);\n\t\tbreak;\n\tcase DLM_VERSION_3_2:\n\t\t \n\t\trcu_read_lock();\n\t\tdlm_midcomms_commit_msg_3_2(mh, name, namelen);\n\t\tsrcu_read_unlock(&nodes_srcu, mh->idx);\n\t\trcu_read_unlock();\n\t\tbreak;\n\tdefault:\n\t\tsrcu_read_unlock(&nodes_srcu, mh->idx);\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n}\n#endif\n\nint dlm_midcomms_start(void)\n{\n\treturn dlm_lowcomms_start();\n}\n\nvoid dlm_midcomms_stop(void)\n{\n\tdlm_lowcomms_stop();\n}\n\nvoid dlm_midcomms_init(void)\n{\n\tint i;\n\n\tfor (i = 0; i < CONN_HASH_SIZE; i++)\n\t\tINIT_HLIST_HEAD(&node_hash[i]);\n\n\tdlm_lowcomms_init();\n}\n\nstatic void midcomms_node_release(struct rcu_head *rcu)\n{\n\tstruct midcomms_node *node = container_of(rcu, struct midcomms_node, rcu);\n\n\tWARN_ON_ONCE(atomic_read(&node->send_queue_cnt));\n\tdlm_send_queue_flush(node);\n\tkfree(node);\n}\n\nvoid dlm_midcomms_exit(void)\n{\n\tstruct midcomms_node *node;\n\tint i, idx;\n\n\tidx = srcu_read_lock(&nodes_srcu);\n\tfor (i = 0; i < CONN_HASH_SIZE; i++) {\n\t\thlist_for_each_entry_rcu(node, &node_hash[i], hlist) {\n\t\t\tdlm_delete_debug_comms_file(node->debugfs);\n\n\t\t\tspin_lock(&nodes_lock);\n\t\t\thlist_del_rcu(&node->hlist);\n\t\t\tspin_unlock(&nodes_lock);\n\n\t\t\tcall_srcu(&nodes_srcu, &node->rcu, midcomms_node_release);\n\t\t}\n\t}\n\tsrcu_read_unlock(&nodes_srcu, idx);\n\n\tdlm_lowcomms_exit();\n}\n\nstatic void dlm_act_fin_ack_rcv(struct midcomms_node *node)\n{\n\tspin_lock(&node->state_lock);\n\tpr_debug(\"receive active fin ack from node %d with state %s\\n\",\n\t\t node->nodeid, dlm_state_str(node->state));\n\n\tswitch (node->state) {\n\tcase DLM_FIN_WAIT1:\n\t\tnode->state = DLM_FIN_WAIT2;\n\t\tpr_debug(\"switch node %d to state %s\\n\",\n\t\t\t node->nodeid, dlm_state_str(node->state));\n\t\tbreak;\n\tcase DLM_CLOSING:\n\t\tmidcomms_node_reset(node);\n\t\tpr_debug(\"switch node %d to state %s\\n\",\n\t\t\t node->nodeid, dlm_state_str(node->state));\n\t\tbreak;\n\tcase DLM_CLOSED:\n\t\t \n\t\twake_up(&node->shutdown_wait);\n\t\tbreak;\n\tdefault:\n\t\tspin_unlock(&node->state_lock);\n\t\tlog_print(\"%s: unexpected state: %d\",\n\t\t\t  __func__, node->state);\n\t\tWARN_ON_ONCE(1);\n\t\treturn;\n\t}\n\tspin_unlock(&node->state_lock);\n}\n\nvoid dlm_midcomms_add_member(int nodeid)\n{\n\tstruct midcomms_node *node;\n\tint idx;\n\n\tidx = srcu_read_lock(&nodes_srcu);\n\tnode = nodeid2node(nodeid);\n\tif (WARN_ON_ONCE(!node)) {\n\t\tsrcu_read_unlock(&nodes_srcu, idx);\n\t\treturn;\n\t}\n\n\tspin_lock(&node->state_lock);\n\tif (!node->users) {\n\t\tpr_debug(\"receive add member from node %d with state %s\\n\",\n\t\t\t node->nodeid, dlm_state_str(node->state));\n\t\tswitch (node->state) {\n\t\tcase DLM_ESTABLISHED:\n\t\t\tbreak;\n\t\tcase DLM_CLOSED:\n\t\t\tnode->state = DLM_ESTABLISHED;\n\t\t\tpr_debug(\"switch node %d to state %s\\n\",\n\t\t\t\t node->nodeid, dlm_state_str(node->state));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tlog_print(\"reset node %d because shutdown stuck\",\n\t\t\t\t  node->nodeid);\n\n\t\t\tmidcomms_node_reset(node);\n\t\t\tnode->state = DLM_ESTABLISHED;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tnode->users++;\n\tpr_debug(\"node %d users inc count %d\\n\", nodeid, node->users);\n\tspin_unlock(&node->state_lock);\n\n\tsrcu_read_unlock(&nodes_srcu, idx);\n}\n\nvoid dlm_midcomms_remove_member(int nodeid)\n{\n\tstruct midcomms_node *node;\n\tint idx;\n\n\tidx = srcu_read_lock(&nodes_srcu);\n\tnode = nodeid2node(nodeid);\n\t \n\tif (!node) {\n\t\tsrcu_read_unlock(&nodes_srcu, idx);\n\t\treturn;\n\t}\n\n\tspin_lock(&node->state_lock);\n\t \n\tif (!node->users) {\n\t\tspin_unlock(&node->state_lock);\n\t\tsrcu_read_unlock(&nodes_srcu, idx);\n\t\treturn;\n\t}\n\n\tnode->users--;\n\tpr_debug(\"node %d users dec count %d\\n\", nodeid, node->users);\n\n\t \n\tif (node->users == 0) {\n\t\tpr_debug(\"receive remove member from node %d with state %s\\n\",\n\t\t\t node->nodeid, dlm_state_str(node->state));\n\t\tswitch (node->state) {\n\t\tcase DLM_ESTABLISHED:\n\t\t\tbreak;\n\t\tcase DLM_CLOSE_WAIT:\n\t\t\t \n\t\t\tnode->state = DLM_LAST_ACK;\n\t\t\tpr_debug(\"switch node %d to state %s case 2\\n\",\n\t\t\t\t node->nodeid, dlm_state_str(node->state));\n\t\t\tset_bit(DLM_NODE_FLAG_STOP_RX, &node->flags);\n\t\t\tdlm_send_fin(node, dlm_pas_fin_ack_rcv);\n\t\t\tbreak;\n\t\tcase DLM_LAST_ACK:\n\t\t\t \n\t\t\tbreak;\n\t\tcase DLM_CLOSED:\n\t\t\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_print(\"%s: unexpected state: %d\",\n\t\t\t\t  __func__, node->state);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&node->state_lock);\n\n\tsrcu_read_unlock(&nodes_srcu, idx);\n}\n\nvoid dlm_midcomms_version_wait(void)\n{\n\tstruct midcomms_node *node;\n\tint i, idx, ret;\n\n\tidx = srcu_read_lock(&nodes_srcu);\n\tfor (i = 0; i < CONN_HASH_SIZE; i++) {\n\t\thlist_for_each_entry_rcu(node, &node_hash[i], hlist) {\n\t\t\tret = wait_event_timeout(node->shutdown_wait,\n\t\t\t\t\t\t node->version != DLM_VERSION_NOT_SET ||\n\t\t\t\t\t\t node->state == DLM_CLOSED ||\n\t\t\t\t\t\t test_bit(DLM_NODE_FLAG_CLOSE, &node->flags),\n\t\t\t\t\t\t DLM_SHUTDOWN_TIMEOUT);\n\t\t\tif (!ret || test_bit(DLM_NODE_FLAG_CLOSE, &node->flags))\n\t\t\t\tpr_debug(\"version wait timed out for node %d with state %s\\n\",\n\t\t\t\t\t node->nodeid, dlm_state_str(node->state));\n\t\t}\n\t}\n\tsrcu_read_unlock(&nodes_srcu, idx);\n}\n\nstatic void midcomms_shutdown(struct midcomms_node *node)\n{\n\tint ret;\n\n\t \n\tswitch (node->version) {\n\tcase DLM_VERSION_3_2:\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tspin_lock(&node->state_lock);\n\tpr_debug(\"receive active shutdown for node %d with state %s\\n\",\n\t\t node->nodeid, dlm_state_str(node->state));\n\tswitch (node->state) {\n\tcase DLM_ESTABLISHED:\n\t\tnode->state = DLM_FIN_WAIT1;\n\t\tpr_debug(\"switch node %d to state %s case 2\\n\",\n\t\t\t node->nodeid, dlm_state_str(node->state));\n\t\tdlm_send_fin(node, dlm_act_fin_ack_rcv);\n\t\tbreak;\n\tcase DLM_CLOSED:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\tspin_unlock(&node->state_lock);\n\n\tif (DLM_DEBUG_FENCE_TERMINATION)\n\t\tmsleep(5000);\n\n\t \n\tret = wait_event_timeout(node->shutdown_wait,\n\t\t\t\t node->state == DLM_CLOSED ||\n\t\t\t\t test_bit(DLM_NODE_FLAG_CLOSE, &node->flags),\n\t\t\t\t DLM_SHUTDOWN_TIMEOUT);\n\tif (!ret)\n\t\tpr_debug(\"active shutdown timed out for node %d with state %s\\n\",\n\t\t\t node->nodeid, dlm_state_str(node->state));\n\telse\n\t\tpr_debug(\"active shutdown done for node %d with state %s\\n\",\n\t\t\t node->nodeid, dlm_state_str(node->state));\n}\n\nvoid dlm_midcomms_shutdown(void)\n{\n\tstruct midcomms_node *node;\n\tint i, idx;\n\n\tmutex_lock(&close_lock);\n\tidx = srcu_read_lock(&nodes_srcu);\n\tfor (i = 0; i < CONN_HASH_SIZE; i++) {\n\t\thlist_for_each_entry_rcu(node, &node_hash[i], hlist) {\n\t\t\tmidcomms_shutdown(node);\n\t\t}\n\t}\n\n\tdlm_lowcomms_shutdown();\n\n\tfor (i = 0; i < CONN_HASH_SIZE; i++) {\n\t\thlist_for_each_entry_rcu(node, &node_hash[i], hlist) {\n\t\t\tmidcomms_node_reset(node);\n\t\t}\n\t}\n\tsrcu_read_unlock(&nodes_srcu, idx);\n\tmutex_unlock(&close_lock);\n}\n\nint dlm_midcomms_close(int nodeid)\n{\n\tstruct midcomms_node *node;\n\tint idx, ret;\n\n\tidx = srcu_read_lock(&nodes_srcu);\n\t \n\tnode = nodeid2node(nodeid);\n\tif (node) {\n\t\t \n\t\tset_bit(DLM_NODE_FLAG_CLOSE, &node->flags);\n\t\twake_up(&node->shutdown_wait);\n\t}\n\tsrcu_read_unlock(&nodes_srcu, idx);\n\n\tsynchronize_srcu(&nodes_srcu);\n\n\tmutex_lock(&close_lock);\n\tidx = srcu_read_lock(&nodes_srcu);\n\tnode = nodeid2node(nodeid);\n\tif (!node) {\n\t\tsrcu_read_unlock(&nodes_srcu, idx);\n\t\tmutex_unlock(&close_lock);\n\t\treturn dlm_lowcomms_close(nodeid);\n\t}\n\n\tret = dlm_lowcomms_close(nodeid);\n\tdlm_delete_debug_comms_file(node->debugfs);\n\n\tspin_lock(&nodes_lock);\n\thlist_del_rcu(&node->hlist);\n\tspin_unlock(&nodes_lock);\n\tsrcu_read_unlock(&nodes_srcu, idx);\n\n\t \n\tsynchronize_srcu(&nodes_srcu);\n\n\t \n\tdlm_send_queue_flush(node);\n\n\tcall_srcu(&nodes_srcu, &node->rcu, midcomms_node_release);\n\tmutex_unlock(&close_lock);\n\n\treturn ret;\n}\n\n \nstruct dlm_rawmsg_data {\n\tstruct midcomms_node *node;\n\tvoid *buf;\n};\n\nstatic void midcomms_new_rawmsg_cb(void *data)\n{\n\tstruct dlm_rawmsg_data *rd = data;\n\tstruct dlm_header *h = rd->buf;\n\n\tswitch (h->h_version) {\n\tcase cpu_to_le32(DLM_VERSION_3_1):\n\t\tbreak;\n\tdefault:\n\t\tswitch (h->h_cmd) {\n\t\tcase DLM_OPTS:\n\t\t\tif (!h->u.h_seq)\n\t\t\t\th->u.h_seq = cpu_to_le32(atomic_fetch_inc(&rd->node->seq_send));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n}\n\nint dlm_midcomms_rawmsg_send(struct midcomms_node *node, void *buf,\n\t\t\t     int buflen)\n{\n\tstruct dlm_rawmsg_data rd;\n\tstruct dlm_msg *msg;\n\tchar *msgbuf;\n\n\trd.node = node;\n\trd.buf = buf;\n\n\tmsg = dlm_lowcomms_new_msg(node->nodeid, buflen, GFP_NOFS,\n\t\t\t\t   &msgbuf, midcomms_new_rawmsg_cb, &rd);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tmemcpy(msgbuf, buf, buflen);\n\tdlm_lowcomms_commit_msg(msg);\n\treturn 0;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}