{
  "module_name": "lock.c",
  "hash_id": "3b978b612d3b10ea93a383a2c09ac906d19ef504a6f0d9ce76b3efc003ee194f",
  "original_prompt": "Ingested from linux-6.6.14/fs/dlm/lock.c",
  "human_readable_source": "\n \n\n \n#include <trace/events/dlm.h>\n\n#include <linux/types.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include \"dlm_internal.h\"\n#include <linux/dlm_device.h>\n#include \"memory.h\"\n#include \"midcomms.h\"\n#include \"requestqueue.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"ast.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"recover.h\"\n#include \"lvb_table.h\"\n#include \"user.h\"\n#include \"config.h\"\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    const struct dlm_message *ms, bool local);\nstatic int receive_extralen(const struct dlm_message *ms);\nstatic void do_purge(struct dlm_ls *ls, int nodeid, int pid);\nstatic void toss_rsb(struct kref *kref);\n\n \n\nstatic const int __dlm_compat_matrix[8][8] = {\n       \n        {1, 1, 1, 1, 1, 1, 1, 0},        \n        {1, 1, 1, 1, 1, 1, 1, 0},        \n        {1, 1, 1, 1, 1, 1, 0, 0},        \n        {1, 1, 1, 1, 0, 0, 0, 0},        \n        {1, 1, 1, 0, 1, 0, 0, 0},        \n        {1, 1, 1, 0, 0, 0, 0, 0},        \n        {1, 1, 0, 0, 0, 0, 0, 0},        \n        {0, 0, 0, 0, 0, 0, 0, 0}         \n};\n\n \n\nconst int dlm_lvb_operations[8][8] = {\n         \n        {  -1,  1,  1,  1,  1,  1,  1, -1 },  \n        {  -1,  1,  1,  1,  1,  1,  1,  0 },  \n        {  -1, -1,  1,  1,  1,  1,  1,  0 },  \n        {  -1, -1, -1,  1,  1,  1,  1,  0 },  \n        {  -1, -1, -1, -1,  1,  1,  1,  0 },  \n        {  -1,  0,  0,  0,  0,  0,  1,  0 },  \n        {  -1,  0,  0,  0,  0,  0,  0,  0 },  \n        {  -1,  0,  0,  0,  0,  0,  0,  0 }   \n};\n\n#define modes_compat(gr, rq) \\\n\t__dlm_compat_matrix[(gr)->lkb_grmode + 1][(rq)->lkb_rqmode + 1]\n\nint dlm_modes_compat(int mode1, int mode2)\n{\n\treturn __dlm_compat_matrix[mode1 + 1][mode2 + 1];\n}\n\n \n\nstatic const int __quecvt_compat_matrix[8][8] = {\n       \n        {0, 0, 0, 0, 0, 0, 0, 0},        \n        {0, 0, 1, 1, 1, 1, 1, 0},        \n        {0, 0, 0, 1, 1, 1, 1, 0},        \n        {0, 0, 0, 0, 1, 1, 1, 0},        \n        {0, 0, 0, 1, 0, 1, 1, 0},        \n        {0, 0, 0, 0, 0, 0, 1, 0},        \n        {0, 0, 0, 0, 0, 0, 0, 0},        \n        {0, 0, 0, 0, 0, 0, 0, 0}         \n};\n\nvoid dlm_print_lkb(struct dlm_lkb *lkb)\n{\n\tprintk(KERN_ERR \"lkb: nodeid %d id %x remid %x exflags %x flags %x \"\n\t       \"sts %d rq %d gr %d wait_type %d wait_nodeid %d seq %llu\\n\",\n\t       lkb->lkb_nodeid, lkb->lkb_id, lkb->lkb_remid, lkb->lkb_exflags,\n\t       dlm_iflags_val(lkb), lkb->lkb_status, lkb->lkb_rqmode,\n\t       lkb->lkb_grmode, lkb->lkb_wait_type, lkb->lkb_wait_nodeid,\n\t       (unsigned long long)lkb->lkb_recover_seq);\n}\n\nstatic void dlm_print_rsb(struct dlm_rsb *r)\n{\n\tprintk(KERN_ERR \"rsb: nodeid %d master %d dir %d flags %lx first %x \"\n\t       \"rlc %d name %s\\n\",\n\t       r->res_nodeid, r->res_master_nodeid, r->res_dir_nodeid,\n\t       r->res_flags, r->res_first_lkid, r->res_recover_locks_count,\n\t       r->res_name);\n}\n\nvoid dlm_dump_rsb(struct dlm_rsb *r)\n{\n\tstruct dlm_lkb *lkb;\n\n\tdlm_print_rsb(r);\n\n\tprintk(KERN_ERR \"rsb: root_list empty %d recover_list empty %d\\n\",\n\t       list_empty(&r->res_root_list), list_empty(&r->res_recover_list));\n\tprintk(KERN_ERR \"rsb lookup list\\n\");\n\tlist_for_each_entry(lkb, &r->res_lookup, lkb_rsb_lookup)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb grant queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_grantqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb convert queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_convertqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb wait queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_waitqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n}\n\n \n\nstatic inline void dlm_lock_recovery(struct dlm_ls *ls)\n{\n\tdown_read(&ls->ls_in_recovery);\n}\n\nvoid dlm_unlock_recovery(struct dlm_ls *ls)\n{\n\tup_read(&ls->ls_in_recovery);\n}\n\nint dlm_lock_recovery_try(struct dlm_ls *ls)\n{\n\treturn down_read_trylock(&ls->ls_in_recovery);\n}\n\nstatic inline int can_be_queued(struct dlm_lkb *lkb)\n{\n\treturn !(lkb->lkb_exflags & DLM_LKF_NOQUEUE);\n}\n\nstatic inline int force_blocking_asts(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_exflags & DLM_LKF_NOQUEUEBAST);\n}\n\nstatic inline int is_demoted(struct dlm_lkb *lkb)\n{\n\treturn test_bit(DLM_SBF_DEMOTED_BIT, &lkb->lkb_sbflags);\n}\n\nstatic inline int is_altmode(struct dlm_lkb *lkb)\n{\n\treturn test_bit(DLM_SBF_ALTMODE_BIT, &lkb->lkb_sbflags);\n}\n\nstatic inline int is_granted(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_status == DLM_LKSTS_GRANTED);\n}\n\nstatic inline int is_remote(struct dlm_rsb *r)\n{\n\tDLM_ASSERT(r->res_nodeid >= 0, dlm_print_rsb(r););\n\treturn !!r->res_nodeid;\n}\n\nstatic inline int is_process_copy(struct dlm_lkb *lkb)\n{\n\treturn lkb->lkb_nodeid &&\n\t       !test_bit(DLM_IFL_MSTCPY_BIT, &lkb->lkb_iflags);\n}\n\nstatic inline int is_master_copy(struct dlm_lkb *lkb)\n{\n\treturn test_bit(DLM_IFL_MSTCPY_BIT, &lkb->lkb_iflags);\n}\n\nstatic inline int middle_conversion(struct dlm_lkb *lkb)\n{\n\tif ((lkb->lkb_grmode==DLM_LOCK_PR && lkb->lkb_rqmode==DLM_LOCK_CW) ||\n\t    (lkb->lkb_rqmode==DLM_LOCK_PR && lkb->lkb_grmode==DLM_LOCK_CW))\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic inline int down_conversion(struct dlm_lkb *lkb)\n{\n\treturn (!middle_conversion(lkb) && lkb->lkb_rqmode < lkb->lkb_grmode);\n}\n\nstatic inline int is_overlap_unlock(struct dlm_lkb *lkb)\n{\n\treturn test_bit(DLM_IFL_OVERLAP_UNLOCK_BIT, &lkb->lkb_iflags);\n}\n\nstatic inline int is_overlap_cancel(struct dlm_lkb *lkb)\n{\n\treturn test_bit(DLM_IFL_OVERLAP_CANCEL_BIT, &lkb->lkb_iflags);\n}\n\nstatic inline int is_overlap(struct dlm_lkb *lkb)\n{\n\treturn test_bit(DLM_IFL_OVERLAP_UNLOCK_BIT, &lkb->lkb_iflags) ||\n\t       test_bit(DLM_IFL_OVERLAP_CANCEL_BIT, &lkb->lkb_iflags);\n}\n\nstatic void queue_cast(struct dlm_rsb *r, struct dlm_lkb *lkb, int rv)\n{\n\tif (is_master_copy(lkb))\n\t\treturn;\n\n\tDLM_ASSERT(lkb->lkb_lksb, dlm_print_lkb(lkb););\n\n\tif (rv == -DLM_ECANCEL &&\n\t    test_and_clear_bit(DLM_IFL_DEADLOCK_CANCEL_BIT, &lkb->lkb_iflags))\n\t\trv = -EDEADLK;\n\n\tdlm_add_cb(lkb, DLM_CB_CAST, lkb->lkb_grmode, rv, dlm_sbflags_val(lkb));\n}\n\nstatic inline void queue_cast_overlap(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tqueue_cast(r, lkb,\n\t\t   is_overlap_unlock(lkb) ? -DLM_EUNLOCK : -DLM_ECANCEL);\n}\n\nstatic void queue_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int rqmode)\n{\n\tif (is_master_copy(lkb)) {\n\t\tsend_bast(r, lkb, rqmode);\n\t} else {\n\t\tdlm_add_cb(lkb, DLM_CB_BAST, rqmode, 0, 0);\n\t}\n}\n\n \n\n \n\nstatic inline void hold_rsb(struct dlm_rsb *r)\n{\n\tkref_get(&r->res_ref);\n}\n\nvoid dlm_hold_rsb(struct dlm_rsb *r)\n{\n\thold_rsb(r);\n}\n\n \n\nstatic void put_rsb(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\tuint32_t bucket = r->res_bucket;\n\tint rv;\n\n\trv = kref_put_lock(&r->res_ref, toss_rsb,\n\t\t\t   &ls->ls_rsbtbl[bucket].lock);\n\tif (rv)\n\t\tspin_unlock(&ls->ls_rsbtbl[bucket].lock);\n}\n\nvoid dlm_put_rsb(struct dlm_rsb *r)\n{\n\tput_rsb(r);\n}\n\nstatic int pre_rsb_struct(struct dlm_ls *ls)\n{\n\tstruct dlm_rsb *r1, *r2;\n\tint count = 0;\n\n\tspin_lock(&ls->ls_new_rsb_spin);\n\tif (ls->ls_new_rsb_count > dlm_config.ci_new_rsb_count / 2) {\n\t\tspin_unlock(&ls->ls_new_rsb_spin);\n\t\treturn 0;\n\t}\n\tspin_unlock(&ls->ls_new_rsb_spin);\n\n\tr1 = dlm_allocate_rsb(ls);\n\tr2 = dlm_allocate_rsb(ls);\n\n\tspin_lock(&ls->ls_new_rsb_spin);\n\tif (r1) {\n\t\tlist_add(&r1->res_hashchain, &ls->ls_new_rsb);\n\t\tls->ls_new_rsb_count++;\n\t}\n\tif (r2) {\n\t\tlist_add(&r2->res_hashchain, &ls->ls_new_rsb);\n\t\tls->ls_new_rsb_count++;\n\t}\n\tcount = ls->ls_new_rsb_count;\n\tspin_unlock(&ls->ls_new_rsb_spin);\n\n\tif (!count)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\n \n\nstatic int get_rsb_struct(struct dlm_ls *ls, const void *name, int len,\n\t\t\t  struct dlm_rsb **r_ret)\n{\n\tstruct dlm_rsb *r;\n\tint count;\n\n\tspin_lock(&ls->ls_new_rsb_spin);\n\tif (list_empty(&ls->ls_new_rsb)) {\n\t\tcount = ls->ls_new_rsb_count;\n\t\tspin_unlock(&ls->ls_new_rsb_spin);\n\t\tlog_debug(ls, \"find_rsb retry %d %d %s\",\n\t\t\t  count, dlm_config.ci_new_rsb_count,\n\t\t\t  (const char *)name);\n\t\treturn -EAGAIN;\n\t}\n\n\tr = list_first_entry(&ls->ls_new_rsb, struct dlm_rsb, res_hashchain);\n\tlist_del(&r->res_hashchain);\n\t \n\tmemset(&r->res_hashnode, 0, sizeof(struct rb_node));\n\tls->ls_new_rsb_count--;\n\tspin_unlock(&ls->ls_new_rsb_spin);\n\n\tr->res_ls = ls;\n\tr->res_length = len;\n\tmemcpy(r->res_name, name, len);\n\tmutex_init(&r->res_mutex);\n\n\tINIT_LIST_HEAD(&r->res_lookup);\n\tINIT_LIST_HEAD(&r->res_grantqueue);\n\tINIT_LIST_HEAD(&r->res_convertqueue);\n\tINIT_LIST_HEAD(&r->res_waitqueue);\n\tINIT_LIST_HEAD(&r->res_root_list);\n\tINIT_LIST_HEAD(&r->res_recover_list);\n\n\t*r_ret = r;\n\treturn 0;\n}\n\nstatic int rsb_cmp(struct dlm_rsb *r, const char *name, int nlen)\n{\n\tchar maxname[DLM_RESNAME_MAXLEN];\n\n\tmemset(maxname, 0, DLM_RESNAME_MAXLEN);\n\tmemcpy(maxname, name, nlen);\n\treturn memcmp(r->res_name, maxname, DLM_RESNAME_MAXLEN);\n}\n\nint dlm_search_rsb_tree(struct rb_root *tree, const void *name, int len,\n\t\t\tstruct dlm_rsb **r_ret)\n{\n\tstruct rb_node *node = tree->rb_node;\n\tstruct dlm_rsb *r;\n\tint rc;\n\n\twhile (node) {\n\t\tr = rb_entry(node, struct dlm_rsb, res_hashnode);\n\t\trc = rsb_cmp(r, name, len);\n\t\tif (rc < 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (rc > 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\tgoto found;\n\t}\n\t*r_ret = NULL;\n\treturn -EBADR;\n\n found:\n\t*r_ret = r;\n\treturn 0;\n}\n\nstatic int rsb_insert(struct dlm_rsb *rsb, struct rb_root *tree)\n{\n\tstruct rb_node **newn = &tree->rb_node;\n\tstruct rb_node *parent = NULL;\n\tint rc;\n\n\twhile (*newn) {\n\t\tstruct dlm_rsb *cur = rb_entry(*newn, struct dlm_rsb,\n\t\t\t\t\t       res_hashnode);\n\n\t\tparent = *newn;\n\t\trc = rsb_cmp(cur, rsb->res_name, rsb->res_length);\n\t\tif (rc < 0)\n\t\t\tnewn = &parent->rb_left;\n\t\telse if (rc > 0)\n\t\t\tnewn = &parent->rb_right;\n\t\telse {\n\t\t\tlog_print(\"rsb_insert match\");\n\t\t\tdlm_dump_rsb(rsb);\n\t\t\tdlm_dump_rsb(cur);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\n\trb_link_node(&rsb->res_hashnode, parent, newn);\n\trb_insert_color(&rsb->res_hashnode, tree);\n\treturn 0;\n}\n\n \n\nstatic int find_rsb_dir(struct dlm_ls *ls, const void *name, int len,\n\t\t\tuint32_t hash, uint32_t b,\n\t\t\tint dir_nodeid, int from_nodeid,\n\t\t\tunsigned int flags, struct dlm_rsb **r_ret)\n{\n\tstruct dlm_rsb *r = NULL;\n\tint our_nodeid = dlm_our_nodeid();\n\tint from_local = 0;\n\tint from_other = 0;\n\tint from_dir = 0;\n\tint create = 0;\n\tint error;\n\n\tif (flags & R_RECEIVE_REQUEST) {\n\t\tif (from_nodeid == dir_nodeid)\n\t\t\tfrom_dir = 1;\n\t\telse\n\t\t\tfrom_other = 1;\n\t} else if (flags & R_REQUEST) {\n\t\tfrom_local = 1;\n\t}\n\n\t \n\n\tif (from_local || from_dir ||\n\t    (from_other && (dir_nodeid == our_nodeid))) {\n\t\tcreate = 1;\n\t}\n\n retry:\n\tif (create) {\n\t\terror = pre_rsb_struct(ls);\n\t\tif (error < 0)\n\t\t\tgoto out;\n\t}\n\n\tspin_lock(&ls->ls_rsbtbl[b].lock);\n\n\terror = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].keep, name, len, &r);\n\tif (error)\n\t\tgoto do_toss;\n\t\n\t \n\n\tkref_get(&r->res_ref);\n\tgoto out_unlock;\n\n\n do_toss:\n\terror = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].toss, name, len, &r);\n\tif (error)\n\t\tgoto do_new;\n\n\t \n\n\tif ((r->res_master_nodeid != our_nodeid) && from_other) {\n\t\t \n\t\tlog_debug(ls, \"find_rsb toss from_other %d master %d dir %d %s\",\n\t\t\t  from_nodeid, r->res_master_nodeid, dir_nodeid,\n\t\t\t  r->res_name);\n\t\terror = -ENOTBLK;\n\t\tgoto out_unlock;\n\t}\n\n\tif ((r->res_master_nodeid != our_nodeid) && from_dir) {\n\t\t \n\t\tlog_error(ls, \"find_rsb toss from_dir %d master %d\",\n\t\t\t  from_nodeid, r->res_master_nodeid);\n\t\tdlm_print_rsb(r);\n\t\t \n\t\tr->res_master_nodeid = our_nodeid;\n\t\tr->res_nodeid = 0;\n\t\trsb_clear_flag(r, RSB_MASTER_UNCERTAIN);\n\t\tr->res_first_lkid = 0;\n\t}\n\n\tif (from_local && (r->res_master_nodeid != our_nodeid)) {\n\t\t \n\t\trsb_set_flag(r, RSB_MASTER_UNCERTAIN);\n\t\tr->res_first_lkid = 0;\n\t}\n\n\trb_erase(&r->res_hashnode, &ls->ls_rsbtbl[b].toss);\n\terror = rsb_insert(r, &ls->ls_rsbtbl[b].keep);\n\tgoto out_unlock;\n\n\n do_new:\n\t \n\n\tif (error == -EBADR && !create)\n\t\tgoto out_unlock;\n\n\terror = get_rsb_struct(ls, name, len, &r);\n\tif (error == -EAGAIN) {\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\tgoto retry;\n\t}\n\tif (error)\n\t\tgoto out_unlock;\n\n\tr->res_hash = hash;\n\tr->res_bucket = b;\n\tr->res_dir_nodeid = dir_nodeid;\n\tkref_init(&r->res_ref);\n\n\tif (from_dir) {\n\t\t \n\t\tlog_debug(ls, \"find_rsb new from_dir %d recreate %s\",\n\t\t\t  from_nodeid, r->res_name);\n\t\tr->res_master_nodeid = our_nodeid;\n\t\tr->res_nodeid = 0;\n\t\tgoto out_add;\n\t}\n\n\tif (from_other && (dir_nodeid != our_nodeid)) {\n\t\t \n\t\tlog_error(ls, \"find_rsb new from_other %d dir %d our %d %s\",\n\t\t\t  from_nodeid, dir_nodeid, our_nodeid, r->res_name);\n\t\tdlm_free_rsb(r);\n\t\tr = NULL;\n\t\terror = -ENOTBLK;\n\t\tgoto out_unlock;\n\t}\n\n\tif (from_other) {\n\t\tlog_debug(ls, \"find_rsb new from_other %d dir %d %s\",\n\t\t\t  from_nodeid, dir_nodeid, r->res_name);\n\t}\n\n\tif (dir_nodeid == our_nodeid) {\n\t\t \n\t\tr->res_master_nodeid = our_nodeid;\n\t\tr->res_nodeid = 0;\n\t} else {\n\t\t \n\t\tr->res_master_nodeid = 0;\n\t\tr->res_nodeid = -1;\n\t}\n\n out_add:\n\terror = rsb_insert(r, &ls->ls_rsbtbl[b].keep);\n out_unlock:\n\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n out:\n\t*r_ret = r;\n\treturn error;\n}\n\n \n\nstatic int find_rsb_nodir(struct dlm_ls *ls, const void *name, int len,\n\t\t\t  uint32_t hash, uint32_t b,\n\t\t\t  int dir_nodeid, int from_nodeid,\n\t\t\t  unsigned int flags, struct dlm_rsb **r_ret)\n{\n\tstruct dlm_rsb *r = NULL;\n\tint our_nodeid = dlm_our_nodeid();\n\tint recover = (flags & R_RECEIVE_RECOVER);\n\tint error;\n\n retry:\n\terror = pre_rsb_struct(ls);\n\tif (error < 0)\n\t\tgoto out;\n\n\tspin_lock(&ls->ls_rsbtbl[b].lock);\n\n\terror = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].keep, name, len, &r);\n\tif (error)\n\t\tgoto do_toss;\n\n\t \n\n\tkref_get(&r->res_ref);\n\tgoto out_unlock;\n\n\n do_toss:\n\terror = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].toss, name, len, &r);\n\tif (error)\n\t\tgoto do_new;\n\n\t \n\n\tif (!recover && (r->res_master_nodeid != our_nodeid) && from_nodeid) {\n\t\t \n\t\tlog_error(ls, \"find_rsb toss from_nodeid %d master %d dir %d\",\n\t\t\t  from_nodeid, r->res_master_nodeid, dir_nodeid);\n\t\tdlm_print_rsb(r);\n\t\terror = -ENOTBLK;\n\t\tgoto out_unlock;\n\t}\n\n\tif (!recover && (r->res_master_nodeid != our_nodeid) &&\n\t    (dir_nodeid == our_nodeid)) {\n\t\t \n\t\tlog_error(ls, \"find_rsb toss our %d master %d dir %d\",\n\t\t\t  our_nodeid, r->res_master_nodeid, dir_nodeid);\n\t\tdlm_print_rsb(r);\n\t\tr->res_master_nodeid = our_nodeid;\n\t\tr->res_nodeid = 0;\n\t}\n\n\trb_erase(&r->res_hashnode, &ls->ls_rsbtbl[b].toss);\n\terror = rsb_insert(r, &ls->ls_rsbtbl[b].keep);\n\tgoto out_unlock;\n\n\n do_new:\n\t \n\n\terror = get_rsb_struct(ls, name, len, &r);\n\tif (error == -EAGAIN) {\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\tgoto retry;\n\t}\n\tif (error)\n\t\tgoto out_unlock;\n\n\tr->res_hash = hash;\n\tr->res_bucket = b;\n\tr->res_dir_nodeid = dir_nodeid;\n\tr->res_master_nodeid = dir_nodeid;\n\tr->res_nodeid = (dir_nodeid == our_nodeid) ? 0 : dir_nodeid;\n\tkref_init(&r->res_ref);\n\n\terror = rsb_insert(r, &ls->ls_rsbtbl[b].keep);\n out_unlock:\n\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n out:\n\t*r_ret = r;\n\treturn error;\n}\n\nstatic int find_rsb(struct dlm_ls *ls, const void *name, int len,\n\t\t    int from_nodeid, unsigned int flags,\n\t\t    struct dlm_rsb **r_ret)\n{\n\tuint32_t hash, b;\n\tint dir_nodeid;\n\n\tif (len > DLM_RESNAME_MAXLEN)\n\t\treturn -EINVAL;\n\n\thash = jhash(name, len, 0);\n\tb = hash & (ls->ls_rsbtbl_size - 1);\n\n\tdir_nodeid = dlm_hash2nodeid(ls, hash);\n\n\tif (dlm_no_directory(ls))\n\t\treturn find_rsb_nodir(ls, name, len, hash, b, dir_nodeid,\n\t\t\t\t      from_nodeid, flags, r_ret);\n\telse\n\t\treturn find_rsb_dir(ls, name, len, hash, b, dir_nodeid,\n\t\t\t\t      from_nodeid, flags, r_ret);\n}\n\n \n\nstatic int validate_master_nodeid(struct dlm_ls *ls, struct dlm_rsb *r,\n\t\t\t\t  int from_nodeid)\n{\n\tif (dlm_no_directory(ls)) {\n\t\tlog_error(ls, \"find_rsb keep from_nodeid %d master %d dir %d\",\n\t\t\t  from_nodeid, r->res_master_nodeid,\n\t\t\t  r->res_dir_nodeid);\n\t\tdlm_print_rsb(r);\n\t\treturn -ENOTBLK;\n\t}\n\n\tif (from_nodeid != r->res_dir_nodeid) {\n\t\t \n\n\t\tif (r->res_master_nodeid) {\n\t\t\tlog_debug(ls, \"validate master from_other %d master %d \"\n\t\t\t\t  \"dir %d first %x %s\", from_nodeid,\n\t\t\t\t  r->res_master_nodeid, r->res_dir_nodeid,\n\t\t\t\t  r->res_first_lkid, r->res_name);\n\t\t}\n\t\treturn -ENOTBLK;\n\t} else {\n\t\t \n\n\t\tif (r->res_master_nodeid) {\n\t\t\tlog_error(ls, \"validate master from_dir %d master %d \"\n\t\t\t\t  \"first %x %s\",\n\t\t\t\t  from_nodeid, r->res_master_nodeid,\n\t\t\t\t  r->res_first_lkid, r->res_name);\n\t\t}\n\n\t\tr->res_master_nodeid = dlm_our_nodeid();\n\t\tr->res_nodeid = 0;\n\t\treturn 0;\n\t}\n}\n\nstatic void __dlm_master_lookup(struct dlm_ls *ls, struct dlm_rsb *r, int our_nodeid,\n\t\t\t\tint from_nodeid, bool toss_list, unsigned int flags,\n\t\t\t\tint *r_nodeid, int *result)\n{\n\tint fix_master = (flags & DLM_LU_RECOVER_MASTER);\n\tint from_master = (flags & DLM_LU_RECOVER_DIR);\n\n\tif (r->res_dir_nodeid != our_nodeid) {\n\t\t \n\t\tlog_error(ls, \"%s res_dir %d our %d %s\", __func__,\n\t\t\t  r->res_dir_nodeid, our_nodeid, r->res_name);\n\t\tr->res_dir_nodeid = our_nodeid;\n\t}\n\n\tif (fix_master && dlm_is_removed(ls, r->res_master_nodeid)) {\n\t\t \n\n\t\tr->res_master_nodeid = from_nodeid;\n\t\tr->res_nodeid = from_nodeid;\n\t\trsb_set_flag(r, RSB_NEW_MASTER);\n\n\t\tif (toss_list) {\n\t\t\t \n\t\t\tlog_error(ls, \"%s fix_master on toss\", __func__);\n\t\t\tdlm_dump_rsb(r);\n\t\t}\n\t}\n\n\tif (from_master && (r->res_master_nodeid != from_nodeid)) {\n\t\t \n\n\t\tlog_limit(ls, \"%s from_master %d master_nodeid %d res_nodeid %d first %x %s\",\n\t\t\t  __func__, from_nodeid, r->res_master_nodeid,\n\t\t\t  r->res_nodeid, r->res_first_lkid, r->res_name);\n\n\t\tif (r->res_master_nodeid == our_nodeid) {\n\t\t\tlog_error(ls, \"from_master %d our_master\", from_nodeid);\n\t\t\tdlm_dump_rsb(r);\n\t\t\tgoto ret_assign;\n\t\t}\n\n\t\tr->res_master_nodeid = from_nodeid;\n\t\tr->res_nodeid = from_nodeid;\n\t\trsb_set_flag(r, RSB_NEW_MASTER);\n\t}\n\n\tif (!r->res_master_nodeid) {\n\t\t \n\n\t\tlog_debug(ls, \"%s master 0 to %d first %x %s\", __func__,\n\t\t\t  from_nodeid, r->res_first_lkid, r->res_name);\n\t\tr->res_master_nodeid = from_nodeid;\n\t\tr->res_nodeid = from_nodeid;\n\t}\n\n\tif (!from_master && !fix_master &&\n\t    (r->res_master_nodeid == from_nodeid)) {\n\t\t \n\n\t\tlog_limit(ls, \"%s from master %d flags %x first %x %s\",\n\t\t\t  __func__, from_nodeid, flags, r->res_first_lkid,\n\t\t\t  r->res_name);\n\t}\n\n ret_assign:\n\t*r_nodeid = r->res_master_nodeid;\n\tif (result)\n\t\t*result = DLM_LU_MATCH;\n}\n\n \n\nint dlm_master_lookup(struct dlm_ls *ls, int from_nodeid, const char *name,\n\t\t      int len, unsigned int flags, int *r_nodeid, int *result)\n{\n\tstruct dlm_rsb *r = NULL;\n\tuint32_t hash, b;\n\tint our_nodeid = dlm_our_nodeid();\n\tint dir_nodeid, error;\n\n\tif (len > DLM_RESNAME_MAXLEN)\n\t\treturn -EINVAL;\n\n\tif (from_nodeid == our_nodeid) {\n\t\tlog_error(ls, \"dlm_master_lookup from our_nodeid %d flags %x\",\n\t\t\t  our_nodeid, flags);\n\t\treturn -EINVAL;\n\t}\n\n\thash = jhash(name, len, 0);\n\tb = hash & (ls->ls_rsbtbl_size - 1);\n\n\tdir_nodeid = dlm_hash2nodeid(ls, hash);\n\tif (dir_nodeid != our_nodeid) {\n\t\tlog_error(ls, \"dlm_master_lookup from %d dir %d our %d h %x %d\",\n\t\t\t  from_nodeid, dir_nodeid, our_nodeid, hash,\n\t\t\t  ls->ls_num_nodes);\n\t\t*r_nodeid = -1;\n\t\treturn -EINVAL;\n\t}\n\n retry:\n\terror = pre_rsb_struct(ls);\n\tif (error < 0)\n\t\treturn error;\n\n\tspin_lock(&ls->ls_rsbtbl[b].lock);\n\terror = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].keep, name, len, &r);\n\tif (!error) {\n\t\t \n\n\t\thold_rsb(r);\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\tlock_rsb(r);\n\n\t\t__dlm_master_lookup(ls, r, our_nodeid, from_nodeid, false,\n\t\t\t\t    flags, r_nodeid, result);\n\n\t\t \n\t\tunlock_rsb(r);\n\t\tput_rsb(r);\n\n\t\treturn 0;\n\t}\n\n\terror = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].toss, name, len, &r);\n\tif (error)\n\t\tgoto not_found;\n\n\t \n\n\t__dlm_master_lookup(ls, r, our_nodeid, from_nodeid, true, flags,\n\t\t\t    r_nodeid, result);\n\n\tr->res_toss_time = jiffies;\n\t \n\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\n\treturn 0;\n\n not_found:\n\terror = get_rsb_struct(ls, name, len, &r);\n\tif (error == -EAGAIN) {\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\tgoto retry;\n\t}\n\tif (error)\n\t\tgoto out_unlock;\n\n\tr->res_hash = hash;\n\tr->res_bucket = b;\n\tr->res_dir_nodeid = our_nodeid;\n\tr->res_master_nodeid = from_nodeid;\n\tr->res_nodeid = from_nodeid;\n\tkref_init(&r->res_ref);\n\tr->res_toss_time = jiffies;\n\n\terror = rsb_insert(r, &ls->ls_rsbtbl[b].toss);\n\tif (error) {\n\t\t \n\t\tdlm_free_rsb(r);\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\tgoto retry;\n\t}\n\n\tif (result)\n\t\t*result = DLM_LU_ADD;\n\t*r_nodeid = from_nodeid;\n out_unlock:\n\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\treturn error;\n}\n\nstatic void dlm_dump_rsb_hash(struct dlm_ls *ls, uint32_t hash)\n{\n\tstruct rb_node *n;\n\tstruct dlm_rsb *r;\n\tint i;\n\n\tfor (i = 0; i < ls->ls_rsbtbl_size; i++) {\n\t\tspin_lock(&ls->ls_rsbtbl[i].lock);\n\t\tfor (n = rb_first(&ls->ls_rsbtbl[i].keep); n; n = rb_next(n)) {\n\t\t\tr = rb_entry(n, struct dlm_rsb, res_hashnode);\n\t\t\tif (r->res_hash == hash)\n\t\t\t\tdlm_dump_rsb(r);\n\t\t}\n\t\tspin_unlock(&ls->ls_rsbtbl[i].lock);\n\t}\n}\n\nvoid dlm_dump_rsb_name(struct dlm_ls *ls, const char *name, int len)\n{\n\tstruct dlm_rsb *r = NULL;\n\tuint32_t hash, b;\n\tint error;\n\n\thash = jhash(name, len, 0);\n\tb = hash & (ls->ls_rsbtbl_size - 1);\n\n\tspin_lock(&ls->ls_rsbtbl[b].lock);\n\terror = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].keep, name, len, &r);\n\tif (!error)\n\t\tgoto out_dump;\n\n\terror = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].toss, name, len, &r);\n\tif (error)\n\t\tgoto out;\n out_dump:\n\tdlm_dump_rsb(r);\n out:\n\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n}\n\nstatic void toss_rsb(struct kref *kref)\n{\n\tstruct dlm_rsb *r = container_of(kref, struct dlm_rsb, res_ref);\n\tstruct dlm_ls *ls = r->res_ls;\n\n\tDLM_ASSERT(list_empty(&r->res_root_list), dlm_print_rsb(r););\n\tkref_init(&r->res_ref);\n\trb_erase(&r->res_hashnode, &ls->ls_rsbtbl[r->res_bucket].keep);\n\trsb_insert(r, &ls->ls_rsbtbl[r->res_bucket].toss);\n\tr->res_toss_time = jiffies;\n\tset_bit(DLM_RTF_SHRINK_BIT, &ls->ls_rsbtbl[r->res_bucket].flags);\n\tif (r->res_lvbptr) {\n\t\tdlm_free_lvb(r->res_lvbptr);\n\t\tr->res_lvbptr = NULL;\n\t}\n}\n\n \n\nstatic void unhold_rsb(struct dlm_rsb *r)\n{\n\tint rv;\n\trv = kref_put(&r->res_ref, toss_rsb);\n\tDLM_ASSERT(!rv, dlm_dump_rsb(r););\n}\n\nstatic void kill_rsb(struct kref *kref)\n{\n\tstruct dlm_rsb *r = container_of(kref, struct dlm_rsb, res_ref);\n\n\t \n\n\tDLM_ASSERT(list_empty(&r->res_lookup), dlm_dump_rsb(r););\n\tDLM_ASSERT(list_empty(&r->res_grantqueue), dlm_dump_rsb(r););\n\tDLM_ASSERT(list_empty(&r->res_convertqueue), dlm_dump_rsb(r););\n\tDLM_ASSERT(list_empty(&r->res_waitqueue), dlm_dump_rsb(r););\n\tDLM_ASSERT(list_empty(&r->res_root_list), dlm_dump_rsb(r););\n\tDLM_ASSERT(list_empty(&r->res_recover_list), dlm_dump_rsb(r););\n}\n\n \n\nstatic void attach_lkb(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\thold_rsb(r);\n\tlkb->lkb_resource = r;\n}\n\nstatic void detach_lkb(struct dlm_lkb *lkb)\n{\n\tif (lkb->lkb_resource) {\n\t\tput_rsb(lkb->lkb_resource);\n\t\tlkb->lkb_resource = NULL;\n\t}\n}\n\nstatic int _create_lkb(struct dlm_ls *ls, struct dlm_lkb **lkb_ret,\n\t\t       int start, int end)\n{\n\tstruct dlm_lkb *lkb;\n\tint rv;\n\n\tlkb = dlm_allocate_lkb(ls);\n\tif (!lkb)\n\t\treturn -ENOMEM;\n\n\tlkb->lkb_last_bast_mode = -1;\n\tlkb->lkb_nodeid = -1;\n\tlkb->lkb_grmode = DLM_LOCK_IV;\n\tkref_init(&lkb->lkb_ref);\n\tINIT_LIST_HEAD(&lkb->lkb_ownqueue);\n\tINIT_LIST_HEAD(&lkb->lkb_rsb_lookup);\n\tINIT_LIST_HEAD(&lkb->lkb_cb_list);\n\tINIT_LIST_HEAD(&lkb->lkb_callbacks);\n\tspin_lock_init(&lkb->lkb_cb_lock);\n\tINIT_WORK(&lkb->lkb_cb_work, dlm_callback_work);\n\n\tidr_preload(GFP_NOFS);\n\tspin_lock(&ls->ls_lkbidr_spin);\n\trv = idr_alloc(&ls->ls_lkbidr, lkb, start, end, GFP_NOWAIT);\n\tif (rv >= 0)\n\t\tlkb->lkb_id = rv;\n\tspin_unlock(&ls->ls_lkbidr_spin);\n\tidr_preload_end();\n\n\tif (rv < 0) {\n\t\tlog_error(ls, \"create_lkb idr error %d\", rv);\n\t\tdlm_free_lkb(lkb);\n\t\treturn rv;\n\t}\n\n\t*lkb_ret = lkb;\n\treturn 0;\n}\n\nstatic int create_lkb(struct dlm_ls *ls, struct dlm_lkb **lkb_ret)\n{\n\treturn _create_lkb(ls, lkb_ret, 1, 0);\n}\n\nstatic int find_lkb(struct dlm_ls *ls, uint32_t lkid, struct dlm_lkb **lkb_ret)\n{\n\tstruct dlm_lkb *lkb;\n\n\tspin_lock(&ls->ls_lkbidr_spin);\n\tlkb = idr_find(&ls->ls_lkbidr, lkid);\n\tif (lkb)\n\t\tkref_get(&lkb->lkb_ref);\n\tspin_unlock(&ls->ls_lkbidr_spin);\n\n\t*lkb_ret = lkb;\n\treturn lkb ? 0 : -ENOENT;\n}\n\nstatic void kill_lkb(struct kref *kref)\n{\n\tstruct dlm_lkb *lkb = container_of(kref, struct dlm_lkb, lkb_ref);\n\n\t \n\n\tDLM_ASSERT(!lkb->lkb_status, dlm_print_lkb(lkb););\n}\n\n \n\nstatic int __put_lkb(struct dlm_ls *ls, struct dlm_lkb *lkb)\n{\n\tuint32_t lkid = lkb->lkb_id;\n\tint rv;\n\n\trv = kref_put_lock(&lkb->lkb_ref, kill_lkb,\n\t\t\t   &ls->ls_lkbidr_spin);\n\tif (rv) {\n\t\tidr_remove(&ls->ls_lkbidr, lkid);\n\t\tspin_unlock(&ls->ls_lkbidr_spin);\n\n\t\tdetach_lkb(lkb);\n\n\t\t \n\t\tif (lkb->lkb_lvbptr && is_master_copy(lkb))\n\t\t\tdlm_free_lvb(lkb->lkb_lvbptr);\n\t\tdlm_free_lkb(lkb);\n\t}\n\n\treturn rv;\n}\n\nint dlm_put_lkb(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls;\n\n\tDLM_ASSERT(lkb->lkb_resource, dlm_print_lkb(lkb););\n\tDLM_ASSERT(lkb->lkb_resource->res_ls, dlm_print_lkb(lkb););\n\n\tls = lkb->lkb_resource->res_ls;\n\treturn __put_lkb(ls, lkb);\n}\n\n \n\nstatic inline void hold_lkb(struct dlm_lkb *lkb)\n{\n\tkref_get(&lkb->lkb_ref);\n}\n\nstatic void unhold_lkb_assert(struct kref *kref)\n{\n\tstruct dlm_lkb *lkb = container_of(kref, struct dlm_lkb, lkb_ref);\n\n\tDLM_ASSERT(false, dlm_print_lkb(lkb););\n}\n\n \n\nstatic inline void unhold_lkb(struct dlm_lkb *lkb)\n{\n\tkref_put(&lkb->lkb_ref, unhold_lkb_assert);\n}\n\nstatic void lkb_add_ordered(struct list_head *new, struct list_head *head,\n\t\t\t    int mode)\n{\n\tstruct dlm_lkb *lkb = NULL, *iter;\n\n\tlist_for_each_entry(iter, head, lkb_statequeue)\n\t\tif (iter->lkb_rqmode < mode) {\n\t\t\tlkb = iter;\n\t\t\tlist_add_tail(new, &iter->lkb_statequeue);\n\t\t\tbreak;\n\t\t}\n\n\tif (!lkb)\n\t\tlist_add_tail(new, head);\n}\n\n \n\nstatic void add_lkb(struct dlm_rsb *r, struct dlm_lkb *lkb, int status)\n{\n\tkref_get(&lkb->lkb_ref);\n\n\tDLM_ASSERT(!lkb->lkb_status, dlm_print_lkb(lkb););\n\n\tlkb->lkb_timestamp = ktime_get();\n\n\tlkb->lkb_status = status;\n\n\tswitch (status) {\n\tcase DLM_LKSTS_WAITING:\n\t\tif (lkb->lkb_exflags & DLM_LKF_HEADQUE)\n\t\t\tlist_add(&lkb->lkb_statequeue, &r->res_waitqueue);\n\t\telse\n\t\t\tlist_add_tail(&lkb->lkb_statequeue, &r->res_waitqueue);\n\t\tbreak;\n\tcase DLM_LKSTS_GRANTED:\n\t\t \n\t\tlkb_add_ordered(&lkb->lkb_statequeue, &r->res_grantqueue,\n\t\t\t\tlkb->lkb_grmode);\n\t\tbreak;\n\tcase DLM_LKSTS_CONVERT:\n\t\tif (lkb->lkb_exflags & DLM_LKF_HEADQUE)\n\t\t\tlist_add(&lkb->lkb_statequeue, &r->res_convertqueue);\n\t\telse\n\t\t\tlist_add_tail(&lkb->lkb_statequeue,\n\t\t\t\t      &r->res_convertqueue);\n\t\tbreak;\n\tdefault:\n\t\tDLM_ASSERT(0, dlm_print_lkb(lkb); printk(\"sts=%d\\n\", status););\n\t}\n}\n\nstatic void del_lkb(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tlkb->lkb_status = 0;\n\tlist_del(&lkb->lkb_statequeue);\n\tunhold_lkb(lkb);\n}\n\nstatic void move_lkb(struct dlm_rsb *r, struct dlm_lkb *lkb, int sts)\n{\n\thold_lkb(lkb);\n\tdel_lkb(r, lkb);\n\tadd_lkb(r, lkb, sts);\n\tunhold_lkb(lkb);\n}\n\nstatic int msg_reply_type(int mstype)\n{\n\tswitch (mstype) {\n\tcase DLM_MSG_REQUEST:\n\t\treturn DLM_MSG_REQUEST_REPLY;\n\tcase DLM_MSG_CONVERT:\n\t\treturn DLM_MSG_CONVERT_REPLY;\n\tcase DLM_MSG_UNLOCK:\n\t\treturn DLM_MSG_UNLOCK_REPLY;\n\tcase DLM_MSG_CANCEL:\n\t\treturn DLM_MSG_CANCEL_REPLY;\n\tcase DLM_MSG_LOOKUP:\n\t\treturn DLM_MSG_LOOKUP_REPLY;\n\t}\n\treturn -1;\n}\n\n \n\nstatic int add_to_waiters(struct dlm_lkb *lkb, int mstype, int to_nodeid)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\tint error = 0;\n\tint wc;\n\n\tmutex_lock(&ls->ls_waiters_mutex);\n\n\tif (is_overlap_unlock(lkb) ||\n\t    (is_overlap_cancel(lkb) && (mstype == DLM_MSG_CANCEL))) {\n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (lkb->lkb_wait_type || is_overlap_cancel(lkb)) {\n\t\tswitch (mstype) {\n\t\tcase DLM_MSG_UNLOCK:\n\t\t\tset_bit(DLM_IFL_OVERLAP_UNLOCK_BIT, &lkb->lkb_iflags);\n\t\t\tbreak;\n\t\tcase DLM_MSG_CANCEL:\n\t\t\tset_bit(DLM_IFL_OVERLAP_CANCEL_BIT, &lkb->lkb_iflags);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t\twc = atomic_inc_return(&lkb->lkb_wait_count);\n\t\thold_lkb(lkb);\n\n\t\tlog_debug(ls, \"addwait %x cur %d overlap %d count %d f %x\",\n\t\t\t  lkb->lkb_id, lkb->lkb_wait_type, mstype, wc,\n\t\t\t  dlm_iflags_val(lkb));\n\t\tgoto out;\n\t}\n\n\twc = atomic_fetch_inc(&lkb->lkb_wait_count);\n\tDLM_ASSERT(!wc, dlm_print_lkb(lkb); printk(\"wait_count %d\\n\", wc););\n\tlkb->lkb_wait_type = mstype;\n\tlkb->lkb_wait_nodeid = to_nodeid;  \n\thold_lkb(lkb);\n\tlist_add(&lkb->lkb_wait_reply, &ls->ls_waiters);\n out:\n\tif (error)\n\t\tlog_error(ls, \"addwait error %x %d flags %x %d %d %s\",\n\t\t\t  lkb->lkb_id, error, dlm_iflags_val(lkb), mstype,\n\t\t\t  lkb->lkb_wait_type, lkb->lkb_resource->res_name);\n\tmutex_unlock(&ls->ls_waiters_mutex);\n\treturn error;\n}\n\n \n\nstatic int _remove_from_waiters(struct dlm_lkb *lkb, int mstype,\n\t\t\t\tconst struct dlm_message *ms)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\tint overlap_done = 0;\n\n\tif (mstype == DLM_MSG_UNLOCK_REPLY &&\n\t    test_and_clear_bit(DLM_IFL_OVERLAP_UNLOCK_BIT, &lkb->lkb_iflags)) {\n\t\tlog_debug(ls, \"remwait %x unlock_reply overlap\", lkb->lkb_id);\n\t\toverlap_done = 1;\n\t\tgoto out_del;\n\t}\n\n\tif (mstype == DLM_MSG_CANCEL_REPLY &&\n\t    test_and_clear_bit(DLM_IFL_OVERLAP_CANCEL_BIT, &lkb->lkb_iflags)) {\n\t\tlog_debug(ls, \"remwait %x cancel_reply overlap\", lkb->lkb_id);\n\t\toverlap_done = 1;\n\t\tgoto out_del;\n\t}\n\n\t \n\n\tif ((mstype == DLM_MSG_CANCEL_REPLY) &&\n\t    (lkb->lkb_wait_type != DLM_MSG_CANCEL)) {\n\t\tlog_debug(ls, \"remwait %x cancel_reply wait_type %d\",\n\t\t\t  lkb->lkb_id, lkb->lkb_wait_type);\n\t\treturn -1;\n\t}\n\n\t \n\n\tif ((mstype == DLM_MSG_CONVERT_REPLY) &&\n\t    (lkb->lkb_wait_type == DLM_MSG_CONVERT) && ms && !ms->m_result &&\n\t    test_and_clear_bit(DLM_IFL_OVERLAP_CANCEL_BIT, &lkb->lkb_iflags)) {\n\t\tlog_debug(ls, \"remwait %x convert_reply zap overlap_cancel\",\n\t\t\t  lkb->lkb_id);\n\t\tlkb->lkb_wait_type = 0;\n\t\tatomic_dec(&lkb->lkb_wait_count);\n\t\tunhold_lkb(lkb);\n\t\tgoto out_del;\n\t}\n\n\t \n\n\tif (lkb->lkb_wait_type) {\n\t\tlkb->lkb_wait_type = 0;\n\t\tgoto out_del;\n\t}\n\n\tlog_error(ls, \"remwait error %x remote %d %x msg %d flags %x no wait\",\n\t\t  lkb->lkb_id, ms ? le32_to_cpu(ms->m_header.h_nodeid) : 0,\n\t\t  lkb->lkb_remid, mstype, dlm_iflags_val(lkb));\n\treturn -1;\n\n out_del:\n\t \n\n\tif (overlap_done && lkb->lkb_wait_type) {\n\t\tlog_error(ls, \"remwait error %x reply %d wait_type %d overlap\",\n\t\t\t  lkb->lkb_id, mstype, lkb->lkb_wait_type);\n\t\tatomic_dec(&lkb->lkb_wait_count);\n\t\tunhold_lkb(lkb);\n\t\tlkb->lkb_wait_type = 0;\n\t}\n\n\tDLM_ASSERT(atomic_read(&lkb->lkb_wait_count), dlm_print_lkb(lkb););\n\n\tclear_bit(DLM_IFL_RESEND_BIT, &lkb->lkb_iflags);\n\tif (atomic_dec_and_test(&lkb->lkb_wait_count))\n\t\tlist_del_init(&lkb->lkb_wait_reply);\n\tunhold_lkb(lkb);\n\treturn 0;\n}\n\nstatic int remove_from_waiters(struct dlm_lkb *lkb, int mstype)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\tint error;\n\n\tmutex_lock(&ls->ls_waiters_mutex);\n\terror = _remove_from_waiters(lkb, mstype, NULL);\n\tmutex_unlock(&ls->ls_waiters_mutex);\n\treturn error;\n}\n\n \n\nstatic int remove_from_waiters_ms(struct dlm_lkb *lkb,\n\t\t\t\t  const struct dlm_message *ms, bool local)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\tint error;\n\n\tif (!local)\n\t\tmutex_lock(&ls->ls_waiters_mutex);\n\terror = _remove_from_waiters(lkb, le32_to_cpu(ms->m_type), ms);\n\tif (!local)\n\t\tmutex_unlock(&ls->ls_waiters_mutex);\n\treturn error;\n}\n\nstatic void shrink_bucket(struct dlm_ls *ls, int b)\n{\n\tstruct rb_node *n, *next;\n\tstruct dlm_rsb *r;\n\tchar *name;\n\tint our_nodeid = dlm_our_nodeid();\n\tint remote_count = 0;\n\tint need_shrink = 0;\n\tint i, len, rv;\n\n\tmemset(&ls->ls_remove_lens, 0, sizeof(int) * DLM_REMOVE_NAMES_MAX);\n\n\tspin_lock(&ls->ls_rsbtbl[b].lock);\n\n\tif (!test_bit(DLM_RTF_SHRINK_BIT, &ls->ls_rsbtbl[b].flags)) {\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\treturn;\n\t}\n\n\tfor (n = rb_first(&ls->ls_rsbtbl[b].toss); n; n = next) {\n\t\tnext = rb_next(n);\n\t\tr = rb_entry(n, struct dlm_rsb, res_hashnode);\n\n\t\t \n\n\t\tif (!dlm_no_directory(ls) &&\n\t\t    (r->res_master_nodeid != our_nodeid) &&\n\t\t    (dlm_dir_nodeid(r) == our_nodeid)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tneed_shrink = 1;\n\n\t\tif (!time_after_eq(jiffies, r->res_toss_time +\n\t\t\t\t   dlm_config.ci_toss_secs * HZ)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!dlm_no_directory(ls) &&\n\t\t    (r->res_master_nodeid == our_nodeid) &&\n\t\t    (dlm_dir_nodeid(r) != our_nodeid)) {\n\n\t\t\t \n\n\t\t\tls->ls_remove_lens[remote_count] = r->res_length;\n\t\t\tmemcpy(ls->ls_remove_names[remote_count], r->res_name,\n\t\t\t       DLM_RESNAME_MAXLEN);\n\t\t\tremote_count++;\n\n\t\t\tif (remote_count >= DLM_REMOVE_NAMES_MAX)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!kref_put(&r->res_ref, kill_rsb)) {\n\t\t\tlog_error(ls, \"tossed rsb in use %s\", r->res_name);\n\t\t\tcontinue;\n\t\t}\n\n\t\trb_erase(&r->res_hashnode, &ls->ls_rsbtbl[b].toss);\n\t\tdlm_free_rsb(r);\n\t}\n\n\tif (need_shrink)\n\t\tset_bit(DLM_RTF_SHRINK_BIT, &ls->ls_rsbtbl[b].flags);\n\telse\n\t\tclear_bit(DLM_RTF_SHRINK_BIT, &ls->ls_rsbtbl[b].flags);\n\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\n\t \n\n\tfor (i = 0; i < remote_count; i++) {\n\t\tname = ls->ls_remove_names[i];\n\t\tlen = ls->ls_remove_lens[i];\n\n\t\tspin_lock(&ls->ls_rsbtbl[b].lock);\n\t\trv = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].toss, name, len, &r);\n\t\tif (rv) {\n\t\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\t\tlog_debug(ls, \"remove_name not toss %s\", name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (r->res_master_nodeid != our_nodeid) {\n\t\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\t\tlog_debug(ls, \"remove_name master %d dir %d our %d %s\",\n\t\t\t\t  r->res_master_nodeid, r->res_dir_nodeid,\n\t\t\t\t  our_nodeid, name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (r->res_dir_nodeid == our_nodeid) {\n\t\t\t \n\t\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\t\tlog_error(ls, \"remove_name dir %d master %d our %d %s\",\n\t\t\t\t  r->res_dir_nodeid, r->res_master_nodeid,\n\t\t\t\t  our_nodeid, name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!time_after_eq(jiffies, r->res_toss_time +\n\t\t\t\t   dlm_config.ci_toss_secs * HZ)) {\n\t\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\t\tlog_debug(ls, \"remove_name toss_time %lu now %lu %s\",\n\t\t\t\t  r->res_toss_time, jiffies, name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!kref_put(&r->res_ref, kill_rsb)) {\n\t\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\t\tlog_error(ls, \"remove_name in use %s\", name);\n\t\t\tcontinue;\n\t\t}\n\n\t\trb_erase(&r->res_hashnode, &ls->ls_rsbtbl[b].toss);\n\t\tsend_remove(r);\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\n\t\tdlm_free_rsb(r);\n\t}\n}\n\nvoid dlm_scan_rsbs(struct dlm_ls *ls)\n{\n\tint i;\n\n\tfor (i = 0; i < ls->ls_rsbtbl_size; i++) {\n\t\tshrink_bucket(ls, i);\n\t\tif (dlm_locking_stopped(ls))\n\t\t\tbreak;\n\t\tcond_resched();\n\t}\n}\n\n \n\nstatic void set_lvb_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint b, len = r->res_ls->ls_lvblen;\n\n\t \n\n\tb =  dlm_lvb_operations[lkb->lkb_grmode + 1][lkb->lkb_rqmode + 1];\n\n\tif (b == 1) {\n\t\tif (!lkb->lkb_lvbptr)\n\t\t\treturn;\n\n\t\tif (!(lkb->lkb_exflags & DLM_LKF_VALBLK))\n\t\t\treturn;\n\n\t\tif (!r->res_lvbptr)\n\t\t\treturn;\n\n\t\tmemcpy(lkb->lkb_lvbptr, r->res_lvbptr, len);\n\t\tlkb->lkb_lvbseq = r->res_lvbseq;\n\n\t} else if (b == 0) {\n\t\tif (lkb->lkb_exflags & DLM_LKF_IVVALBLK) {\n\t\t\trsb_set_flag(r, RSB_VALNOTVALID);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!lkb->lkb_lvbptr)\n\t\t\treturn;\n\n\t\tif (!(lkb->lkb_exflags & DLM_LKF_VALBLK))\n\t\t\treturn;\n\n\t\tif (!r->res_lvbptr)\n\t\t\tr->res_lvbptr = dlm_allocate_lvb(r->res_ls);\n\n\t\tif (!r->res_lvbptr)\n\t\t\treturn;\n\n\t\tmemcpy(r->res_lvbptr, lkb->lkb_lvbptr, len);\n\t\tr->res_lvbseq++;\n\t\tlkb->lkb_lvbseq = r->res_lvbseq;\n\t\trsb_clear_flag(r, RSB_VALNOTVALID);\n\t}\n\n\tif (rsb_flag(r, RSB_VALNOTVALID))\n\t\tset_bit(DLM_SBF_VALNOTVALID_BIT, &lkb->lkb_sbflags);\n}\n\nstatic void set_lvb_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tif (lkb->lkb_grmode < DLM_LOCK_PW)\n\t\treturn;\n\n\tif (lkb->lkb_exflags & DLM_LKF_IVVALBLK) {\n\t\trsb_set_flag(r, RSB_VALNOTVALID);\n\t\treturn;\n\t}\n\n\tif (!lkb->lkb_lvbptr)\n\t\treturn;\n\n\tif (!(lkb->lkb_exflags & DLM_LKF_VALBLK))\n\t\treturn;\n\n\tif (!r->res_lvbptr)\n\t\tr->res_lvbptr = dlm_allocate_lvb(r->res_ls);\n\n\tif (!r->res_lvbptr)\n\t\treturn;\n\n\tmemcpy(r->res_lvbptr, lkb->lkb_lvbptr, r->res_ls->ls_lvblen);\n\tr->res_lvbseq++;\n\trsb_clear_flag(r, RSB_VALNOTVALID);\n}\n\n \n\nstatic void set_lvb_lock_pc(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t    const struct dlm_message *ms)\n{\n\tint b;\n\n\tif (!lkb->lkb_lvbptr)\n\t\treturn;\n\n\tif (!(lkb->lkb_exflags & DLM_LKF_VALBLK))\n\t\treturn;\n\n\tb = dlm_lvb_operations[lkb->lkb_grmode + 1][lkb->lkb_rqmode + 1];\n\tif (b == 1) {\n\t\tint len = receive_extralen(ms);\n\t\tif (len > r->res_ls->ls_lvblen)\n\t\t\tlen = r->res_ls->ls_lvblen;\n\t\tmemcpy(lkb->lkb_lvbptr, ms->m_extra, len);\n\t\tlkb->lkb_lvbseq = le32_to_cpu(ms->m_lvbseq);\n\t}\n}\n\n \n\nstatic void _remove_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tdel_lkb(r, lkb);\n\tlkb->lkb_grmode = DLM_LOCK_IV;\n\t \n\tunhold_lkb(lkb);\n}\n\nstatic void remove_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tset_lvb_unlock(r, lkb);\n\t_remove_lock(r, lkb);\n}\n\nstatic void remove_lock_pc(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\t_remove_lock(r, lkb);\n}\n\n \n\nstatic int revert_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint rv = 0;\n\n\tlkb->lkb_rqmode = DLM_LOCK_IV;\n\n\tswitch (lkb->lkb_status) {\n\tcase DLM_LKSTS_GRANTED:\n\t\tbreak;\n\tcase DLM_LKSTS_CONVERT:\n\t\tmove_lkb(r, lkb, DLM_LKSTS_GRANTED);\n\t\trv = 1;\n\t\tbreak;\n\tcase DLM_LKSTS_WAITING:\n\t\tdel_lkb(r, lkb);\n\t\tlkb->lkb_grmode = DLM_LOCK_IV;\n\t\t \n\t\tunhold_lkb(lkb);\n\t\trv = -1;\n\t\tbreak;\n\tdefault:\n\t\tlog_print(\"invalid status for revert %d\", lkb->lkb_status);\n\t}\n\treturn rv;\n}\n\nstatic int revert_lock_pc(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\treturn revert_lock(r, lkb);\n}\n\nstatic void _grant_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tif (lkb->lkb_grmode != lkb->lkb_rqmode) {\n\t\tlkb->lkb_grmode = lkb->lkb_rqmode;\n\t\tif (lkb->lkb_status)\n\t\t\tmove_lkb(r, lkb, DLM_LKSTS_GRANTED);\n\t\telse\n\t\t\tadd_lkb(r, lkb, DLM_LKSTS_GRANTED);\n\t}\n\n\tlkb->lkb_rqmode = DLM_LOCK_IV;\n\tlkb->lkb_highbast = 0;\n}\n\nstatic void grant_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tset_lvb_lock(r, lkb);\n\t_grant_lock(r, lkb);\n}\n\nstatic void grant_lock_pc(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t  const struct dlm_message *ms)\n{\n\tset_lvb_lock_pc(r, lkb, ms);\n\t_grant_lock(r, lkb);\n}\n\n \n\nstatic void grant_lock_pending(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tgrant_lock(r, lkb);\n\tif (is_master_copy(lkb))\n\t\tsend_grant(r, lkb);\n\telse\n\t\tqueue_cast(r, lkb, 0);\n}\n\n \n\nstatic void munge_demoted(struct dlm_lkb *lkb)\n{\n\tif (lkb->lkb_rqmode == DLM_LOCK_IV || lkb->lkb_grmode == DLM_LOCK_IV) {\n\t\tlog_print(\"munge_demoted %x invalid modes gr %d rq %d\",\n\t\t\t  lkb->lkb_id, lkb->lkb_grmode, lkb->lkb_rqmode);\n\t\treturn;\n\t}\n\n\tlkb->lkb_grmode = DLM_LOCK_NL;\n}\n\nstatic void munge_altmode(struct dlm_lkb *lkb, const struct dlm_message *ms)\n{\n\tif (ms->m_type != cpu_to_le32(DLM_MSG_REQUEST_REPLY) &&\n\t    ms->m_type != cpu_to_le32(DLM_MSG_GRANT)) {\n\t\tlog_print(\"munge_altmode %x invalid reply type %d\",\n\t\t\t  lkb->lkb_id, le32_to_cpu(ms->m_type));\n\t\treturn;\n\t}\n\n\tif (lkb->lkb_exflags & DLM_LKF_ALTPR)\n\t\tlkb->lkb_rqmode = DLM_LOCK_PR;\n\telse if (lkb->lkb_exflags & DLM_LKF_ALTCW)\n\t\tlkb->lkb_rqmode = DLM_LOCK_CW;\n\telse {\n\t\tlog_print(\"munge_altmode invalid exflags %x\", lkb->lkb_exflags);\n\t\tdlm_print_lkb(lkb);\n\t}\n}\n\nstatic inline int first_in_list(struct dlm_lkb *lkb, struct list_head *head)\n{\n\tstruct dlm_lkb *first = list_entry(head->next, struct dlm_lkb,\n\t\t\t\t\t   lkb_statequeue);\n\tif (lkb->lkb_id == first->lkb_id)\n\t\treturn 1;\n\n\treturn 0;\n}\n\n \n\nstatic int queue_conflict(struct list_head *head, struct dlm_lkb *lkb)\n{\n\tstruct dlm_lkb *this;\n\n\tlist_for_each_entry(this, head, lkb_statequeue) {\n\t\tif (this == lkb)\n\t\t\tcontinue;\n\t\tif (!modes_compat(this, lkb))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \n\nstatic int conversion_deadlock_detect(struct dlm_rsb *r, struct dlm_lkb *lkb2)\n{\n\tstruct dlm_lkb *lkb1;\n\tint lkb_is_ahead = 0;\n\n\tlist_for_each_entry(lkb1, &r->res_convertqueue, lkb_statequeue) {\n\t\tif (lkb1 == lkb2) {\n\t\t\tlkb_is_ahead = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!lkb_is_ahead) {\n\t\t\tif (!modes_compat(lkb2, lkb1))\n\t\t\t\treturn 1;\n\t\t} else {\n\t\t\tif (!modes_compat(lkb2, lkb1) &&\n\t\t\t    !modes_compat(lkb1, lkb2))\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \n\nstatic int _can_be_granted(struct dlm_rsb *r, struct dlm_lkb *lkb, int now,\n\t\t\t   int recover)\n{\n\tint8_t conv = (lkb->lkb_grmode != DLM_LOCK_IV);\n\n\t \n\n\tif (lkb->lkb_exflags & DLM_LKF_EXPEDITE)\n\t\treturn 1;\n\n\t \n\n\tif (queue_conflict(&r->res_grantqueue, lkb))\n\t\treturn 0;\n\n\t \n\n\tif (queue_conflict(&r->res_convertqueue, lkb))\n\t\treturn 0;\n\n\t \n\n\tif (conv && recover)\n\t\treturn 1;\n\n\t \n\n\tif (now && conv && !(lkb->lkb_exflags & DLM_LKF_QUECVT))\n\t\treturn 1;\n\n\t \n\n\tif (now && conv && (lkb->lkb_exflags & DLM_LKF_QUECVT)) {\n\t\tif (list_empty(&r->res_convertqueue))\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn 0;\n\t}\n\n\t \n\n\tif (lkb->lkb_exflags & DLM_LKF_NOORDER)\n\t\treturn 1;\n\n\t \n\n\tif (!now && conv && first_in_list(lkb, &r->res_convertqueue))\n\t\treturn 1;\n\n\t \n\n\tif (now && !conv && list_empty(&r->res_convertqueue) &&\n\t    list_empty(&r->res_waitqueue))\n\t\treturn 1;\n\n\t \n\n\tif (!now && !conv && list_empty(&r->res_convertqueue) &&\n\t    first_in_list(lkb, &r->res_waitqueue))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int can_be_granted(struct dlm_rsb *r, struct dlm_lkb *lkb, int now,\n\t\t\t  int recover, int *err)\n{\n\tint rv;\n\tint8_t alt = 0, rqmode = lkb->lkb_rqmode;\n\tint8_t is_convert = (lkb->lkb_grmode != DLM_LOCK_IV);\n\n\tif (err)\n\t\t*err = 0;\n\n\trv = _can_be_granted(r, lkb, now, recover);\n\tif (rv)\n\t\tgoto out;\n\n\t \n\n\tif (is_convert && can_be_queued(lkb) &&\n\t    conversion_deadlock_detect(r, lkb)) {\n\t\tif (lkb->lkb_exflags & DLM_LKF_CONVDEADLK) {\n\t\t\tlkb->lkb_grmode = DLM_LOCK_NL;\n\t\t\tset_bit(DLM_SBF_DEMOTED_BIT, &lkb->lkb_sbflags);\n\t\t} else if (err) {\n\t\t\t*err = -EDEADLK;\n\t\t} else {\n\t\t\tlog_print(\"can_be_granted deadlock %x now %d\",\n\t\t\t\t  lkb->lkb_id, now);\n\t\t\tdlm_dump_rsb(r);\n\t\t}\n\t\tgoto out;\n\t}\n\n\t \n\n\tif (rqmode != DLM_LOCK_PR && (lkb->lkb_exflags & DLM_LKF_ALTPR))\n\t\talt = DLM_LOCK_PR;\n\telse if (rqmode != DLM_LOCK_CW && (lkb->lkb_exflags & DLM_LKF_ALTCW))\n\t\talt = DLM_LOCK_CW;\n\n\tif (alt) {\n\t\tlkb->lkb_rqmode = alt;\n\t\trv = _can_be_granted(r, lkb, now, 0);\n\t\tif (rv)\n\t\t\tset_bit(DLM_SBF_ALTMODE_BIT, &lkb->lkb_sbflags);\n\t\telse\n\t\t\tlkb->lkb_rqmode = rqmode;\n\t}\n out:\n\treturn rv;\n}\n\n \n\nstatic int grant_pending_convert(struct dlm_rsb *r, int high, int *cw,\n\t\t\t\t unsigned int *count)\n{\n\tstruct dlm_lkb *lkb, *s;\n\tint recover = rsb_flag(r, RSB_RECOVER_GRANT);\n\tint hi, demoted, quit, grant_restart, demote_restart;\n\tint deadlk;\n\n\tquit = 0;\n restart:\n\tgrant_restart = 0;\n\tdemote_restart = 0;\n\thi = DLM_LOCK_IV;\n\n\tlist_for_each_entry_safe(lkb, s, &r->res_convertqueue, lkb_statequeue) {\n\t\tdemoted = is_demoted(lkb);\n\t\tdeadlk = 0;\n\n\t\tif (can_be_granted(r, lkb, 0, recover, &deadlk)) {\n\t\t\tgrant_lock_pending(r, lkb);\n\t\t\tgrant_restart = 1;\n\t\t\tif (count)\n\t\t\t\t(*count)++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!demoted && is_demoted(lkb)) {\n\t\t\tlog_print(\"WARN: pending demoted %x node %d %s\",\n\t\t\t\t  lkb->lkb_id, lkb->lkb_nodeid, r->res_name);\n\t\t\tdemote_restart = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (deadlk) {\n\t\t\t \n\t\t\tif (lkb->lkb_exflags & DLM_LKF_NODLCKWT) {\n\t\t\t\tif (lkb->lkb_highbast < lkb->lkb_rqmode) {\n\t\t\t\t\tqueue_bast(r, lkb, lkb->lkb_rqmode);\n\t\t\t\t\tlkb->lkb_highbast = lkb->lkb_rqmode;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlog_print(\"WARN: pending deadlock %x node %d %s\",\n\t\t\t\t\t  lkb->lkb_id, lkb->lkb_nodeid,\n\t\t\t\t\t  r->res_name);\n\t\t\t\tdlm_dump_rsb(r);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\thi = max_t(int, lkb->lkb_rqmode, hi);\n\n\t\tif (cw && lkb->lkb_rqmode == DLM_LOCK_CW)\n\t\t\t*cw = 1;\n\t}\n\n\tif (grant_restart)\n\t\tgoto restart;\n\tif (demote_restart && !quit) {\n\t\tquit = 1;\n\t\tgoto restart;\n\t}\n\n\treturn max_t(int, high, hi);\n}\n\nstatic int grant_pending_wait(struct dlm_rsb *r, int high, int *cw,\n\t\t\t      unsigned int *count)\n{\n\tstruct dlm_lkb *lkb, *s;\n\n\tlist_for_each_entry_safe(lkb, s, &r->res_waitqueue, lkb_statequeue) {\n\t\tif (can_be_granted(r, lkb, 0, 0, NULL)) {\n\t\t\tgrant_lock_pending(r, lkb);\n\t\t\tif (count)\n\t\t\t\t(*count)++;\n\t\t} else {\n\t\t\thigh = max_t(int, lkb->lkb_rqmode, high);\n\t\t\tif (lkb->lkb_rqmode == DLM_LOCK_CW)\n\t\t\t\t*cw = 1;\n\t\t}\n\t}\n\n\treturn high;\n}\n\n \n\nstatic int lock_requires_bast(struct dlm_lkb *gr, int high, int cw)\n{\n\tif (gr->lkb_grmode == DLM_LOCK_PR && cw) {\n\t\tif (gr->lkb_highbast < DLM_LOCK_EX)\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\n\tif (gr->lkb_highbast < high &&\n\t    !__dlm_compat_matrix[gr->lkb_grmode+1][high+1])\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic void grant_pending_locks(struct dlm_rsb *r, unsigned int *count)\n{\n\tstruct dlm_lkb *lkb, *s;\n\tint high = DLM_LOCK_IV;\n\tint cw = 0;\n\n\tif (!is_master(r)) {\n\t\tlog_print(\"grant_pending_locks r nodeid %d\", r->res_nodeid);\n\t\tdlm_dump_rsb(r);\n\t\treturn;\n\t}\n\n\thigh = grant_pending_convert(r, high, &cw, count);\n\thigh = grant_pending_wait(r, high, &cw, count);\n\n\tif (high == DLM_LOCK_IV)\n\t\treturn;\n\n\t \n\n\tlist_for_each_entry_safe(lkb, s, &r->res_grantqueue, lkb_statequeue) {\n\t\tif (lkb->lkb_bastfn && lock_requires_bast(lkb, high, cw)) {\n\t\t\tif (cw && high == DLM_LOCK_PR &&\n\t\t\t    lkb->lkb_grmode == DLM_LOCK_PR)\n\t\t\t\tqueue_bast(r, lkb, DLM_LOCK_CW);\n\t\t\telse\n\t\t\t\tqueue_bast(r, lkb, high);\n\t\t\tlkb->lkb_highbast = high;\n\t\t}\n\t}\n}\n\nstatic int modes_require_bast(struct dlm_lkb *gr, struct dlm_lkb *rq)\n{\n\tif ((gr->lkb_grmode == DLM_LOCK_PR && rq->lkb_rqmode == DLM_LOCK_CW) ||\n\t    (gr->lkb_grmode == DLM_LOCK_CW && rq->lkb_rqmode == DLM_LOCK_PR)) {\n\t\tif (gr->lkb_highbast < DLM_LOCK_EX)\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\n\tif (gr->lkb_highbast < rq->lkb_rqmode && !modes_compat(gr, rq))\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic void send_bast_queue(struct dlm_rsb *r, struct list_head *head,\n\t\t\t    struct dlm_lkb *lkb)\n{\n\tstruct dlm_lkb *gr;\n\n\tlist_for_each_entry(gr, head, lkb_statequeue) {\n\t\t \n\t\tif (gr == lkb)\n\t\t\tcontinue;\n\t\tif (gr->lkb_bastfn && modes_require_bast(gr, lkb)) {\n\t\t\tqueue_bast(r, gr, lkb->lkb_rqmode);\n\t\t\tgr->lkb_highbast = lkb->lkb_rqmode;\n\t\t}\n\t}\n}\n\nstatic void send_blocking_asts(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tsend_bast_queue(r, &r->res_grantqueue, lkb);\n}\n\nstatic void send_blocking_asts_all(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tsend_bast_queue(r, &r->res_grantqueue, lkb);\n\tsend_bast_queue(r, &r->res_convertqueue, lkb);\n}\n\n \n\nstatic int set_master(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint our_nodeid = dlm_our_nodeid();\n\n\tif (rsb_flag(r, RSB_MASTER_UNCERTAIN)) {\n\t\trsb_clear_flag(r, RSB_MASTER_UNCERTAIN);\n\t\tr->res_first_lkid = lkb->lkb_id;\n\t\tlkb->lkb_nodeid = r->res_nodeid;\n\t\treturn 0;\n\t}\n\n\tif (r->res_first_lkid && r->res_first_lkid != lkb->lkb_id) {\n\t\tlist_add_tail(&lkb->lkb_rsb_lookup, &r->res_lookup);\n\t\treturn 1;\n\t}\n\n\tif (r->res_master_nodeid == our_nodeid) {\n\t\tlkb->lkb_nodeid = 0;\n\t\treturn 0;\n\t}\n\n\tif (r->res_master_nodeid) {\n\t\tlkb->lkb_nodeid = r->res_master_nodeid;\n\t\treturn 0;\n\t}\n\n\tif (dlm_dir_nodeid(r) == our_nodeid) {\n\t\t \n\t\tlog_debug(r->res_ls, \"set_master %x self master %d dir %d %s\",\n\t\t\t  lkb->lkb_id, r->res_master_nodeid, r->res_dir_nodeid,\n\t\t\t  r->res_name);\n\t\tr->res_master_nodeid = our_nodeid;\n\t\tr->res_nodeid = 0;\n\t\tlkb->lkb_nodeid = 0;\n\t\treturn 0;\n\t}\n\n\tr->res_first_lkid = lkb->lkb_id;\n\tsend_lookup(r, lkb);\n\treturn 1;\n}\n\nstatic void process_lookup_list(struct dlm_rsb *r)\n{\n\tstruct dlm_lkb *lkb, *safe;\n\n\tlist_for_each_entry_safe(lkb, safe, &r->res_lookup, lkb_rsb_lookup) {\n\t\tlist_del_init(&lkb->lkb_rsb_lookup);\n\t\t_request_lock(r, lkb);\n\t\tschedule();\n\t}\n}\n\n \n\nstatic void confirm_master(struct dlm_rsb *r, int error)\n{\n\tstruct dlm_lkb *lkb;\n\n\tif (!r->res_first_lkid)\n\t\treturn;\n\n\tswitch (error) {\n\tcase 0:\n\tcase -EINPROGRESS:\n\t\tr->res_first_lkid = 0;\n\t\tprocess_lookup_list(r);\n\t\tbreak;\n\n\tcase -EAGAIN:\n\tcase -EBADR:\n\tcase -ENOTBLK:\n\t\t \n\n\t\tr->res_first_lkid = 0;\n\n\t\tif (!list_empty(&r->res_lookup)) {\n\t\t\tlkb = list_entry(r->res_lookup.next, struct dlm_lkb,\n\t\t\t\t\t lkb_rsb_lookup);\n\t\t\tlist_del_init(&lkb->lkb_rsb_lookup);\n\t\t\tr->res_first_lkid = lkb->lkb_id;\n\t\t\t_request_lock(r, lkb);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tlog_error(r->res_ls, \"confirm_master unknown error %d\", error);\n\t}\n}\n\nstatic int set_lock_args(int mode, struct dlm_lksb *lksb, uint32_t flags,\n\t\t\t int namelen, void (*ast)(void *astparam),\n\t\t\t void *astparam,\n\t\t\t void (*bast)(void *astparam, int mode),\n\t\t\t struct dlm_args *args)\n{\n\tint rv = -EINVAL;\n\n\t \n\n\tif (mode < 0 || mode > DLM_LOCK_EX)\n\t\tgoto out;\n\n\tif (!(flags & DLM_LKF_CONVERT) && (namelen > DLM_RESNAME_MAXLEN))\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_CANCEL)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_QUECVT && !(flags & DLM_LKF_CONVERT))\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_CONVDEADLK && !(flags & DLM_LKF_CONVERT))\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_CONVDEADLK && flags & DLM_LKF_NOQUEUE)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_EXPEDITE && flags & DLM_LKF_CONVERT)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_EXPEDITE && flags & DLM_LKF_QUECVT)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_EXPEDITE && flags & DLM_LKF_NOQUEUE)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_EXPEDITE && mode != DLM_LOCK_NL)\n\t\tgoto out;\n\n\tif (!ast || !lksb)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_VALBLK && !lksb->sb_lvbptr)\n\t\tgoto out;\n\n\tif (flags & DLM_LKF_CONVERT && !lksb->sb_lkid)\n\t\tgoto out;\n\n\t \n\n\targs->flags = flags;\n\targs->astfn = ast;\n\targs->astparam = astparam;\n\targs->bastfn = bast;\n\targs->mode = mode;\n\targs->lksb = lksb;\n\trv = 0;\n out:\n\treturn rv;\n}\n\nstatic int set_unlock_args(uint32_t flags, void *astarg, struct dlm_args *args)\n{\n\tif (flags & ~(DLM_LKF_CANCEL | DLM_LKF_VALBLK | DLM_LKF_IVVALBLK |\n \t\t      DLM_LKF_FORCEUNLOCK))\n\t\treturn -EINVAL;\n\n\tif (flags & DLM_LKF_CANCEL && flags & DLM_LKF_FORCEUNLOCK)\n\t\treturn -EINVAL;\n\n\targs->flags = flags;\n\targs->astparam = astarg;\n\treturn 0;\n}\n\nstatic int validate_lock_args(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t\t      struct dlm_args *args)\n{\n\tint rv = -EBUSY;\n\n\tif (args->flags & DLM_LKF_CONVERT) {\n\t\tif (lkb->lkb_status != DLM_LKSTS_GRANTED)\n\t\t\tgoto out;\n\n\t\t \n\t\tif (lkb->lkb_wait_type || atomic_read(&lkb->lkb_wait_count))\n\t\t\tgoto out;\n\n\t\tif (is_overlap(lkb))\n\t\t\tgoto out;\n\n\t\trv = -EINVAL;\n\t\tif (test_bit(DLM_IFL_MSTCPY_BIT, &lkb->lkb_iflags))\n\t\t\tgoto out;\n\n\t\tif (args->flags & DLM_LKF_QUECVT &&\n\t\t    !__quecvt_compat_matrix[lkb->lkb_grmode+1][args->mode+1])\n\t\t\tgoto out;\n\t}\n\n\tlkb->lkb_exflags = args->flags;\n\tdlm_set_sbflags_val(lkb, 0);\n\tlkb->lkb_astfn = args->astfn;\n\tlkb->lkb_astparam = args->astparam;\n\tlkb->lkb_bastfn = args->bastfn;\n\tlkb->lkb_rqmode = args->mode;\n\tlkb->lkb_lksb = args->lksb;\n\tlkb->lkb_lvbptr = args->lksb->sb_lvbptr;\n\tlkb->lkb_ownpid = (int) current->pid;\n\trv = 0;\n out:\n\tswitch (rv) {\n\tcase 0:\n\t\tbreak;\n\tcase -EINVAL:\n\t\t \n\t\tWARN_ON(1);\n\t\tlog_error(ls, \"%s %d %x %x %x %d %d %s\", __func__,\n\t\t\t  rv, lkb->lkb_id, dlm_iflags_val(lkb), args->flags,\n\t\t\t  lkb->lkb_status, lkb->lkb_wait_type,\n\t\t\t  lkb->lkb_resource->res_name);\n\t\tbreak;\n\tdefault:\n\t\tlog_debug(ls, \"%s %d %x %x %x %d %d %s\", __func__,\n\t\t\t  rv, lkb->lkb_id, dlm_iflags_val(lkb), args->flags,\n\t\t\t  lkb->lkb_status, lkb->lkb_wait_type,\n\t\t\t  lkb->lkb_resource->res_name);\n\t\tbreak;\n\t}\n\n\treturn rv;\n}\n\n \n\n \n\nstatic int validate_unlock_args(struct dlm_lkb *lkb, struct dlm_args *args)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\tint rv = -EBUSY;\n\n\t \n\tif (!(args->flags & (DLM_LKF_CANCEL | DLM_LKF_FORCEUNLOCK)) &&\n\t    (lkb->lkb_wait_type || atomic_read(&lkb->lkb_wait_count)))\n\t\tgoto out;\n\n\t \n\n\tif (!list_empty(&lkb->lkb_rsb_lookup)) {\n\t\tif (args->flags & (DLM_LKF_CANCEL | DLM_LKF_FORCEUNLOCK)) {\n\t\t\tlog_debug(ls, \"unlock on rsb_lookup %x\", lkb->lkb_id);\n\t\t\tlist_del_init(&lkb->lkb_rsb_lookup);\n\t\t\tqueue_cast(lkb->lkb_resource, lkb,\n\t\t\t\t   args->flags & DLM_LKF_CANCEL ?\n\t\t\t\t   -DLM_ECANCEL : -DLM_EUNLOCK);\n\t\t\tunhold_lkb(lkb);  \n\t\t}\n\t\t \n\t\tgoto out;\n\t}\n\n\trv = -EINVAL;\n\tif (test_bit(DLM_IFL_MSTCPY_BIT, &lkb->lkb_iflags)) {\n\t\tlog_error(ls, \"unlock on MSTCPY %x\", lkb->lkb_id);\n\t\tdlm_print_lkb(lkb);\n\t\tgoto out;\n\t}\n\n\t \n\n\tif (test_bit(DLM_IFL_ENDOFLIFE_BIT, &lkb->lkb_iflags)) {\n\t\tlog_debug(ls, \"unlock on ENDOFLIFE %x\", lkb->lkb_id);\n\t\trv = -ENOENT;\n\t\tgoto out;\n\t}\n\n\t \n\n\tif (args->flags & DLM_LKF_CANCEL) {\n\t\tif (lkb->lkb_exflags & DLM_LKF_CANCEL)\n\t\t\tgoto out;\n\n\t\tif (is_overlap(lkb))\n\t\t\tgoto out;\n\n\t\tif (test_bit(DLM_IFL_RESEND_BIT, &lkb->lkb_iflags)) {\n\t\t\tset_bit(DLM_IFL_OVERLAP_CANCEL_BIT, &lkb->lkb_iflags);\n\t\t\trv = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif (lkb->lkb_status == DLM_LKSTS_GRANTED &&\n\t\t    !lkb->lkb_wait_type) {\n\t\t\trv = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\n\t\tswitch (lkb->lkb_wait_type) {\n\t\tcase DLM_MSG_LOOKUP:\n\t\tcase DLM_MSG_REQUEST:\n\t\t\tset_bit(DLM_IFL_OVERLAP_CANCEL_BIT, &lkb->lkb_iflags);\n\t\t\trv = -EBUSY;\n\t\t\tgoto out;\n\t\tcase DLM_MSG_UNLOCK:\n\t\tcase DLM_MSG_CANCEL:\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\tgoto out_ok;\n\t}\n\n\t \n\n\tif (args->flags & DLM_LKF_FORCEUNLOCK) {\n\t\tif (lkb->lkb_exflags & DLM_LKF_FORCEUNLOCK)\n\t\t\tgoto out;\n\n\t\tif (is_overlap_unlock(lkb))\n\t\t\tgoto out;\n\n\t\tif (test_bit(DLM_IFL_RESEND_BIT, &lkb->lkb_iflags)) {\n\t\t\tset_bit(DLM_IFL_OVERLAP_UNLOCK_BIT, &lkb->lkb_iflags);\n\t\t\trv = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\n\t\tswitch (lkb->lkb_wait_type) {\n\t\tcase DLM_MSG_LOOKUP:\n\t\tcase DLM_MSG_REQUEST:\n\t\t\tset_bit(DLM_IFL_OVERLAP_UNLOCK_BIT, &lkb->lkb_iflags);\n\t\t\trv = -EBUSY;\n\t\t\tgoto out;\n\t\tcase DLM_MSG_UNLOCK:\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t}\n\n out_ok:\n\t \n\tlkb->lkb_exflags |= args->flags;\n\tdlm_set_sbflags_val(lkb, 0);\n\tlkb->lkb_astparam = args->astparam;\n\trv = 0;\n out:\n\tswitch (rv) {\n\tcase 0:\n\t\tbreak;\n\tcase -EINVAL:\n\t\t \n\t\tWARN_ON(1);\n\t\tlog_error(ls, \"%s %d %x %x %x %x %d %s\", __func__, rv,\n\t\t\t  lkb->lkb_id, dlm_iflags_val(lkb), lkb->lkb_exflags,\n\t\t\t  args->flags, lkb->lkb_wait_type,\n\t\t\t  lkb->lkb_resource->res_name);\n\t\tbreak;\n\tdefault:\n\t\tlog_debug(ls, \"%s %d %x %x %x %x %d %s\", __func__, rv,\n\t\t\t  lkb->lkb_id, dlm_iflags_val(lkb), lkb->lkb_exflags,\n\t\t\t  args->flags, lkb->lkb_wait_type,\n\t\t\t  lkb->lkb_resource->res_name);\n\t\tbreak;\n\t}\n\n\treturn rv;\n}\n\n \n\nstatic int do_request(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error = 0;\n\n\tif (can_be_granted(r, lkb, 1, 0, NULL)) {\n\t\tgrant_lock(r, lkb);\n\t\tqueue_cast(r, lkb, 0);\n\t\tgoto out;\n\t}\n\n\tif (can_be_queued(lkb)) {\n\t\terror = -EINPROGRESS;\n\t\tadd_lkb(r, lkb, DLM_LKSTS_WAITING);\n\t\tgoto out;\n\t}\n\n\terror = -EAGAIN;\n\tqueue_cast(r, lkb, -EAGAIN);\n out:\n\treturn error;\n}\n\nstatic void do_request_effects(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t       int error)\n{\n\tswitch (error) {\n\tcase -EAGAIN:\n\t\tif (force_blocking_asts(lkb))\n\t\t\tsend_blocking_asts_all(r, lkb);\n\t\tbreak;\n\tcase -EINPROGRESS:\n\t\tsend_blocking_asts(r, lkb);\n\t\tbreak;\n\t}\n}\n\nstatic int do_convert(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error = 0;\n\tint deadlk = 0;\n\n\t \n\n\tif (can_be_granted(r, lkb, 1, 0, &deadlk)) {\n\t\tgrant_lock(r, lkb);\n\t\tqueue_cast(r, lkb, 0);\n\t\tgoto out;\n\t}\n\n\t \n\n\tif (deadlk && !(lkb->lkb_exflags & DLM_LKF_NODLCKWT)) {\n\t\t \n\t\trevert_lock(r, lkb);\n\t\tqueue_cast(r, lkb, -EDEADLK);\n\t\terror = -EDEADLK;\n\t\tgoto out;\n\t}\n\n\t \n\n\tif (is_demoted(lkb)) {\n\t\tgrant_pending_convert(r, DLM_LOCK_IV, NULL, NULL);\n\t\tif (_can_be_granted(r, lkb, 1, 0)) {\n\t\t\tgrant_lock(r, lkb);\n\t\t\tqueue_cast(r, lkb, 0);\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t}\n\n\tif (can_be_queued(lkb)) {\n\t\terror = -EINPROGRESS;\n\t\tdel_lkb(r, lkb);\n\t\tadd_lkb(r, lkb, DLM_LKSTS_CONVERT);\n\t\tgoto out;\n\t}\n\n\terror = -EAGAIN;\n\tqueue_cast(r, lkb, -EAGAIN);\n out:\n\treturn error;\n}\n\nstatic void do_convert_effects(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t       int error)\n{\n\tswitch (error) {\n\tcase 0:\n\t\tgrant_pending_locks(r, NULL);\n\t\t \n\t\tbreak;\n\tcase -EAGAIN:\n\t\tif (force_blocking_asts(lkb))\n\t\t\tsend_blocking_asts_all(r, lkb);\n\t\tbreak;\n\tcase -EINPROGRESS:\n\t\tsend_blocking_asts(r, lkb);\n\t\tbreak;\n\t}\n}\n\nstatic int do_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tremove_lock(r, lkb);\n\tqueue_cast(r, lkb, -DLM_EUNLOCK);\n\treturn -DLM_EUNLOCK;\n}\n\nstatic void do_unlock_effects(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t      int error)\n{\n\tgrant_pending_locks(r, NULL);\n}\n\n \n\nstatic int do_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error;\n\n\terror = revert_lock(r, lkb);\n\tif (error) {\n\t\tqueue_cast(r, lkb, -DLM_ECANCEL);\n\t\treturn -DLM_ECANCEL;\n\t}\n\treturn 0;\n}\n\nstatic void do_cancel_effects(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t      int error)\n{\n\tif (error)\n\t\tgrant_pending_locks(r, NULL);\n}\n\n \n\n \n\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error;\n\n\t \n\n\terror = set_master(r, lkb);\n\tif (error < 0)\n\t\tgoto out;\n\tif (error) {\n\t\terror = 0;\n\t\tgoto out;\n\t}\n\n\tif (is_remote(r)) {\n\t\t \n\t\terror = send_request(r, lkb);\n\t} else {\n\t\terror = do_request(r, lkb);\n\t\t \n\t\tdo_request_effects(r, lkb, error);\n\t}\n out:\n\treturn error;\n}\n\n \n\nstatic int _convert_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error;\n\n\tif (is_remote(r)) {\n\t\t \n\t\terror = send_convert(r, lkb);\n\t} else {\n\t\terror = do_convert(r, lkb);\n\t\t \n\t\tdo_convert_effects(r, lkb, error);\n\t}\n\n\treturn error;\n}\n\n \n\nstatic int _unlock_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error;\n\n\tif (is_remote(r)) {\n\t\t \n\t\terror = send_unlock(r, lkb);\n\t} else {\n\t\terror = do_unlock(r, lkb);\n\t\t \n\t\tdo_unlock_effects(r, lkb, error);\n\t}\n\n\treturn error;\n}\n\n \n\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error;\n\n\tif (is_remote(r)) {\n\t\t \n\t\terror = send_cancel(r, lkb);\n\t} else {\n\t\terror = do_cancel(r, lkb);\n\t\t \n\t\tdo_cancel_effects(r, lkb, error);\n\t}\n\n\treturn error;\n}\n\n \n\nstatic int request_lock(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t\tconst void *name, int len,\n\t\t\tstruct dlm_args *args)\n{\n\tstruct dlm_rsb *r;\n\tint error;\n\n\terror = validate_lock_args(ls, lkb, args);\n\tif (error)\n\t\treturn error;\n\n\terror = find_rsb(ls, name, len, 0, R_REQUEST, &r);\n\tif (error)\n\t\treturn error;\n\n\tlock_rsb(r);\n\n\tattach_lkb(r, lkb);\n\tlkb->lkb_lksb->sb_lkid = lkb->lkb_id;\n\n\terror = _request_lock(r, lkb);\n\n\tunlock_rsb(r);\n\tput_rsb(r);\n\treturn error;\n}\n\nstatic int convert_lock(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t\tstruct dlm_args *args)\n{\n\tstruct dlm_rsb *r;\n\tint error;\n\n\tr = lkb->lkb_resource;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_lock_args(ls, lkb, args);\n\tif (error)\n\t\tgoto out;\n\n\terror = _convert_lock(r, lkb);\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\treturn error;\n}\n\nstatic int unlock_lock(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t       struct dlm_args *args)\n{\n\tstruct dlm_rsb *r;\n\tint error;\n\n\tr = lkb->lkb_resource;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_unlock_args(lkb, args);\n\tif (error)\n\t\tgoto out;\n\n\terror = _unlock_lock(r, lkb);\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\treturn error;\n}\n\nstatic int cancel_lock(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t       struct dlm_args *args)\n{\n\tstruct dlm_rsb *r;\n\tint error;\n\n\tr = lkb->lkb_resource;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_unlock_args(lkb, args);\n\tif (error)\n\t\tgoto out;\n\n\terror = _cancel_lock(r, lkb);\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\treturn error;\n}\n\n \n\nint dlm_lock(dlm_lockspace_t *lockspace,\n\t     int mode,\n\t     struct dlm_lksb *lksb,\n\t     uint32_t flags,\n\t     const void *name,\n\t     unsigned int namelen,\n\t     uint32_t parent_lkid,\n\t     void (*ast) (void *astarg),\n\t     void *astarg,\n\t     void (*bast) (void *astarg, int mode))\n{\n\tstruct dlm_ls *ls;\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_args args;\n\tint error, convert = flags & DLM_LKF_CONVERT;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -EINVAL;\n\n\tdlm_lock_recovery(ls);\n\n\tif (convert)\n\t\terror = find_lkb(ls, lksb->sb_lkid, &lkb);\n\telse\n\t\terror = create_lkb(ls, &lkb);\n\n\tif (error)\n\t\tgoto out;\n\n\ttrace_dlm_lock_start(ls, lkb, name, namelen, mode, flags);\n\n\terror = set_lock_args(mode, lksb, flags, namelen, ast, astarg, bast,\n\t\t\t      &args);\n\tif (error)\n\t\tgoto out_put;\n\n\tif (convert)\n\t\terror = convert_lock(ls, lkb, &args);\n\telse\n\t\terror = request_lock(ls, lkb, name, namelen, &args);\n\n\tif (error == -EINPROGRESS)\n\t\terror = 0;\n out_put:\n\ttrace_dlm_lock_end(ls, lkb, name, namelen, mode, flags, error, true);\n\n\tif (convert || error)\n\t\t__put_lkb(ls, lkb);\n\tif (error == -EAGAIN || error == -EDEADLK)\n\t\terror = 0;\n out:\n\tdlm_unlock_recovery(ls);\n\tdlm_put_lockspace(ls);\n\treturn error;\n}\n\nint dlm_unlock(dlm_lockspace_t *lockspace,\n\t       uint32_t lkid,\n\t       uint32_t flags,\n\t       struct dlm_lksb *lksb,\n\t       void *astarg)\n{\n\tstruct dlm_ls *ls;\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_args args;\n\tint error;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -EINVAL;\n\n\tdlm_lock_recovery(ls);\n\n\terror = find_lkb(ls, lkid, &lkb);\n\tif (error)\n\t\tgoto out;\n\n\ttrace_dlm_unlock_start(ls, lkb, flags);\n\n\terror = set_unlock_args(flags, astarg, &args);\n\tif (error)\n\t\tgoto out_put;\n\n\tif (flags & DLM_LKF_CANCEL)\n\t\terror = cancel_lock(ls, lkb, &args);\n\telse\n\t\terror = unlock_lock(ls, lkb, &args);\n\n\tif (error == -DLM_EUNLOCK || error == -DLM_ECANCEL)\n\t\terror = 0;\n\tif (error == -EBUSY && (flags & (DLM_LKF_CANCEL | DLM_LKF_FORCEUNLOCK)))\n\t\terror = 0;\n out_put:\n\ttrace_dlm_unlock_end(ls, lkb, flags, error);\n\n\tdlm_put_lkb(lkb);\n out:\n\tdlm_unlock_recovery(ls);\n\tdlm_put_lockspace(ls);\n\treturn error;\n}\n\n \n\nstatic int _create_message(struct dlm_ls *ls, int mb_len,\n\t\t\t   int to_nodeid, int mstype,\n\t\t\t   struct dlm_message **ms_ret,\n\t\t\t   struct dlm_mhandle **mh_ret,\n\t\t\t   gfp_t allocation)\n{\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tchar *mb;\n\n\t \n\n\tmh = dlm_midcomms_get_mhandle(to_nodeid, mb_len, allocation, &mb);\n\tif (!mh)\n\t\treturn -ENOBUFS;\n\n\tms = (struct dlm_message *) mb;\n\n\tms->m_header.h_version = cpu_to_le32(DLM_HEADER_MAJOR | DLM_HEADER_MINOR);\n\tms->m_header.u.h_lockspace = cpu_to_le32(ls->ls_global_id);\n\tms->m_header.h_nodeid = cpu_to_le32(dlm_our_nodeid());\n\tms->m_header.h_length = cpu_to_le16(mb_len);\n\tms->m_header.h_cmd = DLM_MSG;\n\n\tms->m_type = cpu_to_le32(mstype);\n\n\t*mh_ret = mh;\n\t*ms_ret = ms;\n\treturn 0;\n}\n\nstatic int create_message(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t  int to_nodeid, int mstype,\n\t\t\t  struct dlm_message **ms_ret,\n\t\t\t  struct dlm_mhandle **mh_ret,\n\t\t\t  gfp_t allocation)\n{\n\tint mb_len = sizeof(struct dlm_message);\n\n\tswitch (mstype) {\n\tcase DLM_MSG_REQUEST:\n\tcase DLM_MSG_LOOKUP:\n\tcase DLM_MSG_REMOVE:\n\t\tmb_len += r->res_length;\n\t\tbreak;\n\tcase DLM_MSG_CONVERT:\n\tcase DLM_MSG_UNLOCK:\n\tcase DLM_MSG_REQUEST_REPLY:\n\tcase DLM_MSG_CONVERT_REPLY:\n\tcase DLM_MSG_GRANT:\n\t\tif (lkb && lkb->lkb_lvbptr && (lkb->lkb_exflags & DLM_LKF_VALBLK))\n\t\t\tmb_len += r->res_ls->ls_lvblen;\n\t\tbreak;\n\t}\n\n\treturn _create_message(r->res_ls, mb_len, to_nodeid, mstype,\n\t\t\t       ms_ret, mh_ret, allocation);\n}\n\n \n\nstatic int send_message(struct dlm_mhandle *mh, struct dlm_message *ms,\n\t\t\tconst void *name, int namelen)\n{\n\tdlm_midcomms_commit_mhandle(mh, name, namelen);\n\treturn 0;\n}\n\nstatic void send_args(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t      struct dlm_message *ms)\n{\n\tms->m_nodeid   = cpu_to_le32(lkb->lkb_nodeid);\n\tms->m_pid      = cpu_to_le32(lkb->lkb_ownpid);\n\tms->m_lkid     = cpu_to_le32(lkb->lkb_id);\n\tms->m_remid    = cpu_to_le32(lkb->lkb_remid);\n\tms->m_exflags  = cpu_to_le32(lkb->lkb_exflags);\n\tms->m_sbflags  = cpu_to_le32(dlm_sbflags_val(lkb));\n\tms->m_flags    = cpu_to_le32(dlm_dflags_val(lkb));\n\tms->m_lvbseq   = cpu_to_le32(lkb->lkb_lvbseq);\n\tms->m_status   = cpu_to_le32(lkb->lkb_status);\n\tms->m_grmode   = cpu_to_le32(lkb->lkb_grmode);\n\tms->m_rqmode   = cpu_to_le32(lkb->lkb_rqmode);\n\tms->m_hash     = cpu_to_le32(r->res_hash);\n\n\t \n\n\tif (lkb->lkb_bastfn)\n\t\tms->m_asts |= cpu_to_le32(DLM_CB_BAST);\n\tif (lkb->lkb_astfn)\n\t\tms->m_asts |= cpu_to_le32(DLM_CB_CAST);\n\n\t \n\n\tswitch (ms->m_type) {\n\tcase cpu_to_le32(DLM_MSG_REQUEST):\n\tcase cpu_to_le32(DLM_MSG_LOOKUP):\n\t\tmemcpy(ms->m_extra, r->res_name, r->res_length);\n\t\tbreak;\n\tcase cpu_to_le32(DLM_MSG_CONVERT):\n\tcase cpu_to_le32(DLM_MSG_UNLOCK):\n\tcase cpu_to_le32(DLM_MSG_REQUEST_REPLY):\n\tcase cpu_to_le32(DLM_MSG_CONVERT_REPLY):\n\tcase cpu_to_le32(DLM_MSG_GRANT):\n\t\tif (!lkb->lkb_lvbptr || !(lkb->lkb_exflags & DLM_LKF_VALBLK))\n\t\t\tbreak;\n\t\tmemcpy(ms->m_extra, lkb->lkb_lvbptr, r->res_ls->ls_lvblen);\n\t\tbreak;\n\t}\n}\n\nstatic int send_common(struct dlm_rsb *r, struct dlm_lkb *lkb, int mstype)\n{\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tint to_nodeid, error;\n\n\tto_nodeid = r->res_nodeid;\n\n\terror = add_to_waiters(lkb, mstype, to_nodeid);\n\tif (error)\n\t\treturn error;\n\n\terror = create_message(r, lkb, to_nodeid, mstype, &ms, &mh, GFP_NOFS);\n\tif (error)\n\t\tgoto fail;\n\n\tsend_args(r, lkb, ms);\n\n\terror = send_message(mh, ms, r->res_name, r->res_length);\n\tif (error)\n\t\tgoto fail;\n\treturn 0;\n\n fail:\n\tremove_from_waiters(lkb, msg_reply_type(mstype));\n\treturn error;\n}\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\treturn send_common(r, lkb, DLM_MSG_REQUEST);\n}\n\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tint error;\n\n\terror = send_common(r, lkb, DLM_MSG_CONVERT);\n\n\t \n\tif (!error && down_conversion(lkb)) {\n\t\tremove_from_waiters(lkb, DLM_MSG_CONVERT_REPLY);\n\t\tr->res_ls->ls_local_ms.m_type = cpu_to_le32(DLM_MSG_CONVERT_REPLY);\n\t\tr->res_ls->ls_local_ms.m_result = 0;\n\t\t__receive_convert_reply(r, lkb, &r->res_ls->ls_local_ms, true);\n\t}\n\n\treturn error;\n}\n\n \n\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\treturn send_common(r, lkb, DLM_MSG_UNLOCK);\n}\n\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\treturn send_common(r, lkb, DLM_MSG_CANCEL);\n}\n\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tint to_nodeid, error;\n\n\tto_nodeid = lkb->lkb_nodeid;\n\n\terror = create_message(r, lkb, to_nodeid, DLM_MSG_GRANT, &ms, &mh,\n\t\t\t       GFP_NOFS);\n\tif (error)\n\t\tgoto out;\n\n\tsend_args(r, lkb, ms);\n\n\tms->m_result = 0;\n\n\terror = send_message(mh, ms, r->res_name, r->res_length);\n out:\n\treturn error;\n}\n\nstatic int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode)\n{\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tint to_nodeid, error;\n\n\tto_nodeid = lkb->lkb_nodeid;\n\n\terror = create_message(r, NULL, to_nodeid, DLM_MSG_BAST, &ms, &mh,\n\t\t\t       GFP_NOFS);\n\tif (error)\n\t\tgoto out;\n\n\tsend_args(r, lkb, ms);\n\n\tms->m_bastmode = cpu_to_le32(mode);\n\n\terror = send_message(mh, ms, r->res_name, r->res_length);\n out:\n\treturn error;\n}\n\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tint to_nodeid, error;\n\n\tto_nodeid = dlm_dir_nodeid(r);\n\n\terror = add_to_waiters(lkb, DLM_MSG_LOOKUP, to_nodeid);\n\tif (error)\n\t\treturn error;\n\n\terror = create_message(r, NULL, to_nodeid, DLM_MSG_LOOKUP, &ms, &mh,\n\t\t\t       GFP_NOFS);\n\tif (error)\n\t\tgoto fail;\n\n\tsend_args(r, lkb, ms);\n\n\terror = send_message(mh, ms, r->res_name, r->res_length);\n\tif (error)\n\t\tgoto fail;\n\treturn 0;\n\n fail:\n\tremove_from_waiters(lkb, DLM_MSG_LOOKUP_REPLY);\n\treturn error;\n}\n\nstatic int send_remove(struct dlm_rsb *r)\n{\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tint to_nodeid, error;\n\n\tto_nodeid = dlm_dir_nodeid(r);\n\n\terror = create_message(r, NULL, to_nodeid, DLM_MSG_REMOVE, &ms, &mh,\n\t\t\t       GFP_ATOMIC);\n\tif (error)\n\t\tgoto out;\n\n\tmemcpy(ms->m_extra, r->res_name, r->res_length);\n\tms->m_hash = cpu_to_le32(r->res_hash);\n\n\terror = send_message(mh, ms, r->res_name, r->res_length);\n out:\n\treturn error;\n}\n\nstatic int send_common_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t     int mstype, int rv)\n{\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tint to_nodeid, error;\n\n\tto_nodeid = lkb->lkb_nodeid;\n\n\terror = create_message(r, lkb, to_nodeid, mstype, &ms, &mh, GFP_NOFS);\n\tif (error)\n\t\tgoto out;\n\n\tsend_args(r, lkb, ms);\n\n\tms->m_result = cpu_to_le32(to_dlm_errno(rv));\n\n\terror = send_message(mh, ms, r->res_name, r->res_length);\n out:\n\treturn error;\n}\n\nstatic int send_request_reply(struct dlm_rsb *r, struct dlm_lkb *lkb, int rv)\n{\n\treturn send_common_reply(r, lkb, DLM_MSG_REQUEST_REPLY, rv);\n}\n\nstatic int send_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb, int rv)\n{\n\treturn send_common_reply(r, lkb, DLM_MSG_CONVERT_REPLY, rv);\n}\n\nstatic int send_unlock_reply(struct dlm_rsb *r, struct dlm_lkb *lkb, int rv)\n{\n\treturn send_common_reply(r, lkb, DLM_MSG_UNLOCK_REPLY, rv);\n}\n\nstatic int send_cancel_reply(struct dlm_rsb *r, struct dlm_lkb *lkb, int rv)\n{\n\treturn send_common_reply(r, lkb, DLM_MSG_CANCEL_REPLY, rv);\n}\n\nstatic int send_lookup_reply(struct dlm_ls *ls,\n\t\t\t     const struct dlm_message *ms_in, int ret_nodeid,\n\t\t\t     int rv)\n{\n\tstruct dlm_rsb *r = &ls->ls_local_rsb;\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tint error, nodeid = le32_to_cpu(ms_in->m_header.h_nodeid);\n\n\terror = create_message(r, NULL, nodeid, DLM_MSG_LOOKUP_REPLY, &ms, &mh,\n\t\t\t       GFP_NOFS);\n\tif (error)\n\t\tgoto out;\n\n\tms->m_lkid = ms_in->m_lkid;\n\tms->m_result = cpu_to_le32(to_dlm_errno(rv));\n\tms->m_nodeid = cpu_to_le32(ret_nodeid);\n\n\terror = send_message(mh, ms, ms_in->m_extra, receive_extralen(ms_in));\n out:\n\treturn error;\n}\n\n \n\nstatic void receive_flags(struct dlm_lkb *lkb, const struct dlm_message *ms)\n{\n\tlkb->lkb_exflags = le32_to_cpu(ms->m_exflags);\n\tdlm_set_sbflags_val(lkb, le32_to_cpu(ms->m_sbflags));\n\tdlm_set_dflags_val(lkb, le32_to_cpu(ms->m_flags));\n}\n\nstatic void receive_flags_reply(struct dlm_lkb *lkb,\n\t\t\t\tconst struct dlm_message *ms,\n\t\t\t\tbool local)\n{\n\tif (local)\n\t\treturn;\n\n\tdlm_set_sbflags_val(lkb, le32_to_cpu(ms->m_sbflags));\n\tdlm_set_dflags_val(lkb, le32_to_cpu(ms->m_flags));\n}\n\nstatic int receive_extralen(const struct dlm_message *ms)\n{\n\treturn (le16_to_cpu(ms->m_header.h_length) -\n\t\tsizeof(struct dlm_message));\n}\n\nstatic int receive_lvb(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t       const struct dlm_message *ms)\n{\n\tint len;\n\n\tif (lkb->lkb_exflags & DLM_LKF_VALBLK) {\n\t\tif (!lkb->lkb_lvbptr)\n\t\t\tlkb->lkb_lvbptr = dlm_allocate_lvb(ls);\n\t\tif (!lkb->lkb_lvbptr)\n\t\t\treturn -ENOMEM;\n\t\tlen = receive_extralen(ms);\n\t\tif (len > ls->ls_lvblen)\n\t\t\tlen = ls->ls_lvblen;\n\t\tmemcpy(lkb->lkb_lvbptr, ms->m_extra, len);\n\t}\n\treturn 0;\n}\n\nstatic void fake_bastfn(void *astparam, int mode)\n{\n\tlog_print(\"fake_bastfn should not be called\");\n}\n\nstatic void fake_astfn(void *astparam)\n{\n\tlog_print(\"fake_astfn should not be called\");\n}\n\nstatic int receive_request_args(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t\t\tconst struct dlm_message *ms)\n{\n\tlkb->lkb_nodeid = le32_to_cpu(ms->m_header.h_nodeid);\n\tlkb->lkb_ownpid = le32_to_cpu(ms->m_pid);\n\tlkb->lkb_remid = le32_to_cpu(ms->m_lkid);\n\tlkb->lkb_grmode = DLM_LOCK_IV;\n\tlkb->lkb_rqmode = le32_to_cpu(ms->m_rqmode);\n\n\tlkb->lkb_bastfn = (ms->m_asts & cpu_to_le32(DLM_CB_BAST)) ? &fake_bastfn : NULL;\n\tlkb->lkb_astfn = (ms->m_asts & cpu_to_le32(DLM_CB_CAST)) ? &fake_astfn : NULL;\n\n\tif (lkb->lkb_exflags & DLM_LKF_VALBLK) {\n\t\t \n\t\tlkb->lkb_lvbptr = dlm_allocate_lvb(ls);\n\t\tif (!lkb->lkb_lvbptr)\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic int receive_convert_args(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t\t\tconst struct dlm_message *ms)\n{\n\tif (lkb->lkb_status != DLM_LKSTS_GRANTED)\n\t\treturn -EBUSY;\n\n\tif (receive_lvb(ls, lkb, ms))\n\t\treturn -ENOMEM;\n\n\tlkb->lkb_rqmode = le32_to_cpu(ms->m_rqmode);\n\tlkb->lkb_lvbseq = le32_to_cpu(ms->m_lvbseq);\n\n\treturn 0;\n}\n\nstatic int receive_unlock_args(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t\t       const struct dlm_message *ms)\n{\n\tif (receive_lvb(ls, lkb, ms))\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\n \n\nstatic void setup_local_lkb(struct dlm_ls *ls, const struct dlm_message *ms)\n{\n\tstruct dlm_lkb *lkb = &ls->ls_local_lkb;\n\tlkb->lkb_nodeid = le32_to_cpu(ms->m_header.h_nodeid);\n\tlkb->lkb_remid = le32_to_cpu(ms->m_lkid);\n}\n\n \n\nstatic int validate_message(struct dlm_lkb *lkb, const struct dlm_message *ms)\n{\n\tint from = le32_to_cpu(ms->m_header.h_nodeid);\n\tint error = 0;\n\n\t \n\tif (ms->m_flags & cpu_to_le32(BIT(DLM_DFL_USER_BIT)) &&\n\t    !test_bit(DLM_DFL_USER_BIT, &lkb->lkb_dflags)) {\n\t\tlog_error(lkb->lkb_resource->res_ls,\n\t\t\t  \"got user dlm message for a kernel lock\");\n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tswitch (ms->m_type) {\n\tcase cpu_to_le32(DLM_MSG_CONVERT):\n\tcase cpu_to_le32(DLM_MSG_UNLOCK):\n\tcase cpu_to_le32(DLM_MSG_CANCEL):\n\t\tif (!is_master_copy(lkb) || lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tcase cpu_to_le32(DLM_MSG_CONVERT_REPLY):\n\tcase cpu_to_le32(DLM_MSG_UNLOCK_REPLY):\n\tcase cpu_to_le32(DLM_MSG_CANCEL_REPLY):\n\tcase cpu_to_le32(DLM_MSG_GRANT):\n\tcase cpu_to_le32(DLM_MSG_BAST):\n\t\tif (!is_process_copy(lkb) || lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tcase cpu_to_le32(DLM_MSG_REQUEST_REPLY):\n\t\tif (!is_process_copy(lkb))\n\t\t\terror = -EINVAL;\n\t\telse if (lkb->lkb_nodeid != -1 && lkb->lkb_nodeid != from)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\n\tdefault:\n\t\terror = -EINVAL;\n\t}\n\nout:\n\tif (error)\n\t\tlog_error(lkb->lkb_resource->res_ls,\n\t\t\t  \"ignore invalid message %d from %d %x %x %x %d\",\n\t\t\t  le32_to_cpu(ms->m_type), from, lkb->lkb_id,\n\t\t\t  lkb->lkb_remid, dlm_iflags_val(lkb),\n\t\t\t  lkb->lkb_nodeid);\n\treturn error;\n}\n\nstatic int receive_request(struct dlm_ls *ls, const struct dlm_message *ms)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_rsb *r;\n\tint from_nodeid;\n\tint error, namelen = 0;\n\n\tfrom_nodeid = le32_to_cpu(ms->m_header.h_nodeid);\n\n\terror = create_lkb(ls, &lkb);\n\tif (error)\n\t\tgoto fail;\n\n\treceive_flags(lkb, ms);\n\tset_bit(DLM_IFL_MSTCPY_BIT, &lkb->lkb_iflags);\n\terror = receive_request_args(ls, lkb, ms);\n\tif (error) {\n\t\t__put_lkb(ls, lkb);\n\t\tgoto fail;\n\t}\n\n\t \n\n\tnamelen = receive_extralen(ms);\n\n\terror = find_rsb(ls, ms->m_extra, namelen, from_nodeid,\n\t\t\t R_RECEIVE_REQUEST, &r);\n\tif (error) {\n\t\t__put_lkb(ls, lkb);\n\t\tgoto fail;\n\t}\n\n\tlock_rsb(r);\n\n\tif (r->res_master_nodeid != dlm_our_nodeid()) {\n\t\terror = validate_master_nodeid(ls, r, from_nodeid);\n\t\tif (error) {\n\t\t\tunlock_rsb(r);\n\t\t\tput_rsb(r);\n\t\t\t__put_lkb(ls, lkb);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tattach_lkb(r, lkb);\n\terror = do_request(r, lkb);\n\tsend_request_reply(r, lkb, error);\n\tdo_request_effects(r, lkb, error);\n\n\tunlock_rsb(r);\n\tput_rsb(r);\n\n\tif (error == -EINPROGRESS)\n\t\terror = 0;\n\tif (error)\n\t\tdlm_put_lkb(lkb);\n\treturn 0;\n\n fail:\n\t \n\n\tif (error != -ENOTBLK) {\n\t\tlog_limit(ls, \"receive_request %x from %d %d\",\n\t\t\t  le32_to_cpu(ms->m_lkid), from_nodeid, error);\n\t}\n\n\tsetup_local_lkb(ls, ms);\n\tsend_request_reply(&ls->ls_local_rsb, &ls->ls_local_lkb, error);\n\treturn error;\n}\n\nstatic int receive_convert(struct dlm_ls *ls, const struct dlm_message *ms)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_rsb *r;\n\tint error, reply = 1;\n\n\terror = find_lkb(ls, le32_to_cpu(ms->m_remid), &lkb);\n\tif (error)\n\t\tgoto fail;\n\n\tif (lkb->lkb_remid != le32_to_cpu(ms->m_lkid)) {\n\t\tlog_error(ls, \"receive_convert %x remid %x recover_seq %llu \"\n\t\t\t  \"remote %d %x\", lkb->lkb_id, lkb->lkb_remid,\n\t\t\t  (unsigned long long)lkb->lkb_recover_seq,\n\t\t\t  le32_to_cpu(ms->m_header.h_nodeid),\n\t\t\t  le32_to_cpu(ms->m_lkid));\n\t\terror = -ENOENT;\n\t\tdlm_put_lkb(lkb);\n\t\tgoto fail;\n\t}\n\n\tr = lkb->lkb_resource;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_message(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\treceive_flags(lkb, ms);\n\n\terror = receive_convert_args(ls, lkb, ms);\n\tif (error) {\n\t\tsend_convert_reply(r, lkb, error);\n\t\tgoto out;\n\t}\n\n\treply = !down_conversion(lkb);\n\n\terror = do_convert(r, lkb);\n\tif (reply)\n\t\tsend_convert_reply(r, lkb, error);\n\tdo_convert_effects(r, lkb, error);\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\tdlm_put_lkb(lkb);\n\treturn 0;\n\n fail:\n\tsetup_local_lkb(ls, ms);\n\tsend_convert_reply(&ls->ls_local_rsb, &ls->ls_local_lkb, error);\n\treturn error;\n}\n\nstatic int receive_unlock(struct dlm_ls *ls, const struct dlm_message *ms)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_rsb *r;\n\tint error;\n\n\terror = find_lkb(ls, le32_to_cpu(ms->m_remid), &lkb);\n\tif (error)\n\t\tgoto fail;\n\n\tif (lkb->lkb_remid != le32_to_cpu(ms->m_lkid)) {\n\t\tlog_error(ls, \"receive_unlock %x remid %x remote %d %x\",\n\t\t\t  lkb->lkb_id, lkb->lkb_remid,\n\t\t\t  le32_to_cpu(ms->m_header.h_nodeid),\n\t\t\t  le32_to_cpu(ms->m_lkid));\n\t\terror = -ENOENT;\n\t\tdlm_put_lkb(lkb);\n\t\tgoto fail;\n\t}\n\n\tr = lkb->lkb_resource;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_message(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\treceive_flags(lkb, ms);\n\n\terror = receive_unlock_args(ls, lkb, ms);\n\tif (error) {\n\t\tsend_unlock_reply(r, lkb, error);\n\t\tgoto out;\n\t}\n\n\terror = do_unlock(r, lkb);\n\tsend_unlock_reply(r, lkb, error);\n\tdo_unlock_effects(r, lkb, error);\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\tdlm_put_lkb(lkb);\n\treturn 0;\n\n fail:\n\tsetup_local_lkb(ls, ms);\n\tsend_unlock_reply(&ls->ls_local_rsb, &ls->ls_local_lkb, error);\n\treturn error;\n}\n\nstatic int receive_cancel(struct dlm_ls *ls, const struct dlm_message *ms)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_rsb *r;\n\tint error;\n\n\terror = find_lkb(ls, le32_to_cpu(ms->m_remid), &lkb);\n\tif (error)\n\t\tgoto fail;\n\n\treceive_flags(lkb, ms);\n\n\tr = lkb->lkb_resource;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_message(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\terror = do_cancel(r, lkb);\n\tsend_cancel_reply(r, lkb, error);\n\tdo_cancel_effects(r, lkb, error);\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\tdlm_put_lkb(lkb);\n\treturn 0;\n\n fail:\n\tsetup_local_lkb(ls, ms);\n\tsend_cancel_reply(&ls->ls_local_rsb, &ls->ls_local_lkb, error);\n\treturn error;\n}\n\nstatic int receive_grant(struct dlm_ls *ls, const struct dlm_message *ms)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_rsb *r;\n\tint error;\n\n\terror = find_lkb(ls, le32_to_cpu(ms->m_remid), &lkb);\n\tif (error)\n\t\treturn error;\n\n\tr = lkb->lkb_resource;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_message(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\treceive_flags_reply(lkb, ms, false);\n\tif (is_altmode(lkb))\n\t\tmunge_altmode(lkb, ms);\n\tgrant_lock_pc(r, lkb, ms);\n\tqueue_cast(r, lkb, 0);\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\tdlm_put_lkb(lkb);\n\treturn 0;\n}\n\nstatic int receive_bast(struct dlm_ls *ls, const struct dlm_message *ms)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_rsb *r;\n\tint error;\n\n\terror = find_lkb(ls, le32_to_cpu(ms->m_remid), &lkb);\n\tif (error)\n\t\treturn error;\n\n\tr = lkb->lkb_resource;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_message(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\tqueue_bast(r, lkb, le32_to_cpu(ms->m_bastmode));\n\tlkb->lkb_highbast = le32_to_cpu(ms->m_bastmode);\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\tdlm_put_lkb(lkb);\n\treturn 0;\n}\n\nstatic void receive_lookup(struct dlm_ls *ls, const struct dlm_message *ms)\n{\n\tint len, error, ret_nodeid, from_nodeid, our_nodeid;\n\n\tfrom_nodeid = le32_to_cpu(ms->m_header.h_nodeid);\n\tour_nodeid = dlm_our_nodeid();\n\n\tlen = receive_extralen(ms);\n\n\terror = dlm_master_lookup(ls, from_nodeid, ms->m_extra, len, 0,\n\t\t\t\t  &ret_nodeid, NULL);\n\n\t \n\tif (!error && ret_nodeid == our_nodeid) {\n\t\treceive_request(ls, ms);\n\t\treturn;\n\t}\n\tsend_lookup_reply(ls, ms, ret_nodeid, error);\n}\n\nstatic void receive_remove(struct dlm_ls *ls, const struct dlm_message *ms)\n{\n\tchar name[DLM_RESNAME_MAXLEN+1];\n\tstruct dlm_rsb *r;\n\tuint32_t hash, b;\n\tint rv, len, dir_nodeid, from_nodeid;\n\n\tfrom_nodeid = le32_to_cpu(ms->m_header.h_nodeid);\n\n\tlen = receive_extralen(ms);\n\n\tif (len > DLM_RESNAME_MAXLEN) {\n\t\tlog_error(ls, \"receive_remove from %d bad len %d\",\n\t\t\t  from_nodeid, len);\n\t\treturn;\n\t}\n\n\tdir_nodeid = dlm_hash2nodeid(ls, le32_to_cpu(ms->m_hash));\n\tif (dir_nodeid != dlm_our_nodeid()) {\n\t\tlog_error(ls, \"receive_remove from %d bad nodeid %d\",\n\t\t\t  from_nodeid, dir_nodeid);\n\t\treturn;\n\t}\n\n\t \n\n\tmemset(name, 0, sizeof(name));\n\tmemcpy(name, ms->m_extra, len);\n\n\thash = jhash(name, len, 0);\n\tb = hash & (ls->ls_rsbtbl_size - 1);\n\n\tspin_lock(&ls->ls_rsbtbl[b].lock);\n\n\trv = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].toss, name, len, &r);\n\tif (rv) {\n\t\t \n\t\trv = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].keep, name, len, &r);\n\t\tif (rv) {\n\t\t\t \n\t\t\tlog_error(ls, \"receive_remove from %d not found %s\",\n\t\t\t\t  from_nodeid, name);\n\t\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\t\treturn;\n\t\t}\n\t\tif (r->res_master_nodeid != from_nodeid) {\n\t\t\t \n\t\t\tlog_error(ls, \"receive_remove keep from %d master %d\",\n\t\t\t\t  from_nodeid, r->res_master_nodeid);\n\t\t\tdlm_print_rsb(r);\n\t\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\t\treturn;\n\t\t}\n\n\t\tlog_debug(ls, \"receive_remove from %d master %d first %x %s\",\n\t\t\t  from_nodeid, r->res_master_nodeid, r->res_first_lkid,\n\t\t\t  name);\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\treturn;\n\t}\n\n\tif (r->res_master_nodeid != from_nodeid) {\n\t\tlog_error(ls, \"receive_remove toss from %d master %d\",\n\t\t\t  from_nodeid, r->res_master_nodeid);\n\t\tdlm_print_rsb(r);\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\treturn;\n\t}\n\n\tif (kref_put(&r->res_ref, kill_rsb)) {\n\t\trb_erase(&r->res_hashnode, &ls->ls_rsbtbl[b].toss);\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\tdlm_free_rsb(r);\n\t} else {\n\t\tlog_error(ls, \"receive_remove from %d rsb ref error\",\n\t\t\t  from_nodeid);\n\t\tdlm_print_rsb(r);\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t}\n}\n\nstatic void receive_purge(struct dlm_ls *ls, const struct dlm_message *ms)\n{\n\tdo_purge(ls, le32_to_cpu(ms->m_nodeid), le32_to_cpu(ms->m_pid));\n}\n\nstatic int receive_request_reply(struct dlm_ls *ls,\n\t\t\t\t const struct dlm_message *ms)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_rsb *r;\n\tint error, mstype, result;\n\tint from_nodeid = le32_to_cpu(ms->m_header.h_nodeid);\n\n\terror = find_lkb(ls, le32_to_cpu(ms->m_remid), &lkb);\n\tif (error)\n\t\treturn error;\n\n\tr = lkb->lkb_resource;\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_message(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\tmstype = lkb->lkb_wait_type;\n\terror = remove_from_waiters(lkb, DLM_MSG_REQUEST_REPLY);\n\tif (error) {\n\t\tlog_error(ls, \"receive_request_reply %x remote %d %x result %d\",\n\t\t\t  lkb->lkb_id, from_nodeid, le32_to_cpu(ms->m_lkid),\n\t\t\t  from_dlm_errno(le32_to_cpu(ms->m_result)));\n\t\tdlm_dump_rsb(r);\n\t\tgoto out;\n\t}\n\n\t \n\tif (mstype == DLM_MSG_LOOKUP) {\n\t\tr->res_master_nodeid = from_nodeid;\n\t\tr->res_nodeid = from_nodeid;\n\t\tlkb->lkb_nodeid = from_nodeid;\n\t}\n\n\t \n\tresult = from_dlm_errno(le32_to_cpu(ms->m_result));\n\n\tswitch (result) {\n\tcase -EAGAIN:\n\t\t \n\t\tqueue_cast(r, lkb, -EAGAIN);\n\t\tconfirm_master(r, -EAGAIN);\n\t\tunhold_lkb(lkb);  \n\t\tbreak;\n\n\tcase -EINPROGRESS:\n\tcase 0:\n\t\t \n\t\treceive_flags_reply(lkb, ms, false);\n\t\tlkb->lkb_remid = le32_to_cpu(ms->m_lkid);\n\t\tif (is_altmode(lkb))\n\t\t\tmunge_altmode(lkb, ms);\n\t\tif (result) {\n\t\t\tadd_lkb(r, lkb, DLM_LKSTS_WAITING);\n\t\t} else {\n\t\t\tgrant_lock_pc(r, lkb, ms);\n\t\t\tqueue_cast(r, lkb, 0);\n\t\t}\n\t\tconfirm_master(r, result);\n\t\tbreak;\n\n\tcase -EBADR:\n\tcase -ENOTBLK:\n\t\t \n\t\tlog_limit(ls, \"receive_request_reply %x from %d %d \"\n\t\t\t  \"master %d dir %d first %x %s\", lkb->lkb_id,\n\t\t\t  from_nodeid, result, r->res_master_nodeid,\n\t\t\t  r->res_dir_nodeid, r->res_first_lkid, r->res_name);\n\n\t\tif (r->res_dir_nodeid != dlm_our_nodeid() &&\n\t\t    r->res_master_nodeid != dlm_our_nodeid()) {\n\t\t\t \n\t\t\tr->res_master_nodeid = 0;\n\t\t\tr->res_nodeid = -1;\n\t\t\tlkb->lkb_nodeid = -1;\n\t\t}\n\n\t\tif (is_overlap(lkb)) {\n\t\t\t \n\t\t\tqueue_cast_overlap(r, lkb);\n\t\t\tconfirm_master(r, result);\n\t\t\tunhold_lkb(lkb);  \n\t\t} else {\n\t\t\t_request_lock(r, lkb);\n\n\t\t\tif (r->res_master_nodeid == dlm_our_nodeid())\n\t\t\t\tconfirm_master(r, 0);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tlog_error(ls, \"receive_request_reply %x error %d\",\n\t\t\t  lkb->lkb_id, result);\n\t}\n\n\tif ((result == 0 || result == -EINPROGRESS) &&\n\t    test_and_clear_bit(DLM_IFL_OVERLAP_UNLOCK_BIT, &lkb->lkb_iflags)) {\n\t\tlog_debug(ls, \"receive_request_reply %x result %d unlock\",\n\t\t\t  lkb->lkb_id, result);\n\t\tclear_bit(DLM_IFL_OVERLAP_CANCEL_BIT, &lkb->lkb_iflags);\n\t\tsend_unlock(r, lkb);\n\t} else if ((result == -EINPROGRESS) &&\n\t\t   test_and_clear_bit(DLM_IFL_OVERLAP_CANCEL_BIT,\n\t\t\t\t      &lkb->lkb_iflags)) {\n\t\tlog_debug(ls, \"receive_request_reply %x cancel\", lkb->lkb_id);\n\t\tclear_bit(DLM_IFL_OVERLAP_UNLOCK_BIT, &lkb->lkb_iflags);\n\t\tsend_cancel(r, lkb);\n\t} else {\n\t\tclear_bit(DLM_IFL_OVERLAP_CANCEL_BIT, &lkb->lkb_iflags);\n\t\tclear_bit(DLM_IFL_OVERLAP_UNLOCK_BIT, &lkb->lkb_iflags);\n\t}\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\tdlm_put_lkb(lkb);\n\treturn 0;\n}\n\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    const struct dlm_message *ms, bool local)\n{\n\t \n\tswitch (from_dlm_errno(le32_to_cpu(ms->m_result))) {\n\tcase -EAGAIN:\n\t\t \n\t\tqueue_cast(r, lkb, -EAGAIN);\n\t\tbreak;\n\n\tcase -EDEADLK:\n\t\treceive_flags_reply(lkb, ms, local);\n\t\trevert_lock_pc(r, lkb);\n\t\tqueue_cast(r, lkb, -EDEADLK);\n\t\tbreak;\n\n\tcase -EINPROGRESS:\n\t\t \n\t\treceive_flags_reply(lkb, ms, local);\n\t\tif (is_demoted(lkb))\n\t\t\tmunge_demoted(lkb);\n\t\tdel_lkb(r, lkb);\n\t\tadd_lkb(r, lkb, DLM_LKSTS_CONVERT);\n\t\tbreak;\n\n\tcase 0:\n\t\t \n\t\treceive_flags_reply(lkb, ms, local);\n\t\tif (is_demoted(lkb))\n\t\t\tmunge_demoted(lkb);\n\t\tgrant_lock_pc(r, lkb, ms);\n\t\tqueue_cast(r, lkb, 0);\n\t\tbreak;\n\n\tdefault:\n\t\tlog_error(r->res_ls, \"receive_convert_reply %x remote %d %x %d\",\n\t\t\t  lkb->lkb_id, le32_to_cpu(ms->m_header.h_nodeid),\n\t\t\t  le32_to_cpu(ms->m_lkid),\n\t\t\t  from_dlm_errno(le32_to_cpu(ms->m_result)));\n\t\tdlm_print_rsb(r);\n\t\tdlm_print_lkb(lkb);\n\t}\n}\n\nstatic void _receive_convert_reply(struct dlm_lkb *lkb,\n\t\t\t\t   const struct dlm_message *ms, bool local)\n{\n\tstruct dlm_rsb *r = lkb->lkb_resource;\n\tint error;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_message(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\t \n\terror = remove_from_waiters_ms(lkb, ms, local);\n\tif (error)\n\t\tgoto out;\n\n\t__receive_convert_reply(r, lkb, ms, local);\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n}\n\nstatic int receive_convert_reply(struct dlm_ls *ls,\n\t\t\t\t const struct dlm_message *ms)\n{\n\tstruct dlm_lkb *lkb;\n\tint error;\n\n\terror = find_lkb(ls, le32_to_cpu(ms->m_remid), &lkb);\n\tif (error)\n\t\treturn error;\n\n\t_receive_convert_reply(lkb, ms, false);\n\tdlm_put_lkb(lkb);\n\treturn 0;\n}\n\nstatic void _receive_unlock_reply(struct dlm_lkb *lkb,\n\t\t\t\t  const struct dlm_message *ms, bool local)\n{\n\tstruct dlm_rsb *r = lkb->lkb_resource;\n\tint error;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_message(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\t \n\terror = remove_from_waiters_ms(lkb, ms, local);\n\tif (error)\n\t\tgoto out;\n\n\t \n\n\tswitch (from_dlm_errno(le32_to_cpu(ms->m_result))) {\n\tcase -DLM_EUNLOCK:\n\t\treceive_flags_reply(lkb, ms, local);\n\t\tremove_lock_pc(r, lkb);\n\t\tqueue_cast(r, lkb, -DLM_EUNLOCK);\n\t\tbreak;\n\tcase -ENOENT:\n\t\tbreak;\n\tdefault:\n\t\tlog_error(r->res_ls, \"receive_unlock_reply %x error %d\",\n\t\t\t  lkb->lkb_id, from_dlm_errno(le32_to_cpu(ms->m_result)));\n\t}\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n}\n\nstatic int receive_unlock_reply(struct dlm_ls *ls,\n\t\t\t\tconst struct dlm_message *ms)\n{\n\tstruct dlm_lkb *lkb;\n\tint error;\n\n\terror = find_lkb(ls, le32_to_cpu(ms->m_remid), &lkb);\n\tif (error)\n\t\treturn error;\n\n\t_receive_unlock_reply(lkb, ms, false);\n\tdlm_put_lkb(lkb);\n\treturn 0;\n}\n\nstatic void _receive_cancel_reply(struct dlm_lkb *lkb,\n\t\t\t\t  const struct dlm_message *ms, bool local)\n{\n\tstruct dlm_rsb *r = lkb->lkb_resource;\n\tint error;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_message(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\t \n\terror = remove_from_waiters_ms(lkb, ms, local);\n\tif (error)\n\t\tgoto out;\n\n\t \n\n\tswitch (from_dlm_errno(le32_to_cpu(ms->m_result))) {\n\tcase -DLM_ECANCEL:\n\t\treceive_flags_reply(lkb, ms, local);\n\t\trevert_lock_pc(r, lkb);\n\t\tqueue_cast(r, lkb, -DLM_ECANCEL);\n\t\tbreak;\n\tcase 0:\n\t\tbreak;\n\tdefault:\n\t\tlog_error(r->res_ls, \"receive_cancel_reply %x error %d\",\n\t\t\t  lkb->lkb_id,\n\t\t\t  from_dlm_errno(le32_to_cpu(ms->m_result)));\n\t}\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n}\n\nstatic int receive_cancel_reply(struct dlm_ls *ls,\n\t\t\t\tconst struct dlm_message *ms)\n{\n\tstruct dlm_lkb *lkb;\n\tint error;\n\n\terror = find_lkb(ls, le32_to_cpu(ms->m_remid), &lkb);\n\tif (error)\n\t\treturn error;\n\n\t_receive_cancel_reply(lkb, ms, false);\n\tdlm_put_lkb(lkb);\n\treturn 0;\n}\n\nstatic void receive_lookup_reply(struct dlm_ls *ls,\n\t\t\t\t const struct dlm_message *ms)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_rsb *r;\n\tint error, ret_nodeid;\n\tint do_lookup_list = 0;\n\n\terror = find_lkb(ls, le32_to_cpu(ms->m_lkid), &lkb);\n\tif (error) {\n\t\tlog_error(ls, \"%s no lkid %x\", __func__,\n\t\t\t  le32_to_cpu(ms->m_lkid));\n\t\treturn;\n\t}\n\n\t \n\n\tr = lkb->lkb_resource;\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = remove_from_waiters(lkb, DLM_MSG_LOOKUP_REPLY);\n\tif (error)\n\t\tgoto out;\n\n\tret_nodeid = le32_to_cpu(ms->m_nodeid);\n\n\t \n\n\tif (r->res_master_nodeid && (r->res_master_nodeid != ret_nodeid)) {\n\t\t \n\t\tlog_error(ls, \"receive_lookup_reply %x from %d ret %d \"\n\t\t\t  \"master %d dir %d our %d first %x %s\",\n\t\t\t  lkb->lkb_id, le32_to_cpu(ms->m_header.h_nodeid),\n\t\t\t  ret_nodeid, r->res_master_nodeid, r->res_dir_nodeid,\n\t\t\t  dlm_our_nodeid(), r->res_first_lkid, r->res_name);\n\t}\n\n\tif (ret_nodeid == dlm_our_nodeid()) {\n\t\tr->res_master_nodeid = ret_nodeid;\n\t\tr->res_nodeid = 0;\n\t\tdo_lookup_list = 1;\n\t\tr->res_first_lkid = 0;\n\t} else if (ret_nodeid == -1) {\n\t\t \n\t\tlog_error(ls, \"receive_lookup_reply %x from %d bad ret_nodeid\",\n\t\t\t  lkb->lkb_id, le32_to_cpu(ms->m_header.h_nodeid));\n\t\tr->res_master_nodeid = 0;\n\t\tr->res_nodeid = -1;\n\t\tlkb->lkb_nodeid = -1;\n\t} else {\n\t\t \n\t\tr->res_master_nodeid = ret_nodeid;\n\t\tr->res_nodeid = ret_nodeid;\n\t}\n\n\tif (is_overlap(lkb)) {\n\t\tlog_debug(ls, \"receive_lookup_reply %x unlock %x\",\n\t\t\t  lkb->lkb_id, dlm_iflags_val(lkb));\n\t\tqueue_cast_overlap(r, lkb);\n\t\tunhold_lkb(lkb);  \n\t\tgoto out_list;\n\t}\n\n\t_request_lock(r, lkb);\n\n out_list:\n\tif (do_lookup_list)\n\t\tprocess_lookup_list(r);\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\tdlm_put_lkb(lkb);\n}\n\nstatic void _receive_message(struct dlm_ls *ls, const struct dlm_message *ms,\n\t\t\t     uint32_t saved_seq)\n{\n\tint error = 0, noent = 0;\n\n\tif (WARN_ON_ONCE(!dlm_is_member(ls, le32_to_cpu(ms->m_header.h_nodeid)))) {\n\t\tlog_limit(ls, \"receive %d from non-member %d %x %x %d\",\n\t\t\t  le32_to_cpu(ms->m_type),\n\t\t\t  le32_to_cpu(ms->m_header.h_nodeid),\n\t\t\t  le32_to_cpu(ms->m_lkid), le32_to_cpu(ms->m_remid),\n\t\t\t  from_dlm_errno(le32_to_cpu(ms->m_result)));\n\t\treturn;\n\t}\n\n\tswitch (ms->m_type) {\n\n\t \n\n\tcase cpu_to_le32(DLM_MSG_REQUEST):\n\t\terror = receive_request(ls, ms);\n\t\tbreak;\n\n\tcase cpu_to_le32(DLM_MSG_CONVERT):\n\t\terror = receive_convert(ls, ms);\n\t\tbreak;\n\n\tcase cpu_to_le32(DLM_MSG_UNLOCK):\n\t\terror = receive_unlock(ls, ms);\n\t\tbreak;\n\n\tcase cpu_to_le32(DLM_MSG_CANCEL):\n\t\tnoent = 1;\n\t\terror = receive_cancel(ls, ms);\n\t\tbreak;\n\n\t \n\n\tcase cpu_to_le32(DLM_MSG_REQUEST_REPLY):\n\t\terror = receive_request_reply(ls, ms);\n\t\tbreak;\n\n\tcase cpu_to_le32(DLM_MSG_CONVERT_REPLY):\n\t\terror = receive_convert_reply(ls, ms);\n\t\tbreak;\n\n\tcase cpu_to_le32(DLM_MSG_UNLOCK_REPLY):\n\t\terror = receive_unlock_reply(ls, ms);\n\t\tbreak;\n\n\tcase cpu_to_le32(DLM_MSG_CANCEL_REPLY):\n\t\terror = receive_cancel_reply(ls, ms);\n\t\tbreak;\n\n\t \n\n\tcase cpu_to_le32(DLM_MSG_GRANT):\n\t\tnoent = 1;\n\t\terror = receive_grant(ls, ms);\n\t\tbreak;\n\n\tcase cpu_to_le32(DLM_MSG_BAST):\n\t\tnoent = 1;\n\t\terror = receive_bast(ls, ms);\n\t\tbreak;\n\n\t \n\n\tcase cpu_to_le32(DLM_MSG_LOOKUP):\n\t\treceive_lookup(ls, ms);\n\t\tbreak;\n\n\tcase cpu_to_le32(DLM_MSG_REMOVE):\n\t\treceive_remove(ls, ms);\n\t\tbreak;\n\n\t \n\n\tcase cpu_to_le32(DLM_MSG_LOOKUP_REPLY):\n\t\treceive_lookup_reply(ls, ms);\n\t\tbreak;\n\n\t \n\n\tcase cpu_to_le32(DLM_MSG_PURGE):\n\t\treceive_purge(ls, ms);\n\t\tbreak;\n\n\tdefault:\n\t\tlog_error(ls, \"unknown message type %d\",\n\t\t\t  le32_to_cpu(ms->m_type));\n\t}\n\n\t \n\n\tif (error == -ENOENT && noent) {\n\t\tlog_debug(ls, \"receive %d no %x remote %d %x saved_seq %u\",\n\t\t\t  le32_to_cpu(ms->m_type), le32_to_cpu(ms->m_remid),\n\t\t\t  le32_to_cpu(ms->m_header.h_nodeid),\n\t\t\t  le32_to_cpu(ms->m_lkid), saved_seq);\n\t} else if (error == -ENOENT) {\n\t\tlog_error(ls, \"receive %d no %x remote %d %x saved_seq %u\",\n\t\t\t  le32_to_cpu(ms->m_type), le32_to_cpu(ms->m_remid),\n\t\t\t  le32_to_cpu(ms->m_header.h_nodeid),\n\t\t\t  le32_to_cpu(ms->m_lkid), saved_seq);\n\n\t\tif (ms->m_type == cpu_to_le32(DLM_MSG_CONVERT))\n\t\t\tdlm_dump_rsb_hash(ls, le32_to_cpu(ms->m_hash));\n\t}\n\n\tif (error == -EINVAL) {\n\t\tlog_error(ls, \"receive %d inval from %d lkid %x remid %x \"\n\t\t\t  \"saved_seq %u\",\n\t\t\t  le32_to_cpu(ms->m_type),\n\t\t\t  le32_to_cpu(ms->m_header.h_nodeid),\n\t\t\t  le32_to_cpu(ms->m_lkid), le32_to_cpu(ms->m_remid),\n\t\t\t  saved_seq);\n\t}\n}\n\n \n\nstatic void dlm_receive_message(struct dlm_ls *ls, const struct dlm_message *ms,\n\t\t\t\tint nodeid)\n{\n\tif (dlm_locking_stopped(ls)) {\n\t\t \n\t\tif (WARN_ON_ONCE(!ls->ls_generation)) {\n\t\t\tlog_limit(ls, \"receive %d from %d ignore old gen\",\n\t\t\t\t  le32_to_cpu(ms->m_type), nodeid);\n\t\t\treturn;\n\t\t}\n\n\t\tdlm_add_requestqueue(ls, nodeid, ms);\n\t} else {\n\t\tdlm_wait_requestqueue(ls);\n\t\t_receive_message(ls, ms, 0);\n\t}\n}\n\n \n\nvoid dlm_receive_message_saved(struct dlm_ls *ls, const struct dlm_message *ms,\n\t\t\t       uint32_t saved_seq)\n{\n\t_receive_message(ls, ms, saved_seq);\n}\n\n \n\nvoid dlm_receive_buffer(const union dlm_packet *p, int nodeid)\n{\n\tconst struct dlm_header *hd = &p->header;\n\tstruct dlm_ls *ls;\n\tint type = 0;\n\n\tswitch (hd->h_cmd) {\n\tcase DLM_MSG:\n\t\ttype = le32_to_cpu(p->message.m_type);\n\t\tbreak;\n\tcase DLM_RCOM:\n\t\ttype = le32_to_cpu(p->rcom.rc_type);\n\t\tbreak;\n\tdefault:\n\t\tlog_print(\"invalid h_cmd %d from %u\", hd->h_cmd, nodeid);\n\t\treturn;\n\t}\n\n\tif (le32_to_cpu(hd->h_nodeid) != nodeid) {\n\t\tlog_print(\"invalid h_nodeid %d from %d lockspace %x\",\n\t\t\t  le32_to_cpu(hd->h_nodeid), nodeid,\n\t\t\t  le32_to_cpu(hd->u.h_lockspace));\n\t\treturn;\n\t}\n\n\tls = dlm_find_lockspace_global(le32_to_cpu(hd->u.h_lockspace));\n\tif (!ls) {\n\t\tif (dlm_config.ci_log_debug) {\n\t\t\tprintk_ratelimited(KERN_DEBUG \"dlm: invalid lockspace \"\n\t\t\t\t\"%u from %d cmd %d type %d\\n\",\n\t\t\t\tle32_to_cpu(hd->u.h_lockspace), nodeid,\n\t\t\t\thd->h_cmd, type);\n\t\t}\n\n\t\tif (hd->h_cmd == DLM_RCOM && type == DLM_RCOM_STATUS)\n\t\t\tdlm_send_ls_not_ready(nodeid, &p->rcom);\n\t\treturn;\n\t}\n\n\t \n\n\tdown_read(&ls->ls_recv_active);\n\tif (hd->h_cmd == DLM_MSG)\n\t\tdlm_receive_message(ls, &p->message, nodeid);\n\telse if (hd->h_cmd == DLM_RCOM)\n\t\tdlm_receive_rcom(ls, &p->rcom, nodeid);\n\telse\n\t\tlog_error(ls, \"invalid h_cmd %d from %d lockspace %x\",\n\t\t\t  hd->h_cmd, nodeid, le32_to_cpu(hd->u.h_lockspace));\n\tup_read(&ls->ls_recv_active);\n\n\tdlm_put_lockspace(ls);\n}\n\nstatic void recover_convert_waiter(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t\t\t   struct dlm_message *ms_local)\n{\n\tif (middle_conversion(lkb)) {\n\t\thold_lkb(lkb);\n\t\tmemset(ms_local, 0, sizeof(struct dlm_message));\n\t\tms_local->m_type = cpu_to_le32(DLM_MSG_CONVERT_REPLY);\n\t\tms_local->m_result = cpu_to_le32(to_dlm_errno(-EINPROGRESS));\n\t\tms_local->m_header.h_nodeid = cpu_to_le32(lkb->lkb_nodeid);\n\t\t_receive_convert_reply(lkb, ms_local, true);\n\n\t\t \n\t\tlkb->lkb_grmode = DLM_LOCK_IV;\n\t\trsb_set_flag(lkb->lkb_resource, RSB_RECOVER_CONVERT);\n\t\tunhold_lkb(lkb);\n\n\t} else if (lkb->lkb_rqmode >= lkb->lkb_grmode) {\n\t\tset_bit(DLM_IFL_RESEND_BIT, &lkb->lkb_iflags);\n\t}\n\n\t \n}\n\n \n\nstatic int waiter_needs_recovery(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t\t\t int dir_nodeid)\n{\n\tif (dlm_no_directory(ls))\n\t\treturn 1;\n\n\tif (dlm_is_removed(ls, lkb->lkb_wait_nodeid))\n\t\treturn 1;\n\n\treturn 0;\n}\n\n \n\nvoid dlm_recover_waiters_pre(struct dlm_ls *ls)\n{\n\tstruct dlm_lkb *lkb, *safe;\n\tstruct dlm_message *ms_local;\n\tint wait_type, local_unlock_result, local_cancel_result;\n\tint dir_nodeid;\n\n\tms_local = kmalloc(sizeof(*ms_local), GFP_KERNEL);\n\tif (!ms_local)\n\t\treturn;\n\n\tmutex_lock(&ls->ls_waiters_mutex);\n\n\tlist_for_each_entry_safe(lkb, safe, &ls->ls_waiters, lkb_wait_reply) {\n\n\t\tdir_nodeid = dlm_dir_nodeid(lkb->lkb_resource);\n\n\t\t \n\n\t\tif (lkb->lkb_wait_type != DLM_MSG_UNLOCK) {\n\t\t\tlog_debug(ls, \"waiter %x remote %x msg %d r_nodeid %d \"\n\t\t\t\t  \"lkb_nodeid %d wait_nodeid %d dir_nodeid %d\",\n\t\t\t\t  lkb->lkb_id,\n\t\t\t\t  lkb->lkb_remid,\n\t\t\t\t  lkb->lkb_wait_type,\n\t\t\t\t  lkb->lkb_resource->res_nodeid,\n\t\t\t\t  lkb->lkb_nodeid,\n\t\t\t\t  lkb->lkb_wait_nodeid,\n\t\t\t\t  dir_nodeid);\n\t\t}\n\n\t\t \n\n\t\tif (lkb->lkb_wait_type == DLM_MSG_LOOKUP) {\n\t\t\tset_bit(DLM_IFL_RESEND_BIT, &lkb->lkb_iflags);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!waiter_needs_recovery(ls, lkb, dir_nodeid))\n\t\t\tcontinue;\n\n\t\twait_type = lkb->lkb_wait_type;\n\t\tlocal_unlock_result = -DLM_EUNLOCK;\n\t\tlocal_cancel_result = -DLM_ECANCEL;\n\n\t\t \n\n\t\tif (!wait_type) {\n\t\t\tif (is_overlap_cancel(lkb)) {\n\t\t\t\twait_type = DLM_MSG_CANCEL;\n\t\t\t\tif (lkb->lkb_grmode == DLM_LOCK_IV)\n\t\t\t\t\tlocal_cancel_result = 0;\n\t\t\t}\n\t\t\tif (is_overlap_unlock(lkb)) {\n\t\t\t\twait_type = DLM_MSG_UNLOCK;\n\t\t\t\tif (lkb->lkb_grmode == DLM_LOCK_IV)\n\t\t\t\t\tlocal_unlock_result = -ENOENT;\n\t\t\t}\n\n\t\t\tlog_debug(ls, \"rwpre overlap %x %x %d %d %d\",\n\t\t\t\t  lkb->lkb_id, dlm_iflags_val(lkb), wait_type,\n\t\t\t\t  local_cancel_result, local_unlock_result);\n\t\t}\n\n\t\tswitch (wait_type) {\n\n\t\tcase DLM_MSG_REQUEST:\n\t\t\tset_bit(DLM_IFL_RESEND_BIT, &lkb->lkb_iflags);\n\t\t\tbreak;\n\n\t\tcase DLM_MSG_CONVERT:\n\t\t\trecover_convert_waiter(ls, lkb, ms_local);\n\t\t\tbreak;\n\n\t\tcase DLM_MSG_UNLOCK:\n\t\t\thold_lkb(lkb);\n\t\t\tmemset(ms_local, 0, sizeof(struct dlm_message));\n\t\t\tms_local->m_type = cpu_to_le32(DLM_MSG_UNLOCK_REPLY);\n\t\t\tms_local->m_result = cpu_to_le32(to_dlm_errno(local_unlock_result));\n\t\t\tms_local->m_header.h_nodeid = cpu_to_le32(lkb->lkb_nodeid);\n\t\t\t_receive_unlock_reply(lkb, ms_local, true);\n\t\t\tdlm_put_lkb(lkb);\n\t\t\tbreak;\n\n\t\tcase DLM_MSG_CANCEL:\n\t\t\thold_lkb(lkb);\n\t\t\tmemset(ms_local, 0, sizeof(struct dlm_message));\n\t\t\tms_local->m_type = cpu_to_le32(DLM_MSG_CANCEL_REPLY);\n\t\t\tms_local->m_result = cpu_to_le32(to_dlm_errno(local_cancel_result));\n\t\t\tms_local->m_header.h_nodeid = cpu_to_le32(lkb->lkb_nodeid);\n\t\t\t_receive_cancel_reply(lkb, ms_local, true);\n\t\t\tdlm_put_lkb(lkb);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tlog_error(ls, \"invalid lkb wait_type %d %d\",\n\t\t\t\t  lkb->lkb_wait_type, wait_type);\n\t\t}\n\t\tschedule();\n\t}\n\tmutex_unlock(&ls->ls_waiters_mutex);\n\tkfree(ms_local);\n}\n\nstatic struct dlm_lkb *find_resend_waiter(struct dlm_ls *ls)\n{\n\tstruct dlm_lkb *lkb = NULL, *iter;\n\n\tmutex_lock(&ls->ls_waiters_mutex);\n\tlist_for_each_entry(iter, &ls->ls_waiters, lkb_wait_reply) {\n\t\tif (test_bit(DLM_IFL_RESEND_BIT, &iter->lkb_iflags)) {\n\t\t\thold_lkb(iter);\n\t\t\tlkb = iter;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&ls->ls_waiters_mutex);\n\n\treturn lkb;\n}\n\n \n\n \n\n \n\nint dlm_recover_waiters_post(struct dlm_ls *ls)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_rsb *r;\n\tint error = 0, mstype, err, oc, ou;\n\n\twhile (1) {\n\t\tif (dlm_locking_stopped(ls)) {\n\t\t\tlog_debug(ls, \"recover_waiters_post aborted\");\n\t\t\terror = -EINTR;\n\t\t\tbreak;\n\t\t}\n\n\t\tlkb = find_resend_waiter(ls);\n\t\tif (!lkb)\n\t\t\tbreak;\n\n\t\tr = lkb->lkb_resource;\n\t\thold_rsb(r);\n\t\tlock_rsb(r);\n\n\t\tmstype = lkb->lkb_wait_type;\n\t\toc = test_and_clear_bit(DLM_IFL_OVERLAP_CANCEL_BIT,\n\t\t\t\t\t&lkb->lkb_iflags);\n\t\tou = test_and_clear_bit(DLM_IFL_OVERLAP_UNLOCK_BIT,\n\t\t\t\t\t&lkb->lkb_iflags);\n\t\terr = 0;\n\n\t\tlog_debug(ls, \"waiter %x remote %x msg %d r_nodeid %d \"\n\t\t\t  \"lkb_nodeid %d wait_nodeid %d dir_nodeid %d \"\n\t\t\t  \"overlap %d %d\", lkb->lkb_id, lkb->lkb_remid, mstype,\n\t\t\t  r->res_nodeid, lkb->lkb_nodeid, lkb->lkb_wait_nodeid,\n\t\t\t  dlm_dir_nodeid(r), oc, ou);\n\n\t\t \n\n\t\tclear_bit(DLM_IFL_RESEND_BIT, &lkb->lkb_iflags);\n\t\tlkb->lkb_wait_type = 0;\n\t\t \n\t\twhile (!atomic_dec_and_test(&lkb->lkb_wait_count))\n\t\t\tunhold_lkb(lkb);\n\n\t\tmutex_lock(&ls->ls_waiters_mutex);\n\t\tlist_del_init(&lkb->lkb_wait_reply);\n\t\tmutex_unlock(&ls->ls_waiters_mutex);\n\n\t\tif (oc || ou) {\n\t\t\t \n\t\t\tswitch (mstype) {\n\t\t\tcase DLM_MSG_LOOKUP:\n\t\t\tcase DLM_MSG_REQUEST:\n\t\t\t\tqueue_cast(r, lkb, ou ? -DLM_EUNLOCK :\n\t\t\t\t\t\t\t-DLM_ECANCEL);\n\t\t\t\tunhold_lkb(lkb);  \n\t\t\t\tbreak;\n\t\t\tcase DLM_MSG_CONVERT:\n\t\t\t\tif (oc) {\n\t\t\t\t\tqueue_cast(r, lkb, -DLM_ECANCEL);\n\t\t\t\t} else {\n\t\t\t\t\tlkb->lkb_exflags |= DLM_LKF_FORCEUNLOCK;\n\t\t\t\t\t_unlock_lock(r, lkb);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terr = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (mstype) {\n\t\t\tcase DLM_MSG_LOOKUP:\n\t\t\tcase DLM_MSG_REQUEST:\n\t\t\t\t_request_lock(r, lkb);\n\t\t\t\tif (is_master(r))\n\t\t\t\t\tconfirm_master(r, 0);\n\t\t\t\tbreak;\n\t\t\tcase DLM_MSG_CONVERT:\n\t\t\t\t_convert_lock(r, lkb);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terr = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (err) {\n\t\t\tlog_error(ls, \"waiter %x msg %d r_nodeid %d \"\n\t\t\t\t  \"dir_nodeid %d overlap %d %d\",\n\t\t\t\t  lkb->lkb_id, mstype, r->res_nodeid,\n\t\t\t\t  dlm_dir_nodeid(r), oc, ou);\n\t\t}\n\t\tunlock_rsb(r);\n\t\tput_rsb(r);\n\t\tdlm_put_lkb(lkb);\n\t}\n\n\treturn error;\n}\n\nstatic void purge_mstcpy_list(struct dlm_ls *ls, struct dlm_rsb *r,\n\t\t\t      struct list_head *list)\n{\n\tstruct dlm_lkb *lkb, *safe;\n\n\tlist_for_each_entry_safe(lkb, safe, list, lkb_statequeue) {\n\t\tif (!is_master_copy(lkb))\n\t\t\tcontinue;\n\n\t\t \n\n\t\tif (lkb->lkb_recover_seq == ls->ls_recover_seq)\n\t\t\tcontinue;\n\n\t\tdel_lkb(r, lkb);\n\n\t\t \n\t\tif (!dlm_put_lkb(lkb))\n\t\t\tlog_error(ls, \"purged mstcpy lkb not released\");\n\t}\n}\n\nvoid dlm_purge_mstcpy_locks(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\n\tpurge_mstcpy_list(ls, r, &r->res_grantqueue);\n\tpurge_mstcpy_list(ls, r, &r->res_convertqueue);\n\tpurge_mstcpy_list(ls, r, &r->res_waitqueue);\n}\n\nstatic void purge_dead_list(struct dlm_ls *ls, struct dlm_rsb *r,\n\t\t\t    struct list_head *list,\n\t\t\t    int nodeid_gone, unsigned int *count)\n{\n\tstruct dlm_lkb *lkb, *safe;\n\n\tlist_for_each_entry_safe(lkb, safe, list, lkb_statequeue) {\n\t\tif (!is_master_copy(lkb))\n\t\t\tcontinue;\n\n\t\tif ((lkb->lkb_nodeid == nodeid_gone) ||\n\t\t    dlm_is_removed(ls, lkb->lkb_nodeid)) {\n\n\t\t\t \n\t\t\tif ((lkb->lkb_exflags & DLM_LKF_VALBLK) &&\n\t\t\t    (lkb->lkb_grmode >= DLM_LOCK_PW)) {\n\t\t\t\trsb_set_flag(r, RSB_RECOVER_LVB_INVAL);\n\t\t\t}\n\n\t\t\tdel_lkb(r, lkb);\n\n\t\t\t \n\t\t\tif (!dlm_put_lkb(lkb))\n\t\t\t\tlog_error(ls, \"purged dead lkb not released\");\n\n\t\t\trsb_set_flag(r, RSB_RECOVER_GRANT);\n\n\t\t\t(*count)++;\n\t\t}\n\t}\n}\n\n \n\nvoid dlm_recover_purge(struct dlm_ls *ls)\n{\n\tstruct dlm_rsb *r;\n\tstruct dlm_member *memb;\n\tint nodes_count = 0;\n\tint nodeid_gone = 0;\n\tunsigned int lkb_count = 0;\n\n\t \n\n\tlist_for_each_entry(memb, &ls->ls_nodes_gone, list) {\n\t\tnodes_count++;\n\t\tnodeid_gone = memb->nodeid;\n\t}\n\n\tif (!nodes_count)\n\t\treturn;\n\n\tdown_write(&ls->ls_root_sem);\n\tlist_for_each_entry(r, &ls->ls_root_list, res_root_list) {\n\t\thold_rsb(r);\n\t\tlock_rsb(r);\n\t\tif (is_master(r)) {\n\t\t\tpurge_dead_list(ls, r, &r->res_grantqueue,\n\t\t\t\t\tnodeid_gone, &lkb_count);\n\t\t\tpurge_dead_list(ls, r, &r->res_convertqueue,\n\t\t\t\t\tnodeid_gone, &lkb_count);\n\t\t\tpurge_dead_list(ls, r, &r->res_waitqueue,\n\t\t\t\t\tnodeid_gone, &lkb_count);\n\t\t}\n\t\tunlock_rsb(r);\n\t\tunhold_rsb(r);\n\t\tcond_resched();\n\t}\n\tup_write(&ls->ls_root_sem);\n\n\tif (lkb_count)\n\t\tlog_rinfo(ls, \"dlm_recover_purge %u locks for %u nodes\",\n\t\t\t  lkb_count, nodes_count);\n}\n\nstatic struct dlm_rsb *find_grant_rsb(struct dlm_ls *ls, int bucket)\n{\n\tstruct rb_node *n;\n\tstruct dlm_rsb *r;\n\n\tspin_lock(&ls->ls_rsbtbl[bucket].lock);\n\tfor (n = rb_first(&ls->ls_rsbtbl[bucket].keep); n; n = rb_next(n)) {\n\t\tr = rb_entry(n, struct dlm_rsb, res_hashnode);\n\n\t\tif (!rsb_flag(r, RSB_RECOVER_GRANT))\n\t\t\tcontinue;\n\t\tif (!is_master(r)) {\n\t\t\trsb_clear_flag(r, RSB_RECOVER_GRANT);\n\t\t\tcontinue;\n\t\t}\n\t\thold_rsb(r);\n\t\tspin_unlock(&ls->ls_rsbtbl[bucket].lock);\n\t\treturn r;\n\t}\n\tspin_unlock(&ls->ls_rsbtbl[bucket].lock);\n\treturn NULL;\n}\n\n \n\nvoid dlm_recover_grant(struct dlm_ls *ls)\n{\n\tstruct dlm_rsb *r;\n\tint bucket = 0;\n\tunsigned int count = 0;\n\tunsigned int rsb_count = 0;\n\tunsigned int lkb_count = 0;\n\n\twhile (1) {\n\t\tr = find_grant_rsb(ls, bucket);\n\t\tif (!r) {\n\t\t\tif (bucket == ls->ls_rsbtbl_size - 1)\n\t\t\t\tbreak;\n\t\t\tbucket++;\n\t\t\tcontinue;\n\t\t}\n\t\trsb_count++;\n\t\tcount = 0;\n\t\tlock_rsb(r);\n\t\t \n\t\tgrant_pending_locks(r, &count);\n\t\trsb_clear_flag(r, RSB_RECOVER_GRANT);\n\t\tlkb_count += count;\n\t\tconfirm_master(r, 0);\n\t\tunlock_rsb(r);\n\t\tput_rsb(r);\n\t\tcond_resched();\n\t}\n\n\tif (lkb_count)\n\t\tlog_rinfo(ls, \"dlm_recover_grant %u locks on %u resources\",\n\t\t\t  lkb_count, rsb_count);\n}\n\nstatic struct dlm_lkb *search_remid_list(struct list_head *head, int nodeid,\n\t\t\t\t\t uint32_t remid)\n{\n\tstruct dlm_lkb *lkb;\n\n\tlist_for_each_entry(lkb, head, lkb_statequeue) {\n\t\tif (lkb->lkb_nodeid == nodeid && lkb->lkb_remid == remid)\n\t\t\treturn lkb;\n\t}\n\treturn NULL;\n}\n\nstatic struct dlm_lkb *search_remid(struct dlm_rsb *r, int nodeid,\n\t\t\t\t    uint32_t remid)\n{\n\tstruct dlm_lkb *lkb;\n\n\tlkb = search_remid_list(&r->res_grantqueue, nodeid, remid);\n\tif (lkb)\n\t\treturn lkb;\n\tlkb = search_remid_list(&r->res_convertqueue, nodeid, remid);\n\tif (lkb)\n\t\treturn lkb;\n\tlkb = search_remid_list(&r->res_waitqueue, nodeid, remid);\n\tif (lkb)\n\t\treturn lkb;\n\treturn NULL;\n}\n\n \nstatic int receive_rcom_lock_args(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t\t\t  struct dlm_rsb *r, const struct dlm_rcom *rc)\n{\n\tstruct rcom_lock *rl = (struct rcom_lock *) rc->rc_buf;\n\n\tlkb->lkb_nodeid = le32_to_cpu(rc->rc_header.h_nodeid);\n\tlkb->lkb_ownpid = le32_to_cpu(rl->rl_ownpid);\n\tlkb->lkb_remid = le32_to_cpu(rl->rl_lkid);\n\tlkb->lkb_exflags = le32_to_cpu(rl->rl_exflags);\n\tdlm_set_dflags_val(lkb, le32_to_cpu(rl->rl_flags));\n\tset_bit(DLM_IFL_MSTCPY_BIT, &lkb->lkb_iflags);\n\tlkb->lkb_lvbseq = le32_to_cpu(rl->rl_lvbseq);\n\tlkb->lkb_rqmode = rl->rl_rqmode;\n\tlkb->lkb_grmode = rl->rl_grmode;\n\t \n\n\tlkb->lkb_bastfn = (rl->rl_asts & DLM_CB_BAST) ? &fake_bastfn : NULL;\n\tlkb->lkb_astfn = (rl->rl_asts & DLM_CB_CAST) ? &fake_astfn : NULL;\n\n\tif (lkb->lkb_exflags & DLM_LKF_VALBLK) {\n\t\tint lvblen = le16_to_cpu(rc->rc_header.h_length) -\n\t\t\tsizeof(struct dlm_rcom) - sizeof(struct rcom_lock);\n\t\tif (lvblen > ls->ls_lvblen)\n\t\t\treturn -EINVAL;\n\t\tlkb->lkb_lvbptr = dlm_allocate_lvb(ls);\n\t\tif (!lkb->lkb_lvbptr)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy(lkb->lkb_lvbptr, rl->rl_lvb, lvblen);\n\t}\n\n\t \n\n\tif (rl->rl_wait_type == cpu_to_le16(DLM_MSG_CONVERT) &&\n\t    middle_conversion(lkb)) {\n\t\trl->rl_status = DLM_LKSTS_CONVERT;\n\t\tlkb->lkb_grmode = DLM_LOCK_IV;\n\t\trsb_set_flag(r, RSB_RECOVER_CONVERT);\n\t}\n\n\treturn 0;\n}\n\n \n\n \nint dlm_recover_master_copy(struct dlm_ls *ls, const struct dlm_rcom *rc,\n\t\t\t    __le32 *rl_remid, __le32 *rl_result)\n{\n\tstruct rcom_lock *rl = (struct rcom_lock *) rc->rc_buf;\n\tstruct dlm_rsb *r;\n\tstruct dlm_lkb *lkb;\n\tuint32_t remid = 0;\n\tint from_nodeid = le32_to_cpu(rc->rc_header.h_nodeid);\n\tint error;\n\n\t \n\t*rl_remid = rl->rl_remid;\n\n\tif (rl->rl_parent_lkid) {\n\t\terror = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tremid = le32_to_cpu(rl->rl_lkid);\n\n\t \n\n\terror = find_rsb(ls, rl->rl_name, le16_to_cpu(rl->rl_namelen),\n\t\t\t from_nodeid, R_RECEIVE_RECOVER, &r);\n\tif (error)\n\t\tgoto out;\n\n\tlock_rsb(r);\n\n\tif (dlm_no_directory(ls) && (dlm_dir_nodeid(r) != dlm_our_nodeid())) {\n\t\tlog_error(ls, \"dlm_recover_master_copy remote %d %x not dir\",\n\t\t\t  from_nodeid, remid);\n\t\terror = -EBADR;\n\t\tgoto out_unlock;\n\t}\n\n\tlkb = search_remid(r, from_nodeid, remid);\n\tif (lkb) {\n\t\terror = -EEXIST;\n\t\tgoto out_remid;\n\t}\n\n\terror = create_lkb(ls, &lkb);\n\tif (error)\n\t\tgoto out_unlock;\n\n\terror = receive_rcom_lock_args(ls, lkb, r, rc);\n\tif (error) {\n\t\t__put_lkb(ls, lkb);\n\t\tgoto out_unlock;\n\t}\n\n\tattach_lkb(r, lkb);\n\tadd_lkb(r, lkb, rl->rl_status);\n\tls->ls_recover_locks_in++;\n\n\tif (!list_empty(&r->res_waitqueue) || !list_empty(&r->res_convertqueue))\n\t\trsb_set_flag(r, RSB_RECOVER_GRANT);\n\n out_remid:\n\t \n\t*rl_remid = cpu_to_le32(lkb->lkb_id);\n\n\tlkb->lkb_recover_seq = ls->ls_recover_seq;\n\n out_unlock:\n\tunlock_rsb(r);\n\tput_rsb(r);\n out:\n\tif (error && error != -EEXIST)\n\t\tlog_rinfo(ls, \"dlm_recover_master_copy remote %d %x error %d\",\n\t\t\t  from_nodeid, remid, error);\n\t*rl_result = cpu_to_le32(error);\n\treturn error;\n}\n\n \nint dlm_recover_process_copy(struct dlm_ls *ls, const struct dlm_rcom *rc,\n\t\t\t     uint64_t seq)\n{\n\tstruct rcom_lock *rl = (struct rcom_lock *) rc->rc_buf;\n\tstruct dlm_rsb *r;\n\tstruct dlm_lkb *lkb;\n\tuint32_t lkid, remid;\n\tint error, result;\n\n\tlkid = le32_to_cpu(rl->rl_lkid);\n\tremid = le32_to_cpu(rl->rl_remid);\n\tresult = le32_to_cpu(rl->rl_result);\n\n\terror = find_lkb(ls, lkid, &lkb);\n\tif (error) {\n\t\tlog_error(ls, \"dlm_recover_process_copy no %x remote %d %x %d\",\n\t\t\t  lkid, le32_to_cpu(rc->rc_header.h_nodeid), remid,\n\t\t\t  result);\n\t\treturn error;\n\t}\n\n\tr = lkb->lkb_resource;\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\tif (!is_process_copy(lkb)) {\n\t\tlog_error(ls, \"dlm_recover_process_copy bad %x remote %d %x %d\",\n\t\t\t  lkid, le32_to_cpu(rc->rc_header.h_nodeid), remid,\n\t\t\t  result);\n\t\tdlm_dump_rsb(r);\n\t\tunlock_rsb(r);\n\t\tput_rsb(r);\n\t\tdlm_put_lkb(lkb);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (result) {\n\tcase -EBADR:\n\t\t \n\n\t\tlog_debug(ls, \"dlm_recover_process_copy %x remote %d %x %d\",\n\t\t\t  lkid, le32_to_cpu(rc->rc_header.h_nodeid), remid,\n\t\t\t  result);\n\t\n\t\tdlm_send_rcom_lock(r, lkb, seq);\n\t\tgoto out;\n\tcase -EEXIST:\n\tcase 0:\n\t\tlkb->lkb_remid = remid;\n\t\tbreak;\n\tdefault:\n\t\tlog_error(ls, \"dlm_recover_process_copy %x remote %d %x %d unk\",\n\t\t\t  lkid, le32_to_cpu(rc->rc_header.h_nodeid), remid,\n\t\t\t  result);\n\t}\n\n\t \n\tdlm_recovered_lock(r);\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\tdlm_put_lkb(lkb);\n\n\treturn 0;\n}\n\nint dlm_user_request(struct dlm_ls *ls, struct dlm_user_args *ua,\n\t\t     int mode, uint32_t flags, void *name, unsigned int namelen)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_args args;\n\tbool do_put = true;\n\tint error;\n\n\tdlm_lock_recovery(ls);\n\n\terror = create_lkb(ls, &lkb);\n\tif (error) {\n\t\tkfree(ua);\n\t\tgoto out;\n\t}\n\n\ttrace_dlm_lock_start(ls, lkb, name, namelen, mode, flags);\n\n\tif (flags & DLM_LKF_VALBLK) {\n\t\tua->lksb.sb_lvbptr = kzalloc(DLM_USER_LVB_LEN, GFP_NOFS);\n\t\tif (!ua->lksb.sb_lvbptr) {\n\t\t\tkfree(ua);\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out_put;\n\t\t}\n\t}\n\terror = set_lock_args(mode, &ua->lksb, flags, namelen, fake_astfn, ua,\n\t\t\t      fake_bastfn, &args);\n\tif (error) {\n\t\tkfree(ua->lksb.sb_lvbptr);\n\t\tua->lksb.sb_lvbptr = NULL;\n\t\tkfree(ua);\n\t\tgoto out_put;\n\t}\n\n\t \n\tset_bit(DLM_DFL_USER_BIT, &lkb->lkb_dflags);\n\terror = request_lock(ls, lkb, name, namelen, &args);\n\n\tswitch (error) {\n\tcase 0:\n\t\tbreak;\n\tcase -EINPROGRESS:\n\t\terror = 0;\n\t\tbreak;\n\tcase -EAGAIN:\n\t\terror = 0;\n\t\tfallthrough;\n\tdefault:\n\t\tgoto out_put;\n\t}\n\n\t \n\tspin_lock(&ua->proc->locks_spin);\n\thold_lkb(lkb);\n\tlist_add_tail(&lkb->lkb_ownqueue, &ua->proc->locks);\n\tspin_unlock(&ua->proc->locks_spin);\n\tdo_put = false;\n out_put:\n\ttrace_dlm_lock_end(ls, lkb, name, namelen, mode, flags, error, false);\n\tif (do_put)\n\t\t__put_lkb(ls, lkb);\n out:\n\tdlm_unlock_recovery(ls);\n\treturn error;\n}\n\nint dlm_user_convert(struct dlm_ls *ls, struct dlm_user_args *ua_tmp,\n\t\t     int mode, uint32_t flags, uint32_t lkid, char *lvb_in)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_args args;\n\tstruct dlm_user_args *ua;\n\tint error;\n\n\tdlm_lock_recovery(ls);\n\n\terror = find_lkb(ls, lkid, &lkb);\n\tif (error)\n\t\tgoto out;\n\n\ttrace_dlm_lock_start(ls, lkb, NULL, 0, mode, flags);\n\n\t \n\n\tua = lkb->lkb_ua;\n\n\tif (flags & DLM_LKF_VALBLK && !ua->lksb.sb_lvbptr) {\n\t\tua->lksb.sb_lvbptr = kzalloc(DLM_USER_LVB_LEN, GFP_NOFS);\n\t\tif (!ua->lksb.sb_lvbptr) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out_put;\n\t\t}\n\t}\n\tif (lvb_in && ua->lksb.sb_lvbptr)\n\t\tmemcpy(ua->lksb.sb_lvbptr, lvb_in, DLM_USER_LVB_LEN);\n\n\tua->xid = ua_tmp->xid;\n\tua->castparam = ua_tmp->castparam;\n\tua->castaddr = ua_tmp->castaddr;\n\tua->bastparam = ua_tmp->bastparam;\n\tua->bastaddr = ua_tmp->bastaddr;\n\tua->user_lksb = ua_tmp->user_lksb;\n\n\terror = set_lock_args(mode, &ua->lksb, flags, 0, fake_astfn, ua,\n\t\t\t      fake_bastfn, &args);\n\tif (error)\n\t\tgoto out_put;\n\n\terror = convert_lock(ls, lkb, &args);\n\n\tif (error == -EINPROGRESS || error == -EAGAIN || error == -EDEADLK)\n\t\terror = 0;\n out_put:\n\ttrace_dlm_lock_end(ls, lkb, NULL, 0, mode, flags, error, false);\n\tdlm_put_lkb(lkb);\n out:\n\tdlm_unlock_recovery(ls);\n\tkfree(ua_tmp);\n\treturn error;\n}\n\n \n\nint dlm_user_adopt_orphan(struct dlm_ls *ls, struct dlm_user_args *ua_tmp,\n\t\t     int mode, uint32_t flags, void *name, unsigned int namelen,\n\t\t     uint32_t *lkid)\n{\n\tstruct dlm_lkb *lkb = NULL, *iter;\n\tstruct dlm_user_args *ua;\n\tint found_other_mode = 0;\n\tint rv = 0;\n\n\tmutex_lock(&ls->ls_orphans_mutex);\n\tlist_for_each_entry(iter, &ls->ls_orphans, lkb_ownqueue) {\n\t\tif (iter->lkb_resource->res_length != namelen)\n\t\t\tcontinue;\n\t\tif (memcmp(iter->lkb_resource->res_name, name, namelen))\n\t\t\tcontinue;\n\t\tif (iter->lkb_grmode != mode) {\n\t\t\tfound_other_mode = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlkb = iter;\n\t\tlist_del_init(&iter->lkb_ownqueue);\n\t\tclear_bit(DLM_DFL_ORPHAN_BIT, &iter->lkb_dflags);\n\t\t*lkid = iter->lkb_id;\n\t\tbreak;\n\t}\n\tmutex_unlock(&ls->ls_orphans_mutex);\n\n\tif (!lkb && found_other_mode) {\n\t\trv = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tif (!lkb) {\n\t\trv = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tlkb->lkb_exflags = flags;\n\tlkb->lkb_ownpid = (int) current->pid;\n\n\tua = lkb->lkb_ua;\n\n\tua->proc = ua_tmp->proc;\n\tua->xid = ua_tmp->xid;\n\tua->castparam = ua_tmp->castparam;\n\tua->castaddr = ua_tmp->castaddr;\n\tua->bastparam = ua_tmp->bastparam;\n\tua->bastaddr = ua_tmp->bastaddr;\n\tua->user_lksb = ua_tmp->user_lksb;\n\n\t \n\n\tspin_lock(&ua->proc->locks_spin);\n\tlist_add_tail(&lkb->lkb_ownqueue, &ua->proc->locks);\n\tspin_unlock(&ua->proc->locks_spin);\n out:\n\tkfree(ua_tmp);\n\treturn rv;\n}\n\nint dlm_user_unlock(struct dlm_ls *ls, struct dlm_user_args *ua_tmp,\n\t\t    uint32_t flags, uint32_t lkid, char *lvb_in)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_args args;\n\tstruct dlm_user_args *ua;\n\tint error;\n\n\tdlm_lock_recovery(ls);\n\n\terror = find_lkb(ls, lkid, &lkb);\n\tif (error)\n\t\tgoto out;\n\n\ttrace_dlm_unlock_start(ls, lkb, flags);\n\n\tua = lkb->lkb_ua;\n\n\tif (lvb_in && ua->lksb.sb_lvbptr)\n\t\tmemcpy(ua->lksb.sb_lvbptr, lvb_in, DLM_USER_LVB_LEN);\n\tif (ua_tmp->castparam)\n\t\tua->castparam = ua_tmp->castparam;\n\tua->user_lksb = ua_tmp->user_lksb;\n\n\terror = set_unlock_args(flags, ua, &args);\n\tif (error)\n\t\tgoto out_put;\n\n\terror = unlock_lock(ls, lkb, &args);\n\n\tif (error == -DLM_EUNLOCK)\n\t\terror = 0;\n\t \n\tif (error == -EBUSY && (flags & DLM_LKF_FORCEUNLOCK))\n\t\terror = 0;\n\tif (error)\n\t\tgoto out_put;\n\n\tspin_lock(&ua->proc->locks_spin);\n\t \n\tif (!list_empty(&lkb->lkb_ownqueue))\n\t\tlist_move(&lkb->lkb_ownqueue, &ua->proc->unlocking);\n\tspin_unlock(&ua->proc->locks_spin);\n out_put:\n\ttrace_dlm_unlock_end(ls, lkb, flags, error);\n\tdlm_put_lkb(lkb);\n out:\n\tdlm_unlock_recovery(ls);\n\tkfree(ua_tmp);\n\treturn error;\n}\n\nint dlm_user_cancel(struct dlm_ls *ls, struct dlm_user_args *ua_tmp,\n\t\t    uint32_t flags, uint32_t lkid)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_args args;\n\tstruct dlm_user_args *ua;\n\tint error;\n\n\tdlm_lock_recovery(ls);\n\n\terror = find_lkb(ls, lkid, &lkb);\n\tif (error)\n\t\tgoto out;\n\n\ttrace_dlm_unlock_start(ls, lkb, flags);\n\n\tua = lkb->lkb_ua;\n\tif (ua_tmp->castparam)\n\t\tua->castparam = ua_tmp->castparam;\n\tua->user_lksb = ua_tmp->user_lksb;\n\n\terror = set_unlock_args(flags, ua, &args);\n\tif (error)\n\t\tgoto out_put;\n\n\terror = cancel_lock(ls, lkb, &args);\n\n\tif (error == -DLM_ECANCEL)\n\t\terror = 0;\n\t \n\tif (error == -EBUSY)\n\t\terror = 0;\n out_put:\n\ttrace_dlm_unlock_end(ls, lkb, flags, error);\n\tdlm_put_lkb(lkb);\n out:\n\tdlm_unlock_recovery(ls);\n\tkfree(ua_tmp);\n\treturn error;\n}\n\nint dlm_user_deadlock(struct dlm_ls *ls, uint32_t flags, uint32_t lkid)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_args args;\n\tstruct dlm_user_args *ua;\n\tstruct dlm_rsb *r;\n\tint error;\n\n\tdlm_lock_recovery(ls);\n\n\terror = find_lkb(ls, lkid, &lkb);\n\tif (error)\n\t\tgoto out;\n\n\ttrace_dlm_unlock_start(ls, lkb, flags);\n\n\tua = lkb->lkb_ua;\n\n\terror = set_unlock_args(flags, ua, &args);\n\tif (error)\n\t\tgoto out_put;\n\n\t \n\n\tr = lkb->lkb_resource;\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_unlock_args(lkb, &args);\n\tif (error)\n\t\tgoto out_r;\n\tset_bit(DLM_IFL_DEADLOCK_CANCEL_BIT, &lkb->lkb_iflags);\n\n\terror = _cancel_lock(r, lkb);\n out_r:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\n\tif (error == -DLM_ECANCEL)\n\t\terror = 0;\n\t \n\tif (error == -EBUSY)\n\t\terror = 0;\n out_put:\n\ttrace_dlm_unlock_end(ls, lkb, flags, error);\n\tdlm_put_lkb(lkb);\n out:\n\tdlm_unlock_recovery(ls);\n\treturn error;\n}\n\n \n\nstatic int orphan_proc_lock(struct dlm_ls *ls, struct dlm_lkb *lkb)\n{\n\tstruct dlm_args args;\n\tint error;\n\n\thold_lkb(lkb);  \n\tmutex_lock(&ls->ls_orphans_mutex);\n\tlist_add_tail(&lkb->lkb_ownqueue, &ls->ls_orphans);\n\tmutex_unlock(&ls->ls_orphans_mutex);\n\n\tset_unlock_args(0, lkb->lkb_ua, &args);\n\n\terror = cancel_lock(ls, lkb, &args);\n\tif (error == -DLM_ECANCEL)\n\t\terror = 0;\n\treturn error;\n}\n\n \n\nstatic int unlock_proc_lock(struct dlm_ls *ls, struct dlm_lkb *lkb)\n{\n\tstruct dlm_args args;\n\tint error;\n\n\tset_unlock_args(DLM_LKF_FORCEUNLOCK | DLM_LKF_IVVALBLK,\n\t\t\tlkb->lkb_ua, &args);\n\n\terror = unlock_lock(ls, lkb, &args);\n\tif (error == -DLM_EUNLOCK)\n\t\terror = 0;\n\treturn error;\n}\n\n \n\nstatic struct dlm_lkb *del_proc_lock(struct dlm_ls *ls,\n\t\t\t\t     struct dlm_user_proc *proc)\n{\n\tstruct dlm_lkb *lkb = NULL;\n\n\tspin_lock(&ls->ls_clear_proc_locks);\n\tif (list_empty(&proc->locks))\n\t\tgoto out;\n\n\tlkb = list_entry(proc->locks.next, struct dlm_lkb, lkb_ownqueue);\n\tlist_del_init(&lkb->lkb_ownqueue);\n\n\tif (lkb->lkb_exflags & DLM_LKF_PERSISTENT)\n\t\tset_bit(DLM_DFL_ORPHAN_BIT, &lkb->lkb_dflags);\n\telse\n\t\tset_bit(DLM_IFL_DEAD_BIT, &lkb->lkb_iflags);\n out:\n\tspin_unlock(&ls->ls_clear_proc_locks);\n\treturn lkb;\n}\n\n \n\n \n\nvoid dlm_clear_proc_locks(struct dlm_ls *ls, struct dlm_user_proc *proc)\n{\n\tstruct dlm_lkb *lkb, *safe;\n\n\tdlm_lock_recovery(ls);\n\n\twhile (1) {\n\t\tlkb = del_proc_lock(ls, proc);\n\t\tif (!lkb)\n\t\t\tbreak;\n\t\tif (lkb->lkb_exflags & DLM_LKF_PERSISTENT)\n\t\t\torphan_proc_lock(ls, lkb);\n\t\telse\n\t\t\tunlock_proc_lock(ls, lkb);\n\n\t\t \n\n\t\tdlm_put_lkb(lkb);\n\t}\n\n\tspin_lock(&ls->ls_clear_proc_locks);\n\n\t \n\tlist_for_each_entry_safe(lkb, safe, &proc->unlocking, lkb_ownqueue) {\n\t\tlist_del_init(&lkb->lkb_ownqueue);\n\t\tset_bit(DLM_IFL_DEAD_BIT, &lkb->lkb_iflags);\n\t\tdlm_put_lkb(lkb);\n\t}\n\n\tlist_for_each_entry_safe(lkb, safe, &proc->asts, lkb_cb_list) {\n\t\tdlm_purge_lkb_callbacks(lkb);\n\t\tlist_del_init(&lkb->lkb_cb_list);\n\t\tdlm_put_lkb(lkb);\n\t}\n\n\tspin_unlock(&ls->ls_clear_proc_locks);\n\tdlm_unlock_recovery(ls);\n}\n\nstatic void purge_proc_locks(struct dlm_ls *ls, struct dlm_user_proc *proc)\n{\n\tstruct dlm_lkb *lkb, *safe;\n\n\twhile (1) {\n\t\tlkb = NULL;\n\t\tspin_lock(&proc->locks_spin);\n\t\tif (!list_empty(&proc->locks)) {\n\t\t\tlkb = list_entry(proc->locks.next, struct dlm_lkb,\n\t\t\t\t\t lkb_ownqueue);\n\t\t\tlist_del_init(&lkb->lkb_ownqueue);\n\t\t}\n\t\tspin_unlock(&proc->locks_spin);\n\n\t\tif (!lkb)\n\t\t\tbreak;\n\n\t\tset_bit(DLM_IFL_DEAD_BIT, &lkb->lkb_iflags);\n\t\tunlock_proc_lock(ls, lkb);\n\t\tdlm_put_lkb(lkb);  \n\t}\n\n\tspin_lock(&proc->locks_spin);\n\tlist_for_each_entry_safe(lkb, safe, &proc->unlocking, lkb_ownqueue) {\n\t\tlist_del_init(&lkb->lkb_ownqueue);\n\t\tset_bit(DLM_IFL_DEAD_BIT, &lkb->lkb_iflags);\n\t\tdlm_put_lkb(lkb);\n\t}\n\tspin_unlock(&proc->locks_spin);\n\n\tspin_lock(&proc->asts_spin);\n\tlist_for_each_entry_safe(lkb, safe, &proc->asts, lkb_cb_list) {\n\t\tdlm_purge_lkb_callbacks(lkb);\n\t\tlist_del_init(&lkb->lkb_cb_list);\n\t\tdlm_put_lkb(lkb);\n\t}\n\tspin_unlock(&proc->asts_spin);\n}\n\n \n\nstatic void do_purge(struct dlm_ls *ls, int nodeid, int pid)\n{\n\tstruct dlm_lkb *lkb, *safe;\n\n\tmutex_lock(&ls->ls_orphans_mutex);\n\tlist_for_each_entry_safe(lkb, safe, &ls->ls_orphans, lkb_ownqueue) {\n\t\tif (pid && lkb->lkb_ownpid != pid)\n\t\t\tcontinue;\n\t\tunlock_proc_lock(ls, lkb);\n\t\tlist_del_init(&lkb->lkb_ownqueue);\n\t\tdlm_put_lkb(lkb);\n\t}\n\tmutex_unlock(&ls->ls_orphans_mutex);\n}\n\nstatic int send_purge(struct dlm_ls *ls, int nodeid, int pid)\n{\n\tstruct dlm_message *ms;\n\tstruct dlm_mhandle *mh;\n\tint error;\n\n\terror = _create_message(ls, sizeof(struct dlm_message), nodeid,\n\t\t\t\tDLM_MSG_PURGE, &ms, &mh, GFP_NOFS);\n\tif (error)\n\t\treturn error;\n\tms->m_nodeid = cpu_to_le32(nodeid);\n\tms->m_pid = cpu_to_le32(pid);\n\n\treturn send_message(mh, ms, NULL, 0);\n}\n\nint dlm_user_purge(struct dlm_ls *ls, struct dlm_user_proc *proc,\n\t\t   int nodeid, int pid)\n{\n\tint error = 0;\n\n\tif (nodeid && (nodeid != dlm_our_nodeid())) {\n\t\terror = send_purge(ls, nodeid, pid);\n\t} else {\n\t\tdlm_lock_recovery(ls);\n\t\tif (pid == current->pid)\n\t\t\tpurge_proc_locks(ls, proc);\n\t\telse\n\t\t\tdo_purge(ls, nodeid, pid);\n\t\tdlm_unlock_recovery(ls);\n\t}\n\treturn error;\n}\n\n \nint dlm_debug_add_lkb(struct dlm_ls *ls, uint32_t lkb_id, char *name, int len,\n\t\t      int lkb_nodeid, unsigned int lkb_dflags, int lkb_status)\n{\n\tstruct dlm_lksb *lksb;\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_rsb *r;\n\tint error;\n\n\t \n\tif (lkb_dflags & BIT(DLM_DFL_USER_BIT))\n\t\treturn -EOPNOTSUPP;\n\n\tlksb = kzalloc(sizeof(*lksb), GFP_NOFS);\n\tif (!lksb)\n\t\treturn -ENOMEM;\n\n\terror = _create_lkb(ls, &lkb, lkb_id, lkb_id + 1);\n\tif (error) {\n\t\tkfree(lksb);\n\t\treturn error;\n\t}\n\n\tdlm_set_dflags_val(lkb, lkb_dflags);\n\tlkb->lkb_nodeid = lkb_nodeid;\n\tlkb->lkb_lksb = lksb;\n\t \n\tif (~lkb_dflags & BIT(DLM_DFL_USER_BIT))\n\t\tlkb->lkb_astparam = (void *)0xDEADBEEF;\n\n\terror = find_rsb(ls, name, len, 0, R_REQUEST, &r);\n\tif (error) {\n\t\tkfree(lksb);\n\t\t__put_lkb(ls, lkb);\n\t\treturn error;\n\t}\n\n\tlock_rsb(r);\n\tattach_lkb(r, lkb);\n\tadd_lkb(r, lkb, lkb_status);\n\tunlock_rsb(r);\n\tput_rsb(r);\n\n\treturn 0;\n}\n\nint dlm_debug_add_lkb_to_waiters(struct dlm_ls *ls, uint32_t lkb_id,\n\t\t\t\t int mstype, int to_nodeid)\n{\n\tstruct dlm_lkb *lkb;\n\tint error;\n\n\terror = find_lkb(ls, lkb_id, &lkb);\n\tif (error)\n\t\treturn error;\n\n\terror = add_to_waiters(lkb, mstype, to_nodeid);\n\tdlm_put_lkb(lkb);\n\treturn error;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}