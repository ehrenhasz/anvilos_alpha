{
  "module_name": "dlm_internal.h",
  "hash_id": "52a804db0b1eb0645d6f48601e7f6a6b7edb95d826480e4911a28fc2c88997dd",
  "original_prompt": "Ingested from linux-6.6.14/fs/dlm/dlm_internal.h",
  "human_readable_source": " \n \n\n#ifndef __DLM_INTERNAL_DOT_H__\n#define __DLM_INTERNAL_DOT_H__\n\n \n\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/errno.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/socket.h>\n#include <linux/kthread.h>\n#include <linux/kobject.h>\n#include <linux/kref.h>\n#include <linux/kernel.h>\n#include <linux/jhash.h>\n#include <linux/miscdevice.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/ratelimit.h>\n#include <linux/uaccess.h>\n\n#include <linux/dlm.h>\n#include \"config.h\"\n\nstruct dlm_ls;\nstruct dlm_lkb;\nstruct dlm_rsb;\nstruct dlm_member;\nstruct dlm_rsbtable;\nstruct dlm_recover;\nstruct dlm_header;\nstruct dlm_message;\nstruct dlm_rcom;\nstruct dlm_mhandle;\nstruct dlm_msg;\n\n#define log_print(fmt, args...) \\\n\tprintk(KERN_ERR \"dlm: \"fmt\"\\n\" , ##args)\n#define log_print_ratelimited(fmt, args...) \\\n\tprintk_ratelimited(KERN_ERR \"dlm: \"fmt\"\\n\", ##args)\n#define log_error(ls, fmt, args...) \\\n\tprintk(KERN_ERR \"dlm: %s: \" fmt \"\\n\", (ls)->ls_name , ##args)\n\n#define log_rinfo(ls, fmt, args...) \\\ndo { \\\n\tif (dlm_config.ci_log_info) \\\n\t\tprintk(KERN_INFO \"dlm: %s: \" fmt \"\\n\", \\\n\t\t\t(ls)->ls_name, ##args); \\\n\telse if (dlm_config.ci_log_debug) \\\n\t\tprintk(KERN_DEBUG \"dlm: %s: \" fmt \"\\n\", \\\n\t\t       (ls)->ls_name , ##args); \\\n} while (0)\n\n#define log_debug(ls, fmt, args...) \\\ndo { \\\n\tif (dlm_config.ci_log_debug) \\\n\t\tprintk(KERN_DEBUG \"dlm: %s: \" fmt \"\\n\", \\\n\t\t       (ls)->ls_name , ##args); \\\n} while (0)\n\n#define log_limit(ls, fmt, args...) \\\ndo { \\\n\tif (dlm_config.ci_log_debug) \\\n\t\tprintk_ratelimited(KERN_DEBUG \"dlm: %s: \" fmt \"\\n\", \\\n\t\t\t(ls)->ls_name , ##args); \\\n} while (0)\n\n#define DLM_ASSERT(x, do) \\\n{ \\\n  if (!(x)) \\\n  { \\\n    printk(KERN_ERR \"\\nDLM:  Assertion failed on line %d of file %s\\n\" \\\n               \"DLM:  assertion:  \\\"%s\\\"\\n\" \\\n               \"DLM:  time = %lu\\n\", \\\n               __LINE__, __FILE__, #x, jiffies); \\\n    {do} \\\n    printk(\"\\n\"); \\\n    panic(\"DLM:  Record message above and reboot.\\n\"); \\\n  } \\\n}\n\n\n#define DLM_RTF_SHRINK_BIT\t0\n\nstruct dlm_rsbtable {\n\tstruct rb_root\t\tkeep;\n\tstruct rb_root\t\ttoss;\n\tspinlock_t\t\tlock;\n\tunsigned long\t\tflags;\n};\n\n\n \n\nstruct dlm_member {\n\tstruct list_head\tlist;\n\tint\t\t\tnodeid;\n\tint\t\t\tweight;\n\tint\t\t\tslot;\n\tint\t\t\tslot_prev;\n\tint\t\t\tcomm_seq;\n\tuint32_t\t\tgeneration;\n};\n\n \n\nstruct dlm_recover {\n\tstruct list_head\tlist;\n\tstruct dlm_config_node\t*nodes;\n\tint\t\t\tnodes_count;\n\tuint64_t\t\tseq;\n};\n\n \n\nstruct dlm_args {\n\tuint32_t\t\tflags;\n\tvoid\t\t\t(*astfn) (void *astparam);\n\tvoid\t\t\t*astparam;\n\tvoid\t\t\t(*bastfn) (void *astparam, int mode);\n\tint\t\t\tmode;\n\tstruct dlm_lksb\t\t*lksb;\n};\n\n\n \n\n \n\n#define DLM_LKSTS_WAITING\t1\n#define DLM_LKSTS_GRANTED\t2\n#define DLM_LKSTS_CONVERT\t3\n\n \n\n#define DLM_IFL_MSTCPY_BIT\t16\n#define __DLM_IFL_MIN_BIT\tDLM_IFL_MSTCPY_BIT\n#define DLM_IFL_RESEND_BIT\t17\n#define DLM_IFL_DEAD_BIT\t18\n#define DLM_IFL_OVERLAP_UNLOCK_BIT 19\n#define DLM_IFL_OVERLAP_CANCEL_BIT 20\n#define DLM_IFL_ENDOFLIFE_BIT\t21\n#define DLM_IFL_DEADLOCK_CANCEL_BIT 24\n#define DLM_IFL_CB_PENDING_BIT\t25\n#define __DLM_IFL_MAX_BIT\tDLM_IFL_CB_PENDING_BIT\n\n \n\n#define DLM_DFL_USER_BIT\t0\n#define __DLM_DFL_MIN_BIT\tDLM_DFL_USER_BIT\n#define DLM_DFL_ORPHAN_BIT\t1\n#define __DLM_DFL_MAX_BIT\tDLM_DFL_ORPHAN_BIT\n\n#define DLM_CB_CAST\t\t0x00000001\n#define DLM_CB_BAST\t\t0x00000002\n\nstruct dlm_callback {\n\tuint32_t\t\tflags;\t\t \n\tint\t\t\tsb_status;\t \n\tuint8_t\t\t\tsb_flags;\t \n\tint8_t\t\t\tmode;  \n\n\tstruct list_head\tlist;\n\tstruct kref\t\tref;\n};\n\nstruct dlm_lkb {\n\tstruct dlm_rsb\t\t*lkb_resource;\t \n\tstruct kref\t\tlkb_ref;\n\tint\t\t\tlkb_nodeid;\t \n\tint\t\t\tlkb_ownpid;\t \n\tuint32_t\t\tlkb_id;\t\t \n\tuint32_t\t\tlkb_remid;\t \n\tuint32_t\t\tlkb_exflags;\t \n\tunsigned long\t\tlkb_sbflags;\t \n\tunsigned long\t\tlkb_dflags;\t \n\tunsigned long\t\tlkb_iflags;\t \n\tuint32_t\t\tlkb_lvbseq;\t \n\n\tint8_t\t\t\tlkb_status;      \n\tint8_t\t\t\tlkb_rqmode;\t \n\tint8_t\t\t\tlkb_grmode;\t \n\tint8_t\t\t\tlkb_highbast;\t \n\n\tint8_t\t\t\tlkb_wait_type;\t \n\tatomic_t\t\tlkb_wait_count;\n\tint\t\t\tlkb_wait_nodeid;  \n\n\tstruct list_head\tlkb_statequeue;\t \n\tstruct list_head\tlkb_rsb_lookup;\t \n\tstruct list_head\tlkb_wait_reply;\t \n\tstruct list_head\tlkb_ownqueue;\t \n\tktime_t\t\t\tlkb_timestamp;\n\n\tspinlock_t\t\tlkb_cb_lock;\n\tstruct work_struct\tlkb_cb_work;\n\tstruct list_head\tlkb_cb_list;  \n\tstruct list_head\tlkb_callbacks;\n\tstruct dlm_callback\t*lkb_last_cast;\n\tstruct dlm_callback\t*lkb_last_cb;\n\tint\t\t\tlkb_last_bast_mode;\n\tktime_t\t\t\tlkb_last_cast_time;\t \n\tktime_t\t\t\tlkb_last_bast_time;\t \n\n\tuint64_t\t\tlkb_recover_seq;  \n\n\tchar\t\t\t*lkb_lvbptr;\n\tstruct dlm_lksb\t\t*lkb_lksb;       \n\tvoid\t\t\t(*lkb_astfn) (void *astparam);\n\tvoid\t\t\t(*lkb_bastfn) (void *astparam, int mode);\n\tunion {\n\t\tvoid\t\t\t*lkb_astparam;\t \n\t\tstruct dlm_user_args\t*lkb_ua;\n\t};\n};\n\n \n\nstruct dlm_rsb {\n\tstruct dlm_ls\t\t*res_ls;\t \n\tstruct kref\t\tres_ref;\n\tstruct mutex\t\tres_mutex;\n\tunsigned long\t\tres_flags;\n\tint\t\t\tres_length;\t \n\tint\t\t\tres_nodeid;\n\tint\t\t\tres_master_nodeid;\n\tint\t\t\tres_dir_nodeid;\n\tint\t\t\tres_id;\t\t \n\tuint32_t                res_lvbseq;\n\tuint32_t\t\tres_hash;\n\tuint32_t\t\tres_bucket;\t \n\tunsigned long\t\tres_toss_time;\n\tuint32_t\t\tres_first_lkid;\n\tstruct list_head\tres_lookup;\t \n\tunion {\n\t\tstruct list_head\tres_hashchain;\n\t\tstruct rb_node\t\tres_hashnode;\t \n\t};\n\tstruct list_head\tres_grantqueue;\n\tstruct list_head\tres_convertqueue;\n\tstruct list_head\tres_waitqueue;\n\n\tstruct list_head\tres_root_list;\t     \n\tstruct list_head\tres_recover_list;    \n\tint\t\t\tres_recover_locks_count;\n\n\tchar\t\t\t*res_lvbptr;\n\tchar\t\t\tres_name[DLM_RESNAME_MAXLEN+1];\n};\n\n \n\n#define DLM_LU_RECOVER_DIR\t1\n#define DLM_LU_RECOVER_MASTER\t2\n\n \n\n#define DLM_LU_MATCH\t\t1\n#define DLM_LU_ADD\t\t2\n\n \n\n#define R_REQUEST\t\t0x00000001\n#define R_RECEIVE_REQUEST\t0x00000002\n#define R_RECEIVE_RECOVER\t0x00000004\n\n \n\nenum rsb_flags {\n\tRSB_MASTER_UNCERTAIN,\n\tRSB_VALNOTVALID,\n\tRSB_VALNOTVALID_PREV,\n\tRSB_NEW_MASTER,\n\tRSB_NEW_MASTER2,\n\tRSB_RECOVER_CONVERT,\n\tRSB_RECOVER_GRANT,\n\tRSB_RECOVER_LVB_INVAL,\n};\n\nstatic inline void rsb_set_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\t__set_bit(flag, &r->res_flags);\n}\n\nstatic inline void rsb_clear_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\t__clear_bit(flag, &r->res_flags);\n}\n\nstatic inline int rsb_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\treturn test_bit(flag, &r->res_flags);\n}\n\n\n \n\n#define DLM_HEADER_MAJOR\t0x00030000\n#define DLM_HEADER_MINOR\t0x00000002\n\n#define DLM_VERSION_3_1\t\t0x00030001\n#define DLM_VERSION_3_2\t\t0x00030002\n\n#define DLM_HEADER_SLOTS\t0x00000001\n\n#define DLM_MSG\t\t\t1\n#define DLM_RCOM\t\t2\n#define DLM_OPTS\t\t3\n#define DLM_ACK\t\t\t4\n#define DLM_FIN\t\t\t5\n\nstruct dlm_header {\n\t__le32\t\t\th_version;\n\tunion {\n\t\t \n\t\t__le32\t\th_lockspace;\n\t\t \n\t\t__le32\t\th_seq;\n\t} u;\n\t__le32\t\t\th_nodeid;\t \n\t__le16\t\t\th_length;\n\tuint8_t\t\t\th_cmd;\t\t \n\tuint8_t\t\t\th_pad;\n};\n\n#define DLM_MSG_REQUEST\t\t1\n#define DLM_MSG_CONVERT\t\t2\n#define DLM_MSG_UNLOCK\t\t3\n#define DLM_MSG_CANCEL\t\t4\n#define DLM_MSG_REQUEST_REPLY\t5\n#define DLM_MSG_CONVERT_REPLY\t6\n#define DLM_MSG_UNLOCK_REPLY\t7\n#define DLM_MSG_CANCEL_REPLY\t8\n#define DLM_MSG_GRANT\t\t9\n#define DLM_MSG_BAST\t\t10\n#define DLM_MSG_LOOKUP\t\t11\n#define DLM_MSG_REMOVE\t\t12\n#define DLM_MSG_LOOKUP_REPLY\t13\n#define DLM_MSG_PURGE\t\t14\n\nstruct dlm_message {\n\tstruct dlm_header\tm_header;\n\t__le32\t\t\tm_type;\t\t \n\t__le32\t\t\tm_nodeid;\n\t__le32\t\t\tm_pid;\n\t__le32\t\t\tm_lkid;\t\t \n\t__le32\t\t\tm_remid;\t \n\t__le32\t\t\tm_parent_lkid;\n\t__le32\t\t\tm_parent_remid;\n\t__le32\t\t\tm_exflags;\n\t__le32\t\t\tm_sbflags;\n\t__le32\t\t\tm_flags;\n\t__le32\t\t\tm_lvbseq;\n\t__le32\t\t\tm_hash;\n\t__le32\t\t\tm_status;\n\t__le32\t\t\tm_grmode;\n\t__le32\t\t\tm_rqmode;\n\t__le32\t\t\tm_bastmode;\n\t__le32\t\t\tm_asts;\n\t__le32\t\t\tm_result;\t \n\tchar\t\t\tm_extra[];\t \n};\n\n\n#define DLM_RS_NODES\t\t0x00000001\n#define DLM_RS_NODES_ALL\t0x00000002\n#define DLM_RS_DIR\t\t0x00000004\n#define DLM_RS_DIR_ALL\t\t0x00000008\n#define DLM_RS_LOCKS\t\t0x00000010\n#define DLM_RS_LOCKS_ALL\t0x00000020\n#define DLM_RS_DONE\t\t0x00000040\n#define DLM_RS_DONE_ALL\t\t0x00000080\n\n#define DLM_RCOM_STATUS\t\t1\n#define DLM_RCOM_NAMES\t\t2\n#define DLM_RCOM_LOOKUP\t\t3\n#define DLM_RCOM_LOCK\t\t4\n#define DLM_RCOM_STATUS_REPLY\t5\n#define DLM_RCOM_NAMES_REPLY\t6\n#define DLM_RCOM_LOOKUP_REPLY\t7\n#define DLM_RCOM_LOCK_REPLY\t8\n\nstruct dlm_rcom {\n\tstruct dlm_header\trc_header;\n\t__le32\t\t\trc_type;\t \n\t__le32\t\t\trc_result;\t \n\t__le64\t\t\trc_id;\t\t \n\t__le64\t\t\trc_seq;\t\t \n\t__le64\t\t\trc_seq_reply;\t \n\tchar\t\t\trc_buf[];\n};\n\nstruct dlm_opt_header {\n\t__le16\t\tt_type;\n\t__le16\t\tt_length;\n\t__le32\t\tt_pad;\n\t \n\tchar\t\tt_value[];\n};\n\n \nstruct dlm_opts {\n\tstruct dlm_header\to_header;\n\tuint8_t\t\t\to_nextcmd;\n\tuint8_t\t\t\to_pad;\n\t__le16\t\t\to_optlen;\n\t__le32\t\t\to_pad2;\n\tchar\t\t\to_opts[];\n};\n\nunion dlm_packet {\n\tstruct dlm_header\theader;\t\t \n\tstruct dlm_message\tmessage;\n\tstruct dlm_rcom\t\trcom;\n\tstruct dlm_opts\t\topts;\n};\n\n#define DLM_RSF_NEED_SLOTS\t0x00000001\n\n \nstruct rcom_status {\n\t__le32\t\t\trs_flags;\n\t__le32\t\t\trs_unused1;\n\t__le64\t\t\trs_unused2;\n};\n\n \nstruct rcom_config {\n\t__le32\t\t\trf_lvblen;\n\t__le32\t\t\trf_lsflags;\n\n\t \n\t__le32\t\t\trf_flags;\n\t__le16\t\t\trf_our_slot;\n\t__le16\t\t\trf_num_slots;\n\t__le32\t\t\trf_generation;\n\t__le32\t\t\trf_unused1;\n\t__le64\t\t\trf_unused2;\n};\n\nstruct rcom_slot {\n\t__le32\t\t\tro_nodeid;\n\t__le16\t\t\tro_slot;\n\t__le16\t\t\tro_unused1;\n\t__le64\t\t\tro_unused2;\n};\n\nstruct rcom_lock {\n\t__le32\t\t\trl_ownpid;\n\t__le32\t\t\trl_lkid;\n\t__le32\t\t\trl_remid;\n\t__le32\t\t\trl_parent_lkid;\n\t__le32\t\t\trl_parent_remid;\n\t__le32\t\t\trl_exflags;\n\t__le32\t\t\trl_flags;\n\t__le32\t\t\trl_lvbseq;\n\t__le32\t\t\trl_result;\n\tint8_t\t\t\trl_rqmode;\n\tint8_t\t\t\trl_grmode;\n\tint8_t\t\t\trl_status;\n\tint8_t\t\t\trl_asts;\n\t__le16\t\t\trl_wait_type;\n\t__le16\t\t\trl_namelen;\n\tchar\t\t\trl_name[DLM_RESNAME_MAXLEN];\n\tchar\t\t\trl_lvb[];\n};\n\n \n\n#define DLM_REMOVE_NAMES_MAX 8\n\nstruct dlm_ls {\n\tstruct list_head\tls_list;\t \n\tdlm_lockspace_t\t\t*ls_local_handle;\n\tuint32_t\t\tls_global_id;\t \n\tuint32_t\t\tls_generation;\n\tuint32_t\t\tls_exflags;\n\tint\t\t\tls_lvblen;\n\tatomic_t\t\tls_count;\t \n\twait_queue_head_t\tls_count_wait;\n\tint\t\t\tls_create_count;  \n\tunsigned long\t\tls_flags;\t \n\tunsigned long\t\tls_scan_time;\n\tstruct kobject\t\tls_kobj;\n\n\tstruct idr\t\tls_lkbidr;\n\tspinlock_t\t\tls_lkbidr_spin;\n\n\tstruct dlm_rsbtable\t*ls_rsbtbl;\n\tuint32_t\t\tls_rsbtbl_size;\n\n\tstruct mutex\t\tls_waiters_mutex;\n\tstruct list_head\tls_waiters;\t \n\n\tstruct mutex\t\tls_orphans_mutex;\n\tstruct list_head\tls_orphans;\n\n\tspinlock_t\t\tls_new_rsb_spin;\n\tint\t\t\tls_new_rsb_count;\n\tstruct list_head\tls_new_rsb;\t \n\n\tchar\t\t\t*ls_remove_names[DLM_REMOVE_NAMES_MAX];\n\tint\t\t\tls_remove_lens[DLM_REMOVE_NAMES_MAX];\n\n\tstruct list_head\tls_nodes;\t \n\tstruct list_head\tls_nodes_gone;\t \n\tint\t\t\tls_num_nodes;\t \n\tint\t\t\tls_low_nodeid;\n\tint\t\t\tls_total_weight;\n\tint\t\t\t*ls_node_array;\n\n\tint\t\t\tls_slot;\n\tint\t\t\tls_num_slots;\n\tint\t\t\tls_slots_size;\n\tstruct dlm_slot\t\t*ls_slots;\n\n\tstruct dlm_rsb\t\tls_local_rsb;\t \n\tstruct dlm_lkb\t\tls_local_lkb;\t \n\tstruct dlm_message\tls_local_ms;\t \n\n\tstruct dentry\t\t*ls_debug_rsb_dentry;  \n\tstruct dentry\t\t*ls_debug_waiters_dentry;  \n\tstruct dentry\t\t*ls_debug_locks_dentry;  \n\tstruct dentry\t\t*ls_debug_all_dentry;  \n\tstruct dentry\t\t*ls_debug_toss_dentry;  \n\tstruct dentry\t\t*ls_debug_queued_asts_dentry;  \n\n\twait_queue_head_t\tls_uevent_wait;\t \n\tint\t\t\tls_uevent_result;\n\tstruct completion\tls_recovery_done;\n\tint\t\t\tls_recovery_result;\n\n\tstruct miscdevice       ls_device;\n\n\tstruct workqueue_struct\t*ls_callback_wq;\n\n\t \n\n\tspinlock_t\t\tls_cb_lock;\n\tstruct list_head\tls_cb_delay;  \n\tstruct timer_list\tls_timer;\n\tstruct task_struct\t*ls_recoverd_task;\n\tstruct mutex\t\tls_recoverd_active;\n\tspinlock_t\t\tls_recover_lock;\n\tunsigned long\t\tls_recover_begin;  \n\tuint32_t\t\tls_recover_status;  \n\tuint64_t\t\tls_recover_seq;\n\tstruct dlm_recover\t*ls_recover_args;\n\tstruct rw_semaphore\tls_in_recovery;\t \n\tstruct rw_semaphore\tls_recv_active;\t \n\tstruct list_head\tls_requestqueue; \n\tatomic_t\t\tls_requestqueue_cnt;\n\twait_queue_head_t\tls_requestqueue_wait;\n\tstruct mutex\t\tls_requestqueue_mutex;\n\tstruct dlm_rcom\t\t*ls_recover_buf;\n\tint\t\t\tls_recover_nodeid;  \n\tunsigned int\t\tls_recover_dir_sent_res;  \n\tunsigned int\t\tls_recover_dir_sent_msg;  \n\tunsigned int\t\tls_recover_locks_in;  \n\tuint64_t\t\tls_rcom_seq;\n\tspinlock_t\t\tls_rcom_spin;\n\tstruct list_head\tls_recover_list;\n\tspinlock_t\t\tls_recover_list_lock;\n\tint\t\t\tls_recover_list_count;\n\tstruct idr\t\tls_recover_idr;\n\tspinlock_t\t\tls_recover_idr_lock;\n\twait_queue_head_t\tls_wait_general;\n\twait_queue_head_t\tls_recover_lock_wait;\n\tspinlock_t\t\tls_clear_proc_locks;\n\n\tstruct list_head\tls_root_list;\t \n\tstruct rw_semaphore\tls_root_sem;\t \n\n\tconst struct dlm_lockspace_ops *ls_ops;\n\tvoid\t\t\t*ls_ops_arg;\n\n\tint\t\t\tls_namelen;\n\tchar\t\t\tls_name[DLM_LOCKSPACE_LEN + 1];\n};\n\n \n\n#define LSFL_RECOVER_STOP\t0\n#define LSFL_RECOVER_DOWN\t1\n#define LSFL_RECOVER_LOCK\t2\n#define LSFL_RECOVER_WORK\t3\n#define LSFL_RUNNING\t\t4\n\n#define LSFL_RCOM_READY\t\t5\n#define LSFL_RCOM_WAIT\t\t6\n#define LSFL_UEVENT_WAIT\t7\n#define LSFL_CB_DELAY\t\t9\n#define LSFL_NODIR\t\t10\n\n \n\nstruct dlm_user_args {\n\tstruct dlm_user_proc\t*proc;  \n\tstruct dlm_lksb\t\tlksb;\n\tstruct dlm_lksb __user\t*user_lksb;\n\tvoid __user\t\t*castparam;\n\tvoid __user\t\t*castaddr;\n\tvoid __user\t\t*bastparam;\n\tvoid __user\t\t*bastaddr;\n\tuint64_t\t\txid;\n};\n\n#define DLM_PROC_FLAGS_CLOSING 1\n#define DLM_PROC_FLAGS_COMPAT  2\n\n \n\nstruct dlm_user_proc {\n\tdlm_lockspace_t\t\t*lockspace;\n\tunsigned long\t\tflags;  \n\tstruct list_head\tasts;\n\tspinlock_t\t\tasts_spin;\n\tstruct list_head\tlocks;\n\tspinlock_t\t\tlocks_spin;\n\tstruct list_head\tunlocking;\n\twait_queue_head_t\twait;\n};\n\nstatic inline int dlm_locking_stopped(struct dlm_ls *ls)\n{\n\treturn !test_bit(LSFL_RUNNING, &ls->ls_flags);\n}\n\nstatic inline int dlm_recovery_stopped(struct dlm_ls *ls)\n{\n\treturn test_bit(LSFL_RECOVER_STOP, &ls->ls_flags);\n}\n\nstatic inline int dlm_no_directory(struct dlm_ls *ls)\n{\n\treturn test_bit(LSFL_NODIR, &ls->ls_flags);\n}\n\n \nstatic inline uint32_t dlm_flags_val(const unsigned long *addr,\n\t\t\t\t     uint32_t min, uint32_t max)\n{\n\tuint32_t bit = min, val = 0;\n\n\tfor_each_set_bit_from(bit, addr, max + 1) {\n\t\tval |= BIT(bit);\n\t}\n\n\treturn val;\n}\n\nstatic inline uint32_t dlm_iflags_val(const struct dlm_lkb *lkb)\n{\n\treturn dlm_flags_val(&lkb->lkb_iflags, __DLM_IFL_MIN_BIT,\n\t\t\t     __DLM_IFL_MAX_BIT);\n}\n\nstatic inline uint32_t dlm_dflags_val(const struct dlm_lkb *lkb)\n{\n\treturn dlm_flags_val(&lkb->lkb_dflags, __DLM_DFL_MIN_BIT,\n\t\t\t     __DLM_DFL_MAX_BIT);\n}\n\n \n#define DLM_SBF_DEMOTED_BIT\t0\n#define __DLM_SBF_MIN_BIT\tDLM_SBF_DEMOTED_BIT\n#define DLM_SBF_VALNOTVALID_BIT\t1\n#define DLM_SBF_ALTMODE_BIT\t2\n#define __DLM_SBF_MAX_BIT\tDLM_SBF_ALTMODE_BIT\n\nstatic inline uint32_t dlm_sbflags_val(const struct dlm_lkb *lkb)\n{\n\t \n\tBUILD_BUG_ON(BIT(__DLM_SBF_MAX_BIT) != DLM_SBF_ALTMODE);\n\n\treturn dlm_flags_val(&lkb->lkb_sbflags, __DLM_SBF_MIN_BIT,\n\t\t\t     __DLM_SBF_MAX_BIT);\n}\n\nstatic inline void dlm_set_flags_val(unsigned long *addr, uint32_t val,\n\t\t\t\t     uint32_t min, uint32_t max)\n{\n\tuint32_t bit;\n\n\tfor (bit = min; bit < (max + 1); bit++) {\n\t\tif (val & BIT(bit))\n\t\t\tset_bit(bit, addr);\n\t\telse\n\t\t\tclear_bit(bit, addr);\n\t}\n}\n\nstatic inline void dlm_set_dflags_val(struct dlm_lkb *lkb, uint32_t val)\n{\n\tdlm_set_flags_val(&lkb->lkb_dflags, val, __DLM_DFL_MIN_BIT,\n\t\t\t  __DLM_DFL_MAX_BIT);\n}\n\nstatic inline void dlm_set_sbflags_val(struct dlm_lkb *lkb, uint32_t val)\n{\n\tdlm_set_flags_val(&lkb->lkb_sbflags, val, __DLM_SBF_MIN_BIT,\n\t\t\t  __DLM_SBF_MAX_BIT);\n}\n\nint dlm_plock_init(void);\nvoid dlm_plock_exit(void);\n\n#ifdef CONFIG_DLM_DEBUG\nvoid dlm_register_debugfs(void);\nvoid dlm_unregister_debugfs(void);\nvoid dlm_create_debug_file(struct dlm_ls *ls);\nvoid dlm_delete_debug_file(struct dlm_ls *ls);\nvoid *dlm_create_debug_comms_file(int nodeid, void *data);\nvoid dlm_delete_debug_comms_file(void *ctx);\n#else\nstatic inline void dlm_register_debugfs(void) { }\nstatic inline void dlm_unregister_debugfs(void) { }\nstatic inline void dlm_create_debug_file(struct dlm_ls *ls) { }\nstatic inline void dlm_delete_debug_file(struct dlm_ls *ls) { }\nstatic inline void *dlm_create_debug_comms_file(int nodeid, void *data) { return NULL; }\nstatic inline void dlm_delete_debug_comms_file(void *ctx) { }\n#endif\n\n#endif\t\t\t\t \n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}