{
  "module_name": "requestqueue.c",
  "hash_id": "417d1fc4c3419da1e1b8c6dd35e147aab20f6be0e5a83800796cdfb53bee3136",
  "original_prompt": "Ingested from linux-6.6.14/fs/dlm/requestqueue.c",
  "human_readable_source": "\n \n\n#include \"dlm_internal.h\"\n#include \"member.h\"\n#include \"lock.h\"\n#include \"dir.h\"\n#include \"config.h\"\n#include \"requestqueue.h\"\n#include \"util.h\"\n\nstruct rq_entry {\n\tstruct list_head list;\n\tuint32_t recover_seq;\n\tint nodeid;\n\tstruct dlm_message request;\n};\n\n \n\nvoid dlm_add_requestqueue(struct dlm_ls *ls, int nodeid,\n\t\t\t  const struct dlm_message *ms)\n{\n\tstruct rq_entry *e;\n\tint length = le16_to_cpu(ms->m_header.h_length) -\n\t\tsizeof(struct dlm_message);\n\n\te = kmalloc(sizeof(struct rq_entry) + length, GFP_NOFS);\n\tif (!e) {\n\t\tlog_print(\"dlm_add_requestqueue: out of memory len %d\", length);\n\t\treturn;\n\t}\n\n\te->recover_seq = ls->ls_recover_seq & 0xFFFFFFFF;\n\te->nodeid = nodeid;\n\tmemcpy(&e->request, ms, sizeof(*ms));\n\tmemcpy(&e->request.m_extra, ms->m_extra, length);\n\n\tatomic_inc(&ls->ls_requestqueue_cnt);\n\tmutex_lock(&ls->ls_requestqueue_mutex);\n\tlist_add_tail(&e->list, &ls->ls_requestqueue);\n\tmutex_unlock(&ls->ls_requestqueue_mutex);\n}\n\n \n\nint dlm_process_requestqueue(struct dlm_ls *ls)\n{\n\tstruct rq_entry *e;\n\tstruct dlm_message *ms;\n\tint error = 0;\n\n\tmutex_lock(&ls->ls_requestqueue_mutex);\n\n\tfor (;;) {\n\t\tif (list_empty(&ls->ls_requestqueue)) {\n\t\t\tmutex_unlock(&ls->ls_requestqueue_mutex);\n\t\t\terror = 0;\n\t\t\tbreak;\n\t\t}\n\t\te = list_entry(ls->ls_requestqueue.next, struct rq_entry, list);\n\t\tmutex_unlock(&ls->ls_requestqueue_mutex);\n\n\t\tms = &e->request;\n\n\t\tlog_limit(ls, \"dlm_process_requestqueue msg %d from %d \"\n\t\t\t  \"lkid %x remid %x result %d seq %u\",\n\t\t\t  le32_to_cpu(ms->m_type),\n\t\t\t  le32_to_cpu(ms->m_header.h_nodeid),\n\t\t\t  le32_to_cpu(ms->m_lkid), le32_to_cpu(ms->m_remid),\n\t\t\t  from_dlm_errno(le32_to_cpu(ms->m_result)),\n\t\t\t  e->recover_seq);\n\n\t\tdlm_receive_message_saved(ls, &e->request, e->recover_seq);\n\n\t\tmutex_lock(&ls->ls_requestqueue_mutex);\n\t\tlist_del(&e->list);\n\t\tif (atomic_dec_and_test(&ls->ls_requestqueue_cnt))\n\t\t\twake_up(&ls->ls_requestqueue_wait);\n\t\tkfree(e);\n\n\t\tif (dlm_locking_stopped(ls)) {\n\t\t\tlog_debug(ls, \"process_requestqueue abort running\");\n\t\t\tmutex_unlock(&ls->ls_requestqueue_mutex);\n\t\t\terror = -EINTR;\n\t\t\tbreak;\n\t\t}\n\t\tschedule();\n\t}\n\n\treturn error;\n}\n\n \n\nvoid dlm_wait_requestqueue(struct dlm_ls *ls)\n{\n\twait_event(ls->ls_requestqueue_wait,\n\t\t   atomic_read(&ls->ls_requestqueue_cnt) == 0);\n}\n\nstatic int purge_request(struct dlm_ls *ls, struct dlm_message *ms, int nodeid)\n{\n\t__le32 type = ms->m_type;\n\n\t \n\tif (!atomic_read(&ls->ls_count))\n\t\treturn 1;\n\n\tif (dlm_is_removed(ls, nodeid))\n\t\treturn 1;\n\n\t \n\n\tif (type == cpu_to_le32(DLM_MSG_REMOVE) ||\n\t    type == cpu_to_le32(DLM_MSG_LOOKUP) ||\n\t    type == cpu_to_le32(DLM_MSG_LOOKUP_REPLY))\n\t\treturn 1;\n\n\tif (!dlm_no_directory(ls))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nvoid dlm_purge_requestqueue(struct dlm_ls *ls)\n{\n\tstruct dlm_message *ms;\n\tstruct rq_entry *e, *safe;\n\n\tmutex_lock(&ls->ls_requestqueue_mutex);\n\tlist_for_each_entry_safe(e, safe, &ls->ls_requestqueue, list) {\n\t\tms =  &e->request;\n\n\t\tif (purge_request(ls, ms, e->nodeid)) {\n\t\t\tlist_del(&e->list);\n\t\t\tif (atomic_dec_and_test(&ls->ls_requestqueue_cnt))\n\t\t\t\twake_up(&ls->ls_requestqueue_wait);\n\t\t\tkfree(e);\n\t\t}\n\t}\n\tmutex_unlock(&ls->ls_requestqueue_mutex);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}