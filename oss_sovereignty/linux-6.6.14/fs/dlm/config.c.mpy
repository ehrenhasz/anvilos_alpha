{
  "module_name": "config.c",
  "hash_id": "e696898fe79253e1cf4d32529068248e145bf15a66393671005fec94dd74920a",
  "original_prompt": "Ingested from linux-6.6.14/fs/dlm/config.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/configfs.h>\n#include <linux/slab.h>\n#include <linux/in.h>\n#include <linux/in6.h>\n#include <linux/dlmconstants.h>\n#include <net/ipv6.h>\n#include <net/sock.h>\n\n#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n\n \n\nstatic struct config_group *space_list;\nstatic struct config_group *comm_list;\nstatic struct dlm_comm *local_comm;\nstatic uint32_t dlm_comm_count;\n\nstruct dlm_clusters;\nstruct dlm_cluster;\nstruct dlm_spaces;\nstruct dlm_space;\nstruct dlm_comms;\nstruct dlm_comm;\nstruct dlm_nodes;\nstruct dlm_node;\n\nstatic struct config_group *make_cluster(struct config_group *, const char *);\nstatic void drop_cluster(struct config_group *, struct config_item *);\nstatic void release_cluster(struct config_item *);\nstatic struct config_group *make_space(struct config_group *, const char *);\nstatic void drop_space(struct config_group *, struct config_item *);\nstatic void release_space(struct config_item *);\nstatic struct config_item *make_comm(struct config_group *, const char *);\nstatic void drop_comm(struct config_group *, struct config_item *);\nstatic void release_comm(struct config_item *);\nstatic struct config_item *make_node(struct config_group *, const char *);\nstatic void drop_node(struct config_group *, struct config_item *);\nstatic void release_node(struct config_item *);\n\nstatic struct configfs_attribute *comm_attrs[];\nstatic struct configfs_attribute *node_attrs[];\n\nstruct dlm_cluster {\n\tstruct config_group group;\n\tunsigned int cl_tcp_port;\n\tunsigned int cl_buffer_size;\n\tunsigned int cl_rsbtbl_size;\n\tunsigned int cl_recover_timer;\n\tunsigned int cl_toss_secs;\n\tunsigned int cl_scan_secs;\n\tunsigned int cl_log_debug;\n\tunsigned int cl_log_info;\n\tunsigned int cl_protocol;\n\tunsigned int cl_mark;\n\tunsigned int cl_new_rsb_count;\n\tunsigned int cl_recover_callbacks;\n\tchar cl_cluster_name[DLM_LOCKSPACE_LEN];\n\n\tstruct dlm_spaces *sps;\n\tstruct dlm_comms *cms;\n};\n\nstatic struct dlm_cluster *config_item_to_cluster(struct config_item *i)\n{\n\treturn i ? container_of(to_config_group(i), struct dlm_cluster, group) :\n\t\t   NULL;\n}\n\nenum {\n\tCLUSTER_ATTR_TCP_PORT = 0,\n\tCLUSTER_ATTR_BUFFER_SIZE,\n\tCLUSTER_ATTR_RSBTBL_SIZE,\n\tCLUSTER_ATTR_RECOVER_TIMER,\n\tCLUSTER_ATTR_TOSS_SECS,\n\tCLUSTER_ATTR_SCAN_SECS,\n\tCLUSTER_ATTR_LOG_DEBUG,\n\tCLUSTER_ATTR_LOG_INFO,\n\tCLUSTER_ATTR_PROTOCOL,\n\tCLUSTER_ATTR_MARK,\n\tCLUSTER_ATTR_NEW_RSB_COUNT,\n\tCLUSTER_ATTR_RECOVER_CALLBACKS,\n\tCLUSTER_ATTR_CLUSTER_NAME,\n};\n\nstatic ssize_t cluster_cluster_name_show(struct config_item *item, char *buf)\n{\n\tstruct dlm_cluster *cl = config_item_to_cluster(item);\n\treturn sprintf(buf, \"%s\\n\", cl->cl_cluster_name);\n}\n\nstatic ssize_t cluster_cluster_name_store(struct config_item *item,\n\t\t\t\t\t  const char *buf, size_t len)\n{\n\tstruct dlm_cluster *cl = config_item_to_cluster(item);\n\n\tstrscpy(dlm_config.ci_cluster_name, buf,\n\t\t\t\tsizeof(dlm_config.ci_cluster_name));\n\tstrscpy(cl->cl_cluster_name, buf, sizeof(cl->cl_cluster_name));\n\treturn len;\n}\n\nCONFIGFS_ATTR(cluster_, cluster_name);\n\nstatic ssize_t cluster_set(struct dlm_cluster *cl, unsigned int *cl_field,\n\t\t\t   int *info_field, int (*check_cb)(unsigned int x),\n\t\t\t   const char *buf, size_t len)\n{\n\tunsigned int x;\n\tint rc;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\trc = kstrtouint(buf, 0, &x);\n\tif (rc)\n\t\treturn rc;\n\n\tif (check_cb) {\n\t\trc = check_cb(x);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\t*cl_field = x;\n\t*info_field = x;\n\n\treturn len;\n}\n\n#define CLUSTER_ATTR(name, check_cb)                                          \\\nstatic ssize_t cluster_##name##_store(struct config_item *item, \\\n\t\tconst char *buf, size_t len) \\\n{                                                                             \\\n\tstruct dlm_cluster *cl = config_item_to_cluster(item);\t\t      \\\n\treturn cluster_set(cl, &cl->cl_##name, &dlm_config.ci_##name,         \\\n\t\t\t   check_cb, buf, len);                               \\\n}                                                                             \\\nstatic ssize_t cluster_##name##_show(struct config_item *item, char *buf)     \\\n{                                                                             \\\n\tstruct dlm_cluster *cl = config_item_to_cluster(item);\t\t      \\\n\treturn snprintf(buf, PAGE_SIZE, \"%u\\n\", cl->cl_##name);               \\\n}                                                                             \\\nCONFIGFS_ATTR(cluster_, name);\n\nstatic int dlm_check_protocol_and_dlm_running(unsigned int x)\n{\n\tswitch (x) {\n\tcase 0:\n\t\t \n\t\tbreak;\n\tcase 1:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (dlm_lowcomms_is_running())\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\n\nstatic int dlm_check_zero_and_dlm_running(unsigned int x)\n{\n\tif (!x)\n\t\treturn -EINVAL;\n\n\tif (dlm_lowcomms_is_running())\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\n\nstatic int dlm_check_zero(unsigned int x)\n{\n\tif (!x)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int dlm_check_buffer_size(unsigned int x)\n{\n\tif (x < DLM_MAX_SOCKET_BUFSIZE)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nCLUSTER_ATTR(tcp_port, dlm_check_zero_and_dlm_running);\nCLUSTER_ATTR(buffer_size, dlm_check_buffer_size);\nCLUSTER_ATTR(rsbtbl_size, dlm_check_zero);\nCLUSTER_ATTR(recover_timer, dlm_check_zero);\nCLUSTER_ATTR(toss_secs, dlm_check_zero);\nCLUSTER_ATTR(scan_secs, dlm_check_zero);\nCLUSTER_ATTR(log_debug, NULL);\nCLUSTER_ATTR(log_info, NULL);\nCLUSTER_ATTR(protocol, dlm_check_protocol_and_dlm_running);\nCLUSTER_ATTR(mark, NULL);\nCLUSTER_ATTR(new_rsb_count, NULL);\nCLUSTER_ATTR(recover_callbacks, NULL);\n\nstatic struct configfs_attribute *cluster_attrs[] = {\n\t[CLUSTER_ATTR_TCP_PORT] = &cluster_attr_tcp_port,\n\t[CLUSTER_ATTR_BUFFER_SIZE] = &cluster_attr_buffer_size,\n\t[CLUSTER_ATTR_RSBTBL_SIZE] = &cluster_attr_rsbtbl_size,\n\t[CLUSTER_ATTR_RECOVER_TIMER] = &cluster_attr_recover_timer,\n\t[CLUSTER_ATTR_TOSS_SECS] = &cluster_attr_toss_secs,\n\t[CLUSTER_ATTR_SCAN_SECS] = &cluster_attr_scan_secs,\n\t[CLUSTER_ATTR_LOG_DEBUG] = &cluster_attr_log_debug,\n\t[CLUSTER_ATTR_LOG_INFO] = &cluster_attr_log_info,\n\t[CLUSTER_ATTR_PROTOCOL] = &cluster_attr_protocol,\n\t[CLUSTER_ATTR_MARK] = &cluster_attr_mark,\n\t[CLUSTER_ATTR_NEW_RSB_COUNT] = &cluster_attr_new_rsb_count,\n\t[CLUSTER_ATTR_RECOVER_CALLBACKS] = &cluster_attr_recover_callbacks,\n\t[CLUSTER_ATTR_CLUSTER_NAME] = &cluster_attr_cluster_name,\n\tNULL,\n};\n\nenum {\n\tCOMM_ATTR_NODEID = 0,\n\tCOMM_ATTR_LOCAL,\n\tCOMM_ATTR_ADDR,\n\tCOMM_ATTR_ADDR_LIST,\n\tCOMM_ATTR_MARK,\n};\n\nenum {\n\tNODE_ATTR_NODEID = 0,\n\tNODE_ATTR_WEIGHT,\n};\n\nstruct dlm_clusters {\n\tstruct configfs_subsystem subsys;\n};\n\nstruct dlm_spaces {\n\tstruct config_group ss_group;\n};\n\nstruct dlm_space {\n\tstruct config_group group;\n\tstruct list_head members;\n\tstruct mutex members_lock;\n\tint members_count;\n\tstruct dlm_nodes *nds;\n};\n\nstruct dlm_comms {\n\tstruct config_group cs_group;\n};\n\nstruct dlm_comm {\n\tstruct config_item item;\n\tint seq;\n\tint nodeid;\n\tint local;\n\tint addr_count;\n\tunsigned int mark;\n\tstruct sockaddr_storage *addr[DLM_MAX_ADDR_COUNT];\n};\n\nstruct dlm_nodes {\n\tstruct config_group ns_group;\n};\n\nstruct dlm_node {\n\tstruct config_item item;\n\tstruct list_head list;  \n\tint nodeid;\n\tint weight;\n\tint new;\n\tint comm_seq;  \n};\n\nstatic struct configfs_group_operations clusters_ops = {\n\t.make_group = make_cluster,\n\t.drop_item = drop_cluster,\n};\n\nstatic struct configfs_item_operations cluster_ops = {\n\t.release = release_cluster,\n};\n\nstatic struct configfs_group_operations spaces_ops = {\n\t.make_group = make_space,\n\t.drop_item = drop_space,\n};\n\nstatic struct configfs_item_operations space_ops = {\n\t.release = release_space,\n};\n\nstatic struct configfs_group_operations comms_ops = {\n\t.make_item = make_comm,\n\t.drop_item = drop_comm,\n};\n\nstatic struct configfs_item_operations comm_ops = {\n\t.release = release_comm,\n};\n\nstatic struct configfs_group_operations nodes_ops = {\n\t.make_item = make_node,\n\t.drop_item = drop_node,\n};\n\nstatic struct configfs_item_operations node_ops = {\n\t.release = release_node,\n};\n\nstatic const struct config_item_type clusters_type = {\n\t.ct_group_ops = &clusters_ops,\n\t.ct_owner = THIS_MODULE,\n};\n\nstatic const struct config_item_type cluster_type = {\n\t.ct_item_ops = &cluster_ops,\n\t.ct_attrs = cluster_attrs,\n\t.ct_owner = THIS_MODULE,\n};\n\nstatic const struct config_item_type spaces_type = {\n\t.ct_group_ops = &spaces_ops,\n\t.ct_owner = THIS_MODULE,\n};\n\nstatic const struct config_item_type space_type = {\n\t.ct_item_ops = &space_ops,\n\t.ct_owner = THIS_MODULE,\n};\n\nstatic const struct config_item_type comms_type = {\n\t.ct_group_ops = &comms_ops,\n\t.ct_owner = THIS_MODULE,\n};\n\nstatic const struct config_item_type comm_type = {\n\t.ct_item_ops = &comm_ops,\n\t.ct_attrs = comm_attrs,\n\t.ct_owner = THIS_MODULE,\n};\n\nstatic const struct config_item_type nodes_type = {\n\t.ct_group_ops = &nodes_ops,\n\t.ct_owner = THIS_MODULE,\n};\n\nstatic const struct config_item_type node_type = {\n\t.ct_item_ops = &node_ops,\n\t.ct_attrs = node_attrs,\n\t.ct_owner = THIS_MODULE,\n};\n\nstatic struct dlm_space *config_item_to_space(struct config_item *i)\n{\n\treturn i ? container_of(to_config_group(i), struct dlm_space, group) :\n\t\t   NULL;\n}\n\nstatic struct dlm_comm *config_item_to_comm(struct config_item *i)\n{\n\treturn i ? container_of(i, struct dlm_comm, item) : NULL;\n}\n\nstatic struct dlm_node *config_item_to_node(struct config_item *i)\n{\n\treturn i ? container_of(i, struct dlm_node, item) : NULL;\n}\n\nstatic struct config_group *make_cluster(struct config_group *g,\n\t\t\t\t\t const char *name)\n{\n\tstruct dlm_cluster *cl = NULL;\n\tstruct dlm_spaces *sps = NULL;\n\tstruct dlm_comms *cms = NULL;\n\n\tcl = kzalloc(sizeof(struct dlm_cluster), GFP_NOFS);\n\tsps = kzalloc(sizeof(struct dlm_spaces), GFP_NOFS);\n\tcms = kzalloc(sizeof(struct dlm_comms), GFP_NOFS);\n\n\tif (!cl || !sps || !cms)\n\t\tgoto fail;\n\n\tcl->sps = sps;\n\tcl->cms = cms;\n\n\tconfig_group_init_type_name(&cl->group, name, &cluster_type);\n\tconfig_group_init_type_name(&sps->ss_group, \"spaces\", &spaces_type);\n\tconfig_group_init_type_name(&cms->cs_group, \"comms\", &comms_type);\n\n\tconfigfs_add_default_group(&sps->ss_group, &cl->group);\n\tconfigfs_add_default_group(&cms->cs_group, &cl->group);\n\n\tcl->cl_tcp_port = dlm_config.ci_tcp_port;\n\tcl->cl_buffer_size = dlm_config.ci_buffer_size;\n\tcl->cl_rsbtbl_size = dlm_config.ci_rsbtbl_size;\n\tcl->cl_recover_timer = dlm_config.ci_recover_timer;\n\tcl->cl_toss_secs = dlm_config.ci_toss_secs;\n\tcl->cl_scan_secs = dlm_config.ci_scan_secs;\n\tcl->cl_log_debug = dlm_config.ci_log_debug;\n\tcl->cl_log_info = dlm_config.ci_log_info;\n\tcl->cl_protocol = dlm_config.ci_protocol;\n\tcl->cl_new_rsb_count = dlm_config.ci_new_rsb_count;\n\tcl->cl_recover_callbacks = dlm_config.ci_recover_callbacks;\n\tmemcpy(cl->cl_cluster_name, dlm_config.ci_cluster_name,\n\t       DLM_LOCKSPACE_LEN);\n\n\tspace_list = &sps->ss_group;\n\tcomm_list = &cms->cs_group;\n\treturn &cl->group;\n\n fail:\n\tkfree(cl);\n\tkfree(sps);\n\tkfree(cms);\n\treturn ERR_PTR(-ENOMEM);\n}\n\nstatic void drop_cluster(struct config_group *g, struct config_item *i)\n{\n\tstruct dlm_cluster *cl = config_item_to_cluster(i);\n\n\tconfigfs_remove_default_groups(&cl->group);\n\n\tspace_list = NULL;\n\tcomm_list = NULL;\n\n\tconfig_item_put(i);\n}\n\nstatic void release_cluster(struct config_item *i)\n{\n\tstruct dlm_cluster *cl = config_item_to_cluster(i);\n\n\tkfree(cl->sps);\n\tkfree(cl->cms);\n\tkfree(cl);\n}\n\nstatic struct config_group *make_space(struct config_group *g, const char *name)\n{\n\tstruct dlm_space *sp = NULL;\n\tstruct dlm_nodes *nds = NULL;\n\n\tsp = kzalloc(sizeof(struct dlm_space), GFP_NOFS);\n\tnds = kzalloc(sizeof(struct dlm_nodes), GFP_NOFS);\n\n\tif (!sp || !nds)\n\t\tgoto fail;\n\n\tconfig_group_init_type_name(&sp->group, name, &space_type);\n\n\tconfig_group_init_type_name(&nds->ns_group, \"nodes\", &nodes_type);\n\tconfigfs_add_default_group(&nds->ns_group, &sp->group);\n\n\tINIT_LIST_HEAD(&sp->members);\n\tmutex_init(&sp->members_lock);\n\tsp->members_count = 0;\n\tsp->nds = nds;\n\treturn &sp->group;\n\n fail:\n\tkfree(sp);\n\tkfree(nds);\n\treturn ERR_PTR(-ENOMEM);\n}\n\nstatic void drop_space(struct config_group *g, struct config_item *i)\n{\n\tstruct dlm_space *sp = config_item_to_space(i);\n\n\t \n\n\tconfigfs_remove_default_groups(&sp->group);\n\tconfig_item_put(i);\n}\n\nstatic void release_space(struct config_item *i)\n{\n\tstruct dlm_space *sp = config_item_to_space(i);\n\tkfree(sp->nds);\n\tkfree(sp);\n}\n\nstatic struct config_item *make_comm(struct config_group *g, const char *name)\n{\n\tstruct dlm_comm *cm;\n\n\tcm = kzalloc(sizeof(struct dlm_comm), GFP_NOFS);\n\tif (!cm)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tconfig_item_init_type_name(&cm->item, name, &comm_type);\n\n\tcm->seq = dlm_comm_count++;\n\tif (!cm->seq)\n\t\tcm->seq = dlm_comm_count++;\n\n\tcm->nodeid = -1;\n\tcm->local = 0;\n\tcm->addr_count = 0;\n\tcm->mark = 0;\n\treturn &cm->item;\n}\n\nstatic void drop_comm(struct config_group *g, struct config_item *i)\n{\n\tstruct dlm_comm *cm = config_item_to_comm(i);\n\tif (local_comm == cm)\n\t\tlocal_comm = NULL;\n\tdlm_midcomms_close(cm->nodeid);\n\twhile (cm->addr_count--)\n\t\tkfree(cm->addr[cm->addr_count]);\n\tconfig_item_put(i);\n}\n\nstatic void release_comm(struct config_item *i)\n{\n\tstruct dlm_comm *cm = config_item_to_comm(i);\n\tkfree(cm);\n}\n\nstatic struct config_item *make_node(struct config_group *g, const char *name)\n{\n\tstruct dlm_space *sp = config_item_to_space(g->cg_item.ci_parent);\n\tstruct dlm_node *nd;\n\n\tnd = kzalloc(sizeof(struct dlm_node), GFP_NOFS);\n\tif (!nd)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tconfig_item_init_type_name(&nd->item, name, &node_type);\n\tnd->nodeid = -1;\n\tnd->weight = 1;   \n\tnd->new = 1;      \n\n\tmutex_lock(&sp->members_lock);\n\tlist_add(&nd->list, &sp->members);\n\tsp->members_count++;\n\tmutex_unlock(&sp->members_lock);\n\n\treturn &nd->item;\n}\n\nstatic void drop_node(struct config_group *g, struct config_item *i)\n{\n\tstruct dlm_space *sp = config_item_to_space(g->cg_item.ci_parent);\n\tstruct dlm_node *nd = config_item_to_node(i);\n\n\tmutex_lock(&sp->members_lock);\n\tlist_del(&nd->list);\n\tsp->members_count--;\n\tmutex_unlock(&sp->members_lock);\n\n\tconfig_item_put(i);\n}\n\nstatic void release_node(struct config_item *i)\n{\n\tstruct dlm_node *nd = config_item_to_node(i);\n\tkfree(nd);\n}\n\nstatic struct dlm_clusters clusters_root = {\n\t.subsys = {\n\t\t.su_group = {\n\t\t\t.cg_item = {\n\t\t\t\t.ci_namebuf = \"dlm\",\n\t\t\t\t.ci_type = &clusters_type,\n\t\t\t},\n\t\t},\n\t},\n};\n\nint __init dlm_config_init(void)\n{\n\tconfig_group_init(&clusters_root.subsys.su_group);\n\tmutex_init(&clusters_root.subsys.su_mutex);\n\treturn configfs_register_subsystem(&clusters_root.subsys);\n}\n\nvoid dlm_config_exit(void)\n{\n\tconfigfs_unregister_subsystem(&clusters_root.subsys);\n}\n\n \n\nstatic ssize_t comm_nodeid_show(struct config_item *item, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", config_item_to_comm(item)->nodeid);\n}\n\nstatic ssize_t comm_nodeid_store(struct config_item *item, const char *buf,\n\t\t\t\t size_t len)\n{\n\tint rc = kstrtoint(buf, 0, &config_item_to_comm(item)->nodeid);\n\n\tif (rc)\n\t\treturn rc;\n\treturn len;\n}\n\nstatic ssize_t comm_local_show(struct config_item *item, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", config_item_to_comm(item)->local);\n}\n\nstatic ssize_t comm_local_store(struct config_item *item, const char *buf,\n\t\t\t\tsize_t len)\n{\n\tstruct dlm_comm *cm = config_item_to_comm(item);\n\tint rc = kstrtoint(buf, 0, &cm->local);\n\n\tif (rc)\n\t\treturn rc;\n\tif (cm->local && !local_comm)\n\t\tlocal_comm = cm;\n\treturn len;\n}\n\nstatic ssize_t comm_addr_store(struct config_item *item, const char *buf,\n\t\tsize_t len)\n{\n\tstruct dlm_comm *cm = config_item_to_comm(item);\n\tstruct sockaddr_storage *addr;\n\tint rv;\n\n\tif (len != sizeof(struct sockaddr_storage))\n\t\treturn -EINVAL;\n\n\tif (cm->addr_count >= DLM_MAX_ADDR_COUNT)\n\t\treturn -ENOSPC;\n\n\taddr = kzalloc(sizeof(*addr), GFP_NOFS);\n\tif (!addr)\n\t\treturn -ENOMEM;\n\n\tmemcpy(addr, buf, len);\n\n\trv = dlm_midcomms_addr(cm->nodeid, addr, len);\n\tif (rv) {\n\t\tkfree(addr);\n\t\treturn rv;\n\t}\n\n\tcm->addr[cm->addr_count++] = addr;\n\treturn len;\n}\n\nstatic ssize_t comm_addr_list_show(struct config_item *item, char *buf)\n{\n\tstruct dlm_comm *cm = config_item_to_comm(item);\n\tssize_t s;\n\tssize_t allowance;\n\tint i;\n\tstruct sockaddr_storage *addr;\n\tstruct sockaddr_in *addr_in;\n\tstruct sockaddr_in6 *addr_in6;\n\t\n\t \n\tchar buf0[sizeof(\"AF_INET6\txxxx:xxxx:xxxx:xxxx:xxxx:xxxx:255.255.255.255\\n\")];\n\t\n\n\t \n\tallowance = 4096;\n\tbuf[0] = '\\0';\n\n\tfor (i = 0; i < cm->addr_count; i++) {\n\t\taddr = cm->addr[i];\n\n\t\tswitch(addr->ss_family) {\n\t\tcase AF_INET:\n\t\t\taddr_in = (struct sockaddr_in *)addr;\n\t\t\ts = sprintf(buf0, \"AF_INET\t%pI4\\n\", &addr_in->sin_addr.s_addr);\n\t\t\tbreak;\n\t\tcase AF_INET6:\n\t\t\taddr_in6 = (struct sockaddr_in6 *)addr;\n\t\t\ts = sprintf(buf0, \"AF_INET6\t%pI6\\n\", &addr_in6->sin6_addr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ts = sprintf(buf0, \"%s\\n\", \"<UNKNOWN>\");\n\t\t\tbreak;\n\t\t}\n\t\tallowance -= s;\n\t\tif (allowance >= 0)\n\t\t\tstrcat(buf, buf0);\n\t\telse {\n\t\t\tallowance += s;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 4096 - allowance;\n}\n\nstatic ssize_t comm_mark_show(struct config_item *item, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", config_item_to_comm(item)->mark);\n}\n\nstatic ssize_t comm_mark_store(struct config_item *item, const char *buf,\n\t\t\t       size_t len)\n{\n\tstruct dlm_comm *comm;\n\tunsigned int mark;\n\tint rc;\n\n\trc = kstrtouint(buf, 0, &mark);\n\tif (rc)\n\t\treturn rc;\n\n\tif (mark == 0)\n\t\tmark = dlm_config.ci_mark;\n\n\tcomm = config_item_to_comm(item);\n\trc = dlm_lowcomms_nodes_set_mark(comm->nodeid, mark);\n\tif (rc)\n\t\treturn rc;\n\n\tcomm->mark = mark;\n\treturn len;\n}\n\nCONFIGFS_ATTR(comm_, nodeid);\nCONFIGFS_ATTR(comm_, local);\nCONFIGFS_ATTR(comm_, mark);\nCONFIGFS_ATTR_WO(comm_, addr);\nCONFIGFS_ATTR_RO(comm_, addr_list);\n\nstatic struct configfs_attribute *comm_attrs[] = {\n\t[COMM_ATTR_NODEID] = &comm_attr_nodeid,\n\t[COMM_ATTR_LOCAL] = &comm_attr_local,\n\t[COMM_ATTR_ADDR] = &comm_attr_addr,\n\t[COMM_ATTR_ADDR_LIST] = &comm_attr_addr_list,\n\t[COMM_ATTR_MARK] = &comm_attr_mark,\n\tNULL,\n};\n\nstatic ssize_t node_nodeid_show(struct config_item *item, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", config_item_to_node(item)->nodeid);\n}\n\nstatic ssize_t node_nodeid_store(struct config_item *item, const char *buf,\n\t\t\t\t size_t len)\n{\n\tstruct dlm_node *nd = config_item_to_node(item);\n\tuint32_t seq = 0;\n\tint rc = kstrtoint(buf, 0, &nd->nodeid);\n\n\tif (rc)\n\t\treturn rc;\n\tdlm_comm_seq(nd->nodeid, &seq);\n\tnd->comm_seq = seq;\n\treturn len;\n}\n\nstatic ssize_t node_weight_show(struct config_item *item, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", config_item_to_node(item)->weight);\n}\n\nstatic ssize_t node_weight_store(struct config_item *item, const char *buf,\n\t\t\t\t size_t len)\n{\n\tint rc = kstrtoint(buf, 0, &config_item_to_node(item)->weight);\n\n\tif (rc)\n\t\treturn rc;\n\treturn len;\n}\n\nCONFIGFS_ATTR(node_, nodeid);\nCONFIGFS_ATTR(node_, weight);\n\nstatic struct configfs_attribute *node_attrs[] = {\n\t[NODE_ATTR_NODEID] = &node_attr_nodeid,\n\t[NODE_ATTR_WEIGHT] = &node_attr_weight,\n\tNULL,\n};\n\n \n\nstatic struct dlm_space *get_space(char *name)\n{\n\tstruct config_item *i;\n\n\tif (!space_list)\n\t\treturn NULL;\n\n\tmutex_lock(&space_list->cg_subsys->su_mutex);\n\ti = config_group_find_item(space_list, name);\n\tmutex_unlock(&space_list->cg_subsys->su_mutex);\n\n\treturn config_item_to_space(i);\n}\n\nstatic void put_space(struct dlm_space *sp)\n{\n\tconfig_item_put(&sp->group.cg_item);\n}\n\nstatic struct dlm_comm *get_comm(int nodeid)\n{\n\tstruct config_item *i;\n\tstruct dlm_comm *cm = NULL;\n\tint found = 0;\n\n\tif (!comm_list)\n\t\treturn NULL;\n\n\tmutex_lock(&clusters_root.subsys.su_mutex);\n\n\tlist_for_each_entry(i, &comm_list->cg_children, ci_entry) {\n\t\tcm = config_item_to_comm(i);\n\n\t\tif (cm->nodeid != nodeid)\n\t\t\tcontinue;\n\t\tfound = 1;\n\t\tconfig_item_get(i);\n\t\tbreak;\n\t}\n\tmutex_unlock(&clusters_root.subsys.su_mutex);\n\n\tif (!found)\n\t\tcm = NULL;\n\treturn cm;\n}\n\nstatic void put_comm(struct dlm_comm *cm)\n{\n\tconfig_item_put(&cm->item);\n}\n\n \nint dlm_config_nodes(char *lsname, struct dlm_config_node **nodes_out,\n\t\t     int *count_out)\n{\n\tstruct dlm_space *sp;\n\tstruct dlm_node *nd;\n\tstruct dlm_config_node *nodes, *node;\n\tint rv, count;\n\n\tsp = get_space(lsname);\n\tif (!sp)\n\t\treturn -EEXIST;\n\n\tmutex_lock(&sp->members_lock);\n\tif (!sp->members_count) {\n\t\trv = -EINVAL;\n\t\tprintk(KERN_ERR \"dlm: zero members_count\\n\");\n\t\tgoto out;\n\t}\n\n\tcount = sp->members_count;\n\n\tnodes = kcalloc(count, sizeof(struct dlm_config_node), GFP_NOFS);\n\tif (!nodes) {\n\t\trv = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tnode = nodes;\n\tlist_for_each_entry(nd, &sp->members, list) {\n\t\tnode->nodeid = nd->nodeid;\n\t\tnode->weight = nd->weight;\n\t\tnode->new = nd->new;\n\t\tnode->comm_seq = nd->comm_seq;\n\t\tnode++;\n\n\t\tnd->new = 0;\n\t}\n\n\t*count_out = count;\n\t*nodes_out = nodes;\n\trv = 0;\n out:\n\tmutex_unlock(&sp->members_lock);\n\tput_space(sp);\n\treturn rv;\n}\n\nint dlm_comm_seq(int nodeid, uint32_t *seq)\n{\n\tstruct dlm_comm *cm = get_comm(nodeid);\n\tif (!cm)\n\t\treturn -EEXIST;\n\t*seq = cm->seq;\n\tput_comm(cm);\n\treturn 0;\n}\n\nint dlm_our_nodeid(void)\n{\n\treturn local_comm ? local_comm->nodeid : 0;\n}\n\n \nint dlm_our_addr(struct sockaddr_storage *addr, int num)\n{\n\tif (!local_comm)\n\t\treturn -1;\n\tif (num + 1 > local_comm->addr_count)\n\t\treturn -1;\n\tmemcpy(addr, local_comm->addr[num], sizeof(*addr));\n\treturn 0;\n}\n\n \n#define DEFAULT_TCP_PORT       21064\n#define DEFAULT_RSBTBL_SIZE     1024\n#define DEFAULT_RECOVER_TIMER      5\n#define DEFAULT_TOSS_SECS         10\n#define DEFAULT_SCAN_SECS          5\n#define DEFAULT_LOG_DEBUG          0\n#define DEFAULT_LOG_INFO           1\n#define DEFAULT_PROTOCOL           DLM_PROTO_TCP\n#define DEFAULT_MARK               0\n#define DEFAULT_NEW_RSB_COUNT    128\n#define DEFAULT_RECOVER_CALLBACKS  0\n#define DEFAULT_CLUSTER_NAME      \"\"\n\nstruct dlm_config_info dlm_config = {\n\t.ci_tcp_port = DEFAULT_TCP_PORT,\n\t.ci_buffer_size = DLM_MAX_SOCKET_BUFSIZE,\n\t.ci_rsbtbl_size = DEFAULT_RSBTBL_SIZE,\n\t.ci_recover_timer = DEFAULT_RECOVER_TIMER,\n\t.ci_toss_secs = DEFAULT_TOSS_SECS,\n\t.ci_scan_secs = DEFAULT_SCAN_SECS,\n\t.ci_log_debug = DEFAULT_LOG_DEBUG,\n\t.ci_log_info = DEFAULT_LOG_INFO,\n\t.ci_protocol = DEFAULT_PROTOCOL,\n\t.ci_mark = DEFAULT_MARK,\n\t.ci_new_rsb_count = DEFAULT_NEW_RSB_COUNT,\n\t.ci_recover_callbacks = DEFAULT_RECOVER_CALLBACKS,\n\t.ci_cluster_name = DEFAULT_CLUSTER_NAME\n};\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}