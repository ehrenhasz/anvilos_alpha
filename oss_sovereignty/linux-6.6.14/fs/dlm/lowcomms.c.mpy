{
  "module_name": "lowcomms.c",
  "hash_id": "c2165f70313fc7f9465a3b0d3229beb1c811906f5b5c852f8c532c5a9a140a7a",
  "original_prompt": "Ingested from linux-6.6.14/fs/dlm/lowcomms.c",
  "human_readable_source": "\n \n\n \n\n#include <asm/ioctls.h>\n#include <net/sock.h>\n#include <net/tcp.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/sctp.h>\n#include <linux/slab.h>\n#include <net/sctp/sctp.h>\n#include <net/ipv6.h>\n\n#include <trace/events/dlm.h>\n#include <trace/events/sock.h>\n\n#include \"dlm_internal.h\"\n#include \"lowcomms.h\"\n#include \"midcomms.h\"\n#include \"memory.h\"\n#include \"config.h\"\n\n#define DLM_SHUTDOWN_WAIT_TIMEOUT msecs_to_jiffies(5000)\n#define NEEDED_RMEM (4*1024*1024)\n\nstruct connection {\n\tstruct socket *sock;\t \n\tuint32_t nodeid;\t \n\t \n\tstruct rw_semaphore sock_lock;\n\tunsigned long flags;\n#define CF_APP_LIMITED 0\n#define CF_RECV_PENDING 1\n#define CF_SEND_PENDING 2\n#define CF_RECV_INTR 3\n#define CF_IO_STOP 4\n#define CF_IS_OTHERCON 5\n\tstruct list_head writequeue;   \n\tspinlock_t writequeue_lock;\n\tint retries;\n\tstruct hlist_node list;\n\t \n\tstruct connection *othercon;\n\tstruct work_struct rwork;  \n\tstruct work_struct swork;  \n\twait_queue_head_t shutdown_wait;\n\tunsigned char rx_leftover_buf[DLM_MAX_SOCKET_BUFSIZE];\n\tint rx_leftover;\n\tint mark;\n\tint addr_count;\n\tint curr_addr_index;\n\tstruct sockaddr_storage addr[DLM_MAX_ADDR_COUNT];\n\tspinlock_t addrs_lock;\n\tstruct rcu_head rcu;\n};\n#define sock2con(x) ((struct connection *)(x)->sk_user_data)\n\nstruct listen_connection {\n\tstruct socket *sock;\n\tstruct work_struct rwork;\n};\n\n#define DLM_WQ_REMAIN_BYTES(e) (PAGE_SIZE - e->end)\n#define DLM_WQ_LENGTH_BYTES(e) (e->end - e->offset)\n\n \nstruct writequeue_entry {\n\tstruct list_head list;\n\tstruct page *page;\n\tint offset;\n\tint len;\n\tint end;\n\tint users;\n\tbool dirty;\n\tstruct connection *con;\n\tstruct list_head msgs;\n\tstruct kref ref;\n};\n\nstruct dlm_msg {\n\tstruct writequeue_entry *entry;\n\tstruct dlm_msg *orig_msg;\n\tbool retransmit;\n\tvoid *ppc;\n\tint len;\n\tint idx;  \n\n\tstruct list_head list;\n\tstruct kref ref;\n};\n\nstruct processqueue_entry {\n\tunsigned char *buf;\n\tint nodeid;\n\tint buflen;\n\n\tstruct list_head list;\n};\n\nstruct dlm_proto_ops {\n\tbool try_new_addr;\n\tconst char *name;\n\tint proto;\n\n\tint (*connect)(struct connection *con, struct socket *sock,\n\t\t       struct sockaddr *addr, int addr_len);\n\tvoid (*sockopts)(struct socket *sock);\n\tint (*bind)(struct socket *sock);\n\tint (*listen_validate)(void);\n\tvoid (*listen_sockopts)(struct socket *sock);\n\tint (*listen_bind)(struct socket *sock);\n};\n\nstatic struct listen_sock_callbacks {\n\tvoid (*sk_error_report)(struct sock *);\n\tvoid (*sk_data_ready)(struct sock *);\n\tvoid (*sk_state_change)(struct sock *);\n\tvoid (*sk_write_space)(struct sock *);\n} listen_sock;\n\nstatic struct listen_connection listen_con;\nstatic struct sockaddr_storage dlm_local_addr[DLM_MAX_ADDR_COUNT];\nstatic int dlm_local_count;\n\n \nstatic struct workqueue_struct *io_workqueue;\nstatic struct workqueue_struct *process_workqueue;\n\nstatic struct hlist_head connection_hash[CONN_HASH_SIZE];\nstatic DEFINE_SPINLOCK(connections_lock);\nDEFINE_STATIC_SRCU(connections_srcu);\n\nstatic const struct dlm_proto_ops *dlm_proto_ops;\n\n#define DLM_IO_SUCCESS 0\n#define DLM_IO_END 1\n#define DLM_IO_EOF 2\n#define DLM_IO_RESCHED 3\n\nstatic void process_recv_sockets(struct work_struct *work);\nstatic void process_send_sockets(struct work_struct *work);\nstatic void process_dlm_messages(struct work_struct *work);\n\nstatic DECLARE_WORK(process_work, process_dlm_messages);\nstatic DEFINE_SPINLOCK(processqueue_lock);\nstatic bool process_dlm_messages_pending;\nstatic LIST_HEAD(processqueue);\n\nbool dlm_lowcomms_is_running(void)\n{\n\treturn !!listen_con.sock;\n}\n\nstatic void lowcomms_queue_swork(struct connection *con)\n{\n\tassert_spin_locked(&con->writequeue_lock);\n\n\tif (!test_bit(CF_IO_STOP, &con->flags) &&\n\t    !test_bit(CF_APP_LIMITED, &con->flags) &&\n\t    !test_and_set_bit(CF_SEND_PENDING, &con->flags))\n\t\tqueue_work(io_workqueue, &con->swork);\n}\n\nstatic void lowcomms_queue_rwork(struct connection *con)\n{\n#ifdef CONFIG_LOCKDEP\n\tWARN_ON_ONCE(!lockdep_sock_is_held(con->sock->sk));\n#endif\n\n\tif (!test_bit(CF_IO_STOP, &con->flags) &&\n\t    !test_and_set_bit(CF_RECV_PENDING, &con->flags))\n\t\tqueue_work(io_workqueue, &con->rwork);\n}\n\nstatic void writequeue_entry_ctor(void *data)\n{\n\tstruct writequeue_entry *entry = data;\n\n\tINIT_LIST_HEAD(&entry->msgs);\n}\n\nstruct kmem_cache *dlm_lowcomms_writequeue_cache_create(void)\n{\n\treturn kmem_cache_create(\"dlm_writequeue\", sizeof(struct writequeue_entry),\n\t\t\t\t 0, 0, writequeue_entry_ctor);\n}\n\nstruct kmem_cache *dlm_lowcomms_msg_cache_create(void)\n{\n\treturn kmem_cache_create(\"dlm_msg\", sizeof(struct dlm_msg), 0, 0, NULL);\n}\n\n \nstatic struct writequeue_entry *con_next_wq(struct connection *con)\n{\n\tstruct writequeue_entry *e;\n\n\te = list_first_entry_or_null(&con->writequeue, struct writequeue_entry,\n\t\t\t\t     list);\n\t \n\tif (!e || e->users || e->len == 0)\n\t\treturn NULL;\n\n\treturn e;\n}\n\nstatic struct connection *__find_con(int nodeid, int r)\n{\n\tstruct connection *con;\n\n\thlist_for_each_entry_rcu(con, &connection_hash[r], list) {\n\t\tif (con->nodeid == nodeid)\n\t\t\treturn con;\n\t}\n\n\treturn NULL;\n}\n\nstatic void dlm_con_init(struct connection *con, int nodeid)\n{\n\tcon->nodeid = nodeid;\n\tinit_rwsem(&con->sock_lock);\n\tINIT_LIST_HEAD(&con->writequeue);\n\tspin_lock_init(&con->writequeue_lock);\n\tINIT_WORK(&con->swork, process_send_sockets);\n\tINIT_WORK(&con->rwork, process_recv_sockets);\n\tspin_lock_init(&con->addrs_lock);\n\tinit_waitqueue_head(&con->shutdown_wait);\n}\n\n \nstatic struct connection *nodeid2con(int nodeid, gfp_t alloc)\n{\n\tstruct connection *con, *tmp;\n\tint r;\n\n\tr = nodeid_hash(nodeid);\n\tcon = __find_con(nodeid, r);\n\tif (con || !alloc)\n\t\treturn con;\n\n\tcon = kzalloc(sizeof(*con), alloc);\n\tif (!con)\n\t\treturn NULL;\n\n\tdlm_con_init(con, nodeid);\n\n\tspin_lock(&connections_lock);\n\t \n\ttmp = __find_con(nodeid, r);\n\tif (tmp) {\n\t\tspin_unlock(&connections_lock);\n\t\tkfree(con);\n\t\treturn tmp;\n\t}\n\n\thlist_add_head_rcu(&con->list, &connection_hash[r]);\n\tspin_unlock(&connections_lock);\n\n\treturn con;\n}\n\nstatic int addr_compare(const struct sockaddr_storage *x,\n\t\t\tconst struct sockaddr_storage *y)\n{\n\tswitch (x->ss_family) {\n\tcase AF_INET: {\n\t\tstruct sockaddr_in *sinx = (struct sockaddr_in *)x;\n\t\tstruct sockaddr_in *siny = (struct sockaddr_in *)y;\n\t\tif (sinx->sin_addr.s_addr != siny->sin_addr.s_addr)\n\t\t\treturn 0;\n\t\tif (sinx->sin_port != siny->sin_port)\n\t\t\treturn 0;\n\t\tbreak;\n\t}\n\tcase AF_INET6: {\n\t\tstruct sockaddr_in6 *sinx = (struct sockaddr_in6 *)x;\n\t\tstruct sockaddr_in6 *siny = (struct sockaddr_in6 *)y;\n\t\tif (!ipv6_addr_equal(&sinx->sin6_addr, &siny->sin6_addr))\n\t\t\treturn 0;\n\t\tif (sinx->sin6_port != siny->sin6_port)\n\t\t\treturn 0;\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int nodeid_to_addr(int nodeid, struct sockaddr_storage *sas_out,\n\t\t\t  struct sockaddr *sa_out, bool try_new_addr,\n\t\t\t  unsigned int *mark)\n{\n\tstruct sockaddr_storage sas;\n\tstruct connection *con;\n\tint idx;\n\n\tif (!dlm_local_count)\n\t\treturn -1;\n\n\tidx = srcu_read_lock(&connections_srcu);\n\tcon = nodeid2con(nodeid, 0);\n\tif (!con) {\n\t\tsrcu_read_unlock(&connections_srcu, idx);\n\t\treturn -ENOENT;\n\t}\n\n\tspin_lock(&con->addrs_lock);\n\tif (!con->addr_count) {\n\t\tspin_unlock(&con->addrs_lock);\n\t\tsrcu_read_unlock(&connections_srcu, idx);\n\t\treturn -ENOENT;\n\t}\n\n\tmemcpy(&sas, &con->addr[con->curr_addr_index],\n\t       sizeof(struct sockaddr_storage));\n\n\tif (try_new_addr) {\n\t\tcon->curr_addr_index++;\n\t\tif (con->curr_addr_index == con->addr_count)\n\t\t\tcon->curr_addr_index = 0;\n\t}\n\n\t*mark = con->mark;\n\tspin_unlock(&con->addrs_lock);\n\n\tif (sas_out)\n\t\tmemcpy(sas_out, &sas, sizeof(struct sockaddr_storage));\n\n\tif (!sa_out) {\n\t\tsrcu_read_unlock(&connections_srcu, idx);\n\t\treturn 0;\n\t}\n\n\tif (dlm_local_addr[0].ss_family == AF_INET) {\n\t\tstruct sockaddr_in *in4  = (struct sockaddr_in *) &sas;\n\t\tstruct sockaddr_in *ret4 = (struct sockaddr_in *) sa_out;\n\t\tret4->sin_addr.s_addr = in4->sin_addr.s_addr;\n\t} else {\n\t\tstruct sockaddr_in6 *in6  = (struct sockaddr_in6 *) &sas;\n\t\tstruct sockaddr_in6 *ret6 = (struct sockaddr_in6 *) sa_out;\n\t\tret6->sin6_addr = in6->sin6_addr;\n\t}\n\n\tsrcu_read_unlock(&connections_srcu, idx);\n\treturn 0;\n}\n\nstatic int addr_to_nodeid(struct sockaddr_storage *addr, int *nodeid,\n\t\t\t  unsigned int *mark)\n{\n\tstruct connection *con;\n\tint i, idx, addr_i;\n\n\tidx = srcu_read_lock(&connections_srcu);\n\tfor (i = 0; i < CONN_HASH_SIZE; i++) {\n\t\thlist_for_each_entry_rcu(con, &connection_hash[i], list) {\n\t\t\tWARN_ON_ONCE(!con->addr_count);\n\n\t\t\tspin_lock(&con->addrs_lock);\n\t\t\tfor (addr_i = 0; addr_i < con->addr_count; addr_i++) {\n\t\t\t\tif (addr_compare(&con->addr[addr_i], addr)) {\n\t\t\t\t\t*nodeid = con->nodeid;\n\t\t\t\t\t*mark = con->mark;\n\t\t\t\t\tspin_unlock(&con->addrs_lock);\n\t\t\t\t\tsrcu_read_unlock(&connections_srcu, idx);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tspin_unlock(&con->addrs_lock);\n\t\t}\n\t}\n\tsrcu_read_unlock(&connections_srcu, idx);\n\n\treturn -ENOENT;\n}\n\nstatic bool dlm_lowcomms_con_has_addr(const struct connection *con,\n\t\t\t\t      const struct sockaddr_storage *addr)\n{\n\tint i;\n\n\tfor (i = 0; i < con->addr_count; i++) {\n\t\tif (addr_compare(&con->addr[i], addr))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nint dlm_lowcomms_addr(int nodeid, struct sockaddr_storage *addr, int len)\n{\n\tstruct connection *con;\n\tbool ret, idx;\n\n\tidx = srcu_read_lock(&connections_srcu);\n\tcon = nodeid2con(nodeid, GFP_NOFS);\n\tif (!con) {\n\t\tsrcu_read_unlock(&connections_srcu, idx);\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock(&con->addrs_lock);\n\tif (!con->addr_count) {\n\t\tmemcpy(&con->addr[0], addr, sizeof(*addr));\n\t\tcon->addr_count = 1;\n\t\tcon->mark = dlm_config.ci_mark;\n\t\tspin_unlock(&con->addrs_lock);\n\t\tsrcu_read_unlock(&connections_srcu, idx);\n\t\treturn 0;\n\t}\n\n\tret = dlm_lowcomms_con_has_addr(con, addr);\n\tif (ret) {\n\t\tspin_unlock(&con->addrs_lock);\n\t\tsrcu_read_unlock(&connections_srcu, idx);\n\t\treturn -EEXIST;\n\t}\n\n\tif (con->addr_count >= DLM_MAX_ADDR_COUNT) {\n\t\tspin_unlock(&con->addrs_lock);\n\t\tsrcu_read_unlock(&connections_srcu, idx);\n\t\treturn -ENOSPC;\n\t}\n\n\tmemcpy(&con->addr[con->addr_count++], addr, sizeof(*addr));\n\tsrcu_read_unlock(&connections_srcu, idx);\n\tspin_unlock(&con->addrs_lock);\n\treturn 0;\n}\n\n \nstatic void lowcomms_data_ready(struct sock *sk)\n{\n\tstruct connection *con = sock2con(sk);\n\n\ttrace_sk_data_ready(sk);\n\n\tset_bit(CF_RECV_INTR, &con->flags);\n\tlowcomms_queue_rwork(con);\n}\n\nstatic void lowcomms_write_space(struct sock *sk)\n{\n\tstruct connection *con = sock2con(sk);\n\n\tclear_bit(SOCK_NOSPACE, &con->sock->flags);\n\n\tspin_lock_bh(&con->writequeue_lock);\n\tif (test_and_clear_bit(CF_APP_LIMITED, &con->flags)) {\n\t\tcon->sock->sk->sk_write_pending--;\n\t\tclear_bit(SOCKWQ_ASYNC_NOSPACE, &con->sock->flags);\n\t}\n\n\tlowcomms_queue_swork(con);\n\tspin_unlock_bh(&con->writequeue_lock);\n}\n\nstatic void lowcomms_state_change(struct sock *sk)\n{\n\t \n\tif (sk->sk_shutdown == RCV_SHUTDOWN)\n\t\tlowcomms_data_ready(sk);\n}\n\nstatic void lowcomms_listen_data_ready(struct sock *sk)\n{\n\ttrace_sk_data_ready(sk);\n\n\tqueue_work(io_workqueue, &listen_con.rwork);\n}\n\nint dlm_lowcomms_connect_node(int nodeid)\n{\n\tstruct connection *con;\n\tint idx;\n\n\tidx = srcu_read_lock(&connections_srcu);\n\tcon = nodeid2con(nodeid, 0);\n\tif (WARN_ON_ONCE(!con)) {\n\t\tsrcu_read_unlock(&connections_srcu, idx);\n\t\treturn -ENOENT;\n\t}\n\n\tdown_read(&con->sock_lock);\n\tif (!con->sock) {\n\t\tspin_lock_bh(&con->writequeue_lock);\n\t\tlowcomms_queue_swork(con);\n\t\tspin_unlock_bh(&con->writequeue_lock);\n\t}\n\tup_read(&con->sock_lock);\n\tsrcu_read_unlock(&connections_srcu, idx);\n\n\tcond_resched();\n\treturn 0;\n}\n\nint dlm_lowcomms_nodes_set_mark(int nodeid, unsigned int mark)\n{\n\tstruct connection *con;\n\tint idx;\n\n\tidx = srcu_read_lock(&connections_srcu);\n\tcon = nodeid2con(nodeid, 0);\n\tif (!con) {\n\t\tsrcu_read_unlock(&connections_srcu, idx);\n\t\treturn -ENOENT;\n\t}\n\n\tspin_lock(&con->addrs_lock);\n\tcon->mark = mark;\n\tspin_unlock(&con->addrs_lock);\n\tsrcu_read_unlock(&connections_srcu, idx);\n\treturn 0;\n}\n\nstatic void lowcomms_error_report(struct sock *sk)\n{\n\tstruct connection *con = sock2con(sk);\n\tstruct inet_sock *inet;\n\n\tinet = inet_sk(sk);\n\tswitch (sk->sk_family) {\n\tcase AF_INET:\n\t\tprintk_ratelimited(KERN_ERR \"dlm: node %d: socket error \"\n\t\t\t\t   \"sending to node %d at %pI4, dport %d, \"\n\t\t\t\t   \"sk_err=%d/%d\\n\", dlm_our_nodeid(),\n\t\t\t\t   con->nodeid, &inet->inet_daddr,\n\t\t\t\t   ntohs(inet->inet_dport), sk->sk_err,\n\t\t\t\t   READ_ONCE(sk->sk_err_soft));\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase AF_INET6:\n\t\tprintk_ratelimited(KERN_ERR \"dlm: node %d: socket error \"\n\t\t\t\t   \"sending to node %d at %pI6c, \"\n\t\t\t\t   \"dport %d, sk_err=%d/%d\\n\", dlm_our_nodeid(),\n\t\t\t\t   con->nodeid, &sk->sk_v6_daddr,\n\t\t\t\t   ntohs(inet->inet_dport), sk->sk_err,\n\t\t\t\t   READ_ONCE(sk->sk_err_soft));\n\t\tbreak;\n#endif\n\tdefault:\n\t\tprintk_ratelimited(KERN_ERR \"dlm: node %d: socket error \"\n\t\t\t\t   \"invalid socket family %d set, \"\n\t\t\t\t   \"sk_err=%d/%d\\n\", dlm_our_nodeid(),\n\t\t\t\t   sk->sk_family, sk->sk_err,\n\t\t\t\t   READ_ONCE(sk->sk_err_soft));\n\t\tbreak;\n\t}\n\n\tdlm_midcomms_unack_msg_resend(con->nodeid);\n\n\tlisten_sock.sk_error_report(sk);\n}\n\nstatic void restore_callbacks(struct sock *sk)\n{\n#ifdef CONFIG_LOCKDEP\n\tWARN_ON_ONCE(!lockdep_sock_is_held(sk));\n#endif\n\n\tsk->sk_user_data = NULL;\n\tsk->sk_data_ready = listen_sock.sk_data_ready;\n\tsk->sk_state_change = listen_sock.sk_state_change;\n\tsk->sk_write_space = listen_sock.sk_write_space;\n\tsk->sk_error_report = listen_sock.sk_error_report;\n}\n\n \nstatic void add_sock(struct socket *sock, struct connection *con)\n{\n\tstruct sock *sk = sock->sk;\n\n\tlock_sock(sk);\n\tcon->sock = sock;\n\n\tsk->sk_user_data = con;\n\tsk->sk_data_ready = lowcomms_data_ready;\n\tsk->sk_write_space = lowcomms_write_space;\n\tif (dlm_config.ci_protocol == DLM_PROTO_SCTP)\n\t\tsk->sk_state_change = lowcomms_state_change;\n\tsk->sk_allocation = GFP_NOFS;\n\tsk->sk_use_task_frag = false;\n\tsk->sk_error_report = lowcomms_error_report;\n\trelease_sock(sk);\n}\n\n \nstatic void make_sockaddr(struct sockaddr_storage *saddr, uint16_t port,\n\t\t\t  int *addr_len)\n{\n\tsaddr->ss_family =  dlm_local_addr[0].ss_family;\n\tif (saddr->ss_family == AF_INET) {\n\t\tstruct sockaddr_in *in4_addr = (struct sockaddr_in *)saddr;\n\t\tin4_addr->sin_port = cpu_to_be16(port);\n\t\t*addr_len = sizeof(struct sockaddr_in);\n\t\tmemset(&in4_addr->sin_zero, 0, sizeof(in4_addr->sin_zero));\n\t} else {\n\t\tstruct sockaddr_in6 *in6_addr = (struct sockaddr_in6 *)saddr;\n\t\tin6_addr->sin6_port = cpu_to_be16(port);\n\t\t*addr_len = sizeof(struct sockaddr_in6);\n\t}\n\tmemset((char *)saddr + *addr_len, 0, sizeof(struct sockaddr_storage) - *addr_len);\n}\n\nstatic void dlm_page_release(struct kref *kref)\n{\n\tstruct writequeue_entry *e = container_of(kref, struct writequeue_entry,\n\t\t\t\t\t\t  ref);\n\n\t__free_page(e->page);\n\tdlm_free_writequeue(e);\n}\n\nstatic void dlm_msg_release(struct kref *kref)\n{\n\tstruct dlm_msg *msg = container_of(kref, struct dlm_msg, ref);\n\n\tkref_put(&msg->entry->ref, dlm_page_release);\n\tdlm_free_msg(msg);\n}\n\nstatic void free_entry(struct writequeue_entry *e)\n{\n\tstruct dlm_msg *msg, *tmp;\n\n\tlist_for_each_entry_safe(msg, tmp, &e->msgs, list) {\n\t\tif (msg->orig_msg) {\n\t\t\tmsg->orig_msg->retransmit = false;\n\t\t\tkref_put(&msg->orig_msg->ref, dlm_msg_release);\n\t\t}\n\n\t\tlist_del(&msg->list);\n\t\tkref_put(&msg->ref, dlm_msg_release);\n\t}\n\n\tlist_del(&e->list);\n\tkref_put(&e->ref, dlm_page_release);\n}\n\nstatic void dlm_close_sock(struct socket **sock)\n{\n\tlock_sock((*sock)->sk);\n\trestore_callbacks((*sock)->sk);\n\trelease_sock((*sock)->sk);\n\n\tsock_release(*sock);\n\t*sock = NULL;\n}\n\nstatic void allow_connection_io(struct connection *con)\n{\n\tif (con->othercon)\n\t\tclear_bit(CF_IO_STOP, &con->othercon->flags);\n\tclear_bit(CF_IO_STOP, &con->flags);\n}\n\nstatic void stop_connection_io(struct connection *con)\n{\n\tif (con->othercon)\n\t\tstop_connection_io(con->othercon);\n\n\tspin_lock_bh(&con->writequeue_lock);\n\tset_bit(CF_IO_STOP, &con->flags);\n\tspin_unlock_bh(&con->writequeue_lock);\n\n\tdown_write(&con->sock_lock);\n\tif (con->sock) {\n\t\tlock_sock(con->sock->sk);\n\t\trestore_callbacks(con->sock->sk);\n\t\trelease_sock(con->sock->sk);\n\t}\n\tup_write(&con->sock_lock);\n\n\tcancel_work_sync(&con->swork);\n\tcancel_work_sync(&con->rwork);\n}\n\n \nstatic void close_connection(struct connection *con, bool and_other)\n{\n\tstruct writequeue_entry *e;\n\n\tif (con->othercon && and_other)\n\t\tclose_connection(con->othercon, false);\n\n\tdown_write(&con->sock_lock);\n\tif (!con->sock) {\n\t\tup_write(&con->sock_lock);\n\t\treturn;\n\t}\n\n\tdlm_close_sock(&con->sock);\n\n\t \n\tspin_lock_bh(&con->writequeue_lock);\n\tif (!list_empty(&con->writequeue)) {\n\t\te = list_first_entry(&con->writequeue, struct writequeue_entry,\n\t\t\t\t     list);\n\t\tif (e->dirty)\n\t\t\tfree_entry(e);\n\t}\n\tspin_unlock_bh(&con->writequeue_lock);\n\n\tcon->rx_leftover = 0;\n\tcon->retries = 0;\n\tclear_bit(CF_APP_LIMITED, &con->flags);\n\tclear_bit(CF_RECV_PENDING, &con->flags);\n\tclear_bit(CF_SEND_PENDING, &con->flags);\n\tup_write(&con->sock_lock);\n}\n\nstatic void shutdown_connection(struct connection *con, bool and_other)\n{\n\tint ret;\n\n\tif (con->othercon && and_other)\n\t\tshutdown_connection(con->othercon, false);\n\n\tflush_workqueue(io_workqueue);\n\tdown_read(&con->sock_lock);\n\t \n\tif (!con->sock) {\n\t\tup_read(&con->sock_lock);\n\t\treturn;\n\t}\n\n\tret = kernel_sock_shutdown(con->sock, SHUT_WR);\n\tup_read(&con->sock_lock);\n\tif (ret) {\n\t\tlog_print(\"Connection %p failed to shutdown: %d will force close\",\n\t\t\t  con, ret);\n\t\tgoto force_close;\n\t} else {\n\t\tret = wait_event_timeout(con->shutdown_wait, !con->sock,\n\t\t\t\t\t DLM_SHUTDOWN_WAIT_TIMEOUT);\n\t\tif (ret == 0) {\n\t\t\tlog_print(\"Connection %p shutdown timed out, will force close\",\n\t\t\t\t  con);\n\t\t\tgoto force_close;\n\t\t}\n\t}\n\n\treturn;\n\nforce_close:\n\tclose_connection(con, false);\n}\n\nstatic struct processqueue_entry *new_processqueue_entry(int nodeid,\n\t\t\t\t\t\t\t int buflen)\n{\n\tstruct processqueue_entry *pentry;\n\n\tpentry = kmalloc(sizeof(*pentry), GFP_NOFS);\n\tif (!pentry)\n\t\treturn NULL;\n\n\tpentry->buf = kmalloc(buflen, GFP_NOFS);\n\tif (!pentry->buf) {\n\t\tkfree(pentry);\n\t\treturn NULL;\n\t}\n\n\tpentry->nodeid = nodeid;\n\treturn pentry;\n}\n\nstatic void free_processqueue_entry(struct processqueue_entry *pentry)\n{\n\tkfree(pentry->buf);\n\tkfree(pentry);\n}\n\nstruct dlm_processed_nodes {\n\tint nodeid;\n\n\tstruct list_head list;\n};\n\nstatic void process_dlm_messages(struct work_struct *work)\n{\n\tstruct processqueue_entry *pentry;\n\n\tspin_lock(&processqueue_lock);\n\tpentry = list_first_entry_or_null(&processqueue,\n\t\t\t\t\t  struct processqueue_entry, list);\n\tif (WARN_ON_ONCE(!pentry)) {\n\t\tprocess_dlm_messages_pending = false;\n\t\tspin_unlock(&processqueue_lock);\n\t\treturn;\n\t}\n\n\tlist_del(&pentry->list);\n\tspin_unlock(&processqueue_lock);\n\n\tfor (;;) {\n\t\tdlm_process_incoming_buffer(pentry->nodeid, pentry->buf,\n\t\t\t\t\t    pentry->buflen);\n\t\tfree_processqueue_entry(pentry);\n\n\t\tspin_lock(&processqueue_lock);\n\t\tpentry = list_first_entry_or_null(&processqueue,\n\t\t\t\t\t\t  struct processqueue_entry, list);\n\t\tif (!pentry) {\n\t\t\tprocess_dlm_messages_pending = false;\n\t\t\tspin_unlock(&processqueue_lock);\n\t\t\tbreak;\n\t\t}\n\n\t\tlist_del(&pentry->list);\n\t\tspin_unlock(&processqueue_lock);\n\t}\n}\n\n \nstatic int receive_from_sock(struct connection *con, int buflen)\n{\n\tstruct processqueue_entry *pentry;\n\tint ret, buflen_real;\n\tstruct msghdr msg;\n\tstruct kvec iov;\n\n\tpentry = new_processqueue_entry(con->nodeid, buflen);\n\tif (!pentry)\n\t\treturn DLM_IO_RESCHED;\n\n\tmemcpy(pentry->buf, con->rx_leftover_buf, con->rx_leftover);\n\n\t \n\tiov.iov_base = pentry->buf + con->rx_leftover;\n\tiov.iov_len = buflen - con->rx_leftover;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.msg_flags = MSG_DONTWAIT | MSG_NOSIGNAL;\n\tclear_bit(CF_RECV_INTR, &con->flags);\nagain:\n\tret = kernel_recvmsg(con->sock, &msg, &iov, 1, iov.iov_len,\n\t\t\t     msg.msg_flags);\n\ttrace_dlm_recv(con->nodeid, ret);\n\tif (ret == -EAGAIN) {\n\t\tlock_sock(con->sock->sk);\n\t\tif (test_and_clear_bit(CF_RECV_INTR, &con->flags)) {\n\t\t\trelease_sock(con->sock->sk);\n\t\t\tgoto again;\n\t\t}\n\n\t\tclear_bit(CF_RECV_PENDING, &con->flags);\n\t\trelease_sock(con->sock->sk);\n\t\tfree_processqueue_entry(pentry);\n\t\treturn DLM_IO_END;\n\t} else if (ret == 0) {\n\t\t \n\t\tfree_processqueue_entry(pentry);\n\t\treturn DLM_IO_EOF;\n\t} else if (ret < 0) {\n\t\tfree_processqueue_entry(pentry);\n\t\treturn ret;\n\t}\n\n\t \n\tbuflen_real = ret + con->rx_leftover;\n\tret = dlm_validate_incoming_buffer(con->nodeid, pentry->buf,\n\t\t\t\t\t   buflen_real);\n\tif (ret < 0) {\n\t\tfree_processqueue_entry(pentry);\n\t\treturn ret;\n\t}\n\n\tpentry->buflen = ret;\n\n\t \n\tcon->rx_leftover = buflen_real - ret;\n\tmemmove(con->rx_leftover_buf, pentry->buf + ret,\n\t\tcon->rx_leftover);\n\n\tspin_lock(&processqueue_lock);\n\tlist_add_tail(&pentry->list, &processqueue);\n\tif (!process_dlm_messages_pending) {\n\t\tprocess_dlm_messages_pending = true;\n\t\tqueue_work(process_workqueue, &process_work);\n\t}\n\tspin_unlock(&processqueue_lock);\n\n\treturn DLM_IO_SUCCESS;\n}\n\n \nstatic int accept_from_sock(void)\n{\n\tstruct sockaddr_storage peeraddr;\n\tint len, idx, result, nodeid;\n\tstruct connection *newcon;\n\tstruct socket *newsock;\n\tunsigned int mark;\n\n\tresult = kernel_accept(listen_con.sock, &newsock, O_NONBLOCK);\n\tif (result == -EAGAIN)\n\t\treturn DLM_IO_END;\n\telse if (result < 0)\n\t\tgoto accept_err;\n\n\t \n\tmemset(&peeraddr, 0, sizeof(peeraddr));\n\tlen = newsock->ops->getname(newsock, (struct sockaddr *)&peeraddr, 2);\n\tif (len < 0) {\n\t\tresult = -ECONNABORTED;\n\t\tgoto accept_err;\n\t}\n\n\t \n\tmake_sockaddr(&peeraddr, 0, &len);\n\tif (addr_to_nodeid(&peeraddr, &nodeid, &mark)) {\n\t\tswitch (peeraddr.ss_family) {\n\t\tcase AF_INET: {\n\t\t\tstruct sockaddr_in *sin = (struct sockaddr_in *)&peeraddr;\n\n\t\t\tlog_print(\"connect from non cluster IPv4 node %pI4\",\n\t\t\t\t  &sin->sin_addr);\n\t\t\tbreak;\n\t\t}\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tcase AF_INET6: {\n\t\t\tstruct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)&peeraddr;\n\n\t\t\tlog_print(\"connect from non cluster IPv6 node %pI6c\",\n\t\t\t\t  &sin6->sin6_addr);\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\tlog_print(\"invalid family from non cluster node\");\n\t\t\tbreak;\n\t\t}\n\n\t\tsock_release(newsock);\n\t\treturn -1;\n\t}\n\n\tlog_print(\"got connection from %d\", nodeid);\n\n\t \n\tidx = srcu_read_lock(&connections_srcu);\n\tnewcon = nodeid2con(nodeid, 0);\n\tif (WARN_ON_ONCE(!newcon)) {\n\t\tsrcu_read_unlock(&connections_srcu, idx);\n\t\tresult = -ENOENT;\n\t\tgoto accept_err;\n\t}\n\n\tsock_set_mark(newsock->sk, mark);\n\n\tdown_write(&newcon->sock_lock);\n\tif (newcon->sock) {\n\t\tstruct connection *othercon = newcon->othercon;\n\n\t\tif (!othercon) {\n\t\t\tothercon = kzalloc(sizeof(*othercon), GFP_NOFS);\n\t\t\tif (!othercon) {\n\t\t\t\tlog_print(\"failed to allocate incoming socket\");\n\t\t\t\tup_write(&newcon->sock_lock);\n\t\t\t\tsrcu_read_unlock(&connections_srcu, idx);\n\t\t\t\tresult = -ENOMEM;\n\t\t\t\tgoto accept_err;\n\t\t\t}\n\n\t\t\tdlm_con_init(othercon, nodeid);\n\t\t\tlockdep_set_subclass(&othercon->sock_lock, 1);\n\t\t\tnewcon->othercon = othercon;\n\t\t\tset_bit(CF_IS_OTHERCON, &othercon->flags);\n\t\t} else {\n\t\t\t \n\t\t\tclose_connection(othercon, false);\n\t\t}\n\n\t\tdown_write(&othercon->sock_lock);\n\t\tadd_sock(newsock, othercon);\n\n\t\t \n\t\tlock_sock(othercon->sock->sk);\n\t\tlowcomms_queue_rwork(othercon);\n\t\trelease_sock(othercon->sock->sk);\n\t\tup_write(&othercon->sock_lock);\n\t}\n\telse {\n\t\t \n\t\tadd_sock(newsock, newcon);\n\n\t\t \n\t\tlock_sock(newcon->sock->sk);\n\t\tlowcomms_queue_rwork(newcon);\n\t\trelease_sock(newcon->sock->sk);\n\t}\n\tup_write(&newcon->sock_lock);\n\tsrcu_read_unlock(&connections_srcu, idx);\n\n\treturn DLM_IO_SUCCESS;\n\naccept_err:\n\tif (newsock)\n\t\tsock_release(newsock);\n\n\treturn result;\n}\n\n \nstatic void writequeue_entry_complete(struct writequeue_entry *e, int completed)\n{\n\te->offset += completed;\n\te->len -= completed;\n\t \n\te->dirty = true;\n\n\tif (e->len == 0 && e->users == 0)\n\t\tfree_entry(e);\n}\n\n \nstatic int sctp_bind_addrs(struct socket *sock, uint16_t port)\n{\n\tstruct sockaddr_storage localaddr;\n\tstruct sockaddr *addr = (struct sockaddr *)&localaddr;\n\tint i, addr_len, result = 0;\n\n\tfor (i = 0; i < dlm_local_count; i++) {\n\t\tmemcpy(&localaddr, &dlm_local_addr[i], sizeof(localaddr));\n\t\tmake_sockaddr(&localaddr, port, &addr_len);\n\n\t\tif (!i)\n\t\t\tresult = kernel_bind(sock, addr, addr_len);\n\t\telse\n\t\t\tresult = sock_bind_add(sock->sk, addr, addr_len);\n\n\t\tif (result < 0) {\n\t\t\tlog_print(\"Can't bind to %d addr number %d, %d.\\n\",\n\t\t\t\t  port, i + 1, result);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn result;\n}\n\n \nstatic void init_local(void)\n{\n\tstruct sockaddr_storage sas;\n\tint i;\n\n\tdlm_local_count = 0;\n\tfor (i = 0; i < DLM_MAX_ADDR_COUNT; i++) {\n\t\tif (dlm_our_addr(&sas, i))\n\t\t\tbreak;\n\n\t\tmemcpy(&dlm_local_addr[dlm_local_count++], &sas, sizeof(sas));\n\t}\n}\n\nstatic struct writequeue_entry *new_writequeue_entry(struct connection *con)\n{\n\tstruct writequeue_entry *entry;\n\n\tentry = dlm_allocate_writequeue();\n\tif (!entry)\n\t\treturn NULL;\n\n\tentry->page = alloc_page(GFP_ATOMIC | __GFP_ZERO);\n\tif (!entry->page) {\n\t\tdlm_free_writequeue(entry);\n\t\treturn NULL;\n\t}\n\n\tentry->offset = 0;\n\tentry->len = 0;\n\tentry->end = 0;\n\tentry->dirty = false;\n\tentry->con = con;\n\tentry->users = 1;\n\tkref_init(&entry->ref);\n\treturn entry;\n}\n\nstatic struct writequeue_entry *new_wq_entry(struct connection *con, int len,\n\t\t\t\t\t     char **ppc, void (*cb)(void *data),\n\t\t\t\t\t     void *data)\n{\n\tstruct writequeue_entry *e;\n\n\tspin_lock_bh(&con->writequeue_lock);\n\tif (!list_empty(&con->writequeue)) {\n\t\te = list_last_entry(&con->writequeue, struct writequeue_entry, list);\n\t\tif (DLM_WQ_REMAIN_BYTES(e) >= len) {\n\t\t\tkref_get(&e->ref);\n\n\t\t\t*ppc = page_address(e->page) + e->end;\n\t\t\tif (cb)\n\t\t\t\tcb(data);\n\n\t\t\te->end += len;\n\t\t\te->users++;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\te = new_writequeue_entry(con);\n\tif (!e)\n\t\tgoto out;\n\n\tkref_get(&e->ref);\n\t*ppc = page_address(e->page);\n\te->end += len;\n\tif (cb)\n\t\tcb(data);\n\n\tlist_add_tail(&e->list, &con->writequeue);\n\nout:\n\tspin_unlock_bh(&con->writequeue_lock);\n\treturn e;\n};\n\nstatic struct dlm_msg *dlm_lowcomms_new_msg_con(struct connection *con, int len,\n\t\t\t\t\t\tgfp_t allocation, char **ppc,\n\t\t\t\t\t\tvoid (*cb)(void *data),\n\t\t\t\t\t\tvoid *data)\n{\n\tstruct writequeue_entry *e;\n\tstruct dlm_msg *msg;\n\n\tmsg = dlm_allocate_msg(allocation);\n\tif (!msg)\n\t\treturn NULL;\n\n\tkref_init(&msg->ref);\n\n\te = new_wq_entry(con, len, ppc, cb, data);\n\tif (!e) {\n\t\tdlm_free_msg(msg);\n\t\treturn NULL;\n\t}\n\n\tmsg->retransmit = false;\n\tmsg->orig_msg = NULL;\n\tmsg->ppc = *ppc;\n\tmsg->len = len;\n\tmsg->entry = e;\n\n\treturn msg;\n}\n\n \n#ifndef __CHECKER__\nstruct dlm_msg *dlm_lowcomms_new_msg(int nodeid, int len, gfp_t allocation,\n\t\t\t\t     char **ppc, void (*cb)(void *data),\n\t\t\t\t     void *data)\n{\n\tstruct connection *con;\n\tstruct dlm_msg *msg;\n\tint idx;\n\n\tif (len > DLM_MAX_SOCKET_BUFSIZE ||\n\t    len < sizeof(struct dlm_header)) {\n\t\tBUILD_BUG_ON(PAGE_SIZE < DLM_MAX_SOCKET_BUFSIZE);\n\t\tlog_print(\"failed to allocate a buffer of size %d\", len);\n\t\tWARN_ON_ONCE(1);\n\t\treturn NULL;\n\t}\n\n\tidx = srcu_read_lock(&connections_srcu);\n\tcon = nodeid2con(nodeid, 0);\n\tif (WARN_ON_ONCE(!con)) {\n\t\tsrcu_read_unlock(&connections_srcu, idx);\n\t\treturn NULL;\n\t}\n\n\tmsg = dlm_lowcomms_new_msg_con(con, len, allocation, ppc, cb, data);\n\tif (!msg) {\n\t\tsrcu_read_unlock(&connections_srcu, idx);\n\t\treturn NULL;\n\t}\n\n\t \n\tkref_get(&msg->ref);\n\t \n\tmsg->idx = idx;\n\treturn msg;\n}\n#endif\n\nstatic void _dlm_lowcomms_commit_msg(struct dlm_msg *msg)\n{\n\tstruct writequeue_entry *e = msg->entry;\n\tstruct connection *con = e->con;\n\tint users;\n\n\tspin_lock_bh(&con->writequeue_lock);\n\tkref_get(&msg->ref);\n\tlist_add(&msg->list, &e->msgs);\n\n\tusers = --e->users;\n\tif (users)\n\t\tgoto out;\n\n\te->len = DLM_WQ_LENGTH_BYTES(e);\n\n\tlowcomms_queue_swork(con);\n\nout:\n\tspin_unlock_bh(&con->writequeue_lock);\n\treturn;\n}\n\n \n#ifndef __CHECKER__\nvoid dlm_lowcomms_commit_msg(struct dlm_msg *msg)\n{\n\t_dlm_lowcomms_commit_msg(msg);\n\tsrcu_read_unlock(&connections_srcu, msg->idx);\n\t \n\tkref_put(&msg->ref, dlm_msg_release);\n}\n#endif\n\nvoid dlm_lowcomms_put_msg(struct dlm_msg *msg)\n{\n\tkref_put(&msg->ref, dlm_msg_release);\n}\n\n \nint dlm_lowcomms_resend_msg(struct dlm_msg *msg)\n{\n\tstruct dlm_msg *msg_resend;\n\tchar *ppc;\n\n\tif (msg->retransmit)\n\t\treturn 1;\n\n\tmsg_resend = dlm_lowcomms_new_msg_con(msg->entry->con, msg->len,\n\t\t\t\t\t      GFP_ATOMIC, &ppc, NULL, NULL);\n\tif (!msg_resend)\n\t\treturn -ENOMEM;\n\n\tmsg->retransmit = true;\n\tkref_get(&msg->ref);\n\tmsg_resend->orig_msg = msg;\n\n\tmemcpy(ppc, msg->ppc, msg->len);\n\t_dlm_lowcomms_commit_msg(msg_resend);\n\tdlm_lowcomms_put_msg(msg_resend);\n\n\treturn 0;\n}\n\n \nstatic int send_to_sock(struct connection *con)\n{\n\tstruct writequeue_entry *e;\n\tstruct bio_vec bvec;\n\tstruct msghdr msg = {\n\t\t.msg_flags = MSG_SPLICE_PAGES | MSG_DONTWAIT | MSG_NOSIGNAL,\n\t};\n\tint len, offset, ret;\n\n\tspin_lock_bh(&con->writequeue_lock);\n\te = con_next_wq(con);\n\tif (!e) {\n\t\tclear_bit(CF_SEND_PENDING, &con->flags);\n\t\tspin_unlock_bh(&con->writequeue_lock);\n\t\treturn DLM_IO_END;\n\t}\n\n\tlen = e->len;\n\toffset = e->offset;\n\tWARN_ON_ONCE(len == 0 && e->users == 0);\n\tspin_unlock_bh(&con->writequeue_lock);\n\n\tbvec_set_page(&bvec, e->page, len, offset);\n\tiov_iter_bvec(&msg.msg_iter, ITER_SOURCE, &bvec, 1, len);\n\tret = sock_sendmsg(con->sock, &msg);\n\ttrace_dlm_send(con->nodeid, ret);\n\tif (ret == -EAGAIN || ret == 0) {\n\t\tlock_sock(con->sock->sk);\n\t\tspin_lock_bh(&con->writequeue_lock);\n\t\tif (test_bit(SOCKWQ_ASYNC_NOSPACE, &con->sock->flags) &&\n\t\t    !test_and_set_bit(CF_APP_LIMITED, &con->flags)) {\n\t\t\t \n\t\t\tset_bit(SOCK_NOSPACE, &con->sock->sk->sk_socket->flags);\n\t\t\tcon->sock->sk->sk_write_pending++;\n\n\t\t\tclear_bit(CF_SEND_PENDING, &con->flags);\n\t\t\tspin_unlock_bh(&con->writequeue_lock);\n\t\t\trelease_sock(con->sock->sk);\n\n\t\t\t \n\t\t\treturn DLM_IO_END;\n\t\t}\n\t\tspin_unlock_bh(&con->writequeue_lock);\n\t\trelease_sock(con->sock->sk);\n\n\t\treturn DLM_IO_RESCHED;\n\t} else if (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tspin_lock_bh(&con->writequeue_lock);\n\twritequeue_entry_complete(e, ret);\n\tspin_unlock_bh(&con->writequeue_lock);\n\n\treturn DLM_IO_SUCCESS;\n}\n\nstatic void clean_one_writequeue(struct connection *con)\n{\n\tstruct writequeue_entry *e, *safe;\n\n\tspin_lock_bh(&con->writequeue_lock);\n\tlist_for_each_entry_safe(e, safe, &con->writequeue, list) {\n\t\tfree_entry(e);\n\t}\n\tspin_unlock_bh(&con->writequeue_lock);\n}\n\nstatic void connection_release(struct rcu_head *rcu)\n{\n\tstruct connection *con = container_of(rcu, struct connection, rcu);\n\n\tWARN_ON_ONCE(!list_empty(&con->writequeue));\n\tWARN_ON_ONCE(con->sock);\n\tkfree(con);\n}\n\n \nint dlm_lowcomms_close(int nodeid)\n{\n\tstruct connection *con;\n\tint idx;\n\n\tlog_print(\"closing connection to node %d\", nodeid);\n\n\tidx = srcu_read_lock(&connections_srcu);\n\tcon = nodeid2con(nodeid, 0);\n\tif (WARN_ON_ONCE(!con)) {\n\t\tsrcu_read_unlock(&connections_srcu, idx);\n\t\treturn -ENOENT;\n\t}\n\n\tstop_connection_io(con);\n\tlog_print(\"io handling for node: %d stopped\", nodeid);\n\tclose_connection(con, true);\n\n\tspin_lock(&connections_lock);\n\thlist_del_rcu(&con->list);\n\tspin_unlock(&connections_lock);\n\n\tclean_one_writequeue(con);\n\tcall_srcu(&connections_srcu, &con->rcu, connection_release);\n\tif (con->othercon) {\n\t\tclean_one_writequeue(con->othercon);\n\t\tcall_srcu(&connections_srcu, &con->othercon->rcu, connection_release);\n\t}\n\tsrcu_read_unlock(&connections_srcu, idx);\n\n\t \n\tlog_print(\"closing connection to node %d done\", nodeid);\n\n\treturn 0;\n}\n\n \nstatic void process_recv_sockets(struct work_struct *work)\n{\n\tstruct connection *con = container_of(work, struct connection, rwork);\n\tint ret, buflen;\n\n\tdown_read(&con->sock_lock);\n\tif (!con->sock) {\n\t\tup_read(&con->sock_lock);\n\t\treturn;\n\t}\n\n\tbuflen = READ_ONCE(dlm_config.ci_buffer_size);\n\tdo {\n\t\tret = receive_from_sock(con, buflen);\n\t} while (ret == DLM_IO_SUCCESS);\n\tup_read(&con->sock_lock);\n\n\tswitch (ret) {\n\tcase DLM_IO_END:\n\t\t \n\t\tbreak;\n\tcase DLM_IO_EOF:\n\t\tclose_connection(con, false);\n\t\twake_up(&con->shutdown_wait);\n\t\t \n\t\tbreak;\n\tcase DLM_IO_RESCHED:\n\t\tcond_resched();\n\t\tqueue_work(io_workqueue, &con->rwork);\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tif (ret < 0) {\n\t\t\tif (test_bit(CF_IS_OTHERCON, &con->flags)) {\n\t\t\t\tclose_connection(con, false);\n\t\t\t} else {\n\t\t\t\tspin_lock_bh(&con->writequeue_lock);\n\t\t\t\tlowcomms_queue_swork(con);\n\t\t\t\tspin_unlock_bh(&con->writequeue_lock);\n\t\t\t}\n\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n}\n\nstatic void process_listen_recv_socket(struct work_struct *work)\n{\n\tint ret;\n\n\tif (WARN_ON_ONCE(!listen_con.sock))\n\t\treturn;\n\n\tdo {\n\t\tret = accept_from_sock();\n\t} while (ret == DLM_IO_SUCCESS);\n\n\tif (ret < 0)\n\t\tlog_print(\"critical error accepting connection: %d\", ret);\n}\n\nstatic int dlm_connect(struct connection *con)\n{\n\tstruct sockaddr_storage addr;\n\tint result, addr_len;\n\tstruct socket *sock;\n\tunsigned int mark;\n\n\tmemset(&addr, 0, sizeof(addr));\n\tresult = nodeid_to_addr(con->nodeid, &addr, NULL,\n\t\t\t\tdlm_proto_ops->try_new_addr, &mark);\n\tif (result < 0) {\n\t\tlog_print(\"no address for nodeid %d\", con->nodeid);\n\t\treturn result;\n\t}\n\n\t \n\tresult = sock_create_kern(&init_net, dlm_local_addr[0].ss_family,\n\t\t\t\t  SOCK_STREAM, dlm_proto_ops->proto, &sock);\n\tif (result < 0)\n\t\treturn result;\n\n\tsock_set_mark(sock->sk, mark);\n\tdlm_proto_ops->sockopts(sock);\n\n\tresult = dlm_proto_ops->bind(sock);\n\tif (result < 0) {\n\t\tsock_release(sock);\n\t\treturn result;\n\t}\n\n\tadd_sock(sock, con);\n\n\tlog_print_ratelimited(\"connecting to %d\", con->nodeid);\n\tmake_sockaddr(&addr, dlm_config.ci_tcp_port, &addr_len);\n\tresult = dlm_proto_ops->connect(con, sock, (struct sockaddr *)&addr,\n\t\t\t\t\taddr_len);\n\tswitch (result) {\n\tcase -EINPROGRESS:\n\t\t \n\t\tfallthrough;\n\tcase 0:\n\t\tbreak;\n\tdefault:\n\t\tif (result < 0)\n\t\t\tdlm_close_sock(&con->sock);\n\n\t\tbreak;\n\t}\n\n\treturn result;\n}\n\n \nstatic void process_send_sockets(struct work_struct *work)\n{\n\tstruct connection *con = container_of(work, struct connection, swork);\n\tint ret;\n\n\tWARN_ON_ONCE(test_bit(CF_IS_OTHERCON, &con->flags));\n\n\tdown_read(&con->sock_lock);\n\tif (!con->sock) {\n\t\tup_read(&con->sock_lock);\n\t\tdown_write(&con->sock_lock);\n\t\tif (!con->sock) {\n\t\t\tret = dlm_connect(con);\n\t\t\tswitch (ret) {\n\t\t\tcase 0:\n\t\t\t\tbreak;\n\t\t\tcase -EINPROGRESS:\n\t\t\t\t \n\t\t\t\tmsleep(100);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t \n\t\t\t\tup_write(&con->sock_lock);\n\t\t\t\tlog_print(\"connect to node %d try %d error %d\",\n\t\t\t\t\t  con->nodeid, con->retries++, ret);\n\t\t\t\tmsleep(1000);\n\t\t\t\t \n\t\t\t\tqueue_work(io_workqueue, &con->swork);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tdowngrade_write(&con->sock_lock);\n\t}\n\n\tdo {\n\t\tret = send_to_sock(con);\n\t} while (ret == DLM_IO_SUCCESS);\n\tup_read(&con->sock_lock);\n\n\tswitch (ret) {\n\tcase DLM_IO_END:\n\t\t \n\t\tbreak;\n\tcase DLM_IO_RESCHED:\n\t\t \n\t\tcond_resched();\n\t\tqueue_work(io_workqueue, &con->swork);\n\t\tbreak;\n\tdefault:\n\t\tif (ret < 0) {\n\t\t\tclose_connection(con, false);\n\n\t\t\t \n\t\t\tspin_lock_bh(&con->writequeue_lock);\n\t\t\tlowcomms_queue_swork(con);\n\t\t\tspin_unlock_bh(&con->writequeue_lock);\n\t\t\tbreak;\n\t\t}\n\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n}\n\nstatic void work_stop(void)\n{\n\tif (io_workqueue) {\n\t\tdestroy_workqueue(io_workqueue);\n\t\tio_workqueue = NULL;\n\t}\n\n\tif (process_workqueue) {\n\t\tdestroy_workqueue(process_workqueue);\n\t\tprocess_workqueue = NULL;\n\t}\n}\n\nstatic int work_start(void)\n{\n\tio_workqueue = alloc_workqueue(\"dlm_io\", WQ_HIGHPRI | WQ_MEM_RECLAIM |\n\t\t\t\t       WQ_UNBOUND, 0);\n\tif (!io_workqueue) {\n\t\tlog_print(\"can't start dlm_io\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tprocess_workqueue = alloc_ordered_workqueue(\"dlm_process\",\n\t\t\t\t\t\t    WQ_HIGHPRI | WQ_MEM_RECLAIM);\n\tif (!process_workqueue) {\n\t\tlog_print(\"can't start dlm_process\");\n\t\tdestroy_workqueue(io_workqueue);\n\t\tio_workqueue = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nvoid dlm_lowcomms_shutdown(void)\n{\n\tstruct connection *con;\n\tint i, idx;\n\n\t \n\tlock_sock(listen_con.sock->sk);\n\tlisten_con.sock->sk->sk_data_ready = listen_sock.sk_data_ready;\n\trelease_sock(listen_con.sock->sk);\n\n\tcancel_work_sync(&listen_con.rwork);\n\tdlm_close_sock(&listen_con.sock);\n\n\tidx = srcu_read_lock(&connections_srcu);\n\tfor (i = 0; i < CONN_HASH_SIZE; i++) {\n\t\thlist_for_each_entry_rcu(con, &connection_hash[i], list) {\n\t\t\tshutdown_connection(con, true);\n\t\t\tstop_connection_io(con);\n\t\t\tflush_workqueue(process_workqueue);\n\t\t\tclose_connection(con, true);\n\n\t\t\tclean_one_writequeue(con);\n\t\t\tif (con->othercon)\n\t\t\t\tclean_one_writequeue(con->othercon);\n\t\t\tallow_connection_io(con);\n\t\t}\n\t}\n\tsrcu_read_unlock(&connections_srcu, idx);\n}\n\nvoid dlm_lowcomms_stop(void)\n{\n\twork_stop();\n\tdlm_proto_ops = NULL;\n}\n\nstatic int dlm_listen_for_all(void)\n{\n\tstruct socket *sock;\n\tint result;\n\n\tlog_print(\"Using %s for communications\",\n\t\t  dlm_proto_ops->name);\n\n\tresult = dlm_proto_ops->listen_validate();\n\tif (result < 0)\n\t\treturn result;\n\n\tresult = sock_create_kern(&init_net, dlm_local_addr[0].ss_family,\n\t\t\t\t  SOCK_STREAM, dlm_proto_ops->proto, &sock);\n\tif (result < 0) {\n\t\tlog_print(\"Can't create comms socket: %d\", result);\n\t\treturn result;\n\t}\n\n\tsock_set_mark(sock->sk, dlm_config.ci_mark);\n\tdlm_proto_ops->listen_sockopts(sock);\n\n\tresult = dlm_proto_ops->listen_bind(sock);\n\tif (result < 0)\n\t\tgoto out;\n\n\tlock_sock(sock->sk);\n\tlisten_sock.sk_data_ready = sock->sk->sk_data_ready;\n\tlisten_sock.sk_write_space = sock->sk->sk_write_space;\n\tlisten_sock.sk_error_report = sock->sk->sk_error_report;\n\tlisten_sock.sk_state_change = sock->sk->sk_state_change;\n\n\tlisten_con.sock = sock;\n\n\tsock->sk->sk_allocation = GFP_NOFS;\n\tsock->sk->sk_use_task_frag = false;\n\tsock->sk->sk_data_ready = lowcomms_listen_data_ready;\n\trelease_sock(sock->sk);\n\n\tresult = sock->ops->listen(sock, 128);\n\tif (result < 0) {\n\t\tdlm_close_sock(&listen_con.sock);\n\t\treturn result;\n\t}\n\n\treturn 0;\n\nout:\n\tsock_release(sock);\n\treturn result;\n}\n\nstatic int dlm_tcp_bind(struct socket *sock)\n{\n\tstruct sockaddr_storage src_addr;\n\tint result, addr_len;\n\n\t \n\tmemcpy(&src_addr, &dlm_local_addr[0], sizeof(src_addr));\n\tmake_sockaddr(&src_addr, 0, &addr_len);\n\n\tresult = sock->ops->bind(sock, (struct sockaddr *)&src_addr,\n\t\t\t\t addr_len);\n\tif (result < 0) {\n\t\t \n\t\tlog_print(\"could not bind for connect: %d\", result);\n\t}\n\n\treturn 0;\n}\n\nstatic int dlm_tcp_connect(struct connection *con, struct socket *sock,\n\t\t\t   struct sockaddr *addr, int addr_len)\n{\n\treturn sock->ops->connect(sock, addr, addr_len, O_NONBLOCK);\n}\n\nstatic int dlm_tcp_listen_validate(void)\n{\n\t \n\tif (dlm_local_count > 1) {\n\t\tlog_print(\"TCP protocol can't handle multi-homed hosts, try SCTP\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void dlm_tcp_sockopts(struct socket *sock)\n{\n\t \n\ttcp_sock_set_nodelay(sock->sk);\n}\n\nstatic void dlm_tcp_listen_sockopts(struct socket *sock)\n{\n\tdlm_tcp_sockopts(sock);\n\tsock_set_reuseaddr(sock->sk);\n}\n\nstatic int dlm_tcp_listen_bind(struct socket *sock)\n{\n\tint addr_len;\n\n\t \n\tmake_sockaddr(&dlm_local_addr[0], dlm_config.ci_tcp_port, &addr_len);\n\treturn sock->ops->bind(sock, (struct sockaddr *)&dlm_local_addr[0],\n\t\t\t       addr_len);\n}\n\nstatic const struct dlm_proto_ops dlm_tcp_ops = {\n\t.name = \"TCP\",\n\t.proto = IPPROTO_TCP,\n\t.connect = dlm_tcp_connect,\n\t.sockopts = dlm_tcp_sockopts,\n\t.bind = dlm_tcp_bind,\n\t.listen_validate = dlm_tcp_listen_validate,\n\t.listen_sockopts = dlm_tcp_listen_sockopts,\n\t.listen_bind = dlm_tcp_listen_bind,\n};\n\nstatic int dlm_sctp_bind(struct socket *sock)\n{\n\treturn sctp_bind_addrs(sock, 0);\n}\n\nstatic int dlm_sctp_connect(struct connection *con, struct socket *sock,\n\t\t\t    struct sockaddr *addr, int addr_len)\n{\n\tint ret;\n\n\t \n\tsock_set_sndtimeo(sock->sk, 5);\n\tret = sock->ops->connect(sock, addr, addr_len, 0);\n\tsock_set_sndtimeo(sock->sk, 0);\n\treturn ret;\n}\n\nstatic int dlm_sctp_listen_validate(void)\n{\n\tif (!IS_ENABLED(CONFIG_IP_SCTP)) {\n\t\tlog_print(\"SCTP is not enabled by this kernel\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\trequest_module(\"sctp\");\n\treturn 0;\n}\n\nstatic int dlm_sctp_bind_listen(struct socket *sock)\n{\n\treturn sctp_bind_addrs(sock, dlm_config.ci_tcp_port);\n}\n\nstatic void dlm_sctp_sockopts(struct socket *sock)\n{\n\t \n\tsctp_sock_set_nodelay(sock->sk);\n\tsock_set_rcvbuf(sock->sk, NEEDED_RMEM);\n}\n\nstatic const struct dlm_proto_ops dlm_sctp_ops = {\n\t.name = \"SCTP\",\n\t.proto = IPPROTO_SCTP,\n\t.try_new_addr = true,\n\t.connect = dlm_sctp_connect,\n\t.sockopts = dlm_sctp_sockopts,\n\t.bind = dlm_sctp_bind,\n\t.listen_validate = dlm_sctp_listen_validate,\n\t.listen_sockopts = dlm_sctp_sockopts,\n\t.listen_bind = dlm_sctp_bind_listen,\n};\n\nint dlm_lowcomms_start(void)\n{\n\tint error;\n\n\tinit_local();\n\tif (!dlm_local_count) {\n\t\terror = -ENOTCONN;\n\t\tlog_print(\"no local IP address has been set\");\n\t\tgoto fail;\n\t}\n\n\terror = work_start();\n\tif (error)\n\t\tgoto fail;\n\n\t \n\tswitch (dlm_config.ci_protocol) {\n\tcase DLM_PROTO_TCP:\n\t\tdlm_proto_ops = &dlm_tcp_ops;\n\t\tbreak;\n\tcase DLM_PROTO_SCTP:\n\t\tdlm_proto_ops = &dlm_sctp_ops;\n\t\tbreak;\n\tdefault:\n\t\tlog_print(\"Invalid protocol identifier %d set\",\n\t\t\t  dlm_config.ci_protocol);\n\t\terror = -EINVAL;\n\t\tgoto fail_proto_ops;\n\t}\n\n\terror = dlm_listen_for_all();\n\tif (error)\n\t\tgoto fail_listen;\n\n\treturn 0;\n\nfail_listen:\n\tdlm_proto_ops = NULL;\nfail_proto_ops:\n\twork_stop();\nfail:\n\treturn error;\n}\n\nvoid dlm_lowcomms_init(void)\n{\n\tint i;\n\n\tfor (i = 0; i < CONN_HASH_SIZE; i++)\n\t\tINIT_HLIST_HEAD(&connection_hash[i]);\n\n\tINIT_WORK(&listen_con.rwork, process_listen_recv_socket);\n}\n\nvoid dlm_lowcomms_exit(void)\n{\n\tstruct connection *con;\n\tint i, idx;\n\n\tidx = srcu_read_lock(&connections_srcu);\n\tfor (i = 0; i < CONN_HASH_SIZE; i++) {\n\t\thlist_for_each_entry_rcu(con, &connection_hash[i], list) {\n\t\t\tspin_lock(&connections_lock);\n\t\t\thlist_del_rcu(&con->list);\n\t\t\tspin_unlock(&connections_lock);\n\n\t\t\tif (con->othercon)\n\t\t\t\tcall_srcu(&connections_srcu, &con->othercon->rcu,\n\t\t\t\t\t  connection_release);\n\t\t\tcall_srcu(&connections_srcu, &con->rcu, connection_release);\n\t\t}\n\t}\n\tsrcu_read_unlock(&connections_srcu, idx);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}