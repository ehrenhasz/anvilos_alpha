{
  "module_name": "lockspace.c",
  "hash_id": "0f3565ef7fb46be68ef362fc3c7fee62db546556b8ec8105e059db9fbe37e7f1",
  "original_prompt": "Ingested from linux-6.6.14/fs/dlm/lockspace.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n\n#include \"dlm_internal.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"recoverd.h\"\n#include \"dir.h\"\n#include \"midcomms.h\"\n#include \"config.h\"\n#include \"memory.h\"\n#include \"lock.h\"\n#include \"recover.h\"\n#include \"requestqueue.h\"\n#include \"user.h\"\n#include \"ast.h\"\n\nstatic int\t\t\tls_count;\nstatic struct mutex\t\tls_lock;\nstatic struct list_head\t\tlslist;\nstatic spinlock_t\t\tlslist_lock;\nstatic struct task_struct *\tscand_task;\n\n\nstatic ssize_t dlm_control_store(struct dlm_ls *ls, const char *buf, size_t len)\n{\n\tssize_t ret = len;\n\tint n;\n\tint rc = kstrtoint(buf, 0, &n);\n\n\tif (rc)\n\t\treturn rc;\n\tls = dlm_find_lockspace_local(ls->ls_local_handle);\n\tif (!ls)\n\t\treturn -EINVAL;\n\n\tswitch (n) {\n\tcase 0:\n\t\tdlm_ls_stop(ls);\n\t\tbreak;\n\tcase 1:\n\t\tdlm_ls_start(ls);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\tdlm_put_lockspace(ls);\n\treturn ret;\n}\n\nstatic ssize_t dlm_event_store(struct dlm_ls *ls, const char *buf, size_t len)\n{\n\tint rc = kstrtoint(buf, 0, &ls->ls_uevent_result);\n\n\tif (rc)\n\t\treturn rc;\n\tset_bit(LSFL_UEVENT_WAIT, &ls->ls_flags);\n\twake_up(&ls->ls_uevent_wait);\n\treturn len;\n}\n\nstatic ssize_t dlm_id_show(struct dlm_ls *ls, char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"%u\\n\", ls->ls_global_id);\n}\n\nstatic ssize_t dlm_id_store(struct dlm_ls *ls, const char *buf, size_t len)\n{\n\tint rc = kstrtouint(buf, 0, &ls->ls_global_id);\n\n\tif (rc)\n\t\treturn rc;\n\treturn len;\n}\n\nstatic ssize_t dlm_nodir_show(struct dlm_ls *ls, char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"%u\\n\", dlm_no_directory(ls));\n}\n\nstatic ssize_t dlm_nodir_store(struct dlm_ls *ls, const char *buf, size_t len)\n{\n\tint val;\n\tint rc = kstrtoint(buf, 0, &val);\n\n\tif (rc)\n\t\treturn rc;\n\tif (val == 1)\n\t\tset_bit(LSFL_NODIR, &ls->ls_flags);\n\treturn len;\n}\n\nstatic ssize_t dlm_recover_status_show(struct dlm_ls *ls, char *buf)\n{\n\tuint32_t status = dlm_recover_status(ls);\n\treturn snprintf(buf, PAGE_SIZE, \"%x\\n\", status);\n}\n\nstatic ssize_t dlm_recover_nodeid_show(struct dlm_ls *ls, char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", ls->ls_recover_nodeid);\n}\n\nstruct dlm_attr {\n\tstruct attribute attr;\n\tssize_t (*show)(struct dlm_ls *, char *);\n\tssize_t (*store)(struct dlm_ls *, const char *, size_t);\n};\n\nstatic struct dlm_attr dlm_attr_control = {\n\t.attr  = {.name = \"control\", .mode = S_IWUSR},\n\t.store = dlm_control_store\n};\n\nstatic struct dlm_attr dlm_attr_event = {\n\t.attr  = {.name = \"event_done\", .mode = S_IWUSR},\n\t.store = dlm_event_store\n};\n\nstatic struct dlm_attr dlm_attr_id = {\n\t.attr  = {.name = \"id\", .mode = S_IRUGO | S_IWUSR},\n\t.show  = dlm_id_show,\n\t.store = dlm_id_store\n};\n\nstatic struct dlm_attr dlm_attr_nodir = {\n\t.attr  = {.name = \"nodir\", .mode = S_IRUGO | S_IWUSR},\n\t.show  = dlm_nodir_show,\n\t.store = dlm_nodir_store\n};\n\nstatic struct dlm_attr dlm_attr_recover_status = {\n\t.attr  = {.name = \"recover_status\", .mode = S_IRUGO},\n\t.show  = dlm_recover_status_show\n};\n\nstatic struct dlm_attr dlm_attr_recover_nodeid = {\n\t.attr  = {.name = \"recover_nodeid\", .mode = S_IRUGO},\n\t.show  = dlm_recover_nodeid_show\n};\n\nstatic struct attribute *dlm_attrs[] = {\n\t&dlm_attr_control.attr,\n\t&dlm_attr_event.attr,\n\t&dlm_attr_id.attr,\n\t&dlm_attr_nodir.attr,\n\t&dlm_attr_recover_status.attr,\n\t&dlm_attr_recover_nodeid.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(dlm);\n\nstatic ssize_t dlm_attr_show(struct kobject *kobj, struct attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct dlm_ls *ls  = container_of(kobj, struct dlm_ls, ls_kobj);\n\tstruct dlm_attr *a = container_of(attr, struct dlm_attr, attr);\n\treturn a->show ? a->show(ls, buf) : 0;\n}\n\nstatic ssize_t dlm_attr_store(struct kobject *kobj, struct attribute *attr,\n\t\t\t      const char *buf, size_t len)\n{\n\tstruct dlm_ls *ls  = container_of(kobj, struct dlm_ls, ls_kobj);\n\tstruct dlm_attr *a = container_of(attr, struct dlm_attr, attr);\n\treturn a->store ? a->store(ls, buf, len) : len;\n}\n\nstatic void lockspace_kobj_release(struct kobject *k)\n{\n\tstruct dlm_ls *ls  = container_of(k, struct dlm_ls, ls_kobj);\n\tkfree(ls);\n}\n\nstatic const struct sysfs_ops dlm_attr_ops = {\n\t.show  = dlm_attr_show,\n\t.store = dlm_attr_store,\n};\n\nstatic struct kobj_type dlm_ktype = {\n\t.default_groups = dlm_groups,\n\t.sysfs_ops     = &dlm_attr_ops,\n\t.release       = lockspace_kobj_release,\n};\n\nstatic struct kset *dlm_kset;\n\nstatic int do_uevent(struct dlm_ls *ls, int in)\n{\n\tif (in)\n\t\tkobject_uevent(&ls->ls_kobj, KOBJ_ONLINE);\n\telse\n\t\tkobject_uevent(&ls->ls_kobj, KOBJ_OFFLINE);\n\n\tlog_rinfo(ls, \"%s the lockspace group...\", in ? \"joining\" : \"leaving\");\n\n\t \n\n\twait_event(ls->ls_uevent_wait,\n\t\t   test_and_clear_bit(LSFL_UEVENT_WAIT, &ls->ls_flags));\n\n\tlog_rinfo(ls, \"group event done %d\", ls->ls_uevent_result);\n\n\treturn ls->ls_uevent_result;\n}\n\nstatic int dlm_uevent(const struct kobject *kobj, struct kobj_uevent_env *env)\n{\n\tconst struct dlm_ls *ls = container_of(kobj, struct dlm_ls, ls_kobj);\n\n\tadd_uevent_var(env, \"LOCKSPACE=%s\", ls->ls_name);\n\treturn 0;\n}\n\nstatic const struct kset_uevent_ops dlm_uevent_ops = {\n\t.uevent = dlm_uevent,\n};\n\nint __init dlm_lockspace_init(void)\n{\n\tls_count = 0;\n\tmutex_init(&ls_lock);\n\tINIT_LIST_HEAD(&lslist);\n\tspin_lock_init(&lslist_lock);\n\n\tdlm_kset = kset_create_and_add(\"dlm\", &dlm_uevent_ops, kernel_kobj);\n\tif (!dlm_kset) {\n\t\tprintk(KERN_WARNING \"%s: can not create kset\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nvoid dlm_lockspace_exit(void)\n{\n\tkset_unregister(dlm_kset);\n}\n\nstatic struct dlm_ls *find_ls_to_scan(void)\n{\n\tstruct dlm_ls *ls;\n\n\tspin_lock(&lslist_lock);\n\tlist_for_each_entry(ls, &lslist, ls_list) {\n\t\tif (time_after_eq(jiffies, ls->ls_scan_time +\n\t\t\t\t\t    dlm_config.ci_scan_secs * HZ)) {\n\t\t\tspin_unlock(&lslist_lock);\n\t\t\treturn ls;\n\t\t}\n\t}\n\tspin_unlock(&lslist_lock);\n\treturn NULL;\n}\n\nstatic int dlm_scand(void *data)\n{\n\tstruct dlm_ls *ls;\n\n\twhile (!kthread_should_stop()) {\n\t\tls = find_ls_to_scan();\n\t\tif (ls) {\n\t\t\tif (dlm_lock_recovery_try(ls)) {\n\t\t\t\tls->ls_scan_time = jiffies;\n\t\t\t\tdlm_scan_rsbs(ls);\n\t\t\t\tdlm_unlock_recovery(ls);\n\t\t\t} else {\n\t\t\t\tls->ls_scan_time += HZ;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tschedule_timeout_interruptible(dlm_config.ci_scan_secs * HZ);\n\t}\n\treturn 0;\n}\n\nstatic int dlm_scand_start(void)\n{\n\tstruct task_struct *p;\n\tint error = 0;\n\n\tp = kthread_run(dlm_scand, NULL, \"dlm_scand\");\n\tif (IS_ERR(p))\n\t\terror = PTR_ERR(p);\n\telse\n\t\tscand_task = p;\n\treturn error;\n}\n\nstatic void dlm_scand_stop(void)\n{\n\tkthread_stop(scand_task);\n}\n\nstruct dlm_ls *dlm_find_lockspace_global(uint32_t id)\n{\n\tstruct dlm_ls *ls;\n\n\tspin_lock(&lslist_lock);\n\n\tlist_for_each_entry(ls, &lslist, ls_list) {\n\t\tif (ls->ls_global_id == id) {\n\t\t\tatomic_inc(&ls->ls_count);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tls = NULL;\n out:\n\tspin_unlock(&lslist_lock);\n\treturn ls;\n}\n\nstruct dlm_ls *dlm_find_lockspace_local(dlm_lockspace_t *lockspace)\n{\n\tstruct dlm_ls *ls;\n\n\tspin_lock(&lslist_lock);\n\tlist_for_each_entry(ls, &lslist, ls_list) {\n\t\tif (ls->ls_local_handle == lockspace) {\n\t\t\tatomic_inc(&ls->ls_count);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tls = NULL;\n out:\n\tspin_unlock(&lslist_lock);\n\treturn ls;\n}\n\nstruct dlm_ls *dlm_find_lockspace_device(int minor)\n{\n\tstruct dlm_ls *ls;\n\n\tspin_lock(&lslist_lock);\n\tlist_for_each_entry(ls, &lslist, ls_list) {\n\t\tif (ls->ls_device.minor == minor) {\n\t\t\tatomic_inc(&ls->ls_count);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tls = NULL;\n out:\n\tspin_unlock(&lslist_lock);\n\treturn ls;\n}\n\nvoid dlm_put_lockspace(struct dlm_ls *ls)\n{\n\tif (atomic_dec_and_test(&ls->ls_count))\n\t\twake_up(&ls->ls_count_wait);\n}\n\nstatic void remove_lockspace(struct dlm_ls *ls)\n{\nretry:\n\twait_event(ls->ls_count_wait, atomic_read(&ls->ls_count) == 0);\n\n\tspin_lock(&lslist_lock);\n\tif (atomic_read(&ls->ls_count) != 0) {\n\t\tspin_unlock(&lslist_lock);\n\t\tgoto retry;\n\t}\n\n\tWARN_ON(ls->ls_create_count != 0);\n\tlist_del(&ls->ls_list);\n\tspin_unlock(&lslist_lock);\n}\n\nstatic int threads_start(void)\n{\n\tint error;\n\n\t \n\terror = dlm_midcomms_start();\n\tif (error) {\n\t\tlog_print(\"cannot start dlm midcomms %d\", error);\n\t\tgoto fail;\n\t}\n\n\terror = dlm_scand_start();\n\tif (error) {\n\t\tlog_print(\"cannot start dlm_scand thread %d\", error);\n\t\tgoto midcomms_fail;\n\t}\n\n\treturn 0;\n\n midcomms_fail:\n\tdlm_midcomms_stop();\n fail:\n\treturn error;\n}\n\nstatic int new_lockspace(const char *name, const char *cluster,\n\t\t\t uint32_t flags, int lvblen,\n\t\t\t const struct dlm_lockspace_ops *ops, void *ops_arg,\n\t\t\t int *ops_result, dlm_lockspace_t **lockspace)\n{\n\tstruct dlm_ls *ls;\n\tint i, size, error;\n\tint do_unreg = 0;\n\tint namelen = strlen(name);\n\n\tif (namelen > DLM_LOCKSPACE_LEN || namelen == 0)\n\t\treturn -EINVAL;\n\n\tif (lvblen % 8)\n\t\treturn -EINVAL;\n\n\tif (!try_module_get(THIS_MODULE))\n\t\treturn -EINVAL;\n\n\tif (!dlm_user_daemon_available()) {\n\t\tlog_print(\"dlm user daemon not available\");\n\t\terror = -EUNATCH;\n\t\tgoto out;\n\t}\n\n\tif (ops && ops_result) {\n\t       \tif (!dlm_config.ci_recover_callbacks)\n\t\t\t*ops_result = -EOPNOTSUPP;\n\t\telse\n\t\t\t*ops_result = 0;\n\t}\n\n\tif (!cluster)\n\t\tlog_print(\"dlm cluster name '%s' is being used without an application provided cluster name\",\n\t\t\t  dlm_config.ci_cluster_name);\n\n\tif (dlm_config.ci_recover_callbacks && cluster &&\n\t    strncmp(cluster, dlm_config.ci_cluster_name, DLM_LOCKSPACE_LEN)) {\n\t\tlog_print(\"dlm cluster name '%s' does not match \"\n\t\t\t  \"the application cluster name '%s'\",\n\t\t\t  dlm_config.ci_cluster_name, cluster);\n\t\terror = -EBADR;\n\t\tgoto out;\n\t}\n\n\terror = 0;\n\n\tspin_lock(&lslist_lock);\n\tlist_for_each_entry(ls, &lslist, ls_list) {\n\t\tWARN_ON(ls->ls_create_count <= 0);\n\t\tif (ls->ls_namelen != namelen)\n\t\t\tcontinue;\n\t\tif (memcmp(ls->ls_name, name, namelen))\n\t\t\tcontinue;\n\t\tif (flags & DLM_LSFL_NEWEXCL) {\n\t\t\terror = -EEXIST;\n\t\t\tbreak;\n\t\t}\n\t\tls->ls_create_count++;\n\t\t*lockspace = ls;\n\t\terror = 1;\n\t\tbreak;\n\t}\n\tspin_unlock(&lslist_lock);\n\n\tif (error)\n\t\tgoto out;\n\n\terror = -ENOMEM;\n\n\tls = kzalloc(sizeof(*ls), GFP_NOFS);\n\tif (!ls)\n\t\tgoto out;\n\tmemcpy(ls->ls_name, name, namelen);\n\tls->ls_namelen = namelen;\n\tls->ls_lvblen = lvblen;\n\tatomic_set(&ls->ls_count, 0);\n\tinit_waitqueue_head(&ls->ls_count_wait);\n\tls->ls_flags = 0;\n\tls->ls_scan_time = jiffies;\n\n\tif (ops && dlm_config.ci_recover_callbacks) {\n\t\tls->ls_ops = ops;\n\t\tls->ls_ops_arg = ops_arg;\n\t}\n\n\t \n\tls->ls_exflags = (flags & ~(DLM_LSFL_FS | DLM_LSFL_NEWEXCL));\n\n\tsize = READ_ONCE(dlm_config.ci_rsbtbl_size);\n\tls->ls_rsbtbl_size = size;\n\n\tls->ls_rsbtbl = vmalloc(array_size(size, sizeof(struct dlm_rsbtable)));\n\tif (!ls->ls_rsbtbl)\n\t\tgoto out_lsfree;\n\tfor (i = 0; i < size; i++) {\n\t\tls->ls_rsbtbl[i].keep.rb_node = NULL;\n\t\tls->ls_rsbtbl[i].toss.rb_node = NULL;\n\t\tspin_lock_init(&ls->ls_rsbtbl[i].lock);\n\t}\n\n\tfor (i = 0; i < DLM_REMOVE_NAMES_MAX; i++) {\n\t\tls->ls_remove_names[i] = kzalloc(DLM_RESNAME_MAXLEN+1,\n\t\t\t\t\t\t GFP_KERNEL);\n\t\tif (!ls->ls_remove_names[i])\n\t\t\tgoto out_rsbtbl;\n\t}\n\n\tidr_init(&ls->ls_lkbidr);\n\tspin_lock_init(&ls->ls_lkbidr_spin);\n\n\tINIT_LIST_HEAD(&ls->ls_waiters);\n\tmutex_init(&ls->ls_waiters_mutex);\n\tINIT_LIST_HEAD(&ls->ls_orphans);\n\tmutex_init(&ls->ls_orphans_mutex);\n\n\tINIT_LIST_HEAD(&ls->ls_new_rsb);\n\tspin_lock_init(&ls->ls_new_rsb_spin);\n\n\tINIT_LIST_HEAD(&ls->ls_nodes);\n\tINIT_LIST_HEAD(&ls->ls_nodes_gone);\n\tls->ls_num_nodes = 0;\n\tls->ls_low_nodeid = 0;\n\tls->ls_total_weight = 0;\n\tls->ls_node_array = NULL;\n\n\tmemset(&ls->ls_local_rsb, 0, sizeof(struct dlm_rsb));\n\tls->ls_local_rsb.res_ls = ls;\n\n\tls->ls_debug_rsb_dentry = NULL;\n\tls->ls_debug_waiters_dentry = NULL;\n\n\tinit_waitqueue_head(&ls->ls_uevent_wait);\n\tls->ls_uevent_result = 0;\n\tinit_completion(&ls->ls_recovery_done);\n\tls->ls_recovery_result = -1;\n\n\tspin_lock_init(&ls->ls_cb_lock);\n\tINIT_LIST_HEAD(&ls->ls_cb_delay);\n\n\tls->ls_recoverd_task = NULL;\n\tmutex_init(&ls->ls_recoverd_active);\n\tspin_lock_init(&ls->ls_recover_lock);\n\tspin_lock_init(&ls->ls_rcom_spin);\n\tget_random_bytes(&ls->ls_rcom_seq, sizeof(uint64_t));\n\tls->ls_recover_status = 0;\n\tls->ls_recover_seq = get_random_u64();\n\tls->ls_recover_args = NULL;\n\tinit_rwsem(&ls->ls_in_recovery);\n\tinit_rwsem(&ls->ls_recv_active);\n\tINIT_LIST_HEAD(&ls->ls_requestqueue);\n\tatomic_set(&ls->ls_requestqueue_cnt, 0);\n\tinit_waitqueue_head(&ls->ls_requestqueue_wait);\n\tmutex_init(&ls->ls_requestqueue_mutex);\n\tspin_lock_init(&ls->ls_clear_proc_locks);\n\n\t \n\tls->ls_recover_buf = kmalloc(DLM_MAX_SOCKET_BUFSIZE, GFP_NOFS);\n\tif (!ls->ls_recover_buf)\n\t\tgoto out_lkbidr;\n\n\tls->ls_slot = 0;\n\tls->ls_num_slots = 0;\n\tls->ls_slots_size = 0;\n\tls->ls_slots = NULL;\n\n\tINIT_LIST_HEAD(&ls->ls_recover_list);\n\tspin_lock_init(&ls->ls_recover_list_lock);\n\tidr_init(&ls->ls_recover_idr);\n\tspin_lock_init(&ls->ls_recover_idr_lock);\n\tls->ls_recover_list_count = 0;\n\tls->ls_local_handle = ls;\n\tinit_waitqueue_head(&ls->ls_wait_general);\n\tINIT_LIST_HEAD(&ls->ls_root_list);\n\tinit_rwsem(&ls->ls_root_sem);\n\n\tspin_lock(&lslist_lock);\n\tls->ls_create_count = 1;\n\tlist_add(&ls->ls_list, &lslist);\n\tspin_unlock(&lslist_lock);\n\n\tif (flags & DLM_LSFL_FS) {\n\t\terror = dlm_callback_start(ls);\n\t\tif (error) {\n\t\t\tlog_error(ls, \"can't start dlm_callback %d\", error);\n\t\t\tgoto out_delist;\n\t\t}\n\t}\n\n\tinit_waitqueue_head(&ls->ls_recover_lock_wait);\n\n\t \n\n\terror = dlm_recoverd_start(ls);\n\tif (error) {\n\t\tlog_error(ls, \"can't start dlm_recoverd %d\", error);\n\t\tgoto out_callback;\n\t}\n\n\twait_event(ls->ls_recover_lock_wait,\n\t\t   test_bit(LSFL_RECOVER_LOCK, &ls->ls_flags));\n\n\t \n\tdo_unreg = 1;\n\n\tls->ls_kobj.kset = dlm_kset;\n\terror = kobject_init_and_add(&ls->ls_kobj, &dlm_ktype, NULL,\n\t\t\t\t     \"%s\", ls->ls_name);\n\tif (error)\n\t\tgoto out_recoverd;\n\tkobject_uevent(&ls->ls_kobj, KOBJ_ADD);\n\n\t \n\n\terror = do_uevent(ls, 1);\n\tif (error)\n\t\tgoto out_recoverd;\n\n\t \n\twait_for_completion(&ls->ls_recovery_done);\n\terror = ls->ls_recovery_result;\n\tif (error)\n\t\tgoto out_members;\n\n\tdlm_create_debug_file(ls);\n\n\tlog_rinfo(ls, \"join complete\");\n\t*lockspace = ls;\n\treturn 0;\n\n out_members:\n\tdo_uevent(ls, 0);\n\tdlm_clear_members(ls);\n\tkfree(ls->ls_node_array);\n out_recoverd:\n\tdlm_recoverd_stop(ls);\n out_callback:\n\tdlm_callback_stop(ls);\n out_delist:\n\tspin_lock(&lslist_lock);\n\tlist_del(&ls->ls_list);\n\tspin_unlock(&lslist_lock);\n\tidr_destroy(&ls->ls_recover_idr);\n\tkfree(ls->ls_recover_buf);\n out_lkbidr:\n\tidr_destroy(&ls->ls_lkbidr);\n out_rsbtbl:\n\tfor (i = 0; i < DLM_REMOVE_NAMES_MAX; i++)\n\t\tkfree(ls->ls_remove_names[i]);\n\tvfree(ls->ls_rsbtbl);\n out_lsfree:\n\tif (do_unreg)\n\t\tkobject_put(&ls->ls_kobj);\n\telse\n\t\tkfree(ls);\n out:\n\tmodule_put(THIS_MODULE);\n\treturn error;\n}\n\nstatic int __dlm_new_lockspace(const char *name, const char *cluster,\n\t\t\t       uint32_t flags, int lvblen,\n\t\t\t       const struct dlm_lockspace_ops *ops,\n\t\t\t       void *ops_arg, int *ops_result,\n\t\t\t       dlm_lockspace_t **lockspace)\n{\n\tint error = 0;\n\n\tmutex_lock(&ls_lock);\n\tif (!ls_count)\n\t\terror = threads_start();\n\tif (error)\n\t\tgoto out;\n\n\terror = new_lockspace(name, cluster, flags, lvblen, ops, ops_arg,\n\t\t\t      ops_result, lockspace);\n\tif (!error)\n\t\tls_count++;\n\tif (error > 0)\n\t\terror = 0;\n\tif (!ls_count) {\n\t\tdlm_scand_stop();\n\t\tdlm_midcomms_shutdown();\n\t\tdlm_midcomms_stop();\n\t}\n out:\n\tmutex_unlock(&ls_lock);\n\treturn error;\n}\n\nint dlm_new_lockspace(const char *name, const char *cluster, uint32_t flags,\n\t\t      int lvblen, const struct dlm_lockspace_ops *ops,\n\t\t      void *ops_arg, int *ops_result,\n\t\t      dlm_lockspace_t **lockspace)\n{\n\treturn __dlm_new_lockspace(name, cluster, flags | DLM_LSFL_FS, lvblen,\n\t\t\t\t   ops, ops_arg, ops_result, lockspace);\n}\n\nint dlm_new_user_lockspace(const char *name, const char *cluster,\n\t\t\t   uint32_t flags, int lvblen,\n\t\t\t   const struct dlm_lockspace_ops *ops,\n\t\t\t   void *ops_arg, int *ops_result,\n\t\t\t   dlm_lockspace_t **lockspace)\n{\n\treturn __dlm_new_lockspace(name, cluster, flags, lvblen, ops,\n\t\t\t\t   ops_arg, ops_result, lockspace);\n}\n\nstatic int lkb_idr_is_local(int id, void *p, void *data)\n{\n\tstruct dlm_lkb *lkb = p;\n\n\treturn lkb->lkb_nodeid == 0 && lkb->lkb_grmode != DLM_LOCK_IV;\n}\n\nstatic int lkb_idr_is_any(int id, void *p, void *data)\n{\n\treturn 1;\n}\n\nstatic int lkb_idr_free(int id, void *p, void *data)\n{\n\tstruct dlm_lkb *lkb = p;\n\n\tif (lkb->lkb_lvbptr && test_bit(DLM_IFL_MSTCPY_BIT, &lkb->lkb_iflags))\n\t\tdlm_free_lvb(lkb->lkb_lvbptr);\n\n\tdlm_free_lkb(lkb);\n\treturn 0;\n}\n\n \n\nstatic int lockspace_busy(struct dlm_ls *ls, int force)\n{\n\tint rv;\n\n\tspin_lock(&ls->ls_lkbidr_spin);\n\tif (force == 0) {\n\t\trv = idr_for_each(&ls->ls_lkbidr, lkb_idr_is_any, ls);\n\t} else if (force == 1) {\n\t\trv = idr_for_each(&ls->ls_lkbidr, lkb_idr_is_local, ls);\n\t} else {\n\t\trv = 0;\n\t}\n\tspin_unlock(&ls->ls_lkbidr_spin);\n\treturn rv;\n}\n\nstatic int release_lockspace(struct dlm_ls *ls, int force)\n{\n\tstruct dlm_rsb *rsb;\n\tstruct rb_node *n;\n\tint i, busy, rv;\n\n\tbusy = lockspace_busy(ls, force);\n\n\tspin_lock(&lslist_lock);\n\tif (ls->ls_create_count == 1) {\n\t\tif (busy) {\n\t\t\trv = -EBUSY;\n\t\t} else {\n\t\t\t \n\t\t\tls->ls_create_count = 0;\n\t\t\trv = 0;\n\t\t}\n\t} else if (ls->ls_create_count > 1) {\n\t\trv = --ls->ls_create_count;\n\t} else {\n\t\trv = -EINVAL;\n\t}\n\tspin_unlock(&lslist_lock);\n\n\tif (rv) {\n\t\tlog_debug(ls, \"release_lockspace no remove %d\", rv);\n\t\treturn rv;\n\t}\n\n\tif (ls_count == 1)\n\t\tdlm_midcomms_version_wait();\n\n\tdlm_device_deregister(ls);\n\n\tif (force < 3 && dlm_user_daemon_available())\n\t\tdo_uevent(ls, 0);\n\n\tdlm_recoverd_stop(ls);\n\n\tif (ls_count == 1) {\n\t\tdlm_scand_stop();\n\t\tdlm_clear_members(ls);\n\t\tdlm_midcomms_shutdown();\n\t}\n\n\tdlm_callback_stop(ls);\n\n\tremove_lockspace(ls);\n\n\tdlm_delete_debug_file(ls);\n\n\tidr_destroy(&ls->ls_recover_idr);\n\tkfree(ls->ls_recover_buf);\n\n\t \n\n\tidr_for_each(&ls->ls_lkbidr, lkb_idr_free, ls);\n\tidr_destroy(&ls->ls_lkbidr);\n\n\t \n\n\tfor (i = 0; i < ls->ls_rsbtbl_size; i++) {\n\t\twhile ((n = rb_first(&ls->ls_rsbtbl[i].keep))) {\n\t\t\trsb = rb_entry(n, struct dlm_rsb, res_hashnode);\n\t\t\trb_erase(n, &ls->ls_rsbtbl[i].keep);\n\t\t\tdlm_free_rsb(rsb);\n\t\t}\n\n\t\twhile ((n = rb_first(&ls->ls_rsbtbl[i].toss))) {\n\t\t\trsb = rb_entry(n, struct dlm_rsb, res_hashnode);\n\t\t\trb_erase(n, &ls->ls_rsbtbl[i].toss);\n\t\t\tdlm_free_rsb(rsb);\n\t\t}\n\t}\n\n\tvfree(ls->ls_rsbtbl);\n\n\tfor (i = 0; i < DLM_REMOVE_NAMES_MAX; i++)\n\t\tkfree(ls->ls_remove_names[i]);\n\n\twhile (!list_empty(&ls->ls_new_rsb)) {\n\t\trsb = list_first_entry(&ls->ls_new_rsb, struct dlm_rsb,\n\t\t\t\t       res_hashchain);\n\t\tlist_del(&rsb->res_hashchain);\n\t\tdlm_free_rsb(rsb);\n\t}\n\n\t \n\n\tdlm_purge_requestqueue(ls);\n\tkfree(ls->ls_recover_args);\n\tdlm_clear_members(ls);\n\tdlm_clear_members_gone(ls);\n\tkfree(ls->ls_node_array);\n\tlog_rinfo(ls, \"release_lockspace final free\");\n\tkobject_put(&ls->ls_kobj);\n\t \n\n\tmodule_put(THIS_MODULE);\n\treturn 0;\n}\n\n \n\nint dlm_release_lockspace(void *lockspace, int force)\n{\n\tstruct dlm_ls *ls;\n\tint error;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -EINVAL;\n\tdlm_put_lockspace(ls);\n\n\tmutex_lock(&ls_lock);\n\terror = release_lockspace(ls, force);\n\tif (!error)\n\t\tls_count--;\n\tif (!ls_count)\n\t\tdlm_midcomms_stop();\n\tmutex_unlock(&ls_lock);\n\n\treturn error;\n}\n\nvoid dlm_stop_lockspaces(void)\n{\n\tstruct dlm_ls *ls;\n\tint count;\n\n restart:\n\tcount = 0;\n\tspin_lock(&lslist_lock);\n\tlist_for_each_entry(ls, &lslist, ls_list) {\n\t\tif (!test_bit(LSFL_RUNNING, &ls->ls_flags)) {\n\t\t\tcount++;\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&lslist_lock);\n\t\tlog_error(ls, \"no userland control daemon, stopping lockspace\");\n\t\tdlm_ls_stop(ls);\n\t\tgoto restart;\n\t}\n\tspin_unlock(&lslist_lock);\n\n\tif (count)\n\t\tlog_print(\"dlm user daemon left %d lockspaces\", count);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}