{
  "module_name": "dir.c",
  "hash_id": "180a6e7cceb1b8bd6507454b424c1e13ef44345b737070b986f21bbd21366c81",
  "original_prompt": "Ingested from linux-6.6.14/fs/dlm/dir.c",
  "human_readable_source": "\n \n\n#include \"dlm_internal.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"rcom.h\"\n#include \"config.h\"\n#include \"memory.h\"\n#include \"recover.h\"\n#include \"util.h\"\n#include \"lock.h\"\n#include \"dir.h\"\n\n \n\nint dlm_hash2nodeid(struct dlm_ls *ls, uint32_t hash)\n{\n\tuint32_t node;\n\n\tif (ls->ls_num_nodes == 1)\n\t\treturn dlm_our_nodeid();\n\telse {\n\t\tnode = (hash >> 16) % ls->ls_total_weight;\n\t\treturn ls->ls_node_array[node];\n\t}\n}\n\nint dlm_dir_nodeid(struct dlm_rsb *r)\n{\n\treturn r->res_dir_nodeid;\n}\n\nvoid dlm_recover_dir_nodeid(struct dlm_ls *ls)\n{\n\tstruct dlm_rsb *r;\n\n\tdown_read(&ls->ls_root_sem);\n\tlist_for_each_entry(r, &ls->ls_root_list, res_root_list) {\n\t\tr->res_dir_nodeid = dlm_hash2nodeid(ls, r->res_hash);\n\t}\n\tup_read(&ls->ls_root_sem);\n}\n\nint dlm_recover_directory(struct dlm_ls *ls, uint64_t seq)\n{\n\tstruct dlm_member *memb;\n\tchar *b, *last_name = NULL;\n\tint error = -ENOMEM, last_len, nodeid, result;\n\tuint16_t namelen;\n\tunsigned int count = 0, count_match = 0, count_bad = 0, count_add = 0;\n\n\tlog_rinfo(ls, \"dlm_recover_directory\");\n\n\tif (dlm_no_directory(ls))\n\t\tgoto out_status;\n\n\tlast_name = kmalloc(DLM_RESNAME_MAXLEN, GFP_NOFS);\n\tif (!last_name)\n\t\tgoto out;\n\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tif (memb->nodeid == dlm_our_nodeid())\n\t\t\tcontinue;\n\n\t\tmemset(last_name, 0, DLM_RESNAME_MAXLEN);\n\t\tlast_len = 0;\n\n\t\tfor (;;) {\n\t\t\tint left;\n\t\t\tif (dlm_recovery_stopped(ls)) {\n\t\t\t\terror = -EINTR;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\terror = dlm_rcom_names(ls, memb->nodeid,\n\t\t\t\t\t       last_name, last_len, seq);\n\t\t\tif (error)\n\t\t\t\tgoto out_free;\n\n\t\t\tcond_resched();\n\n\t\t\t \n\n\t\t\tb = ls->ls_recover_buf->rc_buf;\n\t\t\tleft = le16_to_cpu(ls->ls_recover_buf->rc_header.h_length);\n\t\t\tleft -= sizeof(struct dlm_rcom);\n\n\t\t\tfor (;;) {\n\t\t\t\t__be16 v;\n\n\t\t\t\terror = -EINVAL;\n\t\t\t\tif (left < sizeof(__be16))\n\t\t\t\t\tgoto out_free;\n\n\t\t\t\tmemcpy(&v, b, sizeof(__be16));\n\t\t\t\tnamelen = be16_to_cpu(v);\n\t\t\t\tb += sizeof(__be16);\n\t\t\t\tleft -= sizeof(__be16);\n\n\t\t\t\t \n\n\t\t\t\tif (namelen == 0xFFFF)\n\t\t\t\t\tgoto done;\n\t\t\t\tif (!namelen)\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (namelen > left)\n\t\t\t\t\tgoto out_free;\n\n\t\t\t\tif (namelen > DLM_RESNAME_MAXLEN)\n\t\t\t\t\tgoto out_free;\n\n\t\t\t\terror = dlm_master_lookup(ls, memb->nodeid,\n\t\t\t\t\t\t\t  b, namelen,\n\t\t\t\t\t\t\t  DLM_LU_RECOVER_DIR,\n\t\t\t\t\t\t\t  &nodeid, &result);\n\t\t\t\tif (error) {\n\t\t\t\t\tlog_error(ls, \"recover_dir lookup %d\",\n\t\t\t\t\t\t  error);\n\t\t\t\t\tgoto out_free;\n\t\t\t\t}\n\n\t\t\t\t \n\n\t\t\t\tif (result == DLM_LU_MATCH &&\n\t\t\t\t    nodeid != memb->nodeid) {\n\t\t\t\t\tcount_bad++;\n\t\t\t\t\tlog_error(ls, \"recover_dir lookup %d \"\n\t\t\t\t\t\t  \"nodeid %d memb %d bad %u\",\n\t\t\t\t\t\t  result, nodeid, memb->nodeid,\n\t\t\t\t\t\t  count_bad);\n\t\t\t\t\tprint_hex_dump_bytes(\"dlm_recover_dir \",\n\t\t\t\t\t\t\t     DUMP_PREFIX_NONE,\n\t\t\t\t\t\t\t     b, namelen);\n\t\t\t\t}\n\n\t\t\t\t \n\n\t\t\t\tif (result == DLM_LU_MATCH &&\n\t\t\t\t    nodeid == memb->nodeid) {\n\t\t\t\t\tcount_match++;\n\t\t\t\t}\n\n\t\t\t\t \n\n\t\t\t\tif (result == DLM_LU_ADD) {\n\t\t\t\t\tcount_add++;\n\t\t\t\t}\n\n\t\t\t\tlast_len = namelen;\n\t\t\t\tmemcpy(last_name, b, namelen);\n\t\t\t\tb += namelen;\n\t\t\t\tleft -= namelen;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t done:\n\t\t;\n\t}\n\n out_status:\n\terror = 0;\n\tdlm_set_recover_status(ls, DLM_RS_DIR);\n\n\tlog_rinfo(ls, \"dlm_recover_directory %u in %u new\",\n\t\t  count, count_add);\n out_free:\n\tkfree(last_name);\n out:\n\treturn error;\n}\n\nstatic struct dlm_rsb *find_rsb_root(struct dlm_ls *ls, const char *name,\n\t\t\t\t     int len)\n{\n\tstruct dlm_rsb *r;\n\tuint32_t hash, bucket;\n\tint rv;\n\n\thash = jhash(name, len, 0);\n\tbucket = hash & (ls->ls_rsbtbl_size - 1);\n\n\tspin_lock(&ls->ls_rsbtbl[bucket].lock);\n\trv = dlm_search_rsb_tree(&ls->ls_rsbtbl[bucket].keep, name, len, &r);\n\tif (rv)\n\t\trv = dlm_search_rsb_tree(&ls->ls_rsbtbl[bucket].toss,\n\t\t\t\t\t name, len, &r);\n\tspin_unlock(&ls->ls_rsbtbl[bucket].lock);\n\n\tif (!rv)\n\t\treturn r;\n\n\tdown_read(&ls->ls_root_sem);\n\tlist_for_each_entry(r, &ls->ls_root_list, res_root_list) {\n\t\tif (len == r->res_length && !memcmp(name, r->res_name, len)) {\n\t\t\tup_read(&ls->ls_root_sem);\n\t\t\tlog_debug(ls, \"find_rsb_root revert to root_list %s\",\n\t\t\t\t  r->res_name);\n\t\t\treturn r;\n\t\t}\n\t}\n\tup_read(&ls->ls_root_sem);\n\treturn NULL;\n}\n\n \n\nvoid dlm_copy_master_names(struct dlm_ls *ls, const char *inbuf, int inlen,\n \t\t\t   char *outbuf, int outlen, int nodeid)\n{\n\tstruct list_head *list;\n\tstruct dlm_rsb *r;\n\tint offset = 0, dir_nodeid;\n\t__be16 be_namelen;\n\n\tdown_read(&ls->ls_root_sem);\n\n\tif (inlen > 1) {\n\t\tr = find_rsb_root(ls, inbuf, inlen);\n\t\tif (!r) {\n\t\t\tlog_error(ls, \"copy_master_names from %d start %d %.*s\",\n\t\t\t\t  nodeid, inlen, inlen, inbuf);\n\t\t\tgoto out;\n\t\t}\n\t\tlist = r->res_root_list.next;\n\t} else {\n\t\tlist = ls->ls_root_list.next;\n\t}\n\n\tfor (offset = 0; list != &ls->ls_root_list; list = list->next) {\n\t\tr = list_entry(list, struct dlm_rsb, res_root_list);\n\t\tif (r->res_nodeid)\n\t\t\tcontinue;\n\n\t\tdir_nodeid = dlm_dir_nodeid(r);\n\t\tif (dir_nodeid != nodeid)\n\t\t\tcontinue;\n\n\t\t \n\n\t\tif (offset + sizeof(uint16_t)*2 + r->res_length > outlen) {\n\t\t\t \n\t\t\tbe_namelen = cpu_to_be16(0);\n\t\t\tmemcpy(outbuf + offset, &be_namelen, sizeof(__be16));\n\t\t\toffset += sizeof(__be16);\n\t\t\tls->ls_recover_dir_sent_msg++;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbe_namelen = cpu_to_be16(r->res_length);\n\t\tmemcpy(outbuf + offset, &be_namelen, sizeof(__be16));\n\t\toffset += sizeof(__be16);\n\t\tmemcpy(outbuf + offset, r->res_name, r->res_length);\n\t\toffset += r->res_length;\n\t\tls->ls_recover_dir_sent_res++;\n\t}\n\n\t \n\n\tif ((list == &ls->ls_root_list) &&\n\t    (offset + sizeof(uint16_t) <= outlen)) {\n\t\tbe_namelen = cpu_to_be16(0xFFFF);\n\t\tmemcpy(outbuf + offset, &be_namelen, sizeof(__be16));\n\t\toffset += sizeof(__be16);\n\t\tls->ls_recover_dir_sent_msg++;\n\t}\n out:\n\tup_read(&ls->ls_root_sem);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}