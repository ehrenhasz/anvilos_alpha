{
  "module_name": "member.c",
  "hash_id": "6d615ea61e0c4c48cbec2afa769d4754e91d532f026467769b4d4ded8e90804c",
  "original_prompt": "Ingested from linux-6.6.14/fs/dlm/member.c",
  "human_readable_source": "\n \n\n#include \"dlm_internal.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"recoverd.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n\nint dlm_slots_version(const struct dlm_header *h)\n{\n\tif ((le32_to_cpu(h->h_version) & 0x0000FFFF) < DLM_HEADER_SLOTS)\n\t\treturn 0;\n\treturn 1;\n}\n\nvoid dlm_slot_save(struct dlm_ls *ls, struct dlm_rcom *rc,\n\t\t   struct dlm_member *memb)\n{\n\tstruct rcom_config *rf = (struct rcom_config *)rc->rc_buf;\n\n\tif (!dlm_slots_version(&rc->rc_header))\n\t\treturn;\n\n\tmemb->slot = le16_to_cpu(rf->rf_our_slot);\n\tmemb->generation = le32_to_cpu(rf->rf_generation);\n}\n\nvoid dlm_slots_copy_out(struct dlm_ls *ls, struct dlm_rcom *rc)\n{\n\tstruct dlm_slot *slot;\n\tstruct rcom_slot *ro;\n\tint i;\n\n\tro = (struct rcom_slot *)(rc->rc_buf + sizeof(struct rcom_config));\n\n\t \n\n\tfor (i = 0; i < ls->ls_slots_size; i++) {\n\t\tslot = &ls->ls_slots[i];\n\t\tif (!slot->nodeid)\n\t\t\tcontinue;\n\t\tro->ro_nodeid = cpu_to_le32(slot->nodeid);\n\t\tro->ro_slot = cpu_to_le16(slot->slot);\n\t\tro++;\n\t}\n}\n\n#define SLOT_DEBUG_LINE 128\n\nstatic void log_slots(struct dlm_ls *ls, uint32_t gen, int num_slots,\n\t\t      struct rcom_slot *ro0, struct dlm_slot *array,\n\t\t      int array_size)\n{\n\tchar line[SLOT_DEBUG_LINE];\n\tint len = SLOT_DEBUG_LINE - 1;\n\tint pos = 0;\n\tint ret, i;\n\n\tmemset(line, 0, sizeof(line));\n\n\tif (array) {\n\t\tfor (i = 0; i < array_size; i++) {\n\t\t\tif (!array[i].nodeid)\n\t\t\t\tcontinue;\n\n\t\t\tret = snprintf(line + pos, len - pos, \" %d:%d\",\n\t\t\t\t       array[i].slot, array[i].nodeid);\n\t\t\tif (ret >= len - pos)\n\t\t\t\tbreak;\n\t\t\tpos += ret;\n\t\t}\n\t} else if (ro0) {\n\t\tfor (i = 0; i < num_slots; i++) {\n\t\t\tret = snprintf(line + pos, len - pos, \" %d:%d\",\n\t\t\t\t       ro0[i].ro_slot, ro0[i].ro_nodeid);\n\t\t\tif (ret >= len - pos)\n\t\t\t\tbreak;\n\t\t\tpos += ret;\n\t\t}\n\t}\n\n\tlog_rinfo(ls, \"generation %u slots %d%s\", gen, num_slots, line);\n}\n\nint dlm_slots_copy_in(struct dlm_ls *ls)\n{\n\tstruct dlm_member *memb;\n\tstruct dlm_rcom *rc = ls->ls_recover_buf;\n\tstruct rcom_config *rf = (struct rcom_config *)rc->rc_buf;\n\tstruct rcom_slot *ro0, *ro;\n\tint our_nodeid = dlm_our_nodeid();\n\tint i, num_slots;\n\tuint32_t gen;\n\n\tif (!dlm_slots_version(&rc->rc_header))\n\t\treturn -1;\n\n\tgen = le32_to_cpu(rf->rf_generation);\n\tif (gen <= ls->ls_generation) {\n\t\tlog_error(ls, \"dlm_slots_copy_in gen %u old %u\",\n\t\t\t  gen, ls->ls_generation);\n\t}\n\tls->ls_generation = gen;\n\n\tnum_slots = le16_to_cpu(rf->rf_num_slots);\n\tif (!num_slots)\n\t\treturn -1;\n\n\tro0 = (struct rcom_slot *)(rc->rc_buf + sizeof(struct rcom_config));\n\n\tlog_slots(ls, gen, num_slots, ro0, NULL, 0);\n\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tfor (i = 0, ro = ro0; i < num_slots; i++, ro++) {\n\t\t\tif (le32_to_cpu(ro->ro_nodeid) != memb->nodeid)\n\t\t\t\tcontinue;\n\t\t\tmemb->slot = le16_to_cpu(ro->ro_slot);\n\t\t\tmemb->slot_prev = memb->slot;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (memb->nodeid == our_nodeid) {\n\t\t\tif (ls->ls_slot && ls->ls_slot != memb->slot) {\n\t\t\t\tlog_error(ls, \"dlm_slots_copy_in our slot \"\n\t\t\t\t\t  \"changed %d %d\", ls->ls_slot,\n\t\t\t\t\t  memb->slot);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (!ls->ls_slot)\n\t\t\t\tls->ls_slot = memb->slot;\n\t\t}\n\n\t\tif (!memb->slot) {\n\t\t\tlog_error(ls, \"dlm_slots_copy_in nodeid %d no slot\",\n\t\t\t\t   memb->nodeid);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \n\nint dlm_slots_assign(struct dlm_ls *ls, int *num_slots, int *slots_size,\n\t\t     struct dlm_slot **slots_out, uint32_t *gen_out)\n{\n\tstruct dlm_member *memb;\n\tstruct dlm_slot *array;\n\tint our_nodeid = dlm_our_nodeid();\n\tint array_size, max_slots, i;\n\tint need = 0;\n\tint max = 0;\n\tint num = 0;\n\tuint32_t gen = 0;\n\n\t \n\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tif (memb->nodeid == our_nodeid) {\n\t\t\tmemb->slot = ls->ls_slot;\n\t\t\tmemb->generation = ls->ls_generation;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tif (memb->generation > gen)\n\t\t\tgen = memb->generation;\n\n\t\t \n\n\t\tif (memb->slot == -1)\n\t\t\treturn -1;\n\n\t\t \n\n\t\tif (!memb->slot)\n\t\t\tneed++;\n\n\t\t \n\n\t\tnum++;\n\n\t\tif (!max || max < memb->slot)\n\t\t\tmax = memb->slot;\n\n\t\t \n\n\t\tif (memb->slot_prev && memb->slot && memb->slot_prev != memb->slot) {\n\t\t\tlog_error(ls, \"nodeid %d slot changed %d %d\",\n\t\t\t\t  memb->nodeid, memb->slot_prev, memb->slot);\n\t\t\treturn -1;\n\t\t}\n\t\tmemb->slot_prev = memb->slot;\n\t}\n\n\tarray_size = max + need;\n\tarray = kcalloc(array_size, sizeof(*array), GFP_NOFS);\n\tif (!array)\n\t\treturn -ENOMEM;\n\n\tnum = 0;\n\n\t \n\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tif (!memb->slot)\n\t\t\tcontinue;\n\n\t\tif (memb->slot > array_size) {\n\t\t\tlog_error(ls, \"invalid slot number %d\", memb->slot);\n\t\t\tkfree(array);\n\t\t\treturn -1;\n\t\t}\n\n\t\tarray[memb->slot - 1].nodeid = memb->nodeid;\n\t\tarray[memb->slot - 1].slot = memb->slot;\n\t\tnum++;\n\t}\n\n\t \n\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tif (memb->slot)\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < array_size; i++) {\n\t\t\tif (array[i].nodeid)\n\t\t\t\tcontinue;\n\n\t\t\tmemb->slot = i + 1;\n\t\t\tmemb->slot_prev = memb->slot;\n\t\t\tarray[i].nodeid = memb->nodeid;\n\t\t\tarray[i].slot = memb->slot;\n\t\t\tnum++;\n\n\t\t\tif (!ls->ls_slot && memb->nodeid == our_nodeid)\n\t\t\t\tls->ls_slot = memb->slot;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!memb->slot) {\n\t\t\tlog_error(ls, \"no free slot found\");\n\t\t\tkfree(array);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tgen++;\n\n\tlog_slots(ls, gen, num, NULL, array, array_size);\n\n\tmax_slots = (DLM_MAX_APP_BUFSIZE - sizeof(struct dlm_rcom) -\n\t\t     sizeof(struct rcom_config)) / sizeof(struct rcom_slot);\n\n\tif (num > max_slots) {\n\t\tlog_error(ls, \"num_slots %d exceeds max_slots %d\",\n\t\t\t  num, max_slots);\n\t\tkfree(array);\n\t\treturn -1;\n\t}\n\n\t*gen_out = gen;\n\t*slots_out = array;\n\t*slots_size = array_size;\n\t*num_slots = num;\n\treturn 0;\n}\n\nstatic void add_ordered_member(struct dlm_ls *ls, struct dlm_member *new)\n{\n\tstruct dlm_member *memb = NULL;\n\tstruct list_head *tmp;\n\tstruct list_head *newlist = &new->list;\n\tstruct list_head *head = &ls->ls_nodes;\n\n\tlist_for_each(tmp, head) {\n\t\tmemb = list_entry(tmp, struct dlm_member, list);\n\t\tif (new->nodeid < memb->nodeid)\n\t\t\tbreak;\n\t}\n\n\tif (!memb)\n\t\tlist_add_tail(newlist, head);\n\telse {\n\t\t \n\t\tnewlist->prev = tmp->prev;\n\t\tnewlist->next = tmp;\n\t\ttmp->prev->next = newlist;\n\t\ttmp->prev = newlist;\n\t}\n}\n\nstatic int add_remote_member(int nodeid)\n{\n\tint error;\n\n\tif (nodeid == dlm_our_nodeid())\n\t\treturn 0;\n\n\terror = dlm_lowcomms_connect_node(nodeid);\n\tif (error < 0)\n\t\treturn error;\n\n\tdlm_midcomms_add_member(nodeid);\n\treturn 0;\n}\n\nstatic int dlm_add_member(struct dlm_ls *ls, struct dlm_config_node *node)\n{\n\tstruct dlm_member *memb;\n\tint error;\n\n\tmemb = kzalloc(sizeof(*memb), GFP_NOFS);\n\tif (!memb)\n\t\treturn -ENOMEM;\n\n\tmemb->nodeid = node->nodeid;\n\tmemb->weight = node->weight;\n\tmemb->comm_seq = node->comm_seq;\n\n\terror = add_remote_member(node->nodeid);\n\tif (error < 0) {\n\t\tkfree(memb);\n\t\treturn error;\n\t}\n\n\tadd_ordered_member(ls, memb);\n\tls->ls_num_nodes++;\n\treturn 0;\n}\n\nstatic struct dlm_member *find_memb(struct list_head *head, int nodeid)\n{\n\tstruct dlm_member *memb;\n\n\tlist_for_each_entry(memb, head, list) {\n\t\tif (memb->nodeid == nodeid)\n\t\t\treturn memb;\n\t}\n\treturn NULL;\n}\n\nint dlm_is_member(struct dlm_ls *ls, int nodeid)\n{\n\tif (find_memb(&ls->ls_nodes, nodeid))\n\t\treturn 1;\n\treturn 0;\n}\n\nint dlm_is_removed(struct dlm_ls *ls, int nodeid)\n{\n\tif (find_memb(&ls->ls_nodes_gone, nodeid))\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic void clear_memb_list(struct list_head *head,\n\t\t\t    void (*after_del)(int nodeid))\n{\n\tstruct dlm_member *memb;\n\n\twhile (!list_empty(head)) {\n\t\tmemb = list_entry(head->next, struct dlm_member, list);\n\t\tlist_del(&memb->list);\n\t\tif (after_del)\n\t\t\tafter_del(memb->nodeid);\n\t\tkfree(memb);\n\t}\n}\n\nstatic void remove_remote_member(int nodeid)\n{\n\tif (nodeid == dlm_our_nodeid())\n\t\treturn;\n\n\tdlm_midcomms_remove_member(nodeid);\n}\n\nvoid dlm_clear_members(struct dlm_ls *ls)\n{\n\tclear_memb_list(&ls->ls_nodes, remove_remote_member);\n\tls->ls_num_nodes = 0;\n}\n\nvoid dlm_clear_members_gone(struct dlm_ls *ls)\n{\n\tclear_memb_list(&ls->ls_nodes_gone, NULL);\n}\n\nstatic void make_member_array(struct dlm_ls *ls)\n{\n\tstruct dlm_member *memb;\n\tint i, w, x = 0, total = 0, all_zero = 0, *array;\n\n\tkfree(ls->ls_node_array);\n\tls->ls_node_array = NULL;\n\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tif (memb->weight)\n\t\t\ttotal += memb->weight;\n\t}\n\n\t \n\n\tif (!total) {\n\t\ttotal = ls->ls_num_nodes;\n\t\tall_zero = 1;\n\t}\n\n\tls->ls_total_weight = total;\n\tarray = kmalloc_array(total, sizeof(*array), GFP_NOFS);\n\tif (!array)\n\t\treturn;\n\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tif (!all_zero && !memb->weight)\n\t\t\tcontinue;\n\n\t\tif (all_zero)\n\t\t\tw = 1;\n\t\telse\n\t\t\tw = memb->weight;\n\n\t\tDLM_ASSERT(x < total, printk(\"total %d x %d\\n\", total, x););\n\n\t\tfor (i = 0; i < w; i++)\n\t\t\tarray[x++] = memb->nodeid;\n\t}\n\n\tls->ls_node_array = array;\n}\n\n \n\nstatic int ping_members(struct dlm_ls *ls, uint64_t seq)\n{\n\tstruct dlm_member *memb;\n\tint error = 0;\n\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tif (dlm_recovery_stopped(ls)) {\n\t\t\terror = -EINTR;\n\t\t\tbreak;\n\t\t}\n\t\terror = dlm_rcom_status(ls, memb->nodeid, 0, seq);\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\tif (error)\n\t\tlog_rinfo(ls, \"ping_members aborted %d last nodeid %d\",\n\t\t\t  error, ls->ls_recover_nodeid);\n\treturn error;\n}\n\nstatic void dlm_lsop_recover_prep(struct dlm_ls *ls)\n{\n\tif (!ls->ls_ops || !ls->ls_ops->recover_prep)\n\t\treturn;\n\tls->ls_ops->recover_prep(ls->ls_ops_arg);\n}\n\nstatic void dlm_lsop_recover_slot(struct dlm_ls *ls, struct dlm_member *memb)\n{\n\tstruct dlm_slot slot;\n\tuint32_t seq;\n\tint error;\n\n\tif (!ls->ls_ops || !ls->ls_ops->recover_slot)\n\t\treturn;\n\n\t \n\n\terror = dlm_comm_seq(memb->nodeid, &seq);\n\n\tif (!error && seq == memb->comm_seq)\n\t\treturn;\n\n\tslot.nodeid = memb->nodeid;\n\tslot.slot = memb->slot;\n\n\tls->ls_ops->recover_slot(ls->ls_ops_arg, &slot);\n}\n\nvoid dlm_lsop_recover_done(struct dlm_ls *ls)\n{\n\tstruct dlm_member *memb;\n\tstruct dlm_slot *slots;\n\tint i, num;\n\n\tif (!ls->ls_ops || !ls->ls_ops->recover_done)\n\t\treturn;\n\n\tnum = ls->ls_num_nodes;\n\tslots = kcalloc(num, sizeof(*slots), GFP_KERNEL);\n\tif (!slots)\n\t\treturn;\n\n\ti = 0;\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tif (i == num) {\n\t\t\tlog_error(ls, \"dlm_lsop_recover_done bad num %d\", num);\n\t\t\tgoto out;\n\t\t}\n\t\tslots[i].nodeid = memb->nodeid;\n\t\tslots[i].slot = memb->slot;\n\t\ti++;\n\t}\n\n\tls->ls_ops->recover_done(ls->ls_ops_arg, slots, num,\n\t\t\t\t ls->ls_slot, ls->ls_generation);\n out:\n\tkfree(slots);\n}\n\nstatic struct dlm_config_node *find_config_node(struct dlm_recover *rv,\n\t\t\t\t\t\tint nodeid)\n{\n\tint i;\n\n\tfor (i = 0; i < rv->nodes_count; i++) {\n\t\tif (rv->nodes[i].nodeid == nodeid)\n\t\t\treturn &rv->nodes[i];\n\t}\n\treturn NULL;\n}\n\nint dlm_recover_members(struct dlm_ls *ls, struct dlm_recover *rv, int *neg_out)\n{\n\tstruct dlm_member *memb, *safe;\n\tstruct dlm_config_node *node;\n\tint i, error, neg = 0, low = -1;\n\n\t \n\n\tlist_for_each_entry(memb, &ls->ls_nodes_gone, list) {\n\t\tlog_rinfo(ls, \"prev removed member %d\", memb->nodeid);\n\t\tneg++;\n\t}\n\n\t \n\n\tlist_for_each_entry_safe(memb, safe, &ls->ls_nodes, list) {\n\t\tnode = find_config_node(rv, memb->nodeid);\n\t\tif (node && !node->new)\n\t\t\tcontinue;\n\n\t\tif (!node) {\n\t\t\tlog_rinfo(ls, \"remove member %d\", memb->nodeid);\n\t\t} else {\n\t\t\t \n\t\t\tlog_rinfo(ls, \"remove member %d comm_seq %u %u\",\n\t\t\t\t  memb->nodeid, memb->comm_seq, node->comm_seq);\n\t\t}\n\n\t\tneg++;\n\t\tlist_move(&memb->list, &ls->ls_nodes_gone);\n\t\tremove_remote_member(memb->nodeid);\n\t\tls->ls_num_nodes--;\n\t\tdlm_lsop_recover_slot(ls, memb);\n\t}\n\n\t \n\n\tfor (i = 0; i < rv->nodes_count; i++) {\n\t\tnode = &rv->nodes[i];\n\t\tif (dlm_is_member(ls, node->nodeid))\n\t\t\tcontinue;\n\t\terror = dlm_add_member(ls, node);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tlog_rinfo(ls, \"add member %d\", node->nodeid);\n\t}\n\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tif (low == -1 || memb->nodeid < low)\n\t\t\tlow = memb->nodeid;\n\t}\n\tls->ls_low_nodeid = low;\n\n\tmake_member_array(ls);\n\t*neg_out = neg;\n\n\terror = ping_members(ls, rv->seq);\n\tlog_rinfo(ls, \"dlm_recover_members %d nodes\", ls->ls_num_nodes);\n\treturn error;\n}\n\n \n\nint dlm_ls_stop(struct dlm_ls *ls)\n{\n\tint new;\n\n\t \n\n\tdown_write(&ls->ls_recv_active);\n\n\t \n\n\tspin_lock(&ls->ls_recover_lock);\n\tset_bit(LSFL_RECOVER_STOP, &ls->ls_flags);\n\tnew = test_and_clear_bit(LSFL_RUNNING, &ls->ls_flags);\n\tls->ls_recover_seq++;\n\tspin_unlock(&ls->ls_recover_lock);\n\n\t \n\n\tup_write(&ls->ls_recv_active);\n\n\t \n\n\tif (new) {\n\t\tset_bit(LSFL_RECOVER_DOWN, &ls->ls_flags);\n\t\twake_up_process(ls->ls_recoverd_task);\n\t\twait_event(ls->ls_recover_lock_wait,\n\t\t\t   test_bit(LSFL_RECOVER_LOCK, &ls->ls_flags));\n\t}\n\n\t \n\n\tdlm_recoverd_suspend(ls);\n\n\tspin_lock(&ls->ls_recover_lock);\n\tkfree(ls->ls_slots);\n\tls->ls_slots = NULL;\n\tls->ls_num_slots = 0;\n\tls->ls_slots_size = 0;\n\tls->ls_recover_status = 0;\n\tspin_unlock(&ls->ls_recover_lock);\n\n\tdlm_recoverd_resume(ls);\n\n\tif (!ls->ls_recover_begin)\n\t\tls->ls_recover_begin = jiffies;\n\n\t \n\tif (new)\n\t\tdlm_lsop_recover_prep(ls);\n\n\treturn 0;\n}\n\nint dlm_ls_start(struct dlm_ls *ls)\n{\n\tstruct dlm_recover *rv, *rv_old;\n\tstruct dlm_config_node *nodes = NULL;\n\tint error, count;\n\n\trv = kzalloc(sizeof(*rv), GFP_NOFS);\n\tif (!rv)\n\t\treturn -ENOMEM;\n\n\terror = dlm_config_nodes(ls->ls_name, &nodes, &count);\n\tif (error < 0)\n\t\tgoto fail_rv;\n\n\tspin_lock(&ls->ls_recover_lock);\n\n\t \n\n\tif (!dlm_locking_stopped(ls)) {\n\t\tspin_unlock(&ls->ls_recover_lock);\n\t\tlog_error(ls, \"start ignored: lockspace running\");\n\t\terror = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\trv->nodes = nodes;\n\trv->nodes_count = count;\n\trv->seq = ++ls->ls_recover_seq;\n\trv_old = ls->ls_recover_args;\n\tls->ls_recover_args = rv;\n\tspin_unlock(&ls->ls_recover_lock);\n\n\tif (rv_old) {\n\t\tlog_error(ls, \"unused recovery %llx %d\",\n\t\t\t  (unsigned long long)rv_old->seq, rv_old->nodes_count);\n\t\tkfree(rv_old->nodes);\n\t\tkfree(rv_old);\n\t}\n\n\tset_bit(LSFL_RECOVER_WORK, &ls->ls_flags);\n\twake_up_process(ls->ls_recoverd_task);\n\treturn 0;\n\n fail:\n\tkfree(nodes);\n fail_rv:\n\tkfree(rv);\n\treturn error;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}