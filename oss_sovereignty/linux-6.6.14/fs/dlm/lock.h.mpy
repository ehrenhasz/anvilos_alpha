{
  "module_name": "lock.h",
  "hash_id": "6df0cb40a49e2920ec53164e7c25ee631110e751d015234a1a5eacb507d7a430",
  "original_prompt": "Ingested from linux-6.6.14/fs/dlm/lock.h",
  "human_readable_source": " \n \n\n#ifndef __LOCK_DOT_H__\n#define __LOCK_DOT_H__\n\nvoid dlm_dump_rsb(struct dlm_rsb *r);\nvoid dlm_dump_rsb_name(struct dlm_ls *ls, const char *name, int len);\nvoid dlm_print_lkb(struct dlm_lkb *lkb);\nvoid dlm_receive_message_saved(struct dlm_ls *ls, const struct dlm_message *ms,\n\t\t\t       uint32_t saved_seq);\nvoid dlm_receive_buffer(const union dlm_packet *p, int nodeid);\nint dlm_modes_compat(int mode1, int mode2);\nvoid dlm_put_rsb(struct dlm_rsb *r);\nvoid dlm_hold_rsb(struct dlm_rsb *r);\nint dlm_put_lkb(struct dlm_lkb *lkb);\nvoid dlm_scan_rsbs(struct dlm_ls *ls);\nint dlm_lock_recovery_try(struct dlm_ls *ls);\nvoid dlm_unlock_recovery(struct dlm_ls *ls);\n\nint dlm_master_lookup(struct dlm_ls *ls, int from_nodeid, const char *name,\n\t\t      int len, unsigned int flags, int *r_nodeid, int *result);\n\nint dlm_search_rsb_tree(struct rb_root *tree, const void *name, int len,\n\t\t\tstruct dlm_rsb **r_ret);\n\nvoid dlm_recover_purge(struct dlm_ls *ls);\nvoid dlm_purge_mstcpy_locks(struct dlm_rsb *r);\nvoid dlm_recover_grant(struct dlm_ls *ls);\nint dlm_recover_waiters_post(struct dlm_ls *ls);\nvoid dlm_recover_waiters_pre(struct dlm_ls *ls);\nint dlm_recover_master_copy(struct dlm_ls *ls, const struct dlm_rcom *rc,\n\t\t\t    __le32 *rl_remid, __le32 *rl_result);\nint dlm_recover_process_copy(struct dlm_ls *ls, const struct dlm_rcom *rc,\n\t\t\t     uint64_t seq);\n\nint dlm_user_request(struct dlm_ls *ls, struct dlm_user_args *ua, int mode,\n\tuint32_t flags, void *name, unsigned int namelen);\nint dlm_user_convert(struct dlm_ls *ls, struct dlm_user_args *ua_tmp,\n\tint mode, uint32_t flags, uint32_t lkid, char *lvb_in);\nint dlm_user_adopt_orphan(struct dlm_ls *ls, struct dlm_user_args *ua_tmp,\n\tint mode, uint32_t flags, void *name, unsigned int namelen,\n\tuint32_t *lkid);\nint dlm_user_unlock(struct dlm_ls *ls, struct dlm_user_args *ua_tmp,\n\tuint32_t flags, uint32_t lkid, char *lvb_in);\nint dlm_user_cancel(struct dlm_ls *ls,  struct dlm_user_args *ua_tmp,\n\tuint32_t flags, uint32_t lkid);\nint dlm_user_purge(struct dlm_ls *ls, struct dlm_user_proc *proc,\n\tint nodeid, int pid);\nint dlm_user_deadlock(struct dlm_ls *ls, uint32_t flags, uint32_t lkid);\nvoid dlm_clear_proc_locks(struct dlm_ls *ls, struct dlm_user_proc *proc);\nint dlm_debug_add_lkb(struct dlm_ls *ls, uint32_t lkb_id, char *name, int len,\n\t\t      int lkb_nodeid, unsigned int lkb_flags, int lkb_status);\nint dlm_debug_add_lkb_to_waiters(struct dlm_ls *ls, uint32_t lkb_id,\n\t\t\t\t int mstype, int to_nodeid);\n\nstatic inline int is_master(struct dlm_rsb *r)\n{\n\treturn !r->res_nodeid;\n}\n\nstatic inline void lock_rsb(struct dlm_rsb *r)\n{\n\tmutex_lock(&r->res_mutex);\n}\n\nstatic inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}\n\n#endif\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}