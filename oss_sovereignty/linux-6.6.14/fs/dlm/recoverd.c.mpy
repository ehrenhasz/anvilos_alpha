{
  "module_name": "recoverd.c",
  "hash_id": "c078ac6ee124d4c0cb20493b5e2764f88420939e695ede506b9ed18e9b094a71",
  "original_prompt": "Ingested from linux-6.6.14/fs/dlm/recoverd.c",
  "human_readable_source": "\n \n\n#include \"dlm_internal.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"ast.h\"\n#include \"recover.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"requestqueue.h\"\n#include \"recoverd.h\"\n\n\n \n\nstatic int enable_locking(struct dlm_ls *ls, uint64_t seq)\n{\n\tint error = -EINTR;\n\n\tdown_write(&ls->ls_recv_active);\n\n\tspin_lock(&ls->ls_recover_lock);\n\tif (ls->ls_recover_seq == seq) {\n\t\tset_bit(LSFL_RUNNING, &ls->ls_flags);\n\t\t \n\t\tup_write(&ls->ls_in_recovery);\n\t\tclear_bit(LSFL_RECOVER_LOCK, &ls->ls_flags);\n\t\terror = 0;\n\t}\n\tspin_unlock(&ls->ls_recover_lock);\n\n\tup_write(&ls->ls_recv_active);\n\treturn error;\n}\n\nstatic int ls_recover(struct dlm_ls *ls, struct dlm_recover *rv)\n{\n\tunsigned long start;\n\tint error, neg = 0;\n\n\tlog_rinfo(ls, \"dlm_recover %llu\", (unsigned long long)rv->seq);\n\n\tmutex_lock(&ls->ls_recoverd_active);\n\n\tdlm_callback_suspend(ls);\n\n\tdlm_clear_toss(ls);\n\n\t \n\n\tdlm_create_root_list(ls);\n\n\t \n\n\terror = dlm_recover_members(ls, rv, &neg);\n\tif (error) {\n\t\tlog_rinfo(ls, \"dlm_recover_members error %d\", error);\n\t\tgoto fail;\n\t}\n\n\tdlm_recover_dir_nodeid(ls);\n\n\tls->ls_recover_dir_sent_res = 0;\n\tls->ls_recover_dir_sent_msg = 0;\n\tls->ls_recover_locks_in = 0;\n\n\tdlm_set_recover_status(ls, DLM_RS_NODES);\n\n\terror = dlm_recover_members_wait(ls, rv->seq);\n\tif (error) {\n\t\tlog_rinfo(ls, \"dlm_recover_members_wait error %d\", error);\n\t\tgoto fail;\n\t}\n\n\tstart = jiffies;\n\n\t \n\n\terror = dlm_recover_directory(ls, rv->seq);\n\tif (error) {\n\t\tlog_rinfo(ls, \"dlm_recover_directory error %d\", error);\n\t\tgoto fail;\n\t}\n\n\tdlm_set_recover_status(ls, DLM_RS_DIR);\n\n\terror = dlm_recover_directory_wait(ls, rv->seq);\n\tif (error) {\n\t\tlog_rinfo(ls, \"dlm_recover_directory_wait error %d\", error);\n\t\tgoto fail;\n\t}\n\n\tlog_rinfo(ls, \"dlm_recover_directory %u out %u messages\",\n\t\t  ls->ls_recover_dir_sent_res, ls->ls_recover_dir_sent_msg);\n\n\t \n\n\tdlm_recover_waiters_pre(ls);\n\n\tif (dlm_recovery_stopped(ls)) {\n\t\terror = -EINTR;\n\t\tgoto fail;\n\t}\n\n\tif (neg || dlm_no_directory(ls)) {\n\t\t \n\n\t\tdlm_recover_purge(ls);\n\n\t\t \n\n\t\terror = dlm_recover_masters(ls, rv->seq);\n\t\tif (error) {\n\t\t\tlog_rinfo(ls, \"dlm_recover_masters error %d\", error);\n\t\t\tgoto fail;\n\t\t}\n\n\t\t \n\n\t\terror = dlm_recover_locks(ls, rv->seq);\n\t\tif (error) {\n\t\t\tlog_rinfo(ls, \"dlm_recover_locks error %d\", error);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tdlm_set_recover_status(ls, DLM_RS_LOCKS);\n\n\t\terror = dlm_recover_locks_wait(ls, rv->seq);\n\t\tif (error) {\n\t\t\tlog_rinfo(ls, \"dlm_recover_locks_wait error %d\", error);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tlog_rinfo(ls, \"dlm_recover_locks %u in\",\n\t\t\t  ls->ls_recover_locks_in);\n\n\t\t \n\n\t\tdlm_recover_rsbs(ls);\n\t} else {\n\t\t \n\t\tdlm_set_recover_status(ls, DLM_RS_LOCKS);\n\n\t\terror = dlm_recover_locks_wait(ls, rv->seq);\n\t\tif (error) {\n\t\t\tlog_rinfo(ls, \"dlm_recover_locks_wait error %d\", error);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tdlm_release_root_list(ls);\n\n\t \n\n\tdlm_purge_requestqueue(ls);\n\n\tdlm_set_recover_status(ls, DLM_RS_DONE);\n\n\terror = dlm_recover_done_wait(ls, rv->seq);\n\tif (error) {\n\t\tlog_rinfo(ls, \"dlm_recover_done_wait error %d\", error);\n\t\tgoto fail;\n\t}\n\n\tdlm_clear_members_gone(ls);\n\n\tdlm_callback_resume(ls);\n\n\terror = enable_locking(ls, rv->seq);\n\tif (error) {\n\t\tlog_rinfo(ls, \"enable_locking error %d\", error);\n\t\tgoto fail;\n\t}\n\n\terror = dlm_process_requestqueue(ls);\n\tif (error) {\n\t\tlog_rinfo(ls, \"dlm_process_requestqueue error %d\", error);\n\t\tgoto fail;\n\t}\n\n\terror = dlm_recover_waiters_post(ls);\n\tif (error) {\n\t\tlog_rinfo(ls, \"dlm_recover_waiters_post error %d\", error);\n\t\tgoto fail;\n\t}\n\n\tdlm_recover_grant(ls);\n\n\tlog_rinfo(ls, \"dlm_recover %llu generation %u done: %u ms\",\n\t\t  (unsigned long long)rv->seq, ls->ls_generation,\n\t\t  jiffies_to_msecs(jiffies - start));\n\tmutex_unlock(&ls->ls_recoverd_active);\n\n\treturn 0;\n\n fail:\n\tdlm_release_root_list(ls);\n\tmutex_unlock(&ls->ls_recoverd_active);\n\n\treturn error;\n}\n\n \n\nstatic void do_ls_recovery(struct dlm_ls *ls)\n{\n\tstruct dlm_recover *rv = NULL;\n\tint error;\n\n\tspin_lock(&ls->ls_recover_lock);\n\trv = ls->ls_recover_args;\n\tls->ls_recover_args = NULL;\n\tif (rv && ls->ls_recover_seq == rv->seq)\n\t\tclear_bit(LSFL_RECOVER_STOP, &ls->ls_flags);\n\tspin_unlock(&ls->ls_recover_lock);\n\n\tif (rv) {\n\t\terror = ls_recover(ls, rv);\n\t\tswitch (error) {\n\t\tcase 0:\n\t\t\tls->ls_recovery_result = 0;\n\t\t\tcomplete(&ls->ls_recovery_done);\n\n\t\t\tdlm_lsop_recover_done(ls);\n\t\t\tbreak;\n\t\tcase -EINTR:\n\t\t\t \n\t\t\tlog_rinfo(ls, \"%s %llu interrupted and should be queued to run again\",\n\t\t\t\t  __func__, (unsigned long long)rv->seq);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_rinfo(ls, \"%s %llu error %d\", __func__,\n\t\t\t\t  (unsigned long long)rv->seq, error);\n\n\t\t\t \n\t\t\tls->ls_recovery_result = error;\n\t\t\tcomplete(&ls->ls_recovery_done);\n\t\t\tbreak;\n\t\t}\n\n\t\tkfree(rv->nodes);\n\t\tkfree(rv);\n\t}\n}\n\nstatic int dlm_recoverd(void *arg)\n{\n\tstruct dlm_ls *ls;\n\n\tls = dlm_find_lockspace_local(arg);\n\tif (!ls) {\n\t\tlog_print(\"dlm_recoverd: no lockspace %p\", arg);\n\t\treturn -1;\n\t}\n\n\tdown_write(&ls->ls_in_recovery);\n\tset_bit(LSFL_RECOVER_LOCK, &ls->ls_flags);\n\twake_up(&ls->ls_recover_lock_wait);\n\n\twhile (1) {\n\t\t \n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (kthread_should_stop()) {\n\t\t\tset_current_state(TASK_RUNNING);\n\t\t\tbreak;\n\t\t}\n\t\tif (!test_bit(LSFL_RECOVER_WORK, &ls->ls_flags) &&\n\t\t    !test_bit(LSFL_RECOVER_DOWN, &ls->ls_flags)) {\n\t\t\tif (kthread_should_stop())\n\t\t\t\tbreak;\n\t\t\tschedule();\n\t\t}\n\t\tset_current_state(TASK_RUNNING);\n\n\t\tif (test_and_clear_bit(LSFL_RECOVER_DOWN, &ls->ls_flags)) {\n\t\t\tdown_write(&ls->ls_in_recovery);\n\t\t\tset_bit(LSFL_RECOVER_LOCK, &ls->ls_flags);\n\t\t\twake_up(&ls->ls_recover_lock_wait);\n\t\t}\n\n\t\tif (test_and_clear_bit(LSFL_RECOVER_WORK, &ls->ls_flags))\n\t\t\tdo_ls_recovery(ls);\n\t}\n\n\tif (test_bit(LSFL_RECOVER_LOCK, &ls->ls_flags))\n\t\tup_write(&ls->ls_in_recovery);\n\n\tdlm_put_lockspace(ls);\n\treturn 0;\n}\n\nint dlm_recoverd_start(struct dlm_ls *ls)\n{\n\tstruct task_struct *p;\n\tint error = 0;\n\n\tp = kthread_run(dlm_recoverd, ls, \"dlm_recoverd\");\n\tif (IS_ERR(p))\n\t\terror = PTR_ERR(p);\n\telse\n                ls->ls_recoverd_task = p;\n\treturn error;\n}\n\nvoid dlm_recoverd_stop(struct dlm_ls *ls)\n{\n\tkthread_stop(ls->ls_recoverd_task);\n}\n\nvoid dlm_recoverd_suspend(struct dlm_ls *ls)\n{\n\twake_up(&ls->ls_wait_general);\n\tmutex_lock(&ls->ls_recoverd_active);\n}\n\nvoid dlm_recoverd_resume(struct dlm_ls *ls)\n{\n\tmutex_unlock(&ls->ls_recoverd_active);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}