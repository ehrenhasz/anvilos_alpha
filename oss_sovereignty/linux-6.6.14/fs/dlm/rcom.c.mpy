{
  "module_name": "rcom.c",
  "hash_id": "3b592e8f87da05cb969746cf8e06fc09fa6884a2004fc8523075438ac8bddfd7",
  "original_prompt": "Ingested from linux-6.6.14/fs/dlm/rcom.c",
  "human_readable_source": "\n \n\n#include \"dlm_internal.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"midcomms.h\"\n#include \"rcom.h\"\n#include \"recover.h\"\n#include \"dir.h\"\n#include \"config.h\"\n#include \"memory.h\"\n#include \"lock.h\"\n#include \"util.h\"\n\nstatic int rcom_response(struct dlm_ls *ls)\n{\n\treturn test_bit(LSFL_RCOM_READY, &ls->ls_flags);\n}\n\nstatic void _create_rcom(struct dlm_ls *ls, int to_nodeid, int type, int len,\n\t\t\t struct dlm_rcom **rc_ret, char *mb, int mb_len,\n\t\t\t uint64_t seq)\n{\n\tstruct dlm_rcom *rc;\n\n\trc = (struct dlm_rcom *) mb;\n\n\trc->rc_header.h_version = cpu_to_le32(DLM_HEADER_MAJOR | DLM_HEADER_MINOR);\n\trc->rc_header.u.h_lockspace = cpu_to_le32(ls->ls_global_id);\n\trc->rc_header.h_nodeid = cpu_to_le32(dlm_our_nodeid());\n\trc->rc_header.h_length = cpu_to_le16(mb_len);\n\trc->rc_header.h_cmd = DLM_RCOM;\n\n\trc->rc_type = cpu_to_le32(type);\n\trc->rc_seq = cpu_to_le64(seq);\n\n\t*rc_ret = rc;\n}\n\nstatic int create_rcom(struct dlm_ls *ls, int to_nodeid, int type, int len,\n\t\t       struct dlm_rcom **rc_ret, struct dlm_mhandle **mh_ret,\n\t\t       uint64_t seq)\n{\n\tint mb_len = sizeof(struct dlm_rcom) + len;\n\tstruct dlm_mhandle *mh;\n\tchar *mb;\n\n\tmh = dlm_midcomms_get_mhandle(to_nodeid, mb_len, GFP_NOFS, &mb);\n\tif (!mh) {\n\t\tlog_print(\"%s to %d type %d len %d ENOBUFS\",\n\t\t\t  __func__, to_nodeid, type, len);\n\t\treturn -ENOBUFS;\n\t}\n\n\t_create_rcom(ls, to_nodeid, type, len, rc_ret, mb, mb_len, seq);\n\t*mh_ret = mh;\n\treturn 0;\n}\n\nstatic int create_rcom_stateless(struct dlm_ls *ls, int to_nodeid, int type,\n\t\t\t\t int len, struct dlm_rcom **rc_ret,\n\t\t\t\t struct dlm_msg **msg_ret, uint64_t seq)\n{\n\tint mb_len = sizeof(struct dlm_rcom) + len;\n\tstruct dlm_msg *msg;\n\tchar *mb;\n\n\tmsg = dlm_lowcomms_new_msg(to_nodeid, mb_len, GFP_NOFS, &mb,\n\t\t\t\t   NULL, NULL);\n\tif (!msg) {\n\t\tlog_print(\"create_rcom to %d type %d len %d ENOBUFS\",\n\t\t\t  to_nodeid, type, len);\n\t\treturn -ENOBUFS;\n\t}\n\n\t_create_rcom(ls, to_nodeid, type, len, rc_ret, mb, mb_len, seq);\n\t*msg_ret = msg;\n\treturn 0;\n}\n\nstatic void send_rcom(struct dlm_mhandle *mh, struct dlm_rcom *rc)\n{\n\tdlm_midcomms_commit_mhandle(mh, NULL, 0);\n}\n\nstatic void send_rcom_stateless(struct dlm_msg *msg, struct dlm_rcom *rc)\n{\n\tdlm_lowcomms_commit_msg(msg);\n\tdlm_lowcomms_put_msg(msg);\n}\n\nstatic void set_rcom_status(struct dlm_ls *ls, struct rcom_status *rs,\n\t\t\t    uint32_t flags)\n{\n\trs->rs_flags = cpu_to_le32(flags);\n}\n\n \n\nstatic void set_rcom_config(struct dlm_ls *ls, struct rcom_config *rf,\n\t\t\t    uint32_t num_slots)\n{\n\trf->rf_lvblen = cpu_to_le32(ls->ls_lvblen);\n\trf->rf_lsflags = cpu_to_le32(ls->ls_exflags);\n\n\trf->rf_our_slot = cpu_to_le16(ls->ls_slot);\n\trf->rf_num_slots = cpu_to_le16(num_slots);\n\trf->rf_generation =  cpu_to_le32(ls->ls_generation);\n}\n\nstatic int check_rcom_config(struct dlm_ls *ls, struct dlm_rcom *rc, int nodeid)\n{\n\tstruct rcom_config *rf = (struct rcom_config *) rc->rc_buf;\n\n\tif ((le32_to_cpu(rc->rc_header.h_version) & 0xFFFF0000) != DLM_HEADER_MAJOR) {\n\t\tlog_error(ls, \"version mismatch: %x nodeid %d: %x\",\n\t\t\t  DLM_HEADER_MAJOR | DLM_HEADER_MINOR, nodeid,\n\t\t\t  le32_to_cpu(rc->rc_header.h_version));\n\t\treturn -EPROTO;\n\t}\n\n\tif (le32_to_cpu(rf->rf_lvblen) != ls->ls_lvblen ||\n\t    le32_to_cpu(rf->rf_lsflags) != ls->ls_exflags) {\n\t\tlog_error(ls, \"config mismatch: %d,%x nodeid %d: %d,%x\",\n\t\t\t  ls->ls_lvblen, ls->ls_exflags, nodeid,\n\t\t\t  le32_to_cpu(rf->rf_lvblen),\n\t\t\t  le32_to_cpu(rf->rf_lsflags));\n\t\treturn -EPROTO;\n\t}\n\treturn 0;\n}\n\nstatic void allow_sync_reply(struct dlm_ls *ls, __le64 *new_seq)\n{\n\tspin_lock(&ls->ls_rcom_spin);\n\t*new_seq = cpu_to_le64(++ls->ls_rcom_seq);\n\tset_bit(LSFL_RCOM_WAIT, &ls->ls_flags);\n\tspin_unlock(&ls->ls_rcom_spin);\n}\n\nstatic void disallow_sync_reply(struct dlm_ls *ls)\n{\n\tspin_lock(&ls->ls_rcom_spin);\n\tclear_bit(LSFL_RCOM_WAIT, &ls->ls_flags);\n\tclear_bit(LSFL_RCOM_READY, &ls->ls_flags);\n\tspin_unlock(&ls->ls_rcom_spin);\n}\n\n \n\nint dlm_rcom_status(struct dlm_ls *ls, int nodeid, uint32_t status_flags,\n\t\t    uint64_t seq)\n{\n\tstruct dlm_rcom *rc;\n\tstruct dlm_msg *msg;\n\tint error = 0;\n\n\tls->ls_recover_nodeid = nodeid;\n\n\tif (nodeid == dlm_our_nodeid()) {\n\t\trc = ls->ls_recover_buf;\n\t\trc->rc_result = cpu_to_le32(dlm_recover_status(ls));\n\t\tgoto out;\n\t}\n\nretry:\n\terror = create_rcom_stateless(ls, nodeid, DLM_RCOM_STATUS,\n\t\t\t\t      sizeof(struct rcom_status), &rc, &msg,\n\t\t\t\t      seq);\n\tif (error)\n\t\tgoto out;\n\n\tset_rcom_status(ls, (struct rcom_status *)rc->rc_buf, status_flags);\n\n\tallow_sync_reply(ls, &rc->rc_id);\n\tmemset(ls->ls_recover_buf, 0, DLM_MAX_SOCKET_BUFSIZE);\n\n\tsend_rcom_stateless(msg, rc);\n\n\terror = dlm_wait_function(ls, &rcom_response);\n\tdisallow_sync_reply(ls);\n\tif (error == -ETIMEDOUT)\n\t\tgoto retry;\n\tif (error)\n\t\tgoto out;\n\n\trc = ls->ls_recover_buf;\n\n\tif (rc->rc_result == cpu_to_le32(-ESRCH)) {\n\t\t \n\t\tlog_debug(ls, \"remote node %d not ready\", nodeid);\n\t\trc->rc_result = 0;\n\t\terror = 0;\n\t} else {\n\t\terror = check_rcom_config(ls, rc, nodeid);\n\t}\n\n\t \n out:\n\treturn error;\n}\n\nstatic void receive_rcom_status(struct dlm_ls *ls,\n\t\t\t\tconst struct dlm_rcom *rc_in,\n\t\t\t\tuint64_t seq)\n{\n\tstruct dlm_rcom *rc;\n\tstruct rcom_status *rs;\n\tuint32_t status;\n\tint nodeid = le32_to_cpu(rc_in->rc_header.h_nodeid);\n\tint len = sizeof(struct rcom_config);\n\tstruct dlm_msg *msg;\n\tint num_slots = 0;\n\tint error;\n\n\tif (!dlm_slots_version(&rc_in->rc_header)) {\n\t\tstatus = dlm_recover_status(ls);\n\t\tgoto do_create;\n\t}\n\n\trs = (struct rcom_status *)rc_in->rc_buf;\n\n\tif (!(le32_to_cpu(rs->rs_flags) & DLM_RSF_NEED_SLOTS)) {\n\t\tstatus = dlm_recover_status(ls);\n\t\tgoto do_create;\n\t}\n\n\tspin_lock(&ls->ls_recover_lock);\n\tstatus = ls->ls_recover_status;\n\tnum_slots = ls->ls_num_slots;\n\tspin_unlock(&ls->ls_recover_lock);\n\tlen += num_slots * sizeof(struct rcom_slot);\n\n do_create:\n\terror = create_rcom_stateless(ls, nodeid, DLM_RCOM_STATUS_REPLY,\n\t\t\t\t      len, &rc, &msg, seq);\n\tif (error)\n\t\treturn;\n\n\trc->rc_id = rc_in->rc_id;\n\trc->rc_seq_reply = rc_in->rc_seq;\n\trc->rc_result = cpu_to_le32(status);\n\n\tset_rcom_config(ls, (struct rcom_config *)rc->rc_buf, num_slots);\n\n\tif (!num_slots)\n\t\tgoto do_send;\n\n\tspin_lock(&ls->ls_recover_lock);\n\tif (ls->ls_num_slots != num_slots) {\n\t\tspin_unlock(&ls->ls_recover_lock);\n\t\tlog_debug(ls, \"receive_rcom_status num_slots %d to %d\",\n\t\t\t  num_slots, ls->ls_num_slots);\n\t\trc->rc_result = 0;\n\t\tset_rcom_config(ls, (struct rcom_config *)rc->rc_buf, 0);\n\t\tgoto do_send;\n\t}\n\n\tdlm_slots_copy_out(ls, rc);\n\tspin_unlock(&ls->ls_recover_lock);\n\n do_send:\n\tsend_rcom_stateless(msg, rc);\n}\n\nstatic void receive_sync_reply(struct dlm_ls *ls, const struct dlm_rcom *rc_in)\n{\n\tspin_lock(&ls->ls_rcom_spin);\n\tif (!test_bit(LSFL_RCOM_WAIT, &ls->ls_flags) ||\n\t    le64_to_cpu(rc_in->rc_id) != ls->ls_rcom_seq) {\n\t\tlog_debug(ls, \"reject reply %d from %d seq %llx expect %llx\",\n\t\t\t  le32_to_cpu(rc_in->rc_type),\n\t\t\t  le32_to_cpu(rc_in->rc_header.h_nodeid),\n\t\t\t  (unsigned long long)le64_to_cpu(rc_in->rc_id),\n\t\t\t  (unsigned long long)ls->ls_rcom_seq);\n\t\tgoto out;\n\t}\n\tmemcpy(ls->ls_recover_buf, rc_in,\n\t       le16_to_cpu(rc_in->rc_header.h_length));\n\tset_bit(LSFL_RCOM_READY, &ls->ls_flags);\n\tclear_bit(LSFL_RCOM_WAIT, &ls->ls_flags);\n\twake_up(&ls->ls_wait_general);\n out:\n\tspin_unlock(&ls->ls_rcom_spin);\n}\n\nint dlm_rcom_names(struct dlm_ls *ls, int nodeid, char *last_name,\n\t\t   int last_len, uint64_t seq)\n{\n\tstruct dlm_mhandle *mh;\n\tstruct dlm_rcom *rc;\n\tint error = 0;\n\n\tls->ls_recover_nodeid = nodeid;\n\nretry:\n\terror = create_rcom(ls, nodeid, DLM_RCOM_NAMES, last_len,\n\t\t\t    &rc, &mh, seq);\n\tif (error)\n\t\tgoto out;\n\tmemcpy(rc->rc_buf, last_name, last_len);\n\n\tallow_sync_reply(ls, &rc->rc_id);\n\tmemset(ls->ls_recover_buf, 0, DLM_MAX_SOCKET_BUFSIZE);\n\n\tsend_rcom(mh, rc);\n\n\terror = dlm_wait_function(ls, &rcom_response);\n\tdisallow_sync_reply(ls);\n\tif (error == -ETIMEDOUT)\n\t\tgoto retry;\n out:\n\treturn error;\n}\n\nstatic void receive_rcom_names(struct dlm_ls *ls, const struct dlm_rcom *rc_in,\n\t\t\t       uint64_t seq)\n{\n\tstruct dlm_mhandle *mh;\n\tstruct dlm_rcom *rc;\n\tint error, inlen, outlen, nodeid;\n\n\tnodeid = le32_to_cpu(rc_in->rc_header.h_nodeid);\n\tinlen = le16_to_cpu(rc_in->rc_header.h_length) -\n\t\tsizeof(struct dlm_rcom);\n\toutlen = DLM_MAX_APP_BUFSIZE - sizeof(struct dlm_rcom);\n\n\terror = create_rcom(ls, nodeid, DLM_RCOM_NAMES_REPLY, outlen,\n\t\t\t    &rc, &mh, seq);\n\tif (error)\n\t\treturn;\n\trc->rc_id = rc_in->rc_id;\n\trc->rc_seq_reply = rc_in->rc_seq;\n\n\tdlm_copy_master_names(ls, rc_in->rc_buf, inlen, rc->rc_buf, outlen,\n\t\t\t      nodeid);\n\tsend_rcom(mh, rc);\n}\n\nint dlm_send_rcom_lookup(struct dlm_rsb *r, int dir_nodeid, uint64_t seq)\n{\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tstruct dlm_ls *ls = r->res_ls;\n\tint error;\n\n\terror = create_rcom(ls, dir_nodeid, DLM_RCOM_LOOKUP, r->res_length,\n\t\t\t    &rc, &mh, seq);\n\tif (error)\n\t\tgoto out;\n\tmemcpy(rc->rc_buf, r->res_name, r->res_length);\n\trc->rc_id = cpu_to_le64(r->res_id);\n\n\tsend_rcom(mh, rc);\n out:\n\treturn error;\n}\n\nstatic void receive_rcom_lookup(struct dlm_ls *ls,\n\t\t\t\tconst struct dlm_rcom *rc_in, uint64_t seq)\n{\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tint error, ret_nodeid, nodeid = le32_to_cpu(rc_in->rc_header.h_nodeid);\n\tint len = le16_to_cpu(rc_in->rc_header.h_length) -\n\t\tsizeof(struct dlm_rcom);\n\n\t \n\tif (rc_in->rc_id == cpu_to_le64(0xFFFFFFFF)) {\n\t\tlog_error(ls, \"receive_rcom_lookup dump from %d\", nodeid);\n\t\tdlm_dump_rsb_name(ls, rc_in->rc_buf, len);\n\t\treturn;\n\t}\n\n\terror = create_rcom(ls, nodeid, DLM_RCOM_LOOKUP_REPLY, 0, &rc, &mh,\n\t\t\t    seq);\n\tif (error)\n\t\treturn;\n\n\terror = dlm_master_lookup(ls, nodeid, rc_in->rc_buf, len,\n\t\t\t\t  DLM_LU_RECOVER_MASTER, &ret_nodeid, NULL);\n\tif (error)\n\t\tret_nodeid = error;\n\trc->rc_result = cpu_to_le32(ret_nodeid);\n\trc->rc_id = rc_in->rc_id;\n\trc->rc_seq_reply = rc_in->rc_seq;\n\n\tsend_rcom(mh, rc);\n}\n\nstatic void receive_rcom_lookup_reply(struct dlm_ls *ls,\n\t\t\t\t      const struct dlm_rcom *rc_in)\n{\n\tdlm_recover_master_reply(ls, rc_in);\n}\n\nstatic void pack_rcom_lock(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t   struct rcom_lock *rl)\n{\n\tmemset(rl, 0, sizeof(*rl));\n\n\trl->rl_ownpid = cpu_to_le32(lkb->lkb_ownpid);\n\trl->rl_lkid = cpu_to_le32(lkb->lkb_id);\n\trl->rl_exflags = cpu_to_le32(lkb->lkb_exflags);\n\trl->rl_flags = cpu_to_le32(dlm_dflags_val(lkb));\n\trl->rl_lvbseq = cpu_to_le32(lkb->lkb_lvbseq);\n\trl->rl_rqmode = lkb->lkb_rqmode;\n\trl->rl_grmode = lkb->lkb_grmode;\n\trl->rl_status = lkb->lkb_status;\n\trl->rl_wait_type = cpu_to_le16(lkb->lkb_wait_type);\n\n\tif (lkb->lkb_bastfn)\n\t\trl->rl_asts |= DLM_CB_BAST;\n\tif (lkb->lkb_astfn)\n\t\trl->rl_asts |= DLM_CB_CAST;\n\n\trl->rl_namelen = cpu_to_le16(r->res_length);\n\tmemcpy(rl->rl_name, r->res_name, r->res_length);\n\n\t \n\n\tif (lkb->lkb_lvbptr)\n\t\tmemcpy(rl->rl_lvb, lkb->lkb_lvbptr, r->res_ls->ls_lvblen);\n}\n\nint dlm_send_rcom_lock(struct dlm_rsb *r, struct dlm_lkb *lkb, uint64_t seq)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tstruct rcom_lock *rl;\n\tint error, len = sizeof(struct rcom_lock);\n\n\tif (lkb->lkb_lvbptr)\n\t\tlen += ls->ls_lvblen;\n\n\terror = create_rcom(ls, r->res_nodeid, DLM_RCOM_LOCK, len, &rc, &mh,\n\t\t\t    seq);\n\tif (error)\n\t\tgoto out;\n\n\trl = (struct rcom_lock *) rc->rc_buf;\n\tpack_rcom_lock(r, lkb, rl);\n\trc->rc_id = cpu_to_le64((uintptr_t)r);\n\n\tsend_rcom(mh, rc);\n out:\n\treturn error;\n}\n\n \nstatic void receive_rcom_lock(struct dlm_ls *ls, const struct dlm_rcom *rc_in,\n\t\t\t      uint64_t seq)\n{\n\t__le32 rl_remid, rl_result;\n\tstruct rcom_lock *rl;\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tint error, nodeid = le32_to_cpu(rc_in->rc_header.h_nodeid);\n\n\tdlm_recover_master_copy(ls, rc_in, &rl_remid, &rl_result);\n\n\terror = create_rcom(ls, nodeid, DLM_RCOM_LOCK_REPLY,\n\t\t\t    sizeof(struct rcom_lock), &rc, &mh, seq);\n\tif (error)\n\t\treturn;\n\n\tmemcpy(rc->rc_buf, rc_in->rc_buf, sizeof(struct rcom_lock));\n\trl = (struct rcom_lock *)rc->rc_buf;\n\t \n\trl->rl_remid = rl_remid;\n\trl->rl_result = rl_result;\n\n\trc->rc_id = rc_in->rc_id;\n\trc->rc_seq_reply = rc_in->rc_seq;\n\n\tsend_rcom(mh, rc);\n}\n\n \n\nint dlm_send_ls_not_ready(int nodeid, const struct dlm_rcom *rc_in)\n{\n\tstruct dlm_rcom *rc;\n\tstruct rcom_config *rf;\n\tstruct dlm_mhandle *mh;\n\tchar *mb;\n\tint mb_len = sizeof(struct dlm_rcom) + sizeof(struct rcom_config);\n\n\tmh = dlm_midcomms_get_mhandle(nodeid, mb_len, GFP_NOFS, &mb);\n\tif (!mh)\n\t\treturn -ENOBUFS;\n\n\trc = (struct dlm_rcom *) mb;\n\n\trc->rc_header.h_version = cpu_to_le32(DLM_HEADER_MAJOR | DLM_HEADER_MINOR);\n\trc->rc_header.u.h_lockspace = rc_in->rc_header.u.h_lockspace;\n\trc->rc_header.h_nodeid = cpu_to_le32(dlm_our_nodeid());\n\trc->rc_header.h_length = cpu_to_le16(mb_len);\n\trc->rc_header.h_cmd = DLM_RCOM;\n\n\trc->rc_type = cpu_to_le32(DLM_RCOM_STATUS_REPLY);\n\trc->rc_id = rc_in->rc_id;\n\trc->rc_seq_reply = rc_in->rc_seq;\n\trc->rc_result = cpu_to_le32(-ESRCH);\n\n\trf = (struct rcom_config *) rc->rc_buf;\n\trf->rf_lvblen = cpu_to_le32(~0U);\n\n\tdlm_midcomms_commit_mhandle(mh, NULL, 0);\n\n\treturn 0;\n}\n\n \n\n \n\nvoid dlm_receive_rcom(struct dlm_ls *ls, const struct dlm_rcom *rc, int nodeid)\n{\n\tint lock_size = sizeof(struct dlm_rcom) + sizeof(struct rcom_lock);\n\tint stop, reply = 0, names = 0, lookup = 0, lock = 0;\n\tuint32_t status;\n\tuint64_t seq;\n\n\tswitch (rc->rc_type) {\n\tcase cpu_to_le32(DLM_RCOM_STATUS_REPLY):\n\t\treply = 1;\n\t\tbreak;\n\tcase cpu_to_le32(DLM_RCOM_NAMES):\n\t\tnames = 1;\n\t\tbreak;\n\tcase cpu_to_le32(DLM_RCOM_NAMES_REPLY):\n\t\tnames = 1;\n\t\treply = 1;\n\t\tbreak;\n\tcase cpu_to_le32(DLM_RCOM_LOOKUP):\n\t\tlookup = 1;\n\t\tbreak;\n\tcase cpu_to_le32(DLM_RCOM_LOOKUP_REPLY):\n\t\tlookup = 1;\n\t\treply = 1;\n\t\tbreak;\n\tcase cpu_to_le32(DLM_RCOM_LOCK):\n\t\tlock = 1;\n\t\tbreak;\n\tcase cpu_to_le32(DLM_RCOM_LOCK_REPLY):\n\t\tlock = 1;\n\t\treply = 1;\n\t\tbreak;\n\t}\n\n\tspin_lock(&ls->ls_recover_lock);\n\tstatus = ls->ls_recover_status;\n\tstop = dlm_recovery_stopped(ls);\n\tseq = ls->ls_recover_seq;\n\tspin_unlock(&ls->ls_recover_lock);\n\n\tif (stop && (rc->rc_type != cpu_to_le32(DLM_RCOM_STATUS)))\n\t\tgoto ignore;\n\n\tif (reply && (le64_to_cpu(rc->rc_seq_reply) != seq))\n\t\tgoto ignore;\n\n\tif (!(status & DLM_RS_NODES) && (names || lookup || lock))\n\t\tgoto ignore;\n\n\tif (!(status & DLM_RS_DIR) && (lookup || lock))\n\t\tgoto ignore;\n\n\tswitch (rc->rc_type) {\n\tcase cpu_to_le32(DLM_RCOM_STATUS):\n\t\treceive_rcom_status(ls, rc, seq);\n\t\tbreak;\n\n\tcase cpu_to_le32(DLM_RCOM_NAMES):\n\t\treceive_rcom_names(ls, rc, seq);\n\t\tbreak;\n\n\tcase cpu_to_le32(DLM_RCOM_LOOKUP):\n\t\treceive_rcom_lookup(ls, rc, seq);\n\t\tbreak;\n\n\tcase cpu_to_le32(DLM_RCOM_LOCK):\n\t\tif (le16_to_cpu(rc->rc_header.h_length) < lock_size)\n\t\t\tgoto Eshort;\n\t\treceive_rcom_lock(ls, rc, seq);\n\t\tbreak;\n\n\tcase cpu_to_le32(DLM_RCOM_STATUS_REPLY):\n\t\treceive_sync_reply(ls, rc);\n\t\tbreak;\n\n\tcase cpu_to_le32(DLM_RCOM_NAMES_REPLY):\n\t\treceive_sync_reply(ls, rc);\n\t\tbreak;\n\n\tcase cpu_to_le32(DLM_RCOM_LOOKUP_REPLY):\n\t\treceive_rcom_lookup_reply(ls, rc);\n\t\tbreak;\n\n\tcase cpu_to_le32(DLM_RCOM_LOCK_REPLY):\n\t\tif (le16_to_cpu(rc->rc_header.h_length) < lock_size)\n\t\t\tgoto Eshort;\n\t\tdlm_recover_process_copy(ls, rc, seq);\n\t\tbreak;\n\n\tdefault:\n\t\tlog_error(ls, \"receive_rcom bad type %d\",\n\t\t\t  le32_to_cpu(rc->rc_type));\n\t}\n\treturn;\n\nignore:\n\tlog_limit(ls, \"dlm_receive_rcom ignore msg %d \"\n\t\t  \"from %d %llu %llu recover seq %llu sts %x gen %u\",\n\t\t   le32_to_cpu(rc->rc_type),\n\t\t   nodeid,\n\t\t   (unsigned long long)le64_to_cpu(rc->rc_seq),\n\t\t   (unsigned long long)le64_to_cpu(rc->rc_seq_reply),\n\t\t   (unsigned long long)seq,\n\t\t   status, ls->ls_generation);\n\treturn;\nEshort:\n\tlog_error(ls, \"recovery message %d from %d is too short\",\n\t\t  le32_to_cpu(rc->rc_type), nodeid);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}