{
  "module_name": "debug_fs.c",
  "hash_id": "4738dd7cec14722a1a00d8c7fb3c615eac8f170dc203377740428e57f2e206c7",
  "original_prompt": "Ingested from linux-6.6.14/fs/dlm/debug_fs.c",
  "human_readable_source": "\n \n\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n\n#include \"dlm_internal.h\"\n#include \"midcomms.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n\n#define DLM_DEBUG_BUF_LEN 4096\nstatic char debug_buf[DLM_DEBUG_BUF_LEN];\nstatic struct mutex debug_buf_lock;\n\nstatic struct dentry *dlm_root;\nstatic struct dentry *dlm_comms;\n\nstatic char *print_lockmode(int mode)\n{\n\tswitch (mode) {\n\tcase DLM_LOCK_IV:\n\t\treturn \"--\";\n\tcase DLM_LOCK_NL:\n\t\treturn \"NL\";\n\tcase DLM_LOCK_CR:\n\t\treturn \"CR\";\n\tcase DLM_LOCK_CW:\n\t\treturn \"CW\";\n\tcase DLM_LOCK_PR:\n\t\treturn \"PR\";\n\tcase DLM_LOCK_PW:\n\t\treturn \"PW\";\n\tcase DLM_LOCK_EX:\n\t\treturn \"EX\";\n\tdefault:\n\t\treturn \"??\";\n\t}\n}\n\nstatic void print_format1_lock(struct seq_file *s, struct dlm_lkb *lkb,\n\t\t\t       struct dlm_rsb *res)\n{\n\tseq_printf(s, \"%08x %s\", lkb->lkb_id, print_lockmode(lkb->lkb_grmode));\n\n\tif (lkb->lkb_status == DLM_LKSTS_CONVERT ||\n\t    lkb->lkb_status == DLM_LKSTS_WAITING)\n\t\tseq_printf(s, \" (%s)\", print_lockmode(lkb->lkb_rqmode));\n\n\tif (lkb->lkb_nodeid) {\n\t\tif (lkb->lkb_nodeid != res->res_nodeid)\n\t\t\tseq_printf(s, \" Remote: %3d %08x\", lkb->lkb_nodeid,\n\t\t\t\t   lkb->lkb_remid);\n\t\telse\n\t\t\tseq_printf(s, \" Master:     %08x\", lkb->lkb_remid);\n\t}\n\n\tif (lkb->lkb_wait_type)\n\t\tseq_printf(s, \" wait_type: %d\", lkb->lkb_wait_type);\n\n\tseq_putc(s, '\\n');\n}\n\nstatic void print_format1(struct dlm_rsb *res, struct seq_file *s)\n{\n\tstruct dlm_lkb *lkb;\n\tint i, lvblen = res->res_ls->ls_lvblen, recover_list, root_list;\n\n\tlock_rsb(res);\n\n\tseq_printf(s, \"\\nResource %p Name (len=%d) \\\"\", res, res->res_length);\n\n\tfor (i = 0; i < res->res_length; i++) {\n\t\tif (isprint(res->res_name[i]))\n\t\t\tseq_printf(s, \"%c\", res->res_name[i]);\n\t\telse\n\t\t\tseq_printf(s, \"%c\", '.');\n\t}\n\n\tif (res->res_nodeid > 0)\n\t\tseq_printf(s, \"\\\"\\nLocal Copy, Master is node %d\\n\",\n\t\t\t   res->res_nodeid);\n\telse if (res->res_nodeid == 0)\n\t\tseq_puts(s, \"\\\"\\nMaster Copy\\n\");\n\telse if (res->res_nodeid == -1)\n\t\tseq_printf(s, \"\\\"\\nLooking up master (lkid %x)\\n\",\n\t\t\t   res->res_first_lkid);\n\telse\n\t\tseq_printf(s, \"\\\"\\nInvalid master %d\\n\", res->res_nodeid);\n\tif (seq_has_overflowed(s))\n\t\tgoto out;\n\n\t \n\tif (res->res_lvbptr) {\n\t\tseq_puts(s, \"LVB: \");\n\t\tfor (i = 0; i < lvblen; i++) {\n\t\t\tif (i == lvblen / 2)\n\t\t\t\tseq_puts(s, \"\\n     \");\n\t\t\tseq_printf(s, \"%02x \",\n\t\t\t\t   (unsigned char) res->res_lvbptr[i]);\n\t\t}\n\t\tif (rsb_flag(res, RSB_VALNOTVALID))\n\t\t\tseq_puts(s, \" (INVALID)\");\n\t\tseq_putc(s, '\\n');\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n\n\troot_list = !list_empty(&res->res_root_list);\n\trecover_list = !list_empty(&res->res_recover_list);\n\n\tif (root_list || recover_list) {\n\t\tseq_printf(s, \"Recovery: root %d recover %d flags %lx count %d\\n\",\n\t\t\t   root_list, recover_list,\n\t\t\t   res->res_flags, res->res_recover_locks_count);\n\t}\n\n\t \n\tseq_puts(s, \"Granted Queue\\n\");\n\tlist_for_each_entry(lkb, &res->res_grantqueue, lkb_statequeue) {\n\t\tprint_format1_lock(s, lkb, res);\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n\n\tseq_puts(s, \"Conversion Queue\\n\");\n\tlist_for_each_entry(lkb, &res->res_convertqueue, lkb_statequeue) {\n\t\tprint_format1_lock(s, lkb, res);\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n\n\tseq_puts(s, \"Waiting Queue\\n\");\n\tlist_for_each_entry(lkb, &res->res_waitqueue, lkb_statequeue) {\n\t\tprint_format1_lock(s, lkb, res);\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n\n\tif (list_empty(&res->res_lookup))\n\t\tgoto out;\n\n\tseq_puts(s, \"Lookup Queue\\n\");\n\tlist_for_each_entry(lkb, &res->res_lookup, lkb_rsb_lookup) {\n\t\tseq_printf(s, \"%08x %s\",\n\t\t\t   lkb->lkb_id, print_lockmode(lkb->lkb_rqmode));\n\t\tif (lkb->lkb_wait_type)\n\t\t\tseq_printf(s, \" wait_type: %d\", lkb->lkb_wait_type);\n\t\tseq_putc(s, '\\n');\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n out:\n\tunlock_rsb(res);\n}\n\nstatic void print_format2_lock(struct seq_file *s, struct dlm_lkb *lkb,\n\t\t\t       struct dlm_rsb *r)\n{\n\tu64 xid = 0;\n\tu64 us;\n\n\tif (test_bit(DLM_DFL_USER_BIT, &lkb->lkb_dflags)) {\n\t\tif (lkb->lkb_ua)\n\t\t\txid = lkb->lkb_ua->xid;\n\t}\n\n\t \n\tus = ktime_to_us(ktime_sub(ktime_get(), lkb->lkb_timestamp));\n\n\t \n\n\tseq_printf(s, \"%x %d %x %u %llu %x %x %d %d %d %llu %u %d \\\"%s\\\"\\n\",\n\t\t   lkb->lkb_id,\n\t\t   lkb->lkb_nodeid,\n\t\t   lkb->lkb_remid,\n\t\t   lkb->lkb_ownpid,\n\t\t   (unsigned long long)xid,\n\t\t   lkb->lkb_exflags,\n\t\t   dlm_iflags_val(lkb),\n\t\t   lkb->lkb_status,\n\t\t   lkb->lkb_grmode,\n\t\t   lkb->lkb_rqmode,\n\t\t   (unsigned long long)us,\n\t\t   r->res_nodeid,\n\t\t   r->res_length,\n\t\t   r->res_name);\n}\n\nstatic void print_format2(struct dlm_rsb *r, struct seq_file *s)\n{\n\tstruct dlm_lkb *lkb;\n\n\tlock_rsb(r);\n\n\tlist_for_each_entry(lkb, &r->res_grantqueue, lkb_statequeue) {\n\t\tprint_format2_lock(s, lkb, r);\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n\n\tlist_for_each_entry(lkb, &r->res_convertqueue, lkb_statequeue) {\n\t\tprint_format2_lock(s, lkb, r);\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n\n\tlist_for_each_entry(lkb, &r->res_waitqueue, lkb_statequeue) {\n\t\tprint_format2_lock(s, lkb, r);\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n out:\n\tunlock_rsb(r);\n}\n\nstatic void print_format3_lock(struct seq_file *s, struct dlm_lkb *lkb,\n\t\t\t      int rsb_lookup)\n{\n\tu64 xid = 0;\n\n\tif (test_bit(DLM_DFL_USER_BIT, &lkb->lkb_dflags)) {\n\t\tif (lkb->lkb_ua)\n\t\t\txid = lkb->lkb_ua->xid;\n\t}\n\n\tseq_printf(s, \"lkb %x %d %x %u %llu %x %x %d %d %d %d %d %d %u %llu %llu\\n\",\n\t\t   lkb->lkb_id,\n\t\t   lkb->lkb_nodeid,\n\t\t   lkb->lkb_remid,\n\t\t   lkb->lkb_ownpid,\n\t\t   (unsigned long long)xid,\n\t\t   lkb->lkb_exflags,\n\t\t   dlm_iflags_val(lkb),\n\t\t   lkb->lkb_status,\n\t\t   lkb->lkb_grmode,\n\t\t   lkb->lkb_rqmode,\n\t\t   lkb->lkb_last_bast_mode,\n\t\t   rsb_lookup,\n\t\t   lkb->lkb_wait_type,\n\t\t   lkb->lkb_lvbseq,\n\t\t   (unsigned long long)ktime_to_ns(lkb->lkb_timestamp),\n\t\t   (unsigned long long)ktime_to_ns(lkb->lkb_last_bast_time));\n}\n\nstatic void print_format3(struct dlm_rsb *r, struct seq_file *s)\n{\n\tstruct dlm_lkb *lkb;\n\tint i, lvblen = r->res_ls->ls_lvblen;\n\tint print_name = 1;\n\n\tlock_rsb(r);\n\n\tseq_printf(s, \"rsb %p %d %x %lx %d %d %u %d \",\n\t\t   r,\n\t\t   r->res_nodeid,\n\t\t   r->res_first_lkid,\n\t\t   r->res_flags,\n\t\t   !list_empty(&r->res_root_list),\n\t\t   !list_empty(&r->res_recover_list),\n\t\t   r->res_recover_locks_count,\n\t\t   r->res_length);\n\tif (seq_has_overflowed(s))\n\t\tgoto out;\n\n\tfor (i = 0; i < r->res_length; i++) {\n\t\tif (!isascii(r->res_name[i]) || !isprint(r->res_name[i]))\n\t\t\tprint_name = 0;\n\t}\n\n\tseq_puts(s, print_name ? \"str \" : \"hex\");\n\n\tfor (i = 0; i < r->res_length; i++) {\n\t\tif (print_name)\n\t\t\tseq_printf(s, \"%c\", r->res_name[i]);\n\t\telse\n\t\t\tseq_printf(s, \" %02x\", (unsigned char)r->res_name[i]);\n\t}\n\tseq_putc(s, '\\n');\n\tif (seq_has_overflowed(s))\n\t\tgoto out;\n\n\tif (!r->res_lvbptr)\n\t\tgoto do_locks;\n\n\tseq_printf(s, \"lvb %u %d\", r->res_lvbseq, lvblen);\n\n\tfor (i = 0; i < lvblen; i++)\n\t\tseq_printf(s, \" %02x\", (unsigned char)r->res_lvbptr[i]);\n\tseq_putc(s, '\\n');\n\tif (seq_has_overflowed(s))\n\t\tgoto out;\n\n do_locks:\n\tlist_for_each_entry(lkb, &r->res_grantqueue, lkb_statequeue) {\n\t\tprint_format3_lock(s, lkb, 0);\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n\n\tlist_for_each_entry(lkb, &r->res_convertqueue, lkb_statequeue) {\n\t\tprint_format3_lock(s, lkb, 0);\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n\n\tlist_for_each_entry(lkb, &r->res_waitqueue, lkb_statequeue) {\n\t\tprint_format3_lock(s, lkb, 0);\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n\n\tlist_for_each_entry(lkb, &r->res_lookup, lkb_rsb_lookup) {\n\t\tprint_format3_lock(s, lkb, 1);\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n out:\n\tunlock_rsb(r);\n}\n\nstatic void print_format4(struct dlm_rsb *r, struct seq_file *s)\n{\n\tint our_nodeid = dlm_our_nodeid();\n\tint print_name = 1;\n\tint i;\n\n\tlock_rsb(r);\n\n\tseq_printf(s, \"rsb %p %d %d %d %d %lu %lx %d \",\n\t\t   r,\n\t\t   r->res_nodeid,\n\t\t   r->res_master_nodeid,\n\t\t   r->res_dir_nodeid,\n\t\t   our_nodeid,\n\t\t   r->res_toss_time,\n\t\t   r->res_flags,\n\t\t   r->res_length);\n\n\tfor (i = 0; i < r->res_length; i++) {\n\t\tif (!isascii(r->res_name[i]) || !isprint(r->res_name[i]))\n\t\t\tprint_name = 0;\n\t}\n\n\tseq_puts(s, print_name ? \"str \" : \"hex\");\n\n\tfor (i = 0; i < r->res_length; i++) {\n\t\tif (print_name)\n\t\t\tseq_printf(s, \"%c\", r->res_name[i]);\n\t\telse\n\t\t\tseq_printf(s, \" %02x\", (unsigned char)r->res_name[i]);\n\t}\n\tseq_putc(s, '\\n');\n\tunlock_rsb(r);\n}\n\nstatic void print_format5_lock(struct seq_file *s, struct dlm_lkb *lkb)\n{\n\tstruct dlm_callback *cb;\n\n\t \n\n\tspin_lock(&lkb->lkb_cb_lock);\n\tlist_for_each_entry(cb, &lkb->lkb_callbacks, list) {\n\t\tseq_printf(s, \"%x %x %d %x %d %x\\n\",\n\t\t\t   lkb->lkb_id,\n\t\t\t   dlm_iflags_val(lkb),\n\t\t\t   cb->mode,\n\t\t\t   cb->flags,\n\t\t\t   cb->sb_status,\n\t\t\t   cb->sb_flags);\n\t}\n\tspin_unlock(&lkb->lkb_cb_lock);\n}\n\nstatic void print_format5(struct dlm_rsb *r, struct seq_file *s)\n{\n\tstruct dlm_lkb *lkb;\n\n\tlock_rsb(r);\n\n\tlist_for_each_entry(lkb, &r->res_grantqueue, lkb_statequeue) {\n\t\tprint_format5_lock(s, lkb);\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n\n\tlist_for_each_entry(lkb, &r->res_convertqueue, lkb_statequeue) {\n\t\tprint_format5_lock(s, lkb);\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n\n\tlist_for_each_entry(lkb, &r->res_waitqueue, lkb_statequeue) {\n\t\tprint_format5_lock(s, lkb);\n\t\tif (seq_has_overflowed(s))\n\t\t\tgoto out;\n\t}\n out:\n\tunlock_rsb(r);\n}\n\nstruct rsbtbl_iter {\n\tstruct dlm_rsb *rsb;\n\tunsigned bucket;\n\tint format;\n\tint header;\n};\n\n \n\nstatic int table_seq_show(struct seq_file *seq, void *iter_ptr)\n{\n\tstruct rsbtbl_iter *ri = iter_ptr;\n\n\tswitch (ri->format) {\n\tcase 1:\n\t\tprint_format1(ri->rsb, seq);\n\t\tbreak;\n\tcase 2:\n\t\tif (ri->header) {\n\t\t\tseq_puts(seq, \"id nodeid remid pid xid exflags flags sts grmode rqmode time_ms r_nodeid r_len r_name\\n\");\n\t\t\tri->header = 0;\n\t\t}\n\t\tprint_format2(ri->rsb, seq);\n\t\tbreak;\n\tcase 3:\n\t\tif (ri->header) {\n\t\t\tseq_puts(seq, \"version rsb 1.1 lvb 1.1 lkb 1.1\\n\");\n\t\t\tri->header = 0;\n\t\t}\n\t\tprint_format3(ri->rsb, seq);\n\t\tbreak;\n\tcase 4:\n\t\tif (ri->header) {\n\t\t\tseq_puts(seq, \"version 4 rsb 2\\n\");\n\t\t\tri->header = 0;\n\t\t}\n\t\tprint_format4(ri->rsb, seq);\n\t\tbreak;\n\tcase 5:\n\t\tif (ri->header) {\n\t\t\tseq_puts(seq, \"lkb_id lkb_flags mode flags sb_status sb_flags\\n\");\n\t\t\tri->header = 0;\n\t\t}\n\t\tprint_format5(ri->rsb, seq);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct seq_operations format1_seq_ops;\nstatic const struct seq_operations format2_seq_ops;\nstatic const struct seq_operations format3_seq_ops;\nstatic const struct seq_operations format4_seq_ops;\nstatic const struct seq_operations format5_seq_ops;\n\nstatic void *table_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\tstruct rb_root *tree;\n\tstruct rb_node *node;\n\tstruct dlm_ls *ls = seq->private;\n\tstruct rsbtbl_iter *ri;\n\tstruct dlm_rsb *r;\n\tloff_t n = *pos;\n\tunsigned bucket, entry;\n\tint toss = (seq->op == &format4_seq_ops);\n\n\tbucket = n >> 32;\n\tentry = n & ((1LL << 32) - 1);\n\n\tif (bucket >= ls->ls_rsbtbl_size)\n\t\treturn NULL;\n\n\tri = kzalloc(sizeof(*ri), GFP_NOFS);\n\tif (!ri)\n\t\treturn NULL;\n\tif (n == 0)\n\t\tri->header = 1;\n\tif (seq->op == &format1_seq_ops)\n\t\tri->format = 1;\n\tif (seq->op == &format2_seq_ops)\n\t\tri->format = 2;\n\tif (seq->op == &format3_seq_ops)\n\t\tri->format = 3;\n\tif (seq->op == &format4_seq_ops)\n\t\tri->format = 4;\n\tif (seq->op == &format5_seq_ops)\n\t\tri->format = 5;\n\n\ttree = toss ? &ls->ls_rsbtbl[bucket].toss : &ls->ls_rsbtbl[bucket].keep;\n\n\tspin_lock(&ls->ls_rsbtbl[bucket].lock);\n\tif (!RB_EMPTY_ROOT(tree)) {\n\t\tfor (node = rb_first(tree); node; node = rb_next(node)) {\n\t\t\tr = rb_entry(node, struct dlm_rsb, res_hashnode);\n\t\t\tif (!entry--) {\n\t\t\t\tdlm_hold_rsb(r);\n\t\t\t\tri->rsb = r;\n\t\t\t\tri->bucket = bucket;\n\t\t\t\tspin_unlock(&ls->ls_rsbtbl[bucket].lock);\n\t\t\t\treturn ri;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock(&ls->ls_rsbtbl[bucket].lock);\n\n\t \n\n\t \n\tn &= ~((1LL << 32) - 1);\n\n\twhile (1) {\n\t\tbucket++;\n\t\tn += 1LL << 32;\n\n\t\tif (bucket >= ls->ls_rsbtbl_size) {\n\t\t\tkfree(ri);\n\t\t\treturn NULL;\n\t\t}\n\t\ttree = toss ? &ls->ls_rsbtbl[bucket].toss : &ls->ls_rsbtbl[bucket].keep;\n\n\t\tspin_lock(&ls->ls_rsbtbl[bucket].lock);\n\t\tif (!RB_EMPTY_ROOT(tree)) {\n\t\t\tnode = rb_first(tree);\n\t\t\tr = rb_entry(node, struct dlm_rsb, res_hashnode);\n\t\t\tdlm_hold_rsb(r);\n\t\t\tri->rsb = r;\n\t\t\tri->bucket = bucket;\n\t\t\tspin_unlock(&ls->ls_rsbtbl[bucket].lock);\n\t\t\t*pos = n;\n\t\t\treturn ri;\n\t\t}\n\t\tspin_unlock(&ls->ls_rsbtbl[bucket].lock);\n\t}\n}\n\nstatic void *table_seq_next(struct seq_file *seq, void *iter_ptr, loff_t *pos)\n{\n\tstruct dlm_ls *ls = seq->private;\n\tstruct rsbtbl_iter *ri = iter_ptr;\n\tstruct rb_root *tree;\n\tstruct rb_node *next;\n\tstruct dlm_rsb *r, *rp;\n\tloff_t n = *pos;\n\tunsigned bucket;\n\tint toss = (seq->op == &format4_seq_ops);\n\n\tbucket = n >> 32;\n\n\t \n\n\tspin_lock(&ls->ls_rsbtbl[bucket].lock);\n\trp = ri->rsb;\n\tnext = rb_next(&rp->res_hashnode);\n\n\tif (next) {\n\t\tr = rb_entry(next, struct dlm_rsb, res_hashnode);\n\t\tdlm_hold_rsb(r);\n\t\tri->rsb = r;\n\t\tspin_unlock(&ls->ls_rsbtbl[bucket].lock);\n\t\tdlm_put_rsb(rp);\n\t\t++*pos;\n\t\treturn ri;\n\t}\n\tspin_unlock(&ls->ls_rsbtbl[bucket].lock);\n\tdlm_put_rsb(rp);\n\n\t \n\n\t \n\tn &= ~((1LL << 32) - 1);\n\n\twhile (1) {\n\t\tbucket++;\n\t\tn += 1LL << 32;\n\n\t\tif (bucket >= ls->ls_rsbtbl_size) {\n\t\t\tkfree(ri);\n\t\t\t++*pos;\n\t\t\treturn NULL;\n\t\t}\n\t\ttree = toss ? &ls->ls_rsbtbl[bucket].toss : &ls->ls_rsbtbl[bucket].keep;\n\n\t\tspin_lock(&ls->ls_rsbtbl[bucket].lock);\n\t\tif (!RB_EMPTY_ROOT(tree)) {\n\t\t\tnext = rb_first(tree);\n\t\t\tr = rb_entry(next, struct dlm_rsb, res_hashnode);\n\t\t\tdlm_hold_rsb(r);\n\t\t\tri->rsb = r;\n\t\t\tri->bucket = bucket;\n\t\t\tspin_unlock(&ls->ls_rsbtbl[bucket].lock);\n\t\t\t*pos = n;\n\t\t\treturn ri;\n\t\t}\n\t\tspin_unlock(&ls->ls_rsbtbl[bucket].lock);\n\t}\n}\n\nstatic void table_seq_stop(struct seq_file *seq, void *iter_ptr)\n{\n\tstruct rsbtbl_iter *ri = iter_ptr;\n\n\tif (ri) {\n\t\tdlm_put_rsb(ri->rsb);\n\t\tkfree(ri);\n\t}\n}\n\nstatic const struct seq_operations format1_seq_ops = {\n\t.start = table_seq_start,\n\t.next  = table_seq_next,\n\t.stop  = table_seq_stop,\n\t.show  = table_seq_show,\n};\n\nstatic const struct seq_operations format2_seq_ops = {\n\t.start = table_seq_start,\n\t.next  = table_seq_next,\n\t.stop  = table_seq_stop,\n\t.show  = table_seq_show,\n};\n\nstatic const struct seq_operations format3_seq_ops = {\n\t.start = table_seq_start,\n\t.next  = table_seq_next,\n\t.stop  = table_seq_stop,\n\t.show  = table_seq_show,\n};\n\nstatic const struct seq_operations format4_seq_ops = {\n\t.start = table_seq_start,\n\t.next  = table_seq_next,\n\t.stop  = table_seq_stop,\n\t.show  = table_seq_show,\n};\n\nstatic const struct seq_operations format5_seq_ops = {\n\t.start = table_seq_start,\n\t.next  = table_seq_next,\n\t.stop  = table_seq_stop,\n\t.show  = table_seq_show,\n};\n\nstatic const struct file_operations format1_fops;\nstatic const struct file_operations format2_fops;\nstatic const struct file_operations format3_fops;\nstatic const struct file_operations format4_fops;\nstatic const struct file_operations format5_fops;\n\nstatic int table_open1(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq;\n\tint ret;\n\n\tret = seq_open(file, &format1_seq_ops);\n\tif (ret)\n\t\treturn ret;\n\n\tseq = file->private_data;\n\tseq->private = inode->i_private;  \n\treturn 0;\n}\n\nstatic int table_open2(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq;\n\tint ret;\n\n\tret = seq_open(file, &format2_seq_ops);\n\tif (ret)\n\t\treturn ret;\n\n\tseq = file->private_data;\n\tseq->private = inode->i_private;  \n\treturn 0;\n}\n\nstatic ssize_t table_write2(struct file *file, const char __user *user_buf,\n\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct seq_file *seq = file->private_data;\n\tint n, len, lkb_nodeid, lkb_status, error;\n\tchar name[DLM_RESNAME_MAXLEN + 1] = {};\n\tstruct dlm_ls *ls = seq->private;\n\tunsigned int lkb_flags;\n\tchar buf[256] = {};\n\tuint32_t lkb_id;\n\n\tif (copy_from_user(buf, user_buf,\n\t\t\t   min_t(size_t, sizeof(buf) - 1, count)))\n\t\treturn -EFAULT;\n\n\tn = sscanf(buf, \"%x %\" __stringify(DLM_RESNAME_MAXLEN) \"s %x %d %d\",\n\t\t   &lkb_id, name, &lkb_flags, &lkb_nodeid, &lkb_status);\n\tif (n != 5)\n\t\treturn -EINVAL;\n\n\tlen = strnlen(name, DLM_RESNAME_MAXLEN);\n\terror = dlm_debug_add_lkb(ls, lkb_id, name, len, lkb_flags,\n\t\t\t\t  lkb_nodeid, lkb_status);\n\tif (error)\n\t\treturn error;\n\n\treturn count;\n}\n\nstatic int table_open3(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq;\n\tint ret;\n\n\tret = seq_open(file, &format3_seq_ops);\n\tif (ret)\n\t\treturn ret;\n\n\tseq = file->private_data;\n\tseq->private = inode->i_private;  \n\treturn 0;\n}\n\nstatic int table_open4(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq;\n\tint ret;\n\n\tret = seq_open(file, &format4_seq_ops);\n\tif (ret)\n\t\treturn ret;\n\n\tseq = file->private_data;\n\tseq->private = inode->i_private;  \n\treturn 0;\n}\n\nstatic int table_open5(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq;\n\tint ret;\n\n\tret = seq_open(file, &format5_seq_ops);\n\tif (ret)\n\t\treturn ret;\n\n\tseq = file->private_data;\n\tseq->private = inode->i_private;  \n\treturn 0;\n}\n\nstatic const struct file_operations format1_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = table_open1,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release\n};\n\nstatic const struct file_operations format2_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = table_open2,\n\t.read    = seq_read,\n\t.write   = table_write2,\n\t.llseek  = seq_lseek,\n\t.release = seq_release\n};\n\nstatic const struct file_operations format3_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = table_open3,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release\n};\n\nstatic const struct file_operations format4_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = table_open4,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release\n};\n\nstatic const struct file_operations format5_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = table_open5,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release\n};\n\n \nstatic ssize_t waiters_read(struct file *file, char __user *userbuf,\n\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct dlm_ls *ls = file->private_data;\n\tstruct dlm_lkb *lkb;\n\tsize_t len = DLM_DEBUG_BUF_LEN, pos = 0, ret, rv;\n\n\tmutex_lock(&debug_buf_lock);\n\tmutex_lock(&ls->ls_waiters_mutex);\n\tmemset(debug_buf, 0, sizeof(debug_buf));\n\n\tlist_for_each_entry(lkb, &ls->ls_waiters, lkb_wait_reply) {\n\t\tret = snprintf(debug_buf + pos, len - pos, \"%x %d %d %s\\n\",\n\t\t\t       lkb->lkb_id, lkb->lkb_wait_type,\n\t\t\t       lkb->lkb_nodeid, lkb->lkb_resource->res_name);\n\t\tif (ret >= len - pos)\n\t\t\tbreak;\n\t\tpos += ret;\n\t}\n\tmutex_unlock(&ls->ls_waiters_mutex);\n\n\trv = simple_read_from_buffer(userbuf, count, ppos, debug_buf, pos);\n\tmutex_unlock(&debug_buf_lock);\n\treturn rv;\n}\n\nstatic ssize_t waiters_write(struct file *file, const char __user *user_buf,\n\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct dlm_ls *ls = file->private_data;\n\tint mstype, to_nodeid;\n\tchar buf[128] = {};\n\tuint32_t lkb_id;\n\tint n, error;\n\n\tif (copy_from_user(buf, user_buf,\n\t\t\t   min_t(size_t, sizeof(buf) - 1, count)))\n\t\treturn -EFAULT;\n\n\tn = sscanf(buf, \"%x %d %d\", &lkb_id, &mstype, &to_nodeid);\n\tif (n != 3)\n\t\treturn -EINVAL;\n\n\terror = dlm_debug_add_lkb_to_waiters(ls, lkb_id, mstype, to_nodeid);\n\tif (error)\n\t\treturn error;\n\n\treturn count;\n}\n\nstatic const struct file_operations waiters_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = simple_open,\n\t.read    = waiters_read,\n\t.write   = waiters_write,\n\t.llseek  = default_llseek,\n};\n\nvoid dlm_delete_debug_file(struct dlm_ls *ls)\n{\n\tdebugfs_remove(ls->ls_debug_rsb_dentry);\n\tdebugfs_remove(ls->ls_debug_waiters_dentry);\n\tdebugfs_remove(ls->ls_debug_locks_dentry);\n\tdebugfs_remove(ls->ls_debug_all_dentry);\n\tdebugfs_remove(ls->ls_debug_toss_dentry);\n\tdebugfs_remove(ls->ls_debug_queued_asts_dentry);\n}\n\nstatic int dlm_state_show(struct seq_file *file, void *offset)\n{\n\tseq_printf(file, \"%s\\n\", dlm_midcomms_state(file->private));\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(dlm_state);\n\nstatic int dlm_flags_show(struct seq_file *file, void *offset)\n{\n\tseq_printf(file, \"%lu\\n\", dlm_midcomms_flags(file->private));\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(dlm_flags);\n\nstatic int dlm_send_queue_cnt_show(struct seq_file *file, void *offset)\n{\n\tseq_printf(file, \"%d\\n\", dlm_midcomms_send_queue_cnt(file->private));\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(dlm_send_queue_cnt);\n\nstatic int dlm_version_show(struct seq_file *file, void *offset)\n{\n\tseq_printf(file, \"0x%08x\\n\", dlm_midcomms_version(file->private));\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(dlm_version);\n\nstatic ssize_t dlm_rawmsg_write(struct file *fp, const char __user *user_buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tvoid *buf;\n\tint ret;\n\n\tif (count > PAGE_SIZE || count < sizeof(struct dlm_header))\n\t\treturn -EINVAL;\n\n\tbuf = kmalloc(PAGE_SIZE, GFP_NOFS);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(buf, user_buf, count)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tret = dlm_midcomms_rawmsg_send(fp->private_data, buf, count);\n\tif (ret)\n\t\tgoto out;\n\n\tkfree(buf);\n\treturn count;\n\nout:\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic const struct file_operations dlm_rawmsg_fops = {\n\t.open\t= simple_open,\n\t.write\t= dlm_rawmsg_write,\n\t.llseek\t= no_llseek,\n};\n\nvoid *dlm_create_debug_comms_file(int nodeid, void *data)\n{\n\tstruct dentry *d_node;\n\tchar name[256];\n\n\tmemset(name, 0, sizeof(name));\n\tsnprintf(name, 256, \"%d\", nodeid);\n\n\td_node = debugfs_create_dir(name, dlm_comms);\n\tdebugfs_create_file(\"state\", 0444, d_node, data, &dlm_state_fops);\n\tdebugfs_create_file(\"flags\", 0444, d_node, data, &dlm_flags_fops);\n\tdebugfs_create_file(\"send_queue_count\", 0444, d_node, data,\n\t\t\t    &dlm_send_queue_cnt_fops);\n\tdebugfs_create_file(\"version\", 0444, d_node, data, &dlm_version_fops);\n\tdebugfs_create_file(\"rawmsg\", 0200, d_node, data, &dlm_rawmsg_fops);\n\n\treturn d_node;\n}\n\nvoid dlm_delete_debug_comms_file(void *ctx)\n{\n\tdebugfs_remove(ctx);\n}\n\nvoid dlm_create_debug_file(struct dlm_ls *ls)\n{\n\t \n\tchar name[DLM_LOCKSPACE_LEN + sizeof(\"_queued_asts\")];\n\n\t \n\n\tls->ls_debug_rsb_dentry = debugfs_create_file(ls->ls_name,\n\t\t\t\t\t\t      S_IFREG | S_IRUGO,\n\t\t\t\t\t\t      dlm_root,\n\t\t\t\t\t\t      ls,\n\t\t\t\t\t\t      &format1_fops);\n\n\t \n\n\tmemset(name, 0, sizeof(name));\n\tsnprintf(name, sizeof(name), \"%s_locks\", ls->ls_name);\n\n\tls->ls_debug_locks_dentry = debugfs_create_file(name,\n\t\t\t\t\t\t\t0644,\n\t\t\t\t\t\t\tdlm_root,\n\t\t\t\t\t\t\tls,\n\t\t\t\t\t\t\t&format2_fops);\n\n\t \n\n\tmemset(name, 0, sizeof(name));\n\tsnprintf(name, sizeof(name), \"%s_all\", ls->ls_name);\n\n\tls->ls_debug_all_dentry = debugfs_create_file(name,\n\t\t\t\t\t\t      S_IFREG | S_IRUGO,\n\t\t\t\t\t\t      dlm_root,\n\t\t\t\t\t\t      ls,\n\t\t\t\t\t\t      &format3_fops);\n\n\t \n\n\tmemset(name, 0, sizeof(name));\n\tsnprintf(name, sizeof(name), \"%s_toss\", ls->ls_name);\n\n\tls->ls_debug_toss_dentry = debugfs_create_file(name,\n\t\t\t\t\t\t       S_IFREG | S_IRUGO,\n\t\t\t\t\t\t       dlm_root,\n\t\t\t\t\t\t       ls,\n\t\t\t\t\t\t       &format4_fops);\n\n\tmemset(name, 0, sizeof(name));\n\tsnprintf(name, sizeof(name), \"%s_waiters\", ls->ls_name);\n\n\tls->ls_debug_waiters_dentry = debugfs_create_file(name,\n\t\t\t\t\t\t\t  0644,\n\t\t\t\t\t\t\t  dlm_root,\n\t\t\t\t\t\t\t  ls,\n\t\t\t\t\t\t\t  &waiters_fops);\n\n\t \n\n\tmemset(name, 0, sizeof(name));\n\tsnprintf(name, sizeof(name), \"%s_queued_asts\", ls->ls_name);\n\n\tls->ls_debug_queued_asts_dentry = debugfs_create_file(name,\n\t\t\t\t\t\t\t      0644,\n\t\t\t\t\t\t\t      dlm_root,\n\t\t\t\t\t\t\t      ls,\n\t\t\t\t\t\t\t      &format5_fops);\n}\n\nvoid __init dlm_register_debugfs(void)\n{\n\tmutex_init(&debug_buf_lock);\n\tdlm_root = debugfs_create_dir(\"dlm\", NULL);\n\tdlm_comms = debugfs_create_dir(\"comms\", dlm_root);\n}\n\nvoid dlm_unregister_debugfs(void)\n{\n\tdebugfs_remove(dlm_root);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}