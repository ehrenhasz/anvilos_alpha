{
  "module_name": "user.c",
  "hash_id": "54497f29608400eb9064336e7c76bbeb530cb4e310d116a8930cb4fe6ce0a467",
  "original_prompt": "Ingested from linux-6.6.14/fs/dlm/user.c",
  "human_readable_source": "\n \n\n#include <linux/miscdevice.h>\n#include <linux/init.h>\n#include <linux/wait.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/spinlock.h>\n#include <linux/dlm.h>\n#include <linux/dlm_device.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n\n#include <trace/events/dlm.h>\n\n#include \"dlm_internal.h\"\n#include \"lockspace.h\"\n#include \"lock.h\"\n#include \"lvb_table.h\"\n#include \"user.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"memory.h\"\n\nstatic const char name_prefix[] = \"dlm\";\nstatic const struct file_operations device_fops;\nstatic atomic_t dlm_monitor_opened;\nstatic int dlm_monitor_unused = 1;\n\n#ifdef CONFIG_COMPAT\n\nstruct dlm_lock_params32 {\n\t__u8 mode;\n\t__u8 namelen;\n\t__u16 unused;\n\t__u32 flags;\n\t__u32 lkid;\n\t__u32 parent;\n\t__u64 xid;\n\t__u64 timeout;\n\t__u32 castparam;\n\t__u32 castaddr;\n\t__u32 bastparam;\n\t__u32 bastaddr;\n\t__u32 lksb;\n\tchar lvb[DLM_USER_LVB_LEN];\n\tchar name[];\n};\n\nstruct dlm_write_request32 {\n\t__u32 version[3];\n\t__u8 cmd;\n\t__u8 is64bit;\n\t__u8 unused[2];\n\n\tunion  {\n\t\tstruct dlm_lock_params32 lock;\n\t\tstruct dlm_lspace_params lspace;\n\t\tstruct dlm_purge_params purge;\n\t} i;\n};\n\nstruct dlm_lksb32 {\n\t__u32 sb_status;\n\t__u32 sb_lkid;\n\t__u8 sb_flags;\n\t__u32 sb_lvbptr;\n};\n\nstruct dlm_lock_result32 {\n\t__u32 version[3];\n\t__u32 length;\n\t__u32 user_astaddr;\n\t__u32 user_astparam;\n\t__u32 user_lksb;\n\tstruct dlm_lksb32 lksb;\n\t__u8 bast_mode;\n\t__u8 unused[3];\n\t \n\t__u32 lvb_offset;\n};\n\nstatic void compat_input(struct dlm_write_request *kb,\n\t\t\t struct dlm_write_request32 *kb32,\n\t\t\t int namelen)\n{\n\tkb->version[0] = kb32->version[0];\n\tkb->version[1] = kb32->version[1];\n\tkb->version[2] = kb32->version[2];\n\n\tkb->cmd = kb32->cmd;\n\tkb->is64bit = kb32->is64bit;\n\tif (kb->cmd == DLM_USER_CREATE_LOCKSPACE ||\n\t    kb->cmd == DLM_USER_REMOVE_LOCKSPACE) {\n\t\tkb->i.lspace.flags = kb32->i.lspace.flags;\n\t\tkb->i.lspace.minor = kb32->i.lspace.minor;\n\t\tmemcpy(kb->i.lspace.name, kb32->i.lspace.name, namelen);\n\t} else if (kb->cmd == DLM_USER_PURGE) {\n\t\tkb->i.purge.nodeid = kb32->i.purge.nodeid;\n\t\tkb->i.purge.pid = kb32->i.purge.pid;\n\t} else {\n\t\tkb->i.lock.mode = kb32->i.lock.mode;\n\t\tkb->i.lock.namelen = kb32->i.lock.namelen;\n\t\tkb->i.lock.flags = kb32->i.lock.flags;\n\t\tkb->i.lock.lkid = kb32->i.lock.lkid;\n\t\tkb->i.lock.parent = kb32->i.lock.parent;\n\t\tkb->i.lock.xid = kb32->i.lock.xid;\n\t\tkb->i.lock.timeout = kb32->i.lock.timeout;\n\t\tkb->i.lock.castparam = (__user void *)(long)kb32->i.lock.castparam;\n\t\tkb->i.lock.castaddr = (__user void *)(long)kb32->i.lock.castaddr;\n\t\tkb->i.lock.bastparam = (__user void *)(long)kb32->i.lock.bastparam;\n\t\tkb->i.lock.bastaddr = (__user void *)(long)kb32->i.lock.bastaddr;\n\t\tkb->i.lock.lksb = (__user void *)(long)kb32->i.lock.lksb;\n\t\tmemcpy(kb->i.lock.lvb, kb32->i.lock.lvb, DLM_USER_LVB_LEN);\n\t\tmemcpy(kb->i.lock.name, kb32->i.lock.name, namelen);\n\t}\n}\n\nstatic void compat_output(struct dlm_lock_result *res,\n\t\t\t  struct dlm_lock_result32 *res32)\n{\n\tmemset(res32, 0, sizeof(*res32));\n\n\tres32->version[0] = res->version[0];\n\tres32->version[1] = res->version[1];\n\tres32->version[2] = res->version[2];\n\n\tres32->user_astaddr = (__u32)(__force long)res->user_astaddr;\n\tres32->user_astparam = (__u32)(__force long)res->user_astparam;\n\tres32->user_lksb = (__u32)(__force long)res->user_lksb;\n\tres32->bast_mode = res->bast_mode;\n\n\tres32->lvb_offset = res->lvb_offset;\n\tres32->length = res->length;\n\n\tres32->lksb.sb_status = res->lksb.sb_status;\n\tres32->lksb.sb_flags = res->lksb.sb_flags;\n\tres32->lksb.sb_lkid = res->lksb.sb_lkid;\n\tres32->lksb.sb_lvbptr = (__u32)(long)res->lksb.sb_lvbptr;\n}\n#endif\n\n \nvoid dlm_purge_lkb_callbacks(struct dlm_lkb *lkb)\n{\n\tstruct dlm_callback *cb, *safe;\n\n\tlist_for_each_entry_safe(cb, safe, &lkb->lkb_callbacks, list) {\n\t\tlist_del(&cb->list);\n\t\tkref_put(&cb->ref, dlm_release_callback);\n\t}\n\n\tclear_bit(DLM_IFL_CB_PENDING_BIT, &lkb->lkb_iflags);\n\n\t \n\tdlm_callback_set_last_ptr(&lkb->lkb_last_cast, NULL);\n\tdlm_callback_set_last_ptr(&lkb->lkb_last_cb, NULL);\n\tlkb->lkb_last_bast_mode = -1;\n}\n\n \n\nstatic int lkb_is_endoflife(int mode, int status)\n{\n\tswitch (status) {\n\tcase -DLM_EUNLOCK:\n\t\treturn 1;\n\tcase -DLM_ECANCEL:\n\tcase -ETIMEDOUT:\n\tcase -EDEADLK:\n\tcase -EAGAIN:\n\t\tif (mode == DLM_LOCK_IV)\n\t\t\treturn 1;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n \n\nvoid dlm_user_add_ast(struct dlm_lkb *lkb, uint32_t flags, int mode,\n\t\t      int status, uint32_t sbflags)\n{\n\tstruct dlm_ls *ls;\n\tstruct dlm_user_args *ua;\n\tstruct dlm_user_proc *proc;\n\tint rv;\n\n\tif (test_bit(DLM_DFL_ORPHAN_BIT, &lkb->lkb_dflags) ||\n\t    test_bit(DLM_IFL_DEAD_BIT, &lkb->lkb_iflags))\n\t\treturn;\n\n\tls = lkb->lkb_resource->res_ls;\n\tspin_lock(&ls->ls_clear_proc_locks);\n\n\t \n\n\tif (test_bit(DLM_DFL_ORPHAN_BIT, &lkb->lkb_dflags) ||\n\t    test_bit(DLM_IFL_DEAD_BIT, &lkb->lkb_iflags))\n\t\tgoto out;\n\n\tDLM_ASSERT(lkb->lkb_ua, dlm_print_lkb(lkb););\n\tua = lkb->lkb_ua;\n\tproc = ua->proc;\n\n\tif ((flags & DLM_CB_BAST) && ua->bastaddr == NULL)\n\t\tgoto out;\n\n\tif ((flags & DLM_CB_CAST) && lkb_is_endoflife(mode, status))\n\t\tset_bit(DLM_IFL_ENDOFLIFE_BIT, &lkb->lkb_iflags);\n\n\tspin_lock(&proc->asts_spin);\n\n\trv = dlm_enqueue_lkb_callback(lkb, flags, mode, status, sbflags);\n\tswitch (rv) {\n\tcase DLM_ENQUEUE_CALLBACK_FAILURE:\n\t\tspin_unlock(&proc->asts_spin);\n\t\tWARN_ON_ONCE(1);\n\t\tgoto out;\n\tcase DLM_ENQUEUE_CALLBACK_NEED_SCHED:\n\t\tkref_get(&lkb->lkb_ref);\n\t\tlist_add_tail(&lkb->lkb_cb_list, &proc->asts);\n\t\twake_up_interruptible(&proc->wait);\n\t\tbreak;\n\tcase DLM_ENQUEUE_CALLBACK_SUCCESS:\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\tspin_unlock(&proc->asts_spin);\n\n\tif (test_bit(DLM_IFL_ENDOFLIFE_BIT, &lkb->lkb_iflags)) {\n\t\t \n\t\tspin_lock(&proc->locks_spin);\n\t\tif (!list_empty(&lkb->lkb_ownqueue)) {\n\t\t\tlist_del_init(&lkb->lkb_ownqueue);\n\t\t\tdlm_put_lkb(lkb);\n\t\t}\n\t\tspin_unlock(&proc->locks_spin);\n\t}\n out:\n\tspin_unlock(&ls->ls_clear_proc_locks);\n}\n\nstatic int device_user_lock(struct dlm_user_proc *proc,\n\t\t\t    struct dlm_lock_params *params)\n{\n\tstruct dlm_ls *ls;\n\tstruct dlm_user_args *ua;\n\tuint32_t lkid;\n\tint error = -ENOMEM;\n\n\tls = dlm_find_lockspace_local(proc->lockspace);\n\tif (!ls)\n\t\treturn -ENOENT;\n\n\tif (!params->castaddr || !params->lksb) {\n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tua = kzalloc(sizeof(struct dlm_user_args), GFP_NOFS);\n\tif (!ua)\n\t\tgoto out;\n\tua->proc = proc;\n\tua->user_lksb = params->lksb;\n\tua->castparam = params->castparam;\n\tua->castaddr = params->castaddr;\n\tua->bastparam = params->bastparam;\n\tua->bastaddr = params->bastaddr;\n\tua->xid = params->xid;\n\n\tif (params->flags & DLM_LKF_CONVERT) {\n\t\terror = dlm_user_convert(ls, ua,\n\t\t\t\t\t params->mode, params->flags,\n\t\t\t\t\t params->lkid, params->lvb);\n\t} else if (params->flags & DLM_LKF_ORPHAN) {\n\t\terror = dlm_user_adopt_orphan(ls, ua,\n\t\t\t\t\t params->mode, params->flags,\n\t\t\t\t\t params->name, params->namelen,\n\t\t\t\t\t &lkid);\n\t\tif (!error)\n\t\t\terror = lkid;\n\t} else {\n\t\terror = dlm_user_request(ls, ua,\n\t\t\t\t\t params->mode, params->flags,\n\t\t\t\t\t params->name, params->namelen);\n\t\tif (!error)\n\t\t\terror = ua->lksb.sb_lkid;\n\t}\n out:\n\tdlm_put_lockspace(ls);\n\treturn error;\n}\n\nstatic int device_user_unlock(struct dlm_user_proc *proc,\n\t\t\t      struct dlm_lock_params *params)\n{\n\tstruct dlm_ls *ls;\n\tstruct dlm_user_args *ua;\n\tint error = -ENOMEM;\n\n\tls = dlm_find_lockspace_local(proc->lockspace);\n\tif (!ls)\n\t\treturn -ENOENT;\n\n\tua = kzalloc(sizeof(struct dlm_user_args), GFP_NOFS);\n\tif (!ua)\n\t\tgoto out;\n\tua->proc = proc;\n\tua->user_lksb = params->lksb;\n\tua->castparam = params->castparam;\n\tua->castaddr = params->castaddr;\n\n\tif (params->flags & DLM_LKF_CANCEL)\n\t\terror = dlm_user_cancel(ls, ua, params->flags, params->lkid);\n\telse\n\t\terror = dlm_user_unlock(ls, ua, params->flags, params->lkid,\n\t\t\t\t\tparams->lvb);\n out:\n\tdlm_put_lockspace(ls);\n\treturn error;\n}\n\nstatic int device_user_deadlock(struct dlm_user_proc *proc,\n\t\t\t\tstruct dlm_lock_params *params)\n{\n\tstruct dlm_ls *ls;\n\tint error;\n\n\tls = dlm_find_lockspace_local(proc->lockspace);\n\tif (!ls)\n\t\treturn -ENOENT;\n\n\terror = dlm_user_deadlock(ls, params->flags, params->lkid);\n\n\tdlm_put_lockspace(ls);\n\treturn error;\n}\n\nstatic int dlm_device_register(struct dlm_ls *ls, char *name)\n{\n\tint error, len;\n\n\t \n\tif (ls->ls_device.name)\n\t\treturn 0;\n\n\terror = -ENOMEM;\n\tlen = strlen(name) + strlen(name_prefix) + 2;\n\tls->ls_device.name = kzalloc(len, GFP_NOFS);\n\tif (!ls->ls_device.name)\n\t\tgoto fail;\n\n\tsnprintf((char *)ls->ls_device.name, len, \"%s_%s\", name_prefix,\n\t\t name);\n\tls->ls_device.fops = &device_fops;\n\tls->ls_device.minor = MISC_DYNAMIC_MINOR;\n\n\terror = misc_register(&ls->ls_device);\n\tif (error) {\n\t\tkfree(ls->ls_device.name);\n\t\t \n\t\tls->ls_device.name = NULL;\n\t}\nfail:\n\treturn error;\n}\n\nint dlm_device_deregister(struct dlm_ls *ls)\n{\n\t \n\tif (!ls->ls_device.name)\n\t\treturn 0;\n\n\tmisc_deregister(&ls->ls_device);\n\tkfree(ls->ls_device.name);\n\treturn 0;\n}\n\nstatic int device_user_purge(struct dlm_user_proc *proc,\n\t\t\t     struct dlm_purge_params *params)\n{\n\tstruct dlm_ls *ls;\n\tint error;\n\n\tls = dlm_find_lockspace_local(proc->lockspace);\n\tif (!ls)\n\t\treturn -ENOENT;\n\n\terror = dlm_user_purge(ls, proc, params->nodeid, params->pid);\n\n\tdlm_put_lockspace(ls);\n\treturn error;\n}\n\nstatic int device_create_lockspace(struct dlm_lspace_params *params)\n{\n\tdlm_lockspace_t *lockspace;\n\tstruct dlm_ls *ls;\n\tint error;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\terror = dlm_new_user_lockspace(params->name, dlm_config.ci_cluster_name,\n\t\t\t\t       params->flags, DLM_USER_LVB_LEN, NULL,\n\t\t\t\t       NULL, NULL, &lockspace);\n\tif (error)\n\t\treturn error;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -ENOENT;\n\n\terror = dlm_device_register(ls, params->name);\n\tdlm_put_lockspace(ls);\n\n\tif (error)\n\t\tdlm_release_lockspace(lockspace, 0);\n\telse\n\t\terror = ls->ls_device.minor;\n\n\treturn error;\n}\n\nstatic int device_remove_lockspace(struct dlm_lspace_params *params)\n{\n\tdlm_lockspace_t *lockspace;\n\tstruct dlm_ls *ls;\n\tint error, force = 0;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tls = dlm_find_lockspace_device(params->minor);\n\tif (!ls)\n\t\treturn -ENOENT;\n\n\tif (params->flags & DLM_USER_LSFLG_FORCEFREE)\n\t\tforce = 2;\n\n\tlockspace = ls->ls_local_handle;\n\tdlm_put_lockspace(ls);\n\n\t \n\n\terror = dlm_release_lockspace(lockspace, force);\n\tif (error > 0)\n\t\terror = 0;\n\treturn error;\n}\n\n \nstatic int check_version(struct dlm_write_request *req)\n{\n\tif (req->version[0] != DLM_DEVICE_VERSION_MAJOR ||\n\t    (req->version[0] == DLM_DEVICE_VERSION_MAJOR &&\n\t     req->version[1] > DLM_DEVICE_VERSION_MINOR)) {\n\n\t\tprintk(KERN_DEBUG \"dlm: process %s (%d) version mismatch \"\n\t\t       \"user (%d.%d.%d) kernel (%d.%d.%d)\\n\",\n\t\t       current->comm,\n\t\t       task_pid_nr(current),\n\t\t       req->version[0],\n\t\t       req->version[1],\n\t\t       req->version[2],\n\t\t       DLM_DEVICE_VERSION_MAJOR,\n\t\t       DLM_DEVICE_VERSION_MINOR,\n\t\t       DLM_DEVICE_VERSION_PATCH);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \n\n \n\nstatic ssize_t device_write(struct file *file, const char __user *buf,\n\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct dlm_user_proc *proc = file->private_data;\n\tstruct dlm_write_request *kbuf;\n\tint error;\n\n#ifdef CONFIG_COMPAT\n\tif (count < sizeof(struct dlm_write_request32))\n#else\n\tif (count < sizeof(struct dlm_write_request))\n#endif\n\t\treturn -EINVAL;\n\n\t \n\tif (count > sizeof(struct dlm_write_request) + DLM_RESNAME_MAXLEN)\n\t\treturn -EINVAL;\n\n\tkbuf = memdup_user_nul(buf, count);\n\tif (IS_ERR(kbuf))\n\t\treturn PTR_ERR(kbuf);\n\n\tif (check_version(kbuf)) {\n\t\terror = -EBADE;\n\t\tgoto out_free;\n\t}\n\n#ifdef CONFIG_COMPAT\n\tif (!kbuf->is64bit) {\n\t\tstruct dlm_write_request32 *k32buf;\n\t\tint namelen = 0;\n\n\t\tif (count > sizeof(struct dlm_write_request32))\n\t\t\tnamelen = count - sizeof(struct dlm_write_request32);\n\n\t\tk32buf = (struct dlm_write_request32 *)kbuf;\n\n\t\t \n\t\tkbuf = kzalloc(sizeof(struct dlm_write_request) + namelen + 1,\n\t\t\t       GFP_NOFS);\n\t\tif (!kbuf) {\n\t\t\tkfree(k32buf);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (proc)\n\t\t\tset_bit(DLM_PROC_FLAGS_COMPAT, &proc->flags);\n\n\t\tcompat_input(kbuf, k32buf, namelen);\n\t\tkfree(k32buf);\n\t}\n#endif\n\n\t \n\tif ((kbuf->cmd == DLM_USER_LOCK || kbuf->cmd == DLM_USER_UNLOCK) &&\n\t    (proc && test_bit(DLM_PROC_FLAGS_CLOSING, &proc->flags))) {\n\t\terror = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\terror = -EINVAL;\n\n\tswitch (kbuf->cmd)\n\t{\n\tcase DLM_USER_LOCK:\n\t\tif (!proc) {\n\t\t\tlog_print(\"no locking on control device\");\n\t\t\tgoto out_free;\n\t\t}\n\t\terror = device_user_lock(proc, &kbuf->i.lock);\n\t\tbreak;\n\n\tcase DLM_USER_UNLOCK:\n\t\tif (!proc) {\n\t\t\tlog_print(\"no locking on control device\");\n\t\t\tgoto out_free;\n\t\t}\n\t\terror = device_user_unlock(proc, &kbuf->i.lock);\n\t\tbreak;\n\n\tcase DLM_USER_DEADLOCK:\n\t\tif (!proc) {\n\t\t\tlog_print(\"no locking on control device\");\n\t\t\tgoto out_free;\n\t\t}\n\t\terror = device_user_deadlock(proc, &kbuf->i.lock);\n\t\tbreak;\n\n\tcase DLM_USER_CREATE_LOCKSPACE:\n\t\tif (proc) {\n\t\t\tlog_print(\"create/remove only on control device\");\n\t\t\tgoto out_free;\n\t\t}\n\t\terror = device_create_lockspace(&kbuf->i.lspace);\n\t\tbreak;\n\n\tcase DLM_USER_REMOVE_LOCKSPACE:\n\t\tif (proc) {\n\t\t\tlog_print(\"create/remove only on control device\");\n\t\t\tgoto out_free;\n\t\t}\n\t\terror = device_remove_lockspace(&kbuf->i.lspace);\n\t\tbreak;\n\n\tcase DLM_USER_PURGE:\n\t\tif (!proc) {\n\t\t\tlog_print(\"no locking on control device\");\n\t\t\tgoto out_free;\n\t\t}\n\t\terror = device_user_purge(proc, &kbuf->i.purge);\n\t\tbreak;\n\n\tdefault:\n\t\tlog_print(\"Unknown command passed to DLM device : %d\\n\",\n\t\t\t  kbuf->cmd);\n\t}\n\n out_free:\n\tkfree(kbuf);\n\treturn error;\n}\n\n \n\nstatic int device_open(struct inode *inode, struct file *file)\n{\n\tstruct dlm_user_proc *proc;\n\tstruct dlm_ls *ls;\n\n\tls = dlm_find_lockspace_device(iminor(inode));\n\tif (!ls)\n\t\treturn -ENOENT;\n\n\tproc = kzalloc(sizeof(struct dlm_user_proc), GFP_NOFS);\n\tif (!proc) {\n\t\tdlm_put_lockspace(ls);\n\t\treturn -ENOMEM;\n\t}\n\n\tproc->lockspace = ls->ls_local_handle;\n\tINIT_LIST_HEAD(&proc->asts);\n\tINIT_LIST_HEAD(&proc->locks);\n\tINIT_LIST_HEAD(&proc->unlocking);\n\tspin_lock_init(&proc->asts_spin);\n\tspin_lock_init(&proc->locks_spin);\n\tinit_waitqueue_head(&proc->wait);\n\tfile->private_data = proc;\n\n\treturn 0;\n}\n\nstatic int device_close(struct inode *inode, struct file *file)\n{\n\tstruct dlm_user_proc *proc = file->private_data;\n\tstruct dlm_ls *ls;\n\n\tls = dlm_find_lockspace_local(proc->lockspace);\n\tif (!ls)\n\t\treturn -ENOENT;\n\n\tset_bit(DLM_PROC_FLAGS_CLOSING, &proc->flags);\n\n\tdlm_clear_proc_locks(ls, proc);\n\n\t \n\n\tkfree(proc);\n\tfile->private_data = NULL;\n\n\tdlm_put_lockspace(ls);\n\tdlm_put_lockspace(ls);   \n\n\t \n\n\treturn 0;\n}\n\nstatic int copy_result_to_user(struct dlm_user_args *ua, int compat,\n\t\t\t       uint32_t flags, int mode, int copy_lvb,\n\t\t\t       char __user *buf, size_t count)\n{\n#ifdef CONFIG_COMPAT\n\tstruct dlm_lock_result32 result32;\n#endif\n\tstruct dlm_lock_result result;\n\tvoid *resultptr;\n\tint error=0;\n\tint len;\n\tint struct_len;\n\n\tmemset(&result, 0, sizeof(struct dlm_lock_result));\n\tresult.version[0] = DLM_DEVICE_VERSION_MAJOR;\n\tresult.version[1] = DLM_DEVICE_VERSION_MINOR;\n\tresult.version[2] = DLM_DEVICE_VERSION_PATCH;\n\tmemcpy(&result.lksb, &ua->lksb, offsetof(struct dlm_lksb, sb_lvbptr));\n\tresult.user_lksb = ua->user_lksb;\n\n\t \n\n\tif (flags & DLM_CB_BAST) {\n\t\tresult.user_astaddr = ua->bastaddr;\n\t\tresult.user_astparam = ua->bastparam;\n\t\tresult.bast_mode = mode;\n\t} else {\n\t\tresult.user_astaddr = ua->castaddr;\n\t\tresult.user_astparam = ua->castparam;\n\t}\n\n#ifdef CONFIG_COMPAT\n\tif (compat)\n\t\tlen = sizeof(struct dlm_lock_result32);\n\telse\n#endif\n\t\tlen = sizeof(struct dlm_lock_result);\n\tstruct_len = len;\n\n\t \n\n\tif (copy_lvb && ua->lksb.sb_lvbptr && count >= len + DLM_USER_LVB_LEN) {\n\t\tif (copy_to_user(buf+len, ua->lksb.sb_lvbptr,\n\t\t\t\t DLM_USER_LVB_LEN)) {\n\t\t\terror = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tresult.lvb_offset = len;\n\t\tlen += DLM_USER_LVB_LEN;\n\t}\n\n\tresult.length = len;\n\tresultptr = &result;\n#ifdef CONFIG_COMPAT\n\tif (compat) {\n\t\tcompat_output(&result, &result32);\n\t\tresultptr = &result32;\n\t}\n#endif\n\n\tif (copy_to_user(buf, resultptr, struct_len))\n\t\terror = -EFAULT;\n\telse\n\t\terror = len;\n out:\n\treturn error;\n}\n\nstatic int copy_version_to_user(char __user *buf, size_t count)\n{\n\tstruct dlm_device_version ver;\n\n\tmemset(&ver, 0, sizeof(struct dlm_device_version));\n\tver.version[0] = DLM_DEVICE_VERSION_MAJOR;\n\tver.version[1] = DLM_DEVICE_VERSION_MINOR;\n\tver.version[2] = DLM_DEVICE_VERSION_PATCH;\n\n\tif (copy_to_user(buf, &ver, sizeof(struct dlm_device_version)))\n\t\treturn -EFAULT;\n\treturn sizeof(struct dlm_device_version);\n}\n\n \n\nstatic ssize_t device_read(struct file *file, char __user *buf, size_t count,\n\t\t\t   loff_t *ppos)\n{\n\tstruct dlm_user_proc *proc = file->private_data;\n\tstruct dlm_lkb *lkb;\n\tDECLARE_WAITQUEUE(wait, current);\n\tstruct dlm_callback *cb;\n\tint rv, copy_lvb = 0;\n\tint old_mode, new_mode;\n\n\tif (count == sizeof(struct dlm_device_version)) {\n\t\trv = copy_version_to_user(buf, count);\n\t\treturn rv;\n\t}\n\n\tif (!proc) {\n\t\tlog_print(\"non-version read from control device %zu\", count);\n\t\treturn -EINVAL;\n\t}\n\n#ifdef CONFIG_COMPAT\n\tif (count < sizeof(struct dlm_lock_result32))\n#else\n\tif (count < sizeof(struct dlm_lock_result))\n#endif\n\t\treturn -EINVAL;\n\n try_another:\n\n\t \n\tif (test_bit(DLM_PROC_FLAGS_CLOSING, &proc->flags))\n\t\treturn -EINVAL;\n\n\tspin_lock(&proc->asts_spin);\n\tif (list_empty(&proc->asts)) {\n\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\tspin_unlock(&proc->asts_spin);\n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\tadd_wait_queue(&proc->wait, &wait);\n\n\trepeat:\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (list_empty(&proc->asts) && !signal_pending(current)) {\n\t\t\tspin_unlock(&proc->asts_spin);\n\t\t\tschedule();\n\t\t\tspin_lock(&proc->asts_spin);\n\t\t\tgoto repeat;\n\t\t}\n\t\tset_current_state(TASK_RUNNING);\n\t\tremove_wait_queue(&proc->wait, &wait);\n\n\t\tif (signal_pending(current)) {\n\t\t\tspin_unlock(&proc->asts_spin);\n\t\t\treturn -ERESTARTSYS;\n\t\t}\n\t}\n\n\t \n\n\tlkb = list_first_entry(&proc->asts, struct dlm_lkb, lkb_cb_list);\n\n\t \n\told_mode = lkb->lkb_last_cast->mode;\n\n\trv = dlm_dequeue_lkb_callback(lkb, &cb);\n\tswitch (rv) {\n\tcase DLM_DEQUEUE_CALLBACK_EMPTY:\n\t\t \n\t\tlog_print(\"dlm_rem_lkb_callback empty %x\", lkb->lkb_id);\n\t\tlist_del_init(&lkb->lkb_cb_list);\n\t\tspin_unlock(&proc->asts_spin);\n\t\t \n\t\tdlm_put_lkb(lkb);\n\t\tWARN_ON_ONCE(1);\n\t\tgoto try_another;\n\tcase DLM_DEQUEUE_CALLBACK_LAST:\n\t\tlist_del_init(&lkb->lkb_cb_list);\n\t\tclear_bit(DLM_IFL_CB_PENDING_BIT, &lkb->lkb_iflags);\n\t\tbreak;\n\tcase DLM_DEQUEUE_CALLBACK_SUCCESS:\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\tspin_unlock(&proc->asts_spin);\n\n\tif (cb->flags & DLM_CB_BAST) {\n\t\ttrace_dlm_bast(lkb->lkb_resource->res_ls, lkb, cb->mode);\n\t} else if (cb->flags & DLM_CB_CAST) {\n\t\tnew_mode = cb->mode;\n\n\t\tif (!cb->sb_status && lkb->lkb_lksb->sb_lvbptr &&\n\t\t    dlm_lvb_operations[old_mode + 1][new_mode + 1])\n\t\t\tcopy_lvb = 1;\n\n\t\tlkb->lkb_lksb->sb_status = cb->sb_status;\n\t\tlkb->lkb_lksb->sb_flags = cb->sb_flags;\n\t\ttrace_dlm_ast(lkb->lkb_resource->res_ls, lkb);\n\t}\n\n\trv = copy_result_to_user(lkb->lkb_ua,\n\t\t\t\t test_bit(DLM_PROC_FLAGS_COMPAT, &proc->flags),\n\t\t\t\t cb->flags, cb->mode, copy_lvb, buf, count);\n\n\tkref_put(&cb->ref, dlm_release_callback);\n\n\t \n\tif (rv == DLM_DEQUEUE_CALLBACK_LAST)\n\t\tdlm_put_lkb(lkb);\n\n\treturn rv;\n}\n\nstatic __poll_t device_poll(struct file *file, poll_table *wait)\n{\n\tstruct dlm_user_proc *proc = file->private_data;\n\n\tpoll_wait(file, &proc->wait, wait);\n\n\tspin_lock(&proc->asts_spin);\n\tif (!list_empty(&proc->asts)) {\n\t\tspin_unlock(&proc->asts_spin);\n\t\treturn EPOLLIN | EPOLLRDNORM;\n\t}\n\tspin_unlock(&proc->asts_spin);\n\treturn 0;\n}\n\nint dlm_user_daemon_available(void)\n{\n\t \n\n\tif (!dlm_our_nodeid())\n\t\treturn 0;\n\n\t \n\n\tif (dlm_monitor_unused)\n\t\treturn 1;\n\n\treturn atomic_read(&dlm_monitor_opened) ? 1 : 0;\n}\n\nstatic int ctl_device_open(struct inode *inode, struct file *file)\n{\n\tfile->private_data = NULL;\n\treturn 0;\n}\n\nstatic int ctl_device_close(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}\n\nstatic int monitor_device_open(struct inode *inode, struct file *file)\n{\n\tatomic_inc(&dlm_monitor_opened);\n\tdlm_monitor_unused = 0;\n\treturn 0;\n}\n\nstatic int monitor_device_close(struct inode *inode, struct file *file)\n{\n\tif (atomic_dec_and_test(&dlm_monitor_opened))\n\t\tdlm_stop_lockspaces();\n\treturn 0;\n}\n\nstatic const struct file_operations device_fops = {\n\t.open    = device_open,\n\t.release = device_close,\n\t.read    = device_read,\n\t.write   = device_write,\n\t.poll    = device_poll,\n\t.owner   = THIS_MODULE,\n\t.llseek  = noop_llseek,\n};\n\nstatic const struct file_operations ctl_device_fops = {\n\t.open    = ctl_device_open,\n\t.release = ctl_device_close,\n\t.read    = device_read,\n\t.write   = device_write,\n\t.owner   = THIS_MODULE,\n\t.llseek  = noop_llseek,\n};\n\nstatic struct miscdevice ctl_device = {\n\t.name  = \"dlm-control\",\n\t.fops  = &ctl_device_fops,\n\t.minor = MISC_DYNAMIC_MINOR,\n};\n\nstatic const struct file_operations monitor_device_fops = {\n\t.open    = monitor_device_open,\n\t.release = monitor_device_close,\n\t.owner   = THIS_MODULE,\n\t.llseek  = noop_llseek,\n};\n\nstatic struct miscdevice monitor_device = {\n\t.name  = \"dlm-monitor\",\n\t.fops  = &monitor_device_fops,\n\t.minor = MISC_DYNAMIC_MINOR,\n};\n\nint __init dlm_user_init(void)\n{\n\tint error;\n\n\tatomic_set(&dlm_monitor_opened, 0);\n\n\terror = misc_register(&ctl_device);\n\tif (error) {\n\t\tlog_print(\"misc_register failed for control device\");\n\t\tgoto out;\n\t}\n\n\terror = misc_register(&monitor_device);\n\tif (error) {\n\t\tlog_print(\"misc_register failed for monitor device\");\n\t\tmisc_deregister(&ctl_device);\n\t}\n out:\n\treturn error;\n}\n\nvoid dlm_user_exit(void)\n{\n\tmisc_deregister(&ctl_device);\n\tmisc_deregister(&monitor_device);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}