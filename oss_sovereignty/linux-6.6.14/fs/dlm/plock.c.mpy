{
  "module_name": "plock.c",
  "hash_id": "35bb41c86c1f0486424777aee7ea602de1a6e0a395c436804253db2e5a1b600d",
  "original_prompt": "Ingested from linux-6.6.14/fs/dlm/plock.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/filelock.h>\n#include <linux/miscdevice.h>\n#include <linux/poll.h>\n#include <linux/dlm.h>\n#include <linux/dlm_plock.h>\n#include <linux/slab.h>\n\n#include <trace/events/dlm.h>\n\n#include \"dlm_internal.h\"\n#include \"lockspace.h\"\n\nstatic DEFINE_SPINLOCK(ops_lock);\nstatic LIST_HEAD(send_list);\nstatic LIST_HEAD(recv_list);\nstatic DECLARE_WAIT_QUEUE_HEAD(send_wq);\nstatic DECLARE_WAIT_QUEUE_HEAD(recv_wq);\n\nstruct plock_async_data {\n\tvoid *fl;\n\tvoid *file;\n\tstruct file_lock flc;\n\tint (*callback)(struct file_lock *fl, int result);\n};\n\nstruct plock_op {\n\tstruct list_head list;\n\tint done;\n\tstruct dlm_plock_info info;\n\t \n\tstruct plock_async_data *data;\n};\n\nstatic inline void set_version(struct dlm_plock_info *info)\n{\n\tinfo->version[0] = DLM_PLOCK_VERSION_MAJOR;\n\tinfo->version[1] = DLM_PLOCK_VERSION_MINOR;\n\tinfo->version[2] = DLM_PLOCK_VERSION_PATCH;\n}\n\nstatic struct plock_op *plock_lookup_waiter(const struct dlm_plock_info *info)\n{\n\tstruct plock_op *op = NULL, *iter;\n\n\tlist_for_each_entry(iter, &recv_list, list) {\n\t\tif (iter->info.fsid == info->fsid &&\n\t\t    iter->info.number == info->number &&\n\t\t    iter->info.owner == info->owner &&\n\t\t    iter->info.pid == info->pid &&\n\t\t    iter->info.start == info->start &&\n\t\t    iter->info.end == info->end &&\n\t\t    iter->info.ex == info->ex &&\n\t\t    iter->info.wait) {\n\t\t\top = iter;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn op;\n}\n\nstatic int check_version(struct dlm_plock_info *info)\n{\n\tif ((DLM_PLOCK_VERSION_MAJOR != info->version[0]) ||\n\t    (DLM_PLOCK_VERSION_MINOR < info->version[1])) {\n\t\tlog_print(\"plock device version mismatch: \"\n\t\t\t  \"kernel (%u.%u.%u), user (%u.%u.%u)\",\n\t\t\t  DLM_PLOCK_VERSION_MAJOR,\n\t\t\t  DLM_PLOCK_VERSION_MINOR,\n\t\t\t  DLM_PLOCK_VERSION_PATCH,\n\t\t\t  info->version[0],\n\t\t\t  info->version[1],\n\t\t\t  info->version[2]);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic void dlm_release_plock_op(struct plock_op *op)\n{\n\tkfree(op->data);\n\tkfree(op);\n}\n\nstatic void send_op(struct plock_op *op)\n{\n\tset_version(&op->info);\n\tspin_lock(&ops_lock);\n\tlist_add_tail(&op->list, &send_list);\n\tspin_unlock(&ops_lock);\n\twake_up(&send_wq);\n}\n\nstatic int do_lock_cancel(const struct dlm_plock_info *orig_info)\n{\n\tstruct plock_op *op;\n\tint rv;\n\n\top = kzalloc(sizeof(*op), GFP_NOFS);\n\tif (!op)\n\t\treturn -ENOMEM;\n\n\top->info = *orig_info;\n\top->info.optype = DLM_PLOCK_OP_CANCEL;\n\top->info.wait = 0;\n\n\tsend_op(op);\n\twait_event(recv_wq, (op->done != 0));\n\n\trv = op->info.rv;\n\n\tdlm_release_plock_op(op);\n\treturn rv;\n}\n\nint dlm_posix_lock(dlm_lockspace_t *lockspace, u64 number, struct file *file,\n\t\t   int cmd, struct file_lock *fl)\n{\n\tstruct plock_async_data *op_data;\n\tstruct dlm_ls *ls;\n\tstruct plock_op *op;\n\tint rv;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -EINVAL;\n\n\top = kzalloc(sizeof(*op), GFP_NOFS);\n\tif (!op) {\n\t\trv = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\top->info.optype\t\t= DLM_PLOCK_OP_LOCK;\n\top->info.pid\t\t= fl->fl_pid;\n\top->info.ex\t\t= (fl->fl_type == F_WRLCK);\n\top->info.wait\t\t= IS_SETLKW(cmd);\n\top->info.fsid\t\t= ls->ls_global_id;\n\top->info.number\t\t= number;\n\top->info.start\t\t= fl->fl_start;\n\top->info.end\t\t= fl->fl_end;\n\t \n\tif (fl->fl_lmops && fl->fl_lmops->lm_grant) {\n\t\top_data = kzalloc(sizeof(*op_data), GFP_NOFS);\n\t\tif (!op_data) {\n\t\t\tdlm_release_plock_op(op);\n\t\t\trv = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\top->info.owner\t= (__u64) fl->fl_pid;\n\t\top_data->callback = fl->fl_lmops->lm_grant;\n\t\tlocks_init_lock(&op_data->flc);\n\t\tlocks_copy_lock(&op_data->flc, fl);\n\t\top_data->fl\t\t= fl;\n\t\top_data->file\t= file;\n\n\t\top->data = op_data;\n\n\t\tsend_op(op);\n\t\trv = FILE_LOCK_DEFERRED;\n\t\tgoto out;\n\t} else {\n\t\top->info.owner\t= (__u64)(long) fl->fl_owner;\n\t}\n\n\tsend_op(op);\n\n\tif (op->info.wait) {\n\t\trv = wait_event_interruptible(recv_wq, (op->done != 0));\n\t\tif (rv == -ERESTARTSYS) {\n\t\t\tspin_lock(&ops_lock);\n\t\t\t \n\t\t\tif (op->done != 0) {\n\t\t\t\tspin_unlock(&ops_lock);\n\t\t\t\tgoto do_lock_wait;\n\t\t\t}\n\t\t\tspin_unlock(&ops_lock);\n\n\t\t\trv = do_lock_cancel(&op->info);\n\t\t\tswitch (rv) {\n\t\t\tcase 0:\n\t\t\t\t \n\t\t\t\tspin_lock(&ops_lock);\n\t\t\t\tlist_del(&op->list);\n\t\t\t\tspin_unlock(&ops_lock);\n\t\t\t\trv = -EINTR;\n\t\t\t\tbreak;\n\t\t\tcase -ENOENT:\n\t\t\t\t \n\t\t\t\tfallthrough;\n\t\t\tdefault:\n\t\t\t\t \n\t\t\t\tgoto wait;\n\t\t\t}\n\n\t\t\tlog_debug(ls, \"%s: wait interrupted %x %llx pid %d\",\n\t\t\t\t  __func__, ls->ls_global_id,\n\t\t\t\t  (unsigned long long)number, op->info.pid);\n\t\t\tdlm_release_plock_op(op);\n\t\t\tgoto out;\n\t\t}\n\t} else {\nwait:\n\t\twait_event(recv_wq, (op->done != 0));\n\t}\n\ndo_lock_wait:\n\n\tWARN_ON(!list_empty(&op->list));\n\n\trv = op->info.rv;\n\n\tif (!rv) {\n\t\tif (locks_lock_file_wait(file, fl) < 0)\n\t\t\tlog_error(ls, \"dlm_posix_lock: vfs lock error %llx\",\n\t\t\t\t  (unsigned long long)number);\n\t}\n\n\tdlm_release_plock_op(op);\nout:\n\tdlm_put_lockspace(ls);\n\treturn rv;\n}\nEXPORT_SYMBOL_GPL(dlm_posix_lock);\n\n \nstatic int dlm_plock_callback(struct plock_op *op)\n{\n\tstruct plock_async_data *op_data = op->data;\n\tstruct file *file;\n\tstruct file_lock *fl;\n\tstruct file_lock *flc;\n\tint (*notify)(struct file_lock *fl, int result) = NULL;\n\tint rv = 0;\n\n\tWARN_ON(!list_empty(&op->list));\n\n\t \n\tfile = op_data->file;\n\tflc = &op_data->flc;\n\tfl = op_data->fl;\n\tnotify = op_data->callback;\n\n\tif (op->info.rv) {\n\t\tnotify(fl, op->info.rv);\n\t\tgoto out;\n\t}\n\n\t \n\tflc->fl_flags &= ~FL_SLEEP;\n\tif (posix_lock_file(file, flc, NULL)) {\n\t\t \n\t\tlog_print(\"dlm_plock_callback: vfs lock error %llx file %p fl %p\",\n\t\t\t  (unsigned long long)op->info.number, file, fl);\n\t}\n\n\trv = notify(fl, 0);\n\tif (rv) {\n\t\t \n\t\tlog_print(\"%s: lock granted after lock request failed; dangling lock!\",\n\t\t\t  __func__);\n\t\tgoto out;\n\t}\n\nout:\n\tdlm_release_plock_op(op);\n\treturn rv;\n}\n\nint dlm_posix_unlock(dlm_lockspace_t *lockspace, u64 number, struct file *file,\n\t\t     struct file_lock *fl)\n{\n\tstruct dlm_ls *ls;\n\tstruct plock_op *op;\n\tint rv;\n\tunsigned char fl_flags = fl->fl_flags;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -EINVAL;\n\n\top = kzalloc(sizeof(*op), GFP_NOFS);\n\tif (!op) {\n\t\trv = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\tfl->fl_flags |= FL_EXISTS;\n\n\trv = locks_lock_file_wait(file, fl);\n\tif (rv == -ENOENT) {\n\t\trv = 0;\n\t\tgoto out_free;\n\t}\n\tif (rv < 0) {\n\t\tlog_error(ls, \"dlm_posix_unlock: vfs unlock error %d %llx\",\n\t\t\t  rv, (unsigned long long)number);\n\t}\n\n\top->info.optype\t\t= DLM_PLOCK_OP_UNLOCK;\n\top->info.pid\t\t= fl->fl_pid;\n\top->info.fsid\t\t= ls->ls_global_id;\n\top->info.number\t\t= number;\n\top->info.start\t\t= fl->fl_start;\n\top->info.end\t\t= fl->fl_end;\n\tif (fl->fl_lmops && fl->fl_lmops->lm_grant)\n\t\top->info.owner\t= (__u64) fl->fl_pid;\n\telse\n\t\top->info.owner\t= (__u64)(long) fl->fl_owner;\n\n\tif (fl->fl_flags & FL_CLOSE) {\n\t\top->info.flags |= DLM_PLOCK_FL_CLOSE;\n\t\tsend_op(op);\n\t\trv = 0;\n\t\tgoto out;\n\t}\n\n\tsend_op(op);\n\twait_event(recv_wq, (op->done != 0));\n\n\tWARN_ON(!list_empty(&op->list));\n\n\trv = op->info.rv;\n\n\tif (rv == -ENOENT)\n\t\trv = 0;\n\nout_free:\n\tdlm_release_plock_op(op);\nout:\n\tdlm_put_lockspace(ls);\n\tfl->fl_flags = fl_flags;\n\treturn rv;\n}\nEXPORT_SYMBOL_GPL(dlm_posix_unlock);\n\n \nint dlm_posix_cancel(dlm_lockspace_t *lockspace, u64 number, struct file *file,\n\t\t     struct file_lock *fl)\n{\n\tstruct dlm_plock_info info;\n\tstruct plock_op *op;\n\tstruct dlm_ls *ls;\n\tint rv;\n\n\t \n\tif (WARN_ON_ONCE(!fl->fl_lmops || !fl->fl_lmops->lm_grant))\n\t\treturn -EOPNOTSUPP;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -EINVAL;\n\n\tmemset(&info, 0, sizeof(info));\n\tinfo.pid = fl->fl_pid;\n\tinfo.ex = (fl->fl_type == F_WRLCK);\n\tinfo.fsid = ls->ls_global_id;\n\tdlm_put_lockspace(ls);\n\tinfo.number = number;\n\tinfo.start = fl->fl_start;\n\tinfo.end = fl->fl_end;\n\tinfo.owner = (__u64)fl->fl_pid;\n\n\trv = do_lock_cancel(&info);\n\tswitch (rv) {\n\tcase 0:\n\t\tspin_lock(&ops_lock);\n\t\t \n\t\top = plock_lookup_waiter(&info);\n\t\tif (WARN_ON_ONCE(!op)) {\n\t\t\tspin_unlock(&ops_lock);\n\t\t\trv = -ENOLCK;\n\t\t\tbreak;\n\t\t}\n\n\t\tlist_del(&op->list);\n\t\tspin_unlock(&ops_lock);\n\t\tWARN_ON(op->info.optype != DLM_PLOCK_OP_LOCK);\n\t\top->data->callback(op->data->fl, -EINTR);\n\t\tdlm_release_plock_op(op);\n\t\trv = -EINTR;\n\t\tbreak;\n\tcase -ENOENT:\n\t\t \n\t\trv = dlm_posix_unlock(lockspace, number, file, fl);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn rv;\n}\nEXPORT_SYMBOL_GPL(dlm_posix_cancel);\n\nint dlm_posix_get(dlm_lockspace_t *lockspace, u64 number, struct file *file,\n\t\t  struct file_lock *fl)\n{\n\tstruct dlm_ls *ls;\n\tstruct plock_op *op;\n\tint rv;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -EINVAL;\n\n\top = kzalloc(sizeof(*op), GFP_NOFS);\n\tif (!op) {\n\t\trv = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\top->info.optype\t\t= DLM_PLOCK_OP_GET;\n\top->info.pid\t\t= fl->fl_pid;\n\top->info.ex\t\t= (fl->fl_type == F_WRLCK);\n\top->info.fsid\t\t= ls->ls_global_id;\n\top->info.number\t\t= number;\n\top->info.start\t\t= fl->fl_start;\n\top->info.end\t\t= fl->fl_end;\n\tif (fl->fl_lmops && fl->fl_lmops->lm_grant)\n\t\top->info.owner\t= (__u64) fl->fl_pid;\n\telse\n\t\top->info.owner\t= (__u64)(long) fl->fl_owner;\n\n\tsend_op(op);\n\twait_event(recv_wq, (op->done != 0));\n\n\tWARN_ON(!list_empty(&op->list));\n\n\t \n\n\trv = op->info.rv;\n\n\tfl->fl_type = F_UNLCK;\n\tif (rv == -ENOENT)\n\t\trv = 0;\n\telse if (rv > 0) {\n\t\tlocks_init_lock(fl);\n\t\tfl->fl_type = (op->info.ex) ? F_WRLCK : F_RDLCK;\n\t\tfl->fl_flags = FL_POSIX;\n\t\tfl->fl_pid = op->info.pid;\n\t\tif (op->info.nodeid != dlm_our_nodeid())\n\t\t\tfl->fl_pid = -fl->fl_pid;\n\t\tfl->fl_start = op->info.start;\n\t\tfl->fl_end = op->info.end;\n\t\trv = 0;\n\t}\n\n\tdlm_release_plock_op(op);\nout:\n\tdlm_put_lockspace(ls);\n\treturn rv;\n}\nEXPORT_SYMBOL_GPL(dlm_posix_get);\n\n \nstatic ssize_t dev_read(struct file *file, char __user *u, size_t count,\n\t\t\tloff_t *ppos)\n{\n\tstruct dlm_plock_info info;\n\tstruct plock_op *op = NULL;\n\n\tif (count < sizeof(info))\n\t\treturn -EINVAL;\n\n\tspin_lock(&ops_lock);\n\tif (!list_empty(&send_list)) {\n\t\top = list_first_entry(&send_list, struct plock_op, list);\n\t\tif (op->info.flags & DLM_PLOCK_FL_CLOSE)\n\t\t\tlist_del(&op->list);\n\t\telse\n\t\t\tlist_move_tail(&op->list, &recv_list);\n\t\tmemcpy(&info, &op->info, sizeof(info));\n\t}\n\tspin_unlock(&ops_lock);\n\n\tif (!op)\n\t\treturn -EAGAIN;\n\n\ttrace_dlm_plock_read(&info);\n\n\t \n\n\tif (op->info.flags & DLM_PLOCK_FL_CLOSE)\n\t\tdlm_release_plock_op(op);\n\n\tif (copy_to_user(u, &info, sizeof(info)))\n\t\treturn -EFAULT;\n\treturn sizeof(info);\n}\n\n \nstatic ssize_t dev_write(struct file *file, const char __user *u, size_t count,\n\t\t\t loff_t *ppos)\n{\n\tstruct plock_op *op = NULL, *iter;\n\tstruct dlm_plock_info info;\n\tint do_callback = 0;\n\n\tif (count != sizeof(info))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&info, u, sizeof(info)))\n\t\treturn -EFAULT;\n\n\ttrace_dlm_plock_write(&info);\n\n\tif (check_version(&info))\n\t\treturn -EINVAL;\n\n\t \n\tspin_lock(&ops_lock);\n\tif (info.wait) {\n\t\top = plock_lookup_waiter(&info);\n\t} else {\n\t\tlist_for_each_entry(iter, &recv_list, list) {\n\t\t\tif (!iter->info.wait &&\n\t\t\t    iter->info.fsid == info.fsid) {\n\t\t\t\top = iter;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (op) {\n\t\t \n\t\tif (info.wait)\n\t\t\tWARN_ON(op->info.optype != DLM_PLOCK_OP_LOCK);\n\t\telse\n\t\t\tWARN_ON(op->info.number != info.number ||\n\t\t\t\top->info.owner != info.owner ||\n\t\t\t\top->info.optype != info.optype);\n\n\t\tlist_del_init(&op->list);\n\t\tmemcpy(&op->info, &info, sizeof(info));\n\t\tif (op->data)\n\t\t\tdo_callback = 1;\n\t\telse\n\t\t\top->done = 1;\n\t}\n\tspin_unlock(&ops_lock);\n\n\tif (op) {\n\t\tif (do_callback)\n\t\t\tdlm_plock_callback(op);\n\t\telse\n\t\t\twake_up(&recv_wq);\n\t} else\n\t\tpr_debug(\"%s: no op %x %llx\", __func__,\n\t\t\t info.fsid, (unsigned long long)info.number);\n\treturn count;\n}\n\nstatic __poll_t dev_poll(struct file *file, poll_table *wait)\n{\n\t__poll_t mask = 0;\n\n\tpoll_wait(file, &send_wq, wait);\n\n\tspin_lock(&ops_lock);\n\tif (!list_empty(&send_list))\n\t\tmask = EPOLLIN | EPOLLRDNORM;\n\tspin_unlock(&ops_lock);\n\n\treturn mask;\n}\n\nstatic const struct file_operations dev_fops = {\n\t.read    = dev_read,\n\t.write   = dev_write,\n\t.poll    = dev_poll,\n\t.owner   = THIS_MODULE,\n\t.llseek  = noop_llseek,\n};\n\nstatic struct miscdevice plock_dev_misc = {\n\t.minor = MISC_DYNAMIC_MINOR,\n\t.name = DLM_PLOCK_MISC_NAME,\n\t.fops = &dev_fops\n};\n\nint dlm_plock_init(void)\n{\n\tint rv;\n\n\trv = misc_register(&plock_dev_misc);\n\tif (rv)\n\t\tlog_print(\"dlm_plock_init: misc_register failed %d\", rv);\n\treturn rv;\n}\n\nvoid dlm_plock_exit(void)\n{\n\tmisc_deregister(&plock_dev_misc);\n\tWARN_ON(!list_empty(&send_list));\n\tWARN_ON(!list_empty(&recv_list));\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}