{
  "module_name": "recover.c",
  "hash_id": "55f6890bdce93a53433a3888962b230eee92f7f734d9f5b947f9553df8eb5133",
  "original_prompt": "Ingested from linux-6.6.14/fs/dlm/recover.c",
  "human_readable_source": "\n \n\n#include \"dlm_internal.h\"\n#include \"lockspace.h\"\n#include \"dir.h\"\n#include \"config.h\"\n#include \"ast.h\"\n#include \"memory.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"recover.h\"\n\n\n \n\n \n\nint dlm_wait_function(struct dlm_ls *ls, int (*testfn) (struct dlm_ls *ls))\n{\n\tint error = 0;\n\tint rv;\n\n\twhile (1) {\n\t\trv = wait_event_timeout(ls->ls_wait_general,\n\t\t\t\t\ttestfn(ls) || dlm_recovery_stopped(ls),\n\t\t\t\t\tdlm_config.ci_recover_timer * HZ);\n\t\tif (rv)\n\t\t\tbreak;\n\t\tif (test_bit(LSFL_RCOM_WAIT, &ls->ls_flags)) {\n\t\t\tlog_debug(ls, \"dlm_wait_function timed out\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t}\n\n\tif (dlm_recovery_stopped(ls)) {\n\t\tlog_debug(ls, \"dlm_wait_function aborted\");\n\t\terror = -EINTR;\n\t}\n\treturn error;\n}\n\n \n\nuint32_t dlm_recover_status(struct dlm_ls *ls)\n{\n\tuint32_t status;\n\tspin_lock(&ls->ls_recover_lock);\n\tstatus = ls->ls_recover_status;\n\tspin_unlock(&ls->ls_recover_lock);\n\treturn status;\n}\n\nstatic void _set_recover_status(struct dlm_ls *ls, uint32_t status)\n{\n\tls->ls_recover_status |= status;\n}\n\nvoid dlm_set_recover_status(struct dlm_ls *ls, uint32_t status)\n{\n\tspin_lock(&ls->ls_recover_lock);\n\t_set_recover_status(ls, status);\n\tspin_unlock(&ls->ls_recover_lock);\n}\n\nstatic int wait_status_all(struct dlm_ls *ls, uint32_t wait_status,\n\t\t\t   int save_slots, uint64_t seq)\n{\n\tstruct dlm_rcom *rc = ls->ls_recover_buf;\n\tstruct dlm_member *memb;\n\tint error = 0, delay;\n\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tdelay = 0;\n\t\tfor (;;) {\n\t\t\tif (dlm_recovery_stopped(ls)) {\n\t\t\t\terror = -EINTR;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\terror = dlm_rcom_status(ls, memb->nodeid, 0, seq);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\n\t\t\tif (save_slots)\n\t\t\t\tdlm_slot_save(ls, rc, memb);\n\n\t\t\tif (le32_to_cpu(rc->rc_result) & wait_status)\n\t\t\t\tbreak;\n\t\t\tif (delay < 1000)\n\t\t\t\tdelay += 20;\n\t\t\tmsleep(delay);\n\t\t}\n\t}\n out:\n\treturn error;\n}\n\nstatic int wait_status_low(struct dlm_ls *ls, uint32_t wait_status,\n\t\t\t   uint32_t status_flags, uint64_t seq)\n{\n\tstruct dlm_rcom *rc = ls->ls_recover_buf;\n\tint error = 0, delay = 0, nodeid = ls->ls_low_nodeid;\n\n\tfor (;;) {\n\t\tif (dlm_recovery_stopped(ls)) {\n\t\t\terror = -EINTR;\n\t\t\tgoto out;\n\t\t}\n\n\t\terror = dlm_rcom_status(ls, nodeid, status_flags, seq);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tif (le32_to_cpu(rc->rc_result) & wait_status)\n\t\t\tbreak;\n\t\tif (delay < 1000)\n\t\t\tdelay += 20;\n\t\tmsleep(delay);\n\t}\n out:\n\treturn error;\n}\n\nstatic int wait_status(struct dlm_ls *ls, uint32_t status, uint64_t seq)\n{\n\tuint32_t status_all = status << 1;\n\tint error;\n\n\tif (ls->ls_low_nodeid == dlm_our_nodeid()) {\n\t\terror = wait_status_all(ls, status, 0, seq);\n\t\tif (!error)\n\t\t\tdlm_set_recover_status(ls, status_all);\n\t} else\n\t\terror = wait_status_low(ls, status_all, 0, seq);\n\n\treturn error;\n}\n\nint dlm_recover_members_wait(struct dlm_ls *ls, uint64_t seq)\n{\n\tstruct dlm_member *memb;\n\tstruct dlm_slot *slots;\n\tint num_slots, slots_size;\n\tint error, rv;\n\tuint32_t gen;\n\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tmemb->slot = -1;\n\t\tmemb->generation = 0;\n\t}\n\n\tif (ls->ls_low_nodeid == dlm_our_nodeid()) {\n\t\terror = wait_status_all(ls, DLM_RS_NODES, 1, seq);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\t \n\n\t\trv = dlm_slots_assign(ls, &num_slots, &slots_size, &slots, &gen);\n\t\tif (!rv) {\n\t\t\tspin_lock(&ls->ls_recover_lock);\n\t\t\t_set_recover_status(ls, DLM_RS_NODES_ALL);\n\t\t\tls->ls_num_slots = num_slots;\n\t\t\tls->ls_slots_size = slots_size;\n\t\t\tls->ls_slots = slots;\n\t\t\tls->ls_generation = gen;\n\t\t\tspin_unlock(&ls->ls_recover_lock);\n\t\t} else {\n\t\t\tdlm_set_recover_status(ls, DLM_RS_NODES_ALL);\n\t\t}\n\t} else {\n\t\terror = wait_status_low(ls, DLM_RS_NODES_ALL,\n\t\t\t\t\tDLM_RSF_NEED_SLOTS, seq);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\tdlm_slots_copy_in(ls);\n\t}\n out:\n\treturn error;\n}\n\nint dlm_recover_directory_wait(struct dlm_ls *ls, uint64_t seq)\n{\n\treturn wait_status(ls, DLM_RS_DIR, seq);\n}\n\nint dlm_recover_locks_wait(struct dlm_ls *ls, uint64_t seq)\n{\n\treturn wait_status(ls, DLM_RS_LOCKS, seq);\n}\n\nint dlm_recover_done_wait(struct dlm_ls *ls, uint64_t seq)\n{\n\treturn wait_status(ls, DLM_RS_DONE, seq);\n}\n\n \n\nstatic int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}\n\nstatic void recover_list_add(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tif (list_empty(&r->res_recover_list)) {\n\t\tlist_add_tail(&r->res_recover_list, &ls->ls_recover_list);\n\t\tls->ls_recover_list_count++;\n\t\tdlm_hold_rsb(r);\n\t}\n\tspin_unlock(&ls->ls_recover_list_lock);\n}\n\nstatic void recover_list_del(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tlist_del_init(&r->res_recover_list);\n\tls->ls_recover_list_count--;\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\tdlm_put_rsb(r);\n}\n\nstatic void recover_list_clear(struct dlm_ls *ls)\n{\n\tstruct dlm_rsb *r, *s;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tlist_for_each_entry_safe(r, s, &ls->ls_recover_list, res_recover_list) {\n\t\tlist_del_init(&r->res_recover_list);\n\t\tr->res_recover_locks_count = 0;\n\t\tdlm_put_rsb(r);\n\t\tls->ls_recover_list_count--;\n\t}\n\n\tif (ls->ls_recover_list_count != 0) {\n\t\tlog_error(ls, \"warning: recover_list_count %d\",\n\t\t\t  ls->ls_recover_list_count);\n\t\tls->ls_recover_list_count = 0;\n\t}\n\tspin_unlock(&ls->ls_recover_list_lock);\n}\n\nstatic int recover_idr_empty(struct dlm_ls *ls)\n{\n\tint empty = 1;\n\n\tspin_lock(&ls->ls_recover_idr_lock);\n\tif (ls->ls_recover_list_count)\n\t\tempty = 0;\n\tspin_unlock(&ls->ls_recover_idr_lock);\n\n\treturn empty;\n}\n\nstatic int recover_idr_add(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\tint rv;\n\n\tidr_preload(GFP_NOFS);\n\tspin_lock(&ls->ls_recover_idr_lock);\n\tif (r->res_id) {\n\t\trv = -1;\n\t\tgoto out_unlock;\n\t}\n\trv = idr_alloc(&ls->ls_recover_idr, r, 1, 0, GFP_NOWAIT);\n\tif (rv < 0)\n\t\tgoto out_unlock;\n\n\tr->res_id = rv;\n\tls->ls_recover_list_count++;\n\tdlm_hold_rsb(r);\n\trv = 0;\nout_unlock:\n\tspin_unlock(&ls->ls_recover_idr_lock);\n\tidr_preload_end();\n\treturn rv;\n}\n\nstatic void recover_idr_del(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\n\tspin_lock(&ls->ls_recover_idr_lock);\n\tidr_remove(&ls->ls_recover_idr, r->res_id);\n\tr->res_id = 0;\n\tls->ls_recover_list_count--;\n\tspin_unlock(&ls->ls_recover_idr_lock);\n\n\tdlm_put_rsb(r);\n}\n\nstatic struct dlm_rsb *recover_idr_find(struct dlm_ls *ls, uint64_t id)\n{\n\tstruct dlm_rsb *r;\n\n\tspin_lock(&ls->ls_recover_idr_lock);\n\tr = idr_find(&ls->ls_recover_idr, (int)id);\n\tspin_unlock(&ls->ls_recover_idr_lock);\n\treturn r;\n}\n\nstatic void recover_idr_clear(struct dlm_ls *ls)\n{\n\tstruct dlm_rsb *r;\n\tint id;\n\n\tspin_lock(&ls->ls_recover_idr_lock);\n\n\tidr_for_each_entry(&ls->ls_recover_idr, r, id) {\n\t\tidr_remove(&ls->ls_recover_idr, id);\n\t\tr->res_id = 0;\n\t\tr->res_recover_locks_count = 0;\n\t\tls->ls_recover_list_count--;\n\n\t\tdlm_put_rsb(r);\n\t}\n\n\tif (ls->ls_recover_list_count != 0) {\n\t\tlog_error(ls, \"warning: recover_list_count %d\",\n\t\t\t  ls->ls_recover_list_count);\n\t\tls->ls_recover_list_count = 0;\n\t}\n\tspin_unlock(&ls->ls_recover_idr_lock);\n}\n\n\n \n\n \n\nstatic void set_lock_master(struct list_head *queue, int nodeid)\n{\n\tstruct dlm_lkb *lkb;\n\n\tlist_for_each_entry(lkb, queue, lkb_statequeue) {\n\t\tif (!test_bit(DLM_IFL_MSTCPY_BIT, &lkb->lkb_iflags)) {\n\t\t\tlkb->lkb_nodeid = nodeid;\n\t\t\tlkb->lkb_remid = 0;\n\t\t}\n\t}\n}\n\nstatic void set_master_lkbs(struct dlm_rsb *r)\n{\n\tset_lock_master(&r->res_grantqueue, r->res_nodeid);\n\tset_lock_master(&r->res_convertqueue, r->res_nodeid);\n\tset_lock_master(&r->res_waitqueue, r->res_nodeid);\n}\n\n \n\nstatic void set_new_master(struct dlm_rsb *r)\n{\n\tset_master_lkbs(r);\n\trsb_set_flag(r, RSB_NEW_MASTER);\n\trsb_set_flag(r, RSB_NEW_MASTER2);\n}\n\n \n\nstatic int recover_master(struct dlm_rsb *r, unsigned int *count, uint64_t seq)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\tint our_nodeid, dir_nodeid;\n\tint is_removed = 0;\n\tint error;\n\n\tif (is_master(r))\n\t\treturn 0;\n\n\tis_removed = dlm_is_removed(ls, r->res_nodeid);\n\n\tif (!is_removed && !rsb_flag(r, RSB_NEW_MASTER))\n\t\treturn 0;\n\n\tour_nodeid = dlm_our_nodeid();\n\tdir_nodeid = dlm_dir_nodeid(r);\n\n\tif (dir_nodeid == our_nodeid) {\n\t\tif (is_removed) {\n\t\t\tr->res_master_nodeid = our_nodeid;\n\t\t\tr->res_nodeid = 0;\n\t\t}\n\n\t\t \n\t\tset_new_master(r);\n\t\terror = 0;\n\t} else {\n\t\trecover_idr_add(r);\n\t\terror = dlm_send_rcom_lookup(r, dir_nodeid, seq);\n\t}\n\n\t(*count)++;\n\treturn error;\n}\n\n \n\nstatic int recover_master_static(struct dlm_rsb *r, unsigned int *count)\n{\n\tint dir_nodeid = dlm_dir_nodeid(r);\n\tint new_master = dir_nodeid;\n\n\tif (dir_nodeid == dlm_our_nodeid())\n\t\tnew_master = 0;\n\n\tdlm_purge_mstcpy_locks(r);\n\tr->res_master_nodeid = dir_nodeid;\n\tr->res_nodeid = new_master;\n\tset_new_master(r);\n\t(*count)++;\n\treturn 0;\n}\n\n \n\nint dlm_recover_masters(struct dlm_ls *ls, uint64_t seq)\n{\n\tstruct dlm_rsb *r;\n\tunsigned int total = 0;\n\tunsigned int count = 0;\n\tint nodir = dlm_no_directory(ls);\n\tint error;\n\n\tlog_rinfo(ls, \"dlm_recover_masters\");\n\n\tdown_read(&ls->ls_root_sem);\n\tlist_for_each_entry(r, &ls->ls_root_list, res_root_list) {\n\t\tif (dlm_recovery_stopped(ls)) {\n\t\t\tup_read(&ls->ls_root_sem);\n\t\t\terror = -EINTR;\n\t\t\tgoto out;\n\t\t}\n\n\t\tlock_rsb(r);\n\t\tif (nodir)\n\t\t\terror = recover_master_static(r, &count);\n\t\telse\n\t\t\terror = recover_master(r, &count, seq);\n\t\tunlock_rsb(r);\n\t\tcond_resched();\n\t\ttotal++;\n\n\t\tif (error) {\n\t\t\tup_read(&ls->ls_root_sem);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tup_read(&ls->ls_root_sem);\n\n\tlog_rinfo(ls, \"dlm_recover_masters %u of %u\", count, total);\n\n\terror = dlm_wait_function(ls, &recover_idr_empty);\n out:\n\tif (error)\n\t\trecover_idr_clear(ls);\n\treturn error;\n}\n\nint dlm_recover_master_reply(struct dlm_ls *ls, const struct dlm_rcom *rc)\n{\n\tstruct dlm_rsb *r;\n\tint ret_nodeid, new_master;\n\n\tr = recover_idr_find(ls, le64_to_cpu(rc->rc_id));\n\tif (!r) {\n\t\tlog_error(ls, \"dlm_recover_master_reply no id %llx\",\n\t\t\t  (unsigned long long)le64_to_cpu(rc->rc_id));\n\t\tgoto out;\n\t}\n\n\tret_nodeid = le32_to_cpu(rc->rc_result);\n\n\tif (ret_nodeid == dlm_our_nodeid())\n\t\tnew_master = 0;\n\telse\n\t\tnew_master = ret_nodeid;\n\n\tlock_rsb(r);\n\tr->res_master_nodeid = ret_nodeid;\n\tr->res_nodeid = new_master;\n\tset_new_master(r);\n\tunlock_rsb(r);\n\trecover_idr_del(r);\n\n\tif (recover_idr_empty(ls))\n\t\twake_up(&ls->ls_wait_general);\n out:\n\treturn 0;\n}\n\n\n \n\n\n \n\nstatic int recover_locks_queue(struct dlm_rsb *r, struct list_head *head,\n\t\t\t       uint64_t seq)\n{\n\tstruct dlm_lkb *lkb;\n\tint error = 0;\n\n\tlist_for_each_entry(lkb, head, lkb_statequeue) {\n\t\terror = dlm_send_rcom_lock(r, lkb, seq);\n\t\tif (error)\n\t\t\tbreak;\n\t\tr->res_recover_locks_count++;\n\t}\n\n\treturn error;\n}\n\nstatic int recover_locks(struct dlm_rsb *r, uint64_t seq)\n{\n\tint error = 0;\n\n\tlock_rsb(r);\n\n\tDLM_ASSERT(!r->res_recover_locks_count, dlm_dump_rsb(r););\n\n\terror = recover_locks_queue(r, &r->res_grantqueue, seq);\n\tif (error)\n\t\tgoto out;\n\terror = recover_locks_queue(r, &r->res_convertqueue, seq);\n\tif (error)\n\t\tgoto out;\n\terror = recover_locks_queue(r, &r->res_waitqueue, seq);\n\tif (error)\n\t\tgoto out;\n\n\tif (r->res_recover_locks_count)\n\t\trecover_list_add(r);\n\telse\n\t\trsb_clear_flag(r, RSB_NEW_MASTER);\n out:\n\tunlock_rsb(r);\n\treturn error;\n}\n\nint dlm_recover_locks(struct dlm_ls *ls, uint64_t seq)\n{\n\tstruct dlm_rsb *r;\n\tint error, count = 0;\n\n\tdown_read(&ls->ls_root_sem);\n\tlist_for_each_entry(r, &ls->ls_root_list, res_root_list) {\n\t\tif (is_master(r)) {\n\t\t\trsb_clear_flag(r, RSB_NEW_MASTER);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!rsb_flag(r, RSB_NEW_MASTER))\n\t\t\tcontinue;\n\n\t\tif (dlm_recovery_stopped(ls)) {\n\t\t\terror = -EINTR;\n\t\t\tup_read(&ls->ls_root_sem);\n\t\t\tgoto out;\n\t\t}\n\n\t\terror = recover_locks(r, seq);\n\t\tif (error) {\n\t\t\tup_read(&ls->ls_root_sem);\n\t\t\tgoto out;\n\t\t}\n\n\t\tcount += r->res_recover_locks_count;\n\t}\n\tup_read(&ls->ls_root_sem);\n\n\tlog_rinfo(ls, \"dlm_recover_locks %d out\", count);\n\n\terror = dlm_wait_function(ls, &recover_list_empty);\n out:\n\tif (error)\n\t\trecover_list_clear(ls);\n\treturn error;\n}\n\nvoid dlm_recovered_lock(struct dlm_rsb *r)\n{\n\tDLM_ASSERT(rsb_flag(r, RSB_NEW_MASTER), dlm_dump_rsb(r););\n\n\tr->res_recover_locks_count--;\n\tif (!r->res_recover_locks_count) {\n\t\trsb_clear_flag(r, RSB_NEW_MASTER);\n\t\trecover_list_del(r);\n\t}\n\n\tif (recover_list_empty(r->res_ls))\n\t\twake_up(&r->res_ls->ls_wait_general);\n}\n\n \n\nstatic void recover_lvb(struct dlm_rsb *r)\n{\n\tstruct dlm_lkb *big_lkb = NULL, *iter, *high_lkb = NULL;\n\tuint32_t high_seq = 0;\n\tint lock_lvb_exists = 0;\n\tint lvblen = r->res_ls->ls_lvblen;\n\n\tif (!rsb_flag(r, RSB_NEW_MASTER2) &&\n\t    rsb_flag(r, RSB_RECOVER_LVB_INVAL)) {\n\t\t \n\t\trsb_set_flag(r, RSB_VALNOTVALID);\n\t\treturn;\n\t}\n\n\tif (!rsb_flag(r, RSB_NEW_MASTER2))\n\t\treturn;\n\n\t \n\n\tlist_for_each_entry(iter, &r->res_grantqueue, lkb_statequeue) {\n\t\tif (!(iter->lkb_exflags & DLM_LKF_VALBLK))\n\t\t\tcontinue;\n\n\t\tlock_lvb_exists = 1;\n\n\t\tif (iter->lkb_grmode > DLM_LOCK_CR) {\n\t\t\tbig_lkb = iter;\n\t\t\tgoto setflag;\n\t\t}\n\n\t\tif (((int)iter->lkb_lvbseq - (int)high_seq) >= 0) {\n\t\t\thigh_lkb = iter;\n\t\t\thigh_seq = iter->lkb_lvbseq;\n\t\t}\n\t}\n\n\tlist_for_each_entry(iter, &r->res_convertqueue, lkb_statequeue) {\n\t\tif (!(iter->lkb_exflags & DLM_LKF_VALBLK))\n\t\t\tcontinue;\n\n\t\tlock_lvb_exists = 1;\n\n\t\tif (iter->lkb_grmode > DLM_LOCK_CR) {\n\t\t\tbig_lkb = iter;\n\t\t\tgoto setflag;\n\t\t}\n\n\t\tif (((int)iter->lkb_lvbseq - (int)high_seq) >= 0) {\n\t\t\thigh_lkb = iter;\n\t\t\thigh_seq = iter->lkb_lvbseq;\n\t\t}\n\t}\n\n setflag:\n\tif (!lock_lvb_exists)\n\t\tgoto out;\n\n\t \n\tif (!big_lkb)\n\t\trsb_set_flag(r, RSB_VALNOTVALID);\n\n\tif (!r->res_lvbptr) {\n\t\tr->res_lvbptr = dlm_allocate_lvb(r->res_ls);\n\t\tif (!r->res_lvbptr)\n\t\t\tgoto out;\n\t}\n\n\tif (big_lkb) {\n\t\tr->res_lvbseq = big_lkb->lkb_lvbseq;\n\t\tmemcpy(r->res_lvbptr, big_lkb->lkb_lvbptr, lvblen);\n\t} else if (high_lkb) {\n\t\tr->res_lvbseq = high_lkb->lkb_lvbseq;\n\t\tmemcpy(r->res_lvbptr, high_lkb->lkb_lvbptr, lvblen);\n\t} else {\n\t\tr->res_lvbseq = 0;\n\t\tmemset(r->res_lvbptr, 0, lvblen);\n\t}\n out:\n\treturn;\n}\n\n \n\nstatic void recover_conversion(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\tstruct dlm_lkb *lkb;\n\tint grmode = -1;\n\n\tlist_for_each_entry(lkb, &r->res_grantqueue, lkb_statequeue) {\n\t\tif (lkb->lkb_grmode == DLM_LOCK_PR ||\n\t\t    lkb->lkb_grmode == DLM_LOCK_CW) {\n\t\t\tgrmode = lkb->lkb_grmode;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tlist_for_each_entry(lkb, &r->res_convertqueue, lkb_statequeue) {\n\t\tif (lkb->lkb_grmode != DLM_LOCK_IV)\n\t\t\tcontinue;\n\t\tif (grmode == -1) {\n\t\t\tlog_debug(ls, \"recover_conversion %x set gr to rq %d\",\n\t\t\t\t  lkb->lkb_id, lkb->lkb_rqmode);\n\t\t\tlkb->lkb_grmode = lkb->lkb_rqmode;\n\t\t} else {\n\t\t\tlog_debug(ls, \"recover_conversion %x set gr %d\",\n\t\t\t\t  lkb->lkb_id, grmode);\n\t\t\tlkb->lkb_grmode = grmode;\n\t\t}\n\t}\n}\n\n \n\nstatic void recover_grant(struct dlm_rsb *r)\n{\n\tif (!list_empty(&r->res_waitqueue) || !list_empty(&r->res_convertqueue))\n\t\trsb_set_flag(r, RSB_RECOVER_GRANT);\n}\n\nvoid dlm_recover_rsbs(struct dlm_ls *ls)\n{\n\tstruct dlm_rsb *r;\n\tunsigned int count = 0;\n\n\tdown_read(&ls->ls_root_sem);\n\tlist_for_each_entry(r, &ls->ls_root_list, res_root_list) {\n\t\tlock_rsb(r);\n\t\tif (is_master(r)) {\n\t\t\tif (rsb_flag(r, RSB_RECOVER_CONVERT))\n\t\t\t\trecover_conversion(r);\n\n\t\t\t \n\t\t\trecover_lvb(r);\n\n\t\t\tif (rsb_flag(r, RSB_NEW_MASTER2))\n\t\t\t\trecover_grant(r);\n\t\t\tcount++;\n\t\t} else {\n\t\t\trsb_clear_flag(r, RSB_VALNOTVALID);\n\t\t}\n\t\trsb_clear_flag(r, RSB_RECOVER_CONVERT);\n\t\trsb_clear_flag(r, RSB_RECOVER_LVB_INVAL);\n\t\trsb_clear_flag(r, RSB_NEW_MASTER2);\n\t\tunlock_rsb(r);\n\t}\n\tup_read(&ls->ls_root_sem);\n\n\tif (count)\n\t\tlog_rinfo(ls, \"dlm_recover_rsbs %d done\", count);\n}\n\n \n\nint dlm_create_root_list(struct dlm_ls *ls)\n{\n\tstruct rb_node *n;\n\tstruct dlm_rsb *r;\n\tint i, error = 0;\n\n\tdown_write(&ls->ls_root_sem);\n\tif (!list_empty(&ls->ls_root_list)) {\n\t\tlog_error(ls, \"root list not empty\");\n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < ls->ls_rsbtbl_size; i++) {\n\t\tspin_lock(&ls->ls_rsbtbl[i].lock);\n\t\tfor (n = rb_first(&ls->ls_rsbtbl[i].keep); n; n = rb_next(n)) {\n\t\t\tr = rb_entry(n, struct dlm_rsb, res_hashnode);\n\t\t\tlist_add(&r->res_root_list, &ls->ls_root_list);\n\t\t\tdlm_hold_rsb(r);\n\t\t}\n\n\t\tif (!RB_EMPTY_ROOT(&ls->ls_rsbtbl[i].toss))\n\t\t\tlog_error(ls, \"dlm_create_root_list toss not empty\");\n\t\tspin_unlock(&ls->ls_rsbtbl[i].lock);\n\t}\n out:\n\tup_write(&ls->ls_root_sem);\n\treturn error;\n}\n\nvoid dlm_release_root_list(struct dlm_ls *ls)\n{\n\tstruct dlm_rsb *r, *safe;\n\n\tdown_write(&ls->ls_root_sem);\n\tlist_for_each_entry_safe(r, safe, &ls->ls_root_list, res_root_list) {\n\t\tlist_del_init(&r->res_root_list);\n\t\tdlm_put_rsb(r);\n\t}\n\tup_write(&ls->ls_root_sem);\n}\n\nvoid dlm_clear_toss(struct dlm_ls *ls)\n{\n\tstruct rb_node *n, *next;\n\tstruct dlm_rsb *r;\n\tunsigned int count = 0;\n\tint i;\n\n\tfor (i = 0; i < ls->ls_rsbtbl_size; i++) {\n\t\tspin_lock(&ls->ls_rsbtbl[i].lock);\n\t\tfor (n = rb_first(&ls->ls_rsbtbl[i].toss); n; n = next) {\n\t\t\tnext = rb_next(n);\n\t\t\tr = rb_entry(n, struct dlm_rsb, res_hashnode);\n\t\t\trb_erase(n, &ls->ls_rsbtbl[i].toss);\n\t\t\tdlm_free_rsb(r);\n\t\t\tcount++;\n\t\t}\n\t\tspin_unlock(&ls->ls_rsbtbl[i].lock);\n\t}\n\n\tif (count)\n\t\tlog_rinfo(ls, \"dlm_clear_toss %u done\", count);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}