{
  "module_name": "inode.c",
  "hash_id": "f52f0dd41dfef11c319476d670424a6bf712f63fadf2ad2f19bd20b3eb10fd74",
  "original_prompt": "Ingested from linux-6.6.14/fs/orangefs/inode.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/blkdev.h>\n#include <linux/fileattr.h>\n#include \"protocol.h\"\n#include \"orangefs-kernel.h\"\n#include \"orangefs-bufmap.h\"\n\nstatic int orangefs_writepage_locked(struct page *page,\n    struct writeback_control *wbc)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct orangefs_write_range *wr = NULL;\n\tstruct iov_iter iter;\n\tstruct bio_vec bv;\n\tsize_t len, wlen;\n\tssize_t ret;\n\tloff_t off;\n\n\tset_page_writeback(page);\n\n\tlen = i_size_read(inode);\n\tif (PagePrivate(page)) {\n\t\twr = (struct orangefs_write_range *)page_private(page);\n\t\tWARN_ON(wr->pos >= len);\n\t\toff = wr->pos;\n\t\tif (off + wr->len > len)\n\t\t\twlen = len - off;\n\t\telse\n\t\t\twlen = wr->len;\n\t} else {\n\t\tWARN_ON(1);\n\t\toff = page_offset(page);\n\t\tif (off + PAGE_SIZE > len)\n\t\t\twlen = len - off;\n\t\telse\n\t\t\twlen = PAGE_SIZE;\n\t}\n\t \n\tWARN_ON(off == len || off + wlen > len);\n\n\tWARN_ON(wlen == 0);\n\tbvec_set_page(&bv, page, wlen, off % PAGE_SIZE);\n\tiov_iter_bvec(&iter, ITER_SOURCE, &bv, 1, wlen);\n\n\tret = wait_for_direct_io(ORANGEFS_IO_WRITE, inode, &off, &iter, wlen,\n\t    len, wr, NULL, NULL);\n\tif (ret < 0) {\n\t\tSetPageError(page);\n\t\tmapping_set_error(page->mapping, ret);\n\t} else {\n\t\tret = 0;\n\t}\n\tkfree(detach_page_private(page));\n\treturn ret;\n}\n\nstatic int orangefs_writepage(struct page *page, struct writeback_control *wbc)\n{\n\tint ret;\n\tret = orangefs_writepage_locked(page, wbc);\n\tunlock_page(page);\n\tend_page_writeback(page);\n\treturn ret;\n}\n\nstruct orangefs_writepages {\n\tloff_t off;\n\tsize_t len;\n\tkuid_t uid;\n\tkgid_t gid;\n\tint maxpages;\n\tint npages;\n\tstruct page **pages;\n\tstruct bio_vec *bv;\n};\n\nstatic int orangefs_writepages_work(struct orangefs_writepages *ow,\n    struct writeback_control *wbc)\n{\n\tstruct inode *inode = ow->pages[0]->mapping->host;\n\tstruct orangefs_write_range *wrp, wr;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\tsize_t len;\n\tloff_t off;\n\tint i;\n\n\tlen = i_size_read(inode);\n\n\tfor (i = 0; i < ow->npages; i++) {\n\t\tset_page_writeback(ow->pages[i]);\n\t\tbvec_set_page(&ow->bv[i], ow->pages[i],\n\t\t\t      min(page_offset(ow->pages[i]) + PAGE_SIZE,\n\t\t\t          ow->off + ow->len) -\n\t\t\t      max(ow->off, page_offset(ow->pages[i])),\n\t\t\t      i == 0 ? ow->off - page_offset(ow->pages[i]) : 0);\n\t}\n\tiov_iter_bvec(&iter, ITER_SOURCE, ow->bv, ow->npages, ow->len);\n\n\tWARN_ON(ow->off >= len);\n\tif (ow->off + ow->len > len)\n\t\tow->len = len - ow->off;\n\n\toff = ow->off;\n\twr.uid = ow->uid;\n\twr.gid = ow->gid;\n\tret = wait_for_direct_io(ORANGEFS_IO_WRITE, inode, &off, &iter, ow->len,\n\t    0, &wr, NULL, NULL);\n\tif (ret < 0) {\n\t\tfor (i = 0; i < ow->npages; i++) {\n\t\t\tSetPageError(ow->pages[i]);\n\t\t\tmapping_set_error(ow->pages[i]->mapping, ret);\n\t\t\tif (PagePrivate(ow->pages[i])) {\n\t\t\t\twrp = (struct orangefs_write_range *)\n\t\t\t\t    page_private(ow->pages[i]);\n\t\t\t\tClearPagePrivate(ow->pages[i]);\n\t\t\t\tput_page(ow->pages[i]);\n\t\t\t\tkfree(wrp);\n\t\t\t}\n\t\t\tend_page_writeback(ow->pages[i]);\n\t\t\tunlock_page(ow->pages[i]);\n\t\t}\n\t} else {\n\t\tret = 0;\n\t\tfor (i = 0; i < ow->npages; i++) {\n\t\t\tif (PagePrivate(ow->pages[i])) {\n\t\t\t\twrp = (struct orangefs_write_range *)\n\t\t\t\t    page_private(ow->pages[i]);\n\t\t\t\tClearPagePrivate(ow->pages[i]);\n\t\t\t\tput_page(ow->pages[i]);\n\t\t\t\tkfree(wrp);\n\t\t\t}\n\t\t\tend_page_writeback(ow->pages[i]);\n\t\t\tunlock_page(ow->pages[i]);\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int orangefs_writepages_callback(struct folio *folio,\n\t\tstruct writeback_control *wbc, void *data)\n{\n\tstruct orangefs_writepages *ow = data;\n\tstruct orangefs_write_range *wr = folio->private;\n\tint ret;\n\n\tif (!wr) {\n\t\tfolio_unlock(folio);\n\t\t \n\t\tprintk(\"writepages_callback not private!\\n\");\n\t\tBUG();\n\t\treturn 0;\n\t}\n\n\tret = -1;\n\tif (ow->npages == 0) {\n\t\tow->off = wr->pos;\n\t\tow->len = wr->len;\n\t\tow->uid = wr->uid;\n\t\tow->gid = wr->gid;\n\t\tow->pages[ow->npages++] = &folio->page;\n\t\tret = 0;\n\t\tgoto done;\n\t}\n\tif (!uid_eq(ow->uid, wr->uid) || !gid_eq(ow->gid, wr->gid)) {\n\t\torangefs_writepages_work(ow, wbc);\n\t\tow->npages = 0;\n\t\tret = -1;\n\t\tgoto done;\n\t}\n\tif (ow->off + ow->len == wr->pos) {\n\t\tow->len += wr->len;\n\t\tow->pages[ow->npages++] = &folio->page;\n\t\tret = 0;\n\t\tgoto done;\n\t}\ndone:\n\tif (ret == -1) {\n\t\tif (ow->npages) {\n\t\t\torangefs_writepages_work(ow, wbc);\n\t\t\tow->npages = 0;\n\t\t}\n\t\tret = orangefs_writepage_locked(&folio->page, wbc);\n\t\tmapping_set_error(folio->mapping, ret);\n\t\tfolio_unlock(folio);\n\t\tfolio_end_writeback(folio);\n\t} else {\n\t\tif (ow->npages == ow->maxpages) {\n\t\t\torangefs_writepages_work(ow, wbc);\n\t\t\tow->npages = 0;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int orangefs_writepages(struct address_space *mapping,\n    struct writeback_control *wbc)\n{\n\tstruct orangefs_writepages *ow;\n\tstruct blk_plug plug;\n\tint ret;\n\tow = kzalloc(sizeof(struct orangefs_writepages), GFP_KERNEL);\n\tif (!ow)\n\t\treturn -ENOMEM;\n\tow->maxpages = orangefs_bufmap_size_query()/PAGE_SIZE;\n\tow->pages = kcalloc(ow->maxpages, sizeof(struct page *), GFP_KERNEL);\n\tif (!ow->pages) {\n\t\tkfree(ow);\n\t\treturn -ENOMEM;\n\t}\n\tow->bv = kcalloc(ow->maxpages, sizeof(struct bio_vec), GFP_KERNEL);\n\tif (!ow->bv) {\n\t\tkfree(ow->pages);\n\t\tkfree(ow);\n\t\treturn -ENOMEM;\n\t}\n\tblk_start_plug(&plug);\n\tret = write_cache_pages(mapping, wbc, orangefs_writepages_callback, ow);\n\tif (ow->npages)\n\t\tret = orangefs_writepages_work(ow, wbc);\n\tblk_finish_plug(&plug);\n\tkfree(ow->pages);\n\tkfree(ow->bv);\n\tkfree(ow);\n\treturn ret;\n}\n\nstatic int orangefs_launder_folio(struct folio *);\n\nstatic void orangefs_readahead(struct readahead_control *rac)\n{\n\tloff_t offset;\n\tstruct iov_iter iter;\n\tstruct inode *inode = rac->mapping->host;\n\tstruct xarray *i_pages;\n\tstruct folio *folio;\n\tloff_t new_start = readahead_pos(rac);\n\tint ret;\n\tsize_t new_len = 0;\n\n\tloff_t bytes_remaining = inode->i_size - readahead_pos(rac);\n\tloff_t pages_remaining = bytes_remaining / PAGE_SIZE;\n\n\tif (pages_remaining >= 1024)\n\t\tnew_len = 4194304;\n\telse if (pages_remaining > readahead_count(rac))\n\t\tnew_len = bytes_remaining;\n\n\tif (new_len)\n\t\treadahead_expand(rac, new_start, new_len);\n\n\toffset = readahead_pos(rac);\n\ti_pages = &rac->mapping->i_pages;\n\n\tiov_iter_xarray(&iter, ITER_DEST, i_pages, offset, readahead_length(rac));\n\n\t \n\tif ((ret = wait_for_direct_io(ORANGEFS_IO_READ, inode,\n\t\t\t&offset, &iter, readahead_length(rac),\n\t\t\tinode->i_size, NULL, NULL, rac->file)) < 0)\n\t\tgossip_debug(GOSSIP_FILE_DEBUG,\n\t\t\t\"%s: wait_for_direct_io failed. \\n\", __func__);\n\telse\n\t\tret = 0;\n\n\t \n\twhile ((folio = readahead_folio(rac))) {\n\t\tif (!ret)\n\t\t\tfolio_mark_uptodate(folio);\n\t\tfolio_unlock(folio);\n\t}\n}\n\nstatic int orangefs_read_folio(struct file *file, struct folio *folio)\n{\n\tstruct inode *inode = folio->mapping->host;\n\tstruct iov_iter iter;\n\tstruct bio_vec bv;\n\tssize_t ret;\n\tloff_t off;  \n\n\tif (folio_test_dirty(folio))\n\t\torangefs_launder_folio(folio);\n\n\toff = folio_pos(folio);\n\tbvec_set_folio(&bv, folio, folio_size(folio), 0);\n\tiov_iter_bvec(&iter, ITER_DEST, &bv, 1, folio_size(folio));\n\n\tret = wait_for_direct_io(ORANGEFS_IO_READ, inode, &off, &iter,\n\t\t\tfolio_size(folio), inode->i_size, NULL, NULL, file);\n\t \n\tiov_iter_zero(~0U, &iter);\n\t \n\tflush_dcache_folio(folio);\n\tif (ret < 0) {\n\t\tfolio_set_error(folio);\n\t} else {\n\t\tfolio_mark_uptodate(folio);\n\t\tret = 0;\n\t}\n\t \n\tfolio_unlock(folio);\n        return ret;\n}\n\nstatic int orangefs_write_begin(struct file *file,\n\t\tstruct address_space *mapping, loff_t pos, unsigned len,\n\t\tstruct page **pagep, void **fsdata)\n{\n\tstruct orangefs_write_range *wr;\n\tstruct folio *folio;\n\tstruct page *page;\n\tpgoff_t index;\n\tint ret;\n\n\tindex = pos >> PAGE_SHIFT;\n\n\tpage = grab_cache_page_write_begin(mapping, index);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\t*pagep = page;\n\tfolio = page_folio(page);\n\n\tif (folio_test_dirty(folio) && !folio_test_private(folio)) {\n\t\t \n\t\tret = orangefs_launder_folio(folio);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tif (folio_test_private(folio)) {\n\t\tstruct orangefs_write_range *wr;\n\t\twr = folio_get_private(folio);\n\t\tif (wr->pos + wr->len == pos &&\n\t\t    uid_eq(wr->uid, current_fsuid()) &&\n\t\t    gid_eq(wr->gid, current_fsgid())) {\n\t\t\twr->len += len;\n\t\t\tgoto okay;\n\t\t} else {\n\t\t\tret = orangefs_launder_folio(folio);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\twr = kmalloc(sizeof *wr, GFP_KERNEL);\n\tif (!wr)\n\t\treturn -ENOMEM;\n\n\twr->pos = pos;\n\twr->len = len;\n\twr->uid = current_fsuid();\n\twr->gid = current_fsgid();\n\tfolio_attach_private(folio, wr);\nokay:\n\treturn 0;\n}\n\nstatic int orangefs_write_end(struct file *file, struct address_space *mapping,\n    loff_t pos, unsigned len, unsigned copied, struct page *page, void *fsdata)\n{\n\tstruct inode *inode = page->mapping->host;\n\tloff_t last_pos = pos + copied;\n\n\t \n\tif (last_pos > inode->i_size)\n\t\ti_size_write(inode, last_pos);\n\n\t \n\tif (!PageUptodate(page)) {\n\t\tunsigned from = pos & (PAGE_SIZE - 1);\n\t\tif (copied < len) {\n\t\t\tzero_user(page, from + copied, len - copied);\n\t\t}\n\t\t \n\t\tif (pos == page_offset(page) &&\n\t\t    (len == PAGE_SIZE || pos + len == inode->i_size)) {\n\t\t\tzero_user_segment(page, from + copied, PAGE_SIZE);\n\t\t\tSetPageUptodate(page);\n\t\t}\n\t}\n\n\tset_page_dirty(page);\n\tunlock_page(page);\n\tput_page(page);\n\n\tmark_inode_dirty_sync(file_inode(file));\n\treturn copied;\n}\n\nstatic void orangefs_invalidate_folio(struct folio *folio,\n\t\t\t\t size_t offset, size_t length)\n{\n\tstruct orangefs_write_range *wr = folio_get_private(folio);\n\n\tif (offset == 0 && length == PAGE_SIZE) {\n\t\tkfree(folio_detach_private(folio));\n\t\treturn;\n\t \n\t} else if (folio_pos(folio) + offset <= wr->pos &&\n\t    wr->pos + wr->len <= folio_pos(folio) + offset + length) {\n\t\tkfree(folio_detach_private(folio));\n\t\t \n\t\tfolio_cancel_dirty(folio);\n\t\treturn;\n\t \n\t} else if (wr->pos < folio_pos(folio) + offset &&\n\t    wr->pos + wr->len <= folio_pos(folio) + offset + length &&\n\t     folio_pos(folio) + offset < wr->pos + wr->len) {\n\t\tsize_t x;\n\t\tx = wr->pos + wr->len - (folio_pos(folio) + offset);\n\t\tWARN_ON(x > wr->len);\n\t\twr->len -= x;\n\t\twr->uid = current_fsuid();\n\t\twr->gid = current_fsgid();\n\t \n\t} else if (folio_pos(folio) + offset <= wr->pos &&\n\t    folio_pos(folio) + offset + length < wr->pos + wr->len &&\n\t    wr->pos < folio_pos(folio) + offset + length) {\n\t\tsize_t x;\n\t\tx = folio_pos(folio) + offset + length - wr->pos;\n\t\tWARN_ON(x > wr->len);\n\t\twr->pos += x;\n\t\twr->len -= x;\n\t\twr->uid = current_fsuid();\n\t\twr->gid = current_fsgid();\n\t \n\t} else if (wr->pos < folio_pos(folio) + offset &&\n\t    folio_pos(folio) + offset + length < wr->pos + wr->len) {\n\t\t \n\t\tWARN_ON(1);\n\t\t \n\t\t \n\t\treturn;\n\t \n\t} else {\n\t\t \n\t\tif (!((folio_pos(folio) + offset + length <= wr->pos) ^\n\t\t    (wr->pos + wr->len <= folio_pos(folio) + offset))) {\n\t\t\tWARN_ON(1);\n\t\t\tprintk(\"invalidate range offset %llu length %zu\\n\",\n\t\t\t    folio_pos(folio) + offset, length);\n\t\t\tprintk(\"write range offset %llu length %zu\\n\",\n\t\t\t    wr->pos, wr->len);\n\t\t}\n\t\treturn;\n\t}\n\n\t \n\n\torangefs_launder_folio(folio);\n}\n\nstatic bool orangefs_release_folio(struct folio *folio, gfp_t foo)\n{\n\treturn !folio_test_private(folio);\n}\n\nstatic void orangefs_free_folio(struct folio *folio)\n{\n\tkfree(folio_detach_private(folio));\n}\n\nstatic int orangefs_launder_folio(struct folio *folio)\n{\n\tint r = 0;\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = WB_SYNC_ALL,\n\t\t.nr_to_write = 0,\n\t};\n\tfolio_wait_writeback(folio);\n\tif (folio_clear_dirty_for_io(folio)) {\n\t\tr = orangefs_writepage_locked(&folio->page, &wbc);\n\t\tfolio_end_writeback(folio);\n\t}\n\treturn r;\n}\n\nstatic ssize_t orangefs_direct_IO(struct kiocb *iocb,\n\t\t\t\t  struct iov_iter *iter)\n{\n\t \n\tstruct file *file = iocb->ki_filp;\n\tloff_t pos = iocb->ki_pos;\n\tenum ORANGEFS_io_type type = iov_iter_rw(iter) == WRITE ?\n            ORANGEFS_IO_WRITE : ORANGEFS_IO_READ;\n\tloff_t *offset = &pos;\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);\n\tstruct orangefs_khandle *handle = &orangefs_inode->refn.khandle;\n\tsize_t count = iov_iter_count(iter);\n\tssize_t total_count = 0;\n\tssize_t ret = -EINVAL;\n\n\tgossip_debug(GOSSIP_FILE_DEBUG,\n\t\t\"%s-BEGIN(%pU): count(%d) after estimate_max_iovecs.\\n\",\n\t\t__func__,\n\t\thandle,\n\t\t(int)count);\n\n\tif (type == ORANGEFS_IO_WRITE) {\n\t\tgossip_debug(GOSSIP_FILE_DEBUG,\n\t\t\t     \"%s(%pU): proceeding with offset : %llu, \"\n\t\t\t     \"size %d\\n\",\n\t\t\t     __func__,\n\t\t\t     handle,\n\t\t\t     llu(*offset),\n\t\t\t     (int)count);\n\t}\n\n\tif (count == 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\twhile (iov_iter_count(iter)) {\n\t\tsize_t each_count = iov_iter_count(iter);\n\t\tsize_t amt_complete;\n\n\t\t \n\t\tif (each_count > orangefs_bufmap_size_query())\n\t\t\teach_count = orangefs_bufmap_size_query();\n\n\t\tgossip_debug(GOSSIP_FILE_DEBUG,\n\t\t\t     \"%s(%pU): size of each_count(%d)\\n\",\n\t\t\t     __func__,\n\t\t\t     handle,\n\t\t\t     (int)each_count);\n\t\tgossip_debug(GOSSIP_FILE_DEBUG,\n\t\t\t     \"%s(%pU): BEFORE wait_for_io: offset is %d\\n\",\n\t\t\t     __func__,\n\t\t\t     handle,\n\t\t\t     (int)*offset);\n\n\t\tret = wait_for_direct_io(type, inode, offset, iter,\n\t\t\t\teach_count, 0, NULL, NULL, file);\n\t\tgossip_debug(GOSSIP_FILE_DEBUG,\n\t\t\t     \"%s(%pU): return from wait_for_io:%d\\n\",\n\t\t\t     __func__,\n\t\t\t     handle,\n\t\t\t     (int)ret);\n\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\t*offset += ret;\n\t\ttotal_count += ret;\n\t\tamt_complete = ret;\n\n\t\tgossip_debug(GOSSIP_FILE_DEBUG,\n\t\t\t     \"%s(%pU): AFTER wait_for_io: offset is %d\\n\",\n\t\t\t     __func__,\n\t\t\t     handle,\n\t\t\t     (int)*offset);\n\n\t\t \n\t\tif (amt_complete < each_count)\n\t\t\tbreak;\n\t}  \n\nout:\n\tif (total_count > 0)\n\t\tret = total_count;\n\tif (ret > 0) {\n\t\tif (type == ORANGEFS_IO_READ) {\n\t\t\tfile_accessed(file);\n\t\t} else {\n\t\t\tfile_update_time(file);\n\t\t\tif (*offset > i_size_read(inode))\n\t\t\t\ti_size_write(inode, *offset);\n\t\t}\n\t}\n\n\tgossip_debug(GOSSIP_FILE_DEBUG,\n\t\t     \"%s(%pU): Value(%d) returned.\\n\",\n\t\t     __func__,\n\t\t     handle,\n\t\t     (int)ret);\n\n\treturn ret;\n}\n\n \nstatic const struct address_space_operations orangefs_address_operations = {\n\t.writepage = orangefs_writepage,\n\t.readahead = orangefs_readahead,\n\t.read_folio = orangefs_read_folio,\n\t.writepages = orangefs_writepages,\n\t.dirty_folio = filemap_dirty_folio,\n\t.write_begin = orangefs_write_begin,\n\t.write_end = orangefs_write_end,\n\t.invalidate_folio = orangefs_invalidate_folio,\n\t.release_folio = orangefs_release_folio,\n\t.free_folio = orangefs_free_folio,\n\t.launder_folio = orangefs_launder_folio,\n\t.direct_IO = orangefs_direct_IO,\n};\n\nvm_fault_t orangefs_page_mkwrite(struct vm_fault *vmf)\n{\n\tstruct folio *folio = page_folio(vmf->page);\n\tstruct inode *inode = file_inode(vmf->vma->vm_file);\n\tstruct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);\n\tunsigned long *bitlock = &orangefs_inode->bitlock;\n\tvm_fault_t ret;\n\tstruct orangefs_write_range *wr;\n\n\tsb_start_pagefault(inode->i_sb);\n\n\tif (wait_on_bit(bitlock, 1, TASK_KILLABLE)) {\n\t\tret = VM_FAULT_RETRY;\n\t\tgoto out;\n\t}\n\n\tfolio_lock(folio);\n\tif (folio_test_dirty(folio) && !folio_test_private(folio)) {\n\t\t \n\t\tif (orangefs_launder_folio(folio)) {\n\t\t\tret = VM_FAULT_LOCKED|VM_FAULT_RETRY;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (folio_test_private(folio)) {\n\t\twr = folio_get_private(folio);\n\t\tif (uid_eq(wr->uid, current_fsuid()) &&\n\t\t    gid_eq(wr->gid, current_fsgid())) {\n\t\t\twr->pos = page_offset(vmf->page);\n\t\t\twr->len = PAGE_SIZE;\n\t\t\tgoto okay;\n\t\t} else {\n\t\t\tif (orangefs_launder_folio(folio)) {\n\t\t\t\tret = VM_FAULT_LOCKED|VM_FAULT_RETRY;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\twr = kmalloc(sizeof *wr, GFP_KERNEL);\n\tif (!wr) {\n\t\tret = VM_FAULT_LOCKED|VM_FAULT_RETRY;\n\t\tgoto out;\n\t}\n\twr->pos = page_offset(vmf->page);\n\twr->len = PAGE_SIZE;\n\twr->uid = current_fsuid();\n\twr->gid = current_fsgid();\n\tfolio_attach_private(folio, wr);\nokay:\n\n\tfile_update_time(vmf->vma->vm_file);\n\tif (folio->mapping != inode->i_mapping) {\n\t\tfolio_unlock(folio);\n\t\tret = VM_FAULT_LOCKED|VM_FAULT_NOPAGE;\n\t\tgoto out;\n\t}\n\n\t \n\tfolio_mark_dirty(folio);\n\tfolio_wait_stable(folio);\n\tret = VM_FAULT_LOCKED;\nout:\n\tsb_end_pagefault(inode->i_sb);\n\treturn ret;\n}\n\nstatic int orangefs_setattr_size(struct inode *inode, struct iattr *iattr)\n{\n\tstruct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);\n\tstruct orangefs_kernel_op_s *new_op;\n\tloff_t orig_size;\n\tint ret = -EINVAL;\n\n\tgossip_debug(GOSSIP_INODE_DEBUG,\n\t\t     \"%s: %pU: Handle is %pU | fs_id %d | size is %llu\\n\",\n\t\t     __func__,\n\t\t     get_khandle_from_ino(inode),\n\t\t     &orangefs_inode->refn.khandle,\n\t\t     orangefs_inode->refn.fs_id,\n\t\t     iattr->ia_size);\n\n\t \n\tret = orangefs_inode_getattr(inode, ORANGEFS_GETATTR_SIZE);\n\tif (ret == -ESTALE)\n\t\tret = -EIO;\n\tif (ret) {\n\t\tgossip_err(\"%s: orangefs_inode_getattr failed, ret:%d:.\\n\",\n\t\t    __func__, ret);\n\t\treturn ret;\n\t}\n\torig_size = i_size_read(inode);\n\n\t \n\ttruncate_pagecache(inode, iattr->ia_size);\n\ti_size_write(inode, iattr->ia_size);\n\tif (iattr->ia_size > orig_size)\n\t\tpagecache_isize_extended(inode, orig_size, iattr->ia_size);\n\n\tnew_op = op_alloc(ORANGEFS_VFS_OP_TRUNCATE);\n\tif (!new_op)\n\t\treturn -ENOMEM;\n\n\tnew_op->upcall.req.truncate.refn = orangefs_inode->refn;\n\tnew_op->upcall.req.truncate.size = (__s64) iattr->ia_size;\n\n\tret = service_operation(new_op,\n\t\t__func__,\n\t\tget_interruptible_flag(inode));\n\n\t \n\tgossip_debug(GOSSIP_INODE_DEBUG, \"%s: ret:%d:\\n\", __func__, ret);\n\n\top_release(new_op);\n\n\tif (ret != 0)\n\t\treturn ret;\n\n\tif (orig_size != i_size_read(inode))\n\t\tiattr->ia_valid |= ATTR_CTIME | ATTR_MTIME;\n\n\treturn ret;\n}\n\nint __orangefs_setattr(struct inode *inode, struct iattr *iattr)\n{\n\tint ret;\n\n\tif (iattr->ia_valid & ATTR_MODE) {\n\t\tif (iattr->ia_mode & (S_ISVTX)) {\n\t\t\tif (is_root_handle(inode)) {\n\t\t\t\t \n\t\t\t\tiattr->ia_mode -= S_ISVTX;\n\t\t\t} else {\n\t\t\t\tgossip_debug(GOSSIP_UTILS_DEBUG,\n\t\t\t\t\t     \"User attempted to set sticky bit on non-root directory; returning EINVAL.\\n\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tif (iattr->ia_mode & (S_ISUID)) {\n\t\t\tgossip_debug(GOSSIP_UTILS_DEBUG,\n\t\t\t\t     \"Attempting to set setuid bit (not supported); returning EINVAL.\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (iattr->ia_valid & ATTR_SIZE) {\n\t\tret = orangefs_setattr_size(inode, iattr);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\nagain:\n\tspin_lock(&inode->i_lock);\n\tif (ORANGEFS_I(inode)->attr_valid) {\n\t\tif (uid_eq(ORANGEFS_I(inode)->attr_uid, current_fsuid()) &&\n\t\t    gid_eq(ORANGEFS_I(inode)->attr_gid, current_fsgid())) {\n\t\t\tORANGEFS_I(inode)->attr_valid = iattr->ia_valid;\n\t\t} else {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\twrite_inode_now(inode, 1);\n\t\t\tgoto again;\n\t\t}\n\t} else {\n\t\tORANGEFS_I(inode)->attr_valid = iattr->ia_valid;\n\t\tORANGEFS_I(inode)->attr_uid = current_fsuid();\n\t\tORANGEFS_I(inode)->attr_gid = current_fsgid();\n\t}\n\tsetattr_copy(&nop_mnt_idmap, inode, iattr);\n\tspin_unlock(&inode->i_lock);\n\tmark_inode_dirty(inode);\n\n\tret = 0;\nout:\n\treturn ret;\n}\n\nint __orangefs_setattr_mode(struct dentry *dentry, struct iattr *iattr)\n{\n\tint ret;\n\tstruct inode *inode = d_inode(dentry);\n\n\tret = __orangefs_setattr(inode, iattr);\n\t \n\tif (!ret && (iattr->ia_valid & ATTR_MODE))\n\t\tret = posix_acl_chmod(&nop_mnt_idmap, dentry, inode->i_mode);\n\treturn ret;\n}\n\n \nint orangefs_setattr(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\t     struct iattr *iattr)\n{\n\tint ret;\n\tgossip_debug(GOSSIP_INODE_DEBUG, \"__orangefs_setattr: called on %pd\\n\",\n\t    dentry);\n\tret = setattr_prepare(&nop_mnt_idmap, dentry, iattr);\n\tif (ret)\n\t        goto out;\n\tret = __orangefs_setattr_mode(dentry, iattr);\n\tsync_inode_metadata(d_inode(dentry), 1);\nout:\n\tgossip_debug(GOSSIP_INODE_DEBUG, \"orangefs_setattr: returning %d\\n\",\n\t    ret);\n\treturn ret;\n}\n\n \nint orangefs_getattr(struct mnt_idmap *idmap, const struct path *path,\n\t\t     struct kstat *stat, u32 request_mask, unsigned int flags)\n{\n\tint ret;\n\tstruct inode *inode = path->dentry->d_inode;\n\n\tgossip_debug(GOSSIP_INODE_DEBUG,\n\t\t     \"orangefs_getattr: called on %pd mask %u\\n\",\n\t\t     path->dentry, request_mask);\n\n\tret = orangefs_inode_getattr(inode,\n\t    request_mask & STATX_SIZE ? ORANGEFS_GETATTR_SIZE : 0);\n\tif (ret == 0) {\n\t\tgeneric_fillattr(&nop_mnt_idmap, request_mask, inode, stat);\n\n\t\t \n\t\tif (!(request_mask & STATX_SIZE))\n\t\t\tstat->result_mask &= ~STATX_SIZE;\n\n\t\tgeneric_fill_statx_attr(inode, stat);\n\t}\n\treturn ret;\n}\n\nint orangefs_permission(struct mnt_idmap *idmap,\n\t\t\tstruct inode *inode, int mask)\n{\n\tint ret;\n\n\tif (mask & MAY_NOT_BLOCK)\n\t\treturn -ECHILD;\n\n\tgossip_debug(GOSSIP_INODE_DEBUG, \"%s: refreshing\\n\", __func__);\n\n\t \n\tret = orangefs_inode_getattr(inode, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn generic_permission(&nop_mnt_idmap, inode, mask);\n}\n\nint orangefs_update_time(struct inode *inode, int flags)\n{\n\tstruct iattr iattr;\n\n\tgossip_debug(GOSSIP_INODE_DEBUG, \"orangefs_update_time: %pU\\n\",\n\t    get_khandle_from_ino(inode));\n\tflags = generic_update_time(inode, flags);\n\tmemset(&iattr, 0, sizeof iattr);\n        if (flags & S_ATIME)\n\t\tiattr.ia_valid |= ATTR_ATIME;\n\tif (flags & S_CTIME)\n\t\tiattr.ia_valid |= ATTR_CTIME;\n\tif (flags & S_MTIME)\n\t\tiattr.ia_valid |= ATTR_MTIME;\n\treturn __orangefs_setattr(inode, &iattr);\n}\n\nstatic int orangefs_fileattr_get(struct dentry *dentry, struct fileattr *fa)\n{\n\tu64 val = 0;\n\tint ret;\n\n\tgossip_debug(GOSSIP_FILE_DEBUG, \"%s: called on %pd\\n\", __func__,\n\t\t     dentry);\n\n\tret = orangefs_inode_getxattr(d_inode(dentry),\n\t\t\t\t      \"user.pvfs2.meta_hint\",\n\t\t\t\t      &val, sizeof(val));\n\tif (ret < 0 && ret != -ENODATA)\n\t\treturn ret;\n\n\tgossip_debug(GOSSIP_FILE_DEBUG, \"%s: flags=%u\\n\", __func__, (u32) val);\n\n\tfileattr_fill_flags(fa, val);\n\treturn 0;\n}\n\nstatic int orangefs_fileattr_set(struct mnt_idmap *idmap,\n\t\t\t\t struct dentry *dentry, struct fileattr *fa)\n{\n\tu64 val = 0;\n\n\tgossip_debug(GOSSIP_FILE_DEBUG, \"%s: called on %pd\\n\", __func__,\n\t\t     dentry);\n\t \n\tif (fileattr_has_fsx(fa) ||\n\t    (fa->flags & ~(FS_IMMUTABLE_FL | FS_APPEND_FL | FS_NOATIME_FL | ORANGEFS_MIRROR_FL))) {\n\t\tgossip_err(\"%s: only supports setting one of FS_IMMUTABLE_FL|FS_APPEND_FL|FS_NOATIME_FL\\n\",\n\t\t\t   __func__);\n\t\treturn -EOPNOTSUPP;\n\t}\n\tval = fa->flags;\n\tgossip_debug(GOSSIP_FILE_DEBUG, \"%s: flags=%u\\n\", __func__, (u32) val);\n\treturn orangefs_inode_setxattr(d_inode(dentry),\n\t\t\t\t       \"user.pvfs2.meta_hint\",\n\t\t\t\t       &val, sizeof(val), 0);\n}\n\n \nstatic const struct inode_operations orangefs_file_inode_operations = {\n\t.get_inode_acl = orangefs_get_acl,\n\t.set_acl = orangefs_set_acl,\n\t.setattr = orangefs_setattr,\n\t.getattr = orangefs_getattr,\n\t.listxattr = orangefs_listxattr,\n\t.permission = orangefs_permission,\n\t.update_time = orangefs_update_time,\n\t.fileattr_get = orangefs_fileattr_get,\n\t.fileattr_set = orangefs_fileattr_set,\n};\n\nstatic int orangefs_init_iops(struct inode *inode)\n{\n\tinode->i_mapping->a_ops = &orangefs_address_operations;\n\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFREG:\n\t\tinode->i_op = &orangefs_file_inode_operations;\n\t\tinode->i_fop = &orangefs_file_operations;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &orangefs_symlink_inode_operations;\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tinode->i_op = &orangefs_dir_inode_operations;\n\t\tinode->i_fop = &orangefs_dir_operations;\n\t\tbreak;\n\tdefault:\n\t\tgossip_debug(GOSSIP_INODE_DEBUG,\n\t\t\t     \"%s: unsupported mode\\n\",\n\t\t\t     __func__);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic inline ino_t orangefs_handle_hash(struct orangefs_object_kref *ref)\n{\n\tif (!ref)\n\t\treturn 0;\n\treturn orangefs_khandle_to_ino(&(ref->khandle));\n}\n\n \nstatic int orangefs_set_inode(struct inode *inode, void *data)\n{\n\tstruct orangefs_object_kref *ref = (struct orangefs_object_kref *) data;\n\tORANGEFS_I(inode)->refn.fs_id = ref->fs_id;\n\tORANGEFS_I(inode)->refn.khandle = ref->khandle;\n\tORANGEFS_I(inode)->attr_valid = 0;\n\thash_init(ORANGEFS_I(inode)->xattr_cache);\n\tORANGEFS_I(inode)->mapping_time = jiffies - 1;\n\tORANGEFS_I(inode)->bitlock = 0;\n\treturn 0;\n}\n\n \nstatic int orangefs_test_inode(struct inode *inode, void *data)\n{\n\tstruct orangefs_object_kref *ref = (struct orangefs_object_kref *) data;\n\tstruct orangefs_inode_s *orangefs_inode = NULL;\n\n\torangefs_inode = ORANGEFS_I(inode);\n\t \n\treturn (!ORANGEFS_khandle_cmp(&(orangefs_inode->refn.khandle),\n\t\t\t\t&(ref->khandle)) &&\n\t\t\torangefs_inode->refn.fs_id == ref->fs_id);\n}\n\n \nstruct inode *orangefs_iget(struct super_block *sb,\n\t\tstruct orangefs_object_kref *ref)\n{\n\tstruct inode *inode = NULL;\n\tunsigned long hash;\n\tint error;\n\n\thash = orangefs_handle_hash(ref);\n\tinode = iget5_locked(sb,\n\t\t\thash,\n\t\t\torangefs_test_inode,\n\t\t\torangefs_set_inode,\n\t\t\tref);\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\terror = orangefs_inode_getattr(inode, ORANGEFS_GETATTR_NEW);\n\tif (error) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(error);\n\t}\n\n\tinode->i_ino = hash;\t \n\torangefs_init_iops(inode);\n\tunlock_new_inode(inode);\n\n\tgossip_debug(GOSSIP_INODE_DEBUG,\n\t\t     \"iget handle %pU, fsid %d hash %ld i_ino %lu\\n\",\n\t\t     &ref->khandle,\n\t\t     ref->fs_id,\n\t\t     hash,\n\t\t     inode->i_ino);\n\n\treturn inode;\n}\n\n \nstruct inode *orangefs_new_inode(struct super_block *sb, struct inode *dir,\n\t\tumode_t mode, dev_t dev, struct orangefs_object_kref *ref)\n{\n\tstruct posix_acl *acl = NULL, *default_acl = NULL;\n\tunsigned long hash = orangefs_handle_hash(ref);\n\tstruct inode *inode;\n\tint error;\n\n\tgossip_debug(GOSSIP_INODE_DEBUG,\n\t\t     \"%s:(sb is %p | MAJOR(dev)=%u | MINOR(dev)=%u mode=%o)\\n\",\n\t\t     __func__,\n\t\t     sb,\n\t\t     MAJOR(dev),\n\t\t     MINOR(dev),\n\t\t     mode);\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terror = posix_acl_create(dir, &mode, &default_acl, &acl);\n\tif (error)\n\t\tgoto out_iput;\n\n\torangefs_set_inode(inode, ref);\n\tinode->i_ino = hash;\t \n\n\terror = orangefs_inode_getattr(inode, ORANGEFS_GETATTR_NEW);\n\tif (error)\n\t\tgoto out_iput;\n\n\torangefs_init_iops(inode);\n\tinode->i_rdev = dev;\n\n\tif (default_acl) {\n\t\terror = __orangefs_set_acl(inode, default_acl,\n\t\t\t\t\t   ACL_TYPE_DEFAULT);\n\t\tif (error)\n\t\t\tgoto out_iput;\n\t}\n\n\tif (acl) {\n\t\terror = __orangefs_set_acl(inode, acl, ACL_TYPE_ACCESS);\n\t\tif (error)\n\t\t\tgoto out_iput;\n\t}\n\n\terror = insert_inode_locked4(inode, hash, orangefs_test_inode, ref);\n\tif (error < 0)\n\t\tgoto out_iput;\n\n\tgossip_debug(GOSSIP_INODE_DEBUG,\n\t\t     \"Initializing ACL's for inode %pU\\n\",\n\t\t     get_khandle_from_ino(inode));\n\tif (mode != inode->i_mode) {\n\t\tstruct iattr iattr = {\n\t\t\t.ia_mode = mode,\n\t\t\t.ia_valid = ATTR_MODE,\n\t\t};\n\t\tinode->i_mode = mode;\n\t\t__orangefs_setattr(inode, &iattr);\n\t\t__posix_acl_chmod(&acl, GFP_KERNEL, inode->i_mode);\n\t}\n\tposix_acl_release(acl);\n\tposix_acl_release(default_acl);\n\treturn inode;\n\nout_iput:\n\tiput(inode);\n\tposix_acl_release(acl);\n\tposix_acl_release(default_acl);\n\treturn ERR_PTR(error);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}