{
  "module_name": "devorangefs-req.c",
  "hash_id": "a75a0739228025456a235910b81be3906b418729b122b00685cc92dc411a6981",
  "original_prompt": "Ingested from linux-6.6.14/fs/orangefs/devorangefs-req.c",
  "human_readable_source": "\n \n\n#include \"protocol.h\"\n#include \"orangefs-kernel.h\"\n#include \"orangefs-dev-proto.h\"\n#include \"orangefs-bufmap.h\"\n#include \"orangefs-debugfs.h\"\n\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n\n \n\nuint32_t orangefs_userspace_version;\n\nstatic int open_access_count;\n\nstatic DEFINE_MUTEX(devreq_mutex);\n\n#define DUMP_DEVICE_ERROR()                                                   \\\ndo {                                                                          \\\n\tgossip_err(\"*****************************************************\\n\");\\\n\tgossip_err(\"ORANGEFS Device Error:  You cannot open the device file \");  \\\n\tgossip_err(\"\\n/dev/%s more than once.  Please make sure that\\nthere \" \\\n\t\t   \"are no \", ORANGEFS_REQDEVICE_NAME);                          \\\n\tgossip_err(\"instances of a program using this device\\ncurrently \"     \\\n\t\t   \"running. (You must verify this!)\\n\");                     \\\n\tgossip_err(\"For example, you can use the lsof program as follows:\\n\");\\\n\tgossip_err(\"'lsof | grep %s' (run this as root)\\n\",                   \\\n\t\t   ORANGEFS_REQDEVICE_NAME);                                     \\\n\tgossip_err(\"  open_access_count = %d\\n\", open_access_count);          \\\n\tgossip_err(\"*****************************************************\\n\");\\\n} while (0)\n\nstatic int hash_func(__u64 tag, int table_size)\n{\n\treturn do_div(tag, (unsigned int)table_size);\n}\n\nstatic void orangefs_devreq_add_op(struct orangefs_kernel_op_s *op)\n{\n\tint index = hash_func(op->tag, hash_table_size);\n\n\tlist_add_tail(&op->list, &orangefs_htable_ops_in_progress[index]);\n}\n\n \nstatic struct orangefs_kernel_op_s *orangefs_devreq_remove_op(__u64 tag)\n{\n\tstruct orangefs_kernel_op_s *op, *next;\n\tint index;\n\n\tindex = hash_func(tag, hash_table_size);\n\n\tspin_lock(&orangefs_htable_ops_in_progress_lock);\n\tlist_for_each_entry_safe(op,\n\t\t\t\t next,\n\t\t\t\t &orangefs_htable_ops_in_progress[index],\n\t\t\t\t list) {\n\t\tif (op->tag == tag && !op_state_purged(op) &&\n\t\t    !op_state_given_up(op)) {\n\t\t\tlist_del_init(&op->list);\n\t\t\tspin_unlock(&orangefs_htable_ops_in_progress_lock);\n\t\t\treturn op;\n\t\t}\n\t}\n\n\tspin_unlock(&orangefs_htable_ops_in_progress_lock);\n\treturn NULL;\n}\n\n \nstatic int mark_all_pending_mounts(void)\n{\n\tint unmounted = 1;\n\tstruct orangefs_sb_info_s *orangefs_sb = NULL;\n\n\tspin_lock(&orangefs_superblocks_lock);\n\tlist_for_each_entry(orangefs_sb, &orangefs_superblocks, list) {\n\t\t \n\t\torangefs_sb->mount_pending = 1;\n\t\tunmounted = 0;\n\t}\n\tspin_unlock(&orangefs_superblocks_lock);\n\treturn unmounted;\n}\n\n \nstatic int fs_mount_pending(__s32 fsid)\n{\n\tint mount_pending = -1;\n\tstruct orangefs_sb_info_s *orangefs_sb = NULL;\n\n\tspin_lock(&orangefs_superblocks_lock);\n\tlist_for_each_entry(orangefs_sb, &orangefs_superblocks, list) {\n\t\tif (orangefs_sb->fs_id == fsid) {\n\t\t\tmount_pending = orangefs_sb->mount_pending;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&orangefs_superblocks_lock);\n\treturn mount_pending;\n}\n\nstatic int orangefs_devreq_open(struct inode *inode, struct file *file)\n{\n\tint ret = -EINVAL;\n\n\t \n\tif (file->f_cred->user_ns != &init_user_ns) {\n\t\tgossip_err(\"%s: device cannot be opened outside init_user_ns\\n\",\n\t\t\t   __func__);\n\t\tgoto out;\n\t}\n\n\tif (!(file->f_flags & O_NONBLOCK)) {\n\t\tgossip_err(\"%s: device cannot be opened in blocking mode\\n\",\n\t\t\t   __func__);\n\t\tgoto out;\n\t}\n\tret = -EACCES;\n\tgossip_debug(GOSSIP_DEV_DEBUG, \"client-core: opening device\\n\");\n\tmutex_lock(&devreq_mutex);\n\n\tif (open_access_count == 0) {\n\t\topen_access_count = 1;\n\t\tret = 0;\n\t} else {\n\t\tDUMP_DEVICE_ERROR();\n\t}\n\tmutex_unlock(&devreq_mutex);\n\nout:\n\n\tgossip_debug(GOSSIP_DEV_DEBUG,\n\t\t     \"pvfs2-client-core: open device complete (ret = %d)\\n\",\n\t\t     ret);\n\treturn ret;\n}\n\n \nstatic ssize_t orangefs_devreq_read(struct file *file,\n\t\t\t\t char __user *buf,\n\t\t\t\t size_t count, loff_t *offset)\n{\n\tstruct orangefs_kernel_op_s *op, *temp;\n\t__s32 proto_ver = ORANGEFS_KERNEL_PROTO_VERSION;\n\tstatic __s32 magic = ORANGEFS_DEVREQ_MAGIC;\n\tstruct orangefs_kernel_op_s *cur_op;\n\tunsigned long ret;\n\n\t \n\tif (!(file->f_flags & O_NONBLOCK)) {\n\t\tgossip_err(\"%s: blocking read from client-core.\\n\",\n\t\t\t   __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (count != MAX_DEV_REQ_UPSIZE) {\n\t\tgossip_err(\"orangefs: client-core tried to read wrong size\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (list_empty(&orangefs_request_list))\n\t\treturn -EAGAIN;\n\nrestart:\n\tcur_op = NULL;\n\t \n\tspin_lock(&orangefs_request_list_lock);\n\tlist_for_each_entry_safe(op, temp, &orangefs_request_list, list) {\n\t\t__s32 fsid;\n\t\t \n\t\tspin_lock(&op->lock);\n\t\tif (unlikely(op_state_purged(op) || op_state_given_up(op))) {\n\t\t\tspin_unlock(&op->lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfsid = fsid_of_op(op);\n\t\tif (fsid != ORANGEFS_FS_ID_NULL) {\n\t\t\tint ret;\n\t\t\t \n\t\t\tret = fs_mount_pending(fsid);\n\t\t\tif (ret == 1) {\n\t\t\t\tgossip_debug(GOSSIP_DEV_DEBUG,\n\t\t\t\t    \"%s: mount pending, skipping op tag \"\n\t\t\t\t    \"%llu %s\\n\",\n\t\t\t\t    __func__,\n\t\t\t\t    llu(op->tag),\n\t\t\t\t    get_opname_string(op));\n\t\t\t\tspin_unlock(&op->lock);\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\t \n\t\t\t} else if (ret == -1 &&\n\t\t\t\t   !(op->upcall.type ==\n\t\t\t\t\tORANGEFS_VFS_OP_FS_MOUNT ||\n\t\t\t\t     op->upcall.type ==\n\t\t\t\t\tORANGEFS_VFS_OP_GETATTR ||\n\t\t\t\t     op->upcall.type ==\n\t\t\t\t\tORANGEFS_VFS_OP_FS_UMOUNT)) {\n\t\t\t\tgossip_debug(GOSSIP_DEV_DEBUG,\n\t\t\t\t    \"orangefs: skipping op tag %llu %s\\n\",\n\t\t\t\t    llu(op->tag), get_opname_string(op));\n\t\t\t\tgossip_err(\n\t\t\t\t    \"orangefs: ERROR: fs_mount_pending %d\\n\",\n\t\t\t\t    fsid);\n\t\t\t\tspin_unlock(&op->lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t \n\t\tcur_op = op;\n\t\tbreak;\n\t}\n\n\t \n\tif (!cur_op) {\n\t\tspin_unlock(&orangefs_request_list_lock);\n\t\treturn -EAGAIN;\n\t}\n\n\tgossip_debug(GOSSIP_DEV_DEBUG, \"%s: reading op tag %llu %s\\n\",\n\t\t     __func__,\n\t\t     llu(cur_op->tag),\n\t\t     get_opname_string(cur_op));\n\n\t \n\tif (op_state_in_progress(cur_op) || op_state_serviced(cur_op)) {\n\t\tgossip_err(\"orangefs: ERROR: Current op already queued.\\n\");\n\t\tlist_del_init(&cur_op->list);\n\t\tspin_unlock(&cur_op->lock);\n\t\tspin_unlock(&orangefs_request_list_lock);\n\t\treturn -EAGAIN;\n\t}\n\n\tlist_del_init(&cur_op->list);\n\tspin_unlock(&orangefs_request_list_lock);\n\n\tspin_unlock(&cur_op->lock);\n\n\t \n\tret = copy_to_user(buf, &proto_ver, sizeof(__s32));\n\tif (ret != 0)\n\t\tgoto error;\n\tret = copy_to_user(buf + sizeof(__s32), &magic, sizeof(__s32));\n\tif (ret != 0)\n\t\tgoto error;\n\tret = copy_to_user(buf + 2 * sizeof(__s32),\n\t\t&cur_op->tag,\n\t\tsizeof(__u64));\n\tif (ret != 0)\n\t\tgoto error;\n\tret = copy_to_user(buf + 2 * sizeof(__s32) + sizeof(__u64),\n\t\t&cur_op->upcall,\n\t\tsizeof(struct orangefs_upcall_s));\n\tif (ret != 0)\n\t\tgoto error;\n\n\tspin_lock(&orangefs_htable_ops_in_progress_lock);\n\tspin_lock(&cur_op->lock);\n\tif (unlikely(op_state_given_up(cur_op))) {\n\t\tspin_unlock(&cur_op->lock);\n\t\tspin_unlock(&orangefs_htable_ops_in_progress_lock);\n\t\tcomplete(&cur_op->waitq);\n\t\tgoto restart;\n\t}\n\n\t \n\tset_op_state_inprogress(cur_op);\n\tgossip_debug(GOSSIP_DEV_DEBUG,\n\t\t     \"%s: 1 op:%s: op_state:%d: process:%s:\\n\",\n\t\t     __func__,\n\t\t     get_opname_string(cur_op),\n\t\t     cur_op->op_state,\n\t\t     current->comm);\n\torangefs_devreq_add_op(cur_op);\n\tspin_unlock(&cur_op->lock);\n\tspin_unlock(&orangefs_htable_ops_in_progress_lock);\n\n\t \n\treturn MAX_DEV_REQ_UPSIZE;\nerror:\n\t \n\tgossip_err(\"orangefs: Failed to copy data to user space\\n\");\n\tspin_lock(&orangefs_request_list_lock);\n\tspin_lock(&cur_op->lock);\n\tif (likely(!op_state_given_up(cur_op))) {\n\t\tset_op_state_waiting(cur_op);\n\t\tgossip_debug(GOSSIP_DEV_DEBUG,\n\t\t\t     \"%s: 2 op:%s: op_state:%d: process:%s:\\n\",\n\t\t\t     __func__,\n\t\t\t     get_opname_string(cur_op),\n\t\t\t     cur_op->op_state,\n\t\t\t     current->comm);\n\t\tlist_add(&cur_op->list, &orangefs_request_list);\n\t\tspin_unlock(&cur_op->lock);\n\t} else {\n\t\tspin_unlock(&cur_op->lock);\n\t\tcomplete(&cur_op->waitq);\n\t}\n\tspin_unlock(&orangefs_request_list_lock);\n\treturn -EFAULT;\n}\n\n \nstatic ssize_t orangefs_devreq_write_iter(struct kiocb *iocb,\n\t\t\t\t      struct iov_iter *iter)\n{\n\tssize_t ret;\n\tstruct orangefs_kernel_op_s *op = NULL;\n\tstruct {\n\t\t__u32 version;\n\t\t__u32 magic;\n\t\t__u64 tag;\n\t} head;\n\tint total = ret = iov_iter_count(iter);\n\tint downcall_size = sizeof(struct orangefs_downcall_s);\n\tint head_size = sizeof(head);\n\n\tgossip_debug(GOSSIP_DEV_DEBUG, \"%s: total:%d: ret:%zd:\\n\",\n\t\t     __func__,\n\t\t     total,\n\t\t     ret);\n\n        if (total < MAX_DEV_REQ_DOWNSIZE) {\n\t\tgossip_err(\"%s: total:%d: must be at least:%u:\\n\",\n\t\t\t   __func__,\n\t\t\t   total,\n\t\t\t   (unsigned int) MAX_DEV_REQ_DOWNSIZE);\n\t\treturn -EFAULT;\n\t}\n\n\tif (!copy_from_iter_full(&head, head_size, iter)) {\n\t\tgossip_err(\"%s: failed to copy head.\\n\", __func__);\n\t\treturn -EFAULT;\n\t}\n\n\tif (head.version < ORANGEFS_MINIMUM_USERSPACE_VERSION) {\n\t\tgossip_err(\"%s: userspace claims version\"\n\t\t\t   \"%d, minimum version required: %d.\\n\",\n\t\t\t   __func__,\n\t\t\t   head.version,\n\t\t\t   ORANGEFS_MINIMUM_USERSPACE_VERSION);\n\t\treturn -EPROTO;\n\t}\n\n\tif (head.magic != ORANGEFS_DEVREQ_MAGIC) {\n\t\tgossip_err(\"Error: Device magic number does not match.\\n\");\n\t\treturn -EPROTO;\n\t}\n\n\tif (!orangefs_userspace_version) {\n\t\torangefs_userspace_version = head.version;\n\t} else if (orangefs_userspace_version != head.version) {\n\t\tgossip_err(\"Error: userspace version changes\\n\");\n\t\treturn -EPROTO;\n\t}\n\n\t \n\top = orangefs_devreq_remove_op(head.tag);\n\tif (!op) {\n\t\tgossip_debug(GOSSIP_DEV_DEBUG,\n\t\t\t     \"%s: No one's waiting for tag %llu\\n\",\n\t\t\t     __func__, llu(head.tag));\n\t\treturn ret;\n\t}\n\n\tif (!copy_from_iter_full(&op->downcall, downcall_size, iter)) {\n\t\tgossip_err(\"%s: failed to copy downcall.\\n\", __func__);\n\t\tgoto Efault;\n\t}\n\n\tif (op->downcall.status)\n\t\tgoto wakeup;\n\n\t \n\tif ((head_size + downcall_size + op->downcall.trailer_size) != total) {\n\t\tgossip_err(\"%s: funky write, head_size:%d\"\n\t\t\t   \": downcall_size:%d: trailer_size:%lld\"\n\t\t\t   \": total size:%d:\\n\",\n\t\t\t   __func__,\n\t\t\t   head_size,\n\t\t\t   downcall_size,\n\t\t\t   op->downcall.trailer_size,\n\t\t\t   total);\n\t\tgoto Efault;\n\t}\n\n\t \n\tif ((op->downcall.type != ORANGEFS_VFS_OP_READDIR) &&\n\t    (op->downcall.trailer_size != 0)) {\n\t\tgossip_err(\"%s: %x operation with trailer.\",\n\t\t\t   __func__,\n\t\t\t   op->downcall.type);\n\t\tgoto Efault;\n\t}\n\n\t \n\tif ((op->downcall.type == ORANGEFS_VFS_OP_READDIR) &&\n\t    (op->downcall.trailer_size == 0)) {\n\t\tgossip_err(\"%s: %x operation with no trailer.\",\n\t\t\t   __func__,\n\t\t\t   op->downcall.type);\n\t\tgoto Efault;\n\t}\n\n\tif (op->downcall.type != ORANGEFS_VFS_OP_READDIR)\n\t\tgoto wakeup;\n\n\top->downcall.trailer_buf = vzalloc(op->downcall.trailer_size);\n\tif (!op->downcall.trailer_buf)\n\t\tgoto Enomem;\n\n\tif (!copy_from_iter_full(op->downcall.trailer_buf,\n\t\t\t         op->downcall.trailer_size, iter)) {\n\t\tgossip_err(\"%s: failed to copy trailer.\\n\", __func__);\n\t\tvfree(op->downcall.trailer_buf);\n\t\tgoto Efault;\n\t}\n\nwakeup:\n\t \n\tspin_lock(&op->lock);\n\tif (unlikely(op_is_cancel(op))) {\n\t\tspin_unlock(&op->lock);\n\t\tput_cancel(op);\n\t} else if (unlikely(op_state_given_up(op))) {\n\t\tspin_unlock(&op->lock);\n\t\tcomplete(&op->waitq);\n\t} else {\n\t\tset_op_state_serviced(op);\n\t\tgossip_debug(GOSSIP_DEV_DEBUG,\n\t\t\t     \"%s: op:%s: op_state:%d: process:%s:\\n\",\n\t\t\t     __func__,\n\t\t\t     get_opname_string(op),\n\t\t\t     op->op_state,\n\t\t\t     current->comm);\n\t\tspin_unlock(&op->lock);\n\t}\n\treturn ret;\n\nEfault:\n\top->downcall.status = -(ORANGEFS_ERROR_BIT | 9);\n\tret = -EFAULT;\n\tgoto wakeup;\n\nEnomem:\n\top->downcall.status = -(ORANGEFS_ERROR_BIT | 8);\n\tret = -ENOMEM;\n\tgoto wakeup;\n}\n\n \nstatic int orangefs_devreq_release(struct inode *inode, struct file *file)\n{\n\tint unmounted = 0;\n\n\tgossip_debug(GOSSIP_DEV_DEBUG,\n\t\t     \"%s:pvfs2-client-core: exiting, closing device\\n\",\n\t\t     __func__);\n\n\tmutex_lock(&devreq_mutex);\n\torangefs_bufmap_finalize();\n\n\topen_access_count = -1;\n\n\tunmounted = mark_all_pending_mounts();\n\tgossip_debug(GOSSIP_DEV_DEBUG, \"ORANGEFS Device Close: Filesystem(s) %s\\n\",\n\t\t     (unmounted ? \"UNMOUNTED\" : \"MOUNTED\"));\n\n\tpurge_waiting_ops();\n\tpurge_inprogress_ops();\n\n\torangefs_bufmap_run_down();\n\n\tgossip_debug(GOSSIP_DEV_DEBUG,\n\t\t     \"pvfs2-client-core: device close complete\\n\");\n\topen_access_count = 0;\n\torangefs_userspace_version = 0;\n\tmutex_unlock(&devreq_mutex);\n\treturn 0;\n}\n\nint is_daemon_in_service(void)\n{\n\tint in_service;\n\n\t \n\tmutex_lock(&devreq_mutex);\n\tin_service = open_access_count == 1 ? 0 : -EIO;\n\tmutex_unlock(&devreq_mutex);\n\treturn in_service;\n}\n\nbool __is_daemon_in_service(void)\n{\n\treturn open_access_count == 1;\n}\n\nstatic inline long check_ioctl_command(unsigned int command)\n{\n\t \n\tif (_IOC_TYPE(command) != ORANGEFS_DEV_MAGIC) {\n\t\tgossip_err(\"device ioctl magic numbers don't match! Did you rebuild pvfs2-client-core/libpvfs2? [cmd %x, magic %x != %x]\\n\",\n\t\t\tcommand,\n\t\t\t_IOC_TYPE(command),\n\t\t\tORANGEFS_DEV_MAGIC);\n\t\treturn -EINVAL;\n\t}\n\t \n\tif (_IOC_NR(command) >= ORANGEFS_DEV_MAXNR || _IOC_NR(command) <= 0) {\n\t\tgossip_err(\"Invalid ioctl command number [%d >= %d]\\n\",\n\t\t\t   _IOC_NR(command), ORANGEFS_DEV_MAXNR);\n\t\treturn -ENOIOCTLCMD;\n\t}\n\treturn 0;\n}\n\nstatic long dispatch_ioctl_command(unsigned int command, unsigned long arg)\n{\n\tstatic __s32 magic = ORANGEFS_DEVREQ_MAGIC;\n\tstatic __s32 max_up_size = MAX_DEV_REQ_UPSIZE;\n\tstatic __s32 max_down_size = MAX_DEV_REQ_DOWNSIZE;\n\tstruct ORANGEFS_dev_map_desc user_desc;\n\tint ret = 0;\n\tint upstream_kmod = 1;\n\tstruct orangefs_sb_info_s *orangefs_sb;\n\n\t \n\n\tswitch (command) {\n\tcase ORANGEFS_DEV_GET_MAGIC:\n\t\treturn ((put_user(magic, (__s32 __user *) arg) == -EFAULT) ?\n\t\t\t-EIO :\n\t\t\t0);\n\tcase ORANGEFS_DEV_GET_MAX_UPSIZE:\n\t\treturn ((put_user(max_up_size,\n\t\t\t\t  (__s32 __user *) arg) == -EFAULT) ?\n\t\t\t\t\t-EIO :\n\t\t\t\t\t0);\n\tcase ORANGEFS_DEV_GET_MAX_DOWNSIZE:\n\t\treturn ((put_user(max_down_size,\n\t\t\t\t  (__s32 __user *) arg) == -EFAULT) ?\n\t\t\t\t\t-EIO :\n\t\t\t\t\t0);\n\tcase ORANGEFS_DEV_MAP:\n\t\tret = copy_from_user(&user_desc,\n\t\t\t\t     (struct ORANGEFS_dev_map_desc __user *)\n\t\t\t\t     arg,\n\t\t\t\t     sizeof(struct ORANGEFS_dev_map_desc));\n\t\t \n\t\treturn ret ? -EIO : orangefs_bufmap_initialize(&user_desc);\n\tcase ORANGEFS_DEV_REMOUNT_ALL:\n\t\tgossip_debug(GOSSIP_DEV_DEBUG,\n\t\t\t     \"%s: got ORANGEFS_DEV_REMOUNT_ALL\\n\",\n\t\t\t     __func__);\n\n\t\t \n\t\tret = mutex_lock_interruptible(&orangefs_request_mutex);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tgossip_debug(GOSSIP_DEV_DEBUG,\n\t\t\t     \"%s: priority remount in progress\\n\",\n\t\t\t     __func__);\n\t\tspin_lock(&orangefs_superblocks_lock);\n\t\tlist_for_each_entry(orangefs_sb, &orangefs_superblocks, list) {\n\t\t\t \n\t\t\tif (!orangefs_sb->list.prev)\n\t\t\t\tcontinue;\n\t\t\tgossip_debug(GOSSIP_DEV_DEBUG,\n\t\t\t\t     \"%s: Remounting SB %p\\n\",\n\t\t\t\t     __func__,\n\t\t\t\t     orangefs_sb);\n\n\t\t\tspin_unlock(&orangefs_superblocks_lock);\n\t\t\tret = orangefs_remount(orangefs_sb);\n\t\t\tspin_lock(&orangefs_superblocks_lock);\n\t\t\tif (ret) {\n\t\t\t\tgossip_debug(GOSSIP_DEV_DEBUG,\n\t\t\t\t\t     \"SB %p remount failed\\n\",\n\t\t\t\t\t     orangefs_sb);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&orangefs_superblocks_lock);\n\t\tgossip_debug(GOSSIP_DEV_DEBUG,\n\t\t\t     \"%s: priority remount complete\\n\",\n\t\t\t     __func__);\n\t\tmutex_unlock(&orangefs_request_mutex);\n\t\treturn ret;\n\n\tcase ORANGEFS_DEV_UPSTREAM:\n\t\tret = copy_to_user((void __user *)arg,\n\t\t\t\t    &upstream_kmod,\n\t\t\t\t    sizeof(upstream_kmod));\n\n\t\tif (ret != 0)\n\t\t\treturn -EIO;\n\t\telse\n\t\t\treturn ret;\n\n\tcase ORANGEFS_DEV_CLIENT_MASK:\n\t\treturn orangefs_debugfs_new_client_mask((void __user *)arg);\n\tcase ORANGEFS_DEV_CLIENT_STRING:\n\t\treturn orangefs_debugfs_new_client_string((void __user *)arg);\n\tcase ORANGEFS_DEV_DEBUG:\n\t\treturn orangefs_debugfs_new_debug((void __user *)arg);\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\treturn -ENOIOCTLCMD;\n}\n\nstatic long orangefs_devreq_ioctl(struct file *file,\n\t\t\t       unsigned int command, unsigned long arg)\n{\n\tlong ret;\n\n\t \n\tret = check_ioctl_command(command);\n\tif (ret < 0)\n\t\treturn (int)ret;\n\n\treturn (int)dispatch_ioctl_command(command, arg);\n}\n\n#ifdef CONFIG_COMPAT\t\t \n\n \nstruct ORANGEFS_dev_map_desc32 {\n\tcompat_uptr_t ptr;\n\t__s32 total_size;\n\t__s32 size;\n\t__s32 count;\n};\n\n \nstatic long orangefs_devreq_compat_ioctl(struct file *filp, unsigned int cmd,\n\t\t\t\t      unsigned long args)\n{\n\tlong ret;\n\n\t \n\tret = check_ioctl_command(cmd);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (cmd == ORANGEFS_DEV_MAP) {\n\t\tstruct ORANGEFS_dev_map_desc desc;\n\t\tstruct ORANGEFS_dev_map_desc32 d32;\n\n\t\tif (copy_from_user(&d32, (void __user *)args, sizeof(d32)))\n\t\t\treturn -EFAULT;\n\n\t\tdesc.ptr = compat_ptr(d32.ptr);\n\t\tdesc.total_size = d32.total_size;\n\t\tdesc.size = d32.size;\n\t\tdesc.count = d32.count;\n\t\treturn orangefs_bufmap_initialize(&desc);\n\t}\n\t \n\treturn dispatch_ioctl_command(cmd, args);\n}\n\n#endif  \n\nstatic __poll_t orangefs_devreq_poll(struct file *file,\n\t\t\t\t      struct poll_table_struct *poll_table)\n{\n\t__poll_t poll_revent_mask = 0;\n\n\tpoll_wait(file, &orangefs_request_list_waitq, poll_table);\n\n\tif (!list_empty(&orangefs_request_list))\n\t\tpoll_revent_mask |= EPOLLIN;\n\treturn poll_revent_mask;\n}\n\n \nstatic int orangefs_dev_major;\n\nstatic const struct file_operations orangefs_devreq_file_operations = {\n\t.owner = THIS_MODULE,\n\t.read = orangefs_devreq_read,\n\t.write_iter = orangefs_devreq_write_iter,\n\t.open = orangefs_devreq_open,\n\t.release = orangefs_devreq_release,\n\t.unlocked_ioctl = orangefs_devreq_ioctl,\n\n#ifdef CONFIG_COMPAT\t\t \n\t.compat_ioctl = orangefs_devreq_compat_ioctl,\n#endif\n\t.poll = orangefs_devreq_poll\n};\n\n \nint orangefs_dev_init(void)\n{\n\t \n\torangefs_dev_major = register_chrdev(0,\n\t\t\t\t\t  ORANGEFS_REQDEVICE_NAME,\n\t\t\t\t\t  &orangefs_devreq_file_operations);\n\tif (orangefs_dev_major < 0) {\n\t\tgossip_debug(GOSSIP_DEV_DEBUG,\n\t\t\t     \"Failed to register /dev/%s (error %d)\\n\",\n\t\t\t     ORANGEFS_REQDEVICE_NAME, orangefs_dev_major);\n\t\treturn orangefs_dev_major;\n\t}\n\n\tgossip_debug(GOSSIP_DEV_DEBUG,\n\t\t     \"*** /dev/%s character device registered ***\\n\",\n\t\t     ORANGEFS_REQDEVICE_NAME);\n\tgossip_debug(GOSSIP_DEV_DEBUG, \"'mknod /dev/%s c %d 0'.\\n\",\n\t\t     ORANGEFS_REQDEVICE_NAME, orangefs_dev_major);\n\treturn 0;\n}\n\nvoid orangefs_dev_cleanup(void)\n{\n\tunregister_chrdev(orangefs_dev_major, ORANGEFS_REQDEVICE_NAME);\n\tgossip_debug(GOSSIP_DEV_DEBUG,\n\t\t     \"*** /dev/%s character device unregistered ***\\n\",\n\t\t     ORANGEFS_REQDEVICE_NAME);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}