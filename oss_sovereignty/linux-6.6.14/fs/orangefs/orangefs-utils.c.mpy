{
  "module_name": "orangefs-utils.c",
  "hash_id": "d644d7ec91d0eb14e442df6a5d189ba28c2067ca5982ad20f14ce42c3e3ce1db",
  "original_prompt": "Ingested from linux-6.6.14/fs/orangefs/orangefs-utils.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include \"protocol.h\"\n#include \"orangefs-kernel.h\"\n#include \"orangefs-dev-proto.h\"\n#include \"orangefs-bufmap.h\"\n\n__s32 fsid_of_op(struct orangefs_kernel_op_s *op)\n{\n\t__s32 fsid = ORANGEFS_FS_ID_NULL;\n\n\tif (op) {\n\t\tswitch (op->upcall.type) {\n\t\tcase ORANGEFS_VFS_OP_FILE_IO:\n\t\t\tfsid = op->upcall.req.io.refn.fs_id;\n\t\t\tbreak;\n\t\tcase ORANGEFS_VFS_OP_LOOKUP:\n\t\t\tfsid = op->upcall.req.lookup.parent_refn.fs_id;\n\t\t\tbreak;\n\t\tcase ORANGEFS_VFS_OP_CREATE:\n\t\t\tfsid = op->upcall.req.create.parent_refn.fs_id;\n\t\t\tbreak;\n\t\tcase ORANGEFS_VFS_OP_GETATTR:\n\t\t\tfsid = op->upcall.req.getattr.refn.fs_id;\n\t\t\tbreak;\n\t\tcase ORANGEFS_VFS_OP_REMOVE:\n\t\t\tfsid = op->upcall.req.remove.parent_refn.fs_id;\n\t\t\tbreak;\n\t\tcase ORANGEFS_VFS_OP_MKDIR:\n\t\t\tfsid = op->upcall.req.mkdir.parent_refn.fs_id;\n\t\t\tbreak;\n\t\tcase ORANGEFS_VFS_OP_READDIR:\n\t\t\tfsid = op->upcall.req.readdir.refn.fs_id;\n\t\t\tbreak;\n\t\tcase ORANGEFS_VFS_OP_SETATTR:\n\t\t\tfsid = op->upcall.req.setattr.refn.fs_id;\n\t\t\tbreak;\n\t\tcase ORANGEFS_VFS_OP_SYMLINK:\n\t\t\tfsid = op->upcall.req.sym.parent_refn.fs_id;\n\t\t\tbreak;\n\t\tcase ORANGEFS_VFS_OP_RENAME:\n\t\t\tfsid = op->upcall.req.rename.old_parent_refn.fs_id;\n\t\t\tbreak;\n\t\tcase ORANGEFS_VFS_OP_STATFS:\n\t\t\tfsid = op->upcall.req.statfs.fs_id;\n\t\t\tbreak;\n\t\tcase ORANGEFS_VFS_OP_TRUNCATE:\n\t\t\tfsid = op->upcall.req.truncate.refn.fs_id;\n\t\t\tbreak;\n\t\tcase ORANGEFS_VFS_OP_RA_FLUSH:\n\t\t\tfsid = op->upcall.req.ra_cache_flush.refn.fs_id;\n\t\t\tbreak;\n\t\tcase ORANGEFS_VFS_OP_FS_UMOUNT:\n\t\t\tfsid = op->upcall.req.fs_umount.fs_id;\n\t\t\tbreak;\n\t\tcase ORANGEFS_VFS_OP_GETXATTR:\n\t\t\tfsid = op->upcall.req.getxattr.refn.fs_id;\n\t\t\tbreak;\n\t\tcase ORANGEFS_VFS_OP_SETXATTR:\n\t\t\tfsid = op->upcall.req.setxattr.refn.fs_id;\n\t\t\tbreak;\n\t\tcase ORANGEFS_VFS_OP_LISTXATTR:\n\t\t\tfsid = op->upcall.req.listxattr.refn.fs_id;\n\t\t\tbreak;\n\t\tcase ORANGEFS_VFS_OP_REMOVEXATTR:\n\t\t\tfsid = op->upcall.req.removexattr.refn.fs_id;\n\t\t\tbreak;\n\t\tcase ORANGEFS_VFS_OP_FSYNC:\n\t\t\tfsid = op->upcall.req.fsync.refn.fs_id;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn fsid;\n}\n\nstatic int orangefs_inode_flags(struct ORANGEFS_sys_attr_s *attrs)\n{\n\tint flags = 0;\n\tif (attrs->flags & ORANGEFS_IMMUTABLE_FL)\n\t\tflags |= S_IMMUTABLE;\n\telse\n\t\tflags &= ~S_IMMUTABLE;\n\tif (attrs->flags & ORANGEFS_APPEND_FL)\n\t\tflags |= S_APPEND;\n\telse\n\t\tflags &= ~S_APPEND;\n\tif (attrs->flags & ORANGEFS_NOATIME_FL)\n\t\tflags |= S_NOATIME;\n\telse\n\t\tflags &= ~S_NOATIME;\n\treturn flags;\n}\n\nstatic int orangefs_inode_perms(struct ORANGEFS_sys_attr_s *attrs)\n{\n\tint perm_mode = 0;\n\n\tif (attrs->perms & ORANGEFS_O_EXECUTE)\n\t\tperm_mode |= S_IXOTH;\n\tif (attrs->perms & ORANGEFS_O_WRITE)\n\t\tperm_mode |= S_IWOTH;\n\tif (attrs->perms & ORANGEFS_O_READ)\n\t\tperm_mode |= S_IROTH;\n\n\tif (attrs->perms & ORANGEFS_G_EXECUTE)\n\t\tperm_mode |= S_IXGRP;\n\tif (attrs->perms & ORANGEFS_G_WRITE)\n\t\tperm_mode |= S_IWGRP;\n\tif (attrs->perms & ORANGEFS_G_READ)\n\t\tperm_mode |= S_IRGRP;\n\n\tif (attrs->perms & ORANGEFS_U_EXECUTE)\n\t\tperm_mode |= S_IXUSR;\n\tif (attrs->perms & ORANGEFS_U_WRITE)\n\t\tperm_mode |= S_IWUSR;\n\tif (attrs->perms & ORANGEFS_U_READ)\n\t\tperm_mode |= S_IRUSR;\n\n\tif (attrs->perms & ORANGEFS_G_SGID)\n\t\tperm_mode |= S_ISGID;\n\tif (attrs->perms & ORANGEFS_U_SUID)\n\t\tperm_mode |= S_ISUID;\n\n\treturn perm_mode;\n}\n\n \nstatic inline void copy_attributes_from_inode(struct inode *inode,\n    struct ORANGEFS_sys_attr_s *attrs)\n{\n\tstruct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);\n\tattrs->mask = 0;\n\tif (orangefs_inode->attr_valid & ATTR_UID) {\n\t\tattrs->owner = from_kuid(&init_user_ns, inode->i_uid);\n\t\tattrs->mask |= ORANGEFS_ATTR_SYS_UID;\n\t\tgossip_debug(GOSSIP_UTILS_DEBUG, \"(UID) %d\\n\", attrs->owner);\n\t}\n\tif (orangefs_inode->attr_valid & ATTR_GID) {\n\t\tattrs->group = from_kgid(&init_user_ns, inode->i_gid);\n\t\tattrs->mask |= ORANGEFS_ATTR_SYS_GID;\n\t\tgossip_debug(GOSSIP_UTILS_DEBUG, \"(GID) %d\\n\", attrs->group);\n\t}\n\n\tif (orangefs_inode->attr_valid & ATTR_ATIME) {\n\t\tattrs->mask |= ORANGEFS_ATTR_SYS_ATIME;\n\t\tif (orangefs_inode->attr_valid & ATTR_ATIME_SET) {\n\t\t\tattrs->atime = (time64_t)inode->i_atime.tv_sec;\n\t\t\tattrs->mask |= ORANGEFS_ATTR_SYS_ATIME_SET;\n\t\t}\n\t}\n\tif (orangefs_inode->attr_valid & ATTR_MTIME) {\n\t\tattrs->mask |= ORANGEFS_ATTR_SYS_MTIME;\n\t\tif (orangefs_inode->attr_valid & ATTR_MTIME_SET) {\n\t\t\tattrs->mtime = (time64_t)inode->i_mtime.tv_sec;\n\t\t\tattrs->mask |= ORANGEFS_ATTR_SYS_MTIME_SET;\n\t\t}\n\t}\n\tif (orangefs_inode->attr_valid & ATTR_CTIME)\n\t\tattrs->mask |= ORANGEFS_ATTR_SYS_CTIME;\n\n\t \n\n\tif (orangefs_inode->attr_valid & ATTR_MODE) {\n\t\tattrs->perms = ORANGEFS_util_translate_mode(inode->i_mode);\n\t\tattrs->mask |= ORANGEFS_ATTR_SYS_PERM;\n\t}\n}\n\nstatic int orangefs_inode_type(enum orangefs_ds_type objtype)\n{\n\tif (objtype == ORANGEFS_TYPE_METAFILE)\n\t\treturn S_IFREG;\n\telse if (objtype == ORANGEFS_TYPE_DIRECTORY)\n\t\treturn S_IFDIR;\n\telse if (objtype == ORANGEFS_TYPE_SYMLINK)\n\t\treturn S_IFLNK;\n\telse\n\t\treturn -1;\n}\n\nstatic void orangefs_make_bad_inode(struct inode *inode)\n{\n\tif (is_root_handle(inode)) {\n\t\t \n\t\tgossip_debug(GOSSIP_UTILS_DEBUG,\n\t\t\t     \"*** NOT making bad root inode %pU\\n\",\n\t\t\t     get_khandle_from_ino(inode));\n\t} else {\n\t\tgossip_debug(GOSSIP_UTILS_DEBUG,\n\t\t\t     \"*** making bad inode %pU\\n\",\n\t\t\t     get_khandle_from_ino(inode));\n\t\tmake_bad_inode(inode);\n\t}\n}\n\nstatic int orangefs_inode_is_stale(struct inode *inode,\n    struct ORANGEFS_sys_attr_s *attrs, char *link_target)\n{\n\tstruct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);\n\tint type = orangefs_inode_type(attrs->objtype);\n\t \n\tif (type == -1 || inode_wrong_type(inode, type)) {\n\t\torangefs_make_bad_inode(inode);\n\t\treturn 1;\n\t}\n\tif (type == S_IFLNK && strncmp(orangefs_inode->link_target,\n\t    link_target, ORANGEFS_NAME_MAX)) {\n\t\torangefs_make_bad_inode(inode);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint orangefs_inode_getattr(struct inode *inode, int flags)\n{\n\tstruct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);\n\tstruct orangefs_kernel_op_s *new_op;\n\tloff_t inode_size;\n\tint ret, type;\n\n\tgossip_debug(GOSSIP_UTILS_DEBUG, \"%s: called on inode %pU flags %d\\n\",\n\t    __func__, get_khandle_from_ino(inode), flags);\n\nagain:\n\tspin_lock(&inode->i_lock);\n\t \n\tif ((!flags && time_before(jiffies, orangefs_inode->getattr_time)) ||\n\t    orangefs_inode->attr_valid || inode->i_state & I_DIRTY_PAGES) {\n\t\tif (orangefs_inode->attr_valid) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\twrite_inode_now(inode, 1);\n\t\t\tgoto again;\n\t\t}\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn 0;\n\t}\n\tspin_unlock(&inode->i_lock);\n\n\tnew_op = op_alloc(ORANGEFS_VFS_OP_GETATTR);\n\tif (!new_op)\n\t\treturn -ENOMEM;\n\tnew_op->upcall.req.getattr.refn = orangefs_inode->refn;\n\t \n\tif (flags)\n\t\tnew_op->upcall.req.getattr.mask = ORANGEFS_ATTR_SYS_ALL_NOHINT;\n\telse\n\t\tnew_op->upcall.req.getattr.mask =\n\t\t    ORANGEFS_ATTR_SYS_ALL_NOHINT & ~ORANGEFS_ATTR_SYS_SIZE;\n\n\tret = service_operation(new_op, __func__,\n\t    get_interruptible_flag(inode));\n\tif (ret != 0)\n\t\tgoto out;\n\nagain2:\n\tspin_lock(&inode->i_lock);\n\t \n\tif ((!flags && time_before(jiffies, orangefs_inode->getattr_time)) ||\n\t    orangefs_inode->attr_valid || inode->i_state & I_DIRTY_PAGES) {\n\t\tif (orangefs_inode->attr_valid) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\twrite_inode_now(inode, 1);\n\t\t\tgoto again2;\n\t\t}\n\t\tif (inode->i_state & I_DIRTY_PAGES) {\n\t\t\tret = 0;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tgossip_debug(GOSSIP_UTILS_DEBUG, \"%s: in cache or dirty\\n\",\n\t\t    __func__);\n\t\tret = 0;\n\t\tgoto out_unlock;\n\t}\n\n\tif (!(flags & ORANGEFS_GETATTR_NEW)) {\n\t\tret = orangefs_inode_is_stale(inode,\n\t\t    &new_op->downcall.resp.getattr.attributes,\n\t\t    new_op->downcall.resp.getattr.link_target);\n\t\tif (ret) {\n\t\t\tret = -ESTALE;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\ttype = orangefs_inode_type(new_op->\n\t    downcall.resp.getattr.attributes.objtype);\n\tswitch (type) {\n\tcase S_IFREG:\n\t\tinode->i_flags = orangefs_inode_flags(&new_op->\n\t\t    downcall.resp.getattr.attributes);\n\t\tif (flags) {\n\t\t\tinode_size = (loff_t)new_op->\n\t\t\t    downcall.resp.getattr.attributes.size;\n\t\t\tinode->i_size = inode_size;\n\t\t\tinode->i_blkbits = ffs(new_op->downcall.resp.getattr.\n\t\t\t    attributes.blksize);\n\t\t\tinode->i_bytes = inode_size;\n\t\t\tinode->i_blocks =\n\t\t\t    (inode_size + 512 - inode_size % 512)/512;\n\t\t}\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tif (flags) {\n\t\t\tinode->i_size = PAGE_SIZE;\n\t\t\tinode_set_bytes(inode, inode->i_size);\n\t\t}\n\t\tset_nlink(inode, 1);\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tif (flags & ORANGEFS_GETATTR_NEW) {\n\t\t\tinode->i_size = (loff_t)strlen(new_op->\n\t\t\t    downcall.resp.getattr.link_target);\n\t\t\tret = strscpy(orangefs_inode->link_target,\n\t\t\t    new_op->downcall.resp.getattr.link_target,\n\t\t\t    ORANGEFS_NAME_MAX);\n\t\t\tif (ret == -E2BIG) {\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tinode->i_link = orangefs_inode->link_target;\n\t\t}\n\t\tbreak;\n\t \n\tdefault:\n\t\t \n\t\torangefs_make_bad_inode(inode);\n\t\tret = -ESTALE;\n\t\tgoto out_unlock;\n\t}\n\n\tinode->i_uid = make_kuid(&init_user_ns, new_op->\n\t    downcall.resp.getattr.attributes.owner);\n\tinode->i_gid = make_kgid(&init_user_ns, new_op->\n\t    downcall.resp.getattr.attributes.group);\n\tinode->i_atime.tv_sec = (time64_t)new_op->\n\t    downcall.resp.getattr.attributes.atime;\n\tinode->i_mtime.tv_sec = (time64_t)new_op->\n\t    downcall.resp.getattr.attributes.mtime;\n\tinode_set_ctime(inode,\n\t\t\t(time64_t)new_op->downcall.resp.getattr.attributes.ctime,\n\t\t\t0);\n\tinode->i_atime.tv_nsec = 0;\n\tinode->i_mtime.tv_nsec = 0;\n\n\t \n\tinode->i_mode = type | (is_root_handle(inode) ? S_ISVTX : 0) |\n\t    orangefs_inode_perms(&new_op->downcall.resp.getattr.attributes);\n\n\torangefs_inode->getattr_time = jiffies +\n\t    orangefs_getattr_timeout_msecs*HZ/1000;\n\tret = 0;\nout_unlock:\n\tspin_unlock(&inode->i_lock);\nout:\n\top_release(new_op);\n\treturn ret;\n}\n\nint orangefs_inode_check_changed(struct inode *inode)\n{\n\tstruct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);\n\tstruct orangefs_kernel_op_s *new_op;\n\tint ret;\n\n\tgossip_debug(GOSSIP_UTILS_DEBUG, \"%s: called on inode %pU\\n\", __func__,\n\t    get_khandle_from_ino(inode));\n\n\tnew_op = op_alloc(ORANGEFS_VFS_OP_GETATTR);\n\tif (!new_op)\n\t\treturn -ENOMEM;\n\tnew_op->upcall.req.getattr.refn = orangefs_inode->refn;\n\tnew_op->upcall.req.getattr.mask = ORANGEFS_ATTR_SYS_TYPE |\n\t    ORANGEFS_ATTR_SYS_LNK_TARGET;\n\n\tret = service_operation(new_op, __func__,\n\t    get_interruptible_flag(inode));\n\tif (ret != 0)\n\t\tgoto out;\n\n\tret = orangefs_inode_is_stale(inode,\n\t    &new_op->downcall.resp.getattr.attributes,\n\t    new_op->downcall.resp.getattr.link_target);\nout:\n\top_release(new_op);\n\treturn ret;\n}\n\n \nint orangefs_inode_setattr(struct inode *inode)\n{\n\tstruct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);\n\tstruct orangefs_kernel_op_s *new_op;\n\tint ret;\n\n\tnew_op = op_alloc(ORANGEFS_VFS_OP_SETATTR);\n\tif (!new_op)\n\t\treturn -ENOMEM;\n\n\tspin_lock(&inode->i_lock);\n\tnew_op->upcall.uid = from_kuid(&init_user_ns, orangefs_inode->attr_uid);\n\tnew_op->upcall.gid = from_kgid(&init_user_ns, orangefs_inode->attr_gid);\n\tnew_op->upcall.req.setattr.refn = orangefs_inode->refn;\n\tcopy_attributes_from_inode(inode,\n\t    &new_op->upcall.req.setattr.attributes);\n\torangefs_inode->attr_valid = 0;\n\tif (!new_op->upcall.req.setattr.attributes.mask) {\n\t\tspin_unlock(&inode->i_lock);\n\t\top_release(new_op);\n\t\treturn 0;\n\t}\n\tspin_unlock(&inode->i_lock);\n\n\tret = service_operation(new_op, __func__,\n\t    get_interruptible_flag(inode) | ORANGEFS_OP_WRITEBACK);\n\tgossip_debug(GOSSIP_UTILS_DEBUG,\n\t    \"orangefs_inode_setattr: returning %d\\n\", ret);\n\tif (ret)\n\t\torangefs_make_bad_inode(inode);\n\n\top_release(new_op);\n\n\tif (ret == 0)\n\t\torangefs_inode->getattr_time = jiffies - 1;\n\treturn ret;\n}\n\n \n\n \nstatic int PINT_errno_mapping[] = {\n\t0, EPERM, ENOENT, EINTR, EIO, ENXIO, EBADF, EAGAIN, ENOMEM,\n\tEFAULT, EBUSY, EEXIST, ENODEV, ENOTDIR, EISDIR, EINVAL, EMFILE,\n\tEFBIG, ENOSPC, EROFS, EMLINK, EPIPE, EDEADLK, ENAMETOOLONG,\n\tENOLCK, ENOSYS, ENOTEMPTY, ELOOP, EWOULDBLOCK, ENOMSG, EUNATCH,\n\tEBADR, EDEADLOCK, ENODATA, ETIME, ENONET, EREMOTE, ECOMM,\n\tEPROTO, EBADMSG, EOVERFLOW, ERESTART, EMSGSIZE, EPROTOTYPE,\n\tENOPROTOOPT, EPROTONOSUPPORT, EOPNOTSUPP, EADDRINUSE,\n\tEADDRNOTAVAIL, ENETDOWN, ENETUNREACH, ENETRESET, ENOBUFS,\n\tETIMEDOUT, ECONNREFUSED, EHOSTDOWN, EHOSTUNREACH, EALREADY,\n\tEACCES, ECONNRESET, ERANGE\n};\n\nint orangefs_normalize_to_errno(__s32 error_code)\n{\n\t__u32 i;\n\n\t \n\tif (error_code == 0) {\n\t\treturn 0;\n\t \n\t} else if (error_code > 0) {\n\t\tgossip_err(\"orangefs: error status received.\\n\");\n\t\tgossip_err(\"orangefs: assuming error code is inverted.\\n\");\n\t\terror_code = -error_code;\n\t}\n\n\t \n\n\t \n\tif ((-error_code) & ORANGEFS_NON_ERRNO_ERROR_BIT) {\n\t\tif (((-error_code) &\n\t\t    (ORANGEFS_ERROR_NUMBER_BITS|ORANGEFS_NON_ERRNO_ERROR_BIT|\n\t\t    ORANGEFS_ERROR_BIT)) == ORANGEFS_ECANCEL) {\n\t\t\t \n\t\t\terror_code = -ETIMEDOUT;\n\t\t} else {\n\t\t\t \n\t\t\tgossip_err(\"%s: bad error code :%d:.\\n\",\n\t\t\t\t__func__,\n\t\t\t\terror_code);\n\t\t\terror_code = -EINVAL;\n\t\t}\n\n\t \n\t} else if ((-error_code) & ORANGEFS_ERROR_BIT) {\n\t\ti = (-error_code) & ~(ORANGEFS_ERROR_BIT|ORANGEFS_ERROR_CLASS_BITS);\n\t\tif (i < ARRAY_SIZE(PINT_errno_mapping))\n\t\t\terror_code = -PINT_errno_mapping[i];\n\t\telse\n\t\t\terror_code = -EINVAL;\n\n\t \n\t} else {\n\t\tgossip_err(\"%s: unknown error code.\\n\", __func__);\n\t\terror_code = -EINVAL;\n\t}\n\treturn error_code;\n}\n\n#define NUM_MODES 11\n__s32 ORANGEFS_util_translate_mode(int mode)\n{\n\tint ret = 0;\n\tint i = 0;\n\tstatic int modes[NUM_MODES] = {\n\t\tS_IXOTH, S_IWOTH, S_IROTH,\n\t\tS_IXGRP, S_IWGRP, S_IRGRP,\n\t\tS_IXUSR, S_IWUSR, S_IRUSR,\n\t\tS_ISGID, S_ISUID\n\t};\n\tstatic int orangefs_modes[NUM_MODES] = {\n\t\tORANGEFS_O_EXECUTE, ORANGEFS_O_WRITE, ORANGEFS_O_READ,\n\t\tORANGEFS_G_EXECUTE, ORANGEFS_G_WRITE, ORANGEFS_G_READ,\n\t\tORANGEFS_U_EXECUTE, ORANGEFS_U_WRITE, ORANGEFS_U_READ,\n\t\tORANGEFS_G_SGID, ORANGEFS_U_SUID\n\t};\n\n\tfor (i = 0; i < NUM_MODES; i++)\n\t\tif (mode & modes[i])\n\t\t\tret |= orangefs_modes[i];\n\n\treturn ret;\n}\n#undef NUM_MODES\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}