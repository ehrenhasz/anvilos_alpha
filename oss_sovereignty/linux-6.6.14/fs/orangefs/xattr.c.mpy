{
  "module_name": "xattr.c",
  "hash_id": "6d8063013217cc1af2b2168adaebd59dd20f7a7668af5dd21a23eecd78efb406",
  "original_prompt": "Ingested from linux-6.6.14/fs/orangefs/xattr.c",
  "human_readable_source": "\n \n\n \n\n#include \"protocol.h\"\n#include \"orangefs-kernel.h\"\n#include \"orangefs-bufmap.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/hashtable.h>\n\n#define SYSTEM_ORANGEFS_KEY \"system.pvfs2.\"\n#define SYSTEM_ORANGEFS_KEY_LEN 13\n\n \nstatic int is_reserved_key(const char *key, size_t size)\n{\n\n\tif (size < SYSTEM_ORANGEFS_KEY_LEN)\n\t\treturn 1;\n\n\treturn strncmp(key, SYSTEM_ORANGEFS_KEY, SYSTEM_ORANGEFS_KEY_LEN) ?  1 : 0;\n}\n\nstatic inline int convert_to_internal_xattr_flags(int setxattr_flags)\n{\n\tint internal_flag = 0;\n\n\tif (setxattr_flags & XATTR_REPLACE) {\n\t\t \n\t\tinternal_flag = ORANGEFS_XATTR_REPLACE;\n\t} else if (setxattr_flags & XATTR_CREATE) {\n\t\t \n\t\tinternal_flag = ORANGEFS_XATTR_CREATE;\n\t}\n\treturn internal_flag;\n}\n\nstatic unsigned int xattr_key(const char *key)\n{\n\tunsigned int i = 0;\n\twhile (key)\n\t\ti += *key++;\n\treturn i % 16;\n}\n\nstatic struct orangefs_cached_xattr *find_cached_xattr(struct inode *inode,\n    const char *key)\n{\n\tstruct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);\n\tstruct orangefs_cached_xattr *cx;\n\tstruct hlist_head *h;\n\tstruct hlist_node *tmp;\n\th = &orangefs_inode->xattr_cache[xattr_key(key)];\n\tif (hlist_empty(h))\n\t\treturn NULL;\n\thlist_for_each_entry_safe(cx, tmp, h, node) {\n \n\t\tif (!strcmp(cx->key, key))\n\t\t\treturn cx;\n\t}\n\treturn NULL;\n}\n\n \nssize_t orangefs_inode_getxattr(struct inode *inode, const char *name,\n\t\t\t\tvoid *buffer, size_t size)\n{\n\tstruct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);\n\tstruct orangefs_kernel_op_s *new_op = NULL;\n\tstruct orangefs_cached_xattr *cx;\n\tssize_t ret = -ENOMEM;\n\tssize_t length = 0;\n\tint fsuid;\n\tint fsgid;\n\n\tgossip_debug(GOSSIP_XATTR_DEBUG,\n\t\t     \"%s: name %s, buffer_size %zd\\n\",\n\t\t     __func__, name, size);\n\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\n\tif (strlen(name) >= ORANGEFS_MAX_XATTR_NAMELEN)\n\t\treturn -EINVAL;\n\n\tfsuid = from_kuid(&init_user_ns, current_fsuid());\n\tfsgid = from_kgid(&init_user_ns, current_fsgid());\n\n\tgossip_debug(GOSSIP_XATTR_DEBUG,\n\t\t     \"getxattr on inode %pU, name %s \"\n\t\t     \"(uid %o, gid %o)\\n\",\n\t\t     get_khandle_from_ino(inode),\n\t\t     name,\n\t\t     fsuid,\n\t\t     fsgid);\n\n\tdown_read(&orangefs_inode->xattr_sem);\n\n\tcx = find_cached_xattr(inode, name);\n\tif (cx && time_before(jiffies, cx->timeout)) {\n\t\tif (cx->length == -1) {\n\t\t\tret = -ENODATA;\n\t\t\tgoto out_unlock;\n\t\t} else {\n\t\t\tif (size == 0) {\n\t\t\t\tret = cx->length;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tif (cx->length > size) {\n\t\t\t\tret = -ERANGE;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tmemcpy(buffer, cx->val, cx->length);\n\t\t\tmemset(buffer + cx->length, 0, size - cx->length);\n\t\t\tret = cx->length;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tnew_op = op_alloc(ORANGEFS_VFS_OP_GETXATTR);\n\tif (!new_op)\n\t\tgoto out_unlock;\n\n\tnew_op->upcall.req.getxattr.refn = orangefs_inode->refn;\n\tstrcpy(new_op->upcall.req.getxattr.key, name);\n\n\t \n\tnew_op->upcall.req.getxattr.key_sz = strlen(name) + 1;\n\n\tret = service_operation(new_op, \"orangefs_inode_getxattr\",\n\t\t\t\tget_interruptible_flag(inode));\n\tif (ret != 0) {\n\t\tif (ret == -ENOENT) {\n\t\t\tret = -ENODATA;\n\t\t\tgossip_debug(GOSSIP_XATTR_DEBUG,\n\t\t\t\t     \"orangefs_inode_getxattr: inode %pU key %s\"\n\t\t\t\t     \" does not exist!\\n\",\n\t\t\t\t     get_khandle_from_ino(inode),\n\t\t\t\t     (char *)new_op->upcall.req.getxattr.key);\n\t\t\tcx = kmalloc(sizeof *cx, GFP_KERNEL);\n\t\t\tif (cx) {\n\t\t\t\tstrcpy(cx->key, name);\n\t\t\t\tcx->length = -1;\n\t\t\t\tcx->timeout = jiffies +\n\t\t\t\t    orangefs_getattr_timeout_msecs*HZ/1000;\n\t\t\t\thash_add(orangefs_inode->xattr_cache, &cx->node,\n\t\t\t\t    xattr_key(cx->key));\n\t\t\t}\n\t\t}\n\t\tgoto out_release_op;\n\t}\n\n\t \n\tlength = new_op->downcall.resp.getxattr.val_sz;\n\n\t \n\tif (size == 0) {\n\t\tret = length;\n\t\tgoto out_release_op;\n\t}\n\n\t \n\tif (length > size) {\n\t\tret = -ERANGE;\n\t\tgoto out_release_op;\n\t}\n\n\tmemcpy(buffer, new_op->downcall.resp.getxattr.val, length);\n\tmemset(buffer + length, 0, size - length);\n\tgossip_debug(GOSSIP_XATTR_DEBUG,\n\t     \"orangefs_inode_getxattr: inode %pU \"\n\t     \"key %s key_sz %d, val_len %d\\n\",\n\t     get_khandle_from_ino(inode),\n\t     (char *)new_op->\n\t\tupcall.req.getxattr.key,\n\t\t     (int)new_op->\n\t\tupcall.req.getxattr.key_sz,\n\t     (int)ret);\n\n\tret = length;\n\n\tif (cx) {\n\t\tstrcpy(cx->key, name);\n\t\tmemcpy(cx->val, buffer, length);\n\t\tcx->length = length;\n\t\tcx->timeout = jiffies + HZ;\n\t} else {\n\t\tcx = kmalloc(sizeof *cx, GFP_KERNEL);\n\t\tif (cx) {\n\t\t\tstrcpy(cx->key, name);\n\t\t\tmemcpy(cx->val, buffer, length);\n\t\t\tcx->length = length;\n\t\t\tcx->timeout = jiffies + HZ;\n\t\t\thash_add(orangefs_inode->xattr_cache, &cx->node,\n\t\t\t    xattr_key(cx->key));\n\t\t}\n\t}\n\nout_release_op:\n\top_release(new_op);\nout_unlock:\n\tup_read(&orangefs_inode->xattr_sem);\n\treturn ret;\n}\n\nstatic int orangefs_inode_removexattr(struct inode *inode, const char *name,\n\t\t\t\t      int flags)\n{\n\tstruct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);\n\tstruct orangefs_kernel_op_s *new_op = NULL;\n\tstruct orangefs_cached_xattr *cx;\n\tstruct hlist_head *h;\n\tstruct hlist_node *tmp;\n\tint ret = -ENOMEM;\n\n\tif (strlen(name) >= ORANGEFS_MAX_XATTR_NAMELEN)\n\t\treturn -EINVAL;\n\n\tdown_write(&orangefs_inode->xattr_sem);\n\tnew_op = op_alloc(ORANGEFS_VFS_OP_REMOVEXATTR);\n\tif (!new_op)\n\t\tgoto out_unlock;\n\n\tnew_op->upcall.req.removexattr.refn = orangefs_inode->refn;\n\t \n\tstrcpy(new_op->upcall.req.removexattr.key, name);\n\tnew_op->upcall.req.removexattr.key_sz = strlen(name) + 1;\n\n\tgossip_debug(GOSSIP_XATTR_DEBUG,\n\t\t     \"orangefs_inode_removexattr: key %s, key_sz %d\\n\",\n\t\t     (char *)new_op->upcall.req.removexattr.key,\n\t\t     (int)new_op->upcall.req.removexattr.key_sz);\n\n\tret = service_operation(new_op,\n\t\t\t\t\"orangefs_inode_removexattr\",\n\t\t\t\tget_interruptible_flag(inode));\n\tif (ret == -ENOENT) {\n\t\t \n\t\tif (flags & XATTR_REPLACE)\n\t\t\tret = -ENODATA;\n\t\telse\n\t\t\tret = 0;\n\t}\n\n\tgossip_debug(GOSSIP_XATTR_DEBUG,\n\t\t     \"orangefs_inode_removexattr: returning %d\\n\", ret);\n\n\top_release(new_op);\n\n\th = &orangefs_inode->xattr_cache[xattr_key(name)];\n\thlist_for_each_entry_safe(cx, tmp, h, node) {\n\t\tif (!strcmp(cx->key, name)) {\n\t\t\thlist_del(&cx->node);\n\t\t\tkfree(cx);\n\t\t\tbreak;\n\t\t}\n\t}\n\nout_unlock:\n\tup_write(&orangefs_inode->xattr_sem);\n\treturn ret;\n}\n\n \nint orangefs_inode_setxattr(struct inode *inode, const char *name,\n\t\t\t    const void *value, size_t size, int flags)\n{\n\tstruct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);\n\tstruct orangefs_kernel_op_s *new_op;\n\tint internal_flag = 0;\n\tstruct orangefs_cached_xattr *cx;\n\tstruct hlist_head *h;\n\tstruct hlist_node *tmp;\n\tint ret = -ENOMEM;\n\n\tgossip_debug(GOSSIP_XATTR_DEBUG,\n\t\t     \"%s: name %s, buffer_size %zd\\n\",\n\t\t     __func__, name, size);\n\n\tif (size > ORANGEFS_MAX_XATTR_VALUELEN)\n\t\treturn -EINVAL;\n\tif (strlen(name) >= ORANGEFS_MAX_XATTR_NAMELEN)\n\t\treturn -EINVAL;\n\n\tinternal_flag = convert_to_internal_xattr_flags(flags);\n\n\t \n\tif (size == 0 && !value) {\n\t\tgossip_debug(GOSSIP_XATTR_DEBUG,\n\t\t\t     \"removing xattr (%s)\\n\",\n\t\t\t     name);\n\t\treturn orangefs_inode_removexattr(inode, name, flags);\n\t}\n\n\tgossip_debug(GOSSIP_XATTR_DEBUG,\n\t\t     \"setxattr on inode %pU, name %s\\n\",\n\t\t     get_khandle_from_ino(inode),\n\t\t     name);\n\n\tdown_write(&orangefs_inode->xattr_sem);\n\tnew_op = op_alloc(ORANGEFS_VFS_OP_SETXATTR);\n\tif (!new_op)\n\t\tgoto out_unlock;\n\n\n\tnew_op->upcall.req.setxattr.refn = orangefs_inode->refn;\n\tnew_op->upcall.req.setxattr.flags = internal_flag;\n\t \n\tstrcpy(new_op->upcall.req.setxattr.keyval.key, name);\n\tnew_op->upcall.req.setxattr.keyval.key_sz = strlen(name) + 1;\n\tmemcpy(new_op->upcall.req.setxattr.keyval.val, value, size);\n\tnew_op->upcall.req.setxattr.keyval.val_sz = size;\n\n\tgossip_debug(GOSSIP_XATTR_DEBUG,\n\t\t     \"orangefs_inode_setxattr: key %s, key_sz %d \"\n\t\t     \" value size %zd\\n\",\n\t\t     (char *)new_op->upcall.req.setxattr.keyval.key,\n\t\t     (int)new_op->upcall.req.setxattr.keyval.key_sz,\n\t\t     size);\n\n\tret = service_operation(new_op,\n\t\t\t\t\"orangefs_inode_setxattr\",\n\t\t\t\tget_interruptible_flag(inode));\n\n\tgossip_debug(GOSSIP_XATTR_DEBUG,\n\t\t     \"orangefs_inode_setxattr: returning %d\\n\",\n\t\t     ret);\n\n\t \n\top_release(new_op);\n\n\th = &orangefs_inode->xattr_cache[xattr_key(name)];\n\thlist_for_each_entry_safe(cx, tmp, h, node) {\n\t\tif (!strcmp(cx->key, name)) {\n\t\t\thlist_del(&cx->node);\n\t\t\tkfree(cx);\n\t\t\tbreak;\n\t\t}\n\t}\n\nout_unlock:\n\tup_write(&orangefs_inode->xattr_sem);\n\treturn ret;\n}\n\n \nssize_t orangefs_listxattr(struct dentry *dentry, char *buffer, size_t size)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);\n\tstruct orangefs_kernel_op_s *new_op;\n\t__u64 token = ORANGEFS_ITERATE_START;\n\tssize_t ret = -ENOMEM;\n\tssize_t total = 0;\n\tint count_keys = 0;\n\tint key_size;\n\tint i = 0;\n\tint returned_count = 0;\n\n\tif (size > 0 && !buffer) {\n\t\tgossip_err(\"%s: bogus NULL pointers\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tdown_read(&orangefs_inode->xattr_sem);\n\tnew_op = op_alloc(ORANGEFS_VFS_OP_LISTXATTR);\n\tif (!new_op)\n\t\tgoto out_unlock;\n\n\tif (buffer && size > 0)\n\t\tmemset(buffer, 0, size);\n\ntry_again:\n\tkey_size = 0;\n\tnew_op->upcall.req.listxattr.refn = orangefs_inode->refn;\n\tnew_op->upcall.req.listxattr.token = token;\n\tnew_op->upcall.req.listxattr.requested_count =\n\t    (size == 0) ? 0 : ORANGEFS_MAX_XATTR_LISTLEN;\n\tret = service_operation(new_op, __func__,\n\t\t\t\tget_interruptible_flag(inode));\n\tif (ret != 0)\n\t\tgoto done;\n\n\tif (size == 0) {\n\t\t \n\t\ttotal = new_op->downcall.resp.listxattr.returned_count *\n\t\t\tORANGEFS_MAX_XATTR_NAMELEN;\n\t\tgoto done;\n\t}\n\n\treturned_count = new_op->downcall.resp.listxattr.returned_count;\n\tif (returned_count < 0 ||\n\t    returned_count > ORANGEFS_MAX_XATTR_LISTLEN) {\n\t\tgossip_err(\"%s: impossible value for returned_count:%d:\\n\",\n\t\t__func__,\n\t\treturned_count);\n\t\tret = -EIO;\n\t\tgoto done;\n\t}\n\n\t \n\tfor (i = 0; i < returned_count; i++) {\n\t\tif (new_op->downcall.resp.listxattr.lengths[i] < 0 ||\n\t\t    new_op->downcall.resp.listxattr.lengths[i] >\n\t\t    ORANGEFS_MAX_XATTR_NAMELEN) {\n\t\t\tgossip_err(\"%s: impossible value for lengths[%d]\\n\",\n\t\t\t    __func__,\n\t\t\t    new_op->downcall.resp.listxattr.lengths[i]);\n\t\t\tret = -EIO;\n\t\t\tgoto done;\n\t\t}\n\t\tif (total + new_op->downcall.resp.listxattr.lengths[i] > size)\n\t\t\tgoto done;\n\n\t\t \n\t\tif (is_reserved_key(new_op->downcall.resp.listxattr.key +\n\t\t\t\t    key_size,\n\t\t\t\t    new_op->downcall.resp.\n\t\t\t\t\tlistxattr.lengths[i])) {\n\t\t\tgossip_debug(GOSSIP_XATTR_DEBUG, \"Copying key %d -> %s\\n\",\n\t\t\t\t\ti, new_op->downcall.resp.listxattr.key +\n\t\t\t\t\t\tkey_size);\n\t\t\tmemcpy(buffer + total,\n\t\t\t\tnew_op->downcall.resp.listxattr.key + key_size,\n\t\t\t\tnew_op->downcall.resp.listxattr.lengths[i]);\n\t\t\ttotal += new_op->downcall.resp.listxattr.lengths[i];\n\t\t\tcount_keys++;\n\t\t} else {\n\t\t\tgossip_debug(GOSSIP_XATTR_DEBUG, \"[RESERVED] key %d -> %s\\n\",\n\t\t\t\t\ti, new_op->downcall.resp.listxattr.key +\n\t\t\t\t\t\tkey_size);\n\t\t}\n\t\tkey_size += new_op->downcall.resp.listxattr.lengths[i];\n\t}\n\n\t \n\ttoken = new_op->downcall.resp.listxattr.token;\n\tif (token != ORANGEFS_ITERATE_END)\n\t\tgoto try_again;\n\ndone:\n\tgossip_debug(GOSSIP_XATTR_DEBUG, \"%s: returning %d\"\n\t\t     \" [size of buffer %ld] (filled in %d keys)\\n\",\n\t\t     __func__,\n\t\t     ret ? (int)ret : (int)total,\n\t\t     (long)size,\n\t\t     count_keys);\n\top_release(new_op);\n\tif (ret == 0)\n\t\tret = total;\nout_unlock:\n\tup_read(&orangefs_inode->xattr_sem);\n\treturn ret;\n}\n\nstatic int orangefs_xattr_set_default(const struct xattr_handler *handler,\n\t\t\t\t      struct mnt_idmap *idmap,\n\t\t\t\t      struct dentry *unused,\n\t\t\t\t      struct inode *inode,\n\t\t\t\t      const char *name,\n\t\t\t\t      const void *buffer,\n\t\t\t\t      size_t size,\n\t\t\t\t      int flags)\n{\n\treturn orangefs_inode_setxattr(inode, name, buffer, size, flags);\n}\n\nstatic int orangefs_xattr_get_default(const struct xattr_handler *handler,\n\t\t\t\t      struct dentry *unused,\n\t\t\t\t      struct inode *inode,\n\t\t\t\t      const char *name,\n\t\t\t\t      void *buffer,\n\t\t\t\t      size_t size)\n{\n\treturn orangefs_inode_getxattr(inode, name, buffer, size);\n\n}\n\nstatic const struct xattr_handler orangefs_xattr_default_handler = {\n\t.prefix = \"\",   \n\t.get = orangefs_xattr_get_default,\n\t.set = orangefs_xattr_set_default,\n};\n\nconst struct xattr_handler *orangefs_xattr_handlers[] = {\n\t&orangefs_xattr_default_handler,\n\tNULL\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}