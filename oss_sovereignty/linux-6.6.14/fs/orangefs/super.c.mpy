{
  "module_name": "super.c",
  "hash_id": "5a2339fc371faf0e691ee4a9a477358ff4f54e61c22af5290c6ab11573a76f31",
  "original_prompt": "Ingested from linux-6.6.14/fs/orangefs/super.c",
  "human_readable_source": "\n \n\n#include \"protocol.h\"\n#include \"orangefs-kernel.h\"\n#include \"orangefs-bufmap.h\"\n\n#include <linux/parser.h>\n#include <linux/hashtable.h>\n#include <linux/seq_file.h>\n\n \nstatic struct kmem_cache *orangefs_inode_cache;\n\n \nLIST_HEAD(orangefs_superblocks);\n\nDEFINE_SPINLOCK(orangefs_superblocks_lock);\n\nenum {\n\tOpt_intr,\n\tOpt_acl,\n\tOpt_local_lock,\n\n\tOpt_err\n};\n\nstatic const match_table_t tokens = {\n\t{ Opt_acl,\t\t\"acl\" },\n\t{ Opt_intr,\t\t\"intr\" },\n\t{ Opt_local_lock,\t\"local_lock\" },\n\t{ Opt_err,\tNULL }\n};\n\nuint64_t orangefs_features;\n\nstatic int orangefs_show_options(struct seq_file *m, struct dentry *root)\n{\n\tstruct orangefs_sb_info_s *orangefs_sb = ORANGEFS_SB(root->d_sb);\n\n\tif (root->d_sb->s_flags & SB_POSIXACL)\n\t\tseq_puts(m, \",acl\");\n\tif (orangefs_sb->flags & ORANGEFS_OPT_INTR)\n\t\tseq_puts(m, \",intr\");\n\tif (orangefs_sb->flags & ORANGEFS_OPT_LOCAL_LOCK)\n\t\tseq_puts(m, \",local_lock\");\n\treturn 0;\n}\n\nstatic int parse_mount_options(struct super_block *sb, char *options,\n\t\tint silent)\n{\n\tstruct orangefs_sb_info_s *orangefs_sb = ORANGEFS_SB(sb);\n\tsubstring_t args[MAX_OPT_ARGS];\n\tchar *p;\n\n\t \n\tsb->s_flags &= ~SB_POSIXACL;\n\torangefs_sb->flags &= ~ORANGEFS_OPT_INTR;\n\torangefs_sb->flags &= ~ORANGEFS_OPT_LOCAL_LOCK;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_acl:\n\t\t\tsb->s_flags |= SB_POSIXACL;\n\t\t\tbreak;\n\t\tcase Opt_intr:\n\t\t\torangefs_sb->flags |= ORANGEFS_OPT_INTR;\n\t\t\tbreak;\n\t\tcase Opt_local_lock:\n\t\t\torangefs_sb->flags |= ORANGEFS_OPT_LOCAL_LOCK;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\treturn 0;\nfail:\n\tif (!silent)\n\t\tgossip_err(\"Error: mount option [%s] is not supported.\\n\", p);\n\treturn -EINVAL;\n}\n\nstatic void orangefs_inode_cache_ctor(void *req)\n{\n\tstruct orangefs_inode_s *orangefs_inode = req;\n\n\tinode_init_once(&orangefs_inode->vfs_inode);\n\tinit_rwsem(&orangefs_inode->xattr_sem);\n}\n\nstatic struct inode *orangefs_alloc_inode(struct super_block *sb)\n{\n\tstruct orangefs_inode_s *orangefs_inode;\n\n\torangefs_inode = alloc_inode_sb(sb, orangefs_inode_cache, GFP_KERNEL);\n\tif (!orangefs_inode)\n\t\treturn NULL;\n\n\t \n\tmemset(&orangefs_inode->refn.khandle, 0, 16);\n\torangefs_inode->refn.fs_id = ORANGEFS_FS_ID_NULL;\n\torangefs_inode->last_failed_block_index_read = 0;\n\tmemset(orangefs_inode->link_target, 0, sizeof(orangefs_inode->link_target));\n\n\tgossip_debug(GOSSIP_SUPER_DEBUG,\n\t\t     \"orangefs_alloc_inode: allocated %p\\n\",\n\t\t     &orangefs_inode->vfs_inode);\n\treturn &orangefs_inode->vfs_inode;\n}\n\nstatic void orangefs_free_inode(struct inode *inode)\n{\n\tstruct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);\n\tstruct orangefs_cached_xattr *cx;\n\tstruct hlist_node *tmp;\n\tint i;\n\n\thash_for_each_safe(orangefs_inode->xattr_cache, i, tmp, cx, node) {\n\t\thlist_del(&cx->node);\n\t\tkfree(cx);\n\t}\n\n\tkmem_cache_free(orangefs_inode_cache, orangefs_inode);\n}\n\nstatic void orangefs_destroy_inode(struct inode *inode)\n{\n\tstruct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);\n\n\tgossip_debug(GOSSIP_SUPER_DEBUG,\n\t\t\t\"%s: deallocated %p destroying inode %pU\\n\",\n\t\t\t__func__, orangefs_inode, get_khandle_from_ino(inode));\n}\n\nstatic int orangefs_write_inode(struct inode *inode,\n\t\t\t\tstruct writeback_control *wbc)\n{\n\tgossip_debug(GOSSIP_SUPER_DEBUG, \"orangefs_write_inode\\n\");\n\treturn orangefs_inode_setattr(inode);\n}\n\n \nstatic int orangefs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tint ret = -ENOMEM;\n\tstruct orangefs_kernel_op_s *new_op = NULL;\n\tint flags = 0;\n\tstruct super_block *sb = NULL;\n\n\tsb = dentry->d_sb;\n\n\tgossip_debug(GOSSIP_SUPER_DEBUG,\n\t\t\t\"%s: called on sb %p (fs_id is %d)\\n\",\n\t\t\t__func__,\n\t\t\tsb,\n\t\t\t(int)(ORANGEFS_SB(sb)->fs_id));\n\n\tnew_op = op_alloc(ORANGEFS_VFS_OP_STATFS);\n\tif (!new_op)\n\t\treturn ret;\n\tnew_op->upcall.req.statfs.fs_id = ORANGEFS_SB(sb)->fs_id;\n\n\tif (ORANGEFS_SB(sb)->flags & ORANGEFS_OPT_INTR)\n\t\tflags = ORANGEFS_OP_INTERRUPTIBLE;\n\n\tret = service_operation(new_op, \"orangefs_statfs\", flags);\n\n\tif (new_op->downcall.status < 0)\n\t\tgoto out_op_release;\n\n\tgossip_debug(GOSSIP_SUPER_DEBUG,\n\t\t     \"%s: got %ld blocks available | \"\n\t\t     \"%ld blocks total | %ld block size | \"\n\t\t     \"%ld files total | %ld files avail\\n\",\n\t\t     __func__,\n\t\t     (long)new_op->downcall.resp.statfs.blocks_avail,\n\t\t     (long)new_op->downcall.resp.statfs.blocks_total,\n\t\t     (long)new_op->downcall.resp.statfs.block_size,\n\t\t     (long)new_op->downcall.resp.statfs.files_total,\n\t\t     (long)new_op->downcall.resp.statfs.files_avail);\n\n\tbuf->f_type = sb->s_magic;\n\tmemcpy(&buf->f_fsid, &ORANGEFS_SB(sb)->fs_id, sizeof(buf->f_fsid));\n\tbuf->f_bsize = new_op->downcall.resp.statfs.block_size;\n\tbuf->f_namelen = ORANGEFS_NAME_MAX;\n\n\tbuf->f_blocks = (sector_t) new_op->downcall.resp.statfs.blocks_total;\n\tbuf->f_bfree = (sector_t) new_op->downcall.resp.statfs.blocks_avail;\n\tbuf->f_bavail = (sector_t) new_op->downcall.resp.statfs.blocks_avail;\n\tbuf->f_files = (sector_t) new_op->downcall.resp.statfs.files_total;\n\tbuf->f_ffree = (sector_t) new_op->downcall.resp.statfs.files_avail;\n\tbuf->f_frsize = 0;\n\nout_op_release:\n\top_release(new_op);\n\tgossip_debug(GOSSIP_SUPER_DEBUG, \"%s: returning %d\\n\", __func__, ret);\n\treturn ret;\n}\n\n \nstatic int orangefs_remount_fs(struct super_block *sb, int *flags, char *data)\n{\n\tgossip_debug(GOSSIP_SUPER_DEBUG, \"orangefs_remount_fs: called\\n\");\n\treturn parse_mount_options(sb, data, 1);\n}\n\n \nint orangefs_remount(struct orangefs_sb_info_s *orangefs_sb)\n{\n\tstruct orangefs_kernel_op_s *new_op;\n\tint ret = -EINVAL;\n\n\tgossip_debug(GOSSIP_SUPER_DEBUG, \"orangefs_remount: called\\n\");\n\n\tnew_op = op_alloc(ORANGEFS_VFS_OP_FS_MOUNT);\n\tif (!new_op)\n\t\treturn -ENOMEM;\n\tstrncpy(new_op->upcall.req.fs_mount.orangefs_config_server,\n\t\torangefs_sb->devname,\n\t\tORANGEFS_MAX_SERVER_ADDR_LEN);\n\n\tgossip_debug(GOSSIP_SUPER_DEBUG,\n\t\t     \"Attempting ORANGEFS Remount via host %s\\n\",\n\t\t     new_op->upcall.req.fs_mount.orangefs_config_server);\n\n\t \n\tret = service_operation(new_op, \"orangefs_remount\",\n\t\tORANGEFS_OP_PRIORITY | ORANGEFS_OP_NO_MUTEX);\n\tgossip_debug(GOSSIP_SUPER_DEBUG,\n\t\t     \"orangefs_remount: mount got return value of %d\\n\",\n\t\t     ret);\n\tif (ret == 0) {\n\t\t \n\t\torangefs_sb->id = new_op->downcall.resp.fs_mount.id;\n\t\torangefs_sb->mount_pending = 0;\n\t}\n\n\top_release(new_op);\n\n\tif (orangefs_userspace_version >= 20906) {\n\t\tnew_op = op_alloc(ORANGEFS_VFS_OP_FEATURES);\n\t\tif (!new_op)\n\t\t\treturn -ENOMEM;\n\t\tnew_op->upcall.req.features.features = 0;\n\t\tret = service_operation(new_op, \"orangefs_features\",\n\t\t    ORANGEFS_OP_PRIORITY | ORANGEFS_OP_NO_MUTEX);\n\t\tif (!ret)\n\t\t\torangefs_features =\n\t\t\t    new_op->downcall.resp.features.features;\n\t\telse\n\t\t\torangefs_features = 0;\n\t\top_release(new_op);\n\t} else {\n\t\torangefs_features = 0;\n\t}\n\n\treturn ret;\n}\n\nint fsid_key_table_initialize(void)\n{\n\treturn 0;\n}\n\nvoid fsid_key_table_finalize(void)\n{\n}\n\nstatic const struct super_operations orangefs_s_ops = {\n\t.alloc_inode = orangefs_alloc_inode,\n\t.free_inode = orangefs_free_inode,\n\t.destroy_inode = orangefs_destroy_inode,\n\t.write_inode = orangefs_write_inode,\n\t.drop_inode = generic_delete_inode,\n\t.statfs = orangefs_statfs,\n\t.remount_fs = orangefs_remount_fs,\n\t.show_options = orangefs_show_options,\n};\n\nstatic struct dentry *orangefs_fh_to_dentry(struct super_block *sb,\n\t\t\t\t  struct fid *fid,\n\t\t\t\t  int fh_len,\n\t\t\t\t  int fh_type)\n{\n\tstruct orangefs_object_kref refn;\n\n\tif (fh_len < 5 || fh_type > 2)\n\t\treturn NULL;\n\n\tORANGEFS_khandle_from(&(refn.khandle), fid->raw, 16);\n\trefn.fs_id = (u32) fid->raw[4];\n\tgossip_debug(GOSSIP_SUPER_DEBUG,\n\t\t     \"fh_to_dentry: handle %pU, fs_id %d\\n\",\n\t\t     &refn.khandle,\n\t\t     refn.fs_id);\n\n\treturn d_obtain_alias(orangefs_iget(sb, &refn));\n}\n\nstatic int orangefs_encode_fh(struct inode *inode,\n\t\t    __u32 *fh,\n\t\t    int *max_len,\n\t\t    struct inode *parent)\n{\n\tint len = parent ? 10 : 5;\n\tint type = 1;\n\tstruct orangefs_object_kref refn;\n\n\tif (*max_len < len) {\n\t\tgossip_err(\"fh buffer is too small for encoding\\n\");\n\t\t*max_len = len;\n\t\ttype = 255;\n\t\tgoto out;\n\t}\n\n\trefn = ORANGEFS_I(inode)->refn;\n\tORANGEFS_khandle_to(&refn.khandle, fh, 16);\n\tfh[4] = refn.fs_id;\n\n\tgossip_debug(GOSSIP_SUPER_DEBUG,\n\t\t     \"Encoding fh: handle %pU, fsid %u\\n\",\n\t\t     &refn.khandle,\n\t\t     refn.fs_id);\n\n\n\tif (parent) {\n\t\trefn = ORANGEFS_I(parent)->refn;\n\t\tORANGEFS_khandle_to(&refn.khandle, (char *) fh + 20, 16);\n\t\tfh[9] = refn.fs_id;\n\n\t\ttype = 2;\n\t\tgossip_debug(GOSSIP_SUPER_DEBUG,\n\t\t\t     \"Encoding parent: handle %pU, fsid %u\\n\",\n\t\t\t     &refn.khandle,\n\t\t\t     refn.fs_id);\n\t}\n\t*max_len = len;\n\nout:\n\treturn type;\n}\n\nstatic const struct export_operations orangefs_export_ops = {\n\t.encode_fh = orangefs_encode_fh,\n\t.fh_to_dentry = orangefs_fh_to_dentry,\n};\n\nstatic int orangefs_unmount(int id, __s32 fs_id, const char *devname)\n{\n\tstruct orangefs_kernel_op_s *op;\n\tint r;\n\top = op_alloc(ORANGEFS_VFS_OP_FS_UMOUNT);\n\tif (!op)\n\t\treturn -ENOMEM;\n\top->upcall.req.fs_umount.id = id;\n\top->upcall.req.fs_umount.fs_id = fs_id;\n\tstrncpy(op->upcall.req.fs_umount.orangefs_config_server,\n\t    devname, ORANGEFS_MAX_SERVER_ADDR_LEN - 1);\n\tr = service_operation(op, \"orangefs_fs_umount\", 0);\n\t \n\tif (r)\n\t\tgossip_err(\"orangefs_unmount: service_operation %d\\n\", r);\n\top_release(op);\n\treturn r;\n}\n\nstatic int orangefs_fill_sb(struct super_block *sb,\n\t\tstruct orangefs_fs_mount_response *fs_mount,\n\t\tvoid *data, int silent)\n{\n\tint ret;\n\tstruct inode *root;\n\tstruct dentry *root_dentry;\n\tstruct orangefs_object_kref root_object;\n\n\tORANGEFS_SB(sb)->sb = sb;\n\n\tORANGEFS_SB(sb)->root_khandle = fs_mount->root_khandle;\n\tORANGEFS_SB(sb)->fs_id = fs_mount->fs_id;\n\tORANGEFS_SB(sb)->id = fs_mount->id;\n\n\tif (data) {\n\t\tret = parse_mount_options(sb, data, silent);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tsb->s_xattr = orangefs_xattr_handlers;\n\tsb->s_magic = ORANGEFS_SUPER_MAGIC;\n\tsb->s_op = &orangefs_s_ops;\n\tsb->s_d_op = &orangefs_dentry_operations;\n\n\tsb->s_blocksize = PAGE_SIZE;\n\tsb->s_blocksize_bits = PAGE_SHIFT;\n\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\n\tret = super_setup_bdi(sb);\n\tif (ret)\n\t\treturn ret;\n\n\troot_object.khandle = ORANGEFS_SB(sb)->root_khandle;\n\troot_object.fs_id = ORANGEFS_SB(sb)->fs_id;\n\tgossip_debug(GOSSIP_SUPER_DEBUG,\n\t\t     \"get inode %pU, fsid %d\\n\",\n\t\t     &root_object.khandle,\n\t\t     root_object.fs_id);\n\n\troot = orangefs_iget(sb, &root_object);\n\tif (IS_ERR(root))\n\t\treturn PTR_ERR(root);\n\n\tgossip_debug(GOSSIP_SUPER_DEBUG,\n\t\t     \"Allocated root inode [%p] with mode %x\\n\",\n\t\t     root,\n\t\t     root->i_mode);\n\n\t \n\troot_dentry = d_make_root(root);\n\tif (!root_dentry)\n\t\treturn -ENOMEM;\n\n\tsb->s_export_op = &orangefs_export_ops;\n\tsb->s_root = root_dentry;\n\treturn 0;\n}\n\nstruct dentry *orangefs_mount(struct file_system_type *fst,\n\t\t\t   int flags,\n\t\t\t   const char *devname,\n\t\t\t   void *data)\n{\n\tint ret;\n\tstruct super_block *sb = ERR_PTR(-EINVAL);\n\tstruct orangefs_kernel_op_s *new_op;\n\tstruct dentry *d = ERR_PTR(-EINVAL);\n\n\tgossip_debug(GOSSIP_SUPER_DEBUG,\n\t\t     \"orangefs_mount: called with devname %s\\n\",\n\t\t     devname);\n\n\tif (!devname) {\n\t\tgossip_err(\"ERROR: device name not specified.\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tnew_op = op_alloc(ORANGEFS_VFS_OP_FS_MOUNT);\n\tif (!new_op)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstrncpy(new_op->upcall.req.fs_mount.orangefs_config_server,\n\t\tdevname,\n\t\tORANGEFS_MAX_SERVER_ADDR_LEN - 1);\n\n\tgossip_debug(GOSSIP_SUPER_DEBUG,\n\t\t     \"Attempting ORANGEFS Mount via host %s\\n\",\n\t\t     new_op->upcall.req.fs_mount.orangefs_config_server);\n\n\tret = service_operation(new_op, \"orangefs_mount\", 0);\n\tgossip_debug(GOSSIP_SUPER_DEBUG,\n\t\t     \"orangefs_mount: mount got return value of %d\\n\", ret);\n\tif (ret)\n\t\tgoto free_op;\n\n\tif (new_op->downcall.resp.fs_mount.fs_id == ORANGEFS_FS_ID_NULL) {\n\t\tgossip_err(\"ERROR: Retrieved null fs_id\\n\");\n\t\tret = -EINVAL;\n\t\tgoto free_op;\n\t}\n\n\tsb = sget(fst, NULL, set_anon_super, flags, NULL);\n\n\tif (IS_ERR(sb)) {\n\t\td = ERR_CAST(sb);\n\t\torangefs_unmount(new_op->downcall.resp.fs_mount.id,\n\t\t    new_op->downcall.resp.fs_mount.fs_id, devname);\n\t\tgoto free_op;\n\t}\n\n\t \n\tsb->s_fs_info = kzalloc(sizeof(struct orangefs_sb_info_s), GFP_KERNEL);\n\tif (!ORANGEFS_SB(sb)) {\n\t\td = ERR_PTR(-ENOMEM);\n\t\tgoto free_sb_and_op;\n\t}\n\n\tret = orangefs_fill_sb(sb,\n\t      &new_op->downcall.resp.fs_mount, data,\n\t      flags & SB_SILENT ? 1 : 0);\n\n\tif (ret) {\n\t\td = ERR_PTR(ret);\n\t\tgoto free_sb_and_op;\n\t}\n\n\t \n\tstrncpy(ORANGEFS_SB(sb)->devname,\n\t\tdevname,\n\t\tORANGEFS_MAX_SERVER_ADDR_LEN - 1);\n\n\t \n\tORANGEFS_SB(sb)->mount_pending = 0;\n\n\t \n\tgossip_debug(GOSSIP_SUPER_DEBUG,\n\t\t     \"Adding SB %p to orangefs superblocks\\n\",\n\t\t     ORANGEFS_SB(sb));\n\tspin_lock(&orangefs_superblocks_lock);\n\tlist_add_tail(&ORANGEFS_SB(sb)->list, &orangefs_superblocks);\n\tspin_unlock(&orangefs_superblocks_lock);\n\top_release(new_op);\n\n\t \n\tORANGEFS_SB(sb)->no_list = 0;\n\n\tif (orangefs_userspace_version >= 20906) {\n\t\tnew_op = op_alloc(ORANGEFS_VFS_OP_FEATURES);\n\t\tif (!new_op)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tnew_op->upcall.req.features.features = 0;\n\t\tret = service_operation(new_op, \"orangefs_features\", 0);\n\t\torangefs_features = new_op->downcall.resp.features.features;\n\t\top_release(new_op);\n\t} else {\n\t\torangefs_features = 0;\n\t}\n\n\treturn dget(sb->s_root);\n\nfree_sb_and_op:\n\t \n\tORANGEFS_SB(sb)->no_list = 1;\n\t \n\tdeactivate_locked_super(sb);\nfree_op:\n\tgossip_err(\"orangefs_mount: mount request failed with %d\\n\", ret);\n\tif (ret == -EINVAL) {\n\t\tgossip_err(\"Ensure that all orangefs-servers have the same FS configuration files\\n\");\n\t\tgossip_err(\"Look at pvfs2-client-core log file (typically /tmp/pvfs2-client.log) for more details\\n\");\n\t}\n\n\top_release(new_op);\n\n\treturn d;\n}\n\nvoid orangefs_kill_sb(struct super_block *sb)\n{\n\tint r;\n\tgossip_debug(GOSSIP_SUPER_DEBUG, \"orangefs_kill_sb: called\\n\");\n\n\t \n\tkill_anon_super(sb);\n\n\tif (!ORANGEFS_SB(sb)) {\n\t\tmutex_lock(&orangefs_request_mutex);\n\t\tmutex_unlock(&orangefs_request_mutex);\n\t\treturn;\n\t}\n\t \n\tr = orangefs_unmount(ORANGEFS_SB(sb)->id, ORANGEFS_SB(sb)->fs_id,\n\t    ORANGEFS_SB(sb)->devname);\n\tif (!r)\n\t\tORANGEFS_SB(sb)->mount_pending = 1;\n\n\tif (!ORANGEFS_SB(sb)->no_list) {\n\t\t \n\t\tspin_lock(&orangefs_superblocks_lock);\n\t\t \n\t\t__list_del_entry(&ORANGEFS_SB(sb)->list);\n\t\tORANGEFS_SB(sb)->list.prev = NULL;\n\t\tspin_unlock(&orangefs_superblocks_lock);\n\t}\n\n\t \n\tmutex_lock(&orangefs_request_mutex);\n\tmutex_unlock(&orangefs_request_mutex);\n\n\t \n\tkfree(ORANGEFS_SB(sb));\n}\n\nint orangefs_inode_cache_initialize(void)\n{\n\torangefs_inode_cache = kmem_cache_create_usercopy(\n\t\t\t\t\t\"orangefs_inode_cache\",\n\t\t\t\t\tsizeof(struct orangefs_inode_s),\n\t\t\t\t\t0,\n\t\t\t\t\tORANGEFS_CACHE_CREATE_FLAGS,\n\t\t\t\t\toffsetof(struct orangefs_inode_s,\n\t\t\t\t\t\tlink_target),\n\t\t\t\t\tsizeof_field(struct orangefs_inode_s,\n\t\t\t\t\t\tlink_target),\n\t\t\t\t\torangefs_inode_cache_ctor);\n\n\tif (!orangefs_inode_cache) {\n\t\tgossip_err(\"Cannot create orangefs_inode_cache\\n\");\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nint orangefs_inode_cache_finalize(void)\n{\n\tkmem_cache_destroy(orangefs_inode_cache);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}