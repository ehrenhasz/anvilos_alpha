{
  "module_name": "dir.c",
  "hash_id": "9c79d93900a53d16a4103b52e3527b4a6afa7e9117bbee560b767fabf507bd90",
  "original_prompt": "Ingested from linux-6.6.14/fs/orangefs/dir.c",
  "human_readable_source": "\n \n\n#include \"protocol.h\"\n#include \"orangefs-kernel.h\"\n#include \"orangefs-bufmap.h\"\n\nstruct orangefs_dir_part {\n\tstruct orangefs_dir_part *next;\n\tsize_t len;\n};\n\nstruct orangefs_dir {\n\t__u64 token;\n\tstruct orangefs_dir_part *part;\n\tloff_t end;\n\tint error;\n};\n\n#define PART_SHIFT (24)\n#define PART_SIZE (1<<24)\n#define PART_MASK (~(PART_SIZE - 1))\n\n \n\nstatic int do_readdir(struct orangefs_inode_s *oi,\n    struct orangefs_dir *od, struct dentry *dentry,\n    struct orangefs_kernel_op_s *op)\n{\n\tstruct orangefs_readdir_response_s *resp;\n\tint bufi, r;\n\n\t \n\top->uses_shared_memory = 1;\n\top->upcall.req.readdir.refn = oi->refn;\n\top->upcall.req.readdir.token = od->token;\n\top->upcall.req.readdir.max_dirent_count =\n\t    ORANGEFS_MAX_DIRENT_COUNT_READDIR;\n\nagain:\n\tbufi = orangefs_readdir_index_get();\n\tif (bufi < 0) {\n\t\tod->error = bufi;\n\t\treturn bufi;\n\t}\n\n\top->upcall.req.readdir.buf_index = bufi;\n\n\tr = service_operation(op, \"orangefs_readdir\",\n\t    get_interruptible_flag(dentry->d_inode));\n\n\torangefs_readdir_index_put(bufi);\n\n\tif (op_state_purged(op)) {\n\t\tif (r == -EAGAIN) {\n\t\t\tvfree(op->downcall.trailer_buf);\n\t\t\tgoto again;\n\t\t} else if (r == -EIO) {\n\t\t\tvfree(op->downcall.trailer_buf);\n\t\t\tod->error = r;\n\t\t\treturn r;\n\t\t}\n\t}\n\n\tif (r < 0) {\n\t\tvfree(op->downcall.trailer_buf);\n\t\tod->error = r;\n\t\treturn r;\n\t} else if (op->downcall.status) {\n\t\tvfree(op->downcall.trailer_buf);\n\t\tod->error = op->downcall.status;\n\t\treturn op->downcall.status;\n\t}\n\n\t \n\tif (op->downcall.trailer_size > PART_SIZE) {\n\t\tvfree(op->downcall.trailer_buf);\n\t\tod->error = -EIO;\n\t\treturn -EIO;\n\t}\n\n\tresp = (struct orangefs_readdir_response_s *)\n\t    op->downcall.trailer_buf;\n\tod->token = resp->token;\n\treturn 0;\n}\n\nstatic int parse_readdir(struct orangefs_dir *od,\n    struct orangefs_kernel_op_s *op)\n{\n\tstruct orangefs_dir_part *part, *new;\n\tsize_t count;\n\n\tcount = 1;\n\tpart = od->part;\n\twhile (part) {\n\t\tcount++;\n\t\tif (part->next)\n\t\t\tpart = part->next;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tnew = (void *)op->downcall.trailer_buf;\n\tnew->next = NULL;\n\tnew->len = op->downcall.trailer_size -\n\t    sizeof(struct orangefs_readdir_response_s);\n\tif (!od->part)\n\t\tod->part = new;\n\telse\n\t\tpart->next = new;\n\tcount++;\n\tod->end = count << PART_SHIFT;\n\n\treturn 0;\n}\n\nstatic int orangefs_dir_more(struct orangefs_inode_s *oi,\n    struct orangefs_dir *od, struct dentry *dentry)\n{\n\tstruct orangefs_kernel_op_s *op;\n\tint r;\n\n\top = op_alloc(ORANGEFS_VFS_OP_READDIR);\n\tif (!op) {\n\t\tod->error = -ENOMEM;\n\t\treturn -ENOMEM;\n\t}\n\tr = do_readdir(oi, od, dentry, op);\n\tif (r) {\n\t\tod->error = r;\n\t\tgoto out;\n\t}\n\tr = parse_readdir(od, op);\n\tif (r) {\n\t\tod->error = r;\n\t\tgoto out;\n\t}\n\n\tod->error = 0;\nout:\n\top_release(op);\n\treturn od->error;\n}\n\nstatic int fill_from_part(struct orangefs_dir_part *part,\n    struct dir_context *ctx)\n{\n\tconst int offset = sizeof(struct orangefs_readdir_response_s);\n\tstruct orangefs_khandle *khandle;\n\t__u32 *len, padlen;\n\tloff_t i;\n\tchar *s;\n\ti = ctx->pos & ~PART_MASK;\n\n\t \n\tif (i > part->len)\n\t\treturn 1;\n\n\t \n\tif (i % 8)\n\t\ti = i + (8 - i%8)%8;\n\n\twhile (i < part->len) {\n\t\tif (part->len < i + sizeof *len)\n\t\t\tbreak;\n\t\tlen = (void *)part + offset + i;\n\t\t \n\t\tpadlen = (sizeof *len + *len + 1) +\n\t\t    (8 - (sizeof *len + *len + 1)%8)%8;\n\t\tif (part->len < i + padlen + sizeof *khandle)\n\t\t\tgoto next;\n\t\ts = (void *)part + offset + i + sizeof *len;\n\t\tif (s[*len] != 0)\n\t\t\tgoto next;\n\t\tkhandle = (void *)part + offset + i + padlen;\n\t\tif (!dir_emit(ctx, s, *len,\n\t\t    orangefs_khandle_to_ino(khandle),\n\t\t    DT_UNKNOWN))\n\t\t\treturn 0;\n\t\ti += padlen + sizeof *khandle;\n\t\ti = i + (8 - i%8)%8;\n\t\tBUG_ON(i > part->len);\n\t\tctx->pos = (ctx->pos & PART_MASK) | i;\n\t\tcontinue;\nnext:\n\t\ti += 8;\n\t}\n\treturn 1;\n}\n\nstatic int orangefs_dir_fill(struct orangefs_inode_s *oi,\n    struct orangefs_dir *od, struct dentry *dentry,\n    struct dir_context *ctx)\n{\n\tstruct orangefs_dir_part *part;\n\tsize_t count;\n\n\tcount = ((ctx->pos & PART_MASK) >> PART_SHIFT) - 1;\n\n\tpart = od->part;\n\twhile (part->next && count) {\n\t\tcount--;\n\t\tpart = part->next;\n\t}\n\t \n\tif (count) {\n\t\tod->error = -EIO;\n\t\treturn -EIO;\n\t}\n\n\twhile (part && part->len) {\n\t\tint r;\n\t\tr = fill_from_part(part, ctx);\n\t\tif (r < 0) {\n\t\t\tod->error = r;\n\t\t\treturn r;\n\t\t} else if (r == 0) {\n\t\t\t \n\t\t\tbreak;\n\t\t} else {\n\t\t\t \n\t\t\tctx->pos = (ctx->pos & PART_MASK) +\n\t\t\t    (1 << PART_SHIFT);\n\t\t\tpart = part->next;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic loff_t orangefs_dir_llseek(struct file *file, loff_t offset,\n    int whence)\n{\n\tstruct orangefs_dir *od = file->private_data;\n\t \n\tif (!whence && offset < od->end) {\n\t\tstruct orangefs_dir_part *part = od->part;\n\t\twhile (part) {\n\t\t\tstruct orangefs_dir_part *next = part->next;\n\t\t\tvfree(part);\n\t\t\tpart = next;\n\t\t}\n\t\tod->token = ORANGEFS_ITERATE_START;\n\t\tod->part = NULL;\n\t\tod->end = 1 << PART_SHIFT;\n\t}\n\treturn default_llseek(file, offset, whence);\n}\n\nstatic int orangefs_dir_iterate(struct file *file,\n    struct dir_context *ctx)\n{\n\tstruct orangefs_inode_s *oi;\n\tstruct orangefs_dir *od;\n\tstruct dentry *dentry;\n\tint r;\n\n\tdentry = file->f_path.dentry;\n\toi = ORANGEFS_I(dentry->d_inode);\n\tod = file->private_data;\n\n\tif (od->error)\n\t\treturn od->error;\n\n\tif (ctx->pos == 0) {\n\t\tif (!dir_emit_dot(file, ctx))\n\t\t\treturn 0;\n\t\tctx->pos++;\n\t}\n\tif (ctx->pos == 1) {\n\t\tif (!dir_emit_dotdot(file, ctx))\n\t\t\treturn 0;\n\t\tctx->pos = 1 << PART_SHIFT;\n\t}\n\n\t \n\tif ((ctx->pos & PART_MASK) == 0)\n\t\treturn -EIO;\n\n\tr = 0;\n\n\t \n\twhile (od->token != ORANGEFS_ITERATE_END &&\n\t    ctx->pos > od->end) {\n\t\tr = orangefs_dir_more(oi, od, dentry);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\tif (od->token == ORANGEFS_ITERATE_END && ctx->pos > od->end)\n\t\treturn -EIO;\n\n\t \n\tif (ctx->pos < od->end) {\n\t\tr = orangefs_dir_fill(oi, od, dentry, ctx);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\t \n\tif (od->token != ORANGEFS_ITERATE_END) {\n\t\tr = orangefs_dir_more(oi, od, dentry);\n\t\tif (r)\n\t\t\treturn r;\n\t\tr = orangefs_dir_fill(oi, od, dentry, ctx);\n\t}\n\n\treturn r;\n}\n\nstatic int orangefs_dir_open(struct inode *inode, struct file *file)\n{\n\tstruct orangefs_dir *od;\n\tfile->private_data = kmalloc(sizeof(struct orangefs_dir),\n\t    GFP_KERNEL);\n\tif (!file->private_data)\n\t\treturn -ENOMEM;\n\tod = file->private_data;\n\tod->token = ORANGEFS_ITERATE_START;\n\tod->part = NULL;\n\tod->end = 1 << PART_SHIFT;\n\tod->error = 0;\n\treturn 0;\n}\n\nstatic int orangefs_dir_release(struct inode *inode, struct file *file)\n{\n\tstruct orangefs_dir *od = file->private_data;\n\tstruct orangefs_dir_part *part = od->part;\n\twhile (part) {\n\t\tstruct orangefs_dir_part *next = part->next;\n\t\tvfree(part);\n\t\tpart = next;\n\t}\n\tkfree(od);\n\treturn 0;\n}\n\nconst struct file_operations orangefs_dir_operations = {\n\t.llseek = orangefs_dir_llseek,\n\t.read = generic_read_dir,\n\t.iterate_shared = orangefs_dir_iterate,\n\t.open = orangefs_dir_open,\n\t.release = orangefs_dir_release\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}