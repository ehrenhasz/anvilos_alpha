{
  "module_name": "acl.c",
  "hash_id": "5d36a24a3dff6daa86be66e46607f8d33020cef4621050e7a388ae6585cc25c7",
  "original_prompt": "Ingested from linux-6.6.14/fs/orangefs/acl.c",
  "human_readable_source": "\n \n\n#include \"protocol.h\"\n#include \"orangefs-kernel.h\"\n#include \"orangefs-bufmap.h\"\n#include <linux/posix_acl_xattr.h>\n\nstruct posix_acl *orangefs_get_acl(struct inode *inode, int type, bool rcu)\n{\n\tstruct posix_acl *acl;\n\tint ret;\n\tchar *key = NULL, *value = NULL;\n\n\tif (rcu)\n\t\treturn ERR_PTR(-ECHILD);\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tkey = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tkey = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tgossip_err(\"orangefs_get_acl: bogus value of type %d\\n\", type);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\t \n\tvalue = kmalloc(ORANGEFS_MAX_XATTR_VALUELEN, GFP_KERNEL);\n\tif (!value)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tgossip_debug(GOSSIP_ACL_DEBUG,\n\t\t     \"inode %pU, key %s, type %d\\n\",\n\t\t     get_khandle_from_ino(inode),\n\t\t     key,\n\t\t     type);\n\tret = orangefs_inode_getxattr(inode, key, value,\n\t\t\t\t      ORANGEFS_MAX_XATTR_VALUELEN);\n\t \n\tif (ret > 0) {\n\t\tacl = posix_acl_from_xattr(&init_user_ns, value, ret);\n\t} else if (ret == -ENODATA || ret == -ENOSYS) {\n\t\tacl = NULL;\n\t} else {\n\t\tgossip_err(\"inode %pU retrieving acl's failed with error %d\\n\",\n\t\t\t   get_khandle_from_ino(inode),\n\t\t\t   ret);\n\t\tacl = ERR_PTR(ret);\n\t}\n\t \n\tkfree(value);\n\treturn acl;\n}\n\nint __orangefs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint error = 0;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tconst char *name = NULL;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tgossip_err(\"%s: invalid type %d!\\n\", __func__, type);\n\t\treturn -EINVAL;\n\t}\n\n\tgossip_debug(GOSSIP_ACL_DEBUG,\n\t\t     \"%s: inode %pU, key %s type %d\\n\",\n\t\t     __func__, get_khandle_from_ino(inode),\n\t\t     name,\n\t\t     type);\n\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tvalue = kmalloc(size, GFP_KERNEL);\n\t\tif (!value)\n\t\t\treturn -ENOMEM;\n\n\t\terror = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (error < 0)\n\t\t\tgoto out;\n\t}\n\n\tgossip_debug(GOSSIP_ACL_DEBUG,\n\t\t     \"%s: name %s, value %p, size %zd, acl %p\\n\",\n\t\t     __func__, name, value, size, acl);\n\t \n\terror = orangefs_inode_setxattr(inode, name, value, size, 0);\n\nout:\n\tkfree(value);\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\treturn error;\n}\n\nint orangefs_set_acl(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\t     struct posix_acl *acl, int type)\n{\n\tint error;\n\tstruct iattr iattr;\n\tint rc;\n\tstruct inode *inode = d_inode(dentry);\n\n\tmemset(&iattr, 0, sizeof iattr);\n\n\tif (type == ACL_TYPE_ACCESS && acl) {\n\t\t \n\t\terror = posix_acl_update_mode(&nop_mnt_idmap, inode,\n\t\t\t\t\t      &iattr.ia_mode, &acl);\n\t\tif (error) {\n\t\t\tgossip_err(\"%s: posix_acl_update_mode err: %d\\n\",\n\t\t\t\t   __func__,\n\t\t\t\t   error);\n\t\t\treturn error;\n\t\t}\n\n\t\tif (inode->i_mode != iattr.ia_mode)\n\t\t\tiattr.ia_valid = ATTR_MODE;\n\n\t}\n\n\trc = __orangefs_set_acl(inode, acl, type);\n\n\tif (!rc && (iattr.ia_valid == ATTR_MODE))\n\t\trc = __orangefs_setattr_mode(dentry, &iattr);\n\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}