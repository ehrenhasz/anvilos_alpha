{
  "module_name": "orangefs-cache.c",
  "hash_id": "53a4e61f502bf6fdae791ae7427be2c1efa6db7b709608153c0d4db9e64c33bb",
  "original_prompt": "Ingested from linux-6.6.14/fs/orangefs/orangefs-cache.c",
  "human_readable_source": "\n \n\n#include \"protocol.h\"\n#include \"orangefs-kernel.h\"\n\n \nstatic __u64 next_tag_value;\nstatic DEFINE_SPINLOCK(next_tag_value_lock);\n\n \n\n \nstatic struct kmem_cache *op_cache;\n\nint op_cache_initialize(void)\n{\n\top_cache = kmem_cache_create(\"orangefs_op_cache\",\n\t\t\t\t     sizeof(struct orangefs_kernel_op_s),\n\t\t\t\t     0,\n\t\t\t\t     ORANGEFS_CACHE_CREATE_FLAGS,\n\t\t\t\t     NULL);\n\n\tif (!op_cache) {\n\t\tgossip_err(\"Cannot create orangefs_op_cache\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tspin_lock(&next_tag_value_lock);\n\tnext_tag_value = 100;\n\tspin_unlock(&next_tag_value_lock);\n\treturn 0;\n}\n\nint op_cache_finalize(void)\n{\n\tkmem_cache_destroy(op_cache);\n\treturn 0;\n}\n\nchar *get_opname_string(struct orangefs_kernel_op_s *new_op)\n{\n\tif (new_op) {\n\t\t__s32 type = new_op->upcall.type;\n\n\t\tif (type == ORANGEFS_VFS_OP_FILE_IO)\n\t\t\treturn \"OP_FILE_IO\";\n\t\telse if (type == ORANGEFS_VFS_OP_LOOKUP)\n\t\t\treturn \"OP_LOOKUP\";\n\t\telse if (type == ORANGEFS_VFS_OP_CREATE)\n\t\t\treturn \"OP_CREATE\";\n\t\telse if (type == ORANGEFS_VFS_OP_GETATTR)\n\t\t\treturn \"OP_GETATTR\";\n\t\telse if (type == ORANGEFS_VFS_OP_REMOVE)\n\t\t\treturn \"OP_REMOVE\";\n\t\telse if (type == ORANGEFS_VFS_OP_MKDIR)\n\t\t\treturn \"OP_MKDIR\";\n\t\telse if (type == ORANGEFS_VFS_OP_READDIR)\n\t\t\treturn \"OP_READDIR\";\n\t\telse if (type == ORANGEFS_VFS_OP_READDIRPLUS)\n\t\t\treturn \"OP_READDIRPLUS\";\n\t\telse if (type == ORANGEFS_VFS_OP_SETATTR)\n\t\t\treturn \"OP_SETATTR\";\n\t\telse if (type == ORANGEFS_VFS_OP_SYMLINK)\n\t\t\treturn \"OP_SYMLINK\";\n\t\telse if (type == ORANGEFS_VFS_OP_RENAME)\n\t\t\treturn \"OP_RENAME\";\n\t\telse if (type == ORANGEFS_VFS_OP_STATFS)\n\t\t\treturn \"OP_STATFS\";\n\t\telse if (type == ORANGEFS_VFS_OP_TRUNCATE)\n\t\t\treturn \"OP_TRUNCATE\";\n\t\telse if (type == ORANGEFS_VFS_OP_RA_FLUSH)\n\t\t\treturn \"OP_RA_FLUSH\";\n\t\telse if (type == ORANGEFS_VFS_OP_FS_MOUNT)\n\t\t\treturn \"OP_FS_MOUNT\";\n\t\telse if (type == ORANGEFS_VFS_OP_FS_UMOUNT)\n\t\t\treturn \"OP_FS_UMOUNT\";\n\t\telse if (type == ORANGEFS_VFS_OP_GETXATTR)\n\t\t\treturn \"OP_GETXATTR\";\n\t\telse if (type == ORANGEFS_VFS_OP_SETXATTR)\n\t\t\treturn \"OP_SETXATTR\";\n\t\telse if (type == ORANGEFS_VFS_OP_LISTXATTR)\n\t\t\treturn \"OP_LISTXATTR\";\n\t\telse if (type == ORANGEFS_VFS_OP_REMOVEXATTR)\n\t\t\treturn \"OP_REMOVEXATTR\";\n\t\telse if (type == ORANGEFS_VFS_OP_PARAM)\n\t\t\treturn \"OP_PARAM\";\n\t\telse if (type == ORANGEFS_VFS_OP_PERF_COUNT)\n\t\t\treturn \"OP_PERF_COUNT\";\n\t\telse if (type == ORANGEFS_VFS_OP_CANCEL)\n\t\t\treturn \"OP_CANCEL\";\n\t\telse if (type == ORANGEFS_VFS_OP_FSYNC)\n\t\t\treturn \"OP_FSYNC\";\n\t\telse if (type == ORANGEFS_VFS_OP_FSKEY)\n\t\t\treturn \"OP_FSKEY\";\n\t\telse if (type == ORANGEFS_VFS_OP_FEATURES)\n\t\t\treturn \"OP_FEATURES\";\n\t}\n\treturn \"OP_UNKNOWN?\";\n}\n\nvoid orangefs_new_tag(struct orangefs_kernel_op_s *op)\n{\n\tspin_lock(&next_tag_value_lock);\n\top->tag = next_tag_value++;\n\tif (next_tag_value == 0)\n\t\tnext_tag_value = 100;\n\tspin_unlock(&next_tag_value_lock);\n}\n\nstruct orangefs_kernel_op_s *op_alloc(__s32 type)\n{\n\tstruct orangefs_kernel_op_s *new_op = NULL;\n\n\tnew_op = kmem_cache_zalloc(op_cache, GFP_KERNEL);\n\tif (new_op) {\n\t\tINIT_LIST_HEAD(&new_op->list);\n\t\tspin_lock_init(&new_op->lock);\n\t\tinit_completion(&new_op->waitq);\n\n\t\tnew_op->upcall.type = ORANGEFS_VFS_OP_INVALID;\n\t\tnew_op->downcall.type = ORANGEFS_VFS_OP_INVALID;\n\t\tnew_op->downcall.status = -1;\n\n\t\tnew_op->op_state = OP_VFS_STATE_UNKNOWN;\n\n\t\t \n\t\torangefs_new_tag(new_op);\n\t\tnew_op->upcall.type = type;\n\t\tnew_op->attempts = 0;\n\t\tgossip_debug(GOSSIP_CACHE_DEBUG,\n\t\t\t     \"Alloced OP (%p: %llu %s)\\n\",\n\t\t\t     new_op,\n\t\t\t     llu(new_op->tag),\n\t\t\t     get_opname_string(new_op));\n\n\t\tnew_op->upcall.uid = from_kuid(&init_user_ns,\n\t\t\t\t\t       current_fsuid());\n\n\t\tnew_op->upcall.gid = from_kgid(&init_user_ns,\n\t\t\t\t\t       current_fsgid());\n\t} else {\n\t\tgossip_err(\"op_alloc: kmem_cache_zalloc failed!\\n\");\n\t}\n\treturn new_op;\n}\n\nvoid op_release(struct orangefs_kernel_op_s *orangefs_op)\n{\n\tif (orangefs_op) {\n\t\tgossip_debug(GOSSIP_CACHE_DEBUG,\n\t\t\t     \"Releasing OP (%p: %llu)\\n\",\n\t\t\t     orangefs_op,\n\t\t\t     llu(orangefs_op->tag));\n\t\tkmem_cache_free(op_cache, orangefs_op);\n\t} else {\n\t\tgossip_err(\"NULL pointer in op_release\\n\");\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}