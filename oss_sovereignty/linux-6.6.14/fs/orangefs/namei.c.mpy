{
  "module_name": "namei.c",
  "hash_id": "ea22f0c9a7f69f10a7d06bbc315a9aa2d113d0f46af4889dd5eaee897dba239c",
  "original_prompt": "Ingested from linux-6.6.14/fs/orangefs/namei.c",
  "human_readable_source": "\n \n\n \n\n#include \"protocol.h\"\n#include \"orangefs-kernel.h\"\n\n \nstatic int orangefs_create(struct mnt_idmap *idmap,\n\t\t\tstruct inode *dir,\n\t\t\tstruct dentry *dentry,\n\t\t\tumode_t mode,\n\t\t\tbool exclusive)\n{\n\tstruct orangefs_inode_s *parent = ORANGEFS_I(dir);\n\tstruct orangefs_kernel_op_s *new_op;\n\tstruct orangefs_object_kref ref;\n\tstruct inode *inode;\n\tstruct iattr iattr;\n\tint ret;\n\n\tgossip_debug(GOSSIP_NAME_DEBUG, \"%s: %pd\\n\",\n\t\t     __func__,\n\t\t     dentry);\n\n\tnew_op = op_alloc(ORANGEFS_VFS_OP_CREATE);\n\tif (!new_op)\n\t\treturn -ENOMEM;\n\n\tnew_op->upcall.req.create.parent_refn = parent->refn;\n\n\tfill_default_sys_attrs(new_op->upcall.req.create.attributes,\n\t\t\t       ORANGEFS_TYPE_METAFILE, mode);\n\n\tstrncpy(new_op->upcall.req.create.d_name,\n\t\tdentry->d_name.name, ORANGEFS_NAME_MAX - 1);\n\n\tret = service_operation(new_op, __func__, get_interruptible_flag(dir));\n\n\tgossip_debug(GOSSIP_NAME_DEBUG,\n\t\t     \"%s: %pd: handle:%pU: fsid:%d: new_op:%p: ret:%d:\\n\",\n\t\t     __func__,\n\t\t     dentry,\n\t\t     &new_op->downcall.resp.create.refn.khandle,\n\t\t     new_op->downcall.resp.create.refn.fs_id,\n\t\t     new_op,\n\t\t     ret);\n\n\tif (ret < 0)\n\t\tgoto out;\n\n\tref = new_op->downcall.resp.create.refn;\n\n\tinode = orangefs_new_inode(dir->i_sb, dir, S_IFREG | mode, 0, &ref);\n\tif (IS_ERR(inode)) {\n\t\tgossip_err(\"%s: Failed to allocate inode for file :%pd:\\n\",\n\t\t\t   __func__,\n\t\t\t   dentry);\n\t\tret = PTR_ERR(inode);\n\t\tgoto out;\n\t}\n\n\tgossip_debug(GOSSIP_NAME_DEBUG,\n\t\t     \"%s: Assigned inode :%pU: for file :%pd:\\n\",\n\t\t     __func__,\n\t\t     get_khandle_from_ino(inode),\n\t\t     dentry);\n\n\td_instantiate_new(dentry, inode);\n\torangefs_set_timeout(dentry);\n\n\tgossip_debug(GOSSIP_NAME_DEBUG,\n\t\t     \"%s: dentry instantiated for %pd\\n\",\n\t\t     __func__,\n\t\t     dentry);\n\n\tmemset(&iattr, 0, sizeof iattr);\n\tiattr.ia_valid |= ATTR_MTIME | ATTR_CTIME;\n\tiattr.ia_mtime = iattr.ia_ctime = current_time(dir);\n\t__orangefs_setattr(dir, &iattr);\n\tret = 0;\nout:\n\top_release(new_op);\n\tgossip_debug(GOSSIP_NAME_DEBUG,\n\t\t     \"%s: %pd: returning %d\\n\",\n\t\t     __func__,\n\t\t     dentry,\n\t\t     ret);\n\treturn ret;\n}\n\n \nstatic struct dentry *orangefs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t   unsigned int flags)\n{\n\tstruct orangefs_inode_s *parent = ORANGEFS_I(dir);\n\tstruct orangefs_kernel_op_s *new_op;\n\tstruct inode *inode;\n\tint ret = -EINVAL;\n\n\t \n\tgossip_debug(GOSSIP_NAME_DEBUG, \"%s called on %pd\\n\",\n\t\t     __func__, dentry);\n\n\tif (dentry->d_name.len > (ORANGEFS_NAME_MAX - 1))\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tnew_op = op_alloc(ORANGEFS_VFS_OP_LOOKUP);\n\tif (!new_op)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnew_op->upcall.req.lookup.sym_follow = ORANGEFS_LOOKUP_LINK_NO_FOLLOW;\n\n\tgossip_debug(GOSSIP_NAME_DEBUG, \"%s:%s:%d using parent %pU\\n\",\n\t\t     __FILE__,\n\t\t     __func__,\n\t\t     __LINE__,\n\t\t     &parent->refn.khandle);\n\tnew_op->upcall.req.lookup.parent_refn = parent->refn;\n\n\tstrncpy(new_op->upcall.req.lookup.d_name, dentry->d_name.name,\n\t\tORANGEFS_NAME_MAX - 1);\n\n\tgossip_debug(GOSSIP_NAME_DEBUG,\n\t\t     \"%s: doing lookup on %s under %pU,%d\\n\",\n\t\t     __func__,\n\t\t     new_op->upcall.req.lookup.d_name,\n\t\t     &new_op->upcall.req.lookup.parent_refn.khandle,\n\t\t     new_op->upcall.req.lookup.parent_refn.fs_id);\n\n\tret = service_operation(new_op, __func__, get_interruptible_flag(dir));\n\n\tgossip_debug(GOSSIP_NAME_DEBUG,\n\t\t     \"Lookup Got %pU, fsid %d (ret=%d)\\n\",\n\t\t     &new_op->downcall.resp.lookup.refn.khandle,\n\t\t     new_op->downcall.resp.lookup.refn.fs_id,\n\t\t     ret);\n\n\tif (ret == 0) {\n\t\torangefs_set_timeout(dentry);\n\t\tinode = orangefs_iget(dir->i_sb, &new_op->downcall.resp.lookup.refn);\n\t} else if (ret == -ENOENT) {\n\t\tinode = NULL;\n\t} else {\n\t\t \n\t\tinode = ERR_PTR(ret);\n\t}\n\n\top_release(new_op);\n\treturn d_splice_alias(inode, dentry);\n}\n\n \nstatic int orangefs_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct orangefs_inode_s *parent = ORANGEFS_I(dir);\n\tstruct orangefs_kernel_op_s *new_op;\n\tstruct iattr iattr;\n\tint ret;\n\n\tgossip_debug(GOSSIP_NAME_DEBUG,\n\t\t     \"%s: called on %pd\\n\"\n\t\t     \"  (inode %pU): Parent is %pU | fs_id %d\\n\",\n\t\t     __func__,\n\t\t     dentry,\n\t\t     get_khandle_from_ino(inode),\n\t\t     &parent->refn.khandle,\n\t\t     parent->refn.fs_id);\n\n\tnew_op = op_alloc(ORANGEFS_VFS_OP_REMOVE);\n\tif (!new_op)\n\t\treturn -ENOMEM;\n\n\tnew_op->upcall.req.remove.parent_refn = parent->refn;\n\tstrncpy(new_op->upcall.req.remove.d_name, dentry->d_name.name,\n\t\tORANGEFS_NAME_MAX - 1);\n\n\tret = service_operation(new_op, \"orangefs_unlink\",\n\t\t\t\tget_interruptible_flag(inode));\n\n\tgossip_debug(GOSSIP_NAME_DEBUG,\n\t\t     \"%s: service_operation returned:%d:\\n\",\n\t\t     __func__,\n\t\t     ret);\n\n\top_release(new_op);\n\n\tif (!ret) {\n\t\tdrop_nlink(inode);\n\n\t\tmemset(&iattr, 0, sizeof iattr);\n\t\tiattr.ia_valid |= ATTR_MTIME | ATTR_CTIME;\n\t\tiattr.ia_mtime = iattr.ia_ctime = current_time(dir);\n\t\t__orangefs_setattr(dir, &iattr);\n\t}\n\treturn ret;\n}\n\nstatic int orangefs_symlink(struct mnt_idmap *idmap,\n\t\t         struct inode *dir,\n\t\t\t struct dentry *dentry,\n\t\t\t const char *symname)\n{\n\tstruct orangefs_inode_s *parent = ORANGEFS_I(dir);\n\tstruct orangefs_kernel_op_s *new_op;\n\tstruct orangefs_object_kref ref;\n\tstruct inode *inode;\n\tstruct iattr iattr;\n\tint mode = 0755;\n\tint ret;\n\n\tgossip_debug(GOSSIP_NAME_DEBUG, \"%s: called\\n\", __func__);\n\n\tif (!symname)\n\t\treturn -EINVAL;\n\n\tif (strlen(symname)+1 > ORANGEFS_NAME_MAX)\n\t\treturn -ENAMETOOLONG;\n\n\tnew_op = op_alloc(ORANGEFS_VFS_OP_SYMLINK);\n\tif (!new_op)\n\t\treturn -ENOMEM;\n\n\tnew_op->upcall.req.sym.parent_refn = parent->refn;\n\n\tfill_default_sys_attrs(new_op->upcall.req.sym.attributes,\n\t\t\t       ORANGEFS_TYPE_SYMLINK,\n\t\t\t       mode);\n\n\tstrncpy(new_op->upcall.req.sym.entry_name,\n\t\tdentry->d_name.name,\n\t\tORANGEFS_NAME_MAX - 1);\n\tstrncpy(new_op->upcall.req.sym.target, symname, ORANGEFS_NAME_MAX - 1);\n\n\tret = service_operation(new_op, __func__, get_interruptible_flag(dir));\n\n\tgossip_debug(GOSSIP_NAME_DEBUG,\n\t\t     \"Symlink Got ORANGEFS handle %pU on fsid %d (ret=%d)\\n\",\n\t\t     &new_op->downcall.resp.sym.refn.khandle,\n\t\t     new_op->downcall.resp.sym.refn.fs_id, ret);\n\n\tif (ret < 0) {\n\t\tgossip_debug(GOSSIP_NAME_DEBUG,\n\t\t\t    \"%s: failed with error code %d\\n\",\n\t\t\t    __func__, ret);\n\t\tgoto out;\n\t}\n\n\tref = new_op->downcall.resp.sym.refn;\n\n\tinode = orangefs_new_inode(dir->i_sb, dir, S_IFLNK | mode, 0, &ref);\n\tif (IS_ERR(inode)) {\n\t\tgossip_err\n\t\t    (\"*** Failed to allocate orangefs symlink inode\\n\");\n\t\tret = PTR_ERR(inode);\n\t\tgoto out;\n\t}\n\t \n\tinode->i_size = strlen(symname);\n\n\tgossip_debug(GOSSIP_NAME_DEBUG,\n\t\t     \"Assigned symlink inode new number of %pU\\n\",\n\t\t     get_khandle_from_ino(inode));\n\n\td_instantiate_new(dentry, inode);\n\torangefs_set_timeout(dentry);\n\n\tgossip_debug(GOSSIP_NAME_DEBUG,\n\t\t     \"Inode (Symlink) %pU -> %pd\\n\",\n\t\t     get_khandle_from_ino(inode),\n\t\t     dentry);\n\n\tmemset(&iattr, 0, sizeof iattr);\n\tiattr.ia_valid |= ATTR_MTIME | ATTR_CTIME;\n\tiattr.ia_mtime = iattr.ia_ctime = current_time(dir);\n\t__orangefs_setattr(dir, &iattr);\n\tret = 0;\nout:\n\top_release(new_op);\n\treturn ret;\n}\n\nstatic int orangefs_mkdir(struct mnt_idmap *idmap, struct inode *dir,\n\t\t\t  struct dentry *dentry, umode_t mode)\n{\n\tstruct orangefs_inode_s *parent = ORANGEFS_I(dir);\n\tstruct orangefs_kernel_op_s *new_op;\n\tstruct orangefs_object_kref ref;\n\tstruct inode *inode;\n\tstruct iattr iattr;\n\tint ret;\n\n\tnew_op = op_alloc(ORANGEFS_VFS_OP_MKDIR);\n\tif (!new_op)\n\t\treturn -ENOMEM;\n\n\tnew_op->upcall.req.mkdir.parent_refn = parent->refn;\n\n\tfill_default_sys_attrs(new_op->upcall.req.mkdir.attributes,\n\t\t\t      ORANGEFS_TYPE_DIRECTORY, mode);\n\n\tstrncpy(new_op->upcall.req.mkdir.d_name,\n\t\tdentry->d_name.name, ORANGEFS_NAME_MAX - 1);\n\n\tret = service_operation(new_op, __func__, get_interruptible_flag(dir));\n\n\tgossip_debug(GOSSIP_NAME_DEBUG,\n\t\t     \"Mkdir Got ORANGEFS handle %pU on fsid %d\\n\",\n\t\t     &new_op->downcall.resp.mkdir.refn.khandle,\n\t\t     new_op->downcall.resp.mkdir.refn.fs_id);\n\n\tif (ret < 0) {\n\t\tgossip_debug(GOSSIP_NAME_DEBUG,\n\t\t\t     \"%s: failed with error code %d\\n\",\n\t\t\t     __func__, ret);\n\t\tgoto out;\n\t}\n\n\tref = new_op->downcall.resp.mkdir.refn;\n\n\tinode = orangefs_new_inode(dir->i_sb, dir, S_IFDIR | mode, 0, &ref);\n\tif (IS_ERR(inode)) {\n\t\tgossip_err(\"*** Failed to allocate orangefs dir inode\\n\");\n\t\tret = PTR_ERR(inode);\n\t\tgoto out;\n\t}\n\n\tgossip_debug(GOSSIP_NAME_DEBUG,\n\t\t     \"Assigned dir inode new number of %pU\\n\",\n\t\t     get_khandle_from_ino(inode));\n\n\td_instantiate_new(dentry, inode);\n\torangefs_set_timeout(dentry);\n\n\tgossip_debug(GOSSIP_NAME_DEBUG,\n\t\t     \"Inode (Directory) %pU -> %pd\\n\",\n\t\t     get_khandle_from_ino(inode),\n\t\t     dentry);\n\n\t \n\tmemset(&iattr, 0, sizeof iattr);\n\tiattr.ia_valid |= ATTR_MTIME | ATTR_CTIME;\n\tiattr.ia_mtime = iattr.ia_ctime = current_time(dir);\n\t__orangefs_setattr(dir, &iattr);\nout:\n\top_release(new_op);\n\treturn ret;\n}\n\nstatic int orangefs_rename(struct mnt_idmap *idmap,\n\t\t\tstruct inode *old_dir,\n\t\t\tstruct dentry *old_dentry,\n\t\t\tstruct inode *new_dir,\n\t\t\tstruct dentry *new_dentry,\n\t\t\tunsigned int flags)\n{\n\tstruct orangefs_kernel_op_s *new_op;\n\tstruct iattr iattr;\n\tint ret;\n\n\tif (flags)\n\t\treturn -EINVAL;\n\n\tgossip_debug(GOSSIP_NAME_DEBUG,\n\t\t     \"orangefs_rename: called (%pd2 => %pd2) ct=%d\\n\",\n\t\t     old_dentry, new_dentry, d_count(new_dentry));\n\n\tmemset(&iattr, 0, sizeof iattr);\n\tiattr.ia_valid |= ATTR_MTIME | ATTR_CTIME;\n\tiattr.ia_mtime = iattr.ia_ctime = current_time(new_dir);\n\t__orangefs_setattr(new_dir, &iattr);\n\n\tnew_op = op_alloc(ORANGEFS_VFS_OP_RENAME);\n\tif (!new_op)\n\t\treturn -EINVAL;\n\n\tnew_op->upcall.req.rename.old_parent_refn = ORANGEFS_I(old_dir)->refn;\n\tnew_op->upcall.req.rename.new_parent_refn = ORANGEFS_I(new_dir)->refn;\n\n\tstrncpy(new_op->upcall.req.rename.d_old_name,\n\t\told_dentry->d_name.name,\n\t\tORANGEFS_NAME_MAX - 1);\n\tstrncpy(new_op->upcall.req.rename.d_new_name,\n\t\tnew_dentry->d_name.name,\n\t\tORANGEFS_NAME_MAX - 1);\n\n\tret = service_operation(new_op,\n\t\t\t\t\"orangefs_rename\",\n\t\t\t\tget_interruptible_flag(old_dentry->d_inode));\n\n\tgossip_debug(GOSSIP_NAME_DEBUG,\n\t\t     \"orangefs_rename: got downcall status %d\\n\",\n\t\t     ret);\n\n\tif (new_dentry->d_inode)\n\t\tinode_set_ctime_current(d_inode(new_dentry));\n\n\top_release(new_op);\n\treturn ret;\n}\n\n \nconst struct inode_operations orangefs_dir_inode_operations = {\n\t.lookup = orangefs_lookup,\n\t.get_inode_acl = orangefs_get_acl,\n\t.set_acl = orangefs_set_acl,\n\t.create = orangefs_create,\n\t.unlink = orangefs_unlink,\n\t.symlink = orangefs_symlink,\n\t.mkdir = orangefs_mkdir,\n\t.rmdir = orangefs_unlink,\n\t.rename = orangefs_rename,\n\t.setattr = orangefs_setattr,\n\t.getattr = orangefs_getattr,\n\t.listxattr = orangefs_listxattr,\n\t.permission = orangefs_permission,\n\t.update_time = orangefs_update_time,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}