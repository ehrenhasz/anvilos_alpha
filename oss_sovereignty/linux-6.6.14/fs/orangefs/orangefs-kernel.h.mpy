{
  "module_name": "orangefs-kernel.h",
  "hash_id": "588851d5404b2d828a374f58c5c8c381640aa8e36c327de68d31df7c9d164ae1",
  "original_prompt": "Ingested from linux-6.6.14/fs/orangefs/orangefs-kernel.h",
  "human_readable_source": " \n \n\n \n\n \n\n#ifndef __ORANGEFSKERNEL_H\n#define __ORANGEFSKERNEL_H\n\n#include <linux/kernel.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/backing-dev.h>\n#include <linux/device.h>\n#include <linux/mpage.h>\n#include <linux/namei.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n\n#include <linux/aio.h>\n#include <linux/posix_acl.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/compat.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/atomic.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/wait.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/poll.h>\n#include <linux/rwsem.h>\n#include <linux/xattr.h>\n#include <linux/exportfs.h>\n#include <linux/hashtable.h>\n\n#include <asm/unaligned.h>\n\n#include \"orangefs-dev-proto.h\"\n\n#define ORANGEFS_DEFAULT_OP_TIMEOUT_SECS       20\n\n#define ORANGEFS_BUFMAP_WAIT_TIMEOUT_SECS   30\n\n#define ORANGEFS_DEFAULT_SLOT_TIMEOUT_SECS     900\t \n\n#define ORANGEFS_REQDEVICE_NAME          \"pvfs2-req\"\n\n#define ORANGEFS_DEVREQ_MAGIC             0x20030529\n#define ORANGEFS_PURGE_RETRY_COUNT     0x00000005\n\n#define MAX_DEV_REQ_UPSIZE (2 * sizeof(__s32) +   \\\nsizeof(__u64) + sizeof(struct orangefs_upcall_s))\n#define MAX_DEV_REQ_DOWNSIZE (2 * sizeof(__s32) + \\\nsizeof(__u64) + sizeof(struct orangefs_downcall_s))\n\n \nenum orangefs_vfs_op_states {\n\tOP_VFS_STATE_UNKNOWN = 0,\n\tOP_VFS_STATE_WAITING = 1,\n\tOP_VFS_STATE_INPROGR = 2,\n\tOP_VFS_STATE_SERVICED = 4,\n\tOP_VFS_STATE_PURGED = 8,\n\tOP_VFS_STATE_GIVEN_UP = 16,\n};\n\n \n\n#if (defined CONFIG_DEBUG_SLAB)\n#define ORANGEFS_CACHE_CREATE_FLAGS SLAB_RED_ZONE\n#else\n#define ORANGEFS_CACHE_CREATE_FLAGS 0\n#endif\n\nextern const struct xattr_handler *orangefs_xattr_handlers[];\n\nextern struct posix_acl *orangefs_get_acl(struct inode *inode, int type, bool rcu);\nextern int orangefs_set_acl(struct mnt_idmap *idmap,\n\t\t\t    struct dentry *dentry, struct posix_acl *acl,\n\t\t\t    int type);\nint __orangefs_set_acl(struct inode *inode, struct posix_acl *acl, int type);\n\n \nstruct orangefs_kernel_op_s {\n\tenum orangefs_vfs_op_states op_state;\n\t__u64 tag;\n\n\t \n\tunion {\n\t\tint uses_shared_memory;\n\t\tint slot_to_free;\n\t};\n\n\tstruct orangefs_upcall_s upcall;\n\tstruct orangefs_downcall_s downcall;\n\n\tstruct completion waitq;\n\tspinlock_t lock;\n\n\tint attempts;\n\n\tstruct list_head list;\n};\n\n#define set_op_state_waiting(op)     ((op)->op_state = OP_VFS_STATE_WAITING)\n#define set_op_state_inprogress(op)  ((op)->op_state = OP_VFS_STATE_INPROGR)\n#define set_op_state_given_up(op)  ((op)->op_state = OP_VFS_STATE_GIVEN_UP)\nstatic inline void set_op_state_serviced(struct orangefs_kernel_op_s *op)\n{\n\top->op_state = OP_VFS_STATE_SERVICED;\n\tcomplete(&op->waitq);\n}\n\n#define op_state_waiting(op)     ((op)->op_state & OP_VFS_STATE_WAITING)\n#define op_state_in_progress(op) ((op)->op_state & OP_VFS_STATE_INPROGR)\n#define op_state_serviced(op)    ((op)->op_state & OP_VFS_STATE_SERVICED)\n#define op_state_purged(op)      ((op)->op_state & OP_VFS_STATE_PURGED)\n#define op_state_given_up(op)    ((op)->op_state & OP_VFS_STATE_GIVEN_UP)\n#define op_is_cancel(op)         ((op)->upcall.type == ORANGEFS_VFS_OP_CANCEL)\n\nvoid op_release(struct orangefs_kernel_op_s *op);\n\nextern void orangefs_bufmap_put(int);\nstatic inline void put_cancel(struct orangefs_kernel_op_s *op)\n{\n\torangefs_bufmap_put(op->slot_to_free);\n\top_release(op);\n}\n\nstatic inline void set_op_state_purged(struct orangefs_kernel_op_s *op)\n{\n\tspin_lock(&op->lock);\n\tif (unlikely(op_is_cancel(op))) {\n\t\tlist_del_init(&op->list);\n\t\tspin_unlock(&op->lock);\n\t\tput_cancel(op);\n\t} else {\n\t\top->op_state |= OP_VFS_STATE_PURGED;\n\t\tcomplete(&op->waitq);\n\t\tspin_unlock(&op->lock);\n\t}\n}\n\n \nstruct orangefs_inode_s {\n\tstruct orangefs_object_kref refn;\n\tchar link_target[ORANGEFS_NAME_MAX];\n\t \n\tstruct rw_semaphore xattr_sem;\n\n\tstruct inode vfs_inode;\n\tsector_t last_failed_block_index_read;\n\n\tunsigned long getattr_time;\n\tunsigned long mapping_time;\n\tint attr_valid;\n\tkuid_t attr_uid;\n\tkgid_t attr_gid;\n\tunsigned long bitlock;\n\n\tDECLARE_HASHTABLE(xattr_cache, 4);\n};\n\n \nstruct orangefs_sb_info_s {\n\tstruct orangefs_khandle root_khandle;\n\t__s32 fs_id;\n\tint id;\n\tint flags;\n#define ORANGEFS_OPT_INTR\t0x01\n#define ORANGEFS_OPT_LOCAL_LOCK\t0x02\n\tchar devname[ORANGEFS_MAX_SERVER_ADDR_LEN];\n\tstruct super_block *sb;\n\tint mount_pending;\n\tint no_list;\n\tstruct list_head list;\n};\n\nstruct orangefs_stats {\n\tunsigned long cache_hits;\n\tunsigned long cache_misses;\n\tunsigned long reads;\n\tunsigned long writes;\n};\n\nstruct orangefs_cached_xattr {\n\tstruct hlist_node node;\n\tchar key[ORANGEFS_MAX_XATTR_NAMELEN];\n\tchar val[ORANGEFS_MAX_XATTR_VALUELEN];\n\tssize_t length;\n\tunsigned long timeout;\n};\n\nstruct orangefs_write_range {\n\tloff_t pos;\n\tsize_t len;\n\tkuid_t uid;\n\tkgid_t gid;\n};\n\nextern struct orangefs_stats orangefs_stats;\n\n \nstatic inline struct orangefs_inode_s *ORANGEFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct orangefs_inode_s, vfs_inode);\n}\n\nstatic inline struct orangefs_sb_info_s *ORANGEFS_SB(struct super_block *sb)\n{\n\treturn (struct orangefs_sb_info_s *) sb->s_fs_info;\n}\n\n \nstatic inline ino_t orangefs_khandle_to_ino(struct orangefs_khandle *khandle)\n{\n\tunion {\n\t\tunsigned char u[8];\n\t\t__u64 ino;\n\t} ihandle;\n\n\tihandle.u[0] = khandle->u[0] ^ khandle->u[4];\n\tihandle.u[1] = khandle->u[1] ^ khandle->u[5];\n\tihandle.u[2] = khandle->u[2] ^ khandle->u[6];\n\tihandle.u[3] = khandle->u[3] ^ khandle->u[7];\n\tihandle.u[4] = khandle->u[12] ^ khandle->u[8];\n\tihandle.u[5] = khandle->u[13] ^ khandle->u[9];\n\tihandle.u[6] = khandle->u[14] ^ khandle->u[10];\n\tihandle.u[7] = khandle->u[15] ^ khandle->u[11];\n\n\treturn ihandle.ino;\n}\n\nstatic inline struct orangefs_khandle *get_khandle_from_ino(struct inode *inode)\n{\n\treturn &(ORANGEFS_I(inode)->refn.khandle);\n}\n\nstatic inline int is_root_handle(struct inode *inode)\n{\n\tgossip_debug(GOSSIP_DCACHE_DEBUG,\n\t\t     \"%s: root handle: %pU, this handle: %pU:\\n\",\n\t\t     __func__,\n\t\t     &ORANGEFS_SB(inode->i_sb)->root_khandle,\n\t\t     get_khandle_from_ino(inode));\n\n\tif (ORANGEFS_khandle_cmp(&(ORANGEFS_SB(inode->i_sb)->root_khandle),\n\t\t\t     get_khandle_from_ino(inode)))\n\t\treturn 0;\n\telse\n\t\treturn 1;\n}\n\nstatic inline int match_handle(struct orangefs_khandle resp_handle,\n\t\t\t       struct inode *inode)\n{\n\tgossip_debug(GOSSIP_DCACHE_DEBUG,\n\t\t     \"%s: one handle: %pU, another handle:%pU:\\n\",\n\t\t     __func__,\n\t\t     &resp_handle,\n\t\t     get_khandle_from_ino(inode));\n\n\tif (ORANGEFS_khandle_cmp(&resp_handle, get_khandle_from_ino(inode)))\n\t\treturn 0;\n\telse\n\t\treturn 1;\n}\n\n \nint op_cache_initialize(void);\nint op_cache_finalize(void);\nstruct orangefs_kernel_op_s *op_alloc(__s32 type);\nvoid orangefs_new_tag(struct orangefs_kernel_op_s *op);\nchar *get_opname_string(struct orangefs_kernel_op_s *new_op);\n\nint orangefs_inode_cache_initialize(void);\nint orangefs_inode_cache_finalize(void);\n\n \nvoid purge_inprogress_ops(void);\n\n \nvoid purge_waiting_ops(void);\n\n \nextern uint64_t orangefs_features;\n\nstruct dentry *orangefs_mount(struct file_system_type *fst,\n\t\t\t   int flags,\n\t\t\t   const char *devname,\n\t\t\t   void *data);\n\nvoid orangefs_kill_sb(struct super_block *sb);\nint orangefs_remount(struct orangefs_sb_info_s *);\n\nint fsid_key_table_initialize(void);\nvoid fsid_key_table_finalize(void);\n\n \nvm_fault_t orangefs_page_mkwrite(struct vm_fault *);\nstruct inode *orangefs_new_inode(struct super_block *sb,\n\t\t\t      struct inode *dir,\n\t\t\t      umode_t mode,\n\t\t\t      dev_t dev,\n\t\t\t      struct orangefs_object_kref *ref);\n\nint __orangefs_setattr(struct inode *, struct iattr *);\nint __orangefs_setattr_mode(struct dentry *dentry, struct iattr *iattr);\nint orangefs_setattr(struct mnt_idmap *, struct dentry *, struct iattr *);\n\nint orangefs_getattr(struct mnt_idmap *idmap, const struct path *path,\n\t\t     struct kstat *stat, u32 request_mask, unsigned int flags);\n\nint orangefs_permission(struct mnt_idmap *idmap,\n\t\t\tstruct inode *inode, int mask);\n\nint orangefs_update_time(struct inode *, int);\n\n \nssize_t orangefs_listxattr(struct dentry *dentry, char *buffer, size_t size);\n\n \nstruct inode *orangefs_iget(struct super_block *sb,\n\t\t\t struct orangefs_object_kref *ref);\n\n \nextern uint32_t orangefs_userspace_version;\n\nint orangefs_dev_init(void);\nvoid orangefs_dev_cleanup(void);\nint is_daemon_in_service(void);\nbool __is_daemon_in_service(void);\n\n \nint orangefs_revalidate_mapping(struct inode *);\nssize_t wait_for_direct_io(enum ORANGEFS_io_type, struct inode *, loff_t *,\n    struct iov_iter *, size_t, loff_t, struct orangefs_write_range *, int *,\n    struct file *);\nssize_t do_readv_writev(enum ORANGEFS_io_type, struct file *, loff_t *,\n    struct iov_iter *);\n\n \n__s32 fsid_of_op(struct orangefs_kernel_op_s *op);\n\nssize_t orangefs_inode_getxattr(struct inode *inode,\n\t\t\t     const char *name,\n\t\t\t     void *buffer,\n\t\t\t     size_t size);\n\nint orangefs_inode_setxattr(struct inode *inode,\n\t\t\t const char *name,\n\t\t\t const void *value,\n\t\t\t size_t size,\n\t\t\t int flags);\n\n#define ORANGEFS_GETATTR_NEW 1\n#define ORANGEFS_GETATTR_SIZE 2\n\nint orangefs_inode_getattr(struct inode *, int);\n\nint orangefs_inode_check_changed(struct inode *inode);\n\nint orangefs_inode_setattr(struct inode *inode);\n\nbool orangefs_cancel_op_in_progress(struct orangefs_kernel_op_s *op);\n\nint orangefs_normalize_to_errno(__s32 error_code);\n\nextern struct mutex orangefs_request_mutex;\nextern int op_timeout_secs;\nextern int slot_timeout_secs;\nextern int orangefs_cache_timeout_msecs;\nextern int orangefs_dcache_timeout_msecs;\nextern int orangefs_getattr_timeout_msecs;\nextern struct list_head orangefs_superblocks;\nextern spinlock_t orangefs_superblocks_lock;\nextern struct list_head orangefs_request_list;\nextern spinlock_t orangefs_request_list_lock;\nextern wait_queue_head_t orangefs_request_list_waitq;\nextern struct list_head *orangefs_htable_ops_in_progress;\nextern spinlock_t orangefs_htable_ops_in_progress_lock;\nextern int hash_table_size;\n\nextern const struct file_operations orangefs_file_operations;\nextern const struct inode_operations orangefs_symlink_inode_operations;\nextern const struct inode_operations orangefs_dir_inode_operations;\nextern const struct file_operations orangefs_dir_operations;\nextern const struct dentry_operations orangefs_dentry_operations;\n\n \n\n#define ORANGEFS_OP_INTERRUPTIBLE 1    \n#define ORANGEFS_OP_PRIORITY      2    \n#define ORANGEFS_OP_CANCELLATION  4    \n#define ORANGEFS_OP_NO_MUTEX      8    \n#define ORANGEFS_OP_ASYNC         16   \n#define ORANGEFS_OP_WRITEBACK     32\n\nint service_operation(struct orangefs_kernel_op_s *op,\n\t\t      const char *op_name,\n\t\t      int flags);\n\n#define get_interruptible_flag(inode) \\\n\t((ORANGEFS_SB(inode->i_sb)->flags & ORANGEFS_OPT_INTR) ? \\\n\t\tORANGEFS_OP_INTERRUPTIBLE : 0)\n\n#define fill_default_sys_attrs(sys_attr, type, mode)\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tsys_attr.owner = from_kuid(&init_user_ns, current_fsuid()); \\\n\tsys_attr.group = from_kgid(&init_user_ns, current_fsgid()); \\\n\tsys_attr.perms = ORANGEFS_util_translate_mode(mode);\t\t\\\n\tsys_attr.mtime = 0;\t\t\t\t\t\t\\\n\tsys_attr.atime = 0;\t\t\t\t\t\t\\\n\tsys_attr.ctime = 0;\t\t\t\t\t\t\\\n\tsys_attr.mask = ORANGEFS_ATTR_SYS_ALL_SETABLE;\t\t\t\\\n} while (0)\n\nstatic inline void orangefs_set_timeout(struct dentry *dentry)\n{\n\tunsigned long time = jiffies + orangefs_dcache_timeout_msecs*HZ/1000;\n\n\tdentry->d_fsdata = (void *) time;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}