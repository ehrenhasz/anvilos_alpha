{
  "module_name": "orangefs-bufmap.c",
  "hash_id": "b9b501088f428755bda61b2b6f6f95dca48b9dca6f19c085850eccb3a1dba6e9",
  "original_prompt": "Ingested from linux-6.6.14/fs/orangefs/orangefs-bufmap.c",
  "human_readable_source": "\n \n#include \"protocol.h\"\n#include \"orangefs-kernel.h\"\n#include \"orangefs-bufmap.h\"\n\nstruct slot_map {\n\tint c;\n\twait_queue_head_t q;\n\tint count;\n\tunsigned long *map;\n};\n\nstatic struct slot_map rw_map = {\n\t.c = -1,\n\t.q = __WAIT_QUEUE_HEAD_INITIALIZER(rw_map.q)\n};\nstatic struct slot_map readdir_map = {\n\t.c = -1,\n\t.q = __WAIT_QUEUE_HEAD_INITIALIZER(readdir_map.q)\n};\n\n\nstatic void install(struct slot_map *m, int count, unsigned long *map)\n{\n\tspin_lock(&m->q.lock);\n\tm->c = m->count = count;\n\tm->map = map;\n\twake_up_all_locked(&m->q);\n\tspin_unlock(&m->q.lock);\n}\n\nstatic void mark_killed(struct slot_map *m)\n{\n\tspin_lock(&m->q.lock);\n\tm->c -= m->count + 1;\n\tspin_unlock(&m->q.lock);\n}\n\nstatic void run_down(struct slot_map *m)\n{\n\tDEFINE_WAIT(wait);\n\tspin_lock(&m->q.lock);\n\tif (m->c != -1) {\n\t\tfor (;;) {\n\t\t\tif (likely(list_empty(&wait.entry)))\n\t\t\t\t__add_wait_queue_entry_tail(&m->q, &wait);\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\n\t\t\tif (m->c == -1)\n\t\t\t\tbreak;\n\n\t\t\tspin_unlock(&m->q.lock);\n\t\t\tschedule();\n\t\t\tspin_lock(&m->q.lock);\n\t\t}\n\t\t__remove_wait_queue(&m->q, &wait);\n\t\t__set_current_state(TASK_RUNNING);\n\t}\n\tm->map = NULL;\n\tspin_unlock(&m->q.lock);\n}\n\nstatic void put(struct slot_map *m, int slot)\n{\n\tint v;\n\tspin_lock(&m->q.lock);\n\t__clear_bit(slot, m->map);\n\tv = ++m->c;\n\tif (v > 0)\n\t\twake_up_locked(&m->q);\n\tif (unlikely(v == -1))      \n\t\twake_up_all_locked(&m->q);\n\tspin_unlock(&m->q.lock);\n}\n\nstatic int wait_for_free(struct slot_map *m)\n{\n\tlong left = slot_timeout_secs * HZ;\n\tDEFINE_WAIT(wait);\n\n\tdo {\n\t\tlong n = left, t;\n\t\tif (likely(list_empty(&wait.entry)))\n\t\t\t__add_wait_queue_entry_tail_exclusive(&m->q, &wait);\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t\tif (m->c > 0)\n\t\t\tbreak;\n\n\t\tif (m->c < 0) {\n\t\t\t \n\t\t\t \n\t\t\tif (n > ORANGEFS_BUFMAP_WAIT_TIMEOUT_SECS * HZ)\n\t\t\t\tn = ORANGEFS_BUFMAP_WAIT_TIMEOUT_SECS * HZ;\n\t\t}\n\t\tspin_unlock(&m->q.lock);\n\t\tt = schedule_timeout(n);\n\t\tspin_lock(&m->q.lock);\n\t\tif (unlikely(!t) && n != left && m->c < 0)\n\t\t\tleft = t;\n\t\telse\n\t\t\tleft = t + (left - n);\n\t\tif (signal_pending(current))\n\t\t\tleft = -EINTR;\n\t} while (left > 0);\n\n\tif (!list_empty(&wait.entry))\n\t\tlist_del(&wait.entry);\n\telse if (left <= 0 && waitqueue_active(&m->q))\n\t\t__wake_up_locked_key(&m->q, TASK_INTERRUPTIBLE, NULL);\n\t__set_current_state(TASK_RUNNING);\n\n\tif (likely(left > 0))\n\t\treturn 0;\n\n\treturn left < 0 ? -EINTR : -ETIMEDOUT;\n}\n\nstatic int get(struct slot_map *m)\n{\n\tint res = 0;\n\tspin_lock(&m->q.lock);\n\tif (unlikely(m->c <= 0))\n\t\tres = wait_for_free(m);\n\tif (likely(!res)) {\n\t\tm->c--;\n\t\tres = find_first_zero_bit(m->map, m->count);\n\t\t__set_bit(res, m->map);\n\t}\n\tspin_unlock(&m->q.lock);\n\treturn res;\n}\n\n \nstruct orangefs_bufmap_desc {\n\tvoid __user *uaddr;\t\t \n\tstruct page **page_array;\t \n\tint array_count;\t\t \n\tstruct list_head list_link;\n};\n\nstatic struct orangefs_bufmap {\n\tint desc_size;\n\tint desc_shift;\n\tint desc_count;\n\tint total_size;\n\tint page_count;\n\n\tstruct page **page_array;\n\tstruct orangefs_bufmap_desc *desc_array;\n\n\t \n\tunsigned long *buffer_index_array;\n\n\t \n#define N DIV_ROUND_UP(ORANGEFS_READDIR_DEFAULT_DESC_COUNT, BITS_PER_LONG)\n\tunsigned long readdir_index_array[N];\n#undef N\n} *__orangefs_bufmap;\n\nstatic DEFINE_SPINLOCK(orangefs_bufmap_lock);\n\nstatic void\norangefs_bufmap_unmap(struct orangefs_bufmap *bufmap)\n{\n\tunpin_user_pages(bufmap->page_array, bufmap->page_count);\n}\n\nstatic void\norangefs_bufmap_free(struct orangefs_bufmap *bufmap)\n{\n\tkfree(bufmap->page_array);\n\tkfree(bufmap->desc_array);\n\tbitmap_free(bufmap->buffer_index_array);\n\tkfree(bufmap);\n}\n\n \n\nint orangefs_bufmap_size_query(void)\n{\n\tstruct orangefs_bufmap *bufmap;\n\tint size = 0;\n\tspin_lock(&orangefs_bufmap_lock);\n\tbufmap = __orangefs_bufmap;\n\tif (bufmap)\n\t\tsize = bufmap->desc_size;\n\tspin_unlock(&orangefs_bufmap_lock);\n\treturn size;\n}\n\nint orangefs_bufmap_shift_query(void)\n{\n\tstruct orangefs_bufmap *bufmap;\n\tint shift = 0;\n\tspin_lock(&orangefs_bufmap_lock);\n\tbufmap = __orangefs_bufmap;\n\tif (bufmap)\n\t\tshift = bufmap->desc_shift;\n\tspin_unlock(&orangefs_bufmap_lock);\n\treturn shift;\n}\n\nstatic DECLARE_WAIT_QUEUE_HEAD(bufmap_waitq);\nstatic DECLARE_WAIT_QUEUE_HEAD(readdir_waitq);\n\nstatic struct orangefs_bufmap *\norangefs_bufmap_alloc(struct ORANGEFS_dev_map_desc *user_desc)\n{\n\tstruct orangefs_bufmap *bufmap;\n\n\tbufmap = kzalloc(sizeof(*bufmap), GFP_KERNEL);\n\tif (!bufmap)\n\t\tgoto out;\n\n\tbufmap->total_size = user_desc->total_size;\n\tbufmap->desc_count = user_desc->count;\n\tbufmap->desc_size = user_desc->size;\n\tbufmap->desc_shift = ilog2(bufmap->desc_size);\n\n\tbufmap->buffer_index_array = bitmap_zalloc(bufmap->desc_count, GFP_KERNEL);\n\tif (!bufmap->buffer_index_array)\n\t\tgoto out_free_bufmap;\n\n\tbufmap->desc_array =\n\t\tkcalloc(bufmap->desc_count, sizeof(struct orangefs_bufmap_desc),\n\t\t\tGFP_KERNEL);\n\tif (!bufmap->desc_array)\n\t\tgoto out_free_index_array;\n\n\tbufmap->page_count = bufmap->total_size / PAGE_SIZE;\n\n\t \n\tbufmap->page_array =\n\t\tkcalloc(bufmap->page_count, sizeof(struct page *), GFP_KERNEL);\n\tif (!bufmap->page_array)\n\t\tgoto out_free_desc_array;\n\n\treturn bufmap;\n\nout_free_desc_array:\n\tkfree(bufmap->desc_array);\nout_free_index_array:\n\tbitmap_free(bufmap->buffer_index_array);\nout_free_bufmap:\n\tkfree(bufmap);\nout:\n\treturn NULL;\n}\n\nstatic int\norangefs_bufmap_map(struct orangefs_bufmap *bufmap,\n\t\tstruct ORANGEFS_dev_map_desc *user_desc)\n{\n\tint pages_per_desc = bufmap->desc_size / PAGE_SIZE;\n\tint offset = 0, ret, i;\n\n\t \n\tret = pin_user_pages_fast((unsigned long)user_desc->ptr,\n\t\t\t     bufmap->page_count, FOLL_WRITE, bufmap->page_array);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret != bufmap->page_count) {\n\t\tgossip_err(\"orangefs error: asked for %d pages, only got %d.\\n\",\n\t\t\t\tbufmap->page_count, ret);\n\n\t\tfor (i = 0; i < ret; i++) {\n\t\t\tSetPageError(bufmap->page_array[i]);\n\t\t\tunpin_user_page(bufmap->page_array[i]);\n\t\t}\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tfor (i = 0; i < bufmap->page_count; i++)\n\t\tflush_dcache_page(bufmap->page_array[i]);\n\n\t \n\tfor (offset = 0, i = 0; i < bufmap->desc_count; i++) {\n\t\tbufmap->desc_array[i].page_array = &bufmap->page_array[offset];\n\t\tbufmap->desc_array[i].array_count = pages_per_desc;\n\t\tbufmap->desc_array[i].uaddr =\n\t\t    (user_desc->ptr + (i * pages_per_desc * PAGE_SIZE));\n\t\toffset += pages_per_desc;\n\t}\n\n\treturn 0;\n}\n\n \nint orangefs_bufmap_initialize(struct ORANGEFS_dev_map_desc *user_desc)\n{\n\tstruct orangefs_bufmap *bufmap;\n\tint ret = -EINVAL;\n\n\tgossip_debug(GOSSIP_BUFMAP_DEBUG,\n\t\t     \"orangefs_bufmap_initialize: called (ptr (\"\n\t\t     \"%p) sz (%d) cnt(%d).\\n\",\n\t\t     user_desc->ptr,\n\t\t     user_desc->size,\n\t\t     user_desc->count);\n\n\tif (user_desc->total_size < 0 ||\n\t    user_desc->size < 0 ||\n\t    user_desc->count < 0)\n\t\tgoto out;\n\n\t \n\tif (PAGE_ALIGN((unsigned long)user_desc->ptr) !=\n\t    (unsigned long)user_desc->ptr) {\n\t\tgossip_err(\"orangefs error: memory alignment (front). %p\\n\",\n\t\t\t   user_desc->ptr);\n\t\tgoto out;\n\t}\n\n\tif (PAGE_ALIGN(((unsigned long)user_desc->ptr + user_desc->total_size))\n\t    != (unsigned long)(user_desc->ptr + user_desc->total_size)) {\n\t\tgossip_err(\"orangefs error: memory alignment (back).(%p + %d)\\n\",\n\t\t\t   user_desc->ptr,\n\t\t\t   user_desc->total_size);\n\t\tgoto out;\n\t}\n\n\tif (user_desc->total_size != (user_desc->size * user_desc->count)) {\n\t\tgossip_err(\"orangefs error: user provided an oddly sized buffer: (%d, %d, %d)\\n\",\n\t\t\t   user_desc->total_size,\n\t\t\t   user_desc->size,\n\t\t\t   user_desc->count);\n\t\tgoto out;\n\t}\n\n\tif ((user_desc->size % PAGE_SIZE) != 0) {\n\t\tgossip_err(\"orangefs error: bufmap size not page size divisible (%d).\\n\",\n\t\t\t   user_desc->size);\n\t\tgoto out;\n\t}\n\n\tret = -ENOMEM;\n\tbufmap = orangefs_bufmap_alloc(user_desc);\n\tif (!bufmap)\n\t\tgoto out;\n\n\tret = orangefs_bufmap_map(bufmap, user_desc);\n\tif (ret)\n\t\tgoto out_free_bufmap;\n\n\n\tspin_lock(&orangefs_bufmap_lock);\n\tif (__orangefs_bufmap) {\n\t\tspin_unlock(&orangefs_bufmap_lock);\n\t\tgossip_err(\"orangefs: error: bufmap already initialized.\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_unmap_bufmap;\n\t}\n\t__orangefs_bufmap = bufmap;\n\tinstall(&rw_map,\n\t\tbufmap->desc_count,\n\t\tbufmap->buffer_index_array);\n\tinstall(&readdir_map,\n\t\tORANGEFS_READDIR_DEFAULT_DESC_COUNT,\n\t\tbufmap->readdir_index_array);\n\tspin_unlock(&orangefs_bufmap_lock);\n\n\tgossip_debug(GOSSIP_BUFMAP_DEBUG,\n\t\t     \"orangefs_bufmap_initialize: exiting normally\\n\");\n\treturn 0;\n\nout_unmap_bufmap:\n\torangefs_bufmap_unmap(bufmap);\nout_free_bufmap:\n\torangefs_bufmap_free(bufmap);\nout:\n\treturn ret;\n}\n\n \nvoid orangefs_bufmap_finalize(void)\n{\n\tstruct orangefs_bufmap *bufmap = __orangefs_bufmap;\n\tif (!bufmap)\n\t\treturn;\n\tgossip_debug(GOSSIP_BUFMAP_DEBUG, \"orangefs_bufmap_finalize: called\\n\");\n\tmark_killed(&rw_map);\n\tmark_killed(&readdir_map);\n\tgossip_debug(GOSSIP_BUFMAP_DEBUG,\n\t\t     \"orangefs_bufmap_finalize: exiting normally\\n\");\n}\n\nvoid orangefs_bufmap_run_down(void)\n{\n\tstruct orangefs_bufmap *bufmap = __orangefs_bufmap;\n\tif (!bufmap)\n\t\treturn;\n\trun_down(&rw_map);\n\trun_down(&readdir_map);\n\tspin_lock(&orangefs_bufmap_lock);\n\t__orangefs_bufmap = NULL;\n\tspin_unlock(&orangefs_bufmap_lock);\n\torangefs_bufmap_unmap(bufmap);\n\torangefs_bufmap_free(bufmap);\n}\n\n \nint orangefs_bufmap_get(void)\n{\n\treturn get(&rw_map);\n}\n\n \nvoid orangefs_bufmap_put(int buffer_index)\n{\n\tput(&rw_map, buffer_index);\n}\n\n \nint orangefs_readdir_index_get(void)\n{\n\treturn get(&readdir_map);\n}\n\nvoid orangefs_readdir_index_put(int buffer_index)\n{\n\tput(&readdir_map, buffer_index);\n}\n\n \nint orangefs_bufmap_copy_from_iovec(struct iov_iter *iter,\n\t\t\t\tint buffer_index,\n\t\t\t\tsize_t size)\n{\n\tstruct orangefs_bufmap_desc *to;\n\tint i;\n\n\tgossip_debug(GOSSIP_BUFMAP_DEBUG,\n\t\t     \"%s: buffer_index:%d: size:%zu:\\n\",\n\t\t     __func__, buffer_index, size);\n\n\tto = &__orangefs_bufmap->desc_array[buffer_index];\n\tfor (i = 0; size; i++) {\n\t\tstruct page *page = to->page_array[i];\n\t\tsize_t n = size;\n\t\tif (n > PAGE_SIZE)\n\t\t\tn = PAGE_SIZE;\n\t\tif (copy_page_from_iter(page, 0, n, iter) != n)\n\t\t\treturn -EFAULT;\n\t\tsize -= n;\n\t}\n\treturn 0;\n}\n\n \nint orangefs_bufmap_copy_to_iovec(struct iov_iter *iter,\n\t\t\t\t    int buffer_index,\n\t\t\t\t    size_t size)\n{\n\tstruct orangefs_bufmap_desc *from;\n\tint i;\n\n\tfrom = &__orangefs_bufmap->desc_array[buffer_index];\n\tgossip_debug(GOSSIP_BUFMAP_DEBUG,\n\t\t     \"%s: buffer_index:%d: size:%zu:\\n\",\n\t\t     __func__, buffer_index, size);\n\n\n\tfor (i = 0; size; i++) {\n\t\tstruct page *page = from->page_array[i];\n\t\tsize_t n = size;\n\t\tif (n > PAGE_SIZE)\n\t\t\tn = PAGE_SIZE;\n\t\tn = copy_page_to_iter(page, 0, n, iter);\n\t\tif (!n)\n\t\t\treturn -EFAULT;\n\t\tsize -= n;\n\t}\n\treturn 0;\n}\n\nvoid orangefs_bufmap_page_fill(void *page_to,\n\t\t\t\tint buffer_index,\n\t\t\t\tint slot_index)\n{\n\tstruct orangefs_bufmap_desc *from;\n\tvoid *page_from;\n\n\tfrom = &__orangefs_bufmap->desc_array[buffer_index];\n\tpage_from = kmap_atomic(from->page_array[slot_index]);\n\tmemcpy(page_to, page_from, PAGE_SIZE);\n\tkunmap_atomic(page_from);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}