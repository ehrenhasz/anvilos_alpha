{
  "module_name": "file.c",
  "hash_id": "6007cf15d4bf64212d4cac1bc9aead1f2d4d2f83214a3cead1500e395fcf33c1",
  "original_prompt": "Ingested from linux-6.6.14/fs/orangefs/file.c",
  "human_readable_source": "\n \n\n \n\n#include \"protocol.h\"\n#include \"orangefs-kernel.h\"\n#include \"orangefs-bufmap.h\"\n#include <linux/fs.h>\n#include <linux/filelock.h>\n#include <linux/pagemap.h>\n\nstatic int flush_racache(struct inode *inode)\n{\n\tstruct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);\n\tstruct orangefs_kernel_op_s *new_op;\n\tint ret;\n\n\tgossip_debug(GOSSIP_UTILS_DEBUG,\n\t    \"%s: %pU: Handle is %pU | fs_id %d\\n\", __func__,\n\t    get_khandle_from_ino(inode), &orangefs_inode->refn.khandle,\n\t    orangefs_inode->refn.fs_id);\n\n\tnew_op = op_alloc(ORANGEFS_VFS_OP_RA_FLUSH);\n\tif (!new_op)\n\t\treturn -ENOMEM;\n\tnew_op->upcall.req.ra_cache_flush.refn = orangefs_inode->refn;\n\n\tret = service_operation(new_op, \"orangefs_flush_racache\",\n\t    get_interruptible_flag(inode));\n\n\tgossip_debug(GOSSIP_UTILS_DEBUG, \"%s: got return value of %d\\n\",\n\t    __func__, ret);\n\n\top_release(new_op);\n\treturn ret;\n}\n\n \nssize_t wait_for_direct_io(enum ORANGEFS_io_type type, struct inode *inode,\n\tloff_t *offset, struct iov_iter *iter, size_t total_size,\n\tloff_t readahead_size, struct orangefs_write_range *wr,\n\tint *index_return, struct file *file)\n{\n\tstruct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);\n\tstruct orangefs_khandle *handle = &orangefs_inode->refn.khandle;\n\tstruct orangefs_kernel_op_s *new_op = NULL;\n\tint buffer_index;\n\tssize_t ret;\n\tsize_t copy_amount;\n\tint open_for_read;\n\tint open_for_write;\n\n\tnew_op = op_alloc(ORANGEFS_VFS_OP_FILE_IO);\n\tif (!new_op)\n\t\treturn -ENOMEM;\n\n\t \n\tnew_op->upcall.req.io.readahead_size = readahead_size;\n\tnew_op->upcall.req.io.io_type = type;\n\tnew_op->upcall.req.io.refn = orangefs_inode->refn;\n\npopulate_shared_memory:\n\t \n\tbuffer_index = orangefs_bufmap_get();\n\tif (buffer_index < 0) {\n\t\tret = buffer_index;\n\t\tgossip_debug(GOSSIP_FILE_DEBUG,\n\t\t\t     \"%s: orangefs_bufmap_get failure (%zd)\\n\",\n\t\t\t     __func__, ret);\n\t\tgoto out;\n\t}\n\tgossip_debug(GOSSIP_FILE_DEBUG,\n\t\t     \"%s(%pU): GET op %p -> buffer_index %d\\n\",\n\t\t     __func__,\n\t\t     handle,\n\t\t     new_op,\n\t\t     buffer_index);\n\n\tnew_op->uses_shared_memory = 1;\n\tnew_op->upcall.req.io.buf_index = buffer_index;\n\tnew_op->upcall.req.io.count = total_size;\n\tnew_op->upcall.req.io.offset = *offset;\n\tif (type == ORANGEFS_IO_WRITE && wr) {\n\t\tnew_op->upcall.uid = from_kuid(&init_user_ns, wr->uid);\n\t\tnew_op->upcall.gid = from_kgid(&init_user_ns, wr->gid);\n\t}\n\t \n\tif (file) {\n\t\topen_for_write = file->f_mode & FMODE_WRITE;\n\t\topen_for_read = file->f_mode & FMODE_READ;\n\t} else {\n\t\topen_for_write = 1;\n\t\topen_for_read = 0;  \n\t}\n\tif ((type == ORANGEFS_IO_WRITE) && open_for_write)\n\t\tnew_op->upcall.uid = 0;\n\tif ((type == ORANGEFS_IO_READ) && open_for_read)\n\t\tnew_op->upcall.uid = 0;\n\n\tgossip_debug(GOSSIP_FILE_DEBUG,\n\t\t     \"%s(%pU): offset: %llu total_size: %zd\\n\",\n\t\t     __func__,\n\t\t     handle,\n\t\t     llu(*offset),\n\t\t     total_size);\n\t \n\tif (type == ORANGEFS_IO_WRITE && total_size) {\n\t\tret = orangefs_bufmap_copy_from_iovec(iter, buffer_index,\n\t\t    total_size);\n\t\tif (ret < 0) {\n\t\t\tgossip_err(\"%s: Failed to copy-in buffers. Please make sure that the pvfs2-client is running. %ld\\n\",\n\t\t\t    __func__, (long)ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tgossip_debug(GOSSIP_FILE_DEBUG,\n\t\t     \"%s(%pU): Calling post_io_request with tag (%llu)\\n\",\n\t\t     __func__,\n\t\t     handle,\n\t\t     llu(new_op->tag));\n\n\t \n\tret = service_operation(new_op,\n\t\t\t\ttype == ORANGEFS_IO_WRITE ?\n\t\t\t\t\t\"file_write\" :\n\t\t\t\t\t\"file_read\",\n\t\t\t\tget_interruptible_flag(inode));\n\n\t \n\tif (ret == -EAGAIN && op_state_purged(new_op)) {\n\t\torangefs_bufmap_put(buffer_index);\n\t\tif (type == ORANGEFS_IO_WRITE)\n\t\t\tiov_iter_revert(iter, total_size);\n\t\tgossip_debug(GOSSIP_FILE_DEBUG,\n\t\t\t     \"%s:going to repopulate_shared_memory.\\n\",\n\t\t\t     __func__);\n\t\tgoto populate_shared_memory;\n\t}\n\n\tif (ret < 0) {\n\t\tif (ret == -EINTR) {\n\t\t\t \n\t\t\tswitch (new_op->op_state - OP_VFS_STATE_GIVEN_UP) {\n\t\t\t \n\t\t\tcase OP_VFS_STATE_WAITING:\n\t\t\t\tif (*offset == 0)\n\t\t\t\t\tret = -EINTR;\n\t\t\t\telse\n\t\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tcase OP_VFS_STATE_INPROGR:\n\t\t\t\tif (type == ORANGEFS_IO_READ)\n\t\t\t\t\tret = -EINTR;\n\t\t\t\telse\n\t\t\t\t\tret = total_size;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgossip_err(\"%s: unexpected op state :%d:.\\n\",\n\t\t\t\t\t   __func__,\n\t\t\t\t\t   new_op->op_state);\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgossip_debug(GOSSIP_FILE_DEBUG,\n\t\t\t\t     \"%s: got EINTR, state:%d: %p\\n\",\n\t\t\t\t     __func__,\n\t\t\t\t     new_op->op_state,\n\t\t\t\t     new_op);\n\t\t} else {\n\t\t\tgossip_err(\"%s: error in %s handle %pU, returning %zd\\n\",\n\t\t\t\t__func__,\n\t\t\t\ttype == ORANGEFS_IO_READ ?\n\t\t\t\t\t\"read from\" : \"write to\",\n\t\t\t\thandle, ret);\n\t\t}\n\t\tif (orangefs_cancel_op_in_progress(new_op))\n\t\t\treturn ret;\n\n\t\tgoto out;\n\t}\n\n\t \n\tif (type == ORANGEFS_IO_READ && new_op->downcall.resp.io.amt_complete) {\n\t\t \n\n\t\tcopy_amount = new_op->downcall.resp.io.amt_complete;\n\n\t\tret = orangefs_bufmap_copy_to_iovec(iter, buffer_index,\n\t\t\tcopy_amount);\n\t\tif (ret < 0) {\n\t\t\tgossip_err(\"%s: Failed to copy-out buffers. Please make sure that the pvfs2-client is running (%ld)\\n\",\n\t\t\t    __func__, (long)ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tgossip_debug(GOSSIP_FILE_DEBUG,\n\t    \"%s(%pU): Amount %s, returned by the sys-io call:%d\\n\",\n\t    __func__,\n\t    handle,\n\t    type == ORANGEFS_IO_READ ?  \"read\" : \"written\",\n\t    (int)new_op->downcall.resp.io.amt_complete);\n\n\tret = new_op->downcall.resp.io.amt_complete;\n\nout:\n\tif (buffer_index >= 0) {\n\t\torangefs_bufmap_put(buffer_index);\n\t\tgossip_debug(GOSSIP_FILE_DEBUG,\n\t\t\t\"%s(%pU): PUT buffer_index %d\\n\",\n\t\t\t__func__, handle, buffer_index);\n\t}\n\top_release(new_op);\n\treturn ret;\n}\n\nint orangefs_revalidate_mapping(struct inode *inode)\n{\n\tstruct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);\n\tstruct address_space *mapping = inode->i_mapping;\n\tunsigned long *bitlock = &orangefs_inode->bitlock;\n\tint ret;\n\n\twhile (1) {\n\t\tret = wait_on_bit(bitlock, 1, TASK_KILLABLE);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tspin_lock(&inode->i_lock);\n\t\tif (test_bit(1, bitlock)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!time_before(jiffies, orangefs_inode->mapping_time))\n\t\t\tbreak;\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn 0;\n\t}\n\n\tset_bit(1, bitlock);\n\tsmp_wmb();\n\tspin_unlock(&inode->i_lock);\n\n\tunmap_mapping_range(mapping, 0, 0, 0);\n\tret = filemap_write_and_wait(mapping);\n\tif (!ret)\n\t\tret = invalidate_inode_pages2(mapping);\n\n\torangefs_inode->mapping_time = jiffies +\n\t    orangefs_cache_timeout_msecs*HZ/1000;\n\n\tclear_bit(1, bitlock);\n\tsmp_mb__after_atomic();\n\twake_up_bit(bitlock, 1);\n\n\treturn ret;\n}\n\nstatic ssize_t orangefs_file_read_iter(struct kiocb *iocb,\n    struct iov_iter *iter)\n{\n\tint ret;\n\torangefs_stats.reads++;\n\n\tdown_read(&file_inode(iocb->ki_filp)->i_rwsem);\n\tret = orangefs_revalidate_mapping(file_inode(iocb->ki_filp));\n\tif (ret)\n\t\tgoto out;\n\n\tret = generic_file_read_iter(iocb, iter);\nout:\n\tup_read(&file_inode(iocb->ki_filp)->i_rwsem);\n\treturn ret;\n}\n\nstatic ssize_t orangefs_file_splice_read(struct file *in, loff_t *ppos,\n\t\t\t\t\t struct pipe_inode_info *pipe,\n\t\t\t\t\t size_t len, unsigned int flags)\n{\n\tstruct inode *inode = file_inode(in);\n\tssize_t ret;\n\n\torangefs_stats.reads++;\n\n\tdown_read(&inode->i_rwsem);\n\tret = orangefs_revalidate_mapping(inode);\n\tif (ret)\n\t\tgoto out;\n\n\tret = filemap_splice_read(in, ppos, pipe, len, flags);\nout:\n\tup_read(&inode->i_rwsem);\n\treturn ret;\n}\n\nstatic ssize_t orangefs_file_write_iter(struct kiocb *iocb,\n    struct iov_iter *iter)\n{\n\tint ret;\n\torangefs_stats.writes++;\n\n\tif (iocb->ki_pos > i_size_read(file_inode(iocb->ki_filp))) {\n\t\tret = orangefs_revalidate_mapping(file_inode(iocb->ki_filp));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = generic_file_write_iter(iocb, iter);\n\treturn ret;\n}\n\nstatic vm_fault_t orangefs_fault(struct vm_fault *vmf)\n{\n\tstruct file *file = vmf->vma->vm_file;\n\tint ret;\n\tret = orangefs_inode_getattr(file->f_mapping->host,\n\t    ORANGEFS_GETATTR_SIZE);\n\tif (ret == -ESTALE)\n\t\tret = -EIO;\n\tif (ret) {\n\t\tgossip_err(\"%s: orangefs_inode_getattr failed, \"\n\t\t    \"ret:%d:.\\n\", __func__, ret);\n\t\treturn VM_FAULT_SIGBUS;\n\t}\n\treturn filemap_fault(vmf);\n}\n\nstatic const struct vm_operations_struct orangefs_file_vm_ops = {\n\t.fault = orangefs_fault,\n\t.map_pages = filemap_map_pages,\n\t.page_mkwrite = orangefs_page_mkwrite,\n};\n\n \nstatic int orangefs_file_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tint ret;\n\n\tret = orangefs_revalidate_mapping(file_inode(file));\n\tif (ret)\n\t\treturn ret;\n\n\tgossip_debug(GOSSIP_FILE_DEBUG,\n\t\t     \"orangefs_file_mmap: called on %pD\\n\", file);\n\n\t \n\tvm_flags_mod(vma, VM_SEQ_READ, VM_RAND_READ);\n\n\tfile_accessed(file);\n\tvma->vm_ops = &orangefs_file_vm_ops;\n\treturn 0;\n}\n\n#define mapping_nrpages(idata) ((idata)->nrpages)\n\n \nstatic int orangefs_file_release(struct inode *inode, struct file *file)\n{\n\tgossip_debug(GOSSIP_FILE_DEBUG,\n\t\t     \"orangefs_file_release: called on %pD\\n\",\n\t\t     file);\n\n\t \n\tif (mapping_nrpages(file->f_mapping)) {\n\t\tif (orangefs_features & ORANGEFS_FEATURE_READAHEAD) {\n\t\t\tgossip_debug(GOSSIP_INODE_DEBUG,\n\t\t\t    \"calling flush_racache on %pU\\n\",\n\t\t\t    get_khandle_from_ino(inode));\n\t\t\tflush_racache(inode);\n\t\t\tgossip_debug(GOSSIP_INODE_DEBUG,\n\t\t\t    \"flush_racache finished\\n\");\n\t\t}\n\n\t}\n\treturn 0;\n}\n\n \nstatic int orangefs_fsync(struct file *file,\n\t\t       loff_t start,\n\t\t       loff_t end,\n\t\t       int datasync)\n{\n\tint ret;\n\tstruct orangefs_inode_s *orangefs_inode =\n\t\tORANGEFS_I(file_inode(file));\n\tstruct orangefs_kernel_op_s *new_op = NULL;\n\n\tret = filemap_write_and_wait_range(file_inode(file)->i_mapping,\n\t    start, end);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tnew_op = op_alloc(ORANGEFS_VFS_OP_FSYNC);\n\tif (!new_op)\n\t\treturn -ENOMEM;\n\tnew_op->upcall.req.fsync.refn = orangefs_inode->refn;\n\n\tret = service_operation(new_op,\n\t\t\t\"orangefs_fsync\",\n\t\t\tget_interruptible_flag(file_inode(file)));\n\n\tgossip_debug(GOSSIP_FILE_DEBUG,\n\t\t     \"orangefs_fsync got return value of %d\\n\",\n\t\t     ret);\n\n\top_release(new_op);\n\treturn ret;\n}\n\n \nstatic loff_t orangefs_file_llseek(struct file *file, loff_t offset, int origin)\n{\n\tint ret = -EINVAL;\n\tstruct inode *inode = file_inode(file);\n\n\tif (origin == SEEK_END) {\n\t\t \n\t\tret = orangefs_inode_getattr(file->f_mapping->host,\n\t\t    ORANGEFS_GETATTR_SIZE);\n\t\tif (ret == -ESTALE)\n\t\t\tret = -EIO;\n\t\tif (ret) {\n\t\t\tgossip_debug(GOSSIP_FILE_DEBUG,\n\t\t\t\t     \"%s:%s:%d calling make bad inode\\n\",\n\t\t\t\t     __FILE__,\n\t\t\t\t     __func__,\n\t\t\t\t     __LINE__);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tgossip_debug(GOSSIP_FILE_DEBUG,\n\t\t     \"orangefs_file_llseek: offset is %ld | origin is %d\"\n\t\t     \" | inode size is %lu\\n\",\n\t\t     (long)offset,\n\t\t     origin,\n\t\t     (unsigned long)i_size_read(inode));\n\n\treturn generic_file_llseek(file, offset, origin);\n}\n\n \nstatic int orangefs_lock(struct file *filp, int cmd, struct file_lock *fl)\n{\n\tint rc = -EINVAL;\n\n\tif (ORANGEFS_SB(file_inode(filp)->i_sb)->flags & ORANGEFS_OPT_LOCAL_LOCK) {\n\t\tif (cmd == F_GETLK) {\n\t\t\trc = 0;\n\t\t\tposix_test_lock(filp, fl);\n\t\t} else {\n\t\t\trc = posix_lock_file(filp, fl, NULL);\n\t\t}\n\t}\n\n\treturn rc;\n}\n\nstatic int orangefs_flush(struct file *file, fl_owner_t id)\n{\n\t \n\tint r;\n\n\tr = filemap_write_and_wait_range(file->f_mapping, 0, LLONG_MAX);\n\tif (r > 0)\n\t\treturn 0;\n\telse\n\t\treturn r;\n}\n\n \nconst struct file_operations orangefs_file_operations = {\n\t.llseek\t\t= orangefs_file_llseek,\n\t.read_iter\t= orangefs_file_read_iter,\n\t.write_iter\t= orangefs_file_write_iter,\n\t.lock\t\t= orangefs_lock,\n\t.mmap\t\t= orangefs_file_mmap,\n\t.open\t\t= generic_file_open,\n\t.splice_read    = orangefs_file_splice_read,\n\t.splice_write   = iter_file_splice_write,\n\t.flush\t\t= orangefs_flush,\n\t.release\t= orangefs_file_release,\n\t.fsync\t\t= orangefs_fsync,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}