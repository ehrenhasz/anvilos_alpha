{
  "module_name": "orangefs-debugfs.c",
  "hash_id": "44fe2e84d4aa9bda1befe7f856648b9e35e39e63761a3cac4fa3a7d0ba8c03f7",
  "original_prompt": "Ingested from linux-6.6.14/fs/orangefs/orangefs-debugfs.c",
  "human_readable_source": "\n \n#include <linux/debugfs.h>\n#include <linux/slab.h>\n\n#include <linux/uaccess.h>\n\n#include \"orangefs-debugfs.h\"\n#include \"protocol.h\"\n#include \"orangefs-kernel.h\"\n\n#define DEBUG_HELP_STRING_SIZE 4096\n#define HELP_STRING_UNINITIALIZED \\\n\t\"Client Debug Keywords are unknown until the first time\\n\" \\\n\t\"the client is started after boot.\\n\"\n#define ORANGEFS_KMOD_DEBUG_HELP_FILE \"debug-help\"\n#define ORANGEFS_KMOD_DEBUG_FILE \"kernel-debug\"\n#define ORANGEFS_CLIENT_DEBUG_FILE \"client-debug\"\n#define ORANGEFS_VERBOSE \"verbose\"\n#define ORANGEFS_ALL \"all\"\n\n \nstruct client_debug_mask {\n\tchar *keyword;\n\t__u64 mask1;\n\t__u64 mask2;\n};\n\nstatic void orangefs_kernel_debug_init(void);\n\nstatic int orangefs_debug_help_open(struct inode *, struct file *);\nstatic void *help_start(struct seq_file *, loff_t *);\nstatic void *help_next(struct seq_file *, void *, loff_t *);\nstatic void help_stop(struct seq_file *, void *);\nstatic int help_show(struct seq_file *, void *);\n\nstatic int orangefs_debug_open(struct inode *, struct file *);\n\nstatic ssize_t orangefs_debug_read(struct file *,\n\t\t\t\t char __user *,\n\t\t\t\t size_t,\n\t\t\t\t loff_t *);\n\nstatic ssize_t orangefs_debug_write(struct file *,\n\t\t\t\t  const char __user *,\n\t\t\t\t  size_t,\n\t\t\t\t  loff_t *);\n\nstatic int orangefs_prepare_cdm_array(char *);\nstatic void debug_mask_to_string(void *, int);\nstatic void do_k_string(void *, int);\nstatic void do_c_string(void *, int);\nstatic int keyword_is_amalgam(char *);\nstatic int check_amalgam_keyword(void *, int);\nstatic void debug_string_to_mask(char *, void *, int);\nstatic void do_c_mask(int, char *, struct client_debug_mask **);\nstatic void do_k_mask(int, char *, __u64 **);\n\nstatic char kernel_debug_string[ORANGEFS_MAX_DEBUG_STRING_LEN] = \"none\";\nstatic char *debug_help_string;\nstatic char client_debug_string[ORANGEFS_MAX_DEBUG_STRING_LEN];\nstatic char client_debug_array_string[ORANGEFS_MAX_DEBUG_STRING_LEN];\n\nstatic struct dentry *client_debug_dentry;\nstatic struct dentry *debug_dir;\n\nstatic unsigned int kernel_mask_set_mod_init;\nstatic int orangefs_debug_disabled = 1;\nstatic int help_string_initialized;\n\nstatic const struct seq_operations help_debug_ops = {\n\t.start\t= help_start,\n\t.next\t= help_next,\n\t.stop\t= help_stop,\n\t.show\t= help_show,\n};\n\nstatic const struct file_operations debug_help_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open           = orangefs_debug_help_open,\n\t.read           = seq_read,\n\t.release        = seq_release,\n\t.llseek         = seq_lseek,\n};\n\nstatic const struct file_operations kernel_debug_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open           = orangefs_debug_open,\n\t.read           = orangefs_debug_read,\n\t.write\t\t= orangefs_debug_write,\n\t.llseek         = generic_file_llseek,\n};\n\nstatic int client_all_index;\nstatic int client_verbose_index;\n\nstatic struct client_debug_mask *cdm_array;\nstatic int cdm_element_count;\n\nstatic struct client_debug_mask client_debug_mask;\n\n \nstatic DEFINE_MUTEX(orangefs_debug_lock);\n\n \nstatic DEFINE_MUTEX(orangefs_help_file_lock);\n\n \nvoid orangefs_debugfs_init(int debug_mask)\n{\n\t \n        orangefs_gossip_debug_mask = (unsigned long long)debug_mask;\n\n\t \n\tdebug_mask_to_string(&orangefs_gossip_debug_mask, 0);\n\n\t \n\tdebug_string_to_mask(kernel_debug_string, &orangefs_gossip_debug_mask,\n\t    0);\n\n\t \n\tif (orangefs_gossip_debug_mask != 0)\n\t\tkernel_mask_set_mod_init = true;\n\n\tpr_info(\"%s: called with debug mask: :%s: :%llx:\\n\",\n\t\t__func__,\n\t\tkernel_debug_string,\n\t\t(unsigned long long)orangefs_gossip_debug_mask);\n\n\tdebug_dir = debugfs_create_dir(\"orangefs\", NULL);\n\n\tdebugfs_create_file(ORANGEFS_KMOD_DEBUG_HELP_FILE, 0444, debug_dir,\n\t\t\t    debug_help_string, &debug_help_fops);\n\n\torangefs_debug_disabled = 0;\n\n\torangefs_kernel_debug_init();\n}\n\n \nstatic void orangefs_kernel_debug_init(void)\n{\n\tstatic char k_buffer[ORANGEFS_MAX_DEBUG_STRING_LEN] = { };\n\n\tgossip_debug(GOSSIP_DEBUGFS_DEBUG, \"%s: start\\n\", __func__);\n\n\tif (strlen(kernel_debug_string) + 1 < ORANGEFS_MAX_DEBUG_STRING_LEN) {\n\t\tstrcpy(k_buffer, kernel_debug_string);\n\t\tstrcat(k_buffer, \"\\n\");\n\t} else {\n\t\tstrcpy(k_buffer, \"none\\n\");\n\t\tpr_info(\"%s: overflow 1!\\n\", __func__);\n\t}\n\n\tdebugfs_create_file(ORANGEFS_KMOD_DEBUG_FILE, 0444, debug_dir, k_buffer,\n\t\t\t    &kernel_debug_fops);\n}\n\n\nvoid orangefs_debugfs_cleanup(void)\n{\n\tdebugfs_remove_recursive(debug_dir);\n\tkfree(debug_help_string);\n\tdebug_help_string = NULL;\n}\n\n \nstatic int orangefs_debug_help_open(struct inode *inode, struct file *file)\n{\n\tint rc = -ENODEV;\n\tint ret;\n\n\tgossip_debug(GOSSIP_DEBUGFS_DEBUG,\n\t\t     \"orangefs_debug_help_open: start\\n\");\n\n\tif (orangefs_debug_disabled)\n\t\tgoto out;\n\n\tret = seq_open(file, &help_debug_ops);\n\tif (ret)\n\t\tgoto out;\n\n\t((struct seq_file *)(file->private_data))->private = inode->i_private;\n\n\trc = 0;\n\nout:\n\tgossip_debug(GOSSIP_DEBUGFS_DEBUG,\n\t\t     \"orangefs_debug_help_open: rc:%d:\\n\",\n\t\t     rc);\n\treturn rc;\n}\n\n \nstatic void *help_start(struct seq_file *m, loff_t *pos)\n{\n\tvoid *payload = NULL;\n\n\tgossip_debug(GOSSIP_DEBUGFS_DEBUG, \"help_start: start\\n\");\n\n\tmutex_lock(&orangefs_help_file_lock);\n\n\tif (*pos == 0)\n\t\tpayload = m->private;\n\n\treturn payload;\n}\n\nstatic void *help_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\t(*pos)++;\n\tgossip_debug(GOSSIP_DEBUGFS_DEBUG, \"help_next: start\\n\");\n\n\treturn NULL;\n}\n\nstatic void help_stop(struct seq_file *m, void *p)\n{\n\tgossip_debug(GOSSIP_DEBUGFS_DEBUG, \"help_stop: start\\n\");\n\tmutex_unlock(&orangefs_help_file_lock);\n}\n\nstatic int help_show(struct seq_file *m, void *v)\n{\n\tgossip_debug(GOSSIP_DEBUGFS_DEBUG, \"help_show: start\\n\");\n\n\tseq_puts(m, v);\n\n\treturn 0;\n}\n\n \nstatic void orangefs_client_debug_init(void)\n{\n\n\tstatic char c_buffer[ORANGEFS_MAX_DEBUG_STRING_LEN] = { };\n\n\tgossip_debug(GOSSIP_DEBUGFS_DEBUG, \"%s: start\\n\", __func__);\n\n\tif (strlen(client_debug_string) + 1 < ORANGEFS_MAX_DEBUG_STRING_LEN) {\n\t\tstrcpy(c_buffer, client_debug_string);\n\t\tstrcat(c_buffer, \"\\n\");\n\t} else {\n\t\tstrcpy(c_buffer, \"none\\n\");\n\t\tpr_info(\"%s: overflow! 2\\n\", __func__);\n\t}\n\n\tclient_debug_dentry = debugfs_create_file(ORANGEFS_CLIENT_DEBUG_FILE,\n\t\t\t\t\t\t  0444,\n\t\t\t\t\t\t  debug_dir,\n\t\t\t\t\t\t  c_buffer,\n\t\t\t\t\t\t  &kernel_debug_fops);\n}\n\n \nstatic int orangefs_debug_open(struct inode *inode, struct file *file)\n{\n\tint rc = -ENODEV;\n\n\tgossip_debug(GOSSIP_DEBUGFS_DEBUG,\n\t\t     \"%s: orangefs_debug_disabled: %d\\n\",\n\t\t     __func__,\n\t\t     orangefs_debug_disabled);\n\n\tif (orangefs_debug_disabled)\n\t\tgoto out;\n\n\trc = 0;\n\tmutex_lock(&orangefs_debug_lock);\n\tfile->private_data = inode->i_private;\n\tmutex_unlock(&orangefs_debug_lock);\n\nout:\n\tgossip_debug(GOSSIP_DEBUGFS_DEBUG,\n\t\t     \"orangefs_debug_open: rc: %d\\n\",\n\t\t     rc);\n\treturn rc;\n}\n\nstatic ssize_t orangefs_debug_read(struct file *file,\n\t\t\t\t char __user *ubuf,\n\t\t\t\t size_t count,\n\t\t\t\t loff_t *ppos)\n{\n\tchar *buf;\n\tint sprintf_ret;\n\tssize_t read_ret = -ENOMEM;\n\n\tgossip_debug(GOSSIP_DEBUGFS_DEBUG, \"orangefs_debug_read: start\\n\");\n\n\tbuf = kmalloc(ORANGEFS_MAX_DEBUG_STRING_LEN, GFP_KERNEL);\n\tif (!buf)\n\t\tgoto out;\n\n\tmutex_lock(&orangefs_debug_lock);\n\tsprintf_ret = sprintf(buf, \"%s\", (char *)file->private_data);\n\tmutex_unlock(&orangefs_debug_lock);\n\n\tread_ret = simple_read_from_buffer(ubuf, count, ppos, buf, sprintf_ret);\n\n\tkfree(buf);\n\nout:\n\tgossip_debug(GOSSIP_DEBUGFS_DEBUG,\n\t\t     \"orangefs_debug_read: ret: %zu\\n\",\n\t\t     read_ret);\n\n\treturn read_ret;\n}\n\nstatic ssize_t orangefs_debug_write(struct file *file,\n\t\t\t\t  const char __user *ubuf,\n\t\t\t\t  size_t count,\n\t\t\t\t  loff_t *ppos)\n{\n\tchar *buf;\n\tint rc = -EFAULT;\n\tsize_t silly = 0;\n\tchar *debug_string;\n\tstruct orangefs_kernel_op_s *new_op = NULL;\n\tstruct client_debug_mask c_mask = { NULL, 0, 0 };\n\tchar *s;\n\n\tgossip_debug(GOSSIP_DEBUGFS_DEBUG,\n\t\t\"orangefs_debug_write: %pD\\n\",\n\t\tfile);\n\n\tif (count == 0)\n\t\treturn 0;\n\n\t \n\tif (count > ORANGEFS_MAX_DEBUG_STRING_LEN + 1) {\n\t\tsilly = count;\n\t\tcount = ORANGEFS_MAX_DEBUG_STRING_LEN + 1;\n\t}\n\n\tbuf = kzalloc(ORANGEFS_MAX_DEBUG_STRING_LEN, GFP_KERNEL);\n\tif (!buf)\n\t\tgoto out;\n\n\tif (copy_from_user(buf, ubuf, count - 1)) {\n\t\tgossip_debug(GOSSIP_DEBUGFS_DEBUG,\n\t\t\t     \"%s: copy_from_user failed!\\n\",\n\t\t\t     __func__);\n\t\tgoto out;\n\t}\n\n\t \n\tif (!strcmp(file->f_path.dentry->d_name.name,\n\t\t    ORANGEFS_KMOD_DEBUG_FILE)) {\n\t\tdebug_string_to_mask(buf, &orangefs_gossip_debug_mask, 0);\n\t\tdebug_mask_to_string(&orangefs_gossip_debug_mask, 0);\n\t\tdebug_string = kernel_debug_string;\n\t\tgossip_debug(GOSSIP_DEBUGFS_DEBUG,\n\t\t\t     \"New kernel debug string is %s\\n\",\n\t\t\t     kernel_debug_string);\n\t} else {\n\t\t \n\t\tif (is_daemon_in_service()) {\n\t\t\tpr_info(\"%s: Client not running :%d:\\n\",\n\t\t\t\t__func__,\n\t\t\t\tis_daemon_in_service());\n\t\t\tgoto out;\n\t\t}\n\n\t\tdebug_string_to_mask(buf, &c_mask, 1);\n\t\tdebug_mask_to_string(&c_mask, 1);\n\t\tdebug_string = client_debug_string;\n\n\t\tnew_op = op_alloc(ORANGEFS_VFS_OP_PARAM);\n\t\tif (!new_op) {\n\t\t\tpr_info(\"%s: op_alloc failed!\\n\", __func__);\n\t\t\tgoto out;\n\t\t}\n\n\t\tnew_op->upcall.req.param.op =\n\t\t\tORANGEFS_PARAM_REQUEST_OP_TWO_MASK_VALUES;\n\t\tnew_op->upcall.req.param.type = ORANGEFS_PARAM_REQUEST_SET;\n\t\tmemset(new_op->upcall.req.param.s_value,\n\t\t       0,\n\t\t       ORANGEFS_MAX_DEBUG_STRING_LEN);\n\t\tsprintf(new_op->upcall.req.param.s_value,\n\t\t\t\"%llx %llx\\n\",\n\t\t\tc_mask.mask1,\n\t\t\tc_mask.mask2);\n\n\t\t \n\t\trc = service_operation(new_op,\n\t\t\t\t       \"orangefs_param\",\n\t\t\t\t\tORANGEFS_OP_INTERRUPTIBLE);\n\n\t\tif (rc)\n\t\t\tgossip_debug(GOSSIP_DEBUGFS_DEBUG,\n\t\t\t\t     \"%s: service_operation failed! rc:%d:\\n\",\n\t\t\t\t     __func__,\n\t\t\t\t     rc);\n\n\t\top_release(new_op);\n\t}\n\n\tmutex_lock(&orangefs_debug_lock);\n\ts = file_inode(file)->i_private;\n\tmemset(s, 0, ORANGEFS_MAX_DEBUG_STRING_LEN);\n\tsprintf(s, \"%s\\n\", debug_string);\n\tmutex_unlock(&orangefs_debug_lock);\n\n\t*ppos += count;\n\tif (silly)\n\t\trc = silly;\n\telse\n\t\trc = count;\n\nout:\n\tgossip_debug(GOSSIP_DEBUGFS_DEBUG,\n\t\t     \"orangefs_debug_write: rc: %d\\n\",\n\t\t     rc);\n\tkfree(buf);\n\treturn rc;\n}\n\n \nstatic int orangefs_prepare_cdm_array(char *debug_array_string)\n{\n\tint i;\n\tint rc = -EINVAL;\n\tchar *cds_head = NULL;\n\tchar *cds_delimiter = NULL;\n\tint keyword_len = 0;\n\n\tgossip_debug(GOSSIP_UTILS_DEBUG, \"%s: start\\n\", __func__);\n\n\t \n\tfor (i = 0; i < strlen(debug_array_string); i++)\n\t\tif (debug_array_string[i] == '\\n')\n\t\t\tcdm_element_count++;\n\n\tif (!cdm_element_count) {\n\t\tpr_info(\"No elements in client debug array string!\\n\");\n\t\tgoto out;\n\t}\n\n\tcdm_array = kcalloc(cdm_element_count, sizeof(*cdm_array), GFP_KERNEL);\n\tif (!cdm_array) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tcds_head = debug_array_string;\n\n\tfor (i = 0; i < cdm_element_count; i++) {\n\t\tcds_delimiter = strchr(cds_head, '\\n');\n\t\t*cds_delimiter = '\\0';\n\n\t\tkeyword_len = strcspn(cds_head, \" \");\n\n\t\tcdm_array[i].keyword = kzalloc(keyword_len + 1, GFP_KERNEL);\n\t\tif (!cdm_array[i].keyword) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tsscanf(cds_head,\n\t\t       \"%s %llx %llx\",\n\t\t       cdm_array[i].keyword,\n\t\t       (unsigned long long *)&(cdm_array[i].mask1),\n\t\t       (unsigned long long *)&(cdm_array[i].mask2));\n\n\t\tif (!strcmp(cdm_array[i].keyword, ORANGEFS_VERBOSE))\n\t\t\tclient_verbose_index = i;\n\n\t\tif (!strcmp(cdm_array[i].keyword, ORANGEFS_ALL))\n\t\t\tclient_all_index = i;\n\n\t\tcds_head = cds_delimiter + 1;\n\t}\n\n\trc = cdm_element_count;\n\n\tgossip_debug(GOSSIP_UTILS_DEBUG, \"%s: rc:%d:\\n\", __func__, rc);\n\nout:\n\n\treturn rc;\n\n}\n\n \nint orangefs_prepare_debugfs_help_string(int at_boot)\n{\n\tchar *client_title = \"Client Debug Keywords:\\n\";\n\tchar *kernel_title = \"Kernel Debug Keywords:\\n\";\n\tsize_t string_size =  DEBUG_HELP_STRING_SIZE;\n\tsize_t result_size;\n\tsize_t i;\n\tchar *new;\n\tint rc = -EINVAL;\n\n\tgossip_debug(GOSSIP_UTILS_DEBUG, \"%s: start\\n\", __func__);\n\n\tif (at_boot)\n\t\tclient_title = HELP_STRING_UNINITIALIZED;\n\n\t \n\tnew = kzalloc(DEBUG_HELP_STRING_SIZE, GFP_KERNEL);\n\tif (!new) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\tstrlcat(new, client_title, string_size);\n\n\tif (!at_boot) {\n\n                 \n\t\tcdm_element_count =\n\t\t\torangefs_prepare_cdm_array(client_debug_array_string);\n\t\tif (cdm_element_count <= 0) {\n\t\t\tkfree(new);\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (i = 0; i < cdm_element_count; i++) {\n\t\t\tstrlcat(new, \"\\t\", string_size);\n\t\t\tstrlcat(new, cdm_array[i].keyword, string_size);\n\t\t\tstrlcat(new, \"\\n\", string_size);\n\t\t}\n\t}\n\n\tstrlcat(new, \"\\n\", string_size);\n\tstrlcat(new, kernel_title, string_size);\n\n\tfor (i = 0; i < num_kmod_keyword_mask_map; i++) {\n\t\tstrlcat(new, \"\\t\", string_size);\n\t\tstrlcat(new, s_kmod_keyword_mask_map[i].keyword, string_size);\n\t\tresult_size = strlcat(new, \"\\n\", string_size);\n\t}\n\n\t \n\tif (result_size >= string_size) {\n\t\tkfree(new);\n\t\tgoto out;\n\t}\n\n\tif (at_boot) {\n\t\tdebug_help_string = new;\n\t} else {\n\t\tmutex_lock(&orangefs_help_file_lock);\n\t\tmemset(debug_help_string, 0, DEBUG_HELP_STRING_SIZE);\n\t\tstrlcat(debug_help_string, new, string_size);\n\t\tmutex_unlock(&orangefs_help_file_lock);\n\t\tkfree(new);\n\t}\n\n\trc = 0;\n\nout:\treturn rc;\n\n}\n\n \nstatic void debug_mask_to_string(void *mask, int type)\n{\n\tint i;\n\tint len = 0;\n\tchar *debug_string;\n\tint element_count = 0;\n\n\tgossip_debug(GOSSIP_UTILS_DEBUG, \"%s: start\\n\", __func__);\n\n\tif (type) {\n\t\tdebug_string = client_debug_string;\n\t\telement_count = cdm_element_count;\n\t} else {\n\t\tdebug_string = kernel_debug_string;\n\t\telement_count = num_kmod_keyword_mask_map;\n\t}\n\n\tmemset(debug_string, 0, ORANGEFS_MAX_DEBUG_STRING_LEN);\n\n\t \n\tif (check_amalgam_keyword(mask, type))\n\t\tgoto out;\n\n\t \n\tfor (i = 0; i < element_count; i++)\n\t\tif (type)\n\t\t\tdo_c_string(mask, i);\n\t\telse\n\t\t\tdo_k_string(mask, i);\n\n\tlen = strlen(debug_string);\n\n\tif ((len) && (type))\n\t\tclient_debug_string[len - 1] = '\\0';\n\telse if (len)\n\t\tkernel_debug_string[len - 1] = '\\0';\n\telse if (type)\n\t\tstrcpy(client_debug_string, \"none\");\n\telse\n\t\tstrcpy(kernel_debug_string, \"none\");\n\nout:\ngossip_debug(GOSSIP_UTILS_DEBUG, \"%s: string:%s:\\n\", __func__, debug_string);\n\n\treturn;\n\n}\n\nstatic void do_k_string(void *k_mask, int index)\n{\n\t__u64 *mask = (__u64 *) k_mask;\n\n\tif (keyword_is_amalgam((char *) s_kmod_keyword_mask_map[index].keyword))\n\t\tgoto out;\n\n\tif (*mask & s_kmod_keyword_mask_map[index].mask_val) {\n\t\tif ((strlen(kernel_debug_string) +\n\t\t     strlen(s_kmod_keyword_mask_map[index].keyword))\n\t\t\t< ORANGEFS_MAX_DEBUG_STRING_LEN - 1) {\n\t\t\t\tstrcat(kernel_debug_string,\n\t\t\t\t       s_kmod_keyword_mask_map[index].keyword);\n\t\t\t\tstrcat(kernel_debug_string, \",\");\n\t\t\t} else {\n\t\t\t\tgossip_err(\"%s: overflow!\\n\", __func__);\n\t\t\t\tstrcpy(kernel_debug_string, ORANGEFS_ALL);\n\t\t\t\tgoto out;\n\t\t\t}\n\t}\n\nout:\n\n\treturn;\n}\n\nstatic void do_c_string(void *c_mask, int index)\n{\n\tstruct client_debug_mask *mask = (struct client_debug_mask *) c_mask;\n\n\tif (keyword_is_amalgam(cdm_array[index].keyword))\n\t\tgoto out;\n\n\tif ((mask->mask1 & cdm_array[index].mask1) ||\n\t    (mask->mask2 & cdm_array[index].mask2)) {\n\t\tif ((strlen(client_debug_string) +\n\t\t     strlen(cdm_array[index].keyword) + 1)\n\t\t\t< ORANGEFS_MAX_DEBUG_STRING_LEN - 2) {\n\t\t\t\tstrcat(client_debug_string,\n\t\t\t\t       cdm_array[index].keyword);\n\t\t\t\tstrcat(client_debug_string, \",\");\n\t\t\t} else {\n\t\t\t\tgossip_err(\"%s: overflow!\\n\", __func__);\n\t\t\t\tstrcpy(client_debug_string, ORANGEFS_ALL);\n\t\t\t\tgoto out;\n\t\t\t}\n\t}\nout:\n\treturn;\n}\n\nstatic int keyword_is_amalgam(char *keyword)\n{\n\tint rc = 0;\n\n\tif ((!strcmp(keyword, ORANGEFS_ALL)) || (!strcmp(keyword, ORANGEFS_VERBOSE)))\n\t\trc = 1;\n\n\treturn rc;\n}\n\n \nstatic int check_amalgam_keyword(void *mask, int type)\n{\n\t__u64 *k_mask;\n\tstruct client_debug_mask *c_mask;\n\tint k_all_index = num_kmod_keyword_mask_map - 1;\n\tint rc = 0;\n\n\tif (type) {\n\t\tc_mask = (struct client_debug_mask *) mask;\n\n\t\tif ((c_mask->mask1 == cdm_array[client_all_index].mask1) &&\n\t\t    (c_mask->mask2 == cdm_array[client_all_index].mask2)) {\n\t\t\tstrcpy(client_debug_string, ORANGEFS_ALL);\n\t\t\trc = 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif ((c_mask->mask1 == cdm_array[client_verbose_index].mask1) &&\n\t\t    (c_mask->mask2 == cdm_array[client_verbose_index].mask2)) {\n\t\t\tstrcpy(client_debug_string, ORANGEFS_VERBOSE);\n\t\t\trc = 1;\n\t\t\tgoto out;\n\t\t}\n\n\t} else {\n\t\tk_mask = (__u64 *) mask;\n\n\t\tif (*k_mask >= s_kmod_keyword_mask_map[k_all_index].mask_val) {\n\t\t\tstrcpy(kernel_debug_string, ORANGEFS_ALL);\n\t\t\trc = 1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\n\treturn rc;\n}\n\n \nstatic void debug_string_to_mask(char *debug_string, void *mask, int type)\n{\n\tchar *unchecked_keyword;\n\tint i;\n\tchar *strsep_fodder = kstrdup(debug_string, GFP_KERNEL);\n\tchar *original_pointer;\n\tint element_count = 0;\n\tstruct client_debug_mask *c_mask = NULL;\n\t__u64 *k_mask = NULL;\n\n\tgossip_debug(GOSSIP_UTILS_DEBUG, \"%s: start\\n\", __func__);\n\n\tif (type) {\n\t\tc_mask = (struct client_debug_mask *)mask;\n\t\telement_count = cdm_element_count;\n\t} else {\n\t\tk_mask = (__u64 *)mask;\n\t\t*k_mask = 0;\n\t\telement_count = num_kmod_keyword_mask_map;\n\t}\n\n\toriginal_pointer = strsep_fodder;\n\twhile ((unchecked_keyword = strsep(&strsep_fodder, \",\")))\n\t\tif (strlen(unchecked_keyword)) {\n\t\t\tfor (i = 0; i < element_count; i++)\n\t\t\t\tif (type)\n\t\t\t\t\tdo_c_mask(i,\n\t\t\t\t\t\t  unchecked_keyword,\n\t\t\t\t\t\t  &c_mask);\n\t\t\t\telse\n\t\t\t\t\tdo_k_mask(i,\n\t\t\t\t\t\t  unchecked_keyword,\n\t\t\t\t\t\t  &k_mask);\n\t\t}\n\n\tkfree(original_pointer);\n}\n\nstatic void do_c_mask(int i, char *unchecked_keyword,\n    struct client_debug_mask **sane_mask)\n{\n\n\tif (!strcmp(cdm_array[i].keyword, unchecked_keyword)) {\n\t\t(**sane_mask).mask1 = (**sane_mask).mask1 | cdm_array[i].mask1;\n\t\t(**sane_mask).mask2 = (**sane_mask).mask2 | cdm_array[i].mask2;\n\t}\n}\n\nstatic void do_k_mask(int i, char *unchecked_keyword, __u64 **sane_mask)\n{\n\n\tif (!strcmp(s_kmod_keyword_mask_map[i].keyword, unchecked_keyword))\n\t\t**sane_mask = (**sane_mask) |\n\t\t\t\ts_kmod_keyword_mask_map[i].mask_val;\n}\n\nint orangefs_debugfs_new_client_mask(void __user *arg)\n{\n\tstruct dev_mask2_info_s mask2_info = {0};\n\tint ret;\n\n\tret = copy_from_user(&mask2_info,\n\t\t\t     (void __user *)arg,\n\t\t\t     sizeof(struct dev_mask2_info_s));\n\n\tif (ret != 0)\n\t\treturn -EIO;\n\n\tclient_debug_mask.mask1 = mask2_info.mask1_value;\n\tclient_debug_mask.mask2 = mask2_info.mask2_value;\n\n\tpr_info(\"%s: client debug mask has been been received \"\n\t\t\":%llx: :%llx:\\n\",\n\t\t__func__,\n\t\t(unsigned long long)client_debug_mask.mask1,\n\t\t(unsigned long long)client_debug_mask.mask2);\n\n\treturn ret;\n}\n\nint orangefs_debugfs_new_client_string(void __user *arg)\n{\n\tint ret;\n\n\tret = copy_from_user(&client_debug_array_string,\n\t\t\t     (void __user *)arg,\n\t\t\t     ORANGEFS_MAX_DEBUG_STRING_LEN);\n\n\tif (ret != 0) {\n\t\tpr_info(\"%s: CLIENT_STRING: copy_from_user failed\\n\",\n\t\t\t__func__);\n\t\treturn -EFAULT;\n\t}\n\n\t \n\tclient_debug_array_string[ORANGEFS_MAX_DEBUG_STRING_LEN - 1] =\n\t\t'\\0';\n\n\tpr_info(\"%s: client debug array string has been received.\\n\",\n\t\t__func__);\n\n\tif (!help_string_initialized) {\n\n\t\t \n\t\tret = orangefs_prepare_debugfs_help_string(0);\n\t\tif (ret) {\n\t\t\tgossip_err(\"%s: no debug help string \\n\",\n\t\t\t\t   __func__);\n\t\t\treturn ret;\n\t\t}\n\n\t}\n\n\tdebug_mask_to_string(&client_debug_mask, 1);\n\n\tdebugfs_remove(client_debug_dentry);\n\n\torangefs_client_debug_init();\n\n\thelp_string_initialized++;\n\n\treturn 0;\n}\n\nint orangefs_debugfs_new_debug(void __user *arg)\n{\n\tstruct dev_mask_info_s mask_info = {0};\n\tint ret;\n\n\tret = copy_from_user(&mask_info,\n\t\t\t     (void __user *)arg,\n\t\t\t     sizeof(mask_info));\n\n\tif (ret != 0)\n\t\treturn -EIO;\n\n\tif (mask_info.mask_type == KERNEL_MASK) {\n\t\tif ((mask_info.mask_value == 0)\n\t\t    && (kernel_mask_set_mod_init)) {\n\t\t\t \n\t\t\treturn 0;\n\t\t}\n\t\tdebug_mask_to_string(&mask_info.mask_value,\n\t\t\t\t     mask_info.mask_type);\n\t\torangefs_gossip_debug_mask = mask_info.mask_value;\n\t\tpr_info(\"%s: kernel debug mask has been modified to \"\n\t\t\t\":%s: :%llx:\\n\",\n\t\t\t__func__,\n\t\t\tkernel_debug_string,\n\t\t\t(unsigned long long)orangefs_gossip_debug_mask);\n\t} else if (mask_info.mask_type == CLIENT_MASK) {\n\t\tdebug_mask_to_string(&mask_info.mask_value,\n\t\t\t\t     mask_info.mask_type);\n\t\tpr_info(\"%s: client debug mask has been modified to\"\n\t\t\t\":%s: :%llx:\\n\",\n\t\t\t__func__,\n\t\t\tclient_debug_string,\n\t\t\tllu(mask_info.mask_value));\n\t} else {\n\t\tgossip_err(\"Invalid mask type....\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}