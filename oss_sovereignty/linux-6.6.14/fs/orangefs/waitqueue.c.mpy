{
  "module_name": "waitqueue.c",
  "hash_id": "c9a9abe814c62abec824356138a77e066c7532461b7faecc2a58cb94bf7a7355",
  "original_prompt": "Ingested from linux-6.6.14/fs/orangefs/waitqueue.c",
  "human_readable_source": "\n \n\n \n\n#include \"protocol.h\"\n#include \"orangefs-kernel.h\"\n#include \"orangefs-bufmap.h\"\n\nstatic int wait_for_matching_downcall(struct orangefs_kernel_op_s *op,\n\t\tlong timeout,\n\t\tint flags)\n\t\t\t__acquires(op->lock);\nstatic void orangefs_clean_up_interrupted_operation(struct orangefs_kernel_op_s *op)\n\t__releases(op->lock);\n\n \nvoid purge_waiting_ops(void)\n{\n\tstruct orangefs_kernel_op_s *op, *tmp;\n\n\tspin_lock(&orangefs_request_list_lock);\n\tlist_for_each_entry_safe(op, tmp, &orangefs_request_list, list) {\n\t\tgossip_debug(GOSSIP_WAIT_DEBUG,\n\t\t\t     \"pvfs2-client-core: purging op tag %llu %s\\n\",\n\t\t\t     llu(op->tag),\n\t\t\t     get_opname_string(op));\n\t\tset_op_state_purged(op);\n\t\tgossip_debug(GOSSIP_DEV_DEBUG,\n\t\t\t     \"%s: op:%s: op_state:%d: process:%s:\\n\",\n\t\t\t     __func__,\n\t\t\t     get_opname_string(op),\n\t\t\t     op->op_state,\n\t\t\t     current->comm);\n\t}\n\tspin_unlock(&orangefs_request_list_lock);\n}\n\n \nint service_operation(struct orangefs_kernel_op_s *op,\n\t\t      const char *op_name,\n\t\t      int flags)\n{\n\tlong timeout = MAX_SCHEDULE_TIMEOUT;\n\tint ret = 0;\n\n\tDEFINE_WAIT(wait_entry);\n\n\top->upcall.tgid = current->tgid;\n\top->upcall.pid = current->pid;\n\nretry_servicing:\n\top->downcall.status = 0;\n\tgossip_debug(GOSSIP_WAIT_DEBUG,\n\t\t     \"%s: %s op:%p: process:%s: pid:%d:\\n\",\n\t\t     __func__,\n\t\t     op_name,\n\t\t     op,\n\t\t     current->comm,\n\t\t     current->pid);\n\n\t \n\tif (!(flags & ORANGEFS_OP_NO_MUTEX)) {\n\t\tif (flags & ORANGEFS_OP_INTERRUPTIBLE)\n\t\t\tret = mutex_lock_interruptible(&orangefs_request_mutex);\n\t\telse\n\t\t\tret = mutex_lock_killable(&orangefs_request_mutex);\n\t\t \n\t\tif (ret < 0) {\n\t\t\top->downcall.status = ret;\n\t\t\tgossip_debug(GOSSIP_WAIT_DEBUG,\n\t\t\t\t     \"%s: service_operation interrupted.\\n\",\n\t\t\t\t     __func__);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tspin_lock(&orangefs_request_list_lock);\n\tspin_lock(&op->lock);\n\tset_op_state_waiting(op);\n\tgossip_debug(GOSSIP_DEV_DEBUG,\n\t\t     \"%s: op:%s: op_state:%d: process:%s:\\n\",\n\t\t     __func__,\n\t\t     get_opname_string(op),\n\t\t     op->op_state,\n\t\t     current->comm);\n\t \n\tif (flags & ORANGEFS_OP_PRIORITY)\n\t\tlist_add(&op->list, &orangefs_request_list);\n\telse\n\t\tlist_add_tail(&op->list, &orangefs_request_list);\n\tspin_unlock(&op->lock);\n\twake_up_interruptible(&orangefs_request_list_waitq);\n\tif (!__is_daemon_in_service()) {\n\t\tgossip_debug(GOSSIP_WAIT_DEBUG,\n\t\t\t     \"%s:client core is NOT in service.\\n\",\n\t\t\t     __func__);\n\t\t \n\t\tif (op->upcall.type == ORANGEFS_VFS_OP_FS_UMOUNT)\n\t\t\ttimeout = 0;\n\t\telse\n\t\t\ttimeout = op_timeout_secs * HZ;\n\t}\n\tspin_unlock(&orangefs_request_list_lock);\n\n\tif (!(flags & ORANGEFS_OP_NO_MUTEX))\n\t\tmutex_unlock(&orangefs_request_mutex);\n\n\tret = wait_for_matching_downcall(op, timeout, flags);\n\tgossip_debug(GOSSIP_WAIT_DEBUG,\n\t\t     \"%s: wait_for_matching_downcall returned %d for %p\\n\",\n\t\t     __func__,\n\t\t     ret,\n\t\t     op);\n\n\t \n\tif (!ret) {\n\t\tspin_unlock(&op->lock);\n\t\top->downcall.status =\n\t\t    orangefs_normalize_to_errno(op->downcall.status);\n\t\tret = op->downcall.status;\n\t\tgoto out;\n\t}\n\n\t \n\tif (ret == -ETIMEDOUT) {\n\t\tgossip_err(\"%s: %s -- wait timed out; aborting attempt.\\n\",\n\t\t\t   __func__,\n\t\t\t   op_name);\n\t}\n\n\t \n\torangefs_clean_up_interrupted_operation(op);\n\n\top->downcall.status = ret;\n\t \n\tif (ret == -EAGAIN) {\n\t\top->attempts++;\n\t\ttimeout = op_timeout_secs * HZ;\n\t\tgossip_debug(GOSSIP_WAIT_DEBUG,\n\t\t\t     \"orangefs: tag %llu (%s)\"\n\t\t\t     \" -- operation to be retried (%d attempt)\\n\",\n\t\t\t     llu(op->tag),\n\t\t\t     op_name,\n\t\t\t     op->attempts);\n\n\t\t \n\t\tif (!op->uses_shared_memory)\n\t\t\tgoto retry_servicing;\n\t}\n\nout:\n\tgossip_debug(GOSSIP_WAIT_DEBUG,\n\t\t     \"%s: %s returning: %d for %p.\\n\",\n\t\t     __func__,\n\t\t     op_name,\n\t\t     ret,\n\t\t     op);\n\treturn ret;\n}\n\n \nbool orangefs_cancel_op_in_progress(struct orangefs_kernel_op_s *op)\n{\n\tu64 tag = op->tag;\n\tif (!op_state_in_progress(op))\n\t\treturn false;\n\n\top->slot_to_free = op->upcall.req.io.buf_index;\n\tmemset(&op->upcall, 0, sizeof(op->upcall));\n\tmemset(&op->downcall, 0, sizeof(op->downcall));\n\top->upcall.type = ORANGEFS_VFS_OP_CANCEL;\n\top->upcall.req.cancel.op_tag = tag;\n\top->downcall.type = ORANGEFS_VFS_OP_INVALID;\n\top->downcall.status = -1;\n\torangefs_new_tag(op);\n\n\tspin_lock(&orangefs_request_list_lock);\n\t \n\tif (!__is_daemon_in_service()) {\n\t\tspin_unlock(&orangefs_request_list_lock);\n\t\treturn false;\n\t}\n\tspin_lock(&op->lock);\n\tset_op_state_waiting(op);\n\tgossip_debug(GOSSIP_DEV_DEBUG,\n\t\t     \"%s: op:%s: op_state:%d: process:%s:\\n\",\n\t\t     __func__,\n\t\t     get_opname_string(op),\n\t\t     op->op_state,\n\t\t     current->comm);\n\tlist_add(&op->list, &orangefs_request_list);\n\tspin_unlock(&op->lock);\n\tspin_unlock(&orangefs_request_list_lock);\n\n\tgossip_debug(GOSSIP_WAIT_DEBUG,\n\t\t     \"Attempting ORANGEFS operation cancellation of tag %llu\\n\",\n\t\t     llu(tag));\n\treturn true;\n}\n\n \nstatic void\n\torangefs_clean_up_interrupted_operation(struct orangefs_kernel_op_s *op)\n\t\t__releases(op->lock)\n{\n\t \n\n\t \n\top->op_state |= OP_VFS_STATE_GIVEN_UP;\n\n\tif (list_empty(&op->list)) {\n\t\t \n\t\tBUG_ON(op_state_serviced(op));\n\t\tspin_unlock(&op->lock);\n\t\twait_for_completion(&op->waitq);\n\t} else if (op_state_waiting(op)) {\n\t\t \n\t\tspin_unlock(&op->lock);\n\t\tspin_lock(&orangefs_request_list_lock);\n\t\tlist_del_init(&op->list);\n\t\tspin_unlock(&orangefs_request_list_lock);\n\t\tgossip_debug(GOSSIP_WAIT_DEBUG,\n\t\t\t     \"Interrupted: Removed op %p from request_list\\n\",\n\t\t\t     op);\n\t} else if (op_state_in_progress(op)) {\n\t\t \n\t\tspin_unlock(&op->lock);\n\t\tspin_lock(&orangefs_htable_ops_in_progress_lock);\n\t\tlist_del_init(&op->list);\n\t\tspin_unlock(&orangefs_htable_ops_in_progress_lock);\n\t\tgossip_debug(GOSSIP_WAIT_DEBUG,\n\t\t\t     \"Interrupted: Removed op %p\"\n\t\t\t     \" from htable_ops_in_progress\\n\",\n\t\t\t     op);\n\t} else {\n\t\tspin_unlock(&op->lock);\n\t\tgossip_err(\"interrupted operation is in a weird state 0x%x\\n\",\n\t\t\t   op->op_state);\n\t}\n\treinit_completion(&op->waitq);\n}\n\n \nstatic int wait_for_matching_downcall(struct orangefs_kernel_op_s *op,\n\t\tlong timeout,\n\t\tint flags)\n\t\t\t__acquires(op->lock)\n{\n\tlong n;\n\tint writeback = flags & ORANGEFS_OP_WRITEBACK,\n\t    interruptible = flags & ORANGEFS_OP_INTERRUPTIBLE;\n\n\t \n\tif (writeback)\n\t\tn = wait_for_completion_io_timeout(&op->waitq, timeout);\n\telse if (!writeback && interruptible)\n\t\tn = wait_for_completion_interruptible_timeout(&op->waitq,\n\t\t\t\t\t\t\t\t      timeout);\n\telse  \n\t\tn = wait_for_completion_killable_timeout(&op->waitq, timeout);\n\n\tspin_lock(&op->lock);\n\n\tif (op_state_serviced(op))\n\t\treturn 0;\n\n\tif (unlikely(n < 0)) {\n\t\tgossip_debug(GOSSIP_WAIT_DEBUG,\n\t\t\t     \"%s: operation interrupted, tag %llu, %p\\n\",\n\t\t\t     __func__,\n\t\t\t     llu(op->tag),\n\t\t\t     op);\n\t\treturn -EINTR;\n\t}\n\tif (op_state_purged(op)) {\n\t\tgossip_debug(GOSSIP_WAIT_DEBUG,\n\t\t\t     \"%s: operation purged, tag %llu, %p, %d\\n\",\n\t\t\t     __func__,\n\t\t\t     llu(op->tag),\n\t\t\t     op,\n\t\t\t     op->attempts);\n\t\treturn (op->attempts < ORANGEFS_PURGE_RETRY_COUNT) ?\n\t\t\t -EAGAIN :\n\t\t\t -EIO;\n\t}\n\t \n\tgossip_debug(GOSSIP_WAIT_DEBUG,\n\t\t     \"%s: operation timed out, tag %llu, %p, %d)\\n\",\n\t\t     __func__,\n\t\t     llu(op->tag),\n\t\t     op,\n\t\t     op->attempts);\n\treturn -ETIMEDOUT;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}