{
  "module_name": "cache.c",
  "hash_id": "1c324017ce105899fc56335f9fc1e820a87a7a5527269dd95abc49fee2073864",
  "original_prompt": "Ingested from linux-6.6.14/fs/exfat/cache.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <asm/unaligned.h>\n#include <linux/buffer_head.h>\n\n#include \"exfat_raw.h\"\n#include \"exfat_fs.h\"\n\n#define EXFAT_MAX_CACHE\t\t16\n\nstruct exfat_cache {\n\tstruct list_head cache_list;\n\tunsigned int nr_contig;\t \n\tunsigned int fcluster;\t \n\tunsigned int dcluster;\t \n};\n\nstruct exfat_cache_id {\n\tunsigned int id;\n\tunsigned int nr_contig;\n\tunsigned int fcluster;\n\tunsigned int dcluster;\n};\n\nstatic struct kmem_cache *exfat_cachep;\n\nstatic void exfat_cache_init_once(void *c)\n{\n\tstruct exfat_cache *cache = (struct exfat_cache *)c;\n\n\tINIT_LIST_HEAD(&cache->cache_list);\n}\n\nint exfat_cache_init(void)\n{\n\texfat_cachep = kmem_cache_create(\"exfat_cache\",\n\t\t\t\tsizeof(struct exfat_cache),\n\t\t\t\t0, SLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD,\n\t\t\t\texfat_cache_init_once);\n\tif (!exfat_cachep)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nvoid exfat_cache_shutdown(void)\n{\n\tif (!exfat_cachep)\n\t\treturn;\n\tkmem_cache_destroy(exfat_cachep);\n}\n\nstatic inline struct exfat_cache *exfat_cache_alloc(void)\n{\n\treturn kmem_cache_alloc(exfat_cachep, GFP_NOFS);\n}\n\nstatic inline void exfat_cache_free(struct exfat_cache *cache)\n{\n\tWARN_ON(!list_empty(&cache->cache_list));\n\tkmem_cache_free(exfat_cachep, cache);\n}\n\nstatic inline void exfat_cache_update_lru(struct inode *inode,\n\t\tstruct exfat_cache *cache)\n{\n\tstruct exfat_inode_info *ei = EXFAT_I(inode);\n\n\tif (ei->cache_lru.next != &cache->cache_list)\n\t\tlist_move(&cache->cache_list, &ei->cache_lru);\n}\n\nstatic unsigned int exfat_cache_lookup(struct inode *inode,\n\t\tunsigned int fclus, struct exfat_cache_id *cid,\n\t\tunsigned int *cached_fclus, unsigned int *cached_dclus)\n{\n\tstruct exfat_inode_info *ei = EXFAT_I(inode);\n\tstatic struct exfat_cache nohit = { .fcluster = 0, };\n\tstruct exfat_cache *hit = &nohit, *p;\n\tunsigned int offset = EXFAT_EOF_CLUSTER;\n\n\tspin_lock(&ei->cache_lru_lock);\n\tlist_for_each_entry(p, &ei->cache_lru, cache_list) {\n\t\t \n\t\tif (p->fcluster <= fclus && hit->fcluster < p->fcluster) {\n\t\t\thit = p;\n\t\t\tif (hit->fcluster + hit->nr_contig < fclus) {\n\t\t\t\toffset = hit->nr_contig;\n\t\t\t} else {\n\t\t\t\toffset = fclus - hit->fcluster;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (hit != &nohit) {\n\t\texfat_cache_update_lru(inode, hit);\n\n\t\tcid->id = ei->cache_valid_id;\n\t\tcid->nr_contig = hit->nr_contig;\n\t\tcid->fcluster = hit->fcluster;\n\t\tcid->dcluster = hit->dcluster;\n\t\t*cached_fclus = cid->fcluster + offset;\n\t\t*cached_dclus = cid->dcluster + offset;\n\t}\n\tspin_unlock(&ei->cache_lru_lock);\n\n\treturn offset;\n}\n\nstatic struct exfat_cache *exfat_cache_merge(struct inode *inode,\n\t\tstruct exfat_cache_id *new)\n{\n\tstruct exfat_inode_info *ei = EXFAT_I(inode);\n\tstruct exfat_cache *p;\n\n\tlist_for_each_entry(p, &ei->cache_lru, cache_list) {\n\t\t \n\t\tif (p->fcluster == new->fcluster) {\n\t\t\tif (new->nr_contig > p->nr_contig)\n\t\t\t\tp->nr_contig = new->nr_contig;\n\t\t\treturn p;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic void exfat_cache_add(struct inode *inode,\n\t\tstruct exfat_cache_id *new)\n{\n\tstruct exfat_inode_info *ei = EXFAT_I(inode);\n\tstruct exfat_cache *cache, *tmp;\n\n\tif (new->fcluster == EXFAT_EOF_CLUSTER)  \n\t\treturn;\n\n\tspin_lock(&ei->cache_lru_lock);\n\tif (new->id != EXFAT_CACHE_VALID &&\n\t    new->id != ei->cache_valid_id)\n\t\tgoto unlock;\t \n\n\tcache = exfat_cache_merge(inode, new);\n\tif (cache == NULL) {\n\t\tif (ei->nr_caches < EXFAT_MAX_CACHE) {\n\t\t\tei->nr_caches++;\n\t\t\tspin_unlock(&ei->cache_lru_lock);\n\n\t\t\ttmp = exfat_cache_alloc();\n\t\t\tif (!tmp) {\n\t\t\t\tspin_lock(&ei->cache_lru_lock);\n\t\t\t\tei->nr_caches--;\n\t\t\t\tspin_unlock(&ei->cache_lru_lock);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tspin_lock(&ei->cache_lru_lock);\n\t\t\tcache = exfat_cache_merge(inode, new);\n\t\t\tif (cache != NULL) {\n\t\t\t\tei->nr_caches--;\n\t\t\t\texfat_cache_free(tmp);\n\t\t\t\tgoto out_update_lru;\n\t\t\t}\n\t\t\tcache = tmp;\n\t\t} else {\n\t\t\tstruct list_head *p = ei->cache_lru.prev;\n\n\t\t\tcache = list_entry(p,\n\t\t\t\t\tstruct exfat_cache, cache_list);\n\t\t}\n\t\tcache->fcluster = new->fcluster;\n\t\tcache->dcluster = new->dcluster;\n\t\tcache->nr_contig = new->nr_contig;\n\t}\nout_update_lru:\n\texfat_cache_update_lru(inode, cache);\nunlock:\n\tspin_unlock(&ei->cache_lru_lock);\n}\n\n \nstatic void __exfat_cache_inval_inode(struct inode *inode)\n{\n\tstruct exfat_inode_info *ei = EXFAT_I(inode);\n\tstruct exfat_cache *cache;\n\n\twhile (!list_empty(&ei->cache_lru)) {\n\t\tcache = list_entry(ei->cache_lru.next,\n\t\t\t\t   struct exfat_cache, cache_list);\n\t\tlist_del_init(&cache->cache_list);\n\t\tei->nr_caches--;\n\t\texfat_cache_free(cache);\n\t}\n\t \n\tei->cache_valid_id++;\n\tif (ei->cache_valid_id == EXFAT_CACHE_VALID)\n\t\tei->cache_valid_id++;\n}\n\nvoid exfat_cache_inval_inode(struct inode *inode)\n{\n\tstruct exfat_inode_info *ei = EXFAT_I(inode);\n\n\tspin_lock(&ei->cache_lru_lock);\n\t__exfat_cache_inval_inode(inode);\n\tspin_unlock(&ei->cache_lru_lock);\n}\n\nstatic inline int cache_contiguous(struct exfat_cache_id *cid,\n\t\tunsigned int dclus)\n{\n\tcid->nr_contig++;\n\treturn cid->dcluster + cid->nr_contig == dclus;\n}\n\nstatic inline void cache_init(struct exfat_cache_id *cid,\n\t\tunsigned int fclus, unsigned int dclus)\n{\n\tcid->id = EXFAT_CACHE_VALID;\n\tcid->fcluster = fclus;\n\tcid->dcluster = dclus;\n\tcid->nr_contig = 0;\n}\n\nint exfat_get_cluster(struct inode *inode, unsigned int cluster,\n\t\tunsigned int *fclus, unsigned int *dclus,\n\t\tunsigned int *last_dclus, int allow_eof)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct exfat_sb_info *sbi = EXFAT_SB(sb);\n\tunsigned int limit = sbi->num_clusters;\n\tstruct exfat_inode_info *ei = EXFAT_I(inode);\n\tstruct exfat_cache_id cid;\n\tunsigned int content;\n\n\tif (ei->start_clu == EXFAT_FREE_CLUSTER) {\n\t\texfat_fs_error(sb,\n\t\t\t\"invalid access to exfat cache (entry 0x%08x)\",\n\t\t\tei->start_clu);\n\t\treturn -EIO;\n\t}\n\n\t*fclus = 0;\n\t*dclus = ei->start_clu;\n\t*last_dclus = *dclus;\n\n\t \n\tif (cluster == 0 || *dclus == EXFAT_EOF_CLUSTER)\n\t\treturn 0;\n\n\tcache_init(&cid, EXFAT_EOF_CLUSTER, EXFAT_EOF_CLUSTER);\n\n\tif (exfat_cache_lookup(inode, cluster, &cid, fclus, dclus) ==\n\t\t\tEXFAT_EOF_CLUSTER) {\n\t\t \n\t\tWARN_ON(cid.id != EXFAT_CACHE_VALID ||\n\t\t\tcid.fcluster != EXFAT_EOF_CLUSTER ||\n\t\t\tcid.dcluster != EXFAT_EOF_CLUSTER ||\n\t\t\tcid.nr_contig != 0);\n\t}\n\n\tif (*fclus == cluster)\n\t\treturn 0;\n\n\twhile (*fclus < cluster) {\n\t\t \n\t\tif (*fclus > limit) {\n\t\t\texfat_fs_error(sb,\n\t\t\t\t\"detected the cluster chain loop (i_pos %u)\",\n\t\t\t\t(*fclus));\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (exfat_ent_get(sb, *dclus, &content))\n\t\t\treturn -EIO;\n\n\t\t*last_dclus = *dclus;\n\t\t*dclus = content;\n\t\t(*fclus)++;\n\n\t\tif (content == EXFAT_EOF_CLUSTER) {\n\t\t\tif (!allow_eof) {\n\t\t\t\texfat_fs_error(sb,\n\t\t\t\t       \"invalid cluster chain (i_pos %u, last_clus 0x%08x is EOF)\",\n\t\t\t\t       *fclus, (*last_dclus));\n\t\t\t\treturn -EIO;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!cache_contiguous(&cid, *dclus))\n\t\t\tcache_init(&cid, *fclus, *dclus);\n\t}\n\n\texfat_cache_add(inode, &cid);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}