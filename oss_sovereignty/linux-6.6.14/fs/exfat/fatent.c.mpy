{
  "module_name": "fatent.c",
  "hash_id": "27e56a2ba548cee3512a61fd9f5fe52fb4dc68635dd47da44005afdecde7c544",
  "original_prompt": "Ingested from linux-6.6.14/fs/exfat/fatent.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <asm/unaligned.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n\n#include \"exfat_raw.h\"\n#include \"exfat_fs.h\"\n\nstatic int exfat_mirror_bh(struct super_block *sb, sector_t sec,\n\t\tstruct buffer_head *bh)\n{\n\tstruct buffer_head *c_bh;\n\tstruct exfat_sb_info *sbi = EXFAT_SB(sb);\n\tsector_t sec2;\n\tint err = 0;\n\n\tif (sbi->FAT2_start_sector != sbi->FAT1_start_sector) {\n\t\tsec2 = sec - sbi->FAT1_start_sector + sbi->FAT2_start_sector;\n\t\tc_bh = sb_getblk(sb, sec2);\n\t\tif (!c_bh)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy(c_bh->b_data, bh->b_data, sb->s_blocksize);\n\t\tset_buffer_uptodate(c_bh);\n\t\tmark_buffer_dirty(c_bh);\n\t\tif (sb->s_flags & SB_SYNCHRONOUS)\n\t\t\terr = sync_dirty_buffer(c_bh);\n\t\tbrelse(c_bh);\n\t}\n\n\treturn err;\n}\n\nstatic int __exfat_ent_get(struct super_block *sb, unsigned int loc,\n\t\tunsigned int *content)\n{\n\tunsigned int off;\n\tsector_t sec;\n\tstruct buffer_head *bh;\n\n\tsec = FAT_ENT_OFFSET_SECTOR(sb, loc);\n\toff = FAT_ENT_OFFSET_BYTE_IN_SECTOR(sb, loc);\n\n\tbh = sb_bread(sb, sec);\n\tif (!bh)\n\t\treturn -EIO;\n\n\t*content = le32_to_cpu(*(__le32 *)(&bh->b_data[off]));\n\n\t \n\tif (*content > EXFAT_BAD_CLUSTER)\n\t\t*content = EXFAT_EOF_CLUSTER;\n\n\tbrelse(bh);\n\treturn 0;\n}\n\nint exfat_ent_set(struct super_block *sb, unsigned int loc,\n\t\tunsigned int content)\n{\n\tunsigned int off;\n\tsector_t sec;\n\t__le32 *fat_entry;\n\tstruct buffer_head *bh;\n\n\tsec = FAT_ENT_OFFSET_SECTOR(sb, loc);\n\toff = FAT_ENT_OFFSET_BYTE_IN_SECTOR(sb, loc);\n\n\tbh = sb_bread(sb, sec);\n\tif (!bh)\n\t\treturn -EIO;\n\n\tfat_entry = (__le32 *)&(bh->b_data[off]);\n\t*fat_entry = cpu_to_le32(content);\n\texfat_update_bh(bh, sb->s_flags & SB_SYNCHRONOUS);\n\texfat_mirror_bh(sb, sec, bh);\n\tbrelse(bh);\n\treturn 0;\n}\n\nint exfat_ent_get(struct super_block *sb, unsigned int loc,\n\t\tunsigned int *content)\n{\n\tstruct exfat_sb_info *sbi = EXFAT_SB(sb);\n\tint err;\n\n\tif (!is_valid_cluster(sbi, loc)) {\n\t\texfat_fs_error(sb, \"invalid access to FAT (entry 0x%08x)\",\n\t\t\tloc);\n\t\treturn -EIO;\n\t}\n\n\terr = __exfat_ent_get(sb, loc, content);\n\tif (err) {\n\t\texfat_fs_error(sb,\n\t\t\t\"failed to access to FAT (entry 0x%08x, err:%d)\",\n\t\t\tloc, err);\n\t\treturn err;\n\t}\n\n\tif (*content == EXFAT_FREE_CLUSTER) {\n\t\texfat_fs_error(sb,\n\t\t\t\"invalid access to FAT free cluster (entry 0x%08x)\",\n\t\t\tloc);\n\t\treturn -EIO;\n\t}\n\n\tif (*content == EXFAT_BAD_CLUSTER) {\n\t\texfat_fs_error(sb,\n\t\t\t\"invalid access to FAT bad cluster (entry 0x%08x)\",\n\t\t\tloc);\n\t\treturn -EIO;\n\t}\n\n\tif (*content != EXFAT_EOF_CLUSTER && !is_valid_cluster(sbi, *content)) {\n\t\texfat_fs_error(sb,\n\t\t\t\"invalid access to FAT (entry 0x%08x) bogus content (0x%08x)\",\n\t\t\tloc, *content);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nint exfat_chain_cont_cluster(struct super_block *sb, unsigned int chain,\n\t\tunsigned int len)\n{\n\tif (!len)\n\t\treturn 0;\n\n\twhile (len > 1) {\n\t\tif (exfat_ent_set(sb, chain, chain + 1))\n\t\t\treturn -EIO;\n\t\tchain++;\n\t\tlen--;\n\t}\n\n\tif (exfat_ent_set(sb, chain, EXFAT_EOF_CLUSTER))\n\t\treturn -EIO;\n\treturn 0;\n}\n\n \nstatic int __exfat_free_cluster(struct inode *inode, struct exfat_chain *p_chain)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct exfat_sb_info *sbi = EXFAT_SB(sb);\n\tint cur_cmap_i, next_cmap_i;\n\tunsigned int num_clusters = 0;\n\tunsigned int clu;\n\n\t \n\tif (p_chain->dir == EXFAT_FREE_CLUSTER ||\n\t    p_chain->dir == EXFAT_EOF_CLUSTER ||\n\t    p_chain->dir < EXFAT_FIRST_CLUSTER)\n\t\treturn 0;\n\n\t \n\tif (p_chain->size == 0)\n\t\treturn 0;\n\n\t \n\tif (!is_valid_cluster(sbi, p_chain->dir)) {\n\t\texfat_err(sb, \"invalid start cluster (%u)\", p_chain->dir);\n\t\treturn -EIO;\n\t}\n\n\tclu = p_chain->dir;\n\n\tcur_cmap_i = next_cmap_i =\n\t\tBITMAP_OFFSET_SECTOR_INDEX(sb, CLUSTER_TO_BITMAP_ENT(clu));\n\n\tif (p_chain->flags == ALLOC_NO_FAT_CHAIN) {\n\t\tunsigned int last_cluster = p_chain->dir + p_chain->size - 1;\n\t\tdo {\n\t\t\tbool sync = false;\n\n\t\t\tif (clu < last_cluster)\n\t\t\t\tnext_cmap_i =\n\t\t\t\t  BITMAP_OFFSET_SECTOR_INDEX(sb, CLUSTER_TO_BITMAP_ENT(clu+1));\n\n\t\t\t \n\t\t\tif (clu == last_cluster || cur_cmap_i != next_cmap_i) {\n\t\t\t\tsync = true;\n\t\t\t\tcur_cmap_i = next_cmap_i;\n\t\t\t}\n\n\t\t\texfat_clear_bitmap(inode, clu, (sync && IS_DIRSYNC(inode)));\n\t\t\tclu++;\n\t\t\tnum_clusters++;\n\t\t} while (num_clusters < p_chain->size);\n\t} else {\n\t\tdo {\n\t\t\tbool sync = false;\n\t\t\tunsigned int n_clu = clu;\n\t\t\tint err = exfat_get_next_cluster(sb, &n_clu);\n\n\t\t\tif (err || n_clu == EXFAT_EOF_CLUSTER)\n\t\t\t\tsync = true;\n\t\t\telse\n\t\t\t\tnext_cmap_i =\n\t\t\t\t  BITMAP_OFFSET_SECTOR_INDEX(sb, CLUSTER_TO_BITMAP_ENT(n_clu));\n\n\t\t\tif (cur_cmap_i != next_cmap_i) {\n\t\t\t\tsync = true;\n\t\t\t\tcur_cmap_i = next_cmap_i;\n\t\t\t}\n\n\t\t\texfat_clear_bitmap(inode, clu, (sync && IS_DIRSYNC(inode)));\n\t\t\tclu = n_clu;\n\t\t\tnum_clusters++;\n\n\t\t\tif (err)\n\t\t\t\tgoto dec_used_clus;\n\t\t} while (clu != EXFAT_EOF_CLUSTER);\n\t}\n\ndec_used_clus:\n\tsbi->used_clusters -= num_clusters;\n\treturn 0;\n}\n\nint exfat_free_cluster(struct inode *inode, struct exfat_chain *p_chain)\n{\n\tint ret = 0;\n\n\tmutex_lock(&EXFAT_SB(inode->i_sb)->bitmap_lock);\n\tret = __exfat_free_cluster(inode, p_chain);\n\tmutex_unlock(&EXFAT_SB(inode->i_sb)->bitmap_lock);\n\n\treturn ret;\n}\n\nint exfat_find_last_cluster(struct super_block *sb, struct exfat_chain *p_chain,\n\t\tunsigned int *ret_clu)\n{\n\tunsigned int clu, next;\n\tunsigned int count = 0;\n\n\tnext = p_chain->dir;\n\tif (p_chain->flags == ALLOC_NO_FAT_CHAIN) {\n\t\t*ret_clu = next + p_chain->size - 1;\n\t\treturn 0;\n\t}\n\n\tdo {\n\t\tcount++;\n\t\tclu = next;\n\t\tif (exfat_ent_get(sb, clu, &next))\n\t\t\treturn -EIO;\n\t} while (next != EXFAT_EOF_CLUSTER);\n\n\tif (p_chain->size != count) {\n\t\texfat_fs_error(sb,\n\t\t\t\"bogus directory size (clus : ondisk(%d) != counted(%d))\",\n\t\t\tp_chain->size, count);\n\t\treturn -EIO;\n\t}\n\n\t*ret_clu = clu;\n\treturn 0;\n}\n\nint exfat_zeroed_cluster(struct inode *dir, unsigned int clu)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct exfat_sb_info *sbi = EXFAT_SB(sb);\n\tstruct buffer_head *bh;\n\tsector_t blknr, last_blknr, i;\n\n\tblknr = exfat_cluster_to_sector(sbi, clu);\n\tlast_blknr = blknr + sbi->sect_per_clus;\n\n\tif (last_blknr > sbi->num_sectors && sbi->num_sectors > 0) {\n\t\texfat_fs_error_ratelimit(sb,\n\t\t\t\"%s: out of range(sect:%llu len:%u)\",\n\t\t\t__func__, (unsigned long long)blknr,\n\t\t\tsbi->sect_per_clus);\n\t\treturn -EIO;\n\t}\n\n\t \n\tfor (i = blknr; i < last_blknr; i++) {\n\t\tbh = sb_getblk(sb, i);\n\t\tif (!bh)\n\t\t\treturn -ENOMEM;\n\n\t\tmemset(bh->b_data, 0, sb->s_blocksize);\n\t\tset_buffer_uptodate(bh);\n\t\tmark_buffer_dirty(bh);\n\t\tbrelse(bh);\n\t}\n\n\tif (IS_DIRSYNC(dir))\n\t\treturn sync_blockdev_range(sb->s_bdev,\n\t\t\t\tEXFAT_BLK_TO_B(blknr, sb),\n\t\t\t\tEXFAT_BLK_TO_B(last_blknr, sb) - 1);\n\n\treturn 0;\n}\n\nint exfat_alloc_cluster(struct inode *inode, unsigned int num_alloc,\n\t\tstruct exfat_chain *p_chain, bool sync_bmap)\n{\n\tint ret = -ENOSPC;\n\tunsigned int total_cnt;\n\tunsigned int hint_clu, new_clu, last_clu = EXFAT_EOF_CLUSTER;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct exfat_sb_info *sbi = EXFAT_SB(sb);\n\n\ttotal_cnt = EXFAT_DATA_CLUSTER_COUNT(sbi);\n\n\tif (unlikely(total_cnt < sbi->used_clusters)) {\n\t\texfat_fs_error_ratelimit(sb,\n\t\t\t\"%s: invalid used clusters(t:%u,u:%u)\\n\",\n\t\t\t__func__, total_cnt, sbi->used_clusters);\n\t\treturn -EIO;\n\t}\n\n\tif (num_alloc > total_cnt - sbi->used_clusters)\n\t\treturn -ENOSPC;\n\n\tmutex_lock(&sbi->bitmap_lock);\n\n\thint_clu = p_chain->dir;\n\t \n\tif (hint_clu == EXFAT_EOF_CLUSTER) {\n\t\tif (sbi->clu_srch_ptr < EXFAT_FIRST_CLUSTER) {\n\t\t\texfat_err(sb, \"sbi->clu_srch_ptr is invalid (%u)\",\n\t\t\t\t  sbi->clu_srch_ptr);\n\t\t\tsbi->clu_srch_ptr = EXFAT_FIRST_CLUSTER;\n\t\t}\n\n\t\thint_clu = exfat_find_free_bitmap(sb, sbi->clu_srch_ptr);\n\t\tif (hint_clu == EXFAT_EOF_CLUSTER) {\n\t\t\tret = -ENOSPC;\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\t \n\tif (!is_valid_cluster(sbi, hint_clu)) {\n\t\tif (hint_clu != sbi->num_clusters)\n\t\t\texfat_err(sb, \"hint_cluster is invalid (%u), rewind to the first cluster\",\n\t\t\t\t\thint_clu);\n\t\thint_clu = EXFAT_FIRST_CLUSTER;\n\t\tp_chain->flags = ALLOC_FAT_CHAIN;\n\t}\n\n\tp_chain->dir = EXFAT_EOF_CLUSTER;\n\n\twhile ((new_clu = exfat_find_free_bitmap(sb, hint_clu)) !=\n\t       EXFAT_EOF_CLUSTER) {\n\t\tif (new_clu != hint_clu &&\n\t\t    p_chain->flags == ALLOC_NO_FAT_CHAIN) {\n\t\t\tif (exfat_chain_cont_cluster(sb, p_chain->dir,\n\t\t\t\t\tp_chain->size)) {\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto free_cluster;\n\t\t\t}\n\t\t\tp_chain->flags = ALLOC_FAT_CHAIN;\n\t\t}\n\n\t\t \n\t\tif (exfat_set_bitmap(inode, new_clu, sync_bmap)) {\n\t\t\tret = -EIO;\n\t\t\tgoto free_cluster;\n\t\t}\n\n\t\t \n\t\tif (p_chain->flags == ALLOC_FAT_CHAIN) {\n\t\t\tif (exfat_ent_set(sb, new_clu, EXFAT_EOF_CLUSTER)) {\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto free_cluster;\n\t\t\t}\n\t\t}\n\n\t\tif (p_chain->dir == EXFAT_EOF_CLUSTER) {\n\t\t\tp_chain->dir = new_clu;\n\t\t} else if (p_chain->flags == ALLOC_FAT_CHAIN) {\n\t\t\tif (exfat_ent_set(sb, last_clu, new_clu)) {\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto free_cluster;\n\t\t\t}\n\t\t}\n\t\tp_chain->size++;\n\n\t\tlast_clu = new_clu;\n\n\t\tif (p_chain->size == num_alloc) {\n\t\t\tsbi->clu_srch_ptr = hint_clu;\n\t\t\tsbi->used_clusters += num_alloc;\n\n\t\t\tmutex_unlock(&sbi->bitmap_lock);\n\t\t\treturn 0;\n\t\t}\n\n\t\thint_clu = new_clu + 1;\n\t\tif (hint_clu >= sbi->num_clusters) {\n\t\t\thint_clu = EXFAT_FIRST_CLUSTER;\n\n\t\t\tif (p_chain->flags == ALLOC_NO_FAT_CHAIN) {\n\t\t\t\tif (exfat_chain_cont_cluster(sb, p_chain->dir,\n\t\t\t\t\t\tp_chain->size)) {\n\t\t\t\t\tret = -EIO;\n\t\t\t\t\tgoto free_cluster;\n\t\t\t\t}\n\t\t\t\tp_chain->flags = ALLOC_FAT_CHAIN;\n\t\t\t}\n\t\t}\n\t}\nfree_cluster:\n\t__exfat_free_cluster(inode, p_chain);\nunlock:\n\tmutex_unlock(&sbi->bitmap_lock);\n\treturn ret;\n}\n\nint exfat_count_num_clusters(struct super_block *sb,\n\t\tstruct exfat_chain *p_chain, unsigned int *ret_count)\n{\n\tunsigned int i, count;\n\tunsigned int clu;\n\tstruct exfat_sb_info *sbi = EXFAT_SB(sb);\n\n\tif (!p_chain->dir || p_chain->dir == EXFAT_EOF_CLUSTER) {\n\t\t*ret_count = 0;\n\t\treturn 0;\n\t}\n\n\tif (p_chain->flags == ALLOC_NO_FAT_CHAIN) {\n\t\t*ret_count = p_chain->size;\n\t\treturn 0;\n\t}\n\n\tclu = p_chain->dir;\n\tcount = 0;\n\tfor (i = EXFAT_FIRST_CLUSTER; i < sbi->num_clusters; i++) {\n\t\tcount++;\n\t\tif (exfat_ent_get(sb, clu, &clu))\n\t\t\treturn -EIO;\n\t\tif (clu == EXFAT_EOF_CLUSTER)\n\t\t\tbreak;\n\t}\n\n\t*ret_count = count;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}