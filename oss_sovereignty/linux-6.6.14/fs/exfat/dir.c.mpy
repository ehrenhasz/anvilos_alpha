{
  "module_name": "dir.c",
  "hash_id": "460def43365da4777b79f4d2a3e2035ac5614b72d7bf9fa6a67ee38af310476f",
  "original_prompt": "Ingested from linux-6.6.14/fs/exfat/dir.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n\n#include \"exfat_raw.h\"\n#include \"exfat_fs.h\"\n\nstatic int exfat_extract_uni_name(struct exfat_dentry *ep,\n\t\tunsigned short *uniname)\n{\n\tint i, len = 0;\n\n\tfor (i = 0; i < EXFAT_FILE_NAME_LEN; i++) {\n\t\t*uniname = le16_to_cpu(ep->dentry.name.unicode_0_14[i]);\n\t\tif (*uniname == 0x0)\n\t\t\treturn len;\n\t\tuniname++;\n\t\tlen++;\n\t}\n\n\t*uniname = 0x0;\n\treturn len;\n\n}\n\nstatic int exfat_get_uniname_from_ext_entry(struct super_block *sb,\n\t\tstruct exfat_chain *p_dir, int entry, unsigned short *uniname)\n{\n\tint i, err;\n\tstruct exfat_entry_set_cache es;\n\tunsigned int uni_len = 0, len;\n\n\terr = exfat_get_dentry_set(&es, sb, p_dir, entry, ES_ALL_ENTRIES);\n\tif (err)\n\t\treturn err;\n\n\t \n\tfor (i = ES_IDX_FIRST_FILENAME; i < es.num_entries; i++) {\n\t\tstruct exfat_dentry *ep = exfat_get_dentry_cached(&es, i);\n\n\t\t \n\t\tif (exfat_get_entry_type(ep) != TYPE_EXTEND)\n\t\t\tbreak;\n\n\t\tlen = exfat_extract_uni_name(ep, uniname);\n\t\tuni_len += len;\n\t\tif (len != EXFAT_FILE_NAME_LEN || uni_len >= MAX_NAME_LENGTH)\n\t\t\tbreak;\n\t\tuniname += EXFAT_FILE_NAME_LEN;\n\t}\n\n\texfat_put_dentry_set(&es, false);\n\treturn 0;\n}\n\n \nstatic int exfat_readdir(struct inode *inode, loff_t *cpos, struct exfat_dir_entry *dir_entry)\n{\n\tint i, dentries_per_clu, num_ext, err;\n\tunsigned int type, clu_offset, max_dentries;\n\tstruct exfat_chain dir, clu;\n\tstruct exfat_uni_name uni_name;\n\tstruct exfat_dentry *ep;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct exfat_sb_info *sbi = EXFAT_SB(sb);\n\tstruct exfat_inode_info *ei = EXFAT_I(inode);\n\tunsigned int dentry = EXFAT_B_TO_DEN(*cpos) & 0xFFFFFFFF;\n\tstruct buffer_head *bh;\n\n\t \n\tif (ei->type != TYPE_DIR)\n\t\treturn -EPERM;\n\n\tif (ei->entry == -1)\n\t\texfat_chain_set(&dir, sbi->root_dir, 0, ALLOC_FAT_CHAIN);\n\telse\n\t\texfat_chain_set(&dir, ei->start_clu,\n\t\t\tEXFAT_B_TO_CLU(i_size_read(inode), sbi), ei->flags);\n\n\tdentries_per_clu = sbi->dentries_per_clu;\n\tmax_dentries = (unsigned int)min_t(u64, MAX_EXFAT_DENTRIES,\n\t\t\t\t(u64)EXFAT_CLU_TO_DEN(sbi->num_clusters, sbi));\n\n\tclu_offset = EXFAT_DEN_TO_CLU(dentry, sbi);\n\texfat_chain_dup(&clu, &dir);\n\n\tif (clu.flags == ALLOC_NO_FAT_CHAIN) {\n\t\tclu.dir += clu_offset;\n\t\tclu.size -= clu_offset;\n\t} else {\n\t\t \n\t\tif (clu_offset > 0 && ei->hint_bmap.off != EXFAT_EOF_CLUSTER &&\n\t\t    ei->hint_bmap.off > 0 && clu_offset >= ei->hint_bmap.off) {\n\t\t\tclu_offset -= ei->hint_bmap.off;\n\t\t\tclu.dir = ei->hint_bmap.clu;\n\t\t}\n\n\t\twhile (clu_offset > 0 && clu.dir != EXFAT_EOF_CLUSTER) {\n\t\t\tif (exfat_get_next_cluster(sb, &(clu.dir)))\n\t\t\t\treturn -EIO;\n\n\t\t\tclu_offset--;\n\t\t}\n\t}\n\n\twhile (clu.dir != EXFAT_EOF_CLUSTER && dentry < max_dentries) {\n\t\ti = dentry & (dentries_per_clu - 1);\n\n\t\tfor ( ; i < dentries_per_clu; i++, dentry++) {\n\t\t\tep = exfat_get_dentry(sb, &clu, i, &bh);\n\t\t\tif (!ep)\n\t\t\t\treturn -EIO;\n\n\t\t\ttype = exfat_get_entry_type(ep);\n\t\t\tif (type == TYPE_UNUSED) {\n\t\t\t\tbrelse(bh);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (type != TYPE_FILE && type != TYPE_DIR) {\n\t\t\t\tbrelse(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnum_ext = ep->dentry.file.num_ext;\n\t\t\tdir_entry->attr = le16_to_cpu(ep->dentry.file.attr);\n\t\t\texfat_get_entry_time(sbi, &dir_entry->crtime,\n\t\t\t\t\tep->dentry.file.create_tz,\n\t\t\t\t\tep->dentry.file.create_time,\n\t\t\t\t\tep->dentry.file.create_date,\n\t\t\t\t\tep->dentry.file.create_time_cs);\n\t\t\texfat_get_entry_time(sbi, &dir_entry->mtime,\n\t\t\t\t\tep->dentry.file.modify_tz,\n\t\t\t\t\tep->dentry.file.modify_time,\n\t\t\t\t\tep->dentry.file.modify_date,\n\t\t\t\t\tep->dentry.file.modify_time_cs);\n\t\t\texfat_get_entry_time(sbi, &dir_entry->atime,\n\t\t\t\t\tep->dentry.file.access_tz,\n\t\t\t\t\tep->dentry.file.access_time,\n\t\t\t\t\tep->dentry.file.access_date,\n\t\t\t\t\t0);\n\n\t\t\t*uni_name.name = 0x0;\n\t\t\terr = exfat_get_uniname_from_ext_entry(sb, &clu, i,\n\t\t\t\tuni_name.name);\n\t\t\tif (err) {\n\t\t\t\tbrelse(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\texfat_utf16_to_nls(sb, &uni_name,\n\t\t\t\tdir_entry->namebuf.lfn,\n\t\t\t\tdir_entry->namebuf.lfnbuf_len);\n\t\t\tbrelse(bh);\n\n\t\t\tep = exfat_get_dentry(sb, &clu, i + 1, &bh);\n\t\t\tif (!ep)\n\t\t\t\treturn -EIO;\n\t\t\tdir_entry->size =\n\t\t\t\tle64_to_cpu(ep->dentry.stream.valid_size);\n\t\t\tdir_entry->entry = dentry;\n\t\t\tbrelse(bh);\n\n\t\t\tei->hint_bmap.off = EXFAT_DEN_TO_CLU(dentry, sbi);\n\t\t\tei->hint_bmap.clu = clu.dir;\n\n\t\t\t*cpos = EXFAT_DEN_TO_B(dentry + 1 + num_ext);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (clu.flags == ALLOC_NO_FAT_CHAIN) {\n\t\t\tif (--clu.size > 0)\n\t\t\t\tclu.dir++;\n\t\t\telse\n\t\t\t\tclu.dir = EXFAT_EOF_CLUSTER;\n\t\t} else {\n\t\t\tif (exfat_get_next_cluster(sb, &(clu.dir)))\n\t\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tdir_entry->namebuf.lfn[0] = '\\0';\n\t*cpos = EXFAT_DEN_TO_B(dentry);\n\treturn 0;\n}\n\nstatic void exfat_init_namebuf(struct exfat_dentry_namebuf *nb)\n{\n\tnb->lfn = NULL;\n\tnb->lfnbuf_len = 0;\n}\n\nstatic int exfat_alloc_namebuf(struct exfat_dentry_namebuf *nb)\n{\n\tnb->lfn = __getname();\n\tif (!nb->lfn)\n\t\treturn -ENOMEM;\n\tnb->lfnbuf_len = MAX_VFSNAME_BUF_SIZE;\n\treturn 0;\n}\n\nstatic void exfat_free_namebuf(struct exfat_dentry_namebuf *nb)\n{\n\tif (!nb->lfn)\n\t\treturn;\n\n\t__putname(nb->lfn);\n\texfat_init_namebuf(nb);\n}\n\n \n#define ITER_POS_FILLED_DOTS    (2)\nstatic int exfat_iterate(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct inode *tmp;\n\tstruct exfat_dir_entry de;\n\tstruct exfat_dentry_namebuf *nb = &(de.namebuf);\n\tstruct exfat_inode_info *ei = EXFAT_I(inode);\n\tunsigned long inum;\n\tloff_t cpos, i_pos;\n\tint err = 0, fake_offset = 0;\n\n\texfat_init_namebuf(nb);\n\n\tcpos = ctx->pos;\n\tif (!dir_emit_dots(file, ctx))\n\t\tgoto out;\n\n\tif (ctx->pos == ITER_POS_FILLED_DOTS) {\n\t\tcpos = 0;\n\t\tfake_offset = 1;\n\t}\n\n\tcpos = round_up(cpos, DENTRY_SIZE);\n\n\t \n\terr = exfat_alloc_namebuf(nb);\n\tif (err)\n\t\tgoto out;\nget_new:\n\tmutex_lock(&EXFAT_SB(sb)->s_lock);\n\n\tif (ei->flags == ALLOC_NO_FAT_CHAIN && cpos >= i_size_read(inode))\n\t\tgoto end_of_dir;\n\n\terr = exfat_readdir(inode, &cpos, &de);\n\tif (err) {\n\t\t \n\t\tif (err == -EIO) {\n\t\t\tcpos += 1 << (sb->s_blocksize_bits);\n\t\t\tcpos &= ~(sb->s_blocksize - 1);\n\t\t}\n\n\t\terr = -EIO;\n\t\tgoto end_of_dir;\n\t}\n\n\tif (!nb->lfn[0])\n\t\tgoto end_of_dir;\n\n\ti_pos = ((loff_t)ei->start_clu << 32) |\t(de.entry & 0xffffffff);\n\ttmp = exfat_iget(sb, i_pos);\n\tif (tmp) {\n\t\tinum = tmp->i_ino;\n\t\tiput(tmp);\n\t} else {\n\t\tinum = iunique(sb, EXFAT_ROOT_INO);\n\t}\n\n\tmutex_unlock(&EXFAT_SB(sb)->s_lock);\n\tif (!dir_emit(ctx, nb->lfn, strlen(nb->lfn), inum,\n\t\t\t(de.attr & ATTR_SUBDIR) ? DT_DIR : DT_REG))\n\t\tgoto out;\n\tctx->pos = cpos;\n\tgoto get_new;\n\nend_of_dir:\n\tif (!cpos && fake_offset)\n\t\tcpos = ITER_POS_FILLED_DOTS;\n\tctx->pos = cpos;\n\tmutex_unlock(&EXFAT_SB(sb)->s_lock);\nout:\n\t \n\texfat_free_namebuf(nb);\n\treturn err;\n}\n\nWRAP_DIR_ITER(exfat_iterate) \nconst struct file_operations exfat_dir_operations = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= generic_read_dir,\n\t.iterate_shared\t= shared_exfat_iterate,\n\t.unlocked_ioctl = exfat_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl = exfat_compat_ioctl,\n#endif\n\t.fsync\t\t= exfat_file_fsync,\n};\n\nint exfat_alloc_new_dir(struct inode *inode, struct exfat_chain *clu)\n{\n\tint ret;\n\n\texfat_chain_set(clu, EXFAT_EOF_CLUSTER, 0, ALLOC_NO_FAT_CHAIN);\n\n\tret = exfat_alloc_cluster(inode, 1, clu, IS_DIRSYNC(inode));\n\tif (ret)\n\t\treturn ret;\n\n\treturn exfat_zeroed_cluster(inode, clu->dir);\n}\n\nint exfat_calc_num_entries(struct exfat_uni_name *p_uniname)\n{\n\tint len;\n\n\tlen = p_uniname->name_len;\n\tif (len == 0)\n\t\treturn -EINVAL;\n\n\t \n\treturn ES_ENTRY_NUM(len);\n}\n\nunsigned int exfat_get_entry_type(struct exfat_dentry *ep)\n{\n\tif (ep->type == EXFAT_UNUSED)\n\t\treturn TYPE_UNUSED;\n\tif (IS_EXFAT_DELETED(ep->type))\n\t\treturn TYPE_DELETED;\n\tif (ep->type == EXFAT_INVAL)\n\t\treturn TYPE_INVALID;\n\tif (IS_EXFAT_CRITICAL_PRI(ep->type)) {\n\t\tif (ep->type == EXFAT_BITMAP)\n\t\t\treturn TYPE_BITMAP;\n\t\tif (ep->type == EXFAT_UPCASE)\n\t\t\treturn TYPE_UPCASE;\n\t\tif (ep->type == EXFAT_VOLUME)\n\t\t\treturn TYPE_VOLUME;\n\t\tif (ep->type == EXFAT_FILE) {\n\t\t\tif (le16_to_cpu(ep->dentry.file.attr) & ATTR_SUBDIR)\n\t\t\t\treturn TYPE_DIR;\n\t\t\treturn TYPE_FILE;\n\t\t}\n\t\treturn TYPE_CRITICAL_PRI;\n\t}\n\tif (IS_EXFAT_BENIGN_PRI(ep->type)) {\n\t\tif (ep->type == EXFAT_GUID)\n\t\t\treturn TYPE_GUID;\n\t\tif (ep->type == EXFAT_PADDING)\n\t\t\treturn TYPE_PADDING;\n\t\tif (ep->type == EXFAT_ACLTAB)\n\t\t\treturn TYPE_ACLTAB;\n\t\treturn TYPE_BENIGN_PRI;\n\t}\n\tif (IS_EXFAT_CRITICAL_SEC(ep->type)) {\n\t\tif (ep->type == EXFAT_STREAM)\n\t\t\treturn TYPE_STREAM;\n\t\tif (ep->type == EXFAT_NAME)\n\t\t\treturn TYPE_EXTEND;\n\t\tif (ep->type == EXFAT_ACL)\n\t\t\treturn TYPE_ACL;\n\t\treturn TYPE_CRITICAL_SEC;\n\t}\n\n\tif (ep->type == EXFAT_VENDOR_EXT)\n\t\treturn TYPE_VENDOR_EXT;\n\tif (ep->type == EXFAT_VENDOR_ALLOC)\n\t\treturn TYPE_VENDOR_ALLOC;\n\n\treturn TYPE_BENIGN_SEC;\n}\n\nstatic void exfat_set_entry_type(struct exfat_dentry *ep, unsigned int type)\n{\n\tif (type == TYPE_UNUSED) {\n\t\tep->type = EXFAT_UNUSED;\n\t} else if (type == TYPE_DELETED) {\n\t\tep->type &= EXFAT_DELETE;\n\t} else if (type == TYPE_STREAM) {\n\t\tep->type = EXFAT_STREAM;\n\t} else if (type == TYPE_EXTEND) {\n\t\tep->type = EXFAT_NAME;\n\t} else if (type == TYPE_BITMAP) {\n\t\tep->type = EXFAT_BITMAP;\n\t} else if (type == TYPE_UPCASE) {\n\t\tep->type = EXFAT_UPCASE;\n\t} else if (type == TYPE_VOLUME) {\n\t\tep->type = EXFAT_VOLUME;\n\t} else if (type == TYPE_DIR) {\n\t\tep->type = EXFAT_FILE;\n\t\tep->dentry.file.attr = cpu_to_le16(ATTR_SUBDIR);\n\t} else if (type == TYPE_FILE) {\n\t\tep->type = EXFAT_FILE;\n\t\tep->dentry.file.attr = cpu_to_le16(ATTR_ARCHIVE);\n\t}\n}\n\nstatic void exfat_init_stream_entry(struct exfat_dentry *ep,\n\t\tunsigned char flags, unsigned int start_clu,\n\t\tunsigned long long size)\n{\n\texfat_set_entry_type(ep, TYPE_STREAM);\n\tep->dentry.stream.flags = flags;\n\tep->dentry.stream.start_clu = cpu_to_le32(start_clu);\n\tep->dentry.stream.valid_size = cpu_to_le64(size);\n\tep->dentry.stream.size = cpu_to_le64(size);\n}\n\nstatic void exfat_init_name_entry(struct exfat_dentry *ep,\n\t\tunsigned short *uniname)\n{\n\tint i;\n\n\texfat_set_entry_type(ep, TYPE_EXTEND);\n\tep->dentry.name.flags = 0x0;\n\n\tfor (i = 0; i < EXFAT_FILE_NAME_LEN; i++) {\n\t\tif (*uniname != 0x0) {\n\t\t\tep->dentry.name.unicode_0_14[i] = cpu_to_le16(*uniname);\n\t\t\tuniname++;\n\t\t} else {\n\t\t\tep->dentry.name.unicode_0_14[i] = 0x0;\n\t\t}\n\t}\n}\n\nint exfat_init_dir_entry(struct inode *inode, struct exfat_chain *p_dir,\n\t\tint entry, unsigned int type, unsigned int start_clu,\n\t\tunsigned long long size)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct exfat_sb_info *sbi = EXFAT_SB(sb);\n\tstruct timespec64 ts = current_time(inode);\n\tstruct exfat_dentry *ep;\n\tstruct buffer_head *bh;\n\n\t \n\tep = exfat_get_dentry(sb, p_dir, entry, &bh);\n\tif (!ep)\n\t\treturn -EIO;\n\n\texfat_set_entry_type(ep, type);\n\texfat_set_entry_time(sbi, &ts,\n\t\t\t&ep->dentry.file.create_tz,\n\t\t\t&ep->dentry.file.create_time,\n\t\t\t&ep->dentry.file.create_date,\n\t\t\t&ep->dentry.file.create_time_cs);\n\texfat_set_entry_time(sbi, &ts,\n\t\t\t&ep->dentry.file.modify_tz,\n\t\t\t&ep->dentry.file.modify_time,\n\t\t\t&ep->dentry.file.modify_date,\n\t\t\t&ep->dentry.file.modify_time_cs);\n\texfat_set_entry_time(sbi, &ts,\n\t\t\t&ep->dentry.file.access_tz,\n\t\t\t&ep->dentry.file.access_time,\n\t\t\t&ep->dentry.file.access_date,\n\t\t\tNULL);\n\n\texfat_update_bh(bh, IS_DIRSYNC(inode));\n\tbrelse(bh);\n\n\tep = exfat_get_dentry(sb, p_dir, entry + 1, &bh);\n\tif (!ep)\n\t\treturn -EIO;\n\n\texfat_init_stream_entry(ep,\n\t\t(type == TYPE_FILE) ? ALLOC_FAT_CHAIN : ALLOC_NO_FAT_CHAIN,\n\t\tstart_clu, size);\n\texfat_update_bh(bh, IS_DIRSYNC(inode));\n\tbrelse(bh);\n\n\treturn 0;\n}\n\nint exfat_update_dir_chksum(struct inode *inode, struct exfat_chain *p_dir,\n\t\tint entry)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint ret = 0;\n\tint i, num_entries;\n\tu16 chksum;\n\tstruct exfat_dentry *ep, *fep;\n\tstruct buffer_head *fbh, *bh;\n\n\tfep = exfat_get_dentry(sb, p_dir, entry, &fbh);\n\tif (!fep)\n\t\treturn -EIO;\n\n\tnum_entries = fep->dentry.file.num_ext + 1;\n\tchksum = exfat_calc_chksum16(fep, DENTRY_SIZE, 0, CS_DIR_ENTRY);\n\n\tfor (i = 1; i < num_entries; i++) {\n\t\tep = exfat_get_dentry(sb, p_dir, entry + i, &bh);\n\t\tif (!ep) {\n\t\t\tret = -EIO;\n\t\t\tgoto release_fbh;\n\t\t}\n\t\tchksum = exfat_calc_chksum16(ep, DENTRY_SIZE, chksum,\n\t\t\t\tCS_DEFAULT);\n\t\tbrelse(bh);\n\t}\n\n\tfep->dentry.file.checksum = cpu_to_le16(chksum);\n\texfat_update_bh(fbh, IS_DIRSYNC(inode));\nrelease_fbh:\n\tbrelse(fbh);\n\treturn ret;\n}\n\nstatic void exfat_free_benign_secondary_clusters(struct inode *inode,\n\t\tstruct exfat_dentry *ep)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct exfat_chain dir;\n\tunsigned int start_clu =\n\t\tle32_to_cpu(ep->dentry.generic_secondary.start_clu);\n\tu64 size = le64_to_cpu(ep->dentry.generic_secondary.size);\n\tunsigned char flags = ep->dentry.generic_secondary.flags;\n\n\tif (!(flags & ALLOC_POSSIBLE) || !start_clu || !size)\n\t\treturn;\n\n\texfat_chain_set(&dir, start_clu,\n\t\t\tEXFAT_B_TO_CLU_ROUND_UP(size, EXFAT_SB(sb)),\n\t\t\tflags);\n\texfat_free_cluster(inode, &dir);\n}\n\nint exfat_init_ext_entry(struct inode *inode, struct exfat_chain *p_dir,\n\t\tint entry, int num_entries, struct exfat_uni_name *p_uniname)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint i;\n\tunsigned short *uniname = p_uniname->name;\n\tstruct exfat_dentry *ep;\n\tstruct buffer_head *bh;\n\tint sync = IS_DIRSYNC(inode);\n\n\tep = exfat_get_dentry(sb, p_dir, entry, &bh);\n\tif (!ep)\n\t\treturn -EIO;\n\n\tep->dentry.file.num_ext = (unsigned char)(num_entries - 1);\n\texfat_update_bh(bh, sync);\n\tbrelse(bh);\n\n\tep = exfat_get_dentry(sb, p_dir, entry + 1, &bh);\n\tif (!ep)\n\t\treturn -EIO;\n\n\tep->dentry.stream.name_len = p_uniname->name_len;\n\tep->dentry.stream.name_hash = cpu_to_le16(p_uniname->name_hash);\n\texfat_update_bh(bh, sync);\n\tbrelse(bh);\n\n\tfor (i = EXFAT_FIRST_CLUSTER; i < num_entries; i++) {\n\t\tep = exfat_get_dentry(sb, p_dir, entry + i, &bh);\n\t\tif (!ep)\n\t\t\treturn -EIO;\n\n\t\tif (exfat_get_entry_type(ep) & TYPE_BENIGN_SEC)\n\t\t\texfat_free_benign_secondary_clusters(inode, ep);\n\n\t\texfat_init_name_entry(ep, uniname);\n\t\texfat_update_bh(bh, sync);\n\t\tbrelse(bh);\n\t\tuniname += EXFAT_FILE_NAME_LEN;\n\t}\n\n\texfat_update_dir_chksum(inode, p_dir, entry);\n\treturn 0;\n}\n\nint exfat_remove_entries(struct inode *inode, struct exfat_chain *p_dir,\n\t\tint entry, int order, int num_entries)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint i;\n\tstruct exfat_dentry *ep;\n\tstruct buffer_head *bh;\n\n\tfor (i = order; i < num_entries; i++) {\n\t\tep = exfat_get_dentry(sb, p_dir, entry + i, &bh);\n\t\tif (!ep)\n\t\t\treturn -EIO;\n\n\t\tif (exfat_get_entry_type(ep) & TYPE_BENIGN_SEC)\n\t\t\texfat_free_benign_secondary_clusters(inode, ep);\n\n\t\texfat_set_entry_type(ep, TYPE_DELETED);\n\t\texfat_update_bh(bh, IS_DIRSYNC(inode));\n\t\tbrelse(bh);\n\t}\n\n\treturn 0;\n}\n\nvoid exfat_update_dir_chksum_with_entry_set(struct exfat_entry_set_cache *es)\n{\n\tint chksum_type = CS_DIR_ENTRY, i;\n\tunsigned short chksum = 0;\n\tstruct exfat_dentry *ep;\n\n\tfor (i = ES_IDX_FILE; i < es->num_entries; i++) {\n\t\tep = exfat_get_dentry_cached(es, i);\n\t\tchksum = exfat_calc_chksum16(ep, DENTRY_SIZE, chksum,\n\t\t\t\t\t     chksum_type);\n\t\tchksum_type = CS_DEFAULT;\n\t}\n\tep = exfat_get_dentry_cached(es, ES_IDX_FILE);\n\tep->dentry.file.checksum = cpu_to_le16(chksum);\n\tes->modified = true;\n}\n\nint exfat_put_dentry_set(struct exfat_entry_set_cache *es, int sync)\n{\n\tint i, err = 0;\n\n\tif (es->modified)\n\t\terr = exfat_update_bhs(es->bh, es->num_bh, sync);\n\n\tfor (i = 0; i < es->num_bh; i++)\n\t\tif (err)\n\t\t\tbforget(es->bh[i]);\n\t\telse\n\t\t\tbrelse(es->bh[i]);\n\n\tif (IS_DYNAMIC_ES(es))\n\t\tkfree(es->bh);\n\n\treturn err;\n}\n\nstatic int exfat_walk_fat_chain(struct super_block *sb,\n\t\tstruct exfat_chain *p_dir, unsigned int byte_offset,\n\t\tunsigned int *clu)\n{\n\tstruct exfat_sb_info *sbi = EXFAT_SB(sb);\n\tunsigned int clu_offset;\n\tunsigned int cur_clu;\n\n\tclu_offset = EXFAT_B_TO_CLU(byte_offset, sbi);\n\tcur_clu = p_dir->dir;\n\n\tif (p_dir->flags == ALLOC_NO_FAT_CHAIN) {\n\t\tcur_clu += clu_offset;\n\t} else {\n\t\twhile (clu_offset > 0) {\n\t\t\tif (exfat_get_next_cluster(sb, &cur_clu))\n\t\t\t\treturn -EIO;\n\t\t\tif (cur_clu == EXFAT_EOF_CLUSTER) {\n\t\t\t\texfat_fs_error(sb,\n\t\t\t\t\t\"invalid dentry access beyond EOF (clu : %u, eidx : %d)\",\n\t\t\t\t\tp_dir->dir,\n\t\t\t\t\tEXFAT_B_TO_DEN(byte_offset));\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tclu_offset--;\n\t\t}\n\t}\n\n\t*clu = cur_clu;\n\treturn 0;\n}\n\nstatic int exfat_find_location(struct super_block *sb, struct exfat_chain *p_dir,\n\t\t\t       int entry, sector_t *sector, int *offset)\n{\n\tint ret;\n\tunsigned int off, clu = 0;\n\tstruct exfat_sb_info *sbi = EXFAT_SB(sb);\n\n\toff = EXFAT_DEN_TO_B(entry);\n\n\tret = exfat_walk_fat_chain(sb, p_dir, off, &clu);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\toff = EXFAT_CLU_OFFSET(off, sbi);\n\n\t \n\t*offset = EXFAT_BLK_OFFSET(off, sb);\n\n\t \n\t*sector = EXFAT_B_TO_BLK(off, sb);\n\t*sector += exfat_cluster_to_sector(sbi, clu);\n\treturn 0;\n}\n\n#define EXFAT_MAX_RA_SIZE     (128*1024)\nstatic int exfat_dir_readahead(struct super_block *sb, sector_t sec)\n{\n\tstruct exfat_sb_info *sbi = EXFAT_SB(sb);\n\tstruct buffer_head *bh;\n\tunsigned int max_ra_count = EXFAT_MAX_RA_SIZE >> sb->s_blocksize_bits;\n\tunsigned int page_ra_count = PAGE_SIZE >> sb->s_blocksize_bits;\n\tunsigned int adj_ra_count = max(sbi->sect_per_clus, page_ra_count);\n\tunsigned int ra_count = min(adj_ra_count, max_ra_count);\n\n\t \n\tif (sbi->sect_per_clus == 1)\n\t\treturn 0;\n\n\tif (sec < sbi->data_start_sector) {\n\t\texfat_err(sb, \"requested sector is invalid(sect:%llu, root:%llu)\",\n\t\t\t  (unsigned long long)sec, sbi->data_start_sector);\n\t\treturn -EIO;\n\t}\n\n\t \n\tif ((sec - sbi->data_start_sector) & (ra_count - 1))\n\t\tra_count = page_ra_count;\n\n\tbh = sb_find_get_block(sb, sec);\n\tif (!bh || !buffer_uptodate(bh)) {\n\t\tunsigned int i;\n\n\t\tfor (i = 0; i < ra_count; i++)\n\t\t\tsb_breadahead(sb, (sector_t)(sec + i));\n\t}\n\tbrelse(bh);\n\treturn 0;\n}\n\nstruct exfat_dentry *exfat_get_dentry(struct super_block *sb,\n\t\tstruct exfat_chain *p_dir, int entry, struct buffer_head **bh)\n{\n\tunsigned int dentries_per_page = EXFAT_B_TO_DEN(PAGE_SIZE);\n\tint off;\n\tsector_t sec;\n\n\tif (p_dir->dir == DIR_DELETED) {\n\t\texfat_err(sb, \"abnormal access to deleted dentry\");\n\t\treturn NULL;\n\t}\n\n\tif (exfat_find_location(sb, p_dir, entry, &sec, &off))\n\t\treturn NULL;\n\n\tif (p_dir->dir != EXFAT_FREE_CLUSTER &&\n\t\t\t!(entry & (dentries_per_page - 1)))\n\t\texfat_dir_readahead(sb, sec);\n\n\t*bh = sb_bread(sb, sec);\n\tif (!*bh)\n\t\treturn NULL;\n\n\treturn (struct exfat_dentry *)((*bh)->b_data + off);\n}\n\nenum exfat_validate_dentry_mode {\n\tES_MODE_STARTED,\n\tES_MODE_GET_FILE_ENTRY,\n\tES_MODE_GET_STRM_ENTRY,\n\tES_MODE_GET_NAME_ENTRY,\n\tES_MODE_GET_CRITICAL_SEC_ENTRY,\n\tES_MODE_GET_BENIGN_SEC_ENTRY,\n};\n\nstatic bool exfat_validate_entry(unsigned int type,\n\t\tenum exfat_validate_dentry_mode *mode)\n{\n\tif (type == TYPE_UNUSED || type == TYPE_DELETED)\n\t\treturn false;\n\n\tswitch (*mode) {\n\tcase ES_MODE_STARTED:\n\t\tif  (type != TYPE_FILE && type != TYPE_DIR)\n\t\t\treturn false;\n\t\t*mode = ES_MODE_GET_FILE_ENTRY;\n\t\tbreak;\n\tcase ES_MODE_GET_FILE_ENTRY:\n\t\tif (type != TYPE_STREAM)\n\t\t\treturn false;\n\t\t*mode = ES_MODE_GET_STRM_ENTRY;\n\t\tbreak;\n\tcase ES_MODE_GET_STRM_ENTRY:\n\t\tif (type != TYPE_EXTEND)\n\t\t\treturn false;\n\t\t*mode = ES_MODE_GET_NAME_ENTRY;\n\t\tbreak;\n\tcase ES_MODE_GET_NAME_ENTRY:\n\t\tif (type & TYPE_BENIGN_SEC)\n\t\t\t*mode = ES_MODE_GET_BENIGN_SEC_ENTRY;\n\t\telse if (type != TYPE_EXTEND)\n\t\t\treturn false;\n\t\tbreak;\n\tcase ES_MODE_GET_BENIGN_SEC_ENTRY:\n\t\t \n\t\tif (!(type & TYPE_BENIGN_SEC))\n\t\t\treturn false;\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstruct exfat_dentry *exfat_get_dentry_cached(\n\tstruct exfat_entry_set_cache *es, int num)\n{\n\tint off = es->start_off + num * DENTRY_SIZE;\n\tstruct buffer_head *bh = es->bh[EXFAT_B_TO_BLK(off, es->sb)];\n\tchar *p = bh->b_data + EXFAT_BLK_OFFSET(off, es->sb);\n\n\treturn (struct exfat_dentry *)p;\n}\n\n \nint exfat_get_dentry_set(struct exfat_entry_set_cache *es,\n\t\tstruct super_block *sb, struct exfat_chain *p_dir, int entry,\n\t\tunsigned int type)\n{\n\tint ret, i, num_bh;\n\tunsigned int off;\n\tsector_t sec;\n\tstruct exfat_sb_info *sbi = EXFAT_SB(sb);\n\tstruct exfat_dentry *ep;\n\tint num_entries;\n\tenum exfat_validate_dentry_mode mode = ES_MODE_STARTED;\n\tstruct buffer_head *bh;\n\n\tif (p_dir->dir == DIR_DELETED) {\n\t\texfat_err(sb, \"access to deleted dentry\");\n\t\treturn -EIO;\n\t}\n\n\tret = exfat_find_location(sb, p_dir, entry, &sec, &off);\n\tif (ret)\n\t\treturn ret;\n\n\tmemset(es, 0, sizeof(*es));\n\tes->sb = sb;\n\tes->modified = false;\n\tes->start_off = off;\n\tes->bh = es->__bh;\n\n\tbh = sb_bread(sb, sec);\n\tif (!bh)\n\t\treturn -EIO;\n\tes->bh[es->num_bh++] = bh;\n\n\tep = exfat_get_dentry_cached(es, ES_IDX_FILE);\n\tif (!exfat_validate_entry(exfat_get_entry_type(ep), &mode))\n\t\tgoto put_es;\n\n\tnum_entries = type == ES_ALL_ENTRIES ?\n\t\tep->dentry.file.num_ext + 1 : type;\n\tes->num_entries = num_entries;\n\n\tnum_bh = EXFAT_B_TO_BLK_ROUND_UP(off + num_entries * DENTRY_SIZE, sb);\n\tif (num_bh > ARRAY_SIZE(es->__bh)) {\n\t\tes->bh = kmalloc_array(num_bh, sizeof(*es->bh), GFP_KERNEL);\n\t\tif (!es->bh) {\n\t\t\tbrelse(bh);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tes->bh[0] = bh;\n\t}\n\n\tfor (i = 1; i < num_bh; i++) {\n\t\t \n\t\tif (exfat_is_last_sector_in_cluster(sbi, sec)) {\n\t\t\tunsigned int clu = exfat_sector_to_cluster(sbi, sec);\n\n\t\t\tif (p_dir->flags == ALLOC_NO_FAT_CHAIN)\n\t\t\t\tclu++;\n\t\t\telse if (exfat_get_next_cluster(sb, &clu))\n\t\t\t\tgoto put_es;\n\t\t\tsec = exfat_cluster_to_sector(sbi, clu);\n\t\t} else {\n\t\t\tsec++;\n\t\t}\n\n\t\tbh = sb_bread(sb, sec);\n\t\tif (!bh)\n\t\t\tgoto put_es;\n\t\tes->bh[es->num_bh++] = bh;\n\t}\n\n\t \n\tfor (i = ES_IDX_STREAM; i < num_entries; i++) {\n\t\tep = exfat_get_dentry_cached(es, i);\n\t\tif (!exfat_validate_entry(exfat_get_entry_type(ep), &mode))\n\t\t\tgoto put_es;\n\t}\n\treturn 0;\n\nput_es:\n\texfat_put_dentry_set(es, false);\n\treturn -EIO;\n}\n\nstatic inline void exfat_reset_empty_hint(struct exfat_hint_femp *hint_femp)\n{\n\thint_femp->eidx = EXFAT_HINT_NONE;\n\thint_femp->count = 0;\n}\n\nstatic inline void exfat_set_empty_hint(struct exfat_inode_info *ei,\n\t\tstruct exfat_hint_femp *candi_empty, struct exfat_chain *clu,\n\t\tint dentry, int num_entries, int entry_type)\n{\n\tif (ei->hint_femp.eidx == EXFAT_HINT_NONE ||\n\t    ei->hint_femp.eidx > dentry) {\n\t\tint total_entries = EXFAT_B_TO_DEN(i_size_read(&ei->vfs_inode));\n\n\t\tif (candi_empty->count == 0) {\n\t\t\tcandi_empty->cur = *clu;\n\t\t\tcandi_empty->eidx = dentry;\n\t\t}\n\n\t\tif (entry_type == TYPE_UNUSED)\n\t\t\tcandi_empty->count += total_entries - dentry;\n\t\telse\n\t\t\tcandi_empty->count++;\n\n\t\tif (candi_empty->count == num_entries ||\n\t\t    candi_empty->count + candi_empty->eidx == total_entries)\n\t\t\tei->hint_femp = *candi_empty;\n\t}\n}\n\nenum {\n\tDIRENT_STEP_FILE,\n\tDIRENT_STEP_STRM,\n\tDIRENT_STEP_NAME,\n\tDIRENT_STEP_SECD,\n};\n\n \nint exfat_find_dir_entry(struct super_block *sb, struct exfat_inode_info *ei,\n\t\tstruct exfat_chain *p_dir, struct exfat_uni_name *p_uniname,\n\t\tstruct exfat_hint *hint_opt)\n{\n\tint i, rewind = 0, dentry = 0, end_eidx = 0, num_ext = 0, len;\n\tint order, step, name_len = 0;\n\tint dentries_per_clu;\n\tunsigned int entry_type;\n\tunsigned short *uniname = NULL;\n\tstruct exfat_chain clu;\n\tstruct exfat_hint *hint_stat = &ei->hint_stat;\n\tstruct exfat_hint_femp candi_empty;\n\tstruct exfat_sb_info *sbi = EXFAT_SB(sb);\n\tint num_entries = exfat_calc_num_entries(p_uniname);\n\n\tif (num_entries < 0)\n\t\treturn num_entries;\n\n\tdentries_per_clu = sbi->dentries_per_clu;\n\n\texfat_chain_dup(&clu, p_dir);\n\n\tif (hint_stat->eidx) {\n\t\tclu.dir = hint_stat->clu;\n\t\tdentry = hint_stat->eidx;\n\t\tend_eidx = dentry;\n\t}\n\n\texfat_reset_empty_hint(&ei->hint_femp);\n\nrewind:\n\torder = 0;\n\tstep = DIRENT_STEP_FILE;\n\texfat_reset_empty_hint(&candi_empty);\n\n\twhile (clu.dir != EXFAT_EOF_CLUSTER) {\n\t\ti = dentry & (dentries_per_clu - 1);\n\t\tfor (; i < dentries_per_clu; i++, dentry++) {\n\t\t\tstruct exfat_dentry *ep;\n\t\t\tstruct buffer_head *bh;\n\n\t\t\tif (rewind && dentry == end_eidx)\n\t\t\t\tgoto not_found;\n\n\t\t\tep = exfat_get_dentry(sb, &clu, i, &bh);\n\t\t\tif (!ep)\n\t\t\t\treturn -EIO;\n\n\t\t\tentry_type = exfat_get_entry_type(ep);\n\n\t\t\tif (entry_type == TYPE_UNUSED ||\n\t\t\t    entry_type == TYPE_DELETED) {\n\t\t\t\tstep = DIRENT_STEP_FILE;\n\n\t\t\t\texfat_set_empty_hint(ei, &candi_empty, &clu,\n\t\t\t\t\t\tdentry, num_entries,\n\t\t\t\t\t\tentry_type);\n\n\t\t\t\tbrelse(bh);\n\t\t\t\tif (entry_type == TYPE_UNUSED)\n\t\t\t\t\tgoto not_found;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\texfat_reset_empty_hint(&candi_empty);\n\n\t\t\tif (entry_type == TYPE_FILE || entry_type == TYPE_DIR) {\n\t\t\t\tstep = DIRENT_STEP_FILE;\n\t\t\t\thint_opt->clu = clu.dir;\n\t\t\t\thint_opt->eidx = i;\n\t\t\t\tnum_ext = ep->dentry.file.num_ext;\n\t\t\t\tstep = DIRENT_STEP_STRM;\n\t\t\t\tbrelse(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (entry_type == TYPE_STREAM) {\n\t\t\t\tu16 name_hash;\n\n\t\t\t\tif (step != DIRENT_STEP_STRM) {\n\t\t\t\t\tstep = DIRENT_STEP_FILE;\n\t\t\t\t\tbrelse(bh);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tstep = DIRENT_STEP_FILE;\n\t\t\t\tname_hash = le16_to_cpu(\n\t\t\t\t\t\tep->dentry.stream.name_hash);\n\t\t\t\tif (p_uniname->name_hash == name_hash &&\n\t\t\t\t    p_uniname->name_len ==\n\t\t\t\t\t\tep->dentry.stream.name_len) {\n\t\t\t\t\tstep = DIRENT_STEP_NAME;\n\t\t\t\t\torder = 1;\n\t\t\t\t\tname_len = 0;\n\t\t\t\t}\n\t\t\t\tbrelse(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tbrelse(bh);\n\t\t\tif (entry_type == TYPE_EXTEND) {\n\t\t\t\tunsigned short entry_uniname[16], unichar;\n\n\t\t\t\tif (step != DIRENT_STEP_NAME ||\n\t\t\t\t    name_len >= MAX_NAME_LENGTH) {\n\t\t\t\t\tstep = DIRENT_STEP_FILE;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (++order == 2)\n\t\t\t\t\tuniname = p_uniname->name;\n\t\t\t\telse\n\t\t\t\t\tuniname += EXFAT_FILE_NAME_LEN;\n\n\t\t\t\tlen = exfat_extract_uni_name(ep, entry_uniname);\n\t\t\t\tname_len += len;\n\n\t\t\t\tunichar = *(uniname+len);\n\t\t\t\t*(uniname+len) = 0x0;\n\n\t\t\t\tif (exfat_uniname_ncmp(sb, uniname,\n\t\t\t\t\tentry_uniname, len)) {\n\t\t\t\t\tstep = DIRENT_STEP_FILE;\n\t\t\t\t} else if (p_uniname->name_len == name_len) {\n\t\t\t\t\tif (order == num_ext)\n\t\t\t\t\t\tgoto found;\n\t\t\t\t\tstep = DIRENT_STEP_SECD;\n\t\t\t\t}\n\n\t\t\t\t*(uniname+len) = unichar;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (entry_type &\n\t\t\t\t\t(TYPE_CRITICAL_SEC | TYPE_BENIGN_SEC)) {\n\t\t\t\tif (step == DIRENT_STEP_SECD) {\n\t\t\t\t\tif (++order == num_ext)\n\t\t\t\t\t\tgoto found;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstep = DIRENT_STEP_FILE;\n\t\t}\n\n\t\tif (clu.flags == ALLOC_NO_FAT_CHAIN) {\n\t\t\tif (--clu.size > 0)\n\t\t\t\tclu.dir++;\n\t\t\telse\n\t\t\t\tclu.dir = EXFAT_EOF_CLUSTER;\n\t\t} else {\n\t\t\tif (exfat_get_next_cluster(sb, &clu.dir))\n\t\t\t\treturn -EIO;\n\t\t}\n\t}\n\nnot_found:\n\t \n\tif (!rewind && end_eidx) {\n\t\trewind = 1;\n\t\tdentry = 0;\n\t\tclu.dir = p_dir->dir;\n\t\tgoto rewind;\n\t}\n\n\t \n\tif (ei->hint_femp.eidx == EXFAT_HINT_NONE) {\n\t\tei->hint_femp.cur.dir = EXFAT_EOF_CLUSTER;\n\t\tei->hint_femp.eidx = p_dir->size * dentries_per_clu;\n\t\tei->hint_femp.count = 0;\n\t}\n\n\t \n\thint_stat->clu = p_dir->dir;\n\thint_stat->eidx = 0;\n\treturn -ENOENT;\n\nfound:\n\t \n\tif (!((dentry + 1) & (dentries_per_clu - 1))) {\n\t\tint ret = 0;\n\n\t\tif (clu.flags == ALLOC_NO_FAT_CHAIN) {\n\t\t\tif (--clu.size > 0)\n\t\t\t\tclu.dir++;\n\t\t\telse\n\t\t\t\tclu.dir = EXFAT_EOF_CLUSTER;\n\t\t} else {\n\t\t\tret = exfat_get_next_cluster(sb, &clu.dir);\n\t\t}\n\n\t\tif (ret || clu.dir == EXFAT_EOF_CLUSTER) {\n\t\t\t \n\t\t\thint_stat->clu = p_dir->dir;\n\t\t\thint_stat->eidx = 0;\n\t\t\treturn (dentry - num_ext);\n\t\t}\n\t}\n\n\thint_stat->clu = clu.dir;\n\thint_stat->eidx = dentry + 1;\n\treturn dentry - num_ext;\n}\n\nint exfat_count_ext_entries(struct super_block *sb, struct exfat_chain *p_dir,\n\t\tint entry, struct exfat_dentry *ep)\n{\n\tint i, count = 0;\n\tunsigned int type;\n\tstruct exfat_dentry *ext_ep;\n\tstruct buffer_head *bh;\n\n\tfor (i = 0, entry++; i < ep->dentry.file.num_ext; i++, entry++) {\n\t\text_ep = exfat_get_dentry(sb, p_dir, entry, &bh);\n\t\tif (!ext_ep)\n\t\t\treturn -EIO;\n\n\t\ttype = exfat_get_entry_type(ext_ep);\n\t\tbrelse(bh);\n\t\tif (type & TYPE_CRITICAL_SEC || type & TYPE_BENIGN_SEC)\n\t\t\tcount++;\n\t}\n\treturn count;\n}\n\nint exfat_count_dir_entries(struct super_block *sb, struct exfat_chain *p_dir)\n{\n\tint i, count = 0;\n\tint dentries_per_clu;\n\tunsigned int entry_type;\n\tstruct exfat_chain clu;\n\tstruct exfat_dentry *ep;\n\tstruct exfat_sb_info *sbi = EXFAT_SB(sb);\n\tstruct buffer_head *bh;\n\n\tdentries_per_clu = sbi->dentries_per_clu;\n\n\texfat_chain_dup(&clu, p_dir);\n\n\twhile (clu.dir != EXFAT_EOF_CLUSTER) {\n\t\tfor (i = 0; i < dentries_per_clu; i++) {\n\t\t\tep = exfat_get_dentry(sb, &clu, i, &bh);\n\t\t\tif (!ep)\n\t\t\t\treturn -EIO;\n\t\t\tentry_type = exfat_get_entry_type(ep);\n\t\t\tbrelse(bh);\n\n\t\t\tif (entry_type == TYPE_UNUSED)\n\t\t\t\treturn count;\n\t\t\tif (entry_type != TYPE_DIR)\n\t\t\t\tcontinue;\n\t\t\tcount++;\n\t\t}\n\n\t\tif (clu.flags == ALLOC_NO_FAT_CHAIN) {\n\t\t\tif (--clu.size > 0)\n\t\t\t\tclu.dir++;\n\t\t\telse\n\t\t\t\tclu.dir = EXFAT_EOF_CLUSTER;\n\t\t} else {\n\t\t\tif (exfat_get_next_cluster(sb, &(clu.dir)))\n\t\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\treturn count;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}