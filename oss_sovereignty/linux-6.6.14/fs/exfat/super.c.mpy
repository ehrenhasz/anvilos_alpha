{
  "module_name": "super.c",
  "hash_id": "49d0eaf7ab40c21adcdc8e898a5614f99b0bc9380c175c3d8f17a0986da24d94",
  "original_prompt": "Ingested from linux-6.6.14/fs/exfat/super.c",
  "human_readable_source": "\n \n\n#include <linux/fs_context.h>\n#include <linux/fs_parser.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/statfs.h>\n#include <linux/seq_file.h>\n#include <linux/blkdev.h>\n#include <linux/fs_struct.h>\n#include <linux/iversion.h>\n#include <linux/nls.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n\n#include \"exfat_raw.h\"\n#include \"exfat_fs.h\"\n\nstatic char exfat_default_iocharset[] = CONFIG_EXFAT_DEFAULT_IOCHARSET;\nstatic struct kmem_cache *exfat_inode_cachep;\n\nstatic void exfat_free_iocharset(struct exfat_sb_info *sbi)\n{\n\tif (sbi->options.iocharset != exfat_default_iocharset)\n\t\tkfree(sbi->options.iocharset);\n}\n\nstatic void exfat_put_super(struct super_block *sb)\n{\n\tstruct exfat_sb_info *sbi = EXFAT_SB(sb);\n\n\tmutex_lock(&sbi->s_lock);\n\texfat_free_bitmap(sbi);\n\tbrelse(sbi->boot_bh);\n\tmutex_unlock(&sbi->s_lock);\n\n\tunload_nls(sbi->nls_io);\n\texfat_free_upcase_table(sbi);\n}\n\nstatic int exfat_sync_fs(struct super_block *sb, int wait)\n{\n\tstruct exfat_sb_info *sbi = EXFAT_SB(sb);\n\tint err = 0;\n\n\tif (!wait)\n\t\treturn 0;\n\n\t \n\tmutex_lock(&sbi->s_lock);\n\tsync_blockdev(sb->s_bdev);\n\tif (exfat_clear_volume_dirty(sb))\n\t\terr = -EIO;\n\tmutex_unlock(&sbi->s_lock);\n\treturn err;\n}\n\nstatic int exfat_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct exfat_sb_info *sbi = EXFAT_SB(sb);\n\tunsigned long long id = huge_encode_dev(sb->s_bdev->bd_dev);\n\n\tif (sbi->used_clusters == EXFAT_CLUSTERS_UNTRACKED) {\n\t\tmutex_lock(&sbi->s_lock);\n\t\tif (exfat_count_used_clusters(sb, &sbi->used_clusters)) {\n\t\t\tmutex_unlock(&sbi->s_lock);\n\t\t\treturn -EIO;\n\t\t}\n\t\tmutex_unlock(&sbi->s_lock);\n\t}\n\n\tbuf->f_type = sb->s_magic;\n\tbuf->f_bsize = sbi->cluster_size;\n\tbuf->f_blocks = sbi->num_clusters - 2;  \n\tbuf->f_bfree = buf->f_blocks - sbi->used_clusters;\n\tbuf->f_bavail = buf->f_bfree;\n\tbuf->f_fsid = u64_to_fsid(id);\n\t \n\tbuf->f_namelen = EXFAT_MAX_FILE_LEN * NLS_MAX_CHARSET_SIZE;\n\treturn 0;\n}\n\nstatic int exfat_set_vol_flags(struct super_block *sb, unsigned short new_flags)\n{\n\tstruct exfat_sb_info *sbi = EXFAT_SB(sb);\n\tstruct boot_sector *p_boot = (struct boot_sector *)sbi->boot_bh->b_data;\n\n\t \n\tnew_flags |= sbi->vol_flags_persistent;\n\n\t \n\tif (sbi->vol_flags == new_flags)\n\t\treturn 0;\n\n\tsbi->vol_flags = new_flags;\n\n\t \n\tif (sb_rdonly(sb))\n\t\treturn 0;\n\n\tp_boot->vol_flags = cpu_to_le16(new_flags);\n\n\tset_buffer_uptodate(sbi->boot_bh);\n\tmark_buffer_dirty(sbi->boot_bh);\n\n\t__sync_dirty_buffer(sbi->boot_bh, REQ_SYNC | REQ_FUA | REQ_PREFLUSH);\n\n\treturn 0;\n}\n\nint exfat_set_volume_dirty(struct super_block *sb)\n{\n\tstruct exfat_sb_info *sbi = EXFAT_SB(sb);\n\n\treturn exfat_set_vol_flags(sb, sbi->vol_flags | VOLUME_DIRTY);\n}\n\nint exfat_clear_volume_dirty(struct super_block *sb)\n{\n\tstruct exfat_sb_info *sbi = EXFAT_SB(sb);\n\n\treturn exfat_set_vol_flags(sb, sbi->vol_flags & ~VOLUME_DIRTY);\n}\n\nstatic int exfat_show_options(struct seq_file *m, struct dentry *root)\n{\n\tstruct super_block *sb = root->d_sb;\n\tstruct exfat_sb_info *sbi = EXFAT_SB(sb);\n\tstruct exfat_mount_options *opts = &sbi->options;\n\n\t \n\tif (!uid_eq(opts->fs_uid, GLOBAL_ROOT_UID))\n\t\tseq_printf(m, \",uid=%u\",\n\t\t\t\tfrom_kuid_munged(&init_user_ns, opts->fs_uid));\n\tif (!gid_eq(opts->fs_gid, GLOBAL_ROOT_GID))\n\t\tseq_printf(m, \",gid=%u\",\n\t\t\t\tfrom_kgid_munged(&init_user_ns, opts->fs_gid));\n\tseq_printf(m, \",fmask=%04o,dmask=%04o\", opts->fs_fmask, opts->fs_dmask);\n\tif (opts->allow_utime)\n\t\tseq_printf(m, \",allow_utime=%04o\", opts->allow_utime);\n\tif (opts->utf8)\n\t\tseq_puts(m, \",iocharset=utf8\");\n\telse if (sbi->nls_io)\n\t\tseq_printf(m, \",iocharset=%s\", sbi->nls_io->charset);\n\tif (opts->errors == EXFAT_ERRORS_CONT)\n\t\tseq_puts(m, \",errors=continue\");\n\telse if (opts->errors == EXFAT_ERRORS_PANIC)\n\t\tseq_puts(m, \",errors=panic\");\n\telse\n\t\tseq_puts(m, \",errors=remount-ro\");\n\tif (opts->discard)\n\t\tseq_puts(m, \",discard\");\n\tif (opts->keep_last_dots)\n\t\tseq_puts(m, \",keep_last_dots\");\n\tif (opts->sys_tz)\n\t\tseq_puts(m, \",sys_tz\");\n\telse if (opts->time_offset)\n\t\tseq_printf(m, \",time_offset=%d\", opts->time_offset);\n\treturn 0;\n}\n\nstatic struct inode *exfat_alloc_inode(struct super_block *sb)\n{\n\tstruct exfat_inode_info *ei;\n\n\tei = alloc_inode_sb(sb, exfat_inode_cachep, GFP_NOFS);\n\tif (!ei)\n\t\treturn NULL;\n\n\tinit_rwsem(&ei->truncate_lock);\n\treturn &ei->vfs_inode;\n}\n\nstatic void exfat_free_inode(struct inode *inode)\n{\n\tkmem_cache_free(exfat_inode_cachep, EXFAT_I(inode));\n}\n\nstatic const struct super_operations exfat_sops = {\n\t.alloc_inode\t= exfat_alloc_inode,\n\t.free_inode\t= exfat_free_inode,\n\t.write_inode\t= exfat_write_inode,\n\t.evict_inode\t= exfat_evict_inode,\n\t.put_super\t= exfat_put_super,\n\t.sync_fs\t= exfat_sync_fs,\n\t.statfs\t\t= exfat_statfs,\n\t.show_options\t= exfat_show_options,\n};\n\nenum {\n\tOpt_uid,\n\tOpt_gid,\n\tOpt_umask,\n\tOpt_dmask,\n\tOpt_fmask,\n\tOpt_allow_utime,\n\tOpt_charset,\n\tOpt_errors,\n\tOpt_discard,\n\tOpt_keep_last_dots,\n\tOpt_sys_tz,\n\tOpt_time_offset,\n\n\t \n\tOpt_utf8,\n\tOpt_debug,\n\tOpt_namecase,\n\tOpt_codepage,\n};\n\nstatic const struct constant_table exfat_param_enums[] = {\n\t{ \"continue\",\t\tEXFAT_ERRORS_CONT },\n\t{ \"panic\",\t\tEXFAT_ERRORS_PANIC },\n\t{ \"remount-ro\",\t\tEXFAT_ERRORS_RO },\n\t{}\n};\n\nstatic const struct fs_parameter_spec exfat_parameters[] = {\n\tfsparam_u32(\"uid\",\t\t\tOpt_uid),\n\tfsparam_u32(\"gid\",\t\t\tOpt_gid),\n\tfsparam_u32oct(\"umask\",\t\t\tOpt_umask),\n\tfsparam_u32oct(\"dmask\",\t\t\tOpt_dmask),\n\tfsparam_u32oct(\"fmask\",\t\t\tOpt_fmask),\n\tfsparam_u32oct(\"allow_utime\",\t\tOpt_allow_utime),\n\tfsparam_string(\"iocharset\",\t\tOpt_charset),\n\tfsparam_enum(\"errors\",\t\t\tOpt_errors, exfat_param_enums),\n\tfsparam_flag(\"discard\",\t\t\tOpt_discard),\n\tfsparam_flag(\"keep_last_dots\",\t\tOpt_keep_last_dots),\n\tfsparam_flag(\"sys_tz\",\t\t\tOpt_sys_tz),\n\tfsparam_s32(\"time_offset\",\t\tOpt_time_offset),\n\t__fsparam(NULL, \"utf8\",\t\t\tOpt_utf8, fs_param_deprecated,\n\t\t  NULL),\n\t__fsparam(NULL, \"debug\",\t\tOpt_debug, fs_param_deprecated,\n\t\t  NULL),\n\t__fsparam(fs_param_is_u32, \"namecase\",\tOpt_namecase,\n\t\t  fs_param_deprecated, NULL),\n\t__fsparam(fs_param_is_u32, \"codepage\",\tOpt_codepage,\n\t\t  fs_param_deprecated, NULL),\n\t{}\n};\n\nstatic int exfat_parse_param(struct fs_context *fc, struct fs_parameter *param)\n{\n\tstruct exfat_sb_info *sbi = fc->s_fs_info;\n\tstruct exfat_mount_options *opts = &sbi->options;\n\tstruct fs_parse_result result;\n\tint opt;\n\n\topt = fs_parse(fc, exfat_parameters, param, &result);\n\tif (opt < 0)\n\t\treturn opt;\n\n\tswitch (opt) {\n\tcase Opt_uid:\n\t\topts->fs_uid = make_kuid(current_user_ns(), result.uint_32);\n\t\tbreak;\n\tcase Opt_gid:\n\t\topts->fs_gid = make_kgid(current_user_ns(), result.uint_32);\n\t\tbreak;\n\tcase Opt_umask:\n\t\topts->fs_fmask = result.uint_32;\n\t\topts->fs_dmask = result.uint_32;\n\t\tbreak;\n\tcase Opt_dmask:\n\t\topts->fs_dmask = result.uint_32;\n\t\tbreak;\n\tcase Opt_fmask:\n\t\topts->fs_fmask = result.uint_32;\n\t\tbreak;\n\tcase Opt_allow_utime:\n\t\topts->allow_utime = result.uint_32 & 0022;\n\t\tbreak;\n\tcase Opt_charset:\n\t\texfat_free_iocharset(sbi);\n\t\topts->iocharset = param->string;\n\t\tparam->string = NULL;\n\t\tbreak;\n\tcase Opt_errors:\n\t\topts->errors = result.uint_32;\n\t\tbreak;\n\tcase Opt_discard:\n\t\topts->discard = 1;\n\t\tbreak;\n\tcase Opt_keep_last_dots:\n\t\topts->keep_last_dots = 1;\n\t\tbreak;\n\tcase Opt_sys_tz:\n\t\topts->sys_tz = 1;\n\t\tbreak;\n\tcase Opt_time_offset:\n\t\t \n\t\tif (result.int_32 < -24 * 60 || result.int_32 > 24 * 60)\n\t\t\treturn -EINVAL;\n\t\topts->time_offset = result.int_32;\n\t\tbreak;\n\tcase Opt_utf8:\n\tcase Opt_debug:\n\tcase Opt_namecase:\n\tcase Opt_codepage:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void exfat_hash_init(struct super_block *sb)\n{\n\tstruct exfat_sb_info *sbi = EXFAT_SB(sb);\n\tint i;\n\n\tspin_lock_init(&sbi->inode_hash_lock);\n\tfor (i = 0; i < EXFAT_HASH_SIZE; i++)\n\t\tINIT_HLIST_HEAD(&sbi->inode_hashtable[i]);\n}\n\nstatic int exfat_read_root(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct exfat_sb_info *sbi = EXFAT_SB(sb);\n\tstruct exfat_inode_info *ei = EXFAT_I(inode);\n\tstruct exfat_chain cdir;\n\tint num_subdirs, num_clu = 0;\n\n\texfat_chain_set(&ei->dir, sbi->root_dir, 0, ALLOC_FAT_CHAIN);\n\tei->entry = -1;\n\tei->start_clu = sbi->root_dir;\n\tei->flags = ALLOC_FAT_CHAIN;\n\tei->type = TYPE_DIR;\n\tei->version = 0;\n\tei->hint_bmap.off = EXFAT_EOF_CLUSTER;\n\tei->hint_stat.eidx = 0;\n\tei->hint_stat.clu = sbi->root_dir;\n\tei->hint_femp.eidx = EXFAT_HINT_NONE;\n\n\texfat_chain_set(&cdir, sbi->root_dir, 0, ALLOC_FAT_CHAIN);\n\tif (exfat_count_num_clusters(sb, &cdir, &num_clu))\n\t\treturn -EIO;\n\ti_size_write(inode, num_clu << sbi->cluster_size_bits);\n\n\tnum_subdirs = exfat_count_dir_entries(sb, &cdir);\n\tif (num_subdirs < 0)\n\t\treturn -EIO;\n\tset_nlink(inode, num_subdirs + EXFAT_MIN_SUBDIR);\n\n\tinode->i_uid = sbi->options.fs_uid;\n\tinode->i_gid = sbi->options.fs_gid;\n\tinode_inc_iversion(inode);\n\tinode->i_generation = 0;\n\tinode->i_mode = exfat_make_mode(sbi, ATTR_SUBDIR, 0777);\n\tinode->i_op = &exfat_dir_inode_operations;\n\tinode->i_fop = &exfat_dir_operations;\n\n\tinode->i_blocks = round_up(i_size_read(inode), sbi->cluster_size) >> 9;\n\tei->i_pos = ((loff_t)sbi->root_dir << 32) | 0xffffffff;\n\tei->i_size_aligned = i_size_read(inode);\n\tei->i_size_ondisk = i_size_read(inode);\n\n\texfat_save_attr(inode, ATTR_SUBDIR);\n\tinode->i_mtime = inode->i_atime = ei->i_crtime = inode_set_ctime_current(inode);\n\texfat_truncate_atime(&inode->i_atime);\n\treturn 0;\n}\n\nstatic int exfat_calibrate_blocksize(struct super_block *sb, int logical_sect)\n{\n\tstruct exfat_sb_info *sbi = EXFAT_SB(sb);\n\n\tif (!is_power_of_2(logical_sect)) {\n\t\texfat_err(sb, \"bogus logical sector size %u\", logical_sect);\n\t\treturn -EIO;\n\t}\n\n\tif (logical_sect < sb->s_blocksize) {\n\t\texfat_err(sb, \"logical sector size too small for device (logical sector size = %u)\",\n\t\t\t  logical_sect);\n\t\treturn -EIO;\n\t}\n\n\tif (logical_sect > sb->s_blocksize) {\n\t\tbrelse(sbi->boot_bh);\n\t\tsbi->boot_bh = NULL;\n\n\t\tif (!sb_set_blocksize(sb, logical_sect)) {\n\t\t\texfat_err(sb, \"unable to set blocksize %u\",\n\t\t\t\t  logical_sect);\n\t\t\treturn -EIO;\n\t\t}\n\t\tsbi->boot_bh = sb_bread(sb, 0);\n\t\tif (!sbi->boot_bh) {\n\t\t\texfat_err(sb, \"unable to read boot sector (logical sector size = %lu)\",\n\t\t\t\t  sb->s_blocksize);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int exfat_read_boot_sector(struct super_block *sb)\n{\n\tstruct boot_sector *p_boot;\n\tstruct exfat_sb_info *sbi = EXFAT_SB(sb);\n\n\t \n\tsb_min_blocksize(sb, 512);\n\n\t \n\tsbi->boot_bh = sb_bread(sb, 0);\n\tif (!sbi->boot_bh) {\n\t\texfat_err(sb, \"unable to read boot sector\");\n\t\treturn -EIO;\n\t}\n\tp_boot = (struct boot_sector *)sbi->boot_bh->b_data;\n\n\t \n\tif (le16_to_cpu((p_boot->signature)) != BOOT_SIGNATURE) {\n\t\texfat_err(sb, \"invalid boot record signature\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (memcmp(p_boot->fs_name, STR_EXFAT, BOOTSEC_FS_NAME_LEN)) {\n\t\texfat_err(sb, \"invalid fs_name\");  \n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (memchr_inv(p_boot->must_be_zero, 0, sizeof(p_boot->must_be_zero)))\n\t\treturn -EINVAL;\n\n\tif (p_boot->num_fats != 1 && p_boot->num_fats != 2) {\n\t\texfat_err(sb, \"bogus number of FAT structure\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (p_boot->sect_size_bits < EXFAT_MIN_SECT_SIZE_BITS ||\n\t    p_boot->sect_size_bits > EXFAT_MAX_SECT_SIZE_BITS) {\n\t\texfat_err(sb, \"bogus sector size bits : %u\",\n\t\t\t\tp_boot->sect_size_bits);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (p_boot->sect_per_clus_bits > EXFAT_MAX_SECT_PER_CLUS_BITS(p_boot)) {\n\t\texfat_err(sb, \"bogus sectors bits per cluster : %u\",\n\t\t\t\tp_boot->sect_per_clus_bits);\n\t\treturn -EINVAL;\n\t}\n\n\tsbi->sect_per_clus = 1 << p_boot->sect_per_clus_bits;\n\tsbi->sect_per_clus_bits = p_boot->sect_per_clus_bits;\n\tsbi->cluster_size_bits = p_boot->sect_per_clus_bits +\n\t\tp_boot->sect_size_bits;\n\tsbi->cluster_size = 1 << sbi->cluster_size_bits;\n\tsbi->num_FAT_sectors = le32_to_cpu(p_boot->fat_length);\n\tsbi->FAT1_start_sector = le32_to_cpu(p_boot->fat_offset);\n\tsbi->FAT2_start_sector = le32_to_cpu(p_boot->fat_offset);\n\tif (p_boot->num_fats == 2)\n\t\tsbi->FAT2_start_sector += sbi->num_FAT_sectors;\n\tsbi->data_start_sector = le32_to_cpu(p_boot->clu_offset);\n\tsbi->num_sectors = le64_to_cpu(p_boot->vol_length);\n\t \n\tsbi->num_clusters = le32_to_cpu(p_boot->clu_count) +\n\t\tEXFAT_RESERVED_CLUSTERS;\n\n\tsbi->root_dir = le32_to_cpu(p_boot->root_cluster);\n\tsbi->dentries_per_clu = 1 <<\n\t\t(sbi->cluster_size_bits - DENTRY_SIZE_BITS);\n\n\tsbi->vol_flags = le16_to_cpu(p_boot->vol_flags);\n\tsbi->vol_flags_persistent = sbi->vol_flags & (VOLUME_DIRTY | MEDIA_FAILURE);\n\tsbi->clu_srch_ptr = EXFAT_FIRST_CLUSTER;\n\tsbi->used_clusters = EXFAT_CLUSTERS_UNTRACKED;\n\n\t \n\tif ((u64)sbi->num_FAT_sectors << p_boot->sect_size_bits <\n\t    (u64)sbi->num_clusters * 4) {\n\t\texfat_err(sb, \"bogus fat length\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sbi->data_start_sector <\n\t    (u64)sbi->FAT1_start_sector +\n\t    (u64)sbi->num_FAT_sectors * p_boot->num_fats) {\n\t\texfat_err(sb, \"bogus data start sector\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sbi->vol_flags & VOLUME_DIRTY)\n\t\texfat_warn(sb, \"Volume was not properly unmounted. Some data may be corrupt. Please run fsck.\");\n\tif (sbi->vol_flags & MEDIA_FAILURE)\n\t\texfat_warn(sb, \"Medium has reported failures. Some data may be lost.\");\n\n\t \n\tsb->s_maxbytes = (u64)(sbi->num_clusters - EXFAT_RESERVED_CLUSTERS) <<\n\t\tsbi->cluster_size_bits;\n\n\t \n\tif (exfat_calibrate_blocksize(sb, 1 << p_boot->sect_size_bits))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int exfat_verify_boot_region(struct super_block *sb)\n{\n\tstruct buffer_head *bh = NULL;\n\tu32 chksum = 0;\n\t__le32 *p_sig, *p_chksum;\n\tint sn, i;\n\n\t \n\tfor (sn = 0; sn < 11; sn++) {\n\t\tbh = sb_bread(sb, sn);\n\t\tif (!bh)\n\t\t\treturn -EIO;\n\n\t\tif (sn != 0 && sn <= 8) {\n\t\t\t \n\t\t\tp_sig = (__le32 *)&bh->b_data[sb->s_blocksize - 4];\n\t\t\tif (le32_to_cpu(*p_sig) != EXBOOT_SIGNATURE)\n\t\t\t\texfat_warn(sb, \"Invalid exboot-signature(sector = %d): 0x%08x\",\n\t\t\t\t\t   sn, le32_to_cpu(*p_sig));\n\t\t}\n\n\t\tchksum = exfat_calc_chksum32(bh->b_data, sb->s_blocksize,\n\t\t\tchksum, sn ? CS_DEFAULT : CS_BOOT_SECTOR);\n\t\tbrelse(bh);\n\t}\n\n\t \n\tbh = sb_bread(sb, sn);\n\tif (!bh)\n\t\treturn -EIO;\n\n\tfor (i = 0; i < sb->s_blocksize; i += sizeof(u32)) {\n\t\tp_chksum = (__le32 *)&bh->b_data[i];\n\t\tif (le32_to_cpu(*p_chksum) != chksum) {\n\t\t\texfat_err(sb, \"Invalid boot checksum (boot checksum : 0x%08x, checksum : 0x%08x)\",\n\t\t\t\t  le32_to_cpu(*p_chksum), chksum);\n\t\t\tbrelse(bh);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tbrelse(bh);\n\treturn 0;\n}\n\n \nstatic int __exfat_fill_super(struct super_block *sb)\n{\n\tint ret;\n\tstruct exfat_sb_info *sbi = EXFAT_SB(sb);\n\n\tret = exfat_read_boot_sector(sb);\n\tif (ret) {\n\t\texfat_err(sb, \"failed to read boot sector\");\n\t\tgoto free_bh;\n\t}\n\n\tret = exfat_verify_boot_region(sb);\n\tif (ret) {\n\t\texfat_err(sb, \"invalid boot region\");\n\t\tgoto free_bh;\n\t}\n\n\tret = exfat_create_upcase_table(sb);\n\tif (ret) {\n\t\texfat_err(sb, \"failed to load upcase table\");\n\t\tgoto free_bh;\n\t}\n\n\tret = exfat_load_bitmap(sb);\n\tif (ret) {\n\t\texfat_err(sb, \"failed to load alloc-bitmap\");\n\t\tgoto free_upcase_table;\n\t}\n\n\tret = exfat_count_used_clusters(sb, &sbi->used_clusters);\n\tif (ret) {\n\t\texfat_err(sb, \"failed to scan clusters\");\n\t\tgoto free_alloc_bitmap;\n\t}\n\n\treturn 0;\n\nfree_alloc_bitmap:\n\texfat_free_bitmap(sbi);\nfree_upcase_table:\n\texfat_free_upcase_table(sbi);\nfree_bh:\n\tbrelse(sbi->boot_bh);\n\treturn ret;\n}\n\nstatic int exfat_fill_super(struct super_block *sb, struct fs_context *fc)\n{\n\tstruct exfat_sb_info *sbi = sb->s_fs_info;\n\tstruct exfat_mount_options *opts = &sbi->options;\n\tstruct inode *root_inode;\n\tint err;\n\n\tif (opts->allow_utime == (unsigned short)-1)\n\t\topts->allow_utime = ~opts->fs_dmask & 0022;\n\n\tif (opts->discard && !bdev_max_discard_sectors(sb->s_bdev)) {\n\t\texfat_warn(sb, \"mounting with \\\"discard\\\" option, but the device does not support discard\");\n\t\topts->discard = 0;\n\t}\n\n\tsb->s_flags |= SB_NODIRATIME;\n\tsb->s_magic = EXFAT_SUPER_MAGIC;\n\tsb->s_op = &exfat_sops;\n\n\tsb->s_time_gran = 10 * NSEC_PER_MSEC;\n\tsb->s_time_min = EXFAT_MIN_TIMESTAMP_SECS;\n\tsb->s_time_max = EXFAT_MAX_TIMESTAMP_SECS;\n\n\terr = __exfat_fill_super(sb);\n\tif (err) {\n\t\texfat_err(sb, \"failed to recognize exfat type\");\n\t\tgoto check_nls_io;\n\t}\n\n\t \n\texfat_hash_init(sb);\n\n\tif (!strcmp(sbi->options.iocharset, \"utf8\"))\n\t\topts->utf8 = 1;\n\telse {\n\t\tsbi->nls_io = load_nls(sbi->options.iocharset);\n\t\tif (!sbi->nls_io) {\n\t\t\texfat_err(sb, \"IO charset %s not found\",\n\t\t\t\t  sbi->options.iocharset);\n\t\t\terr = -EINVAL;\n\t\t\tgoto free_table;\n\t\t}\n\t}\n\n\tif (sbi->options.utf8)\n\t\tsb->s_d_op = &exfat_utf8_dentry_ops;\n\telse\n\t\tsb->s_d_op = &exfat_dentry_ops;\n\n\troot_inode = new_inode(sb);\n\tif (!root_inode) {\n\t\texfat_err(sb, \"failed to allocate root inode\");\n\t\terr = -ENOMEM;\n\t\tgoto free_table;\n\t}\n\n\troot_inode->i_ino = EXFAT_ROOT_INO;\n\tinode_set_iversion(root_inode, 1);\n\terr = exfat_read_root(root_inode);\n\tif (err) {\n\t\texfat_err(sb, \"failed to initialize root inode\");\n\t\tgoto put_inode;\n\t}\n\n\texfat_hash_inode(root_inode, EXFAT_I(root_inode)->i_pos);\n\tinsert_inode_hash(root_inode);\n\n\tsb->s_root = d_make_root(root_inode);\n\tif (!sb->s_root) {\n\t\texfat_err(sb, \"failed to get the root dentry\");\n\t\terr = -ENOMEM;\n\t\tgoto free_table;\n\t}\n\n\treturn 0;\n\nput_inode:\n\tiput(root_inode);\n\tsb->s_root = NULL;\n\nfree_table:\n\texfat_free_upcase_table(sbi);\n\texfat_free_bitmap(sbi);\n\tbrelse(sbi->boot_bh);\n\ncheck_nls_io:\n\tunload_nls(sbi->nls_io);\n\treturn err;\n}\n\nstatic int exfat_get_tree(struct fs_context *fc)\n{\n\treturn get_tree_bdev(fc, exfat_fill_super);\n}\n\nstatic void exfat_free_sbi(struct exfat_sb_info *sbi)\n{\n\texfat_free_iocharset(sbi);\n\tkfree(sbi);\n}\n\nstatic void exfat_free(struct fs_context *fc)\n{\n\tstruct exfat_sb_info *sbi = fc->s_fs_info;\n\n\tif (sbi)\n\t\texfat_free_sbi(sbi);\n}\n\nstatic int exfat_reconfigure(struct fs_context *fc)\n{\n\tfc->sb_flags |= SB_NODIRATIME;\n\n\t \n\tsync_filesystem(fc->root->d_sb);\n\treturn 0;\n}\n\nstatic const struct fs_context_operations exfat_context_ops = {\n\t.parse_param\t= exfat_parse_param,\n\t.get_tree\t= exfat_get_tree,\n\t.free\t\t= exfat_free,\n\t.reconfigure\t= exfat_reconfigure,\n};\n\nstatic int exfat_init_fs_context(struct fs_context *fc)\n{\n\tstruct exfat_sb_info *sbi;\n\n\tsbi = kzalloc(sizeof(struct exfat_sb_info), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&sbi->s_lock);\n\tmutex_init(&sbi->bitmap_lock);\n\tratelimit_state_init(&sbi->ratelimit, DEFAULT_RATELIMIT_INTERVAL,\n\t\t\tDEFAULT_RATELIMIT_BURST);\n\n\tsbi->options.fs_uid = current_uid();\n\tsbi->options.fs_gid = current_gid();\n\tsbi->options.fs_fmask = current->fs->umask;\n\tsbi->options.fs_dmask = current->fs->umask;\n\tsbi->options.allow_utime = -1;\n\tsbi->options.iocharset = exfat_default_iocharset;\n\tsbi->options.errors = EXFAT_ERRORS_RO;\n\n\tfc->s_fs_info = sbi;\n\tfc->ops = &exfat_context_ops;\n\treturn 0;\n}\n\nstatic void exfat_kill_sb(struct super_block *sb)\n{\n\tstruct exfat_sb_info *sbi = sb->s_fs_info;\n\n\tkill_block_super(sb);\n\tif (sbi)\n\t\texfat_free_sbi(sbi);\n}\n\nstatic struct file_system_type exfat_fs_type = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.name\t\t\t= \"exfat\",\n\t.init_fs_context\t= exfat_init_fs_context,\n\t.parameters\t\t= exfat_parameters,\n\t.kill_sb\t\t= exfat_kill_sb,\n\t.fs_flags\t\t= FS_REQUIRES_DEV,\n};\n\nstatic void exfat_inode_init_once(void *foo)\n{\n\tstruct exfat_inode_info *ei = (struct exfat_inode_info *)foo;\n\n\tspin_lock_init(&ei->cache_lru_lock);\n\tei->nr_caches = 0;\n\tei->cache_valid_id = EXFAT_CACHE_VALID + 1;\n\tINIT_LIST_HEAD(&ei->cache_lru);\n\tINIT_HLIST_NODE(&ei->i_hash_fat);\n\tinode_init_once(&ei->vfs_inode);\n}\n\nstatic int __init init_exfat_fs(void)\n{\n\tint err;\n\n\terr = exfat_cache_init();\n\tif (err)\n\t\treturn err;\n\n\texfat_inode_cachep = kmem_cache_create(\"exfat_inode_cache\",\n\t\t\tsizeof(struct exfat_inode_info),\n\t\t\t0, SLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD,\n\t\t\texfat_inode_init_once);\n\tif (!exfat_inode_cachep) {\n\t\terr = -ENOMEM;\n\t\tgoto shutdown_cache;\n\t}\n\n\terr = register_filesystem(&exfat_fs_type);\n\tif (err)\n\t\tgoto destroy_cache;\n\n\treturn 0;\n\ndestroy_cache:\n\tkmem_cache_destroy(exfat_inode_cachep);\nshutdown_cache:\n\texfat_cache_shutdown();\n\treturn err;\n}\n\nstatic void __exit exit_exfat_fs(void)\n{\n\t \n\trcu_barrier();\n\tkmem_cache_destroy(exfat_inode_cachep);\n\tunregister_filesystem(&exfat_fs_type);\n\texfat_cache_shutdown();\n}\n\nmodule_init(init_exfat_fs);\nmodule_exit(exit_exfat_fs);\n\nMODULE_ALIAS_FS(\"exfat\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"exFAT filesystem support\");\nMODULE_AUTHOR(\"Samsung Electronics Co., Ltd.\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}