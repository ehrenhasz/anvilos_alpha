{
  "module_name": "misc.c",
  "hash_id": "dce1845f67ef8dad5c92fdb6824d8ecb0189f852c5d646cec4c67ffe869d1dc7",
  "original_prompt": "Ingested from linux-6.6.14/fs/exfat/misc.c",
  "human_readable_source": "\n \n\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/blk_types.h>\n\n#include \"exfat_raw.h\"\n#include \"exfat_fs.h\"\n\n \nvoid __exfat_fs_error(struct super_block *sb, int report, const char *fmt, ...)\n{\n\tstruct exfat_mount_options *opts = &EXFAT_SB(sb)->options;\n\tva_list args;\n\tstruct va_format vaf;\n\n\tif (report) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\texfat_err(sb, \"error, %pV\", &vaf);\n\t\tva_end(args);\n\t}\n\n\tif (opts->errors == EXFAT_ERRORS_PANIC) {\n\t\tpanic(\"exFAT-fs (%s): fs panic from previous error\\n\",\n\t\t\tsb->s_id);\n\t} else if (opts->errors == EXFAT_ERRORS_RO && !sb_rdonly(sb)) {\n\t\tsb->s_flags |= SB_RDONLY;\n\t\texfat_err(sb, \"Filesystem has been set read-only\");\n\t}\n}\n\n#define SECS_PER_MIN    (60)\n#define TIMEZONE_SEC(x)\t((x) * 15 * SECS_PER_MIN)\n\nstatic void exfat_adjust_tz(struct timespec64 *ts, u8 tz_off)\n{\n\tif (tz_off <= 0x3F)\n\t\tts->tv_sec -= TIMEZONE_SEC(tz_off);\n\telse  \n\t\tts->tv_sec += TIMEZONE_SEC(0x80 - tz_off);\n}\n\nstatic inline int exfat_tz_offset(struct exfat_sb_info *sbi)\n{\n\tif (sbi->options.sys_tz)\n\t\treturn -sys_tz.tz_minuteswest;\n\treturn sbi->options.time_offset;\n}\n\n \nvoid exfat_get_entry_time(struct exfat_sb_info *sbi, struct timespec64 *ts,\n\t\tu8 tz, __le16 time, __le16 date, u8 time_cs)\n{\n\tu16 t = le16_to_cpu(time);\n\tu16 d = le16_to_cpu(date);\n\n\tts->tv_sec = mktime64(1980 + (d >> 9), d >> 5 & 0x000F, d & 0x001F,\n\t\t\t      t >> 11, (t >> 5) & 0x003F, (t & 0x001F) << 1);\n\n\n\t \n\tif (time_cs) {\n\t\tts->tv_sec += time_cs / 100;\n\t\tts->tv_nsec = (time_cs % 100) * 10 * NSEC_PER_MSEC;\n\t} else\n\t\tts->tv_nsec = 0;\n\n\tif (tz & EXFAT_TZ_VALID)\n\t\t \n\t\texfat_adjust_tz(ts, tz & ~EXFAT_TZ_VALID);\n\telse\n\t\tts->tv_sec -= exfat_tz_offset(sbi) * SECS_PER_MIN;\n}\n\n \nvoid exfat_set_entry_time(struct exfat_sb_info *sbi, struct timespec64 *ts,\n\t\tu8 *tz, __le16 *time, __le16 *date, u8 *time_cs)\n{\n\tstruct tm tm;\n\tu16 t, d;\n\n\ttime64_to_tm(ts->tv_sec, 0, &tm);\n\tt = (tm.tm_hour << 11) | (tm.tm_min << 5) | (tm.tm_sec >> 1);\n\td = ((tm.tm_year - 80) <<  9) | ((tm.tm_mon + 1) << 5) | tm.tm_mday;\n\n\t*time = cpu_to_le16(t);\n\t*date = cpu_to_le16(d);\n\n\t \n\tif (time_cs)\n\t\t*time_cs = (tm.tm_sec & 1) * 100 +\n\t\t\tts->tv_nsec / (10 * NSEC_PER_MSEC);\n\n\t \n\t*tz = EXFAT_TZ_VALID;\n}\n\n \nvoid exfat_truncate_atime(struct timespec64 *ts)\n{\n\tts->tv_sec = round_down(ts->tv_sec, 2);\n\tts->tv_nsec = 0;\n}\n\nu16 exfat_calc_chksum16(void *data, int len, u16 chksum, int type)\n{\n\tint i;\n\tu8 *c = (u8 *)data;\n\n\tfor (i = 0; i < len; i++, c++) {\n\t\tif (unlikely(type == CS_DIR_ENTRY && (i == 2 || i == 3)))\n\t\t\tcontinue;\n\t\tchksum = ((chksum << 15) | (chksum >> 1)) + *c;\n\t}\n\treturn chksum;\n}\n\nu32 exfat_calc_chksum32(void *data, int len, u32 chksum, int type)\n{\n\tint i;\n\tu8 *c = (u8 *)data;\n\n\tfor (i = 0; i < len; i++, c++) {\n\t\tif (unlikely(type == CS_BOOT_SECTOR &&\n\t\t\t     (i == 106 || i == 107 || i == 112)))\n\t\t\tcontinue;\n\t\tchksum = ((chksum << 31) | (chksum >> 1)) + *c;\n\t}\n\treturn chksum;\n}\n\nvoid exfat_update_bh(struct buffer_head *bh, int sync)\n{\n\tset_buffer_uptodate(bh);\n\tmark_buffer_dirty(bh);\n\n\tif (sync)\n\t\tsync_dirty_buffer(bh);\n}\n\nint exfat_update_bhs(struct buffer_head **bhs, int nr_bhs, int sync)\n{\n\tint i, err = 0;\n\n\tfor (i = 0; i < nr_bhs; i++) {\n\t\tset_buffer_uptodate(bhs[i]);\n\t\tmark_buffer_dirty(bhs[i]);\n\t\tif (sync)\n\t\t\twrite_dirty_buffer(bhs[i], REQ_SYNC);\n\t}\n\n\tfor (i = 0; i < nr_bhs && sync; i++) {\n\t\twait_on_buffer(bhs[i]);\n\t\tif (!err && !buffer_uptodate(bhs[i]))\n\t\t\terr = -EIO;\n\t}\n\treturn err;\n}\n\nvoid exfat_chain_set(struct exfat_chain *ec, unsigned int dir,\n\t\tunsigned int size, unsigned char flags)\n{\n\tec->dir = dir;\n\tec->size = size;\n\tec->flags = flags;\n}\n\nvoid exfat_chain_dup(struct exfat_chain *dup, struct exfat_chain *ec)\n{\n\treturn exfat_chain_set(dup, ec->dir, ec->size, ec->flags);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}