{
  "module_name": "inode.c",
  "hash_id": "68e9edab0ae6237d849c1c03d48be8d2bab82fbe5a84a8ad6b6c3835a82a4fc8",
  "original_prompt": "Ingested from linux-6.6.14/fs/exfat/inode.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/time.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/random.h>\n#include <linux/iversion.h>\n\n#include \"exfat_raw.h\"\n#include \"exfat_fs.h\"\n\nint __exfat_write_inode(struct inode *inode, int sync)\n{\n\tunsigned long long on_disk_size;\n\tstruct exfat_dentry *ep, *ep2;\n\tstruct exfat_entry_set_cache es;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct exfat_sb_info *sbi = EXFAT_SB(sb);\n\tstruct exfat_inode_info *ei = EXFAT_I(inode);\n\tbool is_dir = (ei->type == TYPE_DIR) ? true : false;\n\n\tif (inode->i_ino == EXFAT_ROOT_INO)\n\t\treturn 0;\n\n\t \n\tif (ei->dir.dir == DIR_DELETED)\n\t\treturn 0;\n\n\tif (is_dir && ei->dir.dir == sbi->root_dir && ei->entry == -1)\n\t\treturn 0;\n\n\texfat_set_volume_dirty(sb);\n\n\t \n\tif (exfat_get_dentry_set(&es, sb, &(ei->dir), ei->entry, ES_ALL_ENTRIES))\n\t\treturn -EIO;\n\tep = exfat_get_dentry_cached(&es, ES_IDX_FILE);\n\tep2 = exfat_get_dentry_cached(&es, ES_IDX_STREAM);\n\n\tep->dentry.file.attr = cpu_to_le16(exfat_make_attr(inode));\n\n\t \n\texfat_set_entry_time(sbi, &ei->i_crtime,\n\t\t\t&ep->dentry.file.create_tz,\n\t\t\t&ep->dentry.file.create_time,\n\t\t\t&ep->dentry.file.create_date,\n\t\t\t&ep->dentry.file.create_time_cs);\n\texfat_set_entry_time(sbi, &inode->i_mtime,\n\t\t\t&ep->dentry.file.modify_tz,\n\t\t\t&ep->dentry.file.modify_time,\n\t\t\t&ep->dentry.file.modify_date,\n\t\t\t&ep->dentry.file.modify_time_cs);\n\texfat_set_entry_time(sbi, &inode->i_atime,\n\t\t\t&ep->dentry.file.access_tz,\n\t\t\t&ep->dentry.file.access_time,\n\t\t\t&ep->dentry.file.access_date,\n\t\t\tNULL);\n\n\t \n\ton_disk_size = i_size_read(inode);\n\n\tif (ei->start_clu == EXFAT_EOF_CLUSTER)\n\t\ton_disk_size = 0;\n\n\tep2->dentry.stream.valid_size = cpu_to_le64(on_disk_size);\n\tep2->dentry.stream.size = ep2->dentry.stream.valid_size;\n\tif (on_disk_size) {\n\t\tep2->dentry.stream.flags = ei->flags;\n\t\tep2->dentry.stream.start_clu = cpu_to_le32(ei->start_clu);\n\t} else {\n\t\tep2->dentry.stream.flags = ALLOC_FAT_CHAIN;\n\t\tep2->dentry.stream.start_clu = EXFAT_FREE_CLUSTER;\n\t}\n\n\texfat_update_dir_chksum_with_entry_set(&es);\n\treturn exfat_put_dentry_set(&es, sync);\n}\n\nint exfat_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tint ret;\n\n\tmutex_lock(&EXFAT_SB(inode->i_sb)->s_lock);\n\tret = __exfat_write_inode(inode, wbc->sync_mode == WB_SYNC_ALL);\n\tmutex_unlock(&EXFAT_SB(inode->i_sb)->s_lock);\n\n\treturn ret;\n}\n\nvoid exfat_sync_inode(struct inode *inode)\n{\n\tlockdep_assert_held(&EXFAT_SB(inode->i_sb)->s_lock);\n\t__exfat_write_inode(inode, 1);\n}\n\n \nstatic int exfat_map_cluster(struct inode *inode, unsigned int clu_offset,\n\t\tunsigned int *clu, int create)\n{\n\tint ret;\n\tunsigned int last_clu;\n\tstruct exfat_chain new_clu;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct exfat_sb_info *sbi = EXFAT_SB(sb);\n\tstruct exfat_inode_info *ei = EXFAT_I(inode);\n\tunsigned int local_clu_offset = clu_offset;\n\tunsigned int num_to_be_allocated = 0, num_clusters = 0;\n\n\tif (ei->i_size_ondisk > 0)\n\t\tnum_clusters =\n\t\t\tEXFAT_B_TO_CLU_ROUND_UP(ei->i_size_ondisk, sbi);\n\n\tif (clu_offset >= num_clusters)\n\t\tnum_to_be_allocated = clu_offset - num_clusters + 1;\n\n\tif (!create && (num_to_be_allocated > 0)) {\n\t\t*clu = EXFAT_EOF_CLUSTER;\n\t\treturn 0;\n\t}\n\n\t*clu = last_clu = ei->start_clu;\n\n\tif (ei->flags == ALLOC_NO_FAT_CHAIN) {\n\t\tif (clu_offset > 0 && *clu != EXFAT_EOF_CLUSTER) {\n\t\t\tlast_clu += clu_offset - 1;\n\n\t\t\tif (clu_offset == num_clusters)\n\t\t\t\t*clu = EXFAT_EOF_CLUSTER;\n\t\t\telse\n\t\t\t\t*clu += clu_offset;\n\t\t}\n\t} else if (ei->type == TYPE_FILE) {\n\t\tunsigned int fclus = 0;\n\t\tint err = exfat_get_cluster(inode, clu_offset,\n\t\t\t\t&fclus, clu, &last_clu, 1);\n\t\tif (err)\n\t\t\treturn -EIO;\n\n\t\tclu_offset -= fclus;\n\t} else {\n\t\t \n\t\tif (clu_offset > 0 && ei->hint_bmap.off != EXFAT_EOF_CLUSTER &&\n\t\t    ei->hint_bmap.off > 0 && clu_offset >= ei->hint_bmap.off) {\n\t\t\tclu_offset -= ei->hint_bmap.off;\n\t\t\t \n\t\t\tWARN_ON(ei->hint_bmap.clu < 2);\n\t\t\t*clu = ei->hint_bmap.clu;\n\t\t}\n\n\t\twhile (clu_offset > 0 && *clu != EXFAT_EOF_CLUSTER) {\n\t\t\tlast_clu = *clu;\n\t\t\tif (exfat_get_next_cluster(sb, clu))\n\t\t\t\treturn -EIO;\n\t\t\tclu_offset--;\n\t\t}\n\t}\n\n\tif (*clu == EXFAT_EOF_CLUSTER) {\n\t\texfat_set_volume_dirty(sb);\n\n\t\tnew_clu.dir = (last_clu == EXFAT_EOF_CLUSTER) ?\n\t\t\t\tEXFAT_EOF_CLUSTER : last_clu + 1;\n\t\tnew_clu.size = 0;\n\t\tnew_clu.flags = ei->flags;\n\n\t\t \n\t\tif (num_to_be_allocated < 1) {\n\t\t\t \n\t\t\texfat_fs_error(sb, \"broken FAT chain.\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tret = exfat_alloc_cluster(inode, num_to_be_allocated, &new_clu,\n\t\t\t\tinode_needs_sync(inode));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (new_clu.dir == EXFAT_EOF_CLUSTER ||\n\t\t    new_clu.dir == EXFAT_FREE_CLUSTER) {\n\t\t\texfat_fs_error(sb,\n\t\t\t\t\"bogus cluster new allocated (last_clu : %u, new_clu : %u)\",\n\t\t\t\tlast_clu, new_clu.dir);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t \n\t\tif (last_clu == EXFAT_EOF_CLUSTER) {\n\t\t\tif (new_clu.flags == ALLOC_FAT_CHAIN)\n\t\t\t\tei->flags = ALLOC_FAT_CHAIN;\n\t\t\tei->start_clu = new_clu.dir;\n\t\t} else {\n\t\t\tif (new_clu.flags != ei->flags) {\n\t\t\t\t \n\t\t\t\texfat_chain_cont_cluster(sb, ei->start_clu,\n\t\t\t\t\tnum_clusters);\n\t\t\t\tei->flags = ALLOC_FAT_CHAIN;\n\t\t\t}\n\t\t\tif (new_clu.flags == ALLOC_FAT_CHAIN)\n\t\t\t\tif (exfat_ent_set(sb, last_clu, new_clu.dir))\n\t\t\t\t\treturn -EIO;\n\t\t}\n\n\t\tnum_clusters += num_to_be_allocated;\n\t\t*clu = new_clu.dir;\n\n\t\tinode->i_blocks += EXFAT_CLU_TO_B(num_to_be_allocated, sbi) >> 9;\n\n\t\t \n\t\tif (ei->flags == ALLOC_NO_FAT_CHAIN) {\n\t\t\t*clu += num_to_be_allocated - 1;\n\t\t} else {\n\t\t\twhile (num_to_be_allocated > 1) {\n\t\t\t\tif (exfat_get_next_cluster(sb, clu))\n\t\t\t\t\treturn -EIO;\n\t\t\t\tnum_to_be_allocated--;\n\t\t\t}\n\t\t}\n\n\t}\n\n\t \n\tei->hint_bmap.off = local_clu_offset;\n\tei->hint_bmap.clu = *clu;\n\n\treturn 0;\n}\n\nstatic int exfat_map_new_buffer(struct exfat_inode_info *ei,\n\t\tstruct buffer_head *bh, loff_t pos)\n{\n\tif (buffer_delay(bh) && pos > ei->i_size_aligned)\n\t\treturn -EIO;\n\tset_buffer_new(bh);\n\n\t \n\tif (ei->i_size_ondisk > ei->i_size_aligned)\n\t\tei->i_size_aligned = ei->i_size_ondisk;\n\treturn 0;\n}\n\nstatic int exfat_get_block(struct inode *inode, sector_t iblock,\n\t\tstruct buffer_head *bh_result, int create)\n{\n\tstruct exfat_inode_info *ei = EXFAT_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct exfat_sb_info *sbi = EXFAT_SB(sb);\n\tunsigned long max_blocks = bh_result->b_size >> inode->i_blkbits;\n\tint err = 0;\n\tunsigned long mapped_blocks = 0;\n\tunsigned int cluster, sec_offset;\n\tsector_t last_block;\n\tsector_t phys = 0;\n\tloff_t pos;\n\n\tmutex_lock(&sbi->s_lock);\n\tlast_block = EXFAT_B_TO_BLK_ROUND_UP(i_size_read(inode), sb);\n\tif (iblock >= last_block && !create)\n\t\tgoto done;\n\n\t \n\terr = exfat_map_cluster(inode, iblock >> sbi->sect_per_clus_bits,\n\t\t\t&cluster, create);\n\tif (err) {\n\t\tif (err != -ENOSPC)\n\t\t\texfat_fs_error_ratelimit(sb,\n\t\t\t\t\"failed to bmap (inode : %p iblock : %llu, err : %d)\",\n\t\t\t\tinode, (unsigned long long)iblock, err);\n\t\tgoto unlock_ret;\n\t}\n\n\tif (cluster == EXFAT_EOF_CLUSTER)\n\t\tgoto done;\n\n\t \n\tsec_offset = iblock & (sbi->sect_per_clus - 1);\n\n\tphys = exfat_cluster_to_sector(sbi, cluster) + sec_offset;\n\tmapped_blocks = sbi->sect_per_clus - sec_offset;\n\tmax_blocks = min(mapped_blocks, max_blocks);\n\n\t \n\tif (iblock < last_block)\n\t\tcreate = 0;\n\n\tif (create || buffer_delay(bh_result)) {\n\t\tpos = EXFAT_BLK_TO_B((iblock + 1), sb);\n\t\tif (ei->i_size_ondisk < pos)\n\t\t\tei->i_size_ondisk = pos;\n\t}\n\n\tif (create) {\n\t\terr = exfat_map_new_buffer(ei, bh_result, pos);\n\t\tif (err) {\n\t\t\texfat_fs_error(sb,\n\t\t\t\t\t\"requested for bmap out of range(pos : (%llu) > i_size_aligned(%llu)\\n\",\n\t\t\t\t\tpos, ei->i_size_aligned);\n\t\t\tgoto unlock_ret;\n\t\t}\n\t}\n\n\tif (buffer_delay(bh_result))\n\t\tclear_buffer_delay(bh_result);\n\tmap_bh(bh_result, sb, phys);\ndone:\n\tbh_result->b_size = EXFAT_BLK_TO_B(max_blocks, sb);\nunlock_ret:\n\tmutex_unlock(&sbi->s_lock);\n\treturn err;\n}\n\nstatic int exfat_read_folio(struct file *file, struct folio *folio)\n{\n\treturn mpage_read_folio(folio, exfat_get_block);\n}\n\nstatic void exfat_readahead(struct readahead_control *rac)\n{\n\tmpage_readahead(rac, exfat_get_block);\n}\n\nstatic int exfat_writepages(struct address_space *mapping,\n\t\tstruct writeback_control *wbc)\n{\n\treturn mpage_writepages(mapping, wbc, exfat_get_block);\n}\n\nstatic void exfat_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > i_size_read(inode)) {\n\t\ttruncate_pagecache(inode, i_size_read(inode));\n\t\tinode->i_mtime = inode_set_ctime_current(inode);\n\t\texfat_truncate(inode);\n\t}\n}\n\nstatic int exfat_write_begin(struct file *file, struct address_space *mapping,\n\t\tloff_t pos, unsigned int len,\n\t\tstruct page **pagep, void **fsdata)\n{\n\tint ret;\n\n\t*pagep = NULL;\n\tret = cont_write_begin(file, mapping, pos, len, pagep, fsdata,\n\t\t\t       exfat_get_block,\n\t\t\t       &EXFAT_I(mapping->host)->i_size_ondisk);\n\n\tif (ret < 0)\n\t\texfat_write_failed(mapping, pos+len);\n\n\treturn ret;\n}\n\nstatic int exfat_write_end(struct file *file, struct address_space *mapping,\n\t\tloff_t pos, unsigned int len, unsigned int copied,\n\t\tstruct page *pagep, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct exfat_inode_info *ei = EXFAT_I(inode);\n\tint err;\n\n\terr = generic_write_end(file, mapping, pos, len, copied, pagep, fsdata);\n\n\tif (ei->i_size_aligned < i_size_read(inode)) {\n\t\texfat_fs_error(inode->i_sb,\n\t\t\t\"invalid size(size(%llu) > aligned(%llu)\\n\",\n\t\t\ti_size_read(inode), ei->i_size_aligned);\n\t\treturn -EIO;\n\t}\n\n\tif (err < len)\n\t\texfat_write_failed(mapping, pos+len);\n\n\tif (!(err < 0) && !(ei->attr & ATTR_ARCHIVE)) {\n\t\tinode->i_mtime = inode_set_ctime_current(inode);\n\t\tei->attr |= ATTR_ARCHIVE;\n\t\tmark_inode_dirty(inode);\n\t}\n\n\treturn err;\n}\n\nstatic ssize_t exfat_direct_IO(struct kiocb *iocb, struct iov_iter *iter)\n{\n\tstruct address_space *mapping = iocb->ki_filp->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tloff_t size = iocb->ki_pos + iov_iter_count(iter);\n\tint rw = iov_iter_rw(iter);\n\tssize_t ret;\n\n\tif (rw == WRITE) {\n\t\t \n\t\tif (EXFAT_I(inode)->i_size_aligned < size)\n\t\t\treturn 0;\n\t}\n\n\t \n\tret = blockdev_direct_IO(iocb, inode, iter, exfat_get_block);\n\tif (ret < 0 && (rw & WRITE))\n\t\texfat_write_failed(mapping, size);\n\treturn ret;\n}\n\nstatic sector_t exfat_aop_bmap(struct address_space *mapping, sector_t block)\n{\n\tsector_t blocknr;\n\n\t \n\tdown_read(&EXFAT_I(mapping->host)->truncate_lock);\n\tblocknr = generic_block_bmap(mapping, block, exfat_get_block);\n\tup_read(&EXFAT_I(mapping->host)->truncate_lock);\n\treturn blocknr;\n}\n\n \nint exfat_block_truncate_page(struct inode *inode, loff_t from)\n{\n\treturn block_truncate_page(inode->i_mapping, from, exfat_get_block);\n}\n\nstatic const struct address_space_operations exfat_aops = {\n\t.dirty_folio\t= block_dirty_folio,\n\t.invalidate_folio = block_invalidate_folio,\n\t.read_folio\t= exfat_read_folio,\n\t.readahead\t= exfat_readahead,\n\t.writepages\t= exfat_writepages,\n\t.write_begin\t= exfat_write_begin,\n\t.write_end\t= exfat_write_end,\n\t.direct_IO\t= exfat_direct_IO,\n\t.bmap\t\t= exfat_aop_bmap,\n\t.migrate_folio\t= buffer_migrate_folio,\n};\n\nstatic inline unsigned long exfat_hash(loff_t i_pos)\n{\n\treturn hash_32(i_pos, EXFAT_HASH_BITS);\n}\n\nvoid exfat_hash_inode(struct inode *inode, loff_t i_pos)\n{\n\tstruct exfat_sb_info *sbi = EXFAT_SB(inode->i_sb);\n\tstruct hlist_head *head = sbi->inode_hashtable + exfat_hash(i_pos);\n\n\tspin_lock(&sbi->inode_hash_lock);\n\tEXFAT_I(inode)->i_pos = i_pos;\n\thlist_add_head(&EXFAT_I(inode)->i_hash_fat, head);\n\tspin_unlock(&sbi->inode_hash_lock);\n}\n\nvoid exfat_unhash_inode(struct inode *inode)\n{\n\tstruct exfat_sb_info *sbi = EXFAT_SB(inode->i_sb);\n\n\tspin_lock(&sbi->inode_hash_lock);\n\thlist_del_init(&EXFAT_I(inode)->i_hash_fat);\n\tEXFAT_I(inode)->i_pos = 0;\n\tspin_unlock(&sbi->inode_hash_lock);\n}\n\nstruct inode *exfat_iget(struct super_block *sb, loff_t i_pos)\n{\n\tstruct exfat_sb_info *sbi = EXFAT_SB(sb);\n\tstruct exfat_inode_info *info;\n\tstruct hlist_head *head = sbi->inode_hashtable + exfat_hash(i_pos);\n\tstruct inode *inode = NULL;\n\n\tspin_lock(&sbi->inode_hash_lock);\n\thlist_for_each_entry(info, head, i_hash_fat) {\n\t\tWARN_ON(info->vfs_inode.i_sb != sb);\n\n\t\tif (i_pos != info->i_pos)\n\t\t\tcontinue;\n\t\tinode = igrab(&info->vfs_inode);\n\t\tif (inode)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&sbi->inode_hash_lock);\n\treturn inode;\n}\n\n \nstatic int exfat_fill_inode(struct inode *inode, struct exfat_dir_entry *info)\n{\n\tstruct exfat_sb_info *sbi = EXFAT_SB(inode->i_sb);\n\tstruct exfat_inode_info *ei = EXFAT_I(inode);\n\tloff_t size = info->size;\n\n\tei->dir = info->dir;\n\tei->entry = info->entry;\n\tei->attr = info->attr;\n\tei->start_clu = info->start_clu;\n\tei->flags = info->flags;\n\tei->type = info->type;\n\n\tei->version = 0;\n\tei->hint_stat.eidx = 0;\n\tei->hint_stat.clu = info->start_clu;\n\tei->hint_femp.eidx = EXFAT_HINT_NONE;\n\tei->hint_bmap.off = EXFAT_EOF_CLUSTER;\n\tei->i_pos = 0;\n\n\tinode->i_uid = sbi->options.fs_uid;\n\tinode->i_gid = sbi->options.fs_gid;\n\tinode_inc_iversion(inode);\n\tinode->i_generation = get_random_u32();\n\n\tif (info->attr & ATTR_SUBDIR) {  \n\t\tinode->i_generation &= ~1;\n\t\tinode->i_mode = exfat_make_mode(sbi, info->attr, 0777);\n\t\tinode->i_op = &exfat_dir_inode_operations;\n\t\tinode->i_fop = &exfat_dir_operations;\n\t\tset_nlink(inode, info->num_subdirs);\n\t} else {  \n\t\tinode->i_generation |= 1;\n\t\tinode->i_mode = exfat_make_mode(sbi, info->attr, 0777);\n\t\tinode->i_op = &exfat_file_inode_operations;\n\t\tinode->i_fop = &exfat_file_operations;\n\t\tinode->i_mapping->a_ops = &exfat_aops;\n\t\tinode->i_mapping->nrpages = 0;\n\t}\n\n\ti_size_write(inode, size);\n\n\t \n\tif (size & (inode->i_sb->s_blocksize - 1)) {\n\t\tsize |= (inode->i_sb->s_blocksize - 1);\n\t\tsize++;\n\t}\n\n\tei->i_size_aligned = size;\n\tei->i_size_ondisk = size;\n\n\texfat_save_attr(inode, info->attr);\n\n\tinode->i_blocks = round_up(i_size_read(inode), sbi->cluster_size) >> 9;\n\tinode->i_mtime = info->mtime;\n\tinode_set_ctime_to_ts(inode, info->mtime);\n\tei->i_crtime = info->crtime;\n\tinode->i_atime = info->atime;\n\n\treturn 0;\n}\n\nstruct inode *exfat_build_inode(struct super_block *sb,\n\t\tstruct exfat_dir_entry *info, loff_t i_pos)\n{\n\tstruct inode *inode;\n\tint err;\n\n\tinode = exfat_iget(sb, i_pos);\n\tif (inode)\n\t\tgoto out;\n\tinode = new_inode(sb);\n\tif (!inode) {\n\t\tinode = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\tinode->i_ino = iunique(sb, EXFAT_ROOT_INO);\n\tinode_set_iversion(inode, 1);\n\terr = exfat_fill_inode(inode, info);\n\tif (err) {\n\t\tiput(inode);\n\t\tinode = ERR_PTR(err);\n\t\tgoto out;\n\t}\n\texfat_hash_inode(inode, i_pos);\n\tinsert_inode_hash(inode);\nout:\n\treturn inode;\n}\n\nvoid exfat_evict_inode(struct inode *inode)\n{\n\ttruncate_inode_pages(&inode->i_data, 0);\n\n\tif (!inode->i_nlink) {\n\t\ti_size_write(inode, 0);\n\t\tmutex_lock(&EXFAT_SB(inode->i_sb)->s_lock);\n\t\t__exfat_truncate(inode);\n\t\tmutex_unlock(&EXFAT_SB(inode->i_sb)->s_lock);\n\t}\n\n\tinvalidate_inode_buffers(inode);\n\tclear_inode(inode);\n\texfat_cache_inval_inode(inode);\n\texfat_unhash_inode(inode);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}