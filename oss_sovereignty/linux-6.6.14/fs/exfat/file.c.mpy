{
  "module_name": "file.c",
  "hash_id": "73f4401fe104ee36f844c513967c55cac7645a00929a331765091164566f3b28",
  "original_prompt": "Ingested from linux-6.6.14/fs/exfat/file.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/cred.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n\n#include \"exfat_raw.h\"\n#include \"exfat_fs.h\"\n\nstatic int exfat_cont_expand(struct inode *inode, loff_t size)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tloff_t start = i_size_read(inode), count = size - i_size_read(inode);\n\tint err, err2;\n\n\terr = generic_cont_expand_simple(inode, size);\n\tif (err)\n\t\treturn err;\n\n\tinode->i_mtime = inode_set_ctime_current(inode);\n\tmark_inode_dirty(inode);\n\n\tif (!IS_SYNC(inode))\n\t\treturn 0;\n\n\terr = filemap_fdatawrite_range(mapping, start, start + count - 1);\n\terr2 = sync_mapping_buffers(mapping);\n\tif (!err)\n\t\terr = err2;\n\terr2 = write_inode_now(inode, 1);\n\tif (!err)\n\t\terr = err2;\n\tif (err)\n\t\treturn err;\n\n\treturn filemap_fdatawait_range(mapping, start, start + count - 1);\n}\n\nstatic bool exfat_allow_set_time(struct exfat_sb_info *sbi, struct inode *inode)\n{\n\tmode_t allow_utime = sbi->options.allow_utime;\n\n\tif (!uid_eq(current_fsuid(), inode->i_uid)) {\n\t\tif (in_group_p(inode->i_gid))\n\t\t\tallow_utime >>= 3;\n\t\tif (allow_utime & MAY_WRITE)\n\t\t\treturn true;\n\t}\n\n\t \n\treturn false;\n}\n\nstatic int exfat_sanitize_mode(const struct exfat_sb_info *sbi,\n\t\tstruct inode *inode, umode_t *mode_ptr)\n{\n\tmode_t i_mode, mask, perm;\n\n\ti_mode = inode->i_mode;\n\n\tmask = (S_ISREG(i_mode) || S_ISLNK(i_mode)) ?\n\t\tsbi->options.fs_fmask : sbi->options.fs_dmask;\n\tperm = *mode_ptr & ~(S_IFMT | mask);\n\n\t \n\tif ((perm & 0555) != (i_mode & 0555))\n\t\treturn -EPERM;\n\n\tif (exfat_mode_can_hold_ro(inode)) {\n\t\t \n\t\tif ((perm & 0222) && ((perm & 0222) != (0222 & ~mask)))\n\t\t\treturn -EPERM;\n\t} else {\n\t\t \n\t\tif ((perm & 0222) != (0222 & ~mask))\n\t\t\treturn -EPERM;\n\t}\n\n\t*mode_ptr &= S_IFMT | perm;\n\n\treturn 0;\n}\n\n \nint __exfat_truncate(struct inode *inode)\n{\n\tunsigned int num_clusters_new, num_clusters_phys;\n\tunsigned int last_clu = EXFAT_FREE_CLUSTER;\n\tstruct exfat_chain clu;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct exfat_sb_info *sbi = EXFAT_SB(sb);\n\tstruct exfat_inode_info *ei = EXFAT_I(inode);\n\n\t \n\tif (ei->type != TYPE_FILE && ei->type != TYPE_DIR)\n\t\treturn -EPERM;\n\n\texfat_set_volume_dirty(sb);\n\n\tnum_clusters_new = EXFAT_B_TO_CLU_ROUND_UP(i_size_read(inode), sbi);\n\tnum_clusters_phys = EXFAT_B_TO_CLU_ROUND_UP(ei->i_size_ondisk, sbi);\n\n\texfat_chain_set(&clu, ei->start_clu, num_clusters_phys, ei->flags);\n\n\tif (i_size_read(inode) > 0) {\n\t\t \n\t\tunsigned int num_clusters =\n\t\t\tmin(num_clusters_new, num_clusters_phys);\n\n\t\t \n\t\tif (clu.flags == ALLOC_NO_FAT_CHAIN) {\n\t\t\tclu.dir += num_clusters;\n\t\t\tclu.size -= num_clusters;\n\t\t} else {\n\t\t\twhile (num_clusters > 0) {\n\t\t\t\tlast_clu = clu.dir;\n\t\t\t\tif (exfat_get_next_cluster(sb, &(clu.dir)))\n\t\t\t\t\treturn -EIO;\n\n\t\t\t\tnum_clusters--;\n\t\t\t\tclu.size--;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tei->flags = ALLOC_NO_FAT_CHAIN;\n\t\tei->start_clu = EXFAT_EOF_CLUSTER;\n\t}\n\n\tif (ei->type == TYPE_FILE)\n\t\tei->attr |= ATTR_ARCHIVE;\n\n\t \n\tif (__exfat_write_inode(inode, inode_needs_sync(inode)))\n\t\treturn -EIO;\n\n\t \n\tif (ei->flags == ALLOC_FAT_CHAIN && last_clu != EXFAT_FREE_CLUSTER &&\n\t\t\tlast_clu != EXFAT_EOF_CLUSTER) {\n\t\tif (exfat_ent_set(sb, last_clu, EXFAT_EOF_CLUSTER))\n\t\t\treturn -EIO;\n\t}\n\n\t \n\t \n\texfat_cache_inval_inode(inode);\n\n\t \n\tei->hint_bmap.off = EXFAT_EOF_CLUSTER;\n\tei->hint_bmap.clu = EXFAT_EOF_CLUSTER;\n\n\t \n\tei->hint_stat.eidx = 0;\n\tei->hint_stat.clu = ei->start_clu;\n\tei->hint_femp.eidx = EXFAT_HINT_NONE;\n\n\t \n\tif (exfat_free_cluster(inode, &clu))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nvoid exfat_truncate(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct exfat_sb_info *sbi = EXFAT_SB(sb);\n\tstruct exfat_inode_info *ei = EXFAT_I(inode);\n\tunsigned int blocksize = i_blocksize(inode);\n\tloff_t aligned_size;\n\tint err;\n\n\tmutex_lock(&sbi->s_lock);\n\tif (ei->start_clu == 0) {\n\t\t \n\t\texfat_fs_error(sb, \"tried to truncate zeroed cluster.\");\n\t\tgoto write_size;\n\t}\n\n\terr = __exfat_truncate(inode);\n\tif (err)\n\t\tgoto write_size;\n\n\tinode->i_blocks = round_up(i_size_read(inode), sbi->cluster_size) >> 9;\nwrite_size:\n\taligned_size = i_size_read(inode);\n\tif (aligned_size & (blocksize - 1)) {\n\t\taligned_size |= (blocksize - 1);\n\t\taligned_size++;\n\t}\n\n\tif (ei->i_size_ondisk > i_size_read(inode))\n\t\tei->i_size_ondisk = aligned_size;\n\n\tif (ei->i_size_aligned > i_size_read(inode))\n\t\tei->i_size_aligned = aligned_size;\n\tmutex_unlock(&sbi->s_lock);\n}\n\nint exfat_getattr(struct mnt_idmap *idmap, const struct path *path,\n\t\t  struct kstat *stat, unsigned int request_mask,\n\t\t  unsigned int query_flags)\n{\n\tstruct inode *inode = d_backing_inode(path->dentry);\n\tstruct exfat_inode_info *ei = EXFAT_I(inode);\n\n\tgeneric_fillattr(&nop_mnt_idmap, request_mask, inode, stat);\n\texfat_truncate_atime(&stat->atime);\n\tstat->result_mask |= STATX_BTIME;\n\tstat->btime.tv_sec = ei->i_crtime.tv_sec;\n\tstat->btime.tv_nsec = ei->i_crtime.tv_nsec;\n\tstat->blksize = EXFAT_SB(inode->i_sb)->cluster_size;\n\treturn 0;\n}\n\nint exfat_setattr(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\t  struct iattr *attr)\n{\n\tstruct exfat_sb_info *sbi = EXFAT_SB(dentry->d_sb);\n\tstruct inode *inode = dentry->d_inode;\n\tunsigned int ia_valid;\n\tint error;\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size > i_size_read(inode)) {\n\t\terror = exfat_cont_expand(inode, attr->ia_size);\n\t\tif (error || attr->ia_valid == ATTR_SIZE)\n\t\t\treturn error;\n\t\tattr->ia_valid &= ~ATTR_SIZE;\n\t}\n\n\t \n\tia_valid = attr->ia_valid;\n\tif ((ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) &&\n\t    exfat_allow_set_time(sbi, inode)) {\n\t\tattr->ia_valid &= ~(ATTR_MTIME_SET | ATTR_ATIME_SET |\n\t\t\t\tATTR_TIMES_SET);\n\t}\n\n\terror = setattr_prepare(&nop_mnt_idmap, dentry, attr);\n\tattr->ia_valid = ia_valid;\n\tif (error)\n\t\tgoto out;\n\n\tif (((attr->ia_valid & ATTR_UID) &&\n\t     !uid_eq(attr->ia_uid, sbi->options.fs_uid)) ||\n\t    ((attr->ia_valid & ATTR_GID) &&\n\t     !gid_eq(attr->ia_gid, sbi->options.fs_gid)) ||\n\t    ((attr->ia_valid & ATTR_MODE) &&\n\t     (attr->ia_mode & ~(S_IFREG | S_IFLNK | S_IFDIR | 0777)))) {\n\t\terror = -EPERM;\n\t\tgoto out;\n\t}\n\n\t \n\tif (attr->ia_valid & ATTR_MODE) {\n\t\tif (exfat_sanitize_mode(sbi, inode, &attr->ia_mode) < 0)\n\t\t\tattr->ia_valid &= ~ATTR_MODE;\n\t}\n\n\tif (attr->ia_valid & ATTR_SIZE)\n\t\tinode->i_mtime = inode_set_ctime_current(inode);\n\n\tsetattr_copy(&nop_mnt_idmap, inode, attr);\n\texfat_truncate_atime(&inode->i_atime);\n\n\tif (attr->ia_valid & ATTR_SIZE) {\n\t\terror = exfat_block_truncate_page(inode, attr->ia_size);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\tdown_write(&EXFAT_I(inode)->truncate_lock);\n\t\ttruncate_setsize(inode, attr->ia_size);\n\n\t\t \n\t\texfat_truncate(inode);\n\t\tup_write(&EXFAT_I(inode)->truncate_lock);\n\t} else\n\t\tmark_inode_dirty(inode);\n\nout:\n\treturn error;\n}\n\nstatic int exfat_ioctl_fitrim(struct inode *inode, unsigned long arg)\n{\n\tstruct fstrim_range range;\n\tint ret = 0;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!bdev_max_discard_sectors(inode->i_sb->s_bdev))\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&range, (struct fstrim_range __user *)arg, sizeof(range)))\n\t\treturn -EFAULT;\n\n\trange.minlen = max_t(unsigned int, range.minlen,\n\t\t\t\tbdev_discard_granularity(inode->i_sb->s_bdev));\n\n\tret = exfat_trim_fs(inode, &range);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (copy_to_user((struct fstrim_range __user *)arg, &range, sizeof(range)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nlong exfat_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\n\tswitch (cmd) {\n\tcase FITRIM:\n\t\treturn exfat_ioctl_fitrim(inode, arg);\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}\n\n#ifdef CONFIG_COMPAT\nlong exfat_compat_ioctl(struct file *filp, unsigned int cmd,\n\t\t\t\tunsigned long arg)\n{\n\treturn exfat_ioctl(filp, cmd, (unsigned long)compat_ptr(arg));\n}\n#endif\n\nint exfat_file_fsync(struct file *filp, loff_t start, loff_t end, int datasync)\n{\n\tstruct inode *inode = filp->f_mapping->host;\n\tint err;\n\n\terr = __generic_file_fsync(filp, start, end, datasync);\n\tif (err)\n\t\treturn err;\n\n\terr = sync_blockdev(inode->i_sb->s_bdev);\n\tif (err)\n\t\treturn err;\n\n\treturn blkdev_issue_flush(inode->i_sb->s_bdev);\n}\n\nconst struct file_operations exfat_file_operations = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read_iter\t= generic_file_read_iter,\n\t.write_iter\t= generic_file_write_iter,\n\t.unlocked_ioctl = exfat_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl = exfat_compat_ioctl,\n#endif\n\t.mmap\t\t= generic_file_mmap,\n\t.fsync\t\t= exfat_file_fsync,\n\t.splice_read\t= filemap_splice_read,\n\t.splice_write\t= iter_file_splice_write,\n};\n\nconst struct inode_operations exfat_file_inode_operations = {\n\t.setattr     = exfat_setattr,\n\t.getattr     = exfat_getattr,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}