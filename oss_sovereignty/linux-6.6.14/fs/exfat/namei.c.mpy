{
  "module_name": "namei.c",
  "hash_id": "f9b1b31412354ad44b36b9b109969de59cb6418fb9268a6227ab1fd655facf9e",
  "original_prompt": "Ingested from linux-6.6.14/fs/exfat/namei.c",
  "human_readable_source": "\n \n\n#include <linux/iversion.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n\n#include \"exfat_raw.h\"\n#include \"exfat_fs.h\"\n\nstatic inline unsigned long exfat_d_version(struct dentry *dentry)\n{\n\treturn (unsigned long) dentry->d_fsdata;\n}\n\nstatic inline void exfat_d_version_set(struct dentry *dentry,\n\t\tunsigned long version)\n{\n\tdentry->d_fsdata = (void *) version;\n}\n\n \nstatic int exfat_d_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tint ret;\n\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\t \n\tif (d_really_is_positive(dentry))\n\t\treturn 1;\n\n\t \n\tif (flags & (LOOKUP_CREATE | LOOKUP_RENAME_TARGET))\n\t\treturn 0;\n\n\tspin_lock(&dentry->d_lock);\n\tret = inode_eq_iversion(d_inode(dentry->d_parent),\n\t\t\texfat_d_version(dentry));\n\tspin_unlock(&dentry->d_lock);\n\treturn ret;\n}\n\n \nstatic unsigned int exfat_striptail_len(unsigned int len, const char *name,\n\t\t\t\t\tbool keep_last_dots)\n{\n\tif (!keep_last_dots) {\n\t\twhile (len && name[len - 1] == '.')\n\t\t\tlen--;\n\t}\n\treturn len;\n}\n\n \nstatic int exfat_d_hash(const struct dentry *dentry, struct qstr *qstr)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct nls_table *t = EXFAT_SB(sb)->nls_io;\n\tconst unsigned char *name = qstr->name;\n\tunsigned int len = exfat_striptail_len(qstr->len, qstr->name,\n\t\t\t   EXFAT_SB(sb)->options.keep_last_dots);\n\tunsigned long hash = init_name_hash(dentry);\n\tint i, charlen;\n\twchar_t c;\n\n\tfor (i = 0; i < len; i += charlen) {\n\t\tcharlen = t->char2uni(&name[i], len - i, &c);\n\t\tif (charlen < 0)\n\t\t\treturn charlen;\n\t\thash = partial_name_hash(exfat_toupper(sb, c), hash);\n\t}\n\n\tqstr->hash = end_name_hash(hash);\n\treturn 0;\n}\n\nstatic int exfat_d_cmp(const struct dentry *dentry, unsigned int len,\n\t\tconst char *str, const struct qstr *name)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct nls_table *t = EXFAT_SB(sb)->nls_io;\n\tunsigned int alen = exfat_striptail_len(name->len, name->name,\n\t\t\t\tEXFAT_SB(sb)->options.keep_last_dots);\n\tunsigned int blen = exfat_striptail_len(len, str,\n\t\t\t\tEXFAT_SB(sb)->options.keep_last_dots);\n\twchar_t c1, c2;\n\tint charlen, i;\n\n\tif (alen != blen)\n\t\treturn 1;\n\n\tfor (i = 0; i < len; i += charlen) {\n\t\tcharlen = t->char2uni(&name->name[i], alen - i, &c1);\n\t\tif (charlen < 0)\n\t\t\treturn 1;\n\t\tif (charlen != t->char2uni(&str[i], blen - i, &c2))\n\t\t\treturn 1;\n\n\t\tif (exfat_toupper(sb, c1) != exfat_toupper(sb, c2))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nconst struct dentry_operations exfat_dentry_ops = {\n\t.d_revalidate\t= exfat_d_revalidate,\n\t.d_hash\t\t= exfat_d_hash,\n\t.d_compare\t= exfat_d_cmp,\n};\n\nstatic int exfat_utf8_d_hash(const struct dentry *dentry, struct qstr *qstr)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tconst unsigned char *name = qstr->name;\n\tunsigned int len = exfat_striptail_len(qstr->len, qstr->name,\n\t\t\t       EXFAT_SB(sb)->options.keep_last_dots);\n\tunsigned long hash = init_name_hash(dentry);\n\tint i, charlen;\n\tunicode_t u;\n\n\tfor (i = 0; i < len; i += charlen) {\n\t\tcharlen = utf8_to_utf32(&name[i], len - i, &u);\n\t\tif (charlen < 0)\n\t\t\treturn charlen;\n\n\t\t \n\t\thash = partial_name_hash(u <= 0xFFFF ? exfat_toupper(sb, u) : u,\n\t\t\t\t\t hash);\n\t}\n\n\tqstr->hash = end_name_hash(hash);\n\treturn 0;\n}\n\nstatic int exfat_utf8_d_cmp(const struct dentry *dentry, unsigned int len,\n\t\tconst char *str, const struct qstr *name)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tunsigned int alen = exfat_striptail_len(name->len, name->name,\n\t\t\t\tEXFAT_SB(sb)->options.keep_last_dots);\n\tunsigned int blen = exfat_striptail_len(len, str,\n\t\t\t\tEXFAT_SB(sb)->options.keep_last_dots);\n\n\tunicode_t u_a, u_b;\n\tint charlen, i;\n\n\tif (alen != blen)\n\t\treturn 1;\n\n\tfor (i = 0; i < alen; i += charlen) {\n\t\tcharlen = utf8_to_utf32(&name->name[i], alen - i, &u_a);\n\t\tif (charlen < 0)\n\t\t\treturn 1;\n\t\tif (charlen != utf8_to_utf32(&str[i], blen - i, &u_b))\n\t\t\treturn 1;\n\n\t\tif (u_a <= 0xFFFF && u_b <= 0xFFFF) {\n\t\t\tif (exfat_toupper(sb, u_a) != exfat_toupper(sb, u_b))\n\t\t\t\treturn 1;\n\t\t} else {\n\t\t\tif (u_a != u_b)\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nconst struct dentry_operations exfat_utf8_dentry_ops = {\n\t.d_revalidate\t= exfat_d_revalidate,\n\t.d_hash\t\t= exfat_utf8_d_hash,\n\t.d_compare\t= exfat_utf8_d_cmp,\n};\n\n \n#define CNT_UNUSED_NOHIT        (-1)\n#define CNT_UNUSED_HIT          (-2)\n \nstatic int exfat_search_empty_slot(struct super_block *sb,\n\t\tstruct exfat_hint_femp *hint_femp, struct exfat_chain *p_dir,\n\t\tint num_entries)\n{\n\tint i, dentry, num_empty = 0;\n\tint dentries_per_clu;\n\tunsigned int type;\n\tstruct exfat_chain clu;\n\tstruct exfat_dentry *ep;\n\tstruct exfat_sb_info *sbi = EXFAT_SB(sb);\n\tstruct buffer_head *bh;\n\n\tdentries_per_clu = sbi->dentries_per_clu;\n\n\tif (hint_femp->eidx != EXFAT_HINT_NONE) {\n\t\tdentry = hint_femp->eidx;\n\n\t\t \n\t\tif (dentry + hint_femp->count == p_dir->size * dentries_per_clu &&\n\t\t    num_entries > hint_femp->count)\n\t\t\treturn -ENOSPC;\n\n\t\thint_femp->eidx = EXFAT_HINT_NONE;\n\t\texfat_chain_dup(&clu, &hint_femp->cur);\n\t} else {\n\t\texfat_chain_dup(&clu, p_dir);\n\t\tdentry = 0;\n\t}\n\n\twhile (clu.dir != EXFAT_EOF_CLUSTER) {\n\t\ti = dentry & (dentries_per_clu - 1);\n\n\t\tfor (; i < dentries_per_clu; i++, dentry++) {\n\t\t\tep = exfat_get_dentry(sb, &clu, i, &bh);\n\t\t\tif (!ep)\n\t\t\t\treturn -EIO;\n\t\t\ttype = exfat_get_entry_type(ep);\n\t\t\tbrelse(bh);\n\n\t\t\tif (type == TYPE_UNUSED || type == TYPE_DELETED) {\n\t\t\t\tnum_empty++;\n\t\t\t\tif (hint_femp->eidx == EXFAT_HINT_NONE) {\n\t\t\t\t\thint_femp->eidx = dentry;\n\t\t\t\t\thint_femp->count = CNT_UNUSED_NOHIT;\n\t\t\t\t\texfat_chain_set(&hint_femp->cur,\n\t\t\t\t\t\tclu.dir, clu.size, clu.flags);\n\t\t\t\t}\n\n\t\t\t\tif (type == TYPE_UNUSED &&\n\t\t\t\t    hint_femp->count != CNT_UNUSED_HIT)\n\t\t\t\t\thint_femp->count = CNT_UNUSED_HIT;\n\t\t\t} else {\n\t\t\t\tif (hint_femp->eidx != EXFAT_HINT_NONE &&\n\t\t\t\t    hint_femp->count == CNT_UNUSED_HIT) {\n\t\t\t\t\t \n\t\t\t\t\texfat_fs_error(sb,\n\t\t\t\t\t\t\"found bogus dentry(%d) beyond unused empty group(%d) (start_clu : %u, cur_clu : %u)\",\n\t\t\t\t\t\tdentry, hint_femp->eidx,\n\t\t\t\t\t\tp_dir->dir, clu.dir);\n\t\t\t\t\treturn -EIO;\n\t\t\t\t}\n\n\t\t\t\tnum_empty = 0;\n\t\t\t\thint_femp->eidx = EXFAT_HINT_NONE;\n\t\t\t}\n\n\t\t\tif (num_empty >= num_entries) {\n\t\t\t\t \n\t\t\t\thint_femp->eidx = EXFAT_HINT_NONE;\n\t\t\t\treturn (dentry - (num_entries - 1));\n\t\t\t}\n\t\t}\n\n\t\tif (clu.flags == ALLOC_NO_FAT_CHAIN) {\n\t\t\tif (--clu.size > 0)\n\t\t\t\tclu.dir++;\n\t\t\telse\n\t\t\t\tclu.dir = EXFAT_EOF_CLUSTER;\n\t\t} else {\n\t\t\tif (exfat_get_next_cluster(sb, &clu.dir))\n\t\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\thint_femp->eidx = p_dir->size * dentries_per_clu - num_empty;\n\thint_femp->count = num_empty;\n\tif (num_empty == 0)\n\t\texfat_chain_set(&hint_femp->cur, EXFAT_EOF_CLUSTER, 0,\n\t\t\t\tclu.flags);\n\n\treturn -ENOSPC;\n}\n\nstatic int exfat_check_max_dentries(struct inode *inode)\n{\n\tif (EXFAT_B_TO_DEN(i_size_read(inode)) >= MAX_EXFAT_DENTRIES) {\n\t\t \n\t\treturn -ENOSPC;\n\t}\n\treturn 0;\n}\n\n \nstatic int exfat_find_empty_entry(struct inode *inode,\n\t\tstruct exfat_chain *p_dir, int num_entries)\n{\n\tint dentry;\n\tunsigned int ret, last_clu;\n\tloff_t size = 0;\n\tstruct exfat_chain clu;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct exfat_sb_info *sbi = EXFAT_SB(sb);\n\tstruct exfat_inode_info *ei = EXFAT_I(inode);\n\tstruct exfat_hint_femp hint_femp;\n\n\thint_femp.eidx = EXFAT_HINT_NONE;\n\n\tif (ei->hint_femp.eidx != EXFAT_HINT_NONE) {\n\t\thint_femp = ei->hint_femp;\n\t\tei->hint_femp.eidx = EXFAT_HINT_NONE;\n\t}\n\n\twhile ((dentry = exfat_search_empty_slot(sb, &hint_femp, p_dir,\n\t\t\t\t\tnum_entries)) < 0) {\n\t\tif (dentry == -EIO)\n\t\t\tbreak;\n\n\t\tif (exfat_check_max_dentries(inode))\n\t\t\treturn -ENOSPC;\n\n\t\t \n\t\tif (ei->start_clu != EXFAT_EOF_CLUSTER) {\n\t\t\t \n\t\t\tif (exfat_find_last_cluster(sb, p_dir, &last_clu))\n\t\t\t\treturn -EIO;\n\n\t\t\texfat_chain_set(&clu, last_clu + 1, 0, p_dir->flags);\n\t\t} else {\n\t\t\t \n\t\t\texfat_chain_set(&clu, EXFAT_EOF_CLUSTER, 0,\n\t\t\t\t\tALLOC_NO_FAT_CHAIN);\n\t\t}\n\n\t\t \n\t\tret = exfat_alloc_cluster(inode, 1, &clu, IS_DIRSYNC(inode));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (exfat_zeroed_cluster(inode, clu.dir))\n\t\t\treturn -EIO;\n\n\t\tif (ei->start_clu == EXFAT_EOF_CLUSTER) {\n\t\t\tei->start_clu = clu.dir;\n\t\t\tp_dir->dir = clu.dir;\n\t\t}\n\n\t\t \n\t\tif (clu.flags != p_dir->flags) {\n\t\t\t \n\t\t\texfat_chain_cont_cluster(sb, p_dir->dir, p_dir->size);\n\t\t\tp_dir->flags = ALLOC_FAT_CHAIN;\n\t\t\thint_femp.cur.flags = ALLOC_FAT_CHAIN;\n\t\t}\n\n\t\tif (clu.flags == ALLOC_FAT_CHAIN)\n\t\t\tif (exfat_ent_set(sb, last_clu, clu.dir))\n\t\t\t\treturn -EIO;\n\n\t\tif (hint_femp.cur.dir == EXFAT_EOF_CLUSTER)\n\t\t\texfat_chain_set(&hint_femp.cur, clu.dir, 0, clu.flags);\n\n\t\thint_femp.count += sbi->dentries_per_clu;\n\n\t\thint_femp.cur.size++;\n\t\tp_dir->size++;\n\t\tsize = EXFAT_CLU_TO_B(p_dir->size, sbi);\n\n\t\t \n\t\ti_size_write(inode, size);\n\t\tei->i_size_ondisk += sbi->cluster_size;\n\t\tei->i_size_aligned += sbi->cluster_size;\n\t\tei->flags = p_dir->flags;\n\t\tinode->i_blocks += sbi->cluster_size >> 9;\n\t}\n\n\treturn dentry;\n}\n\n \nstatic int __exfat_resolve_path(struct inode *inode, const unsigned char *path,\n\t\tstruct exfat_chain *p_dir, struct exfat_uni_name *p_uniname,\n\t\tint lookup)\n{\n\tint namelen;\n\tint lossy = NLS_NAME_NO_LOSSY;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct exfat_sb_info *sbi = EXFAT_SB(sb);\n\tstruct exfat_inode_info *ei = EXFAT_I(inode);\n\tint pathlen = strlen(path);\n\n\t \n\tnamelen = exfat_striptail_len(pathlen, path, false);\n\tif (EXFAT_SB(sb)->options.keep_last_dots) {\n\t\t \n\t\tif (!lookup && (namelen < pathlen))\n\t\t\treturn -EINVAL;\n\t\tnamelen = pathlen;\n\t}\n\tif (!namelen)\n\t\treturn -ENOENT;\n\tif (pathlen > (MAX_NAME_LENGTH * MAX_CHARSET_SIZE))\n\t\treturn -ENAMETOOLONG;\n\n\t \n\n\t \n\tnamelen = exfat_nls_to_utf16(sb, path, namelen, p_uniname,\n\t\t\t&lossy);\n\tif (namelen < 0)\n\t\treturn namelen;  \n\n\tif ((lossy && !lookup) || !namelen)\n\t\treturn (lossy & NLS_NAME_OVERLEN) ? -ENAMETOOLONG : -EINVAL;\n\n\texfat_chain_set(p_dir, ei->start_clu,\n\t\tEXFAT_B_TO_CLU(i_size_read(inode), sbi), ei->flags);\n\n\treturn 0;\n}\n\nstatic inline int exfat_resolve_path(struct inode *inode,\n\t\tconst unsigned char *path, struct exfat_chain *dir,\n\t\tstruct exfat_uni_name *uni)\n{\n\treturn __exfat_resolve_path(inode, path, dir, uni, 0);\n}\n\nstatic inline int exfat_resolve_path_for_lookup(struct inode *inode,\n\t\tconst unsigned char *path, struct exfat_chain *dir,\n\t\tstruct exfat_uni_name *uni)\n{\n\treturn __exfat_resolve_path(inode, path, dir, uni, 1);\n}\n\nstatic inline loff_t exfat_make_i_pos(struct exfat_dir_entry *info)\n{\n\treturn ((loff_t) info->dir.dir << 32) | (info->entry & 0xffffffff);\n}\n\nstatic int exfat_add_entry(struct inode *inode, const char *path,\n\t\tstruct exfat_chain *p_dir, unsigned int type,\n\t\tstruct exfat_dir_entry *info)\n{\n\tint ret, dentry, num_entries;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct exfat_sb_info *sbi = EXFAT_SB(sb);\n\tstruct exfat_uni_name uniname;\n\tstruct exfat_chain clu;\n\tint clu_size = 0;\n\tunsigned int start_clu = EXFAT_FREE_CLUSTER;\n\n\tret = exfat_resolve_path(inode, path, p_dir, &uniname);\n\tif (ret)\n\t\tgoto out;\n\n\tnum_entries = exfat_calc_num_entries(&uniname);\n\tif (num_entries < 0) {\n\t\tret = num_entries;\n\t\tgoto out;\n\t}\n\n\t \n\tdentry = exfat_find_empty_entry(inode, p_dir, num_entries);\n\tif (dentry < 0) {\n\t\tret = dentry;  \n\t\tgoto out;\n\t}\n\n\tif (type == TYPE_DIR) {\n\t\tret = exfat_alloc_new_dir(inode, &clu);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tstart_clu = clu.dir;\n\t\tclu_size = sbi->cluster_size;\n\t}\n\n\t \n\t \n\tret = exfat_init_dir_entry(inode, p_dir, dentry, type,\n\t\tstart_clu, clu_size);\n\tif (ret)\n\t\tgoto out;\n\n\tret = exfat_init_ext_entry(inode, p_dir, dentry, num_entries, &uniname);\n\tif (ret)\n\t\tgoto out;\n\n\tinfo->dir = *p_dir;\n\tinfo->entry = dentry;\n\tinfo->flags = ALLOC_NO_FAT_CHAIN;\n\tinfo->type = type;\n\n\tif (type == TYPE_FILE) {\n\t\tinfo->attr = ATTR_ARCHIVE;\n\t\tinfo->start_clu = EXFAT_EOF_CLUSTER;\n\t\tinfo->size = 0;\n\t\tinfo->num_subdirs = 0;\n\t} else {\n\t\tinfo->attr = ATTR_SUBDIR;\n\t\tinfo->start_clu = start_clu;\n\t\tinfo->size = clu_size;\n\t\tinfo->num_subdirs = EXFAT_MIN_SUBDIR;\n\t}\n\tmemset(&info->crtime, 0, sizeof(info->crtime));\n\tmemset(&info->mtime, 0, sizeof(info->mtime));\n\tmemset(&info->atime, 0, sizeof(info->atime));\nout:\n\treturn ret;\n}\n\nstatic int exfat_create(struct mnt_idmap *idmap, struct inode *dir,\n\t\t\tstruct dentry *dentry, umode_t mode, bool excl)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct inode *inode;\n\tstruct exfat_chain cdir;\n\tstruct exfat_dir_entry info;\n\tloff_t i_pos;\n\tint err;\n\n\tmutex_lock(&EXFAT_SB(sb)->s_lock);\n\texfat_set_volume_dirty(sb);\n\terr = exfat_add_entry(dir, dentry->d_name.name, &cdir, TYPE_FILE,\n\t\t&info);\n\tif (err)\n\t\tgoto unlock;\n\n\tinode_inc_iversion(dir);\n\tdir->i_mtime = inode_set_ctime_current(dir);\n\tif (IS_DIRSYNC(dir))\n\t\texfat_sync_inode(dir);\n\telse\n\t\tmark_inode_dirty(dir);\n\n\ti_pos = exfat_make_i_pos(&info);\n\tinode = exfat_build_inode(sb, &info, i_pos);\n\terr = PTR_ERR_OR_ZERO(inode);\n\tif (err)\n\t\tgoto unlock;\n\n\tinode_inc_iversion(inode);\n\tinode->i_mtime = inode->i_atime = EXFAT_I(inode)->i_crtime = inode_set_ctime_current(inode);\n\texfat_truncate_atime(&inode->i_atime);\n\t \n\n\td_instantiate(dentry, inode);\nunlock:\n\tmutex_unlock(&EXFAT_SB(sb)->s_lock);\n\treturn err;\n}\n\n \nstatic int exfat_find(struct inode *dir, struct qstr *qname,\n\t\tstruct exfat_dir_entry *info)\n{\n\tint ret, dentry, count;\n\tstruct exfat_chain cdir;\n\tstruct exfat_uni_name uni_name;\n\tstruct super_block *sb = dir->i_sb;\n\tstruct exfat_sb_info *sbi = EXFAT_SB(sb);\n\tstruct exfat_inode_info *ei = EXFAT_I(dir);\n\tstruct exfat_dentry *ep, *ep2;\n\tstruct exfat_entry_set_cache es;\n\t \n\tstruct exfat_hint hint_opt;\n\n\tif (qname->len == 0)\n\t\treturn -ENOENT;\n\n\t \n\tret = exfat_resolve_path_for_lookup(dir, qname->name, &cdir, &uni_name);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (ei->version != (inode_peek_iversion_raw(dir) & 0xffffffff)) {\n\t\tei->hint_stat.clu = cdir.dir;\n\t\tei->hint_stat.eidx = 0;\n\t\tei->version = (inode_peek_iversion_raw(dir) & 0xffffffff);\n\t\tei->hint_femp.eidx = EXFAT_HINT_NONE;\n\t}\n\n\t \n\tdentry = exfat_find_dir_entry(sb, ei, &cdir, &uni_name, &hint_opt);\n\tif (dentry < 0)\n\t\treturn dentry;  \n\n\tinfo->dir = cdir;\n\tinfo->entry = dentry;\n\tinfo->num_subdirs = 0;\n\n\t \n\tcdir.dir = hint_opt.clu;\n\tif (cdir.flags & ALLOC_NO_FAT_CHAIN)\n\t\tcdir.size -= dentry / sbi->dentries_per_clu;\n\tdentry = hint_opt.eidx;\n\tif (exfat_get_dentry_set(&es, sb, &cdir, dentry, ES_2_ENTRIES))\n\t\treturn -EIO;\n\tep = exfat_get_dentry_cached(&es, ES_IDX_FILE);\n\tep2 = exfat_get_dentry_cached(&es, ES_IDX_STREAM);\n\n\tinfo->type = exfat_get_entry_type(ep);\n\tinfo->attr = le16_to_cpu(ep->dentry.file.attr);\n\tinfo->size = le64_to_cpu(ep2->dentry.stream.valid_size);\n\tif (info->size == 0) {\n\t\tinfo->flags = ALLOC_NO_FAT_CHAIN;\n\t\tinfo->start_clu = EXFAT_EOF_CLUSTER;\n\t} else {\n\t\tinfo->flags = ep2->dentry.stream.flags;\n\t\tinfo->start_clu =\n\t\t\tle32_to_cpu(ep2->dentry.stream.start_clu);\n\t}\n\n\texfat_get_entry_time(sbi, &info->crtime,\n\t\t\t     ep->dentry.file.create_tz,\n\t\t\t     ep->dentry.file.create_time,\n\t\t\t     ep->dentry.file.create_date,\n\t\t\t     ep->dentry.file.create_time_cs);\n\texfat_get_entry_time(sbi, &info->mtime,\n\t\t\t     ep->dentry.file.modify_tz,\n\t\t\t     ep->dentry.file.modify_time,\n\t\t\t     ep->dentry.file.modify_date,\n\t\t\t     ep->dentry.file.modify_time_cs);\n\texfat_get_entry_time(sbi, &info->atime,\n\t\t\t     ep->dentry.file.access_tz,\n\t\t\t     ep->dentry.file.access_time,\n\t\t\t     ep->dentry.file.access_date,\n\t\t\t     0);\n\texfat_put_dentry_set(&es, false);\n\n\tif (ei->start_clu == EXFAT_FREE_CLUSTER) {\n\t\texfat_fs_error(sb,\n\t\t\t       \"non-zero size file starts with zero cluster (size : %llu, p_dir : %u, entry : 0x%08x)\",\n\t\t\t       i_size_read(dir), ei->dir.dir, ei->entry);\n\t\treturn -EIO;\n\t}\n\n\tif (info->type == TYPE_DIR) {\n\t\texfat_chain_set(&cdir, info->start_clu,\n\t\t\t\tEXFAT_B_TO_CLU(info->size, sbi), info->flags);\n\t\tcount = exfat_count_dir_entries(sb, &cdir);\n\t\tif (count < 0)\n\t\t\treturn -EIO;\n\n\t\tinfo->num_subdirs = count + EXFAT_MIN_SUBDIR;\n\t}\n\treturn 0;\n}\n\nstatic int exfat_d_anon_disconn(struct dentry *dentry)\n{\n\treturn IS_ROOT(dentry) && (dentry->d_flags & DCACHE_DISCONNECTED);\n}\n\nstatic struct dentry *exfat_lookup(struct inode *dir, struct dentry *dentry,\n\t\tunsigned int flags)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct inode *inode;\n\tstruct dentry *alias;\n\tstruct exfat_dir_entry info;\n\tint err;\n\tloff_t i_pos;\n\tmode_t i_mode;\n\n\tmutex_lock(&EXFAT_SB(sb)->s_lock);\n\terr = exfat_find(dir, &dentry->d_name, &info);\n\tif (err) {\n\t\tif (err == -ENOENT) {\n\t\t\tinode = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tgoto unlock;\n\t}\n\n\ti_pos = exfat_make_i_pos(&info);\n\tinode = exfat_build_inode(sb, &info, i_pos);\n\terr = PTR_ERR_OR_ZERO(inode);\n\tif (err)\n\t\tgoto unlock;\n\n\ti_mode = inode->i_mode;\n\talias = d_find_alias(inode);\n\n\t \n\tif (alias && alias->d_parent == dentry->d_parent &&\n\t\t\t!exfat_d_anon_disconn(alias)) {\n\n\t\t \n\t\tif (d_unhashed(alias)) {\n\t\t\tWARN_ON(alias->d_name.hash_len !=\n\t\t\t\tdentry->d_name.hash_len);\n\t\t\texfat_info(sb, \"rehashed a dentry(%p) in read lookup\",\n\t\t\t\t   alias);\n\t\t\td_drop(dentry);\n\t\t\td_rehash(alias);\n\t\t} else if (!S_ISDIR(i_mode)) {\n\t\t\t \n\t\t\td_move(alias, dentry);\n\t\t}\n\t\tiput(inode);\n\t\tmutex_unlock(&EXFAT_SB(sb)->s_lock);\n\t\treturn alias;\n\t}\n\tdput(alias);\nout:\n\tmutex_unlock(&EXFAT_SB(sb)->s_lock);\n\tif (!inode)\n\t\texfat_d_version_set(dentry, inode_query_iversion(dir));\n\n\treturn d_splice_alias(inode, dentry);\nunlock:\n\tmutex_unlock(&EXFAT_SB(sb)->s_lock);\n\treturn ERR_PTR(err);\n}\n\n \nstatic int exfat_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct exfat_chain cdir;\n\tstruct exfat_dentry *ep;\n\tstruct super_block *sb = dir->i_sb;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct exfat_inode_info *ei = EXFAT_I(inode);\n\tstruct buffer_head *bh;\n\tint num_entries, entry, err = 0;\n\n\tmutex_lock(&EXFAT_SB(sb)->s_lock);\n\texfat_chain_dup(&cdir, &ei->dir);\n\tentry = ei->entry;\n\tif (ei->dir.dir == DIR_DELETED) {\n\t\texfat_err(sb, \"abnormal access to deleted dentry\");\n\t\terr = -ENOENT;\n\t\tgoto unlock;\n\t}\n\n\tep = exfat_get_dentry(sb, &cdir, entry, &bh);\n\tif (!ep) {\n\t\terr = -EIO;\n\t\tgoto unlock;\n\t}\n\tnum_entries = exfat_count_ext_entries(sb, &cdir, entry, ep);\n\tif (num_entries < 0) {\n\t\terr = -EIO;\n\t\tbrelse(bh);\n\t\tgoto unlock;\n\t}\n\tnum_entries++;\n\tbrelse(bh);\n\n\texfat_set_volume_dirty(sb);\n\t \n\tif (exfat_remove_entries(dir, &cdir, entry, 0, num_entries)) {\n\t\terr = -EIO;\n\t\tgoto unlock;\n\t}\n\n\t \n\tei->dir.dir = DIR_DELETED;\n\n\tinode_inc_iversion(dir);\n\tdir->i_mtime = dir->i_atime = inode_set_ctime_current(dir);\n\texfat_truncate_atime(&dir->i_atime);\n\tif (IS_DIRSYNC(dir))\n\t\texfat_sync_inode(dir);\n\telse\n\t\tmark_inode_dirty(dir);\n\n\tclear_nlink(inode);\n\tinode->i_mtime = inode->i_atime = inode_set_ctime_current(inode);\n\texfat_truncate_atime(&inode->i_atime);\n\texfat_unhash_inode(inode);\n\texfat_d_version_set(dentry, inode_query_iversion(dir));\nunlock:\n\tmutex_unlock(&EXFAT_SB(sb)->s_lock);\n\treturn err;\n}\n\nstatic int exfat_mkdir(struct mnt_idmap *idmap, struct inode *dir,\n\t\t       struct dentry *dentry, umode_t mode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct inode *inode;\n\tstruct exfat_dir_entry info;\n\tstruct exfat_chain cdir;\n\tloff_t i_pos;\n\tint err;\n\n\tmutex_lock(&EXFAT_SB(sb)->s_lock);\n\texfat_set_volume_dirty(sb);\n\terr = exfat_add_entry(dir, dentry->d_name.name, &cdir, TYPE_DIR,\n\t\t&info);\n\tif (err)\n\t\tgoto unlock;\n\n\tinode_inc_iversion(dir);\n\tdir->i_mtime = inode_set_ctime_current(dir);\n\tif (IS_DIRSYNC(dir))\n\t\texfat_sync_inode(dir);\n\telse\n\t\tmark_inode_dirty(dir);\n\tinc_nlink(dir);\n\n\ti_pos = exfat_make_i_pos(&info);\n\tinode = exfat_build_inode(sb, &info, i_pos);\n\terr = PTR_ERR_OR_ZERO(inode);\n\tif (err)\n\t\tgoto unlock;\n\n\tinode_inc_iversion(inode);\n\tinode->i_mtime = inode->i_atime = EXFAT_I(inode)->i_crtime = inode_set_ctime_current(inode);\n\texfat_truncate_atime(&inode->i_atime);\n\t \n\n\td_instantiate(dentry, inode);\n\nunlock:\n\tmutex_unlock(&EXFAT_SB(sb)->s_lock);\n\treturn err;\n}\n\nstatic int exfat_check_dir_empty(struct super_block *sb,\n\t\tstruct exfat_chain *p_dir)\n{\n\tint i, dentries_per_clu;\n\tunsigned int type;\n\tstruct exfat_chain clu;\n\tstruct exfat_dentry *ep;\n\tstruct exfat_sb_info *sbi = EXFAT_SB(sb);\n\tstruct buffer_head *bh;\n\n\tdentries_per_clu = sbi->dentries_per_clu;\n\n\tif (p_dir->dir == EXFAT_EOF_CLUSTER)\n\t\treturn 0;\n\n\texfat_chain_dup(&clu, p_dir);\n\n\twhile (clu.dir != EXFAT_EOF_CLUSTER) {\n\t\tfor (i = 0; i < dentries_per_clu; i++) {\n\t\t\tep = exfat_get_dentry(sb, &clu, i, &bh);\n\t\t\tif (!ep)\n\t\t\t\treturn -EIO;\n\t\t\ttype = exfat_get_entry_type(ep);\n\t\t\tbrelse(bh);\n\t\t\tif (type == TYPE_UNUSED)\n\t\t\t\treturn 0;\n\n\t\t\tif (type != TYPE_FILE && type != TYPE_DIR)\n\t\t\t\tcontinue;\n\n\t\t\treturn -ENOTEMPTY;\n\t\t}\n\n\t\tif (clu.flags == ALLOC_NO_FAT_CHAIN) {\n\t\t\tif (--clu.size > 0)\n\t\t\t\tclu.dir++;\n\t\t\telse\n\t\t\t\tclu.dir = EXFAT_EOF_CLUSTER;\n\t\t} else {\n\t\t\tif (exfat_get_next_cluster(sb, &(clu.dir)))\n\t\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int exfat_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct exfat_dentry *ep;\n\tstruct exfat_chain cdir, clu_to_free;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct exfat_sb_info *sbi = EXFAT_SB(sb);\n\tstruct exfat_inode_info *ei = EXFAT_I(inode);\n\tstruct buffer_head *bh;\n\tint num_entries, entry, err;\n\n\tmutex_lock(&EXFAT_SB(inode->i_sb)->s_lock);\n\n\texfat_chain_dup(&cdir, &ei->dir);\n\tentry = ei->entry;\n\n\tif (ei->dir.dir == DIR_DELETED) {\n\t\texfat_err(sb, \"abnormal access to deleted dentry\");\n\t\terr = -ENOENT;\n\t\tgoto unlock;\n\t}\n\n\texfat_chain_set(&clu_to_free, ei->start_clu,\n\t\tEXFAT_B_TO_CLU_ROUND_UP(i_size_read(inode), sbi), ei->flags);\n\n\terr = exfat_check_dir_empty(sb, &clu_to_free);\n\tif (err) {\n\t\tif (err == -EIO)\n\t\t\texfat_err(sb, \"failed to exfat_check_dir_empty : err(%d)\",\n\t\t\t\t  err);\n\t\tgoto unlock;\n\t}\n\n\tep = exfat_get_dentry(sb, &cdir, entry, &bh);\n\tif (!ep) {\n\t\terr = -EIO;\n\t\tgoto unlock;\n\t}\n\n\tnum_entries = exfat_count_ext_entries(sb, &cdir, entry, ep);\n\tif (num_entries < 0) {\n\t\terr = -EIO;\n\t\tbrelse(bh);\n\t\tgoto unlock;\n\t}\n\tnum_entries++;\n\tbrelse(bh);\n\n\texfat_set_volume_dirty(sb);\n\terr = exfat_remove_entries(dir, &cdir, entry, 0, num_entries);\n\tif (err) {\n\t\texfat_err(sb, \"failed to exfat_remove_entries : err(%d)\", err);\n\t\tgoto unlock;\n\t}\n\tei->dir.dir = DIR_DELETED;\n\n\tinode_inc_iversion(dir);\n\tdir->i_mtime = dir->i_atime = inode_set_ctime_current(dir);\n\texfat_truncate_atime(&dir->i_atime);\n\tif (IS_DIRSYNC(dir))\n\t\texfat_sync_inode(dir);\n\telse\n\t\tmark_inode_dirty(dir);\n\tdrop_nlink(dir);\n\n\tclear_nlink(inode);\n\tinode->i_mtime = inode->i_atime = inode_set_ctime_current(inode);\n\texfat_truncate_atime(&inode->i_atime);\n\texfat_unhash_inode(inode);\n\texfat_d_version_set(dentry, inode_query_iversion(dir));\nunlock:\n\tmutex_unlock(&EXFAT_SB(inode->i_sb)->s_lock);\n\treturn err;\n}\n\nstatic int exfat_rename_file(struct inode *inode, struct exfat_chain *p_dir,\n\t\tint oldentry, struct exfat_uni_name *p_uniname,\n\t\tstruct exfat_inode_info *ei)\n{\n\tint ret, num_old_entries, num_new_entries;\n\tstruct exfat_dentry *epold, *epnew;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *new_bh, *old_bh;\n\tint sync = IS_DIRSYNC(inode);\n\n\tepold = exfat_get_dentry(sb, p_dir, oldentry, &old_bh);\n\tif (!epold)\n\t\treturn -EIO;\n\n\tnum_old_entries = exfat_count_ext_entries(sb, p_dir, oldentry, epold);\n\tif (num_old_entries < 0)\n\t\treturn -EIO;\n\tnum_old_entries++;\n\n\tnum_new_entries = exfat_calc_num_entries(p_uniname);\n\tif (num_new_entries < 0)\n\t\treturn num_new_entries;\n\n\tif (num_old_entries < num_new_entries) {\n\t\tint newentry;\n\n\t\tnewentry =\n\t\t\texfat_find_empty_entry(inode, p_dir, num_new_entries);\n\t\tif (newentry < 0)\n\t\t\treturn newentry;  \n\n\t\tepnew = exfat_get_dentry(sb, p_dir, newentry, &new_bh);\n\t\tif (!epnew)\n\t\t\treturn -EIO;\n\n\t\t*epnew = *epold;\n\t\tif (exfat_get_entry_type(epnew) == TYPE_FILE) {\n\t\t\tepnew->dentry.file.attr |= cpu_to_le16(ATTR_ARCHIVE);\n\t\t\tei->attr |= ATTR_ARCHIVE;\n\t\t}\n\t\texfat_update_bh(new_bh, sync);\n\t\tbrelse(old_bh);\n\t\tbrelse(new_bh);\n\n\t\tepold = exfat_get_dentry(sb, p_dir, oldentry + 1, &old_bh);\n\t\tif (!epold)\n\t\t\treturn -EIO;\n\t\tepnew = exfat_get_dentry(sb, p_dir, newentry + 1, &new_bh);\n\t\tif (!epnew) {\n\t\t\tbrelse(old_bh);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t*epnew = *epold;\n\t\texfat_update_bh(new_bh, sync);\n\t\tbrelse(old_bh);\n\t\tbrelse(new_bh);\n\n\t\tret = exfat_init_ext_entry(inode, p_dir, newentry,\n\t\t\tnum_new_entries, p_uniname);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\texfat_remove_entries(inode, p_dir, oldentry, 0,\n\t\t\tnum_old_entries);\n\t\tei->dir = *p_dir;\n\t\tei->entry = newentry;\n\t} else {\n\t\tif (exfat_get_entry_type(epold) == TYPE_FILE) {\n\t\t\tepold->dentry.file.attr |= cpu_to_le16(ATTR_ARCHIVE);\n\t\t\tei->attr |= ATTR_ARCHIVE;\n\t\t}\n\t\texfat_update_bh(old_bh, sync);\n\t\tbrelse(old_bh);\n\t\tret = exfat_init_ext_entry(inode, p_dir, oldentry,\n\t\t\tnum_new_entries, p_uniname);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\texfat_remove_entries(inode, p_dir, oldentry, num_new_entries,\n\t\t\tnum_old_entries);\n\t}\n\treturn 0;\n}\n\nstatic int exfat_move_file(struct inode *inode, struct exfat_chain *p_olddir,\n\t\tint oldentry, struct exfat_chain *p_newdir,\n\t\tstruct exfat_uni_name *p_uniname, struct exfat_inode_info *ei)\n{\n\tint ret, newentry, num_new_entries, num_old_entries;\n\tstruct exfat_dentry *epmov, *epnew;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *mov_bh, *new_bh;\n\n\tepmov = exfat_get_dentry(sb, p_olddir, oldentry, &mov_bh);\n\tif (!epmov)\n\t\treturn -EIO;\n\n\tnum_old_entries = exfat_count_ext_entries(sb, p_olddir, oldentry,\n\t\tepmov);\n\tif (num_old_entries < 0)\n\t\treturn -EIO;\n\tnum_old_entries++;\n\n\tnum_new_entries = exfat_calc_num_entries(p_uniname);\n\tif (num_new_entries < 0)\n\t\treturn num_new_entries;\n\n\tnewentry = exfat_find_empty_entry(inode, p_newdir, num_new_entries);\n\tif (newentry < 0)\n\t\treturn newentry;  \n\n\tepnew = exfat_get_dentry(sb, p_newdir, newentry, &new_bh);\n\tif (!epnew)\n\t\treturn -EIO;\n\n\t*epnew = *epmov;\n\tif (exfat_get_entry_type(epnew) == TYPE_FILE) {\n\t\tepnew->dentry.file.attr |= cpu_to_le16(ATTR_ARCHIVE);\n\t\tei->attr |= ATTR_ARCHIVE;\n\t}\n\texfat_update_bh(new_bh, IS_DIRSYNC(inode));\n\tbrelse(mov_bh);\n\tbrelse(new_bh);\n\n\tepmov = exfat_get_dentry(sb, p_olddir, oldentry + 1, &mov_bh);\n\tif (!epmov)\n\t\treturn -EIO;\n\tepnew = exfat_get_dentry(sb, p_newdir, newentry + 1, &new_bh);\n\tif (!epnew) {\n\t\tbrelse(mov_bh);\n\t\treturn -EIO;\n\t}\n\n\t*epnew = *epmov;\n\texfat_update_bh(new_bh, IS_DIRSYNC(inode));\n\tbrelse(mov_bh);\n\tbrelse(new_bh);\n\n\tret = exfat_init_ext_entry(inode, p_newdir, newentry, num_new_entries,\n\t\tp_uniname);\n\tif (ret)\n\t\treturn ret;\n\n\texfat_remove_entries(inode, p_olddir, oldentry, 0, num_old_entries);\n\n\texfat_chain_set(&ei->dir, p_newdir->dir, p_newdir->size,\n\t\tp_newdir->flags);\n\n\tei->entry = newentry;\n\treturn 0;\n}\n\n \nstatic int __exfat_rename(struct inode *old_parent_inode,\n\t\tstruct exfat_inode_info *ei, struct inode *new_parent_inode,\n\t\tstruct dentry *new_dentry)\n{\n\tint ret;\n\tint dentry;\n\tstruct exfat_chain olddir, newdir;\n\tstruct exfat_chain *p_dir = NULL;\n\tstruct exfat_uni_name uni_name;\n\tstruct exfat_dentry *ep;\n\tstruct super_block *sb = old_parent_inode->i_sb;\n\tstruct exfat_sb_info *sbi = EXFAT_SB(sb);\n\tconst unsigned char *new_path = new_dentry->d_name.name;\n\tstruct inode *new_inode = new_dentry->d_inode;\n\tint num_entries;\n\tstruct exfat_inode_info *new_ei = NULL;\n\tunsigned int new_entry_type = TYPE_UNUSED;\n\tint new_entry = 0;\n\tstruct buffer_head *new_bh = NULL;\n\n\t \n\tif (new_path == NULL || strlen(new_path) == 0)\n\t\treturn -EINVAL;\n\n\tif (ei->dir.dir == DIR_DELETED) {\n\t\texfat_err(sb, \"abnormal access to deleted source dentry\");\n\t\treturn -ENOENT;\n\t}\n\n\texfat_chain_set(&olddir, EXFAT_I(old_parent_inode)->start_clu,\n\t\tEXFAT_B_TO_CLU_ROUND_UP(i_size_read(old_parent_inode), sbi),\n\t\tEXFAT_I(old_parent_inode)->flags);\n\tdentry = ei->entry;\n\n\t \n\tif (new_inode) {\n\t\tret = -EIO;\n\t\tnew_ei = EXFAT_I(new_inode);\n\n\t\tif (new_ei->dir.dir == DIR_DELETED) {\n\t\t\texfat_err(sb, \"abnormal access to deleted target dentry\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tp_dir = &(new_ei->dir);\n\t\tnew_entry = new_ei->entry;\n\t\tep = exfat_get_dentry(sb, p_dir, new_entry, &new_bh);\n\t\tif (!ep)\n\t\t\tgoto out;\n\n\t\tnew_entry_type = exfat_get_entry_type(ep);\n\t\tbrelse(new_bh);\n\n\t\t \n\t\tif (new_entry_type == TYPE_DIR) {\n\t\t\tstruct exfat_chain new_clu;\n\n\t\t\tnew_clu.dir = new_ei->start_clu;\n\t\t\tnew_clu.size =\n\t\t\t\tEXFAT_B_TO_CLU_ROUND_UP(i_size_read(new_inode),\n\t\t\t\tsbi);\n\t\t\tnew_clu.flags = new_ei->flags;\n\n\t\t\tret = exfat_check_dir_empty(sb, &new_clu);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tret = exfat_resolve_path(new_parent_inode, new_path, &newdir,\n\t\t\t&uni_name);\n\tif (ret)\n\t\tgoto out;\n\n\texfat_set_volume_dirty(sb);\n\n\tif (olddir.dir == newdir.dir)\n\t\tret = exfat_rename_file(new_parent_inode, &olddir, dentry,\n\t\t\t\t&uni_name, ei);\n\telse\n\t\tret = exfat_move_file(new_parent_inode, &olddir, dentry,\n\t\t\t\t&newdir, &uni_name, ei);\n\n\tif (!ret && new_inode) {\n\t\t \n\t\tep = exfat_get_dentry(sb, p_dir, new_entry, &new_bh);\n\t\tif (!ep) {\n\t\t\tret = -EIO;\n\t\t\tgoto del_out;\n\t\t}\n\n\t\tnum_entries = exfat_count_ext_entries(sb, p_dir, new_entry, ep);\n\t\tif (num_entries < 0) {\n\t\t\tret = -EIO;\n\t\t\tgoto del_out;\n\t\t}\n\t\tbrelse(new_bh);\n\n\t\tif (exfat_remove_entries(new_inode, p_dir, new_entry, 0,\n\t\t\t\tnum_entries + 1)) {\n\t\t\tret = -EIO;\n\t\t\tgoto del_out;\n\t\t}\n\n\t\t \n\t\tif (new_entry_type == TYPE_DIR &&\n\t\t    new_ei->start_clu != EXFAT_EOF_CLUSTER) {\n\t\t\t \n\t\t\tstruct exfat_chain new_clu_to_free;\n\n\t\t\texfat_chain_set(&new_clu_to_free, new_ei->start_clu,\n\t\t\t\tEXFAT_B_TO_CLU_ROUND_UP(i_size_read(new_inode),\n\t\t\t\tsbi), new_ei->flags);\n\n\t\t\tif (exfat_free_cluster(new_inode, &new_clu_to_free)) {\n\t\t\t\t \n\t\t\t\tret = -EIO;\n\t\t\t}\n\n\t\t\ti_size_write(new_inode, 0);\n\t\t\tnew_ei->start_clu = EXFAT_EOF_CLUSTER;\n\t\t\tnew_ei->flags = ALLOC_NO_FAT_CHAIN;\n\t\t}\ndel_out:\n\t\t \n\t\tnew_ei->dir.dir = DIR_DELETED;\n\t}\nout:\n\treturn ret;\n}\n\nstatic int exfat_rename(struct mnt_idmap *idmap,\n\t\t\tstruct inode *old_dir, struct dentry *old_dentry,\n\t\t\tstruct inode *new_dir, struct dentry *new_dentry,\n\t\t\tunsigned int flags)\n{\n\tstruct inode *old_inode, *new_inode;\n\tstruct super_block *sb = old_dir->i_sb;\n\tloff_t i_pos;\n\tint err;\n\n\t \n\tif (flags & ~RENAME_NOREPLACE)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&EXFAT_SB(sb)->s_lock);\n\told_inode = old_dentry->d_inode;\n\tnew_inode = new_dentry->d_inode;\n\n\terr = __exfat_rename(old_dir, EXFAT_I(old_inode), new_dir, new_dentry);\n\tif (err)\n\t\tgoto unlock;\n\n\tinode_inc_iversion(new_dir);\n\tsimple_rename_timestamp(old_dir, old_dentry, new_dir, new_dentry);\n\tEXFAT_I(new_dir)->i_crtime = current_time(new_dir);\n\texfat_truncate_atime(&new_dir->i_atime);\n\tif (IS_DIRSYNC(new_dir))\n\t\texfat_sync_inode(new_dir);\n\telse\n\t\tmark_inode_dirty(new_dir);\n\n\ti_pos = ((loff_t)EXFAT_I(old_inode)->dir.dir << 32) |\n\t\t(EXFAT_I(old_inode)->entry & 0xffffffff);\n\texfat_unhash_inode(old_inode);\n\texfat_hash_inode(old_inode, i_pos);\n\tif (IS_DIRSYNC(new_dir))\n\t\texfat_sync_inode(old_inode);\n\telse\n\t\tmark_inode_dirty(old_inode);\n\n\tif (S_ISDIR(old_inode->i_mode) && old_dir != new_dir) {\n\t\tdrop_nlink(old_dir);\n\t\tif (!new_inode)\n\t\t\tinc_nlink(new_dir);\n\t}\n\n\tinode_inc_iversion(old_dir);\n\tif (IS_DIRSYNC(old_dir))\n\t\texfat_sync_inode(old_dir);\n\telse\n\t\tmark_inode_dirty(old_dir);\n\n\tif (new_inode) {\n\t\texfat_unhash_inode(new_inode);\n\n\t\t \n\t\tif (new_inode->i_nlink) {\n\t\t\tdrop_nlink(new_inode);\n\t\t\tif (S_ISDIR(new_inode->i_mode))\n\t\t\t\tdrop_nlink(new_inode);\n\t\t} else {\n\t\t\texfat_warn(sb, \"abnormal access to an inode dropped\");\n\t\t\tWARN_ON(new_inode->i_nlink == 0);\n\t\t}\n\t\tEXFAT_I(new_inode)->i_crtime = current_time(new_inode);\n\t}\n\nunlock:\n\tmutex_unlock(&EXFAT_SB(sb)->s_lock);\n\treturn err;\n}\n\nconst struct inode_operations exfat_dir_inode_operations = {\n\t.create\t\t= exfat_create,\n\t.lookup\t\t= exfat_lookup,\n\t.unlink\t\t= exfat_unlink,\n\t.mkdir\t\t= exfat_mkdir,\n\t.rmdir\t\t= exfat_rmdir,\n\t.rename\t\t= exfat_rename,\n\t.setattr\t= exfat_setattr,\n\t.getattr\t= exfat_getattr,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}