{
  "module_name": "balloc.c",
  "hash_id": "a2f12bdd01eb0782303acf51b9f2e7ff87f1de0ab82a31d90dcf403ee59fe522",
  "original_prompt": "Ingested from linux-6.6.14/fs/exfat/balloc.c",
  "human_readable_source": "\n \n\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\n#include \"exfat_raw.h\"\n#include \"exfat_fs.h\"\n\nstatic const unsigned char free_bit[] = {\n\t0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, \n\t0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, \n\t0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, \n\t0, 1, 0, 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, \n\t0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, \n\t0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, \n\t0, 1, 0, 2, 0, 1, 0, 7, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, \n\t0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, \n\t0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, \n\t0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 6, 0, 1, 0, 2, 0, 1, 0, 3, \n\t0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, \n\t0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, \n\t0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0                 \n};\n\nstatic const unsigned char used_bit[] = {\n\t0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, \n\t2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 1, 2, 2, 3, 2, 3, 3, 4, \n\t2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, \n\t4, 5, 5, 6, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, \n\t2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, \n\t3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, \n\t4, 5, 5, 6, 5, 6, 6, 7, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, \n\t3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, \n\t2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, \n\t4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 2, 3, 3, 4, 3, 4, 4, 5, \n\t3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, \n\t5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, \n\t4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8              \n};\n\n \nstatic int exfat_allocate_bitmap(struct super_block *sb,\n\t\tstruct exfat_dentry *ep)\n{\n\tstruct exfat_sb_info *sbi = EXFAT_SB(sb);\n\tlong long map_size;\n\tunsigned int i, need_map_size;\n\tsector_t sector;\n\n\tsbi->map_clu = le32_to_cpu(ep->dentry.bitmap.start_clu);\n\tmap_size = le64_to_cpu(ep->dentry.bitmap.size);\n\tneed_map_size = ((EXFAT_DATA_CLUSTER_COUNT(sbi) - 1) / BITS_PER_BYTE)\n\t\t+ 1;\n\tif (need_map_size != map_size) {\n\t\texfat_err(sb, \"bogus allocation bitmap size(need : %u, cur : %lld)\",\n\t\t\t  need_map_size, map_size);\n\t\t \n\t\tif (need_map_size > map_size)\n\t\t\treturn -EIO;\n\t}\n\tsbi->map_sectors = ((need_map_size - 1) >>\n\t\t\t(sb->s_blocksize_bits)) + 1;\n\tsbi->vol_amap = kvmalloc_array(sbi->map_sectors,\n\t\t\t\tsizeof(struct buffer_head *), GFP_KERNEL);\n\tif (!sbi->vol_amap)\n\t\treturn -ENOMEM;\n\n\tsector = exfat_cluster_to_sector(sbi, sbi->map_clu);\n\tfor (i = 0; i < sbi->map_sectors; i++) {\n\t\tsbi->vol_amap[i] = sb_bread(sb, sector + i);\n\t\tif (!sbi->vol_amap[i]) {\n\t\t\t \n\t\t\tint j = 0;\n\n\t\t\twhile (j < i)\n\t\t\t\tbrelse(sbi->vol_amap[j++]);\n\n\t\t\tkvfree(sbi->vol_amap);\n\t\t\tsbi->vol_amap = NULL;\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint exfat_load_bitmap(struct super_block *sb)\n{\n\tunsigned int i, type;\n\tstruct exfat_chain clu;\n\tstruct exfat_sb_info *sbi = EXFAT_SB(sb);\n\n\texfat_chain_set(&clu, sbi->root_dir, 0, ALLOC_FAT_CHAIN);\n\twhile (clu.dir != EXFAT_EOF_CLUSTER) {\n\t\tfor (i = 0; i < sbi->dentries_per_clu; i++) {\n\t\t\tstruct exfat_dentry *ep;\n\t\t\tstruct buffer_head *bh;\n\n\t\t\tep = exfat_get_dentry(sb, &clu, i, &bh);\n\t\t\tif (!ep)\n\t\t\t\treturn -EIO;\n\n\t\t\ttype = exfat_get_entry_type(ep);\n\t\t\tif (type == TYPE_UNUSED)\n\t\t\t\tbreak;\n\t\t\tif (type != TYPE_BITMAP)\n\t\t\t\tcontinue;\n\t\t\tif (ep->dentry.bitmap.flags == 0x0) {\n\t\t\t\tint err;\n\n\t\t\t\terr = exfat_allocate_bitmap(sb, ep);\n\t\t\t\tbrelse(bh);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tbrelse(bh);\n\t\t}\n\n\t\tif (exfat_get_next_cluster(sb, &clu.dir))\n\t\t\treturn -EIO;\n\t}\n\n\treturn -EINVAL;\n}\n\nvoid exfat_free_bitmap(struct exfat_sb_info *sbi)\n{\n\tint i;\n\n\tfor (i = 0; i < sbi->map_sectors; i++)\n\t\t__brelse(sbi->vol_amap[i]);\n\n\tkvfree(sbi->vol_amap);\n}\n\nint exfat_set_bitmap(struct inode *inode, unsigned int clu, bool sync)\n{\n\tint i, b;\n\tunsigned int ent_idx;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct exfat_sb_info *sbi = EXFAT_SB(sb);\n\n\tif (!is_valid_cluster(sbi, clu))\n\t\treturn -EINVAL;\n\n\tent_idx = CLUSTER_TO_BITMAP_ENT(clu);\n\ti = BITMAP_OFFSET_SECTOR_INDEX(sb, ent_idx);\n\tb = BITMAP_OFFSET_BIT_IN_SECTOR(sb, ent_idx);\n\n\tset_bit_le(b, sbi->vol_amap[i]->b_data);\n\texfat_update_bh(sbi->vol_amap[i], sync);\n\treturn 0;\n}\n\nvoid exfat_clear_bitmap(struct inode *inode, unsigned int clu, bool sync)\n{\n\tint i, b;\n\tunsigned int ent_idx;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct exfat_sb_info *sbi = EXFAT_SB(sb);\n\tstruct exfat_mount_options *opts = &sbi->options;\n\n\tif (!is_valid_cluster(sbi, clu))\n\t\treturn;\n\n\tent_idx = CLUSTER_TO_BITMAP_ENT(clu);\n\ti = BITMAP_OFFSET_SECTOR_INDEX(sb, ent_idx);\n\tb = BITMAP_OFFSET_BIT_IN_SECTOR(sb, ent_idx);\n\n\tclear_bit_le(b, sbi->vol_amap[i]->b_data);\n\texfat_update_bh(sbi->vol_amap[i], sync);\n\n\tif (opts->discard) {\n\t\tint ret_discard;\n\n\t\tret_discard = sb_issue_discard(sb,\n\t\t\texfat_cluster_to_sector(sbi, clu),\n\t\t\t(1 << sbi->sect_per_clus_bits), GFP_NOFS, 0);\n\n\t\tif (ret_discard == -EOPNOTSUPP) {\n\t\t\texfat_err(sb, \"discard not supported by device, disabling\");\n\t\t\topts->discard = 0;\n\t\t}\n\t}\n}\n\n \nunsigned int exfat_find_free_bitmap(struct super_block *sb, unsigned int clu)\n{\n\tunsigned int i, map_i, map_b, ent_idx;\n\tunsigned int clu_base, clu_free;\n\tunsigned char k, clu_mask;\n\tstruct exfat_sb_info *sbi = EXFAT_SB(sb);\n\n\tWARN_ON(clu < EXFAT_FIRST_CLUSTER);\n\tent_idx = CLUSTER_TO_BITMAP_ENT(clu);\n\tclu_base = BITMAP_ENT_TO_CLUSTER(ent_idx & ~(BITS_PER_BYTE_MASK));\n\tclu_mask = IGNORED_BITS_REMAINED(clu, clu_base);\n\n\tmap_i = BITMAP_OFFSET_SECTOR_INDEX(sb, ent_idx);\n\tmap_b = BITMAP_OFFSET_BYTE_IN_SECTOR(sb, ent_idx);\n\n\tfor (i = EXFAT_FIRST_CLUSTER; i < sbi->num_clusters;\n\t     i += BITS_PER_BYTE) {\n\t\tk = *(sbi->vol_amap[map_i]->b_data + map_b);\n\t\tif (clu_mask > 0) {\n\t\t\tk |= clu_mask;\n\t\t\tclu_mask = 0;\n\t\t}\n\t\tif (k < 0xFF) {\n\t\t\tclu_free = clu_base + free_bit[k];\n\t\t\tif (clu_free < sbi->num_clusters)\n\t\t\t\treturn clu_free;\n\t\t}\n\t\tclu_base += BITS_PER_BYTE;\n\n\t\tif (++map_b >= sb->s_blocksize ||\n\t\t    clu_base >= sbi->num_clusters) {\n\t\t\tif (++map_i >= sbi->map_sectors) {\n\t\t\t\tclu_base = EXFAT_FIRST_CLUSTER;\n\t\t\t\tmap_i = 0;\n\t\t\t}\n\t\t\tmap_b = 0;\n\t\t}\n\t}\n\n\treturn EXFAT_EOF_CLUSTER;\n}\n\nint exfat_count_used_clusters(struct super_block *sb, unsigned int *ret_count)\n{\n\tstruct exfat_sb_info *sbi = EXFAT_SB(sb);\n\tunsigned int count = 0;\n\tunsigned int i, map_i = 0, map_b = 0;\n\tunsigned int total_clus = EXFAT_DATA_CLUSTER_COUNT(sbi);\n\tunsigned int last_mask = total_clus & BITS_PER_BYTE_MASK;\n\tunsigned char clu_bits;\n\tconst unsigned char last_bit_mask[] = {0, 0b00000001, 0b00000011,\n\t\t0b00000111, 0b00001111, 0b00011111, 0b00111111, 0b01111111};\n\n\ttotal_clus &= ~last_mask;\n\tfor (i = 0; i < total_clus; i += BITS_PER_BYTE) {\n\t\tclu_bits = *(sbi->vol_amap[map_i]->b_data + map_b);\n\t\tcount += used_bit[clu_bits];\n\t\tif (++map_b >= (unsigned int)sb->s_blocksize) {\n\t\t\tmap_i++;\n\t\t\tmap_b = 0;\n\t\t}\n\t}\n\n\tif (last_mask) {\n\t\tclu_bits = *(sbi->vol_amap[map_i]->b_data + map_b);\n\t\tclu_bits &= last_bit_mask[last_mask];\n\t\tcount += used_bit[clu_bits];\n\t}\n\n\t*ret_count = count;\n\treturn 0;\n}\n\nint exfat_trim_fs(struct inode *inode, struct fstrim_range *range)\n{\n\tunsigned int trim_begin, trim_end, count, next_free_clu;\n\tu64 clu_start, clu_end, trim_minlen, trimmed_total = 0;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct exfat_sb_info *sbi = EXFAT_SB(sb);\n\tint err = 0;\n\n\tclu_start = max_t(u64, range->start >> sbi->cluster_size_bits,\n\t\t\t\tEXFAT_FIRST_CLUSTER);\n\tclu_end = clu_start + (range->len >> sbi->cluster_size_bits) - 1;\n\ttrim_minlen = range->minlen >> sbi->cluster_size_bits;\n\n\tif (clu_start >= sbi->num_clusters || range->len < sbi->cluster_size)\n\t\treturn -EINVAL;\n\n\tif (clu_end >= sbi->num_clusters)\n\t\tclu_end = sbi->num_clusters - 1;\n\n\tmutex_lock(&sbi->bitmap_lock);\n\n\ttrim_begin = trim_end = exfat_find_free_bitmap(sb, clu_start);\n\tif (trim_begin == EXFAT_EOF_CLUSTER)\n\t\tgoto unlock;\n\n\tnext_free_clu = exfat_find_free_bitmap(sb, trim_end + 1);\n\tif (next_free_clu == EXFAT_EOF_CLUSTER)\n\t\tgoto unlock;\n\n\tdo {\n\t\tif (next_free_clu == trim_end + 1) {\n\t\t\t \n\t\t\ttrim_end++;\n\t\t} else {\n\t\t\t \n\t\t\tcount = trim_end - trim_begin + 1;\n\t\t\tif (count >= trim_minlen) {\n\t\t\t\terr = sb_issue_discard(sb,\n\t\t\t\t\texfat_cluster_to_sector(sbi, trim_begin),\n\t\t\t\t\tcount * sbi->sect_per_clus, GFP_NOFS, 0);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto unlock;\n\n\t\t\t\ttrimmed_total += count;\n\t\t\t}\n\n\t\t\t \n\t\t\ttrim_begin = trim_end = next_free_clu;\n\t\t}\n\n\t\tif (next_free_clu >= clu_end)\n\t\t\tbreak;\n\n\t\tif (fatal_signal_pending(current)) {\n\t\t\terr = -ERESTARTSYS;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tnext_free_clu = exfat_find_free_bitmap(sb, next_free_clu + 1);\n\t} while (next_free_clu != EXFAT_EOF_CLUSTER &&\n\t\t\tnext_free_clu > trim_end);\n\n\t \n\tcount = trim_end - trim_begin + 1;\n\tif (count >= trim_minlen) {\n\t\terr = sb_issue_discard(sb, exfat_cluster_to_sector(sbi, trim_begin),\n\t\t\tcount * sbi->sect_per_clus, GFP_NOFS, 0);\n\t\tif (err)\n\t\t\tgoto unlock;\n\n\t\ttrimmed_total += count;\n\t}\n\nunlock:\n\tmutex_unlock(&sbi->bitmap_lock);\n\trange->len = trimmed_total << sbi->cluster_size_bits;\n\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}