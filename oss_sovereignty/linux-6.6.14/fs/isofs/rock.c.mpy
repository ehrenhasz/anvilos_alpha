{
  "module_name": "rock.c",
  "hash_id": "10386a39bcb223e1ee50579b7869696d2e1c4bb6b21563b48e4465f1478563dc",
  "original_prompt": "Ingested from linux-6.6.14/fs/isofs/rock.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n\n#include \"isofs.h\"\n#include \"rock.h\"\n\n \n\n#define SIG(A,B) ((A) | ((B) << 8))\t \n\nstruct rock_state {\n\tvoid *buffer;\n\tunsigned char *chr;\n\tint len;\n\tint cont_size;\n\tint cont_extent;\n\tint cont_offset;\n\tint cont_loops;\n\tstruct inode *inode;\n};\n\n \n\nstatic int check_sp(struct rock_ridge *rr, struct inode *inode)\n{\n\tif (rr->u.SP.magic[0] != 0xbe)\n\t\treturn -1;\n\tif (rr->u.SP.magic[1] != 0xef)\n\t\treturn -1;\n\tISOFS_SB(inode->i_sb)->s_rock_offset = rr->u.SP.skip;\n\treturn 0;\n}\n\nstatic void setup_rock_ridge(struct iso_directory_record *de,\n\t\t\tstruct inode *inode, struct rock_state *rs)\n{\n\trs->len = sizeof(struct iso_directory_record) + de->name_len[0];\n\tif (rs->len & 1)\n\t\t(rs->len)++;\n\trs->chr = (unsigned char *)de + rs->len;\n\trs->len = *((unsigned char *)de) - rs->len;\n\tif (rs->len < 0)\n\t\trs->len = 0;\n\n\tif (ISOFS_SB(inode->i_sb)->s_rock_offset != -1) {\n\t\trs->len -= ISOFS_SB(inode->i_sb)->s_rock_offset;\n\t\trs->chr += ISOFS_SB(inode->i_sb)->s_rock_offset;\n\t\tif (rs->len < 0)\n\t\t\trs->len = 0;\n\t}\n}\n\nstatic void init_rock_state(struct rock_state *rs, struct inode *inode)\n{\n\tmemset(rs, 0, sizeof(*rs));\n\trs->inode = inode;\n}\n\n \n#define RR_MAX_CE_ENTRIES 32\n\n \nstatic int rock_continue(struct rock_state *rs)\n{\n\tint ret = 1;\n\tint blocksize = 1 << rs->inode->i_blkbits;\n\tconst int min_de_size = offsetof(struct rock_ridge, u);\n\n\tkfree(rs->buffer);\n\trs->buffer = NULL;\n\n\tif ((unsigned)rs->cont_offset > blocksize - min_de_size ||\n\t    (unsigned)rs->cont_size > blocksize ||\n\t    (unsigned)(rs->cont_offset + rs->cont_size) > blocksize) {\n\t\tprintk(KERN_NOTICE \"rock: corrupted directory entry. \"\n\t\t\t\"extent=%d, offset=%d, size=%d\\n\",\n\t\t\trs->cont_extent, rs->cont_offset, rs->cont_size);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tif (rs->cont_extent) {\n\t\tstruct buffer_head *bh;\n\n\t\trs->buffer = kmalloc(rs->cont_size, GFP_KERNEL);\n\t\tif (!rs->buffer) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = -EIO;\n\t\tif (++rs->cont_loops >= RR_MAX_CE_ENTRIES)\n\t\t\tgoto out;\n\t\tbh = sb_bread(rs->inode->i_sb, rs->cont_extent);\n\t\tif (bh) {\n\t\t\tmemcpy(rs->buffer, bh->b_data + rs->cont_offset,\n\t\t\t\t\trs->cont_size);\n\t\t\tput_bh(bh);\n\t\t\trs->chr = rs->buffer;\n\t\t\trs->len = rs->cont_size;\n\t\t\trs->cont_extent = 0;\n\t\t\trs->cont_size = 0;\n\t\t\trs->cont_offset = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tprintk(\"Unable to read rock-ridge attributes\\n\");\n\t}\nout:\n\tkfree(rs->buffer);\n\trs->buffer = NULL;\n\treturn ret;\n}\n\n \nstatic int rock_check_overflow(struct rock_state *rs, int sig)\n{\n\tint len;\n\n\tswitch (sig) {\n\tcase SIG('S', 'P'):\n\t\tlen = sizeof(struct SU_SP_s);\n\t\tbreak;\n\tcase SIG('C', 'E'):\n\t\tlen = sizeof(struct SU_CE_s);\n\t\tbreak;\n\tcase SIG('E', 'R'):\n\t\tlen = sizeof(struct SU_ER_s);\n\t\tbreak;\n\tcase SIG('R', 'R'):\n\t\tlen = sizeof(struct RR_RR_s);\n\t\tbreak;\n\tcase SIG('P', 'X'):\n\t\tlen = sizeof(struct RR_PX_s);\n\t\tbreak;\n\tcase SIG('P', 'N'):\n\t\tlen = sizeof(struct RR_PN_s);\n\t\tbreak;\n\tcase SIG('S', 'L'):\n\t\tlen = sizeof(struct RR_SL_s);\n\t\tbreak;\n\tcase SIG('N', 'M'):\n\t\tlen = sizeof(struct RR_NM_s);\n\t\tbreak;\n\tcase SIG('C', 'L'):\n\t\tlen = sizeof(struct RR_CL_s);\n\t\tbreak;\n\tcase SIG('P', 'L'):\n\t\tlen = sizeof(struct RR_PL_s);\n\t\tbreak;\n\tcase SIG('T', 'F'):\n\t\tlen = sizeof(struct RR_TF_s);\n\t\tbreak;\n\tcase SIG('Z', 'F'):\n\t\tlen = sizeof(struct RR_ZF_s);\n\t\tbreak;\n\tdefault:\n\t\tlen = 0;\n\t\tbreak;\n\t}\n\tlen += offsetof(struct rock_ridge, u);\n\tif (len > rs->len) {\n\t\tprintk(KERN_NOTICE \"rock: directory entry would overflow \"\n\t\t\t\t\"storage\\n\");\n\t\tprintk(KERN_NOTICE \"rock: sig=0x%02x, size=%d, remaining=%d\\n\",\n\t\t\t\tsig, len, rs->len);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\n \nint get_rock_ridge_filename(struct iso_directory_record *de,\n\t\t\t    char *retname, struct inode *inode)\n{\n\tstruct rock_state rs;\n\tstruct rock_ridge *rr;\n\tint sig;\n\tint retnamlen = 0;\n\tint truncate = 0;\n\tint ret = 0;\n\tchar *p;\n\tint len;\n\n\tif (!ISOFS_SB(inode->i_sb)->s_rock)\n\t\treturn 0;\n\t*retname = 0;\n\n\tinit_rock_state(&rs, inode);\n\tsetup_rock_ridge(de, inode, &rs);\nrepeat:\n\n\twhile (rs.len > 2) {  \n\t\trr = (struct rock_ridge *)rs.chr;\n\t\t \n\t\tif (rr->len < 3)\n\t\t\tgoto out;\t \n\t\tsig = isonum_721(rs.chr);\n\t\tif (rock_check_overflow(&rs, sig))\n\t\t\tgoto eio;\n\t\trs.chr += rr->len;\n\t\trs.len -= rr->len;\n\t\t \n\t\tif (rs.len < 0)\n\t\t\tgoto out;\t \n\n\t\tswitch (sig) {\n\t\tcase SIG('R', 'R'):\n\t\t\tif ((rr->u.RR.flags[0] & RR_NM) == 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('S', 'P'):\n\t\t\tif (check_sp(rr, inode))\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('C', 'E'):\n\t\t\trs.cont_extent = isonum_733(rr->u.CE.extent);\n\t\t\trs.cont_offset = isonum_733(rr->u.CE.offset);\n\t\t\trs.cont_size = isonum_733(rr->u.CE.size);\n\t\t\tbreak;\n\t\tcase SIG('N', 'M'):\n\t\t\tif (truncate)\n\t\t\t\tbreak;\n\t\t\tif (rr->len < 5)\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tif (rr->u.NM.flags & 6)\n\t\t\t\tbreak;\n\n\t\t\tif (rr->u.NM.flags & ~1) {\n\t\t\t\tprintk(\"Unsupported NM flag settings (%d)\\n\",\n\t\t\t\t\trr->u.NM.flags);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlen = rr->len - 5;\n\t\t\tif (retnamlen + len >= 254) {\n\t\t\t\ttruncate = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp = memchr(rr->u.NM.name, '\\0', len);\n\t\t\tif (unlikely(p))\n\t\t\t\tlen = p - rr->u.NM.name;\n\t\t\tmemcpy(retname + retnamlen, rr->u.NM.name, len);\n\t\t\tretnamlen += len;\n\t\t\tretname[retnamlen] = '\\0';\n\t\t\tbreak;\n\t\tcase SIG('R', 'E'):\n\t\t\tkfree(rs.buffer);\n\t\t\treturn -1;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tret = rock_continue(&rs);\n\tif (ret == 0)\n\t\tgoto repeat;\n\tif (ret == 1)\n\t\treturn retnamlen;  \nout:\n\tkfree(rs.buffer);\n\treturn ret;\neio:\n\tret = -EIO;\n\tgoto out;\n}\n\n#define RR_REGARD_XA 1\n#define RR_RELOC_DE 2\n\nstatic int\nparse_rock_ridge_inode_internal(struct iso_directory_record *de,\n\t\t\t\tstruct inode *inode, int flags)\n{\n\tint symlink_len = 0;\n\tint cnt, sig;\n\tunsigned int reloc_block;\n\tstruct inode *reloc;\n\tstruct rock_ridge *rr;\n\tint rootflag;\n\tstruct rock_state rs;\n\tint ret = 0;\n\n\tif (!ISOFS_SB(inode->i_sb)->s_rock)\n\t\treturn 0;\n\n\tinit_rock_state(&rs, inode);\n\tsetup_rock_ridge(de, inode, &rs);\n\tif (flags & RR_REGARD_XA) {\n\t\trs.chr += 14;\n\t\trs.len -= 14;\n\t\tif (rs.len < 0)\n\t\t\trs.len = 0;\n\t}\n\nrepeat:\n\twhile (rs.len > 2) {  \n\t\trr = (struct rock_ridge *)rs.chr;\n\t\t \n\t\tif (rr->len < 3)\n\t\t\tgoto out;\t \n\t\tsig = isonum_721(rs.chr);\n\t\tif (rock_check_overflow(&rs, sig))\n\t\t\tgoto eio;\n\t\trs.chr += rr->len;\n\t\trs.len -= rr->len;\n\t\t \n\t\tif (rs.len < 0)\n\t\t\tgoto out;\t \n\n\t\tswitch (sig) {\n#ifndef CONFIG_ZISOFS\t\t \n\t\tcase SIG('R', 'R'):\n\t\t\tif ((rr->u.RR.flags[0] &\n\t\t\t     (RR_PX | RR_TF | RR_SL | RR_CL)) == 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n#endif\n\t\tcase SIG('S', 'P'):\n\t\t\tif (check_sp(rr, inode))\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('C', 'E'):\n\t\t\trs.cont_extent = isonum_733(rr->u.CE.extent);\n\t\t\trs.cont_offset = isonum_733(rr->u.CE.offset);\n\t\t\trs.cont_size = isonum_733(rr->u.CE.size);\n\t\t\tbreak;\n\t\tcase SIG('E', 'R'):\n\t\t\t \n\t\t\tif (rr->u.ER.len_id + offsetof(struct rock_ridge, u.ER.data) > rr->len)\n\t\t\t\tgoto out;\n\t\t\tISOFS_SB(inode->i_sb)->s_rock = 1;\n\t\t\tprintk(KERN_DEBUG \"ISO 9660 Extensions: \");\n\t\t\t{\n\t\t\t\tint p;\n\t\t\t\tfor (p = 0; p < rr->u.ER.len_id; p++)\n\t\t\t\t\tprintk(KERN_CONT \"%c\", rr->u.ER.data[p]);\n\t\t\t}\n\t\t\tprintk(KERN_CONT \"\\n\");\n\t\t\tbreak;\n\t\tcase SIG('P', 'X'):\n\t\t\tinode->i_mode = isonum_733(rr->u.PX.mode);\n\t\t\tset_nlink(inode, isonum_733(rr->u.PX.n_links));\n\t\t\ti_uid_write(inode, isonum_733(rr->u.PX.uid));\n\t\t\ti_gid_write(inode, isonum_733(rr->u.PX.gid));\n\t\t\tbreak;\n\t\tcase SIG('P', 'N'):\n\t\t\t{\n\t\t\t\tint high, low;\n\t\t\t\thigh = isonum_733(rr->u.PN.dev_high);\n\t\t\t\tlow = isonum_733(rr->u.PN.dev_low);\n\t\t\t\t \n\t\t\t\tif ((low & ~0xff) && high == 0) {\n\t\t\t\t\tinode->i_rdev =\n\t\t\t\t\t    MKDEV(low >> 8, low & 0xff);\n\t\t\t\t} else {\n\t\t\t\t\tinode->i_rdev =\n\t\t\t\t\t    MKDEV(high, low);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SIG('T', 'F'):\n\t\t\t \n\t\t\t \n\t\t\tcnt = 0;\n\t\t\tif (rr->u.TF.flags & TF_CREATE) {\n\t\t\t\tinode_set_ctime(inode,\n\t\t\t\t\t\tiso_date(rr->u.TF.times[cnt++].time, 0),\n\t\t\t\t\t\t0);\n\t\t\t}\n\t\t\tif (rr->u.TF.flags & TF_MODIFY) {\n\t\t\t\tinode->i_mtime.tv_sec =\n\t\t\t\t    iso_date(rr->u.TF.times[cnt++].time,\n\t\t\t\t\t     0);\n\t\t\t\tinode->i_mtime.tv_nsec = 0;\n\t\t\t}\n\t\t\tif (rr->u.TF.flags & TF_ACCESS) {\n\t\t\t\tinode->i_atime.tv_sec =\n\t\t\t\t    iso_date(rr->u.TF.times[cnt++].time,\n\t\t\t\t\t     0);\n\t\t\t\tinode->i_atime.tv_nsec = 0;\n\t\t\t}\n\t\t\tif (rr->u.TF.flags & TF_ATTRIBUTES) {\n\t\t\t\tinode_set_ctime(inode,\n\t\t\t\t\t\tiso_date(rr->u.TF.times[cnt++].time, 0),\n\t\t\t\t\t\t0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SIG('S', 'L'):\n\t\t\t{\n\t\t\t\tint slen;\n\t\t\t\tstruct SL_component *slp;\n\t\t\t\tstruct SL_component *oldslp;\n\t\t\t\tslen = rr->len - 5;\n\t\t\t\tslp = &rr->u.SL.link;\n\t\t\t\tinode->i_size = symlink_len;\n\t\t\t\twhile (slen > 1) {\n\t\t\t\t\trootflag = 0;\n\t\t\t\t\tswitch (slp->flags & ~1) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tinode->i_size +=\n\t\t\t\t\t\t    slp->len;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tinode->i_size += 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tinode->i_size += 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 8:\n\t\t\t\t\t\trootflag = 1;\n\t\t\t\t\t\tinode->i_size += 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tprintk(\"Symlink component flag \"\n\t\t\t\t\t\t\t\"not implemented\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tslen -= slp->len + 2;\n\t\t\t\t\toldslp = slp;\n\t\t\t\t\tslp = (struct SL_component *)\n\t\t\t\t\t\t(((char *)slp) + slp->len + 2);\n\n\t\t\t\t\tif (slen < 2) {\n\t\t\t\t\t\tif (((rr->u.SL.\n\t\t\t\t\t\t      flags & 1) != 0)\n\t\t\t\t\t\t    &&\n\t\t\t\t\t\t    ((oldslp->\n\t\t\t\t\t\t      flags & 1) == 0))\n\t\t\t\t\t\t\tinode->i_size +=\n\t\t\t\t\t\t\t    1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t \n\t\t\t\t\tif (!rootflag\n\t\t\t\t\t    && (oldslp->flags & 1) == 0)\n\t\t\t\t\t\tinode->i_size += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsymlink_len = inode->i_size;\n\t\t\tbreak;\n\t\tcase SIG('R', 'E'):\n\t\t\tprintk(KERN_WARNING \"Attempt to read inode for \"\n\t\t\t\t\t\"relocated directory\\n\");\n\t\t\tgoto out;\n\t\tcase SIG('C', 'L'):\n\t\t\tif (flags & RR_RELOC_DE) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"ISOFS: Recursive directory relocation \"\n\t\t\t\t       \"is not supported\\n\");\n\t\t\t\tgoto eio;\n\t\t\t}\n\t\t\treloc_block = isonum_733(rr->u.CL.location);\n\t\t\tif (reloc_block == ISOFS_I(inode)->i_iget5_block &&\n\t\t\t    ISOFS_I(inode)->i_iget5_offset == 0) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"ISOFS: Directory relocation points to \"\n\t\t\t\t       \"itself\\n\");\n\t\t\t\tgoto eio;\n\t\t\t}\n\t\t\tISOFS_I(inode)->i_first_extent = reloc_block;\n\t\t\treloc = isofs_iget_reloc(inode->i_sb, reloc_block, 0);\n\t\t\tif (IS_ERR(reloc)) {\n\t\t\t\tret = PTR_ERR(reloc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tinode->i_mode = reloc->i_mode;\n\t\t\tset_nlink(inode, reloc->i_nlink);\n\t\t\tinode->i_uid = reloc->i_uid;\n\t\t\tinode->i_gid = reloc->i_gid;\n\t\t\tinode->i_rdev = reloc->i_rdev;\n\t\t\tinode->i_size = reloc->i_size;\n\t\t\tinode->i_blocks = reloc->i_blocks;\n\t\t\tinode->i_atime = reloc->i_atime;\n\t\t\tinode_set_ctime_to_ts(inode, inode_get_ctime(reloc));\n\t\t\tinode->i_mtime = reloc->i_mtime;\n\t\t\tiput(reloc);\n\t\t\tbreak;\n#ifdef CONFIG_ZISOFS\n\t\tcase SIG('Z', 'F'): {\n\t\t\tint algo;\n\n\t\t\tif (ISOFS_SB(inode->i_sb)->s_nocompress)\n\t\t\t\tbreak;\n\t\t\talgo = isonum_721(rr->u.ZF.algorithm);\n\t\t\tif (algo == SIG('p', 'z')) {\n\t\t\t\tint block_shift =\n\t\t\t\t\tisonum_711(&rr->u.ZF.parms[1]);\n\t\t\t\tif (block_shift > 17) {\n\t\t\t\t\tprintk(KERN_WARNING \"isofs: \"\n\t\t\t\t\t\t\"Can't handle ZF block \"\n\t\t\t\t\t\t\"size of 2^%d\\n\",\n\t\t\t\t\t\tblock_shift);\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tISOFS_I(inode)->i_file_format =\n\t\t\t\t\t\tisofs_file_compressed;\n\t\t\t\t\t \n\t\t\t\t\tISOFS_I(inode)->i_format_parm[0] =\n\t\t\t\t\t\tisonum_711(&rr->u.ZF.parms[0]);\n\t\t\t\t\tISOFS_I(inode)->i_format_parm[1] =\n\t\t\t\t\t\tisonum_711(&rr->u.ZF.parms[1]);\n\t\t\t\t\tinode->i_size =\n\t\t\t\t\t    isonum_733(rr->u.ZF.\n\t\t\t\t\t\t       real_size);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t       \"isofs: Unknown ZF compression \"\n\t\t\t\t\t\t\"algorithm: %c%c\\n\",\n\t\t\t\t       rr->u.ZF.algorithm[0],\n\t\t\t\t       rr->u.ZF.algorithm[1]);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tret = rock_continue(&rs);\n\tif (ret == 0)\n\t\tgoto repeat;\n\tif (ret == 1)\n\t\tret = 0;\nout:\n\tkfree(rs.buffer);\n\treturn ret;\neio:\n\tret = -EIO;\n\tgoto out;\n}\n\nstatic char *get_symlink_chunk(char *rpnt, struct rock_ridge *rr, char *plimit)\n{\n\tint slen;\n\tint rootflag;\n\tstruct SL_component *oldslp;\n\tstruct SL_component *slp;\n\tslen = rr->len - 5;\n\tslp = &rr->u.SL.link;\n\twhile (slen > 1) {\n\t\trootflag = 0;\n\t\tswitch (slp->flags & ~1) {\n\t\tcase 0:\n\t\t\tif (slp->len > plimit - rpnt)\n\t\t\t\treturn NULL;\n\t\t\tmemcpy(rpnt, slp->text, slp->len);\n\t\t\trpnt += slp->len;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (rpnt >= plimit)\n\t\t\t\treturn NULL;\n\t\t\t*rpnt++ = '.';\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tif (2 > plimit - rpnt)\n\t\t\t\treturn NULL;\n\t\t\t*rpnt++ = '.';\n\t\t\t*rpnt++ = '.';\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tif (rpnt >= plimit)\n\t\t\t\treturn NULL;\n\t\t\trootflag = 1;\n\t\t\t*rpnt++ = '/';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(\"Symlink component flag not implemented (%d)\\n\",\n\t\t\t       slp->flags);\n\t\t}\n\t\tslen -= slp->len + 2;\n\t\toldslp = slp;\n\t\tslp = (struct SL_component *)((char *)slp + slp->len + 2);\n\n\t\tif (slen < 2) {\n\t\t\t \n\t\t\tif ((!rootflag) && (rr->u.SL.flags & 1) &&\n\t\t\t    !(oldslp->flags & 1)) {\n\t\t\t\tif (rpnt >= plimit)\n\t\t\t\t\treturn NULL;\n\t\t\t\t*rpnt++ = '/';\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (!rootflag && !(oldslp->flags & 1)) {\n\t\t\tif (rpnt >= plimit)\n\t\t\t\treturn NULL;\n\t\t\t*rpnt++ = '/';\n\t\t}\n\t}\n\treturn rpnt;\n}\n\nint parse_rock_ridge_inode(struct iso_directory_record *de, struct inode *inode,\n\t\t\t   int relocated)\n{\n\tint flags = relocated ? RR_RELOC_DE : 0;\n\tint result = parse_rock_ridge_inode_internal(de, inode, flags);\n\n\t \n\tif ((ISOFS_SB(inode->i_sb)->s_rock_offset == -1)\n\t    && (ISOFS_SB(inode->i_sb)->s_rock == 2)) {\n\t\tresult = parse_rock_ridge_inode_internal(de, inode,\n\t\t\t\t\t\t\t flags | RR_REGARD_XA);\n\t}\n\treturn result;\n}\n\n \nstatic int rock_ridge_symlink_read_folio(struct file *file, struct folio *folio)\n{\n\tstruct page *page = &folio->page;\n\tstruct inode *inode = page->mapping->host;\n\tstruct iso_inode_info *ei = ISOFS_I(inode);\n\tstruct isofs_sb_info *sbi = ISOFS_SB(inode->i_sb);\n\tchar *link = page_address(page);\n\tunsigned long bufsize = ISOFS_BUFFER_SIZE(inode);\n\tstruct buffer_head *bh;\n\tchar *rpnt = link;\n\tunsigned char *pnt;\n\tstruct iso_directory_record *raw_de;\n\tunsigned long block, offset;\n\tint sig;\n\tstruct rock_ridge *rr;\n\tstruct rock_state rs;\n\tint ret;\n\n\tif (!sbi->s_rock)\n\t\tgoto error;\n\n\tinit_rock_state(&rs, inode);\n\tblock = ei->i_iget5_block;\n\tbh = sb_bread(inode->i_sb, block);\n\tif (!bh)\n\t\tgoto out_noread;\n\n\toffset = ei->i_iget5_offset;\n\tpnt = (unsigned char *)bh->b_data + offset;\n\n\traw_de = (struct iso_directory_record *)pnt;\n\n\t \n\tif (offset + *pnt > bufsize)\n\t\tgoto out_bad_span;\n\n\t \n\n\tsetup_rock_ridge(raw_de, inode, &rs);\n\nrepeat:\n\twhile (rs.len > 2) {  \n\t\trr = (struct rock_ridge *)rs.chr;\n\t\tif (rr->len < 3)\n\t\t\tgoto out;\t \n\t\tsig = isonum_721(rs.chr);\n\t\tif (rock_check_overflow(&rs, sig))\n\t\t\tgoto out;\n\t\trs.chr += rr->len;\n\t\trs.len -= rr->len;\n\t\tif (rs.len < 0)\n\t\t\tgoto out;\t \n\n\t\tswitch (sig) {\n\t\tcase SIG('R', 'R'):\n\t\t\tif ((rr->u.RR.flags[0] & RR_SL) == 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('S', 'P'):\n\t\t\tif (check_sp(rr, inode))\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('S', 'L'):\n\t\t\trpnt = get_symlink_chunk(rpnt, rr,\n\t\t\t\t\t\t link + (PAGE_SIZE - 1));\n\t\t\tif (rpnt == NULL)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('C', 'E'):\n\t\t\t \n\t\t\trs.cont_extent = isonum_733(rr->u.CE.extent);\n\t\t\trs.cont_offset = isonum_733(rr->u.CE.offset);\n\t\t\trs.cont_size = isonum_733(rr->u.CE.size);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tret = rock_continue(&rs);\n\tif (ret == 0)\n\t\tgoto repeat;\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tif (rpnt == link)\n\t\tgoto fail;\n\tbrelse(bh);\n\t*rpnt = '\\0';\n\tSetPageUptodate(page);\n\tunlock_page(page);\n\treturn 0;\n\n\t \nout:\n\tkfree(rs.buffer);\n\tgoto fail;\nout_noread:\n\tprintk(\"unable to read i-node block\");\n\tgoto fail;\nout_bad_span:\n\tprintk(\"symlink spans iso9660 blocks\\n\");\nfail:\n\tbrelse(bh);\nerror:\n\tSetPageError(page);\n\tunlock_page(page);\n\treturn -EIO;\n}\n\nconst struct address_space_operations isofs_symlink_aops = {\n\t.read_folio = rock_ridge_symlink_read_folio\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}