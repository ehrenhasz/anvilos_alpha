{
  "module_name": "dir.c",
  "hash_id": "ed330524f5f730f750b27aa17a0dc1c60ef7612e8db48bafeaf9fcf053b39415",
  "original_prompt": "Ingested from linux-6.6.14/fs/isofs/dir.c",
  "human_readable_source": "\n \n#include <linux/gfp.h>\n#include \"isofs.h\"\n\nint isofs_name_translate(struct iso_directory_record *de, char *new, struct inode *inode)\n{\n\tchar * old = de->name;\n\tint len = de->name_len[0];\n\tint i;\n\n\tfor (i = 0; i < len; i++) {\n\t\tunsigned char c = old[i];\n\t\tif (!c)\n\t\t\tbreak;\n\n\t\tif (c >= 'A' && c <= 'Z')\n\t\t\tc |= 0x20;\t \n\n\t\t \n\t\tif (c == '.' && i == len - 3 && old[i + 1] == ';' && old[i + 2] == '1')\n\t\t\tbreak;\n\n\t\t \n\t\tif (c == ';' && i == len - 2 && old[i + 1] == '1')\n\t\t\tbreak;\n\n\t\t \n\t\t \n\t\tif (c == ';' || c == '/')\n\t\t\tc = '.';\n\n\t\tnew[i] = c;\n\t}\n\treturn i;\n}\n\n \nint get_acorn_filename(struct iso_directory_record *de,\n\t\t\t    char *retname, struct inode *inode)\n{\n\tint std;\n\tunsigned char *chr;\n\tint retnamlen = isofs_name_translate(de, retname, inode);\n\n\tif (retnamlen == 0)\n\t\treturn 0;\n\tstd = sizeof(struct iso_directory_record) + de->name_len[0];\n\tif (std & 1)\n\t\tstd++;\n\tif (de->length[0] - std != 32)\n\t\treturn retnamlen;\n\tchr = ((unsigned char *) de) + std;\n\tif (strncmp(chr, \"ARCHIMEDES\", 10))\n\t\treturn retnamlen;\n\tif ((*retname == '_') && ((chr[19] & 1) == 1))\n\t\t*retname = '!';\n\tif (((de->flags[0] & 2) == 0) && (chr[13] == 0xff)\n\t\t&& ((chr[12] & 0xf0) == 0xf0)) {\n\t\tretname[retnamlen] = ',';\n\t\tsprintf(retname+retnamlen+1, \"%3.3x\",\n\t\t\t((chr[12] & 0xf) << 8) | chr[11]);\n\t\tretnamlen += 4;\n\t}\n\treturn retnamlen;\n}\n\n \nstatic int do_isofs_readdir(struct inode *inode, struct file *file,\n\t\tstruct dir_context *ctx,\n\t\tchar *tmpname, struct iso_directory_record *tmpde)\n{\n\tunsigned long bufsize = ISOFS_BUFFER_SIZE(inode);\n\tunsigned char bufbits = ISOFS_BUFFER_BITS(inode);\n\tunsigned long block, offset, block_saved, offset_saved;\n\tunsigned long inode_number = 0;\t \n\tstruct buffer_head *bh = NULL;\n\tint len;\n\tint map;\n\tint first_de = 1;\n\tchar *p = NULL;\t\t \n\tstruct iso_directory_record *de;\n\tstruct isofs_sb_info *sbi = ISOFS_SB(inode->i_sb);\n\n\toffset = ctx->pos & (bufsize - 1);\n\tblock = ctx->pos >> bufbits;\n\n\twhile (ctx->pos < inode->i_size) {\n\t\tint de_len;\n\n\t\tif (!bh) {\n\t\t\tbh = isofs_bread(inode, block);\n\t\t\tif (!bh)\n\t\t\t\treturn 0;\n\t\t}\n\n\t\tde = (struct iso_directory_record *) (bh->b_data + offset);\n\n\t\tde_len = *(unsigned char *)de;\n\n\t\t \n\n\t\tif (de_len == 0) {\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t\tctx->pos = (ctx->pos + ISOFS_BLOCK_SIZE) & ~(ISOFS_BLOCK_SIZE - 1);\n\t\t\tblock = ctx->pos >> bufbits;\n\t\t\toffset = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tblock_saved = block;\n\t\toffset_saved = offset;\n\t\toffset += de_len;\n\n\t\t \n\t\tif (offset >= bufsize) {\n\t\t\tint slop = bufsize - offset + de_len;\n\t\t\tmemcpy(tmpde, de, slop);\n\t\t\toffset &= bufsize - 1;\n\t\t\tblock++;\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t\tif (offset) {\n\t\t\t\tbh = isofs_bread(inode, block);\n\t\t\t\tif (!bh)\n\t\t\t\t\treturn 0;\n\t\t\t\tmemcpy((void *) tmpde + slop, bh->b_data, offset);\n\t\t\t}\n\t\t\tde = tmpde;\n\t\t}\n\t\t \n\t\tif (de_len < de->name_len[0] +\n\t\t\t\t\tsizeof(struct iso_directory_record)) {\n\t\t\tprintk(KERN_NOTICE \"iso9660: Corrupted directory entry\"\n\t\t\t       \" in block %lu of inode %lu\\n\", block,\n\t\t\t       inode->i_ino);\n\t\t\tbrelse(bh);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (first_de) {\n\t\t\tisofs_normalize_block_and_offset(de,\n\t\t\t\t\t\t\t&block_saved,\n\t\t\t\t\t\t\t&offset_saved);\n\t\t\tinode_number = isofs_get_ino(block_saved,\n\t\t\t\t\t\t\toffset_saved, bufbits);\n\t\t}\n\n\t\tif (de->flags[-sbi->s_high_sierra] & 0x80) {\n\t\t\tfirst_de = 0;\n\t\t\tctx->pos += de_len;\n\t\t\tcontinue;\n\t\t}\n\t\tfirst_de = 1;\n\n\t\t \n\t\tif (de->name_len[0] == 1 && de->name[0] == 0) {\n\t\t\tif (!dir_emit_dot(file, ctx))\n\t\t\t\tbreak;\n\t\t\tctx->pos += de_len;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlen = 0;\n\n\t\t \n\t\tif (de->name_len[0] == 1 && de->name[0] == 1) {\n\t\t\tif (!dir_emit_dotdot(file, ctx))\n\t\t\t\tbreak;\n\t\t\tctx->pos += de_len;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\n\t\t \n\t\tif ((sbi->s_hide && (de->flags[-sbi->s_high_sierra] & 1)) ||\n\t\t    (!sbi->s_showassoc &&\n\t\t\t\t(de->flags[-sbi->s_high_sierra] & 4))) {\n\t\t\tctx->pos += de_len;\n\t\t\tcontinue;\n\t\t}\n\n\t\tmap = 1;\n\t\tif (sbi->s_rock) {\n\t\t\tlen = get_rock_ridge_filename(de, tmpname, inode);\n\t\t\tif (len != 0) {\t\t \n\t\t\t\tp = tmpname;\n\t\t\t\tmap = 0;\n\t\t\t}\n\t\t}\n\t\tif (map) {\n#ifdef CONFIG_JOLIET\n\t\t\tif (sbi->s_joliet_level) {\n\t\t\t\tlen = get_joliet_filename(de, tmpname, inode);\n\t\t\t\tp = tmpname;\n\t\t\t} else\n#endif\n\t\t\tif (sbi->s_mapping == 'a') {\n\t\t\t\tlen = get_acorn_filename(de, tmpname, inode);\n\t\t\t\tp = tmpname;\n\t\t\t} else\n\t\t\tif (sbi->s_mapping == 'n') {\n\t\t\t\tlen = isofs_name_translate(de, tmpname, inode);\n\t\t\t\tp = tmpname;\n\t\t\t} else {\n\t\t\t\tp = de->name;\n\t\t\t\tlen = de->name_len[0];\n\t\t\t}\n\t\t}\n\t\tif (len > 0) {\n\t\t\tif (!dir_emit(ctx, p, len, inode_number, DT_UNKNOWN))\n\t\t\t\tbreak;\n\t\t}\n\t\tctx->pos += de_len;\n\t}\n\tif (bh)\n\t\tbrelse(bh);\n\treturn 0;\n}\n\n \nstatic int isofs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tint result;\n\tchar *tmpname;\n\tstruct iso_directory_record *tmpde;\n\tstruct inode *inode = file_inode(file);\n\n\ttmpname = (char *)__get_free_page(GFP_KERNEL);\n\tif (tmpname == NULL)\n\t\treturn -ENOMEM;\n\n\ttmpde = (struct iso_directory_record *) (tmpname+1024);\n\n\tresult = do_isofs_readdir(inode, file, ctx, tmpname, tmpde);\n\n\tfree_page((unsigned long) tmpname);\n\treturn result;\n}\n\nconst struct file_operations isofs_dir_operations =\n{\n\t.llseek = generic_file_llseek,\n\t.read = generic_read_dir,\n\t.iterate_shared = isofs_readdir,\n};\n\n \nconst struct inode_operations isofs_dir_inode_operations =\n{\n\t.lookup = isofs_lookup,\n};\n\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}