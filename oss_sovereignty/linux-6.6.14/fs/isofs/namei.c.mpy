{
  "module_name": "namei.c",
  "hash_id": "749208d3d5cf66613134259c1085148cbe87560dd1b7c302c93477ed85fa4909",
  "original_prompt": "Ingested from linux-6.6.14/fs/isofs/namei.c",
  "human_readable_source": "\n \n\n#include <linux/gfp.h>\n#include \"isofs.h\"\n\n \nstatic int\nisofs_cmp(struct dentry *dentry, const char *compare, int dlen)\n{\n\tstruct qstr qstr;\n\tqstr.name = compare;\n\tqstr.len = dlen;\n\tif (likely(!dentry->d_op))\n\t\treturn dentry->d_name.len != dlen || memcmp(dentry->d_name.name, compare, dlen);\n\treturn dentry->d_op->d_compare(NULL, dentry->d_name.len, dentry->d_name.name, &qstr);\n}\n\n \nstatic unsigned long\nisofs_find_entry(struct inode *dir, struct dentry *dentry,\n\tunsigned long *block_rv, unsigned long *offset_rv,\n\tchar *tmpname, struct iso_directory_record *tmpde)\n{\n\tunsigned long bufsize = ISOFS_BUFFER_SIZE(dir);\n\tunsigned char bufbits = ISOFS_BUFFER_BITS(dir);\n\tunsigned long block, f_pos, offset, block_saved, offset_saved;\n\tstruct buffer_head *bh = NULL;\n\tstruct isofs_sb_info *sbi = ISOFS_SB(dir->i_sb);\n\n\tif (!ISOFS_I(dir)->i_first_extent)\n\t\treturn 0;\n\n\tf_pos = 0;\n\toffset = 0;\n\tblock = 0;\n\n\twhile (f_pos < dir->i_size) {\n\t\tstruct iso_directory_record *de;\n\t\tint de_len, match, i, dlen;\n\t\tchar *dpnt;\n\n\t\tif (!bh) {\n\t\t\tbh = isofs_bread(dir, block);\n\t\t\tif (!bh)\n\t\t\t\treturn 0;\n\t\t}\n\n\t\tde = (struct iso_directory_record *) (bh->b_data + offset);\n\n\t\tde_len = *(unsigned char *) de;\n\t\tif (!de_len) {\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t\tf_pos = (f_pos + ISOFS_BLOCK_SIZE) & ~(ISOFS_BLOCK_SIZE - 1);\n\t\t\tblock = f_pos >> bufbits;\n\t\t\toffset = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tblock_saved = bh->b_blocknr;\n\t\toffset_saved = offset;\n\t\toffset += de_len;\n\t\tf_pos += de_len;\n\n\t\t \n\t\tif (offset >= bufsize) {\n\t\t\tint slop = bufsize - offset + de_len;\n\t\t\tmemcpy(tmpde, de, slop);\n\t\t\toffset &= bufsize - 1;\n\t\t\tblock++;\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t\tif (offset) {\n\t\t\t\tbh = isofs_bread(dir, block);\n\t\t\t\tif (!bh)\n\t\t\t\t\treturn 0;\n\t\t\t\tmemcpy((void *) tmpde + slop, bh->b_data, offset);\n\t\t\t}\n\t\t\tde = tmpde;\n\t\t}\n\n\t\tdlen = de->name_len[0];\n\t\tdpnt = de->name;\n\t\t \n\t\tif (de_len < dlen + sizeof(struct iso_directory_record)) {\n\t\t\tprintk(KERN_NOTICE \"iso9660: Corrupted directory entry\"\n\t\t\t       \" in block %lu of inode %lu\\n\", block,\n\t\t\t       dir->i_ino);\n\t\t\tbrelse(bh);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (sbi->s_rock &&\n\t\t    ((i = get_rock_ridge_filename(de, tmpname, dir)))) {\n\t\t\tdlen = i;\t \n\t\t\tdpnt = tmpname;\n#ifdef CONFIG_JOLIET\n\t\t} else if (sbi->s_joliet_level) {\n\t\t\tdlen = get_joliet_filename(de, tmpname, dir);\n\t\t\tdpnt = tmpname;\n#endif\n\t\t} else if (sbi->s_mapping == 'a') {\n\t\t\tdlen = get_acorn_filename(de, tmpname, dir);\n\t\t\tdpnt = tmpname;\n\t\t} else if (sbi->s_mapping == 'n') {\n\t\t\tdlen = isofs_name_translate(de, tmpname, dir);\n\t\t\tdpnt = tmpname;\n\t\t}\n\n\t\t \n\t\tmatch = 0;\n\t\tif (dlen > 0 &&\n\t\t\t(!sbi->s_hide ||\n\t\t\t\t(!(de->flags[-sbi->s_high_sierra] & 1))) &&\n\t\t\t(sbi->s_showassoc ||\n\t\t\t\t(!(de->flags[-sbi->s_high_sierra] & 4)))) {\n\t\t\tif (dpnt && (dlen > 1 || dpnt[0] > 1))\n\t\t\t\tmatch = (isofs_cmp(dentry, dpnt, dlen) == 0);\n\t\t}\n\t\tif (match) {\n\t\t\tisofs_normalize_block_and_offset(de,\n\t\t\t\t\t\t\t &block_saved,\n\t\t\t\t\t\t\t &offset_saved);\n\t\t\t*block_rv = block_saved;\n\t\t\t*offset_rv = offset_saved;\n\t\t\tbrelse(bh);\n\t\t\treturn 1;\n\t\t}\n\t}\n\tbrelse(bh);\n\treturn 0;\n}\n\nstruct dentry *isofs_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags)\n{\n\tint found;\n\tunsigned long block;\n\tunsigned long offset;\n\tstruct inode *inode;\n\tstruct page *page;\n\n\tpage = alloc_page(GFP_USER);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfound = isofs_find_entry(dir, dentry,\n\t\t\t\t&block, &offset,\n\t\t\t\tpage_address(page),\n\t\t\t\t1024 + page_address(page));\n\t__free_page(page);\n\n\tinode = found ? isofs_iget(dir->i_sb, block, offset) : NULL;\n\n\treturn d_splice_alias(inode, dentry);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}