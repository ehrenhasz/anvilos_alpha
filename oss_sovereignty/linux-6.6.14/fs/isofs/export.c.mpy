{
  "module_name": "export.c",
  "hash_id": "4dd1bdf2f5b72248de6c2bd2d1bf878a9bab807e34679982f69f6e14d104cff2",
  "original_prompt": "Ingested from linux-6.6.14/fs/isofs/export.c",
  "human_readable_source": "\n \n\n#include \"isofs.h\"\n\nstatic struct dentry *\nisofs_export_iget(struct super_block *sb,\n\t\t  unsigned long block,\n\t\t  unsigned long offset,\n\t\t  __u32 generation)\n{\n\tstruct inode *inode;\n\n\tif (block == 0)\n\t\treturn ERR_PTR(-ESTALE);\n\tinode = isofs_iget(sb, block, offset);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\tif (generation && inode->i_generation != generation) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ESTALE);\n\t}\n\treturn d_obtain_alias(inode);\n}\n\n \nstatic struct dentry *isofs_export_get_parent(struct dentry *child)\n{\n\tunsigned long parent_block = 0;\n\tunsigned long parent_offset = 0;\n\tstruct inode *child_inode = d_inode(child);\n\tstruct iso_inode_info *e_child_inode = ISOFS_I(child_inode);\n\tstruct iso_directory_record *de = NULL;\n\tstruct buffer_head * bh = NULL;\n\tstruct dentry *rv = NULL;\n\n\t \n\tif (!S_ISDIR(child_inode->i_mode)) {\n\t\tprintk(KERN_ERR \"isofs: isofs_export_get_parent(): \"\n\t\t       \"child is not a directory!\\n\");\n\t\trv = ERR_PTR(-EACCES);\n\t\tgoto out;\n\t}\n\n\t \n\tif (e_child_inode->i_iget5_offset != 0) {\n\t\tprintk(KERN_ERR \"isofs: isofs_export_get_parent(): \"\n\t\t       \"child directory not normalized!\\n\");\n\t\trv = ERR_PTR(-EACCES);\n\t\tgoto out;\n\t}\n\n\t \n\tparent_block = e_child_inode->i_iget5_block;\n\n\t \n\tbh = sb_bread(child_inode->i_sb, parent_block);\n\tif (bh == NULL) {\n\t\trv = ERR_PTR(-EACCES);\n\t\tgoto out;\n\t}\n\n\t \n\tde = (struct iso_directory_record*)bh->b_data;\n\n\t \n\tparent_offset = (unsigned long)isonum_711(de->length);\n\tde = (struct iso_directory_record*)(bh->b_data + parent_offset);\n\n\t \n\tif ((isonum_711(de->name_len) != 1) || (de->name[0] != 1)) {\n\t\tprintk(KERN_ERR \"isofs: Unable to find the \\\"..\\\" \"\n\t\t       \"directory for NFS.\\n\");\n\t\trv = ERR_PTR(-EACCES);\n\t\tgoto out;\n\t}\n\n\t \n\tisofs_normalize_block_and_offset(de, &parent_block, &parent_offset);\n\n\trv = d_obtain_alias(isofs_iget(child_inode->i_sb, parent_block,\n\t\t\t\t     parent_offset));\n out:\n\tif (bh)\n\t\tbrelse(bh);\n\treturn rv;\n}\n\nstatic int\nisofs_export_encode_fh(struct inode *inode,\n\t\t       __u32 *fh32,\n\t\t       int *max_len,\n\t\t       struct inode *parent)\n{\n\tstruct iso_inode_info * ei = ISOFS_I(inode);\n\tint len = *max_len;\n\tint type = 1;\n\t__u16 *fh16 = (__u16*)fh32;\n\n\t \n\tif (parent && (len < 5)) {\n\t\t*max_len = 5;\n\t\treturn FILEID_INVALID;\n\t} else if (len < 3) {\n\t\t*max_len = 3;\n\t\treturn FILEID_INVALID;\n\t}\n\n\tlen = 3;\n\tfh32[0] = ei->i_iget5_block;\n \tfh16[2] = (__u16)ei->i_iget5_offset;   \n\tfh16[3] = 0;   \n\tfh32[2] = inode->i_generation;\n\tif (parent) {\n\t\tstruct iso_inode_info *eparent;\n\t\teparent = ISOFS_I(parent);\n\t\tfh32[3] = eparent->i_iget5_block;\n\t\tfh16[3] = (__u16)eparent->i_iget5_offset;   \n\t\tfh32[4] = parent->i_generation;\n\t\tlen = 5;\n\t\ttype = 2;\n\t}\n\t*max_len = len;\n\treturn type;\n}\n\nstruct isofs_fid {\n\tu32 block;\n\tu16 offset;\n\tu16 parent_offset;\n\tu32 generation;\n\tu32 parent_block;\n\tu32 parent_generation;\n};\n\nstatic struct dentry *isofs_fh_to_dentry(struct super_block *sb,\n\tstruct fid *fid, int fh_len, int fh_type)\n{\n\tstruct isofs_fid *ifid = (struct isofs_fid *)fid;\n\n\tif (fh_len < 3 || fh_type > 2)\n\t\treturn NULL;\n\n\treturn isofs_export_iget(sb, ifid->block, ifid->offset,\n\t\t\tifid->generation);\n}\n\nstatic struct dentry *isofs_fh_to_parent(struct super_block *sb,\n\t\tstruct fid *fid, int fh_len, int fh_type)\n{\n\tstruct isofs_fid *ifid = (struct isofs_fid *)fid;\n\n\tif (fh_len < 2 || fh_type != 2)\n\t\treturn NULL;\n\n\treturn isofs_export_iget(sb,\n\t\t\tfh_len > 2 ? ifid->parent_block : 0,\n\t\t\tifid->parent_offset,\n\t\t\tfh_len > 4 ? ifid->parent_generation : 0);\n}\n\nconst struct export_operations isofs_export_ops = {\n\t.encode_fh\t= isofs_export_encode_fh,\n\t.fh_to_dentry\t= isofs_fh_to_dentry,\n\t.fh_to_parent\t= isofs_fh_to_parent,\n\t.get_parent     = isofs_export_get_parent,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}