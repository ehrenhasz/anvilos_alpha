{
  "module_name": "compress.c",
  "hash_id": "22b480e78dba7f21077d039948548b741110a17df6e7e6bc000a5377babbf3f2",
  "original_prompt": "Ingested from linux-6.6.14/fs/isofs/compress.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/bio.h>\n\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/zlib.h>\n\n#include \"isofs.h\"\n#include \"zisofs.h\"\n\n \nstatic char zisofs_sink_page[PAGE_SIZE];\n\n \nstatic void *zisofs_zlib_workspace;\nstatic DEFINE_MUTEX(zisofs_zlib_lock);\n\n \nstatic loff_t zisofs_uncompress_block(struct inode *inode, loff_t block_start,\n\t\t\t\t      loff_t block_end, int pcount,\n\t\t\t\t      struct page **pages, unsigned poffset,\n\t\t\t\t      int *errp)\n{\n\tunsigned int zisofs_block_shift = ISOFS_I(inode)->i_format_parm[1];\n\tunsigned int bufsize = ISOFS_BUFFER_SIZE(inode);\n\tunsigned int bufshift = ISOFS_BUFFER_BITS(inode);\n\tunsigned int bufmask = bufsize - 1;\n\tint i, block_size = block_end - block_start;\n\tz_stream stream = { .total_out = 0,\n\t\t\t    .avail_in = 0,\n\t\t\t    .avail_out = 0, };\n\tint zerr;\n\tint needblocks = (block_size + (block_start & bufmask) + bufmask)\n\t\t\t\t>> bufshift;\n\tint haveblocks;\n\tblkcnt_t blocknum;\n\tstruct buffer_head **bhs;\n\tint curbh, curpage;\n\n\tif (block_size > deflateBound(1UL << zisofs_block_shift)) {\n\t\t*errp = -EIO;\n\t\treturn 0;\n\t}\n\t \n\tif (block_size == 0) {\n\t\tfor ( i = 0 ; i < pcount ; i++ ) {\n\t\t\tif (!pages[i])\n\t\t\t\tcontinue;\n\t\t\tmemzero_page(pages[i], 0, PAGE_SIZE);\n\t\t\tSetPageUptodate(pages[i]);\n\t\t}\n\t\treturn ((loff_t)pcount) << PAGE_SHIFT;\n\t}\n\n\t \n\tblocknum = block_start >> bufshift;\n\tbhs = kcalloc(needblocks + 1, sizeof(*bhs), GFP_KERNEL);\n\tif (!bhs) {\n\t\t*errp = -ENOMEM;\n\t\treturn 0;\n\t}\n\thaveblocks = isofs_get_blocks(inode, blocknum, bhs, needblocks);\n\tbh_read_batch(haveblocks, bhs);\n\n\tcurbh = 0;\n\tcurpage = 0;\n\t \n\n\tif (!bhs[0])\n\t\tgoto b_eio;\n\n\twait_on_buffer(bhs[0]);\n\tif (!buffer_uptodate(bhs[0])) {\n\t\t*errp = -EIO;\n\t\tgoto b_eio;\n\t}\n\n\tstream.workspace = zisofs_zlib_workspace;\n\tmutex_lock(&zisofs_zlib_lock);\n\t\t\n\tzerr = zlib_inflateInit(&stream);\n\tif (zerr != Z_OK) {\n\t\tif (zerr == Z_MEM_ERROR)\n\t\t\t*errp = -ENOMEM;\n\t\telse\n\t\t\t*errp = -EIO;\n\t\tprintk(KERN_DEBUG \"zisofs: zisofs_inflateInit returned %d\\n\",\n\t\t\t       zerr);\n\t\tgoto z_eio;\n\t}\n\n\twhile (curpage < pcount && curbh < haveblocks &&\n\t       zerr != Z_STREAM_END) {\n\t\tif (!stream.avail_out) {\n\t\t\tif (pages[curpage]) {\n\t\t\t\tstream.next_out = kmap_local_page(pages[curpage])\n\t\t\t\t\t\t+ poffset;\n\t\t\t\tstream.avail_out = PAGE_SIZE - poffset;\n\t\t\t\tpoffset = 0;\n\t\t\t} else {\n\t\t\t\tstream.next_out = (void *)&zisofs_sink_page;\n\t\t\t\tstream.avail_out = PAGE_SIZE;\n\t\t\t}\n\t\t}\n\t\tif (!stream.avail_in) {\n\t\t\twait_on_buffer(bhs[curbh]);\n\t\t\tif (!buffer_uptodate(bhs[curbh])) {\n\t\t\t\t*errp = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstream.next_in  = bhs[curbh]->b_data +\n\t\t\t\t\t\t(block_start & bufmask);\n\t\t\tstream.avail_in = min_t(unsigned, bufsize -\n\t\t\t\t\t\t(block_start & bufmask),\n\t\t\t\t\t\tblock_size);\n\t\t\tblock_size -= stream.avail_in;\n\t\t\tblock_start = 0;\n\t\t}\n\n\t\twhile (stream.avail_out && stream.avail_in) {\n\t\t\tzerr = zlib_inflate(&stream, Z_SYNC_FLUSH);\n\t\t\tif (zerr == Z_BUF_ERROR && stream.avail_in == 0)\n\t\t\t\tbreak;\n\t\t\tif (zerr == Z_STREAM_END)\n\t\t\t\tbreak;\n\t\t\tif (zerr != Z_OK) {\n\t\t\t\t \n\t\t\t\tif (zerr == Z_MEM_ERROR)\n\t\t\t\t\t*errp = -ENOMEM;\n\t\t\t\telse {\n\t\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\t       \"zisofs: zisofs_inflate returned\"\n\t\t\t\t\t       \" %d, inode = %lu,\"\n\t\t\t\t\t       \" page idx = %d, bh idx = %d,\"\n\t\t\t\t\t       \" avail_in = %ld,\"\n\t\t\t\t\t       \" avail_out = %ld\\n\",\n\t\t\t\t\t       zerr, inode->i_ino, curpage,\n\t\t\t\t\t       curbh, stream.avail_in,\n\t\t\t\t\t       stream.avail_out);\n\t\t\t\t\t*errp = -EIO;\n\t\t\t\t}\n\t\t\t\tgoto inflate_out;\n\t\t\t}\n\t\t}\n\n\t\tif (!stream.avail_out) {\n\t\t\t \n\t\t\tif (pages[curpage]) {\n\t\t\t\tflush_dcache_page(pages[curpage]);\n\t\t\t\tSetPageUptodate(pages[curpage]);\n\t\t\t}\n\t\t\tif (stream.next_out != (unsigned char *)zisofs_sink_page) {\n\t\t\t\tkunmap_local(stream.next_out);\n\t\t\t\tstream.next_out = NULL;\n\t\t\t}\n\t\t\tcurpage++;\n\t\t}\n\t\tif (!stream.avail_in)\n\t\t\tcurbh++;\n\t}\ninflate_out:\n\tzlib_inflateEnd(&stream);\n\tif (stream.next_out && stream.next_out != (unsigned char *)zisofs_sink_page)\n\t\tkunmap_local(stream.next_out);\n\nz_eio:\n\tmutex_unlock(&zisofs_zlib_lock);\n\nb_eio:\n\tfor (i = 0; i < haveblocks; i++)\n\t\tbrelse(bhs[i]);\n\tkfree(bhs);\n\treturn stream.total_out;\n}\n\n \nstatic int zisofs_fill_pages(struct inode *inode, int full_page, int pcount,\n\t\t\t     struct page **pages)\n{\n\tloff_t start_off, end_off;\n\tloff_t block_start, block_end;\n\tunsigned int header_size = ISOFS_I(inode)->i_format_parm[0];\n\tunsigned int zisofs_block_shift = ISOFS_I(inode)->i_format_parm[1];\n\tunsigned int blockptr;\n\tloff_t poffset = 0;\n\tblkcnt_t cstart_block, cend_block;\n\tstruct buffer_head *bh;\n\tunsigned int blkbits = ISOFS_BUFFER_BITS(inode);\n\tunsigned int blksize = 1 << blkbits;\n\tint err;\n\tloff_t ret;\n\n\tBUG_ON(!pages[full_page]);\n\n\t \n\tstart_off = page_offset(pages[full_page]);\n\tend_off = min_t(loff_t, start_off + PAGE_SIZE, inode->i_size);\n\n\tcstart_block = start_off >> zisofs_block_shift;\n\tcend_block = (end_off + (1 << zisofs_block_shift) - 1)\n\t\t\t>> zisofs_block_shift;\n\n\tWARN_ON(start_off - (full_page << PAGE_SHIFT) !=\n\t\t((cstart_block << zisofs_block_shift) & PAGE_MASK));\n\n\t \n\t \n\t \n\tblockptr = (header_size + cstart_block) << 2;\n\tbh = isofs_bread(inode, blockptr >> blkbits);\n\tif (!bh)\n\t\treturn -EIO;\n\tblock_start = le32_to_cpu(*(__le32 *)\n\t\t\t\t(bh->b_data + (blockptr & (blksize - 1))));\n\n\twhile (cstart_block < cend_block && pcount > 0) {\n\t\t \n\t\tblockptr += 4;\n\t\t \n\t\tif (!(blockptr & (blksize - 1))) {\n\t\t\tbrelse(bh);\n\n\t\t\tbh = isofs_bread(inode, blockptr >> blkbits);\n\t\t\tif (!bh)\n\t\t\t\treturn -EIO;\n\t\t}\n\t\tblock_end = le32_to_cpu(*(__le32 *)\n\t\t\t\t(bh->b_data + (blockptr & (blksize - 1))));\n\t\tif (block_start > block_end) {\n\t\t\tbrelse(bh);\n\t\t\treturn -EIO;\n\t\t}\n\t\terr = 0;\n\t\tret = zisofs_uncompress_block(inode, block_start, block_end,\n\t\t\t\t\t      pcount, pages, poffset, &err);\n\t\tpoffset += ret;\n\t\tpages += poffset >> PAGE_SHIFT;\n\t\tpcount -= poffset >> PAGE_SHIFT;\n\t\tfull_page -= poffset >> PAGE_SHIFT;\n\t\tpoffset &= ~PAGE_MASK;\n\n\t\tif (err) {\n\t\t\tbrelse(bh);\n\t\t\t \n\t\t\tif (full_page < 0)\n\t\t\t\treturn 0;\n\t\t\treturn err;\n\t\t}\n\n\t\tblock_start = block_end;\n\t\tcstart_block++;\n\t}\n\n\tif (poffset && *pages) {\n\t\tmemzero_page(*pages, poffset, PAGE_SIZE - poffset);\n\t\tSetPageUptodate(*pages);\n\t}\n\treturn 0;\n}\n\n \nstatic int zisofs_read_folio(struct file *file, struct folio *folio)\n{\n\tstruct page *page = &folio->page;\n\tstruct inode *inode = file_inode(file);\n\tstruct address_space *mapping = inode->i_mapping;\n\tint err;\n\tint i, pcount, full_page;\n\tunsigned int zisofs_block_shift = ISOFS_I(inode)->i_format_parm[1];\n\tunsigned int zisofs_pages_per_cblock =\n\t\tPAGE_SHIFT <= zisofs_block_shift ?\n\t\t(1 << (zisofs_block_shift - PAGE_SHIFT)) : 0;\n\tstruct page **pages;\n\tpgoff_t index = page->index, end_index;\n\n\tend_index = (inode->i_size + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t \n\tif (index >= end_index) {\n\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\tif (PAGE_SHIFT <= zisofs_block_shift) {\n\t\t \n\t\tfull_page = index & (zisofs_pages_per_cblock - 1);\n\t\tpcount = min_t(int, zisofs_pages_per_cblock,\n\t\t\tend_index - (index & ~(zisofs_pages_per_cblock - 1)));\n\t\tindex -= full_page;\n\t} else {\n\t\tfull_page = 0;\n\t\tpcount = 1;\n\t}\n\tpages = kcalloc(max_t(unsigned int, zisofs_pages_per_cblock, 1),\n\t\t\t\t\tsizeof(*pages), GFP_KERNEL);\n\tif (!pages) {\n\t\tunlock_page(page);\n\t\treturn -ENOMEM;\n\t}\n\tpages[full_page] = page;\n\n\tfor (i = 0; i < pcount; i++, index++) {\n\t\tif (i != full_page)\n\t\t\tpages[i] = grab_cache_page_nowait(mapping, index);\n\t\tif (pages[i])\n\t\t\tClearPageError(pages[i]);\n\t}\n\n\terr = zisofs_fill_pages(inode, full_page, pcount, pages);\n\n\t \n\tfor (i = 0; i < pcount; i++) {\n\t\tif (pages[i]) {\n\t\t\tflush_dcache_page(pages[i]);\n\t\t\tif (i == full_page && err)\n\t\t\t\tSetPageError(pages[i]);\n\t\t\tunlock_page(pages[i]);\n\t\t\tif (i != full_page)\n\t\t\t\tput_page(pages[i]);\n\t\t}\n\t}\t\t\t\n\n\t \n\tkfree(pages);\n\treturn err;\n}\n\nconst struct address_space_operations zisofs_aops = {\n\t.read_folio = zisofs_read_folio,\n\t \n};\n\nint __init zisofs_init(void)\n{\n\tzisofs_zlib_workspace = vmalloc(zlib_inflate_workspacesize());\n\tif ( !zisofs_zlib_workspace )\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nvoid zisofs_cleanup(void)\n{\n\tvfree(zisofs_zlib_workspace);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}