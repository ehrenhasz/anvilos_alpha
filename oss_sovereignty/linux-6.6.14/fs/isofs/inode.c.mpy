{
  "module_name": "inode.c",
  "hash_id": "c0fed5735d7b806f512042f681d83f9823b0a8b2eb42150e8801c68499674f01",
  "original_prompt": "Ingested from linux-6.6.14/fs/isofs/inode.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/nls.h>\n#include <linux/ctype.h>\n#include <linux/statfs.h>\n#include <linux/cdrom.h>\n#include <linux/parser.h>\n#include <linux/mpage.h>\n#include <linux/user_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/blkdev.h>\n\n#include \"isofs.h\"\n#include \"zisofs.h\"\n\n \n#define MAX_TZ_OFFSET (52*15*60)\n\n#define BEQUIET\n\nstatic int isofs_hashi(const struct dentry *parent, struct qstr *qstr);\nstatic int isofs_dentry_cmpi(const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);\n\n#ifdef CONFIG_JOLIET\nstatic int isofs_hashi_ms(const struct dentry *parent, struct qstr *qstr);\nstatic int isofs_hash_ms(const struct dentry *parent, struct qstr *qstr);\nstatic int isofs_dentry_cmpi_ms(const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);\nstatic int isofs_dentry_cmp_ms(const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);\n#endif\n\nstatic void isofs_put_super(struct super_block *sb)\n{\n\tstruct isofs_sb_info *sbi = ISOFS_SB(sb);\n\n#ifdef CONFIG_JOLIET\n\tunload_nls(sbi->s_nls_iocharset);\n#endif\n\n\tkfree(sbi);\n\tsb->s_fs_info = NULL;\n\treturn;\n}\n\nstatic int isofs_read_inode(struct inode *, int relocated);\nstatic int isofs_statfs (struct dentry *, struct kstatfs *);\nstatic int isofs_show_options(struct seq_file *, struct dentry *);\n\nstatic struct kmem_cache *isofs_inode_cachep;\n\nstatic struct inode *isofs_alloc_inode(struct super_block *sb)\n{\n\tstruct iso_inode_info *ei;\n\tei = alloc_inode_sb(sb, isofs_inode_cachep, GFP_KERNEL);\n\tif (!ei)\n\t\treturn NULL;\n\treturn &ei->vfs_inode;\n}\n\nstatic void isofs_free_inode(struct inode *inode)\n{\n\tkmem_cache_free(isofs_inode_cachep, ISOFS_I(inode));\n}\n\nstatic void init_once(void *foo)\n{\n\tstruct iso_inode_info *ei = foo;\n\n\tinode_init_once(&ei->vfs_inode);\n}\n\nstatic int __init init_inodecache(void)\n{\n\tisofs_inode_cachep = kmem_cache_create(\"isofs_inode_cache\",\n\t\t\t\t\tsizeof(struct iso_inode_info),\n\t\t\t\t\t0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\tSLAB_MEM_SPREAD|SLAB_ACCOUNT),\n\t\t\t\t\tinit_once);\n\tif (!isofs_inode_cachep)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic void destroy_inodecache(void)\n{\n\t \n\trcu_barrier();\n\tkmem_cache_destroy(isofs_inode_cachep);\n}\n\nstatic int isofs_remount(struct super_block *sb, int *flags, char *data)\n{\n\tsync_filesystem(sb);\n\tif (!(*flags & SB_RDONLY))\n\t\treturn -EROFS;\n\treturn 0;\n}\n\nstatic const struct super_operations isofs_sops = {\n\t.alloc_inode\t= isofs_alloc_inode,\n\t.free_inode\t= isofs_free_inode,\n\t.put_super\t= isofs_put_super,\n\t.statfs\t\t= isofs_statfs,\n\t.remount_fs\t= isofs_remount,\n\t.show_options\t= isofs_show_options,\n};\n\n\nstatic const struct dentry_operations isofs_dentry_ops[] = {\n\t{\n\t\t.d_hash\t\t= isofs_hashi,\n\t\t.d_compare\t= isofs_dentry_cmpi,\n\t},\n#ifdef CONFIG_JOLIET\n\t{\n\t\t.d_hash\t\t= isofs_hash_ms,\n\t\t.d_compare\t= isofs_dentry_cmp_ms,\n\t},\n\t{\n\t\t.d_hash\t\t= isofs_hashi_ms,\n\t\t.d_compare\t= isofs_dentry_cmpi_ms,\n\t},\n#endif\n};\n\nstruct iso9660_options{\n\tunsigned int rock:1;\n\tunsigned int joliet:1;\n\tunsigned int cruft:1;\n\tunsigned int hide:1;\n\tunsigned int showassoc:1;\n\tunsigned int nocompress:1;\n\tunsigned int overriderockperm:1;\n\tunsigned int uid_set:1;\n\tunsigned int gid_set:1;\n\tunsigned char map;\n\tunsigned char check;\n\tunsigned int blocksize;\n\tumode_t fmode;\n\tumode_t dmode;\n\tkgid_t gid;\n\tkuid_t uid;\n\tchar *iocharset;\n\t \n\ts32 session;\n\ts32 sbsector;\n};\n\n \nstatic int\nisofs_hashi_common(const struct dentry *dentry, struct qstr *qstr, int ms)\n{\n\tconst char *name;\n\tint len;\n\tchar c;\n\tunsigned long hash;\n\n\tlen = qstr->len;\n\tname = qstr->name;\n\tif (ms) {\n\t\twhile (len && name[len-1] == '.')\n\t\t\tlen--;\n\t}\n\n\thash = init_name_hash(dentry);\n\twhile (len--) {\n\t\tc = tolower(*name++);\n\t\thash = partial_name_hash(c, hash);\n\t}\n\tqstr->hash = end_name_hash(hash);\n\n\treturn 0;\n}\n\n \nstatic int isofs_dentry_cmp_common(\n\t\tunsigned int len, const char *str,\n\t\tconst struct qstr *name, int ms, int ci)\n{\n\tint alen, blen;\n\n\t \n\talen = name->len;\n\tblen = len;\n\tif (ms) {\n\t\twhile (alen && name->name[alen-1] == '.')\n\t\t\talen--;\n\t\twhile (blen && str[blen-1] == '.')\n\t\t\tblen--;\n\t}\n\tif (alen == blen) {\n\t\tif (ci) {\n\t\t\tif (strncasecmp(name->name, str, alen) == 0)\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (strncmp(name->name, str, alen) == 0)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic int\nisofs_hashi(const struct dentry *dentry, struct qstr *qstr)\n{\n\treturn isofs_hashi_common(dentry, qstr, 0);\n}\n\nstatic int\nisofs_dentry_cmpi(const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name)\n{\n\treturn isofs_dentry_cmp_common(len, str, name, 0, 1);\n}\n\n#ifdef CONFIG_JOLIET\n \nstatic int\nisofs_hash_common(const struct dentry *dentry, struct qstr *qstr, int ms)\n{\n\tconst char *name;\n\tint len;\n\n\tlen = qstr->len;\n\tname = qstr->name;\n\tif (ms) {\n\t\twhile (len && name[len-1] == '.')\n\t\t\tlen--;\n\t}\n\n\tqstr->hash = full_name_hash(dentry, name, len);\n\n\treturn 0;\n}\n\nstatic int\nisofs_hash_ms(const struct dentry *dentry, struct qstr *qstr)\n{\n\treturn isofs_hash_common(dentry, qstr, 1);\n}\n\nstatic int\nisofs_hashi_ms(const struct dentry *dentry, struct qstr *qstr)\n{\n\treturn isofs_hashi_common(dentry, qstr, 1);\n}\n\nstatic int\nisofs_dentry_cmp_ms(const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name)\n{\n\treturn isofs_dentry_cmp_common(len, str, name, 1, 0);\n}\n\nstatic int\nisofs_dentry_cmpi_ms(const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name)\n{\n\treturn isofs_dentry_cmp_common(len, str, name, 1, 1);\n}\n#endif\n\nenum {\n\tOpt_block, Opt_check_r, Opt_check_s, Opt_cruft, Opt_gid, Opt_ignore,\n\tOpt_iocharset, Opt_map_a, Opt_map_n, Opt_map_o, Opt_mode, Opt_nojoliet,\n\tOpt_norock, Opt_sb, Opt_session, Opt_uid, Opt_unhide, Opt_utf8, Opt_err,\n\tOpt_nocompress, Opt_hide, Opt_showassoc, Opt_dmode, Opt_overriderockperm,\n};\n\nstatic const match_table_t tokens = {\n\t{Opt_norock, \"norock\"},\n\t{Opt_nojoliet, \"nojoliet\"},\n\t{Opt_unhide, \"unhide\"},\n\t{Opt_hide, \"hide\"},\n\t{Opt_showassoc, \"showassoc\"},\n\t{Opt_cruft, \"cruft\"},\n\t{Opt_utf8, \"utf8\"},\n\t{Opt_iocharset, \"iocharset=%s\"},\n\t{Opt_map_a, \"map=acorn\"},\n\t{Opt_map_a, \"map=a\"},\n\t{Opt_map_n, \"map=normal\"},\n\t{Opt_map_n, \"map=n\"},\n\t{Opt_map_o, \"map=off\"},\n\t{Opt_map_o, \"map=o\"},\n\t{Opt_session, \"session=%u\"},\n\t{Opt_sb, \"sbsector=%u\"},\n\t{Opt_check_r, \"check=relaxed\"},\n\t{Opt_check_r, \"check=r\"},\n\t{Opt_check_s, \"check=strict\"},\n\t{Opt_check_s, \"check=s\"},\n\t{Opt_uid, \"uid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_mode, \"mode=%u\"},\n\t{Opt_dmode, \"dmode=%u\"},\n\t{Opt_overriderockperm, \"overriderockperm\"},\n\t{Opt_block, \"block=%u\"},\n\t{Opt_ignore, \"conv=binary\"},\n\t{Opt_ignore, \"conv=b\"},\n\t{Opt_ignore, \"conv=text\"},\n\t{Opt_ignore, \"conv=t\"},\n\t{Opt_ignore, \"conv=mtext\"},\n\t{Opt_ignore, \"conv=m\"},\n\t{Opt_ignore, \"conv=auto\"},\n\t{Opt_ignore, \"conv=a\"},\n\t{Opt_nocompress, \"nocompress\"},\n\t{Opt_err, NULL}\n};\n\nstatic int parse_options(char *options, struct iso9660_options *popt)\n{\n\tchar *p;\n\tint option;\n\tunsigned int uv;\n\n\tpopt->map = 'n';\n\tpopt->rock = 1;\n\tpopt->joliet = 1;\n\tpopt->cruft = 0;\n\tpopt->hide = 0;\n\tpopt->showassoc = 0;\n\tpopt->check = 'u';\t\t \n\tpopt->nocompress = 0;\n\tpopt->blocksize = 1024;\n\tpopt->fmode = popt->dmode = ISOFS_INVALID_MODE;\n\tpopt->uid_set = 0;\n\tpopt->gid_set = 0;\n\tpopt->gid = GLOBAL_ROOT_GID;\n\tpopt->uid = GLOBAL_ROOT_UID;\n\tpopt->iocharset = NULL;\n\tpopt->overriderockperm = 0;\n\tpopt->session=-1;\n\tpopt->sbsector=-1;\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tunsigned n;\n\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_norock:\n\t\t\tpopt->rock = 0;\n\t\t\tbreak;\n\t\tcase Opt_nojoliet:\n\t\t\tpopt->joliet = 0;\n\t\t\tbreak;\n\t\tcase Opt_hide:\n\t\t\tpopt->hide = 1;\n\t\t\tbreak;\n\t\tcase Opt_unhide:\n\t\tcase Opt_showassoc:\n\t\t\tpopt->showassoc = 1;\n\t\t\tbreak;\n\t\tcase Opt_cruft:\n\t\t\tpopt->cruft = 1;\n\t\t\tbreak;\n#ifdef CONFIG_JOLIET\n\t\tcase Opt_utf8:\n\t\t\tkfree(popt->iocharset);\n\t\t\tpopt->iocharset = kstrdup(\"utf8\", GFP_KERNEL);\n\t\t\tif (!popt->iocharset)\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_iocharset:\n\t\t\tkfree(popt->iocharset);\n\t\t\tpopt->iocharset = match_strdup(&args[0]);\n\t\t\tif (!popt->iocharset)\n\t\t\t\treturn 0;\n\t\t\tbreak;\n#endif\n\t\tcase Opt_map_a:\n\t\t\tpopt->map = 'a';\n\t\t\tbreak;\n\t\tcase Opt_map_o:\n\t\t\tpopt->map = 'o';\n\t\t\tbreak;\n\t\tcase Opt_map_n:\n\t\t\tpopt->map = 'n';\n\t\t\tbreak;\n\t\tcase Opt_session:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tn = option;\n\t\t\t \n\t\t\tif (n >= 99)\n\t\t\t\treturn 0;\n\t\t\tpopt->session = n + 1;\n\t\t\tbreak;\n\t\tcase Opt_sb:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tpopt->sbsector = option;\n\t\t\tbreak;\n\t\tcase Opt_check_r:\n\t\t\tpopt->check = 'r';\n\t\t\tbreak;\n\t\tcase Opt_check_s:\n\t\t\tpopt->check = 's';\n\t\t\tbreak;\n\t\tcase Opt_ignore:\n\t\t\tbreak;\n\t\tcase Opt_uid:\n\t\t\tif (match_uint(&args[0], &uv))\n\t\t\t\treturn 0;\n\t\t\tpopt->uid = make_kuid(current_user_ns(), uv);\n\t\t\tif (!uid_valid(popt->uid))\n\t\t\t\treturn 0;\n\t\t\tpopt->uid_set = 1;\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_uint(&args[0], &uv))\n\t\t\t\treturn 0;\n\t\t\tpopt->gid = make_kgid(current_user_ns(), uv);\n\t\t\tif (!gid_valid(popt->gid))\n\t\t\t\treturn 0;\n\t\t\tpopt->gid_set = 1;\n\t\t\tbreak;\n\t\tcase Opt_mode:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tpopt->fmode = option;\n\t\t\tbreak;\n\t\tcase Opt_dmode:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tpopt->dmode = option;\n\t\t\tbreak;\n\t\tcase Opt_overriderockperm:\n\t\t\tpopt->overriderockperm = 1;\n\t\t\tbreak;\n\t\tcase Opt_block:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tn = option;\n\t\t\tif (n != 512 && n != 1024 && n != 2048)\n\t\t\t\treturn 0;\n\t\t\tpopt->blocksize = n;\n\t\t\tbreak;\n\t\tcase Opt_nocompress:\n\t\t\tpopt->nocompress = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\n \nstatic int isofs_show_options(struct seq_file *m, struct dentry *root)\n{\n\tstruct isofs_sb_info *sbi = ISOFS_SB(root->d_sb);\n\n\tif (!sbi->s_rock)\t\tseq_puts(m, \",norock\");\n\telse if (!sbi->s_joliet_level)\tseq_puts(m, \",nojoliet\");\n\tif (sbi->s_cruft)\t\tseq_puts(m, \",cruft\");\n\tif (sbi->s_hide)\t\tseq_puts(m, \",hide\");\n\tif (sbi->s_nocompress)\t\tseq_puts(m, \",nocompress\");\n\tif (sbi->s_overriderockperm)\tseq_puts(m, \",overriderockperm\");\n\tif (sbi->s_showassoc)\t\tseq_puts(m, \",showassoc\");\n\n\tif (sbi->s_check)\t\tseq_printf(m, \",check=%c\", sbi->s_check);\n\tif (sbi->s_mapping)\t\tseq_printf(m, \",map=%c\", sbi->s_mapping);\n\tif (sbi->s_session != 255)\tseq_printf(m, \",session=%u\", sbi->s_session - 1);\n\tif (sbi->s_sbsector != -1)\tseq_printf(m, \",sbsector=%u\", sbi->s_sbsector);\n\n\tif (root->d_sb->s_blocksize != 1024)\n\t\tseq_printf(m, \",blocksize=%lu\", root->d_sb->s_blocksize);\n\n\tif (sbi->s_uid_set)\n\t\tseq_printf(m, \",uid=%u\",\n\t\t\t   from_kuid_munged(&init_user_ns, sbi->s_uid));\n\tif (sbi->s_gid_set)\n\t\tseq_printf(m, \",gid=%u\",\n\t\t\t   from_kgid_munged(&init_user_ns, sbi->s_gid));\n\n\tif (sbi->s_dmode != ISOFS_INVALID_MODE)\n\t\tseq_printf(m, \",dmode=%o\", sbi->s_dmode);\n\tif (sbi->s_fmode != ISOFS_INVALID_MODE)\n\t\tseq_printf(m, \",fmode=%o\", sbi->s_fmode);\n\n#ifdef CONFIG_JOLIET\n\tif (sbi->s_nls_iocharset)\n\t\tseq_printf(m, \",iocharset=%s\", sbi->s_nls_iocharset->charset);\n\telse\n\t\tseq_puts(m, \",iocharset=utf8\");\n#endif\n\treturn 0;\n}\n\n \n#define WE_OBEY_THE_WRITTEN_STANDARDS 1\n\nstatic unsigned int isofs_get_last_session(struct super_block *sb, s32 session)\n{\n\tstruct cdrom_device_info *cdi = disk_to_cdi(sb->s_bdev->bd_disk);\n\tunsigned int vol_desc_start = 0;\n\n\tif (session > 0) {\n\t\tstruct cdrom_tocentry te;\n\n\t\tif (!cdi)\n\t\t\treturn 0;\n\n\t\tte.cdte_track = session;\n\t\tte.cdte_format = CDROM_LBA;\n\t\tif (cdrom_read_tocentry(cdi, &te) == 0) {\n\t\t\tprintk(KERN_DEBUG \"ISOFS: Session %d start %d type %d\\n\",\n\t\t\t\tsession, te.cdte_addr.lba,\n\t\t\t\tte.cdte_ctrl & CDROM_DATA_TRACK);\n\t\t\tif ((te.cdte_ctrl & CDROM_DATA_TRACK) == 4)\n\t\t\t\treturn te.cdte_addr.lba;\n\t\t}\n\n\t\tprintk(KERN_ERR \"ISOFS: Invalid session number or type of track\\n\");\n\t}\n\n\tif (cdi) {\n\t\tstruct cdrom_multisession ms_info;\n\n\t\tms_info.addr_format = CDROM_LBA;\n\t\tif (cdrom_multisession(cdi, &ms_info) == 0) {\n#if WE_OBEY_THE_WRITTEN_STANDARDS\n\t\t\t \n\t\t\tif (ms_info.xa_flag)\n#endif\n\t\t\t\tvol_desc_start = ms_info.addr.lba;\n\t\t}\n\t}\n\n\treturn vol_desc_start;\n}\n\n \nstatic bool rootdir_empty(struct super_block *sb, unsigned long block)\n{\n\tint offset = 0, files = 0, de_len;\n\tstruct iso_directory_record *de;\n\tstruct buffer_head *bh;\n\n\tbh = sb_bread(sb, block);\n\tif (!bh)\n\t\treturn true;\n\twhile (files < 3) {\n\t\tde = (struct iso_directory_record *) (bh->b_data + offset);\n\t\tde_len = *(unsigned char *) de;\n\t\tif (de_len == 0)\n\t\t\tbreak;\n\t\tfiles++;\n\t\toffset += de_len;\n\t}\n\tbrelse(bh);\n\treturn files < 3;\n}\n\n \nstatic int isofs_fill_super(struct super_block *s, void *data, int silent)\n{\n\tstruct buffer_head *bh = NULL, *pri_bh = NULL;\n\tstruct hs_primary_descriptor *h_pri = NULL;\n\tstruct iso_primary_descriptor *pri = NULL;\n\tstruct iso_supplementary_descriptor *sec = NULL;\n\tstruct iso_directory_record *rootp;\n\tstruct inode *inode;\n\tstruct iso9660_options opt;\n\tstruct isofs_sb_info *sbi;\n\tunsigned long first_data_zone;\n\tint joliet_level = 0;\n\tint iso_blknum, block;\n\tint orig_zonesize;\n\tint table, error = -EINVAL;\n\tunsigned int vol_desc_start;\n\n\tsbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\ts->s_fs_info = sbi;\n\n\tif (!parse_options((char *)data, &opt))\n\t\tgoto out_freesbi;\n\n\t \n\t \n\tif (bdev_logical_block_size(s->s_bdev) > 2048) {\n\t\tprintk(KERN_WARNING\n\t\t       \"ISOFS: unsupported/invalid hardware sector size %d\\n\",\n\t\t\tbdev_logical_block_size(s->s_bdev));\n\t\tgoto out_freesbi;\n\t}\n\topt.blocksize = sb_min_blocksize(s, opt.blocksize);\n\n\tsbi->s_high_sierra = 0;  \n\tsbi->s_session = opt.session;\n\tsbi->s_sbsector = opt.sbsector;\n\n\tvol_desc_start = (opt.sbsector != -1) ?\n\t\topt.sbsector : isofs_get_last_session(s,opt.session);\n\n\tfor (iso_blknum = vol_desc_start+16;\n\t\tiso_blknum < vol_desc_start+100; iso_blknum++) {\n\t\tstruct hs_volume_descriptor *hdp;\n\t\tstruct iso_volume_descriptor  *vdp;\n\n\t\tblock = iso_blknum << (ISOFS_BLOCK_BITS - s->s_blocksize_bits);\n\t\tif (!(bh = sb_bread(s, block)))\n\t\t\tgoto out_no_read;\n\n\t\tvdp = (struct iso_volume_descriptor *)bh->b_data;\n\t\thdp = (struct hs_volume_descriptor *)bh->b_data;\n\n\t\t \n\t\tif (strncmp (vdp->id, ISO_STANDARD_ID, sizeof vdp->id) == 0) {\n\t\t\tif (isonum_711(vdp->type) == ISO_VD_END)\n\t\t\t\tbreak;\n\t\t\tif (isonum_711(vdp->type) == ISO_VD_PRIMARY) {\n\t\t\t\tif (!pri) {\n\t\t\t\t\tpri = (struct iso_primary_descriptor *)vdp;\n\t\t\t\t\t \n\t\t\t\t\tpri_bh = bh;\n\t\t\t\t\tbh = NULL;\n\t\t\t\t}\n\t\t\t}\n#ifdef CONFIG_JOLIET\n\t\t\telse if (isonum_711(vdp->type) == ISO_VD_SUPPLEMENTARY) {\n\t\t\t\tsec = (struct iso_supplementary_descriptor *)vdp;\n\t\t\t\tif (sec->escape[0] == 0x25 && sec->escape[1] == 0x2f) {\n\t\t\t\t\tif (opt.joliet) {\n\t\t\t\t\t\tif (sec->escape[2] == 0x40)\n\t\t\t\t\t\t\tjoliet_level = 1;\n\t\t\t\t\t\telse if (sec->escape[2] == 0x43)\n\t\t\t\t\t\t\tjoliet_level = 2;\n\t\t\t\t\t\telse if (sec->escape[2] == 0x45)\n\t\t\t\t\t\t\tjoliet_level = 3;\n\n\t\t\t\t\t\tprintk(KERN_DEBUG \"ISO 9660 Extensions: \"\n\t\t\t\t\t\t\t\"Microsoft Joliet Level %d\\n\",\n\t\t\t\t\t\t\tjoliet_level);\n\t\t\t\t\t}\n\t\t\t\t\tgoto root_found;\n\t\t\t\t} else {\n\t\t\t\t \n\t\t\t\tsec = NULL;\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t} else {\n\t\t\tif (strncmp (hdp->id, HS_STANDARD_ID, sizeof hdp->id) == 0) {\n\t\t\t\tif (isonum_711(hdp->type) != ISO_VD_PRIMARY)\n\t\t\t\t\tgoto out_freebh;\n\n\t\t\t\tsbi->s_high_sierra = 1;\n\t\t\t\topt.rock = 0;\n\t\t\t\th_pri = (struct hs_primary_descriptor *)vdp;\n\t\t\t\tgoto root_found;\n\t\t\t}\n\t\t}\n\n\t\t \n\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\t}\n\t \n\tif (!pri)\n\t\tgoto out_unknown_format;\n\tbrelse(bh);\n\tbh = pri_bh;\n\tpri_bh = NULL;\n\nroot_found:\n\t \n\tif (!sb_rdonly(s)) {\n\t\terror = -EACCES;\n\t\tgoto out_freebh;\n\t}\n\n\tif (joliet_level && (!pri || !opt.rock)) {\n\t\t \n\t\tpri = (struct iso_primary_descriptor *) sec;\n\t}\n\n\tif(sbi->s_high_sierra){\n\t\trootp = (struct iso_directory_record *) h_pri->root_directory_record;\n\t\tsbi->s_nzones = isonum_733(h_pri->volume_space_size);\n\t\tsbi->s_log_zone_size = isonum_723(h_pri->logical_block_size);\n\t\tsbi->s_max_size = isonum_733(h_pri->volume_space_size);\n\t} else {\n\t\tif (!pri)\n\t\t\tgoto out_freebh;\n\t\trootp = (struct iso_directory_record *) pri->root_directory_record;\n\t\tsbi->s_nzones = isonum_733(pri->volume_space_size);\n\t\tsbi->s_log_zone_size = isonum_723(pri->logical_block_size);\n\t\tsbi->s_max_size = isonum_733(pri->volume_space_size);\n\t}\n\n\tsbi->s_ninodes = 0;  \n\n\torig_zonesize = sbi->s_log_zone_size;\n\t \n\tif (orig_zonesize < opt.blocksize)\n\t\tgoto out_bad_size;\n\n\t \n\tswitch (sbi->s_log_zone_size) {\n\tcase  512: sbi->s_log_zone_size =  9; break;\n\tcase 1024: sbi->s_log_zone_size = 10; break;\n\tcase 2048: sbi->s_log_zone_size = 11; break;\n\n\tdefault:\n\t\tgoto out_bad_zone_size;\n\t}\n\n\ts->s_magic = ISOFS_SUPER_MAGIC;\n\n\t \n\ts->s_maxbytes = 0x80000000000LL;\n\n\t \n\ts->s_time_min = mktime64(1900, 1, 1, 0, 0, 0) - MAX_TZ_OFFSET;\n\ts->s_time_max = mktime64(U8_MAX+1900, 12, 31, 23, 59, 59) + MAX_TZ_OFFSET;\n\n\t \n\n\tfirst_data_zone = isonum_733(rootp->extent) +\n\t\t\t  isonum_711(rootp->ext_attr_length);\n\tsbi->s_firstdatazone = first_data_zone;\n#ifndef BEQUIET\n\tprintk(KERN_DEBUG \"ISOFS: Max size:%ld   Log zone size:%ld\\n\",\n\t\tsbi->s_max_size, 1UL << sbi->s_log_zone_size);\n\tprintk(KERN_DEBUG \"ISOFS: First datazone:%ld\\n\", sbi->s_firstdatazone);\n\tif(sbi->s_high_sierra)\n\t\tprintk(KERN_DEBUG \"ISOFS: Disc in High Sierra format.\\n\");\n#endif\n\n\t \n\tif (joliet_level) {\n\t\tpri = (struct iso_primary_descriptor *) sec;\n\t\trootp = (struct iso_directory_record *)\n\t\t\tpri->root_directory_record;\n\t\tfirst_data_zone = isonum_733(rootp->extent) +\n\t\t\t\tisonum_711(rootp->ext_attr_length);\n\t}\n\n\t \n\tbrelse(pri_bh);\n\tbrelse(bh);\n\n\t \n\tsb_set_blocksize(s, orig_zonesize);\n\n\tsbi->s_nls_iocharset = NULL;\n\n#ifdef CONFIG_JOLIET\n\tif (joliet_level) {\n\t\tchar *p = opt.iocharset ? opt.iocharset : CONFIG_NLS_DEFAULT;\n\t\tif (strcmp(p, \"utf8\") != 0) {\n\t\t\tsbi->s_nls_iocharset = opt.iocharset ?\n\t\t\t\tload_nls(opt.iocharset) : load_nls_default();\n\t\t\tif (!sbi->s_nls_iocharset)\n\t\t\t\tgoto out_freesbi;\n\t\t}\n\t}\n#endif\n\ts->s_op = &isofs_sops;\n\ts->s_export_op = &isofs_export_ops;\n\tsbi->s_mapping = opt.map;\n\tsbi->s_rock = (opt.rock ? 2 : 0);\n\tsbi->s_rock_offset = -1;  \n\tsbi->s_cruft = opt.cruft;\n\tsbi->s_hide = opt.hide;\n\tsbi->s_showassoc = opt.showassoc;\n\tsbi->s_uid = opt.uid;\n\tsbi->s_gid = opt.gid;\n\tsbi->s_uid_set = opt.uid_set;\n\tsbi->s_gid_set = opt.gid_set;\n\tsbi->s_nocompress = opt.nocompress;\n\tsbi->s_overriderockperm = opt.overriderockperm;\n\t \n\tif (opt.fmode != ISOFS_INVALID_MODE)\n\t\tsbi->s_fmode = opt.fmode & 0777;\n\telse\n\t\tsbi->s_fmode = ISOFS_INVALID_MODE;\n\tif (opt.dmode != ISOFS_INVALID_MODE)\n\t\tsbi->s_dmode = opt.dmode & 0777;\n\telse\n\t\tsbi->s_dmode = ISOFS_INVALID_MODE;\n\n\t \n\tinode = isofs_iget(s, sbi->s_firstdatazone, 0);\n\tif (IS_ERR(inode))\n\t\tgoto out_no_root;\n\n\t \n\tif (sbi->s_rock == 1 && joliet_level &&\n\t\t\t\trootdir_empty(s, sbi->s_firstdatazone)) {\n\t\tprintk(KERN_NOTICE\n\t\t\t\"ISOFS: primary root directory is empty. \"\n\t\t\t\"Disabling Rock Ridge and switching to Joliet.\");\n\t\tsbi->s_rock = 0;\n\t}\n\n\t \n\tif (sbi->s_rock == 1) {\n\t\tjoliet_level = 0;\n\t} else if (joliet_level) {\n\t\tsbi->s_rock = 0;\n\t\tif (sbi->s_firstdatazone != first_data_zone) {\n\t\t\tsbi->s_firstdatazone = first_data_zone;\n\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\"ISOFS: changing to secondary root\\n\");\n\t\t\tiput(inode);\n\t\t\tinode = isofs_iget(s, sbi->s_firstdatazone, 0);\n\t\t\tif (IS_ERR(inode))\n\t\t\t\tgoto out_no_root;\n\t\t}\n\t}\n\n\tif (opt.check == 'u') {\n\t\t \n\t\tif (joliet_level)\n\t\t\topt.check = 'r';\n\t\telse\n\t\t\topt.check = 's';\n\t}\n\tsbi->s_joliet_level = joliet_level;\n\n\t \n\tif (!S_ISDIR(inode->i_mode)) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"isofs_fill_super: root inode is not a directory. \"\n\t\t\t\"Corrupted media?\\n\");\n\t\tgoto out_iput;\n\t}\n\n\ttable = 0;\n\tif (joliet_level)\n\t\ttable += 2;\n\tif (opt.check == 'r')\n\t\ttable++;\n\tsbi->s_check = opt.check;\n\n\tif (table)\n\t\ts->s_d_op = &isofs_dentry_ops[table - 1];\n\n\t \n\ts->s_root = d_make_root(inode);\n\tif (!(s->s_root)) {\n\t\terror = -ENOMEM;\n\t\tgoto out_no_inode;\n\t}\n\n\tkfree(opt.iocharset);\n\n\treturn 0;\n\n\t \nout_iput:\n\tiput(inode);\n\tgoto out_no_inode;\nout_no_root:\n\terror = PTR_ERR(inode);\n\tif (error != -ENOMEM)\n\t\tprintk(KERN_WARNING \"%s: get root inode failed\\n\", __func__);\nout_no_inode:\n#ifdef CONFIG_JOLIET\n\tunload_nls(sbi->s_nls_iocharset);\n#endif\n\tgoto out_freesbi;\nout_no_read:\n\tprintk(KERN_WARNING \"%s: bread failed, dev=%s, iso_blknum=%d, block=%d\\n\",\n\t\t__func__, s->s_id, iso_blknum, block);\n\tgoto out_freebh;\nout_bad_zone_size:\n\tprintk(KERN_WARNING \"ISOFS: Bad logical zone size %ld\\n\",\n\t\tsbi->s_log_zone_size);\n\tgoto out_freebh;\nout_bad_size:\n\tprintk(KERN_WARNING \"ISOFS: Logical zone size(%d) < hardware blocksize(%u)\\n\",\n\t\torig_zonesize, opt.blocksize);\n\tgoto out_freebh;\nout_unknown_format:\n\tif (!silent)\n\t\tprintk(KERN_WARNING \"ISOFS: Unable to identify CD-ROM format.\\n\");\n\nout_freebh:\n\tbrelse(bh);\n\tbrelse(pri_bh);\nout_freesbi:\n\tkfree(opt.iocharset);\n\tkfree(sbi);\n\ts->s_fs_info = NULL;\n\treturn error;\n}\n\nstatic int isofs_statfs (struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tu64 id = huge_encode_dev(sb->s_bdev->bd_dev);\n\n\tbuf->f_type = ISOFS_SUPER_MAGIC;\n\tbuf->f_bsize = sb->s_blocksize;\n\tbuf->f_blocks = (ISOFS_SB(sb)->s_nzones\n\t\t<< (ISOFS_SB(sb)->s_log_zone_size - sb->s_blocksize_bits));\n\tbuf->f_bfree = 0;\n\tbuf->f_bavail = 0;\n\tbuf->f_files = ISOFS_SB(sb)->s_ninodes;\n\tbuf->f_ffree = 0;\n\tbuf->f_fsid = u64_to_fsid(id);\n\tbuf->f_namelen = NAME_MAX;\n\treturn 0;\n}\n\n \nint isofs_get_blocks(struct inode *inode, sector_t iblock,\n\t\t     struct buffer_head **bh, unsigned long nblocks)\n{\n\tunsigned long b_off = iblock;\n\tunsigned offset, sect_size;\n\tunsigned int firstext;\n\tunsigned long nextblk, nextoff;\n\tint section, rv, error;\n\tstruct iso_inode_info *ei = ISOFS_I(inode);\n\n\terror = -EIO;\n\trv = 0;\n\tif (iblock != b_off) {\n\t\tprintk(KERN_DEBUG \"%s: block number too large\\n\", __func__);\n\t\tgoto abort;\n\t}\n\n\n\toffset = 0;\n\tfirstext = ei->i_first_extent;\n\tsect_size = ei->i_section_size >> ISOFS_BUFFER_BITS(inode);\n\tnextblk = ei->i_next_section_block;\n\tnextoff = ei->i_next_section_offset;\n\tsection = 0;\n\n\twhile (nblocks) {\n\t\t \n\t\tif (b_off > ((inode->i_size + PAGE_SIZE - 1) >> ISOFS_BUFFER_BITS(inode))) {\n\t\t\tprintk(KERN_DEBUG \"%s: block >= EOF (%lu, %llu)\\n\",\n\t\t\t\t__func__, b_off,\n\t\t\t\t(unsigned long long)inode->i_size);\n\t\t\tgoto abort;\n\t\t}\n\n\t\t \n\t\twhile (nextblk && (b_off >= (offset + sect_size))) {\n\t\t\tstruct inode *ninode;\n\n\t\t\toffset += sect_size;\n\t\t\tninode = isofs_iget(inode->i_sb, nextblk, nextoff);\n\t\t\tif (IS_ERR(ninode)) {\n\t\t\t\terror = PTR_ERR(ninode);\n\t\t\t\tgoto abort;\n\t\t\t}\n\t\t\tfirstext  = ISOFS_I(ninode)->i_first_extent;\n\t\t\tsect_size = ISOFS_I(ninode)->i_section_size >> ISOFS_BUFFER_BITS(ninode);\n\t\t\tnextblk   = ISOFS_I(ninode)->i_next_section_block;\n\t\t\tnextoff   = ISOFS_I(ninode)->i_next_section_offset;\n\t\t\tiput(ninode);\n\n\t\t\tif (++section > 100) {\n\t\t\t\tprintk(KERN_DEBUG \"%s: More than 100 file sections ?!?\"\n\t\t\t\t\t\" aborting...\\n\", __func__);\n\t\t\t\tprintk(KERN_DEBUG \"%s: block=%lu firstext=%u sect_size=%u \"\n\t\t\t\t\t\"nextblk=%lu nextoff=%lu\\n\", __func__,\n\t\t\t\t\tb_off, firstext, (unsigned) sect_size,\n\t\t\t\t\tnextblk, nextoff);\n\t\t\t\tgoto abort;\n\t\t\t}\n\t\t}\n\n\t\tif (*bh) {\n\t\t\tmap_bh(*bh, inode->i_sb, firstext + b_off - offset);\n\t\t} else {\n\t\t\t*bh = sb_getblk(inode->i_sb, firstext+b_off-offset);\n\t\t\tif (!*bh)\n\t\t\t\tgoto abort;\n\t\t}\n\t\tbh++;\t \n\t\tb_off++;\t \n\t\tnblocks--;\n\t\trv++;\n\t}\n\n\terror = 0;\nabort:\n\treturn rv != 0 ? rv : error;\n}\n\n \nstatic int isofs_get_block(struct inode *inode, sector_t iblock,\n\t\t    struct buffer_head *bh_result, int create)\n{\n\tint ret;\n\n\tif (create) {\n\t\tprintk(KERN_DEBUG \"%s: Kernel tries to allocate a block\\n\", __func__);\n\t\treturn -EROFS;\n\t}\n\n\tret = isofs_get_blocks(inode, iblock, &bh_result, 1);\n\treturn ret < 0 ? ret : 0;\n}\n\nstatic int isofs_bmap(struct inode *inode, sector_t block)\n{\n\tstruct buffer_head dummy;\n\tint error;\n\n\tdummy.b_state = 0;\n\tdummy.b_blocknr = -1000;\n\terror = isofs_get_block(inode, block, &dummy, 0);\n\tif (!error)\n\t\treturn dummy.b_blocknr;\n\treturn 0;\n}\n\nstruct buffer_head *isofs_bread(struct inode *inode, sector_t block)\n{\n\tsector_t blknr = isofs_bmap(inode, block);\n\tif (!blknr)\n\t\treturn NULL;\n\treturn sb_bread(inode->i_sb, blknr);\n}\n\nstatic int isofs_read_folio(struct file *file, struct folio *folio)\n{\n\treturn mpage_read_folio(folio, isofs_get_block);\n}\n\nstatic void isofs_readahead(struct readahead_control *rac)\n{\n\tmpage_readahead(rac, isofs_get_block);\n}\n\nstatic sector_t _isofs_bmap(struct address_space *mapping, sector_t block)\n{\n\treturn generic_block_bmap(mapping,block,isofs_get_block);\n}\n\nstatic const struct address_space_operations isofs_aops = {\n\t.read_folio = isofs_read_folio,\n\t.readahead = isofs_readahead,\n\t.bmap = _isofs_bmap\n};\n\nstatic int isofs_read_level3_size(struct inode *inode)\n{\n\tunsigned long bufsize = ISOFS_BUFFER_SIZE(inode);\n\tint high_sierra = ISOFS_SB(inode->i_sb)->s_high_sierra;\n\tstruct buffer_head *bh = NULL;\n\tunsigned long block, offset, block_saved, offset_saved;\n\tint i = 0;\n\tint more_entries = 0;\n\tstruct iso_directory_record *tmpde = NULL;\n\tstruct iso_inode_info *ei = ISOFS_I(inode);\n\n\tinode->i_size = 0;\n\n\t \n\tei->i_next_section_block = 0;\n\tei->i_next_section_offset = 0;\n\n\tblock = ei->i_iget5_block;\n\toffset = ei->i_iget5_offset;\n\n\tdo {\n\t\tstruct iso_directory_record *de;\n\t\tunsigned int de_len;\n\n\t\tif (!bh) {\n\t\t\tbh = sb_bread(inode->i_sb, block);\n\t\t\tif (!bh)\n\t\t\t\tgoto out_noread;\n\t\t}\n\t\tde = (struct iso_directory_record *) (bh->b_data + offset);\n\t\tde_len = *(unsigned char *) de;\n\n\t\tif (de_len == 0) {\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t\t++block;\n\t\t\toffset = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tblock_saved = block;\n\t\toffset_saved = offset;\n\t\toffset += de_len;\n\n\t\t \n\t\tif (offset >= bufsize) {\n\t\t\tint slop = bufsize - offset + de_len;\n\t\t\tif (!tmpde) {\n\t\t\t\ttmpde = kmalloc(256, GFP_KERNEL);\n\t\t\t\tif (!tmpde)\n\t\t\t\t\tgoto out_nomem;\n\t\t\t}\n\t\t\tmemcpy(tmpde, de, slop);\n\t\t\toffset &= bufsize - 1;\n\t\t\tblock++;\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t\tif (offset) {\n\t\t\t\tbh = sb_bread(inode->i_sb, block);\n\t\t\t\tif (!bh)\n\t\t\t\t\tgoto out_noread;\n\t\t\t\tmemcpy((void *)tmpde+slop, bh->b_data, offset);\n\t\t\t}\n\t\t\tde = tmpde;\n\t\t}\n\n\t\tinode->i_size += isonum_733(de->size);\n\t\tif (i == 1) {\n\t\t\tei->i_next_section_block = block_saved;\n\t\t\tei->i_next_section_offset = offset_saved;\n\t\t}\n\n\t\tmore_entries = de->flags[-high_sierra] & 0x80;\n\n\t\ti++;\n\t\tif (i > 100)\n\t\t\tgoto out_toomany;\n\t} while (more_entries);\nout:\n\tkfree(tmpde);\n\tbrelse(bh);\n\treturn 0;\n\nout_nomem:\n\tbrelse(bh);\n\treturn -ENOMEM;\n\nout_noread:\n\tprintk(KERN_INFO \"ISOFS: unable to read i-node block %lu\\n\", block);\n\tkfree(tmpde);\n\treturn -EIO;\n\nout_toomany:\n\tprintk(KERN_INFO \"%s: More than 100 file sections ?!?, aborting...\\n\"\n\t\t\"isofs_read_level3_size: inode=%lu\\n\",\n\t\t__func__, inode->i_ino);\n\tgoto out;\n}\n\nstatic int isofs_read_inode(struct inode *inode, int relocated)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct isofs_sb_info *sbi = ISOFS_SB(sb);\n\tunsigned long bufsize = ISOFS_BUFFER_SIZE(inode);\n\tunsigned long block;\n\tint high_sierra = sbi->s_high_sierra;\n\tstruct buffer_head *bh;\n\tstruct iso_directory_record *de;\n\tstruct iso_directory_record *tmpde = NULL;\n\tunsigned int de_len;\n\tunsigned long offset;\n\tstruct iso_inode_info *ei = ISOFS_I(inode);\n\tint ret = -EIO;\n\n\tblock = ei->i_iget5_block;\n\tbh = sb_bread(inode->i_sb, block);\n\tif (!bh)\n\t\tgoto out_badread;\n\n\toffset = ei->i_iget5_offset;\n\n\tde = (struct iso_directory_record *) (bh->b_data + offset);\n\tde_len = *(unsigned char *) de;\n\tif (de_len < sizeof(struct iso_directory_record))\n\t\tgoto fail;\n\n\tif (offset + de_len > bufsize) {\n\t\tint frag1 = bufsize - offset;\n\n\t\ttmpde = kmalloc(de_len, GFP_KERNEL);\n\t\tif (!tmpde) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\t\tmemcpy(tmpde, bh->b_data + offset, frag1);\n\t\tbrelse(bh);\n\t\tbh = sb_bread(inode->i_sb, ++block);\n\t\tif (!bh)\n\t\t\tgoto out_badread;\n\t\tmemcpy((char *)tmpde+frag1, bh->b_data, de_len - frag1);\n\t\tde = tmpde;\n\t}\n\n\tinode->i_ino = isofs_get_ino(ei->i_iget5_block,\n\t\t\t\t\tei->i_iget5_offset,\n\t\t\t\t\tISOFS_BUFFER_BITS(inode));\n\n\t \n\tei->i_file_format = isofs_file_normal;\n\n\tif (de->flags[-high_sierra] & 2) {\n\t\tif (sbi->s_dmode != ISOFS_INVALID_MODE)\n\t\t\tinode->i_mode = S_IFDIR | sbi->s_dmode;\n\t\telse\n\t\t\tinode->i_mode = S_IFDIR | S_IRUGO | S_IXUGO;\n\t\tset_nlink(inode, 1);\t \n\t} else {\n\t\tif (sbi->s_fmode != ISOFS_INVALID_MODE) {\n\t\t\tinode->i_mode = S_IFREG | sbi->s_fmode;\n\t\t} else {\n\t\t\t \n\t\t\tinode->i_mode = S_IFREG | S_IRUGO | S_IXUGO;\n\t\t}\n\t\tset_nlink(inode, 1);\n\t}\n\tinode->i_uid = sbi->s_uid;\n\tinode->i_gid = sbi->s_gid;\n\tinode->i_blocks = 0;\n\n\tei->i_format_parm[0] = 0;\n\tei->i_format_parm[1] = 0;\n\tei->i_format_parm[2] = 0;\n\n\tei->i_section_size = isonum_733(de->size);\n\tif (de->flags[-high_sierra] & 0x80) {\n\t\tret = isofs_read_level3_size(inode);\n\t\tif (ret < 0)\n\t\t\tgoto fail;\n\t\tret = -EIO;\n\t} else {\n\t\tei->i_next_section_block = 0;\n\t\tei->i_next_section_offset = 0;\n\t\tinode->i_size = isonum_733(de->size);\n\t}\n\n\t \n\n\tif (sbi->s_cruft)\n\t\tinode->i_size &= 0x00ffffff;\n\n\tif (de->interleave[0]) {\n\t\tprintk(KERN_DEBUG \"ISOFS: Interleaved files not (yet) supported.\\n\");\n\t\tinode->i_size = 0;\n\t}\n\n\t \n\tif (de->file_unit_size[0] != 0) {\n\t\tprintk(KERN_DEBUG \"ISOFS: File unit size != 0 for ISO file (%ld).\\n\",\n\t\t\tinode->i_ino);\n\t}\n\n\t \n#ifdef DEBUG\n\tif((de->flags[-high_sierra] & ~2)!= 0){\n\t\tprintk(KERN_DEBUG \"ISOFS: Unusual flag settings for ISO file \"\n\t\t\t\t\"(%ld %x).\\n\",\n\t\t\tinode->i_ino, de->flags[-high_sierra]);\n\t}\n#endif\n\tinode->i_mtime = inode->i_atime =\n\t\tinode_set_ctime(inode, iso_date(de->date, high_sierra), 0);\n\n\tei->i_first_extent = (isonum_733(de->extent) +\n\t\t\tisonum_711(de->ext_attr_length));\n\n\t \n\tinode->i_blocks = (inode->i_size + 511) >> 9;\n\n\t \n\n\tif (!high_sierra) {\n\t\tparse_rock_ridge_inode(de, inode, relocated);\n\t\t \n\t\tif (sbi->s_uid_set)\n\t\t\tinode->i_uid = sbi->s_uid;\n\t\tif (sbi->s_gid_set)\n\t\t\tinode->i_gid = sbi->s_gid;\n\t}\n\t \n\tif (S_ISDIR(inode->i_mode) && sbi->s_overriderockperm &&\n\t    sbi->s_dmode != ISOFS_INVALID_MODE)\n\t\tinode->i_mode = S_IFDIR | sbi->s_dmode;\n\tif (S_ISREG(inode->i_mode) && sbi->s_overriderockperm &&\n\t    sbi->s_fmode != ISOFS_INVALID_MODE)\n\t\tinode->i_mode = S_IFREG | sbi->s_fmode;\n\n\t \n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_fop = &generic_ro_fops;\n\t\tswitch (ei->i_file_format) {\n#ifdef CONFIG_ZISOFS\n\t\tcase isofs_file_compressed:\n\t\t\tinode->i_data.a_ops = &zisofs_aops;\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tinode->i_data.a_ops = &isofs_aops;\n\t\t\tbreak;\n\t\t}\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &isofs_dir_inode_operations;\n\t\tinode->i_fop = &isofs_dir_operations;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &page_symlink_inode_operations;\n\t\tinode_nohighmem(inode);\n\t\tinode->i_data.a_ops = &isofs_symlink_aops;\n\t} else\n\t\t \n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\n\tret = 0;\nout:\n\tkfree(tmpde);\n\tbrelse(bh);\n\treturn ret;\n\nout_badread:\n\tprintk(KERN_WARNING \"ISOFS: unable to read i-node block\\n\");\nfail:\n\tgoto out;\n}\n\nstruct isofs_iget5_callback_data {\n\tunsigned long block;\n\tunsigned long offset;\n};\n\nstatic int isofs_iget5_test(struct inode *ino, void *data)\n{\n\tstruct iso_inode_info *i = ISOFS_I(ino);\n\tstruct isofs_iget5_callback_data *d =\n\t\t(struct isofs_iget5_callback_data*)data;\n\treturn (i->i_iget5_block == d->block)\n\t\t&& (i->i_iget5_offset == d->offset);\n}\n\nstatic int isofs_iget5_set(struct inode *ino, void *data)\n{\n\tstruct iso_inode_info *i = ISOFS_I(ino);\n\tstruct isofs_iget5_callback_data *d =\n\t\t(struct isofs_iget5_callback_data*)data;\n\ti->i_iget5_block = d->block;\n\ti->i_iget5_offset = d->offset;\n\treturn 0;\n}\n\n \nstruct inode *__isofs_iget(struct super_block *sb,\n\t\t\t   unsigned long block,\n\t\t\t   unsigned long offset,\n\t\t\t   int relocated)\n{\n\tunsigned long hashval;\n\tstruct inode *inode;\n\tstruct isofs_iget5_callback_data data;\n\tlong ret;\n\n\tif (offset >= 1ul << sb->s_blocksize_bits)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdata.block = block;\n\tdata.offset = offset;\n\n\thashval = (block << sb->s_blocksize_bits) | offset;\n\n\tinode = iget5_locked(sb, hashval, &isofs_iget5_test,\n\t\t\t\t&isofs_iget5_set, &data);\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (inode->i_state & I_NEW) {\n\t\tret = isofs_read_inode(inode, relocated);\n\t\tif (ret < 0) {\n\t\t\tiget_failed(inode);\n\t\t\tinode = ERR_PTR(ret);\n\t\t} else {\n\t\t\tunlock_new_inode(inode);\n\t\t}\n\t}\n\n\treturn inode;\n}\n\nstatic struct dentry *isofs_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, isofs_fill_super);\n}\n\nstatic struct file_system_type iso9660_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"iso9660\",\n\t.mount\t\t= isofs_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\nMODULE_ALIAS_FS(\"iso9660\");\nMODULE_ALIAS(\"iso9660\");\n\nstatic int __init init_iso9660_fs(void)\n{\n\tint err = init_inodecache();\n\tif (err)\n\t\tgoto out;\n#ifdef CONFIG_ZISOFS\n\terr = zisofs_init();\n\tif (err)\n\t\tgoto out1;\n#endif\n\terr = register_filesystem(&iso9660_fs_type);\n\tif (err)\n\t\tgoto out2;\n\treturn 0;\nout2:\n#ifdef CONFIG_ZISOFS\n\tzisofs_cleanup();\nout1:\n#endif\n\tdestroy_inodecache();\nout:\n\treturn err;\n}\n\nstatic void __exit exit_iso9660_fs(void)\n{\n        unregister_filesystem(&iso9660_fs_type);\n#ifdef CONFIG_ZISOFS\n\tzisofs_cleanup();\n#endif\n\tdestroy_inodecache();\n}\n\nmodule_init(init_iso9660_fs)\nmodule_exit(exit_iso9660_fs)\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}