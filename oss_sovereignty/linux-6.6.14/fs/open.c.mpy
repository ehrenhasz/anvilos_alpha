{
  "module_name": "open.c",
  "hash_id": "556ec265e710ed0b87c557a66844269a86c23cf4b1713439e0209af029f971f7",
  "original_prompt": "Ingested from linux-6.6.14/fs/open.c",
  "human_readable_source": "\n \n\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/fsnotify.h>\n#include <linux/module.h>\n#include <linux/tty.h>\n#include <linux/namei.h>\n#include <linux/backing-dev.h>\n#include <linux/capability.h>\n#include <linux/securebits.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/fcntl.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/personality.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/rcupdate.h>\n#include <linux/audit.h>\n#include <linux/falloc.h>\n#include <linux/fs_struct.h>\n#include <linux/ima.h>\n#include <linux/dnotify.h>\n#include <linux/compat.h>\n#include <linux/mnt_idmapping.h>\n#include <linux/filelock.h>\n\n#include \"internal.h\"\n\nint do_truncate(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\tloff_t length, unsigned int time_attrs, struct file *filp)\n{\n\tint ret;\n\tstruct iattr newattrs;\n\n\t \n\tif (length < 0)\n\t\treturn -EINVAL;\n\n\tnewattrs.ia_size = length;\n\tnewattrs.ia_valid = ATTR_SIZE | time_attrs;\n\tif (filp) {\n\t\tnewattrs.ia_file = filp;\n\t\tnewattrs.ia_valid |= ATTR_FILE;\n\t}\n\n\t \n\tret = dentry_needs_remove_privs(idmap, dentry);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret)\n\t\tnewattrs.ia_valid |= ret | ATTR_FORCE;\n\n\tinode_lock(dentry->d_inode);\n\t \n\tret = notify_change(idmap, dentry, &newattrs, NULL);\n\tinode_unlock(dentry->d_inode);\n\treturn ret;\n}\n\nlong vfs_truncate(const struct path *path, loff_t length)\n{\n\tstruct mnt_idmap *idmap;\n\tstruct inode *inode;\n\tlong error;\n\n\tinode = path->dentry->d_inode;\n\n\t \n\tif (S_ISDIR(inode->i_mode))\n\t\treturn -EISDIR;\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\n\terror = mnt_want_write(path->mnt);\n\tif (error)\n\t\tgoto out;\n\n\tidmap = mnt_idmap(path->mnt);\n\terror = inode_permission(idmap, inode, MAY_WRITE);\n\tif (error)\n\t\tgoto mnt_drop_write_and_out;\n\n\terror = -EPERM;\n\tif (IS_APPEND(inode))\n\t\tgoto mnt_drop_write_and_out;\n\n\terror = get_write_access(inode);\n\tif (error)\n\t\tgoto mnt_drop_write_and_out;\n\n\t \n\terror = break_lease(inode, O_WRONLY);\n\tif (error)\n\t\tgoto put_write_and_out;\n\n\terror = security_path_truncate(path);\n\tif (!error)\n\t\terror = do_truncate(idmap, path->dentry, length, 0, NULL);\n\nput_write_and_out:\n\tput_write_access(inode);\nmnt_drop_write_and_out:\n\tmnt_drop_write(path->mnt);\nout:\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(vfs_truncate);\n\nlong do_sys_truncate(const char __user *pathname, loff_t length)\n{\n\tunsigned int lookup_flags = LOOKUP_FOLLOW;\n\tstruct path path;\n\tint error;\n\n\tif (length < 0)\t \n\t\treturn -EINVAL;\n\nretry:\n\terror = user_path_at(AT_FDCWD, pathname, lookup_flags, &path);\n\tif (!error) {\n\t\terror = vfs_truncate(&path, length);\n\t\tpath_put(&path);\n\t}\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\n\treturn error;\n}\n\nSYSCALL_DEFINE2(truncate, const char __user *, path, long, length)\n{\n\treturn do_sys_truncate(path, length);\n}\n\n#ifdef CONFIG_COMPAT\nCOMPAT_SYSCALL_DEFINE2(truncate, const char __user *, path, compat_off_t, length)\n{\n\treturn do_sys_truncate(path, length);\n}\n#endif\n\nlong do_sys_ftruncate(unsigned int fd, loff_t length, int small)\n{\n\tstruct inode *inode;\n\tstruct dentry *dentry;\n\tstruct fd f;\n\tint error;\n\n\terror = -EINVAL;\n\tif (length < 0)\n\t\tgoto out;\n\terror = -EBADF;\n\tf = fdget(fd);\n\tif (!f.file)\n\t\tgoto out;\n\n\t \n\tif (f.file->f_flags & O_LARGEFILE)\n\t\tsmall = 0;\n\n\tdentry = f.file->f_path.dentry;\n\tinode = dentry->d_inode;\n\terror = -EINVAL;\n\tif (!S_ISREG(inode->i_mode) || !(f.file->f_mode & FMODE_WRITE))\n\t\tgoto out_putf;\n\n\terror = -EINVAL;\n\t \n\tif (small && length > MAX_NON_LFS)\n\t\tgoto out_putf;\n\n\terror = -EPERM;\n\t \n\tif (IS_APPEND(file_inode(f.file)))\n\t\tgoto out_putf;\n\tsb_start_write(inode->i_sb);\n\terror = security_file_truncate(f.file);\n\tif (!error)\n\t\terror = do_truncate(file_mnt_idmap(f.file), dentry, length,\n\t\t\t\t    ATTR_MTIME | ATTR_CTIME, f.file);\n\tsb_end_write(inode->i_sb);\nout_putf:\n\tfdput(f);\nout:\n\treturn error;\n}\n\nSYSCALL_DEFINE2(ftruncate, unsigned int, fd, unsigned long, length)\n{\n\treturn do_sys_ftruncate(fd, length, 1);\n}\n\n#ifdef CONFIG_COMPAT\nCOMPAT_SYSCALL_DEFINE2(ftruncate, unsigned int, fd, compat_ulong_t, length)\n{\n\treturn do_sys_ftruncate(fd, length, 1);\n}\n#endif\n\n \n#if BITS_PER_LONG == 32\nSYSCALL_DEFINE2(truncate64, const char __user *, path, loff_t, length)\n{\n\treturn do_sys_truncate(path, length);\n}\n\nSYSCALL_DEFINE2(ftruncate64, unsigned int, fd, loff_t, length)\n{\n\treturn do_sys_ftruncate(fd, length, 0);\n}\n#endif  \n\n#if defined(CONFIG_COMPAT) && defined(__ARCH_WANT_COMPAT_TRUNCATE64)\nCOMPAT_SYSCALL_DEFINE3(truncate64, const char __user *, pathname,\n\t\t       compat_arg_u64_dual(length))\n{\n\treturn ksys_truncate(pathname, compat_arg_u64_glue(length));\n}\n#endif\n\n#if defined(CONFIG_COMPAT) && defined(__ARCH_WANT_COMPAT_FTRUNCATE64)\nCOMPAT_SYSCALL_DEFINE3(ftruncate64, unsigned int, fd,\n\t\t       compat_arg_u64_dual(length))\n{\n\treturn ksys_ftruncate(fd, compat_arg_u64_glue(length));\n}\n#endif\n\nint vfs_fallocate(struct file *file, int mode, loff_t offset, loff_t len)\n{\n\tstruct inode *inode = file_inode(file);\n\tlong ret;\n\n\tif (offset < 0 || len <= 0)\n\t\treturn -EINVAL;\n\n\t \n\tif (mode & ~FALLOC_FL_SUPPORTED_MASK)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif ((mode & (FALLOC_FL_PUNCH_HOLE | FALLOC_FL_ZERO_RANGE)) ==\n\t    (FALLOC_FL_PUNCH_HOLE | FALLOC_FL_ZERO_RANGE))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif ((mode & FALLOC_FL_PUNCH_HOLE) &&\n\t    !(mode & FALLOC_FL_KEEP_SIZE))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif ((mode & FALLOC_FL_COLLAPSE_RANGE) &&\n\t    (mode & ~FALLOC_FL_COLLAPSE_RANGE))\n\t\treturn -EINVAL;\n\n\t \n\tif ((mode & FALLOC_FL_INSERT_RANGE) &&\n\t    (mode & ~FALLOC_FL_INSERT_RANGE))\n\t\treturn -EINVAL;\n\n\t \n\tif ((mode & FALLOC_FL_UNSHARE_RANGE) &&\n\t    (mode & ~(FALLOC_FL_UNSHARE_RANGE | FALLOC_FL_KEEP_SIZE)))\n\t\treturn -EINVAL;\n\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\treturn -EBADF;\n\n\t \n\tif ((mode & ~FALLOC_FL_KEEP_SIZE) && IS_APPEND(inode))\n\t\treturn -EPERM;\n\n\tif (IS_IMMUTABLE(inode))\n\t\treturn -EPERM;\n\n\t \n\tif (IS_SWAPFILE(inode))\n\t\treturn -ETXTBSY;\n\n\t \n\tret = security_file_permission(file, MAY_WRITE);\n\tif (ret)\n\t\treturn ret;\n\n\tif (S_ISFIFO(inode->i_mode))\n\t\treturn -ESPIPE;\n\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn -EISDIR;\n\n\tif (!S_ISREG(inode->i_mode) && !S_ISBLK(inode->i_mode))\n\t\treturn -ENODEV;\n\n\t \n\tif (((offset + len) > inode->i_sb->s_maxbytes) || ((offset + len) < 0))\n\t\treturn -EFBIG;\n\n\tif (!file->f_op->fallocate)\n\t\treturn -EOPNOTSUPP;\n\n\tfile_start_write(file);\n\tret = file->f_op->fallocate(file, mode, offset, len);\n\n\t \n\tif (ret == 0)\n\t\tfsnotify_modify(file);\n\n\tfile_end_write(file);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(vfs_fallocate);\n\nint ksys_fallocate(int fd, int mode, loff_t offset, loff_t len)\n{\n\tstruct fd f = fdget(fd);\n\tint error = -EBADF;\n\n\tif (f.file) {\n\t\terror = vfs_fallocate(f.file, mode, offset, len);\n\t\tfdput(f);\n\t}\n\treturn error;\n}\n\nSYSCALL_DEFINE4(fallocate, int, fd, int, mode, loff_t, offset, loff_t, len)\n{\n\treturn ksys_fallocate(fd, mode, offset, len);\n}\n\n#if defined(CONFIG_COMPAT) && defined(__ARCH_WANT_COMPAT_FALLOCATE)\nCOMPAT_SYSCALL_DEFINE6(fallocate, int, fd, int, mode, compat_arg_u64_dual(offset),\n\t\t       compat_arg_u64_dual(len))\n{\n\treturn ksys_fallocate(fd, mode, compat_arg_u64_glue(offset),\n\t\t\t      compat_arg_u64_glue(len));\n}\n#endif\n\n \nstatic bool access_need_override_creds(int flags)\n{\n\tconst struct cred *cred;\n\n\tif (flags & AT_EACCESS)\n\t\treturn false;\n\n\tcred = current_cred();\n\tif (!uid_eq(cred->fsuid, cred->uid) ||\n\t    !gid_eq(cred->fsgid, cred->gid))\n\t\treturn true;\n\n\tif (!issecure(SECURE_NO_SETUID_FIXUP)) {\n\t\tkuid_t root_uid = make_kuid(cred->user_ns, 0);\n\t\tif (!uid_eq(cred->uid, root_uid)) {\n\t\t\tif (!cap_isclear(cred->cap_effective))\n\t\t\t\treturn true;\n\t\t} else {\n\t\t\tif (!cap_isidentical(cred->cap_effective,\n\t\t\t    cred->cap_permitted))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic const struct cred *access_override_creds(void)\n{\n\tconst struct cred *old_cred;\n\tstruct cred *override_cred;\n\n\toverride_cred = prepare_creds();\n\tif (!override_cred)\n\t\treturn NULL;\n\n\t \n\n\toverride_cred->fsuid = override_cred->uid;\n\toverride_cred->fsgid = override_cred->gid;\n\n\tif (!issecure(SECURE_NO_SETUID_FIXUP)) {\n\t\t \n\t\tkuid_t root_uid = make_kuid(override_cred->user_ns, 0);\n\t\tif (!uid_eq(override_cred->uid, root_uid))\n\t\t\tcap_clear(override_cred->cap_effective);\n\t\telse\n\t\t\toverride_cred->cap_effective =\n\t\t\t\toverride_cred->cap_permitted;\n\t}\n\n\t \n\toverride_cred->non_rcu = 1;\n\n\told_cred = override_creds(override_cred);\n\n\t \n\tput_cred(override_cred);\n\n\treturn old_cred;\n}\n\nstatic long do_faccessat(int dfd, const char __user *filename, int mode, int flags)\n{\n\tstruct path path;\n\tstruct inode *inode;\n\tint res;\n\tunsigned int lookup_flags = LOOKUP_FOLLOW;\n\tconst struct cred *old_cred = NULL;\n\n\tif (mode & ~S_IRWXO)\t \n\t\treturn -EINVAL;\n\n\tif (flags & ~(AT_EACCESS | AT_SYMLINK_NOFOLLOW | AT_EMPTY_PATH))\n\t\treturn -EINVAL;\n\n\tif (flags & AT_SYMLINK_NOFOLLOW)\n\t\tlookup_flags &= ~LOOKUP_FOLLOW;\n\tif (flags & AT_EMPTY_PATH)\n\t\tlookup_flags |= LOOKUP_EMPTY;\n\n\tif (access_need_override_creds(flags)) {\n\t\told_cred = access_override_creds();\n\t\tif (!old_cred)\n\t\t\treturn -ENOMEM;\n\t}\n\nretry:\n\tres = user_path_at(dfd, filename, lookup_flags, &path);\n\tif (res)\n\t\tgoto out;\n\n\tinode = d_backing_inode(path.dentry);\n\n\tif ((mode & MAY_EXEC) && S_ISREG(inode->i_mode)) {\n\t\t \n\t\tres = -EACCES;\n\t\tif (path_noexec(&path))\n\t\t\tgoto out_path_release;\n\t}\n\n\tres = inode_permission(mnt_idmap(path.mnt), inode, mode | MAY_ACCESS);\n\t \n\tif (res || !(mode & S_IWOTH) || special_file(inode->i_mode))\n\t\tgoto out_path_release;\n\t \n\tif (__mnt_is_readonly(path.mnt))\n\t\tres = -EROFS;\n\nout_path_release:\n\tpath_put(&path);\n\tif (retry_estale(res, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\nout:\n\tif (old_cred)\n\t\trevert_creds(old_cred);\n\n\treturn res;\n}\n\nSYSCALL_DEFINE3(faccessat, int, dfd, const char __user *, filename, int, mode)\n{\n\treturn do_faccessat(dfd, filename, mode, 0);\n}\n\nSYSCALL_DEFINE4(faccessat2, int, dfd, const char __user *, filename, int, mode,\n\t\tint, flags)\n{\n\treturn do_faccessat(dfd, filename, mode, flags);\n}\n\nSYSCALL_DEFINE2(access, const char __user *, filename, int, mode)\n{\n\treturn do_faccessat(AT_FDCWD, filename, mode, 0);\n}\n\nSYSCALL_DEFINE1(chdir, const char __user *, filename)\n{\n\tstruct path path;\n\tint error;\n\tunsigned int lookup_flags = LOOKUP_FOLLOW | LOOKUP_DIRECTORY;\nretry:\n\terror = user_path_at(AT_FDCWD, filename, lookup_flags, &path);\n\tif (error)\n\t\tgoto out;\n\n\terror = path_permission(&path, MAY_EXEC | MAY_CHDIR);\n\tif (error)\n\t\tgoto dput_and_out;\n\n\tset_fs_pwd(current->fs, &path);\n\ndput_and_out:\n\tpath_put(&path);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\nout:\n\treturn error;\n}\n\nSYSCALL_DEFINE1(fchdir, unsigned int, fd)\n{\n\tstruct fd f = fdget_raw(fd);\n\tint error;\n\n\terror = -EBADF;\n\tif (!f.file)\n\t\tgoto out;\n\n\terror = -ENOTDIR;\n\tif (!d_can_lookup(f.file->f_path.dentry))\n\t\tgoto out_putf;\n\n\terror = file_permission(f.file, MAY_EXEC | MAY_CHDIR);\n\tif (!error)\n\t\tset_fs_pwd(current->fs, &f.file->f_path);\nout_putf:\n\tfdput(f);\nout:\n\treturn error;\n}\n\nSYSCALL_DEFINE1(chroot, const char __user *, filename)\n{\n\tstruct path path;\n\tint error;\n\tunsigned int lookup_flags = LOOKUP_FOLLOW | LOOKUP_DIRECTORY;\nretry:\n\terror = user_path_at(AT_FDCWD, filename, lookup_flags, &path);\n\tif (error)\n\t\tgoto out;\n\n\terror = path_permission(&path, MAY_EXEC | MAY_CHDIR);\n\tif (error)\n\t\tgoto dput_and_out;\n\n\terror = -EPERM;\n\tif (!ns_capable(current_user_ns(), CAP_SYS_CHROOT))\n\t\tgoto dput_and_out;\n\terror = security_path_chroot(&path);\n\tif (error)\n\t\tgoto dput_and_out;\n\n\tset_fs_root(current->fs, &path);\n\terror = 0;\ndput_and_out:\n\tpath_put(&path);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\nout:\n\treturn error;\n}\n\nint chmod_common(const struct path *path, umode_t mode)\n{\n\tstruct inode *inode = path->dentry->d_inode;\n\tstruct inode *delegated_inode = NULL;\n\tstruct iattr newattrs;\n\tint error;\n\n\terror = mnt_want_write(path->mnt);\n\tif (error)\n\t\treturn error;\nretry_deleg:\n\tinode_lock(inode);\n\terror = security_path_chmod(path, mode);\n\tif (error)\n\t\tgoto out_unlock;\n\tnewattrs.ia_mode = (mode & S_IALLUGO) | (inode->i_mode & ~S_IALLUGO);\n\tnewattrs.ia_valid = ATTR_MODE | ATTR_CTIME;\n\terror = notify_change(mnt_idmap(path->mnt), path->dentry,\n\t\t\t      &newattrs, &delegated_inode);\nout_unlock:\n\tinode_unlock(inode);\n\tif (delegated_inode) {\n\t\terror = break_deleg_wait(&delegated_inode);\n\t\tif (!error)\n\t\t\tgoto retry_deleg;\n\t}\n\tmnt_drop_write(path->mnt);\n\treturn error;\n}\n\nint vfs_fchmod(struct file *file, umode_t mode)\n{\n\taudit_file(file);\n\treturn chmod_common(&file->f_path, mode);\n}\n\nSYSCALL_DEFINE2(fchmod, unsigned int, fd, umode_t, mode)\n{\n\tstruct fd f = fdget(fd);\n\tint err = -EBADF;\n\n\tif (f.file) {\n\t\terr = vfs_fchmod(f.file, mode);\n\t\tfdput(f);\n\t}\n\treturn err;\n}\n\nstatic int do_fchmodat(int dfd, const char __user *filename, umode_t mode,\n\t\t       unsigned int flags)\n{\n\tstruct path path;\n\tint error;\n\tunsigned int lookup_flags;\n\n\tif (unlikely(flags & ~(AT_SYMLINK_NOFOLLOW | AT_EMPTY_PATH)))\n\t\treturn -EINVAL;\n\n\tlookup_flags = (flags & AT_SYMLINK_NOFOLLOW) ? 0 : LOOKUP_FOLLOW;\n\tif (flags & AT_EMPTY_PATH)\n\t\tlookup_flags |= LOOKUP_EMPTY;\n\nretry:\n\terror = user_path_at(dfd, filename, lookup_flags, &path);\n\tif (!error) {\n\t\terror = chmod_common(&path, mode);\n\t\tpath_put(&path);\n\t\tif (retry_estale(error, lookup_flags)) {\n\t\t\tlookup_flags |= LOOKUP_REVAL;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\treturn error;\n}\n\nSYSCALL_DEFINE4(fchmodat2, int, dfd, const char __user *, filename,\n\t\tumode_t, mode, unsigned int, flags)\n{\n\treturn do_fchmodat(dfd, filename, mode, flags);\n}\n\nSYSCALL_DEFINE3(fchmodat, int, dfd, const char __user *, filename,\n\t\tumode_t, mode)\n{\n\treturn do_fchmodat(dfd, filename, mode, 0);\n}\n\nSYSCALL_DEFINE2(chmod, const char __user *, filename, umode_t, mode)\n{\n\treturn do_fchmodat(AT_FDCWD, filename, mode, 0);\n}\n\n \nstatic inline bool setattr_vfsuid(struct iattr *attr, kuid_t kuid)\n{\n\tif (!uid_valid(kuid))\n\t\treturn false;\n\tattr->ia_valid |= ATTR_UID;\n\tattr->ia_vfsuid = VFSUIDT_INIT(kuid);\n\treturn true;\n}\n\n \nstatic inline bool setattr_vfsgid(struct iattr *attr, kgid_t kgid)\n{\n\tif (!gid_valid(kgid))\n\t\treturn false;\n\tattr->ia_valid |= ATTR_GID;\n\tattr->ia_vfsgid = VFSGIDT_INIT(kgid);\n\treturn true;\n}\n\nint chown_common(const struct path *path, uid_t user, gid_t group)\n{\n\tstruct mnt_idmap *idmap;\n\tstruct user_namespace *fs_userns;\n\tstruct inode *inode = path->dentry->d_inode;\n\tstruct inode *delegated_inode = NULL;\n\tint error;\n\tstruct iattr newattrs;\n\tkuid_t uid;\n\tkgid_t gid;\n\n\tuid = make_kuid(current_user_ns(), user);\n\tgid = make_kgid(current_user_ns(), group);\n\n\tidmap = mnt_idmap(path->mnt);\n\tfs_userns = i_user_ns(inode);\n\nretry_deleg:\n\tnewattrs.ia_vfsuid = INVALID_VFSUID;\n\tnewattrs.ia_vfsgid = INVALID_VFSGID;\n\tnewattrs.ia_valid =  ATTR_CTIME;\n\tif ((user != (uid_t)-1) && !setattr_vfsuid(&newattrs, uid))\n\t\treturn -EINVAL;\n\tif ((group != (gid_t)-1) && !setattr_vfsgid(&newattrs, gid))\n\t\treturn -EINVAL;\n\tinode_lock(inode);\n\tif (!S_ISDIR(inode->i_mode))\n\t\tnewattrs.ia_valid |= ATTR_KILL_SUID | ATTR_KILL_PRIV |\n\t\t\t\t     setattr_should_drop_sgid(idmap, inode);\n\t \n\terror = security_path_chown(\n\t\tpath,\n\t\tfrom_vfsuid(idmap, fs_userns, newattrs.ia_vfsuid),\n\t\tfrom_vfsgid(idmap, fs_userns, newattrs.ia_vfsgid));\n\tif (!error)\n\t\terror = notify_change(idmap, path->dentry, &newattrs,\n\t\t\t\t      &delegated_inode);\n\tinode_unlock(inode);\n\tif (delegated_inode) {\n\t\terror = break_deleg_wait(&delegated_inode);\n\t\tif (!error)\n\t\t\tgoto retry_deleg;\n\t}\n\treturn error;\n}\n\nint do_fchownat(int dfd, const char __user *filename, uid_t user, gid_t group,\n\t\tint flag)\n{\n\tstruct path path;\n\tint error = -EINVAL;\n\tint lookup_flags;\n\n\tif ((flag & ~(AT_SYMLINK_NOFOLLOW | AT_EMPTY_PATH)) != 0)\n\t\tgoto out;\n\n\tlookup_flags = (flag & AT_SYMLINK_NOFOLLOW) ? 0 : LOOKUP_FOLLOW;\n\tif (flag & AT_EMPTY_PATH)\n\t\tlookup_flags |= LOOKUP_EMPTY;\nretry:\n\terror = user_path_at(dfd, filename, lookup_flags, &path);\n\tif (error)\n\t\tgoto out;\n\terror = mnt_want_write(path.mnt);\n\tif (error)\n\t\tgoto out_release;\n\terror = chown_common(&path, user, group);\n\tmnt_drop_write(path.mnt);\nout_release:\n\tpath_put(&path);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\nout:\n\treturn error;\n}\n\nSYSCALL_DEFINE5(fchownat, int, dfd, const char __user *, filename, uid_t, user,\n\t\tgid_t, group, int, flag)\n{\n\treturn do_fchownat(dfd, filename, user, group, flag);\n}\n\nSYSCALL_DEFINE3(chown, const char __user *, filename, uid_t, user, gid_t, group)\n{\n\treturn do_fchownat(AT_FDCWD, filename, user, group, 0);\n}\n\nSYSCALL_DEFINE3(lchown, const char __user *, filename, uid_t, user, gid_t, group)\n{\n\treturn do_fchownat(AT_FDCWD, filename, user, group,\n\t\t\t   AT_SYMLINK_NOFOLLOW);\n}\n\nint vfs_fchown(struct file *file, uid_t user, gid_t group)\n{\n\tint error;\n\n\terror = mnt_want_write_file(file);\n\tif (error)\n\t\treturn error;\n\taudit_file(file);\n\terror = chown_common(&file->f_path, user, group);\n\tmnt_drop_write_file(file);\n\treturn error;\n}\n\nint ksys_fchown(unsigned int fd, uid_t user, gid_t group)\n{\n\tstruct fd f = fdget(fd);\n\tint error = -EBADF;\n\n\tif (f.file) {\n\t\terror = vfs_fchown(f.file, user, group);\n\t\tfdput(f);\n\t}\n\treturn error;\n}\n\nSYSCALL_DEFINE3(fchown, unsigned int, fd, uid_t, user, gid_t, group)\n{\n\treturn ksys_fchown(fd, user, group);\n}\n\nstatic int do_dentry_open(struct file *f,\n\t\t\t  struct inode *inode,\n\t\t\t  int (*open)(struct inode *, struct file *))\n{\n\tstatic const struct file_operations empty_fops = {};\n\tint error;\n\n\tpath_get(&f->f_path);\n\tf->f_inode = inode;\n\tf->f_mapping = inode->i_mapping;\n\tf->f_wb_err = filemap_sample_wb_err(f->f_mapping);\n\tf->f_sb_err = file_sample_sb_err(f);\n\n\tif (unlikely(f->f_flags & O_PATH)) {\n\t\tf->f_mode = FMODE_PATH | FMODE_OPENED;\n\t\tf->f_op = &empty_fops;\n\t\treturn 0;\n\t}\n\n\tif ((f->f_mode & (FMODE_READ | FMODE_WRITE)) == FMODE_READ) {\n\t\ti_readcount_inc(inode);\n\t} else if (f->f_mode & FMODE_WRITE && !special_file(inode->i_mode)) {\n\t\terror = get_write_access(inode);\n\t\tif (unlikely(error))\n\t\t\tgoto cleanup_file;\n\t\terror = __mnt_want_write(f->f_path.mnt);\n\t\tif (unlikely(error)) {\n\t\t\tput_write_access(inode);\n\t\t\tgoto cleanup_file;\n\t\t}\n\t\tf->f_mode |= FMODE_WRITER;\n\t}\n\n\t \n\tif (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode))\n\t\tf->f_mode |= FMODE_ATOMIC_POS;\n\n\tf->f_op = fops_get(inode->i_fop);\n\tif (WARN_ON(!f->f_op)) {\n\t\terror = -ENODEV;\n\t\tgoto cleanup_all;\n\t}\n\n\terror = security_file_open(f);\n\tif (error)\n\t\tgoto cleanup_all;\n\n\terror = break_lease(file_inode(f), f->f_flags);\n\tif (error)\n\t\tgoto cleanup_all;\n\n\t \n\tf->f_mode |= FMODE_LSEEK | FMODE_PREAD | FMODE_PWRITE;\n\tif (!open)\n\t\topen = f->f_op->open;\n\tif (open) {\n\t\terror = open(inode, f);\n\t\tif (error)\n\t\t\tgoto cleanup_all;\n\t}\n\tf->f_mode |= FMODE_OPENED;\n\tif ((f->f_mode & FMODE_READ) &&\n\t     likely(f->f_op->read || f->f_op->read_iter))\n\t\tf->f_mode |= FMODE_CAN_READ;\n\tif ((f->f_mode & FMODE_WRITE) &&\n\t     likely(f->f_op->write || f->f_op->write_iter))\n\t\tf->f_mode |= FMODE_CAN_WRITE;\n\tif ((f->f_mode & FMODE_LSEEK) && !f->f_op->llseek)\n\t\tf->f_mode &= ~FMODE_LSEEK;\n\tif (f->f_mapping->a_ops && f->f_mapping->a_ops->direct_IO)\n\t\tf->f_mode |= FMODE_CAN_ODIRECT;\n\n\tf->f_flags &= ~(O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC);\n\tf->f_iocb_flags = iocb_flags(f);\n\n\tfile_ra_state_init(&f->f_ra, f->f_mapping->host->i_mapping);\n\n\tif ((f->f_flags & O_DIRECT) && !(f->f_mode & FMODE_CAN_ODIRECT))\n\t\treturn -EINVAL;\n\n\t \n\tif (f->f_mode & FMODE_WRITE) {\n\t\t \n\t\tsmp_mb();\n\t\tif (filemap_nr_thps(inode->i_mapping)) {\n\t\t\tstruct address_space *mapping = inode->i_mapping;\n\n\t\t\tfilemap_invalidate_lock(inode->i_mapping);\n\t\t\t \n\t\t\tunmap_mapping_range(mapping, 0, 0, 0);\n\t\t\ttruncate_inode_pages(mapping, 0);\n\t\t\tfilemap_invalidate_unlock(inode->i_mapping);\n\t\t}\n\t}\n\n\t \n\tfsnotify_open(f);\n\treturn 0;\n\ncleanup_all:\n\tif (WARN_ON_ONCE(error > 0))\n\t\terror = -EINVAL;\n\tfops_put(f->f_op);\n\tput_file_access(f);\ncleanup_file:\n\tpath_put(&f->f_path);\n\tf->f_path.mnt = NULL;\n\tf->f_path.dentry = NULL;\n\tf->f_inode = NULL;\n\treturn error;\n}\n\n \nint finish_open(struct file *file, struct dentry *dentry,\n\t\tint (*open)(struct inode *, struct file *))\n{\n\tBUG_ON(file->f_mode & FMODE_OPENED);  \n\n\tfile->f_path.dentry = dentry;\n\treturn do_dentry_open(file, d_backing_inode(dentry), open);\n}\nEXPORT_SYMBOL(finish_open);\n\n \nint finish_no_open(struct file *file, struct dentry *dentry)\n{\n\tfile->f_path.dentry = dentry;\n\treturn 0;\n}\nEXPORT_SYMBOL(finish_no_open);\n\nchar *file_path(struct file *filp, char *buf, int buflen)\n{\n\treturn d_path(&filp->f_path, buf, buflen);\n}\nEXPORT_SYMBOL(file_path);\n\n \nint vfs_open(const struct path *path, struct file *file)\n{\n\tfile->f_path = *path;\n\treturn do_dentry_open(file, d_backing_inode(path->dentry), NULL);\n}\n\nstruct file *dentry_open(const struct path *path, int flags,\n\t\t\t const struct cred *cred)\n{\n\tint error;\n\tstruct file *f;\n\n\t \n\tBUG_ON(!path->mnt);\n\n\tf = alloc_empty_file(flags, cred);\n\tif (!IS_ERR(f)) {\n\t\terror = vfs_open(path, f);\n\t\tif (error) {\n\t\t\tfput(f);\n\t\t\tf = ERR_PTR(error);\n\t\t}\n\t}\n\treturn f;\n}\nEXPORT_SYMBOL(dentry_open);\n\n \nstruct file *dentry_create(const struct path *path, int flags, umode_t mode,\n\t\t\t   const struct cred *cred)\n{\n\tstruct file *f;\n\tint error;\n\n\tf = alloc_empty_file(flags, cred);\n\tif (IS_ERR(f))\n\t\treturn f;\n\n\terror = vfs_create(mnt_idmap(path->mnt),\n\t\t\t   d_inode(path->dentry->d_parent),\n\t\t\t   path->dentry, mode, true);\n\tif (!error)\n\t\terror = vfs_open(path, f);\n\n\tif (unlikely(error)) {\n\t\tfput(f);\n\t\treturn ERR_PTR(error);\n\t}\n\treturn f;\n}\nEXPORT_SYMBOL(dentry_create);\n\n \nstruct file *kernel_file_open(const struct path *path, int flags,\n\t\t\t\tstruct inode *inode, const struct cred *cred)\n{\n\tstruct file *f;\n\tint error;\n\n\tf = alloc_empty_file_noaccount(flags, cred);\n\tif (IS_ERR(f))\n\t\treturn f;\n\n\tf->f_path = *path;\n\terror = do_dentry_open(f, inode, NULL);\n\tif (error) {\n\t\tfput(f);\n\t\tf = ERR_PTR(error);\n\t}\n\treturn f;\n}\nEXPORT_SYMBOL_GPL(kernel_file_open);\n\n \nstruct file *backing_file_open(const struct path *path, int flags,\n\t\t\t       const struct path *real_path,\n\t\t\t       const struct cred *cred)\n{\n\tstruct file *f;\n\tint error;\n\n\tf = alloc_empty_backing_file(flags, cred);\n\tif (IS_ERR(f))\n\t\treturn f;\n\n\tf->f_path = *path;\n\tpath_get(real_path);\n\t*backing_file_real_path(f) = *real_path;\n\terror = do_dentry_open(f, d_inode(real_path->dentry), NULL);\n\tif (error) {\n\t\tfput(f);\n\t\tf = ERR_PTR(error);\n\t}\n\n\treturn f;\n}\nEXPORT_SYMBOL_GPL(backing_file_open);\n\n#define WILL_CREATE(flags)\t(flags & (O_CREAT | __O_TMPFILE))\n#define O_PATH_FLAGS\t\t(O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC)\n\ninline struct open_how build_open_how(int flags, umode_t mode)\n{\n\tstruct open_how how = {\n\t\t.flags = flags & VALID_OPEN_FLAGS,\n\t\t.mode = mode & S_IALLUGO,\n\t};\n\n\t \n\tif (how.flags & O_PATH)\n\t\thow.flags &= O_PATH_FLAGS;\n\t \n\tif (!WILL_CREATE(how.flags))\n\t\thow.mode = 0;\n\treturn how;\n}\n\ninline int build_open_flags(const struct open_how *how, struct open_flags *op)\n{\n\tu64 flags = how->flags;\n\tu64 strip = __FMODE_NONOTIFY | O_CLOEXEC;\n\tint lookup_flags = 0;\n\tint acc_mode = ACC_MODE(flags);\n\n\tBUILD_BUG_ON_MSG(upper_32_bits(VALID_OPEN_FLAGS),\n\t\t\t \"struct open_flags doesn't yet handle flags > 32 bits\");\n\n\t \n\tflags &= ~strip;\n\n\t \n\tif (flags & ~VALID_OPEN_FLAGS)\n\t\treturn -EINVAL;\n\tif (how->resolve & ~VALID_RESOLVE_FLAGS)\n\t\treturn -EINVAL;\n\n\t \n\tif ((how->resolve & RESOLVE_BENEATH) && (how->resolve & RESOLVE_IN_ROOT))\n\t\treturn -EINVAL;\n\n\t \n\tif (WILL_CREATE(flags)) {\n\t\tif (how->mode & ~S_IALLUGO)\n\t\t\treturn -EINVAL;\n\t\top->mode = how->mode | S_IFREG;\n\t} else {\n\t\tif (how->mode != 0)\n\t\t\treturn -EINVAL;\n\t\top->mode = 0;\n\t}\n\n\t \n\tif ((flags & (O_DIRECTORY | O_CREAT)) == (O_DIRECTORY | O_CREAT))\n\t\treturn -EINVAL;\n\n\t \n\tif (flags & __O_TMPFILE) {\n\t\t \n\t\tif (!(flags & O_DIRECTORY))\n\t\t\treturn -EINVAL;\n\t\tif (!(acc_mode & MAY_WRITE))\n\t\t\treturn -EINVAL;\n\t}\n\tif (flags & O_PATH) {\n\t\t \n\t\tif (flags & ~O_PATH_FLAGS)\n\t\t\treturn -EINVAL;\n\t\tacc_mode = 0;\n\t}\n\n\t \n\tif (flags & __O_SYNC)\n\t\tflags |= O_DSYNC;\n\n\top->open_flag = flags;\n\n\t \n\tif (flags & O_TRUNC)\n\t\tacc_mode |= MAY_WRITE;\n\n\t \n\tif (flags & O_APPEND)\n\t\tacc_mode |= MAY_APPEND;\n\n\top->acc_mode = acc_mode;\n\n\top->intent = flags & O_PATH ? 0 : LOOKUP_OPEN;\n\n\tif (flags & O_CREAT) {\n\t\top->intent |= LOOKUP_CREATE;\n\t\tif (flags & O_EXCL) {\n\t\t\top->intent |= LOOKUP_EXCL;\n\t\t\tflags |= O_NOFOLLOW;\n\t\t}\n\t}\n\n\tif (flags & O_DIRECTORY)\n\t\tlookup_flags |= LOOKUP_DIRECTORY;\n\tif (!(flags & O_NOFOLLOW))\n\t\tlookup_flags |= LOOKUP_FOLLOW;\n\n\tif (how->resolve & RESOLVE_NO_XDEV)\n\t\tlookup_flags |= LOOKUP_NO_XDEV;\n\tif (how->resolve & RESOLVE_NO_MAGICLINKS)\n\t\tlookup_flags |= LOOKUP_NO_MAGICLINKS;\n\tif (how->resolve & RESOLVE_NO_SYMLINKS)\n\t\tlookup_flags |= LOOKUP_NO_SYMLINKS;\n\tif (how->resolve & RESOLVE_BENEATH)\n\t\tlookup_flags |= LOOKUP_BENEATH;\n\tif (how->resolve & RESOLVE_IN_ROOT)\n\t\tlookup_flags |= LOOKUP_IN_ROOT;\n\tif (how->resolve & RESOLVE_CACHED) {\n\t\t \n\t\tif (flags & (O_TRUNC | O_CREAT | __O_TMPFILE))\n\t\t\treturn -EAGAIN;\n\t\tlookup_flags |= LOOKUP_CACHED;\n\t}\n\n\top->lookup_flags = lookup_flags;\n\treturn 0;\n}\n\n \nstruct file *file_open_name(struct filename *name, int flags, umode_t mode)\n{\n\tstruct open_flags op;\n\tstruct open_how how = build_open_how(flags, mode);\n\tint err = build_open_flags(&how, &op);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\treturn do_filp_open(AT_FDCWD, name, &op);\n}\n\n \nstruct file *filp_open(const char *filename, int flags, umode_t mode)\n{\n\tstruct filename *name = getname_kernel(filename);\n\tstruct file *file = ERR_CAST(name);\n\t\n\tif (!IS_ERR(name)) {\n\t\tfile = file_open_name(name, flags, mode);\n\t\tputname(name);\n\t}\n\treturn file;\n}\nEXPORT_SYMBOL(filp_open);\n\nstruct file *file_open_root(const struct path *root,\n\t\t\t    const char *filename, int flags, umode_t mode)\n{\n\tstruct open_flags op;\n\tstruct open_how how = build_open_how(flags, mode);\n\tint err = build_open_flags(&how, &op);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\treturn do_file_open_root(root, filename, &op);\n}\nEXPORT_SYMBOL(file_open_root);\n\nstatic long do_sys_openat2(int dfd, const char __user *filename,\n\t\t\t   struct open_how *how)\n{\n\tstruct open_flags op;\n\tint fd = build_open_flags(how, &op);\n\tstruct filename *tmp;\n\n\tif (fd)\n\t\treturn fd;\n\n\ttmp = getname(filename);\n\tif (IS_ERR(tmp))\n\t\treturn PTR_ERR(tmp);\n\n\tfd = get_unused_fd_flags(how->flags);\n\tif (fd >= 0) {\n\t\tstruct file *f = do_filp_open(dfd, tmp, &op);\n\t\tif (IS_ERR(f)) {\n\t\t\tput_unused_fd(fd);\n\t\t\tfd = PTR_ERR(f);\n\t\t} else {\n\t\t\tfd_install(fd, f);\n\t\t}\n\t}\n\tputname(tmp);\n\treturn fd;\n}\n\nlong do_sys_open(int dfd, const char __user *filename, int flags, umode_t mode)\n{\n\tstruct open_how how = build_open_how(flags, mode);\n\treturn do_sys_openat2(dfd, filename, &how);\n}\n\n\nSYSCALL_DEFINE3(open, const char __user *, filename, int, flags, umode_t, mode)\n{\n\tif (force_o_largefile())\n\t\tflags |= O_LARGEFILE;\n\treturn do_sys_open(AT_FDCWD, filename, flags, mode);\n}\n\nSYSCALL_DEFINE4(openat, int, dfd, const char __user *, filename, int, flags,\n\t\tumode_t, mode)\n{\n\tif (force_o_largefile())\n\t\tflags |= O_LARGEFILE;\n\treturn do_sys_open(dfd, filename, flags, mode);\n}\n\nSYSCALL_DEFINE4(openat2, int, dfd, const char __user *, filename,\n\t\tstruct open_how __user *, how, size_t, usize)\n{\n\tint err;\n\tstruct open_how tmp;\n\n\tBUILD_BUG_ON(sizeof(struct open_how) < OPEN_HOW_SIZE_VER0);\n\tBUILD_BUG_ON(sizeof(struct open_how) != OPEN_HOW_SIZE_LATEST);\n\n\tif (unlikely(usize < OPEN_HOW_SIZE_VER0))\n\t\treturn -EINVAL;\n\n\terr = copy_struct_from_user(&tmp, sizeof(tmp), how, usize);\n\tif (err)\n\t\treturn err;\n\n\taudit_openat2_how(&tmp);\n\n\t \n\tif (!(tmp.flags & O_PATH) && force_o_largefile())\n\t\ttmp.flags |= O_LARGEFILE;\n\n\treturn do_sys_openat2(dfd, filename, &tmp);\n}\n\n#ifdef CONFIG_COMPAT\n \nCOMPAT_SYSCALL_DEFINE3(open, const char __user *, filename, int, flags, umode_t, mode)\n{\n\treturn do_sys_open(AT_FDCWD, filename, flags, mode);\n}\n\n \nCOMPAT_SYSCALL_DEFINE4(openat, int, dfd, const char __user *, filename, int, flags, umode_t, mode)\n{\n\treturn do_sys_open(dfd, filename, flags, mode);\n}\n#endif\n\n#ifndef __alpha__\n\n \nSYSCALL_DEFINE2(creat, const char __user *, pathname, umode_t, mode)\n{\n\tint flags = O_CREAT | O_WRONLY | O_TRUNC;\n\n\tif (force_o_largefile())\n\t\tflags |= O_LARGEFILE;\n\treturn do_sys_open(AT_FDCWD, pathname, flags, mode);\n}\n#endif\n\n \nstatic int filp_flush(struct file *filp, fl_owner_t id)\n{\n\tint retval = 0;\n\n\tif (CHECK_DATA_CORRUPTION(file_count(filp) == 0,\n\t\t\t\"VFS: Close: file count is 0 (f_op=%ps)\",\n\t\t\tfilp->f_op)) {\n\t\treturn 0;\n\t}\n\n\tif (filp->f_op->flush)\n\t\tretval = filp->f_op->flush(filp, id);\n\n\tif (likely(!(filp->f_mode & FMODE_PATH))) {\n\t\tdnotify_flush(filp, id);\n\t\tlocks_remove_posix(filp, id);\n\t}\n\treturn retval;\n}\n\nint filp_close(struct file *filp, fl_owner_t id)\n{\n\tint retval;\n\n\tretval = filp_flush(filp, id);\n\tfput(filp);\n\n\treturn retval;\n}\nEXPORT_SYMBOL(filp_close);\n\n \nSYSCALL_DEFINE1(close, unsigned int, fd)\n{\n\tint retval;\n\tstruct file *file;\n\n\tfile = close_fd_get_file(fd);\n\tif (!file)\n\t\treturn -EBADF;\n\n\tretval = filp_flush(file, current->files);\n\n\t \n\t__fput_sync(file);\n\n\t \n\tif (unlikely(retval == -ERESTARTSYS ||\n\t\t     retval == -ERESTARTNOINTR ||\n\t\t     retval == -ERESTARTNOHAND ||\n\t\t     retval == -ERESTART_RESTARTBLOCK))\n\t\tretval = -EINTR;\n\n\treturn retval;\n}\n\n \nSYSCALL_DEFINE3(close_range, unsigned int, fd, unsigned int, max_fd,\n\t\tunsigned int, flags)\n{\n\treturn __close_range(fd, max_fd, flags);\n}\n\n \nSYSCALL_DEFINE0(vhangup)\n{\n\tif (capable(CAP_SYS_TTY_CONFIG)) {\n\t\ttty_vhangup_self();\n\t\treturn 0;\n\t}\n\treturn -EPERM;\n}\n\n \nint generic_file_open(struct inode * inode, struct file * filp)\n{\n\tif (!(filp->f_flags & O_LARGEFILE) && i_size_read(inode) > MAX_NON_LFS)\n\t\treturn -EOVERFLOW;\n\treturn 0;\n}\n\nEXPORT_SYMBOL(generic_file_open);\n\n \nint nonseekable_open(struct inode *inode, struct file *filp)\n{\n\tfilp->f_mode &= ~(FMODE_LSEEK | FMODE_PREAD | FMODE_PWRITE);\n\treturn 0;\n}\n\nEXPORT_SYMBOL(nonseekable_open);\n\n \nint stream_open(struct inode *inode, struct file *filp)\n{\n\tfilp->f_mode &= ~(FMODE_LSEEK | FMODE_PREAD | FMODE_PWRITE | FMODE_ATOMIC_POS);\n\tfilp->f_mode |= FMODE_STREAM;\n\treturn 0;\n}\n\nEXPORT_SYMBOL(stream_open);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}