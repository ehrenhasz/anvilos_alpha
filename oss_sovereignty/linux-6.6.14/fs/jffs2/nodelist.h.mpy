{
  "module_name": "nodelist.h",
  "hash_id": "710a87d8c70e388340add3f41a224784e85f8f1b50e4345e7df44f1cb0000cd5",
  "original_prompt": "Ingested from linux-6.6.14/fs/jffs2/nodelist.h",
  "human_readable_source": " \n\n#ifndef __JFFS2_NODELIST_H__\n#define __JFFS2_NODELIST_H__\n\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/jffs2.h>\n#include \"jffs2_fs_sb.h\"\n#include \"jffs2_fs_i.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"summary.h\"\n\n#ifdef __ECOS\n#include \"os-ecos.h\"\n#else\n#include \"os-linux.h\"\n#endif\n\n#define JFFS2_NATIVE_ENDIAN\n\n \n\n#if defined(JFFS2_NATIVE_ENDIAN)\n#define cpu_to_je16(x) ((jint16_t){x})\n#define cpu_to_je32(x) ((jint32_t){x})\n#define cpu_to_jemode(x) ((jmode_t){os_to_jffs2_mode(x)})\n\n#define constant_cpu_to_je16(x) ((jint16_t){x})\n#define constant_cpu_to_je32(x) ((jint32_t){x})\n\n#define je16_to_cpu(x) ((x).v16)\n#define je32_to_cpu(x) ((x).v32)\n#define jemode_to_cpu(x) (jffs2_to_os_mode((x).m))\n#elif defined(JFFS2_BIG_ENDIAN)\n#define cpu_to_je16(x) ((jint16_t){cpu_to_be16(x)})\n#define cpu_to_je32(x) ((jint32_t){cpu_to_be32(x)})\n#define cpu_to_jemode(x) ((jmode_t){cpu_to_be32(os_to_jffs2_mode(x))})\n\n#define constant_cpu_to_je16(x) ((jint16_t){__constant_cpu_to_be16(x)})\n#define constant_cpu_to_je32(x) ((jint32_t){__constant_cpu_to_be32(x)})\n\n#define je16_to_cpu(x) (be16_to_cpu(x.v16))\n#define je32_to_cpu(x) (be32_to_cpu(x.v32))\n#define jemode_to_cpu(x) (be32_to_cpu(jffs2_to_os_mode((x).m)))\n#elif defined(JFFS2_LITTLE_ENDIAN)\n#define cpu_to_je16(x) ((jint16_t){cpu_to_le16(x)})\n#define cpu_to_je32(x) ((jint32_t){cpu_to_le32(x)})\n#define cpu_to_jemode(x) ((jmode_t){cpu_to_le32(os_to_jffs2_mode(x))})\n\n#define constant_cpu_to_je16(x) ((jint16_t){__constant_cpu_to_le16(x)})\n#define constant_cpu_to_je32(x) ((jint32_t){__constant_cpu_to_le32(x)})\n\n#define je16_to_cpu(x) (le16_to_cpu(x.v16))\n#define je32_to_cpu(x) (le32_to_cpu(x.v32))\n#define jemode_to_cpu(x) (le32_to_cpu(jffs2_to_os_mode((x).m)))\n#else\n#error wibble\n#endif\n\n \n#define JFFS2_MIN_NODE_HEADER sizeof(struct jffs2_raw_dirent)\n\n \nstruct jffs2_raw_node_ref\n{\n\tstruct jffs2_raw_node_ref *next_in_ino;  \n\tuint32_t flash_offset;\n#undef TEST_TOTLEN\n#ifdef TEST_TOTLEN\n\tuint32_t __totlen;  \n#endif\n};\n\n#define REF_LINK_NODE ((int32_t)-1)\n#define REF_EMPTY_NODE ((int32_t)-2)\n\n \n#define REFS_PER_BLOCK ((255/sizeof(struct jffs2_raw_node_ref))-1)\n\nstatic inline struct jffs2_raw_node_ref *ref_next(struct jffs2_raw_node_ref *ref)\n{\n\tref++;\n\n\t \n\tif (ref->flash_offset == REF_LINK_NODE) {\n\t\tref = ref->next_in_ino;\n\t\tif (!ref)\n\t\t\treturn ref;\n\t}\n\n\t \n\tif (ref->flash_offset == REF_EMPTY_NODE)\n\t\treturn NULL;\n\n\treturn ref;\n}\n\nstatic inline struct jffs2_inode_cache *jffs2_raw_ref_to_ic(struct jffs2_raw_node_ref *raw)\n{\n\twhile(raw->next_in_ino)\n\t\traw = raw->next_in_ino;\n\n\t \n\treturn ((struct jffs2_inode_cache *)raw);\n}\n\n\t \n#define REF_UNCHECKED\t0\t \n#define REF_OBSOLETE\t1\t \n#define REF_PRISTINE\t2\t \n#define REF_NORMAL\t3\t \n#define ref_flags(ref)\t\t((ref)->flash_offset & 3)\n#define ref_offset(ref)\t\t((ref)->flash_offset & ~3)\n#define ref_obsolete(ref)\t(((ref)->flash_offset & 3) == REF_OBSOLETE)\n#define mark_ref_normal(ref)    do { (ref)->flash_offset = ref_offset(ref) | REF_NORMAL; } while(0)\n\n \n#define dirent_node_state(rd)\t( (je32_to_cpu((rd)->ino)?REF_PRISTINE:REF_NORMAL) )\n\n \n\n \nstruct jffs2_inode_cache {\n\t \n\n\tstruct jffs2_full_dirent *scan_dents;  \n\tstruct jffs2_raw_node_ref *nodes;\n\tuint8_t class;\t \n\n\t \n\n\tuint8_t flags;\n\tuint16_t state;\n\tuint32_t ino;\n\tstruct jffs2_inode_cache *next;\n#ifdef CONFIG_JFFS2_FS_XATTR\n\tstruct jffs2_xattr_ref *xref;\n#endif\n\tuint32_t pino_nlink;\t \n};\n\n \n#define INO_STATE_UNCHECKED\t0\t \n#define INO_STATE_CHECKING\t1\t \n#define INO_STATE_PRESENT\t2\t \n#define INO_STATE_CHECKEDABSENT\t3\t \n#define INO_STATE_GC\t\t4\t \n#define INO_STATE_READING\t5\t \n#define INO_STATE_CLEARING\t6\t \n\n#define INO_FLAGS_XATTR_CHECKED\t0x01\t \n#define INO_FLAGS_IS_DIR\t0x02\t \n\n#define RAWNODE_CLASS_INODE_CACHE\t0\n#define RAWNODE_CLASS_XATTR_DATUM\t1\n#define RAWNODE_CLASS_XATTR_REF\t\t2\n\n#define INOCACHE_HASHSIZE_MIN 128\n#define INOCACHE_HASHSIZE_MAX 1024\n\n#define write_ofs(c) ((c)->nextblock->offset + (c)->sector_size - (c)->nextblock->free_size)\n\n \n\nstruct jffs2_full_dnode\n{\n\tstruct jffs2_raw_node_ref *raw;\n\tuint32_t ofs;  \n\tuint32_t size;\n\tuint32_t frags;  \n};\n\n \nstruct jffs2_tmp_dnode_info\n{\n\tstruct rb_node rb;\n\tstruct jffs2_full_dnode *fn;\n\tuint32_t version;\n\tuint32_t data_crc;\n\tuint32_t partial_crc;\n\tuint32_t csize;\n\tuint16_t overlapped;\n};\n\n \nstruct jffs2_readinode_info\n{\n\tstruct rb_root tn_root;\n\tstruct jffs2_tmp_dnode_info *mdata_tn;\n\tuint32_t highest_version;\n\tuint32_t latest_mctime;\n\tuint32_t mctime_ver;\n\tstruct jffs2_full_dirent *fds;\n\tstruct jffs2_raw_node_ref *latest_ref;\n};\n\nstruct jffs2_full_dirent\n{\n\tunion {\n\t\tstruct jffs2_raw_node_ref *raw;\n\t\tstruct jffs2_inode_cache *ic;  \n\t};\n\tstruct jffs2_full_dirent *next;\n\tuint32_t version;\n\tuint32_t ino;  \n\tunsigned int nhash;\n\tunsigned char type;\n\tunsigned char name[];\n};\n\n \nstruct jffs2_node_frag\n{\n\tstruct rb_node rb;\n\tstruct jffs2_full_dnode *node;  \n\tuint32_t size;\n\tuint32_t ofs;  \n};\n\nstruct jffs2_eraseblock\n{\n\tstruct list_head list;\n\tint bad_count;\n\tuint32_t offset;\t\t \n\n\tuint32_t unchecked_size;\n\tuint32_t used_size;\n\tuint32_t dirty_size;\n\tuint32_t wasted_size;\n\tuint32_t free_size;\t \n\tuint32_t allocated_refs;\n\tstruct jffs2_raw_node_ref *first_node;\n\tstruct jffs2_raw_node_ref *last_node;\n\n\tstruct jffs2_raw_node_ref *gc_node;\t \n};\n\nstatic inline int jffs2_blocks_use_vmalloc(struct jffs2_sb_info *c)\n{\n\treturn ((c->flash_size / c->sector_size) * sizeof (struct jffs2_eraseblock)) > (128 * 1024);\n}\n\n#define ref_totlen(a, b, c) __jffs2_ref_totlen((a), (b), (c))\n\n#define ALLOC_NORMAL\t0\t \n#define ALLOC_DELETION\t1\t \n#define ALLOC_GC\t2\t \n#define ALLOC_NORETRY\t3\t \n\n \n#define VERYDIRTY(c, size) ((size) >= ((c)->sector_size / 2))\n\n \n#define ISDIRTY(size) ((size) >  sizeof (struct jffs2_raw_inode) + JFFS2_MIN_DATA_LEN)\n\n#define PAD(x) (((x)+3)&~3)\n\nstatic inline int jffs2_encode_dev(union jffs2_device_node *jdev, dev_t rdev)\n{\n\tif (old_valid_dev(rdev)) {\n\t\tjdev->old_id = cpu_to_je16(old_encode_dev(rdev));\n\t\treturn sizeof(jdev->old_id);\n\t} else {\n\t\tjdev->new_id = cpu_to_je32(new_encode_dev(rdev));\n\t\treturn sizeof(jdev->new_id);\n\t}\n}\n\nstatic inline struct jffs2_node_frag *frag_first(struct rb_root *root)\n{\n\tstruct rb_node *node = rb_first(root);\n\n\tif (!node)\n\t\treturn NULL;\n\n\treturn rb_entry(node, struct jffs2_node_frag, rb);\n}\n\nstatic inline struct jffs2_node_frag *frag_last(struct rb_root *root)\n{\n\tstruct rb_node *node = rb_last(root);\n\n\tif (!node)\n\t\treturn NULL;\n\n\treturn rb_entry(node, struct jffs2_node_frag, rb);\n}\n\n#define frag_next(frag) rb_entry(rb_next(&(frag)->rb), struct jffs2_node_frag, rb)\n#define frag_prev(frag) rb_entry(rb_prev(&(frag)->rb), struct jffs2_node_frag, rb)\n#define frag_parent(frag) rb_entry(rb_parent(&(frag)->rb), struct jffs2_node_frag, rb)\n#define frag_left(frag) rb_entry((frag)->rb.rb_left, struct jffs2_node_frag, rb)\n#define frag_right(frag) rb_entry((frag)->rb.rb_right, struct jffs2_node_frag, rb)\n#define frag_erase(frag, list) rb_erase(&frag->rb, list)\n\n#define tn_next(tn) rb_entry(rb_next(&(tn)->rb), struct jffs2_tmp_dnode_info, rb)\n#define tn_prev(tn) rb_entry(rb_prev(&(tn)->rb), struct jffs2_tmp_dnode_info, rb)\n#define tn_parent(tn) rb_entry(rb_parent(&(tn)->rb), struct jffs2_tmp_dnode_info, rb)\n#define tn_left(tn) rb_entry((tn)->rb.rb_left, struct jffs2_tmp_dnode_info, rb)\n#define tn_right(tn) rb_entry((tn)->rb.rb_right, struct jffs2_tmp_dnode_info, rb)\n#define tn_erase(tn, list) rb_erase(&tn->rb, list)\n#define tn_last(list) rb_entry(rb_last(list), struct jffs2_tmp_dnode_info, rb)\n#define tn_first(list) rb_entry(rb_first(list), struct jffs2_tmp_dnode_info, rb)\n\n \nvoid jffs2_add_fd_to_list(struct jffs2_sb_info *c, struct jffs2_full_dirent *new, struct jffs2_full_dirent **list);\nvoid jffs2_set_inocache_state(struct jffs2_sb_info *c, struct jffs2_inode_cache *ic, int state);\nstruct jffs2_inode_cache *jffs2_get_ino_cache(struct jffs2_sb_info *c, uint32_t ino);\nvoid jffs2_add_ino_cache (struct jffs2_sb_info *c, struct jffs2_inode_cache *new);\nvoid jffs2_del_ino_cache(struct jffs2_sb_info *c, struct jffs2_inode_cache *old);\nvoid jffs2_free_ino_caches(struct jffs2_sb_info *c);\nvoid jffs2_free_raw_node_refs(struct jffs2_sb_info *c);\nstruct jffs2_node_frag *jffs2_lookup_node_frag(struct rb_root *fragtree, uint32_t offset);\nvoid jffs2_kill_fragtree(struct rb_root *root, struct jffs2_sb_info *c_delete);\nint jffs2_add_full_dnode_to_inode(struct jffs2_sb_info *c, struct jffs2_inode_info *f, struct jffs2_full_dnode *fn);\nuint32_t jffs2_truncate_fragtree (struct jffs2_sb_info *c, struct rb_root *list, uint32_t size);\nstruct jffs2_raw_node_ref *jffs2_link_node_ref(struct jffs2_sb_info *c,\n\t\t\t\t\t       struct jffs2_eraseblock *jeb,\n\t\t\t\t\t       uint32_t ofs, uint32_t len,\n\t\t\t\t\t       struct jffs2_inode_cache *ic);\nextern uint32_t __jffs2_ref_totlen(struct jffs2_sb_info *c,\n\t\t\t\t   struct jffs2_eraseblock *jeb,\n\t\t\t\t   struct jffs2_raw_node_ref *ref);\n\n \nint jffs2_thread_should_wake(struct jffs2_sb_info *c);\nint jffs2_reserve_space(struct jffs2_sb_info *c, uint32_t minsize,\n\t\t\tuint32_t *len, int prio, uint32_t sumsize);\nint jffs2_reserve_space_gc(struct jffs2_sb_info *c, uint32_t minsize,\n\t\t\tuint32_t *len, uint32_t sumsize);\nstruct jffs2_raw_node_ref *jffs2_add_physical_node_ref(struct jffs2_sb_info *c, \n\t\t\t\t\t\t       uint32_t ofs, uint32_t len,\n\t\t\t\t\t\t       struct jffs2_inode_cache *ic);\nvoid jffs2_complete_reservation(struct jffs2_sb_info *c);\nvoid jffs2_mark_node_obsolete(struct jffs2_sb_info *c, struct jffs2_raw_node_ref *raw);\n\n \nint jffs2_do_new_inode(struct jffs2_sb_info *c, struct jffs2_inode_info *f, uint32_t mode, struct jffs2_raw_inode *ri);\n\nstruct jffs2_full_dnode *jffs2_write_dnode(struct jffs2_sb_info *c, struct jffs2_inode_info *f,\n\t\t\t\t\t   struct jffs2_raw_inode *ri, const unsigned char *data,\n\t\t\t\t\t   uint32_t datalen, int alloc_mode);\nstruct jffs2_full_dirent *jffs2_write_dirent(struct jffs2_sb_info *c, struct jffs2_inode_info *f,\n\t\t\t\t\t     struct jffs2_raw_dirent *rd, const unsigned char *name,\n\t\t\t\t\t     uint32_t namelen, int alloc_mode);\nint jffs2_write_inode_range(struct jffs2_sb_info *c, struct jffs2_inode_info *f,\n\t\t\t    struct jffs2_raw_inode *ri, unsigned char *buf,\n\t\t\t    uint32_t offset, uint32_t writelen, uint32_t *retlen);\nint jffs2_do_create(struct jffs2_sb_info *c, struct jffs2_inode_info *dir_f, struct jffs2_inode_info *f,\n\t\t    struct jffs2_raw_inode *ri, const struct qstr *qstr);\nint jffs2_do_unlink(struct jffs2_sb_info *c, struct jffs2_inode_info *dir_f, const char *name,\n\t\t    int namelen, struct jffs2_inode_info *dead_f, uint32_t time);\nint jffs2_do_link(struct jffs2_sb_info *c, struct jffs2_inode_info *dir_f, uint32_t ino,\n\t\t   uint8_t type, const char *name, int namelen, uint32_t time);\n\n\n \nint jffs2_do_read_inode(struct jffs2_sb_info *c, struct jffs2_inode_info *f,\n\t\t\tuint32_t ino, struct jffs2_raw_inode *latest_node);\nint jffs2_do_crccheck_inode(struct jffs2_sb_info *c, struct jffs2_inode_cache *ic);\nvoid jffs2_do_clear_inode(struct jffs2_sb_info *c, struct jffs2_inode_info *f);\n\n \nint jffs2_create_slab_caches(void);\nvoid jffs2_destroy_slab_caches(void);\n\nstruct jffs2_full_dirent *jffs2_alloc_full_dirent(int namesize);\nvoid jffs2_free_full_dirent(struct jffs2_full_dirent *);\nstruct jffs2_full_dnode *jffs2_alloc_full_dnode(void);\nvoid jffs2_free_full_dnode(struct jffs2_full_dnode *);\nstruct jffs2_raw_dirent *jffs2_alloc_raw_dirent(void);\nvoid jffs2_free_raw_dirent(struct jffs2_raw_dirent *);\nstruct jffs2_raw_inode *jffs2_alloc_raw_inode(void);\nvoid jffs2_free_raw_inode(struct jffs2_raw_inode *);\nstruct jffs2_tmp_dnode_info *jffs2_alloc_tmp_dnode_info(void);\nvoid jffs2_free_tmp_dnode_info(struct jffs2_tmp_dnode_info *);\nint jffs2_prealloc_raw_node_refs(struct jffs2_sb_info *c,\n\t\t\t\t struct jffs2_eraseblock *jeb, int nr);\nvoid jffs2_free_refblock(struct jffs2_raw_node_ref *);\nstruct jffs2_node_frag *jffs2_alloc_node_frag(void);\nvoid jffs2_free_node_frag(struct jffs2_node_frag *);\nstruct jffs2_inode_cache *jffs2_alloc_inode_cache(void);\nvoid jffs2_free_inode_cache(struct jffs2_inode_cache *);\n#ifdef CONFIG_JFFS2_FS_XATTR\nstruct jffs2_xattr_datum *jffs2_alloc_xattr_datum(void);\nvoid jffs2_free_xattr_datum(struct jffs2_xattr_datum *);\nstruct jffs2_xattr_ref *jffs2_alloc_xattr_ref(void);\nvoid jffs2_free_xattr_ref(struct jffs2_xattr_ref *);\n#endif\n\n \nint jffs2_garbage_collect_pass(struct jffs2_sb_info *c);\n\n \nint jffs2_read_dnode(struct jffs2_sb_info *c, struct jffs2_inode_info *f,\n\t\t     struct jffs2_full_dnode *fd, unsigned char *buf,\n\t\t     int ofs, int len);\nint jffs2_read_inode_range(struct jffs2_sb_info *c, struct jffs2_inode_info *f,\n\t\t\t   unsigned char *buf, uint32_t offset, uint32_t len);\nchar *jffs2_getlink(struct jffs2_sb_info *c, struct jffs2_inode_info *f);\n\n \nint jffs2_scan_medium(struct jffs2_sb_info *c);\nvoid jffs2_rotate_lists(struct jffs2_sb_info *c);\nstruct jffs2_inode_cache *jffs2_scan_make_ino_cache(struct jffs2_sb_info *c, uint32_t ino);\nint jffs2_scan_classify_jeb(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb);\nint jffs2_scan_dirty_space(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb, uint32_t size);\n\n \nint jffs2_do_mount_fs(struct jffs2_sb_info *c);\n\n \nint jffs2_erase_pending_blocks(struct jffs2_sb_info *c, int count);\nvoid jffs2_free_jeb_node_refs(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb);\n\n#ifdef CONFIG_JFFS2_FS_WRITEBUFFER\n \nint jffs2_flush_wbuf_gc(struct jffs2_sb_info *c, uint32_t ino);\nint jffs2_flush_wbuf_pad(struct jffs2_sb_info *c);\nint jffs2_check_nand_cleanmarker(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb);\nint jffs2_write_nand_cleanmarker(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb);\n#endif\n\n#include \"debug.h\"\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}