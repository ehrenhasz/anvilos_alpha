{
  "module_name": "nodelist.c",
  "hash_id": "24bdbc0a789155ec4804a735f45971a84b7f3eef27e87d793af260de235e07fb",
  "original_prompt": "Ingested from linux-6.6.14/fs/jffs2/nodelist.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/mtd/mtd.h>\n#include <linux/rbtree.h>\n#include <linux/crc32.h>\n#include <linux/pagemap.h>\n#include \"nodelist.h\"\n\nstatic void jffs2_obsolete_node_frag(struct jffs2_sb_info *c,\n\t\t\t\t     struct jffs2_node_frag *this);\n\nvoid jffs2_add_fd_to_list(struct jffs2_sb_info *c, struct jffs2_full_dirent *new, struct jffs2_full_dirent **list)\n{\n\tstruct jffs2_full_dirent **prev = list;\n\n\tdbg_dentlist(\"add dirent \\\"%s\\\", ino #%u\\n\", new->name, new->ino);\n\n\twhile ((*prev) && (*prev)->nhash <= new->nhash) {\n\t\tif ((*prev)->nhash == new->nhash && !strcmp((*prev)->name, new->name)) {\n\t\t\t \n\t\t\tif (new->version < (*prev)->version) {\n\t\t\t\tdbg_dentlist(\"Eep! Marking new dirent node obsolete, old is \\\"%s\\\", ino #%u\\n\",\n\t\t\t\t\t(*prev)->name, (*prev)->ino);\n\t\t\t\tjffs2_mark_node_obsolete(c, new->raw);\n\t\t\t\tjffs2_free_full_dirent(new);\n\t\t\t} else {\n\t\t\t\tdbg_dentlist(\"marking old dirent \\\"%s\\\", ino #%u obsolete\\n\",\n\t\t\t\t\t(*prev)->name, (*prev)->ino);\n\t\t\t\tnew->next = (*prev)->next;\n\t\t\t\t \n\t\t\t\tif ((*prev)->raw)\n\t\t\t\t\tjffs2_mark_node_obsolete(c, ((*prev)->raw));\n\t\t\t\tjffs2_free_full_dirent(*prev);\n\t\t\t\t*prev = new;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tprev = &((*prev)->next);\n\t}\n\tnew->next = *prev;\n\t*prev = new;\n}\n\nuint32_t jffs2_truncate_fragtree(struct jffs2_sb_info *c, struct rb_root *list, uint32_t size)\n{\n\tstruct jffs2_node_frag *frag = jffs2_lookup_node_frag(list, size);\n\n\tdbg_fragtree(\"truncating fragtree to 0x%08x bytes\\n\", size);\n\n\t \n\tif (frag && frag->ofs != size) {\n\t\tif (frag->ofs+frag->size > size) {\n\t\t\tfrag->size = size - frag->ofs;\n\t\t}\n\t\tfrag = frag_next(frag);\n\t}\n\twhile (frag && frag->ofs >= size) {\n\t\tstruct jffs2_node_frag *next = frag_next(frag);\n\n\t\tfrag_erase(frag, list);\n\t\tjffs2_obsolete_node_frag(c, frag);\n\t\tfrag = next;\n\t}\n\n\tif (size == 0)\n\t\treturn 0;\n\n\tfrag = frag_last(list);\n\n\t \n\tif (!frag)\n\t\treturn 0;\n\tif (frag->ofs + frag->size < size)\n\t\treturn frag->ofs + frag->size;\n\n\t \n\tif (frag->node && (frag->ofs & (PAGE_SIZE - 1)) == 0) {\n\t\tdbg_fragtree2(\"marking the last fragment 0x%08x-0x%08x REF_PRISTINE.\\n\",\n\t\t\tfrag->ofs, frag->ofs + frag->size);\n\t\tfrag->node->raw->flash_offset = ref_offset(frag->node->raw) | REF_PRISTINE;\n\t}\n\treturn size;\n}\n\nstatic void jffs2_obsolete_node_frag(struct jffs2_sb_info *c,\n\t\t\t\t     struct jffs2_node_frag *this)\n{\n\tif (this->node) {\n\t\tthis->node->frags--;\n\t\tif (!this->node->frags) {\n\t\t\t \n\t\t\tdbg_fragtree2(\"marking old node @0x%08x (0x%04x-0x%04x) obsolete\\n\",\n\t\t\t\tref_offset(this->node->raw), this->node->ofs, this->node->ofs+this->node->size);\n\t\t\tjffs2_mark_node_obsolete(c, this->node->raw);\n\t\t\tjffs2_free_full_dnode(this->node);\n\t\t} else {\n\t\t\tdbg_fragtree2(\"marking old node @0x%08x (0x%04x-0x%04x) REF_NORMAL. frags is %d\\n\",\n\t\t\t\tref_offset(this->node->raw), this->node->ofs, this->node->ofs+this->node->size, this->node->frags);\n\t\t\tmark_ref_normal(this->node->raw);\n\t\t}\n\n\t}\n\tjffs2_free_node_frag(this);\n}\n\nstatic void jffs2_fragtree_insert(struct jffs2_node_frag *newfrag, struct jffs2_node_frag *base)\n{\n\tstruct rb_node *parent = &base->rb;\n\tstruct rb_node **link = &parent;\n\n\tdbg_fragtree2(\"insert frag (0x%04x-0x%04x)\\n\", newfrag->ofs, newfrag->ofs + newfrag->size);\n\n\twhile (*link) {\n\t\tparent = *link;\n\t\tbase = rb_entry(parent, struct jffs2_node_frag, rb);\n\n\t\tif (newfrag->ofs > base->ofs)\n\t\t\tlink = &base->rb.rb_right;\n\t\telse if (newfrag->ofs < base->ofs)\n\t\t\tlink = &base->rb.rb_left;\n\t\telse {\n\t\t\tJFFS2_ERROR(\"duplicate frag at %08x (%p,%p)\\n\", newfrag->ofs, newfrag, base);\n\t\t\tBUG();\n\t\t}\n\t}\n\n\trb_link_node(&newfrag->rb, &base->rb, link);\n}\n\n \nstatic struct jffs2_node_frag * new_fragment(struct jffs2_full_dnode *fn, uint32_t ofs, uint32_t size)\n{\n\tstruct jffs2_node_frag *newfrag;\n\n\tnewfrag = jffs2_alloc_node_frag();\n\tif (likely(newfrag)) {\n\t\tnewfrag->ofs = ofs;\n\t\tnewfrag->size = size;\n\t\tnewfrag->node = fn;\n\t} else {\n\t\tJFFS2_ERROR(\"cannot allocate a jffs2_node_frag object\\n\");\n\t}\n\n\treturn newfrag;\n}\n\n \nstatic int no_overlapping_node(struct jffs2_sb_info *c, struct rb_root *root,\n\t\t \t       struct jffs2_node_frag *newfrag,\n\t\t\t       struct jffs2_node_frag *this, uint32_t lastend)\n{\n\tif (lastend < newfrag->node->ofs) {\n\t\t \n\t\tstruct jffs2_node_frag *holefrag;\n\n\t\tholefrag= new_fragment(NULL, lastend, newfrag->node->ofs - lastend);\n\t\tif (unlikely(!holefrag)) {\n\t\t\tjffs2_free_node_frag(newfrag);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (this) {\n\t\t\t \n\t\t\tdbg_fragtree2(\"add hole frag %#04x-%#04x on the right of the new frag.\\n\",\n\t\t\t\tholefrag->ofs, holefrag->ofs + holefrag->size);\n\t\t\trb_link_node(&holefrag->rb, &this->rb, &this->rb.rb_right);\n\t\t} else {\n\t\t\tdbg_fragtree2(\"Add hole frag %#04x-%#04x to the root of the tree.\\n\",\n\t\t\t\tholefrag->ofs, holefrag->ofs + holefrag->size);\n\t\t\trb_link_node(&holefrag->rb, NULL, &root->rb_node);\n\t\t}\n\t\trb_insert_color(&holefrag->rb, root);\n\t\tthis = holefrag;\n\t}\n\n\tif (this) {\n\t\t \n\t\tdbg_fragtree2(\"add the new node at the right\\n\");\n\t\trb_link_node(&newfrag->rb, &this->rb, &this->rb.rb_right);\n\t} else {\n\t\tdbg_fragtree2(\"insert the new node at the root of the tree\\n\");\n\t\trb_link_node(&newfrag->rb, NULL, &root->rb_node);\n\t}\n\trb_insert_color(&newfrag->rb, root);\n\n\treturn 0;\n}\n\n \nstatic int jffs2_add_frag_to_fragtree(struct jffs2_sb_info *c, struct rb_root *root, struct jffs2_node_frag *newfrag)\n{\n\tstruct jffs2_node_frag *this;\n\tuint32_t lastend;\n\n\t \n\tthis = jffs2_lookup_node_frag(root, newfrag->node->ofs);\n\n\tif (this) {\n\t\tdbg_fragtree2(\"lookup gave frag 0x%04x-0x%04x; phys 0x%08x (*%p)\\n\",\n\t\t\t  this->ofs, this->ofs+this->size, this->node?(ref_offset(this->node->raw)):0xffffffff, this);\n\t\tlastend = this->ofs + this->size;\n\t} else {\n\t\tdbg_fragtree2(\"lookup gave no frag\\n\");\n\t\tlastend = 0;\n\t}\n\n\t \n\tif (lastend <= newfrag->ofs) {\n\t\t \n\n\t\t \n\t\tif (lastend && (lastend-1) >> PAGE_SHIFT == newfrag->ofs >> PAGE_SHIFT) {\n\t\t\tif (this->node)\n\t\t\t\tmark_ref_normal(this->node->raw);\n\t\t\tmark_ref_normal(newfrag->node->raw);\n\t\t}\n\n\t\treturn no_overlapping_node(c, root, newfrag, this, lastend);\n\t}\n\n\tif (this->node)\n\t\tdbg_fragtree2(\"dealing with frag %u-%u, phys %#08x(%d).\\n\",\n\t\tthis->ofs, this->ofs + this->size,\n\t\tref_offset(this->node->raw), ref_flags(this->node->raw));\n\telse\n\t\tdbg_fragtree2(\"dealing with hole frag %u-%u.\\n\",\n\t\tthis->ofs, this->ofs + this->size);\n\n\t \n\tif (newfrag->ofs > this->ofs) {\n\t\t \n\n\t\t \n\t\tmark_ref_normal(newfrag->node->raw);\n\t\tif (this->node)\n\t\t\tmark_ref_normal(this->node->raw);\n\n\t\tif (this->ofs + this->size > newfrag->ofs + newfrag->size) {\n\t\t\t \n\t\t\tstruct jffs2_node_frag *newfrag2;\n\n\t\t\tif (this->node)\n\t\t\t\tdbg_fragtree2(\"split old frag 0x%04x-0x%04x, phys 0x%08x\\n\",\n\t\t\t\t\tthis->ofs, this->ofs+this->size, ref_offset(this->node->raw));\n\t\t\telse\n\t\t\t\tdbg_fragtree2(\"split old hole frag 0x%04x-0x%04x\\n\",\n\t\t\t\t\tthis->ofs, this->ofs+this->size);\n\n\t\t\t \n\t\t\tnewfrag2 = new_fragment(this->node, newfrag->ofs + newfrag->size,\n\t\t\t\t\t\tthis->ofs + this->size - newfrag->ofs - newfrag->size);\n\t\t\tif (unlikely(!newfrag2))\n\t\t\t\treturn -ENOMEM;\n\t\t\tif (this->node)\n\t\t\t\tthis->node->frags++;\n\n\t\t\t \n\t\t\tthis->size = newfrag->ofs - this->ofs;\n\n\t\t\t \n\t\t\tjffs2_fragtree_insert(newfrag, this);\n\t\t\trb_insert_color(&newfrag->rb, root);\n\n\t\t\tjffs2_fragtree_insert(newfrag2, newfrag);\n\t\t\trb_insert_color(&newfrag2->rb, root);\n\n\t\t\treturn 0;\n\t\t}\n\t\t \n\t\tthis->size = newfrag->ofs - this->ofs;\n\n\t\t \n\t\tjffs2_fragtree_insert(newfrag, this);\n\t\trb_insert_color(&newfrag->rb, root);\n\t} else {\n\t\t \n\t\tdbg_fragtree2(\"inserting newfrag (*%p),%d-%d in before 'this' (*%p),%d-%d\\n\",\n\t\t\t  newfrag, newfrag->ofs, newfrag->ofs+newfrag->size, this, this->ofs, this->ofs+this->size);\n\n\t\trb_replace_node(&this->rb, &newfrag->rb, root);\n\n\t\tif (newfrag->ofs + newfrag->size >= this->ofs+this->size) {\n\t\t\tdbg_fragtree2(\"obsoleting node frag %p (%x-%x)\\n\", this, this->ofs, this->ofs+this->size);\n\t\t\tjffs2_obsolete_node_frag(c, this);\n\t\t} else {\n\t\t\tthis->ofs += newfrag->size;\n\t\t\tthis->size -= newfrag->size;\n\n\t\t\tjffs2_fragtree_insert(this, newfrag);\n\t\t\trb_insert_color(&this->rb, root);\n\t\t\treturn 0;\n\t\t}\n\t}\n\t \n\twhile ((this = frag_next(newfrag)) && newfrag->ofs + newfrag->size >= this->ofs + this->size) {\n\t\t \n\t\tdbg_fragtree2(\"obsoleting node frag %p (%x-%x) and removing from tree\\n\",\n\t\t\tthis, this->ofs, this->ofs+this->size);\n\t\trb_erase(&this->rb, root);\n\t\tjffs2_obsolete_node_frag(c, this);\n\t}\n\t \n\n\tif (!this || newfrag->ofs + newfrag->size == this->ofs)\n\t\treturn 0;\n\n\t \n\tthis->size = (this->ofs + this->size) - (newfrag->ofs + newfrag->size);\n\tthis->ofs = newfrag->ofs + newfrag->size;\n\n\t \n\tif (this->node)\n\t\tmark_ref_normal(this->node->raw);\n\tmark_ref_normal(newfrag->node->raw);\n\n\treturn 0;\n}\n\n \nint jffs2_add_full_dnode_to_inode(struct jffs2_sb_info *c, struct jffs2_inode_info *f, struct jffs2_full_dnode *fn)\n{\n\tint ret;\n\tstruct jffs2_node_frag *newfrag;\n\n\tif (unlikely(!fn->size))\n\t\treturn 0;\n\n\tnewfrag = new_fragment(fn, fn->ofs, fn->size);\n\tif (unlikely(!newfrag))\n\t\treturn -ENOMEM;\n\tnewfrag->node->frags = 1;\n\n\tdbg_fragtree(\"adding node %#04x-%#04x @0x%08x on flash, newfrag *%p\\n\",\n\t\t  fn->ofs, fn->ofs+fn->size, ref_offset(fn->raw), newfrag);\n\n\tret = jffs2_add_frag_to_fragtree(c, &f->fragtree, newfrag);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\t \n\tif (newfrag->ofs & (PAGE_SIZE-1)) {\n\t\tstruct jffs2_node_frag *prev = frag_prev(newfrag);\n\n\t\tmark_ref_normal(fn->raw);\n\t\t \n\t\tif (prev->node)\n\t\t\tmark_ref_normal(prev->node->raw);\n\t}\n\n\tif ((newfrag->ofs+newfrag->size) & (PAGE_SIZE-1)) {\n\t\tstruct jffs2_node_frag *next = frag_next(newfrag);\n\n\t\tif (next) {\n\t\t\tmark_ref_normal(fn->raw);\n\t\t\tif (next->node)\n\t\t\t\tmark_ref_normal(next->node->raw);\n\t\t}\n\t}\n\tjffs2_dbg_fragtree_paranoia_check_nolock(f);\n\n\treturn 0;\n}\n\nvoid jffs2_set_inocache_state(struct jffs2_sb_info *c, struct jffs2_inode_cache *ic, int state)\n{\n\tspin_lock(&c->inocache_lock);\n\tic->state = state;\n\twake_up(&c->inocache_wq);\n\tspin_unlock(&c->inocache_lock);\n}\n\n \n\nstruct jffs2_inode_cache *jffs2_get_ino_cache(struct jffs2_sb_info *c, uint32_t ino)\n{\n\tstruct jffs2_inode_cache *ret;\n\n\tret = c->inocache_list[ino % c->inocache_hashsize];\n\twhile (ret && ret->ino < ino) {\n\t\tret = ret->next;\n\t}\n\n\tif (ret && ret->ino != ino)\n\t\tret = NULL;\n\n\treturn ret;\n}\n\nvoid jffs2_add_ino_cache (struct jffs2_sb_info *c, struct jffs2_inode_cache *new)\n{\n\tstruct jffs2_inode_cache **prev;\n\n\tspin_lock(&c->inocache_lock);\n\tif (!new->ino)\n\t\tnew->ino = ++c->highest_ino;\n\n\tdbg_inocache(\"add %p (ino #%u)\\n\", new, new->ino);\n\n\tprev = &c->inocache_list[new->ino % c->inocache_hashsize];\n\n\twhile ((*prev) && (*prev)->ino < new->ino) {\n\t\tprev = &(*prev)->next;\n\t}\n\tnew->next = *prev;\n\t*prev = new;\n\n\tspin_unlock(&c->inocache_lock);\n}\n\nvoid jffs2_del_ino_cache(struct jffs2_sb_info *c, struct jffs2_inode_cache *old)\n{\n\tstruct jffs2_inode_cache **prev;\n\n#ifdef CONFIG_JFFS2_FS_XATTR\n\tBUG_ON(old->xref);\n#endif\n\tdbg_inocache(\"del %p (ino #%u)\\n\", old, old->ino);\n\tspin_lock(&c->inocache_lock);\n\n\tprev = &c->inocache_list[old->ino % c->inocache_hashsize];\n\n\twhile ((*prev) && (*prev)->ino < old->ino) {\n\t\tprev = &(*prev)->next;\n\t}\n\tif ((*prev) == old) {\n\t\t*prev = old->next;\n\t}\n\n\t \n\tif (old->state != INO_STATE_READING && old->state != INO_STATE_CLEARING)\n\t\tjffs2_free_inode_cache(old);\n\n\tspin_unlock(&c->inocache_lock);\n}\n\nvoid jffs2_free_ino_caches(struct jffs2_sb_info *c)\n{\n\tint i;\n\tstruct jffs2_inode_cache *this, *next;\n\n\tfor (i=0; i < c->inocache_hashsize; i++) {\n\t\tthis = c->inocache_list[i];\n\t\twhile (this) {\n\t\t\tnext = this->next;\n\t\t\tjffs2_xattr_free_inode(c, this);\n\t\t\tjffs2_free_inode_cache(this);\n\t\t\tthis = next;\n\t\t}\n\t\tc->inocache_list[i] = NULL;\n\t}\n}\n\nvoid jffs2_free_raw_node_refs(struct jffs2_sb_info *c)\n{\n\tint i;\n\tstruct jffs2_raw_node_ref *this, *next;\n\n\tfor (i=0; i<c->nr_blocks; i++) {\n\t\tthis = c->blocks[i].first_node;\n\t\twhile (this) {\n\t\t\tif (this[REFS_PER_BLOCK].flash_offset == REF_LINK_NODE)\n\t\t\t\tnext = this[REFS_PER_BLOCK].next_in_ino;\n\t\t\telse\n\t\t\t\tnext = NULL;\n\n\t\t\tjffs2_free_refblock(this);\n\t\t\tthis = next;\n\t\t}\n\t\tc->blocks[i].first_node = c->blocks[i].last_node = NULL;\n\t}\n}\n\nstruct jffs2_node_frag *jffs2_lookup_node_frag(struct rb_root *fragtree, uint32_t offset)\n{\n\t \n\tstruct rb_node *next;\n\tstruct jffs2_node_frag *prev = NULL;\n\tstruct jffs2_node_frag *frag = NULL;\n\n\tdbg_fragtree2(\"root %p, offset %d\\n\", fragtree, offset);\n\n\tnext = fragtree->rb_node;\n\n\twhile(next) {\n\t\tfrag = rb_entry(next, struct jffs2_node_frag, rb);\n\n\t\tif (frag->ofs + frag->size <= offset) {\n\t\t\t \n\t\t\tif (!prev || frag->ofs > prev->ofs)\n\t\t\t\tprev = frag;\n\t\t\tnext = frag->rb.rb_right;\n\t\t} else if (frag->ofs > offset) {\n\t\t\tnext = frag->rb.rb_left;\n\t\t} else {\n\t\t\treturn frag;\n\t\t}\n\t}\n\n\t \n\n\tif (prev)\n\t\tdbg_fragtree2(\"no match. Returning frag %#04x-%#04x, closest previous\\n\",\n\t\t\t  prev->ofs, prev->ofs+prev->size);\n\telse\n\t\tdbg_fragtree2(\"returning NULL, empty fragtree\\n\");\n\n\treturn prev;\n}\n\n \nvoid jffs2_kill_fragtree(struct rb_root *root, struct jffs2_sb_info *c)\n{\n\tstruct jffs2_node_frag *frag, *next;\n\n\tdbg_fragtree(\"killing\\n\");\n\trbtree_postorder_for_each_entry_safe(frag, next, root, rb) {\n\t\tif (frag->node && !(--frag->node->frags)) {\n\t\t\t \n\t\t\tif (c)\n\t\t\t\tjffs2_mark_node_obsolete(c, frag->node->raw);\n\n\t\t\tjffs2_free_full_dnode(frag->node);\n\t\t}\n\n\t\tjffs2_free_node_frag(frag);\n\t\tcond_resched();\n\t}\n}\n\nstruct jffs2_raw_node_ref *jffs2_link_node_ref(struct jffs2_sb_info *c,\n\t\t\t\t\t       struct jffs2_eraseblock *jeb,\n\t\t\t\t\t       uint32_t ofs, uint32_t len,\n\t\t\t\t\t       struct jffs2_inode_cache *ic)\n{\n\tstruct jffs2_raw_node_ref *ref;\n\n\tBUG_ON(!jeb->allocated_refs);\n\tjeb->allocated_refs--;\n\n\tref = jeb->last_node;\n\n\tdbg_noderef(\"Last node at %p is (%08x,%p)\\n\", ref, ref->flash_offset,\n\t\t    ref->next_in_ino);\n\n\twhile (ref->flash_offset != REF_EMPTY_NODE) {\n\t\tif (ref->flash_offset == REF_LINK_NODE)\n\t\t\tref = ref->next_in_ino;\n\t\telse\n\t\t\tref++;\n\t}\n\n\tdbg_noderef(\"New ref is %p (%08x becomes %08x,%p) len 0x%x\\n\", ref, \n\t\t    ref->flash_offset, ofs, ref->next_in_ino, len);\n\n\tref->flash_offset = ofs;\n\n\tif (!jeb->first_node) {\n\t\tjeb->first_node = ref;\n\t\tBUG_ON(ref_offset(ref) != jeb->offset);\n\t} else if (unlikely(ref_offset(ref) != jeb->offset + c->sector_size - jeb->free_size)) {\n\t\tuint32_t last_len = ref_totlen(c, jeb, jeb->last_node);\n\n\t\tJFFS2_ERROR(\"Adding new ref %p at (0x%08x-0x%08x) not immediately after previous (0x%08x-0x%08x)\\n\",\n\t\t\t    ref, ref_offset(ref), ref_offset(ref)+len,\n\t\t\t    ref_offset(jeb->last_node), \n\t\t\t    ref_offset(jeb->last_node)+last_len);\n\t\tBUG();\n\t}\n\tjeb->last_node = ref;\n\n\tif (ic) {\n\t\tref->next_in_ino = ic->nodes;\n\t\tic->nodes = ref;\n\t} else {\n\t\tref->next_in_ino = NULL;\n\t}\n\n\tswitch(ref_flags(ref)) {\n\tcase REF_UNCHECKED:\n\t\tc->unchecked_size += len;\n\t\tjeb->unchecked_size += len;\n\t\tbreak;\n\n\tcase REF_NORMAL:\n\tcase REF_PRISTINE:\n\t\tc->used_size += len;\n\t\tjeb->used_size += len;\n\t\tbreak;\n\n\tcase REF_OBSOLETE:\n\t\tc->dirty_size += len;\n\t\tjeb->dirty_size += len;\n\t\tbreak;\n\t}\n\tc->free_size -= len;\n\tjeb->free_size -= len;\n\n#ifdef TEST_TOTLEN\n\t \n\tref->__totlen = len;\n\tref_totlen(c, jeb, ref);\n#endif\n\treturn ref;\n}\n\n \nint jffs2_scan_dirty_space(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t   uint32_t size)\n{\n\tif (!size)\n\t\treturn 0;\n\tif (unlikely(size > jeb->free_size)) {\n\t\tpr_crit(\"Dirty space 0x%x larger then free_size 0x%x (wasted 0x%x)\\n\",\n\t\t\tsize, jeb->free_size, jeb->wasted_size);\n\t\tBUG();\n\t}\n\t \n\tif (jeb->last_node && ref_obsolete(jeb->last_node)) {\n#ifdef TEST_TOTLEN\n\t\tjeb->last_node->__totlen += size;\n#endif\n\t\tc->dirty_size += size;\n\t\tc->free_size -= size;\n\t\tjeb->dirty_size += size;\n\t\tjeb->free_size -= size;\n\t} else {\n\t\tuint32_t ofs = jeb->offset + c->sector_size - jeb->free_size;\n\t\tofs |= REF_OBSOLETE;\n\n\t\tjffs2_link_node_ref(c, jeb, ofs, size, NULL);\n\t}\n\n\treturn 0;\n}\n\n \nstatic inline uint32_t __ref_totlen(struct jffs2_sb_info *c,\n\t\t\t\t    struct jffs2_eraseblock *jeb,\n\t\t\t\t    struct jffs2_raw_node_ref *ref)\n{\n\tuint32_t ref_end;\n\tstruct jffs2_raw_node_ref *next_ref = ref_next(ref);\n\n\tif (next_ref)\n\t\tref_end = ref_offset(next_ref);\n\telse {\n\t\tif (!jeb)\n\t\t\tjeb = &c->blocks[ref->flash_offset / c->sector_size];\n\n\t\t \n\t\tif (unlikely(ref != jeb->last_node)) {\n\t\t\tpr_crit(\"ref %p @0x%08x is not jeb->last_node (%p @0x%08x)\\n\",\n\t\t\t\tref, ref_offset(ref), jeb->last_node,\n\t\t\t\tjeb->last_node ?\n\t\t\t\tref_offset(jeb->last_node) : 0);\n\t\t\tBUG();\n\t\t}\n\t\tref_end = jeb->offset + c->sector_size - jeb->free_size;\n\t}\n\treturn ref_end - ref_offset(ref);\n}\n\nuint32_t __jffs2_ref_totlen(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t    struct jffs2_raw_node_ref *ref)\n{\n\tuint32_t ret;\n\n\tret = __ref_totlen(c, jeb, ref);\n\n#ifdef TEST_TOTLEN\n\tif (unlikely(ret != ref->__totlen)) {\n\t\tif (!jeb)\n\t\t\tjeb = &c->blocks[ref->flash_offset / c->sector_size];\n\n\t\tpr_crit(\"Totlen for ref at %p (0x%08x-0x%08x) miscalculated as 0x%x instead of %x\\n\",\n\t\t\tref, ref_offset(ref), ref_offset(ref) + ref->__totlen,\n\t\t\tret, ref->__totlen);\n\t\tif (ref_next(ref)) {\n\t\t\tpr_crit(\"next %p (0x%08x-0x%08x)\\n\",\n\t\t\t\tref_next(ref), ref_offset(ref_next(ref)),\n\t\t\t\tref_offset(ref_next(ref)) + ref->__totlen);\n\t\t} else \n\t\t\tpr_crit(\"No next ref. jeb->last_node is %p\\n\",\n\t\t\t\tjeb->last_node);\n\n\t\tpr_crit(\"jeb->wasted_size %x, dirty_size %x, used_size %x, free_size %x\\n\",\n\t\t\tjeb->wasted_size, jeb->dirty_size, jeb->used_size,\n\t\t\tjeb->free_size);\n\n#if defined(JFFS2_DBG_DUMPS) || defined(JFFS2_DBG_PARANOIA_CHECKS)\n\t\t__jffs2_dbg_dump_node_refs_nolock(c, jeb);\n#endif\n\n\t\tWARN_ON(1);\n\n\t\tret = ref->__totlen;\n\t}\n#endif  \n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}