{
  "module_name": "background.c",
  "hash_id": "9d711c413dbd8fb90dfdde250442c83d52c1af777d42d2e138907032a47245f2",
  "original_prompt": "Ingested from linux-6.6.14/fs/jffs2/background.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/jffs2.h>\n#include <linux/mtd/mtd.h>\n#include <linux/completion.h>\n#include <linux/sched/signal.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"nodelist.h\"\n\n\nstatic int jffs2_garbage_collect_thread(void *);\n\nvoid jffs2_garbage_collect_trigger(struct jffs2_sb_info *c)\n{\n\tassert_spin_locked(&c->erase_completion_lock);\n\tif (c->gc_task && jffs2_thread_should_wake(c))\n\t\tsend_sig(SIGHUP, c->gc_task, 1);\n}\n\n \nint jffs2_start_garbage_collect_thread(struct jffs2_sb_info *c)\n{\n\tstruct task_struct *tsk;\n\tint ret = 0;\n\n\tBUG_ON(c->gc_task);\n\n\tinit_completion(&c->gc_thread_start);\n\tinit_completion(&c->gc_thread_exit);\n\n\ttsk = kthread_run(jffs2_garbage_collect_thread, c, \"jffs2_gcd_mtd%d\", c->mtd->index);\n\tif (IS_ERR(tsk)) {\n\t\tpr_warn(\"fork failed for JFFS2 garbage collect thread: %ld\\n\",\n\t\t\t-PTR_ERR(tsk));\n\t\tcomplete(&c->gc_thread_exit);\n\t\tret = PTR_ERR(tsk);\n\t} else {\n\t\t \n\t\tjffs2_dbg(1, \"Garbage collect thread is pid %d\\n\", tsk->pid);\n\t\twait_for_completion(&c->gc_thread_start);\n\t\tret = tsk->pid;\n\t}\n\n\treturn ret;\n}\n\nvoid jffs2_stop_garbage_collect_thread(struct jffs2_sb_info *c)\n{\n\tint wait = 0;\n\tspin_lock(&c->erase_completion_lock);\n\tif (c->gc_task) {\n\t\tjffs2_dbg(1, \"Killing GC task %d\\n\", c->gc_task->pid);\n\t\tsend_sig(SIGKILL, c->gc_task, 1);\n\t\twait = 1;\n\t}\n\tspin_unlock(&c->erase_completion_lock);\n\tif (wait)\n\t\twait_for_completion(&c->gc_thread_exit);\n}\n\nstatic int jffs2_garbage_collect_thread(void *_c)\n{\n\tstruct jffs2_sb_info *c = _c;\n\tsigset_t hupmask;\n\n\tsiginitset(&hupmask, sigmask(SIGHUP));\n\tallow_signal(SIGKILL);\n\tallow_signal(SIGSTOP);\n\tallow_signal(SIGHUP);\n\n\tc->gc_task = current;\n\tcomplete(&c->gc_thread_start);\n\n\tset_user_nice(current, 10);\n\n\tset_freezable();\n\tfor (;;) {\n\t\tsigprocmask(SIG_UNBLOCK, &hupmask, NULL);\n\tagain:\n\t\tspin_lock(&c->erase_completion_lock);\n\t\tif (!jffs2_thread_should_wake(c)) {\n\t\t\tset_current_state (TASK_INTERRUPTIBLE);\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\tjffs2_dbg(1, \"%s(): sleeping...\\n\", __func__);\n\t\t\tschedule();\n\t\t} else {\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t}\n\t\t \n\t\tschedule_timeout_interruptible(msecs_to_jiffies(50));\n\n\t\tif (kthread_should_stop()) {\n\t\t\tjffs2_dbg(1, \"%s(): kthread_stop() called\\n\", __func__);\n\t\t\tgoto die;\n\t\t}\n\n\t\t \n\t\twhile (signal_pending(current) || freezing(current)) {\n\t\t\tunsigned long signr;\n\n\t\t\tif (try_to_freeze())\n\t\t\t\tgoto again;\n\n\t\t\tsignr = kernel_dequeue_signal();\n\n\t\t\tswitch(signr) {\n\t\t\tcase SIGSTOP:\n\t\t\t\tjffs2_dbg(1, \"%s(): SIGSTOP received\\n\",\n\t\t\t\t\t  __func__);\n\t\t\t\tkernel_signal_stop();\n\t\t\t\tbreak;\n\n\t\t\tcase SIGKILL:\n\t\t\t\tjffs2_dbg(1, \"%s(): SIGKILL received\\n\",\n\t\t\t\t\t  __func__);\n\t\t\t\tgoto die;\n\n\t\t\tcase SIGHUP:\n\t\t\t\tjffs2_dbg(1, \"%s(): SIGHUP received\\n\",\n\t\t\t\t\t  __func__);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tjffs2_dbg(1, \"%s(): signal %ld received\\n\",\n\t\t\t\t\t  __func__, signr);\n\t\t\t}\n\t\t}\n\t\t \n\t\tsigprocmask(SIG_BLOCK, &hupmask, NULL);\n\n\t\tjffs2_dbg(1, \"%s(): pass\\n\", __func__);\n\t\tif (jffs2_garbage_collect_pass(c) == -ENOSPC) {\n\t\t\tpr_notice(\"No space for garbage collection. Aborting GC thread\\n\");\n\t\t\tgoto die;\n\t\t}\n\t}\n die:\n\tspin_lock(&c->erase_completion_lock);\n\tc->gc_task = NULL;\n\tspin_unlock(&c->erase_completion_lock);\n\tkthread_complete_and_exit(&c->gc_thread_exit, 0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}