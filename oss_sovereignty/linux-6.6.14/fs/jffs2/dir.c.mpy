{
  "module_name": "dir.c",
  "hash_id": "2ec78d24a454966c61872919355cb852e3e0c3b6ae7fa87714b5f8cf42486ab3",
  "original_prompt": "Ingested from linux-6.6.14/fs/jffs2/dir.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/jffs2.h>\n#include \"jffs2_fs_i.h\"\n#include \"jffs2_fs_sb.h\"\n#include <linux/time.h>\n#include \"nodelist.h\"\n\nstatic int jffs2_readdir (struct file *, struct dir_context *);\n\nstatic int jffs2_create (struct mnt_idmap *, struct inode *,\n\t\t         struct dentry *, umode_t, bool);\nstatic struct dentry *jffs2_lookup (struct inode *,struct dentry *,\n\t\t\t\t    unsigned int);\nstatic int jffs2_link (struct dentry *,struct inode *,struct dentry *);\nstatic int jffs2_unlink (struct inode *,struct dentry *);\nstatic int jffs2_symlink (struct mnt_idmap *, struct inode *,\n\t\t\t  struct dentry *, const char *);\nstatic int jffs2_mkdir (struct mnt_idmap *, struct inode *,struct dentry *,\n\t\t\tumode_t);\nstatic int jffs2_rmdir (struct inode *,struct dentry *);\nstatic int jffs2_mknod (struct mnt_idmap *, struct inode *,struct dentry *,\n\t\t\tumode_t,dev_t);\nstatic int jffs2_rename (struct mnt_idmap *, struct inode *,\n\t\t\t struct dentry *, struct inode *, struct dentry *,\n\t\t\t unsigned int);\n\nconst struct file_operations jffs2_dir_operations =\n{\n\t.read =\t\tgeneric_read_dir,\n\t.iterate_shared=jffs2_readdir,\n\t.unlocked_ioctl=jffs2_ioctl,\n\t.fsync =\tjffs2_fsync,\n\t.llseek =\tgeneric_file_llseek,\n};\n\n\nconst struct inode_operations jffs2_dir_inode_operations =\n{\n\t.create =\tjffs2_create,\n\t.lookup =\tjffs2_lookup,\n\t.link =\t\tjffs2_link,\n\t.unlink =\tjffs2_unlink,\n\t.symlink =\tjffs2_symlink,\n\t.mkdir =\tjffs2_mkdir,\n\t.rmdir =\tjffs2_rmdir,\n\t.mknod =\tjffs2_mknod,\n\t.rename =\tjffs2_rename,\n\t.get_inode_acl =\tjffs2_get_acl,\n\t.set_acl =\tjffs2_set_acl,\n\t.setattr =\tjffs2_setattr,\n\t.listxattr =\tjffs2_listxattr,\n};\n\n \n\n\n \nstatic struct dentry *jffs2_lookup(struct inode *dir_i, struct dentry *target,\n\t\t\t\t   unsigned int flags)\n{\n\tstruct jffs2_inode_info *dir_f;\n\tstruct jffs2_full_dirent *fd = NULL, *fd_list;\n\tuint32_t ino = 0;\n\tstruct inode *inode = NULL;\n\tunsigned int nhash;\n\n\tjffs2_dbg(1, \"jffs2_lookup()\\n\");\n\n\tif (target->d_name.len > JFFS2_MAX_NAME_LEN)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tdir_f = JFFS2_INODE_INFO(dir_i);\n\n\t \n\tnhash = full_name_hash(NULL, target->d_name.name, target->d_name.len);\n\n\tmutex_lock(&dir_f->sem);\n\n\t \n\tfor (fd_list = dir_f->dents; fd_list && fd_list->nhash <= nhash; fd_list = fd_list->next) {\n\t\tif (fd_list->nhash == nhash &&\n\t\t    (!fd || fd_list->version > fd->version) &&\n\t\t    strlen(fd_list->name) == target->d_name.len &&\n\t\t    !strncmp(fd_list->name, target->d_name.name, target->d_name.len)) {\n\t\t\tfd = fd_list;\n\t\t}\n\t}\n\tif (fd)\n\t\tino = fd->ino;\n\tmutex_unlock(&dir_f->sem);\n\tif (ino) {\n\t\tinode = jffs2_iget(dir_i->i_sb, ino);\n\t\tif (IS_ERR(inode))\n\t\t\tpr_warn(\"iget() failed for ino #%u\\n\", ino);\n\t}\n\n\treturn d_splice_alias(inode, target);\n}\n\n \n\n\nstatic int jffs2_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);\n\tstruct jffs2_full_dirent *fd;\n\tunsigned long curofs = 1;\n\n\tjffs2_dbg(1, \"jffs2_readdir() for dir_i #%lu\\n\", inode->i_ino);\n\n\tif (!dir_emit_dots(file, ctx))\n\t\treturn 0;\n\n\tmutex_lock(&f->sem);\n\tfor (fd = f->dents; fd; fd = fd->next) {\n\t\tcurofs++;\n\t\t \n\t\tif (curofs < ctx->pos) {\n\t\t\tjffs2_dbg(2, \"Skipping dirent: \\\"%s\\\", ino #%u, type %d, because curofs %ld < offset %ld\\n\",\n\t\t\t\t  fd->name, fd->ino, fd->type, curofs, (unsigned long)ctx->pos);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!fd->ino) {\n\t\t\tjffs2_dbg(2, \"Skipping deletion dirent \\\"%s\\\"\\n\",\n\t\t\t\t  fd->name);\n\t\t\tctx->pos++;\n\t\t\tcontinue;\n\t\t}\n\t\tjffs2_dbg(2, \"Dirent %ld: \\\"%s\\\", ino #%u, type %d\\n\",\n\t\t\t  (unsigned long)ctx->pos, fd->name, fd->ino, fd->type);\n\t\tif (!dir_emit(ctx, fd->name, strlen(fd->name), fd->ino, fd->type))\n\t\t\tbreak;\n\t\tctx->pos++;\n\t}\n\tmutex_unlock(&f->sem);\n\treturn 0;\n}\n\n \n\n\nstatic int jffs2_create(struct mnt_idmap *idmap, struct inode *dir_i,\n\t\t\tstruct dentry *dentry, umode_t mode, bool excl)\n{\n\tstruct jffs2_raw_inode *ri;\n\tstruct jffs2_inode_info *f, *dir_f;\n\tstruct jffs2_sb_info *c;\n\tstruct inode *inode;\n\tint ret;\n\n\tri = jffs2_alloc_raw_inode();\n\tif (!ri)\n\t\treturn -ENOMEM;\n\n\tc = JFFS2_SB_INFO(dir_i->i_sb);\n\n\tjffs2_dbg(1, \"%s()\\n\", __func__);\n\n\tinode = jffs2_new_inode(dir_i, mode, ri);\n\n\tif (IS_ERR(inode)) {\n\t\tjffs2_dbg(1, \"jffs2_new_inode() failed\\n\");\n\t\tjffs2_free_raw_inode(ri);\n\t\treturn PTR_ERR(inode);\n\t}\n\n\tinode->i_op = &jffs2_file_inode_operations;\n\tinode->i_fop = &jffs2_file_operations;\n\tinode->i_mapping->a_ops = &jffs2_file_address_operations;\n\tinode->i_mapping->nrpages = 0;\n\n\tf = JFFS2_INODE_INFO(inode);\n\tdir_f = JFFS2_INODE_INFO(dir_i);\n\n\t \n\tmutex_unlock(&f->sem);\n\n\tret = jffs2_do_create(c, dir_f, f, ri, &dentry->d_name);\n\tif (ret)\n\t\tgoto fail;\n\n\tdir_i->i_mtime = inode_set_ctime_to_ts(dir_i,\n\t\t\t\t\t       ITIME(je32_to_cpu(ri->ctime)));\n\n\tjffs2_free_raw_inode(ri);\n\n\tjffs2_dbg(1, \"%s(): Created ino #%lu with mode %o, nlink %d(%d). nrpages %ld\\n\",\n\t\t  __func__, inode->i_ino, inode->i_mode, inode->i_nlink,\n\t\t  f->inocache->pino_nlink, inode->i_mapping->nrpages);\n\n\td_instantiate_new(dentry, inode);\n\treturn 0;\n\n fail:\n\tiget_failed(inode);\n\tjffs2_free_raw_inode(ri);\n\treturn ret;\n}\n\n \n\n\nstatic int jffs2_unlink(struct inode *dir_i, struct dentry *dentry)\n{\n\tstruct jffs2_sb_info *c = JFFS2_SB_INFO(dir_i->i_sb);\n\tstruct jffs2_inode_info *dir_f = JFFS2_INODE_INFO(dir_i);\n\tstruct jffs2_inode_info *dead_f = JFFS2_INODE_INFO(d_inode(dentry));\n\tint ret;\n\tuint32_t now = JFFS2_NOW();\n\n\tret = jffs2_do_unlink(c, dir_f, dentry->d_name.name,\n\t\t\t      dentry->d_name.len, dead_f, now);\n\tif (dead_f->inocache)\n\t\tset_nlink(d_inode(dentry), dead_f->inocache->pino_nlink);\n\tif (!ret)\n\t\tdir_i->i_mtime = inode_set_ctime_to_ts(dir_i, ITIME(now));\n\treturn ret;\n}\n \n\n\nstatic int jffs2_link (struct dentry *old_dentry, struct inode *dir_i, struct dentry *dentry)\n{\n\tstruct jffs2_sb_info *c = JFFS2_SB_INFO(old_dentry->d_sb);\n\tstruct jffs2_inode_info *f = JFFS2_INODE_INFO(d_inode(old_dentry));\n\tstruct jffs2_inode_info *dir_f = JFFS2_INODE_INFO(dir_i);\n\tint ret;\n\tuint8_t type;\n\tuint32_t now;\n\n\t \n\tif (!f->inocache)\n\t\treturn -EIO;\n\n\tif (d_is_dir(old_dentry))\n\t\treturn -EPERM;\n\n\t \n\ttype = (d_inode(old_dentry)->i_mode & S_IFMT) >> 12;\n\tif (!type) type = DT_REG;\n\n\tnow = JFFS2_NOW();\n\tret = jffs2_do_link(c, dir_f, f->inocache->ino, type, dentry->d_name.name, dentry->d_name.len, now);\n\n\tif (!ret) {\n\t\tmutex_lock(&f->sem);\n\t\tset_nlink(d_inode(old_dentry), ++f->inocache->pino_nlink);\n\t\tmutex_unlock(&f->sem);\n\t\td_instantiate(dentry, d_inode(old_dentry));\n\t\tdir_i->i_mtime = inode_set_ctime_to_ts(dir_i, ITIME(now));\n\t\tihold(d_inode(old_dentry));\n\t}\n\treturn ret;\n}\n\n \n\nstatic int jffs2_symlink (struct mnt_idmap *idmap, struct inode *dir_i,\n\t\t\t  struct dentry *dentry, const char *target)\n{\n\tstruct jffs2_inode_info *f, *dir_f;\n\tstruct jffs2_sb_info *c;\n\tstruct inode *inode;\n\tstruct jffs2_raw_inode *ri;\n\tstruct jffs2_raw_dirent *rd;\n\tstruct jffs2_full_dnode *fn;\n\tstruct jffs2_full_dirent *fd;\n\tint namelen;\n\tuint32_t alloclen;\n\tint ret, targetlen = strlen(target);\n\n\t \n\tif (targetlen > 254)\n\t\treturn -ENAMETOOLONG;\n\n\tri = jffs2_alloc_raw_inode();\n\n\tif (!ri)\n\t\treturn -ENOMEM;\n\n\tc = JFFS2_SB_INFO(dir_i->i_sb);\n\n\t \n\tnamelen = dentry->d_name.len;\n\tret = jffs2_reserve_space(c, sizeof(*ri) + targetlen, &alloclen,\n\t\t\t\t  ALLOC_NORMAL, JFFS2_SUMMARY_INODE_SIZE);\n\n\tif (ret) {\n\t\tjffs2_free_raw_inode(ri);\n\t\treturn ret;\n\t}\n\n\tinode = jffs2_new_inode(dir_i, S_IFLNK | S_IRWXUGO, ri);\n\n\tif (IS_ERR(inode)) {\n\t\tjffs2_free_raw_inode(ri);\n\t\tjffs2_complete_reservation(c);\n\t\treturn PTR_ERR(inode);\n\t}\n\n\tinode->i_op = &jffs2_symlink_inode_operations;\n\n\tf = JFFS2_INODE_INFO(inode);\n\n\tinode->i_size = targetlen;\n\tri->isize = ri->dsize = ri->csize = cpu_to_je32(inode->i_size);\n\tri->totlen = cpu_to_je32(sizeof(*ri) + inode->i_size);\n\tri->hdr_crc = cpu_to_je32(crc32(0, ri, sizeof(struct jffs2_unknown_node)-4));\n\n\tri->compr = JFFS2_COMPR_NONE;\n\tri->data_crc = cpu_to_je32(crc32(0, target, targetlen));\n\tri->node_crc = cpu_to_je32(crc32(0, ri, sizeof(*ri)-8));\n\n\tfn = jffs2_write_dnode(c, f, ri, target, targetlen, ALLOC_NORMAL);\n\n\tjffs2_free_raw_inode(ri);\n\n\tif (IS_ERR(fn)) {\n\t\t \n\t\tmutex_unlock(&f->sem);\n\t\tjffs2_complete_reservation(c);\n\t\tret = PTR_ERR(fn);\n\t\tgoto fail;\n\t}\n\n\t \n\tf->target = kmemdup(target, targetlen + 1, GFP_KERNEL);\n\tif (!f->target) {\n\t\tpr_warn(\"Can't allocate %d bytes of memory\\n\", targetlen + 1);\n\t\tmutex_unlock(&f->sem);\n\t\tjffs2_complete_reservation(c);\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\tinode->i_link = f->target;\n\n\tjffs2_dbg(1, \"%s(): symlink's target '%s' cached\\n\",\n\t\t  __func__, (char *)f->target);\n\n\t \n\tf->metadata = fn;\n\tmutex_unlock(&f->sem);\n\n\tjffs2_complete_reservation(c);\n\n\tret = jffs2_init_security(inode, dir_i, &dentry->d_name);\n\tif (ret)\n\t\tgoto fail;\n\n\tret = jffs2_init_acl_post(inode);\n\tif (ret)\n\t\tgoto fail;\n\n\tret = jffs2_reserve_space(c, sizeof(*rd)+namelen, &alloclen,\n\t\t\t\t  ALLOC_NORMAL, JFFS2_SUMMARY_DIRENT_SIZE(namelen));\n\tif (ret)\n\t\tgoto fail;\n\n\trd = jffs2_alloc_raw_dirent();\n\tif (!rd) {\n\t\t \n\t\tjffs2_complete_reservation(c);\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tdir_f = JFFS2_INODE_INFO(dir_i);\n\tmutex_lock(&dir_f->sem);\n\n\trd->magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);\n\trd->nodetype = cpu_to_je16(JFFS2_NODETYPE_DIRENT);\n\trd->totlen = cpu_to_je32(sizeof(*rd) + namelen);\n\trd->hdr_crc = cpu_to_je32(crc32(0, rd, sizeof(struct jffs2_unknown_node)-4));\n\n\trd->pino = cpu_to_je32(dir_i->i_ino);\n\trd->version = cpu_to_je32(++dir_f->highest_version);\n\trd->ino = cpu_to_je32(inode->i_ino);\n\trd->mctime = cpu_to_je32(JFFS2_NOW());\n\trd->nsize = namelen;\n\trd->type = DT_LNK;\n\trd->node_crc = cpu_to_je32(crc32(0, rd, sizeof(*rd)-8));\n\trd->name_crc = cpu_to_je32(crc32(0, dentry->d_name.name, namelen));\n\n\tfd = jffs2_write_dirent(c, dir_f, rd, dentry->d_name.name, namelen, ALLOC_NORMAL);\n\n\tif (IS_ERR(fd)) {\n\t\t \n\t\tjffs2_complete_reservation(c);\n\t\tjffs2_free_raw_dirent(rd);\n\t\tmutex_unlock(&dir_f->sem);\n\t\tret = PTR_ERR(fd);\n\t\tgoto fail;\n\t}\n\n\tdir_i->i_mtime = inode_set_ctime_to_ts(dir_i,\n\t\t\t\t\t       ITIME(je32_to_cpu(rd->mctime)));\n\n\tjffs2_free_raw_dirent(rd);\n\n\t \n\tjffs2_add_fd_to_list(c, fd, &dir_f->dents);\n\n\tmutex_unlock(&dir_f->sem);\n\tjffs2_complete_reservation(c);\n\n\td_instantiate_new(dentry, inode);\n\treturn 0;\n\n fail:\n\tiget_failed(inode);\n\treturn ret;\n}\n\n\nstatic int jffs2_mkdir (struct mnt_idmap *idmap, struct inode *dir_i,\n\t\t        struct dentry *dentry, umode_t mode)\n{\n\tstruct jffs2_inode_info *f, *dir_f;\n\tstruct jffs2_sb_info *c;\n\tstruct inode *inode;\n\tstruct jffs2_raw_inode *ri;\n\tstruct jffs2_raw_dirent *rd;\n\tstruct jffs2_full_dnode *fn;\n\tstruct jffs2_full_dirent *fd;\n\tint namelen;\n\tuint32_t alloclen;\n\tint ret;\n\n\tmode |= S_IFDIR;\n\n\tri = jffs2_alloc_raw_inode();\n\tif (!ri)\n\t\treturn -ENOMEM;\n\n\tc = JFFS2_SB_INFO(dir_i->i_sb);\n\n\t \n\tnamelen = dentry->d_name.len;\n\tret = jffs2_reserve_space(c, sizeof(*ri), &alloclen, ALLOC_NORMAL,\n\t\t\t\t  JFFS2_SUMMARY_INODE_SIZE);\n\n\tif (ret) {\n\t\tjffs2_free_raw_inode(ri);\n\t\treturn ret;\n\t}\n\n\tinode = jffs2_new_inode(dir_i, mode, ri);\n\n\tif (IS_ERR(inode)) {\n\t\tjffs2_free_raw_inode(ri);\n\t\tjffs2_complete_reservation(c);\n\t\treturn PTR_ERR(inode);\n\t}\n\n\tinode->i_op = &jffs2_dir_inode_operations;\n\tinode->i_fop = &jffs2_dir_operations;\n\n\tf = JFFS2_INODE_INFO(inode);\n\n\t \n\tset_nlink(inode, 2);\n\t \n\tf->inocache->pino_nlink = dir_i->i_ino;\n\n\tri->data_crc = cpu_to_je32(0);\n\tri->node_crc = cpu_to_je32(crc32(0, ri, sizeof(*ri)-8));\n\n\tfn = jffs2_write_dnode(c, f, ri, NULL, 0, ALLOC_NORMAL);\n\n\tjffs2_free_raw_inode(ri);\n\n\tif (IS_ERR(fn)) {\n\t\t \n\t\tmutex_unlock(&f->sem);\n\t\tjffs2_complete_reservation(c);\n\t\tret = PTR_ERR(fn);\n\t\tgoto fail;\n\t}\n\t \n\tf->metadata = fn;\n\tmutex_unlock(&f->sem);\n\n\tjffs2_complete_reservation(c);\n\n\tret = jffs2_init_security(inode, dir_i, &dentry->d_name);\n\tif (ret)\n\t\tgoto fail;\n\n\tret = jffs2_init_acl_post(inode);\n\tif (ret)\n\t\tgoto fail;\n\n\tret = jffs2_reserve_space(c, sizeof(*rd)+namelen, &alloclen,\n\t\t\t\t  ALLOC_NORMAL, JFFS2_SUMMARY_DIRENT_SIZE(namelen));\n\tif (ret)\n\t\tgoto fail;\n\n\trd = jffs2_alloc_raw_dirent();\n\tif (!rd) {\n\t\t \n\t\tjffs2_complete_reservation(c);\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tdir_f = JFFS2_INODE_INFO(dir_i);\n\tmutex_lock(&dir_f->sem);\n\n\trd->magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);\n\trd->nodetype = cpu_to_je16(JFFS2_NODETYPE_DIRENT);\n\trd->totlen = cpu_to_je32(sizeof(*rd) + namelen);\n\trd->hdr_crc = cpu_to_je32(crc32(0, rd, sizeof(struct jffs2_unknown_node)-4));\n\n\trd->pino = cpu_to_je32(dir_i->i_ino);\n\trd->version = cpu_to_je32(++dir_f->highest_version);\n\trd->ino = cpu_to_je32(inode->i_ino);\n\trd->mctime = cpu_to_je32(JFFS2_NOW());\n\trd->nsize = namelen;\n\trd->type = DT_DIR;\n\trd->node_crc = cpu_to_je32(crc32(0, rd, sizeof(*rd)-8));\n\trd->name_crc = cpu_to_je32(crc32(0, dentry->d_name.name, namelen));\n\n\tfd = jffs2_write_dirent(c, dir_f, rd, dentry->d_name.name, namelen, ALLOC_NORMAL);\n\n\tif (IS_ERR(fd)) {\n\t\t \n\t\tjffs2_complete_reservation(c);\n\t\tjffs2_free_raw_dirent(rd);\n\t\tmutex_unlock(&dir_f->sem);\n\t\tret = PTR_ERR(fd);\n\t\tgoto fail;\n\t}\n\n\tdir_i->i_mtime = inode_set_ctime_to_ts(dir_i,\n\t\t\t\t\t       ITIME(je32_to_cpu(rd->mctime)));\n\tinc_nlink(dir_i);\n\n\tjffs2_free_raw_dirent(rd);\n\n\t \n\tjffs2_add_fd_to_list(c, fd, &dir_f->dents);\n\n\tmutex_unlock(&dir_f->sem);\n\tjffs2_complete_reservation(c);\n\n\td_instantiate_new(dentry, inode);\n\treturn 0;\n\n fail:\n\tiget_failed(inode);\n\treturn ret;\n}\n\nstatic int jffs2_rmdir (struct inode *dir_i, struct dentry *dentry)\n{\n\tstruct jffs2_sb_info *c = JFFS2_SB_INFO(dir_i->i_sb);\n\tstruct jffs2_inode_info *dir_f = JFFS2_INODE_INFO(dir_i);\n\tstruct jffs2_inode_info *f = JFFS2_INODE_INFO(d_inode(dentry));\n\tstruct jffs2_full_dirent *fd;\n\tint ret;\n\tuint32_t now = JFFS2_NOW();\n\n\tmutex_lock(&f->sem);\n\tfor (fd = f->dents ; fd; fd = fd->next) {\n\t\tif (fd->ino) {\n\t\t\tmutex_unlock(&f->sem);\n\t\t\treturn -ENOTEMPTY;\n\t\t}\n\t}\n\tmutex_unlock(&f->sem);\n\n\tret = jffs2_do_unlink(c, dir_f, dentry->d_name.name,\n\t\t\t      dentry->d_name.len, f, now);\n\tif (!ret) {\n\t\tdir_i->i_mtime = inode_set_ctime_to_ts(dir_i, ITIME(now));\n\t\tclear_nlink(d_inode(dentry));\n\t\tdrop_nlink(dir_i);\n\t}\n\treturn ret;\n}\n\nstatic int jffs2_mknod (struct mnt_idmap *idmap, struct inode *dir_i,\n\t\t        struct dentry *dentry, umode_t mode, dev_t rdev)\n{\n\tstruct jffs2_inode_info *f, *dir_f;\n\tstruct jffs2_sb_info *c;\n\tstruct inode *inode;\n\tstruct jffs2_raw_inode *ri;\n\tstruct jffs2_raw_dirent *rd;\n\tstruct jffs2_full_dnode *fn;\n\tstruct jffs2_full_dirent *fd;\n\tint namelen;\n\tunion jffs2_device_node dev;\n\tint devlen = 0;\n\tuint32_t alloclen;\n\tint ret;\n\n\tri = jffs2_alloc_raw_inode();\n\tif (!ri)\n\t\treturn -ENOMEM;\n\n\tc = JFFS2_SB_INFO(dir_i->i_sb);\n\n\tif (S_ISBLK(mode) || S_ISCHR(mode))\n\t\tdevlen = jffs2_encode_dev(&dev, rdev);\n\n\t \n\tnamelen = dentry->d_name.len;\n\tret = jffs2_reserve_space(c, sizeof(*ri) + devlen, &alloclen,\n\t\t\t\t  ALLOC_NORMAL, JFFS2_SUMMARY_INODE_SIZE);\n\n\tif (ret) {\n\t\tjffs2_free_raw_inode(ri);\n\t\treturn ret;\n\t}\n\n\tinode = jffs2_new_inode(dir_i, mode, ri);\n\n\tif (IS_ERR(inode)) {\n\t\tjffs2_free_raw_inode(ri);\n\t\tjffs2_complete_reservation(c);\n\t\treturn PTR_ERR(inode);\n\t}\n\tinode->i_op = &jffs2_file_inode_operations;\n\tinit_special_inode(inode, inode->i_mode, rdev);\n\n\tf = JFFS2_INODE_INFO(inode);\n\n\tri->dsize = ri->csize = cpu_to_je32(devlen);\n\tri->totlen = cpu_to_je32(sizeof(*ri) + devlen);\n\tri->hdr_crc = cpu_to_je32(crc32(0, ri, sizeof(struct jffs2_unknown_node)-4));\n\n\tri->compr = JFFS2_COMPR_NONE;\n\tri->data_crc = cpu_to_je32(crc32(0, &dev, devlen));\n\tri->node_crc = cpu_to_je32(crc32(0, ri, sizeof(*ri)-8));\n\n\tfn = jffs2_write_dnode(c, f, ri, (char *)&dev, devlen, ALLOC_NORMAL);\n\n\tjffs2_free_raw_inode(ri);\n\n\tif (IS_ERR(fn)) {\n\t\t \n\t\tmutex_unlock(&f->sem);\n\t\tjffs2_complete_reservation(c);\n\t\tret = PTR_ERR(fn);\n\t\tgoto fail;\n\t}\n\t \n\tf->metadata = fn;\n\tmutex_unlock(&f->sem);\n\n\tjffs2_complete_reservation(c);\n\n\tret = jffs2_init_security(inode, dir_i, &dentry->d_name);\n\tif (ret)\n\t\tgoto fail;\n\n\tret = jffs2_init_acl_post(inode);\n\tif (ret)\n\t\tgoto fail;\n\n\tret = jffs2_reserve_space(c, sizeof(*rd)+namelen, &alloclen,\n\t\t\t\t  ALLOC_NORMAL, JFFS2_SUMMARY_DIRENT_SIZE(namelen));\n\tif (ret)\n\t\tgoto fail;\n\n\trd = jffs2_alloc_raw_dirent();\n\tif (!rd) {\n\t\t \n\t\tjffs2_complete_reservation(c);\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tdir_f = JFFS2_INODE_INFO(dir_i);\n\tmutex_lock(&dir_f->sem);\n\n\trd->magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);\n\trd->nodetype = cpu_to_je16(JFFS2_NODETYPE_DIRENT);\n\trd->totlen = cpu_to_je32(sizeof(*rd) + namelen);\n\trd->hdr_crc = cpu_to_je32(crc32(0, rd, sizeof(struct jffs2_unknown_node)-4));\n\n\trd->pino = cpu_to_je32(dir_i->i_ino);\n\trd->version = cpu_to_je32(++dir_f->highest_version);\n\trd->ino = cpu_to_je32(inode->i_ino);\n\trd->mctime = cpu_to_je32(JFFS2_NOW());\n\trd->nsize = namelen;\n\n\t \n\trd->type = (mode & S_IFMT) >> 12;\n\n\trd->node_crc = cpu_to_je32(crc32(0, rd, sizeof(*rd)-8));\n\trd->name_crc = cpu_to_je32(crc32(0, dentry->d_name.name, namelen));\n\n\tfd = jffs2_write_dirent(c, dir_f, rd, dentry->d_name.name, namelen, ALLOC_NORMAL);\n\n\tif (IS_ERR(fd)) {\n\t\t \n\t\tjffs2_complete_reservation(c);\n\t\tjffs2_free_raw_dirent(rd);\n\t\tmutex_unlock(&dir_f->sem);\n\t\tret = PTR_ERR(fd);\n\t\tgoto fail;\n\t}\n\n\tdir_i->i_mtime = inode_set_ctime_to_ts(dir_i,\n\t\t\t\t\t       ITIME(je32_to_cpu(rd->mctime)));\n\n\tjffs2_free_raw_dirent(rd);\n\n\t \n\tjffs2_add_fd_to_list(c, fd, &dir_f->dents);\n\n\tmutex_unlock(&dir_f->sem);\n\tjffs2_complete_reservation(c);\n\n\td_instantiate_new(dentry, inode);\n\treturn 0;\n\n fail:\n\tiget_failed(inode);\n\treturn ret;\n}\n\nstatic int jffs2_rename (struct mnt_idmap *idmap,\n\t\t\t struct inode *old_dir_i, struct dentry *old_dentry,\n\t\t\t struct inode *new_dir_i, struct dentry *new_dentry,\n\t\t\t unsigned int flags)\n{\n\tint ret;\n\tstruct jffs2_sb_info *c = JFFS2_SB_INFO(old_dir_i->i_sb);\n\tstruct jffs2_inode_info *victim_f = NULL;\n\tuint8_t type;\n\tuint32_t now;\n\n\tif (flags & ~RENAME_NOREPLACE)\n\t\treturn -EINVAL;\n\n\t \n\tif (d_really_is_positive(new_dentry)) {\n\t\tvictim_f = JFFS2_INODE_INFO(d_inode(new_dentry));\n\t\tif (d_is_dir(new_dentry)) {\n\t\t\tstruct jffs2_full_dirent *fd;\n\n\t\t\tmutex_lock(&victim_f->sem);\n\t\t\tfor (fd = victim_f->dents; fd; fd = fd->next) {\n\t\t\t\tif (fd->ino) {\n\t\t\t\t\tmutex_unlock(&victim_f->sem);\n\t\t\t\t\treturn -ENOTEMPTY;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmutex_unlock(&victim_f->sem);\n\t\t}\n\t}\n\n\t \n\n\t \n\n\t \n\ttype = (d_inode(old_dentry)->i_mode & S_IFMT) >> 12;\n\tif (!type) type = DT_REG;\n\n\tnow = JFFS2_NOW();\n\tret = jffs2_do_link(c, JFFS2_INODE_INFO(new_dir_i),\n\t\t\t    d_inode(old_dentry)->i_ino, type,\n\t\t\t    new_dentry->d_name.name, new_dentry->d_name.len, now);\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (victim_f) {\n\t\t \n\t\tif (d_is_dir(new_dentry))\n\t\t\tclear_nlink(d_inode(new_dentry));\n\t\telse\n\t\t\tdrop_nlink(d_inode(new_dentry));\n\t\t \n\t\tif (victim_f->inocache) {\n\t\t\tmutex_lock(&victim_f->sem);\n\t\t\tif (d_is_dir(new_dentry))\n\t\t\t\tvictim_f->inocache->pino_nlink = 0;\n\t\t\telse\n\t\t\t\tvictim_f->inocache->pino_nlink--;\n\t\t\tmutex_unlock(&victim_f->sem);\n\t\t}\n\t}\n\n\t \n\tif (d_is_dir(old_dentry) && !victim_f)\n\t\tinc_nlink(new_dir_i);\n\n\t \n\tret = jffs2_do_unlink(c, JFFS2_INODE_INFO(old_dir_i),\n\t\t\t      old_dentry->d_name.name, old_dentry->d_name.len, NULL, now);\n\n\t \n\n\tif (ret) {\n\t\t \n\t\tstruct jffs2_inode_info *f = JFFS2_INODE_INFO(d_inode(old_dentry));\n\t\tmutex_lock(&f->sem);\n\t\tinc_nlink(d_inode(old_dentry));\n\t\tif (f->inocache && !d_is_dir(old_dentry))\n\t\t\tf->inocache->pino_nlink++;\n\t\tmutex_unlock(&f->sem);\n\n\t\tpr_notice(\"%s(): Link succeeded, unlink failed (err %d). You now have a hard link\\n\",\n\t\t\t  __func__, ret);\n\t\t \n\t\td_invalidate(new_dentry);\n\t\tnew_dir_i->i_mtime = inode_set_ctime_to_ts(new_dir_i,\n\t\t\t\t\t\t\t   ITIME(now));\n\t\treturn ret;\n\t}\n\n\tif (d_is_dir(old_dentry))\n\t\tdrop_nlink(old_dir_i);\n\n\told_dir_i->i_mtime = inode_set_ctime_to_ts(old_dir_i, ITIME(now));\n\tnew_dir_i->i_mtime = inode_set_ctime_to_ts(new_dir_i, ITIME(now));\n\n\treturn 0;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}