{
  "module_name": "xattr.c",
  "hash_id": "9616ab8de4967a2302acaa91d4cd6d69a427dfa53b9794516c2de5c90bf9b872",
  "original_prompt": "Ingested from linux-6.6.14/fs/jffs2/xattr.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#define JFFS2_XATTR_IS_CORRUPTED\t1\n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/crc32.h>\n#include <linux/jffs2.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/mtd/mtd.h>\n#include \"nodelist.h\"\n \nstatic uint32_t xattr_datum_hashkey(int xprefix, const char *xname, const char *xvalue, int xsize)\n{\n\tint name_len = strlen(xname);\n\n\treturn crc32(xprefix, xname, name_len) ^ crc32(xprefix, xvalue, xsize);\n}\n\nstatic int is_xattr_datum_unchecked(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd)\n{\n\tstruct jffs2_raw_node_ref *raw;\n\tint rc = 0;\n\n\tspin_lock(&c->erase_completion_lock);\n\tfor (raw=xd->node; raw != (void *)xd; raw=raw->next_in_ino) {\n\t\tif (ref_flags(raw) == REF_UNCHECKED) {\n\t\t\trc = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&c->erase_completion_lock);\n\treturn rc;\n}\n\nstatic void unload_xattr_datum(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd)\n{\n\t \n\tD1(dbg_xattr(\"%s: xid=%u, version=%u\\n\", __func__, xd->xid, xd->version));\n\tif (xd->xname) {\n\t\tc->xdatum_mem_usage -= (xd->name_len + 1 + xd->value_len);\n\t\tkfree(xd->xname);\n\t}\n\n\tlist_del_init(&xd->xindex);\n\txd->hashkey = 0;\n\txd->xname = NULL;\n\txd->xvalue = NULL;\n}\n\nstatic void reclaim_xattr_datum(struct jffs2_sb_info *c)\n{\n\t \n\tstruct jffs2_xattr_datum *xd, *_xd;\n\tuint32_t target, before;\n\tstatic int index = 0;\n\tint count;\n\n\tif (c->xdatum_mem_threshold > c->xdatum_mem_usage)\n\t\treturn;\n\n\tbefore = c->xdatum_mem_usage;\n\ttarget = c->xdatum_mem_usage * 4 / 5;  \n\tfor (count = 0; count < XATTRINDEX_HASHSIZE; count++) {\n\t\tlist_for_each_entry_safe(xd, _xd, &c->xattrindex[index], xindex) {\n\t\t\tif (xd->flags & JFFS2_XFLAGS_HOT) {\n\t\t\t\txd->flags &= ~JFFS2_XFLAGS_HOT;\n\t\t\t} else if (!(xd->flags & JFFS2_XFLAGS_BIND)) {\n\t\t\t\tunload_xattr_datum(c, xd);\n\t\t\t}\n\t\t\tif (c->xdatum_mem_usage <= target)\n\t\t\t\tgoto out;\n\t\t}\n\t\tindex = (index+1) % XATTRINDEX_HASHSIZE;\n\t}\n out:\n\tJFFS2_NOTICE(\"xdatum_mem_usage from %u byte to %u byte (%u byte reclaimed)\\n\",\n\t\t     before, c->xdatum_mem_usage, before - c->xdatum_mem_usage);\n}\n\nstatic int do_verify_xattr_datum(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd)\n{\n\t \n\tstruct jffs2_eraseblock *jeb;\n\tstruct jffs2_raw_node_ref *raw;\n\tstruct jffs2_raw_xattr rx;\n\tsize_t readlen;\n\tuint32_t crc, offset, totlen;\n\tint rc;\n\n\tspin_lock(&c->erase_completion_lock);\n\toffset = ref_offset(xd->node);\n\tif (ref_flags(xd->node) == REF_PRISTINE)\n\t\tgoto complete;\n\tspin_unlock(&c->erase_completion_lock);\n\n\trc = jffs2_flash_read(c, offset, sizeof(rx), &readlen, (char *)&rx);\n\tif (rc || readlen != sizeof(rx)) {\n\t\tJFFS2_WARNING(\"jffs2_flash_read()=%d, req=%zu, read=%zu at %#08x\\n\",\n\t\t\t      rc, sizeof(rx), readlen, offset);\n\t\treturn rc ? rc : -EIO;\n\t}\n\tcrc = crc32(0, &rx, sizeof(rx) - 4);\n\tif (crc != je32_to_cpu(rx.node_crc)) {\n\t\tJFFS2_ERROR(\"node CRC failed at %#08x, read=%#08x, calc=%#08x\\n\",\n\t\t\t    offset, je32_to_cpu(rx.hdr_crc), crc);\n\t\txd->flags |= JFFS2_XFLAGS_INVALID;\n\t\treturn JFFS2_XATTR_IS_CORRUPTED;\n\t}\n\ttotlen = PAD(sizeof(rx) + rx.name_len + 1 + je16_to_cpu(rx.value_len));\n\tif (je16_to_cpu(rx.magic) != JFFS2_MAGIC_BITMASK\n\t    || je16_to_cpu(rx.nodetype) != JFFS2_NODETYPE_XATTR\n\t    || je32_to_cpu(rx.totlen) != totlen\n\t    || je32_to_cpu(rx.xid) != xd->xid\n\t    || je32_to_cpu(rx.version) != xd->version) {\n\t\tJFFS2_ERROR(\"inconsistent xdatum at %#08x, magic=%#04x/%#04x, \"\n\t\t\t    \"nodetype=%#04x/%#04x, totlen=%u/%u, xid=%u/%u, version=%u/%u\\n\",\n\t\t\t    offset, je16_to_cpu(rx.magic), JFFS2_MAGIC_BITMASK,\n\t\t\t    je16_to_cpu(rx.nodetype), JFFS2_NODETYPE_XATTR,\n\t\t\t    je32_to_cpu(rx.totlen), totlen,\n\t\t\t    je32_to_cpu(rx.xid), xd->xid,\n\t\t\t    je32_to_cpu(rx.version), xd->version);\n\t\txd->flags |= JFFS2_XFLAGS_INVALID;\n\t\treturn JFFS2_XATTR_IS_CORRUPTED;\n\t}\n\txd->xprefix = rx.xprefix;\n\txd->name_len = rx.name_len;\n\txd->value_len = je16_to_cpu(rx.value_len);\n\txd->data_crc = je32_to_cpu(rx.data_crc);\n\n\tspin_lock(&c->erase_completion_lock);\n complete:\n\tfor (raw=xd->node; raw != (void *)xd; raw=raw->next_in_ino) {\n\t\tjeb = &c->blocks[ref_offset(raw) / c->sector_size];\n\t\ttotlen = PAD(ref_totlen(c, jeb, raw));\n\t\tif (ref_flags(raw) == REF_UNCHECKED) {\n\t\t\tc->unchecked_size -= totlen; c->used_size += totlen;\n\t\t\tjeb->unchecked_size -= totlen; jeb->used_size += totlen;\n\t\t}\n\t\traw->flash_offset = ref_offset(raw) | ((xd->node==raw) ? REF_PRISTINE : REF_NORMAL);\n\t}\n\tspin_unlock(&c->erase_completion_lock);\n\n\t \n\tlist_del_init(&xd->xindex);\n\n\tdbg_xattr(\"success on verifying xdatum (xid=%u, version=%u)\\n\",\n\t\t  xd->xid, xd->version);\n\n\treturn 0;\n}\n\nstatic int do_load_xattr_datum(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd)\n{\n\t \n\tchar *data;\n\tsize_t readlen;\n\tuint32_t crc, length;\n\tint i, ret, retry = 0;\n\n\tBUG_ON(ref_flags(xd->node) != REF_PRISTINE);\n\tBUG_ON(!list_empty(&xd->xindex));\n retry:\n\tlength = xd->name_len + 1 + xd->value_len;\n\tdata = kmalloc(length, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tret = jffs2_flash_read(c, ref_offset(xd->node)+sizeof(struct jffs2_raw_xattr),\n\t\t\t       length, &readlen, data);\n\n\tif (ret || length!=readlen) {\n\t\tJFFS2_WARNING(\"jffs2_flash_read() returned %d, request=%d, readlen=%zu, at %#08x\\n\",\n\t\t\t      ret, length, readlen, ref_offset(xd->node));\n\t\tkfree(data);\n\t\treturn ret ? ret : -EIO;\n\t}\n\n\tdata[xd->name_len] = '\\0';\n\tcrc = crc32(0, data, length);\n\tif (crc != xd->data_crc) {\n\t\tJFFS2_WARNING(\"node CRC failed (JFFS2_NODETYPE_XATTR)\"\n\t\t\t      \" at %#08x, read: 0x%08x calculated: 0x%08x\\n\",\n\t\t\t      ref_offset(xd->node), xd->data_crc, crc);\n\t\tkfree(data);\n\t\txd->flags |= JFFS2_XFLAGS_INVALID;\n\t\treturn JFFS2_XATTR_IS_CORRUPTED;\n\t}\n\n\txd->flags |= JFFS2_XFLAGS_HOT;\n\txd->xname = data;\n\txd->xvalue = data + xd->name_len+1;\n\n\tc->xdatum_mem_usage += length;\n\n\txd->hashkey = xattr_datum_hashkey(xd->xprefix, xd->xname, xd->xvalue, xd->value_len);\n\ti = xd->hashkey % XATTRINDEX_HASHSIZE;\n\tlist_add(&xd->xindex, &c->xattrindex[i]);\n\tif (!retry) {\n\t\tretry = 1;\n\t\treclaim_xattr_datum(c);\n\t\tif (!xd->xname)\n\t\t\tgoto retry;\n\t}\n\n\tdbg_xattr(\"success on loading xdatum (xid=%u, xprefix=%u, xname='%s')\\n\",\n\t\t  xd->xid, xd->xprefix, xd->xname);\n\n\treturn 0;\n}\n\nstatic int load_xattr_datum(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd)\n{\n\t \n\tint rc = 0;\n\n\tBUG_ON(xd->flags & JFFS2_XFLAGS_DEAD);\n\tif (xd->xname)\n\t\treturn 0;\n\tif (xd->flags & JFFS2_XFLAGS_INVALID)\n\t\treturn JFFS2_XATTR_IS_CORRUPTED;\n\tif (unlikely(is_xattr_datum_unchecked(c, xd)))\n\t\trc = do_verify_xattr_datum(c, xd);\n\tif (!rc)\n\t\trc = do_load_xattr_datum(c, xd);\n\treturn rc;\n}\n\nstatic int save_xattr_datum(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd)\n{\n\t \n\tstruct jffs2_raw_xattr rx;\n\tstruct kvec vecs[2];\n\tsize_t length;\n\tint rc, totlen;\n\tuint32_t phys_ofs = write_ofs(c);\n\n\tBUG_ON(!xd->xname);\n\tBUG_ON(xd->flags & (JFFS2_XFLAGS_DEAD|JFFS2_XFLAGS_INVALID));\n\n\tvecs[0].iov_base = &rx;\n\tvecs[0].iov_len = sizeof(rx);\n\tvecs[1].iov_base = xd->xname;\n\tvecs[1].iov_len = xd->name_len + 1 + xd->value_len;\n\ttotlen = vecs[0].iov_len + vecs[1].iov_len;\n\n\t \n\tmemset(&rx, 0, sizeof(rx));\n\trx.magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);\n\trx.nodetype = cpu_to_je16(JFFS2_NODETYPE_XATTR);\n\trx.totlen = cpu_to_je32(PAD(totlen));\n\trx.hdr_crc = cpu_to_je32(crc32(0, &rx, sizeof(struct jffs2_unknown_node) - 4));\n\n\trx.xid = cpu_to_je32(xd->xid);\n\trx.version = cpu_to_je32(++xd->version);\n\trx.xprefix = xd->xprefix;\n\trx.name_len = xd->name_len;\n\trx.value_len = cpu_to_je16(xd->value_len);\n\trx.data_crc = cpu_to_je32(crc32(0, vecs[1].iov_base, vecs[1].iov_len));\n\trx.node_crc = cpu_to_je32(crc32(0, &rx, sizeof(struct jffs2_raw_xattr) - 4));\n\n\trc = jffs2_flash_writev(c, vecs, 2, phys_ofs, &length, 0);\n\tif (rc || totlen != length) {\n\t\tJFFS2_WARNING(\"jffs2_flash_writev()=%d, req=%u, wrote=%zu, at %#08x\\n\",\n\t\t\t      rc, totlen, length, phys_ofs);\n\t\trc = rc ? rc : -EIO;\n\t\tif (length)\n\t\t\tjffs2_add_physical_node_ref(c, phys_ofs | REF_OBSOLETE, PAD(totlen), NULL);\n\n\t\treturn rc;\n\t}\n\t \n\tjffs2_add_physical_node_ref(c, phys_ofs | REF_PRISTINE, PAD(totlen), (void *)xd);\n\n\tdbg_xattr(\"success on saving xdatum (xid=%u, version=%u, xprefix=%u, xname='%s')\\n\",\n\t\t  xd->xid, xd->version, xd->xprefix, xd->xname);\n\n\treturn 0;\n}\n\nstatic struct jffs2_xattr_datum *create_xattr_datum(struct jffs2_sb_info *c,\n\t\t\t\t\t\t    int xprefix, const char *xname,\n\t\t\t\t\t\t    const char *xvalue, int xsize)\n{\n\t \n\tstruct jffs2_xattr_datum *xd;\n\tuint32_t hashkey, name_len;\n\tchar *data;\n\tint i, rc;\n\n\t \n\thashkey = xattr_datum_hashkey(xprefix, xname, xvalue, xsize);\n\ti = hashkey % XATTRINDEX_HASHSIZE;\n\tlist_for_each_entry(xd, &c->xattrindex[i], xindex) {\n\t\tif (xd->hashkey==hashkey\n\t\t    && xd->xprefix==xprefix\n\t\t    && xd->value_len==xsize\n\t\t    && !strcmp(xd->xname, xname)\n\t\t    && !memcmp(xd->xvalue, xvalue, xsize)) {\n\t\t\tatomic_inc(&xd->refcnt);\n\t\t\treturn xd;\n\t\t}\n\t}\n\n\t \n\tname_len = strlen(xname);\n\n\txd = jffs2_alloc_xattr_datum();\n\tif (!xd)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdata = kmalloc(name_len + 1 + xsize, GFP_KERNEL);\n\tif (!data) {\n\t\tjffs2_free_xattr_datum(xd);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tstrcpy(data, xname);\n\tmemcpy(data + name_len + 1, xvalue, xsize);\n\n\tatomic_set(&xd->refcnt, 1);\n\txd->xid = ++c->highest_xid;\n\txd->flags |= JFFS2_XFLAGS_HOT;\n\txd->xprefix = xprefix;\n\n\txd->hashkey = hashkey;\n\txd->xname = data;\n\txd->xvalue = data + name_len + 1;\n\txd->name_len = name_len;\n\txd->value_len = xsize;\n\txd->data_crc = crc32(0, data, xd->name_len + 1 + xd->value_len);\n\n\trc = save_xattr_datum(c, xd);\n\tif (rc) {\n\t\tkfree(xd->xname);\n\t\tjffs2_free_xattr_datum(xd);\n\t\treturn ERR_PTR(rc);\n\t}\n\n\t \n\ti = hashkey % XATTRINDEX_HASHSIZE;\n\tlist_add(&xd->xindex, &c->xattrindex[i]);\n\n\tc->xdatum_mem_usage += (xd->name_len + 1 + xd->value_len);\n\treclaim_xattr_datum(c);\n\n\treturn xd;\n}\n\nstatic void unrefer_xattr_datum(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd)\n{\n\t \n\tif (atomic_dec_and_lock(&xd->refcnt, &c->erase_completion_lock)) {\n\t\tunload_xattr_datum(c, xd);\n\t\txd->flags |= JFFS2_XFLAGS_DEAD;\n\t\tif (xd->node == (void *)xd) {\n\t\t\tBUG_ON(!(xd->flags & JFFS2_XFLAGS_INVALID));\n\t\t\tjffs2_free_xattr_datum(xd);\n\t\t} else {\n\t\t\tlist_add(&xd->xindex, &c->xattr_dead_list);\n\t\t}\n\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\tdbg_xattr(\"xdatum(xid=%u, version=%u) was removed.\\n\",\n\t\t\t  xd->xid, xd->version);\n\t}\n}\n\n \nstatic int verify_xattr_ref(struct jffs2_sb_info *c, struct jffs2_xattr_ref *ref)\n{\n\tstruct jffs2_eraseblock *jeb;\n\tstruct jffs2_raw_node_ref *raw;\n\tstruct jffs2_raw_xref rr;\n\tsize_t readlen;\n\tuint32_t crc, offset, totlen;\n\tint rc;\n\n\tspin_lock(&c->erase_completion_lock);\n\tif (ref_flags(ref->node) != REF_UNCHECKED)\n\t\tgoto complete;\n\toffset = ref_offset(ref->node);\n\tspin_unlock(&c->erase_completion_lock);\n\n\trc = jffs2_flash_read(c, offset, sizeof(rr), &readlen, (char *)&rr);\n\tif (rc || sizeof(rr) != readlen) {\n\t\tJFFS2_WARNING(\"jffs2_flash_read()=%d, req=%zu, read=%zu, at %#08x\\n\",\n\t\t\t      rc, sizeof(rr), readlen, offset);\n\t\treturn rc ? rc : -EIO;\n\t}\n\t \n\tcrc = crc32(0, &rr, sizeof(rr) - 4);\n\tif (crc != je32_to_cpu(rr.node_crc)) {\n\t\tJFFS2_ERROR(\"node CRC failed at %#08x, read=%#08x, calc=%#08x\\n\",\n\t\t\t    offset, je32_to_cpu(rr.node_crc), crc);\n\t\treturn JFFS2_XATTR_IS_CORRUPTED;\n\t}\n\tif (je16_to_cpu(rr.magic) != JFFS2_MAGIC_BITMASK\n\t    || je16_to_cpu(rr.nodetype) != JFFS2_NODETYPE_XREF\n\t    || je32_to_cpu(rr.totlen) != PAD(sizeof(rr))) {\n\t\tJFFS2_ERROR(\"inconsistent xref at %#08x, magic=%#04x/%#04x, \"\n\t\t\t    \"nodetype=%#04x/%#04x, totlen=%u/%zu\\n\",\n\t\t\t    offset, je16_to_cpu(rr.magic), JFFS2_MAGIC_BITMASK,\n\t\t\t    je16_to_cpu(rr.nodetype), JFFS2_NODETYPE_XREF,\n\t\t\t    je32_to_cpu(rr.totlen), PAD(sizeof(rr)));\n\t\treturn JFFS2_XATTR_IS_CORRUPTED;\n\t}\n\tref->ino = je32_to_cpu(rr.ino);\n\tref->xid = je32_to_cpu(rr.xid);\n\tref->xseqno = je32_to_cpu(rr.xseqno);\n\tif (ref->xseqno > c->highest_xseqno)\n\t\tc->highest_xseqno = (ref->xseqno & ~XREF_DELETE_MARKER);\n\n\tspin_lock(&c->erase_completion_lock);\n complete:\n\tfor (raw=ref->node; raw != (void *)ref; raw=raw->next_in_ino) {\n\t\tjeb = &c->blocks[ref_offset(raw) / c->sector_size];\n\t\ttotlen = PAD(ref_totlen(c, jeb, raw));\n\t\tif (ref_flags(raw) == REF_UNCHECKED) {\n\t\t\tc->unchecked_size -= totlen; c->used_size += totlen;\n\t\t\tjeb->unchecked_size -= totlen; jeb->used_size += totlen;\n\t\t}\n\t\traw->flash_offset = ref_offset(raw) | ((ref->node==raw) ? REF_PRISTINE : REF_NORMAL);\n\t}\n\tspin_unlock(&c->erase_completion_lock);\n\n\tdbg_xattr(\"success on verifying xref (ino=%u, xid=%u) at %#08x\\n\",\n\t\t  ref->ino, ref->xid, ref_offset(ref->node));\n\treturn 0;\n}\n\nstatic int save_xattr_ref(struct jffs2_sb_info *c, struct jffs2_xattr_ref *ref)\n{\n\t \n\tstruct jffs2_raw_xref rr;\n\tsize_t length;\n\tuint32_t xseqno, phys_ofs = write_ofs(c);\n\tint ret;\n\n\trr.magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);\n\trr.nodetype = cpu_to_je16(JFFS2_NODETYPE_XREF);\n\trr.totlen = cpu_to_je32(PAD(sizeof(rr)));\n\trr.hdr_crc = cpu_to_je32(crc32(0, &rr, sizeof(struct jffs2_unknown_node) - 4));\n\n\txseqno = (c->highest_xseqno += 2);\n\tif (is_xattr_ref_dead(ref)) {\n\t\txseqno |= XREF_DELETE_MARKER;\n\t\trr.ino = cpu_to_je32(ref->ino);\n\t\trr.xid = cpu_to_je32(ref->xid);\n\t} else {\n\t\trr.ino = cpu_to_je32(ref->ic->ino);\n\t\trr.xid = cpu_to_je32(ref->xd->xid);\n\t}\n\trr.xseqno = cpu_to_je32(xseqno);\n\trr.node_crc = cpu_to_je32(crc32(0, &rr, sizeof(rr) - 4));\n\n\tret = jffs2_flash_write(c, phys_ofs, sizeof(rr), &length, (char *)&rr);\n\tif (ret || sizeof(rr) != length) {\n\t\tJFFS2_WARNING(\"jffs2_flash_write() returned %d, request=%zu, retlen=%zu, at %#08x\\n\",\n\t\t\t      ret, sizeof(rr), length, phys_ofs);\n\t\tret = ret ? ret : -EIO;\n\t\tif (length)\n\t\t\tjffs2_add_physical_node_ref(c, phys_ofs | REF_OBSOLETE, PAD(sizeof(rr)), NULL);\n\n\t\treturn ret;\n\t}\n\t \n\tref->xseqno = xseqno;\n\tjffs2_add_physical_node_ref(c, phys_ofs | REF_PRISTINE, PAD(sizeof(rr)), (void *)ref);\n\n\tdbg_xattr(\"success on saving xref (ino=%u, xid=%u)\\n\", ref->ic->ino, ref->xd->xid);\n\n\treturn 0;\n}\n\nstatic struct jffs2_xattr_ref *create_xattr_ref(struct jffs2_sb_info *c, struct jffs2_inode_cache *ic,\n\t\t\t\t\t\tstruct jffs2_xattr_datum *xd)\n{\n\t \n\tstruct jffs2_xattr_ref *ref;\n\tint ret;\n\n\tref = jffs2_alloc_xattr_ref();\n\tif (!ref)\n\t\treturn ERR_PTR(-ENOMEM);\n\tref->ic = ic;\n\tref->xd = xd;\n\n\tret = save_xattr_ref(c, ref);\n\tif (ret) {\n\t\tjffs2_free_xattr_ref(ref);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t \n\tref->next = ic->xref;\n\tic->xref = ref;\n\n\treturn ref;  \n}\n\nstatic void delete_xattr_ref(struct jffs2_sb_info *c, struct jffs2_xattr_ref *ref)\n{\n\t \n\tstruct jffs2_xattr_datum *xd;\n\n\txd = ref->xd;\n\tref->xseqno |= XREF_DELETE_MARKER;\n\tref->ino = ref->ic->ino;\n\tref->xid = ref->xd->xid;\n\tspin_lock(&c->erase_completion_lock);\n\tref->next = c->xref_dead_list;\n\tc->xref_dead_list = ref;\n\tspin_unlock(&c->erase_completion_lock);\n\n\tdbg_xattr(\"xref(ino=%u, xid=%u, xseqno=%u) was removed.\\n\",\n\t\t  ref->ino, ref->xid, ref->xseqno);\n\n\tunrefer_xattr_datum(c, xd);\n}\n\nvoid jffs2_xattr_delete_inode(struct jffs2_sb_info *c, struct jffs2_inode_cache *ic)\n{\n\t \n\tstruct jffs2_xattr_ref *ref, *_ref;\n\n\tif (!ic || ic->pino_nlink > 0)\n\t\treturn;\n\n\tdown_write(&c->xattr_sem);\n\tfor (ref = ic->xref; ref; ref = _ref) {\n\t\t_ref = ref->next;\n\t\tdelete_xattr_ref(c, ref);\n\t}\n\tic->xref = NULL;\n\tup_write(&c->xattr_sem);\n}\n\nvoid jffs2_xattr_free_inode(struct jffs2_sb_info *c, struct jffs2_inode_cache *ic)\n{\n\t \n\tstruct jffs2_xattr_datum *xd;\n\tstruct jffs2_xattr_ref *ref, *_ref;\n\n\tdown_write(&c->xattr_sem);\n\tfor (ref = ic->xref; ref; ref = _ref) {\n\t\t_ref = ref->next;\n\t\txd = ref->xd;\n\t\tif (atomic_dec_and_test(&xd->refcnt)) {\n\t\t\tunload_xattr_datum(c, xd);\n\t\t\tjffs2_free_xattr_datum(xd);\n\t\t}\n\t\tjffs2_free_xattr_ref(ref);\n\t}\n\tic->xref = NULL;\n\tup_write(&c->xattr_sem);\n}\n\nstatic int check_xattr_ref_inode(struct jffs2_sb_info *c, struct jffs2_inode_cache *ic)\n{\n\t \n\tstruct jffs2_xattr_ref *ref, *cmp, **pref, **pcmp;\n\tint rc = 0;\n\n\tif (likely(ic->flags & INO_FLAGS_XATTR_CHECKED))\n\t\treturn 0;\n\tdown_write(&c->xattr_sem);\n retry:\n\trc = 0;\n\tfor (ref=ic->xref, pref=&ic->xref; ref; pref=&ref->next, ref=ref->next) {\n\t\tif (!ref->xd->xname) {\n\t\t\trc = load_xattr_datum(c, ref->xd);\n\t\t\tif (unlikely(rc > 0)) {\n\t\t\t\t*pref = ref->next;\n\t\t\t\tdelete_xattr_ref(c, ref);\n\t\t\t\tgoto retry;\n\t\t\t} else if (unlikely(rc < 0))\n\t\t\t\tgoto out;\n\t\t}\n\t\tfor (cmp=ref->next, pcmp=&ref->next; cmp; pcmp=&cmp->next, cmp=cmp->next) {\n\t\t\tif (!cmp->xd->xname) {\n\t\t\t\tref->xd->flags |= JFFS2_XFLAGS_BIND;\n\t\t\t\trc = load_xattr_datum(c, cmp->xd);\n\t\t\t\tref->xd->flags &= ~JFFS2_XFLAGS_BIND;\n\t\t\t\tif (unlikely(rc > 0)) {\n\t\t\t\t\t*pcmp = cmp->next;\n\t\t\t\t\tdelete_xattr_ref(c, cmp);\n\t\t\t\t\tgoto retry;\n\t\t\t\t} else if (unlikely(rc < 0))\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (ref->xd->xprefix == cmp->xd->xprefix\n\t\t\t    && !strcmp(ref->xd->xname, cmp->xd->xname)) {\n\t\t\t\tif (ref->xseqno > cmp->xseqno) {\n\t\t\t\t\t*pcmp = cmp->next;\n\t\t\t\t\tdelete_xattr_ref(c, cmp);\n\t\t\t\t} else {\n\t\t\t\t\t*pref = ref->next;\n\t\t\t\t\tdelete_xattr_ref(c, ref);\n\t\t\t\t}\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t}\n\t}\n\tic->flags |= INO_FLAGS_XATTR_CHECKED;\n out:\n\tup_write(&c->xattr_sem);\n\n\treturn rc;\n}\n\nvoid jffs2_xattr_do_crccheck_inode(struct jffs2_sb_info *c, struct jffs2_inode_cache *ic)\n{\n\tcheck_xattr_ref_inode(c, ic);\n}\n\n \nvoid jffs2_init_xattr_subsystem(struct jffs2_sb_info *c)\n{\n\tint i;\n\n\tfor (i=0; i < XATTRINDEX_HASHSIZE; i++)\n\t\tINIT_LIST_HEAD(&c->xattrindex[i]);\n\tINIT_LIST_HEAD(&c->xattr_unchecked);\n\tINIT_LIST_HEAD(&c->xattr_dead_list);\n\tc->xref_dead_list = NULL;\n\tc->xref_temp = NULL;\n\n\tinit_rwsem(&c->xattr_sem);\n\tc->highest_xid = 0;\n\tc->highest_xseqno = 0;\n\tc->xdatum_mem_usage = 0;\n\tc->xdatum_mem_threshold = 32 * 1024;\t \n}\n\nstatic struct jffs2_xattr_datum *jffs2_find_xattr_datum(struct jffs2_sb_info *c, uint32_t xid)\n{\n\tstruct jffs2_xattr_datum *xd;\n\tint i = xid % XATTRINDEX_HASHSIZE;\n\n\t \n\tBUG_ON(!(c->flags & (JFFS2_SB_FLAG_SCANNING|JFFS2_SB_FLAG_BUILDING)));\n\n\tlist_for_each_entry(xd, &c->xattrindex[i], xindex) {\n\t\tif (xd->xid==xid)\n\t\t\treturn xd;\n\t}\n\treturn NULL;\n}\n\nvoid jffs2_clear_xattr_subsystem(struct jffs2_sb_info *c)\n{\n\tstruct jffs2_xattr_datum *xd, *_xd;\n\tstruct jffs2_xattr_ref *ref, *_ref;\n\tint i;\n\n\tfor (ref=c->xref_temp; ref; ref = _ref) {\n\t\t_ref = ref->next;\n\t\tjffs2_free_xattr_ref(ref);\n\t}\n\n\tfor (ref=c->xref_dead_list; ref; ref = _ref) {\n\t\t_ref = ref->next;\n\t\tjffs2_free_xattr_ref(ref);\n\t}\n\n\tfor (i=0; i < XATTRINDEX_HASHSIZE; i++) {\n\t\tlist_for_each_entry_safe(xd, _xd, &c->xattrindex[i], xindex) {\n\t\t\tlist_del(&xd->xindex);\n\t\t\tkfree(xd->xname);\n\t\t\tjffs2_free_xattr_datum(xd);\n\t\t}\n\t}\n\n\tlist_for_each_entry_safe(xd, _xd, &c->xattr_dead_list, xindex) {\n\t\tlist_del(&xd->xindex);\n\t\tjffs2_free_xattr_datum(xd);\n\t}\n\tlist_for_each_entry_safe(xd, _xd, &c->xattr_unchecked, xindex) {\n\t\tlist_del(&xd->xindex);\n\t\tjffs2_free_xattr_datum(xd);\n\t}\n}\n\n#define XREF_TMPHASH_SIZE\t(128)\nint jffs2_build_xattr_subsystem(struct jffs2_sb_info *c)\n{\n\tstruct jffs2_xattr_ref *ref, *_ref;\n\tstruct jffs2_xattr_ref **xref_tmphash;\n\tstruct jffs2_xattr_datum *xd, *_xd;\n\tstruct jffs2_inode_cache *ic;\n\tstruct jffs2_raw_node_ref *raw;\n\tint i, xdatum_count = 0, xdatum_unchecked_count = 0, xref_count = 0;\n\tint xdatum_orphan_count = 0, xref_orphan_count = 0, xref_dead_count = 0;\n\n\tBUG_ON(!(c->flags & JFFS2_SB_FLAG_BUILDING));\n\n\txref_tmphash = kcalloc(XREF_TMPHASH_SIZE,\n\t\t\t       sizeof(struct jffs2_xattr_ref *), GFP_KERNEL);\n\tif (!xref_tmphash)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (ref=c->xref_temp; ref; ref=_ref) {\n\t\tstruct jffs2_xattr_ref *tmp;\n\n\t\t_ref = ref->next;\n\t\tif (ref_flags(ref->node) != REF_PRISTINE) {\n\t\t\tif (verify_xattr_ref(c, ref)) {\n\t\t\t\tBUG_ON(ref->node->next_in_ino != (void *)ref);\n\t\t\t\tref->node->next_in_ino = NULL;\n\t\t\t\tjffs2_mark_node_obsolete(c, ref->node);\n\t\t\t\tjffs2_free_xattr_ref(ref);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\ti = (ref->ino ^ ref->xid) % XREF_TMPHASH_SIZE;\n\t\tfor (tmp=xref_tmphash[i]; tmp; tmp=tmp->next) {\n\t\t\tif (tmp->ino == ref->ino && tmp->xid == ref->xid)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (tmp) {\n\t\t\traw = ref->node;\n\t\t\tif (ref->xseqno > tmp->xseqno) {\n\t\t\t\ttmp->xseqno = ref->xseqno;\n\t\t\t\traw->next_in_ino = tmp->node;\n\t\t\t\ttmp->node = raw;\n\t\t\t} else {\n\t\t\t\traw->next_in_ino = tmp->node->next_in_ino;\n\t\t\t\ttmp->node->next_in_ino = raw;\n\t\t\t}\n\t\t\tjffs2_free_xattr_ref(ref);\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tref->next = xref_tmphash[i];\n\t\t\txref_tmphash[i] = ref;\n\t\t}\n\t}\n\tc->xref_temp = NULL;\n\n\t \n\tfor (i=0; i < XREF_TMPHASH_SIZE; i++) {\n\t\tfor (ref=xref_tmphash[i]; ref; ref=_ref) {\n\t\t\txref_count++;\n\t\t\t_ref = ref->next;\n\t\t\tif (is_xattr_ref_dead(ref)) {\n\t\t\t\tref->next = c->xref_dead_list;\n\t\t\t\tc->xref_dead_list = ref;\n\t\t\t\txref_dead_count++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t \n\t\t\txd = jffs2_find_xattr_datum(c, ref->xid);\n\t\t\tic = jffs2_get_ino_cache(c, ref->ino);\n\t\t\tif (!xd || !ic || !ic->pino_nlink) {\n\t\t\t\tdbg_xattr(\"xref(ino=%u, xid=%u, xseqno=%u) is orphan.\\n\",\n\t\t\t\t\t  ref->ino, ref->xid, ref->xseqno);\n\t\t\t\tref->xseqno |= XREF_DELETE_MARKER;\n\t\t\t\tref->next = c->xref_dead_list;\n\t\t\t\tc->xref_dead_list = ref;\n\t\t\t\txref_orphan_count++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tref->xd = xd;\n\t\t\tref->ic = ic;\n\t\t\tatomic_inc(&xd->refcnt);\n\t\t\tref->next = ic->xref;\n\t\t\tic->xref = ref;\n\t\t}\n\t}\n\n\t \n\tfor (i=0; i < XATTRINDEX_HASHSIZE; i++) {\n\t\tlist_for_each_entry_safe(xd, _xd, &c->xattrindex[i], xindex) {\n\t\t\txdatum_count++;\n\t\t\tlist_del_init(&xd->xindex);\n\t\t\tif (!atomic_read(&xd->refcnt)) {\n\t\t\t\tdbg_xattr(\"xdatum(xid=%u, version=%u) is orphan.\\n\",\n\t\t\t\t\t  xd->xid, xd->version);\n\t\t\t\txd->flags |= JFFS2_XFLAGS_DEAD;\n\t\t\t\tlist_add(&xd->xindex, &c->xattr_unchecked);\n\t\t\t\txdatum_orphan_count++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (is_xattr_datum_unchecked(c, xd)) {\n\t\t\t\tdbg_xattr(\"unchecked xdatum(xid=%u, version=%u)\\n\",\n\t\t\t\t\t  xd->xid, xd->version);\n\t\t\t\tlist_add(&xd->xindex, &c->xattr_unchecked);\n\t\t\t\txdatum_unchecked_count++;\n\t\t\t}\n\t\t}\n\t}\n\t \n\tJFFS2_NOTICE(\"complete building xattr subsystem, %u of xdatum\"\n\t\t     \" (%u unchecked, %u orphan) and \"\n\t\t     \"%u of xref (%u dead, %u orphan) found.\\n\",\n\t\t     xdatum_count, xdatum_unchecked_count, xdatum_orphan_count,\n\t\t     xref_count, xref_dead_count, xref_orphan_count);\n\tkfree(xref_tmphash);\n\treturn 0;\n}\n\nstruct jffs2_xattr_datum *jffs2_setup_xattr_datum(struct jffs2_sb_info *c,\n\t\t\t\t\t\t  uint32_t xid, uint32_t version)\n{\n\tstruct jffs2_xattr_datum *xd;\n\n\txd = jffs2_find_xattr_datum(c, xid);\n\tif (!xd) {\n\t\txd = jffs2_alloc_xattr_datum();\n\t\tif (!xd)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\txd->xid = xid;\n\t\txd->version = version;\n\t\tif (xd->xid > c->highest_xid)\n\t\t\tc->highest_xid = xd->xid;\n\t\tlist_add_tail(&xd->xindex, &c->xattrindex[xid % XATTRINDEX_HASHSIZE]);\n\t}\n\treturn xd;\n}\n\n \nconst struct xattr_handler *jffs2_xattr_handlers[] = {\n\t&jffs2_user_xattr_handler,\n#ifdef CONFIG_JFFS2_FS_SECURITY\n\t&jffs2_security_xattr_handler,\n#endif\n\t&jffs2_trusted_xattr_handler,\n\tNULL\n};\n\nstatic const char *jffs2_xattr_prefix(int xprefix, struct dentry *dentry)\n{\n\tconst struct xattr_handler *ret = NULL;\n\n\tswitch (xprefix) {\n\tcase JFFS2_XPREFIX_USER:\n\t\tret = &jffs2_user_xattr_handler;\n\t\tbreak;\n#ifdef CONFIG_JFFS2_FS_SECURITY\n\tcase JFFS2_XPREFIX_SECURITY:\n\t\tret = &jffs2_security_xattr_handler;\n\t\tbreak;\n#endif\n#ifdef CONFIG_JFFS2_FS_POSIX_ACL\n\tcase JFFS2_XPREFIX_ACL_ACCESS:\n\t\tret = &nop_posix_acl_access;\n\t\tbreak;\n\tcase JFFS2_XPREFIX_ACL_DEFAULT:\n\t\tret = &nop_posix_acl_default;\n\t\tbreak;\n#endif\n\tcase JFFS2_XPREFIX_TRUSTED:\n\t\tret = &jffs2_trusted_xattr_handler;\n\t\tbreak;\n\tdefault:\n\t\treturn NULL;\n\t}\n\n\tif (!xattr_handler_can_list(ret, dentry))\n\t\treturn NULL;\n\n\treturn xattr_prefix(ret);\n}\n\nssize_t jffs2_listxattr(struct dentry *dentry, char *buffer, size_t size)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);\n\tstruct jffs2_sb_info *c = JFFS2_SB_INFO(inode->i_sb);\n\tstruct jffs2_inode_cache *ic = f->inocache;\n\tstruct jffs2_xattr_ref *ref, **pref;\n\tstruct jffs2_xattr_datum *xd;\n\tconst char *prefix;\n\tssize_t prefix_len, len, rc;\n\tint retry = 0;\n\n\trc = check_xattr_ref_inode(c, ic);\n\tif (unlikely(rc))\n\t\treturn rc;\n\n\tdown_read(&c->xattr_sem);\n retry:\n\tlen = 0;\n\tfor (ref=ic->xref, pref=&ic->xref; ref; pref=&ref->next, ref=ref->next) {\n\t\tBUG_ON(ref->ic != ic);\n\t\txd = ref->xd;\n\t\tif (!xd->xname) {\n\t\t\t \n\t\t\tif (!retry) {\n\t\t\t\tretry = 1;\n\t\t\t\tup_read(&c->xattr_sem);\n\t\t\t\tdown_write(&c->xattr_sem);\n\t\t\t\tgoto retry;\n\t\t\t} else {\n\t\t\t\trc = load_xattr_datum(c, xd);\n\t\t\t\tif (unlikely(rc > 0)) {\n\t\t\t\t\t*pref = ref->next;\n\t\t\t\t\tdelete_xattr_ref(c, ref);\n\t\t\t\t\tgoto retry;\n\t\t\t\t} else if (unlikely(rc < 0))\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tprefix = jffs2_xattr_prefix(xd->xprefix, dentry);\n\t\tif (!prefix)\n\t\t\tcontinue;\n\t\tprefix_len = strlen(prefix);\n\t\trc = prefix_len + xd->name_len + 1;\n\n\t\tif (buffer) {\n\t\t\tif (rc > size - len) {\n\t\t\t\trc = -ERANGE;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(buffer, prefix, prefix_len);\n\t\t\tbuffer += prefix_len;\n\t\t\tmemcpy(buffer, xd->xname, xd->name_len);\n\t\t\tbuffer += xd->name_len;\n\t\t\t*buffer++ = 0;\n\t\t}\n\t\tlen += rc;\n\t}\n\trc = len;\n out:\n\tif (!retry) {\n\t\tup_read(&c->xattr_sem);\n\t} else {\n\t\tup_write(&c->xattr_sem);\n\t}\n\treturn rc;\n}\n\nint do_jffs2_getxattr(struct inode *inode, int xprefix, const char *xname,\n\t\t      char *buffer, size_t size)\n{\n\tstruct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);\n\tstruct jffs2_sb_info *c = JFFS2_SB_INFO(inode->i_sb);\n\tstruct jffs2_inode_cache *ic = f->inocache;\n\tstruct jffs2_xattr_datum *xd;\n\tstruct jffs2_xattr_ref *ref, **pref;\n\tint rc, retry = 0;\n\n\trc = check_xattr_ref_inode(c, ic);\n\tif (unlikely(rc))\n\t\treturn rc;\n\n\tdown_read(&c->xattr_sem);\n retry:\n\tfor (ref=ic->xref, pref=&ic->xref; ref; pref=&ref->next, ref=ref->next) {\n\t\tBUG_ON(ref->ic!=ic);\n\n\t\txd = ref->xd;\n\t\tif (xd->xprefix != xprefix)\n\t\t\tcontinue;\n\t\tif (!xd->xname) {\n\t\t\t \n\t\t\tif (!retry) {\n\t\t\t\tretry = 1;\n\t\t\t\tup_read(&c->xattr_sem);\n\t\t\t\tdown_write(&c->xattr_sem);\n\t\t\t\tgoto retry;\n\t\t\t} else {\n\t\t\t\trc = load_xattr_datum(c, xd);\n\t\t\t\tif (unlikely(rc > 0)) {\n\t\t\t\t\t*pref = ref->next;\n\t\t\t\t\tdelete_xattr_ref(c, ref);\n\t\t\t\t\tgoto retry;\n\t\t\t\t} else if (unlikely(rc < 0)) {\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!strcmp(xname, xd->xname)) {\n\t\t\trc = xd->value_len;\n\t\t\tif (buffer) {\n\t\t\t\tif (size < rc) {\n\t\t\t\t\trc = -ERANGE;\n\t\t\t\t} else {\n\t\t\t\t\tmemcpy(buffer, xd->xvalue, rc);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\t}\n\trc = -ENODATA;\n out:\n\tif (!retry) {\n\t\tup_read(&c->xattr_sem);\n\t} else {\n\t\tup_write(&c->xattr_sem);\n\t}\n\treturn rc;\n}\n\nint do_jffs2_setxattr(struct inode *inode, int xprefix, const char *xname,\n\t\t      const char *buffer, size_t size, int flags)\n{\n\tstruct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);\n\tstruct jffs2_sb_info *c = JFFS2_SB_INFO(inode->i_sb);\n\tstruct jffs2_inode_cache *ic = f->inocache;\n\tstruct jffs2_xattr_datum *xd;\n\tstruct jffs2_xattr_ref *ref, *newref, **pref;\n\tuint32_t length, request;\n\tint rc;\n\n\trc = check_xattr_ref_inode(c, ic);\n\tif (unlikely(rc))\n\t\treturn rc;\n\n\trequest = PAD(sizeof(struct jffs2_raw_xattr) + strlen(xname) + 1 + size);\n\trc = jffs2_reserve_space(c, request, &length,\n\t\t\t\t ALLOC_NORMAL, JFFS2_SUMMARY_XATTR_SIZE);\n\tif (rc) {\n\t\tJFFS2_WARNING(\"jffs2_reserve_space()=%d, request=%u\\n\", rc, request);\n\t\treturn rc;\n\t}\n\n\t \n\tdown_write(&c->xattr_sem);\n retry:\n\tfor (ref=ic->xref, pref=&ic->xref; ref; pref=&ref->next, ref=ref->next) {\n\t\txd = ref->xd;\n\t\tif (xd->xprefix != xprefix)\n\t\t\tcontinue;\n\t\tif (!xd->xname) {\n\t\t\trc = load_xattr_datum(c, xd);\n\t\t\tif (unlikely(rc > 0)) {\n\t\t\t\t*pref = ref->next;\n\t\t\t\tdelete_xattr_ref(c, ref);\n\t\t\t\tgoto retry;\n\t\t\t} else if (unlikely(rc < 0))\n\t\t\t\tgoto out;\n\t\t}\n\t\tif (!strcmp(xd->xname, xname)) {\n\t\t\tif (flags & XATTR_CREATE) {\n\t\t\t\trc = -EEXIST;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (!buffer) {\n\t\t\t\tref->ino = ic->ino;\n\t\t\t\tref->xid = xd->xid;\n\t\t\t\tref->xseqno |= XREF_DELETE_MARKER;\n\t\t\t\trc = save_xattr_ref(c, ref);\n\t\t\t\tif (!rc) {\n\t\t\t\t\t*pref = ref->next;\n\t\t\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t\t\t\tref->next = c->xref_dead_list;\n\t\t\t\t\tc->xref_dead_list = ref;\n\t\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t\t\tunrefer_xattr_datum(c, xd);\n\t\t\t\t} else {\n\t\t\t\t\tref->ic = ic;\n\t\t\t\t\tref->xd = xd;\n\t\t\t\t\tref->xseqno &= ~XREF_DELETE_MARKER;\n\t\t\t\t}\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tgoto found;\n\t\t}\n\t}\n\t \n\tif (flags & XATTR_REPLACE) {\n\t\trc = -ENODATA;\n\t\tgoto out;\n\t}\n\tif (!buffer) {\n\t\trc = -ENODATA;\n\t\tgoto out;\n\t}\n found:\n\txd = create_xattr_datum(c, xprefix, xname, buffer, size);\n\tif (IS_ERR(xd)) {\n\t\trc = PTR_ERR(xd);\n\t\tgoto out;\n\t}\n\tup_write(&c->xattr_sem);\n\tjffs2_complete_reservation(c);\n\n\t \n\trequest = PAD(sizeof(struct jffs2_raw_xref));\n\trc = jffs2_reserve_space(c, request, &length,\n\t\t\t\t ALLOC_NORMAL, JFFS2_SUMMARY_XREF_SIZE);\n\tdown_write(&c->xattr_sem);\n\tif (rc) {\n\t\tJFFS2_WARNING(\"jffs2_reserve_space()=%d, request=%u\\n\", rc, request);\n\t\tunrefer_xattr_datum(c, xd);\n\t\tup_write(&c->xattr_sem);\n\t\treturn rc;\n\t}\n\tif (ref)\n\t\t*pref = ref->next;\n\tnewref = create_xattr_ref(c, ic, xd);\n\tif (IS_ERR(newref)) {\n\t\tif (ref) {\n\t\t\tref->next = ic->xref;\n\t\t\tic->xref = ref;\n\t\t}\n\t\trc = PTR_ERR(newref);\n\t\tunrefer_xattr_datum(c, xd);\n\t} else if (ref) {\n\t\tdelete_xattr_ref(c, ref);\n\t}\n out:\n\tup_write(&c->xattr_sem);\n\tjffs2_complete_reservation(c);\n\treturn rc;\n}\n\n \nint jffs2_garbage_collect_xattr_datum(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd,\n\t\t\t\t      struct jffs2_raw_node_ref *raw)\n{\n\tuint32_t totlen, length, old_ofs;\n\tint rc = 0;\n\n\tdown_write(&c->xattr_sem);\n\tif (xd->node != raw)\n\t\tgoto out;\n\tif (xd->flags & (JFFS2_XFLAGS_DEAD|JFFS2_XFLAGS_INVALID))\n\t\tgoto out;\n\n\trc = load_xattr_datum(c, xd);\n\tif (unlikely(rc)) {\n\t\trc = (rc > 0) ? 0 : rc;\n\t\tgoto out;\n\t}\n\told_ofs = ref_offset(xd->node);\n\ttotlen = PAD(sizeof(struct jffs2_raw_xattr)\n\t\t\t+ xd->name_len + 1 + xd->value_len);\n\trc = jffs2_reserve_space_gc(c, totlen, &length, JFFS2_SUMMARY_XATTR_SIZE);\n\tif (rc) {\n\t\tJFFS2_WARNING(\"jffs2_reserve_space_gc()=%d, request=%u\\n\", rc, totlen);\n\t\tgoto out;\n\t}\n\trc = save_xattr_datum(c, xd);\n\tif (!rc)\n\t\tdbg_xattr(\"xdatum (xid=%u, version=%u) GC'ed from %#08x to %08x\\n\",\n\t\t\t  xd->xid, xd->version, old_ofs, ref_offset(xd->node));\n out:\n\tif (!rc)\n\t\tjffs2_mark_node_obsolete(c, raw);\n\tup_write(&c->xattr_sem);\n\treturn rc;\n}\n\nint jffs2_garbage_collect_xattr_ref(struct jffs2_sb_info *c, struct jffs2_xattr_ref *ref,\n\t\t\t\t    struct jffs2_raw_node_ref *raw)\n{\n\tuint32_t totlen, length, old_ofs;\n\tint rc = 0;\n\n\tdown_write(&c->xattr_sem);\n\tBUG_ON(!ref->node);\n\n\tif (ref->node != raw)\n\t\tgoto out;\n\tif (is_xattr_ref_dead(ref) && (raw->next_in_ino == (void *)ref))\n\t\tgoto out;\n\n\told_ofs = ref_offset(ref->node);\n\ttotlen = ref_totlen(c, c->gcblock, ref->node);\n\n\trc = jffs2_reserve_space_gc(c, totlen, &length, JFFS2_SUMMARY_XREF_SIZE);\n\tif (rc) {\n\t\tJFFS2_WARNING(\"%s: jffs2_reserve_space_gc() = %d, request = %u\\n\",\n\t\t\t      __func__, rc, totlen);\n\t\tgoto out;\n\t}\n\trc = save_xattr_ref(c, ref);\n\tif (!rc)\n\t\tdbg_xattr(\"xref (ino=%u, xid=%u) GC'ed from %#08x to %08x\\n\",\n\t\t\t  ref->ic->ino, ref->xd->xid, old_ofs, ref_offset(ref->node));\n out:\n\tif (!rc)\n\t\tjffs2_mark_node_obsolete(c, raw);\n\tup_write(&c->xattr_sem);\n\treturn rc;\n}\n\nint jffs2_verify_xattr(struct jffs2_sb_info *c)\n{\n\tstruct jffs2_xattr_datum *xd, *_xd;\n\tstruct jffs2_eraseblock *jeb;\n\tstruct jffs2_raw_node_ref *raw;\n\tuint32_t totlen;\n\tint rc;\n\n\tdown_write(&c->xattr_sem);\n\tlist_for_each_entry_safe(xd, _xd, &c->xattr_unchecked, xindex) {\n\t\trc = do_verify_xattr_datum(c, xd);\n\t\tif (rc < 0)\n\t\t\tcontinue;\n\t\tlist_del_init(&xd->xindex);\n\t\tspin_lock(&c->erase_completion_lock);\n\t\tfor (raw=xd->node; raw != (void *)xd; raw=raw->next_in_ino) {\n\t\t\tif (ref_flags(raw) != REF_UNCHECKED)\n\t\t\t\tcontinue;\n\t\t\tjeb = &c->blocks[ref_offset(raw) / c->sector_size];\n\t\t\ttotlen = PAD(ref_totlen(c, jeb, raw));\n\t\t\tc->unchecked_size -= totlen; c->used_size += totlen;\n\t\t\tjeb->unchecked_size -= totlen; jeb->used_size += totlen;\n\t\t\traw->flash_offset = ref_offset(raw)\n\t\t\t\t| ((xd->node == (void *)raw) ? REF_PRISTINE : REF_NORMAL);\n\t\t}\n\t\tif (xd->flags & JFFS2_XFLAGS_DEAD)\n\t\t\tlist_add(&xd->xindex, &c->xattr_dead_list);\n\t\tspin_unlock(&c->erase_completion_lock);\n\t}\n\tup_write(&c->xattr_sem);\n\treturn list_empty(&c->xattr_unchecked) ? 1 : 0;\n}\n\nvoid jffs2_release_xattr_datum(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd)\n{\n\t \n\tif (atomic_read(&xd->refcnt) || xd->node != (void *)xd)\n\t\treturn;\n\n\tlist_del(&xd->xindex);\n\tjffs2_free_xattr_datum(xd);\n}\n\nvoid jffs2_release_xattr_ref(struct jffs2_sb_info *c, struct jffs2_xattr_ref *ref)\n{\n\t \n\tstruct jffs2_xattr_ref *tmp, **ptmp;\n\n\tif (ref->node != (void *)ref)\n\t\treturn;\n\n\tfor (tmp=c->xref_dead_list, ptmp=&c->xref_dead_list; tmp; ptmp=&tmp->next, tmp=tmp->next) {\n\t\tif (ref == tmp) {\n\t\t\t*ptmp = tmp->next;\n\t\t\tbreak;\n\t\t}\n\t}\n\tjffs2_free_xattr_ref(ref);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}