{
  "module_name": "readinode.c",
  "hash_id": "dc05ba40d0c50bb78144d10f2d3a5b12feece5fe27726a7f87c21a8c0ac2461f",
  "original_prompt": "Ingested from linux-6.6.14/fs/jffs2/readinode.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/pagemap.h>\n#include <linux/mtd/mtd.h>\n#include <linux/compiler.h>\n#include \"nodelist.h\"\n\n \nstatic int check_node_data(struct jffs2_sb_info *c, struct jffs2_tmp_dnode_info *tn)\n{\n\tstruct jffs2_raw_node_ref *ref = tn->fn->raw;\n\tint err = 0, pointed = 0;\n\tstruct jffs2_eraseblock *jeb;\n\tunsigned char *buffer;\n\tuint32_t crc, ofs, len;\n\tsize_t retlen;\n\n\tBUG_ON(tn->csize == 0);\n\n\t \n\tofs = ref_offset(ref) + sizeof(struct jffs2_raw_inode);\n\tlen = tn->csize;\n\n\tif (jffs2_is_writebuffered(c)) {\n\t\tint adj = ofs % c->wbuf_pagesize;\n\t\tif (likely(adj))\n\t\t\tadj = c->wbuf_pagesize - adj;\n\n\t\tif (adj >= tn->csize) {\n\t\t\tdbg_readinode(\"no need to check node at %#08x, data length %u, data starts at %#08x - it has already been checked.\\n\",\n\t\t\t\t      ref_offset(ref), tn->csize, ofs);\n\t\t\tgoto adj_acc;\n\t\t}\n\n\t\tofs += adj;\n\t\tlen -= adj;\n\t}\n\n\tdbg_readinode(\"check node at %#08x, data length %u, partial CRC %#08x, correct CRC %#08x, data starts at %#08x, start checking from %#08x - %u bytes.\\n\",\n\t\tref_offset(ref), tn->csize, tn->partial_crc, tn->data_crc, ofs - len, ofs, len);\n\n#ifndef __ECOS\n\t \n\terr = mtd_point(c->mtd, ofs, len, &retlen, (void **)&buffer, NULL);\n\tif (!err && retlen < len) {\n\t\tJFFS2_WARNING(\"MTD point returned len too short: %zu instead of %u.\\n\", retlen, tn->csize);\n\t\tmtd_unpoint(c->mtd, ofs, retlen);\n\t} else if (err) {\n\t\tif (err != -EOPNOTSUPP)\n\t\t\tJFFS2_WARNING(\"MTD point failed: error code %d.\\n\", err);\n\t} else\n\t\tpointed = 1;  \n#endif\n\n\tif (!pointed) {\n\t\tbuffer = kmalloc(len, GFP_KERNEL);\n\t\tif (unlikely(!buffer))\n\t\t\treturn -ENOMEM;\n\n\t\t \n\t\terr = jffs2_flash_read(c, ofs, len, &retlen, buffer);\n\t\tif (err) {\n\t\t\tJFFS2_ERROR(\"can not read %d bytes from 0x%08x, error code: %d.\\n\", len, ofs, err);\n\t\t\tgoto free_out;\n\t\t}\n\n\t\tif (retlen != len) {\n\t\t\tJFFS2_ERROR(\"short read at %#08x: %zd instead of %d.\\n\", ofs, retlen, len);\n\t\t\terr = -EIO;\n\t\t\tgoto free_out;\n\t\t}\n\t}\n\n\t \n\tcrc = crc32(tn->partial_crc, buffer, len);\n\tif(!pointed)\n\t\tkfree(buffer);\n#ifndef __ECOS\n\telse\n\t\tmtd_unpoint(c->mtd, ofs, len);\n#endif\n\n\tif (crc != tn->data_crc) {\n\t\tJFFS2_NOTICE(\"wrong data CRC in data node at 0x%08x: read %#08x, calculated %#08x.\\n\",\n\t\t\t     ref_offset(ref), tn->data_crc, crc);\n\t\treturn 1;\n\t}\n\nadj_acc:\n\tjeb = &c->blocks[ref->flash_offset / c->sector_size];\n\tlen = ref_totlen(c, jeb, ref);\n\t \n\tref->flash_offset |= REF_PRISTINE;\n\t \n\tspin_lock(&c->erase_completion_lock);\n\tjeb->used_size += len;\n\tjeb->unchecked_size -= len;\n\tc->used_size += len;\n\tc->unchecked_size -= len;\n\tjffs2_dbg_acct_paranoia_check_nolock(c, jeb);\n\tspin_unlock(&c->erase_completion_lock);\n\n\treturn 0;\n\nfree_out:\n\tif(!pointed)\n\t\tkfree(buffer);\n#ifndef __ECOS\n\telse\n\t\tmtd_unpoint(c->mtd, ofs, len);\n#endif\n\treturn err;\n}\n\n \nstatic int check_tn_node(struct jffs2_sb_info *c, struct jffs2_tmp_dnode_info *tn)\n{\n\tint ret;\n\n\tBUG_ON(ref_obsolete(tn->fn->raw));\n\n\t \n\tif (ref_flags(tn->fn->raw) != REF_UNCHECKED)\n\t\treturn 0;\n\n\tdbg_readinode(\"check node %#04x-%#04x, phys offs %#08x\\n\",\n\t\t      tn->fn->ofs, tn->fn->ofs + tn->fn->size, ref_offset(tn->fn->raw));\n\n\tret = check_node_data(c, tn);\n\tif (unlikely(ret < 0)) {\n\t\tJFFS2_ERROR(\"check_node_data() returned error: %d.\\n\",\n\t\t\tret);\n\t} else if (unlikely(ret > 0)) {\n\t\tdbg_readinode(\"CRC error, mark it obsolete.\\n\");\n\t\tjffs2_mark_node_obsolete(c, tn->fn->raw);\n\t}\n\n\treturn ret;\n}\n\nstatic struct jffs2_tmp_dnode_info *jffs2_lookup_tn(struct rb_root *tn_root, uint32_t offset)\n{\n\tstruct rb_node *next;\n\tstruct jffs2_tmp_dnode_info *tn = NULL;\n\n\tdbg_readinode(\"root %p, offset %d\\n\", tn_root, offset);\n\n\tnext = tn_root->rb_node;\n\n\twhile (next) {\n\t\ttn = rb_entry(next, struct jffs2_tmp_dnode_info, rb);\n\n\t\tif (tn->fn->ofs < offset)\n\t\t\tnext = tn->rb.rb_right;\n\t\telse if (tn->fn->ofs >= offset)\n\t\t\tnext = tn->rb.rb_left;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\treturn tn;\n}\n\n\nstatic void jffs2_kill_tn(struct jffs2_sb_info *c, struct jffs2_tmp_dnode_info *tn)\n{\n\tjffs2_mark_node_obsolete(c, tn->fn->raw);\n\tjffs2_free_full_dnode(tn->fn);\n\tjffs2_free_tmp_dnode_info(tn);\n}\n \nstatic int jffs2_add_tn_to_tree(struct jffs2_sb_info *c,\n\t\t\t\tstruct jffs2_readinode_info *rii,\n\t\t\t\tstruct jffs2_tmp_dnode_info *tn)\n{\n\tuint32_t fn_end = tn->fn->ofs + tn->fn->size;\n\tstruct jffs2_tmp_dnode_info *this, *ptn;\n\n\tdbg_readinode(\"insert fragment %#04x-%#04x, ver %u at %08x\\n\", tn->fn->ofs, fn_end, tn->version, ref_offset(tn->fn->raw));\n\n\t \n\tif (!tn->fn->size) {\n\t\tif (rii->mdata_tn) {\n\t\t\tif (rii->mdata_tn->version < tn->version) {\n\t\t\t\t \n\t\t\t\tdbg_readinode(\"kill old mdata with ver %d\\n\", rii->mdata_tn->version);\n\t\t\t\tjffs2_kill_tn(c, rii->mdata_tn);\n\t\t\t} else {\n\t\t\t\tdbg_readinode(\"kill new mdata with ver %d (older than existing %d\\n\",\n\t\t\t\t\t      tn->version, rii->mdata_tn->version);\n\t\t\t\tjffs2_kill_tn(c, tn);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\trii->mdata_tn = tn;\n\t\tdbg_readinode(\"keep new mdata with ver %d\\n\", tn->version);\n\t\treturn 0;\n\t}\n\n\t \n\tthis = jffs2_lookup_tn(&rii->tn_root, tn->fn->ofs);\n\tif (this) {\n\t\t \n\t\twhile (this->overlapped) {\n\t\t\tptn = tn_prev(this);\n\t\t\tif (!ptn) {\n\t\t\t\t \n\t\t\t\tthis->overlapped = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthis = ptn;\n\t\t}\n\t\tdbg_readinode(\"'this' found %#04x-%#04x (%s)\\n\", this->fn->ofs, this->fn->ofs + this->fn->size, this->fn ? \"data\" : \"hole\");\n\t}\n\n\twhile (this) {\n\t\tif (this->fn->ofs > fn_end)\n\t\t\tbreak;\n\t\tdbg_readinode(\"Ponder this ver %d, 0x%x-0x%x\\n\",\n\t\t\t      this->version, this->fn->ofs, this->fn->size);\n\n\t\tif (this->version == tn->version) {\n\t\t\t \n\t\t\tif (!check_tn_node(c, this)) {\n\t\t\t\t \n\t\t\t\tdbg_readinode(\"Like old node. Throw away new\\n\");\n\t\t\t\tjffs2_kill_tn(c, tn);\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tdbg_readinode(\"Like new node. Throw away old\\n\");\n\t\t\t\trb_replace_node(&this->rb, &tn->rb, &rii->tn_root);\n\t\t\t\tjffs2_kill_tn(c, this);\n\t\t\t\t \n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tif (this->version < tn->version &&\n\t\t    this->fn->ofs >= tn->fn->ofs &&\n\t\t    this->fn->ofs + this->fn->size <= fn_end) {\n\t\t\t \n\t\t\tif (check_tn_node(c, tn)) {\n\t\t\t\tdbg_readinode(\"new node bad CRC\\n\");\n\t\t\t\tjffs2_kill_tn(c, tn);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t \n\t\t\twhile (this && this->fn->ofs + this->fn->size <= fn_end) {\n\t\t\t\tstruct jffs2_tmp_dnode_info *next = tn_next(this);\n\t\t\t\tif (this->version < tn->version) {\n\t\t\t\t\ttn_erase(this, &rii->tn_root);\n\t\t\t\t\tdbg_readinode(\"Kill overlapped ver %d, 0x%x-0x%x\\n\",\n\t\t\t\t\t\t      this->version, this->fn->ofs,\n\t\t\t\t\t\t      this->fn->ofs+this->fn->size);\n\t\t\t\t\tjffs2_kill_tn(c, this);\n\t\t\t\t}\n\t\t\t\tthis = next;\n\t\t\t}\n\t\t\tdbg_readinode(\"Done killing overlapped nodes\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (this->version > tn->version &&\n\t\t    this->fn->ofs <= tn->fn->ofs &&\n\t\t    this->fn->ofs+this->fn->size >= fn_end) {\n\t\t\t \n\t\t\tif (!check_tn_node(c, this)) {\n\t\t\t\tdbg_readinode(\"Good CRC on old node. Kill new\\n\");\n\t\t\t\tjffs2_kill_tn(c, tn);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t \n\t\t\tdbg_readinode(\"Bad CRC on old overlapping node. Kill it\\n\");\n\t\t\ttn_erase(this, &rii->tn_root);\n\t\t\tjffs2_kill_tn(c, this);\n\t\t\tbreak;\n\t\t}\n\n\t\tthis = tn_next(this);\n\t}\n\n\t \n\t{\n\t\tstruct rb_node *parent;\n\t\tstruct rb_node **link = &rii->tn_root.rb_node;\n\t\tstruct jffs2_tmp_dnode_info *insert_point = NULL;\n\n\t\twhile (*link) {\n\t\t\tparent = *link;\n\t\t\tinsert_point = rb_entry(parent, struct jffs2_tmp_dnode_info, rb);\n\t\t\tif (tn->fn->ofs > insert_point->fn->ofs)\n\t\t\t\tlink = &insert_point->rb.rb_right;\n\t\t\telse if (tn->fn->ofs < insert_point->fn->ofs ||\n\t\t\t\t tn->fn->size < insert_point->fn->size)\n\t\t\t\tlink = &insert_point->rb.rb_left;\n\t\t\telse\n\t\t\t\tlink = &insert_point->rb.rb_right;\n\t\t}\n\t\trb_link_node(&tn->rb, &insert_point->rb, link);\n\t\trb_insert_color(&tn->rb, &rii->tn_root);\n\t}\n\n\t \n\tthis = tn_prev(tn);\n\tif (this) {\n\t\twhile (1) {\n\t\t\tif (this->fn->ofs + this->fn->size > tn->fn->ofs) {\n\t\t\t\tdbg_readinode(\"Node is overlapped by %p (v %d, 0x%x-0x%x)\\n\",\n\t\t\t\t\t      this, this->version, this->fn->ofs,\n\t\t\t\t\t      this->fn->ofs+this->fn->size);\n\t\t\t\ttn->overlapped = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!this->overlapped)\n\t\t\t\tbreak;\n\n\t\t\tptn = tn_prev(this);\n\t\t\tif (!ptn) {\n\t\t\t\t \n\t\t\t\tthis->overlapped = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthis = ptn;\n\t\t}\n\t}\n\n\t \n\tthis = tn_next(tn);\n\twhile (this && this->fn->ofs < fn_end) {\n\t\tthis->overlapped = 1;\n\t\tdbg_readinode(\"Node ver %d, 0x%x-0x%x is overlapped\\n\",\n\t\t\t      this->version, this->fn->ofs,\n\t\t\t      this->fn->ofs+this->fn->size);\n\t\tthis = tn_next(this);\n\t}\n\treturn 0;\n}\n\n \nstatic void eat_last(struct rb_root *root, struct rb_node *node)\n{\n\tstruct rb_node *parent = rb_parent(node);\n\tstruct rb_node **link;\n\n\t \n\tBUG_ON(node->rb_right);\n\n\tif (!parent)\n\t\tlink = &root->rb_node;\n\telse if (node == parent->rb_left)\n\t\tlink = &parent->rb_left;\n\telse\n\t\tlink = &parent->rb_right;\n\n\t*link = node->rb_left;\n\tif (node->rb_left)\n\t\tnode->rb_left->__rb_parent_color = node->__rb_parent_color;\n}\n\n \nstatic void ver_insert(struct rb_root *ver_root, struct jffs2_tmp_dnode_info *tn)\n{\n\tstruct rb_node **link = &ver_root->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct jffs2_tmp_dnode_info *this_tn;\n\n\twhile (*link) {\n\t\tparent = *link;\n\t\tthis_tn = rb_entry(parent, struct jffs2_tmp_dnode_info, rb);\n\n\t\tif (tn->version > this_tn->version)\n\t\t\tlink = &parent->rb_left;\n\t\telse\n\t\t\tlink = &parent->rb_right;\n\t}\n\tdbg_readinode(\"Link new node at %p (root is %p)\\n\", link, ver_root);\n\trb_link_node(&tn->rb, parent, link);\n\trb_insert_color(&tn->rb, ver_root);\n}\n\n \nstatic int jffs2_build_inode_fragtree(struct jffs2_sb_info *c,\n\t\t\t\t      struct jffs2_inode_info *f,\n\t\t\t\t      struct jffs2_readinode_info *rii)\n{\n\tstruct jffs2_tmp_dnode_info *pen, *last, *this;\n\tstruct rb_root ver_root = RB_ROOT;\n\tuint32_t high_ver = 0;\n\n\tif (rii->mdata_tn) {\n\t\tdbg_readinode(\"potential mdata is ver %d at %p\\n\", rii->mdata_tn->version, rii->mdata_tn);\n\t\thigh_ver = rii->mdata_tn->version;\n\t\trii->latest_ref = rii->mdata_tn->fn->raw;\n\t}\n#ifdef JFFS2_DBG_READINODE_MESSAGES\n\tthis = tn_last(&rii->tn_root);\n\twhile (this) {\n\t\tdbg_readinode(\"tn %p ver %d range 0x%x-0x%x ov %d\\n\", this, this->version, this->fn->ofs,\n\t\t\t      this->fn->ofs+this->fn->size, this->overlapped);\n\t\tthis = tn_prev(this);\n\t}\n#endif\n\tpen = tn_last(&rii->tn_root);\n\twhile ((last = pen)) {\n\t\tpen = tn_prev(last);\n\n\t\teat_last(&rii->tn_root, &last->rb);\n\t\tver_insert(&ver_root, last);\n\n\t\tif (unlikely(last->overlapped)) {\n\t\t\tif (pen)\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tlast->overlapped = 0;\n\t\t}\n\n\t\t \n\t\tthis = tn_last(&ver_root);\n\n\t\twhile (this) {\n\t\t\tstruct jffs2_tmp_dnode_info *vers_next;\n\t\t\tint ret;\n\t\t\tvers_next = tn_prev(this);\n\t\t\teat_last(&ver_root, &this->rb);\n\t\t\tif (check_tn_node(c, this)) {\n\t\t\t\tdbg_readinode(\"node ver %d, 0x%x-0x%x failed CRC\\n\",\n\t\t\t\t\t     this->version, this->fn->ofs,\n\t\t\t\t\t     this->fn->ofs+this->fn->size);\n\t\t\t\tjffs2_kill_tn(c, this);\n\t\t\t} else {\n\t\t\t\tif (this->version > high_ver) {\n\t\t\t\t\t \n\t\t\t\t\thigh_ver = this->version;\n\t\t\t\t\trii->latest_ref = this->fn->raw;\n\t\t\t\t}\n\t\t\t\tdbg_readinode(\"Add %p (v %d, 0x%x-0x%x, ov %d) to fragtree\\n\",\n\t\t\t\t\t     this, this->version, this->fn->ofs,\n\t\t\t\t\t     this->fn->ofs+this->fn->size, this->overlapped);\n\n\t\t\t\tret = jffs2_add_full_dnode_to_inode(c, f, this->fn);\n\t\t\t\tif (ret) {\n\t\t\t\t\t \n\t\t\t\t\tJFFS2_ERROR(\"Add node to tree failed %d\\n\", ret);\n\t\t\t\t\twhile (1) {\n\t\t\t\t\t\tvers_next = tn_prev(this);\n\t\t\t\t\t\tif (check_tn_node(c, this))\n\t\t\t\t\t\t\tjffs2_mark_node_obsolete(c, this->fn->raw);\n\t\t\t\t\t\tjffs2_free_full_dnode(this->fn);\n\t\t\t\t\t\tjffs2_free_tmp_dnode_info(this);\n\t\t\t\t\t\tthis = vers_next;\n\t\t\t\t\t\tif (!this)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\teat_last(&ver_root, &vers_next->rb);\n\t\t\t\t\t}\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\tjffs2_free_tmp_dnode_info(this);\n\t\t\t}\n\t\t\tthis = vers_next;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void jffs2_free_tmp_dnode_info_list(struct rb_root *list)\n{\n\tstruct jffs2_tmp_dnode_info *tn, *next;\n\n\trbtree_postorder_for_each_entry_safe(tn, next, list, rb) {\n\t\t\tjffs2_free_full_dnode(tn->fn);\n\t\t\tjffs2_free_tmp_dnode_info(tn);\n\t}\n\n\t*list = RB_ROOT;\n}\n\nstatic void jffs2_free_full_dirent_list(struct jffs2_full_dirent *fd)\n{\n\tstruct jffs2_full_dirent *next;\n\n\twhile (fd) {\n\t\tnext = fd->next;\n\t\tjffs2_free_full_dirent(fd);\n\t\tfd = next;\n\t}\n}\n\n \nstatic struct jffs2_raw_node_ref *jffs2_first_valid_node(struct jffs2_raw_node_ref *ref)\n{\n\twhile (ref && ref->next_in_ino) {\n\t\tif (!ref_obsolete(ref))\n\t\t\treturn ref;\n\t\tdbg_noderef(\"node at 0x%08x is obsoleted. Ignoring.\\n\", ref_offset(ref));\n\t\tref = ref->next_in_ino;\n\t}\n\treturn NULL;\n}\n\n \nstatic inline int read_direntry(struct jffs2_sb_info *c, struct jffs2_raw_node_ref *ref,\n\t\t\t\tstruct jffs2_raw_dirent *rd, size_t read,\n\t\t\t\tstruct jffs2_readinode_info *rii)\n{\n\tstruct jffs2_full_dirent *fd;\n\tuint32_t crc;\n\n\t \n\tBUG_ON(ref_obsolete(ref));\n\n\tcrc = crc32(0, rd, sizeof(*rd) - 8);\n\tif (unlikely(crc != je32_to_cpu(rd->node_crc))) {\n\t\tJFFS2_NOTICE(\"header CRC failed on dirent node at %#08x: read %#08x, calculated %#08x\\n\",\n\t\t\t     ref_offset(ref), je32_to_cpu(rd->node_crc), crc);\n\t\tjffs2_mark_node_obsolete(c, ref);\n\t\treturn 0;\n\t}\n\n\t \n\tif (ref_flags(ref) == REF_UNCHECKED) {\n\t\tstruct jffs2_eraseblock *jeb;\n\t\tint len;\n\n\t\t \n\t\tif (unlikely(PAD((rd->nsize + sizeof(*rd))) != PAD(je32_to_cpu(rd->totlen)))) {\n\t\t\tJFFS2_ERROR(\"illegal nsize in node at %#08x: nsize %#02x, totlen %#04x\\n\",\n\t\t\t\t    ref_offset(ref), rd->nsize, je32_to_cpu(rd->totlen));\n\t\t\tjffs2_mark_node_obsolete(c, ref);\n\t\t\treturn 0;\n\t\t}\n\n\t\tjeb = &c->blocks[ref->flash_offset / c->sector_size];\n\t\tlen = ref_totlen(c, jeb, ref);\n\n\t\tspin_lock(&c->erase_completion_lock);\n\t\tjeb->used_size += len;\n\t\tjeb->unchecked_size -= len;\n\t\tc->used_size += len;\n\t\tc->unchecked_size -= len;\n\t\tref->flash_offset = ref_offset(ref) | dirent_node_state(rd);\n\t\tspin_unlock(&c->erase_completion_lock);\n\t}\n\n\tfd = jffs2_alloc_full_dirent(rd->nsize + 1);\n\tif (unlikely(!fd))\n\t\treturn -ENOMEM;\n\n\tfd->raw = ref;\n\tfd->version = je32_to_cpu(rd->version);\n\tfd->ino = je32_to_cpu(rd->ino);\n\tfd->type = rd->type;\n\n\tif (fd->version > rii->highest_version)\n\t\trii->highest_version = fd->version;\n\n\t \n\tif(fd->version > rii->mctime_ver && je32_to_cpu(rd->mctime)) {\n\t\trii->mctime_ver = fd->version;\n\t\trii->latest_mctime = je32_to_cpu(rd->mctime);\n\t}\n\n\t \n\tif (read > sizeof(*rd))\n\t\tmemcpy(&fd->name[0], &rd->name[0],\n\t\t       min_t(uint32_t, rd->nsize, (read - sizeof(*rd)) ));\n\n\t \n\tif (rd->nsize + sizeof(*rd) > read) {\n\t\t \n\t\tint err;\n\t\tint already = read - sizeof(*rd);\n\n\t\terr = jffs2_flash_read(c, (ref_offset(ref)) + read,\n\t\t\t\trd->nsize - already, &read, &fd->name[already]);\n\t\tif (unlikely(read != rd->nsize - already) && likely(!err)) {\n\t\t\tjffs2_free_full_dirent(fd);\n\t\t\tJFFS2_ERROR(\"short read: wanted %d bytes, got %zd\\n\",\n\t\t\t\t    rd->nsize - already, read);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (unlikely(err)) {\n\t\t\tJFFS2_ERROR(\"read remainder of name: error %d\\n\", err);\n\t\t\tjffs2_free_full_dirent(fd);\n\t\t\treturn -EIO;\n\t\t}\n\n#ifdef CONFIG_JFFS2_SUMMARY\n\t\t \n\t\tcrc = crc32(0, fd->name, rd->nsize);\n\t\tif (unlikely(crc != je32_to_cpu(rd->name_crc))) {\n\t\t\tJFFS2_NOTICE(\"name CRC failed on dirent node at\"\n\t\t\t   \"%#08x: read %#08x,calculated %#08x\\n\",\n\t\t\t   ref_offset(ref), je32_to_cpu(rd->node_crc), crc);\n\t\t\tjffs2_mark_node_obsolete(c, ref);\n\t\t\tjffs2_free_full_dirent(fd);\n\t\t\treturn 0;\n\t\t}\n#endif\n\t}\n\n\tfd->nhash = full_name_hash(NULL, fd->name, rd->nsize);\n\tfd->next = NULL;\n\tfd->name[rd->nsize] = '\\0';\n\n\t \n\tjffs2_add_fd_to_list(c, fd, &rii->fds);\n\n\treturn 0;\n}\n\n \nstatic inline int read_dnode(struct jffs2_sb_info *c, struct jffs2_raw_node_ref *ref,\n\t\t\t     struct jffs2_raw_inode *rd, int rdlen,\n\t\t\t     struct jffs2_readinode_info *rii)\n{\n\tstruct jffs2_tmp_dnode_info *tn;\n\tuint32_t len, csize;\n\tint ret = 0;\n\tuint32_t crc;\n\n\t \n\tBUG_ON(ref_obsolete(ref));\n\n\tcrc = crc32(0, rd, sizeof(*rd) - 8);\n\tif (unlikely(crc != je32_to_cpu(rd->node_crc))) {\n\t\tJFFS2_NOTICE(\"node CRC failed on dnode at %#08x: read %#08x, calculated %#08x\\n\",\n\t\t\t     ref_offset(ref), je32_to_cpu(rd->node_crc), crc);\n\t\tjffs2_mark_node_obsolete(c, ref);\n\t\treturn 0;\n\t}\n\n\ttn = jffs2_alloc_tmp_dnode_info();\n\tif (!tn) {\n\t\tJFFS2_ERROR(\"failed to allocate tn (%zu bytes).\\n\", sizeof(*tn));\n\t\treturn -ENOMEM;\n\t}\n\n\ttn->partial_crc = 0;\n\tcsize = je32_to_cpu(rd->csize);\n\n\t \n\tif (ref_flags(ref) == REF_UNCHECKED) {\n\n\t\t \n\t\tif (unlikely(je32_to_cpu(rd->offset) > je32_to_cpu(rd->isize)) ||\n\t\t    unlikely(PAD(je32_to_cpu(rd->csize) + sizeof(*rd)) != PAD(je32_to_cpu(rd->totlen)))) {\n\t\t\tJFFS2_WARNING(\"inode node header CRC is corrupted at %#08x\\n\", ref_offset(ref));\n\t\t\tjffs2_dbg_dump_node(c, ref_offset(ref));\n\t\t\tjffs2_mark_node_obsolete(c, ref);\n\t\t\tgoto free_out;\n\t\t}\n\n\t\tif (jffs2_is_writebuffered(c) && csize != 0) {\n\t\t\t \n\t\t\tunsigned char *buf;\n\n\t\t\t \n\t\t\tbuf = (unsigned char *)rd + sizeof(*rd);\n\t\t\t \n\t\t\tlen = min_t(uint32_t, rdlen - sizeof(*rd), csize);\n\t\t\ttn->partial_crc = crc32(0, buf, len);\n\n\t\t\tdbg_readinode(\"Calculates CRC (%#08x) for %d bytes, csize %d\\n\", tn->partial_crc, len, csize);\n\n\t\t\t \n\t\t\tif (len >= csize && unlikely(tn->partial_crc != je32_to_cpu(rd->data_crc))) {\n\t\t\t\tJFFS2_NOTICE(\"wrong data CRC in data node at 0x%08x: read %#08x, calculated %#08x.\\n\",\n\t\t\t\t\tref_offset(ref), tn->partial_crc, je32_to_cpu(rd->data_crc));\n\t\t\t\tjffs2_mark_node_obsolete(c, ref);\n\t\t\t\tgoto free_out;\n\t\t\t}\n\n\t\t} else if (csize == 0) {\n\t\t\t \n\t\t\tstruct jffs2_eraseblock *jeb;\n\n\t\t\tdbg_readinode(\"the node has no data.\\n\");\n\t\t\tjeb = &c->blocks[ref->flash_offset / c->sector_size];\n\t\t\tlen = ref_totlen(c, jeb, ref);\n\n\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t\tjeb->used_size += len;\n\t\t\tjeb->unchecked_size -= len;\n\t\t\tc->used_size += len;\n\t\t\tc->unchecked_size -= len;\n\t\t\tref->flash_offset = ref_offset(ref) | REF_NORMAL;\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t}\n\t}\n\n\ttn->fn = jffs2_alloc_full_dnode();\n\tif (!tn->fn) {\n\t\tJFFS2_ERROR(\"alloc fn failed\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto free_out;\n\t}\n\n\ttn->version = je32_to_cpu(rd->version);\n\ttn->fn->ofs = je32_to_cpu(rd->offset);\n\ttn->data_crc = je32_to_cpu(rd->data_crc);\n\ttn->csize = csize;\n\ttn->fn->raw = ref;\n\ttn->overlapped = 0;\n\n\tif (tn->version > rii->highest_version)\n\t\trii->highest_version = tn->version;\n\n\t \n\tif (rd->compr == JFFS2_COMPR_ZERO && !je32_to_cpu(rd->dsize) && csize)\n\t\ttn->fn->size = csize;\n\telse  \n\t\ttn->fn->size = je32_to_cpu(rd->dsize);\n\n\tdbg_readinode2(\"dnode @%08x: ver %u, offset %#04x, dsize %#04x, csize %#04x\\n\",\n\t\t       ref_offset(ref), je32_to_cpu(rd->version),\n\t\t       je32_to_cpu(rd->offset), je32_to_cpu(rd->dsize), csize);\n\n\tret = jffs2_add_tn_to_tree(c, rii, tn);\n\n\tif (ret) {\n\t\tjffs2_free_full_dnode(tn->fn);\n\tfree_out:\n\t\tjffs2_free_tmp_dnode_info(tn);\n\t\treturn ret;\n\t}\n#ifdef JFFS2_DBG_READINODE2_MESSAGES\n\tdbg_readinode2(\"After adding ver %d:\\n\", je32_to_cpu(rd->version));\n\ttn = tn_first(&rii->tn_root);\n\twhile (tn) {\n\t\tdbg_readinode2(\"%p: v %d r 0x%x-0x%x ov %d\\n\",\n\t\t\t       tn, tn->version, tn->fn->ofs,\n\t\t\t       tn->fn->ofs+tn->fn->size, tn->overlapped);\n\t\ttn = tn_next(tn);\n\t}\n#endif\n\treturn 0;\n}\n\n \nstatic inline int read_unknown(struct jffs2_sb_info *c, struct jffs2_raw_node_ref *ref, struct jffs2_unknown_node *un)\n{\n\t \n\tif (ref_flags(ref) == REF_UNCHECKED) {\n\t\tJFFS2_ERROR(\"REF_UNCHECKED but unknown node at %#08x\\n\",\n\t\t\t    ref_offset(ref));\n\t\tJFFS2_ERROR(\"Node is {%04x,%04x,%08x,%08x}. Please report this error.\\n\",\n\t\t\t    je16_to_cpu(un->magic), je16_to_cpu(un->nodetype),\n\t\t\t    je32_to_cpu(un->totlen), je32_to_cpu(un->hdr_crc));\n\t\tjffs2_mark_node_obsolete(c, ref);\n\t\treturn 0;\n\t}\n\n\tun->nodetype = cpu_to_je16(JFFS2_NODE_ACCURATE | je16_to_cpu(un->nodetype));\n\n\tswitch(je16_to_cpu(un->nodetype) & JFFS2_COMPAT_MASK) {\n\n\tcase JFFS2_FEATURE_INCOMPAT:\n\t\tJFFS2_ERROR(\"unknown INCOMPAT nodetype %#04X at %#08x\\n\",\n\t\t\t    je16_to_cpu(un->nodetype), ref_offset(ref));\n\t\t \n\t\tBUG();\n\t\tbreak;\n\n\tcase JFFS2_FEATURE_ROCOMPAT:\n\t\tJFFS2_ERROR(\"unknown ROCOMPAT nodetype %#04X at %#08x\\n\",\n\t\t\t    je16_to_cpu(un->nodetype), ref_offset(ref));\n\t\tBUG_ON(!(c->flags & JFFS2_SB_FLAG_RO));\n\t\tbreak;\n\n\tcase JFFS2_FEATURE_RWCOMPAT_COPY:\n\t\tJFFS2_NOTICE(\"unknown RWCOMPAT_COPY nodetype %#04X at %#08x\\n\",\n\t\t\t     je16_to_cpu(un->nodetype), ref_offset(ref));\n\t\tbreak;\n\n\tcase JFFS2_FEATURE_RWCOMPAT_DELETE:\n\t\tJFFS2_NOTICE(\"unknown RWCOMPAT_DELETE nodetype %#04X at %#08x\\n\",\n\t\t\t     je16_to_cpu(un->nodetype), ref_offset(ref));\n\t\tjffs2_mark_node_obsolete(c, ref);\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int read_more(struct jffs2_sb_info *c, struct jffs2_raw_node_ref *ref,\n\t\t     int needed_len, int *rdlen, unsigned char *buf)\n{\n\tint err, to_read = needed_len - *rdlen;\n\tsize_t retlen;\n\tuint32_t offs;\n\n\tif (jffs2_is_writebuffered(c)) {\n\t\tint rem = to_read % c->wbuf_pagesize;\n\n\t\tif (rem)\n\t\t\tto_read += c->wbuf_pagesize - rem;\n\t}\n\n\t \n\toffs = ref_offset(ref) + *rdlen;\n\n\tdbg_readinode(\"read more %d bytes\\n\", to_read);\n\n\terr = jffs2_flash_read(c, offs, to_read, &retlen, buf + *rdlen);\n\tif (err) {\n\t\tJFFS2_ERROR(\"can not read %d bytes from 0x%08x, \"\n\t\t\t\"error code: %d.\\n\", to_read, offs, err);\n\t\treturn err;\n\t}\n\n\tif (retlen < to_read) {\n\t\tJFFS2_ERROR(\"short read at %#08x: %zu instead of %d.\\n\",\n\t\t\t\toffs, retlen, to_read);\n\t\treturn -EIO;\n\t}\n\n\t*rdlen += to_read;\n\treturn 0;\n}\n\n \nstatic int jffs2_get_inode_nodes(struct jffs2_sb_info *c, struct jffs2_inode_info *f,\n\t\t\t\t struct jffs2_readinode_info *rii)\n{\n\tstruct jffs2_raw_node_ref *ref, *valid_ref;\n\tunsigned char *buf = NULL;\n\tunion jffs2_node_union *node;\n\tsize_t retlen;\n\tint len, err;\n\n\trii->mctime_ver = 0;\n\n\tdbg_readinode(\"ino #%u\\n\", f->inocache->ino);\n\n\t \n\tlen = sizeof(union jffs2_node_union) + c->wbuf_pagesize;\n\tbuf = kmalloc(len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tspin_lock(&c->erase_completion_lock);\n\tvalid_ref = jffs2_first_valid_node(f->inocache->nodes);\n\tif (!valid_ref && f->inocache->ino != 1)\n\t\tJFFS2_WARNING(\"Eep. No valid nodes for ino #%u.\\n\", f->inocache->ino);\n\twhile (valid_ref) {\n\t\t \n\t\tref = valid_ref;\n\t\tvalid_ref = jffs2_first_valid_node(ref->next_in_ino);\n\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\tcond_resched();\n\n\t\t \n\t\tlen = JFFS2_MIN_NODE_HEADER;\n\t\tif (jffs2_is_writebuffered(c)) {\n\t\t\tint end, rem;\n\n\t\t\t \n\t\t\tend = ref_offset(ref) + len;\n\t\t\trem = end % c->wbuf_pagesize;\n\t\t\tif (rem)\n\t\t\t\tend += c->wbuf_pagesize - rem;\n\t\t\tlen = end - ref_offset(ref);\n\t\t}\n\n\t\tdbg_readinode(\"read %d bytes at %#08x(%d).\\n\", len, ref_offset(ref), ref_flags(ref));\n\n\t\t \n\t\terr = jffs2_flash_read(c, ref_offset(ref), len, &retlen, buf);\n\t\tif (err) {\n\t\t\tJFFS2_ERROR(\"can not read %d bytes from 0x%08x, error code: %d.\\n\", len, ref_offset(ref), err);\n\t\t\tgoto free_out;\n\t\t}\n\n\t\tif (retlen < len) {\n\t\t\tJFFS2_ERROR(\"short read at %#08x: %zu instead of %d.\\n\", ref_offset(ref), retlen, len);\n\t\t\terr = -EIO;\n\t\t\tgoto free_out;\n\t\t}\n\n\t\tnode = (union jffs2_node_union *)buf;\n\n\t\t \n\t\tif (je32_to_cpu(node->u.hdr_crc) != crc32(0, node, sizeof(node->u)-4)) {\n\t\t\tJFFS2_NOTICE(\"Node header CRC failed at %#08x. {%04x,%04x,%08x,%08x}\\n\",\n\t\t\t\t     ref_offset(ref), je16_to_cpu(node->u.magic),\n\t\t\t\t     je16_to_cpu(node->u.nodetype),\n\t\t\t\t     je32_to_cpu(node->u.totlen),\n\t\t\t\t     je32_to_cpu(node->u.hdr_crc));\n\t\t\tjffs2_dbg_dump_node(c, ref_offset(ref));\n\t\t\tjffs2_mark_node_obsolete(c, ref);\n\t\t\tgoto cont;\n\t\t}\n\t\tif (je16_to_cpu(node->u.magic) != JFFS2_MAGIC_BITMASK) {\n\t\t\t \n\t\t\tJFFS2_NOTICE(\"Wrong magic bitmask 0x%04x in node header at %#08x.\\n\",\n\t\t\t\t     je16_to_cpu(node->u.magic), ref_offset(ref));\n\t\t\tjffs2_mark_node_obsolete(c, ref);\n\t\t\tgoto cont;\n\t\t}\n\n\t\tswitch (je16_to_cpu(node->u.nodetype)) {\n\n\t\tcase JFFS2_NODETYPE_DIRENT:\n\n\t\t\tif (JFFS2_MIN_NODE_HEADER < sizeof(struct jffs2_raw_dirent) &&\n\t\t\t    len < sizeof(struct jffs2_raw_dirent)) {\n\t\t\t\terr = read_more(c, ref, sizeof(struct jffs2_raw_dirent), &len, buf);\n\t\t\t\tif (unlikely(err))\n\t\t\t\t\tgoto free_out;\n\t\t\t}\n\n\t\t\terr = read_direntry(c, ref, &node->d, retlen, rii);\n\t\t\tif (unlikely(err))\n\t\t\t\tgoto free_out;\n\n\t\t\tbreak;\n\n\t\tcase JFFS2_NODETYPE_INODE:\n\n\t\t\tif (JFFS2_MIN_NODE_HEADER < sizeof(struct jffs2_raw_inode) &&\n\t\t\t    len < sizeof(struct jffs2_raw_inode)) {\n\t\t\t\terr = read_more(c, ref, sizeof(struct jffs2_raw_inode), &len, buf);\n\t\t\t\tif (unlikely(err))\n\t\t\t\t\tgoto free_out;\n\t\t\t}\n\n\t\t\terr = read_dnode(c, ref, &node->i, len, rii);\n\t\t\tif (unlikely(err))\n\t\t\t\tgoto free_out;\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tif (JFFS2_MIN_NODE_HEADER < sizeof(struct jffs2_unknown_node) &&\n\t\t\t    len < sizeof(struct jffs2_unknown_node)) {\n\t\t\t\terr = read_more(c, ref, sizeof(struct jffs2_unknown_node), &len, buf);\n\t\t\t\tif (unlikely(err))\n\t\t\t\t\tgoto free_out;\n\t\t\t}\n\n\t\t\terr = read_unknown(c, ref, &node->u);\n\t\t\tif (unlikely(err))\n\t\t\t\tgoto free_out;\n\n\t\t}\n\tcont:\n\t\tspin_lock(&c->erase_completion_lock);\n\t}\n\n\tspin_unlock(&c->erase_completion_lock);\n\tkfree(buf);\n\n\tf->highest_version = rii->highest_version;\n\n\tdbg_readinode(\"nodes of inode #%u were read, the highest version is %u, latest_mctime %u, mctime_ver %u.\\n\",\n\t\t      f->inocache->ino, rii->highest_version, rii->latest_mctime,\n\t\t      rii->mctime_ver);\n\treturn 0;\n\n free_out:\n\tjffs2_free_tmp_dnode_info_list(&rii->tn_root);\n\tjffs2_free_full_dirent_list(rii->fds);\n\trii->fds = NULL;\n\tkfree(buf);\n\treturn err;\n}\n\nstatic int jffs2_do_read_inode_internal(struct jffs2_sb_info *c,\n\t\t\t\t\tstruct jffs2_inode_info *f,\n\t\t\t\t\tstruct jffs2_raw_inode *latest_node)\n{\n\tstruct jffs2_readinode_info rii;\n\tuint32_t crc, new_size;\n\tsize_t retlen;\n\tint ret;\n\n\tdbg_readinode(\"ino #%u pino/nlink is %d\\n\", f->inocache->ino,\n\t\t      f->inocache->pino_nlink);\n\n\tmemset(&rii, 0, sizeof(rii));\n\n\t \n\tret = jffs2_get_inode_nodes(c, f, &rii);\n\n\tif (ret) {\n\t\tJFFS2_ERROR(\"cannot read nodes for ino %u, returned error is %d\\n\", f->inocache->ino, ret);\n\t\tif (f->inocache->state == INO_STATE_READING)\n\t\t\tjffs2_set_inocache_state(c, f->inocache, INO_STATE_CHECKEDABSENT);\n\t\treturn ret;\n\t}\n\n\tret = jffs2_build_inode_fragtree(c, f, &rii);\n\tif (ret) {\n\t\tJFFS2_ERROR(\"Failed to build final fragtree for inode #%u: error %d\\n\",\n\t\t\t    f->inocache->ino, ret);\n\t\tif (f->inocache->state == INO_STATE_READING)\n\t\t\tjffs2_set_inocache_state(c, f->inocache, INO_STATE_CHECKEDABSENT);\n\t\tjffs2_free_tmp_dnode_info_list(&rii.tn_root);\n\t\t \n\t\tif (rii.mdata_tn) {\n\t\t\tjffs2_free_full_dnode(rii.mdata_tn->fn);\n\t\t\tjffs2_free_tmp_dnode_info(rii.mdata_tn);\n\t\t\trii.mdata_tn = NULL;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tif (rii.mdata_tn) {\n\t\tif (rii.mdata_tn->fn->raw == rii.latest_ref) {\n\t\t\tf->metadata = rii.mdata_tn->fn;\n\t\t\tjffs2_free_tmp_dnode_info(rii.mdata_tn);\n\t\t} else {\n\t\t\tjffs2_kill_tn(c, rii.mdata_tn);\n\t\t}\n\t\trii.mdata_tn = NULL;\n\t}\n\n\tf->dents = rii.fds;\n\n\tjffs2_dbg_fragtree_paranoia_check_nolock(f);\n\n\tif (unlikely(!rii.latest_ref)) {\n\t\t \n\t\tif (f->inocache->ino != 1) {\n\t\t\tJFFS2_WARNING(\"no data nodes found for ino #%u\\n\", f->inocache->ino);\n\t\t\tif (!rii.fds) {\n\t\t\t\tif (f->inocache->state == INO_STATE_READING)\n\t\t\t\t\tjffs2_set_inocache_state(c, f->inocache, INO_STATE_CHECKEDABSENT);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tJFFS2_NOTICE(\"but it has children so we fake some modes for it\\n\");\n\t\t}\n\t\tlatest_node->mode = cpu_to_jemode(S_IFDIR|S_IRUGO|S_IWUSR|S_IXUGO);\n\t\tlatest_node->version = cpu_to_je32(0);\n\t\tlatest_node->atime = latest_node->ctime = latest_node->mtime = cpu_to_je32(0);\n\t\tlatest_node->isize = cpu_to_je32(0);\n\t\tlatest_node->gid = cpu_to_je16(0);\n\t\tlatest_node->uid = cpu_to_je16(0);\n\t\tif (f->inocache->state == INO_STATE_READING)\n\t\t\tjffs2_set_inocache_state(c, f->inocache, INO_STATE_PRESENT);\n\t\treturn 0;\n\t}\n\n\tret = jffs2_flash_read(c, ref_offset(rii.latest_ref), sizeof(*latest_node), &retlen, (void *)latest_node);\n\tif (ret || retlen != sizeof(*latest_node)) {\n\t\tJFFS2_ERROR(\"failed to read from flash: error %d, %zd of %zd bytes read\\n\",\n\t\t\tret, retlen, sizeof(*latest_node));\n\t\t \n\t\treturn ret ? ret : -EIO;\n\t}\n\n\tcrc = crc32(0, latest_node, sizeof(*latest_node)-8);\n\tif (crc != je32_to_cpu(latest_node->node_crc)) {\n\t\tJFFS2_ERROR(\"CRC failed for read_inode of inode %u at physical location 0x%x\\n\",\n\t\t\tf->inocache->ino, ref_offset(rii.latest_ref));\n\t\treturn -EIO;\n\t}\n\n\tswitch(jemode_to_cpu(latest_node->mode) & S_IFMT) {\n\tcase S_IFDIR:\n\t\tif (rii.mctime_ver > je32_to_cpu(latest_node->version)) {\n\t\t\t \n\t\t\tlatest_node->ctime = latest_node->mtime = cpu_to_je32(rii.latest_mctime);\n\t\t}\n\t\tbreak;\n\n\n\tcase S_IFREG:\n\t\t \n\t\tnew_size = jffs2_truncate_fragtree(c, &f->fragtree, je32_to_cpu(latest_node->isize));\n\t\tif (new_size != je32_to_cpu(latest_node->isize)) {\n\t\t\tJFFS2_WARNING(\"Truncating ino #%u to %d bytes failed because it only had %d bytes to start with!\\n\",\n\t\t\t\t      f->inocache->ino, je32_to_cpu(latest_node->isize), new_size);\n\t\t\tlatest_node->isize = cpu_to_je32(new_size);\n\t\t}\n\t\tbreak;\n\n\tcase S_IFLNK:\n\t\t \n\t\tif (!je32_to_cpu(latest_node->isize))\n\t\t\tlatest_node->isize = latest_node->dsize;\n\n\t\tif (f->inocache->state != INO_STATE_CHECKING) {\n\t\t\t \n\t\t\tuint32_t csize = je32_to_cpu(latest_node->csize);\n\t\t\tif (csize > JFFS2_MAX_NAME_LEN)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t\tf->target = kmalloc(csize + 1, GFP_KERNEL);\n\t\t\tif (!f->target) {\n\t\t\t\tJFFS2_ERROR(\"can't allocate %u bytes of memory for the symlink target path cache\\n\", csize);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\tret = jffs2_flash_read(c, ref_offset(rii.latest_ref) + sizeof(*latest_node),\n\t\t\t\t\t       csize, &retlen, (char *)f->target);\n\n\t\t\tif (ret || retlen != csize) {\n\t\t\t\tif (retlen != csize)\n\t\t\t\t\tret = -EIO;\n\t\t\t\tkfree(f->target);\n\t\t\t\tf->target = NULL;\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tf->target[csize] = '\\0';\n\t\t\tdbg_readinode(\"symlink's target '%s' cached\\n\", f->target);\n\t\t}\n\n\t\tfallthrough;\n\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\t\t \n\t\tif (f->metadata) {\n\t\t\tJFFS2_ERROR(\"Argh. Special inode #%u with mode 0%o had metadata node\\n\",\n\t\t\t       f->inocache->ino, jemode_to_cpu(latest_node->mode));\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (!frag_first(&f->fragtree)) {\n\t\t\tJFFS2_ERROR(\"Argh. Special inode #%u with mode 0%o has no fragments\\n\",\n\t\t\t       f->inocache->ino, jemode_to_cpu(latest_node->mode));\n\t\t\treturn -EIO;\n\t\t}\n\t\t \n\t\tif (frag_next(frag_first(&f->fragtree))) {\n\t\t\tJFFS2_ERROR(\"Argh. Special inode #%u with mode 0x%x had more than one node\\n\",\n\t\t\t       f->inocache->ino, jemode_to_cpu(latest_node->mode));\n\t\t\t \n\t\t\treturn -EIO;\n\t\t}\n\t\t \n\t\tf->metadata = frag_first(&f->fragtree)->node;\n\t\tjffs2_free_node_frag(frag_first(&f->fragtree));\n\t\tf->fragtree = RB_ROOT;\n\t\tbreak;\n\t}\n\tif (f->inocache->state == INO_STATE_READING)\n\t\tjffs2_set_inocache_state(c, f->inocache, INO_STATE_PRESENT);\n\n\treturn 0;\n}\n\n \nint jffs2_do_read_inode(struct jffs2_sb_info *c, struct jffs2_inode_info *f,\n\t\t\tuint32_t ino, struct jffs2_raw_inode *latest_node)\n{\n\tdbg_readinode(\"read inode #%u\\n\", ino);\n\n retry_inocache:\n\tspin_lock(&c->inocache_lock);\n\tf->inocache = jffs2_get_ino_cache(c, ino);\n\n\tif (f->inocache) {\n\t\t \n\t\tswitch(f->inocache->state) {\n\t\tcase INO_STATE_UNCHECKED:\n\t\tcase INO_STATE_CHECKEDABSENT:\n\t\t\tf->inocache->state = INO_STATE_READING;\n\t\t\tbreak;\n\n\t\tcase INO_STATE_CHECKING:\n\t\tcase INO_STATE_GC:\n\t\t\t \n\t\t\tdbg_readinode(\"waiting for ino #%u in state %d\\n\", ino, f->inocache->state);\n\t\t\tsleep_on_spinunlock(&c->inocache_wq, &c->inocache_lock);\n\t\t\tgoto retry_inocache;\n\n\t\tcase INO_STATE_READING:\n\t\tcase INO_STATE_PRESENT:\n\t\t\t \n\t\t\tJFFS2_ERROR(\"Eep. Trying to read_inode #%u when it's already in state %d!\\n\", ino, f->inocache->state);\n\t\t\t \n\t\t\tf->inocache = NULL;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t}\n\tspin_unlock(&c->inocache_lock);\n\n\tif (!f->inocache && ino == 1) {\n\t\t \n\t\tf->inocache = jffs2_alloc_inode_cache();\n\t\tif (!f->inocache) {\n\t\t\tJFFS2_ERROR(\"cannot allocate inocache for root inode\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tdbg_readinode(\"creating inocache for root inode\\n\");\n\t\tmemset(f->inocache, 0, sizeof(struct jffs2_inode_cache));\n\t\tf->inocache->ino = f->inocache->pino_nlink = 1;\n\t\tf->inocache->nodes = (struct jffs2_raw_node_ref *)f->inocache;\n\t\tf->inocache->state = INO_STATE_READING;\n\t\tjffs2_add_ino_cache(c, f->inocache);\n\t}\n\tif (!f->inocache) {\n\t\tJFFS2_ERROR(\"requested to read a nonexistent ino %u\\n\", ino);\n\t\treturn -ENOENT;\n\t}\n\n\treturn jffs2_do_read_inode_internal(c, f, latest_node);\n}\n\nint jffs2_do_crccheck_inode(struct jffs2_sb_info *c, struct jffs2_inode_cache *ic)\n{\n\tstruct jffs2_raw_inode n;\n\tstruct jffs2_inode_info *f = kzalloc(sizeof(*f), GFP_KERNEL);\n\tint ret;\n\n\tif (!f)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&f->sem);\n\tmutex_lock(&f->sem);\n\tf->inocache = ic;\n\n\tret = jffs2_do_read_inode_internal(c, f, &n);\n\tmutex_unlock(&f->sem);\n\tjffs2_do_clear_inode(c, f);\n\tjffs2_xattr_do_crccheck_inode(c, ic);\n\tkfree (f);\n\treturn ret;\n}\n\nvoid jffs2_do_clear_inode(struct jffs2_sb_info *c, struct jffs2_inode_info *f)\n{\n\tstruct jffs2_full_dirent *fd, *fds;\n\tint deleted;\n\n\tjffs2_xattr_delete_inode(c, f->inocache);\n\tmutex_lock(&f->sem);\n\tdeleted = f->inocache && !f->inocache->pino_nlink;\n\n\tif (f->inocache && f->inocache->state != INO_STATE_CHECKING)\n\t\tjffs2_set_inocache_state(c, f->inocache, INO_STATE_CLEARING);\n\n\tif (f->metadata) {\n\t\tif (deleted)\n\t\t\tjffs2_mark_node_obsolete(c, f->metadata->raw);\n\t\tjffs2_free_full_dnode(f->metadata);\n\t}\n\n\tjffs2_kill_fragtree(&f->fragtree, deleted?c:NULL);\n\n\tfds = f->dents;\n\twhile(fds) {\n\t\tfd = fds;\n\t\tfds = fd->next;\n\t\tjffs2_free_full_dirent(fd);\n\t}\n\n\tif (f->inocache && f->inocache->state != INO_STATE_CHECKING) {\n\t\tjffs2_set_inocache_state(c, f->inocache, INO_STATE_CHECKEDABSENT);\n\t\tif (f->inocache->nodes == (void *)f->inocache)\n\t\t\tjffs2_del_ino_cache(c, f->inocache);\n\t}\n\n\tmutex_unlock(&f->sem);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}