{
  "module_name": "os-linux.h",
  "hash_id": "17159e985a201be36b5e877efbe03185421702e5ca9f10bad16f3aeef56f7a97",
  "original_prompt": "Ingested from linux-6.6.14/fs/jffs2/os-linux.h",
  "human_readable_source": " \n\n#ifndef __JFFS2_OS_LINUX_H__\n#define __JFFS2_OS_LINUX_H__\n\n \n#define os_to_jffs2_mode(x) (x)\n#define jffs2_to_os_mode(x) (x)\n\nstruct kstatfs;\nstruct kvec;\n\n#define JFFS2_INODE_INFO(i) (container_of(i, struct jffs2_inode_info, vfs_inode))\n#define OFNI_EDONI_2SFFJ(f)  (&(f)->vfs_inode)\n#define JFFS2_SB_INFO(sb) (sb->s_fs_info)\n#define OFNI_BS_2SFFJ(c)  ((struct super_block *)c->os_priv)\n\n\n#define JFFS2_F_I_SIZE(f) (OFNI_EDONI_2SFFJ(f)->i_size)\n#define JFFS2_F_I_MODE(f) (OFNI_EDONI_2SFFJ(f)->i_mode)\n#define JFFS2_F_I_UID(f) (i_uid_read(OFNI_EDONI_2SFFJ(f)))\n#define JFFS2_F_I_GID(f) (i_gid_read(OFNI_EDONI_2SFFJ(f)))\n#define JFFS2_F_I_RDEV(f) (OFNI_EDONI_2SFFJ(f)->i_rdev)\n\n#define JFFS2_CLAMP_TIME(t) ((uint32_t)clamp_t(time64_t, (t), 0, U32_MAX))\n#define ITIME(sec) ((struct timespec64){sec, 0})\n#define JFFS2_NOW() JFFS2_CLAMP_TIME(ktime_get_real_seconds())\n#define I_SEC(tv) JFFS2_CLAMP_TIME((tv).tv_sec)\n#define JFFS2_F_I_CTIME(f) I_SEC(inode_get_ctime(OFNI_EDONI_2SFFJ(f)))\n#define JFFS2_F_I_MTIME(f) I_SEC(OFNI_EDONI_2SFFJ(f)->i_mtime)\n#define JFFS2_F_I_ATIME(f) I_SEC(OFNI_EDONI_2SFFJ(f)->i_atime)\n#define sleep_on_spinunlock(wq, s)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tDECLARE_WAITQUEUE(__wait, current);\t\t\\\n\t\tadd_wait_queue((wq), &__wait);\t\t\t\\\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\t\\\n\t\tspin_unlock(s);\t\t\t\t\t\\\n\t\tschedule();\t\t\t\t\t\\\n\t\tremove_wait_queue((wq), &__wait);\t\t\\\n\t} while(0)\n\nstatic inline void jffs2_init_inode_info(struct jffs2_inode_info *f)\n{\n\tf->highest_version = 0;\n\tf->fragtree = RB_ROOT;\n\tf->metadata = NULL;\n\tf->dents = NULL;\n\tf->target = NULL;\n\tf->flags = 0;\n\tf->usercompr = 0;\n}\n\n\n#define jffs2_is_readonly(c) (OFNI_BS_2SFFJ(c)->s_flags & SB_RDONLY)\n\n#define SECTOR_ADDR(x) ( (((unsigned long)(x) / c->sector_size) * c->sector_size) )\n#ifndef CONFIG_JFFS2_FS_WRITEBUFFER\n\n\n#ifdef CONFIG_JFFS2_SUMMARY\n#define jffs2_can_mark_obsolete(c) (0)\n#else\n#define jffs2_can_mark_obsolete(c) (1)\n#endif\n\n#define jffs2_is_writebuffered(c) (0)\n#define jffs2_cleanmarker_oob(c) (0)\n#define jffs2_write_nand_cleanmarker(c,jeb) (-EIO)\n\n#define jffs2_flash_write(c, ofs, len, retlen, buf) jffs2_flash_direct_write(c, ofs, len, retlen, buf)\n#define jffs2_flash_read(c, ofs, len, retlen, buf) (mtd_read((c)->mtd, ofs, len, retlen, buf))\n#define jffs2_flush_wbuf_pad(c) ({ do{} while(0); (void)(c), 0; })\n#define jffs2_flush_wbuf_gc(c, i) ({ do{} while(0); (void)(c), (void) i, 0; })\n#define jffs2_write_nand_badblock(c,jeb,bad_offset) (1)\n#define jffs2_nand_flash_setup(c) (0)\n#define jffs2_nand_flash_cleanup(c) do {} while(0)\n#define jffs2_wbuf_dirty(c) (0)\n#define jffs2_flash_writev(a,b,c,d,e,f) jffs2_flash_direct_writev(a,b,c,d,e)\n#define jffs2_wbuf_timeout NULL\n#define jffs2_wbuf_process NULL\n#define jffs2_dataflash(c) (0)\n#define jffs2_dataflash_setup(c) (0)\n#define jffs2_dataflash_cleanup(c) do {} while (0)\n#define jffs2_nor_wbuf_flash(c) (0)\n#define jffs2_nor_wbuf_flash_setup(c) (0)\n#define jffs2_nor_wbuf_flash_cleanup(c) do {} while (0)\n#define jffs2_ubivol(c) (0)\n#define jffs2_ubivol_setup(c) (0)\n#define jffs2_ubivol_cleanup(c) do {} while (0)\n#define jffs2_dirty_trigger(c) do {} while (0)\n\n#else  \n\n#define jffs2_is_writebuffered(c) (c->wbuf != NULL)\n\n#ifdef CONFIG_JFFS2_SUMMARY\n#define jffs2_can_mark_obsolete(c) (0)\n#else\n#define jffs2_can_mark_obsolete(c) (c->mtd->flags & (MTD_BIT_WRITEABLE))\n#endif\n\n#define jffs2_cleanmarker_oob(c) (c->mtd->type == MTD_NANDFLASH)\n\n#define jffs2_wbuf_dirty(c) (!!(c)->wbuf_len)\n\n \nint jffs2_flash_writev(struct jffs2_sb_info *c, const struct kvec *vecs, unsigned long count, loff_t to, size_t *retlen, uint32_t ino);\nint jffs2_flash_write(struct jffs2_sb_info *c, loff_t ofs, size_t len, size_t *retlen, const u_char *buf);\nint jffs2_flash_read(struct jffs2_sb_info *c, loff_t ofs, size_t len, size_t *retlen, u_char *buf);\nint jffs2_check_oob_empty(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,int mode);\nint jffs2_check_nand_cleanmarker(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb);\nint jffs2_write_nand_cleanmarker(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb);\nint jffs2_write_nand_badblock(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb, uint32_t bad_offset);\nvoid jffs2_wbuf_timeout(unsigned long data);\nvoid jffs2_wbuf_process(void *data);\nint jffs2_flush_wbuf_gc(struct jffs2_sb_info *c, uint32_t ino);\nint jffs2_flush_wbuf_pad(struct jffs2_sb_info *c);\nint jffs2_nand_flash_setup(struct jffs2_sb_info *c);\nvoid jffs2_nand_flash_cleanup(struct jffs2_sb_info *c);\n\n#define jffs2_dataflash(c) (c->mtd->type == MTD_DATAFLASH)\nint jffs2_dataflash_setup(struct jffs2_sb_info *c);\nvoid jffs2_dataflash_cleanup(struct jffs2_sb_info *c);\n#define jffs2_ubivol(c) (c->mtd->type == MTD_UBIVOLUME)\nint jffs2_ubivol_setup(struct jffs2_sb_info *c);\nvoid jffs2_ubivol_cleanup(struct jffs2_sb_info *c);\n\n#define jffs2_nor_wbuf_flash(c) (c->mtd->type == MTD_NORFLASH && ! (c->mtd->flags & MTD_BIT_WRITEABLE))\nint jffs2_nor_wbuf_flash_setup(struct jffs2_sb_info *c);\nvoid jffs2_nor_wbuf_flash_cleanup(struct jffs2_sb_info *c);\nvoid jffs2_dirty_trigger(struct jffs2_sb_info *c);\n\n#endif  \n\n \nint jffs2_start_garbage_collect_thread(struct jffs2_sb_info *c);\nvoid jffs2_stop_garbage_collect_thread(struct jffs2_sb_info *c);\nvoid jffs2_garbage_collect_trigger(struct jffs2_sb_info *c);\n\n \nextern const struct file_operations jffs2_dir_operations;\nextern const struct inode_operations jffs2_dir_inode_operations;\n\n \nextern const struct file_operations jffs2_file_operations;\nextern const struct inode_operations jffs2_file_inode_operations;\nextern const struct address_space_operations jffs2_file_address_operations;\nint jffs2_fsync(struct file *, loff_t, loff_t, int);\nint __jffs2_read_folio(struct file *file, struct folio *folio);\n\n \nlong jffs2_ioctl(struct file *, unsigned int, unsigned long);\n\n \nextern const struct inode_operations jffs2_symlink_inode_operations;\n\n \nint jffs2_setattr (struct mnt_idmap *, struct dentry *, struct iattr *);\nint jffs2_do_setattr (struct inode *, struct iattr *);\nstruct inode *jffs2_iget(struct super_block *, unsigned long);\nvoid jffs2_evict_inode (struct inode *);\nvoid jffs2_dirty_inode(struct inode *inode, int flags);\nstruct inode *jffs2_new_inode (struct inode *dir_i, umode_t mode,\n\t\t\t       struct jffs2_raw_inode *ri);\nint jffs2_statfs (struct dentry *, struct kstatfs *);\nint jffs2_do_remount_fs(struct super_block *sb, struct fs_context *fc);\nint jffs2_do_fill_super(struct super_block *sb, struct fs_context *fc);\nvoid jffs2_gc_release_inode(struct jffs2_sb_info *c,\n\t\t\t    struct jffs2_inode_info *f);\nstruct jffs2_inode_info *jffs2_gc_fetch_inode(struct jffs2_sb_info *c,\n\t\t\t\t\t      int inum, int unlinked);\n\nunsigned char *jffs2_gc_fetch_page(struct jffs2_sb_info *c,\n\t\t\t\t   struct jffs2_inode_info *f,\n\t\t\t\t   unsigned long offset,\n\t\t\t\t   unsigned long *priv);\nvoid jffs2_flash_cleanup(struct jffs2_sb_info *c);\n\n\n \nint jffs2_flash_direct_writev(struct jffs2_sb_info *c, const struct kvec *vecs,\n\t\t       unsigned long count, loff_t to, size_t *retlen);\nint jffs2_flash_direct_write(struct jffs2_sb_info *c, loff_t ofs, size_t len,\n\t\t\tsize_t *retlen, const u_char *buf);\n\n#endif  \n\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}