{
  "module_name": "erase.c",
  "hash_id": "b840efd6046401afcf90632ca1a1f9a5bf92cbaddca9f73468b058b3d935adb5",
  "original_prompt": "Ingested from linux-6.6.14/fs/jffs2/erase.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/mtd/mtd.h>\n#include <linux/compiler.h>\n#include <linux/crc32.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include \"nodelist.h\"\n\nstatic void jffs2_erase_failed(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb, uint32_t bad_offset);\nstatic void jffs2_erase_succeeded(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb);\nstatic void jffs2_mark_erased_block(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb);\n\nstatic void jffs2_erase_block(struct jffs2_sb_info *c,\n\t\t\t      struct jffs2_eraseblock *jeb)\n{\n\tint ret;\n\tuint32_t bad_offset;\n#ifdef __ECOS\n       ret = jffs2_flash_erase(c, jeb);\n       if (!ret) {\n\t       jffs2_erase_succeeded(c, jeb);\n\t       return;\n       }\n       bad_offset = jeb->offset;\n#else  \n\tstruct erase_info *instr;\n\n\tjffs2_dbg(1, \"%s(): erase block %#08x (range %#08x-%#08x)\\n\",\n\t\t  __func__,\n\t\t  jeb->offset, jeb->offset, jeb->offset + c->sector_size);\n\tinstr = kzalloc(sizeof(struct erase_info), GFP_KERNEL);\n\tif (!instr) {\n\t\tpr_warn(\"kzalloc for struct erase_info in jffs2_erase_block failed. Refiling block for later\\n\");\n\t\tmutex_lock(&c->erase_free_sem);\n\t\tspin_lock(&c->erase_completion_lock);\n\t\tlist_move(&jeb->list, &c->erase_pending_list);\n\t\tc->erasing_size -= c->sector_size;\n\t\tc->dirty_size += c->sector_size;\n\t\tjeb->dirty_size = c->sector_size;\n\t\tspin_unlock(&c->erase_completion_lock);\n\t\tmutex_unlock(&c->erase_free_sem);\n\t\treturn;\n\t}\n\n\tinstr->addr = jeb->offset;\n\tinstr->len = c->sector_size;\n\n\tret = mtd_erase(c->mtd, instr);\n\tif (!ret) {\n\t\tjffs2_erase_succeeded(c, jeb);\n\t\tkfree(instr);\n\t\treturn;\n\t}\n\n\tbad_offset = instr->fail_addr;\n\tkfree(instr);\n#endif  \n\n\tif (ret == -ENOMEM || ret == -EAGAIN) {\n\t\t \n\t\tjffs2_dbg(1, \"Erase at 0x%08x failed: %d. Refiling on erase_pending_list\\n\",\n\t\t\t  jeb->offset, ret);\n\t\tmutex_lock(&c->erase_free_sem);\n\t\tspin_lock(&c->erase_completion_lock);\n\t\tlist_move(&jeb->list, &c->erase_pending_list);\n\t\tc->erasing_size -= c->sector_size;\n\t\tc->dirty_size += c->sector_size;\n\t\tjeb->dirty_size = c->sector_size;\n\t\tspin_unlock(&c->erase_completion_lock);\n\t\tmutex_unlock(&c->erase_free_sem);\n\t\treturn;\n\t}\n\n\tif (ret == -EROFS)\n\t\tpr_warn(\"Erase at 0x%08x failed immediately: -EROFS. Is the sector locked?\\n\",\n\t\t\tjeb->offset);\n\telse\n\t\tpr_warn(\"Erase at 0x%08x failed immediately: errno %d\\n\",\n\t\t\tjeb->offset, ret);\n\n\tjffs2_erase_failed(c, jeb, bad_offset);\n}\n\nint jffs2_erase_pending_blocks(struct jffs2_sb_info *c, int count)\n{\n\tstruct jffs2_eraseblock *jeb;\n\tint work_done = 0;\n\n\tmutex_lock(&c->erase_free_sem);\n\n\tspin_lock(&c->erase_completion_lock);\n\n\twhile (!list_empty(&c->erase_complete_list) ||\n\t       !list_empty(&c->erase_pending_list)) {\n\n\t\tif (!list_empty(&c->erase_complete_list)) {\n\t\t\tjeb = list_entry(c->erase_complete_list.next, struct jffs2_eraseblock, list);\n\t\t\tlist_move(&jeb->list, &c->erase_checking_list);\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\tmutex_unlock(&c->erase_free_sem);\n\t\t\tjffs2_mark_erased_block(c, jeb);\n\n\t\t\twork_done++;\n\t\t\tif (!--count) {\n\t\t\t\tjffs2_dbg(1, \"Count reached. jffs2_erase_pending_blocks leaving\\n\");\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t} else if (!list_empty(&c->erase_pending_list)) {\n\t\t\tjeb = list_entry(c->erase_pending_list.next, struct jffs2_eraseblock, list);\n\t\t\tjffs2_dbg(1, \"Starting erase of pending block 0x%08x\\n\",\n\t\t\t\t  jeb->offset);\n\t\t\tlist_del(&jeb->list);\n\t\t\tc->erasing_size += c->sector_size;\n\t\t\tc->wasted_size -= jeb->wasted_size;\n\t\t\tc->free_size -= jeb->free_size;\n\t\t\tc->used_size -= jeb->used_size;\n\t\t\tc->dirty_size -= jeb->dirty_size;\n\t\t\tjeb->wasted_size = jeb->used_size = jeb->dirty_size = jeb->free_size = 0;\n\t\t\tjffs2_free_jeb_node_refs(c, jeb);\n\t\t\tlist_add(&jeb->list, &c->erasing_list);\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\tmutex_unlock(&c->erase_free_sem);\n\n\t\t\tjffs2_erase_block(c, jeb);\n\n\t\t} else {\n\t\t\tBUG();\n\t\t}\n\n\t\t \n\t\tcond_resched();\n\t\tmutex_lock(&c->erase_free_sem);\n\t\tspin_lock(&c->erase_completion_lock);\n\t}\n\n\tspin_unlock(&c->erase_completion_lock);\n\tmutex_unlock(&c->erase_free_sem);\n done:\n\tjffs2_dbg(1, \"jffs2_erase_pending_blocks completed\\n\");\n\treturn work_done;\n}\n\nstatic void jffs2_erase_succeeded(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb)\n{\n\tjffs2_dbg(1, \"Erase completed successfully at 0x%08x\\n\", jeb->offset);\n\tmutex_lock(&c->erase_free_sem);\n\tspin_lock(&c->erase_completion_lock);\n\tlist_move_tail(&jeb->list, &c->erase_complete_list);\n\t \n\tjffs2_garbage_collect_trigger(c);\n\tspin_unlock(&c->erase_completion_lock);\n\tmutex_unlock(&c->erase_free_sem);\n\twake_up(&c->erase_wait);\n}\n\nstatic void jffs2_erase_failed(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb, uint32_t bad_offset)\n{\n\t \n\tif (jffs2_cleanmarker_oob(c) && (bad_offset != (uint32_t)MTD_FAIL_ADDR_UNKNOWN)) {\n\t\t \n\t\tif (!jffs2_write_nand_badblock(c, jeb, bad_offset)) {\n\t\t\t \n\t\t\tmutex_lock(&c->erase_free_sem);\n\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t\tlist_move(&jeb->list, &c->erase_pending_list);\n\t\t\tc->erasing_size -= c->sector_size;\n\t\t\tc->dirty_size += c->sector_size;\n\t\t\tjeb->dirty_size = c->sector_size;\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\tmutex_unlock(&c->erase_free_sem);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tmutex_lock(&c->erase_free_sem);\n\tspin_lock(&c->erase_completion_lock);\n\tc->erasing_size -= c->sector_size;\n\tc->bad_size += c->sector_size;\n\tlist_move(&jeb->list, &c->bad_list);\n\tc->nr_erasing_blocks--;\n\tspin_unlock(&c->erase_completion_lock);\n\tmutex_unlock(&c->erase_free_sem);\n\twake_up(&c->erase_wait);\n}\n\n \nstatic inline void jffs2_remove_node_refs_from_ino_list(struct jffs2_sb_info *c,\n\t\t\tstruct jffs2_raw_node_ref *ref, struct jffs2_eraseblock *jeb)\n{\n\tstruct jffs2_inode_cache *ic = NULL;\n\tstruct jffs2_raw_node_ref **prev;\n\n\tprev = &ref->next_in_ino;\n\n\t \n\twhile (1) {\n\t\tif (!(*prev)->next_in_ino) {\n\t\t\t \n\t\t\tic = (struct jffs2_inode_cache *)(*prev);\n\t\t\tprev = &ic->nodes;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (SECTOR_ADDR((*prev)->flash_offset) == jeb->offset) {\n\t\t\t \n\t\t\tstruct jffs2_raw_node_ref *this;\n\n\t\t\tthis = *prev;\n\t\t\t*prev = this->next_in_ino;\n\t\t\tthis->next_in_ino = NULL;\n\n\t\t\tif (this == ref)\n\t\t\t\tbreak;\n\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tprev = &((*prev)->next_in_ino);\n\t}\n\n\t \n\tif (!ic) {\n\t\tJFFS2_WARNING(\"inode_cache/xattr_datum/xattr_ref\"\n\t\t\t      \" not found in remove_node_refs()!!\\n\");\n\t\treturn;\n\t}\n\n\tjffs2_dbg(1, \"Removed nodes in range 0x%08x-0x%08x from ino #%u\\n\",\n\t\t  jeb->offset, jeb->offset + c->sector_size, ic->ino);\n\n\tD2({\n\t\tint i=0;\n\t\tstruct jffs2_raw_node_ref *this;\n\t\tprintk(KERN_DEBUG \"After remove_node_refs_from_ino_list: \\n\");\n\n\t\tthis = ic->nodes;\n\n\t\tprintk(KERN_DEBUG);\n\t\twhile(this) {\n\t\t\tpr_cont(\"0x%08x(%d)->\",\n\t\t\t       ref_offset(this), ref_flags(this));\n\t\t\tif (++i == 5) {\n\t\t\t\tprintk(KERN_DEBUG);\n\t\t\t\ti=0;\n\t\t\t}\n\t\t\tthis = this->next_in_ino;\n\t\t}\n\t\tpr_cont(\"\\n\");\n\t});\n\n\tswitch (ic->class) {\n#ifdef CONFIG_JFFS2_FS_XATTR\n\t\tcase RAWNODE_CLASS_XATTR_DATUM:\n\t\t\tjffs2_release_xattr_datum(c, (struct jffs2_xattr_datum *)ic);\n\t\t\tbreak;\n\t\tcase RAWNODE_CLASS_XATTR_REF:\n\t\t\tjffs2_release_xattr_ref(c, (struct jffs2_xattr_ref *)ic);\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tif (ic->nodes == (void *)ic && ic->pino_nlink == 0)\n\t\t\t\tjffs2_del_ino_cache(c, ic);\n\t}\n}\n\nvoid jffs2_free_jeb_node_refs(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb)\n{\n\tstruct jffs2_raw_node_ref *block, *ref;\n\tjffs2_dbg(1, \"Freeing all node refs for eraseblock offset 0x%08x\\n\",\n\t\t  jeb->offset);\n\n\tblock = ref = jeb->first_node;\n\n\twhile (ref) {\n\t\tif (ref->flash_offset == REF_LINK_NODE) {\n\t\t\tref = ref->next_in_ino;\n\t\t\tjffs2_free_refblock(block);\n\t\t\tblock = ref;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ref->flash_offset != REF_EMPTY_NODE && ref->next_in_ino)\n\t\t\tjffs2_remove_node_refs_from_ino_list(c, ref, jeb);\n\t\t \n\n\t\tref++;\n\t}\n\tjeb->first_node = jeb->last_node = NULL;\n}\n\nstatic int jffs2_block_check_erase(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb, uint32_t *bad_offset)\n{\n\tvoid *ebuf;\n\tuint32_t ofs;\n\tsize_t retlen;\n\tint ret;\n\tunsigned long *wordebuf;\n\n\tret = mtd_point(c->mtd, jeb->offset, c->sector_size, &retlen,\n\t\t\t&ebuf, NULL);\n\tif (ret != -EOPNOTSUPP) {\n\t\tif (ret) {\n\t\t\tjffs2_dbg(1, \"MTD point failed %d\\n\", ret);\n\t\t\tgoto do_flash_read;\n\t\t}\n\t\tif (retlen < c->sector_size) {\n\t\t\t \n\t\t\tjffs2_dbg(1, \"MTD point returned len too short: 0x%zx\\n\",\n\t\t\t\t  retlen);\n\t\t\tmtd_unpoint(c->mtd, jeb->offset, retlen);\n\t\t\tgoto do_flash_read;\n\t\t}\n\t\twordebuf = ebuf-sizeof(*wordebuf);\n\t\tretlen /= sizeof(*wordebuf);\n\t\tdo {\n\t\t   if (*++wordebuf != ~0)\n\t\t\t   break;\n\t\t} while(--retlen);\n\t\tmtd_unpoint(c->mtd, jeb->offset, c->sector_size);\n\t\tif (retlen) {\n\t\t\tpr_warn(\"Newly-erased block contained word 0x%lx at offset 0x%08tx\\n\",\n\t\t\t\t*wordebuf,\n\t\t\t\tjeb->offset +\n\t\t\t\tc->sector_size-retlen * sizeof(*wordebuf));\n\t\t\treturn -EIO;\n\t\t}\n\t\treturn 0;\n\t}\n do_flash_read:\n\tebuf = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!ebuf) {\n\t\tpr_warn(\"Failed to allocate page buffer for verifying erase at 0x%08x. Refiling\\n\",\n\t\t\tjeb->offset);\n\t\treturn -EAGAIN;\n\t}\n\n\tjffs2_dbg(1, \"Verifying erase at 0x%08x\\n\", jeb->offset);\n\n\tfor (ofs = jeb->offset; ofs < jeb->offset + c->sector_size; ) {\n\t\tuint32_t readlen = min((uint32_t)PAGE_SIZE, jeb->offset + c->sector_size - ofs);\n\t\tint i;\n\n\t\t*bad_offset = ofs;\n\n\t\tret = mtd_read(c->mtd, ofs, readlen, &retlen, ebuf);\n\t\tif (ret) {\n\t\t\tpr_warn(\"Read of newly-erased block at 0x%08x failed: %d. Putting on bad_list\\n\",\n\t\t\t\tofs, ret);\n\t\t\tret = -EIO;\n\t\t\tgoto fail;\n\t\t}\n\t\tif (retlen != readlen) {\n\t\t\tpr_warn(\"Short read from newly-erased block at 0x%08x. Wanted %d, got %zd\\n\",\n\t\t\t\tofs, readlen, retlen);\n\t\t\tret = -EIO;\n\t\t\tgoto fail;\n\t\t}\n\t\tfor (i=0; i<readlen; i += sizeof(unsigned long)) {\n\t\t\t \n\t\t\tunsigned long *datum = ebuf + i;\n\t\t\tif (*datum + 1) {\n\t\t\t\t*bad_offset += i;\n\t\t\t\tpr_warn(\"Newly-erased block contained word 0x%lx at offset 0x%08x\\n\",\n\t\t\t\t\t*datum, *bad_offset);\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t\tofs += readlen;\n\t\tcond_resched();\n\t}\n\tret = 0;\nfail:\n\tkfree(ebuf);\n\treturn ret;\n}\n\nstatic void jffs2_mark_erased_block(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb)\n{\n\tsize_t retlen;\n\tint ret;\n\tuint32_t bad_offset;\n\n\tswitch (jffs2_block_check_erase(c, jeb, &bad_offset)) {\n\tcase -EAGAIN:\tgoto refile;\n\tcase -EIO:\tgoto filebad;\n\t}\n\n\t \n\tjffs2_dbg(1, \"Writing erased marker to block at 0x%08x\\n\", jeb->offset);\n\tbad_offset = jeb->offset;\n\n\t \n\tif (jffs2_cleanmarker_oob(c) || c->cleanmarker_size == 0) {\n\n\t\tif (jffs2_cleanmarker_oob(c)) {\n\t\t\tif (jffs2_write_nand_cleanmarker(c, jeb))\n\t\t\t\tgoto filebad;\n\t\t}\n\t} else {\n\n\t\tstruct kvec vecs[1];\n\t\tstruct jffs2_unknown_node marker = {\n\t\t\t.magic =\tcpu_to_je16(JFFS2_MAGIC_BITMASK),\n\t\t\t.nodetype =\tcpu_to_je16(JFFS2_NODETYPE_CLEANMARKER),\n\t\t\t.totlen =\tcpu_to_je32(c->cleanmarker_size)\n\t\t};\n\n\t\tjffs2_prealloc_raw_node_refs(c, jeb, 1);\n\n\t\tmarker.hdr_crc = cpu_to_je32(crc32(0, &marker, sizeof(struct jffs2_unknown_node)-4));\n\n\t\tvecs[0].iov_base = (unsigned char *) &marker;\n\t\tvecs[0].iov_len = sizeof(marker);\n\t\tret = jffs2_flash_direct_writev(c, vecs, 1, jeb->offset, &retlen);\n\n\t\tif (ret || retlen != sizeof(marker)) {\n\t\t\tif (ret)\n\t\t\t\tpr_warn(\"Write clean marker to block at 0x%08x failed: %d\\n\",\n\t\t\t\t       jeb->offset, ret);\n\t\t\telse\n\t\t\t\tpr_warn(\"Short write to newly-erased block at 0x%08x: Wanted %zd, got %zd\\n\",\n\t\t\t\t       jeb->offset, sizeof(marker), retlen);\n\n\t\t\tgoto filebad;\n\t\t}\n\t}\n\t \n\tjeb->free_size = c->sector_size;\n\n\tmutex_lock(&c->erase_free_sem);\n\tspin_lock(&c->erase_completion_lock);\n\n\tc->erasing_size -= c->sector_size;\n\tc->free_size += c->sector_size;\n\n\t \n\tif (c->cleanmarker_size && !jffs2_cleanmarker_oob(c))\n\t\tjffs2_link_node_ref(c, jeb, jeb->offset | REF_NORMAL, c->cleanmarker_size, NULL);\n\n\tlist_move_tail(&jeb->list, &c->free_list);\n\tc->nr_erasing_blocks--;\n\tc->nr_free_blocks++;\n\n\tjffs2_dbg_acct_sanity_check_nolock(c, jeb);\n\tjffs2_dbg_acct_paranoia_check_nolock(c, jeb);\n\n\tspin_unlock(&c->erase_completion_lock);\n\tmutex_unlock(&c->erase_free_sem);\n\twake_up(&c->erase_wait);\n\treturn;\n\nfilebad:\n\tjffs2_erase_failed(c, jeb, bad_offset);\n\treturn;\n\nrefile:\n\t \n\tmutex_lock(&c->erase_free_sem);\n\tspin_lock(&c->erase_completion_lock);\n\tjffs2_garbage_collect_trigger(c);\n\tlist_move(&jeb->list, &c->erase_complete_list);\n\tspin_unlock(&c->erase_completion_lock);\n\tmutex_unlock(&c->erase_free_sem);\n\treturn;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}