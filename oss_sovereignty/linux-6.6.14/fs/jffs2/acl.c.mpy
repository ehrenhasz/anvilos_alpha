{
  "module_name": "acl.c",
  "hash_id": "79c9cd7347f6dc3a36e2a382be2524c85ddf3b5aa7f067a180f71671362f9c36",
  "original_prompt": "Ingested from linux-6.6.14/fs/jffs2/acl.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/crc32.h>\n#include <linux/jffs2.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/mtd/mtd.h>\n#include \"nodelist.h\"\n\nstatic size_t jffs2_acl_size(int count)\n{\n\tif (count <= 4) {\n\t\treturn sizeof(struct jffs2_acl_header)\n\t\t       + count * sizeof(struct jffs2_acl_entry_short);\n\t} else {\n\t\treturn sizeof(struct jffs2_acl_header)\n\t\t       + 4 * sizeof(struct jffs2_acl_entry_short)\n\t\t       + (count - 4) * sizeof(struct jffs2_acl_entry);\n\t}\n}\n\nstatic int jffs2_acl_count(size_t size)\n{\n\tsize_t s;\n\n\tsize -= sizeof(struct jffs2_acl_header);\n\tif (size < 4 * sizeof(struct jffs2_acl_entry_short)) {\n\t\tif (size % sizeof(struct jffs2_acl_entry_short))\n\t\t\treturn -1;\n\t\treturn size / sizeof(struct jffs2_acl_entry_short);\n\t} else {\n\t\ts = size - 4 * sizeof(struct jffs2_acl_entry_short);\n\t\tif (s % sizeof(struct jffs2_acl_entry))\n\t\t\treturn -1;\n\t\treturn s / sizeof(struct jffs2_acl_entry) + 4;\n\t}\n}\n\nstatic struct posix_acl *jffs2_acl_from_medium(void *value, size_t size)\n{\n\tvoid *end = value + size;\n\tstruct jffs2_acl_header *header = value;\n\tstruct jffs2_acl_entry *entry;\n\tstruct posix_acl *acl;\n\tuint32_t ver;\n\tint i, count;\n\n\tif (!value)\n\t\treturn NULL;\n\tif (size < sizeof(struct jffs2_acl_header))\n\t\treturn ERR_PTR(-EINVAL);\n\tver = je32_to_cpu(header->a_version);\n\tif (ver != JFFS2_ACL_VERSION) {\n\t\tJFFS2_WARNING(\"Invalid ACL version. (=%u)\\n\", ver);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tvalue += sizeof(struct jffs2_acl_header);\n\tcount = jffs2_acl_count(size);\n\tif (count < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (count == 0)\n\t\treturn NULL;\n\n\tacl = posix_acl_alloc(count, GFP_KERNEL);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (i=0; i < count; i++) {\n\t\tentry = value;\n\t\tif (value + sizeof(struct jffs2_acl_entry_short) > end)\n\t\t\tgoto fail;\n\t\tacl->a_entries[i].e_tag = je16_to_cpu(entry->e_tag);\n\t\tacl->a_entries[i].e_perm = je16_to_cpu(entry->e_perm);\n\t\tswitch (acl->a_entries[i].e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\tcase ACL_MASK:\n\t\t\tcase ACL_OTHER:\n\t\t\t\tvalue += sizeof(struct jffs2_acl_entry_short);\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_USER:\n\t\t\t\tvalue += sizeof(struct jffs2_acl_entry);\n\t\t\t\tif (value > end)\n\t\t\t\t\tgoto fail;\n\t\t\t\tacl->a_entries[i].e_uid =\n\t\t\t\t\tmake_kuid(&init_user_ns,\n\t\t\t\t\t\t  je32_to_cpu(entry->e_id));\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP:\n\t\t\t\tvalue += sizeof(struct jffs2_acl_entry);\n\t\t\t\tif (value > end)\n\t\t\t\t\tgoto fail;\n\t\t\t\tacl->a_entries[i].e_gid =\n\t\t\t\t\tmake_kgid(&init_user_ns,\n\t\t\t\t\t\t  je32_to_cpu(entry->e_id));\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\tif (value != end)\n\t\tgoto fail;\n\treturn acl;\n fail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic void *jffs2_acl_to_medium(const struct posix_acl *acl, size_t *size)\n{\n\tstruct jffs2_acl_header *header;\n\tstruct jffs2_acl_entry *entry;\n\tvoid *e;\n\tsize_t i;\n\n\t*size = jffs2_acl_size(acl->a_count);\n\theader = kmalloc(struct_size(header, a_entries, acl->a_count),\n\t\t\tGFP_KERNEL);\n\tif (!header)\n\t\treturn ERR_PTR(-ENOMEM);\n\theader->a_version = cpu_to_je32(JFFS2_ACL_VERSION);\n\te = header + 1;\n\tfor (i=0; i < acl->a_count; i++) {\n\t\tconst struct posix_acl_entry *acl_e = &acl->a_entries[i];\n\t\tentry = e;\n\t\tentry->e_tag = cpu_to_je16(acl_e->e_tag);\n\t\tentry->e_perm = cpu_to_je16(acl_e->e_perm);\n\t\tswitch(acl_e->e_tag) {\n\t\t\tcase ACL_USER:\n\t\t\t\tentry->e_id = cpu_to_je32(\n\t\t\t\t\tfrom_kuid(&init_user_ns, acl_e->e_uid));\n\t\t\t\te += sizeof(struct jffs2_acl_entry);\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP:\n\t\t\t\tentry->e_id = cpu_to_je32(\n\t\t\t\t\tfrom_kgid(&init_user_ns, acl_e->e_gid));\n\t\t\t\te += sizeof(struct jffs2_acl_entry);\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_USER_OBJ:\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\tcase ACL_MASK:\n\t\t\tcase ACL_OTHER:\n\t\t\t\te += sizeof(struct jffs2_acl_entry_short);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn header;\n fail:\n\tkfree(header);\n\treturn ERR_PTR(-EINVAL);\n}\n\nstruct posix_acl *jffs2_get_acl(struct inode *inode, int type, bool rcu)\n{\n\tstruct posix_acl *acl;\n\tchar *value = NULL;\n\tint rc, xprefix;\n\n\tif (rcu)\n\t\treturn ERR_PTR(-ECHILD);\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\txprefix = JFFS2_XPREFIX_ACL_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\txprefix = JFFS2_XPREFIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\trc = do_jffs2_getxattr(inode, xprefix, \"\", NULL, 0);\n\tif (rc > 0) {\n\t\tvalue = kmalloc(rc, GFP_KERNEL);\n\t\tif (!value)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\trc = do_jffs2_getxattr(inode, xprefix, \"\", value, rc);\n\t}\n\tif (rc > 0) {\n\t\tacl = jffs2_acl_from_medium(value, rc);\n\t} else if (rc == -ENODATA || rc == -ENOSYS) {\n\t\tacl = NULL;\n\t} else {\n\t\tacl = ERR_PTR(rc);\n\t}\n\tkfree(value);\n\treturn acl;\n}\n\nstatic int __jffs2_set_acl(struct inode *inode, int xprefix, struct posix_acl *acl)\n{\n\tchar *value = NULL;\n\tsize_t size = 0;\n\tint rc;\n\n\tif (acl) {\n\t\tvalue = jffs2_acl_to_medium(acl, &size);\n\t\tif (IS_ERR(value))\n\t\t\treturn PTR_ERR(value);\n\t}\n\trc = do_jffs2_setxattr(inode, xprefix, \"\", value, size, 0);\n\tif (!value && rc == -ENODATA)\n\t\trc = 0;\n\tkfree(value);\n\n\treturn rc;\n}\n\nint jffs2_set_acl(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\t  struct posix_acl *acl, int type)\n{\n\tint rc, xprefix;\n\tstruct inode *inode = d_inode(dentry);\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\txprefix = JFFS2_XPREFIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tumode_t mode;\n\n\t\t\trc = posix_acl_update_mode(&nop_mnt_idmap, inode, &mode,\n\t\t\t\t\t\t   &acl);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\tif (inode->i_mode != mode) {\n\t\t\t\tstruct iattr attr;\n\n\t\t\t\tattr.ia_valid = ATTR_MODE | ATTR_CTIME;\n\t\t\t\tattr.ia_mode = mode;\n\t\t\t\tattr.ia_ctime = current_time(inode);\n\t\t\t\trc = jffs2_do_setattr(inode, &attr);\n\t\t\t\tif (rc < 0)\n\t\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\txprefix = JFFS2_XPREFIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\trc = __jffs2_set_acl(inode, xprefix, acl);\n\tif (!rc)\n\t\tset_cached_acl(inode, type, acl);\n\treturn rc;\n}\n\nint jffs2_init_acl_pre(struct inode *dir_i, struct inode *inode, umode_t *i_mode)\n{\n\tstruct posix_acl *default_acl, *acl;\n\tint rc;\n\n\tcache_no_acl(inode);\n\n\trc = posix_acl_create(dir_i, i_mode, &default_acl, &acl);\n\tif (rc)\n\t\treturn rc;\n\n\tif (default_acl) {\n\t\tset_cached_acl(inode, ACL_TYPE_DEFAULT, default_acl);\n\t\tposix_acl_release(default_acl);\n\t}\n\tif (acl) {\n\t\tset_cached_acl(inode, ACL_TYPE_ACCESS, acl);\n\t\tposix_acl_release(acl);\n\t}\n\treturn 0;\n}\n\nint jffs2_init_acl_post(struct inode *inode)\n{\n\tint rc;\n\n\tif (inode->i_default_acl) {\n\t\trc = __jffs2_set_acl(inode, JFFS2_XPREFIX_ACL_DEFAULT, inode->i_default_acl);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tif (inode->i_acl) {\n\t\trc = __jffs2_set_acl(inode, JFFS2_XPREFIX_ACL_ACCESS, inode->i_acl);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}