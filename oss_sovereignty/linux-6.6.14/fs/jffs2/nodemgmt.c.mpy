{
  "module_name": "nodemgmt.c",
  "hash_id": "3fffab51dd60562b35e33acb19525cc0a2cb71bb6c819d4534013be846a9a8dd",
  "original_prompt": "Ingested from linux-6.6.14/fs/jffs2/nodemgmt.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/mtd/mtd.h>\n#include <linux/compiler.h>\n#include <linux/sched/signal.h>\n#include \"nodelist.h\"\n#include \"debug.h\"\n\n \nstatic int jffs2_rp_can_write(struct jffs2_sb_info *c)\n{\n\tuint32_t avail;\n\tstruct jffs2_mount_opts *opts = &c->mount_opts;\n\n\tavail = c->dirty_size + c->free_size + c->unchecked_size +\n\t\tc->erasing_size - c->resv_blocks_write * c->sector_size\n\t\t- c->nospc_dirty_size;\n\n\tif (avail < 2 * opts->rp_size)\n\t\tjffs2_dbg(1, \"rpsize %u, dirty_size %u, free_size %u, \"\n\t\t\t  \"erasing_size %u, unchecked_size %u, \"\n\t\t\t  \"nr_erasing_blocks %u, avail %u, resrv %u\\n\",\n\t\t\t  opts->rp_size, c->dirty_size, c->free_size,\n\t\t\t  c->erasing_size, c->unchecked_size,\n\t\t\t  c->nr_erasing_blocks, avail, c->nospc_dirty_size);\n\n\tif (avail > opts->rp_size)\n\t\treturn 1;\n\n\t \n\tif (capable(CAP_SYS_RESOURCE))\n\t\treturn 1;\n\n\tjffs2_dbg(1, \"forbid writing\\n\");\n\treturn 0;\n}\n\n \n\nstatic int jffs2_do_reserve_space(struct jffs2_sb_info *c,  uint32_t minsize,\n\t\t\t\t  uint32_t *len, uint32_t sumsize);\n\nint jffs2_reserve_space(struct jffs2_sb_info *c, uint32_t minsize,\n\t\t\tuint32_t *len, int prio, uint32_t sumsize)\n{\n\tint ret = -EAGAIN;\n\tint blocksneeded = c->resv_blocks_write;\n\t \n\tminsize = PAD(minsize);\n\n\tjffs2_dbg(1, \"%s(): Requested 0x%x bytes\\n\", __func__, minsize);\n\tmutex_lock(&c->alloc_sem);\n\n\tjffs2_dbg(1, \"%s(): alloc sem got\\n\", __func__);\n\n\tspin_lock(&c->erase_completion_lock);\n\n\t \n\tif (prio != ALLOC_DELETION && !jffs2_rp_can_write(c)) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t \n\twhile(ret == -EAGAIN) {\n\t\twhile(c->nr_free_blocks + c->nr_erasing_blocks < blocksneeded) {\n\t\t\tuint32_t dirty, avail;\n\n\t\t\t \n\t\t\tdirty = c->dirty_size + c->erasing_size - c->nr_erasing_blocks * c->sector_size + c->unchecked_size;\n\t\t\tif (dirty < c->nospc_dirty_size) {\n\t\t\t\tif (prio == ALLOC_DELETION && c->nr_free_blocks + c->nr_erasing_blocks >= c->resv_blocks_deletion) {\n\t\t\t\t\tjffs2_dbg(1, \"%s(): Low on dirty space to GC, but it's a deletion. Allowing...\\n\",\n\t\t\t\t\t\t  __func__);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tjffs2_dbg(1, \"dirty size 0x%08x + unchecked_size 0x%08x < nospc_dirty_size 0x%08x, returning -ENOSPC\\n\",\n\t\t\t\t\t  dirty, c->unchecked_size,\n\t\t\t\t\t  c->sector_size);\n\n\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t\tmutex_unlock(&c->alloc_sem);\n\t\t\t\treturn -ENOSPC;\n\t\t\t}\n\n\t\t\t \n\t\t\tavail = c->free_size + c->dirty_size + c->erasing_size + c->unchecked_size;\n\t\t\tif ( (avail / c->sector_size) <= blocksneeded) {\n\t\t\t\tif (prio == ALLOC_DELETION && c->nr_free_blocks + c->nr_erasing_blocks >= c->resv_blocks_deletion) {\n\t\t\t\t\tjffs2_dbg(1, \"%s(): Low on possibly available space, but it's a deletion. Allowing...\\n\",\n\t\t\t\t\t\t  __func__);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tjffs2_dbg(1, \"max. available size 0x%08x  < blocksneeded * sector_size 0x%08x, returning -ENOSPC\\n\",\n\t\t\t\t\t  avail, blocksneeded * c->sector_size);\n\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t\tmutex_unlock(&c->alloc_sem);\n\t\t\t\treturn -ENOSPC;\n\t\t\t}\n\n\t\t\tmutex_unlock(&c->alloc_sem);\n\n\t\t\tjffs2_dbg(1, \"Triggering GC pass. nr_free_blocks %d, nr_erasing_blocks %d, free_size 0x%08x, dirty_size 0x%08x, wasted_size 0x%08x, used_size 0x%08x, erasing_size 0x%08x, bad_size 0x%08x (total 0x%08x of 0x%08x)\\n\",\n\t\t\t\t  c->nr_free_blocks, c->nr_erasing_blocks,\n\t\t\t\t  c->free_size, c->dirty_size, c->wasted_size,\n\t\t\t\t  c->used_size, c->erasing_size, c->bad_size,\n\t\t\t\t  c->free_size + c->dirty_size +\n\t\t\t\t  c->wasted_size + c->used_size +\n\t\t\t\t  c->erasing_size + c->bad_size,\n\t\t\t\t  c->flash_size);\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\t\tret = jffs2_garbage_collect_pass(c);\n\n\t\t\tif (ret == -EAGAIN) {\n\t\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t\t\tif (c->nr_erasing_blocks &&\n\t\t\t\t    list_empty(&c->erase_pending_list) &&\n\t\t\t\t    list_empty(&c->erase_complete_list)) {\n\t\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\t\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\t\tadd_wait_queue(&c->erase_wait, &wait);\n\t\t\t\t\tjffs2_dbg(1, \"%s waiting for erase to complete\\n\",\n\t\t\t\t\t\t  __func__);\n\t\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\t\t\t\tschedule();\n\t\t\t\t\tremove_wait_queue(&c->erase_wait, &wait);\n\t\t\t\t} else\n\t\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t} else if (ret)\n\t\t\t\treturn ret;\n\n\t\t\tcond_resched();\n\n\t\t\tif (signal_pending(current))\n\t\t\t\treturn -EINTR;\n\n\t\t\tmutex_lock(&c->alloc_sem);\n\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t}\n\n\t\tret = jffs2_do_reserve_space(c, minsize, len, sumsize);\n\t\tif (ret) {\n\t\t\tjffs2_dbg(1, \"%s(): ret is %d\\n\", __func__, ret);\n\t\t}\n\t}\n\nout:\n\tspin_unlock(&c->erase_completion_lock);\n\tif (!ret)\n\t\tret = jffs2_prealloc_raw_node_refs(c, c->nextblock, 1);\n\tif (ret)\n\t\tmutex_unlock(&c->alloc_sem);\n\treturn ret;\n}\n\nint jffs2_reserve_space_gc(struct jffs2_sb_info *c, uint32_t minsize,\n\t\t\t   uint32_t *len, uint32_t sumsize)\n{\n\tint ret;\n\tminsize = PAD(minsize);\n\n\tjffs2_dbg(1, \"%s(): Requested 0x%x bytes\\n\", __func__, minsize);\n\n\twhile (true) {\n\t\tspin_lock(&c->erase_completion_lock);\n\t\tret = jffs2_do_reserve_space(c, minsize, len, sumsize);\n\t\tif (ret) {\n\t\t\tjffs2_dbg(1, \"%s(): looping, ret is %d\\n\",\n\t\t\t\t  __func__, ret);\n\t\t}\n\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\tif (ret == -EAGAIN)\n\t\t\tcond_resched();\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (!ret)\n\t\tret = jffs2_prealloc_raw_node_refs(c, c->nextblock, 1);\n\n\treturn ret;\n}\n\n\n \n\nstatic void jffs2_close_nextblock(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb)\n{\n\n\tif (c->nextblock == NULL) {\n\t\tjffs2_dbg(1, \"%s(): Erase block at 0x%08x has already been placed in a list\\n\",\n\t\t\t  __func__, jeb->offset);\n\t\treturn;\n\t}\n\t \n\tif (ISDIRTY (jeb->wasted_size + jeb->dirty_size)) {\n\t\tc->dirty_size += jeb->wasted_size;\n\t\tc->wasted_size -= jeb->wasted_size;\n\t\tjeb->dirty_size += jeb->wasted_size;\n\t\tjeb->wasted_size = 0;\n\t\tif (VERYDIRTY(c, jeb->dirty_size)) {\n\t\t\tjffs2_dbg(1, \"Adding full erase block at 0x%08x to very_dirty_list (free 0x%08x, dirty 0x%08x, used 0x%08x\\n\",\n\t\t\t\t  jeb->offset, jeb->free_size, jeb->dirty_size,\n\t\t\t\t  jeb->used_size);\n\t\t\tlist_add_tail(&jeb->list, &c->very_dirty_list);\n\t\t} else {\n\t\t\tjffs2_dbg(1, \"Adding full erase block at 0x%08x to dirty_list (free 0x%08x, dirty 0x%08x, used 0x%08x\\n\",\n\t\t\t\t  jeb->offset, jeb->free_size, jeb->dirty_size,\n\t\t\t\t  jeb->used_size);\n\t\t\tlist_add_tail(&jeb->list, &c->dirty_list);\n\t\t}\n\t} else {\n\t\tjffs2_dbg(1, \"Adding full erase block at 0x%08x to clean_list (free 0x%08x, dirty 0x%08x, used 0x%08x\\n\",\n\t\t\t  jeb->offset, jeb->free_size, jeb->dirty_size,\n\t\t\t  jeb->used_size);\n\t\tlist_add_tail(&jeb->list, &c->clean_list);\n\t}\n\tc->nextblock = NULL;\n\n}\n\n \n\nstatic int jffs2_find_nextblock(struct jffs2_sb_info *c)\n{\n\tstruct list_head *next;\n\n\t \n\n\tif (list_empty(&c->free_list)) {\n\n\t\tif (!c->nr_erasing_blocks &&\n\t\t\t!list_empty(&c->erasable_list)) {\n\t\t\tstruct jffs2_eraseblock *ejeb;\n\n\t\t\tejeb = list_entry(c->erasable_list.next, struct jffs2_eraseblock, list);\n\t\t\tlist_move_tail(&ejeb->list, &c->erase_pending_list);\n\t\t\tc->nr_erasing_blocks++;\n\t\t\tjffs2_garbage_collect_trigger(c);\n\t\t\tjffs2_dbg(1, \"%s(): Triggering erase of erasable block at 0x%08x\\n\",\n\t\t\t\t  __func__, ejeb->offset);\n\t\t}\n\n\t\tif (!c->nr_erasing_blocks &&\n\t\t\t!list_empty(&c->erasable_pending_wbuf_list)) {\n\t\t\tjffs2_dbg(1, \"%s(): Flushing write buffer\\n\",\n\t\t\t\t  __func__);\n\t\t\t \n\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\tjffs2_flush_wbuf_pad(c);\n\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t\t \n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\tif (!c->nr_erasing_blocks) {\n\t\t\t \n\t\t\tpr_crit(\"Argh. No free space left for GC. nr_erasing_blocks is %d. nr_free_blocks is %d. (erasableempty: %s, erasingempty: %s, erasependingempty: %s)\\n\",\n\t\t\t\tc->nr_erasing_blocks, c->nr_free_blocks,\n\t\t\t\tlist_empty(&c->erasable_list) ? \"yes\" : \"no\",\n\t\t\t\tlist_empty(&c->erasing_list) ? \"yes\" : \"no\",\n\t\t\t\tlist_empty(&c->erase_pending_list) ? \"yes\" : \"no\");\n\t\t\treturn -ENOSPC;\n\t\t}\n\n\t\tspin_unlock(&c->erase_completion_lock);\n\t\t \n\t\tjffs2_erase_pending_blocks(c, 1);\n\t\tspin_lock(&c->erase_completion_lock);\n\n\t\t \n\t\treturn -EAGAIN;\n\t}\n\n\tnext = c->free_list.next;\n\tlist_del(next);\n\tc->nextblock = list_entry(next, struct jffs2_eraseblock, list);\n\tc->nr_free_blocks--;\n\n\tjffs2_sum_reset_collected(c->summary);  \n\n#ifdef CONFIG_JFFS2_FS_WRITEBUFFER\n\t \n\tif (!(c->wbuf_ofs % c->sector_size) && !c->wbuf_len)\n\t\tc->wbuf_ofs = 0xffffffff;\n#endif\n\n\tjffs2_dbg(1, \"%s(): new nextblock = 0x%08x\\n\",\n\t\t  __func__, c->nextblock->offset);\n\n\treturn 0;\n}\n\n \nstatic int jffs2_do_reserve_space(struct jffs2_sb_info *c, uint32_t minsize,\n\t\t\t\t  uint32_t *len, uint32_t sumsize)\n{\n\tstruct jffs2_eraseblock *jeb = c->nextblock;\n\tuint32_t reserved_size;\t\t\t\t \n\tint ret;\n\n restart:\n\treserved_size = 0;\n\n\tif (jffs2_sum_active() && (sumsize != JFFS2_SUMMARY_NOSUM_SIZE)) {\n\t\t\t\t\t\t\t \n\n\t\tif (jeb) {\n\t\t\treserved_size = PAD(sumsize + c->summary->sum_size + JFFS2_SUMMARY_FRAME_SIZE);\n\t\t\tdbg_summary(\"minsize=%d , jeb->free=%d ,\"\n\t\t\t\t\t\t\"summary->size=%d , sumsize=%d\\n\",\n\t\t\t\t\t\tminsize, jeb->free_size,\n\t\t\t\t\t\tc->summary->sum_size, sumsize);\n\t\t}\n\n\t\t \n\t\tif (jeb && (PAD(minsize) + PAD(c->summary->sum_size + sumsize +\n\t\t\t\t\tJFFS2_SUMMARY_FRAME_SIZE) > jeb->free_size)) {\n\n\t\t\t \n\t\t\tif (jffs2_sum_is_disabled(c->summary)) {\n\t\t\t\tsumsize = JFFS2_SUMMARY_NOSUM_SIZE;\n\t\t\t\tgoto restart;\n\t\t\t}\n\n\t\t\t \n\t\t\tdbg_summary(\"generating summary for 0x%08x.\\n\", jeb->offset);\n\t\t\tret = jffs2_sum_write_sumnode(c);\n\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tif (jffs2_sum_is_disabled(c->summary)) {\n\t\t\t\t \n\t\t\t\tsumsize = JFFS2_SUMMARY_NOSUM_SIZE;\n\t\t\t\tgoto restart;\n\t\t\t}\n\n\t\t\tjffs2_close_nextblock(c, jeb);\n\t\t\tjeb = NULL;\n\t\t\t \n\t\t\treserved_size = PAD(sumsize + c->summary->sum_size + JFFS2_SUMMARY_FRAME_SIZE);\n\t\t}\n\t} else {\n\t\tif (jeb && minsize > jeb->free_size) {\n\t\t\tuint32_t waste;\n\n\t\t\t \n\t\t\t \n\n\t\t\tif (jffs2_wbuf_dirty(c)) {\n\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t\tjffs2_dbg(1, \"%s(): Flushing write buffer\\n\",\n\t\t\t\t\t  __func__);\n\t\t\t\tjffs2_flush_wbuf_pad(c);\n\t\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t\t\tjeb = c->nextblock;\n\t\t\t\tgoto restart;\n\t\t\t}\n\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\t\tret = jffs2_prealloc_raw_node_refs(c, jeb, 1);\n\n\t\t\t \n\t\t\tspin_lock(&c->erase_completion_lock);\n\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\twaste = jeb->free_size;\n\t\t\tjffs2_link_node_ref(c, jeb,\n\t\t\t\t\t    (jeb->offset + c->sector_size - waste) | REF_OBSOLETE,\n\t\t\t\t\t    waste, NULL);\n\t\t\t \n\t\t\tjeb->dirty_size -= waste;\n\t\t\tc->dirty_size -= waste;\n\t\t\tjeb->wasted_size += waste;\n\t\t\tc->wasted_size += waste;\n\n\t\t\tjffs2_close_nextblock(c, jeb);\n\t\t\tjeb = NULL;\n\t\t}\n\t}\n\n\tif (!jeb) {\n\n\t\tret = jffs2_find_nextblock(c);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tjeb = c->nextblock;\n\n\t\tif (jeb->free_size != c->sector_size - c->cleanmarker_size) {\n\t\t\tpr_warn(\"Eep. Block 0x%08x taken from free_list had free_size of 0x%08x!!\\n\",\n\t\t\t\tjeb->offset, jeb->free_size);\n\t\t\tgoto restart;\n\t\t}\n\t}\n\t \n\t*len = jeb->free_size - reserved_size;\n\n\tif (c->cleanmarker_size && jeb->used_size == c->cleanmarker_size &&\n\t    !jeb->first_node->next_in_ino) {\n\t\t \n\t\tspin_unlock(&c->erase_completion_lock);\n\t\tjffs2_mark_node_obsolete(c, jeb->first_node);\n\t\tspin_lock(&c->erase_completion_lock);\n\t}\n\n\tjffs2_dbg(1, \"%s(): Giving 0x%x bytes at 0x%x\\n\",\n\t\t  __func__,\n\t\t  *len, jeb->offset + (c->sector_size - jeb->free_size));\n\treturn 0;\n}\n\n \n\nstruct jffs2_raw_node_ref *jffs2_add_physical_node_ref(struct jffs2_sb_info *c,\n\t\t\t\t\t\t       uint32_t ofs, uint32_t len,\n\t\t\t\t\t\t       struct jffs2_inode_cache *ic)\n{\n\tstruct jffs2_eraseblock *jeb;\n\tstruct jffs2_raw_node_ref *new;\n\n\tjeb = &c->blocks[ofs / c->sector_size];\n\n\tjffs2_dbg(1, \"%s(): Node at 0x%x(%d), size 0x%x\\n\",\n\t\t  __func__, ofs & ~3, ofs & 3, len);\n#if 1\n\t \n\tif ((c->nextblock || ((ofs & 3) != REF_OBSOLETE))\n\t    && (jeb != c->nextblock || (ofs & ~3) != jeb->offset + (c->sector_size - jeb->free_size))) {\n\t\tpr_warn(\"argh. node added in wrong place at 0x%08x(%d)\\n\",\n\t\t\tofs & ~3, ofs & 3);\n\t\tif (c->nextblock)\n\t\t\tpr_warn(\"nextblock 0x%08x\", c->nextblock->offset);\n\t\telse\n\t\t\tpr_warn(\"No nextblock\");\n\t\tpr_cont(\", expected at %08x\\n\",\n\t\t\tjeb->offset + (c->sector_size - jeb->free_size));\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n#endif\n\tspin_lock(&c->erase_completion_lock);\n\n\tnew = jffs2_link_node_ref(c, jeb, ofs, len, ic);\n\n\tif (!jeb->free_size && !jeb->dirty_size && !ISDIRTY(jeb->wasted_size)) {\n\t\t \n\t\tjffs2_dbg(1, \"Adding full erase block at 0x%08x to clean_list (free 0x%08x, dirty 0x%08x, used 0x%08x\\n\",\n\t\t\t  jeb->offset, jeb->free_size, jeb->dirty_size,\n\t\t\t  jeb->used_size);\n\t\tif (jffs2_wbuf_dirty(c)) {\n\t\t\t \n\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\tjffs2_flush_wbuf_pad(c);\n\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t}\n\n\t\tlist_add_tail(&jeb->list, &c->clean_list);\n\t\tc->nextblock = NULL;\n\t}\n\tjffs2_dbg_acct_sanity_check_nolock(c,jeb);\n\tjffs2_dbg_acct_paranoia_check_nolock(c, jeb);\n\n\tspin_unlock(&c->erase_completion_lock);\n\n\treturn new;\n}\n\n\nvoid jffs2_complete_reservation(struct jffs2_sb_info *c)\n{\n\tjffs2_dbg(1, \"jffs2_complete_reservation()\\n\");\n\tspin_lock(&c->erase_completion_lock);\n\tjffs2_garbage_collect_trigger(c);\n\tspin_unlock(&c->erase_completion_lock);\n\tmutex_unlock(&c->alloc_sem);\n}\n\nstatic inline int on_list(struct list_head *obj, struct list_head *head)\n{\n\tstruct list_head *this;\n\n\tlist_for_each(this, head) {\n\t\tif (this == obj) {\n\t\t\tjffs2_dbg(1, \"%p is on list at %p\\n\", obj, head);\n\t\t\treturn 1;\n\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid jffs2_mark_node_obsolete(struct jffs2_sb_info *c, struct jffs2_raw_node_ref *ref)\n{\n\tstruct jffs2_eraseblock *jeb;\n\tint blocknr;\n\tstruct jffs2_unknown_node n;\n\tint ret, addedsize;\n\tsize_t retlen;\n\tuint32_t freed_len;\n\n\tif(unlikely(!ref)) {\n\t\tpr_notice(\"EEEEEK. jffs2_mark_node_obsolete called with NULL node\\n\");\n\t\treturn;\n\t}\n\tif (ref_obsolete(ref)) {\n\t\tjffs2_dbg(1, \"%s(): called with already obsolete node at 0x%08x\\n\",\n\t\t\t  __func__, ref_offset(ref));\n\t\treturn;\n\t}\n\tblocknr = ref->flash_offset / c->sector_size;\n\tif (blocknr >= c->nr_blocks) {\n\t\tpr_notice(\"raw node at 0x%08x is off the end of device!\\n\",\n\t\t\t  ref->flash_offset);\n\t\tBUG();\n\t}\n\tjeb = &c->blocks[blocknr];\n\n\tif (jffs2_can_mark_obsolete(c) && !jffs2_is_readonly(c) &&\n\t    !(c->flags & (JFFS2_SB_FLAG_SCANNING | JFFS2_SB_FLAG_BUILDING))) {\n\t\t \n\t\tmutex_lock(&c->erase_free_sem);\n\t}\n\n\tspin_lock(&c->erase_completion_lock);\n\n\tfreed_len = ref_totlen(c, jeb, ref);\n\n\tif (ref_flags(ref) == REF_UNCHECKED) {\n\t\tD1(if (unlikely(jeb->unchecked_size < freed_len)) {\n\t\t\t\tpr_notice(\"raw unchecked node of size 0x%08x freed from erase block %d at 0x%08x, but unchecked_size was already 0x%08x\\n\",\n\t\t\t\t\t  freed_len, blocknr,\n\t\t\t\t\t  ref->flash_offset, jeb->used_size);\n\t\t\tBUG();\n\t\t})\n\t\t\tjffs2_dbg(1, \"Obsoleting previously unchecked node at 0x%08x of len %x\\n\",\n\t\t\t\t  ref_offset(ref), freed_len);\n\t\tjeb->unchecked_size -= freed_len;\n\t\tc->unchecked_size -= freed_len;\n\t} else {\n\t\tD1(if (unlikely(jeb->used_size < freed_len)) {\n\t\t\t\tpr_notice(\"raw node of size 0x%08x freed from erase block %d at 0x%08x, but used_size was already 0x%08x\\n\",\n\t\t\t\t\t  freed_len, blocknr,\n\t\t\t\t\t  ref->flash_offset, jeb->used_size);\n\t\t\tBUG();\n\t\t})\n\t\t\tjffs2_dbg(1, \"Obsoleting node at 0x%08x of len %#x: \",\n\t\t\t\t  ref_offset(ref), freed_len);\n\t\tjeb->used_size -= freed_len;\n\t\tc->used_size -= freed_len;\n\t}\n\n\t \n\tif ((jeb->dirty_size || ISDIRTY(jeb->wasted_size + freed_len)) && jeb != c->nextblock) {\n\t\tjffs2_dbg(1, \"Dirtying\\n\");\n\t\taddedsize = freed_len;\n\t\tjeb->dirty_size += freed_len;\n\t\tc->dirty_size += freed_len;\n\n\t\t \n\t\tif (jeb->wasted_size) {\n\t\t\tif (on_list(&jeb->list, &c->bad_used_list)) {\n\t\t\t\tjffs2_dbg(1, \"Leaving block at %08x on the bad_used_list\\n\",\n\t\t\t\t\t  jeb->offset);\n\t\t\t\taddedsize = 0;  \n\t\t\t} else {\n\t\t\t\tjffs2_dbg(1, \"Converting %d bytes of wasted space to dirty in block at %08x\\n\",\n\t\t\t\t\t  jeb->wasted_size, jeb->offset);\n\t\t\t\taddedsize += jeb->wasted_size;\n\t\t\t\tjeb->dirty_size += jeb->wasted_size;\n\t\t\t\tc->dirty_size += jeb->wasted_size;\n\t\t\t\tc->wasted_size -= jeb->wasted_size;\n\t\t\t\tjeb->wasted_size = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tjffs2_dbg(1, \"Wasting\\n\");\n\t\taddedsize = 0;\n\t\tjeb->wasted_size += freed_len;\n\t\tc->wasted_size += freed_len;\n\t}\n\tref->flash_offset = ref_offset(ref) | REF_OBSOLETE;\n\n\tjffs2_dbg_acct_sanity_check_nolock(c, jeb);\n\tjffs2_dbg_acct_paranoia_check_nolock(c, jeb);\n\n\tif (c->flags & JFFS2_SB_FLAG_SCANNING) {\n\t\t \n\t\tspin_unlock(&c->erase_completion_lock);\n\t\t \n\t\treturn;\n\t}\n\n\tif (jeb == c->nextblock) {\n\t\tjffs2_dbg(2, \"Not moving nextblock 0x%08x to dirty/erase_pending list\\n\",\n\t\t\t  jeb->offset);\n\t} else if (!jeb->used_size && !jeb->unchecked_size) {\n\t\tif (jeb == c->gcblock) {\n\t\t\tjffs2_dbg(1, \"gcblock at 0x%08x completely dirtied. Clearing gcblock...\\n\",\n\t\t\t\t  jeb->offset);\n\t\t\tc->gcblock = NULL;\n\t\t} else {\n\t\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x completely dirtied. Removing from (dirty?) list...\\n\",\n\t\t\t\t  jeb->offset);\n\t\t\tlist_del(&jeb->list);\n\t\t}\n\t\tif (jffs2_wbuf_dirty(c)) {\n\t\t\tjffs2_dbg(1, \"...and adding to erasable_pending_wbuf_list\\n\");\n\t\t\tlist_add_tail(&jeb->list, &c->erasable_pending_wbuf_list);\n\t\t} else {\n\t\t\tif (jiffies & 127) {\n\t\t\t\t \n\t\t\t\tjffs2_dbg(1, \"...and adding to erase_pending_list\\n\");\n\t\t\t\tlist_add_tail(&jeb->list, &c->erase_pending_list);\n\t\t\t\tc->nr_erasing_blocks++;\n\t\t\t\tjffs2_garbage_collect_trigger(c);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tjffs2_dbg(1, \"...and adding to erasable_list\\n\");\n\t\t\t\tlist_add_tail(&jeb->list, &c->erasable_list);\n\t\t\t}\n\t\t}\n\t\tjffs2_dbg(1, \"Done OK\\n\");\n\t} else if (jeb == c->gcblock) {\n\t\tjffs2_dbg(2, \"Not moving gcblock 0x%08x to dirty_list\\n\",\n\t\t\t  jeb->offset);\n\t} else if (ISDIRTY(jeb->dirty_size) && !ISDIRTY(jeb->dirty_size - addedsize)) {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x is freshly dirtied. Removing from clean list...\\n\",\n\t\t\t  jeb->offset);\n\t\tlist_del(&jeb->list);\n\t\tjffs2_dbg(1, \"...and adding to dirty_list\\n\");\n\t\tlist_add_tail(&jeb->list, &c->dirty_list);\n\t} else if (VERYDIRTY(c, jeb->dirty_size) &&\n\t\t   !VERYDIRTY(c, jeb->dirty_size - addedsize)) {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x is now very dirty. Removing from dirty list...\\n\",\n\t\t\t  jeb->offset);\n\t\tlist_del(&jeb->list);\n\t\tjffs2_dbg(1, \"...and adding to very_dirty_list\\n\");\n\t\tlist_add_tail(&jeb->list, &c->very_dirty_list);\n\t} else {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x not moved anywhere. (free 0x%08x, dirty 0x%08x, used 0x%08x)\\n\",\n\t\t\t  jeb->offset, jeb->free_size, jeb->dirty_size,\n\t\t\t  jeb->used_size);\n\t}\n\n\tspin_unlock(&c->erase_completion_lock);\n\n\tif (!jffs2_can_mark_obsolete(c) || jffs2_is_readonly(c) ||\n\t\t(c->flags & JFFS2_SB_FLAG_BUILDING)) {\n\t\t \n\t\treturn;\n\t}\n\n\t \n\n\tjffs2_dbg(1, \"obliterating obsoleted node at 0x%08x\\n\",\n\t\t  ref_offset(ref));\n\tret = jffs2_flash_read(c, ref_offset(ref), sizeof(n), &retlen, (char *)&n);\n\tif (ret) {\n\t\tpr_warn(\"Read error reading from obsoleted node at 0x%08x: %d\\n\",\n\t\t\tref_offset(ref), ret);\n\t\tgoto out_erase_sem;\n\t}\n\tif (retlen != sizeof(n)) {\n\t\tpr_warn(\"Short read from obsoleted node at 0x%08x: %zd\\n\",\n\t\t\tref_offset(ref), retlen);\n\t\tgoto out_erase_sem;\n\t}\n\tif (PAD(je32_to_cpu(n.totlen)) != PAD(freed_len)) {\n\t\tpr_warn(\"Node totlen on flash (0x%08x) != totlen from node ref (0x%08x)\\n\",\n\t\t\tje32_to_cpu(n.totlen), freed_len);\n\t\tgoto out_erase_sem;\n\t}\n\tif (!(je16_to_cpu(n.nodetype) & JFFS2_NODE_ACCURATE)) {\n\t\tjffs2_dbg(1, \"Node at 0x%08x was already marked obsolete (nodetype 0x%04x)\\n\",\n\t\t\t  ref_offset(ref), je16_to_cpu(n.nodetype));\n\t\tgoto out_erase_sem;\n\t}\n\t \n\tn.nodetype = cpu_to_je16(je16_to_cpu(n.nodetype) & ~JFFS2_NODE_ACCURATE);\n\tret = jffs2_flash_write(c, ref_offset(ref), sizeof(n), &retlen, (char *)&n);\n\tif (ret) {\n\t\tpr_warn(\"Write error in obliterating obsoleted node at 0x%08x: %d\\n\",\n\t\t\tref_offset(ref), ret);\n\t\tgoto out_erase_sem;\n\t}\n\tif (retlen != sizeof(n)) {\n\t\tpr_warn(\"Short write in obliterating obsoleted node at 0x%08x: %zd\\n\",\n\t\t\tref_offset(ref), retlen);\n\t\tgoto out_erase_sem;\n\t}\n\n\t \n\tif (ref->next_in_ino) {\n\t\tstruct jffs2_inode_cache *ic;\n\t\tstruct jffs2_raw_node_ref **p;\n\n\t\tspin_lock(&c->erase_completion_lock);\n\n\t\tic = jffs2_raw_ref_to_ic(ref);\n\t\tfor (p = &ic->nodes; (*p) != ref; p = &((*p)->next_in_ino))\n\t\t\t;\n\n\t\t*p = ref->next_in_ino;\n\t\tref->next_in_ino = NULL;\n\n\t\tswitch (ic->class) {\n#ifdef CONFIG_JFFS2_FS_XATTR\n\t\t\tcase RAWNODE_CLASS_XATTR_DATUM:\n\t\t\t\tjffs2_release_xattr_datum(c, (struct jffs2_xattr_datum *)ic);\n\t\t\t\tbreak;\n\t\t\tcase RAWNODE_CLASS_XATTR_REF:\n\t\t\t\tjffs2_release_xattr_ref(c, (struct jffs2_xattr_ref *)ic);\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\tif (ic->nodes == (void *)ic && ic->pino_nlink == 0)\n\t\t\t\t\tjffs2_del_ino_cache(c, ic);\n\t\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&c->erase_completion_lock);\n\t}\n\n out_erase_sem:\n\tmutex_unlock(&c->erase_free_sem);\n}\n\nint jffs2_thread_should_wake(struct jffs2_sb_info *c)\n{\n\tint ret = 0;\n\tuint32_t dirty;\n\tint nr_very_dirty = 0;\n\tstruct jffs2_eraseblock *jeb;\n\n\tif (!list_empty(&c->erase_complete_list) ||\n\t    !list_empty(&c->erase_pending_list))\n\t\treturn 1;\n\n\tif (c->unchecked_size) {\n\t\tjffs2_dbg(1, \"jffs2_thread_should_wake(): unchecked_size %d, check_ino #%d\\n\",\n\t\t\t  c->unchecked_size, c->check_ino);\n\t\treturn 1;\n\t}\n\n\t \n\tdirty = c->dirty_size + c->erasing_size - c->nr_erasing_blocks * c->sector_size;\n\n\tif (c->nr_free_blocks + c->nr_erasing_blocks < c->resv_blocks_gctrigger &&\n\t\t\t(dirty > c->nospc_dirty_size))\n\t\tret = 1;\n\n\tlist_for_each_entry(jeb, &c->very_dirty_list, list) {\n\t\tnr_very_dirty++;\n\t\tif (nr_very_dirty == c->vdirty_blocks_gctrigger) {\n\t\t\tret = 1;\n\t\t\t \n\t\t\tD1(continue);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tjffs2_dbg(1, \"%s(): nr_free_blocks %d, nr_erasing_blocks %d, dirty_size 0x%x, vdirty_blocks %d: %s\\n\",\n\t\t  __func__, c->nr_free_blocks, c->nr_erasing_blocks,\n\t\t  c->dirty_size, nr_very_dirty, ret ? \"yes\" : \"no\");\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}