{
  "module_name": "compr_zlib.c",
  "hash_id": "30142b04c0f5772a19a4410a580427b7dd0350c183ed939479073e36a5bd8fde",
  "original_prompt": "Ingested from linux-6.6.14/fs/jffs2/compr_zlib.c",
  "human_readable_source": " \n\n#if !defined(__KERNEL__) && !defined(__ECOS)\n#error \"The userspace support got too messy and was removed. Update your mkfs.jffs2\"\n#endif\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/zlib.h>\n#include <linux/zutil.h>\n#include \"nodelist.h\"\n#include \"compr.h\"\n\n\t \n#define STREAM_END_SPACE 12\n\nstatic DEFINE_MUTEX(deflate_mutex);\nstatic DEFINE_MUTEX(inflate_mutex);\nstatic z_stream inf_strm, def_strm;\n\n#ifdef __KERNEL__  \n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n\nstatic int __init alloc_workspaces(void)\n{\n\tdef_strm.workspace = vmalloc(zlib_deflate_workspacesize(MAX_WBITS,\n\t\t\t\t\t\t\tMAX_MEM_LEVEL));\n\tif (!def_strm.workspace)\n\t\treturn -ENOMEM;\n\n\tjffs2_dbg(1, \"Allocated %d bytes for deflate workspace\\n\",\n\t\t  zlib_deflate_workspacesize(MAX_WBITS, MAX_MEM_LEVEL));\n\tinf_strm.workspace = vmalloc(zlib_inflate_workspacesize());\n\tif (!inf_strm.workspace) {\n\t\tvfree(def_strm.workspace);\n\t\treturn -ENOMEM;\n\t}\n\tjffs2_dbg(1, \"Allocated %d bytes for inflate workspace\\n\",\n\t\t  zlib_inflate_workspacesize());\n\treturn 0;\n}\n\nstatic void free_workspaces(void)\n{\n\tvfree(def_strm.workspace);\n\tvfree(inf_strm.workspace);\n}\n#else\n#define alloc_workspaces() (0)\n#define free_workspaces() do { } while(0)\n#endif  \n\nstatic int jffs2_zlib_compress(unsigned char *data_in,\n\t\t\t       unsigned char *cpage_out,\n\t\t\t       uint32_t *sourcelen, uint32_t *dstlen)\n{\n\tint ret;\n\n\tif (*dstlen <= STREAM_END_SPACE)\n\t\treturn -1;\n\n\tmutex_lock(&deflate_mutex);\n\n\tif (Z_OK != zlib_deflateInit(&def_strm, 3)) {\n\t\tpr_warn(\"deflateInit failed\\n\");\n\t\tmutex_unlock(&deflate_mutex);\n\t\treturn -1;\n\t}\n\n\tdef_strm.next_in = data_in;\n\tdef_strm.total_in = 0;\n\n\tdef_strm.next_out = cpage_out;\n\tdef_strm.total_out = 0;\n\n\twhile (def_strm.total_out < *dstlen - STREAM_END_SPACE && def_strm.total_in < *sourcelen) {\n\t\tdef_strm.avail_out = *dstlen - (def_strm.total_out + STREAM_END_SPACE);\n\t\tdef_strm.avail_in = min_t(unsigned long,\n\t\t\t(*sourcelen-def_strm.total_in), def_strm.avail_out);\n\t\tjffs2_dbg(1, \"calling deflate with avail_in %ld, avail_out %ld\\n\",\n\t\t\t  def_strm.avail_in, def_strm.avail_out);\n\t\tret = zlib_deflate(&def_strm, Z_PARTIAL_FLUSH);\n\t\tjffs2_dbg(1, \"deflate returned with avail_in %ld, avail_out %ld, total_in %ld, total_out %ld\\n\",\n\t\t\t  def_strm.avail_in, def_strm.avail_out,\n\t\t\t  def_strm.total_in, def_strm.total_out);\n\t\tif (ret != Z_OK) {\n\t\t\tjffs2_dbg(1, \"deflate in loop returned %d\\n\", ret);\n\t\t\tzlib_deflateEnd(&def_strm);\n\t\t\tmutex_unlock(&deflate_mutex);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tdef_strm.avail_out += STREAM_END_SPACE;\n\tdef_strm.avail_in = 0;\n\tret = zlib_deflate(&def_strm, Z_FINISH);\n\tzlib_deflateEnd(&def_strm);\n\n\tif (ret != Z_STREAM_END) {\n\t\tjffs2_dbg(1, \"final deflate returned %d\\n\", ret);\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tif (def_strm.total_out >= def_strm.total_in) {\n\t\tjffs2_dbg(1, \"zlib compressed %ld bytes into %ld; failing\\n\",\n\t\t\t  def_strm.total_in, def_strm.total_out);\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tjffs2_dbg(1, \"zlib compressed %ld bytes into %ld\\n\",\n\t\t  def_strm.total_in, def_strm.total_out);\n\n\t*dstlen = def_strm.total_out;\n\t*sourcelen = def_strm.total_in;\n\tret = 0;\n out:\n\tmutex_unlock(&deflate_mutex);\n\treturn ret;\n}\n\nstatic int jffs2_zlib_decompress(unsigned char *data_in,\n\t\t\t\t unsigned char *cpage_out,\n\t\t\t\t uint32_t srclen, uint32_t destlen)\n{\n\tint ret;\n\tint wbits = MAX_WBITS;\n\n\tmutex_lock(&inflate_mutex);\n\n\tinf_strm.next_in = data_in;\n\tinf_strm.avail_in = srclen;\n\tinf_strm.total_in = 0;\n\n\tinf_strm.next_out = cpage_out;\n\tinf_strm.avail_out = destlen;\n\tinf_strm.total_out = 0;\n\n\t \n\tif (srclen > 2 && !(data_in[1] & PRESET_DICT) &&\n\t    ((data_in[0] & 0x0f) == Z_DEFLATED) &&\n\t    !(((data_in[0]<<8) + data_in[1]) % 31)) {\n\n\t\tjffs2_dbg(2, \"inflate skipping adler32\\n\");\n\t\twbits = -((data_in[0] >> 4) + 8);\n\t\tinf_strm.next_in += 2;\n\t\tinf_strm.avail_in -= 2;\n\t} else {\n\t\t \n\t\tjffs2_dbg(1, \"inflate not skipping adler32\\n\");\n\t}\n\n\n\tif (Z_OK != zlib_inflateInit2(&inf_strm, wbits)) {\n\t\tpr_warn(\"inflateInit failed\\n\");\n\t\tmutex_unlock(&inflate_mutex);\n\t\treturn 1;\n\t}\n\n\twhile((ret = zlib_inflate(&inf_strm, Z_FINISH)) == Z_OK)\n\t\t;\n\tif (ret != Z_STREAM_END) {\n\t\tpr_notice(\"inflate returned %d\\n\", ret);\n\t}\n\tzlib_inflateEnd(&inf_strm);\n\tmutex_unlock(&inflate_mutex);\n\treturn 0;\n}\n\nstatic struct jffs2_compressor jffs2_zlib_comp = {\n    .priority = JFFS2_ZLIB_PRIORITY,\n    .name = \"zlib\",\n    .compr = JFFS2_COMPR_ZLIB,\n    .compress = &jffs2_zlib_compress,\n    .decompress = &jffs2_zlib_decompress,\n#ifdef JFFS2_ZLIB_DISABLED\n    .disabled = 1,\n#else\n    .disabled = 0,\n#endif\n};\n\nint __init jffs2_zlib_init(void)\n{\n    int ret;\n\n    ret = alloc_workspaces();\n    if (ret)\n\t    return ret;\n\n    ret = jffs2_register_compressor(&jffs2_zlib_comp);\n    if (ret)\n\t    free_workspaces();\n\n    return ret;\n}\n\nvoid jffs2_zlib_exit(void)\n{\n    jffs2_unregister_compressor(&jffs2_zlib_comp);\n    free_workspaces();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}