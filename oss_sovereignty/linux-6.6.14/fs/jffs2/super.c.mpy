{
  "module_name": "super.c",
  "hash_id": "32af47b463f28034a1e969e6df9db1513bf135a6472236b3372c31bd5ddae73a",
  "original_prompt": "Ingested from linux-6.6.14/fs/jffs2/super.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/err.h>\n#include <linux/mount.h>\n#include <linux/fs_context.h>\n#include <linux/fs_parser.h>\n#include <linux/jffs2.h>\n#include <linux/pagemap.h>\n#include <linux/mtd/super.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/exportfs.h>\n#include \"compr.h\"\n#include \"nodelist.h\"\n\nstatic void jffs2_put_super(struct super_block *);\n\nstatic struct kmem_cache *jffs2_inode_cachep;\n\nstatic struct inode *jffs2_alloc_inode(struct super_block *sb)\n{\n\tstruct jffs2_inode_info *f;\n\n\tf = alloc_inode_sb(sb, jffs2_inode_cachep, GFP_KERNEL);\n\tif (!f)\n\t\treturn NULL;\n\treturn &f->vfs_inode;\n}\n\nstatic void jffs2_free_inode(struct inode *inode)\n{\n\tstruct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);\n\n\tkfree(f->target);\n\tkmem_cache_free(jffs2_inode_cachep, f);\n}\n\nstatic void jffs2_i_init_once(void *foo)\n{\n\tstruct jffs2_inode_info *f = foo;\n\n\tmutex_init(&f->sem);\n\tinode_init_once(&f->vfs_inode);\n}\n\nstatic const char *jffs2_compr_name(unsigned int compr)\n{\n\tswitch (compr) {\n\tcase JFFS2_COMPR_MODE_NONE:\n\t\treturn \"none\";\n#ifdef CONFIG_JFFS2_LZO\n\tcase JFFS2_COMPR_MODE_FORCELZO:\n\t\treturn \"lzo\";\n#endif\n#ifdef CONFIG_JFFS2_ZLIB\n\tcase JFFS2_COMPR_MODE_FORCEZLIB:\n\t\treturn \"zlib\";\n#endif\n\tdefault:\n\t\t \n\t\tWARN_ON(1);\n\t\treturn \"\";\n\t}\n}\n\nstatic int jffs2_show_options(struct seq_file *s, struct dentry *root)\n{\n\tstruct jffs2_sb_info *c = JFFS2_SB_INFO(root->d_sb);\n\tstruct jffs2_mount_opts *opts = &c->mount_opts;\n\n\tif (opts->override_compr)\n\t\tseq_printf(s, \",compr=%s\", jffs2_compr_name(opts->compr));\n\tif (opts->set_rp_size)\n\t\tseq_printf(s, \",rp_size=%u\", opts->rp_size / 1024);\n\n\treturn 0;\n}\n\nstatic int jffs2_sync_fs(struct super_block *sb, int wait)\n{\n\tstruct jffs2_sb_info *c = JFFS2_SB_INFO(sb);\n\n#ifdef CONFIG_JFFS2_FS_WRITEBUFFER\n\tif (jffs2_is_writebuffered(c))\n\t\tcancel_delayed_work_sync(&c->wbuf_dwork);\n#endif\n\n\tmutex_lock(&c->alloc_sem);\n\tjffs2_flush_wbuf_pad(c);\n\tmutex_unlock(&c->alloc_sem);\n\treturn 0;\n}\n\nstatic struct inode *jffs2_nfs_get_inode(struct super_block *sb, uint64_t ino,\n\t\t\t\t\t uint32_t generation)\n{\n\t \n\treturn jffs2_iget(sb, ino);\n}\n\nstatic struct dentry *jffs2_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\t\t\t\t int fh_len, int fh_type)\n{\n        return generic_fh_to_dentry(sb, fid, fh_len, fh_type,\n                                    jffs2_nfs_get_inode);\n}\n\nstatic struct dentry *jffs2_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\t\t\t\t int fh_len, int fh_type)\n{\n        return generic_fh_to_parent(sb, fid, fh_len, fh_type,\n                                    jffs2_nfs_get_inode);\n}\n\nstatic struct dentry *jffs2_get_parent(struct dentry *child)\n{\n\tstruct jffs2_inode_info *f;\n\tuint32_t pino;\n\n\tBUG_ON(!d_is_dir(child));\n\n\tf = JFFS2_INODE_INFO(d_inode(child));\n\n\tpino = f->inocache->pino_nlink;\n\n\tJFFS2_DEBUG(\"Parent of directory ino #%u is #%u\\n\",\n\t\t    f->inocache->ino, pino);\n\n\treturn d_obtain_alias(jffs2_iget(child->d_sb, pino));\n}\n\nstatic const struct export_operations jffs2_export_ops = {\n\t.get_parent = jffs2_get_parent,\n\t.fh_to_dentry = jffs2_fh_to_dentry,\n\t.fh_to_parent = jffs2_fh_to_parent,\n};\n\n \nenum {\n\tOpt_override_compr,\n\tOpt_rp_size,\n};\n\nstatic const struct constant_table jffs2_param_compr[] = {\n\t{\"none\",\tJFFS2_COMPR_MODE_NONE },\n#ifdef CONFIG_JFFS2_LZO\n\t{\"lzo\",\t\tJFFS2_COMPR_MODE_FORCELZO },\n#endif\n#ifdef CONFIG_JFFS2_ZLIB\n\t{\"zlib\",\tJFFS2_COMPR_MODE_FORCEZLIB },\n#endif\n\t{}\n};\n\nstatic const struct fs_parameter_spec jffs2_fs_parameters[] = {\n\tfsparam_enum\t(\"compr\",\tOpt_override_compr, jffs2_param_compr),\n\tfsparam_u32\t(\"rp_size\",\tOpt_rp_size),\n\t{}\n};\n\nstatic int jffs2_parse_param(struct fs_context *fc, struct fs_parameter *param)\n{\n\tstruct fs_parse_result result;\n\tstruct jffs2_sb_info *c = fc->s_fs_info;\n\tint opt;\n\n\topt = fs_parse(fc, jffs2_fs_parameters, param, &result);\n\tif (opt < 0)\n\t\treturn opt;\n\n\tswitch (opt) {\n\tcase Opt_override_compr:\n\t\tc->mount_opts.compr = result.uint_32;\n\t\tc->mount_opts.override_compr = true;\n\t\tbreak;\n\tcase Opt_rp_size:\n\t\tif (result.uint_32 > UINT_MAX / 1024)\n\t\t\treturn invalf(fc, \"jffs2: rp_size unrepresentable\");\n\t\tc->mount_opts.rp_size = result.uint_32 * 1024;\n\t\tc->mount_opts.set_rp_size = true;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic inline void jffs2_update_mount_opts(struct fs_context *fc)\n{\n\tstruct jffs2_sb_info *new_c = fc->s_fs_info;\n\tstruct jffs2_sb_info *c = JFFS2_SB_INFO(fc->root->d_sb);\n\n\tmutex_lock(&c->alloc_sem);\n\tif (new_c->mount_opts.override_compr) {\n\t\tc->mount_opts.override_compr = new_c->mount_opts.override_compr;\n\t\tc->mount_opts.compr = new_c->mount_opts.compr;\n\t}\n\tif (new_c->mount_opts.set_rp_size) {\n\t\tc->mount_opts.set_rp_size = new_c->mount_opts.set_rp_size;\n\t\tc->mount_opts.rp_size = new_c->mount_opts.rp_size;\n\t}\n\tmutex_unlock(&c->alloc_sem);\n}\n\nstatic int jffs2_reconfigure(struct fs_context *fc)\n{\n\tstruct super_block *sb = fc->root->d_sb;\n\n\tsync_filesystem(sb);\n\tjffs2_update_mount_opts(fc);\n\n\treturn jffs2_do_remount_fs(sb, fc);\n}\n\nstatic const struct super_operations jffs2_super_operations =\n{\n\t.alloc_inode =\tjffs2_alloc_inode,\n\t.free_inode =\tjffs2_free_inode,\n\t.put_super =\tjffs2_put_super,\n\t.statfs =\tjffs2_statfs,\n\t.evict_inode =\tjffs2_evict_inode,\n\t.dirty_inode =\tjffs2_dirty_inode,\n\t.show_options =\tjffs2_show_options,\n\t.sync_fs =\tjffs2_sync_fs,\n};\n\n \nstatic int jffs2_fill_super(struct super_block *sb, struct fs_context *fc)\n{\n\tstruct jffs2_sb_info *c = sb->s_fs_info;\n\n\tjffs2_dbg(1, \"jffs2_get_sb_mtd():\"\n\t\t  \" New superblock for device %d (\\\"%s\\\")\\n\",\n\t\t  sb->s_mtd->index, sb->s_mtd->name);\n\n\tc->mtd = sb->s_mtd;\n\tc->os_priv = sb;\n\n\tif (c->mount_opts.rp_size > c->mtd->size)\n\t\treturn invalf(fc, \"jffs2: Too large reserve pool specified, max is %llu KB\",\n\t\t\t      c->mtd->size / 1024);\n\n\t \n\tmutex_init(&c->alloc_sem);\n\tmutex_init(&c->erase_free_sem);\n\tinit_waitqueue_head(&c->erase_wait);\n\tinit_waitqueue_head(&c->inocache_wq);\n\tspin_lock_init(&c->erase_completion_lock);\n\tspin_lock_init(&c->inocache_lock);\n\n\tsb->s_op = &jffs2_super_operations;\n\tsb->s_export_op = &jffs2_export_ops;\n\tsb->s_flags = sb->s_flags | SB_NOATIME;\n\tsb->s_xattr = jffs2_xattr_handlers;\n#ifdef CONFIG_JFFS2_FS_POSIX_ACL\n\tsb->s_flags |= SB_POSIXACL;\n#endif\n\treturn jffs2_do_fill_super(sb, fc);\n}\n\nstatic int jffs2_get_tree(struct fs_context *fc)\n{\n\treturn get_tree_mtd(fc, jffs2_fill_super);\n}\n\nstatic void jffs2_free_fc(struct fs_context *fc)\n{\n\tkfree(fc->s_fs_info);\n}\n\nstatic const struct fs_context_operations jffs2_context_ops = {\n\t.free\t\t= jffs2_free_fc,\n\t.parse_param\t= jffs2_parse_param,\n\t.get_tree\t= jffs2_get_tree,\n\t.reconfigure\t= jffs2_reconfigure,\n};\n\nstatic int jffs2_init_fs_context(struct fs_context *fc)\n{\n\tstruct jffs2_sb_info *ctx;\n\n\tctx = kzalloc(sizeof(struct jffs2_sb_info), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tfc->s_fs_info = ctx;\n\tfc->ops = &jffs2_context_ops;\n\treturn 0;\n}\n\nstatic void jffs2_put_super (struct super_block *sb)\n{\n\tstruct jffs2_sb_info *c = JFFS2_SB_INFO(sb);\n\n\tjffs2_dbg(2, \"%s()\\n\", __func__);\n\n\tmutex_lock(&c->alloc_sem);\n\tjffs2_flush_wbuf_pad(c);\n\tmutex_unlock(&c->alloc_sem);\n\n\tjffs2_sum_exit(c);\n\n\tjffs2_free_ino_caches(c);\n\tjffs2_free_raw_node_refs(c);\n\tkvfree(c->blocks);\n\tjffs2_flash_cleanup(c);\n\tkfree(c->inocache_list);\n\tjffs2_clear_xattr_subsystem(c);\n\tmtd_sync(c->mtd);\n\tjffs2_dbg(1, \"%s(): returning\\n\", __func__);\n}\n\nstatic void jffs2_kill_sb(struct super_block *sb)\n{\n\tstruct jffs2_sb_info *c = JFFS2_SB_INFO(sb);\n\tif (c && !sb_rdonly(sb))\n\t\tjffs2_stop_garbage_collect_thread(c);\n\tkill_mtd_super(sb);\n\tkfree(c);\n}\n\nstatic struct file_system_type jffs2_fs_type = {\n\t.owner =\tTHIS_MODULE,\n\t.name =\t\t\"jffs2\",\n\t.init_fs_context = jffs2_init_fs_context,\n\t.parameters =\tjffs2_fs_parameters,\n\t.kill_sb =\tjffs2_kill_sb,\n};\nMODULE_ALIAS_FS(\"jffs2\");\n\nstatic int __init init_jffs2_fs(void)\n{\n\tint ret;\n\n\t \n\tBUILD_BUG_ON(sizeof(struct jffs2_unknown_node) != 12);\n\tBUILD_BUG_ON(sizeof(struct jffs2_raw_dirent) != 40);\n\tBUILD_BUG_ON(sizeof(struct jffs2_raw_inode) != 68);\n\tBUILD_BUG_ON(sizeof(struct jffs2_raw_summary) != 32);\n\n\tpr_info(\"version 2.2.\"\n#ifdef CONFIG_JFFS2_FS_WRITEBUFFER\n\t       \" (NAND)\"\n#endif\n#ifdef CONFIG_JFFS2_SUMMARY\n\t       \" (SUMMARY) \"\n#endif\n\t       \" \u00a9 2001-2006 Red Hat, Inc.\\n\");\n\n\tjffs2_inode_cachep = kmem_cache_create(\"jffs2_i\",\n\t\t\t\t\t     sizeof(struct jffs2_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD|SLAB_ACCOUNT),\n\t\t\t\t\t     jffs2_i_init_once);\n\tif (!jffs2_inode_cachep) {\n\t\tpr_err(\"error: Failed to initialise inode cache\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tret = jffs2_compressors_init();\n\tif (ret) {\n\t\tpr_err(\"error: Failed to initialise compressors\\n\");\n\t\tgoto out;\n\t}\n\tret = jffs2_create_slab_caches();\n\tif (ret) {\n\t\tpr_err(\"error: Failed to initialise slab caches\\n\");\n\t\tgoto out_compressors;\n\t}\n\tret = register_filesystem(&jffs2_fs_type);\n\tif (ret) {\n\t\tpr_err(\"error: Failed to register filesystem\\n\");\n\t\tgoto out_slab;\n\t}\n\treturn 0;\n\n out_slab:\n\tjffs2_destroy_slab_caches();\n out_compressors:\n\tjffs2_compressors_exit();\n out:\n\tkmem_cache_destroy(jffs2_inode_cachep);\n\treturn ret;\n}\n\nstatic void __exit exit_jffs2_fs(void)\n{\n\tunregister_filesystem(&jffs2_fs_type);\n\tjffs2_destroy_slab_caches();\n\tjffs2_compressors_exit();\n\n\t \n\trcu_barrier();\n\tkmem_cache_destroy(jffs2_inode_cachep);\n}\n\nmodule_init(init_jffs2_fs);\nmodule_exit(exit_jffs2_fs);\n\nMODULE_DESCRIPTION(\"The Journalling Flash File System, v2\");\nMODULE_AUTHOR(\"Red Hat, Inc.\");\nMODULE_LICENSE(\"GPL\"); \n\t\t       \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}