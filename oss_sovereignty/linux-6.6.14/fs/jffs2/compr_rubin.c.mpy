{
  "module_name": "compr_rubin.c",
  "hash_id": "6658e658afc241614274d56617ebc7bc06212c39fcefa591edf5fda50a51d23c",
  "original_prompt": "Ingested from linux-6.6.14/fs/jffs2/compr_rubin.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/jffs2.h>\n#include <linux/errno.h>\n#include \"compr.h\"\n\n\n#define RUBIN_REG_SIZE   16\n#define UPPER_BIT_RUBIN    (((long) 1)<<(RUBIN_REG_SIZE-1))\n#define LOWER_BITS_RUBIN   ((((long) 1)<<(RUBIN_REG_SIZE-1))-1)\n\n\n#define BIT_DIVIDER_MIPS 1043\nstatic int bits_mips[8] = { 277, 249, 290, 267, 229, 341, 212, 241};\n\nstruct pushpull {\n\tunsigned char *buf;\n\tunsigned int buflen;\n\tunsigned int ofs;\n\tunsigned int reserve;\n};\n\nstruct rubin_state {\n\tunsigned long p;\n\tunsigned long q;\n\tunsigned long rec_q;\n\tlong bit_number;\n\tstruct pushpull pp;\n\tint bit_divider;\n\tint bits[8];\n};\n\nstatic inline void init_pushpull(struct pushpull *pp, char *buf,\n\t\t\t\t unsigned buflen, unsigned ofs,\n\t\t\t\t unsigned reserve)\n{\n\tpp->buf = buf;\n\tpp->buflen = buflen;\n\tpp->ofs = ofs;\n\tpp->reserve = reserve;\n}\n\nstatic inline int pushbit(struct pushpull *pp, int bit, int use_reserved)\n{\n\tif (pp->ofs >= pp->buflen - (use_reserved?0:pp->reserve))\n\t\treturn -ENOSPC;\n\n\tif (bit)\n\t\tpp->buf[pp->ofs >> 3] |= (1<<(7-(pp->ofs & 7)));\n\telse\n\t\tpp->buf[pp->ofs >> 3] &= ~(1<<(7-(pp->ofs & 7)));\n\n\tpp->ofs++;\n\n\treturn 0;\n}\n\nstatic inline int pushedbits(struct pushpull *pp)\n{\n\treturn pp->ofs;\n}\n\nstatic inline int pullbit(struct pushpull *pp)\n{\n\tint bit;\n\n\tbit = (pp->buf[pp->ofs >> 3] >> (7-(pp->ofs & 7))) & 1;\n\n\tpp->ofs++;\n\treturn bit;\n}\n\n\nstatic void init_rubin(struct rubin_state *rs, int div, int *bits)\n{\n\tint c;\n\n\trs->q = 0;\n\trs->p = (long) (2 * UPPER_BIT_RUBIN);\n\trs->bit_number = (long) 0;\n\trs->bit_divider = div;\n\n\tfor (c=0; c<8; c++)\n\t\trs->bits[c] = bits[c];\n}\n\n\nstatic int encode(struct rubin_state *rs, long A, long B, int symbol)\n{\n\n\tlong i0, i1;\n\tint ret;\n\n\twhile ((rs->q >= UPPER_BIT_RUBIN) ||\n\t       ((rs->p + rs->q) <= UPPER_BIT_RUBIN)) {\n\t\trs->bit_number++;\n\n\t\tret = pushbit(&rs->pp, (rs->q & UPPER_BIT_RUBIN) ? 1 : 0, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\trs->q &= LOWER_BITS_RUBIN;\n\t\trs->q <<= 1;\n\t\trs->p <<= 1;\n\t}\n\ti0 = A * rs->p / (A + B);\n\tif (i0 <= 0)\n\t\ti0 = 1;\n\n\tif (i0 >= rs->p)\n\t\ti0 = rs->p - 1;\n\n\ti1 = rs->p - i0;\n\n\tif (symbol == 0)\n\t\trs->p = i0;\n\telse {\n\t\trs->p = i1;\n\t\trs->q += i0;\n\t}\n\treturn 0;\n}\n\n\nstatic void end_rubin(struct rubin_state *rs)\n{\n\n\tint i;\n\n\tfor (i = 0; i < RUBIN_REG_SIZE; i++) {\n\t\tpushbit(&rs->pp, (UPPER_BIT_RUBIN & rs->q) ? 1 : 0, 1);\n\t\trs->q &= LOWER_BITS_RUBIN;\n\t\trs->q <<= 1;\n\t}\n}\n\n\nstatic void init_decode(struct rubin_state *rs, int div, int *bits)\n{\n\tinit_rubin(rs, div, bits);\n\n\t \n\trs->rec_q = 0;\n\n\tfor (rs->bit_number = 0; rs->bit_number++ < RUBIN_REG_SIZE;\n\t     rs->rec_q = rs->rec_q * 2 + (long) (pullbit(&rs->pp)))\n\t\t;\n}\n\nstatic void __do_decode(struct rubin_state *rs, unsigned long p,\n\t\t\tunsigned long q)\n{\n\tregister unsigned long lower_bits_rubin = LOWER_BITS_RUBIN;\n\tunsigned long rec_q;\n\tint c, bits = 0;\n\n\t \n\tdo {\n\t\tbits++;\n\t\tq &= lower_bits_rubin;\n\t\tq <<= 1;\n\t\tp <<= 1;\n\t} while ((q >= UPPER_BIT_RUBIN) || ((p + q) <= UPPER_BIT_RUBIN));\n\n\trs->p = p;\n\trs->q = q;\n\n\trs->bit_number += bits;\n\n\t \n\trec_q = rs->rec_q;\n\tdo {\n\t\tc = pullbit(&rs->pp);\n\t\trec_q &= lower_bits_rubin;\n\t\trec_q <<= 1;\n\t\trec_q += c;\n\t} while (--bits);\n\trs->rec_q = rec_q;\n}\n\nstatic int decode(struct rubin_state *rs, long A, long B)\n{\n\tunsigned long p = rs->p, q = rs->q;\n\tlong i0, threshold;\n\tint symbol;\n\n\tif (q >= UPPER_BIT_RUBIN || ((p + q) <= UPPER_BIT_RUBIN))\n\t\t__do_decode(rs, p, q);\n\n\ti0 = A * rs->p / (A + B);\n\tif (i0 <= 0)\n\t\ti0 = 1;\n\n\tif (i0 >= rs->p)\n\t\ti0 = rs->p - 1;\n\n\tthreshold = rs->q + i0;\n\tsymbol = rs->rec_q >= threshold;\n\tif (rs->rec_q >= threshold) {\n\t\trs->q += i0;\n\t\ti0 = rs->p - i0;\n\t}\n\n\trs->p = i0;\n\n\treturn symbol;\n}\n\n\n\nstatic int out_byte(struct rubin_state *rs, unsigned char byte)\n{\n\tint i, ret;\n\tstruct rubin_state rs_copy;\n\trs_copy = *rs;\n\n\tfor (i=0; i<8; i++) {\n\t\tret = encode(rs, rs->bit_divider-rs->bits[i],\n\t\t\t     rs->bits[i], byte & 1);\n\t\tif (ret) {\n\t\t\t \n\t\t\t*rs = rs_copy;\n\t\t\treturn ret;\n\t\t}\n\t\tbyte >>= 1 ;\n\t}\n\treturn 0;\n}\n\nstatic int in_byte(struct rubin_state *rs)\n{\n\tint i, result = 0, bit_divider = rs->bit_divider;\n\n\tfor (i = 0; i < 8; i++)\n\t\tresult |= decode(rs, bit_divider - rs->bits[i],\n\t\t\t\t rs->bits[i]) << i;\n\n\treturn result;\n}\n\n\n\nstatic int rubin_do_compress(int bit_divider, int *bits, unsigned char *data_in,\n\t\t\t     unsigned char *cpage_out, uint32_t *sourcelen,\n\t\t\t     uint32_t *dstlen)\n\t{\n\tint outpos = 0;\n\tint pos=0;\n\tstruct rubin_state rs;\n\n\tinit_pushpull(&rs.pp, cpage_out, *dstlen * 8, 0, 32);\n\n\tinit_rubin(&rs, bit_divider, bits);\n\n\twhile (pos < (*sourcelen) && !out_byte(&rs, data_in[pos]))\n\t\tpos++;\n\n\tend_rubin(&rs);\n\n\tif (outpos > pos) {\n\t\t \n\t\treturn -1;\n\t}\n\n\t \n\n\toutpos = (pushedbits(&rs.pp)+7)/8;\n\n\tif (outpos >= pos)\n\t\treturn -1;  \n\t*sourcelen = pos;\n\t*dstlen = outpos;\n\treturn 0;\n}\n#if 0\n \nint jffs2_rubinmips_compress(unsigned char *data_in, unsigned char *cpage_out,\n\t\t   uint32_t *sourcelen, uint32_t *dstlen)\n{\n\treturn rubin_do_compress(BIT_DIVIDER_MIPS, bits_mips, data_in,\n\t\t\t\t cpage_out, sourcelen, dstlen);\n}\n#endif\nstatic int jffs2_dynrubin_compress(unsigned char *data_in,\n\t\t\t\t   unsigned char *cpage_out,\n\t\t\t\t   uint32_t *sourcelen, uint32_t *dstlen)\n{\n\tint bits[8];\n\tunsigned char histo[256];\n\tint i;\n\tint ret;\n\tuint32_t mysrclen, mydstlen;\n\n\tmysrclen = *sourcelen;\n\tmydstlen = *dstlen - 8;\n\n\tif (*dstlen <= 12)\n\t\treturn -1;\n\n\tmemset(histo, 0, 256);\n\tfor (i=0; i<mysrclen; i++)\n\t\thisto[data_in[i]]++;\n\tmemset(bits, 0, sizeof(int)*8);\n\tfor (i=0; i<256; i++) {\n\t\tif (i&128)\n\t\t\tbits[7] += histo[i];\n\t\tif (i&64)\n\t\t\tbits[6] += histo[i];\n\t\tif (i&32)\n\t\t\tbits[5] += histo[i];\n\t\tif (i&16)\n\t\t\tbits[4] += histo[i];\n\t\tif (i&8)\n\t\t\tbits[3] += histo[i];\n\t\tif (i&4)\n\t\t\tbits[2] += histo[i];\n\t\tif (i&2)\n\t\t\tbits[1] += histo[i];\n\t\tif (i&1)\n\t\t\tbits[0] += histo[i];\n\t}\n\n\tfor (i=0; i<8; i++) {\n\t\tbits[i] = (bits[i] * 256) / mysrclen;\n\t\tif (!bits[i]) bits[i] = 1;\n\t\tif (bits[i] > 255) bits[i] = 255;\n\t\tcpage_out[i] = bits[i];\n\t}\n\n\tret = rubin_do_compress(256, bits, data_in, cpage_out+8, &mysrclen,\n\t\t\t\t&mydstlen);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmydstlen += 8;\n\n\tif (mysrclen <= mydstlen) {\n\t\t \n\t\treturn -1;\n\t}\n\n\t*sourcelen = mysrclen;\n\t*dstlen = mydstlen;\n\treturn 0;\n}\n\nstatic void rubin_do_decompress(int bit_divider, int *bits,\n\t\t\t\tunsigned char *cdata_in, \n\t\t\t\tunsigned char *page_out, uint32_t srclen,\n\t\t\t\tuint32_t destlen)\n{\n\tint outpos = 0;\n\tstruct rubin_state rs;\n\n\tinit_pushpull(&rs.pp, cdata_in, srclen, 0, 0);\n\tinit_decode(&rs, bit_divider, bits);\n\n\twhile (outpos < destlen)\n\t\tpage_out[outpos++] = in_byte(&rs);\n}\n\n\nstatic int jffs2_rubinmips_decompress(unsigned char *data_in,\n\t\t\t\t      unsigned char *cpage_out,\n\t\t\t\t      uint32_t sourcelen, uint32_t dstlen)\n{\n\trubin_do_decompress(BIT_DIVIDER_MIPS, bits_mips, data_in,\n\t\t\t    cpage_out, sourcelen, dstlen);\n\treturn 0;\n}\n\nstatic int jffs2_dynrubin_decompress(unsigned char *data_in,\n\t\t\t\t     unsigned char *cpage_out,\n\t\t\t\t     uint32_t sourcelen, uint32_t dstlen)\n{\n\tint bits[8];\n\tint c;\n\n\tfor (c=0; c<8; c++)\n\t\tbits[c] = data_in[c];\n\n\trubin_do_decompress(256, bits, data_in+8, cpage_out, sourcelen-8,\n\t\t\t    dstlen);\n\treturn 0;\n}\n\nstatic struct jffs2_compressor jffs2_rubinmips_comp = {\n\t.priority = JFFS2_RUBINMIPS_PRIORITY,\n\t.name = \"rubinmips\",\n\t.compr = JFFS2_COMPR_DYNRUBIN,\n\t.compress = NULL,  \n\t.decompress = &jffs2_rubinmips_decompress,\n#ifdef JFFS2_RUBINMIPS_DISABLED\n\t.disabled = 1,\n#else\n\t.disabled = 0,\n#endif\n};\n\nint jffs2_rubinmips_init(void)\n{\n\treturn jffs2_register_compressor(&jffs2_rubinmips_comp);\n}\n\nvoid jffs2_rubinmips_exit(void)\n{\n\tjffs2_unregister_compressor(&jffs2_rubinmips_comp);\n}\n\nstatic struct jffs2_compressor jffs2_dynrubin_comp = {\n\t.priority = JFFS2_DYNRUBIN_PRIORITY,\n\t.name = \"dynrubin\",\n\t.compr = JFFS2_COMPR_RUBINMIPS,\n\t.compress = jffs2_dynrubin_compress,\n\t.decompress = &jffs2_dynrubin_decompress,\n#ifdef JFFS2_DYNRUBIN_DISABLED\n\t.disabled = 1,\n#else\n\t.disabled = 0,\n#endif\n};\n\nint jffs2_dynrubin_init(void)\n{\n\treturn jffs2_register_compressor(&jffs2_dynrubin_comp);\n}\n\nvoid jffs2_dynrubin_exit(void)\n{\n\tjffs2_unregister_compressor(&jffs2_dynrubin_comp);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}