{
  "module_name": "gc.c",
  "hash_id": "3c5898d4de5741fce8adf230f9d8912fc654fb149d2ecf564417839e5b6422f6",
  "original_prompt": "Ingested from linux-6.6.14/fs/jffs2/gc.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/mtd/mtd.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/crc32.h>\n#include <linux/compiler.h>\n#include <linux/stat.h>\n#include \"nodelist.h\"\n#include \"compr.h\"\n\nstatic int jffs2_garbage_collect_pristine(struct jffs2_sb_info *c,\n\t\t\t\t\t  struct jffs2_inode_cache *ic,\n\t\t\t\t\t  struct jffs2_raw_node_ref *raw);\nstatic int jffs2_garbage_collect_metadata(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t\tstruct jffs2_inode_info *f, struct jffs2_full_dnode *fd);\nstatic int jffs2_garbage_collect_dirent(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t\tstruct jffs2_inode_info *f, struct jffs2_full_dirent *fd);\nstatic int jffs2_garbage_collect_deletion_dirent(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t\tstruct jffs2_inode_info *f, struct jffs2_full_dirent *fd);\nstatic int jffs2_garbage_collect_hole(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t      struct jffs2_inode_info *f, struct jffs2_full_dnode *fn,\n\t\t\t\t      uint32_t start, uint32_t end);\nstatic int jffs2_garbage_collect_dnode(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t       struct jffs2_inode_info *f, struct jffs2_full_dnode *fn,\n\t\t\t\t       uint32_t start, uint32_t end);\nstatic int jffs2_garbage_collect_live(struct jffs2_sb_info *c,  struct jffs2_eraseblock *jeb,\n\t\t\t       struct jffs2_raw_node_ref *raw, struct jffs2_inode_info *f);\n\n \nstatic struct jffs2_eraseblock *jffs2_find_gc_block(struct jffs2_sb_info *c)\n{\n\tstruct jffs2_eraseblock *ret;\n\tstruct list_head *nextlist = NULL;\n\tint n = jiffies % 128;\n\n\t \n\t \nagain:\n\tif (!list_empty(&c->bad_used_list) && c->nr_free_blocks > c->resv_blocks_gcbad) {\n\t\tjffs2_dbg(1, \"Picking block from bad_used_list to GC next\\n\");\n\t\tnextlist = &c->bad_used_list;\n\t} else if (n < 50 && !list_empty(&c->erasable_list)) {\n\t\t \n\t\tjffs2_dbg(1, \"Picking block from erasable_list to GC next\\n\");\n\t\tnextlist = &c->erasable_list;\n\t} else if (n < 110 && !list_empty(&c->very_dirty_list)) {\n\t\t \n\t\tjffs2_dbg(1, \"Picking block from very_dirty_list to GC next\\n\");\n\t\tnextlist = &c->very_dirty_list;\n\t} else if (n < 126 && !list_empty(&c->dirty_list)) {\n\t\tjffs2_dbg(1, \"Picking block from dirty_list to GC next\\n\");\n\t\tnextlist = &c->dirty_list;\n\t} else if (!list_empty(&c->clean_list)) {\n\t\tjffs2_dbg(1, \"Picking block from clean_list to GC next\\n\");\n\t\tnextlist = &c->clean_list;\n\t} else if (!list_empty(&c->dirty_list)) {\n\t\tjffs2_dbg(1, \"Picking block from dirty_list to GC next (clean_list was empty)\\n\");\n\n\t\tnextlist = &c->dirty_list;\n\t} else if (!list_empty(&c->very_dirty_list)) {\n\t\tjffs2_dbg(1, \"Picking block from very_dirty_list to GC next (clean_list and dirty_list were empty)\\n\");\n\t\tnextlist = &c->very_dirty_list;\n\t} else if (!list_empty(&c->erasable_list)) {\n\t\tjffs2_dbg(1, \"Picking block from erasable_list to GC next (clean_list and {very_,}dirty_list were empty)\\n\");\n\n\t\tnextlist = &c->erasable_list;\n\t} else if (!list_empty(&c->erasable_pending_wbuf_list)) {\n\t\t \n\t\tjffs2_dbg(1, \"Synching wbuf in order to reuse erasable_pending_wbuf_list blocks\\n\");\n\t\tspin_unlock(&c->erase_completion_lock);\n\t\tjffs2_flush_wbuf_pad(c);\n\t\tspin_lock(&c->erase_completion_lock);\n\t\tgoto again;\n\t} else {\n\t\t \n\t\tjffs2_dbg(1, \"No clean, dirty _or_ erasable blocks to GC from! Where are they all?\\n\");\n\t\treturn NULL;\n\t}\n\n\tret = list_entry(nextlist->next, struct jffs2_eraseblock, list);\n\tlist_del(&ret->list);\n\tc->gcblock = ret;\n\tret->gc_node = ret->first_node;\n\tif (!ret->gc_node) {\n\t\tpr_warn(\"Eep. ret->gc_node for block at 0x%08x is NULL\\n\",\n\t\t\tret->offset);\n\t\tBUG();\n\t}\n\n\t \n\tif (ret->wasted_size) {\n\t\tjffs2_dbg(1, \"Converting wasted_size %08x to dirty_size\\n\",\n\t\t\t  ret->wasted_size);\n\t\tret->dirty_size += ret->wasted_size;\n\t\tc->wasted_size -= ret->wasted_size;\n\t\tc->dirty_size += ret->wasted_size;\n\t\tret->wasted_size = 0;\n\t}\n\n\treturn ret;\n}\n\n \nint jffs2_garbage_collect_pass(struct jffs2_sb_info *c)\n{\n\tstruct jffs2_inode_info *f;\n\tstruct jffs2_inode_cache *ic;\n\tstruct jffs2_eraseblock *jeb;\n\tstruct jffs2_raw_node_ref *raw;\n\tuint32_t gcblock_dirty;\n\tint ret = 0, inum, nlink;\n\tint xattr = 0;\n\n\tif (mutex_lock_interruptible(&c->alloc_sem))\n\t\treturn -EINTR;\n\n\n\tfor (;;) {\n\t\t \n\t\tint bucket, want_ino;\n\n\t\tspin_lock(&c->erase_completion_lock);\n\t\tif (!c->unchecked_size)\n\t\t\tbreak;\n\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\tif (!xattr)\n\t\t\txattr = jffs2_verify_xattr(c);\n\n\t\tspin_lock(&c->inocache_lock);\n\t\t \n\t\twant_ino = c->check_ino;\n\t\tfor (bucket = c->check_ino % c->inocache_hashsize ; bucket < c->inocache_hashsize; bucket++) {\n\t\t\tfor (ic = c->inocache_list[bucket]; ic; ic = ic->next) {\n\t\t\t\tif (ic->ino < want_ino)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (ic->state != INO_STATE_CHECKEDABSENT &&\n\t\t\t\t    ic->state != INO_STATE_PRESENT)\n\t\t\t\t\tgoto got_next;  \n\n\t\t\t\tjffs2_dbg(1, \"Skipping ino #%u already checked\\n\",\n\t\t\t\t\t  ic->ino);\n\t\t\t}\n\t\t\twant_ino = 0;\n\t\t}\n\n\t\t \n\t\tc->check_ino = ((c->highest_ino + c->inocache_hashsize + 1) &\n\t\t\t\t~c->inocache_hashsize) - 1;\n\n\t\tspin_unlock(&c->inocache_lock);\n\n\t\tpr_crit(\"Checked all inodes but still 0x%x bytes of unchecked space?\\n\",\n\t\t\tc->unchecked_size);\n\t\tjffs2_dbg_dump_block_lists_nolock(c);\n\t\tmutex_unlock(&c->alloc_sem);\n\t\treturn -ENOSPC;\n\n\tgot_next:\n\t\t \n\t\tc->check_ino = ic->ino + c->inocache_hashsize;\n\n\t\tif (!ic->pino_nlink) {\n\t\t\tjffs2_dbg(1, \"Skipping check of ino #%d with nlink/pino zero\\n\",\n\t\t\t\t  ic->ino);\n\t\t\tspin_unlock(&c->inocache_lock);\n\t\t\tjffs2_xattr_delete_inode(c, ic);\n\t\t\tcontinue;\n\t\t}\n\t\tswitch(ic->state) {\n\t\tcase INO_STATE_CHECKEDABSENT:\n\t\tcase INO_STATE_PRESENT:\n\t\t\tspin_unlock(&c->inocache_lock);\n\t\t\tcontinue;\n\n\t\tcase INO_STATE_GC:\n\t\tcase INO_STATE_CHECKING:\n\t\t\tpr_warn(\"Inode #%u is in state %d during CRC check phase!\\n\",\n\t\t\t\tic->ino, ic->state);\n\t\t\tspin_unlock(&c->inocache_lock);\n\t\t\tBUG();\n\n\t\tcase INO_STATE_READING:\n\t\t\t \n\t\t\tjffs2_dbg(1, \"Waiting for ino #%u to finish reading\\n\",\n\t\t\t\t  ic->ino);\n\t\t\t \n\t\t\tc->check_ino = ic->ino;\n\n\t\t\tmutex_unlock(&c->alloc_sem);\n\t\t\tsleep_on_spinunlock(&c->inocache_wq, &c->inocache_lock);\n\t\t\treturn 0;\n\n\t\tdefault:\n\t\t\tBUG();\n\n\t\tcase INO_STATE_UNCHECKED:\n\t\t\t;\n\t\t}\n\t\tic->state = INO_STATE_CHECKING;\n\t\tspin_unlock(&c->inocache_lock);\n\n\t\tjffs2_dbg(1, \"%s(): triggering inode scan of ino#%u\\n\",\n\t\t\t  __func__, ic->ino);\n\n\t\tret = jffs2_do_crccheck_inode(c, ic);\n\t\tif (ret)\n\t\t\tpr_warn(\"Returned error for crccheck of ino #%u. Expect badness...\\n\",\n\t\t\t\tic->ino);\n\n\t\tjffs2_set_inocache_state(c, ic, INO_STATE_CHECKEDABSENT);\n\t\tmutex_unlock(&c->alloc_sem);\n\t\treturn ret;\n\t}\n\n\t \n\tif (!list_empty(&c->erase_complete_list) ||\n\t    !list_empty(&c->erase_pending_list)) {\n\t\tspin_unlock(&c->erase_completion_lock);\n\t\tmutex_unlock(&c->alloc_sem);\n\t\tjffs2_dbg(1, \"%s(): erasing pending blocks\\n\", __func__);\n\t\tif (jffs2_erase_pending_blocks(c, 1))\n\t\t\treturn 0;\n\n\t\tjffs2_dbg(1, \"No progress from erasing block; doing GC anyway\\n\");\n\t\tmutex_lock(&c->alloc_sem);\n\t\tspin_lock(&c->erase_completion_lock);\n\t}\n\n\t \n\tjeb = c->gcblock;\n\n\tif (!jeb)\n\t\tjeb = jffs2_find_gc_block(c);\n\n\tif (!jeb) {\n\t\t \n\t\tif (c->nr_erasing_blocks) {\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\tmutex_unlock(&c->alloc_sem);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\tjffs2_dbg(1, \"Couldn't find erase block to garbage collect!\\n\");\n\t\tspin_unlock(&c->erase_completion_lock);\n\t\tmutex_unlock(&c->alloc_sem);\n\t\treturn -EIO;\n\t}\n\n\tjffs2_dbg(1, \"GC from block %08x, used_size %08x, dirty_size %08x, free_size %08x\\n\",\n\t\t  jeb->offset, jeb->used_size, jeb->dirty_size, jeb->free_size);\n\tD1(if (c->nextblock)\n\t   printk(KERN_DEBUG \"Nextblock at  %08x, used_size %08x, dirty_size %08x, wasted_size %08x, free_size %08x\\n\", c->nextblock->offset, c->nextblock->used_size, c->nextblock->dirty_size, c->nextblock->wasted_size, c->nextblock->free_size));\n\n\tif (!jeb->used_size) {\n\t\tmutex_unlock(&c->alloc_sem);\n\t\tgoto eraseit;\n\t}\n\n\traw = jeb->gc_node;\n\tgcblock_dirty = jeb->dirty_size;\n\n\twhile(ref_obsolete(raw)) {\n\t\tjffs2_dbg(1, \"Node at 0x%08x is obsolete... skipping\\n\",\n\t\t\t  ref_offset(raw));\n\t\traw = ref_next(raw);\n\t\tif (unlikely(!raw)) {\n\t\t\tpr_warn(\"eep. End of raw list while still supposedly nodes to GC\\n\");\n\t\t\tpr_warn(\"erase block at 0x%08x. free_size 0x%08x, dirty_size 0x%08x, used_size 0x%08x\\n\",\n\t\t\t\tjeb->offset, jeb->free_size,\n\t\t\t\tjeb->dirty_size, jeb->used_size);\n\t\t\tjeb->gc_node = raw;\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\tmutex_unlock(&c->alloc_sem);\n\t\t\tBUG();\n\t\t}\n\t}\n\tjeb->gc_node = raw;\n\n\tjffs2_dbg(1, \"Going to garbage collect node at 0x%08x\\n\",\n\t\t  ref_offset(raw));\n\n\tif (!raw->next_in_ino) {\n\t\t \n\t\tspin_unlock(&c->erase_completion_lock);\n\t\tif (ref_flags(raw) == REF_PRISTINE) {\n\t\t\t \n\t\t\tjffs2_garbage_collect_pristine(c, NULL, raw);\n\t\t} else {\n\t\t\t \n\t\t\tjffs2_mark_node_obsolete(c, raw);\n\t\t}\n\t\tmutex_unlock(&c->alloc_sem);\n\t\tgoto eraseit_lock;\n\t}\n\n\tic = jffs2_raw_ref_to_ic(raw);\n\n#ifdef CONFIG_JFFS2_FS_XATTR\n\t \n\tif (ic->class == RAWNODE_CLASS_XATTR_DATUM\n\t    || ic->class == RAWNODE_CLASS_XATTR_REF) {\n\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\tif (ic->class == RAWNODE_CLASS_XATTR_DATUM) {\n\t\t\tret = jffs2_garbage_collect_xattr_datum(c, (struct jffs2_xattr_datum *)ic, raw);\n\t\t} else {\n\t\t\tret = jffs2_garbage_collect_xattr_ref(c, (struct jffs2_xattr_ref *)ic, raw);\n\t\t}\n\t\tgoto test_gcnode;\n\t}\n#endif\n\n\t \n\tspin_lock(&c->inocache_lock);\n\n\tspin_unlock(&c->erase_completion_lock);\n\n\tjffs2_dbg(1, \"%s(): collecting from block @0x%08x. Node @0x%08x(%d), ino #%u\\n\",\n\t\t  __func__, jeb->offset, ref_offset(raw), ref_flags(raw),\n\t\t  ic->ino);\n\n\t \n\n\tswitch(ic->state) {\n\tcase INO_STATE_CHECKEDABSENT:\n\t\t \n\t\tif (ref_flags(raw) == REF_PRISTINE)\n\t\t\tic->state = INO_STATE_GC;\n\t\telse {\n\t\t\tjffs2_dbg(1, \"Ino #%u is absent but node not REF_PRISTINE. Reading.\\n\",\n\t\t\t\t  ic->ino);\n\t\t}\n\t\tbreak;\n\n\tcase INO_STATE_PRESENT:\n\t\t \n\t\tbreak;\n\n\tcase INO_STATE_UNCHECKED:\n\tcase INO_STATE_CHECKING:\n\tcase INO_STATE_GC:\n\t\t \n\t\tpr_crit(\"Inode #%u already in state %d in jffs2_garbage_collect_pass()!\\n\",\n\t\t\tic->ino, ic->state);\n\t\tmutex_unlock(&c->alloc_sem);\n\t\tspin_unlock(&c->inocache_lock);\n\t\tBUG();\n\n\tcase INO_STATE_READING:\n\t\t \n\n\t\tmutex_unlock(&c->alloc_sem);\n\t\tjffs2_dbg(1, \"%s(): waiting for ino #%u in state %d\\n\",\n\t\t\t  __func__, ic->ino, ic->state);\n\t\tsleep_on_spinunlock(&c->inocache_wq, &c->inocache_lock);\n\t\t \n\t\treturn 0;\n\t}\n\n\t \n\n\tif (ic->state == INO_STATE_GC) {\n\t\tspin_unlock(&c->inocache_lock);\n\n\t\tret = jffs2_garbage_collect_pristine(c, ic, raw);\n\n\t\tspin_lock(&c->inocache_lock);\n\t\tic->state = INO_STATE_CHECKEDABSENT;\n\t\twake_up(&c->inocache_wq);\n\n\t\tif (ret != -EBADFD) {\n\t\t\tspin_unlock(&c->inocache_lock);\n\t\t\tgoto test_gcnode;\n\t\t}\n\n\t\t \n\t}\n\n\t \n\n\tinum = ic->ino;\n\tnlink = ic->pino_nlink;\n\tspin_unlock(&c->inocache_lock);\n\n\tf = jffs2_gc_fetch_inode(c, inum, !nlink);\n\tif (IS_ERR(f)) {\n\t\tret = PTR_ERR(f);\n\t\tgoto release_sem;\n\t}\n\tif (!f) {\n\t\tret = 0;\n\t\tgoto release_sem;\n\t}\n\n\tret = jffs2_garbage_collect_live(c, jeb, raw, f);\n\n\tjffs2_gc_release_inode(c, f);\n\n test_gcnode:\n\tif (jeb->dirty_size == gcblock_dirty && !ref_obsolete(jeb->gc_node)) {\n\t\t \n\t\tpr_err(\"Error garbage collecting node at %08x!\\n\",\n\t\t       ref_offset(jeb->gc_node));\n\t\tret = -ENOSPC;\n\t}\n release_sem:\n\tmutex_unlock(&c->alloc_sem);\n\n eraseit_lock:\n\t \n\tspin_lock(&c->erase_completion_lock);\n\n eraseit:\n\tif (c->gcblock && !c->gcblock->used_size) {\n\t\tjffs2_dbg(1, \"Block at 0x%08x completely obsoleted by GC. Moving to erase_pending_list\\n\",\n\t\t\t  c->gcblock->offset);\n\t\t \n\t\tlist_add_tail(&c->gcblock->list, &c->erase_pending_list);\n\t\tc->gcblock = NULL;\n\t\tc->nr_erasing_blocks++;\n\t\tjffs2_garbage_collect_trigger(c);\n\t}\n\tspin_unlock(&c->erase_completion_lock);\n\n\treturn ret;\n}\n\nstatic int jffs2_garbage_collect_live(struct jffs2_sb_info *c,  struct jffs2_eraseblock *jeb,\n\t\t\t\t      struct jffs2_raw_node_ref *raw, struct jffs2_inode_info *f)\n{\n\tstruct jffs2_node_frag *frag;\n\tstruct jffs2_full_dnode *fn = NULL;\n\tstruct jffs2_full_dirent *fd;\n\tuint32_t start = 0, end = 0, nrfrags = 0;\n\tint ret = 0;\n\n\tmutex_lock(&f->sem);\n\n\t \n\n\tspin_lock(&c->erase_completion_lock);\n\n\tif (c->gcblock != jeb) {\n\t\tspin_unlock(&c->erase_completion_lock);\n\t\tjffs2_dbg(1, \"GC block is no longer gcblock. Restart\\n\");\n\t\tgoto upnout;\n\t}\n\tif (ref_obsolete(raw)) {\n\t\tspin_unlock(&c->erase_completion_lock);\n\t\tjffs2_dbg(1, \"node to be GC'd was obsoleted in the meantime.\\n\");\n\t\t \n\t\tgoto upnout;\n\t}\n\tspin_unlock(&c->erase_completion_lock);\n\n\t \n\tif (f->metadata && f->metadata->raw == raw) {\n\t\tfn = f->metadata;\n\t\tret = jffs2_garbage_collect_metadata(c, jeb, f, fn);\n\t\tgoto upnout;\n\t}\n\n\t \n\tfor (frag = frag_first(&f->fragtree); frag; frag = frag_next(frag)) {\n\t\tif (frag->node && frag->node->raw == raw) {\n\t\t\tfn = frag->node;\n\t\t\tend = frag->ofs + frag->size;\n\t\t\tif (!nrfrags++)\n\t\t\t\tstart = frag->ofs;\n\t\t\tif (nrfrags == frag->node->frags)\n\t\t\t\tbreak;  \n\t\t}\n\t}\n\tif (fn) {\n\t\tif (ref_flags(raw) == REF_PRISTINE) {\n\t\t\tret = jffs2_garbage_collect_pristine(c, f->inocache, raw);\n\t\t\tif (!ret) {\n\t\t\t\t \n\t\t\t\tfrag->node->raw = f->inocache->nodes;\n\t\t\t}\n\t\t\tif (ret != -EBADFD)\n\t\t\t\tgoto upnout;\n\t\t}\n\t\t \n\t\tif((start >> PAGE_SHIFT) < ((end-1) >> PAGE_SHIFT)) {\n\t\t\t \n\t\t\tret = jffs2_garbage_collect_hole(c, jeb, f, fn, start, end);\n\t\t} else {\n\t\t\t \n\t\t\tret = jffs2_garbage_collect_dnode(c, jeb, f, fn, start, end);\n\t\t}\n\t\tgoto upnout;\n\t}\n\n\t \n\tfor (fd = f->dents; fd; fd=fd->next) {\n\t\tif (fd->raw == raw)\n\t\t\tbreak;\n\t}\n\n\tif (fd && fd->ino) {\n\t\tret = jffs2_garbage_collect_dirent(c, jeb, f, fd);\n\t} else if (fd) {\n\t\tret = jffs2_garbage_collect_deletion_dirent(c, jeb, f, fd);\n\t} else {\n\t\tpr_warn(\"Raw node at 0x%08x wasn't in node lists for ino #%u\\n\",\n\t\t\tref_offset(raw), f->inocache->ino);\n\t\tif (ref_obsolete(raw)) {\n\t\t\tpr_warn(\"But it's obsolete so we don't mind too much\\n\");\n\t\t} else {\n\t\t\tjffs2_dbg_dump_node(c, ref_offset(raw));\n\t\t\tBUG();\n\t\t}\n\t}\n upnout:\n\tmutex_unlock(&f->sem);\n\n\treturn ret;\n}\n\nstatic int jffs2_garbage_collect_pristine(struct jffs2_sb_info *c,\n\t\t\t\t\t  struct jffs2_inode_cache *ic,\n\t\t\t\t\t  struct jffs2_raw_node_ref *raw)\n{\n\tunion jffs2_node_union *node;\n\tsize_t retlen;\n\tint ret;\n\tuint32_t phys_ofs, alloclen;\n\tuint32_t crc, rawlen;\n\tint retried = 0;\n\n\tjffs2_dbg(1, \"Going to GC REF_PRISTINE node at 0x%08x\\n\",\n\t\t  ref_offset(raw));\n\n\talloclen = rawlen = ref_totlen(c, c->gcblock, raw);\n\n\t \n\tif (ic && alloclen > sizeof(struct jffs2_raw_inode) + JFFS2_MIN_DATA_LEN)\n\t\talloclen = sizeof(struct jffs2_raw_inode) + JFFS2_MIN_DATA_LEN;\n\n\tret = jffs2_reserve_space_gc(c, alloclen, &alloclen, rawlen);\n\t \n\n\tif (ret)\n\t\treturn ret;\n\n\tif (alloclen < rawlen) {\n\t\t \n\t\treturn -EBADFD;\n\t}\n\n\tnode = kmalloc(rawlen, GFP_KERNEL);\n\tif (!node)\n\t\treturn -ENOMEM;\n\n\tret = jffs2_flash_read(c, ref_offset(raw), rawlen, &retlen, (char *)node);\n\tif (!ret && retlen != rawlen)\n\t\tret = -EIO;\n\tif (ret)\n\t\tgoto out_node;\n\n\tcrc = crc32(0, node, sizeof(struct jffs2_unknown_node)-4);\n\tif (je32_to_cpu(node->u.hdr_crc) != crc) {\n\t\tpr_warn(\"Header CRC failed on REF_PRISTINE node at 0x%08x: Read 0x%08x, calculated 0x%08x\\n\",\n\t\t\tref_offset(raw), je32_to_cpu(node->u.hdr_crc), crc);\n\t\tgoto bail;\n\t}\n\n\tswitch(je16_to_cpu(node->u.nodetype)) {\n\tcase JFFS2_NODETYPE_INODE:\n\t\tcrc = crc32(0, node, sizeof(node->i)-8);\n\t\tif (je32_to_cpu(node->i.node_crc) != crc) {\n\t\t\tpr_warn(\"Node CRC failed on REF_PRISTINE data node at 0x%08x: Read 0x%08x, calculated 0x%08x\\n\",\n\t\t\t\tref_offset(raw), je32_to_cpu(node->i.node_crc),\n\t\t\t\tcrc);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (je32_to_cpu(node->i.dsize)) {\n\t\t\tcrc = crc32(0, node->i.data, je32_to_cpu(node->i.csize));\n\t\t\tif (je32_to_cpu(node->i.data_crc) != crc) {\n\t\t\t\tpr_warn(\"Data CRC failed on REF_PRISTINE data node at 0x%08x: Read 0x%08x, calculated 0x%08x\\n\",\n\t\t\t\t\tref_offset(raw),\n\t\t\t\t\tje32_to_cpu(node->i.data_crc), crc);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase JFFS2_NODETYPE_DIRENT:\n\t\tcrc = crc32(0, node, sizeof(node->d)-8);\n\t\tif (je32_to_cpu(node->d.node_crc) != crc) {\n\t\t\tpr_warn(\"Node CRC failed on REF_PRISTINE dirent node at 0x%08x: Read 0x%08x, calculated 0x%08x\\n\",\n\t\t\t\tref_offset(raw),\n\t\t\t\tje32_to_cpu(node->d.node_crc), crc);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (strnlen(node->d.name, node->d.nsize) != node->d.nsize) {\n\t\t\tpr_warn(\"Name in dirent node at 0x%08x contains zeroes\\n\",\n\t\t\t\tref_offset(raw));\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (node->d.nsize) {\n\t\t\tcrc = crc32(0, node->d.name, node->d.nsize);\n\t\t\tif (je32_to_cpu(node->d.name_crc) != crc) {\n\t\t\t\tpr_warn(\"Name CRC failed on REF_PRISTINE dirent node at 0x%08x: Read 0x%08x, calculated 0x%08x\\n\",\n\t\t\t\t\tref_offset(raw),\n\t\t\t\t\tje32_to_cpu(node->d.name_crc), crc);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tif (ic) {\n\t\t\tpr_warn(\"Unknown node type for REF_PRISTINE node at 0x%08x: 0x%04x\\n\",\n\t\t\t\tref_offset(raw), je16_to_cpu(node->u.nodetype));\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t \n retry:\n\tphys_ofs = write_ofs(c);\n\n\tret = jffs2_flash_write(c, phys_ofs, rawlen, &retlen, (char *)node);\n\n\tif (ret || (retlen != rawlen)) {\n\t\tpr_notice(\"Write of %d bytes at 0x%08x failed. returned %d, retlen %zd\\n\",\n\t\t\t  rawlen, phys_ofs, ret, retlen);\n\t\tif (retlen) {\n\t\t\tjffs2_add_physical_node_ref(c, phys_ofs | REF_OBSOLETE, rawlen, NULL);\n\t\t} else {\n\t\t\tpr_notice(\"Not marking the space at 0x%08x as dirty because the flash driver returned retlen zero\\n\",\n\t\t\t\t  phys_ofs);\n\t\t}\n\t\tif (!retried) {\n\t\t\t \n\t\t\tuint32_t dummy;\n\t\t\tstruct jffs2_eraseblock *jeb = &c->blocks[phys_ofs / c->sector_size];\n\n\t\t\tretried = 1;\n\n\t\t\tjffs2_dbg(1, \"Retrying failed write of REF_PRISTINE node.\\n\");\n\n\t\t\tjffs2_dbg_acct_sanity_check(c,jeb);\n\t\t\tjffs2_dbg_acct_paranoia_check(c, jeb);\n\n\t\t\tret = jffs2_reserve_space_gc(c, rawlen, &dummy, rawlen);\n\t\t\t\t\t\t \n\n\t\t\tif (!ret) {\n\t\t\t\tjffs2_dbg(1, \"Allocated space at 0x%08x to retry failed write.\\n\",\n\t\t\t\t\t  phys_ofs);\n\n\t\t\t\tjffs2_dbg_acct_sanity_check(c,jeb);\n\t\t\t\tjffs2_dbg_acct_paranoia_check(c, jeb);\n\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\tjffs2_dbg(1, \"Failed to allocate space to retry failed write: %d!\\n\",\n\t\t\t\t  ret);\n\t\t}\n\n\t\tif (!ret)\n\t\t\tret = -EIO;\n\t\tgoto out_node;\n\t}\n\tjffs2_add_physical_node_ref(c, phys_ofs | REF_PRISTINE, rawlen, ic);\n\n\tjffs2_mark_node_obsolete(c, raw);\n\tjffs2_dbg(1, \"WHEEE! GC REF_PRISTINE node at 0x%08x succeeded\\n\",\n\t\t  ref_offset(raw));\n\n out_node:\n\tkfree(node);\n\treturn ret;\n bail:\n\tret = -EBADFD;\n\tgoto out_node;\n}\n\nstatic int jffs2_garbage_collect_metadata(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t\tstruct jffs2_inode_info *f, struct jffs2_full_dnode *fn)\n{\n\tstruct jffs2_full_dnode *new_fn;\n\tstruct jffs2_raw_inode ri;\n\tstruct jffs2_node_frag *last_frag;\n\tunion jffs2_device_node dev;\n\tchar *mdata = NULL;\n\tint mdatalen = 0;\n\tuint32_t alloclen, ilen;\n\tint ret;\n\n\tif (S_ISBLK(JFFS2_F_I_MODE(f)) ||\n\t    S_ISCHR(JFFS2_F_I_MODE(f)) ) {\n\t\t \n\t\tmdatalen = jffs2_encode_dev(&dev, JFFS2_F_I_RDEV(f));\n\t\tmdata = (char *)&dev;\n\t\tjffs2_dbg(1, \"%s(): Writing %d bytes of kdev_t\\n\",\n\t\t\t  __func__, mdatalen);\n\t} else if (S_ISLNK(JFFS2_F_I_MODE(f))) {\n\t\tmdatalen = fn->size;\n\t\tmdata = kmalloc(fn->size, GFP_KERNEL);\n\t\tif (!mdata) {\n\t\t\tpr_warn(\"kmalloc of mdata failed in jffs2_garbage_collect_metadata()\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tret = jffs2_read_dnode(c, f, fn, mdata, 0, mdatalen);\n\t\tif (ret) {\n\t\t\tpr_warn(\"read of old metadata failed in jffs2_garbage_collect_metadata(): %d\\n\",\n\t\t\t\tret);\n\t\t\tkfree(mdata);\n\t\t\treturn ret;\n\t\t}\n\t\tjffs2_dbg(1, \"%s(): Writing %d bites of symlink target\\n\",\n\t\t\t  __func__, mdatalen);\n\n\t}\n\n\tret = jffs2_reserve_space_gc(c, sizeof(ri) + mdatalen, &alloclen,\n\t\t\t\tJFFS2_SUMMARY_INODE_SIZE);\n\tif (ret) {\n\t\tpr_warn(\"jffs2_reserve_space_gc of %zd bytes for garbage_collect_metadata failed: %d\\n\",\n\t\t\tsizeof(ri) + mdatalen, ret);\n\t\tgoto out;\n\t}\n\n\tlast_frag = frag_last(&f->fragtree);\n\tif (last_frag)\n\t\t \n\t\tilen = last_frag->ofs + last_frag->size;\n\telse\n\t\tilen = JFFS2_F_I_SIZE(f);\n\n\tmemset(&ri, 0, sizeof(ri));\n\tri.magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);\n\tri.nodetype = cpu_to_je16(JFFS2_NODETYPE_INODE);\n\tri.totlen = cpu_to_je32(sizeof(ri) + mdatalen);\n\tri.hdr_crc = cpu_to_je32(crc32(0, &ri, sizeof(struct jffs2_unknown_node)-4));\n\n\tri.ino = cpu_to_je32(f->inocache->ino);\n\tri.version = cpu_to_je32(++f->highest_version);\n\tri.mode = cpu_to_jemode(JFFS2_F_I_MODE(f));\n\tri.uid = cpu_to_je16(JFFS2_F_I_UID(f));\n\tri.gid = cpu_to_je16(JFFS2_F_I_GID(f));\n\tri.isize = cpu_to_je32(ilen);\n\tri.atime = cpu_to_je32(JFFS2_F_I_ATIME(f));\n\tri.ctime = cpu_to_je32(JFFS2_F_I_CTIME(f));\n\tri.mtime = cpu_to_je32(JFFS2_F_I_MTIME(f));\n\tri.offset = cpu_to_je32(0);\n\tri.csize = cpu_to_je32(mdatalen);\n\tri.dsize = cpu_to_je32(mdatalen);\n\tri.compr = JFFS2_COMPR_NONE;\n\tri.node_crc = cpu_to_je32(crc32(0, &ri, sizeof(ri)-8));\n\tri.data_crc = cpu_to_je32(crc32(0, mdata, mdatalen));\n\n\tnew_fn = jffs2_write_dnode(c, f, &ri, mdata, mdatalen, ALLOC_GC);\n\n\tif (IS_ERR(new_fn)) {\n\t\tpr_warn(\"Error writing new dnode: %ld\\n\", PTR_ERR(new_fn));\n\t\tret = PTR_ERR(new_fn);\n\t\tgoto out;\n\t}\n\tjffs2_mark_node_obsolete(c, fn->raw);\n\tjffs2_free_full_dnode(fn);\n\tf->metadata = new_fn;\n out:\n\tif (S_ISLNK(JFFS2_F_I_MODE(f)))\n\t\tkfree(mdata);\n\treturn ret;\n}\n\nstatic int jffs2_garbage_collect_dirent(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t\tstruct jffs2_inode_info *f, struct jffs2_full_dirent *fd)\n{\n\tstruct jffs2_full_dirent *new_fd;\n\tstruct jffs2_raw_dirent rd;\n\tuint32_t alloclen;\n\tint ret;\n\n\trd.magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);\n\trd.nodetype = cpu_to_je16(JFFS2_NODETYPE_DIRENT);\n\trd.nsize = strlen(fd->name);\n\trd.totlen = cpu_to_je32(sizeof(rd) + rd.nsize);\n\trd.hdr_crc = cpu_to_je32(crc32(0, &rd, sizeof(struct jffs2_unknown_node)-4));\n\n\trd.pino = cpu_to_je32(f->inocache->ino);\n\trd.version = cpu_to_je32(++f->highest_version);\n\trd.ino = cpu_to_je32(fd->ino);\n\t \n\tif (JFFS2_F_I_MTIME(f) == JFFS2_F_I_CTIME(f))\n\t\trd.mctime = cpu_to_je32(JFFS2_F_I_MTIME(f));\n\telse\n\t\trd.mctime = cpu_to_je32(0);\n\trd.type = fd->type;\n\trd.node_crc = cpu_to_je32(crc32(0, &rd, sizeof(rd)-8));\n\trd.name_crc = cpu_to_je32(crc32(0, fd->name, rd.nsize));\n\n\tret = jffs2_reserve_space_gc(c, sizeof(rd)+rd.nsize, &alloclen,\n\t\t\t\tJFFS2_SUMMARY_DIRENT_SIZE(rd.nsize));\n\tif (ret) {\n\t\tpr_warn(\"jffs2_reserve_space_gc of %zd bytes for garbage_collect_dirent failed: %d\\n\",\n\t\t\tsizeof(rd)+rd.nsize, ret);\n\t\treturn ret;\n\t}\n\tnew_fd = jffs2_write_dirent(c, f, &rd, fd->name, rd.nsize, ALLOC_GC);\n\n\tif (IS_ERR(new_fd)) {\n\t\tpr_warn(\"jffs2_write_dirent in garbage_collect_dirent failed: %ld\\n\",\n\t\t\tPTR_ERR(new_fd));\n\t\treturn PTR_ERR(new_fd);\n\t}\n\tjffs2_add_fd_to_list(c, new_fd, &f->dents);\n\treturn 0;\n}\n\nstatic int jffs2_garbage_collect_deletion_dirent(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t\tstruct jffs2_inode_info *f, struct jffs2_full_dirent *fd)\n{\n\tstruct jffs2_full_dirent **fdp = &f->dents;\n\tint found = 0;\n\n\t \n\tif (!jffs2_can_mark_obsolete(c)) {\n\t\tstruct jffs2_raw_dirent *rd;\n\t\tstruct jffs2_raw_node_ref *raw;\n\t\tint ret;\n\t\tsize_t retlen;\n\t\tint name_len = strlen(fd->name);\n\t\tuint32_t name_crc = crc32(0, fd->name, name_len);\n\t\tuint32_t rawlen = ref_totlen(c, jeb, fd->raw);\n\n\t\trd = kmalloc(rawlen, GFP_KERNEL);\n\t\tif (!rd)\n\t\t\treturn -ENOMEM;\n\n\t\t \n\t\tmutex_lock(&c->erase_free_sem);\n\n\t\tfor (raw = f->inocache->nodes; raw != (void *)f->inocache; raw = raw->next_in_ino) {\n\n\t\t\tcond_resched();\n\n\t\t\t \n\t\t\tif (!(ref_obsolete(raw)))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (ref_totlen(c, NULL, raw) != rawlen)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (SECTOR_ADDR(raw->flash_offset) == SECTOR_ADDR(fd->raw->flash_offset))\n\t\t\t\tcontinue;\n\n\t\t\tjffs2_dbg(1, \"Check potential deletion dirent at %08x\\n\",\n\t\t\t\t  ref_offset(raw));\n\n\t\t\t \n\t\t\tret = jffs2_flash_read(c, ref_offset(raw), rawlen, &retlen, (char *)rd);\n\t\t\tif (ret) {\n\t\t\t\tpr_warn(\"%s(): Read error (%d) reading obsolete node at %08x\\n\",\n\t\t\t\t\t__func__, ret, ref_offset(raw));\n\t\t\t\t \n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (retlen != rawlen) {\n\t\t\t\tpr_warn(\"%s(): Short read (%zd not %u) reading header from obsolete node at %08x\\n\",\n\t\t\t\t\t__func__, retlen, rawlen,\n\t\t\t\t\tref_offset(raw));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (je16_to_cpu(rd->nodetype) != JFFS2_NODETYPE_DIRENT)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (je32_to_cpu(rd->name_crc) != name_crc)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (rd->nsize != name_len || !je32_to_cpu(rd->ino))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (memcmp(rd->name, fd->name, name_len))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tmutex_unlock(&c->erase_free_sem);\n\n\t\t\tjffs2_dbg(1, \"Deletion dirent at %08x still obsoletes real dirent \\\"%s\\\" at %08x for ino #%u\\n\",\n\t\t\t\t  ref_offset(fd->raw), fd->name,\n\t\t\t\t  ref_offset(raw), je32_to_cpu(rd->ino));\n\t\t\tkfree(rd);\n\n\t\t\treturn jffs2_garbage_collect_dirent(c, jeb, f, fd);\n\t\t}\n\n\t\tmutex_unlock(&c->erase_free_sem);\n\t\tkfree(rd);\n\t}\n\n\t \n\n\t \n\twhile (*fdp) {\n\t\tif ((*fdp) == fd) {\n\t\t\tfound = 1;\n\t\t\t*fdp = fd->next;\n\t\t\tbreak;\n\t\t}\n\t\tfdp = &(*fdp)->next;\n\t}\n\tif (!found) {\n\t\tpr_warn(\"Deletion dirent \\\"%s\\\" not found in list for ino #%u\\n\",\n\t\t\tfd->name, f->inocache->ino);\n\t}\n\tjffs2_mark_node_obsolete(c, fd->raw);\n\tjffs2_free_full_dirent(fd);\n\treturn 0;\n}\n\nstatic int jffs2_garbage_collect_hole(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t      struct jffs2_inode_info *f, struct jffs2_full_dnode *fn,\n\t\t\t\t      uint32_t start, uint32_t end)\n{\n\tstruct jffs2_raw_inode ri;\n\tstruct jffs2_node_frag *frag;\n\tstruct jffs2_full_dnode *new_fn;\n\tuint32_t alloclen, ilen;\n\tint ret;\n\n\tjffs2_dbg(1, \"Writing replacement hole node for ino #%u from offset 0x%x to 0x%x\\n\",\n\t\t  f->inocache->ino, start, end);\n\n\tmemset(&ri, 0, sizeof(ri));\n\n\tif(fn->frags > 1) {\n\t\tsize_t readlen;\n\t\tuint32_t crc;\n\t\t \n\t\tret = jffs2_flash_read(c, ref_offset(fn->raw), sizeof(ri), &readlen, (char *)&ri);\n\t\tif (readlen != sizeof(ri) || ret) {\n\t\t\tpr_warn(\"Node read failed in jffs2_garbage_collect_hole. Ret %d, retlen %zd. Data will be lost by writing new hole node\\n\",\n\t\t\t\tret, readlen);\n\t\t\tgoto fill;\n\t\t}\n\t\tif (je16_to_cpu(ri.nodetype) != JFFS2_NODETYPE_INODE) {\n\t\t\tpr_warn(\"%s(): Node at 0x%08x had node type 0x%04x instead of JFFS2_NODETYPE_INODE(0x%04x)\\n\",\n\t\t\t\t__func__, ref_offset(fn->raw),\n\t\t\t\tje16_to_cpu(ri.nodetype), JFFS2_NODETYPE_INODE);\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (je32_to_cpu(ri.totlen) != sizeof(ri)) {\n\t\t\tpr_warn(\"%s(): Node at 0x%08x had totlen 0x%x instead of expected 0x%zx\\n\",\n\t\t\t\t__func__, ref_offset(fn->raw),\n\t\t\t\tje32_to_cpu(ri.totlen), sizeof(ri));\n\t\t\treturn -EIO;\n\t\t}\n\t\tcrc = crc32(0, &ri, sizeof(ri)-8);\n\t\tif (crc != je32_to_cpu(ri.node_crc)) {\n\t\t\tpr_warn(\"%s: Node at 0x%08x had CRC 0x%08x which doesn't match calculated CRC 0x%08x\\n\",\n\t\t\t\t__func__, ref_offset(fn->raw),\n\t\t\t\tje32_to_cpu(ri.node_crc), crc);\n\t\t\t \n\t\t\tpr_warn(\"Data in the range 0x%08x to 0x%08x of inode #%u will be lost\\n\",\n\t\t\t\tstart, end, f->inocache->ino);\n\t\t\tgoto fill;\n\t\t}\n\t\tif (ri.compr != JFFS2_COMPR_ZERO) {\n\t\t\tpr_warn(\"%s(): Node 0x%08x wasn't a hole node!\\n\",\n\t\t\t\t__func__, ref_offset(fn->raw));\n\t\t\tpr_warn(\"Data in the range 0x%08x to 0x%08x of inode #%u will be lost\\n\",\n\t\t\t\tstart, end, f->inocache->ino);\n\t\t\tgoto fill;\n\t\t}\n\t} else {\n\tfill:\n\t\tri.magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);\n\t\tri.nodetype = cpu_to_je16(JFFS2_NODETYPE_INODE);\n\t\tri.totlen = cpu_to_je32(sizeof(ri));\n\t\tri.hdr_crc = cpu_to_je32(crc32(0, &ri, sizeof(struct jffs2_unknown_node)-4));\n\n\t\tri.ino = cpu_to_je32(f->inocache->ino);\n\t\tri.version = cpu_to_je32(++f->highest_version);\n\t\tri.offset = cpu_to_je32(start);\n\t\tri.dsize = cpu_to_je32(end - start);\n\t\tri.csize = cpu_to_je32(0);\n\t\tri.compr = JFFS2_COMPR_ZERO;\n\t}\n\n\tfrag = frag_last(&f->fragtree);\n\tif (frag)\n\t\t \n\t\tilen = frag->ofs + frag->size;\n\telse\n\t\tilen = JFFS2_F_I_SIZE(f);\n\n\tri.mode = cpu_to_jemode(JFFS2_F_I_MODE(f));\n\tri.uid = cpu_to_je16(JFFS2_F_I_UID(f));\n\tri.gid = cpu_to_je16(JFFS2_F_I_GID(f));\n\tri.isize = cpu_to_je32(ilen);\n\tri.atime = cpu_to_je32(JFFS2_F_I_ATIME(f));\n\tri.ctime = cpu_to_je32(JFFS2_F_I_CTIME(f));\n\tri.mtime = cpu_to_je32(JFFS2_F_I_MTIME(f));\n\tri.data_crc = cpu_to_je32(0);\n\tri.node_crc = cpu_to_je32(crc32(0, &ri, sizeof(ri)-8));\n\n\tret = jffs2_reserve_space_gc(c, sizeof(ri), &alloclen,\n\t\t\t\t     JFFS2_SUMMARY_INODE_SIZE);\n\tif (ret) {\n\t\tpr_warn(\"jffs2_reserve_space_gc of %zd bytes for garbage_collect_hole failed: %d\\n\",\n\t\t\tsizeof(ri), ret);\n\t\treturn ret;\n\t}\n\tnew_fn = jffs2_write_dnode(c, f, &ri, NULL, 0, ALLOC_GC);\n\n\tif (IS_ERR(new_fn)) {\n\t\tpr_warn(\"Error writing new hole node: %ld\\n\", PTR_ERR(new_fn));\n\t\treturn PTR_ERR(new_fn);\n\t}\n\tif (je32_to_cpu(ri.version) == f->highest_version) {\n\t\tjffs2_add_full_dnode_to_inode(c, f, new_fn);\n\t\tif (f->metadata) {\n\t\t\tjffs2_mark_node_obsolete(c, f->metadata->raw);\n\t\t\tjffs2_free_full_dnode(f->metadata);\n\t\t\tf->metadata = NULL;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t \n\tD1(if(unlikely(fn->frags <= 1)) {\n\t\t\tpr_warn(\"%s(): Replacing fn with %d frag(s) but new ver %d != highest_version %d of ino #%d\\n\",\n\t\t\t\t__func__, fn->frags, je32_to_cpu(ri.version),\n\t\t\t\tf->highest_version, je32_to_cpu(ri.ino));\n\t});\n\n\t \n\tmark_ref_normal(new_fn->raw);\n\n\tfor (frag = jffs2_lookup_node_frag(&f->fragtree, fn->ofs);\n\t     frag; frag = frag_next(frag)) {\n\t\tif (frag->ofs > fn->size + fn->ofs)\n\t\t\tbreak;\n\t\tif (frag->node == fn) {\n\t\t\tfrag->node = new_fn;\n\t\t\tnew_fn->frags++;\n\t\t\tfn->frags--;\n\t\t}\n\t}\n\tif (fn->frags) {\n\t\tpr_warn(\"%s(): Old node still has frags!\\n\", __func__);\n\t\tBUG();\n\t}\n\tif (!new_fn->frags) {\n\t\tpr_warn(\"%s(): New node has no frags!\\n\", __func__);\n\t\tBUG();\n\t}\n\n\tjffs2_mark_node_obsolete(c, fn->raw);\n\tjffs2_free_full_dnode(fn);\n\n\treturn 0;\n}\n\nstatic int jffs2_garbage_collect_dnode(struct jffs2_sb_info *c, struct jffs2_eraseblock *orig_jeb,\n\t\t\t\t       struct jffs2_inode_info *f, struct jffs2_full_dnode *fn,\n\t\t\t\t       uint32_t start, uint32_t end)\n{\n\tstruct inode *inode = OFNI_EDONI_2SFFJ(f);\n\tstruct jffs2_full_dnode *new_fn;\n\tstruct jffs2_raw_inode ri;\n\tuint32_t alloclen, offset, orig_end, orig_start;\n\tint ret = 0;\n\tunsigned char *comprbuf = NULL, *writebuf;\n\tstruct page *page;\n\tunsigned char *pg_ptr;\n\n\tmemset(&ri, 0, sizeof(ri));\n\n\tjffs2_dbg(1, \"Writing replacement dnode for ino #%u from offset 0x%x to 0x%x\\n\",\n\t\t  f->inocache->ino, start, end);\n\n\torig_end = end;\n\torig_start = start;\n\n\tif (c->nr_free_blocks + c->nr_erasing_blocks > c->resv_blocks_gcmerge) {\n\t\t \n\n\t\tstruct jffs2_node_frag *frag;\n\t\tuint32_t min, max;\n\n\t\tmin = start & ~(PAGE_SIZE-1);\n\t\tmax = min + PAGE_SIZE;\n\n\t\tfrag = jffs2_lookup_node_frag(&f->fragtree, start);\n\n\t\t \n\n\t\tBUG_ON(frag->ofs != start);\n\n\t\t \n\t\twhile((frag = frag_prev(frag)) && frag->ofs >= min) {\n\n\t\t\t \n\t\t\tif (frag->ofs > min) {\n\t\t\t\tjffs2_dbg(1, \"Expanding down to cover partial frag (0x%x-0x%x)\\n\",\n\t\t\t\t\t  frag->ofs, frag->ofs+frag->size);\n\t\t\t\tstart = frag->ofs;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t \n\t\t\tif (!frag->node || !frag->node->raw) {\n\t\t\t\tjffs2_dbg(1, \"First frag in page is hole (0x%x-0x%x). Not expanding down.\\n\",\n\t\t\t\t\t  frag->ofs, frag->ofs+frag->size);\n\t\t\t\tbreak;\n\t\t\t} else {\n\n\t\t\t\t \n\n\t\t\t\tstruct jffs2_raw_node_ref *raw = frag->node->raw;\n\t\t\t\tstruct jffs2_eraseblock *jeb;\n\n\t\t\t\tjeb = &c->blocks[raw->flash_offset / c->sector_size];\n\n\t\t\t\tif (jeb == c->gcblock) {\n\t\t\t\t\tjffs2_dbg(1, \"Expanding down to cover frag (0x%x-0x%x) in gcblock at %08x\\n\",\n\t\t\t\t\t\t  frag->ofs,\n\t\t\t\t\t\t  frag->ofs + frag->size,\n\t\t\t\t\t\t  ref_offset(raw));\n\t\t\t\t\tstart = frag->ofs;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!ISDIRTY(jeb->dirty_size + jeb->wasted_size)) {\n\t\t\t\t\tjffs2_dbg(1, \"Not expanding down to cover frag (0x%x-0x%x) in clean block %08x\\n\",\n\t\t\t\t\t\t  frag->ofs,\n\t\t\t\t\t\t  frag->ofs + frag->size,\n\t\t\t\t\t\t  jeb->offset);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tjffs2_dbg(1, \"Expanding down to cover frag (0x%x-0x%x) in dirty block %08x\\n\",\n\t\t\t\t\t  frag->ofs,\n\t\t\t\t\t  frag->ofs + frag->size,\n\t\t\t\t\t  jeb->offset);\n\t\t\t\tstart = frag->ofs;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\n\t\t \n\t\tfrag = jffs2_lookup_node_frag(&f->fragtree, end-1);\n\n\t\twhile((frag = frag_next(frag)) && frag->ofs+frag->size <= max) {\n\n\t\t\t \n\t\t\tif (frag->ofs+frag->size < max) {\n\t\t\t\tjffs2_dbg(1, \"Expanding up to cover partial frag (0x%x-0x%x)\\n\",\n\t\t\t\t\t  frag->ofs, frag->ofs+frag->size);\n\t\t\t\tend = frag->ofs + frag->size;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!frag->node || !frag->node->raw) {\n\t\t\t\tjffs2_dbg(1, \"Last frag in page is hole (0x%x-0x%x). Not expanding up.\\n\",\n\t\t\t\t\t  frag->ofs, frag->ofs+frag->size);\n\t\t\t\tbreak;\n\t\t\t} else {\n\n\t\t\t\t \n\n\t\t\t\tstruct jffs2_raw_node_ref *raw = frag->node->raw;\n\t\t\t\tstruct jffs2_eraseblock *jeb;\n\n\t\t\t\tjeb = &c->blocks[raw->flash_offset / c->sector_size];\n\n\t\t\t\tif (jeb == c->gcblock) {\n\t\t\t\t\tjffs2_dbg(1, \"Expanding up to cover frag (0x%x-0x%x) in gcblock at %08x\\n\",\n\t\t\t\t\t\t  frag->ofs,\n\t\t\t\t\t\t  frag->ofs + frag->size,\n\t\t\t\t\t\t  ref_offset(raw));\n\t\t\t\t\tend = frag->ofs + frag->size;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!ISDIRTY(jeb->dirty_size + jeb->wasted_size)) {\n\t\t\t\t\tjffs2_dbg(1, \"Not expanding up to cover frag (0x%x-0x%x) in clean block %08x\\n\",\n\t\t\t\t\t\t  frag->ofs,\n\t\t\t\t\t\t  frag->ofs + frag->size,\n\t\t\t\t\t\t  jeb->offset);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tjffs2_dbg(1, \"Expanding up to cover frag (0x%x-0x%x) in dirty block %08x\\n\",\n\t\t\t\t\t  frag->ofs,\n\t\t\t\t\t  frag->ofs + frag->size,\n\t\t\t\t\t  jeb->offset);\n\t\t\t\tend = frag->ofs + frag->size;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tjffs2_dbg(1, \"Expanded dnode to write from (0x%x-0x%x) to (0x%x-0x%x)\\n\",\n\t\t\t  orig_start, orig_end, start, end);\n\n\t\tD1(BUG_ON(end > frag_last(&f->fragtree)->ofs + frag_last(&f->fragtree)->size));\n\t\tBUG_ON(end < orig_end);\n\t\tBUG_ON(start > orig_start);\n\t}\n\n\t \n\tmutex_unlock(&f->sem);\n\tpage = read_cache_page(inode->i_mapping, start >> PAGE_SHIFT,\n\t\t\t       __jffs2_read_folio, NULL);\n\tif (IS_ERR(page)) {\n\t\tpr_warn(\"read_cache_page() returned error: %ld\\n\",\n\t\t\tPTR_ERR(page));\n\t\tmutex_lock(&f->sem);\n\t\treturn PTR_ERR(page);\n\t}\n\n\tpg_ptr = kmap(page);\n\tmutex_lock(&f->sem);\n\n\toffset = start;\n\twhile(offset < orig_end) {\n\t\tuint32_t datalen;\n\t\tuint32_t cdatalen;\n\t\tuint16_t comprtype = JFFS2_COMPR_NONE;\n\n\t\tret = jffs2_reserve_space_gc(c, sizeof(ri) + JFFS2_MIN_DATA_LEN,\n\t\t\t\t\t&alloclen, JFFS2_SUMMARY_INODE_SIZE);\n\n\t\tif (ret) {\n\t\t\tpr_warn(\"jffs2_reserve_space_gc of %zd bytes for garbage_collect_dnode failed: %d\\n\",\n\t\t\t\tsizeof(ri) + JFFS2_MIN_DATA_LEN, ret);\n\t\t\tbreak;\n\t\t}\n\t\tcdatalen = min_t(uint32_t, alloclen - sizeof(ri), end - offset);\n\t\tdatalen = end - offset;\n\n\t\twritebuf = pg_ptr + (offset & (PAGE_SIZE -1));\n\n\t\tcomprtype = jffs2_compress(c, f, writebuf, &comprbuf, &datalen, &cdatalen);\n\n\t\tri.magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);\n\t\tri.nodetype = cpu_to_je16(JFFS2_NODETYPE_INODE);\n\t\tri.totlen = cpu_to_je32(sizeof(ri) + cdatalen);\n\t\tri.hdr_crc = cpu_to_je32(crc32(0, &ri, sizeof(struct jffs2_unknown_node)-4));\n\n\t\tri.ino = cpu_to_je32(f->inocache->ino);\n\t\tri.version = cpu_to_je32(++f->highest_version);\n\t\tri.mode = cpu_to_jemode(JFFS2_F_I_MODE(f));\n\t\tri.uid = cpu_to_je16(JFFS2_F_I_UID(f));\n\t\tri.gid = cpu_to_je16(JFFS2_F_I_GID(f));\n\t\tri.isize = cpu_to_je32(JFFS2_F_I_SIZE(f));\n\t\tri.atime = cpu_to_je32(JFFS2_F_I_ATIME(f));\n\t\tri.ctime = cpu_to_je32(JFFS2_F_I_CTIME(f));\n\t\tri.mtime = cpu_to_je32(JFFS2_F_I_MTIME(f));\n\t\tri.offset = cpu_to_je32(offset);\n\t\tri.csize = cpu_to_je32(cdatalen);\n\t\tri.dsize = cpu_to_je32(datalen);\n\t\tri.compr = comprtype & 0xff;\n\t\tri.usercompr = (comprtype >> 8) & 0xff;\n\t\tri.node_crc = cpu_to_je32(crc32(0, &ri, sizeof(ri)-8));\n\t\tri.data_crc = cpu_to_je32(crc32(0, comprbuf, cdatalen));\n\n\t\tnew_fn = jffs2_write_dnode(c, f, &ri, comprbuf, cdatalen, ALLOC_GC);\n\n\t\tjffs2_free_comprbuf(comprbuf, writebuf);\n\n\t\tif (IS_ERR(new_fn)) {\n\t\t\tpr_warn(\"Error writing new dnode: %ld\\n\",\n\t\t\t\tPTR_ERR(new_fn));\n\t\t\tret = PTR_ERR(new_fn);\n\t\t\tbreak;\n\t\t}\n\t\tret = jffs2_add_full_dnode_to_inode(c, f, new_fn);\n\t\toffset += datalen;\n\t\tif (f->metadata) {\n\t\t\tjffs2_mark_node_obsolete(c, f->metadata->raw);\n\t\t\tjffs2_free_full_dnode(f->metadata);\n\t\t\tf->metadata = NULL;\n\t\t}\n\t}\n\n\tkunmap(page);\n\tput_page(page);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}