{
  "module_name": "build.c",
  "hash_id": "f432619ca73077f24466feb342a6aff7bf814f2b7647d4c676e72e9c374814c8",
  "original_prompt": "Ingested from linux-6.6.14/fs/jffs2/build.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mm.h>  \n#include \"nodelist.h\"\n\nstatic void jffs2_build_remove_unlinked_inode(struct jffs2_sb_info *,\n\t\tstruct jffs2_inode_cache *, struct jffs2_full_dirent **);\n\nstatic inline struct jffs2_inode_cache *\nfirst_inode_chain(int *i, struct jffs2_sb_info *c)\n{\n\tfor (; *i < c->inocache_hashsize; (*i)++) {\n\t\tif (c->inocache_list[*i])\n\t\t\treturn c->inocache_list[*i];\n\t}\n\treturn NULL;\n}\n\nstatic inline struct jffs2_inode_cache *\nnext_inode(int *i, struct jffs2_inode_cache *ic, struct jffs2_sb_info *c)\n{\n\t \n\tif (ic->next)\n\t\treturn ic->next;\n\t(*i)++;\n\treturn first_inode_chain(i, c);\n}\n\n#define for_each_inode(i, c, ic)\t\t\t\\\n\tfor (i = 0, ic = first_inode_chain(&i, (c));\t\\\n\t     ic;\t\t\t\t\t\\\n\t     ic = next_inode(&i, ic, (c)))\n\n\nstatic void jffs2_build_inode_pass1(struct jffs2_sb_info *c,\n\t\t\t\t    struct jffs2_inode_cache *ic,\n\t\t\t\t    int *dir_hardlinks)\n{\n\tstruct jffs2_full_dirent *fd;\n\n\tdbg_fsbuild(\"building directory inode #%u\\n\", ic->ino);\n\n\t \n\tfor(fd = ic->scan_dents; fd; fd = fd->next) {\n\t\tstruct jffs2_inode_cache *child_ic;\n\t\tif (!fd->ino)\n\t\t\tcontinue;\n\n\t\t \n\n\t\tchild_ic = jffs2_get_ino_cache(c, fd->ino);\n\t\tif (!child_ic) {\n\t\t\tdbg_fsbuild(\"child \\\"%s\\\" (ino #%u) of dir ino #%u doesn't exist!\\n\",\n\t\t\t\t  fd->name, fd->ino, ic->ino);\n\t\t\tjffs2_mark_node_obsolete(c, fd->raw);\n\t\t\t \n\t\t\tfd->ic = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tfd->ic = child_ic;\n\t\tchild_ic->pino_nlink++;\n\t\t \n\t\tif (fd->type == DT_DIR) {\n\t\t\tchild_ic->flags |= INO_FLAGS_IS_DIR;\n\t\t\tif (child_ic->pino_nlink > 1)\n\t\t\t\t*dir_hardlinks = 1;\n\t\t}\n\n\t\tdbg_fsbuild(\"increased nlink for child \\\"%s\\\" (ino #%u)\\n\", fd->name, fd->ino);\n\t\t \n\t}\n}\n\n \nstatic int jffs2_build_filesystem(struct jffs2_sb_info *c)\n{\n\tint ret, i, dir_hardlinks = 0;\n\tstruct jffs2_inode_cache *ic;\n\tstruct jffs2_full_dirent *fd;\n\tstruct jffs2_full_dirent *dead_fds = NULL;\n\n\tdbg_fsbuild(\"build FS data structures\\n\");\n\n\t \n\n\tc->flags |= JFFS2_SB_FLAG_SCANNING;\n\tret = jffs2_scan_medium(c);\n\tc->flags &= ~JFFS2_SB_FLAG_SCANNING;\n\tif (ret)\n\t\tgoto exit;\n\n\tdbg_fsbuild(\"scanned flash completely\\n\");\n\tjffs2_dbg_dump_block_lists_nolock(c);\n\n\tdbg_fsbuild(\"pass 1 starting\\n\");\n\tc->flags |= JFFS2_SB_FLAG_BUILDING;\n\t \n\tfor_each_inode(i, c, ic) {\n\t\tif (ic->scan_dents) {\n\t\t\tjffs2_build_inode_pass1(c, ic, &dir_hardlinks);\n\t\t\tcond_resched();\n\t\t}\n\t}\n\n\tdbg_fsbuild(\"pass 1 complete\\n\");\n\n\t \n\tdbg_fsbuild(\"pass 2 starting\\n\");\n\n\tfor_each_inode(i, c, ic) {\n\t\tif (ic->pino_nlink)\n\t\t\tcontinue;\n\n\t\tjffs2_build_remove_unlinked_inode(c, ic, &dead_fds);\n\t\tcond_resched();\n\t}\n\n\tdbg_fsbuild(\"pass 2a starting\\n\");\n\n\twhile (dead_fds) {\n\t\tfd = dead_fds;\n\t\tdead_fds = fd->next;\n\n\t\tic = jffs2_get_ino_cache(c, fd->ino);\n\n\t\tif (ic)\n\t\t\tjffs2_build_remove_unlinked_inode(c, ic, &dead_fds);\n\t\tjffs2_free_full_dirent(fd);\n\t}\n\n\tdbg_fsbuild(\"pass 2a complete\\n\");\n\n\tif (dir_hardlinks) {\n\t\t \n\t\tfor_each_inode(i, c, ic) {\n\t\t\tif (ic->flags & INO_FLAGS_IS_DIR)\n\t\t\t\tic->pino_nlink = 0;\n\t\t}\n\t}\n\tdbg_fsbuild(\"freeing temporary data structures\\n\");\n\n\t \n\tfor_each_inode(i, c, ic) {\n\t\twhile(ic->scan_dents) {\n\t\t\tfd = ic->scan_dents;\n\t\t\tic->scan_dents = fd->next;\n\t\t\t \n\t\t\tif (fd->type == DT_DIR) {\n\t\t\t\tif (!fd->ic) {\n\t\t\t\t\t \n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tBUG_ON(!(fd->ic->flags & INO_FLAGS_IS_DIR));\n\n\t\t\t\t \n\t\t\t\tif (dir_hardlinks && fd->ic->pino_nlink) {\n\t\t\t\t\tJFFS2_ERROR(\"child dir \\\"%s\\\" (ino #%u) of dir ino #%u is also hard linked from dir ino #%u\\n\",\n\t\t\t\t\t\t    fd->name, fd->ino, ic->ino, fd->ic->pino_nlink);\n\t\t\t\t\t \n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tfd->ic->pino_nlink = ic->ino;\n\t\t\t}\n\t\t\tjffs2_free_full_dirent(fd);\n\t\t}\n\t\tic->scan_dents = NULL;\n\t\tcond_resched();\n\t}\n\tret = jffs2_build_xattr_subsystem(c);\n\tif (ret)\n\t\tgoto exit;\n\n\tc->flags &= ~JFFS2_SB_FLAG_BUILDING;\n\n\tdbg_fsbuild(\"FS build complete\\n\");\n\n\t \n\tjffs2_rotate_lists(c);\n\n\tret = 0;\n\nexit:\n\tif (ret) {\n\t\tfor_each_inode(i, c, ic) {\n\t\t\twhile(ic->scan_dents) {\n\t\t\t\tfd = ic->scan_dents;\n\t\t\t\tic->scan_dents = fd->next;\n\t\t\t\tjffs2_free_full_dirent(fd);\n\t\t\t}\n\t\t}\n\t\tjffs2_clear_xattr_subsystem(c);\n\t}\n\n\treturn ret;\n}\n\nstatic void jffs2_build_remove_unlinked_inode(struct jffs2_sb_info *c,\n\t\t\t\t\tstruct jffs2_inode_cache *ic,\n\t\t\t\t\tstruct jffs2_full_dirent **dead_fds)\n{\n\tstruct jffs2_raw_node_ref *raw;\n\tstruct jffs2_full_dirent *fd;\n\n\tdbg_fsbuild(\"removing ino #%u with nlink == zero.\\n\", ic->ino);\n\n\traw = ic->nodes;\n\twhile (raw != (void *)ic) {\n\t\tstruct jffs2_raw_node_ref *next = raw->next_in_ino;\n\t\tdbg_fsbuild(\"obsoleting node at 0x%08x\\n\", ref_offset(raw));\n\t\tjffs2_mark_node_obsolete(c, raw);\n\t\traw = next;\n\t}\n\n\tif (ic->scan_dents) {\n\t\tint whinged = 0;\n\t\tdbg_fsbuild(\"inode #%u was a directory which may have children...\\n\", ic->ino);\n\n\t\twhile(ic->scan_dents) {\n\t\t\tstruct jffs2_inode_cache *child_ic;\n\n\t\t\tfd = ic->scan_dents;\n\t\t\tic->scan_dents = fd->next;\n\n\t\t\tif (!fd->ino) {\n\t\t\t\t \n\t\t\t\tdbg_fsbuild(\"child \\\"%s\\\" is a deletion dirent, skipping...\\n\", fd->name);\n\t\t\t\tjffs2_free_full_dirent(fd);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!whinged)\n\t\t\t\twhinged = 1;\n\n\t\t\tdbg_fsbuild(\"removing child \\\"%s\\\", ino #%u\\n\", fd->name, fd->ino);\n\n\t\t\tchild_ic = jffs2_get_ino_cache(c, fd->ino);\n\t\t\tif (!child_ic) {\n\t\t\t\tdbg_fsbuild(\"cannot remove child \\\"%s\\\", ino #%u, because it doesn't exist\\n\",\n\t\t\t\t\t\tfd->name, fd->ino);\n\t\t\t\tjffs2_free_full_dirent(fd);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tchild_ic->pino_nlink--;\n\n\t\t\tif (!child_ic->pino_nlink) {\n\t\t\t\tdbg_fsbuild(\"inode #%u (\\\"%s\\\") now has no links; adding to dead_fds list.\\n\",\n\t\t\t\t\t  fd->ino, fd->name);\n\t\t\t\tfd->next = *dead_fds;\n\t\t\t\t*dead_fds = fd;\n\t\t\t} else {\n\t\t\t\tdbg_fsbuild(\"inode #%u (\\\"%s\\\") has now got nlink %d. Ignoring.\\n\",\n\t\t\t\t\t  fd->ino, fd->name, child_ic->pino_nlink);\n\t\t\t\tjffs2_free_full_dirent(fd);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n}\n\nstatic void jffs2_calc_trigger_levels(struct jffs2_sb_info *c)\n{\n\tuint32_t size;\n\n\t \n\tc->resv_blocks_deletion = 2;\n\n\t \n\n\tsize = c->flash_size / 50;  \n\tsize += c->nr_blocks * 100;  \n\tsize += c->sector_size - 1;  \n\n\tc->resv_blocks_write = c->resv_blocks_deletion + (size / c->sector_size);\n\n\t \n\n\tc->resv_blocks_gctrigger = c->resv_blocks_write + 1;\n\n\t \n\tc->resv_blocks_gcmerge = c->resv_blocks_deletion + 1;\n\n\t \n\tc->resv_blocks_gcbad = 0; \n\n\t \n\tc->vdirty_blocks_gctrigger = c->resv_blocks_gctrigger;\n\tif (jffs2_can_mark_obsolete(c))\n\t\tc->vdirty_blocks_gctrigger *= 10;\n\n\t \n\tc->nospc_dirty_size = c->sector_size + (c->flash_size / 100);\n\n\tdbg_fsbuild(\"trigger levels (size %d KiB, block size %d KiB, %d blocks)\\n\",\n\t\t    c->flash_size / 1024, c->sector_size / 1024, c->nr_blocks);\n\tdbg_fsbuild(\"Blocks required to allow deletion:    %d (%d KiB)\\n\",\n\t\t  c->resv_blocks_deletion, c->resv_blocks_deletion*c->sector_size/1024);\n\tdbg_fsbuild(\"Blocks required to allow writes:      %d (%d KiB)\\n\",\n\t\t  c->resv_blocks_write, c->resv_blocks_write*c->sector_size/1024);\n\tdbg_fsbuild(\"Blocks required to quiesce GC thread: %d (%d KiB)\\n\",\n\t\t  c->resv_blocks_gctrigger, c->resv_blocks_gctrigger*c->sector_size/1024);\n\tdbg_fsbuild(\"Blocks required to allow GC merges:   %d (%d KiB)\\n\",\n\t\t  c->resv_blocks_gcmerge, c->resv_blocks_gcmerge*c->sector_size/1024);\n\tdbg_fsbuild(\"Blocks required to GC bad blocks:     %d (%d KiB)\\n\",\n\t\t  c->resv_blocks_gcbad, c->resv_blocks_gcbad*c->sector_size/1024);\n\tdbg_fsbuild(\"Amount of dirty space required to GC: %d bytes\\n\",\n\t\t  c->nospc_dirty_size);\n\tdbg_fsbuild(\"Very dirty blocks before GC triggered: %d\\n\",\n\t\t  c->vdirty_blocks_gctrigger);\n}\n\nint jffs2_do_mount_fs(struct jffs2_sb_info *c)\n{\n\tint ret;\n\tint i;\n\tint size;\n\n\tc->free_size = c->flash_size;\n\tc->nr_blocks = c->flash_size / c->sector_size;\n\tsize = sizeof(struct jffs2_eraseblock) * c->nr_blocks;\n#ifndef __ECOS\n\tif (jffs2_blocks_use_vmalloc(c))\n\t\tc->blocks = vzalloc(size);\n\telse\n#endif\n\t\tc->blocks = kzalloc(size, GFP_KERNEL);\n\tif (!c->blocks)\n\t\treturn -ENOMEM;\n\n\tfor (i=0; i<c->nr_blocks; i++) {\n\t\tINIT_LIST_HEAD(&c->blocks[i].list);\n\t\tc->blocks[i].offset = i * c->sector_size;\n\t\tc->blocks[i].free_size = c->sector_size;\n\t}\n\n\tINIT_LIST_HEAD(&c->clean_list);\n\tINIT_LIST_HEAD(&c->very_dirty_list);\n\tINIT_LIST_HEAD(&c->dirty_list);\n\tINIT_LIST_HEAD(&c->erasable_list);\n\tINIT_LIST_HEAD(&c->erasing_list);\n\tINIT_LIST_HEAD(&c->erase_checking_list);\n\tINIT_LIST_HEAD(&c->erase_pending_list);\n\tINIT_LIST_HEAD(&c->erasable_pending_wbuf_list);\n\tINIT_LIST_HEAD(&c->erase_complete_list);\n\tINIT_LIST_HEAD(&c->free_list);\n\tINIT_LIST_HEAD(&c->bad_list);\n\tINIT_LIST_HEAD(&c->bad_used_list);\n\tc->highest_ino = 1;\n\tc->summary = NULL;\n\n\tret = jffs2_sum_init(c);\n\tif (ret)\n\t\tgoto out_free;\n\n\tif (jffs2_build_filesystem(c)) {\n\t\tdbg_fsbuild(\"build_fs failed\\n\");\n\t\tjffs2_free_ino_caches(c);\n\t\tjffs2_free_raw_node_refs(c);\n\t\tret = -EIO;\n\t\tgoto out_sum_exit;\n\t}\n\n\tjffs2_calc_trigger_levels(c);\n\n\treturn 0;\n\n out_sum_exit:\n\tjffs2_sum_exit(c);\n out_free:\n\tkvfree(c->blocks);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}