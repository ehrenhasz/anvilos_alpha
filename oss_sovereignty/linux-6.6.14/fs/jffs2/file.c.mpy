{
  "module_name": "file.c",
  "hash_id": "4b4d938d4fb06e5001639982cab7156190c5ce606e65ef1dffe36dbbac98bb42",
  "original_prompt": "Ingested from linux-6.6.14/fs/jffs2/file.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/crc32.h>\n#include <linux/jffs2.h>\n#include \"nodelist.h\"\n\nstatic int jffs2_write_end(struct file *filp, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *pg, void *fsdata);\nstatic int jffs2_write_begin(struct file *filp, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len,\n\t\t\tstruct page **pagep, void **fsdata);\nstatic int jffs2_read_folio(struct file *filp, struct folio *folio);\n\nint jffs2_fsync(struct file *filp, loff_t start, loff_t end, int datasync)\n{\n\tstruct inode *inode = filp->f_mapping->host;\n\tstruct jffs2_sb_info *c = JFFS2_SB_INFO(inode->i_sb);\n\tint ret;\n\n\tret = file_write_and_wait_range(filp, start, end);\n\tif (ret)\n\t\treturn ret;\n\n\tinode_lock(inode);\n\t \n\tjffs2_flush_wbuf_gc(c, inode->i_ino);\n\tinode_unlock(inode);\n\n\treturn 0;\n}\n\nconst struct file_operations jffs2_file_operations =\n{\n\t.llseek =\tgeneric_file_llseek,\n\t.open =\t\tgeneric_file_open,\n \t.read_iter =\tgeneric_file_read_iter,\n \t.write_iter =\tgeneric_file_write_iter,\n\t.unlocked_ioctl=jffs2_ioctl,\n\t.mmap =\t\tgeneric_file_readonly_mmap,\n\t.fsync =\tjffs2_fsync,\n\t.splice_read =\tfilemap_splice_read,\n\t.splice_write = iter_file_splice_write,\n};\n\n \n\nconst struct inode_operations jffs2_file_inode_operations =\n{\n\t.get_inode_acl =\tjffs2_get_acl,\n\t.set_acl =\tjffs2_set_acl,\n\t.setattr =\tjffs2_setattr,\n\t.listxattr =\tjffs2_listxattr,\n};\n\nconst struct address_space_operations jffs2_file_address_operations =\n{\n\t.read_folio =\tjffs2_read_folio,\n\t.write_begin =\tjffs2_write_begin,\n\t.write_end =\tjffs2_write_end,\n};\n\nstatic int jffs2_do_readpage_nolock (struct inode *inode, struct page *pg)\n{\n\tstruct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);\n\tstruct jffs2_sb_info *c = JFFS2_SB_INFO(inode->i_sb);\n\tunsigned char *pg_buf;\n\tint ret;\n\n\tjffs2_dbg(2, \"%s(): ino #%lu, page at offset 0x%lx\\n\",\n\t\t  __func__, inode->i_ino, pg->index << PAGE_SHIFT);\n\n\tBUG_ON(!PageLocked(pg));\n\n\tpg_buf = kmap(pg);\n\t \n\n\tret = jffs2_read_inode_range(c, f, pg_buf, pg->index << PAGE_SHIFT,\n\t\t\t\t     PAGE_SIZE);\n\n\tif (ret) {\n\t\tClearPageUptodate(pg);\n\t\tSetPageError(pg);\n\t} else {\n\t\tSetPageUptodate(pg);\n\t\tClearPageError(pg);\n\t}\n\n\tflush_dcache_page(pg);\n\tkunmap(pg);\n\n\tjffs2_dbg(2, \"readpage finished\\n\");\n\treturn ret;\n}\n\nint __jffs2_read_folio(struct file *file, struct folio *folio)\n{\n\tint ret = jffs2_do_readpage_nolock(folio->mapping->host, &folio->page);\n\tfolio_unlock(folio);\n\treturn ret;\n}\n\nstatic int jffs2_read_folio(struct file *file, struct folio *folio)\n{\n\tstruct jffs2_inode_info *f = JFFS2_INODE_INFO(folio->mapping->host);\n\tint ret;\n\n\tmutex_lock(&f->sem);\n\tret = __jffs2_read_folio(file, folio);\n\tmutex_unlock(&f->sem);\n\treturn ret;\n}\n\nstatic int jffs2_write_begin(struct file *filp, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len,\n\t\t\tstruct page **pagep, void **fsdata)\n{\n\tstruct page *pg;\n\tstruct inode *inode = mapping->host;\n\tstruct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);\n\tstruct jffs2_sb_info *c = JFFS2_SB_INFO(inode->i_sb);\n\tpgoff_t index = pos >> PAGE_SHIFT;\n\tint ret = 0;\n\n\tjffs2_dbg(1, \"%s()\\n\", __func__);\n\n\tif (pos > inode->i_size) {\n\t\t \n\t\tstruct jffs2_raw_inode ri;\n\t\tstruct jffs2_full_dnode *fn;\n\t\tuint32_t alloc_len;\n\n\t\tjffs2_dbg(1, \"Writing new hole frag 0x%x-0x%x between current EOF and new position\\n\",\n\t\t\t  (unsigned int)inode->i_size, (uint32_t)pos);\n\n\t\tret = jffs2_reserve_space(c, sizeof(ri), &alloc_len,\n\t\t\t\t\t  ALLOC_NORMAL, JFFS2_SUMMARY_INODE_SIZE);\n\t\tif (ret)\n\t\t\tgoto out_err;\n\n\t\tmutex_lock(&f->sem);\n\t\tmemset(&ri, 0, sizeof(ri));\n\n\t\tri.magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);\n\t\tri.nodetype = cpu_to_je16(JFFS2_NODETYPE_INODE);\n\t\tri.totlen = cpu_to_je32(sizeof(ri));\n\t\tri.hdr_crc = cpu_to_je32(crc32(0, &ri, sizeof(struct jffs2_unknown_node)-4));\n\n\t\tri.ino = cpu_to_je32(f->inocache->ino);\n\t\tri.version = cpu_to_je32(++f->highest_version);\n\t\tri.mode = cpu_to_jemode(inode->i_mode);\n\t\tri.uid = cpu_to_je16(i_uid_read(inode));\n\t\tri.gid = cpu_to_je16(i_gid_read(inode));\n\t\tri.isize = cpu_to_je32((uint32_t)pos);\n\t\tri.atime = ri.ctime = ri.mtime = cpu_to_je32(JFFS2_NOW());\n\t\tri.offset = cpu_to_je32(inode->i_size);\n\t\tri.dsize = cpu_to_je32((uint32_t)pos - inode->i_size);\n\t\tri.csize = cpu_to_je32(0);\n\t\tri.compr = JFFS2_COMPR_ZERO;\n\t\tri.node_crc = cpu_to_je32(crc32(0, &ri, sizeof(ri)-8));\n\t\tri.data_crc = cpu_to_je32(0);\n\n\t\tfn = jffs2_write_dnode(c, f, &ri, NULL, 0, ALLOC_NORMAL);\n\n\t\tif (IS_ERR(fn)) {\n\t\t\tret = PTR_ERR(fn);\n\t\t\tjffs2_complete_reservation(c);\n\t\t\tmutex_unlock(&f->sem);\n\t\t\tgoto out_err;\n\t\t}\n\t\tret = jffs2_add_full_dnode_to_inode(c, f, fn);\n\t\tif (f->metadata) {\n\t\t\tjffs2_mark_node_obsolete(c, f->metadata->raw);\n\t\t\tjffs2_free_full_dnode(f->metadata);\n\t\t\tf->metadata = NULL;\n\t\t}\n\t\tif (ret) {\n\t\t\tjffs2_dbg(1, \"Eep. add_full_dnode_to_inode() failed in write_begin, returned %d\\n\",\n\t\t\t\t  ret);\n\t\t\tjffs2_mark_node_obsolete(c, fn->raw);\n\t\t\tjffs2_free_full_dnode(fn);\n\t\t\tjffs2_complete_reservation(c);\n\t\t\tmutex_unlock(&f->sem);\n\t\t\tgoto out_err;\n\t\t}\n\t\tjffs2_complete_reservation(c);\n\t\tinode->i_size = pos;\n\t\tmutex_unlock(&f->sem);\n\t}\n\n\t \n\tmutex_lock(&c->alloc_sem);\n\tpg = grab_cache_page_write_begin(mapping, index);\n\tif (!pg) {\n\t\tret = -ENOMEM;\n\t\tgoto release_sem;\n\t}\n\t*pagep = pg;\n\n\t \n\tif (!PageUptodate(pg)) {\n\t\tmutex_lock(&f->sem);\n\t\tret = jffs2_do_readpage_nolock(inode, pg);\n\t\tmutex_unlock(&f->sem);\n\t\tif (ret) {\n\t\t\tunlock_page(pg);\n\t\t\tput_page(pg);\n\t\t\tgoto release_sem;\n\t\t}\n\t}\n\tjffs2_dbg(1, \"end write_begin(). pg->flags %lx\\n\", pg->flags);\n\nrelease_sem:\n\tmutex_unlock(&c->alloc_sem);\nout_err:\n\treturn ret;\n}\n\nstatic int jffs2_write_end(struct file *filp, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *pg, void *fsdata)\n{\n\t \n\tstruct inode *inode = mapping->host;\n\tstruct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);\n\tstruct jffs2_sb_info *c = JFFS2_SB_INFO(inode->i_sb);\n\tstruct jffs2_raw_inode *ri;\n\tunsigned start = pos & (PAGE_SIZE - 1);\n\tunsigned end = start + copied;\n\tunsigned aligned_start = start & ~3;\n\tint ret = 0;\n\tuint32_t writtenlen = 0;\n\n\tjffs2_dbg(1, \"%s(): ino #%lu, page at 0x%lx, range %d-%d, flags %lx\\n\",\n\t\t  __func__, inode->i_ino, pg->index << PAGE_SHIFT,\n\t\t  start, end, pg->flags);\n\n\t \n\tBUG_ON(!PageUptodate(pg));\n\n\tif (end == PAGE_SIZE) {\n\t\t \n\t\taligned_start = 0;\n\t}\n\n\tri = jffs2_alloc_raw_inode();\n\n\tif (!ri) {\n\t\tjffs2_dbg(1, \"%s(): Allocation of raw inode failed\\n\",\n\t\t\t  __func__);\n\t\tunlock_page(pg);\n\t\tput_page(pg);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tri->ino = cpu_to_je32(inode->i_ino);\n\tri->mode = cpu_to_jemode(inode->i_mode);\n\tri->uid = cpu_to_je16(i_uid_read(inode));\n\tri->gid = cpu_to_je16(i_gid_read(inode));\n\tri->isize = cpu_to_je32((uint32_t)inode->i_size);\n\tri->atime = ri->ctime = ri->mtime = cpu_to_je32(JFFS2_NOW());\n\n\t \n\tkmap(pg);\n\n\tret = jffs2_write_inode_range(c, f, ri, page_address(pg) + aligned_start,\n\t\t\t\t      (pg->index << PAGE_SHIFT) + aligned_start,\n\t\t\t\t      end - aligned_start, &writtenlen);\n\n\tkunmap(pg);\n\n\tif (ret) {\n\t\t \n\t\tSetPageError(pg);\n\t}\n\n\t \n\twrittenlen -= min(writtenlen, (start - aligned_start));\n\n\tif (writtenlen) {\n\t\tif (inode->i_size < pos + writtenlen) {\n\t\t\tinode->i_size = pos + writtenlen;\n\t\t\tinode->i_blocks = (inode->i_size + 511) >> 9;\n\n\t\t\tinode->i_mtime = inode_set_ctime_to_ts(inode,\n\t\t\t\t\t\t\t       ITIME(je32_to_cpu(ri->ctime)));\n\t\t}\n\t}\n\n\tjffs2_free_raw_inode(ri);\n\n\tif (start+writtenlen < end) {\n\t\t \n\t\tjffs2_dbg(1, \"%s(): Not all bytes written. Marking page !uptodate\\n\",\n\t\t\t__func__);\n\t\tSetPageError(pg);\n\t\tClearPageUptodate(pg);\n\t}\n\n\tjffs2_dbg(1, \"%s() returning %d\\n\",\n\t\t  __func__, writtenlen > 0 ? writtenlen : ret);\n\tunlock_page(pg);\n\tput_page(pg);\n\treturn writtenlen > 0 ? writtenlen : ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}