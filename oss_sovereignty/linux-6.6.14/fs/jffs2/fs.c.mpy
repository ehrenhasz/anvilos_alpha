{
  "module_name": "fs.c",
  "hash_id": "d34a2e43f258a1a901d3ef088edd6574213ac723ee5584e1f30ace67555f655d",
  "original_prompt": "Ingested from linux-6.6.14/fs/jffs2/fs.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/capability.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/cred.h>\n#include <linux/fs.h>\n#include <linux/fs_context.h>\n#include <linux/list.h>\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include \"nodelist.h\"\n\nstatic int jffs2_flash_setup(struct jffs2_sb_info *c);\n\nint jffs2_do_setattr (struct inode *inode, struct iattr *iattr)\n{\n\tstruct jffs2_full_dnode *old_metadata, *new_metadata;\n\tstruct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);\n\tstruct jffs2_sb_info *c = JFFS2_SB_INFO(inode->i_sb);\n\tstruct jffs2_raw_inode *ri;\n\tunion jffs2_device_node dev;\n\tunsigned char *mdata = NULL;\n\tint mdatalen = 0;\n\tunsigned int ivalid;\n\tuint32_t alloclen;\n\tint ret;\n\tint alloc_type = ALLOC_NORMAL;\n\n\tjffs2_dbg(1, \"%s(): ino #%lu\\n\", __func__, inode->i_ino);\n\n\t \n\tif (S_ISBLK(inode->i_mode) || S_ISCHR(inode->i_mode)) {\n\t\t \n\t\tmdatalen = jffs2_encode_dev(&dev, inode->i_rdev);\n\t\tmdata = (char *)&dev;\n\t\tjffs2_dbg(1, \"%s(): Writing %d bytes of kdev_t\\n\",\n\t\t\t  __func__, mdatalen);\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tmutex_lock(&f->sem);\n\t\tmdatalen = f->metadata->size;\n\t\tmdata = kmalloc(f->metadata->size, GFP_USER);\n\t\tif (!mdata) {\n\t\t\tmutex_unlock(&f->sem);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tret = jffs2_read_dnode(c, f, f->metadata, mdata, 0, mdatalen);\n\t\tif (ret) {\n\t\t\tmutex_unlock(&f->sem);\n\t\t\tkfree(mdata);\n\t\t\treturn ret;\n\t\t}\n\t\tmutex_unlock(&f->sem);\n\t\tjffs2_dbg(1, \"%s(): Writing %d bytes of symlink target\\n\",\n\t\t\t  __func__, mdatalen);\n\t}\n\n\tri = jffs2_alloc_raw_inode();\n\tif (!ri) {\n\t\tif (S_ISLNK(inode->i_mode))\n\t\t\tkfree(mdata);\n\t\treturn -ENOMEM;\n\t}\n\n\tret = jffs2_reserve_space(c, sizeof(*ri) + mdatalen, &alloclen,\n\t\t\t\t  ALLOC_NORMAL, JFFS2_SUMMARY_INODE_SIZE);\n\tif (ret) {\n\t\tjffs2_free_raw_inode(ri);\n\t\tif (S_ISLNK(inode->i_mode))\n\t\t\t kfree(mdata);\n\t\treturn ret;\n\t}\n\tmutex_lock(&f->sem);\n\tivalid = iattr->ia_valid;\n\n\tri->magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);\n\tri->nodetype = cpu_to_je16(JFFS2_NODETYPE_INODE);\n\tri->totlen = cpu_to_je32(sizeof(*ri) + mdatalen);\n\tri->hdr_crc = cpu_to_je32(crc32(0, ri, sizeof(struct jffs2_unknown_node)-4));\n\n\tri->ino = cpu_to_je32(inode->i_ino);\n\tri->version = cpu_to_je32(++f->highest_version);\n\n\tri->uid = cpu_to_je16((ivalid & ATTR_UID)?\n\t\tfrom_kuid(&init_user_ns, iattr->ia_uid):i_uid_read(inode));\n\tri->gid = cpu_to_je16((ivalid & ATTR_GID)?\n\t\tfrom_kgid(&init_user_ns, iattr->ia_gid):i_gid_read(inode));\n\n\tif (ivalid & ATTR_MODE)\n\t\tri->mode = cpu_to_jemode(iattr->ia_mode);\n\telse\n\t\tri->mode = cpu_to_jemode(inode->i_mode);\n\n\n\tri->isize = cpu_to_je32((ivalid & ATTR_SIZE)?iattr->ia_size:inode->i_size);\n\tri->atime = cpu_to_je32(I_SEC((ivalid & ATTR_ATIME)?iattr->ia_atime:inode->i_atime));\n\tri->mtime = cpu_to_je32(I_SEC((ivalid & ATTR_MTIME)?iattr->ia_mtime:inode->i_mtime));\n\tri->ctime = cpu_to_je32(I_SEC((ivalid & ATTR_CTIME)?iattr->ia_ctime:inode_get_ctime(inode)));\n\n\tri->offset = cpu_to_je32(0);\n\tri->csize = ri->dsize = cpu_to_je32(mdatalen);\n\tri->compr = JFFS2_COMPR_NONE;\n\tif (ivalid & ATTR_SIZE && inode->i_size < iattr->ia_size) {\n\t\t \n\t\tri->compr = JFFS2_COMPR_ZERO;\n\t\tri->dsize = cpu_to_je32(iattr->ia_size - inode->i_size);\n\t\tri->offset = cpu_to_je32(inode->i_size);\n\t} else if (ivalid & ATTR_SIZE && !iattr->ia_size) {\n\t\t \n\t\talloc_type = ALLOC_DELETION;\n\t}\n\tri->node_crc = cpu_to_je32(crc32(0, ri, sizeof(*ri)-8));\n\tif (mdatalen)\n\t\tri->data_crc = cpu_to_je32(crc32(0, mdata, mdatalen));\n\telse\n\t\tri->data_crc = cpu_to_je32(0);\n\n\tnew_metadata = jffs2_write_dnode(c, f, ri, mdata, mdatalen, alloc_type);\n\tif (S_ISLNK(inode->i_mode))\n\t\tkfree(mdata);\n\n\tif (IS_ERR(new_metadata)) {\n\t\tjffs2_complete_reservation(c);\n\t\tjffs2_free_raw_inode(ri);\n\t\tmutex_unlock(&f->sem);\n\t\treturn PTR_ERR(new_metadata);\n\t}\n\t \n\tinode->i_atime = ITIME(je32_to_cpu(ri->atime));\n\tinode_set_ctime_to_ts(inode, ITIME(je32_to_cpu(ri->ctime)));\n\tinode->i_mtime = ITIME(je32_to_cpu(ri->mtime));\n\tinode->i_mode = jemode_to_cpu(ri->mode);\n\ti_uid_write(inode, je16_to_cpu(ri->uid));\n\ti_gid_write(inode, je16_to_cpu(ri->gid));\n\n\n\told_metadata = f->metadata;\n\n\tif (ivalid & ATTR_SIZE && inode->i_size > iattr->ia_size)\n\t\tjffs2_truncate_fragtree (c, &f->fragtree, iattr->ia_size);\n\n\tif (ivalid & ATTR_SIZE && inode->i_size < iattr->ia_size) {\n\t\tjffs2_add_full_dnode_to_inode(c, f, new_metadata);\n\t\tinode->i_size = iattr->ia_size;\n\t\tinode->i_blocks = (inode->i_size + 511) >> 9;\n\t\tf->metadata = NULL;\n\t} else {\n\t\tf->metadata = new_metadata;\n\t}\n\tif (old_metadata) {\n\t\tjffs2_mark_node_obsolete(c, old_metadata->raw);\n\t\tjffs2_free_full_dnode(old_metadata);\n\t}\n\tjffs2_free_raw_inode(ri);\n\n\tmutex_unlock(&f->sem);\n\tjffs2_complete_reservation(c);\n\n\t \n\tif (ivalid & ATTR_SIZE && inode->i_size > iattr->ia_size) {\n\t\ttruncate_setsize(inode, iattr->ia_size);\n\t\tinode->i_blocks = (inode->i_size + 511) >> 9;\n\t}\n\n\treturn 0;\n}\n\nint jffs2_setattr(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\t  struct iattr *iattr)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tint rc;\n\n\trc = setattr_prepare(&nop_mnt_idmap, dentry, iattr);\n\tif (rc)\n\t\treturn rc;\n\n\trc = jffs2_do_setattr(inode, iattr);\n\tif (!rc && (iattr->ia_valid & ATTR_MODE))\n\t\trc = posix_acl_chmod(&nop_mnt_idmap, dentry, inode->i_mode);\n\n\treturn rc;\n}\n\nint jffs2_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct jffs2_sb_info *c = JFFS2_SB_INFO(dentry->d_sb);\n\tunsigned long avail;\n\n\tbuf->f_type = JFFS2_SUPER_MAGIC;\n\tbuf->f_bsize = 1 << PAGE_SHIFT;\n\tbuf->f_blocks = c->flash_size >> PAGE_SHIFT;\n\tbuf->f_files = 0;\n\tbuf->f_ffree = 0;\n\tbuf->f_namelen = JFFS2_MAX_NAME_LEN;\n\tbuf->f_fsid.val[0] = JFFS2_SUPER_MAGIC;\n\tbuf->f_fsid.val[1] = c->mtd->index;\n\n\tspin_lock(&c->erase_completion_lock);\n\tavail = c->dirty_size + c->free_size;\n\tif (avail > c->sector_size * c->resv_blocks_write)\n\t\tavail -= c->sector_size * c->resv_blocks_write;\n\telse\n\t\tavail = 0;\n\tspin_unlock(&c->erase_completion_lock);\n\n\tbuf->f_bavail = buf->f_bfree = avail >> PAGE_SHIFT;\n\n\treturn 0;\n}\n\n\nvoid jffs2_evict_inode (struct inode *inode)\n{\n\t \n\tstruct jffs2_sb_info *c = JFFS2_SB_INFO(inode->i_sb);\n\tstruct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);\n\n\tjffs2_dbg(1, \"%s(): ino #%lu mode %o\\n\",\n\t\t  __func__, inode->i_ino, inode->i_mode);\n\ttruncate_inode_pages_final(&inode->i_data);\n\tclear_inode(inode);\n\tjffs2_do_clear_inode(c, f);\n}\n\nstruct inode *jffs2_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct jffs2_inode_info *f;\n\tstruct jffs2_sb_info *c;\n\tstruct jffs2_raw_inode latest_node;\n\tunion jffs2_device_node jdev;\n\tstruct inode *inode;\n\tdev_t rdev = 0;\n\tint ret;\n\n\tjffs2_dbg(1, \"%s(): ino == %lu\\n\", __func__, ino);\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tf = JFFS2_INODE_INFO(inode);\n\tc = JFFS2_SB_INFO(inode->i_sb);\n\n\tjffs2_init_inode_info(f);\n\tmutex_lock(&f->sem);\n\n\tret = jffs2_do_read_inode(c, f, inode->i_ino, &latest_node);\n\tif (ret)\n\t\tgoto error;\n\n\tinode->i_mode = jemode_to_cpu(latest_node.mode);\n\ti_uid_write(inode, je16_to_cpu(latest_node.uid));\n\ti_gid_write(inode, je16_to_cpu(latest_node.gid));\n\tinode->i_size = je32_to_cpu(latest_node.isize);\n\tinode->i_atime = ITIME(je32_to_cpu(latest_node.atime));\n\tinode->i_mtime = ITIME(je32_to_cpu(latest_node.mtime));\n\tinode_set_ctime_to_ts(inode, ITIME(je32_to_cpu(latest_node.ctime)));\n\n\tset_nlink(inode, f->inocache->pino_nlink);\n\n\tinode->i_blocks = (inode->i_size + 511) >> 9;\n\n\tswitch (inode->i_mode & S_IFMT) {\n\n\tcase S_IFLNK:\n\t\tinode->i_op = &jffs2_symlink_inode_operations;\n\t\tinode->i_link = f->target;\n\t\tbreak;\n\n\tcase S_IFDIR:\n\t{\n\t\tstruct jffs2_full_dirent *fd;\n\t\tset_nlink(inode, 2);  \n\n\t\tfor (fd=f->dents; fd; fd = fd->next) {\n\t\t\tif (fd->type == DT_DIR && fd->ino)\n\t\t\t\tinc_nlink(inode);\n\t\t}\n\t\t \n\t\tif (inode->i_ino == 1)\n\t\t\tinc_nlink(inode);\n\n\t\tinode->i_op = &jffs2_dir_inode_operations;\n\t\tinode->i_fop = &jffs2_dir_operations;\n\t\tbreak;\n\t}\n\tcase S_IFREG:\n\t\tinode->i_op = &jffs2_file_inode_operations;\n\t\tinode->i_fop = &jffs2_file_operations;\n\t\tinode->i_mapping->a_ops = &jffs2_file_address_operations;\n\t\tinode->i_mapping->nrpages = 0;\n\t\tbreak;\n\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\t\t \n\t\tif (f->metadata->size != sizeof(jdev.old_id) &&\n\t\t    f->metadata->size != sizeof(jdev.new_id)) {\n\t\t\tpr_notice(\"Device node has strange size %d\\n\",\n\t\t\t\t  f->metadata->size);\n\t\t\tgoto error_io;\n\t\t}\n\t\tjffs2_dbg(1, \"Reading device numbers from flash\\n\");\n\t\tret = jffs2_read_dnode(c, f, f->metadata, (char *)&jdev, 0, f->metadata->size);\n\t\tif (ret < 0) {\n\t\t\t \n\t\t\tpr_notice(\"Read device numbers for inode %lu failed\\n\",\n\t\t\t\t  (unsigned long)inode->i_ino);\n\t\t\tgoto error;\n\t\t}\n\t\tif (f->metadata->size == sizeof(jdev.old_id))\n\t\t\trdev = old_decode_dev(je16_to_cpu(jdev.old_id));\n\t\telse\n\t\t\trdev = new_decode_dev(je32_to_cpu(jdev.new_id));\n\t\tfallthrough;\n\n\tcase S_IFSOCK:\n\tcase S_IFIFO:\n\t\tinode->i_op = &jffs2_file_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, rdev);\n\t\tbreak;\n\n\tdefault:\n\t\tpr_warn(\"%s(): Bogus i_mode %o for ino %lu\\n\",\n\t\t\t__func__, inode->i_mode, (unsigned long)inode->i_ino);\n\t}\n\n\tmutex_unlock(&f->sem);\n\n\tjffs2_dbg(1, \"jffs2_read_inode() returning\\n\");\n\tunlock_new_inode(inode);\n\treturn inode;\n\nerror_io:\n\tret = -EIO;\nerror:\n\tmutex_unlock(&f->sem);\n\tiget_failed(inode);\n\treturn ERR_PTR(ret);\n}\n\nvoid jffs2_dirty_inode(struct inode *inode, int flags)\n{\n\tstruct iattr iattr;\n\n\tif (!(inode->i_state & I_DIRTY_DATASYNC)) {\n\t\tjffs2_dbg(2, \"%s(): not calling setattr() for ino #%lu\\n\",\n\t\t\t  __func__, inode->i_ino);\n\t\treturn;\n\t}\n\n\tjffs2_dbg(1, \"%s(): calling setattr() for ino #%lu\\n\",\n\t\t  __func__, inode->i_ino);\n\n\tiattr.ia_valid = ATTR_MODE|ATTR_UID|ATTR_GID|ATTR_ATIME|ATTR_MTIME|ATTR_CTIME;\n\tiattr.ia_mode = inode->i_mode;\n\tiattr.ia_uid = inode->i_uid;\n\tiattr.ia_gid = inode->i_gid;\n\tiattr.ia_atime = inode->i_atime;\n\tiattr.ia_mtime = inode->i_mtime;\n\tiattr.ia_ctime = inode_get_ctime(inode);\n\n\tjffs2_do_setattr(inode, &iattr);\n}\n\nint jffs2_do_remount_fs(struct super_block *sb, struct fs_context *fc)\n{\n\tstruct jffs2_sb_info *c = JFFS2_SB_INFO(sb);\n\n\tif (c->flags & JFFS2_SB_FLAG_RO && !sb_rdonly(sb))\n\t\treturn -EROFS;\n\n\t \n\tif (!sb_rdonly(sb)) {\n\t\tjffs2_stop_garbage_collect_thread(c);\n\t\tmutex_lock(&c->alloc_sem);\n\t\tjffs2_flush_wbuf_pad(c);\n\t\tmutex_unlock(&c->alloc_sem);\n\t}\n\n\tif (!(fc->sb_flags & SB_RDONLY))\n\t\tjffs2_start_garbage_collect_thread(c);\n\n\tfc->sb_flags |= SB_NOATIME;\n\treturn 0;\n}\n\n \nstruct inode *jffs2_new_inode (struct inode *dir_i, umode_t mode, struct jffs2_raw_inode *ri)\n{\n\tstruct inode *inode;\n\tstruct super_block *sb = dir_i->i_sb;\n\tstruct jffs2_sb_info *c;\n\tstruct jffs2_inode_info *f;\n\tint ret;\n\n\tjffs2_dbg(1, \"%s(): dir_i %ld, mode 0x%x\\n\",\n\t\t  __func__, dir_i->i_ino, mode);\n\n\tc = JFFS2_SB_INFO(sb);\n\n\tinode = new_inode(sb);\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tf = JFFS2_INODE_INFO(inode);\n\tjffs2_init_inode_info(f);\n\tmutex_lock(&f->sem);\n\n\tmemset(ri, 0, sizeof(*ri));\n\t \n\tri->uid = cpu_to_je16(from_kuid(&init_user_ns, current_fsuid()));\n\n\tif (dir_i->i_mode & S_ISGID) {\n\t\tri->gid = cpu_to_je16(i_gid_read(dir_i));\n\t\tif (S_ISDIR(mode))\n\t\t\tmode |= S_ISGID;\n\t} else {\n\t\tri->gid = cpu_to_je16(from_kgid(&init_user_ns, current_fsgid()));\n\t}\n\n\t \n\tret = jffs2_init_acl_pre(dir_i, inode, &mode);\n\tif (ret) {\n\t\tmutex_unlock(&f->sem);\n\t\tmake_bad_inode(inode);\n\t\tiput(inode);\n\t\treturn ERR_PTR(ret);\n\t}\n\tret = jffs2_do_new_inode (c, f, mode, ri);\n\tif (ret) {\n\t\tmutex_unlock(&f->sem);\n\t\tmake_bad_inode(inode);\n\t\tiput(inode);\n\t\treturn ERR_PTR(ret);\n\t}\n\tset_nlink(inode, 1);\n\tinode->i_ino = je32_to_cpu(ri->ino);\n\tinode->i_mode = jemode_to_cpu(ri->mode);\n\ti_gid_write(inode, je16_to_cpu(ri->gid));\n\ti_uid_write(inode, je16_to_cpu(ri->uid));\n\tinode->i_atime = inode->i_mtime = inode_set_ctime_current(inode);\n\tri->atime = ri->mtime = ri->ctime = cpu_to_je32(I_SEC(inode->i_mtime));\n\n\tinode->i_blocks = 0;\n\tinode->i_size = 0;\n\n\tif (insert_inode_locked(inode) < 0) {\n\t\tmutex_unlock(&f->sem);\n\t\tmake_bad_inode(inode);\n\t\tiput(inode);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn inode;\n}\n\nstatic int calculate_inocache_hashsize(uint32_t flash_size)\n{\n\t \n\n\tint size_mb = flash_size / 1024 / 1024;\n\tint hashsize = (size_mb * 2) & ~0x3f;\n\n\tif (hashsize < INOCACHE_HASHSIZE_MIN)\n\t\treturn INOCACHE_HASHSIZE_MIN;\n\tif (hashsize > INOCACHE_HASHSIZE_MAX)\n\t\treturn INOCACHE_HASHSIZE_MAX;\n\n\treturn hashsize;\n}\n\nint jffs2_do_fill_super(struct super_block *sb, struct fs_context *fc)\n{\n\tstruct jffs2_sb_info *c;\n\tstruct inode *root_i;\n\tint ret;\n\tsize_t blocks;\n\n\tc = JFFS2_SB_INFO(sb);\n\n\t \n\tif (c->mtd->type == MTD_MLCNANDFLASH)\n\t\treturn -EINVAL;\n\n#ifndef CONFIG_JFFS2_FS_WRITEBUFFER\n\tif (c->mtd->type == MTD_NANDFLASH) {\n\t\terrorf(fc, \"Cannot operate on NAND flash unless jffs2 NAND support is compiled in\");\n\t\treturn -EINVAL;\n\t}\n\tif (c->mtd->type == MTD_DATAFLASH) {\n\t\terrorf(fc, \"Cannot operate on DataFlash unless jffs2 DataFlash support is compiled in\");\n\t\treturn -EINVAL;\n\t}\n#endif\n\n\tc->flash_size = c->mtd->size;\n\tc->sector_size = c->mtd->erasesize;\n\tblocks = c->flash_size / c->sector_size;\n\n\t \n\tif ((c->sector_size * blocks) != c->flash_size) {\n\t\tc->flash_size = c->sector_size * blocks;\n\t\tinfof(fc, \"Flash size not aligned to erasesize, reducing to %dKiB\",\n\t\t      c->flash_size / 1024);\n\t}\n\n\tif (c->flash_size < 5*c->sector_size) {\n\t\terrorf(fc, \"Too few erase blocks (%d)\",\n\t\t       c->flash_size / c->sector_size);\n\t\treturn -EINVAL;\n\t}\n\n\tc->cleanmarker_size = sizeof(struct jffs2_unknown_node);\n\n\t \n\tret = jffs2_flash_setup(c);\n\tif (ret)\n\t\treturn ret;\n\n\tc->inocache_hashsize = calculate_inocache_hashsize(c->flash_size);\n\tc->inocache_list = kcalloc(c->inocache_hashsize, sizeof(struct jffs2_inode_cache *), GFP_KERNEL);\n\tif (!c->inocache_list) {\n\t\tret = -ENOMEM;\n\t\tgoto out_wbuf;\n\t}\n\n\tjffs2_init_xattr_subsystem(c);\n\n\tif ((ret = jffs2_do_mount_fs(c)))\n\t\tgoto out_inohash;\n\n\tjffs2_dbg(1, \"%s(): Getting root inode\\n\", __func__);\n\troot_i = jffs2_iget(sb, 1);\n\tif (IS_ERR(root_i)) {\n\t\tjffs2_dbg(1, \"get root inode failed\\n\");\n\t\tret = PTR_ERR(root_i);\n\t\tgoto out_root;\n\t}\n\n\tret = -ENOMEM;\n\n\tjffs2_dbg(1, \"%s(): d_make_root()\\n\", __func__);\n\tsb->s_root = d_make_root(root_i);\n\tif (!sb->s_root)\n\t\tgoto out_root;\n\n\tsb->s_maxbytes = 0xFFFFFFFF;\n\tsb->s_blocksize = PAGE_SIZE;\n\tsb->s_blocksize_bits = PAGE_SHIFT;\n\tsb->s_magic = JFFS2_SUPER_MAGIC;\n\tsb->s_time_min = 0;\n\tsb->s_time_max = U32_MAX;\n\n\tif (!sb_rdonly(sb))\n\t\tjffs2_start_garbage_collect_thread(c);\n\treturn 0;\n\nout_root:\n\tjffs2_free_ino_caches(c);\n\tjffs2_free_raw_node_refs(c);\n\tkvfree(c->blocks);\n\tjffs2_clear_xattr_subsystem(c);\n\tjffs2_sum_exit(c);\n out_inohash:\n\tkfree(c->inocache_list);\n out_wbuf:\n\tjffs2_flash_cleanup(c);\n\n\treturn ret;\n}\n\nvoid jffs2_gc_release_inode(struct jffs2_sb_info *c,\n\t\t\t\t   struct jffs2_inode_info *f)\n{\n\tiput(OFNI_EDONI_2SFFJ(f));\n}\n\nstruct jffs2_inode_info *jffs2_gc_fetch_inode(struct jffs2_sb_info *c,\n\t\t\t\t\t      int inum, int unlinked)\n{\n\tstruct inode *inode;\n\tstruct jffs2_inode_cache *ic;\n\n\tif (unlinked) {\n\t\t \n\t\tinode = ilookup(OFNI_BS_2SFFJ(c), inum);\n\t\tif (!inode) {\n\t\t\tjffs2_dbg(1, \"ilookup() failed for ino #%u; inode is probably deleted.\\n\",\n\t\t\t\t  inum);\n\n\t\t\tspin_lock(&c->inocache_lock);\n\t\t\tic = jffs2_get_ino_cache(c, inum);\n\t\t\tif (!ic) {\n\t\t\t\tjffs2_dbg(1, \"Inode cache for ino #%u is gone\\n\",\n\t\t\t\t\t  inum);\n\t\t\t\tspin_unlock(&c->inocache_lock);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (ic->state != INO_STATE_CHECKEDABSENT) {\n\t\t\t\t \n\t\t\t\tjffs2_dbg(1, \"Waiting for ino #%u in state %d\\n\",\n\t\t\t\t\t  ic->ino, ic->state);\n\t\t\t\tsleep_on_spinunlock(&c->inocache_wq, &c->inocache_lock);\n\t\t\t} else {\n\t\t\t\tspin_unlock(&c->inocache_lock);\n\t\t\t}\n\n\t\t\treturn NULL;\n\t\t}\n\t} else {\n\t\t \n\t\tinode = jffs2_iget(OFNI_BS_2SFFJ(c), inum);\n\t\tif (IS_ERR(inode))\n\t\t\treturn ERR_CAST(inode);\n\t}\n\tif (is_bad_inode(inode)) {\n\t\tpr_notice(\"Eep. read_inode() failed for ino #%u. unlinked %d\\n\",\n\t\t\t  inum, unlinked);\n\t\t \n\t\tiput(inode);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\treturn JFFS2_INODE_INFO(inode);\n}\n\nstatic int jffs2_flash_setup(struct jffs2_sb_info *c) {\n\tint ret = 0;\n\n\tif (jffs2_cleanmarker_oob(c)) {\n\t\t \n\t\tret = jffs2_nand_flash_setup(c);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (jffs2_dataflash(c)) {\n\t\tret = jffs2_dataflash_setup(c);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (jffs2_nor_wbuf_flash(c)) {\n\t\tret = jffs2_nor_wbuf_flash_setup(c);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (jffs2_ubivol(c)) {\n\t\tret = jffs2_ubivol_setup(c);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nvoid jffs2_flash_cleanup(struct jffs2_sb_info *c) {\n\n\tif (jffs2_cleanmarker_oob(c)) {\n\t\tjffs2_nand_flash_cleanup(c);\n\t}\n\n\t \n\tif (jffs2_dataflash(c)) {\n\t\tjffs2_dataflash_cleanup(c);\n\t}\n\n\t \n\tif (jffs2_nor_wbuf_flash(c)) {\n\t\tjffs2_nor_wbuf_flash_cleanup(c);\n\t}\n\n\t \n\tif (jffs2_ubivol(c)) {\n\t\tjffs2_ubivol_cleanup(c);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}