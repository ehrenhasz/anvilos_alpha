{
  "module_name": "compr.c",
  "hash_id": "bb7c21d19a2934af85b9d7a51463c07e071d568fd7a911bcfa843e2ad17ba17a",
  "original_prompt": "Ingested from linux-6.6.14/fs/jffs2/compr.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include \"compr.h\"\n\nstatic DEFINE_SPINLOCK(jffs2_compressor_list_lock);\n\n \nstatic LIST_HEAD(jffs2_compressor_list);\n\n \nstatic int jffs2_compression_mode = JFFS2_COMPR_MODE_PRIORITY;\n\n \nstatic uint32_t none_stat_compr_blocks=0,none_stat_decompr_blocks=0,none_stat_compr_size=0;\n\n\n \nstatic int jffs2_is_best_compression(struct jffs2_compressor *this,\n\t\tstruct jffs2_compressor *best, uint32_t size, uint32_t bestsize)\n{\n\tswitch (jffs2_compression_mode) {\n\tcase JFFS2_COMPR_MODE_SIZE:\n\t\tif (bestsize > size)\n\t\t\treturn 1;\n\t\treturn 0;\n\tcase JFFS2_COMPR_MODE_FAVOURLZO:\n\t\tif ((this->compr == JFFS2_COMPR_LZO) && (bestsize > size))\n\t\t\treturn 1;\n\t\tif ((best->compr != JFFS2_COMPR_LZO) && (bestsize > size))\n\t\t\treturn 1;\n\t\tif ((this->compr == JFFS2_COMPR_LZO) && (bestsize > (size * FAVOUR_LZO_PERCENT / 100)))\n\t\t\treturn 1;\n\t\tif ((bestsize * FAVOUR_LZO_PERCENT / 100) > size)\n\t\t\treturn 1;\n\n\t\treturn 0;\n\t}\n\t \n\treturn 0;\n}\n\n \nstatic int jffs2_selected_compress(u8 compr, unsigned char *data_in,\n\t\tunsigned char **cpage_out, u32 *datalen, u32 *cdatalen)\n{\n\tstruct jffs2_compressor *this;\n\tint err, ret = JFFS2_COMPR_NONE;\n\tuint32_t orig_slen, orig_dlen;\n\tchar *output_buf;\n\n\toutput_buf = kmalloc(*cdatalen, GFP_KERNEL);\n\tif (!output_buf) {\n\t\tpr_warn(\"No memory for compressor allocation. Compression failed.\\n\");\n\t\treturn ret;\n\t}\n\torig_slen = *datalen;\n\torig_dlen = *cdatalen;\n\tspin_lock(&jffs2_compressor_list_lock);\n\tlist_for_each_entry(this, &jffs2_compressor_list, list) {\n\t\t \n\t\tif (!this->compress || this->disabled)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (compr && (compr != this->compr))\n\t\t\tcontinue;\n\n\t\t \n\t\tthis->usecount++;\n\t\tspin_unlock(&jffs2_compressor_list_lock);\n\n\t\t*datalen  = orig_slen;\n\t\t*cdatalen = orig_dlen;\n\t\terr = this->compress(data_in, output_buf, datalen, cdatalen);\n\n\t\tspin_lock(&jffs2_compressor_list_lock);\n\t\tthis->usecount--;\n\t\tif (!err) {\n\t\t\t \n\t\t\tret = this->compr;\n\t\t\tthis->stat_compr_blocks++;\n\t\t\tthis->stat_compr_orig_size += *datalen;\n\t\t\tthis->stat_compr_new_size += *cdatalen;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&jffs2_compressor_list_lock);\n\tif (ret == JFFS2_COMPR_NONE)\n\t\tkfree(output_buf);\n\telse\n\t\t*cpage_out = output_buf;\n\n\treturn ret;\n}\n\n \nuint16_t jffs2_compress(struct jffs2_sb_info *c, struct jffs2_inode_info *f,\n\t\t\tunsigned char *data_in, unsigned char **cpage_out,\n\t\t\tuint32_t *datalen, uint32_t *cdatalen)\n{\n\tint ret = JFFS2_COMPR_NONE;\n\tint mode, compr_ret;\n\tstruct jffs2_compressor *this, *best=NULL;\n\tunsigned char *output_buf = NULL, *tmp_buf;\n\tuint32_t orig_slen, orig_dlen;\n\tuint32_t best_slen=0, best_dlen=0;\n\n\tif (c->mount_opts.override_compr)\n\t\tmode = c->mount_opts.compr;\n\telse\n\t\tmode = jffs2_compression_mode;\n\n\tswitch (mode) {\n\tcase JFFS2_COMPR_MODE_NONE:\n\t\tbreak;\n\tcase JFFS2_COMPR_MODE_PRIORITY:\n\t\tret = jffs2_selected_compress(0, data_in, cpage_out, datalen,\n\t\t\t\tcdatalen);\n\t\tbreak;\n\tcase JFFS2_COMPR_MODE_SIZE:\n\tcase JFFS2_COMPR_MODE_FAVOURLZO:\n\t\torig_slen = *datalen;\n\t\torig_dlen = *cdatalen;\n\t\tspin_lock(&jffs2_compressor_list_lock);\n\t\tlist_for_each_entry(this, &jffs2_compressor_list, list) {\n\t\t\t \n\t\t\tif ((!this->compress)||(this->disabled))\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tif ((this->compr_buf_size < orig_slen) && (this->compr_buf)) {\n\t\t\t\tspin_unlock(&jffs2_compressor_list_lock);\n\t\t\t\tkfree(this->compr_buf);\n\t\t\t\tspin_lock(&jffs2_compressor_list_lock);\n\t\t\t\tthis->compr_buf_size=0;\n\t\t\t\tthis->compr_buf=NULL;\n\t\t\t}\n\t\t\tif (!this->compr_buf) {\n\t\t\t\tspin_unlock(&jffs2_compressor_list_lock);\n\t\t\t\ttmp_buf = kmalloc(orig_slen, GFP_KERNEL);\n\t\t\t\tspin_lock(&jffs2_compressor_list_lock);\n\t\t\t\tif (!tmp_buf) {\n\t\t\t\t\tpr_warn(\"No memory for compressor allocation. (%d bytes)\\n\",\n\t\t\t\t\t\torig_slen);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis->compr_buf = tmp_buf;\n\t\t\t\t\tthis->compr_buf_size = orig_slen;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis->usecount++;\n\t\t\tspin_unlock(&jffs2_compressor_list_lock);\n\t\t\t*datalen  = orig_slen;\n\t\t\t*cdatalen = orig_dlen;\n\t\t\tcompr_ret = this->compress(data_in, this->compr_buf, datalen, cdatalen);\n\t\t\tspin_lock(&jffs2_compressor_list_lock);\n\t\t\tthis->usecount--;\n\t\t\tif (!compr_ret) {\n\t\t\t\tif (((!best_dlen) || jffs2_is_best_compression(this, best, *cdatalen, best_dlen))\n\t\t\t\t\t\t&& (*cdatalen < *datalen)) {\n\t\t\t\t\tbest_dlen = *cdatalen;\n\t\t\t\t\tbest_slen = *datalen;\n\t\t\t\t\tbest = this;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (best_dlen) {\n\t\t\t*cdatalen = best_dlen;\n\t\t\t*datalen  = best_slen;\n\t\t\toutput_buf = best->compr_buf;\n\t\t\tbest->compr_buf = NULL;\n\t\t\tbest->compr_buf_size = 0;\n\t\t\tbest->stat_compr_blocks++;\n\t\t\tbest->stat_compr_orig_size += best_slen;\n\t\t\tbest->stat_compr_new_size  += best_dlen;\n\t\t\tret = best->compr;\n\t\t\t*cpage_out = output_buf;\n\t\t}\n\t\tspin_unlock(&jffs2_compressor_list_lock);\n\t\tbreak;\n\tcase JFFS2_COMPR_MODE_FORCELZO:\n\t\tret = jffs2_selected_compress(JFFS2_COMPR_LZO, data_in,\n\t\t\t\tcpage_out, datalen, cdatalen);\n\t\tbreak;\n\tcase JFFS2_COMPR_MODE_FORCEZLIB:\n\t\tret = jffs2_selected_compress(JFFS2_COMPR_ZLIB, data_in,\n\t\t\t\tcpage_out, datalen, cdatalen);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"unknown compression mode\\n\");\n\t}\n\n\tif (ret == JFFS2_COMPR_NONE) {\n\t\t*cpage_out = data_in;\n\t\t*datalen = *cdatalen;\n\t\tnone_stat_compr_blocks++;\n\t\tnone_stat_compr_size += *datalen;\n\t}\n\treturn ret;\n}\n\nint jffs2_decompress(struct jffs2_sb_info *c, struct jffs2_inode_info *f,\n\t\t     uint16_t comprtype, unsigned char *cdata_in,\n\t\t     unsigned char *data_out, uint32_t cdatalen, uint32_t datalen)\n{\n\tstruct jffs2_compressor *this;\n\tint ret;\n\n\t \n\tif ((comprtype & 0xff) <= JFFS2_COMPR_ZLIB)\n\t\tcomprtype &= 0xff;\n\n\tswitch (comprtype & 0xff) {\n\tcase JFFS2_COMPR_NONE:\n\t\t \n\t\tmemcpy(data_out, cdata_in, datalen);\n\t\tnone_stat_decompr_blocks++;\n\t\tbreak;\n\tcase JFFS2_COMPR_ZERO:\n\t\tmemset(data_out, 0, datalen);\n\t\tbreak;\n\tdefault:\n\t\tspin_lock(&jffs2_compressor_list_lock);\n\t\tlist_for_each_entry(this, &jffs2_compressor_list, list) {\n\t\t\tif (comprtype == this->compr) {\n\t\t\t\tthis->usecount++;\n\t\t\t\tspin_unlock(&jffs2_compressor_list_lock);\n\t\t\t\tret = this->decompress(cdata_in, data_out, cdatalen, datalen);\n\t\t\t\tspin_lock(&jffs2_compressor_list_lock);\n\t\t\t\tif (ret) {\n\t\t\t\t\tpr_warn(\"Decompressor \\\"%s\\\" returned %d\\n\",\n\t\t\t\t\t\tthis->name, ret);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis->stat_decompr_blocks++;\n\t\t\t\t}\n\t\t\t\tthis->usecount--;\n\t\t\t\tspin_unlock(&jffs2_compressor_list_lock);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tpr_warn(\"compression type 0x%02x not available\\n\", comprtype);\n\t\tspin_unlock(&jffs2_compressor_list_lock);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nint jffs2_register_compressor(struct jffs2_compressor *comp)\n{\n\tstruct jffs2_compressor *this;\n\n\tif (!comp->name) {\n\t\tpr_warn(\"NULL compressor name at registering JFFS2 compressor. Failed.\\n\");\n\t\treturn -1;\n\t}\n\tcomp->compr_buf_size=0;\n\tcomp->compr_buf=NULL;\n\tcomp->usecount=0;\n\tcomp->stat_compr_orig_size=0;\n\tcomp->stat_compr_new_size=0;\n\tcomp->stat_compr_blocks=0;\n\tcomp->stat_decompr_blocks=0;\n\tjffs2_dbg(1, \"Registering JFFS2 compressor \\\"%s\\\"\\n\", comp->name);\n\n\tspin_lock(&jffs2_compressor_list_lock);\n\n\tlist_for_each_entry(this, &jffs2_compressor_list, list) {\n\t\tif (this->priority < comp->priority) {\n\t\t\tlist_add(&comp->list, this->list.prev);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tlist_add_tail(&comp->list, &jffs2_compressor_list);\nout:\n\tD2(list_for_each_entry(this, &jffs2_compressor_list, list) {\n\t\tprintk(KERN_DEBUG \"Compressor \\\"%s\\\", prio %d\\n\", this->name, this->priority);\n\t})\n\n\tspin_unlock(&jffs2_compressor_list_lock);\n\n\treturn 0;\n}\n\nint jffs2_unregister_compressor(struct jffs2_compressor *comp)\n{\n\tD2(struct jffs2_compressor *this);\n\n\tjffs2_dbg(1, \"Unregistering JFFS2 compressor \\\"%s\\\"\\n\", comp->name);\n\n\tspin_lock(&jffs2_compressor_list_lock);\n\n\tif (comp->usecount) {\n\t\tspin_unlock(&jffs2_compressor_list_lock);\n\t\tpr_warn(\"Compressor module is in use. Unregister failed.\\n\");\n\t\treturn -1;\n\t}\n\tlist_del(&comp->list);\n\n\tD2(list_for_each_entry(this, &jffs2_compressor_list, list) {\n\t\tprintk(KERN_DEBUG \"Compressor \\\"%s\\\", prio %d\\n\", this->name, this->priority);\n\t})\n\tspin_unlock(&jffs2_compressor_list_lock);\n\treturn 0;\n}\n\nvoid jffs2_free_comprbuf(unsigned char *comprbuf, unsigned char *orig)\n{\n\tif (orig != comprbuf)\n\t\tkfree(comprbuf);\n}\n\nint __init jffs2_compressors_init(void)\n{\n\tint ret = 0;\n \n\tret = jffs2_zlib_init();\n\tif (ret)\n\t\tgoto exit;\n\tret = jffs2_rtime_init();\n\tif (ret)\n\t\tgoto exit_zlib;\n\tret = jffs2_rubinmips_init();\n\tif (ret)\n\t\tgoto exit_rtime;\n\tret = jffs2_dynrubin_init();\n\tif (ret)\n\t\tgoto exit_runinmips;\n\tret = jffs2_lzo_init();\n\tif (ret)\n\t\tgoto exit_dynrubin;\n\n\n \n#ifdef CONFIG_JFFS2_CMODE_NONE\n\tjffs2_compression_mode = JFFS2_COMPR_MODE_NONE;\n\tjffs2_dbg(1, \"default compression mode: none\\n\");\n#else\n#ifdef CONFIG_JFFS2_CMODE_SIZE\n\tjffs2_compression_mode = JFFS2_COMPR_MODE_SIZE;\n\tjffs2_dbg(1, \"default compression mode: size\\n\");\n#else\n#ifdef CONFIG_JFFS2_CMODE_FAVOURLZO\n\tjffs2_compression_mode = JFFS2_COMPR_MODE_FAVOURLZO;\n\tjffs2_dbg(1, \"default compression mode: favourlzo\\n\");\n#else\n\tjffs2_dbg(1, \"default compression mode: priority\\n\");\n#endif\n#endif\n#endif\n\treturn 0;\n\nexit_dynrubin:\n\tjffs2_dynrubin_exit();\nexit_runinmips:\n\tjffs2_rubinmips_exit();\nexit_rtime:\n\tjffs2_rtime_exit();\nexit_zlib:\n\tjffs2_zlib_exit();\nexit:\n\treturn ret;\n}\n\nint jffs2_compressors_exit(void)\n{\n \n\tjffs2_lzo_exit();\n\tjffs2_dynrubin_exit();\n\tjffs2_rubinmips_exit();\n\tjffs2_rtime_exit();\n\tjffs2_zlib_exit();\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}