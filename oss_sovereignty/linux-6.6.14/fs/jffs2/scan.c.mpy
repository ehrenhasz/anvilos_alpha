{
  "module_name": "scan.c",
  "hash_id": "058ea8df125327ab3a3afabd47b3637945c2b2c3601200a2849bfad21eb27a08",
  "original_prompt": "Ingested from linux-6.6.14/fs/jffs2/scan.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/crc32.h>\n#include <linux/compiler.h>\n#include \"nodelist.h\"\n#include \"summary.h\"\n#include \"debug.h\"\n\n#define DEFAULT_EMPTY_SCAN_SIZE 256\n\n#define noisy_printk(noise, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (*(noise)) {\t\t\t\t\t\t\t\\\n\t\tpr_notice(fmt, ##__VA_ARGS__);\t\t\t\t\\\n\t\t(*(noise))--;\t\t\t\t\t\t\\\n\t\tif (!(*(noise)))\t\t\t\t\t\\\n\t\t\tpr_notice(\"Further such events for this erase block will not be printed\\n\"); \\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\nstatic uint32_t pseudo_random;\n\nstatic int jffs2_scan_eraseblock (struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t  unsigned char *buf, uint32_t buf_size, struct jffs2_summary *s);\n\n \nstatic int jffs2_scan_inode_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_inode *ri, uint32_t ofs, struct jffs2_summary *s);\nstatic int jffs2_scan_dirent_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_dirent *rd, uint32_t ofs, struct jffs2_summary *s);\n\nstatic inline int min_free(struct jffs2_sb_info *c)\n{\n\tuint32_t min = 2 * sizeof(struct jffs2_raw_inode);\n#ifdef CONFIG_JFFS2_FS_WRITEBUFFER\n\tif (!jffs2_can_mark_obsolete(c) && min < c->wbuf_pagesize)\n\t\treturn c->wbuf_pagesize;\n#endif\n\treturn min;\n\n}\n\nstatic inline uint32_t EMPTY_SCAN_SIZE(uint32_t sector_size) {\n\tif (sector_size < DEFAULT_EMPTY_SCAN_SIZE)\n\t\treturn sector_size;\n\telse\n\t\treturn DEFAULT_EMPTY_SCAN_SIZE;\n}\n\nstatic int file_dirty(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb)\n{\n\tint ret;\n\n\tif ((ret = jffs2_prealloc_raw_node_refs(c, jeb, 1)))\n\t\treturn ret;\n\tif ((ret = jffs2_scan_dirty_space(c, jeb, jeb->free_size)))\n\t\treturn ret;\n\t \n\tjeb->dirty_size += jeb->wasted_size;\n\tc->dirty_size += jeb->wasted_size;\n\tc->wasted_size -= jeb->wasted_size;\n\tjeb->wasted_size = 0;\n\tif (VERYDIRTY(c, jeb->dirty_size)) {\n\t\tlist_add(&jeb->list, &c->very_dirty_list);\n\t} else {\n\t\tlist_add(&jeb->list, &c->dirty_list);\n\t}\n\treturn 0;\n}\n\nint jffs2_scan_medium(struct jffs2_sb_info *c)\n{\n\tint i, ret;\n\tuint32_t empty_blocks = 0, bad_blocks = 0;\n\tunsigned char *flashbuf = NULL;\n\tuint32_t buf_size = 0;\n\tstruct jffs2_summary *s = NULL;  \n#ifndef __ECOS\n\tsize_t pointlen, try_size;\n\n\tret = mtd_point(c->mtd, 0, c->mtd->size, &pointlen,\n\t\t\t(void **)&flashbuf, NULL);\n\tif (!ret && pointlen < c->mtd->size) {\n\t\t \n\t\tjffs2_dbg(1, \"MTD point returned len too short: 0x%zx\\n\",\n\t\t\t  pointlen);\n\t\tmtd_unpoint(c->mtd, 0, pointlen);\n\t\tflashbuf = NULL;\n\t}\n\tif (ret && ret != -EOPNOTSUPP)\n\t\tjffs2_dbg(1, \"MTD point failed %d\\n\", ret);\n#endif\n\tif (!flashbuf) {\n\t\t \n\t\tif (jffs2_cleanmarker_oob(c))\n\t\t\ttry_size = c->sector_size;\n\t\telse\n\t\t\ttry_size = PAGE_SIZE;\n\n\t\tjffs2_dbg(1, \"Trying to allocate readbuf of %zu \"\n\t\t\t  \"bytes\\n\", try_size);\n\n\t\tflashbuf = mtd_kmalloc_up_to(c->mtd, &try_size);\n\t\tif (!flashbuf)\n\t\t\treturn -ENOMEM;\n\n\t\tjffs2_dbg(1, \"Allocated readbuf of %zu bytes\\n\",\n\t\t\t  try_size);\n\n\t\tbuf_size = (uint32_t)try_size;\n\t}\n\n\tif (jffs2_sum_active()) {\n\t\ts = kzalloc(sizeof(struct jffs2_summary), GFP_KERNEL);\n\t\tif (!s) {\n\t\t\tJFFS2_WARNING(\"Can't allocate memory for summary\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_buf;\n\t\t}\n\t}\n\n\tfor (i=0; i<c->nr_blocks; i++) {\n\t\tstruct jffs2_eraseblock *jeb = &c->blocks[i];\n\n\t\tcond_resched();\n\n\t\t \n\t\tjffs2_sum_reset_collected(s);\n\n\t\tret = jffs2_scan_eraseblock(c, jeb, buf_size?flashbuf:(flashbuf+jeb->offset),\n\t\t\t\t\t\tbuf_size, s);\n\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tjffs2_dbg_acct_paranoia_check_nolock(c, jeb);\n\n\t\t \n\t\tswitch(ret) {\n\t\tcase BLK_STATE_ALLFF:\n\t\t\t \n\t\t\tempty_blocks++;\n\t\t\tlist_add(&jeb->list, &c->erase_pending_list);\n\t\t\tc->nr_erasing_blocks++;\n\t\t\tbreak;\n\n\t\tcase BLK_STATE_CLEANMARKER:\n\t\t\t \n\t\t\tif (!jeb->dirty_size) {\n\t\t\t\t \n\t\t\t\tlist_add(&jeb->list, &c->free_list);\n\t\t\t\tc->nr_free_blocks++;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tjffs2_dbg(1, \"Adding all-dirty block at 0x%08x to erase_pending_list\\n\",\n\t\t\t\t\t  jeb->offset);\n\t\t\t\tlist_add(&jeb->list, &c->erase_pending_list);\n\t\t\t\tc->nr_erasing_blocks++;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase BLK_STATE_CLEAN:\n\t\t\t \n\t\t\tlist_add(&jeb->list, &c->clean_list);\n\t\t\tbreak;\n\n\t\tcase BLK_STATE_PARTDIRTY:\n\t\t\t \n\t\t\t \n\t\t\tif (jeb->free_size > min_free(c) &&\n\t\t\t\t\t(!c->nextblock || c->nextblock->free_size < jeb->free_size)) {\n\t\t\t\t \n\t\t\t\tif (c->nextblock) {\n\t\t\t\t\tret = file_dirty(c, c->nextblock);\n\t\t\t\t\tif (ret)\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t \n\t\t\t\t\tjffs2_sum_reset_collected(c->summary);\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tjffs2_sum_move_collected(c, s);\n\t\t\t\tjffs2_dbg(1, \"%s(): new nextblock = 0x%08x\\n\",\n\t\t\t\t\t  __func__, jeb->offset);\n\t\t\t\tc->nextblock = jeb;\n\t\t\t} else {\n\t\t\t\tret = file_dirty(c, jeb);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase BLK_STATE_ALLDIRTY:\n\t\t\t \n\t\t\t \n\t\t\tjffs2_dbg(1, \"Erase block at 0x%08x is not formatted. It will be erased\\n\",\n\t\t\t\t  jeb->offset);\n\t\t\tlist_add(&jeb->list, &c->erase_pending_list);\n\t\t\tc->nr_erasing_blocks++;\n\t\t\tbreak;\n\n\t\tcase BLK_STATE_BADBLOCK:\n\t\t\tjffs2_dbg(1, \"Block at 0x%08x is bad\\n\", jeb->offset);\n\t\t\tlist_add(&jeb->list, &c->bad_list);\n\t\t\tc->bad_size += c->sector_size;\n\t\t\tc->free_size -= c->sector_size;\n\t\t\tbad_blocks++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_warn(\"%s(): unknown block state\\n\", __func__);\n\t\t\tBUG();\n\t\t}\n\t}\n\n\t \n\tif (c->nextblock && (c->nextblock->dirty_size)) {\n\t\tc->nextblock->wasted_size += c->nextblock->dirty_size;\n\t\tc->wasted_size += c->nextblock->dirty_size;\n\t\tc->dirty_size -= c->nextblock->dirty_size;\n\t\tc->nextblock->dirty_size = 0;\n\t}\n#ifdef CONFIG_JFFS2_FS_WRITEBUFFER\n\tif (!jffs2_can_mark_obsolete(c) && c->wbuf_pagesize && c->nextblock && (c->nextblock->free_size % c->wbuf_pagesize)) {\n\t\t \n\n\t\tuint32_t skip = c->nextblock->free_size % c->wbuf_pagesize;\n\n\t\tjffs2_dbg(1, \"%s(): Skipping %d bytes in nextblock to ensure page alignment\\n\",\n\t\t\t  __func__, skip);\n\t\tjffs2_prealloc_raw_node_refs(c, c->nextblock, 1);\n\t\tjffs2_scan_dirty_space(c, c->nextblock, skip);\n\t}\n#endif\n\tif (c->nr_erasing_blocks) {\n\t\tif (!c->used_size && !c->unchecked_size &&\n\t\t\t((c->nr_free_blocks+empty_blocks+bad_blocks) != c->nr_blocks || bad_blocks == c->nr_blocks)) {\n\t\t\tpr_notice(\"Cowardly refusing to erase blocks on filesystem with no valid JFFS2 nodes\\n\");\n\t\t\tpr_notice(\"empty_blocks %d, bad_blocks %d, c->nr_blocks %d\\n\",\n\t\t\t\t  empty_blocks, bad_blocks, c->nr_blocks);\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tspin_lock(&c->erase_completion_lock);\n\t\tjffs2_garbage_collect_trigger(c);\n\t\tspin_unlock(&c->erase_completion_lock);\n\t}\n\tret = 0;\n out:\n\tjffs2_sum_reset_collected(s);\n\tkfree(s);\n out_buf:\n\tif (buf_size)\n\t\tkfree(flashbuf);\n#ifndef __ECOS\n\telse\n\t\tmtd_unpoint(c->mtd, 0, c->mtd->size);\n#endif\n\treturn ret;\n}\n\nstatic int jffs2_fill_scan_buf(struct jffs2_sb_info *c, void *buf,\n\t\t\t       uint32_t ofs, uint32_t len)\n{\n\tint ret;\n\tsize_t retlen;\n\n\tret = jffs2_flash_read(c, ofs, len, &retlen, buf);\n\tif (ret) {\n\t\tjffs2_dbg(1, \"mtd->read(0x%x bytes from 0x%x) returned %d\\n\",\n\t\t\t  len, ofs, ret);\n\t\treturn ret;\n\t}\n\tif (retlen < len) {\n\t\tjffs2_dbg(1, \"Read at 0x%x gave only 0x%zx bytes\\n\",\n\t\t\t  ofs, retlen);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nint jffs2_scan_classify_jeb(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb)\n{\n\tif ((jeb->used_size + jeb->unchecked_size) == PAD(c->cleanmarker_size) && !jeb->dirty_size\n\t    && (!jeb->first_node || !ref_next(jeb->first_node)) )\n\t\treturn BLK_STATE_CLEANMARKER;\n\n\t \n\telse if (!ISDIRTY(c->sector_size - (jeb->used_size + jeb->unchecked_size))) {\n\t\tc->dirty_size -= jeb->dirty_size;\n\t\tc->wasted_size += jeb->dirty_size;\n\t\tjeb->wasted_size += jeb->dirty_size;\n\t\tjeb->dirty_size = 0;\n\t\treturn BLK_STATE_CLEAN;\n\t} else if (jeb->used_size || jeb->unchecked_size)\n\t\treturn BLK_STATE_PARTDIRTY;\n\telse\n\t\treturn BLK_STATE_ALLDIRTY;\n}\n\n#ifdef CONFIG_JFFS2_FS_XATTR\nstatic int jffs2_scan_xattr_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_xattr *rx, uint32_t ofs,\n\t\t\t\t struct jffs2_summary *s)\n{\n\tstruct jffs2_xattr_datum *xd;\n\tuint32_t xid, version, totlen, crc;\n\tint err;\n\n\tcrc = crc32(0, rx, sizeof(struct jffs2_raw_xattr) - 4);\n\tif (crc != je32_to_cpu(rx->node_crc)) {\n\t\tJFFS2_WARNING(\"node CRC failed at %#08x, read=%#08x, calc=%#08x\\n\",\n\t\t\t      ofs, je32_to_cpu(rx->node_crc), crc);\n\t\tif ((err = jffs2_scan_dirty_space(c, jeb, je32_to_cpu(rx->totlen))))\n\t\t\treturn err;\n\t\treturn 0;\n\t}\n\n\txid = je32_to_cpu(rx->xid);\n\tversion = je32_to_cpu(rx->version);\n\n\ttotlen = PAD(sizeof(struct jffs2_raw_xattr)\n\t\t\t+ rx->name_len + 1 + je16_to_cpu(rx->value_len));\n\tif (totlen != je32_to_cpu(rx->totlen)) {\n\t\tJFFS2_WARNING(\"node length mismatch at %#08x, read=%u, calc=%u\\n\",\n\t\t\t      ofs, je32_to_cpu(rx->totlen), totlen);\n\t\tif ((err = jffs2_scan_dirty_space(c, jeb, je32_to_cpu(rx->totlen))))\n\t\t\treturn err;\n\t\treturn 0;\n\t}\n\n\txd = jffs2_setup_xattr_datum(c, xid, version);\n\tif (IS_ERR(xd))\n\t\treturn PTR_ERR(xd);\n\n\tif (xd->version > version) {\n\t\tstruct jffs2_raw_node_ref *raw\n\t\t\t= jffs2_link_node_ref(c, jeb, ofs | REF_PRISTINE, totlen, NULL);\n\t\traw->next_in_ino = xd->node->next_in_ino;\n\t\txd->node->next_in_ino = raw;\n\t} else {\n\t\txd->version = version;\n\t\txd->xprefix = rx->xprefix;\n\t\txd->name_len = rx->name_len;\n\t\txd->value_len = je16_to_cpu(rx->value_len);\n\t\txd->data_crc = je32_to_cpu(rx->data_crc);\n\n\t\tjffs2_link_node_ref(c, jeb, ofs | REF_PRISTINE, totlen, (void *)xd);\n\t}\n\n\tif (jffs2_sum_active())\n\t\tjffs2_sum_add_xattr_mem(s, rx, ofs - jeb->offset);\n\tdbg_xattr(\"scanning xdatum at %#08x (xid=%u, version=%u)\\n\",\n\t\t  ofs, xd->xid, xd->version);\n\treturn 0;\n}\n\nstatic int jffs2_scan_xref_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\tstruct jffs2_raw_xref *rr, uint32_t ofs,\n\t\t\t\tstruct jffs2_summary *s)\n{\n\tstruct jffs2_xattr_ref *ref;\n\tuint32_t crc;\n\tint err;\n\n\tcrc = crc32(0, rr, sizeof(*rr) - 4);\n\tif (crc != je32_to_cpu(rr->node_crc)) {\n\t\tJFFS2_WARNING(\"node CRC failed at %#08x, read=%#08x, calc=%#08x\\n\",\n\t\t\t      ofs, je32_to_cpu(rr->node_crc), crc);\n\t\tif ((err = jffs2_scan_dirty_space(c, jeb, PAD(je32_to_cpu(rr->totlen)))))\n\t\t\treturn err;\n\t\treturn 0;\n\t}\n\n\tif (PAD(sizeof(struct jffs2_raw_xref)) != je32_to_cpu(rr->totlen)) {\n\t\tJFFS2_WARNING(\"node length mismatch at %#08x, read=%u, calc=%zd\\n\",\n\t\t\t      ofs, je32_to_cpu(rr->totlen),\n\t\t\t      PAD(sizeof(struct jffs2_raw_xref)));\n\t\tif ((err = jffs2_scan_dirty_space(c, jeb, je32_to_cpu(rr->totlen))))\n\t\t\treturn err;\n\t\treturn 0;\n\t}\n\n\tref = jffs2_alloc_xattr_ref();\n\tif (!ref)\n\t\treturn -ENOMEM;\n\n\t \n\tref->ino = je32_to_cpu(rr->ino);\n\tref->xid = je32_to_cpu(rr->xid);\n\tref->xseqno = je32_to_cpu(rr->xseqno);\n\tif (ref->xseqno > c->highest_xseqno)\n\t\tc->highest_xseqno = (ref->xseqno & ~XREF_DELETE_MARKER);\n\tref->next = c->xref_temp;\n\tc->xref_temp = ref;\n\n\tjffs2_link_node_ref(c, jeb, ofs | REF_PRISTINE, PAD(je32_to_cpu(rr->totlen)), (void *)ref);\n\n\tif (jffs2_sum_active())\n\t\tjffs2_sum_add_xref_mem(s, rr, ofs - jeb->offset);\n\tdbg_xattr(\"scan xref at %#08x (xid=%u, ino=%u)\\n\",\n\t\t  ofs, ref->xid, ref->ino);\n\treturn 0;\n}\n#endif\n\n \nstatic int jffs2_scan_eraseblock (struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t  unsigned char *buf, uint32_t buf_size, struct jffs2_summary *s) {\n\tstruct jffs2_unknown_node *node;\n\tstruct jffs2_unknown_node crcnode;\n\tuint32_t ofs, prevofs, max_ofs;\n\tuint32_t hdr_crc, buf_ofs, buf_len;\n\tint err;\n\tint noise = 0;\n\n\n#ifdef CONFIG_JFFS2_FS_WRITEBUFFER\n\tint cleanmarkerfound = 0;\n#endif\n\n\tofs = jeb->offset;\n\tprevofs = jeb->offset - 1;\n\n\tjffs2_dbg(1, \"%s(): Scanning block at 0x%x\\n\", __func__, ofs);\n\n#ifdef CONFIG_JFFS2_FS_WRITEBUFFER\n\tif (jffs2_cleanmarker_oob(c)) {\n\t\tint ret;\n\n\t\tif (mtd_block_isbad(c->mtd, jeb->offset))\n\t\t\treturn BLK_STATE_BADBLOCK;\n\n\t\tret = jffs2_check_nand_cleanmarker(c, jeb);\n\t\tjffs2_dbg(2, \"jffs_check_nand_cleanmarker returned %d\\n\", ret);\n\n\t\t \n\t\tswitch (ret) {\n\t\tcase 0:\t\tcleanmarkerfound = 1; break;\n\t\tcase 1: \tbreak;\n\t\tdefault: \treturn ret;\n\t\t}\n\t}\n#endif\n\n\tif (jffs2_sum_active()) {\n\t\tstruct jffs2_sum_marker *sm;\n\t\tvoid *sumptr = NULL;\n\t\tuint32_t sumlen;\n\t      \n\t\tif (!buf_size) {\n\t\t\t \n\t\t\tsm = (void *)buf + c->sector_size - sizeof(*sm);\n\t\t\tif (je32_to_cpu(sm->magic) == JFFS2_SUM_MAGIC) {\n\t\t\t\tsumptr = buf + je32_to_cpu(sm->offset);\n\t\t\t\tsumlen = c->sector_size - je32_to_cpu(sm->offset);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif (c->wbuf_pagesize)\n\t\t\t\tbuf_len = c->wbuf_pagesize;\n\t\t\telse\n\t\t\t\tbuf_len = sizeof(*sm);\n\n\t\t\t \n\t\t\terr = jffs2_fill_scan_buf(c, buf + buf_size - buf_len, \n\t\t\t\t\t\t  jeb->offset + c->sector_size - buf_len,\n\t\t\t\t\t\t  buf_len);\t\t\t\t\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tsm = (void *)buf + buf_size - sizeof(*sm);\n\t\t\tif (je32_to_cpu(sm->magic) == JFFS2_SUM_MAGIC) {\n\t\t\t\tsumlen = c->sector_size - je32_to_cpu(sm->offset);\n\t\t\t\tsumptr = buf + buf_size - sumlen;\n\n\t\t\t\t \n\t\t\t\tif (sumlen > c->sector_size)\n\t\t\t\t\tgoto full_scan;\n\n\t\t\t\t \n\t\t\t\tif (sumlen > buf_size) {\n\t\t\t\t\t \n\t\t\t\t\tsumptr = kmalloc(sumlen, GFP_KERNEL);\n\t\t\t\t\tif (!sumptr)\n\t\t\t\t\t\treturn -ENOMEM;\n\t\t\t\t\tmemcpy(sumptr + sumlen - buf_len, buf + buf_size - buf_len, buf_len);\n\t\t\t\t}\n\t\t\t\tif (buf_len < sumlen) {\n\t\t\t\t\t \n\t\t\t\t\terr = jffs2_fill_scan_buf(c, sumptr, \n\t\t\t\t\t\t\t\t  jeb->offset + c->sector_size - sumlen,\n\t\t\t\t\t\t\t\t  sumlen - buf_len);\t\t\t\t\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tif (sumlen > buf_size)\n\t\t\t\t\t\t\tkfree(sumptr);\n\t\t\t\t\t\treturn err;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tif (sumptr) {\n\t\t\terr = jffs2_sum_scan_sumnode(c, jeb, sumptr, sumlen, &pseudo_random);\n\n\t\t\tif (buf_size && sumlen > buf_size)\n\t\t\t\tkfree(sumptr);\n\t\t\t \n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\nfull_scan:\n\tbuf_ofs = jeb->offset;\n\n\tif (!buf_size) {\n\t\t \n\t\tbuf_len = c->sector_size;\n\t} else {\n\t\tbuf_len = EMPTY_SCAN_SIZE(c->sector_size);\n\t\terr = jffs2_fill_scan_buf(c, buf, buf_ofs, buf_len);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tofs = 0;\n\tmax_ofs = EMPTY_SCAN_SIZE(c->sector_size);\n\t \n\twhile(ofs < max_ofs && *(uint32_t *)(&buf[ofs]) == 0xFFFFFFFF)\n\t\tofs += 4;\n\n\tif (ofs == max_ofs) {\n#ifdef CONFIG_JFFS2_FS_WRITEBUFFER\n\t\tif (jffs2_cleanmarker_oob(c)) {\n\t\t\t \n\t\t\tint ret = jffs2_check_oob_empty(c, jeb, cleanmarkerfound);\n\t\t\tjffs2_dbg(2, \"jffs2_check_oob_empty returned %d\\n\",\n\t\t\t\t  ret);\n\t\t\tswitch (ret) {\n\t\t\tcase 0:\t\treturn cleanmarkerfound ? BLK_STATE_CLEANMARKER : BLK_STATE_ALLFF;\n\t\t\tcase 1: \treturn BLK_STATE_ALLDIRTY;\n\t\t\tdefault: \treturn ret;\n\t\t\t}\n\t\t}\n#endif\n\t\tjffs2_dbg(1, \"Block at 0x%08x is empty (erased)\\n\",\n\t\t\t  jeb->offset);\n\t\tif (c->cleanmarker_size == 0)\n\t\t\treturn BLK_STATE_CLEANMARKER;\t \n\t\telse\n\t\t\treturn BLK_STATE_ALLFF;\t \n\t}\n\tif (ofs) {\n\t\tjffs2_dbg(1, \"Free space at %08x ends at %08x\\n\", jeb->offset,\n\t\t\t  jeb->offset + ofs);\n\t\tif ((err = jffs2_prealloc_raw_node_refs(c, jeb, 1)))\n\t\t\treturn err;\n\t\tif ((err = jffs2_scan_dirty_space(c, jeb, ofs)))\n\t\t\treturn err;\n\t}\n\n\t \n\tofs += jeb->offset;\n\n\tnoise = 10;\n\n\tdbg_summary(\"no summary found in jeb 0x%08x. Apply original scan.\\n\",jeb->offset);\n\nscan_more:\n\twhile(ofs < jeb->offset + c->sector_size) {\n\n\t\tjffs2_dbg_acct_paranoia_check_nolock(c, jeb);\n\n\t\t \n\t\terr = jffs2_prealloc_raw_node_refs(c, jeb, 2);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tcond_resched();\n\n\t\tif (ofs & 3) {\n\t\t\tpr_warn(\"Eep. ofs 0x%08x not word-aligned!\\n\", ofs);\n\t\t\tofs = PAD(ofs);\n\t\t\tcontinue;\n\t\t}\n\t\tif (ofs == prevofs) {\n\t\t\tpr_warn(\"ofs 0x%08x has already been seen. Skipping\\n\",\n\t\t\t\tofs);\n\t\t\tif ((err = jffs2_scan_dirty_space(c, jeb, 4)))\n\t\t\t\treturn err;\n\t\t\tofs += 4;\n\t\t\tcontinue;\n\t\t}\n\t\tprevofs = ofs;\n\n\t\tif (jeb->offset + c->sector_size < ofs + sizeof(*node)) {\n\t\t\tjffs2_dbg(1, \"Fewer than %zd bytes left to end of block. (%x+%x<%x+%zx) Not reading\\n\",\n\t\t\t\t  sizeof(struct jffs2_unknown_node),\n\t\t\t\t  jeb->offset, c->sector_size, ofs,\n\t\t\t\t  sizeof(*node));\n\t\t\tif ((err = jffs2_scan_dirty_space(c, jeb, (jeb->offset + c->sector_size)-ofs)))\n\t\t\t\treturn err;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (buf_ofs + buf_len < ofs + sizeof(*node)) {\n\t\t\tbuf_len = min_t(uint32_t, buf_size, jeb->offset + c->sector_size - ofs);\n\t\t\tjffs2_dbg(1, \"Fewer than %zd bytes (node header) left to end of buf. Reading 0x%x at 0x%08x\\n\",\n\t\t\t\t  sizeof(struct jffs2_unknown_node),\n\t\t\t\t  buf_len, ofs);\n\t\t\terr = jffs2_fill_scan_buf(c, buf, ofs, buf_len);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tbuf_ofs = ofs;\n\t\t}\n\n\t\tnode = (struct jffs2_unknown_node *)&buf[ofs-buf_ofs];\n\n\t\tif (*(uint32_t *)(&buf[ofs-buf_ofs]) == 0xffffffff) {\n\t\t\tuint32_t inbuf_ofs;\n\t\t\tuint32_t empty_start, scan_end;\n\n\t\t\tempty_start = ofs;\n\t\t\tofs += 4;\n\t\t\tscan_end = min_t(uint32_t, EMPTY_SCAN_SIZE(c->sector_size)/8, buf_len);\n\n\t\t\tjffs2_dbg(1, \"Found empty flash at 0x%08x\\n\", ofs);\n\t\tmore_empty:\n\t\t\tinbuf_ofs = ofs - buf_ofs;\n\t\t\twhile (inbuf_ofs < scan_end) {\n\t\t\t\tif (unlikely(*(uint32_t *)(&buf[inbuf_ofs]) != 0xffffffff)) {\n\t\t\t\t\tpr_warn(\"Empty flash at 0x%08x ends at 0x%08x\\n\",\n\t\t\t\t\t\tempty_start, ofs);\n\t\t\t\t\tif ((err = jffs2_scan_dirty_space(c, jeb, ofs-empty_start)))\n\t\t\t\t\t\treturn err;\n\t\t\t\t\tgoto scan_more;\n\t\t\t\t}\n\n\t\t\t\tinbuf_ofs+=4;\n\t\t\t\tofs += 4;\n\t\t\t}\n\t\t\t \n\t\t\tjffs2_dbg(1, \"Empty flash to end of buffer at 0x%08x\\n\",\n\t\t\t\t  ofs);\n\n\t\t\t \n\t\t\tif (buf_ofs == jeb->offset && jeb->used_size == PAD(c->cleanmarker_size) &&\n\t\t\t    c->cleanmarker_size && !jeb->dirty_size && !ref_next(jeb->first_node)) {\n\t\t\t\tjffs2_dbg(1, \"%d bytes at start of block seems clean... assuming all clean\\n\",\n\t\t\t\t\t  EMPTY_SCAN_SIZE(c->sector_size));\n\t\t\t\treturn BLK_STATE_CLEANMARKER;\n\t\t\t}\n\t\t\tif (!buf_size && (scan_end != buf_len)) { \n\t\t\t\tscan_end = buf_len;\n\t\t\t\tgoto more_empty;\n\t\t\t}\n\t\t\t\n\t\t\t \n\t\t\tbuf_len = min_t(uint32_t, buf_size, jeb->offset + c->sector_size - ofs);\n\t\t\tif (!buf_len) {\n\t\t\t\t \n\t\t\t\tjffs2_dbg(1, \"Empty flash at %08x runs to end of block. Treating as free_space\\n\",\n\t\t\t\t\t  empty_start);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tscan_end = buf_len;\n\t\t\tjffs2_dbg(1, \"Reading another 0x%x at 0x%08x\\n\",\n\t\t\t\t  buf_len, ofs);\n\t\t\terr = jffs2_fill_scan_buf(c, buf, ofs, buf_len);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tbuf_ofs = ofs;\n\t\t\tgoto more_empty;\n\t\t}\n\n\t\tif (ofs == jeb->offset && je16_to_cpu(node->magic) == KSAMTIB_CIGAM_2SFFJ) {\n\t\t\tpr_warn(\"Magic bitmask is backwards at offset 0x%08x. Wrong endian filesystem?\\n\",\n\t\t\t\tofs);\n\t\t\tif ((err = jffs2_scan_dirty_space(c, jeb, 4)))\n\t\t\t\treturn err;\n\t\t\tofs += 4;\n\t\t\tcontinue;\n\t\t}\n\t\tif (je16_to_cpu(node->magic) == JFFS2_DIRTY_BITMASK) {\n\t\t\tjffs2_dbg(1, \"Dirty bitmask at 0x%08x\\n\", ofs);\n\t\t\tif ((err = jffs2_scan_dirty_space(c, jeb, 4)))\n\t\t\t\treturn err;\n\t\t\tofs += 4;\n\t\t\tcontinue;\n\t\t}\n\t\tif (je16_to_cpu(node->magic) == JFFS2_OLD_MAGIC_BITMASK) {\n\t\t\tpr_warn(\"Old JFFS2 bitmask found at 0x%08x\\n\", ofs);\n\t\t\tpr_warn(\"You cannot use older JFFS2 filesystems with newer kernels\\n\");\n\t\t\tif ((err = jffs2_scan_dirty_space(c, jeb, 4)))\n\t\t\t\treturn err;\n\t\t\tofs += 4;\n\t\t\tcontinue;\n\t\t}\n\t\tif (je16_to_cpu(node->magic) != JFFS2_MAGIC_BITMASK) {\n\t\t\t \n\t\t\tnoisy_printk(&noise, \"%s(): Magic bitmask 0x%04x not found at 0x%08x: 0x%04x instead\\n\",\n\t\t\t\t     __func__,\n\t\t\t\t     JFFS2_MAGIC_BITMASK, ofs,\n\t\t\t\t     je16_to_cpu(node->magic));\n\t\t\tif ((err = jffs2_scan_dirty_space(c, jeb, 4)))\n\t\t\t\treturn err;\n\t\t\tofs += 4;\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tcrcnode.magic = node->magic;\n\t\tcrcnode.nodetype = cpu_to_je16( je16_to_cpu(node->nodetype) | JFFS2_NODE_ACCURATE);\n\t\tcrcnode.totlen = node->totlen;\n\t\thdr_crc = crc32(0, &crcnode, sizeof(crcnode)-4);\n\n\t\tif (hdr_crc != je32_to_cpu(node->hdr_crc)) {\n\t\t\tnoisy_printk(&noise, \"%s(): Node at 0x%08x {0x%04x, 0x%04x, 0x%08x) has invalid CRC 0x%08x (calculated 0x%08x)\\n\",\n\t\t\t\t     __func__,\n\t\t\t\t     ofs, je16_to_cpu(node->magic),\n\t\t\t\t     je16_to_cpu(node->nodetype),\n\t\t\t\t     je32_to_cpu(node->totlen),\n\t\t\t\t     je32_to_cpu(node->hdr_crc),\n\t\t\t\t     hdr_crc);\n\t\t\tif ((err = jffs2_scan_dirty_space(c, jeb, 4)))\n\t\t\t\treturn err;\n\t\t\tofs += 4;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ofs + je32_to_cpu(node->totlen) > jeb->offset + c->sector_size) {\n\t\t\t \n\t\t\tpr_warn(\"Node at 0x%08x with length 0x%08x would run over the end of the erase block\\n\",\n\t\t\t\tofs, je32_to_cpu(node->totlen));\n\t\t\tpr_warn(\"Perhaps the file system was created with the wrong erase size?\\n\");\n\t\t\tif ((err = jffs2_scan_dirty_space(c, jeb, 4)))\n\t\t\t\treturn err;\n\t\t\tofs += 4;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!(je16_to_cpu(node->nodetype) & JFFS2_NODE_ACCURATE)) {\n\t\t\t \n\t\t\tjffs2_dbg(2, \"Node at 0x%08x is obsolete. Skipping\\n\",\n\t\t\t\t  ofs);\n\t\t\tif ((err = jffs2_scan_dirty_space(c, jeb, PAD(je32_to_cpu(node->totlen)))))\n\t\t\t\treturn err;\n\t\t\tofs += PAD(je32_to_cpu(node->totlen));\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch(je16_to_cpu(node->nodetype)) {\n\t\tcase JFFS2_NODETYPE_INODE:\n\t\t\tif (buf_ofs + buf_len < ofs + sizeof(struct jffs2_raw_inode)) {\n\t\t\t\tbuf_len = min_t(uint32_t, buf_size, jeb->offset + c->sector_size - ofs);\n\t\t\t\tjffs2_dbg(1, \"Fewer than %zd bytes (inode node) left to end of buf. Reading 0x%x at 0x%08x\\n\",\n\t\t\t\t\t  sizeof(struct jffs2_raw_inode),\n\t\t\t\t\t  buf_len, ofs);\n\t\t\t\terr = jffs2_fill_scan_buf(c, buf, ofs, buf_len);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t\tbuf_ofs = ofs;\n\t\t\t\tnode = (void *)buf;\n\t\t\t}\n\t\t\terr = jffs2_scan_inode_node(c, jeb, (void *)node, ofs, s);\n\t\t\tif (err) return err;\n\t\t\tofs += PAD(je32_to_cpu(node->totlen));\n\t\t\tbreak;\n\n\t\tcase JFFS2_NODETYPE_DIRENT:\n\t\t\tif (buf_ofs + buf_len < ofs + je32_to_cpu(node->totlen)) {\n\t\t\t\tbuf_len = min_t(uint32_t, buf_size, jeb->offset + c->sector_size - ofs);\n\t\t\t\tjffs2_dbg(1, \"Fewer than %d bytes (dirent node) left to end of buf. Reading 0x%x at 0x%08x\\n\",\n\t\t\t\t\t  je32_to_cpu(node->totlen), buf_len,\n\t\t\t\t\t  ofs);\n\t\t\t\terr = jffs2_fill_scan_buf(c, buf, ofs, buf_len);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t\tbuf_ofs = ofs;\n\t\t\t\tnode = (void *)buf;\n\t\t\t}\n\t\t\terr = jffs2_scan_dirent_node(c, jeb, (void *)node, ofs, s);\n\t\t\tif (err) return err;\n\t\t\tofs += PAD(je32_to_cpu(node->totlen));\n\t\t\tbreak;\n\n#ifdef CONFIG_JFFS2_FS_XATTR\n\t\tcase JFFS2_NODETYPE_XATTR:\n\t\t\tif (buf_ofs + buf_len < ofs + je32_to_cpu(node->totlen)) {\n\t\t\t\tbuf_len = min_t(uint32_t, buf_size, jeb->offset + c->sector_size - ofs);\n\t\t\t\tjffs2_dbg(1, \"Fewer than %d bytes (xattr node) left to end of buf. Reading 0x%x at 0x%08x\\n\",\n\t\t\t\t\t  je32_to_cpu(node->totlen), buf_len,\n\t\t\t\t\t  ofs);\n\t\t\t\terr = jffs2_fill_scan_buf(c, buf, ofs, buf_len);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t\tbuf_ofs = ofs;\n\t\t\t\tnode = (void *)buf;\n\t\t\t}\n\t\t\terr = jffs2_scan_xattr_node(c, jeb, (void *)node, ofs, s);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tofs += PAD(je32_to_cpu(node->totlen));\n\t\t\tbreak;\n\t\tcase JFFS2_NODETYPE_XREF:\n\t\t\tif (buf_ofs + buf_len < ofs + je32_to_cpu(node->totlen)) {\n\t\t\t\tbuf_len = min_t(uint32_t, buf_size, jeb->offset + c->sector_size - ofs);\n\t\t\t\tjffs2_dbg(1, \"Fewer than %d bytes (xref node) left to end of buf. Reading 0x%x at 0x%08x\\n\",\n\t\t\t\t\t  je32_to_cpu(node->totlen), buf_len,\n\t\t\t\t\t  ofs);\n\t\t\t\terr = jffs2_fill_scan_buf(c, buf, ofs, buf_len);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t\tbuf_ofs = ofs;\n\t\t\t\tnode = (void *)buf;\n\t\t\t}\n\t\t\terr = jffs2_scan_xref_node(c, jeb, (void *)node, ofs, s);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tofs += PAD(je32_to_cpu(node->totlen));\n\t\t\tbreak;\n#endif\t \n\n\t\tcase JFFS2_NODETYPE_CLEANMARKER:\n\t\t\tjffs2_dbg(1, \"CLEANMARKER node found at 0x%08x\\n\", ofs);\n\t\t\tif (je32_to_cpu(node->totlen) != c->cleanmarker_size) {\n\t\t\t\tpr_notice(\"CLEANMARKER node found at 0x%08x has totlen 0x%x != normal 0x%x\\n\",\n\t\t\t\t\t  ofs, je32_to_cpu(node->totlen),\n\t\t\t\t\t  c->cleanmarker_size);\n\t\t\t\tif ((err = jffs2_scan_dirty_space(c, jeb, PAD(sizeof(struct jffs2_unknown_node)))))\n\t\t\t\t\treturn err;\n\t\t\t\tofs += PAD(sizeof(struct jffs2_unknown_node));\n\t\t\t} else if (jeb->first_node) {\n\t\t\t\tpr_notice(\"CLEANMARKER node found at 0x%08x, not first node in block (0x%08x)\\n\",\n\t\t\t\t\t  ofs, jeb->offset);\n\t\t\t\tif ((err = jffs2_scan_dirty_space(c, jeb, PAD(sizeof(struct jffs2_unknown_node)))))\n\t\t\t\t\treturn err;\n\t\t\t\tofs += PAD(sizeof(struct jffs2_unknown_node));\n\t\t\t} else {\n\t\t\t\tjffs2_link_node_ref(c, jeb, ofs | REF_NORMAL, c->cleanmarker_size, NULL);\n\n\t\t\t\tofs += PAD(c->cleanmarker_size);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase JFFS2_NODETYPE_PADDING:\n\t\t\tif (jffs2_sum_active())\n\t\t\t\tjffs2_sum_add_padding_mem(s, je32_to_cpu(node->totlen));\n\t\t\tif ((err = jffs2_scan_dirty_space(c, jeb, PAD(je32_to_cpu(node->totlen)))))\n\t\t\t\treturn err;\n\t\t\tofs += PAD(je32_to_cpu(node->totlen));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tswitch (je16_to_cpu(node->nodetype) & JFFS2_COMPAT_MASK) {\n\t\t\tcase JFFS2_FEATURE_ROCOMPAT:\n\t\t\t\tpr_notice(\"Read-only compatible feature node (0x%04x) found at offset 0x%08x\\n\",\n\t\t\t\t\t  je16_to_cpu(node->nodetype), ofs);\n\t\t\t\tc->flags |= JFFS2_SB_FLAG_RO;\n\t\t\t\tif (!(jffs2_is_readonly(c)))\n\t\t\t\t\treturn -EROFS;\n\t\t\t\tif ((err = jffs2_scan_dirty_space(c, jeb, PAD(je32_to_cpu(node->totlen)))))\n\t\t\t\t\treturn err;\n\t\t\t\tofs += PAD(je32_to_cpu(node->totlen));\n\t\t\t\tbreak;\n\n\t\t\tcase JFFS2_FEATURE_INCOMPAT:\n\t\t\t\tpr_notice(\"Incompatible feature node (0x%04x) found at offset 0x%08x\\n\",\n\t\t\t\t\t  je16_to_cpu(node->nodetype), ofs);\n\t\t\t\treturn -EINVAL;\n\n\t\t\tcase JFFS2_FEATURE_RWCOMPAT_DELETE:\n\t\t\t\tjffs2_dbg(1, \"Unknown but compatible feature node (0x%04x) found at offset 0x%08x\\n\",\n\t\t\t\t\t  je16_to_cpu(node->nodetype), ofs);\n\t\t\t\tif ((err = jffs2_scan_dirty_space(c, jeb, PAD(je32_to_cpu(node->totlen)))))\n\t\t\t\t\treturn err;\n\t\t\t\tofs += PAD(je32_to_cpu(node->totlen));\n\t\t\t\tbreak;\n\n\t\t\tcase JFFS2_FEATURE_RWCOMPAT_COPY: {\n\t\t\t\tjffs2_dbg(1, \"Unknown but compatible feature node (0x%04x) found at offset 0x%08x\\n\",\n\t\t\t\t\t  je16_to_cpu(node->nodetype), ofs);\n\n\t\t\t\tjffs2_link_node_ref(c, jeb, ofs | REF_PRISTINE, PAD(je32_to_cpu(node->totlen)), NULL);\n\n\t\t\t\t \n\t\t\t\tjffs2_sum_disable_collecting(s);\n\t\t\t\tofs += PAD(je32_to_cpu(node->totlen));\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (jffs2_sum_active()) {\n\t\tif (PAD(s->sum_size + JFFS2_SUMMARY_FRAME_SIZE) > jeb->free_size) {\n\t\t\tdbg_summary(\"There is not enough space for \"\n\t\t\t\t\"summary information, disabling for this jeb!\\n\");\n\t\t\tjffs2_sum_disable_collecting(s);\n\t\t}\n\t}\n\n\tjffs2_dbg(1, \"Block at 0x%08x: free 0x%08x, dirty 0x%08x, unchecked 0x%08x, used 0x%08x, wasted 0x%08x\\n\",\n\t\t  jeb->offset, jeb->free_size, jeb->dirty_size,\n\t\t  jeb->unchecked_size, jeb->used_size, jeb->wasted_size);\n\t\n\t \n\tif (jeb->wasted_size) {\n\t\tjeb->dirty_size += jeb->wasted_size;\n\t\tc->dirty_size += jeb->wasted_size;\n\t\tc->wasted_size -= jeb->wasted_size;\n\t\tjeb->wasted_size = 0;\n\t}\n\n\treturn jffs2_scan_classify_jeb(c, jeb);\n}\n\nstruct jffs2_inode_cache *jffs2_scan_make_ino_cache(struct jffs2_sb_info *c, uint32_t ino)\n{\n\tstruct jffs2_inode_cache *ic;\n\n\tic = jffs2_get_ino_cache(c, ino);\n\tif (ic)\n\t\treturn ic;\n\n\tif (ino > c->highest_ino)\n\t\tc->highest_ino = ino;\n\n\tic = jffs2_alloc_inode_cache();\n\tif (!ic) {\n\t\tpr_notice(\"%s(): allocation of inode cache failed\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tmemset(ic, 0, sizeof(*ic));\n\n\tic->ino = ino;\n\tic->nodes = (void *)ic;\n\tjffs2_add_ino_cache(c, ic);\n\tif (ino == 1)\n\t\tic->pino_nlink = 1;\n\treturn ic;\n}\n\nstatic int jffs2_scan_inode_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_inode *ri, uint32_t ofs, struct jffs2_summary *s)\n{\n\tstruct jffs2_inode_cache *ic;\n\tuint32_t crc, ino = je32_to_cpu(ri->ino);\n\n\tjffs2_dbg(1, \"%s(): Node at 0x%08x\\n\", __func__, ofs);\n\n\t \n\n\t \n\tcrc = crc32(0, ri, sizeof(*ri)-8);\n\tif (crc != je32_to_cpu(ri->node_crc)) {\n\t\tpr_notice(\"%s(): CRC failed on node at 0x%08x: Read 0x%08x, calculated 0x%08x\\n\",\n\t\t\t  __func__, ofs, je32_to_cpu(ri->node_crc), crc);\n\t\t \n\t\treturn jffs2_scan_dirty_space(c, jeb,\n\t\t\t\t\t      PAD(je32_to_cpu(ri->totlen)));\n\t}\n\n\tic = jffs2_get_ino_cache(c, ino);\n\tif (!ic) {\n\t\tic = jffs2_scan_make_ino_cache(c, ino);\n\t\tif (!ic)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t \n\tjffs2_link_node_ref(c, jeb, ofs | REF_UNCHECKED, PAD(je32_to_cpu(ri->totlen)), ic);\n\n\tjffs2_dbg(1, \"Node is ino #%u, version %d. Range 0x%x-0x%x\\n\",\n\t\t  je32_to_cpu(ri->ino), je32_to_cpu(ri->version),\n\t\t  je32_to_cpu(ri->offset),\n\t\t  je32_to_cpu(ri->offset)+je32_to_cpu(ri->dsize));\n\n\tpseudo_random += je32_to_cpu(ri->version);\n\n\tif (jffs2_sum_active()) {\n\t\tjffs2_sum_add_inode_mem(s, ri, ofs - jeb->offset);\n\t}\n\n\treturn 0;\n}\n\nstatic int jffs2_scan_dirent_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t  struct jffs2_raw_dirent *rd, uint32_t ofs, struct jffs2_summary *s)\n{\n\tstruct jffs2_full_dirent *fd;\n\tstruct jffs2_inode_cache *ic;\n\tuint32_t checkedlen;\n\tuint32_t crc;\n\tint err;\n\n\tjffs2_dbg(1, \"%s(): Node at 0x%08x\\n\", __func__, ofs);\n\n\t \n\tcrc = crc32(0, rd, sizeof(*rd)-8);\n\n\tif (crc != je32_to_cpu(rd->node_crc)) {\n\t\tpr_notice(\"%s(): Node CRC failed on node at 0x%08x: Read 0x%08x, calculated 0x%08x\\n\",\n\t\t\t  __func__, ofs, je32_to_cpu(rd->node_crc), crc);\n\t\t \n\t\tif ((err = jffs2_scan_dirty_space(c, jeb, PAD(je32_to_cpu(rd->totlen)))))\n\t\t\treturn err;\n\t\treturn 0;\n\t}\n\n\tpseudo_random += je32_to_cpu(rd->version);\n\n\t \n\tcheckedlen = strnlen(rd->name, rd->nsize);\n\tif (checkedlen < rd->nsize) {\n\t\tpr_err(\"Dirent at %08x has zeroes in name. Truncating to %d chars\\n\",\n\t\t       ofs, checkedlen);\n\t}\n\tfd = jffs2_alloc_full_dirent(checkedlen+1);\n\tif (!fd) {\n\t\treturn -ENOMEM;\n\t}\n\tmemcpy(&fd->name, rd->name, checkedlen);\n\tfd->name[checkedlen] = 0;\n\n\tcrc = crc32(0, fd->name, checkedlen);\n\tif (crc != je32_to_cpu(rd->name_crc)) {\n\t\tpr_notice(\"%s(): Name CRC failed on node at 0x%08x: Read 0x%08x, calculated 0x%08x\\n\",\n\t\t\t  __func__, ofs, je32_to_cpu(rd->name_crc), crc);\n\t\tjffs2_dbg(1, \"Name for which CRC failed is (now) '%s', ino #%d\\n\",\n\t\t\t  fd->name, je32_to_cpu(rd->ino));\n\t\tjffs2_free_full_dirent(fd);\n\t\t \n\t\t \n\t\tif ((err = jffs2_scan_dirty_space(c, jeb, PAD(je32_to_cpu(rd->totlen)))))\n\t\t\treturn err;\n\t\treturn 0;\n\t}\n\tic = jffs2_scan_make_ino_cache(c, je32_to_cpu(rd->pino));\n\tif (!ic) {\n\t\tjffs2_free_full_dirent(fd);\n\t\treturn -ENOMEM;\n\t}\n\n\tfd->raw = jffs2_link_node_ref(c, jeb, ofs | dirent_node_state(rd),\n\t\t\t\t      PAD(je32_to_cpu(rd->totlen)), ic);\n\n\tfd->next = NULL;\n\tfd->version = je32_to_cpu(rd->version);\n\tfd->ino = je32_to_cpu(rd->ino);\n\tfd->nhash = full_name_hash(NULL, fd->name, checkedlen);\n\tfd->type = rd->type;\n\tjffs2_add_fd_to_list(c, fd, &ic->scan_dents);\n\n\tif (jffs2_sum_active()) {\n\t\tjffs2_sum_add_dirent_mem(s, rd, ofs - jeb->offset);\n\t}\n\n\treturn 0;\n}\n\nstatic int count_list(struct list_head *l)\n{\n\tuint32_t count = 0;\n\tstruct list_head *tmp;\n\n\tlist_for_each(tmp, l) {\n\t\tcount++;\n\t}\n\treturn count;\n}\n\n \nstatic void rotate_list(struct list_head *head, uint32_t count)\n{\n\tstruct list_head *n = head->next;\n\n\tlist_del(head);\n\twhile(count--) {\n\t\tn = n->next;\n\t}\n\tlist_add(head, n);\n}\n\nvoid jffs2_rotate_lists(struct jffs2_sb_info *c)\n{\n\tuint32_t x;\n\tuint32_t rotateby;\n\n\tx = count_list(&c->clean_list);\n\tif (x) {\n\t\trotateby = pseudo_random % x;\n\t\trotate_list((&c->clean_list), rotateby);\n\t}\n\n\tx = count_list(&c->very_dirty_list);\n\tif (x) {\n\t\trotateby = pseudo_random % x;\n\t\trotate_list((&c->very_dirty_list), rotateby);\n\t}\n\n\tx = count_list(&c->dirty_list);\n\tif (x) {\n\t\trotateby = pseudo_random % x;\n\t\trotate_list((&c->dirty_list), rotateby);\n\t}\n\n\tx = count_list(&c->erasable_list);\n\tif (x) {\n\t\trotateby = pseudo_random % x;\n\t\trotate_list((&c->erasable_list), rotateby);\n\t}\n\n\tif (c->nr_erasing_blocks) {\n\t\trotateby = pseudo_random % c->nr_erasing_blocks;\n\t\trotate_list((&c->erase_pending_list), rotateby);\n\t}\n\n\tif (c->nr_free_blocks) {\n\t\trotateby = pseudo_random % c->nr_free_blocks;\n\t\trotate_list((&c->free_list), rotateby);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}