{
  "module_name": "wbuf.c",
  "hash_id": "270f895ac12aa4cc906cff07c2f7d04a04ffa0d20aa7c35921a32d3b3f71975d",
  "original_prompt": "Ingested from linux-6.6.14/fs/jffs2/wbuf.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/mtd/mtd.h>\n#include <linux/crc32.h>\n#include <linux/mtd/rawnand.h>\n#include <linux/jiffies.h>\n#include <linux/sched.h>\n#include <linux/writeback.h>\n\n#include \"nodelist.h\"\n\n \n#undef BREAKME\n#undef BREAKMEHEADER\n\n#ifdef BREAKME\nstatic unsigned char *brokenbuf;\n#endif\n\n#define PAGE_DIV(x) ( ((unsigned long)(x) / (unsigned long)(c->wbuf_pagesize)) * (unsigned long)(c->wbuf_pagesize) )\n#define PAGE_MOD(x) ( (unsigned long)(x) % (unsigned long)(c->wbuf_pagesize) )\n\n \n#define MAX_ERASE_FAILURES \t2\n\nstruct jffs2_inodirty {\n\tuint32_t ino;\n\tstruct jffs2_inodirty *next;\n};\n\nstatic struct jffs2_inodirty inodirty_nomem;\n\nstatic int jffs2_wbuf_pending_for_ino(struct jffs2_sb_info *c, uint32_t ino)\n{\n\tstruct jffs2_inodirty *this = c->wbuf_inodes;\n\n\t \n\tif (this == &inodirty_nomem)\n\t\treturn 1;\n\n\t \n\tif (this && !ino)\n\t\treturn 1;\n\n\t \n\twhile (this) {\n\t\tif (this->ino == ino)\n\t\t\treturn 1;\n\t\tthis = this->next;\n\t}\n\treturn 0;\n}\n\nstatic void jffs2_clear_wbuf_ino_list(struct jffs2_sb_info *c)\n{\n\tstruct jffs2_inodirty *this;\n\n\tthis = c->wbuf_inodes;\n\n\tif (this != &inodirty_nomem) {\n\t\twhile (this) {\n\t\t\tstruct jffs2_inodirty *next = this->next;\n\t\t\tkfree(this);\n\t\t\tthis = next;\n\t\t}\n\t}\n\tc->wbuf_inodes = NULL;\n}\n\nstatic void jffs2_wbuf_dirties_inode(struct jffs2_sb_info *c, uint32_t ino)\n{\n\tstruct jffs2_inodirty *new;\n\n\t \n\tjffs2_dirty_trigger(c);\n\n\tif (jffs2_wbuf_pending_for_ino(c, ino))\n\t\treturn;\n\n\tnew = kmalloc(sizeof(*new), GFP_KERNEL);\n\tif (!new) {\n\t\tjffs2_dbg(1, \"No memory to allocate inodirty. Fallback to all considered dirty\\n\");\n\t\tjffs2_clear_wbuf_ino_list(c);\n\t\tc->wbuf_inodes = &inodirty_nomem;\n\t\treturn;\n\t}\n\tnew->ino = ino;\n\tnew->next = c->wbuf_inodes;\n\tc->wbuf_inodes = new;\n\treturn;\n}\n\nstatic inline void jffs2_refile_wbuf_blocks(struct jffs2_sb_info *c)\n{\n\tstruct list_head *this, *next;\n\tstatic int n;\n\n\tif (list_empty(&c->erasable_pending_wbuf_list))\n\t\treturn;\n\n\tlist_for_each_safe(this, next, &c->erasable_pending_wbuf_list) {\n\t\tstruct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);\n\n\t\tjffs2_dbg(1, \"Removing eraseblock at 0x%08x from erasable_pending_wbuf_list...\\n\",\n\t\t\t  jeb->offset);\n\t\tlist_del(this);\n\t\tif ((jiffies + (n++)) & 127) {\n\t\t\t \n\t\t\tjffs2_dbg(1, \"...and adding to erase_pending_list\\n\");\n\t\t\tlist_add_tail(&jeb->list, &c->erase_pending_list);\n\t\t\tc->nr_erasing_blocks++;\n\t\t\tjffs2_garbage_collect_trigger(c);\n\t\t} else {\n\t\t\t \n\t\t\tjffs2_dbg(1, \"...and adding to erasable_list\\n\");\n\t\t\tlist_add_tail(&jeb->list, &c->erasable_list);\n\t\t}\n\t}\n}\n\n#define REFILE_NOTEMPTY 0\n#define REFILE_ANYWAY   1\n\nstatic void jffs2_block_refile(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb, int allow_empty)\n{\n\tjffs2_dbg(1, \"About to refile bad block at %08x\\n\", jeb->offset);\n\n\t \n\tif (c->nextblock == jeb)\n\t\tc->nextblock = NULL;\n\telse  \n\t\tlist_del(&jeb->list);\n\tif (jeb->first_node) {\n\t\tjffs2_dbg(1, \"Refiling block at %08x to bad_used_list\\n\",\n\t\t\t  jeb->offset);\n\t\tlist_add(&jeb->list, &c->bad_used_list);\n\t} else {\n\t\tBUG_ON(allow_empty == REFILE_NOTEMPTY);\n\t\t \n\t\tjffs2_dbg(1, \"Refiling block at %08x to erase_pending_list\\n\",\n\t\t\t  jeb->offset);\n\t\tlist_add(&jeb->list, &c->erase_pending_list);\n\t\tc->nr_erasing_blocks++;\n\t\tjffs2_garbage_collect_trigger(c);\n\t}\n\n\tif (!jffs2_prealloc_raw_node_refs(c, jeb, 1)) {\n\t\tuint32_t oldfree = jeb->free_size;\n\n\t\tjffs2_link_node_ref(c, jeb, \n\t\t\t\t    (jeb->offset+c->sector_size-oldfree) | REF_OBSOLETE,\n\t\t\t\t    oldfree, NULL);\n\t\t \n\t\tc->wasted_size += oldfree;\n\t\tjeb->wasted_size += oldfree;\n\t\tc->dirty_size -= oldfree;\n\t\tjeb->dirty_size -= oldfree;\n\t}\n\n\tjffs2_dbg_dump_block_lists_nolock(c);\n\tjffs2_dbg_acct_sanity_check_nolock(c,jeb);\n\tjffs2_dbg_acct_paranoia_check_nolock(c, jeb);\n}\n\nstatic struct jffs2_raw_node_ref **jffs2_incore_replace_raw(struct jffs2_sb_info *c,\n\t\t\t\t\t\t\t    struct jffs2_inode_info *f,\n\t\t\t\t\t\t\t    struct jffs2_raw_node_ref *raw,\n\t\t\t\t\t\t\t    union jffs2_node_union *node)\n{\n\tstruct jffs2_node_frag *frag;\n\tstruct jffs2_full_dirent *fd;\n\n\tdbg_noderef(\"incore_replace_raw: node at %p is {%04x,%04x}\\n\",\n\t\t    node, je16_to_cpu(node->u.magic), je16_to_cpu(node->u.nodetype));\n\n\tBUG_ON(je16_to_cpu(node->u.magic) != 0x1985 &&\n\t       je16_to_cpu(node->u.magic) != 0);\n\n\tswitch (je16_to_cpu(node->u.nodetype)) {\n\tcase JFFS2_NODETYPE_INODE:\n\t\tif (f->metadata && f->metadata->raw == raw) {\n\t\t\tdbg_noderef(\"Will replace ->raw in f->metadata at %p\\n\", f->metadata);\n\t\t\treturn &f->metadata->raw;\n\t\t}\n\t\tfrag = jffs2_lookup_node_frag(&f->fragtree, je32_to_cpu(node->i.offset));\n\t\tBUG_ON(!frag);\n\t\t \n\t\twhile (!frag->node || frag->node->raw != raw) {\n\t\t\tfrag = frag_next(frag);\n\t\t\tBUG_ON(!frag);\n\t\t}\n\t\tdbg_noderef(\"Will replace ->raw in full_dnode at %p\\n\", frag->node);\n\t\treturn &frag->node->raw;\n\n\tcase JFFS2_NODETYPE_DIRENT:\n\t\tfor (fd = f->dents; fd; fd = fd->next) {\n\t\t\tif (fd->raw == raw) {\n\t\t\t\tdbg_noderef(\"Will replace ->raw in full_dirent at %p\\n\", fd);\n\t\t\t\treturn &fd->raw;\n\t\t\t}\n\t\t}\n\t\tBUG();\n\n\tdefault:\n\t\tdbg_noderef(\"Don't care about replacing raw for nodetype %x\\n\",\n\t\t\t    je16_to_cpu(node->u.nodetype));\n\t\tbreak;\n\t}\n\treturn NULL;\n}\n\n#ifdef CONFIG_JFFS2_FS_WBUF_VERIFY\nstatic int jffs2_verify_write(struct jffs2_sb_info *c, unsigned char *buf,\n\t\t\t      uint32_t ofs)\n{\n\tint ret;\n\tsize_t retlen;\n\tchar *eccstr;\n\n\tret = mtd_read(c->mtd, ofs, c->wbuf_pagesize, &retlen, c->wbuf_verify);\n\tif (ret && ret != -EUCLEAN && ret != -EBADMSG) {\n\t\tpr_warn(\"%s(): Read back of page at %08x failed: %d\\n\",\n\t\t\t__func__, c->wbuf_ofs, ret);\n\t\treturn ret;\n\t} else if (retlen != c->wbuf_pagesize) {\n\t\tpr_warn(\"%s(): Read back of page at %08x gave short read: %zd not %d\\n\",\n\t\t\t__func__, ofs, retlen, c->wbuf_pagesize);\n\t\treturn -EIO;\n\t}\n\tif (!memcmp(buf, c->wbuf_verify, c->wbuf_pagesize))\n\t\treturn 0;\n\n\tif (ret == -EUCLEAN)\n\t\teccstr = \"corrected\";\n\telse if (ret == -EBADMSG)\n\t\teccstr = \"correction failed\";\n\telse\n\t\teccstr = \"OK or unused\";\n\n\tpr_warn(\"Write verify error (ECC %s) at %08x. Wrote:\\n\",\n\t\teccstr, c->wbuf_ofs);\n\tprint_hex_dump(KERN_WARNING, \"\", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t       c->wbuf, c->wbuf_pagesize, 0);\n\n\tpr_warn(\"Read back:\\n\");\n\tprint_hex_dump(KERN_WARNING, \"\", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t       c->wbuf_verify, c->wbuf_pagesize, 0);\n\n\treturn -EIO;\n}\n#else\n#define jffs2_verify_write(c,b,o) (0)\n#endif\n\n \n\nstatic void jffs2_wbuf_recover(struct jffs2_sb_info *c)\n{\n\tstruct jffs2_eraseblock *jeb, *new_jeb;\n\tstruct jffs2_raw_node_ref *raw, *next, *first_raw = NULL;\n\tsize_t retlen;\n\tint ret;\n\tint nr_refile = 0;\n\tunsigned char *buf;\n\tuint32_t start, end, ofs, len;\n\n\tjeb = &c->blocks[c->wbuf_ofs / c->sector_size];\n\n\tspin_lock(&c->erase_completion_lock);\n\tif (c->wbuf_ofs % c->mtd->erasesize)\n\t\tjffs2_block_refile(c, jeb, REFILE_NOTEMPTY);\n\telse\n\t\tjffs2_block_refile(c, jeb, REFILE_ANYWAY);\n\tspin_unlock(&c->erase_completion_lock);\n\n\tBUG_ON(!ref_obsolete(jeb->last_node));\n\n\t \n\tfor (next = raw = jeb->first_node; next; raw = next) {\n\t\tnext = ref_next(raw);\n\n\t\tif (ref_obsolete(raw) || \n\t\t    (next && ref_offset(next) <= c->wbuf_ofs)) {\n\t\t\tdbg_noderef(\"Skipping node at 0x%08x(%d)-0x%08x which is either before 0x%08x or obsolete\\n\",\n\t\t\t\t    ref_offset(raw), ref_flags(raw),\n\t\t\t\t    (ref_offset(raw) + ref_totlen(c, jeb, raw)),\n\t\t\t\t    c->wbuf_ofs);\n\t\t\tcontinue;\n\t\t}\n\t\tdbg_noderef(\"First node to be recovered is at 0x%08x(%d)-0x%08x\\n\",\n\t\t\t    ref_offset(raw), ref_flags(raw),\n\t\t\t    (ref_offset(raw) + ref_totlen(c, jeb, raw)));\n\n\t\tfirst_raw = raw;\n\t\tbreak;\n\t}\n\n\tif (!first_raw) {\n\t\t \n\t\tjffs2_dbg(1, \"No non-obsolete nodes to be recovered. Just filing block bad\\n\");\n\t\tc->wbuf_len = 0;\n\t\treturn;\n\t}\n\n\tstart = ref_offset(first_raw);\n\tend = ref_offset(jeb->last_node);\n\tnr_refile = 1;\n\n\t \n\twhile ((raw = ref_next(raw)) != jeb->last_node)\n\t\tnr_refile++;\n\n\tdbg_noderef(\"wbuf recover %08x-%08x (%d bytes in %d nodes)\\n\",\n\t\t    start, end, end - start, nr_refile);\n\n\tbuf = NULL;\n\tif (start < c->wbuf_ofs) {\n\t\t \n\n\t\tbuf = kmalloc(end - start, GFP_KERNEL);\n\t\tif (!buf) {\n\t\t\tpr_crit(\"Malloc failure in wbuf recovery. Data loss ensues.\\n\");\n\n\t\t\tgoto read_failed;\n\t\t}\n\n\t\t \n\t\tret = mtd_read(c->mtd, start, c->wbuf_ofs - start, &retlen,\n\t\t\t       buf);\n\n\t\t \n\t\tif ((ret == -EUCLEAN || ret == -EBADMSG) &&\n\t\t    (retlen == c->wbuf_ofs - start))\n\t\t\tret = 0;\n\n\t\tif (ret || retlen != c->wbuf_ofs - start) {\n\t\t\tpr_crit(\"Old data are already lost in wbuf recovery. Data loss ensues.\\n\");\n\n\t\t\tkfree(buf);\n\t\t\tbuf = NULL;\n\t\tread_failed:\n\t\t\tfirst_raw = ref_next(first_raw);\n\t\t\tnr_refile--;\n\t\t\twhile (first_raw && ref_obsolete(first_raw)) {\n\t\t\t\tfirst_raw = ref_next(first_raw);\n\t\t\t\tnr_refile--;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!first_raw) {\n\t\t\t\tc->wbuf_len = 0;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t \n\t\t\tstart = ref_offset(first_raw);\n\t\t\tdbg_noderef(\"wbuf now recover %08x-%08x (%d bytes in %d nodes)\\n\",\n\t\t\t\t    start, end, end - start, nr_refile);\n\n\t\t} else {\n\t\t\t \n\t\t\tmemcpy(buf + (c->wbuf_ofs - start), c->wbuf, end - c->wbuf_ofs);\n\t\t}\n\t}\n\t \n\n\t \n\tret = jffs2_reserve_space_gc(c, end-start, &len, JFFS2_SUMMARY_NOSUM_SIZE);\n\tif (ret) {\n\t\tpr_warn(\"Failed to allocate space for wbuf recovery. Data loss ensues.\\n\");\n\t\tkfree(buf);\n\t\treturn;\n\t}\n\n\t \n\tjffs2_sum_disable_collecting(c->summary);\n\n\tret = jffs2_prealloc_raw_node_refs(c, c->nextblock, nr_refile);\n\tif (ret) {\n\t\tpr_warn(\"Failed to allocate node refs for wbuf recovery. Data loss ensues.\\n\");\n\t\tkfree(buf);\n\t\treturn;\n\t}\n\n\tofs = write_ofs(c);\n\n\tif (end-start >= c->wbuf_pagesize) {\n\t\t \n\t\tunsigned char *rewrite_buf = buf?:c->wbuf;\n\t\tuint32_t towrite = (end-start) - ((end-start)%c->wbuf_pagesize);\n\n\t\tjffs2_dbg(1, \"Write 0x%x bytes at 0x%08x in wbuf recover\\n\",\n\t\t\t  towrite, ofs);\n\n#ifdef BREAKMEHEADER\n\t\tstatic int breakme;\n\t\tif (breakme++ == 20) {\n\t\t\tpr_notice(\"Faking write error at 0x%08x\\n\", ofs);\n\t\t\tbreakme = 0;\n\t\t\tmtd_write(c->mtd, ofs, towrite, &retlen, brokenbuf);\n\t\t\tret = -EIO;\n\t\t} else\n#endif\n\t\t\tret = mtd_write(c->mtd, ofs, towrite, &retlen,\n\t\t\t\t\trewrite_buf);\n\n\t\tif (ret || retlen != towrite || jffs2_verify_write(c, rewrite_buf, ofs)) {\n\t\t\t \n\t\t\tpr_crit(\"Recovery of wbuf failed due to a second write error\\n\");\n\t\t\tkfree(buf);\n\n\t\t\tif (retlen)\n\t\t\t\tjffs2_add_physical_node_ref(c, ofs | REF_OBSOLETE, ref_totlen(c, jeb, first_raw), NULL);\n\n\t\t\treturn;\n\t\t}\n\t\tpr_notice(\"Recovery of wbuf succeeded to %08x\\n\", ofs);\n\n\t\tc->wbuf_len = (end - start) - towrite;\n\t\tc->wbuf_ofs = ofs + towrite;\n\t\tmemmove(c->wbuf, rewrite_buf + towrite, c->wbuf_len);\n\t\t \n\t} else {\n\t\t \n\t\tif (buf) {\n\t\t\tmemcpy(c->wbuf, buf, end-start);\n\t\t} else {\n\t\t\tmemmove(c->wbuf, c->wbuf + (start - c->wbuf_ofs), end - start);\n\t\t}\n\t\tc->wbuf_ofs = ofs;\n\t\tc->wbuf_len = end - start;\n\t}\n\n\t \n\tnew_jeb = &c->blocks[ofs / c->sector_size];\n\n\tspin_lock(&c->erase_completion_lock);\n\tfor (raw = first_raw; raw != jeb->last_node; raw = ref_next(raw)) {\n\t\tuint32_t rawlen = ref_totlen(c, jeb, raw);\n\t\tstruct jffs2_inode_cache *ic;\n\t\tstruct jffs2_raw_node_ref *new_ref;\n\t\tstruct jffs2_raw_node_ref **adjust_ref = NULL;\n\t\tstruct jffs2_inode_info *f = NULL;\n\n\t\tjffs2_dbg(1, \"Refiling block of %08x at %08x(%d) to %08x\\n\",\n\t\t\t  rawlen, ref_offset(raw), ref_flags(raw), ofs);\n\n\t\tic = jffs2_raw_ref_to_ic(raw);\n\n\t\t \n\t\tif (ic && ic->class == RAWNODE_CLASS_XATTR_DATUM) {\n\t\t\tstruct jffs2_xattr_datum *xd = (void *)ic;\n\t\t\tBUG_ON(xd->node != raw);\n\t\t\tadjust_ref = &xd->node;\n\t\t\traw->next_in_ino = NULL;\n\t\t\tic = NULL;\n\t\t} else if (ic && ic->class == RAWNODE_CLASS_XATTR_REF) {\n\t\t\tstruct jffs2_xattr_datum *xr = (void *)ic;\n\t\t\tBUG_ON(xr->node != raw);\n\t\t\tadjust_ref = &xr->node;\n\t\t\traw->next_in_ino = NULL;\n\t\t\tic = NULL;\n\t\t} else if (ic && ic->class == RAWNODE_CLASS_INODE_CACHE) {\n\t\t\tstruct jffs2_raw_node_ref **p = &ic->nodes;\n\n\t\t\t \n\t\t\twhile (*p && *p != (void *)ic) {\n\t\t\t\tif (*p == raw) {\n\t\t\t\t\t(*p) = (raw->next_in_ino);\n\t\t\t\t\traw->next_in_ino = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tp = &((*p)->next_in_ino);\n\t\t\t}\n\n\t\t\tif (ic->state == INO_STATE_PRESENT && !ref_obsolete(raw)) {\n\t\t\t\t \n\t\t\t\tf = jffs2_gc_fetch_inode(c, ic->ino, !ic->pino_nlink);\n\t\t\t\tif (IS_ERR(f)) {\n\t\t\t\t\t \n\t\t\t\t\tJFFS2_ERROR(\"Failed to iget() ino #%u, err %ld\\n\",\n\t\t\t\t\t\t    ic->ino, PTR_ERR(f));\n\t\t\t\t\tBUG();\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tadjust_ref = jffs2_incore_replace_raw(c, f, raw,\n\t\t\t\t\t\t\t\t      (void *)(buf?:c->wbuf) + (ref_offset(raw) - start));\n\t\t\t} else if (unlikely(ic->state != INO_STATE_PRESENT &&\n\t\t\t\t\t    ic->state != INO_STATE_CHECKEDABSENT &&\n\t\t\t\t\t    ic->state != INO_STATE_GC)) {\n\t\t\t\tJFFS2_ERROR(\"Inode #%u is in strange state %d!\\n\", ic->ino, ic->state);\n\t\t\t\tBUG();\n\t\t\t}\n\t\t}\n\n\t\tnew_ref = jffs2_link_node_ref(c, new_jeb, ofs | ref_flags(raw), rawlen, ic);\n\n\t\tif (adjust_ref) {\n\t\t\tBUG_ON(*adjust_ref != raw);\n\t\t\t*adjust_ref = new_ref;\n\t\t}\n\t\tif (f)\n\t\t\tjffs2_gc_release_inode(c, f);\n\n\t\tif (!ref_obsolete(raw)) {\n\t\t\tjeb->dirty_size += rawlen;\n\t\t\tjeb->used_size  -= rawlen;\n\t\t\tc->dirty_size += rawlen;\n\t\t\tc->used_size -= rawlen;\n\t\t\traw->flash_offset = ref_offset(raw) | REF_OBSOLETE;\n\t\t\tBUG_ON(raw->next_in_ino);\n\t\t}\n\t\tofs += rawlen;\n\t}\n\n\tkfree(buf);\n\n\t \n\tif (first_raw == jeb->first_node) {\n\t\tjffs2_dbg(1, \"Failing block at %08x is now empty. Moving to erase_pending_list\\n\",\n\t\t\t  jeb->offset);\n\t\tlist_move(&jeb->list, &c->erase_pending_list);\n\t\tc->nr_erasing_blocks++;\n\t\tjffs2_garbage_collect_trigger(c);\n\t}\n\n\tjffs2_dbg_acct_sanity_check_nolock(c, jeb);\n\tjffs2_dbg_acct_paranoia_check_nolock(c, jeb);\n\n\tjffs2_dbg_acct_sanity_check_nolock(c, new_jeb);\n\tjffs2_dbg_acct_paranoia_check_nolock(c, new_jeb);\n\n\tspin_unlock(&c->erase_completion_lock);\n\n\tjffs2_dbg(1, \"wbuf recovery completed OK. wbuf_ofs 0x%08x, len 0x%x\\n\",\n\t\t  c->wbuf_ofs, c->wbuf_len);\n\n}\n\n \n#define NOPAD\t\t0\n#define PAD_NOACCOUNT\t1\n#define PAD_ACCOUNTING\t2\n\nstatic int __jffs2_flush_wbuf(struct jffs2_sb_info *c, int pad)\n{\n\tstruct jffs2_eraseblock *wbuf_jeb;\n\tint ret;\n\tsize_t retlen;\n\n\t \n\tif (!jffs2_is_writebuffered(c))\n\t\treturn 0;\n\n\tif (!mutex_is_locked(&c->alloc_sem)) {\n\t\tpr_crit(\"jffs2_flush_wbuf() called with alloc_sem not locked!\\n\");\n\t\tBUG();\n\t}\n\n\tif (!c->wbuf_len)\t \n\t\treturn 0;\n\n\twbuf_jeb = &c->blocks[c->wbuf_ofs / c->sector_size];\n\tif (jffs2_prealloc_raw_node_refs(c, wbuf_jeb, c->nextblock->allocated_refs + 1))\n\t\treturn -ENOMEM;\n\n\t \n\tif (pad ) {\n\t\tc->wbuf_len = PAD(c->wbuf_len);\n\n\t\t \n\t\tmemset(c->wbuf + c->wbuf_len, 0, c->wbuf_pagesize - c->wbuf_len);\n\n\t\tif ( c->wbuf_len + sizeof(struct jffs2_unknown_node) < c->wbuf_pagesize) {\n\t\t\tstruct jffs2_unknown_node *padnode = (void *)(c->wbuf + c->wbuf_len);\n\t\t\tpadnode->magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);\n\t\t\tpadnode->nodetype = cpu_to_je16(JFFS2_NODETYPE_PADDING);\n\t\t\tpadnode->totlen = cpu_to_je32(c->wbuf_pagesize - c->wbuf_len);\n\t\t\tpadnode->hdr_crc = cpu_to_je32(crc32(0, padnode, sizeof(*padnode)-4));\n\t\t}\n\t}\n\t \n\n#ifdef BREAKME\n\tstatic int breakme;\n\tif (breakme++ == 20) {\n\t\tpr_notice(\"Faking write error at 0x%08x\\n\", c->wbuf_ofs);\n\t\tbreakme = 0;\n\t\tmtd_write(c->mtd, c->wbuf_ofs, c->wbuf_pagesize, &retlen,\n\t\t\t  brokenbuf);\n\t\tret = -EIO;\n\t} else\n#endif\n\n\t\tret = mtd_write(c->mtd, c->wbuf_ofs, c->wbuf_pagesize,\n\t\t\t\t&retlen, c->wbuf);\n\n\tif (ret) {\n\t\tpr_warn(\"jffs2_flush_wbuf(): Write failed with %d\\n\", ret);\n\t\tgoto wfail;\n\t} else if (retlen != c->wbuf_pagesize) {\n\t\tpr_warn(\"jffs2_flush_wbuf(): Write was short: %zd instead of %d\\n\",\n\t\t\tretlen, c->wbuf_pagesize);\n\t\tret = -EIO;\n\t\tgoto wfail;\n\t} else if ((ret = jffs2_verify_write(c, c->wbuf, c->wbuf_ofs))) {\n\twfail:\n\t\tjffs2_wbuf_recover(c);\n\n\t\treturn ret;\n\t}\n\n\t \n\tif (pad) {\n\t\tuint32_t waste = c->wbuf_pagesize - c->wbuf_len;\n\n\t\tjffs2_dbg(1, \"jffs2_flush_wbuf() adjusting free_size of %sblock at %08x\\n\",\n\t\t\t  (wbuf_jeb == c->nextblock) ? \"next\" : \"\",\n\t\t\t  wbuf_jeb->offset);\n\n\t\t \n\t\tif (wbuf_jeb->free_size < waste) {\n\t\t\tpr_crit(\"jffs2_flush_wbuf(): Accounting error. wbuf at 0x%08x has 0x%03x bytes, 0x%03x left.\\n\",\n\t\t\t\tc->wbuf_ofs, c->wbuf_len, waste);\n\t\t\tpr_crit(\"jffs2_flush_wbuf(): But free_size for block at 0x%08x is only 0x%08x\\n\",\n\t\t\t\twbuf_jeb->offset, wbuf_jeb->free_size);\n\t\t\tBUG();\n\t\t}\n\n\t\tspin_lock(&c->erase_completion_lock);\n\n\t\tjffs2_link_node_ref(c, wbuf_jeb, (c->wbuf_ofs + c->wbuf_len) | REF_OBSOLETE, waste, NULL);\n\t\t \n\t\twbuf_jeb->dirty_size -= waste;\n\t\tc->dirty_size -= waste;\n\t\twbuf_jeb->wasted_size += waste;\n\t\tc->wasted_size += waste;\n\t} else\n\t\tspin_lock(&c->erase_completion_lock);\n\n\t \n\tjffs2_refile_wbuf_blocks(c);\n\tjffs2_clear_wbuf_ino_list(c);\n\tspin_unlock(&c->erase_completion_lock);\n\n\tmemset(c->wbuf,0xff,c->wbuf_pagesize);\n\t \n\tc->wbuf_ofs += c->wbuf_pagesize;\n\tc->wbuf_len = 0;\n\treturn 0;\n}\n\n \nint jffs2_flush_wbuf_gc(struct jffs2_sb_info *c, uint32_t ino)\n{\n\tuint32_t old_wbuf_ofs;\n\tuint32_t old_wbuf_len;\n\tint ret = 0;\n\n\tjffs2_dbg(1, \"jffs2_flush_wbuf_gc() called for ino #%u...\\n\", ino);\n\n\tif (!c->wbuf)\n\t\treturn 0;\n\n\tmutex_lock(&c->alloc_sem);\n\tif (!jffs2_wbuf_pending_for_ino(c, ino)) {\n\t\tjffs2_dbg(1, \"Ino #%d not pending in wbuf. Returning\\n\", ino);\n\t\tmutex_unlock(&c->alloc_sem);\n\t\treturn 0;\n\t}\n\n\told_wbuf_ofs = c->wbuf_ofs;\n\told_wbuf_len = c->wbuf_len;\n\n\tif (c->unchecked_size) {\n\t\t \n\t\tjffs2_dbg(1, \"%s(): padding. Not finished checking\\n\",\n\t\t\t  __func__);\n\t\tdown_write(&c->wbuf_sem);\n\t\tret = __jffs2_flush_wbuf(c, PAD_ACCOUNTING);\n\t\t \n\t\tif (ret)\n\t\t\tret = __jffs2_flush_wbuf(c, PAD_ACCOUNTING);\n\t\tup_write(&c->wbuf_sem);\n\t} else while (old_wbuf_len &&\n\t\t      old_wbuf_ofs == c->wbuf_ofs) {\n\n\t\tmutex_unlock(&c->alloc_sem);\n\n\t\tjffs2_dbg(1, \"%s(): calls gc pass\\n\", __func__);\n\n\t\tret = jffs2_garbage_collect_pass(c);\n\t\tif (ret) {\n\t\t\t \n\t\t\tmutex_lock(&c->alloc_sem);\n\t\t\tdown_write(&c->wbuf_sem);\n\t\t\tret = __jffs2_flush_wbuf(c, PAD_ACCOUNTING);\n\t\t\t \n\t\t\tif (ret)\n\t\t\t\tret = __jffs2_flush_wbuf(c, PAD_ACCOUNTING);\n\t\t\tup_write(&c->wbuf_sem);\n\t\t\tbreak;\n\t\t}\n\t\tmutex_lock(&c->alloc_sem);\n\t}\n\n\tjffs2_dbg(1, \"%s(): ends...\\n\", __func__);\n\n\tmutex_unlock(&c->alloc_sem);\n\treturn ret;\n}\n\n \nint jffs2_flush_wbuf_pad(struct jffs2_sb_info *c)\n{\n\tint ret;\n\n\tif (!c->wbuf)\n\t\treturn 0;\n\n\tdown_write(&c->wbuf_sem);\n\tret = __jffs2_flush_wbuf(c, PAD_NOACCOUNT);\n\t \n\tif (ret)\n\t\tret = __jffs2_flush_wbuf(c, PAD_NOACCOUNT);\n\tup_write(&c->wbuf_sem);\n\n\treturn ret;\n}\n\nstatic size_t jffs2_fill_wbuf(struct jffs2_sb_info *c, const uint8_t *buf,\n\t\t\t      size_t len)\n{\n\tif (len && !c->wbuf_len && (len >= c->wbuf_pagesize))\n\t\treturn 0;\n\n\tif (len > (c->wbuf_pagesize - c->wbuf_len))\n\t\tlen = c->wbuf_pagesize - c->wbuf_len;\n\tmemcpy(c->wbuf + c->wbuf_len, buf, len);\n\tc->wbuf_len += (uint32_t) len;\n\treturn len;\n}\n\nint jffs2_flash_writev(struct jffs2_sb_info *c, const struct kvec *invecs,\n\t\t       unsigned long count, loff_t to, size_t *retlen,\n\t\t       uint32_t ino)\n{\n\tstruct jffs2_eraseblock *jeb;\n\tsize_t wbuf_retlen, donelen = 0;\n\tuint32_t outvec_to = to;\n\tint ret, invec;\n\n\t \n\tif (!jffs2_is_writebuffered(c))\n\t\treturn jffs2_flash_direct_writev(c, invecs, count, to, retlen);\n\n\tdown_write(&c->wbuf_sem);\n\n\t \n\tif (c->wbuf_ofs == 0xFFFFFFFF) {\n\t\tc->wbuf_ofs = PAGE_DIV(to);\n\t\tc->wbuf_len = PAGE_MOD(to);\n\t\tmemset(c->wbuf,0xff,c->wbuf_pagesize);\n\t}\n\n\t \n\tif (SECTOR_ADDR(to) != SECTOR_ADDR(c->wbuf_ofs)) {\n\t\t \n\t\tif (c->wbuf_len) {\n\t\t\tjffs2_dbg(1, \"%s(): to 0x%lx causes flush of wbuf at 0x%08x\\n\",\n\t\t\t\t  __func__, (unsigned long)to, c->wbuf_ofs);\n\t\t\tret = __jffs2_flush_wbuf(c, PAD_NOACCOUNT);\n\t\t\tif (ret)\n\t\t\t\tgoto outerr;\n\t\t}\n\t\t \n\t\tc->wbuf_ofs = PAGE_DIV(to);\n\t\tc->wbuf_len = PAGE_MOD(to);\n\t}\n\n\tif (to != PAD(c->wbuf_ofs + c->wbuf_len)) {\n\t\t \n\t\tpr_crit(\"%s(): Non-contiguous write to %08lx\\n\",\n\t\t\t__func__, (unsigned long)to);\n\t\tif (c->wbuf_len)\n\t\t\tpr_crit(\"wbuf was previously %08x-%08x\\n\",\n\t\t\t\tc->wbuf_ofs, c->wbuf_ofs + c->wbuf_len);\n\t\tBUG();\n\t}\n\n\t \n\tif (c->wbuf_len != PAGE_MOD(to)) {\n\t\tc->wbuf_len = PAGE_MOD(to);\n\t\t \n\t\tif (!c->wbuf_len) {\n\t\t\tc->wbuf_len = c->wbuf_pagesize;\n\t\t\tret = __jffs2_flush_wbuf(c, NOPAD);\n\t\t\tif (ret)\n\t\t\t\tgoto outerr;\n\t\t}\n\t}\n\n\tfor (invec = 0; invec < count; invec++) {\n\t\tint vlen = invecs[invec].iov_len;\n\t\tuint8_t *v = invecs[invec].iov_base;\n\n\t\twbuf_retlen = jffs2_fill_wbuf(c, v, vlen);\n\n\t\tif (c->wbuf_len == c->wbuf_pagesize) {\n\t\t\tret = __jffs2_flush_wbuf(c, NOPAD);\n\t\t\tif (ret)\n\t\t\t\tgoto outerr;\n\t\t}\n\t\tvlen -= wbuf_retlen;\n\t\toutvec_to += wbuf_retlen;\n\t\tdonelen += wbuf_retlen;\n\t\tv += wbuf_retlen;\n\n\t\tif (vlen >= c->wbuf_pagesize) {\n\t\t\tret = mtd_write(c->mtd, outvec_to, PAGE_DIV(vlen),\n\t\t\t\t\t&wbuf_retlen, v);\n\t\t\tif (ret < 0 || wbuf_retlen != PAGE_DIV(vlen))\n\t\t\t\tgoto outfile;\n\n\t\t\tvlen -= wbuf_retlen;\n\t\t\toutvec_to += wbuf_retlen;\n\t\t\tc->wbuf_ofs = outvec_to;\n\t\t\tdonelen += wbuf_retlen;\n\t\t\tv += wbuf_retlen;\n\t\t}\n\n\t\twbuf_retlen = jffs2_fill_wbuf(c, v, vlen);\n\t\tif (c->wbuf_len == c->wbuf_pagesize) {\n\t\t\tret = __jffs2_flush_wbuf(c, NOPAD);\n\t\t\tif (ret)\n\t\t\t\tgoto outerr;\n\t\t}\n\n\t\toutvec_to += wbuf_retlen;\n\t\tdonelen += wbuf_retlen;\n\t}\n\n\t \n\t*retlen = donelen;\n\n\tif (jffs2_sum_active()) {\n\t\tint res = jffs2_sum_add_kvec(c, invecs, count, (uint32_t) to);\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\n\tif (c->wbuf_len && ino)\n\t\tjffs2_wbuf_dirties_inode(c, ino);\n\n\tret = 0;\n\tup_write(&c->wbuf_sem);\n\treturn ret;\n\noutfile:\n\t \n\n\tspin_lock(&c->erase_completion_lock);\n\n\tjeb = &c->blocks[outvec_to / c->sector_size];\n\tjffs2_block_refile(c, jeb, REFILE_ANYWAY);\n\n\tspin_unlock(&c->erase_completion_lock);\n\nouterr:\n\t*retlen = 0;\n\tup_write(&c->wbuf_sem);\n\treturn ret;\n}\n\n \nint jffs2_flash_write(struct jffs2_sb_info *c, loff_t ofs, size_t len,\n\t\t      size_t *retlen, const u_char *buf)\n{\n\tstruct kvec vecs[1];\n\n\tif (!jffs2_is_writebuffered(c))\n\t\treturn jffs2_flash_direct_write(c, ofs, len, retlen, buf);\n\n\tvecs[0].iov_base = (unsigned char *) buf;\n\tvecs[0].iov_len = len;\n\treturn jffs2_flash_writev(c, vecs, 1, ofs, retlen, 0);\n}\n\n \nint jffs2_flash_read(struct jffs2_sb_info *c, loff_t ofs, size_t len, size_t *retlen, u_char *buf)\n{\n\tloff_t\torbf = 0, owbf = 0, lwbf = 0;\n\tint\tret;\n\n\tif (!jffs2_is_writebuffered(c))\n\t\treturn mtd_read(c->mtd, ofs, len, retlen, buf);\n\n\t \n\tdown_read(&c->wbuf_sem);\n\tret = mtd_read(c->mtd, ofs, len, retlen, buf);\n\n\tif ( (ret == -EBADMSG || ret == -EUCLEAN) && (*retlen == len) ) {\n\t\tif (ret == -EBADMSG)\n\t\t\tpr_warn(\"mtd->read(0x%zx bytes from 0x%llx) returned ECC error\\n\",\n\t\t\t\tlen, ofs);\n\t\t \n\t\tret = 0;\n\t}\n\n\t \n\tif (!c->wbuf_pagesize || !c->wbuf_len)\n\t\tgoto exit;\n\n\t \n\tif (SECTOR_ADDR(ofs) != SECTOR_ADDR(c->wbuf_ofs))\n\t\tgoto exit;\n\n\tif (ofs >= c->wbuf_ofs) {\n\t\towbf = (ofs - c->wbuf_ofs);\t \n\t\tif (owbf > c->wbuf_len)\t\t \n\t\t\tgoto exit;\n\t\tlwbf = c->wbuf_len - owbf;\t \n\t\tif (lwbf > len)\n\t\t\tlwbf = len;\n\t} else {\n\t\torbf = (c->wbuf_ofs - ofs);\t \n\t\tif (orbf > len)\t\t\t \n\t\t\tgoto exit;\n\t\tlwbf = len - orbf;\t\t \n\t\tif (lwbf > c->wbuf_len)\n\t\t\tlwbf = c->wbuf_len;\n\t}\n\tif (lwbf > 0)\n\t\tmemcpy(buf+orbf,c->wbuf+owbf,lwbf);\n\nexit:\n\tup_read(&c->wbuf_sem);\n\treturn ret;\n}\n\n#define NR_OOB_SCAN_PAGES 4\n\n \n#define OOB_CM_SIZE 8\n\nstatic const struct jffs2_unknown_node oob_cleanmarker =\n{\n\t.magic = constant_cpu_to_je16(JFFS2_MAGIC_BITMASK),\n\t.nodetype = constant_cpu_to_je16(JFFS2_NODETYPE_CLEANMARKER),\n\t.totlen = constant_cpu_to_je32(8)\n};\n\n \nint jffs2_check_oob_empty(struct jffs2_sb_info *c,\n\t\t\t  struct jffs2_eraseblock *jeb, int mode)\n{\n\tint i, ret;\n\tint cmlen = min_t(int, c->oobavail, OOB_CM_SIZE);\n\tstruct mtd_oob_ops ops = { };\n\n\tops.mode = MTD_OPS_AUTO_OOB;\n\tops.ooblen = NR_OOB_SCAN_PAGES * c->oobavail;\n\tops.oobbuf = c->oobbuf;\n\tops.len = ops.ooboffs = ops.retlen = ops.oobretlen = 0;\n\tops.datbuf = NULL;\n\n\tret = mtd_read_oob(c->mtd, jeb->offset, &ops);\n\tif ((ret && !mtd_is_bitflip(ret)) || ops.oobretlen != ops.ooblen) {\n\t\tpr_err(\"cannot read OOB for EB at %08x, requested %zd bytes, read %zd bytes, error %d\\n\",\n\t\t       jeb->offset, ops.ooblen, ops.oobretlen, ret);\n\t\tif (!ret || mtd_is_bitflip(ret))\n\t\t\tret = -EIO;\n\t\treturn ret;\n\t}\n\n\tfor(i = 0; i < ops.ooblen; i++) {\n\t\tif (mode && i < cmlen)\n\t\t\t \n\t\t\tcontinue;\n\n\t\tif (ops.oobbuf[i] != 0xFF) {\n\t\t\tjffs2_dbg(2, \"Found %02x at %x in OOB for \"\n\t\t\t\t  \"%08x\\n\", ops.oobbuf[i], i, jeb->offset);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nint jffs2_check_nand_cleanmarker(struct jffs2_sb_info *c,\n\t\t\t\t struct jffs2_eraseblock *jeb)\n{\n\tstruct mtd_oob_ops ops = { };\n\tint ret, cmlen = min_t(int, c->oobavail, OOB_CM_SIZE);\n\n\tops.mode = MTD_OPS_AUTO_OOB;\n\tops.ooblen = cmlen;\n\tops.oobbuf = c->oobbuf;\n\tops.len = ops.ooboffs = ops.retlen = ops.oobretlen = 0;\n\tops.datbuf = NULL;\n\n\tret = mtd_read_oob(c->mtd, jeb->offset, &ops);\n\tif ((ret && !mtd_is_bitflip(ret)) || ops.oobretlen != ops.ooblen) {\n\t\tpr_err(\"cannot read OOB for EB at %08x, requested %zd bytes, read %zd bytes, error %d\\n\",\n\t\t       jeb->offset, ops.ooblen, ops.oobretlen, ret);\n\t\tif (!ret || mtd_is_bitflip(ret))\n\t\t\tret = -EIO;\n\t\treturn ret;\n\t}\n\n\treturn !!memcmp(&oob_cleanmarker, c->oobbuf, cmlen);\n}\n\nint jffs2_write_nand_cleanmarker(struct jffs2_sb_info *c,\n\t\t\t\t struct jffs2_eraseblock *jeb)\n{\n\tint ret;\n\tstruct mtd_oob_ops ops = { };\n\tint cmlen = min_t(int, c->oobavail, OOB_CM_SIZE);\n\n\tops.mode = MTD_OPS_AUTO_OOB;\n\tops.ooblen = cmlen;\n\tops.oobbuf = (uint8_t *)&oob_cleanmarker;\n\tops.len = ops.ooboffs = ops.retlen = ops.oobretlen = 0;\n\tops.datbuf = NULL;\n\n\tret = mtd_write_oob(c->mtd, jeb->offset, &ops);\n\tif (ret || ops.oobretlen != ops.ooblen) {\n\t\tpr_err(\"cannot write OOB for EB at %08x, requested %zd bytes, read %zd bytes, error %d\\n\",\n\t\t       jeb->offset, ops.ooblen, ops.oobretlen, ret);\n\t\tif (!ret)\n\t\t\tret = -EIO;\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \n\nint jffs2_write_nand_badblock(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb, uint32_t bad_offset)\n{\n\tint \tret;\n\n\t \n\tif( ++jeb->bad_count < MAX_ERASE_FAILURES)\n\t\treturn 0;\n\n\tpr_warn(\"marking eraseblock at %08x as bad\\n\", bad_offset);\n\tret = mtd_block_markbad(c->mtd, bad_offset);\n\n\tif (ret) {\n\t\tjffs2_dbg(1, \"%s(): Write failed for block at %08x: error %d\\n\",\n\t\t\t  __func__, jeb->offset, ret);\n\t\treturn ret;\n\t}\n\treturn 1;\n}\n\nstatic struct jffs2_sb_info *work_to_sb(struct work_struct *work)\n{\n\tstruct delayed_work *dwork;\n\n\tdwork = to_delayed_work(work);\n\treturn container_of(dwork, struct jffs2_sb_info, wbuf_dwork);\n}\n\nstatic void delayed_wbuf_sync(struct work_struct *work)\n{\n\tstruct jffs2_sb_info *c = work_to_sb(work);\n\tstruct super_block *sb = OFNI_BS_2SFFJ(c);\n\n\tif (!sb_rdonly(sb)) {\n\t\tjffs2_dbg(1, \"%s()\\n\", __func__);\n\t\tjffs2_flush_wbuf_gc(c, 0);\n\t}\n}\n\nvoid jffs2_dirty_trigger(struct jffs2_sb_info *c)\n{\n\tstruct super_block *sb = OFNI_BS_2SFFJ(c);\n\tunsigned long delay;\n\n\tif (sb_rdonly(sb))\n\t\treturn;\n\n\tdelay = msecs_to_jiffies(dirty_writeback_interval * 10);\n\tif (queue_delayed_work(system_long_wq, &c->wbuf_dwork, delay))\n\t\tjffs2_dbg(1, \"%s()\\n\", __func__);\n}\n\nint jffs2_nand_flash_setup(struct jffs2_sb_info *c)\n{\n\tif (!c->mtd->oobsize)\n\t\treturn 0;\n\n\t \n\tc->cleanmarker_size = 0;\n\n\tif (c->mtd->oobavail == 0) {\n\t\tpr_err(\"inconsistent device description\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tjffs2_dbg(1, \"using OOB on NAND\\n\");\n\n\tc->oobavail = c->mtd->oobavail;\n\n\t \n\tinit_rwsem(&c->wbuf_sem);\n\tINIT_DELAYED_WORK(&c->wbuf_dwork, delayed_wbuf_sync);\n\tc->wbuf_pagesize = c->mtd->writesize;\n\tc->wbuf_ofs = 0xFFFFFFFF;\n\n\tc->wbuf = kmalloc(c->wbuf_pagesize, GFP_KERNEL);\n\tif (!c->wbuf)\n\t\treturn -ENOMEM;\n\n\tc->oobbuf = kmalloc_array(NR_OOB_SCAN_PAGES, c->oobavail, GFP_KERNEL);\n\tif (!c->oobbuf) {\n\t\tkfree(c->wbuf);\n\t\treturn -ENOMEM;\n\t}\n\n#ifdef CONFIG_JFFS2_FS_WBUF_VERIFY\n\tc->wbuf_verify = kmalloc(c->wbuf_pagesize, GFP_KERNEL);\n\tif (!c->wbuf_verify) {\n\t\tkfree(c->oobbuf);\n\t\tkfree(c->wbuf);\n\t\treturn -ENOMEM;\n\t}\n#endif\n\treturn 0;\n}\n\nvoid jffs2_nand_flash_cleanup(struct jffs2_sb_info *c)\n{\n#ifdef CONFIG_JFFS2_FS_WBUF_VERIFY\n\tkfree(c->wbuf_verify);\n#endif\n\tkfree(c->wbuf);\n\tkfree(c->oobbuf);\n}\n\nint jffs2_dataflash_setup(struct jffs2_sb_info *c) {\n\tc->cleanmarker_size = 0;\t\t \n\n\t \n\tinit_rwsem(&c->wbuf_sem);\n\tINIT_DELAYED_WORK(&c->wbuf_dwork, delayed_wbuf_sync);\n\tc->wbuf_pagesize =  c->mtd->erasesize;\n\n\t \n\n\tc->sector_size = 8 * c->mtd->erasesize;\n\n\twhile (c->sector_size < 8192) {\n\t\tc->sector_size *= 2;\n\t}\n\n\t \n\tc->flash_size = c->mtd->size;\n\n\tif ((c->flash_size % c->sector_size) != 0) {\n\t\tc->flash_size = (c->flash_size / c->sector_size) * c->sector_size;\n\t\tpr_warn(\"flash size adjusted to %dKiB\\n\", c->flash_size);\n\t}\n\n\tc->wbuf_ofs = 0xFFFFFFFF;\n\tc->wbuf = kmalloc(c->wbuf_pagesize, GFP_KERNEL);\n\tif (!c->wbuf)\n\t\treturn -ENOMEM;\n\n#ifdef CONFIG_JFFS2_FS_WBUF_VERIFY\n\tc->wbuf_verify = kmalloc(c->wbuf_pagesize, GFP_KERNEL);\n\tif (!c->wbuf_verify) {\n\t\tkfree(c->wbuf);\n\t\treturn -ENOMEM;\n\t}\n#endif\n\n\tpr_info(\"write-buffering enabled buffer (%d) erasesize (%d)\\n\",\n\t\tc->wbuf_pagesize, c->sector_size);\n\n\treturn 0;\n}\n\nvoid jffs2_dataflash_cleanup(struct jffs2_sb_info *c) {\n#ifdef CONFIG_JFFS2_FS_WBUF_VERIFY\n\tkfree(c->wbuf_verify);\n#endif\n\tkfree(c->wbuf);\n}\n\nint jffs2_nor_wbuf_flash_setup(struct jffs2_sb_info *c) {\n\t \n\tc->cleanmarker_size = max(16u, c->mtd->writesize);\n\n\t \n\tinit_rwsem(&c->wbuf_sem);\n\tINIT_DELAYED_WORK(&c->wbuf_dwork, delayed_wbuf_sync);\n\n\tc->wbuf_pagesize = c->mtd->writesize;\n\tc->wbuf_ofs = 0xFFFFFFFF;\n\n\tc->wbuf = kmalloc(c->wbuf_pagesize, GFP_KERNEL);\n\tif (!c->wbuf)\n\t\treturn -ENOMEM;\n\n#ifdef CONFIG_JFFS2_FS_WBUF_VERIFY\n\tc->wbuf_verify = kmalloc(c->wbuf_pagesize, GFP_KERNEL);\n\tif (!c->wbuf_verify) {\n\t\tkfree(c->wbuf);\n\t\treturn -ENOMEM;\n\t}\n#endif\n\treturn 0;\n}\n\nvoid jffs2_nor_wbuf_flash_cleanup(struct jffs2_sb_info *c) {\n#ifdef CONFIG_JFFS2_FS_WBUF_VERIFY\n\tkfree(c->wbuf_verify);\n#endif\n\tkfree(c->wbuf);\n}\n\nint jffs2_ubivol_setup(struct jffs2_sb_info *c) {\n\tc->cleanmarker_size = 0;\n\n\tif (c->mtd->writesize == 1)\n\t\t \n\t\treturn 0;\n\n\tinit_rwsem(&c->wbuf_sem);\n\tINIT_DELAYED_WORK(&c->wbuf_dwork, delayed_wbuf_sync);\n\n\tc->wbuf_pagesize =  c->mtd->writesize;\n\tc->wbuf_ofs = 0xFFFFFFFF;\n\tc->wbuf = kmalloc(c->wbuf_pagesize, GFP_KERNEL);\n\tif (!c->wbuf)\n\t\treturn -ENOMEM;\n\n\tpr_info(\"write-buffering enabled buffer (%d) erasesize (%d)\\n\",\n\t\tc->wbuf_pagesize, c->sector_size);\n\n\treturn 0;\n}\n\nvoid jffs2_ubivol_cleanup(struct jffs2_sb_info *c) {\n\tkfree(c->wbuf);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}