{
  "module_name": "summary.c",
  "hash_id": "8a36d47679d559383178170ec496cd6049aebabf3126ec973bf6a03f18aea8f2",
  "original_prompt": "Ingested from linux-6.6.14/fs/jffs2/summary.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/crc32.h>\n#include <linux/compiler.h>\n#include <linux/vmalloc.h>\n#include \"nodelist.h\"\n#include \"debug.h\"\n\nint jffs2_sum_init(struct jffs2_sb_info *c)\n{\n\tuint32_t sum_size = min_t(uint32_t, c->sector_size, MAX_SUMMARY_SIZE);\n\n\tc->summary = kzalloc(sizeof(struct jffs2_summary), GFP_KERNEL);\n\n\tif (!c->summary) {\n\t\tJFFS2_WARNING(\"Can't allocate memory for summary information!\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tc->summary->sum_buf = kmalloc(sum_size, GFP_KERNEL);\n\n\tif (!c->summary->sum_buf) {\n\t\tJFFS2_WARNING(\"Can't allocate buffer for writing out summary information!\\n\");\n\t\tkfree(c->summary);\n\t\treturn -ENOMEM;\n\t}\n\n\tdbg_summary(\"returned successfully\\n\");\n\n\treturn 0;\n}\n\nvoid jffs2_sum_exit(struct jffs2_sb_info *c)\n{\n\tdbg_summary(\"called\\n\");\n\n\tjffs2_sum_disable_collecting(c->summary);\n\n\tkfree(c->summary->sum_buf);\n\tc->summary->sum_buf = NULL;\n\n\tkfree(c->summary);\n\tc->summary = NULL;\n}\n\nstatic int jffs2_sum_add_mem(struct jffs2_summary *s, union jffs2_sum_mem *item)\n{\n\tif (!s->sum_list_head)\n\t\ts->sum_list_head = (union jffs2_sum_mem *) item;\n\tif (s->sum_list_tail)\n\t\ts->sum_list_tail->u.next = (union jffs2_sum_mem *) item;\n\ts->sum_list_tail = (union jffs2_sum_mem *) item;\n\n\tswitch (je16_to_cpu(item->u.nodetype)) {\n\t\tcase JFFS2_NODETYPE_INODE:\n\t\t\ts->sum_size += JFFS2_SUMMARY_INODE_SIZE;\n\t\t\ts->sum_num++;\n\t\t\tdbg_summary(\"inode (%u) added to summary\\n\",\n\t\t\t\t\t\tje32_to_cpu(item->i.inode));\n\t\t\tbreak;\n\t\tcase JFFS2_NODETYPE_DIRENT:\n\t\t\ts->sum_size += JFFS2_SUMMARY_DIRENT_SIZE(item->d.nsize);\n\t\t\ts->sum_num++;\n\t\t\tdbg_summary(\"dirent (%u) added to summary\\n\",\n\t\t\t\t\t\tje32_to_cpu(item->d.ino));\n\t\t\tbreak;\n#ifdef CONFIG_JFFS2_FS_XATTR\n\t\tcase JFFS2_NODETYPE_XATTR:\n\t\t\ts->sum_size += JFFS2_SUMMARY_XATTR_SIZE;\n\t\t\ts->sum_num++;\n\t\t\tdbg_summary(\"xattr (xid=%u, version=%u) added to summary\\n\",\n\t\t\t\t    je32_to_cpu(item->x.xid), je32_to_cpu(item->x.version));\n\t\t\tbreak;\n\t\tcase JFFS2_NODETYPE_XREF:\n\t\t\ts->sum_size += JFFS2_SUMMARY_XREF_SIZE;\n\t\t\ts->sum_num++;\n\t\t\tdbg_summary(\"xref added to summary\\n\");\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tJFFS2_WARNING(\"UNKNOWN node type %u\\n\",\n\t\t\t\t\t    je16_to_cpu(item->u.nodetype));\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n\n \n\nint jffs2_sum_add_padding_mem(struct jffs2_summary *s, uint32_t size)\n{\n\tdbg_summary(\"called with %u\\n\", size);\n\ts->sum_padded += size;\n\treturn 0;\n}\n\nint jffs2_sum_add_inode_mem(struct jffs2_summary *s, struct jffs2_raw_inode *ri,\n\t\t\t\tuint32_t ofs)\n{\n\tstruct jffs2_sum_inode_mem *temp = kmalloc(sizeof(struct jffs2_sum_inode_mem), GFP_KERNEL);\n\n\tif (!temp)\n\t\treturn -ENOMEM;\n\n\ttemp->nodetype = ri->nodetype;\n\ttemp->inode = ri->ino;\n\ttemp->version = ri->version;\n\ttemp->offset = cpu_to_je32(ofs);  \n\ttemp->totlen = ri->totlen;\n\ttemp->next = NULL;\n\n\treturn jffs2_sum_add_mem(s, (union jffs2_sum_mem *)temp);\n}\n\nint jffs2_sum_add_dirent_mem(struct jffs2_summary *s, struct jffs2_raw_dirent *rd,\n\t\t\t\tuint32_t ofs)\n{\n\tstruct jffs2_sum_dirent_mem *temp =\n\t\tkmalloc(sizeof(struct jffs2_sum_dirent_mem) + rd->nsize, GFP_KERNEL);\n\n\tif (!temp)\n\t\treturn -ENOMEM;\n\n\ttemp->nodetype = rd->nodetype;\n\ttemp->totlen = rd->totlen;\n\ttemp->offset = cpu_to_je32(ofs);\t \n\ttemp->pino = rd->pino;\n\ttemp->version = rd->version;\n\ttemp->ino = rd->ino;\n\ttemp->nsize = rd->nsize;\n\ttemp->type = rd->type;\n\ttemp->next = NULL;\n\n\tmemcpy(temp->name, rd->name, rd->nsize);\n\n\treturn jffs2_sum_add_mem(s, (union jffs2_sum_mem *)temp);\n}\n\n#ifdef CONFIG_JFFS2_FS_XATTR\nint jffs2_sum_add_xattr_mem(struct jffs2_summary *s, struct jffs2_raw_xattr *rx, uint32_t ofs)\n{\n\tstruct jffs2_sum_xattr_mem *temp;\n\n\ttemp = kmalloc(sizeof(struct jffs2_sum_xattr_mem), GFP_KERNEL);\n\tif (!temp)\n\t\treturn -ENOMEM;\n\n\ttemp->nodetype = rx->nodetype;\n\ttemp->xid = rx->xid;\n\ttemp->version = rx->version;\n\ttemp->offset = cpu_to_je32(ofs);\n\ttemp->totlen = rx->totlen;\n\ttemp->next = NULL;\n\n\treturn jffs2_sum_add_mem(s, (union jffs2_sum_mem *)temp);\n}\n\nint jffs2_sum_add_xref_mem(struct jffs2_summary *s, struct jffs2_raw_xref *rr, uint32_t ofs)\n{\n\tstruct jffs2_sum_xref_mem *temp;\n\n\ttemp = kmalloc(sizeof(struct jffs2_sum_xref_mem), GFP_KERNEL);\n\tif (!temp)\n\t\treturn -ENOMEM;\n\n\ttemp->nodetype = rr->nodetype;\n\ttemp->offset = cpu_to_je32(ofs);\n\ttemp->next = NULL;\n\n\treturn jffs2_sum_add_mem(s, (union jffs2_sum_mem *)temp);\n}\n#endif\n \n\nstatic void jffs2_sum_clean_collected(struct jffs2_summary *s)\n{\n\tunion jffs2_sum_mem *temp;\n\n\tif (!s->sum_list_head) {\n\t\tdbg_summary(\"already empty\\n\");\n\t}\n\twhile (s->sum_list_head) {\n\t\ttemp = s->sum_list_head;\n\t\ts->sum_list_head = s->sum_list_head->u.next;\n\t\tkfree(temp);\n\t}\n\ts->sum_list_tail = NULL;\n\ts->sum_padded = 0;\n\ts->sum_num = 0;\n}\n\nvoid jffs2_sum_reset_collected(struct jffs2_summary *s)\n{\n\tdbg_summary(\"called\\n\");\n\tjffs2_sum_clean_collected(s);\n\ts->sum_size = 0;\n}\n\nvoid jffs2_sum_disable_collecting(struct jffs2_summary *s)\n{\n\tdbg_summary(\"called\\n\");\n\tjffs2_sum_clean_collected(s);\n\ts->sum_size = JFFS2_SUMMARY_NOSUM_SIZE;\n}\n\nint jffs2_sum_is_disabled(struct jffs2_summary *s)\n{\n\treturn (s->sum_size == JFFS2_SUMMARY_NOSUM_SIZE);\n}\n\n \n\nvoid jffs2_sum_move_collected(struct jffs2_sb_info *c, struct jffs2_summary *s)\n{\n\tdbg_summary(\"oldsize=0x%x oldnum=%u => newsize=0x%x newnum=%u\\n\",\n\t\t\t\tc->summary->sum_size, c->summary->sum_num,\n\t\t\t\ts->sum_size, s->sum_num);\n\n\tc->summary->sum_size = s->sum_size;\n\tc->summary->sum_num = s->sum_num;\n\tc->summary->sum_padded = s->sum_padded;\n\tc->summary->sum_list_head = s->sum_list_head;\n\tc->summary->sum_list_tail = s->sum_list_tail;\n\n\ts->sum_list_head = s->sum_list_tail = NULL;\n}\n\n \n\nint jffs2_sum_add_kvec(struct jffs2_sb_info *c, const struct kvec *invecs,\n\t\t\t\tunsigned long count, uint32_t ofs)\n{\n\tunion jffs2_node_union *node;\n\tstruct jffs2_eraseblock *jeb;\n\n\tif (c->summary->sum_size == JFFS2_SUMMARY_NOSUM_SIZE) {\n\t\tdbg_summary(\"Summary is disabled for this jeb! Skipping summary info!\\n\");\n\t\treturn 0;\n\t}\n\n\tnode = invecs[0].iov_base;\n\tjeb = &c->blocks[ofs / c->sector_size];\n\tofs -= jeb->offset;\n\n\tswitch (je16_to_cpu(node->u.nodetype)) {\n\t\tcase JFFS2_NODETYPE_INODE: {\n\t\t\tstruct jffs2_sum_inode_mem *temp =\n\t\t\t\tkmalloc(sizeof(struct jffs2_sum_inode_mem), GFP_KERNEL);\n\n\t\t\tif (!temp)\n\t\t\t\tgoto no_mem;\n\n\t\t\ttemp->nodetype = node->i.nodetype;\n\t\t\ttemp->inode = node->i.ino;\n\t\t\ttemp->version = node->i.version;\n\t\t\ttemp->offset = cpu_to_je32(ofs);\n\t\t\ttemp->totlen = node->i.totlen;\n\t\t\ttemp->next = NULL;\n\n\t\t\treturn jffs2_sum_add_mem(c->summary, (union jffs2_sum_mem *)temp);\n\t\t}\n\n\t\tcase JFFS2_NODETYPE_DIRENT: {\n\t\t\tstruct jffs2_sum_dirent_mem *temp =\n\t\t\t\tkmalloc(sizeof(struct jffs2_sum_dirent_mem) + node->d.nsize, GFP_KERNEL);\n\n\t\t\tif (!temp)\n\t\t\t\tgoto no_mem;\n\n\t\t\ttemp->nodetype = node->d.nodetype;\n\t\t\ttemp->totlen = node->d.totlen;\n\t\t\ttemp->offset = cpu_to_je32(ofs);\n\t\t\ttemp->pino = node->d.pino;\n\t\t\ttemp->version = node->d.version;\n\t\t\ttemp->ino = node->d.ino;\n\t\t\ttemp->nsize = node->d.nsize;\n\t\t\ttemp->type = node->d.type;\n\t\t\ttemp->next = NULL;\n\n\t\t\tswitch (count) {\n\t\t\t\tcase 1:\n\t\t\t\t\tmemcpy(temp->name,node->d.name,node->d.nsize);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\t\t\t\t\tmemcpy(temp->name,invecs[1].iov_base,node->d.nsize);\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tBUG();\t \n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\treturn jffs2_sum_add_mem(c->summary, (union jffs2_sum_mem *)temp);\n\t\t}\n#ifdef CONFIG_JFFS2_FS_XATTR\n\t\tcase JFFS2_NODETYPE_XATTR: {\n\t\t\tstruct jffs2_sum_xattr_mem *temp;\n\t\t\ttemp = kmalloc(sizeof(struct jffs2_sum_xattr_mem), GFP_KERNEL);\n\t\t\tif (!temp)\n\t\t\t\tgoto no_mem;\n\n\t\t\ttemp->nodetype = node->x.nodetype;\n\t\t\ttemp->xid = node->x.xid;\n\t\t\ttemp->version = node->x.version;\n\t\t\ttemp->totlen = node->x.totlen;\n\t\t\ttemp->offset = cpu_to_je32(ofs);\n\t\t\ttemp->next = NULL;\n\n\t\t\treturn jffs2_sum_add_mem(c->summary, (union jffs2_sum_mem *)temp);\n\t\t}\n\t\tcase JFFS2_NODETYPE_XREF: {\n\t\t\tstruct jffs2_sum_xref_mem *temp;\n\t\t\ttemp = kmalloc(sizeof(struct jffs2_sum_xref_mem), GFP_KERNEL);\n\t\t\tif (!temp)\n\t\t\t\tgoto no_mem;\n\t\t\ttemp->nodetype = node->r.nodetype;\n\t\t\ttemp->offset = cpu_to_je32(ofs);\n\t\t\ttemp->next = NULL;\n\n\t\t\treturn jffs2_sum_add_mem(c->summary, (union jffs2_sum_mem *)temp);\n\t\t}\n#endif\n\t\tcase JFFS2_NODETYPE_PADDING:\n\t\t\tdbg_summary(\"node PADDING\\n\");\n\t\t\tc->summary->sum_padded += je32_to_cpu(node->u.totlen);\n\t\t\tbreak;\n\n\t\tcase JFFS2_NODETYPE_CLEANMARKER:\n\t\t\tdbg_summary(\"node CLEANMARKER\\n\");\n\t\t\tbreak;\n\n\t\tcase JFFS2_NODETYPE_SUMMARY:\n\t\t\tdbg_summary(\"node SUMMARY\\n\");\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t \n\t\t\tBUG();\n\t\t\tbreak;\n\t}\n\n\treturn 0;\n\nno_mem:\n\tJFFS2_WARNING(\"MEMORY ALLOCATION ERROR!\");\n\treturn -ENOMEM;\n}\n\nstatic struct jffs2_raw_node_ref *sum_link_node_ref(struct jffs2_sb_info *c,\n\t\t\t\t\t\t    struct jffs2_eraseblock *jeb,\n\t\t\t\t\t\t    uint32_t ofs, uint32_t len,\n\t\t\t\t\t\t    struct jffs2_inode_cache *ic)\n{\n\t \n\tif ((ofs & ~3) > c->sector_size - jeb->free_size) {\n\t\t \n\t\tjffs2_scan_dirty_space(c, jeb, (ofs & ~3) - (c->sector_size - jeb->free_size));\n\t}\n\n\treturn jffs2_link_node_ref(c, jeb, jeb->offset + ofs, len, ic);\n}\n\n \n\nstatic int jffs2_sum_process_sum_data(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\tstruct jffs2_raw_summary *summary, uint32_t *pseudo_random)\n{\n\tstruct jffs2_inode_cache *ic;\n\tstruct jffs2_full_dirent *fd;\n\tvoid *sp;\n\tint i, ino;\n\tint err;\n\n\tsp = summary->sum;\n\n\tfor (i=0; i<je32_to_cpu(summary->sum_num); i++) {\n\t\tdbg_summary(\"processing summary index %d\\n\", i);\n\n\t\tcond_resched();\n\n\t\t \n\t\terr = jffs2_prealloc_raw_node_refs(c, jeb, 2);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tswitch (je16_to_cpu(((struct jffs2_sum_unknown_flash *)sp)->nodetype)) {\n\t\t\tcase JFFS2_NODETYPE_INODE: {\n\t\t\t\tstruct jffs2_sum_inode_flash *spi;\n\t\t\t\tspi = sp;\n\n\t\t\t\tino = je32_to_cpu(spi->inode);\n\n\t\t\t\tdbg_summary(\"Inode at 0x%08x-0x%08x\\n\",\n\t\t\t\t\t    jeb->offset + je32_to_cpu(spi->offset),\n\t\t\t\t\t    jeb->offset + je32_to_cpu(spi->offset) + je32_to_cpu(spi->totlen));\n\n\t\t\t\tic = jffs2_scan_make_ino_cache(c, ino);\n\t\t\t\tif (!ic) {\n\t\t\t\t\tJFFS2_NOTICE(\"scan_make_ino_cache failed\\n\");\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t\t}\n\n\t\t\t\tsum_link_node_ref(c, jeb, je32_to_cpu(spi->offset) | REF_UNCHECKED,\n\t\t\t\t\t\t  PAD(je32_to_cpu(spi->totlen)), ic);\n\n\t\t\t\t*pseudo_random += je32_to_cpu(spi->version);\n\n\t\t\t\tsp += JFFS2_SUMMARY_INODE_SIZE;\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase JFFS2_NODETYPE_DIRENT: {\n\t\t\t\tstruct jffs2_sum_dirent_flash *spd;\n\t\t\t\tint checkedlen;\n\t\t\t\tspd = sp;\n\n\t\t\t\tdbg_summary(\"Dirent at 0x%08x-0x%08x\\n\",\n\t\t\t\t\t    jeb->offset + je32_to_cpu(spd->offset),\n\t\t\t\t\t    jeb->offset + je32_to_cpu(spd->offset) + je32_to_cpu(spd->totlen));\n\n\n\t\t\t\t \n\t\t\t\t\tstruct jffs2_raw_node_ref *raw\n\t\t\t\t\t\t= sum_link_node_ref(c, jeb, je32_to_cpu(spx->offset) | REF_UNCHECKED,\n\t\t\t\t\t\t\t\t    PAD(je32_to_cpu(spx->totlen)), NULL);\n\t\t\t\t\traw->next_in_ino = xd->node->next_in_ino;\n\t\t\t\t\txd->node->next_in_ino = raw;\n\t\t\t\t} else {\n\t\t\t\t\txd->version = je32_to_cpu(spx->version);\n\t\t\t\t\tsum_link_node_ref(c, jeb, je32_to_cpu(spx->offset) | REF_UNCHECKED,\n\t\t\t\t\t\t\t  PAD(je32_to_cpu(spx->totlen)), (void *)xd);\n\t\t\t\t}\n\t\t\t\t*pseudo_random += je32_to_cpu(spx->xid);\n\t\t\t\tsp += JFFS2_SUMMARY_XATTR_SIZE;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase JFFS2_NODETYPE_XREF: {\n\t\t\t\tstruct jffs2_xattr_ref *ref;\n\t\t\t\tstruct jffs2_sum_xref_flash *spr;\n\n\t\t\t\tspr = (struct jffs2_sum_xref_flash *)sp;\n\t\t\t\tdbg_summary(\"xref at %#08x-%#08x\\n\",\n\t\t\t\t\t    jeb->offset + je32_to_cpu(spr->offset),\n\t\t\t\t\t    jeb->offset + je32_to_cpu(spr->offset) + \n\t\t\t\t\t    (uint32_t)PAD(sizeof(struct jffs2_raw_xref)));\n\n\t\t\t\tref = jffs2_alloc_xattr_ref();\n\t\t\t\tif (!ref) {\n\t\t\t\t\tJFFS2_NOTICE(\"allocation of xattr_datum failed\\n\");\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t\t}\n\t\t\t\tref->next = c->xref_temp;\n\t\t\t\tc->xref_temp = ref;\n\n\t\t\t\tsum_link_node_ref(c, jeb, je32_to_cpu(spr->offset) | REF_UNCHECKED,\n\t\t\t\t\t\t  PAD(sizeof(struct jffs2_raw_xref)), (void *)ref);\n\n\t\t\t\t*pseudo_random += ref->node->flash_offset;\n\t\t\t\tsp += JFFS2_SUMMARY_XREF_SIZE;\n\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n\t\t\tdefault : {\n\t\t\t\tuint16_t nodetype = je16_to_cpu(((struct jffs2_sum_unknown_flash *)sp)->nodetype);\n\t\t\t\tJFFS2_WARNING(\"Unsupported node type %x found in summary! Exiting...\\n\", nodetype);\n\t\t\t\tif ((nodetype & JFFS2_COMPAT_MASK) == JFFS2_FEATURE_INCOMPAT)\n\t\t\t\t\treturn -EIO;\n\n\t\t\t\t \n\t\t\t\tc->wasted_size -= jeb->wasted_size;\n\t\t\t\tc->free_size += c->sector_size - jeb->free_size;\n\t\t\t\tc->used_size -= jeb->used_size;\n\t\t\t\tc->dirty_size -= jeb->dirty_size;\n\t\t\t\tjeb->wasted_size = jeb->used_size = jeb->dirty_size = 0;\n\t\t\t\tjeb->free_size = c->sector_size;\n\n\t\t\t\tjffs2_free_jeb_node_refs(c, jeb);\n\t\t\t\treturn -ENOTRECOVERABLE;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nint jffs2_sum_scan_sumnode(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t   struct jffs2_raw_summary *summary, uint32_t sumsize,\n\t\t\t   uint32_t *pseudo_random)\n{\n\tstruct jffs2_unknown_node crcnode;\n\tint ret, ofs;\n\tuint32_t crc;\n\n\tofs = c->sector_size - sumsize;\n\n\tdbg_summary(\"summary found for 0x%08x at 0x%08x (0x%x bytes)\\n\",\n\t\t    jeb->offset, jeb->offset + ofs, sumsize);\n\n\t \n\tcrcnode.magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);\n\tcrcnode.nodetype = cpu_to_je16(JFFS2_NODETYPE_SUMMARY);\n\tcrcnode.totlen = summary->totlen;\n\tcrc = crc32(0, &crcnode, sizeof(crcnode)-4);\n\n\tif (je32_to_cpu(summary->hdr_crc) != crc) {\n\t\tdbg_summary(\"Summary node header is corrupt (bad CRC or \"\n\t\t\t\t\"no summary at all)\\n\");\n\t\tgoto crc_err;\n\t}\n\n\tif (je32_to_cpu(summary->totlen) != sumsize) {\n\t\tdbg_summary(\"Summary node is corrupt (wrong erasesize?)\\n\");\n\t\tgoto crc_err;\n\t}\n\n\tcrc = crc32(0, summary, sizeof(struct jffs2_raw_summary)-8);\n\n\tif (je32_to_cpu(summary->node_crc) != crc) {\n\t\tdbg_summary(\"Summary node is corrupt (bad CRC)\\n\");\n\t\tgoto crc_err;\n\t}\n\n\tcrc = crc32(0, summary->sum, sumsize - sizeof(struct jffs2_raw_summary));\n\n\tif (je32_to_cpu(summary->sum_crc) != crc) {\n\t\tdbg_summary(\"Summary node data is corrupt (bad CRC)\\n\");\n\t\tgoto crc_err;\n\t}\n\n\tif ( je32_to_cpu(summary->cln_mkr) ) {\n\n\t\tdbg_summary(\"Summary : CLEANMARKER node \\n\");\n\n\t\tret = jffs2_prealloc_raw_node_refs(c, jeb, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (je32_to_cpu(summary->cln_mkr) != c->cleanmarker_size) {\n\t\t\tdbg_summary(\"CLEANMARKER node has totlen 0x%x != normal 0x%x\\n\",\n\t\t\t\tje32_to_cpu(summary->cln_mkr), c->cleanmarker_size);\n\t\t\tif ((ret = jffs2_scan_dirty_space(c, jeb, PAD(je32_to_cpu(summary->cln_mkr)))))\n\t\t\t\treturn ret;\n\t\t} else if (jeb->first_node) {\n\t\t\tdbg_summary(\"CLEANMARKER node not first node in block \"\n\t\t\t\t\t\"(0x%08x)\\n\", jeb->offset);\n\t\t\tif ((ret = jffs2_scan_dirty_space(c, jeb, PAD(je32_to_cpu(summary->cln_mkr)))))\n\t\t\t\treturn ret;\n\t\t} else {\n\t\t\tjffs2_link_node_ref(c, jeb, jeb->offset | REF_NORMAL,\n\t\t\t\t\t    je32_to_cpu(summary->cln_mkr), NULL);\n\t\t}\n\t}\n\n\tret = jffs2_sum_process_sum_data(c, jeb, summary, pseudo_random);\n\t \n\tif (ret == -ENOTRECOVERABLE)\n\t\treturn 0;\n\tif (ret)\n\t\treturn ret;\t\t \n\n\t \n\tret = jffs2_prealloc_raw_node_refs(c, jeb, 2);\n\tif (ret)\n\t\treturn ret;\n\n\tsum_link_node_ref(c, jeb, ofs | REF_NORMAL, sumsize, NULL);\n\n\tif (unlikely(jeb->free_size)) {\n\t\tJFFS2_WARNING(\"Free size 0x%x bytes in eraseblock @0x%08x with summary?\\n\",\n\t\t\t      jeb->free_size, jeb->offset);\n\t\tjeb->wasted_size += jeb->free_size;\n\t\tc->wasted_size += jeb->free_size;\n\t\tc->free_size -= jeb->free_size;\n\t\tjeb->free_size = 0;\n\t}\n\n\treturn jffs2_scan_classify_jeb(c, jeb);\n\ncrc_err:\n\tJFFS2_WARNING(\"Summary node crc error, skipping summary information.\\n\");\n\n\treturn 0;\n}\n\n \n\nstatic int jffs2_sum_write_data(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\tuint32_t infosize, uint32_t datasize, int padsize)\n{\n\tstruct jffs2_raw_summary isum;\n\tunion jffs2_sum_mem *temp;\n\tstruct jffs2_sum_marker *sm;\n\tstruct kvec vecs[2];\n\tuint32_t sum_ofs;\n\tvoid *wpage;\n\tint ret;\n\tsize_t retlen;\n\n\tif (padsize + datasize > MAX_SUMMARY_SIZE) {\n\t\t \n\t\tjffs2_sum_disable_collecting(c->summary);\n\n\t\tJFFS2_WARNING(\"Summary too big (%d data, %d pad) in eraseblock at %08x\\n\",\n\t\t\t      datasize, padsize, jeb->offset);\n\t\t \n\t\treturn 0;\n\t}\n\t \n\tif (padsize < 0) {\n\t\t \n\t\tjffs2_sum_disable_collecting(c->summary);\n\n\t\tJFFS2_WARNING(\"Not enough space for summary, padsize = %d\\n\",\n\t\t\t      padsize);\n\t\t \n\t\treturn 0;\n\t}\n\n\tmemset(c->summary->sum_buf, 0xff, datasize);\n\tmemset(&isum, 0, sizeof(isum));\n\n\tisum.magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);\n\tisum.nodetype = cpu_to_je16(JFFS2_NODETYPE_SUMMARY);\n\tisum.totlen = cpu_to_je32(infosize);\n\tisum.hdr_crc = cpu_to_je32(crc32(0, &isum, sizeof(struct jffs2_unknown_node) - 4));\n\tisum.padded = cpu_to_je32(c->summary->sum_padded);\n\tisum.cln_mkr = cpu_to_je32(c->cleanmarker_size);\n\tisum.sum_num = cpu_to_je32(c->summary->sum_num);\n\twpage = c->summary->sum_buf;\n\n\twhile (c->summary->sum_num) {\n\t\ttemp = c->summary->sum_list_head;\n\n\t\tswitch (je16_to_cpu(temp->u.nodetype)) {\n\t\t\tcase JFFS2_NODETYPE_INODE: {\n\t\t\t\tstruct jffs2_sum_inode_flash *sino_ptr = wpage;\n\n\t\t\t\tsino_ptr->nodetype = temp->i.nodetype;\n\t\t\t\tsino_ptr->inode = temp->i.inode;\n\t\t\t\tsino_ptr->version = temp->i.version;\n\t\t\t\tsino_ptr->offset = temp->i.offset;\n\t\t\t\tsino_ptr->totlen = temp->i.totlen;\n\n\t\t\t\twpage += JFFS2_SUMMARY_INODE_SIZE;\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase JFFS2_NODETYPE_DIRENT: {\n\t\t\t\tstruct jffs2_sum_dirent_flash *sdrnt_ptr = wpage;\n\n\t\t\t\tsdrnt_ptr->nodetype = temp->d.nodetype;\n\t\t\t\tsdrnt_ptr->totlen = temp->d.totlen;\n\t\t\t\tsdrnt_ptr->offset = temp->d.offset;\n\t\t\t\tsdrnt_ptr->pino = temp->d.pino;\n\t\t\t\tsdrnt_ptr->version = temp->d.version;\n\t\t\t\tsdrnt_ptr->ino = temp->d.ino;\n\t\t\t\tsdrnt_ptr->nsize = temp->d.nsize;\n\t\t\t\tsdrnt_ptr->type = temp->d.type;\n\n\t\t\t\tmemcpy(sdrnt_ptr->name, temp->d.name,\n\t\t\t\t\t\t\ttemp->d.nsize);\n\n\t\t\t\twpage += JFFS2_SUMMARY_DIRENT_SIZE(temp->d.nsize);\n\n\t\t\t\tbreak;\n\t\t\t}\n#ifdef CONFIG_JFFS2_FS_XATTR\n\t\t\tcase JFFS2_NODETYPE_XATTR: {\n\t\t\t\tstruct jffs2_sum_xattr_flash *sxattr_ptr = wpage;\n\n\t\t\t\ttemp = c->summary->sum_list_head;\n\t\t\t\tsxattr_ptr->nodetype = temp->x.nodetype;\n\t\t\t\tsxattr_ptr->xid = temp->x.xid;\n\t\t\t\tsxattr_ptr->version = temp->x.version;\n\t\t\t\tsxattr_ptr->offset = temp->x.offset;\n\t\t\t\tsxattr_ptr->totlen = temp->x.totlen;\n\n\t\t\t\twpage += JFFS2_SUMMARY_XATTR_SIZE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase JFFS2_NODETYPE_XREF: {\n\t\t\t\tstruct jffs2_sum_xref_flash *sxref_ptr = wpage;\n\n\t\t\t\ttemp = c->summary->sum_list_head;\n\t\t\t\tsxref_ptr->nodetype = temp->r.nodetype;\n\t\t\t\tsxref_ptr->offset = temp->r.offset;\n\n\t\t\t\twpage += JFFS2_SUMMARY_XREF_SIZE;\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n\t\t\tdefault : {\n\t\t\t\tif ((je16_to_cpu(temp->u.nodetype) & JFFS2_COMPAT_MASK)\n\t\t\t\t    == JFFS2_FEATURE_RWCOMPAT_COPY) {\n\t\t\t\t\tdbg_summary(\"Writing unknown RWCOMPAT_COPY node type %x\\n\",\n\t\t\t\t\t\t    je16_to_cpu(temp->u.nodetype));\n\t\t\t\t\tjffs2_sum_disable_collecting(c->summary);\n\t\t\t\t\t \n\t\t\t\t\tgoto bail_rwcompat;\n\t\t\t\t} else {\n\t\t\t\t\tBUG();\t \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tc->summary->sum_list_head = temp->u.next;\n\t\tkfree(temp);\n\n\t\tc->summary->sum_num--;\n\t}\n bail_rwcompat:\n\n\tjffs2_sum_reset_collected(c->summary);\n\n\twpage += padsize;\n\n\tsm = wpage;\n\tsm->offset = cpu_to_je32(c->sector_size - jeb->free_size);\n\tsm->magic = cpu_to_je32(JFFS2_SUM_MAGIC);\n\n\tisum.sum_crc = cpu_to_je32(crc32(0, c->summary->sum_buf, datasize));\n\tisum.node_crc = cpu_to_je32(crc32(0, &isum, sizeof(isum) - 8));\n\n\tvecs[0].iov_base = &isum;\n\tvecs[0].iov_len = sizeof(isum);\n\tvecs[1].iov_base = c->summary->sum_buf;\n\tvecs[1].iov_len = datasize;\n\n\tsum_ofs = jeb->offset + c->sector_size - jeb->free_size;\n\n\tdbg_summary(\"writing out data to flash to pos : 0x%08x\\n\", sum_ofs);\n\n\tret = jffs2_flash_writev(c, vecs, 2, sum_ofs, &retlen, 0);\n\n\tif (ret || (retlen != infosize)) {\n\n\t\tJFFS2_WARNING(\"Write of %u bytes at 0x%08x failed. returned %d, retlen %zd\\n\",\n\t\t\t      infosize, sum_ofs, ret, retlen);\n\n\t\tif (retlen) {\n\t\t\t \n\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t\tjffs2_link_node_ref(c, jeb, sum_ofs | REF_OBSOLETE, infosize, NULL);\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t}\n\n\t\tc->summary->sum_size = JFFS2_SUMMARY_NOSUM_SIZE;\n\n\t\treturn 0;\n\t}\n\n\tspin_lock(&c->erase_completion_lock);\n\tjffs2_link_node_ref(c, jeb, sum_ofs | REF_NORMAL, infosize, NULL);\n\tspin_unlock(&c->erase_completion_lock);\n\n\treturn 0;\n}\n\n \n\nint jffs2_sum_write_sumnode(struct jffs2_sb_info *c)\n\t__must_hold(&c->erase_completion_block)\n{\n\tint datasize, infosize, padsize;\n\tstruct jffs2_eraseblock *jeb;\n\tint ret = 0;\n\n\tdbg_summary(\"called\\n\");\n\n\tspin_unlock(&c->erase_completion_lock);\n\n\tjeb = c->nextblock;\n\tjffs2_prealloc_raw_node_refs(c, jeb, 1);\n\n\tif (!c->summary->sum_num || !c->summary->sum_list_head) {\n\t\tJFFS2_WARNING(\"Empty summary info!!!\\n\");\n\t\tBUG();\n\t}\n\n\tdatasize = c->summary->sum_size + sizeof(struct jffs2_sum_marker);\n\tinfosize = sizeof(struct jffs2_raw_summary) + datasize;\n\tpadsize = jeb->free_size - infosize;\n\tinfosize += padsize;\n\tdatasize += padsize;\n\n\tret = jffs2_sum_write_data(c, jeb, infosize, datasize, padsize);\n\tspin_lock(&c->erase_completion_lock);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}