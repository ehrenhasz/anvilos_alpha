{
  "module_name": "debug.c",
  "hash_id": "5aa53b3e6697cad80778f258e559bf1c7f7c81521e5caf321193994544ffcd0d",
  "original_prompt": "Ingested from linux-6.6.14/fs/jffs2/debug.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/pagemap.h>\n#include <linux/crc32.h>\n#include <linux/jffs2.h>\n#include <linux/mtd/mtd.h>\n#include <linux/slab.h>\n#include \"nodelist.h\"\n#include \"debug.h\"\n\n#ifdef JFFS2_DBG_SANITY_CHECKS\n\nvoid\n__jffs2_dbg_acct_sanity_check_nolock(struct jffs2_sb_info *c,\n\t\t\t\t     struct jffs2_eraseblock *jeb)\n{\n\tif (unlikely(jeb && jeb->used_size + jeb->dirty_size +\n\t\t\tjeb->free_size + jeb->wasted_size +\n\t\t\tjeb->unchecked_size != c->sector_size)) {\n\t\tJFFS2_ERROR(\"eeep, space accounting for block at 0x%08x is screwed.\\n\", jeb->offset);\n\t\tJFFS2_ERROR(\"free %#08x + dirty %#08x + used %#08x + wasted %#08x + unchecked %#08x != total %#08x.\\n\",\n\t\t\tjeb->free_size, jeb->dirty_size, jeb->used_size,\n\t\t\tjeb->wasted_size, jeb->unchecked_size, c->sector_size);\n\t\tBUG();\n\t}\n\n\tif (unlikely(c->used_size + c->dirty_size + c->free_size + c->erasing_size + c->bad_size\n\t\t\t\t+ c->wasted_size + c->unchecked_size != c->flash_size)) {\n\t\tJFFS2_ERROR(\"eeep, space accounting superblock info is screwed.\\n\");\n\t\tJFFS2_ERROR(\"free %#08x + dirty %#08x + used %#08x + erasing %#08x + bad %#08x + wasted %#08x + unchecked %#08x != total %#08x.\\n\",\n\t\t\tc->free_size, c->dirty_size, c->used_size, c->erasing_size, c->bad_size,\n\t\t\tc->wasted_size, c->unchecked_size, c->flash_size);\n\t\tBUG();\n\t}\n}\n\nvoid\n__jffs2_dbg_acct_sanity_check(struct jffs2_sb_info *c,\n\t\t\t      struct jffs2_eraseblock *jeb)\n{\n\tspin_lock(&c->erase_completion_lock);\n\tjffs2_dbg_acct_sanity_check_nolock(c, jeb);\n\tspin_unlock(&c->erase_completion_lock);\n}\n\n#endif  \n\n#ifdef JFFS2_DBG_PARANOIA_CHECKS\n \nvoid\n__jffs2_dbg_fragtree_paranoia_check(struct jffs2_inode_info *f)\n{\n\tmutex_lock(&f->sem);\n\t__jffs2_dbg_fragtree_paranoia_check_nolock(f);\n\tmutex_unlock(&f->sem);\n}\n\nvoid\n__jffs2_dbg_fragtree_paranoia_check_nolock(struct jffs2_inode_info *f)\n{\n\tstruct jffs2_node_frag *frag;\n\tint bitched = 0;\n\n\tfor (frag = frag_first(&f->fragtree); frag; frag = frag_next(frag)) {\n\t\tstruct jffs2_full_dnode *fn = frag->node;\n\n\t\tif (!fn || !fn->raw)\n\t\t\tcontinue;\n\n\t\tif (ref_flags(fn->raw) == REF_PRISTINE) {\n\t\t\tif (fn->frags > 1) {\n\t\t\t\tJFFS2_ERROR(\"REF_PRISTINE node at 0x%08x had %d frags. Tell dwmw2.\\n\",\n\t\t\t\t\tref_offset(fn->raw), fn->frags);\n\t\t\t\tbitched = 1;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (frag->ofs & (PAGE_SIZE-1) && frag_prev(frag)\n\t\t\t\t\t&& frag_prev(frag)->size < PAGE_SIZE && frag_prev(frag)->node) {\n\t\t\t\tJFFS2_ERROR(\"REF_PRISTINE node at 0x%08x had a previous non-hole frag in the same page. Tell dwmw2.\\n\",\n\t\t\t\t\tref_offset(fn->raw));\n\t\t\t\tbitched = 1;\n\t\t\t}\n\n\t\t\tif ((frag->ofs+frag->size) & (PAGE_SIZE-1) && frag_next(frag)\n\t\t\t\t\t&& frag_next(frag)->size < PAGE_SIZE && frag_next(frag)->node) {\n\t\t\t\tJFFS2_ERROR(\"REF_PRISTINE node at 0x%08x (%08x-%08x) had a following non-hole frag in the same page. Tell dwmw2.\\n\",\n\t\t\t\t       ref_offset(fn->raw), frag->ofs, frag->ofs+frag->size);\n\t\t\t\tbitched = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (bitched) {\n\t\tJFFS2_ERROR(\"fragtree is corrupted.\\n\");\n\t\t__jffs2_dbg_dump_fragtree_nolock(f);\n\t\tBUG();\n\t}\n}\n\n \nvoid\n__jffs2_dbg_prewrite_paranoia_check(struct jffs2_sb_info *c,\n\t\t\t\t    uint32_t ofs, int len)\n{\n\tsize_t retlen;\n\tint ret, i;\n\tunsigned char *buf;\n\n\tbuf = kmalloc(len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn;\n\n\tret = jffs2_flash_read(c, ofs, len, &retlen, buf);\n\tif (ret || (retlen != len)) {\n\t\tJFFS2_WARNING(\"read %d bytes failed or short. ret %d, retlen %zd.\\n\",\n\t\t\t\tlen, ret, retlen);\n\t\tkfree(buf);\n\t\treturn;\n\t}\n\n\tret = 0;\n\tfor (i = 0; i < len; i++)\n\t\tif (buf[i] != 0xff)\n\t\t\tret = 1;\n\n\tif (ret) {\n\t\tJFFS2_ERROR(\"argh, about to write node to %#08x on flash, but there are data already there. The first corrupted byte is at %#08x offset.\\n\",\n\t\t\tofs, ofs + i);\n\t\t__jffs2_dbg_dump_buffer(buf, len, ofs);\n\t\tkfree(buf);\n\t\tBUG();\n\t}\n\n\tkfree(buf);\n}\n\nvoid __jffs2_dbg_superblock_counts(struct jffs2_sb_info *c)\n{\n\tstruct jffs2_eraseblock *jeb;\n\tuint32_t free = 0, dirty = 0, used = 0, wasted = 0,\n\t\terasing = 0, bad = 0, unchecked = 0;\n\tint nr_counted = 0;\n\tint dump = 0;\n\n\tif (c->gcblock) {\n\t\tnr_counted++;\n\t\tfree += c->gcblock->free_size;\n\t\tdirty += c->gcblock->dirty_size;\n\t\tused += c->gcblock->used_size;\n\t\twasted += c->gcblock->wasted_size;\n\t\tunchecked += c->gcblock->unchecked_size;\n\t}\n\tif (c->nextblock) {\n\t\tnr_counted++;\n\t\tfree += c->nextblock->free_size;\n\t\tdirty += c->nextblock->dirty_size;\n\t\tused += c->nextblock->used_size;\n\t\twasted += c->nextblock->wasted_size;\n\t\tunchecked += c->nextblock->unchecked_size;\n\t}\n\tlist_for_each_entry(jeb, &c->clean_list, list) {\n\t\tnr_counted++;\n\t\tfree += jeb->free_size;\n\t\tdirty += jeb->dirty_size;\n\t\tused += jeb->used_size;\n\t\twasted += jeb->wasted_size;\n\t\tunchecked += jeb->unchecked_size;\n\t}\n\tlist_for_each_entry(jeb, &c->very_dirty_list, list) {\n\t\tnr_counted++;\n\t\tfree += jeb->free_size;\n\t\tdirty += jeb->dirty_size;\n\t\tused += jeb->used_size;\n\t\twasted += jeb->wasted_size;\n\t\tunchecked += jeb->unchecked_size;\n\t}\n\tlist_for_each_entry(jeb, &c->dirty_list, list) {\n\t\tnr_counted++;\n\t\tfree += jeb->free_size;\n\t\tdirty += jeb->dirty_size;\n\t\tused += jeb->used_size;\n\t\twasted += jeb->wasted_size;\n\t\tunchecked += jeb->unchecked_size;\n\t}\n\tlist_for_each_entry(jeb, &c->erasable_list, list) {\n\t\tnr_counted++;\n\t\tfree += jeb->free_size;\n\t\tdirty += jeb->dirty_size;\n\t\tused += jeb->used_size;\n\t\twasted += jeb->wasted_size;\n\t\tunchecked += jeb->unchecked_size;\n\t}\n\tlist_for_each_entry(jeb, &c->erasable_pending_wbuf_list, list) {\n\t\tnr_counted++;\n\t\tfree += jeb->free_size;\n\t\tdirty += jeb->dirty_size;\n\t\tused += jeb->used_size;\n\t\twasted += jeb->wasted_size;\n\t\tunchecked += jeb->unchecked_size;\n\t}\n\tlist_for_each_entry(jeb, &c->erase_pending_list, list) {\n\t\tnr_counted++;\n\t\tfree += jeb->free_size;\n\t\tdirty += jeb->dirty_size;\n\t\tused += jeb->used_size;\n\t\twasted += jeb->wasted_size;\n\t\tunchecked += jeb->unchecked_size;\n\t}\n\tlist_for_each_entry(jeb, &c->free_list, list) {\n\t\tnr_counted++;\n\t\tfree += jeb->free_size;\n\t\tdirty += jeb->dirty_size;\n\t\tused += jeb->used_size;\n\t\twasted += jeb->wasted_size;\n\t\tunchecked += jeb->unchecked_size;\n\t}\n\tlist_for_each_entry(jeb, &c->bad_used_list, list) {\n\t\tnr_counted++;\n\t\tfree += jeb->free_size;\n\t\tdirty += jeb->dirty_size;\n\t\tused += jeb->used_size;\n\t\twasted += jeb->wasted_size;\n\t\tunchecked += jeb->unchecked_size;\n\t}\n\n\tlist_for_each_entry(jeb, &c->erasing_list, list) {\n\t\tnr_counted++;\n\t\terasing += c->sector_size;\n\t}\n\tlist_for_each_entry(jeb, &c->erase_checking_list, list) {\n\t\tnr_counted++;\n\t\terasing += c->sector_size;\n\t}\n\tlist_for_each_entry(jeb, &c->erase_complete_list, list) {\n\t\tnr_counted++;\n\t\terasing += c->sector_size;\n\t}\n\tlist_for_each_entry(jeb, &c->bad_list, list) {\n\t\tnr_counted++;\n\t\tbad += c->sector_size;\n\t}\n\n#define check(sz)\t\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (sz != c->sz##_size) {\t\t\t\t\t\\\n\t\tpr_warn(\"%s_size mismatch counted 0x%x, c->%s_size 0x%x\\n\", \\\n\t\t\t#sz, sz, #sz, c->sz##_size);\t\t\t\\\n\t\tdump = 1;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\n\tcheck(free);\n\tcheck(dirty);\n\tcheck(used);\n\tcheck(wasted);\n\tcheck(unchecked);\n\tcheck(bad);\n\tcheck(erasing);\n\n#undef check\n\n\tif (nr_counted != c->nr_blocks) {\n\t\tpr_warn(\"%s counted only 0x%x blocks of 0x%x. Where are the others?\\n\",\n\t\t\t__func__, nr_counted, c->nr_blocks);\n\t\tdump = 1;\n\t}\n\n\tif (dump) {\n\t\t__jffs2_dbg_dump_block_lists_nolock(c);\n\t\tBUG();\n\t}\n}\n\n \nvoid\n__jffs2_dbg_acct_paranoia_check(struct jffs2_sb_info *c,\n\t\t\t\tstruct jffs2_eraseblock *jeb)\n{\n\tspin_lock(&c->erase_completion_lock);\n\t__jffs2_dbg_acct_paranoia_check_nolock(c, jeb);\n\tspin_unlock(&c->erase_completion_lock);\n}\n\nvoid\n__jffs2_dbg_acct_paranoia_check_nolock(struct jffs2_sb_info *c,\n\t\t\t\t       struct jffs2_eraseblock *jeb)\n{\n\tuint32_t my_used_size = 0;\n\tuint32_t my_unchecked_size = 0;\n\tuint32_t my_dirty_size = 0;\n\tstruct jffs2_raw_node_ref *ref2 = jeb->first_node;\n\n\twhile (ref2) {\n\t\tuint32_t totlen = ref_totlen(c, jeb, ref2);\n\n\t\tif (ref_offset(ref2) < jeb->offset ||\n\t\t\t\tref_offset(ref2) > jeb->offset + c->sector_size) {\n\t\t\tJFFS2_ERROR(\"node_ref %#08x shouldn't be in block at %#08x.\\n\",\n\t\t\t\tref_offset(ref2), jeb->offset);\n\t\t\tgoto error;\n\n\t\t}\n\t\tif (ref_flags(ref2) == REF_UNCHECKED)\n\t\t\tmy_unchecked_size += totlen;\n\t\telse if (!ref_obsolete(ref2))\n\t\t\tmy_used_size += totlen;\n\t\telse\n\t\t\tmy_dirty_size += totlen;\n\n\t\tif ((!ref_next(ref2)) != (ref2 == jeb->last_node)) {\n\t\t\tJFFS2_ERROR(\"node_ref for node at %#08x (mem %p) has next at %#08x (mem %p), last_node is at %#08x (mem %p).\\n\",\n\t\t\t\t    ref_offset(ref2), ref2, ref_offset(ref_next(ref2)), ref_next(ref2),\n\t\t\t\t    ref_offset(jeb->last_node), jeb->last_node);\n\t\t\tgoto error;\n\t\t}\n\t\tref2 = ref_next(ref2);\n\t}\n\n\tif (my_used_size != jeb->used_size) {\n\t\tJFFS2_ERROR(\"Calculated used size %#08x != stored used size %#08x.\\n\",\n\t\t\tmy_used_size, jeb->used_size);\n\t\tgoto error;\n\t}\n\n\tif (my_unchecked_size != jeb->unchecked_size) {\n\t\tJFFS2_ERROR(\"Calculated unchecked size %#08x != stored unchecked size %#08x.\\n\",\n\t\t\tmy_unchecked_size, jeb->unchecked_size);\n\t\tgoto error;\n\t}\n\n#if 0\n\t \n\tif (my_dirty_size != jeb->dirty_size + jeb->wasted_size) {\n\t\tJFFS2_ERROR(\"Calculated dirty+wasted size %#08x != stored dirty + wasted size %#08x\\n\",\n\t\t\tmy_dirty_size, jeb->dirty_size + jeb->wasted_size);\n\t\tgoto error;\n\t}\n\n\tif (jeb->free_size == 0\n\t\t&& my_used_size + my_unchecked_size + my_dirty_size != c->sector_size) {\n\t\tJFFS2_ERROR(\"The sum of all nodes in block (%#x) != size of block (%#x)\\n\",\n\t\t\tmy_used_size + my_unchecked_size + my_dirty_size,\n\t\t\tc->sector_size);\n\t\tgoto error;\n\t}\n#endif\n\n\tif (!(c->flags & (JFFS2_SB_FLAG_BUILDING|JFFS2_SB_FLAG_SCANNING)))\n\t\t__jffs2_dbg_superblock_counts(c);\n\n\treturn;\n\nerror:\n\t__jffs2_dbg_dump_node_refs_nolock(c, jeb);\n\t__jffs2_dbg_dump_jeb_nolock(jeb);\n\t__jffs2_dbg_dump_block_lists_nolock(c);\n\tBUG();\n\n}\n#endif  \n\n#if defined(JFFS2_DBG_DUMPS) || defined(JFFS2_DBG_PARANOIA_CHECKS)\n \nvoid\n__jffs2_dbg_dump_node_refs(struct jffs2_sb_info *c,\n\t\t\t   struct jffs2_eraseblock *jeb)\n{\n\tspin_lock(&c->erase_completion_lock);\n\t__jffs2_dbg_dump_node_refs_nolock(c, jeb);\n\tspin_unlock(&c->erase_completion_lock);\n}\n\nvoid\n__jffs2_dbg_dump_node_refs_nolock(struct jffs2_sb_info *c,\n\t\t\t\t  struct jffs2_eraseblock *jeb)\n{\n\tstruct jffs2_raw_node_ref *ref;\n\tint i = 0;\n\n\tprintk(JFFS2_DBG_MSG_PREFIX \" Dump node_refs of the eraseblock %#08x\\n\", jeb->offset);\n\tif (!jeb->first_node) {\n\t\tprintk(JFFS2_DBG_MSG_PREFIX \" no nodes in the eraseblock %#08x\\n\", jeb->offset);\n\t\treturn;\n\t}\n\n\tprintk(JFFS2_DBG);\n\tfor (ref = jeb->first_node; ; ref = ref_next(ref)) {\n\t\tprintk(\"%#08x\", ref_offset(ref));\n#ifdef TEST_TOTLEN\n\t\tprintk(\"(%x)\", ref->__totlen);\n#endif\n\t\tif (ref_next(ref))\n\t\t\tprintk(\"->\");\n\t\telse\n\t\t\tbreak;\n\t\tif (++i == 4) {\n\t\t\ti = 0;\n\t\t\tprintk(\"\\n\" JFFS2_DBG);\n\t\t}\n\t}\n\tprintk(\"\\n\");\n}\n\n \nvoid\n__jffs2_dbg_dump_jeb(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb)\n{\n\tspin_lock(&c->erase_completion_lock);\n\t__jffs2_dbg_dump_jeb_nolock(jeb);\n\tspin_unlock(&c->erase_completion_lock);\n}\n\nvoid\n__jffs2_dbg_dump_jeb_nolock(struct jffs2_eraseblock *jeb)\n{\n\tif (!jeb)\n\t\treturn;\n\n\tprintk(JFFS2_DBG_MSG_PREFIX \" dump space accounting for the eraseblock at %#08x:\\n\",\n\t\t\tjeb->offset);\n\n\tprintk(JFFS2_DBG \"used_size: %#08x\\n\",\t\tjeb->used_size);\n\tprintk(JFFS2_DBG \"dirty_size: %#08x\\n\",\t\tjeb->dirty_size);\n\tprintk(JFFS2_DBG \"wasted_size: %#08x\\n\",\tjeb->wasted_size);\n\tprintk(JFFS2_DBG \"unchecked_size: %#08x\\n\",\tjeb->unchecked_size);\n\tprintk(JFFS2_DBG \"free_size: %#08x\\n\",\t\tjeb->free_size);\n}\n\nvoid\n__jffs2_dbg_dump_block_lists(struct jffs2_sb_info *c)\n{\n\tspin_lock(&c->erase_completion_lock);\n\t__jffs2_dbg_dump_block_lists_nolock(c);\n\tspin_unlock(&c->erase_completion_lock);\n}\n\nvoid\n__jffs2_dbg_dump_block_lists_nolock(struct jffs2_sb_info *c)\n{\n\tprintk(JFFS2_DBG_MSG_PREFIX \" dump JFFS2 blocks lists:\\n\");\n\n\tprintk(JFFS2_DBG \"flash_size: %#08x\\n\",\t\tc->flash_size);\n\tprintk(JFFS2_DBG \"used_size: %#08x\\n\",\t\tc->used_size);\n\tprintk(JFFS2_DBG \"dirty_size: %#08x\\n\",\t\tc->dirty_size);\n\tprintk(JFFS2_DBG \"wasted_size: %#08x\\n\",\tc->wasted_size);\n\tprintk(JFFS2_DBG \"unchecked_size: %#08x\\n\",\tc->unchecked_size);\n\tprintk(JFFS2_DBG \"free_size: %#08x\\n\",\t\tc->free_size);\n\tprintk(JFFS2_DBG \"erasing_size: %#08x\\n\",\tc->erasing_size);\n\tprintk(JFFS2_DBG \"bad_size: %#08x\\n\",\t\tc->bad_size);\n\tprintk(JFFS2_DBG \"sector_size: %#08x\\n\",\tc->sector_size);\n\tprintk(JFFS2_DBG \"jffs2_reserved_blocks size: %#08x\\n\",\n\t\t\t\tc->sector_size * c->resv_blocks_write);\n\n\tif (c->nextblock)\n\t\tprintk(JFFS2_DBG \"nextblock: %#08x (used %#08x, dirty %#08x, wasted %#08x, unchecked %#08x, free %#08x)\\n\",\n\t\t\tc->nextblock->offset, c->nextblock->used_size,\n\t\t\tc->nextblock->dirty_size, c->nextblock->wasted_size,\n\t\t\tc->nextblock->unchecked_size, c->nextblock->free_size);\n\telse\n\t\tprintk(JFFS2_DBG \"nextblock: NULL\\n\");\n\n\tif (c->gcblock)\n\t\tprintk(JFFS2_DBG \"gcblock: %#08x (used %#08x, dirty %#08x, wasted %#08x, unchecked %#08x, free %#08x)\\n\",\n\t\t\tc->gcblock->offset, c->gcblock->used_size, c->gcblock->dirty_size,\n\t\t\tc->gcblock->wasted_size, c->gcblock->unchecked_size, c->gcblock->free_size);\n\telse\n\t\tprintk(JFFS2_DBG \"gcblock: NULL\\n\");\n\n\tif (list_empty(&c->clean_list)) {\n\t\tprintk(JFFS2_DBG \"clean_list: empty\\n\");\n\t} else {\n\t\tstruct list_head *this;\n\t\tint numblocks = 0;\n\t\tuint32_t dirty = 0;\n\n\t\tlist_for_each(this, &c->clean_list) {\n\t\t\tstruct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);\n\t\t\tnumblocks ++;\n\t\t\tdirty += jeb->wasted_size;\n\t\t\tif (!(jeb->used_size == 0 && jeb->dirty_size == 0 && jeb->wasted_size == 0)) {\n\t\t\t\tprintk(JFFS2_DBG \"clean_list: %#08x (used %#08x, dirty %#08x, wasted %#08x, unchecked %#08x, free %#08x)\\n\",\n\t\t\t\t\tjeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size,\n\t\t\t\t\tjeb->unchecked_size, jeb->free_size);\n\t\t\t}\n\t\t}\n\n\t\tprintk (JFFS2_DBG \"Contains %d blocks with total wasted size %u, average wasted size: %u\\n\",\n\t\t\tnumblocks, dirty, dirty / numblocks);\n\t}\n\n\tif (list_empty(&c->very_dirty_list)) {\n\t\tprintk(JFFS2_DBG \"very_dirty_list: empty\\n\");\n\t} else {\n\t\tstruct list_head *this;\n\t\tint numblocks = 0;\n\t\tuint32_t dirty = 0;\n\n\t\tlist_for_each(this, &c->very_dirty_list) {\n\t\t\tstruct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);\n\n\t\t\tnumblocks ++;\n\t\t\tdirty += jeb->dirty_size;\n\t\t\tif (!(jeb->used_size == 0 && jeb->dirty_size == 0 && jeb->wasted_size == 0)) {\n\t\t\t\tprintk(JFFS2_DBG \"very_dirty_list: %#08x (used %#08x, dirty %#08x, wasted %#08x, unchecked %#08x, free %#08x)\\n\",\n\t\t\t\t\tjeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size,\n\t\t\t\t\tjeb->unchecked_size, jeb->free_size);\n\t\t\t}\n\t\t}\n\n\t\tprintk (JFFS2_DBG \"Contains %d blocks with total dirty size %u, average dirty size: %u\\n\",\n\t\t\tnumblocks, dirty, dirty / numblocks);\n\t}\n\n\tif (list_empty(&c->dirty_list)) {\n\t\tprintk(JFFS2_DBG \"dirty_list: empty\\n\");\n\t} else {\n\t\tstruct list_head *this;\n\t\tint numblocks = 0;\n\t\tuint32_t dirty = 0;\n\n\t\tlist_for_each(this, &c->dirty_list) {\n\t\t\tstruct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);\n\n\t\t\tnumblocks ++;\n\t\t\tdirty += jeb->dirty_size;\n\t\t\tif (!(jeb->used_size == 0 && jeb->dirty_size == 0 && jeb->wasted_size == 0)) {\n\t\t\t\tprintk(JFFS2_DBG \"dirty_list: %#08x (used %#08x, dirty %#08x, wasted %#08x, unchecked %#08x, free %#08x)\\n\",\n\t\t\t\t\tjeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size,\n\t\t\t\t\tjeb->unchecked_size, jeb->free_size);\n\t\t\t}\n\t\t}\n\n\t\tprintk (JFFS2_DBG \"contains %d blocks with total dirty size %u, average dirty size: %u\\n\",\n\t\t\tnumblocks, dirty, dirty / numblocks);\n\t}\n\n\tif (list_empty(&c->erasable_list)) {\n\t\tprintk(JFFS2_DBG \"erasable_list: empty\\n\");\n\t} else {\n\t\tstruct list_head *this;\n\n\t\tlist_for_each(this, &c->erasable_list) {\n\t\t\tstruct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);\n\n\t\t\tif (!(jeb->used_size == 0 && jeb->dirty_size == 0 && jeb->wasted_size == 0)) {\n\t\t\t\tprintk(JFFS2_DBG \"erasable_list: %#08x (used %#08x, dirty %#08x, wasted %#08x, unchecked %#08x, free %#08x)\\n\",\n\t\t\t\t\tjeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size,\n\t\t\t\t\tjeb->unchecked_size, jeb->free_size);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (list_empty(&c->erasing_list)) {\n\t\tprintk(JFFS2_DBG \"erasing_list: empty\\n\");\n\t} else {\n\t\tstruct list_head *this;\n\n\t\tlist_for_each(this, &c->erasing_list) {\n\t\t\tstruct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);\n\n\t\t\tif (!(jeb->used_size == 0 && jeb->dirty_size == 0 && jeb->wasted_size == 0)) {\n\t\t\t\tprintk(JFFS2_DBG \"erasing_list: %#08x (used %#08x, dirty %#08x, wasted %#08x, unchecked %#08x, free %#08x)\\n\",\n\t\t\t\t\tjeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size,\n\t\t\t\t\tjeb->unchecked_size, jeb->free_size);\n\t\t\t}\n\t\t}\n\t}\n\tif (list_empty(&c->erase_checking_list)) {\n\t\tprintk(JFFS2_DBG \"erase_checking_list: empty\\n\");\n\t} else {\n\t\tstruct list_head *this;\n\n\t\tlist_for_each(this, &c->erase_checking_list) {\n\t\t\tstruct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);\n\n\t\t\tif (!(jeb->used_size == 0 && jeb->dirty_size == 0 && jeb->wasted_size == 0)) {\n\t\t\t\tprintk(JFFS2_DBG \"erase_checking_list: %#08x (used %#08x, dirty %#08x, wasted %#08x, unchecked %#08x, free %#08x)\\n\",\n\t\t\t\t\tjeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size,\n\t\t\t\t\tjeb->unchecked_size, jeb->free_size);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (list_empty(&c->erase_pending_list)) {\n\t\tprintk(JFFS2_DBG \"erase_pending_list: empty\\n\");\n\t} else {\n\t\tstruct list_head *this;\n\n\t\tlist_for_each(this, &c->erase_pending_list) {\n\t\t\tstruct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);\n\n\t\t\tif (!(jeb->used_size == 0 && jeb->dirty_size == 0 && jeb->wasted_size == 0)) {\n\t\t\t\tprintk(JFFS2_DBG \"erase_pending_list: %#08x (used %#08x, dirty %#08x, wasted %#08x, unchecked %#08x, free %#08x)\\n\",\n\t\t\t\t\tjeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size,\n\t\t\t\t\tjeb->unchecked_size, jeb->free_size);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (list_empty(&c->erasable_pending_wbuf_list)) {\n\t\tprintk(JFFS2_DBG \"erasable_pending_wbuf_list: empty\\n\");\n\t} else {\n\t\tstruct list_head *this;\n\n\t\tlist_for_each(this, &c->erasable_pending_wbuf_list) {\n\t\t\tstruct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);\n\n\t\t\tif (!(jeb->used_size == 0 && jeb->dirty_size == 0 && jeb->wasted_size == 0)) {\n\t\t\t\tprintk(JFFS2_DBG \"erasable_pending_wbuf_list: %#08x (used %#08x, dirty %#08x, wasted %#08x, unchecked %#08x, free %#08x)\\n\",\n\t\t\t\t\tjeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size,\n\t\t\t\t\tjeb->unchecked_size, jeb->free_size);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (list_empty(&c->free_list)) {\n\t\tprintk(JFFS2_DBG \"free_list: empty\\n\");\n\t} else {\n\t\tstruct list_head *this;\n\n\t\tlist_for_each(this, &c->free_list) {\n\t\t\tstruct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);\n\n\t\t\tif (!(jeb->used_size == 0 && jeb->dirty_size == 0 && jeb->wasted_size == 0)) {\n\t\t\t\tprintk(JFFS2_DBG \"free_list: %#08x (used %#08x, dirty %#08x, wasted %#08x, unchecked %#08x, free %#08x)\\n\",\n\t\t\t\t\tjeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size,\n\t\t\t\t\tjeb->unchecked_size, jeb->free_size);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (list_empty(&c->bad_list)) {\n\t\tprintk(JFFS2_DBG \"bad_list: empty\\n\");\n\t} else {\n\t\tstruct list_head *this;\n\n\t\tlist_for_each(this, &c->bad_list) {\n\t\t\tstruct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);\n\n\t\t\tif (!(jeb->used_size == 0 && jeb->dirty_size == 0 && jeb->wasted_size == 0)) {\n\t\t\t\tprintk(JFFS2_DBG \"bad_list: %#08x (used %#08x, dirty %#08x, wasted %#08x, unchecked %#08x, free %#08x)\\n\",\n\t\t\t\t\tjeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size,\n\t\t\t\t\tjeb->unchecked_size, jeb->free_size);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (list_empty(&c->bad_used_list)) {\n\t\tprintk(JFFS2_DBG \"bad_used_list: empty\\n\");\n\t} else {\n\t\tstruct list_head *this;\n\n\t\tlist_for_each(this, &c->bad_used_list) {\n\t\t\tstruct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);\n\n\t\t\tif (!(jeb->used_size == 0 && jeb->dirty_size == 0 && jeb->wasted_size == 0)) {\n\t\t\t\tprintk(JFFS2_DBG \"bad_used_list: %#08x (used %#08x, dirty %#08x, wasted %#08x, unchecked %#08x, free %#08x)\\n\",\n\t\t\t\t\tjeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size,\n\t\t\t\t\tjeb->unchecked_size, jeb->free_size);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid\n__jffs2_dbg_dump_fragtree(struct jffs2_inode_info *f)\n{\n\tmutex_lock(&f->sem);\n\tjffs2_dbg_dump_fragtree_nolock(f);\n\tmutex_unlock(&f->sem);\n}\n\nvoid\n__jffs2_dbg_dump_fragtree_nolock(struct jffs2_inode_info *f)\n{\n\tstruct jffs2_node_frag *this = frag_first(&f->fragtree);\n\tuint32_t lastofs = 0;\n\tint buggy = 0;\n\n\tprintk(JFFS2_DBG_MSG_PREFIX \" dump fragtree of ino #%u\\n\", f->inocache->ino);\n\twhile(this) {\n\t\tif (this->node)\n\t\t\tprintk(JFFS2_DBG \"frag %#04x-%#04x: %#08x(%d) on flash (*%p), left (%p), right (%p), parent (%p)\\n\",\n\t\t\t\tthis->ofs, this->ofs+this->size, ref_offset(this->node->raw),\n\t\t\t\tref_flags(this->node->raw), this, frag_left(this), frag_right(this),\n\t\t\t\tfrag_parent(this));\n\t\telse\n\t\t\tprintk(JFFS2_DBG \"frag %#04x-%#04x: hole (*%p). left (%p), right (%p), parent (%p)\\n\",\n\t\t\t\tthis->ofs, this->ofs+this->size, this, frag_left(this),\n\t\t\t\tfrag_right(this), frag_parent(this));\n\t\tif (this->ofs != lastofs)\n\t\t\tbuggy = 1;\n\t\tlastofs = this->ofs + this->size;\n\t\tthis = frag_next(this);\n\t}\n\n\tif (f->metadata)\n\t\tprintk(JFFS2_DBG \"metadata at 0x%08x\\n\", ref_offset(f->metadata->raw));\n\n\tif (buggy) {\n\t\tJFFS2_ERROR(\"frag tree got a hole in it.\\n\");\n\t\tBUG();\n\t}\n}\n\n#define JFFS2_BUFDUMP_BYTES_PER_LINE\t32\nvoid\n__jffs2_dbg_dump_buffer(unsigned char *buf, int len, uint32_t offs)\n{\n\tint skip;\n\tint i;\n\n\tprintk(JFFS2_DBG_MSG_PREFIX \" dump from offset %#08x to offset %#08x (%x bytes).\\n\",\n\t\toffs, offs + len, len);\n\ti = skip = offs % JFFS2_BUFDUMP_BYTES_PER_LINE;\n\toffs = offs & ~(JFFS2_BUFDUMP_BYTES_PER_LINE - 1);\n\n\tif (skip != 0)\n\t\tprintk(JFFS2_DBG \"%#08x: \", offs);\n\n\twhile (skip--)\n\t\tprintk(\"   \");\n\n\twhile (i < len) {\n\t\tif ((i % JFFS2_BUFDUMP_BYTES_PER_LINE) == 0 && i != len -1) {\n\t\t\tif (i != 0)\n\t\t\t\tprintk(\"\\n\");\n\t\t\toffs += JFFS2_BUFDUMP_BYTES_PER_LINE;\n\t\t\tprintk(JFFS2_DBG \"%0#8x: \", offs);\n\t\t}\n\n\t\tprintk(\"%02x \", buf[i]);\n\n\t\ti += 1;\n\t}\n\n\tprintk(\"\\n\");\n}\n\n \nvoid\n__jffs2_dbg_dump_node(struct jffs2_sb_info *c, uint32_t ofs)\n{\n\tunion jffs2_node_union node;\n\tint len = sizeof(union jffs2_node_union);\n\tsize_t retlen;\n\tuint32_t crc;\n\tint ret;\n\n\tprintk(JFFS2_DBG_MSG_PREFIX \" dump node at offset %#08x.\\n\", ofs);\n\n\tret = jffs2_flash_read(c, ofs, len, &retlen, (unsigned char *)&node);\n\tif (ret || (retlen != len)) {\n\t\tJFFS2_ERROR(\"read %d bytes failed or short. ret %d, retlen %zd.\\n\",\n\t\t\tlen, ret, retlen);\n\t\treturn;\n\t}\n\n\tprintk(JFFS2_DBG \"magic:\\t%#04x\\n\", je16_to_cpu(node.u.magic));\n\tprintk(JFFS2_DBG \"nodetype:\\t%#04x\\n\", je16_to_cpu(node.u.nodetype));\n\tprintk(JFFS2_DBG \"totlen:\\t%#08x\\n\", je32_to_cpu(node.u.totlen));\n\tprintk(JFFS2_DBG \"hdr_crc:\\t%#08x\\n\", je32_to_cpu(node.u.hdr_crc));\n\n\tcrc = crc32(0, &node.u, sizeof(node.u) - 4);\n\tif (crc != je32_to_cpu(node.u.hdr_crc)) {\n\t\tJFFS2_ERROR(\"wrong common header CRC.\\n\");\n\t\treturn;\n\t}\n\n\tif (je16_to_cpu(node.u.magic) != JFFS2_MAGIC_BITMASK &&\n\t\tje16_to_cpu(node.u.magic) != JFFS2_OLD_MAGIC_BITMASK)\n\t{\n\t\tJFFS2_ERROR(\"wrong node magic: %#04x instead of %#04x.\\n\",\n\t\t\tje16_to_cpu(node.u.magic), JFFS2_MAGIC_BITMASK);\n\t\treturn;\n\t}\n\n\tswitch(je16_to_cpu(node.u.nodetype)) {\n\n\tcase JFFS2_NODETYPE_INODE:\n\n\t\tprintk(JFFS2_DBG \"the node is inode node\\n\");\n\t\tprintk(JFFS2_DBG \"ino:\\t%#08x\\n\", je32_to_cpu(node.i.ino));\n\t\tprintk(JFFS2_DBG \"version:\\t%#08x\\n\", je32_to_cpu(node.i.version));\n\t\tprintk(JFFS2_DBG \"mode:\\t%#08x\\n\", node.i.mode.m);\n\t\tprintk(JFFS2_DBG \"uid:\\t%#04x\\n\", je16_to_cpu(node.i.uid));\n\t\tprintk(JFFS2_DBG \"gid:\\t%#04x\\n\", je16_to_cpu(node.i.gid));\n\t\tprintk(JFFS2_DBG \"isize:\\t%#08x\\n\", je32_to_cpu(node.i.isize));\n\t\tprintk(JFFS2_DBG \"atime:\\t%#08x\\n\", je32_to_cpu(node.i.atime));\n\t\tprintk(JFFS2_DBG \"mtime:\\t%#08x\\n\", je32_to_cpu(node.i.mtime));\n\t\tprintk(JFFS2_DBG \"ctime:\\t%#08x\\n\", je32_to_cpu(node.i.ctime));\n\t\tprintk(JFFS2_DBG \"offset:\\t%#08x\\n\", je32_to_cpu(node.i.offset));\n\t\tprintk(JFFS2_DBG \"csize:\\t%#08x\\n\", je32_to_cpu(node.i.csize));\n\t\tprintk(JFFS2_DBG \"dsize:\\t%#08x\\n\", je32_to_cpu(node.i.dsize));\n\t\tprintk(JFFS2_DBG \"compr:\\t%#02x\\n\", node.i.compr);\n\t\tprintk(JFFS2_DBG \"usercompr:\\t%#02x\\n\", node.i.usercompr);\n\t\tprintk(JFFS2_DBG \"flags:\\t%#04x\\n\", je16_to_cpu(node.i.flags));\n\t\tprintk(JFFS2_DBG \"data_crc:\\t%#08x\\n\", je32_to_cpu(node.i.data_crc));\n\t\tprintk(JFFS2_DBG \"node_crc:\\t%#08x\\n\", je32_to_cpu(node.i.node_crc));\n\n\t\tcrc = crc32(0, &node.i, sizeof(node.i) - 8);\n\t\tif (crc != je32_to_cpu(node.i.node_crc)) {\n\t\t\tJFFS2_ERROR(\"wrong node header CRC.\\n\");\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tcase JFFS2_NODETYPE_DIRENT:\n\n\t\tprintk(JFFS2_DBG \"the node is dirent node\\n\");\n\t\tprintk(JFFS2_DBG \"pino:\\t%#08x\\n\", je32_to_cpu(node.d.pino));\n\t\tprintk(JFFS2_DBG \"version:\\t%#08x\\n\", je32_to_cpu(node.d.version));\n\t\tprintk(JFFS2_DBG \"ino:\\t%#08x\\n\", je32_to_cpu(node.d.ino));\n\t\tprintk(JFFS2_DBG \"mctime:\\t%#08x\\n\", je32_to_cpu(node.d.mctime));\n\t\tprintk(JFFS2_DBG \"nsize:\\t%#02x\\n\", node.d.nsize);\n\t\tprintk(JFFS2_DBG \"type:\\t%#02x\\n\", node.d.type);\n\t\tprintk(JFFS2_DBG \"node_crc:\\t%#08x\\n\", je32_to_cpu(node.d.node_crc));\n\t\tprintk(JFFS2_DBG \"name_crc:\\t%#08x\\n\", je32_to_cpu(node.d.name_crc));\n\n\t\tnode.d.name[node.d.nsize] = '\\0';\n\t\tprintk(JFFS2_DBG \"name:\\t\\\"%s\\\"\\n\", node.d.name);\n\n\t\tcrc = crc32(0, &node.d, sizeof(node.d) - 8);\n\t\tif (crc != je32_to_cpu(node.d.node_crc)) {\n\t\t\tJFFS2_ERROR(\"wrong node header CRC.\\n\");\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tprintk(JFFS2_DBG \"node type is unknown\\n\");\n\t\tbreak;\n\t}\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}