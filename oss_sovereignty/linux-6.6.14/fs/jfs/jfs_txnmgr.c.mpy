{
  "module_name": "jfs_txnmgr.c",
  "hash_id": "a705e92c0f7ccb3138923ae29c76098bcc4e0d01ff131ca523afecb65e13128c",
  "original_prompt": "Ingested from linux-6.6.14/fs/jfs/jfs_txnmgr.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/completion.h>\n#include <linux/freezer.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kthread.h>\n#include <linux/seq_file.h>\n#include \"jfs_incore.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_debug.h\"\n\n \nstatic struct {\n\tint freetid;\t\t \n\tint freelock;\t\t \n\twait_queue_head_t freewait;\t \n\twait_queue_head_t freelockwait;\t \n\twait_queue_head_t lowlockwait;\t \n\tint tlocksInUse;\t \n\tspinlock_t LazyLock;\t \n \n\tstruct list_head unlock_queue;\t \n\tstruct list_head anon_list;\t \n\tstruct list_head anon_list2;\t \n} TxAnchor;\n\nint jfs_tlocks_low;\t\t \n\n#ifdef CONFIG_JFS_STATISTICS\nstatic struct {\n\tuint txBegin;\n\tuint txBegin_barrier;\n\tuint txBegin_lockslow;\n\tuint txBegin_freetid;\n\tuint txBeginAnon;\n\tuint txBeginAnon_barrier;\n\tuint txBeginAnon_lockslow;\n\tuint txLockAlloc;\n\tuint txLockAlloc_freelock;\n} TxStat;\n#endif\n\nstatic int nTxBlock = -1;\t \nmodule_param(nTxBlock, int, 0);\nMODULE_PARM_DESC(nTxBlock,\n\t\t \"Number of transaction blocks (max:65536)\");\n\nstatic int nTxLock = -1;\t \nmodule_param(nTxLock, int, 0);\nMODULE_PARM_DESC(nTxLock,\n\t\t \"Number of transaction locks (max:65536)\");\n\nstruct tblock *TxBlock;\t \nstatic int TxLockLWM;\t \nstatic int TxLockHWM;\t \nstatic int TxLockVHWM;\t \nstruct tlock *TxLock;\t \n\n \nstatic DEFINE_SPINLOCK(jfsTxnLock);\n\n#define TXN_LOCK()\t\tspin_lock(&jfsTxnLock)\n#define TXN_UNLOCK()\t\tspin_unlock(&jfsTxnLock)\n\n#define LAZY_LOCK_INIT()\tspin_lock_init(&TxAnchor.LazyLock)\n#define LAZY_LOCK(flags)\tspin_lock_irqsave(&TxAnchor.LazyLock, flags)\n#define LAZY_UNLOCK(flags) spin_unlock_irqrestore(&TxAnchor.LazyLock, flags)\n\nstatic DECLARE_WAIT_QUEUE_HEAD(jfs_commit_thread_wait);\nstatic int jfs_commit_thread_waking;\n\n \nstatic inline void TXN_SLEEP_DROP_LOCK(wait_queue_head_t * event)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tadd_wait_queue(event, &wait);\n\tset_current_state(TASK_UNINTERRUPTIBLE);\n\tTXN_UNLOCK();\n\tio_schedule();\n\tremove_wait_queue(event, &wait);\n}\n\n#define TXN_SLEEP(event)\\\n{\\\n\tTXN_SLEEP_DROP_LOCK(event);\\\n\tTXN_LOCK();\\\n}\n\n#define TXN_WAKEUP(event) wake_up_all(event)\n\n \nstatic struct {\n\ttid_t maxtid;\t\t \n\tlid_t maxlid;\t\t \n\tint ntid;\t\t \n\tint nlid;\t\t \n\tint waitlock;\t\t \n} stattx;\n\n \nstatic void diLog(struct jfs_log *log, struct tblock *tblk, struct lrd *lrd,\n\t\tstruct tlock *tlck, struct commit *cd);\nstatic void dataLog(struct jfs_log *log, struct tblock *tblk, struct lrd *lrd,\n\t\tstruct tlock *tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txLog(struct jfs_log *log, struct tblock *tblk,\n\t\tstruct commit *cd);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\n \n\n \nstatic lid_t txLockAlloc(void)\n{\n\tlid_t lid;\n\n\tINCREMENT(TxStat.txLockAlloc);\n\tif (!TxAnchor.freelock) {\n\t\tINCREMENT(TxStat.txLockAlloc_freelock);\n\t}\n\n\twhile (!(lid = TxAnchor.freelock))\n\t\tTXN_SLEEP(&TxAnchor.freelockwait);\n\tTxAnchor.freelock = TxLock[lid].next;\n\tHIGHWATERMARK(stattx.maxlid, lid);\n\tif ((++TxAnchor.tlocksInUse > TxLockHWM) && (jfs_tlocks_low == 0)) {\n\t\tjfs_info(\"txLockAlloc tlocks low\");\n\t\tjfs_tlocks_low = 1;\n\t\twake_up_process(jfsSyncThread);\n\t}\n\n\treturn lid;\n}\n\nstatic void txLockFree(lid_t lid)\n{\n\tTxLock[lid].tid = 0;\n\tTxLock[lid].next = TxAnchor.freelock;\n\tTxAnchor.freelock = lid;\n\tTxAnchor.tlocksInUse--;\n\tif (jfs_tlocks_low && (TxAnchor.tlocksInUse < TxLockLWM)) {\n\t\tjfs_info(\"txLockFree jfs_tlocks_low no more\");\n\t\tjfs_tlocks_low = 0;\n\t\tTXN_WAKEUP(&TxAnchor.lowlockwait);\n\t}\n\tTXN_WAKEUP(&TxAnchor.freelockwait);\n}\n\n \nint txInit(void)\n{\n\tint k, size;\n\tstruct sysinfo si;\n\n\t \n\n\tif (nTxLock == -1) {\n\t\tif (nTxBlock == -1) {\n\t\t\t \n\t\t\tsi_meminfo(&si);\n\t\t\tif (si.totalram > (256 * 1024))  \n\t\t\t\tnTxLock = 64 * 1024;\n\t\t\telse\n\t\t\t\tnTxLock = si.totalram >> 2;\n\t\t} else if (nTxBlock > (8 * 1024))\n\t\t\tnTxLock = 64 * 1024;\n\t\telse\n\t\t\tnTxLock = nTxBlock << 3;\n\t}\n\tif (nTxBlock == -1)\n\t\tnTxBlock = nTxLock >> 3;\n\n\t \n\tif (nTxBlock < 16)\n\t\tnTxBlock = 16;\t \n\tif (nTxBlock > 65536)\n\t\tnTxBlock = 65536;\n\tif (nTxLock < 256)\n\t\tnTxLock = 256;\t \n\tif (nTxLock > 65536)\n\t\tnTxLock = 65536;\n\n\tprintk(KERN_INFO \"JFS: nTxBlock = %d, nTxLock = %d\\n\",\n\t       nTxBlock, nTxLock);\n\t \n\tTxLockLWM = (nTxLock * 4) / 10;\n\tTxLockHWM = (nTxLock * 7) / 10;\n\tTxLockVHWM = (nTxLock * 8) / 10;\n\n\tsize = sizeof(struct tblock) * nTxBlock;\n\tTxBlock = vmalloc(size);\n\tif (TxBlock == NULL)\n\t\treturn -ENOMEM;\n\n\tfor (k = 1; k < nTxBlock - 1; k++) {\n\t\tTxBlock[k].next = k + 1;\n\t\tinit_waitqueue_head(&TxBlock[k].gcwait);\n\t\tinit_waitqueue_head(&TxBlock[k].waitor);\n\t}\n\tTxBlock[k].next = 0;\n\tinit_waitqueue_head(&TxBlock[k].gcwait);\n\tinit_waitqueue_head(&TxBlock[k].waitor);\n\n\tTxAnchor.freetid = 1;\n\tinit_waitqueue_head(&TxAnchor.freewait);\n\n\tstattx.maxtid = 1;\t \n\n\t \n\tsize = sizeof(struct tlock) * nTxLock;\n\tTxLock = vmalloc(size);\n\tif (TxLock == NULL) {\n\t\tvfree(TxBlock);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tfor (k = 1; k < nTxLock - 1; k++)\n\t\tTxLock[k].next = k + 1;\n\tTxLock[k].next = 0;\n\tinit_waitqueue_head(&TxAnchor.freelockwait);\n\tinit_waitqueue_head(&TxAnchor.lowlockwait);\n\n\tTxAnchor.freelock = 1;\n\tTxAnchor.tlocksInUse = 0;\n\tINIT_LIST_HEAD(&TxAnchor.anon_list);\n\tINIT_LIST_HEAD(&TxAnchor.anon_list2);\n\n\tLAZY_LOCK_INIT();\n\tINIT_LIST_HEAD(&TxAnchor.unlock_queue);\n\n\tstattx.maxlid = 1;\t \n\n\treturn 0;\n}\n\n \nvoid txExit(void)\n{\n\tvfree(TxLock);\n\tTxLock = NULL;\n\tvfree(TxBlock);\n\tTxBlock = NULL;\n}\n\n \ntid_t txBegin(struct super_block *sb, int flag)\n{\n\ttid_t t;\n\tstruct tblock *tblk;\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txBegin: flag = 0x%x\", flag);\n\tlog = JFS_SBI(sb)->log;\n\n\tif (!log) {\n\t\tjfs_error(sb, \"read-only filesystem\\n\");\n\t\treturn 0;\n\t}\n\n\tTXN_LOCK();\n\n\tINCREMENT(TxStat.txBegin);\n\n      retry:\n\tif (!(flag & COMMIT_FORCE)) {\n\t\t \n\t\tif (test_bit(log_SYNCBARRIER, &log->flag) ||\n\t\t    test_bit(log_QUIESCE, &log->flag)) {\n\t\t\tINCREMENT(TxStat.txBegin_barrier);\n\t\t\tTXN_SLEEP(&log->syncwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\tif (flag == 0) {\n\t\t \n\t\tif (TxAnchor.tlocksInUse > TxLockVHWM) {\n\t\t\tINCREMENT(TxStat.txBegin_lockslow);\n\t\t\tTXN_SLEEP(&TxAnchor.lowlockwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\t \n\tif ((t = TxAnchor.freetid) == 0) {\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\ttblk = tid_to_tblock(t);\n\n\tif ((tblk->next == 0) && !(flag & COMMIT_FORCE)) {\n\t\t \n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\tTxAnchor.freetid = tblk->next;\n\n\t \n\n\t \n\ttblk->next = tblk->last = tblk->xflag = tblk->flag = tblk->lsn = 0;\n\n\ttblk->sb = sb;\n\t++log->logtid;\n\ttblk->logtid = log->logtid;\n\n\t++log->active;\n\n\tHIGHWATERMARK(stattx.maxtid, t);\t \n\tINCREMENT(stattx.ntid);\t \n\n\tTXN_UNLOCK();\n\n\tjfs_info(\"txBegin: returning tid = %d\", t);\n\n\treturn t;\n}\n\n \nvoid txBeginAnon(struct super_block *sb)\n{\n\tstruct jfs_log *log;\n\n\tlog = JFS_SBI(sb)->log;\n\n\tTXN_LOCK();\n\tINCREMENT(TxStat.txBeginAnon);\n\n      retry:\n\t \n\tif (test_bit(log_SYNCBARRIER, &log->flag) ||\n\t    test_bit(log_QUIESCE, &log->flag)) {\n\t\tINCREMENT(TxStat.txBeginAnon_barrier);\n\t\tTXN_SLEEP(&log->syncwait);\n\t\tgoto retry;\n\t}\n\n\t \n\tif (TxAnchor.tlocksInUse > TxLockVHWM) {\n\t\tINCREMENT(TxStat.txBeginAnon_lockslow);\n\t\tTXN_SLEEP(&TxAnchor.lowlockwait);\n\t\tgoto retry;\n\t}\n\tTXN_UNLOCK();\n}\n\n \nvoid txEnd(tid_t tid)\n{\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txEnd: tid = %d\", tid);\n\tTXN_LOCK();\n\n\t \n\tTXN_WAKEUP(&tblk->waitor);\n\n\tlog = JFS_SBI(tblk->sb)->log;\n\n\t \n\tif (tblk->flag & tblkGC_LAZY) {\n\t\tjfs_info(\"txEnd called w/lazy tid: %d, tblk = 0x%p\", tid, tblk);\n\t\tTXN_UNLOCK();\n\n\t\tspin_lock_irq(&log->gclock);\t \n\t\ttblk->flag |= tblkGC_UNLOCKED;\n\t\tspin_unlock_irq(&log->gclock);\t \n\t\treturn;\n\t}\n\n\tjfs_info(\"txEnd: tid: %d, tblk = 0x%p\", tid, tblk);\n\n\tassert(tblk->next == 0);\n\n\t \n\ttblk->next = TxAnchor.freetid;\n\tTxAnchor.freetid = tid;\n\n\t \n\tif (--log->active == 0) {\n\t\tclear_bit(log_FLUSH, &log->flag);\n\n\t\t \n\t\tif (test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t\tTXN_UNLOCK();\n\n\t\t\t \n\t\t\tjfs_syncpt(log, 1);\n\n\t\t\tjfs_info(\"log barrier off: 0x%x\", log->lsn);\n\n\t\t\t \n\t\t\tclear_bit(log_SYNCBARRIER, &log->flag);\n\n\t\t\t \n\t\t\tTXN_WAKEUP(&log->syncwait);\n\n\t\t\tgoto wakeup;\n\t\t}\n\t}\n\n\tTXN_UNLOCK();\nwakeup:\n\t \n\tTXN_WAKEUP(&TxAnchor.freewait);\n}\n\n \nstruct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t \n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t \n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t \n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t \n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t \n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t \n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t \n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t \n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t \n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t \n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t \n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t \n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t \n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t \n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t \n\t \n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t \n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t \n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t \n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t \n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t \n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t \n      waitLock:\n\t \n\t \n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t \n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t \n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t \n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}\n\n \nstatic void txRelease(struct tblock * tblk)\n{\n\tstruct metapage *mp;\n\tlid_t lid;\n\tstruct tlock *tlck;\n\n\tTXN_LOCK();\n\n\tfor (lid = tblk->next; lid; lid = tlck->next) {\n\t\ttlck = lid_to_tlock(lid);\n\t\tif ((mp = tlck->mp) != NULL &&\n\t\t    (tlck->type & tlckBTROOT) == 0) {\n\t\t\tassert(mp->xflag & COMMIT_PAGE);\n\t\t\tmp->lid = 0;\n\t\t}\n\t}\n\n\t \n\tTXN_WAKEUP(&tblk->waitor);\n\n\tTXN_UNLOCK();\n}\n\n \nstatic void txUnlock(struct tblock * tblk)\n{\n\tstruct tlock *tlck;\n\tstruct linelock *linelock;\n\tlid_t lid, next, llid, k;\n\tstruct metapage *mp;\n\tstruct jfs_log *log;\n\tint difft, diffp;\n\tunsigned long flags;\n\n\tjfs_info(\"txUnlock: tblk = 0x%p\", tblk);\n\tlog = JFS_SBI(tblk->sb)->log;\n\n\t \n\tfor (lid = tblk->next; lid; lid = next) {\n\t\ttlck = lid_to_tlock(lid);\n\t\tnext = tlck->next;\n\n\t\tjfs_info(\"unlocking lid = %d, tlck = 0x%p\", lid, tlck);\n\n\t\t \n\t\tif ((mp = tlck->mp) != NULL &&\n\t\t    (tlck->type & tlckBTROOT) == 0) {\n\t\t\tassert(mp->xflag & COMMIT_PAGE);\n\n\t\t\t \n\t\t\thold_metapage(mp);\n\n\t\t\tassert(mp->nohomeok > 0);\n\t\t\t_metapage_homeok(mp);\n\n\t\t\t \n\t\t\tLOGSYNC_LOCK(log, flags);\n\t\t\tif (mp->clsn) {\n\t\t\t\tlogdiff(difft, tblk->clsn, log);\n\t\t\t\tlogdiff(diffp, mp->clsn, log);\n\t\t\t\tif (difft > diffp)\n\t\t\t\t\tmp->clsn = tblk->clsn;\n\t\t\t} else\n\t\t\t\tmp->clsn = tblk->clsn;\n\t\t\tLOGSYNC_UNLOCK(log, flags);\n\n\t\t\tassert(!(tlck->flag & tlckFREEPAGE));\n\n\t\t\tput_metapage(mp);\n\t\t}\n\n\t\t \n\t\tTXN_LOCK();\n\n\t\tllid = ((struct linelock *) & tlck->lock)->next;\n\t\twhile (llid) {\n\t\t\tlinelock = (struct linelock *) lid_to_tlock(llid);\n\t\t\tk = linelock->next;\n\t\t\ttxLockFree(llid);\n\t\t\tllid = k;\n\t\t}\n\t\ttxLockFree(lid);\n\n\t\tTXN_UNLOCK();\n\t}\n\ttblk->next = tblk->last = 0;\n\n\t \n\tif (tblk->lsn) {\n\t\tLOGSYNC_LOCK(log, flags);\n\t\tlog->count--;\n\t\tlist_del(&tblk->synclist);\n\t\tLOGSYNC_UNLOCK(log, flags);\n\t}\n}\n\n \nstruct tlock *txMaplock(tid_t tid, struct inode *ip, int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tlid_t lid;\n\tstruct tblock *tblk;\n\tstruct tlock *tlck;\n\tstruct maplock *maplock;\n\n\tTXN_LOCK();\n\n\t \n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t \n\ttlck->tid = tid;\n\n\t \n\ttlck->flag = tlckINODELOCK;\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\ttlck->ip = ip;\n\ttlck->mp = NULL;\n\n\ttlck->type = type;\n\n\t \n\t \n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t \n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t \n\t\t\tjfs_ip->atltail = lid;\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t}\n\t}\n\n\tTXN_UNLOCK();\n\n\t \n\tmaplock = (struct maplock *) & tlck->lock;\n\tmaplock->next = 0;\n\tmaplock->maxcnt = 0;\n\tmaplock->index = 0;\n\n\treturn tlck;\n}\n\n \nstruct linelock *txLinelock(struct linelock * tlock)\n{\n\tlid_t lid;\n\tstruct tlock *tlck;\n\tstruct linelock *linelock;\n\n\tTXN_LOCK();\n\n\t \n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\tTXN_UNLOCK();\n\n\t \n\tlinelock = (struct linelock *) tlck;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKLONG;\n\tlinelock->index = 0;\n\tif (tlck->flag & tlckDIRECTORY)\n\t\tlinelock->flag |= tlckDIRECTORY;\n\n\t \n\tlinelock->next = tlock->next;\n\ttlock->next = lid;\n\n\treturn linelock;\n}\n\n \n\n \nint txCommit(tid_t tid,\t\t \n\t     int nip,\t\t \n\t     struct inode **iplist,\t \n\t     int flag)\n{\n\tint rc = 0;\n\tstruct commit cd;\n\tstruct jfs_log *log;\n\tstruct tblock *tblk;\n\tstruct lrd *lrd;\n\tstruct inode *ip;\n\tstruct jfs_inode_info *jfs_ip;\n\tint k, n;\n\tino_t top;\n\tstruct super_block *sb;\n\n\tjfs_info(\"txCommit, tid = %d, flag = %d\", tid, flag);\n\t \n\tif (isReadOnly(iplist[0])) {\n\t\trc = -EROFS;\n\t\tgoto TheEnd;\n\t}\n\n\tsb = cd.sb = iplist[0]->i_sb;\n\tcd.tid = tid;\n\n\tif (tid == 0)\n\t\ttid = txBegin(sb, 0);\n\ttblk = tid_to_tblock(tid);\n\n\t \n\tlog = JFS_SBI(sb)->log;\n\tcd.log = log;\n\n\t \n\tlrd = &cd.lrd;\n\tlrd->logtid = cpu_to_le32(tblk->logtid);\n\tlrd->backchain = 0;\n\n\ttblk->xflag |= flag;\n\n\tif ((flag & (COMMIT_FORCE | COMMIT_SYNC)) == 0)\n\t\ttblk->xflag |= COMMIT_LAZY;\n\t \n\tcd.iplist = iplist;\n\tcd.nip = nip;\n\n\t \n\tfor (k = 0; k < cd.nip; k++) {\n\t\ttop = (cd.iplist[k])->i_ino;\n\t\tfor (n = k + 1; n < cd.nip; n++) {\n\t\t\tip = cd.iplist[n];\n\t\t\tif (ip->i_ino > top) {\n\t\t\t\ttop = ip->i_ino;\n\t\t\t\tcd.iplist[n] = cd.iplist[k];\n\t\t\t\tcd.iplist[k] = ip;\n\t\t\t}\n\t\t}\n\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t \n\n\t\t \n\t\tclear_cflag(COMMIT_Dirty, ip);\n\n\t\t \n\t\tif (jfs_ip->atlhead) {\n\t\t\tlid_to_tlock(jfs_ip->atltail)->next = tblk->next;\n\t\t\ttblk->next = jfs_ip->atlhead;\n\t\t\tif (!tblk->last)\n\t\t\t\ttblk->last = jfs_ip->atltail;\n\t\t\tjfs_ip->atlhead = jfs_ip->atltail = 0;\n\t\t\tTXN_LOCK();\n\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\n\t\t \n\t\tif (((rc = diWrite(tid, ip))))\n\t\t\tgoto out;\n\t}\n\n\t \n\ttxLog(log, tblk, &cd);\n\n\t \n\tif (tblk->xflag & COMMIT_DELETE) {\n\t\tihold(tblk->u.ip);\n\t\t \n\t\t \n\t\tif (tblk->u.ip->i_state & I_SYNC)\n\t\t\ttblk->xflag &= ~COMMIT_LAZY;\n\t}\n\n\tASSERT((!(tblk->xflag & COMMIT_DELETE)) ||\n\t       ((tblk->u.ip->i_nlink == 0) &&\n\t\t!test_cflag(COMMIT_Nolink, tblk->u.ip)));\n\n\t \n\tlrd->type = cpu_to_le16(LOG_COMMIT);\n\tlrd->length = 0;\n\tlmLog(log, tblk, lrd, NULL);\n\n\tlmGroupCommit(log, tblk);\n\n\t \n\n\t \n\tif (flag & COMMIT_FORCE)\n\t\ttxForce(tblk);\n\n\t \n\tif (tblk->xflag & COMMIT_FORCE)\n\t\ttxUpdateMap(tblk);\n\n\t \n\ttxRelease(tblk);\n\n\tif ((tblk->flag & tblkGC_LAZY) == 0)\n\t\ttxUnlock(tblk);\n\n\n\t \n\tfor (k = 0; k < cd.nip; k++) {\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t \n\t\tjfs_ip->bxflag = 0;\n\t\tjfs_ip->blid = 0;\n\t}\n\n      out:\n\tif (rc != 0)\n\t\ttxAbort(tid, 1);\n\n      TheEnd:\n\tjfs_info(\"txCommit: tid = %d, returning %d\", tid, rc);\n\treturn rc;\n}\n\n \nstatic void txLog(struct jfs_log *log, struct tblock *tblk, struct commit *cd)\n{\n\tstruct inode *ip;\n\tlid_t lid;\n\tstruct tlock *tlck;\n\tstruct lrd *lrd = &cd->lrd;\n\n\t \n\tfor (lid = tblk->next; lid; lid = tlck->next) {\n\t\ttlck = lid_to_tlock(lid);\n\n\t\ttlck->flag |= tlckLOG;\n\n\t\t \n\t\tip = tlck->ip;\n\t\tlrd->aggregate = cpu_to_le32(JFS_SBI(ip->i_sb)->aggregate);\n\t\tlrd->log.redopage.fileset = cpu_to_le32(JFS_IP(ip)->fileset);\n\t\tlrd->log.redopage.inode = cpu_to_le32(ip->i_ino);\n\n\t\t \n\t\tswitch (tlck->type & tlckTYPE) {\n\t\tcase tlckXTREE:\n\t\t\txtLog(log, tblk, lrd, tlck);\n\t\t\tbreak;\n\n\t\tcase tlckDTREE:\n\t\t\tdtLog(log, tblk, lrd, tlck);\n\t\t\tbreak;\n\n\t\tcase tlckINODE:\n\t\t\tdiLog(log, tblk, lrd, tlck, cd);\n\t\t\tbreak;\n\n\t\tcase tlckMAP:\n\t\t\tmapLog(log, tblk, lrd, tlck);\n\t\t\tbreak;\n\n\t\tcase tlckDATA:\n\t\t\tdataLog(log, tblk, lrd, tlck);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t\t}\n\t}\n\n\treturn;\n}\n\n \nstatic void diLog(struct jfs_log *log, struct tblock *tblk, struct lrd *lrd,\n\t\t struct tlock *tlck, struct commit *cd)\n{\n\tstruct metapage *mp;\n\tpxd_t *pxd;\n\tstruct pxd_lock *pxdlock;\n\n\tmp = tlck->mp;\n\n\t \n\tlrd->log.redopage.type = cpu_to_le16(LOG_INODE);\n\tlrd->log.redopage.l2linesize = cpu_to_le16(L2INODESLOTSIZE);\n\n\tpxd = &lrd->log.redopage.pxd;\n\n\t \n\tif (tlck->type & tlckENTRY) {\n\t\t \n\t\tlrd->type = cpu_to_le16(LOG_REDOPAGE);\n\t\tPXDaddress(pxd, mp->index);\n\t\tPXDlength(pxd,\n\t\t\t  mp->logical_size >> tblk->sb->s_blocksize_bits);\n\t\tlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, tlck));\n\n\t\t \n\t\ttlck->flag |= tlckWRITEPAGE;\n\t} else if (tlck->type & tlckFREE) {\n\t\t \n\n\t\t \n\t\tlrd->type = cpu_to_le16(LOG_NOREDOINOEXT);\n\t\t \n\t\tlrd->log.noredoinoext.iagnum =\n\t\t    cpu_to_le32((u32) (size_t) cd->iplist[1]);\n\t\tlrd->log.noredoinoext.inoext_idx =\n\t\t    cpu_to_le32((u32) (size_t) cd->iplist[2]);\n\n\t\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\t\t*pxd = pxdlock->pxd;\n\t\tlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, NULL));\n\n\t\t \n\t\ttlck->flag |= tlckUPDATEMAP;\n\n\t\t \n\t\ttlck->flag |= tlckWRITEPAGE;\n\t} else\n\t\tjfs_err(\"diLog: UFO type tlck:0x%p\", tlck);\n\treturn;\n}\n\n \nstatic void dataLog(struct jfs_log *log, struct tblock *tblk, struct lrd *lrd,\n\t    struct tlock *tlck)\n{\n\tstruct metapage *mp;\n\tpxd_t *pxd;\n\n\tmp = tlck->mp;\n\n\t \n\tlrd->log.redopage.type = cpu_to_le16(LOG_DATA);\n\tlrd->log.redopage.l2linesize = cpu_to_le16(L2DATASLOTSIZE);\n\n\tpxd = &lrd->log.redopage.pxd;\n\n\t \n\tlrd->type = cpu_to_le16(LOG_REDOPAGE);\n\n\tif (jfs_dirtable_inline(tlck->ip)) {\n\t\t \n\t\tmp->lid = 0;\n\t\tgrab_metapage(mp);\n\t\tmetapage_homeok(mp);\n\t\tdiscard_metapage(mp);\n\t\ttlck->mp = NULL;\n\t\treturn;\n\t}\n\n\tPXDaddress(pxd, mp->index);\n\tPXDlength(pxd, mp->logical_size >> tblk->sb->s_blocksize_bits);\n\n\tlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, tlck));\n\n\t \n\ttlck->flag |= tlckWRITEPAGE;\n\n\treturn;\n}\n\n \nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck)\n{\n\tstruct metapage *mp;\n\tstruct pxd_lock *pxdlock;\n\tpxd_t *pxd;\n\n\tmp = tlck->mp;\n\n\t \n\tlrd->log.redopage.type = cpu_to_le16(LOG_DTREE);\n\tlrd->log.redopage.l2linesize = cpu_to_le16(L2DTSLOTSIZE);\n\n\tpxd = &lrd->log.redopage.pxd;\n\n\tif (tlck->type & tlckBTROOT)\n\t\tlrd->log.redopage.type |= cpu_to_le16(LOG_BTROOT);\n\n\t \n\tif (tlck->type & (tlckNEW | tlckEXTEND)) {\n\t\t \n\t\tlrd->type = cpu_to_le16(LOG_REDOPAGE);\n\t\tif (tlck->type & tlckEXTEND)\n\t\t\tlrd->log.redopage.type |= cpu_to_le16(LOG_EXTEND);\n\t\telse\n\t\t\tlrd->log.redopage.type |= cpu_to_le16(LOG_NEW);\n\t\tPXDaddress(pxd, mp->index);\n\t\tPXDlength(pxd,\n\t\t\t  mp->logical_size >> tblk->sb->s_blocksize_bits);\n\t\tlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, tlck));\n\n\t\t \n\t\tif (tlck->type & tlckBTROOT)\n\t\t\treturn;\n\t\ttlck->flag |= tlckUPDATEMAP;\n\t\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\t\tpxdlock->flag = mlckALLOCPXD;\n\t\tpxdlock->pxd = *pxd;\n\n\t\tpxdlock->index = 1;\n\n\t\t \n\t\ttlck->flag |= tlckWRITEPAGE;\n\t\treturn;\n\t}\n\n\t \n\tif (tlck->type & (tlckENTRY | tlckRELINK)) {\n\t\t \n\t\tlrd->type = cpu_to_le16(LOG_REDOPAGE);\n\t\tPXDaddress(pxd, mp->index);\n\t\tPXDlength(pxd,\n\t\t\t  mp->logical_size >> tblk->sb->s_blocksize_bits);\n\t\tlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, tlck));\n\n\t\t \n\t\ttlck->flag |= tlckWRITEPAGE;\n\t\treturn;\n\t}\n\n\t \n\tif (tlck->type & (tlckFREE | tlckRELOCATE)) {\n\t\t \n\t\tlrd->type = cpu_to_le16(LOG_NOREDOPAGE);\n\t\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\t\t*pxd = pxdlock->pxd;\n\t\tlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, NULL));\n\n\t\t \n\t\ttlck->flag |= tlckUPDATEMAP;\n\t}\n\treturn;\n}\n\n \nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck)\n{\n\tstruct inode *ip;\n\tstruct metapage *mp;\n\txtpage_t *p;\n\tstruct xtlock *xtlck;\n\tstruct maplock *maplock;\n\tstruct xdlistlock *xadlock;\n\tstruct pxd_lock *pxdlock;\n\tpxd_t *page_pxd;\n\tint next, lwm, hwm;\n\n\tip = tlck->ip;\n\tmp = tlck->mp;\n\n\t \n\tlrd->log.redopage.type = cpu_to_le16(LOG_XTREE);\n\tlrd->log.redopage.l2linesize = cpu_to_le16(L2XTSLOTSIZE);\n\n\tpage_pxd = &lrd->log.redopage.pxd;\n\n\tif (tlck->type & tlckBTROOT) {\n\t\tlrd->log.redopage.type |= cpu_to_le16(LOG_BTROOT);\n\t\tp = &JFS_IP(ip)->i_xtroot;\n\t\tif (S_ISDIR(ip->i_mode))\n\t\t\tlrd->log.redopage.type |=\n\t\t\t    cpu_to_le16(LOG_DIR_XTREE);\n\t} else\n\t\tp = (xtpage_t *) mp->data;\n\tnext = le16_to_cpu(p->header.nextindex);\n\n\txtlck = (struct xtlock *) & tlck->lock;\n\n\tmaplock = (struct maplock *) & tlck->lock;\n\txadlock = (struct xdlistlock *) maplock;\n\n\t \n\tif (tlck->type & (tlckNEW | tlckGROW | tlckRELINK)) {\n\t\t \n\t\tlrd->type = cpu_to_le16(LOG_REDOPAGE);\n\t\tPXDaddress(page_pxd, mp->index);\n\t\tPXDlength(page_pxd,\n\t\t\t  mp->logical_size >> tblk->sb->s_blocksize_bits);\n\t\tlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, tlck));\n\n\t\t \n\t\tlwm = xtlck->lwm.offset;\n\t\tif (lwm == 0)\n\t\t\tlwm = XTPAGEMAXSLOT;\n\n\t\tif (lwm == next)\n\t\t\tgoto out;\n\t\tif (lwm > next) {\n\t\t\tjfs_err(\"xtLog: lwm > next\");\n\t\t\tgoto out;\n\t\t}\n\t\ttlck->flag |= tlckUPDATEMAP;\n\t\txadlock->flag = mlckALLOCXADLIST;\n\t\txadlock->count = next - lwm;\n\t\tif ((xadlock->count <= 4) && (tblk->xflag & COMMIT_LAZY)) {\n\t\t\tint i;\n\t\t\tpxd_t *pxd;\n\t\t\t \n\t\t\txadlock->flag = mlckALLOCPXDLIST;\n\t\t\tpxd = xadlock->xdlist = &xtlck->pxdlock;\n\t\t\tfor (i = 0; i < xadlock->count; i++) {\n\t\t\t\tPXDaddress(pxd, addressXAD(&p->xad[lwm + i]));\n\t\t\t\tPXDlength(pxd, lengthXAD(&p->xad[lwm + i]));\n\t\t\t\tp->xad[lwm + i].flag &=\n\t\t\t\t    ~(XAD_NEW | XAD_EXTENDED);\n\t\t\t\tpxd++;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\txadlock->flag = mlckALLOCXADLIST;\n\t\t\txadlock->xdlist = &p->xad[lwm];\n\t\t\ttblk->xflag &= ~COMMIT_LAZY;\n\t\t}\n\t\tjfs_info(\"xtLog: alloc ip:0x%p mp:0x%p tlck:0x%p lwm:%d count:%d\",\n\t\t\t tlck->ip, mp, tlck, lwm, xadlock->count);\n\n\t\tmaplock->index = 1;\n\n\t      out:\n\t\t \n\t\ttlck->flag |= tlckWRITEPAGE;\n\n\t\treturn;\n\t}\n\n\t \n\tif (tlck->type & tlckFREE) {\n\t\t \n\t\t \n\t\tif (tblk->xflag & COMMIT_TRUNCATE) {\n\t\t\t \n\t\t\tlrd->type = cpu_to_le16(LOG_NOREDOPAGE);\n\t\t\tPXDaddress(page_pxd, mp->index);\n\t\t\tPXDlength(page_pxd,\n\t\t\t\t  mp->logical_size >> tblk->sb->\n\t\t\t\t  s_blocksize_bits);\n\t\t\tlrd->backchain =\n\t\t\t    cpu_to_le32(lmLog(log, tblk, lrd, NULL));\n\n\t\t\tif (tlck->type & tlckBTROOT) {\n\t\t\t\t \n\t\t\t\tlrd->type = cpu_to_le16(LOG_REDOPAGE);\n\t\t\t\tlrd->backchain =\n\t\t\t\t    cpu_to_le32(lmLog(log, tblk, lrd, tlck));\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tlrd->type = cpu_to_le16(LOG_UPDATEMAP);\n\t\tlrd->log.updatemap.type = cpu_to_le16(LOG_FREEXADLIST);\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\thwm = xtlck->hwm.offset;\n\t\tlrd->log.updatemap.nxd =\n\t\t    cpu_to_le16(hwm - XTENTRYSTART + 1);\n\t\t \n\t\txtlck->header.offset = XTENTRYSTART;\n\t\txtlck->header.length = hwm - XTENTRYSTART + 1;\n\t\txtlck->index = 1;\n\t\tlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, tlck));\n\n\t\t \n\t\ttlck->flag |= tlckUPDATEMAP;\n\t\txadlock->count = hwm - XTENTRYSTART + 1;\n\t\tif ((xadlock->count <= 4) && (tblk->xflag & COMMIT_LAZY)) {\n\t\t\tint i;\n\t\t\tpxd_t *pxd;\n\t\t\t \n\t\t\txadlock->flag = mlckFREEPXDLIST;\n\t\t\tpxd = xadlock->xdlist = &xtlck->pxdlock;\n\t\t\tfor (i = 0; i < xadlock->count; i++) {\n\t\t\t\tPXDaddress(pxd,\n\t\t\t\t\taddressXAD(&p->xad[XTENTRYSTART + i]));\n\t\t\t\tPXDlength(pxd,\n\t\t\t\t\tlengthXAD(&p->xad[XTENTRYSTART + i]));\n\t\t\t\tpxd++;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\txadlock->flag = mlckFREEXADLIST;\n\t\t\txadlock->xdlist = &p->xad[XTENTRYSTART];\n\t\t\ttblk->xflag &= ~COMMIT_LAZY;\n\t\t}\n\t\tjfs_info(\"xtLog: free ip:0x%p mp:0x%p count:%d lwm:2\",\n\t\t\t tlck->ip, mp, xadlock->count);\n\n\t\tmaplock->index = 1;\n\n\t\t \n\t\tif (((tblk->xflag & COMMIT_PWMAP) || S_ISDIR(ip->i_mode))\n\t\t    && !(tlck->type & tlckBTROOT))\n\t\t\ttlck->flag |= tlckFREEPAGE;\n\t\t \n\t\treturn;\n\t}\n\n\t \n\tif (tlck->type & tlckTRUNCATE) {\n\t\tpxd_t pxd;\t \n\t\tint twm;\n\n\t\t \n\t\ttblk->xflag &= ~COMMIT_LAZY;\n\t\tlwm = xtlck->lwm.offset;\n\t\tif (lwm == 0)\n\t\t\tlwm = XTPAGEMAXSLOT;\n\t\thwm = xtlck->hwm.offset;\n\t\ttwm = xtlck->twm.offset;\n\n\t\t \n\t\t \n\t\tlrd->type = cpu_to_le16(LOG_REDOPAGE);\n\t\tPXDaddress(page_pxd, mp->index);\n\t\tPXDlength(page_pxd,\n\t\t\t  mp->logical_size >> tblk->sb->s_blocksize_bits);\n\t\tlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, tlck));\n\n\t\t \n\t\tif (twm == next - 1) {\n\t\t\t \n\t\t\tpxdlock = (struct pxd_lock *) & xtlck->pxdlock;\n\t\t\t \n\t\t\tlrd->type = cpu_to_le16(LOG_UPDATEMAP);\n\t\t\tlrd->log.updatemap.type = cpu_to_le16(LOG_FREEPXD);\n\t\t\tlrd->log.updatemap.nxd = cpu_to_le16(1);\n\t\t\tlrd->log.updatemap.pxd = pxdlock->pxd;\n\t\t\tpxd = pxdlock->pxd;\t \n\t\t\tlrd->backchain =\n\t\t\t    cpu_to_le32(lmLog(log, tblk, lrd, NULL));\n\t\t}\n\n\t\t \n\t\tif (hwm >= next) {\n\t\t\t \n\t\t\tlrd->type = cpu_to_le16(LOG_UPDATEMAP);\n\t\t\tlrd->log.updatemap.type =\n\t\t\t    cpu_to_le16(LOG_FREEXADLIST);\n\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\thwm = xtlck->hwm.offset;\n\t\t\tlrd->log.updatemap.nxd =\n\t\t\t    cpu_to_le16(hwm - next + 1);\n\t\t\t \n\t\t\txtlck->header.offset = next;\n\t\t\txtlck->header.length = hwm - next + 1;\n\t\t\txtlck->index = 1;\n\t\t\tlrd->backchain =\n\t\t\t    cpu_to_le32(lmLog(log, tblk, lrd, tlck));\n\t\t}\n\n\t\t \n\t\tmaplock->index = 0;\n\n\t\t \n\t\tif (lwm < next) {\n\t\t\t \n\t\t\ttlck->flag |= tlckUPDATEMAP;\n\t\t\txadlock->flag = mlckALLOCXADLIST;\n\t\t\txadlock->count = next - lwm;\n\t\t\txadlock->xdlist = &p->xad[lwm];\n\n\t\t\tjfs_info(\"xtLog: alloc ip:0x%p mp:0x%p count:%d lwm:%d next:%d\",\n\t\t\t\t tlck->ip, mp, xadlock->count, lwm, next);\n\t\t\tmaplock->index++;\n\t\t\txadlock++;\n\t\t}\n\n\t\t \n\t\tif (twm == next - 1) {\n\t\t\t \n\t\t\ttlck->flag |= tlckUPDATEMAP;\n\t\t\tpxdlock = (struct pxd_lock *) xadlock;\n\t\t\tpxdlock->flag = mlckFREEPXD;\n\t\t\tpxdlock->count = 1;\n\t\t\tpxdlock->pxd = pxd;\n\n\t\t\tjfs_info(\"xtLog: truncate ip:0x%p mp:0x%p count:%d hwm:%d\",\n\t\t\t\t ip, mp, pxdlock->count, hwm);\n\t\t\tmaplock->index++;\n\t\t\txadlock++;\n\t\t}\n\n\t\t \n\t\tif (hwm >= next) {\n\t\t\t \n\t\t\ttlck->flag |= tlckUPDATEMAP;\n\t\t\txadlock->flag = mlckFREEXADLIST;\n\t\t\txadlock->count = hwm - next + 1;\n\t\t\txadlock->xdlist = &p->xad[next];\n\n\t\t\tjfs_info(\"xtLog: free ip:0x%p mp:0x%p count:%d next:%d hwm:%d\",\n\t\t\t\t tlck->ip, mp, xadlock->count, next, hwm);\n\t\t\tmaplock->index++;\n\t\t}\n\n\t\t \n\t\ttlck->flag |= tlckWRITEPAGE;\n\t}\n\treturn;\n}\n\n \nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\t   struct tlock * tlck)\n{\n\tstruct pxd_lock *pxdlock;\n\tint i, nlock;\n\tpxd_t *pxd;\n\n\t \n\tif (tlck->type & tlckRELOCATE) {\n\t\t \n\t\tlrd->type = cpu_to_le16(LOG_NOREDOPAGE);\n\t\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\t\tpxd = &lrd->log.redopage.pxd;\n\t\t*pxd = pxdlock->pxd;\n\t\tlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, NULL));\n\n\t\t \n\t\tlrd->type = cpu_to_le16(LOG_UPDATEMAP);\n\t\tlrd->log.updatemap.type = cpu_to_le16(LOG_FREEPXD);\n\t\tlrd->log.updatemap.nxd = cpu_to_le16(1);\n\t\tlrd->log.updatemap.pxd = pxdlock->pxd;\n\t\tlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, NULL));\n\n\t\t \n\t\ttlck->flag |= tlckUPDATEMAP;\n\t\treturn;\n\t}\n\t \n\telse {\n\t\t \n\t\tlrd->type = cpu_to_le16(LOG_UPDATEMAP);\n\t\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\t\tnlock = pxdlock->index;\n\t\tfor (i = 0; i < nlock; i++, pxdlock++) {\n\t\t\tif (pxdlock->flag & mlckALLOCPXD)\n\t\t\t\tlrd->log.updatemap.type =\n\t\t\t\t    cpu_to_le16(LOG_ALLOCPXD);\n\t\t\telse\n\t\t\t\tlrd->log.updatemap.type =\n\t\t\t\t    cpu_to_le16(LOG_FREEPXD);\n\t\t\tlrd->log.updatemap.nxd = cpu_to_le16(1);\n\t\t\tlrd->log.updatemap.pxd = pxdlock->pxd;\n\t\t\tlrd->backchain =\n\t\t\t    cpu_to_le32(lmLog(log, tblk, lrd, NULL));\n\t\t\tjfs_info(\"mapLog: xaddr:0x%lx xlen:0x%x\",\n\t\t\t\t (ulong) addressPXD(&pxdlock->pxd),\n\t\t\t\t lengthPXD(&pxdlock->pxd));\n\t\t}\n\n\t\t \n\t\ttlck->flag |= tlckUPDATEMAP;\n\t}\n}\n\n \nvoid txEA(tid_t tid, struct inode *ip, dxd_t * oldea, dxd_t * newea)\n{\n\tstruct tlock *tlck = NULL;\n\tstruct pxd_lock *maplock = NULL, *pxdlock = NULL;\n\n\t \n\tif (newea) {\n\t\t \n\t\tif (newea->flag & DXD_EXTENT) {\n\t\t\ttlck = txMaplock(tid, ip, tlckMAP);\n\t\t\tmaplock = (struct pxd_lock *) & tlck->lock;\n\t\t\tpxdlock = (struct pxd_lock *) maplock;\n\t\t\tpxdlock->flag = mlckALLOCPXD;\n\t\t\tPXDaddress(&pxdlock->pxd, addressDXD(newea));\n\t\t\tPXDlength(&pxdlock->pxd, lengthDXD(newea));\n\t\t\tpxdlock++;\n\t\t\tmaplock->index = 1;\n\t\t} else if (newea->flag & DXD_INLINE) {\n\t\t\ttlck = NULL;\n\n\t\t\tset_cflag(COMMIT_Inlineea, ip);\n\t\t}\n\t}\n\n\t \n\tif (!test_cflag(COMMIT_Nolink, ip) && oldea->flag & DXD_EXTENT) {\n\t\tif (tlck == NULL) {\n\t\t\ttlck = txMaplock(tid, ip, tlckMAP);\n\t\t\tmaplock = (struct pxd_lock *) & tlck->lock;\n\t\t\tpxdlock = (struct pxd_lock *) maplock;\n\t\t\tmaplock->index = 0;\n\t\t}\n\t\tpxdlock->flag = mlckFREEPXD;\n\t\tPXDaddress(&pxdlock->pxd, addressDXD(oldea));\n\t\tPXDlength(&pxdlock->pxd, lengthDXD(oldea));\n\t\tmaplock->index++;\n\t}\n}\n\n \nstatic void txForce(struct tblock * tblk)\n{\n\tstruct tlock *tlck;\n\tlid_t lid, next;\n\tstruct metapage *mp;\n\n\t \n\ttlck = lid_to_tlock(tblk->next);\n\tlid = tlck->next;\n\ttlck->next = 0;\n\twhile (lid) {\n\t\ttlck = lid_to_tlock(lid);\n\t\tnext = tlck->next;\n\t\ttlck->next = tblk->next;\n\t\ttblk->next = lid;\n\t\tlid = next;\n\t}\n\n\t \n\tfor (lid = tblk->next; lid; lid = next) {\n\t\ttlck = lid_to_tlock(lid);\n\t\tnext = tlck->next;\n\n\t\tif ((mp = tlck->mp) != NULL &&\n\t\t    (tlck->type & tlckBTROOT) == 0) {\n\t\t\tassert(mp->xflag & COMMIT_PAGE);\n\n\t\t\tif (tlck->flag & tlckWRITEPAGE) {\n\t\t\t\ttlck->flag &= ~tlckWRITEPAGE;\n\n\t\t\t\t \n\t\t\t\tforce_metapage(mp);\n#if 0\n\t\t\t\t \n\t\t\t\tassert(mp->nohomeok);\n\t\t\t\tset_bit(META_dirty, &mp->flag);\n\t\t\t\tset_bit(META_sync, &mp->flag);\n#endif\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nstatic void txUpdateMap(struct tblock * tblk)\n{\n\tstruct inode *ip;\n\tstruct inode *ipimap;\n\tlid_t lid;\n\tstruct tlock *tlck;\n\tstruct maplock *maplock;\n\tstruct pxd_lock pxdlock;\n\tint maptype;\n\tint k, nlock;\n\tstruct metapage *mp = NULL;\n\n\tipimap = JFS_SBI(tblk->sb)->ipimap;\n\n\tmaptype = (tblk->xflag & COMMIT_PMAP) ? COMMIT_PMAP : COMMIT_PWMAP;\n\n\n\t \n\t \n\tfor (lid = tblk->next; lid; lid = tlck->next) {\n\t\ttlck = lid_to_tlock(lid);\n\n\t\tif ((tlck->flag & tlckUPDATEMAP) == 0)\n\t\t\tcontinue;\n\n\t\tif (tlck->flag & tlckFREEPAGE) {\n\t\t\t \n\t\t\tmp = tlck->mp;\n\t\t\tASSERT(mp->xflag & COMMIT_PAGE);\n\t\t\tgrab_metapage(mp);\n\t\t}\n\n\t\t \n\t\tmaplock = (struct maplock *) & tlck->lock;\n\t\tnlock = maplock->index;\n\n\t\tfor (k = 0; k < nlock; k++, maplock++) {\n\t\t\t \n\t\t\tif (maplock->flag & mlckALLOC) {\n\t\t\t\ttxAllocPMap(ipimap, maplock, tblk);\n\t\t\t}\n\t\t\t \n\t\t\telse {\t \n\n\t\t\t\tif (tlck->flag & tlckDIRECTORY)\n\t\t\t\t\ttxFreeMap(ipimap, maplock,\n\t\t\t\t\t\t  tblk, COMMIT_PWMAP);\n\t\t\t\telse\n\t\t\t\t\ttxFreeMap(ipimap, maplock,\n\t\t\t\t\t\t  tblk, maptype);\n\t\t\t}\n\t\t}\n\t\tif (tlck->flag & tlckFREEPAGE) {\n\t\t\tif (!(tblk->flag & tblkGC_LAZY)) {\n\t\t\t\t \n\t\t\t\tASSERT(mp->lid == lid);\n\t\t\t\ttlck->mp->lid = 0;\n\t\t\t}\n\t\t\tassert(mp->nohomeok == 1);\n\t\t\tmetapage_homeok(mp);\n\t\t\tdiscard_metapage(mp);\n\t\t\ttlck->mp = NULL;\n\t\t}\n\t}\n\t \n\tif (tblk->xflag & COMMIT_CREATE) {\n\t\tdiUpdatePMap(ipimap, tblk->ino, false, tblk);\n\t\t \n\t\tpxdlock.flag = mlckALLOCPXD;\n\t\tpxdlock.pxd = tblk->u.ixpxd;\n\t\tpxdlock.index = 1;\n\t\ttxAllocPMap(ipimap, (struct maplock *) & pxdlock, tblk);\n\t} else if (tblk->xflag & COMMIT_DELETE) {\n\t\tip = tblk->u.ip;\n\t\tdiUpdatePMap(ipimap, ip->i_ino, true, tblk);\n\t\tiput(ip);\n\t}\n}\n\n \nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\t\tstruct tblock * tblk)\n{\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct xdlistlock *xadlistlock;\n\txad_t *xad;\n\ts64 xaddr;\n\tint xlen;\n\tstruct pxd_lock *pxdlock;\n\tstruct xdlistlock *pxdlistlock;\n\tpxd_t *pxd;\n\tint n;\n\n\t \n\tif (maplock->flag & mlckALLOCXADLIST) {\n\t\txadlistlock = (struct xdlistlock *) maplock;\n\t\txad = xadlistlock->xdlist;\n\t\tfor (n = 0; n < xadlistlock->count; n++, xad++) {\n\t\t\tif (xad->flag & (XAD_NEW | XAD_EXTENDED)) {\n\t\t\t\txaddr = addressXAD(xad);\n\t\t\t\txlen = lengthXAD(xad);\n\t\t\t\tdbUpdatePMap(ipbmap, false, xaddr,\n\t\t\t\t\t     (s64) xlen, tblk);\n\t\t\t\txad->flag &= ~(XAD_NEW | XAD_EXTENDED);\n\t\t\t\tjfs_info(\"allocPMap: xaddr:0x%lx xlen:%d\",\n\t\t\t\t\t (ulong) xaddr, xlen);\n\t\t\t}\n\t\t}\n\t} else if (maplock->flag & mlckALLOCPXD) {\n\t\tpxdlock = (struct pxd_lock *) maplock;\n\t\txaddr = addressPXD(&pxdlock->pxd);\n\t\txlen = lengthPXD(&pxdlock->pxd);\n\t\tdbUpdatePMap(ipbmap, false, xaddr, (s64) xlen, tblk);\n\t\tjfs_info(\"allocPMap: xaddr:0x%lx xlen:%d\", (ulong) xaddr, xlen);\n\t} else {\t\t \n\n\t\tpxdlistlock = (struct xdlistlock *) maplock;\n\t\tpxd = pxdlistlock->xdlist;\n\t\tfor (n = 0; n < pxdlistlock->count; n++, pxd++) {\n\t\t\txaddr = addressPXD(pxd);\n\t\t\txlen = lengthPXD(pxd);\n\t\t\tdbUpdatePMap(ipbmap, false, xaddr, (s64) xlen,\n\t\t\t\t     tblk);\n\t\t\tjfs_info(\"allocPMap: xaddr:0x%lx xlen:%d\",\n\t\t\t\t (ulong) xaddr, xlen);\n\t\t}\n\t}\n}\n\n \nvoid txFreeMap(struct inode *ip,\n\t       struct maplock * maplock, struct tblock * tblk, int maptype)\n{\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct xdlistlock *xadlistlock;\n\txad_t *xad;\n\ts64 xaddr;\n\tint xlen;\n\tstruct pxd_lock *pxdlock;\n\tstruct xdlistlock *pxdlistlock;\n\tpxd_t *pxd;\n\tint n;\n\n\tjfs_info(\"txFreeMap: tblk:0x%p maplock:0x%p maptype:0x%x\",\n\t\t tblk, maplock, maptype);\n\n\t \n\tif (maptype == COMMIT_PMAP || maptype == COMMIT_PWMAP) {\n\t\tif (maplock->flag & mlckFREEXADLIST) {\n\t\t\txadlistlock = (struct xdlistlock *) maplock;\n\t\t\txad = xadlistlock->xdlist;\n\t\t\tfor (n = 0; n < xadlistlock->count; n++, xad++) {\n\t\t\t\tif (!(xad->flag & XAD_NEW)) {\n\t\t\t\t\txaddr = addressXAD(xad);\n\t\t\t\t\txlen = lengthXAD(xad);\n\t\t\t\t\tdbUpdatePMap(ipbmap, true, xaddr,\n\t\t\t\t\t\t     (s64) xlen, tblk);\n\t\t\t\t\tjfs_info(\"freePMap: xaddr:0x%lx xlen:%d\",\n\t\t\t\t\t\t (ulong) xaddr, xlen);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (maplock->flag & mlckFREEPXD) {\n\t\t\tpxdlock = (struct pxd_lock *) maplock;\n\t\t\txaddr = addressPXD(&pxdlock->pxd);\n\t\t\txlen = lengthPXD(&pxdlock->pxd);\n\t\t\tdbUpdatePMap(ipbmap, true, xaddr, (s64) xlen,\n\t\t\t\t     tblk);\n\t\t\tjfs_info(\"freePMap: xaddr:0x%lx xlen:%d\",\n\t\t\t\t (ulong) xaddr, xlen);\n\t\t} else {\t \n\n\t\t\tpxdlistlock = (struct xdlistlock *) maplock;\n\t\t\tpxd = pxdlistlock->xdlist;\n\t\t\tfor (n = 0; n < pxdlistlock->count; n++, pxd++) {\n\t\t\t\txaddr = addressPXD(pxd);\n\t\t\t\txlen = lengthPXD(pxd);\n\t\t\t\tdbUpdatePMap(ipbmap, true, xaddr,\n\t\t\t\t\t     (s64) xlen, tblk);\n\t\t\t\tjfs_info(\"freePMap: xaddr:0x%lx xlen:%d\",\n\t\t\t\t\t (ulong) xaddr, xlen);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (maptype == COMMIT_PWMAP || maptype == COMMIT_WMAP) {\n\t\tif (maplock->flag & mlckFREEXADLIST) {\n\t\t\txadlistlock = (struct xdlistlock *) maplock;\n\t\t\txad = xadlistlock->xdlist;\n\t\t\tfor (n = 0; n < xadlistlock->count; n++, xad++) {\n\t\t\t\txaddr = addressXAD(xad);\n\t\t\t\txlen = lengthXAD(xad);\n\t\t\t\tdbFree(ip, xaddr, (s64) xlen);\n\t\t\t\txad->flag = 0;\n\t\t\t\tjfs_info(\"freeWMap: xaddr:0x%lx xlen:%d\",\n\t\t\t\t\t (ulong) xaddr, xlen);\n\t\t\t}\n\t\t} else if (maplock->flag & mlckFREEPXD) {\n\t\t\tpxdlock = (struct pxd_lock *) maplock;\n\t\t\txaddr = addressPXD(&pxdlock->pxd);\n\t\t\txlen = lengthPXD(&pxdlock->pxd);\n\t\t\tdbFree(ip, xaddr, (s64) xlen);\n\t\t\tjfs_info(\"freeWMap: xaddr:0x%lx xlen:%d\",\n\t\t\t\t (ulong) xaddr, xlen);\n\t\t} else {\t \n\n\t\t\tpxdlistlock = (struct xdlistlock *) maplock;\n\t\t\tpxd = pxdlistlock->xdlist;\n\t\t\tfor (n = 0; n < pxdlistlock->count; n++, pxd++) {\n\t\t\t\txaddr = addressPXD(pxd);\n\t\t\t\txlen = lengthPXD(pxd);\n\t\t\t\tdbFree(ip, xaddr, (s64) xlen);\n\t\t\t\tjfs_info(\"freeWMap: xaddr:0x%lx xlen:%d\",\n\t\t\t\t\t (ulong) xaddr, xlen);\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nvoid txFreelock(struct inode *ip)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tstruct tlock *xtlck, *tlck;\n\tlid_t xlid = 0, lid;\n\n\tif (!jfs_ip->atlhead)\n\t\treturn;\n\n\tTXN_LOCK();\n\txtlck = (struct tlock *) &jfs_ip->atlhead;\n\n\twhile ((lid = xtlck->next) != 0) {\n\t\ttlck = lid_to_tlock(lid);\n\t\tif (tlck->flag & tlckFREELOCK) {\n\t\t\txtlck->next = tlck->next;\n\t\t\ttxLockFree(lid);\n\t\t} else {\n\t\t\txtlck = tlck;\n\t\t\txlid = lid;\n\t\t}\n\t}\n\n\tif (jfs_ip->atlhead)\n\t\tjfs_ip->atltail = xlid;\n\telse {\n\t\tjfs_ip->atltail = 0;\n\t\t \n\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t}\n\tTXN_UNLOCK();\n}\n\n \nvoid txAbort(tid_t tid, int dirty)\n{\n\tlid_t lid, next;\n\tstruct metapage *mp;\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct tlock *tlck;\n\n\t \n\tfor (lid = tblk->next; lid; lid = next) {\n\t\ttlck = lid_to_tlock(lid);\n\t\tnext = tlck->next;\n\t\tmp = tlck->mp;\n\t\tJFS_IP(tlck->ip)->xtlid = 0;\n\n\t\tif (mp) {\n\t\t\tmp->lid = 0;\n\n\t\t\t \n\t\t\tif (mp->xflag & COMMIT_PAGE && mp->lsn)\n\t\t\t\tLogSyncRelease(mp);\n\t\t}\n\t\t \n\t\tTXN_LOCK();\n\t\ttxLockFree(lid);\n\t\tTXN_UNLOCK();\n\t}\n\n\t \n\n\ttblk->next = tblk->last = 0;\n\n\t \n\tif (dirty)\n\t\tjfs_error(tblk->sb, \"\\n\");\n\n\treturn;\n}\n\n \nstatic void txLazyCommit(struct tblock * tblk)\n{\n\tstruct jfs_log *log;\n\n\twhile (((tblk->flag & tblkGC_READY) == 0) &&\n\t       ((tblk->flag & tblkGC_UNLOCKED) == 0)) {\n\t\t \n\t\tjfs_info(\"jfs_lazycommit: tblk 0x%p not unlocked\", tblk);\n\t\tyield();\n\t}\n\n\tjfs_info(\"txLazyCommit: processing tblk 0x%p\", tblk);\n\n\ttxUpdateMap(tblk);\n\n\tlog = (struct jfs_log *) JFS_SBI(tblk->sb)->log;\n\n\tspin_lock_irq(&log->gclock);\t \n\n\ttblk->flag |= tblkGC_COMMITTED;\n\n\tif (tblk->flag & tblkGC_READY)\n\t\tlog->gcrtc--;\n\n\twake_up_all(&tblk->gcwait);\t \n\n\t \n\tif (tblk->flag & tblkGC_LAZY) {\n\t\tspin_unlock_irq(&log->gclock);\t \n\t\ttxUnlock(tblk);\n\t\ttblk->flag &= ~tblkGC_LAZY;\n\t\ttxEnd(tblk - TxBlock);\t \n\t} else\n\t\tspin_unlock_irq(&log->gclock);\t \n\n\tjfs_info(\"txLazyCommit: done: tblk = 0x%p\", tblk);\n}\n\n \nint jfs_lazycommit(void *arg)\n{\n\tint WorkDone;\n\tstruct tblock *tblk;\n\tunsigned long flags;\n\tstruct jfs_sb_info *sbi;\n\n\tdo {\n\t\tLAZY_LOCK(flags);\n\t\tjfs_commit_thread_waking = 0;\t \n\t\twhile (!list_empty(&TxAnchor.unlock_queue)) {\n\t\t\tWorkDone = 0;\n\t\t\tlist_for_each_entry(tblk, &TxAnchor.unlock_queue,\n\t\t\t\t\t    cqueue) {\n\n\t\t\t\tsbi = JFS_SBI(tblk->sb);\n\t\t\t\t \n\t\t\t\tif (sbi->commit_state & IN_LAZYCOMMIT)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tsbi->commit_state |= IN_LAZYCOMMIT;\n\t\t\t\tWorkDone = 1;\n\n\t\t\t\t \n\t\t\t\tlist_del(&tblk->cqueue);\n\n\t\t\t\tLAZY_UNLOCK(flags);\n\t\t\t\ttxLazyCommit(tblk);\n\t\t\t\tLAZY_LOCK(flags);\n\n\t\t\t\tsbi->commit_state &= ~IN_LAZYCOMMIT;\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!WorkDone)\n\t\t\t\tbreak;\n\t\t}\n\t\t \n\t\tjfs_commit_thread_waking = 0;\n\n\t\tif (freezing(current)) {\n\t\t\tLAZY_UNLOCK(flags);\n\t\t\ttry_to_freeze();\n\t\t} else {\n\t\t\tDECLARE_WAITQUEUE(wq, current);\n\n\t\t\tadd_wait_queue(&jfs_commit_thread_wait, &wq);\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tLAZY_UNLOCK(flags);\n\t\t\tschedule();\n\t\t\tremove_wait_queue(&jfs_commit_thread_wait, &wq);\n\t\t}\n\t} while (!kthread_should_stop());\n\n\tif (!list_empty(&TxAnchor.unlock_queue))\n\t\tjfs_err(\"jfs_lazycommit being killed w/pending transactions!\");\n\telse\n\t\tjfs_info(\"jfs_lazycommit being killed\");\n\treturn 0;\n}\n\nvoid txLazyUnlock(struct tblock * tblk)\n{\n\tunsigned long flags;\n\n\tLAZY_LOCK(flags);\n\n\tlist_add_tail(&tblk->cqueue, &TxAnchor.unlock_queue);\n\t \n\tif (!(JFS_SBI(tblk->sb)->commit_state & IN_LAZYCOMMIT) &&\n\t    !jfs_commit_thread_waking) {\n\t\tjfs_commit_thread_waking = 1;\n\t\twake_up(&jfs_commit_thread_wait);\n\t}\n\tLAZY_UNLOCK(flags);\n}\n\nstatic void LogSyncRelease(struct metapage * mp)\n{\n\tstruct jfs_log *log = mp->log;\n\n\tassert(mp->nohomeok);\n\tassert(log);\n\tmetapage_homeok(mp);\n}\n\n \nvoid txQuiesce(struct super_block *sb)\n{\n\tstruct inode *ip;\n\tstruct jfs_inode_info *jfs_ip;\n\tstruct jfs_log *log = JFS_SBI(sb)->log;\n\ttid_t tid;\n\n\tset_bit(log_QUIESCE, &log->flag);\n\n\tTXN_LOCK();\nrestart:\n\twhile (!list_empty(&TxAnchor.anon_list)) {\n\t\tjfs_ip = list_entry(TxAnchor.anon_list.next,\n\t\t\t\t    struct jfs_inode_info,\n\t\t\t\t    anon_inode_list);\n\t\tip = &jfs_ip->vfs_inode;\n\n\t\t \n\t\tTXN_UNLOCK();\n\t\ttid = txBegin(ip->i_sb, COMMIT_INODE | COMMIT_FORCE);\n\t\tmutex_lock(&jfs_ip->commit_mutex);\n\t\ttxCommit(tid, 1, &ip, 0);\n\t\ttxEnd(tid);\n\t\tmutex_unlock(&jfs_ip->commit_mutex);\n\t\t \n\t\tcond_resched();\n\t\tTXN_LOCK();\n\t}\n\n\t \n\tif (!list_empty(&TxAnchor.anon_list2)) {\n\t\tlist_splice_init(&TxAnchor.anon_list2, &TxAnchor.anon_list);\n\t\tgoto restart;\n\t}\n\tTXN_UNLOCK();\n\n\t \n\tjfs_flush_journal(log, 0);\n}\n\n \nvoid txResume(struct super_block *sb)\n{\n\tstruct jfs_log *log = JFS_SBI(sb)->log;\n\n\tclear_bit(log_QUIESCE, &log->flag);\n\tTXN_WAKEUP(&log->syncwait);\n}\n\n \nint jfs_sync(void *arg)\n{\n\tstruct inode *ip;\n\tstruct jfs_inode_info *jfs_ip;\n\ttid_t tid;\n\n\tdo {\n\t\t \n\t\tTXN_LOCK();\n\t\twhile (jfs_tlocks_low && !list_empty(&TxAnchor.anon_list)) {\n\t\t\tjfs_ip = list_entry(TxAnchor.anon_list.next,\n\t\t\t\t\t    struct jfs_inode_info,\n\t\t\t\t\t    anon_inode_list);\n\t\t\tip = &jfs_ip->vfs_inode;\n\n\t\t\tif (! igrab(ip)) {\n\t\t\t\t \n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t} else if (mutex_trylock(&jfs_ip->commit_mutex)) {\n\t\t\t\t \n\t\t\t\tTXN_UNLOCK();\n\t\t\t\ttid = txBegin(ip->i_sb, COMMIT_INODE);\n\t\t\t\ttxCommit(tid, 1, &ip, 0);\n\t\t\t\ttxEnd(tid);\n\t\t\t\tmutex_unlock(&jfs_ip->commit_mutex);\n\n\t\t\t\tiput(ip);\n\t\t\t\t \n\t\t\t\tcond_resched();\n\t\t\t\tTXN_LOCK();\n\t\t\t} else {\n\t\t\t\t \n\n\t\t\t\t \n\t\t\t\tlist_move(&jfs_ip->anon_inode_list,\n\t\t\t\t\t  &TxAnchor.anon_list2);\n\n\t\t\t\tTXN_UNLOCK();\n\t\t\t\tiput(ip);\n\t\t\t\tTXN_LOCK();\n\t\t\t}\n\t\t}\n\t\t \n\t\tlist_splice_init(&TxAnchor.anon_list2, &TxAnchor.anon_list);\n\n\t\tif (freezing(current)) {\n\t\t\tTXN_UNLOCK();\n\t\t\ttry_to_freeze();\n\t\t} else {\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tTXN_UNLOCK();\n\t\t\tschedule();\n\t\t}\n\t} while (!kthread_should_stop());\n\n\tjfs_info(\"jfs_sync being killed\");\n\treturn 0;\n}\n\n#if defined(CONFIG_PROC_FS) && defined(CONFIG_JFS_DEBUG)\nint jfs_txanchor_proc_show(struct seq_file *m, void *v)\n{\n\tchar *freewait;\n\tchar *freelockwait;\n\tchar *lowlockwait;\n\n\tfreewait =\n\t    waitqueue_active(&TxAnchor.freewait) ? \"active\" : \"empty\";\n\tfreelockwait =\n\t    waitqueue_active(&TxAnchor.freelockwait) ? \"active\" : \"empty\";\n\tlowlockwait =\n\t    waitqueue_active(&TxAnchor.lowlockwait) ? \"active\" : \"empty\";\n\n\tseq_printf(m,\n\t\t       \"JFS TxAnchor\\n\"\n\t\t       \"============\\n\"\n\t\t       \"freetid = %d\\n\"\n\t\t       \"freewait = %s\\n\"\n\t\t       \"freelock = %d\\n\"\n\t\t       \"freelockwait = %s\\n\"\n\t\t       \"lowlockwait = %s\\n\"\n\t\t       \"tlocksInUse = %d\\n\"\n\t\t       \"jfs_tlocks_low = %d\\n\"\n\t\t       \"unlock_queue is %sempty\\n\",\n\t\t       TxAnchor.freetid,\n\t\t       freewait,\n\t\t       TxAnchor.freelock,\n\t\t       freelockwait,\n\t\t       lowlockwait,\n\t\t       TxAnchor.tlocksInUse,\n\t\t       jfs_tlocks_low,\n\t\t       list_empty(&TxAnchor.unlock_queue) ? \"\" : \"not \");\n\treturn 0;\n}\n#endif\n\n#if defined(CONFIG_PROC_FS) && defined(CONFIG_JFS_STATISTICS)\nint jfs_txstats_proc_show(struct seq_file *m, void *v)\n{\n\tseq_printf(m,\n\t\t       \"JFS TxStats\\n\"\n\t\t       \"===========\\n\"\n\t\t       \"calls to txBegin = %d\\n\"\n\t\t       \"txBegin blocked by sync barrier = %d\\n\"\n\t\t       \"txBegin blocked by tlocks low = %d\\n\"\n\t\t       \"txBegin blocked by no free tid = %d\\n\"\n\t\t       \"calls to txBeginAnon = %d\\n\"\n\t\t       \"txBeginAnon blocked by sync barrier = %d\\n\"\n\t\t       \"txBeginAnon blocked by tlocks low = %d\\n\"\n\t\t       \"calls to txLockAlloc = %d\\n\"\n\t\t       \"tLockAlloc blocked by no free lock = %d\\n\",\n\t\t       TxStat.txBegin,\n\t\t       TxStat.txBegin_barrier,\n\t\t       TxStat.txBegin_lockslow,\n\t\t       TxStat.txBegin_freetid,\n\t\t       TxStat.txBeginAnon,\n\t\t       TxStat.txBeginAnon_barrier,\n\t\t       TxStat.txBeginAnon_lockslow,\n\t\t       TxStat.txLockAlloc,\n\t\t       TxStat.txLockAlloc_freelock);\n\treturn 0;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}