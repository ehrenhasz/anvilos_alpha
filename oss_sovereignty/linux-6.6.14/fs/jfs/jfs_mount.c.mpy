{
  "module_name": "jfs_mount.c",
  "hash_id": "ebd214a6b2dcc9f2a85bcad5f49cdeff10a594739691cbdd72bf514ba4c44688",
  "original_prompt": "Ingested from linux-6.6.14/fs/jfs/jfs_mount.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/log2.h>\n\n#include \"jfs_incore.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_debug.h\"\n\n\n \nstatic int chkSuper(struct super_block *);\nstatic int logMOUNT(struct super_block *sb);\n\n \nint jfs_mount(struct super_block *sb)\n{\n\tint rc = 0;\t\t \n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct inode *ipaimap = NULL;\n\tstruct inode *ipaimap2 = NULL;\n\tstruct inode *ipimap = NULL;\n\tstruct inode *ipbmap = NULL;\n\n\t \n\tif ((rc = chkSuper(sb))) {\n\t\tgoto out;\n\t}\n\n\tipaimap = diReadSpecial(sb, AGGREGATE_I, 0);\n\tif (ipaimap == NULL) {\n\t\tjfs_err(\"jfs_mount: Failed to read AGGREGATE_I\");\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\tsbi->ipaimap = ipaimap;\n\n\tjfs_info(\"jfs_mount: ipaimap:0x%p\", ipaimap);\n\n\t \n\tif ((rc = diMount(ipaimap))) {\n\t\tjfs_err(\"jfs_mount: diMount(ipaimap) failed w/rc = %d\", rc);\n\t\tgoto err_ipaimap;\n\t}\n\n\t \n\tipbmap = diReadSpecial(sb, BMAP_I, 0);\n\tif (ipbmap == NULL) {\n\t\trc = -EIO;\n\t\tgoto err_umount_ipaimap;\n\t}\n\n\tjfs_info(\"jfs_mount: ipbmap:0x%p\", ipbmap);\n\n\tsbi->ipbmap = ipbmap;\n\n\t \n\tif ((rc = dbMount(ipbmap))) {\n\t\tjfs_err(\"jfs_mount: dbMount failed w/rc = %d\", rc);\n\t\tgoto err_ipbmap;\n\t}\n\n\t \n\tif ((sbi->mntflag & JFS_BAD_SAIT) == 0) {\n\t\tipaimap2 = diReadSpecial(sb, AGGREGATE_I, 1);\n\t\tif (!ipaimap2) {\n\t\t\tjfs_err(\"jfs_mount: Failed to read AGGREGATE_I\");\n\t\t\trc = -EIO;\n\t\t\tgoto err_umount_ipbmap;\n\t\t}\n\t\tsbi->ipaimap2 = ipaimap2;\n\n\t\tjfs_info(\"jfs_mount: ipaimap2:0x%p\", ipaimap2);\n\n\t\t \n\t\tif ((rc = diMount(ipaimap2))) {\n\t\t\tjfs_err(\"jfs_mount: diMount(ipaimap2) failed, rc = %d\",\n\t\t\t\trc);\n\t\t\tgoto err_ipaimap2;\n\t\t}\n\t} else\n\t\t \n\t\tsbi->ipaimap2 = NULL;\n\n\t \n\t \n\tipimap = diReadSpecial(sb, FILESYSTEM_I, 0);\n\tif (ipimap == NULL) {\n\t\tjfs_err(\"jfs_mount: Failed to read FILESYSTEM_I\");\n\t\t \n\t\trc = -EIO;\n\t\tgoto err_umount_ipaimap2;\n\t}\n\tjfs_info(\"jfs_mount: ipimap:0x%p\", ipimap);\n\n\t \n\tsbi->ipimap = ipimap;\n\n\t \n\tif ((rc = diMount(ipimap))) {\n\t\tjfs_err(\"jfs_mount: diMount failed w/rc = %d\", rc);\n\t\tgoto err_ipimap;\n\t}\n\n\treturn rc;\n\n\t \nerr_ipimap:\n\t \n\tdiFreeSpecial(ipimap);\nerr_umount_ipaimap2:\n\t \n\tif (ipaimap2)\n\t\tdiUnmount(ipaimap2, 1);\nerr_ipaimap2:\n\t \n\tif (ipaimap2)\n\t\tdiFreeSpecial(ipaimap2);\nerr_umount_ipbmap:\t \n\tdbUnmount(ipbmap, 1);\nerr_ipbmap:\t\t \n\tdiFreeSpecial(ipbmap);\nerr_umount_ipaimap:\t \n\tdiUnmount(ipaimap, 1);\nerr_ipaimap:\t\t \n\tdiFreeSpecial(ipaimap);\nout:\n\tif (rc)\n\t\tjfs_err(\"Mount JFS Failure: %d\", rc);\n\n\treturn rc;\n}\n\n \nint jfs_mount_rw(struct super_block *sb, int remount)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tint rc;\n\n\t \n\tif (remount) {\n\t\tif (chkSuper(sb) || (sbi->state != FM_CLEAN))\n\t\t\treturn -EINVAL;\n\n\t\ttruncate_inode_pages(sbi->ipimap->i_mapping, 0);\n\t\ttruncate_inode_pages(sbi->ipbmap->i_mapping, 0);\n\n\t\tIWRITE_LOCK(sbi->ipimap, RDWRLOCK_IMAP);\n\t\tdiUnmount(sbi->ipimap, 1);\n\t\tif ((rc = diMount(sbi->ipimap))) {\n\t\t\tIWRITE_UNLOCK(sbi->ipimap);\n\t\t\tjfs_err(\"jfs_mount_rw: diMount failed!\");\n\t\t\treturn rc;\n\t\t}\n\t\tIWRITE_UNLOCK(sbi->ipimap);\n\n\t\tdbUnmount(sbi->ipbmap, 1);\n\t\tif ((rc = dbMount(sbi->ipbmap))) {\n\t\t\tjfs_err(\"jfs_mount_rw: dbMount failed!\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\t \n\tif ((rc = lmLogOpen(sb)))\n\t\treturn rc;\n\n\t \n\tif ((rc = updateSuper(sb, FM_MOUNT))) {\n\t\tjfs_err(\"jfs_mount: updateSuper failed w/rc = %d\", rc);\n\t\tlmLogClose(sb);\n\t\treturn rc;\n\t}\n\n\t \n\tlogMOUNT(sb);\n\n\treturn rc;\n}\n\n \nstatic int chkSuper(struct super_block *sb)\n{\n\tint rc = 0;\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct jfs_superblock *j_sb;\n\tstruct buffer_head *bh;\n\tint AIM_bytesize, AIT_bytesize;\n\tint expected_AIM_bytesize, expected_AIT_bytesize;\n\ts64 AIM_byte_addr, AIT_byte_addr, fsckwsp_addr;\n\ts64 byte_addr_diff0, byte_addr_diff1;\n\ts32 bsize;\n\n\tif ((rc = readSuper(sb, &bh)))\n\t\treturn rc;\n\tj_sb = (struct jfs_superblock *)bh->b_data;\n\n\t \n\t \n\tif (strncmp(j_sb->s_magic, JFS_MAGIC, 4) ||\n\t    le32_to_cpu(j_sb->s_version) > JFS_VERSION) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tbsize = le32_to_cpu(j_sb->s_bsize);\n\tif (bsize != PSIZE) {\n\t\tjfs_err(\"Only 4K block size supported!\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tjfs_info(\"superblock: flag:0x%08x state:0x%08x size:0x%Lx\",\n\t\t le32_to_cpu(j_sb->s_flag), le32_to_cpu(j_sb->s_state),\n\t\t (unsigned long long) le64_to_cpu(j_sb->s_size));\n\n\t \n\tif ((j_sb->s_flag & cpu_to_le32(JFS_BAD_SAIT)) !=\n\t    cpu_to_le32(JFS_BAD_SAIT)) {\n\t\texpected_AIM_bytesize = 2 * PSIZE;\n\t\tAIM_bytesize = lengthPXD(&(j_sb->s_aim2)) * bsize;\n\t\texpected_AIT_bytesize = 4 * PSIZE;\n\t\tAIT_bytesize = lengthPXD(&(j_sb->s_ait2)) * bsize;\n\t\tAIM_byte_addr = addressPXD(&(j_sb->s_aim2)) * bsize;\n\t\tAIT_byte_addr = addressPXD(&(j_sb->s_ait2)) * bsize;\n\t\tbyte_addr_diff0 = AIT_byte_addr - AIM_byte_addr;\n\t\tfsckwsp_addr = addressPXD(&(j_sb->s_fsckpxd)) * bsize;\n\t\tbyte_addr_diff1 = fsckwsp_addr - AIT_byte_addr;\n\t\tif ((AIM_bytesize != expected_AIM_bytesize) ||\n\t\t    (AIT_bytesize != expected_AIT_bytesize) ||\n\t\t    (byte_addr_diff0 != AIM_bytesize) ||\n\t\t    (byte_addr_diff1 <= AIT_bytesize))\n\t\t\tj_sb->s_flag |= cpu_to_le32(JFS_BAD_SAIT);\n\t}\n\n\tif ((j_sb->s_flag & cpu_to_le32(JFS_GROUPCOMMIT)) !=\n\t    cpu_to_le32(JFS_GROUPCOMMIT))\n\t\tj_sb->s_flag |= cpu_to_le32(JFS_GROUPCOMMIT);\n\n\t \n\tif (j_sb->s_state != cpu_to_le32(FM_CLEAN) &&\n\t    !sb_rdonly(sb)) {\n\t\tjfs_err(\"jfs_mount: Mount Failure: File System Dirty.\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tsbi->state = le32_to_cpu(j_sb->s_state);\n\tsbi->mntflag = le32_to_cpu(j_sb->s_flag);\n\n\t \n\tsbi->bsize = bsize;\n\tsbi->l2bsize = le16_to_cpu(j_sb->s_l2bsize);\n\n\t \n\tif (sbi->l2bsize != ilog2((u32)bsize) ||\n\t    j_sb->pad != 0 ||\n\t    le32_to_cpu(j_sb->s_state) > FM_STATE_MAX) {\n\t\trc = -EINVAL;\n\t\tjfs_err(\"jfs_mount: Mount Failure: superblock is corrupt!\");\n\t\tgoto out;\n\t}\n\n\t \n\tsbi->nbperpage = PSIZE >> sbi->l2bsize;\n\tsbi->l2nbperpage = L2PSIZE - sbi->l2bsize;\n\tsbi->l2niperblk = sbi->l2bsize - L2DISIZE;\n\tif (sbi->mntflag & JFS_INLINELOG)\n\t\tsbi->logpxd = j_sb->s_logpxd;\n\telse {\n\t\tsbi->logdev = new_decode_dev(le32_to_cpu(j_sb->s_logdev));\n\t\tuuid_copy(&sbi->uuid, &j_sb->s_uuid);\n\t\tuuid_copy(&sbi->loguuid, &j_sb->s_loguuid);\n\t}\n\tsbi->fsckpxd = j_sb->s_fsckpxd;\n\tsbi->ait2 = j_sb->s_ait2;\n\n      out:\n\tbrelse(bh);\n\treturn rc;\n}\n\n\n \nint updateSuper(struct super_block *sb, uint state)\n{\n\tstruct jfs_superblock *j_sb;\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct buffer_head *bh;\n\tint rc;\n\n\tif (sbi->flag & JFS_NOINTEGRITY) {\n\t\tif (state == FM_DIRTY) {\n\t\t\tsbi->p_state = state;\n\t\t\treturn 0;\n\t\t} else if (state == FM_MOUNT) {\n\t\t\tsbi->p_state = sbi->state;\n\t\t\tstate = FM_DIRTY;\n\t\t} else if (state == FM_CLEAN) {\n\t\t\tstate = sbi->p_state;\n\t\t} else\n\t\t\tjfs_err(\"updateSuper: bad state\");\n\t} else if (sbi->state == FM_DIRTY)\n\t\treturn 0;\n\n\tif ((rc = readSuper(sb, &bh)))\n\t\treturn rc;\n\n\tj_sb = (struct jfs_superblock *)bh->b_data;\n\n\tj_sb->s_state = cpu_to_le32(state);\n\tsbi->state = state;\n\n\tif (state == FM_MOUNT) {\n\t\t \n\t\tj_sb->s_logdev = cpu_to_le32(new_encode_dev(sbi->log->bdev->bd_dev));\n\t\tj_sb->s_logserial = cpu_to_le32(sbi->log->serial);\n\t} else if (state == FM_CLEAN) {\n\t\t \n\t\tif (j_sb->s_flag & cpu_to_le32(JFS_DASD_ENABLED))\n\t\t\tj_sb->s_flag |= cpu_to_le32(JFS_DASD_PRIME);\n\t}\n\n\tmark_buffer_dirty(bh);\n\tsync_dirty_buffer(bh);\n\tbrelse(bh);\n\n\treturn 0;\n}\n\n\n \nint readSuper(struct super_block *sb, struct buffer_head **bpp)\n{\n\t \n\t*bpp = sb_bread(sb, SUPER1_OFF >> sb->s_blocksize_bits);\n\tif (*bpp)\n\t\treturn 0;\n\n\t \n\t*bpp = sb_bread(sb, SUPER2_OFF >> sb->s_blocksize_bits);\n\tif (*bpp)\n\t\treturn 0;\n\n\treturn -EIO;\n}\n\n\n \nstatic int logMOUNT(struct super_block *sb)\n{\n\tstruct jfs_log *log = JFS_SBI(sb)->log;\n\tstruct lrd lrd;\n\n\tlrd.logtid = 0;\n\tlrd.backchain = 0;\n\tlrd.type = cpu_to_le16(LOG_MOUNT);\n\tlrd.length = 0;\n\tlrd.aggregate = cpu_to_le32(new_encode_dev(sb->s_bdev->bd_dev));\n\tlmLog(log, NULL, &lrd, NULL);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}