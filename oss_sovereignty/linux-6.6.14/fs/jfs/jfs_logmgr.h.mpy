{
  "module_name": "jfs_logmgr.h",
  "hash_id": "47f9314e46ddf96976f7955f58b1b601101490d79fb8f6fe51ac26eb7ab8cf88",
  "original_prompt": "Ingested from linux-6.6.14/fs/jfs/jfs_logmgr.h",
  "human_readable_source": " \n \n#ifndef\t_H_JFS_LOGMGR\n#define _H_JFS_LOGMGR\n\n#include <linux/uuid.h>\n\n#include \"jfs_filsys.h\"\n#include \"jfs_lock.h\"\n\n \n\n \n#define\tLOGPSIZE\t4096\n#define\tL2LOGPSIZE\t12\n\n#define LOGPAGES\t16\t \n\n \n \n#define\tLOGSUPER_B\t1\n#define\tLOGSTART_B\t2\n\n#define\tLOGMAGIC\t0x87654321\n#define\tLOGVERSION\t1\n\n#define MAX_ACTIVE\t128\t \n\nstruct logsuper {\n\t__le32 magic;\t\t \n\t__le32 version;\t\t \n\t__le32 serial;\t\t \n\t__le32 size;\t\t \n\t__le32 bsize;\t\t \n\t__le32 l2bsize;\t\t \n\n\t__le32 flag;\t\t \n\t__le32 state;\t\t \n\n\t__le32 end;\t\t \n\tuuid_t uuid;\t\t \n\tchar label[16];\t\t \n\tstruct {\n\t\tuuid_t uuid;\n\t} active[MAX_ACTIVE];\t \n};\n\n \n\n \n#define\tLOGMOUNT\t0\t \n#define LOGREDONE\t1\t \n#define LOGWRAP\t\t2\t \n#define LOGREADERR\t3\t \n\n\n \nstruct logpage {\n\tstruct {\t\t \n\t\t__le32 page;\t \n\t\t__le16 rsrvd;\t \n\t\t__le16 eor;\t \n\t} h;\n\n\t__le32 data[LOGPSIZE / 4 - 4];\t \n\n\tstruct {\t\t \n\t\t__le32 page;\t \n\t\t__le16 rsrvd;\t \n\t\t__le16 eor;\t \n\t} t;\n};\n\n#define LOGPHDRSIZE\t8\t \n#define LOGPTLRSIZE\t8\t \n\n\n \n\n \n#define LOG_COMMIT\t\t0x8000\n#define LOG_SYNCPT\t\t0x4000\n#define LOG_MOUNT\t\t0x2000\n#define LOG_REDOPAGE\t\t0x0800\n#define LOG_NOREDOPAGE\t\t0x0080\n#define LOG_NOREDOINOEXT\t0x0040\n#define LOG_UPDATEMAP\t\t0x0008\n#define LOG_NOREDOFILE\t\t0x0001\n\n \n#define\tLOG_INODE\t\t0x0001\n#define\tLOG_XTREE\t\t0x0002\n#define\tLOG_DTREE\t\t0x0004\n#define\tLOG_BTROOT\t\t0x0010\n#define\tLOG_EA\t\t\t0x0020\n#define\tLOG_ACL\t\t\t0x0040\n#define\tLOG_DATA\t\t0x0080\n#define\tLOG_NEW\t\t\t0x0100\n#define\tLOG_EXTEND\t\t0x0200\n#define LOG_RELOCATE\t\t0x0400\n#define LOG_DIR_XTREE\t\t0x0800\t \n\n \n#define\tLOG_ALLOCXADLIST\t0x0080\n#define\tLOG_ALLOCPXDLIST\t0x0040\n#define\tLOG_ALLOCXAD\t\t0x0020\n#define\tLOG_ALLOCPXD\t\t0x0010\n#define\tLOG_FREEXADLIST\t\t0x0008\n#define\tLOG_FREEPXDLIST\t\t0x0004\n#define\tLOG_FREEXAD\t\t0x0002\n#define\tLOG_FREEPXD\t\t0x0001\n\n\nstruct lrd {\n\t \n\t__le32 logtid;\t\t \n\t__le32 backchain;\t \n\t__le16 type;\t\t \n\t__le16 length;\t\t \n\t__le32 aggregate;\t \n\t \n\n\t \n\tunion {\n\n\t\t \n\n\t\t \n\t\tstruct {\n\t\t\t__le32 fileset;\t \n\t\t\t__le32 inode;\t \n\t\t\t__le16 type;\t \n\t\t\t__le16 l2linesize;\t \n\t\t\tpxd_t pxd;\t \n\t\t} redopage;\t \n\n\t\t \n\t\tstruct {\n\t\t\t__le32 fileset;\t \n\t\t\t__le32 inode;\t \n\t\t\t__le16 type;\t \n\t\t\t__le16 rsrvd;\t \n\t\t\tpxd_t pxd;\t \n\t\t} noredopage;\t \n\n\t\t \n\t\tstruct {\n\t\t\t__le32 fileset;\t \n\t\t\t__le32 inode;\t \n\t\t\t__le16 type;\t \n\t\t\t__le16 nxd;\t \n\t\t\tpxd_t pxd;\t \n\t\t} updatemap;\t \n\n\t\t \n\t\tstruct {\n\t\t\t__le32 fileset;\t \n\t\t\t__le32 iagnum;\t \n\t\t\t__le32 inoext_idx;\t \n\t\t\tpxd_t pxd;\t \n\t\t} noredoinoext;\t \n\n\t\t \n\t\tstruct {\n\t\t\t__le32 sync;\t \n\t\t} syncpt;\n\n\t\t \n\n\t\t \n\t\tstruct {\n\t\t\t__le32 type;\t \n\t\t\t__le32 nextent;\t \n\n\t\t\t \n\t\t} freextent;\n\n\t\t \n\t\tstruct {\n\t\t\t__le32 fileset;\t \n\t\t\t__le32 inode;\t \n\t\t} noredofile;\n\n\t\t \n\t\tstruct {\n\t\t\t__le32 fileset;\t \n\t\t\t__le32 inode;\t \n\t\t\t__le32 type;\t \n\t\t\tpxd_t pxd;\t \n\t\t} newpage;\n\n\t\t \n\t} log;\n};\t\t\t\t\t \n\n#define\tLOGRDSIZE\t(sizeof(struct lrd))\n\n \nstruct lvd {\n\t__le16 offset;\n\t__le16 length;\n};\n\n\n \nstruct jfs_log {\n\n\tstruct list_head sb_list; \n\tstruct list_head journal_list;  \n\tstruct block_device *bdev;  \n\tint serial;\t\t \n\n\ts64 base;\t\t \n\tint size;\t\t \n\tint l2bsize;\t\t \n\n\tunsigned long flag;\t \n\n\tstruct lbuf *lbuf_free;\t \n\twait_queue_head_t free_wait;\t \n\n\t \n\tint logtid;\t\t \n\tint page;\t\t \n\tint eor;\t\t \n\tstruct lbuf *bp;\t \n\n\tstruct mutex loglock;\t \n\n\t \n\tint nextsync;\t\t \n\tint active;\t\t \n\twait_queue_head_t syncwait;\t \n\n\t \n\tuint cflag;\t\t \n\tstruct list_head cqueue;  \n\tstruct tblock *flush_tblk;  \n\tint gcrtc;\t\t \n\tstruct tblock *gclrt;\t \n\tspinlock_t gclock;\t \n\tint logsize;\t\t \n\tint lsn;\t\t \n\tint clsn;\t\t \n\tint syncpt;\t\t \n\tint sync;\t\t \n\tstruct list_head synclist;\t \n\tspinlock_t synclock;\t \n\tstruct lbuf *wqueue;\t \n\tint count;\t\t \n\tuuid_t uuid;\t\t \n\n\tint no_integrity;\t \n};\n\n \n#define log_INLINELOG\t1\n#define log_SYNCBARRIER\t2\n#define log_QUIESCE\t3\n#define log_FLUSH\t4\n\n \n \n#define logGC_PAGEOUT\t0x00000001\n\n \n#define tblkGC_QUEUE\t\t0x0001\n#define tblkGC_READY\t\t0x0002\n#define tblkGC_COMMIT\t\t0x0004\n#define tblkGC_COMMITTED\t0x0008\n#define tblkGC_EOP\t\t0x0010\n#define tblkGC_FREE\t\t0x0020\n#define tblkGC_LEADER\t\t0x0040\n#define tblkGC_ERROR\t\t0x0080\n#define tblkGC_LAZY\t\t0x0100\t\n#define tblkGC_UNLOCKED\t\t0x0200\t\n\n \nstruct lbuf {\n\tstruct jfs_log *l_log;\t \n\n\t \n\tuint l_flag;\t\t \n\n\tstruct lbuf *l_wqnext;\t \n\tstruct lbuf *l_freelist;\t \n\n\tint l_pn;\t\t \n\tint l_eor;\t\t \n\tint l_ceor;\t\t \n\n\ts64 l_blkno;\t\t \n\tcaddr_t l_ldata;\t \n\tstruct page *l_page;\t \n\tuint l_offset;\t\t \n\n\twait_queue_head_t l_ioevent;\t \n};\n\n \n#define l_redrive_next l_freelist\n\n \nstruct logsyncblk {\n\tu16 xflag;\t\t \n\tu16 flag;\t\t \n\tlid_t lid;\t\t \n\ts32 lsn;\t\t \n\tstruct list_head synclist;\t \n};\n\n \n\n#define LOGSYNC_LOCK_INIT(log) spin_lock_init(&(log)->synclock)\n#define LOGSYNC_LOCK(log, flags) spin_lock_irqsave(&(log)->synclock, flags)\n#define LOGSYNC_UNLOCK(log, flags) \\\n\tspin_unlock_irqrestore(&(log)->synclock, flags)\n\n \n#define logdiff(diff, lsn, log)\\\n{\\\n\tdiff = (lsn) - (log)->syncpt;\\\n\tif (diff < 0)\\\n\t\tdiff += (log)->logsize;\\\n}\n\nextern int lmLogOpen(struct super_block *sb);\nextern int lmLogClose(struct super_block *sb);\nextern int lmLogShutdown(struct jfs_log * log);\nextern int lmLogInit(struct jfs_log * log);\nextern int lmLogFormat(struct jfs_log *log, s64 logAddress, int logSize);\nextern int lmGroupCommit(struct jfs_log *, struct tblock *);\nextern int jfsIOWait(void *);\nextern void jfs_flush_journal(struct jfs_log * log, int wait);\nextern void jfs_syncpt(struct jfs_log *log, int hard_sync);\n\n#endif\t\t\t\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}