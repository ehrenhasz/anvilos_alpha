{
  "module_name": "jfs_metapage.c",
  "hash_id": "0abefcb5f45f93e880fe86309578481748134d0a554eb372136e102df03b6acd",
  "original_prompt": "Ingested from linux-6.6.14/fs/jfs/jfs_metapage.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/buffer_head.h>\n#include <linux/mempool.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include \"jfs_incore.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_debug.h\"\n\n#ifdef CONFIG_JFS_STATISTICS\nstatic struct {\n\tuint\tpagealloc;\t \n\tuint\tpagefree;\t \n\tuint\tlockwait;\t \n} mpStat;\n#endif\n\n#define metapage_locked(mp) test_bit(META_locked, &(mp)->flag)\n#define trylock_metapage(mp) test_and_set_bit_lock(META_locked, &(mp)->flag)\n\nstatic inline void unlock_metapage(struct metapage *mp)\n{\n\tclear_bit_unlock(META_locked, &mp->flag);\n\twake_up(&mp->wait);\n}\n\nstatic inline void __lock_metapage(struct metapage *mp)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\tINCREMENT(mpStat.lockwait);\n\tadd_wait_queue_exclusive(&mp->wait, &wait);\n\tdo {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (metapage_locked(mp)) {\n\t\t\tunlock_page(mp->page);\n\t\t\tio_schedule();\n\t\t\tlock_page(mp->page);\n\t\t}\n\t} while (trylock_metapage(mp));\n\t__set_current_state(TASK_RUNNING);\n\tremove_wait_queue(&mp->wait, &wait);\n}\n\n \nstatic inline void lock_metapage(struct metapage *mp)\n{\n\tif (trylock_metapage(mp))\n\t\t__lock_metapage(mp);\n}\n\n#define METAPOOL_MIN_PAGES 32\nstatic struct kmem_cache *metapage_cache;\nstatic mempool_t *metapage_mempool;\n\n#define MPS_PER_PAGE (PAGE_SIZE >> L2PSIZE)\n\n#if MPS_PER_PAGE > 1\n\nstruct meta_anchor {\n\tint mp_count;\n\tatomic_t io_count;\n\tstruct metapage *mp[MPS_PER_PAGE];\n};\n#define mp_anchor(page) ((struct meta_anchor *)page_private(page))\n\nstatic inline struct metapage *page_to_mp(struct page *page, int offset)\n{\n\tif (!PagePrivate(page))\n\t\treturn NULL;\n\treturn mp_anchor(page)->mp[offset >> L2PSIZE];\n}\n\nstatic inline int insert_metapage(struct page *page, struct metapage *mp)\n{\n\tstruct meta_anchor *a;\n\tint index;\n\tint l2mp_blocks;\t \n\n\tif (PagePrivate(page))\n\t\ta = mp_anchor(page);\n\telse {\n\t\ta = kzalloc(sizeof(struct meta_anchor), GFP_NOFS);\n\t\tif (!a)\n\t\t\treturn -ENOMEM;\n\t\tset_page_private(page, (unsigned long)a);\n\t\tSetPagePrivate(page);\n\t\tkmap(page);\n\t}\n\n\tif (mp) {\n\t\tl2mp_blocks = L2PSIZE - page->mapping->host->i_blkbits;\n\t\tindex = (mp->index >> l2mp_blocks) & (MPS_PER_PAGE - 1);\n\t\ta->mp_count++;\n\t\ta->mp[index] = mp;\n\t}\n\n\treturn 0;\n}\n\nstatic inline void remove_metapage(struct page *page, struct metapage *mp)\n{\n\tstruct meta_anchor *a = mp_anchor(page);\n\tint l2mp_blocks = L2PSIZE - page->mapping->host->i_blkbits;\n\tint index;\n\n\tindex = (mp->index >> l2mp_blocks) & (MPS_PER_PAGE - 1);\n\n\tBUG_ON(a->mp[index] != mp);\n\n\ta->mp[index] = NULL;\n\tif (--a->mp_count == 0) {\n\t\tkfree(a);\n\t\tset_page_private(page, 0);\n\t\tClearPagePrivate(page);\n\t\tkunmap(page);\n\t}\n}\n\nstatic inline void inc_io(struct page *page)\n{\n\tatomic_inc(&mp_anchor(page)->io_count);\n}\n\nstatic inline void dec_io(struct page *page, void (*handler) (struct page *))\n{\n\tif (atomic_dec_and_test(&mp_anchor(page)->io_count))\n\t\thandler(page);\n}\n\n#else\nstatic inline struct metapage *page_to_mp(struct page *page, int offset)\n{\n\treturn PagePrivate(page) ? (struct metapage *)page_private(page) : NULL;\n}\n\nstatic inline int insert_metapage(struct page *page, struct metapage *mp)\n{\n\tif (mp) {\n\t\tset_page_private(page, (unsigned long)mp);\n\t\tSetPagePrivate(page);\n\t\tkmap(page);\n\t}\n\treturn 0;\n}\n\nstatic inline void remove_metapage(struct page *page, struct metapage *mp)\n{\n\tset_page_private(page, 0);\n\tClearPagePrivate(page);\n\tkunmap(page);\n}\n\n#define inc_io(page) do {} while(0)\n#define dec_io(page, handler) handler(page)\n\n#endif\n\nstatic inline struct metapage *alloc_metapage(gfp_t gfp_mask)\n{\n\tstruct metapage *mp = mempool_alloc(metapage_mempool, gfp_mask);\n\n\tif (mp) {\n\t\tmp->lid = 0;\n\t\tmp->lsn = 0;\n\t\tmp->data = NULL;\n\t\tmp->clsn = 0;\n\t\tmp->log = NULL;\n\t\tinit_waitqueue_head(&mp->wait);\n\t}\n\treturn mp;\n}\n\nstatic inline void free_metapage(struct metapage *mp)\n{\n\tmempool_free(mp, metapage_mempool);\n}\n\nint __init metapage_init(void)\n{\n\t \n\tmetapage_cache = kmem_cache_create(\"jfs_mp\", sizeof(struct metapage),\n\t\t\t\t\t   0, 0, NULL);\n\tif (metapage_cache == NULL)\n\t\treturn -ENOMEM;\n\n\tmetapage_mempool = mempool_create_slab_pool(METAPOOL_MIN_PAGES,\n\t\t\t\t\t\t    metapage_cache);\n\n\tif (metapage_mempool == NULL) {\n\t\tkmem_cache_destroy(metapage_cache);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nvoid metapage_exit(void)\n{\n\tmempool_destroy(metapage_mempool);\n\tkmem_cache_destroy(metapage_cache);\n}\n\nstatic inline void drop_metapage(struct page *page, struct metapage *mp)\n{\n\tif (mp->count || mp->nohomeok || test_bit(META_dirty, &mp->flag) ||\n\t    test_bit(META_io, &mp->flag))\n\t\treturn;\n\tremove_metapage(page, mp);\n\tINCREMENT(mpStat.pagefree);\n\tfree_metapage(mp);\n}\n\n \n\nstatic sector_t metapage_get_blocks(struct inode *inode, sector_t lblock,\n\t\t\t\t    int *len)\n{\n\tint rc = 0;\n\tint xflag;\n\ts64 xaddr;\n\tsector_t file_blocks = (inode->i_size + inode->i_sb->s_blocksize - 1) >>\n\t\t\t       inode->i_blkbits;\n\n\tif (lblock >= file_blocks)\n\t\treturn 0;\n\tif (lblock + *len > file_blocks)\n\t\t*len = file_blocks - lblock;\n\n\tif (inode->i_ino) {\n\t\trc = xtLookup(inode, (s64)lblock, *len, &xflag, &xaddr, len, 0);\n\t\tif ((rc == 0) && *len)\n\t\t\tlblock = (sector_t)xaddr;\n\t\telse\n\t\t\tlblock = 0;\n\t}  \n\n\treturn lblock;\n}\n\nstatic void last_read_complete(struct page *page)\n{\n\tif (!PageError(page))\n\t\tSetPageUptodate(page);\n\tunlock_page(page);\n}\n\nstatic void metapage_read_end_io(struct bio *bio)\n{\n\tstruct page *page = bio->bi_private;\n\n\tif (bio->bi_status) {\n\t\tprintk(KERN_ERR \"metapage_read_end_io: I/O error\\n\");\n\t\tSetPageError(page);\n\t}\n\n\tdec_io(page, last_read_complete);\n\tbio_put(bio);\n}\n\nstatic void remove_from_logsync(struct metapage *mp)\n{\n\tstruct jfs_log *log = mp->log;\n\tunsigned long flags;\n \n\tif (!log)\n\t\treturn;\n\n\tLOGSYNC_LOCK(log, flags);\n\tif (mp->lsn) {\n\t\tmp->log = NULL;\n\t\tmp->lsn = 0;\n\t\tmp->clsn = 0;\n\t\tlog->count--;\n\t\tlist_del(&mp->synclist);\n\t}\n\tLOGSYNC_UNLOCK(log, flags);\n}\n\nstatic void last_write_complete(struct page *page)\n{\n\tstruct metapage *mp;\n\tunsigned int offset;\n\n\tfor (offset = 0; offset < PAGE_SIZE; offset += PSIZE) {\n\t\tmp = page_to_mp(page, offset);\n\t\tif (mp && test_bit(META_io, &mp->flag)) {\n\t\t\tif (mp->lsn)\n\t\t\t\tremove_from_logsync(mp);\n\t\t\tclear_bit(META_io, &mp->flag);\n\t\t}\n\t\t \n\t}\n\tend_page_writeback(page);\n}\n\nstatic void metapage_write_end_io(struct bio *bio)\n{\n\tstruct page *page = bio->bi_private;\n\n\tBUG_ON(!PagePrivate(page));\n\n\tif (bio->bi_status) {\n\t\tprintk(KERN_ERR \"metapage_write_end_io: I/O error\\n\");\n\t\tSetPageError(page);\n\t}\n\tdec_io(page, last_write_complete);\n\tbio_put(bio);\n}\n\nstatic int metapage_writepage(struct page *page, struct writeback_control *wbc)\n{\n\tstruct bio *bio = NULL;\n\tint block_offset;\t \n\tstruct inode *inode = page->mapping->host;\n\tint blocks_per_mp = JFS_SBI(inode->i_sb)->nbperpage;\n\tint len;\n\tint xlen;\n\tstruct metapage *mp;\n\tint redirty = 0;\n\tsector_t lblock;\n\tint nr_underway = 0;\n\tsector_t pblock;\n\tsector_t next_block = 0;\n\tsector_t page_start;\n\tunsigned long bio_bytes = 0;\n\tunsigned long bio_offset = 0;\n\tint offset;\n\tint bad_blocks = 0;\n\n\tpage_start = (sector_t)page->index <<\n\t\t     (PAGE_SHIFT - inode->i_blkbits);\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(PageWriteback(page));\n\tset_page_writeback(page);\n\n\tfor (offset = 0; offset < PAGE_SIZE; offset += PSIZE) {\n\t\tmp = page_to_mp(page, offset);\n\n\t\tif (!mp || !test_bit(META_dirty, &mp->flag))\n\t\t\tcontinue;\n\n\t\tif (mp->nohomeok && !test_bit(META_forcewrite, &mp->flag)) {\n\t\t\tredirty = 1;\n\t\t\t \n\t\t\tif (mp->log && !(mp->log->cflag & logGC_PAGEOUT))\n\t\t\t\tjfs_flush_journal(mp->log, 0);\n\t\t\tcontinue;\n\t\t}\n\n\t\tclear_bit(META_dirty, &mp->flag);\n\t\tset_bit(META_io, &mp->flag);\n\t\tblock_offset = offset >> inode->i_blkbits;\n\t\tlblock = page_start + block_offset;\n\t\tif (bio) {\n\t\t\tif (xlen && lblock == next_block) {\n\t\t\t\t \n\t\t\t\tlen = min(xlen, blocks_per_mp);\n\t\t\t\txlen -= len;\n\t\t\t\tbio_bytes += len << inode->i_blkbits;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t \n\t\t\tif (bio_add_page(bio, page, bio_bytes, bio_offset) <\n\t\t\t    bio_bytes)\n\t\t\t\tgoto add_failed;\n\t\t\t \n\t\t\tinc_io(page);\n\t\t\tif (!bio->bi_iter.bi_size)\n\t\t\t\tgoto dump_bio;\n\t\t\tsubmit_bio(bio);\n\t\t\tnr_underway++;\n\t\t\tbio = NULL;\n\t\t} else\n\t\t\tinc_io(page);\n\t\txlen = (PAGE_SIZE - offset) >> inode->i_blkbits;\n\t\tpblock = metapage_get_blocks(inode, lblock, &xlen);\n\t\tif (!pblock) {\n\t\t\tprintk(KERN_ERR \"JFS: metapage_get_blocks failed\\n\");\n\t\t\t \n\t\t\tbad_blocks++;\n\t\t\tcontinue;\n\t\t}\n\t\tlen = min(xlen, (int)JFS_SBI(inode->i_sb)->nbperpage);\n\n\t\tbio = bio_alloc(inode->i_sb->s_bdev, 1, REQ_OP_WRITE, GFP_NOFS);\n\t\tbio->bi_iter.bi_sector = pblock << (inode->i_blkbits - 9);\n\t\tbio->bi_end_io = metapage_write_end_io;\n\t\tbio->bi_private = page;\n\n\t\t \n\t\tbio_offset = offset;\n\t\tbio_bytes = len << inode->i_blkbits;\n\n\t\txlen -= len;\n\t\tnext_block = lblock + len;\n\t}\n\tif (bio) {\n\t\tif (bio_add_page(bio, page, bio_bytes, bio_offset) < bio_bytes)\n\t\t\t\tgoto add_failed;\n\t\tif (!bio->bi_iter.bi_size)\n\t\t\tgoto dump_bio;\n\n\t\tsubmit_bio(bio);\n\t\tnr_underway++;\n\t}\n\tif (redirty)\n\t\tredirty_page_for_writepage(wbc, page);\n\n\tunlock_page(page);\n\n\tif (bad_blocks)\n\t\tgoto err_out;\n\n\tif (nr_underway == 0)\n\t\tend_page_writeback(page);\n\n\treturn 0;\nadd_failed:\n\t \n\tprintk(KERN_ERR \"JFS: bio_add_page failed unexpectedly\\n\");\n\tgoto skip;\ndump_bio:\n\tprint_hex_dump(KERN_ERR, \"JFS: dump of bio: \", DUMP_PREFIX_ADDRESS, 16,\n\t\t       4, bio, sizeof(*bio), 0);\nskip:\n\tbio_put(bio);\n\tunlock_page(page);\n\tdec_io(page, last_write_complete);\nerr_out:\n\twhile (bad_blocks--)\n\t\tdec_io(page, last_write_complete);\n\treturn -EIO;\n}\n\nstatic int metapage_read_folio(struct file *fp, struct folio *folio)\n{\n\tstruct page *page = &folio->page;\n\tstruct inode *inode = page->mapping->host;\n\tstruct bio *bio = NULL;\n\tint block_offset;\n\tint blocks_per_page = i_blocks_per_page(inode, page);\n\tsector_t page_start;\t \n\tsector_t pblock;\n\tint xlen;\n\tunsigned int len;\n\tint offset;\n\n\tBUG_ON(!PageLocked(page));\n\tpage_start = (sector_t)page->index <<\n\t\t     (PAGE_SHIFT - inode->i_blkbits);\n\n\tblock_offset = 0;\n\twhile (block_offset < blocks_per_page) {\n\t\txlen = blocks_per_page - block_offset;\n\t\tpblock = metapage_get_blocks(inode, page_start + block_offset,\n\t\t\t\t\t     &xlen);\n\t\tif (pblock) {\n\t\t\tif (!PagePrivate(page))\n\t\t\t\tinsert_metapage(page, NULL);\n\t\t\tinc_io(page);\n\t\t\tif (bio)\n\t\t\t\tsubmit_bio(bio);\n\n\t\t\tbio = bio_alloc(inode->i_sb->s_bdev, 1, REQ_OP_READ,\n\t\t\t\t\tGFP_NOFS);\n\t\t\tbio->bi_iter.bi_sector =\n\t\t\t\tpblock << (inode->i_blkbits - 9);\n\t\t\tbio->bi_end_io = metapage_read_end_io;\n\t\t\tbio->bi_private = page;\n\t\t\tlen = xlen << inode->i_blkbits;\n\t\t\toffset = block_offset << inode->i_blkbits;\n\t\t\tif (bio_add_page(bio, page, len, offset) < len)\n\t\t\t\tgoto add_failed;\n\t\t\tblock_offset += xlen;\n\t\t} else\n\t\t\tblock_offset++;\n\t}\n\tif (bio)\n\t\tsubmit_bio(bio);\n\telse\n\t\tunlock_page(page);\n\n\treturn 0;\n\nadd_failed:\n\tprintk(KERN_ERR \"JFS: bio_add_page failed unexpectedly\\n\");\n\tbio_put(bio);\n\tdec_io(page, last_read_complete);\n\treturn -EIO;\n}\n\nstatic bool metapage_release_folio(struct folio *folio, gfp_t gfp_mask)\n{\n\tstruct metapage *mp;\n\tbool ret = true;\n\tint offset;\n\n\tfor (offset = 0; offset < PAGE_SIZE; offset += PSIZE) {\n\t\tmp = page_to_mp(&folio->page, offset);\n\n\t\tif (!mp)\n\t\t\tcontinue;\n\n\t\tjfs_info(\"metapage_release_folio: mp = 0x%p\", mp);\n\t\tif (mp->count || mp->nohomeok ||\n\t\t    test_bit(META_dirty, &mp->flag)) {\n\t\t\tjfs_info(\"count = %ld, nohomeok = %d\", mp->count,\n\t\t\t\t mp->nohomeok);\n\t\t\tret = false;\n\t\t\tcontinue;\n\t\t}\n\t\tif (mp->lsn)\n\t\t\tremove_from_logsync(mp);\n\t\tremove_metapage(&folio->page, mp);\n\t\tINCREMENT(mpStat.pagefree);\n\t\tfree_metapage(mp);\n\t}\n\treturn ret;\n}\n\nstatic void metapage_invalidate_folio(struct folio *folio, size_t offset,\n\t\t\t\t    size_t length)\n{\n\tBUG_ON(offset || length < folio_size(folio));\n\n\tBUG_ON(folio_test_writeback(folio));\n\n\tmetapage_release_folio(folio, 0);\n}\n\nconst struct address_space_operations jfs_metapage_aops = {\n\t.read_folio\t= metapage_read_folio,\n\t.writepage\t= metapage_writepage,\n\t.release_folio\t= metapage_release_folio,\n\t.invalidate_folio = metapage_invalidate_folio,\n\t.dirty_folio\t= filemap_dirty_folio,\n};\n\nstruct metapage *__get_metapage(struct inode *inode, unsigned long lblock,\n\t\t\t\tunsigned int size, int absolute,\n\t\t\t\tunsigned long new)\n{\n\tint l2BlocksPerPage;\n\tint l2bsize;\n\tstruct address_space *mapping;\n\tstruct metapage *mp = NULL;\n\tstruct page *page;\n\tunsigned long page_index;\n\tunsigned long page_offset;\n\n\tjfs_info(\"__get_metapage: ino = %ld, lblock = 0x%lx, abs=%d\",\n\t\t inode->i_ino, lblock, absolute);\n\n\tl2bsize = inode->i_blkbits;\n\tl2BlocksPerPage = PAGE_SHIFT - l2bsize;\n\tpage_index = lblock >> l2BlocksPerPage;\n\tpage_offset = (lblock - (page_index << l2BlocksPerPage)) << l2bsize;\n\tif ((page_offset + size) > PAGE_SIZE) {\n\t\tjfs_err(\"MetaData crosses page boundary!!\");\n\t\tjfs_err(\"lblock = %lx, size  = %d\", lblock, size);\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\tif (absolute)\n\t\tmapping = JFS_SBI(inode->i_sb)->direct_inode->i_mapping;\n\telse {\n\t\t \n\t\tif ((lblock << inode->i_blkbits) >= inode->i_size)\n\t\t\treturn NULL;\n\t\tmapping = inode->i_mapping;\n\t}\n\n\tif (new && (PSIZE == PAGE_SIZE)) {\n\t\tpage = grab_cache_page(mapping, page_index);\n\t\tif (!page) {\n\t\t\tjfs_err(\"grab_cache_page failed!\");\n\t\t\treturn NULL;\n\t\t}\n\t\tSetPageUptodate(page);\n\t} else {\n\t\tpage = read_mapping_page(mapping, page_index, NULL);\n\t\tif (IS_ERR(page)) {\n\t\t\tjfs_err(\"read_mapping_page failed!\");\n\t\t\treturn NULL;\n\t\t}\n\t\tlock_page(page);\n\t}\n\n\tmp = page_to_mp(page, page_offset);\n\tif (mp) {\n\t\tif (mp->logical_size != size) {\n\t\t\tjfs_error(inode->i_sb,\n\t\t\t\t  \"get_mp->logical_size != size\\n\");\n\t\t\tjfs_err(\"logical_size = %d, size = %d\",\n\t\t\t\tmp->logical_size, size);\n\t\t\tdump_stack();\n\t\t\tgoto unlock;\n\t\t}\n\t\tmp->count++;\n\t\tlock_metapage(mp);\n\t\tif (test_bit(META_discard, &mp->flag)) {\n\t\t\tif (!new) {\n\t\t\t\tjfs_error(inode->i_sb,\n\t\t\t\t\t  \"using a discarded metapage\\n\");\n\t\t\t\tdiscard_metapage(mp);\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t\tclear_bit(META_discard, &mp->flag);\n\t\t}\n\t} else {\n\t\tINCREMENT(mpStat.pagealloc);\n\t\tmp = alloc_metapage(GFP_NOFS);\n\t\tif (!mp)\n\t\t\tgoto unlock;\n\t\tmp->page = page;\n\t\tmp->sb = inode->i_sb;\n\t\tmp->flag = 0;\n\t\tmp->xflag = COMMIT_PAGE;\n\t\tmp->count = 1;\n\t\tmp->nohomeok = 0;\n\t\tmp->logical_size = size;\n\t\tmp->data = page_address(page) + page_offset;\n\t\tmp->index = lblock;\n\t\tif (unlikely(insert_metapage(page, mp))) {\n\t\t\tfree_metapage(mp);\n\t\t\tgoto unlock;\n\t\t}\n\t\tlock_metapage(mp);\n\t}\n\n\tif (new) {\n\t\tjfs_info(\"zeroing mp = 0x%p\", mp);\n\t\tmemset(mp->data, 0, PSIZE);\n\t}\n\n\tunlock_page(page);\n\tjfs_info(\"__get_metapage: returning = 0x%p data = 0x%p\", mp, mp->data);\n\treturn mp;\n\nunlock:\n\tunlock_page(page);\n\treturn NULL;\n}\n\nvoid grab_metapage(struct metapage * mp)\n{\n\tjfs_info(\"grab_metapage: mp = 0x%p\", mp);\n\tget_page(mp->page);\n\tlock_page(mp->page);\n\tmp->count++;\n\tlock_metapage(mp);\n\tunlock_page(mp->page);\n}\n\nstatic int metapage_write_one(struct page *page)\n{\n\tstruct folio *folio = page_folio(page);\n\tstruct address_space *mapping = folio->mapping;\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = WB_SYNC_ALL,\n\t\t.nr_to_write = folio_nr_pages(folio),\n\t};\n\tint ret = 0;\n\n\tBUG_ON(!folio_test_locked(folio));\n\n\tfolio_wait_writeback(folio);\n\n\tif (folio_clear_dirty_for_io(folio)) {\n\t\tfolio_get(folio);\n\t\tret = metapage_writepage(page, &wbc);\n\t\tif (ret == 0)\n\t\t\tfolio_wait_writeback(folio);\n\t\tfolio_put(folio);\n\t} else {\n\t\tfolio_unlock(folio);\n\t}\n\n\tif (!ret)\n\t\tret = filemap_check_errors(mapping);\n\treturn ret;\n}\n\nvoid force_metapage(struct metapage *mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"force_metapage: mp = 0x%p\", mp);\n\tset_bit(META_forcewrite, &mp->flag);\n\tclear_bit(META_sync, &mp->flag);\n\tget_page(page);\n\tlock_page(page);\n\tset_page_dirty(page);\n\tif (metapage_write_one(page))\n\t\tjfs_error(mp->sb, \"metapage_write_one() failed\\n\");\n\tclear_bit(META_forcewrite, &mp->flag);\n\tput_page(page);\n}\n\nvoid hold_metapage(struct metapage *mp)\n{\n\tlock_page(mp->page);\n}\n\nvoid put_metapage(struct metapage *mp)\n{\n\tif (mp->count || mp->nohomeok) {\n\t\t \n\t\tunlock_page(mp->page);\n\t\treturn;\n\t}\n\tget_page(mp->page);\n\tmp->count++;\n\tlock_metapage(mp);\n\tunlock_page(mp->page);\n\trelease_metapage(mp);\n}\n\nvoid release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\tif (metapage_write_one(page))\n\t\t\t\tjfs_error(mp->sb, \"metapage_write_one() failed\\n\");\n\t\t\tlock_page(page);\n\t\t}\n\t} else if (mp->lsn)\t \n\t\tremove_from_logsync(mp);\n\n\t \n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tput_page(page);\n}\n\nvoid __invalidate_metapages(struct inode *ip, s64 addr, int len)\n{\n\tsector_t lblock;\n\tint l2BlocksPerPage = PAGE_SHIFT - ip->i_blkbits;\n\tint BlocksPerPage = 1 << l2BlocksPerPage;\n\t \n\tstruct address_space *mapping =\n\t\tJFS_SBI(ip->i_sb)->direct_inode->i_mapping;\n\tstruct metapage *mp;\n\tstruct page *page;\n\tunsigned int offset;\n\n\t \n\tfor (lblock = addr & ~(BlocksPerPage - 1); lblock < addr + len;\n\t     lblock += BlocksPerPage) {\n\t\tpage = find_lock_page(mapping, lblock >> l2BlocksPerPage);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tfor (offset = 0; offset < PAGE_SIZE; offset += PSIZE) {\n\t\t\tmp = page_to_mp(page, offset);\n\t\t\tif (!mp)\n\t\t\t\tcontinue;\n\t\t\tif (mp->index < addr)\n\t\t\t\tcontinue;\n\t\t\tif (mp->index >= addr + len)\n\t\t\t\tbreak;\n\n\t\t\tclear_bit(META_dirty, &mp->flag);\n\t\t\tset_bit(META_discard, &mp->flag);\n\t\t\tif (mp->lsn)\n\t\t\t\tremove_from_logsync(mp);\n\t\t}\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t}\n}\n\n#ifdef CONFIG_JFS_STATISTICS\nint jfs_mpstat_proc_show(struct seq_file *m, void *v)\n{\n\tseq_printf(m,\n\t\t       \"JFS Metapage statistics\\n\"\n\t\t       \"=======================\\n\"\n\t\t       \"page allocations = %d\\n\"\n\t\t       \"page frees = %d\\n\"\n\t\t       \"lock waits = %d\\n\",\n\t\t       mpStat.pagealloc,\n\t\t       mpStat.pagefree,\n\t\t       mpStat.lockwait);\n\treturn 0;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}