{
  "module_name": "jfs_logmgr.c",
  "hash_id": "363cf2d9d17517770cc14b7fffb75dc7849213ca1b7ba414f4890842337a2507",
  "original_prompt": "Ingested from linux-6.6.14/fs/jfs/jfs_logmgr.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/fs.h>\n#include <linux/blkdev.h>\n#include <linux/interrupt.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/buffer_head.h>\t\t \n#include <linux/bio.h>\n#include <linux/freezer.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include \"jfs_incore.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_debug.h\"\n\n\n \nstatic struct lbuf *log_redrive_list;\nstatic DEFINE_SPINLOCK(log_redrive_lock);\n\n\n \n#define LOG_LOCK_INIT(log)\tmutex_init(&(log)->loglock)\n#define LOG_LOCK(log)\t\tmutex_lock(&((log)->loglock))\n#define LOG_UNLOCK(log)\t\tmutex_unlock(&((log)->loglock))\n\n\n \n\n#define LOGGC_LOCK_INIT(log)\tspin_lock_init(&(log)->gclock)\n#define LOGGC_LOCK(log)\t\tspin_lock_irq(&(log)->gclock)\n#define LOGGC_UNLOCK(log)\tspin_unlock_irq(&(log)->gclock)\n#define LOGGC_WAKEUP(tblk)\twake_up_all(&(tblk)->gcwait)\n\n \n#define\tLOGSYNC_DELTA(logsize)\t\tmin((logsize)/8, 128*LOGPSIZE)\n#define\tLOGSYNC_BARRIER(logsize)\t((logsize)/4)\n \n\n\n \nstatic DEFINE_SPINLOCK(jfsLCacheLock);\n\n#define\tLCACHE_LOCK(flags)\tspin_lock_irqsave(&jfsLCacheLock, flags)\n#define\tLCACHE_UNLOCK(flags)\tspin_unlock_irqrestore(&jfsLCacheLock, flags)\n\n \n#define LCACHE_SLEEP_COND(wq, cond, flags)\t\\\ndo {\t\t\t\t\t\t\\\n\tif (cond)\t\t\t\t\\\n\t\tbreak;\t\t\t\t\\\n\t__SLEEP_COND(wq, cond, LCACHE_LOCK(flags), LCACHE_UNLOCK(flags)); \\\n} while (0)\n\n#define\tLCACHE_WAKEUP(event)\twake_up(event)\n\n\n \n \n#define\tlbmREAD\t\t0x0001\n#define\tlbmWRITE\t0x0002\t \n#define\tlbmRELEASE\t0x0004\t \n#define\tlbmSYNC\t\t0x0008\t \n#define lbmFREE\t\t0x0010\t \n#define\tlbmDONE\t\t0x0020\n#define\tlbmERROR\t0x0040\n#define lbmGC\t\t0x0080\t \n#define lbmDIRECT\t0x0100\n\n \nstatic LIST_HEAD(jfs_external_logs);\nstatic struct jfs_log *dummy_log;\nstatic DEFINE_MUTEX(jfs_log_mutex);\n\n \nstatic int lmWriteRecord(struct jfs_log * log, struct tblock * tblk,\n\t\t\t struct lrd * lrd, struct tlock * tlck);\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lmLogFileSystem(struct jfs_log * log, struct jfs_sb_info *sbi,\n\t\t\t   int activate);\n\nstatic int open_inline_log(struct super_block *sb);\nstatic int open_dummy_log(struct super_block *sb);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic int lbmRead(struct jfs_log * log, int pn, struct lbuf ** bpp);\nstatic void lbmWrite(struct jfs_log * log, struct lbuf * bp, int flag, int cant_block);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\nstatic bio_end_io_t lbmIODone;\nstatic void lbmStartIO(struct lbuf * bp);\nstatic void lmGCwrite(struct jfs_log * log, int cant_block);\nstatic int lmLogSync(struct jfs_log * log, int hard_sync);\n\n\n\n \n#ifdef CONFIG_JFS_STATISTICS\nstatic struct lmStat {\n\tuint commit;\t\t \n\tuint pagedone;\t\t \n\tuint submitted;\t\t \n\tuint full_page;\t\t \n\tuint partial_page;\t \n} lmStat;\n#endif\n\nstatic void write_special_inodes(struct jfs_log *log,\n\t\t\t\t int (*writer)(struct address_space *))\n{\n\tstruct jfs_sb_info *sbi;\n\n\tlist_for_each_entry(sbi, &log->sb_list, log_list) {\n\t\twriter(sbi->ipbmap->i_mapping);\n\t\twriter(sbi->ipimap->i_mapping);\n\t\twriter(sbi->direct_inode->i_mapping);\n\t}\n}\n\n \nint lmLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t  struct tlock * tlck)\n{\n\tint lsn;\n\tint diffp, difft;\n\tstruct metapage *mp = NULL;\n\tunsigned long flags;\n\n\tjfs_info(\"lmLog: log:0x%p tblk:0x%p, lrd:0x%p tlck:0x%p\",\n\t\t log, tblk, lrd, tlck);\n\n\tLOG_LOCK(log);\n\n\t \n\tif (tblk == NULL)\n\t\tgoto writeRecord;\n\n\t \n\tif (tlck == NULL ||\n\t    tlck->type & tlckBTROOT || (mp = tlck->mp) == NULL)\n\t\tgoto writeRecord;\n\n\t \n\tlsn = log->lsn;\n\n\tLOGSYNC_LOCK(log, flags);\n\n\t \n\tif (mp->lsn == 0) {\n\t\tmp->log = log;\n\t\tmp->lsn = lsn;\n\t\tlog->count++;\n\n\t\t \n\t\tlist_add_tail(&mp->synclist, &log->synclist);\n\t}\n\n\t \n\t \n\tif (tblk->lsn == 0) {\n\t\t \n\t\ttblk->lsn = mp->lsn;\n\t\tlog->count++;\n\n\t\t \n\t\tlist_add(&tblk->synclist, &mp->synclist);\n\t}\n\t \n\telse {\n\t\t \n\t\tlogdiff(diffp, mp->lsn, log);\n\t\tlogdiff(difft, tblk->lsn, log);\n\t\tif (diffp < difft) {\n\t\t\t \n\t\t\ttblk->lsn = mp->lsn;\n\n\t\t\t \n\t\t\tlist_move(&tblk->synclist, &mp->synclist);\n\t\t}\n\t}\n\n\tLOGSYNC_UNLOCK(log, flags);\n\n\t \n      writeRecord:\n\tlsn = lmWriteRecord(log, tblk, lrd, tlck);\n\n\t \n\tlogdiff(diffp, lsn, log);\n\tif (diffp >= log->nextsync)\n\t\tlsn = lmLogSync(log, 0);\n\n\t \n\tlog->lsn = lsn;\n\n\tLOG_UNLOCK(log);\n\n\t \n\treturn lsn;\n}\n\n \nstatic int\nlmWriteRecord(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t      struct tlock * tlck)\n{\n\tint lsn = 0;\t\t \n\tstruct lbuf *bp;\t \n\tstruct logpage *lp;\t \n\tcaddr_t dst;\t\t \n\tint dstoffset;\t\t \n\tint freespace;\t\t \n\tcaddr_t p;\t\t \n\tcaddr_t src;\n\tint srclen;\n\tint nbytes;\t\t \n\tint i;\n\tint len;\n\tstruct linelock *linelock;\n\tstruct lv *lv;\n\tstruct lvd *lvd;\n\tint l2linesize;\n\n\tlen = 0;\n\n\t \n\tbp = (struct lbuf *) log->bp;\n\tlp = (struct logpage *) bp->l_ldata;\n\tdstoffset = log->eor;\n\n\t \n\tif (tlck == NULL)\n\t\tgoto moveLrd;\n\n\t \n\t \n\tif (tlck->flag & tlckPAGELOCK) {\n\t\tp = (caddr_t) (tlck->mp->data);\n\t\tlinelock = (struct linelock *) & tlck->lock;\n\t}\n\t \n\telse if (tlck->flag & tlckINODELOCK) {\n\t\tif (tlck->type & tlckDTREE)\n\t\t\tp = (caddr_t) &JFS_IP(tlck->ip)->i_dtroot;\n\t\telse\n\t\t\tp = (caddr_t) &JFS_IP(tlck->ip)->i_xtroot;\n\t\tlinelock = (struct linelock *) & tlck->lock;\n\t}\n\telse {\n\t\tjfs_err(\"lmWriteRecord: UFO tlck:0x%p\", tlck);\n\t\treturn 0;\t \n\t}\n\tl2linesize = linelock->l2linesize;\n\n      moveData:\n\tASSERT(linelock->index <= linelock->maxcnt);\n\n\tlv = linelock->lv;\n\tfor (i = 0; i < linelock->index; i++, lv++) {\n\t\tif (lv->length == 0)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (dstoffset >= LOGPSIZE - LOGPTLRSIZE) {\n\t\t\t \n\t\t\tlmNextPage(log);\n\n\t\t\tbp = log->bp;\n\t\t\tlp = (struct logpage *) bp->l_ldata;\n\t\t\tdstoffset = LOGPHDRSIZE;\n\t\t}\n\n\t\t \n\t\tsrc = (u8 *) p + (lv->offset << l2linesize);\n\t\tsrclen = lv->length << l2linesize;\n\t\tlen += srclen;\n\t\twhile (srclen > 0) {\n\t\t\tfreespace = (LOGPSIZE - LOGPTLRSIZE) - dstoffset;\n\t\t\tnbytes = min(freespace, srclen);\n\t\t\tdst = (caddr_t) lp + dstoffset;\n\t\t\tmemcpy(dst, src, nbytes);\n\t\t\tdstoffset += nbytes;\n\n\t\t\t \n\t\t\tif (dstoffset < LOGPSIZE - LOGPTLRSIZE)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tlmNextPage(log);\n\n\t\t\tbp = (struct lbuf *) log->bp;\n\t\t\tlp = (struct logpage *) bp->l_ldata;\n\t\t\tdstoffset = LOGPHDRSIZE;\n\n\t\t\tsrclen -= nbytes;\n\t\t\tsrc += nbytes;\n\t\t}\n\n\t\t \n\t\tlen += 4;\n\t\tlvd = (struct lvd *) ((caddr_t) lp + dstoffset);\n\t\tlvd->offset = cpu_to_le16(lv->offset);\n\t\tlvd->length = cpu_to_le16(lv->length);\n\t\tdstoffset += 4;\n\t\tjfs_info(\"lmWriteRecord: lv offset:%d length:%d\",\n\t\t\t lv->offset, lv->length);\n\t}\n\n\tif ((i = linelock->next)) {\n\t\tlinelock = (struct linelock *) lid_to_tlock(i);\n\t\tgoto moveData;\n\t}\n\n\t \n      moveLrd:\n\tlrd->length = cpu_to_le16(len);\n\n\tsrc = (caddr_t) lrd;\n\tsrclen = LOGRDSIZE;\n\n\twhile (srclen > 0) {\n\t\tfreespace = (LOGPSIZE - LOGPTLRSIZE) - dstoffset;\n\t\tnbytes = min(freespace, srclen);\n\t\tdst = (caddr_t) lp + dstoffset;\n\t\tmemcpy(dst, src, nbytes);\n\n\t\tdstoffset += nbytes;\n\t\tsrclen -= nbytes;\n\n\t\t \n\t\tif (srclen)\n\t\t\tgoto pageFull;\n\n\t\t \n\n\t\t \n\t\tlog->eor = dstoffset;\n\t\tbp->l_eor = dstoffset;\n\t\tlsn = (log->page << L2LOGPSIZE) + dstoffset;\n\n\t\tif (lrd->type & cpu_to_le16(LOG_COMMIT)) {\n\t\t\ttblk->clsn = lsn;\n\t\t\tjfs_info(\"wr: tclsn:0x%x, beor:0x%x\", tblk->clsn,\n\t\t\t\t bp->l_eor);\n\n\t\t\tINCREMENT(lmStat.commit);\t \n\n\t\t\t \n\t\t\tLOGGC_LOCK(log);\n\n\t\t\t \n\t\t\ttblk->flag = tblkGC_QUEUE;\n\t\t\ttblk->bp = log->bp;\n\t\t\ttblk->pn = log->page;\n\t\t\ttblk->eor = log->eor;\n\n\t\t\t \n\t\t\tlist_add_tail(&tblk->cqueue, &log->cqueue);\n\n\t\t\tLOGGC_UNLOCK(log);\n\t\t}\n\n\t\tjfs_info(\"lmWriteRecord: lrd:0x%04x bp:0x%p pn:%d eor:0x%x\",\n\t\t\tle16_to_cpu(lrd->type), log->bp, log->page, dstoffset);\n\n\t\t \n\t\tif (dstoffset < LOGPSIZE - LOGPTLRSIZE)\n\t\t\treturn lsn;\n\n\t      pageFull:\n\t\t \n\t\tlmNextPage(log);\n\n\t\tbp = (struct lbuf *) log->bp;\n\t\tlp = (struct logpage *) bp->l_ldata;\n\t\tdstoffset = LOGPHDRSIZE;\n\t\tsrc += nbytes;\n\t}\n\n\treturn lsn;\n}\n\n\n \nstatic int lmNextPage(struct jfs_log * log)\n{\n\tstruct logpage *lp;\n\tint lspn;\t\t \n\tint pn;\t\t\t \n\tstruct lbuf *bp;\n\tstruct lbuf *nextbp;\n\tstruct tblock *tblk;\n\n\t \n\tpn = log->page;\n\tbp = log->bp;\n\tlp = (struct logpage *) bp->l_ldata;\n\tlspn = le32_to_cpu(lp->h.page);\n\n\tLOGGC_LOCK(log);\n\n\t \n\t \n\tif (list_empty(&log->cqueue))\n\t\ttblk = NULL;\n\telse\n\t\ttblk = list_entry(log->cqueue.prev, struct tblock, cqueue);\n\n\t \n\n\t \n\tif (tblk && tblk->pn == pn) {\n\t\t \n\t\ttblk->flag |= tblkGC_EOP;\n\n\t\tif (log->cflag & logGC_PAGEOUT) {\n\t\t\t \n\t\t\tif (bp->l_wqnext == NULL)\n\t\t\t\tlbmWrite(log, bp, 0, 0);\n\t\t} else {\n\t\t\t \n\t\t\tlog->cflag |= logGC_PAGEOUT;\n\t\t\tlmGCwrite(log, 0);\n\t\t}\n\t}\n\t \n\telse {\n\t\t \n\t\tbp->l_ceor = bp->l_eor;\n\t\tlp->h.eor = lp->t.eor = cpu_to_le16(bp->l_ceor);\n\t\tlbmWrite(log, bp, lbmWRITE | lbmRELEASE | lbmFREE, 0);\n\t}\n\tLOGGC_UNLOCK(log);\n\n\t \n\t \n\tlog->page = (pn == log->size - 1) ? 2 : pn + 1;\n\tlog->eor = LOGPHDRSIZE;\t \n\n\t \n\tnextbp = lbmAllocate(log, log->page);\n\tnextbp->l_eor = log->eor;\n\tlog->bp = nextbp;\n\n\t \n\tlp = (struct logpage *) nextbp->l_ldata;\n\tlp->h.page = lp->t.page = cpu_to_le32(lspn + 1);\n\tlp->h.eor = lp->t.eor = cpu_to_le16(LOGPHDRSIZE);\n\n\treturn 0;\n}\n\n\n \nint lmGroupCommit(struct jfs_log * log, struct tblock * tblk)\n{\n\tint rc = 0;\n\n\tLOGGC_LOCK(log);\n\n\t \n\tif (tblk->flag & tblkGC_COMMITTED) {\n\t\tif (tblk->flag & tblkGC_ERROR)\n\t\t\trc = -EIO;\n\n\t\tLOGGC_UNLOCK(log);\n\t\treturn rc;\n\t}\n\tjfs_info(\"lmGroup Commit: tblk = 0x%p, gcrtc = %d\", tblk, log->gcrtc);\n\n\tif (tblk->xflag & COMMIT_LAZY)\n\t\ttblk->flag |= tblkGC_LAZY;\n\n\tif ((!(log->cflag & logGC_PAGEOUT)) && (!list_empty(&log->cqueue)) &&\n\t    (!(tblk->xflag & COMMIT_LAZY) || test_bit(log_FLUSH, &log->flag)\n\t     || jfs_tlocks_low)) {\n\t\t \n\t\tlog->cflag |= logGC_PAGEOUT;\n\n\t\tlmGCwrite(log, 0);\n\t}\n\n\tif (tblk->xflag & COMMIT_LAZY) {\n\t\t \n\t\tLOGGC_UNLOCK(log);\n\t\treturn 0;\n\t}\n\n\t \n\n\tif (tblk->flag & tblkGC_COMMITTED) {\n\t\tif (tblk->flag & tblkGC_ERROR)\n\t\t\trc = -EIO;\n\n\t\tLOGGC_UNLOCK(log);\n\t\treturn rc;\n\t}\n\n\t \n\tlog->gcrtc++;\n\ttblk->flag |= tblkGC_READY;\n\n\t__SLEEP_COND(tblk->gcwait, (tblk->flag & tblkGC_COMMITTED),\n\t\t     LOGGC_LOCK(log), LOGGC_UNLOCK(log));\n\n\t \n\tif (tblk->flag & tblkGC_ERROR)\n\t\trc = -EIO;\n\n\tLOGGC_UNLOCK(log);\n\treturn rc;\n}\n\n \nstatic void lmGCwrite(struct jfs_log * log, int cant_write)\n{\n\tstruct lbuf *bp;\n\tstruct logpage *lp;\n\tint gcpn;\t\t \n\tstruct tblock *tblk;\n\tstruct tblock *xtblk = NULL;\n\n\t \n\t \n\tgcpn = list_entry(log->cqueue.next, struct tblock, cqueue)->pn;\n\n\tlist_for_each_entry(tblk, &log->cqueue, cqueue) {\n\t\tif (tblk->pn != gcpn)\n\t\t\tbreak;\n\n\t\txtblk = tblk;\n\n\t\t \n\t\ttblk->flag |= tblkGC_COMMIT;\n\t}\n\ttblk = xtblk;\t\t \n\n\t \n\tbp = (struct lbuf *) tblk->bp;\n\tlp = (struct logpage *) bp->l_ldata;\n\t \n\tif (tblk->flag & tblkGC_EOP) {\n\t\t \n\t\ttblk->flag &= ~tblkGC_EOP;\n\t\ttblk->flag |= tblkGC_FREE;\n\t\tbp->l_ceor = bp->l_eor;\n\t\tlp->h.eor = lp->t.eor = cpu_to_le16(bp->l_ceor);\n\t\tlbmWrite(log, bp, lbmWRITE | lbmRELEASE | lbmGC,\n\t\t\t cant_write);\n\t\tINCREMENT(lmStat.full_page);\n\t}\n\t \n\telse {\n\t\tbp->l_ceor = tblk->eor;\t \n\t\tlp->h.eor = lp->t.eor = cpu_to_le16(bp->l_ceor);\n\t\tlbmWrite(log, bp, lbmWRITE | lbmGC, cant_write);\n\t\tINCREMENT(lmStat.partial_page);\n\t}\n}\n\n \nstatic void lmPostGC(struct lbuf * bp)\n{\n\tunsigned long flags;\n\tstruct jfs_log *log = bp->l_log;\n\tstruct logpage *lp;\n\tstruct tblock *tblk, *temp;\n\n\t\n\tspin_lock_irqsave(&log->gclock, flags);\n\t \n\tlist_for_each_entry_safe(tblk, temp, &log->cqueue, cqueue) {\n\t\tif (!(tblk->flag & tblkGC_COMMIT))\n\t\t\tbreak;\n\t\t \n\n\t\tif (bp->l_flag & lbmERROR)\n\t\t\ttblk->flag |= tblkGC_ERROR;\n\n\t\t \n\t\tlist_del(&tblk->cqueue);\n\t\ttblk->flag &= ~tblkGC_QUEUE;\n\n\t\tif (tblk == log->flush_tblk) {\n\t\t\t \n\t\t\tclear_bit(log_FLUSH, &log->flag);\n\t\t\tlog->flush_tblk = NULL;\n\t\t}\n\n\t\tjfs_info(\"lmPostGC: tblk = 0x%p, flag = 0x%x\", tblk,\n\t\t\t tblk->flag);\n\n\t\tif (!(tblk->xflag & COMMIT_FORCE))\n\t\t\t \n\t\t\ttxLazyUnlock(tblk);\n\t\telse {\n\t\t\t \n\t\t\ttblk->flag |= tblkGC_COMMITTED;\n\n\t\t\tif (tblk->flag & tblkGC_READY)\n\t\t\t\tlog->gcrtc--;\n\n\t\t\tLOGGC_WAKEUP(tblk);\n\t\t}\n\n\t\t \n\t\tif (tblk->flag & tblkGC_FREE)\n\t\t\tlbmFree(bp);\n\t\t \n\t\telse if (tblk->flag & tblkGC_EOP) {\n\t\t\t \n\t\t\tlp = (struct logpage *) bp->l_ldata;\n\t\t\tbp->l_ceor = bp->l_eor;\n\t\t\tlp->h.eor = lp->t.eor = cpu_to_le16(bp->l_eor);\n\t\t\tjfs_info(\"lmPostGC: calling lbmWrite\");\n\t\t\tlbmWrite(log, bp, lbmWRITE | lbmRELEASE | lbmFREE,\n\t\t\t\t 1);\n\t\t}\n\n\t}\n\n\t \n\tif ((!list_empty(&log->cqueue)) &&\n\t    ((log->gcrtc > 0) || (tblk->bp->l_wqnext != NULL) ||\n\t     test_bit(log_FLUSH, &log->flag) || jfs_tlocks_low))\n\t\t \n\t\tlmGCwrite(log, 1);\n\n\t \n\telse\n\t\tlog->cflag &= ~logGC_PAGEOUT;\n\n\t\n\tspin_unlock_irqrestore(&log->gclock, flags);\n\treturn;\n}\n\n \nstatic int lmLogSync(struct jfs_log * log, int hard_sync)\n{\n\tint logsize;\n\tint written;\t\t \n\tint free;\t\t \n\tint delta;\t\t \n\tint more;\t\t \n\tstruct lrd lrd;\n\tint lsn;\n\tstruct logsyncblk *lp;\n\tunsigned long flags;\n\n\t \n\tif (hard_sync)\n\t\twrite_special_inodes(log, filemap_fdatawrite);\n\telse\n\t\twrite_special_inodes(log, filemap_flush);\n\n\t \n\t \n\n\tif (log->sync == log->syncpt) {\n\t\tLOGSYNC_LOCK(log, flags);\n\t\tif (list_empty(&log->synclist))\n\t\t\tlog->sync = log->lsn;\n\t\telse {\n\t\t\tlp = list_entry(log->synclist.next,\n\t\t\t\t\tstruct logsyncblk, synclist);\n\t\t\tlog->sync = lp->lsn;\n\t\t}\n\t\tLOGSYNC_UNLOCK(log, flags);\n\n\t}\n\n\t \n\tif (log->sync != log->syncpt) {\n\t\tlrd.logtid = 0;\n\t\tlrd.backchain = 0;\n\t\tlrd.type = cpu_to_le16(LOG_SYNCPT);\n\t\tlrd.length = 0;\n\t\tlrd.log.syncpt.sync = cpu_to_le32(log->sync);\n\t\tlsn = lmWriteRecord(log, NULL, &lrd, NULL);\n\n\t\tlog->syncpt = log->sync;\n\t} else\n\t\tlsn = log->lsn;\n\n\t \n\tlogsize = log->logsize;\n\n\tlogdiff(written, lsn, log);\n\tfree = logsize - written;\n\tdelta = LOGSYNC_DELTA(logsize);\n\tmore = min(free / 2, delta);\n\tif (more < 2 * LOGPSIZE) {\n\t\tjfs_warn(\"\\n ... Log Wrap ... Log Wrap ... Log Wrap ...\\n\");\n\t\t \n\t\t \n\t\t \n\n\t\t \n\t\tlog->syncpt = log->sync = lsn;\n\t\tlog->nextsync = delta;\n\t} else\n\t\t \n\t\tlog->nextsync = written + more;\n\n\t \n\tif (!test_bit(log_SYNCBARRIER, &log->flag) &&\n\t    (written > LOGSYNC_BARRIER(logsize)) && log->active) {\n\t\tset_bit(log_SYNCBARRIER, &log->flag);\n\t\tjfs_info(\"log barrier on: lsn=0x%x syncpt=0x%x\", lsn,\n\t\t\t log->syncpt);\n\t\t \n\t\tjfs_flush_journal(log, 0);\n\t}\n\n\treturn lsn;\n}\n\n \nvoid jfs_syncpt(struct jfs_log *log, int hard_sync)\n{\tLOG_LOCK(log);\n\tif (!test_bit(log_QUIESCE, &log->flag))\n\t\tlmLogSync(log, hard_sync);\n\tLOG_UNLOCK(log);\n}\n\n \nint lmLogOpen(struct super_block *sb)\n{\n\tint rc;\n\tstruct block_device *bdev;\n\tstruct jfs_log *log;\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\n\tif (sbi->flag & JFS_NOINTEGRITY)\n\t\treturn open_dummy_log(sb);\n\n\tif (sbi->mntflag & JFS_INLINELOG)\n\t\treturn open_inline_log(sb);\n\n\tmutex_lock(&jfs_log_mutex);\n\tlist_for_each_entry(log, &jfs_external_logs, journal_list) {\n\t\tif (log->bdev->bd_dev == sbi->logdev) {\n\t\t\tif (!uuid_equal(&log->uuid, &sbi->loguuid)) {\n\t\t\t\tjfs_warn(\"wrong uuid on JFS journal\");\n\t\t\t\tmutex_unlock(&jfs_log_mutex);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t \n\t\t\tif ((rc = lmLogFileSystem(log, sbi, 1))) {\n\t\t\t\tmutex_unlock(&jfs_log_mutex);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tgoto journal_found;\n\t\t}\n\t}\n\n\tif (!(log = kzalloc(sizeof(struct jfs_log), GFP_KERNEL))) {\n\t\tmutex_unlock(&jfs_log_mutex);\n\t\treturn -ENOMEM;\n\t}\n\tINIT_LIST_HEAD(&log->sb_list);\n\tinit_waitqueue_head(&log->syncwait);\n\n\t \n\n\tbdev = blkdev_get_by_dev(sbi->logdev, BLK_OPEN_READ | BLK_OPEN_WRITE,\n\t\t\t\t log, NULL);\n\tif (IS_ERR(bdev)) {\n\t\trc = PTR_ERR(bdev);\n\t\tgoto free;\n\t}\n\n\tlog->bdev = bdev;\n\tuuid_copy(&log->uuid, &sbi->loguuid);\n\n\t \n\tif ((rc = lmLogInit(log)))\n\t\tgoto close;\n\n\tlist_add(&log->journal_list, &jfs_external_logs);\n\n\t \n\tif ((rc = lmLogFileSystem(log, sbi, 1)))\n\t\tgoto shutdown;\n\njournal_found:\n\tLOG_LOCK(log);\n\tlist_add(&sbi->log_list, &log->sb_list);\n\tsbi->log = log;\n\tLOG_UNLOCK(log);\n\n\tmutex_unlock(&jfs_log_mutex);\n\treturn 0;\n\n\t \n      shutdown:\t\t \n\tlist_del(&log->journal_list);\n\tlbmLogShutdown(log);\n\n      close:\t\t \n\tblkdev_put(bdev, log);\n\n      free:\t\t \n\tmutex_unlock(&jfs_log_mutex);\n\tkfree(log);\n\n\tjfs_warn(\"lmLogOpen: exit(%d)\", rc);\n\treturn rc;\n}\n\nstatic int open_inline_log(struct super_block *sb)\n{\n\tstruct jfs_log *log;\n\tint rc;\n\n\tif (!(log = kzalloc(sizeof(struct jfs_log), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\tINIT_LIST_HEAD(&log->sb_list);\n\tinit_waitqueue_head(&log->syncwait);\n\n\tset_bit(log_INLINELOG, &log->flag);\n\tlog->bdev = sb->s_bdev;\n\tlog->base = addressPXD(&JFS_SBI(sb)->logpxd);\n\tlog->size = lengthPXD(&JFS_SBI(sb)->logpxd) >>\n\t    (L2LOGPSIZE - sb->s_blocksize_bits);\n\tlog->l2bsize = sb->s_blocksize_bits;\n\tASSERT(L2LOGPSIZE >= sb->s_blocksize_bits);\n\n\t \n\tif ((rc = lmLogInit(log))) {\n\t\tkfree(log);\n\t\tjfs_warn(\"lmLogOpen: exit(%d)\", rc);\n\t\treturn rc;\n\t}\n\n\tlist_add(&JFS_SBI(sb)->log_list, &log->sb_list);\n\tJFS_SBI(sb)->log = log;\n\n\treturn rc;\n}\n\nstatic int open_dummy_log(struct super_block *sb)\n{\n\tint rc;\n\n\tmutex_lock(&jfs_log_mutex);\n\tif (!dummy_log) {\n\t\tdummy_log = kzalloc(sizeof(struct jfs_log), GFP_KERNEL);\n\t\tif (!dummy_log) {\n\t\t\tmutex_unlock(&jfs_log_mutex);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tINIT_LIST_HEAD(&dummy_log->sb_list);\n\t\tinit_waitqueue_head(&dummy_log->syncwait);\n\t\tdummy_log->no_integrity = 1;\n\t\t \n\t\tdummy_log->base = 0;\n\t\tdummy_log->size = 1024;\n\t\trc = lmLogInit(dummy_log);\n\t\tif (rc) {\n\t\t\tkfree(dummy_log);\n\t\t\tdummy_log = NULL;\n\t\t\tmutex_unlock(&jfs_log_mutex);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\tLOG_LOCK(dummy_log);\n\tlist_add(&JFS_SBI(sb)->log_list, &dummy_log->sb_list);\n\tJFS_SBI(sb)->log = dummy_log;\n\tLOG_UNLOCK(dummy_log);\n\tmutex_unlock(&jfs_log_mutex);\n\n\treturn 0;\n}\n\n \nint lmLogInit(struct jfs_log * log)\n{\n\tint rc = 0;\n\tstruct lrd lrd;\n\tstruct logsuper *logsuper;\n\tstruct lbuf *bpsuper;\n\tstruct lbuf *bp;\n\tstruct logpage *lp;\n\tint lsn = 0;\n\n\tjfs_info(\"lmLogInit: log:0x%p\", log);\n\n\t \n\tLOGGC_LOCK_INIT(log);\n\n\t \n\tLOG_LOCK_INIT(log);\n\n\tLOGSYNC_LOCK_INIT(log);\n\n\tINIT_LIST_HEAD(&log->synclist);\n\n\tINIT_LIST_HEAD(&log->cqueue);\n\tlog->flush_tblk = NULL;\n\n\tlog->count = 0;\n\n\t \n\tif ((rc = lbmLogInit(log)))\n\t\treturn rc;\n\n\tif (!test_bit(log_INLINELOG, &log->flag))\n\t\tlog->l2bsize = L2LOGPSIZE;\n\n\t \n\tif (log->no_integrity) {\n\t\t \n\t\tbp = lbmAllocate(log , 0);\n\t\tlog->bp = bp;\n\t\tbp->l_pn = bp->l_eor = 0;\n\t} else {\n\t\t \n\t\tif ((rc = lbmRead(log, 1, &bpsuper)))\n\t\t\tgoto errout10;\n\n\t\tlogsuper = (struct logsuper *) bpsuper->l_ldata;\n\n\t\tif (logsuper->magic != cpu_to_le32(LOGMAGIC)) {\n\t\t\tjfs_warn(\"*** Log Format Error ! ***\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto errout20;\n\t\t}\n\n\t\t \n\t\tif (logsuper->state != cpu_to_le32(LOGREDONE)) {\n\t\t\tjfs_warn(\"*** Log Is Dirty ! ***\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto errout20;\n\t\t}\n\n\t\t \n\t\tif (test_bit(log_INLINELOG,&log->flag)) {\n\t\t\tif (log->size != le32_to_cpu(logsuper->size)) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto errout20;\n\t\t\t}\n\t\t\tjfs_info(\"lmLogInit: inline log:0x%p base:0x%Lx size:0x%x\",\n\t\t\t\t log, (unsigned long long)log->base, log->size);\n\t\t} else {\n\t\t\tif (!uuid_equal(&logsuper->uuid, &log->uuid)) {\n\t\t\t\tjfs_warn(\"wrong uuid on JFS log device\");\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto errout20;\n\t\t\t}\n\t\t\tlog->size = le32_to_cpu(logsuper->size);\n\t\t\tlog->l2bsize = le32_to_cpu(logsuper->l2bsize);\n\t\t\tjfs_info(\"lmLogInit: external log:0x%p base:0x%Lx size:0x%x\",\n\t\t\t\t log, (unsigned long long)log->base, log->size);\n\t\t}\n\n\t\tlog->page = le32_to_cpu(logsuper->end) / LOGPSIZE;\n\t\tlog->eor = le32_to_cpu(logsuper->end) - (LOGPSIZE * log->page);\n\n\t\t \n\t\t \n\t\tif ((rc = lbmRead(log, log->page, &bp)))\n\t\t\tgoto errout20;\n\n\t\tlp = (struct logpage *) bp->l_ldata;\n\n\t\tjfs_info(\"lmLogInit: lsn:0x%x page:%d eor:%d:%d\",\n\t\t\t le32_to_cpu(logsuper->end), log->page, log->eor,\n\t\t\t le16_to_cpu(lp->h.eor));\n\n\t\tlog->bp = bp;\n\t\tbp->l_pn = log->page;\n\t\tbp->l_eor = log->eor;\n\n\t\t \n\t\tif (log->eor >= LOGPSIZE - LOGPTLRSIZE)\n\t\t\tlmNextPage(log);\n\n\t\t \n\t\t \n\t\tlrd.logtid = 0;\n\t\tlrd.backchain = 0;\n\t\tlrd.type = cpu_to_le16(LOG_SYNCPT);\n\t\tlrd.length = 0;\n\t\tlrd.log.syncpt.sync = 0;\n\t\tlsn = lmWriteRecord(log, NULL, &lrd, NULL);\n\t\tbp = log->bp;\n\t\tbp->l_ceor = bp->l_eor;\n\t\tlp = (struct logpage *) bp->l_ldata;\n\t\tlp->h.eor = lp->t.eor = cpu_to_le16(bp->l_eor);\n\t\tlbmWrite(log, bp, lbmWRITE | lbmSYNC, 0);\n\t\tif ((rc = lbmIOWait(bp, 0)))\n\t\t\tgoto errout30;\n\n\t\t \n\t\tlogsuper->state = cpu_to_le32(LOGMOUNT);\n\t\tlog->serial = le32_to_cpu(logsuper->serial) + 1;\n\t\tlogsuper->serial = cpu_to_le32(log->serial);\n\t\tlbmDirectWrite(log, bpsuper, lbmWRITE | lbmRELEASE | lbmSYNC);\n\t\tif ((rc = lbmIOWait(bpsuper, lbmFREE)))\n\t\t\tgoto errout30;\n\t}\n\n\t \n\tlog->logsize = (log->size - 2) << L2LOGPSIZE;\n\tlog->lsn = lsn;\n\tlog->syncpt = lsn;\n\tlog->sync = log->syncpt;\n\tlog->nextsync = LOGSYNC_DELTA(log->logsize);\n\n\tjfs_info(\"lmLogInit: lsn:0x%x syncpt:0x%x sync:0x%x\",\n\t\t log->lsn, log->syncpt, log->sync);\n\n\t \n\tlog->clsn = lsn;\n\n\treturn 0;\n\n\t \n      errout30:\t\t \n\tlog->wqueue = NULL;\n\tbp->l_wqnext = NULL;\n\tlbmFree(bp);\n\n      errout20:\t\t \n\tlbmFree(bpsuper);\n\n      errout10:\t\t \n\tlbmLogShutdown(log);\n\n\tjfs_warn(\"lmLogInit: exit(%d)\", rc);\n\treturn rc;\n}\n\n\n \nint lmLogClose(struct super_block *sb)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct jfs_log *log = sbi->log;\n\tstruct block_device *bdev;\n\tint rc = 0;\n\n\tjfs_info(\"lmLogClose: log:0x%p\", log);\n\n\tmutex_lock(&jfs_log_mutex);\n\tLOG_LOCK(log);\n\tlist_del(&sbi->log_list);\n\tLOG_UNLOCK(log);\n\tsbi->log = NULL;\n\n\t \n\tsync_blockdev(sb->s_bdev);\n\n\tif (test_bit(log_INLINELOG, &log->flag)) {\n\t\t \n\t\trc = lmLogShutdown(log);\n\t\tkfree(log);\n\t\tgoto out;\n\t}\n\n\tif (!log->no_integrity)\n\t\tlmLogFileSystem(log, sbi, 0);\n\n\tif (!list_empty(&log->sb_list))\n\t\tgoto out;\n\n\t \n\tif (log->no_integrity)\n\t\tgoto out;\n\n\t \n\tlist_del(&log->journal_list);\n\tbdev = log->bdev;\n\trc = lmLogShutdown(log);\n\n\tblkdev_put(bdev, log);\n\n\tkfree(log);\n\n      out:\n\tmutex_unlock(&jfs_log_mutex);\n\tjfs_info(\"lmLogClose: exit(%d)\", rc);\n\treturn rc;\n}\n\n\n \nvoid jfs_flush_journal(struct jfs_log *log, int wait)\n{\n\tint i;\n\tstruct tblock *target = NULL;\n\n\t \n\tif (!log)\n\t\treturn;\n\n\tjfs_info(\"jfs_flush_journal: log:0x%p wait=%d\", log, wait);\n\n\tLOGGC_LOCK(log);\n\n\tif (!list_empty(&log->cqueue)) {\n\t\t \n\t\ttarget = list_entry(log->cqueue.prev, struct tblock, cqueue);\n\n\t\tif (test_bit(log_FLUSH, &log->flag)) {\n\t\t\t \n\t\t\tif (log->flush_tblk)\n\t\t\t\tlog->flush_tblk = target;\n\t\t} else {\n\t\t\t \n\t\t\tlog->flush_tblk = target;\n\t\t\tset_bit(log_FLUSH, &log->flag);\n\n\t\t\t \n\t\t\tif (!(log->cflag & logGC_PAGEOUT)) {\n\t\t\t\tlog->cflag |= logGC_PAGEOUT;\n\t\t\t\tlmGCwrite(log, 0);\n\t\t\t}\n\t\t}\n\t}\n\tif ((wait > 1) || test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t \n\t\tset_bit(log_FLUSH, &log->flag);\n\t\tlog->flush_tblk = NULL;\n\t}\n\n\tif (wait && target && !(target->flag & tblkGC_COMMITTED)) {\n\t\tDECLARE_WAITQUEUE(__wait, current);\n\n\t\tadd_wait_queue(&target->gcwait, &__wait);\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tLOGGC_UNLOCK(log);\n\t\tschedule();\n\t\tLOGGC_LOCK(log);\n\t\tremove_wait_queue(&target->gcwait, &__wait);\n\t}\n\tLOGGC_UNLOCK(log);\n\n\tif (wait < 2)\n\t\treturn;\n\n\twrite_special_inodes(log, filemap_fdatawrite);\n\n\t \n\tif ((!list_empty(&log->cqueue)) || !list_empty(&log->synclist)) {\n\t\tfor (i = 0; i < 200; i++) {\t \n\t\t\tmsleep(250);\n\t\t\twrite_special_inodes(log, filemap_fdatawrite);\n\t\t\tif (list_empty(&log->cqueue) &&\n\t\t\t    list_empty(&log->synclist))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tassert(list_empty(&log->cqueue));\n\n#ifdef CONFIG_JFS_DEBUG\n\tif (!list_empty(&log->synclist)) {\n\t\tstruct logsyncblk *lp;\n\n\t\tprintk(KERN_ERR \"jfs_flush_journal: synclist not empty\\n\");\n\t\tlist_for_each_entry(lp, &log->synclist, synclist) {\n\t\t\tif (lp->xflag & COMMIT_PAGE) {\n\t\t\t\tstruct metapage *mp = (struct metapage *)lp;\n\t\t\t\tprint_hex_dump(KERN_ERR, \"metapage: \",\n\t\t\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t\t\t       mp, sizeof(struct metapage), 0);\n\t\t\t\tprint_hex_dump(KERN_ERR, \"page: \",\n\t\t\t\t\t       DUMP_PREFIX_ADDRESS, 16,\n\t\t\t\t\t       sizeof(long), mp->page,\n\t\t\t\t\t       sizeof(struct page), 0);\n\t\t\t} else\n\t\t\t\tprint_hex_dump(KERN_ERR, \"tblock:\",\n\t\t\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t\t\t       lp, sizeof(struct tblock), 0);\n\t\t}\n\t}\n#else\n\tWARN_ON(!list_empty(&log->synclist));\n#endif\n\tclear_bit(log_FLUSH, &log->flag);\n}\n\n \nint lmLogShutdown(struct jfs_log * log)\n{\n\tint rc;\n\tstruct lrd lrd;\n\tint lsn;\n\tstruct logsuper *logsuper;\n\tstruct lbuf *bpsuper;\n\tstruct lbuf *bp;\n\tstruct logpage *lp;\n\n\tjfs_info(\"lmLogShutdown: log:0x%p\", log);\n\n\tjfs_flush_journal(log, 2);\n\n\t \n\tlrd.logtid = 0;\n\tlrd.backchain = 0;\n\tlrd.type = cpu_to_le16(LOG_SYNCPT);\n\tlrd.length = 0;\n\tlrd.log.syncpt.sync = 0;\n\n\tlsn = lmWriteRecord(log, NULL, &lrd, NULL);\n\tbp = log->bp;\n\tlp = (struct logpage *) bp->l_ldata;\n\tlp->h.eor = lp->t.eor = cpu_to_le16(bp->l_eor);\n\tlbmWrite(log, log->bp, lbmWRITE | lbmRELEASE | lbmSYNC, 0);\n\tlbmIOWait(log->bp, lbmFREE);\n\tlog->bp = NULL;\n\n\t \n\tif ((rc = lbmRead(log, 1, &bpsuper)))\n\t\tgoto out;\n\n\tlogsuper = (struct logsuper *) bpsuper->l_ldata;\n\tlogsuper->state = cpu_to_le32(LOGREDONE);\n\tlogsuper->end = cpu_to_le32(lsn);\n\tlbmDirectWrite(log, bpsuper, lbmWRITE | lbmRELEASE | lbmSYNC);\n\trc = lbmIOWait(bpsuper, lbmFREE);\n\n\tjfs_info(\"lmLogShutdown: lsn:0x%x page:%d eor:%d\",\n\t\t lsn, log->page, log->eor);\n\n      out:\n\t \n\tlbmLogShutdown(log);\n\n\tif (rc) {\n\t\tjfs_warn(\"lmLogShutdown: exit(%d)\", rc);\n\t}\n\treturn rc;\n}\n\n\n \nstatic int lmLogFileSystem(struct jfs_log * log, struct jfs_sb_info *sbi,\n\t\t\t   int activate)\n{\n\tint rc = 0;\n\tint i;\n\tstruct logsuper *logsuper;\n\tstruct lbuf *bpsuper;\n\tuuid_t *uuid = &sbi->uuid;\n\n\t \n\tif ((rc = lbmRead(log, 1, &bpsuper)))\n\t\treturn rc;\n\n\tlogsuper = (struct logsuper *) bpsuper->l_ldata;\n\tif (activate) {\n\t\tfor (i = 0; i < MAX_ACTIVE; i++)\n\t\t\tif (uuid_is_null(&logsuper->active[i].uuid)) {\n\t\t\t\tuuid_copy(&logsuper->active[i].uuid, uuid);\n\t\t\t\tsbi->aggregate = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (i == MAX_ACTIVE) {\n\t\t\tjfs_warn(\"Too many file systems sharing journal!\");\n\t\t\tlbmFree(bpsuper);\n\t\t\treturn -EMFILE;\t \n\t\t}\n\t} else {\n\t\tfor (i = 0; i < MAX_ACTIVE; i++)\n\t\t\tif (uuid_equal(&logsuper->active[i].uuid, uuid)) {\n\t\t\t\tuuid_copy(&logsuper->active[i].uuid,\n\t\t\t\t\t  &uuid_null);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (i == MAX_ACTIVE) {\n\t\t\tjfs_warn(\"Somebody stomped on the journal!\");\n\t\t\tlbmFree(bpsuper);\n\t\t\treturn -EIO;\n\t\t}\n\n\t}\n\n\t \n\tlbmDirectWrite(log, bpsuper, lbmWRITE | lbmRELEASE | lbmSYNC);\n\trc = lbmIOWait(bpsuper, lbmFREE);\n\n\treturn rc;\n}\n\n \n\n \nstatic int lbmLogInit(struct jfs_log * log)\n{\t\t\t\t \n\tint i;\n\tstruct lbuf *lbuf;\n\n\tjfs_info(\"lbmLogInit: log:0x%p\", log);\n\n\t \n\tlog->bp = NULL;\n\n\t \n\tlog->wqueue = NULL;\n\n\t \n\tinit_waitqueue_head(&log->free_wait);\n\n\tlog->lbuf_free = NULL;\n\n\tfor (i = 0; i < LOGPAGES;) {\n\t\tchar *buffer;\n\t\tuint offset;\n\t\tstruct page *page = alloc_page(GFP_KERNEL | __GFP_ZERO);\n\n\t\tif (!page)\n\t\t\tgoto error;\n\t\tbuffer = page_address(page);\n\t\tfor (offset = 0; offset < PAGE_SIZE; offset += LOGPSIZE) {\n\t\t\tlbuf = kmalloc(sizeof(struct lbuf), GFP_KERNEL);\n\t\t\tif (lbuf == NULL) {\n\t\t\t\tif (offset == 0)\n\t\t\t\t\t__free_page(page);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif (offset)  \n\t\t\t\tget_page(page);\n\t\t\tlbuf->l_offset = offset;\n\t\t\tlbuf->l_ldata = buffer + offset;\n\t\t\tlbuf->l_page = page;\n\t\t\tlbuf->l_log = log;\n\t\t\tinit_waitqueue_head(&lbuf->l_ioevent);\n\n\t\t\tlbuf->l_freelist = log->lbuf_free;\n\t\t\tlog->lbuf_free = lbuf;\n\t\t\ti++;\n\t\t}\n\t}\n\n\treturn (0);\n\n      error:\n\tlbmLogShutdown(log);\n\treturn -ENOMEM;\n}\n\n\n \nstatic void lbmLogShutdown(struct jfs_log * log)\n{\n\tstruct lbuf *lbuf;\n\n\tjfs_info(\"lbmLogShutdown: log:0x%p\", log);\n\n\tlbuf = log->lbuf_free;\n\twhile (lbuf) {\n\t\tstruct lbuf *next = lbuf->l_freelist;\n\t\t__free_page(lbuf->l_page);\n\t\tkfree(lbuf);\n\t\tlbuf = next;\n\t}\n}\n\n\n \nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int pn)\n{\n\tstruct lbuf *bp;\n\tunsigned long flags;\n\n\t \n\tLCACHE_LOCK(flags);\n\tLCACHE_SLEEP_COND(log->free_wait, (bp = log->lbuf_free), flags);\n\tlog->lbuf_free = bp->l_freelist;\n\tLCACHE_UNLOCK(flags);\n\n\tbp->l_flag = 0;\n\n\tbp->l_wqnext = NULL;\n\tbp->l_freelist = NULL;\n\n\tbp->l_pn = pn;\n\tbp->l_blkno = log->base + (pn << (L2LOGPSIZE - log->l2bsize));\n\tbp->l_ceor = 0;\n\n\treturn bp;\n}\n\n\n \nstatic void lbmFree(struct lbuf * bp)\n{\n\tunsigned long flags;\n\n\tLCACHE_LOCK(flags);\n\n\tlbmfree(bp);\n\n\tLCACHE_UNLOCK(flags);\n}\n\nstatic void lbmfree(struct lbuf * bp)\n{\n\tstruct jfs_log *log = bp->l_log;\n\n\tassert(bp->l_wqnext == NULL);\n\n\t \n\tbp->l_freelist = log->lbuf_free;\n\tlog->lbuf_free = bp;\n\n\twake_up(&log->free_wait);\n\treturn;\n}\n\n\n \nstatic inline void lbmRedrive(struct lbuf *bp)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&log_redrive_lock, flags);\n\tbp->l_redrive_next = log_redrive_list;\n\tlog_redrive_list = bp;\n\tspin_unlock_irqrestore(&log_redrive_lock, flags);\n\n\twake_up_process(jfsIOthread);\n}\n\n\n \nstatic int lbmRead(struct jfs_log * log, int pn, struct lbuf ** bpp)\n{\n\tstruct bio *bio;\n\tstruct lbuf *bp;\n\n\t \n\t*bpp = bp = lbmAllocate(log, pn);\n\tjfs_info(\"lbmRead: bp:0x%p pn:0x%x\", bp, pn);\n\n\tbp->l_flag |= lbmREAD;\n\n\tbio = bio_alloc(log->bdev, 1, REQ_OP_READ, GFP_NOFS);\n\tbio->bi_iter.bi_sector = bp->l_blkno << (log->l2bsize - 9);\n\t__bio_add_page(bio, bp->l_page, LOGPSIZE, bp->l_offset);\n\tBUG_ON(bio->bi_iter.bi_size != LOGPSIZE);\n\n\tbio->bi_end_io = lbmIODone;\n\tbio->bi_private = bp;\n\t \n\tif (log->no_integrity) {\n\t\tbio->bi_iter.bi_size = 0;\n\t\tlbmIODone(bio);\n\t} else {\n\t\tsubmit_bio(bio);\n\t}\n\n\twait_event(bp->l_ioevent, (bp->l_flag != lbmREAD));\n\n\treturn 0;\n}\n\n\n \nstatic void lbmWrite(struct jfs_log * log, struct lbuf * bp, int flag,\n\t\t     int cant_block)\n{\n\tstruct lbuf *tail;\n\tunsigned long flags;\n\n\tjfs_info(\"lbmWrite: bp:0x%p flag:0x%x pn:0x%x\", bp, flag, bp->l_pn);\n\n\t \n\tbp->l_blkno =\n\t    log->base + (bp->l_pn << (L2LOGPSIZE - log->l2bsize));\n\n\tLCACHE_LOCK(flags);\t\t \n\n\t \n\tbp->l_flag = flag;\n\n\t \n\ttail = log->wqueue;\n\n\t \n\tif (bp->l_wqnext == NULL) {\n\t\t \n\t\tif (tail == NULL) {\n\t\t\tlog->wqueue = bp;\n\t\t\tbp->l_wqnext = bp;\n\t\t} else {\n\t\t\tlog->wqueue = bp;\n\t\t\tbp->l_wqnext = tail->l_wqnext;\n\t\t\ttail->l_wqnext = bp;\n\t\t}\n\n\t\ttail = bp;\n\t}\n\n\t \n\tif ((bp != tail->l_wqnext) || !(flag & lbmWRITE)) {\n\t\tLCACHE_UNLOCK(flags);\t \n\t\treturn;\n\t}\n\n\tLCACHE_UNLOCK(flags);\t \n\n\tif (cant_block)\n\t\tlbmRedrive(bp);\n\telse if (flag & lbmSYNC)\n\t\tlbmStartIO(bp);\n\telse {\n\t\tLOGGC_UNLOCK(log);\n\t\tlbmStartIO(bp);\n\t\tLOGGC_LOCK(log);\n\t}\n}\n\n\n \nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag)\n{\n\tjfs_info(\"lbmDirectWrite: bp:0x%p flag:0x%x pn:0x%x\",\n\t\t bp, flag, bp->l_pn);\n\n\t \n\tbp->l_flag = flag | lbmDIRECT;\n\n\t \n\tbp->l_blkno =\n\t    log->base + (bp->l_pn << (L2LOGPSIZE - log->l2bsize));\n\n\t \n\tlbmStartIO(bp);\n}\n\n\n \nstatic void lbmStartIO(struct lbuf * bp)\n{\n\tstruct bio *bio;\n\tstruct jfs_log *log = bp->l_log;\n\n\tjfs_info(\"lbmStartIO\");\n\n\tbio = bio_alloc(log->bdev, 1, REQ_OP_WRITE | REQ_SYNC, GFP_NOFS);\n\tbio->bi_iter.bi_sector = bp->l_blkno << (log->l2bsize - 9);\n\t__bio_add_page(bio, bp->l_page, LOGPSIZE, bp->l_offset);\n\tBUG_ON(bio->bi_iter.bi_size != LOGPSIZE);\n\n\tbio->bi_end_io = lbmIODone;\n\tbio->bi_private = bp;\n\n\t \n\tif (log->no_integrity) {\n\t\tbio->bi_iter.bi_size = 0;\n\t\tlbmIODone(bio);\n\t} else {\n\t\tsubmit_bio(bio);\n\t\tINCREMENT(lmStat.submitted);\n\t}\n}\n\n\n \nstatic int lbmIOWait(struct lbuf * bp, int flag)\n{\n\tunsigned long flags;\n\tint rc = 0;\n\n\tjfs_info(\"lbmIOWait1: bp:0x%p flag:0x%x:0x%x\", bp, bp->l_flag, flag);\n\n\tLCACHE_LOCK(flags);\t\t \n\n\tLCACHE_SLEEP_COND(bp->l_ioevent, (bp->l_flag & lbmDONE), flags);\n\n\trc = (bp->l_flag & lbmERROR) ? -EIO : 0;\n\n\tif (flag & lbmFREE)\n\t\tlbmfree(bp);\n\n\tLCACHE_UNLOCK(flags);\t \n\n\tjfs_info(\"lbmIOWait2: bp:0x%p flag:0x%x:0x%x\", bp, bp->l_flag, flag);\n\treturn rc;\n}\n\n \nstatic void lbmIODone(struct bio *bio)\n{\n\tstruct lbuf *bp = bio->bi_private;\n\tstruct lbuf *nextbp, *tail;\n\tstruct jfs_log *log;\n\tunsigned long flags;\n\n\t \n\tjfs_info(\"lbmIODone: bp:0x%p flag:0x%x\", bp, bp->l_flag);\n\n\tLCACHE_LOCK(flags);\t\t \n\n\tbp->l_flag |= lbmDONE;\n\n\tif (bio->bi_status) {\n\t\tbp->l_flag |= lbmERROR;\n\n\t\tjfs_err(\"lbmIODone: I/O error in JFS log\");\n\t}\n\n\tbio_put(bio);\n\n\t \n\tif (bp->l_flag & lbmREAD) {\n\t\tbp->l_flag &= ~lbmREAD;\n\n\t\tLCACHE_UNLOCK(flags);\t \n\n\t\t \n\t\tLCACHE_WAKEUP(&bp->l_ioevent);\n\n\t\treturn;\n\t}\n\n\t \n\tbp->l_flag &= ~lbmWRITE;\n\tINCREMENT(lmStat.pagedone);\n\n\t \n\tlog = bp->l_log;\n\tlog->clsn = (bp->l_pn << L2LOGPSIZE) + bp->l_ceor;\n\n\tif (bp->l_flag & lbmDIRECT) {\n\t\tLCACHE_WAKEUP(&bp->l_ioevent);\n\t\tLCACHE_UNLOCK(flags);\n\t\treturn;\n\t}\n\n\ttail = log->wqueue;\n\n\t \n\tif (bp == tail) {\n\t\t \n\t\tif (bp->l_flag & lbmRELEASE) {\n\t\t\tlog->wqueue = NULL;\n\t\t\tbp->l_wqnext = NULL;\n\t\t}\n\t}\n\t \n\telse {\n\t\t \n\t\tif (bp->l_flag & lbmRELEASE) {\n\t\t\tnextbp = tail->l_wqnext = bp->l_wqnext;\n\t\t\tbp->l_wqnext = NULL;\n\n\t\t\t \n\t\t\tif (nextbp->l_flag & lbmWRITE) {\n\t\t\t\t \n\t\t\t\tlbmRedrive(nextbp);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (bp->l_flag & lbmSYNC) {\n\t\tLCACHE_UNLOCK(flags);\t \n\n\t\t \n\t\tLCACHE_WAKEUP(&bp->l_ioevent);\n\t}\n\n\t \n\telse if (bp->l_flag & lbmGC) {\n\t\tLCACHE_UNLOCK(flags);\n\t\tlmPostGC(bp);\n\t}\n\n\t \n\telse {\n\t\tassert(bp->l_flag & lbmRELEASE);\n\t\tassert(bp->l_flag & lbmFREE);\n\t\tlbmfree(bp);\n\n\t\tLCACHE_UNLOCK(flags);\t \n\t}\n}\n\nint jfsIOWait(void *arg)\n{\n\tstruct lbuf *bp;\n\n\tdo {\n\t\tspin_lock_irq(&log_redrive_lock);\n\t\twhile ((bp = log_redrive_list)) {\n\t\t\tlog_redrive_list = bp->l_redrive_next;\n\t\t\tbp->l_redrive_next = NULL;\n\t\t\tspin_unlock_irq(&log_redrive_lock);\n\t\t\tlbmStartIO(bp);\n\t\t\tspin_lock_irq(&log_redrive_lock);\n\t\t}\n\n\t\tif (freezing(current)) {\n\t\t\tspin_unlock_irq(&log_redrive_lock);\n\t\t\ttry_to_freeze();\n\t\t} else {\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tspin_unlock_irq(&log_redrive_lock);\n\t\t\tschedule();\n\t\t}\n\t} while (!kthread_should_stop());\n\n\tjfs_info(\"jfsIOWait being killed!\");\n\treturn 0;\n}\n\n \nint lmLogFormat(struct jfs_log *log, s64 logAddress, int logSize)\n{\n\tint rc = -EIO;\n\tstruct jfs_sb_info *sbi;\n\tstruct logsuper *logsuper;\n\tstruct logpage *lp;\n\tint lspn;\t\t \n\tstruct lrd *lrd_ptr;\n\tint npages = 0;\n\tstruct lbuf *bp;\n\n\tjfs_info(\"lmLogFormat: logAddress:%Ld logSize:%d\",\n\t\t (long long)logAddress, logSize);\n\n\tsbi = list_entry(log->sb_list.next, struct jfs_sb_info, log_list);\n\n\t \n\tbp = lbmAllocate(log, 1);\n\n\tnpages = logSize >> sbi->l2nbperpage;\n\n\t \n\t \n\tlogsuper = (struct logsuper *) bp->l_ldata;\n\n\tlogsuper->magic = cpu_to_le32(LOGMAGIC);\n\tlogsuper->version = cpu_to_le32(LOGVERSION);\n\tlogsuper->state = cpu_to_le32(LOGREDONE);\n\tlogsuper->flag = cpu_to_le32(sbi->mntflag);\t \n\tlogsuper->size = cpu_to_le32(npages);\n\tlogsuper->bsize = cpu_to_le32(sbi->bsize);\n\tlogsuper->l2bsize = cpu_to_le32(sbi->l2bsize);\n\tlogsuper->end = cpu_to_le32(2 * LOGPSIZE + LOGPHDRSIZE + LOGRDSIZE);\n\n\tbp->l_flag = lbmWRITE | lbmSYNC | lbmDIRECT;\n\tbp->l_blkno = logAddress + sbi->nbperpage;\n\tlbmStartIO(bp);\n\tif ((rc = lbmIOWait(bp, 0)))\n\t\tgoto exit;\n\n\t \n\tlp = (struct logpage *) bp->l_ldata;\n\t \n\tlp->h.page = lp->t.page = cpu_to_le32(npages - 3);\n\tlp->h.eor = lp->t.eor = cpu_to_le16(LOGPHDRSIZE + LOGRDSIZE);\n\n\tlrd_ptr = (struct lrd *) &lp->data;\n\tlrd_ptr->logtid = 0;\n\tlrd_ptr->backchain = 0;\n\tlrd_ptr->type = cpu_to_le16(LOG_SYNCPT);\n\tlrd_ptr->length = 0;\n\tlrd_ptr->log.syncpt.sync = 0;\n\n\tbp->l_blkno += sbi->nbperpage;\n\tbp->l_flag = lbmWRITE | lbmSYNC | lbmDIRECT;\n\tlbmStartIO(bp);\n\tif ((rc = lbmIOWait(bp, 0)))\n\t\tgoto exit;\n\n\t \n\tfor (lspn = 0; lspn < npages - 3; lspn++) {\n\t\tlp->h.page = lp->t.page = cpu_to_le32(lspn);\n\t\tlp->h.eor = lp->t.eor = cpu_to_le16(LOGPHDRSIZE);\n\n\t\tbp->l_blkno += sbi->nbperpage;\n\t\tbp->l_flag = lbmWRITE | lbmSYNC | lbmDIRECT;\n\t\tlbmStartIO(bp);\n\t\tif ((rc = lbmIOWait(bp, 0)))\n\t\t\tgoto exit;\n\t}\n\n\trc = 0;\nexit:\n\t \n\t \n\tlbmFree(bp);\n\n\treturn rc;\n}\n\n#ifdef CONFIG_JFS_STATISTICS\nint jfs_lmstats_proc_show(struct seq_file *m, void *v)\n{\n\tseq_printf(m,\n\t\t       \"JFS Logmgr stats\\n\"\n\t\t       \"================\\n\"\n\t\t       \"commits = %d\\n\"\n\t\t       \"writes submitted = %d\\n\"\n\t\t       \"writes completed = %d\\n\"\n\t\t       \"full pages submitted = %d\\n\"\n\t\t       \"partial pages submitted = %d\\n\",\n\t\t       lmStat.commit,\n\t\t       lmStat.submitted,\n\t\t       lmStat.pagedone,\n\t\t       lmStat.full_page,\n\t\t       lmStat.partial_page);\n\treturn 0;\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}