{
  "module_name": "inode.c",
  "hash_id": "e5aa4c19f1edad7599518818e5ca1038af8eb958699ba30ab07cf98b99c5c016",
  "original_prompt": "Ingested from linux-6.6.14/fs/jfs/inode.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/quotaops.h>\n#include <linux/uio.h>\n#include <linux/writeback.h>\n#include \"jfs_incore.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_dmap.h\"\n\n\nstruct inode *jfs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct inode *inode;\n\tint ret;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tret = diRead(inode);\n\tif (ret < 0) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &jfs_file_inode_operations;\n\t\tinode->i_fop = &jfs_file_operations;\n\t\tinode->i_mapping->a_ops = &jfs_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &jfs_dir_inode_operations;\n\t\tinode->i_fop = &jfs_dir_operations;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (inode->i_size >= IDATASIZE) {\n\t\t\tinode->i_op = &page_symlink_inode_operations;\n\t\t\tinode_nohighmem(inode);\n\t\t\tinode->i_mapping->a_ops = &jfs_aops;\n\t\t} else {\n\t\t\tinode->i_op = &jfs_fast_symlink_inode_operations;\n\t\t\tinode->i_link = JFS_IP(inode)->i_inline;\n\t\t\t \n\t\t\tinode->i_link[inode->i_size] = '\\0';\n\t\t}\n\t} else {\n\t\tinode->i_op = &jfs_file_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t}\n\tunlock_new_inode(inode);\n\treturn inode;\n}\n\n \nint jfs_commit_inode(struct inode *inode, int wait)\n{\n\tint rc = 0;\n\ttid_t tid;\n\tstatic int noisy = 5;\n\n\tjfs_info(\"In jfs_commit_inode, inode = 0x%p\", inode);\n\n\t \n\tif (inode->i_nlink == 0 || !test_cflag(COMMIT_Dirty, inode))\n\t\treturn 0;\n\n\tif (isReadOnly(inode)) {\n\t\t \n\t\tif (!special_file(inode->i_mode) && noisy) {\n\t\t\tjfs_err(\"jfs_commit_inode(0x%p) called on read-only volume\",\n\t\t\t\tinode);\n\t\t\tjfs_err(\"Is remount racy?\");\n\t\t\tnoisy--;\n\t\t}\n\t\treturn 0;\n\t}\n\n\ttid = txBegin(inode->i_sb, COMMIT_INODE);\n\tmutex_lock(&JFS_IP(inode)->commit_mutex);\n\n\t \n\tif (inode->i_nlink && test_cflag(COMMIT_Dirty, inode))\n\t\trc = txCommit(tid, 1, &inode, wait ? COMMIT_SYNC : 0);\n\n\ttxEnd(tid);\n\tmutex_unlock(&JFS_IP(inode)->commit_mutex);\n\treturn rc;\n}\n\nint jfs_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tint wait = wbc->sync_mode == WB_SYNC_ALL;\n\n\tif (inode->i_nlink == 0)\n\t\treturn 0;\n\t \n\tif (!test_cflag(COMMIT_Dirty, inode)) {\n\t\t \n\t\tjfs_flush_journal(JFS_SBI(inode->i_sb)->log, wait);\n\t\treturn 0;\n\t}\n\n\tif (jfs_commit_inode(inode, wait)) {\n\t\tjfs_err(\"jfs_write_inode: jfs_commit_inode failed!\");\n\t\treturn -EIO;\n\t} else\n\t\treturn 0;\n}\n\nvoid jfs_evict_inode(struct inode *inode)\n{\n\tstruct jfs_inode_info *ji = JFS_IP(inode);\n\n\tjfs_info(\"In jfs_evict_inode, inode = 0x%p\", inode);\n\n\tif (!inode->i_nlink && !is_bad_inode(inode)) {\n\t\tdquot_initialize(inode);\n\n\t\tif (JFS_IP(inode)->fileset == FILESYSTEM_I) {\n\t\t\tstruct inode *ipimap = JFS_SBI(inode->i_sb)->ipimap;\n\t\t\ttruncate_inode_pages_final(&inode->i_data);\n\n\t\t\tif (test_cflag(COMMIT_Freewmap, inode))\n\t\t\t\tjfs_free_zero_link(inode);\n\n\t\t\tif (ipimap && JFS_IP(ipimap)->i_imap)\n\t\t\t\tdiFree(inode);\n\n\t\t\t \n\t\t\tdquot_free_inode(inode);\n\t\t}\n\t} else {\n\t\ttruncate_inode_pages_final(&inode->i_data);\n\t}\n\tclear_inode(inode);\n\tdquot_drop(inode);\n\n\tBUG_ON(!list_empty(&ji->anon_inode_list));\n\n\tspin_lock_irq(&ji->ag_lock);\n\tif (ji->active_ag != -1) {\n\t\tstruct bmap *bmap = JFS_SBI(inode->i_sb)->bmap;\n\t\tatomic_dec(&bmap->db_active[ji->active_ag]);\n\t\tji->active_ag = -1;\n\t}\n\tspin_unlock_irq(&ji->ag_lock);\n}\n\nvoid jfs_dirty_inode(struct inode *inode, int flags)\n{\n\tstatic int noisy = 5;\n\n\tif (isReadOnly(inode)) {\n\t\tif (!special_file(inode->i_mode) && noisy) {\n\t\t\t \n\t\t\tjfs_err(\"jfs_dirty_inode called on read-only volume\");\n\t\t\tjfs_err(\"Is remount racy?\");\n\t\t\tnoisy--;\n\t\t}\n\t\treturn;\n\t}\n\n\tset_cflag(COMMIT_Dirty, inode);\n}\n\nint jfs_get_block(struct inode *ip, sector_t lblock,\n\t\t  struct buffer_head *bh_result, int create)\n{\n\ts64 lblock64 = lblock;\n\tint rc = 0;\n\txad_t xad;\n\ts64 xaddr;\n\tint xflag;\n\ts32 xlen = bh_result->b_size >> ip->i_blkbits;\n\n\t \n\tif (create)\n\t\tIWRITE_LOCK(ip, RDWRLOCK_NORMAL);\n\telse\n\t\tIREAD_LOCK(ip, RDWRLOCK_NORMAL);\n\n\tif (((lblock64 << ip->i_sb->s_blocksize_bits) < ip->i_size) &&\n\t    (!xtLookup(ip, lblock64, xlen, &xflag, &xaddr, &xlen, 0)) &&\n\t    xaddr) {\n\t\tif (xflag & XAD_NOTRECORDED) {\n\t\t\tif (!create)\n\t\t\t\t \n\t\t\t\tgoto unlock;\n\t\t\tXADoffset(&xad, lblock64);\n\t\t\tXADlength(&xad, xlen);\n\t\t\tXADaddress(&xad, xaddr);\n\t\t\trc = extRecord(ip, &xad);\n\t\t\tif (rc)\n\t\t\t\tgoto unlock;\n\t\t\tset_buffer_new(bh_result);\n\t\t}\n\n\t\tmap_bh(bh_result, ip->i_sb, xaddr);\n\t\tbh_result->b_size = xlen << ip->i_blkbits;\n\t\tgoto unlock;\n\t}\n\tif (!create)\n\t\tgoto unlock;\n\n\t \n\tif ((rc = extHint(ip, lblock64 << ip->i_sb->s_blocksize_bits, &xad)))\n\t\tgoto unlock;\n\trc = extAlloc(ip, xlen, lblock64, &xad, false);\n\tif (rc)\n\t\tgoto unlock;\n\n\tset_buffer_new(bh_result);\n\tmap_bh(bh_result, ip->i_sb, addressXAD(&xad));\n\tbh_result->b_size = lengthXAD(&xad) << ip->i_blkbits;\n\n      unlock:\n\t \n\tif (create)\n\t\tIWRITE_UNLOCK(ip);\n\telse\n\t\tIREAD_UNLOCK(ip);\n\treturn rc;\n}\n\nstatic int jfs_writepages(struct address_space *mapping,\n\t\t\tstruct writeback_control *wbc)\n{\n\treturn mpage_writepages(mapping, wbc, jfs_get_block);\n}\n\nstatic int jfs_read_folio(struct file *file, struct folio *folio)\n{\n\treturn mpage_read_folio(folio, jfs_get_block);\n}\n\nstatic void jfs_readahead(struct readahead_control *rac)\n{\n\tmpage_readahead(rac, jfs_get_block);\n}\n\nstatic void jfs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\tjfs_truncate(inode);\n\t}\n}\n\nstatic int jfs_write_begin(struct file *file, struct address_space *mapping,\n\t\t\t\tloff_t pos, unsigned len,\n\t\t\t\tstruct page **pagep, void **fsdata)\n{\n\tint ret;\n\n\tret = block_write_begin(mapping, pos, len, pagep, jfs_get_block);\n\tif (unlikely(ret))\n\t\tjfs_write_failed(mapping, pos + len);\n\n\treturn ret;\n}\n\nstatic int jfs_write_end(struct file *file, struct address_space *mapping,\n\t\tloff_t pos, unsigned len, unsigned copied, struct page *page,\n\t\tvoid *fsdata)\n{\n\tint ret;\n\n\tret = generic_write_end(file, mapping, pos, len, copied, page, fsdata);\n\tif (ret < len)\n\t\tjfs_write_failed(mapping, pos + len);\n\treturn ret;\n}\n\nstatic sector_t jfs_bmap(struct address_space *mapping, sector_t block)\n{\n\treturn generic_block_bmap(mapping, block, jfs_get_block);\n}\n\nstatic ssize_t jfs_direct_IO(struct kiocb *iocb, struct iov_iter *iter)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct inode *inode = file->f_mapping->host;\n\tsize_t count = iov_iter_count(iter);\n\tssize_t ret;\n\n\tret = blockdev_direct_IO(iocb, inode, iter, jfs_get_block);\n\n\t \n\tif (unlikely(iov_iter_rw(iter) == WRITE && ret < 0)) {\n\t\tloff_t isize = i_size_read(inode);\n\t\tloff_t end = iocb->ki_pos + count;\n\n\t\tif (end > isize)\n\t\t\tjfs_write_failed(mapping, end);\n\t}\n\n\treturn ret;\n}\n\nconst struct address_space_operations jfs_aops = {\n\t.dirty_folio\t= block_dirty_folio,\n\t.invalidate_folio = block_invalidate_folio,\n\t.read_folio\t= jfs_read_folio,\n\t.readahead\t= jfs_readahead,\n\t.writepages\t= jfs_writepages,\n\t.write_begin\t= jfs_write_begin,\n\t.write_end\t= jfs_write_end,\n\t.bmap\t\t= jfs_bmap,\n\t.direct_IO\t= jfs_direct_IO,\n\t.migrate_folio\t= buffer_migrate_folio,\n};\n\n \nvoid jfs_truncate_nolock(struct inode *ip, loff_t length)\n{\n\tloff_t newsize;\n\ttid_t tid;\n\n\tASSERT(length >= 0);\n\n\tif (test_cflag(COMMIT_Nolink, ip)) {\n\t\txtTruncate(0, ip, length, COMMIT_WMAP);\n\t\treturn;\n\t}\n\n\tdo {\n\t\ttid = txBegin(ip->i_sb, 0);\n\n\t\t \n\t\tmutex_lock(&JFS_IP(ip)->commit_mutex);\n\n\t\tnewsize = xtTruncate(tid, ip, length,\n\t\t\t\t     COMMIT_TRUNCATE | COMMIT_PWMAP);\n\t\tif (newsize < 0) {\n\t\t\ttxEnd(tid);\n\t\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t\t\tbreak;\n\t\t}\n\n\t\tip->i_mtime = inode_set_ctime_current(ip);\n\t\tmark_inode_dirty(ip);\n\n\t\ttxCommit(tid, 1, &ip, 0);\n\t\ttxEnd(tid);\n\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t} while (newsize > length);\t \n}\n\nvoid jfs_truncate(struct inode *ip)\n{\n\tjfs_info(\"jfs_truncate: size = 0x%lx\", (ulong) ip->i_size);\n\n\tblock_truncate_page(ip->i_mapping, ip->i_size, jfs_get_block);\n\n\tIWRITE_LOCK(ip, RDWRLOCK_NORMAL);\n\tjfs_truncate_nolock(ip, ip->i_size);\n\tIWRITE_UNLOCK(ip);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}