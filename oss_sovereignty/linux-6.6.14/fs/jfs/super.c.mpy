{
  "module_name": "super.c",
  "hash_id": "6edde4d7b97bacdb854a0eea4ada4e2bbb77222870d28d7a5faa76e31f98b7b3",
  "original_prompt": "Ingested from linux-6.6.14/fs/jfs/super.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/completion.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/moduleparam.h>\n#include <linux/kthread.h>\n#include <linux/posix_acl.h>\n#include <linux/buffer_head.h>\n#include <linux/exportfs.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/blkdev.h>\n\n#include \"jfs_incore.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_dinode.h\"\n\nMODULE_DESCRIPTION(\"The Journaled Filesystem (JFS)\");\nMODULE_AUTHOR(\"Steve Best/Dave Kleikamp/Barry Arndt, IBM\");\nMODULE_LICENSE(\"GPL\");\n\nstatic struct kmem_cache *jfs_inode_cachep;\n\nstatic const struct super_operations jfs_super_operations;\nstatic const struct export_operations jfs_export_operations;\nstatic struct file_system_type jfs_fs_type;\n\n#define MAX_COMMIT_THREADS 64\nstatic int commit_threads;\nmodule_param(commit_threads, int, 0);\nMODULE_PARM_DESC(commit_threads, \"Number of commit threads\");\n\nstatic struct task_struct *jfsCommitThread[MAX_COMMIT_THREADS];\nstruct task_struct *jfsIOthread;\nstruct task_struct *jfsSyncThread;\n\n#ifdef CONFIG_JFS_DEBUG\nint jfsloglevel = JFS_LOGLEVEL_WARN;\nmodule_param(jfsloglevel, int, 0644);\nMODULE_PARM_DESC(jfsloglevel, \"Specify JFS loglevel (0, 1 or 2)\");\n#endif\n\nstatic void jfs_handle_error(struct super_block *sb)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\n\tif (sb_rdonly(sb))\n\t\treturn;\n\n\tupdateSuper(sb, FM_DIRTY);\n\n\tif (sbi->flag & JFS_ERR_PANIC)\n\t\tpanic(\"JFS (device %s): panic forced after error\\n\",\n\t\t\tsb->s_id);\n\telse if (sbi->flag & JFS_ERR_REMOUNT_RO) {\n\t\tjfs_err(\"ERROR: (device %s): remounting filesystem as read-only\",\n\t\t\tsb->s_id);\n\t\tsb->s_flags |= SB_RDONLY;\n\t}\n\n\t \n}\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %ps: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}\n\nstatic struct inode *jfs_alloc_inode(struct super_block *sb)\n{\n\tstruct jfs_inode_info *jfs_inode;\n\n\tjfs_inode = alloc_inode_sb(sb, jfs_inode_cachep, GFP_NOFS);\n\tif (!jfs_inode)\n\t\treturn NULL;\n#ifdef CONFIG_QUOTA\n\tmemset(&jfs_inode->i_dquot, 0, sizeof(jfs_inode->i_dquot));\n#endif\n\treturn &jfs_inode->vfs_inode;\n}\n\nstatic void jfs_free_inode(struct inode *inode)\n{\n\tkmem_cache_free(jfs_inode_cachep, JFS_IP(inode));\n}\n\nstatic int jfs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(dentry->d_sb);\n\ts64 maxinodes;\n\tstruct inomap *imap = JFS_IP(sbi->ipimap)->i_imap;\n\n\tjfs_info(\"In jfs_statfs\");\n\tbuf->f_type = JFS_SUPER_MAGIC;\n\tbuf->f_bsize = sbi->bsize;\n\tbuf->f_blocks = sbi->bmap->db_mapsize;\n\tbuf->f_bfree = sbi->bmap->db_nfree;\n\tbuf->f_bavail = sbi->bmap->db_nfree;\n\t \n\tmaxinodes = min((s64) atomic_read(&imap->im_numinos) +\n\t\t\t((sbi->bmap->db_nfree >> imap->im_l2nbperiext)\n\t\t\t << L2INOSPEREXT), (s64) 0xffffffffLL);\n\tbuf->f_files = maxinodes;\n\tbuf->f_ffree = maxinodes - (atomic_read(&imap->im_numinos) -\n\t\t\t\t    atomic_read(&imap->im_numfree));\n\tbuf->f_fsid.val[0] = crc32_le(0, (char *)&sbi->uuid,\n\t\t\t\t      sizeof(sbi->uuid)/2);\n\tbuf->f_fsid.val[1] = crc32_le(0,\n\t\t\t\t      (char *)&sbi->uuid + sizeof(sbi->uuid)/2,\n\t\t\t\t      sizeof(sbi->uuid)/2);\n\n\tbuf->f_namelen = JFS_NAME_MAX;\n\treturn 0;\n}\n\n#ifdef CONFIG_QUOTA\nstatic int jfs_quota_off(struct super_block *sb, int type);\nstatic int jfs_quota_on(struct super_block *sb, int type, int format_id,\n\t\t\tconst struct path *path);\n\nstatic void jfs_quota_off_umount(struct super_block *sb)\n{\n\tint type;\n\n\tfor (type = 0; type < MAXQUOTAS; type++)\n\t\tjfs_quota_off(sb, type);\n}\n\nstatic const struct quotactl_ops jfs_quotactl_ops = {\n\t.quota_on\t= jfs_quota_on,\n\t.quota_off\t= jfs_quota_off,\n\t.quota_sync\t= dquot_quota_sync,\n\t.get_state\t= dquot_get_state,\n\t.set_info\t= dquot_set_dqinfo,\n\t.get_dqblk\t= dquot_get_dqblk,\n\t.set_dqblk\t= dquot_set_dqblk,\n\t.get_nextdqblk\t= dquot_get_next_dqblk,\n};\n#else\nstatic inline void jfs_quota_off_umount(struct super_block *sb)\n{\n}\n#endif\n\nstatic void jfs_put_super(struct super_block *sb)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tint rc;\n\n\tjfs_info(\"In jfs_put_super\");\n\n\tjfs_quota_off_umount(sb);\n\n\trc = jfs_umount(sb);\n\tif (rc)\n\t\tjfs_err(\"jfs_umount failed with return code %d\", rc);\n\n\tunload_nls(sbi->nls_tab);\n\n\ttruncate_inode_pages(sbi->direct_inode->i_mapping, 0);\n\tiput(sbi->direct_inode);\n\n\tkfree(sbi);\n}\n\nenum {\n\tOpt_integrity, Opt_nointegrity, Opt_iocharset, Opt_resize,\n\tOpt_resize_nosize, Opt_errors, Opt_ignore, Opt_err, Opt_quota,\n\tOpt_usrquota, Opt_grpquota, Opt_uid, Opt_gid, Opt_umask,\n\tOpt_discard, Opt_nodiscard, Opt_discard_minblk\n};\n\nstatic const match_table_t tokens = {\n\t{Opt_integrity, \"integrity\"},\n\t{Opt_nointegrity, \"nointegrity\"},\n\t{Opt_iocharset, \"iocharset=%s\"},\n\t{Opt_resize, \"resize=%u\"},\n\t{Opt_resize_nosize, \"resize\"},\n\t{Opt_errors, \"errors=%s\"},\n\t{Opt_ignore, \"noquota\"},\n\t{Opt_quota, \"quota\"},\n\t{Opt_usrquota, \"usrquota\"},\n\t{Opt_grpquota, \"grpquota\"},\n\t{Opt_uid, \"uid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_umask, \"umask=%u\"},\n\t{Opt_discard, \"discard\"},\n\t{Opt_nodiscard, \"nodiscard\"},\n\t{Opt_discard_minblk, \"discard=%u\"},\n\t{Opt_err, NULL}\n};\n\nstatic int parse_options(char *options, struct super_block *sb, s64 *newLVSize,\n\t\t\t int *flag)\n{\n\tvoid *nls_map = (void *)-1;\t \n\tchar *p;\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\n\t*newLVSize = 0;\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_integrity:\n\t\t\t*flag &= ~JFS_NOINTEGRITY;\n\t\t\tbreak;\n\t\tcase Opt_nointegrity:\n\t\t\t*flag |= JFS_NOINTEGRITY;\n\t\t\tbreak;\n\t\tcase Opt_ignore:\n\t\t\t \n\t\t\t \n\t\t\tbreak;\n\t\tcase Opt_iocharset:\n\t\t\tif (nls_map && nls_map != (void *) -1)\n\t\t\t\tunload_nls(nls_map);\n\t\t\tif (!strcmp(args[0].from, \"none\"))\n\t\t\t\tnls_map = NULL;\n\t\t\telse {\n\t\t\t\tnls_map = load_nls(args[0].from);\n\t\t\t\tif (!nls_map) {\n\t\t\t\t\tpr_err(\"JFS: charset not found\\n\");\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_resize:\n\t\t{\n\t\t\tchar *resize = args[0].from;\n\t\t\tint rc = kstrtoll(resize, 0, newLVSize);\n\n\t\t\tif (rc)\n\t\t\t\tgoto cleanup;\n\t\t\tbreak;\n\t\t}\n\t\tcase Opt_resize_nosize:\n\t\t{\n\t\t\t*newLVSize = sb_bdev_nr_blocks(sb);\n\t\t\tif (*newLVSize == 0)\n\t\t\t\tpr_err(\"JFS: Cannot determine volume size\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tcase Opt_errors:\n\t\t{\n\t\t\tchar *errors = args[0].from;\n\t\t\tif (!errors || !*errors)\n\t\t\t\tgoto cleanup;\n\t\t\tif (!strcmp(errors, \"continue\")) {\n\t\t\t\t*flag &= ~JFS_ERR_REMOUNT_RO;\n\t\t\t\t*flag &= ~JFS_ERR_PANIC;\n\t\t\t\t*flag |= JFS_ERR_CONTINUE;\n\t\t\t} else if (!strcmp(errors, \"remount-ro\")) {\n\t\t\t\t*flag &= ~JFS_ERR_CONTINUE;\n\t\t\t\t*flag &= ~JFS_ERR_PANIC;\n\t\t\t\t*flag |= JFS_ERR_REMOUNT_RO;\n\t\t\t} else if (!strcmp(errors, \"panic\")) {\n\t\t\t\t*flag &= ~JFS_ERR_CONTINUE;\n\t\t\t\t*flag &= ~JFS_ERR_REMOUNT_RO;\n\t\t\t\t*flag |= JFS_ERR_PANIC;\n\t\t\t} else {\n\t\t\t\tpr_err(\"JFS: %s is an invalid error handler\\n\",\n\t\t\t\t       errors);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n#ifdef CONFIG_QUOTA\n\t\tcase Opt_quota:\n\t\tcase Opt_usrquota:\n\t\t\t*flag |= JFS_USRQUOTA;\n\t\t\tbreak;\n\t\tcase Opt_grpquota:\n\t\t\t*flag |= JFS_GRPQUOTA;\n\t\t\tbreak;\n#else\n\t\tcase Opt_usrquota:\n\t\tcase Opt_grpquota:\n\t\tcase Opt_quota:\n\t\t\tpr_err(\"JFS: quota operations not supported\\n\");\n\t\t\tbreak;\n#endif\n\t\tcase Opt_uid:\n\t\t{\n\t\t\tchar *uid = args[0].from;\n\t\t\tuid_t val;\n\t\t\tint rc = kstrtouint(uid, 0, &val);\n\n\t\t\tif (rc)\n\t\t\t\tgoto cleanup;\n\t\t\tsbi->uid = make_kuid(current_user_ns(), val);\n\t\t\tif (!uid_valid(sbi->uid))\n\t\t\t\tgoto cleanup;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Opt_gid:\n\t\t{\n\t\t\tchar *gid = args[0].from;\n\t\t\tgid_t val;\n\t\t\tint rc = kstrtouint(gid, 0, &val);\n\n\t\t\tif (rc)\n\t\t\t\tgoto cleanup;\n\t\t\tsbi->gid = make_kgid(current_user_ns(), val);\n\t\t\tif (!gid_valid(sbi->gid))\n\t\t\t\tgoto cleanup;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Opt_umask:\n\t\t{\n\t\t\tchar *umask = args[0].from;\n\t\t\tint rc = kstrtouint(umask, 8, &sbi->umask);\n\n\t\t\tif (rc)\n\t\t\t\tgoto cleanup;\n\t\t\tif (sbi->umask & ~0777) {\n\t\t\t\tpr_err(\"JFS: Invalid value of umask\\n\");\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Opt_discard:\n\t\t\t \n\t\t\tsbi->minblks_trim = 64;\n\t\t\tif (bdev_max_discard_sectors(sb->s_bdev))\n\t\t\t\t*flag |= JFS_DISCARD;\n\t\t\telse\n\t\t\t\tpr_err(\"JFS: discard option not supported on device\\n\");\n\t\t\tbreak;\n\n\t\tcase Opt_nodiscard:\n\t\t\t*flag &= ~JFS_DISCARD;\n\t\t\tbreak;\n\n\t\tcase Opt_discard_minblk:\n\t\t{\n\t\t\tchar *minblks_trim = args[0].from;\n\t\t\tint rc;\n\t\t\tif (bdev_max_discard_sectors(sb->s_bdev)) {\n\t\t\t\t*flag |= JFS_DISCARD;\n\t\t\t\trc = kstrtouint(minblks_trim, 0,\n\t\t\t\t\t\t&sbi->minblks_trim);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto cleanup;\n\t\t\t} else\n\t\t\t\tpr_err(\"JFS: discard option not supported on device\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tdefault:\n\t\t\tprintk(\"jfs: Unrecognized mount option \\\"%s\\\" or missing value\\n\",\n\t\t\t       p);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tif (nls_map != (void *) -1) {\n\t\t \n\t\tunload_nls(sbi->nls_tab);\n\t\tsbi->nls_tab = nls_map;\n\t}\n\treturn 1;\n\ncleanup:\n\tif (nls_map && nls_map != (void *) -1)\n\t\tunload_nls(nls_map);\n\treturn 0;\n}\n\nstatic int jfs_remount(struct super_block *sb, int *flags, char *data)\n{\n\ts64 newLVSize = 0;\n\tint rc = 0;\n\tint flag = JFS_SBI(sb)->flag;\n\tint ret;\n\n\tsync_filesystem(sb);\n\tif (!parse_options(data, sb, &newLVSize, &flag))\n\t\treturn -EINVAL;\n\n\tif (newLVSize) {\n\t\tif (sb_rdonly(sb)) {\n\t\t\tpr_err(\"JFS: resize requires volume to be mounted read-write\\n\");\n\t\t\treturn -EROFS;\n\t\t}\n\t\trc = jfs_extendfs(sb, newLVSize, 0);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tif (sb_rdonly(sb) && !(*flags & SB_RDONLY)) {\n\t\t \n\t\ttruncate_inode_pages(JFS_SBI(sb)->direct_inode->i_mapping, 0);\n\n\t\tJFS_SBI(sb)->flag = flag;\n\t\tret = jfs_mount_rw(sb, 1);\n\n\t\t \n\t\tsb->s_flags &= ~SB_RDONLY;\n\n\t\tdquot_resume(sb, -1);\n\t\treturn ret;\n\t}\n\tif (!sb_rdonly(sb) && (*flags & SB_RDONLY)) {\n\t\trc = dquot_suspend(sb, -1);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\trc = jfs_umount_rw(sb);\n\t\tJFS_SBI(sb)->flag = flag;\n\t\treturn rc;\n\t}\n\tif ((JFS_SBI(sb)->flag & JFS_NOINTEGRITY) != (flag & JFS_NOINTEGRITY))\n\t\tif (!sb_rdonly(sb)) {\n\t\t\trc = jfs_umount_rw(sb);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tJFS_SBI(sb)->flag = flag;\n\t\t\tret = jfs_mount_rw(sb, 1);\n\t\t\treturn ret;\n\t\t}\n\tJFS_SBI(sb)->flag = flag;\n\n\treturn 0;\n}\n\nstatic int jfs_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct jfs_sb_info *sbi;\n\tstruct inode *inode;\n\tint rc;\n\ts64 newLVSize = 0;\n\tint flag, ret = -EINVAL;\n\n\tjfs_info(\"In jfs_read_super: s_flags=0x%lx\", sb->s_flags);\n\n\tsbi = kzalloc(sizeof(struct jfs_sb_info), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\n\tsb->s_fs_info = sbi;\n\tsb->s_max_links = JFS_LINK_MAX;\n\tsb->s_time_min = 0;\n\tsb->s_time_max = U32_MAX;\n\tsbi->sb = sb;\n\tsbi->uid = INVALID_UID;\n\tsbi->gid = INVALID_GID;\n\tsbi->umask = -1;\n\n\t \n\tflag = JFS_ERR_REMOUNT_RO;\n\n\tif (!parse_options((char *) data, sb, &newLVSize, &flag))\n\t\tgoto out_kfree;\n\tsbi->flag = flag;\n\n#ifdef CONFIG_JFS_POSIX_ACL\n\tsb->s_flags |= SB_POSIXACL;\n#endif\n\n\tif (newLVSize) {\n\t\tpr_err(\"resize option for remount only\\n\");\n\t\tgoto out_kfree;\n\t}\n\n\t \n\tsb_set_blocksize(sb, PSIZE);\n\n\t \n\tsb->s_op = &jfs_super_operations;\n\tsb->s_export_op = &jfs_export_operations;\n\tsb->s_xattr = jfs_xattr_handlers;\n#ifdef CONFIG_QUOTA\n\tsb->dq_op = &dquot_operations;\n\tsb->s_qcop = &jfs_quotactl_ops;\n\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP;\n#endif\n\n\t \n\tinode = new_inode(sb);\n\tif (inode == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out_unload;\n\t}\n\tinode->i_size = bdev_nr_bytes(sb->s_bdev);\n\tinode->i_mapping->a_ops = &jfs_metapage_aops;\n\tinode_fake_hash(inode);\n\tmapping_set_gfp_mask(inode->i_mapping, GFP_NOFS);\n\n\tsbi->direct_inode = inode;\n\n\trc = jfs_mount(sb);\n\tif (rc) {\n\t\tif (!silent)\n\t\t\tjfs_err(\"jfs_mount failed w/return code = %d\", rc);\n\t\tgoto out_mount_failed;\n\t}\n\tif (sb_rdonly(sb))\n\t\tsbi->log = NULL;\n\telse {\n\t\trc = jfs_mount_rw(sb, 0);\n\t\tif (rc) {\n\t\t\tif (!silent) {\n\t\t\t\tjfs_err(\"jfs_mount_rw failed, return code = %d\",\n\t\t\t\t\trc);\n\t\t\t}\n\t\t\tgoto out_no_rw;\n\t\t}\n\t}\n\n\tsb->s_magic = JFS_SUPER_MAGIC;\n\n\tif (sbi->mntflag & JFS_OS2)\n\t\tsb->s_d_op = &jfs_ci_dentry_operations;\n\n\tinode = jfs_iget(sb, ROOT_I);\n\tif (IS_ERR(inode)) {\n\t\tret = PTR_ERR(inode);\n\t\tgoto out_no_rw;\n\t}\n\tsb->s_root = d_make_root(inode);\n\tif (!sb->s_root)\n\t\tgoto out_no_root;\n\n\t \n\tsb->s_maxbytes = min(((loff_t)sb->s_blocksize) << 40, MAX_LFS_FILESIZE);\n\tsb->s_time_gran = 1;\n\treturn 0;\n\nout_no_root:\n\tjfs_err(\"jfs_read_super: get root dentry failed\");\n\nout_no_rw:\n\trc = jfs_umount(sb);\n\tif (rc)\n\t\tjfs_err(\"jfs_umount failed with return code %d\", rc);\nout_mount_failed:\n\tfilemap_write_and_wait(sbi->direct_inode->i_mapping);\n\ttruncate_inode_pages(sbi->direct_inode->i_mapping, 0);\n\tmake_bad_inode(sbi->direct_inode);\n\tiput(sbi->direct_inode);\n\tsbi->direct_inode = NULL;\nout_unload:\n\tunload_nls(sbi->nls_tab);\nout_kfree:\n\tkfree(sbi);\n\treturn ret;\n}\n\nstatic int jfs_freeze(struct super_block *sb)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct jfs_log *log = sbi->log;\n\tint rc = 0;\n\n\tif (!sb_rdonly(sb)) {\n\t\ttxQuiesce(sb);\n\t\trc = lmLogShutdown(log);\n\t\tif (rc) {\n\t\t\tjfs_error(sb, \"lmLogShutdown failed\\n\");\n\n\t\t\t \n\t\t\ttxResume(sb);\n\n\t\t\treturn rc;\n\t\t}\n\t\trc = updateSuper(sb, FM_CLEAN);\n\t\tif (rc) {\n\t\t\tjfs_err(\"jfs_freeze: updateSuper failed\");\n\t\t\t \n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int jfs_unfreeze(struct super_block *sb)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct jfs_log *log = sbi->log;\n\tint rc = 0;\n\n\tif (!sb_rdonly(sb)) {\n\t\trc = updateSuper(sb, FM_MOUNT);\n\t\tif (rc) {\n\t\t\tjfs_error(sb, \"updateSuper failed\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\trc = lmLogInit(log);\n\t\tif (rc)\n\t\t\tjfs_error(sb, \"lmLogInit failed\\n\");\nout:\n\t\ttxResume(sb);\n\t}\n\treturn rc;\n}\n\nstatic struct dentry *jfs_do_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, jfs_fill_super);\n}\n\nstatic int jfs_sync_fs(struct super_block *sb, int wait)\n{\n\tstruct jfs_log *log = JFS_SBI(sb)->log;\n\n\t \n\tif (log) {\n\t\t \n\t\tdquot_writeback_dquots(sb, -1);\n\t\tjfs_flush_journal(log, wait);\n\t\tjfs_syncpt(log, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic int jfs_show_options(struct seq_file *seq, struct dentry *root)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(root->d_sb);\n\n\tif (uid_valid(sbi->uid))\n\t\tseq_printf(seq, \",uid=%d\", from_kuid(&init_user_ns, sbi->uid));\n\tif (gid_valid(sbi->gid))\n\t\tseq_printf(seq, \",gid=%d\", from_kgid(&init_user_ns, sbi->gid));\n\tif (sbi->umask != -1)\n\t\tseq_printf(seq, \",umask=%03o\", sbi->umask);\n\tif (sbi->flag & JFS_NOINTEGRITY)\n\t\tseq_puts(seq, \",nointegrity\");\n\tif (sbi->flag & JFS_DISCARD)\n\t\tseq_printf(seq, \",discard=%u\", sbi->minblks_trim);\n\tif (sbi->nls_tab)\n\t\tseq_printf(seq, \",iocharset=%s\", sbi->nls_tab->charset);\n\tif (sbi->flag & JFS_ERR_CONTINUE)\n\t\tseq_printf(seq, \",errors=continue\");\n\tif (sbi->flag & JFS_ERR_PANIC)\n\t\tseq_printf(seq, \",errors=panic\");\n\n#ifdef CONFIG_QUOTA\n\tif (sbi->flag & JFS_USRQUOTA)\n\t\tseq_puts(seq, \",usrquota\");\n\n\tif (sbi->flag & JFS_GRPQUOTA)\n\t\tseq_puts(seq, \",grpquota\");\n#endif\n\n\treturn 0;\n}\n\n#ifdef CONFIG_QUOTA\n\n \nstatic ssize_t jfs_quota_read(struct super_block *sb, int type, char *data,\n\t\t\t      size_t len, loff_t off)\n{\n\tstruct inode *inode = sb_dqopt(sb)->files[type];\n\tsector_t blk = off >> sb->s_blocksize_bits;\n\tint err = 0;\n\tint offset = off & (sb->s_blocksize - 1);\n\tint tocopy;\n\tsize_t toread;\n\tstruct buffer_head tmp_bh;\n\tstruct buffer_head *bh;\n\tloff_t i_size = i_size_read(inode);\n\n\tif (off > i_size)\n\t\treturn 0;\n\tif (off+len > i_size)\n\t\tlen = i_size-off;\n\ttoread = len;\n\twhile (toread > 0) {\n\t\ttocopy = min_t(size_t, sb->s_blocksize - offset, toread);\n\n\t\ttmp_bh.b_state = 0;\n\t\ttmp_bh.b_size = i_blocksize(inode);\n\t\terr = jfs_get_block(inode, blk, &tmp_bh, 0);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (!buffer_mapped(&tmp_bh))\t \n\t\t\tmemset(data, 0, tocopy);\n\t\telse {\n\t\t\tbh = sb_bread(sb, tmp_bh.b_blocknr);\n\t\t\tif (!bh)\n\t\t\t\treturn -EIO;\n\t\t\tmemcpy(data, bh->b_data+offset, tocopy);\n\t\t\tbrelse(bh);\n\t\t}\n\t\toffset = 0;\n\t\ttoread -= tocopy;\n\t\tdata += tocopy;\n\t\tblk++;\n\t}\n\treturn len;\n}\n\n \nstatic ssize_t jfs_quota_write(struct super_block *sb, int type,\n\t\t\t       const char *data, size_t len, loff_t off)\n{\n\tstruct inode *inode = sb_dqopt(sb)->files[type];\n\tsector_t blk = off >> sb->s_blocksize_bits;\n\tint err = 0;\n\tint offset = off & (sb->s_blocksize - 1);\n\tint tocopy;\n\tsize_t towrite = len;\n\tstruct buffer_head tmp_bh;\n\tstruct buffer_head *bh;\n\n\tinode_lock(inode);\n\twhile (towrite > 0) {\n\t\ttocopy = min_t(size_t, sb->s_blocksize - offset, towrite);\n\n\t\ttmp_bh.b_state = 0;\n\t\ttmp_bh.b_size = i_blocksize(inode);\n\t\terr = jfs_get_block(inode, blk, &tmp_bh, 1);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (offset || tocopy != sb->s_blocksize)\n\t\t\tbh = sb_bread(sb, tmp_bh.b_blocknr);\n\t\telse\n\t\t\tbh = sb_getblk(sb, tmp_bh.b_blocknr);\n\t\tif (!bh) {\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tlock_buffer(bh);\n\t\tmemcpy(bh->b_data+offset, data, tocopy);\n\t\tflush_dcache_page(bh->b_page);\n\t\tset_buffer_uptodate(bh);\n\t\tmark_buffer_dirty(bh);\n\t\tunlock_buffer(bh);\n\t\tbrelse(bh);\n\t\toffset = 0;\n\t\ttowrite -= tocopy;\n\t\tdata += tocopy;\n\t\tblk++;\n\t}\nout:\n\tif (len == towrite) {\n\t\tinode_unlock(inode);\n\t\treturn err;\n\t}\n\tif (inode->i_size < off+len-towrite)\n\t\ti_size_write(inode, off+len-towrite);\n\tinode->i_mtime = inode_set_ctime_current(inode);\n\tmark_inode_dirty(inode);\n\tinode_unlock(inode);\n\treturn len - towrite;\n}\n\nstatic struct dquot **jfs_get_dquots(struct inode *inode)\n{\n\treturn JFS_IP(inode)->i_dquot;\n}\n\nstatic int jfs_quota_on(struct super_block *sb, int type, int format_id,\n\t\t\tconst struct path *path)\n{\n\tint err;\n\tstruct inode *inode;\n\n\terr = dquot_quota_on(sb, type, format_id, path);\n\tif (err)\n\t\treturn err;\n\n\tinode = d_inode(path->dentry);\n\tinode_lock(inode);\n\tJFS_IP(inode)->mode2 |= JFS_NOATIME_FL | JFS_IMMUTABLE_FL;\n\tinode_set_flags(inode, S_NOATIME | S_IMMUTABLE,\n\t\t\tS_NOATIME | S_IMMUTABLE);\n\tinode_unlock(inode);\n\tmark_inode_dirty(inode);\n\n\treturn 0;\n}\n\nstatic int jfs_quota_off(struct super_block *sb, int type)\n{\n\tstruct inode *inode = sb_dqopt(sb)->files[type];\n\tint err;\n\n\tif (!inode || !igrab(inode))\n\t\tgoto out;\n\n\terr = dquot_quota_off(sb, type);\n\tif (err)\n\t\tgoto out_put;\n\n\tinode_lock(inode);\n\tJFS_IP(inode)->mode2 &= ~(JFS_NOATIME_FL | JFS_IMMUTABLE_FL);\n\tinode_set_flags(inode, 0, S_NOATIME | S_IMMUTABLE);\n\tinode_unlock(inode);\n\tmark_inode_dirty(inode);\nout_put:\n\tiput(inode);\n\treturn err;\nout:\n\treturn dquot_quota_off(sb, type);\n}\n#endif\n\nstatic const struct super_operations jfs_super_operations = {\n\t.alloc_inode\t= jfs_alloc_inode,\n\t.free_inode\t= jfs_free_inode,\n\t.dirty_inode\t= jfs_dirty_inode,\n\t.write_inode\t= jfs_write_inode,\n\t.evict_inode\t= jfs_evict_inode,\n\t.put_super\t= jfs_put_super,\n\t.sync_fs\t= jfs_sync_fs,\n\t.freeze_fs\t= jfs_freeze,\n\t.unfreeze_fs\t= jfs_unfreeze,\n\t.statfs\t\t= jfs_statfs,\n\t.remount_fs\t= jfs_remount,\n\t.show_options\t= jfs_show_options,\n#ifdef CONFIG_QUOTA\n\t.quota_read\t= jfs_quota_read,\n\t.quota_write\t= jfs_quota_write,\n\t.get_dquots\t= jfs_get_dquots,\n#endif\n};\n\nstatic const struct export_operations jfs_export_operations = {\n\t.fh_to_dentry\t= jfs_fh_to_dentry,\n\t.fh_to_parent\t= jfs_fh_to_parent,\n\t.get_parent\t= jfs_get_parent,\n};\n\nstatic struct file_system_type jfs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"jfs\",\n\t.mount\t\t= jfs_do_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\nMODULE_ALIAS_FS(\"jfs\");\n\nstatic void init_once(void *foo)\n{\n\tstruct jfs_inode_info *jfs_ip = (struct jfs_inode_info *) foo;\n\n\tmemset(jfs_ip, 0, sizeof(struct jfs_inode_info));\n\tINIT_LIST_HEAD(&jfs_ip->anon_inode_list);\n\tinit_rwsem(&jfs_ip->rdwrlock);\n\tmutex_init(&jfs_ip->commit_mutex);\n\tinit_rwsem(&jfs_ip->xattr_sem);\n\tspin_lock_init(&jfs_ip->ag_lock);\n\tjfs_ip->active_ag = -1;\n\tinode_init_once(&jfs_ip->vfs_inode);\n}\n\nstatic int __init init_jfs_fs(void)\n{\n\tint i;\n\tint rc;\n\n\tjfs_inode_cachep =\n\t    kmem_cache_create_usercopy(\"jfs_ip\", sizeof(struct jfs_inode_info),\n\t\t\t0, SLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD|SLAB_ACCOUNT,\n\t\t\toffsetof(struct jfs_inode_info, i_inline_all),\n\t\t\tsizeof_field(struct jfs_inode_info, i_inline_all),\n\t\t\tinit_once);\n\tif (jfs_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\n\t \n\trc = metapage_init();\n\tif (rc) {\n\t\tjfs_err(\"metapage_init failed w/rc = %d\", rc);\n\t\tgoto free_slab;\n\t}\n\n\t \n\trc = txInit();\n\tif (rc) {\n\t\tjfs_err(\"txInit failed w/rc = %d\", rc);\n\t\tgoto free_metapage;\n\t}\n\n\t \n\tjfsIOthread = kthread_run(jfsIOWait, NULL, \"jfsIO\");\n\tif (IS_ERR(jfsIOthread)) {\n\t\trc = PTR_ERR(jfsIOthread);\n\t\tjfs_err(\"init_jfs_fs: fork failed w/rc = %d\", rc);\n\t\tgoto end_txmngr;\n\t}\n\n\tif (commit_threads < 1)\n\t\tcommit_threads = num_online_cpus();\n\tif (commit_threads > MAX_COMMIT_THREADS)\n\t\tcommit_threads = MAX_COMMIT_THREADS;\n\n\tfor (i = 0; i < commit_threads; i++) {\n\t\tjfsCommitThread[i] = kthread_run(jfs_lazycommit, NULL,\n\t\t\t\t\t\t \"jfsCommit\");\n\t\tif (IS_ERR(jfsCommitThread[i])) {\n\t\t\trc = PTR_ERR(jfsCommitThread[i]);\n\t\t\tjfs_err(\"init_jfs_fs: fork failed w/rc = %d\", rc);\n\t\t\tcommit_threads = i;\n\t\t\tgoto kill_committask;\n\t\t}\n\t}\n\n\tjfsSyncThread = kthread_run(jfs_sync, NULL, \"jfsSync\");\n\tif (IS_ERR(jfsSyncThread)) {\n\t\trc = PTR_ERR(jfsSyncThread);\n\t\tjfs_err(\"init_jfs_fs: fork failed w/rc = %d\", rc);\n\t\tgoto kill_committask;\n\t}\n\n#ifdef PROC_FS_JFS\n\tjfs_proc_init();\n#endif\n\n\trc = register_filesystem(&jfs_fs_type);\n\tif (!rc)\n\t\treturn 0;\n\n#ifdef PROC_FS_JFS\n\tjfs_proc_clean();\n#endif\n\tkthread_stop(jfsSyncThread);\nkill_committask:\n\tfor (i = 0; i < commit_threads; i++)\n\t\tkthread_stop(jfsCommitThread[i]);\n\tkthread_stop(jfsIOthread);\nend_txmngr:\n\ttxExit();\nfree_metapage:\n\tmetapage_exit();\nfree_slab:\n\tkmem_cache_destroy(jfs_inode_cachep);\n\treturn rc;\n}\n\nstatic void __exit exit_jfs_fs(void)\n{\n\tint i;\n\n\tjfs_info(\"exit_jfs_fs called\");\n\n\ttxExit();\n\tmetapage_exit();\n\n\tkthread_stop(jfsIOthread);\n\tfor (i = 0; i < commit_threads; i++)\n\t\tkthread_stop(jfsCommitThread[i]);\n\tkthread_stop(jfsSyncThread);\n#ifdef PROC_FS_JFS\n\tjfs_proc_clean();\n#endif\n\tunregister_filesystem(&jfs_fs_type);\n\n\t \n\trcu_barrier();\n\tkmem_cache_destroy(jfs_inode_cachep);\n}\n\nmodule_init(init_jfs_fs)\nmodule_exit(exit_jfs_fs)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}