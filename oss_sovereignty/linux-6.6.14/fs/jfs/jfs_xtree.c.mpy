{
  "module_name": "jfs_xtree.c",
  "hash_id": "e116e013a293148de654e9b5aa514e227d6b544167aa19de77d9e0a519316a72",
  "original_prompt": "Ingested from linux-6.6.14/fs/jfs/jfs_xtree.c",
  "human_readable_source": "\n \n \n\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include \"jfs_incore.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_debug.h\"\n\n \n#define XT_INSERT\t0x00000001\n\n \n#define XT_CMP(CMP, K, X, OFFSET64)\\\n{\\\n\tOFFSET64 = offsetXAD(X);\\\n\t(CMP) = ((K) >= OFFSET64 + lengthXAD(X)) ? 1 :\\\n\t\t((K) < OFFSET64) ? -1 : 0;\\\n}\n\n \n#define XT_PUTENTRY(XAD, FLAG, OFF, LEN, ADDR)\\\n{\\\n\t(XAD)->flag = (FLAG);\\\n\tXADoffset((XAD), (OFF));\\\n\tXADlength((XAD), (LEN));\\\n\tXADaddress((XAD), (ADDR));\\\n}\n\n#define XT_PAGE(IP, MP) BT_PAGE(IP, MP, xtpage_t, i_xtroot)\n\n \n \n#define XT_GETPAGE(IP, BN, MP, SIZE, P, RC)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tBT_GETPAGE(IP, BN, MP, xtpage_t, SIZE, P, RC, i_xtroot);\t\\\n\tif (!(RC)) {\t\t\t\t\t\t\t\\\n\t\tif ((le16_to_cpu((P)->header.nextindex) < XTENTRYSTART) || \\\n\t\t    (le16_to_cpu((P)->header.nextindex) >\t\t\\\n\t\t     le16_to_cpu((P)->header.maxentry)) ||\t\t\\\n\t\t    (le16_to_cpu((P)->header.maxentry) >\t\t\\\n\t\t     (((BN) == 0) ? XTROOTMAXSLOT : PSIZE >> L2XTSLOTSIZE))) { \\\n\t\t\tjfs_error((IP)->i_sb,\t\t\t\t\\\n\t\t\t\t  \"XT_GETPAGE: xtree page corrupt\\n\");\t\\\n\t\t\tBT_PUTPAGE(MP);\t\t\t\t\t\\\n\t\t\tMP = NULL;\t\t\t\t\t\\\n\t\t\tRC = -EIO;\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\n \n#define XT_PUTPAGE(MP) BT_PUTPAGE(MP)\n\n#define XT_GETSEARCH(IP, LEAF, BN, MP, P, INDEX) \\\n\tBT_GETSEARCH(IP, LEAF, BN, MP, xtpage_t, P, INDEX, i_xtroot)\n \nstruct xtsplit {\n\tstruct metapage *mp;\n\ts16 index;\n\tu8 flag;\n\ts64 off;\n\ts64 addr;\n\tint len;\n\tstruct pxdlist *pxdlist;\n};\n\n\n \n#ifdef CONFIG_JFS_STATISTICS\nstatic struct {\n\tuint search;\n\tuint fastSearch;\n\tuint split;\n} xtStat;\n#endif\n\n\n \nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\n\nstatic int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);\n\nstatic int xtSplitPage(tid_t tid, struct inode *ip, struct xtsplit * split,\n\t\t       struct metapage ** rmpp, s64 * rbnp);\n\nstatic int xtSplitRoot(tid_t tid, struct inode *ip,\n\t\t       struct xtsplit * split, struct metapage ** rmpp);\n\n \nint xtLookup(struct inode *ip, s64 lstart,\n\t     s64 llen, int *pflag, s64 * paddr, s32 * plen, int no_check)\n{\n\tint rc = 0;\n\tstruct btstack btstack;\n\tint cmp;\n\ts64 bn;\n\tstruct metapage *mp;\n\txtpage_t *p;\n\tint index;\n\txad_t *xad;\n\ts64 next, size, xoff, xend;\n\tint xlen;\n\ts64 xaddr;\n\n\t*paddr = 0;\n\t*plen = llen;\n\n\tif (!no_check) {\n\t\t \n\t\tsize = ((u64) ip->i_size + (JFS_SBI(ip->i_sb)->bsize - 1)) >>\n\t\t    JFS_SBI(ip->i_sb)->l2bsize;\n\t\tif (lstart >= size)\n\t\t\treturn 0;\n\t}\n\n\t \n\n\tif ((rc = xtSearch(ip, lstart, &next, &cmp, &btstack, 0))) {\n\t\tjfs_err(\"xtLookup: xtSearch returned %d\", rc);\n\t\treturn rc;\n\t}\n\n\t \n\t \n\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\t \n\tif (cmp) {\n\t\tif (next)\n\t\t\t*plen = min(next - lstart, llen);\n\t\tgoto out;\n\t}\n\n\t \n\txad = &p->xad[index];\n\txoff = offsetXAD(xad);\n\txlen = lengthXAD(xad);\n\txend = xoff + xlen;\n\txaddr = addressXAD(xad);\n\n\t \n\t*pflag = xad->flag;\n\t*paddr = xaddr + (lstart - xoff);\n\t \n\t*plen = min(xend - lstart, llen);\n\n      out:\n\tXT_PUTPAGE(mp);\n\n\treturn rc;\n}\n\n \nstatic int xtSearch(struct inode *ip, s64 xoff,\ts64 *nextp,\n\t\t    int *cmpp, struct btstack * btstack, int flag)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint rc = 0;\n\tint cmp = 1;\t\t \n\ts64 bn;\t\t\t \n\tstruct metapage *mp;\t \n\txtpage_t *p;\t\t \n\txad_t *xad;\n\tint base, index, lim, btindex;\n\tstruct btframe *btsp;\n\tint nsplit = 0;\t\t \n\ts64 t64;\n\ts64 next = 0;\n\n\tINCREMENT(xtStat.search);\n\n\tBT_CLR(btstack);\n\n\tbtstack->nsplit = 0;\n\n\t \n\tfor (bn = 0;;) {\n\t\t \n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t \n\n\t\tif ((jfs_ip->btorder & BT_SEQUENTIAL) &&\n\t\t    (p->header.flag & BT_LEAF) &&\n\t\t    (index = jfs_ip->btindex) <\n\t\t    le16_to_cpu(p->header.nextindex)) {\n\t\t\txad = &p->xad[index];\n\t\t\tt64 = offsetXAD(xad);\n\t\t\tif (xoff < t64 + lengthXAD(xad)) {\n\t\t\t\tif (xoff >= t64) {\n\t\t\t\t\t*cmpp = 0;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tgoto binarySearch;\n\t\t\t} else {\t \n\n\t\t\t\t \n\t\t\t\tindex++;\n\t\t\t\tif (index <\n\t\t\t\t    le16_to_cpu(p->header.nextindex)) {\n\t\t\t\t\txad++;\n\t\t\t\t\tt64 = offsetXAD(xad);\n\t\t\t\t\tif (xoff < t64 + lengthXAD(xad)) {\n\t\t\t\t\t\tif (xoff >= t64) {\n\t\t\t\t\t\t\t*cmpp = 0;\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t \n\t\t\t\t\t\t*cmpp = 1;\n\t\t\t\t\t\tnext = t64;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t \n\t\t\t\t\t \n\t\t\t\t\tgoto binarySearch;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\t*cmpp = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t \n\t\t      out:\n\t\t\t \n\t\t\tif (flag & XT_INSERT) {\n\t\t\t\tif (p->header.nextindex ==\t \n\t\t\t\t    p->header.maxentry)\n\t\t\t\t\tnsplit++;\n\t\t\t\telse\n\t\t\t\t\tnsplit = 0;\n\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t}\n\n\t\t\t \n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = index;\n\t\t\tbtsp->mp = mp;\n\n\t\t\t \n\t\t\tjfs_ip->btindex = index;\n\n\t\t\tif (nextp)\n\t\t\t\t*nextp = next;\n\n\t\t\tINCREMENT(xtStat.fastSearch);\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t      binarySearch:\n\t\tlim = le16_to_cpu(p->header.nextindex) - XTENTRYSTART;\n\n\t\t \n\t\tfor (base = XTENTRYSTART; lim; lim >>= 1) {\n\t\t\tindex = base + (lim >> 1);\n\n\t\t\tXT_CMP(cmp, xoff, &p->xad[index], t64);\n\t\t\tif (cmp == 0) {\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t\t*cmpp = cmp;\n\n\t\t\t\t\t \n\t\t\t\t\tif (flag & XT_INSERT) {\n\t\t\t\t\t\tif (p->header.nextindex ==\n\t\t\t\t\t\t    p->header.maxentry)\n\t\t\t\t\t\t\tnsplit++;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tnsplit = 0;\n\t\t\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t\t\t}\n\n\t\t\t\t\t \n\t\t\t\t\tbtsp = btstack->top;\n\t\t\t\t\tbtsp->bn = bn;\n\t\t\t\t\tbtsp->index = index;\n\t\t\t\t\tbtsp->mp = mp;\n\n\t\t\t\t\t \n\t\t\t\t\tbtindex = jfs_ip->btindex;\n\t\t\t\t\tif (index == btindex ||\n\t\t\t\t\t    index == btindex + 1)\n\t\t\t\t\t\tjfs_ip->btorder = BT_SEQUENTIAL;\n\t\t\t\t\telse\n\t\t\t\t\t\tjfs_ip->btorder = BT_RANDOM;\n\t\t\t\t\tjfs_ip->btindex = index;\n\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tif (index < le16_to_cpu(p->header.nextindex)-1)\n\t\t\t\t\tnext = offsetXAD(&p->xad[index + 1]);\n\t\t\t\tgoto next;\n\t\t\t}\n\n\t\t\tif (cmp > 0) {\n\t\t\t\tbase = index + 1;\n\t\t\t\t--lim;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (base < le16_to_cpu(p->header.nextindex))\n\t\t\tnext = offsetXAD(&p->xad[base]);\n\t\t \n\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t*cmpp = cmp;\n\n\t\t\t \n\t\t\tif (flag & XT_INSERT) {\n\t\t\t\tif (p->header.nextindex ==\n\t\t\t\t    p->header.maxentry)\n\t\t\t\t\tnsplit++;\n\t\t\t\telse\n\t\t\t\t\tnsplit = 0;\n\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t}\n\n\t\t\t \n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = base;\n\t\t\tbtsp->mp = mp;\n\n\t\t\t \n\t\t\tbtindex = jfs_ip->btindex;\n\t\t\tif (base == btindex || base == btindex + 1)\n\t\t\t\tjfs_ip->btorder = BT_SEQUENTIAL;\n\t\t\telse\n\t\t\t\tjfs_ip->btorder = BT_RANDOM;\n\t\t\tjfs_ip->btindex = base;\n\n\t\t\tif (nextp)\n\t\t\t\t*nextp = next;\n\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tindex = base ? base - 1 : base;\n\n\t\t \n\t      next:\n\t\t \n\t\tif (p->header.nextindex == p->header.maxentry)\n\t\t\tnsplit++;\n\t\telse\n\t\t\tnsplit = 0;\n\n\t\t \n\t\tif (BT_STACK_FULL(btstack)) {\n\t\t\tjfs_error(ip->i_sb, \"stack overrun!\\n\");\n\t\t\tXT_PUTPAGE(mp);\n\t\t\treturn -EIO;\n\t\t}\n\t\tBT_PUSH(btstack, bn, index);\n\n\t\t \n\t\tbn = addressXAD(&p->xad[index]);\n\n\t\t \n\t\tXT_PUTPAGE(mp);\n\t}\n}\n\n \nint xtInsert(tid_t tid,\t\t \n\t     struct inode *ip, int xflag, s64 xoff, s32 xlen, s64 * xaddrp,\n\t     int flag)\n{\n\tint rc = 0;\n\ts64 xaddr, hint;\n\tstruct metapage *mp;\t \n\txtpage_t *p;\t\t \n\ts64 bn;\n\tint index, nextindex;\n\tstruct btstack btstack;\t \n\tstruct xtsplit split;\t \n\txad_t *xad;\n\tint cmp;\n\ts64 next;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\n\tjfs_info(\"xtInsert: nxoff:0x%lx nxlen:0x%x\", (ulong) xoff, xlen);\n\n\t \n\tif ((rc = xtSearch(ip, xoff, &next, &cmp, &btstack, XT_INSERT)))\n\t\treturn rc;\n\n\t \n\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\t \n\tif ((cmp == 0) || (next && (xlen > next - xoff))) {\n\t\trc = -EEXIST;\n\t\tgoto out;\n\t}\n\n\t \n\tif ((xaddr = *xaddrp) == 0) {\n\t\tif (index > XTENTRYSTART) {\n\t\t\txad = &p->xad[index - 1];\n\t\t\thint = addressXAD(xad) + lengthXAD(xad) - 1;\n\t\t} else\n\t\t\thint = 0;\n\t\tif ((rc = dquot_alloc_block(ip, xlen)))\n\t\t\tgoto out;\n\t\tif ((rc = dbAlloc(ip, hint, (s64) xlen, &xaddr))) {\n\t\t\tdquot_free_block(ip, xlen);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\txflag |= XAD_NEW;\n\n\t \n\tnextindex = le16_to_cpu(p->header.nextindex);\n\tif (nextindex == le16_to_cpu(p->header.maxentry)) {\n\t\tsplit.mp = mp;\n\t\tsplit.index = index;\n\t\tsplit.flag = xflag;\n\t\tsplit.off = xoff;\n\t\tsplit.len = xlen;\n\t\tsplit.addr = xaddr;\n\t\tsplit.pxdlist = NULL;\n\t\tif ((rc = xtSplitUp(tid, ip, &split, &btstack))) {\n\t\t\t \n\t\t\tif (*xaddrp == 0) {\n\t\t\t\tdbFree(ip, xaddr, (s64) xlen);\n\t\t\t\tdquot_free_block(ip, xlen);\n\t\t\t}\n\t\t\treturn rc;\n\t\t}\n\n\t\t*xaddrp = xaddr;\n\t\treturn 0;\n\t}\n\n\t \n\t \n\tBT_MARK_DIRTY(mp, ip);\n\n\t \n\tif (index < nextindex)\n\t\tmemmove(&p->xad[index + 1], &p->xad[index],\n\t\t\t(nextindex - index) * sizeof(xad_t));\n\n\t \n\txad = &p->xad[index];\n\tXT_PUTENTRY(xad, xflag, xoff, xlen, xaddr);\n\n\t \n\tle16_add_cpu(&p->header.nextindex, 1);\n\n\t \n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE | tlckGROW);\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\txtlck->lwm.offset =\n\t\t    (xtlck->lwm.offset) ? min(index,\n\t\t\t\t\t      (int)xtlck->lwm.offset) : index;\n\t\txtlck->lwm.length =\n\t\t    le16_to_cpu(p->header.nextindex) - xtlck->lwm.offset;\n\t}\n\n\t*xaddrp = xaddr;\n\n      out:\n\t \n\tXT_PUTPAGE(mp);\n\n\treturn rc;\n}\n\n\n \nstatic int\nxtSplitUp(tid_t tid,\n\t  struct inode *ip, struct xtsplit * split, struct btstack * btstack)\n{\n\tint rc = 0;\n\tstruct metapage *smp;\n\txtpage_t *sp;\t\t \n\tstruct metapage *rmp;\n\ts64 rbn;\t\t \n\tstruct metapage *rcmp;\n\txtpage_t *rcp;\t\t \n\ts64 rcbn;\t\t \n\tint skip;\t\t \n\tint nextindex;\t\t \n\tstruct btframe *parent;\t \n\txad_t *xad;\n\ts64 xaddr;\n\tint xlen;\n\tint nsplit;\t\t \n\tstruct pxdlist pxdlist;\n\tpxd_t *pxd;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\n\tsmp = split->mp;\n\tsp = XT_PAGE(ip, smp);\n\n\t \n\tif ((sp->header.flag & BT_ROOT) && (!S_ISDIR(ip->i_mode)) &&\n\t    (le16_to_cpu(sp->header.maxentry) < XTROOTMAXSLOT) &&\n\t    (JFS_IP(ip)->mode2 & INLINEEA)) {\n\t\tsp->header.maxentry = cpu_to_le16(XTROOTMAXSLOT);\n\t\tJFS_IP(ip)->mode2 &= ~INLINEEA;\n\n\t\tBT_MARK_DIRTY(smp, ip);\n\t\t \n\n\t\t \n\t\tskip = split->index;\n\t\tnextindex = le16_to_cpu(sp->header.nextindex);\n\t\tif (skip < nextindex)\n\t\t\tmemmove(&sp->xad[skip + 1], &sp->xad[skip],\n\t\t\t\t(nextindex - skip) * sizeof(xad_t));\n\n\t\t \n\t\txad = &sp->xad[skip];\n\t\tXT_PUTENTRY(xad, split->flag, split->off, split->len,\n\t\t\t    split->addr);\n\n\t\t \n\t\tle16_add_cpu(&sp->header.nextindex, 1);\n\n\t\t \n\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\ttlck = txLock(tid, ip, smp, tlckXTREE | tlckGROW);\n\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\txtlck->lwm.offset = (xtlck->lwm.offset) ?\n\t\t\t    min(skip, (int)xtlck->lwm.offset) : skip;\n\t\t\txtlck->lwm.length =\n\t\t\t    le16_to_cpu(sp->header.nextindex) -\n\t\t\t    xtlck->lwm.offset;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t \n\tif (split->pxdlist == NULL) {\n\t\tnsplit = btstack->nsplit;\n\t\tsplit->pxdlist = &pxdlist;\n\t\tpxdlist.maxnpxd = pxdlist.npxd = 0;\n\t\tpxd = &pxdlist.pxd[0];\n\t\txlen = JFS_SBI(ip->i_sb)->nbperpage;\n\t\tfor (; nsplit > 0; nsplit--, pxd++) {\n\t\t\tif ((rc = dbAlloc(ip, (s64) 0, (s64) xlen, &xaddr))\n\t\t\t    == 0) {\n\t\t\t\tPXDaddress(pxd, xaddr);\n\t\t\t\tPXDlength(pxd, xlen);\n\n\t\t\t\tpxdlist.maxnpxd++;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\n\t\t\tXT_PUTPAGE(smp);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\t \n\trc = (sp->header.flag & BT_ROOT) ?\n\t    xtSplitRoot(tid, ip, split, &rmp) :\n\t    xtSplitPage(tid, ip, split, &rmp, &rbn);\n\n\tXT_PUTPAGE(smp);\n\n\tif (rc)\n\t\treturn -EIO;\n\t \n\twhile ((parent = BT_POP(btstack)) != NULL) {\n\t\t \n\n\t\t \n\t\trcmp = rmp;\n\t\trcbn = rbn;\n\t\trcp = XT_PAGE(ip, rcmp);\n\n\t\t \n\t\t \n\t\tXT_GETPAGE(ip, parent->bn, smp, PSIZE, sp, rc);\n\t\tif (rc) {\n\t\t\tXT_PUTPAGE(rcmp);\n\t\t\treturn rc;\n\t\t}\n\n\t\t \n\t\tskip = parent->index + 1;\n\n\t\t \n\t\tnextindex = le16_to_cpu(sp->header.nextindex);\n\t\t \n\t\tif (nextindex == le16_to_cpu(sp->header.maxentry)) {\n\t\t\t \n\t\t\tsplit->mp = smp;\n\t\t\tsplit->index = skip;\t \n\t\t\tsplit->flag = XAD_NEW;\n\t\t\tsplit->off = offsetXAD(&rcp->xad[XTENTRYSTART]);\n\t\t\tsplit->len = JFS_SBI(ip->i_sb)->nbperpage;\n\t\t\tsplit->addr = rcbn;\n\n\t\t\t \n\t\t\tXT_PUTPAGE(rcmp);\n\n\t\t\t \n\t\t\trc = (sp->header.flag & BT_ROOT) ?\n\t\t\t    xtSplitRoot(tid, ip, split, &rmp) :\n\t\t\t    xtSplitPage(tid, ip, split, &rmp, &rbn);\n\t\t\tif (rc) {\n\t\t\t\tXT_PUTPAGE(smp);\n\t\t\t\treturn rc;\n\t\t\t}\n\n\t\t\tXT_PUTPAGE(smp);\n\t\t\t \n\t\t}\n\t\t \n\t\telse {\n\t\t\t \n\t\t\t \n\t\t\tBT_MARK_DIRTY(smp, ip);\n\n\t\t\t \n\t\t\tif (skip < nextindex)\n\t\t\t\tmemmove(&sp->xad[skip + 1], &sp->xad[skip],\n\t\t\t\t\t(nextindex -\n\t\t\t\t\t skip) << L2XTSLOTSIZE);\n\n\t\t\t \n\t\t\txad = &sp->xad[skip];\n\t\t\tXT_PUTENTRY(xad, XAD_NEW,\n\t\t\t\t    offsetXAD(&rcp->xad[XTENTRYSTART]),\n\t\t\t\t    JFS_SBI(ip->i_sb)->nbperpage, rcbn);\n\n\t\t\t \n\t\t\tle16_add_cpu(&sp->header.nextindex, 1);\n\n\t\t\t \n\t\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\t\ttlck = txLock(tid, ip, smp,\n\t\t\t\t\t      tlckXTREE | tlckGROW);\n\t\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\t\txtlck->lwm.offset = (xtlck->lwm.offset) ?\n\t\t\t\t    min(skip, (int)xtlck->lwm.offset) : skip;\n\t\t\t\txtlck->lwm.length =\n\t\t\t\t    le16_to_cpu(sp->header.nextindex) -\n\t\t\t\t    xtlck->lwm.offset;\n\t\t\t}\n\n\t\t\t \n\t\t\tXT_PUTPAGE(smp);\n\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tXT_PUTPAGE(rmp);\n\n\treturn 0;\n}\n\n\n \nstatic int\nxtSplitPage(tid_t tid, struct inode *ip,\n\t    struct xtsplit * split, struct metapage ** rmpp, s64 * rbnp)\n{\n\tint rc = 0;\n\tstruct metapage *smp;\n\txtpage_t *sp;\n\tstruct metapage *rmp;\n\txtpage_t *rp;\t\t \n\ts64 rbn;\t\t \n\tstruct metapage *mp;\n\txtpage_t *p;\n\ts64 nextbn;\n\tint skip, maxentry, middle, righthalf, n;\n\txad_t *xad;\n\tstruct pxdlist *pxdlist;\n\tpxd_t *pxd;\n\tstruct tlock *tlck;\n\tstruct xtlock *sxtlck = NULL, *rxtlck = NULL;\n\tint quota_allocation = 0;\n\n\tsmp = split->mp;\n\tsp = XT_PAGE(ip, smp);\n\n\tINCREMENT(xtStat.split);\n\n\tpxdlist = split->pxdlist;\n\tpxd = &pxdlist->pxd[pxdlist->npxd];\n\tpxdlist->npxd++;\n\trbn = addressPXD(pxd);\n\n\t \n\trc = dquot_alloc_block(ip, lengthPXD(pxd));\n\tif (rc)\n\t\tgoto clean_up;\n\n\tquota_allocation += lengthPXD(pxd);\n\n\t \n\trmp = get_metapage(ip, rbn, PSIZE, 1);\n\tif (rmp == NULL) {\n\t\trc = -EIO;\n\t\tgoto clean_up;\n\t}\n\n\tjfs_info(\"xtSplitPage: ip:0x%p smp:0x%p rmp:0x%p\", ip, smp, rmp);\n\n\tBT_MARK_DIRTY(rmp, ip);\n\t \n\n\trp = (xtpage_t *) rmp->data;\n\trp->header.self = *pxd;\n\trp->header.flag = sp->header.flag & BT_TYPE;\n\trp->header.maxentry = sp->header.maxentry;\t \n\trp->header.nextindex = cpu_to_le16(XTENTRYSTART);\n\n\tBT_MARK_DIRTY(smp, ip);\n\t \n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t \n\t\ttlck = txLock(tid, ip, rmp, tlckXTREE | tlckNEW);\n\t\trxtlck = (struct xtlock *) & tlck->lock;\n\t\trxtlck->lwm.offset = XTENTRYSTART;\n\t\t \n\t\ttlck = txLock(tid, ip, smp, tlckXTREE | tlckGROW);\n\t\tsxtlck = (struct xtlock *) & tlck->lock;\n\t}\n\n\t \n\tnextbn = le64_to_cpu(sp->header.next);\n\trp->header.next = cpu_to_le64(nextbn);\n\trp->header.prev = cpu_to_le64(addressPXD(&sp->header.self));\n\tsp->header.next = cpu_to_le64(rbn);\n\n\tskip = split->index;\n\n\t \n\tif (nextbn == 0 && skip == le16_to_cpu(sp->header.maxentry)) {\n\t\t \n\t\t \n\t\txad = &rp->xad[XTENTRYSTART];\n\t\tXT_PUTENTRY(xad, split->flag, split->off, split->len,\n\t\t\t    split->addr);\n\n\t\trp->header.nextindex = cpu_to_le16(XTENTRYSTART + 1);\n\n\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\t \n\t\t\trxtlck->lwm.length = 1;\n\t\t}\n\n\t\t*rmpp = rmp;\n\t\t*rbnp = rbn;\n\n\t\tjfs_info(\"xtSplitPage: sp:0x%p rp:0x%p\", sp, rp);\n\t\treturn 0;\n\t}\n\n\t \n\n\t \n\tif (nextbn != 0) {\n\t\tXT_GETPAGE(ip, nextbn, mp, PSIZE, p, rc);\n\t\tif (rc) {\n\t\t\tXT_PUTPAGE(rmp);\n\t\t\tgoto clean_up;\n\t\t}\n\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\t \n\t\tif (!test_cflag(COMMIT_Nolink, ip))\n\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE | tlckRELINK);\n\n\t\tp->header.prev = cpu_to_le64(rbn);\n\n\t\t \n\n\t\tXT_PUTPAGE(mp);\n\t}\n\n\t \n\tmaxentry = le16_to_cpu(sp->header.maxentry);\n\tmiddle = maxentry >> 1;\n\trighthalf = maxentry - middle;\n\n\t \n\tif (skip <= middle) {\n\t\t \n\t\tmemmove(&rp->xad[XTENTRYSTART], &sp->xad[middle],\n\t\t\trighthalf << L2XTSLOTSIZE);\n\n\t\t \n\t\tif (skip < middle)\n\t\t\tmemmove(&sp->xad[skip + 1], &sp->xad[skip],\n\t\t\t\t(middle - skip) << L2XTSLOTSIZE);\n\n\t\t \n\t\txad = &sp->xad[skip];\n\t\tXT_PUTENTRY(xad, split->flag, split->off, split->len,\n\t\t\t    split->addr);\n\n\t\t \n\t\tsp->header.nextindex = cpu_to_le16(middle + 1);\n\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\tsxtlck->lwm.offset = (sxtlck->lwm.offset) ?\n\t\t\t    min(skip, (int)sxtlck->lwm.offset) : skip;\n\t\t}\n\n\t\trp->header.nextindex =\n\t\t    cpu_to_le16(XTENTRYSTART + righthalf);\n\t}\n\t \n\telse {\n\t\t \n\t\tn = skip - middle;\n\t\tmemmove(&rp->xad[XTENTRYSTART], &sp->xad[middle],\n\t\t\tn << L2XTSLOTSIZE);\n\n\t\t \n\t\tn += XTENTRYSTART;\n\t\txad = &rp->xad[n];\n\t\tXT_PUTENTRY(xad, split->flag, split->off, split->len,\n\t\t\t    split->addr);\n\n\t\t \n\t\tif (skip < maxentry)\n\t\t\tmemmove(&rp->xad[n + 1], &sp->xad[skip],\n\t\t\t\t(maxentry - skip) << L2XTSLOTSIZE);\n\n\t\t \n\t\tsp->header.nextindex = cpu_to_le16(middle);\n\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\tsxtlck->lwm.offset = (sxtlck->lwm.offset) ?\n\t\t\t    min(middle, (int)sxtlck->lwm.offset) : middle;\n\t\t}\n\n\t\trp->header.nextindex = cpu_to_le16(XTENTRYSTART +\n\t\t\t\t\t\t   righthalf + 1);\n\t}\n\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\tsxtlck->lwm.length = le16_to_cpu(sp->header.nextindex) -\n\t\t    sxtlck->lwm.offset;\n\n\t\t \n\t\trxtlck->lwm.length = le16_to_cpu(rp->header.nextindex) -\n\t\t    XTENTRYSTART;\n\t}\n\n\t*rmpp = rmp;\n\t*rbnp = rbn;\n\n\tjfs_info(\"xtSplitPage: sp:0x%p rp:0x%p\", sp, rp);\n\treturn rc;\n\n      clean_up:\n\n\t \n\tif (quota_allocation)\n\t\tdquot_free_block(ip, quota_allocation);\n\n\treturn (rc);\n}\n\n\n \nstatic int\nxtSplitRoot(tid_t tid,\n\t    struct inode *ip, struct xtsplit * split, struct metapage ** rmpp)\n{\n\txtpage_t *sp;\n\tstruct metapage *rmp;\n\txtpage_t *rp;\n\ts64 rbn;\n\tint skip, nextindex;\n\txad_t *xad;\n\tpxd_t *pxd;\n\tstruct pxdlist *pxdlist;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tint rc;\n\n\tsp = &JFS_IP(ip)->i_xtroot;\n\n\tINCREMENT(xtStat.split);\n\n\t \n\tpxdlist = split->pxdlist;\n\tpxd = &pxdlist->pxd[pxdlist->npxd];\n\tpxdlist->npxd++;\n\trbn = addressPXD(pxd);\n\trmp = get_metapage(ip, rbn, PSIZE, 1);\n\tif (rmp == NULL)\n\t\treturn -EIO;\n\n\t \n\trc = dquot_alloc_block(ip, lengthPXD(pxd));\n\tif (rc) {\n\t\trelease_metapage(rmp);\n\t\treturn rc;\n\t}\n\n\tjfs_info(\"xtSplitRoot: ip:0x%p rmp:0x%p\", ip, rmp);\n\n\t \n\tBT_MARK_DIRTY(rmp, ip);\n\n\trp = (xtpage_t *) rmp->data;\n\trp->header.flag =\n\t    (sp->header.flag & BT_LEAF) ? BT_LEAF : BT_INTERNAL;\n\trp->header.self = *pxd;\n\trp->header.nextindex = cpu_to_le16(XTENTRYSTART);\n\trp->header.maxentry = cpu_to_le16(PSIZE >> L2XTSLOTSIZE);\n\n\t \n\trp->header.next = 0;\n\trp->header.prev = 0;\n\n\t \n\tnextindex = le16_to_cpu(sp->header.maxentry);\n\tmemmove(&rp->xad[XTENTRYSTART], &sp->xad[XTENTRYSTART],\n\t\t(nextindex - XTENTRYSTART) << L2XTSLOTSIZE);\n\n\t \n\tskip = split->index;\n\t \n\tif (skip != nextindex)\n\t\tmemmove(&rp->xad[skip + 1], &rp->xad[skip],\n\t\t\t(nextindex - skip) * sizeof(xad_t));\n\n\txad = &rp->xad[skip];\n\tXT_PUTENTRY(xad, split->flag, split->off, split->len, split->addr);\n\n\t \n\trp->header.nextindex = cpu_to_le16(nextindex + 1);\n\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\ttlck = txLock(tid, ip, rmp, tlckXTREE | tlckNEW);\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\txtlck->lwm.length = le16_to_cpu(rp->header.nextindex) -\n\t\t    XTENTRYSTART;\n\t}\n\n\t \n\t \n\tBT_MARK_DIRTY(split->mp, ip);\n\n\txad = &sp->xad[XTENTRYSTART];\n\tXT_PUTENTRY(xad, XAD_NEW, 0, JFS_SBI(ip->i_sb)->nbperpage, rbn);\n\n\t \n\tsp->header.flag &= ~BT_LEAF;\n\tsp->header.flag |= BT_INTERNAL;\n\n\tsp->header.nextindex = cpu_to_le16(XTENTRYSTART + 1);\n\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\ttlck = txLock(tid, ip, split->mp, tlckXTREE | tlckGROW);\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\txtlck->lwm.length = 1;\n\t}\n\n\t*rmpp = rmp;\n\n\tjfs_info(\"xtSplitRoot: sp:0x%p rp:0x%p\", sp, rp);\n\treturn 0;\n}\n\n\n \nint xtExtend(tid_t tid,\t\t \n\t     struct inode *ip, s64 xoff,\t \n\t     s32 xlen,\t\t \n\t     int flag)\n{\n\tint rc = 0;\n\tint cmp;\n\tstruct metapage *mp;\t \n\txtpage_t *p;\t\t \n\ts64 bn;\n\tint index, nextindex, len;\n\tstruct btstack btstack;\t \n\tstruct xtsplit split;\t \n\txad_t *xad;\n\ts64 xaddr;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck = NULL;\n\n\tjfs_info(\"xtExtend: nxoff:0x%lx nxlen:0x%x\", (ulong) xoff, xlen);\n\n\t \n\tif ((rc = xtSearch(ip, xoff - 1, NULL, &cmp, &btstack, XT_INSERT)))\n\t\treturn rc;\n\n\t \n\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\tif (cmp != 0) {\n\t\tXT_PUTPAGE(mp);\n\t\tjfs_error(ip->i_sb, \"xtSearch did not find extent\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\txad = &p->xad[index];\n\tif ((offsetXAD(xad) + lengthXAD(xad)) != xoff) {\n\t\tXT_PUTPAGE(mp);\n\t\tjfs_error(ip->i_sb, \"extension is not contiguous\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tBT_MARK_DIRTY(mp, ip);\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE | tlckGROW);\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t}\n\n\t \n\txlen = lengthXAD(xad) + xlen;\n\tif ((len = xlen - MAXXLEN) <= 0)\n\t\tgoto extendOld;\n\n\t \n\n\txoff = offsetXAD(xad) + MAXXLEN;\n\txaddr = addressXAD(xad) + MAXXLEN;\n\tnextindex = le16_to_cpu(p->header.nextindex);\n\n\t \n\tif (nextindex == le16_to_cpu(p->header.maxentry)) {\n\t\t \n\t\tsplit.mp = mp;\n\t\tsplit.index = index + 1;\n\t\tsplit.flag = XAD_NEW;\n\t\tsplit.off = xoff;\t \n\t\tsplit.len = len;\n\t\tsplit.addr = xaddr;\n\t\tsplit.pxdlist = NULL;\n\t\tif ((rc = xtSplitUp(tid, ip, &split, &btstack)))\n\t\t\treturn rc;\n\n\t\t \n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\t \n\t\tif (p->header.flag & BT_INTERNAL) {\n\t\t\tASSERT(p->header.nextindex ==\n\t\t\t       cpu_to_le16(XTENTRYSTART + 1));\n\t\t\txad = &p->xad[XTENTRYSTART];\n\t\t\tbn = addressXAD(xad);\n\t\t\tXT_PUTPAGE(mp);\n\n\t\t\t \n\t\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tBT_MARK_DIRTY(mp, ip);\n\t\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE|tlckGROW);\n\t\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\t}\n\t\t}\n\t}\n\t \n\telse {\n\t\t \n\t\txad = &p->xad[index + 1];\n\t\tXT_PUTENTRY(xad, XAD_NEW, xoff, len, xaddr);\n\n\t\t \n\t\tle16_add_cpu(&p->header.nextindex, 1);\n\t}\n\n\t \n\txad = &p->xad[index];\n\txlen = MAXXLEN;\n\n\t \n      extendOld:\n\tXADlength(xad, xlen);\n\tif (!(xad->flag & XAD_NEW))\n\t\txad->flag |= XAD_EXTENDED;\n\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\txtlck->lwm.offset =\n\t\t    (xtlck->lwm.offset) ? min(index,\n\t\t\t\t\t      (int)xtlck->lwm.offset) : index;\n\t\txtlck->lwm.length =\n\t\t    le16_to_cpu(p->header.nextindex) - xtlck->lwm.offset;\n\t}\n\n\t \n\tXT_PUTPAGE(mp);\n\n\treturn rc;\n}\n\n \nint xtUpdate(tid_t tid, struct inode *ip, xad_t * nxad)\n{\t\t\t\t \n\tint rc = 0;\n\tint cmp;\n\tstruct metapage *mp;\t \n\txtpage_t *p;\t\t \n\ts64 bn;\n\tint index0, index, newindex, nextindex;\n\tstruct btstack btstack;\t \n\tstruct xtsplit split;\t \n\txad_t *xad, *lxad, *rxad;\n\tint xflag;\n\ts64 nxoff, xoff;\n\tint nxlen, xlen, lxlen, rxlen;\n\ts64 nxaddr, xaddr;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck = NULL;\n\tint newpage = 0;\n\n\t \n\tnxoff = offsetXAD(nxad);\n\tnxlen = lengthXAD(nxad);\n\tnxaddr = addressXAD(nxad);\n\n\tif ((rc = xtSearch(ip, nxoff, NULL, &cmp, &btstack, XT_INSERT)))\n\t\treturn rc;\n\n\t \n\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index0);\n\n\tif (cmp != 0) {\n\t\tXT_PUTPAGE(mp);\n\t\tjfs_error(ip->i_sb, \"Could not find extent\\n\");\n\t\treturn -EIO;\n\t}\n\n\tBT_MARK_DIRTY(mp, ip);\n\t \n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE | tlckGROW);\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t}\n\n\txad = &p->xad[index0];\n\txflag = xad->flag;\n\txoff = offsetXAD(xad);\n\txlen = lengthXAD(xad);\n\txaddr = addressXAD(xad);\n\n\t \n\tif ((xoff > nxoff) ||\n\t    (nxoff + nxlen > xoff + xlen)) {\n\t\tXT_PUTPAGE(mp);\n\t\tjfs_error(ip->i_sb,\n\t\t\t  \"nXAD in not completely contained within XAD\\n\");\n\t\treturn -EIO;\n\t}\n\n\tindex = index0;\n\tnewindex = index + 1;\n\tnextindex = le16_to_cpu(p->header.nextindex);\n\n\tif (xoff < nxoff)\n\t\tgoto coalesceRight;\n\n\t \n\t \n\tif (index == XTENTRYSTART)\n\t\tgoto replace;\n\n\t \n\tlxad = &p->xad[index - 1];\n\tlxlen = lengthXAD(lxad);\n\tif (!(lxad->flag & XAD_NOTRECORDED) &&\n\t    (nxoff == offsetXAD(lxad) + lxlen) &&\n\t    (nxaddr == addressXAD(lxad) + lxlen) &&\n\t    (lxlen + nxlen < MAXXLEN)) {\n\t\t \n\t\tindex0 = index - 1;\n\t\tXADlength(lxad, lxlen + nxlen);\n\n\t\t \n\t\tif (!(lxad->flag & XAD_NEW))\n\t\t\tlxad->flag |= XAD_EXTENDED;\n\n\t\tif (xlen > nxlen) {\n\t\t\t \n\t\t\tXADoffset(xad, xoff + nxlen);\n\t\t\tXADlength(xad, xlen - nxlen);\n\t\t\tXADaddress(xad, xaddr + nxlen);\n\t\t\tgoto out;\n\t\t} else {\t \n\n\t\t\t \n\t\t\tif (index < nextindex - 1)\n\t\t\t\tmemmove(&p->xad[index], &p->xad[index + 1],\n\t\t\t\t\t(nextindex - index -\n\t\t\t\t\t 1) << L2XTSLOTSIZE);\n\n\t\t\tp->header.nextindex =\n\t\t\t    cpu_to_le16(le16_to_cpu(p->header.nextindex) -\n\t\t\t\t\t1);\n\n\t\t\tindex = index0;\n\t\t\tnewindex = index + 1;\n\t\t\tnextindex = le16_to_cpu(p->header.nextindex);\n\t\t\txoff = nxoff = offsetXAD(lxad);\n\t\t\txlen = nxlen = lxlen + nxlen;\n\t\t\txaddr = nxaddr = addressXAD(lxad);\n\t\t\tgoto coalesceRight;\n\t\t}\n\t}\n\n\t \n      replace:\t\t\t \n\tif (nxlen == xlen) {\n\t\t \n\t\t*xad = *nxad;\n\t\txad->flag = xflag & ~XAD_NOTRECORDED;\n\n\t\tgoto coalesceRight;\n\t} else\t\t\t \n\t\tgoto updateLeft;\n\n\t \n      coalesceRight:\t\t \n\t \n\tif (newindex == nextindex) {\n\t\tif (xoff == nxoff)\n\t\t\tgoto out;\n\t\tgoto updateRight;\n\t}\n\n\t \n\trxad = &p->xad[index + 1];\n\trxlen = lengthXAD(rxad);\n\tif (!(rxad->flag & XAD_NOTRECORDED) &&\n\t    (nxoff + nxlen == offsetXAD(rxad)) &&\n\t    (nxaddr + nxlen == addressXAD(rxad)) &&\n\t    (rxlen + nxlen < MAXXLEN)) {\n\t\t \n\t\tXADoffset(rxad, nxoff);\n\t\tXADlength(rxad, rxlen + nxlen);\n\t\tXADaddress(rxad, nxaddr);\n\n\t\t \n\t\tif (!(rxad->flag & XAD_NEW))\n\t\t\trxad->flag |= XAD_EXTENDED;\n\n\t\tif (xlen > nxlen)\n\t\t\t \n\t\t\tXADlength(xad, xlen - nxlen);\n\t\telse {\t\t \n\n\t\t\t \n\t\t\tmemmove(&p->xad[index], &p->xad[index + 1],\n\t\t\t\t(nextindex - index - 1) << L2XTSLOTSIZE);\n\n\t\t\tp->header.nextindex =\n\t\t\t    cpu_to_le16(le16_to_cpu(p->header.nextindex) -\n\t\t\t\t\t1);\n\t\t}\n\n\t\tgoto out;\n\t} else if (xoff == nxoff)\n\t\tgoto out;\n\n\tif (xoff >= nxoff) {\n\t\tXT_PUTPAGE(mp);\n\t\tjfs_error(ip->i_sb, \"xoff >= nxoff\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n      updateRight:\t\t \n\t \n\txad = &p->xad[index];\n\tXADlength(xad, nxoff - xoff);\n\n\t \n\tif (nextindex == le16_to_cpu(p->header.maxentry)) {\n\n\t\t \n\t\tsplit.mp = mp;\n\t\tsplit.index = newindex;\n\t\tsplit.flag = xflag & ~XAD_NOTRECORDED;\n\t\tsplit.off = nxoff;\n\t\tsplit.len = nxlen;\n\t\tsplit.addr = nxaddr;\n\t\tsplit.pxdlist = NULL;\n\t\tif ((rc = xtSplitUp(tid, ip, &split, &btstack)))\n\t\t\treturn rc;\n\n\t\t \n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\t \n\t\tif (p->header.flag & BT_INTERNAL) {\n\t\t\tASSERT(p->header.nextindex ==\n\t\t\t       cpu_to_le16(XTENTRYSTART + 1));\n\t\t\txad = &p->xad[XTENTRYSTART];\n\t\t\tbn = addressXAD(xad);\n\t\t\tXT_PUTPAGE(mp);\n\n\t\t\t \n\t\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tBT_MARK_DIRTY(mp, ip);\n\t\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE|tlckGROW);\n\t\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif (newindex >\n\t\t\t    (le16_to_cpu(p->header.maxentry) >> 1)) {\n\t\t\t\tnewindex =\n\t\t\t\t    newindex -\n\t\t\t\t    le16_to_cpu(p->header.nextindex) +\n\t\t\t\t    XTENTRYSTART;\n\t\t\t\tnewpage = 1;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\tif (newindex < nextindex)\n\t\t\tmemmove(&p->xad[newindex + 1], &p->xad[newindex],\n\t\t\t\t(nextindex - newindex) << L2XTSLOTSIZE);\n\n\t\t \n\t\txad = &p->xad[newindex];\n\t\t*xad = *nxad;\n\t\txad->flag = xflag & ~XAD_NOTRECORDED;\n\n\t\t \n\t\tp->header.nextindex =\n\t\t    cpu_to_le16(le16_to_cpu(p->header.nextindex) + 1);\n\t}\n\n\t \n\tif (nxoff + nxlen == xoff + xlen)\n\t\tgoto out;\n\n\t \n\tif (newpage) {\n\t\t \n\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\txtlck->lwm.offset = (xtlck->lwm.offset) ?\n\t\t\t    min(index0, (int)xtlck->lwm.offset) : index0;\n\t\t\txtlck->lwm.length =\n\t\t\t    le16_to_cpu(p->header.nextindex) -\n\t\t\t    xtlck->lwm.offset;\n\t\t}\n\n\t\tbn = le64_to_cpu(p->header.next);\n\t\tXT_PUTPAGE(mp);\n\n\t\t \n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE | tlckGROW);\n\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t}\n\n\t\tindex0 = index = newindex;\n\t} else\n\t\tindex++;\n\n\tnewindex = index + 1;\n\tnextindex = le16_to_cpu(p->header.nextindex);\n\txlen = xlen - (nxoff - xoff);\n\txoff = nxoff;\n\txaddr = nxaddr;\n\n\t \n\tif (nextindex == le16_to_cpu(p->header.maxentry)) {\n\t\tXT_PUTPAGE(mp);\n\n\t\tif ((rc = xtSearch(ip, nxoff, NULL, &cmp, &btstack, XT_INSERT)))\n\t\t\treturn rc;\n\n\t\t \n\t\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index0);\n\n\t\tif (cmp != 0) {\n\t\t\tXT_PUTPAGE(mp);\n\t\t\tjfs_error(ip->i_sb, \"xtSearch failed\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (index0 != index) {\n\t\t\tXT_PUTPAGE(mp);\n\t\t\tjfs_error(ip->i_sb, \"unexpected value of index\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\t \n      updateLeft:\t\t \n\t \n\txad = &p->xad[index];\n\t*xad = *nxad;\n\txad->flag = xflag & ~XAD_NOTRECORDED;\n\n\t \n\txoff = xoff + nxlen;\n\txlen = xlen - nxlen;\n\txaddr = xaddr + nxlen;\n\tif (nextindex == le16_to_cpu(p->header.maxentry)) {\n \n\t\t \n\t\tsplit.mp = mp;\n\t\tsplit.index = newindex;\n\t\tsplit.flag = xflag;\n\t\tsplit.off = xoff;\n\t\tsplit.len = xlen;\n\t\tsplit.addr = xaddr;\n\t\tsplit.pxdlist = NULL;\n\t\tif ((rc = xtSplitUp(tid, ip, &split, &btstack)))\n\t\t\treturn rc;\n\n\t\t \n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t \n\t\tif (p->header.flag & BT_INTERNAL) {\n\t\t\tASSERT(p->header.nextindex ==\n\t\t\t       cpu_to_le16(XTENTRYSTART + 1));\n\t\t\txad = &p->xad[XTENTRYSTART];\n\t\t\tbn = addressXAD(xad);\n\t\t\tXT_PUTPAGE(mp);\n\n\t\t\t \n\t\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tBT_MARK_DIRTY(mp, ip);\n\t\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE|tlckGROW);\n\t\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\tif (newindex < nextindex)\n\t\t\tmemmove(&p->xad[newindex + 1], &p->xad[newindex],\n\t\t\t\t(nextindex - newindex) << L2XTSLOTSIZE);\n\n\t\t \n\t\txad = &p->xad[newindex];\n\t\tXT_PUTENTRY(xad, xflag, xoff, xlen, xaddr);\n\n\t\t \n\t\tp->header.nextindex =\n\t\t    cpu_to_le16(le16_to_cpu(p->header.nextindex) + 1);\n\t}\n\n      out:\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\txtlck->lwm.offset = (xtlck->lwm.offset) ?\n\t\t    min(index0, (int)xtlck->lwm.offset) : index0;\n\t\txtlck->lwm.length = le16_to_cpu(p->header.nextindex) -\n\t\t    xtlck->lwm.offset;\n\t}\n\n\t \n\tXT_PUTPAGE(mp);\n\n\treturn rc;\n}\n\n\n \nint xtAppend(tid_t tid,\t\t \n\t     struct inode *ip, int xflag, s64 xoff, s32 maxblocks,\n\t     s32 * xlenp,\t \n\t     s64 * xaddrp,\t \n\t     int flag)\n{\n\tint rc = 0;\n\tstruct metapage *mp;\t \n\txtpage_t *p;\t\t \n\ts64 bn, xaddr;\n\tint index, nextindex;\n\tstruct btstack btstack;\t \n\tstruct xtsplit split;\t \n\txad_t *xad;\n\tint cmp;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tint nsplit, nblocks, xlen;\n\tstruct pxdlist pxdlist;\n\tpxd_t *pxd;\n\ts64 next;\n\n\txaddr = *xaddrp;\n\txlen = *xlenp;\n\tjfs_info(\"xtAppend: xoff:0x%lx maxblocks:%d xlen:%d xaddr:0x%lx\",\n\t\t (ulong) xoff, maxblocks, xlen, (ulong) xaddr);\n\n\t \n\tif ((rc = xtSearch(ip, xoff, &next, &cmp, &btstack, XT_INSERT)))\n\t\treturn rc;\n\n\t \n\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\tif (cmp == 0) {\n\t\trc = -EEXIST;\n\t\tgoto out;\n\t}\n\n\tif (next)\n\t\txlen = min(xlen, (int)(next - xoff));\n\n\t \n\txflag |= XAD_NEW;\n\n\t \n\tnextindex = le16_to_cpu(p->header.nextindex);\n\tif (nextindex < le16_to_cpu(p->header.maxentry))\n\t\tgoto insertLeaf;\n\n\t \n\tnsplit = btstack.nsplit;\n\tsplit.pxdlist = &pxdlist;\n\tpxdlist.maxnpxd = pxdlist.npxd = 0;\n\tpxd = &pxdlist.pxd[0];\n\tnblocks = JFS_SBI(ip->i_sb)->nbperpage;\n\tfor (; nsplit > 0; nsplit--, pxd++, xaddr += nblocks, maxblocks -= nblocks) {\n\t\tif ((rc = dbAllocBottomUp(ip, xaddr, (s64) nblocks)) == 0) {\n\t\t\tPXDaddress(pxd, xaddr);\n\t\t\tPXDlength(pxd, nblocks);\n\n\t\t\tpxdlist.maxnpxd++;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\n\t\tgoto out;\n\t}\n\n\txlen = min(xlen, maxblocks);\n\n\t \n\tif ((rc = dbAllocBottomUp(ip, xaddr, (s64) xlen)))\n\t\tgoto out;\n\n\tsplit.mp = mp;\n\tsplit.index = index;\n\tsplit.flag = xflag;\n\tsplit.off = xoff;\n\tsplit.len = xlen;\n\tsplit.addr = xaddr;\n\tif ((rc = xtSplitUp(tid, ip, &split, &btstack))) {\n\t\t \n\t\tdbFree(ip, *xaddrp, (s64) * xlenp);\n\n\t\treturn rc;\n\t}\n\n\t*xaddrp = xaddr;\n\t*xlenp = xlen;\n\treturn 0;\n\n\t \n      insertLeaf:\n\t \n\tif ((rc = dbAllocBottomUp(ip, xaddr, (s64) xlen)))\n\t\tgoto out;\n\n\tBT_MARK_DIRTY(mp, ip);\n\t \n\ttlck = txLock(tid, ip, mp, tlckXTREE | tlckGROW);\n\txtlck = (struct xtlock *) & tlck->lock;\n\n\t \n\txad = &p->xad[index];\n\tXT_PUTENTRY(xad, xflag, xoff, xlen, xaddr);\n\n\t \n\tle16_add_cpu(&p->header.nextindex, 1);\n\n\txtlck->lwm.offset =\n\t    (xtlck->lwm.offset) ? min(index,(int) xtlck->lwm.offset) : index;\n\txtlck->lwm.length = le16_to_cpu(p->header.nextindex) -\n\t    xtlck->lwm.offset;\n\n\t*xaddrp = xaddr;\n\t*xlenp = xlen;\n\n      out:\n\t \n\tXT_PUTPAGE(mp);\n\n\treturn rc;\n}\n\n \nvoid xtInitRoot(tid_t tid, struct inode *ip)\n{\n\txtpage_t *p;\n\n\t \n\ttxLock(tid, ip, (struct metapage *) &JFS_IP(ip)->bxflag,\n\t\t      tlckXTREE | tlckNEW);\n\tp = &JFS_IP(ip)->i_xtroot;\n\n\tp->header.flag = DXD_INDEX | BT_ROOT | BT_LEAF;\n\tp->header.nextindex = cpu_to_le16(XTENTRYSTART);\n\n\tif (S_ISDIR(ip->i_mode))\n\t\tp->header.maxentry = cpu_to_le16(XTROOTINITSLOT_DIR);\n\telse {\n\t\tp->header.maxentry = cpu_to_le16(XTROOTINITSLOT);\n\t\tip->i_size = 0;\n\t}\n\n\n\treturn;\n}\n\n\n \n#define MAX_TRUNCATE_LEAVES 50\n\n \ns64 xtTruncate(tid_t tid, struct inode *ip, s64 newsize, int flag)\n{\n\tint rc = 0;\n\ts64 teof;\n\tstruct metapage *mp;\n\txtpage_t *p;\n\ts64 bn;\n\tint index, nextindex;\n\txad_t *xad;\n\ts64 xoff, xaddr;\n\tint xlen, len, freexlen;\n\tstruct btstack btstack;\n\tstruct btframe *parent;\n\tstruct tblock *tblk = NULL;\n\tstruct tlock *tlck = NULL;\n\tstruct xtlock *xtlck = NULL;\n\tstruct xdlistlock xadlock;\t \n\tstruct pxd_lock *pxdlock;\t\t \n\ts64 nfreed;\n\tint freed, log;\n\tint locked_leaves = 0;\n\n\t \n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\ttblk->xflag |= flag;\n\t}\n\n\tnfreed = 0;\n\n\tflag &= COMMIT_MAP;\n\tassert(flag != COMMIT_PMAP);\n\n\tif (flag == COMMIT_PWMAP)\n\t\tlog = 1;\n\telse {\n\t\tlog = 0;\n\t\txadlock.flag = mlckFREEXADLIST;\n\t\txadlock.index = 1;\n\t}\n\n\t \n\n\t \n\tteof = (newsize + (JFS_SBI(ip->i_sb)->bsize - 1)) >>\n\t    JFS_SBI(ip->i_sb)->l2bsize;\n\n\t \n\tBT_CLR(&btstack);\n\n\t \n\tbn = 0;\n\n\t \n      getPage:\n\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tindex = le16_to_cpu(p->header.nextindex) - 1;\n\n\n\t \n\tif (p->header.next) {\n\t\tif (log)\n\t\t\t \n\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE|tlckGROW);\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\tp->header.next = 0;\n\t}\n\n\tif (p->header.flag & BT_INTERNAL)\n\t\tgoto getChild;\n\n\t \n\tfreed = 0;\n\n\t \n\txad = &p->xad[index];\n\txoff = offsetXAD(xad);\n\txlen = lengthXAD(xad);\n\tif (teof >= xoff + xlen) {\n\t\tXT_PUTPAGE(mp);\n\t\tgoto getParent;\n\t}\n\n\t \n\tif (log) {\n\t\tif (++locked_leaves > MAX_TRUNCATE_LEAVES) {\n\t\t\t \n\t\t\tXT_PUTPAGE(mp);\n\t\t\tnewsize = (xoff + xlen) << JFS_SBI(ip->i_sb)->l2bsize;\n\t\t\tgoto getParent;\n\t\t}\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\t\ttlck->type = tlckXTREE | tlckTRUNCATE;\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\txtlck->hwm.offset = le16_to_cpu(p->header.nextindex) - 1;\n\t}\n\tBT_MARK_DIRTY(mp, ip);\n\n\t \n\tfor (; index >= XTENTRYSTART; index--) {\n\t\txad = &p->xad[index];\n\t\txoff = offsetXAD(xad);\n\t\txlen = lengthXAD(xad);\n\t\txaddr = addressXAD(xad);\n\n\t\t \n\t\tif (S_ISDIR(ip->i_mode) && (teof == 0))\n\t\t\tinvalidate_xad_metapages(ip, *xad);\n\t\t \n\t\tif (teof < xoff) {\n\t\t\tnfreed += xlen;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\n\t\t \n\t\tif (teof == xoff) {\n\t\t\tnfreed += xlen;\n\n\t\t\tif (index == XTENTRYSTART)\n\t\t\t\tbreak;\n\n\t\t\tnextindex = index;\n\t\t}\n\t\t \n\t\telse if (teof < xoff + xlen) {\n\t\t\t \n\t\t\tlen = teof - xoff;\n\t\t\tfreexlen = xlen - len;\n\t\t\tXADlength(xad, len);\n\n\t\t\t \n\t\t\txaddr += len;\n\t\t\tif (log) {\t \n\t\t\t\txtlck->lwm.offset = (xtlck->lwm.offset) ?\n\t\t\t\t    min(index, (int)xtlck->lwm.offset) : index;\n\t\t\t\txtlck->lwm.length = index + 1 -\n\t\t\t\t    xtlck->lwm.offset;\n\t\t\t\txtlck->twm.offset = index;\n\t\t\t\tpxdlock = (struct pxd_lock *) & xtlck->pxdlock;\n\t\t\t\tpxdlock->flag = mlckFREEPXD;\n\t\t\t\tPXDaddress(&pxdlock->pxd, xaddr);\n\t\t\t\tPXDlength(&pxdlock->pxd, freexlen);\n\t\t\t}\n\t\t\t \n\t\t\telse {\t \n\n\t\t\t\tpxdlock = (struct pxd_lock *) & xadlock;\n\t\t\t\tpxdlock->flag = mlckFREEPXD;\n\t\t\t\tPXDaddress(&pxdlock->pxd, xaddr);\n\t\t\t\tPXDlength(&pxdlock->pxd, freexlen);\n\t\t\t\ttxFreeMap(ip, pxdlock, NULL, COMMIT_WMAP);\n\n\t\t\t\t \n\t\t\t\txadlock.flag = mlckFREEXADLIST;\n\t\t\t}\n\n\t\t\t \n\t\t\tnextindex = index + 1;\n\n\t\t\tnfreed += freexlen;\n\t\t}\n\t\t \n\t\telse {\t\t \n\n\t\t\tnextindex = index + 1;\n\t\t}\n\n\t\tif (nextindex < le16_to_cpu(p->header.nextindex)) {\n\t\t\tif (!log) {\t \n\t\t\t\txadlock.xdlist = &p->xad[nextindex];\n\t\t\t\txadlock.count =\n\t\t\t\t    le16_to_cpu(p->header.nextindex) -\n\t\t\t\t    nextindex;\n\t\t\t\ttxFreeMap(ip, (struct maplock *) & xadlock,\n\t\t\t\t\t  NULL, COMMIT_WMAP);\n\t\t\t}\n\t\t\tp->header.nextindex = cpu_to_le16(nextindex);\n\t\t}\n\n\t\tXT_PUTPAGE(mp);\n\n\t\t \n\t\tgoto getParent;\n\t}\t\t\t \n\n\tfreed = 1;\n\n\t \n\tif (log) {\t\t \n\t\t \n\t\ttlck->type = tlckXTREE | tlckFREE;\n\t} else {\t\t \n\n\t\t \n\t\txadlock.xdlist = &p->xad[XTENTRYSTART];\n\t\txadlock.count =\n\t\t    le16_to_cpu(p->header.nextindex) - XTENTRYSTART;\n\t\ttxFreeMap(ip, (struct maplock *) & xadlock, NULL, COMMIT_WMAP);\n\t}\n\n\tif (p->header.flag & BT_ROOT) {\n\t\tp->header.flag &= ~BT_INTERNAL;\n\t\tp->header.flag |= BT_LEAF;\n\t\tp->header.nextindex = cpu_to_le16(XTENTRYSTART);\n\n\t\tXT_PUTPAGE(mp);\t \n\t\tgoto out;\n\t} else {\n\t\tif (log) {\t \n\t\t\t \n\t\t\tXT_PUTPAGE(mp);\n\t\t} else {\t \n\n\t\t\tif (mp->lid)\n\t\t\t\tlid_to_tlock(mp->lid)->flag |= tlckFREELOCK;\n\n\t\t\t \n\t\t\tdiscard_metapage(mp);\n\t\t}\n\t}\n\n\t \n\n\t \n      getParent:\n\t \n\tif ((parent = BT_POP(&btstack)) == NULL)\n\t\t \n\t\tgoto out;\n\n\t \n\tbn = parent->bn;\n\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\tif (rc)\n\t\treturn rc;\n\n\tindex = parent->index;\n\n\t \n\tif (freed == 0) {\n\t\t \n\t\tif (index < le16_to_cpu(p->header.nextindex) - 1) {\n\t\t\t \n\t\t\tif (log) {\t \n\t\t\t\t \n\t\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\t\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\t\tif (!(tlck->type & tlckTRUNCATE)) {\n\t\t\t\t\txtlck->hwm.offset =\n\t\t\t\t\t    le16_to_cpu(p->header.\n\t\t\t\t\t\t\tnextindex) - 1;\n\t\t\t\t\ttlck->type =\n\t\t\t\t\t    tlckXTREE | tlckTRUNCATE;\n\t\t\t\t}\n\t\t\t} else {\t \n\n\t\t\t\t \n\t\t\t\txadlock.xdlist = &p->xad[index + 1];\n\t\t\t\txadlock.count =\n\t\t\t\t    le16_to_cpu(p->header.nextindex) -\n\t\t\t\t    index - 1;\n\t\t\t\ttxFreeMap(ip, (struct maplock *) & xadlock,\n\t\t\t\t\t  NULL, COMMIT_WMAP);\n\t\t\t}\n\t\t\tBT_MARK_DIRTY(mp, ip);\n\n\t\t\tp->header.nextindex = cpu_to_le16(index + 1);\n\t\t}\n\t\tXT_PUTPAGE(mp);\n\t\tgoto getParent;\n\t}\n\n\t \n\tnfreed += lengthXAD(&p->xad[index]);\n\n\t \n\n\t \n\tif (log && mp->lid && (tblk->last != mp->lid) &&\n\t    lid_to_tlock(mp->lid)->tid) {\n\t\tlid_t lid = mp->lid;\n\t\tstruct tlock *prev;\n\n\t\ttlck = lid_to_tlock(lid);\n\n\t\tif (tblk->next == lid)\n\t\t\ttblk->next = tlck->next;\n\t\telse {\n\t\t\tfor (prev = lid_to_tlock(tblk->next);\n\t\t\t     prev->next != lid;\n\t\t\t     prev = lid_to_tlock(prev->next)) {\n\t\t\t\tassert(prev->next);\n\t\t\t}\n\t\t\tprev->next = tlck->next;\n\t\t}\n\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\n\t \n\tif (index == XTENTRYSTART) {\n\t\tif (log) {\t \n\t\t\t \n\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\txtlck->hwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex) - 1;\n\t\t\ttlck->type = tlckXTREE | tlckFREE;\n\t\t} else {\t \n\n\t\t\t \n\t\t\txadlock.xdlist = &p->xad[XTENTRYSTART];\n\t\t\txadlock.count =\n\t\t\t    le16_to_cpu(p->header.nextindex) -\n\t\t\t    XTENTRYSTART;\n\t\t\ttxFreeMap(ip, (struct maplock *) & xadlock, NULL,\n\t\t\t\t  COMMIT_WMAP);\n\t\t}\n\t\tBT_MARK_DIRTY(mp, ip);\n\n\t\tif (p->header.flag & BT_ROOT) {\n\t\t\tp->header.flag &= ~BT_INTERNAL;\n\t\t\tp->header.flag |= BT_LEAF;\n\t\t\tp->header.nextindex = cpu_to_le16(XTENTRYSTART);\n\t\t\tif (le16_to_cpu(p->header.maxentry) == XTROOTMAXSLOT) {\n\t\t\t\t \n\t\t\t\tp->header.maxentry =\n\t\t\t\t    cpu_to_le16(XTROOTINITSLOT);\n\t\t\t\tJFS_IP(ip)->mode2 |= INLINEEA;\n\t\t\t}\n\n\t\t\tXT_PUTPAGE(mp);\t \n\t\t\tgoto out;\n\t\t} else {\n\t\t\tif (log) {\t \n\t\t\t\t \n\t\t\t\tXT_PUTPAGE(mp);\n\t\t\t} else {\t \n\n\t\t\t\tif (mp->lid)\n\t\t\t\t\tlid_to_tlock(mp->lid)->flag |=\n\t\t\t\t\t\ttlckFREELOCK;\n\n\t\t\t\t \n\t\t\t\tdiscard_metapage(mp);\n\t\t\t}\n\n\t\t\t \n\t\t\t \n\t\t\tgoto getParent;\n\t\t}\n\t}\n\t \n\telse {\n\t\t \n\t\tindex--;\n\n\t\t \n\t\tgoto getChild;\n\t}\n\n\t \n      getChild:\n\t \n\tif (BT_STACK_FULL(&btstack)) {\n\t\tjfs_error(ip->i_sb, \"stack overrun!\\n\");\n\t\tXT_PUTPAGE(mp);\n\t\treturn -EIO;\n\t}\n\tBT_PUSH(&btstack, bn, index);\n\n\t \n\txad = &p->xad[index];\n\tbn = addressXAD(xad);\n\n\t \n\t \n\tXT_PUTPAGE(mp);\n\n\t \n\tgoto getPage;\n\n      out:\n\t \n\t \n\tif (S_ISDIR(ip->i_mode) && !newsize)\n\t\tip->i_size = 1;\t \n\telse\n\t\tip->i_size = newsize;\n\n\t \n\tdquot_free_block(ip, nfreed);\n\n\t \n\tif (flag == COMMIT_WMAP)\n\t\ttxFreelock(ip);\n\n\treturn newsize;\n}\n\n\n \ns64 xtTruncate_pmap(tid_t tid, struct inode *ip, s64 committed_size)\n{\n\ts64 bn;\n\tstruct btstack btstack;\n\tint cmp;\n\tint index;\n\tint locked_leaves = 0;\n\tstruct metapage *mp;\n\txtpage_t *p;\n\tstruct btframe *parent;\n\tint rc;\n\tstruct tblock *tblk;\n\tstruct tlock *tlck = NULL;\n\txad_t *xad;\n\tint xlen;\n\ts64 xoff;\n\tstruct xtlock *xtlck = NULL;\n\n\t \n\ttblk = tid_to_tblock(tid);\n\ttblk->xflag |= COMMIT_PMAP;\n\n\t \n\tBT_CLR(&btstack);\n\n\tif (committed_size) {\n\t\txoff = (committed_size >> JFS_SBI(ip->i_sb)->l2bsize) - 1;\n\t\trc = xtSearch(ip, xoff, NULL, &cmp, &btstack, 0);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\t\tif (cmp != 0) {\n\t\t\tXT_PUTPAGE(mp);\n\t\t\tjfs_error(ip->i_sb, \"did not find extent\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t} else {\n\t\t \n\t\tbn = 0;\n\n\t\t \n      getPage:\n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t \n\t\tindex = le16_to_cpu(p->header.nextindex) - 1;\n\n\t\tif (p->header.flag & BT_INTERNAL)\n\t\t\tgoto getChild;\n\t}\n\n\t \n\n\tif (++locked_leaves > MAX_TRUNCATE_LEAVES) {\n\t\t \n\t\txad = &p->xad[index];\n\t\txoff = offsetXAD(xad);\n\t\txlen = lengthXAD(xad);\n\t\tXT_PUTPAGE(mp);\n\t\treturn (xoff + xlen) << JFS_SBI(ip->i_sb)->l2bsize;\n\t}\n\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\ttlck->type = tlckXTREE | tlckFREE;\n\txtlck = (struct xtlock *) & tlck->lock;\n\txtlck->hwm.offset = index;\n\n\n\tXT_PUTPAGE(mp);\n\n\t \n      getParent:\n\t \n\tif ((parent = BT_POP(&btstack)) == NULL)\n\t\t \n\t\tgoto out;\n\n\t \n\tbn = parent->bn;\n\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\tif (rc)\n\t\treturn rc;\n\n\tindex = parent->index;\n\n\t \n\tif (index == XTENTRYSTART) {\n\t\t \n\t\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\txtlck->hwm.offset = le16_to_cpu(p->header.nextindex) - 1;\n\t\ttlck->type = tlckXTREE | tlckFREE;\n\n\t\tXT_PUTPAGE(mp);\n\n\t\tif (p->header.flag & BT_ROOT) {\n\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tgoto getParent;\n\t\t}\n\t}\n\t \n\telse\n\t\tindex--;\n\t \n      getChild:\n\t \n\tif (BT_STACK_FULL(&btstack)) {\n\t\tjfs_error(ip->i_sb, \"stack overrun!\\n\");\n\t\tXT_PUTPAGE(mp);\n\t\treturn -EIO;\n\t}\n\tBT_PUSH(&btstack, bn, index);\n\n\t \n\txad = &p->xad[index];\n\tbn = addressXAD(xad);\n\n\t \n\t \n\tXT_PUTPAGE(mp);\n\n\t \n\tgoto getPage;\n\n      out:\n\n\treturn 0;\n}\n\n#ifdef CONFIG_JFS_STATISTICS\nint jfs_xtstat_proc_show(struct seq_file *m, void *v)\n{\n\tseq_printf(m,\n\t\t       \"JFS Xtree statistics\\n\"\n\t\t       \"====================\\n\"\n\t\t       \"searches = %d\\n\"\n\t\t       \"fast searches = %d\\n\"\n\t\t       \"splits = %d\\n\",\n\t\t       xtStat.search,\n\t\t       xtStat.fastSearch,\n\t\t       xtStat.split);\n\treturn 0;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}