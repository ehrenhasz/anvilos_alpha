{
  "module_name": "xattr.c",
  "hash_id": "071e258264087a06f129f450a78bc0367136be0bd2f6262b6e1cb77d7d9c6b76",
  "original_prompt": "Ingested from linux-6.6.14/fs/jfs/xattr.c",
  "human_readable_source": "\n \n\n#include <linux/capability.h>\n#include <linux/fs.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/security.h>\n#include \"jfs_incore.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_acl.h\"\n\n \n\nstruct ea_buffer {\n\tint flag;\t\t \n\tint max_size;\t\t \n\tdxd_t new_ea;\t\t \n\tstruct metapage *mp;\t \n\tstruct jfs_ea_list *xattr;\t \n};\n\n \n#define EA_INLINE\t0x0001\n#define EA_EXTENT\t0x0002\n#define EA_NEW\t\t0x0004\n#define EA_MALLOC\t0x0008\n\n\n \n\nstatic int is_known_namespace(const char *name)\n{\n\tif (strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_SECURITY_PREFIX, XATTR_SECURITY_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic inline int name_size(struct jfs_ea *ea)\n{\n\tif (is_known_namespace(ea->name))\n\t\treturn ea->namelen;\n\telse\n\t\treturn ea->namelen + XATTR_OS2_PREFIX_LEN;\n}\n\nstatic inline int copy_name(char *buffer, struct jfs_ea *ea)\n{\n\tint len = ea->namelen;\n\n\tif (!is_known_namespace(ea->name)) {\n\t\tmemcpy(buffer, XATTR_OS2_PREFIX, XATTR_OS2_PREFIX_LEN);\n\t\tbuffer += XATTR_OS2_PREFIX_LEN;\n\t\tlen += XATTR_OS2_PREFIX_LEN;\n\t}\n\tmemcpy(buffer, ea->name, ea->namelen);\n\tbuffer[ea->namelen] = 0;\n\n\treturn len;\n}\n\n \nstatic void ea_release(struct inode *inode, struct ea_buffer *ea_buf);\n\n \nstatic int ea_write_inline(struct inode *ip, struct jfs_ea_list *ealist,\n\t\t\t   int size, dxd_t * ea)\n{\n\tstruct jfs_inode_info *ji = JFS_IP(ip);\n\n\t \n\tif (ealist && size > sizeof (struct jfs_ea_list)) {\n\t\tassert(size <= sizeof (ji->i_inline_ea));\n\n\t\t \n\t\tif (!(ji->mode2 & INLINEEA) && !(ji->ea.flag & DXD_INLINE))\n\t\t\treturn -EPERM;\n\n\t\tDXDsize(ea, size);\n\t\tDXDlength(ea, 0);\n\t\tDXDaddress(ea, 0);\n\t\tmemcpy(ji->i_inline_ea, ealist, size);\n\t\tea->flag = DXD_INLINE;\n\t\tji->mode2 &= ~INLINEEA;\n\t} else {\n\t\tea->flag = 0;\n\t\tDXDsize(ea, 0);\n\t\tDXDlength(ea, 0);\n\t\tDXDaddress(ea, 0);\n\n\t\t \n\t\tif (ji->ea.flag & DXD_INLINE)\n\t\t\tji->mode2 |= INLINEEA;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ea_write(struct inode *ip, struct jfs_ea_list *ealist, int size,\n\t\t       dxd_t * ea)\n{\n\tstruct super_block *sb = ip->i_sb;\n\tstruct jfs_inode_info *ji = JFS_IP(ip);\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tint nblocks;\n\ts64 blkno;\n\tint rc = 0, i;\n\tchar *cp;\n\ts32 nbytes, nb;\n\ts32 bytes_to_write;\n\tstruct metapage *mp;\n\n\t \n\tif (!ealist || size <= sizeof (ji->i_inline_ea)) {\n\t\tif (!ea_write_inline(ip, ealist, size, ea))\n\t\t\treturn 0;\n\t}\n\n\t \n\tnblocks = (size + (sb->s_blocksize - 1)) >> sb->s_blocksize_bits;\n\n\t \n\trc = dquot_alloc_block(ip, nblocks);\n\tif (rc)\n\t\treturn rc;\n\n\trc = dbAlloc(ip, INOHINT(ip), nblocks, &blkno);\n\tif (rc) {\n\t\t \n\t\tdquot_free_block(ip, nblocks);\n\t\treturn rc;\n\t}\n\n\t \n\tcp = (char *) ealist;\n\tnbytes = size;\n\tfor (i = 0; i < nblocks; i += sbi->nbperpage) {\n\t\t \n\t\tnb = min(PSIZE, nbytes);\n\t\tbytes_to_write =\n\t\t    ((((nb + sb->s_blocksize - 1)) >> sb->s_blocksize_bits))\n\t\t    << sb->s_blocksize_bits;\n\n\t\tif (!(mp = get_metapage(ip, blkno + i, bytes_to_write, 1))) {\n\t\t\trc = -EIO;\n\t\t\tgoto failed;\n\t\t}\n\n\t\tmemcpy(mp->data, cp, nb);\n\n\t\t \n#ifdef _JFS_FIXME\n\t\tif ((rc = flush_metapage(mp))) {\n\t\t\t \n\t\t\tgoto failed;\n\t\t}\n#else\n\t\tflush_metapage(mp);\n#endif\n\n\t\tcp += PSIZE;\n\t\tnbytes -= nb;\n\t}\n\n\tea->flag = DXD_EXTENT;\n\tDXDsize(ea, le32_to_cpu(ealist->size));\n\tDXDlength(ea, nblocks);\n\tDXDaddress(ea, blkno);\n\n\t \n\tif (ji->ea.flag & DXD_INLINE)\n\t\tji->mode2 |= INLINEEA;\n\n\treturn 0;\n\n      failed:\n\t \n\tdquot_free_block(ip, nblocks);\n\n\tdbFree(ip, blkno, nblocks);\n\treturn rc;\n}\n\n \nstatic int ea_read_inline(struct inode *ip, struct jfs_ea_list *ealist)\n{\n\tstruct jfs_inode_info *ji = JFS_IP(ip);\n\tint ea_size = sizeDXD(&ji->ea);\n\n\tif (ea_size == 0) {\n\t\tealist->size = 0;\n\t\treturn 0;\n\t}\n\n\t \n\tif ((sizeDXD(&ji->ea) > sizeof (ji->i_inline_ea)))\n\t\treturn -EIO;\n\tif (le32_to_cpu(((struct jfs_ea_list *) &ji->i_inline_ea)->size)\n\t    != ea_size)\n\t\treturn -EIO;\n\n\tmemcpy(ealist, ji->i_inline_ea, ea_size);\n\treturn 0;\n}\n\n \nstatic int ea_read(struct inode *ip, struct jfs_ea_list *ealist)\n{\n\tstruct super_block *sb = ip->i_sb;\n\tstruct jfs_inode_info *ji = JFS_IP(ip);\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tint nblocks;\n\ts64 blkno;\n\tchar *cp = (char *) ealist;\n\tint i;\n\tint nbytes, nb;\n\ts32 bytes_to_read;\n\tstruct metapage *mp;\n\n\t \n\tif (ji->ea.flag & DXD_INLINE)\n\t\treturn ea_read_inline(ip, ealist);\n\n\tnbytes = sizeDXD(&ji->ea);\n\tif (!nbytes) {\n\t\tjfs_error(sb, \"nbytes is 0\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tnblocks = lengthDXD(&ji->ea) << sbi->l2nbperpage;\n\tblkno = addressDXD(&ji->ea) << sbi->l2nbperpage;\n\n\t \n\tfor (i = 0; i < nblocks; i += sbi->nbperpage) {\n\t\t \n\t\tnb = min(PSIZE, nbytes);\n\t\tbytes_to_read =\n\t\t    ((((nb + sb->s_blocksize - 1)) >> sb->s_blocksize_bits))\n\t\t    << sb->s_blocksize_bits;\n\n\t\tif (!(mp = read_metapage(ip, blkno + i, bytes_to_read, 1)))\n\t\t\treturn -EIO;\n\n\t\tmemcpy(cp, mp->data, nb);\n\t\trelease_metapage(mp);\n\n\t\tcp += PSIZE;\n\t\tnbytes -= nb;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ea_get(struct inode *inode, struct ea_buffer *ea_buf, int min_size)\n{\n\tstruct jfs_inode_info *ji = JFS_IP(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tint size;\n\tint ea_size = sizeDXD(&ji->ea);\n\tint blocks_needed, current_blocks;\n\ts64 blkno;\n\tint rc;\n\tint quota_allocation = 0;\n\n\t \n\tif (ji->ea.flag == 0)\n\t\tea_size = 0;\n\n\tif (ea_size == 0) {\n\t\tif (min_size == 0) {\n\t\t\tea_buf->flag = 0;\n\t\t\tea_buf->max_size = 0;\n\t\t\tea_buf->xattr = NULL;\n\t\t\treturn 0;\n\t\t}\n\t\tif ((min_size <= sizeof (ji->i_inline_ea)) &&\n\t\t    (ji->mode2 & INLINEEA)) {\n\t\t\tea_buf->flag = EA_INLINE | EA_NEW;\n\t\t\tea_buf->max_size = sizeof (ji->i_inline_ea);\n\t\t\tea_buf->xattr = (struct jfs_ea_list *) ji->i_inline_ea;\n\t\t\tDXDlength(&ea_buf->new_ea, 0);\n\t\t\tDXDaddress(&ea_buf->new_ea, 0);\n\t\t\tea_buf->new_ea.flag = DXD_INLINE;\n\t\t\tDXDsize(&ea_buf->new_ea, min_size);\n\t\t\treturn 0;\n\t\t}\n\t\tcurrent_blocks = 0;\n\t} else if (ji->ea.flag & DXD_INLINE) {\n\t\tif (min_size <= sizeof (ji->i_inline_ea)) {\n\t\t\tea_buf->flag = EA_INLINE;\n\t\t\tea_buf->max_size = sizeof (ji->i_inline_ea);\n\t\t\tea_buf->xattr = (struct jfs_ea_list *) ji->i_inline_ea;\n\t\t\tgoto size_check;\n\t\t}\n\t\tcurrent_blocks = 0;\n\t} else {\n\t\tif (!(ji->ea.flag & DXD_EXTENT)) {\n\t\t\tjfs_error(sb, \"invalid ea.flag\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tcurrent_blocks = (ea_size + sb->s_blocksize - 1) >>\n\t\t    sb->s_blocksize_bits;\n\t}\n\tsize = max(min_size, ea_size);\n\n\tif (size > PSIZE) {\n\t\t \n\t\tea_buf->max_size = (size + sb->s_blocksize - 1) &\n\t\t    ~(sb->s_blocksize - 1);\n\n\t\tea_buf->xattr = kmalloc(ea_buf->max_size, GFP_KERNEL);\n\t\tif (ea_buf->xattr == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tea_buf->flag = EA_MALLOC;\n\n\t\tif (ea_size == 0)\n\t\t\treturn 0;\n\n\t\tif ((rc = ea_read(inode, ea_buf->xattr))) {\n\t\t\tkfree(ea_buf->xattr);\n\t\t\tea_buf->xattr = NULL;\n\t\t\treturn rc;\n\t\t}\n\t\tgoto size_check;\n\t}\n\tblocks_needed = (min_size + sb->s_blocksize - 1) >>\n\t    sb->s_blocksize_bits;\n\n\tif (blocks_needed > current_blocks) {\n\t\t \n\t\trc = dquot_alloc_block(inode, blocks_needed);\n\t\tif (rc)\n\t\t\treturn -EDQUOT;\n\n\t\tquota_allocation = blocks_needed;\n\n\t\trc = dbAlloc(inode, INOHINT(inode), (s64) blocks_needed,\n\t\t\t     &blkno);\n\t\tif (rc)\n\t\t\tgoto clean_up;\n\n\t\tDXDlength(&ea_buf->new_ea, blocks_needed);\n\t\tDXDaddress(&ea_buf->new_ea, blkno);\n\t\tea_buf->new_ea.flag = DXD_EXTENT;\n\t\tDXDsize(&ea_buf->new_ea, min_size);\n\n\t\tea_buf->flag = EA_EXTENT | EA_NEW;\n\n\t\tea_buf->mp = get_metapage(inode, blkno,\n\t\t\t\t\t  blocks_needed << sb->s_blocksize_bits,\n\t\t\t\t\t  1);\n\t\tif (ea_buf->mp == NULL) {\n\t\t\tdbFree(inode, blkno, (s64) blocks_needed);\n\t\t\trc = -EIO;\n\t\t\tgoto clean_up;\n\t\t}\n\t\tea_buf->xattr = ea_buf->mp->data;\n\t\tea_buf->max_size = (min_size + sb->s_blocksize - 1) &\n\t\t    ~(sb->s_blocksize - 1);\n\t\tif (ea_size == 0)\n\t\t\treturn 0;\n\t\tif ((rc = ea_read(inode, ea_buf->xattr))) {\n\t\t\tdiscard_metapage(ea_buf->mp);\n\t\t\tdbFree(inode, blkno, (s64) blocks_needed);\n\t\t\tgoto clean_up;\n\t\t}\n\t\tgoto size_check;\n\t}\n\tea_buf->flag = EA_EXTENT;\n\tea_buf->mp = read_metapage(inode, addressDXD(&ji->ea),\n\t\t\t\t   lengthDXD(&ji->ea) << sb->s_blocksize_bits,\n\t\t\t\t   1);\n\tif (ea_buf->mp == NULL) {\n\t\trc = -EIO;\n\t\tgoto clean_up;\n\t}\n\tea_buf->xattr = ea_buf->mp->data;\n\tea_buf->max_size = (ea_size + sb->s_blocksize - 1) &\n\t    ~(sb->s_blocksize - 1);\n\n      size_check:\n\tif (EALIST_SIZE(ea_buf->xattr) != ea_size) {\n\t\tprintk(KERN_ERR \"ea_get: invalid extended attribute\\n\");\n\t\tprint_hex_dump(KERN_ERR, \"\", DUMP_PREFIX_ADDRESS, 16, 1,\n\t\t\t\t     ea_buf->xattr, ea_size, 1);\n\t\tea_release(inode, ea_buf);\n\t\trc = -EIO;\n\t\tgoto clean_up;\n\t}\n\n\treturn ea_size;\n\n      clean_up:\n\t \n\tif (quota_allocation)\n\t\tdquot_free_block(inode, quota_allocation);\n\n\treturn (rc);\n}\n\nstatic void ea_release(struct inode *inode, struct ea_buffer *ea_buf)\n{\n\tif (ea_buf->flag & EA_MALLOC)\n\t\tkfree(ea_buf->xattr);\n\telse if (ea_buf->flag & EA_EXTENT) {\n\t\tassert(ea_buf->mp);\n\t\trelease_metapage(ea_buf->mp);\n\n\t\tif (ea_buf->flag & EA_NEW)\n\t\t\tdbFree(inode, addressDXD(&ea_buf->new_ea),\n\t\t\t       lengthDXD(&ea_buf->new_ea));\n\t}\n}\n\nstatic int ea_put(tid_t tid, struct inode *inode, struct ea_buffer *ea_buf,\n\t\t  int new_size)\n{\n\tstruct jfs_inode_info *ji = JFS_IP(inode);\n\tunsigned long old_blocks, new_blocks;\n\tint rc = 0;\n\n\tif (new_size == 0) {\n\t\tea_release(inode, ea_buf);\n\t\tea_buf = NULL;\n\t} else if (ea_buf->flag & EA_INLINE) {\n\t\tassert(new_size <= sizeof (ji->i_inline_ea));\n\t\tji->mode2 &= ~INLINEEA;\n\t\tea_buf->new_ea.flag = DXD_INLINE;\n\t\tDXDsize(&ea_buf->new_ea, new_size);\n\t\tDXDaddress(&ea_buf->new_ea, 0);\n\t\tDXDlength(&ea_buf->new_ea, 0);\n\t} else if (ea_buf->flag & EA_MALLOC) {\n\t\trc = ea_write(inode, ea_buf->xattr, new_size, &ea_buf->new_ea);\n\t\tkfree(ea_buf->xattr);\n\t} else if (ea_buf->flag & EA_NEW) {\n\t\t \n\t\tflush_metapage(ea_buf->mp);\n\t} else {\n\t\t \n\t\trc = ea_write(inode, ea_buf->xattr, new_size, &ea_buf->new_ea);\n\t\tdiscard_metapage(ea_buf->mp);\n\t}\n\tif (rc)\n\t\treturn rc;\n\n\told_blocks = new_blocks = 0;\n\n\tif (ji->ea.flag & DXD_EXTENT) {\n\t\tinvalidate_dxd_metapages(inode, ji->ea);\n\t\told_blocks = lengthDXD(&ji->ea);\n\t}\n\n\tif (ea_buf) {\n\t\ttxEA(tid, inode, &ji->ea, &ea_buf->new_ea);\n\t\tif (ea_buf->new_ea.flag & DXD_EXTENT) {\n\t\t\tnew_blocks = lengthDXD(&ea_buf->new_ea);\n\t\t\tif (ji->ea.flag & DXD_INLINE)\n\t\t\t\tji->mode2 |= INLINEEA;\n\t\t}\n\t\tji->ea = ea_buf->new_ea;\n\t} else {\n\t\ttxEA(tid, inode, &ji->ea, NULL);\n\t\tif (ji->ea.flag & DXD_INLINE)\n\t\t\tji->mode2 |= INLINEEA;\n\t\tji->ea.flag = 0;\n\t\tji->ea.size = 0;\n\t}\n\n\t \n\tif (old_blocks)\n\t\tdquot_free_block(inode, old_blocks);\n\n\tinode_set_ctime_current(inode);\n\n\treturn 0;\n}\n\nint __jfs_setxattr(tid_t tid, struct inode *inode, const char *name,\n\t\t   const void *value, size_t value_len, int flags)\n{\n\tstruct jfs_ea_list *ealist;\n\tstruct jfs_ea *ea, *old_ea = NULL, *next_ea = NULL;\n\tstruct ea_buffer ea_buf;\n\tint old_ea_size = 0;\n\tint xattr_size;\n\tint new_size;\n\tint namelen = strlen(name);\n\tint found = 0;\n\tint rc;\n\tint length;\n\n\tdown_write(&JFS_IP(inode)->xattr_sem);\n\n\txattr_size = ea_get(inode, &ea_buf, 0);\n\tif (xattr_size < 0) {\n\t\trc = xattr_size;\n\t\tgoto out;\n\t}\n\n      again:\n\tealist = (struct jfs_ea_list *) ea_buf.xattr;\n\tnew_size = sizeof (struct jfs_ea_list);\n\n\tif (xattr_size) {\n\t\tfor (ea = FIRST_EA(ealist); ea < END_EALIST(ealist);\n\t\t     ea = NEXT_EA(ea)) {\n\t\t\tif ((namelen == ea->namelen) &&\n\t\t\t    (memcmp(name, ea->name, namelen) == 0)) {\n\t\t\t\tfound = 1;\n\t\t\t\tif (flags & XATTR_CREATE) {\n\t\t\t\t\trc = -EEXIST;\n\t\t\t\t\tgoto release;\n\t\t\t\t}\n\t\t\t\told_ea = ea;\n\t\t\t\told_ea_size = EA_SIZE(ea);\n\t\t\t\tnext_ea = NEXT_EA(ea);\n\t\t\t} else\n\t\t\t\tnew_size += EA_SIZE(ea);\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tif (flags & XATTR_REPLACE) {\n\t\t\trc = -ENODATA;\n\t\t\tgoto release;\n\t\t}\n\t\tif (value == NULL) {\n\t\t\trc = 0;\n\t\t\tgoto release;\n\t\t}\n\t}\n\tif (value)\n\t\tnew_size += sizeof (struct jfs_ea) + namelen + 1 + value_len;\n\n\tif (new_size > ea_buf.max_size) {\n\t\t \n\t\tea_release(inode, &ea_buf);\n\t\txattr_size = ea_get(inode, &ea_buf, new_size);\n\t\tif (xattr_size < 0) {\n\t\t\trc = xattr_size;\n\t\t\tgoto out;\n\t\t}\n\t\tgoto again;\n\t}\n\n\t \n\tif (found) {\n\t\t \n\t\tlength = (char *) END_EALIST(ealist) - (char *) next_ea;\n\t\tif (length > 0)\n\t\t\tmemmove(old_ea, next_ea, length);\n\t\txattr_size -= old_ea_size;\n\t}\n\n\t \n\tif (value) {\n\t\tif (xattr_size == 0)\n\t\t\t \n\t\t\txattr_size = sizeof (struct jfs_ea_list);\n\n\t\t \n\t\tif (value_len >= USHRT_MAX) {\n\t\t\trc = -E2BIG;\n\t\t\tgoto release;\n\t\t}\n\n\t\tea = (struct jfs_ea *) ((char *) ealist + xattr_size);\n\t\tea->flag = 0;\n\t\tea->namelen = namelen;\n\t\tea->valuelen = (cpu_to_le16(value_len));\n\t\tmemcpy(ea->name, name, namelen);\n\t\tea->name[namelen] = 0;\n\t\tif (value_len)\n\t\t\tmemcpy(&ea->name[namelen + 1], value, value_len);\n\t\txattr_size += EA_SIZE(ea);\n\t}\n\n\t \n\tif (xattr_size != new_size) {\n\t\tprintk(KERN_ERR\n\t\t       \"__jfs_setxattr: xattr_size = %d, new_size = %d\\n\",\n\t\t       xattr_size, new_size);\n\n\t\trc = -EINVAL;\n\t\tgoto release;\n\t}\n\n\t \n\tif (new_size == sizeof (struct jfs_ea_list))\n\t\tnew_size = 0;\n\n\tealist->size = cpu_to_le32(new_size);\n\n\trc = ea_put(tid, inode, &ea_buf, new_size);\n\n\tgoto out;\n      release:\n\tea_release(inode, &ea_buf);\n      out:\n\tup_write(&JFS_IP(inode)->xattr_sem);\n\n\treturn rc;\n}\n\nssize_t __jfs_getxattr(struct inode *inode, const char *name, void *data,\n\t\t       size_t buf_size)\n{\n\tstruct jfs_ea_list *ealist;\n\tstruct jfs_ea *ea;\n\tstruct ea_buffer ea_buf;\n\tint xattr_size;\n\tssize_t size;\n\tint namelen = strlen(name);\n\tchar *value;\n\n\tdown_read(&JFS_IP(inode)->xattr_sem);\n\n\txattr_size = ea_get(inode, &ea_buf, 0);\n\n\tif (xattr_size < 0) {\n\t\tsize = xattr_size;\n\t\tgoto out;\n\t}\n\n\tif (xattr_size == 0)\n\t\tgoto not_found;\n\n\tealist = (struct jfs_ea_list *) ea_buf.xattr;\n\n\t \n\tfor (ea = FIRST_EA(ealist); ea < END_EALIST(ealist); ea = NEXT_EA(ea))\n\t\tif ((namelen == ea->namelen) &&\n\t\t    memcmp(name, ea->name, namelen) == 0) {\n\t\t\t \n\t\t\tsize = le16_to_cpu(ea->valuelen);\n\t\t\tif (!data)\n\t\t\t\tgoto release;\n\t\t\telse if (size > buf_size) {\n\t\t\t\tsize = -ERANGE;\n\t\t\t\tgoto release;\n\t\t\t}\n\t\t\tvalue = ((char *) &ea->name) + ea->namelen + 1;\n\t\t\tmemcpy(data, value, size);\n\t\t\tgoto release;\n\t\t}\n      not_found:\n\tsize = -ENODATA;\n      release:\n\tea_release(inode, &ea_buf);\n      out:\n\tup_read(&JFS_IP(inode)->xattr_sem);\n\n\treturn size;\n}\n\n \nstatic inline int can_list(struct jfs_ea *ea)\n{\n\treturn (strncmp(ea->name, XATTR_TRUSTED_PREFIX,\n\t\t\t    XATTR_TRUSTED_PREFIX_LEN) ||\n\t\tcapable(CAP_SYS_ADMIN));\n}\n\nssize_t jfs_listxattr(struct dentry * dentry, char *data, size_t buf_size)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tchar *buffer;\n\tssize_t size = 0;\n\tint xattr_size;\n\tstruct jfs_ea_list *ealist;\n\tstruct jfs_ea *ea;\n\tstruct ea_buffer ea_buf;\n\n\tdown_read(&JFS_IP(inode)->xattr_sem);\n\n\txattr_size = ea_get(inode, &ea_buf, 0);\n\tif (xattr_size < 0) {\n\t\tsize = xattr_size;\n\t\tgoto out;\n\t}\n\n\tif (xattr_size == 0)\n\t\tgoto release;\n\n\tealist = (struct jfs_ea_list *) ea_buf.xattr;\n\n\t \n\tfor (ea = FIRST_EA(ealist); ea < END_EALIST(ealist); ea = NEXT_EA(ea)) {\n\t\tif (can_list(ea))\n\t\t\tsize += name_size(ea) + 1;\n\t}\n\n\tif (!data)\n\t\tgoto release;\n\n\tif (size > buf_size) {\n\t\tsize = -ERANGE;\n\t\tgoto release;\n\t}\n\n\t \n\tbuffer = data;\n\tfor (ea = FIRST_EA(ealist); ea < END_EALIST(ealist); ea = NEXT_EA(ea)) {\n\t\tif (can_list(ea)) {\n\t\t\tint namelen = copy_name(buffer, ea);\n\t\t\tbuffer += namelen + 1;\n\t\t}\n\t}\n\n      release:\n\tea_release(inode, &ea_buf);\n      out:\n\tup_read(&JFS_IP(inode)->xattr_sem);\n\treturn size;\n}\n\nstatic int __jfs_xattr_set(struct inode *inode, const char *name,\n\t\t\t   const void *value, size_t size, int flags)\n{\n\tstruct jfs_inode_info *ji = JFS_IP(inode);\n\ttid_t tid;\n\tint rc;\n\n\ttid = txBegin(inode->i_sb, 0);\n\tmutex_lock(&ji->commit_mutex);\n\trc = __jfs_setxattr(tid, inode, name, value, size, flags);\n\tif (!rc)\n\t\trc = txCommit(tid, 1, &inode, 0);\n\ttxEnd(tid);\n\tmutex_unlock(&ji->commit_mutex);\n\n\treturn rc;\n}\n\nstatic int jfs_xattr_get(const struct xattr_handler *handler,\n\t\t\t struct dentry *unused, struct inode *inode,\n\t\t\t const char *name, void *value, size_t size)\n{\n\tname = xattr_full_name(handler, name);\n\treturn __jfs_getxattr(inode, name, value, size);\n}\n\nstatic int jfs_xattr_set(const struct xattr_handler *handler,\n\t\t\t struct mnt_idmap *idmap,\n\t\t\t struct dentry *unused, struct inode *inode,\n\t\t\t const char *name, const void *value,\n\t\t\t size_t size, int flags)\n{\n\tname = xattr_full_name(handler, name);\n\treturn __jfs_xattr_set(inode, name, value, size, flags);\n}\n\nstatic int jfs_xattr_get_os2(const struct xattr_handler *handler,\n\t\t\t     struct dentry *unused, struct inode *inode,\n\t\t\t     const char *name, void *value, size_t size)\n{\n\tif (is_known_namespace(name))\n\t\treturn -EOPNOTSUPP;\n\treturn __jfs_getxattr(inode, name, value, size);\n}\n\nstatic int jfs_xattr_set_os2(const struct xattr_handler *handler,\n\t\t\t     struct mnt_idmap *idmap,\n\t\t\t     struct dentry *unused, struct inode *inode,\n\t\t\t     const char *name, const void *value,\n\t\t\t     size_t size, int flags)\n{\n\tif (is_known_namespace(name))\n\t\treturn -EOPNOTSUPP;\n\treturn __jfs_xattr_set(inode, name, value, size, flags);\n}\n\nstatic const struct xattr_handler jfs_user_xattr_handler = {\n\t.prefix = XATTR_USER_PREFIX,\n\t.get = jfs_xattr_get,\n\t.set = jfs_xattr_set,\n};\n\nstatic const struct xattr_handler jfs_os2_xattr_handler = {\n\t.prefix = XATTR_OS2_PREFIX,\n\t.get = jfs_xattr_get_os2,\n\t.set = jfs_xattr_set_os2,\n};\n\nstatic const struct xattr_handler jfs_security_xattr_handler = {\n\t.prefix = XATTR_SECURITY_PREFIX,\n\t.get = jfs_xattr_get,\n\t.set = jfs_xattr_set,\n};\n\nstatic const struct xattr_handler jfs_trusted_xattr_handler = {\n\t.prefix = XATTR_TRUSTED_PREFIX,\n\t.get = jfs_xattr_get,\n\t.set = jfs_xattr_set,\n};\n\nconst struct xattr_handler *jfs_xattr_handlers[] = {\n\t&jfs_os2_xattr_handler,\n\t&jfs_user_xattr_handler,\n\t&jfs_security_xattr_handler,\n\t&jfs_trusted_xattr_handler,\n\tNULL,\n};\n\n\n#ifdef CONFIG_JFS_SECURITY\nstatic int jfs_initxattrs(struct inode *inode, const struct xattr *xattr_array,\n\t\t\t  void *fs_info)\n{\n\tconst struct xattr *xattr;\n\ttid_t *tid = fs_info;\n\tchar *name;\n\tint err = 0;\n\n\tfor (xattr = xattr_array; xattr->name != NULL; xattr++) {\n\t\tname = kmalloc(XATTR_SECURITY_PREFIX_LEN +\n\t\t\t       strlen(xattr->name) + 1, GFP_NOFS);\n\t\tif (!name) {\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\tstrcpy(name, XATTR_SECURITY_PREFIX);\n\t\tstrcpy(name + XATTR_SECURITY_PREFIX_LEN, xattr->name);\n\n\t\terr = __jfs_setxattr(*tid, inode, name,\n\t\t\t\t     xattr->value, xattr->value_len, 0);\n\t\tkfree(name);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t}\n\treturn err;\n}\n\nint jfs_init_security(tid_t tid, struct inode *inode, struct inode *dir,\n\t\t      const struct qstr *qstr)\n{\n\treturn security_inode_init_security(inode, dir, qstr,\n\t\t\t\t\t    &jfs_initxattrs, &tid);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}