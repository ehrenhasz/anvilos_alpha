{
  "module_name": "jfs_btree.h",
  "hash_id": "8ce88e5760ccb9cb8447438e5db3149e92bc7ba1f8d7515427c2f7891803f391",
  "original_prompt": "Ingested from linux-6.6.14/fs/jfs/jfs_btree.h",
  "human_readable_source": " \n \n#ifndef\t_H_JFS_BTREE\n#define _H_JFS_BTREE\n\n \n\n \n\n \n#define BT_TYPE\t\t0x07\t \n#define\tBT_ROOT\t\t0x01\t \n#define\tBT_LEAF\t\t0x02\t \n#define\tBT_INTERNAL\t0x04\t \n#define\tBT_RIGHTMOST\t0x10\t \n#define\tBT_LEFTMOST\t0x20\t \n#define\tBT_SWAPPED\t0x80\t \n\n \n#define\tBT_RANDOM\t\t0x0000\n#define\tBT_SEQUENTIAL\t\t0x0001\n#define\tBT_LOOKUP\t\t0x0010\n#define\tBT_INSERT\t\t0x0020\n#define\tBT_DELETE\t\t0x0040\n\n \n#define BT_IS_ROOT(MP) (((MP)->xflag & COMMIT_PAGE) == 0)\n\n \n#define BT_PAGE(IP, MP, TYPE, ROOT)\\\n\t(BT_IS_ROOT(MP) ? (TYPE *)&JFS_IP(IP)->ROOT : (TYPE *)(MP)->data)\n\n \n#define BT_GETPAGE(IP, BN, MP, TYPE, SIZE, P, RC, ROOT)\\\n{\\\n\tif ((BN) == 0)\\\n\t{\\\n\t\tMP = (struct metapage *)&JFS_IP(IP)->bxflag;\\\n\t\tP = (TYPE *)&JFS_IP(IP)->ROOT;\\\n\t\tRC = 0;\\\n\t}\\\n\telse\\\n\t{\\\n\t\tMP = read_metapage((IP), BN, SIZE, 1);\\\n\t\tif (MP) {\\\n\t\t\tRC = 0;\\\n\t\t\tP = (MP)->data;\\\n\t\t} else {\\\n\t\t\tP = NULL;\\\n\t\t\tjfs_err(\"bread failed!\");\\\n\t\t\tRC = -EIO;\\\n\t\t}\\\n\t}\\\n}\n\n#define BT_MARK_DIRTY(MP, IP)\\\n{\\\n\tif (BT_IS_ROOT(MP))\\\n\t\tmark_inode_dirty(IP);\\\n\telse\\\n\t\tmark_metapage_dirty(MP);\\\n}\n\n \n#define BT_PUTPAGE(MP)\\\n{\\\n\tif (! BT_IS_ROOT(MP)) \\\n\t\trelease_metapage(MP); \\\n}\n\n\n \nstruct btframe {\t \n\ts64 bn;\t\t\t \n\ts16 index;\t\t \n\ts16 lastindex;\t\t \n\tstruct metapage *mp;\t \n};\t\t\t\t \n\nstruct btstack {\n\tstruct btframe *top;\n\tint nsplit;\n\tstruct btframe stack[MAXTREEHEIGHT];\n};\n\n#define BT_CLR(btstack)\\\n\t(btstack)->top = (btstack)->stack\n\n#define BT_STACK_FULL(btstack)\\\n\t( (btstack)->top == &((btstack)->stack[MAXTREEHEIGHT-1]))\n\n#define BT_PUSH(BTSTACK, BN, INDEX)\\\n{\\\n\tassert(!BT_STACK_FULL(BTSTACK));\\\n\t(BTSTACK)->top->bn = BN;\\\n\t(BTSTACK)->top->index = INDEX;\\\n\t++(BTSTACK)->top;\\\n}\n\n#define BT_POP(btstack)\\\n\t( (btstack)->top == (btstack)->stack ? NULL : --(btstack)->top )\n\n#define BT_STACK(btstack)\\\n\t( (btstack)->top == (btstack)->stack ? NULL : (btstack)->top )\n\nstatic inline void BT_STACK_DUMP(struct btstack *btstack)\n{\n\tint i;\n\tprintk(\"btstack dump:\\n\");\n\tfor (i = 0; i < MAXTREEHEIGHT; i++)\n\t\tprintk(KERN_ERR \"bn = %Lx, index = %d\\n\",\n\t\t       (long long)btstack->stack[i].bn,\n\t\t       btstack->stack[i].index);\n}\n\n \n#define BT_GETSEARCH(IP, LEAF, BN, MP, TYPE, P, INDEX, ROOT)\\\n{\\\n\tBN = (LEAF)->bn;\\\n\tMP = (LEAF)->mp;\\\n\tif (BN)\\\n\t\tP = (TYPE *)MP->data;\\\n\telse\\\n\t\tP = (TYPE *)&JFS_IP(IP)->ROOT;\\\n\tINDEX = (LEAF)->index;\\\n}\n\n \n#define BT_PUTSEARCH(BTSTACK)\\\n{\\\n\tif (! BT_IS_ROOT((BTSTACK)->top->mp))\\\n\t\trelease_metapage((BTSTACK)->top->mp);\\\n}\n#endif\t\t\t\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}