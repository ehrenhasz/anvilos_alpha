{
  "module_name": "ioctl.c",
  "hash_id": "3c20b11d2df551bf46f75849838db6b0b1f295722041541c99d01c113e81d149",
  "original_prompt": "Ingested from linux-6.6.14/fs/jfs/ioctl.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/blkdev.h>\n#include <asm/current.h>\n#include <linux/uaccess.h>\n#include <linux/fileattr.h>\n\n#include \"jfs_filsys.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_incore.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_discard.h\"\n\nstatic struct {\n\tlong jfs_flag;\n\tlong ext2_flag;\n} jfs_map[] = {\n\t{JFS_NOATIME_FL,\tFS_NOATIME_FL},\n\t{JFS_DIRSYNC_FL,\tFS_DIRSYNC_FL},\n\t{JFS_SYNC_FL,\t\tFS_SYNC_FL},\n\t{JFS_SECRM_FL,\t\tFS_SECRM_FL},\n\t{JFS_UNRM_FL,\t\tFS_UNRM_FL},\n\t{JFS_APPEND_FL,\t\tFS_APPEND_FL},\n\t{JFS_IMMUTABLE_FL,\tFS_IMMUTABLE_FL},\n\t{0, 0},\n};\n\nstatic long jfs_map_ext2(unsigned long flags, int from)\n{\n\tint index=0;\n\tlong mapped=0;\n\n\twhile (jfs_map[index].jfs_flag) {\n\t\tif (from) {\n\t\t\tif (jfs_map[index].ext2_flag & flags)\n\t\t\t\tmapped |= jfs_map[index].jfs_flag;\n\t\t} else {\n\t\t\tif (jfs_map[index].jfs_flag & flags)\n\t\t\t\tmapped |= jfs_map[index].ext2_flag;\n\t\t}\n\t\tindex++;\n\t}\n\treturn mapped;\n}\n\nint jfs_fileattr_get(struct dentry *dentry, struct fileattr *fa)\n{\n\tstruct jfs_inode_info *jfs_inode = JFS_IP(d_inode(dentry));\n\tunsigned int flags = jfs_inode->mode2 & JFS_FL_USER_VISIBLE;\n\n\tif (d_is_special(dentry))\n\t\treturn -ENOTTY;\n\n\tfileattr_fill_flags(fa, jfs_map_ext2(flags, 0));\n\n\treturn 0;\n}\n\nint jfs_fileattr_set(struct mnt_idmap *idmap,\n\t\t     struct dentry *dentry, struct fileattr *fa)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct jfs_inode_info *jfs_inode = JFS_IP(inode);\n\tunsigned int flags;\n\n\tif (d_is_special(dentry))\n\t\treturn -ENOTTY;\n\n\tif (fileattr_has_fsx(fa))\n\t\treturn -EOPNOTSUPP;\n\n\tflags = jfs_map_ext2(fa->flags, 1);\n\tif (!S_ISDIR(inode->i_mode))\n\t\tflags &= ~JFS_DIRSYNC_FL;\n\n\t \n\tif (IS_NOQUOTA(inode))\n\t\treturn -EPERM;\n\n\tflags = flags & JFS_FL_USER_MODIFIABLE;\n\tflags |= jfs_inode->mode2 & ~JFS_FL_USER_MODIFIABLE;\n\tjfs_inode->mode2 = flags;\n\n\tjfs_set_inode_flags(inode);\n\tinode_set_ctime_current(inode);\n\tmark_inode_dirty(inode);\n\n\treturn 0;\n}\n\nlong jfs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\n\tswitch (cmd) {\n\tcase FITRIM:\n\t{\n\t\tstruct super_block *sb = inode->i_sb;\n\t\tstruct fstrim_range range;\n\t\ts64 ret = 0;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (!bdev_max_discard_sectors(sb->s_bdev)) {\n\t\t\tjfs_warn(\"FITRIM not supported on device\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tif (copy_from_user(&range, (struct fstrim_range __user *)arg,\n\t\t    sizeof(range)))\n\t\t\treturn -EFAULT;\n\n\t\trange.minlen = max_t(unsigned int, range.minlen,\n\t\t\t\t     bdev_discard_granularity(sb->s_bdev));\n\n\t\tret = jfs_ioc_trim(inode, &range);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (copy_to_user((struct fstrim_range __user *)arg, &range,\n\t\t    sizeof(range)))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\t}\n\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}