{
  "module_name": "jfs_unicode.c",
  "hash_id": "e18732ae86b5a39d42afd17d450acec70eacd393ccee03b9cc83c2ae377252c2",
  "original_prompt": "Ingested from linux-6.6.14/fs/jfs/jfs_unicode.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include \"jfs_incore.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_debug.h\"\n\n \nint jfs_strfromUCS_le(char *to, const __le16 * from,\n\t\t      int len, struct nls_table *codepage)\n{\n\tint i;\n\tint outlen = 0;\n\tstatic int warn_again = 5;\t \n\tint warn = !!warn_again;\t \n\n\tif (codepage) {\n\t\tfor (i = 0; (i < len) && from[i]; i++) {\n\t\t\tint charlen;\n\t\t\tcharlen =\n\t\t\t    codepage->uni2char(le16_to_cpu(from[i]),\n\t\t\t\t\t       &to[outlen],\n\t\t\t\t\t       NLS_MAX_CHARSET_SIZE);\n\t\t\tif (charlen > 0)\n\t\t\t\toutlen += charlen;\n\t\t\telse\n\t\t\t\tto[outlen++] = '?';\n\t\t}\n\t} else {\n\t\tfor (i = 0; (i < len) && from[i]; i++) {\n\t\t\tif (unlikely(le16_to_cpu(from[i]) & 0xff00)) {\n\t\t\t\tto[i] = '?';\n\t\t\t\tif (unlikely(warn)) {\n\t\t\t\t\twarn--;\n\t\t\t\t\twarn_again--;\n\t\t\t\t\tprintk(KERN_ERR\n\t\t\t\"non-latin1 character 0x%x found in JFS file name\\n\",\n\t\t\t\t\t       le16_to_cpu(from[i]));\n\t\t\t\t\tprintk(KERN_ERR\n\t\t\t\t\"mount with iocharset=utf8 to access\\n\");\n\t\t\t\t}\n\n\t\t\t}\n\t\t\telse\n\t\t\t\tto[i] = (char) (le16_to_cpu(from[i]));\n\t\t}\n\t\toutlen = i;\n\t}\n\tto[outlen] = 0;\n\treturn outlen;\n}\n\n \nstatic int jfs_strtoUCS(wchar_t * to, const unsigned char *from, int len,\n\t\tstruct nls_table *codepage)\n{\n\tint charlen;\n\tint i;\n\n\tif (codepage) {\n\t\tfor (i = 0; len && *from; i++, from += charlen, len -= charlen)\n\t\t{\n\t\t\tcharlen = codepage->char2uni(from, len, &to[i]);\n\t\t\tif (charlen < 1) {\n\t\t\t\tjfs_err(\"jfs_strtoUCS: char2uni returned %d.\",\n\t\t\t\t\tcharlen);\n\t\t\t\tjfs_err(\"charset = %s, char = 0x%x\",\n\t\t\t\t\tcodepage->charset, *from);\n\t\t\t\treturn charlen;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = 0; (i < len) && from[i]; i++)\n\t\t\tto[i] = (wchar_t) from[i];\n\t}\n\n\tto[i] = 0;\n\treturn i;\n}\n\n \nint get_UCSname(struct component_name * uniName, struct dentry *dentry)\n{\n\tstruct nls_table *nls_tab = JFS_SBI(dentry->d_sb)->nls_tab;\n\tint length = dentry->d_name.len;\n\n\tif (length > JFS_NAME_MAX)\n\t\treturn -ENAMETOOLONG;\n\n\tuniName->name =\n\t    kmalloc_array(length + 1, sizeof(wchar_t), GFP_NOFS);\n\n\tif (uniName->name == NULL)\n\t\treturn -ENOMEM;\n\n\tuniName->namlen = jfs_strtoUCS(uniName->name, dentry->d_name.name,\n\t\t\t\t       length, nls_tab);\n\n\tif (uniName->namlen < 0) {\n\t\tkfree(uniName->name);\n\t\treturn uniName->namlen;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}