{
  "module_name": "namei.c",
  "hash_id": "cce03984d2a9b9dca54f6a50b4ce7e14fe70b064abba0bb6924c4a703e41c3f6",
  "original_prompt": "Ingested from linux-6.6.14/fs/jfs/namei.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include \"jfs_incore.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_debug.h\"\n\n \nconst struct dentry_operations jfs_ci_dentry_operations;\n\nstatic s64 commitZeroLink(tid_t, struct inode *);\n\n \nstatic inline void free_ea_wmap(struct inode *inode)\n{\n\tdxd_t *ea = &JFS_IP(inode)->ea;\n\n\tif (ea->flag & DXD_EXTENT) {\n\t\t \n\t\tinvalidate_dxd_metapages(inode, *ea);\n\t\tdbFree(inode, addressDXD(ea), lengthDXD(ea));\n\t}\n\tea->flag = 0;\n}\n\n \nstatic int jfs_create(struct mnt_idmap *idmap, struct inode *dip,\n\t\t      struct dentry *dentry, umode_t mode, bool excl)\n{\n\tint rc = 0;\n\ttid_t tid;\t\t \n\tstruct inode *ip = NULL;\t \n\tino_t ino;\n\tstruct component_name dname;\t \n\tstruct btstack btstack;\n\tstruct inode *iplist[2];\n\tstruct tblock *tblk;\n\n\tjfs_info(\"jfs_create: dip:0x%p name:%pd\", dip, dentry);\n\n\trc = dquot_initialize(dip);\n\tif (rc)\n\t\tgoto out1;\n\n\t \n\tif ((rc = get_UCSname(&dname, dentry)))\n\t\tgoto out1;\n\n\t \n\tip = ialloc(dip, mode);\n\tif (IS_ERR(ip)) {\n\t\trc = PTR_ERR(ip);\n\t\tgoto out2;\n\t}\n\n\ttid = txBegin(dip->i_sb, 0);\n\n\tmutex_lock_nested(&JFS_IP(dip)->commit_mutex, COMMIT_MUTEX_PARENT);\n\tmutex_lock_nested(&JFS_IP(ip)->commit_mutex, COMMIT_MUTEX_CHILD);\n\n\trc = jfs_init_acl(tid, ip, dip);\n\tif (rc)\n\t\tgoto out3;\n\n\trc = jfs_init_security(tid, ip, dip, &dentry->d_name);\n\tif (rc) {\n\t\ttxAbort(tid, 0);\n\t\tgoto out3;\n\t}\n\n\tif ((rc = dtSearch(dip, &dname, &ino, &btstack, JFS_CREATE))) {\n\t\tjfs_err(\"jfs_create: dtSearch returned %d\", rc);\n\t\ttxAbort(tid, 0);\n\t\tgoto out3;\n\t}\n\n\ttblk = tid_to_tblock(tid);\n\ttblk->xflag |= COMMIT_CREATE;\n\ttblk->ino = ip->i_ino;\n\ttblk->u.ixpxd = JFS_IP(ip)->ixpxd;\n\n\tiplist[0] = dip;\n\tiplist[1] = ip;\n\n\t \n\txtInitRoot(tid, ip);\n\n\t \n\tino = ip->i_ino;\n\tif ((rc = dtInsert(tid, dip, &dname, &ino, &btstack))) {\n\t\tif (rc == -EIO) {\n\t\t\tjfs_err(\"jfs_create: dtInsert returned -EIO\");\n\t\t\ttxAbort(tid, 1);\t \n\t\t} else\n\t\t\ttxAbort(tid, 0);\t \n\t\tgoto out3;\n\t}\n\n\tip->i_op = &jfs_file_inode_operations;\n\tip->i_fop = &jfs_file_operations;\n\tip->i_mapping->a_ops = &jfs_aops;\n\n\tmark_inode_dirty(ip);\n\n\tdip->i_mtime = inode_set_ctime_current(dip);\n\n\tmark_inode_dirty(dip);\n\n\trc = txCommit(tid, 2, &iplist[0], 0);\n\n      out3:\n\ttxEnd(tid);\n\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\tmutex_unlock(&JFS_IP(dip)->commit_mutex);\n\tif (rc) {\n\t\tfree_ea_wmap(ip);\n\t\tclear_nlink(ip);\n\t\tdiscard_new_inode(ip);\n\t} else {\n\t\td_instantiate_new(dentry, ip);\n\t}\n\n      out2:\n\tfree_UCSname(&dname);\n\n      out1:\n\n\tjfs_info(\"jfs_create: rc:%d\", rc);\n\treturn rc;\n}\n\n\n \nstatic int jfs_mkdir(struct mnt_idmap *idmap, struct inode *dip,\n\t\t     struct dentry *dentry, umode_t mode)\n{\n\tint rc = 0;\n\ttid_t tid;\t\t \n\tstruct inode *ip = NULL;\t \n\tino_t ino;\n\tstruct component_name dname;\t \n\tstruct btstack btstack;\n\tstruct inode *iplist[2];\n\tstruct tblock *tblk;\n\n\tjfs_info(\"jfs_mkdir: dip:0x%p name:%pd\", dip, dentry);\n\n\trc = dquot_initialize(dip);\n\tif (rc)\n\t\tgoto out1;\n\n\t \n\tif ((rc = get_UCSname(&dname, dentry)))\n\t\tgoto out1;\n\n\t \n\tip = ialloc(dip, S_IFDIR | mode);\n\tif (IS_ERR(ip)) {\n\t\trc = PTR_ERR(ip);\n\t\tgoto out2;\n\t}\n\n\ttid = txBegin(dip->i_sb, 0);\n\n\tmutex_lock_nested(&JFS_IP(dip)->commit_mutex, COMMIT_MUTEX_PARENT);\n\tmutex_lock_nested(&JFS_IP(ip)->commit_mutex, COMMIT_MUTEX_CHILD);\n\n\trc = jfs_init_acl(tid, ip, dip);\n\tif (rc)\n\t\tgoto out3;\n\n\trc = jfs_init_security(tid, ip, dip, &dentry->d_name);\n\tif (rc) {\n\t\ttxAbort(tid, 0);\n\t\tgoto out3;\n\t}\n\n\tif ((rc = dtSearch(dip, &dname, &ino, &btstack, JFS_CREATE))) {\n\t\tjfs_err(\"jfs_mkdir: dtSearch returned %d\", rc);\n\t\ttxAbort(tid, 0);\n\t\tgoto out3;\n\t}\n\n\ttblk = tid_to_tblock(tid);\n\ttblk->xflag |= COMMIT_CREATE;\n\ttblk->ino = ip->i_ino;\n\ttblk->u.ixpxd = JFS_IP(ip)->ixpxd;\n\n\tiplist[0] = dip;\n\tiplist[1] = ip;\n\n\t \n\tdtInitRoot(tid, ip, dip->i_ino);\n\n\t \n\tino = ip->i_ino;\n\tif ((rc = dtInsert(tid, dip, &dname, &ino, &btstack))) {\n\t\tif (rc == -EIO) {\n\t\t\tjfs_err(\"jfs_mkdir: dtInsert returned -EIO\");\n\t\t\ttxAbort(tid, 1);\t \n\t\t} else\n\t\t\ttxAbort(tid, 0);\t \n\t\tgoto out3;\n\t}\n\n\tset_nlink(ip, 2);\t \n\tip->i_op = &jfs_dir_inode_operations;\n\tip->i_fop = &jfs_dir_operations;\n\n\tmark_inode_dirty(ip);\n\n\t \n\tinc_nlink(dip);\t\t \n\tdip->i_mtime = inode_set_ctime_current(dip);\n\tmark_inode_dirty(dip);\n\n\trc = txCommit(tid, 2, &iplist[0], 0);\n\n      out3:\n\ttxEnd(tid);\n\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\tmutex_unlock(&JFS_IP(dip)->commit_mutex);\n\tif (rc) {\n\t\tfree_ea_wmap(ip);\n\t\tclear_nlink(ip);\n\t\tdiscard_new_inode(ip);\n\t} else {\n\t\td_instantiate_new(dentry, ip);\n\t}\n\n      out2:\n\tfree_UCSname(&dname);\n\n\n      out1:\n\n\tjfs_info(\"jfs_mkdir: rc:%d\", rc);\n\treturn rc;\n}\n\n \nstatic int jfs_rmdir(struct inode *dip, struct dentry *dentry)\n{\n\tint rc;\n\ttid_t tid;\t\t \n\tstruct inode *ip = d_inode(dentry);\n\tino_t ino;\n\tstruct component_name dname;\n\tstruct inode *iplist[2];\n\tstruct tblock *tblk;\n\n\tjfs_info(\"jfs_rmdir: dip:0x%p name:%pd\", dip, dentry);\n\n\t \n\trc = dquot_initialize(dip);\n\tif (rc)\n\t\tgoto out;\n\trc = dquot_initialize(ip);\n\tif (rc)\n\t\tgoto out;\n\n\t \n\tif (!dtEmpty(ip)) {\n\t\trc = -ENOTEMPTY;\n\t\tgoto out;\n\t}\n\n\tif ((rc = get_UCSname(&dname, dentry))) {\n\t\tgoto out;\n\t}\n\n\ttid = txBegin(dip->i_sb, 0);\n\n\tmutex_lock_nested(&JFS_IP(dip)->commit_mutex, COMMIT_MUTEX_PARENT);\n\tmutex_lock_nested(&JFS_IP(ip)->commit_mutex, COMMIT_MUTEX_CHILD);\n\n\tiplist[0] = dip;\n\tiplist[1] = ip;\n\n\ttblk = tid_to_tblock(tid);\n\ttblk->xflag |= COMMIT_DELETE;\n\ttblk->u.ip = ip;\n\n\t \n\tino = ip->i_ino;\n\tif ((rc = dtDelete(tid, dip, &dname, &ino, JFS_REMOVE))) {\n\t\tjfs_err(\"jfs_rmdir: dtDelete returned %d\", rc);\n\t\tif (rc == -EIO)\n\t\t\ttxAbort(tid, 1);\n\t\ttxEnd(tid);\n\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t\tmutex_unlock(&JFS_IP(dip)->commit_mutex);\n\n\t\tgoto out2;\n\t}\n\n\t \n\tdip->i_mtime = inode_set_ctime_current(dip);\n\tinode_dec_link_count(dip);\n\n\t \n\t \n\tif (JFS_IP(ip)->ea.flag & DXD_EXTENT) {\n\t\t \n\t\ttxEA(tid, ip, &JFS_IP(ip)->ea, NULL);\n\t}\n\tJFS_IP(ip)->ea.flag = 0;\n\n\t \n\tif (JFS_IP(ip)->acl.flag & DXD_EXTENT) {\n\t\t \n\t\ttxEA(tid, ip, &JFS_IP(ip)->acl, NULL);\n\t}\n\tJFS_IP(ip)->acl.flag = 0;\n\n\t \n\tclear_nlink(ip);\n\tmark_inode_dirty(ip);\n\n\trc = txCommit(tid, 2, &iplist[0], 0);\n\n\ttxEnd(tid);\n\n\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\tmutex_unlock(&JFS_IP(dip)->commit_mutex);\n\n\t \n\tif (test_cflag(COMMIT_Stale, dip)) {\n\t\tif (dip->i_size > 1)\n\t\t\tjfs_truncate_nolock(dip, 0);\n\n\t\tclear_cflag(COMMIT_Stale, dip);\n\t}\n\n      out2:\n\tfree_UCSname(&dname);\n\n      out:\n\tjfs_info(\"jfs_rmdir: rc:%d\", rc);\n\treturn rc;\n}\n\n \nstatic int jfs_unlink(struct inode *dip, struct dentry *dentry)\n{\n\tint rc;\n\ttid_t tid;\t\t \n\tstruct inode *ip = d_inode(dentry);\n\tino_t ino;\n\tstruct component_name dname;\t \n\tstruct inode *iplist[2];\n\tstruct tblock *tblk;\n\ts64 new_size = 0;\n\tint commit_flag;\n\n\tjfs_info(\"jfs_unlink: dip:0x%p name:%pd\", dip, dentry);\n\n\t \n\trc = dquot_initialize(dip);\n\tif (rc)\n\t\tgoto out;\n\trc = dquot_initialize(ip);\n\tif (rc)\n\t\tgoto out;\n\n\tif ((rc = get_UCSname(&dname, dentry)))\n\t\tgoto out;\n\n\tIWRITE_LOCK(ip, RDWRLOCK_NORMAL);\n\n\ttid = txBegin(dip->i_sb, 0);\n\n\tmutex_lock_nested(&JFS_IP(dip)->commit_mutex, COMMIT_MUTEX_PARENT);\n\tmutex_lock_nested(&JFS_IP(ip)->commit_mutex, COMMIT_MUTEX_CHILD);\n\n\tiplist[0] = dip;\n\tiplist[1] = ip;\n\n\t \n\tino = ip->i_ino;\n\tif ((rc = dtDelete(tid, dip, &dname, &ino, JFS_REMOVE))) {\n\t\tjfs_err(\"jfs_unlink: dtDelete returned %d\", rc);\n\t\tif (rc == -EIO)\n\t\t\ttxAbort(tid, 1);\t \n\t\ttxEnd(tid);\n\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t\tmutex_unlock(&JFS_IP(dip)->commit_mutex);\n\t\tIWRITE_UNLOCK(ip);\n\t\tgoto out1;\n\t}\n\n\tASSERT(ip->i_nlink);\n\n\tdip->i_mtime = inode_set_ctime_to_ts(dip, inode_set_ctime_current(ip));\n\tmark_inode_dirty(dip);\n\n\t \n\tinode_dec_link_count(ip);\n\n\t \n\tif (ip->i_nlink == 0) {\n\t\tassert(!test_cflag(COMMIT_Nolink, ip));\n\t\t \n\t\tif ((new_size = commitZeroLink(tid, ip)) < 0) {\n\t\t\ttxAbort(tid, 1);\t \n\t\t\ttxEnd(tid);\n\t\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t\t\tmutex_unlock(&JFS_IP(dip)->commit_mutex);\n\t\t\tIWRITE_UNLOCK(ip);\n\t\t\trc = new_size;\n\t\t\tgoto out1;\n\t\t}\n\t\ttblk = tid_to_tblock(tid);\n\t\ttblk->xflag |= COMMIT_DELETE;\n\t\ttblk->u.ip = ip;\n\t}\n\n\t \n\tif (new_size)\n\t\tcommit_flag = COMMIT_SYNC;\n\telse\n\t\tcommit_flag = 0;\n\n\t \n\trc = txCommit(tid, 2, &iplist[0], commit_flag);\n\n\ttxEnd(tid);\n\n\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\tmutex_unlock(&JFS_IP(dip)->commit_mutex);\n\n\twhile (new_size && (rc == 0)) {\n\t\ttid = txBegin(dip->i_sb, 0);\n\t\tmutex_lock(&JFS_IP(ip)->commit_mutex);\n\t\tnew_size = xtTruncate_pmap(tid, ip, new_size);\n\t\tif (new_size < 0) {\n\t\t\ttxAbort(tid, 1);\t \n\t\t\trc = new_size;\n\t\t} else\n\t\t\trc = txCommit(tid, 2, &iplist[0], COMMIT_SYNC);\n\t\ttxEnd(tid);\n\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t}\n\n\tif (ip->i_nlink == 0)\n\t\tset_cflag(COMMIT_Nolink, ip);\n\n\tIWRITE_UNLOCK(ip);\n\n\t \n\tif (test_cflag(COMMIT_Stale, dip)) {\n\t\tif (dip->i_size > 1)\n\t\t\tjfs_truncate_nolock(dip, 0);\n\n\t\tclear_cflag(COMMIT_Stale, dip);\n\t}\n\n      out1:\n\tfree_UCSname(&dname);\n      out:\n\tjfs_info(\"jfs_unlink: rc:%d\", rc);\n\treturn rc;\n}\n\n \nstatic s64 commitZeroLink(tid_t tid, struct inode *ip)\n{\n\tint filetype;\n\tstruct tblock *tblk;\n\n\tjfs_info(\"commitZeroLink: tid = %d, ip = 0x%p\", tid, ip);\n\n\tfiletype = ip->i_mode & S_IFMT;\n\tswitch (filetype) {\n\tcase S_IFREG:\n\t\tbreak;\n\tcase S_IFLNK:\n\t\t \n\t\tif (ip->i_size < IDATASIZE) {\n\t\t\tip->i_size = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tassert(filetype != S_IFDIR);\n\t\treturn 0;\n\t}\n\n\tset_cflag(COMMIT_Freewmap, ip);\n\n\t \n\ttblk = tid_to_tblock(tid);\n\ttblk->xflag |= COMMIT_PMAP;\n\n\t \n\tif (JFS_IP(ip)->ea.flag & DXD_EXTENT)\n\t\t \n\t\ttxEA(tid, ip, &JFS_IP(ip)->ea, NULL);\n\n\t \n\tif (JFS_IP(ip)->acl.flag & DXD_EXTENT)\n\t\t \n\t\ttxEA(tid, ip, &JFS_IP(ip)->acl, NULL);\n\n\t \n\tif (ip->i_size)\n\t\treturn xtTruncate_pmap(tid, ip, 0);\n\n\treturn 0;\n}\n\n\n \nvoid jfs_free_zero_link(struct inode *ip)\n{\n\tint type;\n\n\tjfs_info(\"jfs_free_zero_link: ip = 0x%p\", ip);\n\n\t \n\ttype = ip->i_mode & S_IFMT;\n\n\tswitch (type) {\n\tcase S_IFREG:\n\t\tbreak;\n\tcase S_IFLNK:\n\t\t \n\t\tif (ip->i_size < IDATASIZE)\n\t\t\treturn;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\t \n\tif (JFS_IP(ip)->ea.flag & DXD_EXTENT) {\n\t\ts64 xaddr = addressDXD(&JFS_IP(ip)->ea);\n\t\tint xlen = lengthDXD(&JFS_IP(ip)->ea);\n\t\tstruct maplock maplock;\t \n\t\tstruct pxd_lock *pxdlock;\t \n\n\t\t \n\t\tinvalidate_dxd_metapages(ip, JFS_IP(ip)->ea);\n\n\t\t \n\t\tmaplock.index = 1;\n\t\tpxdlock = (struct pxd_lock *) & maplock;\n\t\tpxdlock->flag = mlckFREEPXD;\n\t\tPXDaddress(&pxdlock->pxd, xaddr);\n\t\tPXDlength(&pxdlock->pxd, xlen);\n\t\ttxFreeMap(ip, pxdlock, NULL, COMMIT_WMAP);\n\t}\n\n\t \n\tif (JFS_IP(ip)->acl.flag & DXD_EXTENT) {\n\t\ts64 xaddr = addressDXD(&JFS_IP(ip)->acl);\n\t\tint xlen = lengthDXD(&JFS_IP(ip)->acl);\n\t\tstruct maplock maplock;\t \n\t\tstruct pxd_lock *pxdlock;\t \n\n\t\tinvalidate_dxd_metapages(ip, JFS_IP(ip)->acl);\n\n\t\t \n\t\tmaplock.index = 1;\n\t\tpxdlock = (struct pxd_lock *) & maplock;\n\t\tpxdlock->flag = mlckFREEPXD;\n\t\tPXDaddress(&pxdlock->pxd, xaddr);\n\t\tPXDlength(&pxdlock->pxd, xlen);\n\t\ttxFreeMap(ip, pxdlock, NULL, COMMIT_WMAP);\n\t}\n\n\t \n\tif (ip->i_size)\n\t\txtTruncate(0, ip, 0, COMMIT_WMAP);\n}\n\n \nstatic int jfs_link(struct dentry *old_dentry,\n\t     struct inode *dir, struct dentry *dentry)\n{\n\tint rc;\n\ttid_t tid;\n\tstruct inode *ip = d_inode(old_dentry);\n\tino_t ino;\n\tstruct component_name dname;\n\tstruct btstack btstack;\n\tstruct inode *iplist[2];\n\n\tjfs_info(\"jfs_link: %pd %pd\", old_dentry, dentry);\n\n\trc = dquot_initialize(dir);\n\tif (rc)\n\t\tgoto out;\n\n\tif (isReadOnly(ip)) {\n\t\tjfs_error(ip->i_sb, \"read-only filesystem\\n\");\n\t\treturn -EROFS;\n\t}\n\n\ttid = txBegin(ip->i_sb, 0);\n\n\tmutex_lock_nested(&JFS_IP(dir)->commit_mutex, COMMIT_MUTEX_PARENT);\n\tmutex_lock_nested(&JFS_IP(ip)->commit_mutex, COMMIT_MUTEX_CHILD);\n\n\t \n\tif ((rc = get_UCSname(&dname, dentry)))\n\t\tgoto out_tx;\n\n\tif ((rc = dtSearch(dir, &dname, &ino, &btstack, JFS_CREATE)))\n\t\tgoto free_dname;\n\n\t \n\tino = ip->i_ino;\n\tif ((rc = dtInsert(tid, dir, &dname, &ino, &btstack)))\n\t\tgoto free_dname;\n\n\t \n\tinc_nlink(ip);\t\t \n\tinode_set_ctime_current(ip);\n\tdir->i_mtime = inode_set_ctime_current(dir);\n\tmark_inode_dirty(dir);\n\tihold(ip);\n\n\tiplist[0] = ip;\n\tiplist[1] = dir;\n\trc = txCommit(tid, 2, &iplist[0], 0);\n\n\tif (rc) {\n\t\tdrop_nlink(ip);  \n\t\tiput(ip);\n\t} else\n\t\td_instantiate(dentry, ip);\n\n      free_dname:\n\tfree_UCSname(&dname);\n\n      out_tx:\n\ttxEnd(tid);\n\n\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\tmutex_unlock(&JFS_IP(dir)->commit_mutex);\n\n      out:\n\tjfs_info(\"jfs_link: rc:%d\", rc);\n\treturn rc;\n}\n\n \n\nstatic int jfs_symlink(struct mnt_idmap *idmap, struct inode *dip,\n\t\t       struct dentry *dentry, const char *name)\n{\n\tint rc;\n\ttid_t tid;\n\tino_t ino = 0;\n\tstruct component_name dname;\n\tu32 ssize;\t\t \n\tstruct btstack btstack;\n\tstruct inode *ip;\n\ts64 xlen = 0;\n\tint bmask = 0, xsize;\n\ts64 xaddr;\n\tstruct metapage *mp;\n\tstruct super_block *sb;\n\tstruct tblock *tblk;\n\n\tstruct inode *iplist[2];\n\n\tjfs_info(\"jfs_symlink: dip:0x%p name:%s\", dip, name);\n\n\trc = dquot_initialize(dip);\n\tif (rc)\n\t\tgoto out1;\n\n\tssize = strlen(name) + 1;\n\n\t \n\n\tif ((rc = get_UCSname(&dname, dentry)))\n\t\tgoto out1;\n\n\t \n\tip = ialloc(dip, S_IFLNK | 0777);\n\tif (IS_ERR(ip)) {\n\t\trc = PTR_ERR(ip);\n\t\tgoto out2;\n\t}\n\n\ttid = txBegin(dip->i_sb, 0);\n\n\tmutex_lock_nested(&JFS_IP(dip)->commit_mutex, COMMIT_MUTEX_PARENT);\n\tmutex_lock_nested(&JFS_IP(ip)->commit_mutex, COMMIT_MUTEX_CHILD);\n\n\trc = jfs_init_security(tid, ip, dip, &dentry->d_name);\n\tif (rc)\n\t\tgoto out3;\n\n\ttblk = tid_to_tblock(tid);\n\ttblk->xflag |= COMMIT_CREATE;\n\ttblk->ino = ip->i_ino;\n\ttblk->u.ixpxd = JFS_IP(ip)->ixpxd;\n\n\t \n\tip->i_mode |= 0777;\n\n\t \n\txtInitRoot(tid, ip);\n\n\t \n\n\tif (ssize <= IDATASIZE) {\n\t\tip->i_op = &jfs_fast_symlink_inode_operations;\n\n\t\tip->i_link = JFS_IP(ip)->i_inline_all;\n\t\tmemcpy(ip->i_link, name, ssize);\n\t\tip->i_size = ssize - 1;\n\n\t\t \n\t\tif (ssize > sizeof (JFS_IP(ip)->i_inline))\n\t\t\tJFS_IP(ip)->mode2 &= ~INLINEEA;\n\n\t\tjfs_info(\"jfs_symlink: fast symlink added  ssize:%u name:%s \",\n\t\t\t ssize, name);\n\t}\n\t \n\telse {\n\t\tjfs_info(\"jfs_symlink: allocate extent ip:0x%p\", ip);\n\n\t\tip->i_op = &jfs_symlink_inode_operations;\n\t\tinode_nohighmem(ip);\n\t\tip->i_mapping->a_ops = &jfs_aops;\n\n\t\t \n\t\tsb = ip->i_sb;\n\t\tbmask = JFS_SBI(sb)->bsize - 1;\n\t\txsize = (ssize + bmask) & ~bmask;\n\t\txaddr = 0;\n\t\txlen = xsize >> JFS_SBI(sb)->l2bsize;\n\t\tif ((rc = xtInsert(tid, ip, 0, 0, xlen, &xaddr, 0))) {\n\t\t\ttxAbort(tid, 0);\n\t\t\tgoto out3;\n\t\t}\n\t\tip->i_size = ssize - 1;\n\t\twhile (ssize) {\n\t\t\t \n\t\t\tu32 copy_size = min_t(u32, ssize, PSIZE);\n\n\t\t\tmp = get_metapage(ip, xaddr, PSIZE, 1);\n\n\t\t\tif (mp == NULL) {\n\t\t\t\txtTruncate(tid, ip, 0, COMMIT_PWMAP);\n\t\t\t\trc = -EIO;\n\t\t\t\ttxAbort(tid, 0);\n\t\t\t\tgoto out3;\n\t\t\t}\n\t\t\tmemcpy(mp->data, name, copy_size);\n\t\t\tflush_metapage(mp);\n\t\t\tssize -= copy_size;\n\t\t\tname += copy_size;\n\t\t\txaddr += JFS_SBI(sb)->nbperpage;\n\t\t}\n\t}\n\n\t \n\trc = dtSearch(dip, &dname, &ino, &btstack, JFS_CREATE);\n\tif (rc == 0) {\n\t\tino = ip->i_ino;\n\t\trc = dtInsert(tid, dip, &dname, &ino, &btstack);\n\t}\n\tif (rc) {\n\t\tif (xlen)\n\t\t\txtTruncate(tid, ip, 0, COMMIT_PWMAP);\n\t\ttxAbort(tid, 0);\n\t\t \n\t\tgoto out3;\n\t}\n\n\tmark_inode_dirty(ip);\n\n\tdip->i_mtime = inode_set_ctime_current(dip);\n\tmark_inode_dirty(dip);\n\t \n\n\tiplist[0] = dip;\n\tiplist[1] = ip;\n\trc = txCommit(tid, 2, &iplist[0], 0);\n\n      out3:\n\ttxEnd(tid);\n\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\tmutex_unlock(&JFS_IP(dip)->commit_mutex);\n\tif (rc) {\n\t\tfree_ea_wmap(ip);\n\t\tclear_nlink(ip);\n\t\tdiscard_new_inode(ip);\n\t} else {\n\t\td_instantiate_new(dentry, ip);\n\t}\n\n      out2:\n\tfree_UCSname(&dname);\n\n      out1:\n\tjfs_info(\"jfs_symlink: rc:%d\", rc);\n\treturn rc;\n}\n\n\n \nstatic int jfs_rename(struct mnt_idmap *idmap, struct inode *old_dir,\n\t\t      struct dentry *old_dentry, struct inode *new_dir,\n\t\t      struct dentry *new_dentry, unsigned int flags)\n{\n\tstruct btstack btstack;\n\tino_t ino;\n\tstruct component_name new_dname;\n\tstruct inode *new_ip;\n\tstruct component_name old_dname;\n\tstruct inode *old_ip;\n\tint rc;\n\ttid_t tid;\n\tstruct tlock *tlck;\n\tstruct dt_lock *dtlck;\n\tstruct lv *lv;\n\tint ipcount;\n\tstruct inode *iplist[4];\n\tstruct tblock *tblk;\n\ts64 new_size = 0;\n\tint commit_flag;\n\n\tif (flags & ~RENAME_NOREPLACE)\n\t\treturn -EINVAL;\n\n\tjfs_info(\"jfs_rename: %pd %pd\", old_dentry, new_dentry);\n\n\trc = dquot_initialize(old_dir);\n\tif (rc)\n\t\tgoto out1;\n\trc = dquot_initialize(new_dir);\n\tif (rc)\n\t\tgoto out1;\n\n\told_ip = d_inode(old_dentry);\n\tnew_ip = d_inode(new_dentry);\n\n\tif ((rc = get_UCSname(&old_dname, old_dentry)))\n\t\tgoto out1;\n\n\tif ((rc = get_UCSname(&new_dname, new_dentry)))\n\t\tgoto out2;\n\n\t \n\trc = dtSearch(old_dir, &old_dname, &ino, &btstack, JFS_LOOKUP);\n\tif (rc || (ino != old_ip->i_ino)) {\n\t\trc = -ENOENT;\n\t\tgoto out3;\n\t}\n\n\t \n\trc = dtSearch(new_dir, &new_dname, &ino, &btstack, JFS_LOOKUP);\n\tif (!rc) {\n\t\tif ((!new_ip) || (ino != new_ip->i_ino)) {\n\t\t\trc = -ESTALE;\n\t\t\tgoto out3;\n\t\t}\n\t} else if (rc != -ENOENT)\n\t\tgoto out3;\n\telse if (new_ip) {\n\t\t \n\t\trc = -ESTALE;\n\t\tgoto out3;\n\t}\n\n\tif (S_ISDIR(old_ip->i_mode)) {\n\t\tif (new_ip) {\n\t\t\tif (!dtEmpty(new_ip)) {\n\t\t\t\trc = -ENOTEMPTY;\n\t\t\t\tgoto out3;\n\t\t\t}\n\t\t}\n\t} else if (new_ip) {\n\t\tIWRITE_LOCK(new_ip, RDWRLOCK_NORMAL);\n\t\t \n\t\trc = dquot_initialize(new_ip);\n\t\tif (rc)\n\t\t\tgoto out_unlock;\n\t}\n\n\t \n\ttid = txBegin(new_dir->i_sb, 0);\n\n\t \n\tmutex_lock_nested(&JFS_IP(new_dir)->commit_mutex, COMMIT_MUTEX_PARENT);\n\tmutex_lock_nested(&JFS_IP(old_ip)->commit_mutex, COMMIT_MUTEX_CHILD);\n\tif (old_dir != new_dir)\n\t\tmutex_lock_nested(&JFS_IP(old_dir)->commit_mutex,\n\t\t\t\t  COMMIT_MUTEX_SECOND_PARENT);\n\n\tif (new_ip) {\n\t\tmutex_lock_nested(&JFS_IP(new_ip)->commit_mutex,\n\t\t\t\t  COMMIT_MUTEX_VICTIM);\n\t\t \n\t\tino = new_ip->i_ino;\n\t\trc = dtModify(tid, new_dir, &new_dname, &ino,\n\t\t\t      old_ip->i_ino, JFS_RENAME);\n\t\tif (rc)\n\t\t\tgoto out_tx;\n\t\tdrop_nlink(new_ip);\n\t\tif (S_ISDIR(new_ip->i_mode)) {\n\t\t\tdrop_nlink(new_ip);\n\t\t\tif (new_ip->i_nlink) {\n\t\t\t\tmutex_unlock(&JFS_IP(new_ip)->commit_mutex);\n\t\t\t\tif (old_dir != new_dir)\n\t\t\t\t\tmutex_unlock(&JFS_IP(old_dir)->commit_mutex);\n\t\t\t\tmutex_unlock(&JFS_IP(old_ip)->commit_mutex);\n\t\t\t\tmutex_unlock(&JFS_IP(new_dir)->commit_mutex);\n\t\t\t\tif (!S_ISDIR(old_ip->i_mode) && new_ip)\n\t\t\t\t\tIWRITE_UNLOCK(new_ip);\n\t\t\t\tjfs_error(new_ip->i_sb,\n\t\t\t\t\t  \"new_ip->i_nlink != 0\\n\");\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\ttblk = tid_to_tblock(tid);\n\t\t\ttblk->xflag |= COMMIT_DELETE;\n\t\t\ttblk->u.ip = new_ip;\n\t\t} else if (new_ip->i_nlink == 0) {\n\t\t\tassert(!test_cflag(COMMIT_Nolink, new_ip));\n\t\t\t \n\t\t\tif ((new_size = commitZeroLink(tid, new_ip)) < 0) {\n\t\t\t\ttxAbort(tid, 1);\t \n\t\t\t\trc = new_size;\n\t\t\t\tgoto out_tx;\n\t\t\t}\n\t\t\ttblk = tid_to_tblock(tid);\n\t\t\ttblk->xflag |= COMMIT_DELETE;\n\t\t\ttblk->u.ip = new_ip;\n\t\t} else {\n\t\t\tinode_set_ctime_current(new_ip);\n\t\t\tmark_inode_dirty(new_ip);\n\t\t}\n\t} else {\n\t\t \n\t\trc = dtSearch(new_dir, &new_dname, &ino, &btstack,\n\t\t\t      JFS_CREATE);\n\t\tif (rc) {\n\t\t\tjfs_err(\"jfs_rename didn't expect dtSearch to fail w/rc = %d\",\n\t\t\t\trc);\n\t\t\tgoto out_tx;\n\t\t}\n\n\t\tino = old_ip->i_ino;\n\t\trc = dtInsert(tid, new_dir, &new_dname, &ino, &btstack);\n\t\tif (rc) {\n\t\t\tif (rc == -EIO)\n\t\t\t\tjfs_err(\"jfs_rename: dtInsert returned -EIO\");\n\t\t\tgoto out_tx;\n\t\t}\n\t\tif (S_ISDIR(old_ip->i_mode))\n\t\t\tinc_nlink(new_dir);\n\t}\n\t \n\n\tino = old_ip->i_ino;\n\trc = dtDelete(tid, old_dir, &old_dname, &ino, JFS_REMOVE);\n\tif (rc) {\n\t\tjfs_err(\"jfs_rename did not expect dtDelete to return rc = %d\",\n\t\t\trc);\n\t\ttxAbort(tid, 1);\t \n\t\tgoto out_tx;\n\t}\n\tif (S_ISDIR(old_ip->i_mode)) {\n\t\tdrop_nlink(old_dir);\n\t\tif (old_dir != new_dir) {\n\t\t\t \n\n\t\t\tJFS_IP(old_ip)->i_dtroot.header.idotdot =\n\t\t\t\tcpu_to_le32(new_dir->i_ino);\n\n\t\t\t \n\t\t\ttlck = txLock(tid, old_ip,\n\t\t\t\t    (struct metapage *) &JFS_IP(old_ip)->bxflag,\n\t\t\t\t      tlckDTREE | tlckBTROOT | tlckRELINK);\n\t\t\tdtlck = (struct dt_lock *) & tlck->lock;\n\t\t\tASSERT(dtlck->index == 0);\n\t\t\tlv = & dtlck->lv[0];\n\t\t\tlv->offset = 0;\n\t\t\tlv->length = 1;\n\t\t\tdtlck->index++;\n\t\t}\n\t}\n\n\t \n\tinode_set_ctime_current(old_ip);\n\tmark_inode_dirty(old_ip);\n\n\tnew_dir->i_mtime = inode_set_ctime_current(new_dir);\n\tmark_inode_dirty(new_dir);\n\n\t \n\tipcount = 0;\n\tiplist[ipcount++] = old_ip;\n\tif (new_ip)\n\t\tiplist[ipcount++] = new_ip;\n\tiplist[ipcount++] = old_dir;\n\n\tif (old_dir != new_dir) {\n\t\tiplist[ipcount++] = new_dir;\n\t\told_dir->i_mtime = inode_set_ctime_current(old_dir);\n\t\tmark_inode_dirty(old_dir);\n\t}\n\n\t \n\tif (new_size)\n\t\tcommit_flag = COMMIT_SYNC;\n\telse\n\t\tcommit_flag = 0;\n\n\trc = txCommit(tid, ipcount, iplist, commit_flag);\n\n      out_tx:\n\ttxEnd(tid);\n\tif (new_ip)\n\t\tmutex_unlock(&JFS_IP(new_ip)->commit_mutex);\n\tif (old_dir != new_dir)\n\t\tmutex_unlock(&JFS_IP(old_dir)->commit_mutex);\n\tmutex_unlock(&JFS_IP(old_ip)->commit_mutex);\n\tmutex_unlock(&JFS_IP(new_dir)->commit_mutex);\n\n\twhile (new_size && (rc == 0)) {\n\t\ttid = txBegin(new_ip->i_sb, 0);\n\t\tmutex_lock(&JFS_IP(new_ip)->commit_mutex);\n\t\tnew_size = xtTruncate_pmap(tid, new_ip, new_size);\n\t\tif (new_size < 0) {\n\t\t\ttxAbort(tid, 1);\n\t\t\trc = new_size;\n\t\t} else\n\t\t\trc = txCommit(tid, 1, &new_ip, COMMIT_SYNC);\n\t\ttxEnd(tid);\n\t\tmutex_unlock(&JFS_IP(new_ip)->commit_mutex);\n\t}\n\tif (new_ip && (new_ip->i_nlink == 0))\n\t\tset_cflag(COMMIT_Nolink, new_ip);\n\t \n\tif (test_cflag(COMMIT_Stale, old_dir)) {\n\t\tif (old_dir->i_size > 1)\n\t\t\tjfs_truncate_nolock(old_dir, 0);\n\n\t\tclear_cflag(COMMIT_Stale, old_dir);\n\t}\n      out_unlock:\n\tif (new_ip && !S_ISDIR(new_ip->i_mode))\n\t\tIWRITE_UNLOCK(new_ip);\n      out3:\n\tfree_UCSname(&new_dname);\n      out2:\n\tfree_UCSname(&old_dname);\n      out1:\n\tjfs_info(\"jfs_rename: returning %d\", rc);\n\treturn rc;\n}\n\n\n \nstatic int jfs_mknod(struct mnt_idmap *idmap, struct inode *dir,\n\t\t     struct dentry *dentry, umode_t mode, dev_t rdev)\n{\n\tstruct jfs_inode_info *jfs_ip;\n\tstruct btstack btstack;\n\tstruct component_name dname;\n\tino_t ino;\n\tstruct inode *ip;\n\tstruct inode *iplist[2];\n\tint rc;\n\ttid_t tid;\n\tstruct tblock *tblk;\n\n\tjfs_info(\"jfs_mknod: %pd\", dentry);\n\n\trc = dquot_initialize(dir);\n\tif (rc)\n\t\tgoto out;\n\n\tif ((rc = get_UCSname(&dname, dentry)))\n\t\tgoto out;\n\n\tip = ialloc(dir, mode);\n\tif (IS_ERR(ip)) {\n\t\trc = PTR_ERR(ip);\n\t\tgoto out1;\n\t}\n\tjfs_ip = JFS_IP(ip);\n\n\ttid = txBegin(dir->i_sb, 0);\n\n\tmutex_lock_nested(&JFS_IP(dir)->commit_mutex, COMMIT_MUTEX_PARENT);\n\tmutex_lock_nested(&JFS_IP(ip)->commit_mutex, COMMIT_MUTEX_CHILD);\n\n\trc = jfs_init_acl(tid, ip, dir);\n\tif (rc)\n\t\tgoto out3;\n\n\trc = jfs_init_security(tid, ip, dir, &dentry->d_name);\n\tif (rc) {\n\t\ttxAbort(tid, 0);\n\t\tgoto out3;\n\t}\n\n\tif ((rc = dtSearch(dir, &dname, &ino, &btstack, JFS_CREATE))) {\n\t\ttxAbort(tid, 0);\n\t\tgoto out3;\n\t}\n\n\ttblk = tid_to_tblock(tid);\n\ttblk->xflag |= COMMIT_CREATE;\n\ttblk->ino = ip->i_ino;\n\ttblk->u.ixpxd = JFS_IP(ip)->ixpxd;\n\n\tino = ip->i_ino;\n\tif ((rc = dtInsert(tid, dir, &dname, &ino, &btstack))) {\n\t\ttxAbort(tid, 0);\n\t\tgoto out3;\n\t}\n\n\tip->i_op = &jfs_file_inode_operations;\n\tjfs_ip->dev = new_encode_dev(rdev);\n\tinit_special_inode(ip, ip->i_mode, rdev);\n\n\tmark_inode_dirty(ip);\n\n\tdir->i_mtime = inode_set_ctime_current(dir);\n\n\tmark_inode_dirty(dir);\n\n\tiplist[0] = dir;\n\tiplist[1] = ip;\n\trc = txCommit(tid, 2, iplist, 0);\n\n      out3:\n\ttxEnd(tid);\n\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\tmutex_unlock(&JFS_IP(dir)->commit_mutex);\n\tif (rc) {\n\t\tfree_ea_wmap(ip);\n\t\tclear_nlink(ip);\n\t\tdiscard_new_inode(ip);\n\t} else {\n\t\td_instantiate_new(dentry, ip);\n\t}\n\n      out1:\n\tfree_UCSname(&dname);\n\n      out:\n\tjfs_info(\"jfs_mknod: returning %d\", rc);\n\treturn rc;\n}\n\nstatic struct dentry *jfs_lookup(struct inode *dip, struct dentry *dentry, unsigned int flags)\n{\n\tstruct btstack btstack;\n\tino_t inum;\n\tstruct inode *ip;\n\tstruct component_name key;\n\tint rc;\n\n\tjfs_info(\"jfs_lookup: name = %pd\", dentry);\n\n\tif ((rc = get_UCSname(&key, dentry)))\n\t\treturn ERR_PTR(rc);\n\trc = dtSearch(dip, &key, &inum, &btstack, JFS_LOOKUP);\n\tfree_UCSname(&key);\n\tif (rc == -ENOENT) {\n\t\tip = NULL;\n\t} else if (rc) {\n\t\tjfs_err(\"jfs_lookup: dtSearch returned %d\", rc);\n\t\tip = ERR_PTR(rc);\n\t} else {\n\t\tip = jfs_iget(dip->i_sb, inum);\n\t\tif (IS_ERR(ip))\n\t\t\tjfs_err(\"jfs_lookup: iget failed on inum %d\", (uint)inum);\n\t}\n\n\treturn d_splice_alias(ip, dentry);\n}\n\nstatic struct inode *jfs_nfs_get_inode(struct super_block *sb,\n\t\tu64 ino, u32 generation)\n{\n\tstruct inode *inode;\n\n\tif (ino == 0)\n\t\treturn ERR_PTR(-ESTALE);\n\tinode = jfs_iget(sb, ino);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tif (generation && inode->i_generation != generation) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ESTALE);\n\t}\n\n\treturn inode;\n}\n\nstruct dentry *jfs_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type)\n{\n\treturn generic_fh_to_dentry(sb, fid, fh_len, fh_type,\n\t\t\t\t    jfs_nfs_get_inode);\n}\n\nstruct dentry *jfs_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type)\n{\n\treturn generic_fh_to_parent(sb, fid, fh_len, fh_type,\n\t\t\t\t    jfs_nfs_get_inode);\n}\n\nstruct dentry *jfs_get_parent(struct dentry *dentry)\n{\n\tunsigned long parent_ino;\n\n\tparent_ino =\n\t\tle32_to_cpu(JFS_IP(d_inode(dentry))->i_dtroot.header.idotdot);\n\n\treturn d_obtain_alias(jfs_iget(dentry->d_sb, parent_ino));\n}\n\nconst struct inode_operations jfs_dir_inode_operations = {\n\t.create\t\t= jfs_create,\n\t.lookup\t\t= jfs_lookup,\n\t.link\t\t= jfs_link,\n\t.unlink\t\t= jfs_unlink,\n\t.symlink\t= jfs_symlink,\n\t.mkdir\t\t= jfs_mkdir,\n\t.rmdir\t\t= jfs_rmdir,\n\t.mknod\t\t= jfs_mknod,\n\t.rename\t\t= jfs_rename,\n\t.listxattr\t= jfs_listxattr,\n\t.setattr\t= jfs_setattr,\n\t.fileattr_get\t= jfs_fileattr_get,\n\t.fileattr_set\t= jfs_fileattr_set,\n#ifdef CONFIG_JFS_POSIX_ACL\n\t.get_inode_acl\t= jfs_get_acl,\n\t.set_acl\t= jfs_set_acl,\n#endif\n};\n\nWRAP_DIR_ITER(jfs_readdir)  \nconst struct file_operations jfs_dir_operations = {\n\t.read\t\t= generic_read_dir,\n\t.iterate_shared\t= shared_jfs_readdir,\n\t.fsync\t\t= jfs_fsync,\n\t.unlocked_ioctl = jfs_ioctl,\n\t.compat_ioctl\t= compat_ptr_ioctl,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic int jfs_ci_hash(const struct dentry *dir, struct qstr *this)\n{\n\tunsigned long hash;\n\tint i;\n\n\thash = init_name_hash(dir);\n\tfor (i=0; i < this->len; i++)\n\t\thash = partial_name_hash(tolower(this->name[i]), hash);\n\tthis->hash = end_name_hash(hash);\n\n\treturn 0;\n}\n\nstatic int jfs_ci_compare(const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name)\n{\n\tint i, result = 1;\n\n\tif (len != name->len)\n\t\tgoto out;\n\tfor (i=0; i < len; i++) {\n\t\tif (tolower(str[i]) != tolower(name->name[i]))\n\t\t\tgoto out;\n\t}\n\tresult = 0;\nout:\n\treturn result;\n}\n\nstatic int jfs_ci_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\t \n\tif (d_really_is_positive(dentry))\n\t\treturn 1;\n\n\t \n\tif (!flags)\n\t\treturn 0;\n\n\t \n\tif (flags & (LOOKUP_CREATE | LOOKUP_RENAME_TARGET))\n\t\treturn 0;\n\treturn 1;\n}\n\nconst struct dentry_operations jfs_ci_dentry_operations =\n{\n\t.d_hash = jfs_ci_hash,\n\t.d_compare = jfs_ci_compare,\n\t.d_revalidate = jfs_ci_revalidate,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}