{
  "module_name": "jfs_imap.c",
  "hash_id": "be5906b15795a61d70a5be234a4367103d1e1fccc39089fe6715783ed1600f54",
  "original_prompt": "Ingested from linux-6.6.14/fs/jfs/jfs_imap.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n\n#include \"jfs_incore.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_debug.h\"\n\n \n \n#define IAGFREE_LOCK_INIT(imap)\t\tmutex_init(&imap->im_freelock)\n#define IAGFREE_LOCK(imap)\t\tmutex_lock(&imap->im_freelock)\n#define IAGFREE_UNLOCK(imap)\t\tmutex_unlock(&imap->im_freelock)\n\n \n#define AG_LOCK_INIT(imap,index)\tmutex_init(&(imap->im_aglock[index]))\n#define AG_LOCK(imap,agno)\t\tmutex_lock(&imap->im_aglock[agno])\n#define AG_UNLOCK(imap,agno)\t\tmutex_unlock(&imap->im_aglock[agno])\n\n \nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocBit(struct inomap *, struct iag *, int);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int diFindFree(u32, int);\nstatic int diNewExt(struct inomap *, struct iag *, int);\nstatic int diNewIAG(struct inomap *, int *, int, struct metapage **);\nstatic void duplicateIXtree(struct super_block *, s64, int, s64 *);\n\nstatic int diIAGRead(struct inomap * imap, int, struct metapage **);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\n \nint diMount(struct inode *ipimap)\n{\n\tstruct inomap *imap;\n\tstruct metapage *mp;\n\tint index;\n\tstruct dinomap_disk *dinom_le;\n\n\t \n\t \n\timap = kmalloc(sizeof(struct inomap), GFP_KERNEL);\n\tif (imap == NULL)\n\t\treturn -ENOMEM;\n\n\t \n\n\tmp = read_metapage(ipimap,\n\t\t\t   IMAPBLKNO << JFS_SBI(ipimap->i_sb)->l2nbperpage,\n\t\t\t   PSIZE, 0);\n\tif (mp == NULL) {\n\t\tkfree(imap);\n\t\treturn -EIO;\n\t}\n\n\t \n\tdinom_le = (struct dinomap_disk *) mp->data;\n\timap->im_freeiag = le32_to_cpu(dinom_le->in_freeiag);\n\timap->im_nextiag = le32_to_cpu(dinom_le->in_nextiag);\n\tatomic_set(&imap->im_numinos, le32_to_cpu(dinom_le->in_numinos));\n\tatomic_set(&imap->im_numfree, le32_to_cpu(dinom_le->in_numfree));\n\timap->im_nbperiext = le32_to_cpu(dinom_le->in_nbperiext);\n\timap->im_l2nbperiext = le32_to_cpu(dinom_le->in_l2nbperiext);\n\tfor (index = 0; index < MAXAG; index++) {\n\t\timap->im_agctl[index].inofree =\n\t\t    le32_to_cpu(dinom_le->in_agctl[index].inofree);\n\t\timap->im_agctl[index].extfree =\n\t\t    le32_to_cpu(dinom_le->in_agctl[index].extfree);\n\t\timap->im_agctl[index].numinos =\n\t\t    le32_to_cpu(dinom_le->in_agctl[index].numinos);\n\t\timap->im_agctl[index].numfree =\n\t\t    le32_to_cpu(dinom_le->in_agctl[index].numfree);\n\t}\n\n\t \n\trelease_metapage(mp);\n\n\t \n\t \n\tIAGFREE_LOCK_INIT(imap);\n\n\t \n\tfor (index = 0; index < MAXAG; index++) {\n\t\tAG_LOCK_INIT(imap, index);\n\t}\n\n\t \n\timap->im_ipimap = ipimap;\n\tJFS_IP(ipimap)->i_imap = imap;\n\n\treturn (0);\n}\n\n\n \nint diUnmount(struct inode *ipimap, int mounterror)\n{\n\tstruct inomap *imap = JFS_IP(ipimap)->i_imap;\n\n\t \n\n\tif (!(mounterror || isReadOnly(ipimap)))\n\t\tdiSync(ipimap);\n\n\t \n\ttruncate_inode_pages(ipimap->i_mapping, 0);\n\n\t \n\tkfree(imap);\n\tJFS_IP(ipimap)->i_imap = NULL;\n\n\treturn (0);\n}\n\n\n \nint diSync(struct inode *ipimap)\n{\n\tstruct dinomap_disk *dinom_le;\n\tstruct inomap *imp = JFS_IP(ipimap)->i_imap;\n\tstruct metapage *mp;\n\tint index;\n\n\t \n\t \n\tmp = get_metapage(ipimap,\n\t\t\t  IMAPBLKNO << JFS_SBI(ipimap->i_sb)->l2nbperpage,\n\t\t\t  PSIZE, 0);\n\tif (mp == NULL) {\n\t\tjfs_err(\"diSync: get_metapage failed!\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tdinom_le = (struct dinomap_disk *) mp->data;\n\tdinom_le->in_freeiag = cpu_to_le32(imp->im_freeiag);\n\tdinom_le->in_nextiag = cpu_to_le32(imp->im_nextiag);\n\tdinom_le->in_numinos = cpu_to_le32(atomic_read(&imp->im_numinos));\n\tdinom_le->in_numfree = cpu_to_le32(atomic_read(&imp->im_numfree));\n\tdinom_le->in_nbperiext = cpu_to_le32(imp->im_nbperiext);\n\tdinom_le->in_l2nbperiext = cpu_to_le32(imp->im_l2nbperiext);\n\tfor (index = 0; index < MAXAG; index++) {\n\t\tdinom_le->in_agctl[index].inofree =\n\t\t    cpu_to_le32(imp->im_agctl[index].inofree);\n\t\tdinom_le->in_agctl[index].extfree =\n\t\t    cpu_to_le32(imp->im_agctl[index].extfree);\n\t\tdinom_le->in_agctl[index].numinos =\n\t\t    cpu_to_le32(imp->im_agctl[index].numinos);\n\t\tdinom_le->in_agctl[index].numfree =\n\t\t    cpu_to_le32(imp->im_agctl[index].numfree);\n\t}\n\n\t \n\twrite_metapage(mp);\n\n\t \n\tfilemap_write_and_wait(ipimap->i_mapping);\n\n\tdiWriteSpecial(ipimap, 0);\n\n\treturn (0);\n}\n\n\n \nint diRead(struct inode *ip)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\n\tint iagno, ino, extno, rc;\n\tstruct inode *ipimap;\n\tstruct dinode *dp;\n\tstruct iag *iagp;\n\tstruct metapage *mp;\n\ts64 blkno, agstart;\n\tstruct inomap *imap;\n\tint block_offset;\n\tint inodes_left;\n\tunsigned long pageno;\n\tint rel_inode;\n\n\tjfs_info(\"diRead: ino = %ld\", ip->i_ino);\n\n\tipimap = sbi->ipimap;\n\tJFS_IP(ip)->ipimap = ipimap;\n\n\t \n\tiagno = INOTOIAG(ip->i_ino);\n\n\t \n\tIREAD_LOCK(ipimap, RDWRLOCK_IMAP);\n\timap = JFS_IP(ipimap)->i_imap;\n\trc = diIAGRead(imap, iagno, &mp);\n\tIREAD_UNLOCK(ipimap);\n\tif (rc) {\n\t\tjfs_err(\"diRead: diIAGRead returned %d\", rc);\n\t\treturn (rc);\n\t}\n\n\tiagp = (struct iag *) mp->data;\n\n\t \n\tino = ip->i_ino & (INOSPERIAG - 1);\n\textno = ino >> L2INOSPEREXT;\n\n\tif ((lengthPXD(&iagp->inoext[extno]) != imap->im_nbperiext) ||\n\t    (addressPXD(&iagp->inoext[extno]) == 0)) {\n\t\trelease_metapage(mp);\n\t\treturn -ESTALE;\n\t}\n\n\t \n\tblkno = INOPBLK(&iagp->inoext[extno], ino, sbi->l2nbperpage);\n\n\t \n\tagstart = le64_to_cpu(iagp->agstart);\n\n\trelease_metapage(mp);\n\n\trel_inode = (ino & (INOSPERPAGE - 1));\n\tpageno = blkno >> sbi->l2nbperpage;\n\n\tif ((block_offset = ((u32) blkno & (sbi->nbperpage - 1)))) {\n\t\t \n\t\tinodes_left =\n\t\t     (sbi->nbperpage - block_offset) << sbi->l2niperblk;\n\n\t\tif (rel_inode < inodes_left)\n\t\t\trel_inode += block_offset << sbi->l2niperblk;\n\t\telse {\n\t\t\tpageno += 1;\n\t\t\trel_inode -= inodes_left;\n\t\t}\n\t}\n\n\t \n\tmp = read_metapage(ipimap, pageno << sbi->l2nbperpage, PSIZE, 1);\n\tif (!mp) {\n\t\tjfs_err(\"diRead: read_metapage failed\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tdp = (struct dinode *) mp->data;\n\tdp += rel_inode;\n\n\tif (ip->i_ino != le32_to_cpu(dp->di_number)) {\n\t\tjfs_error(ip->i_sb, \"i_ino != di_number\\n\");\n\t\trc = -EIO;\n\t} else if (le32_to_cpu(dp->di_nlink) == 0)\n\t\trc = -ESTALE;\n\telse\n\t\t \n\t\trc = copy_from_dinode(dp, ip);\n\n\trelease_metapage(mp);\n\n\t \n\tJFS_IP(ip)->agstart = agstart;\n\tJFS_IP(ip)->active_ag = -1;\n\n\treturn (rc);\n}\n\n\n \nstruct inode *diReadSpecial(struct super_block *sb, ino_t inum, int secondary)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tuint address;\n\tstruct dinode *dp;\n\tstruct inode *ip;\n\tstruct metapage *mp;\n\n\tip = new_inode(sb);\n\tif (ip == NULL) {\n\t\tjfs_err(\"diReadSpecial: new_inode returned NULL!\");\n\t\treturn ip;\n\t}\n\n\tif (secondary) {\n\t\taddress = addressPXD(&sbi->ait2) >> sbi->l2nbperpage;\n\t\tJFS_IP(ip)->ipimap = sbi->ipaimap2;\n\t} else {\n\t\taddress = AITBL_OFF >> L2PSIZE;\n\t\tJFS_IP(ip)->ipimap = sbi->ipaimap;\n\t}\n\n\tASSERT(inum < INOSPEREXT);\n\n\tip->i_ino = inum;\n\n\taddress += inum >> 3;\t \n\n\t \n\tmp = read_metapage(ip, address << sbi->l2nbperpage, PSIZE, 1);\n\tif (mp == NULL) {\n\t\tset_nlink(ip, 1);\t \n\t\tiput(ip);\n\t\treturn (NULL);\n\t}\n\n\t \n\tdp = (struct dinode *) (mp->data);\n\tdp += inum % 8;\t\t \n\n\t \n\tif ((copy_from_dinode(dp, ip)) != 0) {\n\t\t \n\t\tset_nlink(ip, 1);\t \n\t\tiput(ip);\n\t\t \n\t\trelease_metapage(mp);\n\t\treturn (NULL);\n\n\t}\n\n\tip->i_mapping->a_ops = &jfs_metapage_aops;\n\tmapping_set_gfp_mask(ip->i_mapping, GFP_NOFS);\n\n\t \n\tip->i_flags |= S_NOQUOTA;\n\n\tif ((inum == FILESYSTEM_I) && (JFS_IP(ip)->ipimap == sbi->ipaimap)) {\n\t\tsbi->gengen = le32_to_cpu(dp->di_gengen);\n\t\tsbi->inostamp = le32_to_cpu(dp->di_inostamp);\n\t}\n\n\t \n\trelease_metapage(mp);\n\n\tinode_fake_hash(ip);\n\n\treturn (ip);\n}\n\n \n\nvoid diWriteSpecial(struct inode *ip, int secondary)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\n\tuint address;\n\tstruct dinode *dp;\n\tino_t inum = ip->i_ino;\n\tstruct metapage *mp;\n\n\tif (secondary)\n\t\taddress = addressPXD(&sbi->ait2) >> sbi->l2nbperpage;\n\telse\n\t\taddress = AITBL_OFF >> L2PSIZE;\n\n\tASSERT(inum < INOSPEREXT);\n\n\taddress += inum >> 3;\t \n\n\t \n\tmp = read_metapage(ip, address << sbi->l2nbperpage, PSIZE, 1);\n\tif (mp == NULL) {\n\t\tjfs_err(\"diWriteSpecial: failed to read aggregate inode extent!\");\n\t\treturn;\n\t}\n\n\t \n\tdp = (struct dinode *) (mp->data);\n\tdp += inum % 8;\t\t \n\n\t \n\tcopy_to_dinode(dp, ip);\n\tmemcpy(&dp->di_xtroot, &JFS_IP(ip)->i_xtroot, 288);\n\n\tif (inum == FILESYSTEM_I)\n\t\tdp->di_gengen = cpu_to_le32(sbi->gengen);\n\n\t \n\twrite_metapage(mp);\n}\n\n \nvoid diFreeSpecial(struct inode *ip)\n{\n\tif (ip == NULL) {\n\t\tjfs_err(\"diFreeSpecial called with NULL ip!\");\n\t\treturn;\n\t}\n\tfilemap_write_and_wait(ip->i_mapping);\n\ttruncate_inode_pages(ip->i_mapping, 0);\n\tiput(ip);\n}\n\n\n\n \nint diWrite(tid_t tid, struct inode *ip)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint rc = 0;\n\ts32 ino;\n\tstruct dinode *dp;\n\ts64 blkno;\n\tint block_offset;\n\tint inodes_left;\n\tstruct metapage *mp;\n\tunsigned long pageno;\n\tint rel_inode;\n\tint dioffset;\n\tstruct inode *ipimap;\n\tuint type;\n\tlid_t lid;\n\tstruct tlock *ditlck, *tlck;\n\tstruct linelock *dilinelock, *ilinelock;\n\tstruct lv *lv;\n\tint n;\n\n\tipimap = jfs_ip->ipimap;\n\n\tino = ip->i_ino & (INOSPERIAG - 1);\n\n\tif (!addressPXD(&(jfs_ip->ixpxd)) ||\n\t    (lengthPXD(&(jfs_ip->ixpxd)) !=\n\t     JFS_IP(ipimap)->i_imap->im_nbperiext)) {\n\t\tjfs_error(ip->i_sb, \"ixpxd invalid\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\t \n\tblkno = INOPBLK(&(jfs_ip->ixpxd), ino, sbi->l2nbperpage);\n\n\trel_inode = (ino & (INOSPERPAGE - 1));\n\tpageno = blkno >> sbi->l2nbperpage;\n\n\tif ((block_offset = ((u32) blkno & (sbi->nbperpage - 1)))) {\n\t\t \n\t\tinodes_left =\n\t\t    (sbi->nbperpage - block_offset) << sbi->l2niperblk;\n\n\t\tif (rel_inode < inodes_left)\n\t\t\trel_inode += block_offset << sbi->l2niperblk;\n\t\telse {\n\t\t\tpageno += 1;\n\t\t\trel_inode -= inodes_left;\n\t\t}\n\t}\n\t \n      retry:\n\tmp = read_metapage(ipimap, pageno << sbi->l2nbperpage, PSIZE, 1);\n\tif (!mp)\n\t\treturn -EIO;\n\n\t \n\tdp = (struct dinode *) mp->data;\n\tdp += rel_inode;\n\n\tdioffset = (ino & (INOSPERPAGE - 1)) << L2DISIZE;\n\n\t \n\tif ((ditlck =\n\t     txLock(tid, ipimap, mp, tlckINODE | tlckENTRY)) == NULL)\n\t\tgoto retry;\n\tdilinelock = (struct linelock *) & ditlck->lock;\n\n\t \n\n\tif (S_ISDIR(ip->i_mode) && (lid = jfs_ip->xtlid)) {\n\t\t \n\t\txtpage_t *p, *xp;\n\t\txad_t *xad;\n\n\t\tjfs_ip->xtlid = 0;\n\t\ttlck = lid_to_tlock(lid);\n\t\tassert(tlck->type & tlckXTREE);\n\t\ttlck->type |= tlckBTROOT;\n\t\ttlck->mp = mp;\n\t\tilinelock = (struct linelock *) & tlck->lock;\n\n\t\t \n\t\tp = &jfs_ip->i_xtroot;\n\t\txp = (xtpage_t *) &dp->di_dirtable;\n\t\tlv = ilinelock->lv;\n\t\tfor (n = 0; n < ilinelock->index; n++, lv++) {\n\t\t\tmemcpy(&xp->xad[lv->offset], &p->xad[lv->offset],\n\t\t\t       lv->length << L2XTSLOTSIZE);\n\t\t}\n\n\t\t \n\t\txad = &xp->xad[XTENTRYSTART];\n\t\tfor (n = XTENTRYSTART;\n\t\t     n < le16_to_cpu(xp->header.nextindex); n++, xad++)\n\t\t\tif (xad->flag & (XAD_NEW | XAD_EXTENDED))\n\t\t\t\txad->flag &= ~(XAD_NEW | XAD_EXTENDED);\n\t}\n\n\tif ((lid = jfs_ip->blid) == 0)\n\t\tgoto inlineData;\n\tjfs_ip->blid = 0;\n\n\ttlck = lid_to_tlock(lid);\n\ttype = tlck->type;\n\ttlck->type |= tlckBTROOT;\n\ttlck->mp = mp;\n\tilinelock = (struct linelock *) & tlck->lock;\n\n\t \n\tif (type & tlckXTREE) {\n\t\txtpage_t *p, *xp;\n\t\txad_t *xad;\n\n\t\t \n\t\tp = &jfs_ip->i_xtroot;\n\t\txp = &dp->di_xtroot;\n\t\tlv = ilinelock->lv;\n\t\tfor (n = 0; n < ilinelock->index; n++, lv++) {\n\t\t\tmemcpy(&xp->xad[lv->offset], &p->xad[lv->offset],\n\t\t\t       lv->length << L2XTSLOTSIZE);\n\t\t}\n\n\t\t \n\t\txad = &xp->xad[XTENTRYSTART];\n\t\tfor (n = XTENTRYSTART;\n\t\t     n < le16_to_cpu(xp->header.nextindex); n++, xad++)\n\t\t\tif (xad->flag & (XAD_NEW | XAD_EXTENDED))\n\t\t\t\txad->flag &= ~(XAD_NEW | XAD_EXTENDED);\n\t}\n\t \n\telse if (type & tlckDTREE) {\n\t\tdtpage_t *p, *xp;\n\n\t\t \n\t\tp = (dtpage_t *) &jfs_ip->i_dtroot;\n\t\txp = (dtpage_t *) & dp->di_dtroot;\n\t\tlv = ilinelock->lv;\n\t\tfor (n = 0; n < ilinelock->index; n++, lv++) {\n\t\t\tmemcpy(&xp->slot[lv->offset], &p->slot[lv->offset],\n\t\t\t       lv->length << L2DTSLOTSIZE);\n\t\t}\n\t} else {\n\t\tjfs_err(\"diWrite: UFO tlock\");\n\t}\n\n      inlineData:\n\t \n\tif (S_ISLNK(ip->i_mode) && ip->i_size < IDATASIZE) {\n\t\tlv = & dilinelock->lv[dilinelock->index];\n\t\tlv->offset = (dioffset + 2 * 128) >> L2INODESLOTSIZE;\n\t\tlv->length = 2;\n\t\tmemcpy(&dp->di_inline_all, jfs_ip->i_inline_all, IDATASIZE);\n\t\tdilinelock->index++;\n\t}\n\t \n\tif (test_cflag(COMMIT_Inlineea, ip)) {\n\t\tlv = & dilinelock->lv[dilinelock->index];\n\t\tlv->offset = (dioffset + 3 * 128) >> L2INODESLOTSIZE;\n\t\tlv->length = 1;\n\t\tmemcpy(&dp->di_inlineea, jfs_ip->i_inline_ea, INODESLOTSIZE);\n\t\tdilinelock->index++;\n\n\t\tclear_cflag(COMMIT_Inlineea, ip);\n\t}\n\n\t \n\tlv = & dilinelock->lv[dilinelock->index];\n\tlv->offset = dioffset >> L2INODESLOTSIZE;\n\tcopy_to_dinode(dp, ip);\n\tif (test_and_clear_cflag(COMMIT_Dirtable, ip)) {\n\t\tlv->length = 2;\n\t\tmemcpy(&dp->di_dirtable, &jfs_ip->i_dirtable, 96);\n\t} else\n\t\tlv->length = 1;\n\tdilinelock->index++;\n\n\t \n\twrite_metapage(mp);\n\n\treturn (rc);\n}\n\n\n \nint diFree(struct inode *ip)\n{\n\tint rc;\n\tino_t inum = ip->i_ino;\n\tstruct iag *iagp, *aiagp, *biagp, *ciagp, *diagp;\n\tstruct metapage *mp, *amp, *bmp, *cmp, *dmp;\n\tint iagno, ino, extno, bitno, sword, agno;\n\tint back, fwd;\n\tu32 bitmap, mask;\n\tstruct inode *ipimap = JFS_SBI(ip->i_sb)->ipimap;\n\tstruct inomap *imap = JFS_IP(ipimap)->i_imap;\n\tpxd_t freepxd;\n\ttid_t tid;\n\tstruct inode *iplist[3];\n\tstruct tlock *tlck;\n\tstruct pxd_lock *pxdlock;\n\n\t \n\taiagp = biagp = ciagp = diagp = NULL;\n\n\t \n\tiagno = INOTOIAG(inum);\n\n\t \n\tif (iagno >= imap->im_nextiag) {\n\t\tprint_hex_dump(KERN_ERR, \"imap: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       imap, 32, 0);\n\t\tjfs_error(ip->i_sb, \"inum = %d, iagno = %d, nextiag = %d\\n\",\n\t\t\t  (uint) inum, iagno, imap->im_nextiag);\n\t\treturn -EIO;\n\t}\n\n\t \n\tagno = BLKTOAG(JFS_IP(ip)->agstart, JFS_SBI(ip->i_sb));\n\n\t \n\tAG_LOCK(imap, agno);\n\n\t \n\tIREAD_LOCK(ipimap, RDWRLOCK_IMAP);\n\n\t \n\tif ((rc = diIAGRead(imap, iagno, &mp))) {\n\t\tIREAD_UNLOCK(ipimap);\n\t\tAG_UNLOCK(imap, agno);\n\t\treturn (rc);\n\t}\n\tiagp = (struct iag *) mp->data;\n\n\t \n\tino = inum & (INOSPERIAG - 1);\n\textno = ino >> L2INOSPEREXT;\n\tbitno = ino & (INOSPEREXT - 1);\n\tmask = HIGHORDER >> bitno;\n\n\tif (!(le32_to_cpu(iagp->wmap[extno]) & mask)) {\n\t\tjfs_error(ip->i_sb, \"wmap shows inode already free\\n\");\n\t}\n\n\tif (!addressPXD(&iagp->inoext[extno])) {\n\t\trelease_metapage(mp);\n\t\tIREAD_UNLOCK(ipimap);\n\t\tAG_UNLOCK(imap, agno);\n\t\tjfs_error(ip->i_sb, \"invalid inoext\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tbitmap = le32_to_cpu(iagp->wmap[extno]) & ~mask;\n\n\tif (imap->im_agctl[agno].numfree > imap->im_agctl[agno].numinos) {\n\t\trelease_metapage(mp);\n\t\tIREAD_UNLOCK(ipimap);\n\t\tAG_UNLOCK(imap, agno);\n\t\tjfs_error(ip->i_sb, \"numfree > numinos\\n\");\n\t\treturn -EIO;\n\t}\n\t \n\tif (bitmap ||\n\t    imap->im_agctl[agno].numfree < 96 ||\n\t    (imap->im_agctl[agno].numfree < 288 &&\n\t     (((imap->im_agctl[agno].numfree * 100) /\n\t       imap->im_agctl[agno].numinos) <= 25))) {\n\t\t \n\t\tif (iagp->nfreeinos == 0) {\n\t\t\t \n\t\t\tif ((fwd = imap->im_agctl[agno].inofree) >= 0) {\n\t\t\t\t \n\t\t\t\tif ((rc = diIAGRead(imap, fwd, &amp))) {\n\t\t\t\t\tIREAD_UNLOCK(ipimap);\n\t\t\t\t\tAG_UNLOCK(imap, agno);\n\t\t\t\t\trelease_metapage(mp);\n\t\t\t\t\treturn (rc);\n\t\t\t\t}\n\t\t\t\taiagp = (struct iag *) amp->data;\n\n\t\t\t\t \n\t\t\t\taiagp->inofreeback = cpu_to_le32(iagno);\n\n\t\t\t\twrite_metapage(amp);\n\t\t\t}\n\n\t\t\t \n\t\t\tiagp->inofreefwd =\n\t\t\t    cpu_to_le32(imap->im_agctl[agno].inofree);\n\t\t\tiagp->inofreeback = cpu_to_le32(-1);\n\t\t\timap->im_agctl[agno].inofree = iagno;\n\t\t}\n\t\tIREAD_UNLOCK(ipimap);\n\n\t\t \n\t\tif (iagp->wmap[extno] == cpu_to_le32(ONES)) {\n\t\t\tsword = extno >> L2EXTSPERSUM;\n\t\t\tbitno = extno & (EXTSPERSUM - 1);\n\t\t\tiagp->inosmap[sword] &=\n\t\t\t    cpu_to_le32(~(HIGHORDER >> bitno));\n\t\t}\n\n\t\t \n\t\tiagp->wmap[extno] = cpu_to_le32(bitmap);\n\n\t\t \n\t\tle32_add_cpu(&iagp->nfreeinos, 1);\n\t\timap->im_agctl[agno].numfree += 1;\n\t\tatomic_inc(&imap->im_numfree);\n\n\t\t \n\t\tAG_UNLOCK(imap, agno);\n\n\t\t \n\t\twrite_metapage(mp);\n\n\t\treturn (0);\n\t}\n\n\n\t \n\n\t \n\tamp = bmp = cmp = dmp = NULL;\n\tfwd = back = -1;\n\n\t \n\tif (iagp->nfreeexts == 0) {\n\t\t \n\t\tif ((fwd = imap->im_agctl[agno].extfree) >= 0) {\n\t\t\tif ((rc = diIAGRead(imap, fwd, &amp)))\n\t\t\t\tgoto error_out;\n\t\t\taiagp = (struct iag *) amp->data;\n\t\t}\n\t} else {\n\t\t \n\t\tif (iagp->nfreeexts == cpu_to_le32(EXTSPERIAG - 1)) {\n\t\t\t \n\t\t\tif ((fwd = le32_to_cpu(iagp->extfreefwd)) >= 0) {\n\t\t\t\tif ((rc = diIAGRead(imap, fwd, &amp)))\n\t\t\t\t\tgoto error_out;\n\t\t\t\taiagp = (struct iag *) amp->data;\n\t\t\t}\n\n\t\t\tif ((back = le32_to_cpu(iagp->extfreeback)) >= 0) {\n\t\t\t\tif ((rc = diIAGRead(imap, back, &bmp)))\n\t\t\t\t\tgoto error_out;\n\t\t\t\tbiagp = (struct iag *) bmp->data;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (iagp->nfreeinos == cpu_to_le32(INOSPEREXT - 1)) {\n\t\tint inofreeback = le32_to_cpu(iagp->inofreeback);\n\t\tint inofreefwd = le32_to_cpu(iagp->inofreefwd);\n\n\t\t \n\t\tif (inofreefwd >= 0) {\n\n\t\t\tif (inofreefwd == fwd)\n\t\t\t\tciagp = (struct iag *) amp->data;\n\t\t\telse if (inofreefwd == back)\n\t\t\t\tciagp = (struct iag *) bmp->data;\n\t\t\telse {\n\t\t\t\tif ((rc =\n\t\t\t\t     diIAGRead(imap, inofreefwd, &cmp)))\n\t\t\t\t\tgoto error_out;\n\t\t\t\tciagp = (struct iag *) cmp->data;\n\t\t\t}\n\t\t\tassert(ciagp != NULL);\n\t\t}\n\n\t\tif (inofreeback >= 0) {\n\t\t\tif (inofreeback == fwd)\n\t\t\t\tdiagp = (struct iag *) amp->data;\n\t\t\telse if (inofreeback == back)\n\t\t\t\tdiagp = (struct iag *) bmp->data;\n\t\t\telse {\n\t\t\t\tif ((rc =\n\t\t\t\t     diIAGRead(imap, inofreeback, &dmp)))\n\t\t\t\t\tgoto error_out;\n\t\t\t\tdiagp = (struct iag *) dmp->data;\n\t\t\t}\n\t\t\tassert(diagp != NULL);\n\t\t}\n\t}\n\n\tIREAD_UNLOCK(ipimap);\n\n\t \n\tfreepxd = iagp->inoext[extno];\n\tinvalidate_pxd_metapages(ip, freepxd);\n\n\t \n\t \n\tif (iagp->nfreeexts == 0) {\n\t\tif (fwd >= 0)\n\t\t\taiagp->extfreeback = cpu_to_le32(iagno);\n\n\t\tiagp->extfreefwd =\n\t\t    cpu_to_le32(imap->im_agctl[agno].extfree);\n\t\tiagp->extfreeback = cpu_to_le32(-1);\n\t\timap->im_agctl[agno].extfree = iagno;\n\t} else {\n\t\t \n\t\tif (iagp->nfreeexts == cpu_to_le32(EXTSPERIAG - 1)) {\n\t\t\tif (fwd >= 0)\n\t\t\t\taiagp->extfreeback = iagp->extfreeback;\n\n\t\t\tif (back >= 0)\n\t\t\t\tbiagp->extfreefwd = iagp->extfreefwd;\n\t\t\telse\n\t\t\t\timap->im_agctl[agno].extfree =\n\t\t\t\t    le32_to_cpu(iagp->extfreefwd);\n\n\t\t\tiagp->extfreefwd = iagp->extfreeback = cpu_to_le32(-1);\n\n\t\t\tIAGFREE_LOCK(imap);\n\t\t\tiagp->iagfree = cpu_to_le32(imap->im_freeiag);\n\t\t\timap->im_freeiag = iagno;\n\t\t\tIAGFREE_UNLOCK(imap);\n\t\t}\n\t}\n\n\t \n\tif (iagp->nfreeinos == cpu_to_le32(INOSPEREXT - 1)) {\n\t\tif ((int) le32_to_cpu(iagp->inofreefwd) >= 0)\n\t\t\tciagp->inofreeback = iagp->inofreeback;\n\n\t\tif ((int) le32_to_cpu(iagp->inofreeback) >= 0)\n\t\t\tdiagp->inofreefwd = iagp->inofreefwd;\n\t\telse\n\t\t\timap->im_agctl[agno].inofree =\n\t\t\t    le32_to_cpu(iagp->inofreefwd);\n\n\t\tiagp->inofreefwd = iagp->inofreeback = cpu_to_le32(-1);\n\t}\n\n\t \n\tif (iagp->pmap[extno] != 0) {\n\t\tjfs_error(ip->i_sb, \"the pmap does not show inode free\\n\");\n\t}\n\tiagp->wmap[extno] = 0;\n\tPXDlength(&iagp->inoext[extno], 0);\n\tPXDaddress(&iagp->inoext[extno], 0);\n\n\t \n\tsword = extno >> L2EXTSPERSUM;\n\tbitno = extno & (EXTSPERSUM - 1);\n\tmask = HIGHORDER >> bitno;\n\tiagp->inosmap[sword] |= cpu_to_le32(mask);\n\tiagp->extsmap[sword] &= cpu_to_le32(~mask);\n\n\t \n\tle32_add_cpu(&iagp->nfreeinos, -(INOSPEREXT - 1));\n\tle32_add_cpu(&iagp->nfreeexts, 1);\n\n\t \n\timap->im_agctl[agno].numfree -= (INOSPEREXT - 1);\n\timap->im_agctl[agno].numinos -= INOSPEREXT;\n\tatomic_sub(INOSPEREXT - 1, &imap->im_numfree);\n\tatomic_sub(INOSPEREXT, &imap->im_numinos);\n\n\tif (amp)\n\t\twrite_metapage(amp);\n\tif (bmp)\n\t\twrite_metapage(bmp);\n\tif (cmp)\n\t\twrite_metapage(cmp);\n\tif (dmp)\n\t\twrite_metapage(dmp);\n\n\t \n\ttid = txBegin(ipimap->i_sb, COMMIT_FORCE);\n\tmutex_lock(&JFS_IP(ipimap)->commit_mutex);\n\n\t \n\ttlck = txLock(tid, ipimap, mp, tlckINODE | tlckFREE);\n\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\tpxdlock->flag = mlckFREEPXD;\n\tpxdlock->pxd = freepxd;\n\tpxdlock->index = 1;\n\n\twrite_metapage(mp);\n\n\tiplist[0] = ipimap;\n\n\t \n\tiplist[1] = (struct inode *) (size_t)iagno;\n\tiplist[2] = (struct inode *) (size_t)extno;\n\n\trc = txCommit(tid, 1, &iplist[0], COMMIT_FORCE);\n\n\ttxEnd(tid);\n\tmutex_unlock(&JFS_IP(ipimap)->commit_mutex);\n\n\t \n\tAG_UNLOCK(imap, agno);\n\n\treturn (0);\n\n      error_out:\n\tIREAD_UNLOCK(ipimap);\n\n\tif (amp)\n\t\trelease_metapage(amp);\n\tif (bmp)\n\t\trelease_metapage(bmp);\n\tif (cmp)\n\t\trelease_metapage(cmp);\n\tif (dmp)\n\t\trelease_metapage(dmp);\n\n\tAG_UNLOCK(imap, agno);\n\n\trelease_metapage(mp);\n\n\treturn (rc);\n}\n\n \nstatic inline void\ndiInitInode(struct inode *ip, int iagno, int ino, int extno, struct iag * iagp)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\n\tip->i_ino = (iagno << L2INOSPERIAG) + ino;\n\tjfs_ip->ixpxd = iagp->inoext[extno];\n\tjfs_ip->agstart = le64_to_cpu(iagp->agstart);\n\tjfs_ip->active_ag = -1;\n}\n\n\n \nint diAlloc(struct inode *pip, bool dir, struct inode *ip)\n{\n\tint rc, ino, iagno, addext, extno, bitno, sword;\n\tint nwords, rem, i, agno, dn_numag;\n\tu32 mask, inosmap, extsmap;\n\tstruct inode *ipimap;\n\tstruct metapage *mp;\n\tino_t inum;\n\tstruct iag *iagp;\n\tstruct inomap *imap;\n\n\t \n\tipimap = JFS_SBI(pip->i_sb)->ipimap;\n\timap = JFS_IP(ipimap)->i_imap;\n\tJFS_IP(ip)->ipimap = ipimap;\n\tJFS_IP(ip)->fileset = FILESYSTEM_I;\n\n\t \n\tif (dir) {\n\t\tagno = dbNextAG(JFS_SBI(pip->i_sb)->ipbmap);\n\t\tAG_LOCK(imap, agno);\n\t\tgoto tryag;\n\t}\n\n\t \n\n\t \n\tagno = BLKTOAG(JFS_IP(pip)->agstart, JFS_SBI(pip->i_sb));\n\tdn_numag = JFS_SBI(pip->i_sb)->bmap->db_numag;\n\tif (agno < 0 || agno > dn_numag)\n\t\treturn -EIO;\n\n\tif (atomic_read(&JFS_SBI(pip->i_sb)->bmap->db_active[agno])) {\n\t\t \n\t\tagno = dbNextAG(JFS_SBI(pip->i_sb)->ipbmap);\n\t\tAG_LOCK(imap, agno);\n\t\tgoto tryag;\n\t}\n\n\tinum = pip->i_ino + 1;\n\tino = inum & (INOSPERIAG - 1);\n\n\t \n\tif (ino == 0)\n\t\tinum = pip->i_ino;\n\n\t \n\tAG_LOCK(imap, agno);\n\n\t \n\tIREAD_LOCK(ipimap, RDWRLOCK_IMAP);\n\n\t \n\tiagno = INOTOIAG(inum);\n\tif ((rc = diIAGRead(imap, iagno, &mp))) {\n\t\tIREAD_UNLOCK(ipimap);\n\t\tAG_UNLOCK(imap, agno);\n\t\treturn (rc);\n\t}\n\tiagp = (struct iag *) mp->data;\n\n\t \n\taddext = (imap->im_agctl[agno].numfree < 32 && iagp->nfreeexts);\n\n\t \n\t \n\tif (iagp->nfreeinos || addext) {\n\t\t \n\t\textno = ino >> L2INOSPEREXT;\n\n\t\t \n\t\tif (addressPXD(&iagp->inoext[extno])) {\n\t\t\tbitno = ino & (INOSPEREXT - 1);\n\t\t\tif ((bitno =\n\t\t\t     diFindFree(le32_to_cpu(iagp->wmap[extno]),\n\t\t\t\t\tbitno))\n\t\t\t    < INOSPEREXT) {\n\t\t\t\tino = (extno << L2INOSPEREXT) + bitno;\n\n\t\t\t\t \n\t\t\t\trc = diAllocBit(imap, iagp, ino);\n\t\t\t\tIREAD_UNLOCK(ipimap);\n\t\t\t\tif (rc) {\n\t\t\t\t\tassert(rc == -EIO);\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tdiInitInode(ip, iagno, ino, extno,\n\t\t\t\t\t\t    iagp);\n\t\t\t\t\tmark_metapage_dirty(mp);\n\t\t\t\t}\n\t\t\t\trelease_metapage(mp);\n\n\t\t\t\t \n\t\t\t\tAG_UNLOCK(imap, agno);\n\t\t\t\treturn (rc);\n\t\t\t}\n\n\t\t\tif (!addext)\n\t\t\t\textno =\n\t\t\t\t    (extno ==\n\t\t\t\t     EXTSPERIAG - 1) ? 0 : extno + 1;\n\t\t}\n\n\t\t \n\t\tbitno = extno & (EXTSPERSUM - 1);\n\t\tnwords = (bitno == 0) ? SMAPSZ : SMAPSZ + 1;\n\t\tsword = extno >> L2EXTSPERSUM;\n\n\t\t \n\t\tmask = (bitno == 0) ? 0 : (ONES << (EXTSPERSUM - bitno));\n\t\tinosmap = le32_to_cpu(iagp->inosmap[sword]) | mask;\n\t\textsmap = le32_to_cpu(iagp->extsmap[sword]) | mask;\n\n\t\t \n\t\tfor (i = 0; i < nwords; i++) {\n\t\t\t \n\t\t\tif (~inosmap) {\n\t\t\t\t \n\t\t\t\trem = diFindFree(inosmap, 0);\n\t\t\t\textno = (sword << L2EXTSPERSUM) + rem;\n\t\t\t\trem = diFindFree(le32_to_cpu(iagp->wmap[extno]),\n\t\t\t\t\t\t 0);\n\t\t\t\tif (rem >= INOSPEREXT) {\n\t\t\t\t\tIREAD_UNLOCK(ipimap);\n\t\t\t\t\trelease_metapage(mp);\n\t\t\t\t\tAG_UNLOCK(imap, agno);\n\t\t\t\t\tjfs_error(ip->i_sb,\n\t\t\t\t\t\t  \"can't find free bit in wmap\\n\");\n\t\t\t\t\treturn -EIO;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tino = (extno << L2INOSPEREXT) + rem;\n\t\t\t\trc = diAllocBit(imap, iagp, ino);\n\t\t\t\tIREAD_UNLOCK(ipimap);\n\t\t\t\tif (rc)\n\t\t\t\t\tassert(rc == -EIO);\n\t\t\t\telse {\n\t\t\t\t\t \n\t\t\t\t\tdiInitInode(ip, iagno, ino, extno,\n\t\t\t\t\t\t    iagp);\n\t\t\t\t\tmark_metapage_dirty(mp);\n\t\t\t\t}\n\t\t\t\trelease_metapage(mp);\n\n\t\t\t\t \n\t\t\t\tAG_UNLOCK(imap, agno);\n\t\t\t\treturn (rc);\n\n\t\t\t}\n\n\t\t\t \n\t\t\tif (addext && ~extsmap) {\n\t\t\t\t \n\t\t\t\trem = diFindFree(extsmap, 0);\n\t\t\t\textno = (sword << L2EXTSPERSUM) + rem;\n\n\t\t\t\t \n\t\t\t\tif ((rc = diNewExt(imap, iagp, extno))) {\n\t\t\t\t\t \n\t\t\t\t\tif (rc == -ENOSPC)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tassert(rc == -EIO);\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tdiInitInode(ip, iagno,\n\t\t\t\t\t\t    extno << L2INOSPEREXT,\n\t\t\t\t\t\t    extno, iagp);\n\t\t\t\t\tmark_metapage_dirty(mp);\n\t\t\t\t}\n\t\t\t\trelease_metapage(mp);\n\t\t\t\t \n\t\t\t\tIREAD_UNLOCK(ipimap);\n\t\t\t\tAG_UNLOCK(imap, agno);\n\t\t\t\treturn (rc);\n\t\t\t}\n\n\t\t\t \n\t\t\tsword = (sword == SMAPSZ - 1) ? 0 : sword + 1;\n\t\t\tinosmap = le32_to_cpu(iagp->inosmap[sword]);\n\t\t\textsmap = le32_to_cpu(iagp->extsmap[sword]);\n\t\t}\n\t}\n\t \n\tIREAD_UNLOCK(ipimap);\n\n\t \n\trelease_metapage(mp);\n\n      tryag:\n\t \n\trc = diAllocAG(imap, agno, dir, ip);\n\n\tAG_UNLOCK(imap, agno);\n\n\tif (rc != -ENOSPC)\n\t\treturn (rc);\n\n\t \n\treturn (diAllocAny(imap, agno, dir, ip));\n}\n\n\n \nstatic int\ndiAllocAG(struct inomap * imap, int agno, bool dir, struct inode *ip)\n{\n\tint rc, addext, numfree, numinos;\n\n\t \n\tnumfree = imap->im_agctl[agno].numfree;\n\tnuminos = imap->im_agctl[agno].numinos;\n\n\tif (numfree > numinos) {\n\t\tjfs_error(ip->i_sb, \"numfree > numinos\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tif (dir)\n\t\taddext = (numfree < 64 ||\n\t\t\t  (numfree < 256\n\t\t\t   && ((numfree * 100) / numinos) <= 20));\n\telse\n\t\taddext = (numfree == 0);\n\n\t \n\tif (addext) {\n\t\t \n\t\tif ((rc = diAllocExt(imap, agno, ip)) != -ENOSPC)\n\t\t\treturn (rc);\n\t}\n\n\t \n\treturn (diAllocIno(imap, agno, ip));\n}\n\n\n \nstatic int\ndiAllocAny(struct inomap * imap, int agno, bool dir, struct inode *ip)\n{\n\tint ag, rc;\n\tint maxag = JFS_SBI(imap->im_ipimap->i_sb)->bmap->db_maxag;\n\n\n\t \n\tfor (ag = agno + 1; ag <= maxag; ag++) {\n\t\tAG_LOCK(imap, ag);\n\n\t\trc = diAllocAG(imap, ag, dir, ip);\n\n\t\tAG_UNLOCK(imap, ag);\n\n\t\tif (rc != -ENOSPC)\n\t\t\treturn (rc);\n\t}\n\n\t \n\tfor (ag = 0; ag < agno; ag++) {\n\t\tAG_LOCK(imap, ag);\n\n\t\trc = diAllocAG(imap, ag, dir, ip);\n\n\t\tAG_UNLOCK(imap, ag);\n\n\t\tif (rc != -ENOSPC)\n\t\t\treturn (rc);\n\t}\n\n\t \n\treturn -ENOSPC;\n}\n\n\n \nstatic int diAllocIno(struct inomap * imap, int agno, struct inode *ip)\n{\n\tint iagno, ino, rc, rem, extno, sword;\n\tstruct metapage *mp;\n\tstruct iag *iagp;\n\n\t \n\tif ((iagno = imap->im_agctl[agno].inofree) < 0)\n\t\treturn -ENOSPC;\n\n\t \n\tIREAD_LOCK(imap->im_ipimap, RDWRLOCK_IMAP);\n\n\t \n\tif ((rc = diIAGRead(imap, iagno, &mp))) {\n\t\tIREAD_UNLOCK(imap->im_ipimap);\n\t\treturn (rc);\n\t}\n\tiagp = (struct iag *) mp->data;\n\n\t \n\tif (!iagp->nfreeinos) {\n\t\tIREAD_UNLOCK(imap->im_ipimap);\n\t\trelease_metapage(mp);\n\t\tjfs_error(ip->i_sb, \"nfreeinos = 0, but iag on freelist\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tfor (sword = 0;; sword++) {\n\t\tif (sword >= SMAPSZ) {\n\t\t\tIREAD_UNLOCK(imap->im_ipimap);\n\t\t\trelease_metapage(mp);\n\t\t\tjfs_error(ip->i_sb,\n\t\t\t\t  \"free inode not found in summary map\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (~iagp->inosmap[sword])\n\t\t\tbreak;\n\t}\n\n\t \n\trem = diFindFree(le32_to_cpu(iagp->inosmap[sword]), 0);\n\tif (rem >= EXTSPERSUM) {\n\t\tIREAD_UNLOCK(imap->im_ipimap);\n\t\trelease_metapage(mp);\n\t\tjfs_error(ip->i_sb, \"no free extent found\\n\");\n\t\treturn -EIO;\n\t}\n\textno = (sword << L2EXTSPERSUM) + rem;\n\n\t \n\trem = diFindFree(le32_to_cpu(iagp->wmap[extno]), 0);\n\tif (rem >= INOSPEREXT) {\n\t\tIREAD_UNLOCK(imap->im_ipimap);\n\t\trelease_metapage(mp);\n\t\tjfs_error(ip->i_sb, \"free inode not found\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tino = (extno << L2INOSPEREXT) + rem;\n\n\t \n\trc = diAllocBit(imap, iagp, ino);\n\tIREAD_UNLOCK(imap->im_ipimap);\n\tif (rc) {\n\t\trelease_metapage(mp);\n\t\treturn (rc);\n\t}\n\n\t \n\tdiInitInode(ip, iagno, ino, extno, iagp);\n\twrite_metapage(mp);\n\n\treturn (0);\n}\n\n\n \nstatic int diAllocExt(struct inomap * imap, int agno, struct inode *ip)\n{\n\tint rem, iagno, sword, extno, rc;\n\tstruct metapage *mp;\n\tstruct iag *iagp;\n\n\t \n\tif ((iagno = imap->im_agctl[agno].extfree) < 0) {\n\t\t \n\t\tif ((rc = diNewIAG(imap, &iagno, agno, &mp))) {\n\t\t\treturn (rc);\n\t\t}\n\t\tiagp = (struct iag *) mp->data;\n\n\t\t \n\t\tiagp->agstart =\n\t\t    cpu_to_le64(AGTOBLK(agno, imap->im_ipimap));\n\t} else {\n\t\t \n\t\tIREAD_LOCK(imap->im_ipimap, RDWRLOCK_IMAP);\n\t\tif ((rc = diIAGRead(imap, iagno, &mp))) {\n\t\t\tIREAD_UNLOCK(imap->im_ipimap);\n\t\t\tjfs_error(ip->i_sb, \"error reading iag\\n\");\n\t\t\treturn rc;\n\t\t}\n\t\tiagp = (struct iag *) mp->data;\n\t}\n\n\t \n\tfor (sword = 0;; sword++) {\n\t\tif (sword >= SMAPSZ) {\n\t\t\trelease_metapage(mp);\n\t\t\tIREAD_UNLOCK(imap->im_ipimap);\n\t\t\tjfs_error(ip->i_sb, \"free ext summary map not found\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (~iagp->extsmap[sword])\n\t\t\tbreak;\n\t}\n\n\t \n\trem = diFindFree(le32_to_cpu(iagp->extsmap[sword]), 0);\n\tif (rem >= EXTSPERSUM) {\n\t\trelease_metapage(mp);\n\t\tIREAD_UNLOCK(imap->im_ipimap);\n\t\tjfs_error(ip->i_sb, \"free extent not found\\n\");\n\t\treturn -EIO;\n\t}\n\textno = (sword << L2EXTSPERSUM) + rem;\n\n\t \n\trc = diNewExt(imap, iagp, extno);\n\tIREAD_UNLOCK(imap->im_ipimap);\n\tif (rc) {\n\t\t \n\t\tif (iagp->nfreeexts == cpu_to_le32(EXTSPERIAG)) {\n\t\t\tIAGFREE_LOCK(imap);\n\t\t\tiagp->iagfree = cpu_to_le32(imap->im_freeiag);\n\t\t\timap->im_freeiag = iagno;\n\t\t\tIAGFREE_UNLOCK(imap);\n\t\t}\n\t\twrite_metapage(mp);\n\t\treturn (rc);\n\t}\n\n\t \n\tdiInitInode(ip, iagno, extno << L2INOSPEREXT, extno, iagp);\n\n\twrite_metapage(mp);\n\n\treturn (0);\n}\n\n\n \nstatic int diAllocBit(struct inomap * imap, struct iag * iagp, int ino)\n{\n\tint extno, bitno, agno, sword, rc;\n\tstruct metapage *amp = NULL, *bmp = NULL;\n\tstruct iag *aiagp = NULL, *biagp = NULL;\n\tu32 mask;\n\n\t \n\tif (iagp->nfreeinos == cpu_to_le32(1)) {\n\t\tif ((int) le32_to_cpu(iagp->inofreefwd) >= 0) {\n\t\t\tif ((rc =\n\t\t\t     diIAGRead(imap, le32_to_cpu(iagp->inofreefwd),\n\t\t\t\t       &amp)))\n\t\t\t\treturn (rc);\n\t\t\taiagp = (struct iag *) amp->data;\n\t\t}\n\n\t\tif ((int) le32_to_cpu(iagp->inofreeback) >= 0) {\n\t\t\tif ((rc =\n\t\t\t     diIAGRead(imap,\n\t\t\t\t       le32_to_cpu(iagp->inofreeback),\n\t\t\t\t       &bmp))) {\n\t\t\t\tif (amp)\n\t\t\t\t\trelease_metapage(amp);\n\t\t\t\treturn (rc);\n\t\t\t}\n\t\t\tbiagp = (struct iag *) bmp->data;\n\t\t}\n\t}\n\n\t \n\tagno = BLKTOAG(le64_to_cpu(iagp->agstart), JFS_SBI(imap->im_ipimap->i_sb));\n\textno = ino >> L2INOSPEREXT;\n\tbitno = ino & (INOSPEREXT - 1);\n\n\t \n\tmask = HIGHORDER >> bitno;\n\n\t \n\tif (((le32_to_cpu(iagp->pmap[extno]) & mask) != 0) ||\n\t    ((le32_to_cpu(iagp->wmap[extno]) & mask) != 0) ||\n\t    (addressPXD(&iagp->inoext[extno]) == 0)) {\n\t\tif (amp)\n\t\t\trelease_metapage(amp);\n\t\tif (bmp)\n\t\t\trelease_metapage(bmp);\n\n\t\tjfs_error(imap->im_ipimap->i_sb, \"iag inconsistent\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tiagp->wmap[extno] |= cpu_to_le32(mask);\n\n\t \n\tif (iagp->wmap[extno] == cpu_to_le32(ONES)) {\n\t\tsword = extno >> L2EXTSPERSUM;\n\t\tbitno = extno & (EXTSPERSUM - 1);\n\t\tiagp->inosmap[sword] |= cpu_to_le32(HIGHORDER >> bitno);\n\t}\n\n\t \n\tif (iagp->nfreeinos == cpu_to_le32(1)) {\n\t\tif (amp) {\n\t\t\taiagp->inofreeback = iagp->inofreeback;\n\t\t\twrite_metapage(amp);\n\t\t}\n\n\t\tif (bmp) {\n\t\t\tbiagp->inofreefwd = iagp->inofreefwd;\n\t\t\twrite_metapage(bmp);\n\t\t} else {\n\t\t\timap->im_agctl[agno].inofree =\n\t\t\t    le32_to_cpu(iagp->inofreefwd);\n\t\t}\n\t\tiagp->inofreefwd = iagp->inofreeback = cpu_to_le32(-1);\n\t}\n\n\t \n\tle32_add_cpu(&iagp->nfreeinos, -1);\n\timap->im_agctl[agno].numfree -= 1;\n\tatomic_dec(&imap->im_numfree);\n\n\treturn (0);\n}\n\n\n \nstatic int diNewExt(struct inomap * imap, struct iag * iagp, int extno)\n{\n\tint agno, iagno, fwd, back, freei = 0, sword, rc;\n\tstruct iag *aiagp = NULL, *biagp = NULL, *ciagp = NULL;\n\tstruct metapage *amp, *bmp, *cmp, *dmp;\n\tstruct inode *ipimap;\n\ts64 blkno, hint;\n\tint i, j;\n\tu32 mask;\n\tino_t ino;\n\tstruct dinode *dp;\n\tstruct jfs_sb_info *sbi;\n\n\t \n\tif (!iagp->nfreeexts) {\n\t\tjfs_error(imap->im_ipimap->i_sb, \"no free extents\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tipimap = imap->im_ipimap;\n\tsbi = JFS_SBI(ipimap->i_sb);\n\n\tamp = bmp = cmp = NULL;\n\n\t \n\tagno = BLKTOAG(le64_to_cpu(iagp->agstart), sbi);\n\tiagno = le32_to_cpu(iagp->iagnum);\n\n\t \n\tif (iagp->nfreeexts == cpu_to_le32(1)) {\n\t\tif ((fwd = le32_to_cpu(iagp->extfreefwd)) >= 0) {\n\t\t\tif ((rc = diIAGRead(imap, fwd, &amp)))\n\t\t\t\treturn (rc);\n\t\t\taiagp = (struct iag *) amp->data;\n\t\t}\n\n\t\tif ((back = le32_to_cpu(iagp->extfreeback)) >= 0) {\n\t\t\tif ((rc = diIAGRead(imap, back, &bmp)))\n\t\t\t\tgoto error_out;\n\t\t\tbiagp = (struct iag *) bmp->data;\n\t\t}\n\t} else {\n\t\t \n\t\tfwd = back = -1;\n\t\tif (iagp->nfreeexts == cpu_to_le32(EXTSPERIAG)) {\n\t\t\tif ((fwd = imap->im_agctl[agno].extfree) >= 0) {\n\t\t\t\tif ((rc = diIAGRead(imap, fwd, &amp)))\n\t\t\t\t\tgoto error_out;\n\t\t\t\taiagp = (struct iag *) amp->data;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (iagp->nfreeinos == 0) {\n\t\tfreei = imap->im_agctl[agno].inofree;\n\n\t\tif (freei >= 0) {\n\t\t\tif (freei == fwd) {\n\t\t\t\tciagp = aiagp;\n\t\t\t} else if (freei == back) {\n\t\t\t\tciagp = biagp;\n\t\t\t} else {\n\t\t\t\tif ((rc = diIAGRead(imap, freei, &cmp)))\n\t\t\t\t\tgoto error_out;\n\t\t\t\tciagp = (struct iag *) cmp->data;\n\t\t\t}\n\t\t\tif (ciagp == NULL) {\n\t\t\t\tjfs_error(imap->im_ipimap->i_sb,\n\t\t\t\t\t  \"ciagp == NULL\\n\");\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto error_out;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif ((extno == 0) || (addressPXD(&iagp->inoext[extno - 1]) == 0))\n\t\thint = ((s64) agno << sbi->bmap->db_agl2size) - 1;\n\telse\n\t\thint = addressPXD(&iagp->inoext[extno - 1]) +\n\t\t    lengthPXD(&iagp->inoext[extno - 1]) - 1;\n\n\tif ((rc = dbAlloc(ipimap, hint, (s64) imap->im_nbperiext, &blkno)))\n\t\tgoto error_out;\n\n\t \n\tino = (iagno << L2INOSPERIAG) + (extno << L2INOSPEREXT);\n\n\t \n\tfor (i = 0; i < imap->im_nbperiext; i += sbi->nbperpage) {\n\t\t \n\t\tdmp = get_metapage(ipimap, blkno + i, PSIZE, 1);\n\t\tif (dmp == NULL) {\n\t\t\trc = -EIO;\n\t\t\tgoto error_out;\n\t\t}\n\t\tdp = (struct dinode *) dmp->data;\n\n\t\t \n\t\tfor (j = 0; j < INOSPERPAGE; j++, dp++, ino++) {\n\t\t\tdp->di_inostamp = cpu_to_le32(sbi->inostamp);\n\t\t\tdp->di_number = cpu_to_le32(ino);\n\t\t\tdp->di_fileset = cpu_to_le32(FILESYSTEM_I);\n\t\t\tdp->di_mode = 0;\n\t\t\tdp->di_nlink = 0;\n\t\t\tPXDaddress(&(dp->di_ixpxd), blkno);\n\t\t\tPXDlength(&(dp->di_ixpxd), imap->im_nbperiext);\n\t\t}\n\t\twrite_metapage(dmp);\n\t}\n\n\t \n\tif (iagp->nfreeexts == cpu_to_le32(1)) {\n\t\tif (fwd >= 0)\n\t\t\taiagp->extfreeback = iagp->extfreeback;\n\n\t\tif (back >= 0)\n\t\t\tbiagp->extfreefwd = iagp->extfreefwd;\n\t\telse\n\t\t\timap->im_agctl[agno].extfree =\n\t\t\t    le32_to_cpu(iagp->extfreefwd);\n\n\t\tiagp->extfreefwd = iagp->extfreeback = cpu_to_le32(-1);\n\t} else {\n\t\t \n\t\tif (iagp->nfreeexts == cpu_to_le32(EXTSPERIAG)) {\n\t\t\tif (fwd >= 0)\n\t\t\t\taiagp->extfreeback = cpu_to_le32(iagno);\n\n\t\t\tiagp->extfreefwd = cpu_to_le32(fwd);\n\t\t\tiagp->extfreeback = cpu_to_le32(-1);\n\t\t\timap->im_agctl[agno].extfree = iagno;\n\t\t}\n\t}\n\n\t \n\tif (iagp->nfreeinos == 0) {\n\t\tif (freei >= 0)\n\t\t\tciagp->inofreeback = cpu_to_le32(iagno);\n\n\t\tiagp->inofreefwd =\n\t\t    cpu_to_le32(imap->im_agctl[agno].inofree);\n\t\tiagp->inofreeback = cpu_to_le32(-1);\n\t\timap->im_agctl[agno].inofree = iagno;\n\t}\n\n\t \n\tPXDlength(&iagp->inoext[extno], imap->im_nbperiext);\n\tPXDaddress(&iagp->inoext[extno], blkno);\n\n\t \n\tiagp->wmap[extno] = cpu_to_le32(HIGHORDER);\n\tiagp->pmap[extno] = 0;\n\n\t \n\tsword = extno >> L2EXTSPERSUM;\n\tmask = HIGHORDER >> (extno & (EXTSPERSUM - 1));\n\tiagp->extsmap[sword] |= cpu_to_le32(mask);\n\tiagp->inosmap[sword] &= cpu_to_le32(~mask);\n\n\t \n\tle32_add_cpu(&iagp->nfreeinos, (INOSPEREXT - 1));\n\tle32_add_cpu(&iagp->nfreeexts, -1);\n\n\t \n\timap->im_agctl[agno].numfree += (INOSPEREXT - 1);\n\timap->im_agctl[agno].numinos += INOSPEREXT;\n\n\t \n\tatomic_add(INOSPEREXT - 1, &imap->im_numfree);\n\tatomic_add(INOSPEREXT, &imap->im_numinos);\n\n\t \n\tif (amp)\n\t\twrite_metapage(amp);\n\tif (bmp)\n\t\twrite_metapage(bmp);\n\tif (cmp)\n\t\twrite_metapage(cmp);\n\n\treturn (0);\n\n      error_out:\n\n\t \n\tif (amp)\n\t\trelease_metapage(amp);\n\tif (bmp)\n\t\trelease_metapage(bmp);\n\tif (cmp)\n\t\trelease_metapage(cmp);\n\n\treturn (rc);\n}\n\n\n \nstatic int\ndiNewIAG(struct inomap * imap, int *iagnop, int agno, struct metapage ** mpp)\n{\n\tint rc;\n\tint iagno, i, xlen;\n\tstruct inode *ipimap;\n\tstruct super_block *sb;\n\tstruct jfs_sb_info *sbi;\n\tstruct metapage *mp;\n\tstruct iag *iagp;\n\ts64 xaddr = 0;\n\ts64 blkno;\n\ttid_t tid;\n\tstruct inode *iplist[1];\n\n\t \n\tipimap = imap->im_ipimap;\n\tsb = ipimap->i_sb;\n\tsbi = JFS_SBI(sb);\n\n\t \n\tIAGFREE_LOCK(imap);\n\n\t \n\tif (imap->im_freeiag >= 0) {\n\t\t \n\t\tiagno = imap->im_freeiag;\n\n\t\t \n\t\tblkno = IAGTOLBLK(iagno, sbi->l2nbperpage);\n\t} else {\n\t\t \n\n\t\t \n\t\tIWRITE_LOCK(ipimap, RDWRLOCK_IMAP);\n\n\t\tif (ipimap->i_size >> L2PSIZE != imap->im_nextiag + 1) {\n\t\t\tIWRITE_UNLOCK(ipimap);\n\t\t\tIAGFREE_UNLOCK(imap);\n\t\t\tjfs_error(imap->im_ipimap->i_sb,\n\t\t\t\t  \"ipimap->i_size is wrong\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\n\t\t \n\t\tiagno = imap->im_nextiag;\n\n\t\t \n\t\tif (iagno > (MAXIAGS - 1)) {\n\t\t\t \n\t\t\tIWRITE_UNLOCK(ipimap);\n\n\t\t\trc = -ENOSPC;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\t \n\t\tblkno = IAGTOLBLK(iagno, sbi->l2nbperpage);\n\n\t\t \n\t\txlen = sbi->nbperpage;\n\t\tif ((rc = dbAlloc(ipimap, 0, (s64) xlen, &xaddr))) {\n\t\t\t \n\t\t\tIWRITE_UNLOCK(ipimap);\n\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\ttid = txBegin(sb, COMMIT_FORCE);\n\t\tmutex_lock(&JFS_IP(ipimap)->commit_mutex);\n\n\t\t \n\t\tif ((rc =\n\t\t     xtInsert(tid, ipimap, 0, blkno, xlen, &xaddr, 0))) {\n\t\t\ttxEnd(tid);\n\t\t\tmutex_unlock(&JFS_IP(ipimap)->commit_mutex);\n\t\t\t \n\t\t\tdbFree(ipimap, xaddr, (s64) xlen);\n\n\t\t\t \n\t\t\tIWRITE_UNLOCK(ipimap);\n\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tipimap->i_size += PSIZE;\n\t\tinode_add_bytes(ipimap, PSIZE);\n\n\t\t \n\t\tmp = get_metapage(ipimap, blkno, PSIZE, 0);\n\t\tif (!mp) {\n\t\t\t \n\t\t\txtTruncate(tid, ipimap, ipimap->i_size - PSIZE,\n\t\t\t\t   COMMIT_PWMAP);\n\n\t\t\ttxAbort(tid, 0);\n\t\t\ttxEnd(tid);\n\t\t\tmutex_unlock(&JFS_IP(ipimap)->commit_mutex);\n\n\t\t\t \n\t\t\tIWRITE_UNLOCK(ipimap);\n\n\t\t\trc = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tiagp = (struct iag *) mp->data;\n\n\t\t \n\t\tmemset(iagp, 0, sizeof(struct iag));\n\t\tiagp->iagnum = cpu_to_le32(iagno);\n\t\tiagp->inofreefwd = iagp->inofreeback = cpu_to_le32(-1);\n\t\tiagp->extfreefwd = iagp->extfreeback = cpu_to_le32(-1);\n\t\tiagp->iagfree = cpu_to_le32(-1);\n\t\tiagp->nfreeinos = 0;\n\t\tiagp->nfreeexts = cpu_to_le32(EXTSPERIAG);\n\n\t\t \n\t\tfor (i = 0; i < SMAPSZ; i++)\n\t\t\tiagp->inosmap[i] = cpu_to_le32(ONES);\n\n\t\t \n\t\tflush_metapage(mp);\n\n\t\t \n\t\tiplist[0] = ipimap;\n\t\trc = txCommit(tid, 1, &iplist[0], COMMIT_FORCE);\n\n\t\ttxEnd(tid);\n\t\tmutex_unlock(&JFS_IP(ipimap)->commit_mutex);\n\n\t\tduplicateIXtree(sb, blkno, xlen, &xaddr);\n\n\t\t \n\t\timap->im_nextiag += 1;\n\n\t\t \n\t\timap->im_freeiag = iagno;\n\n\t\t \n\t\tdiSync(ipimap);\n\n\t\t \n\t\tIWRITE_UNLOCK(ipimap);\n\t}\n\n\t \n\tIREAD_LOCK(ipimap, RDWRLOCK_IMAP);\n\n\t \n\tif ((rc = diIAGRead(imap, iagno, &mp))) {\n\t\tIREAD_UNLOCK(ipimap);\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\tiagp = (struct iag *) mp->data;\n\n\t \n\timap->im_freeiag = le32_to_cpu(iagp->iagfree);\n\tiagp->iagfree = cpu_to_le32(-1);\n\n\t \n\t*iagnop = iagno;\n\t*mpp = mp;\n\n      out:\n\t \n\tIAGFREE_UNLOCK(imap);\n\n\treturn (rc);\n}\n\n \nstatic int diIAGRead(struct inomap * imap, int iagno, struct metapage ** mpp)\n{\n\tstruct inode *ipimap = imap->im_ipimap;\n\ts64 blkno;\n\n\t \n\tblkno = IAGTOLBLK(iagno, JFS_SBI(ipimap->i_sb)->l2nbperpage);\n\n\t \n\t*mpp = read_metapage(ipimap, blkno, PSIZE, 0);\n\tif (*mpp == NULL) {\n\t\treturn -EIO;\n\t}\n\n\treturn (0);\n}\n\n \nstatic int diFindFree(u32 word, int start)\n{\n\tint bitno;\n\tassert(start < 32);\n\t \n\tfor (word <<= start, bitno = start; bitno < 32;\n\t     bitno++, word <<= 1) {\n\t\tif ((word & HIGHORDER) == 0)\n\t\t\tbreak;\n\t}\n\treturn (bitno);\n}\n\n \nint\ndiUpdatePMap(struct inode *ipimap,\n\t     unsigned long inum, bool is_free, struct tblock * tblk)\n{\n\tint rc;\n\tstruct iag *iagp;\n\tstruct metapage *mp;\n\tint iagno, ino, extno, bitno;\n\tstruct inomap *imap;\n\tu32 mask;\n\tstruct jfs_log *log;\n\tint lsn, difft, diffp;\n\tunsigned long flags;\n\n\timap = JFS_IP(ipimap)->i_imap;\n\t \n\tiagno = INOTOIAG(inum);\n\t \n\tif (iagno >= imap->im_nextiag) {\n\t\tjfs_error(ipimap->i_sb, \"the iag is outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\t \n\tIREAD_LOCK(ipimap, RDWRLOCK_IMAP);\n\trc = diIAGRead(imap, iagno, &mp);\n\tIREAD_UNLOCK(ipimap);\n\tif (rc)\n\t\treturn (rc);\n\tmetapage_wait_for_io(mp);\n\tiagp = (struct iag *) mp->data;\n\t \n\tino = inum & (INOSPERIAG - 1);\n\textno = ino >> L2INOSPEREXT;\n\tbitno = ino & (INOSPEREXT - 1);\n\tmask = HIGHORDER >> bitno;\n\t \n\tif (is_free) {\n\t\t \n\t\tif (!(le32_to_cpu(iagp->wmap[extno]) & mask)) {\n\t\t\tjfs_error(ipimap->i_sb,\n\t\t\t\t  \"inode %ld not marked as allocated in wmap!\\n\",\n\t\t\t\t  inum);\n\t\t}\n\t\tif (!(le32_to_cpu(iagp->pmap[extno]) & mask)) {\n\t\t\tjfs_error(ipimap->i_sb,\n\t\t\t\t  \"inode %ld not marked as allocated in pmap!\\n\",\n\t\t\t\t  inum);\n\t\t}\n\t\t \n\t\tiagp->pmap[extno] &= cpu_to_le32(~mask);\n\t}\n\t \n\telse {\n\t\t \n\t\tif (!(le32_to_cpu(iagp->wmap[extno]) & mask)) {\n\t\t\trelease_metapage(mp);\n\t\t\tjfs_error(ipimap->i_sb,\n\t\t\t\t  \"the inode is not allocated in the working map\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tif ((le32_to_cpu(iagp->pmap[extno]) & mask) != 0) {\n\t\t\trelease_metapage(mp);\n\t\t\tjfs_error(ipimap->i_sb,\n\t\t\t\t  \"the inode is not free in the persistent map\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\t \n\t\tiagp->pmap[extno] |= cpu_to_le32(mask);\n\t}\n\t \n\tlsn = tblk->lsn;\n\tlog = JFS_SBI(tblk->sb)->log;\n\tLOGSYNC_LOCK(log, flags);\n\tif (mp->lsn != 0) {\n\t\t \n\t\tlogdiff(difft, lsn, log);\n\t\tlogdiff(diffp, mp->lsn, log);\n\t\tif (difft < diffp) {\n\t\t\tmp->lsn = lsn;\n\t\t\t \n\t\t\tlist_move(&mp->synclist, &tblk->synclist);\n\t\t}\n\t\t \n\t\tassert(mp->clsn);\n\t\tlogdiff(difft, tblk->clsn, log);\n\t\tlogdiff(diffp, mp->clsn, log);\n\t\tif (difft > diffp)\n\t\t\tmp->clsn = tblk->clsn;\n\t} else {\n\t\tmp->log = log;\n\t\tmp->lsn = lsn;\n\t\t \n\t\tlog->count++;\n\t\tlist_add(&mp->synclist, &tblk->synclist);\n\t\tmp->clsn = tblk->clsn;\n\t}\n\tLOGSYNC_UNLOCK(log, flags);\n\twrite_metapage(mp);\n\treturn (0);\n}\n\n \nint diExtendFS(struct inode *ipimap, struct inode *ipbmap)\n{\n\tint rc, rcx = 0;\n\tstruct inomap *imap = JFS_IP(ipimap)->i_imap;\n\tstruct iag *iagp = NULL, *hiagp = NULL;\n\tstruct bmap *mp = JFS_SBI(ipbmap->i_sb)->bmap;\n\tstruct metapage *bp, *hbp;\n\tint i, n, head;\n\tint numinos, xnuminos = 0, xnumfree = 0;\n\ts64 agstart;\n\n\tjfs_info(\"diExtendFS: nextiag:%d numinos:%d numfree:%d\",\n\t\t   imap->im_nextiag, atomic_read(&imap->im_numinos),\n\t\t   atomic_read(&imap->im_numfree));\n\n\t \n\n\t \n\tfor (i = 0; i < MAXAG; i++) {\n\t\timap->im_agctl[i].inofree = -1;\n\t\timap->im_agctl[i].extfree = -1;\n\t\timap->im_agctl[i].numinos = 0;\t \n\t\timap->im_agctl[i].numfree = 0;\t \n\t}\n\n\t \n\tfor (i = 0; i < imap->im_nextiag; i++) {\n\t\tif ((rc = diIAGRead(imap, i, &bp))) {\n\t\t\trcx = rc;\n\t\t\tcontinue;\n\t\t}\n\t\tiagp = (struct iag *) bp->data;\n\t\tif (le32_to_cpu(iagp->iagnum) != i) {\n\t\t\trelease_metapage(bp);\n\t\t\tjfs_error(ipimap->i_sb, \"unexpected value of iagnum\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t \n\t\tif (iagp->nfreeexts == cpu_to_le32(EXTSPERIAG)) {\n\t\t\trelease_metapage(bp);\n\t\t\tcontinue;\n\t\t}\n\n\t\tagstart = le64_to_cpu(iagp->agstart);\n\t\tn = agstart >> mp->db_agl2size;\n\t\tiagp->agstart = cpu_to_le64((s64)n << mp->db_agl2size);\n\n\t\t \n\t\tnuminos = (EXTSPERIAG - le32_to_cpu(iagp->nfreeexts))\n\t\t    << L2INOSPEREXT;\n\t\tif (numinos > 0) {\n\t\t\t \n\t\t\timap->im_agctl[n].numinos += numinos;\n\t\t\txnuminos += numinos;\n\t\t}\n\n\t\t \n\t\tif ((int) le32_to_cpu(iagp->nfreeinos) > 0) {\n\t\t\tif ((head = imap->im_agctl[n].inofree) == -1) {\n\t\t\t\tiagp->inofreefwd = cpu_to_le32(-1);\n\t\t\t\tiagp->inofreeback = cpu_to_le32(-1);\n\t\t\t} else {\n\t\t\t\tif ((rc = diIAGRead(imap, head, &hbp))) {\n\t\t\t\t\trcx = rc;\n\t\t\t\t\tgoto nextiag;\n\t\t\t\t}\n\t\t\t\thiagp = (struct iag *) hbp->data;\n\t\t\t\thiagp->inofreeback = iagp->iagnum;\n\t\t\t\tiagp->inofreefwd = cpu_to_le32(head);\n\t\t\t\tiagp->inofreeback = cpu_to_le32(-1);\n\t\t\t\twrite_metapage(hbp);\n\t\t\t}\n\n\t\t\timap->im_agctl[n].inofree =\n\t\t\t    le32_to_cpu(iagp->iagnum);\n\n\t\t\t \n\t\t\timap->im_agctl[n].numfree +=\n\t\t\t    le32_to_cpu(iagp->nfreeinos);\n\t\t\txnumfree += le32_to_cpu(iagp->nfreeinos);\n\t\t}\n\n\t\t \n\t\tif (le32_to_cpu(iagp->nfreeexts) > 0) {\n\t\t\tif ((head = imap->im_agctl[n].extfree) == -1) {\n\t\t\t\tiagp->extfreefwd = cpu_to_le32(-1);\n\t\t\t\tiagp->extfreeback = cpu_to_le32(-1);\n\t\t\t} else {\n\t\t\t\tif ((rc = diIAGRead(imap, head, &hbp))) {\n\t\t\t\t\trcx = rc;\n\t\t\t\t\tgoto nextiag;\n\t\t\t\t}\n\t\t\t\thiagp = (struct iag *) hbp->data;\n\t\t\t\thiagp->extfreeback = iagp->iagnum;\n\t\t\t\tiagp->extfreefwd = cpu_to_le32(head);\n\t\t\t\tiagp->extfreeback = cpu_to_le32(-1);\n\t\t\t\twrite_metapage(hbp);\n\t\t\t}\n\n\t\t\timap->im_agctl[n].extfree =\n\t\t\t    le32_to_cpu(iagp->iagnum);\n\t\t}\n\n\t      nextiag:\n\t\twrite_metapage(bp);\n\t}\n\n\tif (xnuminos != atomic_read(&imap->im_numinos) ||\n\t    xnumfree != atomic_read(&imap->im_numfree)) {\n\t\tjfs_error(ipimap->i_sb, \"numinos or numfree incorrect\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn rcx;\n}\n\n\n \nstatic void duplicateIXtree(struct super_block *sb, s64 blkno,\n\t\t\t    int xlen, s64 *xaddr)\n{\n\tstruct jfs_superblock *j_sb;\n\tstruct buffer_head *bh;\n\tstruct inode *ip;\n\ttid_t tid;\n\n\t \n\tif (JFS_SBI(sb)->mntflag & JFS_BAD_SAIT)\t \n\t\treturn;\n\tip = diReadSpecial(sb, FILESYSTEM_I, 1);\n\tif (ip == NULL) {\n\t\tJFS_SBI(sb)->mntflag |= JFS_BAD_SAIT;\n\t\tif (readSuper(sb, &bh))\n\t\t\treturn;\n\t\tj_sb = (struct jfs_superblock *)bh->b_data;\n\t\tj_sb->s_flag |= cpu_to_le32(JFS_BAD_SAIT);\n\n\t\tmark_buffer_dirty(bh);\n\t\tsync_dirty_buffer(bh);\n\t\tbrelse(bh);\n\t\treturn;\n\t}\n\n\t \n\ttid = txBegin(sb, COMMIT_FORCE);\n\t \n\tif (xtInsert(tid, ip, 0, blkno, xlen, xaddr, 0)) {\n\t\tJFS_SBI(sb)->mntflag |= JFS_BAD_SAIT;\n\t\ttxAbort(tid, 1);\n\t\tgoto cleanup;\n\n\t}\n\t \n\tip->i_size += PSIZE;\n\tinode_add_bytes(ip, PSIZE);\n\ttxCommit(tid, 1, &ip, COMMIT_FORCE);\n      cleanup:\n\ttxEnd(tid);\n\tdiFreeSpecial(ip);\n}\n\n \nstatic int copy_from_dinode(struct dinode * dip, struct inode *ip)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\n\n\tjfs_ip->fileset = le32_to_cpu(dip->di_fileset);\n\tjfs_ip->mode2 = le32_to_cpu(dip->di_mode);\n\tjfs_set_inode_flags(ip);\n\n\tip->i_mode = le32_to_cpu(dip->di_mode) & 0xffff;\n\tif (sbi->umask != -1) {\n\t\tip->i_mode = (ip->i_mode & ~0777) | (0777 & ~sbi->umask);\n\t\t \n\t\tif (S_ISDIR(ip->i_mode)) {\n\t\t\tif (ip->i_mode & 0400)\n\t\t\t\tip->i_mode |= 0100;\n\t\t\tif (ip->i_mode & 0040)\n\t\t\t\tip->i_mode |= 0010;\n\t\t\tif (ip->i_mode & 0004)\n\t\t\t\tip->i_mode |= 0001;\n\t\t}\n\t}\n\tset_nlink(ip, le32_to_cpu(dip->di_nlink));\n\n\tjfs_ip->saved_uid = make_kuid(&init_user_ns, le32_to_cpu(dip->di_uid));\n\tif (!uid_valid(sbi->uid))\n\t\tip->i_uid = jfs_ip->saved_uid;\n\telse {\n\t\tip->i_uid = sbi->uid;\n\t}\n\n\tjfs_ip->saved_gid = make_kgid(&init_user_ns, le32_to_cpu(dip->di_gid));\n\tif (!gid_valid(sbi->gid))\n\t\tip->i_gid = jfs_ip->saved_gid;\n\telse {\n\t\tip->i_gid = sbi->gid;\n\t}\n\n\tip->i_size = le64_to_cpu(dip->di_size);\n\tip->i_atime.tv_sec = le32_to_cpu(dip->di_atime.tv_sec);\n\tip->i_atime.tv_nsec = le32_to_cpu(dip->di_atime.tv_nsec);\n\tip->i_mtime.tv_sec = le32_to_cpu(dip->di_mtime.tv_sec);\n\tip->i_mtime.tv_nsec = le32_to_cpu(dip->di_mtime.tv_nsec);\n\tinode_set_ctime(ip, le32_to_cpu(dip->di_ctime.tv_sec),\n\t\t\tle32_to_cpu(dip->di_ctime.tv_nsec));\n\tip->i_blocks = LBLK2PBLK(ip->i_sb, le64_to_cpu(dip->di_nblocks));\n\tip->i_generation = le32_to_cpu(dip->di_gen);\n\n\tjfs_ip->ixpxd = dip->di_ixpxd;\t \n\tjfs_ip->acl = dip->di_acl;\t \n\tjfs_ip->ea = dip->di_ea;\n\tjfs_ip->next_index = le32_to_cpu(dip->di_next_index);\n\tjfs_ip->otime = le32_to_cpu(dip->di_otime.tv_sec);\n\tjfs_ip->acltype = le32_to_cpu(dip->di_acltype);\n\n\tif (S_ISCHR(ip->i_mode) || S_ISBLK(ip->i_mode)) {\n\t\tjfs_ip->dev = le32_to_cpu(dip->di_rdev);\n\t\tip->i_rdev = new_decode_dev(jfs_ip->dev);\n\t}\n\n\tif (S_ISDIR(ip->i_mode)) {\n\t\tmemcpy(&jfs_ip->u.dir, &dip->u._dir, 384);\n\t} else if (S_ISREG(ip->i_mode) || S_ISLNK(ip->i_mode)) {\n\t\tmemcpy(&jfs_ip->i_xtroot, &dip->di_xtroot, 288);\n\t} else\n\t\tmemcpy(&jfs_ip->i_inline_ea, &dip->di_inlineea, 128);\n\n\t \n\tjfs_ip->cflag = 0;\n\tjfs_ip->btindex = 0;\n\tjfs_ip->btorder = 0;\n\tjfs_ip->bxflag = 0;\n\tjfs_ip->blid = 0;\n\tjfs_ip->atlhead = 0;\n\tjfs_ip->atltail = 0;\n\tjfs_ip->xtlid = 0;\n\treturn (0);\n}\n\n \nstatic void copy_to_dinode(struct dinode * dip, struct inode *ip)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\n\n\tdip->di_fileset = cpu_to_le32(jfs_ip->fileset);\n\tdip->di_inostamp = cpu_to_le32(sbi->inostamp);\n\tdip->di_number = cpu_to_le32(ip->i_ino);\n\tdip->di_gen = cpu_to_le32(ip->i_generation);\n\tdip->di_size = cpu_to_le64(ip->i_size);\n\tdip->di_nblocks = cpu_to_le64(PBLK2LBLK(ip->i_sb, ip->i_blocks));\n\tdip->di_nlink = cpu_to_le32(ip->i_nlink);\n\tif (!uid_valid(sbi->uid))\n\t\tdip->di_uid = cpu_to_le32(i_uid_read(ip));\n\telse\n\t\tdip->di_uid =cpu_to_le32(from_kuid(&init_user_ns,\n\t\t\t\t\t\t   jfs_ip->saved_uid));\n\tif (!gid_valid(sbi->gid))\n\t\tdip->di_gid = cpu_to_le32(i_gid_read(ip));\n\telse\n\t\tdip->di_gid = cpu_to_le32(from_kgid(&init_user_ns,\n\t\t\t\t\t\t    jfs_ip->saved_gid));\n\t \n\tif (sbi->umask == -1)\n\t\tdip->di_mode = cpu_to_le32((jfs_ip->mode2 & 0xffff0000) |\n\t\t\t\t\t   ip->i_mode);\n\telse  \n\t\tdip->di_mode = cpu_to_le32(jfs_ip->mode2);\n\n\tdip->di_atime.tv_sec = cpu_to_le32(ip->i_atime.tv_sec);\n\tdip->di_atime.tv_nsec = cpu_to_le32(ip->i_atime.tv_nsec);\n\tdip->di_ctime.tv_sec = cpu_to_le32(inode_get_ctime(ip).tv_sec);\n\tdip->di_ctime.tv_nsec = cpu_to_le32(inode_get_ctime(ip).tv_nsec);\n\tdip->di_mtime.tv_sec = cpu_to_le32(ip->i_mtime.tv_sec);\n\tdip->di_mtime.tv_nsec = cpu_to_le32(ip->i_mtime.tv_nsec);\n\tdip->di_ixpxd = jfs_ip->ixpxd;\t \n\tdip->di_acl = jfs_ip->acl;\t \n\tdip->di_ea = jfs_ip->ea;\n\tdip->di_next_index = cpu_to_le32(jfs_ip->next_index);\n\tdip->di_otime.tv_sec = cpu_to_le32(jfs_ip->otime);\n\tdip->di_otime.tv_nsec = 0;\n\tdip->di_acltype = cpu_to_le32(jfs_ip->acltype);\n\tif (S_ISCHR(ip->i_mode) || S_ISBLK(ip->i_mode))\n\t\tdip->di_rdev = cpu_to_le32(jfs_ip->dev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}