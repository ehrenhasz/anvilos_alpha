{
  "module_name": "jfs_extent.c",
  "hash_id": "aad3da8040c9637ae1cf9d68a88f30dde92173341e9980df8dc1fb93ad3b3a84",
  "original_prompt": "Ingested from linux-6.6.14/fs/jfs/jfs_extent.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/quotaops.h>\n#include \"jfs_incore.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_debug.h\"\n\n \nstatic int extBalloc(struct inode *, s64, s64 *, s64 *);\nstatic s64 extRoundDown(s64 nb);\n\n#define DPD(a)\t\t(printk(\"(a): %d\\n\",(a)))\n#define DPC(a)\t\t(printk(\"(a): %c\\n\",(a)))\n#define DPL1(a)\t\t\t\t\t\\\n{\t\t\t\t\t\t\\\n\tif ((a) >> 32)\t\t\t\t\\\n\t\tprintk(\"(a): %x%08x  \",(a));\t\\\n\telse\t\t\t\t\t\\\n\t\tprintk(\"(a): %x  \",(a) << 32);\t\\\n}\n#define DPL(a)\t\t\t\t\t\\\n{\t\t\t\t\t\t\\\n\tif ((a) >> 32)\t\t\t\t\\\n\t\tprintk(\"(a): %x%08x\\n\",(a));\t\\\n\telse\t\t\t\t\t\\\n\t\tprintk(\"(a): %x\\n\",(a) << 32);\t\\\n}\n\n#define DPD1(a)\t\t(printk(\"(a): %d  \",(a)))\n#define DPX(a)\t\t(printk(\"(a): %08x\\n\",(a)))\n#define DPX1(a)\t\t(printk(\"(a): %08x  \",(a)))\n#define DPS(a)\t\t(printk(\"%s\\n\",(a)))\n#define DPE(a)\t\t(printk(\"\\nENTERING: %s\\n\",(a)))\n#define DPE1(a)\t\t(printk(\"\\nENTERING: %s\",(a)))\n#define DPS1(a)\t\t(printk(\"  %s  \",(a)))\n\n\n \nint\nextAlloc(struct inode *ip, s64 xlen, s64 pno, xad_t * xp, bool abnr)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\n\ts64 nxlen, nxaddr, xoff, hint, xaddr = 0;\n\tint rc;\n\tint xflag;\n\n\t \n\ttxBeginAnon(ip->i_sb);\n\n\t \n\tmutex_lock(&JFS_IP(ip)->commit_mutex);\n\n\t \n\tif (xlen > MAXXLEN)\n\t\txlen = MAXXLEN;\n\n\t \n\txoff = pno << sbi->l2nbperpage;\n\n\t \n\tif ((hint = addressXAD(xp))) {\n\t\t \n\t\tnxlen = lengthXAD(xp);\n\n\t\t \n\t\tif (offsetXAD(xp) + nxlen == xoff &&\n\t\t    abnr == ((xp->flag & XAD_NOTRECORDED) ? true : false))\n\t\t\txaddr = hint + nxlen;\n\n\t\t \n\t\thint += (nxlen - 1);\n\t}\n\n\t \n\tnxlen = xlen;\n\tif ((rc = extBalloc(ip, hint ? hint : INOHINT(ip), &nxlen, &nxaddr))) {\n\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t\treturn (rc);\n\t}\n\n\t \n\trc = dquot_alloc_block(ip, nxlen);\n\tif (rc) {\n\t\tdbFree(ip, nxaddr, (s64) nxlen);\n\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t\treturn rc;\n\t}\n\n\t \n\txflag = abnr ? XAD_NOTRECORDED : 0;\n\n\t \n\tif (xaddr && xaddr == nxaddr)\n\t\trc = xtExtend(0, ip, xoff, (int) nxlen, 0);\n\telse\n\t\trc = xtInsert(0, ip, xflag, xoff, (int) nxlen, &nxaddr, 0);\n\n\t \n\tif (rc) {\n\t\tdbFree(ip, nxaddr, nxlen);\n\t\tdquot_free_block(ip, nxlen);\n\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t\treturn (rc);\n\t}\n\n\t \n\tXADaddress(xp, nxaddr);\n\tXADlength(xp, nxlen);\n\tXADoffset(xp, xoff);\n\txp->flag = xflag;\n\n\tmark_inode_dirty(ip);\n\n\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t \n\tif (test_and_clear_cflag(COMMIT_Synclist,ip))\n\t\tjfs_commit_inode(ip, 0);\n\n\treturn (0);\n}\n\n \nint extHint(struct inode *ip, s64 offset, xad_t * xp)\n{\n\tstruct super_block *sb = ip->i_sb;\n\tint nbperpage = JFS_SBI(sb)->nbperpage;\n\ts64 prev;\n\tint rc = 0;\n\ts64 xaddr;\n\tint xlen;\n\tint xflag;\n\n\t \n\tXADaddress(xp, 0);\n\n\t \n\tprev = ((offset & ~POFFSET) >> JFS_SBI(sb)->l2bsize) - nbperpage;\n\n\t \n\tif (prev < 0)\n\t\tgoto out;\n\n\trc = xtLookup(ip, prev, nbperpage, &xflag, &xaddr, &xlen, 0);\n\n\tif ((rc == 0) && xlen) {\n\t\tif (xlen != nbperpage) {\n\t\t\tjfs_error(ip->i_sb, \"corrupt xtree\\n\");\n\t\t\trc = -EIO;\n\t\t}\n\t\tXADaddress(xp, xaddr);\n\t\tXADlength(xp, xlen);\n\t\tXADoffset(xp, prev);\n\t\t \n\t\txp->flag  = xflag & XAD_NOTRECORDED;\n\t} else\n\t\trc = 0;\n\nout:\n\treturn (rc);\n}\n\n\n \nint extRecord(struct inode *ip, xad_t * xp)\n{\n\tint rc;\n\n\ttxBeginAnon(ip->i_sb);\n\n\tmutex_lock(&JFS_IP(ip)->commit_mutex);\n\n\t \n\trc = xtUpdate(0, ip, xp);\n\n\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\treturn rc;\n}\n\n \nstatic int\nextBalloc(struct inode *ip, s64 hint, s64 * nblocks, s64 * blkno)\n{\n\tstruct jfs_inode_info *ji = JFS_IP(ip);\n\tstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\n\ts64 nb, nblks, daddr, max;\n\tint rc, nbperpage = sbi->nbperpage;\n\tstruct bmap *bmp = sbi->bmap;\n\tint ag;\n\n\t \n\n\t \n\tif (bmp->db_maxfreebud == -1)\n\t\treturn -ENOSPC;\n\n\tmax = (s64) 1 << bmp->db_maxfreebud;\n\tif (*nblocks >= max && *nblocks > nbperpage)\n\t\tnb = nblks = (max > nbperpage) ? max : nbperpage;\n\telse\n\t\tnb = nblks = *nblocks;\n\n\t \n\twhile ((rc = dbAlloc(ip, hint, nb, &daddr)) != 0) {\n\t\t \n\t\tif (rc != -ENOSPC)\n\t\t\treturn (rc);\n\n\t\t \n\t\tnb = min(nblks, extRoundDown(nb));\n\n\t\t \n\t\tif (nb < nbperpage)\n\t\t\treturn (rc);\n\t}\n\n\t*nblocks = nb;\n\t*blkno = daddr;\n\n\tif (S_ISREG(ip->i_mode) && (ji->fileset == FILESYSTEM_I)) {\n\t\tag = BLKTOAG(daddr, sbi);\n\t\tspin_lock_irq(&ji->ag_lock);\n\t\tif (ji->active_ag == -1) {\n\t\t\tatomic_inc(&bmp->db_active[ag]);\n\t\t\tji->active_ag = ag;\n\t\t} else if (ji->active_ag != ag) {\n\t\t\tatomic_dec(&bmp->db_active[ji->active_ag]);\n\t\t\tatomic_inc(&bmp->db_active[ag]);\n\t\t\tji->active_ag = ag;\n\t\t}\n\t\tspin_unlock_irq(&ji->ag_lock);\n\t}\n\n\treturn (0);\n}\n\n \nstatic s64 extRoundDown(s64 nb)\n{\n\tint i;\n\tu64 m, k;\n\n\tfor (i = 0, m = (u64) 1 << 63; i < 64; i++, m >>= 1) {\n\t\tif (m & nb)\n\t\t\tbreak;\n\t}\n\n\ti = 63 - i;\n\tk = (u64) 1 << i;\n\tk = ((k - 1) & nb) ? k : k >> 1;\n\n\treturn (k);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}