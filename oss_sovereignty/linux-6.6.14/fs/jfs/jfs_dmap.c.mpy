{
  "module_name": "jfs_dmap.c",
  "hash_id": "6597edf3c02a7bc8058638ca1c6900d2546edaa027a17f8de65cbc6f20b401c6",
  "original_prompt": "Ingested from linux-6.6.14/fs/jfs/jfs_dmap.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include \"jfs_incore.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_discard.h\"\n\n \n\n#define BMAP_LOCK_INIT(bmp)\tmutex_init(&bmp->db_bmaplock)\n#define BMAP_LOCK(bmp)\t\tmutex_lock(&bmp->db_bmaplock)\n#define BMAP_UNLOCK(bmp)\tmutex_unlock(&bmp->db_bmaplock)\n\n \nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic void dbSplit(dmtree_t * tp, int leafno, int splitsz, int newval);\nstatic int dbBackSplit(dmtree_t * tp, int leafno);\nstatic int dbJoin(dmtree_t * tp, int leafno, int newval);\nstatic void dbAdjTree(dmtree_t * tp, int leafno, int newval);\nstatic int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);\nstatic int dbAllocAny(struct bmap * bmp, s64 nblocks, int l2nb, s64 * results);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocNear(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks,\n\t\t       int l2nb, s64 * results);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmapLev(struct bmap * bmp, struct dmap * dp, int nblocks,\n\t\t\t  int l2nb,\n\t\t\t  s64 * results);\nstatic int dbAllocAG(struct bmap * bmp, int agno, s64 nblocks, int l2nb,\n\t\t     s64 * results);\nstatic int dbAllocCtl(struct bmap * bmp, s64 nblocks, int l2nb, s64 blkno,\n\t\t      s64 * results);\nstatic int dbExtend(struct inode *ip, s64 blkno, s64 nblocks, s64 addnblocks);\nstatic int dbFindBits(u32 word, int l2nb);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFindLeaf(dmtree_t *tp, int l2nb, int *leafidx, bool is_ctl);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbMaxBud(u8 * cp);\nstatic int blkstol2(s64 nb);\n\nstatic int cntlz(u32 value);\nstatic int cnttz(u32 word);\n\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbInitTree(struct dmaptree * dtp);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\nstatic int dbGetL2AGSize(s64 nblocks);\n\n \nstatic const s8 budtab[256] = {\n\t3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, -1\n};\n\n \nint dbMount(struct inode *ipbmap)\n{\n\tstruct bmap *bmp;\n\tstruct dbmap_disk *dbmp_le;\n\tstruct metapage *mp;\n\tint i, err;\n\n\t \n\t \n\tbmp = kmalloc(sizeof(struct bmap), GFP_KERNEL);\n\tif (bmp == NULL)\n\t\treturn -ENOMEM;\n\n\t \n\tmp = read_metapage(ipbmap,\n\t\t\t   BMAPBLKNO << JFS_SBI(ipbmap->i_sb)->l2nbperpage,\n\t\t\t   PSIZE, 0);\n\tif (mp == NULL) {\n\t\terr = -EIO;\n\t\tgoto err_kfree_bmp;\n\t}\n\n\t \n\tdbmp_le = (struct dbmap_disk *) mp->data;\n\tbmp->db_mapsize = le64_to_cpu(dbmp_le->dn_mapsize);\n\tbmp->db_nfree = le64_to_cpu(dbmp_le->dn_nfree);\n\n\tbmp->db_l2nbperpage = le32_to_cpu(dbmp_le->dn_l2nbperpage);\n\tif (bmp->db_l2nbperpage > L2PSIZE - L2MINBLOCKSIZE ||\n\t\tbmp->db_l2nbperpage < 0) {\n\t\terr = -EINVAL;\n\t\tgoto err_release_metapage;\n\t}\n\n\tbmp->db_numag = le32_to_cpu(dbmp_le->dn_numag);\n\tif (!bmp->db_numag) {\n\t\terr = -EINVAL;\n\t\tgoto err_release_metapage;\n\t}\n\n\tbmp->db_maxlevel = le32_to_cpu(dbmp_le->dn_maxlevel);\n\tbmp->db_maxag = le32_to_cpu(dbmp_le->dn_maxag);\n\tbmp->db_agpref = le32_to_cpu(dbmp_le->dn_agpref);\n\tif (bmp->db_maxag >= MAXAG || bmp->db_maxag < 0 ||\n\t\tbmp->db_agpref >= MAXAG || bmp->db_agpref < 0) {\n\t\terr = -EINVAL;\n\t\tgoto err_release_metapage;\n\t}\n\n\tbmp->db_aglevel = le32_to_cpu(dbmp_le->dn_aglevel);\n\tbmp->db_agheight = le32_to_cpu(dbmp_le->dn_agheight);\n\tbmp->db_agwidth = le32_to_cpu(dbmp_le->dn_agwidth);\n\tbmp->db_agstart = le32_to_cpu(dbmp_le->dn_agstart);\n\tbmp->db_agl2size = le32_to_cpu(dbmp_le->dn_agl2size);\n\tif (bmp->db_agl2size > L2MAXL2SIZE - L2MAXAG ||\n\t    bmp->db_agl2size < 0) {\n\t\terr = -EINVAL;\n\t\tgoto err_release_metapage;\n\t}\n\n\tif (((bmp->db_mapsize - 1) >> bmp->db_agl2size) > MAXAG) {\n\t\terr = -EINVAL;\n\t\tgoto err_release_metapage;\n\t}\n\n\tfor (i = 0; i < MAXAG; i++)\n\t\tbmp->db_agfree[i] = le64_to_cpu(dbmp_le->dn_agfree[i]);\n\tbmp->db_agsize = le64_to_cpu(dbmp_le->dn_agsize);\n\tbmp->db_maxfreebud = dbmp_le->dn_maxfreebud;\n\n\t \n\trelease_metapage(mp);\n\n\t \n\tbmp->db_ipbmap = ipbmap;\n\tJFS_SBI(ipbmap->i_sb)->bmap = bmp;\n\n\tmemset(bmp->db_active, 0, sizeof(bmp->db_active));\n\n\t \n\tBMAP_LOCK_INIT(bmp);\n\n\treturn (0);\n\nerr_release_metapage:\n\trelease_metapage(mp);\nerr_kfree_bmp:\n\tkfree(bmp);\n\treturn err;\n}\n\n\n \nint dbUnmount(struct inode *ipbmap, int mounterror)\n{\n\tstruct bmap *bmp = JFS_SBI(ipbmap->i_sb)->bmap;\n\n\tif (!(mounterror || isReadOnly(ipbmap)))\n\t\tdbSync(ipbmap);\n\n\t \n\ttruncate_inode_pages(ipbmap->i_mapping, 0);\n\n\t \n\tkfree(bmp);\n\tJFS_SBI(ipbmap->i_sb)->bmap = NULL;\n\n\treturn (0);\n}\n\n \nint dbSync(struct inode *ipbmap)\n{\n\tstruct dbmap_disk *dbmp_le;\n\tstruct bmap *bmp = JFS_SBI(ipbmap->i_sb)->bmap;\n\tstruct metapage *mp;\n\tint i;\n\n\t \n\t \n\tmp = read_metapage(ipbmap,\n\t\t\t   BMAPBLKNO << JFS_SBI(ipbmap->i_sb)->l2nbperpage,\n\t\t\t   PSIZE, 0);\n\tif (mp == NULL) {\n\t\tjfs_err(\"dbSync: read_metapage failed!\");\n\t\treturn -EIO;\n\t}\n\t \n\tdbmp_le = (struct dbmap_disk *) mp->data;\n\tdbmp_le->dn_mapsize = cpu_to_le64(bmp->db_mapsize);\n\tdbmp_le->dn_nfree = cpu_to_le64(bmp->db_nfree);\n\tdbmp_le->dn_l2nbperpage = cpu_to_le32(bmp->db_l2nbperpage);\n\tdbmp_le->dn_numag = cpu_to_le32(bmp->db_numag);\n\tdbmp_le->dn_maxlevel = cpu_to_le32(bmp->db_maxlevel);\n\tdbmp_le->dn_maxag = cpu_to_le32(bmp->db_maxag);\n\tdbmp_le->dn_agpref = cpu_to_le32(bmp->db_agpref);\n\tdbmp_le->dn_aglevel = cpu_to_le32(bmp->db_aglevel);\n\tdbmp_le->dn_agheight = cpu_to_le32(bmp->db_agheight);\n\tdbmp_le->dn_agwidth = cpu_to_le32(bmp->db_agwidth);\n\tdbmp_le->dn_agstart = cpu_to_le32(bmp->db_agstart);\n\tdbmp_le->dn_agl2size = cpu_to_le32(bmp->db_agl2size);\n\tfor (i = 0; i < MAXAG; i++)\n\t\tdbmp_le->dn_agfree[i] = cpu_to_le64(bmp->db_agfree[i]);\n\tdbmp_le->dn_agsize = cpu_to_le64(bmp->db_agsize);\n\tdbmp_le->dn_maxfreebud = bmp->db_maxfreebud;\n\n\t \n\twrite_metapage(mp);\n\n\t \n\tfilemap_write_and_wait(ipbmap->i_mapping);\n\n\tdiWriteSpecial(ipbmap, 0);\n\n\treturn (0);\n}\n\n \nint dbFree(struct inode *ip, s64 blkno, s64 nblocks)\n{\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\tint nb, rc;\n\ts64 lblkno, rem;\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\tstruct super_block *sb = ipbmap->i_sb;\n\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t \n\tif (unlikely((blkno == 0) || (blkno + nblocks > bmp->db_mapsize))) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\tprintk(KERN_ERR \"blkno = %Lx, nblocks = %Lx\\n\",\n\t\t       (unsigned long long) blkno,\n\t\t       (unsigned long long) nblocks);\n\t\tjfs_error(ip->i_sb, \"block to be freed is outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tif (JFS_SBI(sb)->flag & JFS_DISCARD)\n\t\tif (JFS_SBI(sb)->minblks_trim <= nblocks)\n\t\t\tjfs_issue_discard(ipbmap, blkno, nblocks);\n\n\t \n\tmp = NULL;\n\tfor (rem = nblocks; rem > 0; rem -= nb, blkno += nb) {\n\t\t \n\t\tif (mp) {\n\t\t\twrite_metapage(mp);\n\t\t}\n\n\t\t \n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t \n\t\tnb = min(rem, BPERDMAP - (blkno & (BPERDMAP - 1)));\n\n\t\t \n\t\tif ((rc = dbFreeDmap(bmp, dp, blkno, nb))) {\n\t\t\tjfs_error(ip->i_sb, \"error in block map\\n\");\n\t\t\trelease_metapage(mp);\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn (rc);\n\t\t}\n\t}\n\n\t \n\tif (mp)\n\t\twrite_metapage(mp);\n\n\tIREAD_UNLOCK(ipbmap);\n\n\treturn (0);\n}\n\n\n \nint\ndbUpdatePMap(struct inode *ipbmap,\n\t     int free, s64 blkno, s64 nblocks, struct tblock * tblk)\n{\n\tint nblks, dbitno, wbitno, rbits;\n\tint word, nbits, nwords;\n\tstruct bmap *bmp = JFS_SBI(ipbmap->i_sb)->bmap;\n\ts64 lblkno, rem, lastlblkno;\n\tu32 mask;\n\tstruct dmap *dp;\n\tstruct metapage *mp;\n\tstruct jfs_log *log;\n\tint lsn, difft, diffp;\n\tunsigned long flags;\n\n\t \n\tif (blkno + nblocks > bmp->db_mapsize) {\n\t\tprintk(KERN_ERR \"blkno = %Lx, nblocks = %Lx\\n\",\n\t\t       (unsigned long long) blkno,\n\t\t       (unsigned long long) nblocks);\n\t\tjfs_error(ipbmap->i_sb, \"blocks are outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tlsn = tblk->lsn;\n\tlog = (struct jfs_log *) JFS_SBI(tblk->sb)->log;\n\tlogdiff(difft, lsn, log);\n\n\t \n\tmp = NULL;\n\tlastlblkno = 0;\n\tfor (rem = nblocks; rem > 0; rem -= nblks, blkno += nblks) {\n\t\t \n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tif (lblkno != lastlblkno) {\n\t\t\tif (mp) {\n\t\t\t\twrite_metapage(mp);\n\t\t\t}\n\n\t\t\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE,\n\t\t\t\t\t   0);\n\t\t\tif (mp == NULL)\n\t\t\t\treturn -EIO;\n\t\t\tmetapage_wait_for_io(mp);\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t \n\t\tdbitno = blkno & (BPERDMAP - 1);\n\t\tword = dbitno >> L2DBWORD;\n\t\tnblks = min(rem, (s64)BPERDMAP - dbitno);\n\n\t\t \n\t\tfor (rbits = nblks; rbits > 0;\n\t\t     rbits -= nbits, dbitno += nbits) {\n\t\t\t \n\t\t\twbitno = dbitno & (DBWORD - 1);\n\t\t\tnbits = min(rbits, DBWORD - wbitno);\n\n\t\t\t \n\t\t\tif (nbits < DBWORD) {\n\t\t\t\t \n\t\t\t\tmask =\n\t\t\t\t    (ONES << (DBWORD - nbits) >> wbitno);\n\t\t\t\tif (free)\n\t\t\t\t\tdp->pmap[word] &=\n\t\t\t\t\t    cpu_to_le32(~mask);\n\t\t\t\telse\n\t\t\t\t\tdp->pmap[word] |=\n\t\t\t\t\t    cpu_to_le32(mask);\n\n\t\t\t\tword += 1;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tnwords = rbits >> L2DBWORD;\n\t\t\t\tnbits = nwords << L2DBWORD;\n\n\t\t\t\t \n\t\t\t\tif (free)\n\t\t\t\t\tmemset(&dp->pmap[word], 0,\n\t\t\t\t\t       nwords * 4);\n\t\t\t\telse\n\t\t\t\t\tmemset(&dp->pmap[word], (int) ONES,\n\t\t\t\t\t       nwords * 4);\n\n\t\t\t\tword += nwords;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (lblkno == lastlblkno)\n\t\t\tcontinue;\n\n\t\tlastlblkno = lblkno;\n\n\t\tLOGSYNC_LOCK(log, flags);\n\t\tif (mp->lsn != 0) {\n\t\t\t \n\t\t\tlogdiff(diffp, mp->lsn, log);\n\t\t\tif (difft < diffp) {\n\t\t\t\tmp->lsn = lsn;\n\n\t\t\t\t \n\t\t\t\tlist_move(&mp->synclist, &tblk->synclist);\n\t\t\t}\n\n\t\t\t \n\t\t\tlogdiff(difft, tblk->clsn, log);\n\t\t\tlogdiff(diffp, mp->clsn, log);\n\t\t\tif (difft > diffp)\n\t\t\t\tmp->clsn = tblk->clsn;\n\t\t} else {\n\t\t\tmp->log = log;\n\t\t\tmp->lsn = lsn;\n\n\t\t\t \n\t\t\tlog->count++;\n\t\t\tlist_add(&mp->synclist, &tblk->synclist);\n\n\t\t\tmp->clsn = tblk->clsn;\n\t\t}\n\t\tLOGSYNC_UNLOCK(log, flags);\n\t}\n\n\t \n\tif (mp) {\n\t\twrite_metapage(mp);\n\t}\n\n\treturn (0);\n}\n\n\n \nint dbNextAG(struct inode *ipbmap)\n{\n\ts64 avgfree;\n\tint agpref;\n\ts64 hwm = 0;\n\tint i;\n\tint next_best = -1;\n\tstruct bmap *bmp = JFS_SBI(ipbmap->i_sb)->bmap;\n\n\tBMAP_LOCK(bmp);\n\n\t \n\tavgfree = (u32)bmp->db_nfree / bmp->db_numag;\n\n\t \n\tagpref = bmp->db_agpref;\n\tif ((atomic_read(&bmp->db_active[agpref]) == 0) &&\n\t    (bmp->db_agfree[agpref] >= avgfree))\n\t\tgoto unlock;\n\n\t \n\tfor (i = 0 ; i < bmp->db_numag; i++, agpref++) {\n\t\tif (agpref == bmp->db_numag)\n\t\t\tagpref = 0;\n\n\t\tif (atomic_read(&bmp->db_active[agpref]))\n\t\t\t \n\t\t\tcontinue;\n\t\tif (bmp->db_agfree[agpref] >= avgfree) {\n\t\t\t \n\t\t\tbmp->db_agpref = agpref;\n\t\t\tgoto unlock;\n\t\t} else if (bmp->db_agfree[agpref] > hwm) {\n\t\t\t \n\t\t\thwm = bmp->db_agfree[agpref];\n\t\t\tnext_best = agpref;\n\t\t}\n\t}\n\n\t \n\tif (next_best != -1)\n\t\tbmp->db_agpref = next_best;\n\t \nunlock:\n\tBMAP_UNLOCK(bmp);\n\n\t \n\treturn (bmp->db_agpref);\n}\n\n \nint dbAlloc(struct inode *ip, s64 hint, s64 nblocks, s64 * results)\n{\n\tint rc, agno;\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp;\n\tstruct metapage *mp;\n\ts64 lblkno, blkno;\n\tstruct dmap *dp;\n\tint l2nb;\n\ts64 mapSize;\n\tint writers;\n\n\t \n\tassert(nblocks > 0);\n\n\t \n\tl2nb = BLKSTOL2(nblocks);\n\n\tbmp = JFS_SBI(ip->i_sb)->bmap;\n\n\tmapSize = bmp->db_mapsize;\n\n\t \n\tif (hint >= mapSize) {\n\t\tjfs_error(ip->i_sb, \"the hint is outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tif (l2nb > bmp->db_agl2size) {\n\t\tIWRITE_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t\trc = dbAllocAny(bmp, nblocks, l2nb, results);\n\n\t\tgoto write_unlock;\n\t}\n\n\t \n\tif (hint == 0)\n\t\tgoto pref_ag;\n\n\t \n\tblkno = hint + 1;\n\n\tif (blkno >= bmp->db_mapsize)\n\t\tgoto pref_ag;\n\n\tagno = blkno >> bmp->db_agl2size;\n\n\t \n\tif ((blkno & (bmp->db_agsize - 1)) == 0)\n\t\t \n\t\tif (atomic_read(&bmp->db_active[agno]))\n\t\t\tgoto pref_ag;\n\n\t \n\tif (nblocks <= BPERDMAP) {\n\t\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t\t \n\t\trc = -EIO;\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL)\n\t\t\tgoto read_unlock;\n\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t \n\t\tif ((rc = dbAllocNext(bmp, dp, blkno, (int) nblocks))\n\t\t    != -ENOSPC) {\n\t\t\tif (rc == 0) {\n\t\t\t\t*results = blkno;\n\t\t\t\tmark_metapage_dirty(mp);\n\t\t\t}\n\n\t\t\trelease_metapage(mp);\n\t\t\tgoto read_unlock;\n\t\t}\n\n\t\twriters = atomic_read(&bmp->db_active[agno]);\n\t\tif ((writers > 1) ||\n\t\t    ((writers == 1) && (JFS_IP(ip)->active_ag != agno))) {\n\t\t\t \n\t\t\trelease_metapage(mp);\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\tgoto pref_ag;\n\t\t}\n\n\t\t \n\t\tif ((rc =\n\t\t     dbAllocNear(bmp, dp, blkno, (int) nblocks, l2nb, results))\n\t\t    != -ENOSPC) {\n\t\t\tif (rc == 0)\n\t\t\t\tmark_metapage_dirty(mp);\n\n\t\t\trelease_metapage(mp);\n\t\t\tgoto read_unlock;\n\t\t}\n\n\t\t \n\t\tif ((rc = dbAllocDmapLev(bmp, dp, (int) nblocks, l2nb, results))\n\t\t    != -ENOSPC) {\n\t\t\tif (rc == 0)\n\t\t\t\tmark_metapage_dirty(mp);\n\n\t\t\trelease_metapage(mp);\n\t\t\tgoto read_unlock;\n\t\t}\n\n\t\trelease_metapage(mp);\n\t\tIREAD_UNLOCK(ipbmap);\n\t}\n\n\t \n\tIWRITE_LOCK(ipbmap, RDWRLOCK_DMAP);\n\tif ((rc = dbAllocAG(bmp, agno, nblocks, l2nb, results)) != -ENOSPC)\n\t\tgoto write_unlock;\n\n\tIWRITE_UNLOCK(ipbmap);\n\n\n      pref_ag:\n\t \n\tagno = dbNextAG(ipbmap);\n\tIWRITE_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t \n\tif ((rc = dbAllocAG(bmp, agno, nblocks, l2nb, results)) == -ENOSPC)\n\t\trc = dbAllocAny(bmp, nblocks, l2nb, results);\n\n      write_unlock:\n\tIWRITE_UNLOCK(ipbmap);\n\n\treturn (rc);\n\n      read_unlock:\n\tIREAD_UNLOCK(ipbmap);\n\n\treturn (rc);\n}\n\n \nint\ndbReAlloc(struct inode *ip,\n\t  s64 blkno, s64 nblocks, s64 addnblocks, s64 * results)\n{\n\tint rc;\n\n\t \n\tif ((rc = dbExtend(ip, blkno, nblocks, addnblocks)) == 0) {\n\t\t*results = blkno;\n\t\treturn (0);\n\t} else {\n\t\tif (rc != -ENOSPC)\n\t\t\treturn (rc);\n\t}\n\n\t \n\treturn (dbAlloc\n\t\t(ip, blkno + nblocks - 1, addnblocks + nblocks, results));\n}\n\n\n \nstatic int dbExtend(struct inode *ip, s64 blkno, s64 nblocks, s64 addnblocks)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\n\ts64 lblkno, lastblkno, extblkno;\n\tuint rel_block;\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\tint rc;\n\tstruct inode *ipbmap = sbi->ipbmap;\n\tstruct bmap *bmp;\n\n\t \n\tif (((rel_block = blkno & (sbi->nbperpage - 1))) &&\n\t    (rel_block + nblocks + addnblocks > sbi->nbperpage))\n\t\treturn -ENOSPC;\n\n\t \n\tlastblkno = blkno + nblocks - 1;\n\n\t \n\textblkno = lastblkno + 1;\n\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t \n\tbmp = sbi->bmap;\n\tif (lastblkno < 0 || lastblkno >= bmp->db_mapsize) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\tjfs_error(ip->i_sb, \"the block is outside the filesystem\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tif (addnblocks > BPERDMAP || extblkno >= bmp->db_mapsize ||\n\t    (extblkno & (bmp->db_agsize - 1)) == 0) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\treturn -ENOSPC;\n\t}\n\n\t \n\tlblkno = BLKTODMAP(extblkno, bmp->db_l2nbperpage);\n\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\tif (mp == NULL) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\treturn -EIO;\n\t}\n\n\tdp = (struct dmap *) mp->data;\n\n\t \n\trc = dbAllocNext(bmp, dp, extblkno, (int) addnblocks);\n\n\tIREAD_UNLOCK(ipbmap);\n\n\t \n\tif (rc == 0)\n\t\twrite_metapage(mp);\n\telse\n\t\t \n\t\trelease_metapage(mp);\n\n\treturn (rc);\n}\n\n\n \nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks)\n{\n\tint dbitno, word, rembits, nb, nwords, wbitno, nw;\n\tint l2size;\n\ts8 *leaf;\n\tu32 mask;\n\n\tif (dp->tree.leafidx != cpu_to_le32(LEAFIND)) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb, \"Corrupt dmap page\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tleaf = dp->tree.stree + le32_to_cpu(dp->tree.leafidx);\n\n\t \n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t \n\tif (dbitno + nblocks > BPERDMAP)\n\t\treturn -ENOSPC;\n\n\t \n\tif (leaf[word] == NOFREE)\n\t\treturn -ENOSPC;\n\n\t \n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t \n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t \n\t\tif (nb < DBWORD) {\n\t\t\t \n\t\t\tmask = (ONES << (DBWORD - nb) >> wbitno);\n\t\t\tif ((mask & ~le32_to_cpu(dp->wmap[word])) != mask)\n\t\t\t\treturn -ENOSPC;\n\n\t\t\tword += 1;\n\t\t} else {\n\t\t\t \n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tnb = nwords << L2DBWORD;\n\n\t\t\t \n\t\t\twhile (nwords > 0) {\n\t\t\t\t \n\t\t\t\tif (leaf[word] < BUDMIN)\n\t\t\t\t\treturn -ENOSPC;\n\n\t\t\t\t \n\t\t\t\tl2size =\n\t\t\t\t    min_t(int, leaf[word], NLSTOL2BSZ(nwords));\n\n\t\t\t\t \n\t\t\t\tnw = BUDSIZE(l2size, BUDMIN);\n\n\t\t\t\tnwords -= nw;\n\t\t\t\tword += nw;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\treturn (dbAllocDmap(bmp, dp, blkno, nblocks));\n}\n\n\n \nstatic int\ndbAllocNear(struct bmap * bmp,\n\t    struct dmap * dp, s64 blkno, int nblocks, int l2nb, s64 * results)\n{\n\tint word, lword, rc;\n\ts8 *leaf;\n\n\tif (dp->tree.leafidx != cpu_to_le32(LEAFIND)) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb, \"Corrupt dmap page\\n\");\n\t\treturn -EIO;\n\t}\n\n\tleaf = dp->tree.stree + le32_to_cpu(dp->tree.leafidx);\n\n\t \n\tword = (blkno & (BPERDMAP - 1)) >> L2DBWORD;\n\tlword = min(word + 4, LPERDMAP);\n\n\t \n\tfor (; word < lword; word++) {\n\t\t \n\t\tif (leaf[word] < l2nb)\n\t\t\tcontinue;\n\n\t\t \n\t\tblkno = le64_to_cpu(dp->start) + (word << L2DBWORD);\n\n\t\t \n\t\tif (leaf[word] < BUDMIN)\n\t\t\tblkno +=\n\t\t\t    dbFindBits(le32_to_cpu(dp->wmap[word]), l2nb);\n\n\t\t \n\t\tif ((rc = dbAllocDmap(bmp, dp, blkno, nblocks)) == 0)\n\t\t\t*results = blkno;\n\n\t\treturn (rc);\n\t}\n\n\treturn -ENOSPC;\n}\n\n\n \nstatic int\ndbAllocAG(struct bmap * bmp, int agno, s64 nblocks, int l2nb, s64 * results)\n{\n\tstruct metapage *mp;\n\tstruct dmapctl *dcp;\n\tint rc, ti, i, k, m, n, agperlev;\n\ts64 blkno, lblkno;\n\tint budmin;\n\n\t \n\tif (l2nb > bmp->db_agl2size) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t  \"allocation request is larger than the allocation group size\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tblkno = (s64) agno << bmp->db_agl2size;\n\n\t \n\tif (bmp->db_agsize == BPERDMAP\n\t    || bmp->db_agfree[agno] == bmp->db_agsize) {\n\t\trc = dbAllocCtl(bmp, nblocks, l2nb, blkno, results);\n\t\tif ((rc == -ENOSPC) &&\n\t\t    (bmp->db_agfree[agno] == bmp->db_agsize)) {\n\t\t\tprintk(KERN_ERR \"blkno = %Lx, blocks = %Lx\\n\",\n\t\t\t       (unsigned long long) blkno,\n\t\t\t       (unsigned long long) nblocks);\n\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t  \"dbAllocCtl failed in free AG\\n\");\n\t\t}\n\t\treturn (rc);\n\t}\n\n\t \n\tlblkno = BLKTOCTL(blkno, bmp->db_l2nbperpage, bmp->db_aglevel);\n\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\n\tif (mp == NULL)\n\t\treturn -EIO;\n\tdcp = (struct dmapctl *) mp->data;\n\tbudmin = dcp->budmin;\n\n\tif (dcp->leafidx != cpu_to_le32(CTLLEAFIND)) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb, \"Corrupt dmapctl page\\n\");\n\t\trelease_metapage(mp);\n\t\treturn -EIO;\n\t}\n\n\t \n\tagperlev =\n\t    (1 << (L2LPERCTL - (bmp->db_agheight << 1))) / bmp->db_agwidth;\n\tti = bmp->db_agstart + bmp->db_agwidth * (agno & (agperlev - 1));\n\n\t \n\tfor (i = 0; i < bmp->db_agwidth; i++, ti++) {\n\t\t \n\t\tif (l2nb > dcp->stree[ti])\n\t\t\tcontinue;\n\n\t\t \n\t\tfor (k = bmp->db_agheight; k > 0; k--) {\n\t\t\tfor (n = 0, m = (ti << 2) + 1; n < 4; n++) {\n\t\t\t\tif (l2nb <= dcp->stree[m + n]) {\n\t\t\t\t\tti = m + n;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (n == 4) {\n\t\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t\t  \"failed descending stree\\n\");\n\t\t\t\trelease_metapage(mp);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (bmp->db_aglevel == 2)\n\t\t\tblkno = 0;\n\t\telse if (bmp->db_aglevel == 1)\n\t\t\tblkno &= ~(MAXL1SIZE - 1);\n\t\telse\t\t \n\t\t\tblkno &= ~(MAXL0SIZE - 1);\n\n\t\tblkno +=\n\t\t    ((s64) (ti - le32_to_cpu(dcp->leafidx))) << budmin;\n\n\t\t \n\t\trelease_metapage(mp);\n\n\t\t \n\t\tif (l2nb < budmin) {\n\n\t\t\t \n\t\t\tif ((rc =\n\t\t\t     dbFindCtl(bmp, l2nb, bmp->db_aglevel - 1,\n\t\t\t\t       &blkno))) {\n\t\t\t\tif (rc == -ENOSPC) {\n\t\t\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t\t\t  \"control page inconsistent\\n\");\n\t\t\t\t\treturn -EIO;\n\t\t\t\t}\n\t\t\t\treturn (rc);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\trc = dbAllocCtl(bmp, nblocks, l2nb, blkno, results);\n\t\tif (rc == -ENOSPC) {\n\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t  \"unable to allocate blocks\\n\");\n\t\t\trc = -EIO;\n\t\t}\n\t\treturn (rc);\n\t}\n\n\t \n\trelease_metapage(mp);\n\n\treturn -ENOSPC;\n}\n\n\n \nstatic int dbAllocAny(struct bmap * bmp, s64 nblocks, int l2nb, s64 * results)\n{\n\tint rc;\n\ts64 blkno = 0;\n\n\t \n\tif ((rc = dbFindCtl(bmp, l2nb, bmp->db_maxlevel, &blkno)))\n\t\treturn (rc);\n\n\t \n\trc = dbAllocCtl(bmp, nblocks, l2nb, blkno, results);\n\tif (rc == -ENOSPC) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb, \"unable to allocate blocks\\n\");\n\t\treturn -EIO;\n\t}\n\treturn (rc);\n}\n\n\n \ns64 dbDiscardAG(struct inode *ip, int agno, s64 minlen)\n{\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\ts64 nblocks, blkno;\n\tu64 trimmed = 0;\n\tint rc, l2nb;\n\tstruct super_block *sb = ipbmap->i_sb;\n\n\tstruct range2trim {\n\t\tu64 blkno;\n\t\tu64 nblocks;\n\t} *totrim, *tt;\n\n\t \n\tint count = 0, range_cnt;\n\tu64 max_ranges;\n\n\t \n\tIWRITE_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\tnblocks = bmp->db_agfree[agno];\n\tmax_ranges = nblocks;\n\tdo_div(max_ranges, minlen);\n\trange_cnt = min_t(u64, max_ranges + 1, 32 * 1024);\n\ttotrim = kmalloc_array(range_cnt, sizeof(struct range2trim), GFP_NOFS);\n\tif (totrim == NULL) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb, \"no memory for trim array\\n\");\n\t\tIWRITE_UNLOCK(ipbmap);\n\t\treturn 0;\n\t}\n\n\ttt = totrim;\n\twhile (nblocks >= minlen) {\n\t\tl2nb = BLKSTOL2(nblocks);\n\n\t\t \n\t\trc = dbAllocAG(bmp, agno, nblocks, l2nb, &blkno);\n\t\tif (rc == 0) {\n\t\t\ttt->blkno = blkno;\n\t\t\ttt->nblocks = nblocks;\n\t\t\ttt++; count++;\n\n\t\t\t \n\t\t\tif (bmp->db_agfree[agno] == 0)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tnblocks = bmp->db_agfree[agno];\n\t\t\tcontinue;\n\t\t} else if (rc == -ENOSPC) {\n\t\t\t \n\t\t\tl2nb = BLKSTOL2(nblocks) - 1;\n\t\t\tnblocks = 1LL << l2nb;\n\t\t} else {\n\t\t\t \n\t\t\tjfs_error(bmp->db_ipbmap->i_sb, \"-EIO\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (unlikely(count >= range_cnt - 1))\n\t\t\tbreak;\n\t}\n\tIWRITE_UNLOCK(ipbmap);\n\n\ttt->nblocks = 0;  \n\tfor (tt = totrim; tt->nblocks != 0; tt++) {\n\t\t \n\t\tif (!(JFS_SBI(sb)->flag & JFS_DISCARD))\n\t\t\tjfs_issue_discard(ip, tt->blkno, tt->nblocks);\n\t\tdbFree(ip, tt->blkno, tt->nblocks);\n\t\ttrimmed += tt->nblocks;\n\t}\n\tkfree(totrim);\n\n\treturn trimmed;\n}\n\n \nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno)\n{\n\tint rc, leafidx, lev;\n\ts64 b, lblkno;\n\tstruct dmapctl *dcp;\n\tint budmin;\n\tstruct metapage *mp;\n\n\t \n\tfor (lev = level, b = *blkno; lev >= 0; lev--) {\n\t\t \n\t\tlblkno = BLKTOCTL(b, bmp->db_l2nbperpage, lev);\n\t\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL)\n\t\t\treturn -EIO;\n\t\tdcp = (struct dmapctl *) mp->data;\n\t\tbudmin = dcp->budmin;\n\n\t\tif (dcp->leafidx != cpu_to_le32(CTLLEAFIND)) {\n\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t  \"Corrupt dmapctl page\\n\");\n\t\t\trelease_metapage(mp);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t \n\t\trc = dbFindLeaf((dmtree_t *) dcp, l2nb, &leafidx, true);\n\n\t\t \n\t\trelease_metapage(mp);\n\n\t\t \n\t\tif (rc) {\n\t\t\tif (lev != level) {\n\t\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t\t  \"dmap inconsistent\\n\");\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\treturn -ENOSPC;\n\t\t}\n\n\t\t \n\t\tb += (((s64) leafidx) << budmin);\n\n\t\t \n\t\tif (l2nb >= budmin)\n\t\t\tbreak;\n\t}\n\n\t*blkno = b;\n\treturn (0);\n}\n\n\n \nstatic int\ndbAllocCtl(struct bmap * bmp, s64 nblocks, int l2nb, s64 blkno, s64 * results)\n{\n\tint rc, nb;\n\ts64 b, lblkno, n;\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\n\t \n\tif (l2nb <= L2BPERDMAP) {\n\t\t \n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL)\n\t\t\treturn -EIO;\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t \n\t\trc = dbAllocDmapLev(bmp, dp, (int) nblocks, l2nb, results);\n\t\tif (rc == 0)\n\t\t\tmark_metapage_dirty(mp);\n\n\t\trelease_metapage(mp);\n\n\t\treturn (rc);\n\t}\n\n\t \n\tassert((blkno & (BPERDMAP - 1)) == 0);\n\n\t \n\tfor (n = nblocks, b = blkno; n > 0; n -= nb, b += nb) {\n\t\t \n\t\tlblkno = BLKTODMAP(b, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\trc = -EIO;\n\t\t\tgoto backout;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t \n\t\tif (dp->tree.stree[ROOT] != L2BPERDMAP) {\n\t\t\trelease_metapage(mp);\n\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t  \"the dmap is not all free\\n\");\n\t\t\trc = -EIO;\n\t\t\tgoto backout;\n\t\t}\n\n\t\t \n\t\tnb = min_t(s64, n, BPERDMAP);\n\n\t\t \n\t\tif ((rc = dbAllocDmap(bmp, dp, b, nb))) {\n\t\t\trelease_metapage(mp);\n\t\t\tgoto backout;\n\t\t}\n\n\t\t \n\t\twrite_metapage(mp);\n\t}\n\n\t \n\t*results = blkno;\n\treturn (0);\n\n\t \n      backout:\n\n\t \n\tfor (n = nblocks - n, b = blkno; n > 0;\n\t     n -= BPERDMAP, b += BPERDMAP) {\n\t\t \n\t\tlblkno = BLKTODMAP(b, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\t \n\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t  \"I/O Error: Block Leakage\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t \n\t\tif (dbFreeDmap(bmp, dp, b, BPERDMAP)) {\n\t\t\t \n\t\t\trelease_metapage(mp);\n\t\t\tjfs_error(bmp->db_ipbmap->i_sb, \"Block Leakage\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\twrite_metapage(mp);\n\t}\n\n\treturn (rc);\n}\n\n\n \nstatic int\ndbAllocDmapLev(struct bmap * bmp,\n\t       struct dmap * dp, int nblocks, int l2nb, s64 * results)\n{\n\ts64 blkno;\n\tint leafidx, rc;\n\n\t \n\tassert(l2nb <= L2BPERDMAP);\n\n\t \n\tif (dbFindLeaf((dmtree_t *) &dp->tree, l2nb, &leafidx, false))\n\t\treturn -ENOSPC;\n\n\tif (leafidx < 0)\n\t\treturn -EIO;\n\n\t \n\tblkno = le64_to_cpu(dp->start) + (leafidx << L2DBWORD);\n\n\t \n\tif (dp->tree.stree[leafidx + LEAFIND] < BUDMIN)\n\t\tblkno += dbFindBits(le32_to_cpu(dp->wmap[leafidx]), l2nb);\n\n\t \n\tif ((rc = dbAllocDmap(bmp, dp, blkno, nblocks)) == 0)\n\t\t*results = blkno;\n\n\treturn (rc);\n}\n\n\n \nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks)\n{\n\ts8 oldroot;\n\tint rc;\n\n\t \n\toldroot = dp->tree.stree[ROOT];\n\n\t \n\tdbAllocBits(bmp, dp, blkno, nblocks);\n\n\t \n\tif (dp->tree.stree[ROOT] == oldroot)\n\t\treturn (0);\n\n\t \n\tif ((rc = dbAdjCtl(bmp, blkno, dp->tree.stree[ROOT], 1, 0)))\n\t\tdbFreeBits(bmp, dp, blkno, nblocks);\n\n\treturn (rc);\n}\n\n\n \nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks)\n{\n\ts8 oldroot;\n\tint rc = 0, word;\n\n\t \n\toldroot = dp->tree.stree[ROOT];\n\n\t \n\trc = dbFreeBits(bmp, dp, blkno, nblocks);\n\n\t \n\tif (rc || (dp->tree.stree[ROOT] == oldroot))\n\t\treturn (rc);\n\n\t \n\tif ((rc = dbAdjCtl(bmp, blkno, dp->tree.stree[ROOT], 0, 0))) {\n\t\tword = (blkno & (BPERDMAP - 1)) >> L2DBWORD;\n\n\t\t \n\t\tif (dp->tree.stree[word] == NOFREE)\n\t\t\tdbBackSplit((dmtree_t *) & dp->tree, word);\n\n\t\tdbAllocBits(bmp, dp, blkno, nblocks);\n\t}\n\n\treturn (rc);\n}\n\n\n \nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks)\n{\n\tint dbitno, word, rembits, nb, nwords, wbitno, nw, agno;\n\tdmtree_t *tp = (dmtree_t *) & dp->tree;\n\tint size;\n\ts8 *leaf;\n\n\t \n\tleaf = dp->tree.stree + LEAFIND;\n\n\t \n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t \n\tassert(dbitno + nblocks <= BPERDMAP);\n\n\t \n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t \n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t \n\t\tif (nb < DBWORD) {\n\t\t\t \n\t\t\tdp->wmap[word] |= cpu_to_le32(ONES << (DBWORD - nb)\n\t\t\t\t\t\t      >> wbitno);\n\n\t\t\t \n\t\t\tdbSplit(tp, word, BUDMIN,\n\t\t\t\tdbMaxBud((u8 *) & dp->wmap[word]));\n\n\t\t\tword += 1;\n\t\t} else {\n\t\t\t \n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tmemset(&dp->wmap[word], (int) ONES, nwords * 4);\n\n\t\t\t \n\t\t\tnb = nwords << L2DBWORD;\n\n\t\t\t \n\t\t\tfor (; nwords > 0; nwords -= nw) {\n\t\t\t\tif (leaf[word] < BUDMIN) {\n\t\t\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t\t\t  \"leaf page corrupt\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tsize = min_t(int, leaf[word],\n\t\t\t\t\t     NLSTOL2BSZ(nwords));\n\n\t\t\t\t \n\t\t\t\tdbSplit(tp, word, size, NOFREE);\n\n\t\t\t\t \n\t\t\t\tnw = BUDSIZE(size, BUDMIN);\n\t\t\t\tword += nw;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tle32_add_cpu(&dp->nfree, -nblocks);\n\n\tBMAP_LOCK(bmp);\n\n\t \n\tagno = blkno >> bmp->db_agl2size;\n\tif (agno > bmp->db_maxag)\n\t\tbmp->db_maxag = agno;\n\n\t \n\tbmp->db_agfree[agno] -= nblocks;\n\tbmp->db_nfree -= nblocks;\n\n\tBMAP_UNLOCK(bmp);\n}\n\n\n \nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks)\n{\n\tint dbitno, word, rembits, nb, nwords, wbitno, nw, agno;\n\tdmtree_t *tp = (dmtree_t *) & dp->tree;\n\tint rc = 0;\n\tint size;\n\n\t \n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t \n\tassert(dbitno + nblocks <= BPERDMAP);\n\n\t \n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t \n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t \n\t\tif (nb < DBWORD) {\n\t\t\t \n\t\t\tdp->wmap[word] &=\n\t\t\t    cpu_to_le32(~(ONES << (DBWORD - nb)\n\t\t\t\t\t  >> wbitno));\n\n\t\t\t \n\t\t\trc = dbJoin(tp, word,\n\t\t\t\t    dbMaxBud((u8 *) & dp->wmap[word]));\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tword += 1;\n\t\t} else {\n\t\t\t \n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tmemset(&dp->wmap[word], 0, nwords * 4);\n\n\t\t\t \n\t\t\tnb = nwords << L2DBWORD;\n\n\t\t\t \n\t\t\tfor (; nwords > 0; nwords -= nw) {\n\t\t\t\t \n\t\t\t\tsize =\n\t\t\t\t    min(LITOL2BSZ\n\t\t\t\t\t(word, L2LPERDMAP, BUDMIN),\n\t\t\t\t\tNLSTOL2BSZ(nwords));\n\n\t\t\t\t \n\t\t\t\trc = dbJoin(tp, word, size);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\n\t\t\t\t \n\t\t\t\tnw = BUDSIZE(size, BUDMIN);\n\t\t\t\tword += nw;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tle32_add_cpu(&dp->nfree, nblocks);\n\n\tBMAP_LOCK(bmp);\n\n\t \n\tagno = blkno >> bmp->db_agl2size;\n\tbmp->db_nfree += nblocks;\n\tbmp->db_agfree[agno] += nblocks;\n\n\t \n\tif ((bmp->db_agfree[agno] == bmp->db_agsize && agno == bmp->db_maxag) ||\n\t    (agno == bmp->db_numag - 1 &&\n\t     bmp->db_agfree[agno] == (bmp-> db_mapsize & (BPERDMAP - 1)))) {\n\t\twhile (bmp->db_maxag > 0) {\n\t\t\tbmp->db_maxag -= 1;\n\t\t\tif (bmp->db_agfree[bmp->db_maxag] !=\n\t\t\t    bmp->db_agsize)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (bmp->db_agpref > bmp->db_maxag)\n\t\t\tbmp->db_agpref = bmp->db_maxag;\n\t}\n\n\tBMAP_UNLOCK(bmp);\n\n\treturn 0;\n}\n\n\n \nstatic int\ndbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc, int level)\n{\n\tstruct metapage *mp;\n\ts8 oldroot;\n\tint oldval;\n\ts64 lblkno;\n\tstruct dmapctl *dcp;\n\tint rc, leafno, ti;\n\n\t \n\tlblkno = BLKTOCTL(blkno, bmp->db_l2nbperpage, level);\n\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\n\tif (mp == NULL)\n\t\treturn -EIO;\n\tdcp = (struct dmapctl *) mp->data;\n\n\tif (dcp->leafidx != cpu_to_le32(CTLLEAFIND)) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb, \"Corrupt dmapctl page\\n\");\n\t\trelease_metapage(mp);\n\t\treturn -EIO;\n\t}\n\n\t \n\tleafno = BLKTOCTLLEAF(blkno, dcp->budmin);\n\tti = leafno + le32_to_cpu(dcp->leafidx);\n\n\t \n\toldval = dcp->stree[ti];\n\toldroot = dcp->stree[ROOT];\n\n\t \n\tif (alloc) {\n\t\t \n\t\tif (oldval == NOFREE) {\n\t\t\trc = dbBackSplit((dmtree_t *) dcp, leafno);\n\t\t\tif (rc) {\n\t\t\t\trelease_metapage(mp);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t\toldval = dcp->stree[ti];\n\t\t}\n\t\tdbSplit((dmtree_t *) dcp, leafno, dcp->budmin, newval);\n\t} else {\n\t\trc = dbJoin((dmtree_t *) dcp, leafno, newval);\n\t\tif (rc) {\n\t\t\trelease_metapage(mp);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\t \n\tif (dcp->stree[ROOT] != oldroot) {\n\t\t \n\t\tif (level < bmp->db_maxlevel) {\n\t\t\t \n\t\t\tif ((rc =\n\t\t\t     dbAdjCtl(bmp, blkno, dcp->stree[ROOT], alloc,\n\t\t\t\t      level + 1))) {\n\t\t\t\t \n\t\t\t\tif (alloc) {\n\t\t\t\t\tdbJoin((dmtree_t *) dcp, leafno,\n\t\t\t\t\t       oldval);\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tif (dcp->stree[ti] == NOFREE)\n\t\t\t\t\t\tdbBackSplit((dmtree_t *)\n\t\t\t\t\t\t\t    dcp, leafno);\n\t\t\t\t\tdbSplit((dmtree_t *) dcp, leafno,\n\t\t\t\t\t\tdcp->budmin, oldval);\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\trelease_metapage(mp);\n\t\t\t\treturn (rc);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tassert(level == bmp->db_maxlevel);\n\t\t\tif (bmp->db_maxfreebud != oldroot) {\n\t\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t\t  \"the maximum free buddy is not the old root\\n\");\n\t\t\t}\n\t\t\tbmp->db_maxfreebud = dcp->stree[ROOT];\n\t\t}\n\t}\n\n\t \n\twrite_metapage(mp);\n\n\treturn (0);\n}\n\n\n \nstatic void dbSplit(dmtree_t * tp, int leafno, int splitsz, int newval)\n{\n\tint budsz;\n\tint cursz;\n\ts8 *leaf = tp->dmt_stree + le32_to_cpu(tp->dmt_leafidx);\n\n\t \n\tif (leaf[leafno] > tp->dmt_budmin) {\n\t\t \n\t\tcursz = leaf[leafno] - 1;\n\t\tbudsz = BUDSIZE(cursz, tp->dmt_budmin);\n\n\t\t \n\t\twhile (cursz >= splitsz) {\n\t\t\t \n\t\t\tdbAdjTree(tp, leafno ^ budsz, cursz);\n\n\t\t\t \n\t\t\tcursz -= 1;\n\t\t\tbudsz >>= 1;\n\t\t}\n\t}\n\n\t \n\tdbAdjTree(tp, leafno, newval);\n}\n\n\n \nstatic int dbBackSplit(dmtree_t * tp, int leafno)\n{\n\tint budsz, bud, w, bsz, size;\n\tint cursz;\n\ts8 *leaf = tp->dmt_stree + le32_to_cpu(tp->dmt_leafidx);\n\n\t \n\tassert(leaf[leafno] == NOFREE);\n\n\t \n\tsize =\n\t    LITOL2BSZ(leafno, le32_to_cpu(tp->dmt_l2nleafs),\n\t\t      tp->dmt_budmin);\n\n\t \n\tbudsz = BUDSIZE(size, tp->dmt_budmin);\n\n\t \n\twhile (leaf[leafno] == NOFREE) {\n\t\t \n\t\tfor (w = leafno, bsz = budsz;; bsz <<= 1,\n\t\t     w = (w < bud) ? w : bud) {\n\t\t\tif (bsz >= le32_to_cpu(tp->dmt_nleafs)) {\n\t\t\t\tjfs_err(\"JFS: block map error in dbBackSplit\");\n\t\t\t\treturn -EIO;\n\t\t\t}\n\n\t\t\t \n\t\t\tbud = w ^ bsz;\n\n\t\t\t \n\t\t\tif (leaf[bud] != NOFREE) {\n\t\t\t\t \n\t\t\t\tcursz = leaf[bud] - 1;\n\t\t\t\tdbSplit(tp, bud, cursz, cursz);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (leaf[leafno] != size) {\n\t\tjfs_err(\"JFS: wrong leaf value in dbBackSplit\");\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\n\n \nstatic int dbJoin(dmtree_t * tp, int leafno, int newval)\n{\n\tint budsz, buddy;\n\ts8 *leaf;\n\n\t \n\tif (newval >= tp->dmt_budmin) {\n\t\t \n\t\tleaf = tp->dmt_stree + le32_to_cpu(tp->dmt_leafidx);\n\n\t\t \n\t\tbudsz = BUDSIZE(newval, tp->dmt_budmin);\n\n\t\t \n\t\twhile (budsz < le32_to_cpu(tp->dmt_nleafs)) {\n\t\t\t \n\t\t\tbuddy = leafno ^ budsz;\n\n\t\t\t \n\t\t\tif (newval > leaf[buddy])\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tif (newval < leaf[buddy])\n\t\t\t\treturn -EIO;\n\n\t\t\t \n\t\t\tif (leafno < buddy) {\n\t\t\t\t \n\t\t\t\tdbAdjTree(tp, buddy, NOFREE);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tdbAdjTree(tp, leafno, NOFREE);\n\t\t\t\tleafno = buddy;\n\t\t\t}\n\n\t\t\t \n\t\t\tnewval += 1;\n\t\t\tbudsz <<= 1;\n\t\t}\n\t}\n\n\t \n\tdbAdjTree(tp, leafno, newval);\n\n\treturn 0;\n}\n\n\n \nstatic void dbAdjTree(dmtree_t * tp, int leafno, int newval)\n{\n\tint lp, pp, k;\n\tint max;\n\n\t \n\tlp = leafno + le32_to_cpu(tp->dmt_leafidx);\n\n\t \n\tif (tp->dmt_stree[lp] == newval)\n\t\treturn;\n\n\t \n\ttp->dmt_stree[lp] = newval;\n\n\t \n\tfor (k = 0; k < le32_to_cpu(tp->dmt_height); k++) {\n\t\t \n\t\tlp = ((lp - 1) & ~0x03) + 1;\n\n\t\t \n\t\tpp = (lp - 1) >> 2;\n\n\t\t \n\t\tmax = TREEMAX(&tp->dmt_stree[lp]);\n\n\t\t \n\t\tif (tp->dmt_stree[pp] == max)\n\t\t\tbreak;\n\n\t\t \n\t\ttp->dmt_stree[pp] = max;\n\n\t\t \n\t\tlp = pp;\n\t}\n}\n\n\n \nstatic int dbFindLeaf(dmtree_t *tp, int l2nb, int *leafidx, bool is_ctl)\n{\n\tint ti, n = 0, k, x = 0;\n\tint max_size;\n\n\tmax_size = is_ctl ? CTLTREESIZE : TREESIZE;\n\n\t \n\tif (l2nb > tp->dmt_stree[ROOT])\n\t\treturn -ENOSPC;\n\n\t \n\tfor (k = le32_to_cpu(tp->dmt_height), ti = 1;\n\t     k > 0; k--, ti = ((ti + n) << 2) + 1) {\n\t\t \n\t\tfor (x = ti, n = 0; n < 4; n++) {\n\t\t\t \n\t\t\tif (x + n > max_size)\n\t\t\t\treturn -ENOSPC;\n\t\t\tif (l2nb <= tp->dmt_stree[x + n])\n\t\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tassert(n < 4);\n\t}\n\n\t \n\t*leafidx = x + n - le32_to_cpu(tp->dmt_leafidx);\n\n\treturn (0);\n}\n\n\n \nstatic int dbFindBits(u32 word, int l2nb)\n{\n\tint bitno, nb;\n\tu32 mask;\n\n\t \n\tnb = 1 << l2nb;\n\tassert(nb <= DBWORD);\n\n\t \n\tword = ~word;\n\tmask = ONES << (DBWORD - nb);\n\n\t \n\tfor (bitno = 0; mask != 0; bitno += nb, mask >>= nb) {\n\t\tif ((mask & word) == mask)\n\t\t\tbreak;\n\t}\n\n\tASSERT(bitno < 32);\n\n\t \n\treturn (bitno);\n}\n\n\n \nstatic int dbMaxBud(u8 * cp)\n{\n\tsigned char tmp1, tmp2;\n\n\t \n\tif (*((uint *) cp) == 0)\n\t\treturn (BUDMIN);\n\n\t \n\tif (*((u16 *) cp) == 0 || *((u16 *) cp + 1) == 0)\n\t\treturn (BUDMIN - 1);\n\n\t \n\ttmp1 = max(budtab[cp[2]], budtab[cp[3]]);\n\ttmp2 = max(budtab[cp[0]], budtab[cp[1]]);\n\treturn (max(tmp1, tmp2));\n}\n\n\n \nstatic int cnttz(u32 word)\n{\n\tint n;\n\n\tfor (n = 0; n < 32; n++, word >>= 1) {\n\t\tif (word & 0x01)\n\t\t\tbreak;\n\t}\n\n\treturn (n);\n}\n\n\n \nstatic int cntlz(u32 value)\n{\n\tint n;\n\n\tfor (n = 0; n < 32; n++, value <<= 1) {\n\t\tif (value & HIGHORDER)\n\t\t\tbreak;\n\t}\n\treturn (n);\n}\n\n\n \nstatic int blkstol2(s64 nb)\n{\n\tint l2nb;\n\ts64 mask;\t\t \n\n\tmask = (s64) 1 << (64 - 1);\n\n\t \n\tfor (l2nb = 0; l2nb < 64; l2nb++, mask >>= 1) {\n\t\t \n\t\tif (nb & mask) {\n\t\t\t \n\t\t\tl2nb = (64 - 1) - l2nb;\n\n\t\t\t \n\t\t\tif (~mask & nb)\n\t\t\t\tl2nb++;\n\n\t\t\treturn (l2nb);\n\t\t}\n\t}\n\tassert(0);\n\treturn 0;\t\t \n}\n\n\n \nint dbAllocBottomUp(struct inode *ip, s64 blkno, s64 nblocks)\n{\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\tint nb, rc;\n\ts64 lblkno, rem;\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t \n\tASSERT(nblocks <= bmp->db_mapsize - blkno);\n\n\t \n\tmp = NULL;\n\tfor (rem = nblocks; rem > 0; rem -= nb, blkno += nb) {\n\t\t \n\t\tif (mp) {\n\t\t\twrite_metapage(mp);\n\t\t}\n\n\t\t \n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t \n\t\tnb = min(rem, BPERDMAP - (blkno & (BPERDMAP - 1)));\n\n\t\t \n\t\tif ((rc = dbAllocDmapBU(bmp, dp, blkno, nb))) {\n\t\t\trelease_metapage(mp);\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn (rc);\n\t\t}\n\t}\n\n\t \n\twrite_metapage(mp);\n\n\tIREAD_UNLOCK(ipbmap);\n\n\treturn (0);\n}\n\n\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks)\n{\n\tint rc;\n\tint dbitno, word, rembits, nb, nwords, wbitno, agno;\n\ts8 oldroot;\n\tstruct dmaptree *tp = (struct dmaptree *) & dp->tree;\n\n\t \n\toldroot = tp->stree[ROOT];\n\n\t \n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t \n\tassert(dbitno + nblocks <= BPERDMAP);\n\n\t \n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t \n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t \n\t\tif (nb < DBWORD) {\n\t\t\t \n\t\t\tdp->wmap[word] |= cpu_to_le32(ONES << (DBWORD - nb)\n\t\t\t\t\t\t      >> wbitno);\n\n\t\t\tword++;\n\t\t} else {\n\t\t\t \n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tmemset(&dp->wmap[word], (int) ONES, nwords * 4);\n\n\t\t\t \n\t\t\tnb = nwords << L2DBWORD;\n\t\t\tword += nwords;\n\t\t}\n\t}\n\n\t \n\tle32_add_cpu(&dp->nfree, -nblocks);\n\n\t \n\tdbInitDmapTree(dp);\n\n\tBMAP_LOCK(bmp);\n\n\t \n\tagno = blkno >> bmp->db_agl2size;\n\tif (agno > bmp->db_maxag)\n\t\tbmp->db_maxag = agno;\n\n\t \n\tbmp->db_agfree[agno] -= nblocks;\n\tbmp->db_nfree -= nblocks;\n\n\tBMAP_UNLOCK(bmp);\n\n\t \n\tif (tp->stree[ROOT] == oldroot)\n\t\treturn (0);\n\n\t \n\tif ((rc = dbAdjCtl(bmp, blkno, tp->stree[ROOT], 1, 0)))\n\t\tdbFreeBits(bmp, dp, blkno, nblocks);\n\n\treturn (rc);\n}\n\n\n \nint dbExtendFS(struct inode *ipbmap, s64 blkno,\ts64 nblocks)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(ipbmap->i_sb);\n\tint nbperpage = sbi->nbperpage;\n\tint i, i0 = true, j, j0 = true, k, n;\n\ts64 newsize;\n\ts64 p;\n\tstruct metapage *mp, *l2mp, *l1mp = NULL, *l0mp = NULL;\n\tstruct dmapctl *l2dcp, *l1dcp, *l0dcp;\n\tstruct dmap *dp;\n\ts8 *l0leaf, *l1leaf, *l2leaf;\n\tstruct bmap *bmp = sbi->bmap;\n\tint agno, l2agsize, oldl2agsize;\n\ts64 ag_rem;\n\n\tnewsize = blkno + nblocks;\n\n\tjfs_info(\"dbExtendFS: blkno:%Ld nblocks:%Ld newsize:%Ld\",\n\t\t (long long) blkno, (long long) nblocks, (long long) newsize);\n\n\t \n\n\t \n\tbmp->db_mapsize = newsize;\n\tbmp->db_maxlevel = BMAPSZTOLEV(bmp->db_mapsize);\n\n\t \n\tl2agsize = dbGetL2AGSize(newsize);\n\toldl2agsize = bmp->db_agl2size;\n\n\tbmp->db_agl2size = l2agsize;\n\tbmp->db_agsize = 1 << l2agsize;\n\n\t \n\tagno = bmp->db_numag;\n\tbmp->db_numag = newsize >> l2agsize;\n\tbmp->db_numag += ((u32) newsize % (u32) bmp->db_agsize) ? 1 : 0;\n\n\t \n\tif (l2agsize == oldl2agsize)\n\t\tgoto extend;\n\tk = 1 << (l2agsize - oldl2agsize);\n\tag_rem = bmp->db_agfree[0];\t \n\tfor (i = 0, n = 0; i < agno; n++) {\n\t\tbmp->db_agfree[n] = 0;\t \n\n\t\t \n\t\tfor (j = 0; j < k && i < agno; j++, i++) {\n\t\t\t \n\t\t\tbmp->db_agfree[n] += bmp->db_agfree[i];\n\t\t}\n\t}\n\tbmp->db_agfree[0] += ag_rem;\t \n\n\tfor (; n < MAXAG; n++)\n\t\tbmp->db_agfree[n] = 0;\n\n\t \n\n\tbmp->db_maxag = bmp->db_maxag / k;\n\n\t \n      extend:\n\t \n\tp = BMAPBLKNO + nbperpage;\t \n\tl2mp = read_metapage(ipbmap, p, PSIZE, 0);\n\tif (!l2mp) {\n\t\tjfs_error(ipbmap->i_sb, \"L2 page could not be read\\n\");\n\t\treturn -EIO;\n\t}\n\tl2dcp = (struct dmapctl *) l2mp->data;\n\n\t \n\tk = blkno >> L2MAXL1SIZE;\n\tl2leaf = l2dcp->stree + CTLLEAFIND + k;\n\tp = BLKTOL1(blkno, sbi->l2nbperpage);\t \n\n\t \n\tfor (; k < LPERCTL; k++, p += nbperpage) {\n\t\t \n\t\tif (j0) {\n\t\t\t \n\t\t\tl1mp = read_metapage(ipbmap, p, PSIZE, 0);\n\t\t\tif (l1mp == NULL)\n\t\t\t\tgoto errout;\n\t\t\tl1dcp = (struct dmapctl *) l1mp->data;\n\n\t\t\t \n\t\t\tj = (blkno & (MAXL1SIZE - 1)) >> L2MAXL0SIZE;\n\t\t\tl1leaf = l1dcp->stree + CTLLEAFIND + j;\n\t\t\tp = BLKTOL0(blkno, sbi->l2nbperpage);\n\t\t\tj0 = false;\n\t\t} else {\n\t\t\t \n\t\t\tl1mp = get_metapage(ipbmap, p, PSIZE, 0);\n\t\t\tif (l1mp == NULL)\n\t\t\t\tgoto errout;\n\n\t\t\tl1dcp = (struct dmapctl *) l1mp->data;\n\n\t\t\t \n\t\t\tj = 0;\n\t\t\tl1leaf = l1dcp->stree + CTLLEAFIND;\n\t\t\tp += nbperpage;\t \n\t\t}\n\n\t\t \n\t\tfor (; j < LPERCTL; j++) {\n\t\t\t \n\t\t\tif (i0) {\n\t\t\t\t \n\n\t\t\t\tl0mp = read_metapage(ipbmap, p, PSIZE, 0);\n\t\t\t\tif (l0mp == NULL)\n\t\t\t\t\tgoto errout;\n\t\t\t\tl0dcp = (struct dmapctl *) l0mp->data;\n\n\t\t\t\t \n\t\t\t\ti = (blkno & (MAXL0SIZE - 1)) >>\n\t\t\t\t    L2BPERDMAP;\n\t\t\t\tl0leaf = l0dcp->stree + CTLLEAFIND + i;\n\t\t\t\tp = BLKTODMAP(blkno,\n\t\t\t\t\t      sbi->l2nbperpage);\n\t\t\t\ti0 = false;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tl0mp = get_metapage(ipbmap, p, PSIZE, 0);\n\t\t\t\tif (l0mp == NULL)\n\t\t\t\t\tgoto errout;\n\n\t\t\t\tl0dcp = (struct dmapctl *) l0mp->data;\n\n\t\t\t\t \n\t\t\t\ti = 0;\n\t\t\t\tl0leaf = l0dcp->stree + CTLLEAFIND;\n\t\t\t\tp += nbperpage;\t \n\t\t\t}\n\n\t\t\t \n\t\t\tfor (; i < LPERCTL; i++) {\n\t\t\t\t \n\t\t\t\tif ((n = blkno & (BPERDMAP - 1))) {\n\t\t\t\t\t \n\t\t\t\t\tmp = read_metapage(ipbmap, p,\n\t\t\t\t\t\t\t   PSIZE, 0);\n\t\t\t\t\tif (mp == NULL)\n\t\t\t\t\t\tgoto errout;\n\t\t\t\t\tn = min(nblocks, (s64)BPERDMAP - n);\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tmp = read_metapage(ipbmap, p,\n\t\t\t\t\t\t\t   PSIZE, 0);\n\t\t\t\t\tif (mp == NULL)\n\t\t\t\t\t\tgoto errout;\n\n\t\t\t\t\tn = min_t(s64, nblocks, BPERDMAP);\n\t\t\t\t}\n\n\t\t\t\tdp = (struct dmap *) mp->data;\n\t\t\t\t*l0leaf = dbInitDmap(dp, blkno, n);\n\n\t\t\t\tbmp->db_nfree += n;\n\t\t\t\tagno = le64_to_cpu(dp->start) >> l2agsize;\n\t\t\t\tbmp->db_agfree[agno] += n;\n\n\t\t\t\twrite_metapage(mp);\n\n\t\t\t\tl0leaf++;\n\t\t\t\tp += nbperpage;\n\n\t\t\t\tblkno += n;\n\t\t\t\tnblocks -= n;\n\t\t\t\tif (nblocks == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\t \n\n\t\t\t \n\t\t\t*l1leaf = dbInitDmapCtl(l0dcp, 0, ++i);\n\t\t\twrite_metapage(l0mp);\n\t\t\tl0mp = NULL;\n\n\t\t\tif (nblocks)\n\t\t\t\tl1leaf++;\t \n\t\t\telse {\n\t\t\t\t \n\t\t\t\tif (j > 0)\n\t\t\t\t\tbreak;\t \n\t\t\t\telse {\n\t\t\t\t\t \n\t\t\t\t\tbmp->db_maxfreebud = *l1leaf;\n\t\t\t\t\trelease_metapage(l1mp);\n\t\t\t\t\trelease_metapage(l2mp);\n\t\t\t\t\tgoto finalize;\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\t \n\n\t\t \n\t\t*l2leaf = dbInitDmapCtl(l1dcp, 1, ++j);\n\t\twrite_metapage(l1mp);\n\t\tl1mp = NULL;\n\n\t\tif (nblocks)\n\t\t\tl2leaf++;\t \n\t\telse {\n\t\t\t \n\t\t\tif (k > 0)\n\t\t\t\tbreak;\t \n\t\t\telse {\n\t\t\t\t \n\t\t\t\tbmp->db_maxfreebud = *l2leaf;\n\t\t\t\trelease_metapage(l2mp);\n\t\t\t\tgoto finalize;\n\t\t\t}\n\t\t}\n\t}\t\t\t \n\n\tjfs_error(ipbmap->i_sb, \"function has not returned as expected\\n\");\nerrout:\n\tif (l0mp)\n\t\trelease_metapage(l0mp);\n\tif (l1mp)\n\t\trelease_metapage(l1mp);\n\trelease_metapage(l2mp);\n\treturn -EIO;\n\n\t \nfinalize:\n\n\treturn 0;\n}\n\n\n \nvoid dbFinalizeBmap(struct inode *ipbmap)\n{\n\tstruct bmap *bmp = JFS_SBI(ipbmap->i_sb)->bmap;\n\tint actags, inactags, l2nl;\n\ts64 ag_rem, actfree, inactfree, avgfree;\n\tint i, n;\n\n\t \n\n\t \n\n\t \n\tactags = bmp->db_maxag + 1;\n\tinactags = bmp->db_numag - actags;\n\tag_rem = bmp->db_mapsize & (bmp->db_agsize - 1);\t \n\n\t \n\tinactfree = (inactags && ag_rem) ?\n\t    ((inactags - 1) << bmp->db_agl2size) + ag_rem\n\t    : inactags << bmp->db_agl2size;\n\n\t \n\tactfree = bmp->db_nfree - inactfree;\n\tavgfree = (u32) actfree / (u32) actags;\n\n\t \n\tif (bmp->db_agfree[bmp->db_agpref] < avgfree) {\n\t\tfor (bmp->db_agpref = 0; bmp->db_agpref < actags;\n\t\t     bmp->db_agpref++) {\n\t\t\tif (bmp->db_agfree[bmp->db_agpref] >= avgfree)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (bmp->db_agpref >= bmp->db_numag) {\n\t\t\tjfs_error(ipbmap->i_sb,\n\t\t\t\t  \"cannot find ag with average freespace\\n\");\n\t\t}\n\t}\n\n\t \n\tbmp->db_aglevel = BMAPSZTOLEV(bmp->db_agsize);\n\tl2nl =\n\t    bmp->db_agl2size - (L2BPERDMAP + bmp->db_aglevel * L2LPERCTL);\n\tbmp->db_agheight = l2nl >> 1;\n\tbmp->db_agwidth = 1 << (l2nl - (bmp->db_agheight << 1));\n\tfor (i = 5 - bmp->db_agheight, bmp->db_agstart = 0, n = 1; i > 0;\n\t     i--) {\n\t\tbmp->db_agstart += n;\n\t\tn <<= 2;\n\t}\n\n}\n\n\n \nstatic int dbInitDmap(struct dmap * dp, s64 Blkno, int nblocks)\n{\n\tint blkno, w, b, r, nw, nb, i;\n\n\t \n\tblkno = Blkno & (BPERDMAP - 1);\n\n\tif (blkno == 0) {\n\t\tdp->nblocks = dp->nfree = cpu_to_le32(nblocks);\n\t\tdp->start = cpu_to_le64(Blkno);\n\n\t\tif (nblocks == BPERDMAP) {\n\t\t\tmemset(&dp->wmap[0], 0, LPERDMAP * 4);\n\t\t\tmemset(&dp->pmap[0], 0, LPERDMAP * 4);\n\t\t\tgoto initTree;\n\t\t}\n\t} else {\n\t\tle32_add_cpu(&dp->nblocks, nblocks);\n\t\tle32_add_cpu(&dp->nfree, nblocks);\n\t}\n\n\t \n\tw = blkno >> L2DBWORD;\n\n\t \n\tfor (r = nblocks; r > 0; r -= nb, blkno += nb) {\n\t\t \n\t\tb = blkno & (DBWORD - 1);\n\t\t \n\t\tnb = min(r, DBWORD - b);\n\n\t\t \n\t\tif (nb < DBWORD) {\n\t\t\t \n\t\t\tdp->wmap[w] &= cpu_to_le32(~(ONES << (DBWORD - nb)\n\t\t\t\t\t\t     >> b));\n\t\t\tdp->pmap[w] &= cpu_to_le32(~(ONES << (DBWORD - nb)\n\t\t\t\t\t\t     >> b));\n\n\t\t\t \n\t\t\tw++;\n\t\t} else {\n\t\t\t \n\t\t\tnw = r >> L2DBWORD;\n\t\t\tmemset(&dp->wmap[w], 0, nw * 4);\n\t\t\tmemset(&dp->pmap[w], 0, nw * 4);\n\n\t\t\t \n\t\t\tnb = nw << L2DBWORD;\n\t\t\tw += nw;\n\t\t}\n\t}\n\n\t \n\n\tif (blkno == BPERDMAP)\n\t\tgoto initTree;\n\n\t \n\tw = blkno >> L2DBWORD;\n\n\t \n\tb = blkno & (DBWORD - 1);\n\tif (b) {\n\t\t \n\t\tdp->wmap[w] = dp->pmap[w] = cpu_to_le32(ONES >> b);\n\t\tw++;\n\t}\n\n\t \n\tfor (i = w; i < LPERDMAP; i++)\n\t\tdp->pmap[i] = dp->wmap[i] = cpu_to_le32(ONES);\n\n\t \n      initTree:\n\treturn (dbInitDmapTree(dp));\n}\n\n\n \nstatic int dbInitDmapTree(struct dmap * dp)\n{\n\tstruct dmaptree *tp;\n\ts8 *cp;\n\tint i;\n\n\t \n\ttp = &dp->tree;\n\ttp->nleafs = cpu_to_le32(LPERDMAP);\n\ttp->l2nleafs = cpu_to_le32(L2LPERDMAP);\n\ttp->leafidx = cpu_to_le32(LEAFIND);\n\ttp->height = cpu_to_le32(4);\n\ttp->budmin = BUDMIN;\n\n\t \n\tcp = tp->stree + le32_to_cpu(tp->leafidx);\n\tfor (i = 0; i < LPERDMAP; i++)\n\t\t*cp++ = dbMaxBud((u8 *) & dp->wmap[i]);\n\n\t \n\treturn (dbInitTree(tp));\n}\n\n\n \nstatic int dbInitTree(struct dmaptree * dtp)\n{\n\tint l2max, l2free, bsize, nextb, i;\n\tint child, parent, nparent;\n\ts8 *tp, *cp, *cp1;\n\n\ttp = dtp->stree;\n\n\t \n\tl2max = le32_to_cpu(dtp->l2nleafs) + dtp->budmin;\n\n\t \n\tfor (l2free = dtp->budmin, bsize = 1; l2free < l2max;\n\t     l2free++, bsize = nextb) {\n\t\t \n\t\tnextb = bsize << 1;\n\n\t\t \n\t\tfor (i = 0, cp = tp + le32_to_cpu(dtp->leafidx);\n\t\t     i < le32_to_cpu(dtp->nleafs);\n\t\t     i += nextb, cp += nextb) {\n\t\t\t \n\t\t\tif (*cp == l2free && *(cp + bsize) == l2free) {\n\t\t\t\t*cp = l2free + 1;\t \n\t\t\t\t*(cp + bsize) = -1;\t \n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tfor (child = le32_to_cpu(dtp->leafidx),\n\t     nparent = le32_to_cpu(dtp->nleafs) >> 2;\n\t     nparent > 0; nparent >>= 2, child = parent) {\n\t\t \n\t\tparent = (child - 1) >> 2;\n\n\t\t \n\t\tfor (i = 0, cp = tp + child, cp1 = tp + parent;\n\t\t     i < nparent; i++, cp += 4, cp1++)\n\t\t\t*cp1 = TREEMAX(cp);\n\t}\n\n\treturn (*tp);\n}\n\n\n \nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i)\n{\t\t\t\t \n\ts8 *cp;\n\n\tdcp->nleafs = cpu_to_le32(LPERCTL);\n\tdcp->l2nleafs = cpu_to_le32(L2LPERCTL);\n\tdcp->leafidx = cpu_to_le32(CTLLEAFIND);\n\tdcp->height = cpu_to_le32(5);\n\tdcp->budmin = L2BPERDMAP + L2LPERCTL * level;\n\n\t \n\tcp = &dcp->stree[CTLLEAFIND + i];\n\tfor (; i < LPERCTL; i++)\n\t\t*cp++ = NOFREE;\n\n\t \n\treturn (dbInitTree((struct dmaptree *) dcp));\n}\n\n\n \nstatic int dbGetL2AGSize(s64 nblocks)\n{\n\ts64 sz;\n\ts64 m;\n\tint l2sz;\n\n\tif (nblocks < BPERDMAP * MAXAG)\n\t\treturn (L2BPERDMAP);\n\n\t \n\tm = ((u64) 1 << (64 - 1));\n\tfor (l2sz = 64; l2sz >= 0; l2sz--, m >>= 1) {\n\t\tif (m & nblocks)\n\t\t\tbreak;\n\t}\n\n\tsz = (s64) 1 << l2sz;\n\tif (sz < nblocks)\n\t\tl2sz += 1;\n\n\t \n\treturn (l2sz - L2MAXAG);\n}\n\n\n \n\n \n#define MAXL0PAGES\t(1 + LPERCTL)\n#define MAXL1PAGES\t(1 + LPERCTL * MAXL0PAGES)\n\n \n#define BMAPPGTOLEV(npages)\t\\\n\t(((npages) <= 3 + MAXL0PAGES) ? 0 : \\\n\t ((npages) <= 2 + MAXL1PAGES) ? 1 : 2)\n\ns64 dbMapFileSizeToMapSize(struct inode * ipbmap)\n{\n\tstruct super_block *sb = ipbmap->i_sb;\n\ts64 nblocks;\n\ts64 npages, ndmaps;\n\tint level, i;\n\tint complete, factor;\n\n\tnblocks = ipbmap->i_size >> JFS_SBI(sb)->l2bsize;\n\tnpages = nblocks >> JFS_SBI(sb)->l2nbperpage;\n\tlevel = BMAPPGTOLEV(npages);\n\n\t \n\tndmaps = 0;\n\tnpages--;\t\t \n\t \n\tnpages -= (2 - level);\n\tnpages--;\t\t \n\tfor (i = level; i >= 0; i--) {\n\t\tfactor =\n\t\t    (i == 2) ? MAXL1PAGES : ((i == 1) ? MAXL0PAGES : 1);\n\t\tcomplete = (u32) npages / factor;\n\t\tndmaps += complete * ((i == 2) ? LPERCTL * LPERCTL :\n\t\t\t\t      ((i == 1) ? LPERCTL : 1));\n\n\t\t \n\t\tnpages = (u32) npages % factor;\n\t\t \n\t\tnpages--;\n\t}\n\n\t \n\tnblocks = ndmaps << L2BPERDMAP;\n\n\treturn (nblocks);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}