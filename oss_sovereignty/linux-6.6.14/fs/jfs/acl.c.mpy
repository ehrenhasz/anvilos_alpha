{
  "module_name": "acl.c",
  "hash_id": "5040ec84358cd60c709d6d753fe2c087da9741242c20e45c510cf3beb1a2aea3",
  "original_prompt": "Ingested from linux-6.6.14/fs/jfs/acl.c",
  "human_readable_source": "\n \n\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/posix_acl_xattr.h>\n#include \"jfs_incore.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_acl.h\"\n\nstruct posix_acl *jfs_get_acl(struct inode *inode, int type, bool rcu)\n{\n\tstruct posix_acl *acl;\n\tchar *ea_name;\n\tint size;\n\tchar *value = NULL;\n\n\tif (rcu)\n\t\treturn ERR_PTR(-ECHILD);\n\n\tswitch(type) {\n\t\tcase ACL_TYPE_ACCESS:\n\t\t\tea_name = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\t\tbreak;\n\t\tcase ACL_TYPE_DEFAULT:\n\t\t\tea_name = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tsize = __jfs_getxattr(inode, ea_name, NULL, 0);\n\n\tif (size > 0) {\n\t\tvalue = kmalloc(size, GFP_KERNEL);\n\t\tif (!value)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tsize = __jfs_getxattr(inode, ea_name, value, size);\n\t}\n\n\tif (size < 0) {\n\t\tif (size == -ENODATA)\n\t\t\tacl = NULL;\n\t\telse\n\t\t\tacl = ERR_PTR(size);\n\t} else {\n\t\tacl = posix_acl_from_xattr(&init_user_ns, value, size);\n\t}\n\tkfree(value);\n\treturn acl;\n}\n\nstatic int __jfs_set_acl(tid_t tid, struct inode *inode, int type,\n\t\t       struct posix_acl *acl)\n{\n\tchar *ea_name;\n\tint rc;\n\tint size = 0;\n\tchar *value = NULL;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tea_name = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tea_name = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tvalue = kmalloc(size, GFP_KERNEL);\n\t\tif (!value)\n\t\t\treturn -ENOMEM;\n\t\trc = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (rc < 0)\n\t\t\tgoto out;\n\t}\n\trc = __jfs_setxattr(tid, inode, ea_name, value, size, 0);\nout:\n\tkfree(value);\n\n\tif (!rc)\n\t\tset_cached_acl(inode, type, acl);\n\n\treturn rc;\n}\n\nint jfs_set_acl(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\tstruct posix_acl *acl, int type)\n{\n\tint rc;\n\ttid_t tid;\n\tint update_mode = 0;\n\tstruct inode *inode = d_inode(dentry);\n\tumode_t mode = inode->i_mode;\n\n\ttid = txBegin(inode->i_sb, 0);\n\tmutex_lock(&JFS_IP(inode)->commit_mutex);\n\tif (type == ACL_TYPE_ACCESS && acl) {\n\t\trc = posix_acl_update_mode(&nop_mnt_idmap, inode, &mode, &acl);\n\t\tif (rc)\n\t\t\tgoto end_tx;\n\t\tif (mode != inode->i_mode)\n\t\t\tupdate_mode = 1;\n\t}\n\trc = __jfs_set_acl(tid, inode, type, acl);\n\tif (!rc) {\n\t\tif (update_mode) {\n\t\t\tinode->i_mode = mode;\n\t\t\tinode_set_ctime_current(inode);\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t\trc = txCommit(tid, 1, &inode, 0);\n\t}\nend_tx:\n\ttxEnd(tid);\n\tmutex_unlock(&JFS_IP(inode)->commit_mutex);\n\treturn rc;\n}\n\nint jfs_init_acl(tid_t tid, struct inode *inode, struct inode *dir)\n{\n\tstruct posix_acl *default_acl, *acl;\n\tint rc = 0;\n\n\trc = posix_acl_create(dir, &inode->i_mode, &default_acl, &acl);\n\tif (rc)\n\t\treturn rc;\n\n\tif (default_acl) {\n\t\trc = __jfs_set_acl(tid, inode, ACL_TYPE_DEFAULT, default_acl);\n\t\tposix_acl_release(default_acl);\n\t} else {\n\t\tinode->i_default_acl = NULL;\n\t}\n\n\tif (acl) {\n\t\tif (!rc)\n\t\t\trc = __jfs_set_acl(tid, inode, ACL_TYPE_ACCESS, acl);\n\t\tposix_acl_release(acl);\n\t} else {\n\t\tinode->i_acl = NULL;\n\t}\n\n\tJFS_IP(inode)->mode2 = (JFS_IP(inode)->mode2 & 0xffff0000) |\n\t\t\t       inode->i_mode;\n\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}