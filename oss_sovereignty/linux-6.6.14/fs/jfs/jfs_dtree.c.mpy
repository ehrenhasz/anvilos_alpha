{
  "module_name": "jfs_dtree.c",
  "hash_id": "e7619e9eee9bae0c2ea5acb6474319e2f075f9fcea9745c43cec8fb89c4f8160",
  "original_prompt": "Ingested from linux-6.6.14/fs/jfs/jfs_dtree.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/fs.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include \"jfs_incore.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_debug.h\"\n\n \nstruct dtsplit {\n\tstruct metapage *mp;\n\ts16 index;\n\ts16 nslot;\n\tstruct component_name *key;\n\tddata_t *data;\n\tstruct pxdlist *pxdlist;\n};\n\n#define DT_PAGE(IP, MP) BT_PAGE(IP, MP, dtpage_t, i_dtroot)\n\n \n#define DT_GETPAGE(IP, BN, MP, SIZE, P, RC)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tBT_GETPAGE(IP, BN, MP, dtpage_t, SIZE, P, RC, i_dtroot);\t\\\n\tif (!(RC)) {\t\t\t\t\t\t\t\\\n\t\tif (((P)->header.nextindex >\t\t\t\t\\\n\t\t     (((BN) == 0) ? DTROOTMAXSLOT : (P)->header.maxslot)) || \\\n\t\t    ((BN) && ((P)->header.maxslot > DTPAGEMAXSLOT))) {\t\\\n\t\t\tBT_PUTPAGE(MP);\t\t\t\t\t\\\n\t\t\tjfs_error((IP)->i_sb,\t\t\t\t\\\n\t\t\t\t  \"DT_GETPAGE: dtree page corrupt\\n\");\t\\\n\t\t\tMP = NULL;\t\t\t\t\t\\\n\t\t\tRC = -EIO;\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\n \n#define DT_PUTPAGE(MP) BT_PUTPAGE(MP)\n\n#define DT_GETSEARCH(IP, LEAF, BN, MP, P, INDEX) \\\n\tBT_GETSEARCH(IP, LEAF, BN, MP, dtpage_t, P, INDEX, i_dtroot)\n\n \nstatic int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);\n\nstatic int dtSplitPage(tid_t tid, struct inode *ip, struct dtsplit * split,\n\t\t       struct metapage ** rmpp, dtpage_t ** rpp, pxd_t * rxdp);\n\nstatic int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);\n\nstatic int dtSplitRoot(tid_t tid, struct inode *ip,\n\t\t       struct dtsplit * split, struct metapage ** rmpp);\n\nstatic int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);\n\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\n\nstatic int dtReadFirst(struct inode *ip, struct btstack * btstack);\n\nstatic int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);\n\nstatic int dtCompare(struct component_name * key, dtpage_t * p, int si);\n\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\n\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\n\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\n\nstatic void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);\n\nstatic void dtMoveEntry(dtpage_t * sp, int si, dtpage_t * dp,\n\t\t\tstruct dt_lock ** sdtlock, struct dt_lock ** ddtlock,\n\t\t\tint do_index);\n\nstatic void dtDeleteEntry(dtpage_t * p, int fi, struct dt_lock ** dtlock);\n\nstatic void dtTruncateEntry(dtpage_t * p, int ti, struct dt_lock ** dtlock);\n\nstatic void dtLinelockFreelist(dtpage_t * p, int m, struct dt_lock ** dtlock);\n\n#define ciToUpper(c)\tUniStrupr((c)->name)\n\n \nstatic struct metapage *read_index_page(struct inode *inode, s64 blkno)\n{\n\tint rc;\n\ts64 xaddr;\n\tint xflag;\n\ts32 xlen;\n\n\trc = xtLookup(inode, blkno, 1, &xflag, &xaddr, &xlen, 1);\n\tif (rc || (xaddr == 0))\n\t\treturn NULL;\n\n\treturn read_metapage(inode, xaddr, PSIZE, 1);\n}\n\n \nstatic struct metapage *get_index_page(struct inode *inode, s64 blkno)\n{\n\tint rc;\n\ts64 xaddr;\n\tint xflag;\n\ts32 xlen;\n\n\trc = xtLookup(inode, blkno, 1, &xflag, &xaddr, &xlen, 1);\n\tif (rc || (xaddr == 0))\n\t\treturn NULL;\n\n\treturn get_metapage(inode, xaddr, PSIZE, 1);\n}\n\n \nstatic struct dir_table_slot *find_index(struct inode *ip, u32 index,\n\t\t\t\t\t struct metapage ** mp, s64 *lblock)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\ts64 blkno;\n\ts64 offset;\n\tint page_offset;\n\tstruct dir_table_slot *slot;\n\tstatic int maxWarnings = 10;\n\n\tif (index < 2) {\n\t\tif (maxWarnings) {\n\t\t\tjfs_warn(\"find_entry called with index = %d\", index);\n\t\t\tmaxWarnings--;\n\t\t}\n\t\treturn NULL;\n\t}\n\n\tif (index >= jfs_ip->next_index) {\n\t\tjfs_warn(\"find_entry called with index >= next_index\");\n\t\treturn NULL;\n\t}\n\n\tif (jfs_dirtable_inline(ip)) {\n\t\t \n\t\t*mp = NULL;\n\t\tslot = &jfs_ip->i_dirtable[index - 2];\n\t} else {\n\t\toffset = (index - 2) * sizeof(struct dir_table_slot);\n\t\tpage_offset = offset & (PSIZE - 1);\n\t\tblkno = ((offset + 1) >> L2PSIZE) <<\n\t\t    JFS_SBI(ip->i_sb)->l2nbperpage;\n\n\t\tif (*mp && (*lblock != blkno)) {\n\t\t\trelease_metapage(*mp);\n\t\t\t*mp = NULL;\n\t\t}\n\t\tif (!(*mp)) {\n\t\t\t*lblock = blkno;\n\t\t\t*mp = read_index_page(ip, blkno);\n\t\t}\n\t\tif (!(*mp)) {\n\t\t\tjfs_err(\"free_index: error reading directory table\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tslot =\n\t\t    (struct dir_table_slot *) ((char *) (*mp)->data +\n\t\t\t\t\t       page_offset);\n\t}\n\treturn slot;\n}\n\nstatic inline void lock_index(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t\t      u32 index)\n{\n\tstruct tlock *tlck;\n\tstruct linelock *llck;\n\tstruct lv *lv;\n\n\ttlck = txLock(tid, ip, mp, tlckDATA);\n\tllck = (struct linelock *) tlck->lock;\n\n\tif (llck->index >= llck->maxcnt)\n\t\tllck = txLinelock(llck);\n\tlv = &llck->lv[llck->index];\n\n\t \n\tlv->offset = ((index - 2) & 511) >> 1;\n\tlv->length = 1;\n\tllck->index++;\n}\n\n \nstatic u32 add_index(tid_t tid, struct inode *ip, s64 bn, int slot)\n{\n\tstruct super_block *sb = ip->i_sb;\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tu64 blkno;\n\tstruct dir_table_slot *dirtab_slot;\n\tu32 index;\n\tstruct linelock *llck;\n\tstruct lv *lv;\n\tstruct metapage *mp;\n\ts64 offset;\n\tuint page_offset;\n\tstruct tlock *tlck;\n\ts64 xaddr;\n\n\tASSERT(DO_INDEX(ip));\n\n\tif (jfs_ip->next_index < 2) {\n\t\tjfs_warn(\"add_index: next_index = %d.  Resetting!\",\n\t\t\t   jfs_ip->next_index);\n\t\tjfs_ip->next_index = 2;\n\t}\n\n\tindex = jfs_ip->next_index++;\n\n\tif (index <= MAX_INLINE_DIRTABLE_ENTRY) {\n\t\t \n\t\tip->i_size = (loff_t) (index - 1) << 3;\n\n\t\t \n\t\tdirtab_slot = &jfs_ip->i_dirtable[index-2];\n\t\tdirtab_slot->flag = DIR_INDEX_VALID;\n\t\tdirtab_slot->slot = slot;\n\t\tDTSaddress(dirtab_slot, bn);\n\n\t\tset_cflag(COMMIT_Dirtable, ip);\n\n\t\treturn index;\n\t}\n\tif (index == (MAX_INLINE_DIRTABLE_ENTRY + 1)) {\n\t\tstruct dir_table_slot temp_table[12];\n\n\t\t \n\t\tif (dquot_alloc_block(ip, sbi->nbperpage))\n\t\t\tgoto clean_up;\n\t\tif (dbAlloc(ip, 0, sbi->nbperpage, &xaddr)) {\n\t\t\tdquot_free_block(ip, sbi->nbperpage);\n\t\t\tgoto clean_up;\n\t\t}\n\n\t\t \n\t\tmemcpy(temp_table, &jfs_ip->i_dirtable, sizeof(temp_table));\n\n\t\t \n\t\txtInitRoot(tid, ip);\n\n\t\t \n\t\tif (xtInsert(tid, ip, 0, 0, sbi->nbperpage, &xaddr, 0)) {\n\t\t\t \n\t\t\tjfs_warn(\"add_index: xtInsert failed!\");\n\t\t\tmemcpy(&jfs_ip->i_dirtable, temp_table,\n\t\t\t       sizeof (temp_table));\n\t\t\tdbFree(ip, xaddr, sbi->nbperpage);\n\t\t\tdquot_free_block(ip, sbi->nbperpage);\n\t\t\tgoto clean_up;\n\t\t}\n\t\tip->i_size = PSIZE;\n\n\t\tmp = get_index_page(ip, 0);\n\t\tif (!mp) {\n\t\t\tjfs_err(\"add_index: get_metapage failed!\");\n\t\t\txtTruncate(tid, ip, 0, COMMIT_PWMAP);\n\t\t\tmemcpy(&jfs_ip->i_dirtable, temp_table,\n\t\t\t       sizeof (temp_table));\n\t\t\tgoto clean_up;\n\t\t}\n\t\ttlck = txLock(tid, ip, mp, tlckDATA);\n\t\tllck = (struct linelock *) & tlck->lock;\n\t\tASSERT(llck->index == 0);\n\t\tlv = &llck->lv[0];\n\n\t\tlv->offset = 0;\n\t\tlv->length = 6;\t \n\t\tllck->index++;\n\n\t\tmemcpy(mp->data, temp_table, sizeof(temp_table));\n\n\t\tmark_metapage_dirty(mp);\n\t\trelease_metapage(mp);\n\n\t\t \n\t\tclear_cflag(COMMIT_Dirtable, ip);\n\t}\n\n\toffset = (index - 2) * sizeof(struct dir_table_slot);\n\tpage_offset = offset & (PSIZE - 1);\n\tblkno = ((offset + 1) >> L2PSIZE) << sbi->l2nbperpage;\n\tif (page_offset == 0) {\n\t\t \n\t\txaddr = 0;\n\t\tif (xtInsert(tid, ip, 0, blkno, sbi->nbperpage, &xaddr, 0)) {\n\t\t\tjfs_warn(\"add_index: xtInsert failed!\");\n\t\t\tgoto clean_up;\n\t\t}\n\t\tip->i_size += PSIZE;\n\n\t\tif ((mp = get_index_page(ip, blkno)))\n\t\t\tmemset(mp->data, 0, PSIZE);\t \n\t\telse\n\t\t\txtTruncate(tid, ip, offset, COMMIT_PWMAP);\n\t} else\n\t\tmp = read_index_page(ip, blkno);\n\n\tif (!mp) {\n\t\tjfs_err(\"add_index: get/read_metapage failed!\");\n\t\tgoto clean_up;\n\t}\n\n\tlock_index(tid, ip, mp, index);\n\n\tdirtab_slot =\n\t    (struct dir_table_slot *) ((char *) mp->data + page_offset);\n\tdirtab_slot->flag = DIR_INDEX_VALID;\n\tdirtab_slot->slot = slot;\n\tDTSaddress(dirtab_slot, bn);\n\n\tmark_metapage_dirty(mp);\n\trelease_metapage(mp);\n\n\treturn index;\n\n      clean_up:\n\n\tjfs_ip->next_index--;\n\n\treturn 0;\n}\n\n \nstatic void free_index(tid_t tid, struct inode *ip, u32 index, u32 next)\n{\n\tstruct dir_table_slot *dirtab_slot;\n\ts64 lblock;\n\tstruct metapage *mp = NULL;\n\n\tdirtab_slot = find_index(ip, index, &mp, &lblock);\n\n\tif (!dirtab_slot)\n\t\treturn;\n\n\tdirtab_slot->flag = DIR_INDEX_FREE;\n\tdirtab_slot->slot = dirtab_slot->addr1 = 0;\n\tdirtab_slot->addr2 = cpu_to_le32(next);\n\n\tif (mp) {\n\t\tlock_index(tid, ip, mp, index);\n\t\tmark_metapage_dirty(mp);\n\t\trelease_metapage(mp);\n\t} else\n\t\tset_cflag(COMMIT_Dirtable, ip);\n}\n\n \nstatic void modify_index(tid_t tid, struct inode *ip, u32 index, s64 bn,\n\t\t\t int slot, struct metapage ** mp, s64 *lblock)\n{\n\tstruct dir_table_slot *dirtab_slot;\n\n\tdirtab_slot = find_index(ip, index, mp, lblock);\n\n\tif (!dirtab_slot)\n\t\treturn;\n\n\tDTSaddress(dirtab_slot, bn);\n\tdirtab_slot->slot = slot;\n\n\tif (*mp) {\n\t\tlock_index(tid, ip, *mp, index);\n\t\tmark_metapage_dirty(*mp);\n\t} else\n\t\tset_cflag(COMMIT_Dirtable, ip);\n}\n\n \nstatic int read_index(struct inode *ip, u32 index,\n\t\t     struct dir_table_slot * dirtab_slot)\n{\n\ts64 lblock;\n\tstruct metapage *mp = NULL;\n\tstruct dir_table_slot *slot;\n\n\tslot = find_index(ip, index, &mp, &lblock);\n\tif (!slot) {\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(dirtab_slot, slot, sizeof(struct dir_table_slot));\n\n\tif (mp)\n\t\trelease_metapage(mp);\n\n\treturn 0;\n}\n\n \nint dtSearch(struct inode *ip, struct component_name * key, ino_t * data,\n\t     struct btstack * btstack, int flag)\n{\n\tint rc = 0;\n\tint cmp = 1;\t\t \n\ts64 bn;\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\ts8 *stbl;\n\tint base, index, lim;\n\tstruct btframe *btsp;\n\tpxd_t *pxd;\n\tint psize = 288;\t \n\tino_t inumber;\n\tstruct component_name ciKey;\n\tstruct super_block *sb = ip->i_sb;\n\n\tciKey.name = kmalloc_array(JFS_NAME_MAX + 1, sizeof(wchar_t),\n\t\t\t\t   GFP_NOFS);\n\tif (!ciKey.name) {\n\t\trc = -ENOMEM;\n\t\tgoto dtSearch_Exit2;\n\t}\n\n\n\t \n\tUniStrcpy(ciKey.name, key->name);\n\tciKey.namlen = key->namlen;\n\n\t \n\tif ((JFS_SBI(sb)->mntflag & JFS_OS2) == JFS_OS2) {\n\t\tciToUpper(&ciKey);\n\t}\n\tBT_CLR(btstack);\t \n\n\t \n\tbtstack->nsplit = 1;\n\n\t \n\tfor (bn = 0;;) {\n\t\t \n\t\tDT_GETPAGE(ip, bn, mp, psize, p, rc);\n\t\tif (rc)\n\t\t\tgoto dtSearch_Exit1;\n\n\t\t \n\t\tstbl = DT_GETSTBL(p);\n\n\t\t \n\t\tfor (base = 0, lim = p->header.nextindex; lim; lim >>= 1) {\n\t\t\tindex = base + (lim >> 1);\n\n\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t \n\t\t\t\tcmp =\n\t\t\t\t    ciCompare(&ciKey, p, stbl[index],\n\t\t\t\t\t      JFS_SBI(sb)->mntflag);\n\t\t\t} else {\n\t\t\t\t \n\n\t\t\t\tcmp = dtCompare(&ciKey, p, stbl[index]);\n\n\n\t\t\t}\n\t\t\tif (cmp == 0) {\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t\tinumber = le32_to_cpu(\n\t\t\t((struct ldtentry *) & p->slot[stbl[index]])->inumber);\n\n\t\t\t\t\t \n\t\t\t\t\tif (flag == JFS_LOOKUP) {\n\t\t\t\t\t\t*data = inumber;\n\t\t\t\t\t\trc = 0;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t \n\t\t\t\t\tif (flag == JFS_CREATE) {\n\t\t\t\t\t\t*data = inumber;\n\t\t\t\t\t\trc = -EEXIST;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t \n\t\t\t\t\tif ((flag == JFS_REMOVE ||\n\t\t\t\t\t     flag == JFS_RENAME) &&\n\t\t\t\t\t    *data != inumber) {\n\t\t\t\t\t\trc = -ESTALE;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t \n\t\t\t\t\t \n\t\t\t\t\t*data = inumber;\n\t\t\t\t\tbtsp = btstack->top;\n\t\t\t\t\tbtsp->bn = bn;\n\t\t\t\t\tbtsp->index = index;\n\t\t\t\t\tbtsp->mp = mp;\n\n\t\t\t\t\trc = 0;\n\t\t\t\t\tgoto dtSearch_Exit1;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tgoto getChild;\n\t\t\t}\n\n\t\t\tif (cmp > 0) {\n\t\t\t\tbase = index + 1;\n\t\t\t\t--lim;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\t \n\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t \n\t\t\tif (flag == JFS_LOOKUP || flag == JFS_REMOVE ||\n\t\t\t    flag == JFS_RENAME) {\n\t\t\t\trc = -ENOENT;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t \n\t\t\t*data = 0;\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = base;\n\t\t\tbtsp->mp = mp;\n\n\t\t\trc = 0;\n\t\t\tgoto dtSearch_Exit1;\n\t\t}\n\n\t\t \n\t\tindex = base ? base - 1 : base;\n\n\t\t \n\t      getChild:\n\t\t \n\t\tif (BT_STACK_FULL(btstack)) {\n\t\t\t \n\t\t\tjfs_error(sb, \"stack overrun!\\n\");\n\t\t\tBT_STACK_DUMP(btstack);\n\t\t\trc = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tbtstack->nsplit++;\n\n\t\t \n\t\tBT_PUSH(btstack, bn, index);\n\n\t\t \n\t\tpxd = (pxd_t *) & p->slot[stbl[index]];\n\t\tbn = addressPXD(pxd);\n\t\tpsize = lengthPXD(pxd) << JFS_SBI(ip->i_sb)->l2bsize;\n\n\t\t \n\t\tDT_PUTPAGE(mp);\n\t}\n\n      out:\n\tDT_PUTPAGE(mp);\n\n      dtSearch_Exit1:\n\n\tkfree(ciKey.name);\n\n      dtSearch_Exit2:\n\n\treturn rc;\n}\n\n\n \nint dtInsert(tid_t tid, struct inode *ip,\n\t struct component_name * name, ino_t * fsn, struct btstack * btstack)\n{\n\tint rc = 0;\n\tstruct metapage *mp;\t \n\tdtpage_t *p;\t\t \n\ts64 bn;\n\tint index;\n\tstruct dtsplit split;\t \n\tddata_t data;\n\tstruct dt_lock *dtlck;\n\tint n;\n\tstruct tlock *tlck;\n\tstruct lv *lv;\n\n\t \n\tDT_GETSEARCH(ip, btstack->top, bn, mp, p, index);\n\n\t \n\tif (DO_INDEX(ip)) {\n\t\tif (JFS_IP(ip)->next_index == DIREND) {\n\t\t\tDT_PUTPAGE(mp);\n\t\t\treturn -EMLINK;\n\t\t}\n\t\tn = NDTLEAF(name->namlen);\n\t\tdata.leaf.tid = tid;\n\t\tdata.leaf.ip = ip;\n\t} else {\n\t\tn = NDTLEAF_LEGACY(name->namlen);\n\t\tdata.leaf.ip = NULL;\t \n\t}\n\tdata.leaf.ino = *fsn;\n\n\t \n\tif (n > p->header.freecnt) {\n\t\tsplit.mp = mp;\n\t\tsplit.index = index;\n\t\tsplit.nslot = n;\n\t\tsplit.key = name;\n\t\tsplit.data = &data;\n\t\trc = dtSplitUp(tid, ip, &split, btstack);\n\t\treturn rc;\n\t}\n\n\t \n\tBT_MARK_DIRTY(mp, ip);\n\t \n\ttlck = txLock(tid, ip, mp, tlckDTREE | tlckENTRY);\n\tdtlck = (struct dt_lock *) & tlck->lock;\n\tASSERT(dtlck->index == 0);\n\tlv = & dtlck->lv[0];\n\n\t \n\tlv->offset = 0;\n\tlv->length = 1;\n\tdtlck->index++;\n\n\tdtInsertEntry(p, index, name, &data, &dtlck);\n\n\t \n\tif (!(p->header.flag & BT_ROOT)) {\n\t\tif (dtlck->index >= dtlck->maxcnt)\n\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\tlv = & dtlck->lv[dtlck->index];\n\t\tn = index >> L2DTSLOTSIZE;\n\t\tlv->offset = p->header.stblindex + n;\n\t\tlv->length =\n\t\t    ((p->header.nextindex - 1) >> L2DTSLOTSIZE) - n + 1;\n\t\tdtlck->index++;\n\t}\n\n\t \n\tDT_PUTPAGE(mp);\n\n\treturn 0;\n}\n\n\n \nstatic int dtSplitUp(tid_t tid,\n\t  struct inode *ip, struct dtsplit * split, struct btstack * btstack)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\n\tint rc = 0;\n\tstruct metapage *smp;\n\tdtpage_t *sp;\t\t \n\tstruct metapage *rmp;\n\tdtpage_t *rp;\t\t \n\tpxd_t rpxd;\t\t \n\tstruct metapage *lmp;\n\tdtpage_t *lp;\t\t \n\tint skip;\t\t \n\tstruct btframe *parent;\t \n\ts64 xaddr, nxaddr;\n\tint xlen, xsize;\n\tstruct pxdlist pxdlist;\n\tpxd_t *pxd;\n\tstruct component_name key = { 0, NULL };\n\tddata_t *data = split->data;\n\tint n;\n\tstruct dt_lock *dtlck;\n\tstruct tlock *tlck;\n\tstruct lv *lv;\n\tint quota_allocation = 0;\n\n\t \n\tsmp = split->mp;\n\tsp = DT_PAGE(ip, smp);\n\n\tkey.name = kmalloc_array(JFS_NAME_MAX + 2, sizeof(wchar_t), GFP_NOFS);\n\tif (!key.name) {\n\t\tDT_PUTPAGE(smp);\n\t\trc = -ENOMEM;\n\t\tgoto dtSplitUp_Exit;\n\t}\n\n\t \n\t \n\tif (sp->header.flag & BT_ROOT) {\n\t\t \n\t\txlen = 1;\n\t\tn = sbi->bsize >> L2DTSLOTSIZE;\n\t\tn -= (n + 31) >> L2DTSLOTSIZE;\t \n\t\tn -= DTROOTMAXSLOT - sp->header.freecnt;  \n\t\tif (n <= split->nslot)\n\t\t\txlen++;\n\t\tif ((rc = dbAlloc(ip, 0, (s64) xlen, &xaddr))) {\n\t\t\tDT_PUTPAGE(smp);\n\t\t\tgoto freeKeyName;\n\t\t}\n\n\t\tpxdlist.maxnpxd = 1;\n\t\tpxdlist.npxd = 0;\n\t\tpxd = &pxdlist.pxd[0];\n\t\tPXDaddress(pxd, xaddr);\n\t\tPXDlength(pxd, xlen);\n\t\tsplit->pxdlist = &pxdlist;\n\t\trc = dtSplitRoot(tid, ip, split, &rmp);\n\n\t\tif (rc)\n\t\t\tdbFree(ip, xaddr, xlen);\n\t\telse\n\t\t\tDT_PUTPAGE(rmp);\n\n\t\tDT_PUTPAGE(smp);\n\n\t\tif (!DO_INDEX(ip))\n\t\t\tip->i_size = xlen << sbi->l2bsize;\n\n\t\tgoto freeKeyName;\n\t}\n\n\t \n\tpxd = &sp->header.self;\n\txlen = lengthPXD(pxd);\n\txsize = xlen << sbi->l2bsize;\n\tif (xsize < PSIZE) {\n\t\txaddr = addressPXD(pxd);\n\t\tn = xsize >> L2DTSLOTSIZE;\n\t\tn -= (n + 31) >> L2DTSLOTSIZE;\t \n\t\tif ((n + sp->header.freecnt) <= split->nslot)\n\t\t\tn = xlen + (xlen << 1);\n\t\telse\n\t\t\tn = xlen;\n\n\t\t \n\t\trc = dquot_alloc_block(ip, n);\n\t\tif (rc)\n\t\t\tgoto extendOut;\n\t\tquota_allocation += n;\n\n\t\tif ((rc = dbReAlloc(sbi->ipbmap, xaddr, (s64) xlen,\n\t\t\t\t    (s64) n, &nxaddr)))\n\t\t\tgoto extendOut;\n\n\t\tpxdlist.maxnpxd = 1;\n\t\tpxdlist.npxd = 0;\n\t\tpxd = &pxdlist.pxd[0];\n\t\tPXDaddress(pxd, nxaddr);\n\t\tPXDlength(pxd, xlen + n);\n\t\tsplit->pxdlist = &pxdlist;\n\t\tif ((rc = dtExtendPage(tid, ip, split, btstack))) {\n\t\t\tnxaddr = addressPXD(pxd);\n\t\t\tif (xaddr != nxaddr) {\n\t\t\t\t \n\t\t\t\txlen = lengthPXD(pxd);\n\t\t\t\tdbFree(ip, nxaddr, (s64) xlen);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\txlen = lengthPXD(pxd) - n;\n\t\t\t\txaddr = addressPXD(pxd) + xlen;\n\t\t\t\tdbFree(ip, xaddr, (s64) n);\n\t\t\t}\n\t\t} else if (!DO_INDEX(ip))\n\t\t\tip->i_size = lengthPXD(pxd) << sbi->l2bsize;\n\n\n\t      extendOut:\n\t\tDT_PUTPAGE(smp);\n\t\tgoto freeKeyName;\n\t}\n\n\t \n\t \n\tn = btstack->nsplit;\n\tpxdlist.maxnpxd = pxdlist.npxd = 0;\n\txlen = sbi->nbperpage;\n\tfor (pxd = pxdlist.pxd; n > 0; n--, pxd++) {\n\t\tif ((rc = dbAlloc(ip, 0, (s64) xlen, &xaddr)) == 0) {\n\t\t\tPXDaddress(pxd, xaddr);\n\t\t\tPXDlength(pxd, xlen);\n\t\t\tpxdlist.maxnpxd++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tDT_PUTPAGE(smp);\n\n\t\t \n\t\tgoto splitOut;\n\t}\n\n\tsplit->pxdlist = &pxdlist;\n\tif ((rc = dtSplitPage(tid, ip, split, &rmp, &rp, &rpxd))) {\n\t\tDT_PUTPAGE(smp);\n\n\t\t \n\t\tgoto splitOut;\n\t}\n\n\tif (!DO_INDEX(ip))\n\t\tip->i_size += PSIZE;\n\n\t \n\twhile ((parent = BT_POP(btstack)) != NULL) {\n\t\t \n\n\t\t \n\t\tlmp = smp;\n\t\tlp = sp;\n\n\t\t \n\t\t \n\t\tDT_GETPAGE(ip, parent->bn, smp, PSIZE, sp, rc);\n\t\tif (rc) {\n\t\t\tDT_PUTPAGE(lmp);\n\t\t\tDT_PUTPAGE(rmp);\n\t\t\tgoto splitOut;\n\t\t}\n\n\t\t \n\t\tskip = parent->index + 1;\n\n\t\t \n\t\tswitch (rp->header.flag & BT_TYPE) {\n\t\tcase BT_LEAF:\n\t\t\t \n\t\t\tif ((sp->header.flag & BT_ROOT && skip > 1) ||\n\t\t\t    sp->header.prev != 0 || skip > 1) {\n\t\t\t\t \n\t\t\t\trc = ciGetLeafPrefixKey(lp,\n\t\t\t\t\t\t\tlp->header.nextindex-1,\n\t\t\t\t\t\t\trp, 0, &key,\n\t\t\t\t\t\t\tsbi->mntflag);\n\t\t\t\tif (rc) {\n\t\t\t\t\tDT_PUTPAGE(lmp);\n\t\t\t\t\tDT_PUTPAGE(rmp);\n\t\t\t\t\tDT_PUTPAGE(smp);\n\t\t\t\t\tgoto splitOut;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t \n\n\t\t\t\t \n\t\t\t\tdtGetKey(rp, 0, &key, sbi->mntflag);\n\t\t\t\tkey.name[key.namlen] = 0;\n\n\t\t\t\tif ((sbi->mntflag & JFS_OS2) == JFS_OS2)\n\t\t\t\t\tciToUpper(&key);\n\t\t\t}\n\n\t\t\tn = NDTINTERNAL(key.namlen);\n\t\t\tbreak;\n\n\t\tcase BT_INTERNAL:\n\t\t\tdtGetKey(rp, 0, &key, sbi->mntflag);\n\t\t\tn = NDTINTERNAL(key.namlen);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tjfs_err(\"dtSplitUp(): UFO!\");\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tDT_PUTPAGE(lmp);\n\n\t\t \n\t\tdata->xd = rpxd;\t \n\n\t\t \n\t\tif (n > sp->header.freecnt) {\n\t\t\t \n\t\t\tsplit->mp = smp;\n\t\t\tsplit->index = skip;\t \n\t\t\tsplit->nslot = n;\n\t\t\tsplit->key = &key;\n\t\t\t \n\n\t\t\t \n\t\t\tDT_PUTPAGE(rmp);\n\n\t\t\t \n\t\t\trc = (sp->header.flag & BT_ROOT) ?\n\t\t\t    dtSplitRoot(tid, ip, split, &rmp) :\n\t\t\t    dtSplitPage(tid, ip, split, &rmp, &rp, &rpxd);\n\t\t\tif (rc) {\n\t\t\t\tDT_PUTPAGE(smp);\n\t\t\t\tgoto splitOut;\n\t\t\t}\n\n\t\t\t \n\t\t}\n\t\t \n\t\telse {\n\t\t\tBT_MARK_DIRTY(smp, ip);\n\t\t\t \n\t\t\ttlck = txLock(tid, ip, smp, tlckDTREE | tlckENTRY);\n\t\t\tdtlck = (struct dt_lock *) & tlck->lock;\n\t\t\tASSERT(dtlck->index == 0);\n\t\t\tlv = & dtlck->lv[0];\n\n\t\t\t \n\t\t\tlv->offset = 0;\n\t\t\tlv->length = 1;\n\t\t\tdtlck->index++;\n\n\t\t\t \n\t\t\tif (!(sp->header.flag & BT_ROOT)) {\n\t\t\t\tlv++;\n\t\t\t\tn = skip >> L2DTSLOTSIZE;\n\t\t\t\tlv->offset = sp->header.stblindex + n;\n\t\t\t\tlv->length =\n\t\t\t\t    ((sp->header.nextindex -\n\t\t\t\t      1) >> L2DTSLOTSIZE) - n + 1;\n\t\t\t\tdtlck->index++;\n\t\t\t}\n\n\t\t\tdtInsertEntry(sp, skip, &key, data, &dtlck);\n\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tDT_PUTPAGE(smp);\n\tDT_PUTPAGE(rmp);\n\n\t \n      splitOut:\n\tn = pxdlist.npxd;\n\tpxd = &pxdlist.pxd[n];\n\tfor (; n < pxdlist.maxnpxd; n++, pxd++)\n\t\tdbFree(ip, addressPXD(pxd), (s64) lengthPXD(pxd));\n\n      freeKeyName:\n\tkfree(key.name);\n\n\t \n\tif (rc && quota_allocation)\n\t\tdquot_free_block(ip, quota_allocation);\n\n      dtSplitUp_Exit:\n\n\treturn rc;\n}\n\n\n \nstatic int dtSplitPage(tid_t tid, struct inode *ip, struct dtsplit * split,\n\t    struct metapage ** rmpp, dtpage_t ** rpp, pxd_t * rpxdp)\n{\n\tint rc = 0;\n\tstruct metapage *smp;\n\tdtpage_t *sp;\n\tstruct metapage *rmp;\n\tdtpage_t *rp;\t\t \n\ts64 rbn;\t\t \n\tstruct metapage *mp;\n\tdtpage_t *p;\n\ts64 nextbn;\n\tstruct pxdlist *pxdlist;\n\tpxd_t *pxd;\n\tint skip, nextindex, half, left, nxt, off, si;\n\tstruct ldtentry *ldtentry;\n\tstruct idtentry *idtentry;\n\tu8 *stbl;\n\tstruct dtslot *f;\n\tint fsi, stblsize;\n\tint n;\n\tstruct dt_lock *sdtlck, *rdtlck;\n\tstruct tlock *tlck;\n\tstruct dt_lock *dtlck;\n\tstruct lv *slv, *rlv, *lv;\n\n\t \n\tsmp = split->mp;\n\tsp = DT_PAGE(ip, smp);\n\n\t \n\tpxdlist = split->pxdlist;\n\tpxd = &pxdlist->pxd[pxdlist->npxd];\n\tpxdlist->npxd++;\n\trbn = addressPXD(pxd);\n\trmp = get_metapage(ip, rbn, PSIZE, 1);\n\tif (rmp == NULL)\n\t\treturn -EIO;\n\n\t \n\trc = dquot_alloc_block(ip, lengthPXD(pxd));\n\tif (rc) {\n\t\trelease_metapage(rmp);\n\t\treturn rc;\n\t}\n\n\tjfs_info(\"dtSplitPage: ip:0x%p smp:0x%p rmp:0x%p\", ip, smp, rmp);\n\n\tBT_MARK_DIRTY(rmp, ip);\n\t \n\ttlck = txLock(tid, ip, rmp, tlckDTREE | tlckNEW);\n\trdtlck = (struct dt_lock *) & tlck->lock;\n\n\trp = (dtpage_t *) rmp->data;\n\t*rpp = rp;\n\trp->header.self = *pxd;\n\n\tBT_MARK_DIRTY(smp, ip);\n\t \n\ttlck = txLock(tid, ip, smp, tlckDTREE | tlckENTRY);\n\tsdtlck = (struct dt_lock *) & tlck->lock;\n\n\t \n\tASSERT(sdtlck->index == 0);\n\tslv = & sdtlck->lv[0];\n\tslv->offset = 0;\n\tslv->length = 1;\n\tsdtlck->index++;\n\n\t \n\tnextbn = le64_to_cpu(sp->header.next);\n\trp->header.next = cpu_to_le64(nextbn);\n\trp->header.prev = cpu_to_le64(addressPXD(&sp->header.self));\n\tsp->header.next = cpu_to_le64(rbn);\n\n\t \n\trp->header.flag = sp->header.flag;\n\n\t \n\trp->header.nextindex = 0;\n\trp->header.stblindex = 1;\n\n\tn = PSIZE >> L2DTSLOTSIZE;\n\trp->header.maxslot = n;\n\tstblsize = (n + 31) >> L2DTSLOTSIZE;\t \n\n\t \n\tfsi = rp->header.stblindex + stblsize;\n\trp->header.freelist = fsi;\n\trp->header.freecnt = rp->header.maxslot - fsi;\n\n\t \n\tif (nextbn == 0 && split->index == sp->header.nextindex) {\n\t\t \n\t\trlv = & rdtlck->lv[rdtlck->index];\n\t\trlv->offset = 0;\n\t\trlv->length = 2;\n\t\trdtlck->index++;\n\n\t\t \n\t\tf = &rp->slot[fsi];\n\t\tfor (fsi++; fsi < rp->header.maxslot; f++, fsi++)\n\t\t\tf->next = fsi;\n\t\tf->next = -1;\n\n\t\t \n\t\tdtInsertEntry(rp, 0, split->key, split->data, &rdtlck);\n\n\t\tgoto out;\n\t}\n\n\t \n\n\t \n\tif (nextbn != 0) {\n\t\tDT_GETPAGE(ip, nextbn, mp, PSIZE, p, rc);\n\t\tif (rc) {\n\t\t\tdiscard_metapage(rmp);\n\t\t\treturn rc;\n\t\t}\n\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\t \n\t\ttlck = txLock(tid, ip, mp, tlckDTREE | tlckRELINK);\n\t\tjfs_info(\"dtSplitPage: tlck = 0x%p, ip = 0x%p, mp=0x%p\",\n\t\t\ttlck, ip, mp);\n\t\tdtlck = (struct dt_lock *) & tlck->lock;\n\n\t\t \n\t\tlv = & dtlck->lv[dtlck->index];\n\t\tlv->offset = 0;\n\t\tlv->length = 1;\n\t\tdtlck->index++;\n\n\t\tp->header.prev = cpu_to_le64(rbn);\n\n\t\tDT_PUTPAGE(mp);\n\t}\n\n\t \n\tskip = split->index;\n\thalf = (PSIZE >> L2DTSLOTSIZE) >> 1;\t \n\tleft = 0;\n\n\t \n\tstbl = (u8 *) & sp->slot[sp->header.stblindex];\n\tnextindex = sp->header.nextindex;\n\tfor (nxt = off = 0; nxt < nextindex; ++off) {\n\t\tif (off == skip)\n\t\t\t \n\t\t\tn = split->nslot;\n\t\telse {\n\t\t\tsi = stbl[nxt];\n\t\t\tswitch (sp->header.flag & BT_TYPE) {\n\t\t\tcase BT_LEAF:\n\t\t\t\tldtentry = (struct ldtentry *) & sp->slot[si];\n\t\t\t\tif (DO_INDEX(ip))\n\t\t\t\t\tn = NDTLEAF(ldtentry->namlen);\n\t\t\t\telse\n\t\t\t\t\tn = NDTLEAF_LEGACY(ldtentry->\n\t\t\t\t\t\t\t   namlen);\n\t\t\t\tbreak;\n\n\t\t\tcase BT_INTERNAL:\n\t\t\t\tidtentry = (struct idtentry *) & sp->slot[si];\n\t\t\t\tn = NDTINTERNAL(idtentry->namlen);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t++nxt;\t \n\t\t}\n\n\t\tleft += n;\n\t\tif (left >= half)\n\t\t\tbreak;\n\t}\n\n\t \n\n\t \n\t \n\trlv = & rdtlck->lv[rdtlck->index];\n\trlv->offset = 0;\n\trlv->length = 5;\n\trdtlck->index++;\n\n\tdtMoveEntry(sp, nxt, rp, &sdtlck, &rdtlck, DO_INDEX(ip));\n\n\tsp->header.nextindex = nxt;\n\n\t \n\tfsi = rp->header.freelist;\n\tf = &rp->slot[fsi];\n\tfor (fsi++; fsi < rp->header.maxslot; f++, fsi++)\n\t\tf->next = fsi;\n\tf->next = -1;\n\n\t \n\tif ((rp->header.flag & BT_LEAF) && DO_INDEX(ip)) {\n\t\ts64 lblock;\n\n\t\tmp = NULL;\n\t\tstbl = DT_GETSTBL(rp);\n\t\tfor (n = 0; n < rp->header.nextindex; n++) {\n\t\t\tldtentry = (struct ldtentry *) & rp->slot[stbl[n]];\n\t\t\tmodify_index(tid, ip, le32_to_cpu(ldtentry->index),\n\t\t\t\t     rbn, n, &mp, &lblock);\n\t\t}\n\t\tif (mp)\n\t\t\trelease_metapage(mp);\n\t}\n\n\t \n\tif (skip <= off) {\n\t\t \n\t\tdtInsertEntry(sp, skip, split->key, split->data, &sdtlck);\n\n\t\t \n\t\tif (sdtlck->index >= sdtlck->maxcnt)\n\t\t\tsdtlck = (struct dt_lock *) txLinelock(sdtlck);\n\t\tslv = & sdtlck->lv[sdtlck->index];\n\t\tn = skip >> L2DTSLOTSIZE;\n\t\tslv->offset = sp->header.stblindex + n;\n\t\tslv->length =\n\t\t    ((sp->header.nextindex - 1) >> L2DTSLOTSIZE) - n + 1;\n\t\tsdtlck->index++;\n\t}\n\t \n\telse {\n\t\t \n\t\tskip -= nxt;\n\n\t\t \n\t\tdtInsertEntry(rp, skip, split->key, split->data, &rdtlck);\n\t}\n\n      out:\n\t*rmpp = rmp;\n\t*rpxdp = *pxd;\n\n\treturn rc;\n}\n\n\n \nstatic int dtExtendPage(tid_t tid,\n\t     struct inode *ip, struct dtsplit * split, struct btstack * btstack)\n{\n\tstruct super_block *sb = ip->i_sb;\n\tint rc;\n\tstruct metapage *smp, *pmp, *mp;\n\tdtpage_t *sp, *pp;\n\tstruct pxdlist *pxdlist;\n\tpxd_t *pxd, *tpxd;\n\tint xlen, xsize;\n\tint newstblindex, newstblsize;\n\tint oldstblindex, oldstblsize;\n\tint fsi, last;\n\tstruct dtslot *f;\n\tstruct btframe *parent;\n\tint n;\n\tstruct dt_lock *dtlck;\n\ts64 xaddr, txaddr;\n\tstruct tlock *tlck;\n\tstruct pxd_lock *pxdlock;\n\tstruct lv *lv;\n\tuint type;\n\tstruct ldtentry *ldtentry;\n\tu8 *stbl;\n\n\t \n\tsmp = split->mp;\n\tsp = DT_PAGE(ip, smp);\n\n\t \n\tparent = BT_POP(btstack);\n\tDT_GETPAGE(ip, parent->bn, pmp, PSIZE, pp, rc);\n\tif (rc)\n\t\treturn (rc);\n\n\t \n\tpxdlist = split->pxdlist;\n\tpxd = &pxdlist->pxd[pxdlist->npxd];\n\tpxdlist->npxd++;\n\n\txaddr = addressPXD(pxd);\n\ttpxd = &sp->header.self;\n\ttxaddr = addressPXD(tpxd);\n\t \n\tif (xaddr == txaddr) {\n\t\ttype = tlckEXTEND;\n\t}\n\t \n\telse {\n\t\ttype = tlckNEW;\n\n\t\t \n\t\ttlck = txMaplock(tid, ip, tlckDTREE | tlckRELOCATE);\n\t\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\t\tpxdlock->flag = mlckFREEPXD;\n\t\tpxdlock->pxd = sp->header.self;\n\t\tpxdlock->index = 1;\n\n\t\t \n\t\tif (DO_INDEX(ip)) {\n\t\t\ts64 lblock;\n\n\t\t\tmp = NULL;\n\t\t\tstbl = DT_GETSTBL(sp);\n\t\t\tfor (n = 0; n < sp->header.nextindex; n++) {\n\t\t\t\tldtentry =\n\t\t\t\t    (struct ldtentry *) & sp->slot[stbl[n]];\n\t\t\t\tmodify_index(tid, ip,\n\t\t\t\t\t     le32_to_cpu(ldtentry->index),\n\t\t\t\t\t     xaddr, n, &mp, &lblock);\n\t\t\t}\n\t\t\tif (mp)\n\t\t\t\trelease_metapage(mp);\n\t\t}\n\t}\n\n\t \n\tsp->header.self = *pxd;\n\n\tjfs_info(\"dtExtendPage: ip:0x%p smp:0x%p sp:0x%p\", ip, smp, sp);\n\n\tBT_MARK_DIRTY(smp, ip);\n\t \n\ttlck = txLock(tid, ip, smp, tlckDTREE | type);\n\tdtlck = (struct dt_lock *) & tlck->lock;\n\tlv = & dtlck->lv[0];\n\n\t \n\txlen = lengthPXD(pxd);\n\txsize = xlen << JFS_SBI(sb)->l2bsize;\n\n\t \n\toldstblindex = sp->header.stblindex;\n\toldstblsize = (sp->header.maxslot + 31) >> L2DTSLOTSIZE;\n\tnewstblindex = sp->header.maxslot;\n\tn = xsize >> L2DTSLOTSIZE;\n\tnewstblsize = (n + 31) >> L2DTSLOTSIZE;\n\tmemcpy(&sp->slot[newstblindex], &sp->slot[oldstblindex],\n\t       sp->header.nextindex);\n\n\t \n\tif (type == tlckEXTEND) {\n\t\t \n\t\tlv->offset = 0;\n\t\tlv->length = 1;\n\t\tdtlck->index++;\n\t\tlv++;\n\n\t\t \n\t\tlv->offset = newstblindex;\n\t\tlv->length = newstblsize;\n\t}\n\t \n\telse {\n\t\tlv->offset = 0;\n\t\tlv->length = sp->header.maxslot + newstblsize;\n\t}\n\n\tdtlck->index++;\n\n\tsp->header.maxslot = n;\n\tsp->header.stblindex = newstblindex;\n\t \n\n\t \n\tfsi = oldstblindex;\n\tf = &sp->slot[fsi];\n\tlast = sp->header.freelist;\n\tfor (n = 0; n < oldstblsize; n++, fsi++, f++) {\n\t\tf->next = last;\n\t\tlast = fsi;\n\t}\n\tsp->header.freelist = last;\n\tsp->header.freecnt += oldstblsize;\n\n\t \n\t \n\tfsi = n = newstblindex + newstblsize;\n\tf = &sp->slot[fsi];\n\tfor (fsi++; fsi < sp->header.maxslot; f++, fsi++)\n\t\tf->next = fsi;\n\tf->next = -1;\n\n\t \n\tfsi = sp->header.freelist;\n\tif (fsi == -1)\n\t\tsp->header.freelist = n;\n\telse {\n\t\tdo {\n\t\t\tf = &sp->slot[fsi];\n\t\t\tfsi = f->next;\n\t\t} while (fsi != -1);\n\n\t\tf->next = n;\n\t}\n\n\tsp->header.freecnt += sp->header.maxslot - n;\n\n\t \n\tdtInsertEntry(sp, split->index, split->key, split->data, &dtlck);\n\n\tBT_MARK_DIRTY(pmp, ip);\n\t \n\tif (type == tlckEXTEND) {\n\t\tn = sp->header.maxslot >> 2;\n\t\tif (sp->header.freelist < n)\n\t\t\tdtLinelockFreelist(sp, n, &dtlck);\n\t}\n\n\t \n\t \n\ttlck = txLock(tid, ip, pmp, tlckDTREE | tlckENTRY);\n\tdtlck = (struct dt_lock *) & tlck->lock;\n\tlv = & dtlck->lv[dtlck->index];\n\n\t \n\tlv->offset = 1;\n\tlv->length = 1;\n\tdtlck->index++;\n\n\t \n\ttpxd = (pxd_t *) & pp->slot[1];\n\t*tpxd = *pxd;\n\n\tDT_PUTPAGE(pmp);\n\treturn 0;\n}\n\n\n \nstatic int dtSplitRoot(tid_t tid,\n\t    struct inode *ip, struct dtsplit * split, struct metapage ** rmpp)\n{\n\tstruct super_block *sb = ip->i_sb;\n\tstruct metapage *smp;\n\tdtroot_t *sp;\n\tstruct metapage *rmp;\n\tdtpage_t *rp;\n\ts64 rbn;\n\tint xlen;\n\tint xsize;\n\tstruct dtslot *f;\n\ts8 *stbl;\n\tint fsi, stblsize, n;\n\tstruct idtentry *s;\n\tpxd_t *ppxd;\n\tstruct pxdlist *pxdlist;\n\tpxd_t *pxd;\n\tstruct dt_lock *dtlck;\n\tstruct tlock *tlck;\n\tstruct lv *lv;\n\tint rc;\n\n\t \n\tsmp = split->mp;\n\tsp = &JFS_IP(ip)->i_dtroot;\n\n\t \n\tpxdlist = split->pxdlist;\n\tpxd = &pxdlist->pxd[pxdlist->npxd];\n\tpxdlist->npxd++;\n\trbn = addressPXD(pxd);\n\txlen = lengthPXD(pxd);\n\txsize = xlen << JFS_SBI(sb)->l2bsize;\n\trmp = get_metapage(ip, rbn, xsize, 1);\n\tif (!rmp)\n\t\treturn -EIO;\n\n\trp = rmp->data;\n\n\t \n\trc = dquot_alloc_block(ip, lengthPXD(pxd));\n\tif (rc) {\n\t\trelease_metapage(rmp);\n\t\treturn rc;\n\t}\n\n\tBT_MARK_DIRTY(rmp, ip);\n\t \n\ttlck = txLock(tid, ip, rmp, tlckDTREE | tlckNEW);\n\tdtlck = (struct dt_lock *) & tlck->lock;\n\n\trp->header.flag =\n\t    (sp->header.flag & BT_LEAF) ? BT_LEAF : BT_INTERNAL;\n\trp->header.self = *pxd;\n\n\t \n\trp->header.next = 0;\n\trp->header.prev = 0;\n\n\t \n\t \n\tASSERT(dtlck->index == 0);\n\tlv = & dtlck->lv[0];\n\tlv->offset = 0;\n\tlv->length = 10;\t \n\tdtlck->index++;\n\n\tn = xsize >> L2DTSLOTSIZE;\n\trp->header.maxslot = n;\n\tstblsize = (n + 31) >> L2DTSLOTSIZE;\n\n\t \n\trp->header.stblindex = DTROOTMAXSLOT;\n\tstbl = (s8 *) & rp->slot[DTROOTMAXSLOT];\n\tmemcpy(stbl, sp->header.stbl, sp->header.nextindex);\n\trp->header.nextindex = sp->header.nextindex;\n\n\t \n\tmemcpy(&rp->slot[1], &sp->slot[1], IDATASIZE);\n\n\t \n\t \n\tfsi = n = DTROOTMAXSLOT + stblsize;\n\tf = &rp->slot[fsi];\n\tfor (fsi++; fsi < rp->header.maxslot; f++, fsi++)\n\t\tf->next = fsi;\n\tf->next = -1;\n\n\t \n\tfsi = sp->header.freelist;\n\tif (fsi == -1)\n\t\trp->header.freelist = n;\n\telse {\n\t\trp->header.freelist = fsi;\n\n\t\tdo {\n\t\t\tf = &rp->slot[fsi];\n\t\t\tfsi = f->next;\n\t\t} while (fsi != -1);\n\n\t\tf->next = n;\n\t}\n\n\trp->header.freecnt = sp->header.freecnt + rp->header.maxslot - n;\n\n\t \n\tif ((rp->header.flag & BT_LEAF) && DO_INDEX(ip)) {\n\t\ts64 lblock;\n\t\tstruct metapage *mp = NULL;\n\t\tstruct ldtentry *ldtentry;\n\n\t\tstbl = DT_GETSTBL(rp);\n\t\tfor (n = 0; n < rp->header.nextindex; n++) {\n\t\t\tldtentry = (struct ldtentry *) & rp->slot[stbl[n]];\n\t\t\tmodify_index(tid, ip, le32_to_cpu(ldtentry->index),\n\t\t\t\t     rbn, n, &mp, &lblock);\n\t\t}\n\t\tif (mp)\n\t\t\trelease_metapage(mp);\n\t}\n\t \n\tdtInsertEntry(rp, split->index, split->key, split->data, &dtlck);\n\n\t \n\tBT_MARK_DIRTY(smp, ip);\n\t \n\ttlck = txLock(tid, ip, smp, tlckDTREE | tlckNEW | tlckBTROOT);\n\tdtlck = (struct dt_lock *) & tlck->lock;\n\n\t \n\tASSERT(dtlck->index == 0);\n\tlv = & dtlck->lv[0];\n\tlv->offset = 0;\n\tlv->length = DTROOTMAXSLOT;\n\tdtlck->index++;\n\n\t \n\tif (sp->header.flag & BT_LEAF) {\n\t\tsp->header.flag &= ~BT_LEAF;\n\t\tsp->header.flag |= BT_INTERNAL;\n\t}\n\n\t \n\ts = (struct idtentry *) & sp->slot[DTENTRYSTART];\n\tppxd = (pxd_t *) s;\n\t*ppxd = *pxd;\n\ts->next = -1;\n\ts->namlen = 0;\n\n\tstbl = sp->header.stbl;\n\tstbl[0] = DTENTRYSTART;\n\tsp->header.nextindex = 1;\n\n\t \n\tfsi = DTENTRYSTART + 1;\n\tf = &sp->slot[fsi];\n\n\t \n\tfor (fsi++; fsi < DTROOTMAXSLOT; f++, fsi++)\n\t\tf->next = fsi;\n\tf->next = -1;\n\n\tsp->header.freelist = DTENTRYSTART + 1;\n\tsp->header.freecnt = DTROOTMAXSLOT - (DTENTRYSTART + 1);\n\n\t*rmpp = rmp;\n\n\treturn 0;\n}\n\n\n \nint dtDelete(tid_t tid,\n\t struct inode *ip, struct component_name * key, ino_t * ino, int flag)\n{\n\tint rc = 0;\n\ts64 bn;\n\tstruct metapage *mp, *imp;\n\tdtpage_t *p;\n\tint index;\n\tstruct btstack btstack;\n\tstruct dt_lock *dtlck;\n\tstruct tlock *tlck;\n\tstruct lv *lv;\n\tint i;\n\tstruct ldtentry *ldtentry;\n\tu8 *stbl;\n\tu32 table_index, next_index;\n\tstruct metapage *nmp;\n\tdtpage_t *np;\n\n\t \n\tif ((rc = dtSearch(ip, key, ino, &btstack, flag)))\n\t\treturn rc;\n\n\t \n\tDT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\t \n\tif (DO_INDEX(ip)) {\n\t\tstbl = DT_GETSTBL(p);\n\t\tldtentry = (struct ldtentry *) & p->slot[stbl[index]];\n\t\ttable_index = le32_to_cpu(ldtentry->index);\n\t\tif (index == (p->header.nextindex - 1)) {\n\t\t\t \n\t\t\tif ((p->header.flag & BT_ROOT)\n\t\t\t    || (p->header.next == 0))\n\t\t\t\tnext_index = -1;\n\t\t\telse {\n\t\t\t\t \n\t\t\t\tDT_GETPAGE(ip, le64_to_cpu(p->header.next),\n\t\t\t\t\t   nmp, PSIZE, np, rc);\n\t\t\t\tif (rc)\n\t\t\t\t\tnext_index = -1;\n\t\t\t\telse {\n\t\t\t\t\tstbl = DT_GETSTBL(np);\n\t\t\t\t\tldtentry =\n\t\t\t\t\t    (struct ldtentry *) & np->\n\t\t\t\t\t    slot[stbl[0]];\n\t\t\t\t\tnext_index =\n\t\t\t\t\t    le32_to_cpu(ldtentry->index);\n\t\t\t\t\tDT_PUTPAGE(nmp);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tldtentry =\n\t\t\t    (struct ldtentry *) & p->slot[stbl[index + 1]];\n\t\t\tnext_index = le32_to_cpu(ldtentry->index);\n\t\t}\n\t\tfree_index(tid, ip, table_index, next_index);\n\t}\n\t \n\tif (p->header.nextindex == 1) {\n\t\t \n\t\trc = dtDeleteUp(tid, ip, mp, p, &btstack);\n\t}\n\t \n\telse {\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\t \n\t\ttlck = txLock(tid, ip, mp, tlckDTREE | tlckENTRY);\n\t\tdtlck = (struct dt_lock *) & tlck->lock;\n\n\t\t \n\n\t\t \n\t\tif (dtlck->index >= dtlck->maxcnt)\n\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\tlv = & dtlck->lv[dtlck->index];\n\t\tlv->offset = 0;\n\t\tlv->length = 1;\n\t\tdtlck->index++;\n\n\t\t \n\t\tif (!(p->header.flag & BT_ROOT)) {\n\t\t\tif (dtlck->index >= dtlck->maxcnt)\n\t\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\t\tlv = & dtlck->lv[dtlck->index];\n\t\t\ti = index >> L2DTSLOTSIZE;\n\t\t\tlv->offset = p->header.stblindex + i;\n\t\t\tlv->length =\n\t\t\t    ((p->header.nextindex - 1) >> L2DTSLOTSIZE) -\n\t\t\t    i + 1;\n\t\t\tdtlck->index++;\n\t\t}\n\n\t\t \n\t\tdtDeleteEntry(p, index, &dtlck);\n\n\t\t \n\t\tif (DO_INDEX(ip) && index < p->header.nextindex) {\n\t\t\ts64 lblock;\n\n\t\t\timp = NULL;\n\t\t\tstbl = DT_GETSTBL(p);\n\t\t\tfor (i = index; i < p->header.nextindex; i++) {\n\t\t\t\tldtentry =\n\t\t\t\t    (struct ldtentry *) & p->slot[stbl[i]];\n\t\t\t\tmodify_index(tid, ip,\n\t\t\t\t\t     le32_to_cpu(ldtentry->index),\n\t\t\t\t\t     bn, i, &imp, &lblock);\n\t\t\t}\n\t\t\tif (imp)\n\t\t\t\trelease_metapage(imp);\n\t\t}\n\n\t\tDT_PUTPAGE(mp);\n\t}\n\n\treturn rc;\n}\n\n\n \nstatic int dtDeleteUp(tid_t tid, struct inode *ip,\n\t   struct metapage * fmp, dtpage_t * fp, struct btstack * btstack)\n{\n\tint rc = 0;\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\tint index, nextindex;\n\tint xlen;\n\tstruct btframe *parent;\n\tstruct dt_lock *dtlck;\n\tstruct tlock *tlck;\n\tstruct lv *lv;\n\tstruct pxd_lock *pxdlock;\n\tint i;\n\n\t \n\tif (BT_IS_ROOT(fmp)) {\n\t\t \n\t\tdtInitRoot(tid, ip, PARENT(ip));\n\n\t\tDT_PUTPAGE(fmp);\n\n\t\treturn 0;\n\t}\n\n\t \n\t \n\ttlck = txMaplock(tid, ip, tlckDTREE | tlckFREE);\n\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\tpxdlock->flag = mlckFREEPXD;\n\tpxdlock->pxd = fp->header.self;\n\tpxdlock->index = 1;\n\n\t \n\tif ((rc = dtRelink(tid, ip, fp))) {\n\t\tBT_PUTPAGE(fmp);\n\t\treturn rc;\n\t}\n\n\txlen = lengthPXD(&fp->header.self);\n\n\t \n\tdquot_free_block(ip, xlen);\n\n\t \n\tdiscard_metapage(fmp);\n\n\t \n\twhile ((parent = BT_POP(btstack)) != NULL) {\n\t\t \n\t\tDT_GETPAGE(ip, parent->bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t \n\t\tindex = parent->index;\n\n\t\t \n\t\tnextindex = p->header.nextindex;\n\n\t\t \n\t\tif (nextindex == 1) {\n\t\t\t \n\t\t\tif (p->header.flag & BT_ROOT) {\n\t\t\t\t \n\t\t\t\tdtInitRoot(tid, ip, PARENT(ip));\n\n\t\t\t\tDT_PUTPAGE(mp);\n\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t \n\t\t\telse {\n\t\t\t\t \n\t\t\t\ttlck =\n\t\t\t\t    txMaplock(tid, ip,\n\t\t\t\t\t      tlckDTREE | tlckFREE);\n\t\t\t\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\t\t\t\tpxdlock->flag = mlckFREEPXD;\n\t\t\t\tpxdlock->pxd = p->header.self;\n\t\t\t\tpxdlock->index = 1;\n\n\t\t\t\t \n\t\t\t\tif ((rc = dtRelink(tid, ip, p))) {\n\t\t\t\t\tDT_PUTPAGE(mp);\n\t\t\t\t\treturn rc;\n\t\t\t\t}\n\n\t\t\t\txlen = lengthPXD(&p->header.self);\n\n\t\t\t\t \n\t\t\t\tdquot_free_block(ip, xlen);\n\n\t\t\t\t \n\t\t\t\tdiscard_metapage(mp);\n\n\t\t\t\t \n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tBT_MARK_DIRTY(mp, ip);\n\t\t \n\t\ttlck = txLock(tid, ip, mp, tlckDTREE | tlckENTRY);\n\t\tdtlck = (struct dt_lock *) & tlck->lock;\n\n\t\t \n\t\tif (dtlck->index >= dtlck->maxcnt)\n\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\tlv = & dtlck->lv[dtlck->index];\n\t\tlv->offset = 0;\n\t\tlv->length = 1;\n\t\tdtlck->index++;\n\n\t\t \n\t\tif (!(p->header.flag & BT_ROOT)) {\n\t\t\tif (dtlck->index < dtlck->maxcnt)\n\t\t\t\tlv++;\n\t\t\telse {\n\t\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\t\t\tlv = & dtlck->lv[0];\n\t\t\t}\n\t\t\ti = index >> L2DTSLOTSIZE;\n\t\t\tlv->offset = p->header.stblindex + i;\n\t\t\tlv->length =\n\t\t\t    ((p->header.nextindex - 1) >> L2DTSLOTSIZE) -\n\t\t\t    i + 1;\n\t\t\tdtlck->index++;\n\t\t}\n\n\t\t \n\t\tdtDeleteEntry(p, index, &dtlck);\n\n\t\t \n\t\tif (index == 0 &&\n\t\t    ((p->header.flag & BT_ROOT) || p->header.prev == 0))\n\t\t\tdtTruncateEntry(p, 0, &dtlck);\n\n\t\t \n\t\tDT_PUTPAGE(mp);\n\n\t\t \n\t\tbreak;\n\t}\n\n\tif (!DO_INDEX(ip))\n\t\tip->i_size -= PSIZE;\n\n\treturn 0;\n}\n\n \nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p)\n{\n\tint rc;\n\tstruct metapage *mp;\n\ts64 nextbn, prevbn;\n\tstruct tlock *tlck;\n\tstruct dt_lock *dtlck;\n\tstruct lv *lv;\n\n\tnextbn = le64_to_cpu(p->header.next);\n\tprevbn = le64_to_cpu(p->header.prev);\n\n\t \n\tif (nextbn != 0) {\n\t\tDT_GETPAGE(ip, nextbn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\t \n\t\ttlck = txLock(tid, ip, mp, tlckDTREE | tlckRELINK);\n\t\tjfs_info(\"dtRelink nextbn: tlck = 0x%p, ip = 0x%p, mp=0x%p\",\n\t\t\ttlck, ip, mp);\n\t\tdtlck = (struct dt_lock *) & tlck->lock;\n\n\t\t \n\t\tif (dtlck->index >= dtlck->maxcnt)\n\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\tlv = & dtlck->lv[dtlck->index];\n\t\tlv->offset = 0;\n\t\tlv->length = 1;\n\t\tdtlck->index++;\n\n\t\tp->header.prev = cpu_to_le64(prevbn);\n\t\tDT_PUTPAGE(mp);\n\t}\n\n\t \n\tif (prevbn != 0) {\n\t\tDT_GETPAGE(ip, prevbn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\t \n\t\ttlck = txLock(tid, ip, mp, tlckDTREE | tlckRELINK);\n\t\tjfs_info(\"dtRelink prevbn: tlck = 0x%p, ip = 0x%p, mp=0x%p\",\n\t\t\ttlck, ip, mp);\n\t\tdtlck = (struct dt_lock *) & tlck->lock;\n\n\t\t \n\t\tif (dtlck->index >= dtlck->maxcnt)\n\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\tlv = & dtlck->lv[dtlck->index];\n\t\tlv->offset = 0;\n\t\tlv->length = 1;\n\t\tdtlck->index++;\n\n\t\tp->header.next = cpu_to_le64(nextbn);\n\t\tDT_PUTPAGE(mp);\n\t}\n\n\treturn 0;\n}\n\n\n \nvoid dtInitRoot(tid_t tid, struct inode *ip, u32 idotdot)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tdtroot_t *p;\n\tint fsi;\n\tstruct dtslot *f;\n\tstruct tlock *tlck;\n\tstruct dt_lock *dtlck;\n\tstruct lv *lv;\n\tu16 xflag_save;\n\n\t \n\tif (DO_INDEX(ip)) {\n\t\tif (!jfs_dirtable_inline(ip)) {\n\t\t\tstruct tblock *tblk = tid_to_tblock(tid);\n\t\t\t \n\t\t\txflag_save = tblk->xflag;\n\t\t\ttblk->xflag = 0;\n\t\t\t \n\t\t\txtTruncate(tid, ip, 0, COMMIT_PWMAP);\n\t\t\tset_cflag(COMMIT_Stale, ip);\n\n\t\t\ttblk->xflag = xflag_save;\n\t\t} else\n\t\t\tip->i_size = 1;\n\n\t\tjfs_ip->next_index = 2;\n\t} else\n\t\tip->i_size = IDATASIZE;\n\n\t \n\ttlck = txLock(tid, ip, (struct metapage *) & jfs_ip->bxflag,\n\t\t      tlckDTREE | tlckENTRY | tlckBTROOT);\n\tdtlck = (struct dt_lock *) & tlck->lock;\n\n\t \n\tASSERT(dtlck->index == 0);\n\tlv = & dtlck->lv[0];\n\tlv->offset = 0;\n\tlv->length = DTROOTMAXSLOT;\n\tdtlck->index++;\n\n\tp = &jfs_ip->i_dtroot;\n\n\tp->header.flag = DXD_INDEX | BT_ROOT | BT_LEAF;\n\n\tp->header.nextindex = 0;\n\n\t \n\tfsi = 1;\n\tf = &p->slot[fsi];\n\n\t \n\tfor (fsi++; fsi < DTROOTMAXSLOT; f++, fsi++)\n\t\tf->next = fsi;\n\tf->next = -1;\n\n\tp->header.freelist = 1;\n\tp->header.freecnt = 8;\n\n\t \n\tp->header.idotdot = cpu_to_le32(idotdot);\n\n\treturn;\n}\n\n \nstatic void add_missing_indices(struct inode *inode, s64 bn)\n{\n\tstruct ldtentry *d;\n\tstruct dt_lock *dtlck;\n\tint i;\n\tuint index;\n\tstruct lv *lv;\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\tint rc;\n\ts8 *stbl;\n\ttid_t tid;\n\tstruct tlock *tlck;\n\n\ttid = txBegin(inode->i_sb, 0);\n\n\tDT_GETPAGE(inode, bn, mp, PSIZE, p, rc);\n\n\tif (rc) {\n\t\tprintk(KERN_ERR \"DT_GETPAGE failed!\\n\");\n\t\tgoto end;\n\t}\n\tBT_MARK_DIRTY(mp, inode);\n\n\tASSERT(p->header.flag & BT_LEAF);\n\n\ttlck = txLock(tid, inode, mp, tlckDTREE | tlckENTRY);\n\tif (BT_IS_ROOT(mp))\n\t\ttlck->type |= tlckBTROOT;\n\n\tdtlck = (struct dt_lock *) &tlck->lock;\n\n\tstbl = DT_GETSTBL(p);\n\tfor (i = 0; i < p->header.nextindex; i++) {\n\t\td = (struct ldtentry *) &p->slot[stbl[i]];\n\t\tindex = le32_to_cpu(d->index);\n\t\tif ((index < 2) || (index >= JFS_IP(inode)->next_index)) {\n\t\t\td->index = cpu_to_le32(add_index(tid, inode, bn, i));\n\t\t\tif (dtlck->index >= dtlck->maxcnt)\n\t\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\t\tlv = &dtlck->lv[dtlck->index];\n\t\t\tlv->offset = stbl[i];\n\t\t\tlv->length = 1;\n\t\t\tdtlck->index++;\n\t\t}\n\t}\n\n\tDT_PUTPAGE(mp);\n\t(void) txCommit(tid, 1, &inode, 0);\nend:\n\ttxEnd(tid);\n}\n\n \nstruct jfs_dirent {\n\tloff_t position;\n\tint ino;\n\tu16 name_len;\n\tchar name[];\n};\n\n \nstatic inline struct jfs_dirent *next_jfs_dirent(struct jfs_dirent *dirent)\n{\n\treturn (struct jfs_dirent *)\n\t\t((char *)dirent +\n\t\t ((sizeof (struct jfs_dirent) + dirent->name_len + 1 +\n\t\t   sizeof (loff_t) - 1) &\n\t\t  ~(sizeof (loff_t) - 1)));\n}\n\n \nint jfs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *ip = file_inode(file);\n\tstruct nls_table *codepage = JFS_SBI(ip->i_sb)->nls_tab;\n\tint rc = 0;\n\tloff_t dtpos;\t \n\tstruct dtoffset {\n\t\ts16 pn;\n\t\ts16 index;\n\t\ts32 unused;\n\t} *dtoffset = (struct dtoffset *) &dtpos;\n\ts64 bn;\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\tint index;\n\ts8 *stbl;\n\tstruct btstack btstack;\n\tint i, next;\n\tstruct ldtentry *d;\n\tstruct dtslot *t;\n\tint d_namleft, len, outlen;\n\tunsigned long dirent_buf;\n\tchar *name_ptr;\n\tu32 dir_index;\n\tint do_index = 0;\n\tuint loop_count = 0;\n\tstruct jfs_dirent *jfs_dirent;\n\tint jfs_dirents;\n\tint overflow, fix_page, page_fixed = 0;\n\tstatic int unique_pos = 2;\t \n\n\tif (ctx->pos == DIREND)\n\t\treturn 0;\n\n\tif (DO_INDEX(ip)) {\n\t\t \n\t\tdo_index = 1;\n\n\t\tdir_index = (u32) ctx->pos;\n\n\t\t \n\t\tif (dir_index)\n\t\t\tdir_index--;\n\n\t\tif (dir_index > 1) {\n\t\t\tstruct dir_table_slot dirtab_slot;\n\n\t\t\tif (dtEmpty(ip) ||\n\t\t\t    (dir_index >= JFS_IP(ip)->next_index)) {\n\t\t\t\t \n\t\t\t\tctx->pos = DIREND;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t      repeat:\n\t\t\trc = read_index(ip, dir_index, &dirtab_slot);\n\t\t\tif (rc) {\n\t\t\t\tctx->pos = DIREND;\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tif (dirtab_slot.flag == DIR_INDEX_FREE) {\n\t\t\t\tif (loop_count++ > JFS_IP(ip)->next_index) {\n\t\t\t\t\tjfs_err(\"jfs_readdir detected infinite loop!\");\n\t\t\t\t\tctx->pos = DIREND;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tdir_index = le32_to_cpu(dirtab_slot.addr2);\n\t\t\t\tif (dir_index == -1) {\n\t\t\t\t\tctx->pos = DIREND;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t\tbn = addressDTS(&dirtab_slot);\n\t\t\tindex = dirtab_slot.slot;\n\t\t\tDT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\t\tif (rc) {\n\t\t\t\tctx->pos = DIREND;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (p->header.flag & BT_INTERNAL) {\n\t\t\t\tjfs_err(\"jfs_readdir: bad index table\");\n\t\t\t\tDT_PUTPAGE(mp);\n\t\t\t\tctx->pos = DIREND;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else {\n\t\t\tif (dir_index == 0) {\n\t\t\t\t \n\t\t\t\tctx->pos = 1;\n\t\t\t\tif (!dir_emit(ctx, \".\", 1, ip->i_ino, DT_DIR))\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t \n\t\t\tctx->pos = 2;\n\t\t\tif (!dir_emit(ctx, \"..\", 2, PARENT(ip), DT_DIR))\n\t\t\t\treturn 0;\n\n\t\t\t \n\t\t\tif (dtEmpty(ip)) {\n\t\t\t\tctx->pos = DIREND;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif ((rc = dtReadFirst(ip, &btstack)))\n\t\t\t\treturn rc;\n\n\t\t\tDT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\t\t}\n\t} else {\n\t\t \n\t\tdtpos = ctx->pos;\n\t\tif (dtpos < 2) {\n\t\t\t \n\t\t\tctx->pos = 1;\n\t\t\tif (!dir_emit(ctx, \".\", 1, ip->i_ino, DT_DIR))\n\t\t\t\treturn 0;\n\t\t\tdtoffset->index = 2;\n\t\t\tctx->pos = dtpos;\n\t\t}\n\n\t\tif (dtoffset->pn == 0) {\n\t\t\tif (dtoffset->index == 2) {\n\t\t\t\t \n\t\t\t\tif (!dir_emit(ctx, \"..\", 2, PARENT(ip), DT_DIR))\n\t\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\tjfs_err(\"jfs_readdir called with invalid offset!\");\n\t\t\t}\n\t\t\tdtoffset->pn = 1;\n\t\t\tdtoffset->index = 0;\n\t\t\tctx->pos = dtpos;\n\t\t}\n\n\t\tif (dtEmpty(ip)) {\n\t\t\tctx->pos = DIREND;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif ((rc = dtReadNext(ip, &ctx->pos, &btstack))) {\n\t\t\tjfs_err(\"jfs_readdir: unexpected rc = %d from dtReadNext\",\n\t\t\t\trc);\n\t\t\tctx->pos = DIREND;\n\t\t\treturn 0;\n\t\t}\n\t\t \n\t\tDT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\t\t \n\t\tif (bn < 0) {\n\t\t\tctx->pos = DIREND;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdirent_buf = __get_free_page(GFP_KERNEL);\n\tif (dirent_buf == 0) {\n\t\tDT_PUTPAGE(mp);\n\t\tjfs_warn(\"jfs_readdir: __get_free_page failed!\");\n\t\tctx->pos = DIREND;\n\t\treturn -ENOMEM;\n\t}\n\n\twhile (1) {\n\t\tjfs_dirent = (struct jfs_dirent *) dirent_buf;\n\t\tjfs_dirents = 0;\n\t\toverflow = fix_page = 0;\n\n\t\tstbl = DT_GETSTBL(p);\n\n\t\tfor (i = index; i < p->header.nextindex; i++) {\n\t\t\td = (struct ldtentry *) & p->slot[stbl[i]];\n\n\t\t\tif (((long) jfs_dirent + d->namlen + 1) >\n\t\t\t    (dirent_buf + PAGE_SIZE)) {\n\t\t\t\t \n\t\t\t\tindex = i;\n\t\t\t\toverflow = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\td_namleft = d->namlen;\n\t\t\tname_ptr = jfs_dirent->name;\n\t\t\tjfs_dirent->ino = le32_to_cpu(d->inumber);\n\n\t\t\tif (do_index) {\n\t\t\t\tlen = min(d_namleft, DTLHDRDATALEN);\n\t\t\t\tjfs_dirent->position = le32_to_cpu(d->index);\n\t\t\t\t \n\t\t\t\tif ((jfs_dirent->position < 2) ||\n\t\t\t\t    (jfs_dirent->position >=\n\t\t\t\t     JFS_IP(ip)->next_index)) {\n\t\t\t\t\tif (!page_fixed && !isReadOnly(ip)) {\n\t\t\t\t\t\tfix_page = 1;\n\t\t\t\t\t\t \n\t\t\t\t\t\toverflow = 1;\n\t\t\t\t\t\tindex = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tjfs_dirent->position = unique_pos++;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tjfs_dirent->position++;\n\t\t\t} else {\n\t\t\t\tjfs_dirent->position = dtpos;\n\t\t\t\tlen = min(d_namleft, DTLHDRDATALEN_LEGACY);\n\t\t\t}\n\n\t\t\t \n\t\t\toutlen = jfs_strfromUCS_le(name_ptr, d->name, len,\n\t\t\t\t\t\t   codepage);\n\t\t\tjfs_dirent->name_len = outlen;\n\n\t\t\t \n\t\t\tnext = d->next;\n\t\t\twhile (next >= 0) {\n\t\t\t\tt = (struct dtslot *) & p->slot[next];\n\t\t\t\tname_ptr += outlen;\n\t\t\t\td_namleft -= len;\n\t\t\t\t \n\t\t\t\tif (d_namleft == 0) {\n\t\t\t\t\tjfs_error(ip->i_sb,\n\t\t\t\t\t\t  \"JFS:Dtree error: ino = %ld, bn=%lld, index = %d\\n\",\n\t\t\t\t\t\t  (long)ip->i_ino,\n\t\t\t\t\t\t  (long long)bn,\n\t\t\t\t\t\t  i);\n\t\t\t\t\tgoto skip_one;\n\t\t\t\t}\n\t\t\t\tlen = min(d_namleft, DTSLOTDATALEN);\n\t\t\t\toutlen = jfs_strfromUCS_le(name_ptr, t->name,\n\t\t\t\t\t\t\t   len, codepage);\n\t\t\t\tjfs_dirent->name_len += outlen;\n\n\t\t\t\tnext = t->next;\n\t\t\t}\n\n\t\t\tjfs_dirents++;\n\t\t\tjfs_dirent = next_jfs_dirent(jfs_dirent);\nskip_one:\n\t\t\tif (!do_index)\n\t\t\t\tdtoffset->index++;\n\t\t}\n\n\t\tif (!overflow) {\n\t\t\t \n\t\t\tif (p->header.flag & BT_ROOT)\n\t\t\t\tbn = 0;\n\t\t\telse {\n\t\t\t\tbn = le64_to_cpu(p->header.next);\n\t\t\t\tindex = 0;\n\t\t\t\t \n\t\t\t\tif (!do_index) {\n\t\t\t\t\tdtoffset->pn++;\n\t\t\t\t\tdtoffset->index = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpage_fixed = 0;\n\t\t}\n\n\t\t \n\t\tDT_PUTPAGE(mp);\n\n\t\tjfs_dirent = (struct jfs_dirent *) dirent_buf;\n\t\twhile (jfs_dirents--) {\n\t\t\tctx->pos = jfs_dirent->position;\n\t\t\tif (!dir_emit(ctx, jfs_dirent->name,\n\t\t\t\t    jfs_dirent->name_len,\n\t\t\t\t    jfs_dirent->ino, DT_UNKNOWN))\n\t\t\t\tgoto out;\n\t\t\tjfs_dirent = next_jfs_dirent(jfs_dirent);\n\t\t}\n\n\t\tif (fix_page) {\n\t\t\tadd_missing_indices(ip, bn);\n\t\t\tpage_fixed = 1;\n\t\t}\n\n\t\tif (!overflow && (bn == 0)) {\n\t\t\tctx->pos = DIREND;\n\t\t\tbreak;\n\t\t}\n\n\t\tDT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc) {\n\t\t\tfree_page(dirent_buf);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n      out:\n\tfree_page(dirent_buf);\n\n\treturn rc;\n}\n\n\n \nstatic int dtReadFirst(struct inode *ip, struct btstack * btstack)\n{\n\tint rc = 0;\n\ts64 bn;\n\tint psize = 288;\t \n\tstruct metapage *mp;\n\tdtpage_t *p;\n\ts8 *stbl;\n\tstruct btframe *btsp;\n\tpxd_t *xd;\n\n\tBT_CLR(btstack);\t \n\n\t \n\tfor (bn = 0;;) {\n\t\tDT_GETPAGE(ip, bn, mp, psize, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t \n\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t \n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = 0;\n\t\t\tbtsp->mp = mp;\n\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tif (BT_STACK_FULL(btstack)) {\n\t\t\tDT_PUTPAGE(mp);\n\t\t\tjfs_error(ip->i_sb, \"btstack overrun\\n\");\n\t\t\tBT_STACK_DUMP(btstack);\n\t\t\treturn -EIO;\n\t\t}\n\t\t \n\t\tBT_PUSH(btstack, bn, 0);\n\n\t\t \n\t\tstbl = DT_GETSTBL(p);\n\t\txd = (pxd_t *) & p->slot[stbl[0]];\n\n\t\t \n\t\tbn = addressPXD(xd);\n\t\tpsize = lengthPXD(xd) << JFS_SBI(ip->i_sb)->l2bsize;\n\n\t\t \n\t\tDT_PUTPAGE(mp);\n\t}\n}\n\n\n \nstatic int dtReadNext(struct inode *ip, loff_t * offset,\n\t\t      struct btstack * btstack)\n{\n\tint rc = 0;\n\tstruct dtoffset {\n\t\ts16 pn;\n\t\ts16 index;\n\t\ts32 unused;\n\t} *dtoffset = (struct dtoffset *) offset;\n\ts64 bn;\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\tint index;\n\tint pn;\n\ts8 *stbl;\n\tstruct btframe *btsp, *parent;\n\tpxd_t *xd;\n\n\t \n\tif ((rc = dtReadFirst(ip, btstack)))\n\t\treturn rc;\n\n\t \n\tDT_GETSEARCH(ip, btstack->top, bn, mp, p, index);\n\n\t \n\tpn = dtoffset->pn - 1;\t \n\tindex = dtoffset->index;\n\n\t \n\tif (pn == 0) {\n\t\t \n\t\tif (index < p->header.nextindex)\n\t\t\tgoto out;\n\n\t\tif (p->header.flag & BT_ROOT) {\n\t\t\tbn = -1;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tdtoffset->pn++;\n\t\tdtoffset->index = index = 0;\n\t\tgoto a;\n\t}\n\n\t \n\tif (p->header.flag & BT_ROOT) {\n\t\tbn = -1;\n\t\tgoto out;\n\t}\n\n\t \n\tif (pn > 1)\n\t\tgoto b;\n\n\t \n      a:\n\tbn = le64_to_cpu(p->header.next);\n\n\t \n\tDT_PUTPAGE(mp);\n\n\t \n\tif (bn == 0) {\n\t\tbn = -1;\n\t\tgoto out;\n\t}\n\n\tgoto c;\n\n\t \n      b:\n\t \n\tDT_PUTPAGE(mp);\n\n\t \n\tbtsp = btstack->top;\n\tparent = btsp - 1;\n\tbn = parent->bn;\n\tDT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\twhile (pn >= p->header.nextindex) {\n\t\tpn -= p->header.nextindex;\n\n\t\t \n\t\tbn = le64_to_cpu(p->header.next);\n\n\t\t \n\t\tDT_PUTPAGE(mp);\n\n\t\t \n\t\tif (bn == 0) {\n\t\t\tbn = -1;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tDT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t \n\t\tparent->bn = bn;\n\t}\n\n\t \n\tstbl = DT_GETSTBL(p);\n\txd = (pxd_t *) & p->slot[stbl[pn]];\n\tbn = addressPXD(xd);\n\n\t \n\tDT_PUTPAGE(mp);\n\n\t \n      c:\n\tDT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tif (index >= p->header.nextindex) {\n\t\tbn = le64_to_cpu(p->header.next);\n\n\t\t \n\t\tDT_PUTPAGE(mp);\n\n\t\t \n\t\tif (bn == 0) {\n\t\t\tbn = -1;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tDT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t \n\t\tdtoffset->pn++;\n\t\tdtoffset->index = 0;\n\t}\n\n      out:\n\t \n\tbtsp = btstack->top;\n\tbtsp->bn = bn;\n\tbtsp->index = dtoffset->index;\n\tbtsp->mp = mp;\n\n\treturn 0;\n}\n\n\n \nstatic int dtCompare(struct component_name * key,\t \n\t\t     dtpage_t * p,\t \n\t\t     int si)\n{\t\t\t\t \n\twchar_t *kname;\n\t__le16 *name;\n\tint klen, namlen, len, rc;\n\tstruct idtentry *ih;\n\tstruct dtslot *t;\n\n\t \n\n\tkname = key->name;\n\tklen = key->namlen;\n\n\tih = (struct idtentry *) & p->slot[si];\n\tsi = ih->next;\n\tname = ih->name;\n\tnamlen = ih->namlen;\n\tlen = min(namlen, DTIHDRDATALEN);\n\n\t \n\tlen = min(klen, len);\n\tif ((rc = UniStrncmp_le(kname, name, len)))\n\t\treturn rc;\n\n\tklen -= len;\n\tnamlen -= len;\n\n\t \n\tkname += len;\n\twhile (klen > 0 && namlen > 0) {\n\t\t \n\t\tt = (struct dtslot *) & p->slot[si];\n\t\tlen = min(namlen, DTSLOTDATALEN);\n\t\tlen = min(klen, len);\n\t\tname = t->name;\n\t\tif ((rc = UniStrncmp_le(kname, name, len)))\n\t\t\treturn rc;\n\n\t\tklen -= len;\n\t\tnamlen -= len;\n\t\tkname += len;\n\t\tsi = t->next;\n\t}\n\n\treturn (klen - namlen);\n}\n\n\n\n\n \nstatic int ciCompare(struct component_name * key,\t \n\t\t     dtpage_t * p,\t \n\t\t     int si,\t \n\t\t     int flag)\n{\n\twchar_t *kname, x;\n\t__le16 *name;\n\tint klen, namlen, len, rc;\n\tstruct ldtentry *lh;\n\tstruct idtentry *ih;\n\tstruct dtslot *t;\n\tint i;\n\n\t \n\n\tkname = key->name;\n\tklen = key->namlen;\n\n\t \n\tif (p->header.flag & BT_LEAF) {\n\t\tlh = (struct ldtentry *) & p->slot[si];\n\t\tsi = lh->next;\n\t\tname = lh->name;\n\t\tnamlen = lh->namlen;\n\t\tif (flag & JFS_DIR_INDEX)\n\t\t\tlen = min(namlen, DTLHDRDATALEN);\n\t\telse\n\t\t\tlen = min(namlen, DTLHDRDATALEN_LEGACY);\n\t}\n\t \n\telse {\n\t\tih = (struct idtentry *) & p->slot[si];\n\t\tsi = ih->next;\n\t\tname = ih->name;\n\t\tnamlen = ih->namlen;\n\t\tlen = min(namlen, DTIHDRDATALEN);\n\t}\n\n\t \n\tlen = min(klen, len);\n\tfor (i = 0; i < len; i++, kname++, name++) {\n\t\t \n\t\tif ((flag & JFS_OS2) == JFS_OS2)\n\t\t\tx = UniToupper(le16_to_cpu(*name));\n\t\telse\n\t\t\tx = le16_to_cpu(*name);\n\t\tif ((rc = *kname - x))\n\t\t\treturn rc;\n\t}\n\n\tklen -= len;\n\tnamlen -= len;\n\n\t \n\twhile (klen > 0 && namlen > 0) {\n\t\t \n\t\tt = (struct dtslot *) & p->slot[si];\n\t\tlen = min(namlen, DTSLOTDATALEN);\n\t\tlen = min(klen, len);\n\t\tname = t->name;\n\t\tfor (i = 0; i < len; i++, kname++, name++) {\n\t\t\t \n\t\t\tif ((flag & JFS_OS2) == JFS_OS2)\n\t\t\t\tx = UniToupper(le16_to_cpu(*name));\n\t\t\telse\n\t\t\t\tx = le16_to_cpu(*name);\n\n\t\t\tif ((rc = *kname - x))\n\t\t\t\treturn rc;\n\t\t}\n\n\t\tklen -= len;\n\t\tnamlen -= len;\n\t\tsi = t->next;\n\t}\n\n\treturn (klen - namlen);\n}\n\n\n \nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t       int ri, struct component_name * key, int flag)\n{\n\tint klen, namlen;\n\twchar_t *pl, *pr, *kname;\n\tstruct component_name lkey;\n\tstruct component_name rkey;\n\n\tlkey.name = kmalloc_array(JFS_NAME_MAX + 1, sizeof(wchar_t),\n\t\t\t\t\tGFP_KERNEL);\n\tif (lkey.name == NULL)\n\t\treturn -ENOMEM;\n\n\trkey.name = kmalloc_array(JFS_NAME_MAX + 1, sizeof(wchar_t),\n\t\t\t\t\tGFP_KERNEL);\n\tif (rkey.name == NULL) {\n\t\tkfree(lkey.name);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tdtGetKey(lp, li, &lkey, flag);\n\tlkey.name[lkey.namlen] = 0;\n\n\tif ((flag & JFS_OS2) == JFS_OS2)\n\t\tciToUpper(&lkey);\n\n\tdtGetKey(rp, ri, &rkey, flag);\n\trkey.name[rkey.namlen] = 0;\n\n\n\tif ((flag & JFS_OS2) == JFS_OS2)\n\t\tciToUpper(&rkey);\n\n\t \n\tklen = 0;\n\tkname = key->name;\n\tnamlen = min(lkey.namlen, rkey.namlen);\n\tfor (pl = lkey.name, pr = rkey.name;\n\t     namlen; pl++, pr++, namlen--, klen++, kname++) {\n\t\t*kname = *pr;\n\t\tif (*pl != *pr) {\n\t\t\tkey->namlen = klen + 1;\n\t\t\tgoto free_names;\n\t\t}\n\t}\n\n\t \n\tif (lkey.namlen < rkey.namlen) {\n\t\t*kname = *pr;\n\t\tkey->namlen = klen + 1;\n\t} else\t\t\t \n\t\tkey->namlen = klen;\n\nfree_names:\n\tkfree(lkey.name);\n\tkfree(rkey.name);\n\treturn 0;\n}\n\n\n\n \nstatic void dtGetKey(dtpage_t * p, int i,\t \n\t\t     struct component_name * key, int flag)\n{\n\tint si;\n\ts8 *stbl;\n\tstruct ldtentry *lh;\n\tstruct idtentry *ih;\n\tstruct dtslot *t;\n\tint namlen, len;\n\twchar_t *kname;\n\t__le16 *name;\n\n\t \n\tstbl = DT_GETSTBL(p);\n\tsi = stbl[i];\n\tif (p->header.flag & BT_LEAF) {\n\t\tlh = (struct ldtentry *) & p->slot[si];\n\t\tsi = lh->next;\n\t\tnamlen = lh->namlen;\n\t\tname = lh->name;\n\t\tif (flag & JFS_DIR_INDEX)\n\t\t\tlen = min(namlen, DTLHDRDATALEN);\n\t\telse\n\t\t\tlen = min(namlen, DTLHDRDATALEN_LEGACY);\n\t} else {\n\t\tih = (struct idtentry *) & p->slot[si];\n\t\tsi = ih->next;\n\t\tnamlen = ih->namlen;\n\t\tname = ih->name;\n\t\tlen = min(namlen, DTIHDRDATALEN);\n\t}\n\n\tkey->namlen = namlen;\n\tkname = key->name;\n\n\t \n\tUniStrncpy_from_le(kname, name, len);\n\n\t \n\twhile (si >= 0) {\n\t\t \n\t\tt = &p->slot[si];\n\t\tkname += len;\n\t\tnamlen -= len;\n\t\tlen = min(namlen, DTSLOTDATALEN);\n\t\tUniStrncpy_from_le(kname, t->name, len);\n\n\t\tsi = t->next;\n\t}\n}\n\n\n \nstatic void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock ** dtlock)\n{\n\tstruct dtslot *h, *t;\n\tstruct ldtentry *lh = NULL;\n\tstruct idtentry *ih = NULL;\n\tint hsi, fsi, klen, len, nextindex;\n\twchar_t *kname;\n\t__le16 *name;\n\ts8 *stbl;\n\tpxd_t *xd;\n\tstruct dt_lock *dtlck = *dtlock;\n\tstruct lv *lv;\n\tint xsi, n;\n\ts64 bn = 0;\n\tstruct metapage *mp = NULL;\n\n\tklen = key->namlen;\n\tkname = key->name;\n\n\t \n\thsi = fsi = p->header.freelist;\n\th = &p->slot[fsi];\n\tp->header.freelist = h->next;\n\t--p->header.freecnt;\n\n\t \n\tif (dtlck->index >= dtlck->maxcnt)\n\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\n\tlv = & dtlck->lv[dtlck->index];\n\tlv->offset = hsi;\n\n\t \n\tif (p->header.flag & BT_LEAF) {\n\t\tlh = (struct ldtentry *) h;\n\t\tlh->next = h->next;\n\t\tlh->inumber = cpu_to_le32(data->leaf.ino);\n\t\tlh->namlen = klen;\n\t\tname = lh->name;\n\t\tif (data->leaf.ip) {\n\t\t\tlen = min(klen, DTLHDRDATALEN);\n\t\t\tif (!(p->header.flag & BT_ROOT))\n\t\t\t\tbn = addressPXD(&p->header.self);\n\t\t\tlh->index = cpu_to_le32(add_index(data->leaf.tid,\n\t\t\t\t\t\t\t  data->leaf.ip,\n\t\t\t\t\t\t\t  bn, index));\n\t\t} else\n\t\t\tlen = min(klen, DTLHDRDATALEN_LEGACY);\n\t} else {\n\t\tih = (struct idtentry *) h;\n\t\tih->next = h->next;\n\t\txd = (pxd_t *) ih;\n\t\t*xd = data->xd;\n\t\tih->namlen = klen;\n\t\tname = ih->name;\n\t\tlen = min(klen, DTIHDRDATALEN);\n\t}\n\n\tUniStrncpy_to_le(name, kname, len);\n\n\tn = 1;\n\txsi = hsi;\n\n\t \n\tt = h;\n\tklen -= len;\n\twhile (klen) {\n\t\t \n\t\tfsi = p->header.freelist;\n\t\tt = &p->slot[fsi];\n\t\tp->header.freelist = t->next;\n\t\t--p->header.freecnt;\n\n\t\t \n\t\tif (fsi != xsi + 1) {\n\t\t\t \n\t\t\tlv->length = n;\n\t\t\tdtlck->index++;\n\n\t\t\t \n\t\t\tif (dtlck->index < dtlck->maxcnt)\n\t\t\t\tlv++;\n\t\t\telse {\n\t\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\t\t\tlv = & dtlck->lv[0];\n\t\t\t}\n\n\t\t\tlv->offset = fsi;\n\t\t\tn = 0;\n\t\t}\n\n\t\tkname += len;\n\t\tlen = min(klen, DTSLOTDATALEN);\n\t\tUniStrncpy_to_le(t->name, kname, len);\n\n\t\tn++;\n\t\txsi = fsi;\n\t\tklen -= len;\n\t}\n\n\t \n\tlv->length = n;\n\tdtlck->index++;\n\n\t*dtlock = dtlck;\n\n\t \n\tif (h == t) {\n\t\t \n\t\tif (p->header.flag & BT_LEAF)\n\t\t\tlh->next = -1;\n\t\telse\n\t\t\tih->next = -1;\n\t} else\n\t\t \n\t\tt->next = -1;\n\n\t \n\tstbl = DT_GETSTBL(p);\n\tnextindex = p->header.nextindex;\n\tif (index < nextindex) {\n\t\tmemmove(stbl + index + 1, stbl + index, nextindex - index);\n\n\t\tif ((p->header.flag & BT_LEAF) && data->leaf.ip) {\n\t\t\ts64 lblock;\n\n\t\t\t \n\t\t\tmp = NULL;\n\t\t\tfor (n = index + 1; n <= nextindex; n++) {\n\t\t\t\tlh = (struct ldtentry *) & (p->slot[stbl[n]]);\n\t\t\t\tmodify_index(data->leaf.tid, data->leaf.ip,\n\t\t\t\t\t     le32_to_cpu(lh->index), bn, n,\n\t\t\t\t\t     &mp, &lblock);\n\t\t\t}\n\t\t\tif (mp)\n\t\t\t\trelease_metapage(mp);\n\t\t}\n\t}\n\n\tstbl[index] = hsi;\n\n\t \n\t++p->header.nextindex;\n}\n\n\n \nstatic void dtMoveEntry(dtpage_t * sp, int si, dtpage_t * dp,\n\t\t\tstruct dt_lock ** sdtlock, struct dt_lock ** ddtlock,\n\t\t\tint do_index)\n{\n\tint ssi, next;\t\t \n\tint di;\t\t\t \n\tint dsi;\t\t \n\ts8 *sstbl, *dstbl;\t \n\tint snamlen, len;\n\tstruct ldtentry *slh, *dlh = NULL;\n\tstruct idtentry *sih, *dih = NULL;\n\tstruct dtslot *h, *s, *d;\n\tstruct dt_lock *sdtlck = *sdtlock, *ddtlck = *ddtlock;\n\tstruct lv *slv, *dlv;\n\tint xssi, ns, nd;\n\tint sfsi;\n\n\tsstbl = (s8 *) & sp->slot[sp->header.stblindex];\n\tdstbl = (s8 *) & dp->slot[dp->header.stblindex];\n\n\tdsi = dp->header.freelist;\t \n\tsfsi = sp->header.freelist;\n\n\t \n\tdlv = & ddtlck->lv[ddtlck->index];\n\tdlv->offset = dsi;\n\n\t \n\tslv = & sdtlck->lv[sdtlck->index];\n\tslv->offset = sstbl[si];\n\txssi = slv->offset - 1;\n\n\t \n\tns = nd = 0;\n\tfor (di = 0; si < sp->header.nextindex; si++, di++) {\n\t\tssi = sstbl[si];\n\t\tdstbl[di] = dsi;\n\n\t\t \n\t\tif (ssi != xssi + 1) {\n\t\t\t \n\t\t\tslv->length = ns;\n\t\t\tsdtlck->index++;\n\n\t\t\t \n\t\t\tif (sdtlck->index < sdtlck->maxcnt)\n\t\t\t\tslv++;\n\t\t\telse {\n\t\t\t\tsdtlck = (struct dt_lock *) txLinelock(sdtlck);\n\t\t\t\tslv = & sdtlck->lv[0];\n\t\t\t}\n\n\t\t\tslv->offset = ssi;\n\t\t\tns = 0;\n\t\t}\n\n\t\t \n\t\t \n\t\th = d = &dp->slot[dsi];\n\n\t\t \n\t\ts = &sp->slot[ssi];\n\t\tif (sp->header.flag & BT_LEAF) {\n\t\t\t \n\t\t\tslh = (struct ldtentry *) s;\n\t\t\tdlh = (struct ldtentry *) h;\n\t\t\tsnamlen = slh->namlen;\n\n\t\t\tif (do_index) {\n\t\t\t\tlen = min(snamlen, DTLHDRDATALEN);\n\t\t\t\tdlh->index = slh->index;  \n\t\t\t} else\n\t\t\t\tlen = min(snamlen, DTLHDRDATALEN_LEGACY);\n\n\t\t\tmemcpy(dlh, slh, 6 + len * 2);\n\n\t\t\tnext = slh->next;\n\n\t\t\t \n\t\t\tdsi++;\n\t\t\tdlh->next = dsi;\n\t\t} else {\n\t\t\tsih = (struct idtentry *) s;\n\t\t\tsnamlen = sih->namlen;\n\n\t\t\tlen = min(snamlen, DTIHDRDATALEN);\n\t\t\tdih = (struct idtentry *) h;\n\t\t\tmemcpy(dih, sih, 10 + len * 2);\n\t\t\tnext = sih->next;\n\n\t\t\tdsi++;\n\t\t\tdih->next = dsi;\n\t\t}\n\n\t\t \n\t\ts->next = sfsi;\n\t\ts->cnt = 1;\n\t\tsfsi = ssi;\n\n\t\tns++;\n\t\tnd++;\n\t\txssi = ssi;\n\n\t\t \n\t\tsnamlen -= len;\n\t\twhile ((ssi = next) >= 0) {\n\t\t\t \n\t\t\tif (ssi != xssi + 1) {\n\t\t\t\t \n\t\t\t\tslv->length = ns;\n\t\t\t\tsdtlck->index++;\n\n\t\t\t\t \n\t\t\t\tif (sdtlck->index < sdtlck->maxcnt)\n\t\t\t\t\tslv++;\n\t\t\t\telse {\n\t\t\t\t\tsdtlck =\n\t\t\t\t\t    (struct dt_lock *)\n\t\t\t\t\t    txLinelock(sdtlck);\n\t\t\t\t\tslv = & sdtlck->lv[0];\n\t\t\t\t}\n\n\t\t\t\tslv->offset = ssi;\n\t\t\t\tns = 0;\n\t\t\t}\n\n\t\t\t \n\t\t\ts = &sp->slot[ssi];\n\n\t\t\t \n\t\t\td++;\n\n\t\t\tlen = min(snamlen, DTSLOTDATALEN);\n\t\t\tUniStrncpy_le(d->name, s->name, len);\n\n\t\t\tns++;\n\t\t\tnd++;\n\t\t\txssi = ssi;\n\n\t\t\tdsi++;\n\t\t\td->next = dsi;\n\n\t\t\t \n\t\t\tnext = s->next;\n\t\t\ts->next = sfsi;\n\t\t\ts->cnt = 1;\n\t\t\tsfsi = ssi;\n\n\t\t\tsnamlen -= len;\n\t\t}\t\t \n\n\t\t \n\t\tif (h == d) {\n\t\t\t \n\t\t\tif (dp->header.flag & BT_LEAF)\n\t\t\t\tdlh->next = -1;\n\t\t\telse\n\t\t\t\tdih->next = -1;\n\t\t} else\n\t\t\t \n\t\t\td->next = -1;\n\t}\t\t\t \n\n\t \n\tslv->length = ns;\n\tsdtlck->index++;\n\t*sdtlock = sdtlck;\n\n\tdlv->length = nd;\n\tddtlck->index++;\n\t*ddtlock = ddtlck;\n\n\t \n\tsp->header.freelist = sfsi;\n\tsp->header.freecnt += nd;\n\n\t \n\tdp->header.nextindex = di;\n\n\tdp->header.freelist = dsi;\n\tdp->header.freecnt -= nd;\n}\n\n\n \nstatic void dtDeleteEntry(dtpage_t * p, int fi, struct dt_lock ** dtlock)\n{\n\tint fsi;\t\t \n\ts8 *stbl;\n\tstruct dtslot *t;\n\tint si, freecnt;\n\tstruct dt_lock *dtlck = *dtlock;\n\tstruct lv *lv;\n\tint xsi, n;\n\n\t \n\tstbl = DT_GETSTBL(p);\n\tfsi = stbl[fi];\n\n\t \n\tif (dtlck->index >= dtlck->maxcnt)\n\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\tlv = & dtlck->lv[dtlck->index];\n\n\tlv->offset = fsi;\n\n\t \n\tt = &p->slot[fsi];\n\tif (p->header.flag & BT_LEAF)\n\t\tsi = ((struct ldtentry *) t)->next;\n\telse\n\t\tsi = ((struct idtentry *) t)->next;\n\tt->next = si;\n\tt->cnt = 1;\n\n\tn = freecnt = 1;\n\txsi = fsi;\n\n\t \n\twhile (si >= 0) {\n\t\t \n\t\tif (si != xsi + 1) {\n\t\t\t \n\t\t\tlv->length = n;\n\t\t\tdtlck->index++;\n\n\t\t\t \n\t\t\tif (dtlck->index < dtlck->maxcnt)\n\t\t\t\tlv++;\n\t\t\telse {\n\t\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\t\t\tlv = & dtlck->lv[0];\n\t\t\t}\n\n\t\t\tlv->offset = si;\n\t\t\tn = 0;\n\t\t}\n\n\t\tn++;\n\t\txsi = si;\n\t\tfreecnt++;\n\n\t\tt = &p->slot[si];\n\t\tt->cnt = 1;\n\t\tsi = t->next;\n\t}\n\n\t \n\tlv->length = n;\n\tdtlck->index++;\n\n\t*dtlock = dtlck;\n\n\t \n\tt->next = p->header.freelist;\n\tp->header.freelist = fsi;\n\tp->header.freecnt += freecnt;\n\n\t \n\tsi = p->header.nextindex;\n\tif (fi < si - 1)\n\t\tmemmove(&stbl[fi], &stbl[fi + 1], si - fi - 1);\n\n\tp->header.nextindex--;\n}\n\n\n \nstatic void dtTruncateEntry(dtpage_t * p, int ti, struct dt_lock ** dtlock)\n{\n\tint tsi;\t\t \n\ts8 *stbl;\n\tstruct dtslot *t;\n\tint si, freecnt;\n\tstruct dt_lock *dtlck = *dtlock;\n\tstruct lv *lv;\n\tint fsi, xsi, n;\n\n\t \n\tstbl = DT_GETSTBL(p);\n\ttsi = stbl[ti];\n\n\t \n\tif (dtlck->index >= dtlck->maxcnt)\n\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\tlv = & dtlck->lv[dtlck->index];\n\n\tlv->offset = tsi;\n\n\t \n\tt = &p->slot[tsi];\n\tASSERT(p->header.flag & BT_INTERNAL);\n\t((struct idtentry *) t)->namlen = 0;\n\tsi = ((struct idtentry *) t)->next;\n\t((struct idtentry *) t)->next = -1;\n\n\tn = 1;\n\tfreecnt = 0;\n\tfsi = si;\n\txsi = tsi;\n\n\t \n\twhile (si >= 0) {\n\t\t \n\t\tif (si != xsi + 1) {\n\t\t\t \n\t\t\tlv->length = n;\n\t\t\tdtlck->index++;\n\n\t\t\t \n\t\t\tif (dtlck->index < dtlck->maxcnt)\n\t\t\t\tlv++;\n\t\t\telse {\n\t\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\t\t\tlv = & dtlck->lv[0];\n\t\t\t}\n\n\t\t\tlv->offset = si;\n\t\t\tn = 0;\n\t\t}\n\n\t\tn++;\n\t\txsi = si;\n\t\tfreecnt++;\n\n\t\tt = &p->slot[si];\n\t\tt->cnt = 1;\n\t\tsi = t->next;\n\t}\n\n\t \n\tlv->length = n;\n\tdtlck->index++;\n\n\t*dtlock = dtlck;\n\n\t \n\tif (freecnt == 0)\n\t\treturn;\n\tt->next = p->header.freelist;\n\tp->header.freelist = fsi;\n\tp->header.freecnt += freecnt;\n}\n\n\n \nstatic void dtLinelockFreelist(dtpage_t * p,\t \n\t\t\t       int m,\t \n\t\t\t       struct dt_lock ** dtlock)\n{\n\tint fsi;\t\t \n\tstruct dtslot *t;\n\tint si;\n\tstruct dt_lock *dtlck = *dtlock;\n\tstruct lv *lv;\n\tint xsi, n;\n\n\t \n\tfsi = p->header.freelist;\n\n\t \n\tif (dtlck->index >= dtlck->maxcnt)\n\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\tlv = & dtlck->lv[dtlck->index];\n\n\tlv->offset = fsi;\n\n\tn = 1;\n\txsi = fsi;\n\n\tt = &p->slot[fsi];\n\tsi = t->next;\n\n\t \n\twhile (si < m && si >= 0) {\n\t\t \n\t\tif (si != xsi + 1) {\n\t\t\t \n\t\t\tlv->length = n;\n\t\t\tdtlck->index++;\n\n\t\t\t \n\t\t\tif (dtlck->index < dtlck->maxcnt)\n\t\t\t\tlv++;\n\t\t\telse {\n\t\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\t\t\tlv = & dtlck->lv[0];\n\t\t\t}\n\n\t\t\tlv->offset = si;\n\t\t\tn = 0;\n\t\t}\n\n\t\tn++;\n\t\txsi = si;\n\n\t\tt = &p->slot[si];\n\t\tsi = t->next;\n\t}\n\n\t \n\tlv->length = n;\n\tdtlck->index++;\n\n\t*dtlock = dtlck;\n}\n\n\n \nint dtModify(tid_t tid, struct inode *ip,\n\t struct component_name * key, ino_t * orig_ino, ino_t new_ino, int flag)\n{\n\tint rc;\n\ts64 bn;\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\tint index;\n\tstruct btstack btstack;\n\tstruct tlock *tlck;\n\tstruct dt_lock *dtlck;\n\tstruct lv *lv;\n\ts8 *stbl;\n\tint entry_si;\t\t \n\tstruct ldtentry *entry;\n\n\t \n\tif ((rc = dtSearch(ip, key, orig_ino, &btstack, flag)))\n\t\treturn rc;\n\n\t \n\tDT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\tBT_MARK_DIRTY(mp, ip);\n\t \n\ttlck = txLock(tid, ip, mp, tlckDTREE | tlckENTRY);\n\tdtlck = (struct dt_lock *) & tlck->lock;\n\n\t \n\tstbl = DT_GETSTBL(p);\n\tentry_si = stbl[index];\n\n\t \n\tASSERT(dtlck->index == 0);\n\tlv = & dtlck->lv[0];\n\tlv->offset = entry_si;\n\tlv->length = 1;\n\tdtlck->index++;\n\n\t \n\tentry = (struct ldtentry *) & p->slot[entry_si];\n\n\t \n\tentry->inumber = cpu_to_le32(new_ino);\n\n\t \n\tDT_PUTPAGE(mp);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}