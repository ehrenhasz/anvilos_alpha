{
  "module_name": "jfs_types.h",
  "hash_id": "bcd904c584cfc7d6ad763887d8cd92340e853bd15cc16ec1b3aaaaf73374c2a8",
  "original_prompt": "Ingested from linux-6.6.14/fs/jfs/jfs_types.h",
  "human_readable_source": " \n \n#ifndef _H_JFS_TYPES\n#define\t_H_JFS_TYPES\n\n \n\n#include <linux/types.h>\n#include <linux/nls.h>\n\n \ntypedef u16 tid_t;\ntypedef u16 lid_t;\n\n \nstruct timestruc_t {\n\t__le32 tv_sec;\n\t__le32 tv_nsec;\n};\n\n \n\n#define LEFTMOSTONE\t0x80000000\n#define\tHIGHORDER\t0x80000000u\t \n#define\tONES\t\t0xffffffffu\t \n\n \ntypedef struct {\n\t__le32 len_addr;\n\t__le32 addr2;\n} pxd_t;\n\n \n\nstatic inline void PXDlength(pxd_t *pxd, __u32 len)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(~0xffffff)) |\n\t\t\tcpu_to_le32(len & 0xffffff);\n}\n\nstatic inline void PXDaddress(pxd_t *pxd, __u64 addr)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(0xffffff)) |\n\t\t\tcpu_to_le32((addr >> 32)<<24);\n\tpxd->addr2 = cpu_to_le32(addr & 0xffffffff);\n}\n\n \nstatic inline __u32 lengthPXD(pxd_t *pxd)\n{\n\treturn le32_to_cpu((pxd)->len_addr) & 0xffffff;\n}\n\nstatic inline __u64 addressPXD(pxd_t *pxd)\n{\n\t__u64 n = le32_to_cpu(pxd->len_addr) & ~0xffffff;\n\treturn (n << 8) + le32_to_cpu(pxd->addr2);\n}\n\n#define MAXTREEHEIGHT 8\n \nstruct pxdlist {\n\ts16 maxnpxd;\n\ts16 npxd;\n\tpxd_t pxd[MAXTREEHEIGHT];\n};\n\n\n \ntypedef struct {\n\t__u8 flag;\t \n\t__u8 rsrvd[3];\n\t__le32 size;\t\t \n\tpxd_t loc;\t\t \n} dxd_t;\t\t\t \n\n \n#define\tDXD_INDEX\t0x80\t \n#define\tDXD_INLINE\t0x40\t \n#define\tDXD_EXTENT\t0x20\t \n#define\tDXD_FILE\t0x10\t \n#define DXD_CORRUPT\t0x08\t \n\n \n#define\tDXDlength(dxd, len)\tPXDlength(&(dxd)->loc, len)\n#define\tDXDaddress(dxd, addr)\tPXDaddress(&(dxd)->loc, addr)\n#define\tlengthDXD(dxd)\tlengthPXD(&(dxd)->loc)\n#define\taddressDXD(dxd)\taddressPXD(&(dxd)->loc)\n#define DXDsize(dxd, size32) ((dxd)->size = cpu_to_le32(size32))\n#define sizeDXD(dxd)\tle32_to_cpu((dxd)->size)\n\n \nstruct component_name {\n\tint namlen;\n\twchar_t *name;\n};\n\n\n \nstruct dasd {\n\tu8 thresh;\t\t \n\tu8 delta;\t\t \n\tu8 rsrvd1;\n\tu8 limit_hi;\t\t \n\t__le32 limit_lo;\t \n\tu8 rsrvd2[3];\n\tu8 used_hi;\t\t \n\t__le32 used_lo;\t\t \n};\n\n#define DASDLIMIT(dasdp) \\\n\t(((u64)((dasdp)->limit_hi) << 32) + __le32_to_cpu((dasdp)->limit_lo))\n#define setDASDLIMIT(dasdp, limit)\\\n{\\\n\t(dasdp)->limit_hi = ((u64)limit) >> 32;\\\n\t(dasdp)->limit_lo = __cpu_to_le32(limit);\\\n}\n#define DASDUSED(dasdp) \\\n\t(((u64)((dasdp)->used_hi) << 32) + __le32_to_cpu((dasdp)->used_lo))\n#define setDASDUSED(dasdp, used)\\\n{\\\n\t(dasdp)->used_hi = ((u64)used) >> 32;\\\n\t(dasdp)->used_lo = __cpu_to_le32(used);\\\n}\n\n#endif\t\t\t\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}