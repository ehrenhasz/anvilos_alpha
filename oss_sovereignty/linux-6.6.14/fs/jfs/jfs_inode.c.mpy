{
  "module_name": "jfs_inode.c",
  "hash_id": "b3658edaff622246a3d910a80d74261c93d841ff41fe4e3bd6c94967e2593a98",
  "original_prompt": "Ingested from linux-6.6.14/fs/jfs/jfs_inode.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/quotaops.h>\n#include \"jfs_incore.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_debug.h\"\n\n\nvoid jfs_set_inode_flags(struct inode *inode)\n{\n\tunsigned int flags = JFS_IP(inode)->mode2;\n\tunsigned int new_fl = 0;\n\n\tif (flags & JFS_IMMUTABLE_FL)\n\t\tnew_fl |= S_IMMUTABLE;\n\tif (flags & JFS_APPEND_FL)\n\t\tnew_fl |= S_APPEND;\n\tif (flags & JFS_NOATIME_FL)\n\t\tnew_fl |= S_NOATIME;\n\tif (flags & JFS_DIRSYNC_FL)\n\t\tnew_fl |= S_DIRSYNC;\n\tif (flags & JFS_SYNC_FL)\n\t\tnew_fl |= S_SYNC;\n\tinode_set_flags(inode, new_fl, S_IMMUTABLE | S_APPEND | S_NOATIME |\n\t\t\tS_DIRSYNC | S_SYNC);\n}\n\n \nstruct inode *ialloc(struct inode *parent, umode_t mode)\n{\n\tstruct super_block *sb = parent->i_sb;\n\tstruct inode *inode;\n\tstruct jfs_inode_info *jfs_inode;\n\tint rc;\n\n\tinode = new_inode(sb);\n\tif (!inode) {\n\t\tjfs_warn(\"ialloc: new_inode returned NULL!\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tjfs_inode = JFS_IP(inode);\n\n\trc = diAlloc(parent, S_ISDIR(mode), inode);\n\tif (rc) {\n\t\tjfs_warn(\"ialloc: diAlloc returned %d!\", rc);\n\t\tgoto fail_put;\n\t}\n\n\tif (insert_inode_locked(inode) < 0) {\n\t\trc = -EINVAL;\n\t\tgoto fail_put;\n\t}\n\n\tinode_init_owner(&nop_mnt_idmap, inode, parent, mode);\n\t \n\tjfs_inode->saved_uid = inode->i_uid;\n\tjfs_inode->saved_gid = inode->i_gid;\n\n\t \n\trc = dquot_initialize(inode);\n\tif (rc)\n\t\tgoto fail_drop;\n\trc = dquot_alloc_inode(inode);\n\tif (rc)\n\t\tgoto fail_drop;\n\n\t \n\tjfs_inode->mode2 = JFS_IP(parent)->mode2 & JFS_FL_INHERIT;\n\n\tif (S_ISDIR(mode)) {\n\t\tjfs_inode->mode2 |= IDIRECTORY;\n\t\tjfs_inode->mode2 &= ~JFS_DIRSYNC_FL;\n\t}\n\telse {\n\t\tjfs_inode->mode2 |= INLINEEA | ISPARSE;\n\t\tif (S_ISLNK(mode))\n\t\t\tjfs_inode->mode2 &= ~(JFS_IMMUTABLE_FL|JFS_APPEND_FL);\n\t}\n\tjfs_inode->mode2 |= inode->i_mode;\n\n\tinode->i_blocks = 0;\n\tinode->i_mtime = inode->i_atime = inode_set_ctime_current(inode);\n\tjfs_inode->otime = inode_get_ctime(inode).tv_sec;\n\tinode->i_generation = JFS_SBI(sb)->gengen++;\n\n\tjfs_inode->cflag = 0;\n\n\t \n\tmemset(&jfs_inode->acl, 0, sizeof(dxd_t));\n\tmemset(&jfs_inode->ea, 0, sizeof(dxd_t));\n\tjfs_inode->next_index = 0;\n\tjfs_inode->acltype = 0;\n\tjfs_inode->btorder = 0;\n\tjfs_inode->btindex = 0;\n\tjfs_inode->bxflag = 0;\n\tjfs_inode->blid = 0;\n\tjfs_inode->atlhead = 0;\n\tjfs_inode->atltail = 0;\n\tjfs_inode->xtlid = 0;\n\tjfs_set_inode_flags(inode);\n\n\tjfs_info(\"ialloc returns inode = 0x%p\", inode);\n\n\treturn inode;\n\nfail_drop:\n\tdquot_drop(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tclear_nlink(inode);\n\tdiscard_new_inode(inode);\n\treturn ERR_PTR(rc);\n\nfail_put:\n\tiput(inode);\n\treturn ERR_PTR(rc);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}