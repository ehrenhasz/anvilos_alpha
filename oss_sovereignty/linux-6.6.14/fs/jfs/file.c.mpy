{
  "module_name": "file.c",
  "hash_id": "c7f2a67c10c6bdbe0115c83c4b4f22aed89c6b2a2c18c7b521c4076d8bf96243",
  "original_prompt": "Ingested from linux-6.6.14/fs/jfs/file.c",
  "human_readable_source": "\n \n\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/posix_acl.h>\n#include <linux/quotaops.h>\n#include \"jfs_incore.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_debug.h\"\n\nint jfs_fsync(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tint rc = 0;\n\n\trc = file_write_and_wait_range(file, start, end);\n\tif (rc)\n\t\treturn rc;\n\n\tinode_lock(inode);\n\tif (!(inode->i_state & I_DIRTY_ALL) ||\n\t    (datasync && !(inode->i_state & I_DIRTY_DATASYNC))) {\n\t\t \n\t\tjfs_flush_journal(JFS_SBI(inode->i_sb)->log, 1);\n\t\tinode_unlock(inode);\n\t\treturn rc;\n\t}\n\n\trc |= jfs_commit_inode(inode, 1);\n\tinode_unlock(inode);\n\n\treturn rc ? -EIO : 0;\n}\n\nstatic int jfs_open(struct inode *inode, struct file *file)\n{\n\tint rc;\n\n\tif ((rc = dquot_file_open(inode, file)))\n\t\treturn rc;\n\n\t \n\tif (S_ISREG(inode->i_mode) && file->f_mode & FMODE_WRITE &&\n\t    (inode->i_size == 0)) {\n\t\tstruct jfs_inode_info *ji = JFS_IP(inode);\n\t\tspin_lock_irq(&ji->ag_lock);\n\t\tif (ji->active_ag == -1) {\n\t\t\tstruct jfs_sb_info *jfs_sb = JFS_SBI(inode->i_sb);\n\t\t\tji->active_ag = BLKTOAG(addressPXD(&ji->ixpxd), jfs_sb);\n\t\t\tatomic_inc(&jfs_sb->bmap->db_active[ji->active_ag]);\n\t\t}\n\t\tspin_unlock_irq(&ji->ag_lock);\n\t}\n\n\treturn 0;\n}\nstatic int jfs_release(struct inode *inode, struct file *file)\n{\n\tstruct jfs_inode_info *ji = JFS_IP(inode);\n\n\tspin_lock_irq(&ji->ag_lock);\n\tif (ji->active_ag != -1) {\n\t\tstruct bmap *bmap = JFS_SBI(inode->i_sb)->bmap;\n\t\tatomic_dec(&bmap->db_active[ji->active_ag]);\n\t\tji->active_ag = -1;\n\t}\n\tspin_unlock_irq(&ji->ag_lock);\n\n\treturn 0;\n}\n\nint jfs_setattr(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\tstruct iattr *iattr)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tint rc;\n\n\trc = setattr_prepare(&nop_mnt_idmap, dentry, iattr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (is_quota_modification(&nop_mnt_idmap, inode, iattr)) {\n\t\trc = dquot_initialize(inode);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\tif ((iattr->ia_valid & ATTR_UID && !uid_eq(iattr->ia_uid, inode->i_uid)) ||\n\t    (iattr->ia_valid & ATTR_GID && !gid_eq(iattr->ia_gid, inode->i_gid))) {\n\t\trc = dquot_transfer(&nop_mnt_idmap, inode, iattr);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tif ((iattr->ia_valid & ATTR_SIZE) &&\n\t    iattr->ia_size != i_size_read(inode)) {\n\t\tinode_dio_wait(inode);\n\n\t\trc = inode_newsize_ok(inode, iattr->ia_size);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\ttruncate_setsize(inode, iattr->ia_size);\n\t\tjfs_truncate(inode);\n\t}\n\n\tsetattr_copy(&nop_mnt_idmap, inode, iattr);\n\tmark_inode_dirty(inode);\n\n\tif (iattr->ia_valid & ATTR_MODE)\n\t\trc = posix_acl_chmod(&nop_mnt_idmap, dentry, inode->i_mode);\n\treturn rc;\n}\n\nconst struct inode_operations jfs_file_inode_operations = {\n\t.listxattr\t= jfs_listxattr,\n\t.setattr\t= jfs_setattr,\n\t.fileattr_get\t= jfs_fileattr_get,\n\t.fileattr_set\t= jfs_fileattr_set,\n#ifdef CONFIG_JFS_POSIX_ACL\n\t.get_inode_acl\t= jfs_get_acl,\n\t.set_acl\t= jfs_set_acl,\n#endif\n};\n\nconst struct file_operations jfs_file_operations = {\n\t.open\t\t= jfs_open,\n\t.llseek\t\t= generic_file_llseek,\n\t.read_iter\t= generic_file_read_iter,\n\t.write_iter\t= generic_file_write_iter,\n\t.mmap\t\t= generic_file_mmap,\n\t.splice_read\t= filemap_splice_read,\n\t.splice_write\t= iter_file_splice_write,\n\t.fsync\t\t= jfs_fsync,\n\t.release\t= jfs_release,\n\t.unlocked_ioctl = jfs_ioctl,\n\t.compat_ioctl\t= compat_ptr_ioctl,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}