{
  "module_name": "inode.c",
  "hash_id": "7527249cf689726f91930427c417c52fddce4020a5d7ffc9e0a7907a223cde61",
  "original_prompt": "Ingested from linux-6.6.14/fs/openpromfs/inode.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/fs_context.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/magic.h>\n\n#include <asm/openprom.h>\n#include <asm/oplib.h>\n#include <asm/prom.h>\n#include <linux/uaccess.h>\n\nstatic DEFINE_MUTEX(op_mutex);\n\n#define OPENPROM_ROOT_INO\t0\n\nenum op_inode_type {\n\top_inode_node,\n\top_inode_prop,\n};\n\nunion op_inode_data {\n\tstruct device_node\t*node;\n\tstruct property\t\t*prop;\n};\n\nstruct op_inode_info {\n\tstruct inode\t\tvfs_inode;\n\tenum op_inode_type\ttype;\n\tunion op_inode_data\tu;\n};\n\nstatic struct inode *openprom_iget(struct super_block *sb, ino_t ino);\n\nstatic inline struct op_inode_info *OP_I(struct inode *inode)\n{\n\treturn container_of(inode, struct op_inode_info, vfs_inode);\n}\n\nstatic int is_string(unsigned char *p, int len)\n{\n\tint i;\n\n\tfor (i = 0; i < len; i++) {\n\t\tunsigned char val = p[i];\n\n\t\tif ((i && !val) ||\n\t\t    (val >= ' ' && val <= '~'))\n\t\t\tcontinue;\n\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int property_show(struct seq_file *f, void *v)\n{\n\tstruct property *prop = f->private;\n\tvoid *pval;\n\tint len;\n\n\tlen = prop->length;\n\tpval = prop->value;\n\n\tif (is_string(pval, len)) {\n\t\twhile (len > 0) {\n\t\t\tint n = strlen(pval);\n\n\t\t\tseq_printf(f, \"%s\", (char *) pval);\n\n\t\t\t \n\t\t\tpval += n + 1;\n\t\t\tlen -= n + 1;\n\n\t\t\tif (len > 0)\n\t\t\t\tseq_printf(f, \" + \");\n\t\t}\n\t} else {\n\t\tif (len & 3) {\n\t\t\twhile (len) {\n\t\t\t\tlen--;\n\t\t\t\tif (len)\n\t\t\t\t\tseq_printf(f, \"%02x.\",\n\t\t\t\t\t\t   *(unsigned char *) pval);\n\t\t\t\telse\n\t\t\t\t\tseq_printf(f, \"%02x\",\n\t\t\t\t\t\t   *(unsigned char *) pval);\n\t\t\t\tpval++;\n\t\t\t}\n\t\t} else {\n\t\t\twhile (len >= 4) {\n\t\t\t\tlen -= 4;\n\n\t\t\t\tif (len)\n\t\t\t\t\tseq_printf(f, \"%08x.\",\n\t\t\t\t\t\t   *(unsigned int *) pval);\n\t\t\t\telse\n\t\t\t\t\tseq_printf(f, \"%08x\",\n\t\t\t\t\t\t   *(unsigned int *) pval);\n\t\t\t\tpval += 4;\n\t\t\t}\n\t\t}\n\t}\n\tseq_printf(f, \"\\n\");\n\n\treturn 0;\n}\n\nstatic void *property_start(struct seq_file *f, loff_t *pos)\n{\n\tif (*pos == 0)\n\t\treturn pos;\n\treturn NULL;\n}\n\nstatic void *property_next(struct seq_file *f, void *v, loff_t *pos)\n{\n\t(*pos)++;\n\treturn NULL;\n}\n\nstatic void property_stop(struct seq_file *f, void *v)\n{\n\t \n}\n\nstatic const struct seq_operations property_op = {\n\t.start\t\t= property_start,\n\t.next\t\t= property_next,\n\t.stop\t\t= property_stop,\n\t.show\t\t= property_show\n};\n\nstatic int property_open(struct inode *inode, struct file *file)\n{\n\tstruct op_inode_info *oi = OP_I(inode);\n\tint ret;\n\n\tBUG_ON(oi->type != op_inode_prop);\n\n\tret = seq_open(file, &property_op);\n\tif (!ret) {\n\t\tstruct seq_file *m = file->private_data;\n\t\tm->private = oi->u.prop;\n\t}\n\treturn ret;\n}\n\nstatic const struct file_operations openpromfs_prop_ops = {\n\t.open\t\t= property_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n};\n\nstatic int openpromfs_readdir(struct file *, struct dir_context *);\n\nstatic const struct file_operations openprom_operations = {\n\t.read\t\t= generic_read_dir,\n\t.iterate_shared\t= openpromfs_readdir,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic struct dentry *openpromfs_lookup(struct inode *, struct dentry *, unsigned int);\n\nstatic const struct inode_operations openprom_inode_operations = {\n\t.lookup\t\t= openpromfs_lookup,\n};\n\nstatic struct dentry *openpromfs_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags)\n{\n\tstruct op_inode_info *ent_oi, *oi = OP_I(dir);\n\tstruct device_node *dp, *child;\n\tstruct property *prop;\n\tenum op_inode_type ent_type;\n\tunion op_inode_data ent_data;\n\tconst char *name;\n\tstruct inode *inode;\n\tunsigned int ino;\n\tint len;\n\t\n\tBUG_ON(oi->type != op_inode_node);\n\n\tdp = oi->u.node;\n\n\tname = dentry->d_name.name;\n\tlen = dentry->d_name.len;\n\n\tmutex_lock(&op_mutex);\n\n\tchild = dp->child;\n\twhile (child) {\n\t\tconst char *node_name = kbasename(child->full_name);\n\t\tint n = strlen(node_name);\n\n\t\tif (len == n &&\n\t\t    !strncmp(node_name, name, len)) {\n\t\t\tent_type = op_inode_node;\n\t\t\tent_data.node = child;\n\t\t\tino = child->unique_id;\n\t\t\tgoto found;\n\t\t}\n\t\tchild = child->sibling;\n\t}\n\n\tprop = dp->properties;\n\twhile (prop) {\n\t\tint n = strlen(prop->name);\n\n\t\tif (len == n && !strncmp(prop->name, name, len)) {\n\t\t\tent_type = op_inode_prop;\n\t\t\tent_data.prop = prop;\n\t\t\tino = prop->unique_id;\n\t\t\tgoto found;\n\t\t}\n\n\t\tprop = prop->next;\n\t}\n\n\tmutex_unlock(&op_mutex);\n\treturn ERR_PTR(-ENOENT);\n\nfound:\n\tinode = openprom_iget(dir->i_sb, ino);\n\tmutex_unlock(&op_mutex);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\tif (inode->i_state & I_NEW) {\n\t\tinode->i_mtime = inode->i_atime = inode_set_ctime_current(inode);\n\t\tent_oi = OP_I(inode);\n\t\tent_oi->type = ent_type;\n\t\tent_oi->u = ent_data;\n\n\t\tswitch (ent_type) {\n\t\tcase op_inode_node:\n\t\t\tinode->i_mode = S_IFDIR | S_IRUGO | S_IXUGO;\n\t\t\tinode->i_op = &openprom_inode_operations;\n\t\t\tinode->i_fop = &openprom_operations;\n\t\t\tset_nlink(inode, 2);\n\t\t\tbreak;\n\t\tcase op_inode_prop:\n\t\t\tif (of_node_name_eq(dp, \"options\") && (len == 17) &&\n\t\t\t    !strncmp (name, \"security-password\", 17))\n\t\t\t\tinode->i_mode = S_IFREG | S_IRUSR | S_IWUSR;\n\t\t\telse\n\t\t\t\tinode->i_mode = S_IFREG | S_IRUGO;\n\t\t\tinode->i_fop = &openpromfs_prop_ops;\n\t\t\tset_nlink(inode, 1);\n\t\t\tinode->i_size = ent_oi->u.prop->length;\n\t\t\tbreak;\n\t\t}\n\t\tunlock_new_inode(inode);\n\t}\n\n\treturn d_splice_alias(inode, dentry);\n}\n\nstatic int openpromfs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct op_inode_info *oi = OP_I(inode);\n\tstruct device_node *dp = oi->u.node;\n\tstruct device_node *child;\n\tstruct property *prop;\n\tint i;\n\n\tmutex_lock(&op_mutex);\n\t\n\tif (ctx->pos == 0) {\n\t\tif (!dir_emit(ctx, \".\", 1, inode->i_ino, DT_DIR))\n\t\t\tgoto out;\n\t\tctx->pos = 1;\n\t}\n\tif (ctx->pos == 1) {\n\t\tif (!dir_emit(ctx, \"..\", 2,\n\t\t\t    (dp->parent == NULL ?\n\t\t\t     OPENPROM_ROOT_INO :\n\t\t\t     dp->parent->unique_id), DT_DIR))\n\t\t\tgoto out;\n\t\tctx->pos = 2;\n\t}\n\ti = ctx->pos - 2;\n\n\t \n\tchild = dp->child;\n\twhile (i && child) {\n\t\tchild = child->sibling;\n\t\ti--;\n\t}\n\twhile (child) {\n\t\tif (!dir_emit(ctx,\n\t\t\t    kbasename(child->full_name),\n\t\t\t    strlen(kbasename(child->full_name)),\n\t\t\t    child->unique_id, DT_DIR))\n\t\t\tgoto out;\n\n\t\tctx->pos++;\n\t\tchild = child->sibling;\n\t}\n\n\t \n\tprop = dp->properties;\n\twhile (i && prop) {\n\t\tprop = prop->next;\n\t\ti--;\n\t}\n\twhile (prop) {\n\t\tif (!dir_emit(ctx, prop->name, strlen(prop->name),\n\t\t\t    prop->unique_id, DT_REG))\n\t\t\tgoto out;\n\n\t\tctx->pos++;\n\t\tprop = prop->next;\n\t}\n\nout:\n\tmutex_unlock(&op_mutex);\n\treturn 0;\n}\n\nstatic struct kmem_cache *op_inode_cachep;\n\nstatic struct inode *openprom_alloc_inode(struct super_block *sb)\n{\n\tstruct op_inode_info *oi;\n\n\toi = alloc_inode_sb(sb, op_inode_cachep, GFP_KERNEL);\n\tif (!oi)\n\t\treturn NULL;\n\n\treturn &oi->vfs_inode;\n}\n\nstatic void openprom_free_inode(struct inode *inode)\n{\n\tkmem_cache_free(op_inode_cachep, OP_I(inode));\n}\n\nstatic struct inode *openprom_iget(struct super_block *sb, ino_t ino)\n{\n\tstruct inode *inode = iget_locked(sb, ino);\n\tif (!inode)\n\t\tinode = ERR_PTR(-ENOMEM);\n\treturn inode;\n}\n\nstatic int openprom_remount(struct super_block *sb, int *flags, char *data)\n{\n\tsync_filesystem(sb);\n\t*flags |= SB_NOATIME;\n\treturn 0;\n}\n\nstatic const struct super_operations openprom_sops = {\n\t.alloc_inode\t= openprom_alloc_inode,\n\t.free_inode\t= openprom_free_inode,\n\t.statfs\t\t= simple_statfs,\n\t.remount_fs\t= openprom_remount,\n};\n\nstatic int openprom_fill_super(struct super_block *s, struct fs_context *fc)\n{\n\tstruct inode *root_inode;\n\tstruct op_inode_info *oi;\n\tint ret;\n\n\ts->s_flags |= SB_NOATIME;\n\ts->s_blocksize = 1024;\n\ts->s_blocksize_bits = 10;\n\ts->s_magic = OPENPROM_SUPER_MAGIC;\n\ts->s_op = &openprom_sops;\n\ts->s_time_gran = 1;\n\troot_inode = openprom_iget(s, OPENPROM_ROOT_INO);\n\tif (IS_ERR(root_inode)) {\n\t\tret = PTR_ERR(root_inode);\n\t\tgoto out_no_root;\n\t}\n\n\troot_inode->i_mtime = root_inode->i_atime = inode_set_ctime_current(root_inode);\n\troot_inode->i_op = &openprom_inode_operations;\n\troot_inode->i_fop = &openprom_operations;\n\troot_inode->i_mode = S_IFDIR | S_IRUGO | S_IXUGO;\n\toi = OP_I(root_inode);\n\toi->type = op_inode_node;\n\toi->u.node = of_find_node_by_path(\"/\");\n\tunlock_new_inode(root_inode);\n\n\ts->s_root = d_make_root(root_inode);\n\tif (!s->s_root)\n\t\tgoto out_no_root_dentry;\n\treturn 0;\n\nout_no_root_dentry:\n\tret = -ENOMEM;\nout_no_root:\n\tprintk(\"openprom_fill_super: get root inode failed\\n\");\n\treturn ret;\n}\n\nstatic int openpromfs_get_tree(struct fs_context *fc)\n{\n\treturn get_tree_single(fc, openprom_fill_super);\n}\n\nstatic const struct fs_context_operations openpromfs_context_ops = {\n\t.get_tree\t= openpromfs_get_tree,\n};\n\nstatic int openpromfs_init_fs_context(struct fs_context *fc)\n{\n\tfc->ops = &openpromfs_context_ops;\n\treturn 0;\n}\n\nstatic struct file_system_type openprom_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"openpromfs\",\n\t.init_fs_context = openpromfs_init_fs_context,\n\t.kill_sb\t= kill_anon_super,\n};\nMODULE_ALIAS_FS(\"openpromfs\");\n\nstatic void op_inode_init_once(void *data)\n{\n\tstruct op_inode_info *oi = (struct op_inode_info *) data;\n\n\tinode_init_once(&oi->vfs_inode);\n}\n\nstatic int __init init_openprom_fs(void)\n{\n\tint err;\n\n\top_inode_cachep = kmem_cache_create(\"op_inode_cache\",\n\t\t\t\t\t    sizeof(struct op_inode_info),\n\t\t\t\t\t    0,\n\t\t\t\t\t    (SLAB_RECLAIM_ACCOUNT |\n\t\t\t\t\t     SLAB_MEM_SPREAD | SLAB_ACCOUNT),\n\t\t\t\t\t    op_inode_init_once);\n\tif (!op_inode_cachep)\n\t\treturn -ENOMEM;\n\n\terr = register_filesystem(&openprom_fs_type);\n\tif (err)\n\t\tkmem_cache_destroy(op_inode_cachep);\n\n\treturn err;\n}\n\nstatic void __exit exit_openprom_fs(void)\n{\n\tunregister_filesystem(&openprom_fs_type);\n\t \n\trcu_barrier();\n\tkmem_cache_destroy(op_inode_cachep);\n}\n\nmodule_init(init_openprom_fs)\nmodule_exit(exit_openprom_fs)\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}