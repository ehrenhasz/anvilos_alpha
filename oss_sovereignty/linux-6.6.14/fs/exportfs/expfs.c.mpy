{
  "module_name": "expfs.c",
  "hash_id": "c7ac9a6489a535c872aa875412db1c588cf1039d38c7f766121a74e1ae354cc5",
  "original_prompt": "Ingested from linux-6.6.14/fs/exportfs/expfs.c",
  "human_readable_source": "\n \n#include <linux/exportfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/cred.h>\n\n#define dprintk(fmt, args...) pr_debug(fmt, ##args)\n\n\nstatic int get_name(const struct path *path, char *name, struct dentry *child);\n\n\nstatic int exportfs_get_name(struct vfsmount *mnt, struct dentry *dir,\n\t\tchar *name, struct dentry *child)\n{\n\tconst struct export_operations *nop = dir->d_sb->s_export_op;\n\tstruct path path = {.mnt = mnt, .dentry = dir};\n\n\tif (nop->get_name)\n\t\treturn nop->get_name(dir, name, child);\n\telse\n\t\treturn get_name(&path, name, child);\n}\n\n \nstatic struct dentry *\nfind_acceptable_alias(struct dentry *result,\n\t\tint (*acceptable)(void *context, struct dentry *dentry),\n\t\tvoid *context)\n{\n\tstruct dentry *dentry, *toput = NULL;\n\tstruct inode *inode;\n\n\tif (acceptable(context, result))\n\t\treturn result;\n\n\tinode = result->d_inode;\n\tspin_lock(&inode->i_lock);\n\thlist_for_each_entry(dentry, &inode->i_dentry, d_u.d_alias) {\n\t\tdget(dentry);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (toput)\n\t\t\tdput(toput);\n\t\tif (dentry != result && acceptable(context, dentry)) {\n\t\t\tdput(result);\n\t\t\treturn dentry;\n\t\t}\n\t\tspin_lock(&inode->i_lock);\n\t\ttoput = dentry;\n\t}\n\tspin_unlock(&inode->i_lock);\n\n\tif (toput)\n\t\tdput(toput);\n\treturn NULL;\n}\n\nstatic bool dentry_connected(struct dentry *dentry)\n{\n\tdget(dentry);\n\twhile (dentry->d_flags & DCACHE_DISCONNECTED) {\n\t\tstruct dentry *parent = dget_parent(dentry);\n\n\t\tdput(dentry);\n\t\tif (dentry == parent) {\n\t\t\tdput(parent);\n\t\t\treturn false;\n\t\t}\n\t\tdentry = parent;\n\t}\n\tdput(dentry);\n\treturn true;\n}\n\nstatic void clear_disconnected(struct dentry *dentry)\n{\n\tdget(dentry);\n\twhile (dentry->d_flags & DCACHE_DISCONNECTED) {\n\t\tstruct dentry *parent = dget_parent(dentry);\n\n\t\tWARN_ON_ONCE(IS_ROOT(dentry));\n\n\t\tspin_lock(&dentry->d_lock);\n\t\tdentry->d_flags &= ~DCACHE_DISCONNECTED;\n\t\tspin_unlock(&dentry->d_lock);\n\n\t\tdput(dentry);\n\t\tdentry = parent;\n\t}\n\tdput(dentry);\n}\n\n \nstatic struct dentry *reconnect_one(struct vfsmount *mnt,\n\t\tstruct dentry *dentry, char *nbuf)\n{\n\tstruct dentry *parent;\n\tstruct dentry *tmp;\n\tint err;\n\n\tparent = ERR_PTR(-EACCES);\n\tinode_lock(dentry->d_inode);\n\tif (mnt->mnt_sb->s_export_op->get_parent)\n\t\tparent = mnt->mnt_sb->s_export_op->get_parent(dentry);\n\tinode_unlock(dentry->d_inode);\n\n\tif (IS_ERR(parent)) {\n\t\tdprintk(\"get_parent of %lu failed, err %ld\\n\",\n\t\t\tdentry->d_inode->i_ino, PTR_ERR(parent));\n\t\treturn parent;\n\t}\n\n\tdprintk(\"%s: find name of %lu in %lu\\n\", __func__,\n\t\tdentry->d_inode->i_ino, parent->d_inode->i_ino);\n\terr = exportfs_get_name(mnt, parent, nbuf, dentry);\n\tif (err == -ENOENT)\n\t\tgoto out_reconnected;\n\tif (err)\n\t\tgoto out_err;\n\tdprintk(\"%s: found name: %s\\n\", __func__, nbuf);\n\ttmp = lookup_one_unlocked(mnt_idmap(mnt), nbuf, parent, strlen(nbuf));\n\tif (IS_ERR(tmp)) {\n\t\tdprintk(\"lookup failed: %ld\\n\", PTR_ERR(tmp));\n\t\terr = PTR_ERR(tmp);\n\t\tgoto out_err;\n\t}\n\tif (tmp != dentry) {\n\t\t \n\t\tdput(tmp);\n\t\tgoto out_reconnected;\n\t}\n\tdput(tmp);\n\tif (IS_ROOT(dentry)) {\n\t\terr = -ESTALE;\n\t\tgoto out_err;\n\t}\n\treturn parent;\n\nout_err:\n\tdput(parent);\n\treturn ERR_PTR(err);\nout_reconnected:\n\tdput(parent);\n\t \n\tif (!dentry_connected(dentry))\n\t\treturn ERR_PTR(-ESTALE);\n\treturn NULL;\n}\n\n \nstatic int\nreconnect_path(struct vfsmount *mnt, struct dentry *target_dir, char *nbuf)\n{\n\tstruct dentry *dentry, *parent;\n\n\tdentry = dget(target_dir);\n\n\twhile (dentry->d_flags & DCACHE_DISCONNECTED) {\n\t\tBUG_ON(dentry == mnt->mnt_sb->s_root);\n\n\t\tif (IS_ROOT(dentry))\n\t\t\tparent = reconnect_one(mnt, dentry, nbuf);\n\t\telse\n\t\t\tparent = dget_parent(dentry);\n\n\t\tif (!parent)\n\t\t\tbreak;\n\t\tdput(dentry);\n\t\tif (IS_ERR(parent))\n\t\t\treturn PTR_ERR(parent);\n\t\tdentry = parent;\n\t}\n\tdput(dentry);\n\tclear_disconnected(target_dir);\n\treturn 0;\n}\n\nstruct getdents_callback {\n\tstruct dir_context ctx;\n\tchar *name;\t\t \n\tu64 ino;\t\t \n\tint found;\t\t \n\tint sequence;\t\t \n};\n\n \nstatic bool filldir_one(struct dir_context *ctx, const char *name, int len,\n\t\t\tloff_t pos, u64 ino, unsigned int d_type)\n{\n\tstruct getdents_callback *buf =\n\t\tcontainer_of(ctx, struct getdents_callback, ctx);\n\n\tbuf->sequence++;\n\tif (buf->ino == ino && len <= NAME_MAX) {\n\t\tmemcpy(buf->name, name, len);\n\t\tbuf->name[len] = '\\0';\n\t\tbuf->found = 1;\n\t\treturn false;\t\n\t}\n\treturn true;\n}\n\n \nstatic int get_name(const struct path *path, char *name, struct dentry *child)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct inode *dir = path->dentry->d_inode;\n\tint error;\n\tstruct file *file;\n\tstruct kstat stat;\n\tstruct path child_path = {\n\t\t.mnt = path->mnt,\n\t\t.dentry = child,\n\t};\n\tstruct getdents_callback buffer = {\n\t\t.ctx.actor = filldir_one,\n\t\t.name = name,\n\t};\n\n\terror = -ENOTDIR;\n\tif (!dir || !S_ISDIR(dir->i_mode))\n\t\tgoto out;\n\terror = -EINVAL;\n\tif (!dir->i_fop)\n\t\tgoto out;\n\t \n\terror = vfs_getattr_nosec(&child_path, &stat,\n\t\t\t\t  STATX_INO, AT_STATX_SYNC_AS_STAT);\n\tif (error)\n\t\treturn error;\n\tbuffer.ino = stat.ino;\n\t \n\tfile = dentry_open(path, O_RDONLY, cred);\n\terror = PTR_ERR(file);\n\tif (IS_ERR(file))\n\t\tgoto out;\n\n\terror = -EINVAL;\n\tif (!file->f_op->iterate_shared)\n\t\tgoto out_close;\n\n\tbuffer.sequence = 0;\n\twhile (1) {\n\t\tint old_seq = buffer.sequence;\n\n\t\terror = iterate_dir(file, &buffer.ctx);\n\t\tif (buffer.found) {\n\t\t\terror = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (error < 0)\n\t\t\tbreak;\n\n\t\terror = -ENOENT;\n\t\tif (old_seq == buffer.sequence)\n\t\t\tbreak;\n\t}\n\nout_close:\n\tfput(file);\nout:\n\treturn error;\n}\n\n \nstatic int export_encode_fh(struct inode *inode, struct fid *fid,\n\t\tint *max_len, struct inode *parent)\n{\n\tint len = *max_len;\n\tint type = FILEID_INO32_GEN;\n\n\tif (parent && (len < 4)) {\n\t\t*max_len = 4;\n\t\treturn FILEID_INVALID;\n\t} else if (len < 2) {\n\t\t*max_len = 2;\n\t\treturn FILEID_INVALID;\n\t}\n\n\tlen = 2;\n\tfid->i32.ino = inode->i_ino;\n\tfid->i32.gen = inode->i_generation;\n\tif (parent) {\n\t\tfid->i32.parent_ino = parent->i_ino;\n\t\tfid->i32.parent_gen = parent->i_generation;\n\t\tlen = 4;\n\t\ttype = FILEID_INO32_GEN_PARENT;\n\t}\n\t*max_len = len;\n\treturn type;\n}\n\n \nint exportfs_encode_inode_fh(struct inode *inode, struct fid *fid,\n\t\t\t     int *max_len, struct inode *parent, int flags)\n{\n\tconst struct export_operations *nop = inode->i_sb->s_export_op;\n\n\t \n\tif (nop && !(flags & EXPORT_FH_FID) && !nop->fh_to_dentry)\n\t\treturn -EOPNOTSUPP;\n\n\tif (nop && nop->encode_fh)\n\t\treturn nop->encode_fh(inode, fid->raw, max_len, parent);\n\n\treturn export_encode_fh(inode, fid, max_len, parent);\n}\nEXPORT_SYMBOL_GPL(exportfs_encode_inode_fh);\n\n \nint exportfs_encode_fh(struct dentry *dentry, struct fid *fid, int *max_len,\n\t\t       int flags)\n{\n\tint error;\n\tstruct dentry *p = NULL;\n\tstruct inode *inode = dentry->d_inode, *parent = NULL;\n\n\tif ((flags & EXPORT_FH_CONNECTABLE) && !S_ISDIR(inode->i_mode)) {\n\t\tp = dget_parent(dentry);\n\t\t \n\t\tparent = p->d_inode;\n\t}\n\n\terror = exportfs_encode_inode_fh(inode, fid, max_len, parent, flags);\n\tdput(p);\n\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(exportfs_encode_fh);\n\nstruct dentry *\nexportfs_decode_fh_raw(struct vfsmount *mnt, struct fid *fid, int fh_len,\n\t\t       int fileid_type,\n\t\t       int (*acceptable)(void *, struct dentry *),\n\t\t       void *context)\n{\n\tconst struct export_operations *nop = mnt->mnt_sb->s_export_op;\n\tstruct dentry *result, *alias;\n\tchar nbuf[NAME_MAX+1];\n\tint err;\n\n\t \n\tif (!nop || !nop->fh_to_dentry)\n\t\treturn ERR_PTR(-ESTALE);\n\tresult = nop->fh_to_dentry(mnt->mnt_sb, fid, fh_len, fileid_type);\n\tif (IS_ERR_OR_NULL(result))\n\t\treturn result;\n\n\t \n\tif (!acceptable)\n\t\treturn result;\n\n\tif (d_is_dir(result)) {\n\t\t \n\t\tif (result->d_flags & DCACHE_DISCONNECTED) {\n\t\t\terr = reconnect_path(mnt, result, nbuf);\n\t\t\tif (err)\n\t\t\t\tgoto err_result;\n\t\t}\n\n\t\tif (!acceptable(context, result)) {\n\t\t\terr = -EACCES;\n\t\t\tgoto err_result;\n\t\t}\n\n\t\treturn result;\n\t} else {\n\t\t \n\t\tstruct dentry *target_dir, *nresult;\n\n\t\t \n\t\talias = find_acceptable_alias(result, acceptable, context);\n\t\tif (alias)\n\t\t\treturn alias;\n\n\t\t \n\t\terr = -ESTALE;\n\t\tif (!nop->fh_to_parent)\n\t\t\tgoto err_result;\n\n\t\ttarget_dir = nop->fh_to_parent(mnt->mnt_sb, fid,\n\t\t\t\tfh_len, fileid_type);\n\t\tif (!target_dir)\n\t\t\tgoto err_result;\n\t\terr = PTR_ERR(target_dir);\n\t\tif (IS_ERR(target_dir))\n\t\t\tgoto err_result;\n\n\t\t \n\t\terr = reconnect_path(mnt, target_dir, nbuf);\n\t\tif (err) {\n\t\t\tdput(target_dir);\n\t\t\tgoto err_result;\n\t\t}\n\n\t\t \n\t\terr = exportfs_get_name(mnt, target_dir, nbuf, result);\n\t\tif (err) {\n\t\t\tdput(target_dir);\n\t\t\tgoto err_result;\n\t\t}\n\n\t\tinode_lock(target_dir->d_inode);\n\t\tnresult = lookup_one(mnt_idmap(mnt), nbuf,\n\t\t\t\t     target_dir, strlen(nbuf));\n\t\tif (!IS_ERR(nresult)) {\n\t\t\tif (unlikely(nresult->d_inode != result->d_inode)) {\n\t\t\t\tdput(nresult);\n\t\t\t\tnresult = ERR_PTR(-ESTALE);\n\t\t\t}\n\t\t}\n\t\tinode_unlock(target_dir->d_inode);\n\t\t \n\t\tdput(target_dir);\n\n\t\tif (IS_ERR(nresult)) {\n\t\t\terr = PTR_ERR(nresult);\n\t\t\tgoto err_result;\n\t\t}\n\t\tdput(result);\n\t\tresult = nresult;\n\n\t\t \n\t\talias = find_acceptable_alias(result, acceptable, context);\n\t\tif (!alias) {\n\t\t\terr = -EACCES;\n\t\t\tgoto err_result;\n\t\t}\n\n\t\treturn alias;\n\t}\n\n err_result:\n\tdput(result);\n\treturn ERR_PTR(err);\n}\nEXPORT_SYMBOL_GPL(exportfs_decode_fh_raw);\n\nstruct dentry *exportfs_decode_fh(struct vfsmount *mnt, struct fid *fid,\n\t\t\t\t  int fh_len, int fileid_type,\n\t\t\t\t  int (*acceptable)(void *, struct dentry *),\n\t\t\t\t  void *context)\n{\n\tstruct dentry *ret;\n\n\tret = exportfs_decode_fh_raw(mnt, fid, fh_len, fileid_type,\n\t\t\t\t     acceptable, context);\n\tif (IS_ERR_OR_NULL(ret)) {\n\t\tif (ret == ERR_PTR(-ENOMEM))\n\t\t\treturn ret;\n\t\treturn ERR_PTR(-ESTALE);\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(exportfs_decode_fh);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}