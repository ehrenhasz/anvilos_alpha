{
  "module_name": "fsntfs.c",
  "hash_id": "357a7527a87243524be2d8a218363a4661585c5ff472fd523205b8d59523d173",
  "original_prompt": "Ingested from linux-6.6.14/fs/ntfs3/fsntfs.c",
  "human_readable_source": "\n \n\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/nls.h>\n\n#include \"debug.h\"\n#include \"ntfs.h\"\n#include \"ntfs_fs.h\"\n\n\nconst struct cpu_str NAME_MFT = {\n\t4, 0, { '$', 'M', 'F', 'T' },\n};\nconst struct cpu_str NAME_MIRROR = {\n\t8, 0, { '$', 'M', 'F', 'T', 'M', 'i', 'r', 'r' },\n};\nconst struct cpu_str NAME_LOGFILE = {\n\t8, 0, { '$', 'L', 'o', 'g', 'F', 'i', 'l', 'e' },\n};\nconst struct cpu_str NAME_VOLUME = {\n\t7, 0, { '$', 'V', 'o', 'l', 'u', 'm', 'e' },\n};\nconst struct cpu_str NAME_ATTRDEF = {\n\t8, 0, { '$', 'A', 't', 't', 'r', 'D', 'e', 'f' },\n};\nconst struct cpu_str NAME_ROOT = {\n\t1, 0, { '.' },\n};\nconst struct cpu_str NAME_BITMAP = {\n\t7, 0, { '$', 'B', 'i', 't', 'm', 'a', 'p' },\n};\nconst struct cpu_str NAME_BOOT = {\n\t5, 0, { '$', 'B', 'o', 'o', 't' },\n};\nconst struct cpu_str NAME_BADCLUS = {\n\t8, 0, { '$', 'B', 'a', 'd', 'C', 'l', 'u', 's' },\n};\nconst struct cpu_str NAME_QUOTA = {\n\t6, 0, { '$', 'Q', 'u', 'o', 't', 'a' },\n};\nconst struct cpu_str NAME_SECURE = {\n\t7, 0, { '$', 'S', 'e', 'c', 'u', 'r', 'e' },\n};\nconst struct cpu_str NAME_UPCASE = {\n\t7, 0, { '$', 'U', 'p', 'C', 'a', 's', 'e' },\n};\nconst struct cpu_str NAME_EXTEND = {\n\t7, 0, { '$', 'E', 'x', 't', 'e', 'n', 'd' },\n};\nconst struct cpu_str NAME_OBJID = {\n\t6, 0, { '$', 'O', 'b', 'j', 'I', 'd' },\n};\nconst struct cpu_str NAME_REPARSE = {\n\t8, 0, { '$', 'R', 'e', 'p', 'a', 'r', 's', 'e' },\n};\nconst struct cpu_str NAME_USNJRNL = {\n\t8, 0, { '$', 'U', 's', 'n', 'J', 'r', 'n', 'l' },\n};\nconst __le16 BAD_NAME[4] = {\n\tcpu_to_le16('$'), cpu_to_le16('B'), cpu_to_le16('a'), cpu_to_le16('d'),\n};\nconst __le16 I30_NAME[4] = {\n\tcpu_to_le16('$'), cpu_to_le16('I'), cpu_to_le16('3'), cpu_to_le16('0'),\n};\nconst __le16 SII_NAME[4] = {\n\tcpu_to_le16('$'), cpu_to_le16('S'), cpu_to_le16('I'), cpu_to_le16('I'),\n};\nconst __le16 SDH_NAME[4] = {\n\tcpu_to_le16('$'), cpu_to_le16('S'), cpu_to_le16('D'), cpu_to_le16('H'),\n};\nconst __le16 SDS_NAME[4] = {\n\tcpu_to_le16('$'), cpu_to_le16('S'), cpu_to_le16('D'), cpu_to_le16('S'),\n};\nconst __le16 SO_NAME[2] = {\n\tcpu_to_le16('$'), cpu_to_le16('O'),\n};\nconst __le16 SQ_NAME[2] = {\n\tcpu_to_le16('$'), cpu_to_le16('Q'),\n};\nconst __le16 SR_NAME[2] = {\n\tcpu_to_le16('$'), cpu_to_le16('R'),\n};\n\n#ifdef CONFIG_NTFS3_LZX_XPRESS\nconst __le16 WOF_NAME[17] = {\n\tcpu_to_le16('W'), cpu_to_le16('o'), cpu_to_le16('f'), cpu_to_le16('C'),\n\tcpu_to_le16('o'), cpu_to_le16('m'), cpu_to_le16('p'), cpu_to_le16('r'),\n\tcpu_to_le16('e'), cpu_to_le16('s'), cpu_to_le16('s'), cpu_to_le16('e'),\n\tcpu_to_le16('d'), cpu_to_le16('D'), cpu_to_le16('a'), cpu_to_le16('t'),\n\tcpu_to_le16('a'),\n};\n#endif\n\nstatic const __le16 CON_NAME[3] = {\n\tcpu_to_le16('C'), cpu_to_le16('O'), cpu_to_le16('N'),\n};\n\nstatic const __le16 NUL_NAME[3] = {\n\tcpu_to_le16('N'), cpu_to_le16('U'), cpu_to_le16('L'),\n};\n\nstatic const __le16 AUX_NAME[3] = {\n\tcpu_to_le16('A'), cpu_to_le16('U'), cpu_to_le16('X'),\n};\n\nstatic const __le16 PRN_NAME[3] = {\n\tcpu_to_le16('P'), cpu_to_le16('R'), cpu_to_le16('N'),\n};\n\nstatic const __le16 COM_NAME[3] = {\n\tcpu_to_le16('C'), cpu_to_le16('O'), cpu_to_le16('M'),\n};\n\nstatic const __le16 LPT_NAME[3] = {\n\tcpu_to_le16('L'), cpu_to_le16('P'), cpu_to_le16('T'),\n};\n\n\n\n \nbool ntfs_fix_pre_write(struct NTFS_RECORD_HEADER *rhdr, size_t bytes)\n{\n\tu16 *fixup, *ptr;\n\tu16 sample;\n\tu16 fo = le16_to_cpu(rhdr->fix_off);\n\tu16 fn = le16_to_cpu(rhdr->fix_num);\n\n\tif ((fo & 1) || fo + fn * sizeof(short) > SECTOR_SIZE || !fn-- ||\n\t    fn * SECTOR_SIZE > bytes) {\n\t\treturn false;\n\t}\n\n\t \n\tfixup = Add2Ptr(rhdr, fo);\n\n\tif (*fixup >= 0x7FFF)\n\t\t*fixup = 1;\n\telse\n\t\t*fixup += 1;\n\n\tsample = *fixup;\n\n\tptr = Add2Ptr(rhdr, SECTOR_SIZE - sizeof(short));\n\n\twhile (fn--) {\n\t\t*++fixup = *ptr;\n\t\t*ptr = sample;\n\t\tptr += SECTOR_SIZE / sizeof(short);\n\t}\n\treturn true;\n}\n\n \nint ntfs_fix_post_read(struct NTFS_RECORD_HEADER *rhdr, size_t bytes,\n\t\t       bool simple)\n{\n\tint ret;\n\tu16 *fixup, *ptr;\n\tu16 sample, fo, fn;\n\n\tfo = le16_to_cpu(rhdr->fix_off);\n\tfn = simple ? ((bytes >> SECTOR_SHIFT) + 1) :\n\t\t      le16_to_cpu(rhdr->fix_num);\n\n\t \n\tif ((fo & 1) || fo + fn * sizeof(short) > SECTOR_SIZE || !fn-- ||\n\t    fn * SECTOR_SIZE > bytes) {\n\t\treturn -E_NTFS_CORRUPT;\n\t}\n\n\t \n\tfixup = Add2Ptr(rhdr, fo);\n\tsample = *fixup;\n\tptr = Add2Ptr(rhdr, SECTOR_SIZE - sizeof(short));\n\tret = 0;\n\n\twhile (fn--) {\n\t\t \n\t\tif (*ptr != sample) {\n\t\t\t \n\t\t\tret = -E_NTFS_FIXUP;\n\t\t}\n\n\t\t \n\t\t*ptr = *++fixup;\n\t\tptr += SECTOR_SIZE / sizeof(short);\n\t}\n\n\treturn ret;\n}\n\n \nint ntfs_extend_init(struct ntfs_sb_info *sbi)\n{\n\tint err;\n\tstruct super_block *sb = sbi->sb;\n\tstruct inode *inode, *inode2;\n\tstruct MFT_REF ref;\n\n\tif (sbi->volume.major_ver < 3) {\n\t\tntfs_notice(sb, \"Skip $Extend 'cause NTFS version\");\n\t\treturn 0;\n\t}\n\n\tref.low = cpu_to_le32(MFT_REC_EXTEND);\n\tref.high = 0;\n\tref.seq = cpu_to_le16(MFT_REC_EXTEND);\n\tinode = ntfs_iget5(sb, &ref, &NAME_EXTEND);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tntfs_err(sb, \"Failed to load $Extend (%d).\", err);\n\t\tinode = NULL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (!S_ISDIR(inode->i_mode)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tinode2 = dir_search_u(inode, &NAME_OBJID, NULL);\n\tif (inode2 && !IS_ERR(inode2)) {\n\t\tif (is_bad_inode(inode2)) {\n\t\t\tiput(inode2);\n\t\t} else {\n\t\t\tsbi->objid.ni = ntfs_i(inode2);\n\t\t\tsbi->objid_no = inode2->i_ino;\n\t\t}\n\t}\n\n\t \n\tinode2 = dir_search_u(inode, &NAME_QUOTA, NULL);\n\tif (inode2 && !IS_ERR(inode2)) {\n\t\tsbi->quota_no = inode2->i_ino;\n\t\tiput(inode2);\n\t}\n\n\t \n\tinode2 = dir_search_u(inode, &NAME_REPARSE, NULL);\n\tif (inode2 && !IS_ERR(inode2)) {\n\t\tsbi->reparse.ni = ntfs_i(inode2);\n\t\tsbi->reparse_no = inode2->i_ino;\n\t}\n\n\t \n\tinode2 = dir_search_u(inode, &NAME_USNJRNL, NULL);\n\tif (inode2 && !IS_ERR(inode2)) {\n\t\tsbi->usn_jrnl_no = inode2->i_ino;\n\t\tiput(inode2);\n\t}\n\n\terr = 0;\nout:\n\tiput(inode);\n\treturn err;\n}\n\nint ntfs_loadlog_and_replay(struct ntfs_inode *ni, struct ntfs_sb_info *sbi)\n{\n\tint err = 0;\n\tstruct super_block *sb = sbi->sb;\n\tbool initialized = false;\n\tstruct MFT_REF ref;\n\tstruct inode *inode;\n\n\t \n\tif (ni->vfs_inode.i_size >= 0x100000000ull) {\n\t\tntfs_err(sb, \"\\x24LogFile is large than 4G.\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tsbi->flags |= NTFS_FLAGS_LOG_REPLAYING;\n\n\tref.low = cpu_to_le32(MFT_REC_MFT);\n\tref.high = 0;\n\tref.seq = cpu_to_le16(1);\n\n\tinode = ntfs_iget5(sb, &ref, NULL);\n\n\tif (IS_ERR(inode))\n\t\tinode = NULL;\n\n\tif (!inode) {\n\t\t \n\t\tu64 t64 = sbi->mft.lbo;\n\n\t\tsbi->mft.lbo = sbi->mft.lbo2;\n\t\tinode = ntfs_iget5(sb, &ref, NULL);\n\t\tsbi->mft.lbo = t64;\n\t\tif (IS_ERR(inode))\n\t\t\tinode = NULL;\n\t}\n\n\tif (!inode) {\n\t\terr = -EINVAL;\n\t\tntfs_err(sb, \"Failed to load $MFT.\");\n\t\tgoto out;\n\t}\n\n\tsbi->mft.ni = ntfs_i(inode);\n\n\t \n\terr = ni_load_all_mi(sbi->mft.ni);\n\tif (!err)\n\t\terr = log_replay(ni, &initialized);\n\n\tiput(inode);\n\tsbi->mft.ni = NULL;\n\n\tsync_blockdev(sb->s_bdev);\n\tinvalidate_bdev(sb->s_bdev);\n\n\tif (sbi->flags & NTFS_FLAGS_NEED_REPLAY) {\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\tif (sb_rdonly(sb) || !initialized)\n\t\tgoto out;\n\n\t \n\terr = ntfs_bio_fill_1(sbi, &ni->file.run);\n\nout:\n\tsbi->flags &= ~NTFS_FLAGS_LOG_REPLAYING;\n\n\treturn err;\n}\n\n \nint ntfs_look_for_free_space(struct ntfs_sb_info *sbi, CLST lcn, CLST len,\n\t\t\t     CLST *new_lcn, CLST *new_len,\n\t\t\t     enum ALLOCATE_OPT opt)\n{\n\tint err;\n\tCLST alen;\n\tstruct super_block *sb = sbi->sb;\n\tsize_t alcn, zlen, zeroes, zlcn, zlen2, ztrim, new_zlen;\n\tstruct wnd_bitmap *wnd = &sbi->used.bitmap;\n\n\tdown_write_nested(&wnd->rw_lock, BITMAP_MUTEX_CLUSTERS);\n\tif (opt & ALLOCATE_MFT) {\n\t\tzlen = wnd_zone_len(wnd);\n\n\t\tif (!zlen) {\n\t\t\terr = ntfs_refresh_zone(sbi);\n\t\t\tif (err)\n\t\t\t\tgoto up_write;\n\n\t\t\tzlen = wnd_zone_len(wnd);\n\t\t}\n\n\t\tif (!zlen) {\n\t\t\tntfs_err(sbi->sb, \"no free space to extend mft\");\n\t\t\terr = -ENOSPC;\n\t\t\tgoto up_write;\n\t\t}\n\n\t\tlcn = wnd_zone_bit(wnd);\n\t\talen = min_t(CLST, len, zlen);\n\n\t\twnd_zone_set(wnd, lcn + alen, zlen - alen);\n\n\t\terr = wnd_set_used(wnd, lcn, alen);\n\t\tif (err)\n\t\t\tgoto up_write;\n\n\t\talcn = lcn;\n\t\tgoto space_found;\n\t}\n\t \n\tif (!lcn)\n\t\tlcn = sbi->used.next_free_lcn;\n\n\tif (lcn >= wnd->nbits)\n\t\tlcn = 0;\n\n\talen = wnd_find(wnd, len, lcn, BITMAP_FIND_MARK_AS_USED, &alcn);\n\tif (alen)\n\t\tgoto space_found;\n\n\t \n\tzlen = wnd_zone_len(wnd);\n\tzeroes = wnd_zeroes(wnd);\n\n\t \n\tif (len > zeroes + zlen || zlen <= NTFS_MIN_MFT_ZONE) {\n\t\terr = -ENOSPC;\n\t\tgoto up_write;\n\t}\n\n\t \n\tzlcn = wnd_zone_bit(wnd);\n\tzlen2 = zlen >> 1;\n\tztrim = clamp_val(len, zlen2, zlen);\n\tnew_zlen = max_t(size_t, zlen - ztrim, NTFS_MIN_MFT_ZONE);\n\n\twnd_zone_set(wnd, zlcn, new_zlen);\n\n\t \n\talen = wnd_find(wnd, len, 0,\n\t\t\tBITMAP_FIND_MARK_AS_USED | BITMAP_FIND_FULL, &alcn);\n\tif (!alen) {\n\t\terr = -ENOSPC;\n\t\tgoto up_write;\n\t}\n\nspace_found:\n\terr = 0;\n\t*new_len = alen;\n\t*new_lcn = alcn;\n\n\tntfs_unmap_meta(sb, alcn, alen);\n\n\t \n\tif (!(opt & ALLOCATE_MFT))\n\t\tsbi->used.next_free_lcn = alcn + alen;\nup_write:\n\tup_write(&wnd->rw_lock);\n\treturn err;\n}\n\n \nbool ntfs_check_for_free_space(struct ntfs_sb_info *sbi, CLST clen, CLST mlen)\n{\n\tsize_t free, zlen, avail;\n\tstruct wnd_bitmap *wnd;\n\n\twnd = &sbi->used.bitmap;\n\tdown_read_nested(&wnd->rw_lock, BITMAP_MUTEX_CLUSTERS);\n\tfree = wnd_zeroes(wnd);\n\tzlen = min_t(size_t, NTFS_MIN_MFT_ZONE, wnd_zone_len(wnd));\n\tup_read(&wnd->rw_lock);\n\n\tif (free < zlen + clen)\n\t\treturn false;\n\n\tavail = free - (zlen + clen);\n\n\twnd = &sbi->mft.bitmap;\n\tdown_read_nested(&wnd->rw_lock, BITMAP_MUTEX_MFT);\n\tfree = wnd_zeroes(wnd);\n\tzlen = wnd_zone_len(wnd);\n\tup_read(&wnd->rw_lock);\n\n\tif (free >= zlen + mlen)\n\t\treturn true;\n\n\treturn avail >= bytes_to_cluster(sbi, mlen << sbi->record_bits);\n}\n\n \nstatic int ntfs_extend_mft(struct ntfs_sb_info *sbi)\n{\n\tint err;\n\tstruct ntfs_inode *ni = sbi->mft.ni;\n\tsize_t new_mft_total;\n\tu64 new_mft_bytes, new_bitmap_bytes;\n\tstruct ATTRIB *attr;\n\tstruct wnd_bitmap *wnd = &sbi->mft.bitmap;\n\n\tnew_mft_total = ALIGN(wnd->nbits + NTFS_MFT_INCREASE_STEP, 128);\n\tnew_mft_bytes = (u64)new_mft_total << sbi->record_bits;\n\n\t \n\tdown_write(&ni->file.run_lock);\n\terr = attr_set_size(ni, ATTR_DATA, NULL, 0, &ni->file.run,\n\t\t\t    new_mft_bytes, NULL, false, &attr);\n\n\tif (err) {\n\t\tup_write(&ni->file.run_lock);\n\t\tgoto out;\n\t}\n\n\tattr->nres.valid_size = attr->nres.data_size;\n\tnew_mft_total = le64_to_cpu(attr->nres.alloc_size) >> sbi->record_bits;\n\tni->mi.dirty = true;\n\n\t \n\tnew_bitmap_bytes = bitmap_size(new_mft_total);\n\n\terr = attr_set_size(ni, ATTR_BITMAP, NULL, 0, &sbi->mft.bitmap.run,\n\t\t\t    new_bitmap_bytes, &new_bitmap_bytes, true, NULL);\n\n\t \n\tdown_write_nested(&sbi->used.bitmap.rw_lock, BITMAP_MUTEX_CLUSTERS);\n\n\tntfs_refresh_zone(sbi);\n\n\tup_write(&sbi->used.bitmap.rw_lock);\n\tup_write(&ni->file.run_lock);\n\n\tif (err)\n\t\tgoto out;\n\n\terr = wnd_extend(wnd, new_mft_total);\n\n\tif (err)\n\t\tgoto out;\n\n\tntfs_clear_mft_tail(sbi, sbi->mft.used, new_mft_total);\n\n\terr = _ni_write_inode(&ni->vfs_inode, 0);\nout:\n\treturn err;\n}\n\n \nint ntfs_look_free_mft(struct ntfs_sb_info *sbi, CLST *rno, bool mft,\n\t\t       struct ntfs_inode *ni, struct mft_inode **mi)\n{\n\tint err = 0;\n\tsize_t zbit, zlen, from, to, fr;\n\tsize_t mft_total;\n\tstruct MFT_REF ref;\n\tstruct super_block *sb = sbi->sb;\n\tstruct wnd_bitmap *wnd = &sbi->mft.bitmap;\n\tu32 ir;\n\n\tstatic_assert(sizeof(sbi->mft.reserved_bitmap) * 8 >=\n\t\t      MFT_REC_FREE - MFT_REC_RESERVED);\n\n\tif (!mft)\n\t\tdown_write_nested(&wnd->rw_lock, BITMAP_MUTEX_MFT);\n\n\tzlen = wnd_zone_len(wnd);\n\n\t \n\tif (zlen) {\n\t\tif (mft) {\n\t\t\tzbit = wnd_zone_bit(wnd);\n\t\t\t*rno = zbit;\n\t\t\twnd_zone_set(wnd, zbit + 1, zlen - 1);\n\t\t}\n\t\tgoto found;\n\t}\n\n\t \n\tif (!wnd_find(wnd, 1, MFT_REC_FREE, 0, &zbit)) {\n\t\t \n\t\tmft_total = wnd->nbits;\n\n\t\terr = ntfs_extend_mft(sbi);\n\t\tif (!err) {\n\t\t\tzbit = mft_total;\n\t\t\tgoto reserve_mft;\n\t\t}\n\n\t\tif (!mft || MFT_REC_FREE == sbi->mft.next_reserved)\n\t\t\tgoto out;\n\n\t\terr = 0;\n\n\t\t \n\t\tif (!sbi->mft.reserved_bitmap) {\n\t\t\t \n\t\t\tsbi->mft.reserved_bitmap = 0xFF;\n\n\t\t\tref.high = 0;\n\t\t\tfor (ir = MFT_REC_RESERVED; ir < MFT_REC_FREE; ir++) {\n\t\t\t\tstruct inode *i;\n\t\t\t\tstruct ntfs_inode *ni;\n\t\t\t\tstruct MFT_REC *mrec;\n\n\t\t\t\tref.low = cpu_to_le32(ir);\n\t\t\t\tref.seq = cpu_to_le16(ir);\n\n\t\t\t\ti = ntfs_iget5(sb, &ref, NULL);\n\t\t\t\tif (IS_ERR(i)) {\nnext:\n\t\t\t\t\tntfs_notice(\n\t\t\t\t\t\tsb,\n\t\t\t\t\t\t\"Invalid reserved record %x\",\n\t\t\t\t\t\tref.low);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (is_bad_inode(i)) {\n\t\t\t\t\tiput(i);\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\n\t\t\t\tni = ntfs_i(i);\n\n\t\t\t\tmrec = ni->mi.mrec;\n\n\t\t\t\tif (!is_rec_base(mrec))\n\t\t\t\t\tgoto next;\n\n\t\t\t\tif (mrec->hard_links)\n\t\t\t\t\tgoto next;\n\n\t\t\t\tif (!ni_std(ni))\n\t\t\t\t\tgoto next;\n\n\t\t\t\tif (ni_find_attr(ni, NULL, NULL, ATTR_NAME,\n\t\t\t\t\t\t NULL, 0, NULL, NULL))\n\t\t\t\t\tgoto next;\n\n\t\t\t\t__clear_bit(ir - MFT_REC_RESERVED,\n\t\t\t\t\t    &sbi->mft.reserved_bitmap);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tzbit = find_next_zero_bit(&sbi->mft.reserved_bitmap,\n\t\t\t\t\t  MFT_REC_FREE, MFT_REC_RESERVED);\n\t\tif (zbit >= MFT_REC_FREE) {\n\t\t\tsbi->mft.next_reserved = MFT_REC_FREE;\n\t\t\tgoto out;\n\t\t}\n\n\t\tzlen = 1;\n\t\tsbi->mft.next_reserved = zbit;\n\t} else {\nreserve_mft:\n\t\tzlen = zbit == MFT_REC_FREE ? (MFT_REC_USER - MFT_REC_FREE) : 4;\n\t\tif (zbit + zlen > wnd->nbits)\n\t\t\tzlen = wnd->nbits - zbit;\n\n\t\twhile (zlen > 1 && !wnd_is_free(wnd, zbit, zlen))\n\t\t\tzlen -= 1;\n\n\t\t \n\t\tfrom = sbi->mft.used;\n\t\tif (from < zbit)\n\t\t\tfrom = zbit;\n\t\tto = zbit + zlen;\n\t\tif (from < to) {\n\t\t\tntfs_clear_mft_tail(sbi, from, to);\n\t\t\tsbi->mft.used = to;\n\t\t}\n\t}\n\n\tif (mft) {\n\t\t*rno = zbit;\n\t\tzbit += 1;\n\t\tzlen -= 1;\n\t}\n\n\twnd_zone_set(wnd, zbit, zlen);\n\nfound:\n\tif (!mft) {\n\t\t \n\t\tif (sbi->mft.next_free < MFT_REC_USER)\n\t\t\tsbi->mft.next_free = MFT_REC_USER;\n\n\t\tfor (;;) {\n\t\t\tif (sbi->mft.next_free >= sbi->mft.bitmap.nbits) {\n\t\t\t} else if (!wnd_find(wnd, 1, MFT_REC_USER, 0, &fr)) {\n\t\t\t\tsbi->mft.next_free = sbi->mft.bitmap.nbits;\n\t\t\t} else {\n\t\t\t\t*rno = fr;\n\t\t\t\tsbi->mft.next_free = *rno + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\terr = ntfs_extend_mft(sbi);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (ni && !ni_add_subrecord(ni, *rno, mi)) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\tif (*rno >= MFT_REC_FREE)\n\t\twnd_set_used(wnd, *rno, 1);\n\telse if (*rno >= MFT_REC_RESERVED && sbi->mft.reserved_bitmap_inited)\n\t\t__set_bit(*rno - MFT_REC_RESERVED, &sbi->mft.reserved_bitmap);\n\nout:\n\tif (!mft)\n\t\tup_write(&wnd->rw_lock);\n\n\treturn err;\n}\n\n \nvoid ntfs_mark_rec_free(struct ntfs_sb_info *sbi, CLST rno, bool is_mft)\n{\n\tstruct wnd_bitmap *wnd = &sbi->mft.bitmap;\n\n\tif (!is_mft)\n\t\tdown_write_nested(&wnd->rw_lock, BITMAP_MUTEX_MFT);\n\tif (rno >= wnd->nbits)\n\t\tgoto out;\n\n\tif (rno >= MFT_REC_FREE) {\n\t\tif (!wnd_is_used(wnd, rno, 1))\n\t\t\tntfs_set_state(sbi, NTFS_DIRTY_ERROR);\n\t\telse\n\t\t\twnd_set_free(wnd, rno, 1);\n\t} else if (rno >= MFT_REC_RESERVED && sbi->mft.reserved_bitmap_inited) {\n\t\t__clear_bit(rno - MFT_REC_RESERVED, &sbi->mft.reserved_bitmap);\n\t}\n\n\tif (rno < wnd_zone_bit(wnd))\n\t\twnd_zone_set(wnd, rno, 1);\n\telse if (rno < sbi->mft.next_free && rno >= MFT_REC_USER)\n\t\tsbi->mft.next_free = rno;\n\nout:\n\tif (!is_mft)\n\t\tup_write(&wnd->rw_lock);\n}\n\n \nint ntfs_clear_mft_tail(struct ntfs_sb_info *sbi, size_t from, size_t to)\n{\n\tint err;\n\tu32 rs;\n\tu64 vbo;\n\tstruct runs_tree *run;\n\tstruct ntfs_inode *ni;\n\n\tif (from >= to)\n\t\treturn 0;\n\n\trs = sbi->record_size;\n\tni = sbi->mft.ni;\n\trun = &ni->file.run;\n\n\tdown_read(&ni->file.run_lock);\n\tvbo = (u64)from * rs;\n\tfor (; from < to; from++, vbo += rs) {\n\t\tstruct ntfs_buffers nb;\n\n\t\terr = ntfs_get_bh(sbi, run, vbo, rs, &nb);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = ntfs_write_bh(sbi, &sbi->new_rec->rhdr, &nb, 0);\n\t\tnb_put(&nb);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\nout:\n\tsbi->mft.used = from;\n\tup_read(&ni->file.run_lock);\n\treturn err;\n}\n\n \nint ntfs_refresh_zone(struct ntfs_sb_info *sbi)\n{\n\tCLST lcn, vcn, len;\n\tsize_t lcn_s, zlen;\n\tstruct wnd_bitmap *wnd = &sbi->used.bitmap;\n\tstruct ntfs_inode *ni = sbi->mft.ni;\n\n\t \n\tif (wnd_zone_len(wnd))\n\t\treturn 0;\n\n\tvcn = bytes_to_cluster(sbi,\n\t\t\t       (u64)sbi->mft.bitmap.nbits << sbi->record_bits);\n\n\tif (!run_lookup_entry(&ni->file.run, vcn - 1, &lcn, &len, NULL))\n\t\tlcn = SPARSE_LCN;\n\n\t \n\tif (lcn == SPARSE_LCN)\n\t\treturn -EINVAL;\n\n\tlcn_s = lcn + 1;\n\n\t \n\tzlen = wnd_find(wnd, sbi->zone_max, lcn_s, 0, &lcn_s);\n\twnd_zone_set(wnd, lcn_s, zlen);\n\n\treturn 0;\n}\n\n \nvoid ntfs_update_mftmirr(struct ntfs_sb_info *sbi, int wait)\n{\n\tint err;\n\tstruct super_block *sb = sbi->sb;\n\tu32 blocksize, bytes;\n\tsector_t block1, block2;\n\n\t \n\tif (!sb || !(sbi->flags & NTFS_FLAGS_MFTMIRR))\n\t\treturn;\n\n\tblocksize = sb->s_blocksize;\n\tbytes = sbi->mft.recs_mirr << sbi->record_bits;\n\tblock1 = sbi->mft.lbo >> sb->s_blocksize_bits;\n\tblock2 = sbi->mft.lbo2 >> sb->s_blocksize_bits;\n\n\tfor (; bytes >= blocksize; bytes -= blocksize) {\n\t\tstruct buffer_head *bh1, *bh2;\n\n\t\tbh1 = sb_bread(sb, block1++);\n\t\tif (!bh1)\n\t\t\treturn;\n\n\t\tbh2 = sb_getblk(sb, block2++);\n\t\tif (!bh2) {\n\t\t\tput_bh(bh1);\n\t\t\treturn;\n\t\t}\n\n\t\tif (buffer_locked(bh2))\n\t\t\t__wait_on_buffer(bh2);\n\n\t\tlock_buffer(bh2);\n\t\tmemcpy(bh2->b_data, bh1->b_data, blocksize);\n\t\tset_buffer_uptodate(bh2);\n\t\tmark_buffer_dirty(bh2);\n\t\tunlock_buffer(bh2);\n\n\t\tput_bh(bh1);\n\t\tbh1 = NULL;\n\n\t\terr = wait ? sync_dirty_buffer(bh2) : 0;\n\n\t\tput_bh(bh2);\n\t\tif (err)\n\t\t\treturn;\n\t}\n\n\tsbi->flags &= ~NTFS_FLAGS_MFTMIRR;\n}\n\n \nvoid ntfs_bad_inode(struct inode *inode, const char *hint)\n{\n\tstruct ntfs_sb_info *sbi = inode->i_sb->s_fs_info;\n\n\tntfs_inode_err(inode, \"%s\", hint);\n\tmake_bad_inode(inode);\n\tntfs_set_state(sbi, NTFS_DIRTY_ERROR);\n}\n\n \nint ntfs_set_state(struct ntfs_sb_info *sbi, enum NTFS_DIRTY_FLAGS dirty)\n{\n\tint err;\n\tstruct ATTRIB *attr;\n\tstruct VOLUME_INFO *info;\n\tstruct mft_inode *mi;\n\tstruct ntfs_inode *ni;\n\t__le16 info_flags;\n\n\t \n\tif (sbi->volume.real_dirty || sb_rdonly(sbi->sb))\n\t\treturn 0;\n\n\t \n\tif ((dirty == NTFS_DIRTY_CLEAR ? 0 : VOLUME_FLAG_DIRTY) ==\n\t    (sbi->volume.flags & VOLUME_FLAG_DIRTY))\n\t\treturn 0;\n\n\tni = sbi->volume.ni;\n\tif (!ni)\n\t\treturn -EINVAL;\n\n\tmutex_lock_nested(&ni->ni_lock, NTFS_INODE_MUTEX_DIRTY);\n\n\tattr = ni_find_attr(ni, NULL, NULL, ATTR_VOL_INFO, NULL, 0, NULL, &mi);\n\tif (!attr) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tinfo = resident_data_ex(attr, SIZEOF_ATTRIBUTE_VOLUME_INFO);\n\tif (!info) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tinfo_flags = info->flags;\n\n\tswitch (dirty) {\n\tcase NTFS_DIRTY_ERROR:\n\t\tntfs_notice(sbi->sb, \"Mark volume as dirty due to NTFS errors\");\n\t\tsbi->volume.real_dirty = true;\n\t\tfallthrough;\n\tcase NTFS_DIRTY_DIRTY:\n\t\tinfo->flags |= VOLUME_FLAG_DIRTY;\n\t\tbreak;\n\tcase NTFS_DIRTY_CLEAR:\n\t\tinfo->flags &= ~VOLUME_FLAG_DIRTY;\n\t\tbreak;\n\t}\n\t \n\tif (info_flags != info->flags) {\n\t\tsbi->volume.flags = info->flags;\n\t\tmi->dirty = true;\n\t}\n\terr = 0;\n\nout:\n\tni_unlock(ni);\n\tif (err)\n\t\treturn err;\n\n\tmark_inode_dirty_sync(&ni->vfs_inode);\n\t \n\n\t \n\terr = _ni_write_inode(&ni->vfs_inode, 1);\n\n\treturn err;\n}\n\n \nstatic inline __le32 security_hash(const void *sd, size_t bytes)\n{\n\tu32 hash = 0;\n\tconst __le32 *ptr = sd;\n\n\tbytes >>= 2;\n\twhile (bytes--)\n\t\thash = ((hash >> 0x1D) | (hash << 3)) + le32_to_cpu(*ptr++);\n\treturn cpu_to_le32(hash);\n}\n\nint ntfs_sb_read(struct super_block *sb, u64 lbo, size_t bytes, void *buffer)\n{\n\tstruct block_device *bdev = sb->s_bdev;\n\tu32 blocksize = sb->s_blocksize;\n\tu64 block = lbo >> sb->s_blocksize_bits;\n\tu32 off = lbo & (blocksize - 1);\n\tu32 op = blocksize - off;\n\n\tfor (; bytes; block += 1, off = 0, op = blocksize) {\n\t\tstruct buffer_head *bh = __bread(bdev, block, blocksize);\n\n\t\tif (!bh)\n\t\t\treturn -EIO;\n\n\t\tif (op > bytes)\n\t\t\top = bytes;\n\n\t\tmemcpy(buffer, bh->b_data + off, op);\n\n\t\tput_bh(bh);\n\n\t\tbytes -= op;\n\t\tbuffer = Add2Ptr(buffer, op);\n\t}\n\n\treturn 0;\n}\n\nint ntfs_sb_write(struct super_block *sb, u64 lbo, size_t bytes,\n\t\t  const void *buf, int wait)\n{\n\tu32 blocksize = sb->s_blocksize;\n\tstruct block_device *bdev = sb->s_bdev;\n\tsector_t block = lbo >> sb->s_blocksize_bits;\n\tu32 off = lbo & (blocksize - 1);\n\tu32 op = blocksize - off;\n\tstruct buffer_head *bh;\n\n\tif (!wait && (sb->s_flags & SB_SYNCHRONOUS))\n\t\twait = 1;\n\n\tfor (; bytes; block += 1, off = 0, op = blocksize) {\n\t\tif (op > bytes)\n\t\t\top = bytes;\n\n\t\tif (op < blocksize) {\n\t\t\tbh = __bread(bdev, block, blocksize);\n\t\t\tif (!bh) {\n\t\t\t\tntfs_err(sb, \"failed to read block %llx\",\n\t\t\t\t\t (u64)block);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t} else {\n\t\t\tbh = __getblk(bdev, block, blocksize);\n\t\t\tif (!bh)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (buffer_locked(bh))\n\t\t\t__wait_on_buffer(bh);\n\n\t\tlock_buffer(bh);\n\t\tif (buf) {\n\t\t\tmemcpy(bh->b_data + off, buf, op);\n\t\t\tbuf = Add2Ptr(buf, op);\n\t\t} else {\n\t\t\tmemset(bh->b_data + off, -1, op);\n\t\t}\n\n\t\tset_buffer_uptodate(bh);\n\t\tmark_buffer_dirty(bh);\n\t\tunlock_buffer(bh);\n\n\t\tif (wait) {\n\t\t\tint err = sync_dirty_buffer(bh);\n\n\t\t\tif (err) {\n\t\t\t\tntfs_err(\n\t\t\t\t\tsb,\n\t\t\t\t\t\"failed to sync buffer at block %llx, error %d\",\n\t\t\t\t\t(u64)block, err);\n\t\t\t\tput_bh(bh);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\n\t\tput_bh(bh);\n\n\t\tbytes -= op;\n\t}\n\treturn 0;\n}\n\nint ntfs_sb_write_run(struct ntfs_sb_info *sbi, const struct runs_tree *run,\n\t\t      u64 vbo, const void *buf, size_t bytes, int sync)\n{\n\tstruct super_block *sb = sbi->sb;\n\tu8 cluster_bits = sbi->cluster_bits;\n\tu32 off = vbo & sbi->cluster_mask;\n\tCLST lcn, clen, vcn = vbo >> cluster_bits, vcn_next;\n\tu64 lbo, len;\n\tsize_t idx;\n\n\tif (!run_lookup_entry(run, vcn, &lcn, &clen, &idx))\n\t\treturn -ENOENT;\n\n\tif (lcn == SPARSE_LCN)\n\t\treturn -EINVAL;\n\n\tlbo = ((u64)lcn << cluster_bits) + off;\n\tlen = ((u64)clen << cluster_bits) - off;\n\n\tfor (;;) {\n\t\tu32 op = min_t(u64, len, bytes);\n\t\tint err = ntfs_sb_write(sb, lbo, op, buf, sync);\n\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tbytes -= op;\n\t\tif (!bytes)\n\t\t\tbreak;\n\n\t\tvcn_next = vcn + clen;\n\t\tif (!run_get_entry(run, ++idx, &vcn, &lcn, &clen) ||\n\t\t    vcn != vcn_next)\n\t\t\treturn -ENOENT;\n\n\t\tif (lcn == SPARSE_LCN)\n\t\t\treturn -EINVAL;\n\n\t\tif (buf)\n\t\t\tbuf = Add2Ptr(buf, op);\n\n\t\tlbo = ((u64)lcn << cluster_bits);\n\t\tlen = ((u64)clen << cluster_bits);\n\t}\n\n\treturn 0;\n}\n\nstruct buffer_head *ntfs_bread_run(struct ntfs_sb_info *sbi,\n\t\t\t\t   const struct runs_tree *run, u64 vbo)\n{\n\tstruct super_block *sb = sbi->sb;\n\tu8 cluster_bits = sbi->cluster_bits;\n\tCLST lcn;\n\tu64 lbo;\n\n\tif (!run_lookup_entry(run, vbo >> cluster_bits, &lcn, NULL, NULL))\n\t\treturn ERR_PTR(-ENOENT);\n\n\tlbo = ((u64)lcn << cluster_bits) + (vbo & sbi->cluster_mask);\n\n\treturn ntfs_bread(sb, lbo >> sb->s_blocksize_bits);\n}\n\nint ntfs_read_run_nb(struct ntfs_sb_info *sbi, const struct runs_tree *run,\n\t\t     u64 vbo, void *buf, u32 bytes, struct ntfs_buffers *nb)\n{\n\tint err;\n\tstruct super_block *sb = sbi->sb;\n\tu32 blocksize = sb->s_blocksize;\n\tu8 cluster_bits = sbi->cluster_bits;\n\tu32 off = vbo & sbi->cluster_mask;\n\tu32 nbh = 0;\n\tCLST vcn_next, vcn = vbo >> cluster_bits;\n\tCLST lcn, clen;\n\tu64 lbo, len;\n\tsize_t idx;\n\tstruct buffer_head *bh;\n\n\tif (!run) {\n\t\t \n\t\tif (vbo > MFT_REC_VOL * sbi->record_size) {\n\t\t\terr = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tlbo = vbo + sbi->mft.lbo;\n\t\tlen = sbi->record_size;\n\t} else if (!run_lookup_entry(run, vcn, &lcn, &clen, &idx)) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t} else {\n\t\tif (lcn == SPARSE_LCN) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tlbo = ((u64)lcn << cluster_bits) + off;\n\t\tlen = ((u64)clen << cluster_bits) - off;\n\t}\n\n\toff = lbo & (blocksize - 1);\n\tif (nb) {\n\t\tnb->off = off;\n\t\tnb->bytes = bytes;\n\t}\n\n\tfor (;;) {\n\t\tu32 len32 = len >= bytes ? bytes : len;\n\t\tsector_t block = lbo >> sb->s_blocksize_bits;\n\n\t\tdo {\n\t\t\tu32 op = blocksize - off;\n\n\t\t\tif (op > len32)\n\t\t\t\top = len32;\n\n\t\t\tbh = ntfs_bread(sb, block);\n\t\t\tif (!bh) {\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (buf) {\n\t\t\t\tmemcpy(buf, bh->b_data + off, op);\n\t\t\t\tbuf = Add2Ptr(buf, op);\n\t\t\t}\n\n\t\t\tif (!nb) {\n\t\t\t\tput_bh(bh);\n\t\t\t} else if (nbh >= ARRAY_SIZE(nb->bh)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tnb->bh[nbh++] = bh;\n\t\t\t\tnb->nbufs = nbh;\n\t\t\t}\n\n\t\t\tbytes -= op;\n\t\t\tif (!bytes)\n\t\t\t\treturn 0;\n\t\t\tlen32 -= op;\n\t\t\tblock += 1;\n\t\t\toff = 0;\n\n\t\t} while (len32);\n\n\t\tvcn_next = vcn + clen;\n\t\tif (!run_get_entry(run, ++idx, &vcn, &lcn, &clen) ||\n\t\t    vcn != vcn_next) {\n\t\t\terr = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (lcn == SPARSE_LCN) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tlbo = ((u64)lcn << cluster_bits);\n\t\tlen = ((u64)clen << cluster_bits);\n\t}\n\nout:\n\tif (!nbh)\n\t\treturn err;\n\n\twhile (nbh) {\n\t\tput_bh(nb->bh[--nbh]);\n\t\tnb->bh[nbh] = NULL;\n\t}\n\n\tnb->nbufs = 0;\n\treturn err;\n}\n\n \nint ntfs_read_bh(struct ntfs_sb_info *sbi, const struct runs_tree *run, u64 vbo,\n\t\t struct NTFS_RECORD_HEADER *rhdr, u32 bytes,\n\t\t struct ntfs_buffers *nb)\n{\n\tint err = ntfs_read_run_nb(sbi, run, vbo, rhdr, bytes, nb);\n\n\tif (err)\n\t\treturn err;\n\treturn ntfs_fix_post_read(rhdr, nb->bytes, true);\n}\n\nint ntfs_get_bh(struct ntfs_sb_info *sbi, const struct runs_tree *run, u64 vbo,\n\t\tu32 bytes, struct ntfs_buffers *nb)\n{\n\tint err = 0;\n\tstruct super_block *sb = sbi->sb;\n\tu32 blocksize = sb->s_blocksize;\n\tu8 cluster_bits = sbi->cluster_bits;\n\tCLST vcn_next, vcn = vbo >> cluster_bits;\n\tu32 off;\n\tu32 nbh = 0;\n\tCLST lcn, clen;\n\tu64 lbo, len;\n\tsize_t idx;\n\n\tnb->bytes = bytes;\n\n\tif (!run_lookup_entry(run, vcn, &lcn, &clen, &idx)) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\toff = vbo & sbi->cluster_mask;\n\tlbo = ((u64)lcn << cluster_bits) + off;\n\tlen = ((u64)clen << cluster_bits) - off;\n\n\tnb->off = off = lbo & (blocksize - 1);\n\n\tfor (;;) {\n\t\tu32 len32 = min_t(u64, len, bytes);\n\t\tsector_t block = lbo >> sb->s_blocksize_bits;\n\n\t\tdo {\n\t\t\tu32 op;\n\t\t\tstruct buffer_head *bh;\n\n\t\t\tif (nbh >= ARRAY_SIZE(nb->bh)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\top = blocksize - off;\n\t\t\tif (op > len32)\n\t\t\t\top = len32;\n\n\t\t\tif (op == blocksize) {\n\t\t\t\tbh = sb_getblk(sb, block);\n\t\t\t\tif (!bh) {\n\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (buffer_locked(bh))\n\t\t\t\t\t__wait_on_buffer(bh);\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t} else {\n\t\t\t\tbh = ntfs_bread(sb, block);\n\t\t\t\tif (!bh) {\n\t\t\t\t\terr = -EIO;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnb->bh[nbh++] = bh;\n\t\t\tbytes -= op;\n\t\t\tif (!bytes) {\n\t\t\t\tnb->nbufs = nbh;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tblock += 1;\n\t\t\tlen32 -= op;\n\t\t\toff = 0;\n\t\t} while (len32);\n\n\t\tvcn_next = vcn + clen;\n\t\tif (!run_get_entry(run, ++idx, &vcn, &lcn, &clen) ||\n\t\t    vcn != vcn_next) {\n\t\t\terr = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tlbo = ((u64)lcn << cluster_bits);\n\t\tlen = ((u64)clen << cluster_bits);\n\t}\n\nout:\n\twhile (nbh) {\n\t\tput_bh(nb->bh[--nbh]);\n\t\tnb->bh[nbh] = NULL;\n\t}\n\n\tnb->nbufs = 0;\n\n\treturn err;\n}\n\nint ntfs_write_bh(struct ntfs_sb_info *sbi, struct NTFS_RECORD_HEADER *rhdr,\n\t\t  struct ntfs_buffers *nb, int sync)\n{\n\tint err = 0;\n\tstruct super_block *sb = sbi->sb;\n\tu32 block_size = sb->s_blocksize;\n\tu32 bytes = nb->bytes;\n\tu32 off = nb->off;\n\tu16 fo = le16_to_cpu(rhdr->fix_off);\n\tu16 fn = le16_to_cpu(rhdr->fix_num);\n\tu32 idx;\n\t__le16 *fixup;\n\t__le16 sample;\n\n\tif ((fo & 1) || fo + fn * sizeof(short) > SECTOR_SIZE || !fn-- ||\n\t    fn * SECTOR_SIZE > bytes) {\n\t\treturn -EINVAL;\n\t}\n\n\tfor (idx = 0; bytes && idx < nb->nbufs; idx += 1, off = 0) {\n\t\tu32 op = block_size - off;\n\t\tchar *bh_data;\n\t\tstruct buffer_head *bh = nb->bh[idx];\n\t\t__le16 *ptr, *end_data;\n\n\t\tif (op > bytes)\n\t\t\top = bytes;\n\n\t\tif (buffer_locked(bh))\n\t\t\t__wait_on_buffer(bh);\n\n\t\tlock_buffer(bh);\n\n\t\tbh_data = bh->b_data + off;\n\t\tend_data = Add2Ptr(bh_data, op);\n\t\tmemcpy(bh_data, rhdr, op);\n\n\t\tif (!idx) {\n\t\t\tu16 t16;\n\n\t\t\tfixup = Add2Ptr(bh_data, fo);\n\t\t\tsample = *fixup;\n\t\t\tt16 = le16_to_cpu(sample);\n\t\t\tif (t16 >= 0x7FFF) {\n\t\t\t\tsample = *fixup = cpu_to_le16(1);\n\t\t\t} else {\n\t\t\t\tsample = cpu_to_le16(t16 + 1);\n\t\t\t\t*fixup = sample;\n\t\t\t}\n\n\t\t\t*(__le16 *)Add2Ptr(rhdr, fo) = sample;\n\t\t}\n\n\t\tptr = Add2Ptr(bh_data, SECTOR_SIZE - sizeof(short));\n\n\t\tdo {\n\t\t\t*++fixup = *ptr;\n\t\t\t*ptr = sample;\n\t\t\tptr += SECTOR_SIZE / sizeof(short);\n\t\t} while (ptr < end_data);\n\n\t\tset_buffer_uptodate(bh);\n\t\tmark_buffer_dirty(bh);\n\t\tunlock_buffer(bh);\n\n\t\tif (sync) {\n\t\t\tint err2 = sync_dirty_buffer(bh);\n\n\t\t\tif (!err && err2)\n\t\t\t\terr = err2;\n\t\t}\n\n\t\tbytes -= op;\n\t\trhdr = Add2Ptr(rhdr, op);\n\t}\n\n\treturn err;\n}\n\n \nint ntfs_bio_pages(struct ntfs_sb_info *sbi, const struct runs_tree *run,\n\t\t   struct page **pages, u32 nr_pages, u64 vbo, u32 bytes,\n\t\t   enum req_op op)\n{\n\tint err = 0;\n\tstruct bio *new, *bio = NULL;\n\tstruct super_block *sb = sbi->sb;\n\tstruct block_device *bdev = sb->s_bdev;\n\tstruct page *page;\n\tu8 cluster_bits = sbi->cluster_bits;\n\tCLST lcn, clen, vcn, vcn_next;\n\tu32 add, off, page_idx;\n\tu64 lbo, len;\n\tsize_t run_idx;\n\tstruct blk_plug plug;\n\n\tif (!bytes)\n\t\treturn 0;\n\n\tblk_start_plug(&plug);\n\n\t \n\tlbo = (vbo + bytes + 511) & ~511ull;\n\tvbo = vbo & ~511ull;\n\tbytes = lbo - vbo;\n\n\tvcn = vbo >> cluster_bits;\n\tif (!run_lookup_entry(run, vcn, &lcn, &clen, &run_idx)) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\toff = vbo & sbi->cluster_mask;\n\tpage_idx = 0;\n\tpage = pages[0];\n\n\tfor (;;) {\n\t\tlbo = ((u64)lcn << cluster_bits) + off;\n\t\tlen = ((u64)clen << cluster_bits) - off;\nnew_bio:\n\t\tnew = bio_alloc(bdev, nr_pages - page_idx, op, GFP_NOFS);\n\t\tif (bio) {\n\t\t\tbio_chain(bio, new);\n\t\t\tsubmit_bio(bio);\n\t\t}\n\t\tbio = new;\n\t\tbio->bi_iter.bi_sector = lbo >> 9;\n\n\t\twhile (len) {\n\t\t\toff = vbo & (PAGE_SIZE - 1);\n\t\t\tadd = off + len > PAGE_SIZE ? (PAGE_SIZE - off) : len;\n\n\t\t\tif (bio_add_page(bio, page, add, off) < add)\n\t\t\t\tgoto new_bio;\n\n\t\t\tif (bytes <= add)\n\t\t\t\tgoto out;\n\t\t\tbytes -= add;\n\t\t\tvbo += add;\n\n\t\t\tif (add + off == PAGE_SIZE) {\n\t\t\t\tpage_idx += 1;\n\t\t\t\tif (WARN_ON(page_idx >= nr_pages)) {\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tpage = pages[page_idx];\n\t\t\t}\n\n\t\t\tif (len <= add)\n\t\t\t\tbreak;\n\t\t\tlen -= add;\n\t\t\tlbo += add;\n\t\t}\n\n\t\tvcn_next = vcn + clen;\n\t\tif (!run_get_entry(run, ++run_idx, &vcn, &lcn, &clen) ||\n\t\t    vcn != vcn_next) {\n\t\t\terr = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\toff = 0;\n\t}\nout:\n\tif (bio) {\n\t\tif (!err)\n\t\t\terr = submit_bio_wait(bio);\n\t\tbio_put(bio);\n\t}\n\tblk_finish_plug(&plug);\n\n\treturn err;\n}\n\n \nint ntfs_bio_fill_1(struct ntfs_sb_info *sbi, const struct runs_tree *run)\n{\n\tint err = 0;\n\tstruct super_block *sb = sbi->sb;\n\tstruct block_device *bdev = sb->s_bdev;\n\tu8 cluster_bits = sbi->cluster_bits;\n\tstruct bio *new, *bio = NULL;\n\tCLST lcn, clen;\n\tu64 lbo, len;\n\tsize_t run_idx;\n\tstruct page *fill;\n\tvoid *kaddr;\n\tstruct blk_plug plug;\n\n\tfill = alloc_page(GFP_KERNEL);\n\tif (!fill)\n\t\treturn -ENOMEM;\n\n\tkaddr = kmap_atomic(fill);\n\tmemset(kaddr, -1, PAGE_SIZE);\n\tkunmap_atomic(kaddr);\n\tflush_dcache_page(fill);\n\tlock_page(fill);\n\n\tif (!run_lookup_entry(run, 0, &lcn, &clen, &run_idx)) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\t \n\tblk_start_plug(&plug);\n\tdo {\n\t\tlbo = (u64)lcn << cluster_bits;\n\t\tlen = (u64)clen << cluster_bits;\nnew_bio:\n\t\tnew = bio_alloc(bdev, BIO_MAX_VECS, REQ_OP_WRITE, GFP_NOFS);\n\t\tif (bio) {\n\t\t\tbio_chain(bio, new);\n\t\t\tsubmit_bio(bio);\n\t\t}\n\t\tbio = new;\n\t\tbio->bi_iter.bi_sector = lbo >> 9;\n\n\t\tfor (;;) {\n\t\t\tu32 add = len > PAGE_SIZE ? PAGE_SIZE : len;\n\n\t\t\tif (bio_add_page(bio, fill, add, 0) < add)\n\t\t\t\tgoto new_bio;\n\n\t\t\tlbo += add;\n\t\t\tif (len <= add)\n\t\t\t\tbreak;\n\t\t\tlen -= add;\n\t\t}\n\t} while (run_get_entry(run, ++run_idx, NULL, &lcn, &clen));\n\n\tif (!err)\n\t\terr = submit_bio_wait(bio);\n\tbio_put(bio);\n\n\tblk_finish_plug(&plug);\nout:\n\tunlock_page(fill);\n\tput_page(fill);\n\n\treturn err;\n}\n\nint ntfs_vbo_to_lbo(struct ntfs_sb_info *sbi, const struct runs_tree *run,\n\t\t    u64 vbo, u64 *lbo, u64 *bytes)\n{\n\tu32 off;\n\tCLST lcn, len;\n\tu8 cluster_bits = sbi->cluster_bits;\n\n\tif (!run_lookup_entry(run, vbo >> cluster_bits, &lcn, &len, NULL))\n\t\treturn -ENOENT;\n\n\toff = vbo & sbi->cluster_mask;\n\t*lbo = lcn == SPARSE_LCN ? -1 : (((u64)lcn << cluster_bits) + off);\n\t*bytes = ((u64)len << cluster_bits) - off;\n\n\treturn 0;\n}\n\nstruct ntfs_inode *ntfs_new_inode(struct ntfs_sb_info *sbi, CLST rno,\n\t\t\t\t  enum RECORD_FLAG flag)\n{\n\tint err = 0;\n\tstruct super_block *sb = sbi->sb;\n\tstruct inode *inode = new_inode(sb);\n\tstruct ntfs_inode *ni;\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tni = ntfs_i(inode);\n\n\terr = mi_format_new(&ni->mi, sbi, rno, flag, false);\n\tif (err)\n\t\tgoto out;\n\n\tinode->i_ino = rno;\n\tif (insert_inode_locked(inode) < 0) {\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\nout:\n\tif (err) {\n\t\tmake_bad_inode(inode);\n\t\tiput(inode);\n\t\tni = ERR_PTR(err);\n\t}\n\treturn ni;\n}\n\n \nconst u8 s_default_security[] __aligned(8) = {\n\t0x01, 0x00, 0x04, 0x80, 0x30, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x02, 0x00, 0x1C, 0x00,\n\t0x01, 0x00, 0x00, 0x00, 0x00, 0x03, 0x14, 0x00, 0xFF, 0x01, 0x1F, 0x00,\n\t0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,\n\t0x01, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x20, 0x00, 0x00, 0x00,\n\t0x20, 0x02, 0x00, 0x00, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05,\n\t0x20, 0x00, 0x00, 0x00, 0x20, 0x02, 0x00, 0x00,\n};\n\nstatic_assert(sizeof(s_default_security) == 0x50);\n\nstatic inline u32 sid_length(const struct SID *sid)\n{\n\treturn struct_size(sid, SubAuthority, sid->SubAuthorityCount);\n}\n\n \nstatic bool is_acl_valid(const struct ACL *acl, u32 len)\n{\n\tconst struct ACE_HEADER *ace;\n\tu32 i;\n\tu16 ace_count, ace_size;\n\n\tif (acl->AclRevision != ACL_REVISION &&\n\t    acl->AclRevision != ACL_REVISION_DS) {\n\t\t \n\t\treturn false;\n\t}\n\n\tif (acl->Sbz1)\n\t\treturn false;\n\n\tif (le16_to_cpu(acl->AclSize) > len)\n\t\treturn false;\n\n\tif (acl->Sbz2)\n\t\treturn false;\n\n\tlen -= sizeof(struct ACL);\n\tace = (struct ACE_HEADER *)&acl[1];\n\tace_count = le16_to_cpu(acl->AceCount);\n\n\tfor (i = 0; i < ace_count; i++) {\n\t\tif (len < sizeof(struct ACE_HEADER))\n\t\t\treturn false;\n\n\t\tace_size = le16_to_cpu(ace->AceSize);\n\t\tif (len < ace_size)\n\t\t\treturn false;\n\n\t\tlen -= ace_size;\n\t\tace = Add2Ptr(ace, ace_size);\n\t}\n\n\treturn true;\n}\n\nbool is_sd_valid(const struct SECURITY_DESCRIPTOR_RELATIVE *sd, u32 len)\n{\n\tu32 sd_owner, sd_group, sd_sacl, sd_dacl;\n\n\tif (len < sizeof(struct SECURITY_DESCRIPTOR_RELATIVE))\n\t\treturn false;\n\n\tif (sd->Revision != 1)\n\t\treturn false;\n\n\tif (sd->Sbz1)\n\t\treturn false;\n\n\tif (!(sd->Control & SE_SELF_RELATIVE))\n\t\treturn false;\n\n\tsd_owner = le32_to_cpu(sd->Owner);\n\tif (sd_owner) {\n\t\tconst struct SID *owner = Add2Ptr(sd, sd_owner);\n\n\t\tif (sd_owner + offsetof(struct SID, SubAuthority) > len)\n\t\t\treturn false;\n\n\t\tif (owner->Revision != 1)\n\t\t\treturn false;\n\n\t\tif (sd_owner + sid_length(owner) > len)\n\t\t\treturn false;\n\t}\n\n\tsd_group = le32_to_cpu(sd->Group);\n\tif (sd_group) {\n\t\tconst struct SID *group = Add2Ptr(sd, sd_group);\n\n\t\tif (sd_group + offsetof(struct SID, SubAuthority) > len)\n\t\t\treturn false;\n\n\t\tif (group->Revision != 1)\n\t\t\treturn false;\n\n\t\tif (sd_group + sid_length(group) > len)\n\t\t\treturn false;\n\t}\n\n\tsd_sacl = le32_to_cpu(sd->Sacl);\n\tif (sd_sacl) {\n\t\tconst struct ACL *sacl = Add2Ptr(sd, sd_sacl);\n\n\t\tif (sd_sacl + sizeof(struct ACL) > len)\n\t\t\treturn false;\n\n\t\tif (!is_acl_valid(sacl, len - sd_sacl))\n\t\t\treturn false;\n\t}\n\n\tsd_dacl = le32_to_cpu(sd->Dacl);\n\tif (sd_dacl) {\n\t\tconst struct ACL *dacl = Add2Ptr(sd, sd_dacl);\n\n\t\tif (sd_dacl + sizeof(struct ACL) > len)\n\t\t\treturn false;\n\n\t\tif (!is_acl_valid(dacl, len - sd_dacl))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nint ntfs_security_init(struct ntfs_sb_info *sbi)\n{\n\tint err;\n\tstruct super_block *sb = sbi->sb;\n\tstruct inode *inode;\n\tstruct ntfs_inode *ni;\n\tstruct MFT_REF ref;\n\tstruct ATTRIB *attr;\n\tstruct ATTR_LIST_ENTRY *le;\n\tu64 sds_size;\n\tsize_t off;\n\tstruct NTFS_DE *ne;\n\tstruct NTFS_DE_SII *sii_e;\n\tstruct ntfs_fnd *fnd_sii = NULL;\n\tconst struct INDEX_ROOT *root_sii;\n\tconst struct INDEX_ROOT *root_sdh;\n\tstruct ntfs_index *indx_sdh = &sbi->security.index_sdh;\n\tstruct ntfs_index *indx_sii = &sbi->security.index_sii;\n\n\tref.low = cpu_to_le32(MFT_REC_SECURE);\n\tref.high = 0;\n\tref.seq = cpu_to_le16(MFT_REC_SECURE);\n\n\tinode = ntfs_iget5(sb, &ref, &NAME_SECURE);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tntfs_err(sb, \"Failed to load $Secure (%d).\", err);\n\t\tinode = NULL;\n\t\tgoto out;\n\t}\n\n\tni = ntfs_i(inode);\n\n\tle = NULL;\n\n\tattr = ni_find_attr(ni, NULL, &le, ATTR_ROOT, SDH_NAME,\n\t\t\t    ARRAY_SIZE(SDH_NAME), NULL, NULL);\n\tif (!attr ||\n\t    !(root_sdh = resident_data_ex(attr, sizeof(struct INDEX_ROOT))) ||\n\t    root_sdh->type != ATTR_ZERO ||\n\t    root_sdh->rule != NTFS_COLLATION_TYPE_SECURITY_HASH ||\n\t    offsetof(struct INDEX_ROOT, ihdr) +\n\t\t\t    le32_to_cpu(root_sdh->ihdr.used) >\n\t\t    le32_to_cpu(attr->res.data_size)) {\n\t\tntfs_err(sb, \"$Secure::$SDH is corrupted.\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\terr = indx_init(indx_sdh, sbi, attr, INDEX_MUTEX_SDH);\n\tif (err) {\n\t\tntfs_err(sb, \"Failed to initialize $Secure::$SDH (%d).\", err);\n\t\tgoto out;\n\t}\n\n\tattr = ni_find_attr(ni, attr, &le, ATTR_ROOT, SII_NAME,\n\t\t\t    ARRAY_SIZE(SII_NAME), NULL, NULL);\n\tif (!attr ||\n\t    !(root_sii = resident_data_ex(attr, sizeof(struct INDEX_ROOT))) ||\n\t    root_sii->type != ATTR_ZERO ||\n\t    root_sii->rule != NTFS_COLLATION_TYPE_UINT ||\n\t    offsetof(struct INDEX_ROOT, ihdr) +\n\t\t\t    le32_to_cpu(root_sii->ihdr.used) >\n\t\t    le32_to_cpu(attr->res.data_size)) {\n\t\tntfs_err(sb, \"$Secure::$SII is corrupted.\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\terr = indx_init(indx_sii, sbi, attr, INDEX_MUTEX_SII);\n\tif (err) {\n\t\tntfs_err(sb, \"Failed to initialize $Secure::$SII (%d).\", err);\n\t\tgoto out;\n\t}\n\n\tfnd_sii = fnd_get();\n\tif (!fnd_sii) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tsds_size = inode->i_size;\n\n\t \n\tsbi->security.next_id = SECURITY_ID_FIRST;\n\t \n\tsbi->security.next_off =\n\t\tALIGN(sds_size - SecurityDescriptorsBlockSize, 16);\n\n\toff = 0;\n\tne = NULL;\n\n\tfor (;;) {\n\t\tu32 next_id;\n\n\t\terr = indx_find_raw(indx_sii, ni, root_sii, &ne, &off, fnd_sii);\n\t\tif (err || !ne)\n\t\t\tbreak;\n\n\t\tsii_e = (struct NTFS_DE_SII *)ne;\n\t\tif (le16_to_cpu(ne->view.data_size) < sizeof(sii_e->sec_hdr))\n\t\t\tcontinue;\n\n\t\tnext_id = le32_to_cpu(sii_e->sec_id) + 1;\n\t\tif (next_id >= sbi->security.next_id)\n\t\t\tsbi->security.next_id = next_id;\n\t}\n\n\tsbi->security.ni = ni;\n\tinode = NULL;\nout:\n\tiput(inode);\n\tfnd_put(fnd_sii);\n\n\treturn err;\n}\n\n \nint ntfs_get_security_by_id(struct ntfs_sb_info *sbi, __le32 security_id,\n\t\t\t    struct SECURITY_DESCRIPTOR_RELATIVE **sd,\n\t\t\t    size_t *size)\n{\n\tint err;\n\tint diff;\n\tstruct ntfs_inode *ni = sbi->security.ni;\n\tstruct ntfs_index *indx = &sbi->security.index_sii;\n\tvoid *p = NULL;\n\tstruct NTFS_DE_SII *sii_e;\n\tstruct ntfs_fnd *fnd_sii;\n\tstruct SECURITY_HDR d_security;\n\tconst struct INDEX_ROOT *root_sii;\n\tu32 t32;\n\n\t*sd = NULL;\n\n\tmutex_lock_nested(&ni->ni_lock, NTFS_INODE_MUTEX_SECURITY);\n\n\tfnd_sii = fnd_get();\n\tif (!fnd_sii) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\troot_sii = indx_get_root(indx, ni, NULL, NULL);\n\tif (!root_sii) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\terr = indx_find(indx, ni, root_sii, &security_id, sizeof(security_id),\n\t\t\tNULL, &diff, (struct NTFS_DE **)&sii_e, fnd_sii);\n\tif (err)\n\t\tgoto out;\n\n\tif (diff)\n\t\tgoto out;\n\n\tt32 = le32_to_cpu(sii_e->sec_hdr.size);\n\tif (t32 < sizeof(struct SECURITY_HDR)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (t32 > sizeof(struct SECURITY_HDR) + 0x10000) {\n\t\t \n\t\terr = -EFBIG;\n\t\tgoto out;\n\t}\n\n\t*size = t32 - sizeof(struct SECURITY_HDR);\n\n\tp = kmalloc(*size, GFP_NOFS);\n\tif (!p) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\terr = ntfs_read_run_nb(sbi, &ni->file.run,\n\t\t\t       le64_to_cpu(sii_e->sec_hdr.off), &d_security,\n\t\t\t       sizeof(d_security), NULL);\n\tif (err)\n\t\tgoto out;\n\n\tif (memcmp(&d_security, &sii_e->sec_hdr, sizeof(d_security))) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\terr = ntfs_read_run_nb(sbi, &ni->file.run,\n\t\t\t       le64_to_cpu(sii_e->sec_hdr.off) +\n\t\t\t\t       sizeof(struct SECURITY_HDR),\n\t\t\t       p, *size, NULL);\n\tif (err)\n\t\tgoto out;\n\n\t*sd = p;\n\tp = NULL;\n\nout:\n\tkfree(p);\n\tfnd_put(fnd_sii);\n\tni_unlock(ni);\n\n\treturn err;\n}\n\n \nint ntfs_insert_security(struct ntfs_sb_info *sbi,\n\t\t\t const struct SECURITY_DESCRIPTOR_RELATIVE *sd,\n\t\t\t u32 size_sd, __le32 *security_id, bool *inserted)\n{\n\tint err, diff;\n\tstruct ntfs_inode *ni = sbi->security.ni;\n\tstruct ntfs_index *indx_sdh = &sbi->security.index_sdh;\n\tstruct ntfs_index *indx_sii = &sbi->security.index_sii;\n\tstruct NTFS_DE_SDH *e;\n\tstruct NTFS_DE_SDH sdh_e;\n\tstruct NTFS_DE_SII sii_e;\n\tstruct SECURITY_HDR *d_security;\n\tu32 new_sec_size = size_sd + sizeof(struct SECURITY_HDR);\n\tu32 aligned_sec_size = ALIGN(new_sec_size, 16);\n\tstruct SECURITY_KEY hash_key;\n\tstruct ntfs_fnd *fnd_sdh = NULL;\n\tconst struct INDEX_ROOT *root_sdh;\n\tconst struct INDEX_ROOT *root_sii;\n\tu64 mirr_off, new_sds_size;\n\tu32 next, left;\n\n\tstatic_assert((1 << Log2OfSecurityDescriptorsBlockSize) ==\n\t\t      SecurityDescriptorsBlockSize);\n\n\thash_key.hash = security_hash(sd, size_sd);\n\thash_key.sec_id = SECURITY_ID_INVALID;\n\n\tif (inserted)\n\t\t*inserted = false;\n\t*security_id = SECURITY_ID_INVALID;\n\n\t \n\td_security = kzalloc(aligned_sec_size, GFP_NOFS);\n\tif (!d_security)\n\t\treturn -ENOMEM;\n\n\tmutex_lock_nested(&ni->ni_lock, NTFS_INODE_MUTEX_SECURITY);\n\n\tfnd_sdh = fnd_get();\n\tif (!fnd_sdh) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\troot_sdh = indx_get_root(indx_sdh, ni, NULL, NULL);\n\tif (!root_sdh) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\troot_sii = indx_get_root(indx_sii, ni, NULL, NULL);\n\tif (!root_sii) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\terr = indx_find(indx_sdh, ni, root_sdh, &hash_key, sizeof(hash_key),\n\t\t\t&d_security->key.sec_id, &diff, (struct NTFS_DE **)&e,\n\t\t\tfnd_sdh);\n\tif (err)\n\t\tgoto out;\n\n\twhile (e) {\n\t\tif (le32_to_cpu(e->sec_hdr.size) == new_sec_size) {\n\t\t\terr = ntfs_read_run_nb(sbi, &ni->file.run,\n\t\t\t\t\t       le64_to_cpu(e->sec_hdr.off),\n\t\t\t\t\t       d_security, new_sec_size, NULL);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\tif (le32_to_cpu(d_security->size) == new_sec_size &&\n\t\t\t    d_security->key.hash == hash_key.hash &&\n\t\t\t    !memcmp(d_security + 1, sd, size_sd)) {\n\t\t\t\t*security_id = d_security->key.sec_id;\n\t\t\t\t \n\t\t\t\terr = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\terr = indx_find_sort(indx_sdh, ni, root_sdh,\n\t\t\t\t     (struct NTFS_DE **)&e, fnd_sdh);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tif (!e || e->key.hash != hash_key.hash)\n\t\t\tbreak;\n\t}\n\n\t \n\tnext = sbi->security.next_off & (SecurityDescriptorsBlockSize - 1);\n\tleft = SecurityDescriptorsBlockSize - next;\n\n\t \n\tif (left < new_sec_size) {\n\t\t \n\t\tsbi->security.next_off += SecurityDescriptorsBlockSize + left;\n\t}\n\n\t \n\t\n\n\t \n\n\t \n\td_security->key.hash = hash_key.hash;\n\td_security->key.sec_id = cpu_to_le32(sbi->security.next_id);\n\td_security->off = cpu_to_le64(sbi->security.next_off);\n\td_security->size = cpu_to_le32(new_sec_size);\n\tmemcpy(d_security + 1, sd, size_sd);\n\n\t \n\terr = ntfs_sb_write_run(sbi, &ni->file.run, sbi->security.next_off,\n\t\t\t\td_security, aligned_sec_size, 0);\n\n\tif (err)\n\t\tgoto out;\n\n\tmirr_off = sbi->security.next_off + SecurityDescriptorsBlockSize;\n\tnew_sds_size = mirr_off + aligned_sec_size;\n\n\tif (new_sds_size > ni->vfs_inode.i_size) {\n\t\terr = attr_set_size(ni, ATTR_DATA, SDS_NAME,\n\t\t\t\t    ARRAY_SIZE(SDS_NAME), &ni->file.run,\n\t\t\t\t    new_sds_size, &new_sds_size, false, NULL);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\t \n\terr = ntfs_sb_write_run(sbi, &ni->file.run, mirr_off, d_security,\n\t\t\t\taligned_sec_size, 0);\n\tif (err)\n\t\tgoto out;\n\n\t \n\tsii_e.de.view.data_off =\n\t\tcpu_to_le16(offsetof(struct NTFS_DE_SII, sec_hdr));\n\tsii_e.de.view.data_size = cpu_to_le16(sizeof(struct SECURITY_HDR));\n\tsii_e.de.view.res = 0;\n\tsii_e.de.size = cpu_to_le16(sizeof(struct NTFS_DE_SII));\n\tsii_e.de.key_size = cpu_to_le16(sizeof(d_security->key.sec_id));\n\tsii_e.de.flags = 0;\n\tsii_e.de.res = 0;\n\tsii_e.sec_id = d_security->key.sec_id;\n\tmemcpy(&sii_e.sec_hdr, d_security, sizeof(struct SECURITY_HDR));\n\n\terr = indx_insert_entry(indx_sii, ni, &sii_e.de, NULL, NULL, 0);\n\tif (err)\n\t\tgoto out;\n\n\t \n\tsdh_e.de.view.data_off =\n\t\tcpu_to_le16(offsetof(struct NTFS_DE_SDH, sec_hdr));\n\tsdh_e.de.view.data_size = cpu_to_le16(sizeof(struct SECURITY_HDR));\n\tsdh_e.de.view.res = 0;\n\tsdh_e.de.size = cpu_to_le16(SIZEOF_SDH_DIRENTRY);\n\tsdh_e.de.key_size = cpu_to_le16(sizeof(sdh_e.key));\n\tsdh_e.de.flags = 0;\n\tsdh_e.de.res = 0;\n\tsdh_e.key.hash = d_security->key.hash;\n\tsdh_e.key.sec_id = d_security->key.sec_id;\n\tmemcpy(&sdh_e.sec_hdr, d_security, sizeof(struct SECURITY_HDR));\n\tsdh_e.magic[0] = cpu_to_le16('I');\n\tsdh_e.magic[1] = cpu_to_le16('I');\n\n\tfnd_clear(fnd_sdh);\n\terr = indx_insert_entry(indx_sdh, ni, &sdh_e.de, (void *)(size_t)1,\n\t\t\t\tfnd_sdh, 0);\n\tif (err)\n\t\tgoto out;\n\n\t*security_id = d_security->key.sec_id;\n\tif (inserted)\n\t\t*inserted = true;\n\n\t \n\tsbi->security.next_id += 1;\n\tsbi->security.next_off += aligned_sec_size;\n\nout:\n\tfnd_put(fnd_sdh);\n\tmark_inode_dirty(&ni->vfs_inode);\n\tni_unlock(ni);\n\tkfree(d_security);\n\n\treturn err;\n}\n\n \nint ntfs_reparse_init(struct ntfs_sb_info *sbi)\n{\n\tint err;\n\tstruct ntfs_inode *ni = sbi->reparse.ni;\n\tstruct ntfs_index *indx = &sbi->reparse.index_r;\n\tstruct ATTRIB *attr;\n\tstruct ATTR_LIST_ENTRY *le;\n\tconst struct INDEX_ROOT *root_r;\n\n\tif (!ni)\n\t\treturn 0;\n\n\tle = NULL;\n\tattr = ni_find_attr(ni, NULL, &le, ATTR_ROOT, SR_NAME,\n\t\t\t    ARRAY_SIZE(SR_NAME), NULL, NULL);\n\tif (!attr) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\troot_r = resident_data(attr);\n\tif (root_r->type != ATTR_ZERO ||\n\t    root_r->rule != NTFS_COLLATION_TYPE_UINTS) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\terr = indx_init(indx, sbi, attr, INDEX_MUTEX_SR);\n\tif (err)\n\t\tgoto out;\n\nout:\n\treturn err;\n}\n\n \nint ntfs_objid_init(struct ntfs_sb_info *sbi)\n{\n\tint err;\n\tstruct ntfs_inode *ni = sbi->objid.ni;\n\tstruct ntfs_index *indx = &sbi->objid.index_o;\n\tstruct ATTRIB *attr;\n\tstruct ATTR_LIST_ENTRY *le;\n\tconst struct INDEX_ROOT *root;\n\n\tif (!ni)\n\t\treturn 0;\n\n\tle = NULL;\n\tattr = ni_find_attr(ni, NULL, &le, ATTR_ROOT, SO_NAME,\n\t\t\t    ARRAY_SIZE(SO_NAME), NULL, NULL);\n\tif (!attr) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\troot = resident_data(attr);\n\tif (root->type != ATTR_ZERO ||\n\t    root->rule != NTFS_COLLATION_TYPE_UINTS) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\terr = indx_init(indx, sbi, attr, INDEX_MUTEX_SO);\n\tif (err)\n\t\tgoto out;\n\nout:\n\treturn err;\n}\n\nint ntfs_objid_remove(struct ntfs_sb_info *sbi, struct GUID *guid)\n{\n\tint err;\n\tstruct ntfs_inode *ni = sbi->objid.ni;\n\tstruct ntfs_index *indx = &sbi->objid.index_o;\n\n\tif (!ni)\n\t\treturn -EINVAL;\n\n\tmutex_lock_nested(&ni->ni_lock, NTFS_INODE_MUTEX_OBJID);\n\n\terr = indx_delete_entry(indx, ni, guid, sizeof(*guid), NULL);\n\n\tmark_inode_dirty(&ni->vfs_inode);\n\tni_unlock(ni);\n\n\treturn err;\n}\n\nint ntfs_insert_reparse(struct ntfs_sb_info *sbi, __le32 rtag,\n\t\t\tconst struct MFT_REF *ref)\n{\n\tint err;\n\tstruct ntfs_inode *ni = sbi->reparse.ni;\n\tstruct ntfs_index *indx = &sbi->reparse.index_r;\n\tstruct NTFS_DE_R re;\n\n\tif (!ni)\n\t\treturn -EINVAL;\n\n\tmemset(&re, 0, sizeof(re));\n\n\tre.de.view.data_off = cpu_to_le16(offsetof(struct NTFS_DE_R, zero));\n\tre.de.size = cpu_to_le16(sizeof(struct NTFS_DE_R));\n\tre.de.key_size = cpu_to_le16(sizeof(re.key));\n\n\tre.key.ReparseTag = rtag;\n\tmemcpy(&re.key.ref, ref, sizeof(*ref));\n\n\tmutex_lock_nested(&ni->ni_lock, NTFS_INODE_MUTEX_REPARSE);\n\n\terr = indx_insert_entry(indx, ni, &re.de, NULL, NULL, 0);\n\n\tmark_inode_dirty(&ni->vfs_inode);\n\tni_unlock(ni);\n\n\treturn err;\n}\n\nint ntfs_remove_reparse(struct ntfs_sb_info *sbi, __le32 rtag,\n\t\t\tconst struct MFT_REF *ref)\n{\n\tint err, diff;\n\tstruct ntfs_inode *ni = sbi->reparse.ni;\n\tstruct ntfs_index *indx = &sbi->reparse.index_r;\n\tstruct ntfs_fnd *fnd = NULL;\n\tstruct REPARSE_KEY rkey;\n\tstruct NTFS_DE_R *re;\n\tstruct INDEX_ROOT *root_r;\n\n\tif (!ni)\n\t\treturn -EINVAL;\n\n\trkey.ReparseTag = rtag;\n\trkey.ref = *ref;\n\n\tmutex_lock_nested(&ni->ni_lock, NTFS_INODE_MUTEX_REPARSE);\n\n\tif (rtag) {\n\t\terr = indx_delete_entry(indx, ni, &rkey, sizeof(rkey), NULL);\n\t\tgoto out1;\n\t}\n\n\tfnd = fnd_get();\n\tif (!fnd) {\n\t\terr = -ENOMEM;\n\t\tgoto out1;\n\t}\n\n\troot_r = indx_get_root(indx, ni, NULL, NULL);\n\tif (!root_r) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\terr = indx_find(indx, ni, root_r, &rkey, sizeof(rkey), (void *)1, &diff,\n\t\t\t(struct NTFS_DE **)&re, fnd);\n\tif (err)\n\t\tgoto out;\n\n\tif (memcmp(&re->key.ref, ref, sizeof(*ref))) {\n\t\t \n\t\tgoto out;\n\t}\n\n\tmemcpy(&rkey, &re->key, sizeof(rkey));\n\n\tfnd_put(fnd);\n\tfnd = NULL;\n\n\terr = indx_delete_entry(indx, ni, &rkey, sizeof(rkey), NULL);\n\tif (err)\n\t\tgoto out;\n\nout:\n\tfnd_put(fnd);\n\nout1:\n\tmark_inode_dirty(&ni->vfs_inode);\n\tni_unlock(ni);\n\n\treturn err;\n}\n\nstatic inline void ntfs_unmap_and_discard(struct ntfs_sb_info *sbi, CLST lcn,\n\t\t\t\t\t  CLST len)\n{\n\tntfs_unmap_meta(sbi->sb, lcn, len);\n\tntfs_discard(sbi, lcn, len);\n}\n\nvoid mark_as_free_ex(struct ntfs_sb_info *sbi, CLST lcn, CLST len, bool trim)\n{\n\tCLST end, i, zone_len, zlen;\n\tstruct wnd_bitmap *wnd = &sbi->used.bitmap;\n\tbool dirty = false;\n\n\tdown_write_nested(&wnd->rw_lock, BITMAP_MUTEX_CLUSTERS);\n\tif (!wnd_is_used(wnd, lcn, len)) {\n\t\t \n\t\tdirty = true;\n\n\t\tend = lcn + len;\n\t\tlen = 0;\n\t\tfor (i = lcn; i < end; i++) {\n\t\t\tif (wnd_is_used(wnd, i, 1)) {\n\t\t\t\tif (!len)\n\t\t\t\t\tlcn = i;\n\t\t\t\tlen += 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!len)\n\t\t\t\tcontinue;\n\n\t\t\tif (trim)\n\t\t\t\tntfs_unmap_and_discard(sbi, lcn, len);\n\n\t\t\twnd_set_free(wnd, lcn, len);\n\t\t\tlen = 0;\n\t\t}\n\n\t\tif (!len)\n\t\t\tgoto out;\n\t}\n\n\tif (trim)\n\t\tntfs_unmap_and_discard(sbi, lcn, len);\n\twnd_set_free(wnd, lcn, len);\n\n\t \n\tzone_len = wnd_zone_len(wnd);\n\tzlen = min(zone_len + len, sbi->zone_max);\n\n\tif (zlen == zone_len) {\n\t\t \n\t} else if (!zone_len) {\n\t\t \n\t\tif (zlen == sbi->zone_max)\n\t\t\twnd_zone_set(wnd, lcn, zlen);\n\t} else {\n\t\tCLST zone_lcn = wnd_zone_bit(wnd);\n\n\t\tif (lcn + len == zone_lcn) {\n\t\t\t \n\t\t\twnd_zone_set(wnd, lcn, zlen);\n\t\t} else if (zone_lcn + zone_len == lcn) {\n\t\t\t \n\t\t\twnd_zone_set(wnd, zone_lcn, zlen);\n\t\t}\n\t}\n\nout:\n\tup_write(&wnd->rw_lock);\n\tif (dirty)\n\t\tntfs_set_state(sbi, NTFS_DIRTY_ERROR);\n}\n\n \nint run_deallocate(struct ntfs_sb_info *sbi, const struct runs_tree *run,\n\t\t   bool trim)\n{\n\tCLST lcn, len;\n\tsize_t idx = 0;\n\n\twhile (run_get_entry(run, idx++, NULL, &lcn, &len)) {\n\t\tif (lcn == SPARSE_LCN)\n\t\t\tcontinue;\n\n\t\tmark_as_free_ex(sbi, lcn, len, trim);\n\t}\n\n\treturn 0;\n}\n\nstatic inline bool name_has_forbidden_chars(const struct le_str *fname)\n{\n\tint i, ch;\n\n\t \n\tfor (i = 0; i < fname->len; ++i) {\n\t\tch = le16_to_cpu(fname->name[i]);\n\n\t\t \n\t\tif (ch < 0x20)\n\t\t\treturn true;\n\n\t\tswitch (ch) {\n\t\t \n\t\tcase '\\\\':\n\t\tcase '/':\n\t\tcase ':':\n\t\tcase '*':\n\t\tcase '?':\n\t\tcase '<':\n\t\tcase '>':\n\t\tcase '|':\n\t\tcase '\\\"':\n\t\t\treturn true;\n\n\t\tdefault:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (fname->len > 0) {\n\t\tch = le16_to_cpu(fname->name[fname->len - 1]);\n\t\tif (ch == ' ' || ch == '.')\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic inline bool is_reserved_name(const struct ntfs_sb_info *sbi,\n\t\t\t\t    const struct le_str *fname)\n{\n\tint port_digit;\n\tconst __le16 *name = fname->name;\n\tint len = fname->len;\n\tconst u16 *upcase = sbi->upcase;\n\n\t \n\t \n\tif (len == 3 || (len > 3 && le16_to_cpu(name[3]) == '.'))\n\t\tif (!ntfs_cmp_names(name, 3, CON_NAME, 3, upcase, false) ||\n\t\t    !ntfs_cmp_names(name, 3, NUL_NAME, 3, upcase, false) ||\n\t\t    !ntfs_cmp_names(name, 3, AUX_NAME, 3, upcase, false) ||\n\t\t    !ntfs_cmp_names(name, 3, PRN_NAME, 3, upcase, false))\n\t\t\treturn true;\n\n\t \n\t \n\tif (len == 4 || (len > 4 && le16_to_cpu(name[4]) == '.')) {\n\t\tport_digit = le16_to_cpu(name[3]);\n\t\tif (port_digit >= '1' && port_digit <= '9')\n\t\t\tif (!ntfs_cmp_names(name, 3, COM_NAME, 3, upcase,\n\t\t\t\t\t    false) ||\n\t\t\t    !ntfs_cmp_names(name, 3, LPT_NAME, 3, upcase,\n\t\t\t\t\t    false))\n\t\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nbool valid_windows_name(struct ntfs_sb_info *sbi, const struct le_str *fname)\n{\n\treturn !name_has_forbidden_chars(fname) &&\n\t       !is_reserved_name(sbi, fname);\n}\n\n \nint ntfs_set_label(struct ntfs_sb_info *sbi, u8 *label, int len)\n{\n\tint err;\n\tstruct ATTRIB *attr;\n\tstruct ntfs_inode *ni = sbi->volume.ni;\n\tconst u8 max_ulen = 0x80;  \n\t \n\tstruct cpu_str *uni = __getname();\n\n\tif (!uni)\n\t\treturn -ENOMEM;\n\n\terr = ntfs_nls_to_utf16(sbi, label, len, uni, (PATH_MAX - 2) / 2,\n\t\t\t\tUTF16_LITTLE_ENDIAN);\n\tif (err < 0)\n\t\tgoto out;\n\n\tif (uni->len > max_ulen) {\n\t\tntfs_warn(sbi->sb, \"new label is too long\");\n\t\terr = -EFBIG;\n\t\tgoto out;\n\t}\n\n\tni_lock(ni);\n\n\t \n\tni_remove_attr(ni, ATTR_LABEL, NULL, 0, false, NULL);\n\n\terr = ni_insert_resident(ni, uni->len * sizeof(u16), ATTR_LABEL, NULL,\n\t\t\t\t 0, &attr, NULL, NULL);\n\tif (err < 0)\n\t\tgoto unlock_out;\n\n\t \n\tmemcpy(resident_data(attr), uni->name, uni->len * sizeof(u16));\n\n\t \n\tif (len >= ARRAY_SIZE(sbi->volume.label))\n\t\tlen = ARRAY_SIZE(sbi->volume.label) - 1;\n\tmemcpy(sbi->volume.label, label, len);\n\tsbi->volume.label[len] = 0;\n\tmark_inode_dirty_sync(&ni->vfs_inode);\n\nunlock_out:\n\tni_unlock(ni);\n\n\tif (!err)\n\t\terr = _ni_write_inode(&ni->vfs_inode, 0);\n\nout:\n\t__putname(uni);\n\treturn err;\n}",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}