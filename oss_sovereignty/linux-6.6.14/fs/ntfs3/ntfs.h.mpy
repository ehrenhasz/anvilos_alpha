{
  "module_name": "ntfs.h",
  "hash_id": "b8929b168e1b86e06b54f7cb35b16d0f0ec7bbd776b0446567db64ad0d87f186",
  "original_prompt": "Ingested from linux-6.6.14/fs/ntfs3/ntfs.h",
  "human_readable_source": " \n \n\n\n#ifndef _LINUX_NTFS3_NTFS_H\n#define _LINUX_NTFS3_NTFS_H\n\n#include <linux/blkdev.h>\n#include <linux/build_bug.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/string.h>\n#include <linux/types.h>\n\n#include \"debug.h\"\n\n \n\n \n#define NTFS3_CHECK_FREE_CLST\n\n#define NTFS_NAME_LEN 255\n\n \n#define NTFS_LINK_MAX 4000\n\n \n\n\n#define NTFS_LZNT_MAX_CLUSTER\t4096\n#define NTFS_LZNT_CUNIT\t\t4\n#define NTFS_LZNT_CLUSTERS\t(1u<<NTFS_LZNT_CUNIT)\n\nstruct GUID {\n\t__le32 Data1;\n\t__le16 Data2;\n\t__le16 Data3;\n\tu8 Data4[8];\n};\n\n \nstruct cpu_str {\n\tu8 len;\n\tu8 unused;\n\tu16 name[10];\n};\n\nstruct le_str {\n\tu8 len;\n\tu8 unused;\n\t__le16 name[];\n};\n\nstatic_assert(SECTOR_SHIFT == 9);\n\n#ifdef CONFIG_NTFS3_64BIT_CLUSTER\ntypedef u64 CLST;\nstatic_assert(sizeof(size_t) == 8);\n#else\ntypedef u32 CLST;\n#endif\n\n#define SPARSE_LCN64   ((u64)-1)\n#define SPARSE_LCN     ((CLST)-1)\n#define RESIDENT_LCN   ((CLST)-2)\n#define COMPRESSED_LCN ((CLST)-3)\n\n#define COMPRESSION_UNIT     4\n#define COMPRESS_MAX_CLUSTER 0x1000\n\nenum RECORD_NUM {\n\tMFT_REC_MFT\t\t= 0,\n\tMFT_REC_MIRR\t\t= 1,\n\tMFT_REC_LOG\t\t= 2,\n\tMFT_REC_VOL\t\t= 3,\n\tMFT_REC_ATTR\t\t= 4,\n\tMFT_REC_ROOT\t\t= 5,\n\tMFT_REC_BITMAP\t\t= 6,\n\tMFT_REC_BOOT\t\t= 7,\n\tMFT_REC_BADCLUST\t= 8,\n\tMFT_REC_SECURE\t\t= 9,\n\tMFT_REC_UPCASE\t\t= 10,\n\tMFT_REC_EXTEND\t\t= 11,\n\tMFT_REC_RESERVED\t= 12,\n\tMFT_REC_FREE\t\t= 16,\n\tMFT_REC_USER\t\t= 24,\n};\n\nenum ATTR_TYPE {\n\tATTR_ZERO\t\t= cpu_to_le32(0x00),\n\tATTR_STD\t\t= cpu_to_le32(0x10),\n\tATTR_LIST\t\t= cpu_to_le32(0x20),\n\tATTR_NAME\t\t= cpu_to_le32(0x30),\n\tATTR_ID\t\t\t= cpu_to_le32(0x40),\n\tATTR_SECURE\t\t= cpu_to_le32(0x50),\n\tATTR_LABEL\t\t= cpu_to_le32(0x60),\n\tATTR_VOL_INFO\t\t= cpu_to_le32(0x70),\n\tATTR_DATA\t\t= cpu_to_le32(0x80),\n\tATTR_ROOT\t\t= cpu_to_le32(0x90),\n\tATTR_ALLOC\t\t= cpu_to_le32(0xA0),\n\tATTR_BITMAP\t\t= cpu_to_le32(0xB0),\n\tATTR_REPARSE\t\t= cpu_to_le32(0xC0),\n\tATTR_EA_INFO\t\t= cpu_to_le32(0xD0),\n\tATTR_EA\t\t\t= cpu_to_le32(0xE0),\n\tATTR_PROPERTYSET\t= cpu_to_le32(0xF0),\n\tATTR_LOGGED_UTILITY_STREAM = cpu_to_le32(0x100),\n\tATTR_END\t\t= cpu_to_le32(0xFFFFFFFF)\n};\n\nstatic_assert(sizeof(enum ATTR_TYPE) == 4);\n\nenum FILE_ATTRIBUTE {\n\tFILE_ATTRIBUTE_READONLY\t\t= cpu_to_le32(0x00000001),\n\tFILE_ATTRIBUTE_HIDDEN\t\t= cpu_to_le32(0x00000002),\n\tFILE_ATTRIBUTE_SYSTEM\t\t= cpu_to_le32(0x00000004),\n\tFILE_ATTRIBUTE_ARCHIVE\t\t= cpu_to_le32(0x00000020),\n\tFILE_ATTRIBUTE_DEVICE\t\t= cpu_to_le32(0x00000040),\n\tFILE_ATTRIBUTE_TEMPORARY\t= cpu_to_le32(0x00000100),\n\tFILE_ATTRIBUTE_SPARSE_FILE\t= cpu_to_le32(0x00000200),\n\tFILE_ATTRIBUTE_REPARSE_POINT\t= cpu_to_le32(0x00000400),\n\tFILE_ATTRIBUTE_COMPRESSED\t= cpu_to_le32(0x00000800),\n\tFILE_ATTRIBUTE_OFFLINE\t\t= cpu_to_le32(0x00001000),\n\tFILE_ATTRIBUTE_NOT_CONTENT_INDEXED = cpu_to_le32(0x00002000),\n\tFILE_ATTRIBUTE_ENCRYPTED\t= cpu_to_le32(0x00004000),\n\tFILE_ATTRIBUTE_VALID_FLAGS\t= cpu_to_le32(0x00007fb7),\n\tFILE_ATTRIBUTE_DIRECTORY\t= cpu_to_le32(0x10000000),\n\tFILE_ATTRIBUTE_INDEX\t\t= cpu_to_le32(0x20000000)\n};\n\nstatic_assert(sizeof(enum FILE_ATTRIBUTE) == 4);\n\nextern const struct cpu_str NAME_MFT;\nextern const struct cpu_str NAME_MIRROR;\nextern const struct cpu_str NAME_LOGFILE;\nextern const struct cpu_str NAME_VOLUME;\nextern const struct cpu_str NAME_ATTRDEF;\nextern const struct cpu_str NAME_ROOT;\nextern const struct cpu_str NAME_BITMAP;\nextern const struct cpu_str NAME_BOOT;\nextern const struct cpu_str NAME_BADCLUS;\nextern const struct cpu_str NAME_QUOTA;\nextern const struct cpu_str NAME_SECURE;\nextern const struct cpu_str NAME_UPCASE;\nextern const struct cpu_str NAME_EXTEND;\nextern const struct cpu_str NAME_OBJID;\nextern const struct cpu_str NAME_REPARSE;\nextern const struct cpu_str NAME_USNJRNL;\n\nextern const __le16 I30_NAME[4];\nextern const __le16 SII_NAME[4];\nextern const __le16 SDH_NAME[4];\nextern const __le16 SO_NAME[2];\nextern const __le16 SQ_NAME[2];\nextern const __le16 SR_NAME[2];\n\nextern const __le16 BAD_NAME[4];\nextern const __le16 SDS_NAME[4];\nextern const __le16 WOF_NAME[17];\t \n\n \nstruct MFT_REF {\n\t__le32 low;\t\n\t__le16 high;\t\n\t__le16 seq;\t\n};\n\nstatic_assert(sizeof(__le64) == sizeof(struct MFT_REF));\n\nstatic inline CLST ino_get(const struct MFT_REF *ref)\n{\n#ifdef CONFIG_NTFS3_64BIT_CLUSTER\n\treturn le32_to_cpu(ref->low) | ((u64)le16_to_cpu(ref->high) << 32);\n#else\n\treturn le32_to_cpu(ref->low);\n#endif\n}\n\nstruct NTFS_BOOT {\n\tu8 jump_code[3];\t\n\tu8 system_id[8];\t\n\n\t\n\t\n\t\n\tu8 bytes_per_sector[2];\t\n\n\tu8 sectors_per_clusters;\n\tu8 unused1[7];\n\tu8 media_type;\t\t\n\tu8 unused2[2];\n\t__le16 sct_per_track;\t\n\t__le16 heads;\t\t\n\t__le32 hidden_sectors;\t\n\tu8 unused3[4];\n\tu8 bios_drive_num;\t\n\tu8 unused4;\n\tu8 signature_ex;\t\n\tu8 unused5;\n\t__le64 sectors_per_volume;\n\t__le64 mft_clst;\t\n\t__le64 mft2_clst;\t\n\ts8 record_size;\t\t\n\tu8 unused6[3];\n\ts8 index_size;\t\t\n\tu8 unused7[3];\n\t__le64 serial_num;\t\n\t__le32 check_sum;\t\n\t\t\t\t\n\n\tu8 boot_code[0x200 - 0x50 - 2 - 4]; \n\tu8 boot_magic[2];\t\n};\n\nstatic_assert(sizeof(struct NTFS_BOOT) == 0x200);\n\nenum NTFS_SIGNATURE {\n\tNTFS_FILE_SIGNATURE = cpu_to_le32(0x454C4946), \n\tNTFS_INDX_SIGNATURE = cpu_to_le32(0x58444E49), \n\tNTFS_CHKD_SIGNATURE = cpu_to_le32(0x444B4843), \n\tNTFS_RSTR_SIGNATURE = cpu_to_le32(0x52545352), \n\tNTFS_RCRD_SIGNATURE = cpu_to_le32(0x44524352), \n\tNTFS_BAAD_SIGNATURE = cpu_to_le32(0x44414142), \n\tNTFS_HOLE_SIGNATURE = cpu_to_le32(0x454C4F48), \n\tNTFS_FFFF_SIGNATURE = cpu_to_le32(0xffffffff),\n};\n\nstatic_assert(sizeof(enum NTFS_SIGNATURE) == 4);\n\n \nstruct NTFS_RECORD_HEADER {\n\t \n\tenum NTFS_SIGNATURE sign; \n\t__le16 fix_off;\t\t\n\t__le16 fix_num;\t\t\n\t__le64 lsn;\t\t\n};\n\nstatic_assert(sizeof(struct NTFS_RECORD_HEADER) == 0x10);\n\nstatic inline int is_baad(const struct NTFS_RECORD_HEADER *hdr)\n{\n\treturn hdr->sign == NTFS_BAAD_SIGNATURE;\n}\n\n \nenum RECORD_FLAG {\n\tRECORD_FLAG_IN_USE\t= cpu_to_le16(0x0001),\n\tRECORD_FLAG_DIR\t\t= cpu_to_le16(0x0002),\n\tRECORD_FLAG_SYSTEM\t= cpu_to_le16(0x0004),\n\tRECORD_FLAG_INDEX\t= cpu_to_le16(0x0008),\n};\n\n \nstruct MFT_REC {\n\tstruct NTFS_RECORD_HEADER rhdr; \n\n\t__le16 seq;\t\t\n\t__le16 hard_links;\t\n\t__le16 attr_off;\t\n\t__le16 flags;\t\t\n\t__le32 used;\t\t\n\t__le32 total;\t\t\n\n\tstruct MFT_REF parent_ref; \n\t__le16 next_attr_id;\t\n\n\t__le16 res;\t\t\n\t__le32 mft_record;\t\n\t__le16 fixups[];\t\n};\n\n#define MFTRECORD_FIXUP_OFFSET_1 offsetof(struct MFT_REC, res)\n#define MFTRECORD_FIXUP_OFFSET_3 offsetof(struct MFT_REC, fixups)\n \n#define MFTRECORD_FIXUP_OFFSET  MFTRECORD_FIXUP_OFFSET_1\n\nstatic_assert(MFTRECORD_FIXUP_OFFSET_1 == 0x2A);\nstatic_assert(MFTRECORD_FIXUP_OFFSET_3 == 0x30);\n\nstatic inline bool is_rec_base(const struct MFT_REC *rec)\n{\n\tconst struct MFT_REF *r = &rec->parent_ref;\n\n\treturn !r->low && !r->high && !r->seq;\n}\n\nstatic inline bool is_mft_rec5(const struct MFT_REC *rec)\n{\n\treturn le16_to_cpu(rec->rhdr.fix_off) >=\n\t       offsetof(struct MFT_REC, fixups);\n}\n\nstatic inline bool is_rec_inuse(const struct MFT_REC *rec)\n{\n\treturn rec->flags & RECORD_FLAG_IN_USE;\n}\n\nstatic inline bool clear_rec_inuse(struct MFT_REC *rec)\n{\n\treturn rec->flags &= ~RECORD_FLAG_IN_USE;\n}\n\n \n#define RESIDENT_FLAG_INDEXED 0x01\n\nstruct ATTR_RESIDENT {\n\t__le32 data_size;\t\n\t__le16 data_off;\t\n\tu8 flags;\t\t\n\tu8 res;\t\t\t\n}; \n\nstruct ATTR_NONRESIDENT {\n\t__le64 svcn;\t\t\n\t__le64 evcn;\t\t\n\t__le16 run_off;\t\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n        \n        \n\t\n\t\n\t\n\tu8 c_unit;\t\t\n\tu8 res1[5];\t\t\n\t__le64 alloc_size;\t\n\t\t\t\t\n\t__le64 data_size;\t\n\t__le64 valid_size;\t\n\t__le64 total_size;\t\n\t\t\t\t\n\t\t\t\t\n\n}; \n\n \n#define ATTR_FLAG_COMPRESSED\t  cpu_to_le16(0x0001)\n#define ATTR_FLAG_COMPRESSED_MASK cpu_to_le16(0x00FF)\n#define ATTR_FLAG_ENCRYPTED\t  cpu_to_le16(0x4000)\n#define ATTR_FLAG_SPARSED\t  cpu_to_le16(0x8000)\n\nstruct ATTRIB {\n\tenum ATTR_TYPE type;\t\n\t__le32 size;\t\t\n\tu8 non_res;\t\t\n\tu8 name_len;\t\t\n\t__le16 name_off;\t\n\t__le16 flags;\t\t\n\t__le16 id;\t\t\n\n\tunion {\n\t\tstruct ATTR_RESIDENT res;     \n\t\tstruct ATTR_NONRESIDENT nres; \n\t};\n};\n\n \n#define SIZEOF_RESIDENT\t\t\t0x18\n#define SIZEOF_NONRESIDENT_EX\t\t0x48\n#define SIZEOF_NONRESIDENT\t\t0x40\n\n#define SIZEOF_RESIDENT_LE\t\tcpu_to_le16(0x18)\n#define SIZEOF_NONRESIDENT_EX_LE\tcpu_to_le16(0x48)\n#define SIZEOF_NONRESIDENT_LE\t\tcpu_to_le16(0x40)\n\nstatic inline u64 attr_ondisk_size(const struct ATTRIB *attr)\n{\n\treturn attr->non_res ? ((attr->flags &\n\t\t\t\t (ATTR_FLAG_COMPRESSED | ATTR_FLAG_SPARSED)) ?\n\t\t\t\t\tle64_to_cpu(attr->nres.total_size) :\n\t\t\t\t\tle64_to_cpu(attr->nres.alloc_size))\n\t\t\t     : ALIGN(le32_to_cpu(attr->res.data_size), 8);\n}\n\nstatic inline u64 attr_size(const struct ATTRIB *attr)\n{\n\treturn attr->non_res ? le64_to_cpu(attr->nres.data_size) :\n\t\t\t       le32_to_cpu(attr->res.data_size);\n}\n\nstatic inline bool is_attr_encrypted(const struct ATTRIB *attr)\n{\n\treturn attr->flags & ATTR_FLAG_ENCRYPTED;\n}\n\nstatic inline bool is_attr_sparsed(const struct ATTRIB *attr)\n{\n\treturn attr->flags & ATTR_FLAG_SPARSED;\n}\n\nstatic inline bool is_attr_compressed(const struct ATTRIB *attr)\n{\n\treturn attr->flags & ATTR_FLAG_COMPRESSED;\n}\n\nstatic inline bool is_attr_ext(const struct ATTRIB *attr)\n{\n\treturn attr->flags & (ATTR_FLAG_SPARSED | ATTR_FLAG_COMPRESSED);\n}\n\nstatic inline bool is_attr_indexed(const struct ATTRIB *attr)\n{\n\treturn !attr->non_res && (attr->res.flags & RESIDENT_FLAG_INDEXED);\n}\n\nstatic inline __le16 const *attr_name(const struct ATTRIB *attr)\n{\n\treturn Add2Ptr(attr, le16_to_cpu(attr->name_off));\n}\n\nstatic inline u64 attr_svcn(const struct ATTRIB *attr)\n{\n\treturn attr->non_res ? le64_to_cpu(attr->nres.svcn) : 0;\n}\n\nstatic_assert(sizeof(struct ATTRIB) == 0x48);\nstatic_assert(sizeof(((struct ATTRIB *)NULL)->res) == 0x08);\nstatic_assert(sizeof(((struct ATTRIB *)NULL)->nres) == 0x38);\n\nstatic inline void *resident_data_ex(const struct ATTRIB *attr, u32 datasize)\n{\n\tu32 asize, rsize;\n\tu16 off;\n\n\tif (attr->non_res)\n\t\treturn NULL;\n\n\tasize = le32_to_cpu(attr->size);\n\toff = le16_to_cpu(attr->res.data_off);\n\n\tif (asize < datasize + off)\n\t\treturn NULL;\n\n\trsize = le32_to_cpu(attr->res.data_size);\n\tif (rsize < datasize)\n\t\treturn NULL;\n\n\treturn Add2Ptr(attr, off);\n}\n\nstatic inline void *resident_data(const struct ATTRIB *attr)\n{\n\treturn Add2Ptr(attr, le16_to_cpu(attr->res.data_off));\n}\n\nstatic inline void *attr_run(const struct ATTRIB *attr)\n{\n\treturn Add2Ptr(attr, le16_to_cpu(attr->nres.run_off));\n}\n\n \nstruct ATTR_STD_INFO {\n\t__le64 cr_time;\t\t\n\t__le64 m_time;\t\t\n\t__le64 c_time;\t\t\n\t__le64 a_time;\t\t\n\tenum FILE_ATTRIBUTE fa;\t\n\t__le32 max_ver_num;\t\n\t__le32 ver_num;\t\t\n\t__le32 class_id;\t\n};\n\nstatic_assert(sizeof(struct ATTR_STD_INFO) == 0x30);\n\n#define SECURITY_ID_INVALID 0x00000000\n#define SECURITY_ID_FIRST 0x00000100\n\nstruct ATTR_STD_INFO5 {\n\t__le64 cr_time;\t\t\n\t__le64 m_time;\t\t\n\t__le64 c_time;\t\t\n\t__le64 a_time;\t\t\n\tenum FILE_ATTRIBUTE fa;\t\n\t__le32 max_ver_num;\t\n\t__le32 ver_num;\t\t\n\t__le32 class_id;\t\n\n\t__le32 owner_id;\t\n\t__le32 security_id;\t\n\t__le64 quota_charge;\t\n\t__le64 usn;\t\t\n\t\t\t\t\n\t\t\t\t\n};\n\nstatic_assert(sizeof(struct ATTR_STD_INFO5) == 0x48);\n\n \nstruct ATTR_LIST_ENTRY {\n\tenum ATTR_TYPE type;\t\n\t__le16 size;\t\t\n\tu8 name_len;\t\t\n\tu8 name_off;\t\t\n\t__le64 vcn;\t\t\n\tstruct MFT_REF ref;\t\n\t__le16 id;\t\t\n\t__le16 name[3];\t\t\n\n}; \n\nstatic_assert(sizeof(struct ATTR_LIST_ENTRY) == 0x20);\n\nstatic inline u32 le_size(u8 name_len)\n{\n\treturn ALIGN(offsetof(struct ATTR_LIST_ENTRY, name) +\n\t\t     name_len * sizeof(short), 8);\n}\n\n \nstatic inline int le_cmp(const struct ATTR_LIST_ENTRY *le,\n\t\t\t const struct ATTRIB *attr)\n{\n\treturn le->type != attr->type || le->name_len != attr->name_len ||\n\t       (!le->name_len &&\n\t\tmemcmp(Add2Ptr(le, le->name_off),\n\t\t       Add2Ptr(attr, le16_to_cpu(attr->name_off)),\n\t\t       le->name_len * sizeof(short)));\n}\n\nstatic inline __le16 const *le_name(const struct ATTR_LIST_ENTRY *le)\n{\n\treturn Add2Ptr(le, le->name_off);\n}\n\n \n#define FILE_NAME_POSIX   0\n#define FILE_NAME_UNICODE 1\n#define FILE_NAME_DOS\t  2\n#define FILE_NAME_UNICODE_AND_DOS (FILE_NAME_DOS | FILE_NAME_UNICODE)\n\n \nstruct NTFS_DUP_INFO {\n\t__le64 cr_time;\t\t\n\t__le64 m_time;\t\t\n\t__le64 c_time;\t\t\n\t__le64 a_time;\t\t\n\t__le64 alloc_size;\t\n\t__le64 data_size;\t\n\tenum FILE_ATTRIBUTE fa;\t\n\t__le16 ea_size;\t\t\n\t__le16 reparse;\t\t\n\n}; \n\nstruct ATTR_FILE_NAME {\n\tstruct MFT_REF home;\t\n\tstruct NTFS_DUP_INFO dup;\n\tu8 name_len;\t\t\n\tu8 type;\t\t\n\t__le16 name[];\t\t\n};\n\nstatic_assert(sizeof(((struct ATTR_FILE_NAME *)NULL)->dup) == 0x38);\nstatic_assert(offsetof(struct ATTR_FILE_NAME, name) == 0x42);\n#define SIZEOF_ATTRIBUTE_FILENAME     0x44\n#define SIZEOF_ATTRIBUTE_FILENAME_MAX (0x42 + 255 * 2)\n\nstatic inline struct ATTRIB *attr_from_name(struct ATTR_FILE_NAME *fname)\n{\n\treturn (struct ATTRIB *)((char *)fname - SIZEOF_RESIDENT);\n}\n\nstatic inline u16 fname_full_size(const struct ATTR_FILE_NAME *fname)\n{\n\t \n\treturn offsetof(struct ATTR_FILE_NAME, name) +\n\t       fname->name_len * sizeof(short);\n}\n\nstatic inline u8 paired_name(u8 type)\n{\n\tif (type == FILE_NAME_UNICODE)\n\t\treturn FILE_NAME_DOS;\n\tif (type == FILE_NAME_DOS)\n\t\treturn FILE_NAME_UNICODE;\n\treturn FILE_NAME_POSIX;\n}\n\n \n#define NTFS_IE_HAS_SUBNODES\tcpu_to_le16(1)\n#define NTFS_IE_LAST\t\tcpu_to_le16(2)\n\n \nstruct NTFS_DE {\n\tunion {\n\t\tstruct MFT_REF ref; \n\t\tstruct {\n\t\t\t__le16 data_off;  \n\t\t\t__le16 data_size; \n\t\t\t__le32 res;\t  \n\t\t} view;\n\t};\n\t__le16 size;\t\t\n\t__le16 key_size;\t\n\t__le16 flags;\t\t\n\t__le16 res;\t\t\n\n\t\n\t\n\t\n\t\n\n\t\n\t\n\t\n\t\n\t\n};\n\nstatic_assert(sizeof(struct NTFS_DE) == 0x10);\n\nstatic inline void de_set_vbn_le(struct NTFS_DE *e, __le64 vcn)\n{\n\t__le64 *v = Add2Ptr(e, le16_to_cpu(e->size) - sizeof(__le64));\n\n\t*v = vcn;\n}\n\nstatic inline void de_set_vbn(struct NTFS_DE *e, CLST vcn)\n{\n\t__le64 *v = Add2Ptr(e, le16_to_cpu(e->size) - sizeof(__le64));\n\n\t*v = cpu_to_le64(vcn);\n}\n\nstatic inline __le64 de_get_vbn_le(const struct NTFS_DE *e)\n{\n\treturn *(__le64 *)Add2Ptr(e, le16_to_cpu(e->size) - sizeof(__le64));\n}\n\nstatic inline CLST de_get_vbn(const struct NTFS_DE *e)\n{\n\t__le64 *v = Add2Ptr(e, le16_to_cpu(e->size) - sizeof(__le64));\n\n\treturn le64_to_cpu(*v);\n}\n\nstatic inline struct NTFS_DE *de_get_next(const struct NTFS_DE *e)\n{\n\treturn Add2Ptr(e, le16_to_cpu(e->size));\n}\n\nstatic inline struct ATTR_FILE_NAME *de_get_fname(const struct NTFS_DE *e)\n{\n\treturn le16_to_cpu(e->key_size) >= SIZEOF_ATTRIBUTE_FILENAME ?\n\t\t       Add2Ptr(e, sizeof(struct NTFS_DE)) :\n\t\t       NULL;\n}\n\nstatic inline bool de_is_last(const struct NTFS_DE *e)\n{\n\treturn e->flags & NTFS_IE_LAST;\n}\n\nstatic inline bool de_has_vcn(const struct NTFS_DE *e)\n{\n\treturn e->flags & NTFS_IE_HAS_SUBNODES;\n}\n\nstatic inline bool de_has_vcn_ex(const struct NTFS_DE *e)\n{\n\treturn (e->flags & NTFS_IE_HAS_SUBNODES) &&\n\t       (u64)(-1) != *((u64 *)Add2Ptr(e, le16_to_cpu(e->size) -\n\t\t\t\t\t\t\tsizeof(__le64)));\n}\n\n#define MAX_BYTES_PER_NAME_ENTRY \\\n\tALIGN(sizeof(struct NTFS_DE) + \\\n\t      offsetof(struct ATTR_FILE_NAME, name) + \\\n\t      NTFS_NAME_LEN * sizeof(short), 8)\n\nstruct INDEX_HDR {\n\t__le32 de_off;\t\n\t\t\t\n\t__le32 used;\t\n\t\t\t\n\t__le32 total;\t\n\tu8 flags;\t\n\tu8 res[3];\n\n\t\n\t\n\t\n};\n\nstatic_assert(sizeof(struct INDEX_HDR) == 0x10);\n\nstatic inline struct NTFS_DE *hdr_first_de(const struct INDEX_HDR *hdr)\n{\n\tu32 de_off = le32_to_cpu(hdr->de_off);\n\tu32 used = le32_to_cpu(hdr->used);\n\tstruct NTFS_DE *e;\n\tu16 esize;\n\n\tif (de_off >= used || de_off + sizeof(struct NTFS_DE) > used )\n\t\treturn NULL;\n\n\te = Add2Ptr(hdr, de_off);\n\tesize = le16_to_cpu(e->size);\n\tif (esize < sizeof(struct NTFS_DE) || de_off + esize > used)\n\t\treturn NULL;\n\n\treturn e;\n}\n\nstatic inline struct NTFS_DE *hdr_next_de(const struct INDEX_HDR *hdr,\n\t\t\t\t\t  const struct NTFS_DE *e)\n{\n\tsize_t off = PtrOffset(hdr, e);\n\tu32 used = le32_to_cpu(hdr->used);\n\tu16 esize;\n\n\tif (off >= used)\n\t\treturn NULL;\n\n\tesize = le16_to_cpu(e->size);\n\n\tif (esize < sizeof(struct NTFS_DE) ||\n\t    off + esize + sizeof(struct NTFS_DE) > used)\n\t\treturn NULL;\n\n\treturn Add2Ptr(e, esize);\n}\n\nstatic inline bool hdr_has_subnode(const struct INDEX_HDR *hdr)\n{\n\treturn hdr->flags & 1;\n}\n\nstruct INDEX_BUFFER {\n\tstruct NTFS_RECORD_HEADER rhdr; \n\t__le64 vbn; \n\tstruct INDEX_HDR ihdr; \n};\n\nstatic_assert(sizeof(struct INDEX_BUFFER) == 0x28);\n\nstatic inline bool ib_is_empty(const struct INDEX_BUFFER *ib)\n{\n\tconst struct NTFS_DE *first = hdr_first_de(&ib->ihdr);\n\n\treturn !first || de_is_last(first);\n}\n\nstatic inline bool ib_is_leaf(const struct INDEX_BUFFER *ib)\n{\n\treturn !(ib->ihdr.flags & 1);\n}\n\n \nenum COLLATION_RULE {\n\tNTFS_COLLATION_TYPE_BINARY\t= cpu_to_le32(0),\n\t\n\tNTFS_COLLATION_TYPE_FILENAME\t= cpu_to_le32(0x01),\n\t\n\tNTFS_COLLATION_TYPE_UINT\t= cpu_to_le32(0x10),\n\t\n\tNTFS_COLLATION_TYPE_SID\t\t= cpu_to_le32(0x11),\n\t\n\tNTFS_COLLATION_TYPE_SECURITY_HASH = cpu_to_le32(0x12),\n\t\n\tNTFS_COLLATION_TYPE_UINTS\t= cpu_to_le32(0x13)\n};\n\nstatic_assert(sizeof(enum COLLATION_RULE) == 4);\n\n\nstruct INDEX_ROOT {\n\tenum ATTR_TYPE type;\t\n\tenum COLLATION_RULE rule; \n\t__le32 index_block_size;\n\tu8 index_block_clst;\t\n\tu8 res[3];\n\tstruct INDEX_HDR ihdr;\t\n};\n\nstatic_assert(sizeof(struct INDEX_ROOT) == 0x20);\nstatic_assert(offsetof(struct INDEX_ROOT, ihdr) == 0x10);\n\n#define VOLUME_FLAG_DIRTY\t    cpu_to_le16(0x0001)\n#define VOLUME_FLAG_RESIZE_LOG_FILE cpu_to_le16(0x0002)\n\nstruct VOLUME_INFO {\n\t__le64 res1;\t\n\tu8 major_ver;\t\n\tu8 minor_ver;\t\n\t__le16 flags;\t\n\n}; \n\n#define SIZEOF_ATTRIBUTE_VOLUME_INFO 0xc\n\n#define NTFS_LABEL_MAX_LENGTH\t\t(0x100 / sizeof(short))\n#define NTFS_ATTR_INDEXABLE\t\tcpu_to_le32(0x00000002)\n#define NTFS_ATTR_DUPALLOWED\t\tcpu_to_le32(0x00000004)\n#define NTFS_ATTR_MUST_BE_INDEXED\tcpu_to_le32(0x00000010)\n#define NTFS_ATTR_MUST_BE_NAMED\t\tcpu_to_le32(0x00000020)\n#define NTFS_ATTR_MUST_BE_RESIDENT\tcpu_to_le32(0x00000040)\n#define NTFS_ATTR_LOG_ALWAYS\t\tcpu_to_le32(0x00000080)\n\n \nstruct ATTR_DEF_ENTRY {\n\t__le16 name[0x40];\t\n\tenum ATTR_TYPE type;\t\n\t__le32 res;\t\t\n\tenum COLLATION_RULE rule; \n\t__le32 flags;\t\t\n\t__le64 min_sz;\t\t\n\t__le64 max_sz;\t\t\n};\n\nstatic_assert(sizeof(struct ATTR_DEF_ENTRY) == 0xa0);\n\n \nstruct OBJECT_ID {\n\tstruct GUID ObjId;\t\n\n\t\n\t\n\tstruct GUID BirthVolumeId; \n\n\t\n\t\n\t\n\t\n\tstruct GUID BirthObjectId; \n\n\t\n\t\n\t\n\t\n\tstruct GUID DomainId;\t\n};\n\nstatic_assert(sizeof(struct OBJECT_ID) == 0x40);\n\n \nstruct NTFS_DE_O {\n\tstruct NTFS_DE de;\n\tstruct GUID ObjId;\t\n\tstruct MFT_REF ref;\t\n\n\t\n\t\n\tstruct GUID BirthVolumeId; \n\n\t\n\t\n\t\n\t\n\t\n\tstruct GUID BirthObjectId; \n\n\t\n\t\n\t\n\t\n\tstruct GUID BirthDomainId; \n};\n\nstatic_assert(sizeof(struct NTFS_DE_O) == 0x58);\n\n \nstruct NTFS_DE_Q {\n\tstruct NTFS_DE de;\n\t__le32 owner_id;\t\n\n\t \n\t__le32 Version;\t\t\n\t__le32 Flags;\t\t\n\t__le64 BytesUsed;\t\n\t__le64 ChangeTime;\t\n\t__le64 WarningLimit;\t\n\t__le64 HardLimit;\t\n\t__le64 ExceededTime;\t\n\n\t\n}__packed; \n\nstatic_assert(sizeof(struct NTFS_DE_Q) == 0x44);\n\n#define SecurityDescriptorsBlockSize 0x40000 \n#define SecurityDescriptorMaxSize    0x20000 \n#define Log2OfSecurityDescriptorsBlockSize 18\n\nstruct SECURITY_KEY {\n\t__le32 hash; \n\t__le32 sec_id; \n};\n\n \nstruct SECURITY_HDR {\n\tstruct SECURITY_KEY key;\t\n\t__le64 off;\t\t\t\n\t__le32 size;\t\t\t\n\t \n} __packed;\n\nstatic_assert(sizeof(struct SECURITY_HDR) == 0x14);\n\n \nstruct NTFS_DE_SII {\n\tstruct NTFS_DE de;\n\t__le32 sec_id;\t\t\t\n\tstruct SECURITY_HDR sec_hdr;\t\n} __packed;\n\nstatic_assert(offsetof(struct NTFS_DE_SII, sec_hdr) == 0x14);\nstatic_assert(sizeof(struct NTFS_DE_SII) == 0x28);\n\n \nstruct NTFS_DE_SDH {\n\tstruct NTFS_DE de;\n\tstruct SECURITY_KEY key;\t\n\tstruct SECURITY_HDR sec_hdr;\t\n\t__le16 magic[2];\t\t\n};\n\n#define SIZEOF_SDH_DIRENTRY 0x30\n\nstruct REPARSE_KEY {\n\t__le32 ReparseTag;\t\t\n\tstruct MFT_REF ref;\t\t\n}; \n\nstatic_assert(offsetof(struct REPARSE_KEY, ref) == 0x04);\n#define SIZEOF_REPARSE_KEY 0x0C\n\n \nstruct NTFS_DE_R {\n\tstruct NTFS_DE de;\n\tstruct REPARSE_KEY key;\t\t\n\tu32 zero;\t\t\t\n}; \n\nstatic_assert(sizeof(struct NTFS_DE_R) == 0x20);\n\n \n#define WOF_CURRENT_VERSION\t\tcpu_to_le32(1)\n \n#define WOF_PROVIDER_WIM\t\tcpu_to_le32(1)\n \n#define WOF_PROVIDER_SYSTEM\t\tcpu_to_le32(2)\n \n#define WOF_PROVIDER_CURRENT_VERSION\tcpu_to_le32(1)\n\n#define WOF_COMPRESSION_XPRESS4K\tcpu_to_le32(0) \n#define WOF_COMPRESSION_LZX32K\t\tcpu_to_le32(1) \n#define WOF_COMPRESSION_XPRESS8K\tcpu_to_le32(2) \n#define WOF_COMPRESSION_XPRESS16K\tcpu_to_le32(3) \n\n \nstruct REPARSE_POINT {\n\t__le32 ReparseTag;\t\n\t__le16 ReparseDataLength;\n\t__le16 Reserved;\n\n\tstruct GUID Guid;\t\n\n\t\n\t\n\t\n};\n\nstatic_assert(sizeof(struct REPARSE_POINT) == 0x18);\n\n \n#define MAXIMUM_REPARSE_DATA_BUFFER_SIZE\t(16 * 1024)\n\n \n#define IO_REPARSE_TAG_RESERVED_RANGE\t\t1\n\n \n\n \n#define IsReparseTagMicrosoft(_tag)\t(((_tag)&IO_REPARSE_TAG_MICROSOFT))\n\n \n#define IsReparseTagNameSurrogate(_tag)\t(((_tag)&IO_REPARSE_TAG_NAME_SURROGATE))\n\n \n#define IO_REPARSE_TAG_VALID_VALUES\t0xF000FFFF\n\n \n#define IsReparseTagValid(_tag)\t\t\t\t\t\t       \\\n\t(!((_tag) & ~IO_REPARSE_TAG_VALID_VALUES) &&\t\t\t       \\\n\t ((_tag) > IO_REPARSE_TAG_RESERVED_RANGE))\n\n \n\nenum IO_REPARSE_TAG {\n\tIO_REPARSE_TAG_SYMBOLIC_LINK\t= cpu_to_le32(0),\n\tIO_REPARSE_TAG_NAME_SURROGATE\t= cpu_to_le32(0x20000000),\n\tIO_REPARSE_TAG_MICROSOFT\t= cpu_to_le32(0x80000000),\n\tIO_REPARSE_TAG_MOUNT_POINT\t= cpu_to_le32(0xA0000003),\n\tIO_REPARSE_TAG_SYMLINK\t\t= cpu_to_le32(0xA000000C),\n\tIO_REPARSE_TAG_HSM\t\t= cpu_to_le32(0xC0000004),\n\tIO_REPARSE_TAG_SIS\t\t= cpu_to_le32(0x80000007),\n\tIO_REPARSE_TAG_DEDUP\t\t= cpu_to_le32(0x80000013),\n\tIO_REPARSE_TAG_COMPRESS\t\t= cpu_to_le32(0x80000017),\n\n\t \n\n\t \n\tIO_REPARSE_TAG_DFS\t= cpu_to_le32(0x8000000A),\n\n\t \n\tIO_REPARSE_TAG_FILTER_MANAGER\t= cpu_to_le32(0x8000000B),\n\n\t \n\n\t \n\tIO_REPARSE_TAG_IFSTEST_CONGRUENT = cpu_to_le32(0x00000009),\n\n\t \n\tIO_REPARSE_TAG_ARKIVIO\t= cpu_to_le32(0x0000000C),\n\n\t \n\tIO_REPARSE_TAG_SOLUTIONSOFT\t= cpu_to_le32(0x2000000D),\n\n\t \n\tIO_REPARSE_TAG_COMMVAULT\t= cpu_to_le32(0x0000000E),\n\n\t \n\tIO_REPARSE_TAG_CLOUD\t= cpu_to_le32(0x9000001A),\n\tIO_REPARSE_TAG_CLOUD_1\t= cpu_to_le32(0x9000101A),\n\tIO_REPARSE_TAG_CLOUD_2\t= cpu_to_le32(0x9000201A),\n\tIO_REPARSE_TAG_CLOUD_3\t= cpu_to_le32(0x9000301A),\n\tIO_REPARSE_TAG_CLOUD_4\t= cpu_to_le32(0x9000401A),\n\tIO_REPARSE_TAG_CLOUD_5\t= cpu_to_le32(0x9000501A),\n\tIO_REPARSE_TAG_CLOUD_6\t= cpu_to_le32(0x9000601A),\n\tIO_REPARSE_TAG_CLOUD_7\t= cpu_to_le32(0x9000701A),\n\tIO_REPARSE_TAG_CLOUD_8\t= cpu_to_le32(0x9000801A),\n\tIO_REPARSE_TAG_CLOUD_9\t= cpu_to_le32(0x9000901A),\n\tIO_REPARSE_TAG_CLOUD_A\t= cpu_to_le32(0x9000A01A),\n\tIO_REPARSE_TAG_CLOUD_B\t= cpu_to_le32(0x9000B01A),\n\tIO_REPARSE_TAG_CLOUD_C\t= cpu_to_le32(0x9000C01A),\n\tIO_REPARSE_TAG_CLOUD_D\t= cpu_to_le32(0x9000D01A),\n\tIO_REPARSE_TAG_CLOUD_E\t= cpu_to_le32(0x9000E01A),\n\tIO_REPARSE_TAG_CLOUD_F\t= cpu_to_le32(0x9000F01A),\n\n};\n\n#define SYMLINK_FLAG_RELATIVE\t\t1\n\n \nstruct REPARSE_DATA_BUFFER {\n\t__le32 ReparseTag;\t\t\n\t__le16 ReparseDataLength;\t\n\t__le16 Reserved;\n\n\tunion {\n\t\t \n\t\tstruct {\n\t\t\t__le16 SubstituteNameOffset; \n\t\t\t__le16 SubstituteNameLength; \n\t\t\t__le16 PrintNameOffset;      \n\t\t\t__le16 PrintNameLength;      \n\t\t\t__le16 PathBuffer[];\t     \n\t\t} MountPointReparseBuffer;\n\n\t\t \n\t\tstruct {\n\t\t\t__le16 SubstituteNameOffset; \n\t\t\t__le16 SubstituteNameLength; \n\t\t\t__le16 PrintNameOffset;      \n\t\t\t__le16 PrintNameLength;      \n\t\t\t\n\t\t\t__le32 Flags;\t\t     \n\t\t\t__le16 PathBuffer[];\t     \n\t\t} SymbolicLinkReparseBuffer;\n\n\t\t \n\t\tstruct {\n\t\t\t__le32 WofVersion;  \n\t\t\t \n\t\t\t__le32 WofProvider; \n\t\t\t__le32 ProviderVer; \n\t\t\t__le32 CompressionFormat; \n\t\t} CompressReparseBuffer;\n\n\t\tstruct {\n\t\t\tu8 DataBuffer[1];   \n\t\t} GenericReparseBuffer;\n\t};\n};\n\n \n\n#define FILE_NEED_EA 0x80 \n \nstruct EA_INFO {\n\t__le16 size_pack;\t\n\t__le16 count;\t\t\n\t__le32 size;\t\t\n};\n\nstatic_assert(sizeof(struct EA_INFO) == 8);\n\n \nstruct EA_FULL {\n\t__le32 size;\t\t\n\tu8 flags;\t\t\n\tu8 name_len;\t\t\n\t__le16 elength;\t\t\n\tu8 name[];\t\t\n};\n\nstatic_assert(offsetof(struct EA_FULL, name) == 8);\n\n#define ACL_REVISION\t2\n#define ACL_REVISION_DS 4\n\n#define SE_SELF_RELATIVE cpu_to_le16(0x8000)\n\nstruct SECURITY_DESCRIPTOR_RELATIVE {\n\tu8 Revision;\n\tu8 Sbz1;\n\t__le16 Control;\n\t__le32 Owner;\n\t__le32 Group;\n\t__le32 Sacl;\n\t__le32 Dacl;\n};\nstatic_assert(sizeof(struct SECURITY_DESCRIPTOR_RELATIVE) == 0x14);\n\nstruct ACE_HEADER {\n\tu8 AceType;\n\tu8 AceFlags;\n\t__le16 AceSize;\n};\nstatic_assert(sizeof(struct ACE_HEADER) == 4);\n\nstruct ACL {\n\tu8 AclRevision;\n\tu8 Sbz1;\n\t__le16 AclSize;\n\t__le16 AceCount;\n\t__le16 Sbz2;\n};\nstatic_assert(sizeof(struct ACL) == 8);\n\nstruct SID {\n\tu8 Revision;\n\tu8 SubAuthorityCount;\n\tu8 IdentifierAuthority[6];\n\t__le32 SubAuthority[];\n};\nstatic_assert(offsetof(struct SID, SubAuthority) == 8);\n\n#endif  \n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}