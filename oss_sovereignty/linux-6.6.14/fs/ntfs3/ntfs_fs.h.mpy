{
  "module_name": "ntfs_fs.h",
  "hash_id": "ce6ce2e424722491e7d9ee5f4b92daa5cef4cf835dbb7874ac104a9f66f3a72a",
  "original_prompt": "Ingested from linux-6.6.14/fs/ntfs3/ntfs_fs.h",
  "human_readable_source": " \n \n\n\n#ifndef _LINUX_NTFS3_NTFS_FS_H\n#define _LINUX_NTFS3_NTFS_FS_H\n\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/mutex.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/time64.h>\n#include <linux/types.h>\n#include <linux/uidgid.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n\n#include \"debug.h\"\n#include \"ntfs.h\"\n\nstruct dentry;\nstruct fiemap_extent_info;\nstruct user_namespace;\nstruct page;\nstruct writeback_control;\nenum utf16_endian;\n\n\n#define MINUS_ONE_T\t\t\t((size_t)(-1))\n \n#define MAXIMUM_BYTES_PER_MFT\t\t4096\n#define MAXIMUM_SHIFT_BYTES_PER_MFT\t12\n#define NTFS_BLOCKS_PER_MFT_RECORD\t(MAXIMUM_BYTES_PER_MFT / 512)\n\n#define MAXIMUM_BYTES_PER_INDEX\t\t4096\n#define MAXIMUM_SHIFT_BYTES_PER_INDEX\t12\n#define NTFS_BLOCKS_PER_INODE\t\t(MAXIMUM_BYTES_PER_INDEX / 512)\n\n \n#define E_NTFS_FIXUP\t\t\t555\n \n#define E_NTFS_NONRESIDENT\t\t556\n \n#define E_NTFS_NOTALIGNED\t\t557\n \n#define E_NTFS_CORRUPT\t\t\t558\n\n\n \n#define NTFS_FLAGS_NODISCARD\t\t0x00000001\n \n#define NTFS_FLAGS_LOG_REPLAYING\t0x00000008\n \n#define NTFS_FLAGS_MFTMIRR\t\t0x00001000\n#define NTFS_FLAGS_NEED_REPLAY\t\t0x04000000\n\n\n \n \n#define NI_FLAG_COMPRESSED_MASK\t\t0x0000000f\n \n#define NI_FLAG_DEDUPLICATED\t\t0x00000010\n#define NI_FLAG_EA\t\t\t0x00000020\n#define NI_FLAG_DIR\t\t\t0x00000040\n#define NI_FLAG_RESIDENT\t\t0x00000080\n#define NI_FLAG_UPDATE_PARENT\t\t0x00000100\n \n\nstruct ntfs_mount_options {\n\tchar *nls_name;\n\tstruct nls_table *nls;\n\n\tkuid_t fs_uid;\n\tkgid_t fs_gid;\n\tu16 fs_fmask_inv;\n\tu16 fs_dmask_inv;\n\n\tunsigned fmask : 1;  \n\tunsigned dmask : 1;  \n\tunsigned sys_immutable : 1;  \n\tunsigned discard : 1;  \n\tunsigned sparse : 1;  \n\tunsigned showmeta : 1;  \n\tunsigned nohidden : 1;  \n\tunsigned hide_dot_files : 1;  \n\tunsigned windows_names : 1;  \n\tunsigned force : 1;  \n\tunsigned prealloc : 1;  \n\tunsigned nocase : 1;  \n};\n\n \n#define RUN_DEALLOCATE ((struct runs_tree *)(size_t)1)\n\n \nstruct runs_tree {\n\tstruct ntfs_run *runs;\n\tsize_t count;  \n\tsize_t allocated;  \n};\n\nstruct ntfs_buffers {\n\t \n\t \n\tstruct buffer_head *bh[PAGE_SIZE >> SECTOR_SHIFT];\n\tu32 bytes;\n\tu32 nbufs;\n\tu32 off;\n};\n\nenum ALLOCATE_OPT {\n\tALLOCATE_DEF = 0,  \n\tALLOCATE_MFT = 1,  \n\tALLOCATE_ZERO = 2,  \n};\n\nenum bitmap_mutex_classes {\n\tBITMAP_MUTEX_CLUSTERS = 0,\n\tBITMAP_MUTEX_MFT = 1,\n};\n\nstruct wnd_bitmap {\n\tstruct super_block *sb;\n\tstruct rw_semaphore rw_lock;\n\n\tstruct runs_tree run;\n\tsize_t nbits;\n\n\tsize_t total_zeroes;  \n\tu16 *free_bits;  \n\tsize_t nwnd;\n\tu32 bits_last;  \n\n\tstruct rb_root start_tree;  \n\tstruct rb_root count_tree;  \n\tsize_t count;  \n\n\t \n\tint uptodated;\n\tsize_t extent_min;  \n\tsize_t extent_max;  \n\n\t \n\tsize_t zone_bit;\n\tsize_t zone_end;\n\n\tbool inited;\n};\n\ntypedef int (*NTFS_CMP_FUNC)(const void *key1, size_t len1, const void *key2,\n\t\t\t     size_t len2, const void *param);\n\nenum index_mutex_classed {\n\tINDEX_MUTEX_I30 = 0,\n\tINDEX_MUTEX_SII = 1,\n\tINDEX_MUTEX_SDH = 2,\n\tINDEX_MUTEX_SO = 3,\n\tINDEX_MUTEX_SQ = 4,\n\tINDEX_MUTEX_SR = 5,\n\tINDEX_MUTEX_TOTAL\n};\n\n \nstruct ntfs_index {\n\tstruct runs_tree bitmap_run;\n\tstruct runs_tree alloc_run;\n\t \n\tstruct rw_semaphore run_lock;\n\n\t \n\tNTFS_CMP_FUNC cmp;\n\n\tu8 index_bits;  \n\tu8 idx2vbn_bits;  \n\tu8 vbn2vbo_bits;  \n\tu8 type;  \n};\n\n \n#define NTFS_MIN_MFT_ZONE 100\n \n#define NTFS_MFT_INCREASE_STEP 1024\n\n \nstruct ntfs_sb_info {\n\tstruct super_block *sb;\n\n\tu32 discard_granularity;\n\tu64 discard_granularity_mask_inv;  \n\n\tu32 cluster_size;  \n\tu32 cluster_mask;  \n\tu64 cluster_mask_inv;  \n\tu32 block_mask;  \n\tu32 blocks_per_cluster;  \n\n\tu32 record_size;\n\tu32 index_size;\n\n\tu8 cluster_bits;\n\tu8 record_bits;\n\n\tu64 maxbytes;  \n\tu64 maxbytes_sparse;  \n\n\tu32 flags;  \n\n\tCLST zone_max;  \n\tCLST bad_clusters;  \n\n\tu16 max_bytes_per_attr;  \n\tu16 attr_size_tr;  \n\n\t \n\tCLST objid_no;\n\tCLST quota_no;\n\tCLST reparse_no;\n\tCLST usn_jrnl_no;\n\n\tstruct ATTR_DEF_ENTRY *def_table;  \n\tu32 def_entries;\n\tu32 ea_max_size;\n\n\tstruct MFT_REC *new_rec;\n\n\tu16 *upcase;\n\n\tstruct {\n\t\tu64 lbo, lbo2;\n\t\tstruct ntfs_inode *ni;\n\t\tstruct wnd_bitmap bitmap;  \n\t\t \n\t\tulong reserved_bitmap;  \n\t\tsize_t next_free;  \n\t\tsize_t used;  \n\t\tu32 recs_mirr;  \n\t\tu8 next_reserved;\n\t\tu8 reserved_bitmap_inited;\n\t} mft;\n\n\tstruct {\n\t\tstruct wnd_bitmap bitmap;  \n\t\tCLST next_free_lcn;\n\t} used;\n\n\tstruct {\n\t\tu64 size;  \n\t\tu64 blocks;  \n\t\tu64 ser_num;\n\t\tstruct ntfs_inode *ni;\n\t\t__le16 flags;  \n\t\tu8 major_ver;\n\t\tu8 minor_ver;\n\t\tchar label[256];\n\t\tbool real_dirty;  \n\t} volume;\n\n\tstruct {\n\t\tstruct ntfs_index index_sii;\n\t\tstruct ntfs_index index_sdh;\n\t\tstruct ntfs_inode *ni;\n\t\tu32 next_id;\n\t\tu64 next_off;\n\t\t__le32 def_security_id;\n\t} security;\n\n\tstruct {\n\t\tstruct ntfs_index index_r;\n\t\tstruct ntfs_inode *ni;\n\t\tu64 max_size;  \n\t} reparse;\n\n\tstruct {\n\t\tstruct ntfs_index index_o;\n\t\tstruct ntfs_inode *ni;\n\t} objid;\n\n\tstruct {\n\t\tstruct mutex mtx_lznt;\n\t\tstruct lznt *lznt;\n#ifdef CONFIG_NTFS3_LZX_XPRESS\n\t\tstruct mutex mtx_xpress;\n\t\tstruct xpress_decompressor *xpress;\n\t\tstruct mutex mtx_lzx;\n\t\tstruct lzx_decompressor *lzx;\n#endif\n\t} compress;\n\n\tstruct ntfs_mount_options *options;\n\tstruct ratelimit_state msg_ratelimit;\n\tstruct proc_dir_entry *procdir;\n};\n\n \nstruct mft_inode {\n\tstruct rb_node node;\n\tstruct ntfs_sb_info *sbi;\n\n\tstruct MFT_REC *mrec;\n\tstruct ntfs_buffers nb;\n\n\tCLST rno;\n\tbool dirty;\n};\n\n \nenum ntfs_inode_mutex_lock_class {\n\tNTFS_INODE_MUTEX_DIRTY,\n\tNTFS_INODE_MUTEX_SECURITY,\n\tNTFS_INODE_MUTEX_OBJID,\n\tNTFS_INODE_MUTEX_REPARSE,\n\tNTFS_INODE_MUTEX_NORMAL,\n\tNTFS_INODE_MUTEX_PARENT,\n\tNTFS_INODE_MUTEX_PARENT2,\n};\n\n \nstruct ntfs_inode {\n\tstruct mft_inode mi;  \n\n\t \n\tu64 i_valid;\n\tstruct timespec64 i_crtime;\n\n\tstruct mutex ni_lock;\n\n\t \n\tenum FILE_ATTRIBUTE std_fa;\n\t__le32 std_security_id;\n\n\t \n\tstruct rb_root mi_tree;\n\n\t \n\tu8 mi_loaded;\n\n\tunion {\n\t\tstruct ntfs_index dir;\n\t\tstruct {\n\t\t\tstruct rw_semaphore run_lock;\n\t\t\tstruct runs_tree run;\n#ifdef CONFIG_NTFS3_LZX_XPRESS\n\t\t\tstruct page *offs_page;\n#endif\n\t\t} file;\n\t};\n\n\tstruct {\n\t\tstruct runs_tree run;\n\t\tstruct ATTR_LIST_ENTRY *le; \n\t\tsize_t size;\n\t\tbool dirty;\n\t} attr_list;\n\n\tsize_t ni_flags; \n\n\tstruct inode vfs_inode;\n};\n\nstruct indx_node {\n\tstruct ntfs_buffers nb;\n\tstruct INDEX_BUFFER *index;\n};\n\nstruct ntfs_fnd {\n\tint level;\n\tstruct indx_node *nodes[20];\n\tstruct NTFS_DE *de[20];\n\tstruct NTFS_DE *root_de;\n};\n\nenum REPARSE_SIGN {\n\tREPARSE_NONE = 0,\n\tREPARSE_COMPRESSED = 1,\n\tREPARSE_DEDUPLICATED = 2,\n\tREPARSE_LINK = 3\n};\n\n \nint attr_allocate_clusters(struct ntfs_sb_info *sbi, struct runs_tree *run,\n\t\t\t   CLST vcn, CLST lcn, CLST len, CLST *pre_alloc,\n\t\t\t   enum ALLOCATE_OPT opt, CLST *alen, const size_t fr,\n\t\t\t   CLST *new_lcn, CLST *new_len);\nint attr_make_nonresident(struct ntfs_inode *ni, struct ATTRIB *attr,\n\t\t\t  struct ATTR_LIST_ENTRY *le, struct mft_inode *mi,\n\t\t\t  u64 new_size, struct runs_tree *run,\n\t\t\t  struct ATTRIB **ins_attr, struct page *page);\nint attr_set_size(struct ntfs_inode *ni, enum ATTR_TYPE type,\n\t\t  const __le16 *name, u8 name_len, struct runs_tree *run,\n\t\t  u64 new_size, const u64 *new_valid, bool keep_prealloc,\n\t\t  struct ATTRIB **ret);\nint attr_data_get_block(struct ntfs_inode *ni, CLST vcn, CLST clen, CLST *lcn,\n\t\t\tCLST *len, bool *new, bool zero);\nint attr_data_read_resident(struct ntfs_inode *ni, struct page *page);\nint attr_data_write_resident(struct ntfs_inode *ni, struct page *page);\nint attr_load_runs_vcn(struct ntfs_inode *ni, enum ATTR_TYPE type,\n\t\t       const __le16 *name, u8 name_len, struct runs_tree *run,\n\t\t       CLST vcn);\nint attr_load_runs_range(struct ntfs_inode *ni, enum ATTR_TYPE type,\n\t\t\t const __le16 *name, u8 name_len, struct runs_tree *run,\n\t\t\t u64 from, u64 to);\nint attr_wof_frame_info(struct ntfs_inode *ni, struct ATTRIB *attr,\n\t\t\tstruct runs_tree *run, u64 frame, u64 frames,\n\t\t\tu8 frame_bits, u32 *ondisk_size, u64 *vbo_data);\nint attr_is_frame_compressed(struct ntfs_inode *ni, struct ATTRIB *attr,\n\t\t\t     CLST frame, CLST *clst_data);\nint attr_allocate_frame(struct ntfs_inode *ni, CLST frame, size_t compr_size,\n\t\t\tu64 new_valid);\nint attr_collapse_range(struct ntfs_inode *ni, u64 vbo, u64 bytes);\nint attr_insert_range(struct ntfs_inode *ni, u64 vbo, u64 bytes);\nint attr_punch_hole(struct ntfs_inode *ni, u64 vbo, u64 bytes, u32 *frame_size);\n\n \nvoid al_destroy(struct ntfs_inode *ni);\nbool al_verify(struct ntfs_inode *ni);\nint ntfs_load_attr_list(struct ntfs_inode *ni, struct ATTRIB *attr);\nstruct ATTR_LIST_ENTRY *al_enumerate(struct ntfs_inode *ni,\n\t\t\t\t     struct ATTR_LIST_ENTRY *le);\nstruct ATTR_LIST_ENTRY *al_find_le(struct ntfs_inode *ni,\n\t\t\t\t   struct ATTR_LIST_ENTRY *le,\n\t\t\t\t   const struct ATTRIB *attr);\nstruct ATTR_LIST_ENTRY *al_find_ex(struct ntfs_inode *ni,\n\t\t\t\t   struct ATTR_LIST_ENTRY *le,\n\t\t\t\t   enum ATTR_TYPE type, const __le16 *name,\n\t\t\t\t   u8 name_len, const CLST *vcn);\nint al_add_le(struct ntfs_inode *ni, enum ATTR_TYPE type, const __le16 *name,\n\t      u8 name_len, CLST svcn, __le16 id, const struct MFT_REF *ref,\n\t      struct ATTR_LIST_ENTRY **new_le);\nbool al_remove_le(struct ntfs_inode *ni, struct ATTR_LIST_ENTRY *le);\nbool al_delete_le(struct ntfs_inode *ni, enum ATTR_TYPE type, CLST vcn,\n\t\t  const __le16 *name, u8 name_len, const struct MFT_REF *ref);\nint al_update(struct ntfs_inode *ni, int sync);\nstatic inline size_t al_aligned(size_t size)\n{\n\treturn (size + 1023) & ~(size_t)1023;\n}\n\n \nbool are_bits_clear(const void *map, size_t bit, size_t nbits);\nbool are_bits_set(const void *map, size_t bit, size_t nbits);\nsize_t get_set_bits_ex(const void *map, size_t bit, size_t nbits);\n\n \nint ntfs_utf16_to_nls(struct ntfs_sb_info *sbi, const __le16 *name, u32 len,\n\t\t      u8 *buf, int buf_len);\nint ntfs_nls_to_utf16(struct ntfs_sb_info *sbi, const u8 *name, u32 name_len,\n\t\t      struct cpu_str *uni, u32 max_ulen,\n\t\t      enum utf16_endian endian);\nstruct inode *dir_search_u(struct inode *dir, const struct cpu_str *uni,\n\t\t\t   struct ntfs_fnd *fnd);\nbool dir_is_empty(struct inode *dir);\nextern const struct file_operations ntfs_dir_operations;\n\n \nint ntfs_getattr(struct mnt_idmap *idmap, const struct path *path,\n\t\t struct kstat *stat, u32 request_mask, u32 flags);\nint ntfs3_setattr(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\t  struct iattr *attr);\nint ntfs_file_open(struct inode *inode, struct file *file);\nint ntfs_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t__u64 start, __u64 len);\nextern const struct inode_operations ntfs_special_inode_operations;\nextern const struct inode_operations ntfs_file_inode_operations;\nextern const struct file_operations ntfs_file_operations;\n\n \nvoid ni_remove_mi(struct ntfs_inode *ni, struct mft_inode *mi);\nstruct ATTR_STD_INFO *ni_std(struct ntfs_inode *ni);\nstruct ATTR_STD_INFO5 *ni_std5(struct ntfs_inode *ni);\nvoid ni_clear(struct ntfs_inode *ni);\nint ni_load_mi_ex(struct ntfs_inode *ni, CLST rno, struct mft_inode **mi);\nint ni_load_mi(struct ntfs_inode *ni, const struct ATTR_LIST_ENTRY *le,\n\t       struct mft_inode **mi);\nstruct ATTRIB *ni_find_attr(struct ntfs_inode *ni, struct ATTRIB *attr,\n\t\t\t    struct ATTR_LIST_ENTRY **entry_o,\n\t\t\t    enum ATTR_TYPE type, const __le16 *name,\n\t\t\t    u8 name_len, const CLST *vcn,\n\t\t\t    struct mft_inode **mi);\nstruct ATTRIB *ni_enum_attr_ex(struct ntfs_inode *ni, struct ATTRIB *attr,\n\t\t\t       struct ATTR_LIST_ENTRY **le,\n\t\t\t       struct mft_inode **mi);\nstruct ATTRIB *ni_load_attr(struct ntfs_inode *ni, enum ATTR_TYPE type,\n\t\t\t    const __le16 *name, u8 name_len, CLST vcn,\n\t\t\t    struct mft_inode **pmi);\nint ni_load_all_mi(struct ntfs_inode *ni);\nbool ni_add_subrecord(struct ntfs_inode *ni, CLST rno, struct mft_inode **mi);\nint ni_remove_attr(struct ntfs_inode *ni, enum ATTR_TYPE type,\n\t\t   const __le16 *name, u8 name_len, bool base_only,\n\t\t   const __le16 *id);\nint ni_create_attr_list(struct ntfs_inode *ni);\nint ni_expand_list(struct ntfs_inode *ni);\nint ni_insert_nonresident(struct ntfs_inode *ni, enum ATTR_TYPE type,\n\t\t\t  const __le16 *name, u8 name_len,\n\t\t\t  const struct runs_tree *run, CLST svcn, CLST len,\n\t\t\t  __le16 flags, struct ATTRIB **new_attr,\n\t\t\t  struct mft_inode **mi, struct ATTR_LIST_ENTRY **le);\nint ni_insert_resident(struct ntfs_inode *ni, u32 data_size,\n\t\t       enum ATTR_TYPE type, const __le16 *name, u8 name_len,\n\t\t       struct ATTRIB **new_attr, struct mft_inode **mi,\n\t\t       struct ATTR_LIST_ENTRY **le);\nvoid ni_remove_attr_le(struct ntfs_inode *ni, struct ATTRIB *attr,\n\t\t       struct mft_inode *mi, struct ATTR_LIST_ENTRY *le);\nint ni_delete_all(struct ntfs_inode *ni);\nstruct ATTR_FILE_NAME *ni_fname_name(struct ntfs_inode *ni,\n\t\t\t\t     const struct le_str *uni,\n\t\t\t\t     const struct MFT_REF *home,\n\t\t\t\t     struct mft_inode **mi,\n\t\t\t\t     struct ATTR_LIST_ENTRY **entry);\nstruct ATTR_FILE_NAME *ni_fname_type(struct ntfs_inode *ni, u8 name_type,\n\t\t\t\t     struct mft_inode **mi,\n\t\t\t\t     struct ATTR_LIST_ENTRY **entry);\nint ni_new_attr_flags(struct ntfs_inode *ni, enum FILE_ATTRIBUTE new_fa);\nenum REPARSE_SIGN ni_parse_reparse(struct ntfs_inode *ni, struct ATTRIB *attr,\n\t\t\t\t   struct REPARSE_DATA_BUFFER *buffer);\nint ni_write_inode(struct inode *inode, int sync, const char *hint);\n#define _ni_write_inode(i, w) ni_write_inode(i, w, __func__)\nint ni_fiemap(struct ntfs_inode *ni, struct fiemap_extent_info *fieinfo,\n\t      __u64 vbo, __u64 len);\nint ni_readpage_cmpr(struct ntfs_inode *ni, struct page *page);\nint ni_decompress_file(struct ntfs_inode *ni);\nint ni_read_frame(struct ntfs_inode *ni, u64 frame_vbo, struct page **pages,\n\t\t  u32 pages_per_frame);\nint ni_write_frame(struct ntfs_inode *ni, struct page **pages,\n\t\t   u32 pages_per_frame);\nint ni_remove_name(struct ntfs_inode *dir_ni, struct ntfs_inode *ni,\n\t\t   struct NTFS_DE *de, struct NTFS_DE **de2, int *undo_step);\n\nbool ni_remove_name_undo(struct ntfs_inode *dir_ni, struct ntfs_inode *ni,\n\t\t\t struct NTFS_DE *de, struct NTFS_DE *de2,\n\t\t\t int undo_step);\n\nint ni_add_name(struct ntfs_inode *dir_ni, struct ntfs_inode *ni,\n\t\tstruct NTFS_DE *de);\n\nint ni_rename(struct ntfs_inode *dir_ni, struct ntfs_inode *new_dir_ni,\n\t      struct ntfs_inode *ni, struct NTFS_DE *de, struct NTFS_DE *new_de,\n\t      bool *is_bad);\n\nbool ni_is_dirty(struct inode *inode);\n\n \nbool check_index_header(const struct INDEX_HDR *hdr, size_t bytes);\nint log_replay(struct ntfs_inode *ni, bool *initialized);\n\n \nbool ntfs_fix_pre_write(struct NTFS_RECORD_HEADER *rhdr, size_t bytes);\nint ntfs_fix_post_read(struct NTFS_RECORD_HEADER *rhdr, size_t bytes,\n\t\t       bool simple);\nint ntfs_extend_init(struct ntfs_sb_info *sbi);\nint ntfs_loadlog_and_replay(struct ntfs_inode *ni, struct ntfs_sb_info *sbi);\nint ntfs_look_for_free_space(struct ntfs_sb_info *sbi, CLST lcn, CLST len,\n\t\t\t     CLST *new_lcn, CLST *new_len,\n\t\t\t     enum ALLOCATE_OPT opt);\nbool ntfs_check_for_free_space(struct ntfs_sb_info *sbi, CLST clen, CLST mlen);\nint ntfs_look_free_mft(struct ntfs_sb_info *sbi, CLST *rno, bool mft,\n\t\t       struct ntfs_inode *ni, struct mft_inode **mi);\nvoid ntfs_mark_rec_free(struct ntfs_sb_info *sbi, CLST rno, bool is_mft);\nint ntfs_clear_mft_tail(struct ntfs_sb_info *sbi, size_t from, size_t to);\nint ntfs_refresh_zone(struct ntfs_sb_info *sbi);\nvoid ntfs_update_mftmirr(struct ntfs_sb_info *sbi, int wait);\nvoid ntfs_bad_inode(struct inode *inode, const char *hint);\n#define _ntfs_bad_inode(i) ntfs_bad_inode(i, __func__)\nenum NTFS_DIRTY_FLAGS {\n\tNTFS_DIRTY_CLEAR = 0,\n\tNTFS_DIRTY_DIRTY = 1,\n\tNTFS_DIRTY_ERROR = 2,\n};\nint ntfs_set_state(struct ntfs_sb_info *sbi, enum NTFS_DIRTY_FLAGS dirty);\nint ntfs_sb_read(struct super_block *sb, u64 lbo, size_t bytes, void *buffer);\nint ntfs_sb_write(struct super_block *sb, u64 lbo, size_t bytes,\n\t\t  const void *buffer, int wait);\nint ntfs_sb_write_run(struct ntfs_sb_info *sbi, const struct runs_tree *run,\n\t\t      u64 vbo, const void *buf, size_t bytes, int sync);\nstruct buffer_head *ntfs_bread_run(struct ntfs_sb_info *sbi,\n\t\t\t\t   const struct runs_tree *run, u64 vbo);\nint ntfs_read_run_nb(struct ntfs_sb_info *sbi, const struct runs_tree *run,\n\t\t     u64 vbo, void *buf, u32 bytes, struct ntfs_buffers *nb);\nint ntfs_read_bh(struct ntfs_sb_info *sbi, const struct runs_tree *run, u64 vbo,\n\t\t struct NTFS_RECORD_HEADER *rhdr, u32 bytes,\n\t\t struct ntfs_buffers *nb);\nint ntfs_get_bh(struct ntfs_sb_info *sbi, const struct runs_tree *run, u64 vbo,\n\t\tu32 bytes, struct ntfs_buffers *nb);\nint ntfs_write_bh(struct ntfs_sb_info *sbi, struct NTFS_RECORD_HEADER *rhdr,\n\t\t  struct ntfs_buffers *nb, int sync);\nint ntfs_bio_pages(struct ntfs_sb_info *sbi, const struct runs_tree *run,\n\t\t   struct page **pages, u32 nr_pages, u64 vbo, u32 bytes,\n\t\t   enum req_op op);\nint ntfs_bio_fill_1(struct ntfs_sb_info *sbi, const struct runs_tree *run);\nint ntfs_vbo_to_lbo(struct ntfs_sb_info *sbi, const struct runs_tree *run,\n\t\t    u64 vbo, u64 *lbo, u64 *bytes);\nstruct ntfs_inode *ntfs_new_inode(struct ntfs_sb_info *sbi, CLST nRec,\n\t\t\t\t  enum RECORD_FLAG flag);\nextern const u8 s_default_security[0x50];\nbool is_sd_valid(const struct SECURITY_DESCRIPTOR_RELATIVE *sd, u32 len);\nint ntfs_security_init(struct ntfs_sb_info *sbi);\nint ntfs_get_security_by_id(struct ntfs_sb_info *sbi, __le32 security_id,\n\t\t\t    struct SECURITY_DESCRIPTOR_RELATIVE **sd,\n\t\t\t    size_t *size);\nint ntfs_insert_security(struct ntfs_sb_info *sbi,\n\t\t\t const struct SECURITY_DESCRIPTOR_RELATIVE *sd,\n\t\t\t u32 size, __le32 *security_id, bool *inserted);\nint ntfs_reparse_init(struct ntfs_sb_info *sbi);\nint ntfs_objid_init(struct ntfs_sb_info *sbi);\nint ntfs_objid_remove(struct ntfs_sb_info *sbi, struct GUID *guid);\nint ntfs_insert_reparse(struct ntfs_sb_info *sbi, __le32 rtag,\n\t\t\tconst struct MFT_REF *ref);\nint ntfs_remove_reparse(struct ntfs_sb_info *sbi, __le32 rtag,\n\t\t\tconst struct MFT_REF *ref);\nvoid mark_as_free_ex(struct ntfs_sb_info *sbi, CLST lcn, CLST len, bool trim);\nint run_deallocate(struct ntfs_sb_info *sbi, const struct runs_tree *run,\n\t\t   bool trim);\nbool valid_windows_name(struct ntfs_sb_info *sbi, const struct le_str *name);\nint ntfs_set_label(struct ntfs_sb_info *sbi, u8 *label, int len);\n\n \nint indx_used_bit(struct ntfs_index *indx, struct ntfs_inode *ni, size_t *bit);\nvoid fnd_clear(struct ntfs_fnd *fnd);\nstatic inline struct ntfs_fnd *fnd_get(void)\n{\n\treturn kzalloc(sizeof(struct ntfs_fnd), GFP_NOFS);\n}\nstatic inline void fnd_put(struct ntfs_fnd *fnd)\n{\n\tif (fnd) {\n\t\tfnd_clear(fnd);\n\t\tkfree(fnd);\n\t}\n}\nvoid indx_clear(struct ntfs_index *idx);\nint indx_init(struct ntfs_index *indx, struct ntfs_sb_info *sbi,\n\t      const struct ATTRIB *attr, enum index_mutex_classed type);\nstruct INDEX_ROOT *indx_get_root(struct ntfs_index *indx, struct ntfs_inode *ni,\n\t\t\t\t struct ATTRIB **attr, struct mft_inode **mi);\nint indx_read(struct ntfs_index *idx, struct ntfs_inode *ni, CLST vbn,\n\t      struct indx_node **node);\nint indx_find(struct ntfs_index *indx, struct ntfs_inode *dir,\n\t      const struct INDEX_ROOT *root, const void *Key, size_t KeyLen,\n\t      const void *param, int *diff, struct NTFS_DE **entry,\n\t      struct ntfs_fnd *fnd);\nint indx_find_sort(struct ntfs_index *indx, struct ntfs_inode *ni,\n\t\t   const struct INDEX_ROOT *root, struct NTFS_DE **entry,\n\t\t   struct ntfs_fnd *fnd);\nint indx_find_raw(struct ntfs_index *indx, struct ntfs_inode *ni,\n\t\t  const struct INDEX_ROOT *root, struct NTFS_DE **entry,\n\t\t  size_t *off, struct ntfs_fnd *fnd);\nint indx_insert_entry(struct ntfs_index *indx, struct ntfs_inode *ni,\n\t\t      const struct NTFS_DE *new_de, const void *param,\n\t\t      struct ntfs_fnd *fnd, bool undo);\nint indx_delete_entry(struct ntfs_index *indx, struct ntfs_inode *ni,\n\t\t      const void *key, u32 key_len, const void *param);\nint indx_update_dup(struct ntfs_inode *ni, struct ntfs_sb_info *sbi,\n\t\t    const struct ATTR_FILE_NAME *fname,\n\t\t    const struct NTFS_DUP_INFO *dup, int sync);\n\n \nstruct inode *ntfs_iget5(struct super_block *sb, const struct MFT_REF *ref,\n\t\t\t const struct cpu_str *name);\nint ntfs_set_size(struct inode *inode, u64 new_size);\nint reset_log_file(struct inode *inode);\nint ntfs_get_block(struct inode *inode, sector_t vbn,\n\t\t   struct buffer_head *bh_result, int create);\nint ntfs_write_begin(struct file *file, struct address_space *mapping,\n\t\t     loff_t pos, u32 len, struct page **pagep, void **fsdata);\nint ntfs_write_end(struct file *file, struct address_space *mapping, loff_t pos,\n\t\t   u32 len, u32 copied, struct page *page, void *fsdata);\nint ntfs3_write_inode(struct inode *inode, struct writeback_control *wbc);\nint ntfs_sync_inode(struct inode *inode);\nint ntfs_flush_inodes(struct super_block *sb, struct inode *i1,\n\t\t      struct inode *i2);\nint inode_write_data(struct inode *inode, const void *data, size_t bytes);\nstruct inode *ntfs_create_inode(struct mnt_idmap *idmap, struct inode *dir,\n\t\t\t\tstruct dentry *dentry,\n\t\t\t\tconst struct cpu_str *uni, umode_t mode,\n\t\t\t\tdev_t dev, const char *symname, u32 size,\n\t\t\t\tstruct ntfs_fnd *fnd);\nint ntfs_link_inode(struct inode *inode, struct dentry *dentry);\nint ntfs_unlink_inode(struct inode *dir, const struct dentry *dentry);\nvoid ntfs_evict_inode(struct inode *inode);\nextern const struct inode_operations ntfs_link_inode_operations;\nextern const struct address_space_operations ntfs_aops;\nextern const struct address_space_operations ntfs_aops_cmpr;\n\n \nint fill_name_de(struct ntfs_sb_info *sbi, void *buf, const struct qstr *name,\n\t\t const struct cpu_str *uni);\nstruct dentry *ntfs3_get_parent(struct dentry *child);\n\nextern const struct inode_operations ntfs_dir_inode_operations;\nextern const struct inode_operations ntfs_special_inode_operations;\nextern const struct dentry_operations ntfs_dentry_ops;\n\n \nint mi_get(struct ntfs_sb_info *sbi, CLST rno, struct mft_inode **mi);\nvoid mi_put(struct mft_inode *mi);\nint mi_init(struct mft_inode *mi, struct ntfs_sb_info *sbi, CLST rno);\nint mi_read(struct mft_inode *mi, bool is_mft);\nstruct ATTRIB *mi_enum_attr(struct mft_inode *mi, struct ATTRIB *attr);\n\nstruct ATTRIB *mi_find_attr(struct mft_inode *mi, struct ATTRIB *attr,\n\t\t\t    enum ATTR_TYPE type, const __le16 *name,\n\t\t\t    u8 name_len, const __le16 *id);\nstatic inline struct ATTRIB *rec_find_attr_le(struct mft_inode *rec,\n\t\t\t\t\t      struct ATTR_LIST_ENTRY *le)\n{\n\treturn mi_find_attr(rec, NULL, le->type, le_name(le), le->name_len,\n\t\t\t    &le->id);\n}\nint mi_write(struct mft_inode *mi, int wait);\nint mi_format_new(struct mft_inode *mi, struct ntfs_sb_info *sbi, CLST rno,\n\t\t  __le16 flags, bool is_mft);\nstruct ATTRIB *mi_insert_attr(struct mft_inode *mi, enum ATTR_TYPE type,\n\t\t\t      const __le16 *name, u8 name_len, u32 asize,\n\t\t\t      u16 name_off);\n\nbool mi_remove_attr(struct ntfs_inode *ni, struct mft_inode *mi,\n\t\t    struct ATTRIB *attr);\nbool mi_resize_attr(struct mft_inode *mi, struct ATTRIB *attr, int bytes);\nint mi_pack_runs(struct mft_inode *mi, struct ATTRIB *attr,\n\t\t struct runs_tree *run, CLST len);\nstatic inline bool mi_is_ref(const struct mft_inode *mi,\n\t\t\t     const struct MFT_REF *ref)\n{\n\tif (le32_to_cpu(ref->low) != mi->rno)\n\t\treturn false;\n\tif (ref->seq != mi->mrec->seq)\n\t\treturn false;\n\n#ifdef CONFIG_NTFS3_64BIT_CLUSTER\n\treturn le16_to_cpu(ref->high) == (mi->rno >> 32);\n#else\n\treturn !ref->high;\n#endif\n}\n\nstatic inline void mi_get_ref(const struct mft_inode *mi, struct MFT_REF *ref)\n{\n\tref->low = cpu_to_le32(mi->rno);\n#ifdef CONFIG_NTFS3_64BIT_CLUSTER\n\tref->high = cpu_to_le16(mi->rno >> 32);\n#else\n\tref->high = 0;\n#endif\n\tref->seq = mi->mrec->seq;\n}\n\n \nbool run_lookup_entry(const struct runs_tree *run, CLST vcn, CLST *lcn,\n\t\t      CLST *len, size_t *index);\nvoid run_truncate(struct runs_tree *run, CLST vcn);\nvoid run_truncate_head(struct runs_tree *run, CLST vcn);\nvoid run_truncate_around(struct runs_tree *run, CLST vcn);\nbool run_add_entry(struct runs_tree *run, CLST vcn, CLST lcn, CLST len,\n\t\t   bool is_mft);\nbool run_collapse_range(struct runs_tree *run, CLST vcn, CLST len);\nbool run_insert_range(struct runs_tree *run, CLST vcn, CLST len);\nbool run_get_entry(const struct runs_tree *run, size_t index, CLST *vcn,\n\t\t   CLST *lcn, CLST *len);\nbool run_is_mapped_full(const struct runs_tree *run, CLST svcn, CLST evcn);\n\nint run_pack(const struct runs_tree *run, CLST svcn, CLST len, u8 *run_buf,\n\t     u32 run_buf_size, CLST *packed_vcns);\nint run_unpack(struct runs_tree *run, struct ntfs_sb_info *sbi, CLST ino,\n\t       CLST svcn, CLST evcn, CLST vcn, const u8 *run_buf,\n\t       int run_buf_size);\n\n#ifdef NTFS3_CHECK_FREE_CLST\nint run_unpack_ex(struct runs_tree *run, struct ntfs_sb_info *sbi, CLST ino,\n\t\t  CLST svcn, CLST evcn, CLST vcn, const u8 *run_buf,\n\t\t  int run_buf_size);\n#else\n#define run_unpack_ex run_unpack\n#endif\nint run_get_highest_vcn(CLST vcn, const u8 *run_buf, u64 *highest_vcn);\nint run_clone(const struct runs_tree *run, struct runs_tree *new_run);\n\n \nvoid *ntfs_set_shared(void *ptr, u32 bytes);\nvoid *ntfs_put_shared(void *ptr);\nvoid ntfs_unmap_meta(struct super_block *sb, CLST lcn, CLST len);\nint ntfs_discard(struct ntfs_sb_info *sbi, CLST Lcn, CLST Len);\n\n \nint __init ntfs3_init_bitmap(void);\nvoid ntfs3_exit_bitmap(void);\nvoid wnd_close(struct wnd_bitmap *wnd);\nstatic inline size_t wnd_zeroes(const struct wnd_bitmap *wnd)\n{\n\treturn wnd->total_zeroes;\n}\nint wnd_init(struct wnd_bitmap *wnd, struct super_block *sb, size_t nbits);\nint wnd_set_free(struct wnd_bitmap *wnd, size_t bit, size_t bits);\nint wnd_set_used(struct wnd_bitmap *wnd, size_t bit, size_t bits);\nint wnd_set_used_safe(struct wnd_bitmap *wnd, size_t bit, size_t bits,\n\t\t      size_t *done);\nbool wnd_is_free(struct wnd_bitmap *wnd, size_t bit, size_t bits);\nbool wnd_is_used(struct wnd_bitmap *wnd, size_t bit, size_t bits);\n\n \n#define BITMAP_FIND_MARK_AS_USED 0x01\n#define BITMAP_FIND_FULL 0x02\nsize_t wnd_find(struct wnd_bitmap *wnd, size_t to_alloc, size_t hint,\n\t\tsize_t flags, size_t *allocated);\nint wnd_extend(struct wnd_bitmap *wnd, size_t new_bits);\nvoid wnd_zone_set(struct wnd_bitmap *wnd, size_t Lcn, size_t Len);\nint ntfs_trim_fs(struct ntfs_sb_info *sbi, struct fstrim_range *range);\n\nvoid ntfs_bitmap_set_le(void *map, unsigned int start, int len);\nvoid ntfs_bitmap_clear_le(void *map, unsigned int start, int len);\nunsigned int ntfs_bitmap_weight_le(const void *bitmap, int bits);\n\n \nint ntfs_cmp_names(const __le16 *s1, size_t l1, const __le16 *s2, size_t l2,\n\t\t   const u16 *upcase, bool bothcase);\nint ntfs_cmp_names_cpu(const struct cpu_str *uni1, const struct le_str *uni2,\n\t\t       const u16 *upcase, bool bothcase);\nunsigned long ntfs_names_hash(const u16 *name, size_t len, const u16 *upcase,\n\t\t\t      unsigned long hash);\n\n \n#ifdef CONFIG_NTFS3_FS_POSIX_ACL\nstruct posix_acl *ntfs_get_acl(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\t\t       int type);\nint ntfs_set_acl(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\t struct posix_acl *acl, int type);\nint ntfs_init_acl(struct mnt_idmap *idmap, struct inode *inode,\n\t\t  struct inode *dir);\n#else\n#define ntfs_get_acl NULL\n#define ntfs_set_acl NULL\n#endif\n\nint ntfs_acl_chmod(struct mnt_idmap *idmap, struct dentry *dentry);\nssize_t ntfs_listxattr(struct dentry *dentry, char *buffer, size_t size);\nextern const struct xattr_handler *ntfs_xattr_handlers[];\n\nint ntfs_save_wsl_perm(struct inode *inode, __le16 *ea_size);\nvoid ntfs_get_wsl_perm(struct inode *inode);\n\n \nstruct lznt *get_lznt_ctx(int level);\nsize_t compress_lznt(const void *uncompressed, size_t uncompressed_size,\n\t\t     void *compressed, size_t compressed_size,\n\t\t     struct lznt *ctx);\nssize_t decompress_lznt(const void *compressed, size_t compressed_size,\n\t\t\tvoid *uncompressed, size_t uncompressed_size);\n\nstatic inline bool is_ntfs3(struct ntfs_sb_info *sbi)\n{\n\treturn sbi->volume.major_ver >= 3;\n}\n\n \nstatic inline bool is_mounted(struct ntfs_sb_info *sbi)\n{\n\treturn !!sbi->sb->s_root;\n}\n\nstatic inline bool ntfs_is_meta_file(struct ntfs_sb_info *sbi, CLST rno)\n{\n\treturn rno < MFT_REC_FREE || rno == sbi->objid_no ||\n\t       rno == sbi->quota_no || rno == sbi->reparse_no ||\n\t       rno == sbi->usn_jrnl_no;\n}\n\nstatic inline void ntfs_unmap_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}\n\nstatic inline struct page *ntfs_map_page(struct address_space *mapping,\n\t\t\t\t\t unsigned long index)\n{\n\tstruct page *page = read_mapping_page(mapping, index, NULL);\n\n\tif (!IS_ERR(page))\n\t\tkmap(page);\n\treturn page;\n}\n\nstatic inline size_t wnd_zone_bit(const struct wnd_bitmap *wnd)\n{\n\treturn wnd->zone_bit;\n}\n\nstatic inline size_t wnd_zone_len(const struct wnd_bitmap *wnd)\n{\n\treturn wnd->zone_end - wnd->zone_bit;\n}\n\nstatic inline void run_init(struct runs_tree *run)\n{\n\trun->runs = NULL;\n\trun->count = 0;\n\trun->allocated = 0;\n}\n\nstatic inline struct runs_tree *run_alloc(void)\n{\n\treturn kzalloc(sizeof(struct runs_tree), GFP_NOFS);\n}\n\nstatic inline void run_close(struct runs_tree *run)\n{\n\tkvfree(run->runs);\n\tmemset(run, 0, sizeof(*run));\n}\n\nstatic inline void run_free(struct runs_tree *run)\n{\n\tif (run) {\n\t\tkvfree(run->runs);\n\t\tkfree(run);\n\t}\n}\n\nstatic inline bool run_is_empty(struct runs_tree *run)\n{\n\treturn !run->count;\n}\n\n \nstatic inline size_t bitmap_size(size_t bits)\n{\n\treturn ALIGN((bits + 7) >> 3, 8);\n}\n\n#define _100ns2seconds 10000000\n#define SecondsToStartOf1970 0x00000002B6109100\n\n#define NTFS_TIME_GRAN 100\n\n \nstatic inline __le64 kernel2nt(const struct timespec64 *ts)\n{\n\t\n\treturn cpu_to_le64(_100ns2seconds *\n\t\t\t\t   (ts->tv_sec + SecondsToStartOf1970) +\n\t\t\t   ts->tv_nsec / NTFS_TIME_GRAN);\n}\n\n \nstatic inline void nt2kernel(const __le64 tm, struct timespec64 *ts)\n{\n\tu64 t = le64_to_cpu(tm) - _100ns2seconds * SecondsToStartOf1970;\n\n\t\n\tts->tv_nsec = do_div(t, _100ns2seconds) * 100;\n\tts->tv_sec = t;\n}\n\nstatic inline struct ntfs_sb_info *ntfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}\n\n \nstatic inline u64 ntfs_up_cluster(const struct ntfs_sb_info *sbi, u64 size)\n{\n\treturn (size + sbi->cluster_mask) & sbi->cluster_mask_inv;\n}\n\n \nstatic inline u64 ntfs_up_block(const struct super_block *sb, u64 size)\n{\n\treturn (size + sb->s_blocksize - 1) & ~(u64)(sb->s_blocksize - 1);\n}\n\nstatic inline CLST bytes_to_cluster(const struct ntfs_sb_info *sbi, u64 size)\n{\n\treturn (size + sbi->cluster_mask) >> sbi->cluster_bits;\n}\n\nstatic inline u64 bytes_to_block(const struct super_block *sb, u64 size)\n{\n\treturn (size + sb->s_blocksize - 1) >> sb->s_blocksize_bits;\n}\n\nstatic inline struct buffer_head *ntfs_bread(struct super_block *sb,\n\t\t\t\t\t     sector_t block)\n{\n\tstruct buffer_head *bh = sb_bread(sb, block);\n\n\tif (bh)\n\t\treturn bh;\n\n\tntfs_err(sb, \"failed to read volume at offset 0x%llx\",\n\t\t (u64)block << sb->s_blocksize_bits);\n\treturn NULL;\n}\n\nstatic inline struct ntfs_inode *ntfs_i(struct inode *inode)\n{\n\treturn container_of(inode, struct ntfs_inode, vfs_inode);\n}\n\nstatic inline bool is_compressed(const struct ntfs_inode *ni)\n{\n\treturn (ni->std_fa & FILE_ATTRIBUTE_COMPRESSED) ||\n\t       (ni->ni_flags & NI_FLAG_COMPRESSED_MASK);\n}\n\nstatic inline int ni_ext_compress_bits(const struct ntfs_inode *ni)\n{\n\treturn 0xb + (ni->ni_flags & NI_FLAG_COMPRESSED_MASK);\n}\n\n \nstatic inline void ni_set_ext_compress_bits(struct ntfs_inode *ni, u8 bits)\n{\n\tni->ni_flags |= (bits - 0xb) & NI_FLAG_COMPRESSED_MASK;\n}\n\nstatic inline bool is_dedup(const struct ntfs_inode *ni)\n{\n\treturn ni->ni_flags & NI_FLAG_DEDUPLICATED;\n}\n\nstatic inline bool is_encrypted(const struct ntfs_inode *ni)\n{\n\treturn ni->std_fa & FILE_ATTRIBUTE_ENCRYPTED;\n}\n\nstatic inline bool is_sparsed(const struct ntfs_inode *ni)\n{\n\treturn ni->std_fa & FILE_ATTRIBUTE_SPARSE_FILE;\n}\n\nstatic inline int is_resident(struct ntfs_inode *ni)\n{\n\treturn ni->ni_flags & NI_FLAG_RESIDENT;\n}\n\nstatic inline void le16_sub_cpu(__le16 *var, u16 val)\n{\n\t*var = cpu_to_le16(le16_to_cpu(*var) - val);\n}\n\nstatic inline void le32_sub_cpu(__le32 *var, u32 val)\n{\n\t*var = cpu_to_le32(le32_to_cpu(*var) - val);\n}\n\nstatic inline void nb_put(struct ntfs_buffers *nb)\n{\n\tu32 i, nbufs = nb->nbufs;\n\n\tif (!nbufs)\n\t\treturn;\n\n\tfor (i = 0; i < nbufs; i++)\n\t\tput_bh(nb->bh[i]);\n\tnb->nbufs = 0;\n}\n\nstatic inline void put_indx_node(struct indx_node *in)\n{\n\tif (!in)\n\t\treturn;\n\n\tkfree(in->index);\n\tnb_put(&in->nb);\n\tkfree(in);\n}\n\nstatic inline void mi_clear(struct mft_inode *mi)\n{\n\tnb_put(&mi->nb);\n\tkfree(mi->mrec);\n\tmi->mrec = NULL;\n}\n\nstatic inline void ni_lock(struct ntfs_inode *ni)\n{\n\tmutex_lock_nested(&ni->ni_lock, NTFS_INODE_MUTEX_NORMAL);\n}\n\nstatic inline void ni_lock_dir(struct ntfs_inode *ni)\n{\n\tmutex_lock_nested(&ni->ni_lock, NTFS_INODE_MUTEX_PARENT);\n}\n\nstatic inline void ni_lock_dir2(struct ntfs_inode *ni)\n{\n\tmutex_lock_nested(&ni->ni_lock, NTFS_INODE_MUTEX_PARENT2);\n}\n\nstatic inline void ni_unlock(struct ntfs_inode *ni)\n{\n\tmutex_unlock(&ni->ni_lock);\n}\n\nstatic inline int ni_trylock(struct ntfs_inode *ni)\n{\n\treturn mutex_trylock(&ni->ni_lock);\n}\n\nstatic inline int attr_load_runs_attr(struct ntfs_inode *ni,\n\t\t\t\t      struct ATTRIB *attr,\n\t\t\t\t      struct runs_tree *run, CLST vcn)\n{\n\treturn attr_load_runs_vcn(ni, attr->type, attr_name(attr),\n\t\t\t\t  attr->name_len, run, vcn);\n}\n\nstatic inline void le64_sub_cpu(__le64 *var, u64 val)\n{\n\t*var = cpu_to_le64(le64_to_cpu(*var) - val);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}