{
  "module_name": "inode.c",
  "hash_id": "6cf24996f059b79a37712625cba4cbe93ee6d5886bb528d3ec58af1891a9527e",
  "original_prompt": "Ingested from linux-6.6.14/fs/ntfs3/inode.c",
  "human_readable_source": "\n \n\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mpage.h>\n#include <linux/namei.h>\n#include <linux/nls.h>\n#include <linux/uio.h>\n#include <linux/writeback.h>\n\n#include \"debug.h\"\n#include \"ntfs.h\"\n#include \"ntfs_fs.h\"\n\n \nstatic struct inode *ntfs_read_mft(struct inode *inode,\n\t\t\t\t   const struct cpu_str *name,\n\t\t\t\t   const struct MFT_REF *ref)\n{\n\tint err = 0;\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ntfs_sb_info *sbi = sb->s_fs_info;\n\tmode_t mode = 0;\n\tstruct ATTR_STD_INFO5 *std5 = NULL;\n\tstruct ATTR_LIST_ENTRY *le;\n\tstruct ATTRIB *attr;\n\tbool is_match = false;\n\tbool is_root = false;\n\tbool is_dir;\n\tunsigned long ino = inode->i_ino;\n\tu32 rp_fa = 0, asize, t32;\n\tu16 roff, rsize, names = 0;\n\tconst struct ATTR_FILE_NAME *fname = NULL;\n\tconst struct INDEX_ROOT *root;\n\tstruct REPARSE_DATA_BUFFER rp; \n\tu64 t64;\n\tstruct MFT_REC *rec;\n\tstruct runs_tree *run;\n\tstruct timespec64 ctime;\n\n\tinode->i_op = NULL;\n\t \n\tinode->i_uid = sbi->options->fs_uid;\n\tinode->i_gid = sbi->options->fs_gid;\n\n\terr = mi_init(&ni->mi, sbi, ino);\n\tif (err)\n\t\tgoto out;\n\n\tif (!sbi->mft.ni && ino == MFT_REC_MFT && !sb->s_root) {\n\t\tt64 = sbi->mft.lbo >> sbi->cluster_bits;\n\t\tt32 = bytes_to_cluster(sbi, MFT_REC_VOL * sbi->record_size);\n\t\tsbi->mft.ni = ni;\n\t\tinit_rwsem(&ni->file.run_lock);\n\n\t\tif (!run_add_entry(&ni->file.run, 0, t64, t32, true)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\terr = mi_read(&ni->mi, ino == MFT_REC_MFT);\n\n\tif (err)\n\t\tgoto out;\n\n\trec = ni->mi.mrec;\n\n\tif (sbi->flags & NTFS_FLAGS_LOG_REPLAYING) {\n\t\t;\n\t} else if (ref->seq != rec->seq) {\n\t\terr = -EINVAL;\n\t\tntfs_err(sb, \"MFT: r=%lx, expect seq=%x instead of %x!\", ino,\n\t\t\t le16_to_cpu(ref->seq), le16_to_cpu(rec->seq));\n\t\tgoto out;\n\t} else if (!is_rec_inuse(rec)) {\n\t\terr = -ESTALE;\n\t\tntfs_err(sb, \"Inode r=%x is not in use!\", (u32)ino);\n\t\tgoto out;\n\t}\n\n\tif (le32_to_cpu(rec->total) != sbi->record_size) {\n\t\t \n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!is_rec_base(rec)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tis_dir = rec->flags & RECORD_FLAG_DIR;\n\n\t \n\tif (is_dir && ino == MFT_REC_MFT) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tinode->i_generation = le16_to_cpu(rec->seq);\n\n\t \n\tle = NULL;\n\tattr = NULL;\n\n\t \nnext_attr:\n\trun = NULL;\n\terr = -EINVAL;\n\tattr = ni_enum_attr_ex(ni, attr, &le, NULL);\n\tif (!attr)\n\t\tgoto end_enum;\n\n\tif (le && le->vcn) {\n\t\t \n\t\tif (ino != MFT_REC_MFT || attr->type != ATTR_DATA)\n\t\t\tgoto next_attr;\n\n\t\trun = &ni->file.run;\n\t\tasize = le32_to_cpu(attr->size);\n\t\tgoto attr_unpack_run;\n\t}\n\n\troff = attr->non_res ? 0 : le16_to_cpu(attr->res.data_off);\n\trsize = attr->non_res ? 0 : le32_to_cpu(attr->res.data_size);\n\tasize = le32_to_cpu(attr->size);\n\n\t \n\tif (attr->name_len &&\n\t    sizeof(short) * attr->name_len + le16_to_cpu(attr->name_off) >\n\t\t    asize)\n\t\tgoto out;\n\n\tif (attr->non_res) {\n\t\tt64 = le64_to_cpu(attr->nres.alloc_size);\n\t\tif (le64_to_cpu(attr->nres.data_size) > t64 ||\n\t\t    le64_to_cpu(attr->nres.valid_size) > t64)\n\t\t\tgoto out;\n\t}\n\n\tswitch (attr->type) {\n\tcase ATTR_STD:\n\t\tif (attr->non_res ||\n\t\t    asize < sizeof(struct ATTR_STD_INFO) + roff ||\n\t\t    rsize < sizeof(struct ATTR_STD_INFO))\n\t\t\tgoto out;\n\n\t\tif (std5)\n\t\t\tgoto next_attr;\n\n\t\tstd5 = Add2Ptr(attr, roff);\n\n#ifdef STATX_BTIME\n\t\tnt2kernel(std5->cr_time, &ni->i_crtime);\n#endif\n\t\tnt2kernel(std5->a_time, &inode->i_atime);\n\t\tnt2kernel(std5->c_time, &ctime);\n\t\tinode_set_ctime_to_ts(inode, ctime);\n\t\tnt2kernel(std5->m_time, &inode->i_mtime);\n\n\t\tni->std_fa = std5->fa;\n\n\t\tif (asize >= sizeof(struct ATTR_STD_INFO5) + roff &&\n\t\t    rsize >= sizeof(struct ATTR_STD_INFO5))\n\t\t\tni->std_security_id = std5->security_id;\n\t\tgoto next_attr;\n\n\tcase ATTR_LIST:\n\t\tif (attr->name_len || le || ino == MFT_REC_LOG)\n\t\t\tgoto out;\n\n\t\terr = ntfs_load_attr_list(ni, attr);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tle = NULL;\n\t\tattr = NULL;\n\t\tgoto next_attr;\n\n\tcase ATTR_NAME:\n\t\tif (attr->non_res || asize < SIZEOF_ATTRIBUTE_FILENAME + roff ||\n\t\t    rsize < SIZEOF_ATTRIBUTE_FILENAME)\n\t\t\tgoto out;\n\n\t\tfname = Add2Ptr(attr, roff);\n\t\tif (fname->type == FILE_NAME_DOS)\n\t\t\tgoto next_attr;\n\n\t\tnames += 1;\n\t\tif (name && name->len == fname->name_len &&\n\t\t    !ntfs_cmp_names_cpu(name, (struct le_str *)&fname->name_len,\n\t\t\t\t\tNULL, false))\n\t\t\tis_match = true;\n\n\t\tgoto next_attr;\n\n\tcase ATTR_DATA:\n\t\tif (is_dir) {\n\t\t\t \n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tif (ino == MFT_REC_BADCLUST && !attr->non_res)\n\t\t\tgoto next_attr;\n\n\t\tif (attr->name_len &&\n\t\t    ((ino != MFT_REC_BADCLUST || !attr->non_res ||\n\t\t      attr->name_len != ARRAY_SIZE(BAD_NAME) ||\n\t\t      memcmp(attr_name(attr), BAD_NAME, sizeof(BAD_NAME))) &&\n\t\t     (ino != MFT_REC_SECURE || !attr->non_res ||\n\t\t      attr->name_len != ARRAY_SIZE(SDS_NAME) ||\n\t\t      memcmp(attr_name(attr), SDS_NAME, sizeof(SDS_NAME))))) {\n\t\t\t \n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tif (is_attr_sparsed(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_SPARSE_FILE;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_SPARSE_FILE;\n\n\t\tif (is_attr_compressed(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_COMPRESSED;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_COMPRESSED;\n\n\t\tif (is_attr_encrypted(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_ENCRYPTED;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_ENCRYPTED;\n\n\t\tif (!attr->non_res) {\n\t\t\tni->i_valid = inode->i_size = rsize;\n\t\t\tinode_set_bytes(inode, rsize);\n\t\t}\n\n\t\tmode = S_IFREG | (0777 & sbi->options->fs_fmask_inv);\n\n\t\tif (!attr->non_res) {\n\t\t\tni->ni_flags |= NI_FLAG_RESIDENT;\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tinode_set_bytes(inode, attr_ondisk_size(attr));\n\n\t\tni->i_valid = le64_to_cpu(attr->nres.valid_size);\n\t\tinode->i_size = le64_to_cpu(attr->nres.data_size);\n\t\tif (!attr->nres.alloc_size)\n\t\t\tgoto next_attr;\n\n\t\trun = ino == MFT_REC_BITMAP ? &sbi->used.bitmap.run :\n\t\t\t\t\t      &ni->file.run;\n\t\tbreak;\n\n\tcase ATTR_ROOT:\n\t\tif (attr->non_res)\n\t\t\tgoto out;\n\n\t\troot = Add2Ptr(attr, roff);\n\n\t\tif (attr->name_len != ARRAY_SIZE(I30_NAME) ||\n\t\t    memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME)))\n\t\t\tgoto next_attr;\n\n\t\tif (root->type != ATTR_NAME ||\n\t\t    root->rule != NTFS_COLLATION_TYPE_FILENAME)\n\t\t\tgoto out;\n\n\t\tif (!is_dir)\n\t\t\tgoto next_attr;\n\n\t\tis_root = true;\n\t\tni->ni_flags |= NI_FLAG_DIR;\n\n\t\terr = indx_init(&ni->dir, sbi, attr, INDEX_MUTEX_I30);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tmode = sb->s_root ?\n\t\t\t       (S_IFDIR | (0777 & sbi->options->fs_dmask_inv)) :\n\t\t\t       (S_IFDIR | 0777);\n\t\tgoto next_attr;\n\n\tcase ATTR_ALLOC:\n\t\tif (!is_root || attr->name_len != ARRAY_SIZE(I30_NAME) ||\n\t\t    memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME)))\n\t\t\tgoto next_attr;\n\n\t\tinode->i_size = le64_to_cpu(attr->nres.data_size);\n\t\tni->i_valid = le64_to_cpu(attr->nres.valid_size);\n\t\tinode_set_bytes(inode, le64_to_cpu(attr->nres.alloc_size));\n\n\t\trun = &ni->dir.alloc_run;\n\t\tbreak;\n\n\tcase ATTR_BITMAP:\n\t\tif (ino == MFT_REC_MFT) {\n\t\t\tif (!attr->non_res)\n\t\t\t\tgoto out;\n#ifndef CONFIG_NTFS3_64BIT_CLUSTER\n\t\t\t \n\t\t\tif (le64_to_cpu(attr->nres.alloc_size) >= 0x20000000)\n\t\t\t\tgoto out;\n#endif\n\t\t\trun = &sbi->mft.bitmap.run;\n\t\t\tbreak;\n\t\t} else if (is_dir && attr->name_len == ARRAY_SIZE(I30_NAME) &&\n\t\t\t   !memcmp(attr_name(attr), I30_NAME,\n\t\t\t\t   sizeof(I30_NAME)) &&\n\t\t\t   attr->non_res) {\n\t\t\trun = &ni->dir.bitmap_run;\n\t\t\tbreak;\n\t\t}\n\t\tgoto next_attr;\n\n\tcase ATTR_REPARSE:\n\t\tif (attr->name_len)\n\t\t\tgoto next_attr;\n\n\t\trp_fa = ni_parse_reparse(ni, attr, &rp);\n\t\tswitch (rp_fa) {\n\t\tcase REPARSE_LINK:\n\t\t\t \n\t\t\tinode->i_size = le16_to_cpu(rp.SymbolicLinkReparseBuffer\n\t\t\t\t\t\t\t    .PrintNameLength) /\n\t\t\t\t\tsizeof(u16);\n\n\t\t\tni->i_valid = inode->i_size;\n\n\t\t\t \n\t\t\tif (ni->ni_flags & NI_FLAG_DIR) {\n\t\t\t\tindx_clear(&ni->dir);\n\t\t\t\tmemset(&ni->dir, 0, sizeof(ni->dir));\n\t\t\t\tni->ni_flags &= ~NI_FLAG_DIR;\n\t\t\t} else {\n\t\t\t\trun_close(&ni->file.run);\n\t\t\t}\n\t\t\tmode = S_IFLNK | 0777;\n\t\t\tis_dir = false;\n\t\t\tif (attr->non_res) {\n\t\t\t\trun = &ni->file.run;\n\t\t\t\tgoto attr_unpack_run; \n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase REPARSE_COMPRESSED:\n\t\t\tbreak;\n\n\t\tcase REPARSE_DEDUPLICATED:\n\t\t\tbreak;\n\t\t}\n\t\tgoto next_attr;\n\n\tcase ATTR_EA_INFO:\n\t\tif (!attr->name_len &&\n\t\t    resident_data_ex(attr, sizeof(struct EA_INFO))) {\n\t\t\tni->ni_flags |= NI_FLAG_EA;\n\t\t\t \n\t\t\tinode->i_mode = mode;\n\t\t\tntfs_get_wsl_perm(inode);\n\t\t\tmode = inode->i_mode;\n\t\t}\n\t\tgoto next_attr;\n\n\tdefault:\n\t\tgoto next_attr;\n\t}\n\nattr_unpack_run:\n\troff = le16_to_cpu(attr->nres.run_off);\n\n\tif (roff > asize) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tt64 = le64_to_cpu(attr->nres.svcn);\n\n\terr = run_unpack_ex(run, sbi, ino, t64, le64_to_cpu(attr->nres.evcn),\n\t\t\t    t64, Add2Ptr(attr, roff), asize - roff);\n\tif (err < 0)\n\t\tgoto out;\n\terr = 0;\n\tgoto next_attr;\n\nend_enum:\n\n\tif (!std5)\n\t\tgoto out;\n\n\tif (!is_match && name) {\n\t\t \n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (std5->fa & FILE_ATTRIBUTE_READONLY)\n\t\tmode &= ~0222;\n\n\tif (!names) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (names != le16_to_cpu(rec->hard_links)) {\n\t\t \n\t\trec->hard_links = cpu_to_le16(names);\n\t\tni->mi.dirty = true;\n\t}\n\n\tset_nlink(inode, names);\n\n\tif (S_ISDIR(mode)) {\n\t\tni->std_fa |= FILE_ATTRIBUTE_DIRECTORY;\n\n\t\t \n\t\tinode->i_op = &ntfs_dir_inode_operations;\n\t\tinode->i_fop = &ntfs_dir_operations;\n\t\tni->i_valid = 0;\n\t} else if (S_ISLNK(mode)) {\n\t\tni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY;\n\t\tinode->i_op = &ntfs_link_inode_operations;\n\t\tinode->i_fop = NULL;\n\t\tinode_nohighmem(inode);\n\t} else if (S_ISREG(mode)) {\n\t\tni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY;\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t\tinode->i_fop = &ntfs_file_operations;\n\t\tinode->i_mapping->a_ops = is_compressed(ni) ? &ntfs_aops_cmpr :\n\t\t\t\t\t\t\t      &ntfs_aops;\n\t\tif (ino != MFT_REC_MFT)\n\t\t\tinit_rwsem(&ni->file.run_lock);\n\t} else if (S_ISCHR(mode) || S_ISBLK(mode) || S_ISFIFO(mode) ||\n\t\t   S_ISSOCK(mode)) {\n\t\tinode->i_op = &ntfs_special_inode_operations;\n\t\tinit_special_inode(inode, mode, inode->i_rdev);\n\t} else if (fname && fname->home.low == cpu_to_le32(MFT_REC_EXTEND) &&\n\t\t   fname->home.seq == cpu_to_le16(MFT_REC_EXTEND)) {\n\t\t \n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t} else {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif ((sbi->options->sys_immutable &&\n\t     (std5->fa & FILE_ATTRIBUTE_SYSTEM)) &&\n\t    !S_ISFIFO(mode) && !S_ISSOCK(mode) && !S_ISLNK(mode)) {\n\t\tinode->i_flags |= S_IMMUTABLE;\n\t} else {\n\t\tinode->i_flags &= ~S_IMMUTABLE;\n\t}\n\n\tinode->i_mode = mode;\n\tif (!(ni->ni_flags & NI_FLAG_EA)) {\n\t\t \n\t\tinode->i_flags |= S_NOSEC;\n\t}\n\n\tif (ino == MFT_REC_MFT && !sb->s_root)\n\t\tsbi->mft.ni = NULL;\n\n\tunlock_new_inode(inode);\n\n\treturn inode;\n\nout:\n\tif (ino == MFT_REC_MFT && !sb->s_root)\n\t\tsbi->mft.ni = NULL;\n\n\tiget_failed(inode);\n\treturn ERR_PTR(err);\n}\n\n \nstatic int ntfs_test_inode(struct inode *inode, void *data)\n{\n\tstruct MFT_REF *ref = data;\n\n\treturn ino_get(ref) == inode->i_ino;\n}\n\nstatic int ntfs_set_inode(struct inode *inode, void *data)\n{\n\tconst struct MFT_REF *ref = data;\n\n\tinode->i_ino = ino_get(ref);\n\treturn 0;\n}\n\nstruct inode *ntfs_iget5(struct super_block *sb, const struct MFT_REF *ref,\n\t\t\t const struct cpu_str *name)\n{\n\tstruct inode *inode;\n\n\tinode = iget5_locked(sb, ino_get(ref), ntfs_test_inode, ntfs_set_inode,\n\t\t\t     (void *)ref);\n\tif (unlikely(!inode))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tif (inode->i_state & I_NEW)\n\t\tinode = ntfs_read_mft(inode, name, ref);\n\telse if (ref->seq != ntfs_i(inode)->mi.mrec->seq) {\n\t\t \n\t\t_ntfs_bad_inode(inode);\n\t}\n\n\tif (IS_ERR(inode) && name)\n\t\tntfs_set_state(sb->s_fs_info, NTFS_DIRTY_ERROR);\n\n\treturn inode;\n}\n\nenum get_block_ctx {\n\tGET_BLOCK_GENERAL = 0,\n\tGET_BLOCK_WRITE_BEGIN = 1,\n\tGET_BLOCK_DIRECT_IO_R = 2,\n\tGET_BLOCK_DIRECT_IO_W = 3,\n\tGET_BLOCK_BMAP = 4,\n};\n\nstatic noinline int ntfs_get_block_vbo(struct inode *inode, u64 vbo,\n\t\t\t\t       struct buffer_head *bh, int create,\n\t\t\t\t       enum get_block_ctx ctx)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ntfs_sb_info *sbi = sb->s_fs_info;\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tstruct folio *folio = bh->b_folio;\n\tu8 cluster_bits = sbi->cluster_bits;\n\tu32 block_size = sb->s_blocksize;\n\tu64 bytes, lbo, valid;\n\tu32 off;\n\tint err;\n\tCLST vcn, lcn, len;\n\tbool new;\n\n\t \n\tclear_buffer_new(bh);\n\tclear_buffer_uptodate(bh);\n\n\tif (is_resident(ni)) {\n\t\tni_lock(ni);\n\t\terr = attr_data_read_resident(ni, &folio->page);\n\t\tni_unlock(ni);\n\n\t\tif (!err)\n\t\t\tset_buffer_uptodate(bh);\n\t\tbh->b_size = block_size;\n\t\treturn err;\n\t}\n\n\tvcn = vbo >> cluster_bits;\n\toff = vbo & sbi->cluster_mask;\n\tnew = false;\n\n\terr = attr_data_get_block(ni, vcn, 1, &lcn, &len, create ? &new : NULL,\n\t\t\t\t  create && sbi->cluster_size > PAGE_SIZE);\n\tif (err)\n\t\tgoto out;\n\n\tif (!len)\n\t\treturn 0;\n\n\tbytes = ((u64)len << cluster_bits) - off;\n\n\tif (lcn == SPARSE_LCN) {\n\t\tif (!create) {\n\t\t\tif (bh->b_size > bytes)\n\t\t\t\tbh->b_size = bytes;\n\t\t\treturn 0;\n\t\t}\n\t\tWARN_ON(1);\n\t}\n\n\tif (new)\n\t\tset_buffer_new(bh);\n\n\tlbo = ((u64)lcn << cluster_bits) + off;\n\n\tset_buffer_mapped(bh);\n\tbh->b_bdev = sb->s_bdev;\n\tbh->b_blocknr = lbo >> sb->s_blocksize_bits;\n\n\tvalid = ni->i_valid;\n\n\tif (ctx == GET_BLOCK_DIRECT_IO_W) {\n\t\t \n\t\tif (vbo >= valid)\n\t\t\tset_buffer_new(bh);\n\t} else if (create) {\n\t\t \n\t\tif (bytes > bh->b_size)\n\t\t\tbytes = bh->b_size;\n\n\t\tif (vbo >= valid)\n\t\t\tset_buffer_new(bh);\n\n\t\tif (vbo + bytes > valid) {\n\t\t\tni->i_valid = vbo + bytes;\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t} else if (vbo >= valid) {\n\t\t \n\t\tclear_buffer_mapped(bh);\n\t} else if (vbo + bytes <= valid) {\n\t\t \n\t} else if (vbo + block_size <= valid) {\n\t\t \n\t\tbytes = block_size;\n\t} else {\n\t\t \n\t\tbytes = block_size;\n\n\t\tif (folio) {\n\t\t\tu32 voff = valid - vbo;\n\n\t\t\tbh->b_size = block_size;\n\t\t\toff = vbo & (PAGE_SIZE - 1);\n\t\t\tfolio_set_bh(bh, folio, off);\n\n\t\t\terr = bh_read(bh, 0);\n\t\t\tif (err < 0)\n\t\t\t\tgoto out;\n\t\t\tfolio_zero_segment(folio, off + voff, off + block_size);\n\t\t}\n\t}\n\n\tif (bh->b_size > bytes)\n\t\tbh->b_size = bytes;\n\n#ifndef __LP64__\n\tif (ctx == GET_BLOCK_DIRECT_IO_W || ctx == GET_BLOCK_DIRECT_IO_R) {\n\t\tstatic_assert(sizeof(size_t) < sizeof(loff_t));\n\t\tif (bytes > 0x40000000u)\n\t\t\tbh->b_size = 0x40000000u;\n\t}\n#endif\n\n\treturn 0;\n\nout:\n\treturn err;\n}\n\nint ntfs_get_block(struct inode *inode, sector_t vbn,\n\t\t   struct buffer_head *bh_result, int create)\n{\n\treturn ntfs_get_block_vbo(inode, (u64)vbn << inode->i_blkbits,\n\t\t\t\t  bh_result, create, GET_BLOCK_GENERAL);\n}\n\nstatic int ntfs_get_block_bmap(struct inode *inode, sector_t vsn,\n\t\t\t       struct buffer_head *bh_result, int create)\n{\n\treturn ntfs_get_block_vbo(inode,\n\t\t\t\t  (u64)vsn << inode->i_sb->s_blocksize_bits,\n\t\t\t\t  bh_result, create, GET_BLOCK_BMAP);\n}\n\nstatic sector_t ntfs_bmap(struct address_space *mapping, sector_t block)\n{\n\treturn generic_block_bmap(mapping, block, ntfs_get_block_bmap);\n}\n\nstatic int ntfs_read_folio(struct file *file, struct folio *folio)\n{\n\tstruct page *page = &folio->page;\n\tint err;\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *inode = mapping->host;\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\n\tif (is_resident(ni)) {\n\t\tni_lock(ni);\n\t\terr = attr_data_read_resident(ni, page);\n\t\tni_unlock(ni);\n\t\tif (err != E_NTFS_NONRESIDENT) {\n\t\t\tunlock_page(page);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (is_compressed(ni)) {\n\t\tni_lock(ni);\n\t\terr = ni_readpage_cmpr(ni, page);\n\t\tni_unlock(ni);\n\t\treturn err;\n\t}\n\n\t \n\treturn mpage_read_folio(folio, ntfs_get_block);\n}\n\nstatic void ntfs_readahead(struct readahead_control *rac)\n{\n\tstruct address_space *mapping = rac->mapping;\n\tstruct inode *inode = mapping->host;\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tu64 valid;\n\tloff_t pos;\n\n\tif (is_resident(ni)) {\n\t\t \n\t\treturn;\n\t}\n\n\tif (is_compressed(ni)) {\n\t\t \n\t\treturn;\n\t}\n\n\tvalid = ni->i_valid;\n\tpos = readahead_pos(rac);\n\n\tif (valid < i_size_read(inode) && pos <= valid &&\n\t    valid < pos + readahead_length(rac)) {\n\t\t \n\t\treturn;\n\t}\n\n\tmpage_readahead(rac, ntfs_get_block);\n}\n\nstatic int ntfs_get_block_direct_IO_R(struct inode *inode, sector_t iblock,\n\t\t\t\t      struct buffer_head *bh_result, int create)\n{\n\treturn ntfs_get_block_vbo(inode, (u64)iblock << inode->i_blkbits,\n\t\t\t\t  bh_result, create, GET_BLOCK_DIRECT_IO_R);\n}\n\nstatic int ntfs_get_block_direct_IO_W(struct inode *inode, sector_t iblock,\n\t\t\t\t      struct buffer_head *bh_result, int create)\n{\n\treturn ntfs_get_block_vbo(inode, (u64)iblock << inode->i_blkbits,\n\t\t\t\t  bh_result, create, GET_BLOCK_DIRECT_IO_W);\n}\n\nstatic ssize_t ntfs_direct_IO(struct kiocb *iocb, struct iov_iter *iter)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tloff_t vbo = iocb->ki_pos;\n\tloff_t end;\n\tint wr = iov_iter_rw(iter) & WRITE;\n\tsize_t iter_count = iov_iter_count(iter);\n\tloff_t valid;\n\tssize_t ret;\n\n\tif (is_resident(ni)) {\n\t\t \n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tret = blockdev_direct_IO(iocb, inode, iter,\n\t\t\t\t wr ? ntfs_get_block_direct_IO_W :\n\t\t\t\t      ntfs_get_block_direct_IO_R);\n\n\tif (ret > 0)\n\t\tend = vbo + ret;\n\telse if (wr && ret == -EIOCBQUEUED)\n\t\tend = vbo + iter_count;\n\telse\n\t\tgoto out;\n\n\tvalid = ni->i_valid;\n\tif (wr) {\n\t\tif (end > valid && !S_ISBLK(inode->i_mode)) {\n\t\t\tni->i_valid = end;\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t} else if (vbo < valid && valid < end) {\n\t\t \n\t\tiov_iter_revert(iter, end - valid);\n\t\tiov_iter_zero(end - valid, iter);\n\t}\n\nout:\n\treturn ret;\n}\n\nint ntfs_set_size(struct inode *inode, u64 new_size)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ntfs_sb_info *sbi = sb->s_fs_info;\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tint err;\n\n\t \n\tif (is_sparsed(ni) || is_compressed(ni)) {\n\t\tif (new_size > sbi->maxbytes_sparse) {\n\t\t\terr = -EFBIG;\n\t\t\tgoto out;\n\t\t}\n\t} else if (new_size > sbi->maxbytes) {\n\t\terr = -EFBIG;\n\t\tgoto out;\n\t}\n\n\tni_lock(ni);\n\tdown_write(&ni->file.run_lock);\n\n\terr = attr_set_size(ni, ATTR_DATA, NULL, 0, &ni->file.run, new_size,\n\t\t\t    &ni->i_valid, true, NULL);\n\n\tup_write(&ni->file.run_lock);\n\tni_unlock(ni);\n\n\tmark_inode_dirty(inode);\n\nout:\n\treturn err;\n}\n\nstatic int ntfs_resident_writepage(struct folio *folio,\n\t\t\t\t   struct writeback_control *wbc, void *data)\n{\n\tstruct address_space *mapping = data;\n\tstruct ntfs_inode *ni = ntfs_i(mapping->host);\n\tint ret;\n\n\tni_lock(ni);\n\tret = attr_data_write_resident(ni, &folio->page);\n\tni_unlock(ni);\n\n\tif (ret != E_NTFS_NONRESIDENT)\n\t\tfolio_unlock(folio);\n\tmapping_set_error(mapping, ret);\n\treturn ret;\n}\n\nstatic int ntfs_writepages(struct address_space *mapping,\n\t\t\t   struct writeback_control *wbc)\n{\n\tif (is_resident(ntfs_i(mapping->host)))\n\t\treturn write_cache_pages(mapping, wbc, ntfs_resident_writepage,\n\t\t\t\t\t mapping);\n\treturn mpage_writepages(mapping, wbc, ntfs_get_block);\n}\n\nstatic int ntfs_get_block_write_begin(struct inode *inode, sector_t vbn,\n\t\t\t\t      struct buffer_head *bh_result, int create)\n{\n\treturn ntfs_get_block_vbo(inode, (u64)vbn << inode->i_blkbits,\n\t\t\t\t  bh_result, create, GET_BLOCK_WRITE_BEGIN);\n}\n\nint ntfs_write_begin(struct file *file, struct address_space *mapping,\n\t\t     loff_t pos, u32 len, struct page **pagep, void **fsdata)\n{\n\tint err;\n\tstruct inode *inode = mapping->host;\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\n\t*pagep = NULL;\n\tif (is_resident(ni)) {\n\t\tstruct page *page =\n\t\t\tgrab_cache_page_write_begin(mapping, pos >> PAGE_SHIFT);\n\n\t\tif (!page) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tni_lock(ni);\n\t\terr = attr_data_read_resident(ni, page);\n\t\tni_unlock(ni);\n\n\t\tif (!err) {\n\t\t\t*pagep = page;\n\t\t\tgoto out;\n\t\t}\n\t\tunlock_page(page);\n\t\tput_page(page);\n\n\t\tif (err != E_NTFS_NONRESIDENT)\n\t\t\tgoto out;\n\t}\n\n\terr = block_write_begin(mapping, pos, len, pagep,\n\t\t\t\tntfs_get_block_write_begin);\n\nout:\n\treturn err;\n}\n\n \nint ntfs_write_end(struct file *file, struct address_space *mapping, loff_t pos,\n\t\t   u32 len, u32 copied, struct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tu64 valid = ni->i_valid;\n\tbool dirty = false;\n\tint err;\n\n\tif (is_resident(ni)) {\n\t\tni_lock(ni);\n\t\terr = attr_data_write_resident(ni, page);\n\t\tni_unlock(ni);\n\t\tif (!err) {\n\t\t\tdirty = true;\n\t\t\t \n\t\t\tif (page_has_buffers(page)) {\n\t\t\t\tstruct buffer_head *head, *bh;\n\n\t\t\t\tbh = head = page_buffers(page);\n\t\t\t\tdo {\n\t\t\t\t\tclear_buffer_dirty(bh);\n\t\t\t\t\tclear_buffer_mapped(bh);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t} while (head != (bh = bh->b_this_page));\n\t\t\t}\n\t\t\tSetPageUptodate(page);\n\t\t\terr = copied;\n\t\t}\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t} else {\n\t\terr = generic_write_end(file, mapping, pos, len, copied, page,\n\t\t\t\t\tfsdata);\n\t}\n\n\tif (err >= 0) {\n\t\tif (!(ni->std_fa & FILE_ATTRIBUTE_ARCHIVE)) {\n\t\t\tinode->i_mtime = inode_set_ctime_current(inode);\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_ARCHIVE;\n\t\t\tdirty = true;\n\t\t}\n\n\t\tif (valid != ni->i_valid) {\n\t\t\t \n\t\t\tdirty = true;\n\t\t}\n\n\t\tif (pos + err > inode->i_size) {\n\t\t\tinode->i_size = pos + err;\n\t\t\tdirty = true;\n\t\t}\n\n\t\tif (dirty)\n\t\t\tmark_inode_dirty(inode);\n\t}\n\n\treturn err;\n}\n\nint reset_log_file(struct inode *inode)\n{\n\tint err;\n\tloff_t pos = 0;\n\tu32 log_size = inode->i_size;\n\tstruct address_space *mapping = inode->i_mapping;\n\n\tfor (;;) {\n\t\tu32 len;\n\t\tvoid *kaddr;\n\t\tstruct page *page;\n\n\t\tlen = pos + PAGE_SIZE > log_size ? (log_size - pos) : PAGE_SIZE;\n\n\t\terr = block_write_begin(mapping, pos, len, &page,\n\t\t\t\t\tntfs_get_block_write_begin);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tkaddr = kmap_atomic(page);\n\t\tmemset(kaddr, -1, len);\n\t\tkunmap_atomic(kaddr);\n\t\tflush_dcache_page(page);\n\n\t\terr = block_write_end(NULL, mapping, pos, len, len, page, NULL);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\tpos += len;\n\n\t\tif (pos >= log_size)\n\t\t\tbreak;\n\t\tbalance_dirty_pages_ratelimited(mapping);\n\t}\nout:\n\tmark_inode_dirty_sync(inode);\n\n\treturn err;\n}\n\nint ntfs3_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\treturn _ni_write_inode(inode, wbc->sync_mode == WB_SYNC_ALL);\n}\n\nint ntfs_sync_inode(struct inode *inode)\n{\n\treturn _ni_write_inode(inode, 1);\n}\n\n \nstatic int writeback_inode(struct inode *inode)\n{\n\tint ret = sync_inode_metadata(inode, 0);\n\n\tif (!ret)\n\t\tret = filemap_fdatawrite(inode->i_mapping);\n\treturn ret;\n}\n\n \nint ntfs_flush_inodes(struct super_block *sb, struct inode *i1,\n\t\t      struct inode *i2)\n{\n\tint ret = 0;\n\n\tif (i1)\n\t\tret = writeback_inode(i1);\n\tif (!ret && i2)\n\t\tret = writeback_inode(i2);\n\tif (!ret)\n\t\tret = sync_blockdev_nowait(sb->s_bdev);\n\treturn ret;\n}\n\nint inode_write_data(struct inode *inode, const void *data, size_t bytes)\n{\n\tpgoff_t idx;\n\n\t \n\tfor (idx = 0; bytes; idx++) {\n\t\tsize_t op = bytes > PAGE_SIZE ? PAGE_SIZE : bytes;\n\t\tstruct page *page = ntfs_map_page(inode->i_mapping, idx);\n\n\t\tif (IS_ERR(page))\n\t\t\treturn PTR_ERR(page);\n\n\t\tlock_page(page);\n\t\tWARN_ON(!PageUptodate(page));\n\t\tClearPageUptodate(page);\n\n\t\tmemcpy(page_address(page), data, op);\n\n\t\tflush_dcache_page(page);\n\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\n\t\tntfs_unmap_page(page);\n\n\t\tbytes -= op;\n\t\tdata = Add2Ptr(data, PAGE_SIZE);\n\t}\n\treturn 0;\n}\n\n \nstatic inline u32 ntfs_reparse_bytes(u32 uni_len)\n{\n\t \n\treturn sizeof(short) * (2 * uni_len + 4) +\n\t       offsetof(struct REPARSE_DATA_BUFFER,\n\t\t\tSymbolicLinkReparseBuffer.PathBuffer);\n}\n\nstatic struct REPARSE_DATA_BUFFER *\nntfs_create_reparse_buffer(struct ntfs_sb_info *sbi, const char *symname,\n\t\t\t   u32 size, u16 *nsize)\n{\n\tint i, err;\n\tstruct REPARSE_DATA_BUFFER *rp;\n\t__le16 *rp_name;\n\ttypeof(rp->SymbolicLinkReparseBuffer) *rs;\n\n\trp = kzalloc(ntfs_reparse_bytes(2 * size + 2), GFP_NOFS);\n\tif (!rp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trs = &rp->SymbolicLinkReparseBuffer;\n\trp_name = rs->PathBuffer;\n\n\t \n\terr = ntfs_nls_to_utf16(sbi, symname, size,\n\t\t\t\t(struct cpu_str *)(rp_name - 1), 2 * size,\n\t\t\t\tUTF16_LITTLE_ENDIAN);\n\tif (err < 0)\n\t\tgoto out;\n\n\t \n\t*nsize = ntfs_reparse_bytes(err);\n\n\tif (*nsize > sbi->reparse.max_size) {\n\t\terr = -EFBIG;\n\t\tgoto out;\n\t}\n\n\t \n\tfor (i = 0; i < err; i++) {\n\t\tif (rp_name[i] == cpu_to_le16('/'))\n\t\t\trp_name[i] = cpu_to_le16('\\\\');\n\t}\n\n\trp->ReparseTag = IO_REPARSE_TAG_SYMLINK;\n\trp->ReparseDataLength =\n\t\tcpu_to_le16(*nsize - offsetof(struct REPARSE_DATA_BUFFER,\n\t\t\t\t\t      SymbolicLinkReparseBuffer));\n\n\t \n\trs->SubstituteNameOffset = cpu_to_le16(sizeof(short) * err);\n\trs->SubstituteNameLength = cpu_to_le16(sizeof(short) * err + 8);\n\trs->PrintNameLength = rs->SubstituteNameOffset;\n\n\t \n\trs->Flags = 0;\n\n\tmemmove(rp_name + err + 4, rp_name, sizeof(short) * err);\n\n\t \n\trp_name += err;\n\trp_name[0] = cpu_to_le16('\\\\');\n\trp_name[1] = cpu_to_le16('?');\n\trp_name[2] = cpu_to_le16('?');\n\trp_name[3] = cpu_to_le16('\\\\');\n\n\treturn rp;\nout:\n\tkfree(rp);\n\treturn ERR_PTR(err);\n}\n\n \nstruct inode *ntfs_create_inode(struct mnt_idmap *idmap, struct inode *dir,\n\t\t\t\tstruct dentry *dentry,\n\t\t\t\tconst struct cpu_str *uni, umode_t mode,\n\t\t\t\tdev_t dev, const char *symname, u32 size,\n\t\t\t\tstruct ntfs_fnd *fnd)\n{\n\tint err;\n\tstruct super_block *sb = dir->i_sb;\n\tstruct ntfs_sb_info *sbi = sb->s_fs_info;\n\tconst struct qstr *name = &dentry->d_name;\n\tCLST ino = 0;\n\tstruct ntfs_inode *dir_ni = ntfs_i(dir);\n\tstruct ntfs_inode *ni = NULL;\n\tstruct inode *inode = NULL;\n\tstruct ATTRIB *attr;\n\tstruct ATTR_STD_INFO5 *std5;\n\tstruct ATTR_FILE_NAME *fname;\n\tstruct MFT_REC *rec;\n\tu32 asize, dsize, sd_size;\n\tenum FILE_ATTRIBUTE fa;\n\t__le32 security_id = SECURITY_ID_INVALID;\n\tCLST vcn;\n\tconst void *sd;\n\tu16 t16, nsize = 0, aid = 0;\n\tstruct INDEX_ROOT *root, *dir_root;\n\tstruct NTFS_DE *e, *new_de = NULL;\n\tstruct REPARSE_DATA_BUFFER *rp = NULL;\n\tbool rp_inserted = false;\n\n\tif (!fnd)\n\t\tni_lock_dir(dir_ni);\n\n\tdir_root = indx_get_root(&dir_ni->dir, dir_ni, NULL, NULL);\n\tif (!dir_root) {\n\t\terr = -EINVAL;\n\t\tgoto out1;\n\t}\n\n\tif (S_ISDIR(mode)) {\n\t\t \n\t\tfa = dir_ni->std_fa | FILE_ATTRIBUTE_DIRECTORY |\n\t\t     FILE_ATTRIBUTE_ARCHIVE;\n\t\t \n\t\tif (dir->i_ino == MFT_REC_ROOT)\n\t\t\tfa &= ~(FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM);\n\t} else if (S_ISLNK(mode)) {\n\t\t \n\t\tfa = FILE_ATTRIBUTE_REPARSE_POINT;\n\n\t\t \n\n\t\t \n\t} else if (S_ISREG(mode)) {\n\t\tif (sbi->options->sparse) {\n\t\t\t \n\t\t\tfa = FILE_ATTRIBUTE_SPARSE_FILE |\n\t\t\t     FILE_ATTRIBUTE_ARCHIVE;\n\t\t} else if (dir_ni->std_fa & FILE_ATTRIBUTE_COMPRESSED) {\n\t\t\t \n\t\t\tfa = FILE_ATTRIBUTE_COMPRESSED | FILE_ATTRIBUTE_ARCHIVE;\n\t\t} else {\n\t\t\t \n\t\t\tfa = FILE_ATTRIBUTE_ARCHIVE;\n\t\t}\n\t} else {\n\t\tfa = FILE_ATTRIBUTE_ARCHIVE;\n\t}\n\n\t \n\tif (sbi->options->hide_dot_files && name->name[0] == '.')\n\t\tfa |= FILE_ATTRIBUTE_HIDDEN;\n\n\tif (!(mode & 0222))\n\t\tfa |= FILE_ATTRIBUTE_READONLY;\n\n\t \n\tnew_de = __getname();\n\tif (!new_de) {\n\t\terr = -ENOMEM;\n\t\tgoto out1;\n\t}\n\n\t \n\tntfs_set_state(sbi, NTFS_DIRTY_DIRTY);\n\n\t \n\terr = ntfs_look_free_mft(sbi, &ino, false, NULL, NULL);\n\tif (err)\n\t\tgoto out2;\n\n\tni = ntfs_new_inode(sbi, ino, S_ISDIR(mode) ? RECORD_FLAG_DIR : 0);\n\tif (IS_ERR(ni)) {\n\t\terr = PTR_ERR(ni);\n\t\tni = NULL;\n\t\tgoto out3;\n\t}\n\tinode = &ni->vfs_inode;\n\tinode_init_owner(idmap, inode, dir, mode);\n\tmode = inode->i_mode;\n\n\tni->i_crtime = current_time(inode);\n\n\trec = ni->mi.mrec;\n\trec->hard_links = cpu_to_le16(1);\n\tattr = Add2Ptr(rec, le16_to_cpu(rec->attr_off));\n\n\t \n\tsd = s_default_security;\n\tsd_size = sizeof(s_default_security);\n\n\tif (is_ntfs3(sbi)) {\n\t\tsecurity_id = dir_ni->std_security_id;\n\t\tif (le32_to_cpu(security_id) < SECURITY_ID_FIRST) {\n\t\t\tsecurity_id = sbi->security.def_security_id;\n\n\t\t\tif (security_id == SECURITY_ID_INVALID &&\n\t\t\t    !ntfs_insert_security(sbi, sd, sd_size,\n\t\t\t\t\t\t  &security_id, NULL))\n\t\t\t\tsbi->security.def_security_id = security_id;\n\t\t}\n\t}\n\n\t \n\tstd5 = Add2Ptr(attr, SIZEOF_RESIDENT);\n\n\tif (security_id == SECURITY_ID_INVALID) {\n\t\tdsize = sizeof(struct ATTR_STD_INFO);\n\t} else {\n\t\tdsize = sizeof(struct ATTR_STD_INFO5);\n\t\tstd5->security_id = security_id;\n\t\tni->std_security_id = security_id;\n\t}\n\tasize = SIZEOF_RESIDENT + dsize;\n\n\tattr->type = ATTR_STD;\n\tattr->size = cpu_to_le32(asize);\n\tattr->id = cpu_to_le16(aid++);\n\tattr->res.data_off = SIZEOF_RESIDENT_LE;\n\tattr->res.data_size = cpu_to_le32(dsize);\n\n\tstd5->cr_time = std5->m_time = std5->c_time = std5->a_time =\n\t\tkernel2nt(&ni->i_crtime);\n\n\tstd5->fa = ni->std_fa = fa;\n\n\tattr = Add2Ptr(attr, asize);\n\n\t \n\terr = fill_name_de(sbi, new_de, name, uni);\n\tif (err)\n\t\tgoto out4;\n\n\tmi_get_ref(&ni->mi, &new_de->ref);\n\n\tfname = (struct ATTR_FILE_NAME *)(new_de + 1);\n\n\tif (sbi->options->windows_names &&\n\t    !valid_windows_name(sbi, (struct le_str *)&fname->name_len)) {\n\t\terr = -EINVAL;\n\t\tgoto out4;\n\t}\n\n\tmi_get_ref(&dir_ni->mi, &fname->home);\n\tfname->dup.cr_time = fname->dup.m_time = fname->dup.c_time =\n\t\tfname->dup.a_time = std5->cr_time;\n\tfname->dup.alloc_size = fname->dup.data_size = 0;\n\tfname->dup.fa = std5->fa;\n\tfname->dup.ea_size = fname->dup.reparse = 0;\n\n\tdsize = le16_to_cpu(new_de->key_size);\n\tasize = ALIGN(SIZEOF_RESIDENT + dsize, 8);\n\n\tattr->type = ATTR_NAME;\n\tattr->size = cpu_to_le32(asize);\n\tattr->res.data_off = SIZEOF_RESIDENT_LE;\n\tattr->res.flags = RESIDENT_FLAG_INDEXED;\n\tattr->id = cpu_to_le16(aid++);\n\tattr->res.data_size = cpu_to_le32(dsize);\n\tmemcpy(Add2Ptr(attr, SIZEOF_RESIDENT), fname, dsize);\n\n\tattr = Add2Ptr(attr, asize);\n\n\tif (security_id == SECURITY_ID_INVALID) {\n\t\t \n\t\tasize = SIZEOF_RESIDENT + ALIGN(sd_size, 8);\n\n\t\tattr->type = ATTR_SECURE;\n\t\tattr->size = cpu_to_le32(asize);\n\t\tattr->id = cpu_to_le16(aid++);\n\t\tattr->res.data_off = SIZEOF_RESIDENT_LE;\n\t\tattr->res.data_size = cpu_to_le32(sd_size);\n\t\tmemcpy(Add2Ptr(attr, SIZEOF_RESIDENT), sd, sd_size);\n\n\t\tattr = Add2Ptr(attr, asize);\n\t}\n\n\tattr->id = cpu_to_le16(aid++);\n\tif (fa & FILE_ATTRIBUTE_DIRECTORY) {\n\t\t \n\t\tdsize = sizeof(struct INDEX_ROOT) + sizeof(struct NTFS_DE);\n\t\tasize = sizeof(I30_NAME) + SIZEOF_RESIDENT + dsize;\n\n\t\tattr->type = ATTR_ROOT;\n\t\tattr->size = cpu_to_le32(asize);\n\n\t\tattr->name_len = ARRAY_SIZE(I30_NAME);\n\t\tattr->name_off = SIZEOF_RESIDENT_LE;\n\t\tattr->res.data_off =\n\t\t\tcpu_to_le16(sizeof(I30_NAME) + SIZEOF_RESIDENT);\n\t\tattr->res.data_size = cpu_to_le32(dsize);\n\t\tmemcpy(Add2Ptr(attr, SIZEOF_RESIDENT), I30_NAME,\n\t\t       sizeof(I30_NAME));\n\n\t\troot = Add2Ptr(attr, sizeof(I30_NAME) + SIZEOF_RESIDENT);\n\t\tmemcpy(root, dir_root, offsetof(struct INDEX_ROOT, ihdr));\n\t\troot->ihdr.de_off = cpu_to_le32(sizeof(struct INDEX_HDR));\n\t\troot->ihdr.used = cpu_to_le32(sizeof(struct INDEX_HDR) +\n\t\t\t\t\t      sizeof(struct NTFS_DE));\n\t\troot->ihdr.total = root->ihdr.used;\n\n\t\te = Add2Ptr(root, sizeof(struct INDEX_ROOT));\n\t\te->size = cpu_to_le16(sizeof(struct NTFS_DE));\n\t\te->flags = NTFS_IE_LAST;\n\t} else if (S_ISLNK(mode)) {\n\t\t \n\t\tasize = SIZEOF_RESIDENT;\n\n\t\t \n\t\tattr->type = ATTR_DATA;\n\t\tattr->size = cpu_to_le32(SIZEOF_RESIDENT);\n\t\tattr->name_off = SIZEOF_RESIDENT_LE;\n\t\tattr->res.data_off = SIZEOF_RESIDENT_LE;\n\t} else if (S_ISREG(mode)) {\n\t\t \n\t\tattr->type = ATTR_DATA;\n\t\tattr->non_res = 1;\n\t\tattr->nres.evcn = cpu_to_le64(-1ll);\n\t\tif (fa & FILE_ATTRIBUTE_SPARSE_FILE) {\n\t\t\tattr->size = cpu_to_le32(SIZEOF_NONRESIDENT_EX + 8);\n\t\t\tattr->name_off = SIZEOF_NONRESIDENT_EX_LE;\n\t\t\tattr->flags = ATTR_FLAG_SPARSED;\n\t\t\tasize = SIZEOF_NONRESIDENT_EX + 8;\n\t\t} else if (fa & FILE_ATTRIBUTE_COMPRESSED) {\n\t\t\tattr->size = cpu_to_le32(SIZEOF_NONRESIDENT_EX + 8);\n\t\t\tattr->name_off = SIZEOF_NONRESIDENT_EX_LE;\n\t\t\tattr->flags = ATTR_FLAG_COMPRESSED;\n\t\t\tattr->nres.c_unit = COMPRESSION_UNIT;\n\t\t\tasize = SIZEOF_NONRESIDENT_EX + 8;\n\t\t} else {\n\t\t\tattr->size = cpu_to_le32(SIZEOF_NONRESIDENT + 8);\n\t\t\tattr->name_off = SIZEOF_NONRESIDENT_LE;\n\t\t\tasize = SIZEOF_NONRESIDENT + 8;\n\t\t}\n\t\tattr->nres.run_off = attr->name_off;\n\t} else {\n\t\t \n\t\tattr->type = ATTR_DATA;\n\t\tattr->size = cpu_to_le32(SIZEOF_RESIDENT);\n\t\tattr->name_off = SIZEOF_RESIDENT_LE;\n\t\tif (fa & FILE_ATTRIBUTE_SPARSE_FILE)\n\t\t\tattr->flags = ATTR_FLAG_SPARSED;\n\t\telse if (fa & FILE_ATTRIBUTE_COMPRESSED)\n\t\t\tattr->flags = ATTR_FLAG_COMPRESSED;\n\t\tattr->res.data_off = SIZEOF_RESIDENT_LE;\n\t\tasize = SIZEOF_RESIDENT;\n\t\tni->ni_flags |= NI_FLAG_RESIDENT;\n\t}\n\n\tif (S_ISDIR(mode)) {\n\t\tni->ni_flags |= NI_FLAG_DIR;\n\t\terr = indx_init(&ni->dir, sbi, attr, INDEX_MUTEX_I30);\n\t\tif (err)\n\t\t\tgoto out4;\n\t} else if (S_ISLNK(mode)) {\n\t\trp = ntfs_create_reparse_buffer(sbi, symname, size, &nsize);\n\n\t\tif (IS_ERR(rp)) {\n\t\t\terr = PTR_ERR(rp);\n\t\t\trp = NULL;\n\t\t\tgoto out4;\n\t\t}\n\n\t\t \n\t\tattr = Add2Ptr(attr, asize);\n\t\tattr->type = ATTR_REPARSE;\n\t\tattr->id = cpu_to_le16(aid++);\n\n\t\t \n\t\tasize = ALIGN(SIZEOF_RESIDENT + nsize, 8);\n\t\tt16 = PtrOffset(rec, attr);\n\n\t\t \n\t\tif (asize + t16 + 0x78 + 8 > sbi->record_size) {\n\t\t\tCLST alen;\n\t\t\tCLST clst = bytes_to_cluster(sbi, nsize);\n\n\t\t\t \n\t\t\tt16 = sbi->record_size - t16 - SIZEOF_NONRESIDENT;\n\n\t\t\tattr->non_res = 1;\n\t\t\tattr->nres.evcn = cpu_to_le64(clst - 1);\n\t\t\tattr->name_off = SIZEOF_NONRESIDENT_LE;\n\t\t\tattr->nres.run_off = attr->name_off;\n\t\t\tattr->nres.data_size = cpu_to_le64(nsize);\n\t\t\tattr->nres.valid_size = attr->nres.data_size;\n\t\t\tattr->nres.alloc_size =\n\t\t\t\tcpu_to_le64(ntfs_up_cluster(sbi, nsize));\n\n\t\t\terr = attr_allocate_clusters(sbi, &ni->file.run, 0, 0,\n\t\t\t\t\t\t     clst, NULL, ALLOCATE_DEF,\n\t\t\t\t\t\t     &alen, 0, NULL, NULL);\n\t\t\tif (err)\n\t\t\t\tgoto out5;\n\n\t\t\terr = run_pack(&ni->file.run, 0, clst,\n\t\t\t\t       Add2Ptr(attr, SIZEOF_NONRESIDENT), t16,\n\t\t\t\t       &vcn);\n\t\t\tif (err < 0)\n\t\t\t\tgoto out5;\n\n\t\t\tif (vcn != clst) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out5;\n\t\t\t}\n\n\t\t\tasize = SIZEOF_NONRESIDENT + ALIGN(err, 8);\n\t\t\t \n\t\t\terr = ntfs_sb_write_run(sbi, &ni->file.run, 0, rp,\n\t\t\t\t\t\tnsize, 0);\n\t\t\tif (err)\n\t\t\t\tgoto out5;\n\t\t} else {\n\t\t\tattr->res.data_off = SIZEOF_RESIDENT_LE;\n\t\t\tattr->res.data_size = cpu_to_le32(nsize);\n\t\t\tmemcpy(Add2Ptr(attr, SIZEOF_RESIDENT), rp, nsize);\n\t\t}\n\t\t \n\t\tinode->i_size = size;\n\n\t\tattr->size = cpu_to_le32(asize);\n\n\t\terr = ntfs_insert_reparse(sbi, IO_REPARSE_TAG_SYMLINK,\n\t\t\t\t\t  &new_de->ref);\n\t\tif (err)\n\t\t\tgoto out5;\n\n\t\trp_inserted = true;\n\t}\n\n\tattr = Add2Ptr(attr, asize);\n\tattr->type = ATTR_END;\n\n\trec->used = cpu_to_le32(PtrOffset(rec, attr) + 8);\n\trec->next_attr_id = cpu_to_le16(aid);\n\n\tinode->i_generation = le16_to_cpu(rec->seq);\n\n\tif (S_ISDIR(mode)) {\n\t\tinode->i_op = &ntfs_dir_inode_operations;\n\t\tinode->i_fop = &ntfs_dir_operations;\n\t} else if (S_ISLNK(mode)) {\n\t\tinode->i_op = &ntfs_link_inode_operations;\n\t\tinode->i_fop = NULL;\n\t\tinode->i_mapping->a_ops = &ntfs_aops;\n\t\tinode->i_size = size;\n\t\tinode_nohighmem(inode);\n\t} else if (S_ISREG(mode)) {\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t\tinode->i_fop = &ntfs_file_operations;\n\t\tinode->i_mapping->a_ops = is_compressed(ni) ? &ntfs_aops_cmpr :\n\t\t\t\t\t\t\t      &ntfs_aops;\n\t\tinit_rwsem(&ni->file.run_lock);\n\t} else {\n\t\tinode->i_op = &ntfs_special_inode_operations;\n\t\tinit_special_inode(inode, mode, dev);\n\t}\n\n#ifdef CONFIG_NTFS3_FS_POSIX_ACL\n\tif (!S_ISLNK(mode) && (sb->s_flags & SB_POSIXACL)) {\n\t\terr = ntfs_init_acl(idmap, inode, dir);\n\t\tif (err)\n\t\t\tgoto out5;\n\t} else\n#endif\n\t{\n\t\tinode->i_flags |= S_NOSEC;\n\t}\n\n\t \n\tntfs_save_wsl_perm(inode, &fname->dup.ea_size);\n\n\t \n\tattr = ni_find_attr(ni, NULL, NULL, ATTR_NAME, NULL, 0, NULL, NULL);\n\tif (attr) {\n\t\tstruct ATTR_FILE_NAME *fn;\n\n\t\tfn = resident_data_ex(attr, SIZEOF_ATTRIBUTE_FILENAME);\n\t\tif (fn)\n\t\t\tfn->dup.ea_size = fname->dup.ea_size;\n\t}\n\n\t \n\tni->ni_flags &= ~NI_FLAG_UPDATE_PARENT;\n\n\t \n\terr = indx_insert_entry(&dir_ni->dir, dir_ni, new_de, sbi, fnd, 0);\n\tif (err)\n\t\tgoto out6;\n\n\t \n\td_instantiate(dentry, inode);\n\n\t \n\tinode->i_atime = inode->i_mtime =\n\t\tinode_set_ctime_to_ts(inode, ni->i_crtime);\n\tdir->i_mtime = inode_set_ctime_to_ts(dir, ni->i_crtime);\n\n\tmark_inode_dirty(dir);\n\tmark_inode_dirty(inode);\n\n\t \n\tgoto out2;\n\nout6:\n\tif (rp_inserted)\n\t\tntfs_remove_reparse(sbi, IO_REPARSE_TAG_SYMLINK, &new_de->ref);\n\nout5:\n\tif (!S_ISDIR(mode))\n\t\trun_deallocate(sbi, &ni->file.run, false);\n\nout4:\n\tclear_rec_inuse(rec);\n\tclear_nlink(inode);\n\tni->mi.dirty = false;\n\tdiscard_new_inode(inode);\nout3:\n\tntfs_mark_rec_free(sbi, ino, false);\n\nout2:\n\t__putname(new_de);\n\tkfree(rp);\n\nout1:\n\tif (!fnd)\n\t\tni_unlock(dir_ni);\n\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tunlock_new_inode(inode);\n\n\treturn inode;\n}\n\nint ntfs_link_inode(struct inode *inode, struct dentry *dentry)\n{\n\tint err;\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tstruct ntfs_sb_info *sbi = inode->i_sb->s_fs_info;\n\tstruct NTFS_DE *de;\n\n\t \n\tde = __getname();\n\tif (!de)\n\t\treturn -ENOMEM;\n\n\t \n\tntfs_set_state(sbi, NTFS_DIRTY_DIRTY);\n\n\t \n\terr = fill_name_de(sbi, de, &dentry->d_name, NULL);\n\tif (err)\n\t\tgoto out;\n\n\terr = ni_add_name(ntfs_i(d_inode(dentry->d_parent)), ni, de);\nout:\n\t__putname(de);\n\treturn err;\n}\n\n \nint ntfs_unlink_inode(struct inode *dir, const struct dentry *dentry)\n{\n\tint err;\n\tstruct ntfs_sb_info *sbi = dir->i_sb->s_fs_info;\n\tstruct inode *inode = d_inode(dentry);\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tstruct ntfs_inode *dir_ni = ntfs_i(dir);\n\tstruct NTFS_DE *de, *de2 = NULL;\n\tint undo_remove;\n\n\tif (ntfs_is_meta_file(sbi, ni->mi.rno))\n\t\treturn -EINVAL;\n\n\t \n\tde = __getname();\n\tif (!de)\n\t\treturn -ENOMEM;\n\n\tni_lock(ni);\n\n\tif (S_ISDIR(inode->i_mode) && !dir_is_empty(inode)) {\n\t\terr = -ENOTEMPTY;\n\t\tgoto out;\n\t}\n\n\terr = fill_name_de(sbi, de, &dentry->d_name, NULL);\n\tif (err < 0)\n\t\tgoto out;\n\n\tundo_remove = 0;\n\terr = ni_remove_name(dir_ni, ni, de, &de2, &undo_remove);\n\n\tif (!err) {\n\t\tdrop_nlink(inode);\n\t\tdir->i_mtime = inode_set_ctime_current(dir);\n\t\tmark_inode_dirty(dir);\n\t\tinode_set_ctime_to_ts(inode, inode_get_ctime(dir));\n\t\tif (inode->i_nlink)\n\t\t\tmark_inode_dirty(inode);\n\t} else if (!ni_remove_name_undo(dir_ni, ni, de, de2, undo_remove)) {\n\t\t_ntfs_bad_inode(inode);\n\t} else {\n\t\tif (ni_is_dirty(dir))\n\t\t\tmark_inode_dirty(dir);\n\t\tif (ni_is_dirty(inode))\n\t\t\tmark_inode_dirty(inode);\n\t}\n\nout:\n\tni_unlock(ni);\n\t__putname(de);\n\treturn err;\n}\n\nvoid ntfs_evict_inode(struct inode *inode)\n{\n\ttruncate_inode_pages_final(&inode->i_data);\n\n\tinvalidate_inode_buffers(inode);\n\tclear_inode(inode);\n\n\tni_clear(ntfs_i(inode));\n}\n\n \nstatic int ntfs_translate_junction(const struct super_block *sb,\n\t\t\t\t   const struct dentry *link_de, char *target,\n\t\t\t\t   int target_len, int target_max)\n{\n\tint tl_len, err = target_len;\n\tchar *link_path_buffer = NULL, *link_path;\n\tchar *translated = NULL;\n\tchar *target_start;\n\tint copy_len;\n\n\tlink_path_buffer = kmalloc(PATH_MAX, GFP_NOFS);\n\tif (!link_path_buffer) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\t \n\tlink_path = dentry_path_raw(link_de, link_path_buffer, PATH_MAX);\n\tif (IS_ERR(link_path)) {\n\t\tntfs_err(sb, \"Error getting link path\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ttranslated = kmalloc(PATH_MAX, GFP_NOFS);\n\tif (!translated) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\tstrcpy(translated, \"./\");\n\t++link_path;  \n\tfor (tl_len = sizeof(\"./\") - 1; *link_path; ++link_path) {\n\t\tif (*link_path == '/') {\n\t\t\tif (PATH_MAX - tl_len < sizeof(\"../\")) {\n\t\t\t\tntfs_err(sb,\n\t\t\t\t\t \"Link path %s has too many components\",\n\t\t\t\t\t link_path);\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tstrcpy(translated + tl_len, \"../\");\n\t\t\ttl_len += sizeof(\"../\") - 1;\n\t\t}\n\t}\n\n\t \n\ttarget_start = target;\n\twhile (*target_start && *target_start != ':')\n\t\t++target_start;\n\n\tif (!*target_start) {\n\t\tntfs_err(sb, \"Link target (%s) missing drive separator\",\n\t\t\t target);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\ttarget_start += 1 + (target_start[1] == '/');\n\tcopy_len = target_len - (target_start - target);\n\n\tif (PATH_MAX - tl_len <= copy_len) {\n\t\tntfs_err(sb, \"Link target %s too large for buffer (%d <= %d)\",\n\t\t\t target_start, PATH_MAX - tl_len, copy_len);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tstrcpy(translated + tl_len, target_start);\n\ttl_len += copy_len;\n\tif (target_max <= tl_len) {\n\t\tntfs_err(sb, \"Target path %s too large for buffer (%d <= %d)\",\n\t\t\t translated, target_max, tl_len);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\tstrcpy(target, translated);\n\terr = tl_len;\n\nout:\n\tkfree(link_path_buffer);\n\tkfree(translated);\n\treturn err;\n}\n\nstatic noinline int ntfs_readlink_hlp(const struct dentry *link_de,\n\t\t\t\t      struct inode *inode, char *buffer,\n\t\t\t\t      int buflen)\n{\n\tint i, err = -EINVAL;\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ntfs_sb_info *sbi = sb->s_fs_info;\n\tu64 size;\n\tu16 ulen = 0;\n\tvoid *to_free = NULL;\n\tstruct REPARSE_DATA_BUFFER *rp;\n\tconst __le16 *uname;\n\tstruct ATTRIB *attr;\n\n\t \n\tstatic_assert(!offsetof(struct REPARSE_DATA_BUFFER, ReparseTag));\n\tstatic_assert(sizeof(u32) == sizeof(rp->ReparseTag));\n\n\t*buffer = 0;\n\n\tattr = ni_find_attr(ni, NULL, NULL, ATTR_REPARSE, NULL, 0, NULL, NULL);\n\tif (!attr)\n\t\tgoto out;\n\n\tif (!attr->non_res) {\n\t\trp = resident_data_ex(attr, sizeof(struct REPARSE_DATA_BUFFER));\n\t\tif (!rp)\n\t\t\tgoto out;\n\t\tsize = le32_to_cpu(attr->res.data_size);\n\t} else {\n\t\tsize = le64_to_cpu(attr->nres.data_size);\n\t\trp = NULL;\n\t}\n\n\tif (size > sbi->reparse.max_size || size <= sizeof(u32))\n\t\tgoto out;\n\n\tif (!rp) {\n\t\trp = kmalloc(size, GFP_NOFS);\n\t\tif (!rp) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tto_free = rp;\n\t\t \n\t\terr = ntfs_read_run_nb(sbi, &ni->file.run, 0, rp, size, NULL);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\t \n\tswitch (rp->ReparseTag) {\n\tcase IO_REPARSE_TAG_MOUNT_POINT:\n\t\t \n\t\t \n\t\tif (size <= offsetof(struct REPARSE_DATA_BUFFER,\n\t\t\t\t     MountPointReparseBuffer.PathBuffer))\n\t\t\tgoto out;\n\t\tuname = Add2Ptr(rp,\n\t\t\t\toffsetof(struct REPARSE_DATA_BUFFER,\n\t\t\t\t\t MountPointReparseBuffer.PathBuffer) +\n\t\t\t\t\tle16_to_cpu(rp->MountPointReparseBuffer\n\t\t\t\t\t\t\t    .PrintNameOffset));\n\t\tulen = le16_to_cpu(rp->MountPointReparseBuffer.PrintNameLength);\n\t\tbreak;\n\n\tcase IO_REPARSE_TAG_SYMLINK:\n\t\t \n\t\t \n\t\tif (size <= offsetof(struct REPARSE_DATA_BUFFER,\n\t\t\t\t     SymbolicLinkReparseBuffer.PathBuffer))\n\t\t\tgoto out;\n\t\tuname = Add2Ptr(\n\t\t\trp, offsetof(struct REPARSE_DATA_BUFFER,\n\t\t\t\t     SymbolicLinkReparseBuffer.PathBuffer) +\n\t\t\t\t    le16_to_cpu(rp->SymbolicLinkReparseBuffer\n\t\t\t\t\t\t\t.PrintNameOffset));\n\t\tulen = le16_to_cpu(\n\t\t\trp->SymbolicLinkReparseBuffer.PrintNameLength);\n\t\tbreak;\n\n\tcase IO_REPARSE_TAG_CLOUD:\n\tcase IO_REPARSE_TAG_CLOUD_1:\n\tcase IO_REPARSE_TAG_CLOUD_2:\n\tcase IO_REPARSE_TAG_CLOUD_3:\n\tcase IO_REPARSE_TAG_CLOUD_4:\n\tcase IO_REPARSE_TAG_CLOUD_5:\n\tcase IO_REPARSE_TAG_CLOUD_6:\n\tcase IO_REPARSE_TAG_CLOUD_7:\n\tcase IO_REPARSE_TAG_CLOUD_8:\n\tcase IO_REPARSE_TAG_CLOUD_9:\n\tcase IO_REPARSE_TAG_CLOUD_A:\n\tcase IO_REPARSE_TAG_CLOUD_B:\n\tcase IO_REPARSE_TAG_CLOUD_C:\n\tcase IO_REPARSE_TAG_CLOUD_D:\n\tcase IO_REPARSE_TAG_CLOUD_E:\n\tcase IO_REPARSE_TAG_CLOUD_F:\n\t\terr = sizeof(\"OneDrive\") - 1;\n\t\tif (err > buflen)\n\t\t\terr = buflen;\n\t\tmemcpy(buffer, \"OneDrive\", err);\n\t\tgoto out;\n\n\tdefault:\n\t\tif (IsReparseTagMicrosoft(rp->ReparseTag)) {\n\t\t\t \n\t\t\tgoto out;\n\t\t}\n\t\tif (!IsReparseTagNameSurrogate(rp->ReparseTag) ||\n\t\t    size <= sizeof(struct REPARSE_POINT)) {\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tuname = Add2Ptr(rp, sizeof(struct REPARSE_POINT));\n\t\tulen = le16_to_cpu(rp->ReparseDataLength) -\n\t\t       sizeof(struct REPARSE_POINT);\n\t}\n\n\t \n\tulen >>= 1;\n\n\t \n\tif (!ulen || uname + ulen > (__le16 *)Add2Ptr(rp, size))\n\t\tgoto out;\n\n\t \n\tif (!uname[ulen - 1])\n\t\tulen -= 1;\n\n\terr = ntfs_utf16_to_nls(sbi, uname, ulen, buffer, buflen);\n\n\tif (err < 0)\n\t\tgoto out;\n\n\t \n\tfor (i = 0; i < err; i++) {\n\t\tif (buffer[i] == '\\\\')\n\t\t\tbuffer[i] = '/';\n\t}\n\n\t \n\tbuffer[err] = 0;\n\n\t \n\tif (rp->ReparseTag == IO_REPARSE_TAG_MOUNT_POINT)\n\t\terr = ntfs_translate_junction(sb, link_de, buffer, err, buflen);\n\nout:\n\tkfree(to_free);\n\treturn err;\n}\n\nstatic const char *ntfs_get_link(struct dentry *de, struct inode *inode,\n\t\t\t\t struct delayed_call *done)\n{\n\tint err;\n\tchar *ret;\n\n\tif (!de)\n\t\treturn ERR_PTR(-ECHILD);\n\n\tret = kmalloc(PAGE_SIZE, GFP_NOFS);\n\tif (!ret)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = ntfs_readlink_hlp(de, inode, ret, PAGE_SIZE);\n\tif (err < 0) {\n\t\tkfree(ret);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tset_delayed_call(done, kfree_link, ret);\n\n\treturn ret;\n}\n\n\nconst struct inode_operations ntfs_link_inode_operations = {\n\t.get_link\t= ntfs_get_link,\n\t.setattr\t= ntfs3_setattr,\n\t.listxattr\t= ntfs_listxattr,\n};\n\nconst struct address_space_operations ntfs_aops = {\n\t.read_folio\t= ntfs_read_folio,\n\t.readahead\t= ntfs_readahead,\n\t.writepages\t= ntfs_writepages,\n\t.write_begin\t= ntfs_write_begin,\n\t.write_end\t= ntfs_write_end,\n\t.direct_IO\t= ntfs_direct_IO,\n\t.bmap\t\t= ntfs_bmap,\n\t.dirty_folio\t= block_dirty_folio,\n\t.migrate_folio\t= buffer_migrate_folio,\n\t.invalidate_folio = block_invalidate_folio,\n};\n\nconst struct address_space_operations ntfs_aops_cmpr = {\n\t.read_folio\t= ntfs_read_folio,\n\t.readahead\t= ntfs_readahead,\n};\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}