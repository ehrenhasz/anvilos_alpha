{
  "module_name": "fslog.c",
  "hash_id": "edf5dbe45eefeb6311347a05e6462203fde7fa67195310a1c4c809c3d75a7d68",
  "original_prompt": "Ingested from linux-6.6.14/fs/ntfs3/fslog.c",
  "human_readable_source": "\n \n\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n#include <linux/random.h>\n#include <linux/slab.h>\n\n#include \"debug.h\"\n#include \"ntfs.h\"\n#include \"ntfs_fs.h\"\n\n \n\n\n\n#define MaxLogFileSize     0x100000000ull\n#define DefaultLogPageSize 4096\n#define MinLogRecordPages  0x30\n\nstruct RESTART_HDR {\n\tstruct NTFS_RECORD_HEADER rhdr; \n\t__le32 sys_page_size; \n\t__le32 page_size;     \n\t__le16 ra_off;        \n\t__le16 minor_ver;     \n\t__le16 major_ver;     \n\t__le16 fixups[];\n};\n\n#define LFS_NO_CLIENT 0xffff\n#define LFS_NO_CLIENT_LE cpu_to_le16(0xffff)\n\nstruct CLIENT_REC {\n\t__le64 oldest_lsn;\n\t__le64 restart_lsn; \n\t__le16 prev_client; \n\t__le16 next_client; \n\t__le16 seq_num;     \n\tu8 align[6];        \n\t__le32 name_bytes;  \n\t__le16 name[32];    \n};\n\nstatic_assert(sizeof(struct CLIENT_REC) == 0x60);\n\n \nstruct RESTART_AREA {\n\t__le64 current_lsn;    \n\t__le16 log_clients;    \n\t__le16 client_idx[2];  \n\t__le16 flags;          \n\t__le32 seq_num_bits;   \n\t__le16 ra_len;         \n\t__le16 client_off;     \n\t__le64 l_size;         \n\t__le32 last_lsn_data_len; \n\t__le16 rec_hdr_len;    \n\t__le16 data_off;       \n\t__le32 open_log_count; \n\t__le32 align[5];       \n\tstruct CLIENT_REC clients[]; \n};\n\nstruct LOG_REC_HDR {\n\t__le16 redo_op;      \n\t__le16 undo_op;      \n\t__le16 redo_off;     \n\t__le16 redo_len;     \n\t__le16 undo_off;     \n\t__le16 undo_len;     \n\t__le16 target_attr;  \n\t__le16 lcns_follow;  \n\t__le16 record_off;   \n\t__le16 attr_off;     \n\t__le16 cluster_off;  \n\t__le16 reserved;     \n\t__le64 target_vcn;   \n\t__le64 page_lcns[];  \n};\n\nstatic_assert(sizeof(struct LOG_REC_HDR) == 0x20);\n\n#define RESTART_ENTRY_ALLOCATED    0xFFFFFFFF\n#define RESTART_ENTRY_ALLOCATED_LE cpu_to_le32(0xFFFFFFFF)\n\nstruct RESTART_TABLE {\n\t__le16 size;       \n\t__le16 used;       \n\t__le16 total;      \n\t__le16 res[3];     \n\t__le32 free_goal;  \n\t__le32 first_free; \n\t__le32 last_free;  \n\n};\n\nstatic_assert(sizeof(struct RESTART_TABLE) == 0x18);\n\nstruct ATTR_NAME_ENTRY {\n\t__le16 off; \n\t__le16 name_bytes;\n\t__le16 name[];\n};\n\nstruct OPEN_ATTR_ENRTY {\n\t__le32 next;            \n\t__le32 bytes_per_index; \n\tenum ATTR_TYPE type;    \n\tu8 is_dirty_pages;      \n\tu8 is_attr_name;        \n\tu8 name_len;            \n\tu8 res;\n\tstruct MFT_REF ref;     \n\t__le64 open_record_lsn; \n\tvoid *ptr;              \n};\n\n \nstruct OPEN_ATTR_ENRTY_32 {\n\t__le32 next;            \n\t__le32 ptr;             \n\tstruct MFT_REF ref;     \n\t__le64 open_record_lsn; \n\tu8 is_dirty_pages;      \n\tu8 is_attr_name;        \n\tu8 res1[2];\n\tenum ATTR_TYPE type;    \n\tu8 name_len;            \n\tu8 res2[3];\n\t__le32 AttributeName;   \n\t__le32 bytes_per_index; \n};\n\n#define SIZEOF_OPENATTRIBUTEENTRY0 0x2c\n\nstatic_assert(sizeof(struct OPEN_ATTR_ENRTY) < SIZEOF_OPENATTRIBUTEENTRY0);\n\n \nstruct DIR_PAGE_ENTRY {\n\t__le32 next;         \n\t__le32 target_attr;  \n\t__le32 transfer_len; \n\t__le32 lcns_follow;  \n\t__le64 vcn;          \n\t__le64 oldest_lsn;   \n\t__le64 page_lcns[];  \n};\n\nstatic_assert(sizeof(struct DIR_PAGE_ENTRY) == 0x20);\n\n \nstruct DIR_PAGE_ENTRY_32 {\n\t__le32 next;\t\t\n\t__le32 target_attr;\t\n\t__le32 transfer_len;\t\n\t__le32 lcns_follow;\t\n\t__le32 reserved;\t\n\t__le32 vcn_low;\t\t\n\t__le32 vcn_hi;\t\t\n\t__le32 oldest_lsn_low;\t\n\t__le32 oldest_lsn_hi;\t\n\t__le32 page_lcns_low;\t\n\t__le32 page_lcns_hi;\t\n};\n\nstatic_assert(offsetof(struct DIR_PAGE_ENTRY_32, vcn_low) == 0x14);\nstatic_assert(sizeof(struct DIR_PAGE_ENTRY_32) == 0x2c);\n\nenum transact_state {\n\tTransactionUninitialized = 0,\n\tTransactionActive,\n\tTransactionPrepared,\n\tTransactionCommitted\n};\n\nstruct TRANSACTION_ENTRY {\n\t__le32 next;          \n\tu8 transact_state;    \n\tu8 reserved[3];       \n\t__le64 first_lsn;     \n\t__le64 prev_lsn;      \n\t__le64 undo_next_lsn; \n\t__le32 undo_records;  \n\t__le32 undo_len;      \n};\n\nstatic_assert(sizeof(struct TRANSACTION_ENTRY) == 0x28);\n\nstruct NTFS_RESTART {\n\t__le32 major_ver;             \n\t__le32 minor_ver;             \n\t__le64 check_point_start;     \n\t__le64 open_attr_table_lsn;   \n\t__le64 attr_names_lsn;        \n\t__le64 dirty_pages_table_lsn; \n\t__le64 transact_table_lsn;    \n\t__le32 open_attr_len;         \n\t__le32 attr_names_len;        \n\t__le32 dirty_pages_len;       \n\t__le32 transact_table_len;    \n};\n\nstatic_assert(sizeof(struct NTFS_RESTART) == 0x40);\n\nstruct NEW_ATTRIBUTE_SIZES {\n\t__le64 alloc_size;\n\t__le64 valid_size;\n\t__le64 data_size;\n\t__le64 total_size;\n};\n\nstruct BITMAP_RANGE {\n\t__le32 bitmap_off;\n\t__le32 bits;\n};\n\nstruct LCN_RANGE {\n\t__le64 lcn;\n\t__le64 len;\n};\n\n \n#define LfsClientRecord  cpu_to_le32(1)\n#define LfsClientRestart cpu_to_le32(2)\n\n \nstruct CLIENT_ID {\n\t__le16 seq_num;\n\t__le16 client_idx;\n};\n\n \nstruct LFS_RECORD_HDR {\n\t__le64 this_lsn;\t\t\n\t__le64 client_prev_lsn;\t\t\n\t__le64 client_undo_next_lsn;\t\n\t__le32 client_data_len;\t\t\n\tstruct CLIENT_ID client;\t\n\t__le32 record_type;\t\t\n\t__le32 transact_id;\t\t\n\t__le16 flags;\t\t\t\n\tu8 align[6];\t\t\t\n};\n\n#define LOG_RECORD_MULTI_PAGE cpu_to_le16(1)\n\nstatic_assert(sizeof(struct LFS_RECORD_HDR) == 0x30);\n\nstruct LFS_RECORD {\n\t__le16 next_record_off;\t\n\tu8 align[6];\t\t\n\t__le64 last_end_lsn;\t\n};\n\nstatic_assert(sizeof(struct LFS_RECORD) == 0x10);\n\nstruct RECORD_PAGE_HDR {\n\tstruct NTFS_RECORD_HEADER rhdr;\t\n\t__le32 rflags;\t\t\t\n\t__le16 page_count;\t\t\n\t__le16 page_pos;\t\t\n\tstruct LFS_RECORD record_hdr;\t\n\t__le16 fixups[10];\t\t\n\t__le32 file_off;\t\t\n};\n\n\n\n\n#define LOG_PAGE_LOG_RECORD_END cpu_to_le32(0x00000001)\n\nstatic inline bool is_log_record_end(const struct RECORD_PAGE_HDR *hdr)\n{\n\treturn hdr->rflags & LOG_PAGE_LOG_RECORD_END;\n}\n\nstatic_assert(offsetof(struct RECORD_PAGE_HDR, file_off) == 0x3c);\n\n \n\n \n#define INITIAL_NUMBER_TRANSACTIONS 5\n\nenum NTFS_LOG_OPERATION {\n\n\tNoop = 0x00,\n\tCompensationLogRecord = 0x01,\n\tInitializeFileRecordSegment = 0x02,\n\tDeallocateFileRecordSegment = 0x03,\n\tWriteEndOfFileRecordSegment = 0x04,\n\tCreateAttribute = 0x05,\n\tDeleteAttribute = 0x06,\n\tUpdateResidentValue = 0x07,\n\tUpdateNonresidentValue = 0x08,\n\tUpdateMappingPairs = 0x09,\n\tDeleteDirtyClusters = 0x0A,\n\tSetNewAttributeSizes = 0x0B,\n\tAddIndexEntryRoot = 0x0C,\n\tDeleteIndexEntryRoot = 0x0D,\n\tAddIndexEntryAllocation = 0x0E,\n\tDeleteIndexEntryAllocation = 0x0F,\n\tWriteEndOfIndexBuffer = 0x10,\n\tSetIndexEntryVcnRoot = 0x11,\n\tSetIndexEntryVcnAllocation = 0x12,\n\tUpdateFileNameRoot = 0x13,\n\tUpdateFileNameAllocation = 0x14,\n\tSetBitsInNonresidentBitMap = 0x15,\n\tClearBitsInNonresidentBitMap = 0x16,\n\tHotFix = 0x17,\n\tEndTopLevelAction = 0x18,\n\tPrepareTransaction = 0x19,\n\tCommitTransaction = 0x1A,\n\tForgetTransaction = 0x1B,\n\tOpenNonresidentAttribute = 0x1C,\n\tOpenAttributeTableDump = 0x1D,\n\tAttributeNamesDump = 0x1E,\n\tDirtyPageTableDump = 0x1F,\n\tTransactionTableDump = 0x20,\n\tUpdateRecordDataRoot = 0x21,\n\tUpdateRecordDataAllocation = 0x22,\n\n\tUpdateRelativeDataInIndex =\n\t\t0x23, \n\tUpdateRelativeDataInIndex2 = 0x24,\n\tZeroEndOfFileRecord = 0x25,\n};\n\n \nstatic const u8 AttributeRequired[] = {\n\t0xFC, 0xFB, 0xFF, 0x10, 0x06,\n};\n\nstatic inline bool is_target_required(u16 op)\n{\n\tbool ret = op <= UpdateRecordDataAllocation &&\n\t\t   (AttributeRequired[op >> 3] >> (op & 7) & 1);\n\treturn ret;\n}\n\nstatic inline bool can_skip_action(enum NTFS_LOG_OPERATION op)\n{\n\tswitch (op) {\n\tcase Noop:\n\tcase DeleteDirtyClusters:\n\tcase HotFix:\n\tcase EndTopLevelAction:\n\tcase PrepareTransaction:\n\tcase CommitTransaction:\n\tcase ForgetTransaction:\n\tcase CompensationLogRecord:\n\tcase OpenNonresidentAttribute:\n\tcase OpenAttributeTableDump:\n\tcase AttributeNamesDump:\n\tcase DirtyPageTableDump:\n\tcase TransactionTableDump:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nenum { lcb_ctx_undo_next, lcb_ctx_prev, lcb_ctx_next };\n\n \nstatic inline u32 bytes_per_rt(const struct RESTART_TABLE *rt)\n{\n\treturn le16_to_cpu(rt->used) * le16_to_cpu(rt->size) +\n\t       sizeof(struct RESTART_TABLE);\n}\n\n \nstatic inline u32 lrh_length(const struct LOG_REC_HDR *lr)\n{\n\tu16 t16 = le16_to_cpu(lr->lcns_follow);\n\n\treturn struct_size(lr, page_lcns, max_t(u16, 1, t16));\n}\n\nstruct lcb {\n\tstruct LFS_RECORD_HDR *lrh; \n\tstruct LOG_REC_HDR *log_rec;\n\tu32 ctx_mode; \n\tstruct CLIENT_ID client;\n\tbool alloc; \n};\n\nstatic void lcb_put(struct lcb *lcb)\n{\n\tif (lcb->alloc)\n\t\tkfree(lcb->log_rec);\n\tkfree(lcb->lrh);\n\tkfree(lcb);\n}\n\n \nstatic inline void oldest_client_lsn(const struct CLIENT_REC *ca,\n\t\t\t\t     __le16 next_client, u64 *oldest_lsn)\n{\n\twhile (next_client != LFS_NO_CLIENT_LE) {\n\t\tconst struct CLIENT_REC *cr = ca + le16_to_cpu(next_client);\n\t\tu64 lsn = le64_to_cpu(cr->oldest_lsn);\n\n\t\t \n\t\tif (lsn && lsn < *oldest_lsn)\n\t\t\t*oldest_lsn = lsn;\n\n\t\tnext_client = cr->next_client;\n\t}\n}\n\nstatic inline bool is_rst_page_hdr_valid(u32 file_off,\n\t\t\t\t\t const struct RESTART_HDR *rhdr)\n{\n\tu32 sys_page = le32_to_cpu(rhdr->sys_page_size);\n\tu32 page_size = le32_to_cpu(rhdr->page_size);\n\tu32 end_usa;\n\tu16 ro;\n\n\tif (sys_page < SECTOR_SIZE || page_size < SECTOR_SIZE ||\n\t    sys_page & (sys_page - 1) || page_size & (page_size - 1)) {\n\t\treturn false;\n\t}\n\n\t \n\tif (file_off && file_off != sys_page)\n\t\treturn false;\n\n\t \n\tif (le16_to_cpu(rhdr->major_ver) <= 1 && !rhdr->minor_ver)\n\t\treturn false;\n\n\tif (le16_to_cpu(rhdr->major_ver) > 2)\n\t\treturn false;\n\n\tro = le16_to_cpu(rhdr->ra_off);\n\tif (!IS_ALIGNED(ro, 8) || ro > sys_page)\n\t\treturn false;\n\n\tend_usa = ((sys_page >> SECTOR_SHIFT) + 1) * sizeof(short);\n\tend_usa += le16_to_cpu(rhdr->rhdr.fix_off);\n\n\tif (ro < end_usa)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic inline bool is_rst_area_valid(const struct RESTART_HDR *rhdr)\n{\n\tconst struct RESTART_AREA *ra;\n\tu16 cl, fl, ul;\n\tu32 off, l_size, file_dat_bits, file_size_round;\n\tu16 ro = le16_to_cpu(rhdr->ra_off);\n\tu32 sys_page = le32_to_cpu(rhdr->sys_page_size);\n\n\tif (ro + offsetof(struct RESTART_AREA, l_size) >\n\t    SECTOR_SIZE - sizeof(short))\n\t\treturn false;\n\n\tra = Add2Ptr(rhdr, ro);\n\tcl = le16_to_cpu(ra->log_clients);\n\n\tif (cl > 1)\n\t\treturn false;\n\n\toff = le16_to_cpu(ra->client_off);\n\n\tif (!IS_ALIGNED(off, 8) || ro + off > SECTOR_SIZE - sizeof(short))\n\t\treturn false;\n\n\toff += cl * sizeof(struct CLIENT_REC);\n\n\tif (off > sys_page)\n\t\treturn false;\n\n\t \n\tif (le16_to_cpu(rhdr->ra_off) + le16_to_cpu(ra->ra_len) > sys_page ||\n\t    off > le16_to_cpu(ra->ra_len)) {\n\t\treturn false;\n\t}\n\n\t \n\tfl = le16_to_cpu(ra->client_idx[0]);\n\tul = le16_to_cpu(ra->client_idx[1]);\n\tif ((fl != LFS_NO_CLIENT && fl >= cl) ||\n\t    (ul != LFS_NO_CLIENT && ul >= cl))\n\t\treturn false;\n\n\t \n\tl_size = le64_to_cpu(ra->l_size);\n\n\tfile_dat_bits = sizeof(u64) * 8 - le32_to_cpu(ra->seq_num_bits);\n\tfile_size_round = 1u << (file_dat_bits + 3);\n\tif (file_size_round != l_size &&\n\t    (file_size_round < l_size || (file_size_round / 2) > l_size)) {\n\t\treturn false;\n\t}\n\n\t \n\tif (!IS_ALIGNED(le16_to_cpu(ra->data_off), 8) ||\n\t    !IS_ALIGNED(le16_to_cpu(ra->rec_hdr_len), 8))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic inline bool is_client_area_valid(const struct RESTART_HDR *rhdr,\n\t\t\t\t\tbool usa_error)\n{\n\tu16 ro = le16_to_cpu(rhdr->ra_off);\n\tconst struct RESTART_AREA *ra = Add2Ptr(rhdr, ro);\n\tu16 ra_len = le16_to_cpu(ra->ra_len);\n\tconst struct CLIENT_REC *ca;\n\tu32 i;\n\n\tif (usa_error && ra_len + ro > SECTOR_SIZE - sizeof(short))\n\t\treturn false;\n\n\t \n\tca = Add2Ptr(ra, le16_to_cpu(ra->client_off));\n\n\t \n\tfor (i = 0; i < 2; i++) {\n\t\tu16 client_idx = le16_to_cpu(ra->client_idx[i]);\n\t\tbool first_client = true;\n\t\tu16 clients = le16_to_cpu(ra->log_clients);\n\n\t\twhile (client_idx != LFS_NO_CLIENT) {\n\t\t\tconst struct CLIENT_REC *cr;\n\n\t\t\tif (!clients ||\n\t\t\t    client_idx >= le16_to_cpu(ra->log_clients))\n\t\t\t\treturn false;\n\n\t\t\tclients -= 1;\n\t\t\tcr = ca + client_idx;\n\n\t\t\tclient_idx = le16_to_cpu(cr->next_client);\n\n\t\t\tif (first_client) {\n\t\t\t\tfirst_client = false;\n\t\t\t\tif (cr->prev_client != LFS_NO_CLIENT_LE)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\n \nstatic inline void remove_client(struct CLIENT_REC *ca,\n\t\t\t\t const struct CLIENT_REC *cr, __le16 *head)\n{\n\tif (cr->prev_client == LFS_NO_CLIENT_LE)\n\t\t*head = cr->next_client;\n\telse\n\t\tca[le16_to_cpu(cr->prev_client)].next_client = cr->next_client;\n\n\tif (cr->next_client != LFS_NO_CLIENT_LE)\n\t\tca[le16_to_cpu(cr->next_client)].prev_client = cr->prev_client;\n}\n\n \nstatic inline void add_client(struct CLIENT_REC *ca, u16 index, __le16 *head)\n{\n\tstruct CLIENT_REC *cr = ca + index;\n\n\tcr->prev_client = LFS_NO_CLIENT_LE;\n\tcr->next_client = *head;\n\n\tif (*head != LFS_NO_CLIENT_LE)\n\t\tca[le16_to_cpu(*head)].prev_client = cpu_to_le16(index);\n\n\t*head = cpu_to_le16(index);\n}\n\nstatic inline void *enum_rstbl(struct RESTART_TABLE *t, void *c)\n{\n\t__le32 *e;\n\tu32 bprt;\n\tu16 rsize = t ? le16_to_cpu(t->size) : 0;\n\n\tif (!c) {\n\t\tif (!t || !t->total)\n\t\t\treturn NULL;\n\t\te = Add2Ptr(t, sizeof(struct RESTART_TABLE));\n\t} else {\n\t\te = Add2Ptr(c, rsize);\n\t}\n\n\t \n\tfor (bprt = bytes_per_rt(t); PtrOffset(t, e) < bprt;\n\t     e = Add2Ptr(e, rsize)) {\n\t\tif (*e == RESTART_ENTRY_ALLOCATED_LE)\n\t\t\treturn e;\n\t}\n\treturn NULL;\n}\n\n \nstatic inline struct DIR_PAGE_ENTRY *find_dp(struct RESTART_TABLE *dptbl,\n\t\t\t\t\t     u32 target_attr, u64 vcn)\n{\n\t__le32 ta = cpu_to_le32(target_attr);\n\tstruct DIR_PAGE_ENTRY *dp = NULL;\n\n\twhile ((dp = enum_rstbl(dptbl, dp))) {\n\t\tu64 dp_vcn = le64_to_cpu(dp->vcn);\n\n\t\tif (dp->target_attr == ta && vcn >= dp_vcn &&\n\t\t    vcn < dp_vcn + le32_to_cpu(dp->lcns_follow)) {\n\t\t\treturn dp;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic inline u32 norm_file_page(u32 page_size, u32 *l_size, bool use_default)\n{\n\tif (use_default)\n\t\tpage_size = DefaultLogPageSize;\n\n\t \n\t*l_size &= ~(page_size - 1);\n\n\t \n\tif (*l_size < (MinLogRecordPages + 2) * page_size)\n\t\treturn 0;\n\n\treturn page_size;\n}\n\nstatic bool check_log_rec(const struct LOG_REC_HDR *lr, u32 bytes, u32 tr,\n\t\t\t  u32 bytes_per_attr_entry)\n{\n\tu16 t16;\n\n\tif (bytes < sizeof(struct LOG_REC_HDR))\n\t\treturn false;\n\tif (!tr)\n\t\treturn false;\n\n\tif ((tr - sizeof(struct RESTART_TABLE)) %\n\t    sizeof(struct TRANSACTION_ENTRY))\n\t\treturn false;\n\n\tif (le16_to_cpu(lr->redo_off) & 7)\n\t\treturn false;\n\n\tif (le16_to_cpu(lr->undo_off) & 7)\n\t\treturn false;\n\n\tif (lr->target_attr)\n\t\tgoto check_lcns;\n\n\tif (is_target_required(le16_to_cpu(lr->redo_op)))\n\t\treturn false;\n\n\tif (is_target_required(le16_to_cpu(lr->undo_op)))\n\t\treturn false;\n\ncheck_lcns:\n\tif (!lr->lcns_follow)\n\t\tgoto check_length;\n\n\tt16 = le16_to_cpu(lr->target_attr);\n\tif ((t16 - sizeof(struct RESTART_TABLE)) % bytes_per_attr_entry)\n\t\treturn false;\n\ncheck_length:\n\tif (bytes < lrh_length(lr))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool check_rstbl(const struct RESTART_TABLE *rt, size_t bytes)\n{\n\tu32 ts;\n\tu32 i, off;\n\tu16 rsize = le16_to_cpu(rt->size);\n\tu16 ne = le16_to_cpu(rt->used);\n\tu32 ff = le32_to_cpu(rt->first_free);\n\tu32 lf = le32_to_cpu(rt->last_free);\n\n\tts = rsize * ne + sizeof(struct RESTART_TABLE);\n\n\tif (!rsize || rsize > bytes ||\n\t    rsize + sizeof(struct RESTART_TABLE) > bytes || bytes < ts ||\n\t    le16_to_cpu(rt->total) > ne || ff > ts || lf > ts ||\n\t    (ff && ff < sizeof(struct RESTART_TABLE)) ||\n\t    (lf && lf < sizeof(struct RESTART_TABLE))) {\n\t\treturn false;\n\t}\n\n\t \n\tfor (i = 0; i < ne; i++) {\n\t\toff = le32_to_cpu(*(__le32 *)Add2Ptr(\n\t\t\trt, i * rsize + sizeof(struct RESTART_TABLE)));\n\n\t\tif (off != RESTART_ENTRY_ALLOCATED && off &&\n\t\t    (off < sizeof(struct RESTART_TABLE) ||\n\t\t     ((off - sizeof(struct RESTART_TABLE)) % rsize))) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t \n\tfor (off = ff; off;) {\n\t\tif (off == RESTART_ENTRY_ALLOCATED)\n\t\t\treturn false;\n\n\t\toff = le32_to_cpu(*(__le32 *)Add2Ptr(rt, off));\n\t}\n\n\treturn true;\n}\n\n \nstatic inline void free_rsttbl_idx(struct RESTART_TABLE *rt, u32 off)\n{\n\t__le32 *e;\n\tu32 lf = le32_to_cpu(rt->last_free);\n\t__le32 off_le = cpu_to_le32(off);\n\n\te = Add2Ptr(rt, off);\n\n\tif (off < le32_to_cpu(rt->free_goal)) {\n\t\t*e = rt->first_free;\n\t\trt->first_free = off_le;\n\t\tif (!lf)\n\t\t\trt->last_free = off_le;\n\t} else {\n\t\tif (lf)\n\t\t\t*(__le32 *)Add2Ptr(rt, lf) = off_le;\n\t\telse\n\t\t\trt->first_free = off_le;\n\n\t\trt->last_free = off_le;\n\t\t*e = 0;\n\t}\n\n\tle16_sub_cpu(&rt->total, 1);\n}\n\nstatic inline struct RESTART_TABLE *init_rsttbl(u16 esize, u16 used)\n{\n\t__le32 *e, *last_free;\n\tu32 off;\n\tu32 bytes = esize * used + sizeof(struct RESTART_TABLE);\n\tu32 lf = sizeof(struct RESTART_TABLE) + (used - 1) * esize;\n\tstruct RESTART_TABLE *t = kzalloc(bytes, GFP_NOFS);\n\n\tif (!t)\n\t\treturn NULL;\n\n\tt->size = cpu_to_le16(esize);\n\tt->used = cpu_to_le16(used);\n\tt->free_goal = cpu_to_le32(~0u);\n\tt->first_free = cpu_to_le32(sizeof(struct RESTART_TABLE));\n\tt->last_free = cpu_to_le32(lf);\n\n\te = (__le32 *)(t + 1);\n\tlast_free = Add2Ptr(t, lf);\n\n\tfor (off = sizeof(struct RESTART_TABLE) + esize; e < last_free;\n\t     e = Add2Ptr(e, esize), off += esize) {\n\t\t*e = cpu_to_le32(off);\n\t}\n\treturn t;\n}\n\nstatic inline struct RESTART_TABLE *extend_rsttbl(struct RESTART_TABLE *tbl,\n\t\t\t\t\t\t  u32 add, u32 free_goal)\n{\n\tu16 esize = le16_to_cpu(tbl->size);\n\t__le32 osize = cpu_to_le32(bytes_per_rt(tbl));\n\tu32 used = le16_to_cpu(tbl->used);\n\tstruct RESTART_TABLE *rt;\n\n\trt = init_rsttbl(esize, used + add);\n\tif (!rt)\n\t\treturn NULL;\n\n\tmemcpy(rt + 1, tbl + 1, esize * used);\n\n\trt->free_goal = free_goal == ~0u ?\n\t\t\t\tcpu_to_le32(~0u) :\n\t\t\t\tcpu_to_le32(sizeof(struct RESTART_TABLE) +\n\t\t\t\t\t    free_goal * esize);\n\n\tif (tbl->first_free) {\n\t\trt->first_free = tbl->first_free;\n\t\t*(__le32 *)Add2Ptr(rt, le32_to_cpu(tbl->last_free)) = osize;\n\t} else {\n\t\trt->first_free = osize;\n\t}\n\n\trt->total = tbl->total;\n\n\tkfree(tbl);\n\treturn rt;\n}\n\n \nstatic inline void *alloc_rsttbl_idx(struct RESTART_TABLE **tbl)\n{\n\tu32 off;\n\t__le32 *e;\n\tstruct RESTART_TABLE *t = *tbl;\n\n\tif (!t->first_free) {\n\t\t*tbl = t = extend_rsttbl(t, 16, ~0u);\n\t\tif (!t)\n\t\t\treturn NULL;\n\t}\n\n\toff = le32_to_cpu(t->first_free);\n\n\t \n\te = Add2Ptr(t, off);\n\n\tt->first_free = *e;\n\n\tmemset(e, 0, le16_to_cpu(t->size));\n\n\t*e = RESTART_ENTRY_ALLOCATED_LE;\n\n\t \n\tif (!t->first_free)\n\t\tt->last_free = 0;\n\n\tle16_add_cpu(&t->total, 1);\n\n\treturn Add2Ptr(t, off);\n}\n\n \nstatic inline void *alloc_rsttbl_from_idx(struct RESTART_TABLE **tbl, u32 vbo)\n{\n\tu32 off;\n\t__le32 *e;\n\tstruct RESTART_TABLE *rt = *tbl;\n\tu32 bytes = bytes_per_rt(rt);\n\tu16 esize = le16_to_cpu(rt->size);\n\n\t \n\tif (vbo >= bytes) {\n\t\t \n\t\tu32 bytes2idx = vbo - bytes;\n\n\t\t \n\t\t*tbl = rt = extend_rsttbl(rt, bytes2idx / esize + 1, bytes);\n\t\tif (!rt)\n\t\t\treturn NULL;\n\t}\n\n\t \n\te = Add2Ptr(rt, vbo);\n\n\tif (*e == RESTART_ENTRY_ALLOCATED_LE)\n\t\treturn e;\n\n\t \n\toff = le32_to_cpu(rt->first_free);\n\te = Add2Ptr(rt, off);\n\n\tif (off == vbo) {\n\t\t \n\t\trt->first_free = *e;\n\t\tgoto skip_looking;\n\t}\n\n\t \n\tfor (;;) {\n\t\t \n\t\tu32 last_off = off;\n\t\t__le32 *last_e = e;\n\n\t\t \n\n\t\t \n\t\toff = le32_to_cpu(*last_e);\n\t\te = Add2Ptr(rt, off);\n\n\t\t \n\t\tif (off == vbo) {\n\t\t\t*last_e = *e;\n\n\t\t\t \n\t\t\tif (le32_to_cpu(rt->last_free) == off)\n\t\t\t\trt->last_free = cpu_to_le32(last_off);\n\t\t\tbreak;\n\t\t}\n\t}\n\nskip_looking:\n\t \n\tif (!rt->first_free)\n\t\trt->last_free = 0;\n\n\t \n\tmemset(e, 0, esize);\n\t*e = RESTART_ENTRY_ALLOCATED_LE;\n\n\tle16_add_cpu(&rt->total, 1);\n\n\treturn e;\n}\n\n#define RESTART_SINGLE_PAGE_IO cpu_to_le16(0x0001)\n\n#define NTFSLOG_WRAPPED 0x00000001\n#define NTFSLOG_MULTIPLE_PAGE_IO 0x00000002\n#define NTFSLOG_NO_LAST_LSN 0x00000004\n#define NTFSLOG_REUSE_TAIL 0x00000010\n#define NTFSLOG_NO_OLDEST_LSN 0x00000020\n\n \nstruct ntfs_log {\n\tstruct ntfs_inode *ni;\n\n\tu32 l_size;\n\tu32 sys_page_size;\n\tu32 sys_page_mask;\n\tu32 page_size;\n\tu32 page_mask; \n\tu8 page_bits;\n\tstruct RECORD_PAGE_HDR *one_page_buf;\n\n\tstruct RESTART_TABLE *open_attr_tbl;\n\tu32 transaction_id;\n\tu32 clst_per_page;\n\n\tu32 first_page;\n\tu32 next_page;\n\tu32 ra_off;\n\tu32 data_off;\n\tu32 restart_size;\n\tu32 data_size;\n\tu16 record_header_len;\n\tu64 seq_num;\n\tu32 seq_num_bits;\n\tu32 file_data_bits;\n\tu32 seq_num_mask;  \n\n\tstruct RESTART_AREA *ra;  \n\tu32 ra_size;  \n\n\t \n\tbool init_ra;\n\tbool set_dirty;  \n\n\tu64 oldest_lsn;\n\n\tu32 oldest_lsn_off;\n\tu64 last_lsn;\n\n\tu32 total_avail;\n\tu32 total_avail_pages;\n\tu32 total_undo_commit;\n\tu32 max_current_avail;\n\tu32 current_avail;\n\tu32 reserved;\n\n\tshort major_ver;\n\tshort minor_ver;\n\n\tu32 l_flags;  \n\tu32 current_openlog_count;  \n\n\tstruct CLIENT_ID client_id;\n\tu32 client_undo_commit;\n};\n\nstatic inline u32 lsn_to_vbo(struct ntfs_log *log, const u64 lsn)\n{\n\tu32 vbo = (lsn << log->seq_num_bits) >> (log->seq_num_bits - 3);\n\n\treturn vbo;\n}\n\n \nstatic inline u32 next_page_off(struct ntfs_log *log, u32 off)\n{\n\toff = (off & ~log->sys_page_mask) + log->page_size;\n\treturn off >= log->l_size ? log->first_page : off;\n}\n\nstatic inline u32 lsn_to_page_off(struct ntfs_log *log, u64 lsn)\n{\n\treturn (((u32)lsn) << 3) & log->page_mask;\n}\n\nstatic inline u64 vbo_to_lsn(struct ntfs_log *log, u32 off, u64 Seq)\n{\n\treturn (off >> 3) + (Seq << log->file_data_bits);\n}\n\nstatic inline bool is_lsn_in_file(struct ntfs_log *log, u64 lsn)\n{\n\treturn lsn >= log->oldest_lsn &&\n\t       lsn <= le64_to_cpu(log->ra->current_lsn);\n}\n\nstatic inline u32 hdr_file_off(struct ntfs_log *log,\n\t\t\t       struct RECORD_PAGE_HDR *hdr)\n{\n\tif (log->major_ver < 2)\n\t\treturn le64_to_cpu(hdr->rhdr.lsn);\n\n\treturn le32_to_cpu(hdr->file_off);\n}\n\nstatic inline u64 base_lsn(struct ntfs_log *log,\n\t\t\t   const struct RECORD_PAGE_HDR *hdr, u64 lsn)\n{\n\tu64 h_lsn = le64_to_cpu(hdr->rhdr.lsn);\n\tu64 ret = (((h_lsn >> log->file_data_bits) +\n\t\t    (lsn < (lsn_to_vbo(log, h_lsn) & ~log->page_mask) ? 1 : 0))\n\t\t   << log->file_data_bits) +\n\t\t  ((((is_log_record_end(hdr) &&\n\t\t      h_lsn <= le64_to_cpu(hdr->record_hdr.last_end_lsn)) ?\n\t\t\t     le16_to_cpu(hdr->record_hdr.next_record_off) :\n\t\t\t     log->page_size) +\n\t\t    lsn) >>\n\t\t   3);\n\n\treturn ret;\n}\n\nstatic inline bool verify_client_lsn(struct ntfs_log *log,\n\t\t\t\t     const struct CLIENT_REC *client, u64 lsn)\n{\n\treturn lsn >= le64_to_cpu(client->oldest_lsn) &&\n\t       lsn <= le64_to_cpu(log->ra->current_lsn) && lsn;\n}\n\nstruct restart_info {\n\tu64 last_lsn;\n\tstruct RESTART_HDR *r_page;\n\tu32 vbo;\n\tbool chkdsk_was_run;\n\tbool valid_page;\n\tbool initialized;\n\tbool restart;\n};\n\nstatic int read_log_page(struct ntfs_log *log, u32 vbo,\n\t\t\t struct RECORD_PAGE_HDR **buffer, bool *usa_error)\n{\n\tint err = 0;\n\tu32 page_idx = vbo >> log->page_bits;\n\tu32 page_off = vbo & log->page_mask;\n\tu32 bytes = log->page_size - page_off;\n\tvoid *to_free = NULL;\n\tu32 page_vbo = page_idx << log->page_bits;\n\tstruct RECORD_PAGE_HDR *page_buf;\n\tstruct ntfs_inode *ni = log->ni;\n\tbool bBAAD;\n\n\tif (vbo >= log->l_size)\n\t\treturn -EINVAL;\n\n\tif (!*buffer) {\n\t\tto_free = kmalloc(log->page_size, GFP_NOFS);\n\t\tif (!to_free)\n\t\t\treturn -ENOMEM;\n\t\t*buffer = to_free;\n\t}\n\n\tpage_buf = page_off ? log->one_page_buf : *buffer;\n\n\terr = ntfs_read_run_nb(ni->mi.sbi, &ni->file.run, page_vbo, page_buf,\n\t\t\t       log->page_size, NULL);\n\tif (err)\n\t\tgoto out;\n\n\tif (page_buf->rhdr.sign != NTFS_FFFF_SIGNATURE)\n\t\tntfs_fix_post_read(&page_buf->rhdr, PAGE_SIZE, false);\n\n\tif (page_buf != *buffer)\n\t\tmemcpy(*buffer, Add2Ptr(page_buf, page_off), bytes);\n\n\tbBAAD = page_buf->rhdr.sign == NTFS_BAAD_SIGNATURE;\n\n\tif (usa_error)\n\t\t*usa_error = bBAAD;\n\t \n\t \n\telse if (bBAAD)\n\t\terr = -EINVAL;\n\nout:\n\tif (err && to_free) {\n\t\tkfree(to_free);\n\t\t*buffer = NULL;\n\t}\n\n\treturn err;\n}\n\n \nstatic int log_read_rst(struct ntfs_log *log, u32 l_size, bool first,\n\t\t\tstruct restart_info *info)\n{\n\tu32 skip, vbo;\n\tstruct RESTART_HDR *r_page = NULL;\n\n\t \n\tif (first) {\n\t\tvbo = 0;\n\t\tskip = 512;\n\t} else {\n\t\tvbo = 512;\n\t\tskip = 0;\n\t}\n\n\t \n\tfor (; vbo < l_size; vbo = 2 * vbo + skip, skip = 0) {\n\t\tbool usa_error;\n\t\tbool brst, bchk;\n\t\tstruct RESTART_AREA *ra;\n\n\t\t \n\t\tif (read_log_page(log, vbo, (struct RECORD_PAGE_HDR **)&r_page,\n\t\t\t\t  &usa_error)) {\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (r_page->rhdr.sign == NTFS_RCRD_SIGNATURE) {\n\t\t\tinfo->initialized = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tbrst = r_page->rhdr.sign == NTFS_RSTR_SIGNATURE;\n\t\tbchk = r_page->rhdr.sign == NTFS_CHKD_SIGNATURE;\n\n\t\tif (!bchk && !brst) {\n\t\t\tif (r_page->rhdr.sign != NTFS_FFFF_SIGNATURE) {\n\t\t\t\t \n\t\t\t\tinfo->initialized = true;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tra = NULL;\n\t\tinfo->valid_page = false;\n\t\tinfo->initialized = true;\n\t\tinfo->vbo = vbo;\n\n\t\t \n\t\tif (!is_rst_page_hdr_valid(vbo, r_page))\n\t\t\tgoto check_result;\n\t\tra = Add2Ptr(r_page, le16_to_cpu(r_page->ra_off));\n\n\t\tif (!is_rst_area_valid(r_page))\n\t\t\tgoto check_result;\n\n\t\t \n\t\tif (bchk || ra->client_idx[1] == LFS_NO_CLIENT_LE) {\n\t\t\tinfo->valid_page = true;\n\t\t\tgoto check_result;\n\t\t}\n\n\t\tif (is_client_area_valid(r_page, usa_error)) {\n\t\t\tinfo->valid_page = true;\n\t\t\tra = Add2Ptr(r_page, le16_to_cpu(r_page->ra_off));\n\t\t}\n\ncheck_result:\n\t\t \n\t\tif (r_page->rhdr.sign == NTFS_CHKD_SIGNATURE) {\n\t\t\tinfo->chkdsk_was_run = true;\n\t\t\tinfo->last_lsn = le64_to_cpu(r_page->rhdr.lsn);\n\t\t\tinfo->restart = true;\n\t\t\tinfo->r_page = r_page;\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tif (info->valid_page) {\n\t\t\tinfo->last_lsn = le64_to_cpu(ra->current_lsn);\n\t\t\tinfo->restart = true;\n\t\t\tinfo->r_page = r_page;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tkfree(r_page);\n\n\treturn 0;\n}\n\n \nstatic void log_init_pg_hdr(struct ntfs_log *log, u32 sys_page_size,\n\t\t\t    u32 page_size, u16 major_ver, u16 minor_ver)\n{\n\tlog->sys_page_size = sys_page_size;\n\tlog->sys_page_mask = sys_page_size - 1;\n\tlog->page_size = page_size;\n\tlog->page_mask = page_size - 1;\n\tlog->page_bits = blksize_bits(page_size);\n\n\tlog->clst_per_page = log->page_size >> log->ni->mi.sbi->cluster_bits;\n\tif (!log->clst_per_page)\n\t\tlog->clst_per_page = 1;\n\n\tlog->first_page = major_ver >= 2 ?\n\t\t\t\t  0x22 * page_size :\n\t\t\t\t  ((sys_page_size << 1) + (page_size << 1));\n\tlog->major_ver = major_ver;\n\tlog->minor_ver = minor_ver;\n}\n\n \nstatic void log_create(struct ntfs_log *log, u32 l_size, const u64 last_lsn,\n\t\t       u32 open_log_count, bool wrapped, bool use_multi_page)\n{\n\tlog->l_size = l_size;\n\t \n\tlog->file_data_bits = blksize_bits(l_size) - 3;\n\tlog->seq_num_mask = (8 << log->file_data_bits) - 1;\n\tlog->seq_num_bits = sizeof(u64) * 8 - log->file_data_bits;\n\tlog->seq_num = (last_lsn >> log->file_data_bits) + 2;\n\tlog->next_page = log->first_page;\n\tlog->oldest_lsn = log->seq_num << log->file_data_bits;\n\tlog->oldest_lsn_off = 0;\n\tlog->last_lsn = log->oldest_lsn;\n\n\tlog->l_flags |= NTFSLOG_NO_LAST_LSN | NTFSLOG_NO_OLDEST_LSN;\n\n\t \n\tif (wrapped)\n\t\tlog->l_flags |= NTFSLOG_WRAPPED;\n\n\tif (use_multi_page)\n\t\tlog->l_flags |= NTFSLOG_MULTIPLE_PAGE_IO;\n\n\t \n\tlog->data_off = ALIGN(\n\t\toffsetof(struct RECORD_PAGE_HDR, fixups) +\n\t\t\tsizeof(short) * ((log->page_size >> SECTOR_SHIFT) + 1),\n\t\t8);\n\tlog->data_size = log->page_size - log->data_off;\n\tlog->record_header_len = sizeof(struct LFS_RECORD_HDR);\n\n\t \n\tlog->reserved = log->data_size - log->record_header_len;\n\n\t \n\tlog->ra_off = ALIGN(\n\t\toffsetof(struct RESTART_HDR, fixups) +\n\t\t\tsizeof(short) *\n\t\t\t\t((log->sys_page_size >> SECTOR_SHIFT) + 1),\n\t\t8);\n\tlog->restart_size = log->sys_page_size - log->ra_off;\n\tlog->ra_size = struct_size(log->ra, clients, 1);\n\tlog->current_openlog_count = open_log_count;\n\n\t \n\tlog->total_avail_pages = log->l_size - log->first_page;\n\tlog->total_avail = log->total_avail_pages >> log->page_bits;\n\n\t \n\tlog->max_current_avail = log->total_avail * log->reserved;\n\tlog->total_avail = log->total_avail * log->data_size;\n\tlog->current_avail = log->max_current_avail;\n}\n\n \nstatic struct RESTART_AREA *log_create_ra(struct ntfs_log *log)\n{\n\tstruct CLIENT_REC *cr;\n\tstruct RESTART_AREA *ra = kzalloc(log->restart_size, GFP_NOFS);\n\n\tif (!ra)\n\t\treturn NULL;\n\n\tra->current_lsn = cpu_to_le64(log->last_lsn);\n\tra->log_clients = cpu_to_le16(1);\n\tra->client_idx[1] = LFS_NO_CLIENT_LE;\n\tif (log->l_flags & NTFSLOG_MULTIPLE_PAGE_IO)\n\t\tra->flags = RESTART_SINGLE_PAGE_IO;\n\tra->seq_num_bits = cpu_to_le32(log->seq_num_bits);\n\tra->ra_len = cpu_to_le16(log->ra_size);\n\tra->client_off = cpu_to_le16(offsetof(struct RESTART_AREA, clients));\n\tra->l_size = cpu_to_le64(log->l_size);\n\tra->rec_hdr_len = cpu_to_le16(log->record_header_len);\n\tra->data_off = cpu_to_le16(log->data_off);\n\tra->open_log_count = cpu_to_le32(log->current_openlog_count + 1);\n\n\tcr = ra->clients;\n\n\tcr->prev_client = LFS_NO_CLIENT_LE;\n\tcr->next_client = LFS_NO_CLIENT_LE;\n\n\treturn ra;\n}\n\nstatic u32 final_log_off(struct ntfs_log *log, u64 lsn, u32 data_len)\n{\n\tu32 base_vbo = lsn << 3;\n\tu32 final_log_off = (base_vbo & log->seq_num_mask) & ~log->page_mask;\n\tu32 page_off = base_vbo & log->page_mask;\n\tu32 tail = log->page_size - page_off;\n\n\tpage_off -= 1;\n\n\t \n\tdata_len += log->record_header_len;\n\n\t \n\tif (data_len > tail) {\n\t\tdata_len -= tail;\n\t\ttail = log->data_size;\n\t\tpage_off = log->data_off - 1;\n\n\t\tfor (;;) {\n\t\t\tfinal_log_off = next_page_off(log, final_log_off);\n\n\t\t\t \n\t\t\tif (data_len <= tail)\n\t\t\t\tbreak;\n\t\t\tdata_len -= tail;\n\t\t}\n\t}\n\n\t \n\treturn final_log_off + data_len + page_off;\n}\n\nstatic int next_log_lsn(struct ntfs_log *log, const struct LFS_RECORD_HDR *rh,\n\t\t\tu64 *lsn)\n{\n\tint err;\n\tu64 this_lsn = le64_to_cpu(rh->this_lsn);\n\tu32 vbo = lsn_to_vbo(log, this_lsn);\n\tu32 end =\n\t\tfinal_log_off(log, this_lsn, le32_to_cpu(rh->client_data_len));\n\tu32 hdr_off = end & ~log->sys_page_mask;\n\tu64 seq = this_lsn >> log->file_data_bits;\n\tstruct RECORD_PAGE_HDR *page = NULL;\n\n\t \n\tif (end <= vbo)\n\t\tseq += 1;\n\n\t \n\terr = read_log_page(log, hdr_off, &page, NULL);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (this_lsn == le64_to_cpu(page->rhdr.lsn)) {\n\t\t \n\t\thdr_off = next_page_off(log, hdr_off);\n\t\tif (hdr_off == log->first_page)\n\t\t\tseq += 1;\n\n\t\tvbo = hdr_off + log->data_off;\n\t} else {\n\t\tvbo = ALIGN(end, 8);\n\t}\n\n\t \n\t*lsn = vbo_to_lsn(log, vbo, seq);\n\n\t \n\tif (!is_lsn_in_file(log, *lsn))\n\t\t*lsn = 0;\n\n\tkfree(page);\n\n\treturn 0;\n}\n\n \nstatic u32 current_log_avail(struct ntfs_log *log)\n{\n\tu32 oldest_off, next_free_off, free_bytes;\n\n\tif (log->l_flags & NTFSLOG_NO_LAST_LSN) {\n\t\t \n\t\treturn log->max_current_avail;\n\t}\n\n\t \n\toldest_off = (log->l_flags & NTFSLOG_NO_OLDEST_LSN) ?\n\t\t\t     log->first_page :\n\t\t\t     (log->oldest_lsn_off & ~log->sys_page_mask);\n\n\t \n\tnext_free_off = (log->l_flags & NTFSLOG_REUSE_TAIL) ?\n\t\t\t\tlog->next_page + log->page_size :\n\t\t\tlog->next_page == log->first_page ? log->l_size :\n\t\t\t\t\t\t\t    log->next_page;\n\n\t \n\tif (oldest_off == next_free_off)\n\t\treturn 0;\n\t \n\tfree_bytes =\n\t\toldest_off < next_free_off ?\n\t\t\tlog->total_avail_pages - (next_free_off - oldest_off) :\n\t\t\toldest_off - next_free_off;\n\n\tfree_bytes >>= log->page_bits;\n\treturn free_bytes * log->reserved;\n}\n\nstatic bool check_subseq_log_page(struct ntfs_log *log,\n\t\t\t\t  const struct RECORD_PAGE_HDR *rp, u32 vbo,\n\t\t\t\t  u64 seq)\n{\n\tu64 lsn_seq;\n\tconst struct NTFS_RECORD_HEADER *rhdr = &rp->rhdr;\n\tu64 lsn = le64_to_cpu(rhdr->lsn);\n\n\tif (rhdr->sign == NTFS_FFFF_SIGNATURE || !rhdr->sign)\n\t\treturn false;\n\n\t \n\tlsn_seq = lsn >> log->file_data_bits;\n\n\t \n\treturn lsn_seq >= seq ||\n\t       (lsn_seq == seq - 1 && log->first_page == vbo &&\n\t\tvbo != (lsn_to_vbo(log, lsn) & ~log->page_mask));\n}\n\n \nstatic int last_log_lsn(struct ntfs_log *log)\n{\n\tint err;\n\tbool usa_error = false;\n\tbool replace_page = false;\n\tbool reuse_page = log->l_flags & NTFSLOG_REUSE_TAIL;\n\tbool wrapped_file, wrapped;\n\n\tu32 page_cnt = 1, page_pos = 1;\n\tu32 page_off = 0, page_off1 = 0, saved_off = 0;\n\tu32 final_off, second_off, final_off_prev = 0, second_off_prev = 0;\n\tu32 first_file_off = 0, second_file_off = 0;\n\tu32 part_io_count = 0;\n\tu32 tails = 0;\n\tu32 this_off, curpage_off, nextpage_off, remain_pages;\n\n\tu64 expected_seq, seq_base = 0, lsn_base = 0;\n\tu64 best_lsn, best_lsn1, best_lsn2;\n\tu64 lsn_cur, lsn1, lsn2;\n\tu64 last_ok_lsn = reuse_page ? log->last_lsn : 0;\n\n\tu16 cur_pos, best_page_pos;\n\n\tstruct RECORD_PAGE_HDR *page = NULL;\n\tstruct RECORD_PAGE_HDR *tst_page = NULL;\n\tstruct RECORD_PAGE_HDR *first_tail = NULL;\n\tstruct RECORD_PAGE_HDR *second_tail = NULL;\n\tstruct RECORD_PAGE_HDR *tail_page = NULL;\n\tstruct RECORD_PAGE_HDR *second_tail_prev = NULL;\n\tstruct RECORD_PAGE_HDR *first_tail_prev = NULL;\n\tstruct RECORD_PAGE_HDR *page_bufs = NULL;\n\tstruct RECORD_PAGE_HDR *best_page;\n\n\tif (log->major_ver >= 2) {\n\t\tfinal_off = 0x02 * log->page_size;\n\t\tsecond_off = 0x12 * log->page_size;\n\n\t\t \n\t\tpage_bufs = kmalloc(log->page_size * 0x10, GFP_NOFS);\n\t\tif (!page_bufs)\n\t\t\treturn -ENOMEM;\n\t} else {\n\t\tsecond_off = log->first_page - log->page_size;\n\t\tfinal_off = second_off - log->page_size;\n\t}\n\nnext_tail:\n\t \n\tif (read_log_page(log, second_off, &second_tail, &usa_error) ||\n\t    usa_error || second_tail->rhdr.sign != NTFS_RCRD_SIGNATURE) {\n\t\tkfree(second_tail);\n\t\tsecond_tail = NULL;\n\t\tsecond_file_off = 0;\n\t\tlsn2 = 0;\n\t} else {\n\t\tsecond_file_off = hdr_file_off(log, second_tail);\n\t\tlsn2 = le64_to_cpu(second_tail->record_hdr.last_end_lsn);\n\t}\n\n\t \n\tif (read_log_page(log, final_off, &first_tail, &usa_error) ||\n\t    usa_error || first_tail->rhdr.sign != NTFS_RCRD_SIGNATURE) {\n\t\tkfree(first_tail);\n\t\tfirst_tail = NULL;\n\t\tfirst_file_off = 0;\n\t\tlsn1 = 0;\n\t} else {\n\t\tfirst_file_off = hdr_file_off(log, first_tail);\n\t\tlsn1 = le64_to_cpu(first_tail->record_hdr.last_end_lsn);\n\t}\n\n\tif (log->major_ver < 2) {\n\t\tint best_page;\n\n\t\tfirst_tail_prev = first_tail;\n\t\tfinal_off_prev = first_file_off;\n\t\tsecond_tail_prev = second_tail;\n\t\tsecond_off_prev = second_file_off;\n\t\ttails = 1;\n\n\t\tif (!first_tail && !second_tail)\n\t\t\tgoto tail_read;\n\n\t\tif (first_tail && second_tail)\n\t\t\tbest_page = lsn1 < lsn2 ? 1 : 0;\n\t\telse if (first_tail)\n\t\t\tbest_page = 0;\n\t\telse\n\t\t\tbest_page = 1;\n\n\t\tpage_off = best_page ? second_file_off : first_file_off;\n\t\tseq_base = (best_page ? lsn2 : lsn1) >> log->file_data_bits;\n\t\tgoto tail_read;\n\t}\n\n\tbest_lsn1 = first_tail ? base_lsn(log, first_tail, first_file_off) : 0;\n\tbest_lsn2 = second_tail ? base_lsn(log, second_tail, second_file_off) :\n\t\t\t\t  0;\n\n\tif (first_tail && second_tail) {\n\t\tif (best_lsn1 > best_lsn2) {\n\t\t\tbest_lsn = best_lsn1;\n\t\t\tbest_page = first_tail;\n\t\t\tthis_off = first_file_off;\n\t\t} else {\n\t\t\tbest_lsn = best_lsn2;\n\t\t\tbest_page = second_tail;\n\t\t\tthis_off = second_file_off;\n\t\t}\n\t} else if (first_tail) {\n\t\tbest_lsn = best_lsn1;\n\t\tbest_page = first_tail;\n\t\tthis_off = first_file_off;\n\t} else if (second_tail) {\n\t\tbest_lsn = best_lsn2;\n\t\tbest_page = second_tail;\n\t\tthis_off = second_file_off;\n\t} else {\n\t\tgoto tail_read;\n\t}\n\n\tbest_page_pos = le16_to_cpu(best_page->page_pos);\n\n\tif (!tails) {\n\t\tif (best_page_pos == page_pos) {\n\t\t\tseq_base = best_lsn >> log->file_data_bits;\n\t\t\tsaved_off = page_off = le32_to_cpu(best_page->file_off);\n\t\t\tlsn_base = best_lsn;\n\n\t\t\tmemmove(page_bufs, best_page, log->page_size);\n\n\t\t\tpage_cnt = le16_to_cpu(best_page->page_count);\n\t\t\tif (page_cnt > 1)\n\t\t\t\tpage_pos += 1;\n\n\t\t\ttails = 1;\n\t\t}\n\t} else if (seq_base == (best_lsn >> log->file_data_bits) &&\n\t\t   saved_off + log->page_size == this_off &&\n\t\t   lsn_base < best_lsn &&\n\t\t   (page_pos != page_cnt || best_page_pos == page_pos ||\n\t\t    best_page_pos == 1) &&\n\t\t   (page_pos >= page_cnt || best_page_pos == page_pos)) {\n\t\tu16 bppc = le16_to_cpu(best_page->page_count);\n\n\t\tsaved_off += log->page_size;\n\t\tlsn_base = best_lsn;\n\n\t\tmemmove(Add2Ptr(page_bufs, tails * log->page_size), best_page,\n\t\t\tlog->page_size);\n\n\t\ttails += 1;\n\n\t\tif (best_page_pos != bppc) {\n\t\t\tpage_cnt = bppc;\n\t\t\tpage_pos = best_page_pos;\n\n\t\t\tif (page_cnt > 1)\n\t\t\t\tpage_pos += 1;\n\t\t} else {\n\t\t\tpage_pos = page_cnt = 1;\n\t\t}\n\t} else {\n\t\tkfree(first_tail);\n\t\tkfree(second_tail);\n\t\tgoto tail_read;\n\t}\n\n\tkfree(first_tail_prev);\n\tfirst_tail_prev = first_tail;\n\tfinal_off_prev = first_file_off;\n\tfirst_tail = NULL;\n\n\tkfree(second_tail_prev);\n\tsecond_tail_prev = second_tail;\n\tsecond_off_prev = second_file_off;\n\tsecond_tail = NULL;\n\n\tfinal_off += log->page_size;\n\tsecond_off += log->page_size;\n\n\tif (tails < 0x10)\n\t\tgoto next_tail;\ntail_read:\n\tfirst_tail = first_tail_prev;\n\tfinal_off = final_off_prev;\n\n\tsecond_tail = second_tail_prev;\n\tsecond_off = second_off_prev;\n\n\tpage_cnt = page_pos = 1;\n\n\tcurpage_off = seq_base == log->seq_num ? min(log->next_page, page_off) :\n\t\t\t\t\t\t log->next_page;\n\n\twrapped_file =\n\t\tcurpage_off == log->first_page &&\n\t\t!(log->l_flags & (NTFSLOG_NO_LAST_LSN | NTFSLOG_REUSE_TAIL));\n\n\texpected_seq = wrapped_file ? (log->seq_num + 1) : log->seq_num;\n\n\tnextpage_off = curpage_off;\n\nnext_page:\n\ttail_page = NULL;\n\t \n\terr = read_log_page(log, curpage_off, &page, &usa_error);\n\n\t \n\tnextpage_off = next_page_off(log, curpage_off);\n\twrapped = nextpage_off == log->first_page;\n\n\tif (tails > 1) {\n\t\tstruct RECORD_PAGE_HDR *cur_page =\n\t\t\tAdd2Ptr(page_bufs, curpage_off - page_off);\n\n\t\tif (curpage_off == saved_off) {\n\t\t\ttail_page = cur_page;\n\t\t\tgoto use_tail_page;\n\t\t}\n\n\t\tif (page_off > curpage_off || curpage_off >= saved_off)\n\t\t\tgoto use_tail_page;\n\n\t\tif (page_off1)\n\t\t\tgoto use_cur_page;\n\n\t\tif (!err && !usa_error &&\n\t\t    page->rhdr.sign == NTFS_RCRD_SIGNATURE &&\n\t\t    cur_page->rhdr.lsn == page->rhdr.lsn &&\n\t\t    cur_page->record_hdr.next_record_off ==\n\t\t\t    page->record_hdr.next_record_off &&\n\t\t    ((page_pos == page_cnt &&\n\t\t      le16_to_cpu(page->page_pos) == 1) ||\n\t\t     (page_pos != page_cnt &&\n\t\t      le16_to_cpu(page->page_pos) == page_pos + 1 &&\n\t\t      le16_to_cpu(page->page_count) == page_cnt))) {\n\t\t\tcur_page = NULL;\n\t\t\tgoto use_tail_page;\n\t\t}\n\n\t\tpage_off1 = page_off;\n\nuse_cur_page:\n\n\t\tlsn_cur = le64_to_cpu(cur_page->rhdr.lsn);\n\n\t\tif (last_ok_lsn !=\n\t\t\t    le64_to_cpu(cur_page->record_hdr.last_end_lsn) &&\n\t\t    ((lsn_cur >> log->file_data_bits) +\n\t\t     ((curpage_off <\n\t\t       (lsn_to_vbo(log, lsn_cur) & ~log->page_mask)) ?\n\t\t\t      1 :\n\t\t\t      0)) != expected_seq) {\n\t\t\tgoto check_tail;\n\t\t}\n\n\t\tif (!is_log_record_end(cur_page)) {\n\t\t\ttail_page = NULL;\n\t\t\tlast_ok_lsn = lsn_cur;\n\t\t\tgoto next_page_1;\n\t\t}\n\n\t\tlog->seq_num = expected_seq;\n\t\tlog->l_flags &= ~NTFSLOG_NO_LAST_LSN;\n\t\tlog->last_lsn = le64_to_cpu(cur_page->record_hdr.last_end_lsn);\n\t\tlog->ra->current_lsn = cur_page->record_hdr.last_end_lsn;\n\n\t\tif (log->record_header_len <=\n\t\t    log->page_size -\n\t\t\t    le16_to_cpu(cur_page->record_hdr.next_record_off)) {\n\t\t\tlog->l_flags |= NTFSLOG_REUSE_TAIL;\n\t\t\tlog->next_page = curpage_off;\n\t\t} else {\n\t\t\tlog->l_flags &= ~NTFSLOG_REUSE_TAIL;\n\t\t\tlog->next_page = nextpage_off;\n\t\t}\n\n\t\tif (wrapped_file)\n\t\t\tlog->l_flags |= NTFSLOG_WRAPPED;\n\n\t\tlast_ok_lsn = le64_to_cpu(cur_page->record_hdr.last_end_lsn);\n\t\tgoto next_page_1;\n\t}\n\n\t \n\tif (page_cnt == page_pos || page_cnt == page_pos + 1) {\n\t\t \n\t\tif (curpage_off == final_off)\n\t\t\ttail_page = first_tail;\n\n\t\t \n\t\tif (curpage_off == second_off) {\n\t\t\tif (!tail_page ||\n\t\t\t    (second_tail &&\n\t\t\t     le64_to_cpu(second_tail->record_hdr.last_end_lsn) >\n\t\t\t\t     le64_to_cpu(first_tail->record_hdr\n\t\t\t\t\t\t\t .last_end_lsn))) {\n\t\t\t\ttail_page = second_tail;\n\t\t\t}\n\t\t}\n\t}\n\nuse_tail_page:\n\tif (tail_page) {\n\t\t \n\t\tlsn_cur = le64_to_cpu(tail_page->record_hdr.last_end_lsn);\n\n\t\tif (last_ok_lsn < lsn_cur) {\n\t\t\t \n\t\t\tif (expected_seq != (lsn_cur >> log->file_data_bits))\n\t\t\t\ttail_page = NULL;\n\t\t} else if (last_ok_lsn > lsn_cur) {\n\t\t\t \n\t\t\ttail_page = NULL;\n\t\t}\n\t}\n\n\t \n\tif (err || usa_error)\n\t\tgoto check_tail;\n\n\t \n\tlsn_cur = le64_to_cpu(page->rhdr.lsn);\n\tif (last_ok_lsn != lsn_cur &&\n\t    expected_seq != (lsn_cur >> log->file_data_bits)) {\n\t\tgoto check_tail;\n\t}\n\n\t \n\tif (page_cnt == page_pos) {\n\t\tif (page->page_pos != cpu_to_le16(1) &&\n\t\t    (!reuse_page || page->page_pos != page->page_count)) {\n\t\t\t \n\t\t\tgoto check_tail;\n\t\t}\n\t} else if (le16_to_cpu(page->page_count) != page_cnt ||\n\t\t   le16_to_cpu(page->page_pos) != page_pos + 1) {\n\t\t \n\t\tgoto check_tail;\n\t}\n\n\t \n\tif (tail_page &&\n\t    le64_to_cpu(tail_page->record_hdr.last_end_lsn) > lsn_cur) {\n\t\t \n\t\treplace_page = true;\n\t\tgoto check_tail;\n\t}\n\n\ttail_page = NULL;\n\n\tif (is_log_record_end(page)) {\n\t\t \n\t\tlog->seq_num = expected_seq;\n\t\tlog->last_lsn = le64_to_cpu(page->record_hdr.last_end_lsn);\n\t\tlog->ra->current_lsn = page->record_hdr.last_end_lsn;\n\t\tlog->l_flags &= ~NTFSLOG_NO_LAST_LSN;\n\n\t\t \n\t\tif (log->record_header_len <=\n\t\t    log->page_size -\n\t\t\t    le16_to_cpu(page->record_hdr.next_record_off)) {\n\t\t\tlog->l_flags |= NTFSLOG_REUSE_TAIL;\n\t\t\tlog->next_page = curpage_off;\n\t\t} else {\n\t\t\tlog->l_flags &= ~NTFSLOG_REUSE_TAIL;\n\t\t\tlog->next_page = nextpage_off;\n\t\t}\n\n\t\t \n\t\tif (wrapped_file)\n\t\t\tlog->l_flags |= NTFSLOG_WRAPPED;\n\t}\n\n\t \n\tpage_cnt = le16_to_cpu(page->page_count);\n\tpage_pos = le16_to_cpu(page->page_pos);\n\tlast_ok_lsn = le64_to_cpu(page->rhdr.lsn);\n\nnext_page_1:\n\n\tif (wrapped) {\n\t\texpected_seq += 1;\n\t\twrapped_file = 1;\n\t}\n\n\tcurpage_off = nextpage_off;\n\tkfree(page);\n\tpage = NULL;\n\treuse_page = 0;\n\tgoto next_page;\n\ncheck_tail:\n\tif (tail_page) {\n\t\tlog->seq_num = expected_seq;\n\t\tlog->last_lsn = le64_to_cpu(tail_page->record_hdr.last_end_lsn);\n\t\tlog->ra->current_lsn = tail_page->record_hdr.last_end_lsn;\n\t\tlog->l_flags &= ~NTFSLOG_NO_LAST_LSN;\n\n\t\tif (log->page_size -\n\t\t\t    le16_to_cpu(\n\t\t\t\t    tail_page->record_hdr.next_record_off) >=\n\t\t    log->record_header_len) {\n\t\t\tlog->l_flags |= NTFSLOG_REUSE_TAIL;\n\t\t\tlog->next_page = curpage_off;\n\t\t} else {\n\t\t\tlog->l_flags &= ~NTFSLOG_REUSE_TAIL;\n\t\t\tlog->next_page = nextpage_off;\n\t\t}\n\n\t\tif (wrapped)\n\t\t\tlog->l_flags |= NTFSLOG_WRAPPED;\n\t}\n\n\t \n\tsecond_off = nextpage_off;\n\n\t \n\tif (wrapped)\n\t\texpected_seq += 1;\n\n\t \n\tif (replace_page || (log->ra->flags & RESTART_SINGLE_PAGE_IO)) {\n\t\tpage_cnt = 2;\n\t\tpage_pos = 1;\n\t\tgoto check_valid;\n\t}\n\n\tif (page_pos != page_cnt)\n\t\tgoto check_valid;\n\t \n\tif (wrapped) {\n\t\tpage_cnt = 2;\n\t\tpage_pos = 1;\n\t\tgoto check_valid;\n\t}\n\n\tcur_pos = 2;\n\nnext_test_page:\n\tkfree(tst_page);\n\ttst_page = NULL;\n\n\t \n\terr = read_log_page(log, nextpage_off, &tst_page, &usa_error);\n\n\t \n\tif (usa_error)\n\t\tgoto file_is_valid;\n\n\t \n\tif (err)\n\t\tgoto next_test_page_1;\n\n\tif (le16_to_cpu(tst_page->page_pos) == cur_pos &&\n\t    check_subseq_log_page(log, tst_page, nextpage_off, expected_seq)) {\n\t\tpage_cnt = le16_to_cpu(tst_page->page_count) + 1;\n\t\tpage_pos = le16_to_cpu(tst_page->page_pos);\n\t\tgoto check_valid;\n\t} else {\n\t\tgoto file_is_valid;\n\t}\n\nnext_test_page_1:\n\n\tnextpage_off = next_page_off(log, curpage_off);\n\twrapped = nextpage_off == log->first_page;\n\n\tif (wrapped) {\n\t\texpected_seq += 1;\n\t\tpage_cnt = 2;\n\t\tpage_pos = 1;\n\t}\n\n\tcur_pos += 1;\n\tpart_io_count += 1;\n\tif (!wrapped)\n\t\tgoto next_test_page;\n\ncheck_valid:\n\t \n\tremain_pages = page_cnt - page_pos - 1;\n\tpart_io_count += remain_pages;\n\n\twhile (remain_pages--) {\n\t\tnextpage_off = next_page_off(log, curpage_off);\n\t\twrapped = nextpage_off == log->first_page;\n\n\t\tif (wrapped)\n\t\t\texpected_seq += 1;\n\t}\n\n\t \n\tkfree(tst_page);\n\ttst_page = NULL;\n\n\terr = read_log_page(log, nextpage_off, &tst_page, &usa_error);\n\tif (!err && !usa_error &&\n\t    check_subseq_log_page(log, tst_page, nextpage_off, expected_seq)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\nfile_is_valid:\n\n\t \n\tif (page_off1 || tail_page) {\n\t\tstruct RECORD_PAGE_HDR *tmp_page;\n\n\t\tif (sb_rdonly(log->ni->mi.sbi->sb)) {\n\t\t\terr = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (page_off1) {\n\t\t\ttmp_page = Add2Ptr(page_bufs, page_off1 - page_off);\n\t\t\ttails -= (page_off1 - page_off) / log->page_size;\n\t\t\tif (!tail_page)\n\t\t\t\ttails -= 1;\n\t\t} else {\n\t\t\ttmp_page = tail_page;\n\t\t\ttails = 1;\n\t\t}\n\n\t\twhile (tails--) {\n\t\t\tu64 off = hdr_file_off(log, tmp_page);\n\n\t\t\tif (!page) {\n\t\t\t\tpage = kmalloc(log->page_size, GFP_NOFS);\n\t\t\t\tif (!page) {\n\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tmemcpy(page, tmp_page, log->page_size);\n\n\t\t\t \n\t\t\tif (log->major_ver < 2)\n\t\t\t\tpage->rhdr.lsn = page->record_hdr.last_end_lsn;\n\t\t\telse\n\t\t\t\tpage->file_off = 0;\n\n\t\t\tpage->page_pos = page->page_count = cpu_to_le16(1);\n\n\t\t\tntfs_fix_pre_write(&page->rhdr, log->page_size);\n\n\t\t\terr = ntfs_sb_write_run(log->ni->mi.sbi,\n\t\t\t\t\t\t&log->ni->file.run, off, page,\n\t\t\t\t\t\tlog->page_size, 0);\n\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\tif (part_io_count && second_off == off) {\n\t\t\t\tsecond_off += log->page_size;\n\t\t\t\tpart_io_count -= 1;\n\t\t\t}\n\n\t\t\ttmp_page = Add2Ptr(tmp_page, log->page_size);\n\t\t}\n\t}\n\n\tif (part_io_count) {\n\t\tif (sb_rdonly(log->ni->mi.sbi->sb)) {\n\t\t\terr = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tkfree(second_tail);\n\tkfree(first_tail);\n\tkfree(page);\n\tkfree(tst_page);\n\tkfree(page_bufs);\n\n\treturn err;\n}\n\n \nstatic int read_log_rec_buf(struct ntfs_log *log,\n\t\t\t    const struct LFS_RECORD_HDR *rh, void *buffer)\n{\n\tint err;\n\tstruct RECORD_PAGE_HDR *ph = NULL;\n\tu64 lsn = le64_to_cpu(rh->this_lsn);\n\tu32 vbo = lsn_to_vbo(log, lsn) & ~log->page_mask;\n\tu32 off = lsn_to_page_off(log, lsn) + log->record_header_len;\n\tu32 data_len = le32_to_cpu(rh->client_data_len);\n\n\t \n\tfor (;;) {\n\t\tbool usa_error;\n\t\tu32 tail = log->page_size - off;\n\n\t\tif (tail >= data_len)\n\t\t\ttail = data_len;\n\n\t\tdata_len -= tail;\n\n\t\terr = read_log_page(log, vbo, &ph, &usa_error);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\t \n\t\tif (lsn > le64_to_cpu(ph->rhdr.lsn)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tmemcpy(buffer, Add2Ptr(ph, off), tail);\n\n\t\t \n\t\tif (!data_len) {\n\t\t\tif (!is_log_record_end(ph) ||\n\t\t\t    lsn > le64_to_cpu(ph->record_hdr.last_end_lsn)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ph->rhdr.lsn == ph->record_hdr.last_end_lsn ||\n\t\t    lsn > le64_to_cpu(ph->rhdr.lsn)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tvbo = next_page_off(log, vbo);\n\t\toff = log->data_off;\n\n\t\t \n\t\tbuffer = Add2Ptr(buffer, tail);\n\t}\n\nout:\n\tkfree(ph);\n\treturn err;\n}\n\nstatic int read_rst_area(struct ntfs_log *log, struct NTFS_RESTART **rst_,\n\t\t\t u64 *lsn)\n{\n\tint err;\n\tstruct LFS_RECORD_HDR *rh = NULL;\n\tconst struct CLIENT_REC *cr =\n\t\tAdd2Ptr(log->ra, le16_to_cpu(log->ra->client_off));\n\tu64 lsnr, lsnc = le64_to_cpu(cr->restart_lsn);\n\tu32 len;\n\tstruct NTFS_RESTART *rst;\n\n\t*lsn = 0;\n\t*rst_ = NULL;\n\n\t \n\tif (!lsnc)\n\t\treturn 0;\n\n\terr = read_log_page(log, lsn_to_vbo(log, lsnc),\n\t\t\t    (struct RECORD_PAGE_HDR **)&rh, NULL);\n\tif (err)\n\t\treturn err;\n\n\trst = NULL;\n\tlsnr = le64_to_cpu(rh->this_lsn);\n\n\tif (lsnc != lsnr) {\n\t\t \n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t*lsn = lsnr;\n\tlen = le32_to_cpu(rh->client_data_len);\n\n\tif (!len) {\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\tif (len < sizeof(struct NTFS_RESTART)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\trst = kmalloc(len, GFP_NOFS);\n\tif (!rst) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\terr = read_log_rec_buf(log, rh, rst);\n\tif (err)\n\t\tgoto out;\n\n\t*rst_ = rst;\n\trst = NULL;\n\nout:\n\tkfree(rh);\n\tkfree(rst);\n\n\treturn err;\n}\n\nstatic int find_log_rec(struct ntfs_log *log, u64 lsn, struct lcb *lcb)\n{\n\tint err;\n\tstruct LFS_RECORD_HDR *rh = lcb->lrh;\n\tu32 rec_len, len;\n\n\t \n\tif (!rh) {\n\t\terr = read_log_page(log, lsn_to_vbo(log, lsn),\n\t\t\t\t    (struct RECORD_PAGE_HDR **)&rh, NULL);\n\n\t\tlcb->lrh = rh;\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tif (lsn != le64_to_cpu(rh->this_lsn))\n\t\treturn -EINVAL;\n\n\tlen = le32_to_cpu(rh->client_data_len);\n\n\t \n\trec_len = len + log->record_header_len;\n\tif (rec_len >= log->total_avail)\n\t\treturn -EINVAL;\n\n\t \n\tif (rh->flags & LOG_RECORD_MULTI_PAGE) {\n\t\tvoid *lr = kmalloc(len, GFP_NOFS);\n\n\t\tif (!lr)\n\t\t\treturn -ENOMEM;\n\n\t\tlcb->log_rec = lr;\n\t\tlcb->alloc = true;\n\n\t\t \n\t\terr = read_log_rec_buf(log, rh, lr);\n\t\tif (err)\n\t\t\treturn err;\n\t} else {\n\t\t \n\t\tu32 page_off = lsn_to_page_off(log, lsn);\n\n\t\tif (page_off + len + log->record_header_len > log->page_size)\n\t\t\treturn -EINVAL;\n\n\t\tlcb->log_rec = Add2Ptr(rh, sizeof(struct LFS_RECORD_HDR));\n\t\tlcb->alloc = false;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int read_log_rec_lcb(struct ntfs_log *log, u64 lsn, u32 ctx_mode,\n\t\t\t    struct lcb **lcb_)\n{\n\tint err;\n\tconst struct CLIENT_REC *cr;\n\tstruct lcb *lcb;\n\n\tswitch (ctx_mode) {\n\tcase lcb_ctx_undo_next:\n\tcase lcb_ctx_prev:\n\tcase lcb_ctx_next:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tcr = Add2Ptr(log->ra, le16_to_cpu(log->ra->client_off));\n\n\tif (!verify_client_lsn(log, cr, lsn))\n\t\treturn -EINVAL;\n\n\tlcb = kzalloc(sizeof(struct lcb), GFP_NOFS);\n\tif (!lcb)\n\t\treturn -ENOMEM;\n\tlcb->client = log->client_id;\n\tlcb->ctx_mode = ctx_mode;\n\n\t \n\terr = find_log_rec(log, lsn, lcb);\n\tif (err)\n\t\tgoto out;\n\n\t*lcb_ = lcb;\n\treturn 0;\n\nout:\n\tlcb_put(lcb);\n\t*lcb_ = NULL;\n\treturn err;\n}\n\n \nstatic int find_client_next_lsn(struct ntfs_log *log, struct lcb *lcb, u64 *lsn)\n{\n\tint err;\n\tu64 next_lsn;\n\tstruct LFS_RECORD_HDR *hdr;\n\n\thdr = lcb->lrh;\n\t*lsn = 0;\n\n\tif (lcb_ctx_next != lcb->ctx_mode)\n\t\tgoto check_undo_next;\n\n\t \n\tfor (;;) {\n\t\tu64 current_lsn;\n\n\t\terr = next_log_lsn(log, hdr, &current_lsn);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tif (!current_lsn)\n\t\t\tbreak;\n\n\t\tif (hdr != lcb->lrh)\n\t\t\tkfree(hdr);\n\n\t\thdr = NULL;\n\t\terr = read_log_page(log, lsn_to_vbo(log, current_lsn),\n\t\t\t\t    (struct RECORD_PAGE_HDR **)&hdr, NULL);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tif (memcmp(&hdr->client, &lcb->client,\n\t\t\t   sizeof(struct CLIENT_ID))) {\n\t\t\t \n\t\t} else if (LfsClientRecord == hdr->record_type) {\n\t\t\tkfree(lcb->lrh);\n\t\t\tlcb->lrh = hdr;\n\t\t\t*lsn = current_lsn;\n\t\t\treturn 0;\n\t\t}\n\t}\n\nout:\n\tif (hdr != lcb->lrh)\n\t\tkfree(hdr);\n\treturn err;\n\ncheck_undo_next:\n\tif (lcb_ctx_undo_next == lcb->ctx_mode)\n\t\tnext_lsn = le64_to_cpu(hdr->client_undo_next_lsn);\n\telse if (lcb_ctx_prev == lcb->ctx_mode)\n\t\tnext_lsn = le64_to_cpu(hdr->client_prev_lsn);\n\telse\n\t\treturn 0;\n\n\tif (!next_lsn)\n\t\treturn 0;\n\n\tif (!verify_client_lsn(\n\t\t    log, Add2Ptr(log->ra, le16_to_cpu(log->ra->client_off)),\n\t\t    next_lsn))\n\t\treturn 0;\n\n\thdr = NULL;\n\terr = read_log_page(log, lsn_to_vbo(log, next_lsn),\n\t\t\t    (struct RECORD_PAGE_HDR **)&hdr, NULL);\n\tif (err)\n\t\treturn err;\n\tkfree(lcb->lrh);\n\tlcb->lrh = hdr;\n\n\t*lsn = next_lsn;\n\n\treturn 0;\n}\n\nstatic int read_next_log_rec(struct ntfs_log *log, struct lcb *lcb, u64 *lsn)\n{\n\tint err;\n\n\terr = find_client_next_lsn(log, lcb, lsn);\n\tif (err)\n\t\treturn err;\n\n\tif (!*lsn)\n\t\treturn 0;\n\n\tif (lcb->alloc)\n\t\tkfree(lcb->log_rec);\n\n\tlcb->log_rec = NULL;\n\tlcb->alloc = false;\n\tkfree(lcb->lrh);\n\tlcb->lrh = NULL;\n\n\treturn find_log_rec(log, *lsn, lcb);\n}\n\nbool check_index_header(const struct INDEX_HDR *hdr, size_t bytes)\n{\n\t__le16 mask;\n\tu32 min_de, de_off, used, total;\n\tconst struct NTFS_DE *e;\n\n\tif (hdr_has_subnode(hdr)) {\n\t\tmin_de = sizeof(struct NTFS_DE) + sizeof(u64);\n\t\tmask = NTFS_IE_HAS_SUBNODES;\n\t} else {\n\t\tmin_de = sizeof(struct NTFS_DE);\n\t\tmask = 0;\n\t}\n\n\tde_off = le32_to_cpu(hdr->de_off);\n\tused = le32_to_cpu(hdr->used);\n\ttotal = le32_to_cpu(hdr->total);\n\n\tif (de_off > bytes - min_de || used > bytes || total > bytes ||\n\t    de_off + min_de > used || used > total) {\n\t\treturn false;\n\t}\n\n\te = Add2Ptr(hdr, de_off);\n\tfor (;;) {\n\t\tu16 esize = le16_to_cpu(e->size);\n\t\tstruct NTFS_DE *next = Add2Ptr(e, esize);\n\n\t\tif (esize < min_de || PtrOffset(hdr, next) > used ||\n\t\t    (e->flags & NTFS_IE_HAS_SUBNODES) != mask) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (de_is_last(e))\n\t\t\tbreak;\n\n\t\te = next;\n\t}\n\n\treturn true;\n}\n\nstatic inline bool check_index_buffer(const struct INDEX_BUFFER *ib, u32 bytes)\n{\n\tu16 fo;\n\tconst struct NTFS_RECORD_HEADER *r = &ib->rhdr;\n\n\tif (r->sign != NTFS_INDX_SIGNATURE)\n\t\treturn false;\n\n\tfo = (SECTOR_SIZE - ((bytes >> SECTOR_SHIFT) + 1) * sizeof(short));\n\n\tif (le16_to_cpu(r->fix_off) > fo)\n\t\treturn false;\n\n\tif ((le16_to_cpu(r->fix_num) - 1) * SECTOR_SIZE != bytes)\n\t\treturn false;\n\n\treturn check_index_header(&ib->ihdr,\n\t\t\t\t  bytes - offsetof(struct INDEX_BUFFER, ihdr));\n}\n\nstatic inline bool check_index_root(const struct ATTRIB *attr,\n\t\t\t\t    struct ntfs_sb_info *sbi)\n{\n\tbool ret;\n\tconst struct INDEX_ROOT *root = resident_data(attr);\n\tu8 index_bits = le32_to_cpu(root->index_block_size) >=\n\t\t\t\t\tsbi->cluster_size ?\n\t\t\t\tsbi->cluster_bits :\n\t\t\t\tSECTOR_SHIFT;\n\tu8 block_clst = root->index_block_clst;\n\n\tif (le32_to_cpu(attr->res.data_size) < sizeof(struct INDEX_ROOT) ||\n\t    (root->type != ATTR_NAME && root->type != ATTR_ZERO) ||\n\t    (root->type == ATTR_NAME &&\n\t     root->rule != NTFS_COLLATION_TYPE_FILENAME) ||\n\t    (le32_to_cpu(root->index_block_size) !=\n\t     (block_clst << index_bits)) ||\n\t    (block_clst != 1 && block_clst != 2 && block_clst != 4 &&\n\t     block_clst != 8 && block_clst != 0x10 && block_clst != 0x20 &&\n\t     block_clst != 0x40 && block_clst != 0x80)) {\n\t\treturn false;\n\t}\n\n\tret = check_index_header(&root->ihdr,\n\t\t\t\t le32_to_cpu(attr->res.data_size) -\n\t\t\t\t\t offsetof(struct INDEX_ROOT, ihdr));\n\treturn ret;\n}\n\nstatic inline bool check_attr(const struct MFT_REC *rec,\n\t\t\t      const struct ATTRIB *attr,\n\t\t\t      struct ntfs_sb_info *sbi)\n{\n\tu32 asize = le32_to_cpu(attr->size);\n\tu32 rsize = 0;\n\tu64 dsize, svcn, evcn;\n\tu16 run_off;\n\n\t \n\tif (asize >= sbi->record_size ||\n\t    asize + PtrOffset(rec, attr) >= sbi->record_size ||\n\t    (attr->name_len &&\n\t     le16_to_cpu(attr->name_off) + attr->name_len * sizeof(short) >\n\t\t     asize)) {\n\t\treturn false;\n\t}\n\n\t \n\tswitch (attr->non_res) {\n\tcase 0:\n\t\trsize = le32_to_cpu(attr->res.data_size);\n\t\tif (rsize >= asize ||\n\t\t    le16_to_cpu(attr->res.data_off) + rsize > asize) {\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\n\tcase 1:\n\t\tdsize = le64_to_cpu(attr->nres.data_size);\n\t\tsvcn = le64_to_cpu(attr->nres.svcn);\n\t\tevcn = le64_to_cpu(attr->nres.evcn);\n\t\trun_off = le16_to_cpu(attr->nres.run_off);\n\n\t\tif (svcn > evcn + 1 || run_off >= asize ||\n\t\t    le64_to_cpu(attr->nres.valid_size) > dsize ||\n\t\t    dsize > le64_to_cpu(attr->nres.alloc_size)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (run_off > asize)\n\t\t\treturn false;\n\n\t\tif (run_unpack(NULL, sbi, 0, svcn, evcn, svcn,\n\t\t\t       Add2Ptr(attr, run_off), asize - run_off) < 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\n\tdefault:\n\t\treturn false;\n\t}\n\n\tswitch (attr->type) {\n\tcase ATTR_NAME:\n\t\tif (fname_full_size(Add2Ptr(\n\t\t\t    attr, le16_to_cpu(attr->res.data_off))) > asize) {\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\n\tcase ATTR_ROOT:\n\t\treturn check_index_root(attr, sbi);\n\n\tcase ATTR_STD:\n\t\tif (rsize < sizeof(struct ATTR_STD_INFO5) &&\n\t\t    rsize != sizeof(struct ATTR_STD_INFO)) {\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\n\tcase ATTR_LIST:\n\tcase ATTR_ID:\n\tcase ATTR_SECURE:\n\tcase ATTR_LABEL:\n\tcase ATTR_VOL_INFO:\n\tcase ATTR_DATA:\n\tcase ATTR_ALLOC:\n\tcase ATTR_BITMAP:\n\tcase ATTR_REPARSE:\n\tcase ATTR_EA_INFO:\n\tcase ATTR_EA:\n\tcase ATTR_PROPERTYSET:\n\tcase ATTR_LOGGED_UTILITY_STREAM:\n\t\tbreak;\n\n\tdefault:\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic inline bool check_file_record(const struct MFT_REC *rec,\n\t\t\t\t     const struct MFT_REC *rec2,\n\t\t\t\t     struct ntfs_sb_info *sbi)\n{\n\tconst struct ATTRIB *attr;\n\tu16 fo = le16_to_cpu(rec->rhdr.fix_off);\n\tu16 fn = le16_to_cpu(rec->rhdr.fix_num);\n\tu16 ao = le16_to_cpu(rec->attr_off);\n\tu32 rs = sbi->record_size;\n\n\t \n\tif (rec->rhdr.sign != NTFS_FILE_SIGNATURE ||\n\t    fo > (SECTOR_SIZE - ((rs >> SECTOR_SHIFT) + 1) * sizeof(short)) ||\n\t    (fn - 1) * SECTOR_SIZE != rs || ao < MFTRECORD_FIXUP_OFFSET_1 ||\n\t    ao > sbi->record_size - SIZEOF_RESIDENT || !is_rec_inuse(rec) ||\n\t    le32_to_cpu(rec->total) != rs) {\n\t\treturn false;\n\t}\n\n\t \n\tfor (attr = Add2Ptr(rec, ao); attr->type != ATTR_END;\n\t     attr = Add2Ptr(attr, le32_to_cpu(attr->size))) {\n\t\tif (check_attr(rec, attr, sbi))\n\t\t\tcontinue;\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic inline int check_lsn(const struct NTFS_RECORD_HEADER *hdr,\n\t\t\t    const u64 *rlsn)\n{\n\tu64 lsn;\n\n\tif (!rlsn)\n\t\treturn true;\n\n\tlsn = le64_to_cpu(hdr->lsn);\n\n\tif (hdr->sign == NTFS_HOLE_SIGNATURE)\n\t\treturn false;\n\n\tif (*rlsn > lsn)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic inline bool check_if_attr(const struct MFT_REC *rec,\n\t\t\t\t const struct LOG_REC_HDR *lrh)\n{\n\tu16 ro = le16_to_cpu(lrh->record_off);\n\tu16 o = le16_to_cpu(rec->attr_off);\n\tconst struct ATTRIB *attr = Add2Ptr(rec, o);\n\n\twhile (o < ro) {\n\t\tu32 asize;\n\n\t\tif (attr->type == ATTR_END)\n\t\t\tbreak;\n\n\t\tasize = le32_to_cpu(attr->size);\n\t\tif (!asize)\n\t\t\tbreak;\n\n\t\to += asize;\n\t\tattr = Add2Ptr(attr, asize);\n\t}\n\n\treturn o == ro;\n}\n\nstatic inline bool check_if_index_root(const struct MFT_REC *rec,\n\t\t\t\t       const struct LOG_REC_HDR *lrh)\n{\n\tu16 ro = le16_to_cpu(lrh->record_off);\n\tu16 o = le16_to_cpu(rec->attr_off);\n\tconst struct ATTRIB *attr = Add2Ptr(rec, o);\n\n\twhile (o < ro) {\n\t\tu32 asize;\n\n\t\tif (attr->type == ATTR_END)\n\t\t\tbreak;\n\n\t\tasize = le32_to_cpu(attr->size);\n\t\tif (!asize)\n\t\t\tbreak;\n\n\t\to += asize;\n\t\tattr = Add2Ptr(attr, asize);\n\t}\n\n\treturn o == ro && attr->type == ATTR_ROOT;\n}\n\nstatic inline bool check_if_root_index(const struct ATTRIB *attr,\n\t\t\t\t       const struct INDEX_HDR *hdr,\n\t\t\t\t       const struct LOG_REC_HDR *lrh)\n{\n\tu16 ao = le16_to_cpu(lrh->attr_off);\n\tu32 de_off = le32_to_cpu(hdr->de_off);\n\tu32 o = PtrOffset(attr, hdr) + de_off;\n\tconst struct NTFS_DE *e = Add2Ptr(hdr, de_off);\n\tu32 asize = le32_to_cpu(attr->size);\n\n\twhile (o < ao) {\n\t\tu16 esize;\n\n\t\tif (o >= asize)\n\t\t\tbreak;\n\n\t\tesize = le16_to_cpu(e->size);\n\t\tif (!esize)\n\t\t\tbreak;\n\n\t\to += esize;\n\t\te = Add2Ptr(e, esize);\n\t}\n\n\treturn o == ao;\n}\n\nstatic inline bool check_if_alloc_index(const struct INDEX_HDR *hdr,\n\t\t\t\t\tu32 attr_off)\n{\n\tu32 de_off = le32_to_cpu(hdr->de_off);\n\tu32 o = offsetof(struct INDEX_BUFFER, ihdr) + de_off;\n\tconst struct NTFS_DE *e = Add2Ptr(hdr, de_off);\n\tu32 used = le32_to_cpu(hdr->used);\n\n\twhile (o < attr_off) {\n\t\tu16 esize;\n\n\t\tif (de_off >= used)\n\t\t\tbreak;\n\n\t\tesize = le16_to_cpu(e->size);\n\t\tif (!esize)\n\t\t\tbreak;\n\n\t\to += esize;\n\t\tde_off += esize;\n\t\te = Add2Ptr(e, esize);\n\t}\n\n\treturn o == attr_off;\n}\n\nstatic inline void change_attr_size(struct MFT_REC *rec, struct ATTRIB *attr,\n\t\t\t\t    u32 nsize)\n{\n\tu32 asize = le32_to_cpu(attr->size);\n\tint dsize = nsize - asize;\n\tu8 *next = Add2Ptr(attr, asize);\n\tu32 used = le32_to_cpu(rec->used);\n\n\tmemmove(Add2Ptr(attr, nsize), next, used - PtrOffset(rec, next));\n\n\trec->used = cpu_to_le32(used + dsize);\n\tattr->size = cpu_to_le32(nsize);\n}\n\nstruct OpenAttr {\n\tstruct ATTRIB *attr;\n\tstruct runs_tree *run1;\n\tstruct runs_tree run0;\n\tstruct ntfs_inode *ni;\n\t \n};\n\n \nstatic inline int cmp_type_and_name(const struct ATTRIB *a1,\n\t\t\t\t    const struct ATTRIB *a2)\n{\n\treturn a1->type != a2->type || a1->name_len != a2->name_len ||\n\t       (a1->name_len && memcmp(attr_name(a1), attr_name(a2),\n\t\t\t\t       a1->name_len * sizeof(short)));\n}\n\nstatic struct OpenAttr *find_loaded_attr(struct ntfs_log *log,\n\t\t\t\t\t const struct ATTRIB *attr, CLST rno)\n{\n\tstruct OPEN_ATTR_ENRTY *oe = NULL;\n\n\twhile ((oe = enum_rstbl(log->open_attr_tbl, oe))) {\n\t\tstruct OpenAttr *op_attr;\n\n\t\tif (ino_get(&oe->ref) != rno)\n\t\t\tcontinue;\n\n\t\top_attr = (struct OpenAttr *)oe->ptr;\n\t\tif (!cmp_type_and_name(op_attr->attr, attr))\n\t\t\treturn op_attr;\n\t}\n\treturn NULL;\n}\n\nstatic struct ATTRIB *attr_create_nonres_log(struct ntfs_sb_info *sbi,\n\t\t\t\t\t     enum ATTR_TYPE type, u64 size,\n\t\t\t\t\t     const u16 *name, size_t name_len,\n\t\t\t\t\t     __le16 flags)\n{\n\tstruct ATTRIB *attr;\n\tu32 name_size = ALIGN(name_len * sizeof(short), 8);\n\tbool is_ext = flags & (ATTR_FLAG_COMPRESSED | ATTR_FLAG_SPARSED);\n\tu32 asize = name_size +\n\t\t    (is_ext ? SIZEOF_NONRESIDENT_EX : SIZEOF_NONRESIDENT);\n\n\tattr = kzalloc(asize, GFP_NOFS);\n\tif (!attr)\n\t\treturn NULL;\n\n\tattr->type = type;\n\tattr->size = cpu_to_le32(asize);\n\tattr->flags = flags;\n\tattr->non_res = 1;\n\tattr->name_len = name_len;\n\n\tattr->nres.evcn = cpu_to_le64((u64)bytes_to_cluster(sbi, size) - 1);\n\tattr->nres.alloc_size = cpu_to_le64(ntfs_up_cluster(sbi, size));\n\tattr->nres.data_size = cpu_to_le64(size);\n\tattr->nres.valid_size = attr->nres.data_size;\n\tif (is_ext) {\n\t\tattr->name_off = SIZEOF_NONRESIDENT_EX_LE;\n\t\tif (is_attr_compressed(attr))\n\t\t\tattr->nres.c_unit = COMPRESSION_UNIT;\n\n\t\tattr->nres.run_off =\n\t\t\tcpu_to_le16(SIZEOF_NONRESIDENT_EX + name_size);\n\t\tmemcpy(Add2Ptr(attr, SIZEOF_NONRESIDENT_EX), name,\n\t\t       name_len * sizeof(short));\n\t} else {\n\t\tattr->name_off = SIZEOF_NONRESIDENT_LE;\n\t\tattr->nres.run_off =\n\t\t\tcpu_to_le16(SIZEOF_NONRESIDENT + name_size);\n\t\tmemcpy(Add2Ptr(attr, SIZEOF_NONRESIDENT), name,\n\t\t       name_len * sizeof(short));\n\t}\n\n\treturn attr;\n}\n\n \nstatic int do_action(struct ntfs_log *log, struct OPEN_ATTR_ENRTY *oe,\n\t\t     const struct LOG_REC_HDR *lrh, u32 op, void *data,\n\t\t     u32 dlen, u32 rec_len, const u64 *rlsn)\n{\n\tint err = 0;\n\tstruct ntfs_sb_info *sbi = log->ni->mi.sbi;\n\tstruct inode *inode = NULL, *inode_parent;\n\tstruct mft_inode *mi = NULL, *mi2_child = NULL;\n\tCLST rno = 0, rno_base = 0;\n\tstruct INDEX_BUFFER *ib = NULL;\n\tstruct MFT_REC *rec = NULL;\n\tstruct ATTRIB *attr = NULL, *attr2;\n\tstruct INDEX_HDR *hdr;\n\tstruct INDEX_ROOT *root;\n\tstruct NTFS_DE *e, *e1, *e2;\n\tstruct NEW_ATTRIBUTE_SIZES *new_sz;\n\tstruct ATTR_FILE_NAME *fname;\n\tstruct OpenAttr *oa, *oa2;\n\tu32 nsize, t32, asize, used, esize, off, bits;\n\tu16 id, id2;\n\tu32 record_size = sbi->record_size;\n\tu64 t64;\n\tu16 roff = le16_to_cpu(lrh->record_off);\n\tu16 aoff = le16_to_cpu(lrh->attr_off);\n\tu64 lco = 0;\n\tu64 cbo = (u64)le16_to_cpu(lrh->cluster_off) << SECTOR_SHIFT;\n\tu64 tvo = le64_to_cpu(lrh->target_vcn) << sbi->cluster_bits;\n\tu64 vbo = cbo + tvo;\n\tvoid *buffer_le = NULL;\n\tu32 bytes = 0;\n\tbool a_dirty = false;\n\tu16 data_off;\n\n\toa = oe->ptr;\n\n\t \n\tswitch (op) {\n\t \n\tcase InitializeFileRecordSegment:\n\tcase DeallocateFileRecordSegment:\n\tcase WriteEndOfFileRecordSegment:\n\tcase CreateAttribute:\n\tcase DeleteAttribute:\n\tcase UpdateResidentValue:\n\tcase UpdateMappingPairs:\n\tcase SetNewAttributeSizes:\n\tcase AddIndexEntryRoot:\n\tcase DeleteIndexEntryRoot:\n\tcase SetIndexEntryVcnRoot:\n\tcase UpdateFileNameRoot:\n\tcase UpdateRecordDataRoot:\n\tcase ZeroEndOfFileRecord:\n\t\trno = vbo >> sbi->record_bits;\n\t\tinode = ilookup(sbi->sb, rno);\n\t\tif (inode) {\n\t\t\tmi = &ntfs_i(inode)->mi;\n\t\t} else if (op == InitializeFileRecordSegment) {\n\t\t\tmi = kzalloc(sizeof(struct mft_inode), GFP_NOFS);\n\t\t\tif (!mi)\n\t\t\t\treturn -ENOMEM;\n\t\t\terr = mi_format_new(mi, sbi, rno, 0, false);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\t \n\t\t\terr = mi_get(sbi, rno, &mi);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\trec = mi->mrec;\n\n\t\tif (op == DeallocateFileRecordSegment)\n\t\t\tgoto skip_load_parent;\n\n\t\tif (InitializeFileRecordSegment != op) {\n\t\t\tif (rec->rhdr.sign == NTFS_BAAD_SIGNATURE)\n\t\t\t\tgoto dirty_vol;\n\t\t\tif (!check_lsn(&rec->rhdr, rlsn))\n\t\t\t\tgoto out;\n\t\t\tif (!check_file_record(rec, NULL, sbi))\n\t\t\t\tgoto dirty_vol;\n\t\t\tattr = Add2Ptr(rec, roff);\n\t\t}\n\n\t\tif (is_rec_base(rec) || InitializeFileRecordSegment == op) {\n\t\t\trno_base = rno;\n\t\t\tgoto skip_load_parent;\n\t\t}\n\n\t\trno_base = ino_get(&rec->parent_ref);\n\t\tinode_parent = ntfs_iget5(sbi->sb, &rec->parent_ref, NULL);\n\t\tif (IS_ERR(inode_parent))\n\t\t\tgoto skip_load_parent;\n\n\t\tif (is_bad_inode(inode_parent)) {\n\t\t\tiput(inode_parent);\n\t\t\tgoto skip_load_parent;\n\t\t}\n\n\t\tif (ni_load_mi_ex(ntfs_i(inode_parent), rno, &mi2_child)) {\n\t\t\tiput(inode_parent);\n\t\t} else {\n\t\t\tif (mi2_child->mrec != mi->mrec)\n\t\t\t\tmemcpy(mi2_child->mrec, mi->mrec,\n\t\t\t\t       sbi->record_size);\n\n\t\t\tif (inode)\n\t\t\t\tiput(inode);\n\t\t\telse if (mi)\n\t\t\t\tmi_put(mi);\n\n\t\t\tinode = inode_parent;\n\t\t\tmi = mi2_child;\n\t\t\trec = mi2_child->mrec;\n\t\t\tattr = Add2Ptr(rec, roff);\n\t\t}\n\nskip_load_parent:\n\t\tinode_parent = NULL;\n\t\tbreak;\n\n\t \n\tcase UpdateNonresidentValue:\n\tcase AddIndexEntryAllocation:\n\tcase DeleteIndexEntryAllocation:\n\tcase WriteEndOfIndexBuffer:\n\tcase SetIndexEntryVcnAllocation:\n\tcase UpdateFileNameAllocation:\n\tcase SetBitsInNonresidentBitMap:\n\tcase ClearBitsInNonresidentBitMap:\n\tcase UpdateRecordDataAllocation:\n\t\tattr = oa->attr;\n\t\tbytes = UpdateNonresidentValue == op ? dlen : 0;\n\t\tlco = (u64)le16_to_cpu(lrh->lcns_follow) << sbi->cluster_bits;\n\n\t\tif (attr->type == ATTR_ALLOC) {\n\t\t\tt32 = le32_to_cpu(oe->bytes_per_index);\n\t\t\tif (bytes < t32)\n\t\t\t\tbytes = t32;\n\t\t}\n\n\t\tif (!bytes)\n\t\t\tbytes = lco - cbo;\n\n\t\tbytes += roff;\n\t\tif (attr->type == ATTR_ALLOC)\n\t\t\tbytes = (bytes + 511) & ~511;  \n\n\t\tbuffer_le = kmalloc(bytes, GFP_NOFS);\n\t\tif (!buffer_le)\n\t\t\treturn -ENOMEM;\n\n\t\terr = ntfs_read_run_nb(sbi, oa->run1, vbo, buffer_le, bytes,\n\t\t\t\t       NULL);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tif (attr->type == ATTR_ALLOC && *(int *)buffer_le)\n\t\t\tntfs_fix_post_read(buffer_le, bytes, false);\n\t\tbreak;\n\n\tdefault:\n\t\tWARN_ON(1);\n\t}\n\n\t \n\tswitch (op) {\n\tcase InitializeFileRecordSegment:\n\t\tif (roff + dlen > record_size)\n\t\t\tgoto dirty_vol;\n\n\t\tmemcpy(Add2Ptr(rec, roff), data, dlen);\n\t\tmi->dirty = true;\n\t\tbreak;\n\n\tcase DeallocateFileRecordSegment:\n\t\tclear_rec_inuse(rec);\n\t\tle16_add_cpu(&rec->seq, 1);\n\t\tmi->dirty = true;\n\t\tbreak;\n\n\tcase WriteEndOfFileRecordSegment:\n\t\tattr2 = (struct ATTRIB *)data;\n\t\tif (!check_if_attr(rec, lrh) || roff + dlen > record_size)\n\t\t\tgoto dirty_vol;\n\n\t\tmemmove(attr, attr2, dlen);\n\t\trec->used = cpu_to_le32(ALIGN(roff + dlen, 8));\n\n\t\tmi->dirty = true;\n\t\tbreak;\n\n\tcase CreateAttribute:\n\t\tattr2 = (struct ATTRIB *)data;\n\t\tasize = le32_to_cpu(attr2->size);\n\t\tused = le32_to_cpu(rec->used);\n\n\t\tif (!check_if_attr(rec, lrh) || dlen < SIZEOF_RESIDENT ||\n\t\t    !IS_ALIGNED(asize, 8) ||\n\t\t    Add2Ptr(attr2, asize) > Add2Ptr(lrh, rec_len) ||\n\t\t    dlen > record_size - used) {\n\t\t\tgoto dirty_vol;\n\t\t}\n\n\t\tmemmove(Add2Ptr(attr, asize), attr, used - roff);\n\t\tmemcpy(attr, attr2, asize);\n\n\t\trec->used = cpu_to_le32(used + asize);\n\t\tid = le16_to_cpu(rec->next_attr_id);\n\t\tid2 = le16_to_cpu(attr2->id);\n\t\tif (id <= id2)\n\t\t\trec->next_attr_id = cpu_to_le16(id2 + 1);\n\t\tif (is_attr_indexed(attr))\n\t\t\tle16_add_cpu(&rec->hard_links, 1);\n\n\t\toa2 = find_loaded_attr(log, attr, rno_base);\n\t\tif (oa2) {\n\t\t\tvoid *p2 = kmemdup(attr, le32_to_cpu(attr->size),\n\t\t\t\t\t   GFP_NOFS);\n\t\t\tif (p2) {\n\t\t\t\t \n\t\t\t\tkfree(oa2->attr);\n\t\t\t\toa2->attr = p2;\n\t\t\t}\n\t\t}\n\n\t\tmi->dirty = true;\n\t\tbreak;\n\n\tcase DeleteAttribute:\n\t\tasize = le32_to_cpu(attr->size);\n\t\tused = le32_to_cpu(rec->used);\n\n\t\tif (!check_if_attr(rec, lrh))\n\t\t\tgoto dirty_vol;\n\n\t\trec->used = cpu_to_le32(used - asize);\n\t\tif (is_attr_indexed(attr))\n\t\t\tle16_add_cpu(&rec->hard_links, -1);\n\n\t\tmemmove(attr, Add2Ptr(attr, asize), used - asize - roff);\n\n\t\tmi->dirty = true;\n\t\tbreak;\n\n\tcase UpdateResidentValue:\n\t\tnsize = aoff + dlen;\n\n\t\tif (!check_if_attr(rec, lrh))\n\t\t\tgoto dirty_vol;\n\n\t\tasize = le32_to_cpu(attr->size);\n\t\tused = le32_to_cpu(rec->used);\n\n\t\tif (lrh->redo_len == lrh->undo_len) {\n\t\t\tif (nsize > asize)\n\t\t\t\tgoto dirty_vol;\n\t\t\tgoto move_data;\n\t\t}\n\n\t\tif (nsize > asize && nsize - asize > record_size - used)\n\t\t\tgoto dirty_vol;\n\n\t\tnsize = ALIGN(nsize, 8);\n\t\tdata_off = le16_to_cpu(attr->res.data_off);\n\n\t\tif (nsize < asize) {\n\t\t\tmemmove(Add2Ptr(attr, aoff), data, dlen);\n\t\t\tdata = NULL;  \n\t\t}\n\n\t\tmemmove(Add2Ptr(attr, nsize), Add2Ptr(attr, asize),\n\t\t\tused - le16_to_cpu(lrh->record_off) - asize);\n\n\t\trec->used = cpu_to_le32(used + nsize - asize);\n\t\tattr->size = cpu_to_le32(nsize);\n\t\tattr->res.data_size = cpu_to_le32(aoff + dlen - data_off);\n\nmove_data:\n\t\tif (data)\n\t\t\tmemmove(Add2Ptr(attr, aoff), data, dlen);\n\n\t\toa2 = find_loaded_attr(log, attr, rno_base);\n\t\tif (oa2) {\n\t\t\tvoid *p2 = kmemdup(attr, le32_to_cpu(attr->size),\n\t\t\t\t\t   GFP_NOFS);\n\t\t\tif (p2) {\n\t\t\t\t \n\t\t\t\toa2->run1 = &oa2->run0;\n\t\t\t\tkfree(oa2->attr);\n\t\t\t\toa2->attr = p2;\n\t\t\t}\n\t\t}\n\n\t\tmi->dirty = true;\n\t\tbreak;\n\n\tcase UpdateMappingPairs:\n\t\tnsize = aoff + dlen;\n\t\tasize = le32_to_cpu(attr->size);\n\t\tused = le32_to_cpu(rec->used);\n\n\t\tif (!check_if_attr(rec, lrh) || !attr->non_res ||\n\t\t    aoff < le16_to_cpu(attr->nres.run_off) || aoff > asize ||\n\t\t    (nsize > asize && nsize - asize > record_size - used)) {\n\t\t\tgoto dirty_vol;\n\t\t}\n\n\t\tnsize = ALIGN(nsize, 8);\n\n\t\tmemmove(Add2Ptr(attr, nsize), Add2Ptr(attr, asize),\n\t\t\tused - le16_to_cpu(lrh->record_off) - asize);\n\t\trec->used = cpu_to_le32(used + nsize - asize);\n\t\tattr->size = cpu_to_le32(nsize);\n\t\tmemmove(Add2Ptr(attr, aoff), data, dlen);\n\n\t\tif (run_get_highest_vcn(le64_to_cpu(attr->nres.svcn),\n\t\t\t\t\tattr_run(attr), &t64)) {\n\t\t\tgoto dirty_vol;\n\t\t}\n\n\t\tattr->nres.evcn = cpu_to_le64(t64);\n\t\toa2 = find_loaded_attr(log, attr, rno_base);\n\t\tif (oa2 && oa2->attr->non_res)\n\t\t\toa2->attr->nres.evcn = attr->nres.evcn;\n\n\t\tmi->dirty = true;\n\t\tbreak;\n\n\tcase SetNewAttributeSizes:\n\t\tnew_sz = data;\n\t\tif (!check_if_attr(rec, lrh) || !attr->non_res)\n\t\t\tgoto dirty_vol;\n\n\t\tattr->nres.alloc_size = new_sz->alloc_size;\n\t\tattr->nres.data_size = new_sz->data_size;\n\t\tattr->nres.valid_size = new_sz->valid_size;\n\n\t\tif (dlen >= sizeof(struct NEW_ATTRIBUTE_SIZES))\n\t\t\tattr->nres.total_size = new_sz->total_size;\n\n\t\toa2 = find_loaded_attr(log, attr, rno_base);\n\t\tif (oa2) {\n\t\t\tvoid *p2 = kmemdup(attr, le32_to_cpu(attr->size),\n\t\t\t\t\t   GFP_NOFS);\n\t\t\tif (p2) {\n\t\t\t\tkfree(oa2->attr);\n\t\t\t\toa2->attr = p2;\n\t\t\t}\n\t\t}\n\t\tmi->dirty = true;\n\t\tbreak;\n\n\tcase AddIndexEntryRoot:\n\t\te = (struct NTFS_DE *)data;\n\t\tesize = le16_to_cpu(e->size);\n\t\troot = resident_data(attr);\n\t\thdr = &root->ihdr;\n\t\tused = le32_to_cpu(hdr->used);\n\n\t\tif (!check_if_index_root(rec, lrh) ||\n\t\t    !check_if_root_index(attr, hdr, lrh) ||\n\t\t    Add2Ptr(data, esize) > Add2Ptr(lrh, rec_len) ||\n\t\t    esize > le32_to_cpu(rec->total) - le32_to_cpu(rec->used)) {\n\t\t\tgoto dirty_vol;\n\t\t}\n\n\t\te1 = Add2Ptr(attr, le16_to_cpu(lrh->attr_off));\n\n\t\tchange_attr_size(rec, attr, le32_to_cpu(attr->size) + esize);\n\n\t\tmemmove(Add2Ptr(e1, esize), e1,\n\t\t\tPtrOffset(e1, Add2Ptr(hdr, used)));\n\t\tmemmove(e1, e, esize);\n\n\t\tle32_add_cpu(&attr->res.data_size, esize);\n\t\thdr->used = cpu_to_le32(used + esize);\n\t\tle32_add_cpu(&hdr->total, esize);\n\n\t\tmi->dirty = true;\n\t\tbreak;\n\n\tcase DeleteIndexEntryRoot:\n\t\troot = resident_data(attr);\n\t\thdr = &root->ihdr;\n\t\tused = le32_to_cpu(hdr->used);\n\n\t\tif (!check_if_index_root(rec, lrh) ||\n\t\t    !check_if_root_index(attr, hdr, lrh)) {\n\t\t\tgoto dirty_vol;\n\t\t}\n\n\t\te1 = Add2Ptr(attr, le16_to_cpu(lrh->attr_off));\n\t\tesize = le16_to_cpu(e1->size);\n\t\te2 = Add2Ptr(e1, esize);\n\n\t\tmemmove(e1, e2, PtrOffset(e2, Add2Ptr(hdr, used)));\n\n\t\tle32_sub_cpu(&attr->res.data_size, esize);\n\t\thdr->used = cpu_to_le32(used - esize);\n\t\tle32_sub_cpu(&hdr->total, esize);\n\n\t\tchange_attr_size(rec, attr, le32_to_cpu(attr->size) - esize);\n\n\t\tmi->dirty = true;\n\t\tbreak;\n\n\tcase SetIndexEntryVcnRoot:\n\t\troot = resident_data(attr);\n\t\thdr = &root->ihdr;\n\n\t\tif (!check_if_index_root(rec, lrh) ||\n\t\t    !check_if_root_index(attr, hdr, lrh)) {\n\t\t\tgoto dirty_vol;\n\t\t}\n\n\t\te = Add2Ptr(attr, le16_to_cpu(lrh->attr_off));\n\n\t\tde_set_vbn_le(e, *(__le64 *)data);\n\t\tmi->dirty = true;\n\t\tbreak;\n\n\tcase UpdateFileNameRoot:\n\t\troot = resident_data(attr);\n\t\thdr = &root->ihdr;\n\n\t\tif (!check_if_index_root(rec, lrh) ||\n\t\t    !check_if_root_index(attr, hdr, lrh)) {\n\t\t\tgoto dirty_vol;\n\t\t}\n\n\t\te = Add2Ptr(attr, le16_to_cpu(lrh->attr_off));\n\t\tfname = (struct ATTR_FILE_NAME *)(e + 1);\n\t\tmemmove(&fname->dup, data, sizeof(fname->dup));  \n\t\tmi->dirty = true;\n\t\tbreak;\n\n\tcase UpdateRecordDataRoot:\n\t\troot = resident_data(attr);\n\t\thdr = &root->ihdr;\n\n\t\tif (!check_if_index_root(rec, lrh) ||\n\t\t    !check_if_root_index(attr, hdr, lrh)) {\n\t\t\tgoto dirty_vol;\n\t\t}\n\n\t\te = Add2Ptr(attr, le16_to_cpu(lrh->attr_off));\n\n\t\tmemmove(Add2Ptr(e, le16_to_cpu(e->view.data_off)), data, dlen);\n\n\t\tmi->dirty = true;\n\t\tbreak;\n\n\tcase ZeroEndOfFileRecord:\n\t\tif (roff + dlen > record_size)\n\t\t\tgoto dirty_vol;\n\n\t\tmemset(attr, 0, dlen);\n\t\tmi->dirty = true;\n\t\tbreak;\n\n\tcase UpdateNonresidentValue:\n\t\tif (lco < cbo + roff + dlen)\n\t\t\tgoto dirty_vol;\n\n\t\tmemcpy(Add2Ptr(buffer_le, roff), data, dlen);\n\n\t\ta_dirty = true;\n\t\tif (attr->type == ATTR_ALLOC)\n\t\t\tntfs_fix_pre_write(buffer_le, bytes);\n\t\tbreak;\n\n\tcase AddIndexEntryAllocation:\n\t\tib = Add2Ptr(buffer_le, roff);\n\t\thdr = &ib->ihdr;\n\t\te = data;\n\t\tesize = le16_to_cpu(e->size);\n\t\te1 = Add2Ptr(ib, aoff);\n\n\t\tif (is_baad(&ib->rhdr))\n\t\t\tgoto dirty_vol;\n\t\tif (!check_lsn(&ib->rhdr, rlsn))\n\t\t\tgoto out;\n\n\t\tused = le32_to_cpu(hdr->used);\n\n\t\tif (!check_index_buffer(ib, bytes) ||\n\t\t    !check_if_alloc_index(hdr, aoff) ||\n\t\t    Add2Ptr(e, esize) > Add2Ptr(lrh, rec_len) ||\n\t\t    used + esize > le32_to_cpu(hdr->total)) {\n\t\t\tgoto dirty_vol;\n\t\t}\n\n\t\tmemmove(Add2Ptr(e1, esize), e1,\n\t\t\tPtrOffset(e1, Add2Ptr(hdr, used)));\n\t\tmemcpy(e1, e, esize);\n\n\t\thdr->used = cpu_to_le32(used + esize);\n\n\t\ta_dirty = true;\n\n\t\tntfs_fix_pre_write(&ib->rhdr, bytes);\n\t\tbreak;\n\n\tcase DeleteIndexEntryAllocation:\n\t\tib = Add2Ptr(buffer_le, roff);\n\t\thdr = &ib->ihdr;\n\t\te = Add2Ptr(ib, aoff);\n\t\tesize = le16_to_cpu(e->size);\n\n\t\tif (is_baad(&ib->rhdr))\n\t\t\tgoto dirty_vol;\n\t\tif (!check_lsn(&ib->rhdr, rlsn))\n\t\t\tgoto out;\n\n\t\tif (!check_index_buffer(ib, bytes) ||\n\t\t    !check_if_alloc_index(hdr, aoff)) {\n\t\t\tgoto dirty_vol;\n\t\t}\n\n\t\te1 = Add2Ptr(e, esize);\n\t\tnsize = esize;\n\t\tused = le32_to_cpu(hdr->used);\n\n\t\tmemmove(e, e1, PtrOffset(e1, Add2Ptr(hdr, used)));\n\n\t\thdr->used = cpu_to_le32(used - nsize);\n\n\t\ta_dirty = true;\n\n\t\tntfs_fix_pre_write(&ib->rhdr, bytes);\n\t\tbreak;\n\n\tcase WriteEndOfIndexBuffer:\n\t\tib = Add2Ptr(buffer_le, roff);\n\t\thdr = &ib->ihdr;\n\t\te = Add2Ptr(ib, aoff);\n\n\t\tif (is_baad(&ib->rhdr))\n\t\t\tgoto dirty_vol;\n\t\tif (!check_lsn(&ib->rhdr, rlsn))\n\t\t\tgoto out;\n\t\tif (!check_index_buffer(ib, bytes) ||\n\t\t    !check_if_alloc_index(hdr, aoff) ||\n\t\t    aoff + dlen > offsetof(struct INDEX_BUFFER, ihdr) +\n\t\t\t\t\t  le32_to_cpu(hdr->total)) {\n\t\t\tgoto dirty_vol;\n\t\t}\n\n\t\thdr->used = cpu_to_le32(dlen + PtrOffset(hdr, e));\n\t\tmemmove(e, data, dlen);\n\n\t\ta_dirty = true;\n\t\tntfs_fix_pre_write(&ib->rhdr, bytes);\n\t\tbreak;\n\n\tcase SetIndexEntryVcnAllocation:\n\t\tib = Add2Ptr(buffer_le, roff);\n\t\thdr = &ib->ihdr;\n\t\te = Add2Ptr(ib, aoff);\n\n\t\tif (is_baad(&ib->rhdr))\n\t\t\tgoto dirty_vol;\n\n\t\tif (!check_lsn(&ib->rhdr, rlsn))\n\t\t\tgoto out;\n\t\tif (!check_index_buffer(ib, bytes) ||\n\t\t    !check_if_alloc_index(hdr, aoff)) {\n\t\t\tgoto dirty_vol;\n\t\t}\n\n\t\tde_set_vbn_le(e, *(__le64 *)data);\n\n\t\ta_dirty = true;\n\t\tntfs_fix_pre_write(&ib->rhdr, bytes);\n\t\tbreak;\n\n\tcase UpdateFileNameAllocation:\n\t\tib = Add2Ptr(buffer_le, roff);\n\t\thdr = &ib->ihdr;\n\t\te = Add2Ptr(ib, aoff);\n\n\t\tif (is_baad(&ib->rhdr))\n\t\t\tgoto dirty_vol;\n\n\t\tif (!check_lsn(&ib->rhdr, rlsn))\n\t\t\tgoto out;\n\t\tif (!check_index_buffer(ib, bytes) ||\n\t\t    !check_if_alloc_index(hdr, aoff)) {\n\t\t\tgoto dirty_vol;\n\t\t}\n\n\t\tfname = (struct ATTR_FILE_NAME *)(e + 1);\n\t\tmemmove(&fname->dup, data, sizeof(fname->dup));\n\n\t\ta_dirty = true;\n\t\tntfs_fix_pre_write(&ib->rhdr, bytes);\n\t\tbreak;\n\n\tcase SetBitsInNonresidentBitMap:\n\t\toff = le32_to_cpu(((struct BITMAP_RANGE *)data)->bitmap_off);\n\t\tbits = le32_to_cpu(((struct BITMAP_RANGE *)data)->bits);\n\n\t\tif (cbo + (off + 7) / 8 > lco ||\n\t\t    cbo + ((off + bits + 7) / 8) > lco) {\n\t\t\tgoto dirty_vol;\n\t\t}\n\n\t\tntfs_bitmap_set_le(Add2Ptr(buffer_le, roff), off, bits);\n\t\ta_dirty = true;\n\t\tbreak;\n\n\tcase ClearBitsInNonresidentBitMap:\n\t\toff = le32_to_cpu(((struct BITMAP_RANGE *)data)->bitmap_off);\n\t\tbits = le32_to_cpu(((struct BITMAP_RANGE *)data)->bits);\n\n\t\tif (cbo + (off + 7) / 8 > lco ||\n\t\t    cbo + ((off + bits + 7) / 8) > lco) {\n\t\t\tgoto dirty_vol;\n\t\t}\n\n\t\tntfs_bitmap_clear_le(Add2Ptr(buffer_le, roff), off, bits);\n\t\ta_dirty = true;\n\t\tbreak;\n\n\tcase UpdateRecordDataAllocation:\n\t\tib = Add2Ptr(buffer_le, roff);\n\t\thdr = &ib->ihdr;\n\t\te = Add2Ptr(ib, aoff);\n\n\t\tif (is_baad(&ib->rhdr))\n\t\t\tgoto dirty_vol;\n\n\t\tif (!check_lsn(&ib->rhdr, rlsn))\n\t\t\tgoto out;\n\t\tif (!check_index_buffer(ib, bytes) ||\n\t\t    !check_if_alloc_index(hdr, aoff)) {\n\t\t\tgoto dirty_vol;\n\t\t}\n\n\t\tmemmove(Add2Ptr(e, le16_to_cpu(e->view.data_off)), data, dlen);\n\n\t\ta_dirty = true;\n\t\tntfs_fix_pre_write(&ib->rhdr, bytes);\n\t\tbreak;\n\n\tdefault:\n\t\tWARN_ON(1);\n\t}\n\n\tif (rlsn) {\n\t\t__le64 t64 = cpu_to_le64(*rlsn);\n\n\t\tif (rec)\n\t\t\trec->rhdr.lsn = t64;\n\t\tif (ib)\n\t\t\tib->rhdr.lsn = t64;\n\t}\n\n\tif (mi && mi->dirty) {\n\t\terr = mi_write(mi, 0);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (a_dirty) {\n\t\tattr = oa->attr;\n\t\terr = ntfs_sb_write_run(sbi, oa->run1, vbo, buffer_le, bytes,\n\t\t\t\t\t0);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\nout:\n\n\tif (inode)\n\t\tiput(inode);\n\telse if (mi != mi2_child)\n\t\tmi_put(mi);\n\n\tkfree(buffer_le);\n\n\treturn err;\n\ndirty_vol:\n\tlog->set_dirty = true;\n\tgoto out;\n}\n\n \nint log_replay(struct ntfs_inode *ni, bool *initialized)\n{\n\tint err;\n\tstruct ntfs_sb_info *sbi = ni->mi.sbi;\n\tstruct ntfs_log *log;\n\n\tstruct restart_info rst_info, rst_info2;\n\tu64 rec_lsn, ra_lsn, checkpt_lsn = 0, rlsn = 0;\n\tstruct ATTR_NAME_ENTRY *attr_names = NULL;\n\tstruct ATTR_NAME_ENTRY *ane;\n\tstruct RESTART_TABLE *dptbl = NULL;\n\tstruct RESTART_TABLE *trtbl = NULL;\n\tconst struct RESTART_TABLE *rt;\n\tstruct RESTART_TABLE *oatbl = NULL;\n\tstruct inode *inode;\n\tstruct OpenAttr *oa;\n\tstruct ntfs_inode *ni_oe;\n\tstruct ATTRIB *attr = NULL;\n\tu64 size, vcn, undo_next_lsn;\n\tCLST rno, lcn, lcn0, len0, clen;\n\tvoid *data;\n\tstruct NTFS_RESTART *rst = NULL;\n\tstruct lcb *lcb = NULL;\n\tstruct OPEN_ATTR_ENRTY *oe;\n\tstruct TRANSACTION_ENTRY *tr;\n\tstruct DIR_PAGE_ENTRY *dp;\n\tu32 i, bytes_per_attr_entry;\n\tu32 l_size = ni->vfs_inode.i_size;\n\tu32 orig_file_size = l_size;\n\tu32 page_size, vbo, tail, off, dlen;\n\tu32 saved_len, rec_len, transact_id;\n\tbool use_second_page;\n\tstruct RESTART_AREA *ra2, *ra = NULL;\n\tstruct CLIENT_REC *ca, *cr;\n\t__le16 client;\n\tstruct RESTART_HDR *rh;\n\tconst struct LFS_RECORD_HDR *frh;\n\tconst struct LOG_REC_HDR *lrh;\n\tbool is_mapped;\n\tbool is_ro = sb_rdonly(sbi->sb);\n\tu64 t64;\n\tu16 t16;\n\tu32 t32;\n\n\t \n#if PAGE_SIZE >= DefaultLogPageSize && PAGE_SIZE <= DefaultLogPageSize * 2\n\tpage_size = norm_file_page(PAGE_SIZE, &l_size, true);\n#else\n\tpage_size = norm_file_page(PAGE_SIZE, &l_size, false);\n#endif\n\tif (!page_size)\n\t\treturn -EINVAL;\n\n\tlog = kzalloc(sizeof(struct ntfs_log), GFP_NOFS);\n\tif (!log)\n\t\treturn -ENOMEM;\n\n\tlog->ni = ni;\n\tlog->l_size = l_size;\n\tlog->one_page_buf = kmalloc(page_size, GFP_NOFS);\n\n\tif (!log->one_page_buf) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tlog->page_size = page_size;\n\tlog->page_mask = page_size - 1;\n\tlog->page_bits = blksize_bits(page_size);\n\n\t \n\tmemset(&rst_info, 0, sizeof(struct restart_info));\n\terr = log_read_rst(log, l_size, true, &rst_info);\n\tif (err)\n\t\tgoto out;\n\n\t \n\t*initialized = rst_info.initialized;\n\n\tif (!rst_info.restart) {\n\t\tif (rst_info.initialized) {\n\t\t\t \n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tlog_init_pg_hdr(log, page_size, page_size, 1, 1);\n\t\tlog_create(log, l_size, 0, get_random_u32(), false, false);\n\n\t\tlog->ra = ra;\n\n\t\tra = log_create_ra(log);\n\t\tif (!ra) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tlog->ra = ra;\n\t\tlog->init_ra = true;\n\n\t\tgoto process_log;\n\t}\n\n\t \n\tif (rst_info.vbo)\n\t\tgoto check_restart_area;\n\n\tmemset(&rst_info2, 0, sizeof(struct restart_info));\n\terr = log_read_rst(log, l_size, false, &rst_info2);\n\tif (err)\n\t\tgoto out;\n\n\t \n\tif (!rst_info2.restart || rst_info2.last_lsn <= rst_info.last_lsn)\n\t\tgoto use_first_page;\n\n\tuse_second_page = true;\n\n\tif (rst_info.chkdsk_was_run && page_size != rst_info.vbo) {\n\t\tstruct RECORD_PAGE_HDR *sp = NULL;\n\t\tbool usa_error;\n\n\t\tif (!read_log_page(log, page_size, &sp, &usa_error) &&\n\t\t    sp->rhdr.sign == NTFS_CHKD_SIGNATURE) {\n\t\t\tuse_second_page = false;\n\t\t}\n\t\tkfree(sp);\n\t}\n\n\tif (use_second_page) {\n\t\tkfree(rst_info.r_page);\n\t\tmemcpy(&rst_info, &rst_info2, sizeof(struct restart_info));\n\t\trst_info2.r_page = NULL;\n\t}\n\nuse_first_page:\n\tkfree(rst_info2.r_page);\n\ncheck_restart_area:\n\t \n\tlog->init_ra = !!rst_info.vbo;\n\n\t \n\tra2 = rst_info.valid_page ?\n\t\t      Add2Ptr(rst_info.r_page,\n\t\t\t      le16_to_cpu(rst_info.r_page->ra_off)) :\n\t\t      NULL;\n\n\tif (rst_info.chkdsk_was_run ||\n\t    (ra2 && ra2->client_idx[1] == LFS_NO_CLIENT_LE)) {\n\t\tbool wrapped = false;\n\t\tbool use_multi_page = false;\n\t\tu32 open_log_count;\n\n\t\t \n\t\tif (!rst_info.valid_page) {\n\t\t\topen_log_count = get_random_u32();\n\t\t\tgoto init_log_instance;\n\t\t}\n\t\topen_log_count = le32_to_cpu(ra2->open_log_count);\n\n\t\t \n\t\tif (page_size != le32_to_cpu(rst_info.r_page->sys_page_size))\n\t\t\tgoto init_log_instance;\n\ninit_log_instance:\n\t\tlog_init_pg_hdr(log, page_size, page_size, 1, 1);\n\n\t\tlog_create(log, l_size, rst_info.last_lsn, open_log_count,\n\t\t\t   wrapped, use_multi_page);\n\n\t\tra = log_create_ra(log);\n\t\tif (!ra) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tlog->ra = ra;\n\n\t\t \n\t\tgoto process_log;\n\t}\n\n\tif (!ra2) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tt32 = le32_to_cpu(rst_info.r_page->sys_page_size);\n\tif (page_size != t32) {\n\t\tl_size = orig_file_size;\n\t\tpage_size =\n\t\t\tnorm_file_page(t32, &l_size, t32 == DefaultLogPageSize);\n\t}\n\n\tif (page_size != t32 ||\n\t    page_size != le32_to_cpu(rst_info.r_page->page_size)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (l_size < le64_to_cpu(ra2->l_size)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tlog_init_pg_hdr(log, page_size, page_size,\n\t\t\tle16_to_cpu(rst_info.r_page->major_ver),\n\t\t\tle16_to_cpu(rst_info.r_page->minor_ver));\n\n\tlog->l_size = le64_to_cpu(ra2->l_size);\n\tlog->seq_num_bits = le32_to_cpu(ra2->seq_num_bits);\n\tlog->file_data_bits = sizeof(u64) * 8 - log->seq_num_bits;\n\tlog->seq_num_mask = (8 << log->file_data_bits) - 1;\n\tlog->last_lsn = le64_to_cpu(ra2->current_lsn);\n\tlog->seq_num = log->last_lsn >> log->file_data_bits;\n\tlog->ra_off = le16_to_cpu(rst_info.r_page->ra_off);\n\tlog->restart_size = log->sys_page_size - log->ra_off;\n\tlog->record_header_len = le16_to_cpu(ra2->rec_hdr_len);\n\tlog->ra_size = le16_to_cpu(ra2->ra_len);\n\tlog->data_off = le16_to_cpu(ra2->data_off);\n\tlog->data_size = log->page_size - log->data_off;\n\tlog->reserved = log->data_size - log->record_header_len;\n\n\tvbo = lsn_to_vbo(log, log->last_lsn);\n\n\tif (vbo < log->first_page) {\n\t\t \n\t\tlog->l_flags |= NTFSLOG_NO_LAST_LSN;\n\t\tlog->next_page = log->first_page;\n\t\tgoto find_oldest;\n\t}\n\n\t \n\toff = final_log_off(log, log->last_lsn,\n\t\t\t    le32_to_cpu(ra2->last_lsn_data_len));\n\n\t \n\tif (off <= vbo) {\n\t\tlog->seq_num += 1;\n\t\tlog->l_flags |= NTFSLOG_WRAPPED;\n\t}\n\n\t \n\tvbo &= ~log->sys_page_mask;\n\ttail = log->page_size - (off & log->page_mask) - 1;\n\n\t \n\tif (tail >= log->record_header_len) {\n\t\tlog->l_flags |= NTFSLOG_REUSE_TAIL;\n\t\tlog->next_page = vbo;\n\t} else {\n\t\tlog->next_page = next_page_off(log, vbo);\n\t}\n\nfind_oldest:\n\t \n\tlog->oldest_lsn = log->last_lsn;\n\toldest_client_lsn(Add2Ptr(ra2, le16_to_cpu(ra2->client_off)),\n\t\t\t  ra2->client_idx[1], &log->oldest_lsn);\n\tlog->oldest_lsn_off = lsn_to_vbo(log, log->oldest_lsn);\n\n\tif (log->oldest_lsn_off < log->first_page)\n\t\tlog->l_flags |= NTFSLOG_NO_OLDEST_LSN;\n\n\tif (!(ra2->flags & RESTART_SINGLE_PAGE_IO))\n\t\tlog->l_flags |= NTFSLOG_WRAPPED | NTFSLOG_MULTIPLE_PAGE_IO;\n\n\tlog->current_openlog_count = le32_to_cpu(ra2->open_log_count);\n\tlog->total_avail_pages = log->l_size - log->first_page;\n\tlog->total_avail = log->total_avail_pages >> log->page_bits;\n\tlog->max_current_avail = log->total_avail * log->reserved;\n\tlog->total_avail = log->total_avail * log->data_size;\n\n\tlog->current_avail = current_log_avail(log);\n\n\tra = kzalloc(log->restart_size, GFP_NOFS);\n\tif (!ra) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\tlog->ra = ra;\n\n\tt16 = le16_to_cpu(ra2->client_off);\n\tif (t16 == offsetof(struct RESTART_AREA, clients)) {\n\t\tmemcpy(ra, ra2, log->ra_size);\n\t} else {\n\t\tmemcpy(ra, ra2, offsetof(struct RESTART_AREA, clients));\n\t\tmemcpy(ra->clients, Add2Ptr(ra2, t16),\n\t\t       le16_to_cpu(ra2->ra_len) - t16);\n\n\t\tlog->current_openlog_count = get_random_u32();\n\t\tra->open_log_count = cpu_to_le32(log->current_openlog_count);\n\t\tlog->ra_size = offsetof(struct RESTART_AREA, clients) +\n\t\t\t       sizeof(struct CLIENT_REC);\n\t\tra->client_off =\n\t\t\tcpu_to_le16(offsetof(struct RESTART_AREA, clients));\n\t\tra->ra_len = cpu_to_le16(log->ra_size);\n\t}\n\n\tle32_add_cpu(&ra->open_log_count, 1);\n\n\t \n\terr = last_log_lsn(log);\n\tif (err)\n\t\tgoto out;\n\n\tlog->current_avail = current_log_avail(log);\n\n\t \n\tlog->init_ra = rst_info.vbo;\n\nprocess_log:\n\t \n\tswitch ((log->major_ver << 16) + log->minor_ver) {\n\tcase 0x10000:\n\tcase 0x10001:\n\tcase 0x20000:\n\t\tbreak;\n\tdefault:\n\t\tntfs_warn(sbi->sb, \"\\x24LogFile version %d.%d is not supported\",\n\t\t\t  log->major_ver, log->minor_ver);\n\t\terr = -EOPNOTSUPP;\n\t\tlog->set_dirty = true;\n\t\tgoto out;\n\t}\n\n\t \n\tca = Add2Ptr(ra, le16_to_cpu(ra->client_off));\n\n\tfor (client = ra->client_idx[1];; client = cr->next_client) {\n\t\tif (client == LFS_NO_CLIENT_LE) {\n\t\t\t \n\t\t\tclient = ra->client_idx[0];\n\t\t\tif (client == LFS_NO_CLIENT_LE) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tt16 = le16_to_cpu(client);\n\t\t\tcr = ca + t16;\n\n\t\t\tremove_client(ca, cr, &ra->client_idx[0]);\n\n\t\t\tcr->restart_lsn = 0;\n\t\t\tcr->oldest_lsn = cpu_to_le64(log->oldest_lsn);\n\t\t\tcr->name_bytes = cpu_to_le32(8);\n\t\t\tcr->name[0] = cpu_to_le16('N');\n\t\t\tcr->name[1] = cpu_to_le16('T');\n\t\t\tcr->name[2] = cpu_to_le16('F');\n\t\t\tcr->name[3] = cpu_to_le16('S');\n\n\t\t\tadd_client(ca, t16, &ra->client_idx[1]);\n\t\t\tbreak;\n\t\t}\n\n\t\tcr = ca + le16_to_cpu(client);\n\n\t\tif (cpu_to_le32(8) == cr->name_bytes &&\n\t\t    cpu_to_le16('N') == cr->name[0] &&\n\t\t    cpu_to_le16('T') == cr->name[1] &&\n\t\t    cpu_to_le16('F') == cr->name[2] &&\n\t\t    cpu_to_le16('S') == cr->name[3])\n\t\t\tbreak;\n\t}\n\n\t \n\tlog->client_id.seq_num = cr->seq_num;\n\tlog->client_id.client_idx = client;\n\n\terr = read_rst_area(log, &rst, &ra_lsn);\n\tif (err)\n\t\tgoto out;\n\n\tif (!rst)\n\t\tgoto out;\n\n\tbytes_per_attr_entry = !rst->major_ver ? 0x2C : 0x28;\n\n\tcheckpt_lsn = le64_to_cpu(rst->check_point_start);\n\tif (!checkpt_lsn)\n\t\tcheckpt_lsn = ra_lsn;\n\n\t \n\tif (!rst->transact_table_len)\n\t\tgoto check_dirty_page_table;\n\n\tt64 = le64_to_cpu(rst->transact_table_lsn);\n\terr = read_log_rec_lcb(log, t64, lcb_ctx_prev, &lcb);\n\tif (err)\n\t\tgoto out;\n\n\tlrh = lcb->log_rec;\n\tfrh = lcb->lrh;\n\trec_len = le32_to_cpu(frh->client_data_len);\n\n\tif (!check_log_rec(lrh, rec_len, le32_to_cpu(frh->transact_id),\n\t\t\t   bytes_per_attr_entry)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tt16 = le16_to_cpu(lrh->redo_off);\n\n\trt = Add2Ptr(lrh, t16);\n\tt32 = rec_len - t16;\n\n\t \n\tif (!check_rstbl(rt, t32)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ttrtbl = kmemdup(rt, t32, GFP_NOFS);\n\tif (!trtbl) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tlcb_put(lcb);\n\tlcb = NULL;\n\ncheck_dirty_page_table:\n\t \n\tif (!rst->dirty_pages_len)\n\t\tgoto check_attribute_names;\n\n\tt64 = le64_to_cpu(rst->dirty_pages_table_lsn);\n\terr = read_log_rec_lcb(log, t64, lcb_ctx_prev, &lcb);\n\tif (err)\n\t\tgoto out;\n\n\tlrh = lcb->log_rec;\n\tfrh = lcb->lrh;\n\trec_len = le32_to_cpu(frh->client_data_len);\n\n\tif (!check_log_rec(lrh, rec_len, le32_to_cpu(frh->transact_id),\n\t\t\t   bytes_per_attr_entry)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tt16 = le16_to_cpu(lrh->redo_off);\n\n\trt = Add2Ptr(lrh, t16);\n\tt32 = rec_len - t16;\n\n\t \n\tif (!check_rstbl(rt, t32)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tdptbl = kmemdup(rt, t32, GFP_NOFS);\n\tif (!dptbl) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\tif (rst->major_ver)\n\t\tgoto end_conv_1;\n\n\tdp = NULL;\n\twhile ((dp = enum_rstbl(dptbl, dp))) {\n\t\tstruct DIR_PAGE_ENTRY_32 *dp0 = (struct DIR_PAGE_ENTRY_32 *)dp;\n\t\t\n\t\tmemmove(&dp->vcn, &dp0->vcn_low,\n\t\t\t2 * sizeof(u64) +\n\t\t\t\tle32_to_cpu(dp->lcns_follow) * sizeof(u64));\n\t}\n\nend_conv_1:\n\tlcb_put(lcb);\n\tlcb = NULL;\n\n\t \n\tif (sbi->cluster_size <= log->page_size)\n\t\tgoto trace_dp_table;\n\n\tdp = NULL;\n\twhile ((dp = enum_rstbl(dptbl, dp))) {\n\t\tstruct DIR_PAGE_ENTRY *next = dp;\n\n\t\twhile ((next = enum_rstbl(dptbl, next))) {\n\t\t\tif (next->target_attr == dp->target_attr &&\n\t\t\t    next->vcn == dp->vcn) {\n\t\t\t\tif (le64_to_cpu(next->oldest_lsn) <\n\t\t\t\t    le64_to_cpu(dp->oldest_lsn)) {\n\t\t\t\t\tdp->oldest_lsn = next->oldest_lsn;\n\t\t\t\t}\n\n\t\t\t\tfree_rsttbl_idx(dptbl, PtrOffset(dptbl, next));\n\t\t\t}\n\t\t}\n\t}\ntrace_dp_table:\ncheck_attribute_names:\n\t \n\tif (!rst->attr_names_len)\n\t\tgoto check_attr_table;\n\n\tt64 = le64_to_cpu(rst->attr_names_lsn);\n\terr = read_log_rec_lcb(log, t64, lcb_ctx_prev, &lcb);\n\tif (err)\n\t\tgoto out;\n\n\tlrh = lcb->log_rec;\n\tfrh = lcb->lrh;\n\trec_len = le32_to_cpu(frh->client_data_len);\n\n\tif (!check_log_rec(lrh, rec_len, le32_to_cpu(frh->transact_id),\n\t\t\t   bytes_per_attr_entry)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tt32 = lrh_length(lrh);\n\trec_len -= t32;\n\n\tattr_names = kmemdup(Add2Ptr(lrh, t32), rec_len, GFP_NOFS);\n\tif (!attr_names) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tlcb_put(lcb);\n\tlcb = NULL;\n\ncheck_attr_table:\n\t \n\tif (!rst->open_attr_len)\n\t\tgoto check_attribute_names2;\n\n\tt64 = le64_to_cpu(rst->open_attr_table_lsn);\n\terr = read_log_rec_lcb(log, t64, lcb_ctx_prev, &lcb);\n\tif (err)\n\t\tgoto out;\n\n\tlrh = lcb->log_rec;\n\tfrh = lcb->lrh;\n\trec_len = le32_to_cpu(frh->client_data_len);\n\n\tif (!check_log_rec(lrh, rec_len, le32_to_cpu(frh->transact_id),\n\t\t\t   bytes_per_attr_entry)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tt16 = le16_to_cpu(lrh->redo_off);\n\n\trt = Add2Ptr(lrh, t16);\n\tt32 = rec_len - t16;\n\n\tif (!check_rstbl(rt, t32)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\toatbl = kmemdup(rt, t32, GFP_NOFS);\n\tif (!oatbl) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tlog->open_attr_tbl = oatbl;\n\n\t \n\toe = NULL;\n\twhile ((oe = enum_rstbl(oatbl, oe))) {\n\t\tif (!rst->major_ver) {\n\t\t\tstruct OPEN_ATTR_ENRTY_32 oe0;\n\n\t\t\t \n\t\t\tmemcpy(&oe0, oe, SIZEOF_OPENATTRIBUTEENTRY0);\n\n\t\t\toe->bytes_per_index = oe0.bytes_per_index;\n\t\t\toe->type = oe0.type;\n\t\t\toe->is_dirty_pages = oe0.is_dirty_pages;\n\t\t\toe->name_len = 0;\n\t\t\toe->ref = oe0.ref;\n\t\t\toe->open_record_lsn = oe0.open_record_lsn;\n\t\t}\n\n\t\toe->is_attr_name = 0;\n\t\toe->ptr = NULL;\n\t}\n\n\tlcb_put(lcb);\n\tlcb = NULL;\n\ncheck_attribute_names2:\n\tif (!rst->attr_names_len)\n\t\tgoto trace_attribute_table;\n\n\tane = attr_names;\n\tif (!oatbl)\n\t\tgoto trace_attribute_table;\n\twhile (ane->off) {\n\t\t \n\t\toe = Add2Ptr(oatbl, le16_to_cpu(ane->off));\n\t\tt16 = le16_to_cpu(ane->name_bytes);\n\t\toe->name_len = t16 / sizeof(short);\n\t\toe->ptr = ane->name;\n\t\toe->is_attr_name = 2;\n\t\tane = Add2Ptr(ane, sizeof(struct ATTR_NAME_ENTRY) + t16);\n\t}\n\ntrace_attribute_table:\n\t \n\tif (!checkpt_lsn) {\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\tif (!oatbl) {\n\t\toatbl = init_rsttbl(bytes_per_attr_entry, 8);\n\t\tif (!oatbl) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tlog->open_attr_tbl = oatbl;\n\n\t \n\trec_lsn = checkpt_lsn;\n\n\t \n\terr = read_log_rec_lcb(log, checkpt_lsn, lcb_ctx_next, &lcb);\n\tif (err)\n\t\tgoto out;\n\n\t \nnext_log_record_analyze:\n\terr = read_next_log_rec(log, lcb, &rec_lsn);\n\tif (err)\n\t\tgoto out;\n\n\tif (!rec_lsn)\n\t\tgoto end_log_records_enumerate;\n\n\tfrh = lcb->lrh;\n\ttransact_id = le32_to_cpu(frh->transact_id);\n\trec_len = le32_to_cpu(frh->client_data_len);\n\tlrh = lcb->log_rec;\n\n\tif (!check_log_rec(lrh, rec_len, transact_id, bytes_per_attr_entry)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (!rlsn)\n\t\trlsn = rec_lsn;\n\n\tif (LfsClientRecord != frh->record_type)\n\t\tgoto next_log_record_analyze;\n\n\t \n\tif (!trtbl) {\n\t\ttrtbl = init_rsttbl(sizeof(struct TRANSACTION_ENTRY),\n\t\t\t\t    INITIAL_NUMBER_TRANSACTIONS);\n\t\tif (!trtbl) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\ttr = Add2Ptr(trtbl, transact_id);\n\n\tif (transact_id >= bytes_per_rt(trtbl) ||\n\t    tr->next != RESTART_ENTRY_ALLOCATED_LE) {\n\t\ttr = alloc_rsttbl_from_idx(&trtbl, transact_id);\n\t\tif (!tr) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\ttr->transact_state = TransactionActive;\n\t\ttr->first_lsn = cpu_to_le64(rec_lsn);\n\t}\n\n\ttr->prev_lsn = tr->undo_next_lsn = cpu_to_le64(rec_lsn);\n\n\t \n\tif (lrh->undo_op == cpu_to_le16(CompensationLogRecord))\n\t\ttr->undo_next_lsn = frh->client_undo_next_lsn;\n\n\t \n\tswitch (le16_to_cpu(lrh->redo_op)) {\n\tcase InitializeFileRecordSegment:\n\tcase DeallocateFileRecordSegment:\n\tcase WriteEndOfFileRecordSegment:\n\tcase CreateAttribute:\n\tcase DeleteAttribute:\n\tcase UpdateResidentValue:\n\tcase UpdateNonresidentValue:\n\tcase UpdateMappingPairs:\n\tcase SetNewAttributeSizes:\n\tcase AddIndexEntryRoot:\n\tcase DeleteIndexEntryRoot:\n\tcase AddIndexEntryAllocation:\n\tcase DeleteIndexEntryAllocation:\n\tcase WriteEndOfIndexBuffer:\n\tcase SetIndexEntryVcnRoot:\n\tcase SetIndexEntryVcnAllocation:\n\tcase UpdateFileNameRoot:\n\tcase UpdateFileNameAllocation:\n\tcase SetBitsInNonresidentBitMap:\n\tcase ClearBitsInNonresidentBitMap:\n\tcase UpdateRecordDataRoot:\n\tcase UpdateRecordDataAllocation:\n\tcase ZeroEndOfFileRecord:\n\t\tt16 = le16_to_cpu(lrh->target_attr);\n\t\tt64 = le64_to_cpu(lrh->target_vcn);\n\t\tdp = find_dp(dptbl, t16, t64);\n\n\t\tif (dp)\n\t\t\tgoto copy_lcns;\n\n\t\t \n\t\tif (dptbl) {\n\t\t\tt32 = (le16_to_cpu(dptbl->size) -\n\t\t\t       sizeof(struct DIR_PAGE_ENTRY)) /\n\t\t\t      sizeof(u64);\n\t\t} else {\n\t\t\tt32 = log->clst_per_page;\n\t\t\tkfree(dptbl);\n\t\t\tdptbl = init_rsttbl(struct_size(dp, page_lcns, t32),\n\t\t\t\t\t    32);\n\t\t\tif (!dptbl) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tdp = alloc_rsttbl_idx(&dptbl);\n\t\tif (!dp) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tdp->target_attr = cpu_to_le32(t16);\n\t\tdp->transfer_len = cpu_to_le32(t32 << sbi->cluster_bits);\n\t\tdp->lcns_follow = cpu_to_le32(t32);\n\t\tdp->vcn = cpu_to_le64(t64 & ~((u64)t32 - 1));\n\t\tdp->oldest_lsn = cpu_to_le64(rec_lsn);\n\ncopy_lcns:\n\t\t \n\t\tt16 = le16_to_cpu(lrh->lcns_follow);\n\t\tfor (i = 0; i < t16; i++) {\n\t\t\tsize_t j = (size_t)(le64_to_cpu(lrh->target_vcn) -\n\t\t\t\t\t    le64_to_cpu(dp->vcn));\n\t\t\tdp->page_lcns[j + i] = lrh->page_lcns[i];\n\t\t}\n\n\t\tgoto next_log_record_analyze;\n\n\tcase DeleteDirtyClusters: {\n\t\tu32 range_count =\n\t\t\tle16_to_cpu(lrh->redo_len) / sizeof(struct LCN_RANGE);\n\t\tconst struct LCN_RANGE *r =\n\t\t\tAdd2Ptr(lrh, le16_to_cpu(lrh->redo_off));\n\n\t\t \n\t\tfor (i = 0; i < range_count; i++, r++) {\n\t\t\tu64 lcn0 = le64_to_cpu(r->lcn);\n\t\t\tu64 lcn_e = lcn0 + le64_to_cpu(r->len) - 1;\n\n\t\t\tdp = NULL;\n\t\t\twhile ((dp = enum_rstbl(dptbl, dp))) {\n\t\t\t\tu32 j;\n\n\t\t\t\tt32 = le32_to_cpu(dp->lcns_follow);\n\t\t\t\tfor (j = 0; j < t32; j++) {\n\t\t\t\t\tt64 = le64_to_cpu(dp->page_lcns[j]);\n\t\t\t\t\tif (t64 >= lcn0 && t64 <= lcn_e)\n\t\t\t\t\t\tdp->page_lcns[j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tgoto next_log_record_analyze;\n\t\t;\n\t}\n\n\tcase OpenNonresidentAttribute:\n\t\tt16 = le16_to_cpu(lrh->target_attr);\n\t\tif (t16 >= bytes_per_rt(oatbl)) {\n\t\t\t \n\t\t\tu32 new_e = t16 / le16_to_cpu(oatbl->size);\n\n\t\t\tnew_e += 10 - le16_to_cpu(oatbl->used);\n\n\t\t\toatbl = extend_rsttbl(oatbl, new_e, ~0u);\n\t\t\tlog->open_attr_tbl = oatbl;\n\t\t\tif (!oatbl) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\toe = alloc_rsttbl_from_idx(&oatbl, t16);\n\t\tlog->open_attr_tbl = oatbl;\n\t\tif (!oe) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tt16 = le16_to_cpu(lrh->redo_off);\n\t\tif (!rst->major_ver) {\n\t\t\t \n\t\t\tstruct OPEN_ATTR_ENRTY_32 *oe0 = Add2Ptr(lrh, t16);\n\n\t\t\toe->bytes_per_index = oe0->bytes_per_index;\n\t\t\toe->type = oe0->type;\n\t\t\toe->is_dirty_pages = oe0->is_dirty_pages;\n\t\t\toe->name_len = 0; \n\t\t\toe->ref = oe0->ref;\n\t\t\toe->open_record_lsn = oe0->open_record_lsn;\n\t\t} else {\n\t\t\tmemcpy(oe, Add2Ptr(lrh, t16), bytes_per_attr_entry);\n\t\t}\n\n\t\tt16 = le16_to_cpu(lrh->undo_len);\n\t\tif (t16) {\n\t\t\toe->ptr = kmalloc(t16, GFP_NOFS);\n\t\t\tif (!oe->ptr) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\toe->name_len = t16 / sizeof(short);\n\t\t\tmemcpy(oe->ptr,\n\t\t\t       Add2Ptr(lrh, le16_to_cpu(lrh->undo_off)), t16);\n\t\t\toe->is_attr_name = 1;\n\t\t} else {\n\t\t\toe->ptr = NULL;\n\t\t\toe->is_attr_name = 0;\n\t\t}\n\n\t\tgoto next_log_record_analyze;\n\n\tcase HotFix:\n\t\tt16 = le16_to_cpu(lrh->target_attr);\n\t\tt64 = le64_to_cpu(lrh->target_vcn);\n\t\tdp = find_dp(dptbl, t16, t64);\n\t\tif (dp) {\n\t\t\tsize_t j = le64_to_cpu(lrh->target_vcn) -\n\t\t\t\t   le64_to_cpu(dp->vcn);\n\t\t\tif (dp->page_lcns[j])\n\t\t\t\tdp->page_lcns[j] = lrh->page_lcns[0];\n\t\t}\n\t\tgoto next_log_record_analyze;\n\n\tcase EndTopLevelAction:\n\t\ttr = Add2Ptr(trtbl, transact_id);\n\t\ttr->prev_lsn = cpu_to_le64(rec_lsn);\n\t\ttr->undo_next_lsn = frh->client_undo_next_lsn;\n\t\tgoto next_log_record_analyze;\n\n\tcase PrepareTransaction:\n\t\ttr = Add2Ptr(trtbl, transact_id);\n\t\ttr->transact_state = TransactionPrepared;\n\t\tgoto next_log_record_analyze;\n\n\tcase CommitTransaction:\n\t\ttr = Add2Ptr(trtbl, transact_id);\n\t\ttr->transact_state = TransactionCommitted;\n\t\tgoto next_log_record_analyze;\n\n\tcase ForgetTransaction:\n\t\tfree_rsttbl_idx(trtbl, transact_id);\n\t\tgoto next_log_record_analyze;\n\n\tcase Noop:\n\tcase OpenAttributeTableDump:\n\tcase AttributeNamesDump:\n\tcase DirtyPageTableDump:\n\tcase TransactionTableDump:\n\t\t \n\t\tgoto next_log_record_analyze;\n\n\tdefault:\n\t\t \n\t\tgoto next_log_record_analyze;\n\t}\n\nend_log_records_enumerate:\n\tlcb_put(lcb);\n\tlcb = NULL;\n\n\t \n\tdp = NULL;\n\twhile ((dp = enum_rstbl(dptbl, dp))) {\n\t\tt64 = le64_to_cpu(dp->oldest_lsn);\n\t\tif (t64 && t64 < rlsn)\n\t\t\trlsn = t64;\n\t}\n\n\ttr = NULL;\n\twhile ((tr = enum_rstbl(trtbl, tr))) {\n\t\tt64 = le64_to_cpu(tr->first_lsn);\n\t\tif (t64 && t64 < rlsn)\n\t\t\trlsn = t64;\n\t}\n\n\t \n\tif ((!dptbl || !dptbl->total) && (!trtbl || !trtbl->total))\n\t\tgoto end_reply;\n\n\tsbi->flags |= NTFS_FLAGS_NEED_REPLAY;\n\tif (is_ro)\n\t\tgoto out;\n\n\t \n\toe = NULL;\nnext_open_attribute:\n\n\toe = enum_rstbl(oatbl, oe);\n\tif (!oe) {\n\t\terr = 0;\n\t\tdp = NULL;\n\t\tgoto next_dirty_page;\n\t}\n\n\toa = kzalloc(sizeof(struct OpenAttr), GFP_NOFS);\n\tif (!oa) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tinode = ntfs_iget5(sbi->sb, &oe->ref, NULL);\n\tif (IS_ERR(inode))\n\t\tgoto fake_attr;\n\n\tif (is_bad_inode(inode)) {\n\t\tiput(inode);\nfake_attr:\n\t\tif (oa->ni) {\n\t\t\tiput(&oa->ni->vfs_inode);\n\t\t\toa->ni = NULL;\n\t\t}\n\n\t\tattr = attr_create_nonres_log(sbi, oe->type, 0, oe->ptr,\n\t\t\t\t\t      oe->name_len, 0);\n\t\tif (!attr) {\n\t\t\tkfree(oa);\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\toa->attr = attr;\n\t\toa->run1 = &oa->run0;\n\t\tgoto final_oe;\n\t}\n\n\tni_oe = ntfs_i(inode);\n\toa->ni = ni_oe;\n\n\tattr = ni_find_attr(ni_oe, NULL, NULL, oe->type, oe->ptr, oe->name_len,\n\t\t\t    NULL, NULL);\n\n\tif (!attr)\n\t\tgoto fake_attr;\n\n\tt32 = le32_to_cpu(attr->size);\n\toa->attr = kmemdup(attr, t32, GFP_NOFS);\n\tif (!oa->attr)\n\t\tgoto fake_attr;\n\n\tif (!S_ISDIR(inode->i_mode)) {\n\t\tif (attr->type == ATTR_DATA && !attr->name_len) {\n\t\t\toa->run1 = &ni_oe->file.run;\n\t\t\tgoto final_oe;\n\t\t}\n\t} else {\n\t\tif (attr->type == ATTR_ALLOC &&\n\t\t    attr->name_len == ARRAY_SIZE(I30_NAME) &&\n\t\t    !memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME))) {\n\t\t\toa->run1 = &ni_oe->dir.alloc_run;\n\t\t\tgoto final_oe;\n\t\t}\n\t}\n\n\tif (attr->non_res) {\n\t\tu16 roff = le16_to_cpu(attr->nres.run_off);\n\t\tCLST svcn = le64_to_cpu(attr->nres.svcn);\n\n\t\tif (roff > t32) {\n\t\t\tkfree(oa->attr);\n\t\t\toa->attr = NULL;\n\t\t\tgoto fake_attr;\n\t\t}\n\n\t\terr = run_unpack(&oa->run0, sbi, inode->i_ino, svcn,\n\t\t\t\t le64_to_cpu(attr->nres.evcn), svcn,\n\t\t\t\t Add2Ptr(attr, roff), t32 - roff);\n\t\tif (err < 0) {\n\t\t\tkfree(oa->attr);\n\t\t\toa->attr = NULL;\n\t\t\tgoto fake_attr;\n\t\t}\n\t\terr = 0;\n\t}\n\toa->run1 = &oa->run0;\n\tattr = oa->attr;\n\nfinal_oe:\n\tif (oe->is_attr_name == 1)\n\t\tkfree(oe->ptr);\n\toe->is_attr_name = 0;\n\toe->ptr = oa;\n\toe->name_len = attr->name_len;\n\n\tgoto next_open_attribute;\n\n\t \nnext_dirty_page:\n\tdp = enum_rstbl(dptbl, dp);\n\tif (!dp)\n\t\tgoto do_redo_1;\n\n\toe = Add2Ptr(oatbl, le32_to_cpu(dp->target_attr));\n\n\tif (oe->next != RESTART_ENTRY_ALLOCATED_LE)\n\t\tgoto next_dirty_page;\n\n\toa = oe->ptr;\n\tif (!oa)\n\t\tgoto next_dirty_page;\n\n\ti = -1;\nnext_dirty_page_vcn:\n\ti += 1;\n\tif (i >= le32_to_cpu(dp->lcns_follow))\n\t\tgoto next_dirty_page;\n\n\tvcn = le64_to_cpu(dp->vcn) + i;\n\tsize = (vcn + 1) << sbi->cluster_bits;\n\n\tif (!dp->page_lcns[i])\n\t\tgoto next_dirty_page_vcn;\n\n\trno = ino_get(&oe->ref);\n\tif (rno <= MFT_REC_MIRR &&\n\t    size < (MFT_REC_VOL + 1) * sbi->record_size &&\n\t    oe->type == ATTR_DATA) {\n\t\tgoto next_dirty_page_vcn;\n\t}\n\n\tlcn = le64_to_cpu(dp->page_lcns[i]);\n\n\tif ((!run_lookup_entry(oa->run1, vcn, &lcn0, &len0, NULL) ||\n\t     lcn0 != lcn) &&\n\t    !run_add_entry(oa->run1, vcn, lcn, 1, false)) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\tattr = oa->attr;\n\tif (size > le64_to_cpu(attr->nres.alloc_size)) {\n\t\tattr->nres.valid_size = attr->nres.data_size =\n\t\t\tattr->nres.alloc_size = cpu_to_le64(size);\n\t}\n\tgoto next_dirty_page_vcn;\n\ndo_redo_1:\n\t \n\tif (!dptbl || !dptbl->total)\n\t\tgoto do_undo_action;\n\n\trec_lsn = rlsn;\n\n\t \n\terr = read_log_rec_lcb(log, rlsn, lcb_ctx_next, &lcb);\n\tif (err)\n\t\tgoto out;\n\n\t \ndo_action_next:\n\tfrh = lcb->lrh;\n\n\tif (LfsClientRecord != frh->record_type)\n\t\tgoto read_next_log_do_action;\n\n\ttransact_id = le32_to_cpu(frh->transact_id);\n\trec_len = le32_to_cpu(frh->client_data_len);\n\tlrh = lcb->log_rec;\n\n\tif (!check_log_rec(lrh, rec_len, transact_id, bytes_per_attr_entry)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (lrh->lcns_follow)\n\t\tgoto find_dirty_page;\n\n\tgoto read_next_log_do_action;\n\nfind_dirty_page:\n\tt16 = le16_to_cpu(lrh->target_attr);\n\tt64 = le64_to_cpu(lrh->target_vcn);\n\tdp = find_dp(dptbl, t16, t64);\n\n\tif (!dp)\n\t\tgoto read_next_log_do_action;\n\n\tif (rec_lsn < le64_to_cpu(dp->oldest_lsn))\n\t\tgoto read_next_log_do_action;\n\n\tt16 = le16_to_cpu(lrh->target_attr);\n\tif (t16 >= bytes_per_rt(oatbl)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\toe = Add2Ptr(oatbl, t16);\n\n\tif (oe->next != RESTART_ENTRY_ALLOCATED_LE) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\toa = oe->ptr;\n\n\tif (!oa) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\tattr = oa->attr;\n\n\tvcn = le64_to_cpu(lrh->target_vcn);\n\n\tif (!run_lookup_entry(oa->run1, vcn, &lcn, NULL, NULL) ||\n\t    lcn == SPARSE_LCN) {\n\t\tgoto read_next_log_do_action;\n\t}\n\n\t \n\tdata = Add2Ptr(lrh, le16_to_cpu(lrh->redo_off));\n\tdlen = le16_to_cpu(lrh->redo_len);\n\n\t \n\tsaved_len = dlen;\n\n\tfor (i = le16_to_cpu(lrh->lcns_follow); i; i--) {\n\t\tsize_t j;\n\t\tu32 alen, voff;\n\n\t\tvoff = le16_to_cpu(lrh->record_off) +\n\t\t       le16_to_cpu(lrh->attr_off);\n\t\tvoff += le16_to_cpu(lrh->cluster_off) << SECTOR_SHIFT;\n\n\t\t \n\t\tj = le64_to_cpu(lrh->target_vcn) - le64_to_cpu(dp->vcn);\n\t\tif (dp->page_lcns[j + i - 1])\n\t\t\tbreak;\n\n\t\tif (!saved_len)\n\t\t\tsaved_len = 1;\n\n\t\t \n\t\talen = (i - 1) << sbi->cluster_bits;\n\n\t\t \n\t\tif (voff >= alen)\n\t\t\tdlen = 0;\n\t\telse if (voff + dlen > alen)\n\t\t\tdlen = alen - voff;\n\t}\n\n\t \n\tif (!dlen && saved_len)\n\t\tgoto read_next_log_do_action;\n\n\tt16 = le16_to_cpu(lrh->redo_op);\n\tif (can_skip_action(t16))\n\t\tgoto read_next_log_do_action;\n\n\t \n\terr = do_action(log, oe, lrh, t16, data, dlen, rec_len, &rec_lsn);\n\tif (err)\n\t\tgoto out;\n\n\t \nread_next_log_do_action:\n\terr = read_next_log_rec(log, lcb, &rec_lsn);\n\tif (!err && rec_lsn)\n\t\tgoto do_action_next;\n\n\tlcb_put(lcb);\n\tlcb = NULL;\n\ndo_undo_action:\n\t \n\ttr = NULL;\ntransaction_table_next:\n\ttr = enum_rstbl(trtbl, tr);\n\tif (!tr)\n\t\tgoto undo_action_done;\n\n\tif (TransactionActive != tr->transact_state || !tr->undo_next_lsn) {\n\t\tfree_rsttbl_idx(trtbl, PtrOffset(trtbl, tr));\n\t\tgoto transaction_table_next;\n\t}\n\n\tlog->transaction_id = PtrOffset(trtbl, tr);\n\tundo_next_lsn = le64_to_cpu(tr->undo_next_lsn);\n\n\t \n\tif (!undo_next_lsn)\n\t\tgoto commit_undo;\n\n\t \n\terr = read_log_rec_lcb(log, undo_next_lsn, lcb_ctx_undo_next, &lcb);\n\tif (err)\n\t\tgoto out;\n\n\t \nundo_action_next:\n\n\tlrh = lcb->log_rec;\n\tfrh = lcb->lrh;\n\ttransact_id = le32_to_cpu(frh->transact_id);\n\trec_len = le32_to_cpu(frh->client_data_len);\n\n\tif (!check_log_rec(lrh, rec_len, transact_id, bytes_per_attr_entry)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (lrh->undo_op == cpu_to_le16(Noop))\n\t\tgoto read_next_log_undo_action;\n\n\toe = Add2Ptr(oatbl, le16_to_cpu(lrh->target_attr));\n\toa = oe->ptr;\n\n\tt16 = le16_to_cpu(lrh->lcns_follow);\n\tif (!t16)\n\t\tgoto add_allocated_vcns;\n\n\tis_mapped = run_lookup_entry(oa->run1, le64_to_cpu(lrh->target_vcn),\n\t\t\t\t     &lcn, &clen, NULL);\n\n\t \n\tif (is_mapped && lcn != SPARSE_LCN && clen >= t16)\n\t\tgoto add_allocated_vcns;\n\n\tvcn = le64_to_cpu(lrh->target_vcn);\n\tvcn &= ~(u64)(log->clst_per_page - 1);\n\nadd_allocated_vcns:\n\tfor (i = 0, vcn = le64_to_cpu(lrh->target_vcn),\n\t    size = (vcn + 1) << sbi->cluster_bits;\n\t     i < t16; i++, vcn += 1, size += sbi->cluster_size) {\n\t\tattr = oa->attr;\n\t\tif (!attr->non_res) {\n\t\t\tif (size > le32_to_cpu(attr->res.data_size))\n\t\t\t\tattr->res.data_size = cpu_to_le32(size);\n\t\t} else {\n\t\t\tif (size > le64_to_cpu(attr->nres.data_size))\n\t\t\t\tattr->nres.valid_size = attr->nres.data_size =\n\t\t\t\t\tattr->nres.alloc_size =\n\t\t\t\t\t\tcpu_to_le64(size);\n\t\t}\n\t}\n\n\tt16 = le16_to_cpu(lrh->undo_op);\n\tif (can_skip_action(t16))\n\t\tgoto read_next_log_undo_action;\n\n\t \n\tdata = Add2Ptr(lrh, le16_to_cpu(lrh->undo_off));\n\tdlen = le16_to_cpu(lrh->undo_len);\n\n\t \n\terr = do_action(log, oe, lrh, t16, data, dlen, rec_len, NULL);\n\nread_next_log_undo_action:\n\t \n\terr = read_next_log_rec(log, lcb, &rec_lsn);\n\tif (err)\n\t\tgoto out;\n\n\tif (rec_lsn)\n\t\tgoto undo_action_next;\n\n\tlcb_put(lcb);\n\tlcb = NULL;\n\ncommit_undo:\n\tfree_rsttbl_idx(trtbl, log->transaction_id);\n\n\tlog->transaction_id = 0;\n\n\tgoto transaction_table_next;\n\nundo_action_done:\n\n\tntfs_update_mftmirr(sbi, 0);\n\n\tsbi->flags &= ~NTFS_FLAGS_NEED_REPLAY;\n\nend_reply:\n\n\terr = 0;\n\tif (is_ro)\n\t\tgoto out;\n\n\trh = kzalloc(log->page_size, GFP_NOFS);\n\tif (!rh) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\trh->rhdr.sign = NTFS_RSTR_SIGNATURE;\n\trh->rhdr.fix_off = cpu_to_le16(offsetof(struct RESTART_HDR, fixups));\n\tt16 = (log->page_size >> SECTOR_SHIFT) + 1;\n\trh->rhdr.fix_num = cpu_to_le16(t16);\n\trh->sys_page_size = cpu_to_le32(log->page_size);\n\trh->page_size = cpu_to_le32(log->page_size);\n\n\tt16 = ALIGN(offsetof(struct RESTART_HDR, fixups) + sizeof(short) * t16,\n\t\t    8);\n\trh->ra_off = cpu_to_le16(t16);\n\trh->minor_ver = cpu_to_le16(1); \n\trh->major_ver = cpu_to_le16(1); \n\n\tra2 = Add2Ptr(rh, t16);\n\tmemcpy(ra2, ra, sizeof(struct RESTART_AREA));\n\n\tra2->client_idx[0] = 0;\n\tra2->client_idx[1] = LFS_NO_CLIENT_LE;\n\tra2->flags = cpu_to_le16(2);\n\n\tle32_add_cpu(&ra2->open_log_count, 1);\n\n\tntfs_fix_pre_write(&rh->rhdr, log->page_size);\n\n\terr = ntfs_sb_write_run(sbi, &ni->file.run, 0, rh, log->page_size, 0);\n\tif (!err)\n\t\terr = ntfs_sb_write_run(sbi, &log->ni->file.run, log->page_size,\n\t\t\t\t\trh, log->page_size, 0);\n\n\tkfree(rh);\n\tif (err)\n\t\tgoto out;\n\nout:\n\tkfree(rst);\n\tif (lcb)\n\t\tlcb_put(lcb);\n\n\t \n\toe = NULL;\n\twhile ((oe = enum_rstbl(oatbl, oe))) {\n\t\trno = ino_get(&oe->ref);\n\n\t\tif (oe->is_attr_name == 1) {\n\t\t\tkfree(oe->ptr);\n\t\t\toe->ptr = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (oe->is_attr_name)\n\t\t\tcontinue;\n\n\t\toa = oe->ptr;\n\t\tif (!oa)\n\t\t\tcontinue;\n\n\t\trun_close(&oa->run0);\n\t\tkfree(oa->attr);\n\t\tif (oa->ni)\n\t\t\tiput(&oa->ni->vfs_inode);\n\t\tkfree(oa);\n\t}\n\n\tkfree(trtbl);\n\tkfree(oatbl);\n\tkfree(dptbl);\n\tkfree(attr_names);\n\tkfree(rst_info.r_page);\n\n\tkfree(ra);\n\tkfree(log->one_page_buf);\n\n\tif (err)\n\t\tsbi->flags |= NTFS_FLAGS_NEED_REPLAY;\n\n\tif (err == -EROFS)\n\t\terr = 0;\n\telse if (log->set_dirty)\n\t\tntfs_set_state(sbi, NTFS_DIRTY_ERROR);\n\n\tkfree(log);\n\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}