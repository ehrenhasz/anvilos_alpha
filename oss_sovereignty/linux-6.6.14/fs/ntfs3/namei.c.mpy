{
  "module_name": "namei.c",
  "hash_id": "2cca62ae7c881cc2756cb510d8a3594c00f9989c781f6b121792589427ad0d64",
  "original_prompt": "Ingested from linux-6.6.14/fs/ntfs3/namei.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/ctype.h>\n#include <linux/posix_acl.h>\n\n#include \"debug.h\"\n#include \"ntfs.h\"\n#include \"ntfs_fs.h\"\n\n \nint fill_name_de(struct ntfs_sb_info *sbi, void *buf, const struct qstr *name,\n\t\t const struct cpu_str *uni)\n{\n\tint err;\n\tstruct NTFS_DE *e = buf;\n\tu16 data_size;\n\tstruct ATTR_FILE_NAME *fname = (struct ATTR_FILE_NAME *)(e + 1);\n\n#ifndef CONFIG_NTFS3_64BIT_CLUSTER\n\te->ref.high = fname->home.high = 0;\n#endif\n\tif (uni) {\n#ifdef __BIG_ENDIAN\n\t\tint ulen = uni->len;\n\t\t__le16 *uname = fname->name;\n\t\tconst u16 *name_cpu = uni->name;\n\n\t\twhile (ulen--)\n\t\t\t*uname++ = cpu_to_le16(*name_cpu++);\n#else\n\t\tmemcpy(fname->name, uni->name, uni->len * sizeof(u16));\n#endif\n\t\tfname->name_len = uni->len;\n\n\t} else {\n\t\t \n\t\terr = ntfs_nls_to_utf16(sbi, name->name, name->len,\n\t\t\t\t\t(struct cpu_str *)&fname->name_len,\n\t\t\t\t\tNTFS_NAME_LEN, UTF16_LITTLE_ENDIAN);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tfname->type = FILE_NAME_POSIX;\n\tdata_size = fname_full_size(fname);\n\n\te->size = cpu_to_le16(ALIGN(data_size, 8) + sizeof(struct NTFS_DE));\n\te->key_size = cpu_to_le16(data_size);\n\te->flags = 0;\n\te->res = 0;\n\n\treturn 0;\n}\n\n \nstatic struct dentry *ntfs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t  u32 flags)\n{\n\tstruct ntfs_inode *ni = ntfs_i(dir);\n\tstruct cpu_str *uni = __getname();\n\tstruct inode *inode;\n\tint err;\n\n\tif (!uni)\n\t\tinode = ERR_PTR(-ENOMEM);\n\telse {\n\t\terr = ntfs_nls_to_utf16(ni->mi.sbi, dentry->d_name.name,\n\t\t\t\t\tdentry->d_name.len, uni, NTFS_NAME_LEN,\n\t\t\t\t\tUTF16_HOST_ENDIAN);\n\t\tif (err < 0)\n\t\t\tinode = ERR_PTR(err);\n\t\telse {\n\t\t\tni_lock(ni);\n\t\t\tinode = dir_search_u(dir, uni, NULL);\n\t\t\tni_unlock(ni);\n\t\t}\n\t\t__putname(uni);\n\t}\n\n\t \n\tif (!IS_ERR_OR_NULL(inode) && !inode->i_op) {\n\t\tiput(inode);\n\t\tinode = ERR_PTR(-EINVAL);\n\t}\n\n\treturn d_splice_alias(inode, dentry);\n}\n\n \nstatic int ntfs_create(struct mnt_idmap *idmap, struct inode *dir,\n\t\t       struct dentry *dentry, umode_t mode, bool excl)\n{\n\tstruct inode *inode;\n\n\tinode = ntfs_create_inode(idmap, dir, dentry, NULL, S_IFREG | mode, 0,\n\t\t\t\t  NULL, 0, NULL);\n\n\treturn IS_ERR(inode) ? PTR_ERR(inode) : 0;\n}\n\n \nstatic int ntfs_mknod(struct mnt_idmap *idmap, struct inode *dir,\n\t\t      struct dentry *dentry, umode_t mode, dev_t rdev)\n{\n\tstruct inode *inode;\n\n\tinode = ntfs_create_inode(idmap, dir, dentry, NULL, mode, rdev, NULL, 0,\n\t\t\t\t  NULL);\n\n\treturn IS_ERR(inode) ? PTR_ERR(inode) : 0;\n}\n\n \nstatic int ntfs_link(struct dentry *ode, struct inode *dir, struct dentry *de)\n{\n\tint err;\n\tstruct inode *inode = d_inode(ode);\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn -EPERM;\n\n\tif (inode->i_nlink >= NTFS_LINK_MAX)\n\t\treturn -EMLINK;\n\n\tni_lock_dir(ntfs_i(dir));\n\tif (inode != dir)\n\t\tni_lock(ni);\n\n\tinc_nlink(inode);\n\tihold(inode);\n\n\terr = ntfs_link_inode(inode, de);\n\n\tif (!err) {\n\t\tdir->i_mtime = inode_set_ctime_to_ts(\n\t\t\tinode, inode_set_ctime_current(dir));\n\t\tmark_inode_dirty(inode);\n\t\tmark_inode_dirty(dir);\n\t\td_instantiate(de, inode);\n\t} else {\n\t\tdrop_nlink(inode);\n\t\tiput(inode);\n\t}\n\n\tif (inode != dir)\n\t\tni_unlock(ni);\n\tni_unlock(ntfs_i(dir));\n\n\treturn err;\n}\n\n \nstatic int ntfs_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct ntfs_inode *ni = ntfs_i(dir);\n\tint err;\n\n\tni_lock_dir(ni);\n\n\terr = ntfs_unlink_inode(dir, dentry);\n\n\tni_unlock(ni);\n\n\treturn err;\n}\n\n \nstatic int ntfs_symlink(struct mnt_idmap *idmap, struct inode *dir,\n\t\t\tstruct dentry *dentry, const char *symname)\n{\n\tu32 size = strlen(symname);\n\tstruct inode *inode;\n\n\tinode = ntfs_create_inode(idmap, dir, dentry, NULL, S_IFLNK | 0777, 0,\n\t\t\t\t  symname, size, NULL);\n\n\treturn IS_ERR(inode) ? PTR_ERR(inode) : 0;\n}\n\n \nstatic int ntfs_mkdir(struct mnt_idmap *idmap, struct inode *dir,\n\t\t      struct dentry *dentry, umode_t mode)\n{\n\tstruct inode *inode;\n\n\tinode = ntfs_create_inode(idmap, dir, dentry, NULL, S_IFDIR | mode, 0,\n\t\t\t\t  NULL, 0, NULL);\n\n\treturn IS_ERR(inode) ? PTR_ERR(inode) : 0;\n}\n\n \nstatic int ntfs_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tstruct ntfs_inode *ni = ntfs_i(dir);\n\tint err;\n\n\tni_lock_dir(ni);\n\n\terr = ntfs_unlink_inode(dir, dentry);\n\n\tni_unlock(ni);\n\n\treturn err;\n}\n\n \nstatic int ntfs_rename(struct mnt_idmap *idmap, struct inode *dir,\n\t\t       struct dentry *dentry, struct inode *new_dir,\n\t\t       struct dentry *new_dentry, u32 flags)\n{\n\tint err;\n\tstruct super_block *sb = dir->i_sb;\n\tstruct ntfs_sb_info *sbi = sb->s_fs_info;\n\tstruct ntfs_inode *dir_ni = ntfs_i(dir);\n\tstruct ntfs_inode *new_dir_ni = ntfs_i(new_dir);\n\tstruct inode *inode = d_inode(dentry);\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tstruct inode *new_inode = d_inode(new_dentry);\n\tstruct NTFS_DE *de, *new_de;\n\tbool is_same, is_bad;\n\t \n\tstatic_assert(SIZEOF_ATTRIBUTE_FILENAME_MAX + SIZEOF_RESIDENT < 1024);\n\tstatic_assert(SIZEOF_ATTRIBUTE_FILENAME_MAX + sizeof(struct NTFS_DE) <\n\t\t      1024);\n\tstatic_assert(PATH_MAX >= 4 * 1024);\n\n\tif (flags & ~RENAME_NOREPLACE)\n\t\treturn -EINVAL;\n\n\tis_same = dentry->d_name.len == new_dentry->d_name.len &&\n\t\t  !memcmp(dentry->d_name.name, new_dentry->d_name.name,\n\t\t\t  dentry->d_name.len);\n\n\tif (is_same && dir == new_dir) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tif (ntfs_is_meta_file(sbi, inode->i_ino)) {\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\tif (new_inode) {\n\t\t \n\t\tdget(new_dentry);\n\t\tni_lock_dir(new_dir_ni);\n\t\terr = ntfs_unlink_inode(new_dir, new_dentry);\n\t\tni_unlock(new_dir_ni);\n\t\tdput(new_dentry);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tde = __getname();\n\tif (!de)\n\t\treturn -ENOMEM;\n\n\t \n\terr = fill_name_de(sbi, de, &dentry->d_name, NULL);\n\tif (err < 0)\n\t\tgoto out;\n\n\tif (is_same) {\n\t\t \n\t\tnew_de = de;\n\t} else {\n\t\t \n\t\tnew_de = Add2Ptr(de, 2048);\n\t\terr = fill_name_de(sbi, new_de, &new_dentry->d_name, NULL);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\n\tni_lock_dir(dir_ni);\n\tni_lock(ni);\n\tif (dir_ni != new_dir_ni)\n\t\tni_lock_dir2(new_dir_ni);\n\n\tis_bad = false;\n\terr = ni_rename(dir_ni, new_dir_ni, ni, de, new_de, &is_bad);\n\tif (is_bad) {\n\t\t \n\t\t_ntfs_bad_inode(inode);\n\t} else if (!err) {\n\t\tsimple_rename_timestamp(dir, dentry, new_dir, new_dentry);\n\t\tmark_inode_dirty(inode);\n\t\tmark_inode_dirty(dir);\n\t\tif (dir != new_dir)\n\t\t\tmark_inode_dirty(new_dir);\n\n\t\tif (IS_DIRSYNC(dir))\n\t\t\tntfs_sync_inode(dir);\n\n\t\tif (IS_DIRSYNC(new_dir))\n\t\t\tntfs_sync_inode(inode);\n\t}\n\n\tif (dir_ni != new_dir_ni)\n\t\tni_unlock(new_dir_ni);\n\tni_unlock(ni);\n\tni_unlock(dir_ni);\nout:\n\t__putname(de);\n\treturn err;\n}\n\n \nstatic int ntfs_atomic_open(struct inode *dir, struct dentry *dentry,\n\t\t\t    struct file *file, u32 flags, umode_t mode)\n{\n\tint err;\n\tstruct inode *inode;\n\tstruct ntfs_fnd *fnd = NULL;\n\tstruct ntfs_inode *ni = ntfs_i(dir);\n\tstruct dentry *d = NULL;\n\tstruct cpu_str *uni = __getname();\n\tbool locked = false;\n\n\tif (!uni)\n\t\treturn -ENOMEM;\n\n\terr = ntfs_nls_to_utf16(ni->mi.sbi, dentry->d_name.name,\n\t\t\t\tdentry->d_name.len, uni, NTFS_NAME_LEN,\n\t\t\t\tUTF16_HOST_ENDIAN);\n\tif (err < 0)\n\t\tgoto out;\n\n#ifdef CONFIG_NTFS3_FS_POSIX_ACL\n\tif (IS_POSIXACL(dir)) {\n\t\t \n\t\tstruct posix_acl *p = get_inode_acl(dir, ACL_TYPE_DEFAULT);\n\n\t\tif (IS_ERR(p)) {\n\t\t\terr = PTR_ERR(p);\n\t\t\tgoto out;\n\t\t}\n\t\tposix_acl_release(p);\n\t}\n#endif\n\n\tif (d_in_lookup(dentry)) {\n\t\tni_lock_dir(ni);\n\t\tlocked = true;\n\t\tfnd = fnd_get();\n\t\tif (!fnd) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out1;\n\t\t}\n\n\t\td = d_splice_alias(dir_search_u(dir, uni, fnd), dentry);\n\t\tif (IS_ERR(d)) {\n\t\t\terr = PTR_ERR(d);\n\t\t\td = NULL;\n\t\t\tgoto out2;\n\t\t}\n\n\t\tif (d)\n\t\t\tdentry = d;\n\t}\n\n\tif (!(flags & O_CREAT) || d_really_is_positive(dentry)) {\n\t\terr = finish_no_open(file, d);\n\t\tgoto out2;\n\t}\n\n\tfile->f_mode |= FMODE_CREATED;\n\n\t \n\tinode = ntfs_create_inode(mnt_idmap(file->f_path.mnt), dir, dentry, uni,\n\t\t\t\t  mode, 0, NULL, 0, fnd);\n\terr = IS_ERR(inode) ? PTR_ERR(inode) :\n\t\t\t      finish_open(file, dentry, ntfs_file_open);\n\tdput(d);\n\nout2:\n\tfnd_put(fnd);\nout1:\n\tif (locked)\n\t\tni_unlock(ni);\nout:\n\t__putname(uni);\n\treturn err;\n}\n\nstruct dentry *ntfs3_get_parent(struct dentry *child)\n{\n\tstruct inode *inode = d_inode(child);\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\n\tstruct ATTR_LIST_ENTRY *le = NULL;\n\tstruct ATTRIB *attr = NULL;\n\tstruct ATTR_FILE_NAME *fname;\n\n\twhile ((attr = ni_find_attr(ni, attr, &le, ATTR_NAME, NULL, 0, NULL,\n\t\t\t\t    NULL))) {\n\t\tfname = resident_data_ex(attr, SIZEOF_ATTRIBUTE_FILENAME);\n\t\tif (!fname)\n\t\t\tcontinue;\n\n\t\treturn d_obtain_alias(\n\t\t\tntfs_iget5(inode->i_sb, &fname->home, NULL));\n\t}\n\n\treturn ERR_PTR(-ENOENT);\n}\n\n \nstatic int ntfs_d_hash(const struct dentry *dentry, struct qstr *name)\n{\n\tstruct ntfs_sb_info *sbi;\n\tconst char *n = name->name;\n\tunsigned int len = name->len;\n\tunsigned long hash;\n\tstruct cpu_str *uni;\n\tunsigned int c;\n\tint err;\n\n\t \n\thash = init_name_hash(dentry);\n\n\tfor (;;) {\n\t\tif (!len--) {\n\t\t\tname->hash = end_name_hash(hash);\n\t\t\treturn 0;\n\t\t}\n\n\t\tc = *n++;\n\t\tif (c >= 0x80)\n\t\t\tbreak;\n\n\t\thash = partial_name_hash(toupper(c), hash);\n\t}\n\n\t \n\tuni = __getname();\n\tif (!uni)\n\t\treturn -ENOMEM;\n\n\tsbi = dentry->d_sb->s_fs_info;\n\n\terr = ntfs_nls_to_utf16(sbi, name->name, name->len, uni, NTFS_NAME_LEN,\n\t\t\t\tUTF16_HOST_ENDIAN);\n\tif (err < 0)\n\t\tgoto out;\n\n\tif (!err) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\thash = ntfs_names_hash(uni->name, uni->len, sbi->upcase,\n\t\t\t       init_name_hash(dentry));\n\tname->hash = end_name_hash(hash);\n\terr = 0;\n\nout:\n\t__putname(uni);\n\treturn err;\n}\n\n \nstatic int ntfs_d_compare(const struct dentry *dentry, unsigned int len1,\n\t\t\t  const char *str, const struct qstr *name)\n{\n\tstruct ntfs_sb_info *sbi;\n\tint ret;\n\tconst char *n1 = str;\n\tconst char *n2 = name->name;\n\tunsigned int len2 = name->len;\n\tunsigned int lm = min(len1, len2);\n\tunsigned char c1, c2;\n\tstruct cpu_str *uni1;\n\tstruct le_str *uni2;\n\n\t \n\tfor (;;) {\n\t\tif (!lm--)\n\t\t\treturn len1 != len2;\n\n\t\tif ((c1 = *n1++) == (c2 = *n2++))\n\t\t\tcontinue;\n\n\t\tif (c1 >= 0x80 || c2 >= 0x80)\n\t\t\tbreak;\n\n\t\tif (toupper(c1) != toupper(c2))\n\t\t\treturn 1;\n\t}\n\n\t \n\tsbi = dentry->d_sb->s_fs_info;\n\tuni1 = __getname();\n\tif (!uni1)\n\t\treturn -ENOMEM;\n\n\tret = ntfs_nls_to_utf16(sbi, str, len1, uni1, NTFS_NAME_LEN,\n\t\t\t\tUTF16_HOST_ENDIAN);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (!ret) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tuni2 = Add2Ptr(uni1, 2048);\n\n\tret = ntfs_nls_to_utf16(sbi, name->name, name->len,\n\t\t\t\t(struct cpu_str *)uni2, NTFS_NAME_LEN,\n\t\t\t\tUTF16_LITTLE_ENDIAN);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (!ret) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = !ntfs_cmp_names_cpu(uni1, uni2, sbi->upcase, false) ? 0 : 1;\n\nout:\n\t__putname(uni1);\n\treturn ret;\n}\n\n\nconst struct inode_operations ntfs_dir_inode_operations = {\n\t.lookup\t\t= ntfs_lookup,\n\t.create\t\t= ntfs_create,\n\t.link\t\t= ntfs_link,\n\t.unlink\t\t= ntfs_unlink,\n\t.symlink\t= ntfs_symlink,\n\t.mkdir\t\t= ntfs_mkdir,\n\t.rmdir\t\t= ntfs_rmdir,\n\t.mknod\t\t= ntfs_mknod,\n\t.rename\t\t= ntfs_rename,\n\t.get_acl\t= ntfs_get_acl,\n\t.set_acl\t= ntfs_set_acl,\n\t.setattr\t= ntfs3_setattr,\n\t.getattr\t= ntfs_getattr,\n\t.listxattr\t= ntfs_listxattr,\n\t.atomic_open\t= ntfs_atomic_open,\n\t.fiemap\t\t= ntfs_fiemap,\n};\n\nconst struct inode_operations ntfs_special_inode_operations = {\n\t.setattr\t= ntfs3_setattr,\n\t.getattr\t= ntfs_getattr,\n\t.listxattr\t= ntfs_listxattr,\n\t.get_acl\t= ntfs_get_acl,\n\t.set_acl\t= ntfs_set_acl,\n};\n\nconst struct dentry_operations ntfs_dentry_ops = {\n\t.d_hash\t\t= ntfs_d_hash,\n\t.d_compare\t= ntfs_d_compare,\n};\n\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}