{
  "module_name": "frecord.c",
  "hash_id": "8451534d79772a713275d04dacc9e0a38e887cce98de5212ba32181f267418df",
  "original_prompt": "Ingested from linux-6.6.14/fs/ntfs3/frecord.c",
  "human_readable_source": "\n \n\n#include <linux/fiemap.h>\n#include <linux/fs.h>\n#include <linux/minmax.h>\n#include <linux/vmalloc.h>\n\n#include \"debug.h\"\n#include \"ntfs.h\"\n#include \"ntfs_fs.h\"\n#ifdef CONFIG_NTFS3_LZX_XPRESS\n#include \"lib/lib.h\"\n#endif\n\nstatic struct mft_inode *ni_ins_mi(struct ntfs_inode *ni, struct rb_root *tree,\n\t\t\t\t   CLST ino, struct rb_node *ins)\n{\n\tstruct rb_node **p = &tree->rb_node;\n\tstruct rb_node *pr = NULL;\n\n\twhile (*p) {\n\t\tstruct mft_inode *mi;\n\n\t\tpr = *p;\n\t\tmi = rb_entry(pr, struct mft_inode, node);\n\t\tif (mi->rno > ino)\n\t\t\tp = &pr->rb_left;\n\t\telse if (mi->rno < ino)\n\t\t\tp = &pr->rb_right;\n\t\telse\n\t\t\treturn mi;\n\t}\n\n\tif (!ins)\n\t\treturn NULL;\n\n\trb_link_node(ins, pr, p);\n\trb_insert_color(ins, tree);\n\treturn rb_entry(ins, struct mft_inode, node);\n}\n\n \nstatic struct mft_inode *ni_find_mi(struct ntfs_inode *ni, CLST rno)\n{\n\treturn ni_ins_mi(ni, &ni->mi_tree, rno, NULL);\n}\n\n \nstatic void ni_add_mi(struct ntfs_inode *ni, struct mft_inode *mi)\n{\n\tni_ins_mi(ni, &ni->mi_tree, mi->rno, &mi->node);\n}\n\n \nvoid ni_remove_mi(struct ntfs_inode *ni, struct mft_inode *mi)\n{\n\trb_erase(&mi->node, &ni->mi_tree);\n}\n\n \nstruct ATTR_STD_INFO *ni_std(struct ntfs_inode *ni)\n{\n\tconst struct ATTRIB *attr;\n\n\tattr = mi_find_attr(&ni->mi, NULL, ATTR_STD, NULL, 0, NULL);\n\treturn attr ? resident_data_ex(attr, sizeof(struct ATTR_STD_INFO)) :\n\t\t      NULL;\n}\n\n \nstruct ATTR_STD_INFO5 *ni_std5(struct ntfs_inode *ni)\n{\n\tconst struct ATTRIB *attr;\n\n\tattr = mi_find_attr(&ni->mi, NULL, ATTR_STD, NULL, 0, NULL);\n\n\treturn attr ? resident_data_ex(attr, sizeof(struct ATTR_STD_INFO5)) :\n\t\t      NULL;\n}\n\n \nvoid ni_clear(struct ntfs_inode *ni)\n{\n\tstruct rb_node *node;\n\n\tif (!ni->vfs_inode.i_nlink && ni->mi.mrec && is_rec_inuse(ni->mi.mrec))\n\t\tni_delete_all(ni);\n\n\tal_destroy(ni);\n\n\tfor (node = rb_first(&ni->mi_tree); node;) {\n\t\tstruct rb_node *next = rb_next(node);\n\t\tstruct mft_inode *mi = rb_entry(node, struct mft_inode, node);\n\n\t\trb_erase(node, &ni->mi_tree);\n\t\tmi_put(mi);\n\t\tnode = next;\n\t}\n\n\t \n\tif (ni->ni_flags & NI_FLAG_DIR)\n\t\tindx_clear(&ni->dir);\n\telse {\n\t\trun_close(&ni->file.run);\n#ifdef CONFIG_NTFS3_LZX_XPRESS\n\t\tif (ni->file.offs_page) {\n\t\t\t \n\t\t\tput_page(ni->file.offs_page);\n\t\t\tni->file.offs_page = NULL;\n\t\t}\n#endif\n\t}\n\n\tmi_clear(&ni->mi);\n}\n\n \nint ni_load_mi_ex(struct ntfs_inode *ni, CLST rno, struct mft_inode **mi)\n{\n\tint err;\n\tstruct mft_inode *r;\n\n\tr = ni_find_mi(ni, rno);\n\tif (r)\n\t\tgoto out;\n\n\terr = mi_get(ni->mi.sbi, rno, &r);\n\tif (err)\n\t\treturn err;\n\n\tni_add_mi(ni, r);\n\nout:\n\tif (mi)\n\t\t*mi = r;\n\treturn 0;\n}\n\n \nint ni_load_mi(struct ntfs_inode *ni, const struct ATTR_LIST_ENTRY *le,\n\t       struct mft_inode **mi)\n{\n\tCLST rno;\n\n\tif (!le) {\n\t\t*mi = &ni->mi;\n\t\treturn 0;\n\t}\n\n\trno = ino_get(&le->ref);\n\tif (rno == ni->mi.rno) {\n\t\t*mi = &ni->mi;\n\t\treturn 0;\n\t}\n\treturn ni_load_mi_ex(ni, rno, mi);\n}\n\n \nstruct ATTRIB *ni_find_attr(struct ntfs_inode *ni, struct ATTRIB *attr,\n\t\t\t    struct ATTR_LIST_ENTRY **le_o, enum ATTR_TYPE type,\n\t\t\t    const __le16 *name, u8 name_len, const CLST *vcn,\n\t\t\t    struct mft_inode **mi)\n{\n\tstruct ATTR_LIST_ENTRY *le;\n\tstruct mft_inode *m;\n\n\tif (!ni->attr_list.size ||\n\t    (!name_len && (type == ATTR_LIST || type == ATTR_STD))) {\n\t\tif (le_o)\n\t\t\t*le_o = NULL;\n\t\tif (mi)\n\t\t\t*mi = &ni->mi;\n\n\t\t \n\t\treturn mi_find_attr(&ni->mi, attr, type, name, name_len, NULL);\n\t}\n\n\t \n\tle = al_find_ex(ni, le_o ? *le_o : NULL, type, name, name_len, vcn);\n\tif (!le)\n\t\treturn NULL;\n\n\tif (le_o)\n\t\t*le_o = le;\n\n\t \n\tif (ni_load_mi(ni, le, &m))\n\t\treturn NULL;\n\n\t \n\tattr = mi_find_attr(m, NULL, type, name, name_len, &le->id);\n\n\tif (!attr)\n\t\tgoto out;\n\n\tif (!attr->non_res) {\n\t\tif (vcn && *vcn)\n\t\t\tgoto out;\n\t} else if (!vcn) {\n\t\tif (attr->nres.svcn)\n\t\t\tgoto out;\n\t} else if (le64_to_cpu(attr->nres.svcn) > *vcn ||\n\t\t   *vcn > le64_to_cpu(attr->nres.evcn)) {\n\t\tgoto out;\n\t}\n\n\tif (mi)\n\t\t*mi = m;\n\treturn attr;\n\nout:\n\tntfs_inode_err(&ni->vfs_inode, \"failed to parse mft record\");\n\tntfs_set_state(ni->mi.sbi, NTFS_DIRTY_ERROR);\n\treturn NULL;\n}\n\n \nstruct ATTRIB *ni_enum_attr_ex(struct ntfs_inode *ni, struct ATTRIB *attr,\n\t\t\t       struct ATTR_LIST_ENTRY **le,\n\t\t\t       struct mft_inode **mi)\n{\n\tstruct mft_inode *mi2;\n\tstruct ATTR_LIST_ENTRY *le2;\n\n\t \n\tif (!ni->attr_list.size) {\n\t\t*le = NULL;\n\t\tif (mi)\n\t\t\t*mi = &ni->mi;\n\t\t \n\t\treturn mi_enum_attr(&ni->mi, attr);\n\t}\n\n\t \n\tle2 = *le = al_enumerate(ni, attr ? *le : NULL);\n\tif (!le2)\n\t\treturn NULL;\n\n\t \n\tif (ni_load_mi(ni, le2, &mi2))\n\t\treturn NULL;\n\n\tif (mi)\n\t\t*mi = mi2;\n\n\t \n\treturn rec_find_attr_le(mi2, le2);\n}\n\n \nstruct ATTRIB *ni_load_attr(struct ntfs_inode *ni, enum ATTR_TYPE type,\n\t\t\t    const __le16 *name, u8 name_len, CLST vcn,\n\t\t\t    struct mft_inode **pmi)\n{\n\tstruct ATTR_LIST_ENTRY *le;\n\tstruct ATTRIB *attr;\n\tstruct mft_inode *mi;\n\tstruct ATTR_LIST_ENTRY *next;\n\n\tif (!ni->attr_list.size) {\n\t\tif (pmi)\n\t\t\t*pmi = &ni->mi;\n\t\treturn mi_find_attr(&ni->mi, NULL, type, name, name_len, NULL);\n\t}\n\n\tle = al_find_ex(ni, NULL, type, name, name_len, NULL);\n\tif (!le)\n\t\treturn NULL;\n\n\t \n\tif (vcn) {\n\t\tfor (;; le = next) {\n\t\t\tnext = al_find_ex(ni, le, type, name, name_len, NULL);\n\t\t\tif (!next || le64_to_cpu(next->vcn) > vcn)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ni_load_mi(ni, le, &mi))\n\t\treturn NULL;\n\n\tif (pmi)\n\t\t*pmi = mi;\n\n\tattr = mi_find_attr(mi, NULL, type, name, name_len, &le->id);\n\tif (!attr)\n\t\treturn NULL;\n\n\tif (!attr->non_res)\n\t\treturn attr;\n\n\tif (le64_to_cpu(attr->nres.svcn) <= vcn &&\n\t    vcn <= le64_to_cpu(attr->nres.evcn))\n\t\treturn attr;\n\n\treturn NULL;\n}\n\n \nint ni_load_all_mi(struct ntfs_inode *ni)\n{\n\tint err;\n\tstruct ATTR_LIST_ENTRY *le;\n\n\tif (!ni->attr_list.size)\n\t\treturn 0;\n\n\tle = NULL;\n\n\twhile ((le = al_enumerate(ni, le))) {\n\t\tCLST rno = ino_get(&le->ref);\n\n\t\tif (rno == ni->mi.rno)\n\t\t\tcontinue;\n\n\t\terr = ni_load_mi_ex(ni, rno, NULL);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nbool ni_add_subrecord(struct ntfs_inode *ni, CLST rno, struct mft_inode **mi)\n{\n\tstruct mft_inode *m;\n\n\tm = kzalloc(sizeof(struct mft_inode), GFP_NOFS);\n\tif (!m)\n\t\treturn false;\n\n\tif (mi_format_new(m, ni->mi.sbi, rno, 0, ni->mi.rno == MFT_REC_MFT)) {\n\t\tmi_put(m);\n\t\treturn false;\n\t}\n\n\tmi_get_ref(&ni->mi, &m->mrec->parent_ref);\n\n\tni_add_mi(ni, m);\n\t*mi = m;\n\treturn true;\n}\n\n \nint ni_remove_attr(struct ntfs_inode *ni, enum ATTR_TYPE type,\n\t\t   const __le16 *name, u8 name_len, bool base_only,\n\t\t   const __le16 *id)\n{\n\tint err;\n\tstruct ATTRIB *attr;\n\tstruct ATTR_LIST_ENTRY *le;\n\tstruct mft_inode *mi;\n\tu32 type_in;\n\tint diff;\n\n\tif (base_only || type == ATTR_LIST || !ni->attr_list.size) {\n\t\tattr = mi_find_attr(&ni->mi, NULL, type, name, name_len, id);\n\t\tif (!attr)\n\t\t\treturn -ENOENT;\n\n\t\tmi_remove_attr(ni, &ni->mi, attr);\n\t\treturn 0;\n\t}\n\n\ttype_in = le32_to_cpu(type);\n\tle = NULL;\n\n\tfor (;;) {\n\t\tle = al_enumerate(ni, le);\n\t\tif (!le)\n\t\t\treturn 0;\n\nnext_le2:\n\t\tdiff = le32_to_cpu(le->type) - type_in;\n\t\tif (diff < 0)\n\t\t\tcontinue;\n\n\t\tif (diff > 0)\n\t\t\treturn 0;\n\n\t\tif (le->name_len != name_len)\n\t\t\tcontinue;\n\n\t\tif (name_len &&\n\t\t    memcmp(le_name(le), name, name_len * sizeof(short)))\n\t\t\tcontinue;\n\n\t\tif (id && le->id != *id)\n\t\t\tcontinue;\n\t\terr = ni_load_mi(ni, le, &mi);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tal_remove_le(ni, le);\n\n\t\tattr = mi_find_attr(mi, NULL, type, name, name_len, id);\n\t\tif (!attr)\n\t\t\treturn -ENOENT;\n\n\t\tmi_remove_attr(ni, mi, attr);\n\n\t\tif (PtrOffset(ni->attr_list.le, le) >= ni->attr_list.size)\n\t\t\treturn 0;\n\t\tgoto next_le2;\n\t}\n}\n\n \nstatic struct ATTRIB *\nni_ins_new_attr(struct ntfs_inode *ni, struct mft_inode *mi,\n\t\tstruct ATTR_LIST_ENTRY *le, enum ATTR_TYPE type,\n\t\tconst __le16 *name, u8 name_len, u32 asize, u16 name_off,\n\t\tCLST svcn, struct ATTR_LIST_ENTRY **ins_le)\n{\n\tint err;\n\tstruct ATTRIB *attr;\n\tbool le_added = false;\n\tstruct MFT_REF ref;\n\n\tmi_get_ref(mi, &ref);\n\n\tif (type != ATTR_LIST && !le && ni->attr_list.size) {\n\t\terr = al_add_le(ni, type, name, name_len, svcn, cpu_to_le16(-1),\n\t\t\t\t&ref, &le);\n\t\tif (err) {\n\t\t\t \n\t\t\treturn ERR_PTR(err);\n\t\t}\n\t\tle_added = true;\n\n\t\t \n\t\tname = le->name;\n\t}\n\n\tattr = mi_insert_attr(mi, type, name, name_len, asize, name_off);\n\tif (!attr) {\n\t\tif (le_added)\n\t\t\tal_remove_le(ni, le);\n\t\treturn NULL;\n\t}\n\n\tif (type == ATTR_LIST) {\n\t\t \n\t\tgoto out;\n\t}\n\n\tif (!le)\n\t\tgoto out;\n\n\t \n\tle->id = attr->id;\n\tni->attr_list.dirty = true;\n\tle->ref = ref;\n\nout:\n\tif (ins_le)\n\t\t*ins_le = le;\n\treturn attr;\n}\n\n \nstatic int ni_repack(struct ntfs_inode *ni)\n{\n#if 1\n\treturn 0;\n#else\n\tint err = 0;\n\tstruct ntfs_sb_info *sbi = ni->mi.sbi;\n\tstruct mft_inode *mi, *mi_p = NULL;\n\tstruct ATTRIB *attr = NULL, *attr_p;\n\tstruct ATTR_LIST_ENTRY *le = NULL, *le_p;\n\tCLST alloc = 0;\n\tu8 cluster_bits = sbi->cluster_bits;\n\tCLST svcn, evcn = 0, svcn_p, evcn_p, next_svcn;\n\tu32 roff, rs = sbi->record_size;\n\tstruct runs_tree run;\n\n\trun_init(&run);\n\n\twhile ((attr = ni_enum_attr_ex(ni, attr, &le, &mi))) {\n\t\tif (!attr->non_res)\n\t\t\tcontinue;\n\n\t\tsvcn = le64_to_cpu(attr->nres.svcn);\n\t\tif (svcn != le64_to_cpu(le->vcn)) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!svcn) {\n\t\t\talloc = le64_to_cpu(attr->nres.alloc_size) >>\n\t\t\t\tcluster_bits;\n\t\t\tmi_p = NULL;\n\t\t} else if (svcn != evcn + 1) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tevcn = le64_to_cpu(attr->nres.evcn);\n\n\t\tif (svcn > evcn + 1) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!mi_p) {\n\t\t\t \n\t\t\tif (le32_to_cpu(mi->mrec->used) + 8 >= rs)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (evcn + 1 == alloc)\n\t\t\t\tcontinue;\n\t\t\trun_close(&run);\n\t\t}\n\n\t\troff = le16_to_cpu(attr->nres.run_off);\n\n\t\tif (roff > le32_to_cpu(attr->size)) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\terr = run_unpack(&run, sbi, ni->mi.rno, svcn, evcn, svcn,\n\t\t\t\t Add2Ptr(attr, roff),\n\t\t\t\t le32_to_cpu(attr->size) - roff);\n\t\tif (err < 0)\n\t\t\tbreak;\n\n\t\tif (!mi_p) {\n\t\t\tmi_p = mi;\n\t\t\tattr_p = attr;\n\t\t\tsvcn_p = svcn;\n\t\t\tevcn_p = evcn;\n\t\t\tle_p = le;\n\t\t\terr = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\terr = mi_pack_runs(mi_p, attr_p, &run, evcn + 1 - svcn_p);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tnext_svcn = le64_to_cpu(attr_p->nres.evcn) + 1;\n\n\t\tif (next_svcn >= evcn + 1) {\n\t\t\t \n\t\t\tal_remove_le(ni, le);\n\t\t\tmi_remove_attr(NULL, mi, attr);\n\t\t\tle = le_p;\n\t\t\tcontinue;\n\t\t}\n\n\t\tattr->nres.svcn = le->vcn = cpu_to_le64(next_svcn);\n\t\tmi->dirty = true;\n\t\tni->attr_list.dirty = true;\n\n\t\tif (evcn + 1 == alloc) {\n\t\t\terr = mi_pack_runs(mi, attr, &run,\n\t\t\t\t\t   evcn + 1 - next_svcn);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tmi_p = NULL;\n\t\t} else {\n\t\t\tmi_p = mi;\n\t\t\tattr_p = attr;\n\t\t\tsvcn_p = next_svcn;\n\t\t\tevcn_p = evcn;\n\t\t\tle_p = le;\n\t\t\trun_truncate_head(&run, next_svcn);\n\t\t}\n\t}\n\n\tif (err) {\n\t\tntfs_inode_warn(&ni->vfs_inode, \"repack problem\");\n\t\tntfs_set_state(sbi, NTFS_DIRTY_ERROR);\n\n\t\t \n\t\tif (mi_p)\n\t\t\tmi_pack_runs(mi_p, attr_p, &run, evcn_p + 1 - svcn_p);\n\t}\n\n\trun_close(&run);\n\treturn err;\n#endif\n}\n\n \nstatic int ni_try_remove_attr_list(struct ntfs_inode *ni)\n{\n\tint err = 0;\n\tstruct ntfs_sb_info *sbi = ni->mi.sbi;\n\tstruct ATTRIB *attr, *attr_list, *attr_ins;\n\tstruct ATTR_LIST_ENTRY *le;\n\tstruct mft_inode *mi;\n\tu32 asize, free;\n\tstruct MFT_REF ref;\n\tstruct MFT_REC *mrec;\n\t__le16 id;\n\n\tif (!ni->attr_list.dirty)\n\t\treturn 0;\n\n\terr = ni_repack(ni);\n\tif (err)\n\t\treturn err;\n\n\tattr_list = mi_find_attr(&ni->mi, NULL, ATTR_LIST, NULL, 0, NULL);\n\tif (!attr_list)\n\t\treturn 0;\n\n\tasize = le32_to_cpu(attr_list->size);\n\n\t \n\tfree = sbi->record_size - le32_to_cpu(ni->mi.mrec->used) + asize;\n\tmi_get_ref(&ni->mi, &ref);\n\n\tle = NULL;\n\twhile ((le = al_enumerate(ni, le))) {\n\t\tif (!memcmp(&le->ref, &ref, sizeof(ref)))\n\t\t\tcontinue;\n\n\t\tif (le->vcn)\n\t\t\treturn 0;\n\n\t\tmi = ni_find_mi(ni, ino_get(&le->ref));\n\t\tif (!mi)\n\t\t\treturn 0;\n\n\t\tattr = mi_find_attr(mi, NULL, le->type, le_name(le),\n\t\t\t\t    le->name_len, &le->id);\n\t\tif (!attr)\n\t\t\treturn 0;\n\n\t\tasize = le32_to_cpu(attr->size);\n\t\tif (asize > free)\n\t\t\treturn 0;\n\n\t\tfree -= asize;\n\t}\n\n\t \n\tmrec = kmemdup(ni->mi.mrec, sbi->record_size, GFP_NOFS);\n\tif (!mrec)\n\t\treturn 0;  \n\n\t \n\tmi_remove_attr(NULL, &ni->mi, attr_list);\n\n\t \n\tle = NULL;\n\twhile ((le = al_enumerate(ni, le))) {\n\t\tif (!memcmp(&le->ref, &ref, sizeof(ref)))\n\t\t\tcontinue;\n\n\t\tmi = ni_find_mi(ni, ino_get(&le->ref));\n\t\tif (!mi) {\n\t\t\t \n\t\t\tgoto out;\n\t\t}\n\n\t\tattr = mi_find_attr(mi, NULL, le->type, le_name(le),\n\t\t\t\t    le->name_len, &le->id);\n\t\tif (!attr) {\n\t\t\t \n\t\t\tgoto out;\n\t\t}\n\t\tasize = le32_to_cpu(attr->size);\n\n\t\t \n\t\tattr_ins = mi_insert_attr(&ni->mi, le->type, le_name(le),\n\t\t\t\t\t  le->name_len, asize,\n\t\t\t\t\t  le16_to_cpu(attr->name_off));\n\t\tif (!attr_ins) {\n\t\t\t \n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tid = attr_ins->id;\n\t\tmemcpy(attr_ins, attr, asize);\n\t\tattr_ins->id = id;\n\t}\n\n\t \n\tle = NULL;\n\twhile ((le = al_enumerate(ni, le))) {\n\t\tif (!memcmp(&le->ref, &ref, sizeof(ref)))\n\t\t\tcontinue;\n\n\t\tmi = ni_find_mi(ni, ino_get(&le->ref));\n\t\tif (!mi)\n\t\t\tcontinue;\n\n\t\tattr = mi_find_attr(mi, NULL, le->type, le_name(le),\n\t\t\t\t    le->name_len, &le->id);\n\t\tif (!attr)\n\t\t\tcontinue;\n\n\t\t \n\t\tmi_remove_attr(NULL, mi, attr);\n\t}\n\n\trun_deallocate(sbi, &ni->attr_list.run, true);\n\trun_close(&ni->attr_list.run);\n\tni->attr_list.size = 0;\n\tkfree(ni->attr_list.le);\n\tni->attr_list.le = NULL;\n\tni->attr_list.dirty = false;\n\n\tkfree(mrec);\n\treturn 0;\nout:\n\t \n\tswap(mrec, ni->mi.mrec);\n\tkfree(mrec);\n\treturn 0;\n}\n\n \nint ni_create_attr_list(struct ntfs_inode *ni)\n{\n\tstruct ntfs_sb_info *sbi = ni->mi.sbi;\n\tint err;\n\tu32 lsize;\n\tstruct ATTRIB *attr;\n\tstruct ATTRIB *arr_move[7];\n\tstruct ATTR_LIST_ENTRY *le, *le_b[7];\n\tstruct MFT_REC *rec;\n\tbool is_mft;\n\tCLST rno = 0;\n\tstruct mft_inode *mi;\n\tu32 free_b, nb, to_free, rs;\n\tu16 sz;\n\n\tis_mft = ni->mi.rno == MFT_REC_MFT;\n\trec = ni->mi.mrec;\n\trs = sbi->record_size;\n\n\t \n\tle = kmalloc(al_aligned(rs), GFP_NOFS);\n\tif (!le)\n\t\treturn -ENOMEM;\n\n\tmi_get_ref(&ni->mi, &le->ref);\n\tni->attr_list.le = le;\n\n\tattr = NULL;\n\tnb = 0;\n\tfree_b = 0;\n\tattr = NULL;\n\n\tfor (; (attr = mi_enum_attr(&ni->mi, attr)); le = Add2Ptr(le, sz)) {\n\t\tsz = le_size(attr->name_len);\n\t\tle->type = attr->type;\n\t\tle->size = cpu_to_le16(sz);\n\t\tle->name_len = attr->name_len;\n\t\tle->name_off = offsetof(struct ATTR_LIST_ENTRY, name);\n\t\tle->vcn = 0;\n\t\tif (le != ni->attr_list.le)\n\t\t\tle->ref = ni->attr_list.le->ref;\n\t\tle->id = attr->id;\n\n\t\tif (attr->name_len)\n\t\t\tmemcpy(le->name, attr_name(attr),\n\t\t\t       sizeof(short) * attr->name_len);\n\t\telse if (attr->type == ATTR_STD)\n\t\t\tcontinue;\n\t\telse if (attr->type == ATTR_LIST)\n\t\t\tcontinue;\n\t\telse if (is_mft && attr->type == ATTR_DATA)\n\t\t\tcontinue;\n\n\t\tif (!nb || nb < ARRAY_SIZE(arr_move)) {\n\t\t\tle_b[nb] = le;\n\t\t\tarr_move[nb++] = attr;\n\t\t\tfree_b += le32_to_cpu(attr->size);\n\t\t}\n\t}\n\n\tlsize = PtrOffset(ni->attr_list.le, le);\n\tni->attr_list.size = lsize;\n\n\tto_free = le32_to_cpu(rec->used) + lsize + SIZEOF_RESIDENT;\n\tif (to_free <= rs) {\n\t\tto_free = 0;\n\t} else {\n\t\tto_free -= rs;\n\n\t\tif (to_free > free_b) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\terr = ntfs_look_free_mft(sbi, &rno, is_mft, ni, &mi);\n\tif (err)\n\t\tgoto out;\n\n\terr = -EINVAL;\n\t \n\twhile (to_free > 0) {\n\t\tstruct ATTRIB *b = arr_move[--nb];\n\t\tu32 asize = le32_to_cpu(b->size);\n\t\tu16 name_off = le16_to_cpu(b->name_off);\n\n\t\tattr = mi_insert_attr(mi, b->type, Add2Ptr(b, name_off),\n\t\t\t\t      b->name_len, asize, name_off);\n\t\tif (!attr)\n\t\t\tgoto out;\n\n\t\tmi_get_ref(mi, &le_b[nb]->ref);\n\t\tle_b[nb]->id = attr->id;\n\n\t\t \n\t\tmemcpy(attr, b, asize);\n\t\tattr->id = le_b[nb]->id;\n\n\t\t \n\t\tif (!mi_remove_attr(NULL, &ni->mi, b))\n\t\t\tgoto out;\n\n\t\tif (to_free <= asize)\n\t\t\tbreak;\n\t\tto_free -= asize;\n\t\tif (!nb)\n\t\t\tgoto out;\n\t}\n\n\tattr = mi_insert_attr(&ni->mi, ATTR_LIST, NULL, 0,\n\t\t\t      lsize + SIZEOF_RESIDENT, SIZEOF_RESIDENT);\n\tif (!attr)\n\t\tgoto out;\n\n\tattr->non_res = 0;\n\tattr->flags = 0;\n\tattr->res.data_size = cpu_to_le32(lsize);\n\tattr->res.data_off = SIZEOF_RESIDENT_LE;\n\tattr->res.flags = 0;\n\tattr->res.res = 0;\n\n\tmemcpy(resident_data_ex(attr, lsize), ni->attr_list.le, lsize);\n\n\tni->attr_list.dirty = false;\n\n\tmark_inode_dirty(&ni->vfs_inode);\n\treturn 0;\n\nout:\n\tkfree(ni->attr_list.le);\n\tni->attr_list.le = NULL;\n\tni->attr_list.size = 0;\n\treturn err;\n}\n\n \nstatic int ni_ins_attr_ext(struct ntfs_inode *ni, struct ATTR_LIST_ENTRY *le,\n\t\t\t   enum ATTR_TYPE type, const __le16 *name, u8 name_len,\n\t\t\t   u32 asize, CLST svcn, u16 name_off, bool force_ext,\n\t\t\t   struct ATTRIB **ins_attr, struct mft_inode **ins_mi,\n\t\t\t   struct ATTR_LIST_ENTRY **ins_le)\n{\n\tstruct ATTRIB *attr;\n\tstruct mft_inode *mi;\n\tCLST rno;\n\tu64 vbo;\n\tstruct rb_node *node;\n\tint err;\n\tbool is_mft, is_mft_data;\n\tstruct ntfs_sb_info *sbi = ni->mi.sbi;\n\n\tis_mft = ni->mi.rno == MFT_REC_MFT;\n\tis_mft_data = is_mft && type == ATTR_DATA && !name_len;\n\n\tif (asize > sbi->max_bytes_per_attr) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (type == ATTR_STD || type == ATTR_LIST ||\n\t    ni->mi.rno == MFT_REC_LOG) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (!ni->attr_list.size) {\n\t\terr = ni_create_attr_list(ni);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tvbo = is_mft_data ? ((u64)svcn << sbi->cluster_bits) : 0;\n\n\tif (force_ext)\n\t\tgoto insert_ext;\n\n\t \n\terr = ni_load_all_mi(ni);\n\tif (err)\n\t\tgoto out;\n\n\t \n\tfor (node = rb_first(&ni->mi_tree); node; node = rb_next(node)) {\n\t\tmi = rb_entry(node, struct mft_inode, node);\n\n\t\tif (is_mft_data &&\n\t\t    (mi_enum_attr(mi, NULL) ||\n\t\t     vbo <= ((u64)mi->rno << sbi->record_bits))) {\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\t\tif (is_mft &&\n\t\t    mi_find_attr(mi, NULL, ATTR_DATA, NULL, 0, NULL)) {\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((type != ATTR_NAME || name_len) &&\n\t\t    mi_find_attr(mi, NULL, type, name, name_len, NULL)) {\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (le32_to_cpu(mi->mrec->used) + asize > sbi->record_size)\n\t\t\tcontinue;\n\n\t\t \n\t\tattr = ni_ins_new_attr(ni, mi, le, type, name, name_len, asize,\n\t\t\t\t       name_off, svcn, ins_le);\n\t\tif (!attr)\n\t\t\tcontinue;\n\t\tif (IS_ERR(attr))\n\t\t\treturn PTR_ERR(attr);\n\n\t\tif (ins_attr)\n\t\t\t*ins_attr = attr;\n\t\tif (ins_mi)\n\t\t\t*ins_mi = mi;\n\t\treturn 0;\n\t}\n\ninsert_ext:\n\t \n\terr = ntfs_look_free_mft(sbi, &rno, is_mft_data, ni, &mi);\n\tif (err)\n\t\tgoto out;\n\n\tif (is_mft_data && vbo <= ((u64)rno << sbi->record_bits)) {\n\t\terr = -EINVAL;\n\t\tgoto out1;\n\t}\n\n\tattr = ni_ins_new_attr(ni, mi, le, type, name, name_len, asize,\n\t\t\t       name_off, svcn, ins_le);\n\tif (!attr) {\n\t\terr = -EINVAL;\n\t\tgoto out2;\n\t}\n\n\tif (IS_ERR(attr)) {\n\t\terr = PTR_ERR(attr);\n\t\tgoto out2;\n\t}\n\n\tif (ins_attr)\n\t\t*ins_attr = attr;\n\tif (ins_mi)\n\t\t*ins_mi = mi;\n\n\treturn 0;\n\nout2:\n\tni_remove_mi(ni, mi);\n\tmi_put(mi);\n\nout1:\n\tntfs_mark_rec_free(sbi, rno, is_mft);\n\nout:\n\treturn err;\n}\n\n \nstatic int ni_insert_attr(struct ntfs_inode *ni, enum ATTR_TYPE type,\n\t\t\t  const __le16 *name, u8 name_len, u32 asize,\n\t\t\t  u16 name_off, CLST svcn, struct ATTRIB **ins_attr,\n\t\t\t  struct mft_inode **ins_mi,\n\t\t\t  struct ATTR_LIST_ENTRY **ins_le)\n{\n\tstruct ntfs_sb_info *sbi = ni->mi.sbi;\n\tint err;\n\tstruct ATTRIB *attr, *eattr;\n\tstruct MFT_REC *rec;\n\tbool is_mft;\n\tstruct ATTR_LIST_ENTRY *le;\n\tu32 list_reserve, max_free, free, used, t32;\n\t__le16 id;\n\tu16 t16;\n\n\tis_mft = ni->mi.rno == MFT_REC_MFT;\n\trec = ni->mi.mrec;\n\n\tlist_reserve = SIZEOF_NONRESIDENT + 3 * (1 + 2 * sizeof(u32));\n\tused = le32_to_cpu(rec->used);\n\tfree = sbi->record_size - used;\n\n\tif (is_mft && type != ATTR_LIST) {\n\t\t \n\t\tif (free < list_reserve)\n\t\t\tfree = 0;\n\t\telse\n\t\t\tfree -= list_reserve;\n\t}\n\n\tif (asize <= free) {\n\t\tattr = ni_ins_new_attr(ni, &ni->mi, NULL, type, name, name_len,\n\t\t\t\t       asize, name_off, svcn, ins_le);\n\t\tif (IS_ERR(attr)) {\n\t\t\terr = PTR_ERR(attr);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (attr) {\n\t\t\tif (ins_attr)\n\t\t\t\t*ins_attr = attr;\n\t\t\tif (ins_mi)\n\t\t\t\t*ins_mi = &ni->mi;\n\t\t\terr = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!is_mft || type != ATTR_DATA || svcn) {\n\t\t \n\t\terr = ni_ins_attr_ext(ni, NULL, type, name, name_len, asize,\n\t\t\t\t      svcn, name_off, false, ins_attr, ins_mi,\n\t\t\t\t      ins_le);\n\t\tgoto out;\n\t}\n\n\t \n\tmax_free = free;\n\n\t \n\tattr = NULL;\n\n\twhile ((attr = mi_enum_attr(&ni->mi, attr))) {\n\t\tif (attr->type == ATTR_STD)\n\t\t\tcontinue;\n\t\tif (attr->type == ATTR_LIST)\n\t\t\tcontinue;\n\t\tmax_free += le32_to_cpu(attr->size);\n\t}\n\n\tif (max_free < asize + list_reserve) {\n\t\t \n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tattr = NULL;\n\n\tfor (;;) {\n\t\tattr = mi_enum_attr(&ni->mi, attr);\n\t\tif (!attr) {\n\t\t\t \n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif (attr->type == ATTR_STD || attr->type == ATTR_LIST)\n\t\t\tcontinue;\n\n\t\tle = NULL;\n\t\tif (ni->attr_list.size) {\n\t\t\tle = al_find_le(ni, NULL, attr);\n\t\t\tif (!le) {\n\t\t\t\t \n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tt32 = le32_to_cpu(attr->size);\n\t\tt16 = le16_to_cpu(attr->name_off);\n\t\terr = ni_ins_attr_ext(ni, le, attr->type, Add2Ptr(attr, t16),\n\t\t\t\t      attr->name_len, t32, attr_svcn(attr), t16,\n\t\t\t\t      false, &eattr, NULL, NULL);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tid = eattr->id;\n\t\tmemcpy(eattr, attr, t32);\n\t\teattr->id = id;\n\n\t\t \n\t\tmi_remove_attr(NULL, &ni->mi, attr);\n\n\t\t \n\t\tif (attr->type == ATTR_END)\n\t\t\tgoto out;\n\t}\n\twhile (asize + list_reserve > sbi->record_size - le32_to_cpu(rec->used))\n\t\t;\n\n\tattr = ni_ins_new_attr(ni, &ni->mi, NULL, type, name, name_len, asize,\n\t\t\t       name_off, svcn, ins_le);\n\tif (!attr) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (IS_ERR(attr)) {\n\t\terr = PTR_ERR(attr);\n\t\tgoto out;\n\t}\n\n\tif (ins_attr)\n\t\t*ins_attr = attr;\n\tif (ins_mi)\n\t\t*ins_mi = &ni->mi;\n\nout:\n\treturn err;\n}\n\n \nstatic int ni_expand_mft_list(struct ntfs_inode *ni)\n{\n\tint err = 0;\n\tstruct runs_tree *run = &ni->file.run;\n\tu32 asize, run_size, done = 0;\n\tstruct ATTRIB *attr;\n\tstruct rb_node *node;\n\tCLST mft_min, mft_new, svcn, evcn, plen;\n\tstruct mft_inode *mi, *mi_min, *mi_new;\n\tstruct ntfs_sb_info *sbi = ni->mi.sbi;\n\n\t \n\tmft_min = 0;\n\tmft_new = 0;\n\tmi_min = NULL;\n\n\tfor (node = rb_first(&ni->mi_tree); node; node = rb_next(node)) {\n\t\tmi = rb_entry(node, struct mft_inode, node);\n\n\t\tattr = mi_enum_attr(mi, NULL);\n\n\t\tif (!attr) {\n\t\t\tmft_min = mi->rno;\n\t\t\tmi_min = mi;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ntfs_look_free_mft(sbi, &mft_new, true, ni, &mi_new)) {\n\t\tmft_new = 0;\n\t\t \n\t} else if (mft_min > mft_new) {\n\t\tmft_min = mft_new;\n\t\tmi_min = mi_new;\n\t} else {\n\t\tntfs_mark_rec_free(sbi, mft_new, true);\n\t\tmft_new = 0;\n\t\tni_remove_mi(ni, mi_new);\n\t}\n\n\tattr = mi_find_attr(&ni->mi, NULL, ATTR_DATA, NULL, 0, NULL);\n\tif (!attr) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tasize = le32_to_cpu(attr->size);\n\n\tevcn = le64_to_cpu(attr->nres.evcn);\n\tsvcn = bytes_to_cluster(sbi, (u64)(mft_min + 1) << sbi->record_bits);\n\tif (evcn + 1 >= svcn) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\terr = run_pack(run, 0, svcn, Add2Ptr(attr, SIZEOF_NONRESIDENT),\n\t\t       asize - SIZEOF_NONRESIDENT, &plen);\n\tif (err < 0)\n\t\tgoto out;\n\n\trun_size = ALIGN(err, 8);\n\terr = 0;\n\n\tif (plen < svcn) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tattr->nres.evcn = cpu_to_le64(svcn - 1);\n\tattr->size = cpu_to_le32(run_size + SIZEOF_NONRESIDENT);\n\t \n\tdone = asize - run_size - SIZEOF_NONRESIDENT;\n\tle32_sub_cpu(&ni->mi.mrec->used, done);\n\n\t \n\terr = run_pack(run, svcn, evcn + 1 - svcn, NULL, sbi->record_size,\n\t\t       &plen);\n\tif (err < 0)\n\t\tgoto out;\n\n\trun_size = ALIGN(err, 8);\n\terr = 0;\n\n\tif (plen < evcn + 1 - svcn) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tattr = ni_ins_new_attr(ni, mi_min, NULL, ATTR_DATA, NULL, 0,\n\t\t\t       SIZEOF_NONRESIDENT + run_size,\n\t\t\t       SIZEOF_NONRESIDENT, svcn, NULL);\n\tif (!attr) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (IS_ERR(attr)) {\n\t\terr = PTR_ERR(attr);\n\t\tgoto out;\n\t}\n\n\tattr->non_res = 1;\n\tattr->name_off = SIZEOF_NONRESIDENT_LE;\n\tattr->flags = 0;\n\n\t \n\trun_pack(run, svcn, evcn + 1 - svcn, Add2Ptr(attr, SIZEOF_NONRESIDENT),\n\t\t run_size, &plen);\n\n\tattr->nres.svcn = cpu_to_le64(svcn);\n\tattr->nres.evcn = cpu_to_le64(evcn);\n\tattr->nres.run_off = cpu_to_le16(SIZEOF_NONRESIDENT);\n\nout:\n\tif (mft_new) {\n\t\tntfs_mark_rec_free(sbi, mft_new, true);\n\t\tni_remove_mi(ni, mi_new);\n\t}\n\n\treturn !err && !done ? -EOPNOTSUPP : err;\n}\n\n \nint ni_expand_list(struct ntfs_inode *ni)\n{\n\tint err = 0;\n\tu32 asize, done = 0;\n\tstruct ATTRIB *attr, *ins_attr;\n\tstruct ATTR_LIST_ENTRY *le;\n\tbool is_mft = ni->mi.rno == MFT_REC_MFT;\n\tstruct MFT_REF ref;\n\n\tmi_get_ref(&ni->mi, &ref);\n\tle = NULL;\n\n\twhile ((le = al_enumerate(ni, le))) {\n\t\tif (le->type == ATTR_STD)\n\t\t\tcontinue;\n\n\t\tif (memcmp(&ref, &le->ref, sizeof(struct MFT_REF)))\n\t\t\tcontinue;\n\n\t\tif (is_mft && le->type == ATTR_DATA)\n\t\t\tcontinue;\n\n\t\t \n\t\tattr = rec_find_attr_le(&ni->mi, le);\n\t\tif (!attr) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tasize = le32_to_cpu(attr->size);\n\n\t\t \n\t\terr = ni_ins_attr_ext(ni, le, attr->type, attr_name(attr),\n\t\t\t\t      attr->name_len, asize, attr_svcn(attr),\n\t\t\t\t      le16_to_cpu(attr->name_off), true,\n\t\t\t\t      &ins_attr, NULL, NULL);\n\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tmemcpy(ins_attr, attr, asize);\n\t\tins_attr->id = le->id;\n\t\t \n\t\tmi_remove_attr(NULL, &ni->mi, attr);\n\n\t\tdone += asize;\n\t\tgoto out;\n\t}\n\n\tif (!is_mft) {\n\t\terr = -EFBIG;  \n\t\tgoto out;\n\t}\n\n\t \n\terr = ni_expand_mft_list(ni);\n\nout:\n\treturn !err && !done ? -EOPNOTSUPP : err;\n}\n\n \nint ni_insert_nonresident(struct ntfs_inode *ni, enum ATTR_TYPE type,\n\t\t\t  const __le16 *name, u8 name_len,\n\t\t\t  const struct runs_tree *run, CLST svcn, CLST len,\n\t\t\t  __le16 flags, struct ATTRIB **new_attr,\n\t\t\t  struct mft_inode **mi, struct ATTR_LIST_ENTRY **le)\n{\n\tint err;\n\tCLST plen;\n\tstruct ATTRIB *attr;\n\tbool is_ext = (flags & (ATTR_FLAG_SPARSED | ATTR_FLAG_COMPRESSED)) &&\n\t\t      !svcn;\n\tu32 name_size = ALIGN(name_len * sizeof(short), 8);\n\tu32 name_off = is_ext ? SIZEOF_NONRESIDENT_EX : SIZEOF_NONRESIDENT;\n\tu32 run_off = name_off + name_size;\n\tu32 run_size, asize;\n\tstruct ntfs_sb_info *sbi = ni->mi.sbi;\n\n\t \n\terr = run_pack(run, svcn, len, NULL, sbi->max_bytes_per_attr - run_off,\n\t\t       &plen);\n\tif (err < 0)\n\t\tgoto out;\n\n\trun_size = ALIGN(err, 8);\n\n\tif (plen < len) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tasize = run_off + run_size;\n\n\tif (asize > sbi->max_bytes_per_attr) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\terr = ni_insert_attr(ni, type, name, name_len, asize, name_off, svcn,\n\t\t\t     &attr, mi, le);\n\n\tif (err)\n\t\tgoto out;\n\n\tattr->non_res = 1;\n\tattr->name_off = cpu_to_le16(name_off);\n\tattr->flags = flags;\n\n\t \n\trun_pack(run, svcn, len, Add2Ptr(attr, run_off), run_size, &plen);\n\n\tattr->nres.svcn = cpu_to_le64(svcn);\n\tattr->nres.evcn = cpu_to_le64((u64)svcn + len - 1);\n\n\tif (new_attr)\n\t\t*new_attr = attr;\n\n\t*(__le64 *)&attr->nres.run_off = cpu_to_le64(run_off);\n\n\tattr->nres.alloc_size =\n\t\tsvcn ? 0 : cpu_to_le64((u64)len << ni->mi.sbi->cluster_bits);\n\tattr->nres.data_size = attr->nres.alloc_size;\n\tattr->nres.valid_size = attr->nres.alloc_size;\n\n\tif (is_ext) {\n\t\tif (flags & ATTR_FLAG_COMPRESSED)\n\t\t\tattr->nres.c_unit = COMPRESSION_UNIT;\n\t\tattr->nres.total_size = attr->nres.alloc_size;\n\t}\n\nout:\n\treturn err;\n}\n\n \nint ni_insert_resident(struct ntfs_inode *ni, u32 data_size,\n\t\t       enum ATTR_TYPE type, const __le16 *name, u8 name_len,\n\t\t       struct ATTRIB **new_attr, struct mft_inode **mi,\n\t\t       struct ATTR_LIST_ENTRY **le)\n{\n\tint err;\n\tu32 name_size = ALIGN(name_len * sizeof(short), 8);\n\tu32 asize = SIZEOF_RESIDENT + name_size + ALIGN(data_size, 8);\n\tstruct ATTRIB *attr;\n\n\terr = ni_insert_attr(ni, type, name, name_len, asize, SIZEOF_RESIDENT,\n\t\t\t     0, &attr, mi, le);\n\tif (err)\n\t\treturn err;\n\n\tattr->non_res = 0;\n\tattr->flags = 0;\n\n\tattr->res.data_size = cpu_to_le32(data_size);\n\tattr->res.data_off = cpu_to_le16(SIZEOF_RESIDENT + name_size);\n\tif (type == ATTR_NAME) {\n\t\tattr->res.flags = RESIDENT_FLAG_INDEXED;\n\n\t\t \n\t\tle16_add_cpu(&ni->mi.mrec->hard_links, 1);\n\t\tni->mi.dirty = true;\n\t}\n\tattr->res.res = 0;\n\n\tif (new_attr)\n\t\t*new_attr = attr;\n\n\treturn 0;\n}\n\n \nvoid ni_remove_attr_le(struct ntfs_inode *ni, struct ATTRIB *attr,\n\t\t       struct mft_inode *mi, struct ATTR_LIST_ENTRY *le)\n{\n\tmi_remove_attr(ni, mi, attr);\n\n\tif (le)\n\t\tal_remove_le(ni, le);\n}\n\n \nint ni_delete_all(struct ntfs_inode *ni)\n{\n\tint err;\n\tstruct ATTR_LIST_ENTRY *le = NULL;\n\tstruct ATTRIB *attr = NULL;\n\tstruct rb_node *node;\n\tu16 roff;\n\tu32 asize;\n\tCLST svcn, evcn;\n\tstruct ntfs_sb_info *sbi = ni->mi.sbi;\n\tbool nt3 = is_ntfs3(sbi);\n\tstruct MFT_REF ref;\n\n\twhile ((attr = ni_enum_attr_ex(ni, attr, &le, NULL))) {\n\t\tif (!nt3 || attr->name_len) {\n\t\t\t;\n\t\t} else if (attr->type == ATTR_REPARSE) {\n\t\t\tmi_get_ref(&ni->mi, &ref);\n\t\t\tntfs_remove_reparse(sbi, 0, &ref);\n\t\t} else if (attr->type == ATTR_ID && !attr->non_res &&\n\t\t\t   le32_to_cpu(attr->res.data_size) >=\n\t\t\t\t   sizeof(struct GUID)) {\n\t\t\tntfs_objid_remove(sbi, resident_data(attr));\n\t\t}\n\n\t\tif (!attr->non_res)\n\t\t\tcontinue;\n\n\t\tsvcn = le64_to_cpu(attr->nres.svcn);\n\t\tevcn = le64_to_cpu(attr->nres.evcn);\n\n\t\tif (evcn + 1 <= svcn)\n\t\t\tcontinue;\n\n\t\tasize = le32_to_cpu(attr->size);\n\t\troff = le16_to_cpu(attr->nres.run_off);\n\n\t\tif (roff > asize)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\trun_unpack_ex(RUN_DEALLOCATE, sbi, ni->mi.rno, svcn, evcn, svcn,\n\t\t\t      Add2Ptr(attr, roff), asize - roff);\n\t}\n\n\tif (ni->attr_list.size) {\n\t\trun_deallocate(ni->mi.sbi, &ni->attr_list.run, true);\n\t\tal_destroy(ni);\n\t}\n\n\t \n\tfor (node = rb_first(&ni->mi_tree); node;) {\n\t\tstruct rb_node *next = rb_next(node);\n\t\tstruct mft_inode *mi = rb_entry(node, struct mft_inode, node);\n\n\t\tclear_rec_inuse(mi->mrec);\n\t\tmi->dirty = true;\n\t\tmi_write(mi, 0);\n\n\t\tntfs_mark_rec_free(sbi, mi->rno, false);\n\t\tni_remove_mi(ni, mi);\n\t\tmi_put(mi);\n\t\tnode = next;\n\t}\n\n\t \n\tclear_rec_inuse(ni->mi.mrec);\n\tni->mi.dirty = true;\n\terr = mi_write(&ni->mi, 0);\n\n\tntfs_mark_rec_free(sbi, ni->mi.rno, false);\n\n\treturn err;\n}\n\n \nstruct ATTR_FILE_NAME *ni_fname_name(struct ntfs_inode *ni,\n\t\t\t\t     const struct le_str *uni,\n\t\t\t\t     const struct MFT_REF *home_dir,\n\t\t\t\t     struct mft_inode **mi,\n\t\t\t\t     struct ATTR_LIST_ENTRY **le)\n{\n\tstruct ATTRIB *attr = NULL;\n\tstruct ATTR_FILE_NAME *fname;\n\n\tif (le)\n\t\t*le = NULL;\n\n\t \nnext:\n\tattr = ni_find_attr(ni, attr, le, ATTR_NAME, NULL, 0, NULL, mi);\n\tif (!attr)\n\t\treturn NULL;\n\n\tfname = resident_data_ex(attr, SIZEOF_ATTRIBUTE_FILENAME);\n\tif (!fname)\n\t\tgoto next;\n\n\tif (home_dir && memcmp(home_dir, &fname->home, sizeof(*home_dir)))\n\t\tgoto next;\n\n\tif (!uni)\n\t\treturn fname;\n\n\tif (uni->len != fname->name_len)\n\t\tgoto next;\n\n\tif (ntfs_cmp_names(uni->name, uni->len, fname->name, uni->len, NULL,\n\t\t\t   false))\n\t\tgoto next;\n\treturn fname;\n}\n\n \nstruct ATTR_FILE_NAME *ni_fname_type(struct ntfs_inode *ni, u8 name_type,\n\t\t\t\t     struct mft_inode **mi,\n\t\t\t\t     struct ATTR_LIST_ENTRY **le)\n{\n\tstruct ATTRIB *attr = NULL;\n\tstruct ATTR_FILE_NAME *fname;\n\n\t*le = NULL;\n\n\tif (name_type == FILE_NAME_POSIX)\n\t\treturn NULL;\n\n\t \n\tfor (;;) {\n\t\tattr = ni_find_attr(ni, attr, le, ATTR_NAME, NULL, 0, NULL, mi);\n\t\tif (!attr)\n\t\t\treturn NULL;\n\n\t\tfname = resident_data_ex(attr, SIZEOF_ATTRIBUTE_FILENAME);\n\t\tif (fname && name_type == fname->type)\n\t\t\treturn fname;\n\t}\n}\n\n \nint ni_new_attr_flags(struct ntfs_inode *ni, enum FILE_ATTRIBUTE new_fa)\n{\n\tstruct ATTRIB *attr;\n\tstruct mft_inode *mi;\n\t__le16 new_aflags;\n\tu32 new_asize;\n\n\tattr = ni_find_attr(ni, NULL, NULL, ATTR_DATA, NULL, 0, NULL, &mi);\n\tif (!attr)\n\t\treturn -EINVAL;\n\n\tnew_aflags = attr->flags;\n\n\tif (new_fa & FILE_ATTRIBUTE_SPARSE_FILE)\n\t\tnew_aflags |= ATTR_FLAG_SPARSED;\n\telse\n\t\tnew_aflags &= ~ATTR_FLAG_SPARSED;\n\n\tif (new_fa & FILE_ATTRIBUTE_COMPRESSED)\n\t\tnew_aflags |= ATTR_FLAG_COMPRESSED;\n\telse\n\t\tnew_aflags &= ~ATTR_FLAG_COMPRESSED;\n\n\tif (new_aflags == attr->flags)\n\t\treturn 0;\n\n\tif ((new_aflags & (ATTR_FLAG_COMPRESSED | ATTR_FLAG_SPARSED)) ==\n\t    (ATTR_FLAG_COMPRESSED | ATTR_FLAG_SPARSED)) {\n\t\tntfs_inode_warn(&ni->vfs_inode,\n\t\t\t\t\"file can't be sparsed and compressed\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!attr->non_res)\n\t\tgoto out;\n\n\tif (attr->nres.data_size) {\n\t\tntfs_inode_warn(\n\t\t\t&ni->vfs_inode,\n\t\t\t\"one can change sparsed/compressed only for empty files\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tnew_asize = (new_aflags & (ATTR_FLAG_COMPRESSED | ATTR_FLAG_SPARSED)) ?\n\t\t\t    (SIZEOF_NONRESIDENT_EX + 8) :\n\t\t\t    (SIZEOF_NONRESIDENT + 8);\n\n\tif (!mi_resize_attr(mi, attr, new_asize - le32_to_cpu(attr->size)))\n\t\treturn -EOPNOTSUPP;\n\n\tif (new_aflags & ATTR_FLAG_SPARSED) {\n\t\tattr->name_off = SIZEOF_NONRESIDENT_EX_LE;\n\t\t \n\t\tattr->nres.c_unit = 0;\n\t\tni->vfs_inode.i_mapping->a_ops = &ntfs_aops;\n\t} else if (new_aflags & ATTR_FLAG_COMPRESSED) {\n\t\tattr->name_off = SIZEOF_NONRESIDENT_EX_LE;\n\t\t \n\t\tattr->nres.c_unit = NTFS_LZNT_CUNIT;\n\t\tni->vfs_inode.i_mapping->a_ops = &ntfs_aops_cmpr;\n\t} else {\n\t\tattr->name_off = SIZEOF_NONRESIDENT_LE;\n\t\t \n\t\tattr->nres.c_unit = 0;\n\t\tni->vfs_inode.i_mapping->a_ops = &ntfs_aops;\n\t}\n\tattr->nres.run_off = attr->name_off;\nout:\n\tattr->flags = new_aflags;\n\tmi->dirty = true;\n\n\treturn 0;\n}\n\n \nenum REPARSE_SIGN ni_parse_reparse(struct ntfs_inode *ni, struct ATTRIB *attr,\n\t\t\t\t   struct REPARSE_DATA_BUFFER *buffer)\n{\n\tconst struct REPARSE_DATA_BUFFER *rp = NULL;\n\tu8 bits;\n\tu16 len;\n\ttypeof(rp->CompressReparseBuffer) *cmpr;\n\n\t \n\tif (!attr->non_res) {\n\t\trp = resident_data_ex(attr, sizeof(struct REPARSE_DATA_BUFFER));\n\t} else if (le64_to_cpu(attr->nres.data_size) >=\n\t\t   sizeof(struct REPARSE_DATA_BUFFER)) {\n\t\tstruct runs_tree run;\n\n\t\trun_init(&run);\n\n\t\tif (!attr_load_runs_vcn(ni, ATTR_REPARSE, NULL, 0, &run, 0) &&\n\t\t    !ntfs_read_run_nb(ni->mi.sbi, &run, 0, buffer,\n\t\t\t\t      sizeof(struct REPARSE_DATA_BUFFER),\n\t\t\t\t      NULL)) {\n\t\t\trp = buffer;\n\t\t}\n\n\t\trun_close(&run);\n\t}\n\n\tif (!rp)\n\t\treturn REPARSE_NONE;\n\n\tlen = le16_to_cpu(rp->ReparseDataLength);\n\tswitch (rp->ReparseTag) {\n\tcase (IO_REPARSE_TAG_MICROSOFT | IO_REPARSE_TAG_SYMBOLIC_LINK):\n\t\tbreak;  \n\tcase IO_REPARSE_TAG_MOUNT_POINT:\n\t\tbreak;  \n\tcase IO_REPARSE_TAG_SYMLINK:\n\t\tbreak;\n\tcase IO_REPARSE_TAG_COMPRESS:\n\t\t \n\n\t\tcmpr = &rp->CompressReparseBuffer;\n\t\tif (len < sizeof(*cmpr) ||\n\t\t    cmpr->WofVersion != WOF_CURRENT_VERSION ||\n\t\t    cmpr->WofProvider != WOF_PROVIDER_SYSTEM ||\n\t\t    cmpr->ProviderVer != WOF_PROVIDER_CURRENT_VERSION) {\n\t\t\treturn REPARSE_NONE;\n\t\t}\n\n\t\tswitch (cmpr->CompressionFormat) {\n\t\tcase WOF_COMPRESSION_XPRESS4K:\n\t\t\tbits = 0xc;  \n\t\t\tbreak;\n\t\tcase WOF_COMPRESSION_XPRESS8K:\n\t\t\tbits = 0xd;  \n\t\t\tbreak;\n\t\tcase WOF_COMPRESSION_XPRESS16K:\n\t\t\tbits = 0xe;  \n\t\t\tbreak;\n\t\tcase WOF_COMPRESSION_LZX32K:\n\t\t\tbits = 0xf;  \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbits = 0x10;  \n\t\t\tbreak;\n\t\t}\n\t\tni_set_ext_compress_bits(ni, bits);\n\t\treturn REPARSE_COMPRESSED;\n\n\tcase IO_REPARSE_TAG_DEDUP:\n\t\tni->ni_flags |= NI_FLAG_DEDUPLICATED;\n\t\treturn REPARSE_DEDUPLICATED;\n\n\tdefault:\n\t\tif (rp->ReparseTag & IO_REPARSE_TAG_NAME_SURROGATE)\n\t\t\tbreak;\n\n\t\treturn REPARSE_NONE;\n\t}\n\n\tif (buffer != rp)\n\t\tmemcpy(buffer, rp, sizeof(struct REPARSE_DATA_BUFFER));\n\n\t \n\treturn REPARSE_LINK;\n}\n\n \nint ni_fiemap(struct ntfs_inode *ni, struct fiemap_extent_info *fieinfo,\n\t      __u64 vbo, __u64 len)\n{\n\tint err = 0;\n\tstruct ntfs_sb_info *sbi = ni->mi.sbi;\n\tu8 cluster_bits = sbi->cluster_bits;\n\tstruct runs_tree *run;\n\tstruct rw_semaphore *run_lock;\n\tstruct ATTRIB *attr;\n\tCLST vcn = vbo >> cluster_bits;\n\tCLST lcn, clen;\n\tu64 valid = ni->i_valid;\n\tu64 lbo, bytes;\n\tu64 end, alloc_size;\n\tsize_t idx = -1;\n\tu32 flags;\n\tbool ok;\n\n\tif (S_ISDIR(ni->vfs_inode.i_mode)) {\n\t\trun = &ni->dir.alloc_run;\n\t\tattr = ni_find_attr(ni, NULL, NULL, ATTR_ALLOC, I30_NAME,\n\t\t\t\t    ARRAY_SIZE(I30_NAME), NULL, NULL);\n\t\trun_lock = &ni->dir.run_lock;\n\t} else {\n\t\trun = &ni->file.run;\n\t\tattr = ni_find_attr(ni, NULL, NULL, ATTR_DATA, NULL, 0, NULL,\n\t\t\t\t    NULL);\n\t\tif (!attr) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (is_attr_compressed(attr)) {\n\t\t\t \n\t\t\terr = -EOPNOTSUPP;\n\t\t\tntfs_inode_warn(\n\t\t\t\t&ni->vfs_inode,\n\t\t\t\t\"fiemap is not supported for compressed file (cp -r)\");\n\t\t\tgoto out;\n\t\t}\n\t\trun_lock = &ni->file.run_lock;\n\t}\n\n\tif (!attr || !attr->non_res) {\n\t\terr = fiemap_fill_next_extent(\n\t\t\tfieinfo, 0, 0,\n\t\t\tattr ? le32_to_cpu(attr->res.data_size) : 0,\n\t\t\tFIEMAP_EXTENT_DATA_INLINE | FIEMAP_EXTENT_LAST |\n\t\t\t\tFIEMAP_EXTENT_MERGED);\n\t\tgoto out;\n\t}\n\n\tend = vbo + len;\n\talloc_size = le64_to_cpu(attr->nres.alloc_size);\n\tif (end > alloc_size)\n\t\tend = alloc_size;\n\n\tdown_read(run_lock);\n\n\twhile (vbo < end) {\n\t\tif (idx == -1) {\n\t\t\tok = run_lookup_entry(run, vcn, &lcn, &clen, &idx);\n\t\t} else {\n\t\t\tCLST vcn_next = vcn;\n\n\t\t\tok = run_get_entry(run, ++idx, &vcn, &lcn, &clen) &&\n\t\t\t     vcn == vcn_next;\n\t\t\tif (!ok)\n\t\t\t\tvcn = vcn_next;\n\t\t}\n\n\t\tif (!ok) {\n\t\t\tup_read(run_lock);\n\t\t\tdown_write(run_lock);\n\n\t\t\terr = attr_load_runs_vcn(ni, attr->type,\n\t\t\t\t\t\t attr_name(attr),\n\t\t\t\t\t\t attr->name_len, run, vcn);\n\n\t\t\tup_write(run_lock);\n\t\t\tdown_read(run_lock);\n\n\t\t\tif (err)\n\t\t\t\tbreak;\n\n\t\t\tok = run_lookup_entry(run, vcn, &lcn, &clen, &idx);\n\n\t\t\tif (!ok) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!clen) {\n\t\t\terr = -EINVAL;  \n\t\t\tbreak;\n\t\t}\n\n\t\tif (lcn == SPARSE_LCN) {\n\t\t\tvcn += clen;\n\t\t\tvbo = (u64)vcn << cluster_bits;\n\t\t\tcontinue;\n\t\t}\n\n\t\tflags = FIEMAP_EXTENT_MERGED;\n\t\tif (S_ISDIR(ni->vfs_inode.i_mode)) {\n\t\t\t;\n\t\t} else if (is_attr_compressed(attr)) {\n\t\t\tCLST clst_data;\n\n\t\t\terr = attr_is_frame_compressed(\n\t\t\t\tni, attr, vcn >> attr->nres.c_unit, &clst_data);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (clst_data < NTFS_LZNT_CLUSTERS)\n\t\t\t\tflags |= FIEMAP_EXTENT_ENCODED;\n\t\t} else if (is_attr_encrypted(attr)) {\n\t\t\tflags |= FIEMAP_EXTENT_DATA_ENCRYPTED;\n\t\t}\n\n\t\tvbo = (u64)vcn << cluster_bits;\n\t\tbytes = (u64)clen << cluster_bits;\n\t\tlbo = (u64)lcn << cluster_bits;\n\n\t\tvcn += clen;\n\n\t\tif (vbo + bytes >= end)\n\t\t\tbytes = end - vbo;\n\n\t\tif (vbo + bytes <= valid) {\n\t\t\t;\n\t\t} else if (vbo >= valid) {\n\t\t\tflags |= FIEMAP_EXTENT_UNWRITTEN;\n\t\t} else {\n\t\t\t \n\t\t\tu64 dlen = valid - vbo;\n\n\t\t\tif (vbo + dlen >= end)\n\t\t\t\tflags |= FIEMAP_EXTENT_LAST;\n\n\t\t\terr = fiemap_fill_next_extent(fieinfo, vbo, lbo, dlen,\n\t\t\t\t\t\t      flags);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t\tif (err == 1) {\n\t\t\t\terr = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tvbo = valid;\n\t\t\tbytes -= dlen;\n\t\t\tif (!bytes)\n\t\t\t\tcontinue;\n\n\t\t\tlbo += dlen;\n\t\t\tflags |= FIEMAP_EXTENT_UNWRITTEN;\n\t\t}\n\n\t\tif (vbo + bytes >= end)\n\t\t\tflags |= FIEMAP_EXTENT_LAST;\n\n\t\terr = fiemap_fill_next_extent(fieinfo, vbo, lbo, bytes, flags);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t\tif (err == 1) {\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tvbo += bytes;\n\t}\n\n\tup_read(run_lock);\n\nout:\n\treturn err;\n}\n\n \nint ni_readpage_cmpr(struct ntfs_inode *ni, struct page *page)\n{\n\tint err;\n\tstruct ntfs_sb_info *sbi = ni->mi.sbi;\n\tstruct address_space *mapping = page->mapping;\n\tpgoff_t index = page->index;\n\tu64 frame_vbo, vbo = (u64)index << PAGE_SHIFT;\n\tstruct page **pages = NULL;  \n\tu8 frame_bits;\n\tCLST frame;\n\tu32 i, idx, frame_size, pages_per_frame;\n\tgfp_t gfp_mask;\n\tstruct page *pg;\n\n\tif (vbo >= ni->vfs_inode.i_size) {\n\t\tSetPageUptodate(page);\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\tif (ni->ni_flags & NI_FLAG_COMPRESSED_MASK) {\n\t\t \n\t\tframe_bits = ni_ext_compress_bits(ni);\n\t} else {\n\t\t \n\t\tframe_bits = NTFS_LZNT_CUNIT + sbi->cluster_bits;\n\t}\n\tframe_size = 1u << frame_bits;\n\tframe = vbo >> frame_bits;\n\tframe_vbo = (u64)frame << frame_bits;\n\tidx = (vbo - frame_vbo) >> PAGE_SHIFT;\n\n\tpages_per_frame = frame_size >> PAGE_SHIFT;\n\tpages = kcalloc(pages_per_frame, sizeof(struct page *), GFP_NOFS);\n\tif (!pages) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tpages[idx] = page;\n\tindex = frame_vbo >> PAGE_SHIFT;\n\tgfp_mask = mapping_gfp_mask(mapping);\n\n\tfor (i = 0; i < pages_per_frame; i++, index++) {\n\t\tif (i == idx)\n\t\t\tcontinue;\n\n\t\tpg = find_or_create_page(mapping, index, gfp_mask);\n\t\tif (!pg) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out1;\n\t\t}\n\t\tpages[i] = pg;\n\t}\n\n\terr = ni_read_frame(ni, frame_vbo, pages, pages_per_frame);\n\nout1:\n\tif (err)\n\t\tSetPageError(page);\n\n\tfor (i = 0; i < pages_per_frame; i++) {\n\t\tpg = pages[i];\n\t\tif (i == idx || !pg)\n\t\t\tcontinue;\n\t\tunlock_page(pg);\n\t\tput_page(pg);\n\t}\n\nout:\n\t \n\tkfree(pages);\n\tunlock_page(page);\n\n\treturn err;\n}\n\n#ifdef CONFIG_NTFS3_LZX_XPRESS\n \nint ni_decompress_file(struct ntfs_inode *ni)\n{\n\tstruct ntfs_sb_info *sbi = ni->mi.sbi;\n\tstruct inode *inode = &ni->vfs_inode;\n\tloff_t i_size = inode->i_size;\n\tstruct address_space *mapping = inode->i_mapping;\n\tgfp_t gfp_mask = mapping_gfp_mask(mapping);\n\tstruct page **pages = NULL;\n\tstruct ATTR_LIST_ENTRY *le;\n\tstruct ATTRIB *attr;\n\tCLST vcn, cend, lcn, clen, end;\n\tpgoff_t index;\n\tu64 vbo;\n\tu8 frame_bits;\n\tu32 i, frame_size, pages_per_frame, bytes;\n\tstruct mft_inode *mi;\n\tint err;\n\n\t \n\tcend = bytes_to_cluster(sbi, i_size);\n\n\tif (!i_size)\n\t\tgoto remove_wof;\n\n\t \n\tif (cend > wnd_zeroes(&sbi->used.bitmap)) {\n\t\terr = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\tframe_bits = ni_ext_compress_bits(ni);\n\tframe_size = 1u << frame_bits;\n\tpages_per_frame = frame_size >> PAGE_SHIFT;\n\tpages = kcalloc(pages_per_frame, sizeof(struct page *), GFP_NOFS);\n\tif (!pages) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\tindex = 0;\n\tfor (vbo = 0; vbo < i_size; vbo += bytes) {\n\t\tu32 nr_pages;\n\t\tbool new;\n\n\t\tif (vbo + frame_size > i_size) {\n\t\t\tbytes = i_size - vbo;\n\t\t\tnr_pages = (bytes + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t\t} else {\n\t\t\tnr_pages = pages_per_frame;\n\t\t\tbytes = frame_size;\n\t\t}\n\n\t\tend = bytes_to_cluster(sbi, vbo + bytes);\n\n\t\tfor (vcn = vbo >> sbi->cluster_bits; vcn < end; vcn += clen) {\n\t\t\terr = attr_data_get_block(ni, vcn, cend - vcn, &lcn,\n\t\t\t\t\t\t  &clen, &new, false);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tfor (i = 0; i < pages_per_frame; i++, index++) {\n\t\t\tstruct page *pg;\n\n\t\t\tpg = find_or_create_page(mapping, index, gfp_mask);\n\t\t\tif (!pg) {\n\t\t\t\twhile (i--) {\n\t\t\t\t\tunlock_page(pages[i]);\n\t\t\t\t\tput_page(pages[i]);\n\t\t\t\t}\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tpages[i] = pg;\n\t\t}\n\n\t\terr = ni_read_frame(ni, vbo, pages, pages_per_frame);\n\n\t\tif (!err) {\n\t\t\tdown_read(&ni->file.run_lock);\n\t\t\terr = ntfs_bio_pages(sbi, &ni->file.run, pages,\n\t\t\t\t\t     nr_pages, vbo, bytes,\n\t\t\t\t\t     REQ_OP_WRITE);\n\t\t\tup_read(&ni->file.run_lock);\n\t\t}\n\n\t\tfor (i = 0; i < pages_per_frame; i++) {\n\t\t\tunlock_page(pages[i]);\n\t\t\tput_page(pages[i]);\n\t\t}\n\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tcond_resched();\n\t}\n\nremove_wof:\n\t \n\tattr = NULL;\n\tle = NULL;\n\twhile ((attr = ni_enum_attr_ex(ni, attr, &le, NULL))) {\n\t\tCLST svcn, evcn;\n\t\tu32 asize, roff;\n\n\t\tif (attr->type == ATTR_REPARSE) {\n\t\t\tstruct MFT_REF ref;\n\n\t\t\tmi_get_ref(&ni->mi, &ref);\n\t\t\tntfs_remove_reparse(sbi, 0, &ref);\n\t\t}\n\n\t\tif (!attr->non_res)\n\t\t\tcontinue;\n\n\t\tif (attr->type != ATTR_REPARSE &&\n\t\t    (attr->type != ATTR_DATA ||\n\t\t     attr->name_len != ARRAY_SIZE(WOF_NAME) ||\n\t\t     memcmp(attr_name(attr), WOF_NAME, sizeof(WOF_NAME))))\n\t\t\tcontinue;\n\n\t\tsvcn = le64_to_cpu(attr->nres.svcn);\n\t\tevcn = le64_to_cpu(attr->nres.evcn);\n\n\t\tif (evcn + 1 <= svcn)\n\t\t\tcontinue;\n\n\t\tasize = le32_to_cpu(attr->size);\n\t\troff = le16_to_cpu(attr->nres.run_off);\n\n\t\tif (roff > asize) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\trun_unpack_ex(RUN_DEALLOCATE, sbi, ni->mi.rno, svcn, evcn, svcn,\n\t\t\t      Add2Ptr(attr, roff), asize - roff);\n\t}\n\n\t \n\terr = ni_remove_attr(ni, ATTR_DATA, WOF_NAME, ARRAY_SIZE(WOF_NAME),\n\t\t\t     false, NULL);\n\tif (err)\n\t\tgoto out;\n\n\t \n\terr = ni_remove_attr(ni, ATTR_REPARSE, NULL, 0, false, NULL);\n\tif (err)\n\t\tgoto out;\n\n\t \n\tattr = ni_find_attr(ni, NULL, NULL, ATTR_DATA, NULL, 0, NULL, &mi);\n\tif (!attr) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (attr->non_res && is_attr_sparsed(attr)) {\n\t\t \n\t\tstruct MFT_REC *rec = mi->mrec;\n\t\tu32 used = le32_to_cpu(rec->used);\n\t\tu32 asize = le32_to_cpu(attr->size);\n\t\tu16 roff = le16_to_cpu(attr->nres.run_off);\n\t\tchar *rbuf = Add2Ptr(attr, roff);\n\n\t\tmemmove(rbuf - 8, rbuf, used - PtrOffset(rec, rbuf));\n\t\tattr->size = cpu_to_le32(asize - 8);\n\t\tattr->flags &= ~ATTR_FLAG_SPARSED;\n\t\tattr->nres.run_off = cpu_to_le16(roff - 8);\n\t\tattr->nres.c_unit = 0;\n\t\trec->used = cpu_to_le32(used - 8);\n\t\tmi->dirty = true;\n\t\tni->std_fa &= ~(FILE_ATTRIBUTE_SPARSE_FILE |\n\t\t\t\tFILE_ATTRIBUTE_REPARSE_POINT);\n\n\t\tmark_inode_dirty(inode);\n\t}\n\n\t \n\tni->ni_flags &= ~NI_FLAG_COMPRESSED_MASK;\n\tif (ni->file.offs_page) {\n\t\tput_page(ni->file.offs_page);\n\t\tni->file.offs_page = NULL;\n\t}\n\tmapping->a_ops = &ntfs_aops;\n\nout:\n\tkfree(pages);\n\tif (err)\n\t\t_ntfs_bad_inode(inode);\n\n\treturn err;\n}\n\n \nstatic int decompress_lzx_xpress(struct ntfs_sb_info *sbi, const char *cmpr,\n\t\t\t\t size_t cmpr_size, void *unc, size_t unc_size,\n\t\t\t\t u32 frame_size)\n{\n\tint err;\n\tvoid *ctx;\n\n\tif (cmpr_size == unc_size) {\n\t\t \n\t\tmemcpy(unc, cmpr, unc_size);\n\t\treturn 0;\n\t}\n\n\terr = 0;\n\tif (frame_size == 0x8000) {\n\t\tmutex_lock(&sbi->compress.mtx_lzx);\n\t\t \n\t\tctx = sbi->compress.lzx;\n\t\tif (!ctx) {\n\t\t\t \n\t\t\tctx = lzx_allocate_decompressor();\n\t\t\tif (!ctx) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out1;\n\t\t\t}\n\n\t\t\tsbi->compress.lzx = ctx;\n\t\t}\n\n\t\tif (lzx_decompress(ctx, cmpr, cmpr_size, unc, unc_size)) {\n\t\t\t \n\t\t\terr = -EINVAL;\n\t\t}\nout1:\n\t\tmutex_unlock(&sbi->compress.mtx_lzx);\n\t} else {\n\t\t \n\t\tmutex_lock(&sbi->compress.mtx_xpress);\n\t\tctx = sbi->compress.xpress;\n\t\tif (!ctx) {\n\t\t\t \n\t\t\tctx = xpress_allocate_decompressor();\n\t\t\tif (!ctx) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out2;\n\t\t\t}\n\n\t\t\tsbi->compress.xpress = ctx;\n\t\t}\n\n\t\tif (xpress_decompress(ctx, cmpr, cmpr_size, unc, unc_size)) {\n\t\t\t \n\t\t\terr = -EINVAL;\n\t\t}\nout2:\n\t\tmutex_unlock(&sbi->compress.mtx_xpress);\n\t}\n\treturn err;\n}\n#endif\n\n \nint ni_read_frame(struct ntfs_inode *ni, u64 frame_vbo, struct page **pages,\n\t\t  u32 pages_per_frame)\n{\n\tint err;\n\tstruct ntfs_sb_info *sbi = ni->mi.sbi;\n\tu8 cluster_bits = sbi->cluster_bits;\n\tchar *frame_ondisk = NULL;\n\tchar *frame_mem = NULL;\n\tstruct page **pages_disk = NULL;\n\tstruct ATTR_LIST_ENTRY *le = NULL;\n\tstruct runs_tree *run = &ni->file.run;\n\tu64 valid_size = ni->i_valid;\n\tu64 vbo_disk;\n\tsize_t unc_size;\n\tu32 frame_size, i, npages_disk, ondisk_size;\n\tstruct page *pg;\n\tstruct ATTRIB *attr;\n\tCLST frame, clst_data;\n\n\t \n\tfor (i = 0; i < pages_per_frame; i++)\n\t\tkmap(pages[i]);\n\n\tframe_size = pages_per_frame << PAGE_SHIFT;\n\tframe_mem = vmap(pages, pages_per_frame, VM_MAP, PAGE_KERNEL);\n\tif (!frame_mem) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tattr = ni_find_attr(ni, NULL, &le, ATTR_DATA, NULL, 0, NULL, NULL);\n\tif (!attr) {\n\t\terr = -ENOENT;\n\t\tgoto out1;\n\t}\n\n\tif (!attr->non_res) {\n\t\tu32 data_size = le32_to_cpu(attr->res.data_size);\n\n\t\tmemset(frame_mem, 0, frame_size);\n\t\tif (frame_vbo < data_size) {\n\t\t\tondisk_size = data_size - frame_vbo;\n\t\t\tmemcpy(frame_mem, resident_data(attr) + frame_vbo,\n\t\t\t       min(ondisk_size, frame_size));\n\t\t}\n\t\terr = 0;\n\t\tgoto out1;\n\t}\n\n\tif (frame_vbo >= valid_size) {\n\t\tmemset(frame_mem, 0, frame_size);\n\t\terr = 0;\n\t\tgoto out1;\n\t}\n\n\tif (ni->ni_flags & NI_FLAG_COMPRESSED_MASK) {\n#ifndef CONFIG_NTFS3_LZX_XPRESS\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out1;\n#else\n\t\tu32 frame_bits = ni_ext_compress_bits(ni);\n\t\tu64 frame64 = frame_vbo >> frame_bits;\n\t\tu64 frames, vbo_data;\n\n\t\tif (frame_size != (1u << frame_bits)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out1;\n\t\t}\n\t\tswitch (frame_size) {\n\t\tcase 0x1000:\n\t\tcase 0x2000:\n\t\tcase 0x4000:\n\t\tcase 0x8000:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out1;\n\t\t}\n\n\t\tattr = ni_find_attr(ni, attr, &le, ATTR_DATA, WOF_NAME,\n\t\t\t\t    ARRAY_SIZE(WOF_NAME), NULL, NULL);\n\t\tif (!attr) {\n\t\t\tntfs_inode_err(\n\t\t\t\t&ni->vfs_inode,\n\t\t\t\t\"external compressed file should contains data attribute \\\"WofCompressedData\\\"\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto out1;\n\t\t}\n\n\t\tif (!attr->non_res) {\n\t\t\trun = NULL;\n\t\t} else {\n\t\t\trun = run_alloc();\n\t\t\tif (!run) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out1;\n\t\t\t}\n\t\t}\n\n\t\tframes = (ni->vfs_inode.i_size - 1) >> frame_bits;\n\n\t\terr = attr_wof_frame_info(ni, attr, run, frame64, frames,\n\t\t\t\t\t  frame_bits, &ondisk_size, &vbo_data);\n\t\tif (err)\n\t\t\tgoto out2;\n\n\t\tif (frame64 == frames) {\n\t\t\tunc_size = 1 + ((ni->vfs_inode.i_size - 1) &\n\t\t\t\t\t(frame_size - 1));\n\t\t\tondisk_size = attr_size(attr) - vbo_data;\n\t\t} else {\n\t\t\tunc_size = frame_size;\n\t\t}\n\n\t\tif (ondisk_size > frame_size) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out2;\n\t\t}\n\n\t\tif (!attr->non_res) {\n\t\t\tif (vbo_data + ondisk_size >\n\t\t\t    le32_to_cpu(attr->res.data_size)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out1;\n\t\t\t}\n\n\t\t\terr = decompress_lzx_xpress(\n\t\t\t\tsbi, Add2Ptr(resident_data(attr), vbo_data),\n\t\t\t\tondisk_size, frame_mem, unc_size, frame_size);\n\t\t\tgoto out1;\n\t\t}\n\t\tvbo_disk = vbo_data;\n\t\t \n\t\terr = attr_load_runs_range(ni, ATTR_DATA, WOF_NAME,\n\t\t\t\t\t   ARRAY_SIZE(WOF_NAME), run, vbo_disk,\n\t\t\t\t\t   vbo_data + ondisk_size);\n\t\tif (err)\n\t\t\tgoto out2;\n\t\tnpages_disk = (ondisk_size + (vbo_disk & (PAGE_SIZE - 1)) +\n\t\t\t       PAGE_SIZE - 1) >>\n\t\t\t      PAGE_SHIFT;\n#endif\n\t} else if (is_attr_compressed(attr)) {\n\t\t \n\t\tif (sbi->cluster_size > NTFS_LZNT_MAX_CLUSTER) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out1;\n\t\t}\n\n\t\tif (attr->nres.c_unit != NTFS_LZNT_CUNIT) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out1;\n\t\t}\n\n\t\tdown_write(&ni->file.run_lock);\n\t\trun_truncate_around(run, le64_to_cpu(attr->nres.svcn));\n\t\tframe = frame_vbo >> (cluster_bits + NTFS_LZNT_CUNIT);\n\t\terr = attr_is_frame_compressed(ni, attr, frame, &clst_data);\n\t\tup_write(&ni->file.run_lock);\n\t\tif (err)\n\t\t\tgoto out1;\n\n\t\tif (!clst_data) {\n\t\t\tmemset(frame_mem, 0, frame_size);\n\t\t\tgoto out1;\n\t\t}\n\n\t\tframe_size = sbi->cluster_size << NTFS_LZNT_CUNIT;\n\t\tondisk_size = clst_data << cluster_bits;\n\n\t\tif (clst_data >= NTFS_LZNT_CLUSTERS) {\n\t\t\t \n\t\t\tdown_read(&ni->file.run_lock);\n\t\t\terr = ntfs_bio_pages(sbi, run, pages, pages_per_frame,\n\t\t\t\t\t     frame_vbo, ondisk_size,\n\t\t\t\t\t     REQ_OP_READ);\n\t\t\tup_read(&ni->file.run_lock);\n\t\t\tgoto out1;\n\t\t}\n\t\tvbo_disk = frame_vbo;\n\t\tnpages_disk = (ondisk_size + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t} else {\n\t\t__builtin_unreachable();\n\t\terr = -EINVAL;\n\t\tgoto out1;\n\t}\n\n\tpages_disk = kzalloc(npages_disk * sizeof(struct page *), GFP_NOFS);\n\tif (!pages_disk) {\n\t\terr = -ENOMEM;\n\t\tgoto out2;\n\t}\n\n\tfor (i = 0; i < npages_disk; i++) {\n\t\tpg = alloc_page(GFP_KERNEL);\n\t\tif (!pg) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out3;\n\t\t}\n\t\tpages_disk[i] = pg;\n\t\tlock_page(pg);\n\t\tkmap(pg);\n\t}\n\n\t \n\tdown_read(&ni->file.run_lock);\n\terr = ntfs_bio_pages(sbi, run, pages_disk, npages_disk, vbo_disk,\n\t\t\t     ondisk_size, REQ_OP_READ);\n\tup_read(&ni->file.run_lock);\n\tif (err)\n\t\tgoto out3;\n\n\t \n\tframe_ondisk = vmap(pages_disk, npages_disk, VM_MAP, PAGE_KERNEL_RO);\n\tif (!frame_ondisk) {\n\t\terr = -ENOMEM;\n\t\tgoto out3;\n\t}\n\n\t \n#ifdef CONFIG_NTFS3_LZX_XPRESS\n\tif (run != &ni->file.run) {\n\t\t \n\t\terr = decompress_lzx_xpress(\n\t\t\tsbi, frame_ondisk + (vbo_disk & (PAGE_SIZE - 1)),\n\t\t\tondisk_size, frame_mem, unc_size, frame_size);\n\t} else\n#endif\n\t{\n\t\t \n\t\tunc_size = decompress_lznt(frame_ondisk, ondisk_size, frame_mem,\n\t\t\t\t\t   frame_size);\n\t\tif ((ssize_t)unc_size < 0)\n\t\t\terr = unc_size;\n\t\telse if (!unc_size || unc_size > frame_size)\n\t\t\terr = -EINVAL;\n\t}\n\tif (!err && valid_size < frame_vbo + frame_size) {\n\t\tsize_t ok = valid_size - frame_vbo;\n\n\t\tmemset(frame_mem + ok, 0, frame_size - ok);\n\t}\n\n\tvunmap(frame_ondisk);\n\nout3:\n\tfor (i = 0; i < npages_disk; i++) {\n\t\tpg = pages_disk[i];\n\t\tif (pg) {\n\t\t\tkunmap(pg);\n\t\t\tunlock_page(pg);\n\t\t\tput_page(pg);\n\t\t}\n\t}\n\tkfree(pages_disk);\n\nout2:\n#ifdef CONFIG_NTFS3_LZX_XPRESS\n\tif (run != &ni->file.run)\n\t\trun_free(run);\n#endif\nout1:\n\tvunmap(frame_mem);\nout:\n\tfor (i = 0; i < pages_per_frame; i++) {\n\t\tpg = pages[i];\n\t\tkunmap(pg);\n\t\tClearPageError(pg);\n\t\tSetPageUptodate(pg);\n\t}\n\n\treturn err;\n}\n\n \nint ni_write_frame(struct ntfs_inode *ni, struct page **pages,\n\t\t   u32 pages_per_frame)\n{\n\tint err;\n\tstruct ntfs_sb_info *sbi = ni->mi.sbi;\n\tu8 frame_bits = NTFS_LZNT_CUNIT + sbi->cluster_bits;\n\tu32 frame_size = sbi->cluster_size << NTFS_LZNT_CUNIT;\n\tu64 frame_vbo = (u64)pages[0]->index << PAGE_SHIFT;\n\tCLST frame = frame_vbo >> frame_bits;\n\tchar *frame_ondisk = NULL;\n\tstruct page **pages_disk = NULL;\n\tstruct ATTR_LIST_ENTRY *le = NULL;\n\tchar *frame_mem;\n\tstruct ATTRIB *attr;\n\tstruct mft_inode *mi;\n\tu32 i;\n\tstruct page *pg;\n\tsize_t compr_size, ondisk_size;\n\tstruct lznt *lznt;\n\n\tattr = ni_find_attr(ni, NULL, &le, ATTR_DATA, NULL, 0, NULL, &mi);\n\tif (!attr) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (WARN_ON(!is_attr_compressed(attr))) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (sbi->cluster_size > NTFS_LZNT_MAX_CLUSTER) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tif (!attr->non_res) {\n\t\tdown_write(&ni->file.run_lock);\n\t\terr = attr_make_nonresident(ni, attr, le, mi,\n\t\t\t\t\t    le32_to_cpu(attr->res.data_size),\n\t\t\t\t\t    &ni->file.run, &attr, pages[0]);\n\t\tup_write(&ni->file.run_lock);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (attr->nres.c_unit != NTFS_LZNT_CUNIT) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tpages_disk = kcalloc(pages_per_frame, sizeof(struct page *), GFP_NOFS);\n\tif (!pages_disk) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < pages_per_frame; i++) {\n\t\tpg = alloc_page(GFP_KERNEL);\n\t\tif (!pg) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out1;\n\t\t}\n\t\tpages_disk[i] = pg;\n\t\tlock_page(pg);\n\t\tkmap(pg);\n\t}\n\n\t \n\tframe_ondisk = vmap(pages_disk, pages_per_frame, VM_MAP, PAGE_KERNEL);\n\tif (!frame_ondisk) {\n\t\terr = -ENOMEM;\n\t\tgoto out1;\n\t}\n\n\tfor (i = 0; i < pages_per_frame; i++)\n\t\tkmap(pages[i]);\n\n\t \n\tframe_mem = vmap(pages, pages_per_frame, VM_MAP, PAGE_KERNEL_RO);\n\tif (!frame_mem) {\n\t\terr = -ENOMEM;\n\t\tgoto out2;\n\t}\n\n\tmutex_lock(&sbi->compress.mtx_lznt);\n\tlznt = NULL;\n\tif (!sbi->compress.lznt) {\n\t\t \n\t\tlznt = get_lznt_ctx(0);\n\t\tif (!lznt) {\n\t\t\tmutex_unlock(&sbi->compress.mtx_lznt);\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out3;\n\t\t}\n\n\t\tsbi->compress.lznt = lznt;\n\t\tlznt = NULL;\n\t}\n\n\t \n\tcompr_size = compress_lznt(frame_mem, frame_size, frame_ondisk,\n\t\t\t\t   frame_size, sbi->compress.lznt);\n\tmutex_unlock(&sbi->compress.mtx_lznt);\n\tkfree(lznt);\n\n\tif (compr_size + sbi->cluster_size > frame_size) {\n\t\t \n\t\tcompr_size = frame_size;\n\t\tondisk_size = frame_size;\n\t} else if (compr_size) {\n\t\t \n\t\tondisk_size = ntfs_up_cluster(sbi, compr_size);\n\t\tmemset(frame_ondisk + compr_size, 0, ondisk_size - compr_size);\n\t} else {\n\t\t \n\t\tondisk_size = 0;\n\t}\n\n\tdown_write(&ni->file.run_lock);\n\trun_truncate_around(&ni->file.run, le64_to_cpu(attr->nres.svcn));\n\terr = attr_allocate_frame(ni, frame, compr_size, ni->i_valid);\n\tup_write(&ni->file.run_lock);\n\tif (err)\n\t\tgoto out2;\n\n\tif (!ondisk_size)\n\t\tgoto out2;\n\n\tdown_read(&ni->file.run_lock);\n\terr = ntfs_bio_pages(sbi, &ni->file.run,\n\t\t\t     ondisk_size < frame_size ? pages_disk : pages,\n\t\t\t     pages_per_frame, frame_vbo, ondisk_size,\n\t\t\t     REQ_OP_WRITE);\n\tup_read(&ni->file.run_lock);\n\nout3:\n\tvunmap(frame_mem);\n\nout2:\n\tfor (i = 0; i < pages_per_frame; i++)\n\t\tkunmap(pages[i]);\n\n\tvunmap(frame_ondisk);\nout1:\n\tfor (i = 0; i < pages_per_frame; i++) {\n\t\tpg = pages_disk[i];\n\t\tif (pg) {\n\t\t\tkunmap(pg);\n\t\t\tunlock_page(pg);\n\t\t\tput_page(pg);\n\t\t}\n\t}\n\tkfree(pages_disk);\nout:\n\treturn err;\n}\n\n \nint ni_remove_name(struct ntfs_inode *dir_ni, struct ntfs_inode *ni,\n\t\t   struct NTFS_DE *de, struct NTFS_DE **de2, int *undo_step)\n{\n\tint err;\n\tstruct ntfs_sb_info *sbi = ni->mi.sbi;\n\tstruct ATTR_FILE_NAME *de_name = (struct ATTR_FILE_NAME *)(de + 1);\n\tstruct ATTR_FILE_NAME *fname;\n\tstruct ATTR_LIST_ENTRY *le;\n\tstruct mft_inode *mi;\n\tu16 de_key_size = le16_to_cpu(de->key_size);\n\tu8 name_type;\n\n\t*undo_step = 0;\n\n\t \n\tmi_get_ref(&dir_ni->mi, &de_name->home);\n\n\tfname = ni_fname_name(ni, (struct le_str *)&de_name->name_len,\n\t\t\t      &de_name->home, &mi, &le);\n\tif (!fname)\n\t\treturn -ENOENT;\n\n\tmemcpy(&de_name->dup, &fname->dup, sizeof(struct NTFS_DUP_INFO));\n\tname_type = paired_name(fname->type);\n\n\t \n\tntfs_set_state(sbi, NTFS_DIRTY_DIRTY);\n\n\t \n\terr = indx_delete_entry(&dir_ni->dir, dir_ni, fname, de_key_size, sbi);\n\tif (err)\n\t\treturn err;\n\n\t \n\tni_remove_attr_le(ni, attr_from_name(fname), mi, le);\n\n\t*undo_step = 2;\n\n\t \n\tfname = ni_fname_type(ni, name_type, &mi, &le);\n\tif (fname) {\n\t\tu16 de2_key_size = fname_full_size(fname);\n\n\t\t*de2 = Add2Ptr(de, 1024);\n\t\t(*de2)->key_size = cpu_to_le16(de2_key_size);\n\n\t\tmemcpy(*de2 + 1, fname, de2_key_size);\n\n\t\t \n\t\terr = indx_delete_entry(&dir_ni->dir, dir_ni, fname,\n\t\t\t\t\tde2_key_size, sbi);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t \n\t\tni_remove_attr_le(ni, attr_from_name(fname), mi, le);\n\n\t\t*undo_step = 4;\n\t}\n\treturn 0;\n}\n\n \nbool ni_remove_name_undo(struct ntfs_inode *dir_ni, struct ntfs_inode *ni,\n\t\t\t struct NTFS_DE *de, struct NTFS_DE *de2, int undo_step)\n{\n\tstruct ntfs_sb_info *sbi = ni->mi.sbi;\n\tstruct ATTRIB *attr;\n\tu16 de_key_size;\n\n\tswitch (undo_step) {\n\tcase 4:\n\t\tde_key_size = le16_to_cpu(de2->key_size);\n\t\tif (ni_insert_resident(ni, de_key_size, ATTR_NAME, NULL, 0,\n\t\t\t\t       &attr, NULL, NULL))\n\t\t\treturn false;\n\t\tmemcpy(Add2Ptr(attr, SIZEOF_RESIDENT), de2 + 1, de_key_size);\n\n\t\tmi_get_ref(&ni->mi, &de2->ref);\n\t\tde2->size = cpu_to_le16(ALIGN(de_key_size, 8) +\n\t\t\t\t\tsizeof(struct NTFS_DE));\n\t\tde2->flags = 0;\n\t\tde2->res = 0;\n\n\t\tif (indx_insert_entry(&dir_ni->dir, dir_ni, de2, sbi, NULL, 1))\n\t\t\treturn false;\n\t\tfallthrough;\n\n\tcase 2:\n\t\tde_key_size = le16_to_cpu(de->key_size);\n\n\t\tif (ni_insert_resident(ni, de_key_size, ATTR_NAME, NULL, 0,\n\t\t\t\t       &attr, NULL, NULL))\n\t\t\treturn false;\n\n\t\tmemcpy(Add2Ptr(attr, SIZEOF_RESIDENT), de + 1, de_key_size);\n\t\tmi_get_ref(&ni->mi, &de->ref);\n\n\t\tif (indx_insert_entry(&dir_ni->dir, dir_ni, de, sbi, NULL, 1))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nint ni_add_name(struct ntfs_inode *dir_ni, struct ntfs_inode *ni,\n\t\tstruct NTFS_DE *de)\n{\n\tint err;\n\tstruct ntfs_sb_info *sbi = ni->mi.sbi;\n\tstruct ATTRIB *attr;\n\tstruct ATTR_LIST_ENTRY *le;\n\tstruct mft_inode *mi;\n\tstruct ATTR_FILE_NAME *fname;\n\tstruct ATTR_FILE_NAME *de_name = (struct ATTR_FILE_NAME *)(de + 1);\n\tu16 de_key_size = le16_to_cpu(de->key_size);\n\n\tif (sbi->options->windows_names &&\n\t    !valid_windows_name(sbi, (struct le_str *)&de_name->name_len))\n\t\treturn -EINVAL;\n\n\t \n\tif (ni->mi.sbi->options->hide_dot_files) {\n\t\tif (de_name->name_len > 0 &&\n\t\t    le16_to_cpu(de_name->name[0]) == '.')\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_HIDDEN;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_HIDDEN;\n\t}\n\n\tmi_get_ref(&ni->mi, &de->ref);\n\tmi_get_ref(&dir_ni->mi, &de_name->home);\n\n\t \n\tfname = ni_fname_name(ni, NULL, NULL, NULL, NULL);\n\tif (fname)\n\t\tmemcpy(&de_name->dup, &fname->dup, sizeof(fname->dup));\n\tde_name->dup.fa = ni->std_fa;\n\n\t \n\terr = ni_insert_resident(ni, de_key_size, ATTR_NAME, NULL, 0, &attr,\n\t\t\t\t &mi, &le);\n\tif (err)\n\t\treturn err;\n\n\tmemcpy(Add2Ptr(attr, SIZEOF_RESIDENT), de_name, de_key_size);\n\n\t \n\terr = indx_insert_entry(&dir_ni->dir, dir_ni, de, sbi, NULL, 0);\n\tif (err)\n\t\tni_remove_attr_le(ni, attr, mi, le);\n\n\treturn err;\n}\n\n \nint ni_rename(struct ntfs_inode *dir_ni, struct ntfs_inode *new_dir_ni,\n\t      struct ntfs_inode *ni, struct NTFS_DE *de, struct NTFS_DE *new_de,\n\t      bool *is_bad)\n{\n\tint err;\n\tstruct NTFS_DE *de2 = NULL;\n\tint undo = 0;\n\n\t \n\n\t \n\terr = ni_add_name(new_dir_ni, ni, new_de);\n\tif (!err) {\n\t\terr = ni_remove_name(dir_ni, ni, de, &de2, &undo);\n\t\tif (err && ni_remove_name(new_dir_ni, ni, new_de, &de2, &undo))\n\t\t\t*is_bad = true;\n\t}\n\n\t \n\t \n\n\treturn err;\n}\n\n \nbool ni_is_dirty(struct inode *inode)\n{\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tstruct rb_node *node;\n\n\tif (ni->mi.dirty || ni->attr_list.dirty ||\n\t    (ni->ni_flags & NI_FLAG_UPDATE_PARENT))\n\t\treturn true;\n\n\tfor (node = rb_first(&ni->mi_tree); node; node = rb_next(node)) {\n\t\tif (rb_entry(node, struct mft_inode, node)->dirty)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nstatic bool ni_update_parent(struct ntfs_inode *ni, struct NTFS_DUP_INFO *dup,\n\t\t\t     int sync)\n{\n\tstruct ATTRIB *attr;\n\tstruct mft_inode *mi;\n\tstruct ATTR_LIST_ENTRY *le = NULL;\n\tstruct ntfs_sb_info *sbi = ni->mi.sbi;\n\tstruct super_block *sb = sbi->sb;\n\tbool re_dirty = false;\n\n\tif (ni->mi.mrec->flags & RECORD_FLAG_DIR) {\n\t\tdup->fa |= FILE_ATTRIBUTE_DIRECTORY;\n\t\tattr = NULL;\n\t\tdup->alloc_size = 0;\n\t\tdup->data_size = 0;\n\t} else {\n\t\tdup->fa &= ~FILE_ATTRIBUTE_DIRECTORY;\n\n\t\tattr = ni_find_attr(ni, NULL, &le, ATTR_DATA, NULL, 0, NULL,\n\t\t\t\t    &mi);\n\t\tif (!attr) {\n\t\t\tdup->alloc_size = dup->data_size = 0;\n\t\t} else if (!attr->non_res) {\n\t\t\tu32 data_size = le32_to_cpu(attr->res.data_size);\n\n\t\t\tdup->alloc_size = cpu_to_le64(ALIGN(data_size, 8));\n\t\t\tdup->data_size = cpu_to_le64(data_size);\n\t\t} else {\n\t\t\tu64 new_valid = ni->i_valid;\n\t\t\tu64 data_size = le64_to_cpu(attr->nres.data_size);\n\t\t\t__le64 valid_le;\n\n\t\t\tdup->alloc_size = is_attr_ext(attr) ?\n\t\t\t\t\t\t  attr->nres.total_size :\n\t\t\t\t\t\t  attr->nres.alloc_size;\n\t\t\tdup->data_size = attr->nres.data_size;\n\n\t\t\tif (new_valid > data_size)\n\t\t\t\tnew_valid = data_size;\n\n\t\t\tvalid_le = cpu_to_le64(new_valid);\n\t\t\tif (valid_le != attr->nres.valid_size) {\n\t\t\t\tattr->nres.valid_size = valid_le;\n\t\t\t\tmi->dirty = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tdup->reparse = 0;\n\tdup->ea_size = 0;\n\n\tif (ni->ni_flags & NI_FLAG_EA) {\n\t\tattr = ni_find_attr(ni, attr, &le, ATTR_EA_INFO, NULL, 0, NULL,\n\t\t\t\t    NULL);\n\t\tif (attr) {\n\t\t\tconst struct EA_INFO *info;\n\n\t\t\tinfo = resident_data_ex(attr, sizeof(struct EA_INFO));\n\t\t\t \n\t\t\tif (info)\n\t\t\t\tdup->ea_size = info->size_pack;\n\t\t}\n\t}\n\n\tattr = NULL;\n\tle = NULL;\n\n\twhile ((attr = ni_find_attr(ni, attr, &le, ATTR_NAME, NULL, 0, NULL,\n\t\t\t\t    &mi))) {\n\t\tstruct inode *dir;\n\t\tstruct ATTR_FILE_NAME *fname;\n\n\t\tfname = resident_data_ex(attr, SIZEOF_ATTRIBUTE_FILENAME);\n\t\tif (!fname || !memcmp(&fname->dup, dup, sizeof(fname->dup)))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (ino_get(&fname->home) == ni->vfs_inode.i_ino) {\n\t\t\tntfs_set_state(sbi, NTFS_DIRTY_ERROR);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tdir = ntfs_iget5(sb, &fname->home, NULL);\n\t\tif (IS_ERR(dir)) {\n\t\t\tntfs_inode_warn(\n\t\t\t\t&ni->vfs_inode,\n\t\t\t\t\"failed to open parent directory r=%lx to update\",\n\t\t\t\t(long)ino_get(&fname->home));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!is_bad_inode(dir)) {\n\t\t\tstruct ntfs_inode *dir_ni = ntfs_i(dir);\n\n\t\t\tif (!ni_trylock(dir_ni)) {\n\t\t\t\tre_dirty = true;\n\t\t\t} else {\n\t\t\t\tindx_update_dup(dir_ni, sbi, fname, dup, sync);\n\t\t\t\tni_unlock(dir_ni);\n\t\t\t\tmemcpy(&fname->dup, dup, sizeof(fname->dup));\n\t\t\t\tmi->dirty = true;\n\t\t\t}\n\t\t}\n\t\tiput(dir);\n\t}\n\n\treturn re_dirty;\n}\n\n \nint ni_write_inode(struct inode *inode, int sync, const char *hint)\n{\n\tint err = 0, err2;\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ntfs_sb_info *sbi = sb->s_fs_info;\n\tbool re_dirty = false;\n\tstruct ATTR_STD_INFO *std;\n\tstruct rb_node *node, *next;\n\tstruct NTFS_DUP_INFO dup;\n\n\tif (is_bad_inode(inode) || sb_rdonly(sb))\n\t\treturn 0;\n\n\tif (!ni_trylock(ni)) {\n\t\t \n\t\tmark_inode_dirty_sync(inode);\n\t\treturn 0;\n\t}\n\n\tif (!ni->mi.mrec)\n\t\tgoto out;\n\n\tif (is_rec_inuse(ni->mi.mrec) &&\n\t    !(sbi->flags & NTFS_FLAGS_LOG_REPLAYING) && inode->i_nlink) {\n\t\tbool modified = false;\n\t\tstruct timespec64 ctime = inode_get_ctime(inode);\n\n\t\t \n\t\tstd = ni_std(ni);\n\t\tif (!std) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tdup.m_time = kernel2nt(&inode->i_mtime);\n\t\tif (std->m_time != dup.m_time) {\n\t\t\tstd->m_time = dup.m_time;\n\t\t\tmodified = true;\n\t\t}\n\n\t\tdup.c_time = kernel2nt(&ctime);\n\t\tif (std->c_time != dup.c_time) {\n\t\t\tstd->c_time = dup.c_time;\n\t\t\tmodified = true;\n\t\t}\n\n\t\tdup.a_time = kernel2nt(&inode->i_atime);\n\t\tif (std->a_time != dup.a_time) {\n\t\t\tstd->a_time = dup.a_time;\n\t\t\tmodified = true;\n\t\t}\n\n\t\tdup.fa = ni->std_fa;\n\t\tif (std->fa != dup.fa) {\n\t\t\tstd->fa = dup.fa;\n\t\t\tmodified = true;\n\t\t}\n\n\t\t \n\t\tif (modified)\n\t\t\tni->mi.dirty = true;\n\n\t\tif (!ntfs_is_meta_file(sbi, inode->i_ino) &&\n\t\t    (modified || (ni->ni_flags & NI_FLAG_UPDATE_PARENT))\n\t\t     \n\t\t    && (sb->s_flags & SB_ACTIVE)) {\n\t\t\tdup.cr_time = std->cr_time;\n\t\t\t \n\t\t\tre_dirty = ni_update_parent(ni, &dup, sync);\n\n\t\t\tif (re_dirty)\n\t\t\t\tni->ni_flags |= NI_FLAG_UPDATE_PARENT;\n\t\t\telse\n\t\t\t\tni->ni_flags &= ~NI_FLAG_UPDATE_PARENT;\n\t\t}\n\n\t\t \n\t\tif (ni->attr_list.size && ni->attr_list.dirty) {\n\t\t\tif (inode->i_ino != MFT_REC_MFT || sync) {\n\t\t\t\terr = ni_try_remove_attr_list(ni);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\terr = al_update(ni, sync);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfor (node = rb_first(&ni->mi_tree); node; node = next) {\n\t\tstruct mft_inode *mi = rb_entry(node, struct mft_inode, node);\n\t\tbool is_empty;\n\n\t\tnext = rb_next(node);\n\n\t\tif (!mi->dirty)\n\t\t\tcontinue;\n\n\t\tis_empty = !mi_enum_attr(mi, NULL);\n\n\t\tif (is_empty)\n\t\t\tclear_rec_inuse(mi->mrec);\n\n\t\terr2 = mi_write(mi, sync);\n\t\tif (!err && err2)\n\t\t\terr = err2;\n\n\t\tif (is_empty) {\n\t\t\tntfs_mark_rec_free(sbi, mi->rno, false);\n\t\t\trb_erase(node, &ni->mi_tree);\n\t\t\tmi_put(mi);\n\t\t}\n\t}\n\n\tif (ni->mi.dirty) {\n\t\terr2 = mi_write(&ni->mi, sync);\n\t\tif (!err && err2)\n\t\t\terr = err2;\n\t}\nout:\n\tni_unlock(ni);\n\n\tif (err) {\n\t\tntfs_inode_err(inode, \"%s failed, %d.\", hint, err);\n\t\tntfs_set_state(sbi, NTFS_DIRTY_ERROR);\n\t\treturn err;\n\t}\n\n\tif (re_dirty)\n\t\tmark_inode_dirty_sync(inode);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}