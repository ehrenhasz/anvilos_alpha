{
  "module_name": "dir.c",
  "hash_id": "bd131428e501687bb9a65d0ed72f50ccaca803b0931d05fb067fdc0215310bb4",
  "original_prompt": "Ingested from linux-6.6.14/fs/ntfs3/dir.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/nls.h>\n\n#include \"debug.h\"\n#include \"ntfs.h\"\n#include \"ntfs_fs.h\"\n\n \nint ntfs_utf16_to_nls(struct ntfs_sb_info *sbi, const __le16 *name, u32 len,\n\t\t      u8 *buf, int buf_len)\n{\n\tint ret, warn;\n\tu8 *op;\n\tstruct nls_table *nls = sbi->options->nls;\n\n\tstatic_assert(sizeof(wchar_t) == sizeof(__le16));\n\n\tif (!nls) {\n\t\t \n\t\tret = utf16s_to_utf8s((wchar_t *)name, len, UTF16_LITTLE_ENDIAN,\n\t\t\t\t      buf, buf_len);\n\t\tbuf[ret] = '\\0';\n\t\treturn ret;\n\t}\n\n\top = buf;\n\twarn = 0;\n\n\twhile (len--) {\n\t\tu16 ec;\n\t\tint charlen;\n\t\tchar dump[5];\n\n\t\tif (buf_len < NLS_MAX_CHARSET_SIZE) {\n\t\t\tntfs_warn(sbi->sb,\n\t\t\t\t  \"filename was truncated while converting.\");\n\t\t\tbreak;\n\t\t}\n\n\t\tec = le16_to_cpu(*name++);\n\t\tcharlen = nls->uni2char(ec, op, buf_len);\n\n\t\tif (charlen > 0) {\n\t\t\top += charlen;\n\t\t\tbuf_len -= charlen;\n\t\t\tcontinue;\n\t\t}\n\n\t\t*op++ = '_';\n\t\tbuf_len -= 1;\n\t\tif (warn)\n\t\t\tcontinue;\n\n\t\twarn = 1;\n\t\thex_byte_pack(&dump[0], ec >> 8);\n\t\thex_byte_pack(&dump[2], ec);\n\t\tdump[4] = 0;\n\n\t\tntfs_err(sbi->sb, \"failed to convert \\\"%s\\\" to %s\", dump,\n\t\t\t nls->charset);\n\t}\n\n\t*op = '\\0';\n\treturn op - buf;\n}\n\n\n#define PLANE_SIZE\t0x00010000\n\n#define SURROGATE_PAIR\t0x0000d800\n#define SURROGATE_LOW\t0x00000400\n#define SURROGATE_BITS\t0x000003ff\n\n\n \nstatic inline void put_utf16(wchar_t *s, unsigned int c,\n\t\t\t     enum utf16_endian endian)\n{\n\tstatic_assert(sizeof(wchar_t) == sizeof(__le16));\n\tstatic_assert(sizeof(wchar_t) == sizeof(__be16));\n\n\tswitch (endian) {\n\tdefault:\n\t\t*s = (wchar_t)c;\n\t\tbreak;\n\tcase UTF16_LITTLE_ENDIAN:\n\t\t*(__le16 *)s = __cpu_to_le16(c);\n\t\tbreak;\n\tcase UTF16_BIG_ENDIAN:\n\t\t*(__be16 *)s = __cpu_to_be16(c);\n\t\tbreak;\n\t}\n}\n\n \nstatic int _utf8s_to_utf16s(const u8 *s, int inlen, enum utf16_endian endian,\n\t\t\t    wchar_t *pwcs, int maxout)\n{\n\tu16 *op;\n\tint size;\n\tunicode_t u;\n\n\top = pwcs;\n\twhile (inlen > 0 && *s) {\n\t\tif (*s & 0x80) {\n\t\t\tsize = utf8_to_utf32(s, inlen, &u);\n\t\t\tif (size < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\ts += size;\n\t\t\tinlen -= size;\n\n\t\t\tif (u >= PLANE_SIZE) {\n\t\t\t\tif (maxout < 2)\n\t\t\t\t\treturn -ENAMETOOLONG;\n\n\t\t\t\tu -= PLANE_SIZE;\n\t\t\t\tput_utf16(op++,\n\t\t\t\t\t  SURROGATE_PAIR |\n\t\t\t\t\t\t  ((u >> 10) & SURROGATE_BITS),\n\t\t\t\t\t  endian);\n\t\t\t\tput_utf16(op++,\n\t\t\t\t\t  SURROGATE_PAIR | SURROGATE_LOW |\n\t\t\t\t\t\t  (u & SURROGATE_BITS),\n\t\t\t\t\t  endian);\n\t\t\t\tmaxout -= 2;\n\t\t\t} else {\n\t\t\t\tif (maxout < 1)\n\t\t\t\t\treturn -ENAMETOOLONG;\n\n\t\t\t\tput_utf16(op++, u, endian);\n\t\t\t\tmaxout--;\n\t\t\t}\n\t\t} else {\n\t\t\tif (maxout < 1)\n\t\t\t\treturn -ENAMETOOLONG;\n\n\t\t\tput_utf16(op++, *s++, endian);\n\t\t\tinlen--;\n\t\t\tmaxout--;\n\t\t}\n\t}\n\treturn op - pwcs;\n}\n\n \nint ntfs_nls_to_utf16(struct ntfs_sb_info *sbi, const u8 *name, u32 name_len,\n\t\t      struct cpu_str *uni, u32 max_ulen,\n\t\t      enum utf16_endian endian)\n{\n\tint ret, slen;\n\tconst u8 *end;\n\tstruct nls_table *nls = sbi->options->nls;\n\tu16 *uname = uni->name;\n\n\tstatic_assert(sizeof(wchar_t) == sizeof(u16));\n\n\tif (!nls) {\n\t\t \n\t\tret = _utf8s_to_utf16s(name, name_len, endian, uname, max_ulen);\n\t\tuni->len = ret;\n\t\treturn ret;\n\t}\n\n\tfor (ret = 0, end = name + name_len; name < end; ret++, name += slen) {\n\t\tif (ret >= max_ulen)\n\t\t\treturn -ENAMETOOLONG;\n\n\t\tslen = nls->char2uni(name, end - name, uname + ret);\n\t\tif (!slen)\n\t\t\treturn -EINVAL;\n\t\tif (slen < 0)\n\t\t\treturn slen;\n\t}\n\n#ifdef __BIG_ENDIAN\n\tif (endian == UTF16_LITTLE_ENDIAN) {\n\t\tint i = ret;\n\n\t\twhile (i--) {\n\t\t\t__cpu_to_le16s(uname);\n\t\t\tuname++;\n\t\t}\n\t}\n#else\n\tif (endian == UTF16_BIG_ENDIAN) {\n\t\tint i = ret;\n\n\t\twhile (i--) {\n\t\t\t__cpu_to_be16s(uname);\n\t\t\tuname++;\n\t\t}\n\t}\n#endif\n\n\tuni->len = ret;\n\treturn ret;\n}\n\n \nstruct inode *dir_search_u(struct inode *dir, const struct cpu_str *uni,\n\t\t\t   struct ntfs_fnd *fnd)\n{\n\tint err = 0;\n\tstruct super_block *sb = dir->i_sb;\n\tstruct ntfs_sb_info *sbi = sb->s_fs_info;\n\tstruct ntfs_inode *ni = ntfs_i(dir);\n\tstruct NTFS_DE *e;\n\tint diff;\n\tstruct inode *inode = NULL;\n\tstruct ntfs_fnd *fnd_a = NULL;\n\n\tif (!fnd) {\n\t\tfnd_a = fnd_get();\n\t\tif (!fnd_a) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tfnd = fnd_a;\n\t}\n\n\terr = indx_find(&ni->dir, ni, NULL, uni, 0, sbi, &diff, &e, fnd);\n\n\tif (err)\n\t\tgoto out;\n\n\tif (diff) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tinode = ntfs_iget5(sb, &e->ref, uni);\n\tif (!IS_ERR(inode) && is_bad_inode(inode)) {\n\t\tiput(inode);\n\t\terr = -EINVAL;\n\t}\nout:\n\tfnd_put(fnd_a);\n\n\treturn err == -ENOENT ? NULL : err ? ERR_PTR(err) : inode;\n}\n\nstatic inline int ntfs_filldir(struct ntfs_sb_info *sbi, struct ntfs_inode *ni,\n\t\t\t       const struct NTFS_DE *e, u8 *name,\n\t\t\t       struct dir_context *ctx)\n{\n\tconst struct ATTR_FILE_NAME *fname;\n\tunsigned long ino;\n\tint name_len;\n\tu32 dt_type;\n\n\tfname = Add2Ptr(e, sizeof(struct NTFS_DE));\n\n\tif (fname->type == FILE_NAME_DOS)\n\t\treturn 0;\n\n\tif (!mi_is_ref(&ni->mi, &fname->home))\n\t\treturn 0;\n\n\tino = ino_get(&e->ref);\n\n\tif (ino == MFT_REC_ROOT)\n\t\treturn 0;\n\n\t \n\tif (!sbi->options->showmeta && ntfs_is_meta_file(sbi, ino))\n\t\treturn 0;\n\n\tif (sbi->options->nohidden && (fname->dup.fa & FILE_ATTRIBUTE_HIDDEN))\n\t\treturn 0;\n\n\tname_len = ntfs_utf16_to_nls(sbi, fname->name, fname->name_len, name,\n\t\t\t\t     PATH_MAX);\n\tif (name_len <= 0) {\n\t\tntfs_warn(sbi->sb, \"failed to convert name for inode %lx.\",\n\t\t\t  ino);\n\t\treturn 0;\n\t}\n\n\t \n\tif (fname->dup.fa & FILE_ATTRIBUTE_REPARSE_POINT)\n\t\tdt_type = DT_LNK;\n\telse\n\t\tdt_type = (fname->dup.fa & FILE_ATTRIBUTE_DIRECTORY) ? DT_DIR : DT_REG;\n\n\treturn !dir_emit(ctx, (s8 *)name, name_len, ino, dt_type);\n}\n\n \nstatic int ntfs_read_hdr(struct ntfs_sb_info *sbi, struct ntfs_inode *ni,\n\t\t\t const struct INDEX_HDR *hdr, u64 vbo, u64 pos,\n\t\t\t u8 *name, struct dir_context *ctx)\n{\n\tint err;\n\tconst struct NTFS_DE *e;\n\tu32 e_size;\n\tu32 end = le32_to_cpu(hdr->used);\n\tu32 off = le32_to_cpu(hdr->de_off);\n\n\tfor (;; off += e_size) {\n\t\tif (off + sizeof(struct NTFS_DE) > end)\n\t\t\treturn -1;\n\n\t\te = Add2Ptr(hdr, off);\n\t\te_size = le16_to_cpu(e->size);\n\t\tif (e_size < sizeof(struct NTFS_DE) || off + e_size > end)\n\t\t\treturn -1;\n\n\t\tif (de_is_last(e))\n\t\t\treturn 0;\n\n\t\t \n\t\tif (vbo + off < pos)\n\t\t\tcontinue;\n\n\t\tif (le16_to_cpu(e->key_size) < SIZEOF_ATTRIBUTE_FILENAME)\n\t\t\treturn -1;\n\n\t\tctx->pos = vbo + off;\n\n\t\t \n\t\terr = ntfs_filldir(sbi, ni, e, name, ctx);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n}\n\n \nstatic int ntfs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tconst struct INDEX_ROOT *root;\n\tu64 vbo;\n\tsize_t bit;\n\tloff_t eod;\n\tint err = 0;\n\tstruct inode *dir = file_inode(file);\n\tstruct ntfs_inode *ni = ntfs_i(dir);\n\tstruct super_block *sb = dir->i_sb;\n\tstruct ntfs_sb_info *sbi = sb->s_fs_info;\n\tloff_t i_size = i_size_read(dir);\n\tu32 pos = ctx->pos;\n\tu8 *name = NULL;\n\tstruct indx_node *node = NULL;\n\tu8 index_bits = ni->dir.index_bits;\n\n\t \n\tstatic_assert(NTFS_NAME_LEN * 4 < PATH_MAX);\n\n\teod = i_size + sbi->record_size;\n\n\tif (pos >= eod)\n\t\treturn 0;\n\n\tif (!dir_emit_dots(file, ctx))\n\t\treturn 0;\n\n\t \n\tname = __getname();\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tif (!ni->mi_loaded && ni->attr_list.size) {\n\t\t \n\t\tni_lock(ni);\n\t\tif (!ni->mi_loaded && ni->attr_list.size) {\n\t\t\terr = ni_load_all_mi(ni);\n\t\t\tif (!err)\n\t\t\t\tni->mi_loaded = true;\n\t\t}\n\t\tni_unlock(ni);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\troot = indx_get_root(&ni->dir, ni, NULL, NULL);\n\tif (!root) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (pos >= sbi->record_size) {\n\t\tbit = (pos - sbi->record_size) >> index_bits;\n\t} else {\n\t\terr = ntfs_read_hdr(sbi, ni, &root->ihdr, 0, pos, name, ctx);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tbit = 0;\n\t}\n\n\tif (!i_size) {\n\t\tctx->pos = eod;\n\t\tgoto out;\n\t}\n\n\tfor (;;) {\n\t\tvbo = (u64)bit << index_bits;\n\t\tif (vbo >= i_size) {\n\t\t\tctx->pos = eod;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = indx_used_bit(&ni->dir, ni, &bit);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tif (bit == MINUS_ONE_T) {\n\t\t\tctx->pos = eod;\n\t\t\tgoto out;\n\t\t}\n\n\t\tvbo = (u64)bit << index_bits;\n\t\tif (vbo >= i_size) {\n\t\t\tntfs_inode_err(dir, \"Looks like your dir is corrupt\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = indx_read(&ni->dir, ni, bit << ni->dir.idx2vbn_bits,\n\t\t\t\t&node);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = ntfs_read_hdr(sbi, ni, &node->index->ihdr,\n\t\t\t\t    vbo + sbi->record_size, pos, name, ctx);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tbit += 1;\n\t}\n\nout:\n\n\t__putname(name);\n\tput_indx_node(node);\n\n\tif (err == -ENOENT) {\n\t\terr = 0;\n\t\tctx->pos = pos;\n\t}\n\n\treturn err;\n}\n\nstatic int ntfs_dir_count(struct inode *dir, bool *is_empty, size_t *dirs,\n\t\t\t  size_t *files)\n{\n\tint err = 0;\n\tstruct ntfs_inode *ni = ntfs_i(dir);\n\tstruct NTFS_DE *e = NULL;\n\tstruct INDEX_ROOT *root;\n\tstruct INDEX_HDR *hdr;\n\tconst struct ATTR_FILE_NAME *fname;\n\tu32 e_size, off, end;\n\tu64 vbo = 0;\n\tsize_t drs = 0, fles = 0, bit = 0;\n\tloff_t i_size = ni->vfs_inode.i_size;\n\tstruct indx_node *node = NULL;\n\tu8 index_bits = ni->dir.index_bits;\n\n\tif (is_empty)\n\t\t*is_empty = true;\n\n\troot = indx_get_root(&ni->dir, ni, NULL, NULL);\n\tif (!root)\n\t\treturn -EINVAL;\n\n\thdr = &root->ihdr;\n\n\tfor (;;) {\n\t\tend = le32_to_cpu(hdr->used);\n\t\toff = le32_to_cpu(hdr->de_off);\n\n\t\tfor (; off + sizeof(struct NTFS_DE) <= end; off += e_size) {\n\t\t\te = Add2Ptr(hdr, off);\n\t\t\te_size = le16_to_cpu(e->size);\n\t\t\tif (e_size < sizeof(struct NTFS_DE) ||\n\t\t\t    off + e_size > end)\n\t\t\t\tbreak;\n\n\t\t\tif (de_is_last(e))\n\t\t\t\tbreak;\n\n\t\t\tfname = de_get_fname(e);\n\t\t\tif (!fname)\n\t\t\t\tcontinue;\n\n\t\t\tif (fname->type == FILE_NAME_DOS)\n\t\t\t\tcontinue;\n\n\t\t\tif (is_empty) {\n\t\t\t\t*is_empty = false;\n\t\t\t\tif (!dirs && !files)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (fname->dup.fa & FILE_ATTRIBUTE_DIRECTORY)\n\t\t\t\tdrs += 1;\n\t\t\telse\n\t\t\t\tfles += 1;\n\t\t}\n\n\t\tif (vbo >= i_size)\n\t\t\tgoto out;\n\n\t\terr = indx_used_bit(&ni->dir, ni, &bit);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tif (bit == MINUS_ONE_T)\n\t\t\tgoto out;\n\n\t\tvbo = (u64)bit << index_bits;\n\t\tif (vbo >= i_size)\n\t\t\tgoto out;\n\n\t\terr = indx_read(&ni->dir, ni, bit << ni->dir.idx2vbn_bits,\n\t\t\t\t&node);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\thdr = &node->index->ihdr;\n\t\tbit += 1;\n\t\tvbo = (u64)bit << ni->dir.idx2vbn_bits;\n\t}\n\nout:\n\tput_indx_node(node);\n\tif (dirs)\n\t\t*dirs = drs;\n\tif (files)\n\t\t*files = fles;\n\n\treturn err;\n}\n\nbool dir_is_empty(struct inode *dir)\n{\n\tbool is_empty = false;\n\n\tntfs_dir_count(dir, &is_empty, NULL, NULL);\n\n\treturn is_empty;\n}\n\n\nconst struct file_operations ntfs_dir_operations = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= generic_read_dir,\n\t.iterate_shared\t= ntfs_readdir,\n\t.fsync\t\t= generic_file_fsync,\n\t.open\t\t= ntfs_file_open,\n};\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}