{
  "module_name": "lznt.c",
  "hash_id": "1f6d0ce2574470b24e37e7d8a1cfbeecaf0c9d8b4f749030c50e8f2779858a04",
  "original_prompt": "Ingested from linux-6.6.14/fs/ntfs3/lznt.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/string.h>\n#include <linux/types.h>\n\n#include \"debug.h\"\n#include \"ntfs_fs.h\"\n\n\n \n#define LZNT_ERROR_ALL_ZEROS\t1\n#define LZNT_CHUNK_SIZE\t\t0x1000\n\n\nstruct lznt_hash {\n\tconst u8 *p1;\n\tconst u8 *p2;\n};\n\nstruct lznt {\n\tconst u8 *unc;\n\tconst u8 *unc_end;\n\tconst u8 *best_match;\n\tsize_t max_len;\n\tbool std;\n\n\tstruct lznt_hash hash[LZNT_CHUNK_SIZE];\n};\n\nstatic inline size_t get_match_len(const u8 *ptr, const u8 *end, const u8 *prev,\n\t\t\t\t   size_t max_len)\n{\n\tsize_t len = 0;\n\n\twhile (ptr + len < end && ptr[len] == prev[len] && ++len < max_len)\n\t\t;\n\treturn len;\n}\n\nstatic size_t longest_match_std(const u8 *src, struct lznt *ctx)\n{\n\tsize_t hash_index;\n\tsize_t len1 = 0, len2 = 0;\n\tconst u8 **hash;\n\n\thash_index =\n\t\t((40543U * ((((src[0] << 4) ^ src[1]) << 4) ^ src[2])) >> 4) &\n\t\t(LZNT_CHUNK_SIZE - 1);\n\n\thash = &(ctx->hash[hash_index].p1);\n\n\tif (hash[0] >= ctx->unc && hash[0] < src && hash[0][0] == src[0] &&\n\t    hash[0][1] == src[1] && hash[0][2] == src[2]) {\n\t\tlen1 = 3;\n\t\tif (ctx->max_len > 3)\n\t\t\tlen1 += get_match_len(src + 3, ctx->unc_end,\n\t\t\t\t\t      hash[0] + 3, ctx->max_len - 3);\n\t}\n\n\tif (hash[1] >= ctx->unc && hash[1] < src && hash[1][0] == src[0] &&\n\t    hash[1][1] == src[1] && hash[1][2] == src[2]) {\n\t\tlen2 = 3;\n\t\tif (ctx->max_len > 3)\n\t\t\tlen2 += get_match_len(src + 3, ctx->unc_end,\n\t\t\t\t\t      hash[1] + 3, ctx->max_len - 3);\n\t}\n\n\t \n\tif (len1 < len2) {\n\t\tctx->best_match = hash[1];\n\t\tlen1 = len2;\n\t} else {\n\t\tctx->best_match = hash[0];\n\t}\n\n\thash[1] = hash[0];\n\thash[0] = src;\n\treturn len1;\n}\n\nstatic size_t longest_match_best(const u8 *src, struct lznt *ctx)\n{\n\tsize_t max_len;\n\tconst u8 *ptr;\n\n\tif (ctx->unc >= src || !ctx->max_len)\n\t\treturn 0;\n\n\tmax_len = 0;\n\tfor (ptr = ctx->unc; ptr < src; ++ptr) {\n\t\tsize_t len =\n\t\t\tget_match_len(src, ctx->unc_end, ptr, ctx->max_len);\n\t\tif (len >= max_len) {\n\t\t\tmax_len = len;\n\t\t\tctx->best_match = ptr;\n\t\t}\n\t}\n\n\treturn max_len >= 3 ? max_len : 0;\n}\n\nstatic const size_t s_max_len[] = {\n\t0x1002, 0x802, 0x402, 0x202, 0x102, 0x82, 0x42, 0x22, 0x12,\n};\n\nstatic const size_t s_max_off[] = {\n\t0x10, 0x20, 0x40, 0x80, 0x100, 0x200, 0x400, 0x800, 0x1000,\n};\n\nstatic inline u16 make_pair(size_t offset, size_t len, size_t index)\n{\n\treturn ((offset - 1) << (12 - index)) |\n\t       ((len - 3) & (((1 << (12 - index)) - 1)));\n}\n\nstatic inline size_t parse_pair(u16 pair, size_t *offset, size_t index)\n{\n\t*offset = 1 + (pair >> (12 - index));\n\treturn 3 + (pair & ((1 << (12 - index)) - 1));\n}\n\n \nstatic inline int compress_chunk(size_t (*match)(const u8 *, struct lznt *),\n\t\t\t\t const u8 *unc, const u8 *unc_end, u8 *cmpr,\n\t\t\t\t u8 *cmpr_end, size_t *cmpr_chunk_size,\n\t\t\t\t struct lznt *ctx)\n{\n\tsize_t cnt = 0;\n\tsize_t idx = 0;\n\tconst u8 *up = unc;\n\tu8 *cp = cmpr + 3;\n\tu8 *cp2 = cmpr + 2;\n\tu8 not_zero = 0;\n\t \n\tu8 ohdr = 0;\n\tu8 *last;\n\tu16 t16;\n\n\tif (unc + LZNT_CHUNK_SIZE < unc_end)\n\t\tunc_end = unc + LZNT_CHUNK_SIZE;\n\n\tlast = min(cmpr + LZNT_CHUNK_SIZE + sizeof(short), cmpr_end);\n\n\tctx->unc = unc;\n\tctx->unc_end = unc_end;\n\tctx->max_len = s_max_len[0];\n\n\twhile (up < unc_end) {\n\t\tsize_t max_len;\n\n\t\twhile (unc + s_max_off[idx] < up)\n\t\t\tctx->max_len = s_max_len[++idx];\n\n\t\t \n\t\tmax_len = up + 3 <= unc_end ? (*match)(up, ctx) : 0;\n\n\t\tif (!max_len) {\n\t\t\tif (cp >= last)\n\t\t\t\tgoto NotCompressed;\n\t\t\tnot_zero |= *cp++ = *up++;\n\t\t} else if (cp + 1 >= last) {\n\t\t\tgoto NotCompressed;\n\t\t} else {\n\t\t\tt16 = make_pair(up - ctx->best_match, max_len, idx);\n\t\t\t*cp++ = t16;\n\t\t\t*cp++ = t16 >> 8;\n\n\t\t\tohdr |= 1 << cnt;\n\t\t\tup += max_len;\n\t\t}\n\n\t\tcnt = (cnt + 1) & 7;\n\t\tif (!cnt) {\n\t\t\t*cp2 = ohdr;\n\t\t\tohdr = 0;\n\t\t\tcp2 = cp;\n\t\t\tcp += 1;\n\t\t}\n\t}\n\n\tif (cp2 < last)\n\t\t*cp2 = ohdr;\n\telse\n\t\tcp -= 1;\n\n\t*cmpr_chunk_size = cp - cmpr;\n\n\tt16 = (*cmpr_chunk_size - 3) | 0xB000;\n\tcmpr[0] = t16;\n\tcmpr[1] = t16 >> 8;\n\n\treturn not_zero ? 0 : LZNT_ERROR_ALL_ZEROS;\n\nNotCompressed:\n\n\tif ((cmpr + LZNT_CHUNK_SIZE + sizeof(short)) > last)\n\t\treturn -2;\n\n\t \n\tcmpr[0] = 0xff;\n\tcmpr[1] = 0x3f;\n\n\tmemcpy(cmpr + sizeof(short), unc, LZNT_CHUNK_SIZE);\n\t*cmpr_chunk_size = LZNT_CHUNK_SIZE + sizeof(short);\n\n\treturn 0;\n}\n\nstatic inline ssize_t decompress_chunk(u8 *unc, u8 *unc_end, const u8 *cmpr,\n\t\t\t\t       const u8 *cmpr_end)\n{\n\tu8 *up = unc;\n\tu8 ch = *cmpr++;\n\tsize_t bit = 0;\n\tsize_t index = 0;\n\tu16 pair;\n\tsize_t offset, length;\n\n\t \n\twhile (up < unc_end && cmpr < cmpr_end) {\n\t\t \n\t\twhile (unc + s_max_off[index] < up)\n\t\t\tindex += 1;\n\n\t\t \n\t\tif (!(ch & (1 << bit))) {\n\t\t\t \n\t\t\t*up++ = *cmpr++;\n\t\t\tgoto next;\n\t\t}\n\n\t\t \n\t\tif (cmpr + 1 >= cmpr_end)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tpair = cmpr[1];\n\t\tpair <<= 8;\n\t\tpair |= cmpr[0];\n\n\t\tcmpr += 2;\n\n\t\t \n\t\tlength = parse_pair(pair, &offset, index);\n\n\t\t \n\t\tif (unc + offset > up)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (up + length >= unc_end)\n\t\t\tlength = unc_end - up;\n\n\t\t \n\t\tfor (; length > 0; length--, up++)\n\t\t\t*up = *(up - offset);\n\nnext:\n\t\t \n\t\tbit = (bit + 1) & 7;\n\n\t\tif (!bit) {\n\t\t\tif (cmpr >= cmpr_end)\n\t\t\t\tbreak;\n\n\t\t\tch = *cmpr++;\n\t\t}\n\t}\n\n\t \n\treturn up - unc;\n}\n\n \nstruct lznt *get_lznt_ctx(int level)\n{\n\tstruct lznt *r = kzalloc(level ? offsetof(struct lznt, hash) :\n\t\t\t\t\t sizeof(struct lznt),\n\t\t\t\t GFP_NOFS);\n\n\tif (r)\n\t\tr->std = !level;\n\treturn r;\n}\n\n \nsize_t compress_lznt(const void *unc, size_t unc_size, void *cmpr,\n\t\t     size_t cmpr_size, struct lznt *ctx)\n{\n\tint err;\n\tsize_t (*match)(const u8 *src, struct lznt *ctx);\n\tu8 *p = cmpr;\n\tu8 *end = p + cmpr_size;\n\tconst u8 *unc_chunk = unc;\n\tconst u8 *unc_end = unc_chunk + unc_size;\n\tbool is_zero = true;\n\n\tif (ctx->std) {\n\t\tmatch = &longest_match_std;\n\t\tmemset(ctx->hash, 0, sizeof(ctx->hash));\n\t} else {\n\t\tmatch = &longest_match_best;\n\t}\n\n\t \n\tfor (; unc_chunk < unc_end; unc_chunk += LZNT_CHUNK_SIZE) {\n\t\tcmpr_size = 0;\n\t\terr = compress_chunk(match, unc_chunk, unc_end, p, end,\n\t\t\t\t     &cmpr_size, ctx);\n\t\tif (err < 0)\n\t\t\treturn unc_size;\n\n\t\tif (is_zero && err != LZNT_ERROR_ALL_ZEROS)\n\t\t\tis_zero = false;\n\n\t\tp += cmpr_size;\n\t}\n\n\tif (p <= end - 2)\n\t\tp[0] = p[1] = 0;\n\n\treturn is_zero ? 0 : PtrOffset(cmpr, p);\n}\n\n \nssize_t decompress_lznt(const void *cmpr, size_t cmpr_size, void *unc,\n\t\t\tsize_t unc_size)\n{\n\tconst u8 *cmpr_chunk = cmpr;\n\tconst u8 *cmpr_end = cmpr_chunk + cmpr_size;\n\tu8 *unc_chunk = unc;\n\tu8 *unc_end = unc_chunk + unc_size;\n\tu16 chunk_hdr;\n\n\tif (cmpr_size < sizeof(short))\n\t\treturn -EINVAL;\n\n\t \n\tchunk_hdr = cmpr_chunk[1];\n\tchunk_hdr <<= 8;\n\tchunk_hdr |= cmpr_chunk[0];\n\n\t \n\tfor (;;) {\n\t\tsize_t chunk_size_saved;\n\t\tsize_t unc_use;\n\t\tsize_t cmpr_use = 3 + (chunk_hdr & (LZNT_CHUNK_SIZE - 1));\n\n\t\t \n\t\tif (cmpr_chunk + cmpr_use > cmpr_end)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (chunk_hdr & 0x8000) {\n\t\t\t \n\t\t\tssize_t err =\n\t\t\t\tdecompress_chunk(unc_chunk, unc_end,\n\t\t\t\t\t\t cmpr_chunk + sizeof(chunk_hdr),\n\t\t\t\t\t\t cmpr_chunk + cmpr_use);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tunc_use = err;\n\t\t} else {\n\t\t\t \n\t\t\tunc_use = unc_chunk + LZNT_CHUNK_SIZE > unc_end ?\n\t\t\t\t\t  unc_end - unc_chunk :\n\t\t\t\t\t  LZNT_CHUNK_SIZE;\n\n\t\t\tif (cmpr_chunk + sizeof(chunk_hdr) + unc_use >\n\t\t\t    cmpr_end) {\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tmemcpy(unc_chunk, cmpr_chunk + sizeof(chunk_hdr),\n\t\t\t       unc_use);\n\t\t}\n\n\t\t \n\t\tcmpr_chunk += cmpr_use;\n\t\tunc_chunk += unc_use;\n\n\t\t \n\t\tif (unc_chunk >= unc_end)\n\t\t\tbreak;\n\n\t\t \n\t\tif (cmpr_chunk > cmpr_end - 2)\n\t\t\tbreak;\n\n\t\tchunk_size_saved = LZNT_CHUNK_SIZE;\n\n\t\t \n\t\tchunk_hdr = cmpr_chunk[1];\n\t\tchunk_hdr <<= 8;\n\t\tchunk_hdr |= cmpr_chunk[0];\n\n\t\tif (!chunk_hdr)\n\t\t\tbreak;\n\n\t\t \n\t\tif (unc_use < chunk_size_saved) {\n\t\t\tsize_t t1 = chunk_size_saved - unc_use;\n\t\t\tu8 *t2 = unc_chunk + t1;\n\n\t\t\t \n\t\t\tif (t2 >= unc_end)\n\t\t\t\tbreak;\n\n\t\t\tmemset(unc_chunk, 0, t1);\n\t\t\tunc_chunk = t2;\n\t\t}\n\t}\n\n\t \n\tif (cmpr_chunk > cmpr_end)\n\t\treturn -EINVAL;\n\n\t \n\treturn PtrOffset(unc, unc_chunk);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}