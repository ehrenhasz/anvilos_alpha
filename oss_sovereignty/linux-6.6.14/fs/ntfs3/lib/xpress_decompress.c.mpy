{
  "module_name": "xpress_decompress.c",
  "hash_id": "af59fa8a048246c49cbeb58f0fff84d197f6773370b04ce8b19e335c093824fd",
  "original_prompt": "Ingested from linux-6.6.14/fs/ntfs3/lib/xpress_decompress.c",
  "human_readable_source": "\n \n\n#include \"decompress_common.h\"\n#include \"lib.h\"\n\n#define XPRESS_NUM_SYMBOLS\t512\n#define XPRESS_MAX_CODEWORD_LEN\t15\n#define XPRESS_MIN_MATCH_LEN\t3\n\n \n#define XPRESS_TABLEBITS 12\n\n \nstruct xpress_decompressor {\n\n\t \n\tu16 decode_table[(1 << XPRESS_TABLEBITS) + 2 * XPRESS_NUM_SYMBOLS];\n\n\t \n\tu8 lens[XPRESS_NUM_SYMBOLS];\n\n\t \n\tu16 working_space[2 * (1 + XPRESS_MAX_CODEWORD_LEN) +\n\t\t\t  XPRESS_NUM_SYMBOLS];\n};\n\n \nstruct xpress_decompressor *xpress_allocate_decompressor(void)\n{\n\treturn kmalloc(sizeof(struct xpress_decompressor), GFP_NOFS);\n}\n\n \nint xpress_decompress(struct xpress_decompressor *decompressor,\n\t\t      const void *compressed_data, size_t compressed_size,\n\t\t      void *uncompressed_data, size_t uncompressed_size)\n{\n\tstruct xpress_decompressor *d = decompressor;\n\tconst u8 * const in_begin = compressed_data;\n\tu8 * const out_begin = uncompressed_data;\n\tu8 *out_next = out_begin;\n\tu8 * const out_end = out_begin + uncompressed_size;\n\tstruct input_bitstream is;\n\tu32 i;\n\n\t \n\tif (compressed_size < XPRESS_NUM_SYMBOLS / 2)\n\t\tgoto invalid;\n\tfor (i = 0; i < XPRESS_NUM_SYMBOLS / 2; i++) {\n\t\td->lens[i*2 + 0] = in_begin[i] & 0xF;\n\t\td->lens[i*2 + 1] = in_begin[i] >> 4;\n\t}\n\n\t \n\tif (make_huffman_decode_table(d->decode_table, XPRESS_NUM_SYMBOLS,\n\t\t\t\t      XPRESS_TABLEBITS, d->lens,\n\t\t\t\t      XPRESS_MAX_CODEWORD_LEN,\n\t\t\t\t      d->working_space))\n\t\tgoto invalid;\n\n\t \n\n\tinit_input_bitstream(&is, in_begin + XPRESS_NUM_SYMBOLS / 2,\n\t\t\t     compressed_size - XPRESS_NUM_SYMBOLS / 2);\n\n\twhile (out_next != out_end) {\n\t\tu32 sym;\n\t\tu32 log2_offset;\n\t\tu32 length;\n\t\tu32 offset;\n\n\t\tsym = read_huffsym(&is, d->decode_table,\n\t\t\t\t   XPRESS_TABLEBITS, XPRESS_MAX_CODEWORD_LEN);\n\t\tif (sym < 256) {\n\t\t\t \n\t\t\t*out_next++ = sym;\n\t\t} else {\n\t\t\t \n\t\t\tlength = sym & 0xf;\n\t\t\tlog2_offset = (sym >> 4) & 0xf;\n\n\t\t\tbitstream_ensure_bits(&is, 16);\n\n\t\t\toffset = ((u32)1 << log2_offset) |\n\t\t\t\t bitstream_pop_bits(&is, log2_offset);\n\n\t\t\tif (length == 0xf) {\n\t\t\t\tlength += bitstream_read_byte(&is);\n\t\t\t\tif (length == 0xf + 0xff)\n\t\t\t\t\tlength = bitstream_read_u16(&is);\n\t\t\t}\n\t\t\tlength += XPRESS_MIN_MATCH_LEN;\n\n\t\t\tif (offset > (size_t)(out_next - out_begin))\n\t\t\t\tgoto invalid;\n\n\t\t\tif (length > (size_t)(out_end - out_next))\n\t\t\t\tgoto invalid;\n\n\t\t\tout_next = lz_copy(out_next, length, offset, out_end,\n\t\t\t\t\t   XPRESS_MIN_MATCH_LEN);\n\t\t}\n\t}\n\treturn 0;\n\ninvalid:\n\treturn -1;\n}\n\n \nvoid xpress_free_decompressor(struct xpress_decompressor *decompressor)\n{\n\tkfree(decompressor);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}