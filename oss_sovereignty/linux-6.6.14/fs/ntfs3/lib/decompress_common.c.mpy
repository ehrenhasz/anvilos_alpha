{
  "module_name": "decompress_common.c",
  "hash_id": "1622882e31167bcc18a7231130774b6130a369cbee8e90ff4301d358a778d92f",
  "original_prompt": "Ingested from linux-6.6.14/fs/ntfs3/lib/decompress_common.c",
  "human_readable_source": "\n \n\n#include \"decompress_common.h\"\n\n \nint make_huffman_decode_table(u16 decode_table[], const u32 num_syms,\n\t\t\t      const u32 table_bits, const u8 lens[],\n\t\t\t      const u32 max_codeword_len,\n\t\t\t      u16 working_space[])\n{\n\tconst u32 table_num_entries = 1 << table_bits;\n\tu16 * const len_counts = &working_space[0];\n\tu16 * const offsets = &working_space[1 * (max_codeword_len + 1)];\n\tu16 * const sorted_syms = &working_space[2 * (max_codeword_len + 1)];\n\tint left;\n\tvoid *decode_table_ptr;\n\tu32 sym_idx;\n\tu32 codeword_len;\n\tu32 stores_per_loop;\n\tu32 decode_table_pos;\n\tu32 len;\n\tu32 sym;\n\n\t \n\tfor (len = 0; len <= max_codeword_len; len++)\n\t\tlen_counts[len] = 0;\n\tfor (sym = 0; sym < num_syms; sym++)\n\t\tlen_counts[lens[sym]]++;\n\n\t \n\tleft = 1;\n\tfor (len = 1; len <= max_codeword_len; len++) {\n\t\tleft <<= 1;\n\t\tleft -= len_counts[len];\n\t\tif (left < 0) {\n\t\t\t \n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (left) {\n\t\t \n\t\tif (left == (1 << max_codeword_len)) {\n\t\t\t \n\t\t\tmemset(decode_table, 0,\n\t\t\t       table_num_entries * sizeof(decode_table[0]));\n\t\t\treturn 0;\n\t\t}\n\t\treturn -1;\n\t}\n\n\t \n\n\t \n\toffsets[1] = 0;\n\tfor (len = 1; len < max_codeword_len; len++)\n\t\toffsets[len + 1] = offsets[len] + len_counts[len];\n\n\t \n\tfor (sym = 0; sym < num_syms; sym++)\n\t\tif (lens[sym])\n\t\t\tsorted_syms[offsets[lens[sym]]++] = sym;\n\n\t \n\tdecode_table_ptr = decode_table;\n\tsym_idx = 0;\n\tcodeword_len = 1;\n\tstores_per_loop = (1 << (table_bits - codeword_len));\n\tfor (; stores_per_loop != 0; codeword_len++, stores_per_loop >>= 1) {\n\t\tu32 end_sym_idx = sym_idx + len_counts[codeword_len];\n\n\t\tfor (; sym_idx < end_sym_idx; sym_idx++) {\n\t\t\tu16 entry;\n\t\t\tu16 *p;\n\t\t\tu32 n;\n\n\t\t\tentry = ((u32)codeword_len << 11) | sorted_syms[sym_idx];\n\t\t\tp = (u16 *)decode_table_ptr;\n\t\t\tn = stores_per_loop;\n\n\t\t\tdo {\n\t\t\t\t*p++ = entry;\n\t\t\t} while (--n);\n\n\t\t\tdecode_table_ptr = p;\n\t\t}\n\t}\n\n\t \n\tdecode_table_pos = (u16 *)decode_table_ptr - decode_table;\n\tif (decode_table_pos != table_num_entries) {\n\t\tu32 j;\n\t\tu32 next_free_tree_slot;\n\t\tu32 cur_codeword;\n\n\t\t \n\t\tj = decode_table_pos;\n\t\tdo {\n\t\t\tdecode_table[j] = 0;\n\t\t} while (++j != table_num_entries);\n\n\t\t \n\t\tnext_free_tree_slot = table_num_entries;\n\n\t\t \n\t\tfor (cur_codeword = decode_table_pos << 1;\n\t\t     codeword_len <= max_codeword_len;\n\t\t     codeword_len++, cur_codeword <<= 1) {\n\t\t\tu32 end_sym_idx = sym_idx + len_counts[codeword_len];\n\n\t\t\tfor (; sym_idx < end_sym_idx; sym_idx++, cur_codeword++) {\n\t\t\t\t \n\t\t\t\tu32 sorted_sym = sorted_syms[sym_idx];\n\t\t\t\tu32 extra_bits = codeword_len - table_bits;\n\t\t\t\tu32 node_idx = cur_codeword >> extra_bits;\n\n\t\t\t\t \n\t\t\t\tdo {\n\t\t\t\t\t \n\t\t\t\t\tif (decode_table[node_idx] == 0) {\n\t\t\t\t\t\tdecode_table[node_idx] =\n\t\t\t\t\t\t\tnext_free_tree_slot | 0xC000;\n\t\t\t\t\t\tdecode_table[next_free_tree_slot++] = 0;\n\t\t\t\t\t\tdecode_table[next_free_tree_slot++] = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\t \n\t\t\t\t\tnode_idx = decode_table[node_idx] & 0x3FFF;\n\t\t\t\t\t--extra_bits;\n\t\t\t\t\tnode_idx += (cur_codeword >> extra_bits) & 1;\n\t\t\t\t} while (extra_bits != 0);\n\n\t\t\t\t \n\t\t\t\tdecode_table[node_idx] = sorted_sym;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}