{
  "module_name": "decompress_common.h",
  "hash_id": "70c9f3ae38b3f732df55c11de88375629e4cd2f2edf28a887ecac939e0c8f9b8",
  "original_prompt": "Ingested from linux-6.6.14/fs/ntfs3/lib/decompress_common.h",
  "human_readable_source": " \n \n\n#ifndef _LINUX_NTFS3_LIB_DECOMPRESS_COMMON_H\n#define _LINUX_NTFS3_LIB_DECOMPRESS_COMMON_H\n\n#include <linux/string.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <asm/unaligned.h>\n\n\n \n#define forceinline __always_inline\n\n \n#if defined(__i386__) || defined(__x86_64__) || defined(__ARM_FEATURE_UNALIGNED)\n#  define FAST_UNALIGNED_ACCESS\n#endif\n\n \n#define WORDBYTES (sizeof(size_t))\n\nstatic forceinline void\ncopy_unaligned_word(const void *src, void *dst)\n{\n\tput_unaligned(get_unaligned((const size_t *)src), (size_t *)dst);\n}\n\n\n \nstatic forceinline size_t repeat_byte(u8 b)\n{\n\tsize_t v;\n\n\tv = b;\n\tv |= v << 8;\n\tv |= v << 16;\n\tv |= v << ((WORDBYTES == 8) ? 32 : 0);\n\treturn v;\n}\n\n \nstruct input_bitstream {\n\n\t \n\tu32 bitbuf;\n\n\t \n\tu32 bitsleft;\n\n\t \n\tconst u8 *next;\n\n\t \n\tconst u8 *end;\n};\n\n \nstatic forceinline void init_input_bitstream(struct input_bitstream *is,\n\t\t\t\t\t     const void *buffer, u32 size)\n{\n\tis->bitbuf = 0;\n\tis->bitsleft = 0;\n\tis->next = buffer;\n\tis->end = is->next + size;\n}\n\n \nstatic forceinline void bitstream_ensure_bits(struct input_bitstream *is,\n\t\t\t\t\t      u32 num_bits)\n{\n\tif (is->bitsleft < num_bits) {\n\t\tif (is->end - is->next >= 2) {\n\t\t\tis->bitbuf |= (u32)get_unaligned_le16(is->next)\n\t\t\t\t\t<< (16 - is->bitsleft);\n\t\t\tis->next += 2;\n\t\t}\n\t\tis->bitsleft += 16;\n\t}\n}\n\n \nstatic forceinline u32\nbitstream_peek_bits(const struct input_bitstream *is, const u32 num_bits)\n{\n\treturn (is->bitbuf >> 1) >> (sizeof(is->bitbuf) * 8 - num_bits - 1);\n}\n\n \nstatic forceinline void\nbitstream_remove_bits(struct input_bitstream *is, u32 num_bits)\n{\n\tis->bitbuf <<= num_bits;\n\tis->bitsleft -= num_bits;\n}\n\n \nstatic forceinline u32\nbitstream_pop_bits(struct input_bitstream *is, u32 num_bits)\n{\n\tu32 bits = bitstream_peek_bits(is, num_bits);\n\n\tbitstream_remove_bits(is, num_bits);\n\treturn bits;\n}\n\n \nstatic forceinline u32\nbitstream_read_bits(struct input_bitstream *is, u32 num_bits)\n{\n\tbitstream_ensure_bits(is, num_bits);\n\treturn bitstream_pop_bits(is, num_bits);\n}\n\n \nstatic forceinline u8\nbitstream_read_byte(struct input_bitstream *is)\n{\n\tif (unlikely(is->end == is->next))\n\t\treturn 0;\n\treturn *is->next++;\n}\n\n \nstatic forceinline u16\nbitstream_read_u16(struct input_bitstream *is)\n{\n\tu16 v;\n\n\tif (unlikely(is->end - is->next < 2))\n\t\treturn 0;\n\tv = get_unaligned_le16(is->next);\n\tis->next += 2;\n\treturn v;\n}\n\n \nstatic forceinline u32\nbitstream_read_u32(struct input_bitstream *is)\n{\n\tu32 v;\n\n\tif (unlikely(is->end - is->next < 4))\n\t\treturn 0;\n\tv = get_unaligned_le32(is->next);\n\tis->next += 4;\n\treturn v;\n}\n\n \nstatic forceinline void *bitstream_read_bytes(struct input_bitstream *is,\n\t\t\t\t\t      void *dst_buffer, size_t count)\n{\n\tif ((size_t)(is->end - is->next) < count)\n\t\treturn NULL;\n\tmemcpy(dst_buffer, is->next, count);\n\tis->next += count;\n\treturn (u8 *)dst_buffer + count;\n}\n\n \nstatic forceinline void bitstream_align(struct input_bitstream *is)\n{\n\tis->bitsleft = 0;\n\tis->bitbuf = 0;\n}\n\nextern int make_huffman_decode_table(u16 decode_table[], const u32 num_syms,\n\t\t\t\t     const u32 num_bits, const u8 lens[],\n\t\t\t\t     const u32 max_codeword_len,\n\t\t\t\t     u16 working_space[]);\n\n\n \nstatic forceinline u32 read_huffsym(struct input_bitstream *istream,\n\t\t\t\t\t const u16 decode_table[],\n\t\t\t\t\t u32 table_bits,\n\t\t\t\t\t u32 max_codeword_len)\n{\n\tu32 entry;\n\tu32 key_bits;\n\n\tbitstream_ensure_bits(istream, max_codeword_len);\n\n\t \n\tkey_bits = bitstream_peek_bits(istream, table_bits);\n\tentry = decode_table[key_bits];\n\tif (entry < 0xC000) {\n\t\t \n\t\tbitstream_remove_bits(istream, entry >> 11);\n\t\treturn entry & 0x7FF;\n\t}\n\t \n\tbitstream_remove_bits(istream, table_bits);\n\tdo {\n\t\tkey_bits = (entry & 0x3FFF) + bitstream_pop_bits(istream, 1);\n\t} while ((entry = decode_table[key_bits]) >= 0xC000);\n\treturn entry;\n}\n\n \nstatic forceinline u8 *lz_copy(u8 *dst, u32 length, u32 offset, const u8 *bufend,\n\t\t\t       u32 min_length)\n{\n\tconst u8 *src = dst - offset;\n\n\t \n#ifdef FAST_UNALIGNED_ACCESS\n\tu8 * const end = dst + length;\n\n\tif (bufend - end >= (ptrdiff_t)(WORDBYTES - 1)) {\n\n\t\tif (offset >= WORDBYTES) {\n\t\t\t \n\n\t\t\t \n\n\t\t\tcopy_unaligned_word(src, dst);\n\t\t\tsrc += WORDBYTES;\n\t\t\tdst += WORDBYTES;\n\n\t\t\tif (dst < end) {\n\t\t\t\tdo {\n\t\t\t\t\tcopy_unaligned_word(src, dst);\n\t\t\t\t\tsrc += WORDBYTES;\n\t\t\t\t\tdst += WORDBYTES;\n\t\t\t\t} while (dst < end);\n\t\t\t}\n\t\t\treturn end;\n\t\t} else if (offset == 1) {\n\n\t\t\t \n\t\t\tsize_t v = repeat_byte(*(dst - 1));\n\n\t\t\tdo {\n\t\t\t\tput_unaligned(v, (size_t *)dst);\n\t\t\t\tsrc += WORDBYTES;\n\t\t\t\tdst += WORDBYTES;\n\t\t\t} while (dst < end);\n\t\t\treturn end;\n\t\t}\n\t\t \n\t}\n#endif  \n\n\t \n\n\tif (min_length >= 2) {\n\t\t*dst++ = *src++;\n\t\tlength--;\n\t}\n\tif (min_length >= 3) {\n\t\t*dst++ = *src++;\n\t\tlength--;\n\t}\n\tdo {\n\t\t*dst++ = *src++;\n\t} while (--length);\n\n\treturn dst;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}