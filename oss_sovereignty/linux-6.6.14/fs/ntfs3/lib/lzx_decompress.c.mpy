{
  "module_name": "lzx_decompress.c",
  "hash_id": "34da830a7920f619141455571c7a70ef0561e5b2174e6ecdca6e45cde2af9b8e",
  "original_prompt": "Ingested from linux-6.6.14/fs/ntfs3/lib/lzx_decompress.c",
  "human_readable_source": "\n \n\n#include \"decompress_common.h\"\n#include \"lib.h\"\n\n \n#define LZX_NUM_CHARS\t\t\t256\n\n \n#define LZX_MIN_MATCH_LEN\t\t2\n#define LZX_MAX_MATCH_LEN\t\t257\n\n \n#define LZX_NUM_LENS\t\t\t(LZX_MAX_MATCH_LEN - LZX_MIN_MATCH_LEN + 1)\n\n \n#define LZX_NUM_PRIMARY_LENS\t\t7\n#define LZX_NUM_LEN_HEADERS\t\t(LZX_NUM_PRIMARY_LENS + 1)\n\n \n#define LZX_BLOCKTYPE_VERBATIM\t\t1\n#define LZX_BLOCKTYPE_ALIGNED\t\t2\n#define LZX_BLOCKTYPE_UNCOMPRESSED\t3\n\n \n#define LZX_NUM_OFFSET_SLOTS\t\t30\n\n \n#define LZX_MAINCODE_NUM_SYMBOLS\t\\\n\t(LZX_NUM_CHARS + (LZX_NUM_OFFSET_SLOTS * LZX_NUM_LEN_HEADERS))\n\n \n#define LZX_LENCODE_NUM_SYMBOLS\t\t(LZX_NUM_LENS - LZX_NUM_PRIMARY_LENS)\n\n \n#define LZX_PRECODE_NUM_SYMBOLS\t\t20\n\n \n#define LZX_PRECODE_ELEMENT_SIZE\t4\n\n \n#define LZX_NUM_ALIGNED_OFFSET_BITS\t3\n\n \n#define LZX_ALIGNEDCODE_NUM_SYMBOLS\t(1 << LZX_NUM_ALIGNED_OFFSET_BITS)\n\n \n#define LZX_ALIGNED_OFFSET_BITMASK\t((1 << LZX_NUM_ALIGNED_OFFSET_BITS) - 1)\n\n \n#define LZX_ALIGNEDCODE_ELEMENT_SIZE\t3\n\n \n#define LZX_MAX_MAIN_CODEWORD_LEN\t16\n#define LZX_MAX_LEN_CODEWORD_LEN\t16\n#define LZX_MAX_PRE_CODEWORD_LEN\t((1 << LZX_PRECODE_ELEMENT_SIZE) - 1)\n#define LZX_MAX_ALIGNED_CODEWORD_LEN\t((1 << LZX_ALIGNEDCODE_ELEMENT_SIZE) - 1)\n\n \n#define LZX_DEFAULT_FILESIZE\t\t12000000\n\n \n#define LZX_DEFAULT_BLOCK_SIZE\t\t32768\n\n \n#define LZX_NUM_RECENT_OFFSETS\t\t3\n\n \n#define LZX_MAINCODE_TABLEBITS\t\t11\n#define LZX_LENCODE_TABLEBITS\t\t10\n#define LZX_PRECODE_TABLEBITS\t\t6\n#define LZX_ALIGNEDCODE_TABLEBITS\t7\n\n#define LZX_READ_LENS_MAX_OVERRUN\t50\n\n \nstatic const u32 lzx_offset_slot_base[LZX_NUM_OFFSET_SLOTS + 1] = {\n\t0,\t1,\t2,\t3,\t4,\t \n\t6,\t8,\t12,\t16,\t24,\t \n\t32,\t48,\t64,\t96,\t128,\t \n\t192,\t256,\t384,\t512,\t768,\t \n\t1024,\t1536,\t2048,\t3072,\t4096,    \n\t6144,\t8192,\t12288,\t16384,\t24576,\t \n\t32768,\t\t\t\t\t \n};\n\n \nstatic const u8 lzx_extra_offset_bits[LZX_NUM_OFFSET_SLOTS] = {\n\t0,\t0,\t0,\t0,\t1,\n\t1,\t2,\t2,\t3,\t3,\n\t4,\t4,\t5,\t5,\t6,\n\t6,\t7,\t7,\t8,\t8,\n\t9,\t9,\t10,\t10,\t11,\n\t11,\t12,\t12,\t13,\t13,\n};\n\n \nstruct lzx_decompressor {\n\n\t \n\n\tu16 maincode_decode_table[(1 << LZX_MAINCODE_TABLEBITS) +\n\t\t\t\t\t(LZX_MAINCODE_NUM_SYMBOLS * 2)];\n\tu8 maincode_lens[LZX_MAINCODE_NUM_SYMBOLS + LZX_READ_LENS_MAX_OVERRUN];\n\n\n\tu16 lencode_decode_table[(1 << LZX_LENCODE_TABLEBITS) +\n\t\t\t\t\t(LZX_LENCODE_NUM_SYMBOLS * 2)];\n\tu8 lencode_lens[LZX_LENCODE_NUM_SYMBOLS + LZX_READ_LENS_MAX_OVERRUN];\n\n\n\tu16 alignedcode_decode_table[(1 << LZX_ALIGNEDCODE_TABLEBITS) +\n\t\t\t\t\t(LZX_ALIGNEDCODE_NUM_SYMBOLS * 2)];\n\tu8 alignedcode_lens[LZX_ALIGNEDCODE_NUM_SYMBOLS];\n\n\tu16 precode_decode_table[(1 << LZX_PRECODE_TABLEBITS) +\n\t\t\t\t (LZX_PRECODE_NUM_SYMBOLS * 2)];\n\tu8 precode_lens[LZX_PRECODE_NUM_SYMBOLS];\n\n\t \n\tu16 working_space[2 * (1 + LZX_MAX_MAIN_CODEWORD_LEN) +\n\t\t\t  LZX_MAINCODE_NUM_SYMBOLS];\n};\n\nstatic void undo_e8_translation(void *target, s32 input_pos)\n{\n\ts32 abs_offset, rel_offset;\n\n\tabs_offset = get_unaligned_le32(target);\n\tif (abs_offset >= 0) {\n\t\tif (abs_offset < LZX_DEFAULT_FILESIZE) {\n\t\t\t \n\t\t\trel_offset = abs_offset - input_pos;\n\t\t\tput_unaligned_le32(rel_offset, target);\n\t\t}\n\t} else {\n\t\tif (abs_offset >= -input_pos) {\n\t\t\t \n\t\t\trel_offset = abs_offset + LZX_DEFAULT_FILESIZE;\n\t\t\tput_unaligned_le32(rel_offset, target);\n\t\t}\n\t}\n}\n\n \nstatic void lzx_postprocess(u8 *data, u32 size)\n{\n\t \n\tu8 *tail;\n\tu8 saved_bytes[6];\n\tu8 *p;\n\n\tif (size <= 10)\n\t\treturn;\n\n\ttail = &data[size - 6];\n\tmemcpy(saved_bytes, tail, 6);\n\tmemset(tail, 0xE8, 6);\n\tp = data;\n\tfor (;;) {\n\t\twhile (*p != 0xE8)\n\t\t\tp++;\n\t\tif (p >= tail)\n\t\t\tbreak;\n\t\tundo_e8_translation(p + 1, p - data);\n\t\tp += 5;\n\t}\n\tmemcpy(tail, saved_bytes, 6);\n}\n\n \nstatic forceinline u32 read_presym(const struct lzx_decompressor *d,\n\t\t\t\t\tstruct input_bitstream *is)\n{\n\treturn read_huffsym(is, d->precode_decode_table,\n\t\t\t    LZX_PRECODE_TABLEBITS, LZX_MAX_PRE_CODEWORD_LEN);\n}\n\n \nstatic forceinline u32 read_mainsym(const struct lzx_decompressor *d,\n\t\t\t\t\t struct input_bitstream *is)\n{\n\treturn read_huffsym(is, d->maincode_decode_table,\n\t\t\t    LZX_MAINCODE_TABLEBITS, LZX_MAX_MAIN_CODEWORD_LEN);\n}\n\n \nstatic forceinline u32 read_lensym(const struct lzx_decompressor *d,\n\t\t\t\t\tstruct input_bitstream *is)\n{\n\treturn read_huffsym(is, d->lencode_decode_table,\n\t\t\t    LZX_LENCODE_TABLEBITS, LZX_MAX_LEN_CODEWORD_LEN);\n}\n\n \nstatic forceinline u32 read_alignedsym(const struct lzx_decompressor *d,\n\t\t\t\t\t    struct input_bitstream *is)\n{\n\treturn read_huffsym(is, d->alignedcode_decode_table,\n\t\t\t    LZX_ALIGNEDCODE_TABLEBITS,\n\t\t\t    LZX_MAX_ALIGNED_CODEWORD_LEN);\n}\n\n \nstatic int lzx_read_codeword_lens(struct lzx_decompressor *d,\n\t\t\t\t  struct input_bitstream *is,\n\t\t\t\t  u8 *lens, u32 num_lens)\n{\n\tu8 *len_ptr = lens;\n\tu8 *lens_end = lens + num_lens;\n\tint i;\n\n\t \n\tfor (i = 0; i < LZX_PRECODE_NUM_SYMBOLS; i++) {\n\t\td->precode_lens[i] =\n\t\t\tbitstream_read_bits(is, LZX_PRECODE_ELEMENT_SIZE);\n\t}\n\n\t \n\tif (make_huffman_decode_table(d->precode_decode_table,\n\t\t\t\t      LZX_PRECODE_NUM_SYMBOLS,\n\t\t\t\t      LZX_PRECODE_TABLEBITS,\n\t\t\t\t      d->precode_lens,\n\t\t\t\t      LZX_MAX_PRE_CODEWORD_LEN,\n\t\t\t\t      d->working_space))\n\t\treturn -1;\n\n\t \n\tdo {\n\t\tu32 presym;\n\t\tu8 len;\n\n\t\t \n\t\tpresym = read_presym(d, is);\n\t\tif (presym < 17) {\n\t\t\t \n\t\t\tlen = *len_ptr - presym;\n\t\t\tif ((s8)len < 0)\n\t\t\t\tlen += 17;\n\t\t\t*len_ptr++ = len;\n\t\t} else {\n\t\t\t \n\n\t\t\tu32 run_len;\n\n\t\t\tif (presym == 17) {\n\t\t\t\t \n\t\t\t\trun_len = 4 + bitstream_read_bits(is, 4);\n\t\t\t\tlen = 0;\n\t\t\t} else if (presym == 18) {\n\t\t\t\t \n\t\t\t\trun_len = 20 + bitstream_read_bits(is, 5);\n\t\t\t\tlen = 0;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\trun_len = 4 + bitstream_read_bits(is, 1);\n\t\t\t\tpresym = read_presym(d, is);\n\t\t\t\tif (presym > 17)\n\t\t\t\t\treturn -1;\n\t\t\t\tlen = *len_ptr - presym;\n\t\t\t\tif ((s8)len < 0)\n\t\t\t\t\tlen += 17;\n\t\t\t}\n\n\t\t\tdo {\n\t\t\t\t*len_ptr++ = len;\n\t\t\t} while (--run_len);\n\t\t\t \n\t\t}\n\t} while (len_ptr < lens_end);\n\n\treturn 0;\n}\n\n \nstatic int lzx_read_block_header(struct lzx_decompressor *d,\n\t\t\t\t struct input_bitstream *is,\n\t\t\t\t int *block_type_ret,\n\t\t\t\t u32 *block_size_ret,\n\t\t\t\t u32 recent_offsets[])\n{\n\tint block_type;\n\tu32 block_size;\n\tint i;\n\n\tbitstream_ensure_bits(is, 4);\n\n\t \n\tblock_type = bitstream_pop_bits(is, 3);\n\n\t \n\tif (bitstream_pop_bits(is, 1)) {\n\t\tblock_size = LZX_DEFAULT_BLOCK_SIZE;\n\t} else {\n\t\tblock_size = 0;\n\t\tblock_size |= bitstream_read_bits(is, 8);\n\t\tblock_size <<= 8;\n\t\tblock_size |= bitstream_read_bits(is, 8);\n\t}\n\n\tswitch (block_type) {\n\n\tcase LZX_BLOCKTYPE_ALIGNED:\n\n\t\t \n\n\t\tfor (i = 0; i < LZX_ALIGNEDCODE_NUM_SYMBOLS; i++) {\n\t\t\td->alignedcode_lens[i] =\n\t\t\t\tbitstream_read_bits(is,\n\t\t\t\t\t\t    LZX_ALIGNEDCODE_ELEMENT_SIZE);\n\t\t}\n\n\t\tif (make_huffman_decode_table(d->alignedcode_decode_table,\n\t\t\t\t\t      LZX_ALIGNEDCODE_NUM_SYMBOLS,\n\t\t\t\t\t      LZX_ALIGNEDCODE_TABLEBITS,\n\t\t\t\t\t      d->alignedcode_lens,\n\t\t\t\t\t      LZX_MAX_ALIGNED_CODEWORD_LEN,\n\t\t\t\t\t      d->working_space))\n\t\t\treturn -1;\n\n\t\t \n\t\tfallthrough;\n\n\tcase LZX_BLOCKTYPE_VERBATIM:\n\n\t\t \n\n\t\tif (lzx_read_codeword_lens(d, is, d->maincode_lens,\n\t\t\t\t\t   LZX_NUM_CHARS))\n\t\t\treturn -1;\n\n\t\tif (lzx_read_codeword_lens(d, is,\n\t\t\t\t\t   d->maincode_lens + LZX_NUM_CHARS,\n\t\t\t\t\t   LZX_MAINCODE_NUM_SYMBOLS - LZX_NUM_CHARS))\n\t\t\treturn -1;\n\n\t\tif (make_huffman_decode_table(d->maincode_decode_table,\n\t\t\t\t\t      LZX_MAINCODE_NUM_SYMBOLS,\n\t\t\t\t\t      LZX_MAINCODE_TABLEBITS,\n\t\t\t\t\t      d->maincode_lens,\n\t\t\t\t\t      LZX_MAX_MAIN_CODEWORD_LEN,\n\t\t\t\t\t      d->working_space))\n\t\t\treturn -1;\n\n\t\t \n\n\t\tif (lzx_read_codeword_lens(d, is, d->lencode_lens,\n\t\t\t\t\t   LZX_LENCODE_NUM_SYMBOLS))\n\t\t\treturn -1;\n\n\t\tif (make_huffman_decode_table(d->lencode_decode_table,\n\t\t\t\t\t      LZX_LENCODE_NUM_SYMBOLS,\n\t\t\t\t\t      LZX_LENCODE_TABLEBITS,\n\t\t\t\t\t      d->lencode_lens,\n\t\t\t\t\t      LZX_MAX_LEN_CODEWORD_LEN,\n\t\t\t\t\t      d->working_space))\n\t\t\treturn -1;\n\n\t\tbreak;\n\n\tcase LZX_BLOCKTYPE_UNCOMPRESSED:\n\n\t\t \n\t\tbitstream_ensure_bits(is, 1);\n\t\tbitstream_align(is);\n\n\t\trecent_offsets[0] = bitstream_read_u32(is);\n\t\trecent_offsets[1] = bitstream_read_u32(is);\n\t\trecent_offsets[2] = bitstream_read_u32(is);\n\n\t\t \n\t\tif (recent_offsets[0] == 0 || recent_offsets[1] == 0 ||\n\t\t    recent_offsets[2] == 0)\n\t\t\treturn -1;\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\treturn -1;\n\t}\n\n\t*block_type_ret = block_type;\n\t*block_size_ret = block_size;\n\treturn 0;\n}\n\n \nstatic int lzx_decompress_block(const struct lzx_decompressor *d,\n\t\t\t\tstruct input_bitstream *is,\n\t\t\t\tint block_type, u32 block_size,\n\t\t\t\tu8 * const out_begin, u8 *out_next,\n\t\t\t\tu32 recent_offsets[])\n{\n\tu8 * const block_end = out_next + block_size;\n\tu32 ones_if_aligned = 0U - (block_type == LZX_BLOCKTYPE_ALIGNED);\n\n\tdo {\n\t\tu32 mainsym;\n\t\tu32 match_len;\n\t\tu32 match_offset;\n\t\tu32 offset_slot;\n\t\tu32 num_extra_bits;\n\n\t\tmainsym = read_mainsym(d, is);\n\t\tif (mainsym < LZX_NUM_CHARS) {\n\t\t\t \n\t\t\t*out_next++ = mainsym;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\n\t\t \n\t\tmainsym -= LZX_NUM_CHARS;\n\t\tmatch_len = mainsym % LZX_NUM_LEN_HEADERS;\n\t\toffset_slot = mainsym / LZX_NUM_LEN_HEADERS;\n\n\t\t \n\t\tif (match_len == LZX_NUM_PRIMARY_LENS)\n\t\t\tmatch_len += read_lensym(d, is);\n\t\tmatch_len += LZX_MIN_MATCH_LEN;\n\n\t\tif (offset_slot < LZX_NUM_RECENT_OFFSETS) {\n\t\t\t \n\n\t\t\t \n\t\t\tmatch_offset = recent_offsets[offset_slot];\n\t\t\trecent_offsets[offset_slot] = recent_offsets[0];\n\t\t\trecent_offsets[0] = match_offset;\n\t\t} else {\n\t\t\t \n\n\t\t\t \n\t\t\tnum_extra_bits = lzx_extra_offset_bits[offset_slot];\n\n\t\t\t \n\t\t\tmatch_offset = lzx_offset_slot_base[offset_slot];\n\n\t\t\t \n\n\t\t\tif ((num_extra_bits & ones_if_aligned) >= LZX_NUM_ALIGNED_OFFSET_BITS) {\n\t\t\t\tmatch_offset +=\n\t\t\t\t\tbitstream_read_bits(is, num_extra_bits -\n\t\t\t\t\t\t\t\tLZX_NUM_ALIGNED_OFFSET_BITS)\n\t\t\t\t\t\t\t<< LZX_NUM_ALIGNED_OFFSET_BITS;\n\t\t\t\tmatch_offset += read_alignedsym(d, is);\n\t\t\t} else {\n\t\t\t\tmatch_offset += bitstream_read_bits(is, num_extra_bits);\n\t\t\t}\n\n\t\t\t \n\t\t\tmatch_offset -= (LZX_NUM_RECENT_OFFSETS - 1);\n\n\t\t\t \n\t\t\trecent_offsets[2] = recent_offsets[1];\n\t\t\trecent_offsets[1] = recent_offsets[0];\n\t\t\trecent_offsets[0] = match_offset;\n\t\t}\n\n\t\t \n\n\t\tif (match_len > (size_t)(block_end - out_next))\n\t\t\treturn -1;\n\n\t\tif (match_offset > (size_t)(out_next - out_begin))\n\t\t\treturn -1;\n\n\t\tout_next = lz_copy(out_next, match_len, match_offset,\n\t\t\t\t   block_end, LZX_MIN_MATCH_LEN);\n\n\t} while (out_next != block_end);\n\n\treturn 0;\n}\n\n \nstruct lzx_decompressor *lzx_allocate_decompressor(void)\n{\n\treturn kmalloc(sizeof(struct lzx_decompressor), GFP_NOFS);\n}\n\n \nint lzx_decompress(struct lzx_decompressor *decompressor,\n\t\t   const void *compressed_data, size_t compressed_size,\n\t\t   void *uncompressed_data, size_t uncompressed_size)\n{\n\tstruct lzx_decompressor *d = decompressor;\n\tu8 * const out_begin = uncompressed_data;\n\tu8 *out_next = out_begin;\n\tu8 * const out_end = out_begin + uncompressed_size;\n\tstruct input_bitstream is;\n\tu32 recent_offsets[LZX_NUM_RECENT_OFFSETS] = {1, 1, 1};\n\tint e8_status = 0;\n\n\tinit_input_bitstream(&is, compressed_data, compressed_size);\n\n\t \n\tmemset(d->maincode_lens, 0, LZX_MAINCODE_NUM_SYMBOLS);\n\tmemset(d->lencode_lens, 0, LZX_LENCODE_NUM_SYMBOLS);\n\n\t \n\n\twhile (out_next != out_end) {\n\t\tint block_type;\n\t\tu32 block_size;\n\n\t\tif (lzx_read_block_header(d, &is, &block_type, &block_size,\n\t\t\t\t\t  recent_offsets))\n\t\t\tgoto invalid;\n\n\t\tif (block_size < 1 || block_size > (size_t)(out_end - out_next))\n\t\t\tgoto invalid;\n\n\t\tif (block_type != LZX_BLOCKTYPE_UNCOMPRESSED) {\n\n\t\t\t \n\n\t\t\tif (lzx_decompress_block(d,\n\t\t\t\t\t\t &is,\n\t\t\t\t\t\t block_type,\n\t\t\t\t\t\t block_size,\n\t\t\t\t\t\t out_begin,\n\t\t\t\t\t\t out_next,\n\t\t\t\t\t\t recent_offsets))\n\t\t\t\tgoto invalid;\n\n\t\t\te8_status |= d->maincode_lens[0xe8];\n\t\t\tout_next += block_size;\n\t\t} else {\n\t\t\t \n\n\t\t\tout_next = bitstream_read_bytes(&is, out_next,\n\t\t\t\t\t\t\tblock_size);\n\t\t\tif (!out_next)\n\t\t\t\tgoto invalid;\n\n\t\t\tif (block_size & 1)\n\t\t\t\tbitstream_read_byte(&is);\n\n\t\t\te8_status = 1;\n\t\t}\n\t}\n\n\t \n\tif (e8_status)\n\t\tlzx_postprocess(uncompressed_data, uncompressed_size);\n\n\treturn 0;\n\ninvalid:\n\treturn -1;\n}\n\n \nvoid lzx_free_decompressor(struct lzx_decompressor *decompressor)\n{\n\tkfree(decompressor);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}