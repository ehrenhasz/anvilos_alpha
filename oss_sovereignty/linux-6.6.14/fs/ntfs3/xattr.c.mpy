{
  "module_name": "xattr.c",
  "hash_id": "32ef504b31cda9f318a913204fdd34cd8c3cf5f7fb96ea8590fc7b779c27964c",
  "original_prompt": "Ingested from linux-6.6.14/fs/ntfs3/xattr.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/posix_acl.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n\n#include \"debug.h\"\n#include \"ntfs.h\"\n#include \"ntfs_fs.h\"\n\n\n#define SYSTEM_DOS_ATTRIB     \"system.dos_attrib\"\n#define SYSTEM_NTFS_ATTRIB    \"system.ntfs_attrib\"\n#define SYSTEM_NTFS_ATTRIB_BE \"system.ntfs_attrib_be\"\n#define SYSTEM_NTFS_SECURITY  \"system.ntfs_security\"\n\n\nstatic inline size_t unpacked_ea_size(const struct EA_FULL *ea)\n{\n\treturn ea->size ? le32_to_cpu(ea->size) :\n\t\t\t  ALIGN(struct_size(ea, name,\n\t\t\t\t\t    1 + ea->name_len +\n\t\t\t\t\t\t    le16_to_cpu(ea->elength)),\n\t\t\t\t4);\n}\n\nstatic inline size_t packed_ea_size(const struct EA_FULL *ea)\n{\n\treturn struct_size(ea, name,\n\t\t\t   1 + ea->name_len + le16_to_cpu(ea->elength)) -\n\t       offsetof(struct EA_FULL, flags);\n}\n\n \nstatic inline bool find_ea(const struct EA_FULL *ea_all, u32 bytes,\n\t\t\t   const char *name, u8 name_len, u32 *off, u32 *ea_sz)\n{\n\tu32 ea_size;\n\n\t*off = 0;\n\tif (!ea_all)\n\t\treturn false;\n\n\tfor (; *off < bytes; *off += ea_size) {\n\t\tconst struct EA_FULL *ea = Add2Ptr(ea_all, *off);\n\t\tea_size = unpacked_ea_size(ea);\n\t\tif (ea->name_len == name_len &&\n\t\t    !memcmp(ea->name, name, name_len)) {\n\t\t\tif (ea_sz)\n\t\t\t\t*ea_sz = ea_size;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\n \nstatic int ntfs_read_ea(struct ntfs_inode *ni, struct EA_FULL **ea,\n\t\t\tsize_t add_bytes, const struct EA_INFO **info)\n{\n\tint err = -EINVAL;\n\tstruct ntfs_sb_info *sbi = ni->mi.sbi;\n\tstruct ATTR_LIST_ENTRY *le = NULL;\n\tstruct ATTRIB *attr_info, *attr_ea;\n\tvoid *ea_p;\n\tu32 size, off, ea_size;\n\n\tstatic_assert(le32_to_cpu(ATTR_EA_INFO) < le32_to_cpu(ATTR_EA));\n\n\t*ea = NULL;\n\t*info = NULL;\n\n\tattr_info =\n\t\tni_find_attr(ni, NULL, &le, ATTR_EA_INFO, NULL, 0, NULL, NULL);\n\tattr_ea =\n\t\tni_find_attr(ni, attr_info, &le, ATTR_EA, NULL, 0, NULL, NULL);\n\n\tif (!attr_ea || !attr_info)\n\t\treturn 0;\n\n\t*info = resident_data_ex(attr_info, sizeof(struct EA_INFO));\n\tif (!*info)\n\t\tgoto out;\n\n\t \n\tsize = le32_to_cpu((*info)->size);\n\tif (size > sbi->ea_max_size) {\n\t\terr = -EFBIG;\n\t\tgoto out;\n\t}\n\n\tif (attr_size(attr_ea) > sbi->ea_max_size) {\n\t\terr = -EFBIG;\n\t\tgoto out;\n\t}\n\n\tif (!size) {\n\t\t \n\t\tgoto out;\n\t}\n\n\t \n\tea_p = kmalloc(size_add(size, add_bytes), GFP_NOFS);\n\tif (!ea_p)\n\t\treturn -ENOMEM;\n\n\tif (attr_ea->non_res) {\n\t\tstruct runs_tree run;\n\n\t\trun_init(&run);\n\n\t\terr = attr_load_runs_range(ni, ATTR_EA, NULL, 0, &run, 0, size);\n\t\tif (!err)\n\t\t\terr = ntfs_read_run_nb(sbi, &run, 0, ea_p, size, NULL);\n\t\trun_close(&run);\n\n\t\tif (err)\n\t\t\tgoto out1;\n\t} else {\n\t\tvoid *p = resident_data_ex(attr_ea, size);\n\n\t\tif (!p)\n\t\t\tgoto out1;\n\t\tmemcpy(ea_p, p, size);\n\t}\n\n\tmemset(Add2Ptr(ea_p, size), 0, add_bytes);\n\n\terr = -EINVAL;\n\t \n\tfor (off = 0; off < size; off += ea_size) {\n\t\tconst struct EA_FULL *ef = Add2Ptr(ea_p, off);\n\t\tu32 bytes = size - off;\n\n\t\t \n\t\tif (bytes < sizeof(ef->size))\n\t\t\tgoto out1;\n\n\t\tif (ef->size) {\n\t\t\tea_size = le32_to_cpu(ef->size);\n\t\t\tif (ea_size > bytes)\n\t\t\t\tgoto out1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (bytes < offsetof(struct EA_FULL, name))\n\t\t\tgoto out1;\n\n\t\tea_size = ALIGN(struct_size(ef, name,\n\t\t\t\t\t    1 + ef->name_len +\n\t\t\t\t\t\t    le16_to_cpu(ef->elength)),\n\t\t\t\t4);\n\t\tif (ea_size > bytes)\n\t\t\tgoto out1;\n\t}\n\n\t*ea = ea_p;\n\treturn 0;\n\nout1:\n\tkfree(ea_p);\nout:\n\tntfs_set_state(sbi, NTFS_DIRTY_DIRTY);\n\treturn err;\n}\n\n \nstatic ssize_t ntfs_list_ea(struct ntfs_inode *ni, char *buffer,\n\t\t\t    size_t bytes_per_buffer)\n{\n\tconst struct EA_INFO *info;\n\tstruct EA_FULL *ea_all = NULL;\n\tconst struct EA_FULL *ea;\n\tu32 off, size;\n\tint err;\n\tint ea_size;\n\tsize_t ret;\n\n\terr = ntfs_read_ea(ni, &ea_all, 0, &info);\n\tif (err)\n\t\treturn err;\n\n\tif (!info || !ea_all)\n\t\treturn 0;\n\n\tsize = le32_to_cpu(info->size);\n\n\t \n\tret = 0;\n\tfor (off = 0; off + sizeof(struct EA_FULL) < size; off += ea_size) {\n\t\tea = Add2Ptr(ea_all, off);\n\t\tea_size = unpacked_ea_size(ea);\n\n\t\tif (!ea->name_len)\n\t\t\tbreak;\n\n\t\tif (buffer) {\n\t\t\t \n\t\t\tif (off + ea_size > size)\n\t\t\t\tbreak;\n\n\t\t\tif (ret + ea->name_len + 1 > bytes_per_buffer) {\n\t\t\t\terr = -ERANGE;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tmemcpy(buffer + ret, ea->name, ea->name_len);\n\t\t\tbuffer[ret + ea->name_len] = 0;\n\t\t}\n\n\t\tret += ea->name_len + 1;\n\t}\n\nout:\n\tkfree(ea_all);\n\treturn err ? err : ret;\n}\n\nstatic int ntfs_get_ea(struct inode *inode, const char *name, size_t name_len,\n\t\t       void *buffer, size_t size, size_t *required)\n{\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tconst struct EA_INFO *info;\n\tstruct EA_FULL *ea_all = NULL;\n\tconst struct EA_FULL *ea;\n\tu32 off, len;\n\tint err;\n\n\tif (!(ni->ni_flags & NI_FLAG_EA))\n\t\treturn -ENODATA;\n\n\tif (!required)\n\t\tni_lock(ni);\n\n\tlen = 0;\n\n\tif (name_len > 255) {\n\t\terr = -ENAMETOOLONG;\n\t\tgoto out;\n\t}\n\n\terr = ntfs_read_ea(ni, &ea_all, 0, &info);\n\tif (err)\n\t\tgoto out;\n\n\tif (!info)\n\t\tgoto out;\n\n\t \n\tif (!find_ea(ea_all, le32_to_cpu(info->size), name, name_len, &off,\n\t\t     NULL)) {\n\t\terr = -ENODATA;\n\t\tgoto out;\n\t}\n\tea = Add2Ptr(ea_all, off);\n\n\tlen = le16_to_cpu(ea->elength);\n\tif (!buffer) {\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\tif (len > size) {\n\t\terr = -ERANGE;\n\t\tif (required)\n\t\t\t*required = len;\n\t\tgoto out;\n\t}\n\n\tmemcpy(buffer, ea->name + ea->name_len + 1, len);\n\terr = 0;\n\nout:\n\tkfree(ea_all);\n\tif (!required)\n\t\tni_unlock(ni);\n\n\treturn err ? err : len;\n}\n\nstatic noinline int ntfs_set_ea(struct inode *inode, const char *name,\n\t\t\t\tsize_t name_len, const void *value,\n\t\t\t\tsize_t val_size, int flags, bool locked,\n\t\t\t\t__le16 *ea_size)\n{\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tstruct ntfs_sb_info *sbi = ni->mi.sbi;\n\tint err;\n\tstruct EA_INFO ea_info;\n\tconst struct EA_INFO *info;\n\tstruct EA_FULL *new_ea;\n\tstruct EA_FULL *ea_all = NULL;\n\tsize_t add, new_pack;\n\tu32 off, size, ea_sz;\n\t__le16 size_pack;\n\tstruct ATTRIB *attr;\n\tstruct ATTR_LIST_ENTRY *le;\n\tstruct mft_inode *mi;\n\tstruct runs_tree ea_run;\n\tu64 new_sz;\n\tvoid *p;\n\n\tif (!locked)\n\t\tni_lock(ni);\n\n\trun_init(&ea_run);\n\n\tif (name_len > 255) {\n\t\terr = -ENAMETOOLONG;\n\t\tgoto out;\n\t}\n\n\tadd = ALIGN(struct_size(ea_all, name, 1 + name_len + val_size), 4);\n\n\terr = ntfs_read_ea(ni, &ea_all, add, &info);\n\tif (err)\n\t\tgoto out;\n\n\tif (!info) {\n\t\tmemset(&ea_info, 0, sizeof(ea_info));\n\t\tsize = 0;\n\t\tsize_pack = 0;\n\t} else {\n\t\tmemcpy(&ea_info, info, sizeof(ea_info));\n\t\tsize = le32_to_cpu(ea_info.size);\n\t\tsize_pack = ea_info.size_pack;\n\t}\n\n\tif (info && find_ea(ea_all, size, name, name_len, &off, &ea_sz)) {\n\t\tstruct EA_FULL *ea;\n\n\t\tif (flags & XATTR_CREATE) {\n\t\t\terr = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\n\t\tea = Add2Ptr(ea_all, off);\n\n\t\t \n\t\tif (val_size && le16_to_cpu(ea->elength) == val_size &&\n\t\t    !memcmp(ea->name + ea->name_len + 1, value, val_size)) {\n\t\t\t \n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif (ea->flags & FILE_NEED_EA)\n\t\t\tle16_add_cpu(&ea_info.count, -1);\n\n\t\tle16_add_cpu(&ea_info.size_pack, 0 - packed_ea_size(ea));\n\n\t\tmemmove(ea, Add2Ptr(ea, ea_sz), size - off - ea_sz);\n\n\t\tsize -= ea_sz;\n\t\tmemset(Add2Ptr(ea_all, size), 0, ea_sz);\n\n\t\tea_info.size = cpu_to_le32(size);\n\n\t\tif ((flags & XATTR_REPLACE) && !val_size) {\n\t\t\t \n\t\t\tgoto update_ea;\n\t\t}\n\t} else {\n\t\tif (flags & XATTR_REPLACE) {\n\t\t\terr = -ENODATA;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!ea_all) {\n\t\t\tea_all = kzalloc(add, GFP_NOFS);\n\t\t\tif (!ea_all) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tnew_ea = Add2Ptr(ea_all, size);\n\tnew_ea->size = cpu_to_le32(add);\n\tnew_ea->flags = 0;\n\tnew_ea->name_len = name_len;\n\tnew_ea->elength = cpu_to_le16(val_size);\n\tmemcpy(new_ea->name, name, name_len);\n\tnew_ea->name[name_len] = 0;\n\tmemcpy(new_ea->name + name_len + 1, value, val_size);\n\tnew_pack = le16_to_cpu(ea_info.size_pack) + packed_ea_size(new_ea);\n\tea_info.size_pack = cpu_to_le16(new_pack);\n\t \n\tsize += add;\n\tea_info.size = cpu_to_le32(size);\n\n\t \n\tif (new_pack > 0xffff || size > sbi->ea_max_size) {\n\t\tntfs_inode_warn(\n\t\t\tinode,\n\t\t\t\"The size of extended attributes must not exceed 64KiB\");\n\t\terr = -EFBIG; \n\t\tgoto out;\n\t}\n\nupdate_ea:\n\n\tif (!info) {\n\t\t \n\t\tif (!size) {\n\t\t\terr = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = ni_insert_resident(ni, sizeof(struct EA_INFO),\n\t\t\t\t\t ATTR_EA_INFO, NULL, 0, NULL, NULL,\n\t\t\t\t\t NULL);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = ni_insert_resident(ni, 0, ATTR_EA, NULL, 0, NULL, NULL,\n\t\t\t\t\t NULL);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tnew_sz = size;\n\terr = attr_set_size(ni, ATTR_EA, NULL, 0, &ea_run, new_sz, &new_sz,\n\t\t\t    false, NULL);\n\tif (err)\n\t\tgoto out;\n\n\tle = NULL;\n\tattr = ni_find_attr(ni, NULL, &le, ATTR_EA_INFO, NULL, 0, NULL, &mi);\n\tif (!attr) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!size) {\n\t\t \n\t\tni_remove_attr_le(ni, attr, mi, le);\n\t} else {\n\t\tp = resident_data_ex(attr, sizeof(struct EA_INFO));\n\t\tif (!p) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(p, &ea_info, sizeof(struct EA_INFO));\n\t\tmi->dirty = true;\n\t}\n\n\tle = NULL;\n\tattr = ni_find_attr(ni, NULL, &le, ATTR_EA, NULL, 0, NULL, &mi);\n\tif (!attr) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!size) {\n\t\t \n\t\tni_remove_attr_le(ni, attr, mi, le);\n\t} else if (attr->non_res) {\n\t\terr = attr_load_runs_range(ni, ATTR_EA, NULL, 0, &ea_run, 0,\n\t\t\t\t\t   size);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = ntfs_sb_write_run(sbi, &ea_run, 0, ea_all, size, 0);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\tp = resident_data_ex(attr, size);\n\t\tif (!p) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(p, ea_all, size);\n\t\tmi->dirty = true;\n\t}\n\n\t \n\tif (size)\n\t\tni->ni_flags |= NI_FLAG_EA;\n\telse\n\t\tni->ni_flags &= ~NI_FLAG_EA;\n\n\tif (ea_info.size_pack != size_pack)\n\t\tni->ni_flags |= NI_FLAG_UPDATE_PARENT;\n\tif (ea_size)\n\t\t*ea_size = ea_info.size_pack;\n\tmark_inode_dirty(&ni->vfs_inode);\n\nout:\n\tif (!locked)\n\t\tni_unlock(ni);\n\n\trun_close(&ea_run);\n\tkfree(ea_all);\n\n\treturn err;\n}\n\n#ifdef CONFIG_NTFS3_FS_POSIX_ACL\n\n \nstruct posix_acl *ntfs_get_acl(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\t\t       int type)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tconst char *name;\n\tsize_t name_len;\n\tstruct posix_acl *acl;\n\tsize_t req;\n\tint err;\n\tvoid *buf;\n\n\t \n\tbuf = __getname();\n\tif (!buf)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tif (type == ACL_TYPE_ACCESS) {\n\t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tname_len = sizeof(XATTR_NAME_POSIX_ACL_ACCESS) - 1;\n\t} else {\n\t\tname = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tname_len = sizeof(XATTR_NAME_POSIX_ACL_DEFAULT) - 1;\n\t}\n\n\tni_lock(ni);\n\n\terr = ntfs_get_ea(inode, name, name_len, buf, PATH_MAX, &req);\n\n\tni_unlock(ni);\n\n\t \n\tif (err >= 0) {\n\t\tacl = posix_acl_from_xattr(&init_user_ns, buf, err);\n\t} else if (err == -ENODATA) {\n\t\tacl = NULL;\n\t} else {\n\t\tacl = ERR_PTR(err);\n\t}\n\n\tif (!IS_ERR(acl))\n\t\tset_cached_acl(inode, type, acl);\n\n\t__putname(buf);\n\n\treturn acl;\n}\n\nstatic noinline int ntfs_set_acl_ex(struct mnt_idmap *idmap,\n\t\t\t\t    struct inode *inode, struct posix_acl *acl,\n\t\t\t\t    int type, bool init_acl)\n{\n\tconst char *name;\n\tsize_t size, name_len;\n\tvoid *value;\n\tint err;\n\tint flags;\n\tumode_t mode;\n\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\n\tmode = inode->i_mode;\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\t \n\t\tif (acl && !init_acl) {\n\t\t\terr = posix_acl_update_mode(idmap, inode, &mode, &acl);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tname_len = sizeof(XATTR_NAME_POSIX_ACL_ACCESS) - 1;\n\t\tbreak;\n\n\tcase ACL_TYPE_DEFAULT:\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tname = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tname_len = sizeof(XATTR_NAME_POSIX_ACL_DEFAULT) - 1;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (!acl) {\n\t\t \n\t\tsize = 0;\n\t\tvalue = NULL;\n\t\tflags = XATTR_REPLACE;\n\t} else {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tvalue = kmalloc(size, GFP_NOFS);\n\t\tif (!value)\n\t\t\treturn -ENOMEM;\n\t\terr = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\tflags = 0;\n\t}\n\n\terr = ntfs_set_ea(inode, name, name_len, value, size, flags, 0, NULL);\n\tif (err == -ENODATA && !size)\n\t\terr = 0;  \n\tif (!err) {\n\t\tset_cached_acl(inode, type, acl);\n\t\tinode->i_mode = mode;\n\t\tinode_set_ctime_current(inode);\n\t\tmark_inode_dirty(inode);\n\t}\n\nout:\n\tkfree(value);\n\n\treturn err;\n}\n\n \nint ntfs_set_acl(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\t struct posix_acl *acl, int type)\n{\n\treturn ntfs_set_acl_ex(idmap, d_inode(dentry), acl, type, false);\n}\n\n \nint ntfs_init_acl(struct mnt_idmap *idmap, struct inode *inode,\n\t\t  struct inode *dir)\n{\n\tstruct posix_acl *default_acl, *acl;\n\tint err;\n\n\terr = posix_acl_create(dir, &inode->i_mode, &default_acl, &acl);\n\tif (err)\n\t\treturn err;\n\n\tif (default_acl) {\n\t\terr = ntfs_set_acl_ex(idmap, inode, default_acl,\n\t\t\t\t      ACL_TYPE_DEFAULT, true);\n\t\tposix_acl_release(default_acl);\n\t} else {\n\t\tinode->i_default_acl = NULL;\n\t}\n\n\tif (acl) {\n\t\tif (!err)\n\t\t\terr = ntfs_set_acl_ex(idmap, inode, acl,\n\t\t\t\t\t      ACL_TYPE_ACCESS, true);\n\t\tposix_acl_release(acl);\n\t} else {\n\t\tinode->i_acl = NULL;\n\t}\n\n\treturn err;\n}\n#endif\n\n \nint ntfs_acl_chmod(struct mnt_idmap *idmap, struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (!(sb->s_flags & SB_POSIXACL))\n\t\treturn 0;\n\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\n\treturn posix_acl_chmod(idmap, dentry, inode->i_mode);\n}\n\n \nssize_t ntfs_listxattr(struct dentry *dentry, char *buffer, size_t size)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tssize_t ret;\n\n\tif (!(ni->ni_flags & NI_FLAG_EA)) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tni_lock(ni);\n\n\tret = ntfs_list_ea(ni, buffer, size);\n\n\tni_unlock(ni);\n\n\treturn ret;\n}\n\nstatic int ntfs_getxattr(const struct xattr_handler *handler, struct dentry *de,\n\t\t\t struct inode *inode, const char *name, void *buffer,\n\t\t\t size_t size)\n{\n\tint err;\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\n\t \n\tif (!strcmp(name, SYSTEM_DOS_ATTRIB)) {\n\t\t \n\t\tif (!buffer) {\n\t\t\terr = sizeof(u8);\n\t\t} else if (size < sizeof(u8)) {\n\t\t\terr = -ENODATA;\n\t\t} else {\n\t\t\terr = sizeof(u8);\n\t\t\t*(u8 *)buffer = le32_to_cpu(ni->std_fa);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tif (!strcmp(name, SYSTEM_NTFS_ATTRIB) ||\n\t    !strcmp(name, SYSTEM_NTFS_ATTRIB_BE)) {\n\t\t \n\t\tif (!buffer) {\n\t\t\terr = sizeof(u32);\n\t\t} else if (size < sizeof(u32)) {\n\t\t\terr = -ENODATA;\n\t\t} else {\n\t\t\terr = sizeof(u32);\n\t\t\t*(u32 *)buffer = le32_to_cpu(ni->std_fa);\n\t\t\tif (!strcmp(name, SYSTEM_NTFS_ATTRIB_BE))\n\t\t\t\t*(__be32 *)buffer = cpu_to_be32(*(u32 *)buffer);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tif (!strcmp(name, SYSTEM_NTFS_SECURITY)) {\n\t\t \n\t\tstruct SECURITY_DESCRIPTOR_RELATIVE *sd = NULL;\n\t\tsize_t sd_size = 0;\n\n\t\tif (!is_ntfs3(ni->mi.sbi)) {\n\t\t\t \n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t} else if (le32_to_cpu(ni->std_security_id) <\n\t\t\t   SECURITY_ID_FIRST) {\n\t\t\terr = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = ntfs_get_security_by_id(ni->mi.sbi, ni->std_security_id,\n\t\t\t\t\t      &sd, &sd_size);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tif (!is_sd_valid(sd, sd_size)) {\n\t\t\tntfs_inode_warn(\n\t\t\t\tinode,\n\t\t\t\t\"looks like you get incorrect security descriptor id=%u\",\n\t\t\t\tni->std_security_id);\n\t\t}\n\n\t\tif (!buffer) {\n\t\t\terr = sd_size;\n\t\t} else if (size < sd_size) {\n\t\t\terr = -ENODATA;\n\t\t} else {\n\t\t\terr = sd_size;\n\t\t\tmemcpy(buffer, sd, sd_size);\n\t\t}\n\t\tkfree(sd);\n\t\tgoto out;\n\t}\n\n\t \n\terr = ntfs_get_ea(inode, name, strlen(name), buffer, size, NULL);\n\nout:\n\treturn err;\n}\n\n \nstatic noinline int ntfs_setxattr(const struct xattr_handler *handler,\n\t\t\t\t  struct mnt_idmap *idmap, struct dentry *de,\n\t\t\t\t  struct inode *inode, const char *name,\n\t\t\t\t  const void *value, size_t size, int flags)\n{\n\tint err = -EINVAL;\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tenum FILE_ATTRIBUTE new_fa;\n\n\t \n\tif (!strcmp(name, SYSTEM_DOS_ATTRIB)) {\n\t\tif (sizeof(u8) != size)\n\t\t\tgoto out;\n\t\tnew_fa = cpu_to_le32(*(u8 *)value);\n\t\tgoto set_new_fa;\n\t}\n\n\tif (!strcmp(name, SYSTEM_NTFS_ATTRIB) ||\n\t    !strcmp(name, SYSTEM_NTFS_ATTRIB_BE)) {\n\t\tif (size != sizeof(u32))\n\t\t\tgoto out;\n\t\tif (!strcmp(name, SYSTEM_NTFS_ATTRIB_BE))\n\t\t\tnew_fa = cpu_to_le32(be32_to_cpu(*(__be32 *)value));\n\t\telse\n\t\t\tnew_fa = cpu_to_le32(*(u32 *)value);\n\n\t\tif (S_ISREG(inode->i_mode)) {\n\t\t\t \n\t\t\tni_lock(ni);\n\t\t\terr = ni_new_attr_flags(ni, new_fa);\n\t\t\tni_unlock(ni);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\nset_new_fa:\n\t\t \n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\tnew_fa |= FILE_ATTRIBUTE_DIRECTORY;\n\t\telse\n\t\t\tnew_fa &= ~FILE_ATTRIBUTE_DIRECTORY;\n\n\t\tif (ni->std_fa != new_fa) {\n\t\t\tni->std_fa = new_fa;\n\t\t\tif (new_fa & FILE_ATTRIBUTE_READONLY)\n\t\t\t\tinode->i_mode &= ~0222;\n\t\t\telse\n\t\t\t\tinode->i_mode |= 0222;\n\t\t\t \n\t\t\tni->mi.dirty = true;\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t\terr = 0;\n\n\t\tgoto out;\n\t}\n\n\tif (!strcmp(name, SYSTEM_NTFS_SECURITY)) {\n\t\t \n\t\t__le32 security_id;\n\t\tbool inserted;\n\t\tstruct ATTR_STD_INFO5 *std;\n\n\t\tif (!is_ntfs3(ni->mi.sbi)) {\n\t\t\t \n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!is_sd_valid(value, size)) {\n\t\t\terr = -EINVAL;\n\t\t\tntfs_inode_warn(\n\t\t\t\tinode,\n\t\t\t\t\"you try to set invalid security descriptor\");\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = ntfs_insert_security(ni->mi.sbi, value, size,\n\t\t\t\t\t   &security_id, &inserted);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tni_lock(ni);\n\t\tstd = ni_std5(ni);\n\t\tif (!std) {\n\t\t\terr = -EINVAL;\n\t\t} else if (std->security_id != security_id) {\n\t\t\tstd->security_id = ni->std_security_id = security_id;\n\t\t\t \n\t\t\tni->mi.dirty = true;\n\t\t\tmark_inode_dirty(&ni->vfs_inode);\n\t\t}\n\t\tni_unlock(ni);\n\t\tgoto out;\n\t}\n\n\t \n\terr = ntfs_set_ea(inode, name, strlen(name), value, size, flags, 0,\n\t\t\t  NULL);\n\nout:\n\tinode_set_ctime_current(inode);\n\tmark_inode_dirty(inode);\n\n\treturn err;\n}\n\n \nint ntfs_save_wsl_perm(struct inode *inode, __le16 *ea_size)\n{\n\tint err;\n\t__le32 value;\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\n\tni_lock(ni);\n\tvalue = cpu_to_le32(i_uid_read(inode));\n\terr = ntfs_set_ea(inode, \"$LXUID\", sizeof(\"$LXUID\") - 1, &value,\n\t\t\t  sizeof(value), 0, true, ea_size);\n\tif (err)\n\t\tgoto out;\n\n\tvalue = cpu_to_le32(i_gid_read(inode));\n\terr = ntfs_set_ea(inode, \"$LXGID\", sizeof(\"$LXGID\") - 1, &value,\n\t\t\t  sizeof(value), 0, true, ea_size);\n\tif (err)\n\t\tgoto out;\n\n\tvalue = cpu_to_le32(inode->i_mode);\n\terr = ntfs_set_ea(inode, \"$LXMOD\", sizeof(\"$LXMOD\") - 1, &value,\n\t\t\t  sizeof(value), 0, true, ea_size);\n\tif (err)\n\t\tgoto out;\n\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\tvalue = cpu_to_le32(inode->i_rdev);\n\t\terr = ntfs_set_ea(inode, \"$LXDEV\", sizeof(\"$LXDEV\") - 1, &value,\n\t\t\t\t  sizeof(value), 0, true, ea_size);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\nout:\n\tni_unlock(ni);\n\t \n\treturn err;\n}\n\n \nvoid ntfs_get_wsl_perm(struct inode *inode)\n{\n\tsize_t sz;\n\t__le32 value[3];\n\n\tif (ntfs_get_ea(inode, \"$LXUID\", sizeof(\"$LXUID\") - 1, &value[0],\n\t\t\tsizeof(value[0]), &sz) == sizeof(value[0]) &&\n\t    ntfs_get_ea(inode, \"$LXGID\", sizeof(\"$LXGID\") - 1, &value[1],\n\t\t\tsizeof(value[1]), &sz) == sizeof(value[1]) &&\n\t    ntfs_get_ea(inode, \"$LXMOD\", sizeof(\"$LXMOD\") - 1, &value[2],\n\t\t\tsizeof(value[2]), &sz) == sizeof(value[2])) {\n\t\ti_uid_write(inode, (uid_t)le32_to_cpu(value[0]));\n\t\ti_gid_write(inode, (gid_t)le32_to_cpu(value[1]));\n\t\tinode->i_mode = le32_to_cpu(value[2]);\n\n\t\tif (ntfs_get_ea(inode, \"$LXDEV\", sizeof(\"$$LXDEV\") - 1,\n\t\t\t\t&value[0], sizeof(value),\n\t\t\t\t&sz) == sizeof(value[0])) {\n\t\t\tinode->i_rdev = le32_to_cpu(value[0]);\n\t\t}\n\t}\n}\n\nstatic bool ntfs_xattr_user_list(struct dentry *dentry)\n{\n\treturn true;\n}\n\n\nstatic const struct xattr_handler ntfs_other_xattr_handler = {\n\t.prefix\t= \"\",\n\t.get\t= ntfs_getxattr,\n\t.set\t= ntfs_setxattr,\n\t.list\t= ntfs_xattr_user_list,\n};\n\nconst struct xattr_handler *ntfs_xattr_handlers[] = {\n\t&ntfs_other_xattr_handler,\n\tNULL,\n};\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}