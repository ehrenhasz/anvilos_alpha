{
  "module_name": "attrlist.c",
  "hash_id": "c5f9079020ed712790663ac0fd99c57aa9195155e2e9477c1d9c527a7413e7d1",
  "original_prompt": "Ingested from linux-6.6.14/fs/ntfs3/attrlist.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n\n#include \"debug.h\"\n#include \"ntfs.h\"\n#include \"ntfs_fs.h\"\n\n \nstatic inline bool al_is_valid_le(const struct ntfs_inode *ni,\n\t\t\t\t  struct ATTR_LIST_ENTRY *le)\n{\n\tif (!le || !ni->attr_list.le || !ni->attr_list.size)\n\t\treturn false;\n\n\treturn PtrOffset(ni->attr_list.le, le) + le16_to_cpu(le->size) <=\n\t       ni->attr_list.size;\n}\n\nvoid al_destroy(struct ntfs_inode *ni)\n{\n\trun_close(&ni->attr_list.run);\n\tkfree(ni->attr_list.le);\n\tni->attr_list.le = NULL;\n\tni->attr_list.size = 0;\n\tni->attr_list.dirty = false;\n}\n\n \nint ntfs_load_attr_list(struct ntfs_inode *ni, struct ATTRIB *attr)\n{\n\tint err;\n\tsize_t lsize;\n\tvoid *le = NULL;\n\n\tif (ni->attr_list.size)\n\t\treturn 0;\n\n\tif (!attr->non_res) {\n\t\tlsize = le32_to_cpu(attr->res.data_size);\n\t\t \n\t\tle = kvmalloc(al_aligned(lsize), GFP_KERNEL);\n\t\tif (!le) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(le, resident_data(attr), lsize);\n\t} else if (attr->nres.svcn) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t} else {\n\t\tu16 run_off = le16_to_cpu(attr->nres.run_off);\n\n\t\tlsize = le64_to_cpu(attr->nres.data_size);\n\n\t\trun_init(&ni->attr_list.run);\n\n\t\tif (run_off > le32_to_cpu(attr->size)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = run_unpack_ex(&ni->attr_list.run, ni->mi.sbi, ni->mi.rno,\n\t\t\t\t    0, le64_to_cpu(attr->nres.evcn), 0,\n\t\t\t\t    Add2Ptr(attr, run_off),\n\t\t\t\t    le32_to_cpu(attr->size) - run_off);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\n\t\t \n\t\tle = kvmalloc(al_aligned(lsize), GFP_KERNEL);\n\t\tif (!le) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = ntfs_read_run_nb(ni->mi.sbi, &ni->attr_list.run, 0, le,\n\t\t\t\t       lsize, NULL);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tni->attr_list.size = lsize;\n\tni->attr_list.le = le;\n\n\treturn 0;\n\nout:\n\tni->attr_list.le = le;\n\tal_destroy(ni);\n\n\treturn err;\n}\n\n \nstruct ATTR_LIST_ENTRY *al_enumerate(struct ntfs_inode *ni,\n\t\t\t\t     struct ATTR_LIST_ENTRY *le)\n{\n\tsize_t off;\n\tu16 sz;\n\n\tif (!le) {\n\t\tle = ni->attr_list.le;\n\t} else {\n\t\tsz = le16_to_cpu(le->size);\n\t\tif (sz < sizeof(struct ATTR_LIST_ENTRY)) {\n\t\t\t \n\t\t\treturn NULL;\n\t\t}\n\t\tle = Add2Ptr(le, sz);\n\t}\n\n\t \n\toff = PtrOffset(ni->attr_list.le, le);\n\tif (off + sizeof(struct ATTR_LIST_ENTRY) > ni->attr_list.size) {\n\t\t \n\t\treturn NULL;\n\t}\n\n\tsz = le16_to_cpu(le->size);\n\n\t \n\tif (sz < sizeof(struct ATTR_LIST_ENTRY) ||\n\t    off + sz > ni->attr_list.size ||\n\t    sz < le->name_off + le->name_len * sizeof(short)) {\n\t\treturn NULL;\n\t}\n\n\treturn le;\n}\n\n \nstruct ATTR_LIST_ENTRY *al_find_le(struct ntfs_inode *ni,\n\t\t\t\t   struct ATTR_LIST_ENTRY *le,\n\t\t\t\t   const struct ATTRIB *attr)\n{\n\tCLST svcn = attr_svcn(attr);\n\n\treturn al_find_ex(ni, le, attr->type, attr_name(attr), attr->name_len,\n\t\t\t  &svcn);\n}\n\n \nstruct ATTR_LIST_ENTRY *al_find_ex(struct ntfs_inode *ni,\n\t\t\t\t   struct ATTR_LIST_ENTRY *le,\n\t\t\t\t   enum ATTR_TYPE type, const __le16 *name,\n\t\t\t\t   u8 name_len, const CLST *vcn)\n{\n\tstruct ATTR_LIST_ENTRY *ret = NULL;\n\tu32 type_in = le32_to_cpu(type);\n\n\twhile ((le = al_enumerate(ni, le))) {\n\t\tu64 le_vcn;\n\t\tint diff = le32_to_cpu(le->type) - type_in;\n\n\t\t \n\t\tif (diff < 0)\n\t\t\tcontinue;\n\n\t\tif (diff > 0)\n\t\t\treturn ret;\n\n\t\tif (le->name_len != name_len)\n\t\t\tcontinue;\n\n\t\tle_vcn = le64_to_cpu(le->vcn);\n\t\tif (!le_vcn) {\n\t\t\t \n\t\t\tdiff = ntfs_cmp_names(le_name(le), name_len, name,\n\t\t\t\t\t      name_len, ni->mi.sbi->upcase,\n\t\t\t\t\t      true);\n\t\t\tif (diff < 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (diff > 0)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tif (!vcn)\n\t\t\treturn le;\n\n\t\tif (*vcn == le_vcn)\n\t\t\treturn le;\n\n\t\tif (*vcn < le_vcn)\n\t\t\treturn ret;\n\n\t\tret = le;\n\t}\n\n\treturn ret;\n}\n\n \nstatic struct ATTR_LIST_ENTRY *al_find_le_to_insert(struct ntfs_inode *ni,\n\t\t\t\t\t\t    enum ATTR_TYPE type,\n\t\t\t\t\t\t    const __le16 *name,\n\t\t\t\t\t\t    u8 name_len, CLST vcn)\n{\n\tstruct ATTR_LIST_ENTRY *le = NULL, *prev;\n\tu32 type_in = le32_to_cpu(type);\n\n\t \n\twhile ((le = al_enumerate(ni, prev = le))) {\n\t\tint diff = le32_to_cpu(le->type) - type_in;\n\n\t\tif (diff < 0)\n\t\t\tcontinue;\n\n\t\tif (diff > 0)\n\t\t\treturn le;\n\n\t\tif (!le->vcn) {\n\t\t\t \n\t\t\tdiff = ntfs_cmp_names(le_name(le), le->name_len, name,\n\t\t\t\t\t      name_len, ni->mi.sbi->upcase,\n\t\t\t\t\t      true);\n\t\t\tif (diff < 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (diff > 0)\n\t\t\t\treturn le;\n\t\t}\n\n\t\tif (le64_to_cpu(le->vcn) >= vcn)\n\t\t\treturn le;\n\t}\n\n\treturn prev ? Add2Ptr(prev, le16_to_cpu(prev->size)) : ni->attr_list.le;\n}\n\n \nint al_add_le(struct ntfs_inode *ni, enum ATTR_TYPE type, const __le16 *name,\n\t      u8 name_len, CLST svcn, __le16 id, const struct MFT_REF *ref,\n\t      struct ATTR_LIST_ENTRY **new_le)\n{\n\tint err;\n\tstruct ATTRIB *attr;\n\tstruct ATTR_LIST_ENTRY *le;\n\tsize_t off;\n\tu16 sz;\n\tsize_t asize, new_asize, old_size;\n\tu64 new_size;\n\ttypeof(ni->attr_list) *al = &ni->attr_list;\n\n\t \n\tsz = le_size(name_len);\n\told_size = al->size;\n\tnew_size = old_size + sz;\n\tasize = al_aligned(old_size);\n\tnew_asize = al_aligned(new_size);\n\n\t \n\tle = al_find_le_to_insert(ni, type, name, name_len, svcn);\n\toff = PtrOffset(al->le, le);\n\n\tif (new_size > asize) {\n\t\tvoid *ptr = kmalloc(new_asize, GFP_NOFS);\n\n\t\tif (!ptr)\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(ptr, al->le, off);\n\t\tmemcpy(Add2Ptr(ptr, off + sz), le, old_size - off);\n\t\tle = Add2Ptr(ptr, off);\n\t\tkfree(al->le);\n\t\tal->le = ptr;\n\t} else {\n\t\tmemmove(Add2Ptr(le, sz), le, old_size - off);\n\t}\n\t*new_le = le;\n\n\tal->size = new_size;\n\n\tle->type = type;\n\tle->size = cpu_to_le16(sz);\n\tle->name_len = name_len;\n\tle->name_off = offsetof(struct ATTR_LIST_ENTRY, name);\n\tle->vcn = cpu_to_le64(svcn);\n\tle->ref = *ref;\n\tle->id = id;\n\tmemcpy(le->name, name, sizeof(short) * name_len);\n\n\terr = attr_set_size(ni, ATTR_LIST, NULL, 0, &al->run, new_size,\n\t\t\t    &new_size, true, &attr);\n\tif (err) {\n\t\t \n\t\tmemmove(le, Add2Ptr(le, sz), old_size - off);\n\t\tal->size = old_size;\n\t\treturn err;\n\t}\n\n\tal->dirty = true;\n\n\tif (attr && attr->non_res) {\n\t\terr = ntfs_sb_write_run(ni->mi.sbi, &al->run, 0, al->le,\n\t\t\t\t\tal->size, 0);\n\t\tif (err)\n\t\t\treturn err;\n\t\tal->dirty = false;\n\t}\n\n\treturn 0;\n}\n\n \nbool al_remove_le(struct ntfs_inode *ni, struct ATTR_LIST_ENTRY *le)\n{\n\tu16 size;\n\tsize_t off;\n\ttypeof(ni->attr_list) *al = &ni->attr_list;\n\n\tif (!al_is_valid_le(ni, le))\n\t\treturn false;\n\n\t \n\tsize = le16_to_cpu(le->size);\n\toff = PtrOffset(al->le, le);\n\n\tmemmove(le, Add2Ptr(le, size), al->size - (off + size));\n\n\tal->size -= size;\n\tal->dirty = true;\n\n\treturn true;\n}\n\n \nbool al_delete_le(struct ntfs_inode *ni, enum ATTR_TYPE type, CLST vcn,\n\t\t  const __le16 *name, u8 name_len, const struct MFT_REF *ref)\n{\n\tu16 size;\n\tstruct ATTR_LIST_ENTRY *le;\n\tsize_t off;\n\ttypeof(ni->attr_list) *al = &ni->attr_list;\n\n\t \n\tle = al_find_ex(ni, NULL, type, name, name_len, &vcn);\n\tif (!le)\n\t\treturn false;\n\n\toff = PtrOffset(al->le, le);\n\nnext:\n\tif (off >= al->size)\n\t\treturn false;\n\tif (le->type != type)\n\t\treturn false;\n\tif (le->name_len != name_len)\n\t\treturn false;\n\tif (name_len && ntfs_cmp_names(le_name(le), name_len, name, name_len,\n\t\t\t\t       ni->mi.sbi->upcase, true))\n\t\treturn false;\n\tif (le64_to_cpu(le->vcn) != vcn)\n\t\treturn false;\n\n\t \n\tif (ref && memcmp(ref, &le->ref, sizeof(*ref))) {\n\t\toff += le16_to_cpu(le->size);\n\t\tle = Add2Ptr(al->le, off);\n\t\tgoto next;\n\t}\n\n\t \n\tsize = le16_to_cpu(le->size);\n\t \n\tmemmove(le, Add2Ptr(le, size), al->size - (off + size));\n\n\tal->size -= size;\n\tal->dirty = true;\n\n\treturn true;\n}\n\nint al_update(struct ntfs_inode *ni, int sync)\n{\n\tint err;\n\tstruct ATTRIB *attr;\n\ttypeof(ni->attr_list) *al = &ni->attr_list;\n\n\tif (!al->dirty || !al->size)\n\t\treturn 0;\n\n\t \n\terr = attr_set_size(ni, ATTR_LIST, NULL, 0, &al->run, al->size, NULL,\n\t\t\t    false, &attr);\n\tif (err)\n\t\tgoto out;\n\n\tif (!attr->non_res) {\n\t\tmemcpy(resident_data(attr), al->le, al->size);\n\t} else {\n\t\terr = ntfs_sb_write_run(ni->mi.sbi, &al->run, 0, al->le,\n\t\t\t\t\tal->size, sync);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tattr->nres.valid_size = attr->nres.data_size;\n\t}\n\n\tni->mi.dirty = true;\n\tal->dirty = false;\n\nout:\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}