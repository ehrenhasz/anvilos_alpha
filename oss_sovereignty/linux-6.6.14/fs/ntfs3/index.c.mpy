{
  "module_name": "index.c",
  "hash_id": "4649fa077022412980b19dcf15acaa51bfe9fc0926731cee2f518b0ebb243454",
  "original_prompt": "Ingested from linux-6.6.14/fs/ntfs3/index.c",
  "human_readable_source": "\n \n\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\n#include \"debug.h\"\n#include \"ntfs.h\"\n#include \"ntfs_fs.h\"\n\nstatic const struct INDEX_NAMES {\n\tconst __le16 *name;\n\tu8 name_len;\n} s_index_names[INDEX_MUTEX_TOTAL] = {\n\t{ I30_NAME, ARRAY_SIZE(I30_NAME) }, { SII_NAME, ARRAY_SIZE(SII_NAME) },\n\t{ SDH_NAME, ARRAY_SIZE(SDH_NAME) }, { SO_NAME, ARRAY_SIZE(SO_NAME) },\n\t{ SQ_NAME, ARRAY_SIZE(SQ_NAME) },   { SR_NAME, ARRAY_SIZE(SR_NAME) },\n};\n\n \nstatic int cmp_fnames(const void *key1, size_t l1, const void *key2, size_t l2,\n\t\t      const void *data)\n{\n\tconst struct ATTR_FILE_NAME *f2 = key2;\n\tconst struct ntfs_sb_info *sbi = data;\n\tconst struct ATTR_FILE_NAME *f1;\n\tu16 fsize2;\n\tbool both_case;\n\n\tif (l2 <= offsetof(struct ATTR_FILE_NAME, name))\n\t\treturn -1;\n\n\tfsize2 = fname_full_size(f2);\n\tif (l2 < fsize2)\n\t\treturn -1;\n\n\tboth_case = f2->type != FILE_NAME_DOS && !sbi->options->nocase;\n\tif (!l1) {\n\t\tconst struct le_str *s2 = (struct le_str *)&f2->name_len;\n\n\t\t \n\t\treturn ntfs_cmp_names_cpu(key1, s2, sbi->upcase, both_case);\n\t}\n\n\tf1 = key1;\n\treturn ntfs_cmp_names(f1->name, f1->name_len, f2->name, f2->name_len,\n\t\t\t      sbi->upcase, both_case);\n}\n\n \nstatic int cmp_uint(const void *key1, size_t l1, const void *key2, size_t l2,\n\t\t    const void *data)\n{\n\tconst u32 *k1 = key1;\n\tconst u32 *k2 = key2;\n\n\tif (l2 < sizeof(u32))\n\t\treturn -1;\n\n\tif (*k1 < *k2)\n\t\treturn -1;\n\tif (*k1 > *k2)\n\t\treturn 1;\n\treturn 0;\n}\n\n \nstatic int cmp_sdh(const void *key1, size_t l1, const void *key2, size_t l2,\n\t\t   const void *data)\n{\n\tconst struct SECURITY_KEY *k1 = key1;\n\tconst struct SECURITY_KEY *k2 = key2;\n\tu32 t1, t2;\n\n\tif (l2 < sizeof(struct SECURITY_KEY))\n\t\treturn -1;\n\n\tt1 = le32_to_cpu(k1->hash);\n\tt2 = le32_to_cpu(k2->hash);\n\n\t \n\tif (t1 < t2)\n\t\treturn -1;\n\tif (t1 > t2)\n\t\treturn 1;\n\n\t \n\tif (data) {\n\t\tt1 = le32_to_cpu(k1->sec_id);\n\t\tt2 = le32_to_cpu(k2->sec_id);\n\t\tif (t1 < t2)\n\t\t\treturn -1;\n\t\tif (t1 > t2)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int cmp_uints(const void *key1, size_t l1, const void *key2, size_t l2,\n\t\t     const void *data)\n{\n\tconst __le32 *k1 = key1;\n\tconst __le32 *k2 = key2;\n\tsize_t count;\n\n\tif ((size_t)data == 1) {\n\t\t \n\n\t\tk1 += 1; \n\t\tk2 += 1; \n\t\tif (l2 <= sizeof(int))\n\t\t\treturn -1;\n\t\tl2 -= sizeof(int);\n\t\tif (l1 <= sizeof(int))\n\t\t\treturn 1;\n\t\tl1 -= sizeof(int);\n\t}\n\n\tif (l2 < sizeof(int))\n\t\treturn -1;\n\n\tfor (count = min(l1, l2) >> 2; count > 0; --count, ++k1, ++k2) {\n\t\tu32 t1 = le32_to_cpu(*k1);\n\t\tu32 t2 = le32_to_cpu(*k2);\n\n\t\tif (t1 > t2)\n\t\t\treturn 1;\n\t\tif (t1 < t2)\n\t\t\treturn -1;\n\t}\n\n\tif (l1 > l2)\n\t\treturn 1;\n\tif (l1 < l2)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic inline NTFS_CMP_FUNC get_cmp_func(const struct INDEX_ROOT *root)\n{\n\tswitch (root->type) {\n\tcase ATTR_NAME:\n\t\tif (root->rule == NTFS_COLLATION_TYPE_FILENAME)\n\t\t\treturn &cmp_fnames;\n\t\tbreak;\n\tcase ATTR_ZERO:\n\t\tswitch (root->rule) {\n\t\tcase NTFS_COLLATION_TYPE_UINT:\n\t\t\treturn &cmp_uint;\n\t\tcase NTFS_COLLATION_TYPE_SECURITY_HASH:\n\t\t\treturn &cmp_sdh;\n\t\tcase NTFS_COLLATION_TYPE_UINTS:\n\t\t\treturn &cmp_uints;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NULL;\n}\n\nstruct bmp_buf {\n\tstruct ATTRIB *b;\n\tstruct mft_inode *mi;\n\tstruct buffer_head *bh;\n\tulong *buf;\n\tsize_t bit;\n\tu32 nbits;\n\tu64 new_valid;\n};\n\nstatic int bmp_buf_get(struct ntfs_index *indx, struct ntfs_inode *ni,\n\t\t       size_t bit, struct bmp_buf *bbuf)\n{\n\tstruct ATTRIB *b;\n\tsize_t data_size, valid_size, vbo, off = bit >> 3;\n\tstruct ntfs_sb_info *sbi = ni->mi.sbi;\n\tCLST vcn = off >> sbi->cluster_bits;\n\tstruct ATTR_LIST_ENTRY *le = NULL;\n\tstruct buffer_head *bh;\n\tstruct super_block *sb;\n\tu32 blocksize;\n\tconst struct INDEX_NAMES *in = &s_index_names[indx->type];\n\n\tbbuf->bh = NULL;\n\n\tb = ni_find_attr(ni, NULL, &le, ATTR_BITMAP, in->name, in->name_len,\n\t\t\t &vcn, &bbuf->mi);\n\tbbuf->b = b;\n\tif (!b)\n\t\treturn -EINVAL;\n\n\tif (!b->non_res) {\n\t\tdata_size = le32_to_cpu(b->res.data_size);\n\n\t\tif (off >= data_size)\n\t\t\treturn -EINVAL;\n\n\t\tbbuf->buf = (ulong *)resident_data(b);\n\t\tbbuf->bit = 0;\n\t\tbbuf->nbits = data_size * 8;\n\n\t\treturn 0;\n\t}\n\n\tdata_size = le64_to_cpu(b->nres.data_size);\n\tif (WARN_ON(off >= data_size)) {\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\tvalid_size = le64_to_cpu(b->nres.valid_size);\n\n\tbh = ntfs_bread_run(sbi, &indx->bitmap_run, off);\n\tif (!bh)\n\t\treturn -EIO;\n\n\tif (IS_ERR(bh))\n\t\treturn PTR_ERR(bh);\n\n\tbbuf->bh = bh;\n\n\tif (buffer_locked(bh))\n\t\t__wait_on_buffer(bh);\n\n\tlock_buffer(bh);\n\n\tsb = sbi->sb;\n\tblocksize = sb->s_blocksize;\n\n\tvbo = off & ~(size_t)sbi->block_mask;\n\n\tbbuf->new_valid = vbo + blocksize;\n\tif (bbuf->new_valid <= valid_size)\n\t\tbbuf->new_valid = 0;\n\telse if (bbuf->new_valid > data_size)\n\t\tbbuf->new_valid = data_size;\n\n\tif (vbo >= valid_size) {\n\t\tmemset(bh->b_data, 0, blocksize);\n\t} else if (vbo + blocksize > valid_size) {\n\t\tu32 voff = valid_size & sbi->block_mask;\n\n\t\tmemset(bh->b_data + voff, 0, blocksize - voff);\n\t}\n\n\tbbuf->buf = (ulong *)bh->b_data;\n\tbbuf->bit = 8 * (off & ~(size_t)sbi->block_mask);\n\tbbuf->nbits = 8 * blocksize;\n\n\treturn 0;\n}\n\nstatic void bmp_buf_put(struct bmp_buf *bbuf, bool dirty)\n{\n\tstruct buffer_head *bh = bbuf->bh;\n\tstruct ATTRIB *b = bbuf->b;\n\n\tif (!bh) {\n\t\tif (b && !b->non_res && dirty)\n\t\t\tbbuf->mi->dirty = true;\n\t\treturn;\n\t}\n\n\tif (!dirty)\n\t\tgoto out;\n\n\tif (bbuf->new_valid) {\n\t\tb->nres.valid_size = cpu_to_le64(bbuf->new_valid);\n\t\tbbuf->mi->dirty = true;\n\t}\n\n\tset_buffer_uptodate(bh);\n\tmark_buffer_dirty(bh);\n\nout:\n\tunlock_buffer(bh);\n\tput_bh(bh);\n}\n\n \nstatic int indx_mark_used(struct ntfs_index *indx, struct ntfs_inode *ni,\n\t\t\t  size_t bit)\n{\n\tint err;\n\tstruct bmp_buf bbuf;\n\n\terr = bmp_buf_get(indx, ni, bit, &bbuf);\n\tif (err)\n\t\treturn err;\n\n\t__set_bit_le(bit - bbuf.bit, bbuf.buf);\n\n\tbmp_buf_put(&bbuf, true);\n\n\treturn 0;\n}\n\n \nstatic int indx_mark_free(struct ntfs_index *indx, struct ntfs_inode *ni,\n\t\t\t  size_t bit)\n{\n\tint err;\n\tstruct bmp_buf bbuf;\n\n\terr = bmp_buf_get(indx, ni, bit, &bbuf);\n\tif (err)\n\t\treturn err;\n\n\t__clear_bit_le(bit - bbuf.bit, bbuf.buf);\n\n\tbmp_buf_put(&bbuf, true);\n\n\treturn 0;\n}\n\n \nstatic int scan_nres_bitmap(struct ntfs_inode *ni, struct ATTRIB *bitmap,\n\t\t\t    struct ntfs_index *indx, size_t from,\n\t\t\t    bool (*fn)(const ulong *buf, u32 bit, u32 bits,\n\t\t\t\t       size_t *ret),\n\t\t\t    size_t *ret)\n{\n\tstruct ntfs_sb_info *sbi = ni->mi.sbi;\n\tstruct super_block *sb = sbi->sb;\n\tstruct runs_tree *run = &indx->bitmap_run;\n\tstruct rw_semaphore *lock = &indx->run_lock;\n\tu32 nbits = sb->s_blocksize * 8;\n\tu32 blocksize = sb->s_blocksize;\n\tu64 valid_size = le64_to_cpu(bitmap->nres.valid_size);\n\tu64 data_size = le64_to_cpu(bitmap->nres.data_size);\n\tsector_t eblock = bytes_to_block(sb, data_size);\n\tsize_t vbo = from >> 3;\n\tsector_t blk = (vbo & sbi->cluster_mask) >> sb->s_blocksize_bits;\n\tsector_t vblock = vbo >> sb->s_blocksize_bits;\n\tsector_t blen, block;\n\tCLST lcn, clen, vcn, vcn_next;\n\tsize_t idx;\n\tstruct buffer_head *bh;\n\tbool ok;\n\n\t*ret = MINUS_ONE_T;\n\n\tif (vblock >= eblock)\n\t\treturn 0;\n\n\tfrom &= nbits - 1;\n\tvcn = vbo >> sbi->cluster_bits;\n\n\tdown_read(lock);\n\tok = run_lookup_entry(run, vcn, &lcn, &clen, &idx);\n\tup_read(lock);\n\nnext_run:\n\tif (!ok) {\n\t\tint err;\n\t\tconst struct INDEX_NAMES *name = &s_index_names[indx->type];\n\n\t\tdown_write(lock);\n\t\terr = attr_load_runs_vcn(ni, ATTR_BITMAP, name->name,\n\t\t\t\t\t name->name_len, run, vcn);\n\t\tup_write(lock);\n\t\tif (err)\n\t\t\treturn err;\n\t\tdown_read(lock);\n\t\tok = run_lookup_entry(run, vcn, &lcn, &clen, &idx);\n\t\tup_read(lock);\n\t\tif (!ok)\n\t\t\treturn -EINVAL;\n\t}\n\n\tblen = (sector_t)clen * sbi->blocks_per_cluster;\n\tblock = (sector_t)lcn * sbi->blocks_per_cluster;\n\n\tfor (; blk < blen; blk++, from = 0) {\n\t\tbh = ntfs_bread(sb, block + blk);\n\t\tif (!bh)\n\t\t\treturn -EIO;\n\n\t\tvbo = (u64)vblock << sb->s_blocksize_bits;\n\t\tif (vbo >= valid_size) {\n\t\t\tmemset(bh->b_data, 0, blocksize);\n\t\t} else if (vbo + blocksize > valid_size) {\n\t\t\tu32 voff = valid_size & sbi->block_mask;\n\n\t\t\tmemset(bh->b_data + voff, 0, blocksize - voff);\n\t\t}\n\n\t\tif (vbo + blocksize > data_size)\n\t\t\tnbits = 8 * (data_size - vbo);\n\n\t\tok = nbits > from ?\n\t\t\t     (*fn)((ulong *)bh->b_data, from, nbits, ret) :\n\t\t\t     false;\n\t\tput_bh(bh);\n\n\t\tif (ok) {\n\t\t\t*ret += 8 * vbo;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (++vblock >= eblock) {\n\t\t\t*ret = MINUS_ONE_T;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tblk = 0;\n\tvcn_next = vcn + clen;\n\tdown_read(lock);\n\tok = run_get_entry(run, ++idx, &vcn, &lcn, &clen) && vcn == vcn_next;\n\tif (!ok)\n\t\tvcn = vcn_next;\n\tup_read(lock);\n\tgoto next_run;\n}\n\nstatic bool scan_for_free(const ulong *buf, u32 bit, u32 bits, size_t *ret)\n{\n\tsize_t pos = find_next_zero_bit_le(buf, bits, bit);\n\n\tif (pos >= bits)\n\t\treturn false;\n\t*ret = pos;\n\treturn true;\n}\n\n \nstatic int indx_find_free(struct ntfs_index *indx, struct ntfs_inode *ni,\n\t\t\t  size_t *bit, struct ATTRIB **bitmap)\n{\n\tstruct ATTRIB *b;\n\tstruct ATTR_LIST_ENTRY *le = NULL;\n\tconst struct INDEX_NAMES *in = &s_index_names[indx->type];\n\tint err;\n\n\tb = ni_find_attr(ni, NULL, &le, ATTR_BITMAP, in->name, in->name_len,\n\t\t\t NULL, NULL);\n\n\tif (!b)\n\t\treturn -ENOENT;\n\n\t*bitmap = b;\n\t*bit = MINUS_ONE_T;\n\n\tif (!b->non_res) {\n\t\tu32 nbits = 8 * le32_to_cpu(b->res.data_size);\n\t\tsize_t pos = find_next_zero_bit_le(resident_data(b), nbits, 0);\n\n\t\tif (pos < nbits)\n\t\t\t*bit = pos;\n\t} else {\n\t\terr = scan_nres_bitmap(ni, b, indx, 0, &scan_for_free, bit);\n\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic bool scan_for_used(const ulong *buf, u32 bit, u32 bits, size_t *ret)\n{\n\tsize_t pos = find_next_bit_le(buf, bits, bit);\n\n\tif (pos >= bits)\n\t\treturn false;\n\t*ret = pos;\n\treturn true;\n}\n\n \nint indx_used_bit(struct ntfs_index *indx, struct ntfs_inode *ni, size_t *bit)\n{\n\tstruct ATTRIB *b;\n\tstruct ATTR_LIST_ENTRY *le = NULL;\n\tsize_t from = *bit;\n\tconst struct INDEX_NAMES *in = &s_index_names[indx->type];\n\tint err;\n\n\tb = ni_find_attr(ni, NULL, &le, ATTR_BITMAP, in->name, in->name_len,\n\t\t\t NULL, NULL);\n\n\tif (!b)\n\t\treturn -ENOENT;\n\n\t*bit = MINUS_ONE_T;\n\n\tif (!b->non_res) {\n\t\tu32 nbits = le32_to_cpu(b->res.data_size) * 8;\n\t\tsize_t pos = find_next_bit_le(resident_data(b), nbits, from);\n\n\t\tif (pos < nbits)\n\t\t\t*bit = pos;\n\t} else {\n\t\terr = scan_nres_bitmap(ni, b, indx, from, &scan_for_used, bit);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstatic const struct NTFS_DE *hdr_find_split(const struct INDEX_HDR *hdr)\n{\n\tsize_t o;\n\tconst struct NTFS_DE *e = hdr_first_de(hdr);\n\tu32 used_2 = le32_to_cpu(hdr->used) >> 1;\n\tu16 esize;\n\n\tif (!e || de_is_last(e))\n\t\treturn NULL;\n\n\tesize = le16_to_cpu(e->size);\n\tfor (o = le32_to_cpu(hdr->de_off) + esize; o < used_2; o += esize) {\n\t\tconst struct NTFS_DE *p = e;\n\n\t\te = Add2Ptr(hdr, o);\n\n\t\t \n\t\tif (de_is_last(e))\n\t\t\treturn p;\n\n\t\tesize = le16_to_cpu(e->size);\n\t}\n\n\treturn e;\n}\n\n \nstatic const struct NTFS_DE *hdr_insert_head(struct INDEX_HDR *hdr,\n\t\t\t\t\t     const void *ins, u32 ins_bytes)\n{\n\tu32 to_move;\n\tstruct NTFS_DE *e = hdr_first_de(hdr);\n\tu32 used = le32_to_cpu(hdr->used);\n\n\tif (!e)\n\t\treturn NULL;\n\n\t \n\tto_move = used - le32_to_cpu(hdr->de_off);\n\tmemmove(Add2Ptr(e, ins_bytes), e, to_move);\n\tmemcpy(e, ins, ins_bytes);\n\thdr->used = cpu_to_le32(used + ins_bytes);\n\n\treturn e;\n}\n\n \nstatic bool index_hdr_check(const struct INDEX_HDR *hdr, u32 bytes)\n{\n\tu32 end = le32_to_cpu(hdr->used);\n\tu32 tot = le32_to_cpu(hdr->total);\n\tu32 off = le32_to_cpu(hdr->de_off);\n\n\tif (!IS_ALIGNED(off, 8) || tot > bytes || end > tot ||\n\t    off + sizeof(struct NTFS_DE) > end) {\n\t\t \n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nstatic bool index_buf_check(const struct INDEX_BUFFER *ib, u32 bytes,\n\t\t\t    const CLST *vbn)\n{\n\tconst struct NTFS_RECORD_HEADER *rhdr = &ib->rhdr;\n\tu16 fo = le16_to_cpu(rhdr->fix_off);\n\tu16 fn = le16_to_cpu(rhdr->fix_num);\n\n\tif (bytes <= offsetof(struct INDEX_BUFFER, ihdr) ||\n\t    rhdr->sign != NTFS_INDX_SIGNATURE ||\n\t    fo < sizeof(struct INDEX_BUFFER)\n\t     \n\t    || (vbn && *vbn != le64_to_cpu(ib->vbn)) || (fo % sizeof(short)) ||\n\t    fo + fn * sizeof(short) >= bytes ||\n\t    fn != ((bytes >> SECTOR_SHIFT) + 1)) {\n\t\t \n\t\treturn false;\n\t}\n\n\treturn index_hdr_check(&ib->ihdr,\n\t\t\t       bytes - offsetof(struct INDEX_BUFFER, ihdr));\n}\n\nvoid fnd_clear(struct ntfs_fnd *fnd)\n{\n\tint i;\n\n\tfor (i = fnd->level - 1; i >= 0; i--) {\n\t\tstruct indx_node *n = fnd->nodes[i];\n\n\t\tif (!n)\n\t\t\tcontinue;\n\n\t\tput_indx_node(n);\n\t\tfnd->nodes[i] = NULL;\n\t}\n\tfnd->level = 0;\n\tfnd->root_de = NULL;\n}\n\nstatic int fnd_push(struct ntfs_fnd *fnd, struct indx_node *n,\n\t\t    struct NTFS_DE *e)\n{\n\tint i = fnd->level;\n\n\tif (i < 0 || i >= ARRAY_SIZE(fnd->nodes))\n\t\treturn -EINVAL;\n\tfnd->nodes[i] = n;\n\tfnd->de[i] = e;\n\tfnd->level += 1;\n\treturn 0;\n}\n\nstatic struct indx_node *fnd_pop(struct ntfs_fnd *fnd)\n{\n\tstruct indx_node *n;\n\tint i = fnd->level;\n\n\ti -= 1;\n\tn = fnd->nodes[i];\n\tfnd->nodes[i] = NULL;\n\tfnd->level = i;\n\n\treturn n;\n}\n\nstatic bool fnd_is_empty(struct ntfs_fnd *fnd)\n{\n\tif (!fnd->level)\n\t\treturn !fnd->root_de;\n\n\treturn !fnd->de[fnd->level - 1];\n}\n\n \nstatic struct NTFS_DE *hdr_find_e(const struct ntfs_index *indx,\n\t\t\t\t  const struct INDEX_HDR *hdr, const void *key,\n\t\t\t\t  size_t key_len, const void *ctx, int *diff)\n{\n\tstruct NTFS_DE *e, *found = NULL;\n\tNTFS_CMP_FUNC cmp = indx->cmp;\n\tint min_idx = 0, mid_idx, max_idx = 0;\n\tint diff2;\n\tint table_size = 8;\n\tu32 e_size, e_key_len;\n\tu32 end = le32_to_cpu(hdr->used);\n\tu32 off = le32_to_cpu(hdr->de_off);\n\tu32 total = le32_to_cpu(hdr->total);\n\tu16 offs[128];\n\n\tif (unlikely(!cmp))\n\t\treturn NULL;\n\nfill_table:\n\tif (end > total)\n\t\treturn NULL;\n\n\tif (off + sizeof(struct NTFS_DE) > end)\n\t\treturn NULL;\n\n\te = Add2Ptr(hdr, off);\n\te_size = le16_to_cpu(e->size);\n\n\tif (e_size < sizeof(struct NTFS_DE) || off + e_size > end)\n\t\treturn NULL;\n\n\tif (!de_is_last(e)) {\n\t\toffs[max_idx] = off;\n\t\toff += e_size;\n\n\t\tmax_idx++;\n\t\tif (max_idx < table_size)\n\t\t\tgoto fill_table;\n\n\t\tmax_idx--;\n\t}\n\nbinary_search:\n\te_key_len = le16_to_cpu(e->key_size);\n\n\tdiff2 = (*cmp)(key, key_len, e + 1, e_key_len, ctx);\n\tif (diff2 > 0) {\n\t\tif (found) {\n\t\t\tmin_idx = mid_idx + 1;\n\t\t} else {\n\t\t\tif (de_is_last(e))\n\t\t\t\treturn NULL;\n\n\t\t\tmax_idx = 0;\n\t\t\ttable_size = min(table_size * 2, (int)ARRAY_SIZE(offs));\n\t\t\tgoto fill_table;\n\t\t}\n\t} else if (diff2 < 0) {\n\t\tif (found)\n\t\t\tmax_idx = mid_idx - 1;\n\t\telse\n\t\t\tmax_idx--;\n\n\t\tfound = e;\n\t} else {\n\t\t*diff = 0;\n\t\treturn e;\n\t}\n\n\tif (min_idx > max_idx) {\n\t\t*diff = -1;\n\t\treturn found;\n\t}\n\n\tmid_idx = (min_idx + max_idx) >> 1;\n\te = Add2Ptr(hdr, offs[mid_idx]);\n\n\tgoto binary_search;\n}\n\n \nstatic struct NTFS_DE *hdr_insert_de(const struct ntfs_index *indx,\n\t\t\t\t     struct INDEX_HDR *hdr,\n\t\t\t\t     const struct NTFS_DE *de,\n\t\t\t\t     struct NTFS_DE *before, const void *ctx)\n{\n\tint diff;\n\tsize_t off = PtrOffset(hdr, before);\n\tu32 used = le32_to_cpu(hdr->used);\n\tu32 total = le32_to_cpu(hdr->total);\n\tu16 de_size = le16_to_cpu(de->size);\n\n\t \n\tif (used + de_size > total)\n\t\treturn NULL;\n\n\t \n\tif (before) {\n\t\t \n\t\tif (off >= used || off < le32_to_cpu(hdr->de_off) ||\n\t\t    off + le16_to_cpu(before->size) > total) {\n\t\t\treturn NULL;\n\t\t}\n\t\tgoto ok;\n\t}\n\t \n\tbefore = hdr_find_e(indx, hdr, de + 1, le16_to_cpu(de->key_size), ctx,\n\t\t\t    &diff);\n\tif (!before)\n\t\treturn NULL;\n\toff = PtrOffset(hdr, before);\n\nok:\n\t \n\tmemmove(Add2Ptr(before, de_size), before, used - off);\n\n\thdr->used = cpu_to_le32(used + de_size);\n\tmemcpy(before, de, de_size);\n\n\treturn before;\n}\n\n \nstatic inline struct NTFS_DE *hdr_delete_de(struct INDEX_HDR *hdr,\n\t\t\t\t\t    struct NTFS_DE *re)\n{\n\tu32 used = le32_to_cpu(hdr->used);\n\tu16 esize = le16_to_cpu(re->size);\n\tu32 off = PtrOffset(hdr, re);\n\tint bytes = used - (off + esize);\n\n\t \n\tif (!check_index_header(hdr, le32_to_cpu(hdr->total)))\n\t\treturn NULL;\n\n\tif (off >= used || esize < sizeof(struct NTFS_DE) ||\n\t    bytes < sizeof(struct NTFS_DE))\n\t\treturn NULL;\n\n\thdr->used = cpu_to_le32(used - esize);\n\tmemmove(re, Add2Ptr(re, esize), bytes);\n\n\treturn re;\n}\n\nvoid indx_clear(struct ntfs_index *indx)\n{\n\trun_close(&indx->alloc_run);\n\trun_close(&indx->bitmap_run);\n}\n\nint indx_init(struct ntfs_index *indx, struct ntfs_sb_info *sbi,\n\t      const struct ATTRIB *attr, enum index_mutex_classed type)\n{\n\tu32 t32;\n\tconst struct INDEX_ROOT *root = resident_data(attr);\n\n\tt32 = le32_to_cpu(attr->res.data_size);\n\tif (t32 <= offsetof(struct INDEX_ROOT, ihdr) ||\n\t    !index_hdr_check(&root->ihdr,\n\t\t\t     t32 - offsetof(struct INDEX_ROOT, ihdr))) {\n\t\tgoto out;\n\t}\n\n\t \n\tif (!root->index_block_clst)\n\t\tgoto out;\n\n\tindx->type = type;\n\tindx->idx2vbn_bits = __ffs(root->index_block_clst);\n\n\tt32 = le32_to_cpu(root->index_block_size);\n\tindx->index_bits = blksize_bits(t32);\n\n\t \n\tif (t32 < sbi->cluster_size) {\n\t\t \n\t\tif (t32 != root->index_block_clst * SECTOR_SIZE)\n\t\t\tgoto out;\n\n\t\t \n\t\tif ((sbi->cluster_size >> SECTOR_SHIFT) &\n\t\t    (root->index_block_clst - 1)) {\n\t\t\tgoto out;\n\t\t}\n\n\t\tindx->vbn2vbo_bits = SECTOR_SHIFT;\n\t} else {\n\t\t \n\t\tif (t32 != root->index_block_clst << sbi->cluster_bits)\n\t\t\tgoto out;\n\n\t\tindx->vbn2vbo_bits = sbi->cluster_bits;\n\t}\n\n\tinit_rwsem(&indx->run_lock);\n\n\tindx->cmp = get_cmp_func(root);\n\tif (!indx->cmp)\n\t\tgoto out;\n\n\treturn 0;\n\nout:\n\tntfs_set_state(sbi, NTFS_DIRTY_DIRTY);\n\treturn -EINVAL;\n}\n\nstatic struct indx_node *indx_new(struct ntfs_index *indx,\n\t\t\t\t  struct ntfs_inode *ni, CLST vbn,\n\t\t\t\t  const __le64 *sub_vbn)\n{\n\tint err;\n\tstruct NTFS_DE *e;\n\tstruct indx_node *r;\n\tstruct INDEX_HDR *hdr;\n\tstruct INDEX_BUFFER *index;\n\tu64 vbo = (u64)vbn << indx->vbn2vbo_bits;\n\tu32 bytes = 1u << indx->index_bits;\n\tu16 fn;\n\tu32 eo;\n\n\tr = kzalloc(sizeof(struct indx_node), GFP_NOFS);\n\tif (!r)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tindex = kzalloc(bytes, GFP_NOFS);\n\tif (!index) {\n\t\tkfree(r);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\terr = ntfs_get_bh(ni->mi.sbi, &indx->alloc_run, vbo, bytes, &r->nb);\n\n\tif (err) {\n\t\tkfree(index);\n\t\tkfree(r);\n\t\treturn ERR_PTR(err);\n\t}\n\n\t \n\tindex->rhdr.sign = NTFS_INDX_SIGNATURE;\n\tindex->rhdr.fix_off = cpu_to_le16(sizeof(struct INDEX_BUFFER));  \n\tfn = (bytes >> SECTOR_SHIFT) + 1;  \n\tindex->rhdr.fix_num = cpu_to_le16(fn);\n\tindex->vbn = cpu_to_le64(vbn);\n\thdr = &index->ihdr;\n\teo = ALIGN(sizeof(struct INDEX_BUFFER) + fn * sizeof(short), 8);\n\thdr->de_off = cpu_to_le32(eo);\n\n\te = Add2Ptr(hdr, eo);\n\n\tif (sub_vbn) {\n\t\te->flags = NTFS_IE_LAST | NTFS_IE_HAS_SUBNODES;\n\t\te->size = cpu_to_le16(sizeof(struct NTFS_DE) + sizeof(u64));\n\t\thdr->used =\n\t\t\tcpu_to_le32(eo + sizeof(struct NTFS_DE) + sizeof(u64));\n\t\tde_set_vbn_le(e, *sub_vbn);\n\t\thdr->flags = 1;\n\t} else {\n\t\te->size = cpu_to_le16(sizeof(struct NTFS_DE));\n\t\thdr->used = cpu_to_le32(eo + sizeof(struct NTFS_DE));\n\t\te->flags = NTFS_IE_LAST;\n\t}\n\n\thdr->total = cpu_to_le32(bytes - offsetof(struct INDEX_BUFFER, ihdr));\n\n\tr->index = index;\n\treturn r;\n}\n\nstruct INDEX_ROOT *indx_get_root(struct ntfs_index *indx, struct ntfs_inode *ni,\n\t\t\t\t struct ATTRIB **attr, struct mft_inode **mi)\n{\n\tstruct ATTR_LIST_ENTRY *le = NULL;\n\tstruct ATTRIB *a;\n\tconst struct INDEX_NAMES *in = &s_index_names[indx->type];\n\tstruct INDEX_ROOT *root;\n\n\ta = ni_find_attr(ni, NULL, &le, ATTR_ROOT, in->name, in->name_len, NULL,\n\t\t\t mi);\n\tif (!a)\n\t\treturn NULL;\n\n\tif (attr)\n\t\t*attr = a;\n\n\troot = resident_data_ex(a, sizeof(struct INDEX_ROOT));\n\n\t \n\tif (root &&\n\t    offsetof(struct INDEX_ROOT, ihdr) + le32_to_cpu(root->ihdr.used) >\n\t\t    le32_to_cpu(a->res.data_size)) {\n\t\treturn NULL;\n\t}\n\n\treturn root;\n}\n\nstatic int indx_write(struct ntfs_index *indx, struct ntfs_inode *ni,\n\t\t      struct indx_node *node, int sync)\n{\n\tstruct INDEX_BUFFER *ib = node->index;\n\n\treturn ntfs_write_bh(ni->mi.sbi, &ib->rhdr, &node->nb, sync);\n}\n\n \nint indx_read(struct ntfs_index *indx, struct ntfs_inode *ni, CLST vbn,\n\t      struct indx_node **node)\n{\n\tint err;\n\tstruct INDEX_BUFFER *ib;\n\tstruct runs_tree *run = &indx->alloc_run;\n\tstruct rw_semaphore *lock = &indx->run_lock;\n\tu64 vbo = (u64)vbn << indx->vbn2vbo_bits;\n\tu32 bytes = 1u << indx->index_bits;\n\tstruct indx_node *in = *node;\n\tconst struct INDEX_NAMES *name;\n\n\tif (!in) {\n\t\tin = kzalloc(sizeof(struct indx_node), GFP_NOFS);\n\t\tif (!in)\n\t\t\treturn -ENOMEM;\n\t} else {\n\t\tnb_put(&in->nb);\n\t}\n\n\tib = in->index;\n\tif (!ib) {\n\t\tib = kmalloc(bytes, GFP_NOFS);\n\t\tif (!ib) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tdown_read(lock);\n\terr = ntfs_read_bh(ni->mi.sbi, run, vbo, &ib->rhdr, bytes, &in->nb);\n\tup_read(lock);\n\tif (!err)\n\t\tgoto ok;\n\n\tif (err == -E_NTFS_FIXUP)\n\t\tgoto ok;\n\n\tif (err != -ENOENT)\n\t\tgoto out;\n\n\tname = &s_index_names[indx->type];\n\tdown_write(lock);\n\terr = attr_load_runs_range(ni, ATTR_ALLOC, name->name, name->name_len,\n\t\t\t\t   run, vbo, vbo + bytes);\n\tup_write(lock);\n\tif (err)\n\t\tgoto out;\n\n\tdown_read(lock);\n\terr = ntfs_read_bh(ni->mi.sbi, run, vbo, &ib->rhdr, bytes, &in->nb);\n\tup_read(lock);\n\tif (err == -E_NTFS_FIXUP)\n\t\tgoto ok;\n\n\tif (err)\n\t\tgoto out;\n\nok:\n\tif (!index_buf_check(ib, bytes, &vbn)) {\n\t\tntfs_inode_err(&ni->vfs_inode, \"directory corrupted\");\n\t\tntfs_set_state(ni->mi.sbi, NTFS_DIRTY_ERROR);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (err == -E_NTFS_FIXUP) {\n\t\tntfs_write_bh(ni->mi.sbi, &ib->rhdr, &in->nb, 0);\n\t\terr = 0;\n\t}\n\n\t \n\tif (offsetof(struct INDEX_BUFFER, ihdr) + le32_to_cpu(ib->ihdr.used) >\n\t    bytes) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tin->index = ib;\n\t*node = in;\n\nout:\n\tif (err == -E_NTFS_CORRUPT) {\n\t\tntfs_inode_err(&ni->vfs_inode, \"directory corrupted\");\n\t\tntfs_set_state(ni->mi.sbi, NTFS_DIRTY_ERROR);\n\t\terr = -EINVAL;\n\t}\n\n\tif (ib != in->index)\n\t\tkfree(ib);\n\n\tif (*node != in) {\n\t\tnb_put(&in->nb);\n\t\tkfree(in);\n\t}\n\n\treturn err;\n}\n\n \nint indx_find(struct ntfs_index *indx, struct ntfs_inode *ni,\n\t      const struct INDEX_ROOT *root, const void *key, size_t key_len,\n\t      const void *ctx, int *diff, struct NTFS_DE **entry,\n\t      struct ntfs_fnd *fnd)\n{\n\tint err;\n\tstruct NTFS_DE *e;\n\tstruct indx_node *node;\n\n\tif (!root)\n\t\troot = indx_get_root(&ni->dir, ni, NULL, NULL);\n\n\tif (!root) {\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\t \n\te = fnd->level ? fnd->de[fnd->level - 1] : fnd->root_de;\n\tif (e && !de_is_last(e) &&\n\t    !(*indx->cmp)(key, key_len, e + 1, le16_to_cpu(e->key_size), ctx)) {\n\t\t*entry = e;\n\t\t*diff = 0;\n\t\treturn 0;\n\t}\n\n\t \n\tfnd_clear(fnd);\n\n\t \n\te = hdr_find_e(indx, &root->ihdr, key, key_len, ctx, diff);\n\tif (!e)\n\t\treturn -EINVAL;\n\n\tfnd->root_de = e;\n\n\tfor (;;) {\n\t\tnode = NULL;\n\t\tif (*diff >= 0 || !de_has_vcn_ex(e))\n\t\t\tbreak;\n\n\t\t \n\t\terr = indx_read(indx, ni, de_get_vbn(e), &node);\n\t\tif (err) {\n\t\t\t \n\t\t\treturn err;\n\t\t}\n\n\t\t \n\t\te = hdr_find_e(indx, &node->index->ihdr, key, key_len, ctx,\n\t\t\t       diff);\n\t\tif (!e) {\n\t\t\tput_indx_node(node);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfnd_push(fnd, node, e);\n\t}\n\n\t*entry = e;\n\treturn 0;\n}\n\nint indx_find_sort(struct ntfs_index *indx, struct ntfs_inode *ni,\n\t\t   const struct INDEX_ROOT *root, struct NTFS_DE **entry,\n\t\t   struct ntfs_fnd *fnd)\n{\n\tint err;\n\tstruct indx_node *n = NULL;\n\tstruct NTFS_DE *e;\n\tsize_t iter = 0;\n\tint level = fnd->level;\n\n\tif (!*entry) {\n\t\t \n\t\te = hdr_first_de(&root->ihdr);\n\t\tif (!e)\n\t\t\treturn 0;\n\t\tfnd_clear(fnd);\n\t\tfnd->root_de = e;\n\t} else if (!level) {\n\t\tif (de_is_last(fnd->root_de)) {\n\t\t\t*entry = NULL;\n\t\t\treturn 0;\n\t\t}\n\n\t\te = hdr_next_de(&root->ihdr, fnd->root_de);\n\t\tif (!e)\n\t\t\treturn -EINVAL;\n\t\tfnd->root_de = e;\n\t} else {\n\t\tn = fnd->nodes[level - 1];\n\t\te = fnd->de[level - 1];\n\n\t\tif (de_is_last(e))\n\t\t\tgoto pop_level;\n\n\t\te = hdr_next_de(&n->index->ihdr, e);\n\t\tif (!e)\n\t\t\treturn -EINVAL;\n\n\t\tfnd->de[level - 1] = e;\n\t}\n\n\t \nnext_iter:\n\tif (iter++ >= 1000)\n\t\treturn -EINVAL;\n\n\twhile (de_has_vcn_ex(e)) {\n\t\tif (le16_to_cpu(e->size) <\n\t\t    sizeof(struct NTFS_DE) + sizeof(u64)) {\n\t\t\tif (n) {\n\t\t\t\tfnd_pop(fnd);\n\t\t\t\tkfree(n);\n\t\t\t}\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\terr = indx_read(indx, ni, de_get_vbn(e), &n);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t \n\t\te = hdr_first_de(&n->index->ihdr);\n\t\tif (!e) {\n\t\t\tkfree(n);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfnd_push(fnd, n, e);\n\t}\n\n\tif (le16_to_cpu(e->size) > sizeof(struct NTFS_DE)) {\n\t\t*entry = e;\n\t\treturn 0;\n\t}\n\npop_level:\n\tfor (;;) {\n\t\tif (!de_is_last(e))\n\t\t\tgoto next_iter;\n\n\t\t \n\t\tif (n) {\n\t\t\tfnd_pop(fnd);\n\t\t\tkfree(n);\n\t\t}\n\n\t\tlevel = fnd->level;\n\n\t\tif (level) {\n\t\t\tn = fnd->nodes[level - 1];\n\t\t\te = fnd->de[level - 1];\n\t\t} else if (fnd->root_de) {\n\t\t\tn = NULL;\n\t\t\te = fnd->root_de;\n\t\t\tfnd->root_de = NULL;\n\t\t} else {\n\t\t\t*entry = NULL;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (le16_to_cpu(e->size) > sizeof(struct NTFS_DE)) {\n\t\t\t*entry = e;\n\t\t\tif (!fnd->root_de)\n\t\t\t\tfnd->root_de = e;\n\t\t\treturn 0;\n\t\t}\n\t}\n}\n\nint indx_find_raw(struct ntfs_index *indx, struct ntfs_inode *ni,\n\t\t  const struct INDEX_ROOT *root, struct NTFS_DE **entry,\n\t\t  size_t *off, struct ntfs_fnd *fnd)\n{\n\tint err;\n\tstruct indx_node *n = NULL;\n\tstruct NTFS_DE *e = NULL;\n\tstruct NTFS_DE *e2;\n\tsize_t bit;\n\tCLST next_used_vbn;\n\tCLST next_vbn;\n\tu32 record_size = ni->mi.sbi->record_size;\n\n\t \n\tif (!*entry) {\n\t\t \n\t\te = hdr_first_de(&root->ihdr);\n\t\tif (!e)\n\t\t\treturn 0;\n\t\tfnd_clear(fnd);\n\t\tfnd->root_de = e;\n\n\t\t \n\t\tif (*off >= record_size) {\n\t\t\tnext_vbn = (((*off - record_size) >> indx->index_bits))\n\t\t\t\t   << indx->idx2vbn_bits;\n\t\t\t \n\t\t\tgoto next;\n\t\t}\n\n\t\t \n\t\t*off = 0;\n\t} else if (!fnd->root_de)\n\t\treturn -EINVAL;\n\n\tfor (;;) {\n\t\t \n\t\tif (e && le16_to_cpu(e->size) > sizeof(struct NTFS_DE))\n\t\t\tgoto ok;\n\n\t\tif (!fnd->level) {\n\t\t\t \n\t\t\tif (!de_is_last(fnd->root_de)) {\n\t\t\t\te = hdr_next_de(&root->ihdr, fnd->root_de);\n\t\t\t\tif (!e)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tfnd->root_de = e;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tnext_vbn = 0;\n\t\t} else {\n\t\t\t \n\t\t\te2 = fnd->de[fnd->level - 1];\n\n\t\t\tn = fnd->nodes[fnd->level - 1];\n\n\t\t\tif (!de_is_last(e2)) {\n\t\t\t\te = hdr_next_de(&n->index->ihdr, e2);\n\t\t\t\tif (!e)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tfnd->de[fnd->level - 1] = e;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tnext_vbn = le64_to_cpu(n->index->vbn) +\n\t\t\t\t   root->index_block_clst;\n\t\t}\n\nnext:\n\t\t \n\t\tif (n) {\n\t\t\tfnd_pop(fnd);\n\t\t\tput_indx_node(n);\n\t\t\tn = NULL;\n\t\t}\n\n\t\t \n\t\tbit = next_vbn >> indx->idx2vbn_bits;\n\t\terr = indx_used_bit(indx, ni, &bit);\n\t\tif (err == -ENOENT || bit == MINUS_ONE_T) {\n\t\t\t \n\t\t\t*entry = NULL;\n\t\t\treturn 0;\n\t\t}\n\n\t\tnext_used_vbn = bit << indx->idx2vbn_bits;\n\n\t\t \n\t\terr = indx_read(indx, ni, next_used_vbn, &n);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\te = hdr_first_de(&n->index->ihdr);\n\t\tfnd_push(fnd, n, e);\n\t\tif (!e)\n\t\t\treturn -EINVAL;\n\t}\n\nok:\n\t \n\tif (!n) {\n\t\t \n\t\t*off = PtrOffset(&root->ihdr, e);\n\t} else {\n\t\t \n\t\t*off = (le64_to_cpu(n->index->vbn) << indx->vbn2vbo_bits) +\n\t\t       record_size + PtrOffset(&n->index->ihdr, e);\n\t}\n\n\t*entry = e;\n\treturn 0;\n}\n\n \nstatic int indx_create_allocate(struct ntfs_index *indx, struct ntfs_inode *ni,\n\t\t\t\tCLST *vbn)\n{\n\tint err;\n\tstruct ntfs_sb_info *sbi = ni->mi.sbi;\n\tstruct ATTRIB *bitmap;\n\tstruct ATTRIB *alloc;\n\tu32 data_size = 1u << indx->index_bits;\n\tu32 alloc_size = ntfs_up_cluster(sbi, data_size);\n\tCLST len = alloc_size >> sbi->cluster_bits;\n\tconst struct INDEX_NAMES *in = &s_index_names[indx->type];\n\tCLST alen;\n\tstruct runs_tree run;\n\n\trun_init(&run);\n\n\terr = attr_allocate_clusters(sbi, &run, 0, 0, len, NULL, ALLOCATE_DEF,\n\t\t\t\t     &alen, 0, NULL, NULL);\n\tif (err)\n\t\tgoto out;\n\n\terr = ni_insert_nonresident(ni, ATTR_ALLOC, in->name, in->name_len,\n\t\t\t\t    &run, 0, len, 0, &alloc, NULL, NULL);\n\tif (err)\n\t\tgoto out1;\n\n\talloc->nres.valid_size = alloc->nres.data_size = cpu_to_le64(data_size);\n\n\terr = ni_insert_resident(ni, bitmap_size(1), ATTR_BITMAP, in->name,\n\t\t\t\t in->name_len, &bitmap, NULL, NULL);\n\tif (err)\n\t\tgoto out2;\n\n\tif (in->name == I30_NAME) {\n\t\tni->vfs_inode.i_size = data_size;\n\t\tinode_set_bytes(&ni->vfs_inode, alloc_size);\n\t}\n\n\tmemcpy(&indx->alloc_run, &run, sizeof(run));\n\n\t*vbn = 0;\n\n\treturn 0;\n\nout2:\n\tmi_remove_attr(NULL, &ni->mi, alloc);\n\nout1:\n\trun_deallocate(sbi, &run, false);\n\nout:\n\treturn err;\n}\n\n \nstatic int indx_add_allocate(struct ntfs_index *indx, struct ntfs_inode *ni,\n\t\t\t     CLST *vbn)\n{\n\tint err;\n\tsize_t bit;\n\tu64 data_size;\n\tu64 bmp_size, bmp_size_v;\n\tstruct ATTRIB *bmp, *alloc;\n\tstruct mft_inode *mi;\n\tconst struct INDEX_NAMES *in = &s_index_names[indx->type];\n\n\terr = indx_find_free(indx, ni, &bit, &bmp);\n\tif (err)\n\t\tgoto out1;\n\n\tif (bit != MINUS_ONE_T) {\n\t\tbmp = NULL;\n\t} else {\n\t\tif (bmp->non_res) {\n\t\t\tbmp_size = le64_to_cpu(bmp->nres.data_size);\n\t\t\tbmp_size_v = le64_to_cpu(bmp->nres.valid_size);\n\t\t} else {\n\t\t\tbmp_size = bmp_size_v = le32_to_cpu(bmp->res.data_size);\n\t\t}\n\n\t\tbit = bmp_size << 3;\n\t}\n\n\tdata_size = (u64)(bit + 1) << indx->index_bits;\n\n\tif (bmp) {\n\t\t \n\t\terr = attr_set_size(ni, ATTR_BITMAP, in->name, in->name_len,\n\t\t\t\t    &indx->bitmap_run, bitmap_size(bit + 1),\n\t\t\t\t    NULL, true, NULL);\n\t\tif (err)\n\t\t\tgoto out1;\n\t}\n\n\talloc = ni_find_attr(ni, NULL, NULL, ATTR_ALLOC, in->name, in->name_len,\n\t\t\t     NULL, &mi);\n\tif (!alloc) {\n\t\terr = -EINVAL;\n\t\tif (bmp)\n\t\t\tgoto out2;\n\t\tgoto out1;\n\t}\n\n\t \n\terr = attr_set_size(ni, ATTR_ALLOC, in->name, in->name_len,\n\t\t\t    &indx->alloc_run, data_size, &data_size, true,\n\t\t\t    NULL);\n\tif (err) {\n\t\tif (bmp)\n\t\t\tgoto out2;\n\t\tgoto out1;\n\t}\n\n\tif (in->name == I30_NAME)\n\t\tni->vfs_inode.i_size = data_size;\n\n\t*vbn = bit << indx->idx2vbn_bits;\n\n\treturn 0;\n\nout2:\n\t \n\tattr_set_size(ni, ATTR_BITMAP, in->name, in->name_len,\n\t\t      &indx->bitmap_run, bmp_size, &bmp_size_v, false, NULL);\n\nout1:\n\treturn err;\n}\n\n \nstatic int indx_insert_into_root(struct ntfs_index *indx, struct ntfs_inode *ni,\n\t\t\t\t const struct NTFS_DE *new_de,\n\t\t\t\t struct NTFS_DE *root_de, const void *ctx,\n\t\t\t\t struct ntfs_fnd *fnd, bool undo)\n{\n\tint err = 0;\n\tstruct NTFS_DE *e, *e0, *re;\n\tstruct mft_inode *mi;\n\tstruct ATTRIB *attr;\n\tstruct INDEX_HDR *hdr;\n\tstruct indx_node *n;\n\tCLST new_vbn;\n\t__le64 *sub_vbn, t_vbn;\n\tu16 new_de_size;\n\tu32 hdr_used, hdr_total, asize, to_move;\n\tu32 root_size, new_root_size;\n\tstruct ntfs_sb_info *sbi;\n\tint ds_root;\n\tstruct INDEX_ROOT *root, *a_root;\n\n\t \n\troot = indx_get_root(indx, ni, &attr, &mi);\n\tif (!root)\n\t\treturn -EINVAL;\n\n\t \n\thdr = &root->ihdr;\n\tsbi = ni->mi.sbi;\n\tnew_de_size = le16_to_cpu(new_de->size);\n\thdr_used = le32_to_cpu(hdr->used);\n\thdr_total = le32_to_cpu(hdr->total);\n\tasize = le32_to_cpu(attr->size);\n\troot_size = le32_to_cpu(attr->res.data_size);\n\n\tds_root = new_de_size + hdr_used - hdr_total;\n\n\t \n\tif ((undo || asize + ds_root < sbi->max_bytes_per_attr) &&\n\t    mi_resize_attr(mi, attr, ds_root)) {\n\t\thdr->total = cpu_to_le32(hdr_total + ds_root);\n\t\te = hdr_insert_de(indx, hdr, new_de, root_de, ctx);\n\t\tWARN_ON(!e);\n\t\tfnd_clear(fnd);\n\t\tfnd->root_de = e;\n\n\t\treturn 0;\n\t}\n\n\t \n\ta_root = kmemdup(attr, asize, GFP_NOFS);\n\tif (!a_root)\n\t\treturn -ENOMEM;\n\n\t \n\tto_move = 0;\n\te0 = hdr_first_de(hdr);\n\n\t \n\tfor (e = e0;; e = hdr_next_de(hdr, e)) {\n\t\tif (!e) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_free_root;\n\t\t}\n\n\t\tif (de_is_last(e))\n\t\t\tbreak;\n\t\tto_move += le16_to_cpu(e->size);\n\t}\n\n\tif (!to_move) {\n\t\tre = NULL;\n\t} else {\n\t\tre = kmemdup(e0, to_move, GFP_NOFS);\n\t\tif (!re) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_free_root;\n\t\t}\n\t}\n\n\tsub_vbn = NULL;\n\tif (de_has_vcn(e)) {\n\t\tt_vbn = de_get_vbn_le(e);\n\t\tsub_vbn = &t_vbn;\n\t}\n\n\tnew_root_size = sizeof(struct INDEX_ROOT) + sizeof(struct NTFS_DE) +\n\t\t\tsizeof(u64);\n\tds_root = new_root_size - root_size;\n\n\tif (ds_root > 0 && asize + ds_root > sbi->max_bytes_per_attr) {\n\t\t \n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_free_re;\n\t}\n\n\tif (ds_root)\n\t\tmi_resize_attr(mi, attr, ds_root);\n\n\t \n\te = (struct NTFS_DE *)(root + 1);\n\tmemset(e, 0, sizeof(struct NTFS_DE));\n\te->size = cpu_to_le16(sizeof(struct NTFS_DE) + sizeof(u64));\n\te->flags = NTFS_IE_HAS_SUBNODES | NTFS_IE_LAST;\n\n\thdr->flags = 1;\n\thdr->used = hdr->total =\n\t\tcpu_to_le32(new_root_size - offsetof(struct INDEX_ROOT, ihdr));\n\n\tfnd->root_de = hdr_first_de(hdr);\n\tmi->dirty = true;\n\n\t \n\terr = run_is_empty(&indx->alloc_run) ?\n\t\t      indx_create_allocate(indx, ni, &new_vbn) :\n\t\t      indx_add_allocate(indx, ni, &new_vbn);\n\n\t \n\troot = indx_get_root(indx, ni, &attr, &mi);\n\tif (!root) {\n\t\t \n\t\tntfs_set_state(sbi, NTFS_DIRTY_ERROR);\n\t\terr = -EINVAL;\n\t\tgoto out_free_re;\n\t}\n\n\tif (err) {\n\t\t \n\t\tif (mi_resize_attr(mi, attr, -ds_root)) {\n\t\t\tmemcpy(attr, a_root, asize);\n\t\t} else {\n\t\t\t \n\t\t\tntfs_set_state(sbi, NTFS_DIRTY_ERROR);\n\t\t}\n\t\tgoto out_free_re;\n\t}\n\n\te = (struct NTFS_DE *)(root + 1);\n\t*(__le64 *)(e + 1) = cpu_to_le64(new_vbn);\n\tmi->dirty = true;\n\n\t \n\tn = indx_new(indx, ni, new_vbn, sub_vbn);\n\tif (IS_ERR(n)) {\n\t\terr = PTR_ERR(n);\n\t\tgoto out_free_re;\n\t}\n\n\thdr = &n->index->ihdr;\n\thdr_used = le32_to_cpu(hdr->used);\n\thdr_total = le32_to_cpu(hdr->total);\n\n\t \n\thdr_insert_head(hdr, re, to_move);\n\n\t \n\tindx_mark_used(indx, ni, new_vbn >> indx->idx2vbn_bits);\n\n\t \n\tif (hdr_used + new_de_size > hdr_total) {\n\t\t \n\t\tkfree(re);\n\t\tindx_write(indx, ni, n, 0);\n\n\t\tput_indx_node(n);\n\t\tfnd_clear(fnd);\n\t\terr = indx_insert_entry(indx, ni, new_de, ctx, fnd, undo);\n\t\tgoto out_free_root;\n\t}\n\n\t \n\te = hdr_insert_de(indx, hdr, new_de, NULL, ctx);\n\tif (!e) {\n\t\terr = -EINVAL;\n\t\tgoto out_put_n;\n\t}\n\tfnd_push(fnd, n, e);\n\n\t \n\tindx_write(indx, ni, n, 0);\n\n\tn = NULL;\n\nout_put_n:\n\tput_indx_node(n);\nout_free_re:\n\tkfree(re);\nout_free_root:\n\tkfree(a_root);\n\treturn err;\n}\n\n \nstatic int\nindx_insert_into_buffer(struct ntfs_index *indx, struct ntfs_inode *ni,\n\t\t\tstruct INDEX_ROOT *root, const struct NTFS_DE *new_de,\n\t\t\tconst void *ctx, int level, struct ntfs_fnd *fnd)\n{\n\tint err;\n\tconst struct NTFS_DE *sp;\n\tstruct NTFS_DE *e, *de_t, *up_e;\n\tstruct indx_node *n2;\n\tstruct indx_node *n1 = fnd->nodes[level];\n\tstruct INDEX_HDR *hdr1 = &n1->index->ihdr;\n\tstruct INDEX_HDR *hdr2;\n\tu32 to_copy, used, used1;\n\tCLST new_vbn;\n\t__le64 t_vbn, *sub_vbn;\n\tu16 sp_size;\n\tvoid *hdr1_saved = NULL;\n\n\t \n\te = fnd->level - 1 == level ? fnd->de[level] : NULL;\n\te = hdr_insert_de(indx, hdr1, new_de, e, ctx);\n\tfnd->de[level] = e;\n\tif (e) {\n\t\t \n\t\tindx_write(indx, ni, n1, 0);\n\t\treturn 0;\n\t}\n\n\t \n\tsp = hdr_find_split(hdr1);\n\tif (!sp)\n\t\treturn -EINVAL;\n\n\tsp_size = le16_to_cpu(sp->size);\n\tup_e = kmalloc(sp_size + sizeof(u64), GFP_NOFS);\n\tif (!up_e)\n\t\treturn -ENOMEM;\n\tmemcpy(up_e, sp, sp_size);\n\n\tused1 = le32_to_cpu(hdr1->used);\n\thdr1_saved = kmemdup(hdr1, used1, GFP_NOFS);\n\tif (!hdr1_saved) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (!hdr1->flags) {\n\t\tup_e->flags |= NTFS_IE_HAS_SUBNODES;\n\t\tup_e->size = cpu_to_le16(sp_size + sizeof(u64));\n\t\tsub_vbn = NULL;\n\t} else {\n\t\tt_vbn = de_get_vbn_le(up_e);\n\t\tsub_vbn = &t_vbn;\n\t}\n\n\t \n\terr = indx_add_allocate(indx, ni, &new_vbn);\n\tif (err)\n\t\tgoto out;\n\n\t \n\tn2 = indx_new(indx, ni, new_vbn, sub_vbn);\n\tif (IS_ERR(n2)) {\n\t\terr = PTR_ERR(n2);\n\t\tgoto out;\n\t}\n\n\thdr2 = &n2->index->ihdr;\n\n\t \n\tde_set_vbn(up_e, new_vbn);\n\n\t \n\tde_t = hdr_first_de(hdr1);\n\tto_copy = PtrOffset(de_t, sp);\n\thdr_insert_head(hdr2, de_t, to_copy);\n\n\t \n\tused = used1 - to_copy - sp_size;\n\tmemmove(de_t, Add2Ptr(sp, sp_size), used - le32_to_cpu(hdr1->de_off));\n\thdr1->used = cpu_to_le32(used);\n\n\t \n\thdr_insert_de(indx,\n\t\t      (*indx->cmp)(new_de + 1, le16_to_cpu(new_de->key_size),\n\t\t\t\t   up_e + 1, le16_to_cpu(up_e->key_size),\n\t\t\t\t   ctx) < 0 ?\n\t\t\t      hdr2 :\n\t\t\t      hdr1,\n\t\t      new_de, NULL, ctx);\n\n\tindx_mark_used(indx, ni, new_vbn >> indx->idx2vbn_bits);\n\n\tindx_write(indx, ni, n1, 0);\n\tindx_write(indx, ni, n2, 0);\n\n\tput_indx_node(n2);\n\n\t \n\tif (!level) {\n\t\t \n\t\terr = indx_insert_into_root(indx, ni, up_e, NULL, ctx, fnd, 0);\n\t} else {\n\t\t \n\t\terr = indx_insert_into_buffer(indx, ni, root, up_e, ctx,\n\t\t\t\t\t      level - 1, fnd);\n\t}\n\n\tif (err) {\n\t\t \n\t\tindx_mark_free(indx, ni, new_vbn >> indx->idx2vbn_bits);\n\t\tmemcpy(hdr1, hdr1_saved, used1);\n\t\tindx_write(indx, ni, n1, 0);\n\t}\n\nout:\n\tkfree(up_e);\n\tkfree(hdr1_saved);\n\n\treturn err;\n}\n\n \nint indx_insert_entry(struct ntfs_index *indx, struct ntfs_inode *ni,\n\t\t      const struct NTFS_DE *new_de, const void *ctx,\n\t\t      struct ntfs_fnd *fnd, bool undo)\n{\n\tint err;\n\tint diff;\n\tstruct NTFS_DE *e;\n\tstruct ntfs_fnd *fnd_a = NULL;\n\tstruct INDEX_ROOT *root;\n\n\tif (!fnd) {\n\t\tfnd_a = fnd_get();\n\t\tif (!fnd_a) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out1;\n\t\t}\n\t\tfnd = fnd_a;\n\t}\n\n\troot = indx_get_root(indx, ni, NULL, NULL);\n\tif (!root) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (fnd_is_empty(fnd)) {\n\t\t \n\t\terr = indx_find(indx, ni, root, new_de + 1,\n\t\t\t\tle16_to_cpu(new_de->key_size), ctx, &diff, &e,\n\t\t\t\tfnd);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tif (!diff) {\n\t\t\terr = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!fnd->level) {\n\t\t \n\t\terr = indx_insert_into_root(indx, ni, new_de, fnd->root_de, ctx,\n\t\t\t\t\t    fnd, undo);\n\t} else {\n\t\t \n\t\terr = indx_insert_into_buffer(indx, ni, root, new_de, ctx,\n\t\t\t\t\t      fnd->level - 1, fnd);\n\t}\n\nout:\n\tfnd_put(fnd_a);\nout1:\n\treturn err;\n}\n\n \nstatic struct indx_node *indx_find_buffer(struct ntfs_index *indx,\n\t\t\t\t\t  struct ntfs_inode *ni,\n\t\t\t\t\t  const struct INDEX_ROOT *root,\n\t\t\t\t\t  __le64 vbn, struct indx_node *n)\n{\n\tint err;\n\tconst struct NTFS_DE *e;\n\tstruct indx_node *r;\n\tconst struct INDEX_HDR *hdr = n ? &n->index->ihdr : &root->ihdr;\n\n\t \n\tfor (e = hdr_first_de(hdr);; e = hdr_next_de(hdr, e)) {\n\t\tif (!e)\n\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\tif (de_has_vcn(e) && vbn == de_get_vbn_le(e))\n\t\t\treturn n;\n\n\t\tif (de_is_last(e))\n\t\t\tbreak;\n\t}\n\n\t \n\te = Add2Ptr(hdr, le32_to_cpu(hdr->de_off));\n\tfor (;;) {\n\t\tif (de_has_vcn_ex(e)) {\n\t\t\terr = indx_read(indx, ni, de_get_vbn(e), &n);\n\t\t\tif (err)\n\t\t\t\treturn ERR_PTR(err);\n\n\t\t\tr = indx_find_buffer(indx, ni, root, vbn, n);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t}\n\n\t\tif (de_is_last(e))\n\t\t\tbreak;\n\n\t\te = Add2Ptr(e, le16_to_cpu(e->size));\n\t}\n\n\treturn NULL;\n}\n\n \nstatic int indx_shrink(struct ntfs_index *indx, struct ntfs_inode *ni,\n\t\t       size_t bit)\n{\n\tint err = 0;\n\tu64 bpb, new_data;\n\tsize_t nbits;\n\tstruct ATTRIB *b;\n\tstruct ATTR_LIST_ENTRY *le = NULL;\n\tconst struct INDEX_NAMES *in = &s_index_names[indx->type];\n\n\tb = ni_find_attr(ni, NULL, &le, ATTR_BITMAP, in->name, in->name_len,\n\t\t\t NULL, NULL);\n\n\tif (!b)\n\t\treturn -ENOENT;\n\n\tif (!b->non_res) {\n\t\tunsigned long pos;\n\t\tconst unsigned long *bm = resident_data(b);\n\n\t\tnbits = (size_t)le32_to_cpu(b->res.data_size) * 8;\n\n\t\tif (bit >= nbits)\n\t\t\treturn 0;\n\n\t\tpos = find_next_bit_le(bm, nbits, bit);\n\t\tif (pos < nbits)\n\t\t\treturn 0;\n\t} else {\n\t\tsize_t used = MINUS_ONE_T;\n\n\t\tnbits = le64_to_cpu(b->nres.data_size) * 8;\n\n\t\tif (bit >= nbits)\n\t\t\treturn 0;\n\n\t\terr = scan_nres_bitmap(ni, b, indx, bit, &scan_for_used, &used);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (used != MINUS_ONE_T)\n\t\t\treturn 0;\n\t}\n\n\tnew_data = (u64)bit << indx->index_bits;\n\n\terr = attr_set_size(ni, ATTR_ALLOC, in->name, in->name_len,\n\t\t\t    &indx->alloc_run, new_data, &new_data, false, NULL);\n\tif (err)\n\t\treturn err;\n\n\tif (in->name == I30_NAME)\n\t\tni->vfs_inode.i_size = new_data;\n\n\tbpb = bitmap_size(bit);\n\tif (bpb * 8 == nbits)\n\t\treturn 0;\n\n\terr = attr_set_size(ni, ATTR_BITMAP, in->name, in->name_len,\n\t\t\t    &indx->bitmap_run, bpb, &bpb, false, NULL);\n\n\treturn err;\n}\n\nstatic int indx_free_children(struct ntfs_index *indx, struct ntfs_inode *ni,\n\t\t\t      const struct NTFS_DE *e, bool trim)\n{\n\tint err;\n\tstruct indx_node *n = NULL;\n\tstruct INDEX_HDR *hdr;\n\tCLST vbn = de_get_vbn(e);\n\tsize_t i;\n\n\terr = indx_read(indx, ni, vbn, &n);\n\tif (err)\n\t\treturn err;\n\n\thdr = &n->index->ihdr;\n\t \n\tif (hdr_has_subnode(hdr)) {\n\t\tfor (e = hdr_first_de(hdr); e; e = hdr_next_de(hdr, e)) {\n\t\t\tindx_free_children(indx, ni, e, false);\n\t\t\tif (de_is_last(e))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tput_indx_node(n);\n\n\ti = vbn >> indx->idx2vbn_bits;\n\t \n\tindx_mark_free(indx, ni, i);\n\n\tif (!trim)\n\t\treturn 0;\n\n\t \n\tindx_shrink(indx, ni, i + 1);\n\treturn 0;\n}\n\n \nstatic int indx_get_entry_to_replace(struct ntfs_index *indx,\n\t\t\t\t     struct ntfs_inode *ni,\n\t\t\t\t     const struct NTFS_DE *de_next,\n\t\t\t\t     struct NTFS_DE **de_to_replace,\n\t\t\t\t     struct ntfs_fnd *fnd)\n{\n\tint err;\n\tint level = -1;\n\tCLST vbn;\n\tstruct NTFS_DE *e, *te, *re;\n\tstruct indx_node *n;\n\tstruct INDEX_BUFFER *ib;\n\n\t*de_to_replace = NULL;\n\n\t \n\tvbn = de_get_vbn(de_next);\n\tfor (;;) {\n\t\tn = NULL;\n\t\terr = indx_read(indx, ni, vbn, &n);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\te = hdr_first_de(&n->index->ihdr);\n\t\tfnd_push(fnd, n, e);\n\n\t\tif (!de_is_last(e)) {\n\t\t\t \n\t\t\tlevel = fnd->level - 1;\n\t\t}\n\n\t\tif (!de_has_vcn(e))\n\t\t\tbreak;\n\n\t\t \n\t\tvbn = de_get_vbn(e);\n\t}\n\n\tif (level == -1)\n\t\tgoto out;\n\n\tn = fnd->nodes[level];\n\tte = hdr_first_de(&n->index->ihdr);\n\t \n\tre = kmalloc(le16_to_cpu(te->size) + sizeof(u64), GFP_NOFS);\n\tif (!re) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t*de_to_replace = re;\n\tmemcpy(re, te, le16_to_cpu(te->size));\n\n\tif (!de_has_vcn(re)) {\n\t\t \n\t\tle16_add_cpu(&re->size, sizeof(u64));\n\t\tre->flags |= NTFS_IE_HAS_SUBNODES;\n\t} else {\n\t\t \n\t\tindx_free_children(indx, ni, te, true);\n\t}\n\n\t \n\tib = n->index;\n\te = hdr_delete_de(&ib->ihdr, te);\n\n\tfnd->de[level] = e;\n\tindx_write(indx, ni, n, 0);\n\n\tif (ib_is_leaf(ib) && ib_is_empty(ib)) {\n\t\t \n\t\treturn 0;\n\t}\n\nout:\n\tfnd_clear(fnd);\n\treturn err;\n}\n\n \nint indx_delete_entry(struct ntfs_index *indx, struct ntfs_inode *ni,\n\t\t      const void *key, u32 key_len, const void *ctx)\n{\n\tint err, diff;\n\tstruct INDEX_ROOT *root;\n\tstruct INDEX_HDR *hdr;\n\tstruct ntfs_fnd *fnd, *fnd2;\n\tstruct INDEX_BUFFER *ib;\n\tstruct NTFS_DE *e, *re, *next, *prev, *me;\n\tstruct indx_node *n, *n2d = NULL;\n\t__le64 sub_vbn;\n\tint level, level2;\n\tstruct ATTRIB *attr;\n\tstruct mft_inode *mi;\n\tu32 e_size, root_size, new_root_size;\n\tsize_t trim_bit;\n\tconst struct INDEX_NAMES *in;\n\n\tfnd = fnd_get();\n\tif (!fnd) {\n\t\terr = -ENOMEM;\n\t\tgoto out2;\n\t}\n\n\tfnd2 = fnd_get();\n\tif (!fnd2) {\n\t\terr = -ENOMEM;\n\t\tgoto out1;\n\t}\n\n\troot = indx_get_root(indx, ni, &attr, &mi);\n\tif (!root) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\terr = indx_find(indx, ni, root, key, key_len, ctx, &diff, &e, fnd);\n\tif (err)\n\t\tgoto out;\n\n\tif (!e || diff) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tlevel = fnd->level;\n\n\tif (level) {\n\t\tn = fnd->nodes[level - 1];\n\t\te = fnd->de[level - 1];\n\t\tib = n->index;\n\t\thdr = &ib->ihdr;\n\t} else {\n\t\thdr = &root->ihdr;\n\t\te = fnd->root_de;\n\t\tn = NULL;\n\t}\n\n\te_size = le16_to_cpu(e->size);\n\n\tif (!de_has_vcn_ex(e)) {\n\t\t \n\t\thdr_delete_de(hdr, e);\n\n\t\tif (!level) {\n\t\t\thdr->total = hdr->used;\n\n\t\t\t \n\t\t\tmi_resize_attr(mi, attr, 0 - e_size);\n\t\t\tgoto out;\n\t\t}\n\n\t\tindx_write(indx, ni, n, 0);\n\n\t\t \n\t\tif (ib_is_leaf(ib) && ib_is_empty(ib)) {\n\t\t\tfnd_pop(fnd);\n\t\t\tfnd_push(fnd2, n, e);\n\t\t}\n\t} else {\n\t\t \n\t\tnext = de_get_next(e);\n\n\t\terr = indx_get_entry_to_replace(indx, ni, next, &re, fnd2);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tif (re) {\n\t\t\tde_set_vbn_le(re, de_get_vbn_le(e));\n\t\t\thdr_delete_de(hdr, e);\n\n\t\t\terr = level ? indx_insert_into_buffer(indx, ni, root,\n\t\t\t\t\t\t\t      re, ctx,\n\t\t\t\t\t\t\t      fnd->level - 1,\n\t\t\t\t\t\t\t      fnd) :\n\t\t\t\t      indx_insert_into_root(indx, ni, re, e,\n\t\t\t\t\t\t\t    ctx, fnd, 0);\n\t\t\tkfree(re);\n\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\t \n\t\t\tindx_free_children(indx, ni, next, true);\n\n\t\t\tde_set_vbn_le(next, de_get_vbn_le(e));\n\t\t\thdr_delete_de(hdr, e);\n\t\t\tif (level) {\n\t\t\t\tindx_write(indx, ni, n, 0);\n\t\t\t} else {\n\t\t\t\thdr->total = hdr->used;\n\n\t\t\t\t \n\t\t\t\tmi_resize_attr(mi, attr, 0 - e_size);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (!fnd2 || !fnd2->level)\n\t\tgoto out;\n\n\t \n\troot = indx_get_root(indx, ni, &attr, &mi);\n\tif (!root) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tn2d = NULL;\n\tsub_vbn = fnd2->nodes[0]->index->vbn;\n\tlevel2 = 0;\n\tlevel = fnd->level;\n\n\thdr = level ? &fnd->nodes[level - 1]->index->ihdr : &root->ihdr;\n\n\t \n\tfor (e = hdr_first_de(hdr);; e = hdr_next_de(hdr, e)) {\n\t\tif (!e) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (de_has_vcn(e) && sub_vbn == de_get_vbn_le(e))\n\t\t\tbreak;\n\n\t\tif (de_is_last(e)) {\n\t\t\te = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!e) {\n\t\t \n\t\tstruct indx_node *in;\n\n\t\tfnd_clear(fnd);\n\n\t\tin = indx_find_buffer(indx, ni, root, sub_vbn, NULL);\n\t\tif (IS_ERR(in)) {\n\t\t\terr = PTR_ERR(in);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (in)\n\t\t\tfnd_push(fnd, in, NULL);\n\t}\n\n\t \n\tfor (level = 0; level < fnd2->level; level++) {\n\t\tfnd_push(fnd, fnd2->nodes[level], fnd2->de[level]);\n\t\tfnd2->nodes[level] = NULL;\n\t}\n\tfnd2->level = 0;\n\n\thdr = NULL;\n\tfor (level = fnd->level; level; level--) {\n\t\tstruct indx_node *in = fnd->nodes[level - 1];\n\n\t\tib = in->index;\n\t\tif (ib_is_empty(ib)) {\n\t\t\tsub_vbn = ib->vbn;\n\t\t} else {\n\t\t\thdr = &ib->ihdr;\n\t\t\tn2d = in;\n\t\t\tlevel2 = level;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!hdr)\n\t\thdr = &root->ihdr;\n\n\te = hdr_first_de(hdr);\n\tif (!e) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (hdr != &root->ihdr || !de_is_last(e)) {\n\t\tprev = NULL;\n\t\twhile (!de_is_last(e)) {\n\t\t\tif (de_has_vcn(e) && sub_vbn == de_get_vbn_le(e))\n\t\t\t\tbreak;\n\t\t\tprev = e;\n\t\t\te = hdr_next_de(hdr, e);\n\t\t\tif (!e) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (sub_vbn != de_get_vbn_le(e)) {\n\t\t\t \n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (de_is_last(e)) {\n\t\t\t \n\t\t\tif (!prev) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (de_has_vcn(prev)) {\n\t\t\t\tde_set_vbn_le(e, de_get_vbn_le(prev));\n\t\t\t} else if (de_has_vcn(e)) {\n\t\t\t\tle16_sub_cpu(&e->size, sizeof(u64));\n\t\t\t\te->flags &= ~NTFS_IE_HAS_SUBNODES;\n\t\t\t\tle32_sub_cpu(&hdr->used, sizeof(u64));\n\t\t\t}\n\t\t\te = prev;\n\t\t}\n\n\t\t \n\t\te_size = le16_to_cpu(e->size);\n\t\tme = kmemdup(e, e_size, GFP_NOFS);\n\t\tif (!me) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (de_has_vcn(me)) {\n\t\t\tme->flags &= ~NTFS_IE_HAS_SUBNODES;\n\t\t\tle16_sub_cpu(&me->size, sizeof(u64));\n\t\t}\n\n\t\thdr_delete_de(hdr, e);\n\n\t\tif (hdr == &root->ihdr) {\n\t\t\tlevel = 0;\n\t\t\thdr->total = hdr->used;\n\n\t\t\t \n\t\t\tmi_resize_attr(mi, attr, 0 - e_size);\n\t\t} else {\n\t\t\tindx_write(indx, ni, n2d, 0);\n\t\t\tlevel = level2;\n\t\t}\n\n\t\t \n\t\ttrim_bit = -1;\n\t\tfor (; level < fnd->level; level++) {\n\t\t\tib = fnd->nodes[level]->index;\n\t\t\tif (ib_is_empty(ib)) {\n\t\t\t\tsize_t k = le64_to_cpu(ib->vbn) >>\n\t\t\t\t\t   indx->idx2vbn_bits;\n\n\t\t\t\tindx_mark_free(indx, ni, k);\n\t\t\t\tif (k < trim_bit)\n\t\t\t\t\ttrim_bit = k;\n\t\t\t}\n\t\t}\n\n\t\tfnd_clear(fnd);\n\t\t \n\n\t\t \n\t\terr = indx_insert_entry(indx, ni, me, ctx, fnd, 0);\n\t\tkfree(me);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tif (trim_bit != -1)\n\t\t\tindx_shrink(indx, ni, trim_bit);\n\t} else {\n\t\t \n\t\tfnd_clear(fnd);\n\t\tfnd_clear(fnd2);\n\n\t\tin = &s_index_names[indx->type];\n\n\t\terr = attr_set_size(ni, ATTR_ALLOC, in->name, in->name_len,\n\t\t\t\t    &indx->alloc_run, 0, NULL, false, NULL);\n\t\tif (in->name == I30_NAME)\n\t\t\tni->vfs_inode.i_size = 0;\n\n\t\terr = ni_remove_attr(ni, ATTR_ALLOC, in->name, in->name_len,\n\t\t\t\t     false, NULL);\n\t\trun_close(&indx->alloc_run);\n\n\t\terr = attr_set_size(ni, ATTR_BITMAP, in->name, in->name_len,\n\t\t\t\t    &indx->bitmap_run, 0, NULL, false, NULL);\n\t\terr = ni_remove_attr(ni, ATTR_BITMAP, in->name, in->name_len,\n\t\t\t\t     false, NULL);\n\t\trun_close(&indx->bitmap_run);\n\n\t\troot = indx_get_root(indx, ni, &attr, &mi);\n\t\tif (!root) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\troot_size = le32_to_cpu(attr->res.data_size);\n\t\tnew_root_size =\n\t\t\tsizeof(struct INDEX_ROOT) + sizeof(struct NTFS_DE);\n\n\t\tif (new_root_size != root_size &&\n\t\t    !mi_resize_attr(mi, attr, new_root_size - root_size)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\te = (struct NTFS_DE *)(root + 1);\n\t\te->ref.low = 0;\n\t\te->ref.high = 0;\n\t\te->ref.seq = 0;\n\t\te->size = cpu_to_le16(sizeof(struct NTFS_DE));\n\t\te->flags = NTFS_IE_LAST; \n\t\te->key_size = 0;\n\t\te->res = 0;\n\n\t\thdr = &root->ihdr;\n\t\thdr->flags = 0;\n\t\thdr->used = hdr->total = cpu_to_le32(\n\t\t\tnew_root_size - offsetof(struct INDEX_ROOT, ihdr));\n\t\tmi->dirty = true;\n\t}\n\nout:\n\tfnd_put(fnd2);\nout1:\n\tfnd_put(fnd);\nout2:\n\treturn err;\n}\n\n \nint indx_update_dup(struct ntfs_inode *ni, struct ntfs_sb_info *sbi,\n\t\t    const struct ATTR_FILE_NAME *fname,\n\t\t    const struct NTFS_DUP_INFO *dup, int sync)\n{\n\tint err, diff;\n\tstruct NTFS_DE *e = NULL;\n\tstruct ATTR_FILE_NAME *e_fname;\n\tstruct ntfs_fnd *fnd;\n\tstruct INDEX_ROOT *root;\n\tstruct mft_inode *mi;\n\tstruct ntfs_index *indx = &ni->dir;\n\n\tfnd = fnd_get();\n\tif (!fnd)\n\t\treturn -ENOMEM;\n\n\troot = indx_get_root(indx, ni, NULL, &mi);\n\tif (!root) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\terr = indx_find(indx, ni, root, fname, fname_full_size(fname), sbi,\n\t\t\t&diff, &e, fnd);\n\tif (err)\n\t\tgoto out;\n\n\tif (!e) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (diff) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\te_fname = (struct ATTR_FILE_NAME *)(e + 1);\n\n\tif (!memcmp(&e_fname->dup, dup, sizeof(*dup))) {\n\t\t \n\t\tgoto out;\n\t}\n\n\tmemcpy(&e_fname->dup, dup, sizeof(*dup));\n\n\tif (fnd->level) {\n\t\t \n\t\terr = indx_write(indx, ni, fnd->nodes[fnd->level - 1], sync);\n\t} else {\n\t\t \n\t\tmi->dirty = true;\n\t\tif (sync)\n\t\t\terr = mi_write(mi, 1);\n\t\telse\n\t\t\tmark_inode_dirty(&ni->vfs_inode);\n\t}\n\nout:\n\tfnd_put(fnd);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}