{
  "module_name": "super.c",
  "hash_id": "c98a4a80419eec821fc1d55c64b946112176960314a69aefdfd0465462fb388d",
  "original_prompt": "Ingested from linux-6.6.14/fs/ntfs3/super.c",
  "human_readable_source": "\n \n\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/exportfs.h>\n#include <linux/fs.h>\n#include <linux/fs_context.h>\n#include <linux/fs_parser.h>\n#include <linux/log2.h>\n#include <linux/minmax.h>\n#include <linux/module.h>\n#include <linux/nls.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n\n#include \"debug.h\"\n#include \"ntfs.h\"\n#include \"ntfs_fs.h\"\n#ifdef CONFIG_NTFS3_LZX_XPRESS\n#include \"lib/lib.h\"\n#endif\n\n#ifdef CONFIG_PRINTK\n \nvoid ntfs_printk(const struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint level;\n\tstruct ntfs_sb_info *sbi = sb->s_fs_info;\n\n\t \n\tif (!___ratelimit(&sbi->msg_ratelimit, \"ntfs3\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\n\tlevel = printk_get_level(fmt);\n\tvaf.fmt = printk_skip_level(fmt);\n\tvaf.va = &args;\n\tprintk(\"%c%cntfs3: %s: %pV\\n\", KERN_SOH_ASCII, level, sb->s_id, &vaf);\n\n\tva_end(args);\n}\n\nstatic char s_name_buf[512];\nstatic atomic_t s_name_buf_cnt = ATOMIC_INIT(1); \n\n \nvoid ntfs_inode_printk(struct inode *inode, const char *fmt, ...)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ntfs_sb_info *sbi = sb->s_fs_info;\n\tchar *name;\n\tva_list args;\n\tstruct va_format vaf;\n\tint level;\n\n\tif (!___ratelimit(&sbi->msg_ratelimit, \"ntfs3\"))\n\t\treturn;\n\n\t \n\tname = atomic_dec_and_test(&s_name_buf_cnt) ?\n\t\t       s_name_buf :\n\t\t       kmalloc(sizeof(s_name_buf), GFP_NOFS);\n\n\tif (name) {\n\t\tstruct dentry *de = d_find_alias(inode);\n\t\tconst u32 name_len = ARRAY_SIZE(s_name_buf) - 1;\n\n\t\tif (de) {\n\t\t\tspin_lock(&de->d_lock);\n\t\t\tsnprintf(name, name_len, \" \\\"%s\\\"\", de->d_name.name);\n\t\t\tspin_unlock(&de->d_lock);\n\t\t\tname[name_len] = 0;  \n\t\t} else {\n\t\t\tname[0] = 0;\n\t\t}\n\t\tdput(de);  \n\t}\n\n\tva_start(args, fmt);\n\n\tlevel = printk_get_level(fmt);\n\tvaf.fmt = printk_skip_level(fmt);\n\tvaf.va = &args;\n\n\tprintk(\"%c%cntfs3: %s: ino=%lx,%s %pV\\n\", KERN_SOH_ASCII, level,\n\t       sb->s_id, inode->i_ino, name ? name : \"\", &vaf);\n\n\tva_end(args);\n\n\tatomic_inc(&s_name_buf_cnt);\n\tif (name != s_name_buf)\n\t\tkfree(name);\n}\n#endif\n\n \nstatic DEFINE_SPINLOCK(s_shared_lock);\n\nstatic struct {\n\tvoid *ptr;\n\tu32 len;\n\tint cnt;\n} s_shared[8];\n\n \nvoid *ntfs_set_shared(void *ptr, u32 bytes)\n{\n\tvoid *ret = NULL;\n\tint i, j = -1;\n\n\tspin_lock(&s_shared_lock);\n\tfor (i = 0; i < ARRAY_SIZE(s_shared); i++) {\n\t\tif (!s_shared[i].cnt) {\n\t\t\tj = i;\n\t\t} else if (bytes == s_shared[i].len &&\n\t\t\t   !memcmp(s_shared[i].ptr, ptr, bytes)) {\n\t\t\ts_shared[i].cnt += 1;\n\t\t\tret = s_shared[i].ptr;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!ret && j != -1) {\n\t\ts_shared[j].ptr = ptr;\n\t\ts_shared[j].len = bytes;\n\t\ts_shared[j].cnt = 1;\n\t\tret = ptr;\n\t}\n\tspin_unlock(&s_shared_lock);\n\n\treturn ret;\n}\n\n \nvoid *ntfs_put_shared(void *ptr)\n{\n\tvoid *ret = ptr;\n\tint i;\n\n\tspin_lock(&s_shared_lock);\n\tfor (i = 0; i < ARRAY_SIZE(s_shared); i++) {\n\t\tif (s_shared[i].cnt && s_shared[i].ptr == ptr) {\n\t\t\tif (--s_shared[i].cnt)\n\t\t\t\tret = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&s_shared_lock);\n\n\treturn ret;\n}\n\nstatic inline void put_mount_options(struct ntfs_mount_options *options)\n{\n\tkfree(options->nls_name);\n\tunload_nls(options->nls);\n\tkfree(options);\n}\n\nenum Opt {\n\tOpt_uid,\n\tOpt_gid,\n\tOpt_umask,\n\tOpt_dmask,\n\tOpt_fmask,\n\tOpt_immutable,\n\tOpt_discard,\n\tOpt_force,\n\tOpt_sparse,\n\tOpt_nohidden,\n\tOpt_hide_dot_files,\n\tOpt_windows_names,\n\tOpt_showmeta,\n\tOpt_acl,\n\tOpt_iocharset,\n\tOpt_prealloc,\n\tOpt_nocase,\n\tOpt_err,\n};\n\n \nstatic const struct fs_parameter_spec ntfs_fs_parameters[] = {\n\tfsparam_u32(\"uid\",\t\t\tOpt_uid),\n\tfsparam_u32(\"gid\",\t\t\tOpt_gid),\n\tfsparam_u32oct(\"umask\",\t\t\tOpt_umask),\n\tfsparam_u32oct(\"dmask\",\t\t\tOpt_dmask),\n\tfsparam_u32oct(\"fmask\",\t\t\tOpt_fmask),\n\tfsparam_flag_no(\"sys_immutable\",\tOpt_immutable),\n\tfsparam_flag_no(\"discard\",\t\tOpt_discard),\n\tfsparam_flag_no(\"force\",\t\tOpt_force),\n\tfsparam_flag_no(\"sparse\",\t\tOpt_sparse),\n\tfsparam_flag_no(\"hidden\",\t\tOpt_nohidden),\n\tfsparam_flag_no(\"hide_dot_files\",\tOpt_hide_dot_files),\n\tfsparam_flag_no(\"windows_names\",\tOpt_windows_names),\n\tfsparam_flag_no(\"showmeta\",\t\tOpt_showmeta),\n\tfsparam_flag_no(\"acl\",\t\t\tOpt_acl),\n\tfsparam_string(\"iocharset\",\t\tOpt_iocharset),\n\tfsparam_flag_no(\"prealloc\",\t\tOpt_prealloc),\n\tfsparam_flag_no(\"nocase\",\t\tOpt_nocase),\n\t{}\n};\n \n\n \nstatic struct nls_table *ntfs_load_nls(char *nls)\n{\n\tstruct nls_table *ret;\n\n\tif (!nls)\n\t\tnls = CONFIG_NLS_DEFAULT;\n\n\tif (strcmp(nls, \"utf8\") == 0)\n\t\treturn NULL;\n\n\tif (strcmp(nls, CONFIG_NLS_DEFAULT) == 0)\n\t\treturn load_nls_default();\n\n\tret = load_nls(nls);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic int ntfs_fs_parse_param(struct fs_context *fc,\n\t\t\t       struct fs_parameter *param)\n{\n\tstruct ntfs_mount_options *opts = fc->fs_private;\n\tstruct fs_parse_result result;\n\tint opt;\n\n\topt = fs_parse(fc, ntfs_fs_parameters, param, &result);\n\tif (opt < 0)\n\t\treturn opt;\n\n\tswitch (opt) {\n\tcase Opt_uid:\n\t\topts->fs_uid = make_kuid(current_user_ns(), result.uint_32);\n\t\tif (!uid_valid(opts->fs_uid))\n\t\t\treturn invalf(fc, \"ntfs3: Invalid value for uid.\");\n\t\tbreak;\n\tcase Opt_gid:\n\t\topts->fs_gid = make_kgid(current_user_ns(), result.uint_32);\n\t\tif (!gid_valid(opts->fs_gid))\n\t\t\treturn invalf(fc, \"ntfs3: Invalid value for gid.\");\n\t\tbreak;\n\tcase Opt_umask:\n\t\tif (result.uint_32 & ~07777)\n\t\t\treturn invalf(fc, \"ntfs3: Invalid value for umask.\");\n\t\topts->fs_fmask_inv = ~result.uint_32;\n\t\topts->fs_dmask_inv = ~result.uint_32;\n\t\topts->fmask = 1;\n\t\topts->dmask = 1;\n\t\tbreak;\n\tcase Opt_dmask:\n\t\tif (result.uint_32 & ~07777)\n\t\t\treturn invalf(fc, \"ntfs3: Invalid value for dmask.\");\n\t\topts->fs_dmask_inv = ~result.uint_32;\n\t\topts->dmask = 1;\n\t\tbreak;\n\tcase Opt_fmask:\n\t\tif (result.uint_32 & ~07777)\n\t\t\treturn invalf(fc, \"ntfs3: Invalid value for fmask.\");\n\t\topts->fs_fmask_inv = ~result.uint_32;\n\t\topts->fmask = 1;\n\t\tbreak;\n\tcase Opt_immutable:\n\t\topts->sys_immutable = result.negated ? 0 : 1;\n\t\tbreak;\n\tcase Opt_discard:\n\t\topts->discard = result.negated ? 0 : 1;\n\t\tbreak;\n\tcase Opt_force:\n\t\topts->force = result.negated ? 0 : 1;\n\t\tbreak;\n\tcase Opt_sparse:\n\t\topts->sparse = result.negated ? 0 : 1;\n\t\tbreak;\n\tcase Opt_nohidden:\n\t\topts->nohidden = result.negated ? 1 : 0;\n\t\tbreak;\n\tcase Opt_hide_dot_files:\n\t\topts->hide_dot_files = result.negated ? 0 : 1;\n\t\tbreak;\n\tcase Opt_windows_names:\n\t\topts->windows_names = result.negated ? 0 : 1;\n\t\tbreak;\n\tcase Opt_showmeta:\n\t\topts->showmeta = result.negated ? 0 : 1;\n\t\tbreak;\n\tcase Opt_acl:\n\t\tif (!result.negated)\n#ifdef CONFIG_NTFS3_FS_POSIX_ACL\n\t\t\tfc->sb_flags |= SB_POSIXACL;\n#else\n\t\t\treturn invalf(\n\t\t\t\tfc, \"ntfs3: Support for ACL not compiled in!\");\n#endif\n\t\telse\n\t\t\tfc->sb_flags &= ~SB_POSIXACL;\n\t\tbreak;\n\tcase Opt_iocharset:\n\t\tkfree(opts->nls_name);\n\t\topts->nls_name = param->string;\n\t\tparam->string = NULL;\n\t\tbreak;\n\tcase Opt_prealloc:\n\t\topts->prealloc = result.negated ? 0 : 1;\n\t\tbreak;\n\tcase Opt_nocase:\n\t\topts->nocase = result.negated ? 1 : 0;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int ntfs_fs_reconfigure(struct fs_context *fc)\n{\n\tstruct super_block *sb = fc->root->d_sb;\n\tstruct ntfs_sb_info *sbi = sb->s_fs_info;\n\tstruct ntfs_mount_options *new_opts = fc->fs_private;\n\tint ro_rw;\n\n\tro_rw = sb_rdonly(sb) && !(fc->sb_flags & SB_RDONLY);\n\tif (ro_rw && (sbi->flags & NTFS_FLAGS_NEED_REPLAY)) {\n\t\terrorf(fc,\n\t\t       \"ntfs3: Couldn't remount rw because journal is not replayed. Please umount/remount instead\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tnew_opts->nls = ntfs_load_nls(new_opts->nls_name);\n\tif (IS_ERR(new_opts->nls)) {\n\t\tnew_opts->nls = NULL;\n\t\terrorf(fc, \"ntfs3: Cannot load iocharset %s\",\n\t\t       new_opts->nls_name);\n\t\treturn -EINVAL;\n\t}\n\tif (new_opts->nls != sbi->options->nls)\n\t\treturn invalf(\n\t\t\tfc,\n\t\t\t\"ntfs3: Cannot use different iocharset when remounting!\");\n\n\tsync_filesystem(sb);\n\n\tif (ro_rw && (sbi->volume.flags & VOLUME_FLAG_DIRTY) &&\n\t    !new_opts->force) {\n\t\terrorf(fc,\n\t\t       \"ntfs3: Volume is dirty and \\\"force\\\" flag is not set!\");\n\t\treturn -EINVAL;\n\t}\n\n\tswap(sbi->options, fc->fs_private);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PROC_FS\nstatic struct proc_dir_entry *proc_info_root;\n\n \nstatic int ntfs3_volinfo(struct seq_file *m, void *o)\n{\n\tstruct super_block *sb = m->private;\n\tstruct ntfs_sb_info *sbi = sb->s_fs_info;\n\n\tseq_printf(m, \"ntfs%d.%d\\n%u\\n%zu\\n\\%zu\\n%zu\\n%s\\n%s\\n\",\n\t\t   sbi->volume.major_ver, sbi->volume.minor_ver,\n\t\t   sbi->cluster_size, sbi->used.bitmap.nbits,\n\t\t   sbi->mft.bitmap.nbits,\n\t\t   sbi->mft.bitmap.nbits - wnd_zeroes(&sbi->mft.bitmap),\n\t\t   sbi->volume.real_dirty ? \"dirty\" : \"clean\",\n\t\t   (sbi->volume.flags & VOLUME_FLAG_DIRTY) ? \"dirty\" : \"clean\");\n\n\treturn 0;\n}\n\nstatic int ntfs3_volinfo_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, ntfs3_volinfo, pde_data(inode));\n}\n\n \nstatic int ntfs3_label_show(struct seq_file *m, void *o)\n{\n\tstruct super_block *sb = m->private;\n\tstruct ntfs_sb_info *sbi = sb->s_fs_info;\n\n\tseq_printf(m, \"%s\\n\", sbi->volume.label);\n\n\treturn 0;\n}\n\n \nstatic ssize_t ntfs3_label_write(struct file *file, const char __user *buffer,\n\t\t\t\t size_t count, loff_t *ppos)\n{\n\tint err;\n\tstruct super_block *sb = pde_data(file_inode(file));\n\tssize_t ret = count;\n\tu8 *label;\n\n\tif (sb_rdonly(sb))\n\t\treturn -EROFS;\n\n\tlabel = kmalloc(count, GFP_NOFS);\n\n\tif (!label)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(label, buffer, ret)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\twhile (ret > 0 && label[ret - 1] == '\\n')\n\t\tret -= 1;\n\n\terr = ntfs_set_label(sb->s_fs_info, label, ret);\n\n\tif (err < 0) {\n\t\tntfs_err(sb, \"failed (%d) to write label\", err);\n\t\tret = err;\n\t\tgoto out;\n\t}\n\n\t*ppos += count;\n\tret = count;\nout:\n\tkfree(label);\n\treturn ret;\n}\n\nstatic int ntfs3_label_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, ntfs3_label_show, pde_data(inode));\n}\n\nstatic const struct proc_ops ntfs3_volinfo_fops = {\n\t.proc_read = seq_read,\n\t.proc_lseek = seq_lseek,\n\t.proc_release = single_release,\n\t.proc_open = ntfs3_volinfo_open,\n};\n\nstatic const struct proc_ops ntfs3_label_fops = {\n\t.proc_read = seq_read,\n\t.proc_lseek = seq_lseek,\n\t.proc_release = single_release,\n\t.proc_open = ntfs3_label_open,\n\t.proc_write = ntfs3_label_write,\n};\n\n#endif\n\nstatic struct kmem_cache *ntfs_inode_cachep;\n\nstatic struct inode *ntfs_alloc_inode(struct super_block *sb)\n{\n\tstruct ntfs_inode *ni = alloc_inode_sb(sb, ntfs_inode_cachep, GFP_NOFS);\n\n\tif (!ni)\n\t\treturn NULL;\n\n\tmemset(ni, 0, offsetof(struct ntfs_inode, vfs_inode));\n\tmutex_init(&ni->ni_lock);\n\treturn &ni->vfs_inode;\n}\n\nstatic void ntfs_free_inode(struct inode *inode)\n{\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\n\tmutex_destroy(&ni->ni_lock);\n\tkmem_cache_free(ntfs_inode_cachep, ni);\n}\n\nstatic void init_once(void *foo)\n{\n\tstruct ntfs_inode *ni = foo;\n\n\tinode_init_once(&ni->vfs_inode);\n}\n\n \nstatic noinline void ntfs3_put_sbi(struct ntfs_sb_info *sbi)\n{\n\twnd_close(&sbi->mft.bitmap);\n\twnd_close(&sbi->used.bitmap);\n\n\tif (sbi->mft.ni) {\n\t\tiput(&sbi->mft.ni->vfs_inode);\n\t\tsbi->mft.ni = NULL;\n\t}\n\n\tif (sbi->security.ni) {\n\t\tiput(&sbi->security.ni->vfs_inode);\n\t\tsbi->security.ni = NULL;\n\t}\n\n\tif (sbi->reparse.ni) {\n\t\tiput(&sbi->reparse.ni->vfs_inode);\n\t\tsbi->reparse.ni = NULL;\n\t}\n\n\tif (sbi->objid.ni) {\n\t\tiput(&sbi->objid.ni->vfs_inode);\n\t\tsbi->objid.ni = NULL;\n\t}\n\n\tif (sbi->volume.ni) {\n\t\tiput(&sbi->volume.ni->vfs_inode);\n\t\tsbi->volume.ni = NULL;\n\t}\n\n\tntfs_update_mftmirr(sbi, 0);\n\n\tindx_clear(&sbi->security.index_sii);\n\tindx_clear(&sbi->security.index_sdh);\n\tindx_clear(&sbi->reparse.index_r);\n\tindx_clear(&sbi->objid.index_o);\n}\n\nstatic void ntfs3_free_sbi(struct ntfs_sb_info *sbi)\n{\n\tkfree(sbi->new_rec);\n\tkvfree(ntfs_put_shared(sbi->upcase));\n\tkfree(sbi->def_table);\n\tkfree(sbi->compress.lznt);\n#ifdef CONFIG_NTFS3_LZX_XPRESS\n\txpress_free_decompressor(sbi->compress.xpress);\n\tlzx_free_decompressor(sbi->compress.lzx);\n#endif\n\tkfree(sbi);\n}\n\nstatic void ntfs_put_super(struct super_block *sb)\n{\n\tstruct ntfs_sb_info *sbi = sb->s_fs_info;\n\n#ifdef CONFIG_PROC_FS\n\t\n\tif (sbi->procdir) {\n\t\tremove_proc_entry(\"label\", sbi->procdir);\n\t\tremove_proc_entry(\"volinfo\", sbi->procdir);\n\t\tremove_proc_entry(sb->s_id, proc_info_root);\n\t\tsbi->procdir = NULL;\n\t}\n#endif\n\n\t \n\tntfs_set_state(sbi, NTFS_DIRTY_CLEAR);\n\tntfs3_put_sbi(sbi);\n}\n\nstatic int ntfs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct ntfs_sb_info *sbi = sb->s_fs_info;\n\tstruct wnd_bitmap *wnd = &sbi->used.bitmap;\n\n\tbuf->f_type = sb->s_magic;\n\tbuf->f_bsize = sbi->cluster_size;\n\tbuf->f_blocks = wnd->nbits;\n\n\tbuf->f_bfree = buf->f_bavail = wnd_zeroes(wnd);\n\tbuf->f_fsid.val[0] = sbi->volume.ser_num;\n\tbuf->f_fsid.val[1] = (sbi->volume.ser_num >> 32);\n\tbuf->f_namelen = NTFS_NAME_LEN;\n\n\treturn 0;\n}\n\nstatic int ntfs_show_options(struct seq_file *m, struct dentry *root)\n{\n\tstruct super_block *sb = root->d_sb;\n\tstruct ntfs_sb_info *sbi = sb->s_fs_info;\n\tstruct ntfs_mount_options *opts = sbi->options;\n\tstruct user_namespace *user_ns = seq_user_ns(m);\n\n\tseq_printf(m, \",uid=%u\", from_kuid_munged(user_ns, opts->fs_uid));\n\tseq_printf(m, \",gid=%u\", from_kgid_munged(user_ns, opts->fs_gid));\n\tif (opts->dmask)\n\t\tseq_printf(m, \",dmask=%04o\", opts->fs_dmask_inv ^ 0xffff);\n\tif (opts->fmask)\n\t\tseq_printf(m, \",fmask=%04o\", opts->fs_fmask_inv ^ 0xffff);\n\tif (opts->sys_immutable)\n\t\tseq_puts(m, \",sys_immutable\");\n\tif (opts->discard)\n\t\tseq_puts(m, \",discard\");\n\tif (opts->force)\n\t\tseq_puts(m, \",force\");\n\tif (opts->sparse)\n\t\tseq_puts(m, \",sparse\");\n\tif (opts->nohidden)\n\t\tseq_puts(m, \",nohidden\");\n\tif (opts->hide_dot_files)\n\t\tseq_puts(m, \",hide_dot_files\");\n\tif (opts->windows_names)\n\t\tseq_puts(m, \",windows_names\");\n\tif (opts->showmeta)\n\t\tseq_puts(m, \",showmeta\");\n\tif (sb->s_flags & SB_POSIXACL)\n\t\tseq_puts(m, \",acl\");\n\tif (opts->nls)\n\t\tseq_printf(m, \",iocharset=%s\", opts->nls->charset);\n\telse\n\t\tseq_puts(m, \",iocharset=utf8\");\n\tif (opts->prealloc)\n\t\tseq_puts(m, \",prealloc\");\n\tif (opts->nocase)\n\t\tseq_puts(m, \",nocase\");\n\n\treturn 0;\n}\n\n \nstatic int ntfs_sync_fs(struct super_block *sb, int wait)\n{\n\tint err = 0, err2;\n\tstruct ntfs_sb_info *sbi = sb->s_fs_info;\n\tstruct ntfs_inode *ni;\n\tstruct inode *inode;\n\n\tni = sbi->security.ni;\n\tif (ni) {\n\t\tinode = &ni->vfs_inode;\n\t\terr2 = _ni_write_inode(inode, wait);\n\t\tif (err2 && !err)\n\t\t\terr = err2;\n\t}\n\n\tni = sbi->objid.ni;\n\tif (ni) {\n\t\tinode = &ni->vfs_inode;\n\t\terr2 = _ni_write_inode(inode, wait);\n\t\tif (err2 && !err)\n\t\t\terr = err2;\n\t}\n\n\tni = sbi->reparse.ni;\n\tif (ni) {\n\t\tinode = &ni->vfs_inode;\n\t\terr2 = _ni_write_inode(inode, wait);\n\t\tif (err2 && !err)\n\t\t\terr = err2;\n\t}\n\n\tif (!err)\n\t\tntfs_set_state(sbi, NTFS_DIRTY_CLEAR);\n\n\tntfs_update_mftmirr(sbi, wait);\n\n\treturn err;\n}\n\nstatic const struct super_operations ntfs_sops = {\n\t.alloc_inode = ntfs_alloc_inode,\n\t.free_inode = ntfs_free_inode,\n\t.evict_inode = ntfs_evict_inode,\n\t.put_super = ntfs_put_super,\n\t.statfs = ntfs_statfs,\n\t.show_options = ntfs_show_options,\n\t.sync_fs = ntfs_sync_fs,\n\t.write_inode = ntfs3_write_inode,\n};\n\nstatic struct inode *ntfs_export_get_inode(struct super_block *sb, u64 ino,\n\t\t\t\t\t   u32 generation)\n{\n\tstruct MFT_REF ref;\n\tstruct inode *inode;\n\n\tref.low = cpu_to_le32(ino);\n#ifdef CONFIG_NTFS3_64BIT_CLUSTER\n\tref.high = cpu_to_le16(ino >> 32);\n#else\n\tref.high = 0;\n#endif\n\tref.seq = cpu_to_le16(generation);\n\n\tinode = ntfs_iget5(sb, &ref, NULL);\n\tif (!IS_ERR(inode) && is_bad_inode(inode)) {\n\t\tiput(inode);\n\t\tinode = ERR_PTR(-ESTALE);\n\t}\n\n\treturn inode;\n}\n\nstatic struct dentry *ntfs_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\t\t\t\tint fh_len, int fh_type)\n{\n\treturn generic_fh_to_dentry(sb, fid, fh_len, fh_type,\n\t\t\t\t    ntfs_export_get_inode);\n}\n\nstatic struct dentry *ntfs_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\t\t\t\tint fh_len, int fh_type)\n{\n\treturn generic_fh_to_parent(sb, fid, fh_len, fh_type,\n\t\t\t\t    ntfs_export_get_inode);\n}\n\n \nstatic int ntfs_nfs_commit_metadata(struct inode *inode)\n{\n\treturn _ni_write_inode(inode, 1);\n}\n\nstatic const struct export_operations ntfs_export_ops = {\n\t.fh_to_dentry = ntfs_fh_to_dentry,\n\t.fh_to_parent = ntfs_fh_to_parent,\n\t.get_parent = ntfs3_get_parent,\n\t.commit_metadata = ntfs_nfs_commit_metadata,\n};\n\n \nstatic u32 format_size_gb(const u64 bytes, u32 *mb)\n{\n\t \n\tu64 kbytes = bytes >> 10;\n\tu32 kbytes32 = kbytes;\n\n\t*mb = (100 * (kbytes32 & 0xfffff) + 0x7ffff) >> 20;\n\tif (*mb >= 100)\n\t\t*mb = 99;\n\n\treturn (kbytes32 >> 20) | (((u32)(kbytes >> 32)) << 12);\n}\n\nstatic u32 true_sectors_per_clst(const struct NTFS_BOOT *boot)\n{\n\tif (boot->sectors_per_clusters <= 0x80)\n\t\treturn boot->sectors_per_clusters;\n\tif (boot->sectors_per_clusters >= 0xf4)  \n\t\treturn 1U << (-(s8)boot->sectors_per_clusters);\n\treturn -EINVAL;\n}\n\n \nstatic int ntfs_init_from_boot(struct super_block *sb, u32 sector_size,\n\t\t\t       u64 dev_size, struct NTFS_BOOT **boot2)\n{\n\tstruct ntfs_sb_info *sbi = sb->s_fs_info;\n\tint err;\n\tu32 mb, gb, boot_sector_size, sct_per_clst, record_size;\n\tu64 sectors, clusters, mlcn, mlcn2, dev_size0;\n\tstruct NTFS_BOOT *boot;\n\tstruct buffer_head *bh;\n\tstruct MFT_REC *rec;\n\tu16 fn, ao;\n\tu8 cluster_bits;\n\tu32 boot_off = 0;\n\tconst char *hint = \"Primary boot\";\n\n\t \n\tdev_size0 = dev_size;\n\n\tsbi->volume.blocks = dev_size >> PAGE_SHIFT;\n\n\tbh = ntfs_bread(sb, 0);\n\tif (!bh)\n\t\treturn -EIO;\n\ncheck_boot:\n\terr = -EINVAL;\n\n\t \n\tif (bh->b_size - sizeof(*boot) < boot_off)\n\t\tgoto out;\n\n\tboot = (struct NTFS_BOOT *)Add2Ptr(bh->b_data, boot_off);\n\n\tif (memcmp(boot->system_id, \"NTFS    \", sizeof(\"NTFS    \") - 1)) {\n\t\tntfs_err(sb, \"%s signature is not NTFS.\", hint);\n\t\tgoto out;\n\t}\n\n\t \n\t \n\n\tboot_sector_size = ((u32)boot->bytes_per_sector[1] << 8) |\n\t\t\t   boot->bytes_per_sector[0];\n\tif (boot_sector_size < SECTOR_SIZE ||\n\t    !is_power_of_2(boot_sector_size)) {\n\t\tntfs_err(sb, \"%s: invalid bytes per sector %u.\", hint,\n\t\t\t boot_sector_size);\n\t\tgoto out;\n\t}\n\n\t \n\tsct_per_clst = true_sectors_per_clst(boot);\n\tif ((int)sct_per_clst < 0 || !is_power_of_2(sct_per_clst)) {\n\t\tntfs_err(sb, \"%s: invalid sectors per cluster %u.\", hint,\n\t\t\t sct_per_clst);\n\t\tgoto out;\n\t}\n\n\tsbi->cluster_size = boot_sector_size * sct_per_clst;\n\tsbi->cluster_bits = cluster_bits = blksize_bits(sbi->cluster_size);\n\tsbi->cluster_mask = sbi->cluster_size - 1;\n\tsbi->cluster_mask_inv = ~(u64)sbi->cluster_mask;\n\n\tmlcn = le64_to_cpu(boot->mft_clst);\n\tmlcn2 = le64_to_cpu(boot->mft2_clst);\n\tsectors = le64_to_cpu(boot->sectors_per_volume);\n\n\tif (mlcn * sct_per_clst >= sectors || mlcn2 * sct_per_clst >= sectors) {\n\t\tntfs_err(\n\t\t\tsb,\n\t\t\t\"%s: start of MFT 0x%llx (0x%llx) is out of volume 0x%llx.\",\n\t\t\thint, mlcn, mlcn2, sectors);\n\t\tgoto out;\n\t}\n\n\tif (boot->record_size >= 0) {\n\t\trecord_size = (u32)boot->record_size << cluster_bits;\n\t} else if (-boot->record_size <= MAXIMUM_SHIFT_BYTES_PER_MFT) {\n\t\trecord_size = 1u << (-boot->record_size);\n\t} else {\n\t\tntfs_err(sb, \"%s: invalid record size %d.\", hint,\n\t\t\t boot->record_size);\n\t\tgoto out;\n\t}\n\n\tsbi->record_size = record_size;\n\tsbi->record_bits = blksize_bits(record_size);\n\tsbi->attr_size_tr = (5 * record_size >> 4); \n\n\t \n\tif (record_size < SECTOR_SIZE || !is_power_of_2(record_size)) {\n\t\tntfs_err(sb, \"%s: invalid bytes per MFT record %u (%d).\", hint,\n\t\t\t record_size, boot->record_size);\n\t\tgoto out;\n\t}\n\n\tif (record_size > MAXIMUM_BYTES_PER_MFT) {\n\t\tntfs_err(sb, \"Unsupported bytes per MFT record %u.\",\n\t\t\t record_size);\n\t\tgoto out;\n\t}\n\n\tif (boot->index_size >= 0) {\n\t\tsbi->index_size = (u32)boot->index_size << cluster_bits;\n\t} else if (-boot->index_size <= MAXIMUM_SHIFT_BYTES_PER_INDEX) {\n\t\tsbi->index_size = 1u << (-boot->index_size);\n\t} else {\n\t\tntfs_err(sb, \"%s: invalid index size %d.\", hint,\n\t\t\t boot->index_size);\n\t\tgoto out;\n\t}\n\n\t \n\tif (sbi->index_size < SECTOR_SIZE || !is_power_of_2(sbi->index_size)) {\n\t\tntfs_err(sb, \"%s: invalid bytes per index %u(%d).\", hint,\n\t\t\t sbi->index_size, boot->index_size);\n\t\tgoto out;\n\t}\n\n\tif (sbi->index_size > MAXIMUM_BYTES_PER_INDEX) {\n\t\tntfs_err(sb, \"%s: unsupported bytes per index %u.\", hint,\n\t\t\t sbi->index_size);\n\t\tgoto out;\n\t}\n\n\tsbi->volume.size = sectors * boot_sector_size;\n\n\tgb = format_size_gb(sbi->volume.size + boot_sector_size, &mb);\n\n\t \n\tif (boot_sector_size != sector_size) {\n\t\tntfs_warn(\n\t\t\tsb,\n\t\t\t\"Different NTFS sector size (%u) and media sector size (%u).\",\n\t\t\tboot_sector_size, sector_size);\n\t\tdev_size += sector_size - 1;\n\t}\n\n\tsbi->mft.lbo = mlcn << cluster_bits;\n\tsbi->mft.lbo2 = mlcn2 << cluster_bits;\n\n\t \n\tif (sbi->cluster_size < boot_sector_size) {\n\t\tntfs_err(sb, \"%s: invalid bytes per cluster (%u).\", hint,\n\t\t\t sbi->cluster_size);\n\t\tgoto out;\n\t}\n\n\t \n\tif (sbi->cluster_size < sector_size) {\n\t\t \n\t\tntfs_err(\n\t\t\tsb,\n\t\t\t\"Failed to mount 'cause NTFS's cluster size (%u) is less than media sector size (%u).\",\n\t\t\tsbi->cluster_size, sector_size);\n\t\tgoto out;\n\t}\n\n\tsbi->max_bytes_per_attr =\n\t\trecord_size - ALIGN(MFTRECORD_FIXUP_OFFSET, 8) -\n\t\tALIGN(((record_size >> SECTOR_SHIFT) * sizeof(short)), 8) -\n\t\tALIGN(sizeof(enum ATTR_TYPE), 8);\n\n\tsbi->volume.ser_num = le64_to_cpu(boot->serial_num);\n\n\t \n\tif (dev_size < sbi->volume.size + boot_sector_size) {\n\t\tu32 mb0, gb0;\n\n\t\tgb0 = format_size_gb(dev_size, &mb0);\n\t\tntfs_warn(\n\t\t\tsb,\n\t\t\t\"RAW NTFS volume: Filesystem size %u.%02u Gb > volume size %u.%02u Gb. Mount in read-only.\",\n\t\t\tgb, mb, gb0, mb0);\n\t\tsb->s_flags |= SB_RDONLY;\n\t}\n\n\tclusters = sbi->volume.size >> cluster_bits;\n#ifndef CONFIG_NTFS3_64BIT_CLUSTER\n\t \n\tif (clusters >> 32) {\n\t\tntfs_notice(\n\t\t\tsb,\n\t\t\t\"NTFS %u.%02u Gb is too big to use 32 bits per cluster.\",\n\t\t\tgb, mb);\n\t\tgoto out;\n\t}\n#elif BITS_PER_LONG < 64\n#error \"CONFIG_NTFS3_64BIT_CLUSTER incompatible in 32 bit OS\"\n#endif\n\n\tsbi->used.bitmap.nbits = clusters;\n\n\trec = kzalloc(record_size, GFP_NOFS);\n\tif (!rec) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tsbi->new_rec = rec;\n\trec->rhdr.sign = NTFS_FILE_SIGNATURE;\n\trec->rhdr.fix_off = cpu_to_le16(MFTRECORD_FIXUP_OFFSET);\n\tfn = (sbi->record_size >> SECTOR_SHIFT) + 1;\n\trec->rhdr.fix_num = cpu_to_le16(fn);\n\tao = ALIGN(MFTRECORD_FIXUP_OFFSET + sizeof(short) * fn, 8);\n\trec->attr_off = cpu_to_le16(ao);\n\trec->used = cpu_to_le32(ao + ALIGN(sizeof(enum ATTR_TYPE), 8));\n\trec->total = cpu_to_le32(sbi->record_size);\n\t((struct ATTRIB *)Add2Ptr(rec, ao))->type = ATTR_END;\n\n\tsb_set_blocksize(sb, min_t(u32, sbi->cluster_size, PAGE_SIZE));\n\n\tsbi->block_mask = sb->s_blocksize - 1;\n\tsbi->blocks_per_cluster = sbi->cluster_size >> sb->s_blocksize_bits;\n\tsbi->volume.blocks = sbi->volume.size >> sb->s_blocksize_bits;\n\n\t \n\tsbi->maxbytes = (clusters << cluster_bits) - 1;\n\n#ifdef CONFIG_NTFS3_64BIT_CLUSTER\n\tif (clusters >= (1ull << (64 - cluster_bits)))\n\t\tsbi->maxbytes = -1;\n\tsbi->maxbytes_sparse = -1;\n\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n#else\n\t \n\tsbi->maxbytes_sparse = (1ull << (cluster_bits + 32)) - 1;\n\tsb->s_maxbytes = 0xFFFFFFFFull << cluster_bits;\n#endif\n\n\t \n\tsbi->zone_max = min_t(CLST, 0x20000000 >> cluster_bits, clusters >> 3);\n\n\terr = 0;\n\n\tif (bh->b_blocknr && !sb_rdonly(sb)) {\n\t\t \n\t\t*boot2 = kmemdup(boot, sizeof(*boot), GFP_NOFS | __GFP_NOWARN);\n\t}\n\nout:\n\tif (err == -EINVAL && !bh->b_blocknr && dev_size0 > PAGE_SHIFT) {\n\t\tu32 block_size = min_t(u32, sector_size, PAGE_SIZE);\n\t\tu64 lbo = dev_size0 - sizeof(*boot);\n\n\t\t \n\t\tbrelse(bh);\n\n\t\tsb_set_blocksize(sb, block_size);\n\t\tbh = ntfs_bread(sb, lbo >> blksize_bits(block_size));\n\t\tif (!bh)\n\t\t\treturn -EINVAL;\n\n\t\tboot_off = lbo & (block_size - 1);\n\t\thint = \"Alternative boot\";\n\t\tdev_size = dev_size0;  \n\t\tgoto check_boot;\n\t}\n\tbrelse(bh);\n\n\treturn err;\n}\n\n \nstatic int ntfs_fill_super(struct super_block *sb, struct fs_context *fc)\n{\n\tint err;\n\tstruct ntfs_sb_info *sbi = sb->s_fs_info;\n\tstruct block_device *bdev = sb->s_bdev;\n\tstruct ntfs_mount_options *options;\n\tstruct inode *inode;\n\tstruct ntfs_inode *ni;\n\tsize_t i, tt, bad_len, bad_frags;\n\tCLST vcn, lcn, len;\n\tstruct ATTRIB *attr;\n\tconst struct VOLUME_INFO *info;\n\tu32 idx, done, bytes;\n\tstruct ATTR_DEF_ENTRY *t;\n\tu16 *shared;\n\tstruct MFT_REF ref;\n\tbool ro = sb_rdonly(sb);\n\tstruct NTFS_BOOT *boot2 = NULL;\n\n\tref.high = 0;\n\n\tsbi->sb = sb;\n\tsbi->options = options = fc->fs_private;\n\tfc->fs_private = NULL;\n\tsb->s_flags |= SB_NODIRATIME;\n\tsb->s_magic = 0x7366746e;  \n\tsb->s_op = &ntfs_sops;\n\tsb->s_export_op = &ntfs_export_ops;\n\tsb->s_time_gran = NTFS_TIME_GRAN;  \n\tsb->s_xattr = ntfs_xattr_handlers;\n\tsb->s_d_op = options->nocase ? &ntfs_dentry_ops : NULL;\n\n\toptions->nls = ntfs_load_nls(options->nls_name);\n\tif (IS_ERR(options->nls)) {\n\t\toptions->nls = NULL;\n\t\terrorf(fc, \"Cannot load nls %s\", options->nls_name);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (bdev_max_discard_sectors(bdev) && bdev_discard_granularity(bdev)) {\n\t\tsbi->discard_granularity = bdev_discard_granularity(bdev);\n\t\tsbi->discard_granularity_mask_inv =\n\t\t\t~(u64)(sbi->discard_granularity - 1);\n\t}\n\n\t \n\terr = ntfs_init_from_boot(sb, bdev_logical_block_size(bdev),\n\t\t\t\t  bdev_nr_bytes(bdev), &boot2);\n\tif (err)\n\t\tgoto out;\n\n\t \n\tref.low = cpu_to_le32(MFT_REC_VOL);\n\tref.seq = cpu_to_le16(MFT_REC_VOL);\n\tinode = ntfs_iget5(sb, &ref, &NAME_VOLUME);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tntfs_err(sb, \"Failed to load $Volume (%d).\", err);\n\t\tgoto out;\n\t}\n\n\tni = ntfs_i(inode);\n\n\t \n\tattr = ni_find_attr(ni, NULL, NULL, ATTR_LABEL, NULL, 0, NULL, NULL);\n\n\tif (!attr) {\n\t\t \n\t} else if (!attr->non_res && !is_attr_ext(attr)) {\n\t\t \n\t\terr = utf16s_to_utf8s(resident_data(attr),\n\t\t\t\t      le32_to_cpu(attr->res.data_size) >> 1,\n\t\t\t\t      UTF16_LITTLE_ENDIAN, sbi->volume.label,\n\t\t\t\t      sizeof(sbi->volume.label));\n\t\tif (err < 0)\n\t\t\tsbi->volume.label[0] = 0;\n\t} else {\n\t\t \n\t\t\n\t\t\n\t}\n\n\tattr = ni_find_attr(ni, attr, NULL, ATTR_VOL_INFO, NULL, 0, NULL, NULL);\n\tif (!attr || is_attr_ext(attr) ||\n\t    !(info = resident_data_ex(attr, SIZEOF_ATTRIBUTE_VOLUME_INFO))) {\n\t\tntfs_err(sb, \"$Volume is corrupted.\");\n\t\terr = -EINVAL;\n\t\tgoto put_inode_out;\n\t}\n\n\tsbi->volume.major_ver = info->major_ver;\n\tsbi->volume.minor_ver = info->minor_ver;\n\tsbi->volume.flags = info->flags;\n\tsbi->volume.ni = ni;\n\tif (info->flags & VOLUME_FLAG_DIRTY) {\n\t\tsbi->volume.real_dirty = true;\n\t\tntfs_info(sb, \"It is recommened to use chkdsk.\");\n\t}\n\n\t \n\tref.low = cpu_to_le32(MFT_REC_MIRR);\n\tref.seq = cpu_to_le16(MFT_REC_MIRR);\n\tinode = ntfs_iget5(sb, &ref, &NAME_MIRROR);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tntfs_err(sb, \"Failed to load $MFTMirr (%d).\", err);\n\t\tgoto out;\n\t}\n\n\tsbi->mft.recs_mirr = ntfs_up_cluster(sbi, inode->i_size) >>\n\t\t\t     sbi->record_bits;\n\n\tiput(inode);\n\n\t \n\tref.low = cpu_to_le32(MFT_REC_LOG);\n\tref.seq = cpu_to_le16(MFT_REC_LOG);\n\tinode = ntfs_iget5(sb, &ref, &NAME_LOGFILE);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tntfs_err(sb, \"Failed to load \\x24LogFile (%d).\", err);\n\t\tgoto out;\n\t}\n\n\tni = ntfs_i(inode);\n\n\terr = ntfs_loadlog_and_replay(ni, sbi);\n\tif (err)\n\t\tgoto put_inode_out;\n\n\tiput(inode);\n\n\tif ((sbi->flags & NTFS_FLAGS_NEED_REPLAY) && !ro) {\n\t\tntfs_warn(sb, \"failed to replay log file. Can't mount rw!\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif ((sbi->volume.flags & VOLUME_FLAG_DIRTY) && !ro && !options->force) {\n\t\tntfs_warn(sb, \"volume is dirty and \\\"force\\\" flag is not set!\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tref.low = cpu_to_le32(MFT_REC_MFT);\n\tref.seq = cpu_to_le16(1);\n\n\tinode = ntfs_iget5(sb, &ref, &NAME_MFT);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tntfs_err(sb, \"Failed to load $MFT (%d).\", err);\n\t\tgoto out;\n\t}\n\n\tni = ntfs_i(inode);\n\n\tsbi->mft.used = ni->i_valid >> sbi->record_bits;\n\ttt = inode->i_size >> sbi->record_bits;\n\tsbi->mft.next_free = MFT_REC_USER;\n\n\terr = wnd_init(&sbi->mft.bitmap, sb, tt);\n\tif (err)\n\t\tgoto put_inode_out;\n\n\terr = ni_load_all_mi(ni);\n\tif (err) {\n\t\tntfs_err(sb, \"Failed to load $MFT's subrecords (%d).\", err);\n\t\tgoto put_inode_out;\n\t}\n\n\tsbi->mft.ni = ni;\n\n\t \n\tref.low = cpu_to_le32(MFT_REC_BITMAP);\n\tref.seq = cpu_to_le16(MFT_REC_BITMAP);\n\tinode = ntfs_iget5(sb, &ref, &NAME_BITMAP);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tntfs_err(sb, \"Failed to load $Bitmap (%d).\", err);\n\t\tgoto out;\n\t}\n\n#ifndef CONFIG_NTFS3_64BIT_CLUSTER\n\tif (inode->i_size >> 32) {\n\t\terr = -EINVAL;\n\t\tgoto put_inode_out;\n\t}\n#endif\n\n\t \n\ttt = sbi->used.bitmap.nbits;\n\tif (inode->i_size < bitmap_size(tt)) {\n\t\tntfs_err(sb, \"$Bitmap is corrupted.\");\n\t\terr = -EINVAL;\n\t\tgoto put_inode_out;\n\t}\n\n\terr = wnd_init(&sbi->used.bitmap, sb, tt);\n\tif (err) {\n\t\tntfs_err(sb, \"Failed to initialize $Bitmap (%d).\", err);\n\t\tgoto put_inode_out;\n\t}\n\n\tiput(inode);\n\n\t \n\terr = ntfs_refresh_zone(sbi);\n\tif (err) {\n\t\tntfs_err(sb, \"Failed to initialize MFT zone (%d).\", err);\n\t\tgoto out;\n\t}\n\n\t \n\tref.low = cpu_to_le32(MFT_REC_BADCLUST);\n\tref.seq = cpu_to_le16(MFT_REC_BADCLUST);\n\tinode = ntfs_iget5(sb, &ref, &NAME_BADCLUS);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tntfs_err(sb, \"Failed to load $BadClus (%d).\", err);\n\t\tgoto out;\n\t}\n\n\tni = ntfs_i(inode);\n\tbad_len = bad_frags = 0;\n\tfor (i = 0; run_get_entry(&ni->file.run, i, &vcn, &lcn, &len); i++) {\n\t\tif (lcn == SPARSE_LCN)\n\t\t\tcontinue;\n\n\t\tbad_len += len;\n\t\tbad_frags += 1;\n\t\tif (ro)\n\t\t\tcontinue;\n\n\t\tif (wnd_set_used_safe(&sbi->used.bitmap, lcn, len, &tt) || tt) {\n\t\t\t \n\t\t\tntfs_set_state(sbi, NTFS_DIRTY_ERROR);\n\t\t}\n\t}\n\tif (bad_len) {\n\t\t \n\t\tntfs_notice(sb,\n\t\t\t    \"Volume contains %zu bad blocks in %zu fragments.\",\n\t\t\t    bad_len, bad_frags);\n\t}\n\tiput(inode);\n\n\t \n\tref.low = cpu_to_le32(MFT_REC_ATTR);\n\tref.seq = cpu_to_le16(MFT_REC_ATTR);\n\tinode = ntfs_iget5(sb, &ref, &NAME_ATTRDEF);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tntfs_err(sb, \"Failed to load $AttrDef (%d)\", err);\n\t\tgoto out;\n\t}\n\n\t \n\tif (inode->i_size < sizeof(struct ATTR_DEF_ENTRY) ||\n\t    inode->i_size > 100 * sizeof(struct ATTR_DEF_ENTRY)) {\n\t\tntfs_err(sb, \"Looks like $AttrDef is corrupted (size=%llu).\",\n\t\t\t inode->i_size);\n\t\terr = -EINVAL;\n\t\tgoto put_inode_out;\n\t}\n\n\tbytes = inode->i_size;\n\tsbi->def_table = t = kvmalloc(bytes, GFP_KERNEL);\n\tif (!t) {\n\t\terr = -ENOMEM;\n\t\tgoto put_inode_out;\n\t}\n\n\tfor (done = idx = 0; done < bytes; done += PAGE_SIZE, idx++) {\n\t\tunsigned long tail = bytes - done;\n\t\tstruct page *page = ntfs_map_page(inode->i_mapping, idx);\n\n\t\tif (IS_ERR(page)) {\n\t\t\terr = PTR_ERR(page);\n\t\t\tntfs_err(sb, \"Failed to read $AttrDef (%d).\", err);\n\t\t\tgoto put_inode_out;\n\t\t}\n\t\tmemcpy(Add2Ptr(t, done), page_address(page),\n\t\t       min(PAGE_SIZE, tail));\n\t\tntfs_unmap_page(page);\n\n\t\tif (!idx && ATTR_STD != t->type) {\n\t\t\tntfs_err(sb, \"$AttrDef is corrupted.\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto put_inode_out;\n\t\t}\n\t}\n\n\tt += 1;\n\tsbi->def_entries = 1;\n\tdone = sizeof(struct ATTR_DEF_ENTRY);\n\tsbi->reparse.max_size = MAXIMUM_REPARSE_DATA_BUFFER_SIZE;\n\tsbi->ea_max_size = 0x10000;  \n\n\twhile (done + sizeof(struct ATTR_DEF_ENTRY) <= bytes) {\n\t\tu32 t32 = le32_to_cpu(t->type);\n\t\tu64 sz = le64_to_cpu(t->max_sz);\n\n\t\tif ((t32 & 0xF) || le32_to_cpu(t[-1].type) >= t32)\n\t\t\tbreak;\n\n\t\tif (t->type == ATTR_REPARSE)\n\t\t\tsbi->reparse.max_size = sz;\n\t\telse if (t->type == ATTR_EA)\n\t\t\tsbi->ea_max_size = sz;\n\n\t\tdone += sizeof(struct ATTR_DEF_ENTRY);\n\t\tt += 1;\n\t\tsbi->def_entries += 1;\n\t}\n\tiput(inode);\n\n\t \n\tref.low = cpu_to_le32(MFT_REC_UPCASE);\n\tref.seq = cpu_to_le16(MFT_REC_UPCASE);\n\tinode = ntfs_iget5(sb, &ref, &NAME_UPCASE);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tntfs_err(sb, \"Failed to load $UpCase (%d).\", err);\n\t\tgoto out;\n\t}\n\n\tif (inode->i_size != 0x10000 * sizeof(short)) {\n\t\terr = -EINVAL;\n\t\tntfs_err(sb, \"$UpCase is corrupted.\");\n\t\tgoto put_inode_out;\n\t}\n\n\tfor (idx = 0; idx < (0x10000 * sizeof(short) >> PAGE_SHIFT); idx++) {\n\t\tconst __le16 *src;\n\t\tu16 *dst = Add2Ptr(sbi->upcase, idx << PAGE_SHIFT);\n\t\tstruct page *page = ntfs_map_page(inode->i_mapping, idx);\n\n\t\tif (IS_ERR(page)) {\n\t\t\terr = PTR_ERR(page);\n\t\t\tntfs_err(sb, \"Failed to read $UpCase (%d).\", err);\n\t\t\tgoto put_inode_out;\n\t\t}\n\n\t\tsrc = page_address(page);\n\n#ifdef __BIG_ENDIAN\n\t\tfor (i = 0; i < PAGE_SIZE / sizeof(u16); i++)\n\t\t\t*dst++ = le16_to_cpu(*src++);\n#else\n\t\tmemcpy(dst, src, PAGE_SIZE);\n#endif\n\t\tntfs_unmap_page(page);\n\t}\n\n\tshared = ntfs_set_shared(sbi->upcase, 0x10000 * sizeof(short));\n\tif (shared && sbi->upcase != shared) {\n\t\tkvfree(sbi->upcase);\n\t\tsbi->upcase = shared;\n\t}\n\n\tiput(inode);\n\n\tif (is_ntfs3(sbi)) {\n\t\t \n\t\terr = ntfs_security_init(sbi);\n\t\tif (err) {\n\t\t\tntfs_err(sb, \"Failed to initialize $Secure (%d).\", err);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\terr = ntfs_extend_init(sbi);\n\t\tif (err) {\n\t\t\tntfs_warn(sb, \"Failed to initialize $Extend.\");\n\t\t\tgoto load_root;\n\t\t}\n\n\t\t \n\t\terr = ntfs_reparse_init(sbi);\n\t\tif (err) {\n\t\t\tntfs_warn(sb, \"Failed to initialize $Extend/$Reparse.\");\n\t\t\tgoto load_root;\n\t\t}\n\n\t\t \n\t\terr = ntfs_objid_init(sbi);\n\t\tif (err) {\n\t\t\tntfs_warn(sb, \"Failed to initialize $Extend/$ObjId.\");\n\t\t\tgoto load_root;\n\t\t}\n\t}\n\nload_root:\n\t \n\tref.low = cpu_to_le32(MFT_REC_ROOT);\n\tref.seq = cpu_to_le16(MFT_REC_ROOT);\n\tinode = ntfs_iget5(sb, &ref, &NAME_ROOT);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tntfs_err(sb, \"Failed to load root (%d).\", err);\n\t\tgoto out;\n\t}\n\n\t \n\tif (!inode->i_op) {\n\t\terr = -EINVAL;\n\t\tntfs_err(sb, \"Failed to load root (%d).\", err);\n\t\tgoto put_inode_out;\n\t}\n\n\tsb->s_root = d_make_root(inode);\n\tif (!sb->s_root) {\n\t\terr = -ENOMEM;\n\t\tgoto put_inode_out;\n\t}\n\n\tif (boot2) {\n\t\t \n\t\tstruct buffer_head *bh0 = sb_getblk(sb, 0);\n\t\tif (bh0) {\n\t\t\tif (buffer_locked(bh0))\n\t\t\t\t__wait_on_buffer(bh0);\n\n\t\t\tlock_buffer(bh0);\n\t\t\tmemcpy(bh0->b_data, boot2, sizeof(*boot2));\n\t\t\tset_buffer_uptodate(bh0);\n\t\t\tmark_buffer_dirty(bh0);\n\t\t\tunlock_buffer(bh0);\n\t\t\tif (!sync_dirty_buffer(bh0))\n\t\t\t\tntfs_warn(sb, \"primary boot is updated\");\n\t\t\tput_bh(bh0);\n\t\t}\n\n\t\tkfree(boot2);\n\t}\n\n#ifdef CONFIG_PROC_FS\n\t \n\tif (proc_info_root) {\n\t\tstruct proc_dir_entry *e = proc_mkdir(sb->s_id, proc_info_root);\n\t\tstatic_assert((S_IRUGO | S_IWUSR) == 0644);\n\t\tif (e) {\n\t\t\tproc_create_data(\"volinfo\", S_IRUGO, e,\n\t\t\t\t\t &ntfs3_volinfo_fops, sb);\n\t\t\tproc_create_data(\"label\", S_IRUGO | S_IWUSR, e,\n\t\t\t\t\t &ntfs3_label_fops, sb);\n\t\t\tsbi->procdir = e;\n\t\t}\n\t}\n#endif\n\n\treturn 0;\n\nput_inode_out:\n\tiput(inode);\nout:\n\tntfs3_put_sbi(sbi);\n\tkfree(boot2);\n\tntfs3_put_sbi(sbi);\n\treturn err;\n}\n\nvoid ntfs_unmap_meta(struct super_block *sb, CLST lcn, CLST len)\n{\n\tstruct ntfs_sb_info *sbi = sb->s_fs_info;\n\tstruct block_device *bdev = sb->s_bdev;\n\tsector_t devblock = (u64)lcn * sbi->blocks_per_cluster;\n\tunsigned long blocks = (u64)len * sbi->blocks_per_cluster;\n\tunsigned long cnt = 0;\n\tunsigned long limit = global_zone_page_state(NR_FREE_PAGES)\n\t\t\t      << (PAGE_SHIFT - sb->s_blocksize_bits);\n\n\tif (limit >= 0x2000)\n\t\tlimit -= 0x1000;\n\telse if (limit < 32)\n\t\tlimit = 32;\n\telse\n\t\tlimit >>= 1;\n\n\twhile (blocks--) {\n\t\tclean_bdev_aliases(bdev, devblock++, 1);\n\t\tif (cnt++ >= limit) {\n\t\t\tsync_blockdev(bdev);\n\t\t\tcnt = 0;\n\t\t}\n\t}\n}\n\n \nint ntfs_discard(struct ntfs_sb_info *sbi, CLST lcn, CLST len)\n{\n\tint err;\n\tu64 lbo, bytes, start, end;\n\tstruct super_block *sb;\n\n\tif (sbi->used.next_free_lcn == lcn + len)\n\t\tsbi->used.next_free_lcn = lcn;\n\n\tif (sbi->flags & NTFS_FLAGS_NODISCARD)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!sbi->options->discard)\n\t\treturn -EOPNOTSUPP;\n\n\tlbo = (u64)lcn << sbi->cluster_bits;\n\tbytes = (u64)len << sbi->cluster_bits;\n\n\t \n\tstart = (lbo + sbi->discard_granularity - 1) &\n\t\tsbi->discard_granularity_mask_inv;\n\t \n\tend = (lbo + bytes) & sbi->discard_granularity_mask_inv;\n\n\tsb = sbi->sb;\n\tif (start >= end)\n\t\treturn 0;\n\n\terr = blkdev_issue_discard(sb->s_bdev, start >> 9, (end - start) >> 9,\n\t\t\t\t   GFP_NOFS);\n\n\tif (err == -EOPNOTSUPP)\n\t\tsbi->flags |= NTFS_FLAGS_NODISCARD;\n\n\treturn err;\n}\n\nstatic int ntfs_fs_get_tree(struct fs_context *fc)\n{\n\treturn get_tree_bdev(fc, ntfs_fill_super);\n}\n\n \nstatic void ntfs_fs_free(struct fs_context *fc)\n{\n\tstruct ntfs_mount_options *opts = fc->fs_private;\n\tstruct ntfs_sb_info *sbi = fc->s_fs_info;\n\n\tif (sbi) {\n\t\tntfs3_put_sbi(sbi);\n\t\tntfs3_free_sbi(sbi);\n\t}\n\n\tif (opts)\n\t\tput_mount_options(opts);\n}\n\n\nstatic const struct fs_context_operations ntfs_context_ops = {\n\t.parse_param\t= ntfs_fs_parse_param,\n\t.get_tree\t= ntfs_fs_get_tree,\n\t.reconfigure\t= ntfs_fs_reconfigure,\n\t.free\t\t= ntfs_fs_free,\n};\n\n\n \nstatic int ntfs_init_fs_context(struct fs_context *fc)\n{\n\tstruct ntfs_mount_options *opts;\n\tstruct ntfs_sb_info *sbi;\n\n\topts = kzalloc(sizeof(struct ntfs_mount_options), GFP_NOFS);\n\tif (!opts)\n\t\treturn -ENOMEM;\n\n\t \n\topts->fs_uid = current_uid();\n\topts->fs_gid = current_gid();\n\topts->fs_fmask_inv = ~current_umask();\n\topts->fs_dmask_inv = ~current_umask();\n\n\tif (fc->purpose == FS_CONTEXT_FOR_RECONFIGURE)\n\t\tgoto ok;\n\n\tsbi = kzalloc(sizeof(struct ntfs_sb_info), GFP_NOFS);\n\tif (!sbi)\n\t\tgoto free_opts;\n\n\tsbi->upcase = kvmalloc(0x10000 * sizeof(short), GFP_KERNEL);\n\tif (!sbi->upcase)\n\t\tgoto free_sbi;\n\n\tratelimit_state_init(&sbi->msg_ratelimit, DEFAULT_RATELIMIT_INTERVAL,\n\t\t\t     DEFAULT_RATELIMIT_BURST);\n\n\tmutex_init(&sbi->compress.mtx_lznt);\n#ifdef CONFIG_NTFS3_LZX_XPRESS\n\tmutex_init(&sbi->compress.mtx_xpress);\n\tmutex_init(&sbi->compress.mtx_lzx);\n#endif\n\n\tfc->s_fs_info = sbi;\nok:\n\tfc->fs_private = opts;\n\tfc->ops = &ntfs_context_ops;\n\n\treturn 0;\nfree_sbi:\n\tkfree(sbi);\nfree_opts:\n\tkfree(opts);\n\treturn -ENOMEM;\n}\n\nstatic void ntfs3_kill_sb(struct super_block *sb)\n{\n\tstruct ntfs_sb_info *sbi = sb->s_fs_info;\n\n\tkill_block_super(sb);\n\n\tif (sbi->options)\n\t\tput_mount_options(sbi->options);\n\tntfs3_free_sbi(sbi);\n}\n\n\nstatic struct file_system_type ntfs_fs_type = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.name\t\t\t= \"ntfs3\",\n\t.init_fs_context\t= ntfs_init_fs_context,\n\t.parameters\t\t= ntfs_fs_parameters,\n\t.kill_sb\t\t= ntfs3_kill_sb,\n\t.fs_flags\t\t= FS_REQUIRES_DEV | FS_ALLOW_IDMAP,\n};\n\n\nstatic int __init init_ntfs_fs(void)\n{\n\tint err;\n\n\tpr_info(\"ntfs3: Max link count %u\\n\", NTFS_LINK_MAX);\n\n\tif (IS_ENABLED(CONFIG_NTFS3_FS_POSIX_ACL))\n\t\tpr_info(\"ntfs3: Enabled Linux POSIX ACLs support\\n\");\n\tif (IS_ENABLED(CONFIG_NTFS3_64BIT_CLUSTER))\n\t\tpr_notice(\n\t\t\t\"ntfs3: Warning: Activated 64 bits per cluster. Windows does not support this\\n\");\n\tif (IS_ENABLED(CONFIG_NTFS3_LZX_XPRESS))\n\t\tpr_info(\"ntfs3: Read-only LZX/Xpress compression included\\n\");\n\n#ifdef CONFIG_PROC_FS\n\t \n\tproc_info_root = proc_mkdir(\"fs/ntfs3\", NULL);\n#endif\n\n\terr = ntfs3_init_bitmap();\n\tif (err)\n\t\treturn err;\n\n\tntfs_inode_cachep = kmem_cache_create(\n\t\t\"ntfs_inode_cache\", sizeof(struct ntfs_inode), 0,\n\t\t(SLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD | SLAB_ACCOUNT),\n\t\tinit_once);\n\tif (!ntfs_inode_cachep) {\n\t\terr = -ENOMEM;\n\t\tgoto out1;\n\t}\n\n\terr = register_filesystem(&ntfs_fs_type);\n\tif (err)\n\t\tgoto out;\n\n\treturn 0;\nout:\n\tkmem_cache_destroy(ntfs_inode_cachep);\nout1:\n\tntfs3_exit_bitmap();\n\treturn err;\n}\n\nstatic void __exit exit_ntfs_fs(void)\n{\n\trcu_barrier();\n\tkmem_cache_destroy(ntfs_inode_cachep);\n\tunregister_filesystem(&ntfs_fs_type);\n\tntfs3_exit_bitmap();\n\n#ifdef CONFIG_PROC_FS\n\tif (proc_info_root)\n\t\tremove_proc_entry(\"fs/ntfs3\", NULL);\n#endif\n}\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"ntfs3 read/write filesystem\");\n#ifdef CONFIG_NTFS3_FS_POSIX_ACL\nMODULE_INFO(behaviour, \"Enabled Linux POSIX ACLs support\");\n#endif\n#ifdef CONFIG_NTFS3_64BIT_CLUSTER\nMODULE_INFO(\n\tcluster,\n\t\"Warning: Activated 64 bits per cluster. Windows does not support this\");\n#endif\n#ifdef CONFIG_NTFS3_LZX_XPRESS\nMODULE_INFO(compression, \"Read-only lzx/xpress compression included\");\n#endif\n\nMODULE_AUTHOR(\"Konstantin Komarov\");\nMODULE_ALIAS_FS(\"ntfs3\");\n\nmodule_init(init_ntfs_fs);\nmodule_exit(exit_ntfs_fs);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}