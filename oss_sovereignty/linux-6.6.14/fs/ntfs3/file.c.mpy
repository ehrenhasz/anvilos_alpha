{
  "module_name": "file.c",
  "hash_id": "4e2c89970606ebe7b39f4ca037db197454ff44ac45c4088aafb28a8ec00aa1f3",
  "original_prompt": "Ingested from linux-6.6.14/fs/ntfs3/file.c",
  "human_readable_source": "\n \n\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <linux/fiemap.h>\n\n#include \"debug.h\"\n#include \"ntfs.h\"\n#include \"ntfs_fs.h\"\n\nstatic int ntfs_ioctl_fitrim(struct ntfs_sb_info *sbi, unsigned long arg)\n{\n\tstruct fstrim_range __user *user_range;\n\tstruct fstrim_range range;\n\tstruct block_device *dev;\n\tint err;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tdev = sbi->sb->s_bdev;\n\tif (!bdev_max_discard_sectors(dev))\n\t\treturn -EOPNOTSUPP;\n\n\tuser_range = (struct fstrim_range __user *)arg;\n\tif (copy_from_user(&range, user_range, sizeof(range)))\n\t\treturn -EFAULT;\n\n\trange.minlen = max_t(u32, range.minlen, bdev_discard_granularity(dev));\n\n\terr = ntfs_trim_fs(sbi, &range);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (copy_to_user(user_range, &range, sizeof(range)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic long ntfs_ioctl(struct file *filp, u32 cmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct ntfs_sb_info *sbi = inode->i_sb->s_fs_info;\n\n\tswitch (cmd) {\n\tcase FITRIM:\n\t\treturn ntfs_ioctl_fitrim(sbi, arg);\n\t}\n\treturn -ENOTTY;  \n}\n\n#ifdef CONFIG_COMPAT\nstatic long ntfs_compat_ioctl(struct file *filp, u32 cmd, unsigned long arg)\n\n{\n\treturn ntfs_ioctl(filp, cmd, (unsigned long)compat_ptr(arg));\n}\n#endif\n\n \nint ntfs_getattr(struct mnt_idmap *idmap, const struct path *path,\n\t\t struct kstat *stat, u32 request_mask, u32 flags)\n{\n\tstruct inode *inode = d_inode(path->dentry);\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\n\tif (is_compressed(ni))\n\t\tstat->attributes |= STATX_ATTR_COMPRESSED;\n\n\tif (is_encrypted(ni))\n\t\tstat->attributes |= STATX_ATTR_ENCRYPTED;\n\n\tstat->attributes_mask |= STATX_ATTR_COMPRESSED | STATX_ATTR_ENCRYPTED;\n\n\tgeneric_fillattr(idmap, request_mask, inode, stat);\n\n\tstat->result_mask |= STATX_BTIME;\n\tstat->btime = ni->i_crtime;\n\tstat->blksize = ni->mi.sbi->cluster_size;  \n\n\treturn 0;\n}\n\nstatic int ntfs_extend_initialized_size(struct file *file,\n\t\t\t\t\tstruct ntfs_inode *ni,\n\t\t\t\t\tconst loff_t valid,\n\t\t\t\t\tconst loff_t new_valid)\n{\n\tstruct inode *inode = &ni->vfs_inode;\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct ntfs_sb_info *sbi = inode->i_sb->s_fs_info;\n\tloff_t pos = valid;\n\tint err;\n\n\tif (is_resident(ni)) {\n\t\tni->i_valid = new_valid;\n\t\treturn 0;\n\t}\n\n\tWARN_ON(is_compressed(ni));\n\tWARN_ON(valid >= new_valid);\n\n\tfor (;;) {\n\t\tu32 zerofrom, len;\n\t\tstruct page *page;\n\t\tu8 bits;\n\t\tCLST vcn, lcn, clen;\n\n\t\tif (is_sparsed(ni)) {\n\t\t\tbits = sbi->cluster_bits;\n\t\t\tvcn = pos >> bits;\n\n\t\t\terr = attr_data_get_block(ni, vcn, 1, &lcn, &clen, NULL,\n\t\t\t\t\t\t  false);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\tif (lcn == SPARSE_LCN) {\n\t\t\t\tpos = ((loff_t)clen + vcn) << bits;\n\t\t\t\tni->i_valid = pos;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t}\n\n\t\tzerofrom = pos & (PAGE_SIZE - 1);\n\t\tlen = PAGE_SIZE - zerofrom;\n\n\t\tif (pos + len > new_valid)\n\t\t\tlen = new_valid - pos;\n\n\t\terr = ntfs_write_begin(file, mapping, pos, len, &page, NULL);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tzero_user_segment(page, zerofrom, PAGE_SIZE);\n\n\t\t \n\t\terr = ntfs_write_end(file, mapping, pos, len, len, page, NULL);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\tpos += len;\n\nnext:\n\t\tif (pos >= new_valid)\n\t\t\tbreak;\n\n\t\tbalance_dirty_pages_ratelimited(mapping);\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n\nout:\n\tni->i_valid = valid;\n\tntfs_inode_warn(inode, \"failed to extend initialized size to %llx.\",\n\t\t\tnew_valid);\n\treturn err;\n}\n\n \nstatic int ntfs_zero_range(struct inode *inode, u64 vbo, u64 vbo_to)\n{\n\tint err = 0;\n\tstruct address_space *mapping = inode->i_mapping;\n\tu32 blocksize = i_blocksize(inode);\n\tpgoff_t idx = vbo >> PAGE_SHIFT;\n\tu32 from = vbo & (PAGE_SIZE - 1);\n\tpgoff_t idx_end = (vbo_to + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tloff_t page_off;\n\tstruct buffer_head *head, *bh;\n\tu32 bh_next, bh_off, to;\n\tsector_t iblock;\n\tstruct page *page;\n\n\tfor (; idx < idx_end; idx += 1, from = 0) {\n\t\tpage_off = (loff_t)idx << PAGE_SHIFT;\n\t\tto = (page_off + PAGE_SIZE) > vbo_to ? (vbo_to - page_off) :\n\t\t\t\t\t\t       PAGE_SIZE;\n\t\tiblock = page_off >> inode->i_blkbits;\n\n\t\tpage = find_or_create_page(mapping, idx,\n\t\t\t\t\t   mapping_gfp_constraint(mapping,\n\t\t\t\t\t\t\t\t  ~__GFP_FS));\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\n\t\tif (!page_has_buffers(page))\n\t\t\tcreate_empty_buffers(page, blocksize, 0);\n\n\t\tbh = head = page_buffers(page);\n\t\tbh_off = 0;\n\t\tdo {\n\t\t\tbh_next = bh_off + blocksize;\n\n\t\t\tif (bh_next <= from || bh_off >= to)\n\t\t\t\tcontinue;\n\n\t\t\tif (!buffer_mapped(bh)) {\n\t\t\t\tntfs_get_block(inode, iblock, bh, 0);\n\t\t\t\t \n\t\t\t\tif (!buffer_mapped(bh))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(bh);\n\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\terr = bh_read(bh, 0);\n\t\t\t\tif (err < 0) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tput_page(page);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmark_buffer_dirty(bh);\n\n\t\t} while (bh_off = bh_next, iblock += 1,\n\t\t\t head != (bh = bh->b_this_page));\n\n\t\tzero_user_segment(page, from, to);\n\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\tcond_resched();\n\t}\nout:\n\tmark_inode_dirty(inode);\n\treturn err;\n}\n\n \nstatic int ntfs_file_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tu64 from = ((u64)vma->vm_pgoff << PAGE_SHIFT);\n\tbool rw = vma->vm_flags & VM_WRITE;\n\tint err;\n\n\tif (is_encrypted(ni)) {\n\t\tntfs_inode_warn(inode, \"mmap encrypted not supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (is_dedup(ni)) {\n\t\tntfs_inode_warn(inode, \"mmap deduplicated not supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (is_compressed(ni) && rw) {\n\t\tntfs_inode_warn(inode, \"mmap(write) compressed not supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (rw) {\n\t\tu64 to = min_t(loff_t, i_size_read(inode),\n\t\t\t       from + vma->vm_end - vma->vm_start);\n\n\t\tif (is_sparsed(ni)) {\n\t\t\t \n\t\t\tstruct ntfs_sb_info *sbi = inode->i_sb->s_fs_info;\n\t\t\tCLST lcn, len;\n\t\t\tCLST vcn = from >> sbi->cluster_bits;\n\t\t\tCLST end = bytes_to_cluster(sbi, to);\n\t\t\tbool new;\n\n\t\t\tfor (; vcn < end; vcn += len) {\n\t\t\t\terr = attr_data_get_block(ni, vcn, 1, &lcn,\n\t\t\t\t\t\t\t  &len, &new, true);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (ni->i_valid < to) {\n\t\t\tif (!inode_trylock(inode)) {\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\terr = ntfs_extend_initialized_size(file, ni,\n\t\t\t\t\t\t\t   ni->i_valid, to);\n\t\t\tinode_unlock(inode);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\terr = generic_file_mmap(file, vma);\nout:\n\treturn err;\n}\n\nstatic int ntfs_extend(struct inode *inode, loff_t pos, size_t count,\n\t\t       struct file *file)\n{\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tstruct address_space *mapping = inode->i_mapping;\n\tloff_t end = pos + count;\n\tbool extend_init = file && pos > ni->i_valid;\n\tint err;\n\n\tif (end <= inode->i_size && !extend_init)\n\t\treturn 0;\n\n\t \n\tntfs_set_state(ni->mi.sbi, NTFS_DIRTY_DIRTY);\n\n\tif (end > inode->i_size) {\n\t\terr = ntfs_set_size(inode, end);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (extend_init && !is_compressed(ni)) {\n\t\terr = ntfs_extend_initialized_size(file, ni, ni->i_valid, pos);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\terr = 0;\n\t}\n\n\tinode->i_mtime = inode_set_ctime_current(inode);\n\tmark_inode_dirty(inode);\n\n\tif (IS_SYNC(inode)) {\n\t\tint err2;\n\n\t\terr = filemap_fdatawrite_range(mapping, pos, end - 1);\n\t\terr2 = sync_mapping_buffers(mapping);\n\t\tif (!err)\n\t\t\terr = err2;\n\t\terr2 = write_inode_now(inode, 1);\n\t\tif (!err)\n\t\t\terr = err2;\n\t\tif (!err)\n\t\t\terr = filemap_fdatawait_range(mapping, pos, end - 1);\n\t}\n\nout:\n\treturn err;\n}\n\nstatic int ntfs_truncate(struct inode *inode, loff_t new_size)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tint err, dirty = 0;\n\tu64 new_valid;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 0;\n\n\tif (is_compressed(ni)) {\n\t\tif (ni->i_valid > new_size)\n\t\t\tni->i_valid = new_size;\n\t} else {\n\t\terr = block_truncate_page(inode->i_mapping, new_size,\n\t\t\t\t\t  ntfs_get_block);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tnew_valid = ntfs_up_block(sb, min_t(u64, ni->i_valid, new_size));\n\n\ttruncate_setsize(inode, new_size);\n\n\tni_lock(ni);\n\n\tdown_write(&ni->file.run_lock);\n\terr = attr_set_size(ni, ATTR_DATA, NULL, 0, &ni->file.run, new_size,\n\t\t\t    &new_valid, ni->mi.sbi->options->prealloc, NULL);\n\tup_write(&ni->file.run_lock);\n\n\tif (new_valid < ni->i_valid)\n\t\tni->i_valid = new_valid;\n\n\tni_unlock(ni);\n\n\tni->std_fa |= FILE_ATTRIBUTE_ARCHIVE;\n\tinode->i_mtime = inode_set_ctime_current(inode);\n\tif (!IS_DIRSYNC(inode)) {\n\t\tdirty = 1;\n\t} else {\n\t\terr = ntfs_sync_inode(inode);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (dirty)\n\t\tmark_inode_dirty(inode);\n\n\t \n\n\treturn 0;\n}\n\n \nstatic long ntfs_fallocate(struct file *file, int mode, loff_t vbo, loff_t len)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ntfs_sb_info *sbi = sb->s_fs_info;\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tloff_t end = vbo + len;\n\tloff_t vbo_down = round_down(vbo, max_t(unsigned long,\n\t\t\t\t\t\tsbi->cluster_size, PAGE_SIZE));\n\tbool is_supported_holes = is_sparsed(ni) || is_compressed(ni);\n\tloff_t i_size, new_size;\n\tbool map_locked;\n\tint err;\n\n\t \n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (mode & FALLOC_FL_PUNCH_HOLE) {\n\t\tif (!is_supported_holes)\n\t\t\treturn -EOPNOTSUPP;\n\t} else if (mode & FALLOC_FL_COLLAPSE_RANGE) {\n\t} else if (mode & FALLOC_FL_INSERT_RANGE) {\n\t\tif (!is_supported_holes)\n\t\t\treturn -EOPNOTSUPP;\n\t} else if (mode &\n\t\t   ~(FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE |\n\t\t     FALLOC_FL_COLLAPSE_RANGE | FALLOC_FL_INSERT_RANGE)) {\n\t\tntfs_inode_warn(inode, \"fallocate(0x%x) is not supported\",\n\t\t\t\tmode);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tntfs_set_state(sbi, NTFS_DIRTY_DIRTY);\n\n\tinode_lock(inode);\n\ti_size = inode->i_size;\n\tnew_size = max(end, i_size);\n\tmap_locked = false;\n\n\tif (WARN_ON(ni->ni_flags & NI_FLAG_COMPRESSED_MASK)) {\n\t\t \n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tif (mode & (FALLOC_FL_PUNCH_HOLE | FALLOC_FL_COLLAPSE_RANGE |\n\t\t    FALLOC_FL_INSERT_RANGE)) {\n\t\tinode_dio_wait(inode);\n\t\tfilemap_invalidate_lock(mapping);\n\t\tmap_locked = true;\n\t}\n\n\tif (mode & FALLOC_FL_PUNCH_HOLE) {\n\t\tu32 frame_size;\n\t\tloff_t mask, vbo_a, end_a, tmp;\n\n\t\terr = filemap_write_and_wait_range(mapping, vbo_down,\n\t\t\t\t\t\t   LLONG_MAX);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\ttruncate_pagecache(inode, vbo_down);\n\n\t\tni_lock(ni);\n\t\terr = attr_punch_hole(ni, vbo, len, &frame_size);\n\t\tni_unlock(ni);\n\t\tif (err != E_NTFS_NOTALIGNED)\n\t\t\tgoto out;\n\n\t\t \n\t\tmask = frame_size - 1;\n\t\tvbo_a = (vbo + mask) & ~mask;\n\t\tend_a = end & ~mask;\n\n\t\ttmp = min(vbo_a, end);\n\t\tif (tmp > vbo) {\n\t\t\terr = ntfs_zero_range(inode, vbo, tmp);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tif (vbo < end_a && end_a < end) {\n\t\t\terr = ntfs_zero_range(inode, end_a, end);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif (end_a > vbo_a) {\n\t\t\tni_lock(ni);\n\t\t\terr = attr_punch_hole(ni, vbo_a, end_a - vbo_a, NULL);\n\t\t\tni_unlock(ni);\n\t\t}\n\t} else if (mode & FALLOC_FL_COLLAPSE_RANGE) {\n\t\t \n\t\terr = filemap_write_and_wait_range(mapping, vbo_down, vbo);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\t \n\t\terr = filemap_write_and_wait_range(mapping, end, LLONG_MAX);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\ttruncate_pagecache(inode, vbo_down);\n\n\t\tni_lock(ni);\n\t\terr = attr_collapse_range(ni, vbo, len);\n\t\tni_unlock(ni);\n\t} else if (mode & FALLOC_FL_INSERT_RANGE) {\n\t\t \n\t\terr = inode_newsize_ok(inode, new_size);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\t \n\t\terr = filemap_write_and_wait_range(mapping, vbo_down,\n\t\t\t\t\t\t   LLONG_MAX);\n\t\tif (err)\n\t\t\tgoto out;\n\t\ttruncate_pagecache(inode, vbo_down);\n\n\t\tni_lock(ni);\n\t\terr = attr_insert_range(ni, vbo, len);\n\t\tni_unlock(ni);\n\t} else {\n\t\t \n\t\tu8 cluster_bits = sbi->cluster_bits;\n\n\t\t \n\t\tif (!is_supported_holes) {\n\t\t\tloff_t to_alloc = new_size - inode_get_bytes(inode);\n\n\t\t\tif (to_alloc > 0 &&\n\t\t\t    (to_alloc >> cluster_bits) >\n\t\t\t\t    wnd_zeroes(&sbi->used.bitmap)) {\n\t\t\t\terr = -ENOSPC;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\terr = inode_newsize_ok(inode, new_size);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tif (new_size > i_size) {\n\t\t\t \n\t\t\terr = ntfs_set_size(inode, new_size);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tif (is_supported_holes) {\n\t\t\tCLST vcn = vbo >> cluster_bits;\n\t\t\tCLST cend = bytes_to_cluster(sbi, end);\n\t\t\tCLST cend_v = bytes_to_cluster(sbi, ni->i_valid);\n\t\t\tCLST lcn, clen;\n\t\t\tbool new;\n\n\t\t\tif (cend_v > cend)\n\t\t\t\tcend_v = cend;\n\n\t\t\t \n\t\t\tfor (; vcn < cend_v; vcn += clen) {\n\t\t\t\terr = attr_data_get_block(ni, vcn, cend_v - vcn,\n\t\t\t\t\t\t\t  &lcn, &clen, &new,\n\t\t\t\t\t\t\t  true);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t \n\t\t\tfor (; vcn < cend; vcn += clen) {\n\t\t\t\terr = attr_data_get_block(ni, vcn, cend - vcn,\n\t\t\t\t\t\t\t  &lcn, &clen, &new,\n\t\t\t\t\t\t\t  false);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (mode & FALLOC_FL_KEEP_SIZE) {\n\t\t\tni_lock(ni);\n\t\t\t \n\t\t\terr = attr_set_size(ni, ATTR_DATA, NULL, 0,\n\t\t\t\t\t    &ni->file.run, i_size, &ni->i_valid,\n\t\t\t\t\t    true, NULL);\n\t\t\tni_unlock(ni);\n\t\t} else if (new_size > i_size) {\n\t\t\tinode->i_size = new_size;\n\t\t}\n\t}\n\nout:\n\tif (map_locked)\n\t\tfilemap_invalidate_unlock(mapping);\n\n\tif (!err) {\n\t\tinode->i_mtime = inode_set_ctime_current(inode);\n\t\tmark_inode_dirty(inode);\n\t}\n\n\tinode_unlock(inode);\n\treturn err;\n}\n\n \nint ntfs3_setattr(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\t  struct iattr *attr)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tu32 ia_valid = attr->ia_valid;\n\tumode_t mode = inode->i_mode;\n\tint err;\n\n\terr = setattr_prepare(idmap, dentry, attr);\n\tif (err)\n\t\tgoto out;\n\n\tif (ia_valid & ATTR_SIZE) {\n\t\tloff_t newsize, oldsize;\n\n\t\tif (WARN_ON(ni->ni_flags & NI_FLAG_COMPRESSED_MASK)) {\n\t\t\t \n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\t\tinode_dio_wait(inode);\n\t\toldsize = inode->i_size;\n\t\tnewsize = attr->ia_size;\n\n\t\tif (newsize <= oldsize)\n\t\t\terr = ntfs_truncate(inode, newsize);\n\t\telse\n\t\t\terr = ntfs_extend(inode, newsize, 0, NULL);\n\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tni->ni_flags |= NI_FLAG_UPDATE_PARENT;\n\t\tinode->i_size = newsize;\n\t}\n\n\tsetattr_copy(idmap, inode, attr);\n\n\tif (mode != inode->i_mode) {\n\t\terr = ntfs_acl_chmod(idmap, dentry);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\t \n\t\tif (0222 & inode->i_mode)\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_READONLY;\n\t\telse\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_READONLY;\n\t}\n\n\tif (ia_valid & (ATTR_UID | ATTR_GID | ATTR_MODE))\n\t\tntfs_save_wsl_perm(inode, NULL);\n\tmark_inode_dirty(inode);\nout:\n\treturn err;\n}\n\nstatic ssize_t ntfs_file_read_iter(struct kiocb *iocb, struct iov_iter *iter)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\n\tif (is_encrypted(ni)) {\n\t\tntfs_inode_warn(inode, \"encrypted i/o not supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (is_compressed(ni) && (iocb->ki_flags & IOCB_DIRECT)) {\n\t\tntfs_inode_warn(inode, \"direct i/o + compressed not supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n#ifndef CONFIG_NTFS3_LZX_XPRESS\n\tif (ni->ni_flags & NI_FLAG_COMPRESSED_MASK) {\n\t\tntfs_inode_warn(\n\t\t\tinode,\n\t\t\t\"activate CONFIG_NTFS3_LZX_XPRESS to read external compressed files\");\n\t\treturn -EOPNOTSUPP;\n\t}\n#endif\n\n\tif (is_dedup(ni)) {\n\t\tntfs_inode_warn(inode, \"read deduplicated not supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn generic_file_read_iter(iocb, iter);\n}\n\nstatic ssize_t ntfs_file_splice_read(struct file *in, loff_t *ppos,\n\t\t\t\t     struct pipe_inode_info *pipe, size_t len,\n\t\t\t\t     unsigned int flags)\n{\n\tstruct inode *inode = in->f_mapping->host;\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\n\tif (is_encrypted(ni)) {\n\t\tntfs_inode_warn(inode, \"encrypted i/o not supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n#ifndef CONFIG_NTFS3_LZX_XPRESS\n\tif (ni->ni_flags & NI_FLAG_COMPRESSED_MASK) {\n\t\tntfs_inode_warn(\n\t\t\tinode,\n\t\t\t\"activate CONFIG_NTFS3_LZX_XPRESS to read external compressed files\");\n\t\treturn -EOPNOTSUPP;\n\t}\n#endif\n\n\tif (is_dedup(ni)) {\n\t\tntfs_inode_warn(inode, \"read deduplicated not supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn filemap_splice_read(in, ppos, pipe, len, flags);\n}\n\n \nstatic int ntfs_get_frame_pages(struct address_space *mapping, pgoff_t index,\n\t\t\t\tstruct page **pages, u32 pages_per_frame,\n\t\t\t\tbool *frame_uptodate)\n{\n\tgfp_t gfp_mask = mapping_gfp_mask(mapping);\n\tu32 npages;\n\n\t*frame_uptodate = true;\n\n\tfor (npages = 0; npages < pages_per_frame; npages++, index++) {\n\t\tstruct page *page;\n\n\t\tpage = find_or_create_page(mapping, index, gfp_mask);\n\t\tif (!page) {\n\t\t\twhile (npages--) {\n\t\t\t\tpage = pages[npages];\n\t\t\t\tunlock_page(page);\n\t\t\t\tput_page(page);\n\t\t\t}\n\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (!PageUptodate(page))\n\t\t\t*frame_uptodate = false;\n\n\t\tpages[npages] = page;\n\t}\n\n\treturn 0;\n}\n\n \nstatic ssize_t ntfs_compress_write(struct kiocb *iocb, struct iov_iter *from)\n{\n\tint err;\n\tstruct file *file = iocb->ki_filp;\n\tsize_t count = iov_iter_count(from);\n\tloff_t pos = iocb->ki_pos;\n\tstruct inode *inode = file_inode(file);\n\tloff_t i_size = inode->i_size;\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tu64 valid = ni->i_valid;\n\tstruct ntfs_sb_info *sbi = ni->mi.sbi;\n\tstruct page *page, **pages = NULL;\n\tsize_t written = 0;\n\tu8 frame_bits = NTFS_LZNT_CUNIT + sbi->cluster_bits;\n\tu32 frame_size = 1u << frame_bits;\n\tu32 pages_per_frame = frame_size >> PAGE_SHIFT;\n\tu32 ip, off;\n\tCLST frame;\n\tu64 frame_vbo;\n\tpgoff_t index;\n\tbool frame_uptodate;\n\n\tif (frame_size < PAGE_SIZE) {\n\t\t \n\t\tntfs_inode_warn(inode, \"page size is bigger than frame size\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tpages = kmalloc_array(pages_per_frame, sizeof(struct page *), GFP_NOFS);\n\tif (!pages)\n\t\treturn -ENOMEM;\n\n\terr = file_remove_privs(file);\n\tif (err)\n\t\tgoto out;\n\n\terr = file_update_time(file);\n\tif (err)\n\t\tgoto out;\n\n\t \n\twhile (valid < pos) {\n\t\tCLST lcn, clen;\n\n\t\tframe = valid >> frame_bits;\n\t\tframe_vbo = valid & ~(frame_size - 1);\n\t\toff = valid & (frame_size - 1);\n\n\t\terr = attr_data_get_block(ni, frame << NTFS_LZNT_CUNIT, 1, &lcn,\n\t\t\t\t\t  &clen, NULL, false);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tif (lcn == SPARSE_LCN) {\n\t\t\tni->i_valid = valid =\n\t\t\t\tframe_vbo + ((u64)clen << sbi->cluster_bits);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\terr = ntfs_get_frame_pages(mapping, frame_vbo >> PAGE_SHIFT,\n\t\t\t\t\t   pages, pages_per_frame,\n\t\t\t\t\t   &frame_uptodate);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tif (!frame_uptodate && off) {\n\t\t\terr = ni_read_frame(ni, frame_vbo, pages,\n\t\t\t\t\t    pages_per_frame);\n\t\t\tif (err) {\n\t\t\t\tfor (ip = 0; ip < pages_per_frame; ip++) {\n\t\t\t\t\tpage = pages[ip];\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tput_page(page);\n\t\t\t\t}\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tip = off >> PAGE_SHIFT;\n\t\toff = offset_in_page(valid);\n\t\tfor (; ip < pages_per_frame; ip++, off = 0) {\n\t\t\tpage = pages[ip];\n\t\t\tzero_user_segment(page, off, PAGE_SIZE);\n\t\t\tflush_dcache_page(page);\n\t\t\tSetPageUptodate(page);\n\t\t}\n\n\t\tni_lock(ni);\n\t\terr = ni_write_frame(ni, pages, pages_per_frame);\n\t\tni_unlock(ni);\n\n\t\tfor (ip = 0; ip < pages_per_frame; ip++) {\n\t\t\tpage = pages[ip];\n\t\t\tSetPageUptodate(page);\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t}\n\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tni->i_valid = valid = frame_vbo + frame_size;\n\t}\n\n\t \n\twhile (count) {\n\t\tsize_t copied, bytes;\n\n\t\toff = pos & (frame_size - 1);\n\t\tbytes = frame_size - off;\n\t\tif (bytes > count)\n\t\t\tbytes = count;\n\n\t\tframe_vbo = pos & ~(frame_size - 1);\n\t\tindex = frame_vbo >> PAGE_SHIFT;\n\n\t\tif (unlikely(fault_in_iov_iter_readable(from, bytes))) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\terr = ntfs_get_frame_pages(mapping, index, pages,\n\t\t\t\t\t   pages_per_frame, &frame_uptodate);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tif (!frame_uptodate) {\n\t\t\tloff_t to = pos + bytes;\n\n\t\t\tif (off || (to < i_size && (to & (frame_size - 1)))) {\n\t\t\t\terr = ni_read_frame(ni, frame_vbo, pages,\n\t\t\t\t\t\t    pages_per_frame);\n\t\t\t\tif (err) {\n\t\t\t\t\tfor (ip = 0; ip < pages_per_frame;\n\t\t\t\t\t     ip++) {\n\t\t\t\t\t\tpage = pages[ip];\n\t\t\t\t\t\tunlock_page(page);\n\t\t\t\t\t\tput_page(page);\n\t\t\t\t\t}\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tWARN_ON(!bytes);\n\t\tcopied = 0;\n\t\tip = off >> PAGE_SHIFT;\n\t\toff = offset_in_page(pos);\n\n\t\t \n\t\tfor (;;) {\n\t\t\tsize_t cp, tail = PAGE_SIZE - off;\n\n\t\t\tpage = pages[ip];\n\t\t\tcp = copy_page_from_iter_atomic(page, off,\n\t\t\t\t\t\t\tmin(tail, bytes), from);\n\t\t\tflush_dcache_page(page);\n\n\t\t\tcopied += cp;\n\t\t\tbytes -= cp;\n\t\t\tif (!bytes || !cp)\n\t\t\t\tbreak;\n\n\t\t\tif (cp < tail) {\n\t\t\t\toff += cp;\n\t\t\t} else {\n\t\t\t\tip++;\n\t\t\t\toff = 0;\n\t\t\t}\n\t\t}\n\n\t\tni_lock(ni);\n\t\terr = ni_write_frame(ni, pages, pages_per_frame);\n\t\tni_unlock(ni);\n\n\t\tfor (ip = 0; ip < pages_per_frame; ip++) {\n\t\t\tpage = pages[ip];\n\t\t\tClearPageDirty(page);\n\t\t\tSetPageUptodate(page);\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t}\n\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\t \n\t\tcond_resched();\n\n\t\tpos += copied;\n\t\twritten += copied;\n\n\t\tcount = iov_iter_count(from);\n\t}\n\nout:\n\tkfree(pages);\n\n\tif (err < 0)\n\t\treturn err;\n\n\tiocb->ki_pos += written;\n\tif (iocb->ki_pos > ni->i_valid)\n\t\tni->i_valid = iocb->ki_pos;\n\n\treturn written;\n}\n\n \nstatic ssize_t ntfs_file_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tssize_t ret;\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\n\tif (is_encrypted(ni)) {\n\t\tntfs_inode_warn(inode, \"encrypted i/o not supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (is_compressed(ni) && (iocb->ki_flags & IOCB_DIRECT)) {\n\t\tntfs_inode_warn(inode, \"direct i/o + compressed not supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (is_dedup(ni)) {\n\t\tntfs_inode_warn(inode, \"write into deduplicated not supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!inode_trylock(inode)) {\n\t\tif (iocb->ki_flags & IOCB_NOWAIT)\n\t\t\treturn -EAGAIN;\n\t\tinode_lock(inode);\n\t}\n\n\tret = generic_write_checks(iocb, from);\n\tif (ret <= 0)\n\t\tgoto out;\n\n\tif (WARN_ON(ni->ni_flags & NI_FLAG_COMPRESSED_MASK)) {\n\t\t \n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tret = ntfs_extend(inode, iocb->ki_pos, ret, file);\n\tif (ret)\n\t\tgoto out;\n\n\tret = is_compressed(ni) ? ntfs_compress_write(iocb, from) :\n\t\t\t\t  __generic_file_write_iter(iocb, from);\n\nout:\n\tinode_unlock(inode);\n\n\tif (ret > 0)\n\t\tret = generic_write_sync(iocb, ret);\n\n\treturn ret;\n}\n\n \nint ntfs_file_open(struct inode *inode, struct file *file)\n{\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\n\tif (unlikely((is_compressed(ni) || is_encrypted(ni)) &&\n\t\t     (file->f_flags & O_DIRECT))) {\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tif ((ni->ni_flags & NI_FLAG_COMPRESSED_MASK) &&\n\t    (file->f_flags & (O_WRONLY | O_RDWR | O_TRUNC))) {\n#ifdef CONFIG_NTFS3_LZX_XPRESS\n\t\tint err = ni_decompress_file(ni);\n\n\t\tif (err)\n\t\t\treturn err;\n#else\n\t\tntfs_inode_warn(\n\t\t\tinode,\n\t\t\t\"activate CONFIG_NTFS3_LZX_XPRESS to write external compressed files\");\n\t\treturn -EOPNOTSUPP;\n#endif\n\t}\n\n\treturn generic_file_open(inode, file);\n}\n\n \nstatic int ntfs_file_release(struct inode *inode, struct file *file)\n{\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tstruct ntfs_sb_info *sbi = ni->mi.sbi;\n\tint err = 0;\n\n\t \n\tif (sbi->options->prealloc &&\n\t    ((file->f_mode & FMODE_WRITE) &&\n\t     atomic_read(&inode->i_writecount) == 1)) {\n\t\tni_lock(ni);\n\t\tdown_write(&ni->file.run_lock);\n\n\t\terr = attr_set_size(ni, ATTR_DATA, NULL, 0, &ni->file.run,\n\t\t\t\t    inode->i_size, &ni->i_valid, false, NULL);\n\n\t\tup_write(&ni->file.run_lock);\n\t\tni_unlock(ni);\n\t}\n\treturn err;\n}\n\n \nint ntfs_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t__u64 start, __u64 len)\n{\n\tint err;\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\n\terr = fiemap_prep(inode, fieinfo, start, &len, ~FIEMAP_FLAG_XATTR);\n\tif (err)\n\t\treturn err;\n\n\tni_lock(ni);\n\n\terr = ni_fiemap(ni, fieinfo, start, len);\n\n\tni_unlock(ni);\n\n\treturn err;\n}\n\n\nconst struct inode_operations ntfs_file_inode_operations = {\n\t.getattr\t= ntfs_getattr,\n\t.setattr\t= ntfs3_setattr,\n\t.listxattr\t= ntfs_listxattr,\n\t.get_acl\t= ntfs_get_acl,\n\t.set_acl\t= ntfs_set_acl,\n\t.fiemap\t\t= ntfs_fiemap,\n};\n\nconst struct file_operations ntfs_file_operations = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read_iter\t= ntfs_file_read_iter,\n\t.write_iter\t= ntfs_file_write_iter,\n\t.unlocked_ioctl = ntfs_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t= ntfs_compat_ioctl,\n#endif\n\t.splice_read\t= ntfs_file_splice_read,\n\t.mmap\t\t= ntfs_file_mmap,\n\t.open\t\t= ntfs_file_open,\n\t.fsync\t\t= generic_file_fsync,\n\t.splice_write\t= iter_file_splice_write,\n\t.fallocate\t= ntfs_fallocate,\n\t.release\t= ntfs_file_release,\n};\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}