{
  "module_name": "bitmap.c",
  "hash_id": "65cc5b0dc8258e839997d12cb1b5940470a48474e600e80c7b3485e93b3c82a7",
  "original_prompt": "Ingested from linux-6.6.14/fs/ntfs3/bitmap.c",
  "human_readable_source": "\n \n\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\n#include \"ntfs.h\"\n#include \"ntfs_fs.h\"\n\n \n#define NTFS_MAX_WND_EXTENTS (32u * 1024u)\n\nstruct rb_node_key {\n\tstruct rb_node node;\n\tsize_t key;\n};\n\nstruct e_node {\n\tstruct rb_node_key start;  \n\tstruct rb_node_key count;  \n};\n\nstatic int wnd_rescan(struct wnd_bitmap *wnd);\nstatic struct buffer_head *wnd_map(struct wnd_bitmap *wnd, size_t iw);\nstatic bool wnd_is_free_hlp(struct wnd_bitmap *wnd, size_t bit, size_t bits);\n\nstatic struct kmem_cache *ntfs_enode_cachep;\n\nint __init ntfs3_init_bitmap(void)\n{\n\tntfs_enode_cachep = kmem_cache_create(\"ntfs3_enode_cache\",\n\t\t\t\t\t      sizeof(struct e_node), 0,\n\t\t\t\t\t      SLAB_RECLAIM_ACCOUNT, NULL);\n\treturn ntfs_enode_cachep ? 0 : -ENOMEM;\n}\n\nvoid ntfs3_exit_bitmap(void)\n{\n\tkmem_cache_destroy(ntfs_enode_cachep);\n}\n\n \nstatic size_t wnd_scan(const void *buf, size_t wbit, u32 wpos, u32 wend,\n\t\t       size_t to_alloc, size_t *prev_tail, size_t *b_pos,\n\t\t       size_t *b_len)\n{\n\twhile (wpos < wend) {\n\t\tsize_t free_len;\n\t\tu32 free_bits, end;\n\t\tu32 used = find_next_zero_bit_le(buf, wend, wpos);\n\n\t\tif (used >= wend) {\n\t\t\tif (*b_len < *prev_tail) {\n\t\t\t\t*b_pos = wbit - *prev_tail;\n\t\t\t\t*b_len = *prev_tail;\n\t\t\t}\n\n\t\t\t*prev_tail = 0;\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (used > wpos) {\n\t\t\twpos = used;\n\t\t\tif (*b_len < *prev_tail) {\n\t\t\t\t*b_pos = wbit - *prev_tail;\n\t\t\t\t*b_len = *prev_tail;\n\t\t\t}\n\n\t\t\t*prev_tail = 0;\n\t\t}\n\n\t\t \n\t\tend = wpos + to_alloc - *prev_tail;\n\t\tfree_bits = find_next_bit_le(buf, min(end, wend), wpos);\n\n\t\tfree_len = *prev_tail + free_bits - wpos;\n\n\t\tif (*b_len < free_len) {\n\t\t\t*b_pos = wbit + wpos - *prev_tail;\n\t\t\t*b_len = free_len;\n\t\t}\n\n\t\tif (free_len >= to_alloc)\n\t\t\treturn wbit + wpos - *prev_tail;\n\n\t\tif (free_bits >= wend) {\n\t\t\t*prev_tail += free_bits - wpos;\n\t\t\treturn -1;\n\t\t}\n\n\t\twpos = free_bits + 1;\n\n\t\t*prev_tail = 0;\n\t}\n\n\treturn -1;\n}\n\n \nvoid wnd_close(struct wnd_bitmap *wnd)\n{\n\tstruct rb_node *node, *next;\n\n\tkfree(wnd->free_bits);\n\twnd->free_bits = NULL;\n\trun_close(&wnd->run);\n\n\tnode = rb_first(&wnd->start_tree);\n\n\twhile (node) {\n\t\tnext = rb_next(node);\n\t\trb_erase(node, &wnd->start_tree);\n\t\tkmem_cache_free(ntfs_enode_cachep,\n\t\t\t\trb_entry(node, struct e_node, start.node));\n\t\tnode = next;\n\t}\n}\n\nstatic struct rb_node *rb_lookup(struct rb_root *root, size_t v)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *r = NULL;\n\n\twhile (*p) {\n\t\tstruct rb_node_key *k;\n\n\t\tk = rb_entry(*p, struct rb_node_key, node);\n\t\tif (v < k->key) {\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (v > k->key) {\n\t\t\tr = &k->node;\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\treturn &k->node;\n\t\t}\n\t}\n\n\treturn r;\n}\n\n \nstatic inline bool rb_insert_count(struct rb_root *root, struct e_node *e)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent = NULL;\n\tsize_t e_ckey = e->count.key;\n\tsize_t e_skey = e->start.key;\n\n\twhile (*p) {\n\t\tstruct e_node *k =\n\t\t\trb_entry(parent = *p, struct e_node, count.node);\n\n\t\tif (e_ckey > k->count.key) {\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (e_ckey < k->count.key) {\n\t\t\tp = &(*p)->rb_right;\n\t\t} else if (e_skey < k->start.key) {\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (e_skey > k->start.key) {\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\tWARN_ON(1);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\trb_link_node(&e->count.node, parent, p);\n\trb_insert_color(&e->count.node, root);\n\treturn true;\n}\n\n \nstatic inline bool rb_insert_start(struct rb_root *root, struct e_node *e)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent = NULL;\n\tsize_t e_skey = e->start.key;\n\n\twhile (*p) {\n\t\tstruct e_node *k;\n\n\t\tparent = *p;\n\n\t\tk = rb_entry(parent, struct e_node, start.node);\n\t\tif (e_skey < k->start.key) {\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (e_skey > k->start.key) {\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\tWARN_ON(1);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\trb_link_node(&e->start.node, parent, p);\n\trb_insert_color(&e->start.node, root);\n\treturn true;\n}\n\n \nstatic void wnd_add_free_ext(struct wnd_bitmap *wnd, size_t bit, size_t len,\n\t\t\t     bool build)\n{\n\tstruct e_node *e, *e0 = NULL;\n\tsize_t ib, end_in = bit + len;\n\tstruct rb_node *n;\n\n\tif (build) {\n\t\t \n\t\tif (wnd->count >= NTFS_MAX_WND_EXTENTS &&\n\t\t    len <= wnd->extent_min) {\n\t\t\twnd->uptodated = -1;\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\t \n\t\tn = rb_lookup(&wnd->start_tree, bit);\n\n\t\tif (!n) {\n\t\t\tn = rb_first(&wnd->start_tree);\n\t\t} else {\n\t\t\te = rb_entry(n, struct e_node, start.node);\n\t\t\tn = rb_next(n);\n\t\t\tif (e->start.key + e->count.key == bit) {\n\t\t\t\t \n\t\t\t\tbit = e->start.key;\n\t\t\t\tlen += e->count.key;\n\t\t\t\trb_erase(&e->start.node, &wnd->start_tree);\n\t\t\t\trb_erase(&e->count.node, &wnd->count_tree);\n\t\t\t\twnd->count -= 1;\n\t\t\t\te0 = e;\n\t\t\t}\n\t\t}\n\n\t\twhile (n) {\n\t\t\tsize_t next_end;\n\n\t\t\te = rb_entry(n, struct e_node, start.node);\n\t\t\tnext_end = e->start.key + e->count.key;\n\t\t\tif (e->start.key > end_in)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tn = rb_next(n);\n\t\t\tlen += next_end - end_in;\n\t\t\tend_in = next_end;\n\t\t\trb_erase(&e->start.node, &wnd->start_tree);\n\t\t\trb_erase(&e->count.node, &wnd->count_tree);\n\t\t\twnd->count -= 1;\n\n\t\t\tif (!e0)\n\t\t\t\te0 = e;\n\t\t\telse\n\t\t\t\tkmem_cache_free(ntfs_enode_cachep, e);\n\t\t}\n\n\t\tif (wnd->uptodated != 1) {\n\t\t\t \n\t\t\tib = wnd->zone_bit == wnd->zone_end ||\n\t\t\t\t\t     bit < wnd->zone_end ?\n\t\t\t\t     0 :\n\t\t\t\t     wnd->zone_end;\n\n\t\t\twhile (bit > ib && wnd_is_free_hlp(wnd, bit - 1, 1)) {\n\t\t\t\tbit -= 1;\n\t\t\t\tlen += 1;\n\t\t\t}\n\n\t\t\t \n\t\t\tib = wnd->zone_bit == wnd->zone_end ||\n\t\t\t\t\t     end_in > wnd->zone_bit ?\n\t\t\t\t     wnd->nbits :\n\t\t\t\t     wnd->zone_bit;\n\n\t\t\twhile (end_in < ib && wnd_is_free_hlp(wnd, end_in, 1)) {\n\t\t\t\tend_in += 1;\n\t\t\t\tlen += 1;\n\t\t\t}\n\t\t}\n\t}\n\t \n\tif (wnd->count >= NTFS_MAX_WND_EXTENTS) {\n\t\tif (e0)\n\t\t\tkmem_cache_free(ntfs_enode_cachep, e0);\n\n\t\twnd->uptodated = -1;\n\n\t\t \n\t\tn = rb_last(&wnd->count_tree);\n\t\te = rb_entry(n, struct e_node, count.node);\n\t\tif (len <= e->count.key)\n\t\t\tgoto out;  \n\n\t\tif (build) {\n\t\t\tstruct e_node *e2;\n\n\t\t\tn = rb_prev(n);\n\t\t\te2 = rb_entry(n, struct e_node, count.node);\n\t\t\t \n\t\t\twnd->extent_min = e2->count.key;\n\t\t}\n\n\t\t \n\t\trb_erase(&e->start.node, &wnd->start_tree);\n\t\trb_erase(&e->count.node, &wnd->count_tree);\n\t\twnd->count -= 1;\n\t} else {\n\t\te = e0 ? e0 : kmem_cache_alloc(ntfs_enode_cachep, GFP_ATOMIC);\n\t\tif (!e) {\n\t\t\twnd->uptodated = -1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (build && len <= wnd->extent_min)\n\t\t\twnd->extent_min = len;\n\t}\n\te->start.key = bit;\n\te->count.key = len;\n\tif (len > wnd->extent_max)\n\t\twnd->extent_max = len;\n\n\trb_insert_start(&wnd->start_tree, e);\n\trb_insert_count(&wnd->count_tree, e);\n\twnd->count += 1;\n\nout:;\n}\n\n \nstatic void wnd_remove_free_ext(struct wnd_bitmap *wnd, size_t bit, size_t len)\n{\n\tstruct rb_node *n, *n3;\n\tstruct e_node *e, *e3;\n\tsize_t end_in = bit + len;\n\tsize_t end3, end, new_key, new_len, max_new_len;\n\n\t \n\tn = rb_lookup(&wnd->start_tree, bit);\n\n\tif (!n)\n\t\treturn;\n\n\te = rb_entry(n, struct e_node, start.node);\n\tend = e->start.key + e->count.key;\n\n\tnew_key = new_len = 0;\n\tlen = e->count.key;\n\n\t \n\tif (e->start.key > bit)\n\t\t;\n\telse if (end_in <= end) {\n\t\t \n\t\tnew_key = end_in;\n\t\tnew_len = end - end_in;\n\t\tlen = bit - e->start.key;\n\t} else if (bit > end) {\n\t\tbool bmax = false;\n\n\t\tn3 = rb_next(n);\n\n\t\twhile (n3) {\n\t\t\te3 = rb_entry(n3, struct e_node, start.node);\n\t\t\tif (e3->start.key >= end_in)\n\t\t\t\tbreak;\n\n\t\t\tif (e3->count.key == wnd->extent_max)\n\t\t\t\tbmax = true;\n\n\t\t\tend3 = e3->start.key + e3->count.key;\n\t\t\tif (end3 > end_in) {\n\t\t\t\te3->start.key = end_in;\n\t\t\t\trb_erase(&e3->count.node, &wnd->count_tree);\n\t\t\t\te3->count.key = end3 - end_in;\n\t\t\t\trb_insert_count(&wnd->count_tree, e3);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tn3 = rb_next(n3);\n\t\t\trb_erase(&e3->start.node, &wnd->start_tree);\n\t\t\trb_erase(&e3->count.node, &wnd->count_tree);\n\t\t\twnd->count -= 1;\n\t\t\tkmem_cache_free(ntfs_enode_cachep, e3);\n\t\t}\n\t\tif (!bmax)\n\t\t\treturn;\n\t\tn3 = rb_first(&wnd->count_tree);\n\t\twnd->extent_max =\n\t\t\tn3 ? rb_entry(n3, struct e_node, count.node)->count.key :\n\t\t\t     0;\n\t\treturn;\n\t}\n\n\tif (e->count.key != wnd->extent_max) {\n\t\t;\n\t} else if (rb_prev(&e->count.node)) {\n\t\t;\n\t} else {\n\t\tn3 = rb_next(&e->count.node);\n\t\tmax_new_len = max(len, new_len);\n\t\tif (!n3) {\n\t\t\twnd->extent_max = max_new_len;\n\t\t} else {\n\t\t\te3 = rb_entry(n3, struct e_node, count.node);\n\t\t\twnd->extent_max = max(e3->count.key, max_new_len);\n\t\t}\n\t}\n\n\tif (!len) {\n\t\tif (new_len) {\n\t\t\te->start.key = new_key;\n\t\t\trb_erase(&e->count.node, &wnd->count_tree);\n\t\t\te->count.key = new_len;\n\t\t\trb_insert_count(&wnd->count_tree, e);\n\t\t} else {\n\t\t\trb_erase(&e->start.node, &wnd->start_tree);\n\t\t\trb_erase(&e->count.node, &wnd->count_tree);\n\t\t\twnd->count -= 1;\n\t\t\tkmem_cache_free(ntfs_enode_cachep, e);\n\t\t}\n\t\tgoto out;\n\t}\n\trb_erase(&e->count.node, &wnd->count_tree);\n\te->count.key = len;\n\trb_insert_count(&wnd->count_tree, e);\n\n\tif (!new_len)\n\t\tgoto out;\n\n\tif (wnd->count >= NTFS_MAX_WND_EXTENTS) {\n\t\twnd->uptodated = -1;\n\n\t\t \n\t\te = rb_entry(rb_last(&wnd->count_tree), struct e_node,\n\t\t\t     count.node);\n\t\tif (e->count.key > new_len)\n\t\t\tgoto out;\n\n\t\t \n\t\trb_erase(&e->start.node, &wnd->start_tree);\n\t\trb_erase(&e->count.node, &wnd->count_tree);\n\t\twnd->count -= 1;\n\t} else {\n\t\te = kmem_cache_alloc(ntfs_enode_cachep, GFP_ATOMIC);\n\t\tif (!e)\n\t\t\twnd->uptodated = -1;\n\t}\n\n\tif (e) {\n\t\te->start.key = new_key;\n\t\te->count.key = new_len;\n\t\trb_insert_start(&wnd->start_tree, e);\n\t\trb_insert_count(&wnd->count_tree, e);\n\t\twnd->count += 1;\n\t}\n\nout:\n\tif (!wnd->count && 1 != wnd->uptodated)\n\t\twnd_rescan(wnd);\n}\n\n \nstatic int wnd_rescan(struct wnd_bitmap *wnd)\n{\n\tint err = 0;\n\tsize_t prev_tail = 0;\n\tstruct super_block *sb = wnd->sb;\n\tstruct ntfs_sb_info *sbi = sb->s_fs_info;\n\tu64 lbo, len = 0;\n\tu32 blocksize = sb->s_blocksize;\n\tu8 cluster_bits = sbi->cluster_bits;\n\tu32 wbits = 8 * sb->s_blocksize;\n\tu32 used, frb;\n\tsize_t wpos, wbit, iw, vbo;\n\tstruct buffer_head *bh = NULL;\n\tCLST lcn, clen;\n\n\twnd->uptodated = 0;\n\twnd->extent_max = 0;\n\twnd->extent_min = MINUS_ONE_T;\n\twnd->total_zeroes = 0;\n\n\tvbo = 0;\n\n\tfor (iw = 0; iw < wnd->nwnd; iw++) {\n\t\tif (iw + 1 == wnd->nwnd)\n\t\t\twbits = wnd->bits_last;\n\n\t\tif (wnd->inited) {\n\t\t\tif (!wnd->free_bits[iw]) {\n\t\t\t\t \n\t\t\t\tif (prev_tail) {\n\t\t\t\t\twnd_add_free_ext(wnd,\n\t\t\t\t\t\t\t vbo * 8 - prev_tail,\n\t\t\t\t\t\t\t prev_tail, true);\n\t\t\t\t\tprev_tail = 0;\n\t\t\t\t}\n\t\t\t\tgoto next_wnd;\n\t\t\t}\n\t\t\tif (wbits == wnd->free_bits[iw]) {\n\t\t\t\t \n\t\t\t\tprev_tail += wbits;\n\t\t\t\twnd->total_zeroes += wbits;\n\t\t\t\tgoto next_wnd;\n\t\t\t}\n\t\t}\n\n\t\tif (!len) {\n\t\t\tu32 off = vbo & sbi->cluster_mask;\n\n\t\t\tif (!run_lookup_entry(&wnd->run, vbo >> cluster_bits,\n\t\t\t\t\t      &lcn, &clen, NULL)) {\n\t\t\t\terr = -ENOENT;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tlbo = ((u64)lcn << cluster_bits) + off;\n\t\t\tlen = ((u64)clen << cluster_bits) - off;\n\t\t}\n\n\t\tbh = ntfs_bread(sb, lbo >> sb->s_blocksize_bits);\n\t\tif (!bh) {\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\tused = ntfs_bitmap_weight_le(bh->b_data, wbits);\n\t\tif (used < wbits) {\n\t\t\tfrb = wbits - used;\n\t\t\twnd->free_bits[iw] = frb;\n\t\t\twnd->total_zeroes += frb;\n\t\t}\n\n\t\twpos = 0;\n\t\twbit = vbo * 8;\n\n\t\tif (wbit + wbits > wnd->nbits)\n\t\t\twbits = wnd->nbits - wbit;\n\n\t\tdo {\n\t\t\tused = find_next_zero_bit_le(bh->b_data, wbits, wpos);\n\n\t\t\tif (used > wpos && prev_tail) {\n\t\t\t\twnd_add_free_ext(wnd, wbit + wpos - prev_tail,\n\t\t\t\t\t\t prev_tail, true);\n\t\t\t\tprev_tail = 0;\n\t\t\t}\n\n\t\t\twpos = used;\n\n\t\t\tif (wpos >= wbits) {\n\t\t\t\t \n\t\t\t\tprev_tail = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfrb = find_next_bit_le(bh->b_data, wbits, wpos);\n\t\t\tif (frb >= wbits) {\n\t\t\t\t \n\t\t\t\tprev_tail += frb - wpos;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\twnd_add_free_ext(wnd, wbit + wpos - prev_tail,\n\t\t\t\t\t frb + prev_tail - wpos, true);\n\n\t\t\t \n\t\t\twpos = frb + 1;\n\t\t\t \n\t\t\tprev_tail = 0;\n\t\t} while (wpos < wbits);\n\nnext_wnd:\n\n\t\tif (bh)\n\t\t\tput_bh(bh);\n\t\tbh = NULL;\n\n\t\tvbo += blocksize;\n\t\tif (len) {\n\t\t\tlen -= blocksize;\n\t\t\tlbo += blocksize;\n\t\t}\n\t}\n\n\t \n\tif (prev_tail)\n\t\twnd_add_free_ext(wnd, wnd->nbits - prev_tail, prev_tail, true);\n\n\t \n\tif (!wnd->uptodated)\n\t\twnd->uptodated = 1;\n\n\tif (wnd->zone_bit != wnd->zone_end) {\n\t\tsize_t zlen = wnd->zone_end - wnd->zone_bit;\n\n\t\twnd->zone_end = wnd->zone_bit;\n\t\twnd_zone_set(wnd, wnd->zone_bit, zlen);\n\t}\n\nout:\n\treturn err;\n}\n\nint wnd_init(struct wnd_bitmap *wnd, struct super_block *sb, size_t nbits)\n{\n\tint err;\n\tu32 blocksize = sb->s_blocksize;\n\tu32 wbits = blocksize * 8;\n\n\tinit_rwsem(&wnd->rw_lock);\n\n\twnd->sb = sb;\n\twnd->nbits = nbits;\n\twnd->total_zeroes = nbits;\n\twnd->extent_max = MINUS_ONE_T;\n\twnd->zone_bit = wnd->zone_end = 0;\n\twnd->nwnd = bytes_to_block(sb, bitmap_size(nbits));\n\twnd->bits_last = nbits & (wbits - 1);\n\tif (!wnd->bits_last)\n\t\twnd->bits_last = wbits;\n\n\twnd->free_bits =\n\t\tkvmalloc_array(wnd->nwnd, sizeof(u16), GFP_KERNEL | __GFP_ZERO);\n\n\tif (!wnd->free_bits)\n\t\treturn -ENOMEM;\n\n\terr = wnd_rescan(wnd);\n\tif (err)\n\t\treturn err;\n\n\twnd->inited = true;\n\n\treturn 0;\n}\n\n \nstatic struct buffer_head *wnd_map(struct wnd_bitmap *wnd, size_t iw)\n{\n\tsize_t vbo;\n\tCLST lcn, clen;\n\tstruct super_block *sb = wnd->sb;\n\tstruct ntfs_sb_info *sbi;\n\tstruct buffer_head *bh;\n\tu64 lbo;\n\n\tsbi = sb->s_fs_info;\n\tvbo = (u64)iw << sb->s_blocksize_bits;\n\n\tif (!run_lookup_entry(&wnd->run, vbo >> sbi->cluster_bits, &lcn, &clen,\n\t\t\t      NULL)) {\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\tlbo = ((u64)lcn << sbi->cluster_bits) + (vbo & sbi->cluster_mask);\n\n\tbh = ntfs_bread(wnd->sb, lbo >> sb->s_blocksize_bits);\n\tif (!bh)\n\t\treturn ERR_PTR(-EIO);\n\n\treturn bh;\n}\n\n \nint wnd_set_free(struct wnd_bitmap *wnd, size_t bit, size_t bits)\n{\n\tint err = 0;\n\tstruct super_block *sb = wnd->sb;\n\tsize_t bits0 = bits;\n\tu32 wbits = 8 * sb->s_blocksize;\n\tsize_t iw = bit >> (sb->s_blocksize_bits + 3);\n\tu32 wbit = bit & (wbits - 1);\n\tstruct buffer_head *bh;\n\n\twhile (iw < wnd->nwnd && bits) {\n\t\tu32 tail, op;\n\n\t\tif (iw + 1 == wnd->nwnd)\n\t\t\twbits = wnd->bits_last;\n\n\t\ttail = wbits - wbit;\n\t\top = min_t(u32, tail, bits);\n\n\t\tbh = wnd_map(wnd, iw);\n\t\tif (IS_ERR(bh)) {\n\t\t\terr = PTR_ERR(bh);\n\t\t\tbreak;\n\t\t}\n\n\t\tlock_buffer(bh);\n\n\t\tntfs_bitmap_clear_le(bh->b_data, wbit, op);\n\n\t\twnd->free_bits[iw] += op;\n\n\t\tset_buffer_uptodate(bh);\n\t\tmark_buffer_dirty(bh);\n\t\tunlock_buffer(bh);\n\t\tput_bh(bh);\n\n\t\twnd->total_zeroes += op;\n\t\tbits -= op;\n\t\twbit = 0;\n\t\tiw += 1;\n\t}\n\n\twnd_add_free_ext(wnd, bit, bits0, false);\n\n\treturn err;\n}\n\n \nint wnd_set_used(struct wnd_bitmap *wnd, size_t bit, size_t bits)\n{\n\tint err = 0;\n\tstruct super_block *sb = wnd->sb;\n\tsize_t bits0 = bits;\n\tsize_t iw = bit >> (sb->s_blocksize_bits + 3);\n\tu32 wbits = 8 * sb->s_blocksize;\n\tu32 wbit = bit & (wbits - 1);\n\tstruct buffer_head *bh;\n\n\twhile (iw < wnd->nwnd && bits) {\n\t\tu32 tail, op;\n\n\t\tif (unlikely(iw + 1 == wnd->nwnd))\n\t\t\twbits = wnd->bits_last;\n\n\t\ttail = wbits - wbit;\n\t\top = min_t(u32, tail, bits);\n\n\t\tbh = wnd_map(wnd, iw);\n\t\tif (IS_ERR(bh)) {\n\t\t\terr = PTR_ERR(bh);\n\t\t\tbreak;\n\t\t}\n\n\t\tlock_buffer(bh);\n\n\t\tntfs_bitmap_set_le(bh->b_data, wbit, op);\n\t\twnd->free_bits[iw] -= op;\n\n\t\tset_buffer_uptodate(bh);\n\t\tmark_buffer_dirty(bh);\n\t\tunlock_buffer(bh);\n\t\tput_bh(bh);\n\n\t\twnd->total_zeroes -= op;\n\t\tbits -= op;\n\t\twbit = 0;\n\t\tiw += 1;\n\t}\n\n\tif (!RB_EMPTY_ROOT(&wnd->start_tree))\n\t\twnd_remove_free_ext(wnd, bit, bits0);\n\n\treturn err;\n}\n\n \nint wnd_set_used_safe(struct wnd_bitmap *wnd, size_t bit, size_t bits,\n\t\t      size_t *done)\n{\n\tsize_t i, from = 0, len = 0;\n\tint err = 0;\n\n\t*done = 0;\n\tfor (i = 0; i < bits; i++) {\n\t\tif (wnd_is_free(wnd, bit + i, 1)) {\n\t\t\tif (!len)\n\t\t\t\tfrom = bit + i;\n\t\t\tlen += 1;\n\t\t} else if (len) {\n\t\t\terr = wnd_set_used(wnd, from, len);\n\t\t\t*done += len;\n\t\t\tlen = 0;\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (len) {\n\t\t \n\t\terr = wnd_set_used(wnd, from, len);\n\t\t*done += len;\n\t}\n\treturn err;\n}\n\n \nstatic bool wnd_is_free_hlp(struct wnd_bitmap *wnd, size_t bit, size_t bits)\n{\n\tstruct super_block *sb = wnd->sb;\n\tsize_t iw = bit >> (sb->s_blocksize_bits + 3);\n\tu32 wbits = 8 * sb->s_blocksize;\n\tu32 wbit = bit & (wbits - 1);\n\n\twhile (iw < wnd->nwnd && bits) {\n\t\tu32 tail, op;\n\n\t\tif (unlikely(iw + 1 == wnd->nwnd))\n\t\t\twbits = wnd->bits_last;\n\n\t\ttail = wbits - wbit;\n\t\top = min_t(u32, tail, bits);\n\n\t\tif (wbits != wnd->free_bits[iw]) {\n\t\t\tbool ret;\n\t\t\tstruct buffer_head *bh = wnd_map(wnd, iw);\n\n\t\t\tif (IS_ERR(bh))\n\t\t\t\treturn false;\n\n\t\t\tret = are_bits_clear(bh->b_data, wbit, op);\n\n\t\t\tput_bh(bh);\n\t\t\tif (!ret)\n\t\t\t\treturn false;\n\t\t}\n\n\t\tbits -= op;\n\t\twbit = 0;\n\t\tiw += 1;\n\t}\n\n\treturn true;\n}\n\n \nbool wnd_is_free(struct wnd_bitmap *wnd, size_t bit, size_t bits)\n{\n\tbool ret;\n\tstruct rb_node *n;\n\tsize_t end;\n\tstruct e_node *e;\n\n\tif (RB_EMPTY_ROOT(&wnd->start_tree))\n\t\tgoto use_wnd;\n\n\tn = rb_lookup(&wnd->start_tree, bit);\n\tif (!n)\n\t\tgoto use_wnd;\n\n\te = rb_entry(n, struct e_node, start.node);\n\n\tend = e->start.key + e->count.key;\n\n\tif (bit < end && bit + bits <= end)\n\t\treturn true;\n\nuse_wnd:\n\tret = wnd_is_free_hlp(wnd, bit, bits);\n\n\treturn ret;\n}\n\n \nbool wnd_is_used(struct wnd_bitmap *wnd, size_t bit, size_t bits)\n{\n\tbool ret = false;\n\tstruct super_block *sb = wnd->sb;\n\tsize_t iw = bit >> (sb->s_blocksize_bits + 3);\n\tu32 wbits = 8 * sb->s_blocksize;\n\tu32 wbit = bit & (wbits - 1);\n\tsize_t end;\n\tstruct rb_node *n;\n\tstruct e_node *e;\n\n\tif (RB_EMPTY_ROOT(&wnd->start_tree))\n\t\tgoto use_wnd;\n\n\tend = bit + bits;\n\tn = rb_lookup(&wnd->start_tree, end - 1);\n\tif (!n)\n\t\tgoto use_wnd;\n\n\te = rb_entry(n, struct e_node, start.node);\n\tif (e->start.key + e->count.key > bit)\n\t\treturn false;\n\nuse_wnd:\n\twhile (iw < wnd->nwnd && bits) {\n\t\tu32 tail, op;\n\n\t\tif (unlikely(iw + 1 == wnd->nwnd))\n\t\t\twbits = wnd->bits_last;\n\n\t\ttail = wbits - wbit;\n\t\top = min_t(u32, tail, bits);\n\n\t\tif (wnd->free_bits[iw]) {\n\t\t\tbool ret;\n\t\t\tstruct buffer_head *bh = wnd_map(wnd, iw);\n\n\t\t\tif (IS_ERR(bh))\n\t\t\t\tgoto out;\n\n\t\t\tret = are_bits_set(bh->b_data, wbit, op);\n\t\t\tput_bh(bh);\n\t\t\tif (!ret)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tbits -= op;\n\t\twbit = 0;\n\t\tiw += 1;\n\t}\n\tret = true;\n\nout:\n\treturn ret;\n}\n\n \nsize_t wnd_find(struct wnd_bitmap *wnd, size_t to_alloc, size_t hint,\n\t\tsize_t flags, size_t *allocated)\n{\n\tstruct super_block *sb;\n\tu32 wbits, wpos, wzbit, wzend;\n\tsize_t fnd, max_alloc, b_len, b_pos;\n\tsize_t iw, prev_tail, nwnd, wbit, ebit, zbit, zend;\n\tsize_t to_alloc0 = to_alloc;\n\tconst struct e_node *e;\n\tconst struct rb_node *pr, *cr;\n\tu8 log2_bits;\n\tbool fbits_valid;\n\tstruct buffer_head *bh;\n\n\t \n\tif (flags & BITMAP_FIND_FULL) {\n\t\tsize_t zeroes = wnd_zeroes(wnd);\n\n\t\tzeroes -= wnd->zone_end - wnd->zone_bit;\n\t\tif (zeroes < to_alloc0)\n\t\t\tgoto no_space;\n\n\t\tif (to_alloc0 > wnd->extent_max)\n\t\t\tgoto no_space;\n\t} else {\n\t\tif (to_alloc > wnd->extent_max)\n\t\t\tto_alloc = wnd->extent_max;\n\t}\n\n\tif (wnd->zone_bit <= hint && hint < wnd->zone_end)\n\t\thint = wnd->zone_end;\n\n\tmax_alloc = wnd->nbits;\n\tb_len = b_pos = 0;\n\n\tif (hint >= max_alloc)\n\t\thint = 0;\n\n\tif (RB_EMPTY_ROOT(&wnd->start_tree)) {\n\t\tif (wnd->uptodated == 1) {\n\t\t\t \n\t\t\tgoto no_space;\n\t\t}\n\t\tgoto scan_bitmap;\n\t}\n\n\te = NULL;\n\tif (!hint)\n\t\tgoto allocate_biggest;\n\n\t \n\tpr = NULL;\n\tcr = wnd->start_tree.rb_node;\n\n\tfor (;;) {\n\t\te = rb_entry(cr, struct e_node, start.node);\n\n\t\tif (e->start.key == hint)\n\t\t\tbreak;\n\n\t\tif (e->start.key < hint) {\n\t\t\tpr = cr;\n\t\t\tcr = cr->rb_right;\n\t\t\tif (!cr)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcr = cr->rb_left;\n\t\tif (!cr) {\n\t\t\te = pr ? rb_entry(pr, struct e_node, start.node) : NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!e)\n\t\tgoto allocate_biggest;\n\n\tif (e->start.key + e->count.key > hint) {\n\t\t \n\t\tsize_t len = e->start.key + e->count.key - hint;\n\n\t\tif (len >= to_alloc && hint + to_alloc <= max_alloc) {\n\t\t\tfnd = hint;\n\t\t\tgoto found;\n\t\t}\n\n\t\tif (!(flags & BITMAP_FIND_FULL)) {\n\t\t\tif (len > to_alloc)\n\t\t\t\tlen = to_alloc;\n\n\t\t\tif (hint + len <= max_alloc) {\n\t\t\t\tfnd = hint;\n\t\t\t\tto_alloc = len;\n\t\t\t\tgoto found;\n\t\t\t}\n\t\t}\n\t}\n\nallocate_biggest:\n\t \n\te = rb_entry(rb_first(&wnd->count_tree), struct e_node, count.node);\n\tif (e->count.key != wnd->extent_max)\n\t\twnd->extent_max = e->count.key;\n\n\tif (e->count.key < max_alloc) {\n\t\tif (e->count.key >= to_alloc) {\n\t\t\t;\n\t\t} else if (flags & BITMAP_FIND_FULL) {\n\t\t\tif (e->count.key < to_alloc0) {\n\t\t\t\t \n\t\t\t\tgoto no_space;\n\t\t\t}\n\t\t\tto_alloc = e->count.key;\n\t\t} else if (-1 != wnd->uptodated) {\n\t\t\tto_alloc = e->count.key;\n\t\t} else {\n\t\t\t \n\t\t\tsize_t op, max_check;\n\t\t\tstruct rb_root start_tree;\n\n\t\t\tmemcpy(&start_tree, &wnd->start_tree,\n\t\t\t       sizeof(struct rb_root));\n\t\t\tmemset(&wnd->start_tree, 0, sizeof(struct rb_root));\n\n\t\t\tmax_check = e->start.key + to_alloc;\n\t\t\tif (max_check > max_alloc)\n\t\t\t\tmax_check = max_alloc;\n\t\t\tfor (op = e->start.key + e->count.key; op < max_check;\n\t\t\t     op++) {\n\t\t\t\tif (!wnd_is_free(wnd, op, 1))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy(&wnd->start_tree, &start_tree,\n\t\t\t       sizeof(struct rb_root));\n\t\t\tto_alloc = op - e->start.key;\n\t\t}\n\n\t\t \n\t\tfnd = e->start.key;\n\t\tif (e->start.key + to_alloc > max_alloc)\n\t\t\tto_alloc = max_alloc - e->start.key;\n\t\tgoto found;\n\t}\n\n\tif (wnd->uptodated == 1) {\n\t\t \n\t\tgoto no_space;\n\t}\n\n\tb_len = e->count.key;\n\tb_pos = e->start.key;\n\nscan_bitmap:\n\tsb = wnd->sb;\n\tlog2_bits = sb->s_blocksize_bits + 3;\n\n\t \nAgain:\n\n\t \n\tiw = hint >> log2_bits;\n\twbits = sb->s_blocksize * 8;\n\twpos = hint & (wbits - 1);\n\tprev_tail = 0;\n\tfbits_valid = true;\n\n\tif (max_alloc == wnd->nbits) {\n\t\tnwnd = wnd->nwnd;\n\t} else {\n\t\tsize_t t = max_alloc + wbits - 1;\n\n\t\tnwnd = likely(t > max_alloc) ? (t >> log2_bits) : wnd->nwnd;\n\t}\n\n\t \n\tfor (; iw < nwnd; iw++) {\n\t\twbit = iw << log2_bits;\n\n\t\tif (!wnd->free_bits[iw]) {\n\t\t\tif (prev_tail > b_len) {\n\t\t\t\tb_pos = wbit - prev_tail;\n\t\t\t\tb_len = prev_tail;\n\t\t\t}\n\n\t\t\t \n\t\t\tprev_tail = 0;\n\t\t\twpos = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (unlikely(iw + 1 == nwnd)) {\n\t\t\tif (max_alloc == wnd->nbits) {\n\t\t\t\twbits = wnd->bits_last;\n\t\t\t} else {\n\t\t\t\tsize_t t = max_alloc & (wbits - 1);\n\n\t\t\t\tif (t) {\n\t\t\t\t\twbits = t;\n\t\t\t\t\tfbits_valid = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (wnd->zone_end > wnd->zone_bit) {\n\t\t\tebit = wbit + wbits;\n\t\t\tzbit = max(wnd->zone_bit, wbit);\n\t\t\tzend = min(wnd->zone_end, ebit);\n\n\t\t\t \n\t\t\tif (zend <= zbit) {\n\t\t\t\t \n\t\t\t} else {\n\t\t\t\twzbit = zbit - wbit;\n\t\t\t\twzend = zend - wbit;\n\n\t\t\t\t \n\t\t\t\tif (wnd->free_bits[iw] == wzend - wzbit) {\n\t\t\t\t\tprev_tail = 0;\n\t\t\t\t\twpos = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tbh = wnd_map(wnd, iw);\n\n\t\t\t\tif (IS_ERR(bh)) {\n\t\t\t\t\t \n\t\t\t\t\tprev_tail = 0;\n\t\t\t\t\twpos = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tif (wpos < wzbit) {\n\t\t\t\t\t \n\t\t\t\t\tfnd = wnd_scan(bh->b_data, wbit, wpos,\n\t\t\t\t\t\t       wzbit, to_alloc,\n\t\t\t\t\t\t       &prev_tail, &b_pos,\n\t\t\t\t\t\t       &b_len);\n\t\t\t\t\tif (fnd != MINUS_ONE_T) {\n\t\t\t\t\t\tput_bh(bh);\n\t\t\t\t\t\tgoto found;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tprev_tail = 0;\n\n\t\t\t\t \n\t\t\t\tif (wzend < wbits) {\n\t\t\t\t\tfnd = wnd_scan(bh->b_data, wbit,\n\t\t\t\t\t\t       max(wzend, wpos), wbits,\n\t\t\t\t\t\t       to_alloc, &prev_tail,\n\t\t\t\t\t\t       &b_pos, &b_len);\n\t\t\t\t\tif (fnd != MINUS_ONE_T) {\n\t\t\t\t\t\tput_bh(bh);\n\t\t\t\t\t\tgoto found;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\twpos = 0;\n\t\t\t\tput_bh(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (!wpos && fbits_valid && wnd->free_bits[iw] == wbits) {\n\t\t\t \n\t\t\tif (prev_tail + wbits >= to_alloc) {\n\t\t\t\tfnd = wbit + wpos - prev_tail;\n\t\t\t\tgoto found;\n\t\t\t}\n\n\t\t\t \n\t\t\tprev_tail += wbits;\n\t\t\twpos = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tbh = wnd_map(wnd, iw);\n\t\tif (IS_ERR(bh)) {\n\t\t\t\n\t\t\tprev_tail = 0;\n\t\t\twpos = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tfnd = wnd_scan(bh->b_data, wbit, wpos, wbits, to_alloc,\n\t\t\t       &prev_tail, &b_pos, &b_len);\n\t\tput_bh(bh);\n\t\tif (fnd != MINUS_ONE_T)\n\t\t\tgoto found;\n\t}\n\n\tif (b_len < prev_tail) {\n\t\t \n\t\tb_len = prev_tail;\n\t\tb_pos = max_alloc - prev_tail;\n\t}\n\n\tif (hint) {\n\t\t \n\t\tsize_t nextmax = hint + to_alloc;\n\n\t\tif (likely(nextmax >= hint) && nextmax < max_alloc)\n\t\t\tmax_alloc = nextmax;\n\t\thint = 0;\n\t\tgoto Again;\n\t}\n\n\tif (!b_len)\n\t\tgoto no_space;\n\n\twnd->extent_max = b_len;\n\n\tif (flags & BITMAP_FIND_FULL)\n\t\tgoto no_space;\n\n\tfnd = b_pos;\n\tto_alloc = b_len;\n\nfound:\n\tif (flags & BITMAP_FIND_MARK_AS_USED) {\n\t\t \n\t\tif (wnd_set_used(wnd, fnd, to_alloc))\n\t\t\tgoto no_space;\n\t} else if (wnd->extent_max != MINUS_ONE_T &&\n\t\t   to_alloc > wnd->extent_max) {\n\t\twnd->extent_max = to_alloc;\n\t}\n\n\t*allocated = fnd;\n\treturn to_alloc;\n\nno_space:\n\treturn 0;\n}\n\n \nint wnd_extend(struct wnd_bitmap *wnd, size_t new_bits)\n{\n\tint err;\n\tstruct super_block *sb = wnd->sb;\n\tstruct ntfs_sb_info *sbi = sb->s_fs_info;\n\tu32 blocksize = sb->s_blocksize;\n\tu32 wbits = blocksize * 8;\n\tu32 b0, new_last;\n\tsize_t bits, iw, new_wnd;\n\tsize_t old_bits = wnd->nbits;\n\tu16 *new_free;\n\n\tif (new_bits <= old_bits)\n\t\treturn -EINVAL;\n\n\t \n\tnew_wnd = bytes_to_block(sb, bitmap_size(new_bits));\n\tnew_last = new_bits & (wbits - 1);\n\tif (!new_last)\n\t\tnew_last = wbits;\n\n\tif (new_wnd != wnd->nwnd) {\n\t\tnew_free = kmalloc_array(new_wnd, sizeof(u16), GFP_NOFS);\n\t\tif (!new_free)\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(new_free, wnd->free_bits, wnd->nwnd * sizeof(short));\n\t\tmemset(new_free + wnd->nwnd, 0,\n\t\t       (new_wnd - wnd->nwnd) * sizeof(short));\n\t\tkfree(wnd->free_bits);\n\t\twnd->free_bits = new_free;\n\t}\n\n\t \n\tbits = new_bits - old_bits;\n\tb0 = old_bits & (wbits - 1);\n\n\tfor (iw = old_bits >> (sb->s_blocksize_bits + 3); bits; iw += 1) {\n\t\tu32 op;\n\t\tsize_t frb;\n\t\tu64 vbo, lbo, bytes;\n\t\tstruct buffer_head *bh;\n\n\t\tif (iw + 1 == new_wnd)\n\t\t\twbits = new_last;\n\n\t\top = b0 + bits > wbits ? wbits - b0 : bits;\n\t\tvbo = (u64)iw * blocksize;\n\n\t\terr = ntfs_vbo_to_lbo(sbi, &wnd->run, vbo, &lbo, &bytes);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tbh = ntfs_bread(sb, lbo >> sb->s_blocksize_bits);\n\t\tif (!bh)\n\t\t\treturn -EIO;\n\n\t\tlock_buffer(bh);\n\n\t\tntfs_bitmap_clear_le(bh->b_data, b0, blocksize * 8 - b0);\n\t\tfrb = wbits - ntfs_bitmap_weight_le(bh->b_data, wbits);\n\t\twnd->total_zeroes += frb - wnd->free_bits[iw];\n\t\twnd->free_bits[iw] = frb;\n\n\t\tset_buffer_uptodate(bh);\n\t\tmark_buffer_dirty(bh);\n\t\tunlock_buffer(bh);\n\t\t \n\n\t\tb0 = 0;\n\t\tbits -= op;\n\t}\n\n\twnd->nbits = new_bits;\n\twnd->nwnd = new_wnd;\n\twnd->bits_last = new_last;\n\n\twnd_add_free_ext(wnd, old_bits, new_bits - old_bits, false);\n\n\treturn 0;\n}\n\nvoid wnd_zone_set(struct wnd_bitmap *wnd, size_t lcn, size_t len)\n{\n\tsize_t zlen = wnd->zone_end - wnd->zone_bit;\n\n\tif (zlen)\n\t\twnd_add_free_ext(wnd, wnd->zone_bit, zlen, false);\n\n\tif (!RB_EMPTY_ROOT(&wnd->start_tree) && len)\n\t\twnd_remove_free_ext(wnd, lcn, len);\n\n\twnd->zone_bit = lcn;\n\twnd->zone_end = lcn + len;\n}\n\nint ntfs_trim_fs(struct ntfs_sb_info *sbi, struct fstrim_range *range)\n{\n\tint err = 0;\n\tstruct super_block *sb = sbi->sb;\n\tstruct wnd_bitmap *wnd = &sbi->used.bitmap;\n\tu32 wbits = 8 * sb->s_blocksize;\n\tCLST len = 0, lcn = 0, done = 0;\n\tCLST minlen = bytes_to_cluster(sbi, range->minlen);\n\tCLST lcn_from = bytes_to_cluster(sbi, range->start);\n\tsize_t iw = lcn_from >> (sb->s_blocksize_bits + 3);\n\tu32 wbit = lcn_from & (wbits - 1);\n\tCLST lcn_to;\n\n\tif (!minlen)\n\t\tminlen = 1;\n\n\tif (range->len == (u64)-1)\n\t\tlcn_to = wnd->nbits;\n\telse\n\t\tlcn_to = bytes_to_cluster(sbi, range->start + range->len);\n\n\tdown_read_nested(&wnd->rw_lock, BITMAP_MUTEX_CLUSTERS);\n\n\tfor (; iw < wnd->nwnd; iw++, wbit = 0) {\n\t\tCLST lcn_wnd = iw * wbits;\n\t\tstruct buffer_head *bh;\n\n\t\tif (lcn_wnd > lcn_to)\n\t\t\tbreak;\n\n\t\tif (!wnd->free_bits[iw])\n\t\t\tcontinue;\n\n\t\tif (iw + 1 == wnd->nwnd)\n\t\t\twbits = wnd->bits_last;\n\n\t\tif (lcn_wnd + wbits > lcn_to)\n\t\t\twbits = lcn_to - lcn_wnd;\n\n\t\tbh = wnd_map(wnd, iw);\n\t\tif (IS_ERR(bh)) {\n\t\t\terr = PTR_ERR(bh);\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (; wbit < wbits; wbit++) {\n\t\t\tif (!test_bit_le(wbit, bh->b_data)) {\n\t\t\t\tif (!len)\n\t\t\t\t\tlcn = lcn_wnd + wbit;\n\t\t\t\tlen += 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (len >= minlen) {\n\t\t\t\terr = ntfs_discard(sbi, lcn, len);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out;\n\t\t\t\tdone += len;\n\t\t\t}\n\t\t\tlen = 0;\n\t\t}\n\t\tput_bh(bh);\n\t}\n\n\t \n\tif (len >= minlen) {\n\t\terr = ntfs_discard(sbi, lcn, len);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tdone += len;\n\t}\n\nout:\n\trange->len = (u64)done << sbi->cluster_bits;\n\n\tup_read(&wnd->rw_lock);\n\n\treturn err;\n}\n\n#if BITS_PER_LONG == 64\ntypedef __le64 bitmap_ulong;\n#define cpu_to_ul(x) cpu_to_le64(x)\n#define ul_to_cpu(x) le64_to_cpu(x)\n#else\ntypedef __le32 bitmap_ulong;\n#define cpu_to_ul(x) cpu_to_le32(x)\n#define ul_to_cpu(x) le32_to_cpu(x)\n#endif\n\nvoid ntfs_bitmap_set_le(void *map, unsigned int start, int len)\n{\n\tbitmap_ulong *p = (bitmap_ulong *)map + BIT_WORD(start);\n\tconst unsigned int size = start + len;\n\tint bits_to_set = BITS_PER_LONG - (start % BITS_PER_LONG);\n\tbitmap_ulong mask_to_set = cpu_to_ul(BITMAP_FIRST_WORD_MASK(start));\n\n\twhile (len - bits_to_set >= 0) {\n\t\t*p |= mask_to_set;\n\t\tlen -= bits_to_set;\n\t\tbits_to_set = BITS_PER_LONG;\n\t\tmask_to_set = cpu_to_ul(~0UL);\n\t\tp++;\n\t}\n\tif (len) {\n\t\tmask_to_set &= cpu_to_ul(BITMAP_LAST_WORD_MASK(size));\n\t\t*p |= mask_to_set;\n\t}\n}\n\nvoid ntfs_bitmap_clear_le(void *map, unsigned int start, int len)\n{\n\tbitmap_ulong *p = (bitmap_ulong *)map + BIT_WORD(start);\n\tconst unsigned int size = start + len;\n\tint bits_to_clear = BITS_PER_LONG - (start % BITS_PER_LONG);\n\tbitmap_ulong mask_to_clear = cpu_to_ul(BITMAP_FIRST_WORD_MASK(start));\n\n\twhile (len - bits_to_clear >= 0) {\n\t\t*p &= ~mask_to_clear;\n\t\tlen -= bits_to_clear;\n\t\tbits_to_clear = BITS_PER_LONG;\n\t\tmask_to_clear = cpu_to_ul(~0UL);\n\t\tp++;\n\t}\n\tif (len) {\n\t\tmask_to_clear &= cpu_to_ul(BITMAP_LAST_WORD_MASK(size));\n\t\t*p &= ~mask_to_clear;\n\t}\n}\n\nunsigned int ntfs_bitmap_weight_le(const void *bitmap, int bits)\n{\n\tconst ulong *bmp = bitmap;\n\tunsigned int k, lim = bits / BITS_PER_LONG;\n\tunsigned int w = 0;\n\n\tfor (k = 0; k < lim; k++)\n\t\tw += hweight_long(bmp[k]);\n\n\tif (bits % BITS_PER_LONG) {\n\t\tw += hweight_long(ul_to_cpu(((bitmap_ulong *)bitmap)[k]) &\n\t\t\t\t  BITMAP_LAST_WORD_MASK(bits));\n\t}\n\n\treturn w;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}