{
  "module_name": "bitfunc.c",
  "hash_id": "b20d23219f6d7fb81044b640e7217804d4d2acfec4136601ee671c92bc9bf3d0",
  "original_prompt": "Ingested from linux-6.6.14/fs/ntfs3/bitfunc.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n\n#include \"ntfs_fs.h\"\n\n#define BITS_IN_SIZE_T (sizeof(size_t) * 8)\n\n \nstatic const u8 fill_mask[] = { 0x00, 0x01, 0x03, 0x07, 0x0F,\n\t\t\t\t0x1F, 0x3F, 0x7F, 0xFF };\n\n \nstatic const u8 zero_mask[] = { 0xFF, 0xFE, 0xFC, 0xF8, 0xF0,\n\t\t\t\t0xE0, 0xC0, 0x80, 0x00 };\n\n \nbool are_bits_clear(const void *lmap, size_t bit, size_t nbits)\n{\n\tsize_t pos = bit & 7;\n\tconst u8 *map = (u8 *)lmap + (bit >> 3);\n\n\tif (pos) {\n\t\tif (8 - pos >= nbits)\n\t\t\treturn !nbits || !(*map & fill_mask[pos + nbits] &\n\t\t\t\t\t   zero_mask[pos]);\n\n\t\tif (*map++ & zero_mask[pos])\n\t\t\treturn false;\n\t\tnbits -= 8 - pos;\n\t}\n\n\tpos = ((size_t)map) & (sizeof(size_t) - 1);\n\tif (pos) {\n\t\tpos = sizeof(size_t) - pos;\n\t\tif (nbits >= pos * 8) {\n\t\t\tfor (nbits -= pos * 8; pos; pos--, map++) {\n\t\t\t\tif (*map)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (pos = nbits / BITS_IN_SIZE_T; pos; pos--, map += sizeof(size_t)) {\n\t\tif (*((size_t *)map))\n\t\t\treturn false;\n\t}\n\n\tfor (pos = (nbits % BITS_IN_SIZE_T) >> 3; pos; pos--, map++) {\n\t\tif (*map)\n\t\t\treturn false;\n\t}\n\n\tpos = nbits & 7;\n\tif (pos && (*map & fill_mask[pos]))\n\t\treturn false;\n\n\treturn true;\n}\n\n \nbool are_bits_set(const void *lmap, size_t bit, size_t nbits)\n{\n\tu8 mask;\n\tsize_t pos = bit & 7;\n\tconst u8 *map = (u8 *)lmap + (bit >> 3);\n\n\tif (pos) {\n\t\tif (8 - pos >= nbits) {\n\t\t\tmask = fill_mask[pos + nbits] & zero_mask[pos];\n\t\t\treturn !nbits || (*map & mask) == mask;\n\t\t}\n\n\t\tmask = zero_mask[pos];\n\t\tif ((*map++ & mask) != mask)\n\t\t\treturn false;\n\t\tnbits -= 8 - pos;\n\t}\n\n\tpos = ((size_t)map) & (sizeof(size_t) - 1);\n\tif (pos) {\n\t\tpos = sizeof(size_t) - pos;\n\t\tif (nbits >= pos * 8) {\n\t\t\tfor (nbits -= pos * 8; pos; pos--, map++) {\n\t\t\t\tif (*map != 0xFF)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (pos = nbits / BITS_IN_SIZE_T; pos; pos--, map += sizeof(size_t)) {\n\t\tif (*((size_t *)map) != MINUS_ONE_T)\n\t\t\treturn false;\n\t}\n\n\tfor (pos = (nbits % BITS_IN_SIZE_T) >> 3; pos; pos--, map++) {\n\t\tif (*map != 0xFF)\n\t\t\treturn false;\n\t}\n\n\tpos = nbits & 7;\n\tif (pos) {\n\t\tmask = fill_mask[pos];\n\t\tif ((*map & mask) != mask)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}