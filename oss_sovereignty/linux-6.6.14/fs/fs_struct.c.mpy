{
  "module_name": "fs_struct.c",
  "hash_id": "64cb93c2e0eb43b5d455ef0c6fc630f7fa1dc7507c6108505f9da76afd9485cf",
  "original_prompt": "Ingested from linux-6.6.14/fs/fs_struct.c",
  "human_readable_source": "\n#include <linux/export.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/fs.h>\n#include <linux/path.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include \"internal.h\"\n\n \nvoid set_fs_root(struct fs_struct *fs, const struct path *path)\n{\n\tstruct path old_root;\n\n\tpath_get(path);\n\tspin_lock(&fs->lock);\n\twrite_seqcount_begin(&fs->seq);\n\told_root = fs->root;\n\tfs->root = *path;\n\twrite_seqcount_end(&fs->seq);\n\tspin_unlock(&fs->lock);\n\tif (old_root.dentry)\n\t\tpath_put(&old_root);\n}\n\n \nvoid set_fs_pwd(struct fs_struct *fs, const struct path *path)\n{\n\tstruct path old_pwd;\n\n\tpath_get(path);\n\tspin_lock(&fs->lock);\n\twrite_seqcount_begin(&fs->seq);\n\told_pwd = fs->pwd;\n\tfs->pwd = *path;\n\twrite_seqcount_end(&fs->seq);\n\tspin_unlock(&fs->lock);\n\n\tif (old_pwd.dentry)\n\t\tpath_put(&old_pwd);\n}\n\nstatic inline int replace_path(struct path *p, const struct path *old, const struct path *new)\n{\n\tif (likely(p->dentry != old->dentry || p->mnt != old->mnt))\n\t\treturn 0;\n\t*p = *new;\n\treturn 1;\n}\n\nvoid chroot_fs_refs(const struct path *old_root, const struct path *new_root)\n{\n\tstruct task_struct *g, *p;\n\tstruct fs_struct *fs;\n\tint count = 0;\n\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, p) {\n\t\ttask_lock(p);\n\t\tfs = p->fs;\n\t\tif (fs) {\n\t\t\tint hits = 0;\n\t\t\tspin_lock(&fs->lock);\n\t\t\twrite_seqcount_begin(&fs->seq);\n\t\t\thits += replace_path(&fs->root, old_root, new_root);\n\t\t\thits += replace_path(&fs->pwd, old_root, new_root);\n\t\t\twrite_seqcount_end(&fs->seq);\n\t\t\twhile (hits--) {\n\t\t\t\tcount++;\n\t\t\t\tpath_get(new_root);\n\t\t\t}\n\t\t\tspin_unlock(&fs->lock);\n\t\t}\n\t\ttask_unlock(p);\n\t}\n\tread_unlock(&tasklist_lock);\n\twhile (count--)\n\t\tpath_put(old_root);\n}\n\nvoid free_fs_struct(struct fs_struct *fs)\n{\n\tpath_put(&fs->root);\n\tpath_put(&fs->pwd);\n\tkmem_cache_free(fs_cachep, fs);\n}\n\nvoid exit_fs(struct task_struct *tsk)\n{\n\tstruct fs_struct *fs = tsk->fs;\n\n\tif (fs) {\n\t\tint kill;\n\t\ttask_lock(tsk);\n\t\tspin_lock(&fs->lock);\n\t\ttsk->fs = NULL;\n\t\tkill = !--fs->users;\n\t\tspin_unlock(&fs->lock);\n\t\ttask_unlock(tsk);\n\t\tif (kill)\n\t\t\tfree_fs_struct(fs);\n\t}\n}\n\nstruct fs_struct *copy_fs_struct(struct fs_struct *old)\n{\n\tstruct fs_struct *fs = kmem_cache_alloc(fs_cachep, GFP_KERNEL);\n\t \n\tif (fs) {\n\t\tfs->users = 1;\n\t\tfs->in_exec = 0;\n\t\tspin_lock_init(&fs->lock);\n\t\tseqcount_spinlock_init(&fs->seq, &fs->lock);\n\t\tfs->umask = old->umask;\n\n\t\tspin_lock(&old->lock);\n\t\tfs->root = old->root;\n\t\tpath_get(&fs->root);\n\t\tfs->pwd = old->pwd;\n\t\tpath_get(&fs->pwd);\n\t\tspin_unlock(&old->lock);\n\t}\n\treturn fs;\n}\n\nint unshare_fs_struct(void)\n{\n\tstruct fs_struct *fs = current->fs;\n\tstruct fs_struct *new_fs = copy_fs_struct(fs);\n\tint kill;\n\n\tif (!new_fs)\n\t\treturn -ENOMEM;\n\n\ttask_lock(current);\n\tspin_lock(&fs->lock);\n\tkill = !--fs->users;\n\tcurrent->fs = new_fs;\n\tspin_unlock(&fs->lock);\n\ttask_unlock(current);\n\n\tif (kill)\n\t\tfree_fs_struct(fs);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(unshare_fs_struct);\n\nint current_umask(void)\n{\n\treturn current->fs->umask;\n}\nEXPORT_SYMBOL(current_umask);\n\n \nstruct fs_struct init_fs = {\n\t.users\t\t= 1,\n\t.lock\t\t= __SPIN_LOCK_UNLOCKED(init_fs.lock),\n\t.seq\t\t= SEQCNT_SPINLOCK_ZERO(init_fs.seq, &init_fs.lock),\n\t.umask\t\t= 0022,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}