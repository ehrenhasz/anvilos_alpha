{
  "module_name": "file.c",
  "hash_id": "99fb8aa7b54d32d78e87cd8293caf60f2ddedd3d50cdcf17a02eb1e40caa8b4e",
  "original_prompt": "Ingested from linux-6.6.14/fs/sysfs/file.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n\n#include \"sysfs.h\"\n\n \nstatic const struct sysfs_ops *sysfs_file_ops(struct kernfs_node *kn)\n{\n\tstruct kobject *kobj = kn->parent->priv;\n\n\tif (kn->flags & KERNFS_LOCKDEP)\n\t\tlockdep_assert_held(kn);\n\treturn kobj->ktype ? kobj->ktype->sysfs_ops : NULL;\n}\n\n \nstatic int sysfs_kf_seq_show(struct seq_file *sf, void *v)\n{\n\tstruct kernfs_open_file *of = sf->private;\n\tstruct kobject *kobj = of->kn->parent->priv;\n\tconst struct sysfs_ops *ops = sysfs_file_ops(of->kn);\n\tssize_t count;\n\tchar *buf;\n\n\tif (WARN_ON_ONCE(!ops->show))\n\t\treturn -EINVAL;\n\n\t \n\tcount = seq_get_buf(sf, &buf);\n\tif (count < PAGE_SIZE) {\n\t\tseq_commit(sf, -1);\n\t\treturn 0;\n\t}\n\tmemset(buf, 0, PAGE_SIZE);\n\n\tcount = ops->show(kobj, of->kn->priv, buf);\n\tif (count < 0)\n\t\treturn count;\n\n\t \n\tif (count >= (ssize_t)PAGE_SIZE) {\n\t\tprintk(\"fill_read_buffer: %pS returned bad count\\n\",\n\t\t\t\tops->show);\n\t\t \n\t\tcount = PAGE_SIZE - 1;\n\t}\n\tseq_commit(sf, count);\n\treturn 0;\n}\n\nstatic ssize_t sysfs_kf_bin_read(struct kernfs_open_file *of, char *buf,\n\t\t\t\t size_t count, loff_t pos)\n{\n\tstruct bin_attribute *battr = of->kn->priv;\n\tstruct kobject *kobj = of->kn->parent->priv;\n\tloff_t size = file_inode(of->file)->i_size;\n\n\tif (!count)\n\t\treturn 0;\n\n\tif (size) {\n\t\tif (pos >= size)\n\t\t\treturn 0;\n\t\tif (pos + count > size)\n\t\t\tcount = size - pos;\n\t}\n\n\tif (!battr->read)\n\t\treturn -EIO;\n\n\treturn battr->read(of->file, kobj, battr, buf, pos, count);\n}\n\n \nstatic ssize_t sysfs_kf_read(struct kernfs_open_file *of, char *buf,\n\t\t\t     size_t count, loff_t pos)\n{\n\tconst struct sysfs_ops *ops = sysfs_file_ops(of->kn);\n\tstruct kobject *kobj = of->kn->parent->priv;\n\tssize_t len;\n\n\t \n\tif (WARN_ON_ONCE(buf != of->prealloc_buf))\n\t\treturn 0;\n\tlen = ops->show(kobj, of->kn->priv, buf);\n\tif (len < 0)\n\t\treturn len;\n\tif (pos) {\n\t\tif (len <= pos)\n\t\t\treturn 0;\n\t\tlen -= pos;\n\t\tmemmove(buf, buf + pos, len);\n\t}\n\treturn min_t(ssize_t, count, len);\n}\n\n \nstatic ssize_t sysfs_kf_write(struct kernfs_open_file *of, char *buf,\n\t\t\t      size_t count, loff_t pos)\n{\n\tconst struct sysfs_ops *ops = sysfs_file_ops(of->kn);\n\tstruct kobject *kobj = of->kn->parent->priv;\n\n\tif (!count)\n\t\treturn 0;\n\n\treturn ops->store(kobj, of->kn->priv, buf, count);\n}\n\n \nstatic ssize_t sysfs_kf_bin_write(struct kernfs_open_file *of, char *buf,\n\t\t\t\t  size_t count, loff_t pos)\n{\n\tstruct bin_attribute *battr = of->kn->priv;\n\tstruct kobject *kobj = of->kn->parent->priv;\n\tloff_t size = file_inode(of->file)->i_size;\n\n\tif (size) {\n\t\tif (size <= pos)\n\t\t\treturn -EFBIG;\n\t\tcount = min_t(ssize_t, count, size - pos);\n\t}\n\tif (!count)\n\t\treturn 0;\n\n\tif (!battr->write)\n\t\treturn -EIO;\n\n\treturn battr->write(of->file, kobj, battr, buf, pos, count);\n}\n\nstatic int sysfs_kf_bin_mmap(struct kernfs_open_file *of,\n\t\t\t     struct vm_area_struct *vma)\n{\n\tstruct bin_attribute *battr = of->kn->priv;\n\tstruct kobject *kobj = of->kn->parent->priv;\n\n\treturn battr->mmap(of->file, kobj, battr, vma);\n}\n\nstatic int sysfs_kf_bin_open(struct kernfs_open_file *of)\n{\n\tstruct bin_attribute *battr = of->kn->priv;\n\n\tif (battr->f_mapping)\n\t\tof->file->f_mapping = battr->f_mapping();\n\n\treturn 0;\n}\n\nvoid sysfs_notify(struct kobject *kobj, const char *dir, const char *attr)\n{\n\tstruct kernfs_node *kn = kobj->sd, *tmp;\n\n\tif (kn && dir)\n\t\tkn = kernfs_find_and_get(kn, dir);\n\telse\n\t\tkernfs_get(kn);\n\n\tif (kn && attr) {\n\t\ttmp = kernfs_find_and_get(kn, attr);\n\t\tkernfs_put(kn);\n\t\tkn = tmp;\n\t}\n\n\tif (kn) {\n\t\tkernfs_notify(kn);\n\t\tkernfs_put(kn);\n\t}\n}\nEXPORT_SYMBOL_GPL(sysfs_notify);\n\nstatic const struct kernfs_ops sysfs_file_kfops_empty = {\n};\n\nstatic const struct kernfs_ops sysfs_file_kfops_ro = {\n\t.seq_show\t= sysfs_kf_seq_show,\n};\n\nstatic const struct kernfs_ops sysfs_file_kfops_wo = {\n\t.write\t\t= sysfs_kf_write,\n};\n\nstatic const struct kernfs_ops sysfs_file_kfops_rw = {\n\t.seq_show\t= sysfs_kf_seq_show,\n\t.write\t\t= sysfs_kf_write,\n};\n\nstatic const struct kernfs_ops sysfs_prealloc_kfops_ro = {\n\t.read\t\t= sysfs_kf_read,\n\t.prealloc\t= true,\n};\n\nstatic const struct kernfs_ops sysfs_prealloc_kfops_wo = {\n\t.write\t\t= sysfs_kf_write,\n\t.prealloc\t= true,\n};\n\nstatic const struct kernfs_ops sysfs_prealloc_kfops_rw = {\n\t.read\t\t= sysfs_kf_read,\n\t.write\t\t= sysfs_kf_write,\n\t.prealloc\t= true,\n};\n\nstatic const struct kernfs_ops sysfs_bin_kfops_ro = {\n\t.read\t\t= sysfs_kf_bin_read,\n};\n\nstatic const struct kernfs_ops sysfs_bin_kfops_wo = {\n\t.write\t\t= sysfs_kf_bin_write,\n};\n\nstatic const struct kernfs_ops sysfs_bin_kfops_rw = {\n\t.read\t\t= sysfs_kf_bin_read,\n\t.write\t\t= sysfs_kf_bin_write,\n};\n\nstatic const struct kernfs_ops sysfs_bin_kfops_mmap = {\n\t.read\t\t= sysfs_kf_bin_read,\n\t.write\t\t= sysfs_kf_bin_write,\n\t.mmap\t\t= sysfs_kf_bin_mmap,\n\t.open\t\t= sysfs_kf_bin_open,\n};\n\nint sysfs_add_file_mode_ns(struct kernfs_node *parent,\n\t\tconst struct attribute *attr, umode_t mode, kuid_t uid,\n\t\tkgid_t gid, const void *ns)\n{\n\tstruct kobject *kobj = parent->priv;\n\tconst struct sysfs_ops *sysfs_ops = kobj->ktype->sysfs_ops;\n\tstruct lock_class_key *key = NULL;\n\tconst struct kernfs_ops *ops = NULL;\n\tstruct kernfs_node *kn;\n\n\t \n\tif (WARN(!sysfs_ops, KERN_ERR\n\t\t\t\"missing sysfs attribute operations for kobject: %s\\n\",\n\t\t\tkobject_name(kobj)))\n\t\treturn -EINVAL;\n\n\tif (mode & SYSFS_PREALLOC) {\n\t\tif (sysfs_ops->show && sysfs_ops->store)\n\t\t\tops = &sysfs_prealloc_kfops_rw;\n\t\telse if (sysfs_ops->show)\n\t\t\tops = &sysfs_prealloc_kfops_ro;\n\t\telse if (sysfs_ops->store)\n\t\t\tops = &sysfs_prealloc_kfops_wo;\n\t} else {\n\t\tif (sysfs_ops->show && sysfs_ops->store)\n\t\t\tops = &sysfs_file_kfops_rw;\n\t\telse if (sysfs_ops->show)\n\t\t\tops = &sysfs_file_kfops_ro;\n\t\telse if (sysfs_ops->store)\n\t\t\tops = &sysfs_file_kfops_wo;\n\t}\n\n\tif (!ops)\n\t\tops = &sysfs_file_kfops_empty;\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (!attr->ignore_lockdep)\n\t\tkey = attr->key ?: (struct lock_class_key *)&attr->skey;\n#endif\n\n\tkn = __kernfs_create_file(parent, attr->name, mode & 0777, uid, gid,\n\t\t\t\t  PAGE_SIZE, ops, (void *)attr, ns, key);\n\tif (IS_ERR(kn)) {\n\t\tif (PTR_ERR(kn) == -EEXIST)\n\t\t\tsysfs_warn_dup(parent, attr->name);\n\t\treturn PTR_ERR(kn);\n\t}\n\treturn 0;\n}\n\nint sysfs_add_bin_file_mode_ns(struct kernfs_node *parent,\n\t\tconst struct bin_attribute *battr, umode_t mode,\n\t\tkuid_t uid, kgid_t gid, const void *ns)\n{\n\tconst struct attribute *attr = &battr->attr;\n\tstruct lock_class_key *key = NULL;\n\tconst struct kernfs_ops *ops;\n\tstruct kernfs_node *kn;\n\n\tif (battr->mmap)\n\t\tops = &sysfs_bin_kfops_mmap;\n\telse if (battr->read && battr->write)\n\t\tops = &sysfs_bin_kfops_rw;\n\telse if (battr->read)\n\t\tops = &sysfs_bin_kfops_ro;\n\telse if (battr->write)\n\t\tops = &sysfs_bin_kfops_wo;\n\telse\n\t\tops = &sysfs_file_kfops_empty;\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (!attr->ignore_lockdep)\n\t\tkey = attr->key ?: (struct lock_class_key *)&attr->skey;\n#endif\n\n\tkn = __kernfs_create_file(parent, attr->name, mode & 0777, uid, gid,\n\t\t\t\t  battr->size, ops, (void *)attr, ns, key);\n\tif (IS_ERR(kn)) {\n\t\tif (PTR_ERR(kn) == -EEXIST)\n\t\t\tsysfs_warn_dup(parent, attr->name);\n\t\treturn PTR_ERR(kn);\n\t}\n\treturn 0;\n}\n\n \nint sysfs_create_file_ns(struct kobject *kobj, const struct attribute *attr,\n\t\t\t const void *ns)\n{\n\tkuid_t uid;\n\tkgid_t gid;\n\n\tif (WARN_ON(!kobj || !kobj->sd || !attr))\n\t\treturn -EINVAL;\n\n\tkobject_get_ownership(kobj, &uid, &gid);\n\treturn sysfs_add_file_mode_ns(kobj->sd, attr, attr->mode, uid, gid, ns);\n}\nEXPORT_SYMBOL_GPL(sysfs_create_file_ns);\n\nint sysfs_create_files(struct kobject *kobj, const struct attribute * const *ptr)\n{\n\tint err = 0;\n\tint i;\n\n\tfor (i = 0; ptr[i] && !err; i++)\n\t\terr = sysfs_create_file(kobj, ptr[i]);\n\tif (err)\n\t\twhile (--i >= 0)\n\t\t\tsysfs_remove_file(kobj, ptr[i]);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(sysfs_create_files);\n\n \nint sysfs_add_file_to_group(struct kobject *kobj,\n\t\tconst struct attribute *attr, const char *group)\n{\n\tstruct kernfs_node *parent;\n\tkuid_t uid;\n\tkgid_t gid;\n\tint error;\n\n\tif (group) {\n\t\tparent = kernfs_find_and_get(kobj->sd, group);\n\t} else {\n\t\tparent = kobj->sd;\n\t\tkernfs_get(parent);\n\t}\n\n\tif (!parent)\n\t\treturn -ENOENT;\n\n\tkobject_get_ownership(kobj, &uid, &gid);\n\terror = sysfs_add_file_mode_ns(parent, attr, attr->mode, uid, gid,\n\t\t\t\t       NULL);\n\tkernfs_put(parent);\n\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(sysfs_add_file_to_group);\n\n \nint sysfs_chmod_file(struct kobject *kobj, const struct attribute *attr,\n\t\t     umode_t mode)\n{\n\tstruct kernfs_node *kn;\n\tstruct iattr newattrs;\n\tint rc;\n\n\tkn = kernfs_find_and_get(kobj->sd, attr->name);\n\tif (!kn)\n\t\treturn -ENOENT;\n\n\tnewattrs.ia_mode = (mode & S_IALLUGO) | (kn->mode & ~S_IALLUGO);\n\tnewattrs.ia_valid = ATTR_MODE;\n\n\trc = kernfs_setattr(kn, &newattrs);\n\n\tkernfs_put(kn);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(sysfs_chmod_file);\n\n \nstruct kernfs_node *sysfs_break_active_protection(struct kobject *kobj,\n\t\t\t\t\t\t  const struct attribute *attr)\n{\n\tstruct kernfs_node *kn;\n\n\tkobject_get(kobj);\n\tkn = kernfs_find_and_get(kobj->sd, attr->name);\n\tif (kn)\n\t\tkernfs_break_active_protection(kn);\n\treturn kn;\n}\nEXPORT_SYMBOL_GPL(sysfs_break_active_protection);\n\n \nvoid sysfs_unbreak_active_protection(struct kernfs_node *kn)\n{\n\tstruct kobject *kobj = kn->parent->priv;\n\n\tkernfs_unbreak_active_protection(kn);\n\tkernfs_put(kn);\n\tkobject_put(kobj);\n}\nEXPORT_SYMBOL_GPL(sysfs_unbreak_active_protection);\n\n \nvoid sysfs_remove_file_ns(struct kobject *kobj, const struct attribute *attr,\n\t\t\t  const void *ns)\n{\n\tstruct kernfs_node *parent = kobj->sd;\n\n\tkernfs_remove_by_name_ns(parent, attr->name, ns);\n}\nEXPORT_SYMBOL_GPL(sysfs_remove_file_ns);\n\n \nbool sysfs_remove_file_self(struct kobject *kobj, const struct attribute *attr)\n{\n\tstruct kernfs_node *parent = kobj->sd;\n\tstruct kernfs_node *kn;\n\tbool ret;\n\n\tkn = kernfs_find_and_get(parent, attr->name);\n\tif (WARN_ON_ONCE(!kn))\n\t\treturn false;\n\n\tret = kernfs_remove_self(kn);\n\n\tkernfs_put(kn);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(sysfs_remove_file_self);\n\nvoid sysfs_remove_files(struct kobject *kobj, const struct attribute * const *ptr)\n{\n\tint i;\n\n\tfor (i = 0; ptr[i]; i++)\n\t\tsysfs_remove_file(kobj, ptr[i]);\n}\nEXPORT_SYMBOL_GPL(sysfs_remove_files);\n\n \nvoid sysfs_remove_file_from_group(struct kobject *kobj,\n\t\tconst struct attribute *attr, const char *group)\n{\n\tstruct kernfs_node *parent;\n\n\tif (group) {\n\t\tparent = kernfs_find_and_get(kobj->sd, group);\n\t} else {\n\t\tparent = kobj->sd;\n\t\tkernfs_get(parent);\n\t}\n\n\tif (parent) {\n\t\tkernfs_remove_by_name(parent, attr->name);\n\t\tkernfs_put(parent);\n\t}\n}\nEXPORT_SYMBOL_GPL(sysfs_remove_file_from_group);\n\n \nint sysfs_create_bin_file(struct kobject *kobj,\n\t\t\t  const struct bin_attribute *attr)\n{\n\tkuid_t uid;\n\tkgid_t gid;\n\n\tif (WARN_ON(!kobj || !kobj->sd || !attr))\n\t\treturn -EINVAL;\n\n\tkobject_get_ownership(kobj, &uid, &gid);\n\treturn sysfs_add_bin_file_mode_ns(kobj->sd, attr, attr->attr.mode, uid,\n\t\t\t\t\t   gid, NULL);\n}\nEXPORT_SYMBOL_GPL(sysfs_create_bin_file);\n\n \nvoid sysfs_remove_bin_file(struct kobject *kobj,\n\t\t\t   const struct bin_attribute *attr)\n{\n\tkernfs_remove_by_name(kobj->sd, attr->attr.name);\n}\nEXPORT_SYMBOL_GPL(sysfs_remove_bin_file);\n\nstatic int internal_change_owner(struct kernfs_node *kn, kuid_t kuid,\n\t\t\t\t kgid_t kgid)\n{\n\tstruct iattr newattrs = {\n\t\t.ia_valid = ATTR_UID | ATTR_GID,\n\t\t.ia_uid = kuid,\n\t\t.ia_gid = kgid,\n\t};\n\treturn kernfs_setattr(kn, &newattrs);\n}\n\n \nint sysfs_link_change_owner(struct kobject *kobj, struct kobject *targ,\n\t\t\t    const char *name, kuid_t kuid, kgid_t kgid)\n{\n\tstruct kernfs_node *kn = NULL;\n\tint error;\n\n\tif (!name || !kobj->state_in_sysfs || !targ->state_in_sysfs)\n\t\treturn -EINVAL;\n\n\terror = -ENOENT;\n\tkn = kernfs_find_and_get_ns(kobj->sd, name, targ->sd->ns);\n\tif (!kn)\n\t\tgoto out;\n\n\terror = -EINVAL;\n\tif (kernfs_type(kn) != KERNFS_LINK)\n\t\tgoto out;\n\tif (kn->symlink.target_kn->priv != targ)\n\t\tgoto out;\n\n\terror = internal_change_owner(kn, kuid, kgid);\n\nout:\n\tkernfs_put(kn);\n\treturn error;\n}\n\n \nint sysfs_file_change_owner(struct kobject *kobj, const char *name, kuid_t kuid,\n\t\t\t    kgid_t kgid)\n{\n\tstruct kernfs_node *kn;\n\tint error;\n\n\tif (!name)\n\t\treturn -EINVAL;\n\n\tif (!kobj->state_in_sysfs)\n\t\treturn -EINVAL;\n\n\tkn = kernfs_find_and_get(kobj->sd, name);\n\tif (!kn)\n\t\treturn -ENOENT;\n\n\terror = internal_change_owner(kn, kuid, kgid);\n\n\tkernfs_put(kn);\n\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(sysfs_file_change_owner);\n\n \nint sysfs_change_owner(struct kobject *kobj, kuid_t kuid, kgid_t kgid)\n{\n\tint error;\n\tconst struct kobj_type *ktype;\n\n\tif (!kobj->state_in_sysfs)\n\t\treturn -EINVAL;\n\n\t \n\terror = internal_change_owner(kobj->sd, kuid, kgid);\n\tif (error)\n\t\treturn error;\n\n\tktype = get_ktype(kobj);\n\tif (ktype) {\n\t\t \n\t\terror = sysfs_groups_change_owner(kobj, ktype->default_groups,\n\t\t\t\t\t\t  kuid, kgid);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(sysfs_change_owner);\n\n \nint sysfs_emit(char *buf, const char *fmt, ...)\n{\n\tva_list args;\n\tint len;\n\n\tif (WARN(!buf || offset_in_page(buf),\n\t\t \"invalid sysfs_emit: buf:%p\\n\", buf))\n\t\treturn 0;\n\n\tva_start(args, fmt);\n\tlen = vscnprintf(buf, PAGE_SIZE, fmt, args);\n\tva_end(args);\n\n\treturn len;\n}\nEXPORT_SYMBOL_GPL(sysfs_emit);\n\n \nint sysfs_emit_at(char *buf, int at, const char *fmt, ...)\n{\n\tva_list args;\n\tint len;\n\n\tif (WARN(!buf || offset_in_page(buf) || at < 0 || at >= PAGE_SIZE,\n\t\t \"invalid sysfs_emit_at: buf:%p at:%d\\n\", buf, at))\n\t\treturn 0;\n\n\tva_start(args, fmt);\n\tlen = vscnprintf(buf + at, PAGE_SIZE - at, fmt, args);\n\tva_end(args);\n\n\treturn len;\n}\nEXPORT_SYMBOL_GPL(sysfs_emit_at);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}