{
  "module_name": "group.c",
  "hash_id": "482ac8f421ecebae999d69174bd671df30f1a927d1ebeedb8322c685e5ba9a82",
  "original_prompt": "Ingested from linux-6.6.14/fs/sysfs/group.c",
  "human_readable_source": "\n \n\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/dcache.h>\n#include <linux/namei.h>\n#include <linux/err.h>\n#include <linux/fs.h>\n#include \"sysfs.h\"\n\n\nstatic void remove_files(struct kernfs_node *parent,\n\t\t\t const struct attribute_group *grp)\n{\n\tstruct attribute *const *attr;\n\tstruct bin_attribute *const *bin_attr;\n\n\tif (grp->attrs)\n\t\tfor (attr = grp->attrs; *attr; attr++)\n\t\t\tkernfs_remove_by_name(parent, (*attr)->name);\n\tif (grp->bin_attrs)\n\t\tfor (bin_attr = grp->bin_attrs; *bin_attr; bin_attr++)\n\t\t\tkernfs_remove_by_name(parent, (*bin_attr)->attr.name);\n}\n\nstatic int create_files(struct kernfs_node *parent, struct kobject *kobj,\n\t\t\tkuid_t uid, kgid_t gid,\n\t\t\tconst struct attribute_group *grp, int update)\n{\n\tstruct attribute *const *attr;\n\tstruct bin_attribute *const *bin_attr;\n\tint error = 0, i;\n\n\tif (grp->attrs) {\n\t\tfor (i = 0, attr = grp->attrs; *attr && !error; i++, attr++) {\n\t\t\tumode_t mode = (*attr)->mode;\n\n\t\t\t \n\t\t\tif (update)\n\t\t\t\tkernfs_remove_by_name(parent, (*attr)->name);\n\t\t\tif (grp->is_visible) {\n\t\t\t\tmode = grp->is_visible(kobj, *attr, i);\n\t\t\t\tif (!mode)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tWARN(mode & ~(SYSFS_PREALLOC | 0664),\n\t\t\t     \"Attribute %s: Invalid permissions 0%o\\n\",\n\t\t\t     (*attr)->name, mode);\n\n\t\t\tmode &= SYSFS_PREALLOC | 0664;\n\t\t\terror = sysfs_add_file_mode_ns(parent, *attr, mode, uid,\n\t\t\t\t\t\t       gid, NULL);\n\t\t\tif (unlikely(error))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (error) {\n\t\t\tremove_files(parent, grp);\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (grp->bin_attrs) {\n\t\tfor (i = 0, bin_attr = grp->bin_attrs; *bin_attr; i++, bin_attr++) {\n\t\t\tumode_t mode = (*bin_attr)->attr.mode;\n\n\t\t\tif (update)\n\t\t\t\tkernfs_remove_by_name(parent,\n\t\t\t\t\t\t(*bin_attr)->attr.name);\n\t\t\tif (grp->is_bin_visible) {\n\t\t\t\tmode = grp->is_bin_visible(kobj, *bin_attr, i);\n\t\t\t\tif (!mode)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tWARN(mode & ~(SYSFS_PREALLOC | 0664),\n\t\t\t     \"Attribute %s: Invalid permissions 0%o\\n\",\n\t\t\t     (*bin_attr)->attr.name, mode);\n\n\t\t\tmode &= SYSFS_PREALLOC | 0664;\n\t\t\terror = sysfs_add_bin_file_mode_ns(parent, *bin_attr,\n\t\t\t\t\t\t\t   mode, uid, gid,\n\t\t\t\t\t\t\t   NULL);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (error)\n\t\t\tremove_files(parent, grp);\n\t}\nexit:\n\treturn error;\n}\n\n\nstatic int internal_create_group(struct kobject *kobj, int update,\n\t\t\t\t const struct attribute_group *grp)\n{\n\tstruct kernfs_node *kn;\n\tkuid_t uid;\n\tkgid_t gid;\n\tint error;\n\n\tif (WARN_ON(!kobj || (!update && !kobj->sd)))\n\t\treturn -EINVAL;\n\n\t \n\tif (unlikely(update && !kobj->sd))\n\t\treturn -EINVAL;\n\n\tif (!grp->attrs && !grp->bin_attrs) {\n\t\tpr_debug(\"sysfs: (bin_)attrs not set by subsystem for group: %s/%s, skipping\\n\",\n\t\t\t kobj->name, grp->name ?: \"\");\n\t\treturn 0;\n\t}\n\n\tkobject_get_ownership(kobj, &uid, &gid);\n\tif (grp->name) {\n\t\tif (update) {\n\t\t\tkn = kernfs_find_and_get(kobj->sd, grp->name);\n\t\t\tif (!kn) {\n\t\t\t\tpr_warn(\"Can't update unknown attr grp name: %s/%s\\n\",\n\t\t\t\t\tkobj->name, grp->name);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\tkn = kernfs_create_dir_ns(kobj->sd, grp->name,\n\t\t\t\t\t\t  S_IRWXU | S_IRUGO | S_IXUGO,\n\t\t\t\t\t\t  uid, gid, kobj, NULL);\n\t\t\tif (IS_ERR(kn)) {\n\t\t\t\tif (PTR_ERR(kn) == -EEXIST)\n\t\t\t\t\tsysfs_warn_dup(kobj->sd, grp->name);\n\t\t\t\treturn PTR_ERR(kn);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tkn = kobj->sd;\n\t}\n\n\tkernfs_get(kn);\n\terror = create_files(kn, kobj, uid, gid, grp, update);\n\tif (error) {\n\t\tif (grp->name)\n\t\t\tkernfs_remove(kn);\n\t}\n\tkernfs_put(kn);\n\n\tif (grp->name && update)\n\t\tkernfs_put(kn);\n\n\treturn error;\n}\n\n \nint sysfs_create_group(struct kobject *kobj,\n\t\t       const struct attribute_group *grp)\n{\n\treturn internal_create_group(kobj, 0, grp);\n}\nEXPORT_SYMBOL_GPL(sysfs_create_group);\n\nstatic int internal_create_groups(struct kobject *kobj, int update,\n\t\t\t\t  const struct attribute_group **groups)\n{\n\tint error = 0;\n\tint i;\n\n\tif (!groups)\n\t\treturn 0;\n\n\tfor (i = 0; groups[i]; i++) {\n\t\terror = internal_create_group(kobj, update, groups[i]);\n\t\tif (error) {\n\t\t\twhile (--i >= 0)\n\t\t\t\tsysfs_remove_group(kobj, groups[i]);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn error;\n}\n\n \nint sysfs_create_groups(struct kobject *kobj,\n\t\t\tconst struct attribute_group **groups)\n{\n\treturn internal_create_groups(kobj, 0, groups);\n}\nEXPORT_SYMBOL_GPL(sysfs_create_groups);\n\n \nint sysfs_update_groups(struct kobject *kobj,\n\t\t\tconst struct attribute_group **groups)\n{\n\treturn internal_create_groups(kobj, 1, groups);\n}\nEXPORT_SYMBOL_GPL(sysfs_update_groups);\n\n \nint sysfs_update_group(struct kobject *kobj,\n\t\t       const struct attribute_group *grp)\n{\n\treturn internal_create_group(kobj, 1, grp);\n}\nEXPORT_SYMBOL_GPL(sysfs_update_group);\n\n \nvoid sysfs_remove_group(struct kobject *kobj,\n\t\t\tconst struct attribute_group *grp)\n{\n\tstruct kernfs_node *parent = kobj->sd;\n\tstruct kernfs_node *kn;\n\n\tif (grp->name) {\n\t\tkn = kernfs_find_and_get(parent, grp->name);\n\t\tif (!kn) {\n\t\t\tWARN(!kn, KERN_WARNING\n\t\t\t     \"sysfs group '%s' not found for kobject '%s'\\n\",\n\t\t\t     grp->name, kobject_name(kobj));\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tkn = parent;\n\t\tkernfs_get(kn);\n\t}\n\n\tremove_files(kn, grp);\n\tif (grp->name)\n\t\tkernfs_remove(kn);\n\n\tkernfs_put(kn);\n}\nEXPORT_SYMBOL_GPL(sysfs_remove_group);\n\n \nvoid sysfs_remove_groups(struct kobject *kobj,\n\t\t\t const struct attribute_group **groups)\n{\n\tint i;\n\n\tif (!groups)\n\t\treturn;\n\tfor (i = 0; groups[i]; i++)\n\t\tsysfs_remove_group(kobj, groups[i]);\n}\nEXPORT_SYMBOL_GPL(sysfs_remove_groups);\n\n \nint sysfs_merge_group(struct kobject *kobj,\n\t\t       const struct attribute_group *grp)\n{\n\tstruct kernfs_node *parent;\n\tkuid_t uid;\n\tkgid_t gid;\n\tint error = 0;\n\tstruct attribute *const *attr;\n\tint i;\n\n\tparent = kernfs_find_and_get(kobj->sd, grp->name);\n\tif (!parent)\n\t\treturn -ENOENT;\n\n\tkobject_get_ownership(kobj, &uid, &gid);\n\n\tfor ((i = 0, attr = grp->attrs); *attr && !error; (++i, ++attr))\n\t\terror = sysfs_add_file_mode_ns(parent, *attr, (*attr)->mode,\n\t\t\t\t\t       uid, gid, NULL);\n\tif (error) {\n\t\twhile (--i >= 0)\n\t\t\tkernfs_remove_by_name(parent, (*--attr)->name);\n\t}\n\tkernfs_put(parent);\n\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(sysfs_merge_group);\n\n \nvoid sysfs_unmerge_group(struct kobject *kobj,\n\t\t       const struct attribute_group *grp)\n{\n\tstruct kernfs_node *parent;\n\tstruct attribute *const *attr;\n\n\tparent = kernfs_find_and_get(kobj->sd, grp->name);\n\tif (parent) {\n\t\tfor (attr = grp->attrs; *attr; ++attr)\n\t\t\tkernfs_remove_by_name(parent, (*attr)->name);\n\t\tkernfs_put(parent);\n\t}\n}\nEXPORT_SYMBOL_GPL(sysfs_unmerge_group);\n\n \nint sysfs_add_link_to_group(struct kobject *kobj, const char *group_name,\n\t\t\t    struct kobject *target, const char *link_name)\n{\n\tstruct kernfs_node *parent;\n\tint error = 0;\n\n\tparent = kernfs_find_and_get(kobj->sd, group_name);\n\tif (!parent)\n\t\treturn -ENOENT;\n\n\terror = sysfs_create_link_sd(parent, target, link_name);\n\tkernfs_put(parent);\n\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(sysfs_add_link_to_group);\n\n \nvoid sysfs_remove_link_from_group(struct kobject *kobj, const char *group_name,\n\t\t\t\t  const char *link_name)\n{\n\tstruct kernfs_node *parent;\n\n\tparent = kernfs_find_and_get(kobj->sd, group_name);\n\tif (parent) {\n\t\tkernfs_remove_by_name(parent, link_name);\n\t\tkernfs_put(parent);\n\t}\n}\nEXPORT_SYMBOL_GPL(sysfs_remove_link_from_group);\n\n \nint compat_only_sysfs_link_entry_to_kobj(struct kobject *kobj,\n\t\t\t\t\t struct kobject *target_kobj,\n\t\t\t\t\t const char *target_name,\n\t\t\t\t\t const char *symlink_name)\n{\n\tstruct kernfs_node *target;\n\tstruct kernfs_node *entry;\n\tstruct kernfs_node *link;\n\n\t \n\tspin_lock(&sysfs_symlink_target_lock);\n\ttarget = target_kobj->sd;\n\tif (target)\n\t\tkernfs_get(target);\n\tspin_unlock(&sysfs_symlink_target_lock);\n\tif (!target)\n\t\treturn -ENOENT;\n\n\tentry = kernfs_find_and_get(target, target_name);\n\tif (!entry) {\n\t\tkernfs_put(target);\n\t\treturn -ENOENT;\n\t}\n\n\tif (!symlink_name)\n\t\tsymlink_name = target_name;\n\n\tlink = kernfs_create_link(kobj->sd, symlink_name, entry);\n\tif (PTR_ERR(link) == -EEXIST)\n\t\tsysfs_warn_dup(kobj->sd, symlink_name);\n\n\tkernfs_put(entry);\n\tkernfs_put(target);\n\treturn PTR_ERR_OR_ZERO(link);\n}\nEXPORT_SYMBOL_GPL(compat_only_sysfs_link_entry_to_kobj);\n\nstatic int sysfs_group_attrs_change_owner(struct kernfs_node *grp_kn,\n\t\t\t\t\t  const struct attribute_group *grp,\n\t\t\t\t\t  struct iattr *newattrs)\n{\n\tstruct kernfs_node *kn;\n\tint error;\n\n\tif (grp->attrs) {\n\t\tstruct attribute *const *attr;\n\n\t\tfor (attr = grp->attrs; *attr; attr++) {\n\t\t\tkn = kernfs_find_and_get(grp_kn, (*attr)->name);\n\t\t\tif (!kn)\n\t\t\t\treturn -ENOENT;\n\n\t\t\terror = kernfs_setattr(kn, newattrs);\n\t\t\tkernfs_put(kn);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\tif (grp->bin_attrs) {\n\t\tstruct bin_attribute *const *bin_attr;\n\n\t\tfor (bin_attr = grp->bin_attrs; *bin_attr; bin_attr++) {\n\t\t\tkn = kernfs_find_and_get(grp_kn, (*bin_attr)->attr.name);\n\t\t\tif (!kn)\n\t\t\t\treturn -ENOENT;\n\n\t\t\terror = kernfs_setattr(kn, newattrs);\n\t\t\tkernfs_put(kn);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nint sysfs_group_change_owner(struct kobject *kobj,\n\t\t\t     const struct attribute_group *grp, kuid_t kuid,\n\t\t\t     kgid_t kgid)\n{\n\tstruct kernfs_node *grp_kn;\n\tint error;\n\tstruct iattr newattrs = {\n\t\t.ia_valid = ATTR_UID | ATTR_GID,\n\t\t.ia_uid = kuid,\n\t\t.ia_gid = kgid,\n\t};\n\n\tif (!kobj->state_in_sysfs)\n\t\treturn -EINVAL;\n\n\tif (grp->name) {\n\t\tgrp_kn = kernfs_find_and_get(kobj->sd, grp->name);\n\t} else {\n\t\tkernfs_get(kobj->sd);\n\t\tgrp_kn = kobj->sd;\n\t}\n\tif (!grp_kn)\n\t\treturn -ENOENT;\n\n\terror = kernfs_setattr(grp_kn, &newattrs);\n\tif (!error)\n\t\terror = sysfs_group_attrs_change_owner(grp_kn, grp, &newattrs);\n\n\tkernfs_put(grp_kn);\n\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(sysfs_group_change_owner);\n\n \nint sysfs_groups_change_owner(struct kobject *kobj,\n\t\t\t      const struct attribute_group **groups,\n\t\t\t      kuid_t kuid, kgid_t kgid)\n{\n\tint error = 0, i;\n\n\tif (!kobj->state_in_sysfs)\n\t\treturn -EINVAL;\n\n\tif (!groups)\n\t\treturn 0;\n\n\tfor (i = 0; groups[i]; i++) {\n\t\terror = sysfs_group_change_owner(kobj, groups[i], kuid, kgid);\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(sysfs_groups_change_owner);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}