{
  "module_name": "symlink.c",
  "hash_id": "9f1d51db38357c55d331ad76a341052a26a0b26a94ab5339380ff47603dbdb89",
  "original_prompt": "Ingested from linux-6.6.14/fs/sysfs/symlink.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/kobject.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n\n#include \"sysfs.h\"\n\nstatic int sysfs_do_create_link_sd(struct kernfs_node *parent,\n\t\t\t\t   struct kobject *target_kobj,\n\t\t\t\t   const char *name, int warn)\n{\n\tstruct kernfs_node *kn, *target = NULL;\n\n\tif (WARN_ON(!name || !parent))\n\t\treturn -EINVAL;\n\n\t \n\tspin_lock(&sysfs_symlink_target_lock);\n\tif (target_kobj->sd) {\n\t\ttarget = target_kobj->sd;\n\t\tkernfs_get(target);\n\t}\n\tspin_unlock(&sysfs_symlink_target_lock);\n\n\tif (!target)\n\t\treturn -ENOENT;\n\n\tkn = kernfs_create_link(parent, name, target);\n\tkernfs_put(target);\n\n\tif (!IS_ERR(kn))\n\t\treturn 0;\n\n\tif (warn && PTR_ERR(kn) == -EEXIST)\n\t\tsysfs_warn_dup(parent, name);\n\treturn PTR_ERR(kn);\n}\n\n \nint sysfs_create_link_sd(struct kernfs_node *kn, struct kobject *target,\n\t\t\t const char *name)\n{\n\treturn sysfs_do_create_link_sd(kn, target, name, 1);\n}\n\nstatic int sysfs_do_create_link(struct kobject *kobj, struct kobject *target,\n\t\t\t\tconst char *name, int warn)\n{\n\tstruct kernfs_node *parent = NULL;\n\n\tif (!kobj)\n\t\tparent = sysfs_root_kn;\n\telse\n\t\tparent = kobj->sd;\n\n\tif (!parent)\n\t\treturn -EFAULT;\n\n\treturn sysfs_do_create_link_sd(parent, target, name, warn);\n}\n\n \nint sysfs_create_link(struct kobject *kobj, struct kobject *target,\n\t\t      const char *name)\n{\n\treturn sysfs_do_create_link(kobj, target, name, 1);\n}\nEXPORT_SYMBOL_GPL(sysfs_create_link);\n\n \nint sysfs_create_link_nowarn(struct kobject *kobj, struct kobject *target,\n\t\t\t     const char *name)\n{\n\treturn sysfs_do_create_link(kobj, target, name, 0);\n}\nEXPORT_SYMBOL_GPL(sysfs_create_link_nowarn);\n\n \nvoid sysfs_delete_link(struct kobject *kobj, struct kobject *targ,\n\t\t\tconst char *name)\n{\n\tconst void *ns = NULL;\n\n\t \n\tspin_lock(&sysfs_symlink_target_lock);\n\tif (targ->sd && kernfs_ns_enabled(kobj->sd))\n\t\tns = targ->sd->ns;\n\tspin_unlock(&sysfs_symlink_target_lock);\n\tkernfs_remove_by_name_ns(kobj->sd, name, ns);\n}\n\n \nvoid sysfs_remove_link(struct kobject *kobj, const char *name)\n{\n\tstruct kernfs_node *parent = NULL;\n\n\tif (!kobj)\n\t\tparent = sysfs_root_kn;\n\telse\n\t\tparent = kobj->sd;\n\n\tkernfs_remove_by_name(parent, name);\n}\nEXPORT_SYMBOL_GPL(sysfs_remove_link);\n\n \nint sysfs_rename_link_ns(struct kobject *kobj, struct kobject *targ,\n\t\t\t const char *old, const char *new, const void *new_ns)\n{\n\tstruct kernfs_node *parent, *kn = NULL;\n\tconst void *old_ns = NULL;\n\tint result;\n\n\tif (!kobj)\n\t\tparent = sysfs_root_kn;\n\telse\n\t\tparent = kobj->sd;\n\n\tif (targ->sd)\n\t\told_ns = targ->sd->ns;\n\n\tresult = -ENOENT;\n\tkn = kernfs_find_and_get_ns(parent, old, old_ns);\n\tif (!kn)\n\t\tgoto out;\n\n\tresult = -EINVAL;\n\tif (kernfs_type(kn) != KERNFS_LINK)\n\t\tgoto out;\n\tif (kn->symlink.target_kn->priv != targ)\n\t\tgoto out;\n\n\tresult = kernfs_rename_ns(kn, parent, new, new_ns);\n\nout:\n\tkernfs_put(kn);\n\treturn result;\n}\nEXPORT_SYMBOL_GPL(sysfs_rename_link_ns);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}