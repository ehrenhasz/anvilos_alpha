{
  "module_name": "dir.c",
  "hash_id": "385befda11f4dcaccf980e47f2182a4d7b770d68046bcba0448c995b9d1d9a4a",
  "original_prompt": "Ingested from linux-6.6.14/fs/sysfs/dir.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\t\"sysfs: \" fmt\n\n#include <linux/fs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include \"sysfs.h\"\n\nDEFINE_SPINLOCK(sysfs_symlink_target_lock);\n\nvoid sysfs_warn_dup(struct kernfs_node *parent, const char *name)\n{\n\tchar *buf;\n\n\tbuf = kzalloc(PATH_MAX, GFP_KERNEL);\n\tif (buf)\n\t\tkernfs_path(parent, buf, PATH_MAX);\n\n\tpr_warn(\"cannot create duplicate filename '%s/%s'\\n\", buf, name);\n\tdump_stack();\n\n\tkfree(buf);\n}\n\n \nint sysfs_create_dir_ns(struct kobject *kobj, const void *ns)\n{\n\tstruct kernfs_node *parent, *kn;\n\tkuid_t uid;\n\tkgid_t gid;\n\n\tif (WARN_ON(!kobj))\n\t\treturn -EINVAL;\n\n\tif (kobj->parent)\n\t\tparent = kobj->parent->sd;\n\telse\n\t\tparent = sysfs_root_kn;\n\n\tif (!parent)\n\t\treturn -ENOENT;\n\n\tkobject_get_ownership(kobj, &uid, &gid);\n\n\tkn = kernfs_create_dir_ns(parent, kobject_name(kobj), 0755, uid, gid,\n\t\t\t\t  kobj, ns);\n\tif (IS_ERR(kn)) {\n\t\tif (PTR_ERR(kn) == -EEXIST)\n\t\t\tsysfs_warn_dup(parent, kobject_name(kobj));\n\t\treturn PTR_ERR(kn);\n\t}\n\n\tkobj->sd = kn;\n\treturn 0;\n}\n\n \nvoid sysfs_remove_dir(struct kobject *kobj)\n{\n\tstruct kernfs_node *kn = kobj->sd;\n\n\t \n\tspin_lock(&sysfs_symlink_target_lock);\n\tkobj->sd = NULL;\n\tspin_unlock(&sysfs_symlink_target_lock);\n\n\tif (kn) {\n\t\tWARN_ON_ONCE(kernfs_type(kn) != KERNFS_DIR);\n\t\tkernfs_remove(kn);\n\t}\n}\n\nint sysfs_rename_dir_ns(struct kobject *kobj, const char *new_name,\n\t\t\tconst void *new_ns)\n{\n\tstruct kernfs_node *parent;\n\tint ret;\n\n\tparent = kernfs_get_parent(kobj->sd);\n\tret = kernfs_rename_ns(kobj->sd, parent, new_name, new_ns);\n\tkernfs_put(parent);\n\treturn ret;\n}\n\nint sysfs_move_dir_ns(struct kobject *kobj, struct kobject *new_parent_kobj,\n\t\t      const void *new_ns)\n{\n\tstruct kernfs_node *kn = kobj->sd;\n\tstruct kernfs_node *new_parent;\n\n\tnew_parent = new_parent_kobj && new_parent_kobj->sd ?\n\t\tnew_parent_kobj->sd : sysfs_root_kn;\n\n\treturn kernfs_rename_ns(kn, new_parent, kn->name, new_ns);\n}\n\n \nint sysfs_create_mount_point(struct kobject *parent_kobj, const char *name)\n{\n\tstruct kernfs_node *kn, *parent = parent_kobj->sd;\n\n\tkn = kernfs_create_empty_dir(parent, name);\n\tif (IS_ERR(kn)) {\n\t\tif (PTR_ERR(kn) == -EEXIST)\n\t\t\tsysfs_warn_dup(parent, name);\n\t\treturn PTR_ERR(kn);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(sysfs_create_mount_point);\n\n \nvoid sysfs_remove_mount_point(struct kobject *parent_kobj, const char *name)\n{\n\tstruct kernfs_node *parent = parent_kobj->sd;\n\n\tkernfs_remove_by_name_ns(parent, name, NULL);\n}\nEXPORT_SYMBOL_GPL(sysfs_remove_mount_point);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}