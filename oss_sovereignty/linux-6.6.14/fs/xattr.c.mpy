{
  "module_name": "xattr.c",
  "hash_id": "aaf9a07f617467436da6eace104191ba10708b3810d7f35c2c0f3d6ecf22687e",
  "original_prompt": "Ingested from linux-6.6.14/fs/xattr.c",
  "human_readable_source": "\n \n#include <linux/fs.h>\n#include <linux/filelock.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/security.h>\n#include <linux/evm.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/fsnotify.h>\n#include <linux/audit.h>\n#include <linux/vmalloc.h>\n#include <linux/posix_acl_xattr.h>\n\n#include <linux/uaccess.h>\n\n#include \"internal.h\"\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}\n\n \n#define for_each_xattr_handler(handlers, handler)\t\t\\\n\tif (handlers)\t\t\t\t\t\t\\\n\t\tfor ((handler) = *(handlers)++;\t\t\t\\\n\t\t\t(handler) != NULL;\t\t\t\\\n\t\t\t(handler) = *(handlers)++)\n\n \nstatic const struct xattr_handler *\nxattr_resolve_name(struct inode *inode, const char **name)\n{\n\tconst struct xattr_handler **handlers = inode->i_sb->s_xattr;\n\tconst struct xattr_handler *handler;\n\n\tif (!(inode->i_opflags & IOP_XATTR)) {\n\t\tif (unlikely(is_bad_inode(inode)))\n\t\t\treturn ERR_PTR(-EIO);\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\t}\n\tfor_each_xattr_handler(handlers, handler) {\n\t\tconst char *n;\n\n\t\tn = strcmp_prefix(*name, xattr_prefix(handler));\n\t\tif (n) {\n\t\t\tif (!handler->prefix ^ !*n) {\n\t\t\t\tif (*n)\n\t\t\t\t\tcontinue;\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\t}\n\t\t\t*name = n;\n\t\t\treturn handler;\n\t\t}\n\t}\n\treturn ERR_PTR(-EOPNOTSUPP);\n}\n\n \nint may_write_xattr(struct mnt_idmap *idmap, struct inode *inode)\n{\n\tif (IS_IMMUTABLE(inode))\n\t\treturn -EPERM;\n\tif (IS_APPEND(inode))\n\t\treturn -EPERM;\n\tif (HAS_UNMAPPED_ID(idmap, inode))\n\t\treturn -EPERM;\n\treturn 0;\n}\n\n \nstatic int\nxattr_permission(struct mnt_idmap *idmap, struct inode *inode,\n\t\t const char *name, int mask)\n{\n\tif (mask & MAY_WRITE) {\n\t\tint ret;\n\n\t\tret = may_write_xattr(idmap, inode);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (!strncmp(name, XATTR_SECURITY_PREFIX, XATTR_SECURITY_PREFIX_LEN) ||\n\t    !strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))\n\t\treturn 0;\n\n\t \n\tif (!strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN)) {\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn (mask & MAY_WRITE) ? -EPERM : -ENODATA;\n\t\treturn 0;\n\t}\n\n\t \n\tif (!strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN)) {\n\t\tif (!S_ISREG(inode->i_mode) && !S_ISDIR(inode->i_mode))\n\t\t\treturn (mask & MAY_WRITE) ? -EPERM : -ENODATA;\n\t\tif (S_ISDIR(inode->i_mode) && (inode->i_mode & S_ISVTX) &&\n\t\t    (mask & MAY_WRITE) &&\n\t\t    !inode_owner_or_capable(idmap, inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn inode_permission(idmap, inode, mask);\n}\n\n \nint\nxattr_supports_user_prefix(struct inode *inode)\n{\n\tconst struct xattr_handler **handlers = inode->i_sb->s_xattr;\n\tconst struct xattr_handler *handler;\n\n\tif (!(inode->i_opflags & IOP_XATTR)) {\n\t\tif (unlikely(is_bad_inode(inode)))\n\t\t\treturn -EIO;\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tfor_each_xattr_handler(handlers, handler) {\n\t\tif (!strncmp(xattr_prefix(handler), XATTR_USER_PREFIX,\n\t\t\t     XATTR_USER_PREFIX_LEN))\n\t\t\treturn 0;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\nEXPORT_SYMBOL(xattr_supports_user_prefix);\n\nint\n__vfs_setxattr(struct mnt_idmap *idmap, struct dentry *dentry,\n\t       struct inode *inode, const char *name, const void *value,\n\t       size_t size, int flags)\n{\n\tconst struct xattr_handler *handler;\n\n\tif (is_posix_acl_xattr(name))\n\t\treturn -EOPNOTSUPP;\n\n\thandler = xattr_resolve_name(inode, &name);\n\tif (IS_ERR(handler))\n\t\treturn PTR_ERR(handler);\n\tif (!handler->set)\n\t\treturn -EOPNOTSUPP;\n\tif (size == 0)\n\t\tvalue = \"\";   \n\treturn handler->set(handler, idmap, dentry, inode, name, value,\n\t\t\t    size, flags);\n}\nEXPORT_SYMBOL(__vfs_setxattr);\n\n \nint __vfs_setxattr_noperm(struct mnt_idmap *idmap,\n\t\t\t  struct dentry *dentry, const char *name,\n\t\t\t  const void *value, size_t size, int flags)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error = -EAGAIN;\n\tint issec = !strncmp(name, XATTR_SECURITY_PREFIX,\n\t\t\t\t   XATTR_SECURITY_PREFIX_LEN);\n\n\tif (issec)\n\t\tinode->i_flags &= ~S_NOSEC;\n\tif (inode->i_opflags & IOP_XATTR) {\n\t\terror = __vfs_setxattr(idmap, dentry, inode, name, value,\n\t\t\t\t       size, flags);\n\t\tif (!error) {\n\t\t\tfsnotify_xattr(dentry);\n\t\t\tsecurity_inode_post_setxattr(dentry, name, value,\n\t\t\t\t\t\t     size, flags);\n\t\t}\n\t} else {\n\t\tif (unlikely(is_bad_inode(inode)))\n\t\t\treturn -EIO;\n\t}\n\tif (error == -EAGAIN) {\n\t\terror = -EOPNOTSUPP;\n\n\t\tif (issec) {\n\t\t\tconst char *suffix = name + XATTR_SECURITY_PREFIX_LEN;\n\n\t\t\terror = security_inode_setsecurity(inode, suffix, value,\n\t\t\t\t\t\t\t   size, flags);\n\t\t\tif (!error)\n\t\t\t\tfsnotify_xattr(dentry);\n\t\t}\n\t}\n\n\treturn error;\n}\n\n \nint\n__vfs_setxattr_locked(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\t      const char *name, const void *value, size_t size,\n\t\t      int flags, struct inode **delegated_inode)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = xattr_permission(idmap, inode, name, MAY_WRITE);\n\tif (error)\n\t\treturn error;\n\n\terror = security_inode_setxattr(idmap, dentry, name, value, size,\n\t\t\t\t\tflags);\n\tif (error)\n\t\tgoto out;\n\n\terror = try_break_deleg(inode, delegated_inode);\n\tif (error)\n\t\tgoto out;\n\n\terror = __vfs_setxattr_noperm(idmap, dentry, name, value,\n\t\t\t\t      size, flags);\n\nout:\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(__vfs_setxattr_locked);\n\nint\nvfs_setxattr(struct mnt_idmap *idmap, struct dentry *dentry,\n\t     const char *name, const void *value, size_t size, int flags)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct inode *delegated_inode = NULL;\n\tconst void  *orig_value = value;\n\tint error;\n\n\tif (size && strcmp(name, XATTR_NAME_CAPS) == 0) {\n\t\terror = cap_convert_nscap(idmap, dentry, &value, size);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t\tsize = error;\n\t}\n\nretry_deleg:\n\tinode_lock(inode);\n\terror = __vfs_setxattr_locked(idmap, dentry, name, value, size,\n\t\t\t\t      flags, &delegated_inode);\n\tinode_unlock(inode);\n\n\tif (delegated_inode) {\n\t\terror = break_deleg_wait(&delegated_inode);\n\t\tif (!error)\n\t\t\tgoto retry_deleg;\n\t}\n\tif (value != orig_value)\n\t\tkfree(value);\n\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(vfs_setxattr);\n\nstatic ssize_t\nxattr_getsecurity(struct mnt_idmap *idmap, struct inode *inode,\n\t\t  const char *name, void *value, size_t size)\n{\n\tvoid *buffer = NULL;\n\tssize_t len;\n\n\tif (!value || !size) {\n\t\tlen = security_inode_getsecurity(idmap, inode, name,\n\t\t\t\t\t\t &buffer, false);\n\t\tgoto out_noalloc;\n\t}\n\n\tlen = security_inode_getsecurity(idmap, inode, name, &buffer,\n\t\t\t\t\t true);\n\tif (len < 0)\n\t\treturn len;\n\tif (size < len) {\n\t\tlen = -ERANGE;\n\t\tgoto out;\n\t}\n\tmemcpy(value, buffer, len);\nout:\n\tkfree(buffer);\nout_noalloc:\n\treturn len;\n}\n\n \nint\nvfs_getxattr_alloc(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\t   const char *name, char **xattr_value, size_t xattr_size,\n\t\t   gfp_t flags)\n{\n\tconst struct xattr_handler *handler;\n\tstruct inode *inode = dentry->d_inode;\n\tchar *value = *xattr_value;\n\tint error;\n\n\terror = xattr_permission(idmap, inode, name, MAY_READ);\n\tif (error)\n\t\treturn error;\n\n\thandler = xattr_resolve_name(inode, &name);\n\tif (IS_ERR(handler))\n\t\treturn PTR_ERR(handler);\n\tif (!handler->get)\n\t\treturn -EOPNOTSUPP;\n\terror = handler->get(handler, dentry, inode, name, NULL, 0);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (!value || (error > xattr_size)) {\n\t\tvalue = krealloc(*xattr_value, error + 1, flags);\n\t\tif (!value)\n\t\t\treturn -ENOMEM;\n\t\tmemset(value, 0, error + 1);\n\t}\n\n\terror = handler->get(handler, dentry, inode, name, value, error);\n\t*xattr_value = value;\n\treturn error;\n}\n\nssize_t\n__vfs_getxattr(struct dentry *dentry, struct inode *inode, const char *name,\n\t       void *value, size_t size)\n{\n\tconst struct xattr_handler *handler;\n\n\tif (is_posix_acl_xattr(name))\n\t\treturn -EOPNOTSUPP;\n\n\thandler = xattr_resolve_name(inode, &name);\n\tif (IS_ERR(handler))\n\t\treturn PTR_ERR(handler);\n\tif (!handler->get)\n\t\treturn -EOPNOTSUPP;\n\treturn handler->get(handler, dentry, inode, name, value, size);\n}\nEXPORT_SYMBOL(__vfs_getxattr);\n\nssize_t\nvfs_getxattr(struct mnt_idmap *idmap, struct dentry *dentry,\n\t     const char *name, void *value, size_t size)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = xattr_permission(idmap, inode, name, MAY_READ);\n\tif (error)\n\t\treturn error;\n\n\terror = security_inode_getxattr(dentry, name);\n\tif (error)\n\t\treturn error;\n\n\tif (!strncmp(name, XATTR_SECURITY_PREFIX,\n\t\t\t\tXATTR_SECURITY_PREFIX_LEN)) {\n\t\tconst char *suffix = name + XATTR_SECURITY_PREFIX_LEN;\n\t\tint ret = xattr_getsecurity(idmap, inode, suffix, value,\n\t\t\t\t\t    size);\n\t\t \n\t\tif (ret == -EOPNOTSUPP)\n\t\t\tgoto nolsm;\n\t\treturn ret;\n\t}\nnolsm:\n\treturn __vfs_getxattr(dentry, inode, name, value, size);\n}\nEXPORT_SYMBOL_GPL(vfs_getxattr);\n\n \nssize_t\nvfs_listxattr(struct dentry *dentry, char *list, size_t size)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tssize_t error;\n\n\terror = security_inode_listxattr(dentry);\n\tif (error)\n\t\treturn error;\n\n\tif (inode->i_op->listxattr) {\n\t\terror = inode->i_op->listxattr(dentry, list, size);\n\t} else {\n\t\terror = security_inode_listsecurity(inode, list, size);\n\t\tif (size && error > size)\n\t\t\terror = -ERANGE;\n\t}\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(vfs_listxattr);\n\nint\n__vfs_removexattr(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\t  const char *name)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tconst struct xattr_handler *handler;\n\n\tif (is_posix_acl_xattr(name))\n\t\treturn -EOPNOTSUPP;\n\n\thandler = xattr_resolve_name(inode, &name);\n\tif (IS_ERR(handler))\n\t\treturn PTR_ERR(handler);\n\tif (!handler->set)\n\t\treturn -EOPNOTSUPP;\n\treturn handler->set(handler, idmap, dentry, inode, name, NULL, 0,\n\t\t\t    XATTR_REPLACE);\n}\nEXPORT_SYMBOL(__vfs_removexattr);\n\n \nint\n__vfs_removexattr_locked(struct mnt_idmap *idmap,\n\t\t\t struct dentry *dentry, const char *name,\n\t\t\t struct inode **delegated_inode)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = xattr_permission(idmap, inode, name, MAY_WRITE);\n\tif (error)\n\t\treturn error;\n\n\terror = security_inode_removexattr(idmap, dentry, name);\n\tif (error)\n\t\tgoto out;\n\n\terror = try_break_deleg(inode, delegated_inode);\n\tif (error)\n\t\tgoto out;\n\n\terror = __vfs_removexattr(idmap, dentry, name);\n\n\tif (!error) {\n\t\tfsnotify_xattr(dentry);\n\t\tevm_inode_post_removexattr(dentry, name);\n\t}\n\nout:\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(__vfs_removexattr_locked);\n\nint\nvfs_removexattr(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\tconst char *name)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct inode *delegated_inode = NULL;\n\tint error;\n\nretry_deleg:\n\tinode_lock(inode);\n\terror = __vfs_removexattr_locked(idmap, dentry,\n\t\t\t\t\t name, &delegated_inode);\n\tinode_unlock(inode);\n\n\tif (delegated_inode) {\n\t\terror = break_deleg_wait(&delegated_inode);\n\t\tif (!error)\n\t\t\tgoto retry_deleg;\n\t}\n\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(vfs_removexattr);\n\n \n\nint setxattr_copy(const char __user *name, struct xattr_ctx *ctx)\n{\n\tint error;\n\n\tif (ctx->flags & ~(XATTR_CREATE|XATTR_REPLACE))\n\t\treturn -EINVAL;\n\n\terror = strncpy_from_user(ctx->kname->name, name,\n\t\t\t\tsizeof(ctx->kname->name));\n\tif (error == 0 || error == sizeof(ctx->kname->name))\n\t\treturn  -ERANGE;\n\tif (error < 0)\n\t\treturn error;\n\n\terror = 0;\n\tif (ctx->size) {\n\t\tif (ctx->size > XATTR_SIZE_MAX)\n\t\t\treturn -E2BIG;\n\n\t\tctx->kvalue = vmemdup_user(ctx->cvalue, ctx->size);\n\t\tif (IS_ERR(ctx->kvalue)) {\n\t\t\terror = PTR_ERR(ctx->kvalue);\n\t\t\tctx->kvalue = NULL;\n\t\t}\n\t}\n\n\treturn error;\n}\n\nint do_setxattr(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\tstruct xattr_ctx *ctx)\n{\n\tif (is_posix_acl_xattr(ctx->kname->name))\n\t\treturn do_set_acl(idmap, dentry, ctx->kname->name,\n\t\t\t\t  ctx->kvalue, ctx->size);\n\n\treturn vfs_setxattr(idmap, dentry, ctx->kname->name,\n\t\t\tctx->kvalue, ctx->size, ctx->flags);\n}\n\nstatic long\nsetxattr(struct mnt_idmap *idmap, struct dentry *d,\n\tconst char __user *name, const void __user *value, size_t size,\n\tint flags)\n{\n\tstruct xattr_name kname;\n\tstruct xattr_ctx ctx = {\n\t\t.cvalue   = value,\n\t\t.kvalue   = NULL,\n\t\t.size     = size,\n\t\t.kname    = &kname,\n\t\t.flags    = flags,\n\t};\n\tint error;\n\n\terror = setxattr_copy(name, &ctx);\n\tif (error)\n\t\treturn error;\n\n\terror = do_setxattr(idmap, d, &ctx);\n\n\tkvfree(ctx.kvalue);\n\treturn error;\n}\n\nstatic int path_setxattr(const char __user *pathname,\n\t\t\t const char __user *name, const void __user *value,\n\t\t\t size_t size, int flags, unsigned int lookup_flags)\n{\n\tstruct path path;\n\tint error;\n\nretry:\n\terror = user_path_at(AT_FDCWD, pathname, lookup_flags, &path);\n\tif (error)\n\t\treturn error;\n\terror = mnt_want_write(path.mnt);\n\tif (!error) {\n\t\terror = setxattr(mnt_idmap(path.mnt), path.dentry, name,\n\t\t\t\t value, size, flags);\n\t\tmnt_drop_write(path.mnt);\n\t}\n\tpath_put(&path);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\n\treturn error;\n}\n\nSYSCALL_DEFINE5(setxattr, const char __user *, pathname,\n\t\tconst char __user *, name, const void __user *, value,\n\t\tsize_t, size, int, flags)\n{\n\treturn path_setxattr(pathname, name, value, size, flags, LOOKUP_FOLLOW);\n}\n\nSYSCALL_DEFINE5(lsetxattr, const char __user *, pathname,\n\t\tconst char __user *, name, const void __user *, value,\n\t\tsize_t, size, int, flags)\n{\n\treturn path_setxattr(pathname, name, value, size, flags, 0);\n}\n\nSYSCALL_DEFINE5(fsetxattr, int, fd, const char __user *, name,\n\t\tconst void __user *,value, size_t, size, int, flags)\n{\n\tstruct fd f = fdget(fd);\n\tint error = -EBADF;\n\n\tif (!f.file)\n\t\treturn error;\n\taudit_file(f.file);\n\terror = mnt_want_write_file(f.file);\n\tif (!error) {\n\t\terror = setxattr(file_mnt_idmap(f.file),\n\t\t\t\t f.file->f_path.dentry, name,\n\t\t\t\t value, size, flags);\n\t\tmnt_drop_write_file(f.file);\n\t}\n\tfdput(f);\n\treturn error;\n}\n\n \nssize_t\ndo_getxattr(struct mnt_idmap *idmap, struct dentry *d,\n\tstruct xattr_ctx *ctx)\n{\n\tssize_t error;\n\tchar *kname = ctx->kname->name;\n\n\tif (ctx->size) {\n\t\tif (ctx->size > XATTR_SIZE_MAX)\n\t\t\tctx->size = XATTR_SIZE_MAX;\n\t\tctx->kvalue = kvzalloc(ctx->size, GFP_KERNEL);\n\t\tif (!ctx->kvalue)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (is_posix_acl_xattr(ctx->kname->name))\n\t\terror = do_get_acl(idmap, d, kname, ctx->kvalue, ctx->size);\n\telse\n\t\terror = vfs_getxattr(idmap, d, kname, ctx->kvalue, ctx->size);\n\tif (error > 0) {\n\t\tif (ctx->size && copy_to_user(ctx->value, ctx->kvalue, error))\n\t\t\terror = -EFAULT;\n\t} else if (error == -ERANGE && ctx->size >= XATTR_SIZE_MAX) {\n\t\t \n\t\terror = -E2BIG;\n\t}\n\n\treturn error;\n}\n\nstatic ssize_t\ngetxattr(struct mnt_idmap *idmap, struct dentry *d,\n\t const char __user *name, void __user *value, size_t size)\n{\n\tssize_t error;\n\tstruct xattr_name kname;\n\tstruct xattr_ctx ctx = {\n\t\t.value    = value,\n\t\t.kvalue   = NULL,\n\t\t.size     = size,\n\t\t.kname    = &kname,\n\t\t.flags    = 0,\n\t};\n\n\terror = strncpy_from_user(kname.name, name, sizeof(kname.name));\n\tif (error == 0 || error == sizeof(kname.name))\n\t\terror = -ERANGE;\n\tif (error < 0)\n\t\treturn error;\n\n\terror =  do_getxattr(idmap, d, &ctx);\n\n\tkvfree(ctx.kvalue);\n\treturn error;\n}\n\nstatic ssize_t path_getxattr(const char __user *pathname,\n\t\t\t     const char __user *name, void __user *value,\n\t\t\t     size_t size, unsigned int lookup_flags)\n{\n\tstruct path path;\n\tssize_t error;\nretry:\n\terror = user_path_at(AT_FDCWD, pathname, lookup_flags, &path);\n\tif (error)\n\t\treturn error;\n\terror = getxattr(mnt_idmap(path.mnt), path.dentry, name, value, size);\n\tpath_put(&path);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\n\treturn error;\n}\n\nSYSCALL_DEFINE4(getxattr, const char __user *, pathname,\n\t\tconst char __user *, name, void __user *, value, size_t, size)\n{\n\treturn path_getxattr(pathname, name, value, size, LOOKUP_FOLLOW);\n}\n\nSYSCALL_DEFINE4(lgetxattr, const char __user *, pathname,\n\t\tconst char __user *, name, void __user *, value, size_t, size)\n{\n\treturn path_getxattr(pathname, name, value, size, 0);\n}\n\nSYSCALL_DEFINE4(fgetxattr, int, fd, const char __user *, name,\n\t\tvoid __user *, value, size_t, size)\n{\n\tstruct fd f = fdget(fd);\n\tssize_t error = -EBADF;\n\n\tif (!f.file)\n\t\treturn error;\n\taudit_file(f.file);\n\terror = getxattr(file_mnt_idmap(f.file), f.file->f_path.dentry,\n\t\t\t name, value, size);\n\tfdput(f);\n\treturn error;\n}\n\n \nstatic ssize_t\nlistxattr(struct dentry *d, char __user *list, size_t size)\n{\n\tssize_t error;\n\tchar *klist = NULL;\n\n\tif (size) {\n\t\tif (size > XATTR_LIST_MAX)\n\t\t\tsize = XATTR_LIST_MAX;\n\t\tklist = kvmalloc(size, GFP_KERNEL);\n\t\tif (!klist)\n\t\t\treturn -ENOMEM;\n\t}\n\n\terror = vfs_listxattr(d, klist, size);\n\tif (error > 0) {\n\t\tif (size && copy_to_user(list, klist, error))\n\t\t\terror = -EFAULT;\n\t} else if (error == -ERANGE && size >= XATTR_LIST_MAX) {\n\t\t \n\t\terror = -E2BIG;\n\t}\n\n\tkvfree(klist);\n\n\treturn error;\n}\n\nstatic ssize_t path_listxattr(const char __user *pathname, char __user *list,\n\t\t\t      size_t size, unsigned int lookup_flags)\n{\n\tstruct path path;\n\tssize_t error;\nretry:\n\terror = user_path_at(AT_FDCWD, pathname, lookup_flags, &path);\n\tif (error)\n\t\treturn error;\n\terror = listxattr(path.dentry, list, size);\n\tpath_put(&path);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\n\treturn error;\n}\n\nSYSCALL_DEFINE3(listxattr, const char __user *, pathname, char __user *, list,\n\t\tsize_t, size)\n{\n\treturn path_listxattr(pathname, list, size, LOOKUP_FOLLOW);\n}\n\nSYSCALL_DEFINE3(llistxattr, const char __user *, pathname, char __user *, list,\n\t\tsize_t, size)\n{\n\treturn path_listxattr(pathname, list, size, 0);\n}\n\nSYSCALL_DEFINE3(flistxattr, int, fd, char __user *, list, size_t, size)\n{\n\tstruct fd f = fdget(fd);\n\tssize_t error = -EBADF;\n\n\tif (!f.file)\n\t\treturn error;\n\taudit_file(f.file);\n\terror = listxattr(f.file->f_path.dentry, list, size);\n\tfdput(f);\n\treturn error;\n}\n\n \nstatic long\nremovexattr(struct mnt_idmap *idmap, struct dentry *d,\n\t    const char __user *name)\n{\n\tint error;\n\tchar kname[XATTR_NAME_MAX + 1];\n\n\terror = strncpy_from_user(kname, name, sizeof(kname));\n\tif (error == 0 || error == sizeof(kname))\n\t\terror = -ERANGE;\n\tif (error < 0)\n\t\treturn error;\n\n\tif (is_posix_acl_xattr(kname))\n\t\treturn vfs_remove_acl(idmap, d, kname);\n\n\treturn vfs_removexattr(idmap, d, kname);\n}\n\nstatic int path_removexattr(const char __user *pathname,\n\t\t\t    const char __user *name, unsigned int lookup_flags)\n{\n\tstruct path path;\n\tint error;\nretry:\n\terror = user_path_at(AT_FDCWD, pathname, lookup_flags, &path);\n\tif (error)\n\t\treturn error;\n\terror = mnt_want_write(path.mnt);\n\tif (!error) {\n\t\terror = removexattr(mnt_idmap(path.mnt), path.dentry, name);\n\t\tmnt_drop_write(path.mnt);\n\t}\n\tpath_put(&path);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\n\treturn error;\n}\n\nSYSCALL_DEFINE2(removexattr, const char __user *, pathname,\n\t\tconst char __user *, name)\n{\n\treturn path_removexattr(pathname, name, LOOKUP_FOLLOW);\n}\n\nSYSCALL_DEFINE2(lremovexattr, const char __user *, pathname,\n\t\tconst char __user *, name)\n{\n\treturn path_removexattr(pathname, name, 0);\n}\n\nSYSCALL_DEFINE2(fremovexattr, int, fd, const char __user *, name)\n{\n\tstruct fd f = fdget(fd);\n\tint error = -EBADF;\n\n\tif (!f.file)\n\t\treturn error;\n\taudit_file(f.file);\n\terror = mnt_want_write_file(f.file);\n\tif (!error) {\n\t\terror = removexattr(file_mnt_idmap(f.file),\n\t\t\t\t    f.file->f_path.dentry, name);\n\t\tmnt_drop_write_file(f.file);\n\t}\n\tfdput(f);\n\treturn error;\n}\n\nint xattr_list_one(char **buffer, ssize_t *remaining_size, const char *name)\n{\n\tsize_t len;\n\n\tlen = strlen(name) + 1;\n\tif (*buffer) {\n\t\tif (*remaining_size < len)\n\t\t\treturn -ERANGE;\n\t\tmemcpy(*buffer, name, len);\n\t\t*buffer += len;\n\t}\n\t*remaining_size -= len;\n\treturn 0;\n}\n\n \nssize_t\ngeneric_listxattr(struct dentry *dentry, char *buffer, size_t buffer_size)\n{\n\tconst struct xattr_handler *handler, **handlers = dentry->d_sb->s_xattr;\n\tssize_t remaining_size = buffer_size;\n\tint err = 0;\n\n\tfor_each_xattr_handler(handlers, handler) {\n\t\tif (!handler->name || (handler->list && !handler->list(dentry)))\n\t\t\tcontinue;\n\t\terr = xattr_list_one(&buffer, &remaining_size, handler->name);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn err ? err : buffer_size - remaining_size;\n}\nEXPORT_SYMBOL(generic_listxattr);\n\n \nconst char *xattr_full_name(const struct xattr_handler *handler,\n\t\t\t    const char *name)\n{\n\tsize_t prefix_len = strlen(xattr_prefix(handler));\n\n\treturn name - prefix_len;\n}\nEXPORT_SYMBOL(xattr_full_name);\n\n \nsize_t simple_xattr_space(const char *name, size_t size)\n{\n\t \n\treturn 40 + size + strlen(name);\n}\n\n \nvoid simple_xattr_free(struct simple_xattr *xattr)\n{\n\tif (xattr)\n\t\tkfree(xattr->name);\n\tkvfree(xattr);\n}\n\n \nstruct simple_xattr *simple_xattr_alloc(const void *value, size_t size)\n{\n\tstruct simple_xattr *new_xattr;\n\tsize_t len;\n\n\t \n\tlen = sizeof(*new_xattr) + size;\n\tif (len < sizeof(*new_xattr))\n\t\treturn NULL;\n\n\tnew_xattr = kvmalloc(len, GFP_KERNEL_ACCOUNT);\n\tif (!new_xattr)\n\t\treturn NULL;\n\n\tnew_xattr->size = size;\n\tmemcpy(new_xattr->value, value, size);\n\treturn new_xattr;\n}\n\n \nstatic int rbtree_simple_xattr_cmp(const void *key, const struct rb_node *node)\n{\n\tconst char *xattr_name = key;\n\tconst struct simple_xattr *xattr;\n\n\txattr = rb_entry(node, struct simple_xattr, rb_node);\n\treturn strcmp(xattr->name, xattr_name);\n}\n\n \nstatic int rbtree_simple_xattr_node_cmp(struct rb_node *new_node,\n\t\t\t\t\tconst struct rb_node *node)\n{\n\tstruct simple_xattr *xattr;\n\txattr = rb_entry(new_node, struct simple_xattr, rb_node);\n\treturn rbtree_simple_xattr_cmp(xattr->name, node);\n}\n\n \nint simple_xattr_get(struct simple_xattrs *xattrs, const char *name,\n\t\t     void *buffer, size_t size)\n{\n\tstruct simple_xattr *xattr = NULL;\n\tstruct rb_node *rbp;\n\tint ret = -ENODATA;\n\n\tread_lock(&xattrs->lock);\n\trbp = rb_find(name, &xattrs->rb_root, rbtree_simple_xattr_cmp);\n\tif (rbp) {\n\t\txattr = rb_entry(rbp, struct simple_xattr, rb_node);\n\t\tret = xattr->size;\n\t\tif (buffer) {\n\t\t\tif (size < xattr->size)\n\t\t\t\tret = -ERANGE;\n\t\t\telse\n\t\t\t\tmemcpy(buffer, xattr->value, xattr->size);\n\t\t}\n\t}\n\tread_unlock(&xattrs->lock);\n\treturn ret;\n}\n\n \nstruct simple_xattr *simple_xattr_set(struct simple_xattrs *xattrs,\n\t\t\t\t      const char *name, const void *value,\n\t\t\t\t      size_t size, int flags)\n{\n\tstruct simple_xattr *old_xattr = NULL, *new_xattr = NULL;\n\tstruct rb_node *parent = NULL, **rbp;\n\tint err = 0, ret;\n\n\t \n\tif (value) {\n\t\tnew_xattr = simple_xattr_alloc(value, size);\n\t\tif (!new_xattr)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t\tnew_xattr->name = kstrdup(name, GFP_KERNEL_ACCOUNT);\n\t\tif (!new_xattr->name) {\n\t\t\tsimple_xattr_free(new_xattr);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t}\n\n\twrite_lock(&xattrs->lock);\n\trbp = &xattrs->rb_root.rb_node;\n\twhile (*rbp) {\n\t\tparent = *rbp;\n\t\tret = rbtree_simple_xattr_cmp(name, *rbp);\n\t\tif (ret < 0)\n\t\t\trbp = &(*rbp)->rb_left;\n\t\telse if (ret > 0)\n\t\t\trbp = &(*rbp)->rb_right;\n\t\telse\n\t\t\told_xattr = rb_entry(*rbp, struct simple_xattr, rb_node);\n\t\tif (old_xattr)\n\t\t\tbreak;\n\t}\n\n\tif (old_xattr) {\n\t\t \n\t\tif (flags & XATTR_CREATE) {\n\t\t\terr = -EEXIST;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tif (new_xattr)\n\t\t\trb_replace_node(&old_xattr->rb_node,\n\t\t\t\t\t&new_xattr->rb_node, &xattrs->rb_root);\n\t\telse\n\t\t\trb_erase(&old_xattr->rb_node, &xattrs->rb_root);\n\t} else {\n\t\t \n\t\tif (flags & XATTR_REPLACE) {\n\t\t\terr = -ENODATA;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t \n\t\tif (new_xattr) {\n\t\t\trb_link_node(&new_xattr->rb_node, parent, rbp);\n\t\t\trb_insert_color(&new_xattr->rb_node, &xattrs->rb_root);\n\t\t}\n\n\t\t \n\t}\n\nout_unlock:\n\twrite_unlock(&xattrs->lock);\n\tif (!err)\n\t\treturn old_xattr;\n\tsimple_xattr_free(new_xattr);\n\treturn ERR_PTR(err);\n}\n\nstatic bool xattr_is_trusted(const char *name)\n{\n\treturn !strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN);\n}\n\n \nssize_t simple_xattr_list(struct inode *inode, struct simple_xattrs *xattrs,\n\t\t\t  char *buffer, size_t size)\n{\n\tbool trusted = ns_capable_noaudit(&init_user_ns, CAP_SYS_ADMIN);\n\tstruct simple_xattr *xattr;\n\tstruct rb_node *rbp;\n\tssize_t remaining_size = size;\n\tint err = 0;\n\n\terr = posix_acl_listxattr(inode, &buffer, &remaining_size);\n\tif (err)\n\t\treturn err;\n\n\tread_lock(&xattrs->lock);\n\tfor (rbp = rb_first(&xattrs->rb_root); rbp; rbp = rb_next(rbp)) {\n\t\txattr = rb_entry(rbp, struct simple_xattr, rb_node);\n\n\t\t \n\t\tif (!trusted && xattr_is_trusted(xattr->name))\n\t\t\tcontinue;\n\n\t\terr = xattr_list_one(&buffer, &remaining_size, xattr->name);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\tread_unlock(&xattrs->lock);\n\n\treturn err ? err : size - remaining_size;\n}\n\n \nstatic bool rbtree_simple_xattr_less(struct rb_node *new_node,\n\t\t\t\t     const struct rb_node *node)\n{\n\treturn rbtree_simple_xattr_node_cmp(new_node, node) < 0;\n}\n\n \nvoid simple_xattr_add(struct simple_xattrs *xattrs,\n\t\t      struct simple_xattr *new_xattr)\n{\n\twrite_lock(&xattrs->lock);\n\trb_add(&new_xattr->rb_node, &xattrs->rb_root, rbtree_simple_xattr_less);\n\twrite_unlock(&xattrs->lock);\n}\n\n \nvoid simple_xattrs_init(struct simple_xattrs *xattrs)\n{\n\txattrs->rb_root = RB_ROOT;\n\trwlock_init(&xattrs->lock);\n}\n\n \nvoid simple_xattrs_free(struct simple_xattrs *xattrs, size_t *freed_space)\n{\n\tstruct rb_node *rbp;\n\n\tif (freed_space)\n\t\t*freed_space = 0;\n\trbp = rb_first(&xattrs->rb_root);\n\twhile (rbp) {\n\t\tstruct simple_xattr *xattr;\n\t\tstruct rb_node *rbp_next;\n\n\t\trbp_next = rb_next(rbp);\n\t\txattr = rb_entry(rbp, struct simple_xattr, rb_node);\n\t\trb_erase(&xattr->rb_node, &xattrs->rb_root);\n\t\tif (freed_space)\n\t\t\t*freed_space += simple_xattr_space(xattr->name,\n\t\t\t\t\t\t\t   xattr->size);\n\t\tsimple_xattr_free(xattr);\n\t\trbp = rbp_next;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}