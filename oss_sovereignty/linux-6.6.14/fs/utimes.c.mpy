{
  "module_name": "utimes.c",
  "hash_id": "6347e752058ee977e85bf18ce573b12a391d4d651a346aa900ba33534fa113ad",
  "original_prompt": "Ingested from linux-6.6.14/fs/utimes.c",
  "human_readable_source": "\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/utime.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <asm/unistd.h>\n#include <linux/filelock.h>\n\nstatic bool nsec_valid(long nsec)\n{\n\tif (nsec == UTIME_OMIT || nsec == UTIME_NOW)\n\t\treturn true;\n\n\treturn nsec >= 0 && nsec <= 999999999;\n}\n\nint vfs_utimes(const struct path *path, struct timespec64 *times)\n{\n\tint error;\n\tstruct iattr newattrs;\n\tstruct inode *inode = path->dentry->d_inode;\n\tstruct inode *delegated_inode = NULL;\n\n\tif (times) {\n\t\tif (!nsec_valid(times[0].tv_nsec) ||\n\t\t    !nsec_valid(times[1].tv_nsec))\n\t\t\treturn -EINVAL;\n\t\tif (times[0].tv_nsec == UTIME_NOW &&\n\t\t    times[1].tv_nsec == UTIME_NOW)\n\t\t\ttimes = NULL;\n\t}\n\n\terror = mnt_want_write(path->mnt);\n\tif (error)\n\t\tgoto out;\n\n\tnewattrs.ia_valid = ATTR_CTIME | ATTR_MTIME | ATTR_ATIME;\n\tif (times) {\n\t\tif (times[0].tv_nsec == UTIME_OMIT)\n\t\t\tnewattrs.ia_valid &= ~ATTR_ATIME;\n\t\telse if (times[0].tv_nsec != UTIME_NOW) {\n\t\t\tnewattrs.ia_atime = times[0];\n\t\t\tnewattrs.ia_valid |= ATTR_ATIME_SET;\n\t\t}\n\n\t\tif (times[1].tv_nsec == UTIME_OMIT)\n\t\t\tnewattrs.ia_valid &= ~ATTR_MTIME;\n\t\telse if (times[1].tv_nsec != UTIME_NOW) {\n\t\t\tnewattrs.ia_mtime = times[1];\n\t\t\tnewattrs.ia_valid |= ATTR_MTIME_SET;\n\t\t}\n\t\t \n\t\tnewattrs.ia_valid |= ATTR_TIMES_SET;\n\t} else {\n\t\tnewattrs.ia_valid |= ATTR_TOUCH;\n\t}\nretry_deleg:\n\tinode_lock(inode);\n\terror = notify_change(mnt_idmap(path->mnt), path->dentry, &newattrs,\n\t\t\t      &delegated_inode);\n\tinode_unlock(inode);\n\tif (delegated_inode) {\n\t\terror = break_deleg_wait(&delegated_inode);\n\t\tif (!error)\n\t\t\tgoto retry_deleg;\n\t}\n\n\tmnt_drop_write(path->mnt);\nout:\n\treturn error;\n}\n\nstatic int do_utimes_path(int dfd, const char __user *filename,\n\t\tstruct timespec64 *times, int flags)\n{\n\tstruct path path;\n\tint lookup_flags = 0, error;\n\n\tif (flags & ~(AT_SYMLINK_NOFOLLOW | AT_EMPTY_PATH))\n\t\treturn -EINVAL;\n\n\tif (!(flags & AT_SYMLINK_NOFOLLOW))\n\t\tlookup_flags |= LOOKUP_FOLLOW;\n\tif (flags & AT_EMPTY_PATH)\n\t\tlookup_flags |= LOOKUP_EMPTY;\n\nretry:\n\terror = user_path_at(dfd, filename, lookup_flags, &path);\n\tif (error)\n\t\treturn error;\n\n\terror = vfs_utimes(&path, times);\n\tpath_put(&path);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\n\n\treturn error;\n}\n\nstatic int do_utimes_fd(int fd, struct timespec64 *times, int flags)\n{\n\tstruct fd f;\n\tint error;\n\n\tif (flags)\n\t\treturn -EINVAL;\n\n\tf = fdget(fd);\n\tif (!f.file)\n\t\treturn -EBADF;\n\terror = vfs_utimes(&f.file->f_path, times);\n\tfdput(f);\n\treturn error;\n}\n\n \nlong do_utimes(int dfd, const char __user *filename, struct timespec64 *times,\n\t       int flags)\n{\n\tif (filename == NULL && dfd != AT_FDCWD)\n\t\treturn do_utimes_fd(dfd, times, flags);\n\treturn do_utimes_path(dfd, filename, times, flags);\n}\n\nSYSCALL_DEFINE4(utimensat, int, dfd, const char __user *, filename,\n\t\tstruct __kernel_timespec __user *, utimes, int, flags)\n{\n\tstruct timespec64 tstimes[2];\n\n\tif (utimes) {\n\t\tif ((get_timespec64(&tstimes[0], &utimes[0]) ||\n\t\t\tget_timespec64(&tstimes[1], &utimes[1])))\n\t\t\treturn -EFAULT;\n\n\t\t \n\t\tif (tstimes[0].tv_nsec == UTIME_OMIT &&\n\t\t    tstimes[1].tv_nsec == UTIME_OMIT)\n\t\t\treturn 0;\n\t}\n\n\treturn do_utimes(dfd, filename, utimes ? tstimes : NULL, flags);\n}\n\n#ifdef __ARCH_WANT_SYS_UTIME\n \nstatic long do_futimesat(int dfd, const char __user *filename,\n\t\t\t struct __kernel_old_timeval __user *utimes)\n{\n\tstruct __kernel_old_timeval times[2];\n\tstruct timespec64 tstimes[2];\n\n\tif (utimes) {\n\t\tif (copy_from_user(&times, utimes, sizeof(times)))\n\t\t\treturn -EFAULT;\n\n\t\t \n\t\tif (times[0].tv_usec >= 1000000 || times[0].tv_usec < 0 ||\n\t\t    times[1].tv_usec >= 1000000 || times[1].tv_usec < 0)\n\t\t\treturn -EINVAL;\n\n\t\ttstimes[0].tv_sec = times[0].tv_sec;\n\t\ttstimes[0].tv_nsec = 1000 * times[0].tv_usec;\n\t\ttstimes[1].tv_sec = times[1].tv_sec;\n\t\ttstimes[1].tv_nsec = 1000 * times[1].tv_usec;\n\t}\n\n\treturn do_utimes(dfd, filename, utimes ? tstimes : NULL, 0);\n}\n\n\nSYSCALL_DEFINE3(futimesat, int, dfd, const char __user *, filename,\n\t\tstruct __kernel_old_timeval __user *, utimes)\n{\n\treturn do_futimesat(dfd, filename, utimes);\n}\n\nSYSCALL_DEFINE2(utimes, char __user *, filename,\n\t\tstruct __kernel_old_timeval __user *, utimes)\n{\n\treturn do_futimesat(AT_FDCWD, filename, utimes);\n}\n\nSYSCALL_DEFINE2(utime, char __user *, filename, struct utimbuf __user *, times)\n{\n\tstruct timespec64 tv[2];\n\n\tif (times) {\n\t\tif (get_user(tv[0].tv_sec, &times->actime) ||\n\t\t    get_user(tv[1].tv_sec, &times->modtime))\n\t\t\treturn -EFAULT;\n\t\ttv[0].tv_nsec = 0;\n\t\ttv[1].tv_nsec = 0;\n\t}\n\treturn do_utimes(AT_FDCWD, filename, times ? tv : NULL, 0);\n}\n#endif\n\n#ifdef CONFIG_COMPAT_32BIT_TIME\n \n#ifdef __ARCH_WANT_SYS_UTIME32\nSYSCALL_DEFINE2(utime32, const char __user *, filename,\n\t\tstruct old_utimbuf32 __user *, t)\n{\n\tstruct timespec64 tv[2];\n\n\tif (t) {\n\t\tif (get_user(tv[0].tv_sec, &t->actime) ||\n\t\t    get_user(tv[1].tv_sec, &t->modtime))\n\t\t\treturn -EFAULT;\n\t\ttv[0].tv_nsec = 0;\n\t\ttv[1].tv_nsec = 0;\n\t}\n\treturn do_utimes(AT_FDCWD, filename, t ? tv : NULL, 0);\n}\n#endif\n\nSYSCALL_DEFINE4(utimensat_time32, unsigned int, dfd, const char __user *, filename, struct old_timespec32 __user *, t, int, flags)\n{\n\tstruct timespec64 tv[2];\n\n\tif  (t) {\n\t\tif (get_old_timespec32(&tv[0], &t[0]) ||\n\t\t    get_old_timespec32(&tv[1], &t[1]))\n\t\t\treturn -EFAULT;\n\n\t\tif (tv[0].tv_nsec == UTIME_OMIT && tv[1].tv_nsec == UTIME_OMIT)\n\t\t\treturn 0;\n\t}\n\treturn do_utimes(dfd, filename, t ? tv : NULL, flags);\n}\n\n#ifdef __ARCH_WANT_SYS_UTIME32\nstatic long do_compat_futimesat(unsigned int dfd, const char __user *filename,\n\t\t\t\tstruct old_timeval32 __user *t)\n{\n\tstruct timespec64 tv[2];\n\n\tif (t) {\n\t\tif (get_user(tv[0].tv_sec, &t[0].tv_sec) ||\n\t\t    get_user(tv[0].tv_nsec, &t[0].tv_usec) ||\n\t\t    get_user(tv[1].tv_sec, &t[1].tv_sec) ||\n\t\t    get_user(tv[1].tv_nsec, &t[1].tv_usec))\n\t\t\treturn -EFAULT;\n\t\tif (tv[0].tv_nsec >= 1000000 || tv[0].tv_nsec < 0 ||\n\t\t    tv[1].tv_nsec >= 1000000 || tv[1].tv_nsec < 0)\n\t\t\treturn -EINVAL;\n\t\ttv[0].tv_nsec *= 1000;\n\t\ttv[1].tv_nsec *= 1000;\n\t}\n\treturn do_utimes(dfd, filename, t ? tv : NULL, 0);\n}\n\nSYSCALL_DEFINE3(futimesat_time32, unsigned int, dfd,\n\t\t       const char __user *, filename,\n\t\t       struct old_timeval32 __user *, t)\n{\n\treturn do_compat_futimesat(dfd, filename, t);\n}\n\nSYSCALL_DEFINE2(utimes_time32, const char __user *, filename, struct old_timeval32 __user *, t)\n{\n\treturn do_compat_futimesat(AT_FDCWD, filename, t);\n}\n#endif\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}