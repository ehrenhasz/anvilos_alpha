{
  "module_name": "pnode.c",
  "hash_id": "94ebd4959ab8d91e02a48bf3e8f4f13dbe85be795e6d965c2b132897d05b2703",
  "original_prompt": "Ingested from linux-6.6.14/fs/pnode.c",
  "human_readable_source": "\n \n#include <linux/mnt_namespace.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/nsproxy.h>\n#include <uapi/linux/mount.h>\n#include \"internal.h\"\n#include \"pnode.h\"\n\n \nstatic inline struct mount *next_peer(struct mount *p)\n{\n\treturn list_entry(p->mnt_share.next, struct mount, mnt_share);\n}\n\nstatic inline struct mount *first_slave(struct mount *p)\n{\n\treturn list_entry(p->mnt_slave_list.next, struct mount, mnt_slave);\n}\n\nstatic inline struct mount *last_slave(struct mount *p)\n{\n\treturn list_entry(p->mnt_slave_list.prev, struct mount, mnt_slave);\n}\n\nstatic inline struct mount *next_slave(struct mount *p)\n{\n\treturn list_entry(p->mnt_slave.next, struct mount, mnt_slave);\n}\n\nstatic struct mount *get_peer_under_root(struct mount *mnt,\n\t\t\t\t\t struct mnt_namespace *ns,\n\t\t\t\t\t const struct path *root)\n{\n\tstruct mount *m = mnt;\n\n\tdo {\n\t\t \n\t\tif (m->mnt_ns == ns && is_path_reachable(m, m->mnt.mnt_root, root))\n\t\t\treturn m;\n\n\t\tm = next_peer(m);\n\t} while (m != mnt);\n\n\treturn NULL;\n}\n\n \nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}\n\nstatic int do_make_slave(struct mount *mnt)\n{\n\tstruct mount *master, *slave_mnt;\n\n\tif (list_empty(&mnt->mnt_share)) {\n\t\tif (IS_MNT_SHARED(mnt)) {\n\t\t\tmnt_release_group_id(mnt);\n\t\t\tCLEAR_MNT_SHARED(mnt);\n\t\t}\n\t\tmaster = mnt->mnt_master;\n\t\tif (!master) {\n\t\t\tstruct list_head *p = &mnt->mnt_slave_list;\n\t\t\twhile (!list_empty(p)) {\n\t\t\t\tslave_mnt = list_first_entry(p,\n\t\t\t\t\t\tstruct mount, mnt_slave);\n\t\t\t\tlist_del_init(&slave_mnt->mnt_slave);\n\t\t\t\tslave_mnt->mnt_master = NULL;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tstruct mount *m;\n\t\t \n\t\tfor (m = master = next_peer(mnt); m != mnt; m = next_peer(m)) {\n\t\t\tif (m->mnt.mnt_root == mnt->mnt.mnt_root) {\n\t\t\t\tmaster = m;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tlist_del_init(&mnt->mnt_share);\n\t\tmnt->mnt_group_id = 0;\n\t\tCLEAR_MNT_SHARED(mnt);\n\t}\n\tlist_for_each_entry(slave_mnt, &mnt->mnt_slave_list, mnt_slave)\n\t\tslave_mnt->mnt_master = master;\n\tlist_move(&mnt->mnt_slave, &master->mnt_slave_list);\n\tlist_splice(&mnt->mnt_slave_list, master->mnt_slave_list.prev);\n\tINIT_LIST_HEAD(&mnt->mnt_slave_list);\n\tmnt->mnt_master = master;\n\treturn 0;\n}\n\n \nvoid change_mnt_propagation(struct mount *mnt, int type)\n{\n\tif (type == MS_SHARED) {\n\t\tset_mnt_shared(mnt);\n\t\treturn;\n\t}\n\tdo_make_slave(mnt);\n\tif (type != MS_SLAVE) {\n\t\tlist_del_init(&mnt->mnt_slave);\n\t\tmnt->mnt_master = NULL;\n\t\tif (type == MS_UNBINDABLE)\n\t\t\tmnt->mnt.mnt_flags |= MNT_UNBINDABLE;\n\t\telse\n\t\t\tmnt->mnt.mnt_flags &= ~MNT_UNBINDABLE;\n\t}\n}\n\n \nstatic struct mount *propagation_next(struct mount *m,\n\t\t\t\t\t struct mount *origin)\n{\n\t \n\tif (!IS_MNT_NEW(m) && !list_empty(&m->mnt_slave_list))\n\t\treturn first_slave(m);\n\n\twhile (1) {\n\t\tstruct mount *master = m->mnt_master;\n\n\t\tif (master == origin->mnt_master) {\n\t\t\tstruct mount *next = next_peer(m);\n\t\t\treturn (next == origin) ? NULL : next;\n\t\t} else if (m->mnt_slave.next != &master->mnt_slave_list)\n\t\t\treturn next_slave(m);\n\n\t\t \n\t\tm = master;\n\t}\n}\n\nstatic struct mount *skip_propagation_subtree(struct mount *m,\n\t\t\t\t\t\tstruct mount *origin)\n{\n\t \n\tif (!IS_MNT_NEW(m) && !list_empty(&m->mnt_slave_list))\n\t\tm = last_slave(m);\n\n\treturn m;\n}\n\nstatic struct mount *next_group(struct mount *m, struct mount *origin)\n{\n\twhile (1) {\n\t\twhile (1) {\n\t\t\tstruct mount *next;\n\t\t\tif (!IS_MNT_NEW(m) && !list_empty(&m->mnt_slave_list))\n\t\t\t\treturn first_slave(m);\n\t\t\tnext = next_peer(m);\n\t\t\tif (m->mnt_group_id == origin->mnt_group_id) {\n\t\t\t\tif (next == origin)\n\t\t\t\t\treturn NULL;\n\t\t\t} else if (m->mnt_slave.next != &next->mnt_slave)\n\t\t\t\tbreak;\n\t\t\tm = next;\n\t\t}\n\t\t \n\t\twhile (1) {\n\t\t\tstruct mount *master = m->mnt_master;\n\t\t\tif (m->mnt_slave.next != &master->mnt_slave_list)\n\t\t\t\treturn next_slave(m);\n\t\t\tm = next_peer(master);\n\t\t\tif (master->mnt_group_id == origin->mnt_group_id)\n\t\t\t\tbreak;\n\t\t\tif (master->mnt_slave.next == &m->mnt_slave)\n\t\t\t\tbreak;\n\t\t\tm = master;\n\t\t}\n\t\tif (m == origin)\n\t\t\treturn NULL;\n\t}\n}\n\n \nstatic struct mount *last_dest, *first_source, *last_source, *dest_master;\nstatic struct hlist_head *list;\n\nstatic inline bool peers(const struct mount *m1, const struct mount *m2)\n{\n\treturn m1->mnt_group_id == m2->mnt_group_id && m1->mnt_group_id;\n}\n\nstatic int propagate_one(struct mount *m, struct mountpoint *dest_mp)\n{\n\tstruct mount *child;\n\tint type;\n\t \n\tif (IS_MNT_NEW(m))\n\t\treturn 0;\n\t \n\tif (!is_subdir(dest_mp->m_dentry, m->mnt.mnt_root))\n\t\treturn 0;\n\tif (peers(m, last_dest)) {\n\t\ttype = CL_MAKE_SHARED;\n\t} else {\n\t\tstruct mount *n, *p;\n\t\tbool done;\n\t\tfor (n = m; ; n = p) {\n\t\t\tp = n->mnt_master;\n\t\t\tif (p == dest_master || IS_MNT_MARKED(p))\n\t\t\t\tbreak;\n\t\t}\n\t\tdo {\n\t\t\tstruct mount *parent = last_source->mnt_parent;\n\t\t\tif (peers(last_source, first_source))\n\t\t\t\tbreak;\n\t\t\tdone = parent->mnt_master == p;\n\t\t\tif (done && peers(n, parent))\n\t\t\t\tbreak;\n\t\t\tlast_source = last_source->mnt_master;\n\t\t} while (!done);\n\n\t\ttype = CL_SLAVE;\n\t\t \n\t\tif (IS_MNT_SHARED(m))\n\t\t\ttype |= CL_MAKE_SHARED;\n\t}\n\t\t\n\tchild = copy_tree(last_source, last_source->mnt.mnt_root, type);\n\tif (IS_ERR(child))\n\t\treturn PTR_ERR(child);\n\tread_seqlock_excl(&mount_lock);\n\tmnt_set_mountpoint(m, dest_mp, child);\n\tif (m->mnt_master != dest_master)\n\t\tSET_MNT_MARK(m->mnt_master);\n\tread_sequnlock_excl(&mount_lock);\n\tlast_dest = m;\n\tlast_source = child;\n\thlist_add_head(&child->mnt_hash, list);\n\treturn count_mounts(m->mnt_ns, child);\n}\n\n \nint propagate_mnt(struct mount *dest_mnt, struct mountpoint *dest_mp,\n\t\t    struct mount *source_mnt, struct hlist_head *tree_list)\n{\n\tstruct mount *m, *n;\n\tint ret = 0;\n\n\t \n\tlast_dest = dest_mnt;\n\tfirst_source = source_mnt;\n\tlast_source = source_mnt;\n\tlist = tree_list;\n\tdest_master = dest_mnt->mnt_master;\n\n\t \n\tfor (n = next_peer(dest_mnt); n != dest_mnt; n = next_peer(n)) {\n\t\tret = propagate_one(n, dest_mp);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\t \n\tfor (m = next_group(dest_mnt, dest_mnt); m;\n\t\t\tm = next_group(m, dest_mnt)) {\n\t\t \n\t\tn = m;\n\t\tdo {\n\t\t\tret = propagate_one(n, dest_mp);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tn = next_peer(n);\n\t\t} while (n != m);\n\t}\nout:\n\tread_seqlock_excl(&mount_lock);\n\thlist_for_each_entry(n, tree_list, mnt_hash) {\n\t\tm = n->mnt_parent;\n\t\tif (m->mnt_master != dest_mnt->mnt_master)\n\t\t\tCLEAR_MNT_MARK(m->mnt_master);\n\t}\n\tread_sequnlock_excl(&mount_lock);\n\treturn ret;\n}\n\nstatic struct mount *find_topper(struct mount *mnt)\n{\n\t \n\tstruct mount *child;\n\n\tif (!list_is_singular(&mnt->mnt_mounts))\n\t\treturn NULL;\n\n\tchild = list_first_entry(&mnt->mnt_mounts, struct mount, mnt_child);\n\tif (child->mnt_mountpoint != mnt->mnt.mnt_root)\n\t\treturn NULL;\n\n\treturn child;\n}\n\n \nstatic inline int do_refcount_check(struct mount *mnt, int count)\n{\n\treturn mnt_get_count(mnt) > count;\n}\n\n \nbool propagation_would_overmount(const struct mount *from,\n\t\t\t\t const struct mount *to,\n\t\t\t\t const struct mountpoint *mp)\n{\n\tif (!IS_MNT_SHARED(from))\n\t\treturn false;\n\n\tif (IS_MNT_NEW(to))\n\t\treturn false;\n\n\tif (to->mnt.mnt_root != mp->m_dentry)\n\t\treturn false;\n\n\tfor (const struct mount *m = to; m; m = m->mnt_master) {\n\t\tif (peers(from, m))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nint propagate_mount_busy(struct mount *mnt, int refcnt)\n{\n\tstruct mount *m, *child, *topper;\n\tstruct mount *parent = mnt->mnt_parent;\n\n\tif (mnt == parent)\n\t\treturn do_refcount_check(mnt, refcnt);\n\n\t \n\tif (!list_empty(&mnt->mnt_mounts) || do_refcount_check(mnt, refcnt))\n\t\treturn 1;\n\n\tfor (m = propagation_next(parent, parent); m;\n\t     \t\tm = propagation_next(m, parent)) {\n\t\tint count = 1;\n\t\tchild = __lookup_mnt(&m->mnt, mnt->mnt_mountpoint);\n\t\tif (!child)\n\t\t\tcontinue;\n\n\t\t \n\t\ttopper = find_topper(child);\n\t\tif (topper)\n\t\t\tcount += 1;\n\t\telse if (!list_empty(&child->mnt_mounts))\n\t\t\tcontinue;\n\n\t\tif (do_refcount_check(child, count))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \nvoid propagate_mount_unlock(struct mount *mnt)\n{\n\tstruct mount *parent = mnt->mnt_parent;\n\tstruct mount *m, *child;\n\n\tBUG_ON(parent == mnt);\n\n\tfor (m = propagation_next(parent, parent); m;\n\t\t\tm = propagation_next(m, parent)) {\n\t\tchild = __lookup_mnt(&m->mnt, mnt->mnt_mountpoint);\n\t\tif (child)\n\t\t\tchild->mnt.mnt_flags &= ~MNT_LOCKED;\n\t}\n}\n\nstatic void umount_one(struct mount *mnt, struct list_head *to_umount)\n{\n\tCLEAR_MNT_MARK(mnt);\n\tmnt->mnt.mnt_flags |= MNT_UMOUNT;\n\tlist_del_init(&mnt->mnt_child);\n\tlist_del_init(&mnt->mnt_umounting);\n\tlist_move_tail(&mnt->mnt_list, to_umount);\n}\n\n \nstatic bool __propagate_umount(struct mount *mnt,\n\t\t\t       struct list_head *to_umount,\n\t\t\t       struct list_head *to_restore)\n{\n\tbool progress = false;\n\tstruct mount *child;\n\n\t \n\tif (mnt->mnt.mnt_flags & (MNT_UMOUNT | MNT_MARKED))\n\t\tgoto out;\n\n\t \n\tlist_for_each_entry(child, &mnt->mnt_mounts, mnt_child) {\n\t\tif (child->mnt_mountpoint == mnt->mnt.mnt_root)\n\t\t\tcontinue;\n\t\tif (!list_empty(&child->mnt_umounting) && IS_MNT_MARKED(child))\n\t\t\tcontinue;\n\t\t \n\t\tgoto children;\n\t}\n\n\t \n\tSET_MNT_MARK(mnt);\n\tprogress = true;\n\n\t \n\tif (!IS_MNT_LOCKED(mnt)) {\n\t\tumount_one(mnt, to_umount);\n\t} else {\nchildren:\n\t\tlist_move_tail(&mnt->mnt_umounting, to_restore);\n\t}\nout:\n\treturn progress;\n}\n\nstatic void umount_list(struct list_head *to_umount,\n\t\t\tstruct list_head *to_restore)\n{\n\tstruct mount *mnt, *child, *tmp;\n\tlist_for_each_entry(mnt, to_umount, mnt_list) {\n\t\tlist_for_each_entry_safe(child, tmp, &mnt->mnt_mounts, mnt_child) {\n\t\t\t \n\t\t\tif (child->mnt_mountpoint == mnt->mnt.mnt_root)\n\t\t\t\tlist_move_tail(&child->mnt_umounting, to_restore);\n\t\t\telse\n\t\t\t\tumount_one(child, to_umount);\n\t\t}\n\t}\n}\n\nstatic void restore_mounts(struct list_head *to_restore)\n{\n\t \n\twhile (!list_empty(to_restore)) {\n\t\tstruct mount *mnt, *parent;\n\t\tstruct mountpoint *mp;\n\n\t\tmnt = list_first_entry(to_restore, struct mount, mnt_umounting);\n\t\tCLEAR_MNT_MARK(mnt);\n\t\tlist_del_init(&mnt->mnt_umounting);\n\n\t\t \n\t\tmp = mnt->mnt_mp;\n\t\tparent = mnt->mnt_parent;\n\t\twhile (parent->mnt.mnt_flags & MNT_UMOUNT) {\n\t\t\tmp = parent->mnt_mp;\n\t\t\tparent = parent->mnt_parent;\n\t\t}\n\t\tif (parent != mnt->mnt_parent)\n\t\t\tmnt_change_mountpoint(parent, mp, mnt);\n\t}\n}\n\nstatic void cleanup_umount_visitations(struct list_head *visited)\n{\n\twhile (!list_empty(visited)) {\n\t\tstruct mount *mnt =\n\t\t\tlist_first_entry(visited, struct mount, mnt_umounting);\n\t\tlist_del_init(&mnt->mnt_umounting);\n\t}\n}\n\n \nint propagate_umount(struct list_head *list)\n{\n\tstruct mount *mnt;\n\tLIST_HEAD(to_restore);\n\tLIST_HEAD(to_umount);\n\tLIST_HEAD(visited);\n\n\t \n\tlist_for_each_entry_reverse(mnt, list, mnt_list) {\n\t\tstruct mount *parent = mnt->mnt_parent;\n\t\tstruct mount *m;\n\n\t\t \n\t\tif (!list_empty(&mnt->mnt_umounting))\n\t\t\tcontinue;\n\n\t\tlist_add_tail(&mnt->mnt_umounting, &visited);\n\t\tfor (m = propagation_next(parent, parent); m;\n\t\t     m = propagation_next(m, parent)) {\n\t\t\tstruct mount *child = __lookup_mnt(&m->mnt,\n\t\t\t\t\t\t\t   mnt->mnt_mountpoint);\n\t\t\tif (!child)\n\t\t\t\tcontinue;\n\n\t\t\tif (!list_empty(&child->mnt_umounting)) {\n\t\t\t\t \n\t\t\t\tm = skip_propagation_subtree(m, parent);\n\t\t\t\tcontinue;\n\t\t\t} else if (child->mnt.mnt_flags & MNT_UMOUNT) {\n\t\t\t\t \n\t\t\t\tlist_add_tail(&child->mnt_umounting, &visited);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\twhile (__propagate_umount(child,\n\t\t\t\t\t\t  &to_umount, &to_restore)) {\n\t\t\t\t \n\t\t\t\tchild = child->mnt_parent;\n\t\t\t\tif (list_empty(&child->mnt_umounting))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tumount_list(&to_umount, &to_restore);\n\trestore_mounts(&to_restore);\n\tcleanup_umount_visitations(&visited);\n\tlist_splice_tail(&to_umount, list);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}