{
  "module_name": "nfs3proc.c",
  "hash_id": "08f5c4cfc6f459b0084c06578678f300ee6e869903481b8de51557ce34623903",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfs/nfs3proc.c",
  "human_readable_source": "\n \n\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/nfs.h>\n#include <linux/nfs3.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs_mount.h>\n#include <linux/freezer.h>\n#include <linux/xattr.h>\n\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"nfs3_fs.h\"\n\n#define NFSDBG_FACILITY\t\tNFSDBG_PROC\n\n \nstatic int\nnfs3_rpc_wrapper(struct rpc_clnt *clnt, struct rpc_message *msg, int flags)\n{\n\tint res;\n\tdo {\n\t\tres = rpc_call_sync(clnt, msg, flags);\n\t\tif (res != -EJUKEBOX)\n\t\t\tbreak;\n\t\t__set_current_state(TASK_KILLABLE|TASK_FREEZABLE_UNSAFE);\n\t\tschedule_timeout(NFS_JUKEBOX_RETRY_TIME);\n\t\tres = -ERESTARTSYS;\n\t} while (!fatal_signal_pending(current));\n\treturn res;\n}\n\n#define rpc_call_sync(clnt, msg, flags)\tnfs3_rpc_wrapper(clnt, msg, flags)\n\nstatic int\nnfs3_async_handle_jukebox(struct rpc_task *task, struct inode *inode)\n{\n\tif (task->tk_status != -EJUKEBOX)\n\t\treturn 0;\n\tnfs_inc_stats(inode, NFSIOS_DELAY);\n\ttask->tk_status = 0;\n\trpc_restart_call(task);\n\trpc_delay(task, NFS_JUKEBOX_RETRY_TIME);\n\treturn 1;\n}\n\nstatic int\ndo_proc_get_root(struct rpc_clnt *client, struct nfs_fh *fhandle,\n\t\t struct nfs_fsinfo *info)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs3_procedures[NFS3PROC_FSINFO],\n\t\t.rpc_argp\t= fhandle,\n\t\t.rpc_resp\t= info,\n\t};\n\tint\tstatus;\n\n\tdprintk(\"%s: call  fsinfo\\n\", __func__);\n\tnfs_fattr_init(info->fattr);\n\tstatus = rpc_call_sync(client, &msg, 0);\n\tdprintk(\"%s: reply fsinfo: %d\\n\", __func__, status);\n\tif (status == 0 && !(info->fattr->valid & NFS_ATTR_FATTR)) {\n\t\tmsg.rpc_proc = &nfs3_procedures[NFS3PROC_GETATTR];\n\t\tmsg.rpc_resp = info->fattr;\n\t\tstatus = rpc_call_sync(client, &msg, 0);\n\t\tdprintk(\"%s: reply getattr: %d\\n\", __func__, status);\n\t}\n\treturn status;\n}\n\n \nstatic int\nnfs3_proc_get_root(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\t   struct nfs_fsinfo *info)\n{\n\tint\tstatus;\n\n\tstatus = do_proc_get_root(server->client, fhandle, info);\n\tif (status && server->nfs_client->cl_rpcclient != server->client)\n\t\tstatus = do_proc_get_root(server->nfs_client->cl_rpcclient, fhandle, info);\n\treturn status;\n}\n\n \nstatic int\nnfs3_proc_getattr(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\tstruct nfs_fattr *fattr, struct inode *inode)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs3_procedures[NFS3PROC_GETATTR],\n\t\t.rpc_argp\t= fhandle,\n\t\t.rpc_resp\t= fattr,\n\t};\n\tint\tstatus;\n\tunsigned short task_flags = 0;\n\n\t \n\tif (inode && (server->flags & NFS_MOUNT_SOFTREVAL))\n\t\ttask_flags |= RPC_TASK_TIMEOUT;\n\n\tdprintk(\"NFS call  getattr\\n\");\n\tnfs_fattr_init(fattr);\n\tstatus = rpc_call_sync(server->client, &msg, task_flags);\n\tdprintk(\"NFS reply getattr: %d\\n\", status);\n\treturn status;\n}\n\nstatic int\nnfs3_proc_setattr(struct dentry *dentry, struct nfs_fattr *fattr,\n\t\t\tstruct iattr *sattr)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct nfs3_sattrargs\targ = {\n\t\t.fh\t\t= NFS_FH(inode),\n\t\t.sattr\t\t= sattr,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs3_procedures[NFS3PROC_SETATTR],\n\t\t.rpc_argp\t= &arg,\n\t\t.rpc_resp\t= fattr,\n\t};\n\tint\tstatus;\n\n\tdprintk(\"NFS call  setattr\\n\");\n\tif (sattr->ia_valid & ATTR_FILE)\n\t\tmsg.rpc_cred = nfs_file_cred(sattr->ia_file);\n\tnfs_fattr_init(fattr);\n\tstatus = rpc_call_sync(NFS_CLIENT(inode), &msg, 0);\n\tif (status == 0) {\n\t\tnfs_setattr_update_inode(inode, sattr, fattr);\n\t\tif (NFS_I(inode)->cache_validity & NFS_INO_INVALID_ACL)\n\t\t\tnfs_zap_acl_cache(inode);\n\t}\n\tdprintk(\"NFS reply setattr: %d\\n\", status);\n\treturn status;\n}\n\nstatic int\n__nfs3_proc_lookup(struct inode *dir, const char *name, size_t len,\n\t\t   struct nfs_fh *fhandle, struct nfs_fattr *fattr,\n\t\t   unsigned short task_flags)\n{\n\tstruct nfs3_diropargs\targ = {\n\t\t.fh\t\t= NFS_FH(dir),\n\t\t.name\t\t= name,\n\t\t.len\t\t= len\n\t};\n\tstruct nfs3_diropres\tres = {\n\t\t.fh\t\t= fhandle,\n\t\t.fattr\t\t= fattr\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs3_procedures[NFS3PROC_LOOKUP],\n\t\t.rpc_argp\t= &arg,\n\t\t.rpc_resp\t= &res,\n\t};\n\tint\t\t\tstatus;\n\n\tres.dir_attr = nfs_alloc_fattr();\n\tif (res.dir_attr == NULL)\n\t\treturn -ENOMEM;\n\n\tnfs_fattr_init(fattr);\n\tstatus = rpc_call_sync(NFS_CLIENT(dir), &msg, task_flags);\n\tnfs_refresh_inode(dir, res.dir_attr);\n\tif (status >= 0 && !(fattr->valid & NFS_ATTR_FATTR)) {\n\t\tmsg.rpc_proc = &nfs3_procedures[NFS3PROC_GETATTR];\n\t\tmsg.rpc_argp = fhandle;\n\t\tmsg.rpc_resp = fattr;\n\t\tstatus = rpc_call_sync(NFS_CLIENT(dir), &msg, task_flags);\n\t}\n\tnfs_free_fattr(res.dir_attr);\n\tdprintk(\"NFS reply lookup: %d\\n\", status);\n\treturn status;\n}\n\nstatic int\nnfs3_proc_lookup(struct inode *dir, struct dentry *dentry,\n\t\t struct nfs_fh *fhandle, struct nfs_fattr *fattr)\n{\n\tunsigned short task_flags = 0;\n\n\t \n\tif (nfs_lookup_is_soft_revalidate(dentry))\n\t\ttask_flags |= RPC_TASK_TIMEOUT;\n\n\tdprintk(\"NFS call  lookup %pd2\\n\", dentry);\n\treturn __nfs3_proc_lookup(dir, dentry->d_name.name,\n\t\t\t\t  dentry->d_name.len, fhandle, fattr,\n\t\t\t\t  task_flags);\n}\n\nstatic int nfs3_proc_lookupp(struct inode *inode, struct nfs_fh *fhandle,\n\t\t\t     struct nfs_fattr *fattr)\n{\n\tconst char dotdot[] = \"..\";\n\tconst size_t len = strlen(dotdot);\n\tunsigned short task_flags = 0;\n\n\tif (NFS_SERVER(inode)->flags & NFS_MOUNT_SOFTREVAL)\n\t\ttask_flags |= RPC_TASK_TIMEOUT;\n\n\treturn __nfs3_proc_lookup(inode, dotdot, len, fhandle, fattr,\n\t\t\t\t  task_flags);\n}\n\nstatic int nfs3_proc_access(struct inode *inode, struct nfs_access_entry *entry,\n\t\t\t    const struct cred *cred)\n{\n\tstruct nfs3_accessargs\targ = {\n\t\t.fh\t\t= NFS_FH(inode),\n\t\t.access\t\t= entry->mask,\n\t};\n\tstruct nfs3_accessres\tres;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs3_procedures[NFS3PROC_ACCESS],\n\t\t.rpc_argp\t= &arg,\n\t\t.rpc_resp\t= &res,\n\t\t.rpc_cred\t= cred,\n\t};\n\tint status = -ENOMEM;\n\n\tdprintk(\"NFS call  access\\n\");\n\tres.fattr = nfs_alloc_fattr();\n\tif (res.fattr == NULL)\n\t\tgoto out;\n\n\tstatus = rpc_call_sync(NFS_CLIENT(inode), &msg, 0);\n\tnfs_refresh_inode(inode, res.fattr);\n\tif (status == 0)\n\t\tnfs_access_set_mask(entry, res.access);\n\tnfs_free_fattr(res.fattr);\nout:\n\tdprintk(\"NFS reply access: %d\\n\", status);\n\treturn status;\n}\n\nstatic int nfs3_proc_readlink(struct inode *inode, struct page *page,\n\t\tunsigned int pgbase, unsigned int pglen)\n{\n\tstruct nfs_fattr\t*fattr;\n\tstruct nfs3_readlinkargs args = {\n\t\t.fh\t\t= NFS_FH(inode),\n\t\t.pgbase\t\t= pgbase,\n\t\t.pglen\t\t= pglen,\n\t\t.pages\t\t= &page\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs3_procedures[NFS3PROC_READLINK],\n\t\t.rpc_argp\t= &args,\n\t};\n\tint status = -ENOMEM;\n\n\tdprintk(\"NFS call  readlink\\n\");\n\tfattr = nfs_alloc_fattr();\n\tif (fattr == NULL)\n\t\tgoto out;\n\tmsg.rpc_resp = fattr;\n\n\tstatus = rpc_call_sync(NFS_CLIENT(inode), &msg, 0);\n\tnfs_refresh_inode(inode, fattr);\n\tnfs_free_fattr(fattr);\nout:\n\tdprintk(\"NFS reply readlink: %d\\n\", status);\n\treturn status;\n}\n\nstruct nfs3_createdata {\n\tstruct rpc_message msg;\n\tunion {\n\t\tstruct nfs3_createargs create;\n\t\tstruct nfs3_mkdirargs mkdir;\n\t\tstruct nfs3_symlinkargs symlink;\n\t\tstruct nfs3_mknodargs mknod;\n\t} arg;\n\tstruct nfs3_diropres res;\n\tstruct nfs_fh fh;\n\tstruct nfs_fattr fattr;\n\tstruct nfs_fattr dir_attr;\n};\n\nstatic struct nfs3_createdata *nfs3_alloc_createdata(void)\n{\n\tstruct nfs3_createdata *data;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (data != NULL) {\n\t\tdata->msg.rpc_argp = &data->arg;\n\t\tdata->msg.rpc_resp = &data->res;\n\t\tdata->res.fh = &data->fh;\n\t\tdata->res.fattr = &data->fattr;\n\t\tdata->res.dir_attr = &data->dir_attr;\n\t\tnfs_fattr_init(data->res.fattr);\n\t\tnfs_fattr_init(data->res.dir_attr);\n\t}\n\treturn data;\n}\n\nstatic struct dentry *\nnfs3_do_create(struct inode *dir, struct dentry *dentry, struct nfs3_createdata *data)\n{\n\tint status;\n\n\tstatus = rpc_call_sync(NFS_CLIENT(dir), &data->msg, 0);\n\tnfs_post_op_update_inode(dir, data->res.dir_attr);\n\tif (status != 0)\n\t\treturn ERR_PTR(status);\n\n\treturn nfs_add_or_obtain(dentry, data->res.fh, data->res.fattr);\n}\n\nstatic void nfs3_free_createdata(struct nfs3_createdata *data)\n{\n\tkfree(data);\n}\n\n \nstatic int\nnfs3_proc_create(struct inode *dir, struct dentry *dentry, struct iattr *sattr,\n\t\t int flags)\n{\n\tstruct posix_acl *default_acl, *acl;\n\tstruct nfs3_createdata *data;\n\tstruct dentry *d_alias;\n\tint status = -ENOMEM;\n\n\tdprintk(\"NFS call  create %pd\\n\", dentry);\n\n\tdata = nfs3_alloc_createdata();\n\tif (data == NULL)\n\t\tgoto out;\n\n\tdata->msg.rpc_proc = &nfs3_procedures[NFS3PROC_CREATE];\n\tdata->arg.create.fh = NFS_FH(dir);\n\tdata->arg.create.name = dentry->d_name.name;\n\tdata->arg.create.len = dentry->d_name.len;\n\tdata->arg.create.sattr = sattr;\n\n\tdata->arg.create.createmode = NFS3_CREATE_UNCHECKED;\n\tif (flags & O_EXCL) {\n\t\tdata->arg.create.createmode  = NFS3_CREATE_EXCLUSIVE;\n\t\tdata->arg.create.verifier[0] = cpu_to_be32(jiffies);\n\t\tdata->arg.create.verifier[1] = cpu_to_be32(current->pid);\n\t}\n\n\tstatus = posix_acl_create(dir, &sattr->ia_mode, &default_acl, &acl);\n\tif (status)\n\t\tgoto out;\n\n\tfor (;;) {\n\t\td_alias = nfs3_do_create(dir, dentry, data);\n\t\tstatus = PTR_ERR_OR_ZERO(d_alias);\n\n\t\tif (status != -ENOTSUPP)\n\t\t\tbreak;\n\t\t \n\t\tswitch (data->arg.create.createmode) {\n\t\t\tcase NFS3_CREATE_EXCLUSIVE:\n\t\t\t\tdata->arg.create.createmode = NFS3_CREATE_GUARDED;\n\t\t\t\tbreak;\n\n\t\t\tcase NFS3_CREATE_GUARDED:\n\t\t\t\tdata->arg.create.createmode = NFS3_CREATE_UNCHECKED;\n\t\t\t\tbreak;\n\n\t\t\tcase NFS3_CREATE_UNCHECKED:\n\t\t\t\tgoto out_release_acls;\n\t\t}\n\t\tnfs_fattr_init(data->res.dir_attr);\n\t\tnfs_fattr_init(data->res.fattr);\n\t}\n\n\tif (status != 0)\n\t\tgoto out_release_acls;\n\n\tif (d_alias)\n\t\tdentry = d_alias;\n\n\t \n\tif (data->arg.create.createmode == NFS3_CREATE_EXCLUSIVE) {\n\t\tdprintk(\"NFS call  setattr (post-create)\\n\");\n\n\t\tif (!(sattr->ia_valid & ATTR_ATIME_SET))\n\t\t\tsattr->ia_valid |= ATTR_ATIME;\n\t\tif (!(sattr->ia_valid & ATTR_MTIME_SET))\n\t\t\tsattr->ia_valid |= ATTR_MTIME;\n\n\t\t \n\t\tstatus = nfs3_proc_setattr(dentry, data->res.fattr, sattr);\n\t\tnfs_post_op_update_inode(d_inode(dentry), data->res.fattr);\n\t\tdprintk(\"NFS reply setattr (post-create): %d\\n\", status);\n\t\tif (status != 0)\n\t\t\tgoto out_dput;\n\t}\n\n\tstatus = nfs3_proc_setacls(d_inode(dentry), acl, default_acl);\n\nout_dput:\n\tdput(d_alias);\nout_release_acls:\n\tposix_acl_release(acl);\n\tposix_acl_release(default_acl);\nout:\n\tnfs3_free_createdata(data);\n\tdprintk(\"NFS reply create: %d\\n\", status);\n\treturn status;\n}\n\nstatic int\nnfs3_proc_remove(struct inode *dir, struct dentry *dentry)\n{\n\tstruct nfs_removeargs arg = {\n\t\t.fh = NFS_FH(dir),\n\t\t.name = dentry->d_name,\n\t};\n\tstruct nfs_removeres res;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs3_procedures[NFS3PROC_REMOVE],\n\t\t.rpc_argp = &arg,\n\t\t.rpc_resp = &res,\n\t};\n\tint status = -ENOMEM;\n\n\tdprintk(\"NFS call  remove %pd2\\n\", dentry);\n\tres.dir_attr = nfs_alloc_fattr();\n\tif (res.dir_attr == NULL)\n\t\tgoto out;\n\n\tstatus = rpc_call_sync(NFS_CLIENT(dir), &msg, 0);\n\tnfs_post_op_update_inode(dir, res.dir_attr);\n\tnfs_free_fattr(res.dir_attr);\nout:\n\tdprintk(\"NFS reply remove: %d\\n\", status);\n\treturn status;\n}\n\nstatic void\nnfs3_proc_unlink_setup(struct rpc_message *msg,\n\t\tstruct dentry *dentry,\n\t\tstruct inode *inode)\n{\n\tmsg->rpc_proc = &nfs3_procedures[NFS3PROC_REMOVE];\n}\n\nstatic void nfs3_proc_unlink_rpc_prepare(struct rpc_task *task, struct nfs_unlinkdata *data)\n{\n\trpc_call_start(task);\n}\n\nstatic int\nnfs3_proc_unlink_done(struct rpc_task *task, struct inode *dir)\n{\n\tstruct nfs_removeres *res;\n\tif (nfs3_async_handle_jukebox(task, dir))\n\t\treturn 0;\n\tres = task->tk_msg.rpc_resp;\n\tnfs_post_op_update_inode(dir, res->dir_attr);\n\treturn 1;\n}\n\nstatic void\nnfs3_proc_rename_setup(struct rpc_message *msg,\n\t\tstruct dentry *old_dentry,\n\t\tstruct dentry *new_dentry)\n{\n\tmsg->rpc_proc = &nfs3_procedures[NFS3PROC_RENAME];\n}\n\nstatic void nfs3_proc_rename_rpc_prepare(struct rpc_task *task, struct nfs_renamedata *data)\n{\n\trpc_call_start(task);\n}\n\nstatic int\nnfs3_proc_rename_done(struct rpc_task *task, struct inode *old_dir,\n\t\t      struct inode *new_dir)\n{\n\tstruct nfs_renameres *res;\n\n\tif (nfs3_async_handle_jukebox(task, old_dir))\n\t\treturn 0;\n\tres = task->tk_msg.rpc_resp;\n\n\tnfs_post_op_update_inode(old_dir, res->old_fattr);\n\tnfs_post_op_update_inode(new_dir, res->new_fattr);\n\treturn 1;\n}\n\nstatic int\nnfs3_proc_link(struct inode *inode, struct inode *dir, const struct qstr *name)\n{\n\tstruct nfs3_linkargs\targ = {\n\t\t.fromfh\t\t= NFS_FH(inode),\n\t\t.tofh\t\t= NFS_FH(dir),\n\t\t.toname\t\t= name->name,\n\t\t.tolen\t\t= name->len\n\t};\n\tstruct nfs3_linkres\tres;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs3_procedures[NFS3PROC_LINK],\n\t\t.rpc_argp\t= &arg,\n\t\t.rpc_resp\t= &res,\n\t};\n\tint status = -ENOMEM;\n\n\tdprintk(\"NFS call  link %s\\n\", name->name);\n\tres.fattr = nfs_alloc_fattr();\n\tres.dir_attr = nfs_alloc_fattr();\n\tif (res.fattr == NULL || res.dir_attr == NULL)\n\t\tgoto out;\n\n\tstatus = rpc_call_sync(NFS_CLIENT(inode), &msg, 0);\n\tnfs_post_op_update_inode(dir, res.dir_attr);\n\tnfs_post_op_update_inode(inode, res.fattr);\nout:\n\tnfs_free_fattr(res.dir_attr);\n\tnfs_free_fattr(res.fattr);\n\tdprintk(\"NFS reply link: %d\\n\", status);\n\treturn status;\n}\n\nstatic int\nnfs3_proc_symlink(struct inode *dir, struct dentry *dentry, struct page *page,\n\t\t  unsigned int len, struct iattr *sattr)\n{\n\tstruct nfs3_createdata *data;\n\tstruct dentry *d_alias;\n\tint status = -ENOMEM;\n\n\tif (len > NFS3_MAXPATHLEN)\n\t\treturn -ENAMETOOLONG;\n\n\tdprintk(\"NFS call  symlink %pd\\n\", dentry);\n\n\tdata = nfs3_alloc_createdata();\n\tif (data == NULL)\n\t\tgoto out;\n\tdata->msg.rpc_proc = &nfs3_procedures[NFS3PROC_SYMLINK];\n\tdata->arg.symlink.fromfh = NFS_FH(dir);\n\tdata->arg.symlink.fromname = dentry->d_name.name;\n\tdata->arg.symlink.fromlen = dentry->d_name.len;\n\tdata->arg.symlink.pages = &page;\n\tdata->arg.symlink.pathlen = len;\n\tdata->arg.symlink.sattr = sattr;\n\n\td_alias = nfs3_do_create(dir, dentry, data);\n\tstatus = PTR_ERR_OR_ZERO(d_alias);\n\n\tif (status == 0)\n\t\tdput(d_alias);\n\n\tnfs3_free_createdata(data);\nout:\n\tdprintk(\"NFS reply symlink: %d\\n\", status);\n\treturn status;\n}\n\nstatic int\nnfs3_proc_mkdir(struct inode *dir, struct dentry *dentry, struct iattr *sattr)\n{\n\tstruct posix_acl *default_acl, *acl;\n\tstruct nfs3_createdata *data;\n\tstruct dentry *d_alias;\n\tint status = -ENOMEM;\n\n\tdprintk(\"NFS call  mkdir %pd\\n\", dentry);\n\n\tdata = nfs3_alloc_createdata();\n\tif (data == NULL)\n\t\tgoto out;\n\n\tstatus = posix_acl_create(dir, &sattr->ia_mode, &default_acl, &acl);\n\tif (status)\n\t\tgoto out;\n\n\tdata->msg.rpc_proc = &nfs3_procedures[NFS3PROC_MKDIR];\n\tdata->arg.mkdir.fh = NFS_FH(dir);\n\tdata->arg.mkdir.name = dentry->d_name.name;\n\tdata->arg.mkdir.len = dentry->d_name.len;\n\tdata->arg.mkdir.sattr = sattr;\n\n\td_alias = nfs3_do_create(dir, dentry, data);\n\tstatus = PTR_ERR_OR_ZERO(d_alias);\n\n\tif (status != 0)\n\t\tgoto out_release_acls;\n\n\tif (d_alias)\n\t\tdentry = d_alias;\n\n\tstatus = nfs3_proc_setacls(d_inode(dentry), acl, default_acl);\n\n\tdput(d_alias);\nout_release_acls:\n\tposix_acl_release(acl);\n\tposix_acl_release(default_acl);\nout:\n\tnfs3_free_createdata(data);\n\tdprintk(\"NFS reply mkdir: %d\\n\", status);\n\treturn status;\n}\n\nstatic int\nnfs3_proc_rmdir(struct inode *dir, const struct qstr *name)\n{\n\tstruct nfs_fattr\t*dir_attr;\n\tstruct nfs3_diropargs\targ = {\n\t\t.fh\t\t= NFS_FH(dir),\n\t\t.name\t\t= name->name,\n\t\t.len\t\t= name->len\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs3_procedures[NFS3PROC_RMDIR],\n\t\t.rpc_argp\t= &arg,\n\t};\n\tint status = -ENOMEM;\n\n\tdprintk(\"NFS call  rmdir %s\\n\", name->name);\n\tdir_attr = nfs_alloc_fattr();\n\tif (dir_attr == NULL)\n\t\tgoto out;\n\n\tmsg.rpc_resp = dir_attr;\n\tstatus = rpc_call_sync(NFS_CLIENT(dir), &msg, 0);\n\tnfs_post_op_update_inode(dir, dir_attr);\n\tnfs_free_fattr(dir_attr);\nout:\n\tdprintk(\"NFS reply rmdir: %d\\n\", status);\n\treturn status;\n}\n\n \nstatic int nfs3_proc_readdir(struct nfs_readdir_arg *nr_arg,\n\t\t\t     struct nfs_readdir_res *nr_res)\n{\n\tstruct inode\t\t*dir = d_inode(nr_arg->dentry);\n\tstruct nfs3_readdirargs\targ = {\n\t\t.fh\t\t= NFS_FH(dir),\n\t\t.cookie\t\t= nr_arg->cookie,\n\t\t.plus\t\t= nr_arg->plus,\n\t\t.count\t\t= nr_arg->page_len,\n\t\t.pages\t\t= nr_arg->pages\n\t};\n\tstruct nfs3_readdirres\tres = {\n\t\t.verf\t\t= nr_res->verf,\n\t\t.plus\t\t= nr_arg->plus,\n\t};\n\tstruct rpc_message\tmsg = {\n\t\t.rpc_proc\t= &nfs3_procedures[NFS3PROC_READDIR],\n\t\t.rpc_argp\t= &arg,\n\t\t.rpc_resp\t= &res,\n\t\t.rpc_cred\t= nr_arg->cred,\n\t};\n\tint status = -ENOMEM;\n\n\tif (nr_arg->plus)\n\t\tmsg.rpc_proc = &nfs3_procedures[NFS3PROC_READDIRPLUS];\n\tif (arg.cookie)\n\t\tmemcpy(arg.verf, nr_arg->verf, sizeof(arg.verf));\n\n\tdprintk(\"NFS call  readdir%s %llu\\n\", nr_arg->plus ? \"plus\" : \"\",\n\t\t(unsigned long long)nr_arg->cookie);\n\n\tres.dir_attr = nfs_alloc_fattr();\n\tif (res.dir_attr == NULL)\n\t\tgoto out;\n\n\tstatus = rpc_call_sync(NFS_CLIENT(dir), &msg, 0);\n\n\tnfs_invalidate_atime(dir);\n\tnfs_refresh_inode(dir, res.dir_attr);\n\n\tnfs_free_fattr(res.dir_attr);\nout:\n\tdprintk(\"NFS reply readdir%s: %d\\n\", nr_arg->plus ? \"plus\" : \"\",\n\t\tstatus);\n\treturn status;\n}\n\nstatic int\nnfs3_proc_mknod(struct inode *dir, struct dentry *dentry, struct iattr *sattr,\n\t\tdev_t rdev)\n{\n\tstruct posix_acl *default_acl, *acl;\n\tstruct nfs3_createdata *data;\n\tstruct dentry *d_alias;\n\tint status = -ENOMEM;\n\n\tdprintk(\"NFS call  mknod %pd %u:%u\\n\", dentry,\n\t\t\tMAJOR(rdev), MINOR(rdev));\n\n\tdata = nfs3_alloc_createdata();\n\tif (data == NULL)\n\t\tgoto out;\n\n\tstatus = posix_acl_create(dir, &sattr->ia_mode, &default_acl, &acl);\n\tif (status)\n\t\tgoto out;\n\n\tdata->msg.rpc_proc = &nfs3_procedures[NFS3PROC_MKNOD];\n\tdata->arg.mknod.fh = NFS_FH(dir);\n\tdata->arg.mknod.name = dentry->d_name.name;\n\tdata->arg.mknod.len = dentry->d_name.len;\n\tdata->arg.mknod.sattr = sattr;\n\tdata->arg.mknod.rdev = rdev;\n\n\tswitch (sattr->ia_mode & S_IFMT) {\n\tcase S_IFBLK:\n\t\tdata->arg.mknod.type = NF3BLK;\n\t\tbreak;\n\tcase S_IFCHR:\n\t\tdata->arg.mknod.type = NF3CHR;\n\t\tbreak;\n\tcase S_IFIFO:\n\t\tdata->arg.mknod.type = NF3FIFO;\n\t\tbreak;\n\tcase S_IFSOCK:\n\t\tdata->arg.mknod.type = NF3SOCK;\n\t\tbreak;\n\tdefault:\n\t\tstatus = -EINVAL;\n\t\tgoto out_release_acls;\n\t}\n\n\td_alias = nfs3_do_create(dir, dentry, data);\n\tstatus = PTR_ERR_OR_ZERO(d_alias);\n\tif (status != 0)\n\t\tgoto out_release_acls;\n\n\tif (d_alias)\n\t\tdentry = d_alias;\n\n\tstatus = nfs3_proc_setacls(d_inode(dentry), acl, default_acl);\n\n\tdput(d_alias);\nout_release_acls:\n\tposix_acl_release(acl);\n\tposix_acl_release(default_acl);\nout:\n\tnfs3_free_createdata(data);\n\tdprintk(\"NFS reply mknod: %d\\n\", status);\n\treturn status;\n}\n\nstatic int\nnfs3_proc_statfs(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\t struct nfs_fsstat *stat)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs3_procedures[NFS3PROC_FSSTAT],\n\t\t.rpc_argp\t= fhandle,\n\t\t.rpc_resp\t= stat,\n\t};\n\tint\tstatus;\n\n\tdprintk(\"NFS call  fsstat\\n\");\n\tnfs_fattr_init(stat->fattr);\n\tstatus = rpc_call_sync(server->client, &msg, 0);\n\tdprintk(\"NFS reply fsstat: %d\\n\", status);\n\treturn status;\n}\n\nstatic int\ndo_proc_fsinfo(struct rpc_clnt *client, struct nfs_fh *fhandle,\n\t\t struct nfs_fsinfo *info)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs3_procedures[NFS3PROC_FSINFO],\n\t\t.rpc_argp\t= fhandle,\n\t\t.rpc_resp\t= info,\n\t};\n\tint\tstatus;\n\n\tdprintk(\"NFS call  fsinfo\\n\");\n\tnfs_fattr_init(info->fattr);\n\tstatus = rpc_call_sync(client, &msg, 0);\n\tdprintk(\"NFS reply fsinfo: %d\\n\", status);\n\treturn status;\n}\n\n \nstatic int\nnfs3_proc_fsinfo(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\t   struct nfs_fsinfo *info)\n{\n\tint\tstatus;\n\n\tstatus = do_proc_fsinfo(server->client, fhandle, info);\n\tif (status && server->nfs_client->cl_rpcclient != server->client)\n\t\tstatus = do_proc_fsinfo(server->nfs_client->cl_rpcclient, fhandle, info);\n\treturn status;\n}\n\nstatic int\nnfs3_proc_pathconf(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\t   struct nfs_pathconf *info)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs3_procedures[NFS3PROC_PATHCONF],\n\t\t.rpc_argp\t= fhandle,\n\t\t.rpc_resp\t= info,\n\t};\n\tint\tstatus;\n\n\tdprintk(\"NFS call  pathconf\\n\");\n\tnfs_fattr_init(info->fattr);\n\tstatus = rpc_call_sync(server->client, &msg, 0);\n\tdprintk(\"NFS reply pathconf: %d\\n\", status);\n\treturn status;\n}\n\nstatic int nfs3_read_done(struct rpc_task *task, struct nfs_pgio_header *hdr)\n{\n\tstruct inode *inode = hdr->inode;\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\n\tif (hdr->pgio_done_cb != NULL)\n\t\treturn hdr->pgio_done_cb(task, hdr);\n\n\tif (nfs3_async_handle_jukebox(task, inode))\n\t\treturn -EAGAIN;\n\n\tif (task->tk_status >= 0 && !server->read_hdrsize)\n\t\tcmpxchg(&server->read_hdrsize, 0, hdr->res.replen);\n\n\tnfs_invalidate_atime(inode);\n\tnfs_refresh_inode(inode, &hdr->fattr);\n\treturn 0;\n}\n\nstatic void nfs3_proc_read_setup(struct nfs_pgio_header *hdr,\n\t\t\t\t struct rpc_message *msg)\n{\n\tmsg->rpc_proc = &nfs3_procedures[NFS3PROC_READ];\n\thdr->args.replen = NFS_SERVER(hdr->inode)->read_hdrsize;\n}\n\nstatic int nfs3_proc_pgio_rpc_prepare(struct rpc_task *task,\n\t\t\t\t      struct nfs_pgio_header *hdr)\n{\n\trpc_call_start(task);\n\treturn 0;\n}\n\nstatic int nfs3_write_done(struct rpc_task *task, struct nfs_pgio_header *hdr)\n{\n\tstruct inode *inode = hdr->inode;\n\n\tif (hdr->pgio_done_cb != NULL)\n\t\treturn hdr->pgio_done_cb(task, hdr);\n\n\tif (nfs3_async_handle_jukebox(task, inode))\n\t\treturn -EAGAIN;\n\tif (task->tk_status >= 0)\n\t\tnfs_writeback_update_inode(hdr);\n\treturn 0;\n}\n\nstatic void nfs3_proc_write_setup(struct nfs_pgio_header *hdr,\n\t\t\t\t  struct rpc_message *msg,\n\t\t\t\t  struct rpc_clnt **clnt)\n{\n\tmsg->rpc_proc = &nfs3_procedures[NFS3PROC_WRITE];\n}\n\nstatic void nfs3_proc_commit_rpc_prepare(struct rpc_task *task, struct nfs_commit_data *data)\n{\n\trpc_call_start(task);\n}\n\nstatic int nfs3_commit_done(struct rpc_task *task, struct nfs_commit_data *data)\n{\n\tif (data->commit_done_cb != NULL)\n\t\treturn data->commit_done_cb(task, data);\n\n\tif (nfs3_async_handle_jukebox(task, data->inode))\n\t\treturn -EAGAIN;\n\tnfs_refresh_inode(data->inode, data->res.fattr);\n\treturn 0;\n}\n\nstatic void nfs3_proc_commit_setup(struct nfs_commit_data *data, struct rpc_message *msg,\n\t\t\t\t   struct rpc_clnt **clnt)\n{\n\tmsg->rpc_proc = &nfs3_procedures[NFS3PROC_COMMIT];\n}\n\nstatic void nfs3_nlm_alloc_call(void *data)\n{\n\tstruct nfs_lock_context *l_ctx = data;\n\tif (l_ctx && test_bit(NFS_CONTEXT_UNLOCK, &l_ctx->open_context->flags)) {\n\t\tget_nfs_open_context(l_ctx->open_context);\n\t\tnfs_get_lock_context(l_ctx->open_context);\n\t}\n}\n\nstatic bool nfs3_nlm_unlock_prepare(struct rpc_task *task, void *data)\n{\n\tstruct nfs_lock_context *l_ctx = data;\n\tif (l_ctx && test_bit(NFS_CONTEXT_UNLOCK, &l_ctx->open_context->flags))\n\t\treturn nfs_async_iocounter_wait(task, l_ctx);\n\treturn false;\n\n}\n\nstatic void nfs3_nlm_release_call(void *data)\n{\n\tstruct nfs_lock_context *l_ctx = data;\n\tstruct nfs_open_context *ctx;\n\tif (l_ctx && test_bit(NFS_CONTEXT_UNLOCK, &l_ctx->open_context->flags)) {\n\t\tctx = l_ctx->open_context;\n\t\tnfs_put_lock_context(l_ctx);\n\t\tput_nfs_open_context(ctx);\n\t}\n}\n\nstatic const struct nlmclnt_operations nlmclnt_fl_close_lock_ops = {\n\t.nlmclnt_alloc_call = nfs3_nlm_alloc_call,\n\t.nlmclnt_unlock_prepare = nfs3_nlm_unlock_prepare,\n\t.nlmclnt_release_call = nfs3_nlm_release_call,\n};\n\nstatic int\nnfs3_proc_lock(struct file *filp, int cmd, struct file_lock *fl)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct nfs_lock_context *l_ctx = NULL;\n\tstruct nfs_open_context *ctx = nfs_file_open_context(filp);\n\tint status;\n\n\tif (fl->fl_flags & FL_CLOSE) {\n\t\tl_ctx = nfs_get_lock_context(ctx);\n\t\tif (IS_ERR(l_ctx))\n\t\t\tl_ctx = NULL;\n\t\telse\n\t\t\tset_bit(NFS_CONTEXT_UNLOCK, &ctx->flags);\n\t}\n\n\tstatus = nlmclnt_proc(NFS_SERVER(inode)->nlm_host, cmd, fl, l_ctx);\n\n\tif (l_ctx)\n\t\tnfs_put_lock_context(l_ctx);\n\n\treturn status;\n}\n\nstatic int nfs3_have_delegation(struct inode *inode, fmode_t flags)\n{\n\treturn 0;\n}\n\nstatic const struct inode_operations nfs3_dir_inode_operations = {\n\t.create\t\t= nfs_create,\n\t.lookup\t\t= nfs_lookup,\n\t.link\t\t= nfs_link,\n\t.unlink\t\t= nfs_unlink,\n\t.symlink\t= nfs_symlink,\n\t.mkdir\t\t= nfs_mkdir,\n\t.rmdir\t\t= nfs_rmdir,\n\t.mknod\t\t= nfs_mknod,\n\t.rename\t\t= nfs_rename,\n\t.permission\t= nfs_permission,\n\t.getattr\t= nfs_getattr,\n\t.setattr\t= nfs_setattr,\n#ifdef CONFIG_NFS_V3_ACL\n\t.listxattr\t= nfs3_listxattr,\n\t.get_inode_acl\t= nfs3_get_acl,\n\t.set_acl\t= nfs3_set_acl,\n#endif\n};\n\nstatic const struct inode_operations nfs3_file_inode_operations = {\n\t.permission\t= nfs_permission,\n\t.getattr\t= nfs_getattr,\n\t.setattr\t= nfs_setattr,\n#ifdef CONFIG_NFS_V3_ACL\n\t.listxattr\t= nfs3_listxattr,\n\t.get_inode_acl\t= nfs3_get_acl,\n\t.set_acl\t= nfs3_set_acl,\n#endif\n};\n\nconst struct nfs_rpc_ops nfs_v3_clientops = {\n\t.version\t= 3,\t\t\t \n\t.dentry_ops\t= &nfs_dentry_operations,\n\t.dir_inode_ops\t= &nfs3_dir_inode_operations,\n\t.file_inode_ops\t= &nfs3_file_inode_operations,\n\t.file_ops\t= &nfs_file_operations,\n\t.nlmclnt_ops\t= &nlmclnt_fl_close_lock_ops,\n\t.getroot\t= nfs3_proc_get_root,\n\t.submount\t= nfs_submount,\n\t.try_get_tree\t= nfs_try_get_tree,\n\t.getattr\t= nfs3_proc_getattr,\n\t.setattr\t= nfs3_proc_setattr,\n\t.lookup\t\t= nfs3_proc_lookup,\n\t.lookupp\t= nfs3_proc_lookupp,\n\t.access\t\t= nfs3_proc_access,\n\t.readlink\t= nfs3_proc_readlink,\n\t.create\t\t= nfs3_proc_create,\n\t.remove\t\t= nfs3_proc_remove,\n\t.unlink_setup\t= nfs3_proc_unlink_setup,\n\t.unlink_rpc_prepare = nfs3_proc_unlink_rpc_prepare,\n\t.unlink_done\t= nfs3_proc_unlink_done,\n\t.rename_setup\t= nfs3_proc_rename_setup,\n\t.rename_rpc_prepare = nfs3_proc_rename_rpc_prepare,\n\t.rename_done\t= nfs3_proc_rename_done,\n\t.link\t\t= nfs3_proc_link,\n\t.symlink\t= nfs3_proc_symlink,\n\t.mkdir\t\t= nfs3_proc_mkdir,\n\t.rmdir\t\t= nfs3_proc_rmdir,\n\t.readdir\t= nfs3_proc_readdir,\n\t.mknod\t\t= nfs3_proc_mknod,\n\t.statfs\t\t= nfs3_proc_statfs,\n\t.fsinfo\t\t= nfs3_proc_fsinfo,\n\t.pathconf\t= nfs3_proc_pathconf,\n\t.decode_dirent\t= nfs3_decode_dirent,\n\t.pgio_rpc_prepare = nfs3_proc_pgio_rpc_prepare,\n\t.read_setup\t= nfs3_proc_read_setup,\n\t.read_done\t= nfs3_read_done,\n\t.write_setup\t= nfs3_proc_write_setup,\n\t.write_done\t= nfs3_write_done,\n\t.commit_setup\t= nfs3_proc_commit_setup,\n\t.commit_rpc_prepare = nfs3_proc_commit_rpc_prepare,\n\t.commit_done\t= nfs3_commit_done,\n\t.lock\t\t= nfs3_proc_lock,\n\t.clear_acl_cache = forget_all_cached_acls,\n\t.close_context\t= nfs_close_context,\n\t.have_delegation = nfs3_have_delegation,\n\t.alloc_client\t= nfs_alloc_client,\n\t.init_client\t= nfs_init_client,\n\t.free_client\t= nfs_free_client,\n\t.create_server\t= nfs3_create_server,\n\t.clone_server\t= nfs3_clone_server,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}