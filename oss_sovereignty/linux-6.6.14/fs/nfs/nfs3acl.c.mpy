{
  "module_name": "nfs3acl.c",
  "hash_id": "b5342ae15980e490e31fbc3c968a1d39b8d93f60100872d246a4c5db9f7e7988",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfs/nfs3acl.c",
  "human_readable_source": "\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/nfs.h>\n#include <linux/nfs3.h>\n#include <linux/nfs_fs.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/nfsacl.h>\n\n#include \"internal.h\"\n#include \"nfs3_fs.h\"\n\n#define NFSDBG_FACILITY\tNFSDBG_PROC\n\n \nstatic void nfs3_prepare_get_acl(struct posix_acl **p)\n{\n\tstruct posix_acl *sentinel = uncached_acl_sentinel(current);\n\n\t \n\tcmpxchg(p, ACL_NOT_CACHED, sentinel);\n}\n\nstatic void nfs3_complete_get_acl(struct posix_acl **p, struct posix_acl *acl)\n{\n\tstruct posix_acl *sentinel = uncached_acl_sentinel(current);\n\n\t \n\tposix_acl_dup(acl);\n\tif (cmpxchg(p, sentinel, acl) != sentinel)\n\t\tposix_acl_release(acl);\n}\n\nstatic void nfs3_abort_get_acl(struct posix_acl **p)\n{\n\tstruct posix_acl *sentinel = uncached_acl_sentinel(current);\n\n\t \n\tcmpxchg(p, sentinel, ACL_NOT_CACHED);\n}\n\nstruct posix_acl *nfs3_get_acl(struct inode *inode, int type, bool rcu)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct page *pages[NFSACL_MAXPAGES] = { };\n\tstruct nfs3_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t \n\t\t.pages = pages,\n\t};\n\tstruct nfs3_getaclres res = {\n\t\tNULL,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_argp\t= &args,\n\t\t.rpc_resp\t= &res,\n\t};\n\tint status, count;\n\n\tif (rcu)\n\t\treturn ERR_PTR(-ECHILD);\n\n\tif (!nfs_server_capable(inode, NFS_CAP_ACLS))\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tstatus = nfs_revalidate_inode(inode, NFS_INO_INVALID_CHANGE);\n\tif (status < 0)\n\t\treturn ERR_PTR(status);\n\n\t \n\tif (type == ACL_TYPE_ACCESS)\n\t\targs.mask |= NFS_ACLCNT|NFS_ACL;\n\tif (S_ISDIR(inode->i_mode))\n\t\targs.mask |= NFS_DFACLCNT|NFS_DFACL;\n\tif (args.mask == 0)\n\t\treturn NULL;\n\n\tdprintk(\"NFS call getacl\\n\");\n\tmsg.rpc_proc = &server->client_acl->cl_procinfo[ACLPROC3_GETACL];\n\tres.fattr = nfs_alloc_fattr();\n\tif (res.fattr == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (args.mask & NFS_ACL)\n\t\tnfs3_prepare_get_acl(&inode->i_acl);\n\tif (args.mask & NFS_DFACL)\n\t\tnfs3_prepare_get_acl(&inode->i_default_acl);\n\n\tstatus = rpc_call_sync(server->client_acl, &msg, 0);\n\tdprintk(\"NFS reply getacl: %d\\n\", status);\n\n\t \n\tfor (count = 0; count < NFSACL_MAXPAGES && args.pages[count]; count++)\n\t\t__free_page(args.pages[count]);\n\n\tswitch (status) {\n\t\tcase 0:\n\t\t\tstatus = nfs_refresh_inode(inode, res.fattr);\n\t\t\tbreak;\n\t\tcase -EPFNOSUPPORT:\n\t\tcase -EPROTONOSUPPORT:\n\t\t\tdprintk(\"NFS_V3_ACL extension not supported; disabling\\n\");\n\t\t\tserver->caps &= ~NFS_CAP_ACLS;\n\t\t\tfallthrough;\n\t\tcase -ENOTSUPP:\n\t\t\tstatus = -EOPNOTSUPP;\n\t\t\tgoto getout;\n\t\tdefault:\n\t\t\tgoto getout;\n\t}\n\tif ((args.mask & res.mask) != args.mask) {\n\t\tstatus = -EIO;\n\t\tgoto getout;\n\t}\n\n\tif (res.acl_access != NULL) {\n\t\tif ((posix_acl_equiv_mode(res.acl_access, NULL) == 0) ||\n\t\t    res.acl_access->a_count == 0) {\n\t\t\tposix_acl_release(res.acl_access);\n\t\t\tres.acl_access = NULL;\n\t\t}\n\t}\n\n\tif (res.mask & NFS_ACL)\n\t\tnfs3_complete_get_acl(&inode->i_acl, res.acl_access);\n\telse\n\t\tforget_cached_acl(inode, ACL_TYPE_ACCESS);\n\n\tif (res.mask & NFS_DFACL)\n\t\tnfs3_complete_get_acl(&inode->i_default_acl, res.acl_default);\n\telse\n\t\tforget_cached_acl(inode, ACL_TYPE_DEFAULT);\n\n\tnfs_free_fattr(res.fattr);\n\tif (type == ACL_TYPE_ACCESS) {\n\t\tposix_acl_release(res.acl_default);\n\t\treturn res.acl_access;\n\t} else {\n\t\tposix_acl_release(res.acl_access);\n\t\treturn res.acl_default;\n\t}\n\ngetout:\n\tnfs3_abort_get_acl(&inode->i_acl);\n\tnfs3_abort_get_acl(&inode->i_default_acl);\n\tposix_acl_release(res.acl_access);\n\tposix_acl_release(res.acl_default);\n\tnfs_free_fattr(res.fattr);\n\treturn ERR_PTR(status);\n}\n\nstatic int __nfs3_proc_setacls(struct inode *inode, struct posix_acl *acl,\n\t\tstruct posix_acl *dfacl)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs_fattr *fattr;\n\tstruct page *pages[NFSACL_MAXPAGES];\n\tstruct nfs3_setaclargs args = {\n\t\t.inode = inode,\n\t\t.mask = NFS_ACL,\n\t\t.acl_access = acl,\n\t\t.pages = pages,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_argp\t= &args,\n\t\t.rpc_resp\t= &fattr,\n\t};\n\tint status = 0;\n\n\tif (acl == NULL && (!S_ISDIR(inode->i_mode) || dfacl == NULL))\n\t\tgoto out;\n\n\tstatus = -EOPNOTSUPP;\n\tif (!nfs_server_capable(inode, NFS_CAP_ACLS))\n\t\tgoto out;\n\n\t \n\tstatus = -ENOSPC;\n\tif (acl != NULL && acl->a_count > NFS_ACL_MAX_ENTRIES)\n\t\tgoto out;\n\tif (dfacl != NULL && dfacl->a_count > NFS_ACL_MAX_ENTRIES)\n\t\tgoto out;\n\tif (S_ISDIR(inode->i_mode)) {\n\t\targs.mask |= NFS_DFACL;\n\t\targs.acl_default = dfacl;\n\t\targs.len = nfsacl_size(acl, dfacl);\n\t} else\n\t\targs.len = nfsacl_size(acl, NULL);\n\n\tif (args.len > NFS_ACL_INLINE_BUFSIZE) {\n\t\tunsigned int npages = 1 + ((args.len - 1) >> PAGE_SHIFT);\n\n\t\tstatus = -ENOMEM;\n\t\tdo {\n\t\t\targs.pages[args.npages] = alloc_page(GFP_KERNEL);\n\t\t\tif (args.pages[args.npages] == NULL)\n\t\t\t\tgoto out_freepages;\n\t\t\targs.npages++;\n\t\t} while (args.npages < npages);\n\t}\n\n\tdprintk(\"NFS call setacl\\n\");\n\tstatus = -ENOMEM;\n\tfattr = nfs_alloc_fattr();\n\tif (fattr == NULL)\n\t\tgoto out_freepages;\n\n\tmsg.rpc_proc = &server->client_acl->cl_procinfo[ACLPROC3_SETACL];\n\tmsg.rpc_resp = fattr;\n\tstatus = rpc_call_sync(server->client_acl, &msg, 0);\n\tnfs_access_zap_cache(inode);\n\tnfs_zap_acl_cache(inode);\n\tdprintk(\"NFS reply setacl: %d\\n\", status);\n\n\tswitch (status) {\n\t\tcase 0:\n\t\t\tstatus = nfs_refresh_inode(inode, fattr);\n\t\t\tbreak;\n\t\tcase -EPFNOSUPPORT:\n\t\tcase -EPROTONOSUPPORT:\n\t\t\tdprintk(\"NFS_V3_ACL SETACL RPC not supported\"\n\t\t\t\t\t\"(will not retry)\\n\");\n\t\t\tserver->caps &= ~NFS_CAP_ACLS;\n\t\t\tfallthrough;\n\t\tcase -ENOTSUPP:\n\t\t\tstatus = -EOPNOTSUPP;\n\t}\n\tnfs_free_fattr(fattr);\nout_freepages:\n\twhile (args.npages != 0) {\n\t\targs.npages--;\n\t\t__free_page(args.pages[args.npages]);\n\t}\nout:\n\treturn status;\n}\n\nint nfs3_proc_setacls(struct inode *inode, struct posix_acl *acl,\n\t\tstruct posix_acl *dfacl)\n{\n\tint ret;\n\tret = __nfs3_proc_setacls(inode, acl, dfacl);\n\treturn (ret == -EOPNOTSUPP) ? 0 : ret;\n\n}\n\nint nfs3_set_acl(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\t struct posix_acl *acl, int type)\n{\n\tstruct posix_acl *orig = acl, *dfacl = NULL, *alloc;\n\tstruct inode *inode = d_inode(dentry);\n\tint status;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tswitch(type) {\n\t\tcase ACL_TYPE_ACCESS:\n\t\t\talloc = get_inode_acl(inode, ACL_TYPE_DEFAULT);\n\t\t\tif (IS_ERR(alloc))\n\t\t\t\tgoto fail;\n\t\t\tdfacl = alloc;\n\t\t\tbreak;\n\n\t\tcase ACL_TYPE_DEFAULT:\n\t\t\talloc = get_inode_acl(inode, ACL_TYPE_ACCESS);\n\t\t\tif (IS_ERR(alloc))\n\t\t\t\tgoto fail;\n\t\t\tdfacl = acl;\n\t\t\tacl = alloc;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (acl == NULL) {\n\t\talloc = posix_acl_from_mode(inode->i_mode, GFP_KERNEL);\n\t\tif (IS_ERR(alloc))\n\t\t\tgoto fail;\n\t\tacl = alloc;\n\t}\n\tstatus = __nfs3_proc_setacls(inode, acl, dfacl);\nout:\n\tif (acl != orig)\n\t\tposix_acl_release(acl);\n\tif (dfacl != orig)\n\t\tposix_acl_release(dfacl);\n\treturn status;\n\nfail:\n\tstatus = PTR_ERR(alloc);\n\tgoto out;\n}\n\nstatic int\nnfs3_list_one_acl(struct inode *inode, int type, const char *name, void *data,\n\t\tsize_t size, ssize_t *result)\n{\n\tstruct posix_acl *acl;\n\tchar *p = data + *result;\n\n\tacl = get_inode_acl(inode, type);\n\tif (IS_ERR_OR_NULL(acl))\n\t\treturn 0;\n\n\tposix_acl_release(acl);\n\n\t*result += strlen(name);\n\t*result += 1;\n\tif (!size)\n\t\treturn 0;\n\tif (*result > size)\n\t\treturn -ERANGE;\n\n\tstrcpy(p, name);\n\treturn 0;\n}\n\nssize_t\nnfs3_listxattr(struct dentry *dentry, char *data, size_t size)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tssize_t result = 0;\n\tint error;\n\n\terror = nfs3_list_one_acl(inode, ACL_TYPE_ACCESS,\n\t\t\tXATTR_NAME_POSIX_ACL_ACCESS, data, size, &result);\n\tif (error)\n\t\treturn error;\n\n\terror = nfs3_list_one_acl(inode, ACL_TYPE_DEFAULT,\n\t\t\tXATTR_NAME_POSIX_ACL_DEFAULT, data, size, &result);\n\tif (error)\n\t\treturn error;\n\treturn result;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}