{
  "module_name": "callback_xdr.c",
  "hash_id": "46305a1a0ad94a1a4b654e22b74b59c8032dd1b178f40a0c2c531b9c50761833",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfs/callback_xdr.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/nfs4.h>\n#include <linux/nfs_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include \"nfs4_fs.h\"\n#include \"callback.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include \"nfs4trace.h\"\n\n#define CB_OP_TAGLEN_MAXSZ\t\t(512)\n#define CB_OP_HDR_RES_MAXSZ\t\t(2 * 4) \n#define CB_OP_GETATTR_BITMAP_MAXSZ\t(4 * 4) \n#define CB_OP_GETATTR_RES_MAXSZ\t\t(CB_OP_HDR_RES_MAXSZ + \\\n\t\t\t\t\t CB_OP_GETATTR_BITMAP_MAXSZ + \\\n\t\t\t\t\t  \\\n\t\t\t\t\t (2 + 2 + 3 + 3) * 4)\n#define CB_OP_RECALL_RES_MAXSZ\t\t(CB_OP_HDR_RES_MAXSZ)\n\n#if defined(CONFIG_NFS_V4_1)\n#define CB_OP_LAYOUTRECALL_RES_MAXSZ\t(CB_OP_HDR_RES_MAXSZ)\n#define CB_OP_DEVICENOTIFY_RES_MAXSZ\t(CB_OP_HDR_RES_MAXSZ)\n#define CB_OP_SEQUENCE_RES_MAXSZ\t(CB_OP_HDR_RES_MAXSZ + \\\n\t\t\t\t\t NFS4_MAX_SESSIONID_LEN + \\\n\t\t\t\t\t (1 + 3) * 4) \n#define CB_OP_RECALLANY_RES_MAXSZ\t(CB_OP_HDR_RES_MAXSZ)\n#define CB_OP_RECALLSLOT_RES_MAXSZ\t(CB_OP_HDR_RES_MAXSZ)\n#define CB_OP_NOTIFY_LOCK_RES_MAXSZ\t(CB_OP_HDR_RES_MAXSZ)\n#endif  \n#ifdef CONFIG_NFS_V4_2\n#define CB_OP_OFFLOAD_RES_MAXSZ\t\t(CB_OP_HDR_RES_MAXSZ)\n#endif  \n\n#define NFSDBG_FACILITY NFSDBG_CALLBACK\n\n \n#define NFS4ERR_RESOURCE_HDR\t11050\n\nstruct callback_op {\n\t__be32 (*process_op)(void *, void *, struct cb_process_state *);\n\t__be32 (*decode_args)(struct svc_rqst *, struct xdr_stream *, void *);\n\t__be32 (*encode_res)(struct svc_rqst *, struct xdr_stream *,\n\t\t\tconst void *);\n\tlong res_maxsize;\n};\n\nstatic struct callback_op callback_ops[];\n\nstatic __be32 nfs4_callback_null(struct svc_rqst *rqstp)\n{\n\treturn htonl(NFS4_OK);\n}\n\n \nstatic bool nfs4_encode_void(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\treturn true;\n}\n\nstatic __be32 decode_string(struct xdr_stream *xdr, unsigned int *len,\n\t\tconst char **str, size_t maxlen)\n{\n\tssize_t err;\n\n\terr = xdr_stream_decode_opaque_inline(xdr, (void **)str, maxlen);\n\tif (err < 0)\n\t\treturn cpu_to_be32(NFS4ERR_RESOURCE);\n\t*len = err;\n\treturn 0;\n}\n\nstatic __be32 decode_fh(struct xdr_stream *xdr, struct nfs_fh *fh)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\tfh->size = ntohl(*p);\n\tif (fh->size > NFS4_FHSIZE)\n\t\treturn htonl(NFS4ERR_BADHANDLE);\n\tp = xdr_inline_decode(xdr, fh->size);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\tmemcpy(&fh->data[0], p, fh->size);\n\tmemset(&fh->data[fh->size], 0, sizeof(fh->data) - fh->size);\n\treturn 0;\n}\n\nstatic __be32 decode_bitmap(struct xdr_stream *xdr, uint32_t *bitmap)\n{\n\t__be32 *p;\n\tunsigned int attrlen;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\tattrlen = ntohl(*p);\n\tp = xdr_inline_decode(xdr, attrlen << 2);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\tif (likely(attrlen > 0))\n\t\tbitmap[0] = ntohl(*p++);\n\tif (attrlen > 1)\n\t\tbitmap[1] = ntohl(*p);\n\treturn 0;\n}\n\nstatic __be32 decode_stateid(struct xdr_stream *xdr, nfs4_stateid *stateid)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, NFS4_STATEID_SIZE);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\tmemcpy(stateid->data, p, NFS4_STATEID_SIZE);\n\treturn 0;\n}\n\nstatic __be32 decode_delegation_stateid(struct xdr_stream *xdr, nfs4_stateid *stateid)\n{\n\tstateid->type = NFS4_DELEGATION_STATEID_TYPE;\n\treturn decode_stateid(xdr, stateid);\n}\n\nstatic __be32 decode_compound_hdr_arg(struct xdr_stream *xdr, struct cb_compound_hdr_arg *hdr)\n{\n\t__be32 *p;\n\t__be32 status;\n\n\tstatus = decode_string(xdr, &hdr->taglen, &hdr->tag, CB_OP_TAGLEN_MAXSZ);\n\tif (unlikely(status != 0))\n\t\treturn status;\n\tp = xdr_inline_decode(xdr, 12);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\thdr->minorversion = ntohl(*p++);\n\t \n\tif (hdr->minorversion <= NFS4_MAX_MINOR_VERSION) {\n\t\thdr->cb_ident = ntohl(*p++);  \n\t} else {\n\t\tpr_warn_ratelimited(\"NFS: %s: NFSv4 server callback with \"\n\t\t\t\"illegal minor version %u!\\n\",\n\t\t\t__func__, hdr->minorversion);\n\t\treturn htonl(NFS4ERR_MINOR_VERS_MISMATCH);\n\t}\n\thdr->nops = ntohl(*p);\n\treturn 0;\n}\n\nstatic __be32 decode_op_hdr(struct xdr_stream *xdr, unsigned int *op)\n{\n\t__be32 *p;\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE_HDR);\n\t*op = ntohl(*p);\n\treturn 0;\n}\n\nstatic __be32 decode_getattr_args(struct svc_rqst *rqstp,\n\t\tstruct xdr_stream *xdr, void *argp)\n{\n\tstruct cb_getattrargs *args = argp;\n\t__be32 status;\n\n\tstatus = decode_fh(xdr, &args->fh);\n\tif (unlikely(status != 0))\n\t\treturn status;\n\treturn decode_bitmap(xdr, args->bitmap);\n}\n\nstatic __be32 decode_recall_args(struct svc_rqst *rqstp,\n\t\tstruct xdr_stream *xdr, void *argp)\n{\n\tstruct cb_recallargs *args = argp;\n\t__be32 *p;\n\t__be32 status;\n\n\tstatus = decode_delegation_stateid(xdr, &args->stateid);\n\tif (unlikely(status != 0))\n\t\treturn status;\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\targs->truncate = ntohl(*p);\n\treturn decode_fh(xdr, &args->fh);\n}\n\n#if defined(CONFIG_NFS_V4_1)\nstatic __be32 decode_layout_stateid(struct xdr_stream *xdr, nfs4_stateid *stateid)\n{\n\tstateid->type = NFS4_LAYOUT_STATEID_TYPE;\n\treturn decode_stateid(xdr, stateid);\n}\n\nstatic __be32 decode_layoutrecall_args(struct svc_rqst *rqstp,\n\t\t\t\t       struct xdr_stream *xdr, void *argp)\n{\n\tstruct cb_layoutrecallargs *args = argp;\n\t__be32 *p;\n\t__be32 status = 0;\n\tuint32_t iomode;\n\n\tp = xdr_inline_decode(xdr, 4 * sizeof(uint32_t));\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_BADXDR);\n\n\targs->cbl_layout_type = ntohl(*p++);\n\t \n\tiomode = ntohl(*p++);\n\targs->cbl_layoutchanged = ntohl(*p++);\n\targs->cbl_recall_type = ntohl(*p++);\n\n\tif (args->cbl_recall_type == RETURN_FILE) {\n\t\targs->cbl_range.iomode = iomode;\n\t\tstatus = decode_fh(xdr, &args->cbl_fh);\n\t\tif (unlikely(status != 0))\n\t\t\treturn status;\n\n\t\tp = xdr_inline_decode(xdr, 2 * sizeof(uint64_t));\n\t\tif (unlikely(p == NULL))\n\t\t\treturn htonl(NFS4ERR_BADXDR);\n\t\tp = xdr_decode_hyper(p, &args->cbl_range.offset);\n\t\tp = xdr_decode_hyper(p, &args->cbl_range.length);\n\t\treturn decode_layout_stateid(xdr, &args->cbl_stateid);\n\t} else if (args->cbl_recall_type == RETURN_FSID) {\n\t\tp = xdr_inline_decode(xdr, 2 * sizeof(uint64_t));\n\t\tif (unlikely(p == NULL))\n\t\t\treturn htonl(NFS4ERR_BADXDR);\n\t\tp = xdr_decode_hyper(p, &args->cbl_fsid.major);\n\t\tp = xdr_decode_hyper(p, &args->cbl_fsid.minor);\n\t} else if (args->cbl_recall_type != RETURN_ALL)\n\t\treturn htonl(NFS4ERR_BADXDR);\n\treturn 0;\n}\n\nstatic\n__be32 decode_devicenotify_args(struct svc_rqst *rqstp,\n\t\t\t\tstruct xdr_stream *xdr,\n\t\t\t\tvoid *argp)\n{\n\tstruct cb_devicenotifyargs *args = argp;\n\tuint32_t tmp, n, i;\n\t__be32 *p;\n\t__be32 status = 0;\n\n\t \n\tp = xdr_inline_decode(xdr, sizeof(uint32_t));\n\tif (unlikely(p == NULL)) {\n\t\tstatus = htonl(NFS4ERR_BADXDR);\n\t\tgoto out;\n\t}\n\tn = ntohl(*p++);\n\tif (n == 0)\n\t\tgoto out;\n\n\targs->devs = kmalloc_array(n, sizeof(*args->devs), GFP_KERNEL);\n\tif (!args->devs) {\n\t\tstatus = htonl(NFS4ERR_DELAY);\n\t\tgoto out;\n\t}\n\n\t \n\tfor (i = 0; i < n; i++) {\n\t\tstruct cb_devicenotifyitem *dev = &args->devs[i];\n\n\t\tp = xdr_inline_decode(xdr, (4 * sizeof(uint32_t)) +\n\t\t\t\t      NFS4_DEVICEID4_SIZE);\n\t\tif (unlikely(p == NULL)) {\n\t\t\tstatus = htonl(NFS4ERR_BADXDR);\n\t\t\tgoto err;\n\t\t}\n\n\t\ttmp = ntohl(*p++);\t \n\t\tif (tmp != 1) {\n\t\t\tstatus = htonl(NFS4ERR_INVAL);\n\t\t\tgoto err;\n\t\t}\n\t\tdev->cbd_notify_type = ntohl(*p++);\n\t\tif (dev->cbd_notify_type != NOTIFY_DEVICEID4_CHANGE &&\n\t\t    dev->cbd_notify_type != NOTIFY_DEVICEID4_DELETE) {\n\t\t\tstatus = htonl(NFS4ERR_INVAL);\n\t\t\tgoto err;\n\t\t}\n\n\t\ttmp = ntohl(*p++);\t \n\t\tif (((dev->cbd_notify_type == NOTIFY_DEVICEID4_CHANGE) &&\n\t\t     (tmp != NFS4_DEVICEID4_SIZE + 8)) ||\n\t\t    ((dev->cbd_notify_type == NOTIFY_DEVICEID4_DELETE) &&\n\t\t     (tmp != NFS4_DEVICEID4_SIZE + 4))) {\n\t\t\tstatus = htonl(NFS4ERR_INVAL);\n\t\t\tgoto err;\n\t\t}\n\t\tdev->cbd_layout_type = ntohl(*p++);\n\t\tmemcpy(dev->cbd_dev_id.data, p, NFS4_DEVICEID4_SIZE);\n\t\tp += XDR_QUADLEN(NFS4_DEVICEID4_SIZE);\n\n\t\tif (dev->cbd_layout_type == NOTIFY_DEVICEID4_CHANGE) {\n\t\t\tp = xdr_inline_decode(xdr, sizeof(uint32_t));\n\t\t\tif (unlikely(p == NULL)) {\n\t\t\t\tstatus = htonl(NFS4ERR_BADXDR);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tdev->cbd_immediate = ntohl(*p++);\n\t\t} else {\n\t\t\tdev->cbd_immediate = 0;\n\t\t}\n\n\t\tdprintk(\"%s: type %d layout 0x%x immediate %d\\n\",\n\t\t\t__func__, dev->cbd_notify_type, dev->cbd_layout_type,\n\t\t\tdev->cbd_immediate);\n\t}\n\targs->ndevs = n;\n\tdprintk(\"%s: ndevs %d\\n\", __func__, args->ndevs);\n\treturn 0;\nerr:\n\tkfree(args->devs);\nout:\n\targs->devs = NULL;\n\targs->ndevs = 0;\n\tdprintk(\"%s: status %d ndevs %d\\n\",\n\t\t__func__, ntohl(status), args->ndevs);\n\treturn status;\n}\n\nstatic __be32 decode_sessionid(struct xdr_stream *xdr,\n\t\t\t\t struct nfs4_sessionid *sid)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, NFS4_MAX_SESSIONID_LEN);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\n\tmemcpy(sid->data, p, NFS4_MAX_SESSIONID_LEN);\n\treturn 0;\n}\n\nstatic __be32 decode_rc_list(struct xdr_stream *xdr,\n\t\t\t       struct referring_call_list *rc_list)\n{\n\t__be32 *p;\n\tint i;\n\t__be32 status;\n\n\tstatus = decode_sessionid(xdr, &rc_list->rcl_sessionid);\n\tif (status)\n\t\tgoto out;\n\n\tstatus = htonl(NFS4ERR_RESOURCE);\n\tp = xdr_inline_decode(xdr, sizeof(uint32_t));\n\tif (unlikely(p == NULL))\n\t\tgoto out;\n\n\trc_list->rcl_nrefcalls = ntohl(*p++);\n\tif (rc_list->rcl_nrefcalls) {\n\t\tp = xdr_inline_decode(xdr,\n\t\t\t     rc_list->rcl_nrefcalls * 2 * sizeof(uint32_t));\n\t\tif (unlikely(p == NULL))\n\t\t\tgoto out;\n\t\trc_list->rcl_refcalls = kmalloc_array(rc_list->rcl_nrefcalls,\n\t\t\t\t\t\tsizeof(*rc_list->rcl_refcalls),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (unlikely(rc_list->rcl_refcalls == NULL))\n\t\t\tgoto out;\n\t\tfor (i = 0; i < rc_list->rcl_nrefcalls; i++) {\n\t\t\trc_list->rcl_refcalls[i].rc_sequenceid = ntohl(*p++);\n\t\t\trc_list->rcl_refcalls[i].rc_slotid = ntohl(*p++);\n\t\t}\n\t}\n\tstatus = 0;\n\nout:\n\treturn status;\n}\n\nstatic __be32 decode_cb_sequence_args(struct svc_rqst *rqstp,\n\t\t\t\t\tstruct xdr_stream *xdr,\n\t\t\t\t\tvoid *argp)\n{\n\tstruct cb_sequenceargs *args = argp;\n\t__be32 *p;\n\tint i;\n\t__be32 status;\n\n\tstatus = decode_sessionid(xdr, &args->csa_sessionid);\n\tif (status)\n\t\treturn status;\n\n\tp = xdr_inline_decode(xdr, 5 * sizeof(uint32_t));\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\n\targs->csa_addr = svc_addr(rqstp);\n\targs->csa_sequenceid = ntohl(*p++);\n\targs->csa_slotid = ntohl(*p++);\n\targs->csa_highestslotid = ntohl(*p++);\n\targs->csa_cachethis = ntohl(*p++);\n\targs->csa_nrclists = ntohl(*p++);\n\targs->csa_rclists = NULL;\n\tif (args->csa_nrclists) {\n\t\targs->csa_rclists = kmalloc_array(args->csa_nrclists,\n\t\t\t\t\t\t  sizeof(*args->csa_rclists),\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\tif (unlikely(args->csa_rclists == NULL))\n\t\t\treturn htonl(NFS4ERR_RESOURCE);\n\n\t\tfor (i = 0; i < args->csa_nrclists; i++) {\n\t\t\tstatus = decode_rc_list(xdr, &args->csa_rclists[i]);\n\t\t\tif (status) {\n\t\t\t\targs->csa_nrclists = i;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n\nout_free:\n\tfor (i = 0; i < args->csa_nrclists; i++)\n\t\tkfree(args->csa_rclists[i].rcl_refcalls);\n\tkfree(args->csa_rclists);\n\treturn status;\n}\n\nstatic __be32 decode_recallany_args(struct svc_rqst *rqstp,\n\t\t\t\t      struct xdr_stream *xdr,\n\t\t\t\t      void *argp)\n{\n\tstruct cb_recallanyargs *args = argp;\n\tuint32_t bitmap[2];\n\t__be32 *p, status;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_BADXDR);\n\targs->craa_objs_to_keep = ntohl(*p++);\n\tstatus = decode_bitmap(xdr, bitmap);\n\tif (unlikely(status))\n\t\treturn status;\n\targs->craa_type_mask = bitmap[0];\n\n\treturn 0;\n}\n\nstatic __be32 decode_recallslot_args(struct svc_rqst *rqstp,\n\t\t\t\t\tstruct xdr_stream *xdr,\n\t\t\t\t\tvoid *argp)\n{\n\tstruct cb_recallslotargs *args = argp;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_BADXDR);\n\targs->crsa_target_highest_slotid = ntohl(*p++);\n\treturn 0;\n}\n\nstatic __be32 decode_lockowner(struct xdr_stream *xdr, struct cb_notify_lock_args *args)\n{\n\t__be32\t\t*p;\n\tunsigned int\tlen;\n\n\tp = xdr_inline_decode(xdr, 12);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_BADXDR);\n\n\tp = xdr_decode_hyper(p, &args->cbnl_owner.clientid);\n\tlen = be32_to_cpu(*p);\n\n\tp = xdr_inline_decode(xdr, len);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_BADXDR);\n\n\t \n\tif (len == 20) {\n\t\tp += 2;\t \n\t\targs->cbnl_owner.s_dev = be32_to_cpu(*p++);\n\t\txdr_decode_hyper(p, &args->cbnl_owner.id);\n\t\targs->cbnl_valid = true;\n\t} else {\n\t\targs->cbnl_owner.s_dev = 0;\n\t\targs->cbnl_owner.id = 0;\n\t\targs->cbnl_valid = false;\n\t}\n\treturn 0;\n}\n\nstatic __be32 decode_notify_lock_args(struct svc_rqst *rqstp,\n\t\tstruct xdr_stream *xdr, void *argp)\n{\n\tstruct cb_notify_lock_args *args = argp;\n\t__be32 status;\n\n\tstatus = decode_fh(xdr, &args->cbnl_fh);\n\tif (unlikely(status != 0))\n\t\treturn status;\n\treturn decode_lockowner(xdr, args);\n}\n\n#endif  \n#ifdef CONFIG_NFS_V4_2\nstatic __be32 decode_write_response(struct xdr_stream *xdr,\n\t\t\t\t\tstruct cb_offloadargs *args)\n{\n\t__be32 *p;\n\n\t \n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\tgoto out;\n\tp++;\n\n\t \n\tp = xdr_inline_decode(xdr, 8 + 4);\n\tif (unlikely(!p))\n\t\tgoto out;\n\tp = xdr_decode_hyper(p, &args->wr_count);\n\targs->wr_writeverf.committed = be32_to_cpup(p);\n\tp = xdr_inline_decode(xdr, NFS4_VERIFIER_SIZE);\n\tif (likely(p)) {\n\t\tmemcpy(&args->wr_writeverf.verifier.data[0], p,\n\t\t\tNFS4_VERIFIER_SIZE);\n\t\treturn 0;\n\t}\nout:\n\treturn htonl(NFS4ERR_RESOURCE);\n}\n\nstatic __be32 decode_offload_args(struct svc_rqst *rqstp,\n\t\t\t\t\tstruct xdr_stream *xdr,\n\t\t\t\t\tvoid *data)\n{\n\tstruct cb_offloadargs *args = data;\n\t__be32 *p;\n\t__be32 status;\n\n\t \n\tstatus = decode_fh(xdr, &args->coa_fh);\n\tif (unlikely(status != 0))\n\t\treturn status;\n\n\t \n\tstatus = decode_stateid(xdr, &args->coa_stateid);\n\tif (unlikely(status != 0))\n\t\treturn status;\n\n\t \n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\tgoto out;\n\targs->error = ntohl(*p++);\n\tif (!args->error) {\n\t\tstatus = decode_write_response(xdr, args);\n\t\tif (unlikely(status != 0))\n\t\t\treturn status;\n\t} else {\n\t\tp = xdr_inline_decode(xdr, 8);\n\t\tif (unlikely(!p))\n\t\t\tgoto out;\n\t\tp = xdr_decode_hyper(p, &args->wr_count);\n\t}\n\treturn 0;\nout:\n\treturn htonl(NFS4ERR_RESOURCE);\n}\n#endif  \nstatic __be32 encode_string(struct xdr_stream *xdr, unsigned int len, const char *str)\n{\n\tif (unlikely(xdr_stream_encode_opaque(xdr, str, len) < 0))\n\t\treturn cpu_to_be32(NFS4ERR_RESOURCE);\n\treturn 0;\n}\n\nstatic __be32 encode_attr_bitmap(struct xdr_stream *xdr, const uint32_t *bitmap, size_t sz)\n{\n\tif (xdr_stream_encode_uint32_array(xdr, bitmap, sz) < 0)\n\t\treturn cpu_to_be32(NFS4ERR_RESOURCE);\n\treturn 0;\n}\n\nstatic __be32 encode_attr_change(struct xdr_stream *xdr, const uint32_t *bitmap, uint64_t change)\n{\n\t__be32 *p;\n\n\tif (!(bitmap[0] & FATTR4_WORD0_CHANGE))\n\t\treturn 0;\n\tp = xdr_reserve_space(xdr, 8);\n\tif (unlikely(!p))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\tp = xdr_encode_hyper(p, change);\n\treturn 0;\n}\n\nstatic __be32 encode_attr_size(struct xdr_stream *xdr, const uint32_t *bitmap, uint64_t size)\n{\n\t__be32 *p;\n\n\tif (!(bitmap[0] & FATTR4_WORD0_SIZE))\n\t\treturn 0;\n\tp = xdr_reserve_space(xdr, 8);\n\tif (unlikely(!p))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\tp = xdr_encode_hyper(p, size);\n\treturn 0;\n}\n\nstatic __be32 encode_attr_time(struct xdr_stream *xdr, const struct timespec64 *time)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 12);\n\tif (unlikely(!p))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\tp = xdr_encode_hyper(p, time->tv_sec);\n\t*p = htonl(time->tv_nsec);\n\treturn 0;\n}\n\nstatic __be32 encode_attr_ctime(struct xdr_stream *xdr, const uint32_t *bitmap, const struct timespec64 *time)\n{\n\tif (!(bitmap[1] & FATTR4_WORD1_TIME_METADATA))\n\t\treturn 0;\n\treturn encode_attr_time(xdr,time);\n}\n\nstatic __be32 encode_attr_mtime(struct xdr_stream *xdr, const uint32_t *bitmap, const struct timespec64 *time)\n{\n\tif (!(bitmap[1] & FATTR4_WORD1_TIME_MODIFY))\n\t\treturn 0;\n\treturn encode_attr_time(xdr,time);\n}\n\nstatic __be32 encode_compound_hdr_res(struct xdr_stream *xdr, struct cb_compound_hdr_res *hdr)\n{\n\t__be32 status;\n\n\thdr->status = xdr_reserve_space(xdr, 4);\n\tif (unlikely(hdr->status == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\tstatus = encode_string(xdr, hdr->taglen, hdr->tag);\n\tif (unlikely(status != 0))\n\t\treturn status;\n\thdr->nops = xdr_reserve_space(xdr, 4);\n\tif (unlikely(hdr->nops == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\treturn 0;\n}\n\nstatic __be32 encode_op_hdr(struct xdr_stream *xdr, uint32_t op, __be32 res)\n{\n\t__be32 *p;\n\t\n\tp = xdr_reserve_space(xdr, 8);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE_HDR);\n\t*p++ = htonl(op);\n\t*p = res;\n\treturn 0;\n}\n\nstatic __be32 encode_getattr_res(struct svc_rqst *rqstp, struct xdr_stream *xdr,\n\t\tconst void *resp)\n{\n\tconst struct cb_getattrres *res = resp;\n\t__be32 *savep = NULL;\n\t__be32 status = res->status;\n\t\n\tif (unlikely(status != 0))\n\t\tgoto out;\n\tstatus = encode_attr_bitmap(xdr, res->bitmap, ARRAY_SIZE(res->bitmap));\n\tif (unlikely(status != 0))\n\t\tgoto out;\n\tstatus = cpu_to_be32(NFS4ERR_RESOURCE);\n\tsavep = xdr_reserve_space(xdr, sizeof(*savep));\n\tif (unlikely(!savep))\n\t\tgoto out;\n\tstatus = encode_attr_change(xdr, res->bitmap, res->change_attr);\n\tif (unlikely(status != 0))\n\t\tgoto out;\n\tstatus = encode_attr_size(xdr, res->bitmap, res->size);\n\tif (unlikely(status != 0))\n\t\tgoto out;\n\tstatus = encode_attr_ctime(xdr, res->bitmap, &res->ctime);\n\tif (unlikely(status != 0))\n\t\tgoto out;\n\tstatus = encode_attr_mtime(xdr, res->bitmap, &res->mtime);\n\t*savep = htonl((unsigned int)((char *)xdr->p - (char *)(savep+1)));\nout:\n\treturn status;\n}\n\n#if defined(CONFIG_NFS_V4_1)\n\nstatic __be32 encode_sessionid(struct xdr_stream *xdr,\n\t\t\t\t const struct nfs4_sessionid *sid)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, NFS4_MAX_SESSIONID_LEN);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\n\tmemcpy(p, sid, NFS4_MAX_SESSIONID_LEN);\n\treturn 0;\n}\n\nstatic __be32 encode_cb_sequence_res(struct svc_rqst *rqstp,\n\t\t\t\t       struct xdr_stream *xdr,\n\t\t\t\t       const void *resp)\n{\n\tconst struct cb_sequenceres *res = resp;\n\t__be32 *p;\n\t__be32 status = res->csr_status;\n\n\tif (unlikely(status != 0))\n\t\treturn status;\n\n\tstatus = encode_sessionid(xdr, &res->csr_sessionid);\n\tif (status)\n\t\treturn status;\n\n\tp = xdr_reserve_space(xdr, 4 * sizeof(uint32_t));\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\n\t*p++ = htonl(res->csr_sequenceid);\n\t*p++ = htonl(res->csr_slotid);\n\t*p++ = htonl(res->csr_highestslotid);\n\t*p++ = htonl(res->csr_target_highestslotid);\n\treturn 0;\n}\n\nstatic __be32\npreprocess_nfs41_op(int nop, unsigned int op_nr, struct callback_op **op)\n{\n\tif (op_nr == OP_CB_SEQUENCE) {\n\t\tif (nop != 0)\n\t\t\treturn htonl(NFS4ERR_SEQUENCE_POS);\n\t} else {\n\t\tif (nop == 0)\n\t\t\treturn htonl(NFS4ERR_OP_NOT_IN_SESSION);\n\t}\n\n\tswitch (op_nr) {\n\tcase OP_CB_GETATTR:\n\tcase OP_CB_RECALL:\n\tcase OP_CB_SEQUENCE:\n\tcase OP_CB_RECALL_ANY:\n\tcase OP_CB_RECALL_SLOT:\n\tcase OP_CB_LAYOUTRECALL:\n\tcase OP_CB_NOTIFY_DEVICEID:\n\tcase OP_CB_NOTIFY_LOCK:\n\t\t*op = &callback_ops[op_nr];\n\t\tbreak;\n\n\tcase OP_CB_NOTIFY:\n\tcase OP_CB_PUSH_DELEG:\n\tcase OP_CB_RECALLABLE_OBJ_AVAIL:\n\tcase OP_CB_WANTS_CANCELLED:\n\t\treturn htonl(NFS4ERR_NOTSUPP);\n\n\tdefault:\n\t\treturn htonl(NFS4ERR_OP_ILLEGAL);\n\t}\n\n\treturn htonl(NFS_OK);\n}\n\nstatic void nfs4_callback_free_slot(struct nfs4_session *session,\n\t\tstruct nfs4_slot *slot)\n{\n\tstruct nfs4_slot_table *tbl = &session->bc_slot_table;\n\n\tspin_lock(&tbl->slot_tbl_lock);\n\t \n\tnfs4_free_slot(tbl, slot);\n\tspin_unlock(&tbl->slot_tbl_lock);\n}\n\nstatic void nfs4_cb_free_slot(struct cb_process_state *cps)\n{\n\tif (cps->slot) {\n\t\tnfs4_callback_free_slot(cps->clp->cl_session, cps->slot);\n\t\tcps->slot = NULL;\n\t}\n}\n\n#else  \n\nstatic __be32\npreprocess_nfs41_op(int nop, unsigned int op_nr, struct callback_op **op)\n{\n\treturn htonl(NFS4ERR_MINOR_VERS_MISMATCH);\n}\n\nstatic void nfs4_cb_free_slot(struct cb_process_state *cps)\n{\n}\n#endif  \n\n#ifdef CONFIG_NFS_V4_2\nstatic __be32\npreprocess_nfs42_op(int nop, unsigned int op_nr, struct callback_op **op)\n{\n\t__be32 status = preprocess_nfs41_op(nop, op_nr, op);\n\tif (status != htonl(NFS4ERR_OP_ILLEGAL))\n\t\treturn status;\n\n\tif (op_nr == OP_CB_OFFLOAD) {\n\t\t*op = &callback_ops[op_nr];\n\t\treturn htonl(NFS_OK);\n\t} else\n\t\treturn htonl(NFS4ERR_NOTSUPP);\n\treturn htonl(NFS4ERR_OP_ILLEGAL);\n}\n#else  \nstatic __be32\npreprocess_nfs42_op(int nop, unsigned int op_nr, struct callback_op **op)\n{\n\treturn htonl(NFS4ERR_MINOR_VERS_MISMATCH);\n}\n#endif  \n\nstatic __be32\npreprocess_nfs4_op(unsigned int op_nr, struct callback_op **op)\n{\n\tswitch (op_nr) {\n\tcase OP_CB_GETATTR:\n\tcase OP_CB_RECALL:\n\t\t*op = &callback_ops[op_nr];\n\t\tbreak;\n\tdefault:\n\t\treturn htonl(NFS4ERR_OP_ILLEGAL);\n\t}\n\n\treturn htonl(NFS_OK);\n}\n\nstatic __be32 process_op(int nop, struct svc_rqst *rqstp,\n\t\t\t struct cb_process_state *cps)\n{\n\tstruct xdr_stream *xdr_out = &rqstp->rq_res_stream;\n\tstruct callback_op *op = &callback_ops[0];\n\tunsigned int op_nr;\n\t__be32 status;\n\tlong maxlen;\n\t__be32 res;\n\n\tstatus = decode_op_hdr(&rqstp->rq_arg_stream, &op_nr);\n\tif (unlikely(status))\n\t\treturn status;\n\n\tswitch (cps->minorversion) {\n\tcase 0:\n\t\tstatus = preprocess_nfs4_op(op_nr, &op);\n\t\tbreak;\n\tcase 1:\n\t\tstatus = preprocess_nfs41_op(nop, op_nr, &op);\n\t\tbreak;\n\tcase 2:\n\t\tstatus = preprocess_nfs42_op(nop, op_nr, &op);\n\t\tbreak;\n\tdefault:\n\t\tstatus = htonl(NFS4ERR_MINOR_VERS_MISMATCH);\n\t}\n\n\tif (status == htonl(NFS4ERR_OP_ILLEGAL))\n\t\top_nr = OP_CB_ILLEGAL;\n\tif (status)\n\t\tgoto encode_hdr;\n\n\tif (cps->drc_status) {\n\t\tstatus = cps->drc_status;\n\t\tgoto encode_hdr;\n\t}\n\n\tmaxlen = xdr_out->end - xdr_out->p;\n\tif (maxlen > 0 && maxlen < PAGE_SIZE) {\n\t\tstatus = op->decode_args(rqstp, &rqstp->rq_arg_stream,\n\t\t\t\t\t rqstp->rq_argp);\n\t\tif (likely(status == 0))\n\t\t\tstatus = op->process_op(rqstp->rq_argp, rqstp->rq_resp,\n\t\t\t\t\t\tcps);\n\t} else\n\t\tstatus = htonl(NFS4ERR_RESOURCE);\n\nencode_hdr:\n\tres = encode_op_hdr(xdr_out, op_nr, status);\n\tif (unlikely(res))\n\t\treturn res;\n\tif (op->encode_res != NULL && status == 0)\n\t\tstatus = op->encode_res(rqstp, xdr_out, rqstp->rq_resp);\n\treturn status;\n}\n\n \nstatic __be32 nfs4_callback_compound(struct svc_rqst *rqstp)\n{\n\tstruct cb_compound_hdr_arg hdr_arg = { 0 };\n\tstruct cb_compound_hdr_res hdr_res = { NULL };\n\tstruct cb_process_state cps = {\n\t\t.drc_status = 0,\n\t\t.clp = NULL,\n\t\t.net = SVC_NET(rqstp),\n\t};\n\tunsigned int nops = 0;\n\t__be32 status;\n\n\tstatus = decode_compound_hdr_arg(&rqstp->rq_arg_stream, &hdr_arg);\n\tif (status == htonl(NFS4ERR_RESOURCE))\n\t\treturn rpc_garbage_args;\n\n\tif (hdr_arg.minorversion == 0) {\n\t\tcps.clp = nfs4_find_client_ident(SVC_NET(rqstp), hdr_arg.cb_ident);\n\t\tif (!cps.clp) {\n\t\t\ttrace_nfs_cb_no_clp(rqstp->rq_xid, hdr_arg.cb_ident);\n\t\t\tgoto out_invalidcred;\n\t\t}\n\t\tif (!check_gss_callback_principal(cps.clp, rqstp)) {\n\t\t\ttrace_nfs_cb_badprinc(rqstp->rq_xid, hdr_arg.cb_ident);\n\t\t\tnfs_put_client(cps.clp);\n\t\t\tgoto out_invalidcred;\n\t\t}\n\t}\n\n\tcps.minorversion = hdr_arg.minorversion;\n\thdr_res.taglen = hdr_arg.taglen;\n\thdr_res.tag = hdr_arg.tag;\n\tif (encode_compound_hdr_res(&rqstp->rq_res_stream, &hdr_res) != 0) {\n\t\tif (cps.clp)\n\t\t\tnfs_put_client(cps.clp);\n\t\treturn rpc_system_err;\n\t}\n\twhile (status == 0 && nops != hdr_arg.nops) {\n\t\tstatus = process_op(nops, rqstp, &cps);\n\t\tnops++;\n\t}\n\n\t \n\tif (unlikely(status == htonl(NFS4ERR_RESOURCE_HDR))) {\n\t\tstatus = htonl(NFS4ERR_RESOURCE);\n\t\tnops--;\n\t}\n\n\t*hdr_res.status = status;\n\t*hdr_res.nops = htonl(nops);\n\tnfs4_cb_free_slot(&cps);\n\tnfs_put_client(cps.clp);\n\treturn rpc_success;\n\nout_invalidcred:\n\tpr_warn_ratelimited(\"NFS: NFSv4 callback contains invalid cred\\n\");\n\trqstp->rq_auth_stat = rpc_autherr_badcred;\n\treturn rpc_success;\n}\n\nstatic int\nnfs_callback_dispatch(struct svc_rqst *rqstp)\n{\n\tconst struct svc_procedure *procp = rqstp->rq_procinfo;\n\n\t*rqstp->rq_accept_statp = procp->pc_func(rqstp);\n\treturn 1;\n}\n\n \nstatic struct callback_op callback_ops[] = {\n\t[0] = {\n\t\t.res_maxsize = CB_OP_HDR_RES_MAXSZ,\n\t},\n\t[OP_CB_GETATTR] = {\n\t\t.process_op = nfs4_callback_getattr,\n\t\t.decode_args = decode_getattr_args,\n\t\t.encode_res = encode_getattr_res,\n\t\t.res_maxsize = CB_OP_GETATTR_RES_MAXSZ,\n\t},\n\t[OP_CB_RECALL] = {\n\t\t.process_op = nfs4_callback_recall,\n\t\t.decode_args = decode_recall_args,\n\t\t.res_maxsize = CB_OP_RECALL_RES_MAXSZ,\n\t},\n#if defined(CONFIG_NFS_V4_1)\n\t[OP_CB_LAYOUTRECALL] = {\n\t\t.process_op = nfs4_callback_layoutrecall,\n\t\t.decode_args = decode_layoutrecall_args,\n\t\t.res_maxsize = CB_OP_LAYOUTRECALL_RES_MAXSZ,\n\t},\n\t[OP_CB_NOTIFY_DEVICEID] = {\n\t\t.process_op = nfs4_callback_devicenotify,\n\t\t.decode_args = decode_devicenotify_args,\n\t\t.res_maxsize = CB_OP_DEVICENOTIFY_RES_MAXSZ,\n\t},\n\t[OP_CB_SEQUENCE] = {\n\t\t.process_op = nfs4_callback_sequence,\n\t\t.decode_args = decode_cb_sequence_args,\n\t\t.encode_res = encode_cb_sequence_res,\n\t\t.res_maxsize = CB_OP_SEQUENCE_RES_MAXSZ,\n\t},\n\t[OP_CB_RECALL_ANY] = {\n\t\t.process_op = nfs4_callback_recallany,\n\t\t.decode_args = decode_recallany_args,\n\t\t.res_maxsize = CB_OP_RECALLANY_RES_MAXSZ,\n\t},\n\t[OP_CB_RECALL_SLOT] = {\n\t\t.process_op = nfs4_callback_recallslot,\n\t\t.decode_args = decode_recallslot_args,\n\t\t.res_maxsize = CB_OP_RECALLSLOT_RES_MAXSZ,\n\t},\n\t[OP_CB_NOTIFY_LOCK] = {\n\t\t.process_op = nfs4_callback_notify_lock,\n\t\t.decode_args = decode_notify_lock_args,\n\t\t.res_maxsize = CB_OP_NOTIFY_LOCK_RES_MAXSZ,\n\t},\n#endif  \n#ifdef CONFIG_NFS_V4_2\n\t[OP_CB_OFFLOAD] = {\n\t\t.process_op = nfs4_callback_offload,\n\t\t.decode_args = decode_offload_args,\n\t\t.res_maxsize = CB_OP_OFFLOAD_RES_MAXSZ,\n\t},\n#endif  \n};\n\n \nstatic const struct svc_procedure nfs4_callback_procedures1[] = {\n\t[CB_NULL] = {\n\t\t.pc_func = nfs4_callback_null,\n\t\t.pc_encode = nfs4_encode_void,\n\t\t.pc_xdrressize = 1,\n\t\t.pc_name = \"NULL\",\n\t},\n\t[CB_COMPOUND] = {\n\t\t.pc_func = nfs4_callback_compound,\n\t\t.pc_encode = nfs4_encode_void,\n\t\t.pc_argsize = 256,\n\t\t.pc_argzero = 256,\n\t\t.pc_ressize = 256,\n\t\t.pc_xdrressize = NFS4_CALLBACK_BUFSIZE,\n\t\t.pc_name = \"COMPOUND\",\n\t}\n};\n\nstatic DEFINE_PER_CPU_ALIGNED(unsigned long,\n\t\t\t      nfs4_callback_count1[ARRAY_SIZE(nfs4_callback_procedures1)]);\nconst struct svc_version nfs4_callback_version1 = {\n\t.vs_vers = 1,\n\t.vs_nproc = ARRAY_SIZE(nfs4_callback_procedures1),\n\t.vs_proc = nfs4_callback_procedures1,\n\t.vs_count = nfs4_callback_count1,\n\t.vs_xdrsize = NFS4_CALLBACK_XDRSIZE,\n\t.vs_dispatch = nfs_callback_dispatch,\n\t.vs_hidden = true,\n\t.vs_need_cong_ctrl = true,\n};\n\nstatic DEFINE_PER_CPU_ALIGNED(unsigned long,\n\t\t\t      nfs4_callback_count4[ARRAY_SIZE(nfs4_callback_procedures1)]);\nconst struct svc_version nfs4_callback_version4 = {\n\t.vs_vers = 4,\n\t.vs_nproc = ARRAY_SIZE(nfs4_callback_procedures1),\n\t.vs_proc = nfs4_callback_procedures1,\n\t.vs_count = nfs4_callback_count4,\n\t.vs_xdrsize = NFS4_CALLBACK_XDRSIZE,\n\t.vs_dispatch = nfs_callback_dispatch,\n\t.vs_hidden = true,\n\t.vs_need_cong_ctrl = true,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}