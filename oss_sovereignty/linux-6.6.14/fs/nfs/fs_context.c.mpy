{
  "module_name": "fs_context.c",
  "hash_id": "0e80cbdcbcac1e8185679e7b2d086d1c746db9f593ff3c242a51b18a363fb50a",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfs/fs_context.c",
  "human_readable_source": "\n \n\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/fs_context.h>\n#include <linux/fs_parser.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs4_mount.h>\n\n#include <net/handshake.h>\n\n#include \"nfs.h\"\n#include \"internal.h\"\n\n#include \"nfstrace.h\"\n\n#define NFSDBG_FACILITY\t\tNFSDBG_MOUNT\n\n#if IS_ENABLED(CONFIG_NFS_V3)\n#define NFS_DEFAULT_VERSION 3\n#else\n#define NFS_DEFAULT_VERSION 2\n#endif\n\n#define NFS_MAX_CONNECTIONS 16\n\nenum nfs_param {\n\tOpt_ac,\n\tOpt_acdirmax,\n\tOpt_acdirmin,\n\tOpt_acl,\n\tOpt_acregmax,\n\tOpt_acregmin,\n\tOpt_actimeo,\n\tOpt_addr,\n\tOpt_bg,\n\tOpt_bsize,\n\tOpt_clientaddr,\n\tOpt_cto,\n\tOpt_fg,\n\tOpt_fscache,\n\tOpt_fscache_flag,\n\tOpt_hard,\n\tOpt_intr,\n\tOpt_local_lock,\n\tOpt_lock,\n\tOpt_lookupcache,\n\tOpt_migration,\n\tOpt_minorversion,\n\tOpt_mountaddr,\n\tOpt_mounthost,\n\tOpt_mountport,\n\tOpt_mountproto,\n\tOpt_mountvers,\n\tOpt_namelen,\n\tOpt_nconnect,\n\tOpt_max_connect,\n\tOpt_port,\n\tOpt_posix,\n\tOpt_proto,\n\tOpt_rdirplus,\n\tOpt_rdma,\n\tOpt_resvport,\n\tOpt_retrans,\n\tOpt_retry,\n\tOpt_rsize,\n\tOpt_sec,\n\tOpt_sharecache,\n\tOpt_sloppy,\n\tOpt_soft,\n\tOpt_softerr,\n\tOpt_softreval,\n\tOpt_source,\n\tOpt_tcp,\n\tOpt_timeo,\n\tOpt_trunkdiscovery,\n\tOpt_udp,\n\tOpt_v,\n\tOpt_vers,\n\tOpt_wsize,\n\tOpt_write,\n\tOpt_xprtsec,\n};\n\nenum {\n\tOpt_local_lock_all,\n\tOpt_local_lock_flock,\n\tOpt_local_lock_none,\n\tOpt_local_lock_posix,\n};\n\nstatic const struct constant_table nfs_param_enums_local_lock[] = {\n\t{ \"all\",\t\tOpt_local_lock_all },\n\t{ \"flock\",\tOpt_local_lock_flock },\n\t{ \"posix\",\tOpt_local_lock_posix },\n\t{ \"none\",\t\tOpt_local_lock_none },\n\t{}\n};\n\nenum {\n\tOpt_lookupcache_all,\n\tOpt_lookupcache_none,\n\tOpt_lookupcache_positive,\n};\n\nstatic const struct constant_table nfs_param_enums_lookupcache[] = {\n\t{ \"all\",\t\tOpt_lookupcache_all },\n\t{ \"none\",\t\tOpt_lookupcache_none },\n\t{ \"pos\",\t\tOpt_lookupcache_positive },\n\t{ \"positive\",\t\tOpt_lookupcache_positive },\n\t{}\n};\n\nenum {\n\tOpt_write_lazy,\n\tOpt_write_eager,\n\tOpt_write_wait,\n};\n\nstatic const struct constant_table nfs_param_enums_write[] = {\n\t{ \"lazy\",\t\tOpt_write_lazy },\n\t{ \"eager\",\t\tOpt_write_eager },\n\t{ \"wait\",\t\tOpt_write_wait },\n\t{}\n};\n\nstatic const struct fs_parameter_spec nfs_fs_parameters[] = {\n\tfsparam_flag_no(\"ac\",\t\tOpt_ac),\n\tfsparam_u32   (\"acdirmax\",\tOpt_acdirmax),\n\tfsparam_u32   (\"acdirmin\",\tOpt_acdirmin),\n\tfsparam_flag_no(\"acl\",\t\tOpt_acl),\n\tfsparam_u32   (\"acregmax\",\tOpt_acregmax),\n\tfsparam_u32   (\"acregmin\",\tOpt_acregmin),\n\tfsparam_u32   (\"actimeo\",\tOpt_actimeo),\n\tfsparam_string(\"addr\",\t\tOpt_addr),\n\tfsparam_flag  (\"bg\",\t\tOpt_bg),\n\tfsparam_u32   (\"bsize\",\t\tOpt_bsize),\n\tfsparam_string(\"clientaddr\",\tOpt_clientaddr),\n\tfsparam_flag_no(\"cto\",\t\tOpt_cto),\n\tfsparam_flag  (\"fg\",\t\tOpt_fg),\n\tfsparam_flag_no(\"fsc\",\t\tOpt_fscache_flag),\n\tfsparam_string(\"fsc\",\t\tOpt_fscache),\n\tfsparam_flag  (\"hard\",\t\tOpt_hard),\n\t__fsparam(NULL, \"intr\",\t\tOpt_intr,\n\t\t  fs_param_neg_with_no|fs_param_deprecated, NULL),\n\tfsparam_enum  (\"local_lock\",\tOpt_local_lock, nfs_param_enums_local_lock),\n\tfsparam_flag_no(\"lock\",\t\tOpt_lock),\n\tfsparam_enum  (\"lookupcache\",\tOpt_lookupcache, nfs_param_enums_lookupcache),\n\tfsparam_flag_no(\"migration\",\tOpt_migration),\n\tfsparam_u32   (\"minorversion\",\tOpt_minorversion),\n\tfsparam_string(\"mountaddr\",\tOpt_mountaddr),\n\tfsparam_string(\"mounthost\",\tOpt_mounthost),\n\tfsparam_u32   (\"mountport\",\tOpt_mountport),\n\tfsparam_string(\"mountproto\",\tOpt_mountproto),\n\tfsparam_u32   (\"mountvers\",\tOpt_mountvers),\n\tfsparam_u32   (\"namlen\",\tOpt_namelen),\n\tfsparam_u32   (\"nconnect\",\tOpt_nconnect),\n\tfsparam_u32   (\"max_connect\",\tOpt_max_connect),\n\tfsparam_string(\"nfsvers\",\tOpt_vers),\n\tfsparam_u32   (\"port\",\t\tOpt_port),\n\tfsparam_flag_no(\"posix\",\tOpt_posix),\n\tfsparam_string(\"proto\",\t\tOpt_proto),\n\tfsparam_flag_no(\"rdirplus\",\tOpt_rdirplus),\n\tfsparam_flag  (\"rdma\",\t\tOpt_rdma),\n\tfsparam_flag_no(\"resvport\",\tOpt_resvport),\n\tfsparam_u32   (\"retrans\",\tOpt_retrans),\n\tfsparam_string(\"retry\",\t\tOpt_retry),\n\tfsparam_u32   (\"rsize\",\t\tOpt_rsize),\n\tfsparam_string(\"sec\",\t\tOpt_sec),\n\tfsparam_flag_no(\"sharecache\",\tOpt_sharecache),\n\tfsparam_flag  (\"sloppy\",\tOpt_sloppy),\n\tfsparam_flag  (\"soft\",\t\tOpt_soft),\n\tfsparam_flag  (\"softerr\",\tOpt_softerr),\n\tfsparam_flag  (\"softreval\",\tOpt_softreval),\n\tfsparam_string(\"source\",\tOpt_source),\n\tfsparam_flag  (\"tcp\",\t\tOpt_tcp),\n\tfsparam_u32   (\"timeo\",\t\tOpt_timeo),\n\tfsparam_flag_no(\"trunkdiscovery\", Opt_trunkdiscovery),\n\tfsparam_flag  (\"udp\",\t\tOpt_udp),\n\tfsparam_flag  (\"v2\",\t\tOpt_v),\n\tfsparam_flag  (\"v3\",\t\tOpt_v),\n\tfsparam_flag  (\"v4\",\t\tOpt_v),\n\tfsparam_flag  (\"v4.0\",\t\tOpt_v),\n\tfsparam_flag  (\"v4.1\",\t\tOpt_v),\n\tfsparam_flag  (\"v4.2\",\t\tOpt_v),\n\tfsparam_string(\"vers\",\t\tOpt_vers),\n\tfsparam_enum  (\"write\",\t\tOpt_write, nfs_param_enums_write),\n\tfsparam_u32   (\"wsize\",\t\tOpt_wsize),\n\tfsparam_string(\"xprtsec\",\tOpt_xprtsec),\n\t{}\n};\n\nenum {\n\tOpt_vers_2,\n\tOpt_vers_3,\n\tOpt_vers_4,\n\tOpt_vers_4_0,\n\tOpt_vers_4_1,\n\tOpt_vers_4_2,\n};\n\nstatic const struct constant_table nfs_vers_tokens[] = {\n\t{ \"2\",\t\tOpt_vers_2 },\n\t{ \"3\",\t\tOpt_vers_3 },\n\t{ \"4\",\t\tOpt_vers_4 },\n\t{ \"4.0\",\tOpt_vers_4_0 },\n\t{ \"4.1\",\tOpt_vers_4_1 },\n\t{ \"4.2\",\tOpt_vers_4_2 },\n\t{}\n};\n\nenum {\n\tOpt_xprt_rdma,\n\tOpt_xprt_rdma6,\n\tOpt_xprt_tcp,\n\tOpt_xprt_tcp6,\n\tOpt_xprt_udp,\n\tOpt_xprt_udp6,\n\tnr__Opt_xprt\n};\n\nstatic const struct constant_table nfs_xprt_protocol_tokens[] = {\n\t{ \"rdma\",\tOpt_xprt_rdma },\n\t{ \"rdma6\",\tOpt_xprt_rdma6 },\n\t{ \"tcp\",\tOpt_xprt_tcp },\n\t{ \"tcp6\",\tOpt_xprt_tcp6 },\n\t{ \"udp\",\tOpt_xprt_udp },\n\t{ \"udp6\",\tOpt_xprt_udp6 },\n\t{}\n};\n\nenum {\n\tOpt_sec_krb5,\n\tOpt_sec_krb5i,\n\tOpt_sec_krb5p,\n\tOpt_sec_lkey,\n\tOpt_sec_lkeyi,\n\tOpt_sec_lkeyp,\n\tOpt_sec_none,\n\tOpt_sec_spkm,\n\tOpt_sec_spkmi,\n\tOpt_sec_spkmp,\n\tOpt_sec_sys,\n\tnr__Opt_sec\n};\n\nstatic const struct constant_table nfs_secflavor_tokens[] = {\n\t{ \"krb5\",\tOpt_sec_krb5 },\n\t{ \"krb5i\",\tOpt_sec_krb5i },\n\t{ \"krb5p\",\tOpt_sec_krb5p },\n\t{ \"lkey\",\tOpt_sec_lkey },\n\t{ \"lkeyi\",\tOpt_sec_lkeyi },\n\t{ \"lkeyp\",\tOpt_sec_lkeyp },\n\t{ \"none\",\tOpt_sec_none },\n\t{ \"null\",\tOpt_sec_none },\n\t{ \"spkm3\",\tOpt_sec_spkm },\n\t{ \"spkm3i\",\tOpt_sec_spkmi },\n\t{ \"spkm3p\",\tOpt_sec_spkmp },\n\t{ \"sys\",\tOpt_sec_sys },\n\t{}\n};\n\nenum {\n\tOpt_xprtsec_none,\n\tOpt_xprtsec_tls,\n\tOpt_xprtsec_mtls,\n\tnr__Opt_xprtsec\n};\n\nstatic const struct constant_table nfs_xprtsec_policies[] = {\n\t{ \"none\",\tOpt_xprtsec_none },\n\t{ \"tls\",\tOpt_xprtsec_tls },\n\t{ \"mtls\",\tOpt_xprtsec_mtls },\n\t{}\n};\n\n \nstatic int nfs_verify_server_address(struct sockaddr_storage *addr)\n{\n\tswitch (addr->ss_family) {\n\tcase AF_INET: {\n\t\tstruct sockaddr_in *sa = (struct sockaddr_in *)addr;\n\t\treturn sa->sin_addr.s_addr != htonl(INADDR_ANY);\n\t}\n\tcase AF_INET6: {\n\t\tstruct in6_addr *sa = &((struct sockaddr_in6 *)addr)->sin6_addr;\n\t\treturn !ipv6_addr_any(sa);\n\t}\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_NFS_DISABLE_UDP_SUPPORT\nstatic bool nfs_server_transport_udp_invalid(const struct nfs_fs_context *ctx)\n{\n\treturn true;\n}\n#else\nstatic bool nfs_server_transport_udp_invalid(const struct nfs_fs_context *ctx)\n{\n\tif (ctx->version == 4)\n\t\treturn true;\n\treturn false;\n}\n#endif\n\n \nstatic int nfs_validate_transport_protocol(struct fs_context *fc,\n\t\t\t\t\t   struct nfs_fs_context *ctx)\n{\n\tswitch (ctx->nfs_server.protocol) {\n\tcase XPRT_TRANSPORT_UDP:\n\t\tif (nfs_server_transport_udp_invalid(ctx))\n\t\t\tgoto out_invalid_transport_udp;\n\t\tbreak;\n\tcase XPRT_TRANSPORT_TCP:\n\tcase XPRT_TRANSPORT_RDMA:\n\t\tbreak;\n\tdefault:\n\t\tctx->nfs_server.protocol = XPRT_TRANSPORT_TCP;\n\t}\n\n\tif (ctx->xprtsec.policy != RPC_XPRTSEC_NONE)\n\t\tswitch (ctx->nfs_server.protocol) {\n\t\tcase XPRT_TRANSPORT_TCP:\n\t\t\tctx->nfs_server.protocol = XPRT_TRANSPORT_TCP_TLS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto out_invalid_xprtsec_policy;\n\t}\n\n\treturn 0;\nout_invalid_transport_udp:\n\treturn nfs_invalf(fc, \"NFS: Unsupported transport protocol udp\");\nout_invalid_xprtsec_policy:\n\treturn nfs_invalf(fc, \"NFS: Transport does not support xprtsec\");\n}\n\n \nstatic void nfs_set_mount_transport_protocol(struct nfs_fs_context *ctx)\n{\n\tif (ctx->mount_server.protocol == XPRT_TRANSPORT_UDP ||\n\t    ctx->mount_server.protocol == XPRT_TRANSPORT_TCP)\n\t\t\treturn;\n\tswitch (ctx->nfs_server.protocol) {\n\tcase XPRT_TRANSPORT_UDP:\n\t\tctx->mount_server.protocol = XPRT_TRANSPORT_UDP;\n\t\tbreak;\n\tcase XPRT_TRANSPORT_TCP:\n\tcase XPRT_TRANSPORT_RDMA:\n\t\tctx->mount_server.protocol = XPRT_TRANSPORT_TCP;\n\t}\n}\n\n \nstatic int nfs_auth_info_add(struct fs_context *fc,\n\t\t\t     struct nfs_auth_info *auth_info,\n\t\t\t     rpc_authflavor_t flavor)\n{\n\tunsigned int i;\n\tunsigned int max_flavor_len = ARRAY_SIZE(auth_info->flavors);\n\n\t \n\tfor (i = 0; i < auth_info->flavor_len; i++) {\n\t\tif (flavor == auth_info->flavors[i])\n\t\t\treturn 0;\n\t}\n\n\tif (auth_info->flavor_len + 1 >= max_flavor_len)\n\t\treturn nfs_invalf(fc, \"NFS: too many sec= flavors\");\n\n\tauth_info->flavors[auth_info->flavor_len++] = flavor;\n\treturn 0;\n}\n\n \nstatic int nfs_parse_security_flavors(struct fs_context *fc,\n\t\t\t\t      struct fs_parameter *param)\n{\n\tstruct nfs_fs_context *ctx = nfs_fc2context(fc);\n\trpc_authflavor_t pseudoflavor;\n\tchar *string = param->string, *p;\n\tint ret;\n\n\ttrace_nfs_mount_assign(param->key, string);\n\n\twhile ((p = strsep(&string, \":\")) != NULL) {\n\t\tif (!*p)\n\t\t\tcontinue;\n\t\tswitch (lookup_constant(nfs_secflavor_tokens, p, -1)) {\n\t\tcase Opt_sec_none:\n\t\t\tpseudoflavor = RPC_AUTH_NULL;\n\t\t\tbreak;\n\t\tcase Opt_sec_sys:\n\t\t\tpseudoflavor = RPC_AUTH_UNIX;\n\t\t\tbreak;\n\t\tcase Opt_sec_krb5:\n\t\t\tpseudoflavor = RPC_AUTH_GSS_KRB5;\n\t\t\tbreak;\n\t\tcase Opt_sec_krb5i:\n\t\t\tpseudoflavor = RPC_AUTH_GSS_KRB5I;\n\t\t\tbreak;\n\t\tcase Opt_sec_krb5p:\n\t\t\tpseudoflavor = RPC_AUTH_GSS_KRB5P;\n\t\t\tbreak;\n\t\tcase Opt_sec_lkey:\n\t\t\tpseudoflavor = RPC_AUTH_GSS_LKEY;\n\t\t\tbreak;\n\t\tcase Opt_sec_lkeyi:\n\t\t\tpseudoflavor = RPC_AUTH_GSS_LKEYI;\n\t\t\tbreak;\n\t\tcase Opt_sec_lkeyp:\n\t\t\tpseudoflavor = RPC_AUTH_GSS_LKEYP;\n\t\t\tbreak;\n\t\tcase Opt_sec_spkm:\n\t\t\tpseudoflavor = RPC_AUTH_GSS_SPKM;\n\t\t\tbreak;\n\t\tcase Opt_sec_spkmi:\n\t\t\tpseudoflavor = RPC_AUTH_GSS_SPKMI;\n\t\t\tbreak;\n\t\tcase Opt_sec_spkmp:\n\t\t\tpseudoflavor = RPC_AUTH_GSS_SPKMP;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn nfs_invalf(fc, \"NFS: sec=%s option not recognized\", p);\n\t\t}\n\n\t\tret = nfs_auth_info_add(fc, &ctx->auth_info, pseudoflavor);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int nfs_parse_xprtsec_policy(struct fs_context *fc,\n\t\t\t\t    struct fs_parameter *param)\n{\n\tstruct nfs_fs_context *ctx = nfs_fc2context(fc);\n\n\ttrace_nfs_mount_assign(param->key, param->string);\n\n\tswitch (lookup_constant(nfs_xprtsec_policies, param->string, -1)) {\n\tcase Opt_xprtsec_none:\n\t\tctx->xprtsec.policy = RPC_XPRTSEC_NONE;\n\t\tbreak;\n\tcase Opt_xprtsec_tls:\n\t\tctx->xprtsec.policy = RPC_XPRTSEC_TLS_ANON;\n\t\tbreak;\n\tcase Opt_xprtsec_mtls:\n\t\tctx->xprtsec.policy = RPC_XPRTSEC_TLS_X509;\n\t\tbreak;\n\tdefault:\n\t\treturn nfs_invalf(fc, \"NFS: Unrecognized transport security policy\");\n\t}\n\treturn 0;\n}\n\nstatic int nfs_parse_version_string(struct fs_context *fc,\n\t\t\t\t    const char *string)\n{\n\tstruct nfs_fs_context *ctx = nfs_fc2context(fc);\n\n\tctx->flags &= ~NFS_MOUNT_VER3;\n\tswitch (lookup_constant(nfs_vers_tokens, string, -1)) {\n\tcase Opt_vers_2:\n\t\tctx->version = 2;\n\t\tbreak;\n\tcase Opt_vers_3:\n\t\tctx->flags |= NFS_MOUNT_VER3;\n\t\tctx->version = 3;\n\t\tbreak;\n\tcase Opt_vers_4:\n\t\t \n\t\tctx->version = 4;\n\t\tbreak;\n\tcase Opt_vers_4_0:\n\t\tctx->version = 4;\n\t\tctx->minorversion = 0;\n\t\tbreak;\n\tcase Opt_vers_4_1:\n\t\tctx->version = 4;\n\t\tctx->minorversion = 1;\n\t\tbreak;\n\tcase Opt_vers_4_2:\n\t\tctx->version = 4;\n\t\tctx->minorversion = 2;\n\t\tbreak;\n\tdefault:\n\t\treturn nfs_invalf(fc, \"NFS: Unsupported NFS version\");\n\t}\n\treturn 0;\n}\n\n \nstatic int nfs_fs_context_parse_param(struct fs_context *fc,\n\t\t\t\t      struct fs_parameter *param)\n{\n\tstruct fs_parse_result result;\n\tstruct nfs_fs_context *ctx = nfs_fc2context(fc);\n\tunsigned short protofamily, mountfamily;\n\tunsigned int len;\n\tint ret, opt;\n\n\ttrace_nfs_mount_option(param);\n\n\topt = fs_parse(fc, nfs_fs_parameters, param, &result);\n\tif (opt < 0)\n\t\treturn (opt == -ENOPARAM && ctx->sloppy) ? 1 : opt;\n\n\tif (fc->security)\n\t\tctx->has_sec_mnt_opts = 1;\n\n\tswitch (opt) {\n\tcase Opt_source:\n\t\tif (fc->source)\n\t\t\treturn nfs_invalf(fc, \"NFS: Multiple sources not supported\");\n\t\tfc->source = param->string;\n\t\tparam->string = NULL;\n\t\tbreak;\n\n\t\t \n\tcase Opt_soft:\n\t\tctx->flags |= NFS_MOUNT_SOFT;\n\t\tctx->flags &= ~NFS_MOUNT_SOFTERR;\n\t\tbreak;\n\tcase Opt_softerr:\n\t\tctx->flags |= NFS_MOUNT_SOFTERR | NFS_MOUNT_SOFTREVAL;\n\t\tctx->flags &= ~NFS_MOUNT_SOFT;\n\t\tbreak;\n\tcase Opt_hard:\n\t\tctx->flags &= ~(NFS_MOUNT_SOFT |\n\t\t\t\tNFS_MOUNT_SOFTERR |\n\t\t\t\tNFS_MOUNT_SOFTREVAL);\n\t\tbreak;\n\tcase Opt_softreval:\n\t\tif (result.negated)\n\t\t\tctx->flags &= ~NFS_MOUNT_SOFTREVAL;\n\t\telse\n\t\t\tctx->flags |= NFS_MOUNT_SOFTREVAL;\n\t\tbreak;\n\tcase Opt_posix:\n\t\tif (result.negated)\n\t\t\tctx->flags &= ~NFS_MOUNT_POSIX;\n\t\telse\n\t\t\tctx->flags |= NFS_MOUNT_POSIX;\n\t\tbreak;\n\tcase Opt_cto:\n\t\tif (result.negated)\n\t\t\tctx->flags |= NFS_MOUNT_NOCTO;\n\t\telse\n\t\t\tctx->flags &= ~NFS_MOUNT_NOCTO;\n\t\tbreak;\n\tcase Opt_trunkdiscovery:\n\t\tif (result.negated)\n\t\t\tctx->flags &= ~NFS_MOUNT_TRUNK_DISCOVERY;\n\t\telse\n\t\t\tctx->flags |= NFS_MOUNT_TRUNK_DISCOVERY;\n\t\tbreak;\n\tcase Opt_ac:\n\t\tif (result.negated)\n\t\t\tctx->flags |= NFS_MOUNT_NOAC;\n\t\telse\n\t\t\tctx->flags &= ~NFS_MOUNT_NOAC;\n\t\tbreak;\n\tcase Opt_lock:\n\t\tif (result.negated) {\n\t\t\tctx->flags |= NFS_MOUNT_NONLM;\n\t\t\tctx->flags |= (NFS_MOUNT_LOCAL_FLOCK | NFS_MOUNT_LOCAL_FCNTL);\n\t\t} else {\n\t\t\tctx->flags &= ~NFS_MOUNT_NONLM;\n\t\t\tctx->flags &= ~(NFS_MOUNT_LOCAL_FLOCK | NFS_MOUNT_LOCAL_FCNTL);\n\t\t}\n\t\tbreak;\n\tcase Opt_udp:\n\t\tctx->flags &= ~NFS_MOUNT_TCP;\n\t\tctx->nfs_server.protocol = XPRT_TRANSPORT_UDP;\n\t\tbreak;\n\tcase Opt_tcp:\n\tcase Opt_rdma:\n\t\tctx->flags |= NFS_MOUNT_TCP;  \n\t\tret = xprt_find_transport_ident(param->key);\n\t\tif (ret < 0)\n\t\t\tgoto out_bad_transport;\n\t\tctx->nfs_server.protocol = ret;\n\t\tbreak;\n\tcase Opt_acl:\n\t\tif (result.negated)\n\t\t\tctx->flags |= NFS_MOUNT_NOACL;\n\t\telse\n\t\t\tctx->flags &= ~NFS_MOUNT_NOACL;\n\t\tbreak;\n\tcase Opt_rdirplus:\n\t\tif (result.negated)\n\t\t\tctx->flags |= NFS_MOUNT_NORDIRPLUS;\n\t\telse\n\t\t\tctx->flags &= ~NFS_MOUNT_NORDIRPLUS;\n\t\tbreak;\n\tcase Opt_sharecache:\n\t\tif (result.negated)\n\t\t\tctx->flags |= NFS_MOUNT_UNSHARED;\n\t\telse\n\t\t\tctx->flags &= ~NFS_MOUNT_UNSHARED;\n\t\tbreak;\n\tcase Opt_resvport:\n\t\tif (result.negated)\n\t\t\tctx->flags |= NFS_MOUNT_NORESVPORT;\n\t\telse\n\t\t\tctx->flags &= ~NFS_MOUNT_NORESVPORT;\n\t\tbreak;\n\tcase Opt_fscache_flag:\n\t\tif (result.negated)\n\t\t\tctx->options &= ~NFS_OPTION_FSCACHE;\n\t\telse\n\t\t\tctx->options |= NFS_OPTION_FSCACHE;\n\t\tkfree(ctx->fscache_uniq);\n\t\tctx->fscache_uniq = NULL;\n\t\tbreak;\n\tcase Opt_fscache:\n\t\tctx->options |= NFS_OPTION_FSCACHE;\n\t\tkfree(ctx->fscache_uniq);\n\t\tctx->fscache_uniq = param->string;\n\t\tparam->string = NULL;\n\t\tbreak;\n\tcase Opt_migration:\n\t\tif (result.negated)\n\t\t\tctx->options &= ~NFS_OPTION_MIGRATION;\n\t\telse\n\t\t\tctx->options |= NFS_OPTION_MIGRATION;\n\t\tbreak;\n\n\t\t \n\tcase Opt_port:\n\t\tif (result.uint_32 > USHRT_MAX)\n\t\t\tgoto out_of_bounds;\n\t\tctx->nfs_server.port = result.uint_32;\n\t\tbreak;\n\tcase Opt_rsize:\n\t\tctx->rsize = result.uint_32;\n\t\tbreak;\n\tcase Opt_wsize:\n\t\tctx->wsize = result.uint_32;\n\t\tbreak;\n\tcase Opt_bsize:\n\t\tctx->bsize = result.uint_32;\n\t\tbreak;\n\tcase Opt_timeo:\n\t\tif (result.uint_32 < 1 || result.uint_32 > INT_MAX)\n\t\t\tgoto out_of_bounds;\n\t\tctx->timeo = result.uint_32;\n\t\tbreak;\n\tcase Opt_retrans:\n\t\tif (result.uint_32 > INT_MAX)\n\t\t\tgoto out_of_bounds;\n\t\tctx->retrans = result.uint_32;\n\t\tbreak;\n\tcase Opt_acregmin:\n\t\tctx->acregmin = result.uint_32;\n\t\tbreak;\n\tcase Opt_acregmax:\n\t\tctx->acregmax = result.uint_32;\n\t\tbreak;\n\tcase Opt_acdirmin:\n\t\tctx->acdirmin = result.uint_32;\n\t\tbreak;\n\tcase Opt_acdirmax:\n\t\tctx->acdirmax = result.uint_32;\n\t\tbreak;\n\tcase Opt_actimeo:\n\t\tctx->acregmin = result.uint_32;\n\t\tctx->acregmax = result.uint_32;\n\t\tctx->acdirmin = result.uint_32;\n\t\tctx->acdirmax = result.uint_32;\n\t\tbreak;\n\tcase Opt_namelen:\n\t\tctx->namlen = result.uint_32;\n\t\tbreak;\n\tcase Opt_mountport:\n\t\tif (result.uint_32 > USHRT_MAX)\n\t\t\tgoto out_of_bounds;\n\t\tctx->mount_server.port = result.uint_32;\n\t\tbreak;\n\tcase Opt_mountvers:\n\t\tif (result.uint_32 < NFS_MNT_VERSION ||\n\t\t    result.uint_32 > NFS_MNT3_VERSION)\n\t\t\tgoto out_of_bounds;\n\t\tctx->mount_server.version = result.uint_32;\n\t\tbreak;\n\tcase Opt_minorversion:\n\t\tif (result.uint_32 > NFS4_MAX_MINOR_VERSION)\n\t\t\tgoto out_of_bounds;\n\t\tctx->minorversion = result.uint_32;\n\t\tbreak;\n\n\t\t \n\tcase Opt_v:\n\t\tret = nfs_parse_version_string(fc, param->key + 1);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase Opt_vers:\n\t\tif (!param->string)\n\t\t\tgoto out_invalid_value;\n\t\ttrace_nfs_mount_assign(param->key, param->string);\n\t\tret = nfs_parse_version_string(fc, param->string);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase Opt_sec:\n\t\tret = nfs_parse_security_flavors(fc, param);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase Opt_xprtsec:\n\t\tret = nfs_parse_xprtsec_policy(fc, param);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\n\tcase Opt_proto:\n\t\tif (!param->string)\n\t\t\tgoto out_invalid_value;\n\t\ttrace_nfs_mount_assign(param->key, param->string);\n\t\tprotofamily = AF_INET;\n\t\tswitch (lookup_constant(nfs_xprt_protocol_tokens, param->string, -1)) {\n\t\tcase Opt_xprt_udp6:\n\t\t\tprotofamily = AF_INET6;\n\t\t\tfallthrough;\n\t\tcase Opt_xprt_udp:\n\t\t\tctx->flags &= ~NFS_MOUNT_TCP;\n\t\t\tctx->nfs_server.protocol = XPRT_TRANSPORT_UDP;\n\t\t\tbreak;\n\t\tcase Opt_xprt_tcp6:\n\t\t\tprotofamily = AF_INET6;\n\t\t\tfallthrough;\n\t\tcase Opt_xprt_tcp:\n\t\t\tctx->flags |= NFS_MOUNT_TCP;\n\t\t\tctx->nfs_server.protocol = XPRT_TRANSPORT_TCP;\n\t\t\tbreak;\n\t\tcase Opt_xprt_rdma6:\n\t\t\tprotofamily = AF_INET6;\n\t\t\tfallthrough;\n\t\tcase Opt_xprt_rdma:\n\t\t\t \n\t\t\tctx->flags |= NFS_MOUNT_TCP;\n\t\t\tret = xprt_find_transport_ident(param->string);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out_bad_transport;\n\t\t\tctx->nfs_server.protocol = ret;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto out_bad_transport;\n\t\t}\n\n\t\tctx->protofamily = protofamily;\n\t\tbreak;\n\n\tcase Opt_mountproto:\n\t\tif (!param->string)\n\t\t\tgoto out_invalid_value;\n\t\ttrace_nfs_mount_assign(param->key, param->string);\n\t\tmountfamily = AF_INET;\n\t\tswitch (lookup_constant(nfs_xprt_protocol_tokens, param->string, -1)) {\n\t\tcase Opt_xprt_udp6:\n\t\t\tmountfamily = AF_INET6;\n\t\t\tfallthrough;\n\t\tcase Opt_xprt_udp:\n\t\t\tctx->mount_server.protocol = XPRT_TRANSPORT_UDP;\n\t\t\tbreak;\n\t\tcase Opt_xprt_tcp6:\n\t\t\tmountfamily = AF_INET6;\n\t\t\tfallthrough;\n\t\tcase Opt_xprt_tcp:\n\t\t\tctx->mount_server.protocol = XPRT_TRANSPORT_TCP;\n\t\t\tbreak;\n\t\tcase Opt_xprt_rdma:  \n\t\tdefault:\n\t\t\tgoto out_bad_transport;\n\t\t}\n\t\tctx->mountfamily = mountfamily;\n\t\tbreak;\n\n\tcase Opt_addr:\n\t\ttrace_nfs_mount_assign(param->key, param->string);\n\t\tlen = rpc_pton(fc->net_ns, param->string, param->size,\n\t\t\t       &ctx->nfs_server.address,\n\t\t\t       sizeof(ctx->nfs_server._address));\n\t\tif (len == 0)\n\t\t\tgoto out_invalid_address;\n\t\tctx->nfs_server.addrlen = len;\n\t\tbreak;\n\tcase Opt_clientaddr:\n\t\ttrace_nfs_mount_assign(param->key, param->string);\n\t\tkfree(ctx->client_address);\n\t\tctx->client_address = param->string;\n\t\tparam->string = NULL;\n\t\tbreak;\n\tcase Opt_mounthost:\n\t\ttrace_nfs_mount_assign(param->key, param->string);\n\t\tkfree(ctx->mount_server.hostname);\n\t\tctx->mount_server.hostname = param->string;\n\t\tparam->string = NULL;\n\t\tbreak;\n\tcase Opt_mountaddr:\n\t\ttrace_nfs_mount_assign(param->key, param->string);\n\t\tlen = rpc_pton(fc->net_ns, param->string, param->size,\n\t\t\t       &ctx->mount_server.address,\n\t\t\t       sizeof(ctx->mount_server._address));\n\t\tif (len == 0)\n\t\t\tgoto out_invalid_address;\n\t\tctx->mount_server.addrlen = len;\n\t\tbreak;\n\tcase Opt_nconnect:\n\t\ttrace_nfs_mount_assign(param->key, param->string);\n\t\tif (result.uint_32 < 1 || result.uint_32 > NFS_MAX_CONNECTIONS)\n\t\t\tgoto out_of_bounds;\n\t\tctx->nfs_server.nconnect = result.uint_32;\n\t\tbreak;\n\tcase Opt_max_connect:\n\t\ttrace_nfs_mount_assign(param->key, param->string);\n\t\tif (result.uint_32 < 1 || result.uint_32 > NFS_MAX_TRANSPORTS)\n\t\t\tgoto out_of_bounds;\n\t\tctx->nfs_server.max_connect = result.uint_32;\n\t\tbreak;\n\tcase Opt_lookupcache:\n\t\ttrace_nfs_mount_assign(param->key, param->string);\n\t\tswitch (result.uint_32) {\n\t\tcase Opt_lookupcache_all:\n\t\t\tctx->flags &= ~(NFS_MOUNT_LOOKUP_CACHE_NONEG|NFS_MOUNT_LOOKUP_CACHE_NONE);\n\t\t\tbreak;\n\t\tcase Opt_lookupcache_positive:\n\t\t\tctx->flags &= ~NFS_MOUNT_LOOKUP_CACHE_NONE;\n\t\t\tctx->flags |= NFS_MOUNT_LOOKUP_CACHE_NONEG;\n\t\t\tbreak;\n\t\tcase Opt_lookupcache_none:\n\t\t\tctx->flags |= NFS_MOUNT_LOOKUP_CACHE_NONEG|NFS_MOUNT_LOOKUP_CACHE_NONE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto out_invalid_value;\n\t\t}\n\t\tbreak;\n\tcase Opt_local_lock:\n\t\ttrace_nfs_mount_assign(param->key, param->string);\n\t\tswitch (result.uint_32) {\n\t\tcase Opt_local_lock_all:\n\t\t\tctx->flags |= (NFS_MOUNT_LOCAL_FLOCK |\n\t\t\t\t       NFS_MOUNT_LOCAL_FCNTL);\n\t\t\tbreak;\n\t\tcase Opt_local_lock_flock:\n\t\t\tctx->flags |= NFS_MOUNT_LOCAL_FLOCK;\n\t\t\tbreak;\n\t\tcase Opt_local_lock_posix:\n\t\t\tctx->flags |= NFS_MOUNT_LOCAL_FCNTL;\n\t\t\tbreak;\n\t\tcase Opt_local_lock_none:\n\t\t\tctx->flags &= ~(NFS_MOUNT_LOCAL_FLOCK |\n\t\t\t\t\tNFS_MOUNT_LOCAL_FCNTL);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto out_invalid_value;\n\t\t}\n\t\tbreak;\n\tcase Opt_write:\n\t\ttrace_nfs_mount_assign(param->key, param->string);\n\t\tswitch (result.uint_32) {\n\t\tcase Opt_write_lazy:\n\t\t\tctx->flags &=\n\t\t\t\t~(NFS_MOUNT_WRITE_EAGER | NFS_MOUNT_WRITE_WAIT);\n\t\t\tbreak;\n\t\tcase Opt_write_eager:\n\t\t\tctx->flags |= NFS_MOUNT_WRITE_EAGER;\n\t\t\tctx->flags &= ~NFS_MOUNT_WRITE_WAIT;\n\t\t\tbreak;\n\t\tcase Opt_write_wait:\n\t\t\tctx->flags |=\n\t\t\t\tNFS_MOUNT_WRITE_EAGER | NFS_MOUNT_WRITE_WAIT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto out_invalid_value;\n\t\t}\n\t\tbreak;\n\n\t\t \n\tcase Opt_sloppy:\n\t\tctx->sloppy = true;\n\t\tbreak;\n\t}\n\n\treturn 0;\n\nout_invalid_value:\n\treturn nfs_invalf(fc, \"NFS: Bad mount option value specified\");\nout_invalid_address:\n\treturn nfs_invalf(fc, \"NFS: Bad IP address specified\");\nout_of_bounds:\n\treturn nfs_invalf(fc, \"NFS: Value for '%s' out of range\", param->key);\nout_bad_transport:\n\treturn nfs_invalf(fc, \"NFS: Unrecognized transport protocol\");\n}\n\n \nstatic int nfs_parse_source(struct fs_context *fc,\n\t\t\t    size_t maxnamlen, size_t maxpathlen)\n{\n\tstruct nfs_fs_context *ctx = nfs_fc2context(fc);\n\tconst char *dev_name = fc->source;\n\tsize_t len;\n\tconst char *end;\n\n\tif (unlikely(!dev_name || !*dev_name))\n\t\treturn -EINVAL;\n\n\t \n\tif (*dev_name == '[') {\n\t\tend = strchr(++dev_name, ']');\n\t\tif (end == NULL || end[1] != ':')\n\t\t\tgoto out_bad_devname;\n\n\t\tlen = end - dev_name;\n\t\tend++;\n\t} else {\n\t\tconst char *comma;\n\n\t\tend = strchr(dev_name, ':');\n\t\tif (end == NULL)\n\t\t\tgoto out_bad_devname;\n\t\tlen = end - dev_name;\n\n\t\t \n\t\tcomma = memchr(dev_name, ',', len);\n\t\tif (comma)\n\t\t\tlen = comma - dev_name;\n\t}\n\n\tif (len > maxnamlen)\n\t\tgoto out_hostname;\n\n\tkfree(ctx->nfs_server.hostname);\n\n\t \n\tctx->nfs_server.hostname = kmemdup_nul(dev_name, len, GFP_KERNEL);\n\tif (!ctx->nfs_server.hostname)\n\t\tgoto out_nomem;\n\tlen = strlen(++end);\n\tif (len > maxpathlen)\n\t\tgoto out_path;\n\tctx->nfs_server.export_path = kmemdup_nul(end, len, GFP_KERNEL);\n\tif (!ctx->nfs_server.export_path)\n\t\tgoto out_nomem;\n\n\ttrace_nfs_mount_path(ctx->nfs_server.export_path);\n\treturn 0;\n\nout_bad_devname:\n\treturn nfs_invalf(fc, \"NFS: device name not in host:path format\");\nout_nomem:\n\tnfs_errorf(fc, \"NFS: not enough memory to parse device name\");\n\treturn -ENOMEM;\nout_hostname:\n\tnfs_errorf(fc, \"NFS: server hostname too long\");\n\treturn -ENAMETOOLONG;\nout_path:\n\tnfs_errorf(fc, \"NFS: export pathname too long\");\n\treturn -ENAMETOOLONG;\n}\n\nstatic inline bool is_remount_fc(struct fs_context *fc)\n{\n\treturn fc->root != NULL;\n}\n\n \nstatic int nfs23_parse_monolithic(struct fs_context *fc,\n\t\t\t\t  struct nfs_mount_data *data)\n{\n\tstruct nfs_fs_context *ctx = nfs_fc2context(fc);\n\tstruct nfs_fh *mntfh = ctx->mntfh;\n\tstruct sockaddr_storage *sap = &ctx->nfs_server._address;\n\tint extra_flags = NFS_MOUNT_LEGACY_INTERFACE;\n\tint ret;\n\n\tif (data == NULL)\n\t\tgoto out_no_data;\n\n\tctx->version = NFS_DEFAULT_VERSION;\n\tswitch (data->version) {\n\tcase 1:\n\t\tdata->namlen = 0;\n\t\tfallthrough;\n\tcase 2:\n\t\tdata->bsize = 0;\n\t\tfallthrough;\n\tcase 3:\n\t\tif (data->flags & NFS_MOUNT_VER3)\n\t\t\tgoto out_no_v3;\n\t\tdata->root.size = NFS2_FHSIZE;\n\t\tmemcpy(data->root.data, data->old_root.data, NFS2_FHSIZE);\n\t\t \n\t\textra_flags |= NFS_MOUNT_SECFLAVOUR;\n\t\tfallthrough;\n\tcase 4:\n\t\tif (data->flags & NFS_MOUNT_SECFLAVOUR)\n\t\t\tgoto out_no_sec;\n\t\tfallthrough;\n\tcase 5:\n\t\tmemset(data->context, 0, sizeof(data->context));\n\t\tfallthrough;\n\tcase 6:\n\t\tif (data->flags & NFS_MOUNT_VER3) {\n\t\t\tif (data->root.size > NFS3_FHSIZE || data->root.size == 0)\n\t\t\t\tgoto out_invalid_fh;\n\t\t\tmntfh->size = data->root.size;\n\t\t\tctx->version = 3;\n\t\t} else {\n\t\t\tmntfh->size = NFS2_FHSIZE;\n\t\t\tctx->version = 2;\n\t\t}\n\n\n\t\tmemcpy(mntfh->data, data->root.data, mntfh->size);\n\t\tif (mntfh->size < sizeof(mntfh->data))\n\t\t\tmemset(mntfh->data + mntfh->size, 0,\n\t\t\t       sizeof(mntfh->data) - mntfh->size);\n\n\t\t \n\t\tif (!(data->flags & NFS_MOUNT_TCP))  \n\t\t\tif (data->retrans >= 64)  \n\t\t\t\tgoto out_invalid_data;\n\n\t\t \n\t\tctx->flags\t= data->flags & NFS_MOUNT_FLAGMASK;\n\t\tctx->flags\t|= extra_flags;\n\t\tctx->rsize\t= data->rsize;\n\t\tctx->wsize\t= data->wsize;\n\t\tctx->timeo\t= data->timeo;\n\t\tctx->retrans\t= data->retrans;\n\t\tctx->acregmin\t= data->acregmin;\n\t\tctx->acregmax\t= data->acregmax;\n\t\tctx->acdirmin\t= data->acdirmin;\n\t\tctx->acdirmax\t= data->acdirmax;\n\t\tctx->need_mount\t= false;\n\n\t\tmemcpy(sap, &data->addr, sizeof(data->addr));\n\t\tctx->nfs_server.addrlen = sizeof(data->addr);\n\t\tctx->nfs_server.port = ntohs(data->addr.sin_port);\n\t\tif (sap->ss_family != AF_INET ||\n\t\t    !nfs_verify_server_address(sap))\n\t\t\tgoto out_no_address;\n\n\t\tif (!(data->flags & NFS_MOUNT_TCP))\n\t\t\tctx->nfs_server.protocol = XPRT_TRANSPORT_UDP;\n\t\t \n\t\tctx->nfs_server.hostname = kstrdup(data->hostname, GFP_KERNEL);\n\t\tif (!ctx->nfs_server.hostname)\n\t\t\tgoto out_nomem;\n\n\t\tctx->namlen\t\t= data->namlen;\n\t\tctx->bsize\t\t= data->bsize;\n\n\t\tif (data->flags & NFS_MOUNT_SECFLAVOUR)\n\t\t\tctx->selected_flavor = data->pseudoflavor;\n\t\telse\n\t\t\tctx->selected_flavor = RPC_AUTH_UNIX;\n\n\t\tif (!(data->flags & NFS_MOUNT_NONLM))\n\t\t\tctx->flags &= ~(NFS_MOUNT_LOCAL_FLOCK|\n\t\t\t\t\t NFS_MOUNT_LOCAL_FCNTL);\n\t\telse\n\t\t\tctx->flags |= (NFS_MOUNT_LOCAL_FLOCK|\n\t\t\t\t\tNFS_MOUNT_LOCAL_FCNTL);\n\n\t\t \n\t\tif (data->context[0]){\n#ifdef CONFIG_SECURITY_SELINUX\n\t\t\tint ret;\n\n\t\t\tdata->context[NFS_MAX_CONTEXT_LEN] = '\\0';\n\t\t\tret = vfs_parse_fs_string(fc, \"context\",\n\t\t\t\t\t\t  data->context, strlen(data->context));\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n#else\n\t\t\treturn -EINVAL;\n#endif\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\tgoto generic;\n\t}\n\n\tret = nfs_validate_transport_protocol(fc, ctx);\n\tif (ret)\n\t\treturn ret;\n\n\tctx->skip_reconfig_option_check = true;\n\treturn 0;\n\ngeneric:\n\treturn generic_parse_monolithic(fc, data);\n\nout_no_data:\n\tif (is_remount_fc(fc)) {\n\t\tctx->skip_reconfig_option_check = true;\n\t\treturn 0;\n\t}\n\treturn nfs_invalf(fc, \"NFS: mount program didn't pass any mount data\");\n\nout_no_v3:\n\treturn nfs_invalf(fc, \"NFS: nfs_mount_data version does not support v3\");\n\nout_no_sec:\n\treturn nfs_invalf(fc, \"NFS: nfs_mount_data version supports only AUTH_SYS\");\n\nout_nomem:\n\treturn -ENOMEM;\n\nout_no_address:\n\treturn nfs_invalf(fc, \"NFS: mount program didn't pass remote address\");\n\nout_invalid_fh:\n\treturn nfs_invalf(fc, \"NFS: invalid root filehandle\");\n\nout_invalid_data:\n\treturn nfs_invalf(fc, \"NFS: invalid binary mount data\");\n}\n\n#if IS_ENABLED(CONFIG_NFS_V4)\nstruct compat_nfs_string {\n\tcompat_uint_t len;\n\tcompat_uptr_t data;\n};\n\nstatic inline void compat_nfs_string(struct nfs_string *dst,\n\t\t\t\t     struct compat_nfs_string *src)\n{\n\tdst->data = compat_ptr(src->data);\n\tdst->len = src->len;\n}\n\nstruct compat_nfs4_mount_data_v1 {\n\tcompat_int_t version;\n\tcompat_int_t flags;\n\tcompat_int_t rsize;\n\tcompat_int_t wsize;\n\tcompat_int_t timeo;\n\tcompat_int_t retrans;\n\tcompat_int_t acregmin;\n\tcompat_int_t acregmax;\n\tcompat_int_t acdirmin;\n\tcompat_int_t acdirmax;\n\tstruct compat_nfs_string client_addr;\n\tstruct compat_nfs_string mnt_path;\n\tstruct compat_nfs_string hostname;\n\tcompat_uint_t host_addrlen;\n\tcompat_uptr_t host_addr;\n\tcompat_int_t proto;\n\tcompat_int_t auth_flavourlen;\n\tcompat_uptr_t auth_flavours;\n};\n\nstatic void nfs4_compat_mount_data_conv(struct nfs4_mount_data *data)\n{\n\tstruct compat_nfs4_mount_data_v1 *compat =\n\t\t\t(struct compat_nfs4_mount_data_v1 *)data;\n\n\t \n\tdata->auth_flavours = compat_ptr(compat->auth_flavours);\n\tdata->auth_flavourlen = compat->auth_flavourlen;\n\tdata->proto = compat->proto;\n\tdata->host_addr = compat_ptr(compat->host_addr);\n\tdata->host_addrlen = compat->host_addrlen;\n\tcompat_nfs_string(&data->hostname, &compat->hostname);\n\tcompat_nfs_string(&data->mnt_path, &compat->mnt_path);\n\tcompat_nfs_string(&data->client_addr, &compat->client_addr);\n\tdata->acdirmax = compat->acdirmax;\n\tdata->acdirmin = compat->acdirmin;\n\tdata->acregmax = compat->acregmax;\n\tdata->acregmin = compat->acregmin;\n\tdata->retrans = compat->retrans;\n\tdata->timeo = compat->timeo;\n\tdata->wsize = compat->wsize;\n\tdata->rsize = compat->rsize;\n\tdata->flags = compat->flags;\n\tdata->version = compat->version;\n}\n\n \nstatic int nfs4_parse_monolithic(struct fs_context *fc,\n\t\t\t\t struct nfs4_mount_data *data)\n{\n\tstruct nfs_fs_context *ctx = nfs_fc2context(fc);\n\tstruct sockaddr_storage *sap = &ctx->nfs_server._address;\n\tint ret;\n\tchar *c;\n\n\tif (!data) {\n\t\tif (is_remount_fc(fc))\n\t\t\tgoto done;\n\t\treturn nfs_invalf(fc,\n\t\t\t\"NFS4: mount program didn't pass any mount data\");\n\t}\n\n\tctx->version = 4;\n\n\tif (data->version != 1)\n\t\treturn generic_parse_monolithic(fc, data);\n\n\tif (in_compat_syscall())\n\t\tnfs4_compat_mount_data_conv(data);\n\n\tif (data->host_addrlen > sizeof(ctx->nfs_server.address))\n\t\tgoto out_no_address;\n\tif (data->host_addrlen == 0)\n\t\tgoto out_no_address;\n\tctx->nfs_server.addrlen = data->host_addrlen;\n\tif (copy_from_user(sap, data->host_addr, data->host_addrlen))\n\t\treturn -EFAULT;\n\tif (!nfs_verify_server_address(sap))\n\t\tgoto out_no_address;\n\tctx->nfs_server.port = ntohs(((struct sockaddr_in *)sap)->sin_port);\n\n\tif (data->auth_flavourlen) {\n\t\trpc_authflavor_t pseudoflavor;\n\n\t\tif (data->auth_flavourlen > 1)\n\t\t\tgoto out_inval_auth;\n\t\tif (copy_from_user(&pseudoflavor, data->auth_flavours,\n\t\t\t\t   sizeof(pseudoflavor)))\n\t\t\treturn -EFAULT;\n\t\tctx->selected_flavor = pseudoflavor;\n\t} else {\n\t\tctx->selected_flavor = RPC_AUTH_UNIX;\n\t}\n\n\tc = strndup_user(data->hostname.data, NFS4_MAXNAMLEN);\n\tif (IS_ERR(c))\n\t\treturn PTR_ERR(c);\n\tctx->nfs_server.hostname = c;\n\n\tc = strndup_user(data->mnt_path.data, NFS4_MAXPATHLEN);\n\tif (IS_ERR(c))\n\t\treturn PTR_ERR(c);\n\tctx->nfs_server.export_path = c;\n\ttrace_nfs_mount_path(c);\n\n\tc = strndup_user(data->client_addr.data, 16);\n\tif (IS_ERR(c))\n\t\treturn PTR_ERR(c);\n\tctx->client_address = c;\n\n\t \n\n\tctx->flags\t= data->flags & NFS4_MOUNT_FLAGMASK;\n\tctx->rsize\t= data->rsize;\n\tctx->wsize\t= data->wsize;\n\tctx->timeo\t= data->timeo;\n\tctx->retrans\t= data->retrans;\n\tctx->acregmin\t= data->acregmin;\n\tctx->acregmax\t= data->acregmax;\n\tctx->acdirmin\t= data->acdirmin;\n\tctx->acdirmax\t= data->acdirmax;\n\tctx->nfs_server.protocol = data->proto;\n\tret = nfs_validate_transport_protocol(fc, ctx);\n\tif (ret)\n\t\treturn ret;\ndone:\n\tctx->skip_reconfig_option_check = true;\n\treturn 0;\n\nout_inval_auth:\n\treturn nfs_invalf(fc, \"NFS4: Invalid number of RPC auth flavours %d\",\n\t\t      data->auth_flavourlen);\n\nout_no_address:\n\treturn nfs_invalf(fc, \"NFS4: mount program didn't pass remote address\");\n}\n#endif\n\n \nstatic int nfs_fs_context_parse_monolithic(struct fs_context *fc,\n\t\t\t\t\t   void *data)\n{\n\tif (fc->fs_type == &nfs_fs_type)\n\t\treturn nfs23_parse_monolithic(fc, data);\n\n#if IS_ENABLED(CONFIG_NFS_V4)\n\tif (fc->fs_type == &nfs4_fs_type)\n\t\treturn nfs4_parse_monolithic(fc, data);\n#endif\n\n\treturn nfs_invalf(fc, \"NFS: Unsupported monolithic data version\");\n}\n\n \nstatic int nfs_fs_context_validate(struct fs_context *fc)\n{\n\tstruct nfs_fs_context *ctx = nfs_fc2context(fc);\n\tstruct nfs_subversion *nfs_mod;\n\tstruct sockaddr_storage *sap = &ctx->nfs_server._address;\n\tint max_namelen = PAGE_SIZE;\n\tint max_pathlen = NFS_MAXPATHLEN;\n\tint port = 0;\n\tint ret;\n\n\tif (!fc->source)\n\t\tgoto out_no_device_name;\n\n\t \n\tif (ctx->minorversion && ctx->version != 4)\n\t\tgoto out_minorversion_mismatch;\n\n\tif (ctx->options & NFS_OPTION_MIGRATION &&\n\t    (ctx->version != 4 || ctx->minorversion != 0))\n\t\tgoto out_migration_misuse;\n\n\t \n\tif (ctx->protofamily != AF_UNSPEC &&\n\t    ctx->protofamily != ctx->nfs_server.address.sa_family)\n\t\tgoto out_proto_mismatch;\n\n\tif (ctx->mountfamily != AF_UNSPEC) {\n\t\tif (ctx->mount_server.addrlen) {\n\t\t\tif (ctx->mountfamily != ctx->mount_server.address.sa_family)\n\t\t\t\tgoto out_mountproto_mismatch;\n\t\t} else {\n\t\t\tif (ctx->mountfamily != ctx->nfs_server.address.sa_family)\n\t\t\t\tgoto out_mountproto_mismatch;\n\t\t}\n\t}\n\n\tif (!nfs_verify_server_address(sap))\n\t\tgoto out_no_address;\n\n\tret = nfs_validate_transport_protocol(fc, ctx);\n\tif (ret)\n\t\treturn ret;\n\n\tif (ctx->version == 4) {\n\t\tif (IS_ENABLED(CONFIG_NFS_V4)) {\n\t\t\tif (ctx->nfs_server.protocol == XPRT_TRANSPORT_RDMA)\n\t\t\t\tport = NFS_RDMA_PORT;\n\t\t\telse\n\t\t\t\tport = NFS_PORT;\n\t\t\tmax_namelen = NFS4_MAXNAMLEN;\n\t\t\tmax_pathlen = NFS4_MAXPATHLEN;\n\t\t\tctx->flags &= ~(NFS_MOUNT_NONLM | NFS_MOUNT_NOACL |\n\t\t\t\t\tNFS_MOUNT_VER3 | NFS_MOUNT_LOCAL_FLOCK |\n\t\t\t\t\tNFS_MOUNT_LOCAL_FCNTL);\n\t\t} else {\n\t\t\tgoto out_v4_not_compiled;\n\t\t}\n\t} else {\n\t\tnfs_set_mount_transport_protocol(ctx);\n\t\tif (ctx->nfs_server.protocol == XPRT_TRANSPORT_RDMA)\n\t\t\tport = NFS_RDMA_PORT;\n\t}\n\n\tnfs_set_port(sap, &ctx->nfs_server.port, port);\n\n\tret = nfs_parse_source(fc, max_namelen, max_pathlen);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (!ctx->nfs_mod) {\n\t\tnfs_mod = get_nfs_version(ctx->version);\n\t\tif (IS_ERR(nfs_mod)) {\n\t\t\tret = PTR_ERR(nfs_mod);\n\t\t\tgoto out_version_unavailable;\n\t\t}\n\t\tctx->nfs_mod = nfs_mod;\n\t}\n\n\t \n\tif (fc->fs_type != ctx->nfs_mod->nfs_fs) {\n\t\tmodule_put(fc->fs_type->owner);\n\t\t__module_get(ctx->nfs_mod->nfs_fs->owner);\n\t\tfc->fs_type = ctx->nfs_mod->nfs_fs;\n\t}\n\treturn 0;\n\nout_no_device_name:\n\treturn nfs_invalf(fc, \"NFS: Device name not specified\");\nout_v4_not_compiled:\n\tnfs_errorf(fc, \"NFS: NFSv4 is not compiled into kernel\");\n\treturn -EPROTONOSUPPORT;\nout_no_address:\n\treturn nfs_invalf(fc, \"NFS: mount program didn't pass remote address\");\nout_mountproto_mismatch:\n\treturn nfs_invalf(fc, \"NFS: Mount server address does not match mountproto= option\");\nout_proto_mismatch:\n\treturn nfs_invalf(fc, \"NFS: Server address does not match proto= option\");\nout_minorversion_mismatch:\n\treturn nfs_invalf(fc, \"NFS: Mount option vers=%u does not support minorversion=%u\",\n\t\t\t  ctx->version, ctx->minorversion);\nout_migration_misuse:\n\treturn nfs_invalf(fc, \"NFS: 'Migration' not supported for this NFS version\");\nout_version_unavailable:\n\tnfs_errorf(fc, \"NFS: Version unavailable\");\n\treturn ret;\n}\n\n \nstatic int nfs_get_tree(struct fs_context *fc)\n{\n\tstruct nfs_fs_context *ctx = nfs_fc2context(fc);\n\tint err = nfs_fs_context_validate(fc);\n\n\tif (err)\n\t\treturn err;\n\tif (!ctx->internal)\n\t\treturn ctx->nfs_mod->rpc_ops->try_get_tree(fc);\n\telse\n\t\treturn nfs_get_tree_common(fc);\n}\n\n \nstatic int nfs_fs_context_dup(struct fs_context *fc, struct fs_context *src_fc)\n{\n\tstruct nfs_fs_context *src = nfs_fc2context(src_fc), *ctx;\n\n\tctx = kmemdup(src, sizeof(struct nfs_fs_context), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->mntfh = nfs_alloc_fhandle();\n\tif (!ctx->mntfh) {\n\t\tkfree(ctx);\n\t\treturn -ENOMEM;\n\t}\n\tnfs_copy_fh(ctx->mntfh, src->mntfh);\n\n\t__module_get(ctx->nfs_mod->owner);\n\tctx->client_address\t\t= NULL;\n\tctx->mount_server.hostname\t= NULL;\n\tctx->nfs_server.export_path\t= NULL;\n\tctx->nfs_server.hostname\t= NULL;\n\tctx->fscache_uniq\t\t= NULL;\n\tctx->clone_data.fattr\t\t= NULL;\n\tfc->fs_private = ctx;\n\treturn 0;\n}\n\nstatic void nfs_fs_context_free(struct fs_context *fc)\n{\n\tstruct nfs_fs_context *ctx = nfs_fc2context(fc);\n\n\tif (ctx) {\n\t\tif (ctx->server)\n\t\t\tnfs_free_server(ctx->server);\n\t\tif (ctx->nfs_mod)\n\t\t\tput_nfs_version(ctx->nfs_mod);\n\t\tkfree(ctx->client_address);\n\t\tkfree(ctx->mount_server.hostname);\n\t\tkfree(ctx->nfs_server.export_path);\n\t\tkfree(ctx->nfs_server.hostname);\n\t\tkfree(ctx->fscache_uniq);\n\t\tnfs_free_fhandle(ctx->mntfh);\n\t\tnfs_free_fattr(ctx->clone_data.fattr);\n\t\tkfree(ctx);\n\t}\n}\n\nstatic const struct fs_context_operations nfs_fs_context_ops = {\n\t.free\t\t\t= nfs_fs_context_free,\n\t.dup\t\t\t= nfs_fs_context_dup,\n\t.parse_param\t\t= nfs_fs_context_parse_param,\n\t.parse_monolithic\t= nfs_fs_context_parse_monolithic,\n\t.get_tree\t\t= nfs_get_tree,\n\t.reconfigure\t\t= nfs_reconfigure,\n};\n\n \nstatic int nfs_init_fs_context(struct fs_context *fc)\n{\n\tstruct nfs_fs_context *ctx;\n\n\tctx = kzalloc(sizeof(struct nfs_fs_context), GFP_KERNEL);\n\tif (unlikely(!ctx))\n\t\treturn -ENOMEM;\n\n\tctx->mntfh = nfs_alloc_fhandle();\n\tif (unlikely(!ctx->mntfh)) {\n\t\tkfree(ctx);\n\t\treturn -ENOMEM;\n\t}\n\n\tctx->protofamily\t= AF_UNSPEC;\n\tctx->mountfamily\t= AF_UNSPEC;\n\tctx->mount_server.port\t= NFS_UNSPEC_PORT;\n\n\tif (fc->root) {\n\t\t \n\t\tstruct nfs_server *nfss = fc->root->d_sb->s_fs_info;\n\t\tstruct net *net = nfss->nfs_client->cl_net;\n\n\t\tctx->flags\t\t= nfss->flags;\n\t\tctx->rsize\t\t= nfss->rsize;\n\t\tctx->wsize\t\t= nfss->wsize;\n\t\tctx->retrans\t\t= nfss->client->cl_timeout->to_retries;\n\t\tctx->selected_flavor\t= nfss->client->cl_auth->au_flavor;\n\t\tctx->acregmin\t\t= nfss->acregmin / HZ;\n\t\tctx->acregmax\t\t= nfss->acregmax / HZ;\n\t\tctx->acdirmin\t\t= nfss->acdirmin / HZ;\n\t\tctx->acdirmax\t\t= nfss->acdirmax / HZ;\n\t\tctx->timeo\t\t= 10U * nfss->client->cl_timeout->to_initval / HZ;\n\t\tctx->nfs_server.port\t= nfss->port;\n\t\tctx->nfs_server.addrlen\t= nfss->nfs_client->cl_addrlen;\n\t\tctx->version\t\t= nfss->nfs_client->rpc_ops->version;\n\t\tctx->minorversion\t= nfss->nfs_client->cl_minorversion;\n\n\t\tmemcpy(&ctx->nfs_server._address, &nfss->nfs_client->cl_addr,\n\t\t\tctx->nfs_server.addrlen);\n\n\t\tif (fc->net_ns != net) {\n\t\t\tput_net(fc->net_ns);\n\t\t\tfc->net_ns = get_net(net);\n\t\t}\n\n\t\tctx->nfs_mod = nfss->nfs_client->cl_nfs_mod;\n\t\t__module_get(ctx->nfs_mod->owner);\n\t} else {\n\t\t \n\t\tctx->timeo\t\t= NFS_UNSPEC_TIMEO;\n\t\tctx->retrans\t\t= NFS_UNSPEC_RETRANS;\n\t\tctx->acregmin\t\t= NFS_DEF_ACREGMIN;\n\t\tctx->acregmax\t\t= NFS_DEF_ACREGMAX;\n\t\tctx->acdirmin\t\t= NFS_DEF_ACDIRMIN;\n\t\tctx->acdirmax\t\t= NFS_DEF_ACDIRMAX;\n\t\tctx->nfs_server.port\t= NFS_UNSPEC_PORT;\n\t\tctx->nfs_server.protocol = XPRT_TRANSPORT_TCP;\n\t\tctx->selected_flavor\t= RPC_AUTH_MAXFLAVOR;\n\t\tctx->minorversion\t= 0;\n\t\tctx->need_mount\t\t= true;\n\t\tctx->xprtsec.policy\t= RPC_XPRTSEC_NONE;\n\t\tctx->xprtsec.cert_serial\t= TLS_NO_CERT;\n\t\tctx->xprtsec.privkey_serial\t= TLS_NO_PRIVKEY;\n\n\t\tfc->s_iflags\t\t|= SB_I_STABLE_WRITES;\n\t}\n\tfc->fs_private = ctx;\n\tfc->ops = &nfs_fs_context_ops;\n\treturn 0;\n}\n\nstruct file_system_type nfs_fs_type = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.name\t\t\t= \"nfs\",\n\t.init_fs_context\t= nfs_init_fs_context,\n\t.parameters\t\t= nfs_fs_parameters,\n\t.kill_sb\t\t= nfs_kill_super,\n\t.fs_flags\t\t= FS_RENAME_DOES_D_MOVE|FS_BINARY_MOUNTDATA,\n};\nMODULE_ALIAS_FS(\"nfs\");\nEXPORT_SYMBOL_GPL(nfs_fs_type);\n\n#if IS_ENABLED(CONFIG_NFS_V4)\nstruct file_system_type nfs4_fs_type = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.name\t\t\t= \"nfs4\",\n\t.init_fs_context\t= nfs_init_fs_context,\n\t.parameters\t\t= nfs_fs_parameters,\n\t.kill_sb\t\t= nfs_kill_super,\n\t.fs_flags\t\t= FS_RENAME_DOES_D_MOVE|FS_BINARY_MOUNTDATA,\n};\nMODULE_ALIAS_FS(\"nfs4\");\nMODULE_ALIAS(\"nfs4\");\nEXPORT_SYMBOL_GPL(nfs4_fs_type);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}