{
  "module_name": "super.c",
  "hash_id": "fe11ebdeb276c514ea060e4de30defd28ea4e63f571cb255df9f8fb081fcf623",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfs/super.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/unistd.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/xprtsock.h>\n#include <linux/sunrpc/xprtrdma.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs4_mount.h>\n#include <linux/lockd/bind.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/vfs.h>\n#include <linux/inet.h>\n#include <linux/in6.h>\n#include <linux/slab.h>\n#include <net/ipv6.h>\n#include <linux/netdevice.h>\n#include <linux/nfs_xdr.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/nsproxy.h>\n#include <linux/rcupdate.h>\n\n#include <linux/uaccess.h>\n#include <linux/nfs_ssc.h>\n\n#include <uapi/linux/tls.h>\n\n#include \"nfs4_fs.h\"\n#include \"callback.h\"\n#include \"delegation.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"pnfs.h\"\n#include \"nfs.h\"\n#include \"netns.h\"\n#include \"sysfs.h\"\n\n#define NFSDBG_FACILITY\t\tNFSDBG_VFS\n\nconst struct super_operations nfs_sops = {\n\t.alloc_inode\t= nfs_alloc_inode,\n\t.free_inode\t= nfs_free_inode,\n\t.write_inode\t= nfs_write_inode,\n\t.drop_inode\t= nfs_drop_inode,\n\t.statfs\t\t= nfs_statfs,\n\t.evict_inode\t= nfs_evict_inode,\n\t.umount_begin\t= nfs_umount_begin,\n\t.show_options\t= nfs_show_options,\n\t.show_devname\t= nfs_show_devname,\n\t.show_path\t= nfs_show_path,\n\t.show_stats\t= nfs_show_stats,\n};\nEXPORT_SYMBOL_GPL(nfs_sops);\n\n#ifdef CONFIG_NFS_V4_2\nstatic const struct nfs_ssc_client_ops nfs_ssc_clnt_ops_tbl = {\n\t.sco_sb_deactive = nfs_sb_deactive,\n};\n#endif\n\n#if IS_ENABLED(CONFIG_NFS_V4)\nstatic int __init register_nfs4_fs(void)\n{\n\treturn register_filesystem(&nfs4_fs_type);\n}\n\nstatic void unregister_nfs4_fs(void)\n{\n\tunregister_filesystem(&nfs4_fs_type);\n}\n#else\nstatic int __init register_nfs4_fs(void)\n{\n\treturn 0;\n}\n\nstatic void unregister_nfs4_fs(void)\n{\n}\n#endif\n\n#ifdef CONFIG_NFS_V4_2\nstatic void nfs_ssc_register_ops(void)\n{\n\tnfs_ssc_register(&nfs_ssc_clnt_ops_tbl);\n}\n\nstatic void nfs_ssc_unregister_ops(void)\n{\n\tnfs_ssc_unregister(&nfs_ssc_clnt_ops_tbl);\n}\n#endif  \n\nstatic struct shrinker acl_shrinker = {\n\t.count_objects\t= nfs_access_cache_count,\n\t.scan_objects\t= nfs_access_cache_scan,\n\t.seeks\t\t= DEFAULT_SEEKS,\n};\n\n \nint __init register_nfs_fs(void)\n{\n\tint ret;\n\n        ret = register_filesystem(&nfs_fs_type);\n\tif (ret < 0)\n\t\tgoto error_0;\n\n\tret = register_nfs4_fs();\n\tif (ret < 0)\n\t\tgoto error_1;\n\n\tret = nfs_register_sysctl();\n\tif (ret < 0)\n\t\tgoto error_2;\n\tret = register_shrinker(&acl_shrinker, \"nfs-acl\");\n\tif (ret < 0)\n\t\tgoto error_3;\n#ifdef CONFIG_NFS_V4_2\n\tnfs_ssc_register_ops();\n#endif\n\treturn 0;\nerror_3:\n\tnfs_unregister_sysctl();\nerror_2:\n\tunregister_nfs4_fs();\nerror_1:\n\tunregister_filesystem(&nfs_fs_type);\nerror_0:\n\treturn ret;\n}\n\n \nvoid __exit unregister_nfs_fs(void)\n{\n\tunregister_shrinker(&acl_shrinker);\n\tnfs_unregister_sysctl();\n\tunregister_nfs4_fs();\n#ifdef CONFIG_NFS_V4_2\n\tnfs_ssc_unregister_ops();\n#endif\n\tunregister_filesystem(&nfs_fs_type);\n}\n\nbool nfs_sb_active(struct super_block *sb)\n{\n\tstruct nfs_server *server = NFS_SB(sb);\n\n\tif (!atomic_inc_not_zero(&sb->s_active))\n\t\treturn false;\n\tif (atomic_inc_return(&server->active) != 1)\n\t\tatomic_dec(&sb->s_active);\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(nfs_sb_active);\n\nvoid nfs_sb_deactive(struct super_block *sb)\n{\n\tstruct nfs_server *server = NFS_SB(sb);\n\n\tif (atomic_dec_and_test(&server->active))\n\t\tdeactivate_super(sb);\n}\nEXPORT_SYMBOL_GPL(nfs_sb_deactive);\n\nstatic int __nfs_list_for_each_server(struct list_head *head,\n\t\tint (*fn)(struct nfs_server *, void *),\n\t\tvoid *data)\n{\n\tstruct nfs_server *server, *last = NULL;\n\tint ret = 0;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(server, head, client_link) {\n\t\tif (!(server->super && nfs_sb_active(server->super)))\n\t\t\tcontinue;\n\t\trcu_read_unlock();\n\t\tif (last)\n\t\t\tnfs_sb_deactive(last->super);\n\t\tlast = server;\n\t\tret = fn(server, data);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\trcu_read_lock();\n\t}\n\trcu_read_unlock();\nout:\n\tif (last)\n\t\tnfs_sb_deactive(last->super);\n\treturn ret;\n}\n\nint nfs_client_for_each_server(struct nfs_client *clp,\n\t\tint (*fn)(struct nfs_server *, void *),\n\t\tvoid *data)\n{\n\treturn __nfs_list_for_each_server(&clp->cl_superblocks, fn, data);\n}\nEXPORT_SYMBOL_GPL(nfs_client_for_each_server);\n\n \nint nfs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct nfs_server *server = NFS_SB(dentry->d_sb);\n\tunsigned char blockbits;\n\tunsigned long blockres;\n\tstruct nfs_fh *fh = NFS_FH(d_inode(dentry));\n\tstruct nfs_fsstat res;\n\tint error = -ENOMEM;\n\n\tres.fattr = nfs_alloc_fattr();\n\tif (res.fattr == NULL)\n\t\tgoto out_err;\n\n\terror = server->nfs_client->rpc_ops->statfs(server, fh, &res);\n\tif (unlikely(error == -ESTALE)) {\n\t\tstruct dentry *pd_dentry;\n\n\t\tpd_dentry = dget_parent(dentry);\n\t\tnfs_zap_caches(d_inode(pd_dentry));\n\t\tdput(pd_dentry);\n\t}\n\tnfs_free_fattr(res.fattr);\n\tif (error < 0)\n\t\tgoto out_err;\n\n\tbuf->f_type = NFS_SUPER_MAGIC;\n\n\t \n\tbuf->f_frsize = dentry->d_sb->s_blocksize;\n\n\t \n\tbuf->f_bsize = dentry->d_sb->s_blocksize;\n\tblockbits = dentry->d_sb->s_blocksize_bits;\n\tblockres = (1 << blockbits) - 1;\n\tbuf->f_blocks = (res.tbytes + blockres) >> blockbits;\n\tbuf->f_bfree = (res.fbytes + blockres) >> blockbits;\n\tbuf->f_bavail = (res.abytes + blockres) >> blockbits;\n\n\tbuf->f_files = res.tfiles;\n\tbuf->f_ffree = res.afiles;\n\n\tbuf->f_namelen = server->namelen;\n\n\treturn 0;\n\n out_err:\n\tdprintk(\"%s: statfs error = %d\\n\", __func__, -error);\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(nfs_statfs);\n\n \nstatic const char *nfs_pseudoflavour_to_name(rpc_authflavor_t flavour)\n{\n\tstatic const struct {\n\t\trpc_authflavor_t flavour;\n\t\tconst char *str;\n\t} sec_flavours[NFS_AUTH_INFO_MAX_FLAVORS] = {\n\t\t \n\t\t{ RPC_AUTH_NULL, \"null\" },\n\t\t{ RPC_AUTH_UNIX, \"sys\" },\n\t\t{ RPC_AUTH_GSS_KRB5, \"krb5\" },\n\t\t{ RPC_AUTH_GSS_KRB5I, \"krb5i\" },\n\t\t{ RPC_AUTH_GSS_KRB5P, \"krb5p\" },\n\t\t{ RPC_AUTH_GSS_LKEY, \"lkey\" },\n\t\t{ RPC_AUTH_GSS_LKEYI, \"lkeyi\" },\n\t\t{ RPC_AUTH_GSS_LKEYP, \"lkeyp\" },\n\t\t{ RPC_AUTH_GSS_SPKM, \"spkm\" },\n\t\t{ RPC_AUTH_GSS_SPKMI, \"spkmi\" },\n\t\t{ RPC_AUTH_GSS_SPKMP, \"spkmp\" },\n\t\t{ UINT_MAX, \"unknown\" }\n\t};\n\tint i;\n\n\tfor (i = 0; sec_flavours[i].flavour != UINT_MAX; i++) {\n\t\tif (sec_flavours[i].flavour == flavour)\n\t\t\tbreak;\n\t}\n\treturn sec_flavours[i].str;\n}\n\nstatic void nfs_show_mountd_netid(struct seq_file *m, struct nfs_server *nfss,\n\t\t\t\t  int showdefaults)\n{\n\tstruct sockaddr *sap = (struct sockaddr *) &nfss->mountd_address;\n\tchar *proto = NULL;\n\n\tswitch (sap->sa_family) {\n\tcase AF_INET:\n\t\tswitch (nfss->mountd_protocol) {\n\t\tcase IPPROTO_UDP:\n\t\t\tproto = RPCBIND_NETID_UDP;\n\t\t\tbreak;\n\t\tcase IPPROTO_TCP:\n\t\t\tproto = RPCBIND_NETID_TCP;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase AF_INET6:\n\t\tswitch (nfss->mountd_protocol) {\n\t\tcase IPPROTO_UDP:\n\t\t\tproto = RPCBIND_NETID_UDP6;\n\t\t\tbreak;\n\t\tcase IPPROTO_TCP:\n\t\t\tproto = RPCBIND_NETID_TCP6;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\tif (proto || showdefaults)\n\t\tseq_printf(m, \",mountproto=%s\", proto ?: \"auto\");\n}\n\nstatic void nfs_show_mountd_options(struct seq_file *m, struct nfs_server *nfss,\n\t\t\t\t    int showdefaults)\n{\n\tstruct sockaddr *sap = (struct sockaddr *)&nfss->mountd_address;\n\n\tif (nfss->flags & NFS_MOUNT_LEGACY_INTERFACE)\n\t\treturn;\n\n\tswitch (sap->sa_family) {\n\tcase AF_INET: {\n\t\tstruct sockaddr_in *sin = (struct sockaddr_in *)sap;\n\t\tseq_printf(m, \",mountaddr=%pI4\", &sin->sin_addr.s_addr);\n\t\tbreak;\n\t}\n\tcase AF_INET6: {\n\t\tstruct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)sap;\n\t\tseq_printf(m, \",mountaddr=%pI6c\", &sin6->sin6_addr);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tif (showdefaults)\n\t\t\tseq_puts(m, \",mountaddr=unspecified\");\n\t}\n\n\tif (nfss->mountd_version || showdefaults)\n\t\tseq_printf(m, \",mountvers=%u\", nfss->mountd_version);\n\tif ((nfss->mountd_port &&\n\t\tnfss->mountd_port != (unsigned short)NFS_UNSPEC_PORT) ||\n\t\tshowdefaults)\n\t\tseq_printf(m, \",mountport=%u\", nfss->mountd_port);\n\n\tnfs_show_mountd_netid(m, nfss, showdefaults);\n}\n\n#if IS_ENABLED(CONFIG_NFS_V4)\nstatic void nfs_show_nfsv4_options(struct seq_file *m, struct nfs_server *nfss,\n\t\t\t\t    int showdefaults)\n{\n\tstruct nfs_client *clp = nfss->nfs_client;\n\n\tseq_printf(m, \",clientaddr=%s\", clp->cl_ipaddr);\n}\n#else\nstatic void nfs_show_nfsv4_options(struct seq_file *m, struct nfs_server *nfss,\n\t\t\t\t    int showdefaults)\n{\n}\n#endif\n\nstatic void nfs_show_nfs_version(struct seq_file *m,\n\t\tunsigned int version,\n\t\tunsigned int minorversion)\n{\n\tseq_printf(m, \",vers=%u\", version);\n\tif (version == 4)\n\t\tseq_printf(m, \".%u\", minorversion);\n}\n\n \nstatic void nfs_show_mount_options(struct seq_file *m, struct nfs_server *nfss,\n\t\t\t\t   int showdefaults)\n{\n\tstatic const struct proc_nfs_info {\n\t\tint flag;\n\t\tconst char *str;\n\t\tconst char *nostr;\n\t} nfs_info[] = {\n\t\t{ NFS_MOUNT_SOFT, \",soft\", \"\" },\n\t\t{ NFS_MOUNT_SOFTERR, \",softerr\", \"\" },\n\t\t{ NFS_MOUNT_SOFTREVAL, \",softreval\", \"\" },\n\t\t{ NFS_MOUNT_POSIX, \",posix\", \"\" },\n\t\t{ NFS_MOUNT_NOCTO, \",nocto\", \"\" },\n\t\t{ NFS_MOUNT_NOAC, \",noac\", \"\" },\n\t\t{ NFS_MOUNT_NONLM, \",nolock\", \"\" },\n\t\t{ NFS_MOUNT_NOACL, \",noacl\", \"\" },\n\t\t{ NFS_MOUNT_NORDIRPLUS, \",nordirplus\", \"\" },\n\t\t{ NFS_MOUNT_UNSHARED, \",nosharecache\", \"\" },\n\t\t{ NFS_MOUNT_NORESVPORT, \",noresvport\", \"\" },\n\t\t{ 0, NULL, NULL }\n\t};\n\tconst struct proc_nfs_info *nfs_infop;\n\tstruct nfs_client *clp = nfss->nfs_client;\n\tu32 version = clp->rpc_ops->version;\n\tint local_flock, local_fcntl;\n\n\tnfs_show_nfs_version(m, version, clp->cl_minorversion);\n\tseq_printf(m, \",rsize=%u\", nfss->rsize);\n\tseq_printf(m, \",wsize=%u\", nfss->wsize);\n\tif (nfss->bsize != 0)\n\t\tseq_printf(m, \",bsize=%u\", nfss->bsize);\n\tseq_printf(m, \",namlen=%u\", nfss->namelen);\n\tif (nfss->acregmin != NFS_DEF_ACREGMIN*HZ || showdefaults)\n\t\tseq_printf(m, \",acregmin=%u\", nfss->acregmin/HZ);\n\tif (nfss->acregmax != NFS_DEF_ACREGMAX*HZ || showdefaults)\n\t\tseq_printf(m, \",acregmax=%u\", nfss->acregmax/HZ);\n\tif (nfss->acdirmin != NFS_DEF_ACDIRMIN*HZ || showdefaults)\n\t\tseq_printf(m, \",acdirmin=%u\", nfss->acdirmin/HZ);\n\tif (nfss->acdirmax != NFS_DEF_ACDIRMAX*HZ || showdefaults)\n\t\tseq_printf(m, \",acdirmax=%u\", nfss->acdirmax/HZ);\n\tif (!(nfss->flags & (NFS_MOUNT_SOFT|NFS_MOUNT_SOFTERR)))\n\t\t\tseq_puts(m, \",hard\");\n\tfor (nfs_infop = nfs_info; nfs_infop->flag; nfs_infop++) {\n\t\tif (nfss->flags & nfs_infop->flag)\n\t\t\tseq_puts(m, nfs_infop->str);\n\t\telse\n\t\t\tseq_puts(m, nfs_infop->nostr);\n\t}\n\trcu_read_lock();\n\tseq_printf(m, \",proto=%s\",\n\t\t   rpc_peeraddr2str(nfss->client, RPC_DISPLAY_NETID));\n\trcu_read_unlock();\n\tif (clp->cl_nconnect > 0)\n\t\tseq_printf(m, \",nconnect=%u\", clp->cl_nconnect);\n\tif (version == 4) {\n\t\tif (clp->cl_max_connect > 1)\n\t\t\tseq_printf(m, \",max_connect=%u\", clp->cl_max_connect);\n\t\tif (nfss->port != NFS_PORT)\n\t\t\tseq_printf(m, \",port=%u\", nfss->port);\n\t} else\n\t\tif (nfss->port)\n\t\t\tseq_printf(m, \",port=%u\", nfss->port);\n\n\tseq_printf(m, \",timeo=%lu\", 10U * nfss->client->cl_timeout->to_initval / HZ);\n\tseq_printf(m, \",retrans=%u\", nfss->client->cl_timeout->to_retries);\n\tseq_printf(m, \",sec=%s\", nfs_pseudoflavour_to_name(nfss->client->cl_auth->au_flavor));\n\tswitch (clp->cl_xprtsec.policy) {\n\tcase RPC_XPRTSEC_TLS_ANON:\n\t\tseq_puts(m, \",xprtsec=tls\");\n\t\tbreak;\n\tcase RPC_XPRTSEC_TLS_X509:\n\t\tseq_puts(m, \",xprtsec=mtls\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (version != 4)\n\t\tnfs_show_mountd_options(m, nfss, showdefaults);\n\telse\n\t\tnfs_show_nfsv4_options(m, nfss, showdefaults);\n\n\tif (nfss->options & NFS_OPTION_FSCACHE)\n\t\tseq_puts(m, \",fsc\");\n\n\tif (nfss->options & NFS_OPTION_MIGRATION)\n\t\tseq_puts(m, \",migration\");\n\n\tif (nfss->flags & NFS_MOUNT_LOOKUP_CACHE_NONEG) {\n\t\tif (nfss->flags & NFS_MOUNT_LOOKUP_CACHE_NONE)\n\t\t\tseq_puts(m, \",lookupcache=none\");\n\t\telse\n\t\t\tseq_puts(m, \",lookupcache=pos\");\n\t}\n\n\tlocal_flock = nfss->flags & NFS_MOUNT_LOCAL_FLOCK;\n\tlocal_fcntl = nfss->flags & NFS_MOUNT_LOCAL_FCNTL;\n\n\tif (!local_flock && !local_fcntl)\n\t\tseq_puts(m, \",local_lock=none\");\n\telse if (local_flock && local_fcntl)\n\t\tseq_puts(m, \",local_lock=all\");\n\telse if (local_flock)\n\t\tseq_puts(m, \",local_lock=flock\");\n\telse\n\t\tseq_puts(m, \",local_lock=posix\");\n\n\tif (nfss->flags & NFS_MOUNT_WRITE_EAGER) {\n\t\tif (nfss->flags & NFS_MOUNT_WRITE_WAIT)\n\t\t\tseq_puts(m, \",write=wait\");\n\t\telse\n\t\t\tseq_puts(m, \",write=eager\");\n\t}\n}\n\n \nint nfs_show_options(struct seq_file *m, struct dentry *root)\n{\n\tstruct nfs_server *nfss = NFS_SB(root->d_sb);\n\n\tnfs_show_mount_options(m, nfss, 0);\n\n\trcu_read_lock();\n\tseq_printf(m, \",addr=%s\",\n\t\t\trpc_peeraddr2str(nfss->nfs_client->cl_rpcclient,\n\t\t\t\t\t\t\tRPC_DISPLAY_ADDR));\n\trcu_read_unlock();\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nfs_show_options);\n\n#if IS_ENABLED(CONFIG_NFS_V4)\nstatic void show_lease(struct seq_file *m, struct nfs_server *server)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tunsigned long expire;\n\n\tseq_printf(m, \",lease_time=%ld\", clp->cl_lease_time / HZ);\n\texpire = clp->cl_last_renewal + clp->cl_lease_time;\n\tseq_printf(m, \",lease_expired=%ld\",\n\t\t   time_after(expire, jiffies) ?  0 : (jiffies - expire) / HZ);\n}\n#ifdef CONFIG_NFS_V4_1\nstatic void show_sessions(struct seq_file *m, struct nfs_server *server)\n{\n\tif (nfs4_has_session(server->nfs_client))\n\t\tseq_puts(m, \",sessions\");\n}\n#else\nstatic void show_sessions(struct seq_file *m, struct nfs_server *server) {}\n#endif\n#endif\n\n#ifdef CONFIG_NFS_V4_1\nstatic void show_pnfs(struct seq_file *m, struct nfs_server *server)\n{\n\tseq_printf(m, \",pnfs=\");\n\tif (server->pnfs_curr_ld)\n\t\tseq_printf(m, \"%s\", server->pnfs_curr_ld->name);\n\telse\n\t\tseq_printf(m, \"not configured\");\n}\n\nstatic void show_implementation_id(struct seq_file *m, struct nfs_server *nfss)\n{\n\tif (nfss->nfs_client && nfss->nfs_client->cl_implid) {\n\t\tstruct nfs41_impl_id *impl_id = nfss->nfs_client->cl_implid;\n\t\tseq_printf(m, \"\\n\\timpl_id:\\tname='%s',domain='%s',\"\n\t\t\t   \"date='%llu,%u'\",\n\t\t\t   impl_id->name, impl_id->domain,\n\t\t\t   impl_id->date.seconds, impl_id->date.nseconds);\n\t}\n}\n#else\n#if IS_ENABLED(CONFIG_NFS_V4)\nstatic void show_pnfs(struct seq_file *m, struct nfs_server *server)\n{\n}\n#endif\nstatic void show_implementation_id(struct seq_file *m, struct nfs_server *nfss)\n{\n}\n#endif\n\nint nfs_show_devname(struct seq_file *m, struct dentry *root)\n{\n\tchar *page = (char *) __get_free_page(GFP_KERNEL);\n\tchar *devname, *dummy;\n\tint err = 0;\n\tif (!page)\n\t\treturn -ENOMEM;\n\tdevname = nfs_path(&dummy, root, page, PAGE_SIZE, 0);\n\tif (IS_ERR(devname))\n\t\terr = PTR_ERR(devname);\n\telse\n\t\tseq_escape(m, devname, \" \\t\\n\\\\\");\n\tfree_page((unsigned long)page);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(nfs_show_devname);\n\nint nfs_show_path(struct seq_file *m, struct dentry *dentry)\n{\n\tseq_puts(m, \"/\");\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nfs_show_path);\n\n \nint nfs_show_stats(struct seq_file *m, struct dentry *root)\n{\n\tint i, cpu;\n\tstruct nfs_server *nfss = NFS_SB(root->d_sb);\n\tstruct rpc_auth *auth = nfss->client->cl_auth;\n\tstruct nfs_iostats totals = { };\n\n\tseq_printf(m, \"statvers=%s\", NFS_IOSTAT_VERS);\n\n\t \n\tseq_puts(m, \"\\n\\topts:\\t\");\n\tseq_puts(m, sb_rdonly(root->d_sb) ? \"ro\" : \"rw\");\n\tseq_puts(m, root->d_sb->s_flags & SB_SYNCHRONOUS ? \",sync\" : \"\");\n\tseq_puts(m, root->d_sb->s_flags & SB_NOATIME ? \",noatime\" : \"\");\n\tseq_puts(m, root->d_sb->s_flags & SB_NODIRATIME ? \",nodiratime\" : \"\");\n\tnfs_show_mount_options(m, nfss, 1);\n\n\tseq_printf(m, \"\\n\\tage:\\t%lu\", (jiffies - nfss->mount_time) / HZ);\n\n\tshow_implementation_id(m, nfss);\n\n\tseq_puts(m, \"\\n\\tcaps:\\t\");\n\tseq_printf(m, \"caps=0x%x\", nfss->caps);\n\tseq_printf(m, \",wtmult=%u\", nfss->wtmult);\n\tseq_printf(m, \",dtsize=%u\", nfss->dtsize);\n\tseq_printf(m, \",bsize=%u\", nfss->bsize);\n\tseq_printf(m, \",namlen=%u\", nfss->namelen);\n\n#if IS_ENABLED(CONFIG_NFS_V4)\n\tif (nfss->nfs_client->rpc_ops->version == 4) {\n\t\tseq_puts(m, \"\\n\\tnfsv4:\\t\");\n\t\tseq_printf(m, \"bm0=0x%x\", nfss->attr_bitmask[0]);\n\t\tseq_printf(m, \",bm1=0x%x\", nfss->attr_bitmask[1]);\n\t\tseq_printf(m, \",bm2=0x%x\", nfss->attr_bitmask[2]);\n\t\tseq_printf(m, \",acl=0x%x\", nfss->acl_bitmask);\n\t\tshow_sessions(m, nfss);\n\t\tshow_pnfs(m, nfss);\n\t\tshow_lease(m, nfss);\n\t}\n#endif\n\n\t \n\tseq_printf(m, \"\\n\\tsec:\\tflavor=%u\", auth->au_ops->au_flavor);\n\tif (auth->au_flavor)\n\t\tseq_printf(m, \",pseudoflavor=%u\", auth->au_flavor);\n\n\t \n\tfor_each_possible_cpu(cpu) {\n\t\tstruct nfs_iostats *stats;\n\n\t\tpreempt_disable();\n\t\tstats = per_cpu_ptr(nfss->io_stats, cpu);\n\n\t\tfor (i = 0; i < __NFSIOS_COUNTSMAX; i++)\n\t\t\ttotals.events[i] += stats->events[i];\n\t\tfor (i = 0; i < __NFSIOS_BYTESMAX; i++)\n\t\t\ttotals.bytes[i] += stats->bytes[i];\n\n\t\tpreempt_enable();\n\t}\n\n\tseq_puts(m, \"\\n\\tevents:\\t\");\n\tfor (i = 0; i < __NFSIOS_COUNTSMAX; i++)\n\t\tseq_printf(m, \"%lu \", totals.events[i]);\n\tseq_puts(m, \"\\n\\tbytes:\\t\");\n\tfor (i = 0; i < __NFSIOS_BYTESMAX; i++)\n\t\tseq_printf(m, \"%Lu \", totals.bytes[i]);\n\tseq_putc(m, '\\n');\n\n\trpc_clnt_show_stats(m, nfss->client);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nfs_show_stats);\n\n \nvoid nfs_umount_begin(struct super_block *sb)\n{\n\tstruct nfs_server *server;\n\tstruct rpc_clnt *rpc;\n\n\tserver = NFS_SB(sb);\n\t \n\trpc = server->client_acl;\n\tif (!IS_ERR(rpc))\n\t\trpc_killall_tasks(rpc);\n\trpc = server->client;\n\tif (!IS_ERR(rpc))\n\t\trpc_killall_tasks(rpc);\n}\nEXPORT_SYMBOL_GPL(nfs_umount_begin);\n\n \nbool nfs_auth_info_match(const struct nfs_auth_info *auth_info,\n\t\t\t rpc_authflavor_t match)\n{\n\tint i;\n\n\tif (!auth_info->flavor_len)\n\t\treturn true;\n\n\tfor (i = 0; i < auth_info->flavor_len; i++) {\n\t\tif (auth_info->flavors[i] == match)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(nfs_auth_info_match);\n\n \nstatic int nfs_verify_authflavors(struct nfs_fs_context *ctx,\n\t\t\t\t  rpc_authflavor_t *server_authlist,\n\t\t\t\t  unsigned int count)\n{\n\trpc_authflavor_t flavor = RPC_AUTH_MAXFLAVOR;\n\tbool found_auth_null = false;\n\tunsigned int i;\n\n\t \n\tfor (i = 0; i < count; i++) {\n\t\tflavor = server_authlist[i];\n\n\t\tif (nfs_auth_info_match(&ctx->auth_info, flavor))\n\t\t\tgoto out;\n\n\t\tif (flavor == RPC_AUTH_NULL)\n\t\t\tfound_auth_null = true;\n\t}\n\n\tif (found_auth_null) {\n\t\tflavor = ctx->auth_info.flavors[0];\n\t\tgoto out;\n\t}\n\n\tdfprintk(MOUNT,\n\t\t \"NFS: specified auth flavors not supported by server\\n\");\n\treturn -EACCES;\n\nout:\n\tctx->selected_flavor = flavor;\n\tdfprintk(MOUNT, \"NFS: using auth flavor %u\\n\", ctx->selected_flavor);\n\treturn 0;\n}\n\n \nstatic int nfs_request_mount(struct fs_context *fc,\n\t\t\t     struct nfs_fh *root_fh,\n\t\t\t     rpc_authflavor_t *server_authlist,\n\t\t\t     unsigned int *server_authlist_len)\n{\n\tstruct nfs_fs_context *ctx = nfs_fc2context(fc);\n\tstruct nfs_mount_request request = {\n\t\t.sap\t\t= &ctx->mount_server._address,\n\t\t.dirpath\t= ctx->nfs_server.export_path,\n\t\t.protocol\t= ctx->mount_server.protocol,\n\t\t.fh\t\t= root_fh,\n\t\t.noresvport\t= ctx->flags & NFS_MOUNT_NORESVPORT,\n\t\t.auth_flav_len\t= server_authlist_len,\n\t\t.auth_flavs\t= server_authlist,\n\t\t.net\t\t= fc->net_ns,\n\t};\n\tint status;\n\n\tif (ctx->mount_server.version == 0) {\n\t\tswitch (ctx->version) {\n\t\t\tdefault:\n\t\t\t\tctx->mount_server.version = NFS_MNT3_VERSION;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tctx->mount_server.version = NFS_MNT_VERSION;\n\t\t}\n\t}\n\trequest.version = ctx->mount_server.version;\n\n\tif (ctx->mount_server.hostname)\n\t\trequest.hostname = ctx->mount_server.hostname;\n\telse\n\t\trequest.hostname = ctx->nfs_server.hostname;\n\n\t \n\tif (ctx->mount_server.address.sa_family == AF_UNSPEC) {\n\t\tmemcpy(request.sap, &ctx->nfs_server._address,\n\t\t       ctx->nfs_server.addrlen);\n\t\tctx->mount_server.addrlen = ctx->nfs_server.addrlen;\n\t}\n\trequest.salen = ctx->mount_server.addrlen;\n\tnfs_set_port(request.sap, &ctx->mount_server.port, 0);\n\n\t \n\tstatus = nfs_mount(&request, ctx->timeo, ctx->retrans);\n\tif (status != 0) {\n\t\tdfprintk(MOUNT, \"NFS: unable to mount server %s, error %d\\n\",\n\t\t\t\trequest.hostname, status);\n\t\treturn status;\n\t}\n\n\treturn 0;\n}\n\nstatic struct nfs_server *nfs_try_mount_request(struct fs_context *fc)\n{\n\tstruct nfs_fs_context *ctx = nfs_fc2context(fc);\n\tint status;\n\tunsigned int i;\n\tbool tried_auth_unix = false;\n\tbool auth_null_in_list = false;\n\tstruct nfs_server *server = ERR_PTR(-EACCES);\n\trpc_authflavor_t authlist[NFS_MAX_SECFLAVORS];\n\tunsigned int authlist_len = ARRAY_SIZE(authlist);\n\n\tstatus = nfs_request_mount(fc, ctx->mntfh, authlist, &authlist_len);\n\tif (status)\n\t\treturn ERR_PTR(status);\n\n\t \n\tif (ctx->auth_info.flavor_len > 0) {\n\t\tstatus = nfs_verify_authflavors(ctx, authlist, authlist_len);\n\t\tdfprintk(MOUNT, \"NFS: using auth flavor %u\\n\",\n\t\t\t ctx->selected_flavor);\n\t\tif (status)\n\t\t\treturn ERR_PTR(status);\n\t\treturn ctx->nfs_mod->rpc_ops->create_server(fc);\n\t}\n\n\t \n\tfor (i = 0; i < authlist_len; ++i) {\n\t\trpc_authflavor_t flavor;\n\t\tstruct rpcsec_gss_info info;\n\n\t\tflavor = authlist[i];\n\t\tswitch (flavor) {\n\t\tcase RPC_AUTH_UNIX:\n\t\t\ttried_auth_unix = true;\n\t\t\tbreak;\n\t\tcase RPC_AUTH_NULL:\n\t\t\tauth_null_in_list = true;\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tif (rpcauth_get_gssinfo(flavor, &info) != 0)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\t\tdfprintk(MOUNT, \"NFS: attempting to use auth flavor %u\\n\", flavor);\n\t\tctx->selected_flavor = flavor;\n\t\tserver = ctx->nfs_mod->rpc_ops->create_server(fc);\n\t\tif (!IS_ERR(server))\n\t\t\treturn server;\n\t}\n\n\t \n\tif (tried_auth_unix || !auth_null_in_list)\n\t\treturn server;\n\n\t \n\tdfprintk(MOUNT, \"NFS: attempting to use auth flavor %u\\n\", RPC_AUTH_UNIX);\n\tctx->selected_flavor = RPC_AUTH_UNIX;\n\treturn ctx->nfs_mod->rpc_ops->create_server(fc);\n}\n\nint nfs_try_get_tree(struct fs_context *fc)\n{\n\tstruct nfs_fs_context *ctx = nfs_fc2context(fc);\n\n\tif (ctx->need_mount)\n\t\tctx->server = nfs_try_mount_request(fc);\n\telse\n\t\tctx->server = ctx->nfs_mod->rpc_ops->create_server(fc);\n\n\treturn nfs_get_tree_common(fc);\n}\nEXPORT_SYMBOL_GPL(nfs_try_get_tree);\n\n\n#define NFS_REMOUNT_CMP_FLAGMASK ~(NFS_MOUNT_INTR \\\n\t\t| NFS_MOUNT_SECURE \\\n\t\t| NFS_MOUNT_TCP \\\n\t\t| NFS_MOUNT_VER3 \\\n\t\t| NFS_MOUNT_KERBEROS \\\n\t\t| NFS_MOUNT_NONLM \\\n\t\t| NFS_MOUNT_BROKEN_SUID \\\n\t\t| NFS_MOUNT_STRICTLOCK \\\n\t\t| NFS_MOUNT_LEGACY_INTERFACE)\n\n#define NFS_MOUNT_CMP_FLAGMASK (NFS_REMOUNT_CMP_FLAGMASK & \\\n\t\t~(NFS_MOUNT_UNSHARED | NFS_MOUNT_NORESVPORT))\n\nstatic int\nnfs_compare_remount_data(struct nfs_server *nfss,\n\t\t\t struct nfs_fs_context *ctx)\n{\n\tif ((ctx->flags ^ nfss->flags) & NFS_REMOUNT_CMP_FLAGMASK ||\n\t    ctx->rsize != nfss->rsize ||\n\t    ctx->wsize != nfss->wsize ||\n\t    ctx->version != nfss->nfs_client->rpc_ops->version ||\n\t    ctx->minorversion != nfss->nfs_client->cl_minorversion ||\n\t    ctx->retrans != nfss->client->cl_timeout->to_retries ||\n\t    !nfs_auth_info_match(&ctx->auth_info, nfss->client->cl_auth->au_flavor) ||\n\t    ctx->acregmin != nfss->acregmin / HZ ||\n\t    ctx->acregmax != nfss->acregmax / HZ ||\n\t    ctx->acdirmin != nfss->acdirmin / HZ ||\n\t    ctx->acdirmax != nfss->acdirmax / HZ ||\n\t    ctx->timeo != (10U * nfss->client->cl_timeout->to_initval / HZ) ||\n\t    (ctx->options & NFS_OPTION_FSCACHE) != (nfss->options & NFS_OPTION_FSCACHE) ||\n\t    ctx->nfs_server.port != nfss->port ||\n\t    ctx->nfs_server.addrlen != nfss->nfs_client->cl_addrlen ||\n\t    !rpc_cmp_addr((struct sockaddr *)&ctx->nfs_server.address,\n\t\t\t  (struct sockaddr *)&nfss->nfs_client->cl_addr))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nint nfs_reconfigure(struct fs_context *fc)\n{\n\tstruct nfs_fs_context *ctx = nfs_fc2context(fc);\n\tstruct super_block *sb = fc->root->d_sb;\n\tstruct nfs_server *nfss = sb->s_fs_info;\n\tint ret;\n\n\tsync_filesystem(sb);\n\n\t \n\tif (ctx->skip_reconfig_option_check)\n\t\treturn 0;\n\n\t \n\tif (ctx->flags & NFS_MOUNT_NOAC) {\n\t\tfc->sb_flags |= SB_SYNCHRONOUS;\n\t\tfc->sb_flags_mask |= SB_SYNCHRONOUS;\n\t}\n\n\t \n\tret = nfs_compare_remount_data(nfss, ctx);\n\tif (ret)\n\t\treturn ret;\n\n\treturn nfs_probe_server(nfss, NFS_FH(d_inode(fc->root)));\n}\nEXPORT_SYMBOL_GPL(nfs_reconfigure);\n\n \nstatic void nfs_fill_super(struct super_block *sb, struct nfs_fs_context *ctx)\n{\n\tstruct nfs_server *server = NFS_SB(sb);\n\n\tsb->s_blocksize_bits = 0;\n\tsb->s_blocksize = 0;\n\tsb->s_xattr = server->nfs_client->cl_nfs_mod->xattr;\n\tsb->s_op = server->nfs_client->cl_nfs_mod->sops;\n\tif (ctx->bsize)\n\t\tsb->s_blocksize = nfs_block_size(ctx->bsize, &sb->s_blocksize_bits);\n\n\tswitch (server->nfs_client->rpc_ops->version) {\n\tcase 2:\n\t\tsb->s_time_gran = 1000;\n\t\tsb->s_time_min = 0;\n\t\tsb->s_time_max = U32_MAX;\n\t\tbreak;\n\tcase 3:\n\t\t \n\t\tsb->s_flags |= SB_POSIXACL;\n\t\tsb->s_time_gran = 1;\n\t\tsb->s_time_min = 0;\n\t\tsb->s_time_max = U32_MAX;\n\t\tsb->s_export_op = &nfs_export_ops;\n\t\tbreak;\n\tcase 4:\n\t\tsb->s_flags |= SB_POSIXACL;\n\t\tsb->s_time_gran = 1;\n\t\tsb->s_time_min = S64_MIN;\n\t\tsb->s_time_max = S64_MAX;\n\t\tif (server->caps & NFS_CAP_ATOMIC_OPEN_V1)\n\t\t\tsb->s_export_op = &nfs_export_ops;\n\t\tbreak;\n\t}\n\n\tsb->s_magic = NFS_SUPER_MAGIC;\n\n\t \n\tsnprintf(sb->s_id, sizeof(sb->s_id),\n\t\t \"%u:%u\", MAJOR(sb->s_dev), MINOR(sb->s_dev));\n\n\tif (sb->s_blocksize == 0)\n\t\tsb->s_blocksize = nfs_block_bits(server->wsize,\n\t\t\t\t\t\t &sb->s_blocksize_bits);\n\n\tnfs_super_set_maxbytes(sb, server->maxfilesize);\n\tnfs_sysfs_move_server_to_sb(sb);\n\tserver->has_sec_mnt_opts = ctx->has_sec_mnt_opts;\n}\n\nstatic int nfs_compare_mount_options(const struct super_block *s, const struct nfs_server *b,\n\t\t\t\t     const struct fs_context *fc)\n{\n\tconst struct nfs_server *a = s->s_fs_info;\n\tconst struct rpc_clnt *clnt_a = a->client;\n\tconst struct rpc_clnt *clnt_b = b->client;\n\n\tif ((s->s_flags & NFS_SB_MASK) != (fc->sb_flags & NFS_SB_MASK))\n\t\tgoto Ebusy;\n\tif (a->nfs_client != b->nfs_client)\n\t\tgoto Ebusy;\n\tif ((a->flags ^ b->flags) & NFS_MOUNT_CMP_FLAGMASK)\n\t\tgoto Ebusy;\n\tif (a->wsize != b->wsize)\n\t\tgoto Ebusy;\n\tif (a->rsize != b->rsize)\n\t\tgoto Ebusy;\n\tif (a->acregmin != b->acregmin)\n\t\tgoto Ebusy;\n\tif (a->acregmax != b->acregmax)\n\t\tgoto Ebusy;\n\tif (a->acdirmin != b->acdirmin)\n\t\tgoto Ebusy;\n\tif (a->acdirmax != b->acdirmax)\n\t\tgoto Ebusy;\n\tif (clnt_a->cl_auth->au_flavor != clnt_b->cl_auth->au_flavor)\n\t\tgoto Ebusy;\n\treturn 1;\nEbusy:\n\treturn 0;\n}\n\nstatic int nfs_set_super(struct super_block *s, struct fs_context *fc)\n{\n\tstruct nfs_server *server = fc->s_fs_info;\n\tint ret;\n\n\ts->s_d_op = server->nfs_client->rpc_ops->dentry_ops;\n\tret = set_anon_super(s, server);\n\tif (ret == 0)\n\t\tserver->s_dev = s->s_dev;\n\treturn ret;\n}\n\nstatic int nfs_compare_super_address(struct nfs_server *server1,\n\t\t\t\t     struct nfs_server *server2)\n{\n\tstruct sockaddr *sap1, *sap2;\n\tstruct rpc_xprt *xprt1 = server1->client->cl_xprt;\n\tstruct rpc_xprt *xprt2 = server2->client->cl_xprt;\n\n\tif (!net_eq(xprt1->xprt_net, xprt2->xprt_net))\n\t\treturn 0;\n\n\tsap1 = (struct sockaddr *)&server1->nfs_client->cl_addr;\n\tsap2 = (struct sockaddr *)&server2->nfs_client->cl_addr;\n\n\tif (sap1->sa_family != sap2->sa_family)\n\t\treturn 0;\n\n\tswitch (sap1->sa_family) {\n\tcase AF_INET: {\n\t\tstruct sockaddr_in *sin1 = (struct sockaddr_in *)sap1;\n\t\tstruct sockaddr_in *sin2 = (struct sockaddr_in *)sap2;\n\t\tif (sin1->sin_addr.s_addr != sin2->sin_addr.s_addr)\n\t\t\treturn 0;\n\t\tif (sin1->sin_port != sin2->sin_port)\n\t\t\treturn 0;\n\t\tbreak;\n\t}\n\tcase AF_INET6: {\n\t\tstruct sockaddr_in6 *sin1 = (struct sockaddr_in6 *)sap1;\n\t\tstruct sockaddr_in6 *sin2 = (struct sockaddr_in6 *)sap2;\n\t\tif (!ipv6_addr_equal(&sin1->sin6_addr, &sin2->sin6_addr))\n\t\t\treturn 0;\n\t\tif (sin1->sin6_port != sin2->sin6_port)\n\t\t\treturn 0;\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int nfs_compare_userns(const struct nfs_server *old,\n\t\tconst struct nfs_server *new)\n{\n\tconst struct user_namespace *oldns = &init_user_ns;\n\tconst struct user_namespace *newns = &init_user_ns;\n\n\tif (old->client && old->client->cl_cred)\n\t\toldns = old->client->cl_cred->user_ns;\n\tif (new->client && new->client->cl_cred)\n\t\tnewns = new->client->cl_cred->user_ns;\n\tif (oldns != newns)\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic int nfs_compare_super(struct super_block *sb, struct fs_context *fc)\n{\n\tstruct nfs_server *server = fc->s_fs_info, *old = NFS_SB(sb);\n\n\tif (!nfs_compare_super_address(old, server))\n\t\treturn 0;\n\t \n\tif (old->flags & NFS_MOUNT_UNSHARED)\n\t\treturn 0;\n\tif (memcmp(&old->fsid, &server->fsid, sizeof(old->fsid)) != 0)\n\t\treturn 0;\n\tif (!nfs_compare_userns(old, server))\n\t\treturn 0;\n\tif ((old->has_sec_mnt_opts || fc->security) &&\n\t\t\tsecurity_sb_mnt_opts_compat(sb, fc->security))\n\t\treturn 0;\n\treturn nfs_compare_mount_options(sb, server, fc);\n}\n\n#ifdef CONFIG_NFS_FSCACHE\nstatic int nfs_get_cache_cookie(struct super_block *sb,\n\t\t\t\tstruct nfs_fs_context *ctx)\n{\n\tstruct nfs_server *nfss = NFS_SB(sb);\n\tchar *uniq = NULL;\n\tint ulen = 0;\n\n\tnfss->fscache = NULL;\n\n\tif (!ctx)\n\t\treturn 0;\n\n\tif (ctx->clone_data.sb) {\n\t\tstruct nfs_server *mnt_s = NFS_SB(ctx->clone_data.sb);\n\t\tif (!(mnt_s->options & NFS_OPTION_FSCACHE))\n\t\t\treturn 0;\n\t\tif (mnt_s->fscache_uniq) {\n\t\t\tuniq = mnt_s->fscache_uniq;\n\t\t\tulen = strlen(uniq);\n\t\t}\n\t} else {\n\t\tif (!(ctx->options & NFS_OPTION_FSCACHE))\n\t\t\treturn 0;\n\t\tif (ctx->fscache_uniq) {\n\t\t\tuniq = ctx->fscache_uniq;\n\t\t\tulen = strlen(ctx->fscache_uniq);\n\t\t}\n\t}\n\n\treturn nfs_fscache_get_super_cookie(sb, uniq, ulen);\n}\n#else\nstatic int nfs_get_cache_cookie(struct super_block *sb,\n\t\t\t\tstruct nfs_fs_context *ctx)\n{\n\treturn 0;\n}\n#endif\n\nint nfs_get_tree_common(struct fs_context *fc)\n{\n\tstruct nfs_fs_context *ctx = nfs_fc2context(fc);\n\tstruct super_block *s;\n\tint (*compare_super)(struct super_block *, struct fs_context *) = nfs_compare_super;\n\tstruct nfs_server *server = ctx->server;\n\tint error;\n\n\tctx->server = NULL;\n\tif (IS_ERR(server))\n\t\treturn PTR_ERR(server);\n\n\tif (server->flags & NFS_MOUNT_UNSHARED)\n\t\tcompare_super = NULL;\n\n\t \n\tif (server->flags & NFS_MOUNT_NOAC)\n\t\tfc->sb_flags |= SB_SYNCHRONOUS;\n\n\tif (ctx->clone_data.sb)\n\t\tif (ctx->clone_data.sb->s_flags & SB_SYNCHRONOUS)\n\t\t\tfc->sb_flags |= SB_SYNCHRONOUS;\n\n\t \n\tfc->s_fs_info = server;\n\ts = sget_fc(fc, compare_super, nfs_set_super);\n\tfc->s_fs_info = NULL;\n\tif (IS_ERR(s)) {\n\t\terror = PTR_ERR(s);\n\t\tnfs_errorf(fc, \"NFS: Couldn't get superblock\");\n\t\tgoto out_err_nosb;\n\t}\n\n\tif (s->s_fs_info != server) {\n\t\tnfs_free_server(server);\n\t\tserver = NULL;\n\t} else {\n\t\terror = super_setup_bdi_name(s, \"%u:%u\", MAJOR(server->s_dev),\n\t\t\t\t\t     MINOR(server->s_dev));\n\t\tif (error)\n\t\t\tgoto error_splat_super;\n\t\ts->s_bdi->io_pages = server->rpages;\n\t\tserver->super = s;\n\t}\n\n\tif (!s->s_root) {\n\t\tunsigned bsize = ctx->clone_data.inherited_bsize;\n\t\t \n\t\tnfs_fill_super(s, ctx);\n\t\tif (bsize) {\n\t\t\ts->s_blocksize_bits = bsize;\n\t\t\ts->s_blocksize = 1U << bsize;\n\t\t}\n\t\terror = nfs_get_cache_cookie(s, ctx);\n\t\tif (error < 0)\n\t\t\tgoto error_splat_super;\n\t}\n\n\terror = nfs_get_root(s, fc);\n\tif (error < 0) {\n\t\tnfs_errorf(fc, \"NFS: Couldn't get root dentry\");\n\t\tgoto error_splat_super;\n\t}\n\n\ts->s_flags |= SB_ACTIVE;\n\terror = 0;\n\nout:\n\treturn error;\n\nout_err_nosb:\n\tnfs_free_server(server);\n\tgoto out;\nerror_splat_super:\n\tdeactivate_locked_super(s);\n\tgoto out;\n}\n\n \nvoid nfs_kill_super(struct super_block *s)\n{\n\tstruct nfs_server *server = NFS_SB(s);\n\n\tnfs_sysfs_move_sb_to_server(server);\n\tkill_anon_super(s);\n\n\tnfs_fscache_release_super_cookie(s);\n\n\tnfs_free_server(server);\n}\nEXPORT_SYMBOL_GPL(nfs_kill_super);\n\n#if IS_ENABLED(CONFIG_NFS_V4)\n\n \nunsigned int nfs_callback_set_tcpport;\nunsigned short nfs_callback_nr_threads;\n \nunsigned int nfs_idmap_cache_timeout = 600;\n \nbool nfs4_disable_idmapping = true;\nunsigned short max_session_slots = NFS4_DEF_SLOT_TABLE_SIZE;\nunsigned short max_session_cb_slots = NFS4_DEF_CB_SLOT_TABLE_SIZE;\nunsigned short send_implementation_id = 1;\nchar nfs4_client_id_uniquifier[NFS4_CLIENT_ID_UNIQ_LEN] = \"\";\nbool recover_lost_locks = false;\n\nEXPORT_SYMBOL_GPL(nfs_callback_nr_threads);\nEXPORT_SYMBOL_GPL(nfs_callback_set_tcpport);\nEXPORT_SYMBOL_GPL(nfs_idmap_cache_timeout);\nEXPORT_SYMBOL_GPL(nfs4_disable_idmapping);\nEXPORT_SYMBOL_GPL(max_session_slots);\nEXPORT_SYMBOL_GPL(max_session_cb_slots);\nEXPORT_SYMBOL_GPL(send_implementation_id);\nEXPORT_SYMBOL_GPL(nfs4_client_id_uniquifier);\nEXPORT_SYMBOL_GPL(recover_lost_locks);\n\n#define NFS_CALLBACK_MAXPORTNR (65535U)\n\nstatic int param_set_portnr(const char *val, const struct kernel_param *kp)\n{\n\tunsigned long num;\n\tint ret;\n\n\tif (!val)\n\t\treturn -EINVAL;\n\tret = kstrtoul(val, 0, &num);\n\tif (ret || num > NFS_CALLBACK_MAXPORTNR)\n\t\treturn -EINVAL;\n\t*((unsigned int *)kp->arg) = num;\n\treturn 0;\n}\nstatic const struct kernel_param_ops param_ops_portnr = {\n\t.set = param_set_portnr,\n\t.get = param_get_uint,\n};\n#define param_check_portnr(name, p) __param_check(name, p, unsigned int)\n\nmodule_param_named(callback_tcpport, nfs_callback_set_tcpport, portnr, 0644);\nmodule_param_named(callback_nr_threads, nfs_callback_nr_threads, ushort, 0644);\nMODULE_PARM_DESC(callback_nr_threads, \"Number of threads that will be \"\n\t\t\"assigned to the NFSv4 callback channels.\");\nmodule_param(nfs_idmap_cache_timeout, int, 0644);\nmodule_param(nfs4_disable_idmapping, bool, 0644);\nmodule_param_string(nfs4_unique_id, nfs4_client_id_uniquifier,\n\t\t\tNFS4_CLIENT_ID_UNIQ_LEN, 0600);\nMODULE_PARM_DESC(nfs4_disable_idmapping,\n\t\t\"Turn off NFSv4 idmapping when using 'sec=sys'\");\nmodule_param(max_session_slots, ushort, 0644);\nMODULE_PARM_DESC(max_session_slots, \"Maximum number of outstanding NFSv4.1 \"\n\t\t\"requests the client will negotiate\");\nmodule_param(max_session_cb_slots, ushort, 0644);\nMODULE_PARM_DESC(max_session_cb_slots, \"Maximum number of parallel NFSv4.1 \"\n\t\t\"callbacks the client will process for a given server\");\nmodule_param(send_implementation_id, ushort, 0644);\nMODULE_PARM_DESC(send_implementation_id,\n\t\t\"Send implementation ID with NFSv4.1 exchange_id\");\nMODULE_PARM_DESC(nfs4_unique_id, \"nfs_client_id4 uniquifier string\");\n\nmodule_param(recover_lost_locks, bool, 0644);\nMODULE_PARM_DESC(recover_lost_locks,\n\t\t \"If the server reports that a lock might be lost, \"\n\t\t \"try to recover it risking data corruption.\");\n\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}