{
  "module_name": "callback.h",
  "hash_id": "f61871ca8151c13eded0cfff6fe71965eaf53c7e5bdca6266fdf37ce8134b640",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfs/callback.h",
  "human_readable_source": " \n \n#ifndef __LINUX_FS_NFS_CALLBACK_H\n#define __LINUX_FS_NFS_CALLBACK_H\n#include <linux/sunrpc/svc.h>\n\n#define NFS4_CALLBACK 0x40000000\n#define NFS4_CALLBACK_XDRSIZE 2048\n#define NFS4_CALLBACK_BUFSIZE (1024 + NFS4_CALLBACK_XDRSIZE)\n\nenum nfs4_callback_procnum {\n\tCB_NULL = 0,\n\tCB_COMPOUND = 1,\n};\n\nenum nfs4_callback_opnum {\n\tOP_CB_GETATTR = 3,\n\tOP_CB_RECALL  = 4,\n \n\tOP_CB_LAYOUTRECALL  = 5,\n\tOP_CB_NOTIFY        = 6,\n\tOP_CB_PUSH_DELEG    = 7,\n\tOP_CB_RECALL_ANY    = 8,\n\tOP_CB_RECALLABLE_OBJ_AVAIL = 9,\n\tOP_CB_RECALL_SLOT   = 10,\n\tOP_CB_SEQUENCE      = 11,\n\tOP_CB_WANTS_CANCELLED = 12,\n\tOP_CB_NOTIFY_LOCK   = 13,\n\tOP_CB_NOTIFY_DEVICEID = 14,\n \n\tOP_CB_OFFLOAD = 15,\n\tOP_CB_ILLEGAL = 10044,\n};\n\nstruct nfs4_slot;\nstruct cb_process_state {\n\t__be32\t\t\tdrc_status;\n\tstruct nfs_client\t*clp;\n\tstruct nfs4_slot\t*slot;\n\tu32\t\t\tminorversion;\n\tstruct net\t\t*net;\n};\n\nstruct cb_compound_hdr_arg {\n\tunsigned int taglen;\n\tconst char *tag;\n\tunsigned int minorversion;\n\tunsigned int cb_ident;  \n\tunsigned nops;\n};\n\nstruct cb_compound_hdr_res {\n\t__be32 *status;\n\tunsigned int taglen;\n\tconst char *tag;\n\t__be32 *nops;\n};\n\nstruct cb_getattrargs {\n\tstruct nfs_fh fh;\n\tuint32_t bitmap[2];\n};\n\nstruct cb_getattrres {\n\t__be32 status;\n\tuint32_t bitmap[2];\n\tuint64_t size;\n\tuint64_t change_attr;\n\tstruct timespec64 ctime;\n\tstruct timespec64 mtime;\n};\n\nstruct cb_recallargs {\n\tstruct nfs_fh fh;\n\tnfs4_stateid stateid;\n\tuint32_t truncate;\n};\n\n#if defined(CONFIG_NFS_V4_1)\n\nstruct referring_call {\n\tuint32_t\t\t\trc_sequenceid;\n\tuint32_t\t\t\trc_slotid;\n};\n\nstruct referring_call_list {\n\tstruct nfs4_sessionid\t\trcl_sessionid;\n\tuint32_t\t\t\trcl_nrefcalls;\n\tstruct referring_call \t\t*rcl_refcalls;\n};\n\nstruct cb_sequenceargs {\n\tstruct sockaddr\t\t\t*csa_addr;\n\tstruct nfs4_sessionid\t\tcsa_sessionid;\n\tuint32_t\t\t\tcsa_sequenceid;\n\tuint32_t\t\t\tcsa_slotid;\n\tuint32_t\t\t\tcsa_highestslotid;\n\tuint32_t\t\t\tcsa_cachethis;\n\tuint32_t\t\t\tcsa_nrclists;\n\tstruct referring_call_list\t*csa_rclists;\n};\n\nstruct cb_sequenceres {\n\t__be32\t\t\t\tcsr_status;\n\tstruct nfs4_sessionid\t\tcsr_sessionid;\n\tuint32_t\t\t\tcsr_sequenceid;\n\tuint32_t\t\t\tcsr_slotid;\n\tuint32_t\t\t\tcsr_highestslotid;\n\tuint32_t\t\t\tcsr_target_highestslotid;\n};\n\nextern __be32 nfs4_callback_sequence(void *argp, void *resp,\n\t\t\t\t       struct cb_process_state *cps);\n\n#define RCA4_TYPE_MASK_RDATA_DLG\t0\n#define RCA4_TYPE_MASK_WDATA_DLG\t1\n#define RCA4_TYPE_MASK_DIR_DLG         2\n#define RCA4_TYPE_MASK_FILE_LAYOUT     3\n#define RCA4_TYPE_MASK_BLK_LAYOUT      4\n#define RCA4_TYPE_MASK_OBJ_LAYOUT_MIN  8\n#define RCA4_TYPE_MASK_OBJ_LAYOUT_MAX  9\n#define RCA4_TYPE_MASK_OTHER_LAYOUT_MIN 12\n#define RCA4_TYPE_MASK_OTHER_LAYOUT_MAX 15\n#define PNFS_FF_RCA4_TYPE_MASK_READ 16\n#define PNFS_FF_RCA4_TYPE_MASK_RW 17\n#define RCA4_TYPE_MASK_ALL 0x3f31f\n\nstruct cb_recallanyargs {\n\tuint32_t\tcraa_objs_to_keep;\n\tuint32_t\tcraa_type_mask;\n};\n\nextern __be32 nfs4_callback_recallany(void *argp, void *resp,\n\t\t\t\t\tstruct cb_process_state *cps);\n\nstruct cb_recallslotargs {\n\tuint32_t\tcrsa_target_highest_slotid;\n};\nextern __be32 nfs4_callback_recallslot(void *argp, void *resp,\n\t\t\t\t\t struct cb_process_state *cps);\n\nstruct cb_layoutrecallargs {\n\tuint32_t\t\tcbl_recall_type;\n\tuint32_t\t\tcbl_layout_type;\n\tuint32_t\t\tcbl_layoutchanged;\n\tunion {\n\t\tstruct {\n\t\t\tstruct nfs_fh\t\tcbl_fh;\n\t\t\tstruct pnfs_layout_range cbl_range;\n\t\t\tnfs4_stateid\t\tcbl_stateid;\n\t\t};\n\t\tstruct nfs_fsid\t\tcbl_fsid;\n\t};\n};\n\nextern __be32 nfs4_callback_layoutrecall(void *argp, void *resp,\n\t\tstruct cb_process_state *cps);\n\nstruct cb_devicenotifyitem {\n\tuint32_t\t\tcbd_notify_type;\n\tuint32_t\t\tcbd_layout_type;\n\tstruct nfs4_deviceid\tcbd_dev_id;\n\tuint32_t\t\tcbd_immediate;\n};\n\nstruct cb_devicenotifyargs {\n\tuint32_t\t\t\t ndevs;\n\tstruct cb_devicenotifyitem\t *devs;\n};\n\nextern __be32 nfs4_callback_devicenotify(void *argp, void *resp,\n\t\tstruct cb_process_state *cps);\n\nstruct cb_notify_lock_args {\n\tstruct nfs_fh\t\t\tcbnl_fh;\n\tstruct nfs_lowner\t\tcbnl_owner;\n\tbool\t\t\t\tcbnl_valid;\n};\n\nextern __be32 nfs4_callback_notify_lock(void *argp, void *resp,\n\t\t\t\t\t struct cb_process_state *cps);\n#endif  \n#ifdef CONFIG_NFS_V4_2\nstruct cb_offloadargs {\n\tstruct nfs_fh\t\tcoa_fh;\n\tnfs4_stateid\t\tcoa_stateid;\n\tuint32_t\t\terror;\n\tuint64_t\t\twr_count;\n\tstruct nfs_writeverf\twr_writeverf;\n};\n\nextern __be32 nfs4_callback_offload(void *args, void *dummy,\n\t\t\t\t    struct cb_process_state *cps);\n#endif  \nextern int check_gss_callback_principal(struct nfs_client *, struct svc_rqst *);\nextern __be32 nfs4_callback_getattr(void *argp, void *resp,\n\t\t\t\t    struct cb_process_state *cps);\nextern __be32 nfs4_callback_recall(void *argp, void *resp,\n\t\t\t\t   struct cb_process_state *cps);\n#if IS_ENABLED(CONFIG_NFS_V4)\nextern int nfs_callback_up(u32 minorversion, struct rpc_xprt *xprt);\nextern void nfs_callback_down(int minorversion, struct net *net);\n#endif  \n \n#define NFS41_BC_MIN_CALLBACKS 1\n#define NFS41_BC_MAX_CALLBACKS 1\n\n#define NFS4_MIN_NR_CALLBACK_THREADS 1\n\nextern unsigned int nfs_callback_set_tcpport;\nextern unsigned short nfs_callback_nr_threads;\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}