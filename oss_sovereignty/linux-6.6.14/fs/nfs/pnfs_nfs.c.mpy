{
  "module_name": "pnfs_nfs.c",
  "hash_id": "d15d8ea31da064cb24c088d0f766d7327d9c3a0e0751c40ac0e2e844246189cc",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfs/pnfs_nfs.c",
  "human_readable_source": "\n \n\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/module.h>\n\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"pnfs.h\"\n\n#define NFSDBG_FACILITY\t\tNFSDBG_PNFS\n\nvoid pnfs_generic_rw_release(void *data)\n{\n\tstruct nfs_pgio_header *hdr = data;\n\n\tnfs_put_client(hdr->ds_clp);\n\thdr->mds_ops->rpc_release(data);\n}\nEXPORT_SYMBOL_GPL(pnfs_generic_rw_release);\n\n \nvoid pnfs_generic_prepare_to_resend_writes(struct nfs_commit_data *data)\n{\n\tstruct nfs_writeverf *verf = data->res.verf;\n\n\tdata->task.tk_status = 0;\n\tmemset(&verf->verifier, 0, sizeof(verf->verifier));\n\tverf->committed = NFS_UNSTABLE;\n}\nEXPORT_SYMBOL_GPL(pnfs_generic_prepare_to_resend_writes);\n\nvoid pnfs_generic_write_commit_done(struct rpc_task *task, void *data)\n{\n\tstruct nfs_commit_data *wdata = data;\n\n\t \n\twdata->mds_ops->rpc_call_done(task, data);\n}\nEXPORT_SYMBOL_GPL(pnfs_generic_write_commit_done);\n\nvoid pnfs_generic_commit_release(void *calldata)\n{\n\tstruct nfs_commit_data *data = calldata;\n\n\tdata->completion_ops->completion(data);\n\tpnfs_put_lseg(data->lseg);\n\tnfs_put_client(data->ds_clp);\n\tnfs_commitdata_release(data);\n}\nEXPORT_SYMBOL_GPL(pnfs_generic_commit_release);\n\nstatic struct pnfs_layout_segment *\npnfs_free_bucket_lseg(struct pnfs_commit_bucket *bucket)\n{\n\tif (list_empty(&bucket->committing) && list_empty(&bucket->written)) {\n\t\tstruct pnfs_layout_segment *freeme = bucket->lseg;\n\t\tbucket->lseg = NULL;\n\t\treturn freeme;\n\t}\n\treturn NULL;\n}\n\n \nvoid\npnfs_generic_clear_request_commit(struct nfs_page *req,\n\t\t\t\t  struct nfs_commit_info *cinfo)\n{\n\tstruct pnfs_commit_bucket *bucket = NULL;\n\n\tif (!test_and_clear_bit(PG_COMMIT_TO_DS, &req->wb_flags))\n\t\tgoto out;\n\tcinfo->ds->nwritten--;\n\tif (list_is_singular(&req->wb_list))\n\t\tbucket = list_first_entry(&req->wb_list,\n\t\t\t\t\t  struct pnfs_commit_bucket, written);\nout:\n\tnfs_request_remove_commit_list(req, cinfo);\n\tif (bucket)\n\t\tpnfs_put_lseg(pnfs_free_bucket_lseg(bucket));\n}\nEXPORT_SYMBOL_GPL(pnfs_generic_clear_request_commit);\n\nstruct pnfs_commit_array *\npnfs_alloc_commit_array(size_t n, gfp_t gfp_flags)\n{\n\tstruct pnfs_commit_array *p;\n\tstruct pnfs_commit_bucket *b;\n\n\tp = kmalloc(struct_size(p, buckets, n), gfp_flags);\n\tif (!p)\n\t\treturn NULL;\n\tp->nbuckets = n;\n\tINIT_LIST_HEAD(&p->cinfo_list);\n\tINIT_LIST_HEAD(&p->lseg_list);\n\tp->lseg = NULL;\n\tfor (b = &p->buckets[0]; n != 0; b++, n--) {\n\t\tINIT_LIST_HEAD(&b->written);\n\t\tINIT_LIST_HEAD(&b->committing);\n\t\tb->lseg = NULL;\n\t\tb->direct_verf.committed = NFS_INVALID_STABLE_HOW;\n\t}\n\treturn p;\n}\nEXPORT_SYMBOL_GPL(pnfs_alloc_commit_array);\n\nvoid\npnfs_free_commit_array(struct pnfs_commit_array *p)\n{\n\tkfree_rcu(p, rcu);\n}\nEXPORT_SYMBOL_GPL(pnfs_free_commit_array);\n\nstatic struct pnfs_commit_array *\npnfs_find_commit_array_by_lseg(struct pnfs_ds_commit_info *fl_cinfo,\n\t\tstruct pnfs_layout_segment *lseg)\n{\n\tstruct pnfs_commit_array *array;\n\n\tlist_for_each_entry_rcu(array, &fl_cinfo->commits, cinfo_list) {\n\t\tif (array->lseg == lseg)\n\t\t\treturn array;\n\t}\n\treturn NULL;\n}\n\nstruct pnfs_commit_array *\npnfs_add_commit_array(struct pnfs_ds_commit_info *fl_cinfo,\n\t\tstruct pnfs_commit_array *new,\n\t\tstruct pnfs_layout_segment *lseg)\n{\n\tstruct pnfs_commit_array *array;\n\n\tarray = pnfs_find_commit_array_by_lseg(fl_cinfo, lseg);\n\tif (array)\n\t\treturn array;\n\tnew->lseg = lseg;\n\trefcount_set(&new->refcount, 1);\n\tlist_add_rcu(&new->cinfo_list, &fl_cinfo->commits);\n\tlist_add(&new->lseg_list, &lseg->pls_commits);\n\treturn new;\n}\nEXPORT_SYMBOL_GPL(pnfs_add_commit_array);\n\nstatic struct pnfs_commit_array *\npnfs_lookup_commit_array(struct pnfs_ds_commit_info *fl_cinfo,\n\t\tstruct pnfs_layout_segment *lseg)\n{\n\tstruct pnfs_commit_array *array;\n\n\trcu_read_lock();\n\tarray = pnfs_find_commit_array_by_lseg(fl_cinfo, lseg);\n\tif (!array) {\n\t\trcu_read_unlock();\n\t\tfl_cinfo->ops->setup_ds_info(fl_cinfo, lseg);\n\t\trcu_read_lock();\n\t\tarray = pnfs_find_commit_array_by_lseg(fl_cinfo, lseg);\n\t}\n\trcu_read_unlock();\n\treturn array;\n}\n\nstatic void\npnfs_release_commit_array_locked(struct pnfs_commit_array *array)\n{\n\tlist_del_rcu(&array->cinfo_list);\n\tlist_del(&array->lseg_list);\n\tpnfs_free_commit_array(array);\n}\n\nstatic void\npnfs_put_commit_array_locked(struct pnfs_commit_array *array)\n{\n\tif (refcount_dec_and_test(&array->refcount))\n\t\tpnfs_release_commit_array_locked(array);\n}\n\nstatic void\npnfs_put_commit_array(struct pnfs_commit_array *array, struct inode *inode)\n{\n\tif (refcount_dec_and_lock(&array->refcount, &inode->i_lock)) {\n\t\tpnfs_release_commit_array_locked(array);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n}\n\nstatic struct pnfs_commit_array *\npnfs_get_commit_array(struct pnfs_commit_array *array)\n{\n\tif (refcount_inc_not_zero(&array->refcount))\n\t\treturn array;\n\treturn NULL;\n}\n\nstatic void\npnfs_remove_and_free_commit_array(struct pnfs_commit_array *array)\n{\n\tarray->lseg = NULL;\n\tlist_del_init(&array->lseg_list);\n\tpnfs_put_commit_array_locked(array);\n}\n\nvoid\npnfs_generic_ds_cinfo_release_lseg(struct pnfs_ds_commit_info *fl_cinfo,\n\t\tstruct pnfs_layout_segment *lseg)\n{\n\tstruct pnfs_commit_array *array, *tmp;\n\n\tlist_for_each_entry_safe(array, tmp, &lseg->pls_commits, lseg_list)\n\t\tpnfs_remove_and_free_commit_array(array);\n}\nEXPORT_SYMBOL_GPL(pnfs_generic_ds_cinfo_release_lseg);\n\nvoid\npnfs_generic_ds_cinfo_destroy(struct pnfs_ds_commit_info *fl_cinfo)\n{\n\tstruct pnfs_commit_array *array, *tmp;\n\n\tlist_for_each_entry_safe(array, tmp, &fl_cinfo->commits, cinfo_list)\n\t\tpnfs_remove_and_free_commit_array(array);\n}\nEXPORT_SYMBOL_GPL(pnfs_generic_ds_cinfo_destroy);\n\n \nstatic int\npnfs_bucket_scan_ds_commit_list(struct pnfs_commit_bucket *bucket,\n\t\t\t\tstruct nfs_commit_info *cinfo,\n\t\t\t\tint max)\n{\n\tstruct list_head *src = &bucket->written;\n\tstruct list_head *dst = &bucket->committing;\n\tint ret;\n\n\tlockdep_assert_held(&NFS_I(cinfo->inode)->commit_mutex);\n\tret = nfs_scan_commit_list(src, dst, cinfo, max);\n\tif (ret) {\n\t\tcinfo->ds->nwritten -= ret;\n\t\tcinfo->ds->ncommitting += ret;\n\t}\n\treturn ret;\n}\n\nstatic int pnfs_bucket_scan_array(struct nfs_commit_info *cinfo,\n\t\t\t\t  struct pnfs_commit_bucket *buckets,\n\t\t\t\t  unsigned int nbuckets,\n\t\t\t\t  int max)\n{\n\tunsigned int i;\n\tint rv = 0, cnt;\n\n\tfor (i = 0; i < nbuckets && max != 0; i++) {\n\t\tcnt = pnfs_bucket_scan_ds_commit_list(&buckets[i], cinfo, max);\n\t\trv += cnt;\n\t\tmax -= cnt;\n\t}\n\treturn rv;\n}\n\n \nint pnfs_generic_scan_commit_lists(struct nfs_commit_info *cinfo, int max)\n{\n\tstruct pnfs_ds_commit_info *fl_cinfo = cinfo->ds;\n\tstruct pnfs_commit_array *array;\n\tint rv = 0, cnt;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(array, &fl_cinfo->commits, cinfo_list) {\n\t\tif (!array->lseg || !pnfs_get_commit_array(array))\n\t\t\tcontinue;\n\t\trcu_read_unlock();\n\t\tcnt = pnfs_bucket_scan_array(cinfo, array->buckets,\n\t\t\t\tarray->nbuckets, max);\n\t\trcu_read_lock();\n\t\tpnfs_put_commit_array(array, cinfo->inode);\n\t\trv += cnt;\n\t\tmax -= cnt;\n\t\tif (!max)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\treturn rv;\n}\nEXPORT_SYMBOL_GPL(pnfs_generic_scan_commit_lists);\n\nstatic unsigned int\npnfs_bucket_recover_commit_reqs(struct list_head *dst,\n\t\t\t        struct pnfs_commit_bucket *buckets,\n\t\t\t\tunsigned int nbuckets,\n\t\t\t\tstruct nfs_commit_info *cinfo)\n{\n\tstruct pnfs_commit_bucket *b;\n\tstruct pnfs_layout_segment *freeme;\n\tunsigned int nwritten, ret = 0;\n\tunsigned int i;\n\nrestart:\n\tfor (i = 0, b = buckets; i < nbuckets; i++, b++) {\n\t\tnwritten = nfs_scan_commit_list(&b->written, dst, cinfo, 0);\n\t\tif (!nwritten)\n\t\t\tcontinue;\n\t\tret += nwritten;\n\t\tfreeme = pnfs_free_bucket_lseg(b);\n\t\tif (freeme) {\n\t\t\tpnfs_put_lseg(freeme);\n\t\t\tgoto restart;\n\t\t}\n\t}\n\treturn ret;\n}\n\n \nvoid pnfs_generic_recover_commit_reqs(struct list_head *dst,\n\t\t\t\t      struct nfs_commit_info *cinfo)\n{\n\tstruct pnfs_ds_commit_info *fl_cinfo = cinfo->ds;\n\tstruct pnfs_commit_array *array;\n\tunsigned int nwritten;\n\n\tlockdep_assert_held(&NFS_I(cinfo->inode)->commit_mutex);\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(array, &fl_cinfo->commits, cinfo_list) {\n\t\tif (!array->lseg || !pnfs_get_commit_array(array))\n\t\t\tcontinue;\n\t\trcu_read_unlock();\n\t\tnwritten = pnfs_bucket_recover_commit_reqs(dst,\n\t\t\t\t\t\t\t   array->buckets,\n\t\t\t\t\t\t\t   array->nbuckets,\n\t\t\t\t\t\t\t   cinfo);\n\t\trcu_read_lock();\n\t\tpnfs_put_commit_array(array, cinfo->inode);\n\t\tfl_cinfo->nwritten -= nwritten;\n\t}\n\trcu_read_unlock();\n}\nEXPORT_SYMBOL_GPL(pnfs_generic_recover_commit_reqs);\n\nstatic struct nfs_page *\npnfs_bucket_search_commit_reqs(struct pnfs_commit_bucket *buckets,\n\t\t\t       unsigned int nbuckets, struct folio *folio)\n{\n\tstruct nfs_page *req;\n\tstruct pnfs_commit_bucket *b;\n\tunsigned int i;\n\n\t \n\tfor (i = 0, b = buckets; i < nbuckets; i++, b++) {\n\t\tlist_for_each_entry(req, &b->written, wb_list) {\n\t\t\tif (nfs_page_to_folio(req) == folio)\n\t\t\t\treturn req->wb_head;\n\t\t}\n\t\tlist_for_each_entry(req, &b->committing, wb_list) {\n\t\t\tif (nfs_page_to_folio(req) == folio)\n\t\t\t\treturn req->wb_head;\n\t\t}\n\t}\n\treturn NULL;\n}\n\n \nstruct nfs_page *pnfs_generic_search_commit_reqs(struct nfs_commit_info *cinfo,\n\t\t\t\t\t\t struct folio *folio)\n{\n\tstruct pnfs_ds_commit_info *fl_cinfo = cinfo->ds;\n\tstruct pnfs_commit_array *array;\n\tstruct nfs_page *req;\n\n\tlist_for_each_entry(array, &fl_cinfo->commits, cinfo_list) {\n\t\treq = pnfs_bucket_search_commit_reqs(array->buckets,\n\t\t\t\t\t\t     array->nbuckets, folio);\n\t\tif (req)\n\t\t\treturn req;\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(pnfs_generic_search_commit_reqs);\n\nstatic struct pnfs_layout_segment *\npnfs_bucket_get_committing(struct list_head *head,\n\t\t\t   struct pnfs_commit_bucket *bucket,\n\t\t\t   struct nfs_commit_info *cinfo)\n{\n\tstruct pnfs_layout_segment *lseg;\n\tstruct list_head *pos;\n\n\tlist_for_each(pos, &bucket->committing)\n\t\tcinfo->ds->ncommitting--;\n\tlist_splice_init(&bucket->committing, head);\n\tlseg = pnfs_free_bucket_lseg(bucket);\n\tif (!lseg)\n\t\tlseg = pnfs_get_lseg(bucket->lseg);\n\treturn lseg;\n}\n\nstatic struct nfs_commit_data *\npnfs_bucket_fetch_commitdata(struct pnfs_commit_bucket *bucket,\n\t\t\t     struct nfs_commit_info *cinfo)\n{\n\tstruct nfs_commit_data *data = nfs_commitdata_alloc();\n\n\tif (!data)\n\t\treturn NULL;\n\tdata->lseg = pnfs_bucket_get_committing(&data->pages, bucket, cinfo);\n\treturn data;\n}\n\nstatic void pnfs_generic_retry_commit(struct pnfs_commit_bucket *buckets,\n\t\t\t\t      unsigned int nbuckets,\n\t\t\t\t      struct nfs_commit_info *cinfo,\n\t\t\t\t      unsigned int idx)\n{\n\tstruct pnfs_commit_bucket *bucket;\n\tstruct pnfs_layout_segment *freeme;\n\tLIST_HEAD(pages);\n\n\tfor (bucket = buckets; idx < nbuckets; bucket++, idx++) {\n\t\tif (list_empty(&bucket->committing))\n\t\t\tcontinue;\n\t\tmutex_lock(&NFS_I(cinfo->inode)->commit_mutex);\n\t\tfreeme = pnfs_bucket_get_committing(&pages, bucket, cinfo);\n\t\tmutex_unlock(&NFS_I(cinfo->inode)->commit_mutex);\n\t\tnfs_retry_commit(&pages, freeme, cinfo, idx);\n\t\tpnfs_put_lseg(freeme);\n\t}\n}\n\nstatic unsigned int\npnfs_bucket_alloc_ds_commits(struct list_head *list,\n\t\t\t     struct pnfs_commit_bucket *buckets,\n\t\t\t     unsigned int nbuckets,\n\t\t\t     struct nfs_commit_info *cinfo)\n{\n\tstruct pnfs_commit_bucket *bucket;\n\tstruct nfs_commit_data *data;\n\tunsigned int i;\n\tunsigned int nreq = 0;\n\n\tfor (i = 0, bucket = buckets; i < nbuckets; i++, bucket++) {\n\t\tif (list_empty(&bucket->committing))\n\t\t\tcontinue;\n\t\tmutex_lock(&NFS_I(cinfo->inode)->commit_mutex);\n\t\tif (!list_empty(&bucket->committing)) {\n\t\t\tdata = pnfs_bucket_fetch_commitdata(bucket, cinfo);\n\t\t\tif (!data)\n\t\t\t\tgoto out_error;\n\t\t\tdata->ds_commit_index = i;\n\t\t\tlist_add_tail(&data->list, list);\n\t\t\tnreq++;\n\t\t}\n\t\tmutex_unlock(&NFS_I(cinfo->inode)->commit_mutex);\n\t}\n\treturn nreq;\nout_error:\n\tmutex_unlock(&NFS_I(cinfo->inode)->commit_mutex);\n\t \n\tpnfs_generic_retry_commit(buckets, nbuckets, cinfo, i);\n\treturn nreq;\n}\n\nstatic unsigned int\npnfs_alloc_ds_commits_list(struct list_head *list,\n\t\t\t   struct pnfs_ds_commit_info *fl_cinfo,\n\t\t\t   struct nfs_commit_info *cinfo)\n{\n\tstruct pnfs_commit_array *array;\n\tunsigned int ret = 0;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(array, &fl_cinfo->commits, cinfo_list) {\n\t\tif (!array->lseg || !pnfs_get_commit_array(array))\n\t\t\tcontinue;\n\t\trcu_read_unlock();\n\t\tret += pnfs_bucket_alloc_ds_commits(list, array->buckets,\n\t\t\t\tarray->nbuckets, cinfo);\n\t\trcu_read_lock();\n\t\tpnfs_put_commit_array(array, cinfo->inode);\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}\n\n \nint\npnfs_generic_commit_pagelist(struct inode *inode, struct list_head *mds_pages,\n\t\t\t     int how, struct nfs_commit_info *cinfo,\n\t\t\t     int (*initiate_commit)(struct nfs_commit_data *data,\n\t\t\t\t\t\t    int how))\n{\n\tstruct pnfs_ds_commit_info *fl_cinfo = cinfo->ds;\n\tstruct nfs_commit_data *data, *tmp;\n\tLIST_HEAD(list);\n\tunsigned int nreq = 0;\n\n\tif (!list_empty(mds_pages)) {\n\t\tdata = nfs_commitdata_alloc();\n\t\tif (!data) {\n\t\t\tnfs_retry_commit(mds_pages, NULL, cinfo, -1);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tdata->ds_commit_index = -1;\n\t\tlist_splice_init(mds_pages, &data->pages);\n\t\tlist_add_tail(&data->list, &list);\n\t\tnreq++;\n\t}\n\n\tnreq += pnfs_alloc_ds_commits_list(&list, fl_cinfo, cinfo);\n\tif (nreq == 0)\n\t\tgoto out;\n\n\tlist_for_each_entry_safe(data, tmp, &list, list) {\n\t\tlist_del(&data->list);\n\t\tif (data->ds_commit_index < 0) {\n\t\t\tnfs_init_commit(data, NULL, NULL, cinfo);\n\t\t\tnfs_initiate_commit(NFS_CLIENT(inode), data,\n\t\t\t\t\t    NFS_PROTO(data->inode),\n\t\t\t\t\t    data->mds_ops, how,\n\t\t\t\t\t    RPC_TASK_CRED_NOREF);\n\t\t} else {\n\t\t\tnfs_init_commit(data, NULL, data->lseg, cinfo);\n\t\t\tinitiate_commit(data, how);\n\t\t}\n\t}\nout:\n\treturn PNFS_ATTEMPTED;\n}\nEXPORT_SYMBOL_GPL(pnfs_generic_commit_pagelist);\n\n \nstatic DEFINE_SPINLOCK(nfs4_ds_cache_lock);\nstatic LIST_HEAD(nfs4_data_server_cache);\n\n \nstatic void\nprint_ds(struct nfs4_pnfs_ds *ds)\n{\n\tif (ds == NULL) {\n\t\tprintk(KERN_WARNING \"%s NULL device\\n\", __func__);\n\t\treturn;\n\t}\n\tprintk(KERN_WARNING \"        ds %s\\n\"\n\t\t\"        ref count %d\\n\"\n\t\t\"        client %p\\n\"\n\t\t\"        cl_exchange_flags %x\\n\",\n\t\tds->ds_remotestr,\n\t\trefcount_read(&ds->ds_count), ds->ds_clp,\n\t\tds->ds_clp ? ds->ds_clp->cl_exchange_flags : 0);\n}\n\nstatic bool\nsame_sockaddr(struct sockaddr *addr1, struct sockaddr *addr2)\n{\n\tstruct sockaddr_in *a, *b;\n\tstruct sockaddr_in6 *a6, *b6;\n\n\tif (addr1->sa_family != addr2->sa_family)\n\t\treturn false;\n\n\tswitch (addr1->sa_family) {\n\tcase AF_INET:\n\t\ta = (struct sockaddr_in *)addr1;\n\t\tb = (struct sockaddr_in *)addr2;\n\n\t\tif (a->sin_addr.s_addr == b->sin_addr.s_addr &&\n\t\t    a->sin_port == b->sin_port)\n\t\t\treturn true;\n\t\tbreak;\n\n\tcase AF_INET6:\n\t\ta6 = (struct sockaddr_in6 *)addr1;\n\t\tb6 = (struct sockaddr_in6 *)addr2;\n\n\t\t \n\t\tif (ipv6_addr_src_scope(&a6->sin6_addr) ==\n\t\t    IPV6_ADDR_SCOPE_LINKLOCAL &&\n\t\t    a6->sin6_scope_id != b6->sin6_scope_id)\n\t\t\treturn false;\n\n\t\tif (ipv6_addr_equal(&a6->sin6_addr, &b6->sin6_addr) &&\n\t\t    a6->sin6_port == b6->sin6_port)\n\t\t\treturn true;\n\t\tbreak;\n\n\tdefault:\n\t\tdprintk(\"%s: unhandled address family: %u\\n\",\n\t\t\t__func__, addr1->sa_family);\n\t\treturn false;\n\t}\n\n\treturn false;\n}\n\n \nstatic bool\n_same_data_server_addrs_locked(const struct list_head *dsaddrs1,\n\t\t\t       const struct list_head *dsaddrs2)\n{\n\tstruct nfs4_pnfs_ds_addr *da1, *da2;\n\tstruct sockaddr *sa1, *sa2;\n\tbool match = false;\n\n\tlist_for_each_entry(da1, dsaddrs1, da_node) {\n\t\tsa1 = (struct sockaddr *)&da1->da_addr;\n\t\tmatch = false;\n\t\tlist_for_each_entry(da2, dsaddrs2, da_node) {\n\t\t\tsa2 = (struct sockaddr *)&da2->da_addr;\n\t\t\tmatch = same_sockaddr(sa1, sa2);\n\t\t\tif (match)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!match)\n\t\t\tbreak;\n\t}\n\treturn match;\n}\n\n \nstatic struct nfs4_pnfs_ds *\n_data_server_lookup_locked(const struct list_head *dsaddrs)\n{\n\tstruct nfs4_pnfs_ds *ds;\n\n\tlist_for_each_entry(ds, &nfs4_data_server_cache, ds_node)\n\t\tif (_same_data_server_addrs_locked(&ds->ds_addrs, dsaddrs))\n\t\t\treturn ds;\n\treturn NULL;\n}\n\nstatic struct nfs4_pnfs_ds_addr *nfs4_pnfs_ds_addr_alloc(gfp_t gfp_flags)\n{\n\tstruct nfs4_pnfs_ds_addr *da = kzalloc(sizeof(*da), gfp_flags);\n\tif (da)\n\t\tINIT_LIST_HEAD(&da->da_node);\n\treturn da;\n}\n\nstatic void nfs4_pnfs_ds_addr_free(struct nfs4_pnfs_ds_addr *da)\n{\n\tkfree(da->da_remotestr);\n\tkfree(da->da_netid);\n\tkfree(da);\n}\n\nstatic void destroy_ds(struct nfs4_pnfs_ds *ds)\n{\n\tstruct nfs4_pnfs_ds_addr *da;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\tifdebug(FACILITY)\n\t\tprint_ds(ds);\n\n\tnfs_put_client(ds->ds_clp);\n\n\twhile (!list_empty(&ds->ds_addrs)) {\n\t\tda = list_first_entry(&ds->ds_addrs,\n\t\t\t\t      struct nfs4_pnfs_ds_addr,\n\t\t\t\t      da_node);\n\t\tlist_del_init(&da->da_node);\n\t\tnfs4_pnfs_ds_addr_free(da);\n\t}\n\n\tkfree(ds->ds_remotestr);\n\tkfree(ds);\n}\n\nvoid nfs4_pnfs_ds_put(struct nfs4_pnfs_ds *ds)\n{\n\tif (refcount_dec_and_lock(&ds->ds_count,\n\t\t\t\t&nfs4_ds_cache_lock)) {\n\t\tlist_del_init(&ds->ds_node);\n\t\tspin_unlock(&nfs4_ds_cache_lock);\n\t\tdestroy_ds(ds);\n\t}\n}\nEXPORT_SYMBOL_GPL(nfs4_pnfs_ds_put);\n\n \nstatic char *\nnfs4_pnfs_remotestr(struct list_head *dsaddrs, gfp_t gfp_flags)\n{\n\tstruct nfs4_pnfs_ds_addr *da;\n\tchar *remotestr;\n\tsize_t len;\n\tchar *p;\n\n\tlen = 3;         \n\tlist_for_each_entry(da, dsaddrs, da_node) {\n\t\tlen += strlen(da->da_remotestr) + 1;     \n\t}\n\n\tremotestr = kzalloc(len, gfp_flags);\n\tif (!remotestr)\n\t\treturn NULL;\n\n\tp = remotestr;\n\t*(p++) = '{';\n\tlen--;\n\tlist_for_each_entry(da, dsaddrs, da_node) {\n\t\tsize_t ll = strlen(da->da_remotestr);\n\n\t\tif (ll > len)\n\t\t\tgoto out_err;\n\n\t\tmemcpy(p, da->da_remotestr, ll);\n\t\tp += ll;\n\t\tlen -= ll;\n\n\t\tif (len < 1)\n\t\t\tgoto out_err;\n\t\t(*p++) = ',';\n\t\tlen--;\n\t}\n\tif (len < 2)\n\t\tgoto out_err;\n\t*(p++) = '}';\n\t*p = '\\0';\n\treturn remotestr;\nout_err:\n\tkfree(remotestr);\n\treturn NULL;\n}\n\n \nstruct nfs4_pnfs_ds *\nnfs4_pnfs_ds_add(struct list_head *dsaddrs, gfp_t gfp_flags)\n{\n\tstruct nfs4_pnfs_ds *tmp_ds, *ds = NULL;\n\tchar *remotestr;\n\n\tif (list_empty(dsaddrs)) {\n\t\tdprintk(\"%s: no addresses defined\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tds = kzalloc(sizeof(*ds), gfp_flags);\n\tif (!ds)\n\t\tgoto out;\n\n\t \n\tremotestr = nfs4_pnfs_remotestr(dsaddrs, gfp_flags);\n\n\tspin_lock(&nfs4_ds_cache_lock);\n\ttmp_ds = _data_server_lookup_locked(dsaddrs);\n\tif (tmp_ds == NULL) {\n\t\tINIT_LIST_HEAD(&ds->ds_addrs);\n\t\tlist_splice_init(dsaddrs, &ds->ds_addrs);\n\t\tds->ds_remotestr = remotestr;\n\t\trefcount_set(&ds->ds_count, 1);\n\t\tINIT_LIST_HEAD(&ds->ds_node);\n\t\tds->ds_clp = NULL;\n\t\tlist_add(&ds->ds_node, &nfs4_data_server_cache);\n\t\tdprintk(\"%s add new data server %s\\n\", __func__,\n\t\t\tds->ds_remotestr);\n\t} else {\n\t\tkfree(remotestr);\n\t\tkfree(ds);\n\t\trefcount_inc(&tmp_ds->ds_count);\n\t\tdprintk(\"%s data server %s found, inc'ed ds_count to %d\\n\",\n\t\t\t__func__, tmp_ds->ds_remotestr,\n\t\t\trefcount_read(&tmp_ds->ds_count));\n\t\tds = tmp_ds;\n\t}\n\tspin_unlock(&nfs4_ds_cache_lock);\nout:\n\treturn ds;\n}\nEXPORT_SYMBOL_GPL(nfs4_pnfs_ds_add);\n\nstatic int nfs4_wait_ds_connect(struct nfs4_pnfs_ds *ds)\n{\n\tmight_sleep();\n\treturn wait_on_bit(&ds->ds_state, NFS4DS_CONNECTING, TASK_KILLABLE);\n}\n\nstatic void nfs4_clear_ds_conn_bit(struct nfs4_pnfs_ds *ds)\n{\n\tsmp_mb__before_atomic();\n\tclear_and_wake_up_bit(NFS4DS_CONNECTING, &ds->ds_state);\n}\n\nstatic struct nfs_client *(*get_v3_ds_connect)(\n\t\t\tstruct nfs_server *mds_srv,\n\t\t\tconst struct sockaddr_storage *ds_addr,\n\t\t\tint ds_addrlen,\n\t\t\tint ds_proto,\n\t\t\tunsigned int ds_timeo,\n\t\t\tunsigned int ds_retrans);\n\nstatic bool load_v3_ds_connect(void)\n{\n\tif (!get_v3_ds_connect) {\n\t\tget_v3_ds_connect = symbol_request(nfs3_set_ds_client);\n\t\tWARN_ON_ONCE(!get_v3_ds_connect);\n\t}\n\n\treturn(get_v3_ds_connect != NULL);\n}\n\nvoid nfs4_pnfs_v3_ds_connect_unload(void)\n{\n\tif (get_v3_ds_connect) {\n\t\tsymbol_put(nfs3_set_ds_client);\n\t\tget_v3_ds_connect = NULL;\n\t}\n}\n\nstatic int _nfs4_pnfs_v3_ds_connect(struct nfs_server *mds_srv,\n\t\t\t\t struct nfs4_pnfs_ds *ds,\n\t\t\t\t unsigned int timeo,\n\t\t\t\t unsigned int retrans)\n{\n\tstruct nfs_client *clp = ERR_PTR(-EIO);\n\tstruct nfs4_pnfs_ds_addr *da;\n\tunsigned long connect_timeout = timeo * (retrans + 1) * HZ / 10;\n\tint status = 0;\n\n\tdprintk(\"--> %s DS %s\\n\", __func__, ds->ds_remotestr);\n\n\tif (!load_v3_ds_connect())\n\t\treturn -EPROTONOSUPPORT;\n\n\tlist_for_each_entry(da, &ds->ds_addrs, da_node) {\n\t\tdprintk(\"%s: DS %s: trying address %s\\n\",\n\t\t\t__func__, ds->ds_remotestr, da->da_remotestr);\n\n\t\tif (!IS_ERR(clp)) {\n\t\t\tstruct xprt_create xprt_args = {\n\t\t\t\t.ident = da->da_transport,\n\t\t\t\t.net = clp->cl_net,\n\t\t\t\t.dstaddr = (struct sockaddr *)&da->da_addr,\n\t\t\t\t.addrlen = da->da_addrlen,\n\t\t\t\t.servername = clp->cl_hostname,\n\t\t\t\t.connect_timeout = connect_timeout,\n\t\t\t\t.reconnect_timeout = connect_timeout,\n\t\t\t};\n\n\t\t\tif (da->da_transport != clp->cl_proto)\n\t\t\t\tcontinue;\n\t\t\tif (da->da_addr.ss_family != clp->cl_addr.ss_family)\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\trpc_clnt_add_xprt(clp->cl_rpcclient, &xprt_args,\n\t\t\t\t\trpc_clnt_test_and_add_xprt, NULL);\n\t\t\tcontinue;\n\t\t}\n\t\tclp = get_v3_ds_connect(mds_srv,\n\t\t\t\t&da->da_addr,\n\t\t\t\tda->da_addrlen, da->da_transport,\n\t\t\t\ttimeo, retrans);\n\t\tif (IS_ERR(clp))\n\t\t\tcontinue;\n\t\tclp->cl_rpcclient->cl_softerr = 0;\n\t\tclp->cl_rpcclient->cl_softrtry = 0;\n\t}\n\n\tif (IS_ERR(clp)) {\n\t\tstatus = PTR_ERR(clp);\n\t\tgoto out;\n\t}\n\n\tsmp_wmb();\n\tWRITE_ONCE(ds->ds_clp, clp);\n\tdprintk(\"%s [new] addr: %s\\n\", __func__, ds->ds_remotestr);\nout:\n\treturn status;\n}\n\nstatic int _nfs4_pnfs_v4_ds_connect(struct nfs_server *mds_srv,\n\t\t\t\t struct nfs4_pnfs_ds *ds,\n\t\t\t\t unsigned int timeo,\n\t\t\t\t unsigned int retrans,\n\t\t\t\t u32 minor_version)\n{\n\tstruct nfs_client *clp = ERR_PTR(-EIO);\n\tstruct nfs4_pnfs_ds_addr *da;\n\tint status = 0;\n\n\tdprintk(\"--> %s DS %s\\n\", __func__, ds->ds_remotestr);\n\n\tlist_for_each_entry(da, &ds->ds_addrs, da_node) {\n\t\tdprintk(\"%s: DS %s: trying address %s\\n\",\n\t\t\t__func__, ds->ds_remotestr, da->da_remotestr);\n\n\t\tif (!IS_ERR(clp) && clp->cl_mvops->session_trunk) {\n\t\t\tstruct xprt_create xprt_args = {\n\t\t\t\t.ident = da->da_transport,\n\t\t\t\t.net = clp->cl_net,\n\t\t\t\t.dstaddr = (struct sockaddr *)&da->da_addr,\n\t\t\t\t.addrlen = da->da_addrlen,\n\t\t\t\t.servername = clp->cl_hostname,\n\t\t\t};\n\t\t\tstruct nfs4_add_xprt_data xprtdata = {\n\t\t\t\t.clp = clp,\n\t\t\t};\n\t\t\tstruct rpc_add_xprt_test rpcdata = {\n\t\t\t\t.add_xprt_test = clp->cl_mvops->session_trunk,\n\t\t\t\t.data = &xprtdata,\n\t\t\t};\n\n\t\t\tif (da->da_transport != clp->cl_proto)\n\t\t\t\tcontinue;\n\t\t\tif (da->da_addr.ss_family != clp->cl_addr.ss_family)\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\txprtdata.cred = nfs4_get_clid_cred(clp);\n\t\t\trpc_clnt_add_xprt(clp->cl_rpcclient, &xprt_args,\n\t\t\t\t\t  rpc_clnt_setup_test_and_add_xprt,\n\t\t\t\t\t  &rpcdata);\n\t\t\tif (xprtdata.cred)\n\t\t\t\tput_cred(xprtdata.cred);\n\t\t} else {\n\t\t\tclp = nfs4_set_ds_client(mds_srv,\n\t\t\t\t\t\t&da->da_addr,\n\t\t\t\t\t\tda->da_addrlen,\n\t\t\t\t\t\tda->da_transport, timeo,\n\t\t\t\t\t\tretrans, minor_version);\n\t\t\tif (IS_ERR(clp))\n\t\t\t\tcontinue;\n\n\t\t\tstatus = nfs4_init_ds_session(clp,\n\t\t\t\t\tmds_srv->nfs_client->cl_lease_time);\n\t\t\tif (status) {\n\t\t\t\tnfs_put_client(clp);\n\t\t\t\tclp = ERR_PTR(-EIO);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t}\n\t}\n\n\tif (IS_ERR(clp)) {\n\t\tstatus = PTR_ERR(clp);\n\t\tgoto out;\n\t}\n\n\tsmp_wmb();\n\tWRITE_ONCE(ds->ds_clp, clp);\n\tdprintk(\"%s [new] addr: %s\\n\", __func__, ds->ds_remotestr);\nout:\n\treturn status;\n}\n\n \nint nfs4_pnfs_ds_connect(struct nfs_server *mds_srv, struct nfs4_pnfs_ds *ds,\n\t\t\t  struct nfs4_deviceid_node *devid, unsigned int timeo,\n\t\t\t  unsigned int retrans, u32 version, u32 minor_version)\n{\n\tint err;\n\n\tdo {\n\t\terr = nfs4_wait_ds_connect(ds);\n\t\tif (err || ds->ds_clp)\n\t\t\tgoto out;\n\t\tif (nfs4_test_deviceid_unavailable(devid))\n\t\t\treturn -ENODEV;\n\t} while (test_and_set_bit(NFS4DS_CONNECTING, &ds->ds_state) != 0);\n\n\tif (ds->ds_clp)\n\t\tgoto connect_done;\n\n\tswitch (version) {\n\tcase 3:\n\t\terr = _nfs4_pnfs_v3_ds_connect(mds_srv, ds, timeo, retrans);\n\t\tbreak;\n\tcase 4:\n\t\terr = _nfs4_pnfs_v4_ds_connect(mds_srv, ds, timeo, retrans,\n\t\t\t\t\t       minor_version);\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"%s: unsupported DS version %d\\n\", __func__, version);\n\t\terr = -EPROTONOSUPPORT;\n\t}\n\nconnect_done:\n\tnfs4_clear_ds_conn_bit(ds);\nout:\n\t \n\tif (!err) {\n\t\tif (!ds->ds_clp || !nfs_client_init_is_complete(ds->ds_clp)) {\n\t\t\tWARN_ON_ONCE(ds->ds_clp ||\n\t\t\t\t!nfs4_test_deviceid_unavailable(devid));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\terr = nfs_client_init_status(ds->ds_clp);\n\t}\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(nfs4_pnfs_ds_connect);\n\n \nstruct nfs4_pnfs_ds_addr *\nnfs4_decode_mp_ds_addr(struct net *net, struct xdr_stream *xdr, gfp_t gfp_flags)\n{\n\tstruct nfs4_pnfs_ds_addr *da = NULL;\n\tchar *buf, *portstr;\n\t__be16 port;\n\tssize_t nlen, rlen;\n\tint tmp[2];\n\tchar *netid;\n\tsize_t len;\n\tchar *startsep = \"\";\n\tchar *endsep = \"\";\n\n\n\t \n\tnlen = xdr_stream_decode_string_dup(xdr, &netid, XDR_MAX_NETOBJ,\n\t\t\t\t\t    gfp_flags);\n\tif (unlikely(nlen < 0))\n\t\tgoto out_err;\n\n\t \n\t \n\trlen = xdr_stream_decode_string_dup(xdr, &buf, INET6_ADDRSTRLEN +\n\t\t\t\t\t    IPV6_SCOPE_ID_LEN + 8, gfp_flags);\n\tif (unlikely(rlen < 0))\n\t\tgoto out_free_netid;\n\n\t \n\tportstr = strrchr(buf, '.');\n\tif (!portstr) {\n\t\tdprintk(\"%s: Failed finding expected dot in port\\n\",\n\t\t\t__func__);\n\t\tgoto out_free_buf;\n\t}\n\t*portstr = '-';\n\n\t \n\tportstr = strrchr(buf, '.');\n\tif (!portstr) {\n\t\tdprintk(\"%s: Failed finding expected dot between address and \"\n\t\t\t\"port\\n\", __func__);\n\t\tgoto out_free_buf;\n\t}\n\t*portstr = '\\0';\n\n\tda = nfs4_pnfs_ds_addr_alloc(gfp_flags);\n\tif (unlikely(!da))\n\t\tgoto out_free_buf;\n\n\tif (!rpc_pton(net, buf, portstr-buf, (struct sockaddr *)&da->da_addr,\n\t\t      sizeof(da->da_addr))) {\n\t\tdprintk(\"%s: error parsing address %s\\n\", __func__, buf);\n\t\tgoto out_free_da;\n\t}\n\n\tportstr++;\n\tsscanf(portstr, \"%d-%d\", &tmp[0], &tmp[1]);\n\tport = htons((tmp[0] << 8) | (tmp[1]));\n\n\tswitch (da->da_addr.ss_family) {\n\tcase AF_INET:\n\t\t((struct sockaddr_in *)&da->da_addr)->sin_port = port;\n\t\tda->da_addrlen = sizeof(struct sockaddr_in);\n\t\tbreak;\n\n\tcase AF_INET6:\n\t\t((struct sockaddr_in6 *)&da->da_addr)->sin6_port = port;\n\t\tda->da_addrlen = sizeof(struct sockaddr_in6);\n\t\tstartsep = \"[\";\n\t\tendsep = \"]\";\n\t\tbreak;\n\n\tdefault:\n\t\tdprintk(\"%s: unsupported address family: %u\\n\",\n\t\t\t__func__, da->da_addr.ss_family);\n\t\tgoto out_free_da;\n\t}\n\n\tda->da_transport = xprt_find_transport_ident(netid);\n\tif (da->da_transport < 0) {\n\t\tdprintk(\"%s: ERROR: unknown r_netid \\\"%s\\\"\\n\",\n\t\t\t__func__, netid);\n\t\tgoto out_free_da;\n\t}\n\n\tda->da_netid = netid;\n\n\t \n\tlen = strlen(startsep) + strlen(buf) + strlen(endsep) + 7;\n\tda->da_remotestr = kzalloc(len, gfp_flags);\n\n\t \n\tif (da->da_remotestr)\n\t\tsnprintf(da->da_remotestr, len, \"%s%s%s:%u\", startsep,\n\t\t\t buf, endsep, ntohs(port));\n\n\tdprintk(\"%s: Parsed DS addr %s\\n\", __func__, da->da_remotestr);\n\tkfree(buf);\n\treturn da;\n\nout_free_da:\n\tkfree(da);\nout_free_buf:\n\tdprintk(\"%s: Error parsing DS addr: %s\\n\", __func__, buf);\n\tkfree(buf);\nout_free_netid:\n\tkfree(netid);\nout_err:\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(nfs4_decode_mp_ds_addr);\n\nvoid\npnfs_layout_mark_request_commit(struct nfs_page *req,\n\t\t\t\tstruct pnfs_layout_segment *lseg,\n\t\t\t\tstruct nfs_commit_info *cinfo,\n\t\t\t\tu32 ds_commit_idx)\n{\n\tstruct list_head *list;\n\tstruct pnfs_commit_array *array;\n\tstruct pnfs_commit_bucket *bucket;\n\n\tmutex_lock(&NFS_I(cinfo->inode)->commit_mutex);\n\tarray = pnfs_lookup_commit_array(cinfo->ds, lseg);\n\tif (!array || !pnfs_is_valid_lseg(lseg))\n\t\tgoto out_resched;\n\tbucket = &array->buckets[ds_commit_idx];\n\tlist = &bucket->written;\n\t \n\tif (!bucket->lseg)\n\t\tbucket->lseg = pnfs_get_lseg(lseg);\n\tset_bit(PG_COMMIT_TO_DS, &req->wb_flags);\n\tcinfo->ds->nwritten++;\n\n\tnfs_request_add_commit_list_locked(req, list, cinfo);\n\tmutex_unlock(&NFS_I(cinfo->inode)->commit_mutex);\n\tnfs_folio_mark_unstable(nfs_page_to_folio(req), cinfo);\n\treturn;\nout_resched:\n\tmutex_unlock(&NFS_I(cinfo->inode)->commit_mutex);\n\tcinfo->completion_ops->resched_write(cinfo, req);\n}\nEXPORT_SYMBOL_GPL(pnfs_layout_mark_request_commit);\n\nint\npnfs_nfs_generic_sync(struct inode *inode, bool datasync)\n{\n\tint ret;\n\n\tif (!pnfs_layoutcommit_outstanding(inode))\n\t\treturn 0;\n\tret = nfs_commit_inode(inode, FLUSH_SYNC);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (datasync)\n\t\treturn 0;\n\treturn pnfs_layoutcommit_inode(inode, true);\n}\nEXPORT_SYMBOL_GPL(pnfs_nfs_generic_sync);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}