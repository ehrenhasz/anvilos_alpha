{
  "module_name": "filelayout.c",
  "hash_id": "798b7b75aa0c527952241e66126c047198f0e9abd712e0704931fb5a2432b02e",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfs/filelayout/filelayout.c",
  "human_readable_source": " \n\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n\n#include <linux/sunrpc/metrics.h>\n\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include \"../delegation.h\"\n#include \"filelayout.h\"\n#include \"../nfs4trace.h\"\n\n#define NFSDBG_FACILITY         NFSDBG_PNFS_LD\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Dean Hildebrand <dhildebz@umich.edu>\");\nMODULE_DESCRIPTION(\"The NFSv4 file layout driver\");\n\n#define FILELAYOUT_POLL_RETRY_MAX     (15*HZ)\nstatic const struct pnfs_commit_ops filelayout_commit_ops;\n\nstatic loff_t\nfilelayout_get_dense_offset(struct nfs4_filelayout_segment *flseg,\n\t\t\t    loff_t offset)\n{\n\tu32 stripe_width = flseg->stripe_unit * flseg->dsaddr->stripe_count;\n\tu64 stripe_no;\n\tu32 rem;\n\n\toffset -= flseg->pattern_offset;\n\tstripe_no = div_u64(offset, stripe_width);\n\tdiv_u64_rem(offset, flseg->stripe_unit, &rem);\n\n\treturn stripe_no * flseg->stripe_unit + rem;\n}\n\n \nstatic loff_t\nfilelayout_get_dserver_offset(struct pnfs_layout_segment *lseg, loff_t offset)\n{\n\tstruct nfs4_filelayout_segment *flseg = FILELAYOUT_LSEG(lseg);\n\n\tswitch (flseg->stripe_type) {\n\tcase STRIPE_SPARSE:\n\t\treturn offset;\n\n\tcase STRIPE_DENSE:\n\t\treturn filelayout_get_dense_offset(flseg, offset);\n\t}\n\n\tBUG();\n}\n\nstatic void filelayout_reset_write(struct nfs_pgio_header *hdr)\n{\n\tstruct rpc_task *task = &hdr->task;\n\n\tif (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags)) {\n\t\tdprintk(\"%s Reset task %5u for i/o through MDS \"\n\t\t\t\"(req %s/%llu, %u bytes @ offset %llu)\\n\", __func__,\n\t\t\thdr->task.tk_pid,\n\t\t\thdr->inode->i_sb->s_id,\n\t\t\t(unsigned long long)NFS_FILEID(hdr->inode),\n\t\t\thdr->args.count,\n\t\t\t(unsigned long long)hdr->args.offset);\n\n\t\ttask->tk_status = pnfs_write_done_resend_to_mds(hdr);\n\t}\n}\n\nstatic void filelayout_reset_read(struct nfs_pgio_header *hdr)\n{\n\tstruct rpc_task *task = &hdr->task;\n\n\tif (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags)) {\n\t\tdprintk(\"%s Reset task %5u for i/o through MDS \"\n\t\t\t\"(req %s/%llu, %u bytes @ offset %llu)\\n\", __func__,\n\t\t\thdr->task.tk_pid,\n\t\t\thdr->inode->i_sb->s_id,\n\t\t\t(unsigned long long)NFS_FILEID(hdr->inode),\n\t\t\thdr->args.count,\n\t\t\t(unsigned long long)hdr->args.offset);\n\n\t\ttask->tk_status = pnfs_read_done_resend_to_mds(hdr);\n\t}\n}\n\nstatic int filelayout_async_handle_error(struct rpc_task *task,\n\t\t\t\t\t struct nfs4_state *state,\n\t\t\t\t\t struct nfs_client *clp,\n\t\t\t\t\t struct pnfs_layout_segment *lseg)\n{\n\tstruct pnfs_layout_hdr *lo = lseg->pls_layout;\n\tstruct inode *inode = lo->plh_inode;\n\tstruct nfs4_deviceid_node *devid = FILELAYOUT_DEVID_NODE(lseg);\n\tstruct nfs4_slot_table *tbl = &clp->cl_session->fc_slot_table;\n\n\tif (task->tk_status >= 0)\n\t\treturn 0;\n\n\tswitch (task->tk_status) {\n\t \n\tcase -NFS4ERR_BADSESSION:\n\tcase -NFS4ERR_BADSLOT:\n\tcase -NFS4ERR_BAD_HIGH_SLOT:\n\tcase -NFS4ERR_DEADSESSION:\n\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\tcase -NFS4ERR_SEQ_FALSE_RETRY:\n\tcase -NFS4ERR_SEQ_MISORDERED:\n\t\tdprintk(\"%s ERROR %d, Reset session. Exchangeid \"\n\t\t\t\"flags 0x%x\\n\", __func__, task->tk_status,\n\t\t\tclp->cl_exchange_flags);\n\t\tnfs4_schedule_session_recovery(clp->cl_session, task->tk_status);\n\t\tbreak;\n\tcase -NFS4ERR_DELAY:\n\tcase -NFS4ERR_GRACE:\n\t\trpc_delay(task, FILELAYOUT_POLL_RETRY_MAX);\n\t\tbreak;\n\tcase -NFS4ERR_RETRY_UNCACHED_REP:\n\t\tbreak;\n\t \n\tcase -NFS4ERR_ACCESS:\n\tcase -NFS4ERR_PNFS_NO_LAYOUT:\n\tcase -ESTALE:            \n\tcase -EBADHANDLE:        \n\tcase -EISDIR:            \n\tcase -NFS4ERR_FHEXPIRED:\n\tcase -NFS4ERR_WRONG_TYPE:\n\t\tdprintk(\"%s Invalid layout error %d\\n\", __func__,\n\t\t\ttask->tk_status);\n\t\t \n\t\tpnfs_destroy_layout(NFS_I(inode));\n\t\trpc_wake_up(&tbl->slot_tbl_waitq);\n\t\tgoto reset;\n\t \n\tcase -ECONNREFUSED:\n\tcase -EHOSTDOWN:\n\tcase -EHOSTUNREACH:\n\tcase -ENETUNREACH:\n\tcase -EIO:\n\tcase -ETIMEDOUT:\n\tcase -EPIPE:\n\tcase -EPROTO:\n\tcase -ENODEV:\n\t\tdprintk(\"%s DS connection error %d\\n\", __func__,\n\t\t\ttask->tk_status);\n\t\tnfs4_mark_deviceid_unavailable(devid);\n\t\tpnfs_error_mark_layout_for_return(inode, lseg);\n\t\tpnfs_set_lo_fail(lseg);\n\t\trpc_wake_up(&tbl->slot_tbl_waitq);\n\t\tfallthrough;\n\tdefault:\nreset:\n\t\tdprintk(\"%s Retry through MDS. Error %d\\n\", __func__,\n\t\t\ttask->tk_status);\n\t\treturn -NFS4ERR_RESET_TO_MDS;\n\t}\n\ttask->tk_status = 0;\n\treturn -EAGAIN;\n}\n\n \n\nstatic int filelayout_read_done_cb(struct rpc_task *task,\n\t\t\t\tstruct nfs_pgio_header *hdr)\n{\n\tint err;\n\n\ttrace_nfs4_pnfs_read(hdr, task->tk_status);\n\terr = filelayout_async_handle_error(task, hdr->args.context->state,\n\t\t\t\t\t    hdr->ds_clp, hdr->lseg);\n\n\tswitch (err) {\n\tcase -NFS4ERR_RESET_TO_MDS:\n\t\tfilelayout_reset_read(hdr);\n\t\treturn task->tk_status;\n\tcase -EAGAIN:\n\t\trpc_restart_call_prepare(task);\n\t\treturn -EAGAIN;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void\nfilelayout_set_layoutcommit(struct nfs_pgio_header *hdr)\n{\n\tloff_t end_offs = 0;\n\n\tif (FILELAYOUT_LSEG(hdr->lseg)->commit_through_mds ||\n\t    hdr->res.verf->committed == NFS_FILE_SYNC)\n\t\treturn;\n\tif (hdr->res.verf->committed == NFS_DATA_SYNC)\n\t\tend_offs = hdr->mds_offset + (loff_t)hdr->res.count;\n\n\t \n\tpnfs_set_layoutcommit(hdr->inode, hdr->lseg, end_offs);\n\tdprintk(\"%s inode %lu pls_end_pos %lu\\n\", __func__, hdr->inode->i_ino,\n\t\t(unsigned long) NFS_I(hdr->inode)->layout->plh_lwb);\n}\n\nbool\nfilelayout_test_devid_unavailable(struct nfs4_deviceid_node *node)\n{\n\treturn filelayout_test_devid_invalid(node) ||\n\t\tnfs4_test_deviceid_unavailable(node);\n}\n\nstatic bool\nfilelayout_reset_to_mds(struct pnfs_layout_segment *lseg)\n{\n\tstruct nfs4_deviceid_node *node = FILELAYOUT_DEVID_NODE(lseg);\n\n\treturn filelayout_test_devid_unavailable(node);\n}\n\n \nstatic void filelayout_read_prepare(struct rpc_task *task, void *data)\n{\n\tstruct nfs_pgio_header *hdr = data;\n\n\tif (unlikely(test_bit(NFS_CONTEXT_BAD, &hdr->args.context->flags))) {\n\t\trpc_exit(task, -EIO);\n\t\treturn;\n\t}\n\tif (filelayout_reset_to_mds(hdr->lseg)) {\n\t\tdprintk(\"%s task %u reset io to MDS\\n\", __func__, task->tk_pid);\n\t\tfilelayout_reset_read(hdr);\n\t\trpc_exit(task, 0);\n\t\treturn;\n\t}\n\thdr->pgio_done_cb = filelayout_read_done_cb;\n\n\tif (nfs4_setup_sequence(hdr->ds_clp,\n\t\t\t&hdr->args.seq_args,\n\t\t\t&hdr->res.seq_res,\n\t\t\ttask))\n\t\treturn;\n\tif (nfs4_set_rw_stateid(&hdr->args.stateid, hdr->args.context,\n\t\t\thdr->args.lock_context, FMODE_READ) == -EIO)\n\t\trpc_exit(task, -EIO);  \n}\n\nstatic void filelayout_read_call_done(struct rpc_task *task, void *data)\n{\n\tstruct nfs_pgio_header *hdr = data;\n\n\tif (test_bit(NFS_IOHDR_REDO, &hdr->flags) &&\n\t    task->tk_status == 0) {\n\t\tnfs41_sequence_done(task, &hdr->res.seq_res);\n\t\treturn;\n\t}\n\n\t \n\thdr->mds_ops->rpc_call_done(task, data);\n}\n\nstatic void filelayout_read_count_stats(struct rpc_task *task, void *data)\n{\n\tstruct nfs_pgio_header *hdr = data;\n\n\trpc_count_iostats(task, NFS_SERVER(hdr->inode)->client->cl_metrics);\n}\n\nstatic int filelayout_write_done_cb(struct rpc_task *task,\n\t\t\t\tstruct nfs_pgio_header *hdr)\n{\n\tint err;\n\n\ttrace_nfs4_pnfs_write(hdr, task->tk_status);\n\terr = filelayout_async_handle_error(task, hdr->args.context->state,\n\t\t\t\t\t    hdr->ds_clp, hdr->lseg);\n\n\tswitch (err) {\n\tcase -NFS4ERR_RESET_TO_MDS:\n\t\tfilelayout_reset_write(hdr);\n\t\treturn task->tk_status;\n\tcase -EAGAIN:\n\t\trpc_restart_call_prepare(task);\n\t\treturn -EAGAIN;\n\t}\n\n\tfilelayout_set_layoutcommit(hdr);\n\n\t \n\thdr->fattr.valid = 0;\n\tif (task->tk_status >= 0)\n\t\tnfs_writeback_update_inode(hdr);\n\n\treturn 0;\n}\n\nstatic int filelayout_commit_done_cb(struct rpc_task *task,\n\t\t\t\t     struct nfs_commit_data *data)\n{\n\tint err;\n\n\ttrace_nfs4_pnfs_commit_ds(data, task->tk_status);\n\terr = filelayout_async_handle_error(task, NULL, data->ds_clp,\n\t\t\t\t\t    data->lseg);\n\n\tswitch (err) {\n\tcase -NFS4ERR_RESET_TO_MDS:\n\t\tpnfs_generic_prepare_to_resend_writes(data);\n\t\treturn -EAGAIN;\n\tcase -EAGAIN:\n\t\trpc_restart_call_prepare(task);\n\t\treturn -EAGAIN;\n\t}\n\n\tpnfs_set_layoutcommit(data->inode, data->lseg, data->lwb);\n\n\treturn 0;\n}\n\nstatic void filelayout_write_prepare(struct rpc_task *task, void *data)\n{\n\tstruct nfs_pgio_header *hdr = data;\n\n\tif (unlikely(test_bit(NFS_CONTEXT_BAD, &hdr->args.context->flags))) {\n\t\trpc_exit(task, -EIO);\n\t\treturn;\n\t}\n\tif (filelayout_reset_to_mds(hdr->lseg)) {\n\t\tdprintk(\"%s task %u reset io to MDS\\n\", __func__, task->tk_pid);\n\t\tfilelayout_reset_write(hdr);\n\t\trpc_exit(task, 0);\n\t\treturn;\n\t}\n\tif (nfs4_setup_sequence(hdr->ds_clp,\n\t\t\t&hdr->args.seq_args,\n\t\t\t&hdr->res.seq_res,\n\t\t\ttask))\n\t\treturn;\n\tif (nfs4_set_rw_stateid(&hdr->args.stateid, hdr->args.context,\n\t\t\thdr->args.lock_context, FMODE_WRITE) == -EIO)\n\t\trpc_exit(task, -EIO);  \n}\n\nstatic void filelayout_write_call_done(struct rpc_task *task, void *data)\n{\n\tstruct nfs_pgio_header *hdr = data;\n\n\tif (test_bit(NFS_IOHDR_REDO, &hdr->flags) &&\n\t    task->tk_status == 0) {\n\t\tnfs41_sequence_done(task, &hdr->res.seq_res);\n\t\treturn;\n\t}\n\n\t \n\thdr->mds_ops->rpc_call_done(task, data);\n}\n\nstatic void filelayout_write_count_stats(struct rpc_task *task, void *data)\n{\n\tstruct nfs_pgio_header *hdr = data;\n\n\trpc_count_iostats(task, NFS_SERVER(hdr->inode)->client->cl_metrics);\n}\n\nstatic void filelayout_commit_prepare(struct rpc_task *task, void *data)\n{\n\tstruct nfs_commit_data *wdata = data;\n\n\tnfs4_setup_sequence(wdata->ds_clp,\n\t\t\t&wdata->args.seq_args,\n\t\t\t&wdata->res.seq_res,\n\t\t\ttask);\n}\n\nstatic void filelayout_commit_count_stats(struct rpc_task *task, void *data)\n{\n\tstruct nfs_commit_data *cdata = data;\n\n\trpc_count_iostats(task, NFS_SERVER(cdata->inode)->client->cl_metrics);\n}\n\nstatic const struct rpc_call_ops filelayout_read_call_ops = {\n\t.rpc_call_prepare = filelayout_read_prepare,\n\t.rpc_call_done = filelayout_read_call_done,\n\t.rpc_count_stats = filelayout_read_count_stats,\n\t.rpc_release = pnfs_generic_rw_release,\n};\n\nstatic const struct rpc_call_ops filelayout_write_call_ops = {\n\t.rpc_call_prepare = filelayout_write_prepare,\n\t.rpc_call_done = filelayout_write_call_done,\n\t.rpc_count_stats = filelayout_write_count_stats,\n\t.rpc_release = pnfs_generic_rw_release,\n};\n\nstatic const struct rpc_call_ops filelayout_commit_call_ops = {\n\t.rpc_call_prepare = filelayout_commit_prepare,\n\t.rpc_call_done = pnfs_generic_write_commit_done,\n\t.rpc_count_stats = filelayout_commit_count_stats,\n\t.rpc_release = pnfs_generic_commit_release,\n};\n\nstatic enum pnfs_try_status\nfilelayout_read_pagelist(struct nfs_pgio_header *hdr)\n{\n\tstruct pnfs_layout_segment *lseg = hdr->lseg;\n\tstruct nfs4_pnfs_ds *ds;\n\tstruct rpc_clnt *ds_clnt;\n\tloff_t offset = hdr->args.offset;\n\tu32 j, idx;\n\tstruct nfs_fh *fh;\n\n\tdprintk(\"--> %s ino %lu pgbase %u req %zu@%llu\\n\",\n\t\t__func__, hdr->inode->i_ino,\n\t\thdr->args.pgbase, (size_t)hdr->args.count, offset);\n\n\t \n\tj = nfs4_fl_calc_j_index(lseg, offset);\n\tidx = nfs4_fl_calc_ds_index(lseg, j);\n\tds = nfs4_fl_prepare_ds(lseg, idx);\n\tif (!ds)\n\t\treturn PNFS_NOT_ATTEMPTED;\n\n\tds_clnt = nfs4_find_or_create_ds_client(ds->ds_clp, hdr->inode);\n\tif (IS_ERR(ds_clnt))\n\t\treturn PNFS_NOT_ATTEMPTED;\n\n\tdprintk(\"%s USE DS: %s cl_count %d\\n\", __func__,\n\t\tds->ds_remotestr, refcount_read(&ds->ds_clp->cl_count));\n\n\t \n\trefcount_inc(&ds->ds_clp->cl_count);\n\thdr->ds_clp = ds->ds_clp;\n\thdr->ds_commit_idx = idx;\n\tfh = nfs4_fl_select_ds_fh(lseg, j);\n\tif (fh)\n\t\thdr->args.fh = fh;\n\n\thdr->args.offset = filelayout_get_dserver_offset(lseg, offset);\n\thdr->mds_offset = offset;\n\n\t \n\tnfs_initiate_pgio(ds_clnt, hdr, hdr->cred,\n\t\t\t  NFS_PROTO(hdr->inode), &filelayout_read_call_ops,\n\t\t\t  0, RPC_TASK_SOFTCONN);\n\treturn PNFS_ATTEMPTED;\n}\n\n \nstatic enum pnfs_try_status\nfilelayout_write_pagelist(struct nfs_pgio_header *hdr, int sync)\n{\n\tstruct pnfs_layout_segment *lseg = hdr->lseg;\n\tstruct nfs4_pnfs_ds *ds;\n\tstruct rpc_clnt *ds_clnt;\n\tloff_t offset = hdr->args.offset;\n\tu32 j, idx;\n\tstruct nfs_fh *fh;\n\n\t \n\tj = nfs4_fl_calc_j_index(lseg, offset);\n\tidx = nfs4_fl_calc_ds_index(lseg, j);\n\tds = nfs4_fl_prepare_ds(lseg, idx);\n\tif (!ds)\n\t\treturn PNFS_NOT_ATTEMPTED;\n\n\tds_clnt = nfs4_find_or_create_ds_client(ds->ds_clp, hdr->inode);\n\tif (IS_ERR(ds_clnt))\n\t\treturn PNFS_NOT_ATTEMPTED;\n\n\tdprintk(\"%s ino %lu sync %d req %zu@%llu DS: %s cl_count %d\\n\",\n\t\t__func__, hdr->inode->i_ino, sync, (size_t) hdr->args.count,\n\t\toffset, ds->ds_remotestr, refcount_read(&ds->ds_clp->cl_count));\n\n\thdr->pgio_done_cb = filelayout_write_done_cb;\n\trefcount_inc(&ds->ds_clp->cl_count);\n\thdr->ds_clp = ds->ds_clp;\n\thdr->ds_commit_idx = idx;\n\tfh = nfs4_fl_select_ds_fh(lseg, j);\n\tif (fh)\n\t\thdr->args.fh = fh;\n\thdr->args.offset = filelayout_get_dserver_offset(lseg, offset);\n\n\t \n\tnfs_initiate_pgio(ds_clnt, hdr, hdr->cred,\n\t\t\t  NFS_PROTO(hdr->inode), &filelayout_write_call_ops,\n\t\t\t  sync, RPC_TASK_SOFTCONN);\n\treturn PNFS_ATTEMPTED;\n}\n\nstatic int\nfilelayout_check_deviceid(struct pnfs_layout_hdr *lo,\n\t\t\t  struct nfs4_filelayout_segment *fl,\n\t\t\t  gfp_t gfp_flags)\n{\n\tstruct nfs4_deviceid_node *d;\n\tstruct nfs4_file_layout_dsaddr *dsaddr;\n\tint status = -EINVAL;\n\n\t \n\tif (fl->dsaddr != NULL)\n\t\treturn 0;\n\n\t \n\td = nfs4_find_get_deviceid(NFS_SERVER(lo->plh_inode), &fl->deviceid,\n\t\t\tlo->plh_lc_cred, gfp_flags);\n\tif (d == NULL)\n\t\tgoto out;\n\n\tdsaddr = container_of(d, struct nfs4_file_layout_dsaddr, id_node);\n\t \n\tif (filelayout_test_devid_unavailable(&dsaddr->id_node))\n\t\tgoto out_put;\n\n\tif (fl->first_stripe_index >= dsaddr->stripe_count) {\n\t\tdprintk(\"%s Bad first_stripe_index %u\\n\",\n\t\t\t\t__func__, fl->first_stripe_index);\n\t\tgoto out_put;\n\t}\n\n\tif ((fl->stripe_type == STRIPE_SPARSE &&\n\t    fl->num_fh > 1 && fl->num_fh != dsaddr->ds_num) ||\n\t    (fl->stripe_type == STRIPE_DENSE &&\n\t    fl->num_fh != dsaddr->stripe_count)) {\n\t\tdprintk(\"%s num_fh %u not valid for given packing\\n\",\n\t\t\t__func__, fl->num_fh);\n\t\tgoto out_put;\n\t}\n\tstatus = 0;\n\n\t \n\tif (cmpxchg(&fl->dsaddr, NULL, dsaddr) != NULL)\n\t\tgoto out_put;\nout:\n\treturn status;\nout_put:\n\tnfs4_fl_put_deviceid(dsaddr);\n\tgoto out;\n}\n\n \nstatic int\nfilelayout_check_layout(struct pnfs_layout_hdr *lo,\n\t\t\tstruct nfs4_filelayout_segment *fl,\n\t\t\tstruct nfs4_layoutget_res *lgr,\n\t\t\tgfp_t gfp_flags)\n{\n\tint status = -EINVAL;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\n\t \n\tif (lgr->range.offset != 0 ||\n\t    lgr->range.length != NFS4_MAX_UINT64) {\n\t\tdprintk(\"%s Only whole file layouts supported. Use MDS i/o\\n\",\n\t\t\t__func__);\n\t\tgoto out;\n\t}\n\n\tif (fl->pattern_offset > lgr->range.offset) {\n\t\tdprintk(\"%s pattern_offset %lld too large\\n\",\n\t\t\t\t__func__, fl->pattern_offset);\n\t\tgoto out;\n\t}\n\n\tif (!fl->stripe_unit) {\n\t\tdprintk(\"%s Invalid stripe unit (%u)\\n\",\n\t\t\t__func__, fl->stripe_unit);\n\t\tgoto out;\n\t}\n\n\tstatus = 0;\nout:\n\tdprintk(\"--> %s returns %d\\n\", __func__, status);\n\treturn status;\n}\n\nstatic void _filelayout_free_lseg(struct nfs4_filelayout_segment *fl)\n{\n\tint i;\n\n\tif (fl->fh_array) {\n\t\tfor (i = 0; i < fl->num_fh; i++) {\n\t\t\tif (!fl->fh_array[i])\n\t\t\t\tbreak;\n\t\t\tkfree(fl->fh_array[i]);\n\t\t}\n\t\tkfree(fl->fh_array);\n\t}\n\tkfree(fl);\n}\n\nstatic int\nfilelayout_decode_layout(struct pnfs_layout_hdr *flo,\n\t\t\t struct nfs4_filelayout_segment *fl,\n\t\t\t struct nfs4_layoutget_res *lgr,\n\t\t\t gfp_t gfp_flags)\n{\n\tstruct xdr_stream stream;\n\tstruct xdr_buf buf;\n\tstruct page *scratch;\n\t__be32 *p;\n\tuint32_t nfl_util;\n\tint i;\n\n\tdprintk(\"%s: set_layout_map Begin\\n\", __func__);\n\n\tscratch = alloc_page(gfp_flags);\n\tif (!scratch)\n\t\treturn -ENOMEM;\n\n\txdr_init_decode_pages(&stream, &buf, lgr->layoutp->pages, lgr->layoutp->len);\n\txdr_set_scratch_page(&stream, scratch);\n\n\t \n\tp = xdr_inline_decode(&stream, NFS4_DEVICEID4_SIZE + 20);\n\tif (unlikely(!p))\n\t\tgoto out_err;\n\n\tmemcpy(&fl->deviceid, p, sizeof(fl->deviceid));\n\tp += XDR_QUADLEN(NFS4_DEVICEID4_SIZE);\n\tnfs4_print_deviceid(&fl->deviceid);\n\n\tnfl_util = be32_to_cpup(p++);\n\tif (nfl_util & NFL4_UFLG_COMMIT_THRU_MDS)\n\t\tfl->commit_through_mds = 1;\n\tif (nfl_util & NFL4_UFLG_DENSE)\n\t\tfl->stripe_type = STRIPE_DENSE;\n\telse\n\t\tfl->stripe_type = STRIPE_SPARSE;\n\tfl->stripe_unit = nfl_util & ~NFL4_UFLG_MASK;\n\n\tfl->first_stripe_index = be32_to_cpup(p++);\n\tp = xdr_decode_hyper(p, &fl->pattern_offset);\n\tfl->num_fh = be32_to_cpup(p++);\n\n\tdprintk(\"%s: nfl_util 0x%X num_fh %u fsi %u po %llu\\n\",\n\t\t__func__, nfl_util, fl->num_fh, fl->first_stripe_index,\n\t\tfl->pattern_offset);\n\n\t \n\tif (fl->num_fh >\n\t    max(NFS4_PNFS_MAX_STRIPE_CNT, NFS4_PNFS_MAX_MULTI_CNT))\n\t\tgoto out_err;\n\n\tif (fl->num_fh > 0) {\n\t\tfl->fh_array = kcalloc(fl->num_fh, sizeof(fl->fh_array[0]),\n\t\t\t\t       gfp_flags);\n\t\tif (!fl->fh_array)\n\t\t\tgoto out_err;\n\t}\n\n\tfor (i = 0; i < fl->num_fh; i++) {\n\t\t \n\t\tfl->fh_array[i] = kmalloc(sizeof(struct nfs_fh), gfp_flags);\n\t\tif (!fl->fh_array[i])\n\t\t\tgoto out_err;\n\n\t\tp = xdr_inline_decode(&stream, 4);\n\t\tif (unlikely(!p))\n\t\t\tgoto out_err;\n\t\tfl->fh_array[i]->size = be32_to_cpup(p++);\n\t\tif (fl->fh_array[i]->size > NFS_MAXFHSIZE) {\n\t\t\tprintk(KERN_ERR \"NFS: Too big fh %d received %d\\n\",\n\t\t\t       i, fl->fh_array[i]->size);\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tp = xdr_inline_decode(&stream, fl->fh_array[i]->size);\n\t\tif (unlikely(!p))\n\t\t\tgoto out_err;\n\t\tmemcpy(fl->fh_array[i]->data, p, fl->fh_array[i]->size);\n\t\tdprintk(\"DEBUG: %s: fh len %d\\n\", __func__,\n\t\t\tfl->fh_array[i]->size);\n\t}\n\n\t__free_page(scratch);\n\treturn 0;\n\nout_err:\n\t__free_page(scratch);\n\treturn -EIO;\n}\n\nstatic void\nfilelayout_free_lseg(struct pnfs_layout_segment *lseg)\n{\n\tstruct nfs4_filelayout_segment *fl = FILELAYOUT_LSEG(lseg);\n\n\tdprintk(\"--> %s\\n\", __func__);\n\tif (fl->dsaddr != NULL)\n\t\tnfs4_fl_put_deviceid(fl->dsaddr);\n\t \n\tif (lseg->pls_range.iomode == IOMODE_RW) {\n\t\tstruct nfs4_filelayout *flo;\n\t\tstruct inode *inode;\n\n\t\tflo = FILELAYOUT_FROM_HDR(lseg->pls_layout);\n\t\tinode = flo->generic_hdr.plh_inode;\n\t\tspin_lock(&inode->i_lock);\n\t\tpnfs_generic_ds_cinfo_release_lseg(&flo->commit_info, lseg);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\t_filelayout_free_lseg(fl);\n}\n\nstatic struct pnfs_layout_segment *\nfilelayout_alloc_lseg(struct pnfs_layout_hdr *layoutid,\n\t\t      struct nfs4_layoutget_res *lgr,\n\t\t      gfp_t gfp_flags)\n{\n\tstruct nfs4_filelayout_segment *fl;\n\tint rc;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\tfl = kzalloc(sizeof(*fl), gfp_flags);\n\tif (!fl)\n\t\treturn NULL;\n\n\trc = filelayout_decode_layout(layoutid, fl, lgr, gfp_flags);\n\tif (rc != 0 || filelayout_check_layout(layoutid, fl, lgr, gfp_flags)) {\n\t\t_filelayout_free_lseg(fl);\n\t\treturn NULL;\n\t}\n\treturn &fl->generic_hdr;\n}\n\nstatic bool\nfilelayout_lseg_is_striped(const struct nfs4_filelayout_segment *flseg)\n{\n\treturn flseg->num_fh > 1;\n}\n\n \nstatic size_t\nfilelayout_pg_test(struct nfs_pageio_descriptor *pgio, struct nfs_page *prev,\n\t\t   struct nfs_page *req)\n{\n\tunsigned int size;\n\tu64 p_stripe, r_stripe;\n\tu32 stripe_offset;\n\tu64 segment_offset = pgio->pg_lseg->pls_range.offset;\n\tu32 stripe_unit = FILELAYOUT_LSEG(pgio->pg_lseg)->stripe_unit;\n\n\t \n\tsize = pnfs_generic_pg_test(pgio, prev, req);\n\tif (!size)\n\t\treturn 0;\n\telse if (!filelayout_lseg_is_striped(FILELAYOUT_LSEG(pgio->pg_lseg)))\n\t\treturn size;\n\n\t \n\tif (prev) {\n\t\tp_stripe = (u64)req_offset(prev) - segment_offset;\n\t\tr_stripe = (u64)req_offset(req) - segment_offset;\n\t\tdo_div(p_stripe, stripe_unit);\n\t\tdo_div(r_stripe, stripe_unit);\n\n\t\tif (p_stripe != r_stripe)\n\t\t\treturn 0;\n\t}\n\n\t \n\tdiv_u64_rem((u64)req_offset(req) - segment_offset,\n\t\t\tstripe_unit,\n\t\t\t&stripe_offset);\n\tWARN_ON_ONCE(stripe_offset > stripe_unit);\n\tif (stripe_offset >= stripe_unit)\n\t\treturn 0;\n\treturn min(stripe_unit - (unsigned int)stripe_offset, size);\n}\n\nstatic struct pnfs_layout_segment *\nfl_pnfs_update_layout(struct inode *ino,\n\t\t      struct nfs_open_context *ctx,\n\t\t      loff_t pos,\n\t\t      u64 count,\n\t\t      enum pnfs_iomode iomode,\n\t\t      bool strict_iomode,\n\t\t      gfp_t gfp_flags)\n{\n\tstruct pnfs_layout_segment *lseg = NULL;\n\tstruct pnfs_layout_hdr *lo;\n\tstruct nfs4_filelayout_segment *fl;\n\tint status;\n\n\tlseg = pnfs_update_layout(ino, ctx, pos, count, iomode, strict_iomode,\n\t\t\t\t  gfp_flags);\n\tif (IS_ERR(lseg)) {\n\t\t \n\t\tif (!nfs_error_is_fatal_on_server(PTR_ERR(lseg)))\n\t\t\tlseg = NULL;\n\t\tgoto out;\n\t} else if (!lseg)\n\t\tgoto out;\n\n\tlo = NFS_I(ino)->layout;\n\tfl = FILELAYOUT_LSEG(lseg);\n\n\tstatus = filelayout_check_deviceid(lo, fl, gfp_flags);\n\tif (status) {\n\t\tpnfs_error_mark_layout_for_return(ino, lseg);\n\t\tpnfs_set_lo_fail(lseg);\n\t\tpnfs_put_lseg(lseg);\n\t\tlseg = NULL;\n\t}\nout:\n\treturn lseg;\n}\n\nstatic void\nfilelayout_pg_init_read(struct nfs_pageio_descriptor *pgio,\n\t\t\tstruct nfs_page *req)\n{\n\tpnfs_generic_pg_check_layout(pgio);\n\tif (!pgio->pg_lseg) {\n\t\tpgio->pg_lseg = fl_pnfs_update_layout(pgio->pg_inode,\n\t\t\t\t\t\t      nfs_req_openctx(req),\n\t\t\t\t\t\t      0,\n\t\t\t\t\t\t      NFS4_MAX_UINT64,\n\t\t\t\t\t\t      IOMODE_READ,\n\t\t\t\t\t\t      false,\n\t\t\t\t\t\t      GFP_KERNEL);\n\t\tif (IS_ERR(pgio->pg_lseg)) {\n\t\t\tpgio->pg_error = PTR_ERR(pgio->pg_lseg);\n\t\t\tpgio->pg_lseg = NULL;\n\t\t\treturn;\n\t\t}\n\t}\n\t \n\tif (pgio->pg_lseg == NULL)\n\t\tnfs_pageio_reset_read_mds(pgio);\n}\n\nstatic void\nfilelayout_pg_init_write(struct nfs_pageio_descriptor *pgio,\n\t\t\t struct nfs_page *req)\n{\n\tpnfs_generic_pg_check_layout(pgio);\n\tif (!pgio->pg_lseg) {\n\t\tpgio->pg_lseg = fl_pnfs_update_layout(pgio->pg_inode,\n\t\t\t\t\t\t      nfs_req_openctx(req),\n\t\t\t\t\t\t      0,\n\t\t\t\t\t\t      NFS4_MAX_UINT64,\n\t\t\t\t\t\t      IOMODE_RW,\n\t\t\t\t\t\t      false,\n\t\t\t\t\t\t      GFP_NOFS);\n\t\tif (IS_ERR(pgio->pg_lseg)) {\n\t\t\tpgio->pg_error = PTR_ERR(pgio->pg_lseg);\n\t\t\tpgio->pg_lseg = NULL;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tif (pgio->pg_lseg == NULL)\n\t\tnfs_pageio_reset_write_mds(pgio);\n}\n\nstatic const struct nfs_pageio_ops filelayout_pg_read_ops = {\n\t.pg_init = filelayout_pg_init_read,\n\t.pg_test = filelayout_pg_test,\n\t.pg_doio = pnfs_generic_pg_readpages,\n\t.pg_cleanup = pnfs_generic_pg_cleanup,\n};\n\nstatic const struct nfs_pageio_ops filelayout_pg_write_ops = {\n\t.pg_init = filelayout_pg_init_write,\n\t.pg_test = filelayout_pg_test,\n\t.pg_doio = pnfs_generic_pg_writepages,\n\t.pg_cleanup = pnfs_generic_pg_cleanup,\n};\n\nstatic u32 select_bucket_index(struct nfs4_filelayout_segment *fl, u32 j)\n{\n\tif (fl->stripe_type == STRIPE_SPARSE)\n\t\treturn nfs4_fl_calc_ds_index(&fl->generic_hdr, j);\n\telse\n\t\treturn j;\n}\n\nstatic void\nfilelayout_mark_request_commit(struct nfs_page *req,\n\t\t\t       struct pnfs_layout_segment *lseg,\n\t\t\t       struct nfs_commit_info *cinfo,\n\t\t\t       u32 ds_commit_idx)\n\n{\n\tstruct nfs4_filelayout_segment *fl = FILELAYOUT_LSEG(lseg);\n\tu32 i, j;\n\n\tif (fl->commit_through_mds) {\n\t\tnfs_request_add_commit_list(req, cinfo);\n\t} else {\n\t\t \n\t\tj = nfs4_fl_calc_j_index(lseg, req_offset(req));\n\t\ti = select_bucket_index(fl, j);\n\t\tpnfs_layout_mark_request_commit(req, lseg, cinfo, i);\n\t}\n}\n\nstatic u32 calc_ds_index_from_commit(struct pnfs_layout_segment *lseg, u32 i)\n{\n\tstruct nfs4_filelayout_segment *flseg = FILELAYOUT_LSEG(lseg);\n\n\tif (flseg->stripe_type == STRIPE_SPARSE)\n\t\treturn i;\n\telse\n\t\treturn nfs4_fl_calc_ds_index(lseg, i);\n}\n\nstatic struct nfs_fh *\nselect_ds_fh_from_commit(struct pnfs_layout_segment *lseg, u32 i)\n{\n\tstruct nfs4_filelayout_segment *flseg = FILELAYOUT_LSEG(lseg);\n\n\tif (flseg->stripe_type == STRIPE_SPARSE) {\n\t\tif (flseg->num_fh == 1)\n\t\t\ti = 0;\n\t\telse if (flseg->num_fh == 0)\n\t\t\t \n\t\t\treturn NULL;\n\t}\n\treturn flseg->fh_array[i];\n}\n\nstatic int filelayout_initiate_commit(struct nfs_commit_data *data, int how)\n{\n\tstruct pnfs_layout_segment *lseg = data->lseg;\n\tstruct nfs4_pnfs_ds *ds;\n\tstruct rpc_clnt *ds_clnt;\n\tu32 idx;\n\tstruct nfs_fh *fh;\n\n\tidx = calc_ds_index_from_commit(lseg, data->ds_commit_index);\n\tds = nfs4_fl_prepare_ds(lseg, idx);\n\tif (!ds)\n\t\tgoto out_err;\n\n\tds_clnt = nfs4_find_or_create_ds_client(ds->ds_clp, data->inode);\n\tif (IS_ERR(ds_clnt))\n\t\tgoto out_err;\n\n\tdprintk(\"%s ino %lu, how %d cl_count %d\\n\", __func__,\n\t\tdata->inode->i_ino, how, refcount_read(&ds->ds_clp->cl_count));\n\tdata->commit_done_cb = filelayout_commit_done_cb;\n\trefcount_inc(&ds->ds_clp->cl_count);\n\tdata->ds_clp = ds->ds_clp;\n\tfh = select_ds_fh_from_commit(lseg, data->ds_commit_index);\n\tif (fh)\n\t\tdata->args.fh = fh;\n\treturn nfs_initiate_commit(ds_clnt, data, NFS_PROTO(data->inode),\n\t\t\t\t   &filelayout_commit_call_ops, how,\n\t\t\t\t   RPC_TASK_SOFTCONN);\nout_err:\n\tpnfs_generic_prepare_to_resend_writes(data);\n\tpnfs_generic_commit_release(data);\n\treturn -EAGAIN;\n}\n\nstatic int\nfilelayout_commit_pagelist(struct inode *inode, struct list_head *mds_pages,\n\t\t\t   int how, struct nfs_commit_info *cinfo)\n{\n\treturn pnfs_generic_commit_pagelist(inode, mds_pages, how, cinfo,\n\t\t\t\t\t    filelayout_initiate_commit);\n}\n\nstatic struct nfs4_deviceid_node *\nfilelayout_alloc_deviceid_node(struct nfs_server *server,\n\t\tstruct pnfs_device *pdev, gfp_t gfp_flags)\n{\n\tstruct nfs4_file_layout_dsaddr *dsaddr;\n\n\tdsaddr = nfs4_fl_alloc_deviceid_node(server, pdev, gfp_flags);\n\tif (!dsaddr)\n\t\treturn NULL;\n\treturn &dsaddr->id_node;\n}\n\nstatic void\nfilelayout_free_deviceid_node(struct nfs4_deviceid_node *d)\n{\n\tnfs4_fl_free_deviceid(container_of(d, struct nfs4_file_layout_dsaddr, id_node));\n}\n\nstatic struct pnfs_layout_hdr *\nfilelayout_alloc_layout_hdr(struct inode *inode, gfp_t gfp_flags)\n{\n\tstruct nfs4_filelayout *flo;\n\n\tflo = kzalloc(sizeof(*flo), gfp_flags);\n\tif (flo == NULL)\n\t\treturn NULL;\n\tpnfs_init_ds_commit_info(&flo->commit_info);\n\tflo->commit_info.ops = &filelayout_commit_ops;\n\treturn &flo->generic_hdr;\n}\n\nstatic void\nfilelayout_free_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tkfree_rcu(FILELAYOUT_FROM_HDR(lo), generic_hdr.plh_rcu);\n}\n\nstatic struct pnfs_ds_commit_info *\nfilelayout_get_ds_info(struct inode *inode)\n{\n\tstruct pnfs_layout_hdr *layout = NFS_I(inode)->layout;\n\n\tif (layout == NULL)\n\t\treturn NULL;\n\telse\n\t\treturn &FILELAYOUT_FROM_HDR(layout)->commit_info;\n}\n\nstatic void\nfilelayout_setup_ds_info(struct pnfs_ds_commit_info *fl_cinfo,\n\t\tstruct pnfs_layout_segment *lseg)\n{\n\tstruct nfs4_filelayout_segment *fl = FILELAYOUT_LSEG(lseg);\n\tstruct inode *inode = lseg->pls_layout->plh_inode;\n\tstruct pnfs_commit_array *array, *new;\n\tunsigned int size = (fl->stripe_type == STRIPE_SPARSE) ?\n\t\tfl->dsaddr->ds_num : fl->dsaddr->stripe_count;\n\n\tnew = pnfs_alloc_commit_array(size, nfs_io_gfp_mask());\n\tif (new) {\n\t\tspin_lock(&inode->i_lock);\n\t\tarray = pnfs_add_commit_array(fl_cinfo, new, lseg);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (array != new)\n\t\t\tpnfs_free_commit_array(new);\n\t}\n}\n\nstatic void\nfilelayout_release_ds_info(struct pnfs_ds_commit_info *fl_cinfo,\n\t\tstruct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tpnfs_generic_ds_cinfo_destroy(fl_cinfo);\n\tspin_unlock(&inode->i_lock);\n}\n\nstatic const struct pnfs_commit_ops filelayout_commit_ops = {\n\t.setup_ds_info\t\t= filelayout_setup_ds_info,\n\t.release_ds_info\t= filelayout_release_ds_info,\n\t.mark_request_commit\t= filelayout_mark_request_commit,\n\t.clear_request_commit\t= pnfs_generic_clear_request_commit,\n\t.scan_commit_lists\t= pnfs_generic_scan_commit_lists,\n\t.recover_commit_reqs\t= pnfs_generic_recover_commit_reqs,\n\t.search_commit_reqs\t= pnfs_generic_search_commit_reqs,\n\t.commit_pagelist\t= filelayout_commit_pagelist,\n};\n\nstatic struct pnfs_layoutdriver_type filelayout_type = {\n\t.id\t\t\t= LAYOUT_NFSV4_1_FILES,\n\t.name\t\t\t= \"LAYOUT_NFSV4_1_FILES\",\n\t.owner\t\t\t= THIS_MODULE,\n\t.flags\t\t\t= PNFS_LAYOUTGET_ON_OPEN,\n\t.max_layoutget_response\t= 4096,  \n\t.alloc_layout_hdr\t= filelayout_alloc_layout_hdr,\n\t.free_layout_hdr\t= filelayout_free_layout_hdr,\n\t.alloc_lseg\t\t= filelayout_alloc_lseg,\n\t.free_lseg\t\t= filelayout_free_lseg,\n\t.pg_read_ops\t\t= &filelayout_pg_read_ops,\n\t.pg_write_ops\t\t= &filelayout_pg_write_ops,\n\t.get_ds_info\t\t= &filelayout_get_ds_info,\n\t.read_pagelist\t\t= filelayout_read_pagelist,\n\t.write_pagelist\t\t= filelayout_write_pagelist,\n\t.alloc_deviceid_node\t= filelayout_alloc_deviceid_node,\n\t.free_deviceid_node\t= filelayout_free_deviceid_node,\n\t.sync\t\t\t= pnfs_nfs_generic_sync,\n};\n\nstatic int __init nfs4filelayout_init(void)\n{\n\tprintk(KERN_INFO \"%s: NFSv4 File Layout Driver Registering...\\n\",\n\t       __func__);\n\treturn pnfs_register_layoutdriver(&filelayout_type);\n}\n\nstatic void __exit nfs4filelayout_exit(void)\n{\n\tprintk(KERN_INFO \"%s: NFSv4 File Layout Driver Unregistering...\\n\",\n\t       __func__);\n\tpnfs_unregister_layoutdriver(&filelayout_type);\n}\n\nMODULE_ALIAS(\"nfs-layouttype4-1\");\n\nmodule_init(nfs4filelayout_init);\nmodule_exit(nfs4filelayout_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}