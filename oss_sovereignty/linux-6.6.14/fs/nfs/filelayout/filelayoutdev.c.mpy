{
  "module_name": "filelayoutdev.c",
  "hash_id": "21ad84f0dbba26f8e3e2f4cb16aa151ef9059d2adf8a0c10d9b6e6419256a0b5",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfs/filelayout/filelayoutdev.c",
  "human_readable_source": " \n\n#include <linux/nfs_fs.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"filelayout.h\"\n\n#define NFSDBG_FACILITY\t\tNFSDBG_PNFS_LD\n\nstatic unsigned int dataserver_timeo = NFS4_DEF_DS_TIMEO;\nstatic unsigned int dataserver_retrans = NFS4_DEF_DS_RETRANS;\n\nvoid\nnfs4_fl_free_deviceid(struct nfs4_file_layout_dsaddr *dsaddr)\n{\n\tstruct nfs4_pnfs_ds *ds;\n\tint i;\n\n\tnfs4_print_deviceid(&dsaddr->id_node.deviceid);\n\n\tfor (i = 0; i < dsaddr->ds_num; i++) {\n\t\tds = dsaddr->ds_list[i];\n\t\tif (ds != NULL)\n\t\t\tnfs4_pnfs_ds_put(ds);\n\t}\n\tkfree(dsaddr->stripe_indices);\n\tkfree_rcu(dsaddr, id_node.rcu);\n}\n\n \nstruct nfs4_file_layout_dsaddr *\nnfs4_fl_alloc_deviceid_node(struct nfs_server *server, struct pnfs_device *pdev,\n\t\tgfp_t gfp_flags)\n{\n\tint i;\n\tu32 cnt, num;\n\tu8 *indexp;\n\t__be32 *p;\n\tu8 *stripe_indices;\n\tu8 max_stripe_index;\n\tstruct nfs4_file_layout_dsaddr *dsaddr = NULL;\n\tstruct xdr_stream stream;\n\tstruct xdr_buf buf;\n\tstruct page *scratch;\n\tstruct list_head dsaddrs;\n\tstruct nfs4_pnfs_ds_addr *da;\n\n\t \n\tscratch = alloc_page(gfp_flags);\n\tif (!scratch)\n\t\tgoto out_err;\n\n\txdr_init_decode_pages(&stream, &buf, pdev->pages, pdev->pglen);\n\txdr_set_scratch_page(&stream, scratch);\n\n\t \n\tp = xdr_inline_decode(&stream, 4);\n\tif (unlikely(!p))\n\t\tgoto out_err_free_scratch;\n\n\tcnt = be32_to_cpup(p);\n\tdprintk(\"%s stripe count  %d\\n\", __func__, cnt);\n\tif (cnt > NFS4_PNFS_MAX_STRIPE_CNT) {\n\t\tprintk(KERN_WARNING \"NFS: %s: stripe count %d greater than \"\n\t\t       \"supported maximum %d\\n\", __func__,\n\t\t\tcnt, NFS4_PNFS_MAX_STRIPE_CNT);\n\t\tgoto out_err_free_scratch;\n\t}\n\n\t \n\tstripe_indices = kcalloc(cnt, sizeof(u8), gfp_flags);\n\tif (!stripe_indices)\n\t\tgoto out_err_free_scratch;\n\n\tp = xdr_inline_decode(&stream, cnt << 2);\n\tif (unlikely(!p))\n\t\tgoto out_err_free_stripe_indices;\n\n\tindexp = &stripe_indices[0];\n\tmax_stripe_index = 0;\n\tfor (i = 0; i < cnt; i++) {\n\t\t*indexp = be32_to_cpup(p++);\n\t\tmax_stripe_index = max(max_stripe_index, *indexp);\n\t\tindexp++;\n\t}\n\n\t \n\tp = xdr_inline_decode(&stream, 4);\n\tif (unlikely(!p))\n\t\tgoto out_err_free_stripe_indices;\n\n\tnum = be32_to_cpup(p);\n\tdprintk(\"%s ds_num %u\\n\", __func__, num);\n\tif (num > NFS4_PNFS_MAX_MULTI_CNT) {\n\t\tprintk(KERN_WARNING \"NFS: %s: multipath count %d greater than \"\n\t\t\t\"supported maximum %d\\n\", __func__,\n\t\t\tnum, NFS4_PNFS_MAX_MULTI_CNT);\n\t\tgoto out_err_free_stripe_indices;\n\t}\n\n\t \n\tif (max_stripe_index >= num) {\n\t\tprintk(KERN_WARNING \"NFS: %s: stripe index %u >= num ds %u\\n\",\n\t\t\t__func__, max_stripe_index, num);\n\t\tgoto out_err_free_stripe_indices;\n\t}\n\n\tdsaddr = kzalloc(struct_size(dsaddr, ds_list, num), gfp_flags);\n\tif (!dsaddr)\n\t\tgoto out_err_free_stripe_indices;\n\n\tdsaddr->stripe_count = cnt;\n\tdsaddr->stripe_indices = stripe_indices;\n\tstripe_indices = NULL;\n\tdsaddr->ds_num = num;\n\tnfs4_init_deviceid_node(&dsaddr->id_node, server, &pdev->dev_id);\n\n\tINIT_LIST_HEAD(&dsaddrs);\n\n\tfor (i = 0; i < dsaddr->ds_num; i++) {\n\t\tint j;\n\t\tu32 mp_count;\n\n\t\tp = xdr_inline_decode(&stream, 4);\n\t\tif (unlikely(!p))\n\t\t\tgoto out_err_free_deviceid;\n\n\t\tmp_count = be32_to_cpup(p);  \n\t\tfor (j = 0; j < mp_count; j++) {\n\t\t\tda = nfs4_decode_mp_ds_addr(server->nfs_client->cl_net,\n\t\t\t\t\t\t    &stream, gfp_flags);\n\t\t\tif (da)\n\t\t\t\tlist_add_tail(&da->da_node, &dsaddrs);\n\t\t}\n\t\tif (list_empty(&dsaddrs)) {\n\t\t\tdprintk(\"%s: no suitable DS addresses found\\n\",\n\t\t\t\t__func__);\n\t\t\tgoto out_err_free_deviceid;\n\t\t}\n\n\t\tdsaddr->ds_list[i] = nfs4_pnfs_ds_add(&dsaddrs, gfp_flags);\n\t\tif (!dsaddr->ds_list[i])\n\t\t\tgoto out_err_drain_dsaddrs;\n\n\t\t \n\t\twhile (!list_empty(&dsaddrs)) {\n\t\t\tda = list_first_entry(&dsaddrs,\n\t\t\t\t\t      struct nfs4_pnfs_ds_addr,\n\t\t\t\t\t      da_node);\n\t\t\tlist_del_init(&da->da_node);\n\t\t\tkfree(da->da_remotestr);\n\t\t\tkfree(da);\n\t\t}\n\t}\n\n\t__free_page(scratch);\n\treturn dsaddr;\n\nout_err_drain_dsaddrs:\n\twhile (!list_empty(&dsaddrs)) {\n\t\tda = list_first_entry(&dsaddrs, struct nfs4_pnfs_ds_addr,\n\t\t\t\t      da_node);\n\t\tlist_del_init(&da->da_node);\n\t\tkfree(da->da_remotestr);\n\t\tkfree(da);\n\t}\nout_err_free_deviceid:\n\tnfs4_fl_free_deviceid(dsaddr);\n\t \n\tgoto out_err_free_scratch;\nout_err_free_stripe_indices:\n\tkfree(stripe_indices);\nout_err_free_scratch:\n\t__free_page(scratch);\nout_err:\n\tdprintk(\"%s ERROR: returning NULL\\n\", __func__);\n\treturn NULL;\n}\n\nvoid\nnfs4_fl_put_deviceid(struct nfs4_file_layout_dsaddr *dsaddr)\n{\n\tnfs4_put_deviceid_node(&dsaddr->id_node);\n}\n\n \nu32\nnfs4_fl_calc_j_index(struct pnfs_layout_segment *lseg, loff_t offset)\n{\n\tstruct nfs4_filelayout_segment *flseg = FILELAYOUT_LSEG(lseg);\n\tu64 tmp;\n\n\ttmp = offset - flseg->pattern_offset;\n\tdo_div(tmp, flseg->stripe_unit);\n\ttmp += flseg->first_stripe_index;\n\treturn do_div(tmp, flseg->dsaddr->stripe_count);\n}\n\nu32\nnfs4_fl_calc_ds_index(struct pnfs_layout_segment *lseg, u32 j)\n{\n\treturn FILELAYOUT_LSEG(lseg)->dsaddr->stripe_indices[j];\n}\n\nstruct nfs_fh *\nnfs4_fl_select_ds_fh(struct pnfs_layout_segment *lseg, u32 j)\n{\n\tstruct nfs4_filelayout_segment *flseg = FILELAYOUT_LSEG(lseg);\n\tu32 i;\n\n\tif (flseg->stripe_type == STRIPE_SPARSE) {\n\t\tif (flseg->num_fh == 1)\n\t\t\ti = 0;\n\t\telse if (flseg->num_fh == 0)\n\t\t\t \n\t\t\treturn NULL;\n\t\telse\n\t\t\ti = nfs4_fl_calc_ds_index(lseg, j);\n\t} else\n\t\ti = j;\n\treturn flseg->fh_array[i];\n}\n\n \nstruct nfs4_pnfs_ds *\nnfs4_fl_prepare_ds(struct pnfs_layout_segment *lseg, u32 ds_idx)\n{\n\tstruct nfs4_file_layout_dsaddr *dsaddr = FILELAYOUT_LSEG(lseg)->dsaddr;\n\tstruct nfs4_pnfs_ds *ds = dsaddr->ds_list[ds_idx];\n\tstruct nfs4_deviceid_node *devid = FILELAYOUT_DEVID_NODE(lseg);\n\tstruct nfs4_pnfs_ds *ret = ds;\n\tstruct nfs_server *s = NFS_SERVER(lseg->pls_layout->plh_inode);\n\tint status;\n\n\tif (ds == NULL) {\n\t\tprintk(KERN_ERR \"NFS: %s: No data server for offset index %d\\n\",\n\t\t\t__func__, ds_idx);\n\t\tpnfs_generic_mark_devid_invalid(devid);\n\t\tgoto out;\n\t}\n\tsmp_rmb();\n\tif (ds->ds_clp)\n\t\tgoto out_test_devid;\n\n\tstatus = nfs4_pnfs_ds_connect(s, ds, devid, dataserver_timeo,\n\t\t\t     dataserver_retrans, 4,\n\t\t\t     s->nfs_client->cl_minorversion);\n\tif (status) {\n\t\tnfs4_mark_deviceid_unavailable(devid);\n\t\tret = NULL;\n\t\tgoto out;\n\t}\n\nout_test_devid:\n\tif (ret->ds_clp == NULL ||\n\t    filelayout_test_devid_unavailable(devid))\n\t\tret = NULL;\nout:\n\treturn ret;\n}\n\nmodule_param(dataserver_retrans, uint, 0644);\nMODULE_PARM_DESC(dataserver_retrans, \"The  number of times the NFSv4.1 client \"\n\t\t\t\"retries a request before it attempts further \"\n\t\t\t\" recovery  action.\");\nmodule_param(dataserver_timeo, uint, 0644);\nMODULE_PARM_DESC(dataserver_timeo, \"The time (in tenths of a second) the \"\n\t\t\t\"NFSv4.1  client  waits for a response from a \"\n\t\t\t\" data server before it retries an NFS request.\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}