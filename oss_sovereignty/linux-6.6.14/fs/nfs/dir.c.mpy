{
  "module_name": "dir.c",
  "hash_id": "adaf0ab69a34e7619bd88cace73498c6b175e700af2600585eecf4cd70b3a667",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfs/dir.c",
  "human_readable_source": "\n \n\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_mount.h>\n#include <linux/pagemap.h>\n#include <linux/pagevec.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/swap.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/xattr.h>\n#include <linux/hash.h>\n\n#include \"delegation.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"fscache.h\"\n\n#include \"nfstrace.h\"\n\n \n\nstatic int nfs_opendir(struct inode *, struct file *);\nstatic int nfs_closedir(struct inode *, struct file *);\nstatic int nfs_readdir(struct file *, struct dir_context *);\nstatic int nfs_fsync_dir(struct file *, loff_t, loff_t, int);\nstatic loff_t nfs_llseek_dir(struct file *, loff_t, int);\nstatic void nfs_readdir_clear_array(struct folio *);\n\nconst struct file_operations nfs_dir_operations = {\n\t.llseek\t\t= nfs_llseek_dir,\n\t.read\t\t= generic_read_dir,\n\t.iterate_shared\t= nfs_readdir,\n\t.open\t\t= nfs_opendir,\n\t.release\t= nfs_closedir,\n\t.fsync\t\t= nfs_fsync_dir,\n};\n\nconst struct address_space_operations nfs_dir_aops = {\n\t.free_folio = nfs_readdir_clear_array,\n};\n\n#define NFS_INIT_DTSIZE PAGE_SIZE\n\nstatic struct nfs_open_dir_context *\nalloc_nfs_open_dir_context(struct inode *dir)\n{\n\tstruct nfs_inode *nfsi = NFS_I(dir);\n\tstruct nfs_open_dir_context *ctx;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL_ACCOUNT);\n\tif (ctx != NULL) {\n\t\tctx->attr_gencount = nfsi->attr_gencount;\n\t\tctx->dtsize = NFS_INIT_DTSIZE;\n\t\tspin_lock(&dir->i_lock);\n\t\tif (list_empty(&nfsi->open_files) &&\n\t\t    (nfsi->cache_validity & NFS_INO_DATA_INVAL_DEFER))\n\t\t\tnfs_set_cache_invalid(dir,\n\t\t\t\t\t      NFS_INO_INVALID_DATA |\n\t\t\t\t\t\t      NFS_INO_REVAL_FORCED);\n\t\tlist_add_tail_rcu(&ctx->list, &nfsi->open_files);\n\t\tmemcpy(ctx->verf, nfsi->cookieverf, sizeof(ctx->verf));\n\t\tspin_unlock(&dir->i_lock);\n\t\treturn ctx;\n\t}\n\treturn  ERR_PTR(-ENOMEM);\n}\n\nstatic void put_nfs_open_dir_context(struct inode *dir, struct nfs_open_dir_context *ctx)\n{\n\tspin_lock(&dir->i_lock);\n\tlist_del_rcu(&ctx->list);\n\tspin_unlock(&dir->i_lock);\n\tkfree_rcu(ctx, rcu_head);\n}\n\n \nstatic int\nnfs_opendir(struct inode *inode, struct file *filp)\n{\n\tint res = 0;\n\tstruct nfs_open_dir_context *ctx;\n\n\tdfprintk(FILE, \"NFS: open dir(%pD2)\\n\", filp);\n\n\tnfs_inc_stats(inode, NFSIOS_VFSOPEN);\n\n\tctx = alloc_nfs_open_dir_context(inode);\n\tif (IS_ERR(ctx)) {\n\t\tres = PTR_ERR(ctx);\n\t\tgoto out;\n\t}\n\tfilp->private_data = ctx;\nout:\n\treturn res;\n}\n\nstatic int\nnfs_closedir(struct inode *inode, struct file *filp)\n{\n\tput_nfs_open_dir_context(file_inode(filp), filp->private_data);\n\treturn 0;\n}\n\nstruct nfs_cache_array_entry {\n\tu64 cookie;\n\tu64 ino;\n\tconst char *name;\n\tunsigned int name_len;\n\tunsigned char d_type;\n};\n\nstruct nfs_cache_array {\n\tu64 change_attr;\n\tu64 last_cookie;\n\tunsigned int size;\n\tunsigned char folio_full : 1,\n\t\t      folio_is_eof : 1,\n\t\t      cookies_are_ordered : 1;\n\tstruct nfs_cache_array_entry array[];\n};\n\nstruct nfs_readdir_descriptor {\n\tstruct file\t*file;\n\tstruct folio\t*folio;\n\tstruct dir_context *ctx;\n\tpgoff_t\t\tfolio_index;\n\tpgoff_t\t\tfolio_index_max;\n\tu64\t\tdir_cookie;\n\tu64\t\tlast_cookie;\n\tloff_t\t\tcurrent_index;\n\n\t__be32\t\tverf[NFS_DIR_VERIFIER_SIZE];\n\tunsigned long\tdir_verifier;\n\tunsigned long\ttimestamp;\n\tunsigned long\tgencount;\n\tunsigned long\tattr_gencount;\n\tunsigned int\tcache_entry_index;\n\tunsigned int\tbuffer_fills;\n\tunsigned int\tdtsize;\n\tbool clear_cache;\n\tbool plus;\n\tbool eob;\n\tbool eof;\n};\n\nstatic void nfs_set_dtsize(struct nfs_readdir_descriptor *desc, unsigned int sz)\n{\n\tstruct nfs_server *server = NFS_SERVER(file_inode(desc->file));\n\tunsigned int maxsize = server->dtsize;\n\n\tif (sz > maxsize)\n\t\tsz = maxsize;\n\tif (sz < NFS_MIN_FILE_IO_SIZE)\n\t\tsz = NFS_MIN_FILE_IO_SIZE;\n\tdesc->dtsize = sz;\n}\n\nstatic void nfs_shrink_dtsize(struct nfs_readdir_descriptor *desc)\n{\n\tnfs_set_dtsize(desc, desc->dtsize >> 1);\n}\n\nstatic void nfs_grow_dtsize(struct nfs_readdir_descriptor *desc)\n{\n\tnfs_set_dtsize(desc, desc->dtsize << 1);\n}\n\nstatic void nfs_readdir_folio_init_array(struct folio *folio, u64 last_cookie,\n\t\t\t\t\t u64 change_attr)\n{\n\tstruct nfs_cache_array *array;\n\n\tarray = kmap_local_folio(folio, 0);\n\tarray->change_attr = change_attr;\n\tarray->last_cookie = last_cookie;\n\tarray->size = 0;\n\tarray->folio_full = 0;\n\tarray->folio_is_eof = 0;\n\tarray->cookies_are_ordered = 1;\n\tkunmap_local(array);\n}\n\n \nstatic void nfs_readdir_clear_array(struct folio *folio)\n{\n\tstruct nfs_cache_array *array;\n\tunsigned int i;\n\n\tarray = kmap_local_folio(folio, 0);\n\tfor (i = 0; i < array->size; i++)\n\t\tkfree(array->array[i].name);\n\tarray->size = 0;\n\tkunmap_local(array);\n}\n\nstatic void nfs_readdir_folio_reinit_array(struct folio *folio, u64 last_cookie,\n\t\t\t\t\t   u64 change_attr)\n{\n\tnfs_readdir_clear_array(folio);\n\tnfs_readdir_folio_init_array(folio, last_cookie, change_attr);\n}\n\nstatic struct folio *\nnfs_readdir_folio_array_alloc(u64 last_cookie, gfp_t gfp_flags)\n{\n\tstruct folio *folio = folio_alloc(gfp_flags, 0);\n\tif (folio)\n\t\tnfs_readdir_folio_init_array(folio, last_cookie, 0);\n\treturn folio;\n}\n\nstatic void nfs_readdir_folio_array_free(struct folio *folio)\n{\n\tif (folio) {\n\t\tnfs_readdir_clear_array(folio);\n\t\tfolio_put(folio);\n\t}\n}\n\nstatic u64 nfs_readdir_array_index_cookie(struct nfs_cache_array *array)\n{\n\treturn array->size == 0 ? array->last_cookie : array->array[0].cookie;\n}\n\nstatic void nfs_readdir_array_set_eof(struct nfs_cache_array *array)\n{\n\tarray->folio_is_eof = 1;\n\tarray->folio_full = 1;\n}\n\nstatic bool nfs_readdir_array_is_full(struct nfs_cache_array *array)\n{\n\treturn array->folio_full;\n}\n\n \nstatic const char *nfs_readdir_copy_name(const char *name, unsigned int len)\n{\n\tconst char *ret = kmemdup_nul(name, len, GFP_KERNEL);\n\n\t \n\tif (ret != NULL)\n\t\tkmemleak_not_leak(ret);\n\treturn ret;\n}\n\nstatic size_t nfs_readdir_array_maxentries(void)\n{\n\treturn (PAGE_SIZE - sizeof(struct nfs_cache_array)) /\n\t       sizeof(struct nfs_cache_array_entry);\n}\n\n \nstatic int nfs_readdir_array_can_expand(struct nfs_cache_array *array)\n{\n\tif (array->folio_full)\n\t\treturn -ENOSPC;\n\tif (array->size == nfs_readdir_array_maxentries()) {\n\t\tarray->folio_full = 1;\n\t\treturn -ENOSPC;\n\t}\n\treturn 0;\n}\n\nstatic int nfs_readdir_folio_array_append(struct folio *folio,\n\t\t\t\t\t  const struct nfs_entry *entry,\n\t\t\t\t\t  u64 *cookie)\n{\n\tstruct nfs_cache_array *array;\n\tstruct nfs_cache_array_entry *cache_entry;\n\tconst char *name;\n\tint ret = -ENOMEM;\n\n\tname = nfs_readdir_copy_name(entry->name, entry->len);\n\n\tarray = kmap_local_folio(folio, 0);\n\tif (!name)\n\t\tgoto out;\n\tret = nfs_readdir_array_can_expand(array);\n\tif (ret) {\n\t\tkfree(name);\n\t\tgoto out;\n\t}\n\n\tcache_entry = &array->array[array->size];\n\tcache_entry->cookie = array->last_cookie;\n\tcache_entry->ino = entry->ino;\n\tcache_entry->d_type = entry->d_type;\n\tcache_entry->name_len = entry->len;\n\tcache_entry->name = name;\n\tarray->last_cookie = entry->cookie;\n\tif (array->last_cookie <= cache_entry->cookie)\n\t\tarray->cookies_are_ordered = 0;\n\tarray->size++;\n\tif (entry->eof != 0)\n\t\tnfs_readdir_array_set_eof(array);\nout:\n\t*cookie = array->last_cookie;\n\tkunmap_local(array);\n\treturn ret;\n}\n\n#define NFS_READDIR_COOKIE_MASK (U32_MAX >> 14)\n \nstatic pgoff_t nfs_readdir_folio_cookie_hash(u64 cookie)\n{\n\tif (cookie == 0)\n\t\treturn 0;\n\treturn hash_64(cookie, 18);\n}\n\nstatic bool nfs_readdir_folio_validate(struct folio *folio, u64 last_cookie,\n\t\t\t\t       u64 change_attr)\n{\n\tstruct nfs_cache_array *array = kmap_local_folio(folio, 0);\n\tint ret = true;\n\n\tif (array->change_attr != change_attr)\n\t\tret = false;\n\tif (nfs_readdir_array_index_cookie(array) != last_cookie)\n\t\tret = false;\n\tkunmap_local(array);\n\treturn ret;\n}\n\nstatic void nfs_readdir_folio_unlock_and_put(struct folio *folio)\n{\n\tfolio_unlock(folio);\n\tfolio_put(folio);\n}\n\nstatic void nfs_readdir_folio_init_and_validate(struct folio *folio, u64 cookie,\n\t\t\t\t\t\tu64 change_attr)\n{\n\tif (folio_test_uptodate(folio)) {\n\t\tif (nfs_readdir_folio_validate(folio, cookie, change_attr))\n\t\t\treturn;\n\t\tnfs_readdir_clear_array(folio);\n\t}\n\tnfs_readdir_folio_init_array(folio, cookie, change_attr);\n\tfolio_mark_uptodate(folio);\n}\n\nstatic struct folio *nfs_readdir_folio_get_locked(struct address_space *mapping,\n\t\t\t\t\t\t  u64 cookie, u64 change_attr)\n{\n\tpgoff_t index = nfs_readdir_folio_cookie_hash(cookie);\n\tstruct folio *folio;\n\n\tfolio = filemap_grab_folio(mapping, index);\n\tif (IS_ERR(folio))\n\t\treturn NULL;\n\tnfs_readdir_folio_init_and_validate(folio, cookie, change_attr);\n\treturn folio;\n}\n\nstatic u64 nfs_readdir_folio_last_cookie(struct folio *folio)\n{\n\tstruct nfs_cache_array *array;\n\tu64 ret;\n\n\tarray = kmap_local_folio(folio, 0);\n\tret = array->last_cookie;\n\tkunmap_local(array);\n\treturn ret;\n}\n\nstatic bool nfs_readdir_folio_needs_filling(struct folio *folio)\n{\n\tstruct nfs_cache_array *array;\n\tbool ret;\n\n\tarray = kmap_local_folio(folio, 0);\n\tret = !nfs_readdir_array_is_full(array);\n\tkunmap_local(array);\n\treturn ret;\n}\n\nstatic void nfs_readdir_folio_set_eof(struct folio *folio)\n{\n\tstruct nfs_cache_array *array;\n\n\tarray = kmap_local_folio(folio, 0);\n\tnfs_readdir_array_set_eof(array);\n\tkunmap_local(array);\n}\n\nstatic struct folio *nfs_readdir_folio_get_next(struct address_space *mapping,\n\t\t\t\t\t\tu64 cookie, u64 change_attr)\n{\n\tpgoff_t index = nfs_readdir_folio_cookie_hash(cookie);\n\tstruct folio *folio;\n\n\tfolio = __filemap_get_folio(mapping, index,\n\t\t\tFGP_LOCK|FGP_CREAT|FGP_NOFS|FGP_NOWAIT,\n\t\t\tmapping_gfp_mask(mapping));\n\tif (IS_ERR(folio))\n\t\treturn NULL;\n\tnfs_readdir_folio_init_and_validate(folio, cookie, change_attr);\n\tif (nfs_readdir_folio_last_cookie(folio) != cookie)\n\t\tnfs_readdir_folio_reinit_array(folio, cookie, change_attr);\n\treturn folio;\n}\n\nstatic inline\nint is_32bit_api(void)\n{\n#ifdef CONFIG_COMPAT\n\treturn in_compat_syscall();\n#else\n\treturn (BITS_PER_LONG == 32);\n#endif\n}\n\nstatic\nbool nfs_readdir_use_cookie(const struct file *filp)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn false;\n\treturn true;\n}\n\nstatic void nfs_readdir_seek_next_array(struct nfs_cache_array *array,\n\t\t\t\t\tstruct nfs_readdir_descriptor *desc)\n{\n\tif (array->folio_full) {\n\t\tdesc->last_cookie = array->last_cookie;\n\t\tdesc->current_index += array->size;\n\t\tdesc->cache_entry_index = 0;\n\t\tdesc->folio_index++;\n\t} else\n\t\tdesc->last_cookie = nfs_readdir_array_index_cookie(array);\n}\n\nstatic void nfs_readdir_rewind_search(struct nfs_readdir_descriptor *desc)\n{\n\tdesc->current_index = 0;\n\tdesc->last_cookie = 0;\n\tdesc->folio_index = 0;\n}\n\nstatic int nfs_readdir_search_for_pos(struct nfs_cache_array *array,\n\t\t\t\t      struct nfs_readdir_descriptor *desc)\n{\n\tloff_t diff = desc->ctx->pos - desc->current_index;\n\tunsigned int index;\n\n\tif (diff < 0)\n\t\tgoto out_eof;\n\tif (diff >= array->size) {\n\t\tif (array->folio_is_eof)\n\t\t\tgoto out_eof;\n\t\tnfs_readdir_seek_next_array(array, desc);\n\t\treturn -EAGAIN;\n\t}\n\n\tindex = (unsigned int)diff;\n\tdesc->dir_cookie = array->array[index].cookie;\n\tdesc->cache_entry_index = index;\n\treturn 0;\nout_eof:\n\tdesc->eof = true;\n\treturn -EBADCOOKIE;\n}\n\nstatic bool nfs_readdir_array_cookie_in_range(struct nfs_cache_array *array,\n\t\t\t\t\t      u64 cookie)\n{\n\tif (!array->cookies_are_ordered)\n\t\treturn true;\n\t \n\tif (cookie >= array->last_cookie)\n\t\treturn false;\n\tif (array->size && cookie < array->array[0].cookie)\n\t\treturn false;\n\treturn true;\n}\n\nstatic int nfs_readdir_search_for_cookie(struct nfs_cache_array *array,\n\t\t\t\t\t struct nfs_readdir_descriptor *desc)\n{\n\tunsigned int i;\n\tint status = -EAGAIN;\n\n\tif (!nfs_readdir_array_cookie_in_range(array, desc->dir_cookie))\n\t\tgoto check_eof;\n\n\tfor (i = 0; i < array->size; i++) {\n\t\tif (array->array[i].cookie == desc->dir_cookie) {\n\t\t\tif (nfs_readdir_use_cookie(desc->file))\n\t\t\t\tdesc->ctx->pos = desc->dir_cookie;\n\t\t\telse\n\t\t\t\tdesc->ctx->pos = desc->current_index + i;\n\t\t\tdesc->cache_entry_index = i;\n\t\t\treturn 0;\n\t\t}\n\t}\ncheck_eof:\n\tif (array->folio_is_eof) {\n\t\tstatus = -EBADCOOKIE;\n\t\tif (desc->dir_cookie == array->last_cookie)\n\t\t\tdesc->eof = true;\n\t} else\n\t\tnfs_readdir_seek_next_array(array, desc);\n\treturn status;\n}\n\nstatic int nfs_readdir_search_array(struct nfs_readdir_descriptor *desc)\n{\n\tstruct nfs_cache_array *array;\n\tint status;\n\n\tarray = kmap_local_folio(desc->folio, 0);\n\n\tif (desc->dir_cookie == 0)\n\t\tstatus = nfs_readdir_search_for_pos(array, desc);\n\telse\n\t\tstatus = nfs_readdir_search_for_cookie(array, desc);\n\n\tkunmap_local(array);\n\treturn status;\n}\n\n \nstatic int nfs_readdir_xdr_filler(struct nfs_readdir_descriptor *desc,\n\t\t\t\t  __be32 *verf, u64 cookie,\n\t\t\t\t  struct page **pages, size_t bufsize,\n\t\t\t\t  __be32 *verf_res)\n{\n\tstruct inode *inode = file_inode(desc->file);\n\tstruct nfs_readdir_arg arg = {\n\t\t.dentry = file_dentry(desc->file),\n\t\t.cred = desc->file->f_cred,\n\t\t.verf = verf,\n\t\t.cookie = cookie,\n\t\t.pages = pages,\n\t\t.page_len = bufsize,\n\t\t.plus = desc->plus,\n\t};\n\tstruct nfs_readdir_res res = {\n\t\t.verf = verf_res,\n\t};\n\tunsigned long\ttimestamp, gencount;\n\tint\t\terror;\n\n again:\n\ttimestamp = jiffies;\n\tgencount = nfs_inc_attr_generation_counter();\n\tdesc->dir_verifier = nfs_save_change_attribute(inode);\n\terror = NFS_PROTO(inode)->readdir(&arg, &res);\n\tif (error < 0) {\n\t\t \n\t\tif (error == -ENOTSUPP && desc->plus) {\n\t\t\tNFS_SERVER(inode)->caps &= ~NFS_CAP_READDIRPLUS;\n\t\t\tdesc->plus = arg.plus = false;\n\t\t\tgoto again;\n\t\t}\n\t\tgoto error;\n\t}\n\tdesc->timestamp = timestamp;\n\tdesc->gencount = gencount;\nerror:\n\treturn error;\n}\n\nstatic int xdr_decode(struct nfs_readdir_descriptor *desc,\n\t\t      struct nfs_entry *entry, struct xdr_stream *xdr)\n{\n\tstruct inode *inode = file_inode(desc->file);\n\tint error;\n\n\terror = NFS_PROTO(inode)->decode_dirent(xdr, entry, desc->plus);\n\tif (error)\n\t\treturn error;\n\tentry->fattr->time_start = desc->timestamp;\n\tentry->fattr->gencount = desc->gencount;\n\treturn 0;\n}\n\n \nstatic\nint nfs_same_file(struct dentry *dentry, struct nfs_entry *entry)\n{\n\tstruct inode *inode;\n\tstruct nfs_inode *nfsi;\n\n\tif (d_really_is_negative(dentry))\n\t\treturn 0;\n\n\tinode = d_inode(dentry);\n\tif (is_bad_inode(inode) || NFS_STALE(inode))\n\t\treturn 0;\n\n\tnfsi = NFS_I(inode);\n\tif (entry->fattr->fileid != nfsi->fileid)\n\t\treturn 0;\n\tif (entry->fh->size && nfs_compare_fh(entry->fh, &nfsi->fh) != 0)\n\t\treturn 0;\n\treturn 1;\n}\n\n#define NFS_READDIR_CACHE_USAGE_THRESHOLD (8UL)\n\nstatic bool nfs_use_readdirplus(struct inode *dir, struct dir_context *ctx,\n\t\t\t\tunsigned int cache_hits,\n\t\t\t\tunsigned int cache_misses)\n{\n\tif (!nfs_server_capable(dir, NFS_CAP_READDIRPLUS))\n\t\treturn false;\n\tif (ctx->pos == 0 ||\n\t    cache_hits + cache_misses > NFS_READDIR_CACHE_USAGE_THRESHOLD)\n\t\treturn true;\n\treturn false;\n}\n\n \nvoid nfs_readdir_record_entry_cache_hit(struct inode *dir)\n{\n\tstruct nfs_inode *nfsi = NFS_I(dir);\n\tstruct nfs_open_dir_context *ctx;\n\n\tif (nfs_server_capable(dir, NFS_CAP_READDIRPLUS) &&\n\t    S_ISDIR(dir->i_mode)) {\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu (ctx, &nfsi->open_files, list)\n\t\t\tatomic_inc(&ctx->cache_hits);\n\t\trcu_read_unlock();\n\t}\n}\n\n \nvoid nfs_readdir_record_entry_cache_miss(struct inode *dir)\n{\n\tstruct nfs_inode *nfsi = NFS_I(dir);\n\tstruct nfs_open_dir_context *ctx;\n\n\tif (nfs_server_capable(dir, NFS_CAP_READDIRPLUS) &&\n\t    S_ISDIR(dir->i_mode)) {\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu (ctx, &nfsi->open_files, list)\n\t\t\tatomic_inc(&ctx->cache_misses);\n\t\trcu_read_unlock();\n\t}\n}\n\nstatic void nfs_lookup_advise_force_readdirplus(struct inode *dir,\n\t\t\t\t\t\tunsigned int flags)\n{\n\tif (nfs_server_capable(dir, NFS_CAP_CASE_INSENSITIVE))\n\t\treturn;\n\tif (flags & (LOOKUP_EXCL | LOOKUP_PARENT | LOOKUP_REVAL))\n\t\treturn;\n\tnfs_readdir_record_entry_cache_miss(dir);\n}\n\nstatic\nvoid nfs_prime_dcache(struct dentry *parent, struct nfs_entry *entry,\n\t\tunsigned long dir_verifier)\n{\n\tstruct qstr filename = QSTR_INIT(entry->name, entry->len);\n\tDECLARE_WAIT_QUEUE_HEAD_ONSTACK(wq);\n\tstruct dentry *dentry;\n\tstruct dentry *alias;\n\tstruct inode *inode;\n\tint status;\n\n\tif (!(entry->fattr->valid & NFS_ATTR_FATTR_FILEID))\n\t\treturn;\n\tif (!(entry->fattr->valid & NFS_ATTR_FATTR_FSID))\n\t\treturn;\n\tif (filename.len == 0)\n\t\treturn;\n\t \n\tif (strnlen(filename.name, filename.len) != filename.len)\n\t\treturn;\n\t \n\tif (strnchr(filename.name, filename.len, '/'))\n\t\treturn;\n\tif (filename.name[0] == '.') {\n\t\tif (filename.len == 1)\n\t\t\treturn;\n\t\tif (filename.len == 2 && filename.name[1] == '.')\n\t\t\treturn;\n\t}\n\tfilename.hash = full_name_hash(parent, filename.name, filename.len);\n\n\tdentry = d_lookup(parent, &filename);\nagain:\n\tif (!dentry) {\n\t\tdentry = d_alloc_parallel(parent, &filename, &wq);\n\t\tif (IS_ERR(dentry))\n\t\t\treturn;\n\t}\n\tif (!d_in_lookup(dentry)) {\n\t\t \n\t\tif (!nfs_fsid_equal(&NFS_SB(dentry->d_sb)->fsid,\n\t\t\t\t\t&entry->fattr->fsid))\n\t\t\tgoto out;\n\t\tif (nfs_same_file(dentry, entry)) {\n\t\t\tif (!entry->fh->size)\n\t\t\t\tgoto out;\n\t\t\tnfs_set_verifier(dentry, dir_verifier);\n\t\t\tstatus = nfs_refresh_inode(d_inode(dentry), entry->fattr);\n\t\t\tif (!status)\n\t\t\t\tnfs_setsecurity(d_inode(dentry), entry->fattr);\n\t\t\ttrace_nfs_readdir_lookup_revalidate(d_inode(parent),\n\t\t\t\t\t\t\t    dentry, 0, status);\n\t\t\tgoto out;\n\t\t} else {\n\t\t\ttrace_nfs_readdir_lookup_revalidate_failed(\n\t\t\t\td_inode(parent), dentry, 0);\n\t\t\td_invalidate(dentry);\n\t\t\tdput(dentry);\n\t\t\tdentry = NULL;\n\t\t\tgoto again;\n\t\t}\n\t}\n\tif (!entry->fh->size) {\n\t\td_lookup_done(dentry);\n\t\tgoto out;\n\t}\n\n\tinode = nfs_fhget(dentry->d_sb, entry->fh, entry->fattr);\n\talias = d_splice_alias(inode, dentry);\n\td_lookup_done(dentry);\n\tif (alias) {\n\t\tif (IS_ERR(alias))\n\t\t\tgoto out;\n\t\tdput(dentry);\n\t\tdentry = alias;\n\t}\n\tnfs_set_verifier(dentry, dir_verifier);\n\ttrace_nfs_readdir_lookup(d_inode(parent), dentry, 0);\nout:\n\tdput(dentry);\n}\n\nstatic int nfs_readdir_entry_decode(struct nfs_readdir_descriptor *desc,\n\t\t\t\t    struct nfs_entry *entry,\n\t\t\t\t    struct xdr_stream *stream)\n{\n\tint ret;\n\n\tif (entry->fattr->label)\n\t\tentry->fattr->label->len = NFS4_MAXLABELLEN;\n\tret = xdr_decode(desc, entry, stream);\n\tif (ret || !desc->plus)\n\t\treturn ret;\n\tnfs_prime_dcache(file_dentry(desc->file), entry, desc->dir_verifier);\n\treturn 0;\n}\n\n \nstatic int nfs_readdir_folio_filler(struct nfs_readdir_descriptor *desc,\n\t\t\t\t    struct nfs_entry *entry,\n\t\t\t\t    struct page **xdr_pages, unsigned int buflen,\n\t\t\t\t    struct folio **arrays, size_t narrays,\n\t\t\t\t    u64 change_attr)\n{\n\tstruct address_space *mapping = desc->file->f_mapping;\n\tstruct folio *new, *folio = *arrays;\n\tstruct xdr_stream stream;\n\tstruct page *scratch;\n\tstruct xdr_buf buf;\n\tu64 cookie;\n\tint status;\n\n\tscratch = alloc_page(GFP_KERNEL);\n\tif (scratch == NULL)\n\t\treturn -ENOMEM;\n\n\txdr_init_decode_pages(&stream, &buf, xdr_pages, buflen);\n\txdr_set_scratch_page(&stream, scratch);\n\n\tdo {\n\t\tstatus = nfs_readdir_entry_decode(desc, entry, &stream);\n\t\tif (status != 0)\n\t\t\tbreak;\n\n\t\tstatus = nfs_readdir_folio_array_append(folio, entry, &cookie);\n\t\tif (status != -ENOSPC)\n\t\t\tcontinue;\n\n\t\tif (folio->mapping != mapping) {\n\t\t\tif (!--narrays)\n\t\t\t\tbreak;\n\t\t\tnew = nfs_readdir_folio_array_alloc(cookie, GFP_KERNEL);\n\t\t\tif (!new)\n\t\t\t\tbreak;\n\t\t\tarrays++;\n\t\t\t*arrays = folio = new;\n\t\t} else {\n\t\t\tnew = nfs_readdir_folio_get_next(mapping, cookie,\n\t\t\t\t\t\t\t change_attr);\n\t\t\tif (!new)\n\t\t\t\tbreak;\n\t\t\tif (folio != *arrays)\n\t\t\t\tnfs_readdir_folio_unlock_and_put(folio);\n\t\t\tfolio = new;\n\t\t}\n\t\tdesc->folio_index_max++;\n\t\tstatus = nfs_readdir_folio_array_append(folio, entry, &cookie);\n\t} while (!status && !entry->eof);\n\n\tswitch (status) {\n\tcase -EBADCOOKIE:\n\t\tif (!entry->eof)\n\t\t\tbreak;\n\t\tnfs_readdir_folio_set_eof(folio);\n\t\tfallthrough;\n\tcase -EAGAIN:\n\t\tstatus = 0;\n\t\tbreak;\n\tcase -ENOSPC:\n\t\tstatus = 0;\n\t\tif (!desc->plus)\n\t\t\tbreak;\n\t\twhile (!nfs_readdir_entry_decode(desc, entry, &stream))\n\t\t\t;\n\t}\n\n\tif (folio != *arrays)\n\t\tnfs_readdir_folio_unlock_and_put(folio);\n\n\tput_page(scratch);\n\treturn status;\n}\n\nstatic void nfs_readdir_free_pages(struct page **pages, size_t npages)\n{\n\twhile (npages--)\n\t\tput_page(pages[npages]);\n\tkfree(pages);\n}\n\n \nstatic struct page **nfs_readdir_alloc_pages(size_t npages)\n{\n\tstruct page **pages;\n\tsize_t i;\n\n\tpages = kmalloc_array(npages, sizeof(*pages), GFP_KERNEL);\n\tif (!pages)\n\t\treturn NULL;\n\tfor (i = 0; i < npages; i++) {\n\t\tstruct page *page = alloc_page(GFP_KERNEL);\n\t\tif (page == NULL)\n\t\t\tgoto out_freepages;\n\t\tpages[i] = page;\n\t}\n\treturn pages;\n\nout_freepages:\n\tnfs_readdir_free_pages(pages, i);\n\treturn NULL;\n}\n\nstatic int nfs_readdir_xdr_to_array(struct nfs_readdir_descriptor *desc,\n\t\t\t\t    __be32 *verf_arg, __be32 *verf_res,\n\t\t\t\t    struct folio **arrays, size_t narrays)\n{\n\tu64 change_attr;\n\tstruct page **pages;\n\tstruct folio *folio = *arrays;\n\tstruct nfs_entry *entry;\n\tsize_t array_size;\n\tstruct inode *inode = file_inode(desc->file);\n\tunsigned int dtsize = desc->dtsize;\n\tunsigned int pglen;\n\tint status = -ENOMEM;\n\n\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\tentry->cookie = nfs_readdir_folio_last_cookie(folio);\n\tentry->fh = nfs_alloc_fhandle();\n\tentry->fattr = nfs_alloc_fattr_with_label(NFS_SERVER(inode));\n\tentry->server = NFS_SERVER(inode);\n\tif (entry->fh == NULL || entry->fattr == NULL)\n\t\tgoto out;\n\n\tarray_size = (dtsize + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tpages = nfs_readdir_alloc_pages(array_size);\n\tif (!pages)\n\t\tgoto out;\n\n\tchange_attr = inode_peek_iversion_raw(inode);\n\tstatus = nfs_readdir_xdr_filler(desc, verf_arg, entry->cookie, pages,\n\t\t\t\t\tdtsize, verf_res);\n\tif (status < 0)\n\t\tgoto free_pages;\n\n\tpglen = status;\n\tif (pglen != 0)\n\t\tstatus = nfs_readdir_folio_filler(desc, entry, pages, pglen,\n\t\t\t\t\t\t  arrays, narrays, change_attr);\n\telse\n\t\tnfs_readdir_folio_set_eof(folio);\n\tdesc->buffer_fills++;\n\nfree_pages:\n\tnfs_readdir_free_pages(pages, array_size);\nout:\n\tnfs_free_fattr(entry->fattr);\n\tnfs_free_fhandle(entry->fh);\n\tkfree(entry);\n\treturn status;\n}\n\nstatic void nfs_readdir_folio_put(struct nfs_readdir_descriptor *desc)\n{\n\tfolio_put(desc->folio);\n\tdesc->folio = NULL;\n}\n\nstatic void\nnfs_readdir_folio_unlock_and_put_cached(struct nfs_readdir_descriptor *desc)\n{\n\tfolio_unlock(desc->folio);\n\tnfs_readdir_folio_put(desc);\n}\n\nstatic struct folio *\nnfs_readdir_folio_get_cached(struct nfs_readdir_descriptor *desc)\n{\n\tstruct address_space *mapping = desc->file->f_mapping;\n\tu64 change_attr = inode_peek_iversion_raw(mapping->host);\n\tu64 cookie = desc->last_cookie;\n\tstruct folio *folio;\n\n\tfolio = nfs_readdir_folio_get_locked(mapping, cookie, change_attr);\n\tif (!folio)\n\t\treturn NULL;\n\tif (desc->clear_cache && !nfs_readdir_folio_needs_filling(folio))\n\t\tnfs_readdir_folio_reinit_array(folio, cookie, change_attr);\n\treturn folio;\n}\n\n \nstatic int find_and_lock_cache_page(struct nfs_readdir_descriptor *desc)\n{\n\tstruct inode *inode = file_inode(desc->file);\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\t__be32 verf[NFS_DIR_VERIFIER_SIZE];\n\tint res;\n\n\tdesc->folio = nfs_readdir_folio_get_cached(desc);\n\tif (!desc->folio)\n\t\treturn -ENOMEM;\n\tif (nfs_readdir_folio_needs_filling(desc->folio)) {\n\t\t \n\t\tif (desc->folio_index == desc->folio_index_max)\n\t\t\tnfs_grow_dtsize(desc);\n\t\tdesc->folio_index_max = desc->folio_index;\n\t\ttrace_nfs_readdir_cache_fill(desc->file, nfsi->cookieverf,\n\t\t\t\t\t     desc->last_cookie,\n\t\t\t\t\t     desc->folio->index, desc->dtsize);\n\t\tres = nfs_readdir_xdr_to_array(desc, nfsi->cookieverf, verf,\n\t\t\t\t\t       &desc->folio, 1);\n\t\tif (res < 0) {\n\t\t\tnfs_readdir_folio_unlock_and_put_cached(desc);\n\t\t\ttrace_nfs_readdir_cache_fill_done(inode, res);\n\t\t\tif (res == -EBADCOOKIE || res == -ENOTSYNC) {\n\t\t\t\tinvalidate_inode_pages2(desc->file->f_mapping);\n\t\t\t\tnfs_readdir_rewind_search(desc);\n\t\t\t\ttrace_nfs_readdir_invalidate_cache_range(\n\t\t\t\t\tinode, 0, MAX_LFS_FILESIZE);\n\t\t\t\treturn -EAGAIN;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\t \n\t\tif (desc->last_cookie == 0 &&\n\t\t    memcmp(nfsi->cookieverf, verf, sizeof(nfsi->cookieverf))) {\n\t\t\tmemcpy(nfsi->cookieverf, verf,\n\t\t\t       sizeof(nfsi->cookieverf));\n\t\t\tinvalidate_inode_pages2_range(desc->file->f_mapping, 1,\n\t\t\t\t\t\t      -1);\n\t\t\ttrace_nfs_readdir_invalidate_cache_range(\n\t\t\t\tinode, 1, MAX_LFS_FILESIZE);\n\t\t}\n\t\tdesc->clear_cache = false;\n\t}\n\tres = nfs_readdir_search_array(desc);\n\tif (res == 0)\n\t\treturn 0;\n\tnfs_readdir_folio_unlock_and_put_cached(desc);\n\treturn res;\n}\n\n \nstatic int readdir_search_pagecache(struct nfs_readdir_descriptor *desc)\n{\n\tint res;\n\n\tdo {\n\t\tres = find_and_lock_cache_page(desc);\n\t} while (res == -EAGAIN);\n\treturn res;\n}\n\n#define NFS_READDIR_CACHE_MISS_THRESHOLD (16UL)\n\n \nstatic void nfs_do_filldir(struct nfs_readdir_descriptor *desc,\n\t\t\t   const __be32 *verf)\n{\n\tstruct file\t*file = desc->file;\n\tstruct nfs_cache_array *array;\n\tunsigned int i;\n\tbool first_emit = !desc->dir_cookie;\n\n\tarray = kmap_local_folio(desc->folio, 0);\n\tfor (i = desc->cache_entry_index; i < array->size; i++) {\n\t\tstruct nfs_cache_array_entry *ent;\n\n\t\t \n\t\tif (first_emit && i > NFS_READDIR_CACHE_MISS_THRESHOLD + 2) {\n\t\t\tdesc->eob = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tent = &array->array[i];\n\t\tif (!dir_emit(desc->ctx, ent->name, ent->name_len,\n\t\t    nfs_compat_user_ino64(ent->ino), ent->d_type)) {\n\t\t\tdesc->eob = true;\n\t\t\tbreak;\n\t\t}\n\t\tmemcpy(desc->verf, verf, sizeof(desc->verf));\n\t\tif (i == array->size - 1) {\n\t\t\tdesc->dir_cookie = array->last_cookie;\n\t\t\tnfs_readdir_seek_next_array(array, desc);\n\t\t} else {\n\t\t\tdesc->dir_cookie = array->array[i + 1].cookie;\n\t\t\tdesc->last_cookie = array->array[0].cookie;\n\t\t}\n\t\tif (nfs_readdir_use_cookie(file))\n\t\t\tdesc->ctx->pos = desc->dir_cookie;\n\t\telse\n\t\t\tdesc->ctx->pos++;\n\t}\n\tif (array->folio_is_eof)\n\t\tdesc->eof = !desc->eob;\n\n\tkunmap_local(array);\n\tdfprintk(DIRCACHE, \"NFS: nfs_do_filldir() filling ended @ cookie %llu\\n\",\n\t\t\t(unsigned long long)desc->dir_cookie);\n}\n\n \nstatic int uncached_readdir(struct nfs_readdir_descriptor *desc)\n{\n\tstruct folio\t**arrays;\n\tsize_t\t\ti, sz = 512;\n\t__be32\t\tverf[NFS_DIR_VERIFIER_SIZE];\n\tint\t\tstatus = -ENOMEM;\n\n\tdfprintk(DIRCACHE, \"NFS: uncached_readdir() searching for cookie %llu\\n\",\n\t\t\t(unsigned long long)desc->dir_cookie);\n\n\tarrays = kcalloc(sz, sizeof(*arrays), GFP_KERNEL);\n\tif (!arrays)\n\t\tgoto out;\n\tarrays[0] = nfs_readdir_folio_array_alloc(desc->dir_cookie, GFP_KERNEL);\n\tif (!arrays[0])\n\t\tgoto out;\n\n\tdesc->folio_index = 0;\n\tdesc->cache_entry_index = 0;\n\tdesc->last_cookie = desc->dir_cookie;\n\tdesc->folio_index_max = 0;\n\n\ttrace_nfs_readdir_uncached(desc->file, desc->verf, desc->last_cookie,\n\t\t\t\t   -1, desc->dtsize);\n\n\tstatus = nfs_readdir_xdr_to_array(desc, desc->verf, verf, arrays, sz);\n\tif (status < 0) {\n\t\ttrace_nfs_readdir_uncached_done(file_inode(desc->file), status);\n\t\tgoto out_free;\n\t}\n\n\tfor (i = 0; !desc->eob && i < sz && arrays[i]; i++) {\n\t\tdesc->folio = arrays[i];\n\t\tnfs_do_filldir(desc, verf);\n\t}\n\tdesc->folio = NULL;\n\n\t \n\tif (!desc->eof) {\n\t\tif (!desc->eob)\n\t\t\tnfs_grow_dtsize(desc);\n\t\telse if (desc->buffer_fills == 1 &&\n\t\t\t i < (desc->folio_index_max >> 1))\n\t\t\tnfs_shrink_dtsize(desc);\n\t}\nout_free:\n\tfor (i = 0; i < sz && arrays[i]; i++)\n\t\tnfs_readdir_folio_array_free(arrays[i]);\nout:\n\tif (!nfs_readdir_use_cookie(desc->file))\n\t\tnfs_readdir_rewind_search(desc);\n\tdesc->folio_index_max = -1;\n\tkfree(arrays);\n\tdfprintk(DIRCACHE, \"NFS: %s: returns %d\\n\", __func__, status);\n\treturn status;\n}\n\nstatic bool nfs_readdir_handle_cache_misses(struct inode *inode,\n\t\t\t\t\t    struct nfs_readdir_descriptor *desc,\n\t\t\t\t\t    unsigned int cache_misses,\n\t\t\t\t\t    bool force_clear)\n{\n\tif (desc->ctx->pos == 0 || !desc->plus)\n\t\treturn false;\n\tif (cache_misses <= NFS_READDIR_CACHE_MISS_THRESHOLD && !force_clear)\n\t\treturn false;\n\ttrace_nfs_readdir_force_readdirplus(inode);\n\treturn true;\n}\n\n \nstatic int nfs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct dentry\t*dentry = file_dentry(file);\n\tstruct inode\t*inode = d_inode(dentry);\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs_open_dir_context *dir_ctx = file->private_data;\n\tstruct nfs_readdir_descriptor *desc;\n\tunsigned int cache_hits, cache_misses;\n\tbool force_clear;\n\tint res;\n\n\tdfprintk(FILE, \"NFS: readdir(%pD2) starting at cookie %llu\\n\",\n\t\t\tfile, (long long)ctx->pos);\n\tnfs_inc_stats(inode, NFSIOS_VFSGETDENTS);\n\n\t \n\tnfs_revalidate_mapping(inode, file->f_mapping);\n\n\tres = -ENOMEM;\n\tdesc = kzalloc(sizeof(*desc), GFP_KERNEL);\n\tif (!desc)\n\t\tgoto out;\n\tdesc->file = file;\n\tdesc->ctx = ctx;\n\tdesc->folio_index_max = -1;\n\n\tspin_lock(&file->f_lock);\n\tdesc->dir_cookie = dir_ctx->dir_cookie;\n\tdesc->folio_index = dir_ctx->page_index;\n\tdesc->last_cookie = dir_ctx->last_cookie;\n\tdesc->attr_gencount = dir_ctx->attr_gencount;\n\tdesc->eof = dir_ctx->eof;\n\tnfs_set_dtsize(desc, dir_ctx->dtsize);\n\tmemcpy(desc->verf, dir_ctx->verf, sizeof(desc->verf));\n\tcache_hits = atomic_xchg(&dir_ctx->cache_hits, 0);\n\tcache_misses = atomic_xchg(&dir_ctx->cache_misses, 0);\n\tforce_clear = dir_ctx->force_clear;\n\tspin_unlock(&file->f_lock);\n\n\tif (desc->eof) {\n\t\tres = 0;\n\t\tgoto out_free;\n\t}\n\n\tdesc->plus = nfs_use_readdirplus(inode, ctx, cache_hits, cache_misses);\n\tforce_clear = nfs_readdir_handle_cache_misses(inode, desc, cache_misses,\n\t\t\t\t\t\t      force_clear);\n\tdesc->clear_cache = force_clear;\n\n\tdo {\n\t\tres = readdir_search_pagecache(desc);\n\n\t\tif (res == -EBADCOOKIE) {\n\t\t\tres = 0;\n\t\t\t \n\t\t\tif (desc->dir_cookie && !desc->eof) {\n\t\t\t\t \n\t\t\t\tres = uncached_readdir(desc);\n\t\t\t\tif (res == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (res == -EBADCOOKIE || res == -ENOTSYNC)\n\t\t\t\t\tres = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (res == -ETOOSMALL && desc->plus) {\n\t\t\tnfs_zap_caches(inode);\n\t\t\tdesc->plus = false;\n\t\t\tdesc->eof = false;\n\t\t\tcontinue;\n\t\t}\n\t\tif (res < 0)\n\t\t\tbreak;\n\n\t\tnfs_do_filldir(desc, nfsi->cookieverf);\n\t\tnfs_readdir_folio_unlock_and_put_cached(desc);\n\t\tif (desc->folio_index == desc->folio_index_max)\n\t\t\tdesc->clear_cache = force_clear;\n\t} while (!desc->eob && !desc->eof);\n\n\tspin_lock(&file->f_lock);\n\tdir_ctx->dir_cookie = desc->dir_cookie;\n\tdir_ctx->last_cookie = desc->last_cookie;\n\tdir_ctx->attr_gencount = desc->attr_gencount;\n\tdir_ctx->page_index = desc->folio_index;\n\tdir_ctx->force_clear = force_clear;\n\tdir_ctx->eof = desc->eof;\n\tdir_ctx->dtsize = desc->dtsize;\n\tmemcpy(dir_ctx->verf, desc->verf, sizeof(dir_ctx->verf));\n\tspin_unlock(&file->f_lock);\nout_free:\n\tkfree(desc);\n\nout:\n\tdfprintk(FILE, \"NFS: readdir(%pD2) returns %d\\n\", file, res);\n\treturn res;\n}\n\nstatic loff_t nfs_llseek_dir(struct file *filp, loff_t offset, int whence)\n{\n\tstruct nfs_open_dir_context *dir_ctx = filp->private_data;\n\n\tdfprintk(FILE, \"NFS: llseek dir(%pD2, %lld, %d)\\n\",\n\t\t\tfilp, offset, whence);\n\n\tswitch (whence) {\n\tdefault:\n\t\treturn -EINVAL;\n\tcase SEEK_SET:\n\t\tif (offset < 0)\n\t\t\treturn -EINVAL;\n\t\tspin_lock(&filp->f_lock);\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\tif (offset == 0)\n\t\t\treturn filp->f_pos;\n\t\tspin_lock(&filp->f_lock);\n\t\toffset += filp->f_pos;\n\t\tif (offset < 0) {\n\t\t\tspin_unlock(&filp->f_lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (offset != filp->f_pos) {\n\t\tfilp->f_pos = offset;\n\t\tdir_ctx->page_index = 0;\n\t\tif (!nfs_readdir_use_cookie(filp)) {\n\t\t\tdir_ctx->dir_cookie = 0;\n\t\t\tdir_ctx->last_cookie = 0;\n\t\t} else {\n\t\t\tdir_ctx->dir_cookie = offset;\n\t\t\tdir_ctx->last_cookie = offset;\n\t\t}\n\t\tdir_ctx->eof = false;\n\t}\n\tspin_unlock(&filp->f_lock);\n\treturn offset;\n}\n\n \nstatic int nfs_fsync_dir(struct file *filp, loff_t start, loff_t end,\n\t\t\t int datasync)\n{\n\tdfprintk(FILE, \"NFS: fsync dir(%pD2) datasync %d\\n\", filp, datasync);\n\n\tnfs_inc_stats(file_inode(filp), NFSIOS_VFSFSYNC);\n\treturn 0;\n}\n\n \nvoid nfs_force_lookup_revalidate(struct inode *dir)\n{\n\tNFS_I(dir)->cache_change_attribute += 2;\n}\nEXPORT_SYMBOL_GPL(nfs_force_lookup_revalidate);\n\n \nstatic bool nfs_verify_change_attribute(struct inode *dir, unsigned long verf)\n{\n\treturn (verf & ~1UL) == nfs_save_change_attribute(dir);\n}\n\nstatic void nfs_set_verifier_delegated(unsigned long *verf)\n{\n\t*verf |= 1UL;\n}\n\n#if IS_ENABLED(CONFIG_NFS_V4)\nstatic void nfs_unset_verifier_delegated(unsigned long *verf)\n{\n\t*verf &= ~1UL;\n}\n#endif  \n\nstatic bool nfs_test_verifier_delegated(unsigned long verf)\n{\n\treturn verf & 1;\n}\n\nstatic bool nfs_verifier_is_delegated(struct dentry *dentry)\n{\n\treturn nfs_test_verifier_delegated(dentry->d_time);\n}\n\nstatic void nfs_set_verifier_locked(struct dentry *dentry, unsigned long verf)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct inode *dir = d_inode(dentry->d_parent);\n\n\tif (!nfs_verify_change_attribute(dir, verf))\n\t\treturn;\n\tif (inode && NFS_PROTO(inode)->have_delegation(inode, FMODE_READ))\n\t\tnfs_set_verifier_delegated(&verf);\n\tdentry->d_time = verf;\n}\n\n \nvoid nfs_set_verifier(struct dentry *dentry, unsigned long verf)\n{\n\n\tspin_lock(&dentry->d_lock);\n\tnfs_set_verifier_locked(dentry, verf);\n\tspin_unlock(&dentry->d_lock);\n}\nEXPORT_SYMBOL_GPL(nfs_set_verifier);\n\n#if IS_ENABLED(CONFIG_NFS_V4)\n \nvoid nfs_clear_verifier_delegated(struct inode *inode)\n{\n\tstruct dentry *alias;\n\n\tif (!inode)\n\t\treturn;\n\tspin_lock(&inode->i_lock);\n\thlist_for_each_entry(alias, &inode->i_dentry, d_u.d_alias) {\n\t\tspin_lock(&alias->d_lock);\n\t\tnfs_unset_verifier_delegated(&alias->d_time);\n\t\tspin_unlock(&alias->d_lock);\n\t}\n\tspin_unlock(&inode->i_lock);\n}\nEXPORT_SYMBOL_GPL(nfs_clear_verifier_delegated);\n#endif  \n\nstatic int nfs_dentry_verify_change(struct inode *dir, struct dentry *dentry)\n{\n\tif (nfs_server_capable(dir, NFS_CAP_CASE_INSENSITIVE) &&\n\t    d_really_is_negative(dentry))\n\t\treturn dentry->d_time == inode_peek_iversion_raw(dir);\n\treturn nfs_verify_change_attribute(dir, dentry->d_time);\n}\n\n \nstatic int nfs_check_verifier(struct inode *dir, struct dentry *dentry,\n\t\t\t      int rcu_walk)\n{\n\tif (IS_ROOT(dentry))\n\t\treturn 1;\n\tif (NFS_SERVER(dir)->flags & NFS_MOUNT_LOOKUP_CACHE_NONE)\n\t\treturn 0;\n\tif (!nfs_dentry_verify_change(dir, dentry))\n\t\treturn 0;\n\t \n\tif (nfs_mapping_need_revalidate_inode(dir)) {\n\t\tif (rcu_walk)\n\t\t\treturn 0;\n\t\tif (__nfs_revalidate_inode(NFS_SERVER(dir), dir) < 0)\n\t\t\treturn 0;\n\t}\n\tif (!nfs_dentry_verify_change(dir, dentry))\n\t\treturn 0;\n\treturn 1;\n}\n\n \nstatic int nfs_is_exclusive_create(struct inode *dir, unsigned int flags)\n{\n\tif (NFS_PROTO(dir)->version == 2)\n\t\treturn 0;\n\treturn flags & LOOKUP_EXCL;\n}\n\n \nstatic\nint nfs_lookup_verify_inode(struct inode *inode, unsigned int flags)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tint ret;\n\n\tif (IS_AUTOMOUNT(inode))\n\t\treturn 0;\n\n\tif (flags & LOOKUP_OPEN) {\n\t\tswitch (inode->i_mode & S_IFMT) {\n\t\tcase S_IFREG:\n\t\t\t \n\t\t\tif (server->caps & NFS_CAP_ATOMIC_OPEN)\n\t\t\t\tgoto out;\n\t\t\tfallthrough;\n\t\tcase S_IFDIR:\n\t\t\tif (server->flags & NFS_MOUNT_NOCTO)\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tgoto out_force;\n\t\t}\n\t}\n\n\t \n\tif (flags & LOOKUP_REVAL)\n\t\tgoto out_force;\nout:\n\tif (inode->i_nlink > 0 ||\n\t    (inode->i_nlink == 0 &&\n\t     test_bit(NFS_INO_PRESERVE_UNLINKED, &NFS_I(inode)->flags)))\n\t\treturn 0;\n\telse\n\t\treturn -ESTALE;\nout_force:\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\tret = __nfs_revalidate_inode(server, inode);\n\tif (ret != 0)\n\t\treturn ret;\n\tgoto out;\n}\n\nstatic void nfs_mark_dir_for_revalidate(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_CHANGE);\n\tspin_unlock(&inode->i_lock);\n}\n\n \nstatic inline\nint nfs_neg_need_reval(struct inode *dir, struct dentry *dentry,\n\t\t       unsigned int flags)\n{\n\tif (flags & (LOOKUP_CREATE | LOOKUP_RENAME_TARGET))\n\t\treturn 0;\n\tif (NFS_SERVER(dir)->flags & NFS_MOUNT_LOOKUP_CACHE_NONEG)\n\t\treturn 1;\n\t \n\tif (nfs_server_capable(dir, NFS_CAP_CASE_INSENSITIVE))\n\t\treturn 1;\n\treturn !nfs_check_verifier(dir, dentry, flags & LOOKUP_RCU);\n}\n\nstatic int\nnfs_lookup_revalidate_done(struct inode *dir, struct dentry *dentry,\n\t\t\t   struct inode *inode, int error)\n{\n\tswitch (error) {\n\tcase 1:\n\t\tbreak;\n\tcase 0:\n\t\t \n\t\tif (inode && IS_ROOT(dentry))\n\t\t\terror = 1;\n\t\tbreak;\n\t}\n\ttrace_nfs_lookup_revalidate_exit(dir, dentry, 0, error);\n\treturn error;\n}\n\nstatic int\nnfs_lookup_revalidate_negative(struct inode *dir, struct dentry *dentry,\n\t\t\t       unsigned int flags)\n{\n\tint ret = 1;\n\tif (nfs_neg_need_reval(dir, dentry, flags)) {\n\t\tif (flags & LOOKUP_RCU)\n\t\t\treturn -ECHILD;\n\t\tret = 0;\n\t}\n\treturn nfs_lookup_revalidate_done(dir, dentry, NULL, ret);\n}\n\nstatic int\nnfs_lookup_revalidate_delegated(struct inode *dir, struct dentry *dentry,\n\t\t\t\tstruct inode *inode)\n{\n\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\treturn nfs_lookup_revalidate_done(dir, dentry, inode, 1);\n}\n\nstatic int nfs_lookup_revalidate_dentry(struct inode *dir,\n\t\t\t\t\tstruct dentry *dentry,\n\t\t\t\t\tstruct inode *inode, unsigned int flags)\n{\n\tstruct nfs_fh *fhandle;\n\tstruct nfs_fattr *fattr;\n\tunsigned long dir_verifier;\n\tint ret;\n\n\ttrace_nfs_lookup_revalidate_enter(dir, dentry, flags);\n\n\tret = -ENOMEM;\n\tfhandle = nfs_alloc_fhandle();\n\tfattr = nfs_alloc_fattr_with_label(NFS_SERVER(inode));\n\tif (fhandle == NULL || fattr == NULL)\n\t\tgoto out;\n\n\tdir_verifier = nfs_save_change_attribute(dir);\n\tret = NFS_PROTO(dir)->lookup(dir, dentry, fhandle, fattr);\n\tif (ret < 0) {\n\t\tswitch (ret) {\n\t\tcase -ESTALE:\n\t\tcase -ENOENT:\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\tcase -ETIMEDOUT:\n\t\t\tif (NFS_SERVER(inode)->flags & NFS_MOUNT_SOFTREVAL)\n\t\t\t\tret = 1;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t \n\tnfs_lookup_advise_force_readdirplus(dir, flags);\n\n\tret = 0;\n\tif (nfs_compare_fh(NFS_FH(inode), fhandle))\n\t\tgoto out;\n\tif (nfs_refresh_inode(inode, fattr) < 0)\n\t\tgoto out;\n\n\tnfs_setsecurity(inode, fattr);\n\tnfs_set_verifier(dentry, dir_verifier);\n\n\tret = 1;\nout:\n\tnfs_free_fattr(fattr);\n\tnfs_free_fhandle(fhandle);\n\n\t \n\tif (!ret && nfs_dentry_verify_change(dir, dentry))\n\t\tnfs_mark_dir_for_revalidate(dir);\n\treturn nfs_lookup_revalidate_done(dir, dentry, inode, ret);\n}\n\n \nstatic int\nnfs_do_lookup_revalidate(struct inode *dir, struct dentry *dentry,\n\t\t\t unsigned int flags)\n{\n\tstruct inode *inode;\n\tint error;\n\n\tnfs_inc_stats(dir, NFSIOS_DENTRYREVALIDATE);\n\tinode = d_inode(dentry);\n\n\tif (!inode)\n\t\treturn nfs_lookup_revalidate_negative(dir, dentry, flags);\n\n\tif (is_bad_inode(inode)) {\n\t\tdfprintk(LOOKUPCACHE, \"%s: %pd2 has dud inode\\n\",\n\t\t\t\t__func__, dentry);\n\t\tgoto out_bad;\n\t}\n\n\tif ((flags & LOOKUP_RENAME_TARGET) && d_count(dentry) < 2 &&\n\t    nfs_server_capable(dir, NFS_CAP_CASE_INSENSITIVE))\n\t\tgoto out_bad;\n\n\tif (nfs_verifier_is_delegated(dentry))\n\t\treturn nfs_lookup_revalidate_delegated(dir, dentry, inode);\n\n\t \n\tif (!(flags & (LOOKUP_EXCL | LOOKUP_REVAL)) &&\n\t    nfs_check_verifier(dir, dentry, flags & LOOKUP_RCU)) {\n\t\terror = nfs_lookup_verify_inode(inode, flags);\n\t\tif (error) {\n\t\t\tif (error == -ESTALE)\n\t\t\t\tnfs_mark_dir_for_revalidate(dir);\n\t\t\tgoto out_bad;\n\t\t}\n\t\tgoto out_valid;\n\t}\n\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\tif (NFS_STALE(inode))\n\t\tgoto out_bad;\n\n\treturn nfs_lookup_revalidate_dentry(dir, dentry, inode, flags);\nout_valid:\n\treturn nfs_lookup_revalidate_done(dir, dentry, inode, 1);\nout_bad:\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\treturn nfs_lookup_revalidate_done(dir, dentry, inode, 0);\n}\n\nstatic int\n__nfs_lookup_revalidate(struct dentry *dentry, unsigned int flags,\n\t\t\tint (*reval)(struct inode *, struct dentry *, unsigned int))\n{\n\tstruct dentry *parent;\n\tstruct inode *dir;\n\tint ret;\n\n\tif (flags & LOOKUP_RCU) {\n\t\tif (dentry->d_fsdata == NFS_FSDATA_BLOCKED)\n\t\t\treturn -ECHILD;\n\t\tparent = READ_ONCE(dentry->d_parent);\n\t\tdir = d_inode_rcu(parent);\n\t\tif (!dir)\n\t\t\treturn -ECHILD;\n\t\tret = reval(dir, dentry, flags);\n\t\tif (parent != READ_ONCE(dentry->d_parent))\n\t\t\treturn -ECHILD;\n\t} else {\n\t\t \n\t\twait_var_event(&dentry->d_fsdata,\n\t\t\t       dentry->d_fsdata != NFS_FSDATA_BLOCKED);\n\t\tparent = dget_parent(dentry);\n\t\tret = reval(d_inode(parent), dentry, flags);\n\t\tdput(parent);\n\t}\n\treturn ret;\n}\n\nstatic int nfs_lookup_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\treturn __nfs_lookup_revalidate(dentry, flags, nfs_do_lookup_revalidate);\n}\n\n \nstatic int nfs_weak_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tint error = 0;\n\n\t \n\tif (!inode) {\n\t\tdfprintk(LOOKUPCACHE, \"%s: %pd2 has negative inode\\n\",\n\t\t\t\t__func__, dentry);\n\t\treturn 1;\n\t}\n\n\tif (is_bad_inode(inode)) {\n\t\tdfprintk(LOOKUPCACHE, \"%s: %pd2 has dud inode\\n\",\n\t\t\t\t__func__, dentry);\n\t\treturn 0;\n\t}\n\n\terror = nfs_lookup_verify_inode(inode, flags);\n\tdfprintk(LOOKUPCACHE, \"NFS: %s: inode %lu is %s\\n\",\n\t\t\t__func__, inode->i_ino, error ? \"invalid\" : \"valid\");\n\treturn !error;\n}\n\n \nstatic int nfs_dentry_delete(const struct dentry *dentry)\n{\n\tdfprintk(VFS, \"NFS: dentry_delete(%pd2, %x)\\n\",\n\t\tdentry, dentry->d_flags);\n\n\t \n\tif (d_really_is_positive(dentry) && NFS_STALE(d_inode(dentry)))\n\t\treturn 1;\n\n\tif (dentry->d_flags & DCACHE_NFSFS_RENAMED) {\n\t\t \n\t\treturn 1;\n\t}\n\tif (!(dentry->d_sb->s_flags & SB_ACTIVE)) {\n\t\t \n\t\treturn 1;\n\t}\n\treturn 0;\n\n}\n\n \nstatic void nfs_drop_nlink(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\t \n\tif (inode->i_nlink > 0)\n\t\tdrop_nlink(inode);\n\tNFS_I(inode)->attr_gencount = nfs_inc_attr_generation_counter();\n\tnfs_set_cache_invalid(\n\t\tinode, NFS_INO_INVALID_CHANGE | NFS_INO_INVALID_CTIME |\n\t\t\t       NFS_INO_INVALID_NLINK);\n\tspin_unlock(&inode->i_lock);\n}\n\n \nstatic void nfs_dentry_iput(struct dentry *dentry, struct inode *inode)\n{\n\tif (dentry->d_flags & DCACHE_NFSFS_RENAMED) {\n\t\tnfs_complete_unlink(dentry, inode);\n\t\tnfs_drop_nlink(inode);\n\t}\n\tiput(inode);\n}\n\nstatic void nfs_d_release(struct dentry *dentry)\n{\n\t \n\tif (unlikely(dentry->d_fsdata)) {\n\t\tif (dentry->d_flags & DCACHE_NFSFS_RENAMED)\n\t\t\tWARN_ON(1);\n\t\telse\n\t\t\tkfree(dentry->d_fsdata);\n\t}\n}\n\nconst struct dentry_operations nfs_dentry_operations = {\n\t.d_revalidate\t= nfs_lookup_revalidate,\n\t.d_weak_revalidate\t= nfs_weak_revalidate,\n\t.d_delete\t= nfs_dentry_delete,\n\t.d_iput\t\t= nfs_dentry_iput,\n\t.d_automount\t= nfs_d_automount,\n\t.d_release\t= nfs_d_release,\n};\nEXPORT_SYMBOL_GPL(nfs_dentry_operations);\n\nstruct dentry *nfs_lookup(struct inode *dir, struct dentry * dentry, unsigned int flags)\n{\n\tstruct dentry *res;\n\tstruct inode *inode = NULL;\n\tstruct nfs_fh *fhandle = NULL;\n\tstruct nfs_fattr *fattr = NULL;\n\tunsigned long dir_verifier;\n\tint error;\n\n\tdfprintk(VFS, \"NFS: lookup(%pd2)\\n\", dentry);\n\tnfs_inc_stats(dir, NFSIOS_VFSLOOKUP);\n\n\tif (unlikely(dentry->d_name.len > NFS_SERVER(dir)->namelen))\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\t \n\tif (nfs_is_exclusive_create(dir, flags) || flags & LOOKUP_RENAME_TARGET)\n\t\treturn NULL;\n\n\tres = ERR_PTR(-ENOMEM);\n\tfhandle = nfs_alloc_fhandle();\n\tfattr = nfs_alloc_fattr_with_label(NFS_SERVER(dir));\n\tif (fhandle == NULL || fattr == NULL)\n\t\tgoto out;\n\n\tdir_verifier = nfs_save_change_attribute(dir);\n\ttrace_nfs_lookup_enter(dir, dentry, flags);\n\terror = NFS_PROTO(dir)->lookup(dir, dentry, fhandle, fattr);\n\tif (error == -ENOENT) {\n\t\tif (nfs_server_capable(dir, NFS_CAP_CASE_INSENSITIVE))\n\t\t\tdir_verifier = inode_peek_iversion_raw(dir);\n\t\tgoto no_entry;\n\t}\n\tif (error < 0) {\n\t\tres = ERR_PTR(error);\n\t\tgoto out;\n\t}\n\tinode = nfs_fhget(dentry->d_sb, fhandle, fattr);\n\tres = ERR_CAST(inode);\n\tif (IS_ERR(res))\n\t\tgoto out;\n\n\t \n\tnfs_lookup_advise_force_readdirplus(dir, flags);\n\nno_entry:\n\tres = d_splice_alias(inode, dentry);\n\tif (res != NULL) {\n\t\tif (IS_ERR(res))\n\t\t\tgoto out;\n\t\tdentry = res;\n\t}\n\tnfs_set_verifier(dentry, dir_verifier);\nout:\n\ttrace_nfs_lookup_exit(dir, dentry, flags, PTR_ERR_OR_ZERO(res));\n\tnfs_free_fattr(fattr);\n\tnfs_free_fhandle(fhandle);\n\treturn res;\n}\nEXPORT_SYMBOL_GPL(nfs_lookup);\n\nvoid nfs_d_prune_case_insensitive_aliases(struct inode *inode)\n{\n\t \n\tif (inode && nfs_server_capable(inode, NFS_CAP_CASE_INSENSITIVE))\n\t\td_prune_aliases(inode);\n}\nEXPORT_SYMBOL_GPL(nfs_d_prune_case_insensitive_aliases);\n\n#if IS_ENABLED(CONFIG_NFS_V4)\nstatic int nfs4_lookup_revalidate(struct dentry *, unsigned int);\n\nconst struct dentry_operations nfs4_dentry_operations = {\n\t.d_revalidate\t= nfs4_lookup_revalidate,\n\t.d_weak_revalidate\t= nfs_weak_revalidate,\n\t.d_delete\t= nfs_dentry_delete,\n\t.d_iput\t\t= nfs_dentry_iput,\n\t.d_automount\t= nfs_d_automount,\n\t.d_release\t= nfs_d_release,\n};\nEXPORT_SYMBOL_GPL(nfs4_dentry_operations);\n\nstatic struct nfs_open_context *create_nfs_open_context(struct dentry *dentry, int open_flags, struct file *filp)\n{\n\treturn alloc_nfs_open_context(dentry, flags_to_mode(open_flags), filp);\n}\n\nstatic int do_open(struct inode *inode, struct file *filp)\n{\n\tnfs_fscache_open_file(inode, filp);\n\treturn 0;\n}\n\nstatic int nfs_finish_open(struct nfs_open_context *ctx,\n\t\t\t   struct dentry *dentry,\n\t\t\t   struct file *file, unsigned open_flags)\n{\n\tint err;\n\n\terr = finish_open(file, dentry, do_open);\n\tif (err)\n\t\tgoto out;\n\tif (S_ISREG(file_inode(file)->i_mode))\n\t\tnfs_file_set_open_context(file, ctx);\n\telse\n\t\terr = -EOPENSTALE;\nout:\n\treturn err;\n}\n\nint nfs_atomic_open(struct inode *dir, struct dentry *dentry,\n\t\t    struct file *file, unsigned open_flags,\n\t\t    umode_t mode)\n{\n\tDECLARE_WAIT_QUEUE_HEAD_ONSTACK(wq);\n\tstruct nfs_open_context *ctx;\n\tstruct dentry *res;\n\tstruct iattr attr = { .ia_valid = ATTR_OPEN };\n\tstruct inode *inode;\n\tunsigned int lookup_flags = 0;\n\tunsigned long dir_verifier;\n\tbool switched = false;\n\tint created = 0;\n\tint err;\n\n\t \n\tBUG_ON(d_inode(dentry));\n\n\tdfprintk(VFS, \"NFS: atomic_open(%s/%lu), %pd\\n\",\n\t\t\tdir->i_sb->s_id, dir->i_ino, dentry);\n\n\terr = nfs_check_flags(open_flags);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif ((open_flags & O_DIRECTORY)) {\n\t\tif (!d_in_lookup(dentry)) {\n\t\t\t \n\t\t\treturn -ENOENT;\n\t\t}\n\t\tlookup_flags = LOOKUP_OPEN|LOOKUP_DIRECTORY;\n\t\tgoto no_open;\n\t}\n\n\tif (dentry->d_name.len > NFS_SERVER(dir)->namelen)\n\t\treturn -ENAMETOOLONG;\n\n\tif (open_flags & O_CREAT) {\n\t\tstruct nfs_server *server = NFS_SERVER(dir);\n\n\t\tif (!(server->attr_bitmask[2] & FATTR4_WORD2_MODE_UMASK))\n\t\t\tmode &= ~current_umask();\n\n\t\tattr.ia_valid |= ATTR_MODE;\n\t\tattr.ia_mode = mode;\n\t}\n\tif (open_flags & O_TRUNC) {\n\t\tattr.ia_valid |= ATTR_SIZE;\n\t\tattr.ia_size = 0;\n\t}\n\n\tif (!(open_flags & O_CREAT) && !d_in_lookup(dentry)) {\n\t\td_drop(dentry);\n\t\tswitched = true;\n\t\tdentry = d_alloc_parallel(dentry->d_parent,\n\t\t\t\t\t  &dentry->d_name, &wq);\n\t\tif (IS_ERR(dentry))\n\t\t\treturn PTR_ERR(dentry);\n\t\tif (unlikely(!d_in_lookup(dentry)))\n\t\t\treturn finish_no_open(file, dentry);\n\t}\n\n\tctx = create_nfs_open_context(dentry, open_flags, file);\n\terr = PTR_ERR(ctx);\n\tif (IS_ERR(ctx))\n\t\tgoto out;\n\n\ttrace_nfs_atomic_open_enter(dir, ctx, open_flags);\n\tinode = NFS_PROTO(dir)->open_context(dir, ctx, open_flags, &attr, &created);\n\tif (created)\n\t\tfile->f_mode |= FMODE_CREATED;\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\ttrace_nfs_atomic_open_exit(dir, ctx, open_flags, err);\n\t\tput_nfs_open_context(ctx);\n\t\td_drop(dentry);\n\t\tswitch (err) {\n\t\tcase -ENOENT:\n\t\t\td_splice_alias(NULL, dentry);\n\t\t\tif (nfs_server_capable(dir, NFS_CAP_CASE_INSENSITIVE))\n\t\t\t\tdir_verifier = inode_peek_iversion_raw(dir);\n\t\t\telse\n\t\t\t\tdir_verifier = nfs_save_change_attribute(dir);\n\t\t\tnfs_set_verifier(dentry, dir_verifier);\n\t\t\tbreak;\n\t\tcase -EISDIR:\n\t\tcase -ENOTDIR:\n\t\t\tgoto no_open;\n\t\tcase -ELOOP:\n\t\t\tif (!(open_flags & O_NOFOLLOW))\n\t\t\t\tgoto no_open;\n\t\t\tbreak;\n\t\t\t \n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tgoto out;\n\t}\n\tfile->f_mode |= FMODE_CAN_ODIRECT;\n\n\terr = nfs_finish_open(ctx, ctx->dentry, file, open_flags);\n\ttrace_nfs_atomic_open_exit(dir, ctx, open_flags, err);\n\tput_nfs_open_context(ctx);\nout:\n\tif (unlikely(switched)) {\n\t\td_lookup_done(dentry);\n\t\tdput(dentry);\n\t}\n\treturn err;\n\nno_open:\n\tres = nfs_lookup(dir, dentry, lookup_flags);\n\tif (!res) {\n\t\tinode = d_inode(dentry);\n\t\tif ((lookup_flags & LOOKUP_DIRECTORY) && inode &&\n\t\t    !(S_ISDIR(inode->i_mode) || S_ISLNK(inode->i_mode)))\n\t\t\tres = ERR_PTR(-ENOTDIR);\n\t\telse if (inode && S_ISREG(inode->i_mode))\n\t\t\tres = ERR_PTR(-EOPENSTALE);\n\t} else if (!IS_ERR(res)) {\n\t\tinode = d_inode(res);\n\t\tif ((lookup_flags & LOOKUP_DIRECTORY) && inode &&\n\t\t    !(S_ISDIR(inode->i_mode) || S_ISLNK(inode->i_mode))) {\n\t\t\tdput(res);\n\t\t\tres = ERR_PTR(-ENOTDIR);\n\t\t} else if (inode && S_ISREG(inode->i_mode)) {\n\t\t\tdput(res);\n\t\t\tres = ERR_PTR(-EOPENSTALE);\n\t\t}\n\t}\n\tif (switched) {\n\t\td_lookup_done(dentry);\n\t\tif (!res)\n\t\t\tres = dentry;\n\t\telse\n\t\t\tdput(dentry);\n\t}\n\tif (IS_ERR(res))\n\t\treturn PTR_ERR(res);\n\treturn finish_no_open(file, res);\n}\nEXPORT_SYMBOL_GPL(nfs_atomic_open);\n\nstatic int\nnfs4_do_lookup_revalidate(struct inode *dir, struct dentry *dentry,\n\t\t\t  unsigned int flags)\n{\n\tstruct inode *inode;\n\n\tif (!(flags & LOOKUP_OPEN) || (flags & LOOKUP_DIRECTORY))\n\t\tgoto full_reval;\n\tif (d_mountpoint(dentry))\n\t\tgoto full_reval;\n\n\tinode = d_inode(dentry);\n\n\t \n\tif (inode == NULL)\n\t\tgoto full_reval;\n\n\tif (nfs_verifier_is_delegated(dentry))\n\t\treturn nfs_lookup_revalidate_delegated(dir, dentry, inode);\n\n\t \n\tif (!S_ISREG(inode->i_mode))\n\t\tgoto full_reval;\n\n\t \n\tif (flags & (LOOKUP_EXCL | LOOKUP_REVAL))\n\t\tgoto reval_dentry;\n\n\t \n\tif (!nfs_check_verifier(dir, dentry, flags & LOOKUP_RCU))\n\t\tgoto reval_dentry;\n\n\t \n\treturn 1;\nreval_dentry:\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\treturn nfs_lookup_revalidate_dentry(dir, dentry, inode, flags);\n\nfull_reval:\n\treturn nfs_do_lookup_revalidate(dir, dentry, flags);\n}\n\nstatic int nfs4_lookup_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\treturn __nfs_lookup_revalidate(dentry, flags,\n\t\t\tnfs4_do_lookup_revalidate);\n}\n\n#endif  \n\nstruct dentry *\nnfs_add_or_obtain(struct dentry *dentry, struct nfs_fh *fhandle,\n\t\t\t\tstruct nfs_fattr *fattr)\n{\n\tstruct dentry *parent = dget_parent(dentry);\n\tstruct inode *dir = d_inode(parent);\n\tstruct inode *inode;\n\tstruct dentry *d;\n\tint error;\n\n\td_drop(dentry);\n\n\tif (fhandle->size == 0) {\n\t\terror = NFS_PROTO(dir)->lookup(dir, dentry, fhandle, fattr);\n\t\tif (error)\n\t\t\tgoto out_error;\n\t}\n\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\tif (!(fattr->valid & NFS_ATTR_FATTR)) {\n\t\tstruct nfs_server *server = NFS_SB(dentry->d_sb);\n\t\terror = server->nfs_client->rpc_ops->getattr(server, fhandle,\n\t\t\t\tfattr, NULL);\n\t\tif (error < 0)\n\t\t\tgoto out_error;\n\t}\n\tinode = nfs_fhget(dentry->d_sb, fhandle, fattr);\n\td = d_splice_alias(inode, dentry);\nout:\n\tdput(parent);\n\treturn d;\nout_error:\n\td = ERR_PTR(error);\n\tgoto out;\n}\nEXPORT_SYMBOL_GPL(nfs_add_or_obtain);\n\n \nint nfs_instantiate(struct dentry *dentry, struct nfs_fh *fhandle,\n\t\t\t\tstruct nfs_fattr *fattr)\n{\n\tstruct dentry *d;\n\n\td = nfs_add_or_obtain(dentry, fhandle, fattr);\n\tif (IS_ERR(d))\n\t\treturn PTR_ERR(d);\n\n\t \n\tdput(d);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nfs_instantiate);\n\n \nint nfs_create(struct mnt_idmap *idmap, struct inode *dir,\n\t       struct dentry *dentry, umode_t mode, bool excl)\n{\n\tstruct iattr attr;\n\tint open_flags = excl ? O_CREAT | O_EXCL : O_CREAT;\n\tint error;\n\n\tdfprintk(VFS, \"NFS: create(%s/%lu), %pd\\n\",\n\t\t\tdir->i_sb->s_id, dir->i_ino, dentry);\n\n\tattr.ia_mode = mode;\n\tattr.ia_valid = ATTR_MODE;\n\n\ttrace_nfs_create_enter(dir, dentry, open_flags);\n\terror = NFS_PROTO(dir)->create(dir, dentry, &attr, open_flags);\n\ttrace_nfs_create_exit(dir, dentry, open_flags, error);\n\tif (error != 0)\n\t\tgoto out_err;\n\treturn 0;\nout_err:\n\td_drop(dentry);\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(nfs_create);\n\n \nint\nnfs_mknod(struct mnt_idmap *idmap, struct inode *dir,\n\t  struct dentry *dentry, umode_t mode, dev_t rdev)\n{\n\tstruct iattr attr;\n\tint status;\n\n\tdfprintk(VFS, \"NFS: mknod(%s/%lu), %pd\\n\",\n\t\t\tdir->i_sb->s_id, dir->i_ino, dentry);\n\n\tattr.ia_mode = mode;\n\tattr.ia_valid = ATTR_MODE;\n\n\ttrace_nfs_mknod_enter(dir, dentry);\n\tstatus = NFS_PROTO(dir)->mknod(dir, dentry, &attr, rdev);\n\ttrace_nfs_mknod_exit(dir, dentry, status);\n\tif (status != 0)\n\t\tgoto out_err;\n\treturn 0;\nout_err:\n\td_drop(dentry);\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(nfs_mknod);\n\n \nint nfs_mkdir(struct mnt_idmap *idmap, struct inode *dir,\n\t      struct dentry *dentry, umode_t mode)\n{\n\tstruct iattr attr;\n\tint error;\n\n\tdfprintk(VFS, \"NFS: mkdir(%s/%lu), %pd\\n\",\n\t\t\tdir->i_sb->s_id, dir->i_ino, dentry);\n\n\tattr.ia_valid = ATTR_MODE;\n\tattr.ia_mode = mode | S_IFDIR;\n\n\ttrace_nfs_mkdir_enter(dir, dentry);\n\terror = NFS_PROTO(dir)->mkdir(dir, dentry, &attr);\n\ttrace_nfs_mkdir_exit(dir, dentry, error);\n\tif (error != 0)\n\t\tgoto out_err;\n\treturn 0;\nout_err:\n\td_drop(dentry);\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(nfs_mkdir);\n\nstatic void nfs_dentry_handle_enoent(struct dentry *dentry)\n{\n\tif (simple_positive(dentry))\n\t\td_delete(dentry);\n}\n\nstatic void nfs_dentry_remove_handle_error(struct inode *dir,\n\t\t\t\t\t   struct dentry *dentry, int error)\n{\n\tswitch (error) {\n\tcase -ENOENT:\n\t\tif (d_really_is_positive(dentry))\n\t\t\td_delete(dentry);\n\t\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\t\tbreak;\n\tcase 0:\n\t\tnfs_d_prune_case_insensitive_aliases(d_inode(dentry));\n\t\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\t}\n}\n\nint nfs_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tint error;\n\n\tdfprintk(VFS, \"NFS: rmdir(%s/%lu), %pd\\n\",\n\t\t\tdir->i_sb->s_id, dir->i_ino, dentry);\n\n\ttrace_nfs_rmdir_enter(dir, dentry);\n\tif (d_really_is_positive(dentry)) {\n\t\tdown_write(&NFS_I(d_inode(dentry))->rmdir_sem);\n\t\terror = NFS_PROTO(dir)->rmdir(dir, &dentry->d_name);\n\t\t \n\t\tswitch (error) {\n\t\tcase 0:\n\t\t\tclear_nlink(d_inode(dentry));\n\t\t\tbreak;\n\t\tcase -ENOENT:\n\t\t\tnfs_dentry_handle_enoent(dentry);\n\t\t}\n\t\tup_write(&NFS_I(d_inode(dentry))->rmdir_sem);\n\t} else\n\t\terror = NFS_PROTO(dir)->rmdir(dir, &dentry->d_name);\n\tnfs_dentry_remove_handle_error(dir, dentry, error);\n\ttrace_nfs_rmdir_exit(dir, dentry, error);\n\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(nfs_rmdir);\n\n \nstatic int nfs_safe_remove(struct dentry *dentry)\n{\n\tstruct inode *dir = d_inode(dentry->d_parent);\n\tstruct inode *inode = d_inode(dentry);\n\tint error = -EBUSY;\n\t\t\n\tdfprintk(VFS, \"NFS: safe_remove(%pd2)\\n\", dentry);\n\n\t \n\tif (dentry->d_flags & DCACHE_NFSFS_RENAMED) {\n\t\terror = 0;\n\t\tgoto out;\n\t}\n\n\ttrace_nfs_remove_enter(dir, dentry);\n\tif (inode != NULL) {\n\t\terror = NFS_PROTO(dir)->remove(dir, dentry);\n\t\tif (error == 0)\n\t\t\tnfs_drop_nlink(inode);\n\t} else\n\t\terror = NFS_PROTO(dir)->remove(dir, dentry);\n\tif (error == -ENOENT)\n\t\tnfs_dentry_handle_enoent(dentry);\n\ttrace_nfs_remove_exit(dir, dentry, error);\nout:\n\treturn error;\n}\n\n \nint nfs_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tint error;\n\n\tdfprintk(VFS, \"NFS: unlink(%s/%lu, %pd)\\n\", dir->i_sb->s_id,\n\t\tdir->i_ino, dentry);\n\n\ttrace_nfs_unlink_enter(dir, dentry);\n\tspin_lock(&dentry->d_lock);\n\tif (d_count(dentry) > 1 && !test_bit(NFS_INO_PRESERVE_UNLINKED,\n\t\t\t\t\t     &NFS_I(d_inode(dentry))->flags)) {\n\t\tspin_unlock(&dentry->d_lock);\n\t\t \n\t\twrite_inode_now(d_inode(dentry), 0);\n\t\terror = nfs_sillyrename(dir, dentry);\n\t\tgoto out;\n\t}\n\t \n\terror = -ETXTBSY;\n\tif (WARN_ON(dentry->d_flags & DCACHE_NFSFS_RENAMED) ||\n\t    WARN_ON(dentry->d_fsdata == NFS_FSDATA_BLOCKED)) {\n\t\tspin_unlock(&dentry->d_lock);\n\t\tgoto out;\n\t}\n\t \n\tkfree(dentry->d_fsdata);\n\tdentry->d_fsdata = NFS_FSDATA_BLOCKED;\n\n\tspin_unlock(&dentry->d_lock);\n\terror = nfs_safe_remove(dentry);\n\tnfs_dentry_remove_handle_error(dir, dentry, error);\n\tdentry->d_fsdata = NULL;\n\twake_up_var(&dentry->d_fsdata);\nout:\n\ttrace_nfs_unlink_exit(dir, dentry, error);\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(nfs_unlink);\n\n \nint nfs_symlink(struct mnt_idmap *idmap, struct inode *dir,\n\t\tstruct dentry *dentry, const char *symname)\n{\n\tstruct page *page;\n\tchar *kaddr;\n\tstruct iattr attr;\n\tunsigned int pathlen = strlen(symname);\n\tint error;\n\n\tdfprintk(VFS, \"NFS: symlink(%s/%lu, %pd, %s)\\n\", dir->i_sb->s_id,\n\t\tdir->i_ino, dentry, symname);\n\n\tif (pathlen > PAGE_SIZE)\n\t\treturn -ENAMETOOLONG;\n\n\tattr.ia_mode = S_IFLNK | S_IRWXUGO;\n\tattr.ia_valid = ATTR_MODE;\n\n\tpage = alloc_page(GFP_USER);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tkaddr = page_address(page);\n\tmemcpy(kaddr, symname, pathlen);\n\tif (pathlen < PAGE_SIZE)\n\t\tmemset(kaddr + pathlen, 0, PAGE_SIZE - pathlen);\n\n\ttrace_nfs_symlink_enter(dir, dentry);\n\terror = NFS_PROTO(dir)->symlink(dir, dentry, page, pathlen, &attr);\n\ttrace_nfs_symlink_exit(dir, dentry, error);\n\tif (error != 0) {\n\t\tdfprintk(VFS, \"NFS: symlink(%s/%lu, %pd, %s) error %d\\n\",\n\t\t\tdir->i_sb->s_id, dir->i_ino,\n\t\t\tdentry, symname, error);\n\t\td_drop(dentry);\n\t\t__free_page(page);\n\t\treturn error;\n\t}\n\n\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\n\t \n\tif (!add_to_page_cache_lru(page, d_inode(dentry)->i_mapping, 0,\n\t\t\t\t\t\t\tGFP_KERNEL)) {\n\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\t \n\t\tput_page(page);\n\t} else\n\t\t__free_page(page);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nfs_symlink);\n\nint\nnfs_link(struct dentry *old_dentry, struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(old_dentry);\n\tint error;\n\n\tdfprintk(VFS, \"NFS: link(%pd2 -> %pd2)\\n\",\n\t\told_dentry, dentry);\n\n\ttrace_nfs_link_enter(inode, dir, dentry);\n\td_drop(dentry);\n\tif (S_ISREG(inode->i_mode))\n\t\tnfs_sync_inode(inode);\n\terror = NFS_PROTO(dir)->link(inode, dir, &dentry->d_name);\n\tif (error == 0) {\n\t\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\t\tihold(inode);\n\t\td_add(dentry, inode);\n\t}\n\ttrace_nfs_link_exit(inode, dir, dentry, error);\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(nfs_link);\n\nstatic void\nnfs_unblock_rename(struct rpc_task *task, struct nfs_renamedata *data)\n{\n\tstruct dentry *new_dentry = data->new_dentry;\n\n\tnew_dentry->d_fsdata = NULL;\n\twake_up_var(&new_dentry->d_fsdata);\n}\n\n \nint nfs_rename(struct mnt_idmap *idmap, struct inode *old_dir,\n\t       struct dentry *old_dentry, struct inode *new_dir,\n\t       struct dentry *new_dentry, unsigned int flags)\n{\n\tstruct inode *old_inode = d_inode(old_dentry);\n\tstruct inode *new_inode = d_inode(new_dentry);\n\tstruct dentry *dentry = NULL;\n\tstruct rpc_task *task;\n\tbool must_unblock = false;\n\tint error = -EBUSY;\n\n\tif (flags)\n\t\treturn -EINVAL;\n\n\tdfprintk(VFS, \"NFS: rename(%pd2 -> %pd2, ct=%d)\\n\",\n\t\t old_dentry, new_dentry,\n\t\t d_count(new_dentry));\n\n\ttrace_nfs_rename_enter(old_dir, old_dentry, new_dir, new_dentry);\n\t \n\tif (new_inode && !S_ISDIR(new_inode->i_mode)) {\n\t\t \n\t\terror = -ETXTBSY;\n\t\tif (WARN_ON(new_dentry->d_flags & DCACHE_NFSFS_RENAMED) ||\n\t\t    WARN_ON(new_dentry->d_fsdata == NFS_FSDATA_BLOCKED))\n\t\t\tgoto out;\n\t\tif (new_dentry->d_fsdata) {\n\t\t\t \n\t\t\tkfree(new_dentry->d_fsdata);\n\t\t\tnew_dentry->d_fsdata = NULL;\n\t\t}\n\n\t\tspin_lock(&new_dentry->d_lock);\n\t\tif (d_count(new_dentry) > 2) {\n\t\t\tint err;\n\n\t\t\tspin_unlock(&new_dentry->d_lock);\n\n\t\t\t \n\t\t\tdentry = d_alloc(new_dentry->d_parent,\n\t\t\t\t\t &new_dentry->d_name);\n\t\t\tif (!dentry)\n\t\t\t\tgoto out;\n\n\t\t\t \n\t\t\terr = nfs_sillyrename(new_dir, new_dentry);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\tnew_dentry = dentry;\n\t\t\tnew_inode = NULL;\n\t\t} else {\n\t\t\tnew_dentry->d_fsdata = NFS_FSDATA_BLOCKED;\n\t\t\tmust_unblock = true;\n\t\t\tspin_unlock(&new_dentry->d_lock);\n\t\t}\n\n\t}\n\n\tif (S_ISREG(old_inode->i_mode))\n\t\tnfs_sync_inode(old_inode);\n\ttask = nfs_async_rename(old_dir, new_dir, old_dentry, new_dentry,\n\t\t\t\tmust_unblock ? nfs_unblock_rename : NULL);\n\tif (IS_ERR(task)) {\n\t\terror = PTR_ERR(task);\n\t\tgoto out;\n\t}\n\n\terror = rpc_wait_for_completion_task(task);\n\tif (error != 0) {\n\t\t((struct nfs_renamedata *)task->tk_calldata)->cancelled = 1;\n\t\t \n\t\tsmp_wmb();\n\t} else\n\t\terror = task->tk_status;\n\trpc_put_task(task);\n\t \n\tif (error == 0) {\n\t\tspin_lock(&old_inode->i_lock);\n\t\tNFS_I(old_inode)->attr_gencount = nfs_inc_attr_generation_counter();\n\t\tnfs_set_cache_invalid(old_inode, NFS_INO_INVALID_CHANGE |\n\t\t\t\t\t\t\t NFS_INO_INVALID_CTIME |\n\t\t\t\t\t\t\t NFS_INO_REVAL_FORCED);\n\t\tspin_unlock(&old_inode->i_lock);\n\t}\nout:\n\ttrace_nfs_rename_exit(old_dir, old_dentry,\n\t\t\tnew_dir, new_dentry, error);\n\tif (!error) {\n\t\tif (new_inode != NULL)\n\t\t\tnfs_drop_nlink(new_inode);\n\t\t \n\t\td_move(old_dentry, new_dentry);\n\t\tnfs_set_verifier(old_dentry,\n\t\t\t\t\tnfs_save_change_attribute(new_dir));\n\t} else if (error == -ENOENT)\n\t\tnfs_dentry_handle_enoent(old_dentry);\n\n\t \n\tif (dentry)\n\t\tdput(dentry);\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(nfs_rename);\n\nstatic DEFINE_SPINLOCK(nfs_access_lru_lock);\nstatic LIST_HEAD(nfs_access_lru_list);\nstatic atomic_long_t nfs_access_nr_entries;\n\nstatic unsigned long nfs_access_max_cachesize = 4*1024*1024;\nmodule_param(nfs_access_max_cachesize, ulong, 0644);\nMODULE_PARM_DESC(nfs_access_max_cachesize, \"NFS access maximum total cache length\");\n\nstatic void nfs_access_free_entry(struct nfs_access_entry *entry)\n{\n\tput_group_info(entry->group_info);\n\tkfree_rcu(entry, rcu_head);\n\tsmp_mb__before_atomic();\n\tatomic_long_dec(&nfs_access_nr_entries);\n\tsmp_mb__after_atomic();\n}\n\nstatic void nfs_access_free_list(struct list_head *head)\n{\n\tstruct nfs_access_entry *cache;\n\n\twhile (!list_empty(head)) {\n\t\tcache = list_entry(head->next, struct nfs_access_entry, lru);\n\t\tlist_del(&cache->lru);\n\t\tnfs_access_free_entry(cache);\n\t}\n}\n\nstatic unsigned long\nnfs_do_access_cache_scan(unsigned int nr_to_scan)\n{\n\tLIST_HEAD(head);\n\tstruct nfs_inode *nfsi, *next;\n\tstruct nfs_access_entry *cache;\n\tlong freed = 0;\n\n\tspin_lock(&nfs_access_lru_lock);\n\tlist_for_each_entry_safe(nfsi, next, &nfs_access_lru_list, access_cache_inode_lru) {\n\t\tstruct inode *inode;\n\n\t\tif (nr_to_scan-- == 0)\n\t\t\tbreak;\n\t\tinode = &nfsi->vfs_inode;\n\t\tspin_lock(&inode->i_lock);\n\t\tif (list_empty(&nfsi->access_cache_entry_lru))\n\t\t\tgoto remove_lru_entry;\n\t\tcache = list_entry(nfsi->access_cache_entry_lru.next,\n\t\t\t\tstruct nfs_access_entry, lru);\n\t\tlist_move(&cache->lru, &head);\n\t\trb_erase(&cache->rb_node, &nfsi->access_cache);\n\t\tfreed++;\n\t\tif (!list_empty(&nfsi->access_cache_entry_lru))\n\t\t\tlist_move_tail(&nfsi->access_cache_inode_lru,\n\t\t\t\t\t&nfs_access_lru_list);\n\t\telse {\nremove_lru_entry:\n\t\t\tlist_del_init(&nfsi->access_cache_inode_lru);\n\t\t\tsmp_mb__before_atomic();\n\t\t\tclear_bit(NFS_INO_ACL_LRU_SET, &nfsi->flags);\n\t\t\tsmp_mb__after_atomic();\n\t\t}\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\tspin_unlock(&nfs_access_lru_lock);\n\tnfs_access_free_list(&head);\n\treturn freed;\n}\n\nunsigned long\nnfs_access_cache_scan(struct shrinker *shrink, struct shrink_control *sc)\n{\n\tint nr_to_scan = sc->nr_to_scan;\n\tgfp_t gfp_mask = sc->gfp_mask;\n\n\tif ((gfp_mask & GFP_KERNEL) != GFP_KERNEL)\n\t\treturn SHRINK_STOP;\n\treturn nfs_do_access_cache_scan(nr_to_scan);\n}\n\n\nunsigned long\nnfs_access_cache_count(struct shrinker *shrink, struct shrink_control *sc)\n{\n\treturn vfs_pressure_ratio(atomic_long_read(&nfs_access_nr_entries));\n}\n\nstatic void\nnfs_access_cache_enforce_limit(void)\n{\n\tlong nr_entries = atomic_long_read(&nfs_access_nr_entries);\n\tunsigned long diff;\n\tunsigned int nr_to_scan;\n\n\tif (nr_entries < 0 || nr_entries <= nfs_access_max_cachesize)\n\t\treturn;\n\tnr_to_scan = 100;\n\tdiff = nr_entries - nfs_access_max_cachesize;\n\tif (diff < nr_to_scan)\n\t\tnr_to_scan = diff;\n\tnfs_do_access_cache_scan(nr_to_scan);\n}\n\nstatic void __nfs_access_zap_cache(struct nfs_inode *nfsi, struct list_head *head)\n{\n\tstruct rb_root *root_node = &nfsi->access_cache;\n\tstruct rb_node *n;\n\tstruct nfs_access_entry *entry;\n\n\t \n\twhile ((n = rb_first(root_node)) != NULL) {\n\t\tentry = rb_entry(n, struct nfs_access_entry, rb_node);\n\t\trb_erase(n, root_node);\n\t\tlist_move(&entry->lru, head);\n\t}\n\tnfsi->cache_validity &= ~NFS_INO_INVALID_ACCESS;\n}\n\nvoid nfs_access_zap_cache(struct inode *inode)\n{\n\tLIST_HEAD(head);\n\n\tif (test_bit(NFS_INO_ACL_LRU_SET, &NFS_I(inode)->flags) == 0)\n\t\treturn;\n\t \n\tspin_lock(&nfs_access_lru_lock);\n\tif (test_and_clear_bit(NFS_INO_ACL_LRU_SET, &NFS_I(inode)->flags))\n\t\tlist_del_init(&NFS_I(inode)->access_cache_inode_lru);\n\n\tspin_lock(&inode->i_lock);\n\t__nfs_access_zap_cache(NFS_I(inode), &head);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&nfs_access_lru_lock);\n\tnfs_access_free_list(&head);\n}\nEXPORT_SYMBOL_GPL(nfs_access_zap_cache);\n\nstatic int access_cmp(const struct cred *a, const struct nfs_access_entry *b)\n{\n\tstruct group_info *ga, *gb;\n\tint g;\n\n\tif (uid_lt(a->fsuid, b->fsuid))\n\t\treturn -1;\n\tif (uid_gt(a->fsuid, b->fsuid))\n\t\treturn 1;\n\n\tif (gid_lt(a->fsgid, b->fsgid))\n\t\treturn -1;\n\tif (gid_gt(a->fsgid, b->fsgid))\n\t\treturn 1;\n\n\tga = a->group_info;\n\tgb = b->group_info;\n\tif (ga == gb)\n\t\treturn 0;\n\tif (ga == NULL)\n\t\treturn -1;\n\tif (gb == NULL)\n\t\treturn 1;\n\tif (ga->ngroups < gb->ngroups)\n\t\treturn -1;\n\tif (ga->ngroups > gb->ngroups)\n\t\treturn 1;\n\n\tfor (g = 0; g < ga->ngroups; g++) {\n\t\tif (gid_lt(ga->gid[g], gb->gid[g]))\n\t\t\treturn -1;\n\t\tif (gid_gt(ga->gid[g], gb->gid[g]))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic struct nfs_access_entry *nfs_access_search_rbtree(struct inode *inode, const struct cred *cred)\n{\n\tstruct rb_node *n = NFS_I(inode)->access_cache.rb_node;\n\n\twhile (n != NULL) {\n\t\tstruct nfs_access_entry *entry =\n\t\t\trb_entry(n, struct nfs_access_entry, rb_node);\n\t\tint cmp = access_cmp(cred, entry);\n\n\t\tif (cmp < 0)\n\t\t\tn = n->rb_left;\n\t\telse if (cmp > 0)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}\n\nstatic u64 nfs_access_login_time(const struct task_struct *task,\n\t\t\t\t const struct cred *cred)\n{\n\tconst struct task_struct *parent;\n\tconst struct cred *pcred;\n\tu64 ret;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tparent = rcu_dereference(task->real_parent);\n\t\tpcred = __task_cred(parent);\n\t\tif (parent == task || cred_fscmp(pcred, cred) != 0)\n\t\t\tbreak;\n\t\ttask = parent;\n\t}\n\tret = task->start_time;\n\trcu_read_unlock();\n\treturn ret;\n}\n\nstatic int nfs_access_get_cached_locked(struct inode *inode, const struct cred *cred, u32 *mask, bool may_block)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tu64 login_time = nfs_access_login_time(current, cred);\n\tstruct nfs_access_entry *cache;\n\tbool retry = true;\n\tint err;\n\n\tspin_lock(&inode->i_lock);\n\tfor(;;) {\n\t\tif (nfsi->cache_validity & NFS_INO_INVALID_ACCESS)\n\t\t\tgoto out_zap;\n\t\tcache = nfs_access_search_rbtree(inode, cred);\n\t\terr = -ENOENT;\n\t\tif (cache == NULL)\n\t\t\tgoto out;\n\t\t \n\t\tif (!nfs_check_cache_invalid(inode, NFS_INO_INVALID_ACCESS))\n\t\t\tbreak;\n\t\tif (!retry)\n\t\t\tbreak;\n\t\terr = -ECHILD;\n\t\tif (!may_block)\n\t\t\tgoto out;\n\t\tspin_unlock(&inode->i_lock);\n\t\terr = __nfs_revalidate_inode(NFS_SERVER(inode), inode);\n\t\tif (err)\n\t\t\treturn err;\n\t\tspin_lock(&inode->i_lock);\n\t\tretry = false;\n\t}\n\terr = -ENOENT;\n\tif ((s64)(login_time - cache->timestamp) > 0)\n\t\tgoto out;\n\t*mask = cache->mask;\n\tlist_move_tail(&cache->lru, &nfsi->access_cache_entry_lru);\n\terr = 0;\nout:\n\tspin_unlock(&inode->i_lock);\n\treturn err;\nout_zap:\n\tspin_unlock(&inode->i_lock);\n\tnfs_access_zap_cache(inode);\n\treturn -ENOENT;\n}\n\nstatic int nfs_access_get_cached_rcu(struct inode *inode, const struct cred *cred, u32 *mask)\n{\n\t \n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tu64 login_time = nfs_access_login_time(current, cred);\n\tstruct nfs_access_entry *cache;\n\tint err = -ECHILD;\n\tstruct list_head *lh;\n\n\trcu_read_lock();\n\tif (nfsi->cache_validity & NFS_INO_INVALID_ACCESS)\n\t\tgoto out;\n\tlh = rcu_dereference(list_tail_rcu(&nfsi->access_cache_entry_lru));\n\tcache = list_entry(lh, struct nfs_access_entry, lru);\n\tif (lh == &nfsi->access_cache_entry_lru ||\n\t    access_cmp(cred, cache) != 0)\n\t\tcache = NULL;\n\tif (cache == NULL)\n\t\tgoto out;\n\tif ((s64)(login_time - cache->timestamp) > 0)\n\t\tgoto out;\n\tif (nfs_check_cache_invalid(inode, NFS_INO_INVALID_ACCESS))\n\t\tgoto out;\n\t*mask = cache->mask;\n\terr = 0;\nout:\n\trcu_read_unlock();\n\treturn err;\n}\n\nint nfs_access_get_cached(struct inode *inode, const struct cred *cred,\n\t\t\t  u32 *mask, bool may_block)\n{\n\tint status;\n\n\tstatus = nfs_access_get_cached_rcu(inode, cred, mask);\n\tif (status != 0)\n\t\tstatus = nfs_access_get_cached_locked(inode, cred, mask,\n\t\t    may_block);\n\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(nfs_access_get_cached);\n\nstatic void nfs_access_add_rbtree(struct inode *inode,\n\t\t\t\t  struct nfs_access_entry *set,\n\t\t\t\t  const struct cred *cred)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct rb_root *root_node = &nfsi->access_cache;\n\tstruct rb_node **p = &root_node->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct nfs_access_entry *entry;\n\tint cmp;\n\n\tspin_lock(&inode->i_lock);\n\twhile (*p != NULL) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct nfs_access_entry, rb_node);\n\t\tcmp = access_cmp(cred, entry);\n\n\t\tif (cmp < 0)\n\t\t\tp = &parent->rb_left;\n\t\telse if (cmp > 0)\n\t\t\tp = &parent->rb_right;\n\t\telse\n\t\t\tgoto found;\n\t}\n\trb_link_node(&set->rb_node, parent, p);\n\trb_insert_color(&set->rb_node, root_node);\n\tlist_add_tail(&set->lru, &nfsi->access_cache_entry_lru);\n\tspin_unlock(&inode->i_lock);\n\treturn;\nfound:\n\trb_replace_node(parent, &set->rb_node, root_node);\n\tlist_add_tail(&set->lru, &nfsi->access_cache_entry_lru);\n\tlist_del(&entry->lru);\n\tspin_unlock(&inode->i_lock);\n\tnfs_access_free_entry(entry);\n}\n\nvoid nfs_access_add_cache(struct inode *inode, struct nfs_access_entry *set,\n\t\t\t  const struct cred *cred)\n{\n\tstruct nfs_access_entry *cache = kmalloc(sizeof(*cache), GFP_KERNEL);\n\tif (cache == NULL)\n\t\treturn;\n\tRB_CLEAR_NODE(&cache->rb_node);\n\tcache->fsuid = cred->fsuid;\n\tcache->fsgid = cred->fsgid;\n\tcache->group_info = get_group_info(cred->group_info);\n\tcache->mask = set->mask;\n\tcache->timestamp = ktime_get_ns();\n\n\t \n\tsmp_wmb();\n\tnfs_access_add_rbtree(inode, cache, cred);\n\n\t \n\tsmp_mb__before_atomic();\n\tatomic_long_inc(&nfs_access_nr_entries);\n\tsmp_mb__after_atomic();\n\n\t \n\tif (!test_bit(NFS_INO_ACL_LRU_SET, &NFS_I(inode)->flags)) {\n\t\tspin_lock(&nfs_access_lru_lock);\n\t\tif (!test_and_set_bit(NFS_INO_ACL_LRU_SET, &NFS_I(inode)->flags))\n\t\t\tlist_add_tail(&NFS_I(inode)->access_cache_inode_lru,\n\t\t\t\t\t&nfs_access_lru_list);\n\t\tspin_unlock(&nfs_access_lru_lock);\n\t}\n\tnfs_access_cache_enforce_limit();\n}\nEXPORT_SYMBOL_GPL(nfs_access_add_cache);\n\n#define NFS_MAY_READ (NFS_ACCESS_READ)\n#define NFS_MAY_WRITE (NFS_ACCESS_MODIFY | \\\n\t\tNFS_ACCESS_EXTEND | \\\n\t\tNFS_ACCESS_DELETE)\n#define NFS_FILE_MAY_WRITE (NFS_ACCESS_MODIFY | \\\n\t\tNFS_ACCESS_EXTEND)\n#define NFS_DIR_MAY_WRITE NFS_MAY_WRITE\n#define NFS_MAY_LOOKUP (NFS_ACCESS_LOOKUP)\n#define NFS_MAY_EXECUTE (NFS_ACCESS_EXECUTE)\nstatic int\nnfs_access_calc_mask(u32 access_result, umode_t umode)\n{\n\tint mask = 0;\n\n\tif (access_result & NFS_MAY_READ)\n\t\tmask |= MAY_READ;\n\tif (S_ISDIR(umode)) {\n\t\tif ((access_result & NFS_DIR_MAY_WRITE) == NFS_DIR_MAY_WRITE)\n\t\t\tmask |= MAY_WRITE;\n\t\tif ((access_result & NFS_MAY_LOOKUP) == NFS_MAY_LOOKUP)\n\t\t\tmask |= MAY_EXEC;\n\t} else if (S_ISREG(umode)) {\n\t\tif ((access_result & NFS_FILE_MAY_WRITE) == NFS_FILE_MAY_WRITE)\n\t\t\tmask |= MAY_WRITE;\n\t\tif ((access_result & NFS_MAY_EXECUTE) == NFS_MAY_EXECUTE)\n\t\t\tmask |= MAY_EXEC;\n\t} else if (access_result & NFS_MAY_WRITE)\n\t\t\tmask |= MAY_WRITE;\n\treturn mask;\n}\n\nvoid nfs_access_set_mask(struct nfs_access_entry *entry, u32 access_result)\n{\n\tentry->mask = access_result;\n}\nEXPORT_SYMBOL_GPL(nfs_access_set_mask);\n\nstatic int nfs_do_access(struct inode *inode, const struct cred *cred, int mask)\n{\n\tstruct nfs_access_entry cache;\n\tbool may_block = (mask & MAY_NOT_BLOCK) == 0;\n\tint cache_mask = -1;\n\tint status;\n\n\ttrace_nfs_access_enter(inode);\n\n\tstatus = nfs_access_get_cached(inode, cred, &cache.mask, may_block);\n\tif (status == 0)\n\t\tgoto out_cached;\n\n\tstatus = -ECHILD;\n\tif (!may_block)\n\t\tgoto out;\n\n\t \n\tcache.mask = NFS_ACCESS_READ | NFS_ACCESS_MODIFY | NFS_ACCESS_EXTEND |\n\t\t     nfs_access_xattr_mask(NFS_SERVER(inode));\n\tif (S_ISDIR(inode->i_mode))\n\t\tcache.mask |= NFS_ACCESS_DELETE | NFS_ACCESS_LOOKUP;\n\telse\n\t\tcache.mask |= NFS_ACCESS_EXECUTE;\n\tstatus = NFS_PROTO(inode)->access(inode, &cache, cred);\n\tif (status != 0) {\n\t\tif (status == -ESTALE) {\n\t\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\t\tnfs_set_inode_stale(inode);\n\t\t\telse\n\t\t\t\tnfs_zap_caches(inode);\n\t\t}\n\t\tgoto out;\n\t}\n\tnfs_access_add_cache(inode, &cache, cred);\nout_cached:\n\tcache_mask = nfs_access_calc_mask(cache.mask, inode->i_mode);\n\tif ((mask & ~cache_mask & (MAY_READ | MAY_WRITE | MAY_EXEC)) != 0)\n\t\tstatus = -EACCES;\nout:\n\ttrace_nfs_access_exit(inode, mask, cache_mask, status);\n\treturn status;\n}\n\nstatic int nfs_open_permission_mask(int openflags)\n{\n\tint mask = 0;\n\n\tif (openflags & __FMODE_EXEC) {\n\t\t \n\t\tmask = MAY_EXEC;\n\t} else {\n\t\tif ((openflags & O_ACCMODE) != O_WRONLY)\n\t\t\tmask |= MAY_READ;\n\t\tif ((openflags & O_ACCMODE) != O_RDONLY)\n\t\t\tmask |= MAY_WRITE;\n\t}\n\n\treturn mask;\n}\n\nint nfs_may_open(struct inode *inode, const struct cred *cred, int openflags)\n{\n\treturn nfs_do_access(inode, cred, nfs_open_permission_mask(openflags));\n}\nEXPORT_SYMBOL_GPL(nfs_may_open);\n\nstatic int nfs_execute_ok(struct inode *inode, int mask)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tint ret = 0;\n\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn 0;\n\tif (nfs_check_cache_invalid(inode, NFS_INO_INVALID_MODE)) {\n\t\tif (mask & MAY_NOT_BLOCK)\n\t\t\treturn -ECHILD;\n\t\tret = __nfs_revalidate_inode(server, inode);\n\t}\n\tif (ret == 0 && !execute_ok(inode))\n\t\tret = -EACCES;\n\treturn ret;\n}\n\nint nfs_permission(struct mnt_idmap *idmap,\n\t\t   struct inode *inode,\n\t\t   int mask)\n{\n\tconst struct cred *cred = current_cred();\n\tint res = 0;\n\n\tnfs_inc_stats(inode, NFSIOS_VFSACCESS);\n\n\tif ((mask & (MAY_READ | MAY_WRITE | MAY_EXEC)) == 0)\n\t\tgoto out;\n\t \n\tif (mask & (MAY_ACCESS | MAY_CHDIR))\n\t\tgoto force_lookup;\n\n\tswitch (inode->i_mode & S_IFMT) {\n\t\tcase S_IFLNK:\n\t\t\tgoto out;\n\t\tcase S_IFREG:\n\t\t\tif ((mask & MAY_OPEN) &&\n\t\t\t   nfs_server_capable(inode, NFS_CAP_ATOMIC_OPEN))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase S_IFDIR:\n\t\t\t \n\t\t\tif ((mask & MAY_WRITE) && !(mask & MAY_READ))\n\t\t\t\tgoto out;\n\t}\n\nforce_lookup:\n\tif (!NFS_PROTO(inode)->access)\n\t\tgoto out_notsup;\n\n\tres = nfs_do_access(inode, cred, mask);\nout:\n\tif (!res && (mask & MAY_EXEC))\n\t\tres = nfs_execute_ok(inode, mask);\n\n\tdfprintk(VFS, \"NFS: permission(%s/%lu), mask=0x%x, res=%d\\n\",\n\t\tinode->i_sb->s_id, inode->i_ino, mask, res);\n\treturn res;\nout_notsup:\n\tif (mask & MAY_NOT_BLOCK)\n\t\treturn -ECHILD;\n\n\tres = nfs_revalidate_inode(inode, NFS_INO_INVALID_MODE |\n\t\t\t\t\t\t  NFS_INO_INVALID_OTHER);\n\tif (res == 0)\n\t\tres = generic_permission(&nop_mnt_idmap, inode, mask);\n\tgoto out;\n}\nEXPORT_SYMBOL_GPL(nfs_permission);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}