{
  "module_name": "inode.c",
  "hash_id": "4e496386742fe41fb98df20e6f3de09f7f9c938be3a2d88f1e2a4f35d0a7b5ba",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfs/inode.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sched/signal.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/unistd.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs4_mount.h>\n#include <linux/lockd/bind.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/inet.h>\n#include <linux/nfs_xdr.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/uaccess.h>\n#include <linux/iversion.h>\n\n#include \"nfs4_fs.h\"\n#include \"callback.h\"\n#include \"delegation.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"fscache.h\"\n#include \"pnfs.h\"\n#include \"nfs.h\"\n#include \"netns.h\"\n#include \"sysfs.h\"\n\n#include \"nfstrace.h\"\n\n#define NFSDBG_FACILITY\t\tNFSDBG_VFS\n\n#define NFS_64_BIT_INODE_NUMBERS_ENABLED\t1\n\n \nstatic bool enable_ino64 = NFS_64_BIT_INODE_NUMBERS_ENABLED;\n\nstatic int nfs_update_inode(struct inode *, struct nfs_fattr *);\n\nstatic struct kmem_cache * nfs_inode_cachep;\n\nstatic inline unsigned long\nnfs_fattr_to_ino_t(struct nfs_fattr *fattr)\n{\n\treturn nfs_fileid_to_ino_t(fattr->fileid);\n}\n\nint nfs_wait_bit_killable(struct wait_bit_key *key, int mode)\n{\n\tschedule();\n\tif (signal_pending_state(mode, current))\n\t\treturn -ERESTARTSYS;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nfs_wait_bit_killable);\n\n \nu64 nfs_compat_user_ino64(u64 fileid)\n{\n#ifdef CONFIG_COMPAT\n\tcompat_ulong_t ino;\n#else\t\n\tunsigned long ino;\n#endif\n\n\tif (enable_ino64)\n\t\treturn fileid;\n\tino = fileid;\n\tif (sizeof(ino) < sizeof(fileid))\n\t\tino ^= fileid >> (sizeof(fileid)-sizeof(ino)) * 8;\n\treturn ino;\n}\n\nint nfs_drop_inode(struct inode *inode)\n{\n\treturn NFS_STALE(inode) || generic_drop_inode(inode);\n}\nEXPORT_SYMBOL_GPL(nfs_drop_inode);\n\nvoid nfs_clear_inode(struct inode *inode)\n{\n\t \n\tWARN_ON_ONCE(nfs_have_writebacks(inode));\n\tWARN_ON_ONCE(!list_empty(&NFS_I(inode)->open_files));\n\tnfs_zap_acl_cache(inode);\n\tnfs_access_zap_cache(inode);\n\tnfs_fscache_clear_inode(inode);\n}\nEXPORT_SYMBOL_GPL(nfs_clear_inode);\n\nvoid nfs_evict_inode(struct inode *inode)\n{\n\ttruncate_inode_pages_final(&inode->i_data);\n\tclear_inode(inode);\n\tnfs_clear_inode(inode);\n}\n\nint nfs_sync_inode(struct inode *inode)\n{\n\tinode_dio_wait(inode);\n\treturn nfs_wb_all(inode);\n}\nEXPORT_SYMBOL_GPL(nfs_sync_inode);\n\n \nint nfs_sync_mapping(struct address_space *mapping)\n{\n\tint ret = 0;\n\n\tif (mapping->nrpages != 0) {\n\t\tunmap_mapping_range(mapping, 0, 0, 0);\n\t\tret = nfs_wb_all(mapping->host);\n\t}\n\treturn ret;\n}\n\nstatic int nfs_attribute_timeout(struct inode *inode)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\treturn !time_in_range_open(jiffies, nfsi->read_cache_jiffies, nfsi->read_cache_jiffies + nfsi->attrtimeo);\n}\n\nstatic bool nfs_check_cache_flags_invalid(struct inode *inode,\n\t\t\t\t\t  unsigned long flags)\n{\n\tunsigned long cache_validity = READ_ONCE(NFS_I(inode)->cache_validity);\n\n\treturn (cache_validity & flags) != 0;\n}\n\nbool nfs_check_cache_invalid(struct inode *inode, unsigned long flags)\n{\n\tif (nfs_check_cache_flags_invalid(inode, flags))\n\t\treturn true;\n\treturn nfs_attribute_cache_expired(inode);\n}\nEXPORT_SYMBOL_GPL(nfs_check_cache_invalid);\n\n#ifdef CONFIG_NFS_V4_2\nstatic bool nfs_has_xattr_cache(const struct nfs_inode *nfsi)\n{\n\treturn nfsi->xattr_cache != NULL;\n}\n#else\nstatic bool nfs_has_xattr_cache(const struct nfs_inode *nfsi)\n{\n\treturn false;\n}\n#endif\n\nvoid nfs_set_cache_invalid(struct inode *inode, unsigned long flags)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tbool have_delegation = NFS_PROTO(inode)->have_delegation(inode, FMODE_READ);\n\n\tif (have_delegation) {\n\t\tif (!(flags & NFS_INO_REVAL_FORCED))\n\t\t\tflags &= ~(NFS_INO_INVALID_MODE |\n\t\t\t\t   NFS_INO_INVALID_OTHER |\n\t\t\t\t   NFS_INO_INVALID_XATTR);\n\t\tflags &= ~(NFS_INO_INVALID_CHANGE | NFS_INO_INVALID_SIZE);\n\t}\n\n\tif (!nfs_has_xattr_cache(nfsi))\n\t\tflags &= ~NFS_INO_INVALID_XATTR;\n\tif (flags & NFS_INO_INVALID_DATA)\n\t\tnfs_fscache_invalidate(inode, 0);\n\tflags &= ~NFS_INO_REVAL_FORCED;\n\n\tnfsi->cache_validity |= flags;\n\n\tif (inode->i_mapping->nrpages == 0) {\n\t\tnfsi->cache_validity &= ~NFS_INO_INVALID_DATA;\n\t\tnfs_ooo_clear(nfsi);\n\t} else if (nfsi->cache_validity & NFS_INO_INVALID_DATA) {\n\t\tnfs_ooo_clear(nfsi);\n\t}\n\ttrace_nfs_set_cache_invalid(inode, 0);\n}\nEXPORT_SYMBOL_GPL(nfs_set_cache_invalid);\n\n \nstatic void nfs_zap_caches_locked(struct inode *inode)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tint mode = inode->i_mode;\n\n\tnfs_inc_stats(inode, NFSIOS_ATTRINVALIDATE);\n\n\tnfsi->attrtimeo = NFS_MINATTRTIMEO(inode);\n\tnfsi->attrtimeo_timestamp = jiffies;\n\n\tif (S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode))\n\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR |\n\t\t\t\t\t\t     NFS_INO_INVALID_DATA |\n\t\t\t\t\t\t     NFS_INO_INVALID_ACCESS |\n\t\t\t\t\t\t     NFS_INO_INVALID_ACL |\n\t\t\t\t\t\t     NFS_INO_INVALID_XATTR);\n\telse\n\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR |\n\t\t\t\t\t\t     NFS_INO_INVALID_ACCESS |\n\t\t\t\t\t\t     NFS_INO_INVALID_ACL |\n\t\t\t\t\t\t     NFS_INO_INVALID_XATTR);\n\tnfs_zap_label_cache_locked(nfsi);\n}\n\nvoid nfs_zap_caches(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tnfs_zap_caches_locked(inode);\n\tspin_unlock(&inode->i_lock);\n}\n\nvoid nfs_zap_mapping(struct inode *inode, struct address_space *mapping)\n{\n\tif (mapping->nrpages != 0) {\n\t\tspin_lock(&inode->i_lock);\n\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_DATA);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n}\n\nvoid nfs_zap_acl_cache(struct inode *inode)\n{\n\tvoid (*clear_acl_cache)(struct inode *);\n\n\tclear_acl_cache = NFS_PROTO(inode)->clear_acl_cache;\n\tif (clear_acl_cache != NULL)\n\t\tclear_acl_cache(inode);\n\tspin_lock(&inode->i_lock);\n\tNFS_I(inode)->cache_validity &= ~NFS_INO_INVALID_ACL;\n\tspin_unlock(&inode->i_lock);\n}\nEXPORT_SYMBOL_GPL(nfs_zap_acl_cache);\n\nvoid nfs_invalidate_atime(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATIME);\n\tspin_unlock(&inode->i_lock);\n}\nEXPORT_SYMBOL_GPL(nfs_invalidate_atime);\n\n \nstatic void nfs_set_inode_stale_locked(struct inode *inode)\n{\n\tset_bit(NFS_INO_STALE, &NFS_I(inode)->flags);\n\tnfs_zap_caches_locked(inode);\n\ttrace_nfs_set_inode_stale(inode);\n}\n\nvoid nfs_set_inode_stale(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tnfs_set_inode_stale_locked(inode);\n\tspin_unlock(&inode->i_lock);\n}\n\nstruct nfs_find_desc {\n\tstruct nfs_fh\t\t*fh;\n\tstruct nfs_fattr\t*fattr;\n};\n\n \nstatic int\nnfs_find_actor(struct inode *inode, void *opaque)\n{\n\tstruct nfs_find_desc\t*desc = opaque;\n\tstruct nfs_fh\t\t*fh = desc->fh;\n\tstruct nfs_fattr\t*fattr = desc->fattr;\n\n\tif (NFS_FILEID(inode) != fattr->fileid)\n\t\treturn 0;\n\tif (inode_wrong_type(inode, fattr->mode))\n\t\treturn 0;\n\tif (nfs_compare_fh(NFS_FH(inode), fh))\n\t\treturn 0;\n\tif (is_bad_inode(inode) || NFS_STALE(inode))\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic int\nnfs_init_locked(struct inode *inode, void *opaque)\n{\n\tstruct nfs_find_desc\t*desc = opaque;\n\tstruct nfs_fattr\t*fattr = desc->fattr;\n\n\tset_nfs_fileid(inode, fattr->fileid);\n\tinode->i_mode = fattr->mode;\n\tnfs_copy_fh(NFS_FH(inode), desc->fh);\n\treturn 0;\n}\n\n#ifdef CONFIG_NFS_V4_SECURITY_LABEL\nstatic void nfs_clear_label_invalid(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tNFS_I(inode)->cache_validity &= ~NFS_INO_INVALID_LABEL;\n\tspin_unlock(&inode->i_lock);\n}\n\nvoid nfs_setsecurity(struct inode *inode, struct nfs_fattr *fattr)\n{\n\tint error;\n\n\tif (fattr->label == NULL)\n\t\treturn;\n\n\tif ((fattr->valid & NFS_ATTR_FATTR_V4_SECURITY_LABEL) && inode->i_security) {\n\t\terror = security_inode_notifysecctx(inode, fattr->label->label,\n\t\t\t\tfattr->label->len);\n\t\tif (error)\n\t\t\tprintk(KERN_ERR \"%s() %s %d \"\n\t\t\t\t\t\"security_inode_notifysecctx() %d\\n\",\n\t\t\t\t\t__func__,\n\t\t\t\t\t(char *)fattr->label->label,\n\t\t\t\t\tfattr->label->len, error);\n\t\tnfs_clear_label_invalid(inode);\n\t}\n}\n\nstruct nfs4_label *nfs4_label_alloc(struct nfs_server *server, gfp_t flags)\n{\n\tstruct nfs4_label *label;\n\n\tif (!(server->caps & NFS_CAP_SECURITY_LABEL))\n\t\treturn NULL;\n\n\tlabel = kzalloc(sizeof(struct nfs4_label), flags);\n\tif (label == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlabel->label = kzalloc(NFS4_MAXLABELLEN, flags);\n\tif (label->label == NULL) {\n\t\tkfree(label);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tlabel->len = NFS4_MAXLABELLEN;\n\n\treturn label;\n}\nEXPORT_SYMBOL_GPL(nfs4_label_alloc);\n#else\nvoid nfs_setsecurity(struct inode *inode, struct nfs_fattr *fattr)\n{\n}\n#endif\nEXPORT_SYMBOL_GPL(nfs_setsecurity);\n\n \nstruct inode *\nnfs_ilookup(struct super_block *sb, struct nfs_fattr *fattr, struct nfs_fh *fh)\n{\n\tstruct nfs_find_desc desc = {\n\t\t.fh\t= fh,\n\t\t.fattr\t= fattr,\n\t};\n\tstruct inode *inode;\n\tunsigned long hash;\n\n\tif (!(fattr->valid & NFS_ATTR_FATTR_FILEID) ||\n\t    !(fattr->valid & NFS_ATTR_FATTR_TYPE))\n\t\treturn NULL;\n\n\thash = nfs_fattr_to_ino_t(fattr);\n\tinode = ilookup5(sb, hash, nfs_find_actor, &desc);\n\n\tdprintk(\"%s: returning %p\\n\", __func__, inode);\n\treturn inode;\n}\n\nstatic void nfs_inode_init_regular(struct nfs_inode *nfsi)\n{\n\tatomic_long_set(&nfsi->nrequests, 0);\n\tatomic_long_set(&nfsi->redirtied_pages, 0);\n\tINIT_LIST_HEAD(&nfsi->commit_info.list);\n\tatomic_long_set(&nfsi->commit_info.ncommit, 0);\n\tatomic_set(&nfsi->commit_info.rpcs_out, 0);\n\tmutex_init(&nfsi->commit_mutex);\n}\n\nstatic void nfs_inode_init_dir(struct nfs_inode *nfsi)\n{\n\tnfsi->cache_change_attribute = 0;\n\tmemset(nfsi->cookieverf, 0, sizeof(nfsi->cookieverf));\n\tinit_rwsem(&nfsi->rmdir_sem);\n}\n\n \nstruct inode *\nnfs_fhget(struct super_block *sb, struct nfs_fh *fh, struct nfs_fattr *fattr)\n{\n\tstruct nfs_find_desc desc = {\n\t\t.fh\t= fh,\n\t\t.fattr\t= fattr\n\t};\n\tstruct inode *inode = ERR_PTR(-ENOENT);\n\tu64 fattr_supported = NFS_SB(sb)->fattr_valid;\n\tunsigned long hash;\n\n\tnfs_attr_check_mountpoint(sb, fattr);\n\n\tif (nfs_attr_use_mounted_on_fileid(fattr))\n\t\tfattr->fileid = fattr->mounted_on_fileid;\n\telse if ((fattr->valid & NFS_ATTR_FATTR_FILEID) == 0)\n\t\tgoto out_no_inode;\n\tif ((fattr->valid & NFS_ATTR_FATTR_TYPE) == 0)\n\t\tgoto out_no_inode;\n\n\thash = nfs_fattr_to_ino_t(fattr);\n\n\tinode = iget5_locked(sb, hash, nfs_find_actor, nfs_init_locked, &desc);\n\tif (inode == NULL) {\n\t\tinode = ERR_PTR(-ENOMEM);\n\t\tgoto out_no_inode;\n\t}\n\n\tif (inode->i_state & I_NEW) {\n\t\tstruct nfs_inode *nfsi = NFS_I(inode);\n\t\tunsigned long now = jiffies;\n\n\t\t \n\t\tinode->i_ino = hash;\n\n\t\t \n\t\tinode->i_flags |= S_NOATIME|S_NOCMTIME;\n\t\tinode->i_mode = fattr->mode;\n\t\tnfsi->cache_validity = 0;\n\t\tif ((fattr->valid & NFS_ATTR_FATTR_MODE) == 0\n\t\t\t\t&& (fattr_supported & NFS_ATTR_FATTR_MODE))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_MODE);\n\t\t \n\t\tinode->i_op = NFS_SB(sb)->nfs_client->rpc_ops->file_inode_ops;\n\t\tif (S_ISREG(inode->i_mode)) {\n\t\t\tinode->i_fop = NFS_SB(sb)->nfs_client->rpc_ops->file_ops;\n\t\t\tinode->i_data.a_ops = &nfs_file_aops;\n\t\t\tnfs_inode_init_regular(nfsi);\n\t\t} else if (S_ISDIR(inode->i_mode)) {\n\t\t\tinode->i_op = NFS_SB(sb)->nfs_client->rpc_ops->dir_inode_ops;\n\t\t\tinode->i_fop = &nfs_dir_operations;\n\t\t\tinode->i_data.a_ops = &nfs_dir_aops;\n\t\t\tnfs_inode_init_dir(nfsi);\n\t\t\t \n\t\t\tif (fattr->valid & NFS_ATTR_FATTR_MOUNTPOINT ||\n\t\t\t\t\tfattr->valid & NFS_ATTR_FATTR_V4_REFERRAL) {\n\t\t\t\tif (fattr->valid & NFS_ATTR_FATTR_V4_REFERRAL)\n\t\t\t\t\tinode->i_op = &nfs_referral_inode_operations;\n\t\t\t\telse\n\t\t\t\t\tinode->i_op = &nfs_mountpoint_inode_operations;\n\t\t\t\tinode->i_fop = NULL;\n\t\t\t\tinode->i_flags |= S_AUTOMOUNT;\n\t\t\t}\n\t\t} else if (S_ISLNK(inode->i_mode)) {\n\t\t\tinode->i_op = &nfs_symlink_inode_operations;\n\t\t\tinode_nohighmem(inode);\n\t\t} else\n\t\t\tinit_special_inode(inode, inode->i_mode, fattr->rdev);\n\n\t\tmemset(&inode->i_atime, 0, sizeof(inode->i_atime));\n\t\tmemset(&inode->i_mtime, 0, sizeof(inode->i_mtime));\n\t\tinode_set_ctime(inode, 0, 0);\n\t\tinode_set_iversion_raw(inode, 0);\n\t\tinode->i_size = 0;\n\t\tclear_nlink(inode);\n\t\tinode->i_uid = make_kuid(&init_user_ns, -2);\n\t\tinode->i_gid = make_kgid(&init_user_ns, -2);\n\t\tinode->i_blocks = 0;\n\t\tnfsi->write_io = 0;\n\t\tnfsi->read_io = 0;\n\n\t\tnfsi->read_cache_jiffies = fattr->time_start;\n\t\tnfsi->attr_gencount = fattr->gencount;\n\t\tif (fattr->valid & NFS_ATTR_FATTR_ATIME)\n\t\t\tinode->i_atime = fattr->atime;\n\t\telse if (fattr_supported & NFS_ATTR_FATTR_ATIME)\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATIME);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_MTIME)\n\t\t\tinode->i_mtime = fattr->mtime;\n\t\telse if (fattr_supported & NFS_ATTR_FATTR_MTIME)\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_MTIME);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_CTIME)\n\t\t\tinode_set_ctime_to_ts(inode, fattr->ctime);\n\t\telse if (fattr_supported & NFS_ATTR_FATTR_CTIME)\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_CTIME);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_CHANGE)\n\t\t\tinode_set_iversion_raw(inode, fattr->change_attr);\n\t\telse\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_CHANGE);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_SIZE)\n\t\t\tinode->i_size = nfs_size_to_loff_t(fattr->size);\n\t\telse\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_SIZE);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_NLINK)\n\t\t\tset_nlink(inode, fattr->nlink);\n\t\telse if (fattr_supported & NFS_ATTR_FATTR_NLINK)\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_NLINK);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_OWNER)\n\t\t\tinode->i_uid = fattr->uid;\n\t\telse if (fattr_supported & NFS_ATTR_FATTR_OWNER)\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_OTHER);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_GROUP)\n\t\t\tinode->i_gid = fattr->gid;\n\t\telse if (fattr_supported & NFS_ATTR_FATTR_GROUP)\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_OTHER);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_BLOCKS_USED)\n\t\t\tinode->i_blocks = fattr->du.nfs2.blocks;\n\t\telse if (fattr_supported & NFS_ATTR_FATTR_BLOCKS_USED &&\n\t\t\t fattr->size != 0)\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_BLOCKS);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_SPACE_USED) {\n\t\t\t \n\t\t\tinode->i_blocks = nfs_calc_block_size(fattr->du.nfs3.used);\n\t\t} else if (fattr_supported & NFS_ATTR_FATTR_SPACE_USED &&\n\t\t\t   fattr->size != 0)\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_BLOCKS);\n\n\t\tnfs_setsecurity(inode, fattr);\n\n\t\tnfsi->attrtimeo = NFS_MINATTRTIMEO(inode);\n\t\tnfsi->attrtimeo_timestamp = now;\n\t\tnfsi->access_cache = RB_ROOT;\n\n\t\tnfs_fscache_init_inode(inode);\n\n\t\tunlock_new_inode(inode);\n\t} else {\n\t\tint err = nfs_refresh_inode(inode, fattr);\n\t\tif (err < 0) {\n\t\t\tiput(inode);\n\t\t\tinode = ERR_PTR(err);\n\t\t\tgoto out_no_inode;\n\t\t}\n\t}\n\tdprintk(\"NFS: nfs_fhget(%s/%Lu fh_crc=0x%08x ct=%d)\\n\",\n\t\tinode->i_sb->s_id,\n\t\t(unsigned long long)NFS_FILEID(inode),\n\t\tnfs_display_fhandle_hash(fh),\n\t\tatomic_read(&inode->i_count));\n\nout:\n\treturn inode;\n\nout_no_inode:\n\tdprintk(\"nfs_fhget: iget failed with error %ld\\n\", PTR_ERR(inode));\n\tgoto out;\n}\nEXPORT_SYMBOL_GPL(nfs_fhget);\n\n#define NFS_VALID_ATTRS (ATTR_MODE|ATTR_UID|ATTR_GID|ATTR_SIZE|ATTR_ATIME|ATTR_ATIME_SET|ATTR_MTIME|ATTR_MTIME_SET|ATTR_FILE|ATTR_OPEN)\n\nint\nnfs_setattr(struct mnt_idmap *idmap, struct dentry *dentry,\n\t    struct iattr *attr)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct nfs_fattr *fattr;\n\tint error = 0;\n\n\tnfs_inc_stats(inode, NFSIOS_VFSSETATTR);\n\n\t \n\tif (attr->ia_valid & (ATTR_KILL_SUID | ATTR_KILL_SGID))\n\t\tattr->ia_valid &= ~ATTR_MODE;\n\n\tif (attr->ia_valid & ATTR_SIZE) {\n\t\tBUG_ON(!S_ISREG(inode->i_mode));\n\n\t\terror = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (attr->ia_size == i_size_read(inode))\n\t\t\tattr->ia_valid &= ~ATTR_SIZE;\n\t}\n\n\t \n\tif (((attr->ia_valid & NFS_VALID_ATTRS) & ~(ATTR_FILE|ATTR_OPEN)) == 0)\n\t\treturn 0;\n\n\ttrace_nfs_setattr_enter(inode);\n\n\t \n\tif (S_ISREG(inode->i_mode))\n\t\tnfs_sync_inode(inode);\n\n\tfattr = nfs_alloc_fattr_with_label(NFS_SERVER(inode));\n\tif (fattr == NULL) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\terror = NFS_PROTO(inode)->setattr(dentry, fattr, attr);\n\tif (error == 0)\n\t\terror = nfs_refresh_inode(inode, fattr);\n\tnfs_free_fattr(fattr);\nout:\n\ttrace_nfs_setattr_exit(inode, error);\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(nfs_setattr);\n\n \nstatic int nfs_vmtruncate(struct inode * inode, loff_t offset)\n{\n\tint err;\n\n\terr = inode_newsize_ok(inode, offset);\n\tif (err)\n\t\tgoto out;\n\n\ttrace_nfs_size_truncate(inode, offset);\n\ti_size_write(inode, offset);\n\t \n\tif (offset == 0) {\n\t\tNFS_I(inode)->cache_validity &= ~NFS_INO_INVALID_DATA;\n\t\tnfs_ooo_clear(NFS_I(inode));\n\t}\n\tNFS_I(inode)->cache_validity &= ~NFS_INO_INVALID_SIZE;\n\n\tspin_unlock(&inode->i_lock);\n\ttruncate_pagecache(inode, offset);\n\tspin_lock(&inode->i_lock);\nout:\n\treturn err;\n}\n\n \nvoid nfs_setattr_update_inode(struct inode *inode, struct iattr *attr,\n\t\tstruct nfs_fattr *fattr)\n{\n\t \n\tnfs_fattr_set_barrier(fattr);\n\n\tspin_lock(&inode->i_lock);\n\tNFS_I(inode)->attr_gencount = fattr->gencount;\n\tif ((attr->ia_valid & ATTR_SIZE) != 0) {\n\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_MTIME |\n\t\t\t\t\t\t     NFS_INO_INVALID_BLOCKS);\n\t\tnfs_inc_stats(inode, NFSIOS_SETATTRTRUNC);\n\t\tnfs_vmtruncate(inode, attr->ia_size);\n\t}\n\tif ((attr->ia_valid & (ATTR_MODE|ATTR_UID|ATTR_GID)) != 0) {\n\t\tNFS_I(inode)->cache_validity &= ~NFS_INO_INVALID_CTIME;\n\t\tif ((attr->ia_valid & ATTR_KILL_SUID) != 0 &&\n\t\t    inode->i_mode & S_ISUID)\n\t\t\tinode->i_mode &= ~S_ISUID;\n\t\tif (setattr_should_drop_sgid(&nop_mnt_idmap, inode))\n\t\t\tinode->i_mode &= ~S_ISGID;\n\t\tif ((attr->ia_valid & ATTR_MODE) != 0) {\n\t\t\tint mode = attr->ia_mode & S_IALLUGO;\n\t\t\tmode |= inode->i_mode & ~S_IALLUGO;\n\t\t\tinode->i_mode = mode;\n\t\t}\n\t\tif ((attr->ia_valid & ATTR_UID) != 0)\n\t\t\tinode->i_uid = attr->ia_uid;\n\t\tif ((attr->ia_valid & ATTR_GID) != 0)\n\t\t\tinode->i_gid = attr->ia_gid;\n\t\tif (fattr->valid & NFS_ATTR_FATTR_CTIME)\n\t\t\tinode_set_ctime_to_ts(inode, fattr->ctime);\n\t\telse\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_CHANGE\n\t\t\t\t\t| NFS_INO_INVALID_CTIME);\n\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ACCESS\n\t\t\t\t| NFS_INO_INVALID_ACL);\n\t}\n\tif (attr->ia_valid & (ATTR_ATIME_SET|ATTR_ATIME)) {\n\t\tNFS_I(inode)->cache_validity &= ~(NFS_INO_INVALID_ATIME\n\t\t\t\t| NFS_INO_INVALID_CTIME);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_ATIME)\n\t\t\tinode->i_atime = fattr->atime;\n\t\telse if (attr->ia_valid & ATTR_ATIME_SET)\n\t\t\tinode->i_atime = attr->ia_atime;\n\t\telse\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATIME);\n\n\t\tif (fattr->valid & NFS_ATTR_FATTR_CTIME)\n\t\t\tinode_set_ctime_to_ts(inode, fattr->ctime);\n\t\telse\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_CHANGE\n\t\t\t\t\t| NFS_INO_INVALID_CTIME);\n\t}\n\tif (attr->ia_valid & (ATTR_MTIME_SET|ATTR_MTIME)) {\n\t\tNFS_I(inode)->cache_validity &= ~(NFS_INO_INVALID_MTIME\n\t\t\t\t| NFS_INO_INVALID_CTIME);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_MTIME)\n\t\t\tinode->i_mtime = fattr->mtime;\n\t\telse if (attr->ia_valid & ATTR_MTIME_SET)\n\t\t\tinode->i_mtime = attr->ia_mtime;\n\t\telse\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_MTIME);\n\n\t\tif (fattr->valid & NFS_ATTR_FATTR_CTIME)\n\t\t\tinode_set_ctime_to_ts(inode, fattr->ctime);\n\t\telse\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_CHANGE\n\t\t\t\t\t| NFS_INO_INVALID_CTIME);\n\t}\n\tif (fattr->valid)\n\t\tnfs_update_inode(inode, fattr);\n\tspin_unlock(&inode->i_lock);\n}\nEXPORT_SYMBOL_GPL(nfs_setattr_update_inode);\n\n \nstatic bool nfs_getattr_readdirplus_enable(const struct inode *inode)\n{\n\treturn nfs_server_capable(inode, NFS_CAP_READDIRPLUS) &&\n\t       !nfs_have_writebacks(inode) && NFS_MAXATTRTIMEO(inode) > 5 * HZ;\n}\n\nstatic void nfs_readdirplus_parent_cache_miss(struct dentry *dentry)\n{\n\tif (!IS_ROOT(dentry)) {\n\t\tstruct dentry *parent = dget_parent(dentry);\n\t\tnfs_readdir_record_entry_cache_miss(d_inode(parent));\n\t\tdput(parent);\n\t}\n}\n\nstatic void nfs_readdirplus_parent_cache_hit(struct dentry *dentry)\n{\n\tif (!IS_ROOT(dentry)) {\n\t\tstruct dentry *parent = dget_parent(dentry);\n\t\tnfs_readdir_record_entry_cache_hit(d_inode(parent));\n\t\tdput(parent);\n\t}\n}\n\nstatic u32 nfs_get_valid_attrmask(struct inode *inode)\n{\n\tunsigned long cache_validity = READ_ONCE(NFS_I(inode)->cache_validity);\n\tu32 reply_mask = STATX_INO | STATX_TYPE;\n\n\tif (!(cache_validity & NFS_INO_INVALID_ATIME))\n\t\treply_mask |= STATX_ATIME;\n\tif (!(cache_validity & NFS_INO_INVALID_CTIME))\n\t\treply_mask |= STATX_CTIME;\n\tif (!(cache_validity & NFS_INO_INVALID_MTIME))\n\t\treply_mask |= STATX_MTIME;\n\tif (!(cache_validity & NFS_INO_INVALID_SIZE))\n\t\treply_mask |= STATX_SIZE;\n\tif (!(cache_validity & NFS_INO_INVALID_NLINK))\n\t\treply_mask |= STATX_NLINK;\n\tif (!(cache_validity & NFS_INO_INVALID_MODE))\n\t\treply_mask |= STATX_MODE;\n\tif (!(cache_validity & NFS_INO_INVALID_OTHER))\n\t\treply_mask |= STATX_UID | STATX_GID;\n\tif (!(cache_validity & NFS_INO_INVALID_BLOCKS))\n\t\treply_mask |= STATX_BLOCKS;\n\tif (!(cache_validity & NFS_INO_INVALID_CHANGE))\n\t\treply_mask |= STATX_CHANGE_COOKIE;\n\treturn reply_mask;\n}\n\nint nfs_getattr(struct mnt_idmap *idmap, const struct path *path,\n\t\tstruct kstat *stat, u32 request_mask, unsigned int query_flags)\n{\n\tstruct inode *inode = d_inode(path->dentry);\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tunsigned long cache_validity;\n\tint err = 0;\n\tbool force_sync = query_flags & AT_STATX_FORCE_SYNC;\n\tbool do_update = false;\n\tbool readdirplus_enabled = nfs_getattr_readdirplus_enable(inode);\n\n\ttrace_nfs_getattr_enter(inode);\n\n\trequest_mask &= STATX_TYPE | STATX_MODE | STATX_NLINK | STATX_UID |\n\t\t\tSTATX_GID | STATX_ATIME | STATX_MTIME | STATX_CTIME |\n\t\t\tSTATX_INO | STATX_SIZE | STATX_BLOCKS |\n\t\t\tSTATX_CHANGE_COOKIE;\n\n\tif ((query_flags & AT_STATX_DONT_SYNC) && !force_sync) {\n\t\tif (readdirplus_enabled)\n\t\t\tnfs_readdirplus_parent_cache_hit(path->dentry);\n\t\tgoto out_no_revalidate;\n\t}\n\n\t \n\tif ((request_mask & (STATX_CTIME | STATX_MTIME | STATX_CHANGE_COOKIE)) &&\n\t    S_ISREG(inode->i_mode))\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\n\t \n\tif ((path->mnt->mnt_flags & MNT_NOATIME) ||\n\t    ((path->mnt->mnt_flags & MNT_NODIRATIME) && S_ISDIR(inode->i_mode)))\n\t\trequest_mask &= ~STATX_ATIME;\n\n\t \n\tif (!(request_mask & (STATX_MODE|STATX_NLINK|STATX_ATIME|STATX_CTIME|\n\t\t\t\t\tSTATX_MTIME|STATX_UID|STATX_GID|\n\t\t\t\t\tSTATX_SIZE|STATX_BLOCKS|\n\t\t\t\t\tSTATX_CHANGE_COOKIE)))\n\t\tgoto out_no_revalidate;\n\n\t \n\tdo_update |= force_sync || nfs_attribute_cache_expired(inode);\n\tcache_validity = READ_ONCE(NFS_I(inode)->cache_validity);\n\tdo_update |= cache_validity & NFS_INO_INVALID_CHANGE;\n\tif (request_mask & STATX_ATIME)\n\t\tdo_update |= cache_validity & NFS_INO_INVALID_ATIME;\n\tif (request_mask & STATX_CTIME)\n\t\tdo_update |= cache_validity & NFS_INO_INVALID_CTIME;\n\tif (request_mask & STATX_MTIME)\n\t\tdo_update |= cache_validity & NFS_INO_INVALID_MTIME;\n\tif (request_mask & STATX_SIZE)\n\t\tdo_update |= cache_validity & NFS_INO_INVALID_SIZE;\n\tif (request_mask & STATX_NLINK)\n\t\tdo_update |= cache_validity & NFS_INO_INVALID_NLINK;\n\tif (request_mask & STATX_MODE)\n\t\tdo_update |= cache_validity & NFS_INO_INVALID_MODE;\n\tif (request_mask & (STATX_UID | STATX_GID))\n\t\tdo_update |= cache_validity & NFS_INO_INVALID_OTHER;\n\tif (request_mask & STATX_BLOCKS)\n\t\tdo_update |= cache_validity & NFS_INO_INVALID_BLOCKS;\n\n\tif (do_update) {\n\t\tif (readdirplus_enabled)\n\t\t\tnfs_readdirplus_parent_cache_miss(path->dentry);\n\t\terr = __nfs_revalidate_inode(server, inode);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else if (readdirplus_enabled)\n\t\tnfs_readdirplus_parent_cache_hit(path->dentry);\nout_no_revalidate:\n\t \n\tstat->result_mask = nfs_get_valid_attrmask(inode) | request_mask;\n\n\tgeneric_fillattr(&nop_mnt_idmap, request_mask, inode, stat);\n\tstat->ino = nfs_compat_user_ino64(NFS_FILEID(inode));\n\tstat->change_cookie = inode_peek_iversion_raw(inode);\n\tstat->attributes_mask |= STATX_ATTR_CHANGE_MONOTONIC;\n\tif (server->change_attr_type != NFS4_CHANGE_TYPE_IS_UNDEFINED)\n\t\tstat->attributes |= STATX_ATTR_CHANGE_MONOTONIC;\n\tif (S_ISDIR(inode->i_mode))\n\t\tstat->blksize = NFS_SERVER(inode)->dtsize;\nout:\n\ttrace_nfs_getattr_exit(inode, err);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(nfs_getattr);\n\nstatic void nfs_init_lock_context(struct nfs_lock_context *l_ctx)\n{\n\trefcount_set(&l_ctx->count, 1);\n\tl_ctx->lockowner = current->files;\n\tINIT_LIST_HEAD(&l_ctx->list);\n\tatomic_set(&l_ctx->io_count, 0);\n}\n\nstatic struct nfs_lock_context *__nfs_find_lock_context(struct nfs_open_context *ctx)\n{\n\tstruct nfs_lock_context *pos;\n\n\tlist_for_each_entry_rcu(pos, &ctx->lock_context.list, list) {\n\t\tif (pos->lockowner != current->files)\n\t\t\tcontinue;\n\t\tif (refcount_inc_not_zero(&pos->count))\n\t\t\treturn pos;\n\t}\n\treturn NULL;\n}\n\nstruct nfs_lock_context *nfs_get_lock_context(struct nfs_open_context *ctx)\n{\n\tstruct nfs_lock_context *res, *new = NULL;\n\tstruct inode *inode = d_inode(ctx->dentry);\n\n\trcu_read_lock();\n\tres = __nfs_find_lock_context(ctx);\n\trcu_read_unlock();\n\tif (res == NULL) {\n\t\tnew = kmalloc(sizeof(*new), GFP_KERNEL_ACCOUNT);\n\t\tif (new == NULL)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tnfs_init_lock_context(new);\n\t\tspin_lock(&inode->i_lock);\n\t\tres = __nfs_find_lock_context(ctx);\n\t\tif (res == NULL) {\n\t\t\tnew->open_context = get_nfs_open_context(ctx);\n\t\t\tif (new->open_context) {\n\t\t\t\tlist_add_tail_rcu(&new->list,\n\t\t\t\t\t\t&ctx->lock_context.list);\n\t\t\t\tres = new;\n\t\t\t\tnew = NULL;\n\t\t\t} else\n\t\t\t\tres = ERR_PTR(-EBADF);\n\t\t}\n\t\tspin_unlock(&inode->i_lock);\n\t\tkfree(new);\n\t}\n\treturn res;\n}\nEXPORT_SYMBOL_GPL(nfs_get_lock_context);\n\nvoid nfs_put_lock_context(struct nfs_lock_context *l_ctx)\n{\n\tstruct nfs_open_context *ctx = l_ctx->open_context;\n\tstruct inode *inode = d_inode(ctx->dentry);\n\n\tif (!refcount_dec_and_lock(&l_ctx->count, &inode->i_lock))\n\t\treturn;\n\tlist_del_rcu(&l_ctx->list);\n\tspin_unlock(&inode->i_lock);\n\tput_nfs_open_context(ctx);\n\tkfree_rcu(l_ctx, rcu_head);\n}\nEXPORT_SYMBOL_GPL(nfs_put_lock_context);\n\n \nvoid nfs_close_context(struct nfs_open_context *ctx, int is_sync)\n{\n\tstruct nfs_inode *nfsi;\n\tstruct inode *inode;\n\n\tif (!(ctx->mode & FMODE_WRITE))\n\t\treturn;\n\tif (!is_sync)\n\t\treturn;\n\tinode = d_inode(ctx->dentry);\n\tif (NFS_PROTO(inode)->have_delegation(inode, FMODE_READ))\n\t\treturn;\n\tnfsi = NFS_I(inode);\n\tif (inode->i_mapping->nrpages == 0)\n\t\treturn;\n\tif (nfsi->cache_validity & NFS_INO_INVALID_DATA)\n\t\treturn;\n\tif (!list_empty(&nfsi->open_files))\n\t\treturn;\n\tif (NFS_SERVER(inode)->flags & NFS_MOUNT_NOCTO)\n\t\treturn;\n\tnfs_revalidate_inode(inode,\n\t\t\t     NFS_INO_INVALID_CHANGE | NFS_INO_INVALID_SIZE);\n}\nEXPORT_SYMBOL_GPL(nfs_close_context);\n\nstruct nfs_open_context *alloc_nfs_open_context(struct dentry *dentry,\n\t\t\t\t\t\tfmode_t f_mode,\n\t\t\t\t\t\tstruct file *filp)\n{\n\tstruct nfs_open_context *ctx;\n\n\tctx = kmalloc(sizeof(*ctx), GFP_KERNEL_ACCOUNT);\n\tif (!ctx)\n\t\treturn ERR_PTR(-ENOMEM);\n\tnfs_sb_active(dentry->d_sb);\n\tctx->dentry = dget(dentry);\n\tif (filp)\n\t\tctx->cred = get_cred(filp->f_cred);\n\telse\n\t\tctx->cred = get_current_cred();\n\trcu_assign_pointer(ctx->ll_cred, NULL);\n\tctx->state = NULL;\n\tctx->mode = f_mode;\n\tctx->flags = 0;\n\tctx->error = 0;\n\tctx->flock_owner = (fl_owner_t)filp;\n\tnfs_init_lock_context(&ctx->lock_context);\n\tctx->lock_context.open_context = ctx;\n\tINIT_LIST_HEAD(&ctx->list);\n\tctx->mdsthreshold = NULL;\n\treturn ctx;\n}\nEXPORT_SYMBOL_GPL(alloc_nfs_open_context);\n\nstruct nfs_open_context *get_nfs_open_context(struct nfs_open_context *ctx)\n{\n\tif (ctx != NULL && refcount_inc_not_zero(&ctx->lock_context.count))\n\t\treturn ctx;\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(get_nfs_open_context);\n\nstatic void __put_nfs_open_context(struct nfs_open_context *ctx, int is_sync)\n{\n\tstruct inode *inode = d_inode(ctx->dentry);\n\tstruct super_block *sb = ctx->dentry->d_sb;\n\n\tif (!refcount_dec_and_test(&ctx->lock_context.count))\n\t\treturn;\n\tif (!list_empty(&ctx->list)) {\n\t\tspin_lock(&inode->i_lock);\n\t\tlist_del_rcu(&ctx->list);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\tif (inode != NULL)\n\t\tNFS_PROTO(inode)->close_context(ctx, is_sync);\n\tput_cred(ctx->cred);\n\tdput(ctx->dentry);\n\tnfs_sb_deactive(sb);\n\tput_rpccred(rcu_dereference_protected(ctx->ll_cred, 1));\n\tkfree(ctx->mdsthreshold);\n\tkfree_rcu(ctx, rcu_head);\n}\n\nvoid put_nfs_open_context(struct nfs_open_context *ctx)\n{\n\t__put_nfs_open_context(ctx, 0);\n}\nEXPORT_SYMBOL_GPL(put_nfs_open_context);\n\nstatic void put_nfs_open_context_sync(struct nfs_open_context *ctx)\n{\n\t__put_nfs_open_context(ctx, 1);\n}\n\n \nvoid nfs_inode_attach_open_context(struct nfs_open_context *ctx)\n{\n\tstruct inode *inode = d_inode(ctx->dentry);\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\tspin_lock(&inode->i_lock);\n\tif (list_empty(&nfsi->open_files) &&\n\t    nfs_ooo_test(nfsi))\n\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_DATA |\n\t\t\t\t\t\t     NFS_INO_REVAL_FORCED);\n\tlist_add_tail_rcu(&ctx->list, &nfsi->open_files);\n\tspin_unlock(&inode->i_lock);\n}\nEXPORT_SYMBOL_GPL(nfs_inode_attach_open_context);\n\nvoid nfs_file_set_open_context(struct file *filp, struct nfs_open_context *ctx)\n{\n\tfilp->private_data = get_nfs_open_context(ctx);\n\tset_bit(NFS_CONTEXT_FILE_OPEN, &ctx->flags);\n\tif (list_empty(&ctx->list))\n\t\tnfs_inode_attach_open_context(ctx);\n}\nEXPORT_SYMBOL_GPL(nfs_file_set_open_context);\n\n \nstruct nfs_open_context *nfs_find_open_context(struct inode *inode, const struct cred *cred, fmode_t mode)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs_open_context *pos, *ctx = NULL;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(pos, &nfsi->open_files, list) {\n\t\tif (cred != NULL && cred_fscmp(pos->cred, cred) != 0)\n\t\t\tcontinue;\n\t\tif ((pos->mode & (FMODE_READ|FMODE_WRITE)) != mode)\n\t\t\tcontinue;\n\t\tif (!test_bit(NFS_CONTEXT_FILE_OPEN, &pos->flags))\n\t\t\tcontinue;\n\t\tctx = get_nfs_open_context(pos);\n\t\tif (ctx)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\treturn ctx;\n}\n\nvoid nfs_file_clear_open_context(struct file *filp)\n{\n\tstruct nfs_open_context *ctx = nfs_file_open_context(filp);\n\n\tif (ctx) {\n\t\tstruct inode *inode = d_inode(ctx->dentry);\n\n\t\tclear_bit(NFS_CONTEXT_FILE_OPEN, &ctx->flags);\n\t\t \n\t\tif (ctx->error < 0)\n\t\t\tinvalidate_inode_pages2(inode->i_mapping);\n\t\tfilp->private_data = NULL;\n\t\tput_nfs_open_context_sync(ctx);\n\t}\n}\n\n \nint nfs_open(struct inode *inode, struct file *filp)\n{\n\tstruct nfs_open_context *ctx;\n\n\tctx = alloc_nfs_open_context(file_dentry(filp),\n\t\t\t\t     flags_to_mode(filp->f_flags), filp);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\tnfs_file_set_open_context(filp, ctx);\n\tput_nfs_open_context(ctx);\n\tnfs_fscache_open_file(inode, filp);\n\treturn 0;\n}\n\n \nint\n__nfs_revalidate_inode(struct nfs_server *server, struct inode *inode)\n{\n\tint\t\t status = -ESTALE;\n\tstruct nfs_fattr *fattr = NULL;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\tdfprintk(PAGECACHE, \"NFS: revalidating (%s/%Lu)\\n\",\n\t\tinode->i_sb->s_id, (unsigned long long)NFS_FILEID(inode));\n\n\ttrace_nfs_revalidate_inode_enter(inode);\n\n\tif (is_bad_inode(inode))\n\t\tgoto out;\n\tif (NFS_STALE(inode))\n\t\tgoto out;\n\n\t \n\tif (S_ISREG(inode->i_mode)) {\n\t\tstatus = pnfs_sync_inode(inode, false);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\tstatus = -ENOMEM;\n\tfattr = nfs_alloc_fattr_with_label(NFS_SERVER(inode));\n\tif (fattr == NULL)\n\t\tgoto out;\n\n\tnfs_inc_stats(inode, NFSIOS_INODEREVALIDATE);\n\n\tstatus = NFS_PROTO(inode)->getattr(server, NFS_FH(inode), fattr, inode);\n\tif (status != 0) {\n\t\tdfprintk(PAGECACHE, \"nfs_revalidate_inode: (%s/%Lu) getattr failed, error=%d\\n\",\n\t\t\t inode->i_sb->s_id,\n\t\t\t (unsigned long long)NFS_FILEID(inode), status);\n\t\tswitch (status) {\n\t\tcase -ETIMEDOUT:\n\t\t\t \n\t\t\tif (server->flags & NFS_MOUNT_SOFTREVAL)\n\t\t\t\tstatus = 0;\n\t\t\tbreak;\n\t\tcase -ESTALE:\n\t\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\t\tnfs_set_inode_stale(inode);\n\t\t\telse\n\t\t\t\tnfs_zap_caches(inode);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tstatus = nfs_refresh_inode(inode, fattr);\n\tif (status) {\n\t\tdfprintk(PAGECACHE, \"nfs_revalidate_inode: (%s/%Lu) refresh failed, error=%d\\n\",\n\t\t\t inode->i_sb->s_id,\n\t\t\t (unsigned long long)NFS_FILEID(inode), status);\n\t\tgoto out;\n\t}\n\n\tif (nfsi->cache_validity & NFS_INO_INVALID_ACL)\n\t\tnfs_zap_acl_cache(inode);\n\n\tnfs_setsecurity(inode, fattr);\n\n\tdfprintk(PAGECACHE, \"NFS: (%s/%Lu) revalidation complete\\n\",\n\t\tinode->i_sb->s_id,\n\t\t(unsigned long long)NFS_FILEID(inode));\n\nout:\n\tnfs_free_fattr(fattr);\n\ttrace_nfs_revalidate_inode_exit(inode, status);\n\treturn status;\n}\n\nint nfs_attribute_cache_expired(struct inode *inode)\n{\n\tif (nfs_have_delegated_attributes(inode))\n\t\treturn 0;\n\treturn nfs_attribute_timeout(inode);\n}\n\n \nint nfs_revalidate_inode(struct inode *inode, unsigned long flags)\n{\n\tif (!nfs_check_cache_invalid(inode, flags))\n\t\treturn NFS_STALE(inode) ? -ESTALE : 0;\n\treturn __nfs_revalidate_inode(NFS_SERVER(inode), inode);\n}\nEXPORT_SYMBOL_GPL(nfs_revalidate_inode);\n\nstatic int nfs_invalidate_mapping(struct inode *inode, struct address_space *mapping)\n{\n\tint ret;\n\n\tnfs_fscache_invalidate(inode, 0);\n\tif (mapping->nrpages != 0) {\n\t\tif (S_ISREG(inode->i_mode)) {\n\t\t\tret = nfs_sync_mapping(mapping);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t\tret = invalidate_inode_pages2(mapping);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\tnfs_inc_stats(inode, NFSIOS_DATAINVALIDATE);\n\n\tdfprintk(PAGECACHE, \"NFS: (%s/%Lu) data cache invalidated\\n\",\n\t\t\tinode->i_sb->s_id,\n\t\t\t(unsigned long long)NFS_FILEID(inode));\n\treturn 0;\n}\n\n \nint nfs_clear_invalid_mapping(struct address_space *mapping)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tunsigned long *bitlock = &nfsi->flags;\n\tint ret = 0;\n\n\t \n\tfor (;;) {\n\t\tret = wait_on_bit_action(bitlock, NFS_INO_INVALIDATING,\n\t\t\t\t\t nfs_wait_bit_killable,\n\t\t\t\t\t TASK_KILLABLE|TASK_FREEZABLE_UNSAFE);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tspin_lock(&inode->i_lock);\n\t\tif (test_bit(NFS_INO_INVALIDATING, bitlock)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tif (nfsi->cache_validity & NFS_INO_INVALID_DATA)\n\t\t\tbreak;\n\t\tspin_unlock(&inode->i_lock);\n\t\tgoto out;\n\t}\n\n\tset_bit(NFS_INO_INVALIDATING, bitlock);\n\tsmp_wmb();\n\tnfsi->cache_validity &= ~NFS_INO_INVALID_DATA;\n\tnfs_ooo_clear(nfsi);\n\tspin_unlock(&inode->i_lock);\n\ttrace_nfs_invalidate_mapping_enter(inode);\n\tret = nfs_invalidate_mapping(inode, mapping);\n\ttrace_nfs_invalidate_mapping_exit(inode, ret);\n\n\tclear_bit_unlock(NFS_INO_INVALIDATING, bitlock);\n\tsmp_mb__after_atomic();\n\twake_up_bit(bitlock, NFS_INO_INVALIDATING);\nout:\n\treturn ret;\n}\n\nbool nfs_mapping_need_revalidate_inode(struct inode *inode)\n{\n\treturn nfs_check_cache_invalid(inode, NFS_INO_INVALID_CHANGE) ||\n\t\tNFS_STALE(inode);\n}\n\nint nfs_revalidate_mapping_rcu(struct inode *inode)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tunsigned long *bitlock = &nfsi->flags;\n\tint ret = 0;\n\n\tif (IS_SWAPFILE(inode))\n\t\tgoto out;\n\tif (nfs_mapping_need_revalidate_inode(inode)) {\n\t\tret = -ECHILD;\n\t\tgoto out;\n\t}\n\tspin_lock(&inode->i_lock);\n\tif (test_bit(NFS_INO_INVALIDATING, bitlock) ||\n\t    (nfsi->cache_validity & NFS_INO_INVALID_DATA))\n\t\tret = -ECHILD;\n\tspin_unlock(&inode->i_lock);\nout:\n\treturn ret;\n}\n\n \nint nfs_revalidate_mapping(struct inode *inode, struct address_space *mapping)\n{\n\t \n\tif (IS_SWAPFILE(inode))\n\t\treturn 0;\n\n\tif (nfs_mapping_need_revalidate_inode(inode)) {\n\t\tint ret = __nfs_revalidate_inode(NFS_SERVER(inode), inode);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn nfs_clear_invalid_mapping(mapping);\n}\n\nstatic bool nfs_file_has_writers(struct nfs_inode *nfsi)\n{\n\tstruct inode *inode = &nfsi->vfs_inode;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn false;\n\tif (list_empty(&nfsi->open_files))\n\t\treturn false;\n\treturn inode_is_open_for_write(inode);\n}\n\nstatic bool nfs_file_has_buffered_writers(struct nfs_inode *nfsi)\n{\n\treturn nfs_file_has_writers(nfsi) && nfs_file_io_is_buffered(nfsi);\n}\n\nstatic void nfs_wcc_update_inode(struct inode *inode, struct nfs_fattr *fattr)\n{\n\tstruct timespec64 ts;\n\n\tif ((fattr->valid & NFS_ATTR_FATTR_PRECHANGE)\n\t\t\t&& (fattr->valid & NFS_ATTR_FATTR_CHANGE)\n\t\t\t&& inode_eq_iversion_raw(inode, fattr->pre_change_attr)) {\n\t\tinode_set_iversion_raw(inode, fattr->change_attr);\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_DATA);\n\t\telse if (nfs_server_capable(inode, NFS_CAP_XATTR))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_XATTR);\n\t}\n\t \n\tts = inode_get_ctime(inode);\n\tif ((fattr->valid & NFS_ATTR_FATTR_PRECTIME)\n\t\t\t&& (fattr->valid & NFS_ATTR_FATTR_CTIME)\n\t\t\t&& timespec64_equal(&ts, &fattr->pre_ctime)) {\n\t\tinode_set_ctime_to_ts(inode, fattr->ctime);\n\t}\n\n\tts = inode->i_mtime;\n\tif ((fattr->valid & NFS_ATTR_FATTR_PREMTIME)\n\t\t\t&& (fattr->valid & NFS_ATTR_FATTR_MTIME)\n\t\t\t&& timespec64_equal(&ts, &fattr->pre_mtime)) {\n\t\tinode->i_mtime = fattr->mtime;\n\t}\n\tif ((fattr->valid & NFS_ATTR_FATTR_PRESIZE)\n\t\t\t&& (fattr->valid & NFS_ATTR_FATTR_SIZE)\n\t\t\t&& i_size_read(inode) == nfs_size_to_loff_t(fattr->pre_size)\n\t\t\t&& !nfs_have_writebacks(inode)) {\n\t\ttrace_nfs_size_wcc(inode, fattr->size);\n\t\ti_size_write(inode, nfs_size_to_loff_t(fattr->size));\n\t}\n}\n\n \nstatic int nfs_check_inode_attributes(struct inode *inode, struct nfs_fattr *fattr)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tloff_t cur_size, new_isize;\n\tunsigned long invalid = 0;\n\tstruct timespec64 ts;\n\n\tif (NFS_PROTO(inode)->have_delegation(inode, FMODE_READ))\n\t\treturn 0;\n\n\tif (!(fattr->valid & NFS_ATTR_FATTR_FILEID)) {\n\t\t \n\t\tif (fattr->valid & NFS_ATTR_FATTR_MOUNTED_ON_FILEID)\n\t\t\treturn 0;\n\t \n\t} else if (nfsi->fileid != fattr->fileid) {\n\t\t \n\t\tif ((fattr->valid & NFS_ATTR_FATTR_MOUNTED_ON_FILEID) &&\n\t\t    nfsi->fileid == fattr->mounted_on_fileid)\n\t\t\treturn 0;\n\t\treturn -ESTALE;\n\t}\n\tif ((fattr->valid & NFS_ATTR_FATTR_TYPE) && inode_wrong_type(inode, fattr->mode))\n\t\treturn -ESTALE;\n\n\n\tif (!nfs_file_has_buffered_writers(nfsi)) {\n\t\t \n\t\tif ((fattr->valid & NFS_ATTR_FATTR_CHANGE) != 0 && !inode_eq_iversion_raw(inode, fattr->change_attr))\n\t\t\tinvalid |= NFS_INO_INVALID_CHANGE;\n\n\t\tts = inode->i_mtime;\n\t\tif ((fattr->valid & NFS_ATTR_FATTR_MTIME) && !timespec64_equal(&ts, &fattr->mtime))\n\t\t\tinvalid |= NFS_INO_INVALID_MTIME;\n\n\t\tts = inode_get_ctime(inode);\n\t\tif ((fattr->valid & NFS_ATTR_FATTR_CTIME) && !timespec64_equal(&ts, &fattr->ctime))\n\t\t\tinvalid |= NFS_INO_INVALID_CTIME;\n\n\t\tif (fattr->valid & NFS_ATTR_FATTR_SIZE) {\n\t\t\tcur_size = i_size_read(inode);\n\t\t\tnew_isize = nfs_size_to_loff_t(fattr->size);\n\t\t\tif (cur_size != new_isize)\n\t\t\t\tinvalid |= NFS_INO_INVALID_SIZE;\n\t\t}\n\t}\n\n\t \n\tif ((fattr->valid & NFS_ATTR_FATTR_MODE) && (inode->i_mode & S_IALLUGO) != (fattr->mode & S_IALLUGO))\n\t\tinvalid |= NFS_INO_INVALID_MODE;\n\tif ((fattr->valid & NFS_ATTR_FATTR_OWNER) && !uid_eq(inode->i_uid, fattr->uid))\n\t\tinvalid |= NFS_INO_INVALID_OTHER;\n\tif ((fattr->valid & NFS_ATTR_FATTR_GROUP) && !gid_eq(inode->i_gid, fattr->gid))\n\t\tinvalid |= NFS_INO_INVALID_OTHER;\n\n\t \n\tif ((fattr->valid & NFS_ATTR_FATTR_NLINK) && inode->i_nlink != fattr->nlink)\n\t\tinvalid |= NFS_INO_INVALID_NLINK;\n\n\tts = inode->i_atime;\n\tif ((fattr->valid & NFS_ATTR_FATTR_ATIME) && !timespec64_equal(&ts, &fattr->atime))\n\t\tinvalid |= NFS_INO_INVALID_ATIME;\n\n\tif (invalid != 0)\n\t\tnfs_set_cache_invalid(inode, invalid);\n\n\tnfsi->read_cache_jiffies = fattr->time_start;\n\treturn 0;\n}\n\nstatic atomic_long_t nfs_attr_generation_counter;\n\nstatic unsigned long nfs_read_attr_generation_counter(void)\n{\n\treturn atomic_long_read(&nfs_attr_generation_counter);\n}\n\nunsigned long nfs_inc_attr_generation_counter(void)\n{\n\treturn atomic_long_inc_return(&nfs_attr_generation_counter);\n}\nEXPORT_SYMBOL_GPL(nfs_inc_attr_generation_counter);\n\nvoid nfs_fattr_init(struct nfs_fattr *fattr)\n{\n\tfattr->valid = 0;\n\tfattr->time_start = jiffies;\n\tfattr->gencount = nfs_inc_attr_generation_counter();\n\tfattr->owner_name = NULL;\n\tfattr->group_name = NULL;\n}\nEXPORT_SYMBOL_GPL(nfs_fattr_init);\n\n \nvoid nfs_fattr_set_barrier(struct nfs_fattr *fattr)\n{\n\tfattr->gencount = nfs_inc_attr_generation_counter();\n}\n\nstruct nfs_fattr *nfs_alloc_fattr(void)\n{\n\tstruct nfs_fattr *fattr;\n\n\tfattr = kmalloc(sizeof(*fattr), GFP_KERNEL);\n\tif (fattr != NULL) {\n\t\tnfs_fattr_init(fattr);\n\t\tfattr->label = NULL;\n\t}\n\treturn fattr;\n}\nEXPORT_SYMBOL_GPL(nfs_alloc_fattr);\n\nstruct nfs_fattr *nfs_alloc_fattr_with_label(struct nfs_server *server)\n{\n\tstruct nfs_fattr *fattr = nfs_alloc_fattr();\n\n\tif (!fattr)\n\t\treturn NULL;\n\n\tfattr->label = nfs4_label_alloc(server, GFP_KERNEL);\n\tif (IS_ERR(fattr->label)) {\n\t\tkfree(fattr);\n\t\treturn NULL;\n\t}\n\n\treturn fattr;\n}\nEXPORT_SYMBOL_GPL(nfs_alloc_fattr_with_label);\n\nstruct nfs_fh *nfs_alloc_fhandle(void)\n{\n\tstruct nfs_fh *fh;\n\n\tfh = kmalloc(sizeof(struct nfs_fh), GFP_KERNEL);\n\tif (fh != NULL)\n\t\tfh->size = 0;\n\treturn fh;\n}\nEXPORT_SYMBOL_GPL(nfs_alloc_fhandle);\n\n#ifdef NFS_DEBUG\n \nu32 _nfs_display_fhandle_hash(const struct nfs_fh *fh)\n{\n\t \n\treturn nfs_fhandle_hash(fh);\n}\nEXPORT_SYMBOL_GPL(_nfs_display_fhandle_hash);\n\n \nvoid _nfs_display_fhandle(const struct nfs_fh *fh, const char *caption)\n{\n\tunsigned short i;\n\n\tif (fh == NULL || fh->size == 0) {\n\t\tprintk(KERN_DEFAULT \"%s at %p is empty\\n\", caption, fh);\n\t\treturn;\n\t}\n\n\tprintk(KERN_DEFAULT \"%s at %p is %u bytes, crc: 0x%08x:\\n\",\n\t       caption, fh, fh->size, _nfs_display_fhandle_hash(fh));\n\tfor (i = 0; i < fh->size; i += 16) {\n\t\t__be32 *pos = (__be32 *)&fh->data[i];\n\n\t\tswitch ((fh->size - i - 1) >> 2) {\n\t\tcase 0:\n\t\t\tprintk(KERN_DEFAULT \" %08x\\n\",\n\t\t\t\tbe32_to_cpup(pos));\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tprintk(KERN_DEFAULT \" %08x %08x\\n\",\n\t\t\t\tbe32_to_cpup(pos), be32_to_cpup(pos + 1));\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tprintk(KERN_DEFAULT \" %08x %08x %08x\\n\",\n\t\t\t\tbe32_to_cpup(pos), be32_to_cpup(pos + 1),\n\t\t\t\tbe32_to_cpup(pos + 2));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_DEFAULT \" %08x %08x %08x %08x\\n\",\n\t\t\t\tbe32_to_cpup(pos), be32_to_cpup(pos + 1),\n\t\t\t\tbe32_to_cpup(pos + 2), be32_to_cpup(pos + 3));\n\t\t}\n\t}\n}\nEXPORT_SYMBOL_GPL(_nfs_display_fhandle);\n#endif\n\n \nstatic int nfs_inode_attrs_cmp_generic(const struct nfs_fattr *fattr,\n\t\t\t\t       const struct inode *inode)\n{\n\tunsigned long attr_gencount = NFS_I(inode)->attr_gencount;\n\n\treturn (long)(fattr->gencount - attr_gencount) > 0 ||\n\t       (long)(attr_gencount - nfs_read_attr_generation_counter()) > 0;\n}\n\n \nstatic int nfs_inode_attrs_cmp_monotonic(const struct nfs_fattr *fattr,\n\t\t\t\t\t const struct inode *inode)\n{\n\ts64 diff = fattr->change_attr - inode_peek_iversion_raw(inode);\n\tif (diff > 0)\n\t\treturn 1;\n\treturn diff == 0 ? 0 : -1;\n}\n\n \nstatic int nfs_inode_attrs_cmp_strict_monotonic(const struct nfs_fattr *fattr,\n\t\t\t\t\t\tconst struct inode *inode)\n{\n\treturn  nfs_inode_attrs_cmp_monotonic(fattr, inode) > 0 ? 1 : -1;\n}\n\n \nstatic int nfs_inode_attrs_cmp(const struct nfs_fattr *fattr,\n\t\t\t       const struct inode *inode)\n{\n\tif (nfs_inode_attrs_cmp_generic(fattr, inode) > 0)\n\t\treturn 1;\n\tswitch (NFS_SERVER(inode)->change_attr_type) {\n\tcase NFS4_CHANGE_TYPE_IS_UNDEFINED:\n\t\tbreak;\n\tcase NFS4_CHANGE_TYPE_IS_TIME_METADATA:\n\t\tif (!(fattr->valid & NFS_ATTR_FATTR_CHANGE))\n\t\t\tbreak;\n\t\treturn nfs_inode_attrs_cmp_monotonic(fattr, inode);\n\tdefault:\n\t\tif (!(fattr->valid & NFS_ATTR_FATTR_CHANGE))\n\t\t\tbreak;\n\t\treturn nfs_inode_attrs_cmp_strict_monotonic(fattr, inode);\n\t}\n\treturn 0;\n}\n\n \nstatic int nfs_inode_finish_partial_attr_update(const struct nfs_fattr *fattr,\n\t\t\t\t\t\tconst struct inode *inode)\n{\n\tconst unsigned long check_valid =\n\t\tNFS_INO_INVALID_ATIME | NFS_INO_INVALID_CTIME |\n\t\tNFS_INO_INVALID_MTIME | NFS_INO_INVALID_SIZE |\n\t\tNFS_INO_INVALID_BLOCKS | NFS_INO_INVALID_OTHER |\n\t\tNFS_INO_INVALID_NLINK;\n\tunsigned long cache_validity = NFS_I(inode)->cache_validity;\n\tenum nfs4_change_attr_type ctype = NFS_SERVER(inode)->change_attr_type;\n\n\tif (ctype != NFS4_CHANGE_TYPE_IS_UNDEFINED &&\n\t    !(cache_validity & NFS_INO_INVALID_CHANGE) &&\n\t    (cache_validity & check_valid) != 0 &&\n\t    (fattr->valid & NFS_ATTR_FATTR_CHANGE) != 0 &&\n\t    nfs_inode_attrs_cmp_monotonic(fattr, inode) == 0)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic void nfs_ooo_merge(struct nfs_inode *nfsi,\n\t\t\t  u64 start, u64 end)\n{\n\tint i, cnt;\n\n\tif (nfsi->cache_validity & NFS_INO_DATA_INVAL_DEFER)\n\t\t \n\t\treturn;\n\n\tif (!nfsi->ooo) {\n\t\tnfsi->ooo = kmalloc(sizeof(*nfsi->ooo), GFP_ATOMIC);\n\t\tif (!nfsi->ooo) {\n\t\t\tnfsi->cache_validity |= NFS_INO_DATA_INVAL_DEFER;\n\t\t\treturn;\n\t\t}\n\t\tnfsi->ooo->cnt = 0;\n\t}\n\n\t \n\tcnt = nfsi->ooo->cnt;\n\tfor (i = 0; i < cnt; i++) {\n\t\tif (end == nfsi->ooo->gap[i].start)\n\t\t\tend = nfsi->ooo->gap[i].end;\n\t\telse if (start == nfsi->ooo->gap[i].end)\n\t\t\tstart = nfsi->ooo->gap[i].start;\n\t\telse\n\t\t\tcontinue;\n\t\t \n\t\tcnt -= 1;\n\t\tnfsi->ooo->gap[i] = nfsi->ooo->gap[cnt];\n\t\ti = -1;\n\t}\n\tif (start != end) {\n\t\tif (cnt >= ARRAY_SIZE(nfsi->ooo->gap)) {\n\t\t\tnfsi->cache_validity |= NFS_INO_DATA_INVAL_DEFER;\n\t\t\tkfree(nfsi->ooo);\n\t\t\tnfsi->ooo = NULL;\n\t\t\treturn;\n\t\t}\n\t\tnfsi->ooo->gap[cnt].start = start;\n\t\tnfsi->ooo->gap[cnt].end = end;\n\t\tcnt += 1;\n\t}\n\tnfsi->ooo->cnt = cnt;\n}\n\nstatic void nfs_ooo_record(struct nfs_inode *nfsi,\n\t\t\t   struct nfs_fattr *fattr)\n{\n\t \n\tif ((fattr->valid & NFS_ATTR_FATTR_CHANGE) &&\n\t    (fattr->valid & NFS_ATTR_FATTR_PRECHANGE))\n\t\tnfs_ooo_merge(nfsi,\n\t\t\t      fattr->change_attr,\n\t\t\t      fattr->pre_change_attr);\n}\n\nstatic int nfs_refresh_inode_locked(struct inode *inode,\n\t\t\t\t    struct nfs_fattr *fattr)\n{\n\tint attr_cmp = nfs_inode_attrs_cmp(fattr, inode);\n\tint ret = 0;\n\n\ttrace_nfs_refresh_inode_enter(inode);\n\n\tif (attr_cmp > 0 || nfs_inode_finish_partial_attr_update(fattr, inode))\n\t\tret = nfs_update_inode(inode, fattr);\n\telse {\n\t\tnfs_ooo_record(NFS_I(inode), fattr);\n\n\t\tif (attr_cmp == 0)\n\t\t\tret = nfs_check_inode_attributes(inode, fattr);\n\t}\n\n\ttrace_nfs_refresh_inode_exit(inode, ret);\n\treturn ret;\n}\n\n \nint nfs_refresh_inode(struct inode *inode, struct nfs_fattr *fattr)\n{\n\tint status;\n\n\tif ((fattr->valid & NFS_ATTR_FATTR) == 0)\n\t\treturn 0;\n\tspin_lock(&inode->i_lock);\n\tstatus = nfs_refresh_inode_locked(inode, fattr);\n\tspin_unlock(&inode->i_lock);\n\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(nfs_refresh_inode);\n\nstatic int nfs_post_op_update_inode_locked(struct inode *inode,\n\t\tstruct nfs_fattr *fattr, unsigned int invalid)\n{\n\tif (S_ISDIR(inode->i_mode))\n\t\tinvalid |= NFS_INO_INVALID_DATA;\n\tnfs_set_cache_invalid(inode, invalid);\n\tif ((fattr->valid & NFS_ATTR_FATTR) == 0)\n\t\treturn 0;\n\treturn nfs_refresh_inode_locked(inode, fattr);\n}\n\n \nint nfs_post_op_update_inode(struct inode *inode, struct nfs_fattr *fattr)\n{\n\tint status;\n\n\tspin_lock(&inode->i_lock);\n\tnfs_fattr_set_barrier(fattr);\n\tstatus = nfs_post_op_update_inode_locked(inode, fattr,\n\t\t\tNFS_INO_INVALID_CHANGE\n\t\t\t| NFS_INO_INVALID_CTIME\n\t\t\t| NFS_INO_REVAL_FORCED);\n\tspin_unlock(&inode->i_lock);\n\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(nfs_post_op_update_inode);\n\n \nint nfs_post_op_update_inode_force_wcc_locked(struct inode *inode, struct nfs_fattr *fattr)\n{\n\tint attr_cmp = nfs_inode_attrs_cmp(fattr, inode);\n\tint status;\n\n\t \n\tif (attr_cmp < 0)\n\t\treturn 0;\n\tif ((fattr->valid & NFS_ATTR_FATTR) == 0 || !attr_cmp) {\n\t\t \n\t\tnfs_ooo_record(NFS_I(inode), fattr);\n\t\tfattr->valid &= ~(NFS_ATTR_FATTR_PRECHANGE\n\t\t\t\t| NFS_ATTR_FATTR_PRESIZE\n\t\t\t\t| NFS_ATTR_FATTR_PREMTIME\n\t\t\t\t| NFS_ATTR_FATTR_PRECTIME);\n\t\tgoto out_noforce;\n\t}\n\tif ((fattr->valid & NFS_ATTR_FATTR_CHANGE) != 0 &&\n\t\t\t(fattr->valid & NFS_ATTR_FATTR_PRECHANGE) == 0) {\n\t\tfattr->pre_change_attr = inode_peek_iversion_raw(inode);\n\t\tfattr->valid |= NFS_ATTR_FATTR_PRECHANGE;\n\t}\n\tif ((fattr->valid & NFS_ATTR_FATTR_CTIME) != 0 &&\n\t\t\t(fattr->valid & NFS_ATTR_FATTR_PRECTIME) == 0) {\n\t\tfattr->pre_ctime = inode_get_ctime(inode);\n\t\tfattr->valid |= NFS_ATTR_FATTR_PRECTIME;\n\t}\n\tif ((fattr->valid & NFS_ATTR_FATTR_MTIME) != 0 &&\n\t\t\t(fattr->valid & NFS_ATTR_FATTR_PREMTIME) == 0) {\n\t\tfattr->pre_mtime = inode->i_mtime;\n\t\tfattr->valid |= NFS_ATTR_FATTR_PREMTIME;\n\t}\n\tif ((fattr->valid & NFS_ATTR_FATTR_SIZE) != 0 &&\n\t\t\t(fattr->valid & NFS_ATTR_FATTR_PRESIZE) == 0) {\n\t\tfattr->pre_size = i_size_read(inode);\n\t\tfattr->valid |= NFS_ATTR_FATTR_PRESIZE;\n\t}\nout_noforce:\n\tstatus = nfs_post_op_update_inode_locked(inode, fattr,\n\t\t\tNFS_INO_INVALID_CHANGE\n\t\t\t| NFS_INO_INVALID_CTIME\n\t\t\t| NFS_INO_INVALID_MTIME\n\t\t\t| NFS_INO_INVALID_BLOCKS);\n\treturn status;\n}\n\n \nint nfs_post_op_update_inode_force_wcc(struct inode *inode, struct nfs_fattr *fattr)\n{\n\tint status;\n\n\tspin_lock(&inode->i_lock);\n\tnfs_fattr_set_barrier(fattr);\n\tstatus = nfs_post_op_update_inode_force_wcc_locked(inode, fattr);\n\tspin_unlock(&inode->i_lock);\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(nfs_post_op_update_inode_force_wcc);\n\n\n \nstatic int nfs_update_inode(struct inode *inode, struct nfs_fattr *fattr)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tloff_t cur_isize, new_isize;\n\tu64 fattr_supported = server->fattr_valid;\n\tunsigned long invalid = 0;\n\tunsigned long now = jiffies;\n\tunsigned long save_cache_validity;\n\tbool have_writers = nfs_file_has_buffered_writers(nfsi);\n\tbool cache_revalidated = true;\n\tbool attr_changed = false;\n\tbool have_delegation;\n\n\tdfprintk(VFS, \"NFS: %s(%s/%lu fh_crc=0x%08x ct=%d info=0x%x)\\n\",\n\t\t\t__func__, inode->i_sb->s_id, inode->i_ino,\n\t\t\tnfs_display_fhandle_hash(NFS_FH(inode)),\n\t\t\tatomic_read(&inode->i_count), fattr->valid);\n\n\tif (!(fattr->valid & NFS_ATTR_FATTR_FILEID)) {\n\t\t \n\t\tif (fattr->valid & NFS_ATTR_FATTR_MOUNTED_ON_FILEID)\n\t\t\treturn 0;\n\t \n\t} else if (nfsi->fileid != fattr->fileid) {\n\t\t \n\t\tif ((fattr->valid & NFS_ATTR_FATTR_MOUNTED_ON_FILEID) &&\n\t\t    nfsi->fileid == fattr->mounted_on_fileid)\n\t\t\treturn 0;\n\t\tprintk(KERN_ERR \"NFS: server %s error: fileid changed\\n\"\n\t\t\t\"fsid %s: expected fileid 0x%Lx, got 0x%Lx\\n\",\n\t\t\tNFS_SERVER(inode)->nfs_client->cl_hostname,\n\t\t\tinode->i_sb->s_id, (long long)nfsi->fileid,\n\t\t\t(long long)fattr->fileid);\n\t\tgoto out_err;\n\t}\n\n\t \n\tif ((fattr->valid & NFS_ATTR_FATTR_TYPE) && inode_wrong_type(inode, fattr->mode)) {\n\t\t \n\t\tprintk(KERN_DEBUG \"NFS: %s: inode %lu mode changed, %07o to %07o\\n\",\n\t\t\t\t__func__, inode->i_ino, inode->i_mode, fattr->mode);\n\t\tgoto out_err;\n\t}\n\n\t \n\tif (S_ISDIR(inode->i_mode) && (fattr->valid & NFS_ATTR_FATTR_FSID) &&\n\t\t\t!nfs_fsid_equal(&server->fsid, &fattr->fsid) &&\n\t\t\t!IS_AUTOMOUNT(inode))\n\t\tserver->fsid = fattr->fsid;\n\n\t \n\thave_delegation = nfs_have_delegated_attributes(inode);\n\n\t \n\tnfsi->read_cache_jiffies = fattr->time_start;\n\n\tsave_cache_validity = nfsi->cache_validity;\n\tnfsi->cache_validity &= ~(NFS_INO_INVALID_ATTR\n\t\t\t| NFS_INO_INVALID_ATIME\n\t\t\t| NFS_INO_REVAL_FORCED\n\t\t\t| NFS_INO_INVALID_BLOCKS);\n\n\t \n\tnfs_wcc_update_inode(inode, fattr);\n\n\tif (pnfs_layoutcommit_outstanding(inode)) {\n\t\tnfsi->cache_validity |=\n\t\t\tsave_cache_validity &\n\t\t\t(NFS_INO_INVALID_CHANGE | NFS_INO_INVALID_CTIME |\n\t\t\t NFS_INO_INVALID_MTIME | NFS_INO_INVALID_SIZE |\n\t\t\t NFS_INO_INVALID_BLOCKS);\n\t\tcache_revalidated = false;\n\t}\n\n\t \n\tif (fattr->valid & NFS_ATTR_FATTR_CHANGE) {\n\t\tif (!have_writers && nfsi->ooo && nfsi->ooo->cnt == 1 &&\n\t\t    nfsi->ooo->gap[0].end == inode_peek_iversion_raw(inode)) {\n\t\t\t \n\t\t\tinode_set_iversion_raw(inode, nfsi->ooo->gap[0].start);\n\t\t\tkfree(nfsi->ooo);\n\t\t\tnfsi->ooo = NULL;\n\t\t}\n\t\tif (!inode_eq_iversion_raw(inode, fattr->change_attr)) {\n\t\t\t \n\t\t\tif (!(have_writers || have_delegation)) {\n\t\t\t\tinvalid |= NFS_INO_INVALID_DATA\n\t\t\t\t\t| NFS_INO_INVALID_ACCESS\n\t\t\t\t\t| NFS_INO_INVALID_ACL\n\t\t\t\t\t| NFS_INO_INVALID_XATTR;\n\t\t\t\t \n\t\t\t\tsave_cache_validity |= NFS_INO_INVALID_CTIME\n\t\t\t\t\t| NFS_INO_INVALID_MTIME\n\t\t\t\t\t| NFS_INO_INVALID_SIZE\n\t\t\t\t\t| NFS_INO_INVALID_BLOCKS\n\t\t\t\t\t| NFS_INO_INVALID_NLINK\n\t\t\t\t\t| NFS_INO_INVALID_MODE\n\t\t\t\t\t| NFS_INO_INVALID_OTHER;\n\t\t\t\tif (S_ISDIR(inode->i_mode))\n\t\t\t\t\tnfs_force_lookup_revalidate(inode);\n\t\t\t\tattr_changed = true;\n\t\t\t\tdprintk(\"NFS: change_attr change on server for file %s/%ld\\n\",\n\t\t\t\t\t\tinode->i_sb->s_id,\n\t\t\t\t\t\tinode->i_ino);\n\t\t\t} else if (!have_delegation) {\n\t\t\t\tnfs_ooo_record(nfsi, fattr);\n\t\t\t\tnfs_ooo_merge(nfsi, inode_peek_iversion_raw(inode),\n\t\t\t\t\t      fattr->change_attr);\n\t\t\t}\n\t\t\tinode_set_iversion_raw(inode, fattr->change_attr);\n\t\t}\n\t} else {\n\t\tnfsi->cache_validity |=\n\t\t\tsave_cache_validity & NFS_INO_INVALID_CHANGE;\n\t\tif (!have_delegation ||\n\t\t    (nfsi->cache_validity & NFS_INO_INVALID_CHANGE) != 0)\n\t\t\tcache_revalidated = false;\n\t}\n\n\tif (fattr->valid & NFS_ATTR_FATTR_MTIME)\n\t\tinode->i_mtime = fattr->mtime;\n\telse if (fattr_supported & NFS_ATTR_FATTR_MTIME)\n\t\tnfsi->cache_validity |=\n\t\t\tsave_cache_validity & NFS_INO_INVALID_MTIME;\n\n\tif (fattr->valid & NFS_ATTR_FATTR_CTIME)\n\t\tinode_set_ctime_to_ts(inode, fattr->ctime);\n\telse if (fattr_supported & NFS_ATTR_FATTR_CTIME)\n\t\tnfsi->cache_validity |=\n\t\t\tsave_cache_validity & NFS_INO_INVALID_CTIME;\n\n\t \n\tif (fattr->valid & NFS_ATTR_FATTR_SIZE) {\n\t\tnew_isize = nfs_size_to_loff_t(fattr->size);\n\t\tcur_isize = i_size_read(inode);\n\t\tif (new_isize != cur_isize && !have_delegation) {\n\t\t\t \n\t\t\tif (!nfs_have_writebacks(inode) || new_isize > cur_isize) {\n\t\t\t\ttrace_nfs_size_update(inode, new_isize);\n\t\t\t\ti_size_write(inode, new_isize);\n\t\t\t\tif (!have_writers)\n\t\t\t\t\tinvalid |= NFS_INO_INVALID_DATA;\n\t\t\t}\n\t\t}\n\t\tif (new_isize == 0 &&\n\t\t    !(fattr->valid & (NFS_ATTR_FATTR_SPACE_USED |\n\t\t\t\t      NFS_ATTR_FATTR_BLOCKS_USED))) {\n\t\t\tfattr->du.nfs3.used = 0;\n\t\t\tfattr->valid |= NFS_ATTR_FATTR_SPACE_USED;\n\t\t}\n\t} else\n\t\tnfsi->cache_validity |=\n\t\t\tsave_cache_validity & NFS_INO_INVALID_SIZE;\n\n\tif (fattr->valid & NFS_ATTR_FATTR_ATIME)\n\t\tinode->i_atime = fattr->atime;\n\telse if (fattr_supported & NFS_ATTR_FATTR_ATIME)\n\t\tnfsi->cache_validity |=\n\t\t\tsave_cache_validity & NFS_INO_INVALID_ATIME;\n\n\tif (fattr->valid & NFS_ATTR_FATTR_MODE) {\n\t\tif ((inode->i_mode & S_IALLUGO) != (fattr->mode & S_IALLUGO)) {\n\t\t\tumode_t newmode = inode->i_mode & S_IFMT;\n\t\t\tnewmode |= fattr->mode & S_IALLUGO;\n\t\t\tinode->i_mode = newmode;\n\t\t\tinvalid |= NFS_INO_INVALID_ACCESS\n\t\t\t\t| NFS_INO_INVALID_ACL;\n\t\t}\n\t} else if (fattr_supported & NFS_ATTR_FATTR_MODE)\n\t\tnfsi->cache_validity |=\n\t\t\tsave_cache_validity & NFS_INO_INVALID_MODE;\n\n\tif (fattr->valid & NFS_ATTR_FATTR_OWNER) {\n\t\tif (!uid_eq(inode->i_uid, fattr->uid)) {\n\t\t\tinvalid |= NFS_INO_INVALID_ACCESS\n\t\t\t\t| NFS_INO_INVALID_ACL;\n\t\t\tinode->i_uid = fattr->uid;\n\t\t}\n\t} else if (fattr_supported & NFS_ATTR_FATTR_OWNER)\n\t\tnfsi->cache_validity |=\n\t\t\tsave_cache_validity & NFS_INO_INVALID_OTHER;\n\n\tif (fattr->valid & NFS_ATTR_FATTR_GROUP) {\n\t\tif (!gid_eq(inode->i_gid, fattr->gid)) {\n\t\t\tinvalid |= NFS_INO_INVALID_ACCESS\n\t\t\t\t| NFS_INO_INVALID_ACL;\n\t\t\tinode->i_gid = fattr->gid;\n\t\t}\n\t} else if (fattr_supported & NFS_ATTR_FATTR_GROUP)\n\t\tnfsi->cache_validity |=\n\t\t\tsave_cache_validity & NFS_INO_INVALID_OTHER;\n\n\tif (fattr->valid & NFS_ATTR_FATTR_NLINK) {\n\t\tif (inode->i_nlink != fattr->nlink)\n\t\t\tset_nlink(inode, fattr->nlink);\n\t} else if (fattr_supported & NFS_ATTR_FATTR_NLINK)\n\t\tnfsi->cache_validity |=\n\t\t\tsave_cache_validity & NFS_INO_INVALID_NLINK;\n\n\tif (fattr->valid & NFS_ATTR_FATTR_SPACE_USED) {\n\t\t \n\t\tinode->i_blocks = nfs_calc_block_size(fattr->du.nfs3.used);\n\t} else if (fattr_supported & NFS_ATTR_FATTR_SPACE_USED)\n\t\tnfsi->cache_validity |=\n\t\t\tsave_cache_validity & NFS_INO_INVALID_BLOCKS;\n\n\tif (fattr->valid & NFS_ATTR_FATTR_BLOCKS_USED)\n\t\tinode->i_blocks = fattr->du.nfs2.blocks;\n\telse if (fattr_supported & NFS_ATTR_FATTR_BLOCKS_USED)\n\t\tnfsi->cache_validity |=\n\t\t\tsave_cache_validity & NFS_INO_INVALID_BLOCKS;\n\n\t \n\tif (attr_changed) {\n\t\tnfs_inc_stats(inode, NFSIOS_ATTRINVALIDATE);\n\t\tnfsi->attrtimeo = NFS_MINATTRTIMEO(inode);\n\t\tnfsi->attrtimeo_timestamp = now;\n\t\t \n\t\tnfsi->attr_gencount = nfs_inc_attr_generation_counter();\n\t} else {\n\t\tif (cache_revalidated) {\n\t\t\tif (!time_in_range_open(now, nfsi->attrtimeo_timestamp,\n\t\t\t\tnfsi->attrtimeo_timestamp + nfsi->attrtimeo)) {\n\t\t\t\tnfsi->attrtimeo <<= 1;\n\t\t\t\tif (nfsi->attrtimeo > NFS_MAXATTRTIMEO(inode))\n\t\t\t\t\tnfsi->attrtimeo = NFS_MAXATTRTIMEO(inode);\n\t\t\t}\n\t\t\tnfsi->attrtimeo_timestamp = now;\n\t\t}\n\t\t \n\t\tif ((long)(fattr->gencount - nfsi->attr_gencount) > 0)\n\t\t\tnfsi->attr_gencount = fattr->gencount;\n\t}\n\n\t \n\tif (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode)\n\t\t\t\t|| S_ISLNK(inode->i_mode)))\n\t\tinvalid &= ~NFS_INO_INVALID_DATA;\n\tnfs_set_cache_invalid(inode, invalid);\n\n\treturn 0;\n out_err:\n\t \n\tnfs_set_inode_stale_locked(inode);\n\treturn -ESTALE;\n}\n\nstruct inode *nfs_alloc_inode(struct super_block *sb)\n{\n\tstruct nfs_inode *nfsi;\n\tnfsi = alloc_inode_sb(sb, nfs_inode_cachep, GFP_KERNEL);\n\tif (!nfsi)\n\t\treturn NULL;\n\tnfsi->flags = 0UL;\n\tnfsi->cache_validity = 0UL;\n\tnfsi->ooo = NULL;\n#if IS_ENABLED(CONFIG_NFS_V4)\n\tnfsi->nfs4_acl = NULL;\n#endif  \n#ifdef CONFIG_NFS_V4_2\n\tnfsi->xattr_cache = NULL;\n#endif\n\tnfs_netfs_inode_init(nfsi);\n\n\treturn &nfsi->vfs_inode;\n}\nEXPORT_SYMBOL_GPL(nfs_alloc_inode);\n\nvoid nfs_free_inode(struct inode *inode)\n{\n\tkfree(NFS_I(inode)->ooo);\n\tkmem_cache_free(nfs_inode_cachep, NFS_I(inode));\n}\nEXPORT_SYMBOL_GPL(nfs_free_inode);\n\nstatic inline void nfs4_init_once(struct nfs_inode *nfsi)\n{\n#if IS_ENABLED(CONFIG_NFS_V4)\n\tINIT_LIST_HEAD(&nfsi->open_states);\n\tnfsi->delegation = NULL;\n\tinit_rwsem(&nfsi->rwsem);\n\tnfsi->layout = NULL;\n#endif\n}\n\nstatic void init_once(void *foo)\n{\n\tstruct nfs_inode *nfsi = foo;\n\n\tinode_init_once(&nfsi->vfs_inode);\n\tINIT_LIST_HEAD(&nfsi->open_files);\n\tINIT_LIST_HEAD(&nfsi->access_cache_entry_lru);\n\tINIT_LIST_HEAD(&nfsi->access_cache_inode_lru);\n\tnfs4_init_once(nfsi);\n}\n\nstatic int __init nfs_init_inodecache(void)\n{\n\tnfs_inode_cachep = kmem_cache_create(\"nfs_inode_cache\",\n\t\t\t\t\t     sizeof(struct nfs_inode),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD|SLAB_ACCOUNT),\n\t\t\t\t\t     init_once);\n\tif (nfs_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void nfs_destroy_inodecache(void)\n{\n\t \n\trcu_barrier();\n\tkmem_cache_destroy(nfs_inode_cachep);\n}\n\nstruct workqueue_struct *nfsiod_workqueue;\nEXPORT_SYMBOL_GPL(nfsiod_workqueue);\n\n \nstatic int nfsiod_start(void)\n{\n\tstruct workqueue_struct *wq;\n\tdprintk(\"RPC:       creating workqueue nfsiod\\n\");\n\twq = alloc_workqueue(\"nfsiod\", WQ_MEM_RECLAIM | WQ_UNBOUND, 0);\n\tif (wq == NULL)\n\t\treturn -ENOMEM;\n\tnfsiod_workqueue = wq;\n\treturn 0;\n}\n\n \nstatic void nfsiod_stop(void)\n{\n\tstruct workqueue_struct *wq;\n\n\twq = nfsiod_workqueue;\n\tif (wq == NULL)\n\t\treturn;\n\tnfsiod_workqueue = NULL;\n\tdestroy_workqueue(wq);\n}\n\nunsigned int nfs_net_id;\nEXPORT_SYMBOL_GPL(nfs_net_id);\n\nstatic int nfs_net_init(struct net *net)\n{\n\tnfs_clients_init(net);\n\treturn nfs_fs_proc_net_init(net);\n}\n\nstatic void nfs_net_exit(struct net *net)\n{\n\tnfs_fs_proc_net_exit(net);\n\tnfs_clients_exit(net);\n}\n\nstatic struct pernet_operations nfs_net_ops = {\n\t.init = nfs_net_init,\n\t.exit = nfs_net_exit,\n\t.id   = &nfs_net_id,\n\t.size = sizeof(struct nfs_net),\n};\n\n \nstatic int __init init_nfs_fs(void)\n{\n\tint err;\n\n\terr = nfs_sysfs_init();\n\tif (err < 0)\n\t\tgoto out10;\n\n\terr = register_pernet_subsys(&nfs_net_ops);\n\tif (err < 0)\n\t\tgoto out9;\n\n\terr = nfsiod_start();\n\tif (err)\n\t\tgoto out7;\n\n\terr = nfs_fs_proc_init();\n\tif (err)\n\t\tgoto out6;\n\n\terr = nfs_init_nfspagecache();\n\tif (err)\n\t\tgoto out5;\n\n\terr = nfs_init_inodecache();\n\tif (err)\n\t\tgoto out4;\n\n\terr = nfs_init_readpagecache();\n\tif (err)\n\t\tgoto out3;\n\n\terr = nfs_init_writepagecache();\n\tif (err)\n\t\tgoto out2;\n\n\terr = nfs_init_directcache();\n\tif (err)\n\t\tgoto out1;\n\n\trpc_proc_register(&init_net, &nfs_rpcstat);\n\n\terr = register_nfs_fs();\n\tif (err)\n\t\tgoto out0;\n\n\treturn 0;\nout0:\n\trpc_proc_unregister(&init_net, \"nfs\");\n\tnfs_destroy_directcache();\nout1:\n\tnfs_destroy_writepagecache();\nout2:\n\tnfs_destroy_readpagecache();\nout3:\n\tnfs_destroy_inodecache();\nout4:\n\tnfs_destroy_nfspagecache();\nout5:\n\tnfs_fs_proc_exit();\nout6:\n\tnfsiod_stop();\nout7:\n\tunregister_pernet_subsys(&nfs_net_ops);\nout9:\n\tnfs_sysfs_exit();\nout10:\n\treturn err;\n}\n\nstatic void __exit exit_nfs_fs(void)\n{\n\tnfs_destroy_directcache();\n\tnfs_destroy_writepagecache();\n\tnfs_destroy_readpagecache();\n\tnfs_destroy_inodecache();\n\tnfs_destroy_nfspagecache();\n\tunregister_pernet_subsys(&nfs_net_ops);\n\trpc_proc_unregister(&init_net, \"nfs\");\n\tunregister_nfs_fs();\n\tnfs_fs_proc_exit();\n\tnfsiod_stop();\n\tnfs_sysfs_exit();\n}\n\n \nMODULE_AUTHOR(\"Olaf Kirch <okir@monad.swb.de>\");\nMODULE_LICENSE(\"GPL\");\nmodule_param(enable_ino64, bool, 0644);\n\nmodule_init(init_nfs_fs)\nmodule_exit(exit_nfs_fs)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}