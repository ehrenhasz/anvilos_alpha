{
  "module_name": "nfs4session.h",
  "hash_id": "9d6cc6eb583a30a7be83a7fccde333e8484238c77b00b158686e42974efad908",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfs/nfs4session.h",
  "human_readable_source": " \n \n#ifndef __LINUX_FS_NFS_NFS4SESSION_H\n#define __LINUX_FS_NFS_NFS4SESSION_H\n\n \n#define NFS4_DEF_SLOT_TABLE_SIZE (64U)\n#define NFS4_DEF_CB_SLOT_TABLE_SIZE (16U)\n#define NFS4_MAX_SLOT_TABLE (1024U)\n#define NFS4_MAX_SLOTID (NFS4_MAX_SLOT_TABLE - 1U)\n#define NFS4_NO_SLOT ((u32)-1)\n\n#if IS_ENABLED(CONFIG_NFS_V4)\n\n \nstruct nfs4_slot {\n\tstruct nfs4_slot_table\t*table;\n\tstruct nfs4_slot\t*next;\n\tunsigned long\t\tgeneration;\n\tu32\t\t\tslot_nr;\n\tu32\t\t \tseq_nr;\n\tu32\t\t \tseq_nr_last_acked;\n\tu32\t\t \tseq_nr_highest_sent;\n\tunsigned int\t\tprivileged : 1,\n\t\t\t\tseq_done : 1;\n};\n\n \nenum nfs4_slot_tbl_state {\n\tNFS4_SLOT_TBL_DRAINING,\n};\n\n#define SLOT_TABLE_SZ DIV_ROUND_UP(NFS4_MAX_SLOT_TABLE, BITS_PER_LONG)\nstruct nfs4_slot_table {\n\tstruct nfs4_session *session;\t\t \n\tstruct nfs4_slot *slots;\t\t \n\tunsigned long   used_slots[SLOT_TABLE_SZ];  \n\tspinlock_t\tslot_tbl_lock;\n\tstruct rpc_wait_queue\tslot_tbl_waitq;\t \n\twait_queue_head_t\tslot_waitq;\t \n\tu32\t\tmax_slots;\t\t \n\tu32\t\tmax_slotid;\t\t \n\tu32\t\thighest_used_slotid;\t \n\tu32\t\ttarget_highest_slotid;\t \n\tu32\t\tserver_highest_slotid;\t \n\ts32\t\td_target_highest_slotid;  \n\ts32\t\td2_target_highest_slotid;  \n\tunsigned long\tgeneration;\t\t \n\tstruct completion complete;\n\tunsigned long\tslot_tbl_state;\n};\n\n \nstruct nfs4_session {\n\tstruct nfs4_sessionid\t\tsess_id;\n\tu32\t\t\t\tflags;\n\tunsigned long\t\t\tsession_state;\n\tu32\t\t\t\thash_alg;\n\tu32\t\t\t\tssv_len;\n\n\t \n\tstruct nfs4_channel_attrs\tfc_attrs;\n\tstruct nfs4_slot_table\t\tfc_slot_table;\n\tstruct nfs4_channel_attrs\tbc_attrs;\n\tstruct nfs4_slot_table\t\tbc_slot_table;\n\tstruct nfs_client\t\t*clp;\n};\n\nenum nfs4_session_state {\n\tNFS4_SESSION_INITING,\n\tNFS4_SESSION_ESTABLISHED,\n};\n\nextern int nfs4_setup_slot_table(struct nfs4_slot_table *tbl,\n\t\tunsigned int max_reqs, const char *queue);\nextern void nfs4_shutdown_slot_table(struct nfs4_slot_table *tbl);\nextern struct nfs4_slot *nfs4_alloc_slot(struct nfs4_slot_table *tbl);\nextern struct nfs4_slot *nfs4_lookup_slot(struct nfs4_slot_table *tbl, u32 slotid);\nextern int nfs4_slot_wait_on_seqid(struct nfs4_slot_table *tbl,\n\t\tu32 slotid, u32 seq_nr,\n\t\tunsigned long timeout);\nextern bool nfs4_try_to_lock_slot(struct nfs4_slot_table *tbl, struct nfs4_slot *slot);\nextern void nfs4_free_slot(struct nfs4_slot_table *tbl, struct nfs4_slot *slot);\nextern void nfs4_slot_tbl_drain_complete(struct nfs4_slot_table *tbl);\nbool nfs41_wake_and_assign_slot(struct nfs4_slot_table *tbl,\n\t\tstruct nfs4_slot *slot);\nvoid nfs41_wake_slot_table(struct nfs4_slot_table *tbl);\n\nstatic inline bool nfs4_slot_tbl_draining(struct nfs4_slot_table *tbl)\n{\n\treturn !!test_bit(NFS4_SLOT_TBL_DRAINING, &tbl->slot_tbl_state);\n}\n\nstatic inline bool nfs4_test_locked_slot(const struct nfs4_slot_table *tbl,\n\t\tu32 slotid)\n{\n\treturn !!test_bit(slotid, tbl->used_slots);\n}\n\nstatic inline struct nfs4_session *nfs4_get_session(const struct nfs_client *clp)\n{\n\treturn clp->cl_session;\n}\n\n#if defined(CONFIG_NFS_V4_1)\nextern void nfs41_set_target_slotid(struct nfs4_slot_table *tbl,\n\t\tu32 target_highest_slotid);\nextern void nfs41_update_target_slotid(struct nfs4_slot_table *tbl,\n\t\tstruct nfs4_slot *slot,\n\t\tstruct nfs4_sequence_res *res);\n\nextern int nfs4_setup_session_slot_tables(struct nfs4_session *ses);\n\nextern struct nfs4_session *nfs4_alloc_session(struct nfs_client *clp);\nextern void nfs4_destroy_session(struct nfs4_session *session);\nextern int nfs4_init_session(struct nfs_client *clp);\nextern int nfs4_init_ds_session(struct nfs_client *, unsigned long);\n\n \nstatic inline int nfs4_has_session(const struct nfs_client *clp)\n{\n\tif (clp->cl_session)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic inline int nfs4_has_persistent_session(const struct nfs_client *clp)\n{\n\tif (nfs4_has_session(clp))\n\t\treturn (clp->cl_session->flags & SESSION4_PERSIST);\n\treturn 0;\n}\n\nstatic inline void nfs4_copy_sessionid(struct nfs4_sessionid *dst,\n\t\tconst struct nfs4_sessionid *src)\n{\n\tmemcpy(dst->data, src->data, NFS4_MAX_SESSIONID_LEN);\n}\n\n#ifdef CONFIG_CRC32\n \n#define nfs_session_id_hash(sess_id) \\\n\t(~crc32_le(0xFFFFFFFF, &(sess_id)->data[0], sizeof((sess_id)->data)))\n#else\n#define nfs_session_id_hash(session) (0)\n#endif\n#else  \n\nstatic inline int nfs4_init_session(struct nfs_client *clp)\n{\n\treturn 0;\n}\n\n \nstatic inline int nfs4_has_session(const struct nfs_client *clp)\n{\n\treturn 0;\n}\n\nstatic inline int nfs4_has_persistent_session(const struct nfs_client *clp)\n{\n\treturn 0;\n}\n\n#define nfs_session_id_hash(session) (0)\n\n#endif  \n#endif  \n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}