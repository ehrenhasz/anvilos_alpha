{
  "module_name": "getroot.c",
  "hash_id": "513cd2034eab87da839acd899a66ce6c981fd1b5c5e85f3b57fc993ecd16295b",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfs/getroot.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/unistd.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_mount.h>\n#include <linux/lockd/bind.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/namei.h>\n#include <linux/security.h>\n\n#include <linux/uaccess.h>\n\n#include \"internal.h\"\n\n#define NFSDBG_FACILITY\t\tNFSDBG_CLIENT\n\n \nstatic int nfs_superblock_set_dummy_root(struct super_block *sb, struct inode *inode)\n{\n\t \n\tif (sb->s_root == NULL) {\n\t\tsb->s_root = d_make_root(inode);\n\t\tif (sb->s_root == NULL)\n\t\t\treturn -ENOMEM;\n\t\tihold(inode);\n\t\t \n\t\tspin_lock(&d_inode(sb->s_root)->i_lock);\n\t\tspin_lock(&sb->s_root->d_lock);\n\t\thlist_del_init(&sb->s_root->d_u.d_alias);\n\t\tspin_unlock(&sb->s_root->d_lock);\n\t\tspin_unlock(&d_inode(sb->s_root)->i_lock);\n\t}\n\treturn 0;\n}\n\n \nint nfs_get_root(struct super_block *s, struct fs_context *fc)\n{\n\tstruct nfs_fs_context *ctx = nfs_fc2context(fc);\n\tstruct nfs_server *server = NFS_SB(s), *clone_server;\n\tstruct nfs_fsinfo fsinfo;\n\tstruct dentry *root;\n\tstruct inode *inode;\n\tchar *name;\n\tint error = -ENOMEM;\n\tunsigned long kflags = 0, kflags_out = 0;\n\n\tname = kstrdup(fc->source, GFP_KERNEL);\n\tif (!name)\n\t\tgoto out;\n\n\t \n\tfsinfo.fattr = nfs_alloc_fattr_with_label(server);\n\tif (fsinfo.fattr == NULL)\n\t\tgoto out_name;\n\n\terror = server->nfs_client->rpc_ops->getroot(server, ctx->mntfh, &fsinfo);\n\tif (error < 0) {\n\t\tdprintk(\"nfs_get_root: getattr error = %d\\n\", -error);\n\t\tnfs_errorf(fc, \"NFS: Couldn't getattr on root\");\n\t\tgoto out_fattr;\n\t}\n\n\tinode = nfs_fhget(s, ctx->mntfh, fsinfo.fattr);\n\tif (IS_ERR(inode)) {\n\t\tdprintk(\"nfs_get_root: get root inode failed\\n\");\n\t\terror = PTR_ERR(inode);\n\t\tnfs_errorf(fc, \"NFS: Couldn't get root inode\");\n\t\tgoto out_fattr;\n\t}\n\n\terror = nfs_superblock_set_dummy_root(s, inode);\n\tif (error != 0)\n\t\tgoto out_fattr;\n\n\t \n\troot = d_obtain_root(inode);\n\tif (IS_ERR(root)) {\n\t\tdprintk(\"nfs_get_root: get root dentry failed\\n\");\n\t\terror = PTR_ERR(root);\n\t\tnfs_errorf(fc, \"NFS: Couldn't get root dentry\");\n\t\tgoto out_fattr;\n\t}\n\n\tsecurity_d_instantiate(root, inode);\n\tspin_lock(&root->d_lock);\n\tif (IS_ROOT(root) && !root->d_fsdata &&\n\t    !(root->d_flags & DCACHE_NFSFS_RENAMED)) {\n\t\troot->d_fsdata = name;\n\t\tname = NULL;\n\t}\n\tspin_unlock(&root->d_lock);\n\tfc->root = root;\n\tif (server->caps & NFS_CAP_SECURITY_LABEL)\n\t\tkflags |= SECURITY_LSM_NATIVE_LABELS;\n\tif (ctx->clone_data.sb) {\n\t\tif (d_inode(fc->root)->i_fop != &nfs_dir_operations) {\n\t\t\terror = -ESTALE;\n\t\t\tgoto error_splat_root;\n\t\t}\n\t\t \n\t\terror = security_sb_clone_mnt_opts(ctx->clone_data.sb,\n\t\t\t\t\t\t   s, kflags, &kflags_out);\n\t\tif (error)\n\t\t\tgoto error_splat_root;\n\t\tclone_server = NFS_SB(ctx->clone_data.sb);\n\t\tserver->has_sec_mnt_opts = clone_server->has_sec_mnt_opts;\n\t} else {\n\t\terror = security_sb_set_mnt_opts(s, fc->security,\n\t\t\t\t\t\t\tkflags, &kflags_out);\n\t}\n\tif (error)\n\t\tgoto error_splat_root;\n\tif (server->caps & NFS_CAP_SECURITY_LABEL &&\n\t\t!(kflags_out & SECURITY_LSM_NATIVE_LABELS))\n\t\tserver->caps &= ~NFS_CAP_SECURITY_LABEL;\n\n\tnfs_setsecurity(inode, fsinfo.fattr);\n\terror = 0;\n\nout_fattr:\n\tnfs_free_fattr(fsinfo.fattr);\nout_name:\n\tkfree(name);\nout:\n\treturn error;\nerror_splat_root:\n\tdput(fc->root);\n\tfc->root = NULL;\n\tgoto out_fattr;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}