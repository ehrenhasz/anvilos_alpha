{
  "module_name": "pnfs.h",
  "hash_id": "9ddcac5d985cf259ac182b9e392130ed2e5ea320825e906d2676693f73112fda",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfs/pnfs.h",
  "human_readable_source": " \n\n#ifndef FS_NFS_PNFS_H\n#define FS_NFS_PNFS_H\n\n#include <linux/refcount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/workqueue.h>\n\nstruct nfs4_opendata;\n\nenum {\n\tNFS_LSEG_VALID = 0,\t \n\tNFS_LSEG_ROC,\t\t \n\tNFS_LSEG_LAYOUTCOMMIT,\t \n\tNFS_LSEG_LAYOUTRETURN,\t \n\tNFS_LSEG_UNAVAILABLE,\t \n};\n\n \nstruct nfs4_pnfs_ds_addr {\n\tstruct sockaddr_storage\tda_addr;\n\tsize_t\t\t\tda_addrlen;\n\tstruct list_head\tda_node;   \n\tchar\t\t\t*da_remotestr;\t \n\tconst char\t\t*da_netid;\n\tint\t\t\tda_transport;\n};\n\nstruct nfs4_pnfs_ds {\n\tstruct list_head\tds_node;   \n\tchar\t\t\t*ds_remotestr;\t \n\tstruct list_head\tds_addrs;\n\tstruct nfs_client\t*ds_clp;\n\trefcount_t\t\tds_count;\n\tunsigned long\t\tds_state;\n#define NFS4DS_CONNECTING\t0\t \n};\n\nstruct pnfs_layout_segment {\n\tstruct list_head pls_list;\n\tstruct list_head pls_lc_list;\n\tstruct list_head pls_commits;\n\tstruct pnfs_layout_range pls_range;\n\trefcount_t pls_refcount;\n\tu32 pls_seq;\n\tunsigned long pls_flags;\n\tstruct pnfs_layout_hdr *pls_layout;\n};\n\nenum pnfs_try_status {\n\tPNFS_ATTEMPTED     = 0,\n\tPNFS_NOT_ATTEMPTED = 1,\n\tPNFS_TRY_AGAIN     = 2,\n};\n\n#ifdef CONFIG_NFS_V4_1\n\n#define LAYOUT_NFSV4_1_MODULE_PREFIX \"nfs-layouttype4\"\n\n \n#define NFS4_DEF_DS_TIMEO   600  \n#define NFS4_DEF_DS_RETRANS 5\n#define PNFS_DEVICE_RETRY_TIMEOUT (120*HZ)\n\nenum {\n\tNFS_LAYOUT_RO_FAILED = 0,\t \n\tNFS_LAYOUT_RW_FAILED,\t\t \n\tNFS_LAYOUT_BULK_RECALL,\t\t \n\tNFS_LAYOUT_RETURN,\t\t \n\tNFS_LAYOUT_RETURN_LOCK,\t\t \n\tNFS_LAYOUT_RETURN_REQUESTED,\t \n\tNFS_LAYOUT_INVALID_STID,\t \n\tNFS_LAYOUT_FIRST_LAYOUTGET,\t \n\tNFS_LAYOUT_INODE_FREEING,\t \n\tNFS_LAYOUT_HASHED,\t\t \n\tNFS_LAYOUT_DRAIN,\n};\n\nenum layoutdriver_policy_flags {\n\t \n\tPNFS_LAYOUTRET_ON_SETATTR\t= 1 << 0,\n\tPNFS_LAYOUTRET_ON_ERROR\t\t= 1 << 1,\n\tPNFS_READ_WHOLE_PAGE\t\t= 1 << 2,\n\tPNFS_LAYOUTGET_ON_OPEN\t\t= 1 << 3,\n};\n\nstruct nfs4_deviceid_node;\n\n \nstruct pnfs_layoutdriver_type {\n\tstruct list_head pnfs_tblid;\n\tconst u32 id;\n\tconst char *name;\n\tstruct module *owner;\n\tunsigned flags;\n\tunsigned max_deviceinfo_size;\n\tunsigned max_layoutget_response;\n\n\tint (*set_layoutdriver) (struct nfs_server *, const struct nfs_fh *);\n\tint (*clear_layoutdriver) (struct nfs_server *);\n\n\tstruct pnfs_layout_hdr * (*alloc_layout_hdr) (struct inode *inode, gfp_t gfp_flags);\n\tvoid (*free_layout_hdr) (struct pnfs_layout_hdr *);\n\n\tstruct pnfs_layout_segment * (*alloc_lseg) (struct pnfs_layout_hdr *layoutid, struct nfs4_layoutget_res *lgr, gfp_t gfp_flags);\n\tvoid (*free_lseg) (struct pnfs_layout_segment *lseg);\n\tvoid (*add_lseg) (struct pnfs_layout_hdr *layoutid,\n\t\t\tstruct pnfs_layout_segment *lseg,\n\t\t\tstruct list_head *free_me);\n\n\tvoid (*return_range) (struct pnfs_layout_hdr *lo,\n\t\t\t      struct pnfs_layout_range *range);\n\n\t \n\tconst struct nfs_pageio_ops *pg_read_ops;\n\tconst struct nfs_pageio_ops *pg_write_ops;\n\n\tstruct pnfs_ds_commit_info *(*get_ds_info) (struct inode *inode);\n\n\tint (*sync)(struct inode *inode, bool datasync);\n\n\t \n\tenum pnfs_try_status (*read_pagelist)(struct nfs_pgio_header *);\n\tenum pnfs_try_status (*write_pagelist)(struct nfs_pgio_header *, int);\n\n\tvoid (*free_deviceid_node) (struct nfs4_deviceid_node *);\n\tstruct nfs4_deviceid_node * (*alloc_deviceid_node)\n\t\t\t(struct nfs_server *server, struct pnfs_device *pdev,\n\t\t\tgfp_t gfp_flags);\n\n\tint (*prepare_layoutreturn) (struct nfs4_layoutreturn_args *);\n\n\tvoid (*cleanup_layoutcommit) (struct nfs4_layoutcommit_data *data);\n\tint (*prepare_layoutcommit) (struct nfs4_layoutcommit_args *args);\n\tint (*prepare_layoutstats) (struct nfs42_layoutstat_args *args);\n\n\tvoid (*cancel_io)(struct pnfs_layout_segment *lseg);\n};\n\nstruct pnfs_commit_ops {\n\tvoid (*setup_ds_info)(struct pnfs_ds_commit_info *,\n\t\t\t      struct pnfs_layout_segment *);\n\tvoid (*release_ds_info)(struct pnfs_ds_commit_info *,\n\t\t\t\tstruct inode *inode);\n\tint (*commit_pagelist)(struct inode *inode,\n\t\t\t       struct list_head *mds_pages,\n\t\t\t       int how,\n\t\t\t       struct nfs_commit_info *cinfo);\n\tvoid (*mark_request_commit) (struct nfs_page *req,\n\t\t\t\t     struct pnfs_layout_segment *lseg,\n\t\t\t\t     struct nfs_commit_info *cinfo,\n\t\t\t\t     u32 ds_commit_idx);\n\tvoid (*clear_request_commit) (struct nfs_page *req,\n\t\t\t\t      struct nfs_commit_info *cinfo);\n\tint (*scan_commit_lists) (struct nfs_commit_info *cinfo,\n\t\t\t\t  int max);\n\tvoid (*recover_commit_reqs) (struct list_head *list,\n\t\t\t\t     struct nfs_commit_info *cinfo);\n\tstruct nfs_page * (*search_commit_reqs)(struct nfs_commit_info *cinfo,\n\t\t\t\t\t\tstruct folio *folio);\n};\n\nstruct pnfs_layout_hdr {\n\trefcount_t\t\tplh_refcount;\n\tatomic_t\t\tplh_outstanding;  \n\tstruct list_head\tplh_layouts;    \n\tstruct list_head\tplh_bulk_destroy;\n\tstruct list_head\tplh_segs;       \n\tstruct list_head\tplh_return_segs;  \n\tunsigned long\t\tplh_block_lgets;  \n\tunsigned long\t\tplh_retry_timestamp;\n\tunsigned long\t\tplh_flags;\n\tnfs4_stateid\t\tplh_stateid;\n\tu32\t\t\tplh_barrier;  \n\tu32\t\t\tplh_return_seq;\n\tenum pnfs_iomode\tplh_return_iomode;\n\tloff_t\t\t\tplh_lwb;  \n\tconst struct cred\t*plh_lc_cred;  \n\tstruct inode\t\t*plh_inode;\n\tstruct rcu_head\t\tplh_rcu;\n};\n\nstruct pnfs_device {\n\tstruct nfs4_deviceid dev_id;\n\tunsigned int  layout_type;\n\tunsigned int  mincount;\n\tunsigned int  maxcount;\t \n\tstruct page **pages;\n\tunsigned int  pgbase;\n\tunsigned int  pglen;\t \n\tunsigned char nocache : 1; \n};\n\n#define NFS4_PNFS_GETDEVLIST_MAXNUM 16\n\nstruct pnfs_devicelist {\n\tunsigned int\t\teof;\n\tunsigned int\t\tnum_devs;\n\tstruct nfs4_deviceid\tdev_id[NFS4_PNFS_GETDEVLIST_MAXNUM];\n};\n\nextern int pnfs_register_layoutdriver(struct pnfs_layoutdriver_type *);\nextern void pnfs_unregister_layoutdriver(struct pnfs_layoutdriver_type *);\nextern const struct pnfs_layoutdriver_type *pnfs_find_layoutdriver(u32 id);\nextern void pnfs_put_layoutdriver(const struct pnfs_layoutdriver_type *ld);\n\n \nextern size_t max_response_pages(struct nfs_server *server);\nextern int nfs4_proc_getdeviceinfo(struct nfs_server *server,\n\t\t\t\t   struct pnfs_device *dev,\n\t\t\t\t   const struct cred *cred);\nextern struct pnfs_layout_segment* nfs4_proc_layoutget(struct nfs4_layoutget *lgp, long *timeout);\nextern int nfs4_proc_layoutreturn(struct nfs4_layoutreturn *lrp, bool sync);\n\n \nvoid pnfs_get_layout_hdr(struct pnfs_layout_hdr *lo);\nvoid pnfs_put_lseg(struct pnfs_layout_segment *lseg);\n\nvoid set_pnfs_layoutdriver(struct nfs_server *, const struct nfs_fh *, struct nfs_fsinfo *);\nvoid unset_pnfs_layoutdriver(struct nfs_server *);\nvoid pnfs_generic_pg_check_layout(struct nfs_pageio_descriptor *pgio);\nvoid pnfs_generic_pg_check_range(struct nfs_pageio_descriptor *pgio, struct nfs_page *req);\nvoid pnfs_generic_pg_init_read(struct nfs_pageio_descriptor *, struct nfs_page *);\nint pnfs_generic_pg_readpages(struct nfs_pageio_descriptor *desc);\nvoid pnfs_generic_pg_init_write(struct nfs_pageio_descriptor *pgio,\n\t\t\t        struct nfs_page *req, u64 wb_size);\nvoid pnfs_generic_pg_cleanup(struct nfs_pageio_descriptor *);\nint pnfs_generic_pg_writepages(struct nfs_pageio_descriptor *desc);\nsize_t pnfs_generic_pg_test(struct nfs_pageio_descriptor *pgio,\n\t\t\t    struct nfs_page *prev, struct nfs_page *req);\nvoid pnfs_set_lo_fail(struct pnfs_layout_segment *lseg);\nstruct pnfs_layout_segment *pnfs_layout_process(struct nfs4_layoutget *lgp);\nvoid pnfs_layoutget_free(struct nfs4_layoutget *lgp);\nvoid pnfs_free_lseg_list(struct list_head *tmp_list);\nvoid pnfs_destroy_layout(struct nfs_inode *);\nvoid pnfs_destroy_layout_final(struct nfs_inode *);\nvoid pnfs_destroy_all_layouts(struct nfs_client *);\nint pnfs_destroy_layouts_byfsid(struct nfs_client *clp,\n\t\tstruct nfs_fsid *fsid,\n\t\tbool is_recall);\nint pnfs_destroy_layouts_byclid(struct nfs_client *clp,\n\t\tbool is_recall);\nbool nfs4_layout_refresh_old_stateid(nfs4_stateid *dst,\n\t\tstruct pnfs_layout_range *dst_range,\n\t\tstruct inode *inode);\nvoid pnfs_put_layout_hdr(struct pnfs_layout_hdr *lo);\nvoid pnfs_set_layout_stateid(struct pnfs_layout_hdr *lo,\n\t\t\t     const nfs4_stateid *new,\n\t\t\t     const struct cred *cred,\n\t\t\t     bool update_barrier);\nint pnfs_mark_matching_lsegs_invalid(struct pnfs_layout_hdr *lo,\n\t\t\t\tstruct list_head *tmp_list,\n\t\t\t\tconst struct pnfs_layout_range *recall_range,\n\t\t\t\tu32 seq);\nint pnfs_mark_matching_lsegs_return(struct pnfs_layout_hdr *lo,\n\t\t\t\tstruct list_head *tmp_list,\n\t\t\t\tconst struct pnfs_layout_range *recall_range,\n\t\t\t\tu32 seq);\nint pnfs_mark_layout_stateid_invalid(struct pnfs_layout_hdr *lo,\n\t\tstruct list_head *lseg_list);\nbool pnfs_roc(struct inode *ino,\n\t\tstruct nfs4_layoutreturn_args *args,\n\t\tstruct nfs4_layoutreturn_res *res,\n\t\tconst struct cred *cred);\nint pnfs_roc_done(struct rpc_task *task, struct nfs4_layoutreturn_args **argpp,\n\t\t  struct nfs4_layoutreturn_res **respp, int *ret);\nvoid pnfs_roc_release(struct nfs4_layoutreturn_args *args,\n\t\tstruct nfs4_layoutreturn_res *res,\n\t\tint ret);\nbool pnfs_wait_on_layoutreturn(struct inode *ino, struct rpc_task *task);\nvoid pnfs_set_layoutcommit(struct inode *, struct pnfs_layout_segment *, loff_t);\nvoid pnfs_cleanup_layoutcommit(struct nfs4_layoutcommit_data *data);\nint pnfs_layoutcommit_inode(struct inode *inode, bool sync);\nint pnfs_generic_sync(struct inode *inode, bool datasync);\nint pnfs_nfs_generic_sync(struct inode *inode, bool datasync);\nint _pnfs_return_layout(struct inode *);\nint pnfs_commit_and_return_layout(struct inode *);\nvoid pnfs_ld_write_done(struct nfs_pgio_header *);\nvoid pnfs_ld_read_done(struct nfs_pgio_header *);\nvoid pnfs_read_resend_pnfs(struct nfs_pgio_header *, unsigned int mirror_idx);\nstruct pnfs_layout_segment *pnfs_update_layout(struct inode *ino,\n\t\t\t\t\t       struct nfs_open_context *ctx,\n\t\t\t\t\t       loff_t pos,\n\t\t\t\t\t       u64 count,\n\t\t\t\t\t       enum pnfs_iomode iomode,\n\t\t\t\t\t       bool strict_iomode,\n\t\t\t\t\t       gfp_t gfp_flags);\nvoid pnfs_layoutreturn_free_lsegs(struct pnfs_layout_hdr *lo,\n\t\tconst nfs4_stateid *arg_stateid,\n\t\tconst struct pnfs_layout_range *range,\n\t\tconst nfs4_stateid *stateid);\n\nvoid pnfs_generic_layout_insert_lseg(struct pnfs_layout_hdr *lo,\n\t\t   struct pnfs_layout_segment *lseg,\n\t\t   bool (*is_after)(const struct pnfs_layout_range *lseg_range,\n\t\t\t   const struct pnfs_layout_range *old),\n\t\t   bool (*do_merge)(struct pnfs_layout_segment *lseg,\n\t\t\t   struct pnfs_layout_segment *old),\n\t\t   struct list_head *free_me);\n\nvoid nfs4_deviceid_mark_client_invalid(struct nfs_client *clp);\nint pnfs_read_done_resend_to_mds(struct nfs_pgio_header *);\nint pnfs_write_done_resend_to_mds(struct nfs_pgio_header *);\nstruct nfs4_threshold *pnfs_mdsthreshold_alloc(void);\nvoid pnfs_error_mark_layout_for_return(struct inode *inode,\n\t\t\t\t       struct pnfs_layout_segment *lseg);\nvoid pnfs_layout_return_unused_byclid(struct nfs_client *clp,\n\t\t\t\t      enum pnfs_iomode iomode);\n\n \nenum {\n\tNFS_DEVICEID_INVALID = 0,        \n\tNFS_DEVICEID_UNAVAILABLE,\t \n\tNFS_DEVICEID_NOCACHE,\t\t \n};\n\n \nstruct nfs4_deviceid_node {\n\tstruct hlist_node\t\tnode;\n\tstruct hlist_node\t\ttmpnode;\n\tconst struct pnfs_layoutdriver_type *ld;\n\tconst struct nfs_client\t\t*nfs_client;\n\tunsigned long \t\t\tflags;\n\tunsigned long\t\t\ttimestamp_unavailable;\n\tstruct nfs4_deviceid\t\tdeviceid;\n\tstruct rcu_head\t\t\trcu;\n\tatomic_t\t\t\tref;\n};\n\nstruct nfs4_deviceid_node *\nnfs4_find_get_deviceid(struct nfs_server *server,\n\t\tconst struct nfs4_deviceid *id, const struct cred *cred,\n\t\tgfp_t gfp_mask);\nvoid nfs4_delete_deviceid(const struct pnfs_layoutdriver_type *, const struct nfs_client *, const struct nfs4_deviceid *);\nvoid nfs4_init_deviceid_node(struct nfs4_deviceid_node *, struct nfs_server *,\n\t\t\t     const struct nfs4_deviceid *);\nbool nfs4_put_deviceid_node(struct nfs4_deviceid_node *);\nvoid nfs4_mark_deviceid_available(struct nfs4_deviceid_node *node);\nvoid nfs4_mark_deviceid_unavailable(struct nfs4_deviceid_node *node);\nbool nfs4_test_deviceid_unavailable(struct nfs4_deviceid_node *node);\nvoid nfs4_deviceid_purge_client(const struct nfs_client *);\n\n \nstruct pnfs_commit_array *pnfs_alloc_commit_array(size_t n, gfp_t gfp_flags);\nvoid pnfs_free_commit_array(struct pnfs_commit_array *p);\nstruct pnfs_commit_array *pnfs_add_commit_array(struct pnfs_ds_commit_info *,\n\t\t\t\t\t\tstruct pnfs_commit_array *,\n\t\t\t\t\t\tstruct pnfs_layout_segment *);\n\nvoid pnfs_generic_ds_cinfo_release_lseg(struct pnfs_ds_commit_info *fl_cinfo,\n\t\tstruct pnfs_layout_segment *lseg);\nvoid pnfs_generic_ds_cinfo_destroy(struct pnfs_ds_commit_info *fl_cinfo);\n\nvoid pnfs_generic_clear_request_commit(struct nfs_page *req,\n\t\t\t\t       struct nfs_commit_info *cinfo);\nvoid pnfs_generic_commit_release(void *calldata);\nvoid pnfs_generic_prepare_to_resend_writes(struct nfs_commit_data *data);\nvoid pnfs_generic_rw_release(void *data);\nvoid pnfs_generic_recover_commit_reqs(struct list_head *dst,\n\t\t\t\t      struct nfs_commit_info *cinfo);\nstruct nfs_page *pnfs_generic_search_commit_reqs(struct nfs_commit_info *cinfo,\n\t\t\t\t\t\t struct folio *folio);\nint pnfs_generic_commit_pagelist(struct inode *inode,\n\t\t\t\t struct list_head *mds_pages,\n\t\t\t\t int how,\n\t\t\t\t struct nfs_commit_info *cinfo,\n\t\t\t\t int (*initiate_commit)(struct nfs_commit_data *data,\n\t\t\t\t\t\t\tint how));\nint pnfs_generic_scan_commit_lists(struct nfs_commit_info *cinfo, int max);\nvoid pnfs_generic_write_commit_done(struct rpc_task *task, void *data);\nvoid nfs4_pnfs_ds_put(struct nfs4_pnfs_ds *ds);\nstruct nfs4_pnfs_ds *nfs4_pnfs_ds_add(struct list_head *dsaddrs,\n\t\t\t\t      gfp_t gfp_flags);\nvoid nfs4_pnfs_v3_ds_connect_unload(void);\nint nfs4_pnfs_ds_connect(struct nfs_server *mds_srv, struct nfs4_pnfs_ds *ds,\n\t\t\t  struct nfs4_deviceid_node *devid, unsigned int timeo,\n\t\t\t  unsigned int retrans, u32 version, u32 minor_version);\nstruct nfs4_pnfs_ds_addr *nfs4_decode_mp_ds_addr(struct net *net,\n\t\t\t\t\t\t struct xdr_stream *xdr,\n\t\t\t\t\t\t gfp_t gfp_flags);\nvoid pnfs_layout_mark_request_commit(struct nfs_page *req,\n\t\t\t\t     struct pnfs_layout_segment *lseg,\n\t\t\t\t     struct nfs_commit_info *cinfo,\n\t\t\t\t     u32 ds_commit_idx);\nvoid pnfs_lgopen_prepare(struct nfs4_opendata *data,\n\t\t\t struct nfs_open_context *ctx);\nvoid pnfs_parse_lgopen(struct inode *ino, struct nfs4_layoutget *lgp,\n\t\t       struct nfs_open_context *ctx);\nvoid nfs4_lgopen_release(struct nfs4_layoutget *lgp);\n\nstatic inline bool nfs_have_layout(struct inode *inode)\n{\n\treturn NFS_I(inode)->layout != NULL;\n}\n\nstatic inline bool pnfs_layout_is_valid(const struct pnfs_layout_hdr *lo)\n{\n\treturn test_bit(NFS_LAYOUT_INVALID_STID, &lo->plh_flags) == 0;\n}\n\nstatic inline struct nfs4_deviceid_node *\nnfs4_get_deviceid(struct nfs4_deviceid_node *d)\n{\n\tatomic_inc(&d->ref);\n\treturn d;\n}\n\nstatic inline struct pnfs_layout_segment *\npnfs_get_lseg(struct pnfs_layout_segment *lseg)\n{\n\tif (lseg) {\n\t\trefcount_inc(&lseg->pls_refcount);\n\t\tsmp_mb__after_atomic();\n\t}\n\treturn lseg;\n}\n\nstatic inline bool\npnfs_is_valid_lseg(struct pnfs_layout_segment *lseg)\n{\n\treturn test_bit(NFS_LSEG_VALID, &lseg->pls_flags) != 0;\n}\n\n \nstatic inline int pnfs_enabled_sb(struct nfs_server *nfss)\n{\n\treturn nfss->pnfs_curr_ld != NULL;\n}\n\nstatic inline int\npnfs_commit_list(struct inode *inode, struct list_head *mds_pages, int how,\n\t\t struct nfs_commit_info *cinfo)\n{\n\tstruct pnfs_ds_commit_info *fl_cinfo = cinfo->ds;\n\n\tif (fl_cinfo == NULL || fl_cinfo->ncommitting == 0)\n\t\treturn PNFS_NOT_ATTEMPTED;\n\treturn fl_cinfo->ops->commit_pagelist(inode, mds_pages, how, cinfo);\n}\n\nstatic inline struct pnfs_ds_commit_info *\npnfs_get_ds_info(struct inode *inode)\n{\n\tstruct pnfs_layoutdriver_type *ld = NFS_SERVER(inode)->pnfs_curr_ld;\n\n\tif (ld == NULL || ld->get_ds_info == NULL)\n\t\treturn NULL;\n\treturn ld->get_ds_info(inode);\n}\n\nstatic inline void\npnfs_init_ds_commit_info_ops(struct pnfs_ds_commit_info *fl_cinfo, struct inode *inode)\n{\n\tstruct pnfs_ds_commit_info *inode_cinfo = pnfs_get_ds_info(inode);\n\tif (inode_cinfo != NULL)\n\t\tfl_cinfo->ops = inode_cinfo->ops;\n}\n\nstatic inline void\npnfs_init_ds_commit_info(struct pnfs_ds_commit_info *fl_cinfo)\n{\n\tINIT_LIST_HEAD(&fl_cinfo->commits);\n\tfl_cinfo->ops = NULL;\n}\n\nstatic inline void\npnfs_release_ds_info(struct pnfs_ds_commit_info *fl_cinfo, struct inode *inode)\n{\n\tif (fl_cinfo->ops != NULL && fl_cinfo->ops->release_ds_info != NULL)\n\t\tfl_cinfo->ops->release_ds_info(fl_cinfo, inode);\n}\n\nstatic inline void\npnfs_generic_mark_devid_invalid(struct nfs4_deviceid_node *node)\n{\n\tset_bit(NFS_DEVICEID_INVALID, &node->flags);\n}\n\nstatic inline bool\npnfs_mark_request_commit(struct nfs_page *req, struct pnfs_layout_segment *lseg,\n\t\t\t struct nfs_commit_info *cinfo, u32 ds_commit_idx)\n{\n\tstruct pnfs_ds_commit_info *fl_cinfo = cinfo->ds;\n\n\tif (!lseg || !fl_cinfo->ops || !fl_cinfo->ops->mark_request_commit)\n\t\treturn false;\n\tfl_cinfo->ops->mark_request_commit(req, lseg, cinfo, ds_commit_idx);\n\treturn true;\n}\n\nstatic inline bool\npnfs_clear_request_commit(struct nfs_page *req, struct nfs_commit_info *cinfo)\n{\n\tstruct pnfs_ds_commit_info *fl_cinfo = cinfo->ds;\n\n\tif (!fl_cinfo || !fl_cinfo->ops || !fl_cinfo->ops->clear_request_commit)\n\t\treturn false;\n\tfl_cinfo->ops->clear_request_commit(req, cinfo);\n\treturn true;\n}\n\nstatic inline int\npnfs_scan_commit_lists(struct inode *inode, struct nfs_commit_info *cinfo,\n\t\t       int max)\n{\n\tstruct pnfs_ds_commit_info *fl_cinfo = cinfo->ds;\n\n\tif (!fl_cinfo || fl_cinfo->nwritten == 0)\n\t\treturn 0;\n\treturn fl_cinfo->ops->scan_commit_lists(cinfo, max);\n}\n\nstatic inline void\npnfs_recover_commit_reqs(struct list_head *head, struct nfs_commit_info *cinfo)\n{\n\tstruct pnfs_ds_commit_info *fl_cinfo = cinfo->ds;\n\n\tif (fl_cinfo && fl_cinfo->nwritten != 0)\n\t\tfl_cinfo->ops->recover_commit_reqs(head, cinfo);\n}\n\nstatic inline struct nfs_page *\npnfs_search_commit_reqs(struct inode *inode, struct nfs_commit_info *cinfo,\n\t\t\tstruct folio *folio)\n{\n\tstruct pnfs_ds_commit_info *fl_cinfo = cinfo->ds;\n\n\tif (!fl_cinfo->ops || !fl_cinfo->ops->search_commit_reqs)\n\t\treturn NULL;\n\treturn fl_cinfo->ops->search_commit_reqs(cinfo, folio);\n}\n\n \nstatic inline bool\npnfs_ld_layoutret_on_setattr(struct inode *inode)\n{\n\tif (!pnfs_enabled_sb(NFS_SERVER(inode)))\n\t\treturn false;\n\treturn NFS_SERVER(inode)->pnfs_curr_ld->flags &\n\t\tPNFS_LAYOUTRET_ON_SETATTR;\n}\n\nstatic inline bool\npnfs_ld_read_whole_page(struct inode *inode)\n{\n\tif (!pnfs_enabled_sb(NFS_SERVER(inode)))\n\t\treturn false;\n\treturn NFS_SERVER(inode)->pnfs_curr_ld->flags & PNFS_READ_WHOLE_PAGE;\n}\n\nstatic inline int\npnfs_sync_inode(struct inode *inode, bool datasync)\n{\n\tif (!pnfs_enabled_sb(NFS_SERVER(inode)))\n\t\treturn 0;\n\treturn NFS_SERVER(inode)->pnfs_curr_ld->sync(inode, datasync);\n}\n\nstatic inline bool\npnfs_layoutcommit_outstanding(struct inode *inode)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\treturn test_bit(NFS_INO_LAYOUTCOMMIT, &nfsi->flags) != 0 ||\n\t\ttest_bit(NFS_INO_LAYOUTCOMMITTING, &nfsi->flags) != 0;\n}\n\nstatic inline int pnfs_return_layout(struct inode *ino)\n{\n\tstruct nfs_inode *nfsi = NFS_I(ino);\n\tstruct nfs_server *nfss = NFS_SERVER(ino);\n\n\tif (pnfs_enabled_sb(nfss) && nfsi->layout) {\n\t\tset_bit(NFS_LAYOUT_RETURN_REQUESTED, &nfsi->layout->plh_flags);\n\t\treturn _pnfs_return_layout(ino);\n\t}\n\n\treturn 0;\n}\n\nstatic inline bool\npnfs_use_threshold(struct nfs4_threshold **dst, struct nfs4_threshold *src,\n\t\t   struct nfs_server *nfss)\n{\n\treturn (dst && src && src->bm != 0 && nfss->pnfs_curr_ld &&\n\t\t\t\t\tnfss->pnfs_curr_ld->id == src->l_type);\n}\n\nstatic inline u64\npnfs_calc_offset_end(u64 offset, u64 len)\n{\n\tif (len == NFS4_MAX_UINT64 || len >= NFS4_MAX_UINT64 - offset)\n\t\treturn NFS4_MAX_UINT64;\n\treturn offset + len - 1;\n}\n\nstatic inline u64\npnfs_calc_offset_length(u64 offset, u64 end)\n{\n\tif (end == NFS4_MAX_UINT64 || end <= offset)\n\t\treturn NFS4_MAX_UINT64;\n\treturn 1 + end - offset;\n}\n\nstatic inline void\npnfs_copy_range(struct pnfs_layout_range *dst,\n\t\tconst struct pnfs_layout_range *src)\n{\n\tmemcpy(dst, src, sizeof(*dst));\n}\n\nstatic inline u64\npnfs_end_offset(u64 start, u64 len)\n{\n\tif (NFS4_MAX_UINT64 - start <= len)\n\t\treturn NFS4_MAX_UINT64;\n\treturn start + len;\n}\n\n \nstatic inline bool\npnfs_is_range_intersecting(u64 start1, u64 end1, u64 start2, u64 end2)\n{\n\treturn (end1 == NFS4_MAX_UINT64 || start2 < end1) &&\n\t\t(end2 == NFS4_MAX_UINT64 || start1 < end2);\n}\n\nstatic inline bool\npnfs_lseg_range_intersecting(const struct pnfs_layout_range *l1,\n\t\tconst struct pnfs_layout_range *l2)\n{\n\tu64 end1 = pnfs_end_offset(l1->offset, l1->length);\n\tu64 end2 = pnfs_end_offset(l2->offset, l2->length);\n\n\treturn pnfs_is_range_intersecting(l1->offset, end1, l2->offset, end2);\n}\n\nstatic inline bool\npnfs_lseg_request_intersecting(struct pnfs_layout_segment *lseg, struct nfs_page *req)\n{\n\tu64 seg_last = pnfs_end_offset(lseg->pls_range.offset, lseg->pls_range.length);\n\tu64 req_last = req_offset(req) + req->wb_bytes;\n\n\treturn pnfs_is_range_intersecting(lseg->pls_range.offset, seg_last,\n\t\t\t\treq_offset(req), req_last);\n}\n\nstatic inline void pnfs_lseg_cancel_io(struct nfs_server *server,\n\t\t\t\t       struct pnfs_layout_segment *lseg)\n{\n\tif (server->pnfs_curr_ld->cancel_io)\n\t\tserver->pnfs_curr_ld->cancel_io(lseg);\n}\n\nextern unsigned int layoutstats_timer;\n\n#ifdef NFS_DEBUG\nvoid nfs4_print_deviceid(const struct nfs4_deviceid *dev_id);\n#else\nstatic inline void nfs4_print_deviceid(const struct nfs4_deviceid *dev_id)\n{\n}\n\n#endif  \n#else   \n\nstatic inline bool nfs_have_layout(struct inode *inode)\n{\n\treturn false;\n}\n\nstatic inline void pnfs_destroy_all_layouts(struct nfs_client *clp)\n{\n}\n\nstatic inline void pnfs_destroy_layout(struct nfs_inode *nfsi)\n{\n}\n\nstatic inline void pnfs_destroy_layout_final(struct nfs_inode *nfsi)\n{\n}\n\nstatic inline struct pnfs_layout_segment *\npnfs_get_lseg(struct pnfs_layout_segment *lseg)\n{\n\treturn NULL;\n}\n\nstatic inline void pnfs_put_lseg(struct pnfs_layout_segment *lseg)\n{\n}\n\nstatic inline int pnfs_return_layout(struct inode *ino)\n{\n\treturn 0;\n}\n\nstatic inline int pnfs_commit_and_return_layout(struct inode *inode)\n{\n\treturn 0;\n}\n\nstatic inline bool\npnfs_ld_layoutret_on_setattr(struct inode *inode)\n{\n\treturn false;\n}\n\nstatic inline bool\npnfs_ld_read_whole_page(struct inode *inode)\n{\n\treturn false;\n}\n\nstatic inline int\npnfs_sync_inode(struct inode *inode, bool datasync)\n{\n\treturn 0;\n}\n\nstatic inline bool\npnfs_layoutcommit_outstanding(struct inode *inode)\n{\n\treturn false;\n}\n\n\nstatic inline bool\npnfs_roc(struct inode *ino,\n\t\tstruct nfs4_layoutreturn_args *args,\n\t\tstruct nfs4_layoutreturn_res *res,\n\t\tconst struct cred *cred)\n{\n\treturn false;\n}\n\nstatic inline int\npnfs_roc_done(struct rpc_task *task,\n\t\tstruct nfs4_layoutreturn_args **argpp,\n\t\tstruct nfs4_layoutreturn_res **respp,\n\t\tint *ret)\n{\n\treturn 0;\n}\n\nstatic inline void\npnfs_roc_release(struct nfs4_layoutreturn_args *args,\n\t\tstruct nfs4_layoutreturn_res *res,\n\t\tint ret)\n{\n}\n\nstatic inline bool\npnfs_wait_on_layoutreturn(struct inode *ino, struct rpc_task *task)\n{\n\treturn false;\n}\n\nstatic inline void set_pnfs_layoutdriver(struct nfs_server *s,\n\t\t\t\t\t const struct nfs_fh *mntfh,\n\t\t\t\t\t struct nfs_fsinfo *fsinfo)\n{\n}\n\nstatic inline void unset_pnfs_layoutdriver(struct nfs_server *s)\n{\n}\n\nstatic inline int\npnfs_commit_list(struct inode *inode, struct list_head *mds_pages, int how,\n\t\t struct nfs_commit_info *cinfo)\n{\n\treturn PNFS_NOT_ATTEMPTED;\n}\n\nstatic inline struct pnfs_ds_commit_info *\npnfs_get_ds_info(struct inode *inode)\n{\n\treturn NULL;\n}\n\nstatic inline void\npnfs_init_ds_commit_info_ops(struct pnfs_ds_commit_info *fl_cinfo, struct inode *inode)\n{\n}\n\nstatic inline void\npnfs_init_ds_commit_info(struct pnfs_ds_commit_info *fl_cinfo)\n{\n}\n\nstatic inline void\npnfs_release_ds_info(struct pnfs_ds_commit_info *fl_cinfo, struct inode *inode)\n{\n}\n\nstatic inline bool\npnfs_mark_request_commit(struct nfs_page *req, struct pnfs_layout_segment *lseg,\n\t\t\t struct nfs_commit_info *cinfo, u32 ds_commit_idx)\n{\n\treturn false;\n}\n\nstatic inline bool\npnfs_clear_request_commit(struct nfs_page *req, struct nfs_commit_info *cinfo)\n{\n\treturn false;\n}\n\nstatic inline int\npnfs_scan_commit_lists(struct inode *inode, struct nfs_commit_info *cinfo,\n\t\t       int max)\n{\n\treturn 0;\n}\n\nstatic inline void\npnfs_recover_commit_reqs(struct list_head *head, struct nfs_commit_info *cinfo)\n{\n}\n\nstatic inline struct nfs_page *\npnfs_search_commit_reqs(struct inode *inode, struct nfs_commit_info *cinfo,\n\t\t\tstruct folio *folio)\n{\n\treturn NULL;\n}\n\nstatic inline int pnfs_layoutcommit_inode(struct inode *inode, bool sync)\n{\n\treturn 0;\n}\n\nstatic inline bool\npnfs_use_threshold(struct nfs4_threshold **dst, struct nfs4_threshold *src,\n\t\t   struct nfs_server *nfss)\n{\n\treturn false;\n}\n\nstatic inline struct nfs4_threshold *pnfs_mdsthreshold_alloc(void)\n{\n\treturn NULL;\n}\n\nstatic inline void nfs4_pnfs_v3_ds_connect_unload(void)\n{\n}\n\nstatic inline bool nfs4_layout_refresh_old_stateid(nfs4_stateid *dst,\n\t\tstruct pnfs_layout_range *dst_range,\n\t\tstruct inode *inode)\n{\n\treturn false;\n}\n\nstatic inline void pnfs_lgopen_prepare(struct nfs4_opendata *data,\n\t\tstruct nfs_open_context *ctx)\n{\n}\n\nstatic inline void pnfs_parse_lgopen(struct inode *ino,\n\t\tstruct nfs4_layoutget *lgp,\n\t\tstruct nfs_open_context *ctx)\n{\n}\n\nstatic inline void nfs4_lgopen_release(struct nfs4_layoutget *lgp)\n{\n}\n\nstatic inline bool pnfs_layout_is_valid(const struct pnfs_layout_hdr *lo)\n{\n\treturn false;\n}\n\n#endif  \n\n#if IS_ENABLED(CONFIG_NFS_V4_2)\nint pnfs_report_layoutstat(struct inode *inode, gfp_t gfp_flags);\n#else\nstatic inline int\npnfs_report_layoutstat(struct inode *inode, gfp_t gfp_flags)\n{\n\treturn 0;\n}\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}