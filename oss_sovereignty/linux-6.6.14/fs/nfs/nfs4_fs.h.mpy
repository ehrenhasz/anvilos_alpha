{
  "module_name": "nfs4_fs.h",
  "hash_id": "1527445207d9482f33199b3ef8e47a39df5a4a61ef7827f481e19796b34465ae",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfs/nfs4_fs.h",
  "human_readable_source": " \n \n\n#ifndef __LINUX_FS_NFS_NFS4_FS_H\n#define __LINUX_FS_NFS_NFS4_FS_H\n\n#if defined(CONFIG_NFS_V4_2)\n#define NFS4_MAX_MINOR_VERSION 2\n#elif defined(CONFIG_NFS_V4_1)\n#define NFS4_MAX_MINOR_VERSION 1\n#else\n#define NFS4_MAX_MINOR_VERSION 0\n#endif\n\n#if IS_ENABLED(CONFIG_NFS_V4)\n\n#define NFS4_MAX_LOOP_ON_RECOVER (10)\n\n#include <linux/seqlock.h>\n#include <linux/filelock.h>\n\nstruct idmap;\n\nenum nfs4_client_state {\n\tNFS4CLNT_MANAGER_RUNNING  = 0,\n\tNFS4CLNT_CHECK_LEASE,\n\tNFS4CLNT_LEASE_EXPIRED,\n\tNFS4CLNT_RECLAIM_REBOOT,\n\tNFS4CLNT_RECLAIM_NOGRACE,\n\tNFS4CLNT_DELEGRETURN,\n\tNFS4CLNT_SESSION_RESET,\n\tNFS4CLNT_LEASE_CONFIRM,\n\tNFS4CLNT_SERVER_SCOPE_MISMATCH,\n\tNFS4CLNT_PURGE_STATE,\n\tNFS4CLNT_BIND_CONN_TO_SESSION,\n\tNFS4CLNT_MOVED,\n\tNFS4CLNT_LEASE_MOVED,\n\tNFS4CLNT_DELEGATION_EXPIRED,\n\tNFS4CLNT_RUN_MANAGER,\n\tNFS4CLNT_MANAGER_AVAILABLE,\n\tNFS4CLNT_RECALL_RUNNING,\n\tNFS4CLNT_RECALL_ANY_LAYOUT_READ,\n\tNFS4CLNT_RECALL_ANY_LAYOUT_RW,\n\tNFS4CLNT_DELEGRETURN_DELAYED,\n};\n\n#define NFS4_RENEW_TIMEOUT\t\t0x01\n#define NFS4_RENEW_DELEGATION_CB\t0x02\n\nstruct nfs_seqid_counter;\nstruct nfs4_minor_version_ops {\n\tu32\tminor_version;\n\tunsigned init_caps;\n\n\tint\t(*init_client)(struct nfs_client *);\n\tvoid\t(*shutdown_client)(struct nfs_client *);\n\tbool\t(*match_stateid)(const nfs4_stateid *,\n\t\t\tconst nfs4_stateid *);\n\tint\t(*find_root_sec)(struct nfs_server *, struct nfs_fh *,\n\t\t\tstruct nfs_fsinfo *);\n\tvoid\t(*free_lock_state)(struct nfs_server *,\n\t\t\tstruct nfs4_lock_state *);\n\tint\t(*test_and_free_expired)(struct nfs_server *,\n\t\t\tnfs4_stateid *, const struct cred *);\n\tstruct nfs_seqid *\n\t\t(*alloc_seqid)(struct nfs_seqid_counter *, gfp_t);\n\tvoid\t(*session_trunk)(struct rpc_clnt *clnt,\n\t\t\tstruct rpc_xprt *xprt, void *data);\n\tconst struct rpc_call_ops *call_sync_ops;\n\tconst struct nfs4_state_recovery_ops *reboot_recovery_ops;\n\tconst struct nfs4_state_recovery_ops *nograce_recovery_ops;\n\tconst struct nfs4_state_maintenance_ops *state_renewal_ops;\n\tconst struct nfs4_mig_recovery_ops *mig_recovery_ops;\n};\n\n#define NFS_SEQID_CONFIRMED 1\nstruct nfs_seqid_counter {\n\tktime_t create_time;\n\tint owner_id;\n\tint flags;\n\tu32 counter;\n\tspinlock_t lock;\t\t \n\tstruct list_head list;\t\t \n\tstruct rpc_wait_queue\twait;\t \n};\n\nstruct nfs_seqid {\n\tstruct nfs_seqid_counter *sequence;\n\tstruct list_head list;\n\tstruct rpc_task *task;\n};\n\nstatic inline void nfs_confirm_seqid(struct nfs_seqid_counter *seqid, int status)\n{\n\tif (seqid_mutating_err(-status))\n\t\tseqid->flags |= NFS_SEQID_CONFIRMED;\n}\n\n \nstruct nfs4_state_owner {\n\tstruct nfs_server    *so_server;\n\tstruct list_head     so_lru;\n\tunsigned long        so_expires;\n\tstruct rb_node\t     so_server_node;\n\n\tconst struct cred    *so_cred;\t  \n\n\tspinlock_t\t     so_lock;\n\tatomic_t\t     so_count;\n\tunsigned long\t     so_flags;\n\tstruct list_head     so_states;\n\tstruct nfs_seqid_counter so_seqid;\n\tseqcount_spinlock_t  so_reclaim_seqcount;\n\tstruct mutex\t     so_delegreturn_mutex;\n};\n\nenum {\n\tNFS_OWNER_RECLAIM_REBOOT,\n\tNFS_OWNER_RECLAIM_NOGRACE\n};\n\n#define NFS_LOCK_NEW\t\t0\n#define NFS_LOCK_RECLAIM\t1\n#define NFS_LOCK_EXPIRED\t2\n\n \n\nstruct nfs4_lock_state {\n\tstruct list_head\tls_locks;\t \n\tstruct nfs4_state *\tls_state;\t \n#define NFS_LOCK_INITIALIZED 0\n#define NFS_LOCK_LOST        1\n#define NFS_LOCK_UNLOCKING   2\n\tunsigned long\t\tls_flags;\n\tstruct nfs_seqid_counter\tls_seqid;\n\tnfs4_stateid\t\tls_stateid;\n\trefcount_t\t\tls_count;\n\tfl_owner_t\t\tls_owner;\n};\n\n \nenum {\n\tLK_STATE_IN_USE,\n\tNFS_DELEGATED_STATE,\t\t \n\tNFS_OPEN_STATE,\t\t\t \n\tNFS_O_RDONLY_STATE,\t\t \n\tNFS_O_WRONLY_STATE,\t\t \n\tNFS_O_RDWR_STATE,\t\t \n\tNFS_STATE_RECLAIM_REBOOT,\t \n\tNFS_STATE_RECLAIM_NOGRACE,\t \n\tNFS_STATE_POSIX_LOCKS,\t\t \n\tNFS_STATE_RECOVERY_FAILED,\t \n\tNFS_STATE_MAY_NOTIFY_LOCK,\t \n\tNFS_STATE_CHANGE_WAIT,\t\t \n\tNFS_CLNT_DST_SSC_COPY_STATE,     \n\tNFS_CLNT_SRC_SSC_COPY_STATE,     \n\tNFS_SRV_SSC_COPY_STATE,\t\t \n};\n\nstruct nfs4_state {\n\tstruct list_head open_states;\t \n\tstruct list_head inode_states;\t \n\tstruct list_head lock_states;\t \n\n\tstruct nfs4_state_owner *owner;\t \n\tstruct inode *inode;\t\t \n\n\tunsigned long flags;\t\t \n\tspinlock_t state_lock;\t\t \n\n\tseqlock_t seqlock;\t\t \n\tnfs4_stateid stateid;\t\t \n\tnfs4_stateid open_stateid;\t \n\n\t \n\tunsigned int n_rdonly;\t\t \n\tunsigned int n_wronly;\t\t \n\tunsigned int n_rdwr;\t\t \n\tfmode_t state;\t\t\t \n\trefcount_t count;\n\n\twait_queue_head_t waitq;\n\tstruct rcu_head rcu_head;\n};\n\n\nstruct nfs4_exception {\n\tstruct nfs4_state *state;\n\tstruct inode *inode;\n\tnfs4_stateid *stateid;\n\tlong timeout;\n\tunsigned char task_is_privileged : 1;\n\tunsigned char delay : 1,\n\t\t      recovering : 1,\n\t\t      retry : 1;\n\tbool interruptible;\n};\n\nstruct nfs4_state_recovery_ops {\n\tint owner_flag_bit;\n\tint state_flag_bit;\n\tint (*recover_open)(struct nfs4_state_owner *, struct nfs4_state *);\n\tint (*recover_lock)(struct nfs4_state *, struct file_lock *);\n\tint (*establish_clid)(struct nfs_client *, const struct cred *);\n\tint (*reclaim_complete)(struct nfs_client *, const struct cred *);\n\tint (*detect_trunking)(struct nfs_client *, struct nfs_client **,\n\t\tconst struct cred *);\n};\n\nstruct nfs4_opendata {\n\tstruct kref kref;\n\tstruct nfs_openargs o_arg;\n\tstruct nfs_openres o_res;\n\tstruct nfs_open_confirmargs c_arg;\n\tstruct nfs_open_confirmres c_res;\n\tstruct nfs4_string owner_name;\n\tstruct nfs4_string group_name;\n\tstruct nfs4_label *a_label;\n\tstruct nfs_fattr f_attr;\n\tstruct dentry *dir;\n\tstruct dentry *dentry;\n\tstruct nfs4_state_owner *owner;\n\tstruct nfs4_state *state;\n\tstruct iattr attrs;\n\tstruct nfs4_layoutget *lgp;\n\tunsigned long timestamp;\n\tbool rpc_done;\n\tbool file_created;\n\tbool is_recover;\n\tbool cancelled;\n\tint rpc_status;\n};\n\nstruct nfs4_add_xprt_data {\n\tstruct nfs_client\t*clp;\n\tconst struct cred\t*cred;\n};\n\nstruct nfs4_state_maintenance_ops {\n\tint (*sched_state_renewal)(struct nfs_client *, const struct cred *, unsigned);\n\tconst struct cred * (*get_state_renewal_cred)(struct nfs_client *);\n\tint (*renew_lease)(struct nfs_client *, const struct cred *);\n};\n\nstruct nfs4_mig_recovery_ops {\n\tint (*get_locations)(struct nfs_server *, struct nfs_fh *,\n\t\tstruct nfs4_fs_locations *, struct page *, const struct cred *);\n\tint (*fsid_present)(struct inode *, const struct cred *);\n};\n\nextern const struct dentry_operations nfs4_dentry_operations;\n\n \nint nfs_atomic_open(struct inode *, struct dentry *, struct file *,\n\t\t    unsigned, umode_t);\n\n \nextern struct file_system_type nfs4_fs_type;\n\n \nstruct rpc_clnt *nfs4_negotiate_security(struct rpc_clnt *, struct inode *,\n\t\t\t\t\t const struct qstr *);\nint nfs4_submount(struct fs_context *, struct nfs_server *);\nint nfs4_replace_transport(struct nfs_server *server,\n\t\t\t\tconst struct nfs4_fs_locations *locations);\nsize_t nfs_parse_server_name(char *string, size_t len, struct sockaddr_storage *ss,\n\t\t\t     size_t salen, struct net *net, int port);\n \nextern int nfs4_handle_exception(struct nfs_server *, int, struct nfs4_exception *);\nextern int nfs4_async_handle_error(struct rpc_task *task,\n\t\t\t\t   struct nfs_server *server,\n\t\t\t\t   struct nfs4_state *state, long *timeout);\nextern int nfs4_call_sync(struct rpc_clnt *, struct nfs_server *,\n\t\t\t  struct rpc_message *, struct nfs4_sequence_args *,\n\t\t\t  struct nfs4_sequence_res *, int);\nextern void nfs4_init_sequence(struct nfs4_sequence_args *, struct nfs4_sequence_res *, int, int);\nextern int nfs4_proc_setclientid(struct nfs_client *, u32, unsigned short, const struct cred *, struct nfs4_setclientid_res *);\nextern int nfs4_proc_setclientid_confirm(struct nfs_client *, struct nfs4_setclientid_res *arg, const struct cred *);\nextern int nfs4_proc_get_rootfh(struct nfs_server *, struct nfs_fh *, struct nfs_fsinfo *, bool);\nextern int nfs4_proc_bind_conn_to_session(struct nfs_client *, const struct cred *cred);\nextern int nfs4_proc_exchange_id(struct nfs_client *clp, const struct cred *cred);\nextern int nfs4_destroy_clientid(struct nfs_client *clp);\nextern int nfs4_init_clientid(struct nfs_client *, const struct cred *);\nextern int nfs41_init_clientid(struct nfs_client *, const struct cred *);\nextern int nfs4_do_close(struct nfs4_state *state, gfp_t gfp_mask, int wait);\nextern int nfs4_server_capabilities(struct nfs_server *server, struct nfs_fh *fhandle);\nextern int nfs4_proc_fs_locations(struct rpc_clnt *, struct inode *, const struct qstr *,\n\t\t\t\t  struct nfs4_fs_locations *, struct page *);\nextern int nfs4_proc_get_locations(struct nfs_server *, struct nfs_fh *,\n\t\t\t\t   struct nfs4_fs_locations *,\n\t\t\t\t   struct page *page, const struct cred *);\nextern int nfs4_proc_fsid_present(struct inode *, const struct cred *);\nextern struct rpc_clnt *nfs4_proc_lookup_mountpoint(struct inode *,\n\t\t\t\t\t\t    struct dentry *,\n\t\t\t\t\t\t    struct nfs_fh *,\n\t\t\t\t\t\t    struct nfs_fattr *);\nextern int nfs4_proc_secinfo(struct inode *, const struct qstr *, struct nfs4_secinfo_flavors *);\nextern const struct xattr_handler *nfs4_xattr_handlers[];\nextern int nfs4_set_rw_stateid(nfs4_stateid *stateid,\n\t\tconst struct nfs_open_context *ctx,\n\t\tconst struct nfs_lock_context *l_ctx,\n\t\tfmode_t fmode);\nextern void nfs4_bitmask_set(__u32 bitmask[], const __u32 src[],\n\t\t\t     struct inode *inode, unsigned long cache_validity);\nextern int nfs4_proc_getattr(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\t\t     struct nfs_fattr *fattr, struct inode *inode);\nextern int update_open_stateid(struct nfs4_state *state,\n\t\t\t\tconst nfs4_stateid *open_stateid,\n\t\t\t\tconst nfs4_stateid *deleg_stateid,\n\t\t\t\tfmode_t fmode);\nextern int nfs4_proc_setlease(struct file *file, int arg,\n\t\t\t      struct file_lock **lease, void **priv);\nextern int nfs4_proc_get_lease_time(struct nfs_client *clp,\n\t\tstruct nfs_fsinfo *fsinfo);\nextern void nfs4_update_changeattr(struct inode *dir,\n\t\t\t\t   struct nfs4_change_info *cinfo,\n\t\t\t\t   unsigned long timestamp,\n\t\t\t\t   unsigned long cache_validity);\nextern int nfs4_buf_to_pages_noslab(const void *buf, size_t buflen,\n\t\t\t\t    struct page **pages);\n\n#if defined(CONFIG_NFS_V4_1)\nextern int nfs41_sequence_done(struct rpc_task *, struct nfs4_sequence_res *);\nextern int nfs4_proc_create_session(struct nfs_client *, const struct cred *);\nextern int nfs4_proc_destroy_session(struct nfs4_session *, const struct cred *);\nextern int nfs4_proc_layoutcommit(struct nfs4_layoutcommit_data *data,\n\t\t\t\t  bool sync);\nextern int nfs4_detect_session_trunking(struct nfs_client *clp,\n\t\tstruct nfs41_exchange_id_res *res, struct rpc_xprt *xprt);\n\nstatic inline bool\nis_ds_only_client(struct nfs_client *clp)\n{\n\treturn (clp->cl_exchange_flags & EXCHGID4_FLAG_MASK_PNFS) ==\n\t\tEXCHGID4_FLAG_USE_PNFS_DS;\n}\n\nstatic inline bool\nis_ds_client(struct nfs_client *clp)\n{\n\treturn clp->cl_exchange_flags & EXCHGID4_FLAG_USE_PNFS_DS;\n}\n\nstatic inline bool\n_nfs4_state_protect(struct nfs_client *clp, unsigned long sp4_mode,\n\t\t    struct rpc_clnt **clntp, struct rpc_message *msg)\n{\n\trpc_authflavor_t flavor;\n\n\tif (sp4_mode == NFS_SP4_MACH_CRED_CLEANUP ||\n\t    sp4_mode == NFS_SP4_MACH_CRED_PNFS_CLEANUP) {\n\t\t \n\t\tif ((*clntp)->cl_auth->au_flavor == RPC_AUTH_UNIX)\n\t\t\treturn false;\n\t}\n\tif (test_bit(sp4_mode, &clp->cl_sp4_flags)) {\n\t\tmsg->rpc_cred = rpc_machine_cred();\n\n\t\tflavor = clp->cl_rpcclient->cl_auth->au_flavor;\n\t\tWARN_ON_ONCE(flavor != RPC_AUTH_GSS_KRB5I &&\n\t\t\t     flavor != RPC_AUTH_GSS_KRB5P);\n\t\t*clntp = clp->cl_rpcclient;\n\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nstatic inline void\nnfs4_state_protect(struct nfs_client *clp, unsigned long sp4_mode,\n\t\t   struct rpc_clnt **clntp, struct rpc_message *msg)\n{\n\t_nfs4_state_protect(clp, sp4_mode, clntp, msg);\n}\n\n \nstatic inline void\nnfs4_state_protect_write(struct nfs_client *clp, struct rpc_clnt **clntp,\n\t\t\t struct rpc_message *msg, struct nfs_pgio_header *hdr)\n{\n\tif (_nfs4_state_protect(clp, NFS_SP4_MACH_CRED_WRITE, clntp, msg) &&\n\t    !test_bit(NFS_SP4_MACH_CRED_COMMIT, &clp->cl_sp4_flags))\n\t\thdr->args.stable = NFS_FILE_SYNC;\n}\n#else  \nstatic inline bool\nis_ds_only_client(struct nfs_client *clp)\n{\n\treturn false;\n}\n\nstatic inline bool\nis_ds_client(struct nfs_client *clp)\n{\n\treturn false;\n}\n\nstatic inline void\nnfs4_state_protect(struct nfs_client *clp, unsigned long sp4_flags,\n\t\t   struct rpc_clnt **clntp, struct rpc_message *msg)\n{\n}\n\nstatic inline void\nnfs4_state_protect_write(struct nfs_client *clp, struct rpc_clnt **clntp,\n\t\t\t struct rpc_message *msg, struct nfs_pgio_header *hdr)\n{\n}\n#endif  \n\nextern const struct nfs4_minor_version_ops *nfs_v4_minor_ops[];\n\nextern const u32 nfs4_fattr_bitmap[3];\nextern const u32 nfs4_statfs_bitmap[3];\nextern const u32 nfs4_pathconf_bitmap[3];\nextern const u32 nfs4_fsinfo_bitmap[3];\nextern const u32 nfs4_fs_locations_bitmap[3];\n\nvoid nfs40_shutdown_client(struct nfs_client *);\nvoid nfs41_shutdown_client(struct nfs_client *);\nint nfs40_init_client(struct nfs_client *);\nint nfs41_init_client(struct nfs_client *);\nvoid nfs4_free_client(struct nfs_client *);\n\nstruct nfs_client *nfs4_alloc_client(const struct nfs_client_initdata *);\n\n \nextern void nfs4_schedule_state_renewal(struct nfs_client *);\nextern void nfs4_kill_renewd(struct nfs_client *);\nextern void nfs4_renew_state(struct work_struct *);\nextern void nfs4_set_lease_period(struct nfs_client *clp, unsigned long lease);\n\n\n \nextern const nfs4_stateid current_stateid;\n\nconst struct cred *nfs4_get_clid_cred(struct nfs_client *clp);\nconst struct cred *nfs4_get_machine_cred(struct nfs_client *clp);\nconst struct cred *nfs4_get_renew_cred(struct nfs_client *clp);\nint nfs4_discover_server_trunking(struct nfs_client *clp,\n\t\t\tstruct nfs_client **);\nint nfs40_discover_server_trunking(struct nfs_client *clp,\n\t\t\tstruct nfs_client **, const struct cred *);\n#if defined(CONFIG_NFS_V4_1)\nint nfs41_discover_server_trunking(struct nfs_client *clp,\n\t\t\tstruct nfs_client **, const struct cred *);\nextern void nfs4_schedule_session_recovery(struct nfs4_session *, int);\nextern void nfs41_notify_server(struct nfs_client *);\nbool nfs4_check_serverowner_major_id(struct nfs41_server_owner *o1,\n\t\t\tstruct nfs41_server_owner *o2);\n#else\nstatic inline void nfs4_schedule_session_recovery(struct nfs4_session *session, int err)\n{\n}\n#endif  \n\nextern struct nfs4_state_owner *nfs4_get_state_owner(struct nfs_server *, const struct cred *, gfp_t);\nextern void nfs4_put_state_owner(struct nfs4_state_owner *);\nextern void nfs4_purge_state_owners(struct nfs_server *, struct list_head *);\nextern void nfs4_free_state_owners(struct list_head *head);\nextern struct nfs4_state * nfs4_get_open_state(struct inode *, struct nfs4_state_owner *);\nextern void nfs4_put_open_state(struct nfs4_state *);\nextern void nfs4_close_state(struct nfs4_state *, fmode_t);\nextern void nfs4_close_sync(struct nfs4_state *, fmode_t);\nextern void nfs4_state_set_mode_locked(struct nfs4_state *, fmode_t);\nextern void nfs_inode_find_state_and_recover(struct inode *inode,\n\t\tconst nfs4_stateid *stateid);\nextern int nfs4_state_mark_reclaim_nograce(struct nfs_client *, struct nfs4_state *);\nextern void nfs4_schedule_lease_recovery(struct nfs_client *);\nextern int nfs4_wait_clnt_recover(struct nfs_client *clp);\nextern int nfs4_client_recover_expired_lease(struct nfs_client *clp);\nextern void nfs4_schedule_state_manager(struct nfs_client *);\nextern void nfs4_schedule_path_down_recovery(struct nfs_client *clp);\nextern int nfs4_schedule_stateid_recovery(const struct nfs_server *, struct nfs4_state *);\nextern int nfs4_schedule_migration_recovery(const struct nfs_server *);\nextern void nfs4_schedule_lease_moved_recovery(struct nfs_client *);\nextern void nfs41_handle_sequence_flag_errors(struct nfs_client *clp, u32 flags, bool);\nextern void nfs41_handle_server_scope(struct nfs_client *,\n\t\t\t\t      struct nfs41_server_scope **);\nextern void nfs4_put_lock_state(struct nfs4_lock_state *lsp);\nextern int nfs4_set_lock_state(struct nfs4_state *state, struct file_lock *fl);\nextern int nfs4_select_rw_stateid(struct nfs4_state *, fmode_t,\n\t\tconst struct nfs_lock_context *, nfs4_stateid *,\n\t\tconst struct cred **);\nextern bool nfs4_copy_open_stateid(nfs4_stateid *dst,\n\t\tstruct nfs4_state *state);\n\nextern struct nfs_seqid *nfs_alloc_seqid(struct nfs_seqid_counter *counter, gfp_t gfp_mask);\nextern int nfs_wait_on_sequence(struct nfs_seqid *seqid, struct rpc_task *task);\nextern void nfs_increment_open_seqid(int status, struct nfs_seqid *seqid);\nextern void nfs_increment_lock_seqid(int status, struct nfs_seqid *seqid);\nextern void nfs_release_seqid(struct nfs_seqid *seqid);\nextern void nfs_free_seqid(struct nfs_seqid *seqid);\nextern int nfs4_setup_sequence(struct nfs_client *client,\n\t\t\t\tstruct nfs4_sequence_args *args,\n\t\t\t\tstruct nfs4_sequence_res *res,\n\t\t\t\tstruct rpc_task *task);\nextern int nfs4_sequence_done(struct rpc_task *task,\n\t\t\t      struct nfs4_sequence_res *res);\n\nextern void nfs4_free_lock_state(struct nfs_server *server, struct nfs4_lock_state *lsp);\nextern int nfs4_proc_commit(struct file *dst, __u64 offset, __u32 count, struct nfs_commitres *res);\nextern const nfs4_stateid zero_stateid;\nextern const nfs4_stateid invalid_stateid;\n\n \nstruct nfs_mount_info;\nextern struct nfs_subversion nfs_v4;\nextern bool nfs4_disable_idmapping;\nextern unsigned short max_session_slots;\nextern unsigned short max_session_cb_slots;\nextern unsigned short send_implementation_id;\nextern bool recover_lost_locks;\n\n#define NFS4_CLIENT_ID_UNIQ_LEN\t\t(64)\nextern char nfs4_client_id_uniquifier[NFS4_CLIENT_ID_UNIQ_LEN];\n\nextern int nfs4_try_get_tree(struct fs_context *);\nextern int nfs4_get_referral_tree(struct fs_context *);\n\n \n#ifdef CONFIG_SYSCTL\nint nfs4_register_sysctl(void);\nvoid nfs4_unregister_sysctl(void);\n#else\nstatic inline int nfs4_register_sysctl(void)\n{\n\treturn 0;\n}\n\nstatic inline void nfs4_unregister_sysctl(void)\n{\n}\n#endif\n\n \nextern const struct rpc_procinfo nfs4_procedures[];\n\n#ifdef CONFIG_NFS_V4_2\nextern const u32 nfs42_maxsetxattr_overhead;\nextern const u32 nfs42_maxgetxattr_overhead;\nextern const u32 nfs42_maxlistxattrs_overhead;\n#endif\n\nstruct nfs4_mount_data;\n\n \nextern const struct svc_version nfs4_callback_version1;\nextern const struct svc_version nfs4_callback_version4;\n\nstatic inline void nfs4_stateid_copy(nfs4_stateid *dst, const nfs4_stateid *src)\n{\n\tmemcpy(dst->data, src->data, sizeof(dst->data));\n\tdst->type = src->type;\n}\n\nstatic inline bool nfs4_stateid_match(const nfs4_stateid *dst, const nfs4_stateid *src)\n{\n\tif (dst->type != src->type)\n\t\treturn false;\n\treturn memcmp(dst->data, src->data, sizeof(dst->data)) == 0;\n}\n\nstatic inline bool nfs4_stateid_match_other(const nfs4_stateid *dst, const nfs4_stateid *src)\n{\n\treturn memcmp(dst->other, src->other, NFS4_STATEID_OTHER_SIZE) == 0;\n}\n\nstatic inline bool nfs4_stateid_is_newer(const nfs4_stateid *s1, const nfs4_stateid *s2)\n{\n\treturn (s32)(be32_to_cpu(s1->seqid) - be32_to_cpu(s2->seqid)) > 0;\n}\n\nstatic inline bool nfs4_stateid_is_next(const nfs4_stateid *s1, const nfs4_stateid *s2)\n{\n\tu32 seq1 = be32_to_cpu(s1->seqid);\n\tu32 seq2 = be32_to_cpu(s2->seqid);\n\n\treturn seq2 == seq1 + 1U || (seq2 == 1U && seq1 == 0xffffffffU);\n}\n\nstatic inline bool nfs4_stateid_match_or_older(const nfs4_stateid *dst, const nfs4_stateid *src)\n{\n\treturn nfs4_stateid_match_other(dst, src) &&\n\t\t!(src->seqid && nfs4_stateid_is_newer(dst, src));\n}\n\nstatic inline void nfs4_stateid_seqid_inc(nfs4_stateid *s1)\n{\n\tu32 seqid = be32_to_cpu(s1->seqid);\n\n\tif (++seqid == 0)\n\t\t++seqid;\n\ts1->seqid = cpu_to_be32(seqid);\n}\n\nstatic inline bool nfs4_valid_open_stateid(const struct nfs4_state *state)\n{\n\treturn test_bit(NFS_STATE_RECOVERY_FAILED, &state->flags) == 0;\n}\n\nstatic inline bool nfs4_state_match_open_stateid_other(const struct nfs4_state *state,\n\t\tconst nfs4_stateid *stateid)\n{\n\treturn test_bit(NFS_OPEN_STATE, &state->flags) &&\n\t\tnfs4_stateid_match_other(&state->open_stateid, stateid);\n}\n\n \n#ifdef CONFIG_NFS_V4_2\nextern int __init nfs4_xattr_cache_init(void);\nextern void nfs4_xattr_cache_exit(void);\nextern void nfs4_xattr_cache_add(struct inode *inode, const char *name,\n\t\t\t\t const char *buf, struct page **pages,\n\t\t\t\t ssize_t buflen);\nextern void nfs4_xattr_cache_remove(struct inode *inode, const char *name);\nextern ssize_t nfs4_xattr_cache_get(struct inode *inode, const char *name,\n\t\t\t\tchar *buf, ssize_t buflen);\nextern void nfs4_xattr_cache_set_list(struct inode *inode, const char *buf,\n\t\t\t\t      ssize_t buflen);\nextern ssize_t nfs4_xattr_cache_list(struct inode *inode, char *buf,\n\t\t\t\t     ssize_t buflen);\nextern void nfs4_xattr_cache_zap(struct inode *inode);\n#else\nstatic inline void nfs4_xattr_cache_zap(struct inode *inode)\n{\n}\n#endif  \n\n#else  \n\n#define nfs4_close_state(a, b) do { } while (0)\n#define nfs4_close_sync(a, b) do { } while (0)\n#define nfs4_state_protect(a, b, c, d) do { } while (0)\n#define nfs4_state_protect_write(a, b, c, d) do { } while (0)\n\n\n#endif  \n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}