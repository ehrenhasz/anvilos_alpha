{
  "module_name": "nfs4idmap.c",
  "hash_id": "ab69bbf5b977d55c4afae3a22b9c4fc621d0dba23b15a648d1c60204bcd5e724",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfs/nfs4idmap.c",
  "human_readable_source": " \n#include <linux/types.h>\n#include <linux/parser.h>\n#include <linux/fs.h>\n#include <net/net_namespace.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_fs_sb.h>\n#include <linux/key.h>\n#include <linux/keyctl.h>\n#include <linux/key-type.h>\n#include <keys/user-type.h>\n#include <keys/request_key_auth-type.h>\n#include <linux/module.h>\n#include <linux/user_namespace.h>\n\n#include \"internal.h\"\n#include \"netns.h\"\n#include \"nfs4idmap.h\"\n#include \"nfs4trace.h\"\n\n#define NFS_UINT_MAXLEN 11\n\nstatic const struct cred *id_resolver_cache;\nstatic struct key_type key_type_id_resolver_legacy;\n\nstruct idmap_legacy_upcalldata {\n\tstruct rpc_pipe_msg pipe_msg;\n\tstruct idmap_msg idmap_msg;\n\tstruct key\t*authkey;\n\tstruct idmap *idmap;\n};\n\nstruct idmap {\n\tstruct rpc_pipe_dir_object idmap_pdo;\n\tstruct rpc_pipe\t\t*idmap_pipe;\n\tstruct idmap_legacy_upcalldata *idmap_upcall_data;\n\tstruct mutex\t\tidmap_mutex;\n\tstruct user_namespace\t*user_ns;\n};\n\nstatic struct user_namespace *idmap_userns(const struct idmap *idmap)\n{\n\tif (idmap && idmap->user_ns)\n\t\treturn idmap->user_ns;\n\treturn &init_user_ns;\n}\n\n \nvoid nfs_fattr_init_names(struct nfs_fattr *fattr,\n\t\tstruct nfs4_string *owner_name,\n\t\tstruct nfs4_string *group_name)\n{\n\tfattr->owner_name = owner_name;\n\tfattr->group_name = group_name;\n}\n\nstatic void nfs_fattr_free_owner_name(struct nfs_fattr *fattr)\n{\n\tfattr->valid &= ~NFS_ATTR_FATTR_OWNER_NAME;\n\tkfree(fattr->owner_name->data);\n}\n\nstatic void nfs_fattr_free_group_name(struct nfs_fattr *fattr)\n{\n\tfattr->valid &= ~NFS_ATTR_FATTR_GROUP_NAME;\n\tkfree(fattr->group_name->data);\n}\n\nstatic bool nfs_fattr_map_owner_name(struct nfs_server *server, struct nfs_fattr *fattr)\n{\n\tstruct nfs4_string *owner = fattr->owner_name;\n\tkuid_t uid;\n\n\tif (!(fattr->valid & NFS_ATTR_FATTR_OWNER_NAME))\n\t\treturn false;\n\tif (nfs_map_name_to_uid(server, owner->data, owner->len, &uid) == 0) {\n\t\tfattr->uid = uid;\n\t\tfattr->valid |= NFS_ATTR_FATTR_OWNER;\n\t}\n\treturn true;\n}\n\nstatic bool nfs_fattr_map_group_name(struct nfs_server *server, struct nfs_fattr *fattr)\n{\n\tstruct nfs4_string *group = fattr->group_name;\n\tkgid_t gid;\n\n\tif (!(fattr->valid & NFS_ATTR_FATTR_GROUP_NAME))\n\t\treturn false;\n\tif (nfs_map_group_to_gid(server, group->data, group->len, &gid) == 0) {\n\t\tfattr->gid = gid;\n\t\tfattr->valid |= NFS_ATTR_FATTR_GROUP;\n\t}\n\treturn true;\n}\n\n \nvoid nfs_fattr_free_names(struct nfs_fattr *fattr)\n{\n\tif (fattr->valid & NFS_ATTR_FATTR_OWNER_NAME)\n\t\tnfs_fattr_free_owner_name(fattr);\n\tif (fattr->valid & NFS_ATTR_FATTR_GROUP_NAME)\n\t\tnfs_fattr_free_group_name(fattr);\n}\n\n \nvoid nfs_fattr_map_and_free_names(struct nfs_server *server, struct nfs_fattr *fattr)\n{\n\tif (nfs_fattr_map_owner_name(server, fattr))\n\t\tnfs_fattr_free_owner_name(fattr);\n\tif (nfs_fattr_map_group_name(server, fattr))\n\t\tnfs_fattr_free_group_name(fattr);\n}\n\nint nfs_map_string_to_numeric(const char *name, size_t namelen, __u32 *res)\n{\n\tunsigned long val;\n\tchar buf[16];\n\n\tif (memchr(name, '@', namelen) != NULL || namelen >= sizeof(buf))\n\t\treturn 0;\n\tmemcpy(buf, name, namelen);\n\tbuf[namelen] = '\\0';\n\tif (kstrtoul(buf, 0, &val) != 0)\n\t\treturn 0;\n\t*res = val;\n\treturn 1;\n}\nEXPORT_SYMBOL_GPL(nfs_map_string_to_numeric);\n\nstatic int nfs_map_numeric_to_string(__u32 id, char *buf, size_t buflen)\n{\n\treturn snprintf(buf, buflen, \"%u\", id);\n}\n\nstatic struct key_type key_type_id_resolver = {\n\t.name\t\t= \"id_resolver\",\n\t.preparse\t= user_preparse,\n\t.free_preparse\t= user_free_preparse,\n\t.instantiate\t= generic_key_instantiate,\n\t.revoke\t\t= user_revoke,\n\t.destroy\t= user_destroy,\n\t.describe\t= user_describe,\n\t.read\t\t= user_read,\n};\n\nint nfs_idmap_init(void)\n{\n\tstruct cred *cred;\n\tstruct key *keyring;\n\tint ret = 0;\n\n\tprintk(KERN_NOTICE \"NFS: Registering the %s key type\\n\",\n\t\tkey_type_id_resolver.name);\n\n\tcred = prepare_kernel_cred(&init_task);\n\tif (!cred)\n\t\treturn -ENOMEM;\n\n\tkeyring = keyring_alloc(\".id_resolver\",\n\t\t\t\tGLOBAL_ROOT_UID, GLOBAL_ROOT_GID, cred,\n\t\t\t\t(KEY_POS_ALL & ~KEY_POS_SETATTR) |\n\t\t\t\tKEY_USR_VIEW | KEY_USR_READ,\n\t\t\t\tKEY_ALLOC_NOT_IN_QUOTA, NULL, NULL);\n\tif (IS_ERR(keyring)) {\n\t\tret = PTR_ERR(keyring);\n\t\tgoto failed_put_cred;\n\t}\n\n\tret = register_key_type(&key_type_id_resolver);\n\tif (ret < 0)\n\t\tgoto failed_put_key;\n\n\tret = register_key_type(&key_type_id_resolver_legacy);\n\tif (ret < 0)\n\t\tgoto failed_reg_legacy;\n\n\tset_bit(KEY_FLAG_ROOT_CAN_CLEAR, &keyring->flags);\n\tcred->thread_keyring = keyring;\n\tcred->jit_keyring = KEY_REQKEY_DEFL_THREAD_KEYRING;\n\tid_resolver_cache = cred;\n\treturn 0;\n\nfailed_reg_legacy:\n\tunregister_key_type(&key_type_id_resolver);\nfailed_put_key:\n\tkey_put(keyring);\nfailed_put_cred:\n\tput_cred(cred);\n\treturn ret;\n}\n\nvoid nfs_idmap_quit(void)\n{\n\tkey_revoke(id_resolver_cache->thread_keyring);\n\tunregister_key_type(&key_type_id_resolver);\n\tunregister_key_type(&key_type_id_resolver_legacy);\n\tput_cred(id_resolver_cache);\n}\n\n \nstatic ssize_t nfs_idmap_get_desc(const char *name, size_t namelen,\n\t\t\t\tconst char *type, size_t typelen, char **desc)\n{\n\tchar *cp;\n\tsize_t desclen = typelen + namelen + 2;\n\n\t*desc = kmalloc(desclen, GFP_KERNEL);\n\tif (!*desc)\n\t\treturn -ENOMEM;\n\n\tcp = *desc;\n\tmemcpy(cp, type, typelen);\n\tcp += typelen;\n\t*cp++ = ':';\n\n\tmemcpy(cp, name, namelen);\n\tcp += namelen;\n\t*cp = '\\0';\n\treturn desclen;\n}\n\nstatic struct key *nfs_idmap_request_key(const char *name, size_t namelen,\n\t\t\t\t\t const char *type, struct idmap *idmap)\n{\n\tchar *desc;\n\tstruct key *rkey = ERR_PTR(-EAGAIN);\n\tssize_t ret;\n\n\tret = nfs_idmap_get_desc(name, namelen, type, strlen(type), &desc);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\tif (!idmap->user_ns || idmap->user_ns == &init_user_ns)\n\t\trkey = request_key(&key_type_id_resolver, desc, \"\");\n\tif (IS_ERR(rkey)) {\n\t\tmutex_lock(&idmap->idmap_mutex);\n\t\trkey = request_key_with_auxdata(&key_type_id_resolver_legacy,\n\t\t\t\t\t\tdesc, NULL, \"\", 0, idmap);\n\t\tmutex_unlock(&idmap->idmap_mutex);\n\t}\n\tif (!IS_ERR(rkey))\n\t\tset_bit(KEY_FLAG_ROOT_CAN_INVAL, &rkey->flags);\n\n\tkfree(desc);\n\treturn rkey;\n}\n\nstatic ssize_t nfs_idmap_get_key(const char *name, size_t namelen,\n\t\t\t\t const char *type, void *data,\n\t\t\t\t size_t data_size, struct idmap *idmap)\n{\n\tconst struct cred *saved_cred;\n\tstruct key *rkey;\n\tconst struct user_key_payload *payload;\n\tssize_t ret;\n\n\tsaved_cred = override_creds(id_resolver_cache);\n\trkey = nfs_idmap_request_key(name, namelen, type, idmap);\n\trevert_creds(saved_cred);\n\n\tif (IS_ERR(rkey)) {\n\t\tret = PTR_ERR(rkey);\n\t\tgoto out;\n\t}\n\n\trcu_read_lock();\n\trkey->perm |= KEY_USR_VIEW;\n\n\tret = key_validate(rkey);\n\tif (ret < 0)\n\t\tgoto out_up;\n\n\tpayload = user_key_payload_rcu(rkey);\n\tif (IS_ERR_OR_NULL(payload)) {\n\t\tret = PTR_ERR(payload);\n\t\tgoto out_up;\n\t}\n\n\tret = payload->datalen;\n\tif (ret > 0 && ret <= data_size)\n\t\tmemcpy(data, payload->data, ret);\n\telse\n\t\tret = -EINVAL;\n\nout_up:\n\trcu_read_unlock();\n\tkey_put(rkey);\nout:\n\treturn ret;\n}\n\n \nstatic ssize_t nfs_idmap_lookup_name(__u32 id, const char *type, char *buf,\n\t\t\t\t     size_t buflen, struct idmap *idmap)\n{\n\tchar id_str[NFS_UINT_MAXLEN];\n\tint id_len;\n\tssize_t ret;\n\n\tid_len = nfs_map_numeric_to_string(id, id_str, sizeof(id_str));\n\tret = nfs_idmap_get_key(id_str, id_len, type, buf, buflen, idmap);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\treturn ret;\n}\n\n \nstatic int nfs_idmap_lookup_id(const char *name, size_t namelen, const char *type,\n\t\t\t       __u32 *id, struct idmap *idmap)\n{\n\tchar id_str[NFS_UINT_MAXLEN];\n\tlong id_long;\n\tssize_t data_size;\n\tint ret = 0;\n\n\tdata_size = nfs_idmap_get_key(name, namelen, type, id_str, NFS_UINT_MAXLEN, idmap);\n\tif (data_size <= 0) {\n\t\tret = -EINVAL;\n\t} else {\n\t\tret = kstrtol(id_str, 10, &id_long);\n\t\tif (!ret)\n\t\t\t*id = (__u32)id_long;\n\t}\n\treturn ret;\n}\n\n \n\nenum {\n\tOpt_find_uid, Opt_find_gid, Opt_find_user, Opt_find_group, Opt_find_err\n};\n\nstatic const match_table_t nfs_idmap_tokens = {\n\t{ Opt_find_uid, \"uid:%s\" },\n\t{ Opt_find_gid, \"gid:%s\" },\n\t{ Opt_find_user, \"user:%s\" },\n\t{ Opt_find_group, \"group:%s\" },\n\t{ Opt_find_err, NULL }\n};\n\nstatic int nfs_idmap_legacy_upcall(struct key *, void *);\nstatic ssize_t idmap_pipe_downcall(struct file *, const char __user *,\n\t\t\t\t   size_t);\nstatic void idmap_release_pipe(struct inode *);\nstatic void idmap_pipe_destroy_msg(struct rpc_pipe_msg *);\n\nstatic const struct rpc_pipe_ops idmap_upcall_ops = {\n\t.upcall\t\t= rpc_pipe_generic_upcall,\n\t.downcall\t= idmap_pipe_downcall,\n\t.release_pipe\t= idmap_release_pipe,\n\t.destroy_msg\t= idmap_pipe_destroy_msg,\n};\n\nstatic struct key_type key_type_id_resolver_legacy = {\n\t.name\t\t= \"id_legacy\",\n\t.preparse\t= user_preparse,\n\t.free_preparse\t= user_free_preparse,\n\t.instantiate\t= generic_key_instantiate,\n\t.revoke\t\t= user_revoke,\n\t.destroy\t= user_destroy,\n\t.describe\t= user_describe,\n\t.read\t\t= user_read,\n\t.request_key\t= nfs_idmap_legacy_upcall,\n};\n\nstatic void nfs_idmap_pipe_destroy(struct dentry *dir,\n\t\tstruct rpc_pipe_dir_object *pdo)\n{\n\tstruct idmap *idmap = pdo->pdo_data;\n\tstruct rpc_pipe *pipe = idmap->idmap_pipe;\n\n\tif (pipe->dentry) {\n\t\trpc_unlink(pipe->dentry);\n\t\tpipe->dentry = NULL;\n\t}\n}\n\nstatic int nfs_idmap_pipe_create(struct dentry *dir,\n\t\tstruct rpc_pipe_dir_object *pdo)\n{\n\tstruct idmap *idmap = pdo->pdo_data;\n\tstruct rpc_pipe *pipe = idmap->idmap_pipe;\n\tstruct dentry *dentry;\n\n\tdentry = rpc_mkpipe_dentry(dir, \"idmap\", idmap, pipe);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\tpipe->dentry = dentry;\n\treturn 0;\n}\n\nstatic const struct rpc_pipe_dir_object_ops nfs_idmap_pipe_dir_object_ops = {\n\t.create = nfs_idmap_pipe_create,\n\t.destroy = nfs_idmap_pipe_destroy,\n};\n\nint\nnfs_idmap_new(struct nfs_client *clp)\n{\n\tstruct idmap *idmap;\n\tstruct rpc_pipe *pipe;\n\tint error;\n\n\tidmap = kzalloc(sizeof(*idmap), GFP_KERNEL);\n\tif (idmap == NULL)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&idmap->idmap_mutex);\n\tidmap->user_ns = get_user_ns(clp->cl_rpcclient->cl_cred->user_ns);\n\n\trpc_init_pipe_dir_object(&idmap->idmap_pdo,\n\t\t\t&nfs_idmap_pipe_dir_object_ops,\n\t\t\tidmap);\n\n\tpipe = rpc_mkpipe_data(&idmap_upcall_ops, 0);\n\tif (IS_ERR(pipe)) {\n\t\terror = PTR_ERR(pipe);\n\t\tgoto err;\n\t}\n\tidmap->idmap_pipe = pipe;\n\n\terror = rpc_add_pipe_dir_object(clp->cl_net,\n\t\t\t&clp->cl_rpcclient->cl_pipedir_objects,\n\t\t\t&idmap->idmap_pdo);\n\tif (error)\n\t\tgoto err_destroy_pipe;\n\n\tclp->cl_idmap = idmap;\n\treturn 0;\nerr_destroy_pipe:\n\trpc_destroy_pipe_data(idmap->idmap_pipe);\nerr:\n\tput_user_ns(idmap->user_ns);\n\tkfree(idmap);\n\treturn error;\n}\n\nvoid\nnfs_idmap_delete(struct nfs_client *clp)\n{\n\tstruct idmap *idmap = clp->cl_idmap;\n\n\tif (!idmap)\n\t\treturn;\n\tclp->cl_idmap = NULL;\n\trpc_remove_pipe_dir_object(clp->cl_net,\n\t\t\t&clp->cl_rpcclient->cl_pipedir_objects,\n\t\t\t&idmap->idmap_pdo);\n\trpc_destroy_pipe_data(idmap->idmap_pipe);\n\tput_user_ns(idmap->user_ns);\n\tkfree(idmap);\n}\n\nstatic int nfs_idmap_prepare_message(char *desc, struct idmap *idmap,\n\t\t\t\t     struct idmap_msg *im,\n\t\t\t\t     struct rpc_pipe_msg *msg)\n{\n\tsubstring_t substr;\n\tint token, ret;\n\n\tim->im_type = IDMAP_TYPE_GROUP;\n\ttoken = match_token(desc, nfs_idmap_tokens, &substr);\n\n\tswitch (token) {\n\tcase Opt_find_uid:\n\t\tim->im_type = IDMAP_TYPE_USER;\n\t\tfallthrough;\n\tcase Opt_find_gid:\n\t\tim->im_conv = IDMAP_CONV_NAMETOID;\n\t\tret = match_strlcpy(im->im_name, &substr, IDMAP_NAMESZ);\n\t\tbreak;\n\n\tcase Opt_find_user:\n\t\tim->im_type = IDMAP_TYPE_USER;\n\t\tfallthrough;\n\tcase Opt_find_group:\n\t\tim->im_conv = IDMAP_CONV_IDTONAME;\n\t\tret = match_int(&substr, &im->im_id);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmsg->data = im;\n\tmsg->len  = sizeof(struct idmap_msg);\n\nout:\n\treturn ret;\n}\n\nstatic bool\nnfs_idmap_prepare_pipe_upcall(struct idmap *idmap,\n\t\tstruct idmap_legacy_upcalldata *data)\n{\n\tif (idmap->idmap_upcall_data != NULL) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn false;\n\t}\n\tidmap->idmap_upcall_data = data;\n\treturn true;\n}\n\nstatic void nfs_idmap_complete_pipe_upcall(struct idmap_legacy_upcalldata *data,\n\t\t\t\t\t   int ret)\n{\n\tcomplete_request_key(data->authkey, ret);\n\tkey_put(data->authkey);\n\tkfree(data);\n}\n\nstatic void nfs_idmap_abort_pipe_upcall(struct idmap *idmap,\n\t\t\t\t\tstruct idmap_legacy_upcalldata *data,\n\t\t\t\t\tint ret)\n{\n\tif (cmpxchg(&idmap->idmap_upcall_data, data, NULL) == data)\n\t\tnfs_idmap_complete_pipe_upcall(data, ret);\n}\n\nstatic int nfs_idmap_legacy_upcall(struct key *authkey, void *aux)\n{\n\tstruct idmap_legacy_upcalldata *data;\n\tstruct request_key_auth *rka = get_request_key_auth(authkey);\n\tstruct rpc_pipe_msg *msg;\n\tstruct idmap_msg *im;\n\tstruct idmap *idmap = aux;\n\tstruct key *key = rka->target_key;\n\tint ret = -ENOKEY;\n\n\tif (!aux)\n\t\tgoto out1;\n\n\t \n\tret = -ENOMEM;\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\tgoto out1;\n\n\tmsg = &data->pipe_msg;\n\tim = &data->idmap_msg;\n\tdata->idmap = idmap;\n\tdata->authkey = key_get(authkey);\n\n\tret = nfs_idmap_prepare_message(key->description, idmap, im, msg);\n\tif (ret < 0)\n\t\tgoto out2;\n\n\tret = -EAGAIN;\n\tif (!nfs_idmap_prepare_pipe_upcall(idmap, data))\n\t\tgoto out2;\n\n\tret = rpc_queue_upcall(idmap->idmap_pipe, msg);\n\tif (ret < 0)\n\t\tnfs_idmap_abort_pipe_upcall(idmap, data, ret);\n\n\treturn ret;\nout2:\n\tkfree(data);\nout1:\n\tcomplete_request_key(authkey, ret);\n\treturn ret;\n}\n\nstatic int nfs_idmap_instantiate(struct key *key, struct key *authkey, char *data, size_t datalen)\n{\n\treturn key_instantiate_and_link(key, data, datalen,\n\t\t\t\t\tid_resolver_cache->thread_keyring,\n\t\t\t\t\tauthkey);\n}\n\nstatic int nfs_idmap_read_and_verify_message(struct idmap_msg *im,\n\t\tstruct idmap_msg *upcall,\n\t\tstruct key *key, struct key *authkey)\n{\n\tchar id_str[NFS_UINT_MAXLEN];\n\tsize_t len;\n\tint ret = -ENOKEY;\n\n\t \n\tif (upcall->im_type != im->im_type || upcall->im_conv != im->im_conv)\n\t\tgoto out;\n\tswitch (im->im_conv) {\n\tcase IDMAP_CONV_NAMETOID:\n\t\tif (strcmp(upcall->im_name, im->im_name) != 0)\n\t\t\tbreak;\n\t\t \n\t\tlen = 1 + nfs_map_numeric_to_string(im->im_id, id_str,\n\t\t\t\t\t\t    sizeof(id_str));\n\t\tret = nfs_idmap_instantiate(key, authkey, id_str, len);\n\t\tbreak;\n\tcase IDMAP_CONV_IDTONAME:\n\t\tif (upcall->im_id != im->im_id)\n\t\t\tbreak;\n\t\tlen = strlen(im->im_name);\n\t\tret = nfs_idmap_instantiate(key, authkey, im->im_name, len);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\nout:\n\treturn ret;\n}\n\nstatic ssize_t\nidmap_pipe_downcall(struct file *filp, const char __user *src, size_t mlen)\n{\n\tstruct request_key_auth *rka;\n\tstruct rpc_inode *rpci = RPC_I(file_inode(filp));\n\tstruct idmap *idmap = (struct idmap *)rpci->private;\n\tstruct idmap_legacy_upcalldata *data;\n\tstruct key *authkey;\n\tstruct idmap_msg im;\n\tsize_t namelen_in;\n\tint ret = -ENOKEY;\n\n\t \n\tdata = xchg(&idmap->idmap_upcall_data, NULL);\n\tif (data == NULL)\n\t\tgoto out_noupcall;\n\n\tauthkey = data->authkey;\n\trka = get_request_key_auth(authkey);\n\n\tif (mlen != sizeof(im)) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\tif (copy_from_user(&im, src, mlen) != 0) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (!(im.im_status & IDMAP_STATUS_SUCCESS)) {\n\t\tret = -ENOKEY;\n\t\tgoto out;\n\t}\n\n\tnamelen_in = strnlen(im.im_name, IDMAP_NAMESZ);\n\tif (namelen_in == 0 || namelen_in == IDMAP_NAMESZ) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = nfs_idmap_read_and_verify_message(&im, &data->idmap_msg,\n\t\t\t\t\t\trka->target_key, authkey);\n\tif (ret >= 0) {\n\t\tkey_set_timeout(rka->target_key, nfs_idmap_cache_timeout);\n\t\tret = mlen;\n\t}\n\nout:\n\tnfs_idmap_complete_pipe_upcall(data, ret);\nout_noupcall:\n\treturn ret;\n}\n\nstatic void\nidmap_pipe_destroy_msg(struct rpc_pipe_msg *msg)\n{\n\tstruct idmap_legacy_upcalldata *data = container_of(msg,\n\t\t\tstruct idmap_legacy_upcalldata,\n\t\t\tpipe_msg);\n\tstruct idmap *idmap = data->idmap;\n\n\tif (msg->errno)\n\t\tnfs_idmap_abort_pipe_upcall(idmap, data, msg->errno);\n}\n\nstatic void\nidmap_release_pipe(struct inode *inode)\n{\n\tstruct rpc_inode *rpci = RPC_I(inode);\n\tstruct idmap *idmap = (struct idmap *)rpci->private;\n\tstruct idmap_legacy_upcalldata *data;\n\n\tdata = xchg(&idmap->idmap_upcall_data, NULL);\n\tif (data)\n\t\tnfs_idmap_complete_pipe_upcall(data, -EPIPE);\n}\n\nint nfs_map_name_to_uid(const struct nfs_server *server, const char *name, size_t namelen, kuid_t *uid)\n{\n\tstruct idmap *idmap = server->nfs_client->cl_idmap;\n\t__u32 id = -1;\n\tint ret = 0;\n\n\tif (!nfs_map_string_to_numeric(name, namelen, &id))\n\t\tret = nfs_idmap_lookup_id(name, namelen, \"uid\", &id, idmap);\n\tif (ret == 0) {\n\t\t*uid = make_kuid(idmap_userns(idmap), id);\n\t\tif (!uid_valid(*uid))\n\t\t\tret = -ERANGE;\n\t}\n\ttrace_nfs4_map_name_to_uid(name, namelen, id, ret);\n\treturn ret;\n}\n\nint nfs_map_group_to_gid(const struct nfs_server *server, const char *name, size_t namelen, kgid_t *gid)\n{\n\tstruct idmap *idmap = server->nfs_client->cl_idmap;\n\t__u32 id = -1;\n\tint ret = 0;\n\n\tif (!nfs_map_string_to_numeric(name, namelen, &id))\n\t\tret = nfs_idmap_lookup_id(name, namelen, \"gid\", &id, idmap);\n\tif (ret == 0) {\n\t\t*gid = make_kgid(idmap_userns(idmap), id);\n\t\tif (!gid_valid(*gid))\n\t\t\tret = -ERANGE;\n\t}\n\ttrace_nfs4_map_group_to_gid(name, namelen, id, ret);\n\treturn ret;\n}\n\nint nfs_map_uid_to_name(const struct nfs_server *server, kuid_t uid, char *buf, size_t buflen)\n{\n\tstruct idmap *idmap = server->nfs_client->cl_idmap;\n\tint ret = -EINVAL;\n\t__u32 id;\n\n\tid = from_kuid_munged(idmap_userns(idmap), uid);\n\tif (!(server->caps & NFS_CAP_UIDGID_NOMAP))\n\t\tret = nfs_idmap_lookup_name(id, \"user\", buf, buflen, idmap);\n\tif (ret < 0)\n\t\tret = nfs_map_numeric_to_string(id, buf, buflen);\n\ttrace_nfs4_map_uid_to_name(buf, ret, id, ret);\n\treturn ret;\n}\nint nfs_map_gid_to_group(const struct nfs_server *server, kgid_t gid, char *buf, size_t buflen)\n{\n\tstruct idmap *idmap = server->nfs_client->cl_idmap;\n\tint ret = -EINVAL;\n\t__u32 id;\n\n\tid = from_kgid_munged(idmap_userns(idmap), gid);\n\tif (!(server->caps & NFS_CAP_UIDGID_NOMAP))\n\t\tret = nfs_idmap_lookup_name(id, \"group\", buf, buflen, idmap);\n\tif (ret < 0)\n\t\tret = nfs_map_numeric_to_string(id, buf, buflen);\n\ttrace_nfs4_map_gid_to_group(buf, ret, id, ret);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}