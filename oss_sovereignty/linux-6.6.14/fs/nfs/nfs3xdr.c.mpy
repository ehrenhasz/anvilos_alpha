{
  "module_name": "nfs3xdr.c",
  "hash_id": "5757616ed0b947b0e63cc8e660091f976768221a0023aa16019d7dffc02dec7a",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfs/nfs3xdr.c",
  "human_readable_source": "\n \n\n#include <linux/param.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/in.h>\n#include <linux/pagemap.h>\n#include <linux/proc_fs.h>\n#include <linux/kdev_t.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/nfs.h>\n#include <linux/nfs3.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfsacl.h>\n#include \"nfstrace.h\"\n#include \"internal.h\"\n\n#define NFSDBG_FACILITY\t\tNFSDBG_XDR\n\n \n#define errno_NFSERR_IO\t\tEIO\n\n \n#define NFS3_pagepad_sz\t\t(1)  \n#define NFS3_fhandle_sz\t\t(1+16)\n#define NFS3_fh_sz\t\t(NFS3_fhandle_sz)\t \n#define NFS3_post_op_fh_sz\t(1+NFS3_fh_sz)\n#define NFS3_sattr_sz\t\t(15)\n#define NFS3_filename_sz\t(1+(NFS3_MAXNAMLEN>>2))\n#define NFS3_path_sz\t\t(1+(NFS3_MAXPATHLEN>>2))\n#define NFS3_fattr_sz\t\t(21)\n#define NFS3_cookieverf_sz\t(NFS3_COOKIEVERFSIZE>>2)\n#define NFS3_wcc_attr_sz\t(6)\n#define NFS3_pre_op_attr_sz\t(1+NFS3_wcc_attr_sz)\n#define NFS3_post_op_attr_sz\t(1+NFS3_fattr_sz)\n#define NFS3_wcc_data_sz\t(NFS3_pre_op_attr_sz+NFS3_post_op_attr_sz)\n#define NFS3_diropargs_sz\t(NFS3_fh_sz+NFS3_filename_sz)\n\n#define NFS3_getattrargs_sz\t(NFS3_fh_sz)\n#define NFS3_setattrargs_sz\t(NFS3_fh_sz+NFS3_sattr_sz+3)\n#define NFS3_lookupargs_sz\t(NFS3_fh_sz+NFS3_filename_sz)\n#define NFS3_accessargs_sz\t(NFS3_fh_sz+1)\n#define NFS3_readlinkargs_sz\t(NFS3_fh_sz)\n#define NFS3_readargs_sz\t(NFS3_fh_sz+3)\n#define NFS3_writeargs_sz\t(NFS3_fh_sz+5)\n#define NFS3_createargs_sz\t(NFS3_diropargs_sz+NFS3_sattr_sz)\n#define NFS3_mkdirargs_sz\t(NFS3_diropargs_sz+NFS3_sattr_sz)\n#define NFS3_symlinkargs_sz\t(NFS3_diropargs_sz+1+NFS3_sattr_sz)\n#define NFS3_mknodargs_sz\t(NFS3_diropargs_sz+2+NFS3_sattr_sz)\n#define NFS3_removeargs_sz\t(NFS3_fh_sz+NFS3_filename_sz)\n#define NFS3_renameargs_sz\t(NFS3_diropargs_sz+NFS3_diropargs_sz)\n#define NFS3_linkargs_sz\t\t(NFS3_fh_sz+NFS3_diropargs_sz)\n#define NFS3_readdirargs_sz\t(NFS3_fh_sz+NFS3_cookieverf_sz+3)\n#define NFS3_readdirplusargs_sz\t(NFS3_fh_sz+NFS3_cookieverf_sz+4)\n#define NFS3_commitargs_sz\t(NFS3_fh_sz+3)\n\n#define NFS3_getattrres_sz\t(1+NFS3_fattr_sz)\n#define NFS3_setattrres_sz\t(1+NFS3_wcc_data_sz)\n#define NFS3_removeres_sz\t(NFS3_setattrres_sz)\n#define NFS3_lookupres_sz\t(1+NFS3_fh_sz+(2 * NFS3_post_op_attr_sz))\n#define NFS3_accessres_sz\t(1+NFS3_post_op_attr_sz+1)\n#define NFS3_readlinkres_sz\t(1+NFS3_post_op_attr_sz+1+NFS3_pagepad_sz)\n#define NFS3_readres_sz\t\t(1+NFS3_post_op_attr_sz+3+NFS3_pagepad_sz)\n#define NFS3_writeres_sz\t(1+NFS3_wcc_data_sz+4)\n#define NFS3_createres_sz\t(1+NFS3_post_op_fh_sz+NFS3_post_op_attr_sz+NFS3_wcc_data_sz)\n#define NFS3_renameres_sz\t(1+(2 * NFS3_wcc_data_sz))\n#define NFS3_linkres_sz\t\t(1+NFS3_post_op_attr_sz+NFS3_wcc_data_sz)\n#define NFS3_readdirres_sz\t(1+NFS3_post_op_attr_sz+2+NFS3_pagepad_sz)\n#define NFS3_fsstatres_sz\t(1+NFS3_post_op_attr_sz+13)\n#define NFS3_fsinfores_sz\t(1+NFS3_post_op_attr_sz+12)\n#define NFS3_pathconfres_sz\t(1+NFS3_post_op_attr_sz+6)\n#define NFS3_commitres_sz\t(1+NFS3_wcc_data_sz+2)\n\n#define ACL3_getaclargs_sz\t(NFS3_fh_sz+1)\n#define ACL3_setaclargs_sz\t(NFS3_fh_sz+1+ \\\n\t\t\t\tXDR_QUADLEN(NFS_ACL_INLINE_BUFSIZE))\n#define ACL3_getaclres_sz\t(1+NFS3_post_op_attr_sz+1+ \\\n\t\t\t\tXDR_QUADLEN(NFS_ACL_INLINE_BUFSIZE)+\\\n\t\t\t\tNFS3_pagepad_sz)\n#define ACL3_setaclres_sz\t(1+NFS3_post_op_attr_sz)\n\nstatic int nfs3_stat_to_errno(enum nfs_stat);\n\n \nstatic const umode_t nfs_type2fmt[] = {\n\t[NF3BAD] = 0,\n\t[NF3REG] = S_IFREG,\n\t[NF3DIR] = S_IFDIR,\n\t[NF3BLK] = S_IFBLK,\n\t[NF3CHR] = S_IFCHR,\n\t[NF3LNK] = S_IFLNK,\n\t[NF3SOCK] = S_IFSOCK,\n\t[NF3FIFO] = S_IFIFO,\n};\n\nstatic struct user_namespace *rpc_userns(const struct rpc_clnt *clnt)\n{\n\tif (clnt && clnt->cl_cred)\n\t\treturn clnt->cl_cred->user_ns;\n\treturn &init_user_ns;\n}\n\nstatic struct user_namespace *rpc_rqst_userns(const struct rpc_rqst *rqstp)\n{\n\tif (rqstp->rq_task)\n\t\treturn rpc_userns(rqstp->rq_task->tk_client);\n\treturn &init_user_ns;\n}\n\n \n\nstatic void encode_uint32(struct xdr_stream *xdr, u32 value)\n{\n\t__be32 *p = xdr_reserve_space(xdr, 4);\n\t*p = cpu_to_be32(value);\n}\n\nstatic int decode_uint32(struct xdr_stream *xdr, u32 *value)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\t*value = be32_to_cpup(p);\n\treturn 0;\n}\n\nstatic int decode_uint64(struct xdr_stream *xdr, u64 *value)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 8);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\txdr_decode_hyper(p, value);\n\treturn 0;\n}\n\n \nstatic __be32 *xdr_decode_fileid3(__be32 *p, u64 *fileid)\n{\n\treturn xdr_decode_hyper(p, fileid);\n}\n\nstatic int decode_fileid3(struct xdr_stream *xdr, u64 *fileid)\n{\n\treturn decode_uint64(xdr, fileid);\n}\n\n \nstatic void encode_filename3(struct xdr_stream *xdr,\n\t\t\t     const char *name, u32 length)\n{\n\t__be32 *p;\n\n\tWARN_ON_ONCE(length > NFS3_MAXNAMLEN);\n\tp = xdr_reserve_space(xdr, 4 + length);\n\txdr_encode_opaque(p, name, length);\n}\n\nstatic int decode_inline_filename3(struct xdr_stream *xdr,\n\t\t\t\t   const char **name, u32 *length)\n{\n\t__be32 *p;\n\tu32 count;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tcount = be32_to_cpup(p);\n\tif (count > NFS3_MAXNAMLEN)\n\t\tgoto out_nametoolong;\n\tp = xdr_inline_decode(xdr, count);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\t*name = (const char *)p;\n\t*length = count;\n\treturn 0;\n\nout_nametoolong:\n\tdprintk(\"NFS: returned filename too long: %u\\n\", count);\n\treturn -ENAMETOOLONG;\n}\n\n \nstatic void encode_nfspath3(struct xdr_stream *xdr, struct page **pages,\n\t\t\t    const u32 length)\n{\n\tencode_uint32(xdr, length);\n\txdr_write_pages(xdr, pages, 0, length);\n}\n\nstatic int decode_nfspath3(struct xdr_stream *xdr)\n{\n\tu32 recvd, count;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tcount = be32_to_cpup(p);\n\tif (unlikely(count >= xdr->buf->page_len || count > NFS3_MAXPATHLEN))\n\t\tgoto out_nametoolong;\n\trecvd = xdr_read_pages(xdr, count);\n\tif (unlikely(count > recvd))\n\t\tgoto out_cheating;\n\txdr_terminate_string(xdr->buf, count);\n\treturn 0;\n\nout_nametoolong:\n\tdprintk(\"NFS: returned pathname too long: %u\\n\", count);\n\treturn -ENAMETOOLONG;\nout_cheating:\n\tdprintk(\"NFS: server cheating in pathname result: \"\n\t\t\"count %u > recvd %u\\n\", count, recvd);\n\treturn -EIO;\n}\n\n \nstatic __be32 *xdr_encode_cookie3(__be32 *p, u64 cookie)\n{\n\treturn xdr_encode_hyper(p, cookie);\n}\n\nstatic int decode_cookie3(struct xdr_stream *xdr, u64 *cookie)\n{\n\treturn decode_uint64(xdr, cookie);\n}\n\n \nstatic __be32 *xdr_encode_cookieverf3(__be32 *p, const __be32 *verifier)\n{\n\tmemcpy(p, verifier, NFS3_COOKIEVERFSIZE);\n\treturn p + XDR_QUADLEN(NFS3_COOKIEVERFSIZE);\n}\n\nstatic int decode_cookieverf3(struct xdr_stream *xdr, __be32 *verifier)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, NFS3_COOKIEVERFSIZE);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tmemcpy(verifier, p, NFS3_COOKIEVERFSIZE);\n\treturn 0;\n}\n\n \nstatic void encode_createverf3(struct xdr_stream *xdr, const __be32 *verifier)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, NFS3_CREATEVERFSIZE);\n\tmemcpy(p, verifier, NFS3_CREATEVERFSIZE);\n}\n\nstatic int decode_writeverf3(struct xdr_stream *xdr, struct nfs_write_verifier *verifier)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, NFS3_WRITEVERFSIZE);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tmemcpy(verifier->data, p, NFS3_WRITEVERFSIZE);\n\treturn 0;\n}\n\n \nstatic __be32 *xdr_decode_size3(__be32 *p, u64 *size)\n{\n\treturn xdr_decode_hyper(p, size);\n}\n\n \n#define NFS3_OK\t\tNFS_OK\n\nstatic int decode_nfsstat3(struct xdr_stream *xdr, enum nfs_stat *status)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tif (unlikely(*p != cpu_to_be32(NFS3_OK)))\n\t\tgoto out_status;\n\t*status = 0;\n\treturn 0;\nout_status:\n\t*status = be32_to_cpup(p);\n\ttrace_nfs_xdr_status(xdr, (int)*status);\n\treturn 0;\n}\n\n \nstatic void encode_ftype3(struct xdr_stream *xdr, const u32 type)\n{\n\tencode_uint32(xdr, type);\n}\n\nstatic __be32 *xdr_decode_ftype3(__be32 *p, umode_t *mode)\n{\n\tu32 type;\n\n\ttype = be32_to_cpup(p++);\n\tif (type > NF3FIFO)\n\t\ttype = NF3NON;\n\t*mode = nfs_type2fmt[type];\n\treturn p;\n}\n\n \nstatic void encode_specdata3(struct xdr_stream *xdr, const dev_t rdev)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 8);\n\t*p++ = cpu_to_be32(MAJOR(rdev));\n\t*p = cpu_to_be32(MINOR(rdev));\n}\n\nstatic __be32 *xdr_decode_specdata3(__be32 *p, dev_t *rdev)\n{\n\tunsigned int major, minor;\n\n\tmajor = be32_to_cpup(p++);\n\tminor = be32_to_cpup(p++);\n\t*rdev = MKDEV(major, minor);\n\tif (MAJOR(*rdev) != major || MINOR(*rdev) != minor)\n\t\t*rdev = 0;\n\treturn p;\n}\n\n \nstatic void encode_nfs_fh3(struct xdr_stream *xdr, const struct nfs_fh *fh)\n{\n\t__be32 *p;\n\n\tWARN_ON_ONCE(fh->size > NFS3_FHSIZE);\n\tp = xdr_reserve_space(xdr, 4 + fh->size);\n\txdr_encode_opaque(p, fh->data, fh->size);\n}\n\nstatic int decode_nfs_fh3(struct xdr_stream *xdr, struct nfs_fh *fh)\n{\n\tu32 length;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tlength = be32_to_cpup(p++);\n\tif (unlikely(length > NFS3_FHSIZE || length == 0))\n\t\tgoto out_toobig;\n\tp = xdr_inline_decode(xdr, length);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tfh->size = length;\n\tmemcpy(fh->data, p, length);\n\treturn 0;\nout_toobig:\n\ttrace_nfs_xdr_bad_filehandle(xdr, NFSERR_BADHANDLE);\n\treturn -E2BIG;\n}\n\nstatic void zero_nfs_fh3(struct nfs_fh *fh)\n{\n\tmemset(fh, 0, sizeof(*fh));\n}\n\n \nstatic __be32 *xdr_encode_nfstime3(__be32 *p, const struct timespec64 *timep)\n{\n\t*p++ = cpu_to_be32((u32)timep->tv_sec);\n\t*p++ = cpu_to_be32(timep->tv_nsec);\n\treturn p;\n}\n\nstatic __be32 *xdr_decode_nfstime3(__be32 *p, struct timespec64 *timep)\n{\n\ttimep->tv_sec = be32_to_cpup(p++);\n\ttimep->tv_nsec = be32_to_cpup(p++);\n\treturn p;\n}\n\n \nstatic void encode_sattr3(struct xdr_stream *xdr, const struct iattr *attr,\n\t\tstruct user_namespace *userns)\n{\n\tu32 nbytes;\n\t__be32 *p;\n\n\t \n\tnbytes = 6 * 4;\n\tif (attr->ia_valid & ATTR_MODE)\n\t\tnbytes += 4;\n\tif (attr->ia_valid & ATTR_UID)\n\t\tnbytes += 4;\n\tif (attr->ia_valid & ATTR_GID)\n\t\tnbytes += 4;\n\tif (attr->ia_valid & ATTR_SIZE)\n\t\tnbytes += 8;\n\tif (attr->ia_valid & ATTR_ATIME_SET)\n\t\tnbytes += 8;\n\tif (attr->ia_valid & ATTR_MTIME_SET)\n\t\tnbytes += 8;\n\tp = xdr_reserve_space(xdr, nbytes);\n\n\tif (attr->ia_valid & ATTR_MODE) {\n\t\t*p++ = xdr_one;\n\t\t*p++ = cpu_to_be32(attr->ia_mode & S_IALLUGO);\n\t} else\n\t\t*p++ = xdr_zero;\n\n\tif (attr->ia_valid & ATTR_UID) {\n\t\t*p++ = xdr_one;\n\t\t*p++ = cpu_to_be32(from_kuid_munged(userns, attr->ia_uid));\n\t} else\n\t\t*p++ = xdr_zero;\n\n\tif (attr->ia_valid & ATTR_GID) {\n\t\t*p++ = xdr_one;\n\t\t*p++ = cpu_to_be32(from_kgid_munged(userns, attr->ia_gid));\n\t} else\n\t\t*p++ = xdr_zero;\n\n\tif (attr->ia_valid & ATTR_SIZE) {\n\t\t*p++ = xdr_one;\n\t\tp = xdr_encode_hyper(p, (u64)attr->ia_size);\n\t} else\n\t\t*p++ = xdr_zero;\n\n\tif (attr->ia_valid & ATTR_ATIME_SET) {\n\t\t*p++ = xdr_two;\n\t\tp = xdr_encode_nfstime3(p, &attr->ia_atime);\n\t} else if (attr->ia_valid & ATTR_ATIME) {\n\t\t*p++ = xdr_one;\n\t} else\n\t\t*p++ = xdr_zero;\n\n\tif (attr->ia_valid & ATTR_MTIME_SET) {\n\t\t*p++ = xdr_two;\n\t\txdr_encode_nfstime3(p, &attr->ia_mtime);\n\t} else if (attr->ia_valid & ATTR_MTIME) {\n\t\t*p = xdr_one;\n\t} else\n\t\t*p = xdr_zero;\n}\n\n \nstatic int decode_fattr3(struct xdr_stream *xdr, struct nfs_fattr *fattr,\n\t\tstruct user_namespace *userns)\n{\n\tumode_t fmode;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, NFS3_fattr_sz << 2);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\n\tp = xdr_decode_ftype3(p, &fmode);\n\n\tfattr->mode = (be32_to_cpup(p++) & ~S_IFMT) | fmode;\n\tfattr->nlink = be32_to_cpup(p++);\n\tfattr->uid = make_kuid(userns, be32_to_cpup(p++));\n\tif (!uid_valid(fattr->uid))\n\t\tgoto out_uid;\n\tfattr->gid = make_kgid(userns, be32_to_cpup(p++));\n\tif (!gid_valid(fattr->gid))\n\t\tgoto out_gid;\n\n\tp = xdr_decode_size3(p, &fattr->size);\n\tp = xdr_decode_size3(p, &fattr->du.nfs3.used);\n\tp = xdr_decode_specdata3(p, &fattr->rdev);\n\n\tp = xdr_decode_hyper(p, &fattr->fsid.major);\n\tfattr->fsid.minor = 0;\n\n\tp = xdr_decode_fileid3(p, &fattr->fileid);\n\tp = xdr_decode_nfstime3(p, &fattr->atime);\n\tp = xdr_decode_nfstime3(p, &fattr->mtime);\n\txdr_decode_nfstime3(p, &fattr->ctime);\n\tfattr->change_attr = nfs_timespec_to_change_attr(&fattr->ctime);\n\n\tfattr->valid |= NFS_ATTR_FATTR_V3;\n\treturn 0;\nout_uid:\n\tdprintk(\"NFS: returned invalid uid\\n\");\n\treturn -EINVAL;\nout_gid:\n\tdprintk(\"NFS: returned invalid gid\\n\");\n\treturn -EINVAL;\n}\n\n \nstatic int decode_post_op_attr(struct xdr_stream *xdr, struct nfs_fattr *fattr,\n\t\tstruct user_namespace *userns)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tif (*p != xdr_zero)\n\t\treturn decode_fattr3(xdr, fattr, userns);\n\treturn 0;\n}\n\n \nstatic int decode_wcc_attr(struct xdr_stream *xdr, struct nfs_fattr *fattr)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, NFS3_wcc_attr_sz << 2);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\n\tfattr->valid |= NFS_ATTR_FATTR_PRESIZE\n\t\t| NFS_ATTR_FATTR_PRECHANGE\n\t\t| NFS_ATTR_FATTR_PREMTIME\n\t\t| NFS_ATTR_FATTR_PRECTIME;\n\n\tp = xdr_decode_size3(p, &fattr->pre_size);\n\tp = xdr_decode_nfstime3(p, &fattr->pre_mtime);\n\txdr_decode_nfstime3(p, &fattr->pre_ctime);\n\tfattr->pre_change_attr = nfs_timespec_to_change_attr(&fattr->pre_ctime);\n\n\treturn 0;\n}\n\n \nstatic int decode_pre_op_attr(struct xdr_stream *xdr, struct nfs_fattr *fattr)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tif (*p != xdr_zero)\n\t\treturn decode_wcc_attr(xdr, fattr);\n\treturn 0;\n}\n\nstatic int decode_wcc_data(struct xdr_stream *xdr, struct nfs_fattr *fattr,\n\t\tstruct user_namespace *userns)\n{\n\tint error;\n\n\terror = decode_pre_op_attr(xdr, fattr);\n\tif (unlikely(error))\n\t\tgoto out;\n\terror = decode_post_op_attr(xdr, fattr, userns);\nout:\n\treturn error;\n}\n\n \nstatic int decode_post_op_fh3(struct xdr_stream *xdr, struct nfs_fh *fh)\n{\n\t__be32 *p = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tif (*p != xdr_zero)\n\t\treturn decode_nfs_fh3(xdr, fh);\n\tzero_nfs_fh3(fh);\n\treturn 0;\n}\n\n \nstatic void encode_diropargs3(struct xdr_stream *xdr, const struct nfs_fh *fh,\n\t\t\t      const char *name, u32 length)\n{\n\tencode_nfs_fh3(xdr, fh);\n\tencode_filename3(xdr, name, length);\n}\n\n\n \n\n \nstatic void nfs3_xdr_enc_getattr3args(struct rpc_rqst *req,\n\t\t\t\t      struct xdr_stream *xdr,\n\t\t\t\t      const void *data)\n{\n\tconst struct nfs_fh *fh = data;\n\n\tencode_nfs_fh3(xdr, fh);\n}\n\n \nstatic void encode_sattrguard3(struct xdr_stream *xdr,\n\t\t\t       const struct nfs3_sattrargs *args)\n{\n\t__be32 *p;\n\n\tif (args->guard) {\n\t\tp = xdr_reserve_space(xdr, 4 + 8);\n\t\t*p++ = xdr_one;\n\t\txdr_encode_nfstime3(p, &args->guardtime);\n\t} else {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\t*p = xdr_zero;\n\t}\n}\n\nstatic void nfs3_xdr_enc_setattr3args(struct rpc_rqst *req,\n\t\t\t\t      struct xdr_stream *xdr,\n\t\t\t\t      const void *data)\n{\n\tconst struct nfs3_sattrargs *args = data;\n\tencode_nfs_fh3(xdr, args->fh);\n\tencode_sattr3(xdr, args->sattr, rpc_rqst_userns(req));\n\tencode_sattrguard3(xdr, args);\n}\n\n \nstatic void nfs3_xdr_enc_lookup3args(struct rpc_rqst *req,\n\t\t\t\t     struct xdr_stream *xdr,\n\t\t\t\t     const void *data)\n{\n\tconst struct nfs3_diropargs *args = data;\n\n\tencode_diropargs3(xdr, args->fh, args->name, args->len);\n}\n\n \nstatic void encode_access3args(struct xdr_stream *xdr,\n\t\t\t       const struct nfs3_accessargs *args)\n{\n\tencode_nfs_fh3(xdr, args->fh);\n\tencode_uint32(xdr, args->access);\n}\n\nstatic void nfs3_xdr_enc_access3args(struct rpc_rqst *req,\n\t\t\t\t     struct xdr_stream *xdr,\n\t\t\t\t     const void *data)\n{\n\tconst struct nfs3_accessargs *args = data;\n\n\tencode_access3args(xdr, args);\n}\n\n \nstatic void nfs3_xdr_enc_readlink3args(struct rpc_rqst *req,\n\t\t\t\t       struct xdr_stream *xdr,\n\t\t\t\t       const void *data)\n{\n\tconst struct nfs3_readlinkargs *args = data;\n\n\tencode_nfs_fh3(xdr, args->fh);\n\trpc_prepare_reply_pages(req, args->pages, args->pgbase, args->pglen,\n\t\t\t\tNFS3_readlinkres_sz - NFS3_pagepad_sz);\n}\n\n \nstatic void encode_read3args(struct xdr_stream *xdr,\n\t\t\t     const struct nfs_pgio_args *args)\n{\n\t__be32 *p;\n\n\tencode_nfs_fh3(xdr, args->fh);\n\n\tp = xdr_reserve_space(xdr, 8 + 4);\n\tp = xdr_encode_hyper(p, args->offset);\n\t*p = cpu_to_be32(args->count);\n}\n\nstatic void nfs3_xdr_enc_read3args(struct rpc_rqst *req,\n\t\t\t\t   struct xdr_stream *xdr,\n\t\t\t\t   const void *data)\n{\n\tconst struct nfs_pgio_args *args = data;\n\tunsigned int replen = args->replen ? args->replen :\n\t\t\t\t\t     NFS3_readres_sz - NFS3_pagepad_sz;\n\n\tencode_read3args(xdr, args);\n\trpc_prepare_reply_pages(req, args->pages, args->pgbase,\n\t\t\t\targs->count, replen);\n\treq->rq_rcv_buf.flags |= XDRBUF_READ;\n}\n\n \nstatic void encode_write3args(struct xdr_stream *xdr,\n\t\t\t      const struct nfs_pgio_args *args)\n{\n\t__be32 *p;\n\n\tencode_nfs_fh3(xdr, args->fh);\n\n\tp = xdr_reserve_space(xdr, 8 + 4 + 4 + 4);\n\tp = xdr_encode_hyper(p, args->offset);\n\t*p++ = cpu_to_be32(args->count);\n\t*p++ = cpu_to_be32(args->stable);\n\t*p = cpu_to_be32(args->count);\n\txdr_write_pages(xdr, args->pages, args->pgbase, args->count);\n}\n\nstatic void nfs3_xdr_enc_write3args(struct rpc_rqst *req,\n\t\t\t\t    struct xdr_stream *xdr,\n\t\t\t\t    const void *data)\n{\n\tconst struct nfs_pgio_args *args = data;\n\n\tencode_write3args(xdr, args);\n\txdr->buf->flags |= XDRBUF_WRITE;\n}\n\n \nstatic void encode_createhow3(struct xdr_stream *xdr,\n\t\t\t      const struct nfs3_createargs *args,\n\t\t\t      struct user_namespace *userns)\n{\n\tencode_uint32(xdr, args->createmode);\n\tswitch (args->createmode) {\n\tcase NFS3_CREATE_UNCHECKED:\n\tcase NFS3_CREATE_GUARDED:\n\t\tencode_sattr3(xdr, args->sattr, userns);\n\t\tbreak;\n\tcase NFS3_CREATE_EXCLUSIVE:\n\t\tencode_createverf3(xdr, args->verifier);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}\n\nstatic void nfs3_xdr_enc_create3args(struct rpc_rqst *req,\n\t\t\t\t     struct xdr_stream *xdr,\n\t\t\t\t     const void *data)\n{\n\tconst struct nfs3_createargs *args = data;\n\n\tencode_diropargs3(xdr, args->fh, args->name, args->len);\n\tencode_createhow3(xdr, args, rpc_rqst_userns(req));\n}\n\n \nstatic void nfs3_xdr_enc_mkdir3args(struct rpc_rqst *req,\n\t\t\t\t    struct xdr_stream *xdr,\n\t\t\t\t    const void *data)\n{\n\tconst struct nfs3_mkdirargs *args = data;\n\n\tencode_diropargs3(xdr, args->fh, args->name, args->len);\n\tencode_sattr3(xdr, args->sattr, rpc_rqst_userns(req));\n}\n\n \nstatic void encode_symlinkdata3(struct xdr_stream *xdr,\n\t\t\t\tconst void *data,\n\t\t\t\tstruct user_namespace *userns)\n{\n\tconst struct nfs3_symlinkargs *args = data;\n\n\tencode_sattr3(xdr, args->sattr, userns);\n\tencode_nfspath3(xdr, args->pages, args->pathlen);\n}\n\nstatic void nfs3_xdr_enc_symlink3args(struct rpc_rqst *req,\n\t\t\t\t      struct xdr_stream *xdr,\n\t\t\t\t      const void *data)\n{\n\tconst struct nfs3_symlinkargs *args = data;\n\n\tencode_diropargs3(xdr, args->fromfh, args->fromname, args->fromlen);\n\tencode_symlinkdata3(xdr, args, rpc_rqst_userns(req));\n\txdr->buf->flags |= XDRBUF_WRITE;\n}\n\n \nstatic void encode_devicedata3(struct xdr_stream *xdr,\n\t\t\t       const struct nfs3_mknodargs *args,\n\t\t\t       struct user_namespace *userns)\n{\n\tencode_sattr3(xdr, args->sattr, userns);\n\tencode_specdata3(xdr, args->rdev);\n}\n\nstatic void encode_mknoddata3(struct xdr_stream *xdr,\n\t\t\t      const struct nfs3_mknodargs *args,\n\t\t\t      struct user_namespace *userns)\n{\n\tencode_ftype3(xdr, args->type);\n\tswitch (args->type) {\n\tcase NF3CHR:\n\tcase NF3BLK:\n\t\tencode_devicedata3(xdr, args, userns);\n\t\tbreak;\n\tcase NF3SOCK:\n\tcase NF3FIFO:\n\t\tencode_sattr3(xdr, args->sattr, userns);\n\t\tbreak;\n\tcase NF3REG:\n\tcase NF3DIR:\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}\n\nstatic void nfs3_xdr_enc_mknod3args(struct rpc_rqst *req,\n\t\t\t\t    struct xdr_stream *xdr,\n\t\t\t\t    const void *data)\n{\n\tconst struct nfs3_mknodargs *args = data;\n\n\tencode_diropargs3(xdr, args->fh, args->name, args->len);\n\tencode_mknoddata3(xdr, args, rpc_rqst_userns(req));\n}\n\n \nstatic void nfs3_xdr_enc_remove3args(struct rpc_rqst *req,\n\t\t\t\t     struct xdr_stream *xdr,\n\t\t\t\t     const void *data)\n{\n\tconst struct nfs_removeargs *args = data;\n\n\tencode_diropargs3(xdr, args->fh, args->name.name, args->name.len);\n}\n\n \nstatic void nfs3_xdr_enc_rename3args(struct rpc_rqst *req,\n\t\t\t\t     struct xdr_stream *xdr,\n\t\t\t\t     const void *data)\n{\n\tconst struct nfs_renameargs *args = data;\n\tconst struct qstr *old = args->old_name;\n\tconst struct qstr *new = args->new_name;\n\n\tencode_diropargs3(xdr, args->old_dir, old->name, old->len);\n\tencode_diropargs3(xdr, args->new_dir, new->name, new->len);\n}\n\n \nstatic void nfs3_xdr_enc_link3args(struct rpc_rqst *req,\n\t\t\t\t   struct xdr_stream *xdr,\n\t\t\t\t   const void *data)\n{\n\tconst struct nfs3_linkargs *args = data;\n\n\tencode_nfs_fh3(xdr, args->fromfh);\n\tencode_diropargs3(xdr, args->tofh, args->toname, args->tolen);\n}\n\n \nstatic void encode_readdir3args(struct xdr_stream *xdr,\n\t\t\t\tconst struct nfs3_readdirargs *args)\n{\n\t__be32 *p;\n\n\tencode_nfs_fh3(xdr, args->fh);\n\n\tp = xdr_reserve_space(xdr, 8 + NFS3_COOKIEVERFSIZE + 4);\n\tp = xdr_encode_cookie3(p, args->cookie);\n\tp = xdr_encode_cookieverf3(p, args->verf);\n\t*p = cpu_to_be32(args->count);\n}\n\nstatic void nfs3_xdr_enc_readdir3args(struct rpc_rqst *req,\n\t\t\t\t      struct xdr_stream *xdr,\n\t\t\t\t      const void *data)\n{\n\tconst struct nfs3_readdirargs *args = data;\n\n\tencode_readdir3args(xdr, args);\n\trpc_prepare_reply_pages(req, args->pages, 0, args->count,\n\t\t\t\tNFS3_readdirres_sz - NFS3_pagepad_sz);\n}\n\n \nstatic void encode_readdirplus3args(struct xdr_stream *xdr,\n\t\t\t\t    const struct nfs3_readdirargs *args)\n{\n\tuint32_t dircount = args->count;\n\tuint32_t maxcount = args->count;\n\t__be32 *p;\n\n\tencode_nfs_fh3(xdr, args->fh);\n\n\tp = xdr_reserve_space(xdr, 8 + NFS3_COOKIEVERFSIZE + 4 + 4);\n\tp = xdr_encode_cookie3(p, args->cookie);\n\tp = xdr_encode_cookieverf3(p, args->verf);\n\n\t \n\t*p++ = cpu_to_be32(dircount);\n\t*p = cpu_to_be32(maxcount);\n}\n\nstatic void nfs3_xdr_enc_readdirplus3args(struct rpc_rqst *req,\n\t\t\t\t\t  struct xdr_stream *xdr,\n\t\t\t\t\t  const void *data)\n{\n\tconst struct nfs3_readdirargs *args = data;\n\n\tencode_readdirplus3args(xdr, args);\n\trpc_prepare_reply_pages(req, args->pages, 0, args->count,\n\t\t\t\tNFS3_readdirres_sz - NFS3_pagepad_sz);\n}\n\n \nstatic void encode_commit3args(struct xdr_stream *xdr,\n\t\t\t       const struct nfs_commitargs *args)\n{\n\t__be32 *p;\n\n\tencode_nfs_fh3(xdr, args->fh);\n\n\tp = xdr_reserve_space(xdr, 8 + 4);\n\tp = xdr_encode_hyper(p, args->offset);\n\t*p = cpu_to_be32(args->count);\n}\n\nstatic void nfs3_xdr_enc_commit3args(struct rpc_rqst *req,\n\t\t\t\t     struct xdr_stream *xdr,\n\t\t\t\t     const void *data)\n{\n\tconst struct nfs_commitargs *args = data;\n\n\tencode_commit3args(xdr, args);\n}\n\n#ifdef CONFIG_NFS_V3_ACL\n\nstatic void nfs3_xdr_enc_getacl3args(struct rpc_rqst *req,\n\t\t\t\t     struct xdr_stream *xdr,\n\t\t\t\t     const void *data)\n{\n\tconst struct nfs3_getaclargs *args = data;\n\n\tencode_nfs_fh3(xdr, args->fh);\n\tencode_uint32(xdr, args->mask);\n\tif (args->mask & (NFS_ACL | NFS_DFACL)) {\n\t\trpc_prepare_reply_pages(req, args->pages, 0,\n\t\t\t\t\tNFSACL_MAXPAGES << PAGE_SHIFT,\n\t\t\t\t\tACL3_getaclres_sz - NFS3_pagepad_sz);\n\t\treq->rq_rcv_buf.flags |= XDRBUF_SPARSE_PAGES;\n\t}\n}\n\nstatic void nfs3_xdr_enc_setacl3args(struct rpc_rqst *req,\n\t\t\t\t     struct xdr_stream *xdr,\n\t\t\t\t     const void *data)\n{\n\tconst struct nfs3_setaclargs *args = data;\n\tunsigned int base;\n\tint error;\n\n\tencode_nfs_fh3(xdr, NFS_FH(args->inode));\n\tencode_uint32(xdr, args->mask);\n\n\tbase = req->rq_slen;\n\tif (args->npages != 0)\n\t\txdr_write_pages(xdr, args->pages, 0, args->len);\n\telse\n\t\txdr_reserve_space(xdr, args->len);\n\n\terror = nfsacl_encode(xdr->buf, base, args->inode,\n\t\t\t    (args->mask & NFS_ACL) ?\n\t\t\t    args->acl_access : NULL, 1, 0);\n\t \n\tBUG_ON(error < 0);\n\terror = nfsacl_encode(xdr->buf, base + error, args->inode,\n\t\t\t    (args->mask & NFS_DFACL) ?\n\t\t\t    args->acl_default : NULL, 1,\n\t\t\t    NFS_ACL_DEFAULT);\n\tBUG_ON(error < 0);\n}\n\n#endif   \n\n \n\n \nstatic int nfs3_xdr_dec_getattr3res(struct rpc_rqst *req,\n\t\t\t\t    struct xdr_stream *xdr,\n\t\t\t\t    void *result)\n{\n\tenum nfs_stat status;\n\tint error;\n\n\terror = decode_nfsstat3(xdr, &status);\n\tif (unlikely(error))\n\t\tgoto out;\n\tif (status != NFS3_OK)\n\t\tgoto out_default;\n\terror = decode_fattr3(xdr, result, rpc_rqst_userns(req));\nout:\n\treturn error;\nout_default:\n\treturn nfs3_stat_to_errno(status);\n}\n\n \nstatic int nfs3_xdr_dec_setattr3res(struct rpc_rqst *req,\n\t\t\t\t    struct xdr_stream *xdr,\n\t\t\t\t    void *result)\n{\n\tenum nfs_stat status;\n\tint error;\n\n\terror = decode_nfsstat3(xdr, &status);\n\tif (unlikely(error))\n\t\tgoto out;\n\terror = decode_wcc_data(xdr, result, rpc_rqst_userns(req));\n\tif (unlikely(error))\n\t\tgoto out;\n\tif (status != NFS3_OK)\n\t\tgoto out_status;\nout:\n\treturn error;\nout_status:\n\treturn nfs3_stat_to_errno(status);\n}\n\n \nstatic int nfs3_xdr_dec_lookup3res(struct rpc_rqst *req,\n\t\t\t\t   struct xdr_stream *xdr,\n\t\t\t\t   void *data)\n{\n\tstruct user_namespace *userns = rpc_rqst_userns(req);\n\tstruct nfs3_diropres *result = data;\n\tenum nfs_stat status;\n\tint error;\n\n\terror = decode_nfsstat3(xdr, &status);\n\tif (unlikely(error))\n\t\tgoto out;\n\tif (status != NFS3_OK)\n\t\tgoto out_default;\n\terror = decode_nfs_fh3(xdr, result->fh);\n\tif (unlikely(error))\n\t\tgoto out;\n\terror = decode_post_op_attr(xdr, result->fattr, userns);\n\tif (unlikely(error))\n\t\tgoto out;\n\terror = decode_post_op_attr(xdr, result->dir_attr, userns);\nout:\n\treturn error;\nout_default:\n\terror = decode_post_op_attr(xdr, result->dir_attr, userns);\n\tif (unlikely(error))\n\t\tgoto out;\n\treturn nfs3_stat_to_errno(status);\n}\n\n \nstatic int nfs3_xdr_dec_access3res(struct rpc_rqst *req,\n\t\t\t\t   struct xdr_stream *xdr,\n\t\t\t\t   void *data)\n{\n\tstruct nfs3_accessres *result = data;\n\tenum nfs_stat status;\n\tint error;\n\n\terror = decode_nfsstat3(xdr, &status);\n\tif (unlikely(error))\n\t\tgoto out;\n\terror = decode_post_op_attr(xdr, result->fattr, rpc_rqst_userns(req));\n\tif (unlikely(error))\n\t\tgoto out;\n\tif (status != NFS3_OK)\n\t\tgoto out_default;\n\terror = decode_uint32(xdr, &result->access);\nout:\n\treturn error;\nout_default:\n\treturn nfs3_stat_to_errno(status);\n}\n\n \nstatic int nfs3_xdr_dec_readlink3res(struct rpc_rqst *req,\n\t\t\t\t     struct xdr_stream *xdr,\n\t\t\t\t     void *result)\n{\n\tenum nfs_stat status;\n\tint error;\n\n\terror = decode_nfsstat3(xdr, &status);\n\tif (unlikely(error))\n\t\tgoto out;\n\terror = decode_post_op_attr(xdr, result, rpc_rqst_userns(req));\n\tif (unlikely(error))\n\t\tgoto out;\n\tif (status != NFS3_OK)\n\t\tgoto out_default;\n\terror = decode_nfspath3(xdr);\nout:\n\treturn error;\nout_default:\n\treturn nfs3_stat_to_errno(status);\n}\n\n \nstatic int decode_read3resok(struct xdr_stream *xdr,\n\t\t\t     struct nfs_pgio_res *result)\n{\n\tu32 eof, count, ocount, recvd;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4 + 4 + 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tcount = be32_to_cpup(p++);\n\teof = be32_to_cpup(p++);\n\tocount = be32_to_cpup(p++);\n\tif (unlikely(ocount != count))\n\t\tgoto out_mismatch;\n\trecvd = xdr_read_pages(xdr, count);\n\tif (unlikely(count > recvd))\n\t\tgoto out_cheating;\nout:\n\tresult->eof = eof;\n\tresult->count = count;\n\treturn count;\nout_mismatch:\n\tdprintk(\"NFS: READ count doesn't match length of opaque: \"\n\t\t\"count %u != ocount %u\\n\", count, ocount);\n\treturn -EIO;\nout_cheating:\n\tdprintk(\"NFS: server cheating in read result: \"\n\t\t\"count %u > recvd %u\\n\", count, recvd);\n\tcount = recvd;\n\teof = 0;\n\tgoto out;\n}\n\nstatic int nfs3_xdr_dec_read3res(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\t void *data)\n{\n\tstruct nfs_pgio_res *result = data;\n\tunsigned int pos;\n\tenum nfs_stat status;\n\tint error;\n\n\tpos = xdr_stream_pos(xdr);\n\terror = decode_nfsstat3(xdr, &status);\n\tif (unlikely(error))\n\t\tgoto out;\n\terror = decode_post_op_attr(xdr, result->fattr, rpc_rqst_userns(req));\n\tif (unlikely(error))\n\t\tgoto out;\n\tresult->op_status = status;\n\tif (status != NFS3_OK)\n\t\tgoto out_status;\n\tresult->replen = 3 + ((xdr_stream_pos(xdr) - pos) >> 2);\n\terror = decode_read3resok(xdr, result);\nout:\n\treturn error;\nout_status:\n\treturn nfs3_stat_to_errno(status);\n}\n\n \nstatic int decode_write3resok(struct xdr_stream *xdr,\n\t\t\t      struct nfs_pgio_res *result)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4 + 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tresult->count = be32_to_cpup(p++);\n\tresult->verf->committed = be32_to_cpup(p++);\n\tif (unlikely(result->verf->committed > NFS_FILE_SYNC))\n\t\tgoto out_badvalue;\n\tif (decode_writeverf3(xdr, &result->verf->verifier))\n\t\treturn -EIO;\n\treturn result->count;\nout_badvalue:\n\tdprintk(\"NFS: bad stable_how value: %u\\n\", result->verf->committed);\n\treturn -EIO;\n}\n\nstatic int nfs3_xdr_dec_write3res(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\t  void *data)\n{\n\tstruct nfs_pgio_res *result = data;\n\tenum nfs_stat status;\n\tint error;\n\n\terror = decode_nfsstat3(xdr, &status);\n\tif (unlikely(error))\n\t\tgoto out;\n\terror = decode_wcc_data(xdr, result->fattr, rpc_rqst_userns(req));\n\tif (unlikely(error))\n\t\tgoto out;\n\tresult->op_status = status;\n\tif (status != NFS3_OK)\n\t\tgoto out_status;\n\terror = decode_write3resok(xdr, result);\nout:\n\treturn error;\nout_status:\n\treturn nfs3_stat_to_errno(status);\n}\n\n \nstatic int decode_create3resok(struct xdr_stream *xdr,\n\t\t\t       struct nfs3_diropres *result,\n\t\t\t       struct user_namespace *userns)\n{\n\tint error;\n\n\terror = decode_post_op_fh3(xdr, result->fh);\n\tif (unlikely(error))\n\t\tgoto out;\n\terror = decode_post_op_attr(xdr, result->fattr, userns);\n\tif (unlikely(error))\n\t\tgoto out;\n\t \n\tif (result->fh->size == 0)\n\t\tresult->fattr->valid = 0;\n\terror = decode_wcc_data(xdr, result->dir_attr, userns);\nout:\n\treturn error;\n}\n\nstatic int nfs3_xdr_dec_create3res(struct rpc_rqst *req,\n\t\t\t\t   struct xdr_stream *xdr,\n\t\t\t\t   void *data)\n{\n\tstruct user_namespace *userns = rpc_rqst_userns(req);\n\tstruct nfs3_diropres *result = data;\n\tenum nfs_stat status;\n\tint error;\n\n\terror = decode_nfsstat3(xdr, &status);\n\tif (unlikely(error))\n\t\tgoto out;\n\tif (status != NFS3_OK)\n\t\tgoto out_default;\n\terror = decode_create3resok(xdr, result, userns);\nout:\n\treturn error;\nout_default:\n\terror = decode_wcc_data(xdr, result->dir_attr, userns);\n\tif (unlikely(error))\n\t\tgoto out;\n\treturn nfs3_stat_to_errno(status);\n}\n\n \nstatic int nfs3_xdr_dec_remove3res(struct rpc_rqst *req,\n\t\t\t\t   struct xdr_stream *xdr,\n\t\t\t\t   void *data)\n{\n\tstruct nfs_removeres *result = data;\n\tenum nfs_stat status;\n\tint error;\n\n\terror = decode_nfsstat3(xdr, &status);\n\tif (unlikely(error))\n\t\tgoto out;\n\terror = decode_wcc_data(xdr, result->dir_attr, rpc_rqst_userns(req));\n\tif (unlikely(error))\n\t\tgoto out;\n\tif (status != NFS3_OK)\n\t\tgoto out_status;\nout:\n\treturn error;\nout_status:\n\treturn nfs3_stat_to_errno(status);\n}\n\n \nstatic int nfs3_xdr_dec_rename3res(struct rpc_rqst *req,\n\t\t\t\t   struct xdr_stream *xdr,\n\t\t\t\t   void *data)\n{\n\tstruct user_namespace *userns = rpc_rqst_userns(req);\n\tstruct nfs_renameres *result = data;\n\tenum nfs_stat status;\n\tint error;\n\n\terror = decode_nfsstat3(xdr, &status);\n\tif (unlikely(error))\n\t\tgoto out;\n\terror = decode_wcc_data(xdr, result->old_fattr, userns);\n\tif (unlikely(error))\n\t\tgoto out;\n\terror = decode_wcc_data(xdr, result->new_fattr, userns);\n\tif (unlikely(error))\n\t\tgoto out;\n\tif (status != NFS3_OK)\n\t\tgoto out_status;\nout:\n\treturn error;\nout_status:\n\treturn nfs3_stat_to_errno(status);\n}\n\n \nstatic int nfs3_xdr_dec_link3res(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\t void *data)\n{\n\tstruct user_namespace *userns = rpc_rqst_userns(req);\n\tstruct nfs3_linkres *result = data;\n\tenum nfs_stat status;\n\tint error;\n\n\terror = decode_nfsstat3(xdr, &status);\n\tif (unlikely(error))\n\t\tgoto out;\n\terror = decode_post_op_attr(xdr, result->fattr, userns);\n\tif (unlikely(error))\n\t\tgoto out;\n\terror = decode_wcc_data(xdr, result->dir_attr, userns);\n\tif (unlikely(error))\n\t\tgoto out;\n\tif (status != NFS3_OK)\n\t\tgoto out_status;\nout:\n\treturn error;\nout_status:\n\treturn nfs3_stat_to_errno(status);\n}\n\n \nint nfs3_decode_dirent(struct xdr_stream *xdr, struct nfs_entry *entry,\n\t\t       bool plus)\n{\n\tstruct user_namespace *userns = rpc_userns(entry->server->client);\n\t__be32 *p;\n\tint error;\n\tu64 new_cookie;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -EAGAIN;\n\tif (*p == xdr_zero) {\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EAGAIN;\n\t\tif (*p == xdr_zero)\n\t\t\treturn -EAGAIN;\n\t\tentry->eof = 1;\n\t\treturn -EBADCOOKIE;\n\t}\n\n\terror = decode_fileid3(xdr, &entry->ino);\n\tif (unlikely(error))\n\t\treturn -EAGAIN;\n\n\terror = decode_inline_filename3(xdr, &entry->name, &entry->len);\n\tif (unlikely(error))\n\t\treturn error == -ENAMETOOLONG ? -ENAMETOOLONG : -EAGAIN;\n\n\terror = decode_cookie3(xdr, &new_cookie);\n\tif (unlikely(error))\n\t\treturn -EAGAIN;\n\n\tentry->d_type = DT_UNKNOWN;\n\n\tif (plus) {\n\t\tentry->fattr->valid = 0;\n\t\terror = decode_post_op_attr(xdr, entry->fattr, userns);\n\t\tif (unlikely(error))\n\t\t\treturn -EAGAIN;\n\t\tif (entry->fattr->valid & NFS_ATTR_FATTR_V3)\n\t\t\tentry->d_type = nfs_umode_to_dtype(entry->fattr->mode);\n\n\t\tif (entry->fattr->fileid != entry->ino) {\n\t\t\tentry->fattr->mounted_on_fileid = entry->ino;\n\t\t\tentry->fattr->valid |= NFS_ATTR_FATTR_MOUNTED_ON_FILEID;\n\t\t}\n\n\t\t \n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EAGAIN;\n\t\tif (*p != xdr_zero) {\n\t\t\terror = decode_nfs_fh3(xdr, entry->fh);\n\t\t\tif (unlikely(error))\n\t\t\t\treturn -EAGAIN;\n\t\t} else\n\t\t\tzero_nfs_fh3(entry->fh);\n\t}\n\n\tentry->cookie = new_cookie;\n\n\treturn 0;\n}\n\n \nstatic int decode_dirlist3(struct xdr_stream *xdr)\n{\n\treturn xdr_read_pages(xdr, xdr->buf->page_len);\n}\n\nstatic int decode_readdir3resok(struct xdr_stream *xdr,\n\t\t\t\tstruct nfs3_readdirres *result,\n\t\t\t\tstruct user_namespace *userns)\n{\n\tint error;\n\n\terror = decode_post_op_attr(xdr, result->dir_attr, userns);\n\tif (unlikely(error))\n\t\tgoto out;\n\t \n\terror = decode_cookieverf3(xdr, result->verf);\n\tif (unlikely(error))\n\t\tgoto out;\n\terror = decode_dirlist3(xdr);\nout:\n\treturn error;\n}\n\nstatic int nfs3_xdr_dec_readdir3res(struct rpc_rqst *req,\n\t\t\t\t    struct xdr_stream *xdr,\n\t\t\t\t    void *data)\n{\n\tstruct nfs3_readdirres *result = data;\n\tenum nfs_stat status;\n\tint error;\n\n\terror = decode_nfsstat3(xdr, &status);\n\tif (unlikely(error))\n\t\tgoto out;\n\tif (status != NFS3_OK)\n\t\tgoto out_default;\n\terror = decode_readdir3resok(xdr, result, rpc_rqst_userns(req));\nout:\n\treturn error;\nout_default:\n\terror = decode_post_op_attr(xdr, result->dir_attr, rpc_rqst_userns(req));\n\tif (unlikely(error))\n\t\tgoto out;\n\treturn nfs3_stat_to_errno(status);\n}\n\n \nstatic int decode_fsstat3resok(struct xdr_stream *xdr,\n\t\t\t       struct nfs_fsstat *result)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 8 * 6 + 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tp = xdr_decode_size3(p, &result->tbytes);\n\tp = xdr_decode_size3(p, &result->fbytes);\n\tp = xdr_decode_size3(p, &result->abytes);\n\tp = xdr_decode_size3(p, &result->tfiles);\n\tp = xdr_decode_size3(p, &result->ffiles);\n\txdr_decode_size3(p, &result->afiles);\n\t \n\treturn 0;\n}\n\nstatic int nfs3_xdr_dec_fsstat3res(struct rpc_rqst *req,\n\t\t\t\t   struct xdr_stream *xdr,\n\t\t\t\t   void *data)\n{\n\tstruct nfs_fsstat *result = data;\n\tenum nfs_stat status;\n\tint error;\n\n\terror = decode_nfsstat3(xdr, &status);\n\tif (unlikely(error))\n\t\tgoto out;\n\terror = decode_post_op_attr(xdr, result->fattr, rpc_rqst_userns(req));\n\tif (unlikely(error))\n\t\tgoto out;\n\tif (status != NFS3_OK)\n\t\tgoto out_status;\n\terror = decode_fsstat3resok(xdr, result);\nout:\n\treturn error;\nout_status:\n\treturn nfs3_stat_to_errno(status);\n}\n\n \nstatic int decode_fsinfo3resok(struct xdr_stream *xdr,\n\t\t\t       struct nfs_fsinfo *result)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4 * 7 + 8 + 8 + 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tresult->rtmax  = be32_to_cpup(p++);\n\tresult->rtpref = be32_to_cpup(p++);\n\tresult->rtmult = be32_to_cpup(p++);\n\tresult->wtmax  = be32_to_cpup(p++);\n\tresult->wtpref = be32_to_cpup(p++);\n\tresult->wtmult = be32_to_cpup(p++);\n\tresult->dtpref = be32_to_cpup(p++);\n\tp = xdr_decode_size3(p, &result->maxfilesize);\n\txdr_decode_nfstime3(p, &result->time_delta);\n\n\t \n\tresult->lease_time = 0;\n\tresult->change_attr_type = NFS4_CHANGE_TYPE_IS_UNDEFINED;\n\tresult->xattr_support = 0;\n\treturn 0;\n}\n\nstatic int nfs3_xdr_dec_fsinfo3res(struct rpc_rqst *req,\n\t\t\t\t   struct xdr_stream *xdr,\n\t\t\t\t   void *data)\n{\n\tstruct nfs_fsinfo *result = data;\n\tenum nfs_stat status;\n\tint error;\n\n\terror = decode_nfsstat3(xdr, &status);\n\tif (unlikely(error))\n\t\tgoto out;\n\terror = decode_post_op_attr(xdr, result->fattr, rpc_rqst_userns(req));\n\tif (unlikely(error))\n\t\tgoto out;\n\tif (status != NFS3_OK)\n\t\tgoto out_status;\n\terror = decode_fsinfo3resok(xdr, result);\nout:\n\treturn error;\nout_status:\n\treturn nfs3_stat_to_errno(status);\n}\n\n \nstatic int decode_pathconf3resok(struct xdr_stream *xdr,\n\t\t\t\t struct nfs_pathconf *result)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4 * 6);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tresult->max_link = be32_to_cpup(p++);\n\tresult->max_namelen = be32_to_cpup(p);\n\t \n\treturn 0;\n}\n\nstatic int nfs3_xdr_dec_pathconf3res(struct rpc_rqst *req,\n\t\t\t\t     struct xdr_stream *xdr,\n\t\t\t\t     void *data)\n{\n\tstruct nfs_pathconf *result = data;\n\tenum nfs_stat status;\n\tint error;\n\n\terror = decode_nfsstat3(xdr, &status);\n\tif (unlikely(error))\n\t\tgoto out;\n\terror = decode_post_op_attr(xdr, result->fattr, rpc_rqst_userns(req));\n\tif (unlikely(error))\n\t\tgoto out;\n\tif (status != NFS3_OK)\n\t\tgoto out_status;\n\terror = decode_pathconf3resok(xdr, result);\nout:\n\treturn error;\nout_status:\n\treturn nfs3_stat_to_errno(status);\n}\n\n \nstatic int nfs3_xdr_dec_commit3res(struct rpc_rqst *req,\n\t\t\t\t   struct xdr_stream *xdr,\n\t\t\t\t   void *data)\n{\n\tstruct nfs_commitres *result = data;\n\tstruct nfs_writeverf *verf = result->verf;\n\tenum nfs_stat status;\n\tint error;\n\n\terror = decode_nfsstat3(xdr, &status);\n\tif (unlikely(error))\n\t\tgoto out;\n\terror = decode_wcc_data(xdr, result->fattr, rpc_rqst_userns(req));\n\tif (unlikely(error))\n\t\tgoto out;\n\tresult->op_status = status;\n\tif (status != NFS3_OK)\n\t\tgoto out_status;\n\terror = decode_writeverf3(xdr, &verf->verifier);\n\tif (!error)\n\t\tverf->committed = NFS_FILE_SYNC;\nout:\n\treturn error;\nout_status:\n\treturn nfs3_stat_to_errno(status);\n}\n\n#ifdef CONFIG_NFS_V3_ACL\n\nstatic inline int decode_getacl3resok(struct xdr_stream *xdr,\n\t\t\t\t      struct nfs3_getaclres *result,\n\t\t\t\t      struct user_namespace *userns)\n{\n\tstruct posix_acl **acl;\n\tunsigned int *aclcnt;\n\tsize_t hdrlen;\n\tint error;\n\n\terror = decode_post_op_attr(xdr, result->fattr, userns);\n\tif (unlikely(error))\n\t\tgoto out;\n\terror = decode_uint32(xdr, &result->mask);\n\tif (unlikely(error))\n\t\tgoto out;\n\terror = -EINVAL;\n\tif (result->mask & ~(NFS_ACL|NFS_ACLCNT|NFS_DFACL|NFS_DFACLCNT))\n\t\tgoto out;\n\n\thdrlen = xdr_stream_pos(xdr);\n\n\tacl = NULL;\n\tif (result->mask & NFS_ACL)\n\t\tacl = &result->acl_access;\n\taclcnt = NULL;\n\tif (result->mask & NFS_ACLCNT)\n\t\taclcnt = &result->acl_access_count;\n\terror = nfsacl_decode(xdr->buf, hdrlen, aclcnt, acl);\n\tif (unlikely(error <= 0))\n\t\tgoto out;\n\n\tacl = NULL;\n\tif (result->mask & NFS_DFACL)\n\t\tacl = &result->acl_default;\n\taclcnt = NULL;\n\tif (result->mask & NFS_DFACLCNT)\n\t\taclcnt = &result->acl_default_count;\n\terror = nfsacl_decode(xdr->buf, hdrlen + error, aclcnt, acl);\n\tif (unlikely(error <= 0))\n\t\treturn error;\n\terror = 0;\nout:\n\treturn error;\n}\n\nstatic int nfs3_xdr_dec_getacl3res(struct rpc_rqst *req,\n\t\t\t\t   struct xdr_stream *xdr,\n\t\t\t\t   void *result)\n{\n\tenum nfs_stat status;\n\tint error;\n\n\terror = decode_nfsstat3(xdr, &status);\n\tif (unlikely(error))\n\t\tgoto out;\n\tif (status != NFS3_OK)\n\t\tgoto out_default;\n\terror = decode_getacl3resok(xdr, result, rpc_rqst_userns(req));\nout:\n\treturn error;\nout_default:\n\treturn nfs3_stat_to_errno(status);\n}\n\nstatic int nfs3_xdr_dec_setacl3res(struct rpc_rqst *req,\n\t\t\t\t   struct xdr_stream *xdr,\n\t\t\t\t   void *result)\n{\n\tenum nfs_stat status;\n\tint error;\n\n\terror = decode_nfsstat3(xdr, &status);\n\tif (unlikely(error))\n\t\tgoto out;\n\tif (status != NFS3_OK)\n\t\tgoto out_default;\n\terror = decode_post_op_attr(xdr, result, rpc_rqst_userns(req));\nout:\n\treturn error;\nout_default:\n\treturn nfs3_stat_to_errno(status);\n}\n\n#endif   \n\n\n \nstatic const struct {\n\tint stat;\n\tint errno;\n} nfs_errtbl[] = {\n\t{ NFS_OK,\t\t0\t\t},\n\t{ NFSERR_PERM,\t\t-EPERM\t\t},\n\t{ NFSERR_NOENT,\t\t-ENOENT\t\t},\n\t{ NFSERR_IO,\t\t-errno_NFSERR_IO},\n\t{ NFSERR_NXIO,\t\t-ENXIO\t\t},\n \n\t{ NFSERR_ACCES,\t\t-EACCES\t\t},\n\t{ NFSERR_EXIST,\t\t-EEXIST\t\t},\n\t{ NFSERR_XDEV,\t\t-EXDEV\t\t},\n\t{ NFSERR_NODEV,\t\t-ENODEV\t\t},\n\t{ NFSERR_NOTDIR,\t-ENOTDIR\t},\n\t{ NFSERR_ISDIR,\t\t-EISDIR\t\t},\n\t{ NFSERR_INVAL,\t\t-EINVAL\t\t},\n\t{ NFSERR_FBIG,\t\t-EFBIG\t\t},\n\t{ NFSERR_NOSPC,\t\t-ENOSPC\t\t},\n\t{ NFSERR_ROFS,\t\t-EROFS\t\t},\n\t{ NFSERR_MLINK,\t\t-EMLINK\t\t},\n\t{ NFSERR_NAMETOOLONG,\t-ENAMETOOLONG\t},\n\t{ NFSERR_NOTEMPTY,\t-ENOTEMPTY\t},\n\t{ NFSERR_DQUOT,\t\t-EDQUOT\t\t},\n\t{ NFSERR_STALE,\t\t-ESTALE\t\t},\n\t{ NFSERR_REMOTE,\t-EREMOTE\t},\n#ifdef EWFLUSH\n\t{ NFSERR_WFLUSH,\t-EWFLUSH\t},\n#endif\n\t{ NFSERR_BADHANDLE,\t-EBADHANDLE\t},\n\t{ NFSERR_NOT_SYNC,\t-ENOTSYNC\t},\n\t{ NFSERR_BAD_COOKIE,\t-EBADCOOKIE\t},\n\t{ NFSERR_NOTSUPP,\t-ENOTSUPP\t},\n\t{ NFSERR_TOOSMALL,\t-ETOOSMALL\t},\n\t{ NFSERR_SERVERFAULT,\t-EREMOTEIO\t},\n\t{ NFSERR_BADTYPE,\t-EBADTYPE\t},\n\t{ NFSERR_JUKEBOX,\t-EJUKEBOX\t},\n\t{ -1,\t\t\t-EIO\t\t}\n};\n\n \nstatic int nfs3_stat_to_errno(enum nfs_stat status)\n{\n\tint i;\n\n\tfor (i = 0; nfs_errtbl[i].stat != -1; i++) {\n\t\tif (nfs_errtbl[i].stat == (int)status)\n\t\t\treturn nfs_errtbl[i].errno;\n\t}\n\tdprintk(\"NFS: Unrecognized nfs status value: %u\\n\", status);\n\treturn nfs_errtbl[i].errno;\n}\n\n\n#define PROC(proc, argtype, restype, timer)\t\t\t\t\\\n[NFS3PROC_##proc] = {\t\t\t\t\t\t\t\\\n\t.p_proc      = NFS3PROC_##proc,\t\t\t\t\t\\\n\t.p_encode    = nfs3_xdr_enc_##argtype##3args,\t\t\t\\\n\t.p_decode    = nfs3_xdr_dec_##restype##3res,\t\t\t\\\n\t.p_arglen    = NFS3_##argtype##args_sz,\t\t\t\t\\\n\t.p_replen    = NFS3_##restype##res_sz,\t\t\t\t\\\n\t.p_timer     = timer,\t\t\t\t\t\t\\\n\t.p_statidx   = NFS3PROC_##proc,\t\t\t\t\t\\\n\t.p_name      = #proc,\t\t\t\t\t\t\\\n\t}\n\nconst struct rpc_procinfo nfs3_procedures[] = {\n\tPROC(GETATTR,\t\tgetattr,\tgetattr,\t1),\n\tPROC(SETATTR,\t\tsetattr,\tsetattr,\t0),\n\tPROC(LOOKUP,\t\tlookup,\t\tlookup,\t\t2),\n\tPROC(ACCESS,\t\taccess,\t\taccess,\t\t1),\n\tPROC(READLINK,\t\treadlink,\treadlink,\t3),\n\tPROC(READ,\t\tread,\t\tread,\t\t3),\n\tPROC(WRITE,\t\twrite,\t\twrite,\t\t4),\n\tPROC(CREATE,\t\tcreate,\t\tcreate,\t\t0),\n\tPROC(MKDIR,\t\tmkdir,\t\tcreate,\t\t0),\n\tPROC(SYMLINK,\t\tsymlink,\tcreate,\t\t0),\n\tPROC(MKNOD,\t\tmknod,\t\tcreate,\t\t0),\n\tPROC(REMOVE,\t\tremove,\t\tremove,\t\t0),\n\tPROC(RMDIR,\t\tlookup,\t\tsetattr,\t0),\n\tPROC(RENAME,\t\trename,\t\trename,\t\t0),\n\tPROC(LINK,\t\tlink,\t\tlink,\t\t0),\n\tPROC(READDIR,\t\treaddir,\treaddir,\t3),\n\tPROC(READDIRPLUS,\treaddirplus,\treaddir,\t3),\n\tPROC(FSSTAT,\t\tgetattr,\tfsstat,\t\t0),\n\tPROC(FSINFO,\t\tgetattr,\tfsinfo,\t\t0),\n\tPROC(PATHCONF,\t\tgetattr,\tpathconf,\t0),\n\tPROC(COMMIT,\t\tcommit,\t\tcommit,\t\t5),\n};\n\nstatic unsigned int nfs_version3_counts[ARRAY_SIZE(nfs3_procedures)];\nconst struct rpc_version nfs_version3 = {\n\t.number\t\t\t= 3,\n\t.nrprocs\t\t= ARRAY_SIZE(nfs3_procedures),\n\t.procs\t\t\t= nfs3_procedures,\n\t.counts\t\t\t= nfs_version3_counts,\n};\n\n#ifdef CONFIG_NFS_V3_ACL\nstatic const struct rpc_procinfo nfs3_acl_procedures[] = {\n\t[ACLPROC3_GETACL] = {\n\t\t.p_proc = ACLPROC3_GETACL,\n\t\t.p_encode = nfs3_xdr_enc_getacl3args,\n\t\t.p_decode = nfs3_xdr_dec_getacl3res,\n\t\t.p_arglen = ACL3_getaclargs_sz,\n\t\t.p_replen = ACL3_getaclres_sz,\n\t\t.p_timer = 1,\n\t\t.p_name = \"GETACL\",\n\t},\n\t[ACLPROC3_SETACL] = {\n\t\t.p_proc = ACLPROC3_SETACL,\n\t\t.p_encode = nfs3_xdr_enc_setacl3args,\n\t\t.p_decode = nfs3_xdr_dec_setacl3res,\n\t\t.p_arglen = ACL3_setaclargs_sz,\n\t\t.p_replen = ACL3_setaclres_sz,\n\t\t.p_timer = 0,\n\t\t.p_name = \"SETACL\",\n\t},\n};\n\nstatic unsigned int nfs3_acl_counts[ARRAY_SIZE(nfs3_acl_procedures)];\nconst struct rpc_version nfsacl_version3 = {\n\t.number\t\t\t= 3,\n\t.nrprocs\t\t= ARRAY_SIZE(nfs3_acl_procedures),\n\t.procs\t\t\t= nfs3_acl_procedures,\n\t.counts\t\t\t= nfs3_acl_counts,\n};\n#endif   \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}