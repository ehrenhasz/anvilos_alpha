{
  "module_name": "nfs4client.c",
  "hash_id": "dfb7f66856f44310f1936e3f733d7f09f48e496bff98baf3c883957002e239e2",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfs/nfs4client.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_mount.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/auth.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"delegation.h\"\n#include \"nfs4session.h\"\n#include \"nfs4idmap.h\"\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"sysfs.h\"\n\n#define NFSDBG_FACILITY\t\tNFSDBG_CLIENT\n\n \nstatic int nfs_get_cb_ident_idr(struct nfs_client *clp, int minorversion)\n{\n\tint ret = 0;\n\tstruct nfs_net *nn = net_generic(clp->cl_net, nfs_net_id);\n\n\tif (clp->rpc_ops->version != 4 || minorversion != 0)\n\t\treturn ret;\n\tidr_preload(GFP_KERNEL);\n\tspin_lock(&nn->nfs_client_lock);\n\tret = idr_alloc(&nn->cb_ident_idr, clp, 1, 0, GFP_NOWAIT);\n\tif (ret >= 0)\n\t\tclp->cl_cb_ident = ret;\n\tspin_unlock(&nn->nfs_client_lock);\n\tidr_preload_end();\n\treturn ret < 0 ? ret : 0;\n}\n\n#ifdef CONFIG_NFS_V4_1\n \nstruct nfs4_ds_server {\n\tstruct list_head\tlist;    \n\tstruct rpc_clnt\t\t*rpc_clnt;\n};\n\n \nstatic struct nfs4_ds_server *\nnfs4_find_ds_client(struct nfs_client *ds_clp, rpc_authflavor_t flavor)\n{\n\tstruct nfs4_ds_server *dss;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(dss, &ds_clp->cl_ds_clients, list) {\n\t\tif (dss->rpc_clnt->cl_auth->au_flavor != flavor)\n\t\t\tcontinue;\n\t\tgoto out;\n\t}\n\tdss = NULL;\nout:\n\trcu_read_unlock();\n\treturn dss;\n}\n\nstatic struct nfs4_ds_server *\nnfs4_add_ds_client(struct nfs_client *ds_clp, rpc_authflavor_t flavor,\n\t\t\t   struct nfs4_ds_server *new)\n{\n\tstruct nfs4_ds_server *dss;\n\n\tspin_lock(&ds_clp->cl_lock);\n\tlist_for_each_entry(dss, &ds_clp->cl_ds_clients, list) {\n\t\tif (dss->rpc_clnt->cl_auth->au_flavor != flavor)\n\t\t\tcontinue;\n\t\tgoto out;\n\t}\n\tif (new)\n\t\tlist_add_rcu(&new->list, &ds_clp->cl_ds_clients);\n\tdss = new;\nout:\n\tspin_unlock(&ds_clp->cl_lock);  \n\treturn dss;\n}\n\nstatic struct nfs4_ds_server *\nnfs4_alloc_ds_server(struct nfs_client *ds_clp, rpc_authflavor_t flavor)\n{\n\tstruct nfs4_ds_server *dss;\n\n\tdss = kmalloc(sizeof(*dss), GFP_NOFS);\n\tif (dss == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdss->rpc_clnt = rpc_clone_client_set_auth(ds_clp->cl_rpcclient, flavor);\n\tif (IS_ERR(dss->rpc_clnt)) {\n\t\tint err = PTR_ERR(dss->rpc_clnt);\n\t\tkfree (dss);\n\t\treturn ERR_PTR(err);\n\t}\n\tINIT_LIST_HEAD(&dss->list);\n\n\treturn dss;\n}\n\nstatic void\nnfs4_free_ds_server(struct nfs4_ds_server *dss)\n{\n\trpc_release_client(dss->rpc_clnt);\n\tkfree(dss);\n}\n\n \nstruct rpc_clnt *\nnfs4_find_or_create_ds_client(struct nfs_client *ds_clp, struct inode *inode)\n{\n\tstruct nfs4_ds_server *dss, *new;\n\trpc_authflavor_t flavor = NFS_SERVER(inode)->client->cl_auth->au_flavor;\n\n\tdss = nfs4_find_ds_client(ds_clp, flavor);\n\tif (dss != NULL)\n\t\tgoto out;\n\tnew = nfs4_alloc_ds_server(ds_clp, flavor);\n\tif (IS_ERR(new))\n\t\treturn ERR_CAST(new);\n\tdss = nfs4_add_ds_client(ds_clp, flavor, new);\n\tif (dss != new)\n\t\tnfs4_free_ds_server(new);\nout:\n\treturn dss->rpc_clnt;\n}\nEXPORT_SYMBOL_GPL(nfs4_find_or_create_ds_client);\n\nstatic void\nnfs4_shutdown_ds_clients(struct nfs_client *clp)\n{\n\tstruct nfs4_ds_server *dss;\n\n\twhile (!list_empty(&clp->cl_ds_clients)) {\n\t\tdss = list_entry(clp->cl_ds_clients.next,\n\t\t\t\t\tstruct nfs4_ds_server, list);\n\t\tlist_del(&dss->list);\n\t\trpc_shutdown_client(dss->rpc_clnt);\n\t\tkfree (dss);\n\t}\n}\n\nstatic void\nnfs4_cleanup_callback(struct nfs_client *clp)\n{\n\tstruct nfs4_copy_state *cp_state;\n\n\twhile (!list_empty(&clp->pending_cb_stateids)) {\n\t\tcp_state = list_entry(clp->pending_cb_stateids.next,\n\t\t\t\t\tstruct nfs4_copy_state, copies);\n\t\tlist_del(&cp_state->copies);\n\t\tkfree(cp_state);\n\t}\n}\n\nvoid nfs41_shutdown_client(struct nfs_client *clp)\n{\n\tif (nfs4_has_session(clp)) {\n\t\tnfs4_cleanup_callback(clp);\n\t\tnfs4_shutdown_ds_clients(clp);\n\t\tnfs4_destroy_session(clp->cl_session);\n\t\tnfs4_destroy_clientid(clp);\n\t}\n\n}\n#endif\t \n\nvoid nfs40_shutdown_client(struct nfs_client *clp)\n{\n\tif (clp->cl_slot_tbl) {\n\t\tnfs4_shutdown_slot_table(clp->cl_slot_tbl);\n\t\tkfree(clp->cl_slot_tbl);\n\t}\n}\n\nstruct nfs_client *nfs4_alloc_client(const struct nfs_client_initdata *cl_init)\n{\n\tchar buf[INET6_ADDRSTRLEN + 1];\n\tconst char *ip_addr = cl_init->ip_addr;\n\tstruct nfs_client *clp = nfs_alloc_client(cl_init);\n\tint err;\n\n\tif (IS_ERR(clp))\n\t\treturn clp;\n\n\terr = nfs_get_cb_ident_idr(clp, cl_init->minorversion);\n\tif (err)\n\t\tgoto error;\n\n\tif (cl_init->minorversion > NFS4_MAX_MINOR_VERSION) {\n\t\terr = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tspin_lock_init(&clp->cl_lock);\n\tINIT_DELAYED_WORK(&clp->cl_renewd, nfs4_renew_state);\n\tINIT_LIST_HEAD(&clp->cl_ds_clients);\n\trpc_init_wait_queue(&clp->cl_rpcwaitq, \"NFS client\");\n\tclp->cl_state = 1 << NFS4CLNT_LEASE_EXPIRED;\n\tclp->cl_mvops = nfs_v4_minor_ops[cl_init->minorversion];\n\tclp->cl_mig_gen = 1;\n#if IS_ENABLED(CONFIG_NFS_V4_1)\n\tinit_waitqueue_head(&clp->cl_lock_waitq);\n#endif\n\tINIT_LIST_HEAD(&clp->pending_cb_stateids);\n\n\tif (cl_init->minorversion != 0)\n\t\t__set_bit(NFS_CS_INFINITE_SLOTS, &clp->cl_flags);\n\t__set_bit(NFS_CS_DISCRTRY, &clp->cl_flags);\n\t__set_bit(NFS_CS_NO_RETRANS_TIMEOUT, &clp->cl_flags);\n\n\tif (test_bit(NFS_CS_DS, &cl_init->init_flags))\n\t\t__set_bit(NFS_CS_DS, &clp->cl_flags);\n\t \n\terr = nfs_create_rpc_client(clp, cl_init, RPC_AUTH_GSS_KRB5I);\n\tif (err == -EINVAL)\n\t\terr = nfs_create_rpc_client(clp, cl_init, RPC_AUTH_UNIX);\n\tif (err < 0)\n\t\tgoto error;\n\n\t \n\tif (ip_addr == NULL) {\n\t\tstruct sockaddr_storage cb_addr;\n\t\tstruct sockaddr *sap = (struct sockaddr *)&cb_addr;\n\n\t\terr = rpc_localaddr(clp->cl_rpcclient, sap, sizeof(cb_addr));\n\t\tif (err < 0)\n\t\t\tgoto error;\n\t\terr = rpc_ntop(sap, buf, sizeof(buf));\n\t\tif (err < 0)\n\t\t\tgoto error;\n\t\tip_addr = (const char *)buf;\n\t}\n\tstrscpy(clp->cl_ipaddr, ip_addr, sizeof(clp->cl_ipaddr));\n\n\terr = nfs_idmap_new(clp);\n\tif (err < 0) {\n\t\tdprintk(\"%s: failed to create idmapper. Error = %d\\n\",\n\t\t\t__func__, err);\n\t\tgoto error;\n\t}\n\t__set_bit(NFS_CS_IDMAP, &clp->cl_res_state);\n\treturn clp;\n\nerror:\n\tnfs_free_client(clp);\n\treturn ERR_PTR(err);\n}\n\n \nstatic void nfs4_destroy_callback(struct nfs_client *clp)\n{\n\tif (__test_and_clear_bit(NFS_CS_CALLBACK, &clp->cl_res_state))\n\t\tnfs_callback_down(clp->cl_mvops->minor_version, clp->cl_net);\n}\n\nstatic void nfs4_shutdown_client(struct nfs_client *clp)\n{\n\tif (__test_and_clear_bit(NFS_CS_RENEWD, &clp->cl_res_state))\n\t\tnfs4_kill_renewd(clp);\n\tclp->cl_mvops->shutdown_client(clp);\n\tnfs4_destroy_callback(clp);\n\tif (__test_and_clear_bit(NFS_CS_IDMAP, &clp->cl_res_state))\n\t\tnfs_idmap_delete(clp);\n\n\trpc_destroy_wait_queue(&clp->cl_rpcwaitq);\n\tkfree(clp->cl_serverowner);\n\tkfree(clp->cl_serverscope);\n\tkfree(clp->cl_implid);\n\tkfree(clp->cl_owner_id);\n}\n\nvoid nfs4_free_client(struct nfs_client *clp)\n{\n\tnfs4_shutdown_client(clp);\n\tnfs_free_client(clp);\n}\n\n \nstatic int nfs4_init_callback(struct nfs_client *clp)\n{\n\tstruct rpc_xprt *xprt;\n\tint error;\n\n\txprt = rcu_dereference_raw(clp->cl_rpcclient->cl_xprt);\n\n\tif (nfs4_has_session(clp)) {\n\t\terror = xprt_setup_backchannel(xprt, NFS41_BC_MIN_CALLBACKS);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t}\n\n\terror = nfs_callback_up(clp->cl_mvops->minor_version, xprt);\n\tif (error < 0) {\n\t\tdprintk(\"%s: failed to start callback. Error = %d\\n\",\n\t\t\t__func__, error);\n\t\treturn error;\n\t}\n\t__set_bit(NFS_CS_CALLBACK, &clp->cl_res_state);\n\n\treturn 0;\n}\n\n \nint nfs40_init_client(struct nfs_client *clp)\n{\n\tstruct nfs4_slot_table *tbl;\n\tint ret;\n\n\ttbl = kzalloc(sizeof(*tbl), GFP_NOFS);\n\tif (tbl == NULL)\n\t\treturn -ENOMEM;\n\n\tret = nfs4_setup_slot_table(tbl, NFS4_MAX_SLOT_TABLE,\n\t\t\t\t\t\"NFSv4.0 transport Slot table\");\n\tif (ret) {\n\t\tnfs4_shutdown_slot_table(tbl);\n\t\tkfree(tbl);\n\t\treturn ret;\n\t}\n\n\tclp->cl_slot_tbl = tbl;\n\treturn 0;\n}\n\n#if defined(CONFIG_NFS_V4_1)\n\n \nint nfs41_init_client(struct nfs_client *clp)\n{\n\tstruct nfs4_session *session = NULL;\n\n\t \n\tsession = nfs4_alloc_session(clp);\n\tif (!session)\n\t\treturn -ENOMEM;\n\n\tclp->cl_session = session;\n\n\t \n\tnfs_mark_client_ready(clp, NFS_CS_SESSION_INITING);\n\treturn 0;\n}\n\n#endif\t \n\n \nstatic int nfs4_init_client_minor_version(struct nfs_client *clp)\n{\n\tint ret;\n\n\tret = clp->cl_mvops->init_client(clp);\n\tif (ret)\n\t\treturn ret;\n\treturn nfs4_init_callback(clp);\n}\n\nstatic void nfs4_add_trunk(struct nfs_client *clp, struct nfs_client *old)\n{\n\tstruct sockaddr_storage clp_addr, old_addr;\n\tstruct sockaddr *clp_sap = (struct sockaddr *)&clp_addr;\n\tstruct sockaddr *old_sap = (struct sockaddr *)&old_addr;\n\tsize_t clp_salen;\n\tstruct xprt_create xprt_args = {\n\t\t.ident = old->cl_proto,\n\t\t.net = old->cl_net,\n\t\t.servername = old->cl_hostname,\n\t};\n\tint max_connect = test_bit(NFS_CS_PNFS, &clp->cl_flags) ?\n\t\tclp->cl_max_connect : old->cl_max_connect;\n\n\tif (clp->cl_proto != old->cl_proto)\n\t\treturn;\n\tclp_salen = rpc_peeraddr(clp->cl_rpcclient, clp_sap, sizeof(clp_addr));\n\trpc_peeraddr(old->cl_rpcclient, old_sap, sizeof(old_addr));\n\n\tif (clp_addr.ss_family != old_addr.ss_family)\n\t\treturn;\n\n\txprt_args.dstaddr = clp_sap;\n\txprt_args.addrlen = clp_salen;\n\n\trpc_clnt_add_xprt(old->cl_rpcclient, &xprt_args,\n\t\t\t  rpc_clnt_test_and_add_xprt, &max_connect);\n}\n\n \nstruct nfs_client *nfs4_init_client(struct nfs_client *clp,\n\t\t\t\t    const struct nfs_client_initdata *cl_init)\n{\n\tstruct nfs_client *old;\n\tint error;\n\n\tif (clp->cl_cons_state == NFS_CS_READY)\n\t\t \n\t\treturn clp;\n\n\terror = nfs4_init_client_minor_version(clp);\n\tif (error < 0)\n\t\tgoto error;\n\n\terror = nfs4_discover_server_trunking(clp, &old);\n\tif (error < 0)\n\t\tgoto error;\n\n\tif (clp != old) {\n\t\tclp->cl_preserve_clid = true;\n\t\t \n\t\tnfs_mark_client_ready(clp, -EPERM);\n\t\tif (old->cl_mvops->session_trunk)\n\t\t\tnfs4_add_trunk(clp, old);\n\t}\n\tclear_bit(NFS_CS_TSM_POSSIBLE, &clp->cl_flags);\n\tnfs_put_client(clp);\n\treturn old;\n\nerror:\n\tnfs_mark_client_ready(clp, error);\n\tnfs_put_client(clp);\n\treturn ERR_PTR(error);\n}\n\n \nstatic void nfs4_swap_callback_idents(struct nfs_client *keep,\n\t\t\t\t      struct nfs_client *drop)\n{\n\tstruct nfs_net *nn = net_generic(keep->cl_net, nfs_net_id);\n\tunsigned int save = keep->cl_cb_ident;\n\n\tif (keep->cl_cb_ident == drop->cl_cb_ident)\n\t\treturn;\n\n\tdprintk(\"%s: keeping callback ident %u and dropping ident %u\\n\",\n\t\t__func__, keep->cl_cb_ident, drop->cl_cb_ident);\n\n\tspin_lock(&nn->nfs_client_lock);\n\n\tidr_replace(&nn->cb_ident_idr, keep, drop->cl_cb_ident);\n\tkeep->cl_cb_ident = drop->cl_cb_ident;\n\n\tidr_replace(&nn->cb_ident_idr, drop, save);\n\tdrop->cl_cb_ident = save;\n\n\tspin_unlock(&nn->nfs_client_lock);\n}\n\nstatic bool nfs4_match_client_owner_id(const struct nfs_client *clp1,\n\t\tconst struct nfs_client *clp2)\n{\n\tif (clp1->cl_owner_id == NULL || clp2->cl_owner_id == NULL)\n\t\treturn true;\n\treturn strcmp(clp1->cl_owner_id, clp2->cl_owner_id) == 0;\n}\n\nstatic bool nfs4_same_verifier(nfs4_verifier *v1, nfs4_verifier *v2)\n{\n\treturn memcmp(v1->data, v2->data, sizeof(v1->data)) == 0;\n}\n\nstatic int nfs4_match_client(struct nfs_client  *pos,  struct nfs_client *new,\n\t\t\t     struct nfs_client **prev, struct nfs_net *nn)\n{\n\tint status;\n\n\tif (pos->rpc_ops != new->rpc_ops)\n\t\treturn 1;\n\n\tif (pos->cl_minorversion != new->cl_minorversion)\n\t\treturn 1;\n\n\t \n\tif (pos->cl_cons_state > NFS_CS_READY) {\n\t\trefcount_inc(&pos->cl_count);\n\t\tspin_unlock(&nn->nfs_client_lock);\n\n\t\tnfs_put_client(*prev);\n\t\t*prev = pos;\n\n\t\tstatus = nfs_wait_client_init_complete(pos);\n\t\tspin_lock(&nn->nfs_client_lock);\n\n\t\tif (status < 0)\n\t\t\treturn status;\n\t}\n\n\tif (pos->cl_cons_state != NFS_CS_READY)\n\t\treturn 1;\n\n\tif (pos->cl_clientid != new->cl_clientid)\n\t\treturn 1;\n\n\t \n\tif (!nfs4_match_client_owner_id(pos, new))\n\t\treturn 1;\n\n\treturn 0;\n}\n\n \nint nfs40_walk_client_list(struct nfs_client *new,\n\t\t\t   struct nfs_client **result,\n\t\t\t   const struct cred *cred)\n{\n\tstruct nfs_net *nn = net_generic(new->cl_net, nfs_net_id);\n\tstruct nfs_client *pos, *prev = NULL;\n\tstruct nfs4_setclientid_res clid = {\n\t\t.clientid\t= new->cl_clientid,\n\t\t.confirm\t= new->cl_confirm,\n\t};\n\tint status = -NFS4ERR_STALE_CLIENTID;\n\n\tspin_lock(&nn->nfs_client_lock);\n\tlist_for_each_entry(pos, &nn->nfs_client_list, cl_share_link) {\n\n\t\tif (pos == new)\n\t\t\tgoto found;\n\n\t\tstatus = nfs4_match_client(pos, new, &prev, nn);\n\t\tif (status < 0)\n\t\t\tgoto out_unlock;\n\t\tif (status != 0)\n\t\t\tcontinue;\n\t\t \n\t\tif ((new != pos) && nfs4_same_verifier(&pos->cl_confirm,\n\t\t\t\t\t\t       &new->cl_confirm))\n\t\t\tcontinue;\n\t\t \nfound:\n\t\trefcount_inc(&pos->cl_count);\n\t\tspin_unlock(&nn->nfs_client_lock);\n\n\t\tnfs_put_client(prev);\n\t\tprev = pos;\n\n\t\tstatus = nfs4_proc_setclientid_confirm(pos, &clid, cred);\n\t\tswitch (status) {\n\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tnfs4_swap_callback_idents(pos, new);\n\t\t\tpos->cl_confirm = new->cl_confirm;\n\t\t\tnfs_mark_client_ready(pos, NFS_CS_READY);\n\n\t\t\tprev = NULL;\n\t\t\t*result = pos;\n\t\t\tgoto out;\n\t\tcase -ERESTARTSYS:\n\t\tcase -ETIMEDOUT:\n\t\t\t \n\t\t\tnfs4_schedule_path_down_recovery(pos);\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\tgoto out;\n\t\t}\n\n\t\tspin_lock(&nn->nfs_client_lock);\n\t}\nout_unlock:\n\tspin_unlock(&nn->nfs_client_lock);\n\n\t \nout:\n\tnfs_put_client(prev);\n\treturn status;\n}\n\n#ifdef CONFIG_NFS_V4_1\n \nbool\nnfs4_check_serverowner_major_id(struct nfs41_server_owner *o1,\n\t\t\t\tstruct nfs41_server_owner *o2)\n{\n\tif (o1->major_id_sz != o2->major_id_sz)\n\t\treturn false;\n\treturn memcmp(o1->major_id, o2->major_id, o1->major_id_sz) == 0;\n}\n\n \nstatic bool\nnfs4_check_server_scope(struct nfs41_server_scope *s1,\n\t\t\tstruct nfs41_server_scope *s2)\n{\n\tif (s1->server_scope_sz != s2->server_scope_sz)\n\t\treturn false;\n\treturn memcmp(s1->server_scope, s2->server_scope,\n\t\t\t\t\ts1->server_scope_sz) == 0;\n}\n\n \nint nfs4_detect_session_trunking(struct nfs_client *clp,\n\t\t\t\t struct nfs41_exchange_id_res *res,\n\t\t\t\t struct rpc_xprt *xprt)\n{\n\t \n\tif (clp->cl_clientid != res->clientid)\n\t\tgoto out_err;\n\n\t \n\tif (!nfs4_check_serverowner_major_id(clp->cl_serverowner,\n\t\t\t\t\t     res->server_owner))\n\t\tgoto out_err;\n\n\t \n\tif (clp->cl_serverowner->minor_id != res->server_owner->minor_id)\n\t\tgoto out_err;\n\n\t \n\tif (!nfs4_check_server_scope(clp->cl_serverscope, res->server_scope))\n\t\tgoto out_err;\n\n\tpr_info(\"NFS:  %s: Session trunking succeeded for %s\\n\",\n\t\tclp->cl_hostname,\n\t\txprt->address_strings[RPC_DISPLAY_ADDR]);\n\n\treturn 0;\nout_err:\n\tpr_info(\"NFS:  %s: Session trunking failed for %s\\n\", clp->cl_hostname,\n\t\txprt->address_strings[RPC_DISPLAY_ADDR]);\n\n\treturn -EINVAL;\n}\n\n \nint nfs41_walk_client_list(struct nfs_client *new,\n\t\t\t   struct nfs_client **result,\n\t\t\t   const struct cred *cred)\n{\n\tstruct nfs_net *nn = net_generic(new->cl_net, nfs_net_id);\n\tstruct nfs_client *pos, *prev = NULL;\n\tint status = -NFS4ERR_STALE_CLIENTID;\n\n\tspin_lock(&nn->nfs_client_lock);\n\tlist_for_each_entry(pos, &nn->nfs_client_list, cl_share_link) {\n\n\t\tif (pos == new)\n\t\t\tgoto found;\n\n\t\tstatus = nfs4_match_client(pos, new, &prev, nn);\n\t\tif (status < 0)\n\t\t\tgoto out;\n\t\tif (status != 0)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!nfs4_check_serverowner_major_id(pos->cl_serverowner,\n\t\t\t\t\t\t     new->cl_serverowner))\n\t\t\tcontinue;\n\nfound:\n\t\trefcount_inc(&pos->cl_count);\n\t\t*result = pos;\n\t\tstatus = 0;\n\t\tbreak;\n\t}\n\nout:\n\tspin_unlock(&nn->nfs_client_lock);\n\tnfs_put_client(prev);\n\treturn status;\n}\n#endif\t \n\nstatic void nfs4_destroy_server(struct nfs_server *server)\n{\n\tLIST_HEAD(freeme);\n\n\tnfs_server_return_all_delegations(server);\n\tunset_pnfs_layoutdriver(server);\n\tnfs4_purge_state_owners(server, &freeme);\n\tnfs4_free_state_owners(&freeme);\n}\n\n \nstruct nfs_client *\nnfs4_find_client_ident(struct net *net, int cb_ident)\n{\n\tstruct nfs_client *clp;\n\tstruct nfs_net *nn = net_generic(net, nfs_net_id);\n\n\tspin_lock(&nn->nfs_client_lock);\n\tclp = idr_find(&nn->cb_ident_idr, cb_ident);\n\tif (clp)\n\t\trefcount_inc(&clp->cl_count);\n\tspin_unlock(&nn->nfs_client_lock);\n\treturn clp;\n}\n\n#if defined(CONFIG_NFS_V4_1)\n \nstatic bool nfs4_cb_match_client(const struct sockaddr *addr,\n\t\tstruct nfs_client *clp, u32 minorversion)\n{\n\tstruct sockaddr *clap = (struct sockaddr *)&clp->cl_addr;\n\n\t \n\tif (!(clp->cl_cons_state == NFS_CS_READY ||\n\t    clp->cl_cons_state == NFS_CS_SESSION_INITING))\n\t\treturn false;\n\n\tsmp_rmb();\n\n\t \n\tif (clp->rpc_ops->version != 4 ||\n\t    clp->cl_minorversion != minorversion)\n\t\treturn false;\n\n\t \n\treturn rpc_cmp_addr(addr, clap);\n}\n\n \nstruct nfs_client *\nnfs4_find_client_sessionid(struct net *net, const struct sockaddr *addr,\n\t\t\t   struct nfs4_sessionid *sid, u32 minorversion)\n{\n\tstruct nfs_client *clp;\n\tstruct nfs_net *nn = net_generic(net, nfs_net_id);\n\n\tspin_lock(&nn->nfs_client_lock);\n\tlist_for_each_entry(clp, &nn->nfs_client_list, cl_share_link) {\n\t\tif (!nfs4_cb_match_client(addr, clp, minorversion))\n\t\t\tcontinue;\n\n\t\tif (!nfs4_has_session(clp))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (memcmp(clp->cl_session->sess_id.data,\n\t\t    sid->data, NFS4_MAX_SESSIONID_LEN) != 0)\n\t\t\tcontinue;\n\n\t\trefcount_inc(&clp->cl_count);\n\t\tspin_unlock(&nn->nfs_client_lock);\n\t\treturn clp;\n\t}\n\tspin_unlock(&nn->nfs_client_lock);\n\treturn NULL;\n}\n\n#else  \n\nstruct nfs_client *\nnfs4_find_client_sessionid(struct net *net, const struct sockaddr *addr,\n\t\t\t   struct nfs4_sessionid *sid, u32 minorversion)\n{\n\treturn NULL;\n}\n#endif  \n\n \nstatic int nfs4_set_client(struct nfs_server *server,\n\t\tconst char *hostname,\n\t\tconst struct sockaddr_storage *addr,\n\t\tconst size_t addrlen,\n\t\tconst char *ip_addr,\n\t\tint proto, const struct rpc_timeout *timeparms,\n\t\tu32 minorversion, unsigned int nconnect,\n\t\tunsigned int max_connect,\n\t\tstruct net *net,\n\t\tstruct xprtsec_parms *xprtsec)\n{\n\tstruct nfs_client_initdata cl_init = {\n\t\t.hostname = hostname,\n\t\t.addr = addr,\n\t\t.addrlen = addrlen,\n\t\t.ip_addr = ip_addr,\n\t\t.nfs_mod = &nfs_v4,\n\t\t.proto = proto,\n\t\t.minorversion = minorversion,\n\t\t.net = net,\n\t\t.timeparms = timeparms,\n\t\t.cred = server->cred,\n\t\t.xprtsec = *xprtsec,\n\t};\n\tstruct nfs_client *clp;\n\n\tif (minorversion == 0)\n\t\t__set_bit(NFS_CS_REUSEPORT, &cl_init.init_flags);\n\telse\n\t\tcl_init.max_connect = max_connect;\n\tswitch (proto) {\n\tcase XPRT_TRANSPORT_TCP:\n\tcase XPRT_TRANSPORT_TCP_TLS:\n\t\tcl_init.nconnect = nconnect;\n\t}\n\n\tif (server->flags & NFS_MOUNT_NORESVPORT)\n\t\t__set_bit(NFS_CS_NORESVPORT, &cl_init.init_flags);\n\tif (server->options & NFS_OPTION_MIGRATION)\n\t\t__set_bit(NFS_CS_MIGRATION, &cl_init.init_flags);\n\tif (test_bit(NFS_MIG_TSM_POSSIBLE, &server->mig_status))\n\t\t__set_bit(NFS_CS_TSM_POSSIBLE, &cl_init.init_flags);\n\tserver->port = rpc_get_port((struct sockaddr *)addr);\n\n\t \n\tclp = nfs_get_client(&cl_init);\n\tif (IS_ERR(clp))\n\t\treturn PTR_ERR(clp);\n\n\tif (server->nfs_client == clp) {\n\t\tnfs_put_client(clp);\n\t\treturn -ELOOP;\n\t}\n\n\t \n\tset_bit(NFS_CS_CHECK_LEASE_TIME, &clp->cl_res_state);\n\n\tserver->nfs_client = clp;\n\tnfs_sysfs_add_server(server);\n\tnfs_sysfs_link_rpc_client(server, clp->cl_rpcclient, \"_state\");\n\n\treturn 0;\n}\n\n \nstruct nfs_client *nfs4_set_ds_client(struct nfs_server *mds_srv,\n\t\tconst struct sockaddr_storage *ds_addr, int ds_addrlen,\n\t\tint ds_proto, unsigned int ds_timeo, unsigned int ds_retrans,\n\t\tu32 minor_version)\n{\n\tstruct rpc_timeout ds_timeout;\n\tstruct nfs_client *mds_clp = mds_srv->nfs_client;\n\tstruct nfs_client_initdata cl_init = {\n\t\t.addr = ds_addr,\n\t\t.addrlen = ds_addrlen,\n\t\t.nodename = mds_clp->cl_rpcclient->cl_nodename,\n\t\t.ip_addr = mds_clp->cl_ipaddr,\n\t\t.nfs_mod = &nfs_v4,\n\t\t.proto = ds_proto,\n\t\t.minorversion = minor_version,\n\t\t.net = mds_clp->cl_net,\n\t\t.timeparms = &ds_timeout,\n\t\t.cred = mds_srv->cred,\n\t\t.xprtsec = mds_srv->nfs_client->cl_xprtsec,\n\t};\n\tchar buf[INET6_ADDRSTRLEN + 1];\n\n\tif (rpc_ntop((struct sockaddr *)ds_addr, buf, sizeof(buf)) <= 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tcl_init.hostname = buf;\n\n\tswitch (ds_proto) {\n\tcase XPRT_TRANSPORT_TCP:\n\tcase XPRT_TRANSPORT_TCP_TLS:\n\t\tif (mds_clp->cl_nconnect > 1) {\n\t\t\tcl_init.nconnect = mds_clp->cl_nconnect;\n\t\t\tcl_init.max_connect = NFS_MAX_TRANSPORTS;\n\t\t}\n\t}\n\n\tif (mds_srv->flags & NFS_MOUNT_NORESVPORT)\n\t\t__set_bit(NFS_CS_NORESVPORT, &cl_init.init_flags);\n\n\t__set_bit(NFS_CS_DS, &cl_init.init_flags);\n\t__set_bit(NFS_CS_PNFS, &cl_init.init_flags);\n\tcl_init.max_connect = NFS_MAX_TRANSPORTS;\n\t \n\tnfs_init_timeout_values(&ds_timeout, ds_proto, ds_timeo, ds_retrans);\n\treturn nfs_get_client(&cl_init);\n}\nEXPORT_SYMBOL_GPL(nfs4_set_ds_client);\n\n \nstatic void nfs4_session_limit_rwsize(struct nfs_server *server)\n{\n#ifdef CONFIG_NFS_V4_1\n\tstruct nfs4_session *sess;\n\tu32 server_resp_sz;\n\tu32 server_rqst_sz;\n\n\tif (!nfs4_has_session(server->nfs_client))\n\t\treturn;\n\tsess = server->nfs_client->cl_session;\n\tserver_resp_sz = sess->fc_attrs.max_resp_sz - nfs41_maxread_overhead;\n\tserver_rqst_sz = sess->fc_attrs.max_rqst_sz - nfs41_maxwrite_overhead;\n\n\tif (server->dtsize > server_resp_sz)\n\t\tserver->dtsize = server_resp_sz;\n\tif (server->rsize > server_resp_sz)\n\t\tserver->rsize = server_resp_sz;\n\tif (server->wsize > server_rqst_sz)\n\t\tserver->wsize = server_rqst_sz;\n#endif  \n}\n\n \nstatic void nfs4_session_limit_xasize(struct nfs_server *server)\n{\n#ifdef CONFIG_NFS_V4_2\n\tstruct nfs4_session *sess;\n\tu32 server_gxa_sz;\n\tu32 server_sxa_sz;\n\tu32 server_lxa_sz;\n\n\tif (!nfs4_has_session(server->nfs_client))\n\t\treturn;\n\n\tsess = server->nfs_client->cl_session;\n\n\tserver_gxa_sz = sess->fc_attrs.max_resp_sz - nfs42_maxgetxattr_overhead;\n\tserver_sxa_sz = sess->fc_attrs.max_rqst_sz - nfs42_maxsetxattr_overhead;\n\tserver_lxa_sz = sess->fc_attrs.max_resp_sz -\n\t    nfs42_maxlistxattrs_overhead;\n\n\tif (server->gxasize > server_gxa_sz)\n\t\tserver->gxasize = server_gxa_sz;\n\tif (server->sxasize > server_sxa_sz)\n\t\tserver->sxasize = server_sxa_sz;\n\tif (server->lxasize > server_lxa_sz)\n\t\tserver->lxasize = server_lxa_sz;\n#endif\n}\n\nvoid nfs4_server_set_init_caps(struct nfs_server *server)\n{\n\t \n\tserver->caps |= server->nfs_client->cl_mvops->init_caps;\n\tif (server->flags & NFS_MOUNT_NORDIRPLUS)\n\t\t\tserver->caps &= ~NFS_CAP_READDIRPLUS;\n\tif (server->nfs_client->cl_proto == XPRT_TRANSPORT_RDMA)\n\t\tserver->caps &= ~NFS_CAP_READ_PLUS;\n\n\t \n\tif (nfs4_disable_idmapping &&\n\t\t\tserver->client->cl_auth->au_flavor == RPC_AUTH_UNIX)\n\t\tserver->caps |= NFS_CAP_UIDGID_NOMAP;\n}\n\nstatic int nfs4_server_common_setup(struct nfs_server *server,\n\t\tstruct nfs_fh *mntfh, bool auth_probe)\n{\n\tint error;\n\n\t \n\tif (is_ds_only_client(server->nfs_client))\n\t\treturn -EPROTONOSUPPORT;\n\n\t \n\terror = nfs4_init_session(server->nfs_client);\n\tif (error < 0)\n\t\tgoto out;\n\n\tnfs4_server_set_init_caps(server);\n\n\t \n\terror = nfs4_get_rootfh(server, mntfh, auth_probe);\n\tif (error < 0)\n\t\tgoto out;\n\n\tdprintk(\"Server FSID: %llx:%llx\\n\",\n\t\t\t(unsigned long long) server->fsid.major,\n\t\t\t(unsigned long long) server->fsid.minor);\n\tnfs_display_fhandle(mntfh, \"Pseudo-fs root FH\");\n\n\terror = nfs_probe_server(server, mntfh);\n\tif (error < 0)\n\t\tgoto out;\n\n\tnfs4_session_limit_rwsize(server);\n\tnfs4_session_limit_xasize(server);\n\n\tif (server->namelen == 0 || server->namelen > NFS4_MAXNAMLEN)\n\t\tserver->namelen = NFS4_MAXNAMLEN;\n\n\tnfs_server_insert_lists(server);\n\tserver->mount_time = jiffies;\n\tserver->destroy = nfs4_destroy_server;\nout:\n\treturn error;\n}\n\n \nstatic int nfs4_init_server(struct nfs_server *server, struct fs_context *fc)\n{\n\tstruct nfs_fs_context *ctx = nfs_fc2context(fc);\n\tstruct rpc_timeout timeparms;\n\tint error;\n\n\tnfs_init_timeout_values(&timeparms, ctx->nfs_server.protocol,\n\t\t\t\tctx->timeo, ctx->retrans);\n\n\t \n\tserver->flags = ctx->flags;\n\tserver->options = ctx->options;\n\tserver->auth_info = ctx->auth_info;\n\n\t \n\tif (ctx->auth_info.flavor_len >= 1)\n\t\tctx->selected_flavor = ctx->auth_info.flavors[0];\n\telse\n\t\tctx->selected_flavor = RPC_AUTH_UNIX;\n\n\t \n\terror = nfs4_set_client(server,\n\t\t\t\tctx->nfs_server.hostname,\n\t\t\t\t&ctx->nfs_server._address,\n\t\t\t\tctx->nfs_server.addrlen,\n\t\t\t\tctx->client_address,\n\t\t\t\tctx->nfs_server.protocol,\n\t\t\t\t&timeparms,\n\t\t\t\tctx->minorversion,\n\t\t\t\tctx->nfs_server.nconnect,\n\t\t\t\tctx->nfs_server.max_connect,\n\t\t\t\tfc->net_ns,\n\t\t\t\t&ctx->xprtsec);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (ctx->rsize)\n\t\tserver->rsize = nfs_io_size(ctx->rsize, server->nfs_client->cl_proto);\n\tif (ctx->wsize)\n\t\tserver->wsize = nfs_io_size(ctx->wsize, server->nfs_client->cl_proto);\n\n\tserver->acregmin = ctx->acregmin * HZ;\n\tserver->acregmax = ctx->acregmax * HZ;\n\tserver->acdirmin = ctx->acdirmin * HZ;\n\tserver->acdirmax = ctx->acdirmax * HZ;\n\tserver->port     = ctx->nfs_server.port;\n\n\treturn nfs_init_server_rpcclient(server, &timeparms,\n\t\t\t\t\t ctx->selected_flavor);\n}\n\n \nstruct nfs_server *nfs4_create_server(struct fs_context *fc)\n{\n\tstruct nfs_fs_context *ctx = nfs_fc2context(fc);\n\tstruct nfs_server *server;\n\tbool auth_probe;\n\tint error;\n\n\tserver = nfs_alloc_server();\n\tif (!server)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tserver->cred = get_cred(fc->cred);\n\n\tauth_probe = ctx->auth_info.flavor_len < 1;\n\n\t \n\terror = nfs4_init_server(server, fc);\n\tif (error < 0)\n\t\tgoto error;\n\n\terror = nfs4_server_common_setup(server, ctx->mntfh, auth_probe);\n\tif (error < 0)\n\t\tgoto error;\n\n\treturn server;\n\nerror:\n\tnfs_free_server(server);\n\treturn ERR_PTR(error);\n}\n\n \nstruct nfs_server *nfs4_create_referral_server(struct fs_context *fc)\n{\n\tstruct nfs_fs_context *ctx = nfs_fc2context(fc);\n\tstruct nfs_client *parent_client;\n\tstruct nfs_server *server, *parent_server;\n\tint proto, error;\n\tbool auth_probe;\n\n\tserver = nfs_alloc_server();\n\tif (!server)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tparent_server = NFS_SB(ctx->clone_data.sb);\n\tparent_client = parent_server->nfs_client;\n\n\tserver->cred = get_cred(parent_server->cred);\n\n\t \n\tnfs_server_copy_userdata(server, parent_server);\n\n\t \n#if IS_ENABLED(CONFIG_SUNRPC_XPRT_RDMA)\n\trpc_set_port(&ctx->nfs_server.address, NFS_RDMA_PORT);\n\terror = nfs4_set_client(server,\n\t\t\t\tctx->nfs_server.hostname,\n\t\t\t\t&ctx->nfs_server._address,\n\t\t\t\tctx->nfs_server.addrlen,\n\t\t\t\tparent_client->cl_ipaddr,\n\t\t\t\tXPRT_TRANSPORT_RDMA,\n\t\t\t\tparent_server->client->cl_timeout,\n\t\t\t\tparent_client->cl_mvops->minor_version,\n\t\t\t\tparent_client->cl_nconnect,\n\t\t\t\tparent_client->cl_max_connect,\n\t\t\t\tparent_client->cl_net,\n\t\t\t\t&parent_client->cl_xprtsec);\n\tif (!error)\n\t\tgoto init_server;\n#endif\t \n\n\tproto = XPRT_TRANSPORT_TCP;\n\tif (parent_client->cl_xprtsec.policy != RPC_XPRTSEC_NONE)\n\t\tproto = XPRT_TRANSPORT_TCP_TLS;\n\trpc_set_port(&ctx->nfs_server.address, NFS_PORT);\n\terror = nfs4_set_client(server,\n\t\t\t\tctx->nfs_server.hostname,\n\t\t\t\t&ctx->nfs_server._address,\n\t\t\t\tctx->nfs_server.addrlen,\n\t\t\t\tparent_client->cl_ipaddr,\n\t\t\t\tproto,\n\t\t\t\tparent_server->client->cl_timeout,\n\t\t\t\tparent_client->cl_mvops->minor_version,\n\t\t\t\tparent_client->cl_nconnect,\n\t\t\t\tparent_client->cl_max_connect,\n\t\t\t\tparent_client->cl_net,\n\t\t\t\t&parent_client->cl_xprtsec);\n\tif (error < 0)\n\t\tgoto error;\n\n#if IS_ENABLED(CONFIG_SUNRPC_XPRT_RDMA)\ninit_server:\n#endif\n\terror = nfs_init_server_rpcclient(server, parent_server->client->cl_timeout,\n\t\t\t\t\t  ctx->selected_flavor);\n\tif (error < 0)\n\t\tgoto error;\n\n\tauth_probe = parent_server->auth_info.flavor_len < 1;\n\n\terror = nfs4_server_common_setup(server, ctx->mntfh, auth_probe);\n\tif (error < 0)\n\t\tgoto error;\n\n\treturn server;\n\nerror:\n\tnfs_free_server(server);\n\treturn ERR_PTR(error);\n}\n\n \nint nfs4_update_server(struct nfs_server *server, const char *hostname,\n\t\t       struct sockaddr_storage *sap, size_t salen, struct net *net)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct rpc_clnt *clnt = server->client;\n\tstruct xprt_create xargs = {\n\t\t.ident\t\t= clp->cl_proto,\n\t\t.net\t\t= net,\n\t\t.dstaddr\t= (struct sockaddr *)sap,\n\t\t.addrlen\t= salen,\n\t\t.servername\t= hostname,\n\t\t \n\t};\n\tchar buf[INET6_ADDRSTRLEN + 1];\n\tstruct sockaddr_storage address;\n\tstruct sockaddr *localaddr = (struct sockaddr *)&address;\n\tint error;\n\n\terror = rpc_switch_client_transport(clnt, &xargs, clnt->cl_timeout);\n\tif (error != 0)\n\t\treturn error;\n\n\terror = rpc_localaddr(clnt, localaddr, sizeof(address));\n\tif (error != 0)\n\t\treturn error;\n\n\tif (rpc_ntop(localaddr, buf, sizeof(buf)) == 0)\n\t\treturn -EAFNOSUPPORT;\n\n\tnfs_server_remove_lists(server);\n\tset_bit(NFS_MIG_TSM_POSSIBLE, &server->mig_status);\n\terror = nfs4_set_client(server, hostname, sap, salen, buf,\n\t\t\t\tclp->cl_proto, clnt->cl_timeout,\n\t\t\t\tclp->cl_minorversion,\n\t\t\t\tclp->cl_nconnect, clp->cl_max_connect,\n\t\t\t\tnet, &clp->cl_xprtsec);\n\tclear_bit(NFS_MIG_TSM_POSSIBLE, &server->mig_status);\n\tif (error != 0) {\n\t\tnfs_server_insert_lists(server);\n\t\treturn error;\n\t}\n\tnfs_put_client(clp);\n\n\tif (server->nfs_client->cl_hostname == NULL) {\n\t\tserver->nfs_client->cl_hostname = kstrdup(hostname, GFP_KERNEL);\n\t\tif (server->nfs_client->cl_hostname == NULL)\n\t\t\treturn -ENOMEM;\n\t}\n\tnfs_server_insert_lists(server);\n\n\treturn nfs_probe_server(server, NFS_FH(d_inode(server->super->s_root)));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}