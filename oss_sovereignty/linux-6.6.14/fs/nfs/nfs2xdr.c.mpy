{
  "module_name": "nfs2xdr.c",
  "hash_id": "bce91ca1679e4766eb923ca5519de36abcfd47ed3c16f768ee525c1b8199f427",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfs/nfs2xdr.c",
  "human_readable_source": "\n \n\n#include <linux/param.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/in.h>\n#include <linux/pagemap.h>\n#include <linux/proc_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/nfs.h>\n#include <linux/nfs2.h>\n#include <linux/nfs_fs.h>\n#include \"nfstrace.h\"\n#include \"internal.h\"\n\n#define NFSDBG_FACILITY\t\tNFSDBG_XDR\n\n \n#define errno_NFSERR_IO\t\tEIO\n\n \n#define NFS_pagepad_sz\t\t(1)  \n#define NFS_fhandle_sz\t\t(8)\n#define NFS_sattr_sz\t\t(8)\n#define NFS_filename_sz\t\t(1+(NFS2_MAXNAMLEN>>2))\n#define NFS_path_sz\t\t(1+(NFS2_MAXPATHLEN>>2))\n#define NFS_fattr_sz\t\t(17)\n#define NFS_info_sz\t\t(5)\n#define NFS_entry_sz\t\t(NFS_filename_sz+3)\n\n#define NFS_diropargs_sz\t(NFS_fhandle_sz+NFS_filename_sz)\n#define NFS_removeargs_sz\t(NFS_fhandle_sz+NFS_filename_sz)\n#define NFS_sattrargs_sz\t(NFS_fhandle_sz+NFS_sattr_sz)\n#define NFS_readlinkargs_sz\t(NFS_fhandle_sz)\n#define NFS_readargs_sz\t\t(NFS_fhandle_sz+3)\n#define NFS_writeargs_sz\t(NFS_fhandle_sz+4)\n#define NFS_createargs_sz\t(NFS_diropargs_sz+NFS_sattr_sz)\n#define NFS_renameargs_sz\t(NFS_diropargs_sz+NFS_diropargs_sz)\n#define NFS_linkargs_sz\t\t(NFS_fhandle_sz+NFS_diropargs_sz)\n#define NFS_symlinkargs_sz\t(NFS_diropargs_sz+1+NFS_sattr_sz)\n#define NFS_readdirargs_sz\t(NFS_fhandle_sz+2)\n\n#define NFS_attrstat_sz\t\t(1+NFS_fattr_sz)\n#define NFS_diropres_sz\t\t(1+NFS_fhandle_sz+NFS_fattr_sz)\n#define NFS_readlinkres_sz\t(2+NFS_pagepad_sz)\n#define NFS_readres_sz\t\t(1+NFS_fattr_sz+1+NFS_pagepad_sz)\n#define NFS_writeres_sz         (NFS_attrstat_sz)\n#define NFS_stat_sz\t\t(1)\n#define NFS_readdirres_sz\t(1+NFS_pagepad_sz)\n#define NFS_statfsres_sz\t(1+NFS_info_sz)\n\nstatic int nfs_stat_to_errno(enum nfs_stat);\n\n \n\nstatic struct user_namespace *rpc_userns(const struct rpc_clnt *clnt)\n{\n\tif (clnt && clnt->cl_cred)\n\t\treturn clnt->cl_cred->user_ns;\n\treturn &init_user_ns;\n}\n\nstatic struct user_namespace *rpc_rqst_userns(const struct rpc_rqst *rqstp)\n{\n\tif (rqstp->rq_task)\n\t\treturn rpc_userns(rqstp->rq_task->tk_client);\n\treturn &init_user_ns;\n}\n\n \nstatic int decode_nfsdata(struct xdr_stream *xdr, struct nfs_pgio_res *result)\n{\n\tu32 recvd, count;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tcount = be32_to_cpup(p);\n\trecvd = xdr_read_pages(xdr, count);\n\tif (unlikely(count > recvd))\n\t\tgoto out_cheating;\nout:\n\tresult->eof = 0;\t \n\tresult->count = count;\n\treturn count;\nout_cheating:\n\tdprintk(\"NFS: server cheating in read result: \"\n\t\t\"count %u > recvd %u\\n\", count, recvd);\n\tcount = recvd;\n\tgoto out;\n}\n\n \nstatic int decode_stat(struct xdr_stream *xdr, enum nfs_stat *status)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tif (unlikely(*p != cpu_to_be32(NFS_OK)))\n\t\tgoto out_status;\n\t*status = 0;\n\treturn 0;\nout_status:\n\t*status = be32_to_cpup(p);\n\ttrace_nfs_xdr_status(xdr, (int)*status);\n\treturn 0;\n}\n\n \nstatic __be32 *xdr_decode_ftype(__be32 *p, u32 *type)\n{\n\t*type = be32_to_cpup(p++);\n\tif (unlikely(*type > NF2FIFO))\n\t\t*type = NFBAD;\n\treturn p;\n}\n\n \nstatic void encode_fhandle(struct xdr_stream *xdr, const struct nfs_fh *fh)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, NFS2_FHSIZE);\n\tmemcpy(p, fh->data, NFS2_FHSIZE);\n}\n\nstatic int decode_fhandle(struct xdr_stream *xdr, struct nfs_fh *fh)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, NFS2_FHSIZE);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tfh->size = NFS2_FHSIZE;\n\tmemcpy(fh->data, p, NFS2_FHSIZE);\n\treturn 0;\n}\n\n \nstatic __be32 *xdr_encode_time(__be32 *p, const struct timespec64 *timep)\n{\n\t*p++ = cpu_to_be32((u32)timep->tv_sec);\n\tif (timep->tv_nsec != 0)\n\t\t*p++ = cpu_to_be32(timep->tv_nsec / NSEC_PER_USEC);\n\telse\n\t\t*p++ = cpu_to_be32(0);\n\treturn p;\n}\n\n \nstatic __be32 *xdr_encode_current_server_time(__be32 *p,\n\t\t\t\t\t      const struct timespec64 *timep)\n{\n\t*p++ = cpu_to_be32(timep->tv_sec);\n\t*p++ = cpu_to_be32(1000000);\n\treturn p;\n}\n\nstatic __be32 *xdr_decode_time(__be32 *p, struct timespec64 *timep)\n{\n\ttimep->tv_sec = be32_to_cpup(p++);\n\ttimep->tv_nsec = be32_to_cpup(p++) * NSEC_PER_USEC;\n\treturn p;\n}\n\n \nstatic int decode_fattr(struct xdr_stream *xdr, struct nfs_fattr *fattr,\n\t\tstruct user_namespace *userns)\n{\n\tu32 rdev, type;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, NFS_fattr_sz << 2);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\n\tfattr->valid |= NFS_ATTR_FATTR_V2;\n\n\tp = xdr_decode_ftype(p, &type);\n\n\tfattr->mode = be32_to_cpup(p++);\n\tfattr->nlink = be32_to_cpup(p++);\n\tfattr->uid = make_kuid(userns, be32_to_cpup(p++));\n\tif (!uid_valid(fattr->uid))\n\t\tgoto out_uid;\n\tfattr->gid = make_kgid(userns, be32_to_cpup(p++));\n\tif (!gid_valid(fattr->gid))\n\t\tgoto out_gid;\n\t\t\n\tfattr->size = be32_to_cpup(p++);\n\tfattr->du.nfs2.blocksize = be32_to_cpup(p++);\n\n\trdev = be32_to_cpup(p++);\n\tfattr->rdev = new_decode_dev(rdev);\n\tif (type == (u32)NFCHR && rdev == (u32)NFS2_FIFO_DEV) {\n\t\tfattr->mode = (fattr->mode & ~S_IFMT) | S_IFIFO;\n\t\tfattr->rdev = 0;\n\t}\n\n\tfattr->du.nfs2.blocks = be32_to_cpup(p++);\n\tfattr->fsid.major = be32_to_cpup(p++);\n\tfattr->fsid.minor = 0;\n\tfattr->fileid = be32_to_cpup(p++);\n\n\tp = xdr_decode_time(p, &fattr->atime);\n\tp = xdr_decode_time(p, &fattr->mtime);\n\txdr_decode_time(p, &fattr->ctime);\n\tfattr->change_attr = nfs_timespec_to_change_attr(&fattr->ctime);\n\n\treturn 0;\nout_uid:\n\tdprintk(\"NFS: returned invalid uid\\n\");\n\treturn -EINVAL;\nout_gid:\n\tdprintk(\"NFS: returned invalid gid\\n\");\n\treturn -EINVAL;\n}\n\n \n\n#define NFS2_SATTR_NOT_SET\t(0xffffffff)\n\nstatic __be32 *xdr_time_not_set(__be32 *p)\n{\n\t*p++ = cpu_to_be32(NFS2_SATTR_NOT_SET);\n\t*p++ = cpu_to_be32(NFS2_SATTR_NOT_SET);\n\treturn p;\n}\n\nstatic void encode_sattr(struct xdr_stream *xdr, const struct iattr *attr,\n\t\tstruct user_namespace *userns)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, NFS_sattr_sz << 2);\n\n\tif (attr->ia_valid & ATTR_MODE)\n\t\t*p++ = cpu_to_be32(attr->ia_mode);\n\telse\n\t\t*p++ = cpu_to_be32(NFS2_SATTR_NOT_SET);\n\tif (attr->ia_valid & ATTR_UID)\n\t\t*p++ = cpu_to_be32(from_kuid_munged(userns, attr->ia_uid));\n\telse\n\t\t*p++ = cpu_to_be32(NFS2_SATTR_NOT_SET);\n\tif (attr->ia_valid & ATTR_GID)\n\t\t*p++ = cpu_to_be32(from_kgid_munged(userns, attr->ia_gid));\n\telse\n\t\t*p++ = cpu_to_be32(NFS2_SATTR_NOT_SET);\n\tif (attr->ia_valid & ATTR_SIZE)\n\t\t*p++ = cpu_to_be32((u32)attr->ia_size);\n\telse\n\t\t*p++ = cpu_to_be32(NFS2_SATTR_NOT_SET);\n\n\tif (attr->ia_valid & ATTR_ATIME_SET)\n\t\tp = xdr_encode_time(p, &attr->ia_atime);\n\telse if (attr->ia_valid & ATTR_ATIME)\n\t\tp = xdr_encode_current_server_time(p, &attr->ia_atime);\n\telse\n\t\tp = xdr_time_not_set(p);\n\tif (attr->ia_valid & ATTR_MTIME_SET)\n\t\txdr_encode_time(p, &attr->ia_mtime);\n\telse if (attr->ia_valid & ATTR_MTIME)\n\t\txdr_encode_current_server_time(p, &attr->ia_mtime);\n\telse\n\t\txdr_time_not_set(p);\n}\n\n \nstatic void encode_filename(struct xdr_stream *xdr,\n\t\t\t    const char *name, u32 length)\n{\n\t__be32 *p;\n\n\tWARN_ON_ONCE(length > NFS2_MAXNAMLEN);\n\tp = xdr_reserve_space(xdr, 4 + length);\n\txdr_encode_opaque(p, name, length);\n}\n\nstatic int decode_filename_inline(struct xdr_stream *xdr,\n\t\t\t\t  const char **name, u32 *length)\n{\n\t__be32 *p;\n\tu32 count;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tcount = be32_to_cpup(p);\n\tif (count > NFS3_MAXNAMLEN)\n\t\tgoto out_nametoolong;\n\tp = xdr_inline_decode(xdr, count);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\t*name = (const char *)p;\n\t*length = count;\n\treturn 0;\nout_nametoolong:\n\tdprintk(\"NFS: returned filename too long: %u\\n\", count);\n\treturn -ENAMETOOLONG;\n}\n\n \nstatic void encode_path(struct xdr_stream *xdr, struct page **pages, u32 length)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4);\n\t*p = cpu_to_be32(length);\n\txdr_write_pages(xdr, pages, 0, length);\n}\n\nstatic int decode_path(struct xdr_stream *xdr)\n{\n\tu32 length, recvd;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tlength = be32_to_cpup(p);\n\tif (unlikely(length >= xdr->buf->page_len || length > NFS_MAXPATHLEN))\n\t\tgoto out_size;\n\trecvd = xdr_read_pages(xdr, length);\n\tif (unlikely(length > recvd))\n\t\tgoto out_cheating;\n\txdr_terminate_string(xdr->buf, length);\n\treturn 0;\nout_size:\n\tdprintk(\"NFS: returned pathname too long: %u\\n\", length);\n\treturn -ENAMETOOLONG;\nout_cheating:\n\tdprintk(\"NFS: server cheating in pathname result: \"\n\t\t\"length %u > received %u\\n\", length, recvd);\n\treturn -EIO;\n}\n\n \nstatic int decode_attrstat(struct xdr_stream *xdr, struct nfs_fattr *result,\n\t\t\t   __u32 *op_status,\n\t\t\t   struct user_namespace *userns)\n{\n\tenum nfs_stat status;\n\tint error;\n\n\terror = decode_stat(xdr, &status);\n\tif (unlikely(error))\n\t\tgoto out;\n\tif (op_status)\n\t\t*op_status = status;\n\tif (status != NFS_OK)\n\t\tgoto out_default;\n\terror = decode_fattr(xdr, result, userns);\nout:\n\treturn error;\nout_default:\n\treturn nfs_stat_to_errno(status);\n}\n\n \nstatic void encode_diropargs(struct xdr_stream *xdr, const struct nfs_fh *fh,\n\t\t\t     const char *name, u32 length)\n{\n\tencode_fhandle(xdr, fh);\n\tencode_filename(xdr, name, length);\n}\n\n \nstatic int decode_diropok(struct xdr_stream *xdr, struct nfs_diropok *result,\n\t\tstruct user_namespace *userns)\n{\n\tint error;\n\n\terror = decode_fhandle(xdr, result->fh);\n\tif (unlikely(error))\n\t\tgoto out;\n\terror = decode_fattr(xdr, result->fattr, userns);\nout:\n\treturn error;\n}\n\nstatic int decode_diropres(struct xdr_stream *xdr, struct nfs_diropok *result,\n\t\tstruct user_namespace *userns)\n{\n\tenum nfs_stat status;\n\tint error;\n\n\terror = decode_stat(xdr, &status);\n\tif (unlikely(error))\n\t\tgoto out;\n\tif (status != NFS_OK)\n\t\tgoto out_default;\n\terror = decode_diropok(xdr, result, userns);\nout:\n\treturn error;\nout_default:\n\treturn nfs_stat_to_errno(status);\n}\n\n\n \n\nstatic void nfs2_xdr_enc_fhandle(struct rpc_rqst *req,\n\t\t\t\t struct xdr_stream *xdr,\n\t\t\t\t const void *data)\n{\n\tconst struct nfs_fh *fh = data;\n\n\tencode_fhandle(xdr, fh);\n}\n\n \nstatic void nfs2_xdr_enc_sattrargs(struct rpc_rqst *req,\n\t\t\t\t   struct xdr_stream *xdr,\n\t\t\t\t   const void *data)\n{\n\tconst struct nfs_sattrargs *args = data;\n\n\tencode_fhandle(xdr, args->fh);\n\tencode_sattr(xdr, args->sattr, rpc_rqst_userns(req));\n}\n\nstatic void nfs2_xdr_enc_diropargs(struct rpc_rqst *req,\n\t\t\t\t   struct xdr_stream *xdr,\n\t\t\t\t   const void *data)\n{\n\tconst struct nfs_diropargs *args = data;\n\n\tencode_diropargs(xdr, args->fh, args->name, args->len);\n}\n\nstatic void nfs2_xdr_enc_readlinkargs(struct rpc_rqst *req,\n\t\t\t\t      struct xdr_stream *xdr,\n\t\t\t\t      const void *data)\n{\n\tconst struct nfs_readlinkargs *args = data;\n\n\tencode_fhandle(xdr, args->fh);\n\trpc_prepare_reply_pages(req, args->pages, args->pgbase, args->pglen,\n\t\t\t\tNFS_readlinkres_sz - NFS_pagepad_sz);\n}\n\n \nstatic void encode_readargs(struct xdr_stream *xdr,\n\t\t\t    const struct nfs_pgio_args *args)\n{\n\tu32 offset = args->offset;\n\tu32 count = args->count;\n\t__be32 *p;\n\n\tencode_fhandle(xdr, args->fh);\n\n\tp = xdr_reserve_space(xdr, 4 + 4 + 4);\n\t*p++ = cpu_to_be32(offset);\n\t*p++ = cpu_to_be32(count);\n\t*p = cpu_to_be32(count);\n}\n\nstatic void nfs2_xdr_enc_readargs(struct rpc_rqst *req,\n\t\t\t\t  struct xdr_stream *xdr,\n\t\t\t\t  const void *data)\n{\n\tconst struct nfs_pgio_args *args = data;\n\n\tencode_readargs(xdr, args);\n\trpc_prepare_reply_pages(req, args->pages, args->pgbase, args->count,\n\t\t\t\tNFS_readres_sz - NFS_pagepad_sz);\n\treq->rq_rcv_buf.flags |= XDRBUF_READ;\n}\n\n \nstatic void encode_writeargs(struct xdr_stream *xdr,\n\t\t\t     const struct nfs_pgio_args *args)\n{\n\tu32 offset = args->offset;\n\tu32 count = args->count;\n\t__be32 *p;\n\n\tencode_fhandle(xdr, args->fh);\n\n\tp = xdr_reserve_space(xdr, 4 + 4 + 4 + 4);\n\t*p++ = cpu_to_be32(offset);\n\t*p++ = cpu_to_be32(offset);\n\t*p++ = cpu_to_be32(count);\n\n\t \n\t*p = cpu_to_be32(count);\n\txdr_write_pages(xdr, args->pages, args->pgbase, count);\n}\n\nstatic void nfs2_xdr_enc_writeargs(struct rpc_rqst *req,\n\t\t\t\t   struct xdr_stream *xdr,\n\t\t\t\t   const void *data)\n{\n\tconst struct nfs_pgio_args *args = data;\n\n\tencode_writeargs(xdr, args);\n\txdr->buf->flags |= XDRBUF_WRITE;\n}\n\n \nstatic void nfs2_xdr_enc_createargs(struct rpc_rqst *req,\n\t\t\t\t    struct xdr_stream *xdr,\n\t\t\t\t    const void *data)\n{\n\tconst struct nfs_createargs *args = data;\n\n\tencode_diropargs(xdr, args->fh, args->name, args->len);\n\tencode_sattr(xdr, args->sattr, rpc_rqst_userns(req));\n}\n\nstatic void nfs2_xdr_enc_removeargs(struct rpc_rqst *req,\n\t\t\t\t    struct xdr_stream *xdr,\n\t\t\t\t    const void *data)\n{\n\tconst struct nfs_removeargs *args = data;\n\n\tencode_diropargs(xdr, args->fh, args->name.name, args->name.len);\n}\n\n \nstatic void nfs2_xdr_enc_renameargs(struct rpc_rqst *req,\n\t\t\t\t    struct xdr_stream *xdr,\n\t\t\t\t    const void *data)\n{\n\tconst struct nfs_renameargs *args = data;\n\tconst struct qstr *old = args->old_name;\n\tconst struct qstr *new = args->new_name;\n\n\tencode_diropargs(xdr, args->old_dir, old->name, old->len);\n\tencode_diropargs(xdr, args->new_dir, new->name, new->len);\n}\n\n \nstatic void nfs2_xdr_enc_linkargs(struct rpc_rqst *req,\n\t\t\t\t  struct xdr_stream *xdr,\n\t\t\t\t  const void *data)\n{\n\tconst struct nfs_linkargs *args = data;\n\n\tencode_fhandle(xdr, args->fromfh);\n\tencode_diropargs(xdr, args->tofh, args->toname, args->tolen);\n}\n\n \nstatic void nfs2_xdr_enc_symlinkargs(struct rpc_rqst *req,\n\t\t\t\t     struct xdr_stream *xdr,\n\t\t\t\t     const void *data)\n{\n\tconst struct nfs_symlinkargs *args = data;\n\n\tencode_diropargs(xdr, args->fromfh, args->fromname, args->fromlen);\n\tencode_path(xdr, args->pages, args->pathlen);\n\tencode_sattr(xdr, args->sattr, rpc_rqst_userns(req));\n}\n\n \nstatic void encode_readdirargs(struct xdr_stream *xdr,\n\t\t\t       const struct nfs_readdirargs *args)\n{\n\t__be32 *p;\n\n\tencode_fhandle(xdr, args->fh);\n\n\tp = xdr_reserve_space(xdr, 4 + 4);\n\t*p++ = cpu_to_be32(args->cookie);\n\t*p = cpu_to_be32(args->count);\n}\n\nstatic void nfs2_xdr_enc_readdirargs(struct rpc_rqst *req,\n\t\t\t\t     struct xdr_stream *xdr,\n\t\t\t\t     const void *data)\n{\n\tconst struct nfs_readdirargs *args = data;\n\n\tencode_readdirargs(xdr, args);\n\trpc_prepare_reply_pages(req, args->pages, 0, args->count,\n\t\t\t\tNFS_readdirres_sz - NFS_pagepad_sz);\n}\n\n \n\nstatic int nfs2_xdr_dec_stat(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t     void *__unused)\n{\n\tenum nfs_stat status;\n\tint error;\n\n\terror = decode_stat(xdr, &status);\n\tif (unlikely(error))\n\t\tgoto out;\n\tif (status != NFS_OK)\n\t\tgoto out_default;\nout:\n\treturn error;\nout_default:\n\treturn nfs_stat_to_errno(status);\n}\n\nstatic int nfs2_xdr_dec_attrstat(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\t void *result)\n{\n\treturn decode_attrstat(xdr, result, NULL, rpc_rqst_userns(req));\n}\n\nstatic int nfs2_xdr_dec_diropres(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\t void *result)\n{\n\treturn decode_diropres(xdr, result, rpc_rqst_userns(req));\n}\n\n \nstatic int nfs2_xdr_dec_readlinkres(struct rpc_rqst *req,\n\t\t\t\t    struct xdr_stream *xdr, void *__unused)\n{\n\tenum nfs_stat status;\n\tint error;\n\n\terror = decode_stat(xdr, &status);\n\tif (unlikely(error))\n\t\tgoto out;\n\tif (status != NFS_OK)\n\t\tgoto out_default;\n\terror = decode_path(xdr);\nout:\n\treturn error;\nout_default:\n\treturn nfs_stat_to_errno(status);\n}\n\n \nstatic int nfs2_xdr_dec_readres(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\tvoid *data)\n{\n\tstruct nfs_pgio_res *result = data;\n\tenum nfs_stat status;\n\tint error;\n\n\terror = decode_stat(xdr, &status);\n\tif (unlikely(error))\n\t\tgoto out;\n\tresult->op_status = status;\n\tif (status != NFS_OK)\n\t\tgoto out_default;\n\terror = decode_fattr(xdr, result->fattr, rpc_rqst_userns(req));\n\tif (unlikely(error))\n\t\tgoto out;\n\terror = decode_nfsdata(xdr, result);\nout:\n\treturn error;\nout_default:\n\treturn nfs_stat_to_errno(status);\n}\n\nstatic int nfs2_xdr_dec_writeres(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\t void *data)\n{\n\tstruct nfs_pgio_res *result = data;\n\n\t \n\tresult->verf->committed = NFS_FILE_SYNC;\n\treturn decode_attrstat(xdr, result->fattr, &result->op_status,\n\t\t\trpc_rqst_userns(req));\n}\n\n \nint nfs2_decode_dirent(struct xdr_stream *xdr, struct nfs_entry *entry,\n\t\t       bool plus)\n{\n\t__be32 *p;\n\tint error;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -EAGAIN;\n\tif (*p++ == xdr_zero) {\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EAGAIN;\n\t\tif (*p++ == xdr_zero)\n\t\t\treturn -EAGAIN;\n\t\tentry->eof = 1;\n\t\treturn -EBADCOOKIE;\n\t}\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -EAGAIN;\n\tentry->ino = be32_to_cpup(p);\n\n\terror = decode_filename_inline(xdr, &entry->name, &entry->len);\n\tif (unlikely(error))\n\t\treturn error == -ENAMETOOLONG ? -ENAMETOOLONG : -EAGAIN;\n\n\t \n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -EAGAIN;\n\tentry->cookie = be32_to_cpup(p);\n\n\tentry->d_type = DT_UNKNOWN;\n\n\treturn 0;\n}\n\n \nstatic int decode_readdirok(struct xdr_stream *xdr)\n{\n\treturn xdr_read_pages(xdr, xdr->buf->page_len);\n}\n\nstatic int nfs2_xdr_dec_readdirres(struct rpc_rqst *req,\n\t\t\t\t   struct xdr_stream *xdr, void *__unused)\n{\n\tenum nfs_stat status;\n\tint error;\n\n\terror = decode_stat(xdr, &status);\n\tif (unlikely(error))\n\t\tgoto out;\n\tif (status != NFS_OK)\n\t\tgoto out_default;\n\terror = decode_readdirok(xdr);\nout:\n\treturn error;\nout_default:\n\treturn nfs_stat_to_errno(status);\n}\n\n \nstatic int decode_info(struct xdr_stream *xdr, struct nfs2_fsstat *result)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, NFS_info_sz << 2);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tresult->tsize  = be32_to_cpup(p++);\n\tresult->bsize  = be32_to_cpup(p++);\n\tresult->blocks = be32_to_cpup(p++);\n\tresult->bfree  = be32_to_cpup(p++);\n\tresult->bavail = be32_to_cpup(p);\n\treturn 0;\n}\n\nstatic int nfs2_xdr_dec_statfsres(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\t  void *result)\n{\n\tenum nfs_stat status;\n\tint error;\n\n\terror = decode_stat(xdr, &status);\n\tif (unlikely(error))\n\t\tgoto out;\n\tif (status != NFS_OK)\n\t\tgoto out_default;\n\terror = decode_info(xdr, result);\nout:\n\treturn error;\nout_default:\n\treturn nfs_stat_to_errno(status);\n}\n\n\n \nstatic const struct {\n\tint stat;\n\tint errno;\n} nfs_errtbl[] = {\n\t{ NFS_OK,\t\t0\t\t},\n\t{ NFSERR_PERM,\t\t-EPERM\t\t},\n\t{ NFSERR_NOENT,\t\t-ENOENT\t\t},\n\t{ NFSERR_IO,\t\t-errno_NFSERR_IO},\n\t{ NFSERR_NXIO,\t\t-ENXIO\t\t},\n \n\t{ NFSERR_ACCES,\t\t-EACCES\t\t},\n\t{ NFSERR_EXIST,\t\t-EEXIST\t\t},\n\t{ NFSERR_XDEV,\t\t-EXDEV\t\t},\n\t{ NFSERR_NODEV,\t\t-ENODEV\t\t},\n\t{ NFSERR_NOTDIR,\t-ENOTDIR\t},\n\t{ NFSERR_ISDIR,\t\t-EISDIR\t\t},\n\t{ NFSERR_INVAL,\t\t-EINVAL\t\t},\n\t{ NFSERR_FBIG,\t\t-EFBIG\t\t},\n\t{ NFSERR_NOSPC,\t\t-ENOSPC\t\t},\n\t{ NFSERR_ROFS,\t\t-EROFS\t\t},\n\t{ NFSERR_MLINK,\t\t-EMLINK\t\t},\n\t{ NFSERR_NAMETOOLONG,\t-ENAMETOOLONG\t},\n\t{ NFSERR_NOTEMPTY,\t-ENOTEMPTY\t},\n\t{ NFSERR_DQUOT,\t\t-EDQUOT\t\t},\n\t{ NFSERR_STALE,\t\t-ESTALE\t\t},\n\t{ NFSERR_REMOTE,\t-EREMOTE\t},\n#ifdef EWFLUSH\n\t{ NFSERR_WFLUSH,\t-EWFLUSH\t},\n#endif\n\t{ NFSERR_BADHANDLE,\t-EBADHANDLE\t},\n\t{ NFSERR_NOT_SYNC,\t-ENOTSYNC\t},\n\t{ NFSERR_BAD_COOKIE,\t-EBADCOOKIE\t},\n\t{ NFSERR_NOTSUPP,\t-ENOTSUPP\t},\n\t{ NFSERR_TOOSMALL,\t-ETOOSMALL\t},\n\t{ NFSERR_SERVERFAULT,\t-EREMOTEIO\t},\n\t{ NFSERR_BADTYPE,\t-EBADTYPE\t},\n\t{ NFSERR_JUKEBOX,\t-EJUKEBOX\t},\n\t{ -1,\t\t\t-EIO\t\t}\n};\n\n \nstatic int nfs_stat_to_errno(enum nfs_stat status)\n{\n\tint i;\n\n\tfor (i = 0; nfs_errtbl[i].stat != -1; i++) {\n\t\tif (nfs_errtbl[i].stat == (int)status)\n\t\t\treturn nfs_errtbl[i].errno;\n\t}\n\tdprintk(\"NFS: Unrecognized nfs status value: %u\\n\", status);\n\treturn nfs_errtbl[i].errno;\n}\n\n#define PROC(proc, argtype, restype, timer)\t\t\t\t\\\n[NFSPROC_##proc] = {\t\t\t\t\t\t\t\\\n\t.p_proc\t    =  NFSPROC_##proc,\t\t\t\t\t\\\n\t.p_encode   =  nfs2_xdr_enc_##argtype,\t\t\t\t\\\n\t.p_decode   =  nfs2_xdr_dec_##restype,\t\t\t\t\\\n\t.p_arglen   =  NFS_##argtype##_sz,\t\t\t\t\\\n\t.p_replen   =  NFS_##restype##_sz,\t\t\t\t\\\n\t.p_timer    =  timer,\t\t\t\t\t\t\\\n\t.p_statidx  =  NFSPROC_##proc,\t\t\t\t\t\\\n\t.p_name     =  #proc,\t\t\t\t\t\t\\\n\t}\nconst struct rpc_procinfo nfs_procedures[] = {\n\tPROC(GETATTR,\tfhandle,\tattrstat,\t1),\n\tPROC(SETATTR,\tsattrargs,\tattrstat,\t0),\n\tPROC(LOOKUP,\tdiropargs,\tdiropres,\t2),\n\tPROC(READLINK,\treadlinkargs,\treadlinkres,\t3),\n\tPROC(READ,\treadargs,\treadres,\t3),\n\tPROC(WRITE,\twriteargs,\twriteres,\t4),\n\tPROC(CREATE,\tcreateargs,\tdiropres,\t0),\n\tPROC(REMOVE,\tremoveargs,\tstat,\t\t0),\n\tPROC(RENAME,\trenameargs,\tstat,\t\t0),\n\tPROC(LINK,\tlinkargs,\tstat,\t\t0),\n\tPROC(SYMLINK,\tsymlinkargs,\tstat,\t\t0),\n\tPROC(MKDIR,\tcreateargs,\tdiropres,\t0),\n\tPROC(RMDIR,\tdiropargs,\tstat,\t\t0),\n\tPROC(READDIR,\treaddirargs,\treaddirres,\t3),\n\tPROC(STATFS,\tfhandle,\tstatfsres,\t0),\n};\n\nstatic unsigned int nfs_version2_counts[ARRAY_SIZE(nfs_procedures)];\nconst struct rpc_version nfs_version2 = {\n\t.number\t\t\t= 2,\n\t.nrprocs\t\t= ARRAY_SIZE(nfs_procedures),\n\t.procs\t\t\t= nfs_procedures,\n\t.counts\t\t\t= nfs_version2_counts,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}