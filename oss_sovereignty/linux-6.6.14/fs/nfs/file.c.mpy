{
  "module_name": "file.c",
  "hash_id": "0ee4cee96385089d22cd888b9302a079dea858dd4dd3d146d4213d2158e4300f",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfs/file.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_mount.h>\n#include <linux/mm.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/swap.h>\n\n#include <linux/uaccess.h>\n#include <linux/filelock.h>\n\n#include \"delegation.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"fscache.h\"\n#include \"pnfs.h\"\n\n#include \"nfstrace.h\"\n\n#define NFSDBG_FACILITY\t\tNFSDBG_FILE\n\nstatic const struct vm_operations_struct nfs_file_vm_ops;\n\nint nfs_check_flags(int flags)\n{\n\tif ((flags & (O_APPEND | O_DIRECT)) == (O_APPEND | O_DIRECT))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nfs_check_flags);\n\n \nstatic int\nnfs_file_open(struct inode *inode, struct file *filp)\n{\n\tint res;\n\n\tdprintk(\"NFS: open file(%pD2)\\n\", filp);\n\n\tnfs_inc_stats(inode, NFSIOS_VFSOPEN);\n\tres = nfs_check_flags(filp->f_flags);\n\tif (res)\n\t\treturn res;\n\n\tres = nfs_open(inode, filp);\n\tif (res == 0)\n\t\tfilp->f_mode |= FMODE_CAN_ODIRECT;\n\treturn res;\n}\n\nint\nnfs_file_release(struct inode *inode, struct file *filp)\n{\n\tdprintk(\"NFS: release(%pD2)\\n\", filp);\n\n\tnfs_inc_stats(inode, NFSIOS_VFSRELEASE);\n\tnfs_file_clear_open_context(filp);\n\tnfs_fscache_release_file(inode, filp);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nfs_file_release);\n\n \nstatic int nfs_revalidate_file_size(struct inode *inode, struct file *filp)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\n\tif (filp->f_flags & O_DIRECT)\n\t\tgoto force_reval;\n\tif (nfs_check_cache_invalid(inode, NFS_INO_INVALID_SIZE))\n\t\tgoto force_reval;\n\treturn 0;\nforce_reval:\n\treturn __nfs_revalidate_inode(server, inode);\n}\n\nloff_t nfs_file_llseek(struct file *filp, loff_t offset, int whence)\n{\n\tdprintk(\"NFS: llseek file(%pD2, %lld, %d)\\n\",\n\t\t\tfilp, offset, whence);\n\n\t \n\tif (whence != SEEK_SET && whence != SEEK_CUR) {\n\t\tstruct inode *inode = filp->f_mapping->host;\n\n\t\tint retval = nfs_revalidate_file_size(inode, filp);\n\t\tif (retval < 0)\n\t\t\treturn (loff_t)retval;\n\t}\n\n\treturn generic_file_llseek(filp, offset, whence);\n}\nEXPORT_SYMBOL_GPL(nfs_file_llseek);\n\n \nstatic int\nnfs_file_flush(struct file *file, fl_owner_t id)\n{\n\tstruct inode\t*inode = file_inode(file);\n\terrseq_t since;\n\n\tdprintk(\"NFS: flush(%pD2)\\n\", file);\n\n\tnfs_inc_stats(inode, NFSIOS_VFSFLUSH);\n\tif ((file->f_mode & FMODE_WRITE) == 0)\n\t\treturn 0;\n\n\t \n\tsince = filemap_sample_wb_err(file->f_mapping);\n\tnfs_wb_all(inode);\n\treturn filemap_check_wb_err(file->f_mapping, since);\n}\n\nssize_t\nnfs_file_read(struct kiocb *iocb, struct iov_iter *to)\n{\n\tstruct inode *inode = file_inode(iocb->ki_filp);\n\tssize_t result;\n\n\tif (iocb->ki_flags & IOCB_DIRECT)\n\t\treturn nfs_file_direct_read(iocb, to, false);\n\n\tdprintk(\"NFS: read(%pD2, %zu@%lu)\\n\",\n\t\tiocb->ki_filp,\n\t\tiov_iter_count(to), (unsigned long) iocb->ki_pos);\n\n\tnfs_start_io_read(inode);\n\tresult = nfs_revalidate_mapping(inode, iocb->ki_filp->f_mapping);\n\tif (!result) {\n\t\tresult = generic_file_read_iter(iocb, to);\n\t\tif (result > 0)\n\t\t\tnfs_add_stats(inode, NFSIOS_NORMALREADBYTES, result);\n\t}\n\tnfs_end_io_read(inode);\n\treturn result;\n}\nEXPORT_SYMBOL_GPL(nfs_file_read);\n\nssize_t\nnfs_file_splice_read(struct file *in, loff_t *ppos, struct pipe_inode_info *pipe,\n\t\t     size_t len, unsigned int flags)\n{\n\tstruct inode *inode = file_inode(in);\n\tssize_t result;\n\n\tdprintk(\"NFS: splice_read(%pD2, %zu@%llu)\\n\", in, len, *ppos);\n\n\tnfs_start_io_read(inode);\n\tresult = nfs_revalidate_mapping(inode, in->f_mapping);\n\tif (!result) {\n\t\tresult = filemap_splice_read(in, ppos, pipe, len, flags);\n\t\tif (result > 0)\n\t\t\tnfs_add_stats(inode, NFSIOS_NORMALREADBYTES, result);\n\t}\n\tnfs_end_io_read(inode);\n\treturn result;\n}\nEXPORT_SYMBOL_GPL(nfs_file_splice_read);\n\nint\nnfs_file_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct inode *inode = file_inode(file);\n\tint\tstatus;\n\n\tdprintk(\"NFS: mmap(%pD2)\\n\", file);\n\n\t \n\tstatus = generic_file_mmap(file, vma);\n\tif (!status) {\n\t\tvma->vm_ops = &nfs_file_vm_ops;\n\t\tstatus = nfs_revalidate_mapping(inode, file->f_mapping);\n\t}\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(nfs_file_mmap);\n\n \nstatic int\nnfs_file_fsync_commit(struct file *file, int datasync)\n{\n\tstruct inode *inode = file_inode(file);\n\tint ret, ret2;\n\n\tdprintk(\"NFS: fsync file(%pD2) datasync %d\\n\", file, datasync);\n\n\tnfs_inc_stats(inode, NFSIOS_VFSFSYNC);\n\tret = nfs_commit_inode(inode, FLUSH_SYNC);\n\tret2 = file_check_and_advance_wb_err(file);\n\tif (ret2 < 0)\n\t\treturn ret2;\n\treturn ret;\n}\n\nint\nnfs_file_fsync(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tlong save_nredirtied = atomic_long_read(&nfsi->redirtied_pages);\n\tlong nredirtied;\n\tint ret;\n\n\ttrace_nfs_fsync_enter(inode);\n\n\tfor (;;) {\n\t\tret = file_write_and_wait_range(file, start, end);\n\t\tif (ret != 0)\n\t\t\tbreak;\n\t\tret = nfs_file_fsync_commit(file, datasync);\n\t\tif (ret != 0)\n\t\t\tbreak;\n\t\tret = pnfs_sync_inode(inode, !!datasync);\n\t\tif (ret != 0)\n\t\t\tbreak;\n\t\tnredirtied = atomic_long_read(&nfsi->redirtied_pages);\n\t\tif (nredirtied == save_nredirtied)\n\t\t\tbreak;\n\t\tsave_nredirtied = nredirtied;\n\t}\n\n\ttrace_nfs_fsync_exit(inode, ret);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(nfs_file_fsync);\n\n \nstatic bool nfs_folio_is_full_write(struct folio *folio, loff_t pos,\n\t\t\t\t    unsigned int len)\n{\n\tunsigned int pglen = nfs_folio_length(folio);\n\tunsigned int offset = offset_in_folio(folio, pos);\n\tunsigned int end = offset + len;\n\n\treturn !pglen || (end >= pglen && !offset);\n}\n\nstatic bool nfs_want_read_modify_write(struct file *file, struct folio *folio,\n\t\t\t\t       loff_t pos, unsigned int len)\n{\n\t \n\tif (folio_test_uptodate(folio) || folio_test_private(folio) ||\n\t    nfs_folio_is_full_write(folio, pos, len))\n\t\treturn false;\n\n\tif (pnfs_ld_read_whole_page(file_inode(file)))\n\t\treturn true;\n\t \n\tif (file->f_mode & FMODE_READ)\n\t\treturn true;\n\treturn false;\n}\n\n \nstatic int nfs_write_begin(struct file *file, struct address_space *mapping,\n\t\t\t   loff_t pos, unsigned len, struct page **pagep,\n\t\t\t   void **fsdata)\n{\n\tstruct folio *folio;\n\tint once_thru = 0;\n\tint ret;\n\n\tdfprintk(PAGECACHE, \"NFS: write_begin(%pD2(%lu), %u@%lld)\\n\",\n\t\tfile, mapping->host->i_ino, len, (long long) pos);\n\nstart:\n\tfolio = __filemap_get_folio(mapping, pos >> PAGE_SHIFT, FGP_WRITEBEGIN,\n\t\t\t\t    mapping_gfp_mask(mapping));\n\tif (IS_ERR(folio))\n\t\treturn PTR_ERR(folio);\n\t*pagep = &folio->page;\n\n\tret = nfs_flush_incompatible(file, folio);\n\tif (ret) {\n\t\tfolio_unlock(folio);\n\t\tfolio_put(folio);\n\t} else if (!once_thru &&\n\t\t   nfs_want_read_modify_write(file, folio, pos, len)) {\n\t\tonce_thru = 1;\n\t\tret = nfs_read_folio(file, folio);\n\t\tfolio_put(folio);\n\t\tif (!ret)\n\t\t\tgoto start;\n\t}\n\treturn ret;\n}\n\nstatic int nfs_write_end(struct file *file, struct address_space *mapping,\n\t\t\t loff_t pos, unsigned len, unsigned copied,\n\t\t\t struct page *page, void *fsdata)\n{\n\tstruct nfs_open_context *ctx = nfs_file_open_context(file);\n\tstruct folio *folio = page_folio(page);\n\tunsigned offset = offset_in_folio(folio, pos);\n\tint status;\n\n\tdfprintk(PAGECACHE, \"NFS: write_end(%pD2(%lu), %u@%lld)\\n\",\n\t\tfile, mapping->host->i_ino, len, (long long) pos);\n\n\t \n\tif (!folio_test_uptodate(folio)) {\n\t\tsize_t fsize = folio_size(folio);\n\t\tunsigned pglen = nfs_folio_length(folio);\n\t\tunsigned end = offset + copied;\n\n\t\tif (pglen == 0) {\n\t\t\tfolio_zero_segments(folio, 0, offset, end, fsize);\n\t\t\tfolio_mark_uptodate(folio);\n\t\t} else if (end >= pglen) {\n\t\t\tfolio_zero_segment(folio, end, fsize);\n\t\t\tif (offset == 0)\n\t\t\t\tfolio_mark_uptodate(folio);\n\t\t} else\n\t\t\tfolio_zero_segment(folio, pglen, fsize);\n\t}\n\n\tstatus = nfs_update_folio(file, folio, offset, copied);\n\n\tfolio_unlock(folio);\n\tfolio_put(folio);\n\n\tif (status < 0)\n\t\treturn status;\n\tNFS_I(mapping->host)->write_io += copied;\n\n\tif (nfs_ctx_key_to_expire(ctx, mapping->host))\n\t\tnfs_wb_all(mapping->host);\n\n\treturn copied;\n}\n\n \nstatic void nfs_invalidate_folio(struct folio *folio, size_t offset,\n\t\t\t\tsize_t length)\n{\n\tstruct inode *inode = folio_file_mapping(folio)->host;\n\tdfprintk(PAGECACHE, \"NFS: invalidate_folio(%lu, %zu, %zu)\\n\",\n\t\t folio->index, offset, length);\n\n\tif (offset != 0 || length < folio_size(folio))\n\t\treturn;\n\t \n\tnfs_wb_folio_cancel(inode, folio);\n\tfolio_wait_fscache(folio);\n\ttrace_nfs_invalidate_folio(inode, folio);\n}\n\n \nstatic bool nfs_release_folio(struct folio *folio, gfp_t gfp)\n{\n\tdfprintk(PAGECACHE, \"NFS: release_folio(%p)\\n\", folio);\n\n\t \n\tif (folio_test_private(folio)) {\n\t\tif ((current_gfp_context(gfp) & GFP_KERNEL) != GFP_KERNEL ||\n\t\t    current_is_kswapd())\n\t\t\treturn false;\n\t\tif (nfs_wb_folio(folio_file_mapping(folio)->host, folio) < 0)\n\t\t\treturn false;\n\t}\n\treturn nfs_fscache_release_folio(folio, gfp);\n}\n\nstatic void nfs_check_dirty_writeback(struct folio *folio,\n\t\t\t\tbool *dirty, bool *writeback)\n{\n\tstruct nfs_inode *nfsi;\n\tstruct address_space *mapping = folio->mapping;\n\n\t \n\tnfsi = NFS_I(mapping->host);\n\tif (atomic_read(&nfsi->commit_info.rpcs_out)) {\n\t\t*writeback = true;\n\t\treturn;\n\t}\n\n\t \n\tif (folio_test_private(folio))\n\t\t*dirty = true;\n}\n\n \nstatic int nfs_launder_folio(struct folio *folio)\n{\n\tstruct inode *inode = folio->mapping->host;\n\tint ret;\n\n\tdfprintk(PAGECACHE, \"NFS: launder_folio(%ld, %llu)\\n\",\n\t\tinode->i_ino, folio_pos(folio));\n\n\tfolio_wait_fscache(folio);\n\tret = nfs_wb_folio(inode, folio);\n\ttrace_nfs_launder_folio_done(inode, folio, ret);\n\treturn ret;\n}\n\nstatic int nfs_swap_activate(struct swap_info_struct *sis, struct file *file,\n\t\t\t\t\t\tsector_t *span)\n{\n\tunsigned long blocks;\n\tlong long isize;\n\tint ret;\n\tstruct inode *inode = file_inode(file);\n\tstruct rpc_clnt *clnt = NFS_CLIENT(inode);\n\tstruct nfs_client *cl = NFS_SERVER(inode)->nfs_client;\n\n\tspin_lock(&inode->i_lock);\n\tblocks = inode->i_blocks;\n\tisize = inode->i_size;\n\tspin_unlock(&inode->i_lock);\n\tif (blocks*512 < isize) {\n\t\tpr_warn(\"swap activate: swapfile has holes\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = rpc_clnt_swap_activate(clnt);\n\tif (ret)\n\t\treturn ret;\n\tret = add_swap_extent(sis, 0, sis->max, 0);\n\tif (ret < 0) {\n\t\trpc_clnt_swap_deactivate(clnt);\n\t\treturn ret;\n\t}\n\n\t*span = sis->pages;\n\n\tif (cl->rpc_ops->enable_swap)\n\t\tcl->rpc_ops->enable_swap(inode);\n\n\tsis->flags |= SWP_FS_OPS;\n\treturn ret;\n}\n\nstatic void nfs_swap_deactivate(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct rpc_clnt *clnt = NFS_CLIENT(inode);\n\tstruct nfs_client *cl = NFS_SERVER(inode)->nfs_client;\n\n\trpc_clnt_swap_deactivate(clnt);\n\tif (cl->rpc_ops->disable_swap)\n\t\tcl->rpc_ops->disable_swap(file_inode(file));\n}\n\nconst struct address_space_operations nfs_file_aops = {\n\t.read_folio = nfs_read_folio,\n\t.readahead = nfs_readahead,\n\t.dirty_folio = filemap_dirty_folio,\n\t.writepage = nfs_writepage,\n\t.writepages = nfs_writepages,\n\t.write_begin = nfs_write_begin,\n\t.write_end = nfs_write_end,\n\t.invalidate_folio = nfs_invalidate_folio,\n\t.release_folio = nfs_release_folio,\n\t.migrate_folio = nfs_migrate_folio,\n\t.launder_folio = nfs_launder_folio,\n\t.is_dirty_writeback = nfs_check_dirty_writeback,\n\t.error_remove_page = generic_error_remove_page,\n\t.swap_activate = nfs_swap_activate,\n\t.swap_deactivate = nfs_swap_deactivate,\n\t.swap_rw = nfs_swap_rw,\n};\n\n \nstatic vm_fault_t nfs_vm_page_mkwrite(struct vm_fault *vmf)\n{\n\tstruct file *filp = vmf->vma->vm_file;\n\tstruct inode *inode = file_inode(filp);\n\tunsigned pagelen;\n\tvm_fault_t ret = VM_FAULT_NOPAGE;\n\tstruct address_space *mapping;\n\tstruct folio *folio = page_folio(vmf->page);\n\n\tdfprintk(PAGECACHE, \"NFS: vm_page_mkwrite(%pD2(%lu), offset %lld)\\n\",\n\t\t filp, filp->f_mapping->host->i_ino,\n\t\t (long long)folio_file_pos(folio));\n\n\tsb_start_pagefault(inode->i_sb);\n\n\t \n\tif (folio_test_fscache(folio) &&\n\t    folio_wait_fscache_killable(folio) < 0) {\n\t\tret = VM_FAULT_RETRY;\n\t\tgoto out;\n\t}\n\n\twait_on_bit_action(&NFS_I(inode)->flags, NFS_INO_INVALIDATING,\n\t\t\t   nfs_wait_bit_killable,\n\t\t\t   TASK_KILLABLE|TASK_FREEZABLE_UNSAFE);\n\n\tfolio_lock(folio);\n\tmapping = folio_file_mapping(folio);\n\tif (mapping != inode->i_mapping)\n\t\tgoto out_unlock;\n\n\tfolio_wait_writeback(folio);\n\n\tpagelen = nfs_folio_length(folio);\n\tif (pagelen == 0)\n\t\tgoto out_unlock;\n\n\tret = VM_FAULT_LOCKED;\n\tif (nfs_flush_incompatible(filp, folio) == 0 &&\n\t    nfs_update_folio(filp, folio, 0, pagelen) == 0)\n\t\tgoto out;\n\n\tret = VM_FAULT_SIGBUS;\nout_unlock:\n\tfolio_unlock(folio);\nout:\n\tsb_end_pagefault(inode->i_sb);\n\treturn ret;\n}\n\nstatic const struct vm_operations_struct nfs_file_vm_ops = {\n\t.fault = filemap_fault,\n\t.map_pages = filemap_map_pages,\n\t.page_mkwrite = nfs_vm_page_mkwrite,\n};\n\nssize_t nfs_file_write(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file_inode(file);\n\tunsigned int mntflags = NFS_SERVER(inode)->flags;\n\tssize_t result, written;\n\terrseq_t since;\n\tint error;\n\n\tresult = nfs_key_timeout_notify(file, inode);\n\tif (result)\n\t\treturn result;\n\n\tif (iocb->ki_flags & IOCB_DIRECT)\n\t\treturn nfs_file_direct_write(iocb, from, false);\n\n\tdprintk(\"NFS: write(%pD2, %zu@%Ld)\\n\",\n\t\tfile, iov_iter_count(from), (long long) iocb->ki_pos);\n\n\tif (IS_SWAPFILE(inode))\n\t\tgoto out_swapfile;\n\t \n\tif (iocb->ki_flags & IOCB_APPEND || iocb->ki_pos > i_size_read(inode)) {\n\t\tresult = nfs_revalidate_file_size(inode, file);\n\t\tif (result)\n\t\t\treturn result;\n\t}\n\n\tnfs_clear_invalid_mapping(file->f_mapping);\n\n\tsince = filemap_sample_wb_err(file->f_mapping);\n\tnfs_start_io_write(inode);\n\tresult = generic_write_checks(iocb, from);\n\tif (result > 0)\n\t\tresult = generic_perform_write(iocb, from);\n\tnfs_end_io_write(inode);\n\tif (result <= 0)\n\t\tgoto out;\n\n\twritten = result;\n\tnfs_add_stats(inode, NFSIOS_NORMALWRITTENBYTES, written);\n\n\tif (mntflags & NFS_MOUNT_WRITE_EAGER) {\n\t\tresult = filemap_fdatawrite_range(file->f_mapping,\n\t\t\t\t\t\t  iocb->ki_pos - written,\n\t\t\t\t\t\t  iocb->ki_pos - 1);\n\t\tif (result < 0)\n\t\t\tgoto out;\n\t}\n\tif (mntflags & NFS_MOUNT_WRITE_WAIT) {\n\t\tfilemap_fdatawait_range(file->f_mapping,\n\t\t\t\t\tiocb->ki_pos - written,\n\t\t\t\t\tiocb->ki_pos - 1);\n\t}\n\tresult = generic_write_sync(iocb, written);\n\tif (result < 0)\n\t\treturn result;\n\nout:\n\t \n\terror = filemap_check_wb_err(file->f_mapping, since);\n\tswitch (error) {\n\tdefault:\n\t\tbreak;\n\tcase -EDQUOT:\n\tcase -EFBIG:\n\tcase -ENOSPC:\n\t\tnfs_wb_all(inode);\n\t\terror = file_check_and_advance_wb_err(file);\n\t\tif (error < 0)\n\t\t\tresult = error;\n\t}\n\treturn result;\n\nout_swapfile:\n\tprintk(KERN_INFO \"NFS: attempt to write to active swap file!\\n\");\n\treturn -ETXTBSY;\n}\nEXPORT_SYMBOL_GPL(nfs_file_write);\n\nstatic int\ndo_getlk(struct file *filp, int cmd, struct file_lock *fl, int is_local)\n{\n\tstruct inode *inode = filp->f_mapping->host;\n\tint status = 0;\n\tunsigned int saved_type = fl->fl_type;\n\n\t \n\tposix_test_lock(filp, fl);\n\tif (fl->fl_type != F_UNLCK) {\n\t\t \n\t\tgoto out;\n\t}\n\tfl->fl_type = saved_type;\n\n\tif (NFS_PROTO(inode)->have_delegation(inode, FMODE_READ))\n\t\tgoto out_noconflict;\n\n\tif (is_local)\n\t\tgoto out_noconflict;\n\n\tstatus = NFS_PROTO(inode)->lock(filp, cmd, fl);\nout:\n\treturn status;\nout_noconflict:\n\tfl->fl_type = F_UNLCK;\n\tgoto out;\n}\n\nstatic int\ndo_unlk(struct file *filp, int cmd, struct file_lock *fl, int is_local)\n{\n\tstruct inode *inode = filp->f_mapping->host;\n\tstruct nfs_lock_context *l_ctx;\n\tint status;\n\n\t \n\tnfs_wb_all(inode);\n\n\tl_ctx = nfs_get_lock_context(nfs_file_open_context(filp));\n\tif (!IS_ERR(l_ctx)) {\n\t\tstatus = nfs_iocounter_wait(l_ctx);\n\t\tnfs_put_lock_context(l_ctx);\n\t\t \n\t\tif (status < 0 && !(fl->fl_flags & FL_CLOSE))\n\t\t\treturn status;\n\t}\n\n\t \n\tif (!is_local)\n\t\tstatus = NFS_PROTO(inode)->lock(filp, cmd, fl);\n\telse\n\t\tstatus = locks_lock_file_wait(filp, fl);\n\treturn status;\n}\n\nstatic int\ndo_setlk(struct file *filp, int cmd, struct file_lock *fl, int is_local)\n{\n\tstruct inode *inode = filp->f_mapping->host;\n\tint status;\n\n\t \n\tstatus = nfs_sync_mapping(filp->f_mapping);\n\tif (status != 0)\n\t\tgoto out;\n\n\t \n\tif (!is_local)\n\t\tstatus = NFS_PROTO(inode)->lock(filp, cmd, fl);\n\telse\n\t\tstatus = locks_lock_file_wait(filp, fl);\n\tif (status < 0)\n\t\tgoto out;\n\n\t \n\tnfs_sync_mapping(filp->f_mapping);\n\tif (!NFS_PROTO(inode)->have_delegation(inode, FMODE_READ)) {\n\t\tnfs_zap_caches(inode);\n\t\tif (mapping_mapped(filp->f_mapping))\n\t\t\tnfs_revalidate_mapping(inode, filp->f_mapping);\n\t}\nout:\n\treturn status;\n}\n\n \nint nfs_lock(struct file *filp, int cmd, struct file_lock *fl)\n{\n\tstruct inode *inode = filp->f_mapping->host;\n\tint ret = -ENOLCK;\n\tint is_local = 0;\n\n\tdprintk(\"NFS: lock(%pD2, t=%x, fl=%x, r=%lld:%lld)\\n\",\n\t\t\tfilp, fl->fl_type, fl->fl_flags,\n\t\t\t(long long)fl->fl_start, (long long)fl->fl_end);\n\n\tnfs_inc_stats(inode, NFSIOS_VFSLOCK);\n\n\tif (fl->fl_flags & FL_RECLAIM)\n\t\treturn -ENOGRACE;\n\n\tif (NFS_SERVER(inode)->flags & NFS_MOUNT_LOCAL_FCNTL)\n\t\tis_local = 1;\n\n\tif (NFS_PROTO(inode)->lock_check_bounds != NULL) {\n\t\tret = NFS_PROTO(inode)->lock_check_bounds(fl);\n\t\tif (ret < 0)\n\t\t\tgoto out_err;\n\t}\n\n\tif (IS_GETLK(cmd))\n\t\tret = do_getlk(filp, cmd, fl, is_local);\n\telse if (fl->fl_type == F_UNLCK)\n\t\tret = do_unlk(filp, cmd, fl, is_local);\n\telse\n\t\tret = do_setlk(filp, cmd, fl, is_local);\nout_err:\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(nfs_lock);\n\n \nint nfs_flock(struct file *filp, int cmd, struct file_lock *fl)\n{\n\tstruct inode *inode = filp->f_mapping->host;\n\tint is_local = 0;\n\n\tdprintk(\"NFS: flock(%pD2, t=%x, fl=%x)\\n\",\n\t\t\tfilp, fl->fl_type, fl->fl_flags);\n\n\tif (!(fl->fl_flags & FL_FLOCK))\n\t\treturn -ENOLCK;\n\n\tif (NFS_SERVER(inode)->flags & NFS_MOUNT_LOCAL_FLOCK)\n\t\tis_local = 1;\n\n\t \n\tif (fl->fl_type == F_UNLCK)\n\t\treturn do_unlk(filp, cmd, fl, is_local);\n\treturn do_setlk(filp, cmd, fl, is_local);\n}\nEXPORT_SYMBOL_GPL(nfs_flock);\n\nconst struct file_operations nfs_file_operations = {\n\t.llseek\t\t= nfs_file_llseek,\n\t.read_iter\t= nfs_file_read,\n\t.write_iter\t= nfs_file_write,\n\t.mmap\t\t= nfs_file_mmap,\n\t.open\t\t= nfs_file_open,\n\t.flush\t\t= nfs_file_flush,\n\t.release\t= nfs_file_release,\n\t.fsync\t\t= nfs_file_fsync,\n\t.lock\t\t= nfs_lock,\n\t.flock\t\t= nfs_flock,\n\t.splice_read\t= nfs_file_splice_read,\n\t.splice_write\t= iter_file_splice_write,\n\t.check_flags\t= nfs_check_flags,\n\t.setlease\t= simple_nosetlease,\n};\nEXPORT_SYMBOL_GPL(nfs_file_operations);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}