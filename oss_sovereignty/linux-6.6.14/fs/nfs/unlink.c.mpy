{
  "module_name": "unlink.c",
  "hash_id": "4b77a41ea3488df2e9abc9403b8b3de90b56758af582549f3fec228b4bea8649",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfs/unlink.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/dcache.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/nfs_fs.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/namei.h>\n#include <linux/fsnotify.h>\n\n#include \"internal.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n\n#include \"nfstrace.h\"\n\n \nstatic void\nnfs_free_unlinkdata(struct nfs_unlinkdata *data)\n{\n\tput_cred(data->cred);\n\tkfree(data->args.name.name);\n\tkfree(data);\n}\n\n \nstatic void nfs_async_unlink_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs_unlinkdata *data = calldata;\n\tstruct inode *dir = d_inode(data->dentry->d_parent);\n\n\ttrace_nfs_sillyrename_unlink(data, task->tk_status);\n\tif (!NFS_PROTO(dir)->unlink_done(task, dir))\n\t\trpc_restart_call_prepare(task);\n}\n\n \nstatic void nfs_async_unlink_release(void *calldata)\n{\n\tstruct nfs_unlinkdata\t*data = calldata;\n\tstruct dentry *dentry = data->dentry;\n\tstruct super_block *sb = dentry->d_sb;\n\n\tup_read_non_owner(&NFS_I(d_inode(dentry->d_parent))->rmdir_sem);\n\td_lookup_done(dentry);\n\tnfs_free_unlinkdata(data);\n\tdput(dentry);\n\tnfs_sb_deactive(sb);\n}\n\nstatic void nfs_unlink_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs_unlinkdata *data = calldata;\n\tstruct inode *dir = d_inode(data->dentry->d_parent);\n\tNFS_PROTO(dir)->unlink_rpc_prepare(task, data);\n}\n\nstatic const struct rpc_call_ops nfs_unlink_ops = {\n\t.rpc_call_done = nfs_async_unlink_done,\n\t.rpc_release = nfs_async_unlink_release,\n\t.rpc_call_prepare = nfs_unlink_prepare,\n};\n\nstatic void nfs_do_call_unlink(struct inode *inode, struct nfs_unlinkdata *data)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_argp = &data->args,\n\t\t.rpc_resp = &data->res,\n\t\t.rpc_cred = data->cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs_unlink_ops,\n\t\t.callback_data = data,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC | RPC_TASK_CRED_NOREF,\n\t};\n\tstruct rpc_task *task;\n\tstruct inode *dir = d_inode(data->dentry->d_parent);\n\n\tif (nfs_server_capable(inode, NFS_CAP_MOVEABLE))\n\t\ttask_setup_data.flags |= RPC_TASK_MOVEABLE;\n\n\tnfs_sb_active(dir->i_sb);\n\tdata->args.fh = NFS_FH(dir);\n\tnfs_fattr_init(data->res.dir_attr);\n\n\tNFS_PROTO(dir)->unlink_setup(&msg, data->dentry, inode);\n\n\ttask_setup_data.rpc_client = NFS_CLIENT(dir);\n\ttask = rpc_run_task(&task_setup_data);\n\tif (!IS_ERR(task))\n\t\trpc_put_task_async(task);\n}\n\nstatic int nfs_call_unlink(struct dentry *dentry, struct inode *inode, struct nfs_unlinkdata *data)\n{\n\tstruct inode *dir = d_inode(dentry->d_parent);\n\tstruct dentry *alias;\n\n\tdown_read_non_owner(&NFS_I(dir)->rmdir_sem);\n\talias = d_alloc_parallel(dentry->d_parent, &data->args.name, &data->wq);\n\tif (IS_ERR(alias)) {\n\t\tup_read_non_owner(&NFS_I(dir)->rmdir_sem);\n\t\treturn 0;\n\t}\n\tif (!d_in_lookup(alias)) {\n\t\tint ret;\n\t\tvoid *devname_garbage = NULL;\n\n\t\t \n\t\tspin_lock(&alias->d_lock);\n\t\tif (d_really_is_positive(alias) &&\n\t\t    !nfs_compare_fh(NFS_FH(inode), NFS_FH(d_inode(alias))) &&\n\t\t    !(alias->d_flags & DCACHE_NFSFS_RENAMED)) {\n\t\t\tdevname_garbage = alias->d_fsdata;\n\t\t\talias->d_fsdata = data;\n\t\t\talias->d_flags |= DCACHE_NFSFS_RENAMED;\n\t\t\tret = 1;\n\t\t} else\n\t\t\tret = 0;\n\t\tspin_unlock(&alias->d_lock);\n\t\tdput(alias);\n\t\tup_read_non_owner(&NFS_I(dir)->rmdir_sem);\n\t\t \n\t\tkfree(devname_garbage);\n\t\treturn ret;\n\t}\n\tdata->dentry = alias;\n\tnfs_do_call_unlink(inode, data);\n\treturn 1;\n}\n\n \nstatic int\nnfs_async_unlink(struct dentry *dentry, const struct qstr *name)\n{\n\tstruct nfs_unlinkdata *data;\n\tint status = -ENOMEM;\n\tvoid *devname_garbage = NULL;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (data == NULL)\n\t\tgoto out;\n\tdata->args.name.name = kstrdup(name->name, GFP_KERNEL);\n\tif (!data->args.name.name)\n\t\tgoto out_free;\n\tdata->args.name.len = name->len;\n\n\tdata->cred = get_current_cred();\n\tdata->res.dir_attr = &data->dir_attr;\n\tinit_waitqueue_head(&data->wq);\n\n\tstatus = -EBUSY;\n\tspin_lock(&dentry->d_lock);\n\tif (dentry->d_flags & DCACHE_NFSFS_RENAMED)\n\t\tgoto out_unlock;\n\tdentry->d_flags |= DCACHE_NFSFS_RENAMED;\n\tdevname_garbage = dentry->d_fsdata;\n\tdentry->d_fsdata = data;\n\tspin_unlock(&dentry->d_lock);\n\t \n\tkfree(devname_garbage);\n\treturn 0;\nout_unlock:\n\tspin_unlock(&dentry->d_lock);\n\tput_cred(data->cred);\n\tkfree(data->args.name.name);\nout_free:\n\tkfree(data);\nout:\n\treturn status;\n}\n\n \nvoid\nnfs_complete_unlink(struct dentry *dentry, struct inode *inode)\n{\n\tstruct nfs_unlinkdata\t*data;\n\n\tspin_lock(&dentry->d_lock);\n\tdentry->d_flags &= ~DCACHE_NFSFS_RENAMED;\n\tdata = dentry->d_fsdata;\n\tdentry->d_fsdata = NULL;\n\tspin_unlock(&dentry->d_lock);\n\n\tif (NFS_STALE(inode) || !nfs_call_unlink(dentry, inode, data))\n\t\tnfs_free_unlinkdata(data);\n}\n\n \nstatic void\nnfs_cancel_async_unlink(struct dentry *dentry)\n{\n\tspin_lock(&dentry->d_lock);\n\tif (dentry->d_flags & DCACHE_NFSFS_RENAMED) {\n\t\tstruct nfs_unlinkdata *data = dentry->d_fsdata;\n\n\t\tdentry->d_flags &= ~DCACHE_NFSFS_RENAMED;\n\t\tdentry->d_fsdata = NULL;\n\t\tspin_unlock(&dentry->d_lock);\n\t\tnfs_free_unlinkdata(data);\n\t\treturn;\n\t}\n\tspin_unlock(&dentry->d_lock);\n}\n\n \nstatic void nfs_async_rename_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs_renamedata *data = calldata;\n\tstruct inode *old_dir = data->old_dir;\n\tstruct inode *new_dir = data->new_dir;\n\tstruct dentry *old_dentry = data->old_dentry;\n\n\ttrace_nfs_sillyrename_rename(old_dir, old_dentry,\n\t\t\tnew_dir, data->new_dentry, task->tk_status);\n\tif (!NFS_PROTO(old_dir)->rename_done(task, old_dir, new_dir)) {\n\t\trpc_restart_call_prepare(task);\n\t\treturn;\n\t}\n\n\tif (data->complete)\n\t\tdata->complete(task, data);\n}\n\n \nstatic void nfs_async_rename_release(void *calldata)\n{\n\tstruct nfs_renamedata\t*data = calldata;\n\tstruct super_block *sb = data->old_dir->i_sb;\n\n\tif (d_really_is_positive(data->old_dentry))\n\t\tnfs_mark_for_revalidate(d_inode(data->old_dentry));\n\n\t \n\tif (data->cancelled) {\n\t\tspin_lock(&data->old_dir->i_lock);\n\t\tnfs_force_lookup_revalidate(data->old_dir);\n\t\tspin_unlock(&data->old_dir->i_lock);\n\t\tif (data->new_dir != data->old_dir) {\n\t\t\tspin_lock(&data->new_dir->i_lock);\n\t\t\tnfs_force_lookup_revalidate(data->new_dir);\n\t\t\tspin_unlock(&data->new_dir->i_lock);\n\t\t}\n\t}\n\n\tdput(data->old_dentry);\n\tdput(data->new_dentry);\n\tiput(data->old_dir);\n\tiput(data->new_dir);\n\tnfs_sb_deactive(sb);\n\tput_cred(data->cred);\n\tkfree(data);\n}\n\nstatic void nfs_rename_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs_renamedata *data = calldata;\n\tNFS_PROTO(data->old_dir)->rename_rpc_prepare(task, data);\n}\n\nstatic const struct rpc_call_ops nfs_rename_ops = {\n\t.rpc_call_done = nfs_async_rename_done,\n\t.rpc_release = nfs_async_rename_release,\n\t.rpc_call_prepare = nfs_rename_prepare,\n};\n\n \nstruct rpc_task *\nnfs_async_rename(struct inode *old_dir, struct inode *new_dir,\n\t\t struct dentry *old_dentry, struct dentry *new_dentry,\n\t\t void (*complete)(struct rpc_task *, struct nfs_renamedata *))\n{\n\tstruct nfs_renamedata *data;\n\tstruct rpc_message msg = { };\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs_rename_ops,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.rpc_client = NFS_CLIENT(old_dir),\n\t\t.flags = RPC_TASK_ASYNC | RPC_TASK_CRED_NOREF,\n\t};\n\n\tif (nfs_server_capable(old_dir, NFS_CAP_MOVEABLE) &&\n\t    nfs_server_capable(new_dir, NFS_CAP_MOVEABLE))\n\t\ttask_setup_data.flags |= RPC_TASK_MOVEABLE;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (data == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\ttask_setup_data.task = &data->task;\n\ttask_setup_data.callback_data = data;\n\n\tdata->cred = get_current_cred();\n\n\tmsg.rpc_argp = &data->args;\n\tmsg.rpc_resp = &data->res;\n\tmsg.rpc_cred = data->cred;\n\n\t \n\tdata->old_dir = old_dir;\n\tihold(old_dir);\n\tdata->new_dir = new_dir;\n\tihold(new_dir);\n\tdata->old_dentry = dget(old_dentry);\n\tdata->new_dentry = dget(new_dentry);\n\tnfs_fattr_init(&data->old_fattr);\n\tnfs_fattr_init(&data->new_fattr);\n\tdata->complete = complete;\n\n\t \n\tdata->args.old_dir = NFS_FH(old_dir);\n\tdata->args.old_name = &old_dentry->d_name;\n\tdata->args.new_dir = NFS_FH(new_dir);\n\tdata->args.new_name = &new_dentry->d_name;\n\n\t \n\tdata->res.old_fattr = &data->old_fattr;\n\tdata->res.new_fattr = &data->new_fattr;\n\n\tnfs_sb_active(old_dir->i_sb);\n\n\tNFS_PROTO(data->old_dir)->rename_setup(&msg, old_dentry, new_dentry);\n\n\treturn rpc_run_task(&task_setup_data);\n}\n\n \nstatic void\nnfs_complete_sillyrename(struct rpc_task *task, struct nfs_renamedata *data)\n{\n\tstruct dentry *dentry = data->old_dentry;\n\n\tif (task->tk_status != 0) {\n\t\tnfs_cancel_async_unlink(dentry);\n\t\treturn;\n\t}\n}\n\n#define SILLYNAME_PREFIX \".nfs\"\n#define SILLYNAME_PREFIX_LEN ((unsigned)sizeof(SILLYNAME_PREFIX) - 1)\n#define SILLYNAME_FILEID_LEN ((unsigned)sizeof(u64) << 1)\n#define SILLYNAME_COUNTER_LEN ((unsigned)sizeof(unsigned int) << 1)\n#define SILLYNAME_LEN (SILLYNAME_PREFIX_LEN + \\\n\t\tSILLYNAME_FILEID_LEN + \\\n\t\tSILLYNAME_COUNTER_LEN)\n\n \nint\nnfs_sillyrename(struct inode *dir, struct dentry *dentry)\n{\n\tstatic unsigned int sillycounter;\n\tunsigned char silly[SILLYNAME_LEN + 1];\n\tunsigned long long fileid;\n\tstruct dentry *sdentry;\n\tstruct inode *inode = d_inode(dentry);\n\tstruct rpc_task *task;\n\tint            error = -EBUSY;\n\n\tdfprintk(VFS, \"NFS: silly-rename(%pd2, ct=%d)\\n\",\n\t\tdentry, d_count(dentry));\n\tnfs_inc_stats(dir, NFSIOS_SILLYRENAME);\n\n\t \n\tif (dentry->d_flags & DCACHE_NFSFS_RENAMED)\n\t\tgoto out;\n\n\tfileid = NFS_FILEID(d_inode(dentry));\n\n\tsdentry = NULL;\n\tdo {\n\t\tint slen;\n\t\tdput(sdentry);\n\t\tsillycounter++;\n\t\tslen = scnprintf(silly, sizeof(silly),\n\t\t\t\tSILLYNAME_PREFIX \"%0*llx%0*x\",\n\t\t\t\tSILLYNAME_FILEID_LEN, fileid,\n\t\t\t\tSILLYNAME_COUNTER_LEN, sillycounter);\n\n\t\tdfprintk(VFS, \"NFS: trying to rename %pd to %s\\n\",\n\t\t\t\tdentry, silly);\n\n\t\tsdentry = lookup_one_len(silly, dentry->d_parent, slen);\n\t\t \n\t\tif (IS_ERR(sdentry))\n\t\t\tgoto out;\n\t} while (d_inode(sdentry) != NULL);  \n\n\tihold(inode);\n\n\t \n\terror = nfs_async_unlink(dentry, &sdentry->d_name);\n\tif (error)\n\t\tgoto out_dput;\n\n\t \n\ttask = nfs_async_rename(dir, dir, dentry, sdentry,\n\t\t\t\t\tnfs_complete_sillyrename);\n\tif (IS_ERR(task)) {\n\t\terror = -EBUSY;\n\t\tnfs_cancel_async_unlink(dentry);\n\t\tgoto out_dput;\n\t}\n\n\t \n\terror = rpc_wait_for_completion_task(task);\n\tif (error == 0)\n\t\terror = task->tk_status;\n\tswitch (error) {\n\tcase 0:\n\t\t \n\t\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\t\tspin_lock(&inode->i_lock);\n\t\tNFS_I(inode)->attr_gencount = nfs_inc_attr_generation_counter();\n\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_CHANGE |\n\t\t\t\t\t\t     NFS_INO_INVALID_CTIME |\n\t\t\t\t\t\t     NFS_INO_REVAL_FORCED);\n\t\tspin_unlock(&inode->i_lock);\n\t\td_move(dentry, sdentry);\n\t\tbreak;\n\tcase -ERESTARTSYS:\n\t\t \n\t\td_drop(dentry);\n\t\td_drop(sdentry);\n\t}\n\trpc_put_task(task);\nout_dput:\n\tiput(inode);\n\tdput(sdentry);\nout:\n\treturn error;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}