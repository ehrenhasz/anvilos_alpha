{
  "module_name": "namespace.c",
  "hash_id": "71c419f146e0c11e5916fc70992fd4965a903e0a910e88f4405405e7568ceb1c",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfs/namespace.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/dcache.h>\n#include <linux/gfp.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_fs.h>\n#include <linux/string.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/vfs.h>\n#include <linux/sunrpc/gss_api.h>\n#include \"internal.h\"\n#include \"nfs.h\"\n\n#define NFSDBG_FACILITY\t\tNFSDBG_VFS\n\nstatic void nfs_expire_automounts(struct work_struct *work);\n\nstatic LIST_HEAD(nfs_automount_list);\nstatic DECLARE_DELAYED_WORK(nfs_automount_task, nfs_expire_automounts);\nint nfs_mountpoint_expiry_timeout = 500 * HZ;\n\n \nchar *nfs_path(char **p, struct dentry *dentry_in, char *buffer,\n\t       ssize_t buflen_in, unsigned flags)\n{\n\tchar *end;\n\tint namelen;\n\tunsigned seq;\n\tconst char *base;\n\tstruct dentry *dentry;\n\tssize_t buflen;\n\nrename_retry:\n\tbuflen = buflen_in;\n\tdentry = dentry_in;\n\tend = buffer+buflen;\n\t*--end = '\\0';\n\tbuflen--;\n\n\tseq = read_seqbegin(&rename_lock);\n\trcu_read_lock();\n\twhile (1) {\n\t\tspin_lock(&dentry->d_lock);\n\t\tif (IS_ROOT(dentry))\n\t\t\tbreak;\n\t\tnamelen = dentry->d_name.len;\n\t\tbuflen -= namelen + 1;\n\t\tif (buflen < 0)\n\t\t\tgoto Elong_unlock;\n\t\tend -= namelen;\n\t\tmemcpy(end, dentry->d_name.name, namelen);\n\t\t*--end = '/';\n\t\tspin_unlock(&dentry->d_lock);\n\t\tdentry = dentry->d_parent;\n\t}\n\tif (read_seqretry(&rename_lock, seq)) {\n\t\tspin_unlock(&dentry->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto rename_retry;\n\t}\n\tif ((flags & NFS_PATH_CANONICAL) && *end != '/') {\n\t\tif (--buflen < 0) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\trcu_read_unlock();\n\t\t\tgoto Elong;\n\t\t}\n\t\t*--end = '/';\n\t}\n\t*p = end;\n\tbase = dentry->d_fsdata;\n\tif (!base) {\n\t\tspin_unlock(&dentry->d_lock);\n\t\trcu_read_unlock();\n\t\tWARN_ON(1);\n\t\treturn end;\n\t}\n\tnamelen = strlen(base);\n\tif (*end == '/') {\n\t\t \n\t\twhile (namelen > 0 && base[namelen - 1] == '/')\n\t\t\tnamelen--;\n\t}\n\tbuflen -= namelen;\n\tif (buflen < 0) {\n\t\tspin_unlock(&dentry->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto Elong;\n\t}\n\tend -= namelen;\n\tmemcpy(end, base, namelen);\n\tspin_unlock(&dentry->d_lock);\n\trcu_read_unlock();\n\treturn end;\nElong_unlock:\n\tspin_unlock(&dentry->d_lock);\n\trcu_read_unlock();\n\tif (read_seqretry(&rename_lock, seq))\n\t\tgoto rename_retry;\nElong:\n\treturn ERR_PTR(-ENAMETOOLONG);\n}\nEXPORT_SYMBOL_GPL(nfs_path);\n\n \nstruct vfsmount *nfs_d_automount(struct path *path)\n{\n\tstruct nfs_fs_context *ctx;\n\tstruct fs_context *fc;\n\tstruct vfsmount *mnt = ERR_PTR(-ENOMEM);\n\tstruct nfs_server *server = NFS_SB(path->dentry->d_sb);\n\tstruct nfs_client *client = server->nfs_client;\n\tint timeout = READ_ONCE(nfs_mountpoint_expiry_timeout);\n\tint ret;\n\n\tif (IS_ROOT(path->dentry))\n\t\treturn ERR_PTR(-ESTALE);\n\n\t \n\tfc = fs_context_for_submount(path->mnt->mnt_sb->s_type, path->dentry);\n\tif (IS_ERR(fc))\n\t\treturn ERR_CAST(fc);\n\n\tctx = nfs_fc2context(fc);\n\tctx->clone_data.dentry\t= path->dentry;\n\tctx->clone_data.sb\t= path->dentry->d_sb;\n\tctx->clone_data.fattr\t= nfs_alloc_fattr();\n\tif (!ctx->clone_data.fattr)\n\t\tgoto out_fc;\n\n\tif (fc->net_ns != client->cl_net) {\n\t\tput_net(fc->net_ns);\n\t\tfc->net_ns = get_net(client->cl_net);\n\t}\n\n\t \n\tmemcpy(&ctx->nfs_server._address, &client->cl_addr, client->cl_addrlen);\n\tctx->nfs_server.addrlen\t= client->cl_addrlen;\n\tctx->nfs_server.port\t= server->port;\n\n\tctx->version\t\t= client->rpc_ops->version;\n\tctx->minorversion\t= client->cl_minorversion;\n\tctx->nfs_mod\t\t= client->cl_nfs_mod;\n\t__module_get(ctx->nfs_mod->owner);\n\n\tret = client->rpc_ops->submount(fc, server);\n\tif (ret < 0) {\n\t\tmnt = ERR_PTR(ret);\n\t\tgoto out_fc;\n\t}\n\n\tup_write(&fc->root->d_sb->s_umount);\n\tmnt = vfs_create_mount(fc);\n\tif (IS_ERR(mnt))\n\t\tgoto out_fc;\n\n\tmntget(mnt);  \n\tif (timeout <= 0)\n\t\tgoto out_fc;\n\n\tmnt_set_expiry(mnt, &nfs_automount_list);\n\tschedule_delayed_work(&nfs_automount_task, timeout);\n\nout_fc:\n\tput_fs_context(fc);\n\treturn mnt;\n}\n\nstatic int\nnfs_namespace_getattr(struct mnt_idmap *idmap,\n\t\t      const struct path *path, struct kstat *stat,\n\t\t      u32 request_mask, unsigned int query_flags)\n{\n\tif (NFS_FH(d_inode(path->dentry))->size != 0)\n\t\treturn nfs_getattr(idmap, path, stat, request_mask,\n\t\t\t\t   query_flags);\n\tgeneric_fillattr(&nop_mnt_idmap, request_mask, d_inode(path->dentry),\n\t\t\t stat);\n\treturn 0;\n}\n\nstatic int\nnfs_namespace_setattr(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\t      struct iattr *attr)\n{\n\tif (NFS_FH(d_inode(dentry))->size != 0)\n\t\treturn nfs_setattr(idmap, dentry, attr);\n\treturn -EACCES;\n}\n\nconst struct inode_operations nfs_mountpoint_inode_operations = {\n\t.getattr\t= nfs_getattr,\n\t.setattr\t= nfs_setattr,\n};\n\nconst struct inode_operations nfs_referral_inode_operations = {\n\t.getattr\t= nfs_namespace_getattr,\n\t.setattr\t= nfs_namespace_setattr,\n};\n\nstatic void nfs_expire_automounts(struct work_struct *work)\n{\n\tstruct list_head *list = &nfs_automount_list;\n\tint timeout = READ_ONCE(nfs_mountpoint_expiry_timeout);\n\n\tmark_mounts_for_expiry(list);\n\tif (!list_empty(list) && timeout > 0)\n\t\tschedule_delayed_work(&nfs_automount_task, timeout);\n}\n\nvoid nfs_release_automount_timer(void)\n{\n\tif (list_empty(&nfs_automount_list))\n\t\tcancel_delayed_work(&nfs_automount_task);\n}\n\n \nint nfs_do_submount(struct fs_context *fc)\n{\n\tstruct nfs_fs_context *ctx = nfs_fc2context(fc);\n\tstruct dentry *dentry = ctx->clone_data.dentry;\n\tstruct nfs_server *server;\n\tchar *buffer, *p;\n\tint ret;\n\n\t \n\tserver = ctx->nfs_mod->rpc_ops->clone_server(NFS_SB(ctx->clone_data.sb),\n\t\t\t\t\t\t     ctx->mntfh,\n\t\t\t\t\t\t     ctx->clone_data.fattr,\n\t\t\t\t\t\t     ctx->selected_flavor);\n\n\tif (IS_ERR(server))\n\t\treturn PTR_ERR(server);\n\n\tctx->server = server;\n\n\tbuffer = kmalloc(4096, GFP_USER);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tctx->internal\t\t= true;\n\tctx->clone_data.inherited_bsize = ctx->clone_data.sb->s_blocksize_bits;\n\n\tp = nfs_devname(dentry, buffer, 4096);\n\tif (IS_ERR(p)) {\n\t\tnfs_errorf(fc, \"NFS: Couldn't determine submount pathname\");\n\t\tret = PTR_ERR(p);\n\t} else {\n\t\tret = vfs_parse_fs_string(fc, \"source\", p, buffer + 4096 - p);\n\t\tif (!ret)\n\t\t\tret = vfs_get_tree(fc);\n\t}\n\tkfree(buffer);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(nfs_do_submount);\n\nint nfs_submount(struct fs_context *fc, struct nfs_server *server)\n{\n\tstruct nfs_fs_context *ctx = nfs_fc2context(fc);\n\tstruct dentry *dentry = ctx->clone_data.dentry;\n\tstruct dentry *parent = dget_parent(dentry);\n\tint err;\n\n\t \n\terr = server->nfs_client->rpc_ops->lookup(d_inode(parent), dentry,\n\t\t\t\t\t\t  ctx->mntfh, ctx->clone_data.fattr);\n\tdput(parent);\n\tif (err != 0)\n\t\treturn err;\n\n\tctx->selected_flavor = server->client->cl_auth->au_flavor;\n\treturn nfs_do_submount(fc);\n}\nEXPORT_SYMBOL_GPL(nfs_submount);\n\nstatic int param_set_nfs_timeout(const char *val, const struct kernel_param *kp)\n{\n\tlong num;\n\tint ret;\n\n\tif (!val)\n\t\treturn -EINVAL;\n\tret = kstrtol(val, 0, &num);\n\tif (ret)\n\t\treturn -EINVAL;\n\tif (num > 0) {\n\t\tif (num >= INT_MAX / HZ)\n\t\t\tnum = INT_MAX;\n\t\telse\n\t\t\tnum *= HZ;\n\t\t*((int *)kp->arg) = num;\n\t\tif (!list_empty(&nfs_automount_list))\n\t\t\tmod_delayed_work(system_wq, &nfs_automount_task, num);\n\t} else {\n\t\t*((int *)kp->arg) = -1*HZ;\n\t\tcancel_delayed_work(&nfs_automount_task);\n\t}\n\treturn 0;\n}\n\nstatic int param_get_nfs_timeout(char *buffer, const struct kernel_param *kp)\n{\n\tlong num = *((int *)kp->arg);\n\n\tif (num > 0) {\n\t\tif (num >= INT_MAX - (HZ - 1))\n\t\t\tnum = INT_MAX / HZ;\n\t\telse\n\t\t\tnum = (num + (HZ - 1)) / HZ;\n\t} else\n\t\tnum = -1;\n\treturn sysfs_emit(buffer, \"%li\\n\", num);\n}\n\nstatic const struct kernel_param_ops param_ops_nfs_timeout = {\n\t.set = param_set_nfs_timeout,\n\t.get = param_get_nfs_timeout,\n};\n#define param_check_nfs_timeout(name, p) __param_check(name, p, int)\n\nmodule_param(nfs_mountpoint_expiry_timeout, nfs_timeout, 0644);\nMODULE_PARM_DESC(nfs_mountpoint_expiry_timeout,\n\t\t\"Set the NFS automounted mountpoint timeout value (seconds).\"\n\t\t\"Values <= 0 turn expiration off.\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}