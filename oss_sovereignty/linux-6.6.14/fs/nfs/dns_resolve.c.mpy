{
  "module_name": "dns_resolve.c",
  "hash_id": "d2d8cd5927f222b35866804689973ba87b2fede740307ac0de3b1f2fe836b80e",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfs/dns_resolve.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/addr.h>\n\n#include \"dns_resolve.h\"\n\n#ifdef CONFIG_NFS_USE_KERNEL_DNS\n\n#include <linux/dns_resolver.h>\n\nssize_t nfs_dns_resolve_name(struct net *net, char *name, size_t namelen,\n\t\tstruct sockaddr_storage *ss, size_t salen)\n{\n\tstruct sockaddr *sa = (struct sockaddr *)ss;\n\tssize_t ret;\n\tchar *ip_addr = NULL;\n\tint ip_len;\n\n\tip_len = dns_query(net, NULL, name, namelen, NULL, &ip_addr, NULL,\n\t\t\t   false);\n\tif (ip_len > 0)\n\t\tret = rpc_pton(net, ip_addr, ip_len, sa, salen);\n\telse\n\t\tret = -ESRCH;\n\tkfree(ip_addr);\n\treturn ret;\n}\n\n#else\n\n#include <linux/hash.h>\n#include <linux/string.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/socket.h>\n#include <linux/seq_file.h>\n#include <linux/inet.h>\n#include <linux/sunrpc/cache.h>\n#include <linux/sunrpc/svcauth.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/nfs_fs.h>\n\n#include \"nfs4_fs.h\"\n#include \"cache_lib.h\"\n#include \"netns.h\"\n\n#define NFS_DNS_HASHBITS 4\n#define NFS_DNS_HASHTBL_SIZE (1 << NFS_DNS_HASHBITS)\n\nstruct nfs_dns_ent {\n\tstruct cache_head h;\n\n\tchar *hostname;\n\tsize_t namelen;\n\n\tstruct sockaddr_storage addr;\n\tsize_t addrlen;\n\tstruct rcu_head rcu_head;\n};\n\n\nstatic void nfs_dns_ent_update(struct cache_head *cnew,\n\t\tstruct cache_head *ckey)\n{\n\tstruct nfs_dns_ent *new;\n\tstruct nfs_dns_ent *key;\n\n\tnew = container_of(cnew, struct nfs_dns_ent, h);\n\tkey = container_of(ckey, struct nfs_dns_ent, h);\n\n\tmemcpy(&new->addr, &key->addr, key->addrlen);\n\tnew->addrlen = key->addrlen;\n}\n\nstatic void nfs_dns_ent_init(struct cache_head *cnew,\n\t\tstruct cache_head *ckey)\n{\n\tstruct nfs_dns_ent *new;\n\tstruct nfs_dns_ent *key;\n\n\tnew = container_of(cnew, struct nfs_dns_ent, h);\n\tkey = container_of(ckey, struct nfs_dns_ent, h);\n\n\tkfree(new->hostname);\n\tnew->hostname = kmemdup_nul(key->hostname, key->namelen, GFP_KERNEL);\n\tif (new->hostname) {\n\t\tnew->namelen = key->namelen;\n\t\tnfs_dns_ent_update(cnew, ckey);\n\t} else {\n\t\tnew->namelen = 0;\n\t\tnew->addrlen = 0;\n\t}\n}\n\nstatic void nfs_dns_ent_free_rcu(struct rcu_head *head)\n{\n\tstruct nfs_dns_ent *item;\n\n\titem = container_of(head, struct nfs_dns_ent, rcu_head);\n\tkfree(item->hostname);\n\tkfree(item);\n}\n\nstatic void nfs_dns_ent_put(struct kref *ref)\n{\n\tstruct nfs_dns_ent *item;\n\n\titem = container_of(ref, struct nfs_dns_ent, h.ref);\n\tcall_rcu(&item->rcu_head, nfs_dns_ent_free_rcu);\n}\n\nstatic struct cache_head *nfs_dns_ent_alloc(void)\n{\n\tstruct nfs_dns_ent *item = kmalloc(sizeof(*item), GFP_KERNEL);\n\n\tif (item != NULL) {\n\t\titem->hostname = NULL;\n\t\titem->namelen = 0;\n\t\titem->addrlen = 0;\n\t\treturn &item->h;\n\t}\n\treturn NULL;\n};\n\nstatic unsigned int nfs_dns_hash(const struct nfs_dns_ent *key)\n{\n\treturn hash_str(key->hostname, NFS_DNS_HASHBITS);\n}\n\nstatic void nfs_dns_request(struct cache_detail *cd,\n\t\tstruct cache_head *ch,\n\t\tchar **bpp, int *blen)\n{\n\tstruct nfs_dns_ent *key = container_of(ch, struct nfs_dns_ent, h);\n\n\tqword_add(bpp, blen, key->hostname);\n\t(*bpp)[-1] = '\\n';\n}\n\nstatic int nfs_dns_upcall(struct cache_detail *cd,\n\t\tstruct cache_head *ch)\n{\n\tstruct nfs_dns_ent *key = container_of(ch, struct nfs_dns_ent, h);\n\n\tif (test_and_set_bit(CACHE_PENDING, &ch->flags))\n\t\treturn 0;\n\tif (!nfs_cache_upcall(cd, key->hostname))\n\t\treturn 0;\n\tclear_bit(CACHE_PENDING, &ch->flags);\n\treturn sunrpc_cache_pipe_upcall_timeout(cd, ch);\n}\n\nstatic int nfs_dns_match(struct cache_head *ca,\n\t\tstruct cache_head *cb)\n{\n\tstruct nfs_dns_ent *a;\n\tstruct nfs_dns_ent *b;\n\n\ta = container_of(ca, struct nfs_dns_ent, h);\n\tb = container_of(cb, struct nfs_dns_ent, h);\n\n\tif (a->namelen == 0 || a->namelen != b->namelen)\n\t\treturn 0;\n\treturn memcmp(a->hostname, b->hostname, a->namelen) == 0;\n}\n\nstatic int nfs_dns_show(struct seq_file *m, struct cache_detail *cd,\n\t\tstruct cache_head *h)\n{\n\tstruct nfs_dns_ent *item;\n\tlong ttl;\n\n\tif (h == NULL) {\n\t\tseq_puts(m, \"# ip address      hostname        ttl\\n\");\n\t\treturn 0;\n\t}\n\titem = container_of(h, struct nfs_dns_ent, h);\n\tttl = item->h.expiry_time - seconds_since_boot();\n\tif (ttl < 0)\n\t\tttl = 0;\n\n\tif (!test_bit(CACHE_NEGATIVE, &h->flags)) {\n\t\tchar buf[INET6_ADDRSTRLEN+IPV6_SCOPE_ID_LEN+1];\n\n\t\trpc_ntop((struct sockaddr *)&item->addr, buf, sizeof(buf));\n\t\tseq_printf(m, \"%15s \", buf);\n\t} else\n\t\tseq_puts(m, \"<none>          \");\n\tseq_printf(m, \"%15s %ld\\n\", item->hostname, ttl);\n\treturn 0;\n}\n\nstatic struct nfs_dns_ent *nfs_dns_lookup(struct cache_detail *cd,\n\t\tstruct nfs_dns_ent *key)\n{\n\tstruct cache_head *ch;\n\n\tch = sunrpc_cache_lookup_rcu(cd,\n\t\t\t&key->h,\n\t\t\tnfs_dns_hash(key));\n\tif (!ch)\n\t\treturn NULL;\n\treturn container_of(ch, struct nfs_dns_ent, h);\n}\n\nstatic struct nfs_dns_ent *nfs_dns_update(struct cache_detail *cd,\n\t\tstruct nfs_dns_ent *new,\n\t\tstruct nfs_dns_ent *key)\n{\n\tstruct cache_head *ch;\n\n\tch = sunrpc_cache_update(cd,\n\t\t\t&new->h, &key->h,\n\t\t\tnfs_dns_hash(key));\n\tif (!ch)\n\t\treturn NULL;\n\treturn container_of(ch, struct nfs_dns_ent, h);\n}\n\nstatic int nfs_dns_parse(struct cache_detail *cd, char *buf, int buflen)\n{\n\tchar buf1[NFS_DNS_HOSTNAME_MAXLEN+1];\n\tstruct nfs_dns_ent key, *item;\n\tunsigned int ttl;\n\tssize_t len;\n\tint ret = -EINVAL;\n\n\tif (buf[buflen-1] != '\\n')\n\t\tgoto out;\n\tbuf[buflen-1] = '\\0';\n\n\tlen = qword_get(&buf, buf1, sizeof(buf1));\n\tif (len <= 0)\n\t\tgoto out;\n\tkey.addrlen = rpc_pton(cd->net, buf1, len,\n\t\t\t(struct sockaddr *)&key.addr,\n\t\t\tsizeof(key.addr));\n\n\tlen = qword_get(&buf, buf1, sizeof(buf1));\n\tif (len <= 0)\n\t\tgoto out;\n\n\tkey.hostname = buf1;\n\tkey.namelen = len;\n\tmemset(&key.h, 0, sizeof(key.h));\n\n\tif (get_uint(&buf, &ttl) < 0)\n\t\tgoto out;\n\tif (ttl == 0)\n\t\tgoto out;\n\tkey.h.expiry_time = ttl + seconds_since_boot();\n\n\tret = -ENOMEM;\n\titem = nfs_dns_lookup(cd, &key);\n\tif (item == NULL)\n\t\tgoto out;\n\n\tif (key.addrlen == 0)\n\t\tset_bit(CACHE_NEGATIVE, &key.h.flags);\n\n\titem = nfs_dns_update(cd, &key, item);\n\tif (item == NULL)\n\t\tgoto out;\n\n\tret = 0;\n\tcache_put(&item->h, cd);\nout:\n\treturn ret;\n}\n\nstatic int do_cache_lookup(struct cache_detail *cd,\n\t\tstruct nfs_dns_ent *key,\n\t\tstruct nfs_dns_ent **item,\n\t\tstruct nfs_cache_defer_req *dreq)\n{\n\tint ret = -ENOMEM;\n\n\t*item = nfs_dns_lookup(cd, key);\n\tif (*item) {\n\t\tret = cache_check(cd, &(*item)->h, &dreq->req);\n\t\tif (ret)\n\t\t\t*item = NULL;\n\t}\n\treturn ret;\n}\n\nstatic int do_cache_lookup_nowait(struct cache_detail *cd,\n\t\tstruct nfs_dns_ent *key,\n\t\tstruct nfs_dns_ent **item)\n{\n\tint ret = -ENOMEM;\n\n\t*item = nfs_dns_lookup(cd, key);\n\tif (!*item)\n\t\tgoto out_err;\n\tret = -ETIMEDOUT;\n\tif (!test_bit(CACHE_VALID, &(*item)->h.flags)\n\t\t\t|| (*item)->h.expiry_time < seconds_since_boot()\n\t\t\t|| cd->flush_time > (*item)->h.last_refresh)\n\t\tgoto out_put;\n\tret = -ENOENT;\n\tif (test_bit(CACHE_NEGATIVE, &(*item)->h.flags))\n\t\tgoto out_put;\n\treturn 0;\nout_put:\n\tcache_put(&(*item)->h, cd);\nout_err:\n\t*item = NULL;\n\treturn ret;\n}\n\nstatic int do_cache_lookup_wait(struct cache_detail *cd,\n\t\tstruct nfs_dns_ent *key,\n\t\tstruct nfs_dns_ent **item)\n{\n\tstruct nfs_cache_defer_req *dreq;\n\tint ret = -ENOMEM;\n\n\tdreq = nfs_cache_defer_req_alloc();\n\tif (!dreq)\n\t\tgoto out;\n\tret = do_cache_lookup(cd, key, item, dreq);\n\tif (ret == -EAGAIN) {\n\t\tret = nfs_cache_wait_for_upcall(dreq);\n\t\tif (!ret)\n\t\t\tret = do_cache_lookup_nowait(cd, key, item);\n\t}\n\tnfs_cache_defer_req_put(dreq);\nout:\n\treturn ret;\n}\n\nssize_t nfs_dns_resolve_name(struct net *net, char *name,\n\t\tsize_t namelen, struct sockaddr_storage *ss, size_t salen)\n{\n\tstruct nfs_dns_ent key = {\n\t\t.hostname = name,\n\t\t.namelen = namelen,\n\t};\n\tstruct nfs_dns_ent *item = NULL;\n\tssize_t ret;\n\tstruct nfs_net *nn = net_generic(net, nfs_net_id);\n\n\tret = do_cache_lookup_wait(nn->nfs_dns_resolve, &key, &item);\n\tif (ret == 0) {\n\t\tif (salen >= item->addrlen) {\n\t\t\tmemcpy(ss, &item->addr, item->addrlen);\n\t\t\tret = item->addrlen;\n\t\t} else\n\t\t\tret = -EOVERFLOW;\n\t\tcache_put(&item->h, nn->nfs_dns_resolve);\n\t} else if (ret == -ENOENT)\n\t\tret = -ESRCH;\n\treturn ret;\n}\n\nstatic struct cache_detail nfs_dns_resolve_template = {\n\t.owner\t\t= THIS_MODULE,\n\t.hash_size\t= NFS_DNS_HASHTBL_SIZE,\n\t.name\t\t= \"dns_resolve\",\n\t.cache_put\t= nfs_dns_ent_put,\n\t.cache_upcall\t= nfs_dns_upcall,\n\t.cache_request\t= nfs_dns_request,\n\t.cache_parse\t= nfs_dns_parse,\n\t.cache_show\t= nfs_dns_show,\n\t.match\t\t= nfs_dns_match,\n\t.init\t\t= nfs_dns_ent_init,\n\t.update\t\t= nfs_dns_ent_update,\n\t.alloc\t\t= nfs_dns_ent_alloc,\n};\n\n\nint nfs_dns_resolver_cache_init(struct net *net)\n{\n\tint err;\n\tstruct nfs_net *nn = net_generic(net, nfs_net_id);\n\n\tnn->nfs_dns_resolve = cache_create_net(&nfs_dns_resolve_template, net);\n\tif (IS_ERR(nn->nfs_dns_resolve))\n\t\treturn PTR_ERR(nn->nfs_dns_resolve);\n\n\terr = nfs_cache_register_net(net, nn->nfs_dns_resolve);\n\tif (err)\n\t\tgoto err_reg;\n\treturn 0;\n\nerr_reg:\n\tcache_destroy_net(nn->nfs_dns_resolve, net);\n\treturn err;\n}\n\nvoid nfs_dns_resolver_cache_destroy(struct net *net)\n{\n\tstruct nfs_net *nn = net_generic(net, nfs_net_id);\n\n\tnfs_cache_unregister_net(net, nn->nfs_dns_resolve);\n\tcache_destroy_net(nn->nfs_dns_resolve, net);\n}\n\nstatic int nfs4_dns_net_init(struct net *net)\n{\n\treturn nfs_dns_resolver_cache_init(net);\n}\n\nstatic void nfs4_dns_net_exit(struct net *net)\n{\n\tnfs_dns_resolver_cache_destroy(net);\n}\n\nstatic struct pernet_operations nfs4_dns_resolver_ops = {\n\t.init = nfs4_dns_net_init,\n\t.exit = nfs4_dns_net_exit,\n};\n\nstatic int rpc_pipefs_event(struct notifier_block *nb, unsigned long event,\n\t\t\t   void *ptr)\n{\n\tstruct super_block *sb = ptr;\n\tstruct net *net = sb->s_fs_info;\n\tstruct nfs_net *nn = net_generic(net, nfs_net_id);\n\tstruct cache_detail *cd = nn->nfs_dns_resolve;\n\tint ret = 0;\n\n\tif (cd == NULL)\n\t\treturn 0;\n\n\tif (!try_module_get(THIS_MODULE))\n\t\treturn 0;\n\n\tswitch (event) {\n\tcase RPC_PIPEFS_MOUNT:\n\t\tret = nfs_cache_register_sb(sb, cd);\n\t\tbreak;\n\tcase RPC_PIPEFS_UMOUNT:\n\t\tnfs_cache_unregister_sb(sb, cd);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOTSUPP;\n\t\tbreak;\n\t}\n\tmodule_put(THIS_MODULE);\n\treturn ret;\n}\n\nstatic struct notifier_block nfs_dns_resolver_block = {\n\t.notifier_call\t= rpc_pipefs_event,\n};\n\nint nfs_dns_resolver_init(void)\n{\n\tint err;\n\n\terr = register_pernet_subsys(&nfs4_dns_resolver_ops);\n\tif (err < 0)\n\t\tgoto out;\n\terr = rpc_pipefs_notifier_register(&nfs_dns_resolver_block);\n\tif (err < 0)\n\t\tgoto out1;\n\treturn 0;\nout1:\n\tunregister_pernet_subsys(&nfs4_dns_resolver_ops);\nout:\n\treturn err;\n}\n\nvoid nfs_dns_resolver_destroy(void)\n{\n\trpc_pipefs_notifier_unregister(&nfs_dns_resolver_block);\n\tunregister_pernet_subsys(&nfs4_dns_resolver_ops);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}