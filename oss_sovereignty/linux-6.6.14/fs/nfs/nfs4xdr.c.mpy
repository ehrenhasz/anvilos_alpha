{
  "module_name": "nfs4xdr.c",
  "hash_id": "ce9de4ec9c49e45b10777dc005d74face86c4739a8d1b58eaa04c253a2bb7577",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfs/nfs4xdr.c",
  "human_readable_source": " \n\n#include <linux/param.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/in.h>\n#include <linux/pagemap.h>\n#include <linux/proc_fs.h>\n#include <linux/kdev_t.h>\n#include <linux/module.h>\n#include <linux/utsname.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/msg_prot.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/nfs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs_fs.h>\n\n#include \"nfs4_fs.h\"\n#include \"nfs4trace.h\"\n#include \"internal.h\"\n#include \"nfs4idmap.h\"\n#include \"nfs4session.h\"\n#include \"pnfs.h\"\n#include \"netns.h\"\n\n#define NFSDBG_FACILITY\t\tNFSDBG_XDR\n\n \n#define errno_NFSERR_IO\t\tEIO\n\nstruct compound_hdr;\nstatic int nfs4_stat_to_errno(int);\nstatic void encode_layoutget(struct xdr_stream *xdr,\n\t\t\t     const struct nfs4_layoutget_args *args,\n\t\t\t     struct compound_hdr *hdr);\nstatic int decode_layoutget(struct xdr_stream *xdr, struct rpc_rqst *req,\n\t\t\t     struct nfs4_layoutget_res *res);\n\n \n#ifdef DEBUG\n#define NFS4_MAXTAGLEN\t\t20\n#else\n#define NFS4_MAXTAGLEN\t\t0\n#endif\n\n \n#define pagepad_maxsz\t\t(1)\n#define open_owner_id_maxsz\t(1 + 2 + 1 + 1 + 2)\n#define lock_owner_id_maxsz\t(1 + 1 + 4)\n#define decode_lockowner_maxsz\t(1 + XDR_QUADLEN(IDMAP_NAMESZ))\n#define compound_encode_hdr_maxsz\t(3 + (NFS4_MAXTAGLEN >> 2))\n#define compound_decode_hdr_maxsz\t(3 + (NFS4_MAXTAGLEN >> 2))\n#define op_encode_hdr_maxsz\t(1)\n#define op_decode_hdr_maxsz\t(2)\n#define encode_stateid_maxsz\t(XDR_QUADLEN(NFS4_STATEID_SIZE))\n#define decode_stateid_maxsz\t(XDR_QUADLEN(NFS4_STATEID_SIZE))\n#define encode_verifier_maxsz\t(XDR_QUADLEN(NFS4_VERIFIER_SIZE))\n#define decode_verifier_maxsz\t(XDR_QUADLEN(NFS4_VERIFIER_SIZE))\n#define encode_putfh_maxsz\t(op_encode_hdr_maxsz + 1 + \\\n\t\t\t\t(NFS4_FHSIZE >> 2))\n#define decode_putfh_maxsz\t(op_decode_hdr_maxsz)\n#define encode_putrootfh_maxsz\t(op_encode_hdr_maxsz)\n#define decode_putrootfh_maxsz\t(op_decode_hdr_maxsz)\n#define encode_getfh_maxsz      (op_encode_hdr_maxsz)\n#define decode_getfh_maxsz      (op_decode_hdr_maxsz + 1 + \\\n\t\t\t\t((3+NFS4_FHSIZE) >> 2))\n#define nfs4_fattr_bitmap_maxsz 4\n#define encode_getattr_maxsz    (op_encode_hdr_maxsz + nfs4_fattr_bitmap_maxsz)\n#define nfstime4_maxsz\t\t(3)\n#define nfs4_name_maxsz\t\t(1 + ((3 + NFS4_MAXNAMLEN) >> 2))\n#define nfs4_path_maxsz\t\t(1 + ((3 + NFS4_MAXPATHLEN) >> 2))\n#define nfs4_owner_maxsz\t(1 + XDR_QUADLEN(IDMAP_NAMESZ))\n#define nfs4_group_maxsz\t(1 + XDR_QUADLEN(IDMAP_NAMESZ))\n#ifdef CONFIG_NFS_V4_SECURITY_LABEL\n \n#define\tnfs4_label_maxsz\t(4 + 4 + 1 + XDR_QUADLEN(NFS4_MAXLABELLEN))\n#else\n#define\tnfs4_label_maxsz\t0\n#endif\n \n#define decode_mdsthreshold_maxsz (1 + 1 + nfs4_fattr_bitmap_maxsz + 1 + 8)\n \n#define nfs4_fattr_value_maxsz\t(1 + (1 + 2 + 2 + 4 + 2 + 1 + 1 + 2 + 2 + \\\n\t\t\t\t3*nfstime4_maxsz + \\\n\t\t\t\tnfs4_owner_maxsz + \\\n\t\t\t\tnfs4_group_maxsz + nfs4_label_maxsz + \\\n\t\t\t\t decode_mdsthreshold_maxsz))\n#define nfs4_fattr_maxsz\t(nfs4_fattr_bitmap_maxsz + \\\n\t\t\t\tnfs4_fattr_value_maxsz)\n#define decode_getattr_maxsz    (op_decode_hdr_maxsz + nfs4_fattr_maxsz)\n#define encode_attrs_maxsz\t(nfs4_fattr_bitmap_maxsz + \\\n\t\t\t\t 1 + 2 + 1 + \\\n\t\t\t\tnfs4_owner_maxsz + \\\n\t\t\t\tnfs4_group_maxsz + \\\n\t\t\t\tnfs4_label_maxsz + \\\n\t\t\t\t1 + nfstime4_maxsz + \\\n\t\t\t\t1 + nfstime4_maxsz)\n#define encode_savefh_maxsz     (op_encode_hdr_maxsz)\n#define decode_savefh_maxsz     (op_decode_hdr_maxsz)\n#define encode_restorefh_maxsz  (op_encode_hdr_maxsz)\n#define decode_restorefh_maxsz  (op_decode_hdr_maxsz)\n#define encode_fsinfo_maxsz\t(encode_getattr_maxsz)\n \n#define decode_fsinfo_maxsz\t(op_decode_hdr_maxsz + \\\n\t\t\t\t nfs4_fattr_bitmap_maxsz + 1 + \\\n\t\t\t\t 1   + \\\n\t\t\t\t 2   + \\\n\t\t\t\t 2   + \\\n\t\t\t\t 2   + \\\n\t\t\t\t nfstime4_maxsz   + \\\n\t\t\t\t 5   + \\\n\t\t\t\t 1   + \\\n\t\t\t\t 1   + \\\n\t\t\t\t 1   + \\\n\t\t\t\t 1  )\n#define encode_renew_maxsz\t(op_encode_hdr_maxsz + 3)\n#define decode_renew_maxsz\t(op_decode_hdr_maxsz)\n#define encode_setclientid_maxsz \\\n\t\t\t\t(op_encode_hdr_maxsz + \\\n\t\t\t\tXDR_QUADLEN(NFS4_VERIFIER_SIZE) + \\\n\t\t\t\t  \\\n\t\t\t\t1 + XDR_QUADLEN(NFS4_OPAQUE_LIMIT) + \\\n\t\t\t\t1   + \\\n\t\t\t\t1 + XDR_QUADLEN(RPCBIND_MAXNETIDLEN) + \\\n\t\t\t\t1 + XDR_QUADLEN(RPCBIND_MAXUADDRLEN) + \\\n\t\t\t\t1)  \n#define decode_setclientid_maxsz \\\n\t\t\t\t(op_decode_hdr_maxsz + \\\n\t\t\t\t2   + \\\n\t\t\t\tXDR_QUADLEN(NFS4_VERIFIER_SIZE) + \\\n\t\t\t\t1 + XDR_QUADLEN(RPCBIND_MAXNETIDLEN) + \\\n\t\t\t\t1 + XDR_QUADLEN(RPCBIND_MAXUADDRLEN))\n#define encode_setclientid_confirm_maxsz \\\n\t\t\t\t(op_encode_hdr_maxsz + \\\n\t\t\t\t3 + (NFS4_VERIFIER_SIZE >> 2))\n#define decode_setclientid_confirm_maxsz \\\n\t\t\t\t(op_decode_hdr_maxsz)\n#define encode_lookup_maxsz\t(op_encode_hdr_maxsz + nfs4_name_maxsz)\n#define decode_lookup_maxsz\t(op_decode_hdr_maxsz)\n#define encode_lookupp_maxsz\t(op_encode_hdr_maxsz)\n#define decode_lookupp_maxsz\t(op_decode_hdr_maxsz)\n#define encode_share_access_maxsz \\\n\t\t\t\t(2)\n#define encode_createmode_maxsz\t(1 + encode_attrs_maxsz + encode_verifier_maxsz)\n#define encode_opentype_maxsz\t(1 + encode_createmode_maxsz)\n#define encode_claim_null_maxsz\t(1 + nfs4_name_maxsz)\n#define encode_open_maxsz\t(op_encode_hdr_maxsz + \\\n\t\t\t\t2 + encode_share_access_maxsz + 2 + \\\n\t\t\t\topen_owner_id_maxsz + \\\n\t\t\t\tencode_opentype_maxsz + \\\n\t\t\t\tencode_claim_null_maxsz)\n#define decode_space_limit_maxsz\t(3)\n#define decode_ace_maxsz\t(3 + nfs4_owner_maxsz)\n#define decode_delegation_maxsz\t(1 + decode_stateid_maxsz + 1 + \\\n\t\t\t\tdecode_space_limit_maxsz + \\\n\t\t\t\tdecode_ace_maxsz)\n#define decode_change_info_maxsz\t(5)\n#define decode_open_maxsz\t(op_decode_hdr_maxsz + \\\n\t\t\t\tdecode_stateid_maxsz + \\\n\t\t\t\tdecode_change_info_maxsz + 1 + \\\n\t\t\t\tnfs4_fattr_bitmap_maxsz + \\\n\t\t\t\tdecode_delegation_maxsz)\n#define encode_open_confirm_maxsz \\\n\t\t\t\t(op_encode_hdr_maxsz + \\\n\t\t\t\t encode_stateid_maxsz + 1)\n#define decode_open_confirm_maxsz \\\n\t\t\t\t(op_decode_hdr_maxsz + \\\n\t\t\t\t decode_stateid_maxsz)\n#define encode_open_downgrade_maxsz \\\n\t\t\t\t(op_encode_hdr_maxsz + \\\n\t\t\t\t encode_stateid_maxsz + 1 + \\\n\t\t\t\t encode_share_access_maxsz)\n#define decode_open_downgrade_maxsz \\\n\t\t\t\t(op_decode_hdr_maxsz + \\\n\t\t\t\t decode_stateid_maxsz)\n#define encode_close_maxsz\t(op_encode_hdr_maxsz + \\\n\t\t\t\t 1 + encode_stateid_maxsz)\n#define decode_close_maxsz\t(op_decode_hdr_maxsz + \\\n\t\t\t\t decode_stateid_maxsz)\n#define encode_setattr_maxsz\t(op_encode_hdr_maxsz + \\\n\t\t\t\t encode_stateid_maxsz + \\\n\t\t\t\t encode_attrs_maxsz)\n#define decode_setattr_maxsz\t(op_decode_hdr_maxsz + \\\n\t\t\t\t nfs4_fattr_bitmap_maxsz)\n#define encode_read_maxsz\t(op_encode_hdr_maxsz + \\\n\t\t\t\t encode_stateid_maxsz + 3)\n#define decode_read_maxsz\t(op_decode_hdr_maxsz + 2 + pagepad_maxsz)\n#define encode_readdir_maxsz\t(op_encode_hdr_maxsz + \\\n\t\t\t\t 2 + encode_verifier_maxsz + 5 + \\\n\t\t\t\tnfs4_label_maxsz)\n#define decode_readdir_maxsz\t(op_decode_hdr_maxsz + \\\n\t\t\t\t decode_verifier_maxsz + pagepad_maxsz)\n#define encode_readlink_maxsz\t(op_encode_hdr_maxsz)\n#define decode_readlink_maxsz\t(op_decode_hdr_maxsz + 1 + pagepad_maxsz)\n#define encode_write_maxsz\t(op_encode_hdr_maxsz + \\\n\t\t\t\t encode_stateid_maxsz + 4)\n#define decode_write_maxsz\t(op_decode_hdr_maxsz + \\\n\t\t\t\t 2 + decode_verifier_maxsz)\n#define encode_commit_maxsz\t(op_encode_hdr_maxsz + 3)\n#define decode_commit_maxsz\t(op_decode_hdr_maxsz + \\\n\t\t\t\t decode_verifier_maxsz)\n#define encode_remove_maxsz\t(op_encode_hdr_maxsz + \\\n\t\t\t\tnfs4_name_maxsz)\n#define decode_remove_maxsz\t(op_decode_hdr_maxsz + \\\n\t\t\t\t decode_change_info_maxsz)\n#define encode_rename_maxsz\t(op_encode_hdr_maxsz + \\\n\t\t\t\t2 * nfs4_name_maxsz)\n#define decode_rename_maxsz\t(op_decode_hdr_maxsz + \\\n\t\t\t\t decode_change_info_maxsz + \\\n\t\t\t\t decode_change_info_maxsz)\n#define encode_link_maxsz\t(op_encode_hdr_maxsz + \\\n\t\t\t\tnfs4_name_maxsz)\n#define decode_link_maxsz\t(op_decode_hdr_maxsz + decode_change_info_maxsz)\n#define encode_lockowner_maxsz\t(7)\n#define encode_lock_maxsz\t(op_encode_hdr_maxsz + \\\n\t\t\t\t 7 + \\\n\t\t\t\t 1 + encode_stateid_maxsz + 1 + \\\n\t\t\t\t encode_lockowner_maxsz)\n#define decode_lock_denied_maxsz \\\n\t\t\t\t(8 + decode_lockowner_maxsz)\n#define decode_lock_maxsz\t(op_decode_hdr_maxsz + \\\n\t\t\t\t decode_lock_denied_maxsz)\n#define encode_lockt_maxsz\t(op_encode_hdr_maxsz + 5 + \\\n\t\t\t\tencode_lockowner_maxsz)\n#define decode_lockt_maxsz\t(op_decode_hdr_maxsz + \\\n\t\t\t\t decode_lock_denied_maxsz)\n#define encode_locku_maxsz\t(op_encode_hdr_maxsz + 3 + \\\n\t\t\t\t encode_stateid_maxsz + \\\n\t\t\t\t 4)\n#define decode_locku_maxsz\t(op_decode_hdr_maxsz + \\\n\t\t\t\t decode_stateid_maxsz)\n#define encode_release_lockowner_maxsz \\\n\t\t\t\t(op_encode_hdr_maxsz + \\\n\t\t\t\t encode_lockowner_maxsz)\n#define decode_release_lockowner_maxsz \\\n\t\t\t\t(op_decode_hdr_maxsz)\n#define encode_access_maxsz\t(op_encode_hdr_maxsz + 1)\n#define decode_access_maxsz\t(op_decode_hdr_maxsz + 2)\n#define encode_symlink_maxsz\t(op_encode_hdr_maxsz + \\\n\t\t\t\t1 + nfs4_name_maxsz + \\\n\t\t\t\t1 + \\\n\t\t\t\tnfs4_fattr_maxsz)\n#define decode_symlink_maxsz\t(op_decode_hdr_maxsz + 8)\n#define encode_create_maxsz\t(op_encode_hdr_maxsz + \\\n\t\t\t\t1 + 2 + nfs4_name_maxsz + \\\n\t\t\t\tencode_attrs_maxsz)\n#define decode_create_maxsz\t(op_decode_hdr_maxsz + \\\n\t\t\t\tdecode_change_info_maxsz + \\\n\t\t\t\tnfs4_fattr_bitmap_maxsz)\n#define encode_statfs_maxsz\t(encode_getattr_maxsz)\n#define decode_statfs_maxsz\t(decode_getattr_maxsz)\n#define encode_delegreturn_maxsz (op_encode_hdr_maxsz + 4)\n#define decode_delegreturn_maxsz (op_decode_hdr_maxsz)\n#define encode_getacl_maxsz\t(encode_getattr_maxsz)\n#define decode_getacl_maxsz\t(op_decode_hdr_maxsz + \\\n\t\t\t\t nfs4_fattr_bitmap_maxsz + 1 + pagepad_maxsz)\n#define encode_setacl_maxsz\t(op_encode_hdr_maxsz + \\\n\t\t\t\t encode_stateid_maxsz + 3)\n#define decode_setacl_maxsz\t(decode_setattr_maxsz)\n#define encode_fs_locations_maxsz \\\n\t\t\t\t(encode_getattr_maxsz)\n#define decode_fs_locations_maxsz \\\n\t\t\t\t(pagepad_maxsz)\n#define encode_secinfo_maxsz\t(op_encode_hdr_maxsz + nfs4_name_maxsz)\n#define decode_secinfo_maxsz\t(op_decode_hdr_maxsz + 1 + ((NFS_MAX_SECFLAVORS * (16 + GSS_OID_MAX_LEN)) / 4))\n\n#if defined(CONFIG_NFS_V4_1)\n#define NFS4_MAX_MACHINE_NAME_LEN (64)\n#define IMPL_NAME_LIMIT (sizeof(utsname()->sysname) + sizeof(utsname()->release) + \\\n\t\t\t sizeof(utsname()->version) + sizeof(utsname()->machine) + 8)\n\n#define encode_exchange_id_maxsz (op_encode_hdr_maxsz + \\\n\t\t\t\tencode_verifier_maxsz + \\\n\t\t\t\t1   + \\\n\t\t\t\t  \\\n\t\t\t\t1 + XDR_QUADLEN(NFS4_OPAQUE_LIMIT) + \\\n\t\t\t\t1   + \\\n\t\t\t\t1   + \\\n\t\t\t\t  + \\\n\t\t\t\t1 + NFS4_OP_MAP_NUM_WORDS + \\\n\t\t\t\t1 + NFS4_OP_MAP_NUM_WORDS + \\\n\t\t\t\t1   + \\\n\t\t\t\t1   + \\\n\t\t\t\tXDR_QUADLEN(NFS4_OPAQUE_LIMIT) + \\\n\t\t\t\t1   + \\\n\t\t\t\tXDR_QUADLEN(IMPL_NAME_LIMIT) + \\\n\t\t\t\t3  )\n#define decode_exchange_id_maxsz (op_decode_hdr_maxsz + \\\n\t\t\t\t2   + \\\n\t\t\t\t1   + \\\n\t\t\t\t1   + \\\n\t\t\t\t1   + \\\n\t\t\t\t    + \\\n\t\t\t\t1 + NFS4_OP_MAP_NUM_WORDS + \\\n\t\t\t\t1 + NFS4_OP_MAP_NUM_WORDS + \\\n\t\t\t\t2   + \\\n\t\t\t\t  \\\n\t\t\t\tXDR_QUADLEN(NFS4_OPAQUE_LIMIT) + 1 + \\\n\t\t\t\t  \\\n\t\t\t\tXDR_QUADLEN(NFS4_OPAQUE_LIMIT) + 1 + \\\n\t\t\t\t1   + \\\n\t\t\t\t1   + \\\n\t\t\t\tXDR_QUADLEN(NFS4_OPAQUE_LIMIT) + \\\n\t\t\t\t1   + \\\n\t\t\t\tXDR_QUADLEN(NFS4_OPAQUE_LIMIT) + \\\n\t\t\t\t3  )\n#define encode_channel_attrs_maxsz  (6 + 1  )\n#define decode_channel_attrs_maxsz  (6 + \\\n\t\t\t\t     1   + \\\n\t\t\t\t     1  )\n#define encode_create_session_maxsz  (op_encode_hdr_maxsz + \\\n\t\t\t\t     2   + \\\n\t\t\t\t     1   + \\\n\t\t\t\t     1   + \\\n\t\t\t\t     encode_channel_attrs_maxsz + \\\n\t\t\t\t     encode_channel_attrs_maxsz + \\\n\t\t\t\t     1   + \\\n\t\t\t\t     1   + \\\n\t\t\t\t     1   + \\\n\t\t\t\t     1   + \\\n\t\t\t\t     1   + \\\n\t\t\t\t     XDR_QUADLEN(NFS4_MAX_MACHINE_NAME_LEN) + \\\n\t\t\t\t     1   + \\\n\t\t\t\t     1   + \\\n\t\t\t\t     1  )\n#define decode_create_session_maxsz  (op_decode_hdr_maxsz +\t\\\n\t\t\t\t     XDR_QUADLEN(NFS4_MAX_SESSIONID_LEN) + \\\n\t\t\t\t     1   + \\\n\t\t\t\t     1   + \\\n\t\t\t\t     decode_channel_attrs_maxsz + \\\n\t\t\t\t     decode_channel_attrs_maxsz)\n#define encode_bind_conn_to_session_maxsz  (op_encode_hdr_maxsz + \\\n\t\t\t\t       \\\n\t\t\t\t     XDR_QUADLEN(NFS4_MAX_SESSIONID_LEN) + \\\n\t\t\t\t     1   + \\\n\t\t\t\t     1  )\n#define decode_bind_conn_to_session_maxsz  (op_decode_hdr_maxsz +\t\\\n\t\t\t\t       \\\n\t\t\t\t     XDR_QUADLEN(NFS4_MAX_SESSIONID_LEN) + \\\n\t\t\t\t     1   + \\\n\t\t\t\t     1  )\n#define encode_destroy_session_maxsz    (op_encode_hdr_maxsz + 4)\n#define decode_destroy_session_maxsz    (op_decode_hdr_maxsz)\n#define encode_destroy_clientid_maxsz   (op_encode_hdr_maxsz + 2)\n#define decode_destroy_clientid_maxsz   (op_decode_hdr_maxsz)\n#define encode_sequence_maxsz\t(op_encode_hdr_maxsz + \\\n\t\t\t\tXDR_QUADLEN(NFS4_MAX_SESSIONID_LEN) + 4)\n#define decode_sequence_maxsz\t(op_decode_hdr_maxsz + \\\n\t\t\t\tXDR_QUADLEN(NFS4_MAX_SESSIONID_LEN) + 5)\n#define encode_reclaim_complete_maxsz\t(op_encode_hdr_maxsz + 4)\n#define decode_reclaim_complete_maxsz\t(op_decode_hdr_maxsz + 4)\n#define encode_getdeviceinfo_maxsz (op_encode_hdr_maxsz + \\\n\t\t\t\tXDR_QUADLEN(NFS4_DEVICEID4_SIZE) + \\\n\t\t\t\t1   + \\\n\t\t\t\t1   + \\\n\t\t\t\t1   + \\\n\t\t\t\t1   + \\\n\t\t\t\t1  )\n#define decode_getdeviceinfo_maxsz (op_decode_hdr_maxsz + \\\n\t\t\t\t1   + \\\n\t\t\t\t1   + \\\n\t\t\t\t    \\\n\t\t\t\t1   + \\\n\t\t\t\t1   + \\\n\t\t\t\tpagepad_maxsz  )\n#define encode_layoutget_maxsz\t(op_encode_hdr_maxsz + 10 + \\\n\t\t\t\tencode_stateid_maxsz)\n#define decode_layoutget_maxsz\t(op_decode_hdr_maxsz + 8 + \\\n\t\t\t\tdecode_stateid_maxsz + \\\n\t\t\t\tXDR_QUADLEN(PNFS_LAYOUT_MAXSIZE) + \\\n\t\t\t\tpagepad_maxsz)\n#define encode_layoutcommit_maxsz (op_encode_hdr_maxsz +          \\\n\t\t\t\t2   + \\\n\t\t\t\t2   + \\\n\t\t\t\t1   + \\\n\t\t\t\tencode_stateid_maxsz + \\\n\t\t\t\t1   + \\\n\t\t\t\t2   + \\\n\t\t\t\t1   + \\\n\t\t\t\t1   + \\\n\t\t\t\t1  )\n\t\t\t\t   \n#define decode_layoutcommit_maxsz (op_decode_hdr_maxsz + 3)\n#define encode_layoutreturn_maxsz (8 + op_encode_hdr_maxsz + \\\n\t\t\t\tencode_stateid_maxsz + \\\n\t\t\t\t1 + \\\n\t\t\t\tXDR_QUADLEN(NFS4_OPAQUE_LIMIT))\n#define decode_layoutreturn_maxsz (op_decode_hdr_maxsz + \\\n\t\t\t\t1 + decode_stateid_maxsz)\n#define encode_secinfo_no_name_maxsz (op_encode_hdr_maxsz + 1)\n#define decode_secinfo_no_name_maxsz decode_secinfo_maxsz\n#define encode_test_stateid_maxsz\t(op_encode_hdr_maxsz + 2 + \\\n\t\t\t\t\t XDR_QUADLEN(NFS4_STATEID_SIZE))\n#define decode_test_stateid_maxsz\t(op_decode_hdr_maxsz + 2 + 1)\n#define encode_free_stateid_maxsz\t(op_encode_hdr_maxsz + 1 + \\\n\t\t\t\t\t XDR_QUADLEN(NFS4_STATEID_SIZE))\n#define decode_free_stateid_maxsz\t(op_decode_hdr_maxsz)\n#else  \n#define encode_sequence_maxsz\t0\n#define decode_sequence_maxsz\t0\n#define encode_layoutreturn_maxsz 0\n#define decode_layoutreturn_maxsz 0\n#define encode_layoutget_maxsz\t0\n#define decode_layoutget_maxsz\t0\n#endif  \n\n#define NFS4_enc_compound_sz\t(1024)   \n#define NFS4_dec_compound_sz\t(1024)   \n#define NFS4_enc_read_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_sequence_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_read_maxsz)\n#define NFS4_dec_read_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_read_maxsz)\n#define NFS4_enc_readlink_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_sequence_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_readlink_maxsz)\n#define NFS4_dec_readlink_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_readlink_maxsz)\n#define NFS4_enc_readdir_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_sequence_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_readdir_maxsz)\n#define NFS4_dec_readdir_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_readdir_maxsz)\n#define NFS4_enc_write_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_sequence_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_write_maxsz + \\\n\t\t\t\tencode_getattr_maxsz)\n#define NFS4_dec_write_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_write_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz)\n#define NFS4_enc_commit_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_sequence_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_commit_maxsz)\n#define NFS4_dec_commit_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_commit_maxsz)\n#define NFS4_enc_open_sz        (compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_sequence_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_open_maxsz + \\\n\t\t\t\tencode_access_maxsz + \\\n\t\t\t\tencode_getfh_maxsz + \\\n\t\t\t\tencode_getattr_maxsz + \\\n\t\t\t\tencode_layoutget_maxsz)\n#define NFS4_dec_open_sz        (compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_open_maxsz + \\\n\t\t\t\tdecode_access_maxsz + \\\n\t\t\t\tdecode_getfh_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz + \\\n\t\t\t\tdecode_layoutget_maxsz)\n#define NFS4_enc_open_confirm_sz \\\n\t\t\t\t(compound_encode_hdr_maxsz + \\\n\t\t\t\t encode_putfh_maxsz + \\\n\t\t\t\t encode_open_confirm_maxsz)\n#define NFS4_dec_open_confirm_sz \\\n\t\t\t\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t decode_putfh_maxsz + \\\n\t\t\t\t decode_open_confirm_maxsz)\n#define NFS4_enc_open_noattr_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\t\tencode_sequence_maxsz + \\\n\t\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\t\tencode_open_maxsz + \\\n\t\t\t\t\tencode_access_maxsz + \\\n\t\t\t\t\tencode_getattr_maxsz + \\\n\t\t\t\t\tencode_layoutget_maxsz)\n#define NFS4_dec_open_noattr_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\t\tdecode_open_maxsz + \\\n\t\t\t\t\tdecode_access_maxsz + \\\n\t\t\t\t\tdecode_getattr_maxsz + \\\n\t\t\t\t\tdecode_layoutget_maxsz)\n#define NFS4_enc_open_downgrade_sz \\\n\t\t\t\t(compound_encode_hdr_maxsz + \\\n\t\t\t\t encode_sequence_maxsz + \\\n\t\t\t\t encode_putfh_maxsz + \\\n\t\t\t\t encode_layoutreturn_maxsz + \\\n\t\t\t\t encode_open_downgrade_maxsz)\n#define NFS4_dec_open_downgrade_sz \\\n\t\t\t\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t decode_sequence_maxsz + \\\n\t\t\t\t decode_putfh_maxsz + \\\n\t\t\t\t decode_layoutreturn_maxsz + \\\n\t\t\t\t decode_open_downgrade_maxsz)\n#define NFS4_enc_close_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\t encode_sequence_maxsz + \\\n\t\t\t\t encode_putfh_maxsz + \\\n\t\t\t\t encode_layoutreturn_maxsz + \\\n\t\t\t\t encode_close_maxsz + \\\n\t\t\t\t encode_getattr_maxsz)\n#define NFS4_dec_close_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t decode_sequence_maxsz + \\\n\t\t\t\t decode_putfh_maxsz + \\\n\t\t\t\t decode_layoutreturn_maxsz + \\\n\t\t\t\t decode_close_maxsz + \\\n\t\t\t\t decode_getattr_maxsz)\n#define NFS4_enc_setattr_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\t encode_sequence_maxsz + \\\n\t\t\t\t encode_putfh_maxsz + \\\n\t\t\t\t encode_setattr_maxsz + \\\n\t\t\t\t encode_getattr_maxsz)\n#define NFS4_dec_setattr_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t decode_sequence_maxsz + \\\n\t\t\t\t decode_putfh_maxsz + \\\n\t\t\t\t decode_setattr_maxsz + \\\n\t\t\t\t decode_getattr_maxsz)\n#define NFS4_enc_fsinfo_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_sequence_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_fsinfo_maxsz)\n#define NFS4_dec_fsinfo_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_fsinfo_maxsz)\n#define NFS4_enc_renew_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_renew_maxsz)\n#define NFS4_dec_renew_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_renew_maxsz)\n#define NFS4_enc_setclientid_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_setclientid_maxsz)\n#define NFS4_dec_setclientid_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_setclientid_maxsz)\n#define NFS4_enc_setclientid_confirm_sz \\\n\t\t\t\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_setclientid_confirm_maxsz)\n#define NFS4_dec_setclientid_confirm_sz \\\n\t\t\t\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_setclientid_confirm_maxsz)\n#define NFS4_enc_lock_sz        (compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_sequence_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_lock_maxsz)\n#define NFS4_dec_lock_sz        (compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_lock_maxsz)\n#define NFS4_enc_lockt_sz       (compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_sequence_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_lockt_maxsz)\n#define NFS4_dec_lockt_sz       (compound_decode_hdr_maxsz + \\\n\t\t\t\t decode_sequence_maxsz + \\\n\t\t\t\t decode_putfh_maxsz + \\\n\t\t\t\t decode_lockt_maxsz)\n#define NFS4_enc_locku_sz       (compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_sequence_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_locku_maxsz)\n#define NFS4_dec_locku_sz       (compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_locku_maxsz)\n#define NFS4_enc_release_lockowner_sz \\\n\t\t\t\t(compound_encode_hdr_maxsz + \\\n\t\t\t\t encode_lockowner_maxsz)\n#define NFS4_dec_release_lockowner_sz \\\n\t\t\t\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t decode_lockowner_maxsz)\n#define NFS4_enc_access_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_sequence_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_access_maxsz + \\\n\t\t\t\tencode_getattr_maxsz)\n#define NFS4_dec_access_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_access_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz)\n#define NFS4_enc_getattr_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_sequence_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_getattr_maxsz + \\\n\t\t\t\tencode_renew_maxsz)\n#define NFS4_dec_getattr_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz + \\\n\t\t\t\tdecode_renew_maxsz)\n#define NFS4_enc_lookup_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_sequence_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_lookup_maxsz + \\\n\t\t\t\tencode_getattr_maxsz + \\\n\t\t\t\tencode_getfh_maxsz)\n#define NFS4_dec_lookup_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_lookup_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz + \\\n\t\t\t\tdecode_getfh_maxsz)\n#define NFS4_enc_lookupp_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_sequence_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_lookupp_maxsz + \\\n\t\t\t\tencode_getattr_maxsz + \\\n\t\t\t\tencode_getfh_maxsz)\n#define NFS4_dec_lookupp_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_lookupp_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz + \\\n\t\t\t\tdecode_getfh_maxsz)\n#define NFS4_enc_lookup_root_sz (compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_sequence_maxsz + \\\n\t\t\t\tencode_putrootfh_maxsz + \\\n\t\t\t\tencode_getattr_maxsz + \\\n\t\t\t\tencode_getfh_maxsz)\n#define NFS4_dec_lookup_root_sz (compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\tdecode_putrootfh_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz + \\\n\t\t\t\tdecode_getfh_maxsz)\n#define NFS4_enc_remove_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_sequence_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_remove_maxsz)\n#define NFS4_dec_remove_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_remove_maxsz)\n#define NFS4_enc_rename_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_sequence_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_savefh_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_rename_maxsz)\n#define NFS4_dec_rename_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_savefh_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_rename_maxsz)\n#define NFS4_enc_link_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_sequence_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_savefh_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_link_maxsz + \\\n\t\t\t\tencode_restorefh_maxsz + \\\n\t\t\t\tencode_getattr_maxsz)\n#define NFS4_dec_link_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_savefh_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_link_maxsz + \\\n\t\t\t\tdecode_restorefh_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz)\n#define NFS4_enc_symlink_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_sequence_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_symlink_maxsz + \\\n\t\t\t\tencode_getattr_maxsz + \\\n\t\t\t\tencode_getfh_maxsz)\n#define NFS4_dec_symlink_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_symlink_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz + \\\n\t\t\t\tdecode_getfh_maxsz)\n#define NFS4_enc_create_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_sequence_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_create_maxsz + \\\n\t\t\t\tencode_getfh_maxsz + \\\n\t\t\t\tencode_getattr_maxsz)\n#define NFS4_dec_create_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_create_maxsz + \\\n\t\t\t\tdecode_getfh_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz)\n#define NFS4_enc_pathconf_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_sequence_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_getattr_maxsz)\n#define NFS4_dec_pathconf_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz)\n#define NFS4_enc_statfs_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_sequence_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_statfs_maxsz)\n#define NFS4_dec_statfs_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_statfs_maxsz)\n#define NFS4_enc_server_caps_sz (compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_sequence_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_getattr_maxsz)\n#define NFS4_dec_server_caps_sz (compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz)\n#define NFS4_enc_delegreturn_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_sequence_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_layoutreturn_maxsz + \\\n\t\t\t\tencode_delegreturn_maxsz + \\\n\t\t\t\tencode_getattr_maxsz)\n#define NFS4_dec_delegreturn_sz (compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_layoutreturn_maxsz + \\\n\t\t\t\tdecode_delegreturn_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz)\n#define NFS4_enc_getacl_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_sequence_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_getacl_maxsz)\n#define NFS4_dec_getacl_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_getacl_maxsz)\n#define NFS4_enc_setacl_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_sequence_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_setacl_maxsz)\n#define NFS4_dec_setacl_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_setacl_maxsz)\n#define NFS4_enc_fs_locations_sz \\\n\t\t\t\t(compound_encode_hdr_maxsz + \\\n\t\t\t\t encode_sequence_maxsz + \\\n\t\t\t\t encode_putfh_maxsz + \\\n\t\t\t\t encode_lookup_maxsz + \\\n\t\t\t\t encode_fs_locations_maxsz + \\\n\t\t\t\t encode_renew_maxsz)\n#define NFS4_dec_fs_locations_sz \\\n\t\t\t\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t decode_sequence_maxsz + \\\n\t\t\t\t decode_putfh_maxsz + \\\n\t\t\t\t decode_lookup_maxsz + \\\n\t\t\t\t decode_fs_locations_maxsz + \\\n\t\t\t\t decode_renew_maxsz)\n#define NFS4_enc_secinfo_sz \t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_sequence_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_secinfo_maxsz)\n#define NFS4_dec_secinfo_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_secinfo_maxsz)\n#define NFS4_enc_fsid_present_sz \\\n\t\t\t\t(compound_encode_hdr_maxsz + \\\n\t\t\t\t encode_sequence_maxsz + \\\n\t\t\t\t encode_putfh_maxsz + \\\n\t\t\t\t encode_getfh_maxsz + \\\n\t\t\t\t encode_renew_maxsz)\n#define NFS4_dec_fsid_present_sz \\\n\t\t\t\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t decode_sequence_maxsz + \\\n\t\t\t\t decode_putfh_maxsz + \\\n\t\t\t\t decode_getfh_maxsz + \\\n\t\t\t\t decode_renew_maxsz)\n#if defined(CONFIG_NFS_V4_1)\n#define NFS4_enc_bind_conn_to_session_sz \\\n\t\t\t\t(compound_encode_hdr_maxsz + \\\n\t\t\t\t encode_bind_conn_to_session_maxsz)\n#define NFS4_dec_bind_conn_to_session_sz \\\n\t\t\t\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t decode_bind_conn_to_session_maxsz)\n#define NFS4_enc_exchange_id_sz \\\n\t\t\t\t(compound_encode_hdr_maxsz + \\\n\t\t\t\t encode_exchange_id_maxsz)\n#define NFS4_dec_exchange_id_sz \\\n\t\t\t\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t decode_exchange_id_maxsz)\n#define NFS4_enc_create_session_sz \\\n\t\t\t\t(compound_encode_hdr_maxsz + \\\n\t\t\t\t encode_create_session_maxsz)\n#define NFS4_dec_create_session_sz \\\n\t\t\t\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t decode_create_session_maxsz)\n#define NFS4_enc_destroy_session_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\t\t encode_destroy_session_maxsz)\n#define NFS4_dec_destroy_session_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t\t decode_destroy_session_maxsz)\n#define NFS4_enc_destroy_clientid_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\t\t encode_destroy_clientid_maxsz)\n#define NFS4_dec_destroy_clientid_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t\t decode_destroy_clientid_maxsz)\n#define NFS4_enc_sequence_sz \\\n\t\t\t\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t encode_sequence_maxsz)\n#define NFS4_dec_sequence_sz \\\n\t\t\t\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t decode_sequence_maxsz)\n#endif\n#define NFS4_enc_get_lease_time_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\t\t encode_sequence_maxsz + \\\n\t\t\t\t\t encode_putrootfh_maxsz + \\\n\t\t\t\t\t encode_fsinfo_maxsz)\n#define NFS4_dec_get_lease_time_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t\t decode_sequence_maxsz + \\\n\t\t\t\t\t decode_putrootfh_maxsz + \\\n\t\t\t\t\t decode_fsinfo_maxsz)\n#if defined(CONFIG_NFS_V4_1)\n#define NFS4_enc_reclaim_complete_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\t\t encode_sequence_maxsz + \\\n\t\t\t\t\t encode_reclaim_complete_maxsz)\n#define NFS4_dec_reclaim_complete_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t\t decode_sequence_maxsz + \\\n\t\t\t\t\t decode_reclaim_complete_maxsz)\n#define NFS4_enc_getdeviceinfo_sz (compound_encode_hdr_maxsz +    \\\n\t\t\t\tencode_sequence_maxsz +\\\n\t\t\t\tencode_getdeviceinfo_maxsz)\n#define NFS4_dec_getdeviceinfo_sz (compound_decode_hdr_maxsz +    \\\n\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\tdecode_getdeviceinfo_maxsz)\n#define NFS4_enc_layoutget_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_sequence_maxsz + \\\n\t\t\t\tencode_putfh_maxsz +        \\\n\t\t\t\tencode_layoutget_maxsz)\n#define NFS4_dec_layoutget_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz +        \\\n\t\t\t\tdecode_layoutget_maxsz)\n#define NFS4_enc_layoutcommit_sz (compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_sequence_maxsz +\\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_layoutcommit_maxsz + \\\n\t\t\t\tencode_getattr_maxsz)\n#define NFS4_dec_layoutcommit_sz (compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_layoutcommit_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz)\n#define NFS4_enc_layoutreturn_sz (compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_sequence_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_layoutreturn_maxsz)\n#define NFS4_dec_layoutreturn_sz (compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_layoutreturn_maxsz)\n#define NFS4_enc_secinfo_no_name_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\t\tencode_sequence_maxsz + \\\n\t\t\t\t\tencode_putrootfh_maxsz +\\\n\t\t\t\t\tencode_secinfo_no_name_maxsz)\n#define NFS4_dec_secinfo_no_name_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\t\tdecode_putrootfh_maxsz + \\\n\t\t\t\t\tdecode_secinfo_no_name_maxsz)\n#define NFS4_enc_test_stateid_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\t\t encode_sequence_maxsz + \\\n\t\t\t\t\t encode_test_stateid_maxsz)\n#define NFS4_dec_test_stateid_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t\t decode_sequence_maxsz + \\\n\t\t\t\t\t decode_test_stateid_maxsz)\n#define NFS4_enc_free_stateid_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\t\t encode_sequence_maxsz + \\\n\t\t\t\t\t encode_free_stateid_maxsz)\n#define NFS4_dec_free_stateid_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t\t decode_sequence_maxsz + \\\n\t\t\t\t\t decode_free_stateid_maxsz)\n\nconst u32 nfs41_maxwrite_overhead = ((RPC_MAX_HEADER_WITH_AUTH +\n\t\t\t\t      compound_encode_hdr_maxsz +\n\t\t\t\t      encode_sequence_maxsz +\n\t\t\t\t      encode_putfh_maxsz +\n\t\t\t\t      encode_getattr_maxsz) *\n\t\t\t\t     XDR_UNIT);\n\nconst u32 nfs41_maxread_overhead = ((RPC_MAX_HEADER_WITH_AUTH +\n\t\t\t\t     compound_decode_hdr_maxsz +\n\t\t\t\t     decode_sequence_maxsz +\n\t\t\t\t     decode_putfh_maxsz) *\n\t\t\t\t    XDR_UNIT);\n\nconst u32 nfs41_maxgetdevinfo_overhead = ((RPC_MAX_REPHEADER_WITH_AUTH +\n\t\t\t\t\t   compound_decode_hdr_maxsz +\n\t\t\t\t\t   decode_sequence_maxsz) *\n\t\t\t\t\t  XDR_UNIT);\nEXPORT_SYMBOL_GPL(nfs41_maxgetdevinfo_overhead);\n#endif  \n\nstatic const umode_t nfs_type2fmt[] = {\n\t[NF4BAD] = 0,\n\t[NF4REG] = S_IFREG,\n\t[NF4DIR] = S_IFDIR,\n\t[NF4BLK] = S_IFBLK,\n\t[NF4CHR] = S_IFCHR,\n\t[NF4LNK] = S_IFLNK,\n\t[NF4SOCK] = S_IFSOCK,\n\t[NF4FIFO] = S_IFIFO,\n\t[NF4ATTRDIR] = 0,\n\t[NF4NAMEDATTR] = 0,\n};\n\nstruct compound_hdr {\n\tint32_t\t\tstatus;\n\tuint32_t\tnops;\n\t__be32 *\tnops_p;\n\tuint32_t\ttaglen;\n\tchar *\t\ttag;\n\tuint32_t\treplen;\t\t \n\tu32\t\tminorversion;\n};\n\nstatic __be32 *reserve_space(struct xdr_stream *xdr, size_t nbytes)\n{\n\t__be32 *p = xdr_reserve_space(xdr, nbytes);\n\tBUG_ON(!p);\n\treturn p;\n}\n\nstatic void encode_opaque_fixed(struct xdr_stream *xdr, const void *buf, size_t len)\n{\n\tWARN_ON_ONCE(xdr_stream_encode_opaque_fixed(xdr, buf, len) < 0);\n}\n\nstatic void encode_string(struct xdr_stream *xdr, unsigned int len, const char *str)\n{\n\tWARN_ON_ONCE(xdr_stream_encode_opaque(xdr, str, len) < 0);\n}\n\nstatic void encode_uint32(struct xdr_stream *xdr, u32 n)\n{\n\tWARN_ON_ONCE(xdr_stream_encode_u32(xdr, n) < 0);\n}\n\nstatic void encode_uint64(struct xdr_stream *xdr, u64 n)\n{\n\tWARN_ON_ONCE(xdr_stream_encode_u64(xdr, n) < 0);\n}\n\nstatic ssize_t xdr_encode_bitmap4(struct xdr_stream *xdr,\n\t\tconst __u32 *bitmap, size_t len)\n{\n\tssize_t ret;\n\n\t \n\twhile (len > 0 && bitmap[len-1] == 0)\n\t\tlen--;\n\tret = xdr_stream_encode_uint32_array(xdr, bitmap, len);\n\tif (WARN_ON_ONCE(ret < 0))\n\t\treturn ret;\n\treturn len;\n}\n\nstatic size_t mask_bitmap4(const __u32 *bitmap, const __u32 *mask,\n\t\t__u32 *res, size_t len)\n{\n\tsize_t i;\n\t__u32 tmp;\n\n\twhile (len > 0 && (bitmap[len-1] == 0 || mask[len-1] == 0))\n\t\tlen--;\n\tfor (i = len; i-- > 0;) {\n\t\ttmp = bitmap[i] & mask[i];\n\t\tres[i] = tmp;\n\t}\n\treturn len;\n}\n\nstatic void encode_nfs4_seqid(struct xdr_stream *xdr,\n\t\tconst struct nfs_seqid *seqid)\n{\n\tif (seqid != NULL)\n\t\tencode_uint32(xdr, seqid->sequence->counter);\n\telse\n\t\tencode_uint32(xdr, 0);\n}\n\nstatic void encode_compound_hdr(struct xdr_stream *xdr,\n\t\t\t\tstruct rpc_rqst *req,\n\t\t\t\tstruct compound_hdr *hdr)\n{\n\t__be32 *p;\n\n\t \n\thdr->replen = 3 + hdr->taglen;\n\n\tWARN_ON_ONCE(hdr->taglen > NFS4_MAXTAGLEN);\n\tencode_string(xdr, hdr->taglen, hdr->tag);\n\tp = reserve_space(xdr, 8);\n\t*p++ = cpu_to_be32(hdr->minorversion);\n\thdr->nops_p = p;\n\t*p = cpu_to_be32(hdr->nops);\n}\n\nstatic void encode_op_hdr(struct xdr_stream *xdr, enum nfs_opnum4 op,\n\t\tuint32_t replen,\n\t\tstruct compound_hdr *hdr)\n{\n\tencode_uint32(xdr, op);\n\thdr->nops++;\n\thdr->replen += replen;\n}\n\nstatic void encode_nops(struct compound_hdr *hdr)\n{\n\tWARN_ON_ONCE(hdr->nops > NFS4_MAX_OPS);\n\t*hdr->nops_p = htonl(hdr->nops);\n}\n\nstatic void encode_nfs4_stateid(struct xdr_stream *xdr, const nfs4_stateid *stateid)\n{\n\tencode_opaque_fixed(xdr, stateid, NFS4_STATEID_SIZE);\n}\n\nstatic void encode_nfs4_verifier(struct xdr_stream *xdr, const nfs4_verifier *verf)\n{\n\tencode_opaque_fixed(xdr, verf->data, NFS4_VERIFIER_SIZE);\n}\n\nstatic __be32 *\nxdr_encode_nfstime4(__be32 *p, const struct timespec64 *t)\n{\n\tp = xdr_encode_hyper(p, t->tv_sec);\n\t*p++ = cpu_to_be32(t->tv_nsec);\n\treturn p;\n}\n\nstatic void encode_attrs(struct xdr_stream *xdr, const struct iattr *iap,\n\t\t\t\tconst struct nfs4_label *label,\n\t\t\t\tconst umode_t *umask,\n\t\t\t\tconst struct nfs_server *server,\n\t\t\t\tconst uint32_t attrmask[])\n{\n\tchar owner_name[IDMAP_NAMESZ];\n\tchar owner_group[IDMAP_NAMESZ];\n\tint owner_namelen = 0;\n\tint owner_grouplen = 0;\n\t__be32 *p;\n\tuint32_t len = 0;\n\tuint32_t bmval[3] = { 0 };\n\n\t \n\tif ((iap->ia_valid & ATTR_SIZE) && (attrmask[0] & FATTR4_WORD0_SIZE)) {\n\t\tbmval[0] |= FATTR4_WORD0_SIZE;\n\t\tlen += 8;\n\t}\n\tif (iap->ia_valid & ATTR_MODE) {\n\t\tif (umask && (attrmask[2] & FATTR4_WORD2_MODE_UMASK)) {\n\t\t\tbmval[2] |= FATTR4_WORD2_MODE_UMASK;\n\t\t\tlen += 8;\n\t\t} else if (attrmask[1] & FATTR4_WORD1_MODE) {\n\t\t\tbmval[1] |= FATTR4_WORD1_MODE;\n\t\t\tlen += 4;\n\t\t}\n\t}\n\tif ((iap->ia_valid & ATTR_UID) && (attrmask[1] & FATTR4_WORD1_OWNER)) {\n\t\towner_namelen = nfs_map_uid_to_name(server, iap->ia_uid, owner_name, IDMAP_NAMESZ);\n\t\tif (owner_namelen < 0) {\n\t\t\tdprintk(\"nfs: couldn't resolve uid %d to string\\n\",\n\t\t\t\t\tfrom_kuid(&init_user_ns, iap->ia_uid));\n\t\t\t \n\t\t\tstrcpy(owner_name, \"nobody\");\n\t\t\towner_namelen = sizeof(\"nobody\") - 1;\n\t\t\t \n\t\t}\n\t\tbmval[1] |= FATTR4_WORD1_OWNER;\n\t\tlen += 4 + (XDR_QUADLEN(owner_namelen) << 2);\n\t}\n\tif ((iap->ia_valid & ATTR_GID) &&\n\t   (attrmask[1] & FATTR4_WORD1_OWNER_GROUP)) {\n\t\towner_grouplen = nfs_map_gid_to_group(server, iap->ia_gid, owner_group, IDMAP_NAMESZ);\n\t\tif (owner_grouplen < 0) {\n\t\t\tdprintk(\"nfs: couldn't resolve gid %d to string\\n\",\n\t\t\t\t\tfrom_kgid(&init_user_ns, iap->ia_gid));\n\t\t\tstrcpy(owner_group, \"nobody\");\n\t\t\towner_grouplen = sizeof(\"nobody\") - 1;\n\t\t\t \n\t\t}\n\t\tbmval[1] |= FATTR4_WORD1_OWNER_GROUP;\n\t\tlen += 4 + (XDR_QUADLEN(owner_grouplen) << 2);\n\t}\n\tif (attrmask[1] & FATTR4_WORD1_TIME_ACCESS_SET) {\n\t\tif (iap->ia_valid & ATTR_ATIME_SET) {\n\t\t\tbmval[1] |= FATTR4_WORD1_TIME_ACCESS_SET;\n\t\t\tlen += 4 + (nfstime4_maxsz << 2);\n\t\t} else if (iap->ia_valid & ATTR_ATIME) {\n\t\t\tbmval[1] |= FATTR4_WORD1_TIME_ACCESS_SET;\n\t\t\tlen += 4;\n\t\t}\n\t}\n\tif (attrmask[1] & FATTR4_WORD1_TIME_MODIFY_SET) {\n\t\tif (iap->ia_valid & ATTR_MTIME_SET) {\n\t\t\tbmval[1] |= FATTR4_WORD1_TIME_MODIFY_SET;\n\t\t\tlen += 4 + (nfstime4_maxsz << 2);\n\t\t} else if (iap->ia_valid & ATTR_MTIME) {\n\t\t\tbmval[1] |= FATTR4_WORD1_TIME_MODIFY_SET;\n\t\t\tlen += 4;\n\t\t}\n\t}\n\n\tif (label && (attrmask[2] & FATTR4_WORD2_SECURITY_LABEL)) {\n\t\tlen += 4 + 4 + 4 + (XDR_QUADLEN(label->len) << 2);\n\t\tbmval[2] |= FATTR4_WORD2_SECURITY_LABEL;\n\t}\n\n\txdr_encode_bitmap4(xdr, bmval, ARRAY_SIZE(bmval));\n\txdr_stream_encode_opaque_inline(xdr, (void **)&p, len);\n\n\tif (bmval[0] & FATTR4_WORD0_SIZE)\n\t\tp = xdr_encode_hyper(p, iap->ia_size);\n\tif (bmval[1] & FATTR4_WORD1_MODE)\n\t\t*p++ = cpu_to_be32(iap->ia_mode & S_IALLUGO);\n\tif (bmval[1] & FATTR4_WORD1_OWNER)\n\t\tp = xdr_encode_opaque(p, owner_name, owner_namelen);\n\tif (bmval[1] & FATTR4_WORD1_OWNER_GROUP)\n\t\tp = xdr_encode_opaque(p, owner_group, owner_grouplen);\n\tif (bmval[1] & FATTR4_WORD1_TIME_ACCESS_SET) {\n\t\tif (iap->ia_valid & ATTR_ATIME_SET) {\n\t\t\t*p++ = cpu_to_be32(NFS4_SET_TO_CLIENT_TIME);\n\t\t\tp = xdr_encode_nfstime4(p, &iap->ia_atime);\n\t\t} else\n\t\t\t*p++ = cpu_to_be32(NFS4_SET_TO_SERVER_TIME);\n\t}\n\tif (bmval[1] & FATTR4_WORD1_TIME_MODIFY_SET) {\n\t\tif (iap->ia_valid & ATTR_MTIME_SET) {\n\t\t\t*p++ = cpu_to_be32(NFS4_SET_TO_CLIENT_TIME);\n\t\t\tp = xdr_encode_nfstime4(p, &iap->ia_mtime);\n\t\t} else\n\t\t\t*p++ = cpu_to_be32(NFS4_SET_TO_SERVER_TIME);\n\t}\n\tif (label && (bmval[2] & FATTR4_WORD2_SECURITY_LABEL)) {\n\t\t*p++ = cpu_to_be32(label->lfs);\n\t\t*p++ = cpu_to_be32(label->pi);\n\t\t*p++ = cpu_to_be32(label->len);\n\t\tp = xdr_encode_opaque_fixed(p, label->label, label->len);\n\t}\n\tif (bmval[2] & FATTR4_WORD2_MODE_UMASK) {\n\t\t*p++ = cpu_to_be32(iap->ia_mode & S_IALLUGO);\n\t\t*p++ = cpu_to_be32(*umask);\n\t}\n\n \n}\n\nstatic void encode_access(struct xdr_stream *xdr, u32 access, struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_ACCESS, decode_access_maxsz, hdr);\n\tencode_uint32(xdr, access);\n}\n\nstatic void encode_close(struct xdr_stream *xdr, const struct nfs_closeargs *arg, struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_CLOSE, decode_close_maxsz, hdr);\n\tencode_nfs4_seqid(xdr, arg->seqid);\n\tencode_nfs4_stateid(xdr, &arg->stateid);\n}\n\nstatic void encode_commit(struct xdr_stream *xdr, const struct nfs_commitargs *args, struct compound_hdr *hdr)\n{\n\t__be32 *p;\n\n\tencode_op_hdr(xdr, OP_COMMIT, decode_commit_maxsz, hdr);\n\tp = reserve_space(xdr, 12);\n\tp = xdr_encode_hyper(p, args->offset);\n\t*p = cpu_to_be32(args->count);\n}\n\nstatic void encode_create(struct xdr_stream *xdr, const struct nfs4_create_arg *create, struct compound_hdr *hdr)\n{\n\t__be32 *p;\n\n\tencode_op_hdr(xdr, OP_CREATE, decode_create_maxsz, hdr);\n\tencode_uint32(xdr, create->ftype);\n\n\tswitch (create->ftype) {\n\tcase NF4LNK:\n\t\tp = reserve_space(xdr, 4);\n\t\t*p = cpu_to_be32(create->u.symlink.len);\n\t\txdr_write_pages(xdr, create->u.symlink.pages, 0,\n\t\t\t\tcreate->u.symlink.len);\n\t\txdr->buf->flags |= XDRBUF_WRITE;\n\t\tbreak;\n\n\tcase NF4BLK: case NF4CHR:\n\t\tp = reserve_space(xdr, 8);\n\t\t*p++ = cpu_to_be32(create->u.device.specdata1);\n\t\t*p = cpu_to_be32(create->u.device.specdata2);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tencode_string(xdr, create->name->len, create->name->name);\n\tencode_attrs(xdr, create->attrs, create->label, &create->umask,\n\t\t\tcreate->server, create->server->attr_bitmask);\n}\n\nstatic void encode_getattr(struct xdr_stream *xdr,\n\t\tconst __u32 *bitmap, const __u32 *mask, size_t len,\n\t\tstruct compound_hdr *hdr)\n{\n\t__u32 masked_bitmap[nfs4_fattr_bitmap_maxsz];\n\n\tencode_op_hdr(xdr, OP_GETATTR, decode_getattr_maxsz, hdr);\n\tif (mask) {\n\t\tif (WARN_ON_ONCE(len > ARRAY_SIZE(masked_bitmap)))\n\t\t\tlen = ARRAY_SIZE(masked_bitmap);\n\t\tlen = mask_bitmap4(bitmap, mask, masked_bitmap, len);\n\t\tbitmap = masked_bitmap;\n\t}\n\txdr_encode_bitmap4(xdr, bitmap, len);\n}\n\nstatic void encode_getfattr(struct xdr_stream *xdr, const u32* bitmask, struct compound_hdr *hdr)\n{\n\tencode_getattr(xdr, nfs4_fattr_bitmap, bitmask,\n\t\t\tARRAY_SIZE(nfs4_fattr_bitmap), hdr);\n}\n\nstatic void encode_getfattr_open(struct xdr_stream *xdr, const u32 *bitmask,\n\t\t\t\t const u32 *open_bitmap,\n\t\t\t\t struct compound_hdr *hdr)\n{\n\tencode_getattr(xdr, open_bitmap, bitmask, 3, hdr);\n}\n\nstatic void encode_fsinfo(struct xdr_stream *xdr, const u32* bitmask, struct compound_hdr *hdr)\n{\n\tencode_getattr(xdr, nfs4_fsinfo_bitmap, bitmask,\n\t\t\tARRAY_SIZE(nfs4_fsinfo_bitmap), hdr);\n}\n\nstatic void encode_fs_locations(struct xdr_stream *xdr, const u32* bitmask, struct compound_hdr *hdr)\n{\n\tencode_getattr(xdr, nfs4_fs_locations_bitmap, bitmask,\n\t\t\tARRAY_SIZE(nfs4_fs_locations_bitmap), hdr);\n}\n\nstatic void encode_getfh(struct xdr_stream *xdr, struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_GETFH, decode_getfh_maxsz, hdr);\n}\n\nstatic void encode_link(struct xdr_stream *xdr, const struct qstr *name, struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_LINK, decode_link_maxsz, hdr);\n\tencode_string(xdr, name->len, name->name);\n}\n\nstatic inline int nfs4_lock_type(struct file_lock *fl, int block)\n{\n\tif (fl->fl_type == F_RDLCK)\n\t\treturn block ? NFS4_READW_LT : NFS4_READ_LT;\n\treturn block ? NFS4_WRITEW_LT : NFS4_WRITE_LT;\n}\n\nstatic inline uint64_t nfs4_lock_length(struct file_lock *fl)\n{\n\tif (fl->fl_end == OFFSET_MAX)\n\t\treturn ~(uint64_t)0;\n\treturn fl->fl_end - fl->fl_start + 1;\n}\n\nstatic void encode_lockowner(struct xdr_stream *xdr, const struct nfs_lowner *lowner)\n{\n\t__be32 *p;\n\n\tp = reserve_space(xdr, 32);\n\tp = xdr_encode_hyper(p, lowner->clientid);\n\t*p++ = cpu_to_be32(20);\n\tp = xdr_encode_opaque_fixed(p, \"lock id:\", 8);\n\t*p++ = cpu_to_be32(lowner->s_dev);\n\txdr_encode_hyper(p, lowner->id);\n}\n\n \nstatic void encode_lock(struct xdr_stream *xdr, const struct nfs_lock_args *args, struct compound_hdr *hdr)\n{\n\t__be32 *p;\n\n\tencode_op_hdr(xdr, OP_LOCK, decode_lock_maxsz, hdr);\n\tp = reserve_space(xdr, 28);\n\t*p++ = cpu_to_be32(nfs4_lock_type(args->fl, args->block));\n\t*p++ = cpu_to_be32(args->reclaim);\n\tp = xdr_encode_hyper(p, args->fl->fl_start);\n\tp = xdr_encode_hyper(p, nfs4_lock_length(args->fl));\n\t*p = cpu_to_be32(args->new_lock_owner);\n\tif (args->new_lock_owner){\n\t\tencode_nfs4_seqid(xdr, args->open_seqid);\n\t\tencode_nfs4_stateid(xdr, &args->open_stateid);\n\t\tencode_nfs4_seqid(xdr, args->lock_seqid);\n\t\tencode_lockowner(xdr, &args->lock_owner);\n\t}\n\telse {\n\t\tencode_nfs4_stateid(xdr, &args->lock_stateid);\n\t\tencode_nfs4_seqid(xdr, args->lock_seqid);\n\t}\n}\n\nstatic void encode_lockt(struct xdr_stream *xdr, const struct nfs_lockt_args *args, struct compound_hdr *hdr)\n{\n\t__be32 *p;\n\n\tencode_op_hdr(xdr, OP_LOCKT, decode_lockt_maxsz, hdr);\n\tp = reserve_space(xdr, 20);\n\t*p++ = cpu_to_be32(nfs4_lock_type(args->fl, 0));\n\tp = xdr_encode_hyper(p, args->fl->fl_start);\n\tp = xdr_encode_hyper(p, nfs4_lock_length(args->fl));\n\tencode_lockowner(xdr, &args->lock_owner);\n}\n\nstatic void encode_locku(struct xdr_stream *xdr, const struct nfs_locku_args *args, struct compound_hdr *hdr)\n{\n\t__be32 *p;\n\n\tencode_op_hdr(xdr, OP_LOCKU, decode_locku_maxsz, hdr);\n\tencode_uint32(xdr, nfs4_lock_type(args->fl, 0));\n\tencode_nfs4_seqid(xdr, args->seqid);\n\tencode_nfs4_stateid(xdr, &args->stateid);\n\tp = reserve_space(xdr, 16);\n\tp = xdr_encode_hyper(p, args->fl->fl_start);\n\txdr_encode_hyper(p, nfs4_lock_length(args->fl));\n}\n\nstatic void encode_release_lockowner(struct xdr_stream *xdr, const struct nfs_lowner *lowner, struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_RELEASE_LOCKOWNER, decode_release_lockowner_maxsz, hdr);\n\tencode_lockowner(xdr, lowner);\n}\n\nstatic void encode_lookup(struct xdr_stream *xdr, const struct qstr *name, struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_LOOKUP, decode_lookup_maxsz, hdr);\n\tencode_string(xdr, name->len, name->name);\n}\n\nstatic void encode_lookupp(struct xdr_stream *xdr, struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_LOOKUPP, decode_lookupp_maxsz, hdr);\n}\n\nstatic void encode_share_access(struct xdr_stream *xdr, u32 share_access)\n{\n\t__be32 *p;\n\n\tp = reserve_space(xdr, 8);\n\t*p++ = cpu_to_be32(share_access);\n\t*p = cpu_to_be32(0);\t\t \n}\n\nstatic inline void encode_openhdr(struct xdr_stream *xdr, const struct nfs_openargs *arg)\n{\n\t__be32 *p;\n  \n\tencode_nfs4_seqid(xdr, arg->seqid);\n\tencode_share_access(xdr, arg->share_access);\n\tp = reserve_space(xdr, 36);\n\tp = xdr_encode_hyper(p, arg->clientid);\n\t*p++ = cpu_to_be32(24);\n\tp = xdr_encode_opaque_fixed(p, \"open id:\", 8);\n\t*p++ = cpu_to_be32(arg->server->s_dev);\n\t*p++ = cpu_to_be32(arg->id.uniquifier);\n\txdr_encode_hyper(p, arg->id.create_time);\n}\n\nstatic inline void encode_createmode(struct xdr_stream *xdr, const struct nfs_openargs *arg)\n{\n\t__be32 *p;\n\n\tp = reserve_space(xdr, 4);\n\tswitch(arg->createmode) {\n\tcase NFS4_CREATE_UNCHECKED:\n\t\t*p = cpu_to_be32(NFS4_CREATE_UNCHECKED);\n\t\tencode_attrs(xdr, arg->u.attrs, arg->label, &arg->umask,\n\t\t\t\targ->server, arg->server->attr_bitmask);\n\t\tbreak;\n\tcase NFS4_CREATE_GUARDED:\n\t\t*p = cpu_to_be32(NFS4_CREATE_GUARDED);\n\t\tencode_attrs(xdr, arg->u.attrs, arg->label, &arg->umask,\n\t\t\t\targ->server, arg->server->attr_bitmask);\n\t\tbreak;\n\tcase NFS4_CREATE_EXCLUSIVE:\n\t\t*p = cpu_to_be32(NFS4_CREATE_EXCLUSIVE);\n\t\tencode_nfs4_verifier(xdr, &arg->u.verifier);\n\t\tbreak;\n\tcase NFS4_CREATE_EXCLUSIVE4_1:\n\t\t*p = cpu_to_be32(NFS4_CREATE_EXCLUSIVE4_1);\n\t\tencode_nfs4_verifier(xdr, &arg->u.verifier);\n\t\tencode_attrs(xdr, arg->u.attrs, arg->label, &arg->umask,\n\t\t\t\targ->server, arg->server->exclcreat_bitmask);\n\t}\n}\n\nstatic void encode_opentype(struct xdr_stream *xdr, const struct nfs_openargs *arg)\n{\n\t__be32 *p;\n\n\tp = reserve_space(xdr, 4);\n\tswitch (arg->open_flags & O_CREAT) {\n\tcase 0:\n\t\t*p = cpu_to_be32(NFS4_OPEN_NOCREATE);\n\t\tbreak;\n\tdefault:\n\t\t*p = cpu_to_be32(NFS4_OPEN_CREATE);\n\t\tencode_createmode(xdr, arg);\n\t}\n}\n\nstatic inline void encode_delegation_type(struct xdr_stream *xdr, fmode_t delegation_type)\n{\n\t__be32 *p;\n\n\tp = reserve_space(xdr, 4);\n\tswitch (delegation_type) {\n\tcase 0:\n\t\t*p = cpu_to_be32(NFS4_OPEN_DELEGATE_NONE);\n\t\tbreak;\n\tcase FMODE_READ:\n\t\t*p = cpu_to_be32(NFS4_OPEN_DELEGATE_READ);\n\t\tbreak;\n\tcase FMODE_WRITE|FMODE_READ:\n\t\t*p = cpu_to_be32(NFS4_OPEN_DELEGATE_WRITE);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}\n\nstatic inline void encode_claim_null(struct xdr_stream *xdr, const struct qstr *name)\n{\n\t__be32 *p;\n\n\tp = reserve_space(xdr, 4);\n\t*p = cpu_to_be32(NFS4_OPEN_CLAIM_NULL);\n\tencode_string(xdr, name->len, name->name);\n}\n\nstatic inline void encode_claim_previous(struct xdr_stream *xdr, fmode_t type)\n{\n\t__be32 *p;\n\n\tp = reserve_space(xdr, 4);\n\t*p = cpu_to_be32(NFS4_OPEN_CLAIM_PREVIOUS);\n\tencode_delegation_type(xdr, type);\n}\n\nstatic inline void encode_claim_delegate_cur(struct xdr_stream *xdr, const struct qstr *name, const nfs4_stateid *stateid)\n{\n\t__be32 *p;\n\n\tp = reserve_space(xdr, 4);\n\t*p = cpu_to_be32(NFS4_OPEN_CLAIM_DELEGATE_CUR);\n\tencode_nfs4_stateid(xdr, stateid);\n\tencode_string(xdr, name->len, name->name);\n}\n\nstatic inline void encode_claim_fh(struct xdr_stream *xdr)\n{\n\t__be32 *p;\n\n\tp = reserve_space(xdr, 4);\n\t*p = cpu_to_be32(NFS4_OPEN_CLAIM_FH);\n}\n\nstatic inline void encode_claim_delegate_cur_fh(struct xdr_stream *xdr, const nfs4_stateid *stateid)\n{\n\t__be32 *p;\n\n\tp = reserve_space(xdr, 4);\n\t*p = cpu_to_be32(NFS4_OPEN_CLAIM_DELEG_CUR_FH);\n\tencode_nfs4_stateid(xdr, stateid);\n}\n\nstatic void encode_open(struct xdr_stream *xdr, const struct nfs_openargs *arg, struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_OPEN, decode_open_maxsz, hdr);\n\tencode_openhdr(xdr, arg);\n\tencode_opentype(xdr, arg);\n\tswitch (arg->claim) {\n\tcase NFS4_OPEN_CLAIM_NULL:\n\t\tencode_claim_null(xdr, arg->name);\n\t\tbreak;\n\tcase NFS4_OPEN_CLAIM_PREVIOUS:\n\t\tencode_claim_previous(xdr, arg->u.delegation_type);\n\t\tbreak;\n\tcase NFS4_OPEN_CLAIM_DELEGATE_CUR:\n\t\tencode_claim_delegate_cur(xdr, arg->name, &arg->u.delegation);\n\t\tbreak;\n\tcase NFS4_OPEN_CLAIM_FH:\n\t\tencode_claim_fh(xdr);\n\t\tbreak;\n\tcase NFS4_OPEN_CLAIM_DELEG_CUR_FH:\n\t\tencode_claim_delegate_cur_fh(xdr, &arg->u.delegation);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}\n\nstatic void encode_open_confirm(struct xdr_stream *xdr, const struct nfs_open_confirmargs *arg, struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_OPEN_CONFIRM, decode_open_confirm_maxsz, hdr);\n\tencode_nfs4_stateid(xdr, arg->stateid);\n\tencode_nfs4_seqid(xdr, arg->seqid);\n}\n\nstatic void encode_open_downgrade(struct xdr_stream *xdr, const struct nfs_closeargs *arg, struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_OPEN_DOWNGRADE, decode_open_downgrade_maxsz, hdr);\n\tencode_nfs4_stateid(xdr, &arg->stateid);\n\tencode_nfs4_seqid(xdr, arg->seqid);\n\tencode_share_access(xdr, arg->share_access);\n}\n\nstatic void\nencode_putfh(struct xdr_stream *xdr, const struct nfs_fh *fh, struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_PUTFH, decode_putfh_maxsz, hdr);\n\tencode_string(xdr, fh->size, fh->data);\n}\n\nstatic void encode_putrootfh(struct xdr_stream *xdr, struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_PUTROOTFH, decode_putrootfh_maxsz, hdr);\n}\n\nstatic void encode_read(struct xdr_stream *xdr, const struct nfs_pgio_args *args,\n\t\t\tstruct compound_hdr *hdr)\n{\n\t__be32 *p;\n\n\tencode_op_hdr(xdr, OP_READ, decode_read_maxsz, hdr);\n\tencode_nfs4_stateid(xdr, &args->stateid);\n\n\tp = reserve_space(xdr, 12);\n\tp = xdr_encode_hyper(p, args->offset);\n\t*p = cpu_to_be32(args->count);\n}\n\nstatic void encode_readdir(struct xdr_stream *xdr, const struct nfs4_readdir_arg *readdir, struct rpc_rqst *req, struct compound_hdr *hdr)\n{\n\tuint32_t attrs[3] = {\n\t\tFATTR4_WORD0_RDATTR_ERROR,\n\t\tFATTR4_WORD1_MOUNTED_ON_FILEID,\n\t};\n\tuint32_t dircount = readdir->count;\n\tuint32_t maxcount = readdir->count;\n\t__be32 *p, verf[2];\n\tuint32_t attrlen = 0;\n\tunsigned int i;\n\n\tif (readdir->plus) {\n\t\tattrs[0] |= FATTR4_WORD0_TYPE|FATTR4_WORD0_CHANGE|FATTR4_WORD0_SIZE|\n\t\t\tFATTR4_WORD0_FSID|FATTR4_WORD0_FILEHANDLE|FATTR4_WORD0_FILEID;\n\t\tattrs[1] |= FATTR4_WORD1_MODE|FATTR4_WORD1_NUMLINKS|FATTR4_WORD1_OWNER|\n\t\t\tFATTR4_WORD1_OWNER_GROUP|FATTR4_WORD1_RAWDEV|\n\t\t\tFATTR4_WORD1_SPACE_USED|FATTR4_WORD1_TIME_ACCESS|\n\t\t\tFATTR4_WORD1_TIME_METADATA|FATTR4_WORD1_TIME_MODIFY;\n\t\tattrs[2] |= FATTR4_WORD2_SECURITY_LABEL;\n\t}\n\t \n\tif (!(readdir->bitmask[1] & FATTR4_WORD1_MOUNTED_ON_FILEID))\n\t\tattrs[0] |= FATTR4_WORD0_FILEID;\n\tfor (i = 0; i < ARRAY_SIZE(attrs); i++) {\n\t\tattrs[i] &= readdir->bitmask[i];\n\t\tif (attrs[i] != 0)\n\t\t\tattrlen = i+1;\n\t}\n\n\tencode_op_hdr(xdr, OP_READDIR, decode_readdir_maxsz, hdr);\n\tencode_uint64(xdr, readdir->cookie);\n\tencode_nfs4_verifier(xdr, &readdir->verifier);\n\tp = reserve_space(xdr, 12 + (attrlen << 2));\n\t*p++ = cpu_to_be32(dircount);\n\t*p++ = cpu_to_be32(maxcount);\n\t*p++ = cpu_to_be32(attrlen);\n\tfor (i = 0; i < attrlen; i++)\n\t\t*p++ = cpu_to_be32(attrs[i]);\n\tmemcpy(verf, readdir->verifier.data, sizeof(verf));\n\n\tdprintk(\"%s: cookie = %llu, verifier = %08x:%08x, bitmap = %08x:%08x:%08x\\n\",\n\t\t\t__func__,\n\t\t\t(unsigned long long)readdir->cookie,\n\t\t\tverf[0], verf[1],\n\t\t\tattrs[0] & readdir->bitmask[0],\n\t\t\tattrs[1] & readdir->bitmask[1],\n\t\t\tattrs[2] & readdir->bitmask[2]);\n}\n\nstatic void encode_readlink(struct xdr_stream *xdr, const struct nfs4_readlink *readlink, struct rpc_rqst *req, struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_READLINK, decode_readlink_maxsz, hdr);\n}\n\nstatic void encode_remove(struct xdr_stream *xdr, const struct qstr *name, struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_REMOVE, decode_remove_maxsz, hdr);\n\tencode_string(xdr, name->len, name->name);\n}\n\nstatic void encode_rename(struct xdr_stream *xdr, const struct qstr *oldname, const struct qstr *newname, struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_RENAME, decode_rename_maxsz, hdr);\n\tencode_string(xdr, oldname->len, oldname->name);\n\tencode_string(xdr, newname->len, newname->name);\n}\n\nstatic void encode_renew(struct xdr_stream *xdr, clientid4 clid,\n\t\t\t struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_RENEW, decode_renew_maxsz, hdr);\n\tencode_uint64(xdr, clid);\n}\n\nstatic void\nencode_restorefh(struct xdr_stream *xdr, struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_RESTOREFH, decode_restorefh_maxsz, hdr);\n}\n\nstatic void nfs4_acltype_to_bitmap(enum nfs4_acl_type type, __u32 bitmap[2])\n{\n\tswitch (type) {\n\tdefault:\n\t\tbitmap[0] = FATTR4_WORD0_ACL;\n\t\tbitmap[1] = 0;\n\t\tbreak;\n\tcase NFS4ACL_DACL:\n\t\tbitmap[0] = 0;\n\t\tbitmap[1] = FATTR4_WORD1_DACL;\n\t\tbreak;\n\tcase NFS4ACL_SACL:\n\t\tbitmap[0] = 0;\n\t\tbitmap[1] = FATTR4_WORD1_SACL;\n\t}\n}\n\nstatic void encode_setacl(struct xdr_stream *xdr,\n\t\t\t  const struct nfs_setaclargs *arg,\n\t\t\t  struct compound_hdr *hdr)\n{\n\t__u32 bitmap[2];\n\n\tnfs4_acltype_to_bitmap(arg->acl_type, bitmap);\n\n\tencode_op_hdr(xdr, OP_SETATTR, decode_setacl_maxsz, hdr);\n\tencode_nfs4_stateid(xdr, &zero_stateid);\n\txdr_encode_bitmap4(xdr, bitmap, ARRAY_SIZE(bitmap));\n\tencode_uint32(xdr, arg->acl_len);\n\txdr_write_pages(xdr, arg->acl_pages, 0, arg->acl_len);\n}\n\nstatic void\nencode_savefh(struct xdr_stream *xdr, struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_SAVEFH, decode_savefh_maxsz, hdr);\n}\n\nstatic void encode_setattr(struct xdr_stream *xdr, const struct nfs_setattrargs *arg, const struct nfs_server *server, struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_SETATTR, decode_setattr_maxsz, hdr);\n\tencode_nfs4_stateid(xdr, &arg->stateid);\n\tencode_attrs(xdr, arg->iap, arg->label, NULL, server,\n\t\t\tserver->attr_bitmask);\n}\n\nstatic void encode_setclientid(struct xdr_stream *xdr, const struct nfs4_setclientid *setclientid, struct compound_hdr *hdr)\n{\n\t__be32 *p;\n\n\tencode_op_hdr(xdr, OP_SETCLIENTID, decode_setclientid_maxsz, hdr);\n\tencode_nfs4_verifier(xdr, setclientid->sc_verifier);\n\n\tencode_string(xdr, strlen(setclientid->sc_clnt->cl_owner_id),\n\t\t\tsetclientid->sc_clnt->cl_owner_id);\n\tp = reserve_space(xdr, 4);\n\t*p = cpu_to_be32(setclientid->sc_prog);\n\tencode_string(xdr, setclientid->sc_netid_len, setclientid->sc_netid);\n\tencode_string(xdr, setclientid->sc_uaddr_len, setclientid->sc_uaddr);\n\tp = reserve_space(xdr, 4);\n\t*p = cpu_to_be32(setclientid->sc_clnt->cl_cb_ident);\n}\n\nstatic void encode_setclientid_confirm(struct xdr_stream *xdr, const struct nfs4_setclientid_res *arg, struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_SETCLIENTID_CONFIRM,\n\t\t\tdecode_setclientid_confirm_maxsz, hdr);\n\tencode_uint64(xdr, arg->clientid);\n\tencode_nfs4_verifier(xdr, &arg->confirm);\n}\n\nstatic void encode_write(struct xdr_stream *xdr, const struct nfs_pgio_args *args,\n\t\t\t struct compound_hdr *hdr)\n{\n\t__be32 *p;\n\n\tencode_op_hdr(xdr, OP_WRITE, decode_write_maxsz, hdr);\n\tencode_nfs4_stateid(xdr, &args->stateid);\n\n\tp = reserve_space(xdr, 16);\n\tp = xdr_encode_hyper(p, args->offset);\n\t*p++ = cpu_to_be32(args->stable);\n\t*p = cpu_to_be32(args->count);\n\n\txdr_write_pages(xdr, args->pages, args->pgbase, args->count);\n}\n\nstatic void encode_delegreturn(struct xdr_stream *xdr, const nfs4_stateid *stateid, struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_DELEGRETURN, decode_delegreturn_maxsz, hdr);\n\tencode_nfs4_stateid(xdr, stateid);\n}\n\nstatic void encode_secinfo(struct xdr_stream *xdr, const struct qstr *name, struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_SECINFO, decode_secinfo_maxsz, hdr);\n\tencode_string(xdr, name->len, name->name);\n}\n\n#if defined(CONFIG_NFS_V4_1)\n \nstatic void encode_bind_conn_to_session(struct xdr_stream *xdr,\n\t\t\t\t   const struct nfs41_bind_conn_to_session_args *args,\n\t\t\t\t   struct compound_hdr *hdr)\n{\n\t__be32 *p;\n\n\tencode_op_hdr(xdr, OP_BIND_CONN_TO_SESSION,\n\t\tdecode_bind_conn_to_session_maxsz, hdr);\n\tencode_opaque_fixed(xdr, args->sessionid.data, NFS4_MAX_SESSIONID_LEN);\n\tp = xdr_reserve_space(xdr, 8);\n\t*p++ = cpu_to_be32(args->dir);\n\t*p = (args->use_conn_in_rdma_mode) ? cpu_to_be32(1) : cpu_to_be32(0);\n}\n\nstatic void encode_op_map(struct xdr_stream *xdr, const struct nfs4_op_map *op_map)\n{\n\tunsigned int i;\n\tencode_uint32(xdr, NFS4_OP_MAP_NUM_WORDS);\n\tfor (i = 0; i < NFS4_OP_MAP_NUM_WORDS; i++)\n\t\tencode_uint32(xdr, op_map->u.words[i]);\n}\n\nstatic void encode_exchange_id(struct xdr_stream *xdr,\n\t\t\t       const struct nfs41_exchange_id_args *args,\n\t\t\t       struct compound_hdr *hdr)\n{\n\t__be32 *p;\n\tchar impl_name[IMPL_NAME_LIMIT];\n\tint len = 0;\n\n\tencode_op_hdr(xdr, OP_EXCHANGE_ID, decode_exchange_id_maxsz, hdr);\n\tencode_nfs4_verifier(xdr, &args->verifier);\n\n\tencode_string(xdr, strlen(args->client->cl_owner_id),\n\t\t\targs->client->cl_owner_id);\n\n\tencode_uint32(xdr, args->flags);\n\tencode_uint32(xdr, args->state_protect.how);\n\n\tswitch (args->state_protect.how) {\n\tcase SP4_NONE:\n\t\tbreak;\n\tcase SP4_MACH_CRED:\n\t\tencode_op_map(xdr, &args->state_protect.enforce);\n\t\tencode_op_map(xdr, &args->state_protect.allow);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\n\tif (send_implementation_id &&\n\t    sizeof(CONFIG_NFS_V4_1_IMPLEMENTATION_ID_DOMAIN) > 1 &&\n\t    sizeof(CONFIG_NFS_V4_1_IMPLEMENTATION_ID_DOMAIN)\n\t\t<= sizeof(impl_name) + 1)\n\t\tlen = snprintf(impl_name, sizeof(impl_name), \"%s %s %s %s\",\n\t\t\t       utsname()->sysname, utsname()->release,\n\t\t\t       utsname()->version, utsname()->machine);\n\n\tif (len > 0) {\n\t\tencode_uint32(xdr, 1);\t \n\n\t\tencode_string(xdr,\n\t\t\tsizeof(CONFIG_NFS_V4_1_IMPLEMENTATION_ID_DOMAIN) - 1,\n\t\t\tCONFIG_NFS_V4_1_IMPLEMENTATION_ID_DOMAIN);\n\t\tencode_string(xdr, len, impl_name);\n\t\t \n\t\tp = reserve_space(xdr, 12);\n\t\tp = xdr_encode_hyper(p, 0);\n\t\t*p = cpu_to_be32(0);\n\t} else\n\t\tencode_uint32(xdr, 0);\t \n}\n\nstatic void encode_create_session(struct xdr_stream *xdr,\n\t\t\t\t  const struct nfs41_create_session_args *args,\n\t\t\t\t  struct compound_hdr *hdr)\n{\n\t__be32 *p;\n\tstruct nfs_client *clp = args->client;\n\tstruct rpc_clnt *clnt = clp->cl_rpcclient;\n\tstruct nfs_net *nn = net_generic(clp->cl_net, nfs_net_id);\n\tu32 max_resp_sz_cached;\n\n\t \n\tmax_resp_sz_cached = (NFS4_dec_open_sz + RPC_REPHDRSIZE + 2)\n\t\t\t\t* XDR_UNIT + RPC_MAX_AUTH_SIZE;\n\n\tencode_op_hdr(xdr, OP_CREATE_SESSION, decode_create_session_maxsz, hdr);\n\tp = reserve_space(xdr, 16 + 2*28 + 20 + clnt->cl_nodelen + 12);\n\tp = xdr_encode_hyper(p, args->clientid);\n\t*p++ = cpu_to_be32(args->seqid);\t\t\t \n\t*p++ = cpu_to_be32(args->flags);\t\t\t \n\n\t \n\t*p++ = cpu_to_be32(0);\t\t\t\t \n\t*p++ = cpu_to_be32(args->fc_attrs.max_rqst_sz);\t \n\t*p++ = cpu_to_be32(args->fc_attrs.max_resp_sz);\t \n\t*p++ = cpu_to_be32(max_resp_sz_cached);\t\t \n\t*p++ = cpu_to_be32(args->fc_attrs.max_ops);\t \n\t*p++ = cpu_to_be32(args->fc_attrs.max_reqs);\t \n\t*p++ = cpu_to_be32(0);\t\t\t\t \n\n\t \n\t*p++ = cpu_to_be32(0);\t\t\t\t \n\t*p++ = cpu_to_be32(args->bc_attrs.max_rqst_sz);\t \n\t*p++ = cpu_to_be32(args->bc_attrs.max_resp_sz);\t \n\t*p++ = cpu_to_be32(args->bc_attrs.max_resp_sz_cached);\t \n\t*p++ = cpu_to_be32(args->bc_attrs.max_ops);\t \n\t*p++ = cpu_to_be32(args->bc_attrs.max_reqs);\t \n\t*p++ = cpu_to_be32(0);\t\t\t\t \n\n\t*p++ = cpu_to_be32(args->cb_program);\t\t \n\t*p++ = cpu_to_be32(1);\n\t*p++ = cpu_to_be32(RPC_AUTH_UNIX);\t\t\t \n\n\t \n\t*p++ = cpu_to_be32(ktime_to_ns(nn->boot_time));\t \n\tp = xdr_encode_array(p, clnt->cl_nodename, clnt->cl_nodelen);\n\t*p++ = cpu_to_be32(0);\t\t\t\t \n\t*p++ = cpu_to_be32(0);\t\t\t\t \n\t*p = cpu_to_be32(0);\t\t\t\t \n}\n\nstatic void encode_destroy_session(struct xdr_stream *xdr,\n\t\t\t\t   const struct nfs4_session *session,\n\t\t\t\t   struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_DESTROY_SESSION, decode_destroy_session_maxsz, hdr);\n\tencode_opaque_fixed(xdr, session->sess_id.data, NFS4_MAX_SESSIONID_LEN);\n}\n\nstatic void encode_destroy_clientid(struct xdr_stream *xdr,\n\t\t\t\t   uint64_t clientid,\n\t\t\t\t   struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_DESTROY_CLIENTID, decode_destroy_clientid_maxsz, hdr);\n\tencode_uint64(xdr, clientid);\n}\n\nstatic void encode_reclaim_complete(struct xdr_stream *xdr,\n\t\t\t\t    const struct nfs41_reclaim_complete_args *args,\n\t\t\t\t    struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_RECLAIM_COMPLETE, decode_reclaim_complete_maxsz, hdr);\n\tencode_uint32(xdr, args->one_fs);\n}\n#endif  \n\nstatic void encode_sequence(struct xdr_stream *xdr,\n\t\t\t    const struct nfs4_sequence_args *args,\n\t\t\t    struct compound_hdr *hdr)\n{\n#if defined(CONFIG_NFS_V4_1)\n\tstruct nfs4_session *session;\n\tstruct nfs4_slot_table *tp;\n\tstruct nfs4_slot *slot = args->sa_slot;\n\t__be32 *p;\n\n\ttp = slot->table;\n\tsession = tp->session;\n\tif (!session)\n\t\treturn;\n\n\tencode_op_hdr(xdr, OP_SEQUENCE, decode_sequence_maxsz, hdr);\n\n\t \n\tdprintk(\"%s: sessionid=%u:%u:%u:%u seqid=%d slotid=%d \"\n\t\t\"max_slotid=%d cache_this=%d\\n\",\n\t\t__func__,\n\t\t((u32 *)session->sess_id.data)[0],\n\t\t((u32 *)session->sess_id.data)[1],\n\t\t((u32 *)session->sess_id.data)[2],\n\t\t((u32 *)session->sess_id.data)[3],\n\t\tslot->seq_nr, slot->slot_nr,\n\t\ttp->highest_used_slotid, args->sa_cache_this);\n\tp = reserve_space(xdr, NFS4_MAX_SESSIONID_LEN + 16);\n\tp = xdr_encode_opaque_fixed(p, session->sess_id.data, NFS4_MAX_SESSIONID_LEN);\n\t*p++ = cpu_to_be32(slot->seq_nr);\n\t*p++ = cpu_to_be32(slot->slot_nr);\n\t*p++ = cpu_to_be32(tp->highest_used_slotid);\n\t*p = cpu_to_be32(args->sa_cache_this);\n#endif  \n}\n\n#ifdef CONFIG_NFS_V4_1\nstatic void\nencode_getdeviceinfo(struct xdr_stream *xdr,\n\t\t     const struct nfs4_getdeviceinfo_args *args,\n\t\t     struct compound_hdr *hdr)\n{\n\t__be32 *p;\n\n\tencode_op_hdr(xdr, OP_GETDEVICEINFO, decode_getdeviceinfo_maxsz, hdr);\n\tp = reserve_space(xdr, NFS4_DEVICEID4_SIZE + 4 + 4);\n\tp = xdr_encode_opaque_fixed(p, args->pdev->dev_id.data,\n\t\t\t\t    NFS4_DEVICEID4_SIZE);\n\t*p++ = cpu_to_be32(args->pdev->layout_type);\n\t*p++ = cpu_to_be32(args->pdev->maxcount);\t \n\n\tp = reserve_space(xdr, 4 + 4);\n\t*p++ = cpu_to_be32(1);\t\t\t \n\t*p++ = cpu_to_be32(args->notify_types);\n}\n\nstatic void\nencode_layoutget(struct xdr_stream *xdr,\n\t\t      const struct nfs4_layoutget_args *args,\n\t\t      struct compound_hdr *hdr)\n{\n\t__be32 *p;\n\n\tencode_op_hdr(xdr, OP_LAYOUTGET, decode_layoutget_maxsz, hdr);\n\tp = reserve_space(xdr, 36);\n\t*p++ = cpu_to_be32(0);      \n\t*p++ = cpu_to_be32(args->type);\n\t*p++ = cpu_to_be32(args->range.iomode);\n\tp = xdr_encode_hyper(p, args->range.offset);\n\tp = xdr_encode_hyper(p, args->range.length);\n\tp = xdr_encode_hyper(p, args->minlength);\n\tencode_nfs4_stateid(xdr, &args->stateid);\n\tencode_uint32(xdr, args->maxcount);\n\n\tdprintk(\"%s: 1st type:0x%x iomode:%d off:%lu len:%lu mc:%d\\n\",\n\t\t__func__,\n\t\targs->type,\n\t\targs->range.iomode,\n\t\t(unsigned long)args->range.offset,\n\t\t(unsigned long)args->range.length,\n\t\targs->maxcount);\n}\n\nstatic int\nencode_layoutcommit(struct xdr_stream *xdr,\n\t\t    struct inode *inode,\n\t\t    const struct nfs4_layoutcommit_args *args,\n\t\t    struct compound_hdr *hdr)\n{\n\t__be32 *p;\n\n\tdprintk(\"%s: lbw: %llu type: %d\\n\", __func__, args->lastbytewritten,\n\t\tNFS_SERVER(args->inode)->pnfs_curr_ld->id);\n\n\tencode_op_hdr(xdr, OP_LAYOUTCOMMIT, decode_layoutcommit_maxsz, hdr);\n\tp = reserve_space(xdr, 20);\n\t \n\tp = xdr_encode_hyper(p, 0);  \n\tp = xdr_encode_hyper(p, args->lastbytewritten + 1);\t \n\t*p = cpu_to_be32(0);  \n\tencode_nfs4_stateid(xdr, &args->stateid);\n\tif (args->lastbytewritten != U64_MAX) {\n\t\tp = reserve_space(xdr, 20);\n\t\t*p++ = cpu_to_be32(1);  \n\t\tp = xdr_encode_hyper(p, args->lastbytewritten);\n\t} else {\n\t\tp = reserve_space(xdr, 12);\n\t\t*p++ = cpu_to_be32(0);  \n\t}\n\t*p++ = cpu_to_be32(0);  \n\t*p++ = cpu_to_be32(NFS_SERVER(args->inode)->pnfs_curr_ld->id); \n\n\tencode_uint32(xdr, args->layoutupdate_len);\n\tif (args->layoutupdate_pages)\n\t\txdr_write_pages(xdr, args->layoutupdate_pages, 0,\n\t\t\t\targs->layoutupdate_len);\n\n\treturn 0;\n}\n\nstatic void\nencode_layoutreturn(struct xdr_stream *xdr,\n\t\t    const struct nfs4_layoutreturn_args *args,\n\t\t    struct compound_hdr *hdr)\n{\n\t__be32 *p;\n\n\tencode_op_hdr(xdr, OP_LAYOUTRETURN, decode_layoutreturn_maxsz, hdr);\n\tp = reserve_space(xdr, 16);\n\t*p++ = cpu_to_be32(0);\t\t \n\t*p++ = cpu_to_be32(args->layout_type);\n\t*p++ = cpu_to_be32(args->range.iomode);\n\t*p = cpu_to_be32(RETURN_FILE);\n\tp = reserve_space(xdr, 16);\n\tp = xdr_encode_hyper(p, args->range.offset);\n\tp = xdr_encode_hyper(p, args->range.length);\n\tspin_lock(&args->inode->i_lock);\n\tencode_nfs4_stateid(xdr, &args->stateid);\n\tspin_unlock(&args->inode->i_lock);\n\tif (args->ld_private->ops && args->ld_private->ops->encode)\n\t\targs->ld_private->ops->encode(xdr, args, args->ld_private);\n\telse\n\t\tencode_uint32(xdr, 0);\n}\n\nstatic int\nencode_secinfo_no_name(struct xdr_stream *xdr,\n\t\t       const struct nfs41_secinfo_no_name_args *args,\n\t\t       struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_SECINFO_NO_NAME, decode_secinfo_no_name_maxsz, hdr);\n\tencode_uint32(xdr, args->style);\n\treturn 0;\n}\n\nstatic void encode_test_stateid(struct xdr_stream *xdr,\n\t\t\t\tconst struct nfs41_test_stateid_args *args,\n\t\t\t\tstruct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_TEST_STATEID, decode_test_stateid_maxsz, hdr);\n\tencode_uint32(xdr, 1);\n\tencode_nfs4_stateid(xdr, args->stateid);\n}\n\nstatic void encode_free_stateid(struct xdr_stream *xdr,\n\t\t\t\tconst struct nfs41_free_stateid_args *args,\n\t\t\t\tstruct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_FREE_STATEID, decode_free_stateid_maxsz, hdr);\n\tencode_nfs4_stateid(xdr, &args->stateid);\n}\n#else\nstatic inline void\nencode_layoutreturn(struct xdr_stream *xdr,\n\t\t    const struct nfs4_layoutreturn_args *args,\n\t\t    struct compound_hdr *hdr)\n{\n}\n\nstatic void\nencode_layoutget(struct xdr_stream *xdr,\n\t\t      const struct nfs4_layoutget_args *args,\n\t\t      struct compound_hdr *hdr)\n{\n}\n#endif  \n\n \n\nstatic u32 nfs4_xdr_minorversion(const struct nfs4_sequence_args *args)\n{\n#if defined(CONFIG_NFS_V4_1)\n\tstruct nfs4_session *session = args->sa_slot->table->session;\n\tif (session)\n\t\treturn session->clp->cl_mvops->minor_version;\n#endif  \n\treturn 0;\n}\n\n \nstatic void nfs4_xdr_enc_access(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\tconst void *data)\n{\n\tconst struct nfs4_accessargs *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tencode_access(xdr, args->access, &hdr);\n\tif (args->bitmask)\n\t\tencode_getfattr(xdr, args->bitmask, &hdr);\n\tencode_nops(&hdr);\n}\n\n \nstatic void nfs4_xdr_enc_lookup(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\tconst void *data)\n{\n\tconst struct nfs4_lookup_arg *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->dir_fh, &hdr);\n\tencode_lookup(xdr, args->name, &hdr);\n\tencode_getfh(xdr, &hdr);\n\tencode_getfattr(xdr, args->bitmask, &hdr);\n\tencode_nops(&hdr);\n}\n\n \nstatic void nfs4_xdr_enc_lookupp(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\tconst void *data)\n{\n\tconst struct nfs4_lookupp_arg *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tencode_lookupp(xdr, &hdr);\n\tencode_getfh(xdr, &hdr);\n\tencode_getfattr(xdr, args->bitmask, &hdr);\n\tencode_nops(&hdr);\n}\n\n \nstatic void nfs4_xdr_enc_lookup_root(struct rpc_rqst *req,\n\t\t\t\t     struct xdr_stream *xdr,\n\t\t\t\t     const void *data)\n{\n\tconst struct nfs4_lookup_root_arg *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putrootfh(xdr, &hdr);\n\tencode_getfh(xdr, &hdr);\n\tencode_getfattr(xdr, args->bitmask, &hdr);\n\tencode_nops(&hdr);\n}\n\n \nstatic void nfs4_xdr_enc_remove(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\tconst void *data)\n{\n\tconst struct nfs_removeargs *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tencode_remove(xdr, &args->name, &hdr);\n\tencode_nops(&hdr);\n}\n\n \nstatic void nfs4_xdr_enc_rename(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\tconst void *data)\n{\n\tconst struct nfs_renameargs *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->old_dir, &hdr);\n\tencode_savefh(xdr, &hdr);\n\tencode_putfh(xdr, args->new_dir, &hdr);\n\tencode_rename(xdr, args->old_name, args->new_name, &hdr);\n\tencode_nops(&hdr);\n}\n\n \nstatic void nfs4_xdr_enc_link(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t      const void *data)\n{\n\tconst struct nfs4_link_arg *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tencode_savefh(xdr, &hdr);\n\tencode_putfh(xdr, args->dir_fh, &hdr);\n\tencode_link(xdr, args->name, &hdr);\n\tencode_restorefh(xdr, &hdr);\n\tencode_getfattr(xdr, args->bitmask, &hdr);\n\tencode_nops(&hdr);\n}\n\n \nstatic void nfs4_xdr_enc_create(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\tconst void *data)\n{\n\tconst struct nfs4_create_arg *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->dir_fh, &hdr);\n\tencode_create(xdr, args, &hdr);\n\tencode_getfh(xdr, &hdr);\n\tencode_getfattr(xdr, args->bitmask, &hdr);\n\tencode_nops(&hdr);\n}\n\n \nstatic void nfs4_xdr_enc_symlink(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\t const void *data)\n{\n\tconst struct nfs4_create_arg *args = data;\n\n\tnfs4_xdr_enc_create(req, xdr, args);\n}\n\n \nstatic void nfs4_xdr_enc_getattr(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\t const void *data)\n{\n\tconst struct nfs4_getattr_arg *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tencode_getfattr(xdr, args->bitmask, &hdr);\n\tencode_nops(&hdr);\n}\n\n \nstatic void nfs4_xdr_enc_close(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t       const void *data)\n{\n\tconst struct nfs_closeargs *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tif (args->lr_args)\n\t\tencode_layoutreturn(xdr, args->lr_args, &hdr);\n\tif (args->bitmask != NULL)\n\t\tencode_getfattr(xdr, args->bitmask, &hdr);\n\tencode_close(xdr, args, &hdr);\n\tencode_nops(&hdr);\n}\n\n \nstatic void nfs4_xdr_enc_open(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t      const void *data)\n{\n\tconst struct nfs_openargs *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tencode_open(xdr, args, &hdr);\n\tencode_getfh(xdr, &hdr);\n\tif (args->access)\n\t\tencode_access(xdr, args->access, &hdr);\n\tencode_getfattr_open(xdr, args->bitmask, args->open_bitmap, &hdr);\n\tif (args->lg_args) {\n\t\tencode_layoutget(xdr, args->lg_args, &hdr);\n\t\trpc_prepare_reply_pages(req, args->lg_args->layout.pages, 0,\n\t\t\t\t\targs->lg_args->layout.pglen,\n\t\t\t\t\thdr.replen - pagepad_maxsz);\n\t}\n\tencode_nops(&hdr);\n}\n\n \nstatic void nfs4_xdr_enc_open_confirm(struct rpc_rqst *req,\n\t\t\t\t      struct xdr_stream *xdr,\n\t\t\t\t      const void *data)\n{\n\tconst struct nfs_open_confirmargs *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.nops   = 0,\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tencode_open_confirm(xdr, args, &hdr);\n\tencode_nops(&hdr);\n}\n\n \nstatic void nfs4_xdr_enc_open_noattr(struct rpc_rqst *req,\n\t\t\t\t     struct xdr_stream *xdr,\n\t\t\t\t     const void *data)\n{\n\tconst struct nfs_openargs *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tencode_open(xdr, args, &hdr);\n\tif (args->access)\n\t\tencode_access(xdr, args->access, &hdr);\n\tencode_getfattr_open(xdr, args->bitmask, args->open_bitmap, &hdr);\n\tif (args->lg_args) {\n\t\tencode_layoutget(xdr, args->lg_args, &hdr);\n\t\trpc_prepare_reply_pages(req, args->lg_args->layout.pages, 0,\n\t\t\t\t\targs->lg_args->layout.pglen,\n\t\t\t\t\thdr.replen - pagepad_maxsz);\n\t}\n\tencode_nops(&hdr);\n}\n\n \nstatic void nfs4_xdr_enc_open_downgrade(struct rpc_rqst *req,\n\t\t\t\t\tstruct xdr_stream *xdr,\n\t\t\t\t\tconst void *data)\n{\n\tconst struct nfs_closeargs *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tif (args->lr_args)\n\t\tencode_layoutreturn(xdr, args->lr_args, &hdr);\n\tencode_open_downgrade(xdr, args, &hdr);\n\tencode_nops(&hdr);\n}\n\n \nstatic void nfs4_xdr_enc_lock(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t      const void *data)\n{\n\tconst struct nfs_lock_args *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tencode_lock(xdr, args, &hdr);\n\tencode_nops(&hdr);\n}\n\n \nstatic void nfs4_xdr_enc_lockt(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t       const void *data)\n{\n\tconst struct nfs_lockt_args *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tencode_lockt(xdr, args, &hdr);\n\tencode_nops(&hdr);\n}\n\n \nstatic void nfs4_xdr_enc_locku(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t       const void *data)\n{\n\tconst struct nfs_locku_args *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tencode_locku(xdr, args, &hdr);\n\tencode_nops(&hdr);\n}\n\nstatic void nfs4_xdr_enc_release_lockowner(struct rpc_rqst *req,\n\t\t\t\t\t   struct xdr_stream *xdr,\n\t\t\t\t\t   const void *data)\n{\n\tconst struct nfs_release_lockowner_args *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = 0,\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_release_lockowner(xdr, &args->lock_owner, &hdr);\n\tencode_nops(&hdr);\n}\n\n \nstatic void nfs4_xdr_enc_readlink(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\t  const void *data)\n{\n\tconst struct nfs4_readlink *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tencode_readlink(xdr, args, req, &hdr);\n\n\trpc_prepare_reply_pages(req, args->pages, args->pgbase,\n\t\t\t\targs->pglen, hdr.replen - pagepad_maxsz);\n\tencode_nops(&hdr);\n}\n\n \nstatic void nfs4_xdr_enc_readdir(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\t const void *data)\n{\n\tconst struct nfs4_readdir_arg *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tencode_readdir(xdr, args, req, &hdr);\n\n\trpc_prepare_reply_pages(req, args->pages, args->pgbase,\n\t\t\t\targs->count, hdr.replen - pagepad_maxsz);\n\tencode_nops(&hdr);\n}\n\n \nstatic void nfs4_xdr_enc_read(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t      const void *data)\n{\n\tconst struct nfs_pgio_args *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tencode_read(xdr, args, &hdr);\n\n\trpc_prepare_reply_pages(req, args->pages, args->pgbase,\n\t\t\t\targs->count, hdr.replen - pagepad_maxsz);\n\treq->rq_rcv_buf.flags |= XDRBUF_READ;\n\tencode_nops(&hdr);\n}\n\n \nstatic void nfs4_xdr_enc_setattr(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\t const void *data)\n{\n\tconst struct nfs_setattrargs *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tencode_setattr(xdr, args, args->server, &hdr);\n\tencode_getfattr(xdr, args->bitmask, &hdr);\n\tencode_nops(&hdr);\n}\n\n \nstatic void nfs4_xdr_enc_getacl(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\tconst void *data)\n{\n\tconst struct nfs_getaclargs *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\t__u32 nfs4_acl_bitmap[2];\n\tuint32_t replen;\n\n\tnfs4_acltype_to_bitmap(args->acl_type, nfs4_acl_bitmap);\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\treplen = hdr.replen + op_decode_hdr_maxsz;\n\tencode_getattr(xdr, nfs4_acl_bitmap, NULL,\n\t\t\tARRAY_SIZE(nfs4_acl_bitmap), &hdr);\n\n\trpc_prepare_reply_pages(req, args->acl_pages, 0,\n\t\t\t\targs->acl_len, replen);\n\tencode_nops(&hdr);\n}\n\n \nstatic void nfs4_xdr_enc_write(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t       const void *data)\n{\n\tconst struct nfs_pgio_args *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tencode_write(xdr, args, &hdr);\n\treq->rq_snd_buf.flags |= XDRBUF_WRITE;\n\tif (args->bitmask)\n\t\tencode_getfattr(xdr, args->bitmask, &hdr);\n\tencode_nops(&hdr);\n}\n\n \nstatic void nfs4_xdr_enc_commit(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\tconst void *data)\n{\n\tconst struct nfs_commitargs *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tencode_commit(xdr, args, &hdr);\n\tencode_nops(&hdr);\n}\n\n \nstatic void nfs4_xdr_enc_fsinfo(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\tconst void *data)\n{\n\tconst struct nfs4_fsinfo_arg *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tencode_fsinfo(xdr, args->bitmask, &hdr);\n\tencode_nops(&hdr);\n}\n\n \nstatic void nfs4_xdr_enc_pathconf(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\t  const void *data)\n{\n\tconst struct nfs4_pathconf_arg *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tencode_getattr(xdr, nfs4_pathconf_bitmap, args->bitmask,\n\t\t\tARRAY_SIZE(nfs4_pathconf_bitmap), &hdr);\n\tencode_nops(&hdr);\n}\n\n \nstatic void nfs4_xdr_enc_statfs(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\tconst void *data)\n{\n\tconst struct nfs4_statfs_arg *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tencode_getattr(xdr, nfs4_statfs_bitmap, args->bitmask,\n\t\t\tARRAY_SIZE(nfs4_statfs_bitmap), &hdr);\n\tencode_nops(&hdr);\n}\n\n \nstatic void nfs4_xdr_enc_server_caps(struct rpc_rqst *req,\n\t\t\t\t     struct xdr_stream *xdr,\n\t\t\t\t     const void *data)\n{\n\tconst struct nfs4_server_caps_arg *args = data;\n\tconst u32 *bitmask = args->bitmask;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fhandle, &hdr);\n\tencode_getattr(xdr, bitmask, NULL, 3, &hdr);\n\tencode_nops(&hdr);\n}\n\n \nstatic void nfs4_xdr_enc_renew(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t       const void *data)\n\n{\n\tconst struct nfs_client *clp = data;\n\tstruct compound_hdr hdr = {\n\t\t.nops\t= 0,\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_renew(xdr, clp->cl_clientid, &hdr);\n\tencode_nops(&hdr);\n}\n\n \nstatic void nfs4_xdr_enc_setclientid(struct rpc_rqst *req,\n\t\t\t\t     struct xdr_stream *xdr,\n\t\t\t\t     const void *data)\n{\n\tconst struct nfs4_setclientid *sc = data;\n\tstruct compound_hdr hdr = {\n\t\t.nops\t= 0,\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_setclientid(xdr, sc, &hdr);\n\tencode_nops(&hdr);\n}\n\n \nstatic void nfs4_xdr_enc_setclientid_confirm(struct rpc_rqst *req,\n\t\t\t\t\t     struct xdr_stream *xdr,\n\t\t\t\t\t     const void *data)\n{\n\tconst struct nfs4_setclientid_res *arg = data;\n\tstruct compound_hdr hdr = {\n\t\t.nops\t= 0,\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_setclientid_confirm(xdr, arg, &hdr);\n\tencode_nops(&hdr);\n}\n\n \nstatic void nfs4_xdr_enc_delegreturn(struct rpc_rqst *req,\n\t\t\t\t     struct xdr_stream *xdr,\n\t\t\t\t     const void *data)\n{\n\tconst struct nfs4_delegreturnargs *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fhandle, &hdr);\n\tif (args->lr_args)\n\t\tencode_layoutreturn(xdr, args->lr_args, &hdr);\n\tif (args->bitmask)\n\t\tencode_getfattr(xdr, args->bitmask, &hdr);\n\tencode_delegreturn(xdr, args->stateid, &hdr);\n\tencode_nops(&hdr);\n}\n\n \nstatic void nfs4_xdr_enc_fs_locations(struct rpc_rqst *req,\n\t\t\t\t      struct xdr_stream *xdr,\n\t\t\t\t      const void *data)\n{\n\tconst struct nfs4_fs_locations_arg *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\tuint32_t replen;\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tif (args->migration) {\n\t\tencode_putfh(xdr, args->fh, &hdr);\n\t\treplen = hdr.replen;\n\t\tencode_fs_locations(xdr, args->bitmask, &hdr);\n\t\tif (args->renew)\n\t\t\tencode_renew(xdr, args->clientid, &hdr);\n\t} else {\n\t\tencode_putfh(xdr, args->dir_fh, &hdr);\n\t\tencode_lookup(xdr, args->name, &hdr);\n\t\treplen = hdr.replen;\n\t\tencode_fs_locations(xdr, args->bitmask, &hdr);\n\t}\n\n\trpc_prepare_reply_pages(req, (struct page **)&args->page, 0,\n\t\t\t\tPAGE_SIZE, replen);\n\tencode_nops(&hdr);\n}\n\n \nstatic void nfs4_xdr_enc_secinfo(struct rpc_rqst *req,\n\t\t\t\tstruct xdr_stream *xdr,\n\t\t\t\tconst void *data)\n{\n\tconst struct nfs4_secinfo_arg *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->dir_fh, &hdr);\n\tencode_secinfo(xdr, args->name, &hdr);\n\tencode_nops(&hdr);\n}\n\n \nstatic void nfs4_xdr_enc_fsid_present(struct rpc_rqst *req,\n\t\t\t\t      struct xdr_stream *xdr,\n\t\t\t\t      const void *data)\n{\n\tconst struct nfs4_fsid_present_arg *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tencode_getfh(xdr, &hdr);\n\tif (args->renew)\n\t\tencode_renew(xdr, args->clientid, &hdr);\n\tencode_nops(&hdr);\n}\n\n#if defined(CONFIG_NFS_V4_1)\n \nstatic void nfs4_xdr_enc_bind_conn_to_session(struct rpc_rqst *req,\n\t\t\t\tstruct xdr_stream *xdr,\n\t\t\t\tconst void *data)\n{\n\tconst struct nfs41_bind_conn_to_session_args *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = args->client->cl_mvops->minor_version,\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_bind_conn_to_session(xdr, args, &hdr);\n\tencode_nops(&hdr);\n}\n\n \nstatic void nfs4_xdr_enc_exchange_id(struct rpc_rqst *req,\n\t\t\t\t     struct xdr_stream *xdr,\n\t\t\t\t     const void *data)\n{\n\tconst struct nfs41_exchange_id_args *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = args->client->cl_mvops->minor_version,\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_exchange_id(xdr, args, &hdr);\n\tencode_nops(&hdr);\n}\n\n \nstatic void nfs4_xdr_enc_create_session(struct rpc_rqst *req,\n\t\t\t\t\tstruct xdr_stream *xdr,\n\t\t\t\t\tconst void *data)\n{\n\tconst struct nfs41_create_session_args *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = args->client->cl_mvops->minor_version,\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_create_session(xdr, args, &hdr);\n\tencode_nops(&hdr);\n}\n\n \nstatic void nfs4_xdr_enc_destroy_session(struct rpc_rqst *req,\n\t\t\t\t\t struct xdr_stream *xdr,\n\t\t\t\t\t const void *data)\n{\n\tconst struct nfs4_session *session = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = session->clp->cl_mvops->minor_version,\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_destroy_session(xdr, session, &hdr);\n\tencode_nops(&hdr);\n}\n\n \nstatic void nfs4_xdr_enc_destroy_clientid(struct rpc_rqst *req,\n\t\t\t\t\t struct xdr_stream *xdr,\n\t\t\t\t\t const void *data)\n{\n\tconst struct nfs_client *clp = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = clp->cl_mvops->minor_version,\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_destroy_clientid(xdr, clp->cl_clientid, &hdr);\n\tencode_nops(&hdr);\n}\n\n \nstatic void nfs4_xdr_enc_sequence(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\t  const void *data)\n{\n\tconst struct nfs4_sequence_args *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, args, &hdr);\n\tencode_nops(&hdr);\n}\n\n#endif\n\n \nstatic void nfs4_xdr_enc_get_lease_time(struct rpc_rqst *req,\n\t\t\t\t\tstruct xdr_stream *xdr,\n\t\t\t\t\tconst void *data)\n{\n\tconst struct nfs4_get_lease_time_args *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->la_seq_args),\n\t};\n\tconst u32 lease_bitmap[3] = { FATTR4_WORD0_LEASE_TIME };\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->la_seq_args, &hdr);\n\tencode_putrootfh(xdr, &hdr);\n\tencode_fsinfo(xdr, lease_bitmap, &hdr);\n\tencode_nops(&hdr);\n}\n\n#ifdef CONFIG_NFS_V4_1\n\n \nstatic void nfs4_xdr_enc_reclaim_complete(struct rpc_rqst *req,\n\t\t\t\t\t  struct xdr_stream *xdr,\n\t\t\t\t\t  const void *data)\n{\n\tconst struct nfs41_reclaim_complete_args *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args)\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_reclaim_complete(xdr, args, &hdr);\n\tencode_nops(&hdr);\n}\n\n \nstatic void nfs4_xdr_enc_getdeviceinfo(struct rpc_rqst *req,\n\t\t\t\t       struct xdr_stream *xdr,\n\t\t\t\t       const void *data)\n{\n\tconst struct nfs4_getdeviceinfo_args *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\tuint32_t replen;\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\n\treplen = hdr.replen + op_decode_hdr_maxsz + 2;\n\n\tencode_getdeviceinfo(xdr, args, &hdr);\n\n\t \n\trpc_prepare_reply_pages(req, args->pdev->pages, args->pdev->pgbase,\n\t\t\t\targs->pdev->pglen, replen);\n\tencode_nops(&hdr);\n}\n\n \nstatic void nfs4_xdr_enc_layoutget(struct rpc_rqst *req,\n\t\t\t\t   struct xdr_stream *xdr,\n\t\t\t\t   const void *data)\n{\n\tconst struct nfs4_layoutget_args *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, NFS_FH(args->inode), &hdr);\n\tencode_layoutget(xdr, args, &hdr);\n\n\trpc_prepare_reply_pages(req, args->layout.pages, 0,\n\t\t\t\targs->layout.pglen, hdr.replen - pagepad_maxsz);\n\tencode_nops(&hdr);\n}\n\n \nstatic void nfs4_xdr_enc_layoutcommit(struct rpc_rqst *req,\n\t\t\t\t      struct xdr_stream *xdr,\n\t\t\t\t      const void *priv)\n{\n\tconst struct nfs4_layoutcommit_args *args = priv;\n\tstruct nfs4_layoutcommit_data *data =\n\t\tcontainer_of(args, struct nfs4_layoutcommit_data, args);\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, NFS_FH(args->inode), &hdr);\n\tencode_layoutcommit(xdr, data->args.inode, args, &hdr);\n\tencode_getfattr(xdr, args->bitmask, &hdr);\n\tencode_nops(&hdr);\n}\n\n \nstatic void nfs4_xdr_enc_layoutreturn(struct rpc_rqst *req,\n\t\t\t\t      struct xdr_stream *xdr,\n\t\t\t\t      const void *data)\n{\n\tconst struct nfs4_layoutreturn_args *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, NFS_FH(args->inode), &hdr);\n\tencode_layoutreturn(xdr, args, &hdr);\n\tencode_nops(&hdr);\n}\n\n \nstatic void nfs4_xdr_enc_secinfo_no_name(struct rpc_rqst *req,\n\t\t\t\t\tstruct xdr_stream *xdr,\n\t\t\t\t\tconst void *data)\n{\n\tconst struct nfs41_secinfo_no_name_args *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putrootfh(xdr, &hdr);\n\tencode_secinfo_no_name(xdr, args, &hdr);\n\tencode_nops(&hdr);\n}\n\n \nstatic void nfs4_xdr_enc_test_stateid(struct rpc_rqst *req,\n\t\t\t\t      struct xdr_stream *xdr,\n\t\t\t\t      const void *data)\n{\n\tconst struct nfs41_test_stateid_args *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_test_stateid(xdr, args, &hdr);\n\tencode_nops(&hdr);\n}\n\n \nstatic void nfs4_xdr_enc_free_stateid(struct rpc_rqst *req,\n\t\t\t\t     struct xdr_stream *xdr,\n\t\t\t\t     const void *data)\n{\n\tconst struct nfs41_free_stateid_args *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_free_stateid(xdr, args, &hdr);\n\tencode_nops(&hdr);\n}\n#endif  \n\nstatic int decode_opaque_inline(struct xdr_stream *xdr, unsigned int *len, char **string)\n{\n\tssize_t ret = xdr_stream_decode_opaque_inline(xdr, (void **)string,\n\t\t\tNFS4_OPAQUE_LIMIT);\n\tif (unlikely(ret < 0))\n\t\treturn -EIO;\n\t*len = ret;\n\treturn 0;\n}\n\nstatic int decode_compound_hdr(struct xdr_stream *xdr, struct compound_hdr *hdr)\n{\n\tssize_t ret;\n\tvoid *ptr;\n\tu32 tmp;\n\n\tif (xdr_stream_decode_u32(xdr, &tmp) < 0)\n\t\treturn -EIO;\n\thdr->status = tmp;\n\n\tret = xdr_stream_decode_opaque_inline(xdr, &ptr, NFS4_OPAQUE_LIMIT);\n\tif (ret < 0)\n\t\treturn -EIO;\n\thdr->taglen = ret;\n\thdr->tag = ptr;\n\n\tif (xdr_stream_decode_u32(xdr, &tmp) < 0)\n\t\treturn -EIO;\n\thdr->nops = tmp;\n\tif (unlikely(hdr->nops < 1))\n\t\treturn nfs4_stat_to_errno(hdr->status);\n\treturn 0;\n}\n\nstatic bool __decode_op_hdr(struct xdr_stream *xdr, enum nfs_opnum4 expected,\n\t\tint *nfs_retval)\n{\n\t__be32 *p;\n\tuint32_t opnum;\n\tint32_t nfserr;\n\n\tp = xdr_inline_decode(xdr, 8);\n\tif (unlikely(!p))\n\t\tgoto out_overflow;\n\topnum = be32_to_cpup(p++);\n\tif (unlikely(opnum != expected))\n\t\tgoto out_bad_operation;\n\tif (unlikely(*p != cpu_to_be32(NFS_OK)))\n\t\tgoto out_status;\n\t*nfs_retval = 0;\n\treturn true;\nout_status:\n\tnfserr = be32_to_cpup(p);\n\ttrace_nfs4_xdr_status(xdr, opnum, nfserr);\n\t*nfs_retval = nfs4_stat_to_errno(nfserr);\n\treturn true;\nout_bad_operation:\n\ttrace_nfs4_xdr_bad_operation(xdr, opnum, expected);\n\t*nfs_retval = -EREMOTEIO;\n\treturn false;\nout_overflow:\n\t*nfs_retval = -EIO;\n\treturn false;\n}\n\nstatic int decode_op_hdr(struct xdr_stream *xdr, enum nfs_opnum4 expected)\n{\n\tint retval;\n\n\t__decode_op_hdr(xdr, expected, &retval);\n\treturn retval;\n}\n\n \nstatic int decode_ace(struct xdr_stream *xdr, void *ace)\n{\n\t__be32 *p;\n\tunsigned int strlen;\n\tchar *str;\n\n\tp = xdr_inline_decode(xdr, 12);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\treturn decode_opaque_inline(xdr, &strlen, &str);\n}\n\nstatic ssize_t\ndecode_bitmap4(struct xdr_stream *xdr, uint32_t *bitmap, size_t sz)\n{\n\tssize_t ret;\n\n\tret = xdr_stream_decode_uint32_array(xdr, bitmap, sz);\n\tif (likely(ret >= 0))\n\t\treturn ret;\n\tif (ret != -EMSGSIZE)\n\t\treturn -EIO;\n\treturn sz;\n}\n\nstatic int decode_attr_bitmap(struct xdr_stream *xdr, uint32_t *bitmap)\n{\n\tssize_t ret;\n\tret = decode_bitmap4(xdr, bitmap, 3);\n\treturn ret < 0 ? ret : 0;\n}\n\nstatic int decode_attr_length(struct xdr_stream *xdr, uint32_t *attrlen, unsigned int *savep)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\t*attrlen = be32_to_cpup(p);\n\t*savep = xdr_stream_pos(xdr);\n\treturn 0;\n}\n\nstatic int decode_attr_supported(struct xdr_stream *xdr, uint32_t *bitmap, uint32_t *bitmask)\n{\n\tif (likely(bitmap[0] & FATTR4_WORD0_SUPPORTED_ATTRS)) {\n\t\tint ret;\n\t\tret = decode_attr_bitmap(xdr, bitmask);\n\t\tif (unlikely(ret < 0))\n\t\t\treturn ret;\n\t\tbitmap[0] &= ~FATTR4_WORD0_SUPPORTED_ATTRS;\n\t} else\n\t\tbitmask[0] = bitmask[1] = bitmask[2] = 0;\n\tdprintk(\"%s: bitmask=%08x:%08x:%08x\\n\", __func__,\n\t\tbitmask[0], bitmask[1], bitmask[2]);\n\treturn 0;\n}\n\nstatic int decode_attr_type(struct xdr_stream *xdr, uint32_t *bitmap, uint32_t *type)\n{\n\t__be32 *p;\n\tint ret = 0;\n\n\t*type = 0;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_TYPE - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_TYPE)) {\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\t*type = be32_to_cpup(p);\n\t\tif (*type < NF4REG || *type > NF4NAMEDATTR) {\n\t\t\tdprintk(\"%s: bad type %d\\n\", __func__, *type);\n\t\t\treturn -EIO;\n\t\t}\n\t\tbitmap[0] &= ~FATTR4_WORD0_TYPE;\n\t\tret = NFS_ATTR_FATTR_TYPE;\n\t}\n\tdprintk(\"%s: type=0%o\\n\", __func__, nfs_type2fmt[*type]);\n\treturn ret;\n}\n\nstatic int decode_attr_fh_expire_type(struct xdr_stream *xdr,\n\t\t\t\t      uint32_t *bitmap, uint32_t *type)\n{\n\t__be32 *p;\n\n\t*type = 0;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_FH_EXPIRE_TYPE - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_FH_EXPIRE_TYPE)) {\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\t*type = be32_to_cpup(p);\n\t\tbitmap[0] &= ~FATTR4_WORD0_FH_EXPIRE_TYPE;\n\t}\n\tdprintk(\"%s: expire type=0x%x\\n\", __func__, *type);\n\treturn 0;\n}\n\nstatic int decode_attr_change(struct xdr_stream *xdr, uint32_t *bitmap, uint64_t *change)\n{\n\t__be32 *p;\n\tint ret = 0;\n\n\t*change = 0;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_CHANGE - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_CHANGE)) {\n\t\tp = xdr_inline_decode(xdr, 8);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\txdr_decode_hyper(p, change);\n\t\tbitmap[0] &= ~FATTR4_WORD0_CHANGE;\n\t\tret = NFS_ATTR_FATTR_CHANGE;\n\t}\n\tdprintk(\"%s: change attribute=%Lu\\n\", __func__,\n\t\t\t(unsigned long long)*change);\n\treturn ret;\n}\n\nstatic int decode_attr_size(struct xdr_stream *xdr, uint32_t *bitmap, uint64_t *size)\n{\n\t__be32 *p;\n\tint ret = 0;\n\n\t*size = 0;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_SIZE - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_SIZE)) {\n\t\tp = xdr_inline_decode(xdr, 8);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\txdr_decode_hyper(p, size);\n\t\tbitmap[0] &= ~FATTR4_WORD0_SIZE;\n\t\tret = NFS_ATTR_FATTR_SIZE;\n\t}\n\tdprintk(\"%s: file size=%Lu\\n\", __func__, (unsigned long long)*size);\n\treturn ret;\n}\n\nstatic int decode_attr_link_support(struct xdr_stream *xdr, uint32_t *bitmap, uint32_t *res)\n{\n\t__be32 *p;\n\n\t*res = 0;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_LINK_SUPPORT - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_LINK_SUPPORT)) {\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\t*res = be32_to_cpup(p);\n\t\tbitmap[0] &= ~FATTR4_WORD0_LINK_SUPPORT;\n\t}\n\tdprintk(\"%s: link support=%s\\n\", __func__, *res == 0 ? \"false\" : \"true\");\n\treturn 0;\n}\n\nstatic int decode_attr_symlink_support(struct xdr_stream *xdr, uint32_t *bitmap, uint32_t *res)\n{\n\t__be32 *p;\n\n\t*res = 0;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_SYMLINK_SUPPORT - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_SYMLINK_SUPPORT)) {\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\t*res = be32_to_cpup(p);\n\t\tbitmap[0] &= ~FATTR4_WORD0_SYMLINK_SUPPORT;\n\t}\n\tdprintk(\"%s: symlink support=%s\\n\", __func__, *res == 0 ? \"false\" : \"true\");\n\treturn 0;\n}\n\nstatic int decode_attr_fsid(struct xdr_stream *xdr, uint32_t *bitmap, struct nfs_fsid *fsid)\n{\n\t__be32 *p;\n\tint ret = 0;\n\n\tfsid->major = 0;\n\tfsid->minor = 0;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_FSID - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_FSID)) {\n\t\tp = xdr_inline_decode(xdr, 16);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\tp = xdr_decode_hyper(p, &fsid->major);\n\t\txdr_decode_hyper(p, &fsid->minor);\n\t\tbitmap[0] &= ~FATTR4_WORD0_FSID;\n\t\tret = NFS_ATTR_FATTR_FSID;\n\t}\n\tdprintk(\"%s: fsid=(0x%Lx/0x%Lx)\\n\", __func__,\n\t\t\t(unsigned long long)fsid->major,\n\t\t\t(unsigned long long)fsid->minor);\n\treturn ret;\n}\n\nstatic int decode_attr_lease_time(struct xdr_stream *xdr, uint32_t *bitmap, uint32_t *res)\n{\n\t__be32 *p;\n\n\t*res = 60;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_LEASE_TIME - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_LEASE_TIME)) {\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\t*res = be32_to_cpup(p);\n\t\tbitmap[0] &= ~FATTR4_WORD0_LEASE_TIME;\n\t}\n\tdprintk(\"%s: lease time=%u\\n\", __func__, (unsigned int)*res);\n\treturn 0;\n}\n\nstatic int decode_attr_error(struct xdr_stream *xdr, uint32_t *bitmap, int32_t *res)\n{\n\t__be32 *p;\n\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_RDATTR_ERROR - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_RDATTR_ERROR)) {\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\tbitmap[0] &= ~FATTR4_WORD0_RDATTR_ERROR;\n\t\t*res = -be32_to_cpup(p);\n\t}\n\treturn 0;\n}\n\nstatic int decode_attr_exclcreat_supported(struct xdr_stream *xdr,\n\t\t\t\t uint32_t *bitmap, uint32_t *bitmask)\n{\n\tif (likely(bitmap[2] & FATTR4_WORD2_SUPPATTR_EXCLCREAT)) {\n\t\tint ret;\n\t\tret = decode_attr_bitmap(xdr, bitmask);\n\t\tif (unlikely(ret < 0))\n\t\t\treturn ret;\n\t\tbitmap[2] &= ~FATTR4_WORD2_SUPPATTR_EXCLCREAT;\n\t} else\n\t\tbitmask[0] = bitmask[1] = bitmask[2] = 0;\n\tdprintk(\"%s: bitmask=%08x:%08x:%08x\\n\", __func__,\n\t\tbitmask[0], bitmask[1], bitmask[2]);\n\treturn 0;\n}\n\nstatic int decode_attr_filehandle(struct xdr_stream *xdr, uint32_t *bitmap, struct nfs_fh *fh)\n{\n\t__be32 *p;\n\tu32 len;\n\n\tif (fh != NULL)\n\t\tmemset(fh, 0, sizeof(*fh));\n\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_FILEHANDLE - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_FILEHANDLE)) {\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\tlen = be32_to_cpup(p);\n\t\tif (len > NFS4_FHSIZE || len == 0) {\n\t\t\ttrace_nfs4_xdr_bad_filehandle(xdr, OP_READDIR,\n\t\t\t\t\t\t      NFS4ERR_BADHANDLE);\n\t\t\treturn -EREMOTEIO;\n\t\t}\n\t\tp = xdr_inline_decode(xdr, len);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\tif (fh != NULL) {\n\t\t\tmemcpy(fh->data, p, len);\n\t\t\tfh->size = len;\n\t\t}\n\t\tbitmap[0] &= ~FATTR4_WORD0_FILEHANDLE;\n\t}\n\treturn 0;\n}\n\nstatic int decode_attr_aclsupport(struct xdr_stream *xdr, uint32_t *bitmap, uint32_t *res)\n{\n\t__be32 *p;\n\n\t*res = 0;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_ACLSUPPORT - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_ACLSUPPORT)) {\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\t*res = be32_to_cpup(p);\n\t\tbitmap[0] &= ~FATTR4_WORD0_ACLSUPPORT;\n\t}\n\tdprintk(\"%s: ACLs supported=%u\\n\", __func__, (unsigned int)*res);\n\treturn 0;\n}\n\nstatic int decode_attr_case_insensitive(struct xdr_stream *xdr, uint32_t *bitmap, uint32_t *res)\n{\n\t__be32 *p;\n\n\t*res = 0;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_CASE_INSENSITIVE - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_CASE_INSENSITIVE)) {\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\t*res = be32_to_cpup(p);\n\t\tbitmap[0] &= ~FATTR4_WORD0_CASE_INSENSITIVE;\n\t}\n\tdprintk(\"%s: case_insensitive=%s\\n\", __func__, *res == 0 ? \"false\" : \"true\");\n\treturn 0;\n}\n\nstatic int decode_attr_case_preserving(struct xdr_stream *xdr, uint32_t *bitmap, uint32_t *res)\n{\n\t__be32 *p;\n\n\t*res = 0;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_CASE_PRESERVING - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_CASE_PRESERVING)) {\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\t*res = be32_to_cpup(p);\n\t\tbitmap[0] &= ~FATTR4_WORD0_CASE_PRESERVING;\n\t}\n\tdprintk(\"%s: case_preserving=%s\\n\", __func__, *res == 0 ? \"false\" : \"true\");\n\treturn 0;\n}\n\nstatic int decode_attr_fileid(struct xdr_stream *xdr, uint32_t *bitmap, uint64_t *fileid)\n{\n\t__be32 *p;\n\tint ret = 0;\n\n\t*fileid = 0;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_FILEID - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_FILEID)) {\n\t\tp = xdr_inline_decode(xdr, 8);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\txdr_decode_hyper(p, fileid);\n\t\tbitmap[0] &= ~FATTR4_WORD0_FILEID;\n\t\tret = NFS_ATTR_FATTR_FILEID;\n\t}\n\tdprintk(\"%s: fileid=%Lu\\n\", __func__, (unsigned long long)*fileid);\n\treturn ret;\n}\n\nstatic int decode_attr_mounted_on_fileid(struct xdr_stream *xdr, uint32_t *bitmap, uint64_t *fileid)\n{\n\t__be32 *p;\n\tint ret = 0;\n\n\t*fileid = 0;\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_MOUNTED_ON_FILEID - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[1] & FATTR4_WORD1_MOUNTED_ON_FILEID)) {\n\t\tp = xdr_inline_decode(xdr, 8);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\txdr_decode_hyper(p, fileid);\n\t\tbitmap[1] &= ~FATTR4_WORD1_MOUNTED_ON_FILEID;\n\t\tret = NFS_ATTR_FATTR_MOUNTED_ON_FILEID;\n\t}\n\tdprintk(\"%s: fileid=%Lu\\n\", __func__, (unsigned long long)*fileid);\n\treturn ret;\n}\n\nstatic int decode_attr_files_avail(struct xdr_stream *xdr, uint32_t *bitmap, uint64_t *res)\n{\n\t__be32 *p;\n\tint status = 0;\n\n\t*res = 0;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_FILES_AVAIL - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_FILES_AVAIL)) {\n\t\tp = xdr_inline_decode(xdr, 8);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\txdr_decode_hyper(p, res);\n\t\tbitmap[0] &= ~FATTR4_WORD0_FILES_AVAIL;\n\t}\n\tdprintk(\"%s: files avail=%Lu\\n\", __func__, (unsigned long long)*res);\n\treturn status;\n}\n\nstatic int decode_attr_files_free(struct xdr_stream *xdr, uint32_t *bitmap, uint64_t *res)\n{\n\t__be32 *p;\n\tint status = 0;\n\n\t*res = 0;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_FILES_FREE - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_FILES_FREE)) {\n\t\tp = xdr_inline_decode(xdr, 8);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\txdr_decode_hyper(p, res);\n\t\tbitmap[0] &= ~FATTR4_WORD0_FILES_FREE;\n\t}\n\tdprintk(\"%s: files free=%Lu\\n\", __func__, (unsigned long long)*res);\n\treturn status;\n}\n\nstatic int decode_attr_files_total(struct xdr_stream *xdr, uint32_t *bitmap, uint64_t *res)\n{\n\t__be32 *p;\n\tint status = 0;\n\n\t*res = 0;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_FILES_TOTAL - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_FILES_TOTAL)) {\n\t\tp = xdr_inline_decode(xdr, 8);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\txdr_decode_hyper(p, res);\n\t\tbitmap[0] &= ~FATTR4_WORD0_FILES_TOTAL;\n\t}\n\tdprintk(\"%s: files total=%Lu\\n\", __func__, (unsigned long long)*res);\n\treturn status;\n}\n\nstatic int decode_pathname(struct xdr_stream *xdr, struct nfs4_pathname *path)\n{\n\tu32 n;\n\t__be32 *p;\n\tint status = 0;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tn = be32_to_cpup(p);\n\tif (n == 0)\n\t\tgoto root_path;\n\tdprintk(\"pathname4: \");\n\tif (n > NFS4_PATHNAME_MAXCOMPONENTS) {\n\t\tdprintk(\"cannot parse %d components in path\\n\", n);\n\t\tgoto out_eio;\n\t}\n\tfor (path->ncomponents = 0; path->ncomponents < n; path->ncomponents++) {\n\t\tstruct nfs4_string *component = &path->components[path->ncomponents];\n\t\tstatus = decode_opaque_inline(xdr, &component->len, &component->data);\n\t\tif (unlikely(status != 0))\n\t\t\tgoto out_eio;\n\t\tifdebug (XDR)\n\t\t\tpr_cont(\"%s%.*s \",\n\t\t\t\t(path->ncomponents != n ? \"/ \" : \"\"),\n\t\t\t\tcomponent->len, component->data);\n\t}\nout:\n\treturn status;\nroot_path:\n \n\tpath->ncomponents = 1;\n\tpath->components[0].len=0;\n\tpath->components[0].data=NULL;\n\tdprintk(\"pathname4: /\\n\");\n\tgoto out;\nout_eio:\n\tdprintk(\" status %d\", status);\n\tstatus = -EIO;\n\tgoto out;\n}\n\nstatic int decode_attr_fs_locations(struct xdr_stream *xdr, uint32_t *bitmap, struct nfs4_fs_locations *res)\n{\n\tint n;\n\t__be32 *p;\n\tint status = -EIO;\n\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_FS_LOCATIONS -1U)))\n\t\tgoto out;\n\tstatus = 0;\n\tif (unlikely(!(bitmap[0] & FATTR4_WORD0_FS_LOCATIONS)))\n\t\tgoto out;\n\tbitmap[0] &= ~FATTR4_WORD0_FS_LOCATIONS;\n\tstatus = -EIO;\n\t \n\tif (unlikely(res == NULL))\n\t\tgoto out;\n\tdprintk(\"%s: fsroot:\\n\", __func__);\n\tstatus = decode_pathname(xdr, &res->fs_path);\n\tif (unlikely(status != 0))\n\t\tgoto out;\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\tgoto out_eio;\n\tn = be32_to_cpup(p);\n\tfor (res->nlocations = 0; res->nlocations < n; res->nlocations++) {\n\t\tu32 m;\n\t\tstruct nfs4_fs_location *loc;\n\n\t\tif (res->nlocations == NFS4_FS_LOCATIONS_MAXENTRIES)\n\t\t\tbreak;\n\t\tloc = &res->locations[res->nlocations];\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\tgoto out_eio;\n\t\tm = be32_to_cpup(p);\n\n\t\tdprintk(\"%s: servers:\\n\", __func__);\n\t\tfor (loc->nservers = 0; loc->nservers < m; loc->nservers++) {\n\t\t\tstruct nfs4_string *server;\n\n\t\t\tif (loc->nservers == NFS4_FS_LOCATION_MAXSERVERS) {\n\t\t\t\tunsigned int i;\n\t\t\t\tdprintk(\"%s: using first %u of %u servers \"\n\t\t\t\t\t\"returned for location %u\\n\",\n\t\t\t\t\t\t__func__,\n\t\t\t\t\t\tNFS4_FS_LOCATION_MAXSERVERS,\n\t\t\t\t\t\tm, res->nlocations);\n\t\t\t\tfor (i = loc->nservers; i < m; i++) {\n\t\t\t\t\tunsigned int len;\n\t\t\t\t\tchar *data;\n\t\t\t\t\tstatus = decode_opaque_inline(xdr, &len, &data);\n\t\t\t\t\tif (unlikely(status != 0))\n\t\t\t\t\t\tgoto out_eio;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tserver = &loc->servers[loc->nservers];\n\t\t\tstatus = decode_opaque_inline(xdr, &server->len, &server->data);\n\t\t\tif (unlikely(status != 0))\n\t\t\t\tgoto out_eio;\n\t\t\tdprintk(\"%s \", server->data);\n\t\t}\n\t\tstatus = decode_pathname(xdr, &loc->rootpath);\n\t\tif (unlikely(status != 0))\n\t\t\tgoto out_eio;\n\t}\n\tif (res->nlocations != 0)\n\t\tstatus = NFS_ATTR_FATTR_V4_LOCATIONS;\nout:\n\tdprintk(\"%s: fs_locations done, error = %d\\n\", __func__, status);\n\treturn status;\nout_eio:\n\tstatus = -EIO;\n\tgoto out;\n}\n\nstatic int decode_attr_maxfilesize(struct xdr_stream *xdr, uint32_t *bitmap, uint64_t *res)\n{\n\t__be32 *p;\n\tint status = 0;\n\n\t*res = 0;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_MAXFILESIZE - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_MAXFILESIZE)) {\n\t\tp = xdr_inline_decode(xdr, 8);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\txdr_decode_hyper(p, res);\n\t\tbitmap[0] &= ~FATTR4_WORD0_MAXFILESIZE;\n\t}\n\tdprintk(\"%s: maxfilesize=%Lu\\n\", __func__, (unsigned long long)*res);\n\treturn status;\n}\n\nstatic int decode_attr_maxlink(struct xdr_stream *xdr, uint32_t *bitmap, uint32_t *maxlink)\n{\n\t__be32 *p;\n\tint status = 0;\n\n\t*maxlink = 1;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_MAXLINK - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_MAXLINK)) {\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\t*maxlink = be32_to_cpup(p);\n\t\tbitmap[0] &= ~FATTR4_WORD0_MAXLINK;\n\t}\n\tdprintk(\"%s: maxlink=%u\\n\", __func__, *maxlink);\n\treturn status;\n}\n\nstatic int decode_attr_maxname(struct xdr_stream *xdr, uint32_t *bitmap, uint32_t *maxname)\n{\n\t__be32 *p;\n\tint status = 0;\n\n\t*maxname = 1024;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_MAXNAME - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_MAXNAME)) {\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\t*maxname = be32_to_cpup(p);\n\t\tbitmap[0] &= ~FATTR4_WORD0_MAXNAME;\n\t}\n\tdprintk(\"%s: maxname=%u\\n\", __func__, *maxname);\n\treturn status;\n}\n\nstatic int decode_attr_maxread(struct xdr_stream *xdr, uint32_t *bitmap, uint32_t *res)\n{\n\t__be32 *p;\n\tint status = 0;\n\n\t*res = 1024;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_MAXREAD - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_MAXREAD)) {\n\t\tuint64_t maxread;\n\t\tp = xdr_inline_decode(xdr, 8);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\txdr_decode_hyper(p, &maxread);\n\t\tif (maxread > 0x7FFFFFFF)\n\t\t\tmaxread = 0x7FFFFFFF;\n\t\t*res = (uint32_t)maxread;\n\t\tbitmap[0] &= ~FATTR4_WORD0_MAXREAD;\n\t}\n\tdprintk(\"%s: maxread=%lu\\n\", __func__, (unsigned long)*res);\n\treturn status;\n}\n\nstatic int decode_attr_maxwrite(struct xdr_stream *xdr, uint32_t *bitmap, uint32_t *res)\n{\n\t__be32 *p;\n\tint status = 0;\n\n\t*res = 1024;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_MAXWRITE - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_MAXWRITE)) {\n\t\tuint64_t maxwrite;\n\t\tp = xdr_inline_decode(xdr, 8);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\txdr_decode_hyper(p, &maxwrite);\n\t\tif (maxwrite > 0x7FFFFFFF)\n\t\t\tmaxwrite = 0x7FFFFFFF;\n\t\t*res = (uint32_t)maxwrite;\n\t\tbitmap[0] &= ~FATTR4_WORD0_MAXWRITE;\n\t}\n\tdprintk(\"%s: maxwrite=%lu\\n\", __func__, (unsigned long)*res);\n\treturn status;\n}\n\nstatic int decode_attr_mode(struct xdr_stream *xdr, uint32_t *bitmap, umode_t *mode)\n{\n\tuint32_t tmp;\n\t__be32 *p;\n\tint ret = 0;\n\n\t*mode = 0;\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_MODE - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[1] & FATTR4_WORD1_MODE)) {\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\ttmp = be32_to_cpup(p);\n\t\t*mode = tmp & ~S_IFMT;\n\t\tbitmap[1] &= ~FATTR4_WORD1_MODE;\n\t\tret = NFS_ATTR_FATTR_MODE;\n\t}\n\tdprintk(\"%s: file mode=0%o\\n\", __func__, (unsigned int)*mode);\n\treturn ret;\n}\n\nstatic int decode_attr_nlink(struct xdr_stream *xdr, uint32_t *bitmap, uint32_t *nlink)\n{\n\t__be32 *p;\n\tint ret = 0;\n\n\t*nlink = 1;\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_NUMLINKS - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[1] & FATTR4_WORD1_NUMLINKS)) {\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\t*nlink = be32_to_cpup(p);\n\t\tbitmap[1] &= ~FATTR4_WORD1_NUMLINKS;\n\t\tret = NFS_ATTR_FATTR_NLINK;\n\t}\n\tdprintk(\"%s: nlink=%u\\n\", __func__, (unsigned int)*nlink);\n\treturn ret;\n}\n\nstatic ssize_t decode_nfs4_string(struct xdr_stream *xdr,\n\t\tstruct nfs4_string *name, gfp_t gfp_flags)\n{\n\tssize_t ret;\n\n\tret = xdr_stream_decode_string_dup(xdr, &name->data,\n\t\t\tXDR_MAX_NETOBJ, gfp_flags);\n\tname->len = 0;\n\tif (ret > 0)\n\t\tname->len = ret;\n\treturn ret;\n}\n\nstatic int decode_attr_owner(struct xdr_stream *xdr, uint32_t *bitmap,\n\t\tconst struct nfs_server *server, kuid_t *uid,\n\t\tstruct nfs4_string *owner_name)\n{\n\tssize_t len;\n\tchar *p;\n\n\t*uid = make_kuid(&init_user_ns, -2);\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_OWNER - 1U)))\n\t\treturn -EIO;\n\tif (!(bitmap[1] & FATTR4_WORD1_OWNER))\n\t\treturn 0;\n\tbitmap[1] &= ~FATTR4_WORD1_OWNER;\n\n\tif (owner_name != NULL) {\n\t\tlen = decode_nfs4_string(xdr, owner_name, GFP_NOIO);\n\t\tif (len <= 0)\n\t\t\tgoto out;\n\t\tdprintk(\"%s: name=%s\\n\", __func__, owner_name->data);\n\t\treturn NFS_ATTR_FATTR_OWNER_NAME;\n\t} else {\n\t\tlen = xdr_stream_decode_opaque_inline(xdr, (void **)&p,\n\t\t\t\tXDR_MAX_NETOBJ);\n\t\tif (len <= 0 || nfs_map_name_to_uid(server, p, len, uid) != 0)\n\t\t\tgoto out;\n\t\tdprintk(\"%s: uid=%d\\n\", __func__, (int)from_kuid(&init_user_ns, *uid));\n\t\treturn NFS_ATTR_FATTR_OWNER;\n\t}\nout:\n\tif (len == -EBADMSG)\n\t\treturn -EIO;\n\treturn 0;\n}\n\nstatic int decode_attr_group(struct xdr_stream *xdr, uint32_t *bitmap,\n\t\tconst struct nfs_server *server, kgid_t *gid,\n\t\tstruct nfs4_string *group_name)\n{\n\tssize_t len;\n\tchar *p;\n\n\t*gid = make_kgid(&init_user_ns, -2);\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_OWNER_GROUP - 1U)))\n\t\treturn -EIO;\n\tif (!(bitmap[1] & FATTR4_WORD1_OWNER_GROUP))\n\t\treturn 0;\n\tbitmap[1] &= ~FATTR4_WORD1_OWNER_GROUP;\n\n\tif (group_name != NULL) {\n\t\tlen = decode_nfs4_string(xdr, group_name, GFP_NOIO);\n\t\tif (len <= 0)\n\t\t\tgoto out;\n\t\tdprintk(\"%s: name=%s\\n\", __func__, group_name->data);\n\t\treturn NFS_ATTR_FATTR_GROUP_NAME;\n\t} else {\n\t\tlen = xdr_stream_decode_opaque_inline(xdr, (void **)&p,\n\t\t\t\tXDR_MAX_NETOBJ);\n\t\tif (len <= 0 || nfs_map_group_to_gid(server, p, len, gid) != 0)\n\t\t\tgoto out;\n\t\tdprintk(\"%s: gid=%d\\n\", __func__, (int)from_kgid(&init_user_ns, *gid));\n\t\treturn NFS_ATTR_FATTR_GROUP;\n\t}\nout:\n\tif (len == -EBADMSG)\n\t\treturn -EIO;\n\treturn 0;\n}\n\nstatic int decode_attr_rdev(struct xdr_stream *xdr, uint32_t *bitmap, dev_t *rdev)\n{\n\tuint32_t major = 0, minor = 0;\n\t__be32 *p;\n\tint ret = 0;\n\n\t*rdev = MKDEV(0,0);\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_RAWDEV - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[1] & FATTR4_WORD1_RAWDEV)) {\n\t\tdev_t tmp;\n\n\t\tp = xdr_inline_decode(xdr, 8);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\tmajor = be32_to_cpup(p++);\n\t\tminor = be32_to_cpup(p);\n\t\ttmp = MKDEV(major, minor);\n\t\tif (MAJOR(tmp) == major && MINOR(tmp) == minor)\n\t\t\t*rdev = tmp;\n\t\tbitmap[1] &= ~ FATTR4_WORD1_RAWDEV;\n\t\tret = NFS_ATTR_FATTR_RDEV;\n\t}\n\tdprintk(\"%s: rdev=(0x%x:0x%x)\\n\", __func__, major, minor);\n\treturn ret;\n}\n\nstatic int decode_attr_space_avail(struct xdr_stream *xdr, uint32_t *bitmap, uint64_t *res)\n{\n\t__be32 *p;\n\tint status = 0;\n\n\t*res = 0;\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_SPACE_AVAIL - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[1] & FATTR4_WORD1_SPACE_AVAIL)) {\n\t\tp = xdr_inline_decode(xdr, 8);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\txdr_decode_hyper(p, res);\n\t\tbitmap[1] &= ~FATTR4_WORD1_SPACE_AVAIL;\n\t}\n\tdprintk(\"%s: space avail=%Lu\\n\", __func__, (unsigned long long)*res);\n\treturn status;\n}\n\nstatic int decode_attr_space_free(struct xdr_stream *xdr, uint32_t *bitmap, uint64_t *res)\n{\n\t__be32 *p;\n\tint status = 0;\n\n\t*res = 0;\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_SPACE_FREE - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[1] & FATTR4_WORD1_SPACE_FREE)) {\n\t\tp = xdr_inline_decode(xdr, 8);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\txdr_decode_hyper(p, res);\n\t\tbitmap[1] &= ~FATTR4_WORD1_SPACE_FREE;\n\t}\n\tdprintk(\"%s: space free=%Lu\\n\", __func__, (unsigned long long)*res);\n\treturn status;\n}\n\nstatic int decode_attr_space_total(struct xdr_stream *xdr, uint32_t *bitmap, uint64_t *res)\n{\n\t__be32 *p;\n\tint status = 0;\n\n\t*res = 0;\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_SPACE_TOTAL - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[1] & FATTR4_WORD1_SPACE_TOTAL)) {\n\t\tp = xdr_inline_decode(xdr, 8);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\txdr_decode_hyper(p, res);\n\t\tbitmap[1] &= ~FATTR4_WORD1_SPACE_TOTAL;\n\t}\n\tdprintk(\"%s: space total=%Lu\\n\", __func__, (unsigned long long)*res);\n\treturn status;\n}\n\nstatic int decode_attr_space_used(struct xdr_stream *xdr, uint32_t *bitmap, uint64_t *used)\n{\n\t__be32 *p;\n\tint ret = 0;\n\n\t*used = 0;\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_SPACE_USED - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[1] & FATTR4_WORD1_SPACE_USED)) {\n\t\tp = xdr_inline_decode(xdr, 8);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\txdr_decode_hyper(p, used);\n\t\tbitmap[1] &= ~FATTR4_WORD1_SPACE_USED;\n\t\tret = NFS_ATTR_FATTR_SPACE_USED;\n\t}\n\tdprintk(\"%s: space used=%Lu\\n\", __func__,\n\t\t\t(unsigned long long)*used);\n\treturn ret;\n}\n\nstatic __be32 *\nxdr_decode_nfstime4(__be32 *p, struct timespec64 *t)\n{\n\t__u64 sec;\n\n\tp = xdr_decode_hyper(p, &sec);\n\tt-> tv_sec = sec;\n\tt->tv_nsec = be32_to_cpup(p++);\n\treturn p;\n}\n\nstatic int decode_attr_time(struct xdr_stream *xdr, struct timespec64 *time)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, nfstime4_maxsz << 2);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\txdr_decode_nfstime4(p, time);\n\treturn 0;\n}\n\nstatic int decode_attr_time_access(struct xdr_stream *xdr, uint32_t *bitmap, struct timespec64 *time)\n{\n\tint status = 0;\n\n\ttime->tv_sec = 0;\n\ttime->tv_nsec = 0;\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_TIME_ACCESS - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[1] & FATTR4_WORD1_TIME_ACCESS)) {\n\t\tstatus = decode_attr_time(xdr, time);\n\t\tif (status == 0)\n\t\t\tstatus = NFS_ATTR_FATTR_ATIME;\n\t\tbitmap[1] &= ~FATTR4_WORD1_TIME_ACCESS;\n\t}\n\tdprintk(\"%s: atime=%lld\\n\", __func__, time->tv_sec);\n\treturn status;\n}\n\nstatic int decode_attr_time_metadata(struct xdr_stream *xdr, uint32_t *bitmap, struct timespec64 *time)\n{\n\tint status = 0;\n\n\ttime->tv_sec = 0;\n\ttime->tv_nsec = 0;\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_TIME_METADATA - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[1] & FATTR4_WORD1_TIME_METADATA)) {\n\t\tstatus = decode_attr_time(xdr, time);\n\t\tif (status == 0)\n\t\t\tstatus = NFS_ATTR_FATTR_CTIME;\n\t\tbitmap[1] &= ~FATTR4_WORD1_TIME_METADATA;\n\t}\n\tdprintk(\"%s: ctime=%lld\\n\", __func__, time->tv_sec);\n\treturn status;\n}\n\nstatic int decode_attr_time_delta(struct xdr_stream *xdr, uint32_t *bitmap,\n\t\t\t\t  struct timespec64 *time)\n{\n\tint status = 0;\n\n\ttime->tv_sec = 0;\n\ttime->tv_nsec = 0;\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_TIME_DELTA - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[1] & FATTR4_WORD1_TIME_DELTA)) {\n\t\tstatus = decode_attr_time(xdr, time);\n\t\tbitmap[1] &= ~FATTR4_WORD1_TIME_DELTA;\n\t}\n\tdprintk(\"%s: time_delta=%lld %ld\\n\", __func__, time->tv_sec,\n\t\ttime->tv_nsec);\n\treturn status;\n}\n\nstatic int decode_attr_security_label(struct xdr_stream *xdr, uint32_t *bitmap,\n\t\t\t\t\tstruct nfs4_label *label)\n{\n\tuint32_t pi = 0;\n\tuint32_t lfs = 0;\n\t__u32 len;\n\t__be32 *p;\n\tint status = 0;\n\n\tif (unlikely(bitmap[2] & (FATTR4_WORD2_SECURITY_LABEL - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[2] & FATTR4_WORD2_SECURITY_LABEL)) {\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\tlfs = be32_to_cpup(p++);\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\tpi = be32_to_cpup(p++);\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\tlen = be32_to_cpup(p++);\n\t\tp = xdr_inline_decode(xdr, len);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\tbitmap[2] &= ~FATTR4_WORD2_SECURITY_LABEL;\n\t\tif (len < NFS4_MAXLABELLEN) {\n\t\t\tif (label && label->len) {\n\t\t\t\tif (label->len < len)\n\t\t\t\t\treturn -ERANGE;\n\t\t\t\tmemcpy(label->label, p, len);\n\t\t\t\tlabel->len = len;\n\t\t\t\tlabel->pi = pi;\n\t\t\t\tlabel->lfs = lfs;\n\t\t\t\tstatus = NFS_ATTR_FATTR_V4_SECURITY_LABEL;\n\t\t\t}\n\t\t} else\n\t\t\tprintk(KERN_WARNING \"%s: label too long (%u)!\\n\",\n\t\t\t\t\t__func__, len);\n\t\tif (label && label->label)\n\t\t\tdprintk(\"%s: label=%.*s, len=%d, PI=%d, LFS=%d\\n\",\n\t\t\t\t__func__, label->len, (char *)label->label,\n\t\t\t\tlabel->len, label->pi, label->lfs);\n\t}\n\treturn status;\n}\n\nstatic int decode_attr_time_modify(struct xdr_stream *xdr, uint32_t *bitmap, struct timespec64 *time)\n{\n\tint status = 0;\n\n\ttime->tv_sec = 0;\n\ttime->tv_nsec = 0;\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_TIME_MODIFY - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[1] & FATTR4_WORD1_TIME_MODIFY)) {\n\t\tstatus = decode_attr_time(xdr, time);\n\t\tif (status == 0)\n\t\t\tstatus = NFS_ATTR_FATTR_MTIME;\n\t\tbitmap[1] &= ~FATTR4_WORD1_TIME_MODIFY;\n\t}\n\tdprintk(\"%s: mtime=%lld\\n\", __func__, time->tv_sec);\n\treturn status;\n}\n\nstatic int decode_attr_xattrsupport(struct xdr_stream *xdr, uint32_t *bitmap,\n\t\t\t\t    uint32_t *res)\n{\n\t__be32 *p;\n\n\t*res = 0;\n\tif (unlikely(bitmap[2] & (FATTR4_WORD2_XATTR_SUPPORT - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[2] & FATTR4_WORD2_XATTR_SUPPORT)) {\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\t*res = be32_to_cpup(p);\n\t\tbitmap[2] &= ~FATTR4_WORD2_XATTR_SUPPORT;\n\t}\n\tdprintk(\"%s: XATTR support=%s\\n\", __func__,\n\t\t*res == 0 ? \"false\" : \"true\");\n\treturn 0;\n}\n\nstatic int verify_attr_len(struct xdr_stream *xdr, unsigned int savep, uint32_t attrlen)\n{\n\tunsigned int attrwords = XDR_QUADLEN(attrlen);\n\tunsigned int nwords = (xdr_stream_pos(xdr) - savep) >> 2;\n\n\tif (unlikely(attrwords != nwords)) {\n\t\tdprintk(\"%s: server returned incorrect attribute length: \"\n\t\t\t\"%u %c %u\\n\",\n\t\t\t\t__func__,\n\t\t\t\tattrwords << 2,\n\t\t\t\t(attrwords < nwords) ? '<' : '>',\n\t\t\t\tnwords << 2);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic int decode_change_info(struct xdr_stream *xdr, struct nfs4_change_info *cinfo)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 20);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tcinfo->atomic = be32_to_cpup(p++);\n\tp = xdr_decode_hyper(p, &cinfo->before);\n\txdr_decode_hyper(p, &cinfo->after);\n\treturn 0;\n}\n\nstatic int decode_access(struct xdr_stream *xdr, u32 *supported, u32 *access)\n{\n\t__be32 *p;\n\tuint32_t supp, acc;\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_ACCESS);\n\tif (status)\n\t\treturn status;\n\tp = xdr_inline_decode(xdr, 8);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tsupp = be32_to_cpup(p++);\n\tacc = be32_to_cpup(p);\n\t*supported = supp;\n\t*access = acc;\n\treturn 0;\n}\n\nstatic int decode_opaque_fixed(struct xdr_stream *xdr, void *buf, size_t len)\n{\n\tssize_t ret = xdr_stream_decode_opaque_fixed(xdr, buf, len);\n\tif (unlikely(ret < 0))\n\t\treturn -EIO;\n\treturn 0;\n}\n\nstatic int decode_stateid(struct xdr_stream *xdr, nfs4_stateid *stateid)\n{\n\treturn decode_opaque_fixed(xdr, stateid, NFS4_STATEID_SIZE);\n}\n\nstatic int decode_open_stateid(struct xdr_stream *xdr, nfs4_stateid *stateid)\n{\n\tstateid->type = NFS4_OPEN_STATEID_TYPE;\n\treturn decode_stateid(xdr, stateid);\n}\n\nstatic int decode_lock_stateid(struct xdr_stream *xdr, nfs4_stateid *stateid)\n{\n\tstateid->type = NFS4_LOCK_STATEID_TYPE;\n\treturn decode_stateid(xdr, stateid);\n}\n\nstatic int decode_delegation_stateid(struct xdr_stream *xdr, nfs4_stateid *stateid)\n{\n\tstateid->type = NFS4_DELEGATION_STATEID_TYPE;\n\treturn decode_stateid(xdr, stateid);\n}\n\nstatic int decode_invalid_stateid(struct xdr_stream *xdr, nfs4_stateid *stateid)\n{\n\tnfs4_stateid dummy;\n\n\tnfs4_stateid_copy(stateid, &invalid_stateid);\n\treturn decode_stateid(xdr, &dummy);\n}\n\nstatic int decode_close(struct xdr_stream *xdr, struct nfs_closeres *res)\n{\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_CLOSE);\n\tif (status != -EIO)\n\t\tnfs_increment_open_seqid(status, res->seqid);\n\tif (!status)\n\t\tstatus = decode_invalid_stateid(xdr, &res->stateid);\n\treturn status;\n}\n\nstatic int decode_verifier(struct xdr_stream *xdr, void *verifier)\n{\n\treturn decode_opaque_fixed(xdr, verifier, NFS4_VERIFIER_SIZE);\n}\n\nstatic int decode_write_verifier(struct xdr_stream *xdr, struct nfs_write_verifier *verifier)\n{\n\treturn decode_opaque_fixed(xdr, verifier->data, NFS4_VERIFIER_SIZE);\n}\n\nstatic int decode_commit(struct xdr_stream *xdr, struct nfs_commitres *res)\n{\n\tstruct nfs_writeverf *verf = res->verf;\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_COMMIT);\n\tif (!status)\n\t\tstatus = decode_write_verifier(xdr, &verf->verifier);\n\tif (!status)\n\t\tverf->committed = NFS_FILE_SYNC;\n\treturn status;\n}\n\nstatic int decode_create(struct xdr_stream *xdr, struct nfs4_change_info *cinfo)\n{\n\t__be32 *p;\n\tuint32_t bmlen;\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_CREATE);\n\tif (status)\n\t\treturn status;\n\tif ((status = decode_change_info(xdr, cinfo)))\n\t\treturn status;\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tbmlen = be32_to_cpup(p);\n\tp = xdr_inline_decode(xdr, bmlen << 2);\n\tif (likely(p))\n\t\treturn 0;\n\treturn -EIO;\n}\n\nstatic int decode_server_caps(struct xdr_stream *xdr, struct nfs4_server_caps_res *res)\n{\n\tunsigned int savep;\n\tuint32_t attrlen, bitmap[3] = {0};\n\tint status;\n\n\tif ((status = decode_op_hdr(xdr, OP_GETATTR)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_bitmap(xdr, bitmap)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_length(xdr, &attrlen, &savep)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_supported(xdr, bitmap, res->attr_bitmask)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_fh_expire_type(xdr, bitmap,\n\t\t\t\t\t\t &res->fh_expire_type)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_link_support(xdr, bitmap, &res->has_links)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_symlink_support(xdr, bitmap, &res->has_symlinks)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_aclsupport(xdr, bitmap, &res->acl_bitmask)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_case_insensitive(xdr, bitmap, &res->case_insensitive)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_case_preserving(xdr, bitmap, &res->case_preserving)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_exclcreat_supported(xdr, bitmap,\n\t\t\t\tres->exclcreat_bitmask)) != 0)\n\t\tgoto xdr_error;\n\tstatus = verify_attr_len(xdr, savep, attrlen);\nxdr_error:\n\tdprintk(\"%s: xdr returned %d!\\n\", __func__, -status);\n\treturn status;\n}\n\nstatic int decode_statfs(struct xdr_stream *xdr, struct nfs_fsstat *fsstat)\n{\n\tunsigned int savep;\n\tuint32_t attrlen, bitmap[3] = {0};\n\tint status;\n\n\tif ((status = decode_op_hdr(xdr, OP_GETATTR)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_bitmap(xdr, bitmap)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_length(xdr, &attrlen, &savep)) != 0)\n\t\tgoto xdr_error;\n\n\tif ((status = decode_attr_files_avail(xdr, bitmap, &fsstat->afiles)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_files_free(xdr, bitmap, &fsstat->ffiles)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_files_total(xdr, bitmap, &fsstat->tfiles)) != 0)\n\t\tgoto xdr_error;\n\n\tstatus = -EIO;\n\tif (unlikely(bitmap[0]))\n\t\tgoto xdr_error;\n\n\tif ((status = decode_attr_space_avail(xdr, bitmap, &fsstat->abytes)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_space_free(xdr, bitmap, &fsstat->fbytes)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_space_total(xdr, bitmap, &fsstat->tbytes)) != 0)\n\t\tgoto xdr_error;\n\n\tstatus = verify_attr_len(xdr, savep, attrlen);\nxdr_error:\n\tdprintk(\"%s: xdr returned %d!\\n\", __func__, -status);\n\treturn status;\n}\n\nstatic int decode_pathconf(struct xdr_stream *xdr, struct nfs_pathconf *pathconf)\n{\n\tunsigned int savep;\n\tuint32_t attrlen, bitmap[3] = {0};\n\tint status;\n\n\tif ((status = decode_op_hdr(xdr, OP_GETATTR)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_bitmap(xdr, bitmap)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_length(xdr, &attrlen, &savep)) != 0)\n\t\tgoto xdr_error;\n\n\tif ((status = decode_attr_maxlink(xdr, bitmap, &pathconf->max_link)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_maxname(xdr, bitmap, &pathconf->max_namelen)) != 0)\n\t\tgoto xdr_error;\n\n\tstatus = verify_attr_len(xdr, savep, attrlen);\nxdr_error:\n\tdprintk(\"%s: xdr returned %d!\\n\", __func__, -status);\n\treturn status;\n}\n\nstatic int decode_threshold_hint(struct xdr_stream *xdr,\n\t\t\t\t  uint32_t *bitmap,\n\t\t\t\t  uint64_t *res,\n\t\t\t\t  uint32_t hint_bit)\n{\n\t__be32 *p;\n\n\t*res = 0;\n\tif (likely(bitmap[0] & hint_bit)) {\n\t\tp = xdr_inline_decode(xdr, 8);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\txdr_decode_hyper(p, res);\n\t}\n\treturn 0;\n}\n\nstatic int decode_first_threshold_item4(struct xdr_stream *xdr,\n\t\t\t\t\tstruct nfs4_threshold *res)\n{\n\t__be32 *p;\n\tunsigned int savep;\n\tuint32_t bitmap[3] = {0,}, attrlen;\n\tint status;\n\n\t \n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tres->l_type = be32_to_cpup(p);\n\n\t \n\tstatus = decode_attr_bitmap(xdr, bitmap);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\n\t \n\tstatus = decode_attr_length(xdr, &attrlen, &savep);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\t \n\tstatus = decode_threshold_hint(xdr, bitmap, &res->rd_sz, THRESHOLD_RD);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\tstatus = decode_threshold_hint(xdr, bitmap, &res->wr_sz, THRESHOLD_WR);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\tstatus = decode_threshold_hint(xdr, bitmap, &res->rd_io_sz,\n\t\t\t\t       THRESHOLD_RD_IO);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\tstatus = decode_threshold_hint(xdr, bitmap, &res->wr_io_sz,\n\t\t\t\t       THRESHOLD_WR_IO);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\n\tstatus = verify_attr_len(xdr, savep, attrlen);\n\tres->bm = bitmap[0];\n\n\tdprintk(\"%s bm=0x%x rd_sz=%llu wr_sz=%llu rd_io=%llu wr_io=%llu\\n\",\n\t\t __func__, res->bm, res->rd_sz, res->wr_sz, res->rd_io_sz,\n\t\tres->wr_io_sz);\nxdr_error:\n\tdprintk(\"%s ret=%d!\\n\", __func__, status);\n\treturn status;\n}\n\n \nstatic int decode_attr_mdsthreshold(struct xdr_stream *xdr,\n\t\t\t\t    uint32_t *bitmap,\n\t\t\t\t    struct nfs4_threshold *res)\n{\n\t__be32 *p;\n\tint status = 0;\n\tuint32_t num;\n\n\tif (unlikely(bitmap[2] & (FATTR4_WORD2_MDSTHRESHOLD - 1U)))\n\t\treturn -EIO;\n\tif (bitmap[2] & FATTR4_WORD2_MDSTHRESHOLD) {\n\t\t \n\t\tif (unlikely(res == NULL))\n\t\t\treturn -EREMOTEIO;\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\tnum = be32_to_cpup(p);\n\t\tif (num == 0)\n\t\t\treturn 0;\n\t\tif (num > 1)\n\t\t\tprintk(KERN_INFO \"%s: Warning: Multiple pNFS layout \"\n\t\t\t\t\"drivers per filesystem not supported\\n\",\n\t\t\t\t__func__);\n\n\t\tstatus = decode_first_threshold_item4(xdr, res);\n\t\tbitmap[2] &= ~FATTR4_WORD2_MDSTHRESHOLD;\n\t}\n\treturn status;\n}\n\nstatic int decode_getfattr_attrs(struct xdr_stream *xdr, uint32_t *bitmap,\n\t\tstruct nfs_fattr *fattr, struct nfs_fh *fh,\n\t\tstruct nfs4_fs_locations *fs_loc, const struct nfs_server *server)\n{\n\tint status;\n\tumode_t fmode = 0;\n\tuint32_t type;\n\tint32_t err;\n\n\tstatus = decode_attr_type(xdr, bitmap, &type);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\tfattr->mode = 0;\n\tif (status != 0) {\n\t\tfattr->mode |= nfs_type2fmt[type];\n\t\tfattr->valid |= status;\n\t}\n\n\tstatus = decode_attr_change(xdr, bitmap, &fattr->change_attr);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\tfattr->valid |= status;\n\n\tstatus = decode_attr_size(xdr, bitmap, &fattr->size);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\tfattr->valid |= status;\n\n\tstatus = decode_attr_fsid(xdr, bitmap, &fattr->fsid);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\tfattr->valid |= status;\n\n\terr = 0;\n\tstatus = decode_attr_error(xdr, bitmap, &err);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\n\tstatus = decode_attr_filehandle(xdr, bitmap, fh);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\n\tstatus = decode_attr_fileid(xdr, bitmap, &fattr->fileid);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\tfattr->valid |= status;\n\n\tstatus = decode_attr_fs_locations(xdr, bitmap, fs_loc);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\tfattr->valid |= status;\n\n\tstatus = -EIO;\n\tif (unlikely(bitmap[0]))\n\t\tgoto xdr_error;\n\n\tstatus = decode_attr_mode(xdr, bitmap, &fmode);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\tif (status != 0) {\n\t\tfattr->mode |= fmode;\n\t\tfattr->valid |= status;\n\t}\n\n\tstatus = decode_attr_nlink(xdr, bitmap, &fattr->nlink);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\tfattr->valid |= status;\n\n\tstatus = decode_attr_owner(xdr, bitmap, server, &fattr->uid, fattr->owner_name);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\tfattr->valid |= status;\n\n\tstatus = decode_attr_group(xdr, bitmap, server, &fattr->gid, fattr->group_name);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\tfattr->valid |= status;\n\n\tstatus = decode_attr_rdev(xdr, bitmap, &fattr->rdev);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\tfattr->valid |= status;\n\n\tstatus = decode_attr_space_used(xdr, bitmap, &fattr->du.nfs3.used);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\tfattr->valid |= status;\n\n\tstatus = decode_attr_time_access(xdr, bitmap, &fattr->atime);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\tfattr->valid |= status;\n\n\tstatus = decode_attr_time_metadata(xdr, bitmap, &fattr->ctime);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\tfattr->valid |= status;\n\n\tstatus = decode_attr_time_modify(xdr, bitmap, &fattr->mtime);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\tfattr->valid |= status;\n\n\tstatus = decode_attr_mounted_on_fileid(xdr, bitmap, &fattr->mounted_on_fileid);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\tfattr->valid |= status;\n\n\tstatus = -EIO;\n\tif (unlikely(bitmap[1]))\n\t\tgoto xdr_error;\n\n\tstatus = decode_attr_mdsthreshold(xdr, bitmap, fattr->mdsthreshold);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\n\tstatus = decode_attr_security_label(xdr, bitmap, fattr->label);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\tfattr->valid |= status;\n\nxdr_error:\n\tdprintk(\"%s: xdr returned %d\\n\", __func__, -status);\n\treturn status;\n}\n\nstatic int decode_getfattr_generic(struct xdr_stream *xdr, struct nfs_fattr *fattr,\n\t\tstruct nfs_fh *fh, struct nfs4_fs_locations *fs_loc,\n\t\tconst struct nfs_server *server)\n{\n\tunsigned int savep;\n\tuint32_t attrlen,\n\t\t bitmap[3] = {0};\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_GETATTR);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\n\tstatus = decode_attr_bitmap(xdr, bitmap);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\n\tstatus = decode_attr_length(xdr, &attrlen, &savep);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\n\tstatus = decode_getfattr_attrs(xdr, bitmap, fattr, fh, fs_loc, server);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\n\tstatus = verify_attr_len(xdr, savep, attrlen);\nxdr_error:\n\tdprintk(\"%s: xdr returned %d\\n\", __func__, -status);\n\treturn status;\n}\n\nstatic int decode_getfattr(struct xdr_stream *xdr, struct nfs_fattr *fattr,\n\t\tconst struct nfs_server *server)\n{\n\treturn decode_getfattr_generic(xdr, fattr, NULL, NULL, server);\n}\n\n \nstatic int decode_pnfs_layout_types(struct xdr_stream *xdr,\n\t\t\t\t    struct nfs_fsinfo *fsinfo)\n{\n\t__be32 *p;\n\tuint32_t i;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tfsinfo->nlayouttypes = be32_to_cpup(p);\n\n\t \n\tif (fsinfo->nlayouttypes == 0)\n\t\treturn 0;\n\n\t \n\tp = xdr_inline_decode(xdr, fsinfo->nlayouttypes * 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\n\t \n\tif (fsinfo->nlayouttypes > NFS_MAX_LAYOUT_TYPES) {\n\t\tprintk(KERN_INFO \"NFS: %s: Warning: Too many (%u) pNFS layout types\\n\",\n\t\t\t__func__, fsinfo->nlayouttypes);\n\t\tfsinfo->nlayouttypes = NFS_MAX_LAYOUT_TYPES;\n\t}\n\n\tfor(i = 0; i < fsinfo->nlayouttypes; ++i)\n\t\tfsinfo->layouttype[i] = be32_to_cpup(p++);\n\treturn 0;\n}\n\n \nstatic int decode_attr_pnfstype(struct xdr_stream *xdr, uint32_t *bitmap,\n\t\t\t\tstruct nfs_fsinfo *fsinfo)\n{\n\tint status = 0;\n\n\tdprintk(\"%s: bitmap is %x\\n\", __func__, bitmap[1]);\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_FS_LAYOUT_TYPES - 1U)))\n\t\treturn -EIO;\n\tif (bitmap[1] & FATTR4_WORD1_FS_LAYOUT_TYPES) {\n\t\tstatus = decode_pnfs_layout_types(xdr, fsinfo);\n\t\tbitmap[1] &= ~FATTR4_WORD1_FS_LAYOUT_TYPES;\n\t}\n\treturn status;\n}\n\n \nstatic int decode_attr_layout_blksize(struct xdr_stream *xdr, uint32_t *bitmap,\n\t\t\t\t      uint32_t *res)\n{\n\t__be32 *p;\n\n\tdprintk(\"%s: bitmap is %x\\n\", __func__, bitmap[2]);\n\t*res = 0;\n\tif (bitmap[2] & FATTR4_WORD2_LAYOUT_BLKSIZE) {\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\t*res = be32_to_cpup(p);\n\t\tbitmap[2] &= ~FATTR4_WORD2_LAYOUT_BLKSIZE;\n\t}\n\treturn 0;\n}\n\n \nstatic int decode_attr_clone_blksize(struct xdr_stream *xdr, uint32_t *bitmap,\n\t\t\t\t     uint32_t *res)\n{\n\t__be32 *p;\n\n\tdprintk(\"%s: bitmap is %x\\n\", __func__, bitmap[2]);\n\t*res = 0;\n\tif (bitmap[2] & FATTR4_WORD2_CLONE_BLKSIZE) {\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\t*res = be32_to_cpup(p);\n\t\tbitmap[2] &= ~FATTR4_WORD2_CLONE_BLKSIZE;\n\t}\n\treturn 0;\n}\n\nstatic int decode_attr_change_attr_type(struct xdr_stream *xdr,\n\t\t\t\t\tuint32_t *bitmap,\n\t\t\t\t\tenum nfs4_change_attr_type *res)\n{\n\tu32 tmp = NFS4_CHANGE_TYPE_IS_UNDEFINED;\n\n\tdprintk(\"%s: bitmap is %x\\n\", __func__, bitmap[2]);\n\tif (bitmap[2] & FATTR4_WORD2_CHANGE_ATTR_TYPE) {\n\t\tif (xdr_stream_decode_u32(xdr, &tmp))\n\t\t\treturn -EIO;\n\t\tbitmap[2] &= ~FATTR4_WORD2_CHANGE_ATTR_TYPE;\n\t}\n\n\tswitch(tmp) {\n\tcase NFS4_CHANGE_TYPE_IS_MONOTONIC_INCR:\n\tcase NFS4_CHANGE_TYPE_IS_VERSION_COUNTER:\n\tcase NFS4_CHANGE_TYPE_IS_VERSION_COUNTER_NOPNFS:\n\tcase NFS4_CHANGE_TYPE_IS_TIME_METADATA:\n\t\t*res = tmp;\n\t\tbreak;\n\tdefault:\n\t\t*res = NFS4_CHANGE_TYPE_IS_UNDEFINED;\n\t}\n\treturn 0;\n}\n\nstatic int decode_fsinfo(struct xdr_stream *xdr, struct nfs_fsinfo *fsinfo)\n{\n\tunsigned int savep;\n\tuint32_t attrlen, bitmap[3];\n\tint status;\n\n\tif ((status = decode_op_hdr(xdr, OP_GETATTR)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_bitmap(xdr, bitmap)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_length(xdr, &attrlen, &savep)) != 0)\n\t\tgoto xdr_error;\n\n\tfsinfo->rtmult = fsinfo->wtmult = 512;\t \n\n\tif ((status = decode_attr_lease_time(xdr, bitmap, &fsinfo->lease_time)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_maxfilesize(xdr, bitmap, &fsinfo->maxfilesize)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_maxread(xdr, bitmap, &fsinfo->rtmax)) != 0)\n\t\tgoto xdr_error;\n\tfsinfo->rtpref = fsinfo->dtpref = fsinfo->rtmax;\n\tif ((status = decode_attr_maxwrite(xdr, bitmap, &fsinfo->wtmax)) != 0)\n\t\tgoto xdr_error;\n\tfsinfo->wtpref = fsinfo->wtmax;\n\n\tstatus = -EIO;\n\tif (unlikely(bitmap[0]))\n\t\tgoto xdr_error;\n\n\tstatus = decode_attr_time_delta(xdr, bitmap, &fsinfo->time_delta);\n\tif (status != 0)\n\t\tgoto xdr_error;\n\tstatus = decode_attr_pnfstype(xdr, bitmap, fsinfo);\n\tif (status != 0)\n\t\tgoto xdr_error;\n\n\tstatus = -EIO;\n\tif (unlikely(bitmap[1]))\n\t\tgoto xdr_error;\n\n\tstatus = decode_attr_layout_blksize(xdr, bitmap, &fsinfo->blksize);\n\tif (status)\n\t\tgoto xdr_error;\n\tstatus = decode_attr_clone_blksize(xdr, bitmap, &fsinfo->clone_blksize);\n\tif (status)\n\t\tgoto xdr_error;\n\n\tstatus = decode_attr_change_attr_type(xdr, bitmap,\n\t\t\t\t\t      &fsinfo->change_attr_type);\n\tif (status)\n\t\tgoto xdr_error;\n\n\tstatus = decode_attr_xattrsupport(xdr, bitmap,\n\t\t\t\t\t  &fsinfo->xattr_support);\n\tif (status)\n\t\tgoto xdr_error;\n\n\tstatus = verify_attr_len(xdr, savep, attrlen);\nxdr_error:\n\tdprintk(\"%s: xdr returned %d!\\n\", __func__, -status);\n\treturn status;\n}\n\nstatic int decode_getfh(struct xdr_stream *xdr, struct nfs_fh *fh)\n{\n\t__be32 *p;\n\tuint32_t len;\n\tint status;\n\n\t \n\tmemset(fh, 0, sizeof(*fh));\n\n\tstatus = decode_op_hdr(xdr, OP_GETFH);\n\tif (status)\n\t\treturn status;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tlen = be32_to_cpup(p);\n\tif (len > NFS4_FHSIZE || len == 0) {\n\t\ttrace_nfs4_xdr_bad_filehandle(xdr, OP_GETFH, NFS4ERR_BADHANDLE);\n\t\treturn -EREMOTEIO;\n\t}\n\tfh->size = len;\n\tp = xdr_inline_decode(xdr, len);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tmemcpy(fh->data, p, len);\n\treturn 0;\n}\n\nstatic int decode_link(struct xdr_stream *xdr, struct nfs4_change_info *cinfo)\n{\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_LINK);\n\tif (status)\n\t\treturn status;\n\treturn decode_change_info(xdr, cinfo);\n}\n\n \nstatic int decode_lock_denied (struct xdr_stream *xdr, struct file_lock *fl)\n{\n\tuint64_t offset, length, clientid;\n\t__be32 *p;\n\tuint32_t namelen, type;\n\n\tp = xdr_inline_decode(xdr, 32);  \n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tp = xdr_decode_hyper(p, &offset);  \n\tp = xdr_decode_hyper(p, &length);\n\ttype = be32_to_cpup(p++);  \n\tif (fl != NULL) {  \n\t\tfl->fl_start = (loff_t)offset;\n\t\tfl->fl_end = fl->fl_start + (loff_t)length - 1;\n\t\tif (length == ~(uint64_t)0)\n\t\t\tfl->fl_end = OFFSET_MAX;\n\t\tfl->fl_type = F_WRLCK;\n\t\tif (type & 1)\n\t\t\tfl->fl_type = F_RDLCK;\n\t\tfl->fl_pid = 0;\n\t}\n\tp = xdr_decode_hyper(p, &clientid);  \n\tnamelen = be32_to_cpup(p);     \n\tp = xdr_inline_decode(xdr, namelen);  \n\tif (likely(!p))\n\t\treturn -EIO;\n\treturn -NFS4ERR_DENIED;\n}\n\nstatic int decode_lock(struct xdr_stream *xdr, struct nfs_lock_res *res)\n{\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_LOCK);\n\tif (status == -EIO)\n\t\tgoto out;\n\tif (status == 0) {\n\t\tstatus = decode_lock_stateid(xdr, &res->stateid);\n\t\tif (unlikely(status))\n\t\t\tgoto out;\n\t} else if (status == -NFS4ERR_DENIED)\n\t\tstatus = decode_lock_denied(xdr, NULL);\n\tif (res->open_seqid != NULL)\n\t\tnfs_increment_open_seqid(status, res->open_seqid);\n\tnfs_increment_lock_seqid(status, res->lock_seqid);\nout:\n\treturn status;\n}\n\nstatic int decode_lockt(struct xdr_stream *xdr, struct nfs_lockt_res *res)\n{\n\tint status;\n\tstatus = decode_op_hdr(xdr, OP_LOCKT);\n\tif (status == -NFS4ERR_DENIED)\n\t\treturn decode_lock_denied(xdr, res->denied);\n\treturn status;\n}\n\nstatic int decode_locku(struct xdr_stream *xdr, struct nfs_locku_res *res)\n{\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_LOCKU);\n\tif (status != -EIO)\n\t\tnfs_increment_lock_seqid(status, res->seqid);\n\tif (status == 0)\n\t\tstatus = decode_lock_stateid(xdr, &res->stateid);\n\treturn status;\n}\n\nstatic int decode_release_lockowner(struct xdr_stream *xdr)\n{\n\treturn decode_op_hdr(xdr, OP_RELEASE_LOCKOWNER);\n}\n\nstatic int decode_lookup(struct xdr_stream *xdr)\n{\n\treturn decode_op_hdr(xdr, OP_LOOKUP);\n}\n\nstatic int decode_lookupp(struct xdr_stream *xdr)\n{\n\treturn decode_op_hdr(xdr, OP_LOOKUPP);\n}\n\n \nstatic int decode_space_limit(struct xdr_stream *xdr,\n\t\tunsigned long *pagemod_limit)\n{\n\t__be32 *p;\n\tuint32_t limit_type, nblocks, blocksize;\n\tu64 maxsize = 0;\n\n\tp = xdr_inline_decode(xdr, 12);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tlimit_type = be32_to_cpup(p++);\n\tswitch (limit_type) {\n\tcase NFS4_LIMIT_SIZE:\n\t\txdr_decode_hyper(p, &maxsize);\n\t\tbreak;\n\tcase NFS4_LIMIT_BLOCKS:\n\t\tnblocks = be32_to_cpup(p++);\n\t\tblocksize = be32_to_cpup(p);\n\t\tmaxsize = (uint64_t)nblocks * (uint64_t)blocksize;\n\t}\n\tmaxsize >>= PAGE_SHIFT;\n\t*pagemod_limit = min_t(u64, maxsize, ULONG_MAX);\n\treturn 0;\n}\n\nstatic int decode_rw_delegation(struct xdr_stream *xdr,\n\t\tuint32_t delegation_type,\n\t\tstruct nfs_openres *res)\n{\n\t__be32 *p;\n\tint status;\n\n\tstatus = decode_delegation_stateid(xdr, &res->delegation);\n\tif (unlikely(status))\n\t\treturn status;\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tres->do_recall = be32_to_cpup(p);\n\n\tswitch (delegation_type) {\n\tcase NFS4_OPEN_DELEGATE_READ:\n\t\tres->delegation_type = FMODE_READ;\n\t\tbreak;\n\tcase NFS4_OPEN_DELEGATE_WRITE:\n\t\tres->delegation_type = FMODE_WRITE|FMODE_READ;\n\t\tif (decode_space_limit(xdr, &res->pagemod_limit) < 0)\n\t\t\t\treturn -EIO;\n\t}\n\treturn decode_ace(xdr, NULL);\n}\n\nstatic int decode_no_delegation(struct xdr_stream *xdr, struct nfs_openres *res)\n{\n\t__be32 *p;\n\tuint32_t why_no_delegation;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\twhy_no_delegation = be32_to_cpup(p);\n\tswitch (why_no_delegation) {\n\t\tcase WND4_CONTENTION:\n\t\tcase WND4_RESOURCE:\n\t\t\txdr_inline_decode(xdr, 4);\n\t\t\t \n\t}\n\treturn 0;\n}\n\nstatic int decode_delegation(struct xdr_stream *xdr, struct nfs_openres *res)\n{\n\t__be32 *p;\n\tuint32_t delegation_type;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tdelegation_type = be32_to_cpup(p);\n\tres->delegation_type = 0;\n\tswitch (delegation_type) {\n\tcase NFS4_OPEN_DELEGATE_NONE:\n\t\treturn 0;\n\tcase NFS4_OPEN_DELEGATE_READ:\n\tcase NFS4_OPEN_DELEGATE_WRITE:\n\t\treturn decode_rw_delegation(xdr, delegation_type, res);\n\tcase NFS4_OPEN_DELEGATE_NONE_EXT:\n\t\treturn decode_no_delegation(xdr, res);\n\t}\n\treturn -EIO;\n}\n\nstatic int decode_open(struct xdr_stream *xdr, struct nfs_openres *res)\n{\n\t__be32 *p;\n\tuint32_t savewords, bmlen, i;\n\tint status;\n\n\tif (!__decode_op_hdr(xdr, OP_OPEN, &status))\n\t\treturn status;\n\tnfs_increment_open_seqid(status, res->seqid);\n\tif (status)\n\t\treturn status;\n\tstatus = decode_open_stateid(xdr, &res->stateid);\n\tif (unlikely(status))\n\t\treturn status;\n\n\tdecode_change_info(xdr, &res->cinfo);\n\n\tp = xdr_inline_decode(xdr, 8);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tres->rflags = be32_to_cpup(p++);\n\tbmlen = be32_to_cpup(p);\n\tif (bmlen > 10)\n\t\tgoto xdr_error;\n\n\tp = xdr_inline_decode(xdr, bmlen << 2);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tsavewords = min_t(uint32_t, bmlen, NFS4_BITMAP_SIZE);\n\tfor (i = 0; i < savewords; ++i)\n\t\tres->attrset[i] = be32_to_cpup(p++);\n\tfor (; i < NFS4_BITMAP_SIZE; i++)\n\t\tres->attrset[i] = 0;\n\n\treturn decode_delegation(xdr, res);\nxdr_error:\n\tdprintk(\"%s: Bitmap too large! Length = %u\\n\", __func__, bmlen);\n\treturn -EIO;\n}\n\nstatic int decode_open_confirm(struct xdr_stream *xdr, struct nfs_open_confirmres *res)\n{\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_OPEN_CONFIRM);\n\tif (status != -EIO)\n\t\tnfs_increment_open_seqid(status, res->seqid);\n\tif (!status)\n\t\tstatus = decode_open_stateid(xdr, &res->stateid);\n\treturn status;\n}\n\nstatic int decode_open_downgrade(struct xdr_stream *xdr, struct nfs_closeres *res)\n{\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_OPEN_DOWNGRADE);\n\tif (status != -EIO)\n\t\tnfs_increment_open_seqid(status, res->seqid);\n\tif (!status)\n\t\tstatus = decode_open_stateid(xdr, &res->stateid);\n\treturn status;\n}\n\nstatic int decode_putfh(struct xdr_stream *xdr)\n{\n\treturn decode_op_hdr(xdr, OP_PUTFH);\n}\n\nstatic int decode_putrootfh(struct xdr_stream *xdr)\n{\n\treturn decode_op_hdr(xdr, OP_PUTROOTFH);\n}\n\nstatic int decode_read(struct xdr_stream *xdr, struct rpc_rqst *req,\n\t\t       struct nfs_pgio_res *res)\n{\n\t__be32 *p;\n\tuint32_t count, eof, recvd;\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_READ);\n\tif (status)\n\t\treturn status;\n\tp = xdr_inline_decode(xdr, 8);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\teof = be32_to_cpup(p++);\n\tcount = be32_to_cpup(p);\n\trecvd = xdr_read_pages(xdr, count);\n\tif (count > recvd) {\n\t\tdprintk(\"NFS: server cheating in read reply: \"\n\t\t\t\t\"count %u > recvd %u\\n\", count, recvd);\n\t\tcount = recvd;\n\t\teof = 0;\n\t}\n\tres->eof = eof;\n\tres->count = count;\n\treturn 0;\n}\n\nstatic int decode_readdir(struct xdr_stream *xdr, struct rpc_rqst *req, struct nfs4_readdir_res *readdir)\n{\n\tint\t\tstatus;\n\t__be32\t\tverf[2];\n\n\tstatus = decode_op_hdr(xdr, OP_READDIR);\n\tif (!status)\n\t\tstatus = decode_verifier(xdr, readdir->verifier.data);\n\tif (unlikely(status))\n\t\treturn status;\n\tmemcpy(verf, readdir->verifier.data, sizeof(verf));\n\tdprintk(\"%s: verifier = %08x:%08x\\n\",\n\t\t\t__func__, verf[0], verf[1]);\n\treturn xdr_read_pages(xdr, xdr->buf->page_len);\n}\n\nstatic int decode_readlink(struct xdr_stream *xdr, struct rpc_rqst *req)\n{\n\tstruct xdr_buf *rcvbuf = &req->rq_rcv_buf;\n\tu32 len, recvd;\n\t__be32 *p;\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_READLINK);\n\tif (status)\n\t\treturn status;\n\n\t \n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tlen = be32_to_cpup(p);\n\tif (len >= rcvbuf->page_len || len <= 0) {\n\t\tdprintk(\"nfs: server returned giant symlink!\\n\");\n\t\treturn -ENAMETOOLONG;\n\t}\n\trecvd = xdr_read_pages(xdr, len);\n\tif (recvd < len) {\n\t\tdprintk(\"NFS: server cheating in readlink reply: \"\n\t\t\t\t\"count %u > recvd %u\\n\", len, recvd);\n\t\treturn -EIO;\n\t}\n\t \n\txdr_terminate_string(rcvbuf, len);\n\treturn 0;\n}\n\nstatic int decode_remove(struct xdr_stream *xdr, struct nfs4_change_info *cinfo)\n{\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_REMOVE);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_change_info(xdr, cinfo);\nout:\n\treturn status;\n}\n\nstatic int decode_rename(struct xdr_stream *xdr, struct nfs4_change_info *old_cinfo,\n\t      struct nfs4_change_info *new_cinfo)\n{\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_RENAME);\n\tif (status)\n\t\tgoto out;\n\tif ((status = decode_change_info(xdr, old_cinfo)))\n\t\tgoto out;\n\tstatus = decode_change_info(xdr, new_cinfo);\nout:\n\treturn status;\n}\n\nstatic int decode_renew(struct xdr_stream *xdr)\n{\n\treturn decode_op_hdr(xdr, OP_RENEW);\n}\n\nstatic int\ndecode_restorefh(struct xdr_stream *xdr)\n{\n\treturn decode_op_hdr(xdr, OP_RESTOREFH);\n}\n\nstatic int decode_getacl(struct xdr_stream *xdr, struct rpc_rqst *req,\n\t\t\t struct nfs_getaclres *res, enum nfs4_acl_type type)\n{\n\tunsigned int savep;\n\tuint32_t attrlen,\n\t\t bitmap[3] = {0};\n\tint status;\n\n\tres->acl_len = 0;\n\tif ((status = decode_op_hdr(xdr, OP_GETATTR)) != 0)\n\t\tgoto out;\n\n\txdr_enter_page(xdr, xdr->buf->page_len);\n\n\tif ((status = decode_attr_bitmap(xdr, bitmap)) != 0)\n\t\tgoto out;\n\tif ((status = decode_attr_length(xdr, &attrlen, &savep)) != 0)\n\t\tgoto out;\n\n\tswitch (type) {\n\tdefault:\n\t\tif (unlikely(bitmap[0] & (FATTR4_WORD0_ACL - 1U)))\n\t\t\treturn -EIO;\n\t\tif (!(bitmap[0] & FATTR4_WORD0_ACL))\n\t\t\treturn -EOPNOTSUPP;\n\t\tbreak;\n\tcase NFS4ACL_DACL:\n\t\tif (unlikely(bitmap[0] || bitmap[1] & (FATTR4_WORD1_DACL - 1U)))\n\t\t\treturn -EIO;\n\t\tif (!(bitmap[1] & FATTR4_WORD1_DACL))\n\t\t\treturn -EOPNOTSUPP;\n\t\tbreak;\n\tcase NFS4ACL_SACL:\n\t\tif (unlikely(bitmap[0] || bitmap[1] & (FATTR4_WORD1_SACL - 1U)))\n\t\t\treturn -EIO;\n\t\tif (!(bitmap[1] & FATTR4_WORD1_SACL))\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tres->acl_data_offset = xdr_page_pos(xdr);\n\tres->acl_len = attrlen;\n\n\t \n\tif (res->acl_len > xdr_stream_remaining(xdr) ||\n\t    res->acl_len + res->acl_data_offset > xdr->buf->page_len) {\n\t\tres->acl_flags |= NFS4_ACL_TRUNC;\n\t\tdprintk(\"NFS: acl reply: attrlen %u > page_len %zu\\n\",\n\t\t\tattrlen, xdr_stream_remaining(xdr));\n\t}\nout:\n\treturn status;\n}\n\nstatic int\ndecode_savefh(struct xdr_stream *xdr)\n{\n\treturn decode_op_hdr(xdr, OP_SAVEFH);\n}\n\nstatic int decode_setattr(struct xdr_stream *xdr)\n{\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_SETATTR);\n\tif (status)\n\t\treturn status;\n\tif (decode_bitmap4(xdr, NULL, 0) >= 0)\n\t\treturn 0;\n\treturn -EIO;\n}\n\nstatic int decode_setclientid(struct xdr_stream *xdr, struct nfs4_setclientid_res *res)\n{\n\t__be32 *p;\n\tuint32_t opnum;\n\tint32_t nfserr;\n\n\tp = xdr_inline_decode(xdr, 8);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\topnum = be32_to_cpup(p++);\n\tif (opnum != OP_SETCLIENTID) {\n\t\tdprintk(\"nfs: decode_setclientid: Server returned operation\"\n\t\t\t\" %d\\n\", opnum);\n\t\treturn -EIO;\n\t}\n\tnfserr = be32_to_cpup(p);\n\tif (nfserr == NFS_OK) {\n\t\tp = xdr_inline_decode(xdr, 8 + NFS4_VERIFIER_SIZE);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\tp = xdr_decode_hyper(p, &res->clientid);\n\t\tmemcpy(res->confirm.data, p, NFS4_VERIFIER_SIZE);\n\t} else if (nfserr == NFSERR_CLID_INUSE) {\n\t\tuint32_t len;\n\n\t\t \n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\tlen = be32_to_cpup(p);\n\t\tp = xdr_inline_decode(xdr, len);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\n\t\t \n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\tlen = be32_to_cpup(p);\n\t\tp = xdr_inline_decode(xdr, len);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\treturn -NFSERR_CLID_INUSE;\n\t} else\n\t\treturn nfs4_stat_to_errno(nfserr);\n\n\treturn 0;\n}\n\nstatic int decode_setclientid_confirm(struct xdr_stream *xdr)\n{\n\treturn decode_op_hdr(xdr, OP_SETCLIENTID_CONFIRM);\n}\n\nstatic int decode_write(struct xdr_stream *xdr, struct nfs_pgio_res *res)\n{\n\t__be32 *p;\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_WRITE);\n\tif (status)\n\t\treturn status;\n\n\tp = xdr_inline_decode(xdr, 8);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tres->count = be32_to_cpup(p++);\n\tres->verf->committed = be32_to_cpup(p++);\n\treturn decode_write_verifier(xdr, &res->verf->verifier);\n}\n\nstatic int decode_delegreturn(struct xdr_stream *xdr)\n{\n\treturn decode_op_hdr(xdr, OP_DELEGRETURN);\n}\n\nstatic int decode_secinfo_gss(struct xdr_stream *xdr,\n\t\t\t      struct nfs4_secinfo4 *flavor)\n{\n\tu32 oid_len;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\toid_len = be32_to_cpup(p);\n\tif (oid_len > GSS_OID_MAX_LEN)\n\t\treturn -EINVAL;\n\n\tp = xdr_inline_decode(xdr, oid_len);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tmemcpy(flavor->flavor_info.oid.data, p, oid_len);\n\tflavor->flavor_info.oid.len = oid_len;\n\n\tp = xdr_inline_decode(xdr, 8);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tflavor->flavor_info.qop = be32_to_cpup(p++);\n\tflavor->flavor_info.service = be32_to_cpup(p);\n\n\treturn 0;\n}\n\nstatic int decode_secinfo_common(struct xdr_stream *xdr, struct nfs4_secinfo_res *res)\n{\n\tstruct nfs4_secinfo4 *sec_flavor;\n\tunsigned int i, num_flavors;\n\tint status;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\n\tres->flavors->num_flavors = 0;\n\tnum_flavors = be32_to_cpup(p);\n\n\tfor (i = 0; i < num_flavors; i++) {\n\t\tsec_flavor = &res->flavors->flavors[i];\n\t\tif ((char *)&sec_flavor[1] - (char *)res->flavors > PAGE_SIZE)\n\t\t\tbreak;\n\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\tsec_flavor->flavor = be32_to_cpup(p);\n\n\t\tif (sec_flavor->flavor == RPC_AUTH_GSS) {\n\t\t\tstatus = decode_secinfo_gss(xdr, sec_flavor);\n\t\t\tif (status)\n\t\t\t\tgoto out;\n\t\t}\n\t\tres->flavors->num_flavors++;\n\t}\n\n\tstatus = 0;\nout:\n\treturn status;\n}\n\nstatic int decode_secinfo(struct xdr_stream *xdr, struct nfs4_secinfo_res *res)\n{\n\tint status = decode_op_hdr(xdr, OP_SECINFO);\n\tif (status)\n\t\treturn status;\n\treturn decode_secinfo_common(xdr, res);\n}\n\n#if defined(CONFIG_NFS_V4_1)\nstatic int decode_secinfo_no_name(struct xdr_stream *xdr, struct nfs4_secinfo_res *res)\n{\n\tint status = decode_op_hdr(xdr, OP_SECINFO_NO_NAME);\n\tif (status)\n\t\treturn status;\n\treturn decode_secinfo_common(xdr, res);\n}\n\nstatic int decode_op_map(struct xdr_stream *xdr, struct nfs4_op_map *op_map)\n{\n\tif (xdr_stream_decode_uint32_array(xdr, op_map->u.words,\n\t\t\t\t\t   ARRAY_SIZE(op_map->u.words)) < 0)\n\t\treturn -EIO;\n\treturn 0;\n}\n\nstatic int decode_exchange_id(struct xdr_stream *xdr,\n\t\t\t      struct nfs41_exchange_id_res *res)\n{\n\t__be32 *p;\n\tuint32_t dummy;\n\tchar *dummy_str;\n\tint status;\n\tuint32_t impl_id_count;\n\n\tstatus = decode_op_hdr(xdr, OP_EXCHANGE_ID);\n\tif (status)\n\t\treturn status;\n\n\tp = xdr_inline_decode(xdr, 8);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\txdr_decode_hyper(p, &res->clientid);\n\tp = xdr_inline_decode(xdr, 12);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tres->seqid = be32_to_cpup(p++);\n\tres->flags = be32_to_cpup(p++);\n\n\tres->state_protect.how = be32_to_cpup(p);\n\tswitch (res->state_protect.how) {\n\tcase SP4_NONE:\n\t\tbreak;\n\tcase SP4_MACH_CRED:\n\t\tstatus = decode_op_map(xdr, &res->state_protect.enforce);\n\t\tif (status)\n\t\t\treturn status;\n\t\tstatus = decode_op_map(xdr, &res->state_protect.allow);\n\t\tif (status)\n\t\t\treturn status;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn -EIO;\n\t}\n\n\t \n\tp = xdr_inline_decode(xdr, 8);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tp = xdr_decode_hyper(p, &res->server_owner->minor_id);\n\n\t \n\tstatus = decode_opaque_inline(xdr, &dummy, &dummy_str);\n\tif (unlikely(status))\n\t\treturn status;\n\tmemcpy(res->server_owner->major_id, dummy_str, dummy);\n\tres->server_owner->major_id_sz = dummy;\n\n\t \n\tstatus = decode_opaque_inline(xdr, &dummy, &dummy_str);\n\tif (unlikely(status))\n\t\treturn status;\n\tmemcpy(res->server_scope->server_scope, dummy_str, dummy);\n\tres->server_scope->server_scope_sz = dummy;\n\n\t \n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\timpl_id_count = be32_to_cpup(p++);\n\n\tif (impl_id_count) {\n\t\t \n\t\tstatus = decode_opaque_inline(xdr, &dummy, &dummy_str);\n\t\tif (unlikely(status))\n\t\t\treturn status;\n\t\tmemcpy(res->impl_id->domain, dummy_str, dummy);\n\n\t\t \n\t\tstatus = decode_opaque_inline(xdr, &dummy, &dummy_str);\n\t\tif (unlikely(status))\n\t\t\treturn status;\n\t\tmemcpy(res->impl_id->name, dummy_str, dummy);\n\n\t\t \n\t\tp = xdr_inline_decode(xdr, 12);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\tp = xdr_decode_hyper(p, &res->impl_id->date.seconds);\n\t\tres->impl_id->date.nseconds = be32_to_cpup(p);\n\n\t\t \n\t}\n\treturn 0;\n}\n\nstatic int decode_chan_attrs(struct xdr_stream *xdr,\n\t\t\t     struct nfs4_channel_attrs *attrs)\n{\n\t__be32 *p;\n\tu32 nr_attrs, val;\n\n\tp = xdr_inline_decode(xdr, 28);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tval = be32_to_cpup(p++);\t \n\tif (val)\n\t\treturn -EINVAL;\t\t \n\tattrs->max_rqst_sz = be32_to_cpup(p++);\n\tattrs->max_resp_sz = be32_to_cpup(p++);\n\tattrs->max_resp_sz_cached = be32_to_cpup(p++);\n\tattrs->max_ops = be32_to_cpup(p++);\n\tattrs->max_reqs = be32_to_cpup(p++);\n\tnr_attrs = be32_to_cpup(p);\n\tif (unlikely(nr_attrs > 1)) {\n\t\tprintk(KERN_WARNING \"NFS: %s: Invalid rdma channel attrs \"\n\t\t\t\"count %u\\n\", __func__, nr_attrs);\n\t\treturn -EINVAL;\n\t}\n\tif (nr_attrs == 1) {\n\t\tp = xdr_inline_decode(xdr, 4);  \n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic int decode_sessionid(struct xdr_stream *xdr, struct nfs4_sessionid *sid)\n{\n\treturn decode_opaque_fixed(xdr, sid->data, NFS4_MAX_SESSIONID_LEN);\n}\n\nstatic int decode_bind_conn_to_session(struct xdr_stream *xdr,\n\t\t\t\tstruct nfs41_bind_conn_to_session_res *res)\n{\n\t__be32 *p;\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_BIND_CONN_TO_SESSION);\n\tif (!status)\n\t\tstatus = decode_sessionid(xdr, &res->sessionid);\n\tif (unlikely(status))\n\t\treturn status;\n\n\t \n\tp = xdr_inline_decode(xdr, 8);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\n\tres->dir = be32_to_cpup(p++);\n\tif (res->dir == 0 || res->dir > NFS4_CDFS4_BOTH)\n\t\treturn -EIO;\n\tif (be32_to_cpup(p) == 0)\n\t\tres->use_conn_in_rdma_mode = false;\n\telse\n\t\tres->use_conn_in_rdma_mode = true;\n\n\treturn 0;\n}\n\nstatic int decode_create_session(struct xdr_stream *xdr,\n\t\t\t\t struct nfs41_create_session_res *res)\n{\n\t__be32 *p;\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_CREATE_SESSION);\n\tif (!status)\n\t\tstatus = decode_sessionid(xdr, &res->sessionid);\n\tif (unlikely(status))\n\t\treturn status;\n\n\t \n\tp = xdr_inline_decode(xdr, 8);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tres->seqid = be32_to_cpup(p++);\n\tres->flags = be32_to_cpup(p);\n\n\t \n\tstatus = decode_chan_attrs(xdr, &res->fc_attrs);\n\tif (!status)\n\t\tstatus = decode_chan_attrs(xdr, &res->bc_attrs);\n\treturn status;\n}\n\nstatic int decode_destroy_session(struct xdr_stream *xdr, void *dummy)\n{\n\treturn decode_op_hdr(xdr, OP_DESTROY_SESSION);\n}\n\nstatic int decode_destroy_clientid(struct xdr_stream *xdr, void *dummy)\n{\n\treturn decode_op_hdr(xdr, OP_DESTROY_CLIENTID);\n}\n\nstatic int decode_reclaim_complete(struct xdr_stream *xdr, void *dummy)\n{\n\treturn decode_op_hdr(xdr, OP_RECLAIM_COMPLETE);\n}\n#endif  \n\nstatic int decode_sequence(struct xdr_stream *xdr,\n\t\t\t   struct nfs4_sequence_res *res,\n\t\t\t   struct rpc_rqst *rqstp)\n{\n#if defined(CONFIG_NFS_V4_1)\n\tstruct nfs4_session *session;\n\tstruct nfs4_sessionid id;\n\tu32 dummy;\n\tint status;\n\t__be32 *p;\n\n\tif (res->sr_slot == NULL)\n\t\treturn 0;\n\tif (!res->sr_slot->table->session)\n\t\treturn 0;\n\n\tstatus = decode_op_hdr(xdr, OP_SEQUENCE);\n\tif (!status)\n\t\tstatus = decode_sessionid(xdr, &id);\n\tif (unlikely(status))\n\t\tgoto out_err;\n\n\t \n\tstatus = -EREMOTEIO;\n\tsession = res->sr_slot->table->session;\n\n\tif (memcmp(id.data, session->sess_id.data,\n\t\t   NFS4_MAX_SESSIONID_LEN)) {\n\t\tdprintk(\"%s Invalid session id\\n\", __func__);\n\t\tgoto out_err;\n\t}\n\n\tp = xdr_inline_decode(xdr, 20);\n\tif (unlikely(!p))\n\t\tgoto out_overflow;\n\n\t \n\tdummy = be32_to_cpup(p++);\n\tif (dummy != res->sr_slot->seq_nr) {\n\t\tdprintk(\"%s Invalid sequence number\\n\", __func__);\n\t\tgoto out_err;\n\t}\n\t \n\tdummy = be32_to_cpup(p++);\n\tif (dummy != res->sr_slot->slot_nr) {\n\t\tdprintk(\"%s Invalid slot id\\n\", __func__);\n\t\tgoto out_err;\n\t}\n\t \n\tres->sr_highest_slotid = be32_to_cpup(p++);\n\t \n\tres->sr_target_highest_slotid = be32_to_cpup(p++);\n\t \n\tres->sr_status_flags = be32_to_cpup(p);\n\tstatus = 0;\nout_err:\n\tres->sr_status = status;\n\treturn status;\nout_overflow:\n\tstatus = -EIO;\n\tgoto out_err;\n#else   \n\treturn 0;\n#endif  \n}\n\n#if defined(CONFIG_NFS_V4_1)\nstatic int decode_layout_stateid(struct xdr_stream *xdr, nfs4_stateid *stateid)\n{\n\tstateid->type = NFS4_LAYOUT_STATEID_TYPE;\n\treturn decode_stateid(xdr, stateid);\n}\n\nstatic int decode_getdeviceinfo(struct xdr_stream *xdr,\n\t\t\t\tstruct nfs4_getdeviceinfo_res *res)\n{\n\tstruct pnfs_device *pdev = res->pdev;\n\t__be32 *p;\n\tuint32_t len, type;\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_GETDEVICEINFO);\n\tif (status) {\n\t\tif (status == -ETOOSMALL) {\n\t\t\tp = xdr_inline_decode(xdr, 4);\n\t\t\tif (unlikely(!p))\n\t\t\t\treturn -EIO;\n\t\t\tpdev->mincount = be32_to_cpup(p);\n\t\t\tdprintk(\"%s: Min count too small. mincnt = %u\\n\",\n\t\t\t\t__func__, pdev->mincount);\n\t\t}\n\t\treturn status;\n\t}\n\n\tp = xdr_inline_decode(xdr, 8);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\ttype = be32_to_cpup(p++);\n\tif (type != pdev->layout_type) {\n\t\tdprintk(\"%s: layout mismatch req: %u pdev: %u\\n\",\n\t\t\t__func__, pdev->layout_type, type);\n\t\treturn -EINVAL;\n\t}\n\t \n\tpdev->mincount = be32_to_cpup(p);\n\tif (xdr_read_pages(xdr, pdev->mincount) != pdev->mincount)\n\t\treturn -EIO;\n\n\t \n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tlen = be32_to_cpup(p);\n\tif (len) {\n\t\tuint32_t i;\n\n\t\tp = xdr_inline_decode(xdr, 4 * len);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\n\t\tres->notification = be32_to_cpup(p++);\n\t\tfor (i = 1; i < len; i++) {\n\t\t\tif (be32_to_cpup(p++)) {\n\t\t\t\tdprintk(\"%s: unsupported notification\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int decode_layoutget(struct xdr_stream *xdr, struct rpc_rqst *req,\n\t\t\t    struct nfs4_layoutget_res *res)\n{\n\t__be32 *p;\n\tint status;\n\tu32 layout_count;\n\tu32 recvd;\n\n\tstatus = decode_op_hdr(xdr, OP_LAYOUTGET);\n\tif (status)\n\t\tgoto out;\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\tgoto out_overflow;\n\tres->return_on_close = be32_to_cpup(p);\n\tdecode_layout_stateid(xdr, &res->stateid);\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\tgoto out_overflow;\n\tlayout_count = be32_to_cpup(p);\n\tif (!layout_count) {\n\t\tdprintk(\"%s: server responded with empty layout array\\n\",\n\t\t\t__func__);\n\t\tstatus = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tp = xdr_inline_decode(xdr, 28);\n\tif (unlikely(!p))\n\t\tgoto out_overflow;\n\tp = xdr_decode_hyper(p, &res->range.offset);\n\tp = xdr_decode_hyper(p, &res->range.length);\n\tres->range.iomode = be32_to_cpup(p++);\n\tres->type = be32_to_cpup(p++);\n\tres->layoutp->len = be32_to_cpup(p);\n\n\tdprintk(\"%s roff:%lu rlen:%lu riomode:%d, lo_type:0x%x, lo.len:%d\\n\",\n\t\t__func__,\n\t\t(unsigned long)res->range.offset,\n\t\t(unsigned long)res->range.length,\n\t\tres->range.iomode,\n\t\tres->type,\n\t\tres->layoutp->len);\n\n\trecvd = xdr_read_pages(xdr, res->layoutp->len);\n\tif (res->layoutp->len > recvd) {\n\t\tdprintk(\"NFS: server cheating in layoutget reply: \"\n\t\t\t\t\"layout len %u > recvd %u\\n\",\n\t\t\t\tres->layoutp->len, recvd);\n\t\tstatus = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (layout_count > 1) {\n\t\t \n\t\tdprintk(\"%s: server responded with %d layouts, dropping tail\\n\",\n\t\t\t__func__, layout_count);\n\t}\n\nout:\n\tres->status = status;\n\treturn status;\nout_overflow:\n\tstatus = -EIO;\n\tgoto out;\n}\n\nstatic int decode_layoutreturn(struct xdr_stream *xdr,\n\t\t\t       struct nfs4_layoutreturn_res *res)\n{\n\t__be32 *p;\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_LAYOUTRETURN);\n\tif (status)\n\t\treturn status;\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tres->lrs_present = be32_to_cpup(p);\n\tif (res->lrs_present)\n\t\tstatus = decode_layout_stateid(xdr, &res->stateid);\n\telse\n\t\tnfs4_stateid_copy(&res->stateid, &invalid_stateid);\n\treturn status;\n}\n\nstatic int decode_layoutcommit(struct xdr_stream *xdr,\n\t\t\t       struct rpc_rqst *req,\n\t\t\t       struct nfs4_layoutcommit_res *res)\n{\n\t__be32 *p;\n\t__u32 sizechanged;\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_LAYOUTCOMMIT);\n\tres->status = status;\n\tif (status)\n\t\treturn status;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tsizechanged = be32_to_cpup(p);\n\n\tif (sizechanged) {\n\t\t \n\t\tp = xdr_inline_decode(xdr, 8);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic int decode_test_stateid(struct xdr_stream *xdr,\n\t\t\t       struct nfs41_test_stateid_res *res)\n{\n\t__be32 *p;\n\tint status;\n\tint num_res;\n\n\tstatus = decode_op_hdr(xdr, OP_TEST_STATEID);\n\tif (status)\n\t\treturn status;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tnum_res = be32_to_cpup(p++);\n\tif (num_res != 1)\n\t\treturn -EIO;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tres->status = be32_to_cpup(p++);\n\n\treturn status;\n}\n\nstatic int decode_free_stateid(struct xdr_stream *xdr,\n\t\t\t       struct nfs41_free_stateid_res *res)\n{\n\tres->status = decode_op_hdr(xdr, OP_FREE_STATEID);\n\treturn res->status;\n}\n#else\nstatic inline\nint decode_layoutreturn(struct xdr_stream *xdr,\n\t\t\t       struct nfs4_layoutreturn_res *res)\n{\n\treturn 0;\n}\n\nstatic int decode_layoutget(struct xdr_stream *xdr, struct rpc_rqst *req,\n\t\t\t    struct nfs4_layoutget_res *res)\n{\n\treturn 0;\n}\n\n#endif  \n\n \n\n \nstatic int nfs4_xdr_dec_open_downgrade(struct rpc_rqst *rqstp,\n\t\t\t\t       struct xdr_stream *xdr,\n\t\t\t\t       void *data)\n{\n\tstruct nfs_closeres *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tif (res->lr_res) {\n\t\tstatus = decode_layoutreturn(xdr, res->lr_res);\n\t\tres->lr_ret = status;\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tstatus = decode_open_downgrade(xdr, res);\nout:\n\treturn status;\n}\n\n \nstatic int nfs4_xdr_dec_access(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t\t       void *data)\n{\n\tstruct nfs4_accessres *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status != 0)\n\t\tgoto out;\n\tstatus = decode_access(xdr, &res->supported, &res->access);\n\tif (status != 0)\n\t\tgoto out;\n\tif (res->fattr)\n\t\tdecode_getfattr(xdr, res->fattr, res->server);\nout:\n\treturn status;\n}\n\n \nstatic int nfs4_xdr_dec_lookup(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t\t       void *data)\n{\n\tstruct nfs4_lookup_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_lookup(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_getfh(xdr, res->fh);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_getfattr(xdr, res->fattr, res->server);\nout:\n\treturn status;\n}\n\n \nstatic int nfs4_xdr_dec_lookupp(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\tvoid *data)\n{\n\tstruct nfs4_lookupp_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_lookupp(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_getfh(xdr, res->fh);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_getfattr(xdr, res->fattr, res->server);\nout:\n\treturn status;\n}\n\n \nstatic int nfs4_xdr_dec_lookup_root(struct rpc_rqst *rqstp,\n\t\t\t\t    struct xdr_stream *xdr,\n\t\t\t\t    void *data)\n{\n\tstruct nfs4_lookup_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putrootfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_getfh(xdr, res->fh);\n\tif (status == 0)\n\t\tstatus = decode_getfattr(xdr, res->fattr, res->server);\nout:\n\treturn status;\n}\n\n \nstatic int nfs4_xdr_dec_remove(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t\t       void *data)\n{\n\tstruct nfs_removeres *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_remove(xdr, &res->cinfo);\nout:\n\treturn status;\n}\n\n \nstatic int nfs4_xdr_dec_rename(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t\t       void *data)\n{\n\tstruct nfs_renameres *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_savefh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_rename(xdr, &res->old_cinfo, &res->new_cinfo);\nout:\n\treturn status;\n}\n\n \nstatic int nfs4_xdr_dec_link(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t\t     void *data)\n{\n\tstruct nfs4_link_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_savefh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_link(xdr, &res->cinfo);\n\tif (status)\n\t\tgoto out;\n\t \n\tstatus = decode_restorefh(xdr);\n\tif (status)\n\t\tgoto out;\n\tdecode_getfattr(xdr, res->fattr, res->server);\nout:\n\treturn status;\n}\n\n \nstatic int nfs4_xdr_dec_create(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t\t       void *data)\n{\n\tstruct nfs4_create_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_create(xdr, &res->dir_cinfo);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_getfh(xdr, res->fh);\n\tif (status)\n\t\tgoto out;\n\tdecode_getfattr(xdr, res->fattr, res->server);\nout:\n\treturn status;\n}\n\n \nstatic int nfs4_xdr_dec_symlink(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t\t\tvoid *res)\n{\n\treturn nfs4_xdr_dec_create(rqstp, xdr, res);\n}\n\n \nstatic int nfs4_xdr_dec_getattr(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t\t\tvoid *data)\n{\n\tstruct nfs4_getattr_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_getfattr(xdr, res->fattr, res->server);\nout:\n\treturn status;\n}\n\n \nstatic void nfs4_xdr_enc_setacl(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\tconst void *data)\n{\n\tconst struct nfs_setaclargs *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tencode_setacl(xdr, args, &hdr);\n\tencode_nops(&hdr);\n}\n\n \nstatic int\nnfs4_xdr_dec_setacl(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t    void *data)\n{\n\tstruct nfs_setaclres *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_setattr(xdr);\nout:\n\treturn status;\n}\n\n \nstatic int\nnfs4_xdr_dec_getacl(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t    void *data)\n{\n\tstruct nfs_getaclres *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tif (res->acl_scratch != NULL)\n\t\txdr_set_scratch_page(xdr, res->acl_scratch);\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_getacl(xdr, rqstp, res, res->acl_type);\n\nout:\n\treturn status;\n}\n\n \nstatic int nfs4_xdr_dec_close(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t\t      void *data)\n{\n\tstruct nfs_closeres *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tif (res->lr_res) {\n\t\tstatus = decode_layoutreturn(xdr, res->lr_res);\n\t\tres->lr_ret = status;\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (res->fattr != NULL) {\n\t\tstatus = decode_getfattr(xdr, res->fattr, res->server);\n\t\tif (status != 0)\n\t\t\tgoto out;\n\t}\n\tstatus = decode_close(xdr, res);\nout:\n\treturn status;\n}\n\n \nstatic int nfs4_xdr_dec_open(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t\t     void *data)\n{\n\tstruct nfs_openres *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_open(xdr, res);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_getfh(xdr, &res->fh);\n\tif (status)\n\t\tgoto out;\n\tif (res->access_request)\n\t\tdecode_access(xdr, &res->access_supported, &res->access_result);\n\tdecode_getfattr(xdr, res->f_attr, res->server);\n\tif (res->lg_res)\n\t\tdecode_layoutget(xdr, rqstp, res->lg_res);\nout:\n\treturn status;\n}\n\n \nstatic int nfs4_xdr_dec_open_confirm(struct rpc_rqst *rqstp,\n\t\t\t\t     struct xdr_stream *xdr,\n\t\t\t\t     void *data)\n{\n\tstruct nfs_open_confirmres *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_open_confirm(xdr, res);\nout:\n\treturn status;\n}\n\n \nstatic int nfs4_xdr_dec_open_noattr(struct rpc_rqst *rqstp,\n\t\t\t\t    struct xdr_stream *xdr,\n\t\t\t\t    void *data)\n{\n\tstruct nfs_openres *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_open(xdr, res);\n\tif (status)\n\t\tgoto out;\n\tif (res->access_request)\n\t\tdecode_access(xdr, &res->access_supported, &res->access_result);\n\tdecode_getfattr(xdr, res->f_attr, res->server);\n\tif (res->lg_res)\n\t\tdecode_layoutget(xdr, rqstp, res->lg_res);\nout:\n\treturn status;\n}\n\n \nstatic int nfs4_xdr_dec_setattr(struct rpc_rqst *rqstp,\n\t\t\t\tstruct xdr_stream *xdr,\n\t\t\t\tvoid *data)\n{\n\tstruct nfs_setattrres *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_setattr(xdr);\n\tif (status)\n\t\tgoto out;\n\tdecode_getfattr(xdr, res->fattr, res->server);\nout:\n\treturn status;\n}\n\n \nstatic int nfs4_xdr_dec_lock(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t\t     void *data)\n{\n\tstruct nfs_lock_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_lock(xdr, res);\nout:\n\treturn status;\n}\n\n \nstatic int nfs4_xdr_dec_lockt(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t\t      void *data)\n{\n\tstruct nfs_lockt_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_lockt(xdr, res);\nout:\n\treturn status;\n}\n\n \nstatic int nfs4_xdr_dec_locku(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t\t      void *data)\n{\n\tstruct nfs_locku_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_locku(xdr, res);\nout:\n\treturn status;\n}\n\nstatic int nfs4_xdr_dec_release_lockowner(struct rpc_rqst *rqstp,\n\t\t\t\t\t  struct xdr_stream *xdr, void *dummy)\n{\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (!status)\n\t\tstatus = decode_release_lockowner(xdr);\n\treturn status;\n}\n\n \nstatic int nfs4_xdr_dec_readlink(struct rpc_rqst *rqstp,\n\t\t\t\t struct xdr_stream *xdr,\n\t\t\t\t void *data)\n{\n\tstruct nfs4_readlink_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_readlink(xdr, rqstp);\nout:\n\treturn status;\n}\n\n \nstatic int nfs4_xdr_dec_readdir(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t\t\tvoid *data)\n{\n\tstruct nfs4_readdir_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_readdir(xdr, rqstp, res);\nout:\n\treturn status;\n}\n\n \nstatic int nfs4_xdr_dec_read(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t\t     void *data)\n{\n\tstruct nfs_pgio_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tres->op_status = hdr.status;\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_read(xdr, rqstp, res);\n\tif (!status)\n\t\tstatus = res->count;\nout:\n\treturn status;\n}\n\n \nstatic int nfs4_xdr_dec_write(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t\t      void *data)\n{\n\tstruct nfs_pgio_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tres->op_status = hdr.status;\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_write(xdr, res);\n\tif (status)\n\t\tgoto out;\n\tif (res->fattr)\n\t\tdecode_getfattr(xdr, res->fattr, res->server);\n\tif (!status)\n\t\tstatus = res->count;\nout:\n\treturn status;\n}\n\n \nstatic int nfs4_xdr_dec_commit(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t\t       void *data)\n{\n\tstruct nfs_commitres *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tres->op_status = hdr.status;\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_commit(xdr, res);\nout:\n\treturn status;\n}\n\n \nstatic int nfs4_xdr_dec_fsinfo(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t       void *data)\n{\n\tstruct nfs4_fsinfo_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (!status)\n\t\tstatus = decode_sequence(xdr, &res->seq_res, req);\n\tif (!status)\n\t\tstatus = decode_putfh(xdr);\n\tif (!status)\n\t\tstatus = decode_fsinfo(xdr, res->fsinfo);\n\treturn status;\n}\n\n \nstatic int nfs4_xdr_dec_pathconf(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\t void *data)\n{\n\tstruct nfs4_pathconf_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (!status)\n\t\tstatus = decode_sequence(xdr, &res->seq_res, req);\n\tif (!status)\n\t\tstatus = decode_putfh(xdr);\n\tif (!status)\n\t\tstatus = decode_pathconf(xdr, res->pathconf);\n\treturn status;\n}\n\n \nstatic int nfs4_xdr_dec_statfs(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t       void *data)\n{\n\tstruct nfs4_statfs_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (!status)\n\t\tstatus = decode_sequence(xdr, &res->seq_res, req);\n\tif (!status)\n\t\tstatus = decode_putfh(xdr);\n\tif (!status)\n\t\tstatus = decode_statfs(xdr, res->fsstat);\n\treturn status;\n}\n\n \nstatic int nfs4_xdr_dec_server_caps(struct rpc_rqst *req,\n\t\t\t\t    struct xdr_stream *xdr,\n\t\t\t\t    void *data)\n{\n\tstruct nfs4_server_caps_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, req);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_server_caps(xdr, res);\nout:\n\treturn status;\n}\n\n \nstatic int nfs4_xdr_dec_renew(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t\t      void *__unused)\n{\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (!status)\n\t\tstatus = decode_renew(xdr);\n\treturn status;\n}\n\n \nstatic int nfs4_xdr_dec_setclientid(struct rpc_rqst *req,\n\t\t\t\t    struct xdr_stream *xdr,\n\t\t\t\t    void *data)\n{\n\tstruct nfs4_setclientid_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (!status)\n\t\tstatus = decode_setclientid(xdr, res);\n\treturn status;\n}\n\n \nstatic int nfs4_xdr_dec_setclientid_confirm(struct rpc_rqst *req,\n\t\t\t\t\t    struct xdr_stream *xdr,\n\t\t\t\t\t    void *data)\n{\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (!status)\n\t\tstatus = decode_setclientid_confirm(xdr);\n\treturn status;\n}\n\n \nstatic int nfs4_xdr_dec_delegreturn(struct rpc_rqst *rqstp,\n\t\t\t\t    struct xdr_stream *xdr,\n\t\t\t\t    void *data)\n{\n\tstruct nfs4_delegreturnres *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status != 0)\n\t\tgoto out;\n\tif (res->lr_res) {\n\t\tstatus = decode_layoutreturn(xdr, res->lr_res);\n\t\tres->lr_ret = status;\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (res->fattr) {\n\t\tstatus = decode_getfattr(xdr, res->fattr, res->server);\n\t\tif (status != 0)\n\t\t\tgoto out;\n\t}\n\tstatus = decode_delegreturn(xdr);\nout:\n\treturn status;\n}\n\n \nstatic int nfs4_xdr_dec_fs_locations(struct rpc_rqst *req,\n\t\t\t\t     struct xdr_stream *xdr,\n\t\t\t\t     void *data)\n{\n\tstruct nfs4_fs_locations_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, req);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tif (res->migration) {\n\t\txdr_enter_page(xdr, PAGE_SIZE);\n\t\tstatus = decode_getfattr_generic(xdr,\n\t\t\t\t\tres->fs_locations->fattr,\n\t\t\t\t\t NULL, res->fs_locations,\n\t\t\t\t\t res->fs_locations->server);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tif (res->renew)\n\t\t\tstatus = decode_renew(xdr);\n\t} else {\n\t\tstatus = decode_lookup(xdr);\n\t\tif (status)\n\t\t\tgoto out;\n\t\txdr_enter_page(xdr, PAGE_SIZE);\n\t\tstatus = decode_getfattr_generic(xdr,\n\t\t\t\t\tres->fs_locations->fattr,\n\t\t\t\t\t NULL, res->fs_locations,\n\t\t\t\t\t res->fs_locations->server);\n\t}\nout:\n\treturn status;\n}\n\n \nstatic int nfs4_xdr_dec_secinfo(struct rpc_rqst *rqstp,\n\t\t\t\tstruct xdr_stream *xdr,\n\t\t\t\tvoid *data)\n{\n\tstruct nfs4_secinfo_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_secinfo(xdr, res);\nout:\n\treturn status;\n}\n\n \nstatic int nfs4_xdr_dec_fsid_present(struct rpc_rqst *rqstp,\n\t\t\t\t     struct xdr_stream *xdr,\n\t\t\t\t     void *data)\n{\n\tstruct nfs4_fsid_present_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_getfh(xdr, res->fh);\n\tif (status)\n\t\tgoto out;\n\tif (res->renew)\n\t\tstatus = decode_renew(xdr);\nout:\n\treturn status;\n}\n\n#if defined(CONFIG_NFS_V4_1)\n \nstatic int nfs4_xdr_dec_bind_conn_to_session(struct rpc_rqst *rqstp,\n\t\t\t\t\tstruct xdr_stream *xdr,\n\t\t\t\t\tvoid *res)\n{\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (!status)\n\t\tstatus = decode_bind_conn_to_session(xdr, res);\n\treturn status;\n}\n\n \nstatic int nfs4_xdr_dec_exchange_id(struct rpc_rqst *rqstp,\n\t\t\t\t    struct xdr_stream *xdr,\n\t\t\t\t    void *res)\n{\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (!status)\n\t\tstatus = decode_exchange_id(xdr, res);\n\treturn status;\n}\n\n \nstatic int nfs4_xdr_dec_create_session(struct rpc_rqst *rqstp,\n\t\t\t\t       struct xdr_stream *xdr,\n\t\t\t\t       void *res)\n{\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (!status)\n\t\tstatus = decode_create_session(xdr, res);\n\treturn status;\n}\n\n \nstatic int nfs4_xdr_dec_destroy_session(struct rpc_rqst *rqstp,\n\t\t\t\t\tstruct xdr_stream *xdr,\n\t\t\t\t\tvoid *res)\n{\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (!status)\n\t\tstatus = decode_destroy_session(xdr, res);\n\treturn status;\n}\n\n \nstatic int nfs4_xdr_dec_destroy_clientid(struct rpc_rqst *rqstp,\n\t\t\t\t\tstruct xdr_stream *xdr,\n\t\t\t\t\tvoid *res)\n{\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (!status)\n\t\tstatus = decode_destroy_clientid(xdr, res);\n\treturn status;\n}\n\n \nstatic int nfs4_xdr_dec_sequence(struct rpc_rqst *rqstp,\n\t\t\t\t struct xdr_stream *xdr,\n\t\t\t\t void *res)\n{\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (!status)\n\t\tstatus = decode_sequence(xdr, res, rqstp);\n\treturn status;\n}\n\n#endif\n\n \nstatic int nfs4_xdr_dec_get_lease_time(struct rpc_rqst *rqstp,\n\t\t\t\t       struct xdr_stream *xdr,\n\t\t\t\t       void *data)\n{\n\tstruct nfs4_get_lease_time_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (!status)\n\t\tstatus = decode_sequence(xdr, &res->lr_seq_res, rqstp);\n\tif (!status)\n\t\tstatus = decode_putrootfh(xdr);\n\tif (!status)\n\t\tstatus = decode_fsinfo(xdr, res->lr_fsinfo);\n\treturn status;\n}\n\n#ifdef CONFIG_NFS_V4_1\n\n \nstatic int nfs4_xdr_dec_reclaim_complete(struct rpc_rqst *rqstp,\n\t\t\t\t\t struct xdr_stream *xdr,\n\t\t\t\t\t void *data)\n{\n\tstruct nfs41_reclaim_complete_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (!status)\n\t\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (!status)\n\t\tstatus = decode_reclaim_complete(xdr, NULL);\n\treturn status;\n}\n\n \nstatic int nfs4_xdr_dec_getdeviceinfo(struct rpc_rqst *rqstp,\n\t\t\t\t      struct xdr_stream *xdr,\n\t\t\t\t      void *data)\n{\n\tstruct nfs4_getdeviceinfo_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status != 0)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status != 0)\n\t\tgoto out;\n\tstatus = decode_getdeviceinfo(xdr, res);\nout:\n\treturn status;\n}\n\n \nstatic int nfs4_xdr_dec_layoutget(struct rpc_rqst *rqstp,\n\t\t\t\t  struct xdr_stream *xdr,\n\t\t\t\t  void *data)\n{\n\tstruct nfs4_layoutget_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_layoutget(xdr, rqstp, res);\nout:\n\treturn status;\n}\n\n \nstatic int nfs4_xdr_dec_layoutreturn(struct rpc_rqst *rqstp,\n\t\t\t\t     struct xdr_stream *xdr,\n\t\t\t\t     void *data)\n{\n\tstruct nfs4_layoutreturn_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_layoutreturn(xdr, res);\nout:\n\treturn status;\n}\n\n \nstatic int nfs4_xdr_dec_layoutcommit(struct rpc_rqst *rqstp,\n\t\t\t\t     struct xdr_stream *xdr,\n\t\t\t\t     void *data)\n{\n\tstruct nfs4_layoutcommit_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_layoutcommit(xdr, rqstp, res);\n\tif (status)\n\t\tgoto out;\n\tdecode_getfattr(xdr, res->fattr, res->server);\nout:\n\treturn status;\n}\n\n \nstatic int nfs4_xdr_dec_secinfo_no_name(struct rpc_rqst *rqstp,\n\t\t\t\t\tstruct xdr_stream *xdr,\n\t\t\t\t\tvoid *data)\n{\n\tstruct nfs4_secinfo_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putrootfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_secinfo_no_name(xdr, res);\nout:\n\treturn status;\n}\n\n \nstatic int nfs4_xdr_dec_test_stateid(struct rpc_rqst *rqstp,\n\t\t\t\t     struct xdr_stream *xdr,\n\t\t\t\t     void *data)\n{\n\tstruct nfs41_test_stateid_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_test_stateid(xdr, res);\nout:\n\treturn status;\n}\n\n \nstatic int nfs4_xdr_dec_free_stateid(struct rpc_rqst *rqstp,\n\t\t\t\t     struct xdr_stream *xdr,\n\t\t\t\t     void *data)\n{\n\tstruct nfs41_free_stateid_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_free_stateid(xdr, res);\nout:\n\treturn status;\n}\n#endif  \n\n \nint nfs4_decode_dirent(struct xdr_stream *xdr, struct nfs_entry *entry,\n\t\t       bool plus)\n{\n\tunsigned int savep;\n\tuint32_t bitmap[3] = {0};\n\tuint32_t len;\n\tuint64_t new_cookie;\n\t__be32 *p = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -EAGAIN;\n\tif (*p == xdr_zero) {\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EAGAIN;\n\t\tif (*p == xdr_zero)\n\t\t\treturn -EAGAIN;\n\t\tentry->eof = 1;\n\t\treturn -EBADCOOKIE;\n\t}\n\n\tp = xdr_inline_decode(xdr, 12);\n\tif (unlikely(!p))\n\t\treturn -EAGAIN;\n\tp = xdr_decode_hyper(p, &new_cookie);\n\tentry->len = be32_to_cpup(p);\n\n\tp = xdr_inline_decode(xdr, entry->len);\n\tif (unlikely(!p))\n\t\treturn -EAGAIN;\n\tentry->name = (const char *) p;\n\n\t \n\tentry->ino = 1;\n\tentry->fattr->valid = 0;\n\n\tif (decode_attr_bitmap(xdr, bitmap) < 0)\n\t\treturn -EAGAIN;\n\n\tif (decode_attr_length(xdr, &len, &savep) < 0)\n\t\treturn -EAGAIN;\n\n\tif (decode_getfattr_attrs(xdr, bitmap, entry->fattr, entry->fh,\n\t\t\tNULL, entry->server) < 0)\n\t\treturn -EAGAIN;\n\tif (entry->fattr->valid & NFS_ATTR_FATTR_MOUNTED_ON_FILEID)\n\t\tentry->ino = entry->fattr->mounted_on_fileid;\n\telse if (entry->fattr->valid & NFS_ATTR_FATTR_FILEID)\n\t\tentry->ino = entry->fattr->fileid;\n\n\tentry->d_type = DT_UNKNOWN;\n\tif (entry->fattr->valid & NFS_ATTR_FATTR_TYPE)\n\t\tentry->d_type = nfs_umode_to_dtype(entry->fattr->mode);\n\n\tentry->cookie = new_cookie;\n\n\treturn 0;\n}\n\n \nstatic struct {\n\tint stat;\n\tint errno;\n} nfs_errtbl[] = {\n\t{ NFS4_OK,\t\t0\t\t},\n\t{ NFS4ERR_PERM,\t\t-EPERM\t\t},\n\t{ NFS4ERR_NOENT,\t-ENOENT\t\t},\n\t{ NFS4ERR_IO,\t\t-errno_NFSERR_IO},\n\t{ NFS4ERR_NXIO,\t\t-ENXIO\t\t},\n\t{ NFS4ERR_ACCESS,\t-EACCES\t\t},\n\t{ NFS4ERR_EXIST,\t-EEXIST\t\t},\n\t{ NFS4ERR_XDEV,\t\t-EXDEV\t\t},\n\t{ NFS4ERR_NOTDIR,\t-ENOTDIR\t},\n\t{ NFS4ERR_ISDIR,\t-EISDIR\t\t},\n\t{ NFS4ERR_INVAL,\t-EINVAL\t\t},\n\t{ NFS4ERR_FBIG,\t\t-EFBIG\t\t},\n\t{ NFS4ERR_NOSPC,\t-ENOSPC\t\t},\n\t{ NFS4ERR_ROFS,\t\t-EROFS\t\t},\n\t{ NFS4ERR_MLINK,\t-EMLINK\t\t},\n\t{ NFS4ERR_NAMETOOLONG,\t-ENAMETOOLONG\t},\n\t{ NFS4ERR_NOTEMPTY,\t-ENOTEMPTY\t},\n\t{ NFS4ERR_DQUOT,\t-EDQUOT\t\t},\n\t{ NFS4ERR_STALE,\t-ESTALE\t\t},\n\t{ NFS4ERR_BADHANDLE,\t-EBADHANDLE\t},\n\t{ NFS4ERR_BAD_COOKIE,\t-EBADCOOKIE\t},\n\t{ NFS4ERR_NOTSUPP,\t-ENOTSUPP\t},\n\t{ NFS4ERR_TOOSMALL,\t-ETOOSMALL\t},\n\t{ NFS4ERR_SERVERFAULT,\t-EREMOTEIO\t},\n\t{ NFS4ERR_BADTYPE,\t-EBADTYPE\t},\n\t{ NFS4ERR_LOCKED,\t-EAGAIN\t\t},\n\t{ NFS4ERR_SYMLINK,\t-ELOOP\t\t},\n\t{ NFS4ERR_OP_ILLEGAL,\t-EOPNOTSUPP\t},\n\t{ NFS4ERR_DEADLOCK,\t-EDEADLK\t},\n\t{ NFS4ERR_NOXATTR,\t-ENODATA\t},\n\t{ NFS4ERR_XATTR2BIG,\t-E2BIG\t\t},\n\t{ -1,\t\t\t-EIO\t\t}\n};\n\n \nstatic int\nnfs4_stat_to_errno(int stat)\n{\n\tint i;\n\tfor (i = 0; nfs_errtbl[i].stat != -1; i++) {\n\t\tif (nfs_errtbl[i].stat == stat)\n\t\t\treturn nfs_errtbl[i].errno;\n\t}\n\tif (stat <= 10000 || stat > 10100) {\n\t\t \n\t\treturn -EREMOTEIO;\n\t}\n\t \n\treturn -stat;\n}\n\n#ifdef CONFIG_NFS_V4_2\n#include \"nfs42xdr.c\"\n#endif  \n\n#define PROC(proc, argtype, restype)\t\t\t\t\\\n[NFSPROC4_CLNT_##proc] = {\t\t\t\t\t\\\n\t.p_proc   = NFSPROC4_COMPOUND,\t\t\t\t\\\n\t.p_encode = nfs4_xdr_##argtype,\t\t\t\t\\\n\t.p_decode = nfs4_xdr_##restype,\t\t\t\t\\\n\t.p_arglen = NFS4_##argtype##_sz,\t\t\t\\\n\t.p_replen = NFS4_##restype##_sz,\t\t\t\\\n\t.p_statidx = NFSPROC4_CLNT_##proc,\t\t\t\\\n\t.p_name   = #proc,\t\t\t\t\t\\\n}\n\n#define STUB(proc)\t\t\\\n[NFSPROC4_CLNT_##proc] = {\t\\\n\t.p_name = #proc,\t\\\n}\n\n#if defined(CONFIG_NFS_V4_1)\n#define PROC41(proc, argtype, restype)\t\t\t\t\\\n\tPROC(proc, argtype, restype)\n#else\n#define PROC41(proc, argtype, restype)\t\t\t\t\\\n\tSTUB(proc)\n#endif\n\n#if defined(CONFIG_NFS_V4_2)\n#define PROC42(proc, argtype, restype)\t\t\t\t\\\n\tPROC(proc, argtype, restype)\n#else\n#define PROC42(proc, argtype, restype)\t\t\t\t\\\n\tSTUB(proc)\n#endif\n\nconst struct rpc_procinfo nfs4_procedures[] = {\n\tPROC(READ,\t\tenc_read,\t\tdec_read),\n\tPROC(WRITE,\t\tenc_write,\t\tdec_write),\n\tPROC(COMMIT,\t\tenc_commit,\t\tdec_commit),\n\tPROC(OPEN,\t\tenc_open,\t\tdec_open),\n\tPROC(OPEN_CONFIRM,\tenc_open_confirm,\tdec_open_confirm),\n\tPROC(OPEN_NOATTR,\tenc_open_noattr,\tdec_open_noattr),\n\tPROC(OPEN_DOWNGRADE,\tenc_open_downgrade,\tdec_open_downgrade),\n\tPROC(CLOSE,\t\tenc_close,\t\tdec_close),\n\tPROC(SETATTR,\t\tenc_setattr,\t\tdec_setattr),\n\tPROC(FSINFO,\t\tenc_fsinfo,\t\tdec_fsinfo),\n\tPROC(RENEW,\t\tenc_renew,\t\tdec_renew),\n\tPROC(SETCLIENTID,\tenc_setclientid,\tdec_setclientid),\n\tPROC(SETCLIENTID_CONFIRM, enc_setclientid_confirm, dec_setclientid_confirm),\n\tPROC(LOCK,\t\tenc_lock,\t\tdec_lock),\n\tPROC(LOCKT,\t\tenc_lockt,\t\tdec_lockt),\n\tPROC(LOCKU,\t\tenc_locku,\t\tdec_locku),\n\tPROC(ACCESS,\t\tenc_access,\t\tdec_access),\n\tPROC(GETATTR,\t\tenc_getattr,\t\tdec_getattr),\n\tPROC(LOOKUP,\t\tenc_lookup,\t\tdec_lookup),\n\tPROC(LOOKUP_ROOT,\tenc_lookup_root,\tdec_lookup_root),\n\tPROC(REMOVE,\t\tenc_remove,\t\tdec_remove),\n\tPROC(RENAME,\t\tenc_rename,\t\tdec_rename),\n\tPROC(LINK,\t\tenc_link,\t\tdec_link),\n\tPROC(SYMLINK,\t\tenc_symlink,\t\tdec_symlink),\n\tPROC(CREATE,\t\tenc_create,\t\tdec_create),\n\tPROC(PATHCONF,\t\tenc_pathconf,\t\tdec_pathconf),\n\tPROC(STATFS,\t\tenc_statfs,\t\tdec_statfs),\n\tPROC(READLINK,\t\tenc_readlink,\t\tdec_readlink),\n\tPROC(READDIR,\t\tenc_readdir,\t\tdec_readdir),\n\tPROC(SERVER_CAPS,\tenc_server_caps,\tdec_server_caps),\n\tPROC(DELEGRETURN,\tenc_delegreturn,\tdec_delegreturn),\n\tPROC(GETACL,\t\tenc_getacl,\t\tdec_getacl),\n\tPROC(SETACL,\t\tenc_setacl,\t\tdec_setacl),\n\tPROC(FS_LOCATIONS,\tenc_fs_locations,\tdec_fs_locations),\n\tPROC(RELEASE_LOCKOWNER,\tenc_release_lockowner,\tdec_release_lockowner),\n\tPROC(SECINFO,\t\tenc_secinfo,\t\tdec_secinfo),\n\tPROC(FSID_PRESENT,\tenc_fsid_present,\tdec_fsid_present),\n\tPROC41(EXCHANGE_ID,\tenc_exchange_id,\tdec_exchange_id),\n\tPROC41(CREATE_SESSION,\tenc_create_session,\tdec_create_session),\n\tPROC41(DESTROY_SESSION,\tenc_destroy_session,\tdec_destroy_session),\n\tPROC41(SEQUENCE,\tenc_sequence,\t\tdec_sequence),\n\tPROC(GET_LEASE_TIME,\tenc_get_lease_time,\tdec_get_lease_time),\n\tPROC41(RECLAIM_COMPLETE,enc_reclaim_complete,\tdec_reclaim_complete),\n\tPROC41(GETDEVICEINFO,\tenc_getdeviceinfo,\tdec_getdeviceinfo),\n\tPROC41(LAYOUTGET,\tenc_layoutget,\t\tdec_layoutget),\n\tPROC41(LAYOUTCOMMIT,\tenc_layoutcommit,\tdec_layoutcommit),\n\tPROC41(LAYOUTRETURN,\tenc_layoutreturn,\tdec_layoutreturn),\n\tPROC41(SECINFO_NO_NAME,\tenc_secinfo_no_name,\tdec_secinfo_no_name),\n\tPROC41(TEST_STATEID,\tenc_test_stateid,\tdec_test_stateid),\n\tPROC41(FREE_STATEID,\tenc_free_stateid,\tdec_free_stateid),\n\tSTUB(GETDEVICELIST),\n\tPROC41(BIND_CONN_TO_SESSION,\n\t\t\tenc_bind_conn_to_session, dec_bind_conn_to_session),\n\tPROC41(DESTROY_CLIENTID,enc_destroy_clientid,\tdec_destroy_clientid),\n\tPROC42(SEEK,\t\tenc_seek,\t\tdec_seek),\n\tPROC42(ALLOCATE,\tenc_allocate,\t\tdec_allocate),\n\tPROC42(DEALLOCATE,\tenc_deallocate,\t\tdec_deallocate),\n\tPROC42(LAYOUTSTATS,\tenc_layoutstats,\tdec_layoutstats),\n\tPROC42(CLONE,\t\tenc_clone,\t\tdec_clone),\n\tPROC42(COPY,\t\tenc_copy,\t\tdec_copy),\n\tPROC42(OFFLOAD_CANCEL,\tenc_offload_cancel,\tdec_offload_cancel),\n\tPROC42(COPY_NOTIFY,\tenc_copy_notify,\tdec_copy_notify),\n\tPROC(LOOKUPP,\t\tenc_lookupp,\t\tdec_lookupp),\n\tPROC42(LAYOUTERROR,\tenc_layouterror,\tdec_layouterror),\n\tPROC42(GETXATTR,\tenc_getxattr,\t\tdec_getxattr),\n\tPROC42(SETXATTR,\tenc_setxattr,\t\tdec_setxattr),\n\tPROC42(LISTXATTRS,\tenc_listxattrs,\t\tdec_listxattrs),\n\tPROC42(REMOVEXATTR,\tenc_removexattr,\tdec_removexattr),\n\tPROC42(READ_PLUS,\tenc_read_plus,\t\tdec_read_plus),\n};\n\nstatic unsigned int nfs_version4_counts[ARRAY_SIZE(nfs4_procedures)];\nconst struct rpc_version nfs_version4 = {\n\t.number\t\t\t= 4,\n\t.nrprocs\t\t= ARRAY_SIZE(nfs4_procedures),\n\t.procs\t\t\t= nfs4_procedures,\n\t.counts\t\t\t= nfs_version4_counts,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}