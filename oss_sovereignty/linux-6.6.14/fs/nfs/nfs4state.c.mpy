{
  "module_name": "nfs4state.c",
  "hash_id": "f58aae81da31670d9ac17fb1d07c3b68c756a8a72b0b2f55f3e9908f58e98a29",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfs/nfs4state.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/nfs_fs.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/ratelimit.h>\n#include <linux/workqueue.h>\n#include <linux/bitops.h>\n#include <linux/jiffies.h>\n#include <linux/sched/mm.h>\n\n#include <linux/sunrpc/clnt.h>\n\n#include \"nfs4_fs.h\"\n#include \"callback.h\"\n#include \"delegation.h\"\n#include \"internal.h\"\n#include \"nfs4idmap.h\"\n#include \"nfs4session.h\"\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfs4trace.h\"\n\n#define NFSDBG_FACILITY\t\tNFSDBG_STATE\n\n#define OPENOWNER_POOL_SIZE\t8\n\nstatic void nfs4_state_start_reclaim_reboot(struct nfs_client *clp);\n\nconst nfs4_stateid zero_stateid = {\n\t{ .data = { 0 } },\n\t.type = NFS4_SPECIAL_STATEID_TYPE,\n};\nconst nfs4_stateid invalid_stateid = {\n\t{\n\t\t \n\t\t.data = { 0xff, 0xff, 0xff, 0xff, 0 },\n\t},\n\t.type = NFS4_INVALID_STATEID_TYPE,\n};\n\nconst nfs4_stateid current_stateid = {\n\t{\n\t\t \n\t\t.data = { 0x0, 0x0, 0x0, 0x1, 0 },\n\t},\n\t.type = NFS4_SPECIAL_STATEID_TYPE,\n};\n\nstatic DEFINE_MUTEX(nfs_clid_init_mutex);\n\nstatic int nfs4_setup_state_renewal(struct nfs_client *clp)\n{\n\tint status;\n\tstruct nfs_fsinfo fsinfo;\n\n\tif (!test_bit(NFS_CS_CHECK_LEASE_TIME, &clp->cl_res_state)) {\n\t\tnfs4_schedule_state_renewal(clp);\n\t\treturn 0;\n\t}\n\n\tstatus = nfs4_proc_get_lease_time(clp, &fsinfo);\n\tif (status == 0) {\n\t\tnfs4_set_lease_period(clp, fsinfo.lease_time * HZ);\n\t\tnfs4_schedule_state_renewal(clp);\n\t}\n\n\treturn status;\n}\n\nint nfs4_init_clientid(struct nfs_client *clp, const struct cred *cred)\n{\n\tstruct nfs4_setclientid_res clid = {\n\t\t.clientid = clp->cl_clientid,\n\t\t.confirm = clp->cl_confirm,\n\t};\n\tunsigned short port;\n\tint status;\n\tstruct nfs_net *nn = net_generic(clp->cl_net, nfs_net_id);\n\n\tif (test_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state))\n\t\tgoto do_confirm;\n\tport = nn->nfs_callback_tcpport;\n\tif (clp->cl_addr.ss_family == AF_INET6)\n\t\tport = nn->nfs_callback_tcpport6;\n\n\tstatus = nfs4_proc_setclientid(clp, NFS4_CALLBACK, port, cred, &clid);\n\tif (status != 0)\n\t\tgoto out;\n\tclp->cl_clientid = clid.clientid;\n\tclp->cl_confirm = clid.confirm;\n\tset_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state);\ndo_confirm:\n\tstatus = nfs4_proc_setclientid_confirm(clp, &clid, cred);\n\tif (status != 0)\n\t\tgoto out;\n\tclear_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state);\n\tnfs4_setup_state_renewal(clp);\nout:\n\treturn status;\n}\n\n \nint nfs40_discover_server_trunking(struct nfs_client *clp,\n\t\t\t\t   struct nfs_client **result,\n\t\t\t\t   const struct cred *cred)\n{\n\tstruct nfs4_setclientid_res clid = {\n\t\t.clientid = clp->cl_clientid,\n\t\t.confirm = clp->cl_confirm,\n\t};\n\tstruct nfs_net *nn = net_generic(clp->cl_net, nfs_net_id);\n\tunsigned short port;\n\tint status;\n\n\tport = nn->nfs_callback_tcpport;\n\tif (clp->cl_addr.ss_family == AF_INET6)\n\t\tport = nn->nfs_callback_tcpport6;\n\n\tstatus = nfs4_proc_setclientid(clp, NFS4_CALLBACK, port, cred, &clid);\n\tif (status != 0)\n\t\tgoto out;\n\tclp->cl_clientid = clid.clientid;\n\tclp->cl_confirm = clid.confirm;\n\n\tstatus = nfs40_walk_client_list(clp, result, cred);\n\tif (status == 0) {\n\t\t \n\t\tnfs4_schedule_state_renewal(*result);\n\n\t\t \n\t\tif (clp->cl_state)\n\t\t\tnfs4_schedule_state_manager(clp);\n\t}\nout:\n\treturn status;\n}\n\nconst struct cred *nfs4_get_machine_cred(struct nfs_client *clp)\n{\n\treturn get_cred(rpc_machine_cred());\n}\n\nstatic void nfs4_root_machine_cred(struct nfs_client *clp)\n{\n\n\t \n\tclp->cl_principal = NULL;\n\tclp->cl_rpcclient->cl_principal = NULL;\n}\n\nstatic const struct cred *\nnfs4_get_renew_cred_server_locked(struct nfs_server *server)\n{\n\tconst struct cred *cred = NULL;\n\tstruct nfs4_state_owner *sp;\n\tstruct rb_node *pos;\n\n\tfor (pos = rb_first(&server->state_owners);\n\t     pos != NULL;\n\t     pos = rb_next(pos)) {\n\t\tsp = rb_entry(pos, struct nfs4_state_owner, so_server_node);\n\t\tif (list_empty(&sp->so_states))\n\t\t\tcontinue;\n\t\tcred = get_cred(sp->so_cred);\n\t\tbreak;\n\t}\n\treturn cred;\n}\n\n \nconst struct cred *nfs4_get_renew_cred(struct nfs_client *clp)\n{\n\tconst struct cred *cred = NULL;\n\tstruct nfs_server *server;\n\n\t \n\tcred = nfs4_get_machine_cred(clp);\n\tif (cred != NULL)\n\t\tgoto out;\n\n\tspin_lock(&clp->cl_lock);\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link) {\n\t\tcred = nfs4_get_renew_cred_server_locked(server);\n\t\tif (cred != NULL)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\tspin_unlock(&clp->cl_lock);\n\nout:\n\treturn cred;\n}\n\nstatic void nfs4_end_drain_slot_table(struct nfs4_slot_table *tbl)\n{\n\tif (test_and_clear_bit(NFS4_SLOT_TBL_DRAINING, &tbl->slot_tbl_state)) {\n\t\tspin_lock(&tbl->slot_tbl_lock);\n\t\tnfs41_wake_slot_table(tbl);\n\t\tspin_unlock(&tbl->slot_tbl_lock);\n\t}\n}\n\nstatic void nfs4_end_drain_session(struct nfs_client *clp)\n{\n\tstruct nfs4_session *ses = clp->cl_session;\n\n\tif (clp->cl_slot_tbl) {\n\t\tnfs4_end_drain_slot_table(clp->cl_slot_tbl);\n\t\treturn;\n\t}\n\n\tif (ses != NULL) {\n\t\tnfs4_end_drain_slot_table(&ses->bc_slot_table);\n\t\tnfs4_end_drain_slot_table(&ses->fc_slot_table);\n\t}\n}\n\nstatic int nfs4_drain_slot_tbl(struct nfs4_slot_table *tbl)\n{\n\tset_bit(NFS4_SLOT_TBL_DRAINING, &tbl->slot_tbl_state);\n\tspin_lock(&tbl->slot_tbl_lock);\n\tif (tbl->highest_used_slotid != NFS4_NO_SLOT) {\n\t\treinit_completion(&tbl->complete);\n\t\tspin_unlock(&tbl->slot_tbl_lock);\n\t\treturn wait_for_completion_interruptible(&tbl->complete);\n\t}\n\tspin_unlock(&tbl->slot_tbl_lock);\n\treturn 0;\n}\n\nstatic int nfs4_begin_drain_session(struct nfs_client *clp)\n{\n\tstruct nfs4_session *ses = clp->cl_session;\n\tint ret;\n\n\tif (clp->cl_slot_tbl)\n\t\treturn nfs4_drain_slot_tbl(clp->cl_slot_tbl);\n\n\t \n\tret = nfs4_drain_slot_tbl(&ses->bc_slot_table);\n\tif (ret)\n\t\treturn ret;\n\t \n\treturn nfs4_drain_slot_tbl(&ses->fc_slot_table);\n}\n\n#if defined(CONFIG_NFS_V4_1)\n\nstatic void nfs41_finish_session_reset(struct nfs_client *clp)\n{\n\tclear_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state);\n\tclear_bit(NFS4CLNT_SESSION_RESET, &clp->cl_state);\n\t \n\tclear_bit(NFS4CLNT_BIND_CONN_TO_SESSION, &clp->cl_state);\n\tnfs4_setup_state_renewal(clp);\n}\n\nint nfs41_init_clientid(struct nfs_client *clp, const struct cred *cred)\n{\n\tint status;\n\n\tif (test_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state))\n\t\tgoto do_confirm;\n\tstatus = nfs4_proc_exchange_id(clp, cred);\n\tif (status != 0)\n\t\tgoto out;\n\tset_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state);\ndo_confirm:\n\tstatus = nfs4_proc_create_session(clp, cred);\n\tif (status != 0)\n\t\tgoto out;\n\tif (!(clp->cl_exchange_flags & EXCHGID4_FLAG_CONFIRMED_R))\n\t\tnfs4_state_start_reclaim_reboot(clp);\n\tnfs41_finish_session_reset(clp);\n\tnfs_mark_client_ready(clp, NFS_CS_READY);\nout:\n\treturn status;\n}\n\n \nint nfs41_discover_server_trunking(struct nfs_client *clp,\n\t\t\t\t   struct nfs_client **result,\n\t\t\t\t   const struct cred *cred)\n{\n\tint status;\n\n\tstatus = nfs4_proc_exchange_id(clp, cred);\n\tif (status != NFS4_OK)\n\t\treturn status;\n\n\tstatus = nfs41_walk_client_list(clp, result, cred);\n\tif (status < 0)\n\t\treturn status;\n\tif (clp != *result)\n\t\treturn 0;\n\n\t \n\tif (clp->cl_exchange_flags & EXCHGID4_FLAG_CONFIRMED_R) {\n\t\tif (!test_bit(NFS_CS_TSM_POSSIBLE, &clp->cl_flags))\n\t\t\tset_bit(NFS4CLNT_PURGE_STATE, &clp->cl_state);\n\t\telse\n\t\t\tset_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state);\n\t}\n\tnfs4_schedule_state_manager(clp);\n\tstatus = nfs_wait_client_init_complete(clp);\n\tif (status < 0)\n\t\tnfs_put_client(clp);\n\treturn status;\n}\n\n#endif  \n\n \nconst struct cred *nfs4_get_clid_cred(struct nfs_client *clp)\n{\n\tconst struct cred *cred;\n\n\tcred = nfs4_get_machine_cred(clp);\n\treturn cred;\n}\n\nstatic struct nfs4_state_owner *\nnfs4_find_state_owner_locked(struct nfs_server *server, const struct cred *cred)\n{\n\tstruct rb_node **p = &server->state_owners.rb_node,\n\t\t       *parent = NULL;\n\tstruct nfs4_state_owner *sp;\n\tint cmp;\n\n\twhile (*p != NULL) {\n\t\tparent = *p;\n\t\tsp = rb_entry(parent, struct nfs4_state_owner, so_server_node);\n\t\tcmp = cred_fscmp(cred, sp->so_cred);\n\n\t\tif (cmp < 0)\n\t\t\tp = &parent->rb_left;\n\t\telse if (cmp > 0)\n\t\t\tp = &parent->rb_right;\n\t\telse {\n\t\t\tif (!list_empty(&sp->so_lru))\n\t\t\t\tlist_del_init(&sp->so_lru);\n\t\t\tatomic_inc(&sp->so_count);\n\t\t\treturn sp;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic struct nfs4_state_owner *\nnfs4_insert_state_owner_locked(struct nfs4_state_owner *new)\n{\n\tstruct nfs_server *server = new->so_server;\n\tstruct rb_node **p = &server->state_owners.rb_node,\n\t\t       *parent = NULL;\n\tstruct nfs4_state_owner *sp;\n\tint cmp;\n\n\twhile (*p != NULL) {\n\t\tparent = *p;\n\t\tsp = rb_entry(parent, struct nfs4_state_owner, so_server_node);\n\t\tcmp = cred_fscmp(new->so_cred, sp->so_cred);\n\n\t\tif (cmp < 0)\n\t\t\tp = &parent->rb_left;\n\t\telse if (cmp > 0)\n\t\t\tp = &parent->rb_right;\n\t\telse {\n\t\t\tif (!list_empty(&sp->so_lru))\n\t\t\t\tlist_del_init(&sp->so_lru);\n\t\t\tatomic_inc(&sp->so_count);\n\t\t\treturn sp;\n\t\t}\n\t}\n\trb_link_node(&new->so_server_node, parent, p);\n\trb_insert_color(&new->so_server_node, &server->state_owners);\n\treturn new;\n}\n\nstatic void\nnfs4_remove_state_owner_locked(struct nfs4_state_owner *sp)\n{\n\tstruct nfs_server *server = sp->so_server;\n\n\tif (!RB_EMPTY_NODE(&sp->so_server_node))\n\t\trb_erase(&sp->so_server_node, &server->state_owners);\n}\n\nstatic void\nnfs4_init_seqid_counter(struct nfs_seqid_counter *sc)\n{\n\tsc->create_time = ktime_get();\n\tsc->flags = 0;\n\tsc->counter = 0;\n\tspin_lock_init(&sc->lock);\n\tINIT_LIST_HEAD(&sc->list);\n\trpc_init_wait_queue(&sc->wait, \"Seqid_waitqueue\");\n}\n\nstatic void\nnfs4_destroy_seqid_counter(struct nfs_seqid_counter *sc)\n{\n\trpc_destroy_wait_queue(&sc->wait);\n}\n\n \nstatic struct nfs4_state_owner *\nnfs4_alloc_state_owner(struct nfs_server *server,\n\t\tconst struct cred *cred,\n\t\tgfp_t gfp_flags)\n{\n\tstruct nfs4_state_owner *sp;\n\n\tsp = kzalloc(sizeof(*sp), gfp_flags);\n\tif (!sp)\n\t\treturn NULL;\n\tsp->so_seqid.owner_id = ida_alloc(&server->openowner_id, gfp_flags);\n\tif (sp->so_seqid.owner_id < 0) {\n\t\tkfree(sp);\n\t\treturn NULL;\n\t}\n\tsp->so_server = server;\n\tsp->so_cred = get_cred(cred);\n\tspin_lock_init(&sp->so_lock);\n\tINIT_LIST_HEAD(&sp->so_states);\n\tnfs4_init_seqid_counter(&sp->so_seqid);\n\tatomic_set(&sp->so_count, 1);\n\tINIT_LIST_HEAD(&sp->so_lru);\n\tseqcount_spinlock_init(&sp->so_reclaim_seqcount, &sp->so_lock);\n\tmutex_init(&sp->so_delegreturn_mutex);\n\treturn sp;\n}\n\nstatic void\nnfs4_reset_state_owner(struct nfs4_state_owner *sp)\n{\n\t \n\tsp->so_seqid.create_time = ktime_get();\n}\n\nstatic void nfs4_free_state_owner(struct nfs4_state_owner *sp)\n{\n\tnfs4_destroy_seqid_counter(&sp->so_seqid);\n\tput_cred(sp->so_cred);\n\tida_free(&sp->so_server->openowner_id, sp->so_seqid.owner_id);\n\tkfree(sp);\n}\n\nstatic void nfs4_gc_state_owners(struct nfs_server *server)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct nfs4_state_owner *sp, *tmp;\n\tunsigned long time_min, time_max;\n\tLIST_HEAD(doomed);\n\n\tspin_lock(&clp->cl_lock);\n\ttime_max = jiffies;\n\ttime_min = (long)time_max - (long)clp->cl_lease_time;\n\tlist_for_each_entry_safe(sp, tmp, &server->state_owners_lru, so_lru) {\n\t\t \n\t\tif (time_in_range(sp->so_expires, time_min, time_max))\n\t\t\tbreak;\n\t\tlist_move(&sp->so_lru, &doomed);\n\t\tnfs4_remove_state_owner_locked(sp);\n\t}\n\tspin_unlock(&clp->cl_lock);\n\n\tlist_for_each_entry_safe(sp, tmp, &doomed, so_lru) {\n\t\tlist_del(&sp->so_lru);\n\t\tnfs4_free_state_owner(sp);\n\t}\n}\n\n \nstruct nfs4_state_owner *nfs4_get_state_owner(struct nfs_server *server,\n\t\t\t\t\t      const struct cred *cred,\n\t\t\t\t\t      gfp_t gfp_flags)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct nfs4_state_owner *sp, *new;\n\n\tspin_lock(&clp->cl_lock);\n\tsp = nfs4_find_state_owner_locked(server, cred);\n\tspin_unlock(&clp->cl_lock);\n\tif (sp != NULL)\n\t\tgoto out;\n\tnew = nfs4_alloc_state_owner(server, cred, gfp_flags);\n\tif (new == NULL)\n\t\tgoto out;\n\tspin_lock(&clp->cl_lock);\n\tsp = nfs4_insert_state_owner_locked(new);\n\tspin_unlock(&clp->cl_lock);\n\tif (sp != new)\n\t\tnfs4_free_state_owner(new);\nout:\n\tnfs4_gc_state_owners(server);\n\treturn sp;\n}\n\n \nvoid nfs4_put_state_owner(struct nfs4_state_owner *sp)\n{\n\tstruct nfs_server *server = sp->so_server;\n\tstruct nfs_client *clp = server->nfs_client;\n\n\tif (!atomic_dec_and_lock(&sp->so_count, &clp->cl_lock))\n\t\treturn;\n\n\tsp->so_expires = jiffies;\n\tlist_add_tail(&sp->so_lru, &server->state_owners_lru);\n\tspin_unlock(&clp->cl_lock);\n}\n\n \nvoid nfs4_purge_state_owners(struct nfs_server *server, struct list_head *head)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct nfs4_state_owner *sp, *tmp;\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(sp, tmp, &server->state_owners_lru, so_lru) {\n\t\tlist_move(&sp->so_lru, head);\n\t\tnfs4_remove_state_owner_locked(sp);\n\t}\n\tspin_unlock(&clp->cl_lock);\n}\n\n \nvoid nfs4_free_state_owners(struct list_head *head)\n{\n\tstruct nfs4_state_owner *sp, *tmp;\n\n\tlist_for_each_entry_safe(sp, tmp, head, so_lru) {\n\t\tlist_del(&sp->so_lru);\n\t\tnfs4_free_state_owner(sp);\n\t}\n}\n\nstatic struct nfs4_state *\nnfs4_alloc_open_state(void)\n{\n\tstruct nfs4_state *state;\n\n\tstate = kzalloc(sizeof(*state), GFP_KERNEL_ACCOUNT);\n\tif (!state)\n\t\treturn NULL;\n\trefcount_set(&state->count, 1);\n\tINIT_LIST_HEAD(&state->lock_states);\n\tspin_lock_init(&state->state_lock);\n\tseqlock_init(&state->seqlock);\n\tinit_waitqueue_head(&state->waitq);\n\treturn state;\n}\n\nvoid\nnfs4_state_set_mode_locked(struct nfs4_state *state, fmode_t fmode)\n{\n\tif (state->state == fmode)\n\t\treturn;\n\t \n\tif ((fmode & FMODE_WRITE) != (state->state & FMODE_WRITE)) {\n\t\tif (fmode & FMODE_WRITE)\n\t\t\tlist_move(&state->open_states, &state->owner->so_states);\n\t\telse\n\t\t\tlist_move_tail(&state->open_states, &state->owner->so_states);\n\t}\n\tstate->state = fmode;\n}\n\nstatic struct nfs4_state *\n__nfs4_find_state_byowner(struct inode *inode, struct nfs4_state_owner *owner)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs4_state *state;\n\n\tlist_for_each_entry_rcu(state, &nfsi->open_states, inode_states) {\n\t\tif (state->owner != owner)\n\t\t\tcontinue;\n\t\tif (!nfs4_valid_open_stateid(state))\n\t\t\tcontinue;\n\t\tif (refcount_inc_not_zero(&state->count))\n\t\t\treturn state;\n\t}\n\treturn NULL;\n}\n\nstatic void\nnfs4_free_open_state(struct nfs4_state *state)\n{\n\tkfree_rcu(state, rcu_head);\n}\n\nstruct nfs4_state *\nnfs4_get_open_state(struct inode *inode, struct nfs4_state_owner *owner)\n{\n\tstruct nfs4_state *state, *new;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\trcu_read_lock();\n\tstate = __nfs4_find_state_byowner(inode, owner);\n\trcu_read_unlock();\n\tif (state)\n\t\tgoto out;\n\tnew = nfs4_alloc_open_state();\n\tspin_lock(&owner->so_lock);\n\tspin_lock(&inode->i_lock);\n\tstate = __nfs4_find_state_byowner(inode, owner);\n\tif (state == NULL && new != NULL) {\n\t\tstate = new;\n\t\tstate->owner = owner;\n\t\tatomic_inc(&owner->so_count);\n\t\tihold(inode);\n\t\tstate->inode = inode;\n\t\tlist_add_rcu(&state->inode_states, &nfsi->open_states);\n\t\tspin_unlock(&inode->i_lock);\n\t\t \n\t\tlist_add_tail(&state->open_states, &owner->so_states);\n\t\tspin_unlock(&owner->so_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\tspin_unlock(&owner->so_lock);\n\t\tif (new)\n\t\t\tnfs4_free_open_state(new);\n\t}\nout:\n\treturn state;\n}\n\nvoid nfs4_put_open_state(struct nfs4_state *state)\n{\n\tstruct inode *inode = state->inode;\n\tstruct nfs4_state_owner *owner = state->owner;\n\n\tif (!refcount_dec_and_lock(&state->count, &owner->so_lock))\n\t\treturn;\n\tspin_lock(&inode->i_lock);\n\tlist_del_rcu(&state->inode_states);\n\tlist_del(&state->open_states);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&owner->so_lock);\n\tnfs4_inode_return_delegation_on_close(inode);\n\tiput(inode);\n\tnfs4_free_open_state(state);\n\tnfs4_put_state_owner(owner);\n}\n\n \nstatic void __nfs4_close(struct nfs4_state *state,\n\t\tfmode_t fmode, gfp_t gfp_mask, int wait)\n{\n\tstruct nfs4_state_owner *owner = state->owner;\n\tint call_close = 0;\n\tfmode_t newstate;\n\n\tatomic_inc(&owner->so_count);\n\t \n\tspin_lock(&owner->so_lock);\n\tswitch (fmode & (FMODE_READ | FMODE_WRITE)) {\n\t\tcase FMODE_READ:\n\t\t\tstate->n_rdonly--;\n\t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tstate->n_wronly--;\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tstate->n_rdwr--;\n\t}\n\tnewstate = FMODE_READ|FMODE_WRITE;\n\tif (state->n_rdwr == 0) {\n\t\tif (state->n_rdonly == 0) {\n\t\t\tnewstate &= ~FMODE_READ;\n\t\t\tcall_close |= test_bit(NFS_O_RDONLY_STATE, &state->flags);\n\t\t\tcall_close |= test_bit(NFS_O_RDWR_STATE, &state->flags);\n\t\t}\n\t\tif (state->n_wronly == 0) {\n\t\t\tnewstate &= ~FMODE_WRITE;\n\t\t\tcall_close |= test_bit(NFS_O_WRONLY_STATE, &state->flags);\n\t\t\tcall_close |= test_bit(NFS_O_RDWR_STATE, &state->flags);\n\t\t}\n\t\tif (newstate == 0)\n\t\t\tclear_bit(NFS_DELEGATED_STATE, &state->flags);\n\t}\n\tnfs4_state_set_mode_locked(state, newstate);\n\tspin_unlock(&owner->so_lock);\n\n\tif (!call_close) {\n\t\tnfs4_put_open_state(state);\n\t\tnfs4_put_state_owner(owner);\n\t} else\n\t\tnfs4_do_close(state, gfp_mask, wait);\n}\n\nvoid nfs4_close_state(struct nfs4_state *state, fmode_t fmode)\n{\n\t__nfs4_close(state, fmode, GFP_KERNEL, 0);\n}\n\nvoid nfs4_close_sync(struct nfs4_state *state, fmode_t fmode)\n{\n\t__nfs4_close(state, fmode, GFP_KERNEL, 1);\n}\n\n \nstatic struct nfs4_lock_state *\n__nfs4_find_lock_state(struct nfs4_state *state,\n\t\t       fl_owner_t fl_owner, fl_owner_t fl_owner2)\n{\n\tstruct nfs4_lock_state *pos, *ret = NULL;\n\tlist_for_each_entry(pos, &state->lock_states, ls_locks) {\n\t\tif (pos->ls_owner == fl_owner) {\n\t\t\tret = pos;\n\t\t\tbreak;\n\t\t}\n\t\tif (pos->ls_owner == fl_owner2)\n\t\t\tret = pos;\n\t}\n\tif (ret)\n\t\trefcount_inc(&ret->ls_count);\n\treturn ret;\n}\n\n \nstatic struct nfs4_lock_state *nfs4_alloc_lock_state(struct nfs4_state *state, fl_owner_t fl_owner)\n{\n\tstruct nfs4_lock_state *lsp;\n\tstruct nfs_server *server = state->owner->so_server;\n\n\tlsp = kzalloc(sizeof(*lsp), GFP_KERNEL_ACCOUNT);\n\tif (lsp == NULL)\n\t\treturn NULL;\n\tnfs4_init_seqid_counter(&lsp->ls_seqid);\n\trefcount_set(&lsp->ls_count, 1);\n\tlsp->ls_state = state;\n\tlsp->ls_owner = fl_owner;\n\tlsp->ls_seqid.owner_id = ida_alloc(&server->lockowner_id, GFP_KERNEL_ACCOUNT);\n\tif (lsp->ls_seqid.owner_id < 0)\n\t\tgoto out_free;\n\tINIT_LIST_HEAD(&lsp->ls_locks);\n\treturn lsp;\nout_free:\n\tkfree(lsp);\n\treturn NULL;\n}\n\nvoid nfs4_free_lock_state(struct nfs_server *server, struct nfs4_lock_state *lsp)\n{\n\tida_free(&server->lockowner_id, lsp->ls_seqid.owner_id);\n\tnfs4_destroy_seqid_counter(&lsp->ls_seqid);\n\tkfree(lsp);\n}\n\n \nstatic struct nfs4_lock_state *nfs4_get_lock_state(struct nfs4_state *state, fl_owner_t owner)\n{\n\tstruct nfs4_lock_state *lsp, *new = NULL;\n\t\n\tfor(;;) {\n\t\tspin_lock(&state->state_lock);\n\t\tlsp = __nfs4_find_lock_state(state, owner, NULL);\n\t\tif (lsp != NULL)\n\t\t\tbreak;\n\t\tif (new != NULL) {\n\t\t\tlist_add(&new->ls_locks, &state->lock_states);\n\t\t\tset_bit(LK_STATE_IN_USE, &state->flags);\n\t\t\tlsp = new;\n\t\t\tnew = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&state->state_lock);\n\t\tnew = nfs4_alloc_lock_state(state, owner);\n\t\tif (new == NULL)\n\t\t\treturn NULL;\n\t}\n\tspin_unlock(&state->state_lock);\n\tif (new != NULL)\n\t\tnfs4_free_lock_state(state->owner->so_server, new);\n\treturn lsp;\n}\n\n \nvoid nfs4_put_lock_state(struct nfs4_lock_state *lsp)\n{\n\tstruct nfs_server *server;\n\tstruct nfs4_state *state;\n\n\tif (lsp == NULL)\n\t\treturn;\n\tstate = lsp->ls_state;\n\tif (!refcount_dec_and_lock(&lsp->ls_count, &state->state_lock))\n\t\treturn;\n\tlist_del(&lsp->ls_locks);\n\tif (list_empty(&state->lock_states))\n\t\tclear_bit(LK_STATE_IN_USE, &state->flags);\n\tspin_unlock(&state->state_lock);\n\tserver = state->owner->so_server;\n\tif (test_bit(NFS_LOCK_INITIALIZED, &lsp->ls_flags)) {\n\t\tstruct nfs_client *clp = server->nfs_client;\n\n\t\tclp->cl_mvops->free_lock_state(server, lsp);\n\t} else\n\t\tnfs4_free_lock_state(server, lsp);\n}\n\nstatic void nfs4_fl_copy_lock(struct file_lock *dst, struct file_lock *src)\n{\n\tstruct nfs4_lock_state *lsp = src->fl_u.nfs4_fl.owner;\n\n\tdst->fl_u.nfs4_fl.owner = lsp;\n\trefcount_inc(&lsp->ls_count);\n}\n\nstatic void nfs4_fl_release_lock(struct file_lock *fl)\n{\n\tnfs4_put_lock_state(fl->fl_u.nfs4_fl.owner);\n}\n\nstatic const struct file_lock_operations nfs4_fl_lock_ops = {\n\t.fl_copy_lock = nfs4_fl_copy_lock,\n\t.fl_release_private = nfs4_fl_release_lock,\n};\n\nint nfs4_set_lock_state(struct nfs4_state *state, struct file_lock *fl)\n{\n\tstruct nfs4_lock_state *lsp;\n\n\tif (fl->fl_ops != NULL)\n\t\treturn 0;\n\tlsp = nfs4_get_lock_state(state, fl->fl_owner);\n\tif (lsp == NULL)\n\t\treturn -ENOMEM;\n\tfl->fl_u.nfs4_fl.owner = lsp;\n\tfl->fl_ops = &nfs4_fl_lock_ops;\n\treturn 0;\n}\n\nstatic int nfs4_copy_lock_stateid(nfs4_stateid *dst,\n\t\tstruct nfs4_state *state,\n\t\tconst struct nfs_lock_context *l_ctx)\n{\n\tstruct nfs4_lock_state *lsp;\n\tfl_owner_t fl_owner, fl_flock_owner;\n\tint ret = -ENOENT;\n\n\tif (l_ctx == NULL)\n\t\tgoto out;\n\n\tif (test_bit(LK_STATE_IN_USE, &state->flags) == 0)\n\t\tgoto out;\n\n\tfl_owner = l_ctx->lockowner;\n\tfl_flock_owner = l_ctx->open_context->flock_owner;\n\n\tspin_lock(&state->state_lock);\n\tlsp = __nfs4_find_lock_state(state, fl_owner, fl_flock_owner);\n\tif (lsp && test_bit(NFS_LOCK_LOST, &lsp->ls_flags))\n\t\tret = -EIO;\n\telse if (lsp != NULL && test_bit(NFS_LOCK_INITIALIZED, &lsp->ls_flags) != 0) {\n\t\tnfs4_stateid_copy(dst, &lsp->ls_stateid);\n\t\tret = 0;\n\t}\n\tspin_unlock(&state->state_lock);\n\tnfs4_put_lock_state(lsp);\nout:\n\treturn ret;\n}\n\nbool nfs4_copy_open_stateid(nfs4_stateid *dst, struct nfs4_state *state)\n{\n\tbool ret;\n\tconst nfs4_stateid *src;\n\tint seq;\n\n\tdo {\n\t\tret = false;\n\t\tsrc = &zero_stateid;\n\t\tseq = read_seqbegin(&state->seqlock);\n\t\tif (test_bit(NFS_OPEN_STATE, &state->flags)) {\n\t\t\tsrc = &state->open_stateid;\n\t\t\tret = true;\n\t\t}\n\t\tnfs4_stateid_copy(dst, src);\n\t} while (read_seqretry(&state->seqlock, seq));\n\treturn ret;\n}\n\n \nint nfs4_select_rw_stateid(struct nfs4_state *state,\n\t\tfmode_t fmode, const struct nfs_lock_context *l_ctx,\n\t\tnfs4_stateid *dst, const struct cred **cred)\n{\n\tint ret;\n\n\tif (!nfs4_valid_open_stateid(state))\n\t\treturn -EIO;\n\tif (cred != NULL)\n\t\t*cred = NULL;\n\tret = nfs4_copy_lock_stateid(dst, state, l_ctx);\n\tif (ret == -EIO)\n\t\t \n\t\tgoto out;\n\t \n\tif (nfs4_copy_delegation_stateid(state->inode, fmode, dst, cred)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tif (ret != -ENOENT)\n\t\t \n\t\tgoto out;\n\tret = nfs4_copy_open_stateid(dst, state) ? 0 : -EAGAIN;\nout:\n\tif (nfs_server_capable(state->inode, NFS_CAP_STATEID_NFSV41))\n\t\tdst->seqid = 0;\n\treturn ret;\n}\n\nstruct nfs_seqid *nfs_alloc_seqid(struct nfs_seqid_counter *counter, gfp_t gfp_mask)\n{\n\tstruct nfs_seqid *new;\n\n\tnew = kmalloc(sizeof(*new), gfp_mask);\n\tif (new == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\tnew->sequence = counter;\n\tINIT_LIST_HEAD(&new->list);\n\tnew->task = NULL;\n\treturn new;\n}\n\nvoid nfs_release_seqid(struct nfs_seqid *seqid)\n{\n\tstruct nfs_seqid_counter *sequence;\n\n\tif (seqid == NULL || list_empty(&seqid->list))\n\t\treturn;\n\tsequence = seqid->sequence;\n\tspin_lock(&sequence->lock);\n\tlist_del_init(&seqid->list);\n\tif (!list_empty(&sequence->list)) {\n\t\tstruct nfs_seqid *next;\n\n\t\tnext = list_first_entry(&sequence->list,\n\t\t\t\tstruct nfs_seqid, list);\n\t\trpc_wake_up_queued_task(&sequence->wait, next->task);\n\t}\n\tspin_unlock(&sequence->lock);\n}\n\nvoid nfs_free_seqid(struct nfs_seqid *seqid)\n{\n\tnfs_release_seqid(seqid);\n\tkfree(seqid);\n}\n\n \nstatic void nfs_increment_seqid(int status, struct nfs_seqid *seqid)\n{\n\tswitch (status) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase -NFS4ERR_BAD_SEQID:\n\t\t\tif (seqid->sequence->flags & NFS_SEQID_CONFIRMED)\n\t\t\t\treturn;\n\t\t\tpr_warn_ratelimited(\"NFS: v4 server returned a bad\"\n\t\t\t\t\t\" sequence-id error on an\"\n\t\t\t\t\t\" unconfirmed sequence %p!\\n\",\n\t\t\t\t\tseqid->sequence);\n\t\t\treturn;\n\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\tcase -NFS4ERR_STALE_STATEID:\n\t\tcase -NFS4ERR_BAD_STATEID:\n\t\tcase -NFS4ERR_BADXDR:\n\t\tcase -NFS4ERR_RESOURCE:\n\t\tcase -NFS4ERR_NOFILEHANDLE:\n\t\tcase -NFS4ERR_MOVED:\n\t\t\t \n\t\t\treturn;\n\t}\n\t \n\tseqid->sequence->counter++;\n}\n\nvoid nfs_increment_open_seqid(int status, struct nfs_seqid *seqid)\n{\n\tstruct nfs4_state_owner *sp;\n\n\tif (seqid == NULL)\n\t\treturn;\n\n\tsp = container_of(seqid->sequence, struct nfs4_state_owner, so_seqid);\n\tif (status == -NFS4ERR_BAD_SEQID)\n\t\tnfs4_reset_state_owner(sp);\n\tif (!nfs4_has_session(sp->so_server->nfs_client))\n\t\tnfs_increment_seqid(status, seqid);\n}\n\n \nvoid nfs_increment_lock_seqid(int status, struct nfs_seqid *seqid)\n{\n\tif (seqid != NULL)\n\t\tnfs_increment_seqid(status, seqid);\n}\n\nint nfs_wait_on_sequence(struct nfs_seqid *seqid, struct rpc_task *task)\n{\n\tstruct nfs_seqid_counter *sequence;\n\tint status = 0;\n\n\tif (seqid == NULL)\n\t\tgoto out;\n\tsequence = seqid->sequence;\n\tspin_lock(&sequence->lock);\n\tseqid->task = task;\n\tif (list_empty(&seqid->list))\n\t\tlist_add_tail(&seqid->list, &sequence->list);\n\tif (list_first_entry(&sequence->list, struct nfs_seqid, list) == seqid)\n\t\tgoto unlock;\n\trpc_sleep_on(&sequence->wait, task, NULL);\n\tstatus = -EAGAIN;\nunlock:\n\tspin_unlock(&sequence->lock);\nout:\n\treturn status;\n}\n\nstatic int nfs4_run_state_manager(void *);\n\nstatic void nfs4_clear_state_manager_bit(struct nfs_client *clp)\n{\n\tclear_and_wake_up_bit(NFS4CLNT_MANAGER_RUNNING, &clp->cl_state);\n\trpc_wake_up(&clp->cl_rpcwaitq);\n}\n\n \nvoid nfs4_schedule_state_manager(struct nfs_client *clp)\n{\n\tstruct task_struct *task;\n\tchar buf[INET6_ADDRSTRLEN + sizeof(\"-manager\") + 1];\n\tstruct rpc_clnt *clnt = clp->cl_rpcclient;\n\tbool swapon = false;\n\n\tif (clnt->cl_shutdown)\n\t\treturn;\n\n\tset_bit(NFS4CLNT_RUN_MANAGER, &clp->cl_state);\n\n\tif (atomic_read(&clnt->cl_swapper)) {\n\t\tswapon = !test_and_set_bit(NFS4CLNT_MANAGER_AVAILABLE,\n\t\t\t\t\t   &clp->cl_state);\n\t\tif (!swapon) {\n\t\t\twake_up_var(&clp->cl_state);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (test_and_set_bit(NFS4CLNT_MANAGER_RUNNING, &clp->cl_state) != 0)\n\t\treturn;\n\n\t__module_get(THIS_MODULE);\n\trefcount_inc(&clp->cl_count);\n\n\t \n\trcu_read_lock();\n\tsnprintf(buf, sizeof(buf), \"%s-manager\",\n\t\t\trpc_peeraddr2str(clp->cl_rpcclient, RPC_DISPLAY_ADDR));\n\trcu_read_unlock();\n\ttask = kthread_run(nfs4_run_state_manager, clp, \"%s\", buf);\n\tif (IS_ERR(task)) {\n\t\tprintk(KERN_ERR \"%s: kthread_run: %ld\\n\",\n\t\t\t__func__, PTR_ERR(task));\n\t\tif (!nfs_client_init_is_complete(clp))\n\t\t\tnfs_mark_client_ready(clp, PTR_ERR(task));\n\t\tif (swapon)\n\t\t\tclear_bit(NFS4CLNT_MANAGER_AVAILABLE, &clp->cl_state);\n\t\tnfs4_clear_state_manager_bit(clp);\n\t\tnfs_put_client(clp);\n\t\tmodule_put(THIS_MODULE);\n\t}\n}\n\n \nvoid nfs4_schedule_lease_recovery(struct nfs_client *clp)\n{\n\tif (!clp)\n\t\treturn;\n\tif (!test_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state))\n\t\tset_bit(NFS4CLNT_CHECK_LEASE, &clp->cl_state);\n\tdprintk(\"%s: scheduling lease recovery for server %s\\n\", __func__,\n\t\t\tclp->cl_hostname);\n\tnfs4_schedule_state_manager(clp);\n}\nEXPORT_SYMBOL_GPL(nfs4_schedule_lease_recovery);\n\n \nint nfs4_schedule_migration_recovery(const struct nfs_server *server)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\n\tif (server->fh_expire_type != NFS4_FH_PERSISTENT) {\n\t\tpr_err(\"NFS: volatile file handles not supported (server %s)\\n\",\n\t\t\t\tclp->cl_hostname);\n\t\treturn -NFS4ERR_IO;\n\t}\n\n\tif (test_bit(NFS_MIG_FAILED, &server->mig_status))\n\t\treturn -NFS4ERR_IO;\n\n\tdprintk(\"%s: scheduling migration recovery for (%llx:%llx) on %s\\n\",\n\t\t\t__func__,\n\t\t\t(unsigned long long)server->fsid.major,\n\t\t\t(unsigned long long)server->fsid.minor,\n\t\t\tclp->cl_hostname);\n\n\tset_bit(NFS_MIG_IN_TRANSITION,\n\t\t\t&((struct nfs_server *)server)->mig_status);\n\tset_bit(NFS4CLNT_MOVED, &clp->cl_state);\n\n\tnfs4_schedule_state_manager(clp);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nfs4_schedule_migration_recovery);\n\n \nvoid nfs4_schedule_lease_moved_recovery(struct nfs_client *clp)\n{\n\tdprintk(\"%s: scheduling lease-moved recovery for client ID %llx on %s\\n\",\n\t\t__func__, clp->cl_clientid, clp->cl_hostname);\n\n\tset_bit(NFS4CLNT_LEASE_MOVED, &clp->cl_state);\n\tnfs4_schedule_state_manager(clp);\n}\nEXPORT_SYMBOL_GPL(nfs4_schedule_lease_moved_recovery);\n\nint nfs4_wait_clnt_recover(struct nfs_client *clp)\n{\n\tint res;\n\n\tmight_sleep();\n\n\trefcount_inc(&clp->cl_count);\n\tres = wait_on_bit_action(&clp->cl_state, NFS4CLNT_MANAGER_RUNNING,\n\t\t\t\t nfs_wait_bit_killable,\n\t\t\t\t TASK_KILLABLE|TASK_FREEZABLE_UNSAFE);\n\tif (res)\n\t\tgoto out;\n\tif (clp->cl_cons_state < 0)\n\t\tres = clp->cl_cons_state;\nout:\n\tnfs_put_client(clp);\n\treturn res;\n}\n\nint nfs4_client_recover_expired_lease(struct nfs_client *clp)\n{\n\tunsigned int loop;\n\tint ret;\n\n\tfor (loop = NFS4_MAX_LOOP_ON_RECOVER; loop != 0; loop--) {\n\t\tret = nfs4_wait_clnt_recover(clp);\n\t\tif (ret != 0)\n\t\t\tbreak;\n\t\tif (!test_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state) &&\n\t\t    !test_bit(NFS4CLNT_CHECK_LEASE,&clp->cl_state))\n\t\t\tbreak;\n\t\tnfs4_schedule_state_manager(clp);\n\t\tret = -EIO;\n\t}\n\treturn ret;\n}\n\n \nstatic void nfs40_handle_cb_pathdown(struct nfs_client *clp)\n{\n\tset_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);\n\tnfs_expire_all_delegations(clp);\n\tdprintk(\"%s: handling CB_PATHDOWN recovery for server %s\\n\", __func__,\n\t\t\tclp->cl_hostname);\n}\n\nvoid nfs4_schedule_path_down_recovery(struct nfs_client *clp)\n{\n\tnfs40_handle_cb_pathdown(clp);\n\tnfs4_schedule_state_manager(clp);\n}\n\nstatic int nfs4_state_mark_reclaim_reboot(struct nfs_client *clp, struct nfs4_state *state)\n{\n\n\tif (!nfs4_valid_open_stateid(state))\n\t\treturn 0;\n\tset_bit(NFS_STATE_RECLAIM_REBOOT, &state->flags);\n\t \n\tif (test_bit(NFS_STATE_RECLAIM_NOGRACE, &state->flags)) {\n\t\tclear_bit(NFS_STATE_RECLAIM_REBOOT, &state->flags);\n\t\treturn 0;\n\t}\n\tset_bit(NFS_OWNER_RECLAIM_REBOOT, &state->owner->so_flags);\n\tset_bit(NFS4CLNT_RECLAIM_REBOOT, &clp->cl_state);\n\treturn 1;\n}\n\nint nfs4_state_mark_reclaim_nograce(struct nfs_client *clp, struct nfs4_state *state)\n{\n\tif (!nfs4_valid_open_stateid(state))\n\t\treturn 0;\n\tset_bit(NFS_STATE_RECLAIM_NOGRACE, &state->flags);\n\tclear_bit(NFS_STATE_RECLAIM_REBOOT, &state->flags);\n\tset_bit(NFS_OWNER_RECLAIM_NOGRACE, &state->owner->so_flags);\n\tset_bit(NFS4CLNT_RECLAIM_NOGRACE, &clp->cl_state);\n\treturn 1;\n}\n\nint nfs4_schedule_stateid_recovery(const struct nfs_server *server, struct nfs4_state *state)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\n\tif (!nfs4_state_mark_reclaim_nograce(clp, state))\n\t\treturn -EBADF;\n\tnfs_inode_find_delegation_state_and_recover(state->inode,\n\t\t\t&state->stateid);\n\tdprintk(\"%s: scheduling stateid recovery for server %s\\n\", __func__,\n\t\t\tclp->cl_hostname);\n\tnfs4_schedule_state_manager(clp);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nfs4_schedule_stateid_recovery);\n\nstatic struct nfs4_lock_state *\nnfs_state_find_lock_state_by_stateid(struct nfs4_state *state,\n\t\tconst nfs4_stateid *stateid)\n{\n\tstruct nfs4_lock_state *pos;\n\n\tlist_for_each_entry(pos, &state->lock_states, ls_locks) {\n\t\tif (!test_bit(NFS_LOCK_INITIALIZED, &pos->ls_flags))\n\t\t\tcontinue;\n\t\tif (nfs4_stateid_match_or_older(&pos->ls_stateid, stateid))\n\t\t\treturn pos;\n\t}\n\treturn NULL;\n}\n\nstatic bool nfs_state_lock_state_matches_stateid(struct nfs4_state *state,\n\t\tconst nfs4_stateid *stateid)\n{\n\tbool found = false;\n\n\tif (test_bit(LK_STATE_IN_USE, &state->flags)) {\n\t\tspin_lock(&state->state_lock);\n\t\tif (nfs_state_find_lock_state_by_stateid(state, stateid))\n\t\t\tfound = true;\n\t\tspin_unlock(&state->state_lock);\n\t}\n\treturn found;\n}\n\nvoid nfs_inode_find_state_and_recover(struct inode *inode,\n\t\tconst nfs4_stateid *stateid)\n{\n\tstruct nfs_client *clp = NFS_SERVER(inode)->nfs_client;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs_open_context *ctx;\n\tstruct nfs4_state *state;\n\tbool found = false;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(ctx, &nfsi->open_files, list) {\n\t\tstate = ctx->state;\n\t\tif (state == NULL)\n\t\t\tcontinue;\n\t\tif (nfs4_stateid_match_or_older(&state->stateid, stateid) &&\n\t\t    nfs4_state_mark_reclaim_nograce(clp, state)) {\n\t\t\tfound = true;\n\t\t\tcontinue;\n\t\t}\n\t\tif (test_bit(NFS_OPEN_STATE, &state->flags) &&\n\t\t    nfs4_stateid_match_or_older(&state->open_stateid, stateid) &&\n\t\t    nfs4_state_mark_reclaim_nograce(clp, state)) {\n\t\t\tfound = true;\n\t\t\tcontinue;\n\t\t}\n\t\tif (nfs_state_lock_state_matches_stateid(state, stateid) &&\n\t\t    nfs4_state_mark_reclaim_nograce(clp, state))\n\t\t\tfound = true;\n\t}\n\trcu_read_unlock();\n\n\tnfs_inode_find_delegation_state_and_recover(inode, stateid);\n\tif (found)\n\t\tnfs4_schedule_state_manager(clp);\n}\n\nstatic void nfs4_state_mark_open_context_bad(struct nfs4_state *state, int err)\n{\n\tstruct inode *inode = state->inode;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs_open_context *ctx;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(ctx, &nfsi->open_files, list) {\n\t\tif (ctx->state != state)\n\t\t\tcontinue;\n\t\tset_bit(NFS_CONTEXT_BAD, &ctx->flags);\n\t\tpr_warn(\"NFSv4: state recovery failed for open file %pd2, \"\n\t\t\t\t\"error = %d\\n\", ctx->dentry, err);\n\t}\n\trcu_read_unlock();\n}\n\nstatic void nfs4_state_mark_recovery_failed(struct nfs4_state *state, int error)\n{\n\tset_bit(NFS_STATE_RECOVERY_FAILED, &state->flags);\n\tnfs4_state_mark_open_context_bad(state, error);\n}\n\n\nstatic int nfs4_reclaim_locks(struct nfs4_state *state, const struct nfs4_state_recovery_ops *ops)\n{\n\tstruct inode *inode = state->inode;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct file_lock *fl;\n\tstruct nfs4_lock_state *lsp;\n\tint status = 0;\n\tstruct file_lock_context *flctx = locks_inode_context(inode);\n\tstruct list_head *list;\n\n\tif (flctx == NULL)\n\t\treturn 0;\n\n\tlist = &flctx->flc_posix;\n\n\t \n\tdown_write(&nfsi->rwsem);\n\tspin_lock(&flctx->flc_lock);\nrestart:\n\tlist_for_each_entry(fl, list, fl_list) {\n\t\tif (nfs_file_open_context(fl->fl_file)->state != state)\n\t\t\tcontinue;\n\t\tspin_unlock(&flctx->flc_lock);\n\t\tstatus = ops->recover_lock(state, fl);\n\t\tswitch (status) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase -ETIMEDOUT:\n\t\tcase -ESTALE:\n\t\tcase -NFS4ERR_ADMIN_REVOKED:\n\t\tcase -NFS4ERR_STALE_STATEID:\n\t\tcase -NFS4ERR_BAD_STATEID:\n\t\tcase -NFS4ERR_EXPIRED:\n\t\tcase -NFS4ERR_NO_GRACE:\n\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\tcase -NFS4ERR_BADSESSION:\n\t\tcase -NFS4ERR_BADSLOT:\n\t\tcase -NFS4ERR_BAD_HIGH_SLOT:\n\t\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\tpr_err(\"NFS: %s: unhandled error %d\\n\",\n\t\t\t\t\t__func__, status);\n\t\t\tfallthrough;\n\t\tcase -ENOMEM:\n\t\tcase -NFS4ERR_DENIED:\n\t\tcase -NFS4ERR_RECLAIM_BAD:\n\t\tcase -NFS4ERR_RECLAIM_CONFLICT:\n\t\t\tlsp = fl->fl_u.nfs4_fl.owner;\n\t\t\tif (lsp)\n\t\t\t\tset_bit(NFS_LOCK_LOST, &lsp->ls_flags);\n\t\t\tstatus = 0;\n\t\t}\n\t\tspin_lock(&flctx->flc_lock);\n\t}\n\tif (list == &flctx->flc_posix) {\n\t\tlist = &flctx->flc_flock;\n\t\tgoto restart;\n\t}\n\tspin_unlock(&flctx->flc_lock);\nout:\n\tup_write(&nfsi->rwsem);\n\treturn status;\n}\n\n#ifdef CONFIG_NFS_V4_2\nstatic void nfs42_complete_copies(struct nfs4_state_owner *sp, struct nfs4_state *state)\n{\n\tstruct nfs4_copy_state *copy;\n\n\tif (!test_bit(NFS_CLNT_DST_SSC_COPY_STATE, &state->flags) &&\n\t\t!test_bit(NFS_CLNT_SRC_SSC_COPY_STATE, &state->flags))\n\t\treturn;\n\n\tspin_lock(&sp->so_server->nfs_client->cl_lock);\n\tlist_for_each_entry(copy, &sp->so_server->ss_copies, copies) {\n\t\tif ((test_bit(NFS_CLNT_DST_SSC_COPY_STATE, &state->flags) &&\n\t\t\t\t!nfs4_stateid_match_other(&state->stateid,\n\t\t\t\t&copy->parent_dst_state->stateid)))\n\t\t\t\tcontinue;\n\t\tcopy->flags = 1;\n\t\tif (test_and_clear_bit(NFS_CLNT_DST_SSC_COPY_STATE,\n\t\t\t\t&state->flags)) {\n\t\t\tclear_bit(NFS_CLNT_SRC_SSC_COPY_STATE, &state->flags);\n\t\t\tcomplete(&copy->completion);\n\t\t}\n\t}\n\tlist_for_each_entry(copy, &sp->so_server->ss_copies, src_copies) {\n\t\tif ((test_bit(NFS_CLNT_SRC_SSC_COPY_STATE, &state->flags) &&\n\t\t\t\t!nfs4_stateid_match_other(&state->stateid,\n\t\t\t\t&copy->parent_src_state->stateid)))\n\t\t\t\tcontinue;\n\t\tcopy->flags = 1;\n\t\tif (test_and_clear_bit(NFS_CLNT_DST_SSC_COPY_STATE,\n\t\t\t\t&state->flags))\n\t\t\tcomplete(&copy->completion);\n\t}\n\tspin_unlock(&sp->so_server->nfs_client->cl_lock);\n}\n#else  \nstatic inline void nfs42_complete_copies(struct nfs4_state_owner *sp,\n\t\t\t\t\t struct nfs4_state *state)\n{\n}\n#endif  \n\nstatic int __nfs4_reclaim_open_state(struct nfs4_state_owner *sp, struct nfs4_state *state,\n\t\t\t\t     const struct nfs4_state_recovery_ops *ops,\n\t\t\t\t     int *lost_locks)\n{\n\tstruct nfs4_lock_state *lock;\n\tint status;\n\n\tstatus = ops->recover_open(sp, state);\n\tif (status < 0)\n\t\treturn status;\n\n\tstatus = nfs4_reclaim_locks(state, ops);\n\tif (status < 0)\n\t\treturn status;\n\n\tif (!test_bit(NFS_DELEGATED_STATE, &state->flags)) {\n\t\tspin_lock(&state->state_lock);\n\t\tlist_for_each_entry(lock, &state->lock_states, ls_locks) {\n\t\t\ttrace_nfs4_state_lock_reclaim(state, lock);\n\t\t\tif (!test_bit(NFS_LOCK_INITIALIZED, &lock->ls_flags) &&\n\t\t\t    !test_bit(NFS_LOCK_UNLOCKING, &lock->ls_flags))\n\t\t\t\t*lost_locks += 1;\n\t\t}\n\t\tspin_unlock(&state->state_lock);\n\t}\n\n\tnfs42_complete_copies(sp, state);\n\tclear_bit(NFS_STATE_RECLAIM_NOGRACE, &state->flags);\n\treturn status;\n}\n\nstatic int nfs4_reclaim_open_state(struct nfs4_state_owner *sp,\n\t\t\t\t   const struct nfs4_state_recovery_ops *ops,\n\t\t\t\t   int *lost_locks)\n{\n\tstruct nfs4_state *state;\n\tunsigned int loop = 0;\n\tint status = 0;\n#ifdef CONFIG_NFS_V4_2\n\tbool found_ssc_copy_state = false;\n#endif  \n\n\t \n\tspin_lock(&sp->so_lock);\n\traw_write_seqcount_begin(&sp->so_reclaim_seqcount);\nrestart:\n\tlist_for_each_entry(state, &sp->so_states, open_states) {\n\t\tif (!test_and_clear_bit(ops->state_flag_bit, &state->flags))\n\t\t\tcontinue;\n\t\tif (!nfs4_valid_open_stateid(state))\n\t\t\tcontinue;\n\t\tif (state->state == 0)\n\t\t\tcontinue;\n#ifdef CONFIG_NFS_V4_2\n\t\tif (test_bit(NFS_SRV_SSC_COPY_STATE, &state->flags)) {\n\t\t\tnfs4_state_mark_recovery_failed(state, -EIO);\n\t\t\tfound_ssc_copy_state = true;\n\t\t\tcontinue;\n\t\t}\n#endif  \n\t\trefcount_inc(&state->count);\n\t\tspin_unlock(&sp->so_lock);\n\t\tstatus = __nfs4_reclaim_open_state(sp, state, ops, lost_locks);\n\n\t\tswitch (status) {\n\t\tdefault:\n\t\t\tif (status >= 0) {\n\t\t\t\tloop = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tprintk(KERN_ERR \"NFS: %s: unhandled error %d\\n\", __func__, status);\n\t\t\tfallthrough;\n\t\tcase -ENOENT:\n\t\tcase -ENOMEM:\n\t\tcase -EACCES:\n\t\tcase -EROFS:\n\t\tcase -EIO:\n\t\tcase -ESTALE:\n\t\t\t \n\t\t\tnfs4_state_mark_recovery_failed(state, status);\n\t\t\tbreak;\n\t\tcase -EAGAIN:\n\t\t\tssleep(1);\n\t\t\tif (loop++ < 10) {\n\t\t\t\tset_bit(ops->state_flag_bit, &state->flags);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\n\t\tcase -NFS4ERR_ADMIN_REVOKED:\n\t\tcase -NFS4ERR_STALE_STATEID:\n\t\tcase -NFS4ERR_OLD_STATEID:\n\t\tcase -NFS4ERR_BAD_STATEID:\n\t\tcase -NFS4ERR_RECLAIM_BAD:\n\t\tcase -NFS4ERR_RECLAIM_CONFLICT:\n\t\t\tnfs4_state_mark_reclaim_nograce(sp->so_server->nfs_client, state);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_EXPIRED:\n\t\tcase -NFS4ERR_NO_GRACE:\n\t\t\tnfs4_state_mark_reclaim_nograce(sp->so_server->nfs_client, state);\n\t\t\tfallthrough;\n\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\tcase -NFS4ERR_BADSESSION:\n\t\tcase -NFS4ERR_BADSLOT:\n\t\tcase -NFS4ERR_BAD_HIGH_SLOT:\n\t\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\t\tcase -ETIMEDOUT:\n\t\t\tgoto out_err;\n\t\t}\n\t\tnfs4_put_open_state(state);\n\t\tspin_lock(&sp->so_lock);\n\t\tgoto restart;\n\t}\n\traw_write_seqcount_end(&sp->so_reclaim_seqcount);\n\tspin_unlock(&sp->so_lock);\n#ifdef CONFIG_NFS_V4_2\n\tif (found_ssc_copy_state)\n\t\treturn -EIO;\n#endif  \n\treturn 0;\nout_err:\n\tnfs4_put_open_state(state);\n\tspin_lock(&sp->so_lock);\n\traw_write_seqcount_end(&sp->so_reclaim_seqcount);\n\tspin_unlock(&sp->so_lock);\n\treturn status;\n}\n\nstatic void nfs4_clear_open_state(struct nfs4_state *state)\n{\n\tstruct nfs4_lock_state *lock;\n\n\tclear_bit(NFS_DELEGATED_STATE, &state->flags);\n\tclear_bit(NFS_O_RDONLY_STATE, &state->flags);\n\tclear_bit(NFS_O_WRONLY_STATE, &state->flags);\n\tclear_bit(NFS_O_RDWR_STATE, &state->flags);\n\tspin_lock(&state->state_lock);\n\tlist_for_each_entry(lock, &state->lock_states, ls_locks) {\n\t\tlock->ls_seqid.flags = 0;\n\t\tclear_bit(NFS_LOCK_INITIALIZED, &lock->ls_flags);\n\t}\n\tspin_unlock(&state->state_lock);\n}\n\nstatic void nfs4_reset_seqids(struct nfs_server *server,\n\tint (*mark_reclaim)(struct nfs_client *clp, struct nfs4_state *state))\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct nfs4_state_owner *sp;\n\tstruct rb_node *pos;\n\tstruct nfs4_state *state;\n\n\tspin_lock(&clp->cl_lock);\n\tfor (pos = rb_first(&server->state_owners);\n\t     pos != NULL;\n\t     pos = rb_next(pos)) {\n\t\tsp = rb_entry(pos, struct nfs4_state_owner, so_server_node);\n\t\tsp->so_seqid.flags = 0;\n\t\tspin_lock(&sp->so_lock);\n\t\tlist_for_each_entry(state, &sp->so_states, open_states) {\n\t\t\tif (mark_reclaim(clp, state))\n\t\t\t\tnfs4_clear_open_state(state);\n\t\t}\n\t\tspin_unlock(&sp->so_lock);\n\t}\n\tspin_unlock(&clp->cl_lock);\n}\n\nstatic void nfs4_state_mark_reclaim_helper(struct nfs_client *clp,\n\tint (*mark_reclaim)(struct nfs_client *clp, struct nfs4_state *state))\n{\n\tstruct nfs_server *server;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link)\n\t\tnfs4_reset_seqids(server, mark_reclaim);\n\trcu_read_unlock();\n}\n\nstatic void nfs4_state_start_reclaim_reboot(struct nfs_client *clp)\n{\n\tset_bit(NFS4CLNT_RECLAIM_REBOOT, &clp->cl_state);\n\t \n\tnfs_delegation_mark_reclaim(clp);\n\tnfs4_state_mark_reclaim_helper(clp, nfs4_state_mark_reclaim_reboot);\n}\n\nstatic int nfs4_reclaim_complete(struct nfs_client *clp,\n\t\t\t\t const struct nfs4_state_recovery_ops *ops,\n\t\t\t\t const struct cred *cred)\n{\n\t \n\tif (ops->reclaim_complete)\n\t\treturn ops->reclaim_complete(clp, cred);\n\treturn 0;\n}\n\nstatic void nfs4_clear_reclaim_server(struct nfs_server *server)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct nfs4_state_owner *sp;\n\tstruct rb_node *pos;\n\tstruct nfs4_state *state;\n\n\tspin_lock(&clp->cl_lock);\n\tfor (pos = rb_first(&server->state_owners);\n\t     pos != NULL;\n\t     pos = rb_next(pos)) {\n\t\tsp = rb_entry(pos, struct nfs4_state_owner, so_server_node);\n\t\tspin_lock(&sp->so_lock);\n\t\tlist_for_each_entry(state, &sp->so_states, open_states) {\n\t\t\tif (!test_and_clear_bit(NFS_STATE_RECLAIM_REBOOT,\n\t\t\t\t\t\t&state->flags))\n\t\t\t\tcontinue;\n\t\t\tnfs4_state_mark_reclaim_nograce(clp, state);\n\t\t}\n\t\tspin_unlock(&sp->so_lock);\n\t}\n\tspin_unlock(&clp->cl_lock);\n}\n\nstatic int nfs4_state_clear_reclaim_reboot(struct nfs_client *clp)\n{\n\tstruct nfs_server *server;\n\n\tif (!test_and_clear_bit(NFS4CLNT_RECLAIM_REBOOT, &clp->cl_state))\n\t\treturn 0;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link)\n\t\tnfs4_clear_reclaim_server(server);\n\trcu_read_unlock();\n\n\tnfs_delegation_reap_unclaimed(clp);\n\treturn 1;\n}\n\nstatic void nfs4_state_end_reclaim_reboot(struct nfs_client *clp)\n{\n\tconst struct nfs4_state_recovery_ops *ops;\n\tconst struct cred *cred;\n\tint err;\n\n\tif (!nfs4_state_clear_reclaim_reboot(clp))\n\t\treturn;\n\tops = clp->cl_mvops->reboot_recovery_ops;\n\tcred = nfs4_get_clid_cred(clp);\n\terr = nfs4_reclaim_complete(clp, ops, cred);\n\tput_cred(cred);\n\tif (err == -NFS4ERR_CONN_NOT_BOUND_TO_SESSION)\n\t\tset_bit(NFS4CLNT_RECLAIM_REBOOT, &clp->cl_state);\n}\n\nstatic void nfs4_state_start_reclaim_nograce(struct nfs_client *clp)\n{\n\tnfs_mark_test_expired_all_delegations(clp);\n\tnfs4_state_mark_reclaim_helper(clp, nfs4_state_mark_reclaim_nograce);\n}\n\nstatic int nfs4_recovery_handle_error(struct nfs_client *clp, int error)\n{\n\tswitch (error) {\n\tcase 0:\n\t\tbreak;\n\tcase -NFS4ERR_CB_PATH_DOWN:\n\t\tnfs40_handle_cb_pathdown(clp);\n\t\tbreak;\n\tcase -NFS4ERR_NO_GRACE:\n\t\tnfs4_state_end_reclaim_reboot(clp);\n\t\tbreak;\n\tcase -NFS4ERR_STALE_CLIENTID:\n\t\tset_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);\n\t\tnfs4_state_start_reclaim_reboot(clp);\n\t\tbreak;\n\tcase -NFS4ERR_EXPIRED:\n\t\tset_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);\n\t\tnfs4_state_start_reclaim_nograce(clp);\n\t\tbreak;\n\tcase -NFS4ERR_BADSESSION:\n\tcase -NFS4ERR_BADSLOT:\n\tcase -NFS4ERR_BAD_HIGH_SLOT:\n\tcase -NFS4ERR_DEADSESSION:\n\tcase -NFS4ERR_SEQ_FALSE_RETRY:\n\tcase -NFS4ERR_SEQ_MISORDERED:\n\t\tset_bit(NFS4CLNT_SESSION_RESET, &clp->cl_state);\n\t\t \n\t\tbreak;\n\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\t\tset_bit(NFS4CLNT_BIND_CONN_TO_SESSION, &clp->cl_state);\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"%s: failed to handle error %d for server %s\\n\",\n\t\t\t\t__func__, error, clp->cl_hostname);\n\t\treturn error;\n\t}\n\tdprintk(\"%s: handled error %d for server %s\\n\", __func__, error,\n\t\t\tclp->cl_hostname);\n\treturn 0;\n}\n\nstatic int nfs4_do_reclaim(struct nfs_client *clp, const struct nfs4_state_recovery_ops *ops)\n{\n\tstruct nfs4_state_owner *sp;\n\tstruct nfs_server *server;\n\tstruct rb_node *pos;\n\tLIST_HEAD(freeme);\n\tint status = 0;\n\tint lost_locks = 0;\n\nrestart:\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link) {\n\t\tnfs4_purge_state_owners(server, &freeme);\n\t\tspin_lock(&clp->cl_lock);\n\t\tfor (pos = rb_first(&server->state_owners);\n\t\t     pos != NULL;\n\t\t     pos = rb_next(pos)) {\n\t\t\tsp = rb_entry(pos,\n\t\t\t\tstruct nfs4_state_owner, so_server_node);\n\t\t\tif (!test_and_clear_bit(ops->owner_flag_bit,\n\t\t\t\t\t\t\t&sp->so_flags))\n\t\t\t\tcontinue;\n\t\t\tif (!atomic_inc_not_zero(&sp->so_count))\n\t\t\t\tcontinue;\n\t\t\tspin_unlock(&clp->cl_lock);\n\t\t\trcu_read_unlock();\n\n\t\t\tstatus = nfs4_reclaim_open_state(sp, ops, &lost_locks);\n\t\t\tif (status < 0) {\n\t\t\t\tif (lost_locks)\n\t\t\t\t\tpr_warn(\"NFS: %s: lost %d locks\\n\",\n\t\t\t\t\t\tclp->cl_hostname, lost_locks);\n\t\t\t\tset_bit(ops->owner_flag_bit, &sp->so_flags);\n\t\t\t\tnfs4_put_state_owner(sp);\n\t\t\t\tstatus = nfs4_recovery_handle_error(clp, status);\n\t\t\t\treturn (status != 0) ? status : -EAGAIN;\n\t\t\t}\n\n\t\t\tnfs4_put_state_owner(sp);\n\t\t\tgoto restart;\n\t\t}\n\t\tspin_unlock(&clp->cl_lock);\n\t}\n\trcu_read_unlock();\n\tnfs4_free_state_owners(&freeme);\n\tif (lost_locks)\n\t\tpr_warn(\"NFS: %s: lost %d locks\\n\",\n\t\t\tclp->cl_hostname, lost_locks);\n\treturn 0;\n}\n\nstatic int nfs4_check_lease(struct nfs_client *clp)\n{\n\tconst struct cred *cred;\n\tconst struct nfs4_state_maintenance_ops *ops =\n\t\tclp->cl_mvops->state_renewal_ops;\n\tint status;\n\n\t \n\tif (test_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state))\n\t\treturn 0;\n\tcred = ops->get_state_renewal_cred(clp);\n\tif (cred == NULL) {\n\t\tcred = nfs4_get_clid_cred(clp);\n\t\tstatus = -ENOKEY;\n\t\tif (cred == NULL)\n\t\t\tgoto out;\n\t}\n\tstatus = ops->renew_lease(clp, cred);\n\tput_cred(cred);\n\tif (status == -ETIMEDOUT) {\n\t\tset_bit(NFS4CLNT_CHECK_LEASE, &clp->cl_state);\n\t\treturn 0;\n\t}\nout:\n\treturn nfs4_recovery_handle_error(clp, status);\n}\n\n \nstatic int nfs4_handle_reclaim_lease_error(struct nfs_client *clp, int status)\n{\n\tswitch (status) {\n\tcase -NFS4ERR_SEQ_MISORDERED:\n\t\tif (test_and_set_bit(NFS4CLNT_PURGE_STATE, &clp->cl_state))\n\t\t\treturn -ESERVERFAULT;\n\t\t \n\t\tssleep(1);\n\t\tclear_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state);\n\t\tbreak;\n\tcase -NFS4ERR_STALE_CLIENTID:\n\t\tclear_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state);\n\t\tnfs4_state_start_reclaim_reboot(clp);\n\t\tbreak;\n\tcase -NFS4ERR_CLID_INUSE:\n\t\tpr_err(\"NFS: Server %s reports our clientid is in use\\n\",\n\t\t\tclp->cl_hostname);\n\t\tnfs_mark_client_ready(clp, -EPERM);\n\t\tclear_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state);\n\t\treturn -EPERM;\n\tcase -EACCES:\n\tcase -NFS4ERR_DELAY:\n\tcase -EAGAIN:\n\t\tssleep(1);\n\t\tbreak;\n\n\tcase -NFS4ERR_MINOR_VERS_MISMATCH:\n\t\tif (clp->cl_cons_state == NFS_CS_SESSION_INITING)\n\t\t\tnfs_mark_client_ready(clp, -EPROTONOSUPPORT);\n\t\tdprintk(\"%s: exit with error %d for server %s\\n\",\n\t\t\t\t__func__, -EPROTONOSUPPORT, clp->cl_hostname);\n\t\treturn -EPROTONOSUPPORT;\n\tcase -ENOSPC:\n\t\tif (clp->cl_cons_state == NFS_CS_SESSION_INITING)\n\t\t\tnfs_mark_client_ready(clp, -EIO);\n\t\treturn -EIO;\n\tcase -NFS4ERR_NOT_SAME:  \n\tdefault:\n\t\tdprintk(\"%s: exit with error %d for server %s\\n\", __func__,\n\t\t\t\tstatus, clp->cl_hostname);\n\t\treturn status;\n\t}\n\tset_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);\n\tdprintk(\"%s: handled error %d for server %s\\n\", __func__, status,\n\t\t\tclp->cl_hostname);\n\treturn 0;\n}\n\nstatic int nfs4_establish_lease(struct nfs_client *clp)\n{\n\tconst struct cred *cred;\n\tconst struct nfs4_state_recovery_ops *ops =\n\t\tclp->cl_mvops->reboot_recovery_ops;\n\tint status;\n\n\tstatus = nfs4_begin_drain_session(clp);\n\tif (status != 0)\n\t\treturn status;\n\tcred = nfs4_get_clid_cred(clp);\n\tif (cred == NULL)\n\t\treturn -ENOENT;\n\tstatus = ops->establish_clid(clp, cred);\n\tput_cred(cred);\n\tif (status != 0)\n\t\treturn status;\n\tpnfs_destroy_all_layouts(clp);\n\treturn 0;\n}\n\n \nstatic int nfs4_reclaim_lease(struct nfs_client *clp)\n{\n\tint status;\n\n\tstatus = nfs4_establish_lease(clp);\n\tif (status < 0)\n\t\treturn nfs4_handle_reclaim_lease_error(clp, status);\n\tif (test_and_clear_bit(NFS4CLNT_SERVER_SCOPE_MISMATCH, &clp->cl_state))\n\t\tnfs4_state_start_reclaim_nograce(clp);\n\tif (!test_bit(NFS4CLNT_RECLAIM_NOGRACE, &clp->cl_state))\n\t\tset_bit(NFS4CLNT_RECLAIM_REBOOT, &clp->cl_state);\n\tclear_bit(NFS4CLNT_CHECK_LEASE, &clp->cl_state);\n\tclear_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);\n\treturn 0;\n}\n\nstatic int nfs4_purge_lease(struct nfs_client *clp)\n{\n\tint status;\n\n\tstatus = nfs4_establish_lease(clp);\n\tif (status < 0)\n\t\treturn nfs4_handle_reclaim_lease_error(clp, status);\n\tclear_bit(NFS4CLNT_PURGE_STATE, &clp->cl_state);\n\tset_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);\n\tnfs4_state_start_reclaim_nograce(clp);\n\treturn 0;\n}\n\n \nstatic int nfs4_try_migration(struct nfs_server *server, const struct cred *cred)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct nfs4_fs_locations *locations = NULL;\n\tstruct inode *inode;\n\tstruct page *page;\n\tint status, result;\n\n\tdprintk(\"--> %s: FSID %llx:%llx on \\\"%s\\\"\\n\", __func__,\n\t\t\t(unsigned long long)server->fsid.major,\n\t\t\t(unsigned long long)server->fsid.minor,\n\t\t\tclp->cl_hostname);\n\n\tresult = 0;\n\tpage = alloc_page(GFP_KERNEL);\n\tlocations = kmalloc(sizeof(struct nfs4_fs_locations), GFP_KERNEL);\n\tif (page == NULL || locations == NULL) {\n\t\tdprintk(\"<-- %s: no memory\\n\", __func__);\n\t\tgoto out;\n\t}\n\tlocations->fattr = nfs_alloc_fattr();\n\tif (locations->fattr == NULL) {\n\t\tdprintk(\"<-- %s: no memory\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tinode = d_inode(server->super->s_root);\n\tresult = nfs4_proc_get_locations(server, NFS_FH(inode), locations,\n\t\t\t\t\t page, cred);\n\tif (result) {\n\t\tdprintk(\"<-- %s: failed to retrieve fs_locations: %d\\n\",\n\t\t\t__func__, result);\n\t\tgoto out;\n\t}\n\n\tresult = -NFS4ERR_NXIO;\n\tif (!locations->nlocations)\n\t\tgoto out;\n\n\tif (!(locations->fattr->valid & NFS_ATTR_FATTR_V4_LOCATIONS)) {\n\t\tdprintk(\"<-- %s: No fs_locations data, migration skipped\\n\",\n\t\t\t__func__);\n\t\tgoto out;\n\t}\n\n\tstatus = nfs4_begin_drain_session(clp);\n\tif (status != 0) {\n\t\tresult = status;\n\t\tgoto out;\n\t}\n\n\tstatus = nfs4_replace_transport(server, locations);\n\tif (status != 0) {\n\t\tdprintk(\"<-- %s: failed to replace transport: %d\\n\",\n\t\t\t__func__, status);\n\t\tgoto out;\n\t}\n\n\tresult = 0;\n\tdprintk(\"<-- %s: migration succeeded\\n\", __func__);\n\nout:\n\tif (page != NULL)\n\t\t__free_page(page);\n\tif (locations != NULL)\n\t\tkfree(locations->fattr);\n\tkfree(locations);\n\tif (result) {\n\t\tpr_err(\"NFS: migration recovery failed (server %s)\\n\",\n\t\t\t\tclp->cl_hostname);\n\t\tset_bit(NFS_MIG_FAILED, &server->mig_status);\n\t}\n\treturn result;\n}\n\n \nstatic int nfs4_handle_migration(struct nfs_client *clp)\n{\n\tconst struct nfs4_state_maintenance_ops *ops =\n\t\t\t\tclp->cl_mvops->state_renewal_ops;\n\tstruct nfs_server *server;\n\tconst struct cred *cred;\n\n\tdprintk(\"%s: migration reported on \\\"%s\\\"\\n\", __func__,\n\t\t\tclp->cl_hostname);\n\n\tcred = ops->get_state_renewal_cred(clp);\n\tif (cred == NULL)\n\t\treturn -NFS4ERR_NOENT;\n\n\tclp->cl_mig_gen++;\nrestart:\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link) {\n\t\tint status;\n\n\t\tif (server->mig_gen == clp->cl_mig_gen)\n\t\t\tcontinue;\n\t\tserver->mig_gen = clp->cl_mig_gen;\n\n\t\tif (!test_and_clear_bit(NFS_MIG_IN_TRANSITION,\n\t\t\t\t\t\t&server->mig_status))\n\t\t\tcontinue;\n\n\t\trcu_read_unlock();\n\t\tstatus = nfs4_try_migration(server, cred);\n\t\tif (status < 0) {\n\t\t\tput_cred(cred);\n\t\t\treturn status;\n\t\t}\n\t\tgoto restart;\n\t}\n\trcu_read_unlock();\n\tput_cred(cred);\n\treturn 0;\n}\n\n \nstatic int nfs4_handle_lease_moved(struct nfs_client *clp)\n{\n\tconst struct nfs4_state_maintenance_ops *ops =\n\t\t\t\tclp->cl_mvops->state_renewal_ops;\n\tstruct nfs_server *server;\n\tconst struct cred *cred;\n\n\tdprintk(\"%s: lease moved reported on \\\"%s\\\"\\n\", __func__,\n\t\t\tclp->cl_hostname);\n\n\tcred = ops->get_state_renewal_cred(clp);\n\tif (cred == NULL)\n\t\treturn -NFS4ERR_NOENT;\n\n\tclp->cl_mig_gen++;\nrestart:\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link) {\n\t\tstruct inode *inode;\n\t\tint status;\n\n\t\tif (server->mig_gen == clp->cl_mig_gen)\n\t\t\tcontinue;\n\t\tserver->mig_gen = clp->cl_mig_gen;\n\n\t\trcu_read_unlock();\n\n\t\tinode = d_inode(server->super->s_root);\n\t\tstatus = nfs4_proc_fsid_present(inode, cred);\n\t\tif (status != -NFS4ERR_MOVED)\n\t\t\tgoto restart;\t \n\t\tif (nfs4_try_migration(server, cred) == -NFS4ERR_LEASE_MOVED)\n\t\t\tgoto restart;\t \n\t\tgoto out;\n\t}\n\trcu_read_unlock();\n\nout:\n\tput_cred(cred);\n\treturn 0;\n}\n\n \nint nfs4_discover_server_trunking(struct nfs_client *clp,\n\t\t\t\t  struct nfs_client **result)\n{\n\tconst struct nfs4_state_recovery_ops *ops =\n\t\t\t\tclp->cl_mvops->reboot_recovery_ops;\n\tstruct rpc_clnt *clnt;\n\tconst struct cred *cred;\n\tint i, status;\n\n\tdprintk(\"NFS: %s: testing '%s'\\n\", __func__, clp->cl_hostname);\n\n\tclnt = clp->cl_rpcclient;\n\ti = 0;\n\n\tmutex_lock(&nfs_clid_init_mutex);\nagain:\n\tstatus  = -ENOENT;\n\tcred = nfs4_get_clid_cred(clp);\n\tif (cred == NULL)\n\t\tgoto out_unlock;\n\n\tstatus = ops->detect_trunking(clp, result, cred);\n\tput_cred(cred);\n\tswitch (status) {\n\tcase 0:\n\tcase -EINTR:\n\tcase -ERESTARTSYS:\n\t\tbreak;\n\tcase -ETIMEDOUT:\n\t\tif (clnt->cl_softrtry)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase -NFS4ERR_DELAY:\n\tcase -EAGAIN:\n\t\tssleep(1);\n\t\tfallthrough;\n\tcase -NFS4ERR_STALE_CLIENTID:\n\t\tdprintk(\"NFS: %s after status %d, retrying\\n\",\n\t\t\t__func__, status);\n\t\tgoto again;\n\tcase -EACCES:\n\t\tif (i++ == 0) {\n\t\t\tnfs4_root_machine_cred(clp);\n\t\t\tgoto again;\n\t\t}\n\t\tif (clnt->cl_auth->au_flavor == RPC_AUTH_UNIX)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase -NFS4ERR_CLID_INUSE:\n\tcase -NFS4ERR_WRONGSEC:\n\t\t \n\t\tif (clnt->cl_auth->au_flavor == RPC_AUTH_UNIX) {\n\t\t\tstatus = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tclnt = rpc_clone_client_set_auth(clnt, RPC_AUTH_UNIX);\n\t\tif (IS_ERR(clnt)) {\n\t\t\tstatus = PTR_ERR(clnt);\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tclnt = xchg(&clp->cl_rpcclient, clnt);\n\t\trpc_shutdown_client(clnt);\n\t\tclnt = clp->cl_rpcclient;\n\t\tgoto again;\n\n\tcase -NFS4ERR_MINOR_VERS_MISMATCH:\n\t\tstatus = -EPROTONOSUPPORT;\n\t\tbreak;\n\n\tcase -EKEYEXPIRED:\n\tcase -NFS4ERR_NOT_SAME:  \n\t\tstatus = -EKEYEXPIRED;\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"NFS: %s unhandled error %d. Exiting with error EIO\\n\",\n\t\t\t\t__func__, status);\n\t\tstatus = -EIO;\n\t}\n\nout_unlock:\n\tmutex_unlock(&nfs_clid_init_mutex);\n\tdprintk(\"NFS: %s: status = %d\\n\", __func__, status);\n\treturn status;\n}\n\n#ifdef CONFIG_NFS_V4_1\nvoid nfs4_schedule_session_recovery(struct nfs4_session *session, int err)\n{\n\tstruct nfs_client *clp = session->clp;\n\n\tswitch (err) {\n\tdefault:\n\t\tset_bit(NFS4CLNT_SESSION_RESET, &clp->cl_state);\n\t\tbreak;\n\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\t\tset_bit(NFS4CLNT_BIND_CONN_TO_SESSION, &clp->cl_state);\n\t}\n\tnfs4_schedule_state_manager(clp);\n}\nEXPORT_SYMBOL_GPL(nfs4_schedule_session_recovery);\n\nvoid nfs41_notify_server(struct nfs_client *clp)\n{\n\t \n\tset_bit(NFS4CLNT_CHECK_LEASE, &clp->cl_state);\n\tnfs4_schedule_state_manager(clp);\n}\n\nstatic void nfs4_reset_all_state(struct nfs_client *clp)\n{\n\tif (test_and_set_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state) == 0) {\n\t\tset_bit(NFS4CLNT_PURGE_STATE, &clp->cl_state);\n\t\tclear_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state);\n\t\tnfs4_state_start_reclaim_nograce(clp);\n\t\tdprintk(\"%s: scheduling reset of all state for server %s!\\n\",\n\t\t\t\t__func__, clp->cl_hostname);\n\t\tnfs4_schedule_state_manager(clp);\n\t}\n}\n\nstatic void nfs41_handle_server_reboot(struct nfs_client *clp)\n{\n\tif (test_and_set_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state) == 0) {\n\t\tnfs4_state_start_reclaim_reboot(clp);\n\t\tdprintk(\"%s: server %s rebooted!\\n\", __func__,\n\t\t\t\tclp->cl_hostname);\n\t\tnfs4_schedule_state_manager(clp);\n\t}\n}\n\nstatic void nfs41_handle_all_state_revoked(struct nfs_client *clp)\n{\n\tnfs4_reset_all_state(clp);\n\tdprintk(\"%s: state revoked on server %s\\n\", __func__, clp->cl_hostname);\n}\n\nstatic void nfs41_handle_some_state_revoked(struct nfs_client *clp)\n{\n\tnfs4_state_start_reclaim_nograce(clp);\n\tnfs4_schedule_state_manager(clp);\n\n\tdprintk(\"%s: state revoked on server %s\\n\", __func__, clp->cl_hostname);\n}\n\nstatic void nfs41_handle_recallable_state_revoked(struct nfs_client *clp)\n{\n\t \n\tpnfs_destroy_all_layouts(clp);\n\tnfs_test_expired_all_delegations(clp);\n\tdprintk(\"%s: Recallable state revoked on server %s!\\n\", __func__,\n\t\t\tclp->cl_hostname);\n}\n\nstatic void nfs41_handle_backchannel_fault(struct nfs_client *clp)\n{\n\tset_bit(NFS4CLNT_SESSION_RESET, &clp->cl_state);\n\tnfs4_schedule_state_manager(clp);\n\n\tdprintk(\"%s: server %s declared a backchannel fault\\n\", __func__,\n\t\t\tclp->cl_hostname);\n}\n\nstatic void nfs41_handle_cb_path_down(struct nfs_client *clp)\n{\n\tif (test_and_set_bit(NFS4CLNT_BIND_CONN_TO_SESSION,\n\t\t&clp->cl_state) == 0)\n\t\tnfs4_schedule_state_manager(clp);\n}\n\nvoid nfs41_handle_sequence_flag_errors(struct nfs_client *clp, u32 flags,\n\t\tbool recovery)\n{\n\tif (!flags)\n\t\treturn;\n\n\tdprintk(\"%s: \\\"%s\\\" (client ID %llx) flags=0x%08x\\n\",\n\t\t__func__, clp->cl_hostname, clp->cl_clientid, flags);\n\t \n\tif (recovery)\n\t\tgoto out_recovery;\n\n\tif (flags & SEQ4_STATUS_RESTART_RECLAIM_NEEDED)\n\t\tnfs41_handle_server_reboot(clp);\n\tif (flags & (SEQ4_STATUS_EXPIRED_ALL_STATE_REVOKED))\n\t\tnfs41_handle_all_state_revoked(clp);\n\tif (flags & (SEQ4_STATUS_EXPIRED_SOME_STATE_REVOKED |\n\t\t\t    SEQ4_STATUS_ADMIN_STATE_REVOKED))\n\t\tnfs41_handle_some_state_revoked(clp);\n\tif (flags & SEQ4_STATUS_LEASE_MOVED)\n\t\tnfs4_schedule_lease_moved_recovery(clp);\n\tif (flags & SEQ4_STATUS_RECALLABLE_STATE_REVOKED)\n\t\tnfs41_handle_recallable_state_revoked(clp);\nout_recovery:\n\tif (flags & SEQ4_STATUS_BACKCHANNEL_FAULT)\n\t\tnfs41_handle_backchannel_fault(clp);\n\telse if (flags & (SEQ4_STATUS_CB_PATH_DOWN |\n\t\t\t\tSEQ4_STATUS_CB_PATH_DOWN_SESSION))\n\t\tnfs41_handle_cb_path_down(clp);\n}\n\nstatic int nfs4_reset_session(struct nfs_client *clp)\n{\n\tconst struct cred *cred;\n\tint status;\n\n\tif (!nfs4_has_session(clp))\n\t\treturn 0;\n\tstatus = nfs4_begin_drain_session(clp);\n\tif (status != 0)\n\t\treturn status;\n\tcred = nfs4_get_clid_cred(clp);\n\tstatus = nfs4_proc_destroy_session(clp->cl_session, cred);\n\tswitch (status) {\n\tcase 0:\n\tcase -NFS4ERR_BADSESSION:\n\tcase -NFS4ERR_DEADSESSION:\n\t\tbreak;\n\tcase -NFS4ERR_BACK_CHAN_BUSY:\n\tcase -NFS4ERR_DELAY:\n\t\tset_bit(NFS4CLNT_SESSION_RESET, &clp->cl_state);\n\t\tstatus = 0;\n\t\tssleep(1);\n\t\tgoto out;\n\tdefault:\n\t\tstatus = nfs4_recovery_handle_error(clp, status);\n\t\tgoto out;\n\t}\n\n\tmemset(clp->cl_session->sess_id.data, 0, NFS4_MAX_SESSIONID_LEN);\n\tstatus = nfs4_proc_create_session(clp, cred);\n\tif (status) {\n\t\tdprintk(\"%s: session reset failed with status %d for server %s!\\n\",\n\t\t\t__func__, status, clp->cl_hostname);\n\t\tstatus = nfs4_handle_reclaim_lease_error(clp, status);\n\t\tgoto out;\n\t}\n\tnfs41_finish_session_reset(clp);\n\tdprintk(\"%s: session reset was successful for server %s!\\n\",\n\t\t\t__func__, clp->cl_hostname);\nout:\n\tput_cred(cred);\n\treturn status;\n}\n\nstatic int nfs4_bind_conn_to_session(struct nfs_client *clp)\n{\n\tconst struct cred *cred;\n\tint ret;\n\n\tif (!nfs4_has_session(clp))\n\t\treturn 0;\n\tret = nfs4_begin_drain_session(clp);\n\tif (ret != 0)\n\t\treturn ret;\n\tcred = nfs4_get_clid_cred(clp);\n\tret = nfs4_proc_bind_conn_to_session(clp, cred);\n\tput_cred(cred);\n\tclear_bit(NFS4CLNT_BIND_CONN_TO_SESSION, &clp->cl_state);\n\tswitch (ret) {\n\tcase 0:\n\t\tdprintk(\"%s: bind_conn_to_session was successful for server %s!\\n\",\n\t\t\t__func__, clp->cl_hostname);\n\t\tbreak;\n\tcase -NFS4ERR_DELAY:\n\t\tssleep(1);\n\t\tset_bit(NFS4CLNT_BIND_CONN_TO_SESSION, &clp->cl_state);\n\t\tbreak;\n\tdefault:\n\t\treturn nfs4_recovery_handle_error(clp, ret);\n\t}\n\treturn 0;\n}\n\nstatic void nfs4_layoutreturn_any_run(struct nfs_client *clp)\n{\n\tint iomode = 0;\n\n\tif (test_and_clear_bit(NFS4CLNT_RECALL_ANY_LAYOUT_READ, &clp->cl_state))\n\t\tiomode += IOMODE_READ;\n\tif (test_and_clear_bit(NFS4CLNT_RECALL_ANY_LAYOUT_RW, &clp->cl_state))\n\t\tiomode += IOMODE_RW;\n\t \n\tif (iomode) {\n\t\tpnfs_layout_return_unused_byclid(clp, iomode);\n\t\tset_bit(NFS4CLNT_RUN_MANAGER, &clp->cl_state);\n\t}\n}\n#else  \nstatic int nfs4_reset_session(struct nfs_client *clp) { return 0; }\n\nstatic int nfs4_bind_conn_to_session(struct nfs_client *clp)\n{\n\treturn 0;\n}\n\nstatic void nfs4_layoutreturn_any_run(struct nfs_client *clp)\n{\n}\n#endif  \n\nstatic void nfs4_state_manager(struct nfs_client *clp)\n{\n\tunsigned int memflags;\n\tint status = 0;\n\tconst char *section = \"\", *section_sep = \"\";\n\n\t \n\tmemflags = memalloc_nofs_save();\n\n\t \n\tdo {\n\t\ttrace_nfs4_state_mgr(clp);\n\t\tclear_bit(NFS4CLNT_RUN_MANAGER, &clp->cl_state);\n\t\tif (test_bit(NFS4CLNT_PURGE_STATE, &clp->cl_state)) {\n\t\t\tsection = \"purge state\";\n\t\t\tstatus = nfs4_purge_lease(clp);\n\t\t\tif (status < 0)\n\t\t\t\tgoto out_error;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (test_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state)) {\n\t\t\tsection = \"lease expired\";\n\t\t\t \n\t\t\tstatus = nfs4_reclaim_lease(clp);\n\t\t\tif (status < 0)\n\t\t\t\tgoto out_error;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (test_and_clear_bit(NFS4CLNT_SESSION_RESET, &clp->cl_state)) {\n\t\t\tsection = \"reset session\";\n\t\t\tstatus = nfs4_reset_session(clp);\n\t\t\tif (test_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state))\n\t\t\t\tcontinue;\n\t\t\tif (status < 0)\n\t\t\t\tgoto out_error;\n\t\t}\n\n\t\t \n\t\tif (test_and_clear_bit(NFS4CLNT_BIND_CONN_TO_SESSION,\n\t\t\t\t&clp->cl_state)) {\n\t\t\tsection = \"bind conn to session\";\n\t\t\tstatus = nfs4_bind_conn_to_session(clp);\n\t\t\tif (status < 0)\n\t\t\t\tgoto out_error;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (test_and_clear_bit(NFS4CLNT_CHECK_LEASE, &clp->cl_state)) {\n\t\t\tsection = \"check lease\";\n\t\t\tstatus = nfs4_check_lease(clp);\n\t\t\tif (status < 0)\n\t\t\t\tgoto out_error;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (test_and_clear_bit(NFS4CLNT_MOVED, &clp->cl_state)) {\n\t\t\tsection = \"migration\";\n\t\t\tstatus = nfs4_handle_migration(clp);\n\t\t\tif (status < 0)\n\t\t\t\tgoto out_error;\n\t\t}\n\n\t\tif (test_and_clear_bit(NFS4CLNT_LEASE_MOVED, &clp->cl_state)) {\n\t\t\tsection = \"lease moved\";\n\t\t\tstatus = nfs4_handle_lease_moved(clp);\n\t\t\tif (status < 0)\n\t\t\t\tgoto out_error;\n\t\t}\n\n\t\t \n\t\tif (test_bit(NFS4CLNT_RECLAIM_REBOOT, &clp->cl_state)) {\n\t\t\tsection = \"reclaim reboot\";\n\t\t\tstatus = nfs4_do_reclaim(clp,\n\t\t\t\tclp->cl_mvops->reboot_recovery_ops);\n\t\t\tif (status == -EAGAIN)\n\t\t\t\tcontinue;\n\t\t\tif (status < 0)\n\t\t\t\tgoto out_error;\n\t\t\tnfs4_state_end_reclaim_reboot(clp);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (test_and_clear_bit(NFS4CLNT_DELEGATION_EXPIRED, &clp->cl_state)) {\n\t\t\tsection = \"detect expired delegations\";\n\t\t\tnfs_reap_expired_delegations(clp);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (test_bit(NFS4CLNT_RECLAIM_NOGRACE, &clp->cl_state)) {\n\t\t\tsection = \"reclaim nograce\";\n\t\t\tstatus = nfs4_do_reclaim(clp,\n\t\t\t\tclp->cl_mvops->nograce_recovery_ops);\n\t\t\tif (status == -EAGAIN)\n\t\t\t\tcontinue;\n\t\t\tif (status < 0)\n\t\t\t\tgoto out_error;\n\t\t\tclear_bit(NFS4CLNT_RECLAIM_NOGRACE, &clp->cl_state);\n\t\t}\n\n\t\tmemalloc_nofs_restore(memflags);\n\t\tnfs4_end_drain_session(clp);\n\t\tnfs4_clear_state_manager_bit(clp);\n\n\t\tif (test_bit(NFS4CLNT_RUN_MANAGER, &clp->cl_state) &&\n\t\t    !test_and_set_bit(NFS4CLNT_MANAGER_RUNNING,\n\t\t\t\t      &clp->cl_state)) {\n\t\t\tmemflags = memalloc_nofs_save();\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!test_and_set_bit(NFS4CLNT_RECALL_RUNNING, &clp->cl_state)) {\n\t\t\tif (test_and_clear_bit(NFS4CLNT_DELEGRETURN, &clp->cl_state)) {\n\t\t\t\tnfs_client_return_marked_delegations(clp);\n\t\t\t\tset_bit(NFS4CLNT_RUN_MANAGER, &clp->cl_state);\n\t\t\t}\n\t\t\tnfs4_layoutreturn_any_run(clp);\n\t\t\tclear_bit(NFS4CLNT_RECALL_RUNNING, &clp->cl_state);\n\t\t}\n\n\t\treturn;\n\n\t} while (refcount_read(&clp->cl_count) > 1 && !signalled());\n\tgoto out_drain;\n\nout_error:\n\tif (strlen(section))\n\t\tsection_sep = \": \";\n\ttrace_nfs4_state_mgr_failed(clp, section, status);\n\tpr_warn_ratelimited(\"NFS: state manager%s%s failed on NFSv4 server %s\"\n\t\t\t\" with error %d\\n\", section_sep, section,\n\t\t\tclp->cl_hostname, -status);\n\tssleep(1);\nout_drain:\n\tmemalloc_nofs_restore(memflags);\n\tnfs4_end_drain_session(clp);\n\tnfs4_clear_state_manager_bit(clp);\n}\n\nstatic int nfs4_run_state_manager(void *ptr)\n{\n\tstruct nfs_client *clp = ptr;\n\tstruct rpc_clnt *cl = clp->cl_rpcclient;\n\n\twhile (cl != cl->cl_parent)\n\t\tcl = cl->cl_parent;\n\n\tallow_signal(SIGKILL);\nagain:\n\tnfs4_state_manager(clp);\n\n\tif (test_bit(NFS4CLNT_MANAGER_AVAILABLE, &clp->cl_state) &&\n\t    !test_bit(NFS4CLNT_MANAGER_RUNNING, &clp->cl_state)) {\n\t\twait_var_event_interruptible(&clp->cl_state,\n\t\t\t\t\t     test_bit(NFS4CLNT_RUN_MANAGER,\n\t\t\t\t\t\t      &clp->cl_state));\n\t\tif (!atomic_read(&cl->cl_swapper))\n\t\t\tclear_bit(NFS4CLNT_MANAGER_AVAILABLE, &clp->cl_state);\n\t\tif (refcount_read(&clp->cl_count) > 1 && !signalled() &&\n\t\t    !test_and_set_bit(NFS4CLNT_MANAGER_RUNNING, &clp->cl_state))\n\t\t\tgoto again;\n\t\t \n\t\tclear_bit(NFS4CLNT_MANAGER_AVAILABLE, &clp->cl_state);\n\t}\n\n\tif (refcount_read(&clp->cl_count) > 1 && !signalled() &&\n\t    test_bit(NFS4CLNT_RUN_MANAGER, &clp->cl_state) &&\n\t    !test_and_set_bit(NFS4CLNT_MANAGER_RUNNING, &clp->cl_state))\n\t\tgoto again;\n\n\tnfs_put_client(clp);\n\tmodule_put_and_kthread_exit(0);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}