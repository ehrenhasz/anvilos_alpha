{
  "module_name": "delegation.c",
  "hash_id": "65efe35acb4997fca7c3586116d40715d14b09a7d5308b97ff29166337f839fb",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfs/delegation.c",
  "human_readable_source": "\n \n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/iversion.h>\n\n#include <linux/nfs4.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_xdr.h>\n\n#include \"nfs4_fs.h\"\n#include \"nfs4session.h\"\n#include \"delegation.h\"\n#include \"internal.h\"\n#include \"nfs4trace.h\"\n\n#define NFS_DEFAULT_DELEGATION_WATERMARK (5000U)\n\nstatic atomic_long_t nfs_active_delegations;\nstatic unsigned nfs_delegation_watermark = NFS_DEFAULT_DELEGATION_WATERMARK;\n\nstatic void __nfs_free_delegation(struct nfs_delegation *delegation)\n{\n\tput_cred(delegation->cred);\n\tdelegation->cred = NULL;\n\tkfree_rcu(delegation, rcu);\n}\n\nstatic void nfs_mark_delegation_revoked(struct nfs_delegation *delegation)\n{\n\tif (!test_and_set_bit(NFS_DELEGATION_REVOKED, &delegation->flags)) {\n\t\tdelegation->stateid.type = NFS4_INVALID_STATEID_TYPE;\n\t\tatomic_long_dec(&nfs_active_delegations);\n\t\tif (!test_bit(NFS_DELEGATION_RETURNING, &delegation->flags))\n\t\t\tnfs_clear_verifier_delegated(delegation->inode);\n\t}\n}\n\nstatic struct nfs_delegation *nfs_get_delegation(struct nfs_delegation *delegation)\n{\n\trefcount_inc(&delegation->refcount);\n\treturn delegation;\n}\n\nstatic void nfs_put_delegation(struct nfs_delegation *delegation)\n{\n\tif (refcount_dec_and_test(&delegation->refcount))\n\t\t__nfs_free_delegation(delegation);\n}\n\nstatic void nfs_free_delegation(struct nfs_delegation *delegation)\n{\n\tnfs_mark_delegation_revoked(delegation);\n\tnfs_put_delegation(delegation);\n}\n\n \nvoid nfs_mark_delegation_referenced(struct nfs_delegation *delegation)\n{\n\tset_bit(NFS_DELEGATION_REFERENCED, &delegation->flags);\n}\n\nstatic void nfs_mark_return_delegation(struct nfs_server *server,\n\t\t\t\t       struct nfs_delegation *delegation)\n{\n\tset_bit(NFS_DELEGATION_RETURN, &delegation->flags);\n\tset_bit(NFS4CLNT_DELEGRETURN, &server->nfs_client->cl_state);\n}\n\nstatic bool\nnfs4_is_valid_delegation(const struct nfs_delegation *delegation,\n\t\tfmode_t flags)\n{\n\tif (delegation != NULL && (delegation->type & flags) == flags &&\n\t    !test_bit(NFS_DELEGATION_REVOKED, &delegation->flags) &&\n\t    !test_bit(NFS_DELEGATION_RETURNING, &delegation->flags))\n\t\treturn true;\n\treturn false;\n}\n\nstruct nfs_delegation *nfs4_get_valid_delegation(const struct inode *inode)\n{\n\tstruct nfs_delegation *delegation;\n\n\tdelegation = rcu_dereference(NFS_I(inode)->delegation);\n\tif (nfs4_is_valid_delegation(delegation, 0))\n\t\treturn delegation;\n\treturn NULL;\n}\n\nstatic int\nnfs4_do_check_delegation(struct inode *inode, fmode_t flags, bool mark)\n{\n\tstruct nfs_delegation *delegation;\n\tint ret = 0;\n\n\tflags &= FMODE_READ|FMODE_WRITE;\n\trcu_read_lock();\n\tdelegation = rcu_dereference(NFS_I(inode)->delegation);\n\tif (nfs4_is_valid_delegation(delegation, flags)) {\n\t\tif (mark)\n\t\t\tnfs_mark_delegation_referenced(delegation);\n\t\tret = 1;\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}\n \nint nfs4_have_delegation(struct inode *inode, fmode_t flags)\n{\n\treturn nfs4_do_check_delegation(inode, flags, true);\n}\n\n \nint nfs4_check_delegation(struct inode *inode, fmode_t flags)\n{\n\treturn nfs4_do_check_delegation(inode, flags, false);\n}\n\nstatic int nfs_delegation_claim_locks(struct nfs4_state *state, const nfs4_stateid *stateid)\n{\n\tstruct inode *inode = state->inode;\n\tstruct file_lock *fl;\n\tstruct file_lock_context *flctx = locks_inode_context(inode);\n\tstruct list_head *list;\n\tint status = 0;\n\n\tif (flctx == NULL)\n\t\tgoto out;\n\n\tlist = &flctx->flc_posix;\n\tspin_lock(&flctx->flc_lock);\nrestart:\n\tlist_for_each_entry(fl, list, fl_list) {\n\t\tif (nfs_file_open_context(fl->fl_file)->state != state)\n\t\t\tcontinue;\n\t\tspin_unlock(&flctx->flc_lock);\n\t\tstatus = nfs4_lock_delegation_recall(fl, state, stateid);\n\t\tif (status < 0)\n\t\t\tgoto out;\n\t\tspin_lock(&flctx->flc_lock);\n\t}\n\tif (list == &flctx->flc_posix) {\n\t\tlist = &flctx->flc_flock;\n\t\tgoto restart;\n\t}\n\tspin_unlock(&flctx->flc_lock);\nout:\n\treturn status;\n}\n\nstatic int nfs_delegation_claim_opens(struct inode *inode,\n\t\tconst nfs4_stateid *stateid, fmode_t type)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs_open_context *ctx;\n\tstruct nfs4_state_owner *sp;\n\tstruct nfs4_state *state;\n\tunsigned int seq;\n\tint err;\n\nagain:\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(ctx, &nfsi->open_files, list) {\n\t\tstate = ctx->state;\n\t\tif (state == NULL)\n\t\t\tcontinue;\n\t\tif (!test_bit(NFS_DELEGATED_STATE, &state->flags))\n\t\t\tcontinue;\n\t\tif (!nfs4_valid_open_stateid(state))\n\t\t\tcontinue;\n\t\tif (!nfs4_stateid_match(&state->stateid, stateid))\n\t\t\tcontinue;\n\t\tif (!get_nfs_open_context(ctx))\n\t\t\tcontinue;\n\t\trcu_read_unlock();\n\t\tsp = state->owner;\n\t\t \n\t\tmutex_lock(&sp->so_delegreturn_mutex);\n\t\tseq = raw_seqcount_begin(&sp->so_reclaim_seqcount);\n\t\terr = nfs4_open_delegation_recall(ctx, state, stateid);\n\t\tif (!err)\n\t\t\terr = nfs_delegation_claim_locks(state, stateid);\n\t\tif (!err && read_seqcount_retry(&sp->so_reclaim_seqcount, seq))\n\t\t\terr = -EAGAIN;\n\t\tmutex_unlock(&sp->so_delegreturn_mutex);\n\t\tput_nfs_open_context(ctx);\n\t\tif (err != 0)\n\t\t\treturn err;\n\t\tgoto again;\n\t}\n\trcu_read_unlock();\n\treturn 0;\n}\n\n \nvoid nfs_inode_reclaim_delegation(struct inode *inode, const struct cred *cred,\n\t\t\t\t  fmode_t type, const nfs4_stateid *stateid,\n\t\t\t\t  unsigned long pagemod_limit)\n{\n\tstruct nfs_delegation *delegation;\n\tconst struct cred *oldcred = NULL;\n\n\trcu_read_lock();\n\tdelegation = rcu_dereference(NFS_I(inode)->delegation);\n\tif (delegation != NULL) {\n\t\tspin_lock(&delegation->lock);\n\t\tnfs4_stateid_copy(&delegation->stateid, stateid);\n\t\tdelegation->type = type;\n\t\tdelegation->pagemod_limit = pagemod_limit;\n\t\toldcred = delegation->cred;\n\t\tdelegation->cred = get_cred(cred);\n\t\tclear_bit(NFS_DELEGATION_NEED_RECLAIM, &delegation->flags);\n\t\tif (test_and_clear_bit(NFS_DELEGATION_REVOKED,\n\t\t\t\t       &delegation->flags))\n\t\t\tatomic_long_inc(&nfs_active_delegations);\n\t\tspin_unlock(&delegation->lock);\n\t\trcu_read_unlock();\n\t\tput_cred(oldcred);\n\t\ttrace_nfs4_reclaim_delegation(inode, type);\n\t} else {\n\t\trcu_read_unlock();\n\t\tnfs_inode_set_delegation(inode, cred, type, stateid,\n\t\t\t\t\t pagemod_limit);\n\t}\n}\n\nstatic int nfs_do_return_delegation(struct inode *inode, struct nfs_delegation *delegation, int issync)\n{\n\tconst struct cred *cred;\n\tint res = 0;\n\n\tif (!test_bit(NFS_DELEGATION_REVOKED, &delegation->flags)) {\n\t\tspin_lock(&delegation->lock);\n\t\tcred = get_cred(delegation->cred);\n\t\tspin_unlock(&delegation->lock);\n\t\tres = nfs4_proc_delegreturn(inode, cred,\n\t\t\t\t&delegation->stateid,\n\t\t\t\tissync);\n\t\tput_cred(cred);\n\t}\n\treturn res;\n}\n\nstatic struct inode *nfs_delegation_grab_inode(struct nfs_delegation *delegation)\n{\n\tstruct inode *inode = NULL;\n\n\tspin_lock(&delegation->lock);\n\tif (delegation->inode != NULL)\n\t\tinode = igrab(delegation->inode);\n\tif (!inode)\n\t\tset_bit(NFS_DELEGATION_INODE_FREEING, &delegation->flags);\n\tspin_unlock(&delegation->lock);\n\treturn inode;\n}\n\nstatic struct nfs_delegation *\nnfs_start_delegation_return_locked(struct nfs_inode *nfsi)\n{\n\tstruct nfs_delegation *ret = NULL;\n\tstruct nfs_delegation *delegation = rcu_dereference(nfsi->delegation);\n\n\tif (delegation == NULL)\n\t\tgoto out;\n\tspin_lock(&delegation->lock);\n\tif (!test_and_set_bit(NFS_DELEGATION_RETURNING, &delegation->flags)) {\n\t\tclear_bit(NFS_DELEGATION_RETURN_DELAYED, &delegation->flags);\n\t\t \n\t\tret = nfs_get_delegation(delegation);\n\t}\n\tspin_unlock(&delegation->lock);\n\tif (ret)\n\t\tnfs_clear_verifier_delegated(&nfsi->vfs_inode);\nout:\n\treturn ret;\n}\n\nstatic struct nfs_delegation *\nnfs_start_delegation_return(struct nfs_inode *nfsi)\n{\n\tstruct nfs_delegation *delegation;\n\n\trcu_read_lock();\n\tdelegation = nfs_start_delegation_return_locked(nfsi);\n\trcu_read_unlock();\n\treturn delegation;\n}\n\nstatic void nfs_abort_delegation_return(struct nfs_delegation *delegation,\n\t\t\t\t\tstruct nfs_client *clp, int err)\n{\n\n\tspin_lock(&delegation->lock);\n\tclear_bit(NFS_DELEGATION_RETURNING, &delegation->flags);\n\tif (err == -EAGAIN) {\n\t\tset_bit(NFS_DELEGATION_RETURN_DELAYED, &delegation->flags);\n\t\tset_bit(NFS4CLNT_DELEGRETURN_DELAYED, &clp->cl_state);\n\t}\n\tspin_unlock(&delegation->lock);\n}\n\nstatic struct nfs_delegation *\nnfs_detach_delegation_locked(struct nfs_inode *nfsi,\n\t\tstruct nfs_delegation *delegation,\n\t\tstruct nfs_client *clp)\n{\n\tstruct nfs_delegation *deleg_cur =\n\t\trcu_dereference_protected(nfsi->delegation,\n\t\t\t\tlockdep_is_held(&clp->cl_lock));\n\n\tif (deleg_cur == NULL || delegation != deleg_cur)\n\t\treturn NULL;\n\n\tspin_lock(&delegation->lock);\n\tif (!delegation->inode) {\n\t\tspin_unlock(&delegation->lock);\n\t\treturn NULL;\n\t}\n\tlist_del_rcu(&delegation->super_list);\n\tdelegation->inode = NULL;\n\trcu_assign_pointer(nfsi->delegation, NULL);\n\tspin_unlock(&delegation->lock);\n\treturn delegation;\n}\n\nstatic struct nfs_delegation *nfs_detach_delegation(struct nfs_inode *nfsi,\n\t\tstruct nfs_delegation *delegation,\n\t\tstruct nfs_server *server)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\n\tspin_lock(&clp->cl_lock);\n\tdelegation = nfs_detach_delegation_locked(nfsi, delegation, clp);\n\tspin_unlock(&clp->cl_lock);\n\treturn delegation;\n}\n\nstatic struct nfs_delegation *\nnfs_inode_detach_delegation(struct inode *inode)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs_delegation *delegation;\n\n\trcu_read_lock();\n\tdelegation = rcu_dereference(nfsi->delegation);\n\tif (delegation != NULL)\n\t\tdelegation = nfs_detach_delegation(nfsi, delegation, server);\n\trcu_read_unlock();\n\treturn delegation;\n}\n\nstatic void\nnfs_update_delegation_cred(struct nfs_delegation *delegation,\n\t\tconst struct cred *cred)\n{\n\tconst struct cred *old;\n\n\tif (cred_fscmp(delegation->cred, cred) != 0) {\n\t\told = xchg(&delegation->cred, get_cred(cred));\n\t\tput_cred(old);\n\t}\n}\n\nstatic void\nnfs_update_inplace_delegation(struct nfs_delegation *delegation,\n\t\tconst struct nfs_delegation *update)\n{\n\tif (nfs4_stateid_is_newer(&update->stateid, &delegation->stateid)) {\n\t\tdelegation->stateid.seqid = update->stateid.seqid;\n\t\tsmp_wmb();\n\t\tdelegation->type = update->type;\n\t\tdelegation->pagemod_limit = update->pagemod_limit;\n\t\tif (test_bit(NFS_DELEGATION_REVOKED, &delegation->flags)) {\n\t\t\tdelegation->change_attr = update->change_attr;\n\t\t\tnfs_update_delegation_cred(delegation, update->cred);\n\t\t\t \n\t\t\tclear_bit(NFS_DELEGATION_REVOKED, &delegation->flags);\n\t\t\tatomic_long_inc(&nfs_active_delegations);\n\t\t}\n\t}\n}\n\n \nint nfs_inode_set_delegation(struct inode *inode, const struct cred *cred,\n\t\t\t\t  fmode_t type,\n\t\t\t\t  const nfs4_stateid *stateid,\n\t\t\t\t  unsigned long pagemod_limit)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs_delegation *delegation, *old_delegation;\n\tstruct nfs_delegation *freeme = NULL;\n\tint status = 0;\n\n\tdelegation = kmalloc(sizeof(*delegation), GFP_KERNEL_ACCOUNT);\n\tif (delegation == NULL)\n\t\treturn -ENOMEM;\n\tnfs4_stateid_copy(&delegation->stateid, stateid);\n\trefcount_set(&delegation->refcount, 1);\n\tdelegation->type = type;\n\tdelegation->pagemod_limit = pagemod_limit;\n\tdelegation->change_attr = inode_peek_iversion_raw(inode);\n\tdelegation->cred = get_cred(cred);\n\tdelegation->inode = inode;\n\tdelegation->flags = 1<<NFS_DELEGATION_REFERENCED;\n\tspin_lock_init(&delegation->lock);\n\n\tspin_lock(&clp->cl_lock);\n\told_delegation = rcu_dereference_protected(nfsi->delegation,\n\t\t\t\t\tlockdep_is_held(&clp->cl_lock));\n\tif (old_delegation == NULL)\n\t\tgoto add_new;\n\t \n\tif (nfs4_stateid_match_other(&old_delegation->stateid,\n\t\t\t\t&delegation->stateid)) {\n\t\tspin_lock(&old_delegation->lock);\n\t\tnfs_update_inplace_delegation(old_delegation,\n\t\t\t\tdelegation);\n\t\tspin_unlock(&old_delegation->lock);\n\t\tgoto out;\n\t}\n\tif (!test_bit(NFS_DELEGATION_REVOKED, &old_delegation->flags)) {\n\t\t \n\t\tdfprintk(FILE, \"%s: server %s handed out \"\n\t\t\t\t\"a duplicate delegation!\\n\",\n\t\t\t\t__func__, clp->cl_hostname);\n\t\tif (delegation->type == old_delegation->type ||\n\t\t    !(delegation->type & FMODE_WRITE)) {\n\t\t\tfreeme = delegation;\n\t\t\tdelegation = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (test_and_set_bit(NFS_DELEGATION_RETURNING,\n\t\t\t\t\t&old_delegation->flags))\n\t\t\tgoto out;\n\t}\n\tfreeme = nfs_detach_delegation_locked(nfsi, old_delegation, clp);\n\tif (freeme == NULL)\n\t\tgoto out;\nadd_new:\n\t \n\tspin_lock(&inode->i_lock);\n\tif (NFS_I(inode)->cache_validity & NFS_INO_INVALID_CHANGE)\n\t\tnfs_set_cache_invalid(inode,\n\t\t\tNFS_INO_INVALID_ATIME | NFS_INO_INVALID_CTIME |\n\t\t\tNFS_INO_INVALID_MTIME | NFS_INO_INVALID_SIZE |\n\t\t\tNFS_INO_INVALID_BLOCKS | NFS_INO_INVALID_NLINK |\n\t\t\tNFS_INO_INVALID_OTHER | NFS_INO_INVALID_DATA |\n\t\t\tNFS_INO_INVALID_ACCESS | NFS_INO_INVALID_ACL |\n\t\t\tNFS_INO_INVALID_XATTR);\n\tspin_unlock(&inode->i_lock);\n\n\tlist_add_tail_rcu(&delegation->super_list, &server->delegations);\n\trcu_assign_pointer(nfsi->delegation, delegation);\n\tdelegation = NULL;\n\n\tatomic_long_inc(&nfs_active_delegations);\n\n\ttrace_nfs4_set_delegation(inode, type);\nout:\n\tspin_unlock(&clp->cl_lock);\n\tif (delegation != NULL)\n\t\t__nfs_free_delegation(delegation);\n\tif (freeme != NULL) {\n\t\tnfs_do_return_delegation(inode, freeme, 0);\n\t\tnfs_free_delegation(freeme);\n\t}\n\treturn status;\n}\n\n \nstatic int nfs_end_delegation_return(struct inode *inode, struct nfs_delegation *delegation, int issync)\n{\n\tstruct nfs_client *clp = NFS_SERVER(inode)->nfs_client;\n\tunsigned int mode = O_WRONLY | O_RDWR;\n\tint err = 0;\n\n\tif (delegation == NULL)\n\t\treturn 0;\n\n\tif (!issync)\n\t\tmode |= O_NONBLOCK;\n\t \n\terr = break_lease(inode, mode);\n\n\twhile (err == 0) {\n\t\tif (test_bit(NFS_DELEGATION_REVOKED, &delegation->flags))\n\t\t\tbreak;\n\t\terr = nfs_delegation_claim_opens(inode, &delegation->stateid,\n\t\t\t\tdelegation->type);\n\t\tif (!issync || err != -EAGAIN)\n\t\t\tbreak;\n\t\t \n\t\terr = nfs4_wait_clnt_recover(clp);\n\t}\n\n\tif (err) {\n\t\tnfs_abort_delegation_return(delegation, clp, err);\n\t\tgoto out;\n\t}\n\n\terr = nfs_do_return_delegation(inode, delegation, issync);\nout:\n\t \n\tnfs_put_delegation(delegation);\n\treturn err;\n}\n\nstatic bool nfs_delegation_need_return(struct nfs_delegation *delegation)\n{\n\tbool ret = false;\n\n\tif (test_and_clear_bit(NFS_DELEGATION_RETURN, &delegation->flags))\n\t\tret = true;\n\telse if (test_bit(NFS_DELEGATION_RETURN_IF_CLOSED, &delegation->flags)) {\n\t\tstruct inode *inode;\n\n\t\tspin_lock(&delegation->lock);\n\t\tinode = delegation->inode;\n\t\tif (inode && list_empty(&NFS_I(inode)->open_files))\n\t\t\tret = true;\n\t\tspin_unlock(&delegation->lock);\n\t}\n\tif (ret)\n\t\tclear_bit(NFS_DELEGATION_RETURN_IF_CLOSED, &delegation->flags);\n\tif (test_bit(NFS_DELEGATION_RETURNING, &delegation->flags) ||\n\t    test_bit(NFS_DELEGATION_RETURN_DELAYED, &delegation->flags) ||\n\t    test_bit(NFS_DELEGATION_REVOKED, &delegation->flags))\n\t\tret = false;\n\n\treturn ret;\n}\n\nstatic int nfs_server_return_marked_delegations(struct nfs_server *server,\n\t\tvoid __always_unused *data)\n{\n\tstruct nfs_delegation *delegation;\n\tstruct nfs_delegation *prev;\n\tstruct inode *inode;\n\tstruct inode *place_holder = NULL;\n\tstruct nfs_delegation *place_holder_deleg = NULL;\n\tint err = 0;\n\nrestart:\n\t \n\tprev = NULL;\n\tdelegation = NULL;\n\trcu_read_lock();\n\tif (place_holder)\n\t\tdelegation = rcu_dereference(NFS_I(place_holder)->delegation);\n\tif (!delegation || delegation != place_holder_deleg)\n\t\tdelegation = list_entry_rcu(server->delegations.next,\n\t\t\t\t\t    struct nfs_delegation, super_list);\n\tlist_for_each_entry_from_rcu(delegation, &server->delegations, super_list) {\n\t\tstruct inode *to_put = NULL;\n\n\t\tif (test_bit(NFS_DELEGATION_INODE_FREEING, &delegation->flags))\n\t\t\tcontinue;\n\t\tif (!nfs_delegation_need_return(delegation)) {\n\t\t\tif (nfs4_is_valid_delegation(delegation, 0))\n\t\t\t\tprev = delegation;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (prev) {\n\t\t\tstruct inode *tmp = nfs_delegation_grab_inode(prev);\n\t\t\tif (tmp) {\n\t\t\t\tto_put = place_holder;\n\t\t\t\tplace_holder = tmp;\n\t\t\t\tplace_holder_deleg = prev;\n\t\t\t}\n\t\t}\n\n\t\tinode = nfs_delegation_grab_inode(delegation);\n\t\tif (inode == NULL) {\n\t\t\trcu_read_unlock();\n\t\t\tiput(to_put);\n\t\t\tgoto restart;\n\t\t}\n\t\tdelegation = nfs_start_delegation_return_locked(NFS_I(inode));\n\t\trcu_read_unlock();\n\n\t\tiput(to_put);\n\n\t\terr = nfs_end_delegation_return(inode, delegation, 0);\n\t\tiput(inode);\n\t\tcond_resched();\n\t\tif (!err)\n\t\t\tgoto restart;\n\t\tset_bit(NFS4CLNT_DELEGRETURN, &server->nfs_client->cl_state);\n\t\tgoto out;\n\t}\n\trcu_read_unlock();\nout:\n\tiput(place_holder);\n\treturn err;\n}\n\nstatic bool nfs_server_clear_delayed_delegations(struct nfs_server *server)\n{\n\tstruct nfs_delegation *d;\n\tbool ret = false;\n\n\tlist_for_each_entry_rcu (d, &server->delegations, super_list) {\n\t\tif (!test_bit(NFS_DELEGATION_RETURN_DELAYED, &d->flags))\n\t\t\tcontinue;\n\t\tnfs_mark_return_delegation(server, d);\n\t\tclear_bit(NFS_DELEGATION_RETURN_DELAYED, &d->flags);\n\t\tret = true;\n\t}\n\treturn ret;\n}\n\nstatic bool nfs_client_clear_delayed_delegations(struct nfs_client *clp)\n{\n\tstruct nfs_server *server;\n\tbool ret = false;\n\n\tif (!test_and_clear_bit(NFS4CLNT_DELEGRETURN_DELAYED, &clp->cl_state))\n\t\tgoto out;\n\trcu_read_lock();\n\tlist_for_each_entry_rcu (server, &clp->cl_superblocks, client_link) {\n\t\tif (nfs_server_clear_delayed_delegations(server))\n\t\t\tret = true;\n\t}\n\trcu_read_unlock();\nout:\n\treturn ret;\n}\n\n \nint nfs_client_return_marked_delegations(struct nfs_client *clp)\n{\n\tint err = nfs_client_for_each_server(\n\t\tclp, nfs_server_return_marked_delegations, NULL);\n\tif (err)\n\t\treturn err;\n\t \n\tif (nfs_client_clear_delayed_delegations(clp))\n\t\tssleep(1);\n\treturn 0;\n}\n\n \nvoid nfs_inode_evict_delegation(struct inode *inode)\n{\n\tstruct nfs_delegation *delegation;\n\n\tdelegation = nfs_inode_detach_delegation(inode);\n\tif (delegation != NULL) {\n\t\tset_bit(NFS_DELEGATION_RETURNING, &delegation->flags);\n\t\tset_bit(NFS_DELEGATION_INODE_FREEING, &delegation->flags);\n\t\tnfs_do_return_delegation(inode, delegation, 1);\n\t\tnfs_free_delegation(delegation);\n\t}\n}\n\n \nint nfs4_inode_return_delegation(struct inode *inode)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs_delegation *delegation;\n\n\tdelegation = nfs_start_delegation_return(nfsi);\n\tif (delegation != NULL) {\n\t\t \n\t\tbreak_lease(inode, O_WRONLY | O_RDWR);\n\t\tif (S_ISREG(inode->i_mode))\n\t\t\tnfs_wb_all(inode);\n\t\treturn nfs_end_delegation_return(inode, delegation, 1);\n\t}\n\treturn 0;\n}\n\n \nvoid nfs4_inode_return_delegation_on_close(struct inode *inode)\n{\n\tstruct nfs_delegation *delegation;\n\tstruct nfs_delegation *ret = NULL;\n\n\tif (!inode)\n\t\treturn;\n\trcu_read_lock();\n\tdelegation = nfs4_get_valid_delegation(inode);\n\tif (!delegation)\n\t\tgoto out;\n\tif (test_bit(NFS_DELEGATION_RETURN_IF_CLOSED, &delegation->flags) ||\n\t    atomic_long_read(&nfs_active_delegations) >= nfs_delegation_watermark) {\n\t\tspin_lock(&delegation->lock);\n\t\tif (delegation->inode &&\n\t\t    list_empty(&NFS_I(inode)->open_files) &&\n\t\t    !test_and_set_bit(NFS_DELEGATION_RETURNING, &delegation->flags)) {\n\t\t\tclear_bit(NFS_DELEGATION_RETURN_IF_CLOSED, &delegation->flags);\n\t\t\t \n\t\t\tret = nfs_get_delegation(delegation);\n\t\t}\n\t\tspin_unlock(&delegation->lock);\n\t\tif (ret)\n\t\t\tnfs_clear_verifier_delegated(inode);\n\t}\nout:\n\trcu_read_unlock();\n\tnfs_end_delegation_return(inode, ret, 0);\n}\n\n \nint nfs4_inode_make_writeable(struct inode *inode)\n{\n\tstruct nfs_delegation *delegation;\n\n\trcu_read_lock();\n\tdelegation = nfs4_get_valid_delegation(inode);\n\tif (delegation == NULL ||\n\t    (nfs4_has_session(NFS_SERVER(inode)->nfs_client) &&\n\t     (delegation->type & FMODE_WRITE))) {\n\t\trcu_read_unlock();\n\t\treturn 0;\n\t}\n\trcu_read_unlock();\n\treturn nfs4_inode_return_delegation(inode);\n}\n\nstatic void nfs_mark_return_if_closed_delegation(struct nfs_server *server,\n\t\tstruct nfs_delegation *delegation)\n{\n\tset_bit(NFS_DELEGATION_RETURN_IF_CLOSED, &delegation->flags);\n\tset_bit(NFS4CLNT_DELEGRETURN, &server->nfs_client->cl_state);\n}\n\nstatic bool nfs_server_mark_return_all_delegations(struct nfs_server *server)\n{\n\tstruct nfs_delegation *delegation;\n\tbool ret = false;\n\n\tlist_for_each_entry_rcu(delegation, &server->delegations, super_list) {\n\t\tnfs_mark_return_delegation(server, delegation);\n\t\tret = true;\n\t}\n\treturn ret;\n}\n\nstatic void nfs_client_mark_return_all_delegations(struct nfs_client *clp)\n{\n\tstruct nfs_server *server;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link)\n\t\tnfs_server_mark_return_all_delegations(server);\n\trcu_read_unlock();\n}\n\nstatic void nfs_delegation_run_state_manager(struct nfs_client *clp)\n{\n\tif (test_bit(NFS4CLNT_DELEGRETURN, &clp->cl_state))\n\t\tnfs4_schedule_state_manager(clp);\n}\n\n \nvoid nfs_expire_all_delegations(struct nfs_client *clp)\n{\n\tnfs_client_mark_return_all_delegations(clp);\n\tnfs_delegation_run_state_manager(clp);\n}\n\n \nvoid nfs_server_return_all_delegations(struct nfs_server *server)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tbool need_wait;\n\n\tif (clp == NULL)\n\t\treturn;\n\n\trcu_read_lock();\n\tneed_wait = nfs_server_mark_return_all_delegations(server);\n\trcu_read_unlock();\n\n\tif (need_wait) {\n\t\tnfs4_schedule_state_manager(clp);\n\t\tnfs4_wait_clnt_recover(clp);\n\t}\n}\n\nstatic void nfs_mark_return_unused_delegation_types(struct nfs_server *server,\n\t\t\t\t\t\t fmode_t flags)\n{\n\tstruct nfs_delegation *delegation;\n\n\tlist_for_each_entry_rcu(delegation, &server->delegations, super_list) {\n\t\tif ((delegation->type == (FMODE_READ|FMODE_WRITE)) && !(flags & FMODE_WRITE))\n\t\t\tcontinue;\n\t\tif (delegation->type & flags)\n\t\t\tnfs_mark_return_if_closed_delegation(server, delegation);\n\t}\n}\n\nstatic void nfs_client_mark_return_unused_delegation_types(struct nfs_client *clp,\n\t\t\t\t\t\t\tfmode_t flags)\n{\n\tstruct nfs_server *server;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link)\n\t\tnfs_mark_return_unused_delegation_types(server, flags);\n\trcu_read_unlock();\n}\n\nstatic void nfs_revoke_delegation(struct inode *inode,\n\t\tconst nfs4_stateid *stateid)\n{\n\tstruct nfs_delegation *delegation;\n\tnfs4_stateid tmp;\n\tbool ret = false;\n\n\trcu_read_lock();\n\tdelegation = rcu_dereference(NFS_I(inode)->delegation);\n\tif (delegation == NULL)\n\t\tgoto out;\n\tif (stateid == NULL) {\n\t\tnfs4_stateid_copy(&tmp, &delegation->stateid);\n\t\tstateid = &tmp;\n\t} else {\n\t\tif (!nfs4_stateid_match_other(stateid, &delegation->stateid))\n\t\t\tgoto out;\n\t\tspin_lock(&delegation->lock);\n\t\tif (stateid->seqid) {\n\t\t\tif (nfs4_stateid_is_newer(&delegation->stateid, stateid)) {\n\t\t\t\tspin_unlock(&delegation->lock);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tdelegation->stateid.seqid = stateid->seqid;\n\t\t}\n\t\tspin_unlock(&delegation->lock);\n\t}\n\tnfs_mark_delegation_revoked(delegation);\n\tret = true;\nout:\n\trcu_read_unlock();\n\tif (ret)\n\t\tnfs_inode_find_state_and_recover(inode, stateid);\n}\n\nvoid nfs_remove_bad_delegation(struct inode *inode,\n\t\tconst nfs4_stateid *stateid)\n{\n\tnfs_revoke_delegation(inode, stateid);\n}\nEXPORT_SYMBOL_GPL(nfs_remove_bad_delegation);\n\nvoid nfs_delegation_mark_returned(struct inode *inode,\n\t\tconst nfs4_stateid *stateid)\n{\n\tstruct nfs_delegation *delegation;\n\n\tif (!inode)\n\t\treturn;\n\n\trcu_read_lock();\n\tdelegation = rcu_dereference(NFS_I(inode)->delegation);\n\tif (!delegation)\n\t\tgoto out_rcu_unlock;\n\n\tspin_lock(&delegation->lock);\n\tif (!nfs4_stateid_match_other(stateid, &delegation->stateid))\n\t\tgoto out_spin_unlock;\n\tif (stateid->seqid) {\n\t\t \n\t\tif (nfs4_stateid_is_newer(&delegation->stateid, stateid))\n\t\t\tgoto out_clear_returning;\n\t\tif (delegation->stateid.seqid != stateid->seqid)\n\t\t\tdelegation->stateid.seqid = stateid->seqid;\n\t}\n\n\tnfs_mark_delegation_revoked(delegation);\n\nout_clear_returning:\n\tclear_bit(NFS_DELEGATION_RETURNING, &delegation->flags);\nout_spin_unlock:\n\tspin_unlock(&delegation->lock);\nout_rcu_unlock:\n\trcu_read_unlock();\n\n\tnfs_inode_find_state_and_recover(inode, stateid);\n}\n\n \nvoid nfs_expire_unused_delegation_types(struct nfs_client *clp, fmode_t flags)\n{\n\tnfs_client_mark_return_unused_delegation_types(clp, flags);\n\tnfs_delegation_run_state_manager(clp);\n}\n\nstatic void nfs_mark_return_unreferenced_delegations(struct nfs_server *server)\n{\n\tstruct nfs_delegation *delegation;\n\n\tlist_for_each_entry_rcu(delegation, &server->delegations, super_list) {\n\t\tif (test_and_clear_bit(NFS_DELEGATION_REFERENCED, &delegation->flags))\n\t\t\tcontinue;\n\t\tnfs_mark_return_if_closed_delegation(server, delegation);\n\t}\n}\n\n \nvoid nfs_expire_unreferenced_delegations(struct nfs_client *clp)\n{\n\tstruct nfs_server *server;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link)\n\t\tnfs_mark_return_unreferenced_delegations(server);\n\trcu_read_unlock();\n\n\tnfs_delegation_run_state_manager(clp);\n}\n\n \nint nfs_async_inode_return_delegation(struct inode *inode,\n\t\t\t\t      const nfs4_stateid *stateid)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct nfs_delegation *delegation;\n\n\trcu_read_lock();\n\tdelegation = nfs4_get_valid_delegation(inode);\n\tif (delegation == NULL)\n\t\tgoto out_enoent;\n\tif (stateid != NULL &&\n\t    !clp->cl_mvops->match_stateid(&delegation->stateid, stateid))\n\t\tgoto out_enoent;\n\tnfs_mark_return_delegation(server, delegation);\n\trcu_read_unlock();\n\n\t \n\tbreak_lease(inode, O_WRONLY | O_RDWR | O_NONBLOCK);\n\n\tnfs_delegation_run_state_manager(clp);\n\treturn 0;\nout_enoent:\n\trcu_read_unlock();\n\treturn -ENOENT;\n}\n\nstatic struct inode *\nnfs_delegation_find_inode_server(struct nfs_server *server,\n\t\t\t\t const struct nfs_fh *fhandle)\n{\n\tstruct nfs_delegation *delegation;\n\tstruct super_block *freeme = NULL;\n\tstruct inode *res = NULL;\n\n\tlist_for_each_entry_rcu(delegation, &server->delegations, super_list) {\n\t\tspin_lock(&delegation->lock);\n\t\tif (delegation->inode != NULL &&\n\t\t    !test_bit(NFS_DELEGATION_REVOKED, &delegation->flags) &&\n\t\t    nfs_compare_fh(fhandle, &NFS_I(delegation->inode)->fh) == 0) {\n\t\t\tif (nfs_sb_active(server->super)) {\n\t\t\t\tfreeme = server->super;\n\t\t\t\tres = igrab(delegation->inode);\n\t\t\t}\n\t\t\tspin_unlock(&delegation->lock);\n\t\t\tif (res != NULL)\n\t\t\t\treturn res;\n\t\t\tif (freeme) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\tnfs_sb_deactive(freeme);\n\t\t\t\trcu_read_lock();\n\t\t\t}\n\t\t\treturn ERR_PTR(-EAGAIN);\n\t\t}\n\t\tspin_unlock(&delegation->lock);\n\t}\n\treturn ERR_PTR(-ENOENT);\n}\n\n \nstruct inode *nfs_delegation_find_inode(struct nfs_client *clp,\n\t\t\t\t\tconst struct nfs_fh *fhandle)\n{\n\tstruct nfs_server *server;\n\tstruct inode *res;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link) {\n\t\tres = nfs_delegation_find_inode_server(server, fhandle);\n\t\tif (res != ERR_PTR(-ENOENT)) {\n\t\t\trcu_read_unlock();\n\t\t\treturn res;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn ERR_PTR(-ENOENT);\n}\n\nstatic void nfs_delegation_mark_reclaim_server(struct nfs_server *server)\n{\n\tstruct nfs_delegation *delegation;\n\n\tlist_for_each_entry_rcu(delegation, &server->delegations, super_list) {\n\t\t \n\t\tif (test_bit(NFS_DELEGATION_TEST_EXPIRED, &delegation->flags))\n\t\t\tcontinue;\n\t\tset_bit(NFS_DELEGATION_NEED_RECLAIM, &delegation->flags);\n\t}\n}\n\n \nvoid nfs_delegation_mark_reclaim(struct nfs_client *clp)\n{\n\tstruct nfs_server *server;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link)\n\t\tnfs_delegation_mark_reclaim_server(server);\n\trcu_read_unlock();\n}\n\nstatic int nfs_server_reap_unclaimed_delegations(struct nfs_server *server,\n\t\tvoid __always_unused *data)\n{\n\tstruct nfs_delegation *delegation;\n\tstruct inode *inode;\nrestart:\n\trcu_read_lock();\nrestart_locked:\n\tlist_for_each_entry_rcu(delegation, &server->delegations, super_list) {\n\t\tif (test_bit(NFS_DELEGATION_INODE_FREEING,\n\t\t\t\t\t&delegation->flags) ||\n\t\t    test_bit(NFS_DELEGATION_RETURNING,\n\t\t\t\t\t&delegation->flags) ||\n\t\t    test_bit(NFS_DELEGATION_NEED_RECLAIM,\n\t\t\t\t\t&delegation->flags) == 0)\n\t\t\tcontinue;\n\t\tinode = nfs_delegation_grab_inode(delegation);\n\t\tif (inode == NULL)\n\t\t\tgoto restart_locked;\n\t\tdelegation = nfs_start_delegation_return_locked(NFS_I(inode));\n\t\trcu_read_unlock();\n\t\tif (delegation != NULL) {\n\t\t\tif (nfs_detach_delegation(NFS_I(inode), delegation,\n\t\t\t\t\t\tserver) != NULL)\n\t\t\t\tnfs_free_delegation(delegation);\n\t\t\t \n\t\t\tnfs_put_delegation(delegation);\n\t\t}\n\t\tiput(inode);\n\t\tcond_resched();\n\t\tgoto restart;\n\t}\n\trcu_read_unlock();\n\treturn 0;\n}\n\n \nvoid nfs_delegation_reap_unclaimed(struct nfs_client *clp)\n{\n\tnfs_client_for_each_server(clp, nfs_server_reap_unclaimed_delegations,\n\t\t\tNULL);\n}\n\nstatic inline bool nfs4_server_rebooted(const struct nfs_client *clp)\n{\n\treturn (clp->cl_state & (BIT(NFS4CLNT_CHECK_LEASE) |\n\t\t\t\tBIT(NFS4CLNT_LEASE_EXPIRED) |\n\t\t\t\tBIT(NFS4CLNT_SESSION_RESET))) != 0;\n}\n\nstatic void nfs_mark_test_expired_delegation(struct nfs_server *server,\n\t    struct nfs_delegation *delegation)\n{\n\tif (delegation->stateid.type == NFS4_INVALID_STATEID_TYPE)\n\t\treturn;\n\tclear_bit(NFS_DELEGATION_NEED_RECLAIM, &delegation->flags);\n\tset_bit(NFS_DELEGATION_TEST_EXPIRED, &delegation->flags);\n\tset_bit(NFS4CLNT_DELEGATION_EXPIRED, &server->nfs_client->cl_state);\n}\n\nstatic void nfs_inode_mark_test_expired_delegation(struct nfs_server *server,\n\t\tstruct inode *inode)\n{\n\tstruct nfs_delegation *delegation;\n\n\trcu_read_lock();\n\tdelegation = rcu_dereference(NFS_I(inode)->delegation);\n\tif (delegation)\n\t\tnfs_mark_test_expired_delegation(server, delegation);\n\trcu_read_unlock();\n\n}\n\nstatic void nfs_delegation_mark_test_expired_server(struct nfs_server *server)\n{\n\tstruct nfs_delegation *delegation;\n\n\tlist_for_each_entry_rcu(delegation, &server->delegations, super_list)\n\t\tnfs_mark_test_expired_delegation(server, delegation);\n}\n\n \nvoid nfs_mark_test_expired_all_delegations(struct nfs_client *clp)\n{\n\tstruct nfs_server *server;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link)\n\t\tnfs_delegation_mark_test_expired_server(server);\n\trcu_read_unlock();\n}\n\n \nvoid nfs_test_expired_all_delegations(struct nfs_client *clp)\n{\n\tnfs_mark_test_expired_all_delegations(clp);\n\tnfs4_schedule_state_manager(clp);\n}\n\nstatic void\nnfs_delegation_test_free_expired(struct inode *inode,\n\t\tnfs4_stateid *stateid,\n\t\tconst struct cred *cred)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tconst struct nfs4_minor_version_ops *ops = server->nfs_client->cl_mvops;\n\tint status;\n\n\tif (!cred)\n\t\treturn;\n\tstatus = ops->test_and_free_expired(server, stateid, cred);\n\tif (status == -NFS4ERR_EXPIRED || status == -NFS4ERR_BAD_STATEID)\n\t\tnfs_remove_bad_delegation(inode, stateid);\n}\n\nstatic int nfs_server_reap_expired_delegations(struct nfs_server *server,\n\t\tvoid __always_unused *data)\n{\n\tstruct nfs_delegation *delegation;\n\tstruct inode *inode;\n\tconst struct cred *cred;\n\tnfs4_stateid stateid;\nrestart:\n\trcu_read_lock();\nrestart_locked:\n\tlist_for_each_entry_rcu(delegation, &server->delegations, super_list) {\n\t\tif (test_bit(NFS_DELEGATION_INODE_FREEING,\n\t\t\t\t\t&delegation->flags) ||\n\t\t    test_bit(NFS_DELEGATION_RETURNING,\n\t\t\t\t\t&delegation->flags) ||\n\t\t    test_bit(NFS_DELEGATION_TEST_EXPIRED,\n\t\t\t\t\t&delegation->flags) == 0)\n\t\t\tcontinue;\n\t\tinode = nfs_delegation_grab_inode(delegation);\n\t\tif (inode == NULL)\n\t\t\tgoto restart_locked;\n\t\tspin_lock(&delegation->lock);\n\t\tcred = get_cred_rcu(delegation->cred);\n\t\tnfs4_stateid_copy(&stateid, &delegation->stateid);\n\t\tspin_unlock(&delegation->lock);\n\t\tclear_bit(NFS_DELEGATION_TEST_EXPIRED, &delegation->flags);\n\t\trcu_read_unlock();\n\t\tnfs_delegation_test_free_expired(inode, &stateid, cred);\n\t\tput_cred(cred);\n\t\tif (!nfs4_server_rebooted(server->nfs_client)) {\n\t\t\tiput(inode);\n\t\t\tcond_resched();\n\t\t\tgoto restart;\n\t\t}\n\t\tnfs_inode_mark_test_expired_delegation(server,inode);\n\t\tiput(inode);\n\t\treturn -EAGAIN;\n\t}\n\trcu_read_unlock();\n\treturn 0;\n}\n\n \nvoid nfs_reap_expired_delegations(struct nfs_client *clp)\n{\n\tnfs_client_for_each_server(clp, nfs_server_reap_expired_delegations,\n\t\t\tNULL);\n}\n\nvoid nfs_inode_find_delegation_state_and_recover(struct inode *inode,\n\t\tconst nfs4_stateid *stateid)\n{\n\tstruct nfs_client *clp = NFS_SERVER(inode)->nfs_client;\n\tstruct nfs_delegation *delegation;\n\tbool found = false;\n\n\trcu_read_lock();\n\tdelegation = rcu_dereference(NFS_I(inode)->delegation);\n\tif (delegation &&\n\t    nfs4_stateid_match_or_older(&delegation->stateid, stateid) &&\n\t    !test_bit(NFS_DELEGATION_REVOKED, &delegation->flags)) {\n\t\tnfs_mark_test_expired_delegation(NFS_SERVER(inode), delegation);\n\t\tfound = true;\n\t}\n\trcu_read_unlock();\n\tif (found)\n\t\tnfs4_schedule_state_manager(clp);\n}\n\n \nint nfs_delegations_present(struct nfs_client *clp)\n{\n\tstruct nfs_server *server;\n\tint ret = 0;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link)\n\t\tif (!list_empty(&server->delegations)) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\trcu_read_unlock();\n\treturn ret;\n}\n\n \nbool nfs4_refresh_delegation_stateid(nfs4_stateid *dst, struct inode *inode)\n{\n\tstruct nfs_delegation *delegation;\n\tbool ret = false;\n\tif (!inode)\n\t\tgoto out;\n\n\trcu_read_lock();\n\tdelegation = rcu_dereference(NFS_I(inode)->delegation);\n\tif (delegation != NULL &&\n\t    nfs4_stateid_match_other(dst, &delegation->stateid) &&\n\t    nfs4_stateid_is_newer(&delegation->stateid, dst) &&\n\t    !test_bit(NFS_DELEGATION_REVOKED, &delegation->flags)) {\n\t\tdst->seqid = delegation->stateid.seqid;\n\t\tret = true;\n\t}\n\trcu_read_unlock();\nout:\n\treturn ret;\n}\n\n \nbool nfs4_copy_delegation_stateid(struct inode *inode, fmode_t flags,\n\t\tnfs4_stateid *dst, const struct cred **cred)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs_delegation *delegation;\n\tbool ret = false;\n\n\tflags &= FMODE_READ|FMODE_WRITE;\n\trcu_read_lock();\n\tdelegation = rcu_dereference(nfsi->delegation);\n\tif (!delegation)\n\t\tgoto out;\n\tspin_lock(&delegation->lock);\n\tret = nfs4_is_valid_delegation(delegation, flags);\n\tif (ret) {\n\t\tnfs4_stateid_copy(dst, &delegation->stateid);\n\t\tnfs_mark_delegation_referenced(delegation);\n\t\tif (cred)\n\t\t\t*cred = get_cred(delegation->cred);\n\t}\n\tspin_unlock(&delegation->lock);\nout:\n\trcu_read_unlock();\n\treturn ret;\n}\n\n \nbool nfs4_delegation_flush_on_close(const struct inode *inode)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs_delegation *delegation;\n\tbool ret = true;\n\n\trcu_read_lock();\n\tdelegation = rcu_dereference(nfsi->delegation);\n\tif (delegation == NULL || !(delegation->type & FMODE_WRITE))\n\t\tgoto out;\n\tif (atomic_long_read(&nfsi->nrequests) < delegation->pagemod_limit)\n\t\tret = false;\nout:\n\trcu_read_unlock();\n\treturn ret;\n}\n\nmodule_param_named(delegation_watermark, nfs_delegation_watermark, uint, 0644);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}