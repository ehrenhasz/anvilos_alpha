{
  "module_name": "cache_lib.c",
  "hash_id": "d12d4aee9aaef9499b4d1335e109c98a380809320d419ae5839ce4440513f892",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfs/cache_lib.c",
  "human_readable_source": "\n \n#include <linux/kmod.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/sunrpc/cache.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n\n#include \"cache_lib.h\"\n\n#define NFS_CACHE_UPCALL_PATHLEN 256\n#define NFS_CACHE_UPCALL_TIMEOUT 15\n\nstatic char nfs_cache_getent_prog[NFS_CACHE_UPCALL_PATHLEN] =\n\t\t\t\t\"/sbin/nfs_cache_getent\";\nstatic unsigned long nfs_cache_getent_timeout = NFS_CACHE_UPCALL_TIMEOUT;\n\nmodule_param_string(cache_getent, nfs_cache_getent_prog,\n\t\tsizeof(nfs_cache_getent_prog), 0600);\nMODULE_PARM_DESC(cache_getent, \"Path to the client cache upcall program\");\nmodule_param_named(cache_getent_timeout, nfs_cache_getent_timeout, ulong, 0600);\nMODULE_PARM_DESC(cache_getent_timeout, \"Timeout (in seconds) after which \"\n\t\t\"the cache upcall is assumed to have failed\");\n\nint nfs_cache_upcall(struct cache_detail *cd, char *entry_name)\n{\n\tstatic char *envp[] = { \"HOME=/\",\n\t\t\"TERM=linux\",\n\t\t\"PATH=/sbin:/usr/sbin:/bin:/usr/bin\",\n\t\tNULL\n\t};\n\tchar *argv[] = {\n\t\tnfs_cache_getent_prog,\n\t\tcd->name,\n\t\tentry_name,\n\t\tNULL\n\t};\n\tint ret = -EACCES;\n\n\tif (nfs_cache_getent_prog[0] == '\\0')\n\t\tgoto out;\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_EXEC);\n\t \n\tif (ret == -ENOENT || ret == -EACCES)\n\t\tnfs_cache_getent_prog[0] = '\\0';\nout:\n\treturn ret > 0 ? 0 : ret;\n}\n\n \nvoid nfs_cache_defer_req_put(struct nfs_cache_defer_req *dreq)\n{\n\tif (refcount_dec_and_test(&dreq->count))\n\t\tkfree(dreq);\n}\n\nstatic void nfs_dns_cache_revisit(struct cache_deferred_req *d, int toomany)\n{\n\tstruct nfs_cache_defer_req *dreq;\n\n\tdreq = container_of(d, struct nfs_cache_defer_req, deferred_req);\n\n\tcomplete(&dreq->completion);\n\tnfs_cache_defer_req_put(dreq);\n}\n\nstatic struct cache_deferred_req *nfs_dns_cache_defer(struct cache_req *req)\n{\n\tstruct nfs_cache_defer_req *dreq;\n\n\tdreq = container_of(req, struct nfs_cache_defer_req, req);\n\tdreq->deferred_req.revisit = nfs_dns_cache_revisit;\n\trefcount_inc(&dreq->count);\n\n\treturn &dreq->deferred_req;\n}\n\nstruct nfs_cache_defer_req *nfs_cache_defer_req_alloc(void)\n{\n\tstruct nfs_cache_defer_req *dreq;\n\n\tdreq = kzalloc(sizeof(*dreq), GFP_KERNEL);\n\tif (dreq) {\n\t\tinit_completion(&dreq->completion);\n\t\trefcount_set(&dreq->count, 1);\n\t\tdreq->req.defer = nfs_dns_cache_defer;\n\t}\n\treturn dreq;\n}\n\nint nfs_cache_wait_for_upcall(struct nfs_cache_defer_req *dreq)\n{\n\tif (wait_for_completion_timeout(&dreq->completion,\n\t\t\tnfs_cache_getent_timeout * HZ) == 0)\n\t\treturn -ETIMEDOUT;\n\treturn 0;\n}\n\nint nfs_cache_register_sb(struct super_block *sb, struct cache_detail *cd)\n{\n\tint ret;\n\tstruct dentry *dir;\n\n\tdir = rpc_d_lookup_sb(sb, \"cache\");\n\tret = sunrpc_cache_register_pipefs(dir, cd->name, 0600, cd);\n\tdput(dir);\n\treturn ret;\n}\n\nint nfs_cache_register_net(struct net *net, struct cache_detail *cd)\n{\n\tstruct super_block *pipefs_sb;\n\tint ret = 0;\n\n\tsunrpc_init_cache_detail(cd);\n\tpipefs_sb = rpc_get_sb_net(net);\n\tif (pipefs_sb) {\n\t\tret = nfs_cache_register_sb(pipefs_sb, cd);\n\t\trpc_put_sb_net(net);\n\t\tif (ret)\n\t\t\tsunrpc_destroy_cache_detail(cd);\n\t}\n\treturn ret;\n}\n\nvoid nfs_cache_unregister_sb(struct super_block *sb, struct cache_detail *cd)\n{\n\tsunrpc_cache_unregister_pipefs(cd);\n}\n\nvoid nfs_cache_unregister_net(struct net *net, struct cache_detail *cd)\n{\n\tstruct super_block *pipefs_sb;\n\n\tpipefs_sb = rpc_get_sb_net(net);\n\tif (pipefs_sb) {\n\t\tnfs_cache_unregister_sb(pipefs_sb, cd);\n\t\trpc_put_sb_net(net);\n\t}\n\tsunrpc_destroy_cache_detail(cd);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}