{
  "module_name": "export.c",
  "hash_id": "dce2e18c28b0a54147efdef10fc23dc83da0dee488144242fa1603b436c79f27",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfs/export.c",
  "human_readable_source": "\n \n#include <linux/dcache.h>\n#include <linux/exportfs.h>\n#include <linux/nfs.h>\n#include <linux/nfs_fs.h>\n\n#include \"internal.h\"\n#include \"nfstrace.h\"\n\n#define NFSDBG_FACILITY\t\tNFSDBG_VFS\n\nenum {\n\tFILEID_HIGH_OFF = 0,\t \n\tFILEID_LOW_OFF,\t\t \n\tFILE_I_TYPE_OFF,\t \n\tEMBED_FH_OFF\t\t \n};\n\n\nstatic struct nfs_fh *nfs_exp_embedfh(__u32 *p)\n{\n\treturn (struct nfs_fh *)(p + EMBED_FH_OFF);\n}\n\n \nstatic int\nnfs_encode_fh(struct inode *inode, __u32 *p, int *max_len, struct inode *parent)\n{\n\tstruct nfs_fh *server_fh = NFS_FH(inode);\n\tstruct nfs_fh *clnt_fh = nfs_exp_embedfh(p);\n\tsize_t fh_size = offsetof(struct nfs_fh, data) + server_fh->size;\n\tint len = EMBED_FH_OFF + XDR_QUADLEN(fh_size);\n\n\tdprintk(\"%s: max fh len %d inode %p parent %p\",\n\t\t__func__, *max_len, inode, parent);\n\n\tif (*max_len < len) {\n\t\tdprintk(\"%s: fh len %d too small, required %d\\n\",\n\t\t\t__func__, *max_len, len);\n\t\t*max_len = len;\n\t\treturn FILEID_INVALID;\n\t}\n\n\tp[FILEID_HIGH_OFF] = NFS_FILEID(inode) >> 32;\n\tp[FILEID_LOW_OFF] = NFS_FILEID(inode);\n\tp[FILE_I_TYPE_OFF] = inode->i_mode & S_IFMT;\n\tp[len - 1] = 0;  \n\tnfs_copy_fh(clnt_fh, server_fh);\n\t*max_len = len;\n\tdprintk(\"%s: result fh fileid %llu mode %u size %d\\n\",\n\t\t__func__, NFS_FILEID(inode), inode->i_mode, *max_len);\n\treturn *max_len;\n}\n\nstatic struct dentry *\nnfs_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\t int fh_len, int fh_type)\n{\n\tstruct nfs_fattr *fattr = NULL;\n\tstruct nfs_fh *server_fh = nfs_exp_embedfh(fid->raw);\n\tsize_t fh_size = offsetof(struct nfs_fh, data) + server_fh->size;\n\tconst struct nfs_rpc_ops *rpc_ops;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tint len = EMBED_FH_OFF + XDR_QUADLEN(fh_size);\n\tu32 *p = fid->raw;\n\tint ret;\n\n\t \n\tif (fh_len < len || fh_type != len)\n\t\treturn NULL;\n\n\tfattr = nfs_alloc_fattr_with_label(NFS_SB(sb));\n\tif (fattr == NULL) {\n\t\tdentry = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\tfattr->fileid = ((u64)p[FILEID_HIGH_OFF] << 32) + p[FILEID_LOW_OFF];\n\tfattr->mode = p[FILE_I_TYPE_OFF];\n\tfattr->valid |= NFS_ATTR_FATTR_FILEID | NFS_ATTR_FATTR_TYPE;\n\n\tdprintk(\"%s: fileid %llu mode %d\\n\", __func__, fattr->fileid, fattr->mode);\n\n\tinode = nfs_ilookup(sb, fattr, server_fh);\n\tif (inode)\n\t\tgoto out_found;\n\n\trpc_ops = NFS_SB(sb)->nfs_client->rpc_ops;\n\tret = rpc_ops->getattr(NFS_SB(sb), server_fh, fattr, NULL);\n\tif (ret) {\n\t\tdprintk(\"%s: getattr failed %d\\n\", __func__, ret);\n\t\ttrace_nfs_fh_to_dentry(sb, server_fh, fattr->fileid, ret);\n\t\tdentry = ERR_PTR(ret);\n\t\tgoto out_free_fattr;\n\t}\n\n\tinode = nfs_fhget(sb, server_fh, fattr);\n\nout_found:\n\tdentry = d_obtain_alias(inode);\nout_free_fattr:\n\tnfs_free_fattr(fattr);\nout:\n\treturn dentry;\n}\n\nstatic struct dentry *\nnfs_get_parent(struct dentry *dentry)\n{\n\tint ret;\n\tstruct inode *inode = d_inode(dentry), *pinode;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct nfs_server *server = NFS_SB(sb);\n\tstruct nfs_fattr *fattr = NULL;\n\tstruct dentry *parent;\n\tstruct nfs_rpc_ops const *ops = server->nfs_client->rpc_ops;\n\tstruct nfs_fh fh;\n\n\tif (!ops->lookupp)\n\t\treturn ERR_PTR(-EACCES);\n\n\tfattr = nfs_alloc_fattr_with_label(server);\n\tif (fattr == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = ops->lookupp(inode, &fh, fattr);\n\tif (ret) {\n\t\tparent = ERR_PTR(ret);\n\t\tgoto out;\n\t}\n\n\tpinode = nfs_fhget(sb, &fh, fattr);\n\tparent = d_obtain_alias(pinode);\nout:\n\tnfs_free_fattr(fattr);\n\treturn parent;\n}\n\nconst struct export_operations nfs_export_ops = {\n\t.encode_fh = nfs_encode_fh,\n\t.fh_to_dentry = nfs_fh_to_dentry,\n\t.get_parent = nfs_get_parent,\n\t.flags = EXPORT_OP_NOWCC\t\t|\n\t\t EXPORT_OP_NOSUBTREECHK\t\t|\n\t\t EXPORT_OP_CLOSE_BEFORE_UNLINK\t|\n\t\t EXPORT_OP_REMOTE_FS\t\t|\n\t\t EXPORT_OP_NOATOMIC_ATTR\t|\n\t\t EXPORT_OP_FLUSH_ON_CLOSE,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}