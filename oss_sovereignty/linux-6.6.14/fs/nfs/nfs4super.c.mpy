{
  "module_name": "nfs4super.c",
  "hash_id": "68bcfcd0e510a36109abedde6775bf2b6a7fa37029a3c07b8a36635115c16723",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfs/nfs4super.c",
  "human_readable_source": "\n \n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_ssc.h>\n#include \"delegation.h\"\n#include \"internal.h\"\n#include \"nfs4_fs.h\"\n#include \"nfs4idmap.h\"\n#include \"dns_resolve.h\"\n#include \"pnfs.h\"\n#include \"nfs.h\"\n\n#define NFSDBG_FACILITY\t\tNFSDBG_VFS\n\nstatic int nfs4_write_inode(struct inode *inode, struct writeback_control *wbc);\nstatic void nfs4_evict_inode(struct inode *inode);\n\nstatic const struct super_operations nfs4_sops = {\n\t.alloc_inode\t= nfs_alloc_inode,\n\t.free_inode\t= nfs_free_inode,\n\t.write_inode\t= nfs4_write_inode,\n\t.drop_inode\t= nfs_drop_inode,\n\t.statfs\t\t= nfs_statfs,\n\t.evict_inode\t= nfs4_evict_inode,\n\t.umount_begin\t= nfs_umount_begin,\n\t.show_options\t= nfs_show_options,\n\t.show_devname\t= nfs_show_devname,\n\t.show_path\t= nfs_show_path,\n\t.show_stats\t= nfs_show_stats,\n};\n\nstruct nfs_subversion nfs_v4 = {\n\t.owner\t\t= THIS_MODULE,\n\t.nfs_fs\t\t= &nfs4_fs_type,\n\t.rpc_vers\t= &nfs_version4,\n\t.rpc_ops\t= &nfs_v4_clientops,\n\t.sops\t\t= &nfs4_sops,\n\t.xattr\t\t= nfs4_xattr_handlers,\n};\n\nstatic int nfs4_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tint ret = nfs_write_inode(inode, wbc);\n\n\tif (ret == 0)\n\t\tret = pnfs_layoutcommit_inode(inode,\n\t\t\t\twbc->sync_mode == WB_SYNC_ALL);\n\treturn ret;\n}\n\n \nstatic void nfs4_evict_inode(struct inode *inode)\n{\n\ttruncate_inode_pages_final(&inode->i_data);\n\tclear_inode(inode);\n\t \n\tnfs_inode_evict_delegation(inode);\n\t \n\tpnfs_return_layout(inode);\n\tpnfs_destroy_layout_final(NFS_I(inode));\n\t \n\tnfs_clear_inode(inode);\n\tnfs4_xattr_cache_zap(inode);\n}\n\nstruct nfs_referral_count {\n\tstruct list_head list;\n\tconst struct task_struct *task;\n\tunsigned int referral_count;\n};\n\nstatic LIST_HEAD(nfs_referral_count_list);\nstatic DEFINE_SPINLOCK(nfs_referral_count_list_lock);\n\nstatic struct nfs_referral_count *nfs_find_referral_count(void)\n{\n\tstruct nfs_referral_count *p;\n\n\tlist_for_each_entry(p, &nfs_referral_count_list, list) {\n\t\tif (p->task == current)\n\t\t\treturn p;\n\t}\n\treturn NULL;\n}\n\n#define NFS_MAX_NESTED_REFERRALS 2\n\nstatic int nfs_referral_loop_protect(void)\n{\n\tstruct nfs_referral_count *p, *new;\n\tint ret = -ENOMEM;\n\n\tnew = kmalloc(sizeof(*new), GFP_KERNEL);\n\tif (!new)\n\t\tgoto out;\n\tnew->task = current;\n\tnew->referral_count = 1;\n\n\tret = 0;\n\tspin_lock(&nfs_referral_count_list_lock);\n\tp = nfs_find_referral_count();\n\tif (p != NULL) {\n\t\tif (p->referral_count >= NFS_MAX_NESTED_REFERRALS)\n\t\t\tret = -ELOOP;\n\t\telse\n\t\t\tp->referral_count++;\n\t} else {\n\t\tlist_add(&new->list, &nfs_referral_count_list);\n\t\tnew = NULL;\n\t}\n\tspin_unlock(&nfs_referral_count_list_lock);\n\tkfree(new);\nout:\n\treturn ret;\n}\n\nstatic void nfs_referral_loop_unprotect(void)\n{\n\tstruct nfs_referral_count *p;\n\n\tspin_lock(&nfs_referral_count_list_lock);\n\tp = nfs_find_referral_count();\n\tp->referral_count--;\n\tif (p->referral_count == 0)\n\t\tlist_del(&p->list);\n\telse\n\t\tp = NULL;\n\tspin_unlock(&nfs_referral_count_list_lock);\n\tkfree(p);\n}\n\nstatic int do_nfs4_mount(struct nfs_server *server,\n\t\t\t struct fs_context *fc,\n\t\t\t const char *hostname,\n\t\t\t const char *export_path)\n{\n\tstruct nfs_fs_context *root_ctx;\n\tstruct fs_context *root_fc;\n\tstruct vfsmount *root_mnt;\n\tstruct dentry *dentry;\n\tsize_t len;\n\tint ret;\n\n\tstruct fs_parameter param = {\n\t\t.key\t= \"source\",\n\t\t.type\t= fs_value_is_string,\n\t\t.dirfd\t= -1,\n\t};\n\n\tif (IS_ERR(server))\n\t\treturn PTR_ERR(server);\n\n\troot_fc = vfs_dup_fs_context(fc);\n\tif (IS_ERR(root_fc)) {\n\t\tnfs_free_server(server);\n\t\treturn PTR_ERR(root_fc);\n\t}\n\tkfree(root_fc->source);\n\troot_fc->source = NULL;\n\n\troot_ctx = nfs_fc2context(root_fc);\n\troot_ctx->internal = true;\n\troot_ctx->server = server;\n\t \n\n\tlen = strlen(hostname) + 5;\n\tparam.string = kmalloc(len, GFP_KERNEL);\n\tif (param.string == NULL) {\n\t\tput_fs_context(root_fc);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tif (strchr(hostname, ':'))\n\t\tparam.size = snprintf(param.string, len, \"[%s]:/\", hostname);\n\telse\n\t\tparam.size = snprintf(param.string, len, \"%s:/\", hostname);\n\tret = vfs_parse_fs_param(root_fc, &param);\n\tkfree(param.string);\n\tif (ret < 0) {\n\t\tput_fs_context(root_fc);\n\t\treturn ret;\n\t}\n\troot_mnt = fc_mount(root_fc);\n\tput_fs_context(root_fc);\n\n\tif (IS_ERR(root_mnt))\n\t\treturn PTR_ERR(root_mnt);\n\n\tret = nfs_referral_loop_protect();\n\tif (ret) {\n\t\tmntput(root_mnt);\n\t\treturn ret;\n\t}\n\n\tdentry = mount_subtree(root_mnt, export_path);\n\tnfs_referral_loop_unprotect();\n\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\tfc->root = dentry;\n\treturn 0;\n}\n\nint nfs4_try_get_tree(struct fs_context *fc)\n{\n\tstruct nfs_fs_context *ctx = nfs_fc2context(fc);\n\tint err;\n\n\tdfprintk(MOUNT, \"--> nfs4_try_get_tree()\\n\");\n\n\t \n\terr= do_nfs4_mount(nfs4_create_server(fc),\n\t\t\t   fc, ctx->nfs_server.hostname,\n\t\t\t   ctx->nfs_server.export_path);\n\tif (err) {\n\t\tnfs_ferrorf(fc, MOUNT, \"NFS4: Couldn't follow remote path\");\n\t\tdfprintk(MOUNT, \"<-- nfs4_try_get_tree() = %d [error]\\n\", err);\n\t} else {\n\t\tdfprintk(MOUNT, \"<-- nfs4_try_get_tree() = 0\\n\");\n\t}\n\treturn err;\n}\n\n \nint nfs4_get_referral_tree(struct fs_context *fc)\n{\n\tstruct nfs_fs_context *ctx = nfs_fc2context(fc);\n\tint err;\n\n\tdprintk(\"--> nfs4_referral_mount()\\n\");\n\n\t \n\terr = do_nfs4_mount(nfs4_create_referral_server(fc),\n\t\t\t    fc, ctx->nfs_server.hostname,\n\t\t\t    ctx->nfs_server.export_path);\n\tif (err) {\n\t\tnfs_ferrorf(fc, MOUNT, \"NFS4: Couldn't follow remote path\");\n\t\tdfprintk(MOUNT, \"<-- nfs4_get_referral_tree() = %d [error]\\n\", err);\n\t} else {\n\t\tdfprintk(MOUNT, \"<-- nfs4_get_referral_tree() = 0\\n\");\n\t}\n\treturn err;\n}\n\nstatic int __init init_nfs_v4(void)\n{\n\tint err;\n\n\terr = nfs_dns_resolver_init();\n\tif (err)\n\t\tgoto out;\n\n\terr = nfs_idmap_init();\n\tif (err)\n\t\tgoto out1;\n\n#ifdef CONFIG_NFS_V4_2\n\terr = nfs4_xattr_cache_init();\n\tif (err)\n\t\tgoto out2;\n#endif\n\n\terr = nfs4_register_sysctl();\n\tif (err)\n\t\tgoto out2;\n\n#ifdef CONFIG_NFS_V4_2\n\tnfs42_ssc_register_ops();\n#endif\n\tregister_nfs_version(&nfs_v4);\n\treturn 0;\nout2:\n\tnfs_idmap_quit();\nout1:\n\tnfs_dns_resolver_destroy();\nout:\n\treturn err;\n}\n\nstatic void __exit exit_nfs_v4(void)\n{\n\t \n\tnfs4_pnfs_v3_ds_connect_unload();\n\n\tunregister_nfs_version(&nfs_v4);\n#ifdef CONFIG_NFS_V4_2\n\tnfs4_xattr_cache_exit();\n\tnfs42_ssc_unregister_ops();\n#endif\n\tnfs4_unregister_sysctl();\n\tnfs_idmap_quit();\n\tnfs_dns_resolver_destroy();\n}\n\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(init_nfs_v4);\nmodule_exit(exit_nfs_v4);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}