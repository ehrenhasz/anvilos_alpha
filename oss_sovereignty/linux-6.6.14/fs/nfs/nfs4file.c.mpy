{
  "module_name": "nfs4file.c",
  "hash_id": "24320b7730845eec7534aaf110db7549174b1eef191214da0fa6fc3c50a7278a",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfs/nfs4file.c",
  "human_readable_source": "\n \n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/falloc.h>\n#include <linux/mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_ssc.h>\n#include \"delegation.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"fscache.h\"\n#include \"pnfs.h\"\n\n#include \"nfstrace.h\"\n\n#ifdef CONFIG_NFS_V4_2\n#include \"nfs42.h\"\n#endif\n\n#define NFSDBG_FACILITY\t\tNFSDBG_FILE\n\nstatic int\nnfs4_file_open(struct inode *inode, struct file *filp)\n{\n\tstruct nfs_open_context *ctx;\n\tstruct dentry *dentry = file_dentry(filp);\n\tstruct dentry *parent = NULL;\n\tstruct inode *dir;\n\tunsigned openflags = filp->f_flags;\n\tstruct iattr attr;\n\tint err;\n\n\t \n\n\tdprintk(\"NFS: open file(%pd2)\\n\", dentry);\n\n\terr = nfs_check_flags(openflags);\n\tif (err)\n\t\treturn err;\n\n\t \n\topenflags &= ~(O_CREAT|O_EXCL);\n\n\tparent = dget_parent(dentry);\n\tdir = d_inode(parent);\n\n\tctx = alloc_nfs_open_context(file_dentry(filp),\n\t\t\t\t     flags_to_mode(openflags), filp);\n\terr = PTR_ERR(ctx);\n\tif (IS_ERR(ctx))\n\t\tgoto out;\n\n\tattr.ia_valid = ATTR_OPEN;\n\tif (openflags & O_TRUNC) {\n\t\tattr.ia_valid |= ATTR_SIZE;\n\t\tattr.ia_size = 0;\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\t}\n\n\tinode = NFS_PROTO(dir)->open_context(dir, ctx, openflags, &attr, NULL);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tswitch (err) {\n\t\tdefault:\n\t\t\tgoto out_put_ctx;\n\t\tcase -ENOENT:\n\t\tcase -ESTALE:\n\t\tcase -EISDIR:\n\t\tcase -ENOTDIR:\n\t\tcase -ELOOP:\n\t\t\tgoto out_drop;\n\t\t}\n\t}\n\tif (inode != d_inode(dentry))\n\t\tgoto out_drop;\n\n\tnfs_file_set_open_context(filp, ctx);\n\tnfs_fscache_open_file(inode, filp);\n\terr = 0;\n\tfilp->f_mode |= FMODE_CAN_ODIRECT;\n\nout_put_ctx:\n\tput_nfs_open_context(ctx);\nout:\n\tdput(parent);\n\treturn err;\n\nout_drop:\n\td_drop(dentry);\n\terr = -EOPENSTALE;\n\tgoto out_put_ctx;\n}\n\n \nstatic int\nnfs4_file_flush(struct file *file, fl_owner_t id)\n{\n\tstruct inode\t*inode = file_inode(file);\n\terrseq_t since;\n\n\tdprintk(\"NFS: flush(%pD2)\\n\", file);\n\n\tnfs_inc_stats(inode, NFSIOS_VFSFLUSH);\n\tif ((file->f_mode & FMODE_WRITE) == 0)\n\t\treturn 0;\n\n\t \n\tif (!nfs4_delegation_flush_on_close(inode))\n\t\treturn filemap_fdatawrite(file->f_mapping);\n\n\t \n\tsince = filemap_sample_wb_err(file->f_mapping);\n\tnfs_wb_all(inode);\n\treturn filemap_check_wb_err(file->f_mapping, since);\n}\n\n#ifdef CONFIG_NFS_V4_2\nstatic ssize_t __nfs4_copy_file_range(struct file *file_in, loff_t pos_in,\n\t\t\t\t      struct file *file_out, loff_t pos_out,\n\t\t\t\t      size_t count, unsigned int flags)\n{\n\tstruct nfs42_copy_notify_res *cn_resp = NULL;\n\tstruct nl4_server *nss = NULL;\n\tnfs4_stateid *cnrs = NULL;\n\tssize_t ret;\n\tbool sync = false;\n\n\t \n\tif (file_in->f_op != &nfs4_file_operations)\n\t\treturn -EXDEV;\n\tif (!nfs_server_capable(file_inode(file_out), NFS_CAP_COPY) ||\n\t    !nfs_server_capable(file_inode(file_in), NFS_CAP_COPY))\n\t\treturn -EOPNOTSUPP;\n\tif (file_inode(file_in) == file_inode(file_out))\n\t\treturn -EOPNOTSUPP;\n\t \n\tif (count <= 2 * NFS_SERVER(file_inode(file_in))->rsize)\n\t\tsync = true;\nretry:\n\tif (!nfs42_files_from_same_server(file_in, file_out)) {\n\t\t \n\t\tif (sync)\n\t\t\treturn -EOPNOTSUPP;\n\t\tcn_resp = kzalloc(sizeof(struct nfs42_copy_notify_res),\n\t\t\t\t  GFP_KERNEL);\n\t\tif (unlikely(cn_resp == NULL))\n\t\t\treturn -ENOMEM;\n\n\t\tret = nfs42_proc_copy_notify(file_in, file_out, cn_resp);\n\t\tif (ret) {\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\t\tnss = &cn_resp->cnr_src;\n\t\tcnrs = &cn_resp->cnr_stateid;\n\t}\n\tret = nfs42_proc_copy(file_in, pos_in, file_out, pos_out, count,\n\t\t\t\tnss, cnrs, sync);\nout:\n\tkfree(cn_resp);\n\n\tif (ret == -EAGAIN)\n\t\tgoto retry;\n\treturn ret;\n}\n\nstatic ssize_t nfs4_copy_file_range(struct file *file_in, loff_t pos_in,\n\t\t\t\t    struct file *file_out, loff_t pos_out,\n\t\t\t\t    size_t count, unsigned int flags)\n{\n\tssize_t ret;\n\n\tret = __nfs4_copy_file_range(file_in, pos_in, file_out, pos_out, count,\n\t\t\t\t     flags);\n\tif (ret == -EOPNOTSUPP || ret == -EXDEV)\n\t\tret = generic_copy_file_range(file_in, pos_in, file_out,\n\t\t\t\t\t      pos_out, count, flags);\n\treturn ret;\n}\n\nstatic loff_t nfs4_file_llseek(struct file *filep, loff_t offset, int whence)\n{\n\tloff_t ret;\n\n\tswitch (whence) {\n\tcase SEEK_HOLE:\n\tcase SEEK_DATA:\n\t\tret = nfs42_proc_llseek(filep, offset, whence);\n\t\tif (ret != -EOPNOTSUPP)\n\t\t\treturn ret;\n\t\tfallthrough;\n\tdefault:\n\t\treturn nfs_file_llseek(filep, offset, whence);\n\t}\n}\n\nstatic long nfs42_fallocate(struct file *filep, int mode, loff_t offset, loff_t len)\n{\n\tstruct inode *inode = file_inode(filep);\n\tlong ret;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\n\tif ((mode != 0) && (mode != (FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE)))\n\t\treturn -EOPNOTSUPP;\n\n\tret = inode_newsize_ok(inode, offset + len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (mode & FALLOC_FL_PUNCH_HOLE)\n\t\treturn nfs42_proc_deallocate(filep, offset, len);\n\treturn nfs42_proc_allocate(filep, offset, len);\n}\n\nstatic loff_t nfs42_remap_file_range(struct file *src_file, loff_t src_off,\n\t\tstruct file *dst_file, loff_t dst_off, loff_t count,\n\t\tunsigned int remap_flags)\n{\n\tstruct inode *dst_inode = file_inode(dst_file);\n\tstruct nfs_server *server = NFS_SERVER(dst_inode);\n\tstruct inode *src_inode = file_inode(src_file);\n\tunsigned int bs = server->clone_blksize;\n\tbool same_inode = false;\n\tint ret;\n\n\t \n\tif (remap_flags & REMAP_FILE_DEDUP)\n\t\treturn -EOPNOTSUPP;\n\n\tif (remap_flags & ~REMAP_FILE_ADVISORY)\n\t\treturn -EINVAL;\n\n\tif (IS_SWAPFILE(dst_inode) || IS_SWAPFILE(src_inode))\n\t\treturn -ETXTBSY;\n\n\t \n\tret = -EINVAL;\n\tif (bs) {\n\t\tif (!IS_ALIGNED(src_off, bs) || !IS_ALIGNED(dst_off, bs))\n\t\t\tgoto out;\n\t\tif (!IS_ALIGNED(count, bs) && i_size_read(src_inode) != (src_off + count))\n\t\t\tgoto out;\n\t}\n\n\tif (src_inode == dst_inode)\n\t\tsame_inode = true;\n\n\t \n\tif (same_inode) {\n\t\tinode_lock(src_inode);\n\t} else if (dst_inode < src_inode) {\n\t\tinode_lock_nested(dst_inode, I_MUTEX_PARENT);\n\t\tinode_lock_nested(src_inode, I_MUTEX_CHILD);\n\t} else {\n\t\tinode_lock_nested(src_inode, I_MUTEX_PARENT);\n\t\tinode_lock_nested(dst_inode, I_MUTEX_CHILD);\n\t}\n\n\t \n\tret = nfs_sync_inode(src_inode);\n\tif (ret)\n\t\tgoto out_unlock;\n\tret = nfs_sync_inode(dst_inode);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = nfs42_proc_clone(src_file, dst_file, src_off, dst_off, count);\n\n\t \n\tif (!ret)\n\t\ttruncate_inode_pages_range(&dst_inode->i_data, dst_off, dst_off + count - 1);\n\nout_unlock:\n\tif (same_inode) {\n\t\tinode_unlock(src_inode);\n\t} else if (dst_inode < src_inode) {\n\t\tinode_unlock(src_inode);\n\t\tinode_unlock(dst_inode);\n\t} else {\n\t\tinode_unlock(dst_inode);\n\t\tinode_unlock(src_inode);\n\t}\nout:\n\treturn ret < 0 ? ret : count;\n}\n\nstatic int read_name_gen = 1;\n#define SSC_READ_NAME_BODY \"ssc_read_%d\"\n\nstatic struct file *__nfs42_ssc_open(struct vfsmount *ss_mnt,\n\t\tstruct nfs_fh *src_fh, nfs4_stateid *stateid)\n{\n\tstruct nfs_fattr *fattr = nfs_alloc_fattr();\n\tstruct file *filep, *res;\n\tstruct nfs_server *server;\n\tstruct inode *r_ino = NULL;\n\tstruct nfs_open_context *ctx;\n\tstruct nfs4_state_owner *sp;\n\tchar *read_name = NULL;\n\tint len, status = 0;\n\n\tserver = NFS_SB(ss_mnt->mnt_sb);\n\n\tif (!fattr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstatus = nfs4_proc_getattr(server, src_fh, fattr, NULL);\n\tif (status < 0) {\n\t\tres = ERR_PTR(status);\n\t\tgoto out;\n\t}\n\n\tif (!S_ISREG(fattr->mode)) {\n\t\tres = ERR_PTR(-EBADF);\n\t\tgoto out;\n\t}\n\n\tres = ERR_PTR(-ENOMEM);\n\tlen = strlen(SSC_READ_NAME_BODY) + 16;\n\tread_name = kzalloc(len, GFP_KERNEL);\n\tif (read_name == NULL)\n\t\tgoto out;\n\tsnprintf(read_name, len, SSC_READ_NAME_BODY, read_name_gen++);\n\n\tr_ino = nfs_fhget(ss_mnt->mnt_sb, src_fh, fattr);\n\tif (IS_ERR(r_ino)) {\n\t\tres = ERR_CAST(r_ino);\n\t\tgoto out_free_name;\n\t}\n\n\tfilep = alloc_file_pseudo(r_ino, ss_mnt, read_name, O_RDONLY,\n\t\t\t\t     r_ino->i_fop);\n\tif (IS_ERR(filep)) {\n\t\tres = ERR_CAST(filep);\n\t\tiput(r_ino);\n\t\tgoto out_free_name;\n\t}\n\n\tctx = alloc_nfs_open_context(filep->f_path.dentry,\n\t\t\t\t     flags_to_mode(filep->f_flags), filep);\n\tif (IS_ERR(ctx)) {\n\t\tres = ERR_CAST(ctx);\n\t\tgoto out_filep;\n\t}\n\n\tres = ERR_PTR(-EINVAL);\n\tsp = nfs4_get_state_owner(server, ctx->cred, GFP_KERNEL);\n\tif (sp == NULL)\n\t\tgoto out_ctx;\n\n\tctx->state = nfs4_get_open_state(r_ino, sp);\n\tif (ctx->state == NULL)\n\t\tgoto out_stateowner;\n\n\tset_bit(NFS_SRV_SSC_COPY_STATE, &ctx->state->flags);\n\tmemcpy(&ctx->state->open_stateid.other, &stateid->other,\n\t       NFS4_STATEID_OTHER_SIZE);\n\tupdate_open_stateid(ctx->state, stateid, NULL, filep->f_mode);\n\tset_bit(NFS_OPEN_STATE, &ctx->state->flags);\n\n\tnfs_file_set_open_context(filep, ctx);\n\tput_nfs_open_context(ctx);\n\n\tfile_ra_state_init(&filep->f_ra, filep->f_mapping->host->i_mapping);\n\tres = filep;\nout_free_name:\n\tkfree(read_name);\nout:\n\tnfs_free_fattr(fattr);\n\treturn res;\nout_stateowner:\n\tnfs4_put_state_owner(sp);\nout_ctx:\n\tput_nfs_open_context(ctx);\nout_filep:\n\tfput(filep);\n\tgoto out_free_name;\n}\n\nstatic void __nfs42_ssc_close(struct file *filep)\n{\n\tstruct nfs_open_context *ctx = nfs_file_open_context(filep);\n\n\tctx->state->flags = 0;\n}\n\nstatic const struct nfs4_ssc_client_ops nfs4_ssc_clnt_ops_tbl = {\n\t.sco_open = __nfs42_ssc_open,\n\t.sco_close = __nfs42_ssc_close,\n};\n\n \nvoid nfs42_ssc_register_ops(void)\n{\n\tnfs42_ssc_register(&nfs4_ssc_clnt_ops_tbl);\n}\n\n \nvoid nfs42_ssc_unregister_ops(void)\n{\n\tnfs42_ssc_unregister(&nfs4_ssc_clnt_ops_tbl);\n}\n#endif  \n\nstatic int nfs4_setlease(struct file *file, int arg, struct file_lock **lease,\n\t\t\t void **priv)\n{\n\treturn nfs4_proc_setlease(file, arg, lease, priv);\n}\n\nconst struct file_operations nfs4_file_operations = {\n\t.read_iter\t= nfs_file_read,\n\t.write_iter\t= nfs_file_write,\n\t.mmap\t\t= nfs_file_mmap,\n\t.open\t\t= nfs4_file_open,\n\t.flush\t\t= nfs4_file_flush,\n\t.release\t= nfs_file_release,\n\t.fsync\t\t= nfs_file_fsync,\n\t.lock\t\t= nfs_lock,\n\t.flock\t\t= nfs_flock,\n\t.splice_read\t= nfs_file_splice_read,\n\t.splice_write\t= iter_file_splice_write,\n\t.check_flags\t= nfs_check_flags,\n\t.setlease\t= nfs4_setlease,\n#ifdef CONFIG_NFS_V4_2\n\t.copy_file_range = nfs4_copy_file_range,\n\t.llseek\t\t= nfs4_file_llseek,\n\t.fallocate\t= nfs42_fallocate,\n\t.remap_file_range = nfs42_remap_file_range,\n#else\n\t.llseek\t\t= nfs_file_llseek,\n#endif\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}