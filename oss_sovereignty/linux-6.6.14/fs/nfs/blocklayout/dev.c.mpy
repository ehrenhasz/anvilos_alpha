{
  "module_name": "dev.c",
  "hash_id": "a8b8fcfa0e2ca781b28b83894f1a947c788d5f51a7f5b88cef9e4d43bfe722f1",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfs/blocklayout/dev.c",
  "human_readable_source": "\n \n#include <linux/sunrpc/svc.h>\n#include <linux/blkdev.h>\n#include <linux/nfs4.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_xdr.h>\n#include <linux/pr.h>\n\n#include \"blocklayout.h\"\n\n#define NFSDBG_FACILITY\t\tNFSDBG_PNFS_LD\n\nstatic void\nbl_free_device(struct pnfs_block_dev *dev)\n{\n\tif (dev->nr_children) {\n\t\tint i;\n\n\t\tfor (i = 0; i < dev->nr_children; i++)\n\t\t\tbl_free_device(&dev->children[i]);\n\t\tkfree(dev->children);\n\t} else {\n\t\tif (dev->pr_registered) {\n\t\t\tconst struct pr_ops *ops =\n\t\t\t\tdev->bdev->bd_disk->fops->pr_ops;\n\t\t\tint error;\n\n\t\t\terror = ops->pr_register(dev->bdev, dev->pr_key, 0,\n\t\t\t\tfalse);\n\t\t\tif (error)\n\t\t\t\tpr_err(\"failed to unregister PR key.\\n\");\n\t\t}\n\n\t\tif (dev->bdev)\n\t\t\tblkdev_put(dev->bdev, NULL);\n\t}\n}\n\nvoid\nbl_free_deviceid_node(struct nfs4_deviceid_node *d)\n{\n\tstruct pnfs_block_dev *dev =\n\t\tcontainer_of(d, struct pnfs_block_dev, node);\n\n\tbl_free_device(dev);\n\tkfree_rcu(dev, node.rcu);\n}\n\nstatic int\nnfs4_block_decode_volume(struct xdr_stream *xdr, struct pnfs_block_volume *b)\n{\n\t__be32 *p;\n\tint i;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (!p)\n\t\treturn -EIO;\n\tb->type = be32_to_cpup(p++);\n\n\tswitch (b->type) {\n\tcase PNFS_BLOCK_VOLUME_SIMPLE:\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (!p)\n\t\t\treturn -EIO;\n\t\tb->simple.nr_sigs = be32_to_cpup(p++);\n\t\tif (!b->simple.nr_sigs || b->simple.nr_sigs > PNFS_BLOCK_MAX_UUIDS) {\n\t\t\tdprintk(\"Bad signature count: %d\\n\", b->simple.nr_sigs);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tb->simple.len = 4 + 4;\n\t\tfor (i = 0; i < b->simple.nr_sigs; i++) {\n\t\t\tp = xdr_inline_decode(xdr, 8 + 4);\n\t\t\tif (!p)\n\t\t\t\treturn -EIO;\n\t\t\tp = xdr_decode_hyper(p, &b->simple.sigs[i].offset);\n\t\t\tb->simple.sigs[i].sig_len = be32_to_cpup(p++);\n\t\t\tif (b->simple.sigs[i].sig_len > PNFS_BLOCK_UUID_LEN) {\n\t\t\t\tpr_info(\"signature too long: %d\\n\",\n\t\t\t\t\tb->simple.sigs[i].sig_len);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\n\t\t\tp = xdr_inline_decode(xdr, b->simple.sigs[i].sig_len);\n\t\t\tif (!p)\n\t\t\t\treturn -EIO;\n\t\t\tmemcpy(&b->simple.sigs[i].sig, p,\n\t\t\t\tb->simple.sigs[i].sig_len);\n\n\t\t\tb->simple.len += 8 + 4 + \\\n\t\t\t\t(XDR_QUADLEN(b->simple.sigs[i].sig_len) << 2);\n\t\t}\n\t\tbreak;\n\tcase PNFS_BLOCK_VOLUME_SLICE:\n\t\tp = xdr_inline_decode(xdr, 8 + 8 + 4);\n\t\tif (!p)\n\t\t\treturn -EIO;\n\t\tp = xdr_decode_hyper(p, &b->slice.start);\n\t\tp = xdr_decode_hyper(p, &b->slice.len);\n\t\tb->slice.volume = be32_to_cpup(p++);\n\t\tbreak;\n\tcase PNFS_BLOCK_VOLUME_CONCAT:\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (!p)\n\t\t\treturn -EIO;\n\n\t\tb->concat.volumes_count = be32_to_cpup(p++);\n\t\tif (b->concat.volumes_count > PNFS_BLOCK_MAX_DEVICES) {\n\t\t\tdprintk(\"Too many volumes: %d\\n\", b->concat.volumes_count);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tp = xdr_inline_decode(xdr, b->concat.volumes_count * 4);\n\t\tif (!p)\n\t\t\treturn -EIO;\n\t\tfor (i = 0; i < b->concat.volumes_count; i++)\n\t\t\tb->concat.volumes[i] = be32_to_cpup(p++);\n\t\tbreak;\n\tcase PNFS_BLOCK_VOLUME_STRIPE:\n\t\tp = xdr_inline_decode(xdr, 8 + 4);\n\t\tif (!p)\n\t\t\treturn -EIO;\n\n\t\tp = xdr_decode_hyper(p, &b->stripe.chunk_size);\n\t\tb->stripe.volumes_count = be32_to_cpup(p++);\n\t\tif (b->stripe.volumes_count > PNFS_BLOCK_MAX_DEVICES) {\n\t\t\tdprintk(\"Too many volumes: %d\\n\", b->stripe.volumes_count);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tp = xdr_inline_decode(xdr, b->stripe.volumes_count * 4);\n\t\tif (!p)\n\t\t\treturn -EIO;\n\t\tfor (i = 0; i < b->stripe.volumes_count; i++)\n\t\t\tb->stripe.volumes[i] = be32_to_cpup(p++);\n\t\tbreak;\n\tcase PNFS_BLOCK_VOLUME_SCSI:\n\t\tp = xdr_inline_decode(xdr, 4 + 4 + 4);\n\t\tif (!p)\n\t\t\treturn -EIO;\n\t\tb->scsi.code_set = be32_to_cpup(p++);\n\t\tb->scsi.designator_type = be32_to_cpup(p++);\n\t\tb->scsi.designator_len = be32_to_cpup(p++);\n\t\tp = xdr_inline_decode(xdr, b->scsi.designator_len);\n\t\tif (!p)\n\t\t\treturn -EIO;\n\t\tif (b->scsi.designator_len > 256)\n\t\t\treturn -EIO;\n\t\tmemcpy(&b->scsi.designator, p, b->scsi.designator_len);\n\t\tp = xdr_inline_decode(xdr, 8);\n\t\tif (!p)\n\t\t\treturn -EIO;\n\t\tp = xdr_decode_hyper(p, &b->scsi.pr_key);\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"unknown volume type!\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic bool bl_map_simple(struct pnfs_block_dev *dev, u64 offset,\n\t\tstruct pnfs_block_dev_map *map)\n{\n\tmap->start = dev->start;\n\tmap->len = dev->len;\n\tmap->disk_offset = dev->disk_offset;\n\tmap->bdev = dev->bdev;\n\treturn true;\n}\n\nstatic bool bl_map_concat(struct pnfs_block_dev *dev, u64 offset,\n\t\tstruct pnfs_block_dev_map *map)\n{\n\tint i;\n\n\tfor (i = 0; i < dev->nr_children; i++) {\n\t\tstruct pnfs_block_dev *child = &dev->children[i];\n\n\t\tif (child->start > offset ||\n\t\t    child->start + child->len <= offset)\n\t\t\tcontinue;\n\n\t\tchild->map(child, offset - child->start, map);\n\t\treturn true;\n\t}\n\n\tdprintk(\"%s: ran off loop!\\n\", __func__);\n\treturn false;\n}\n\nstatic bool bl_map_stripe(struct pnfs_block_dev *dev, u64 offset,\n\t\tstruct pnfs_block_dev_map *map)\n{\n\tstruct pnfs_block_dev *child;\n\tu64 chunk;\n\tu32 chunk_idx;\n\tu64 disk_offset;\n\n\tchunk = div_u64(offset, dev->chunk_size);\n\tdiv_u64_rem(chunk, dev->nr_children, &chunk_idx);\n\n\tif (chunk_idx >= dev->nr_children) {\n\t\tdprintk(\"%s: invalid chunk idx %d (%lld/%lld)\\n\",\n\t\t\t__func__, chunk_idx, offset, dev->chunk_size);\n\t\t \n\t\treturn false;\n\t}\n\n\t \n\toffset = chunk * dev->chunk_size;\n\n\t \n\tdisk_offset = div_u64(offset, dev->nr_children);\n\n\tchild = &dev->children[chunk_idx];\n\tchild->map(child, disk_offset, map);\n\n\tmap->start += offset;\n\tmap->disk_offset += disk_offset;\n\tmap->len = dev->chunk_size;\n\treturn true;\n}\n\nstatic int\nbl_parse_deviceid(struct nfs_server *server, struct pnfs_block_dev *d,\n\t\tstruct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask);\n\n\nstatic int\nbl_parse_simple(struct nfs_server *server, struct pnfs_block_dev *d,\n\t\tstruct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask)\n{\n\tstruct pnfs_block_volume *v = &volumes[idx];\n\tstruct block_device *bdev;\n\tdev_t dev;\n\n\tdev = bl_resolve_deviceid(server, v, gfp_mask);\n\tif (!dev)\n\t\treturn -EIO;\n\n\tbdev = blkdev_get_by_dev(dev, BLK_OPEN_READ | BLK_OPEN_WRITE, NULL,\n\t\t\t\t NULL);\n\tif (IS_ERR(bdev)) {\n\t\tprintk(KERN_WARNING \"pNFS: failed to open device %d:%d (%ld)\\n\",\n\t\t\tMAJOR(dev), MINOR(dev), PTR_ERR(bdev));\n\t\treturn PTR_ERR(bdev);\n\t}\n\td->bdev = bdev;\n\n\n\td->len = bdev_nr_bytes(d->bdev);\n\td->map = bl_map_simple;\n\n\tprintk(KERN_INFO \"pNFS: using block device %s\\n\",\n\t\td->bdev->bd_disk->disk_name);\n\treturn 0;\n}\n\nstatic bool\nbl_validate_designator(struct pnfs_block_volume *v)\n{\n\tswitch (v->scsi.designator_type) {\n\tcase PS_DESIGNATOR_EUI64:\n\t\tif (v->scsi.code_set != PS_CODE_SET_BINARY)\n\t\t\treturn false;\n\n\t\tif (v->scsi.designator_len != 8 &&\n\t\t    v->scsi.designator_len != 10 &&\n\t\t    v->scsi.designator_len != 16)\n\t\t\treturn false;\n\n\t\treturn true;\n\tcase PS_DESIGNATOR_NAA:\n\t\tif (v->scsi.code_set != PS_CODE_SET_BINARY)\n\t\t\treturn false;\n\n\t\tif (v->scsi.designator_len != 8 &&\n\t\t    v->scsi.designator_len != 16)\n\t\t\treturn false;\n\n\t\treturn true;\n\tcase PS_DESIGNATOR_T10:\n\tcase PS_DESIGNATOR_NAME:\n\t\tpr_err(\"pNFS: unsupported designator \"\n\t\t\t\"(code set %d, type %d, len %d.\\n\",\n\t\t\tv->scsi.code_set,\n\t\t\tv->scsi.designator_type,\n\t\t\tv->scsi.designator_len);\n\t\treturn false;\n\tdefault:\n\t\tpr_err(\"pNFS: invalid designator \"\n\t\t\t\"(code set %d, type %d, len %d.\\n\",\n\t\t\tv->scsi.code_set,\n\t\t\tv->scsi.designator_type,\n\t\t\tv->scsi.designator_len);\n\t\treturn false;\n\t}\n}\n\nstatic struct block_device *\nbl_open_path(struct pnfs_block_volume *v, const char *prefix)\n{\n\tstruct block_device *bdev;\n\tconst char *devname;\n\n\tdevname = kasprintf(GFP_KERNEL, \"/dev/disk/by-id/%s%*phN\",\n\t\t\tprefix, v->scsi.designator_len, v->scsi.designator);\n\tif (!devname)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tbdev = blkdev_get_by_path(devname, BLK_OPEN_READ | BLK_OPEN_WRITE, NULL,\n\t\t\t\t  NULL);\n\tif (IS_ERR(bdev)) {\n\t\tpr_warn(\"pNFS: failed to open device %s (%ld)\\n\",\n\t\t\tdevname, PTR_ERR(bdev));\n\t}\n\n\tkfree(devname);\n\treturn bdev;\n}\n\nstatic int\nbl_parse_scsi(struct nfs_server *server, struct pnfs_block_dev *d,\n\t\tstruct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask)\n{\n\tstruct pnfs_block_volume *v = &volumes[idx];\n\tstruct block_device *bdev;\n\tconst struct pr_ops *ops;\n\tint error;\n\n\tif (!bl_validate_designator(v))\n\t\treturn -EINVAL;\n\n\t \n\tbdev = bl_open_path(v, \"dm-uuid-mpath-0x\");\n\tif (IS_ERR(bdev))\n\t\tbdev = bl_open_path(v, \"wwn-0x\");\n\tif (IS_ERR(bdev))\n\t\treturn PTR_ERR(bdev);\n\td->bdev = bdev;\n\n\td->len = bdev_nr_bytes(d->bdev);\n\td->map = bl_map_simple;\n\td->pr_key = v->scsi.pr_key;\n\n\tpr_info(\"pNFS: using block device %s (reservation key 0x%llx)\\n\",\n\t\td->bdev->bd_disk->disk_name, d->pr_key);\n\n\tops = d->bdev->bd_disk->fops->pr_ops;\n\tif (!ops) {\n\t\tpr_err(\"pNFS: block device %s does not support reservations.\",\n\t\t\t\td->bdev->bd_disk->disk_name);\n\t\terror = -EINVAL;\n\t\tgoto out_blkdev_put;\n\t}\n\n\terror = ops->pr_register(d->bdev, 0, d->pr_key, true);\n\tif (error) {\n\t\tpr_err(\"pNFS: failed to register key for block device %s.\",\n\t\t\t\td->bdev->bd_disk->disk_name);\n\t\tgoto out_blkdev_put;\n\t}\n\n\td->pr_registered = true;\n\treturn 0;\n\nout_blkdev_put:\n\tblkdev_put(d->bdev, NULL);\n\treturn error;\n}\n\nstatic int\nbl_parse_slice(struct nfs_server *server, struct pnfs_block_dev *d,\n\t\tstruct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask)\n{\n\tstruct pnfs_block_volume *v = &volumes[idx];\n\tint ret;\n\n\tret = bl_parse_deviceid(server, d, volumes, v->slice.volume, gfp_mask);\n\tif (ret)\n\t\treturn ret;\n\n\td->disk_offset = v->slice.start;\n\td->len = v->slice.len;\n\treturn 0;\n}\n\nstatic int\nbl_parse_concat(struct nfs_server *server, struct pnfs_block_dev *d,\n\t\tstruct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask)\n{\n\tstruct pnfs_block_volume *v = &volumes[idx];\n\tu64 len = 0;\n\tint ret, i;\n\n\td->children = kcalloc(v->concat.volumes_count,\n\t\t\tsizeof(struct pnfs_block_dev), gfp_mask);\n\tif (!d->children)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < v->concat.volumes_count; i++) {\n\t\tret = bl_parse_deviceid(server, &d->children[i],\n\t\t\t\tvolumes, v->concat.volumes[i], gfp_mask);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\td->nr_children++;\n\t\td->children[i].start += len;\n\t\tlen += d->children[i].len;\n\t}\n\n\td->len = len;\n\td->map = bl_map_concat;\n\treturn 0;\n}\n\nstatic int\nbl_parse_stripe(struct nfs_server *server, struct pnfs_block_dev *d,\n\t\tstruct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask)\n{\n\tstruct pnfs_block_volume *v = &volumes[idx];\n\tu64 len = 0;\n\tint ret, i;\n\n\td->children = kcalloc(v->stripe.volumes_count,\n\t\t\tsizeof(struct pnfs_block_dev), gfp_mask);\n\tif (!d->children)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < v->stripe.volumes_count; i++) {\n\t\tret = bl_parse_deviceid(server, &d->children[i],\n\t\t\t\tvolumes, v->stripe.volumes[i], gfp_mask);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\td->nr_children++;\n\t\tlen += d->children[i].len;\n\t}\n\n\td->len = len;\n\td->chunk_size = v->stripe.chunk_size;\n\td->map = bl_map_stripe;\n\treturn 0;\n}\n\nstatic int\nbl_parse_deviceid(struct nfs_server *server, struct pnfs_block_dev *d,\n\t\tstruct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask)\n{\n\tswitch (volumes[idx].type) {\n\tcase PNFS_BLOCK_VOLUME_SIMPLE:\n\t\treturn bl_parse_simple(server, d, volumes, idx, gfp_mask);\n\tcase PNFS_BLOCK_VOLUME_SLICE:\n\t\treturn bl_parse_slice(server, d, volumes, idx, gfp_mask);\n\tcase PNFS_BLOCK_VOLUME_CONCAT:\n\t\treturn bl_parse_concat(server, d, volumes, idx, gfp_mask);\n\tcase PNFS_BLOCK_VOLUME_STRIPE:\n\t\treturn bl_parse_stripe(server, d, volumes, idx, gfp_mask);\n\tcase PNFS_BLOCK_VOLUME_SCSI:\n\t\treturn bl_parse_scsi(server, d, volumes, idx, gfp_mask);\n\tdefault:\n\t\tdprintk(\"unsupported volume type: %d\\n\", volumes[idx].type);\n\t\treturn -EIO;\n\t}\n}\n\nstruct nfs4_deviceid_node *\nbl_alloc_deviceid_node(struct nfs_server *server, struct pnfs_device *pdev,\n\t\tgfp_t gfp_mask)\n{\n\tstruct nfs4_deviceid_node *node = NULL;\n\tstruct pnfs_block_volume *volumes;\n\tstruct pnfs_block_dev *top;\n\tstruct xdr_stream xdr;\n\tstruct xdr_buf buf;\n\tstruct page *scratch;\n\tint nr_volumes, ret, i;\n\t__be32 *p;\n\n\tscratch = alloc_page(gfp_mask);\n\tif (!scratch)\n\t\tgoto out;\n\n\txdr_init_decode_pages(&xdr, &buf, pdev->pages, pdev->pglen);\n\txdr_set_scratch_page(&xdr, scratch);\n\n\tp = xdr_inline_decode(&xdr, sizeof(__be32));\n\tif (!p)\n\t\tgoto out_free_scratch;\n\tnr_volumes = be32_to_cpup(p++);\n\n\tvolumes = kcalloc(nr_volumes, sizeof(struct pnfs_block_volume),\n\t\t\t  gfp_mask);\n\tif (!volumes)\n\t\tgoto out_free_scratch;\n\n\tfor (i = 0; i < nr_volumes; i++) {\n\t\tret = nfs4_block_decode_volume(&xdr, &volumes[i]);\n\t\tif (ret < 0)\n\t\t\tgoto out_free_volumes;\n\t}\n\n\ttop = kzalloc(sizeof(*top), gfp_mask);\n\tif (!top)\n\t\tgoto out_free_volumes;\n\n\tret = bl_parse_deviceid(server, top, volumes, nr_volumes - 1, gfp_mask);\n\n\tnode = &top->node;\n\tnfs4_init_deviceid_node(node, server, &pdev->dev_id);\n\tif (ret)\n\t\tnfs4_mark_deviceid_unavailable(node);\n\nout_free_volumes:\n\tkfree(volumes);\nout_free_scratch:\n\t__free_page(scratch);\nout:\n\treturn node;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}