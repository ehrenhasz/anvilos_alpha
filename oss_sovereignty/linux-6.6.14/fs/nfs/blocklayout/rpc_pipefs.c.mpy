{
  "module_name": "rpc_pipefs.c",
  "hash_id": "5c4e2dd6abf09110c3e3bd63114d2f80d29a9671f62ddeda4438d623bd2cfcc1",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfs/blocklayout/rpc_pipefs.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\n#include \"blocklayout.h\"\n\n#define NFSDBG_FACILITY         NFSDBG_PNFS_LD\n\nstatic void\nnfs4_encode_simple(__be32 *p, struct pnfs_block_volume *b)\n{\n\tint i;\n\n\t*p++ = cpu_to_be32(1);\n\t*p++ = cpu_to_be32(b->type);\n\t*p++ = cpu_to_be32(b->simple.nr_sigs);\n\tfor (i = 0; i < b->simple.nr_sigs; i++) {\n\t\tp = xdr_encode_hyper(p, b->simple.sigs[i].offset);\n\t\tp = xdr_encode_opaque(p, b->simple.sigs[i].sig,\n\t\t\t\t\t b->simple.sigs[i].sig_len);\n\t}\n}\n\ndev_t\nbl_resolve_deviceid(struct nfs_server *server, struct pnfs_block_volume *b,\n\t\tgfp_t gfp_mask)\n{\n\tstruct net *net = server->nfs_client->cl_net;\n\tstruct nfs_net *nn = net_generic(net, nfs_net_id);\n\tstruct bl_dev_msg *reply = &nn->bl_mount_reply;\n\tstruct bl_pipe_msg bl_pipe_msg;\n\tstruct rpc_pipe_msg *msg = &bl_pipe_msg.msg;\n\tstruct bl_msg_hdr *bl_msg;\n\tDECLARE_WAITQUEUE(wq, current);\n\tdev_t dev = 0;\n\tint rc;\n\n\tdprintk(\"%s CREATING PIPEFS MESSAGE\\n\", __func__);\n\n\tmutex_lock(&nn->bl_mutex);\n\tbl_pipe_msg.bl_wq = &nn->bl_wq;\n\n\tb->simple.len += 4;\t \n\tif (b->simple.len > PAGE_SIZE)\n\t\tgoto out_unlock;\n\n\tmemset(msg, 0, sizeof(*msg));\n\tmsg->len = sizeof(*bl_msg) + b->simple.len;\n\tmsg->data = kzalloc(msg->len, gfp_mask);\n\tif (!msg->data)\n\t\tgoto out_free_data;\n\n\tbl_msg = msg->data;\n\tbl_msg->type = BL_DEVICE_MOUNT;\n\tbl_msg->totallen = b->simple.len;\n\tnfs4_encode_simple(msg->data + sizeof(*bl_msg), b);\n\n\tdprintk(\"%s CALLING USERSPACE DAEMON\\n\", __func__);\n\tadd_wait_queue(&nn->bl_wq, &wq);\n\trc = rpc_queue_upcall(nn->bl_device_pipe, msg);\n\tif (rc < 0) {\n\t\tremove_wait_queue(&nn->bl_wq, &wq);\n\t\tgoto out_free_data;\n\t}\n\n\tset_current_state(TASK_UNINTERRUPTIBLE);\n\tschedule();\n\tremove_wait_queue(&nn->bl_wq, &wq);\n\n\tif (reply->status != BL_DEVICE_REQUEST_PROC) {\n\t\tprintk(KERN_WARNING \"%s failed to decode device: %d\\n\",\n\t\t\t__func__, reply->status);\n\t\tgoto out_free_data;\n\t}\n\n\tdev = MKDEV(reply->major, reply->minor);\nout_free_data:\n\tkfree(msg->data);\nout_unlock:\n\tmutex_unlock(&nn->bl_mutex);\n\treturn dev;\n}\n\nstatic ssize_t bl_pipe_downcall(struct file *filp, const char __user *src,\n\t\t\t size_t mlen)\n{\n\tstruct nfs_net *nn = net_generic(file_inode(filp)->i_sb->s_fs_info,\n\t\t\t\t\t nfs_net_id);\n\n\tif (mlen != sizeof (struct bl_dev_msg))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&nn->bl_mount_reply, src, mlen) != 0)\n\t\treturn -EFAULT;\n\n\twake_up(&nn->bl_wq);\n\n\treturn mlen;\n}\n\nstatic void bl_pipe_destroy_msg(struct rpc_pipe_msg *msg)\n{\n\tstruct bl_pipe_msg *bl_pipe_msg =\n\t\tcontainer_of(msg, struct bl_pipe_msg, msg);\n\n\tif (msg->errno >= 0)\n\t\treturn;\n\twake_up(bl_pipe_msg->bl_wq);\n}\n\nstatic const struct rpc_pipe_ops bl_upcall_ops = {\n\t.upcall\t\t= rpc_pipe_generic_upcall,\n\t.downcall\t= bl_pipe_downcall,\n\t.destroy_msg\t= bl_pipe_destroy_msg,\n};\n\nstatic struct dentry *nfs4blocklayout_register_sb(struct super_block *sb,\n\t\t\t\t\t    struct rpc_pipe *pipe)\n{\n\tstruct dentry *dir, *dentry;\n\n\tdir = rpc_d_lookup_sb(sb, NFS_PIPE_DIRNAME);\n\tif (dir == NULL)\n\t\treturn ERR_PTR(-ENOENT);\n\tdentry = rpc_mkpipe_dentry(dir, \"blocklayout\", NULL, pipe);\n\tdput(dir);\n\treturn dentry;\n}\n\nstatic void nfs4blocklayout_unregister_sb(struct super_block *sb,\n\t\t\t\t\t  struct rpc_pipe *pipe)\n{\n\tif (pipe->dentry)\n\t\trpc_unlink(pipe->dentry);\n}\n\nstatic int rpc_pipefs_event(struct notifier_block *nb, unsigned long event,\n\t\t\t   void *ptr)\n{\n\tstruct super_block *sb = ptr;\n\tstruct net *net = sb->s_fs_info;\n\tstruct nfs_net *nn = net_generic(net, nfs_net_id);\n\tstruct dentry *dentry;\n\tint ret = 0;\n\n\tif (!try_module_get(THIS_MODULE))\n\t\treturn 0;\n\n\tif (nn->bl_device_pipe == NULL) {\n\t\tmodule_put(THIS_MODULE);\n\t\treturn 0;\n\t}\n\n\tswitch (event) {\n\tcase RPC_PIPEFS_MOUNT:\n\t\tdentry = nfs4blocklayout_register_sb(sb, nn->bl_device_pipe);\n\t\tif (IS_ERR(dentry)) {\n\t\t\tret = PTR_ERR(dentry);\n\t\t\tbreak;\n\t\t}\n\t\tnn->bl_device_pipe->dentry = dentry;\n\t\tbreak;\n\tcase RPC_PIPEFS_UMOUNT:\n\t\tif (nn->bl_device_pipe->dentry)\n\t\t\tnfs4blocklayout_unregister_sb(sb, nn->bl_device_pipe);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOTSUPP;\n\t\tbreak;\n\t}\n\tmodule_put(THIS_MODULE);\n\treturn ret;\n}\n\nstatic struct notifier_block nfs4blocklayout_block = {\n\t.notifier_call = rpc_pipefs_event,\n};\n\nstatic struct dentry *nfs4blocklayout_register_net(struct net *net,\n\t\t\t\t\t\t   struct rpc_pipe *pipe)\n{\n\tstruct super_block *pipefs_sb;\n\tstruct dentry *dentry;\n\n\tpipefs_sb = rpc_get_sb_net(net);\n\tif (!pipefs_sb)\n\t\treturn NULL;\n\tdentry = nfs4blocklayout_register_sb(pipefs_sb, pipe);\n\trpc_put_sb_net(net);\n\treturn dentry;\n}\n\nstatic void nfs4blocklayout_unregister_net(struct net *net,\n\t\t\t\t\t   struct rpc_pipe *pipe)\n{\n\tstruct super_block *pipefs_sb;\n\n\tpipefs_sb = rpc_get_sb_net(net);\n\tif (pipefs_sb) {\n\t\tnfs4blocklayout_unregister_sb(pipefs_sb, pipe);\n\t\trpc_put_sb_net(net);\n\t}\n}\n\nstatic int nfs4blocklayout_net_init(struct net *net)\n{\n\tstruct nfs_net *nn = net_generic(net, nfs_net_id);\n\tstruct dentry *dentry;\n\n\tmutex_init(&nn->bl_mutex);\n\tinit_waitqueue_head(&nn->bl_wq);\n\tnn->bl_device_pipe = rpc_mkpipe_data(&bl_upcall_ops, 0);\n\tif (IS_ERR(nn->bl_device_pipe))\n\t\treturn PTR_ERR(nn->bl_device_pipe);\n\tdentry = nfs4blocklayout_register_net(net, nn->bl_device_pipe);\n\tif (IS_ERR(dentry)) {\n\t\trpc_destroy_pipe_data(nn->bl_device_pipe);\n\t\treturn PTR_ERR(dentry);\n\t}\n\tnn->bl_device_pipe->dentry = dentry;\n\treturn 0;\n}\n\nstatic void nfs4blocklayout_net_exit(struct net *net)\n{\n\tstruct nfs_net *nn = net_generic(net, nfs_net_id);\n\n\tnfs4blocklayout_unregister_net(net, nn->bl_device_pipe);\n\trpc_destroy_pipe_data(nn->bl_device_pipe);\n\tnn->bl_device_pipe = NULL;\n}\n\nstatic struct pernet_operations nfs4blocklayout_net_ops = {\n\t.init = nfs4blocklayout_net_init,\n\t.exit = nfs4blocklayout_net_exit,\n};\n\nint __init bl_init_pipefs(void)\n{\n\tint ret;\n\n\tret = rpc_pipefs_notifier_register(&nfs4blocklayout_block);\n\tif (ret)\n\t\tgoto out;\n\tret = register_pernet_subsys(&nfs4blocklayout_net_ops);\n\tif (ret)\n\t\tgoto out_unregister_notifier;\n\treturn 0;\n\nout_unregister_notifier:\n\trpc_pipefs_notifier_unregister(&nfs4blocklayout_block);\nout:\n\treturn ret;\n}\n\nvoid bl_cleanup_pipefs(void)\n{\n\trpc_pipefs_notifier_unregister(&nfs4blocklayout_block);\n\tunregister_pernet_subsys(&nfs4blocklayout_net_ops);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}