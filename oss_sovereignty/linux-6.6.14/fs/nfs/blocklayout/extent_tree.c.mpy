{
  "module_name": "extent_tree.c",
  "hash_id": "9b0064c97522a7751b76c7ac7c4a774d59bc46e531f3fb72d5de1afda2679d5e",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfs/blocklayout/extent_tree.c",
  "human_readable_source": "\n \n\n#include <linux/vmalloc.h>\n\n#include \"blocklayout.h\"\n\n#define NFSDBG_FACILITY\t\tNFSDBG_PNFS_LD\n\nstatic inline struct pnfs_block_extent *\next_node(struct rb_node *node)\n{\n\treturn rb_entry(node, struct pnfs_block_extent, be_node);\n}\n\nstatic struct pnfs_block_extent *\next_tree_first(struct rb_root *root)\n{\n\tstruct rb_node *node = rb_first(root);\n\treturn node ? ext_node(node) : NULL;\n}\n\nstatic struct pnfs_block_extent *\next_tree_prev(struct pnfs_block_extent *be)\n{\n\tstruct rb_node *node = rb_prev(&be->be_node);\n\treturn node ? ext_node(node) : NULL;\n}\n\nstatic struct pnfs_block_extent *\next_tree_next(struct pnfs_block_extent *be)\n{\n\tstruct rb_node *node = rb_next(&be->be_node);\n\treturn node ? ext_node(node) : NULL;\n}\n\nstatic inline sector_t\next_f_end(struct pnfs_block_extent *be)\n{\n\treturn be->be_f_offset + be->be_length;\n}\n\nstatic struct pnfs_block_extent *\n__ext_tree_search(struct rb_root *root, sector_t start)\n{\n\tstruct rb_node *node = root->rb_node;\n\tstruct pnfs_block_extent *be = NULL;\n\n\twhile (node) {\n\t\tbe = ext_node(node);\n\t\tif (start < be->be_f_offset)\n\t\t\tnode = node->rb_left;\n\t\telse if (start >= ext_f_end(be))\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn be;\n\t}\n\n\tif (be) {\n\t\tif (start < be->be_f_offset)\n\t\t\treturn be;\n\n\t\tif (start >= ext_f_end(be))\n\t\t\treturn ext_tree_next(be);\n\t}\n\n\treturn NULL;\n}\n\nstatic bool\next_can_merge(struct pnfs_block_extent *be1, struct pnfs_block_extent *be2)\n{\n\tif (be1->be_state != be2->be_state)\n\t\treturn false;\n\tif (be1->be_device != be2->be_device)\n\t\treturn false;\n\n\tif (be1->be_f_offset + be1->be_length != be2->be_f_offset)\n\t\treturn false;\n\n\tif (be1->be_state != PNFS_BLOCK_NONE_DATA &&\n\t    (be1->be_v_offset + be1->be_length != be2->be_v_offset))\n\t\treturn false;\n\n\tif (be1->be_state == PNFS_BLOCK_INVALID_DATA &&\n\t    be1->be_tag != be2->be_tag)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic struct pnfs_block_extent *\next_try_to_merge_left(struct rb_root *root, struct pnfs_block_extent *be)\n{\n\tstruct pnfs_block_extent *left = ext_tree_prev(be);\n\n\tif (left && ext_can_merge(left, be)) {\n\t\tleft->be_length += be->be_length;\n\t\trb_erase(&be->be_node, root);\n\t\tnfs4_put_deviceid_node(be->be_device);\n\t\tkfree(be);\n\t\treturn left;\n\t}\n\n\treturn be;\n}\n\nstatic struct pnfs_block_extent *\next_try_to_merge_right(struct rb_root *root, struct pnfs_block_extent *be)\n{\n\tstruct pnfs_block_extent *right = ext_tree_next(be);\n\n\tif (right && ext_can_merge(be, right)) {\n\t\tbe->be_length += right->be_length;\n\t\trb_erase(&right->be_node, root);\n\t\tnfs4_put_deviceid_node(right->be_device);\n\t\tkfree(right);\n\t}\n\n\treturn be;\n}\n\nstatic void __ext_put_deviceids(struct list_head *head)\n{\n\tstruct pnfs_block_extent *be, *tmp;\n\n\tlist_for_each_entry_safe(be, tmp, head, be_list) {\n\t\tnfs4_put_deviceid_node(be->be_device);\n\t\tkfree(be);\n\t}\n}\n\nstatic void\n__ext_tree_insert(struct rb_root *root,\n\t\tstruct pnfs_block_extent *new, bool merge_ok)\n{\n\tstruct rb_node **p = &root->rb_node, *parent = NULL;\n\tstruct pnfs_block_extent *be;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tbe = ext_node(parent);\n\n\t\tif (new->be_f_offset < be->be_f_offset) {\n\t\t\tif (merge_ok && ext_can_merge(new, be)) {\n\t\t\t\tbe->be_f_offset = new->be_f_offset;\n\t\t\t\tif (be->be_state != PNFS_BLOCK_NONE_DATA)\n\t\t\t\t\tbe->be_v_offset = new->be_v_offset;\n\t\t\t\tbe->be_length += new->be_length;\n\t\t\t\tbe = ext_try_to_merge_left(root, be);\n\t\t\t\tgoto free_new;\n\t\t\t}\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (new->be_f_offset >= ext_f_end(be)) {\n\t\t\tif (merge_ok && ext_can_merge(be, new)) {\n\t\t\t\tbe->be_length += new->be_length;\n\t\t\t\tbe = ext_try_to_merge_right(root, be);\n\t\t\t\tgoto free_new;\n\t\t\t}\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\tBUG();\n\t\t}\n\t}\n\n\trb_link_node(&new->be_node, parent, p);\n\trb_insert_color(&new->be_node, root);\n\treturn;\nfree_new:\n\tnfs4_put_deviceid_node(new->be_device);\n\tkfree(new);\n}\n\nstatic int\n__ext_tree_remove(struct rb_root *root,\n\t\tsector_t start, sector_t end, struct list_head *tmp)\n{\n\tstruct pnfs_block_extent *be;\n\tsector_t len1 = 0, len2 = 0;\n\tsector_t orig_v_offset;\n\tsector_t orig_len;\n\n\tbe = __ext_tree_search(root, start);\n\tif (!be)\n\t\treturn 0;\n\tif (be->be_f_offset >= end)\n\t\treturn 0;\n\n\torig_v_offset = be->be_v_offset;\n\torig_len = be->be_length;\n\n\tif (start > be->be_f_offset)\n\t\tlen1 = start - be->be_f_offset;\n\tif (ext_f_end(be) > end)\n\t\tlen2 = ext_f_end(be) - end;\n\n\tif (len2 > 0) {\n\t\tif (len1 > 0) {\n\t\t\tstruct pnfs_block_extent *new;\n\n\t\t\tnew = kzalloc(sizeof(*new), GFP_ATOMIC);\n\t\t\tif (!new)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tbe->be_length = len1;\n\n\t\t\tnew->be_f_offset = end;\n\t\t\tif (be->be_state != PNFS_BLOCK_NONE_DATA) {\n\t\t\t\tnew->be_v_offset =\n\t\t\t\t\torig_v_offset + orig_len - len2;\n\t\t\t}\n\t\t\tnew->be_length = len2;\n\t\t\tnew->be_state = be->be_state;\n\t\t\tnew->be_tag = be->be_tag;\n\t\t\tnew->be_device = nfs4_get_deviceid(be->be_device);\n\n\t\t\t__ext_tree_insert(root, new, true);\n\t\t} else {\n\t\t\tbe->be_f_offset = end;\n\t\t\tif (be->be_state != PNFS_BLOCK_NONE_DATA) {\n\t\t\t\tbe->be_v_offset =\n\t\t\t\t\torig_v_offset + orig_len - len2;\n\t\t\t}\n\t\t\tbe->be_length = len2;\n\t\t}\n\t} else {\n\t\tif (len1 > 0) {\n\t\t\tbe->be_length = len1;\n\t\t\tbe = ext_tree_next(be);\n\t\t}\n\n\t\twhile (be && ext_f_end(be) <= end) {\n\t\t\tstruct pnfs_block_extent *next = ext_tree_next(be);\n\n\t\t\trb_erase(&be->be_node, root);\n\t\t\tlist_add_tail(&be->be_list, tmp);\n\t\t\tbe = next;\n\t\t}\n\n\t\tif (be && be->be_f_offset < end) {\n\t\t\tlen1 = ext_f_end(be) - end;\n\t\t\tbe->be_f_offset = end;\n\t\t\tif (be->be_state != PNFS_BLOCK_NONE_DATA)\n\t\t\t\tbe->be_v_offset += be->be_length - len1;\n\t\t\tbe->be_length = len1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint\next_tree_insert(struct pnfs_block_layout *bl, struct pnfs_block_extent *new)\n{\n\tstruct pnfs_block_extent *be;\n\tstruct rb_root *root;\n\tint err = 0;\n\n\tswitch (new->be_state) {\n\tcase PNFS_BLOCK_READWRITE_DATA:\n\tcase PNFS_BLOCK_INVALID_DATA:\n\t\troot = &bl->bl_ext_rw;\n\t\tbreak;\n\tcase PNFS_BLOCK_READ_DATA:\n\tcase PNFS_BLOCK_NONE_DATA:\n\t\troot = &bl->bl_ext_ro;\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"invalid extent type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock(&bl->bl_ext_lock);\nretry:\n\tbe = __ext_tree_search(root, new->be_f_offset);\n\tif (!be || be->be_f_offset >= ext_f_end(new)) {\n\t\t__ext_tree_insert(root, new, true);\n\t} else if (new->be_f_offset >= be->be_f_offset) {\n\t\tif (ext_f_end(new) <= ext_f_end(be)) {\n\t\t\tnfs4_put_deviceid_node(new->be_device);\n\t\t\tkfree(new);\n\t\t} else {\n\t\t\tsector_t new_len = ext_f_end(new) - ext_f_end(be);\n\t\t\tsector_t diff = new->be_length - new_len;\n\n\t\t\tnew->be_f_offset += diff;\n\t\t\tnew->be_v_offset += diff;\n\t\t\tnew->be_length = new_len;\n\t\t\tgoto retry;\n\t\t}\n\t} else if (ext_f_end(new) <= ext_f_end(be)) {\n\t\tnew->be_length = be->be_f_offset - new->be_f_offset;\n\t\t__ext_tree_insert(root, new, true);\n\t} else {\n\t\tstruct pnfs_block_extent *split;\n\t\tsector_t new_len = ext_f_end(new) - ext_f_end(be);\n\t\tsector_t diff = new->be_length - new_len;\n\n\t\tsplit = kmemdup(new, sizeof(*new), GFP_ATOMIC);\n\t\tif (!split) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tsplit->be_length = be->be_f_offset - split->be_f_offset;\n\t\tsplit->be_device = nfs4_get_deviceid(new->be_device);\n\t\t__ext_tree_insert(root, split, true);\n\n\t\tnew->be_f_offset += diff;\n\t\tnew->be_v_offset += diff;\n\t\tnew->be_length = new_len;\n\t\tgoto retry;\n\t}\nout:\n\tspin_unlock(&bl->bl_ext_lock);\n\treturn err;\n}\n\nstatic bool\n__ext_tree_lookup(struct rb_root *root, sector_t isect,\n\t\tstruct pnfs_block_extent *ret)\n{\n\tstruct rb_node *node;\n\tstruct pnfs_block_extent *be;\n\n\tnode = root->rb_node;\n\twhile (node) {\n\t\tbe = ext_node(node);\n\t\tif (isect < be->be_f_offset)\n\t\t\tnode = node->rb_left;\n\t\telse if (isect >= ext_f_end(be))\n\t\t\tnode = node->rb_right;\n\t\telse {\n\t\t\t*ret = *be;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nbool\next_tree_lookup(struct pnfs_block_layout *bl, sector_t isect,\n\t    struct pnfs_block_extent *ret, bool rw)\n{\n\tbool found = false;\n\n\tspin_lock(&bl->bl_ext_lock);\n\tif (!rw)\n\t\tfound = __ext_tree_lookup(&bl->bl_ext_ro, isect, ret);\n\tif (!found)\n\t\tfound = __ext_tree_lookup(&bl->bl_ext_rw, isect, ret);\n\tspin_unlock(&bl->bl_ext_lock);\n\n\treturn found;\n}\n\nint ext_tree_remove(struct pnfs_block_layout *bl, bool rw,\n\t\tsector_t start, sector_t end)\n{\n\tint err, err2;\n\tLIST_HEAD(tmp);\n\n\tspin_lock(&bl->bl_ext_lock);\n\terr = __ext_tree_remove(&bl->bl_ext_ro, start, end, &tmp);\n\tif (rw) {\n\t\terr2 = __ext_tree_remove(&bl->bl_ext_rw, start, end, &tmp);\n\t\tif (!err)\n\t\t\terr = err2;\n\t}\n\tspin_unlock(&bl->bl_ext_lock);\n\n\t__ext_put_deviceids(&tmp);\n\treturn err;\n}\n\nstatic int\next_tree_split(struct rb_root *root, struct pnfs_block_extent *be,\n\t\tsector_t split)\n{\n\tstruct pnfs_block_extent *new;\n\tsector_t orig_len = be->be_length;\n\n\tnew = kzalloc(sizeof(*new), GFP_ATOMIC);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tbe->be_length = split - be->be_f_offset;\n\n\tnew->be_f_offset = split;\n\tif (be->be_state != PNFS_BLOCK_NONE_DATA)\n\t\tnew->be_v_offset = be->be_v_offset + be->be_length;\n\tnew->be_length = orig_len - be->be_length;\n\tnew->be_state = be->be_state;\n\tnew->be_tag = be->be_tag;\n\tnew->be_device = nfs4_get_deviceid(be->be_device);\n\n\t__ext_tree_insert(root, new, false);\n\treturn 0;\n}\n\nint\next_tree_mark_written(struct pnfs_block_layout *bl, sector_t start,\n\t\tsector_t len, u64 lwb)\n{\n\tstruct rb_root *root = &bl->bl_ext_rw;\n\tsector_t end = start + len;\n\tstruct pnfs_block_extent *be;\n\tint err = 0;\n\tLIST_HEAD(tmp);\n\n\tspin_lock(&bl->bl_ext_lock);\n\t \n\terr = __ext_tree_remove(&bl->bl_ext_ro, start, end, &tmp);\n\tif (err)\n\t\tgoto out;\n\n\t \n\tfor (be = __ext_tree_search(root, start); be; be = ext_tree_next(be)) {\n\t\tif (be->be_f_offset >= end)\n\t\t\tbreak;\n\n\t\tif (be->be_state != PNFS_BLOCK_INVALID_DATA || be->be_tag)\n\t\t\tcontinue;\n\n\t\tif (be->be_f_offset < start) {\n\t\t\tstruct pnfs_block_extent *left = ext_tree_prev(be);\n\n\t\t\tif (left && ext_can_merge(left, be)) {\n\t\t\t\tsector_t diff = start - be->be_f_offset;\n\n\t\t\t\tleft->be_length += diff;\n\n\t\t\t\tbe->be_f_offset += diff;\n\t\t\t\tbe->be_v_offset += diff;\n\t\t\t\tbe->be_length -= diff;\n\t\t\t} else {\n\t\t\t\terr = ext_tree_split(root, be, start);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (ext_f_end(be) > end) {\n\t\t\tstruct pnfs_block_extent *right = ext_tree_next(be);\n\n\t\t\tif (right && ext_can_merge(be, right)) {\n\t\t\t\tsector_t diff = end - be->be_f_offset;\n\n\t\t\t\tbe->be_length -= diff;\n\n\t\t\t\tright->be_f_offset -= diff;\n\t\t\t\tright->be_v_offset -= diff;\n\t\t\t\tright->be_length += diff;\n\t\t\t} else {\n\t\t\t\terr = ext_tree_split(root, be, end);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (be->be_f_offset >= start && ext_f_end(be) <= end) {\n\t\t\tbe->be_tag = EXTENT_WRITTEN;\n\t\t\tbe = ext_try_to_merge_left(root, be);\n\t\t\tbe = ext_try_to_merge_right(root, be);\n\t\t}\n\t}\nout:\n\tif (bl->bl_lwb < lwb)\n\t\tbl->bl_lwb = lwb;\n\tspin_unlock(&bl->bl_ext_lock);\n\n\t__ext_put_deviceids(&tmp);\n\treturn err;\n}\n\nstatic size_t ext_tree_layoutupdate_size(struct pnfs_block_layout *bl, size_t count)\n{\n\tif (bl->bl_scsi_layout)\n\t\treturn sizeof(__be32) + PNFS_SCSI_RANGE_SIZE * count;\n\telse\n\t\treturn sizeof(__be32) + PNFS_BLOCK_EXTENT_SIZE * count;\n}\n\nstatic void ext_tree_free_commitdata(struct nfs4_layoutcommit_args *arg,\n\t\tsize_t buffer_size)\n{\n\tif (arg->layoutupdate_pages != &arg->layoutupdate_page) {\n\t\tint nr_pages = DIV_ROUND_UP(buffer_size, PAGE_SIZE), i;\n\n\t\tfor (i = 0; i < nr_pages; i++)\n\t\t\tput_page(arg->layoutupdate_pages[i]);\n\t\tvfree(arg->start_p);\n\t\tkfree(arg->layoutupdate_pages);\n\t} else {\n\t\tput_page(arg->layoutupdate_page);\n\t}\n}\n\nstatic __be32 *encode_block_extent(struct pnfs_block_extent *be, __be32 *p)\n{\n\tp = xdr_encode_opaque_fixed(p, be->be_device->deviceid.data,\n\t\t\tNFS4_DEVICEID4_SIZE);\n\tp = xdr_encode_hyper(p, be->be_f_offset << SECTOR_SHIFT);\n\tp = xdr_encode_hyper(p, be->be_length << SECTOR_SHIFT);\n\tp = xdr_encode_hyper(p, 0LL);\n\t*p++ = cpu_to_be32(PNFS_BLOCK_READWRITE_DATA);\n\treturn p;\n}\n\nstatic __be32 *encode_scsi_range(struct pnfs_block_extent *be, __be32 *p)\n{\n\tp = xdr_encode_hyper(p, be->be_f_offset << SECTOR_SHIFT);\n\treturn xdr_encode_hyper(p, be->be_length << SECTOR_SHIFT);\n}\n\nstatic int ext_tree_encode_commit(struct pnfs_block_layout *bl, __be32 *p,\n\t\tsize_t buffer_size, size_t *count, __u64 *lastbyte)\n{\n\tstruct pnfs_block_extent *be;\n\tint ret = 0;\n\n\tspin_lock(&bl->bl_ext_lock);\n\tfor (be = ext_tree_first(&bl->bl_ext_rw); be; be = ext_tree_next(be)) {\n\t\tif (be->be_state != PNFS_BLOCK_INVALID_DATA ||\n\t\t    be->be_tag != EXTENT_WRITTEN)\n\t\t\tcontinue;\n\n\t\t(*count)++;\n\t\tif (ext_tree_layoutupdate_size(bl, *count) > buffer_size) {\n\t\t\t \n\t\t\tret = -ENOSPC;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (bl->bl_scsi_layout)\n\t\t\tp = encode_scsi_range(be, p);\n\t\telse\n\t\t\tp = encode_block_extent(be, p);\n\t\tbe->be_tag = EXTENT_COMMITTING;\n\t}\n\t*lastbyte = bl->bl_lwb - 1;\n\tbl->bl_lwb = 0;\n\tspin_unlock(&bl->bl_ext_lock);\n\n\treturn ret;\n}\n\nint\next_tree_prepare_commit(struct nfs4_layoutcommit_args *arg)\n{\n\tstruct pnfs_block_layout *bl = BLK_LO2EXT(NFS_I(arg->inode)->layout);\n\tsize_t count = 0, buffer_size = PAGE_SIZE;\n\t__be32 *start_p;\n\tint ret;\n\n\tdprintk(\"%s enter\\n\", __func__);\n\n\targ->layoutupdate_page = alloc_page(GFP_NOFS);\n\tif (!arg->layoutupdate_page)\n\t\treturn -ENOMEM;\n\tstart_p = page_address(arg->layoutupdate_page);\n\targ->layoutupdate_pages = &arg->layoutupdate_page;\n\nretry:\n\tret = ext_tree_encode_commit(bl, start_p + 1, buffer_size, &count, &arg->lastbytewritten);\n\tif (unlikely(ret)) {\n\t\text_tree_free_commitdata(arg, buffer_size);\n\n\t\tbuffer_size = ext_tree_layoutupdate_size(bl, count);\n\t\tcount = 0;\n\n\t\targ->layoutupdate_pages =\n\t\t\tkcalloc(DIV_ROUND_UP(buffer_size, PAGE_SIZE),\n\t\t\t\tsizeof(struct page *), GFP_NOFS);\n\t\tif (!arg->layoutupdate_pages)\n\t\t\treturn -ENOMEM;\n\n\t\tstart_p = __vmalloc(buffer_size, GFP_NOFS);\n\t\tif (!start_p) {\n\t\t\tkfree(arg->layoutupdate_pages);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tgoto retry;\n\t}\n\n\t*start_p = cpu_to_be32(count);\n\targ->layoutupdate_len = ext_tree_layoutupdate_size(bl, count);\n\n\tif (unlikely(arg->layoutupdate_pages != &arg->layoutupdate_page)) {\n\t\tvoid *p = start_p, *end = p + arg->layoutupdate_len;\n\t\tstruct page *page = NULL;\n\t\tint i = 0;\n\n\t\targ->start_p = start_p;\n\t\tfor ( ; p < end; p += PAGE_SIZE) {\n\t\t\tpage = vmalloc_to_page(p);\n\t\t\targ->layoutupdate_pages[i++] = page;\n\t\t\tget_page(page);\n\t\t}\n\t}\n\n\tdprintk(\"%s found %zu ranges\\n\", __func__, count);\n\treturn 0;\n}\n\nvoid\next_tree_mark_committed(struct nfs4_layoutcommit_args *arg, int status)\n{\n\tstruct pnfs_block_layout *bl = BLK_LO2EXT(NFS_I(arg->inode)->layout);\n\tstruct rb_root *root = &bl->bl_ext_rw;\n\tstruct pnfs_block_extent *be;\n\n\tdprintk(\"%s status %d\\n\", __func__, status);\n\n\text_tree_free_commitdata(arg, arg->layoutupdate_len);\n\n\tspin_lock(&bl->bl_ext_lock);\n\tfor (be = ext_tree_first(root); be; be = ext_tree_next(be)) {\n\t\tif (be->be_state != PNFS_BLOCK_INVALID_DATA ||\n\t\t    be->be_tag != EXTENT_COMMITTING)\n\t\t\tcontinue;\n\n\t\tif (status) {\n\t\t\t \n\t\t\tbe->be_tag = EXTENT_WRITTEN;\n\t\t} else {\n\t\t\tbe->be_state = PNFS_BLOCK_READWRITE_DATA;\n\t\t\tbe->be_tag = 0;\n\t\t}\n\n\t\tbe = ext_try_to_merge_left(root, be);\n\t\tbe = ext_try_to_merge_right(root, be);\n\t}\n\tspin_unlock(&bl->bl_ext_lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}