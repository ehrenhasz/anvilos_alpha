{
  "module_name": "sysfs.c",
  "hash_id": "a4ec5da19f7c18fe29880efe3e627efd12a486f8252e5a2beb1375ac761967bb",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfs/sysfs.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kobject.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/netdevice.h>\n#include <linux/string.h>\n#include <linux/nfs_fs.h>\n#include <linux/rcupdate.h>\n#include <linux/lockd/lockd.h>\n\n#include \"nfs4_fs.h\"\n#include \"netns.h\"\n#include \"sysfs.h\"\n\nstatic struct kset *nfs_kset;\n\nstatic void nfs_kset_release(struct kobject *kobj)\n{\n\tstruct kset *kset = container_of(kobj, struct kset, kobj);\n\tkfree(kset);\n}\n\nstatic const struct kobj_ns_type_operations *nfs_netns_object_child_ns_type(\n\t\tconst struct kobject *kobj)\n{\n\treturn &net_ns_type_operations;\n}\n\nstatic struct kobj_type nfs_kset_type = {\n\t.release = nfs_kset_release,\n\t.sysfs_ops = &kobj_sysfs_ops,\n\t.child_ns_type = nfs_netns_object_child_ns_type,\n};\n\nint nfs_sysfs_init(void)\n{\n\tint ret;\n\n\tnfs_kset = kzalloc(sizeof(*nfs_kset), GFP_KERNEL);\n\tif (!nfs_kset)\n\t\treturn -ENOMEM;\n\n\tret = kobject_set_name(&nfs_kset->kobj, \"nfs\");\n\tif (ret) {\n\t\tkfree(nfs_kset);\n\t\treturn ret;\n\t}\n\n\tnfs_kset->kobj.parent = fs_kobj;\n\tnfs_kset->kobj.ktype = &nfs_kset_type;\n\tnfs_kset->kobj.kset = NULL;\n\n\tret = kset_register(nfs_kset);\n\tif (ret) {\n\t\tkfree(nfs_kset);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nvoid nfs_sysfs_exit(void)\n{\n\tkset_unregister(nfs_kset);\n}\n\nstatic ssize_t nfs_netns_identifier_show(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tstruct nfs_netns_client *c = container_of(kobj,\n\t\t\tstruct nfs_netns_client,\n\t\t\tkobject);\n\tssize_t ret;\n\n\trcu_read_lock();\n\tret = sysfs_emit(buf, \"%s\\n\", rcu_dereference(c->identifier));\n\trcu_read_unlock();\n\treturn ret;\n}\n\n \nstatic size_t nfs_string_strip(const char *c, size_t len)\n{\n\twhile (len > 0 && c[len-1] == '\\n')\n\t\t--len;\n\treturn len;\n}\n\nstatic ssize_t nfs_netns_identifier_store(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tstruct nfs_netns_client *c = container_of(kobj,\n\t\t\tstruct nfs_netns_client,\n\t\t\tkobject);\n\tconst char *old;\n\tchar *p;\n\tsize_t len;\n\n\tlen = nfs_string_strip(buf, min_t(size_t, count, CONTAINER_ID_MAXLEN));\n\tif (!len)\n\t\treturn 0;\n\tp = kmemdup_nul(buf, len, GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\told = rcu_dereference_protected(xchg(&c->identifier, (char __rcu *)p), 1);\n\tif (old) {\n\t\tsynchronize_rcu();\n\t\tkfree(old);\n\t}\n\treturn count;\n}\n\nstatic void nfs_netns_client_release(struct kobject *kobj)\n{\n\tstruct nfs_netns_client *c = container_of(kobj,\n\t\t\tstruct nfs_netns_client,\n\t\t\tkobject);\n\n\tkfree(rcu_dereference_raw(c->identifier));\n}\n\nstatic const void *nfs_netns_client_namespace(const struct kobject *kobj)\n{\n\treturn container_of(kobj, struct nfs_netns_client, kobject)->net;\n}\n\nstatic struct kobj_attribute nfs_netns_client_id = __ATTR(identifier,\n\t\t0644, nfs_netns_identifier_show, nfs_netns_identifier_store);\n\nstatic struct attribute *nfs_netns_client_attrs[] = {\n\t&nfs_netns_client_id.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(nfs_netns_client);\n\nstatic struct kobj_type nfs_netns_client_type = {\n\t.release = nfs_netns_client_release,\n\t.default_groups = nfs_netns_client_groups,\n\t.sysfs_ops = &kobj_sysfs_ops,\n\t.namespace = nfs_netns_client_namespace,\n};\n\nstatic void nfs_netns_object_release(struct kobject *kobj)\n{\n\tstruct nfs_netns_client *c = container_of(kobj,\n\t\t\tstruct nfs_netns_client,\n\t\t\tnfs_net_kobj);\n\tkfree(c);\n}\n\nstatic const void *nfs_netns_namespace(const struct kobject *kobj)\n{\n\treturn container_of(kobj, struct nfs_netns_client, nfs_net_kobj)->net;\n}\n\nstatic struct kobj_type nfs_netns_object_type = {\n\t.release = nfs_netns_object_release,\n\t.sysfs_ops = &kobj_sysfs_ops,\n\t.namespace =  nfs_netns_namespace,\n};\n\nstatic struct nfs_netns_client *nfs_netns_client_alloc(struct kobject *parent,\n\t\tstruct net *net)\n{\n\tstruct nfs_netns_client *p;\n\n\tp = kzalloc(sizeof(*p), GFP_KERNEL);\n\tif (p) {\n\t\tp->net = net;\n\t\tp->kobject.kset = nfs_kset;\n\t\tp->nfs_net_kobj.kset = nfs_kset;\n\n\t\tif (kobject_init_and_add(&p->nfs_net_kobj, &nfs_netns_object_type,\n\t\t\t\t\tparent, \"net\") != 0) {\n\t\t\tkobject_put(&p->nfs_net_kobj);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (kobject_init_and_add(&p->kobject, &nfs_netns_client_type,\n\t\t\t\t\t&p->nfs_net_kobj, \"nfs_client\") == 0)\n\t\t\treturn p;\n\n\t\tkobject_put(&p->kobject);\n\t}\n\treturn NULL;\n}\n\nvoid nfs_netns_sysfs_setup(struct nfs_net *netns, struct net *net)\n{\n\tstruct nfs_netns_client *clp;\n\n\tclp = nfs_netns_client_alloc(&nfs_kset->kobj, net);\n\tif (clp) {\n\t\tnetns->nfs_client = clp;\n\t\tkobject_uevent(&clp->kobject, KOBJ_ADD);\n\t}\n}\n\nvoid nfs_netns_sysfs_destroy(struct nfs_net *netns)\n{\n\tstruct nfs_netns_client *clp = netns->nfs_client;\n\n\tif (clp) {\n\t\tkobject_uevent(&clp->kobject, KOBJ_REMOVE);\n\t\tkobject_del(&clp->kobject);\n\t\tkobject_put(&clp->kobject);\n\t\tkobject_del(&clp->nfs_net_kobj);\n\t\tkobject_put(&clp->nfs_net_kobj);\n\t\tnetns->nfs_client = NULL;\n\t}\n}\n\nstatic bool shutdown_match_client(const struct rpc_task *task, const void *data)\n{\n\treturn true;\n}\n\nstatic void shutdown_client(struct rpc_clnt *clnt)\n{\n\tclnt->cl_shutdown = 1;\n\trpc_cancel_tasks(clnt, -EIO, shutdown_match_client, NULL);\n}\n\nstatic ssize_t\nshutdown_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct nfs_server *server = container_of(kobj, struct nfs_server, kobj);\n\tbool shutdown = server->flags & NFS_MOUNT_SHUTDOWN;\n\treturn sysfs_emit(buf, \"%d\\n\", shutdown);\n}\n\nstatic ssize_t\nshutdown_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct nfs_server *server;\n\tint ret, val;\n\n\tserver = container_of(kobj, struct nfs_server, kobj);\n\n\tret = kstrtoint(buf, 0, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val != 1)\n\t\treturn -EINVAL;\n\n\t \n\tif (server->flags & NFS_MOUNT_SHUTDOWN)\n\t\tgoto out;\n\n\tserver->flags |= NFS_MOUNT_SHUTDOWN;\n\tshutdown_client(server->client);\n\tshutdown_client(server->nfs_client->cl_rpcclient);\n\n\tif (!IS_ERR(server->client_acl))\n\t\tshutdown_client(server->client_acl);\n\n\tif (server->nlm_host)\n\t\tshutdown_client(server->nlm_host->h_rpcclnt);\nout:\n\treturn count;\n}\n\nstatic struct kobj_attribute nfs_sysfs_attr_shutdown = __ATTR_RW(shutdown);\n\n#define RPC_CLIENT_NAME_SIZE 64\n\nvoid nfs_sysfs_link_rpc_client(struct nfs_server *server,\n\t\t\tstruct rpc_clnt *clnt, const char *uniq)\n{\n\tchar name[RPC_CLIENT_NAME_SIZE];\n\tint ret;\n\n\tstrcpy(name, clnt->cl_program->name);\n\tstrcat(name, uniq ? uniq : \"\");\n\tstrcat(name, \"_client\");\n\n\tret = sysfs_create_link_nowarn(&server->kobj,\n\t\t\t\t\t\t&clnt->cl_sysfs->kobject, name);\n\tif (ret < 0)\n\t\tpr_warn(\"NFS: can't create link to %s in sysfs (%d)\\n\",\n\t\t\tname, ret);\n}\nEXPORT_SYMBOL_GPL(nfs_sysfs_link_rpc_client);\n\nstatic void nfs_sysfs_sb_release(struct kobject *kobj)\n{\n\t \n}\n\nstatic const void *nfs_netns_server_namespace(const struct kobject *kobj)\n{\n\treturn container_of(kobj, struct nfs_server, kobj)->nfs_client->cl_net;\n}\n\nstatic struct kobj_type nfs_sb_ktype = {\n\t.release = nfs_sysfs_sb_release,\n\t.sysfs_ops = &kobj_sysfs_ops,\n\t.namespace = nfs_netns_server_namespace,\n\t.child_ns_type = nfs_netns_object_child_ns_type,\n};\n\nvoid nfs_sysfs_add_server(struct nfs_server *server)\n{\n\tint ret;\n\n\tret = kobject_init_and_add(&server->kobj, &nfs_sb_ktype,\n\t\t\t\t&nfs_kset->kobj, \"server-%d\", server->s_sysfs_id);\n\tif (ret < 0) {\n\t\tpr_warn(\"NFS: nfs sysfs add server-%d failed (%d)\\n\",\n\t\t\t\t\tserver->s_sysfs_id, ret);\n\t\treturn;\n\t}\n\tret = sysfs_create_file_ns(&server->kobj, &nfs_sysfs_attr_shutdown.attr,\n\t\t\t\tnfs_netns_server_namespace(&server->kobj));\n\tif (ret < 0)\n\t\tpr_warn(\"NFS: sysfs_create_file_ns for server-%d failed (%d)\\n\",\n\t\t\tserver->s_sysfs_id, ret);\n}\nEXPORT_SYMBOL_GPL(nfs_sysfs_add_server);\n\nvoid nfs_sysfs_move_server_to_sb(struct super_block *s)\n{\n\tstruct nfs_server *server = s->s_fs_info;\n\tint ret;\n\n\tret = kobject_rename(&server->kobj, s->s_id);\n\tif (ret < 0)\n\t\tpr_warn(\"NFS: rename sysfs %s failed (%d)\\n\",\n\t\t\t\t\tserver->kobj.name, ret);\n}\n\nvoid nfs_sysfs_move_sb_to_server(struct nfs_server *server)\n{\n\tconst char *s;\n\tint ret = -ENOMEM;\n\n\ts = kasprintf(GFP_KERNEL, \"server-%d\", server->s_sysfs_id);\n\tif (s) {\n\t\tret = kobject_rename(&server->kobj, s);\n\t\tkfree(s);\n\t}\n\tif (ret < 0)\n\t\tpr_warn(\"NFS: rename sysfs %s failed (%d)\\n\",\n\t\t\t\t\tserver->kobj.name, ret);\n}\n\n \nvoid nfs_sysfs_remove_server(struct nfs_server *server)\n{\n\tkobject_del(&server->kobj);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}