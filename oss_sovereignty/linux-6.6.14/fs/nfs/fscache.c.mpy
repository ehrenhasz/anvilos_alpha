{
  "module_name": "fscache.c",
  "hash_id": "49b723d777c4420825cf997825b3ec390e13c05ad8fa04c44c5b95842419cec4",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfs/fscache.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_fs_sb.h>\n#include <linux/in6.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/iversion.h>\n#include <linux/xarray.h>\n#include <linux/fscache.h>\n#include <linux/netfs.h>\n\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"fscache.h\"\n#include \"nfstrace.h\"\n\n#define NFS_MAX_KEY_LEN 1000\n\nstatic bool nfs_append_int(char *key, int *_len, unsigned long long x)\n{\n\tif (*_len > NFS_MAX_KEY_LEN)\n\t\treturn false;\n\tif (x == 0)\n\t\tkey[(*_len)++] = ',';\n\telse\n\t\t*_len += sprintf(key + *_len, \",%llx\", x);\n\treturn true;\n}\n\n \nstatic bool nfs_fscache_get_client_key(struct nfs_client *clp,\n\t\t\t\t       char *key, int *_len)\n{\n\tconst struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *) &clp->cl_addr;\n\tconst struct sockaddr_in *sin = (struct sockaddr_in *) &clp->cl_addr;\n\n\t*_len += snprintf(key + *_len, NFS_MAX_KEY_LEN - *_len,\n\t\t\t  \",%u.%u,%x\",\n\t\t\t  clp->rpc_ops->version,\n\t\t\t  clp->cl_minorversion,\n\t\t\t  clp->cl_addr.ss_family);\n\n\tswitch (clp->cl_addr.ss_family) {\n\tcase AF_INET:\n\t\tif (!nfs_append_int(key, _len, sin->sin_port) ||\n\t\t    !nfs_append_int(key, _len, sin->sin_addr.s_addr))\n\t\t\treturn false;\n\t\treturn true;\n\n\tcase AF_INET6:\n\t\tif (!nfs_append_int(key, _len, sin6->sin6_port) ||\n\t\t    !nfs_append_int(key, _len, sin6->sin6_addr.s6_addr32[0]) ||\n\t\t    !nfs_append_int(key, _len, sin6->sin6_addr.s6_addr32[1]) ||\n\t\t    !nfs_append_int(key, _len, sin6->sin6_addr.s6_addr32[2]) ||\n\t\t    !nfs_append_int(key, _len, sin6->sin6_addr.s6_addr32[3]))\n\t\t\treturn false;\n\t\treturn true;\n\n\tdefault:\n\t\tprintk(KERN_WARNING \"NFS: Unknown network family '%d'\\n\",\n\t\t       clp->cl_addr.ss_family);\n\t\treturn false;\n\t}\n}\n\n \nint nfs_fscache_get_super_cookie(struct super_block *sb, const char *uniq, int ulen)\n{\n\tstruct fscache_volume *vcookie;\n\tstruct nfs_server *nfss = NFS_SB(sb);\n\tunsigned int len = 3;\n\tchar *key;\n\n\tif (uniq) {\n\t\tnfss->fscache_uniq = kmemdup_nul(uniq, ulen, GFP_KERNEL);\n\t\tif (!nfss->fscache_uniq)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tkey = kmalloc(NFS_MAX_KEY_LEN + 24, GFP_KERNEL);\n\tif (!key)\n\t\treturn -ENOMEM;\n\n\tmemcpy(key, \"nfs\", 3);\n\tif (!nfs_fscache_get_client_key(nfss->nfs_client, key, &len) ||\n\t    !nfs_append_int(key, &len, nfss->fsid.major) ||\n\t    !nfs_append_int(key, &len, nfss->fsid.minor) ||\n\t    !nfs_append_int(key, &len, sb->s_flags & NFS_SB_MASK) ||\n\t    !nfs_append_int(key, &len, nfss->flags) ||\n\t    !nfs_append_int(key, &len, nfss->rsize) ||\n\t    !nfs_append_int(key, &len, nfss->wsize) ||\n\t    !nfs_append_int(key, &len, nfss->acregmin) ||\n\t    !nfs_append_int(key, &len, nfss->acregmax) ||\n\t    !nfs_append_int(key, &len, nfss->acdirmin) ||\n\t    !nfs_append_int(key, &len, nfss->acdirmax) ||\n\t    !nfs_append_int(key, &len, nfss->client->cl_auth->au_flavor))\n\t\tgoto out;\n\n\tif (ulen > 0) {\n\t\tif (ulen > NFS_MAX_KEY_LEN - len)\n\t\t\tgoto out;\n\t\tkey[len++] = ',';\n\t\tmemcpy(key + len, uniq, ulen);\n\t\tlen += ulen;\n\t}\n\tkey[len] = 0;\n\n\t \n\tvcookie = fscache_acquire_volume(key,\n\t\t\t\t\t NULL,  \n\t\t\t\t\t NULL, 0  );\n\tif (IS_ERR(vcookie)) {\n\t\tif (vcookie != ERR_PTR(-EBUSY)) {\n\t\t\tkfree(key);\n\t\t\treturn PTR_ERR(vcookie);\n\t\t}\n\t\tpr_err(\"NFS: Cache volume key already in use (%s)\\n\", key);\n\t\tvcookie = NULL;\n\t}\n\tnfss->fscache = vcookie;\n\nout:\n\tkfree(key);\n\treturn 0;\n}\n\n \nvoid nfs_fscache_release_super_cookie(struct super_block *sb)\n{\n\tstruct nfs_server *nfss = NFS_SB(sb);\n\n\tfscache_relinquish_volume(nfss->fscache, NULL, false);\n\tnfss->fscache = NULL;\n\tkfree(nfss->fscache_uniq);\n}\n\n \nvoid nfs_fscache_init_inode(struct inode *inode)\n{\n\tstruct nfs_fscache_inode_auxdata auxdata;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\tnetfs_inode(inode)->cache = NULL;\n\tif (!(nfss->fscache && S_ISREG(inode->i_mode)))\n\t\treturn;\n\n\tnfs_fscache_update_auxdata(&auxdata, inode);\n\n\tnetfs_inode(inode)->cache = fscache_acquire_cookie(\n\t\t\t\t\t       nfss->fscache,\n\t\t\t\t\t       0,\n\t\t\t\t\t       nfsi->fh.data,  \n\t\t\t\t\t       nfsi->fh.size,\n\t\t\t\t\t       &auxdata,       \n\t\t\t\t\t       sizeof(auxdata),\n\t\t\t\t\t       i_size_read(inode));\n\n\tif (netfs_inode(inode)->cache)\n\t\tmapping_set_release_always(inode->i_mapping);\n}\n\n \nvoid nfs_fscache_clear_inode(struct inode *inode)\n{\n\tfscache_relinquish_cookie(netfs_i_cookie(netfs_inode(inode)), false);\n\tnetfs_inode(inode)->cache = NULL;\n}\n\n \nvoid nfs_fscache_open_file(struct inode *inode, struct file *filp)\n{\n\tstruct nfs_fscache_inode_auxdata auxdata;\n\tstruct fscache_cookie *cookie = netfs_i_cookie(netfs_inode(inode));\n\tbool open_for_write = inode_is_open_for_write(inode);\n\n\tif (!fscache_cookie_valid(cookie))\n\t\treturn;\n\n\tfscache_use_cookie(cookie, open_for_write);\n\tif (open_for_write) {\n\t\tnfs_fscache_update_auxdata(&auxdata, inode);\n\t\tfscache_invalidate(cookie, &auxdata, i_size_read(inode),\n\t\t\t\t   FSCACHE_INVAL_DIO_WRITE);\n\t}\n}\nEXPORT_SYMBOL_GPL(nfs_fscache_open_file);\n\nvoid nfs_fscache_release_file(struct inode *inode, struct file *filp)\n{\n\tstruct nfs_fscache_inode_auxdata auxdata;\n\tstruct fscache_cookie *cookie = netfs_i_cookie(netfs_inode(inode));\n\tloff_t i_size = i_size_read(inode);\n\n\tnfs_fscache_update_auxdata(&auxdata, inode);\n\tfscache_unuse_cookie(cookie, &auxdata, &i_size);\n}\n\nint nfs_netfs_read_folio(struct file *file, struct folio *folio)\n{\n\tif (!netfs_inode(folio_inode(folio))->cache)\n\t\treturn -ENOBUFS;\n\n\treturn netfs_read_folio(file, folio);\n}\n\nint nfs_netfs_readahead(struct readahead_control *ractl)\n{\n\tstruct inode *inode = ractl->mapping->host;\n\n\tif (!netfs_inode(inode)->cache)\n\t\treturn -ENOBUFS;\n\n\tnetfs_readahead(ractl);\n\treturn 0;\n}\n\nstatic atomic_t nfs_netfs_debug_id;\nstatic int nfs_netfs_init_request(struct netfs_io_request *rreq, struct file *file)\n{\n\trreq->netfs_priv = get_nfs_open_context(nfs_file_open_context(file));\n\trreq->debug_id = atomic_inc_return(&nfs_netfs_debug_id);\n\n\treturn 0;\n}\n\nstatic void nfs_netfs_free_request(struct netfs_io_request *rreq)\n{\n\tput_nfs_open_context(rreq->netfs_priv);\n}\n\nstatic inline int nfs_netfs_begin_cache_operation(struct netfs_io_request *rreq)\n{\n\treturn fscache_begin_read_operation(&rreq->cache_resources,\n\t\t\t\t\t    netfs_i_cookie(netfs_inode(rreq->inode)));\n}\n\nstatic struct nfs_netfs_io_data *nfs_netfs_alloc(struct netfs_io_subrequest *sreq)\n{\n\tstruct nfs_netfs_io_data *netfs;\n\n\tnetfs = kzalloc(sizeof(*netfs), GFP_KERNEL_ACCOUNT);\n\tif (!netfs)\n\t\treturn NULL;\n\tnetfs->sreq = sreq;\n\trefcount_set(&netfs->refcount, 1);\n\treturn netfs;\n}\n\nstatic bool nfs_netfs_clamp_length(struct netfs_io_subrequest *sreq)\n{\n\tsize_t\trsize = NFS_SB(sreq->rreq->inode->i_sb)->rsize;\n\n\tsreq->len = min(sreq->len, rsize);\n\treturn true;\n}\n\nstatic void nfs_netfs_issue_read(struct netfs_io_subrequest *sreq)\n{\n\tstruct nfs_netfs_io_data\t*netfs;\n\tstruct nfs_pageio_descriptor\tpgio;\n\tstruct inode *inode = sreq->rreq->inode;\n\tstruct nfs_open_context *ctx = sreq->rreq->netfs_priv;\n\tstruct page *page;\n\tint err;\n\tpgoff_t start = (sreq->start + sreq->transferred) >> PAGE_SHIFT;\n\tpgoff_t last = ((sreq->start + sreq->len -\n\t\t\t sreq->transferred - 1) >> PAGE_SHIFT);\n\tXA_STATE(xas, &sreq->rreq->mapping->i_pages, start);\n\n\tnfs_pageio_init_read(&pgio, inode, false,\n\t\t\t     &nfs_async_read_completion_ops);\n\n\tnetfs = nfs_netfs_alloc(sreq);\n\tif (!netfs)\n\t\treturn netfs_subreq_terminated(sreq, -ENOMEM, false);\n\n\tpgio.pg_netfs = netfs;  \n\n\txas_lock(&xas);\n\txas_for_each(&xas, page, last) {\n\t\t \n\t\txas_pause(&xas);\n\t\txas_unlock(&xas);\n\t\terr = nfs_read_add_folio(&pgio, ctx, page_folio(page));\n\t\tif (err < 0) {\n\t\t\tnetfs->error = err;\n\t\t\tgoto out;\n\t\t}\n\t\txas_lock(&xas);\n\t}\n\txas_unlock(&xas);\nout:\n\tnfs_pageio_complete_read(&pgio);\n\tnfs_netfs_put(netfs);\n}\n\nvoid nfs_netfs_initiate_read(struct nfs_pgio_header *hdr)\n{\n\tstruct nfs_netfs_io_data        *netfs = hdr->netfs;\n\n\tif (!netfs)\n\t\treturn;\n\n\tnfs_netfs_get(netfs);\n}\n\nint nfs_netfs_folio_unlock(struct folio *folio)\n{\n\tstruct inode *inode = folio_file_mapping(folio)->host;\n\n\t \n\tif (netfs_inode(inode)->cache)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nvoid nfs_netfs_read_completion(struct nfs_pgio_header *hdr)\n{\n\tstruct nfs_netfs_io_data        *netfs = hdr->netfs;\n\tstruct netfs_io_subrequest      *sreq;\n\n\tif (!netfs)\n\t\treturn;\n\n\tsreq = netfs->sreq;\n\tif (test_bit(NFS_IOHDR_EOF, &hdr->flags))\n\t\t__set_bit(NETFS_SREQ_CLEAR_TAIL, &sreq->flags);\n\n\tif (hdr->error)\n\t\tnetfs->error = hdr->error;\n\telse\n\t\tatomic64_add(hdr->res.count, &netfs->transferred);\n\n\tnfs_netfs_put(netfs);\n\thdr->netfs = NULL;\n}\n\nconst struct netfs_request_ops nfs_netfs_ops = {\n\t.init_request\t\t= nfs_netfs_init_request,\n\t.free_request\t\t= nfs_netfs_free_request,\n\t.begin_cache_operation\t= nfs_netfs_begin_cache_operation,\n\t.issue_read\t\t= nfs_netfs_issue_read,\n\t.clamp_length\t\t= nfs_netfs_clamp_length\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}