{
  "module_name": "callback_proc.c",
  "hash_id": "8461c998a5e20a022916f2721b32ae71bfd64f8afbe0705056a393e5d1b58203",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfs/callback_proc.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/math.h>\n#include <linux/nfs4.h>\n#include <linux/nfs_fs.h>\n#include <linux/slab.h>\n#include <linux/rcupdate.h>\n#include <linux/types.h>\n\n#include \"nfs4_fs.h\"\n#include \"callback.h\"\n#include \"delegation.h\"\n#include \"internal.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"nfs4trace.h\"\n\n#define NFSDBG_FACILITY NFSDBG_CALLBACK\n\n__be32 nfs4_callback_getattr(void *argp, void *resp,\n\t\t\t     struct cb_process_state *cps)\n{\n\tstruct cb_getattrargs *args = argp;\n\tstruct cb_getattrres *res = resp;\n\tstruct nfs_delegation *delegation;\n\tstruct inode *inode;\n\n\tres->status = htonl(NFS4ERR_OP_NOT_IN_SESSION);\n\tif (!cps->clp)  \n\t\tgoto out;\n\n\tres->bitmap[0] = res->bitmap[1] = 0;\n\tres->status = htonl(NFS4ERR_BADHANDLE);\n\n\tdprintk_rcu(\"NFS: GETATTR callback request from %s\\n\",\n\t\trpc_peeraddr2str(cps->clp->cl_rpcclient, RPC_DISPLAY_ADDR));\n\n\tinode = nfs_delegation_find_inode(cps->clp, &args->fh);\n\tif (IS_ERR(inode)) {\n\t\tif (inode == ERR_PTR(-EAGAIN))\n\t\t\tres->status = htonl(NFS4ERR_DELAY);\n\t\ttrace_nfs4_cb_getattr(cps->clp, &args->fh, NULL,\n\t\t\t\t-ntohl(res->status));\n\t\tgoto out;\n\t}\n\trcu_read_lock();\n\tdelegation = nfs4_get_valid_delegation(inode);\n\tif (delegation == NULL || (delegation->type & FMODE_WRITE) == 0)\n\t\tgoto out_iput;\n\tres->size = i_size_read(inode);\n\tres->change_attr = delegation->change_attr;\n\tif (nfs_have_writebacks(inode))\n\t\tres->change_attr++;\n\tres->ctime = inode_get_ctime(inode);\n\tres->mtime = inode->i_mtime;\n\tres->bitmap[0] = (FATTR4_WORD0_CHANGE|FATTR4_WORD0_SIZE) &\n\t\targs->bitmap[0];\n\tres->bitmap[1] = (FATTR4_WORD1_TIME_METADATA|FATTR4_WORD1_TIME_MODIFY) &\n\t\targs->bitmap[1];\n\tres->status = 0;\nout_iput:\n\trcu_read_unlock();\n\ttrace_nfs4_cb_getattr(cps->clp, &args->fh, inode, -ntohl(res->status));\n\tnfs_iput_and_deactive(inode);\nout:\n\tdprintk(\"%s: exit with status = %d\\n\", __func__, ntohl(res->status));\n\treturn res->status;\n}\n\n__be32 nfs4_callback_recall(void *argp, void *resp,\n\t\t\t    struct cb_process_state *cps)\n{\n\tstruct cb_recallargs *args = argp;\n\tstruct inode *inode;\n\t__be32 res;\n\t\n\tres = htonl(NFS4ERR_OP_NOT_IN_SESSION);\n\tif (!cps->clp)  \n\t\tgoto out;\n\n\tdprintk_rcu(\"NFS: RECALL callback request from %s\\n\",\n\t\trpc_peeraddr2str(cps->clp->cl_rpcclient, RPC_DISPLAY_ADDR));\n\n\tres = htonl(NFS4ERR_BADHANDLE);\n\tinode = nfs_delegation_find_inode(cps->clp, &args->fh);\n\tif (IS_ERR(inode)) {\n\t\tif (inode == ERR_PTR(-EAGAIN))\n\t\t\tres = htonl(NFS4ERR_DELAY);\n\t\ttrace_nfs4_cb_recall(cps->clp, &args->fh, NULL,\n\t\t\t\t&args->stateid, -ntohl(res));\n\t\tgoto out;\n\t}\n\t \n\tswitch (nfs_async_inode_return_delegation(inode, &args->stateid)) {\n\tcase 0:\n\t\tres = 0;\n\t\tbreak;\n\tcase -ENOENT:\n\t\tres = htonl(NFS4ERR_BAD_STATEID);\n\t\tbreak;\n\tdefault:\n\t\tres = htonl(NFS4ERR_RESOURCE);\n\t}\n\ttrace_nfs4_cb_recall(cps->clp, &args->fh, inode,\n\t\t\t&args->stateid, -ntohl(res));\n\tnfs_iput_and_deactive(inode);\nout:\n\tdprintk(\"%s: exit with status = %d\\n\", __func__, ntohl(res));\n\treturn res;\n}\n\n#if defined(CONFIG_NFS_V4_1)\n\n \nstatic struct inode *nfs_layout_find_inode_by_stateid(struct nfs_client *clp,\n\t\tconst nfs4_stateid *stateid)\n\t__must_hold(RCU)\n{\n\tstruct nfs_server *server;\n\tstruct inode *inode;\n\tstruct pnfs_layout_hdr *lo;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link) {\n\t\tlist_for_each_entry_rcu(lo, &server->layouts, plh_layouts) {\n\t\t\tif (!pnfs_layout_is_valid(lo))\n\t\t\t\tcontinue;\n\t\t\tif (!nfs4_stateid_match_other(stateid, &lo->plh_stateid))\n\t\t\t\tcontinue;\n\t\t\tif (nfs_sb_active(server->super))\n\t\t\t\tinode = igrab(lo->plh_inode);\n\t\t\telse\n\t\t\t\tinode = ERR_PTR(-EAGAIN);\n\t\t\trcu_read_unlock();\n\t\t\tif (inode)\n\t\t\t\treturn inode;\n\t\t\tnfs_sb_deactive(server->super);\n\t\t\treturn ERR_PTR(-EAGAIN);\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn ERR_PTR(-ENOENT);\n}\n\n \nstatic struct inode *nfs_layout_find_inode_by_fh(struct nfs_client *clp,\n\t\tconst struct nfs_fh *fh)\n{\n\tstruct nfs_server *server;\n\tstruct nfs_inode *nfsi;\n\tstruct inode *inode;\n\tstruct pnfs_layout_hdr *lo;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link) {\n\t\tlist_for_each_entry_rcu(lo, &server->layouts, plh_layouts) {\n\t\t\tnfsi = NFS_I(lo->plh_inode);\n\t\t\tif (nfs_compare_fh(fh, &nfsi->fh))\n\t\t\t\tcontinue;\n\t\t\tif (nfsi->layout != lo)\n\t\t\t\tcontinue;\n\t\t\tif (nfs_sb_active(server->super))\n\t\t\t\tinode = igrab(lo->plh_inode);\n\t\t\telse\n\t\t\t\tinode = ERR_PTR(-EAGAIN);\n\t\t\trcu_read_unlock();\n\t\t\tif (inode)\n\t\t\t\treturn inode;\n\t\t\tnfs_sb_deactive(server->super);\n\t\t\treturn ERR_PTR(-EAGAIN);\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn ERR_PTR(-ENOENT);\n}\n\nstatic struct inode *nfs_layout_find_inode(struct nfs_client *clp,\n\t\tconst struct nfs_fh *fh,\n\t\tconst nfs4_stateid *stateid)\n{\n\tstruct inode *inode;\n\n\tinode = nfs_layout_find_inode_by_stateid(clp, stateid);\n\tif (inode == ERR_PTR(-ENOENT))\n\t\tinode = nfs_layout_find_inode_by_fh(clp, fh);\n\treturn inode;\n}\n\n \nstatic u32 pnfs_check_callback_stateid(struct pnfs_layout_hdr *lo,\n\t\t\t\t\tconst nfs4_stateid *new)\n{\n\tu32 oldseq, newseq;\n\n\t \n\tif (!pnfs_layout_is_valid(lo))\n\t\treturn NFS4ERR_NOMATCHING_LAYOUT;\n\n\t \n\tif (!nfs4_stateid_match_other(&lo->plh_stateid, new))\n\t\treturn NFS4ERR_BAD_STATEID;\n\n\tnewseq = be32_to_cpu(new->seqid);\n\t \n\tif (test_bit(NFS_LAYOUT_RETURN_REQUESTED, &lo->plh_flags) &&\n\t    lo->plh_return_seq != 0) {\n\t\tif (newseq < lo->plh_return_seq)\n\t\t\treturn NFS4ERR_OLD_STATEID;\n\t\tif (newseq > lo->plh_return_seq)\n\t\t\treturn NFS4ERR_DELAY;\n\t\tgoto out;\n\t}\n\n\t \n\toldseq = be32_to_cpu(lo->plh_stateid.seqid);\n\tif (newseq > oldseq + 1)\n\t\treturn NFS4ERR_DELAY;\n\t \n\tif (newseq <= oldseq)\n\t\treturn NFS4ERR_OLD_STATEID;\nout:\n\treturn NFS_OK;\n}\n\nstatic u32 initiate_file_draining(struct nfs_client *clp,\n\t\t\t\t  struct cb_layoutrecallargs *args)\n{\n\tstruct inode *ino;\n\tstruct pnfs_layout_hdr *lo;\n\tu32 rv = NFS4ERR_NOMATCHING_LAYOUT;\n\tLIST_HEAD(free_me_list);\n\n\tino = nfs_layout_find_inode(clp, &args->cbl_fh, &args->cbl_stateid);\n\tif (IS_ERR(ino)) {\n\t\tif (ino == ERR_PTR(-EAGAIN))\n\t\t\trv = NFS4ERR_DELAY;\n\t\tgoto out_noput;\n\t}\n\n\tpnfs_layoutcommit_inode(ino, false);\n\n\n\tspin_lock(&ino->i_lock);\n\tlo = NFS_I(ino)->layout;\n\tif (!lo) {\n\t\tspin_unlock(&ino->i_lock);\n\t\tgoto out;\n\t}\n\tpnfs_get_layout_hdr(lo);\n\trv = pnfs_check_callback_stateid(lo, &args->cbl_stateid);\n\tif (rv != NFS_OK)\n\t\tgoto unlock;\n\n\t \n\tif (test_bit(NFS_LAYOUT_BULK_RECALL, &lo->plh_flags)) {\n\t\trv = NFS4ERR_DELAY;\n\t\tgoto unlock;\n\t}\n\n\tpnfs_set_layout_stateid(lo, &args->cbl_stateid, NULL, true);\n\tswitch (pnfs_mark_matching_lsegs_return(lo, &free_me_list,\n\t\t\t\t&args->cbl_range,\n\t\t\t\tbe32_to_cpu(args->cbl_stateid.seqid))) {\n\tcase 0:\n\tcase -EBUSY:\n\t\t \n\t\trv = NFS4_OK;\n\t\tbreak;\n\tcase -ENOENT:\n\t\tset_bit(NFS_LAYOUT_DRAIN, &lo->plh_flags);\n\t\t \n\t\trv = NFS4ERR_NOMATCHING_LAYOUT;\n\n\t\tif (NFS_SERVER(ino)->pnfs_curr_ld->return_range) {\n\t\t\tNFS_SERVER(ino)->pnfs_curr_ld->return_range(lo,\n\t\t\t\t&args->cbl_range);\n\t\t}\n\t}\nunlock:\n\tspin_unlock(&ino->i_lock);\n\tpnfs_free_lseg_list(&free_me_list);\n\t \n\tnfs_commit_inode(ino, 0);\n\tpnfs_put_layout_hdr(lo);\nout:\n\tnfs_iput_and_deactive(ino);\nout_noput:\n\ttrace_nfs4_cb_layoutrecall_file(clp, &args->cbl_fh, ino,\n\t\t\t&args->cbl_stateid, -rv);\n\treturn rv;\n}\n\nstatic u32 initiate_bulk_draining(struct nfs_client *clp,\n\t\t\t\t  struct cb_layoutrecallargs *args)\n{\n\tint stat;\n\n\tif (args->cbl_recall_type == RETURN_FSID)\n\t\tstat = pnfs_destroy_layouts_byfsid(clp, &args->cbl_fsid, true);\n\telse\n\t\tstat = pnfs_destroy_layouts_byclid(clp, true);\n\tif (stat != 0)\n\t\treturn NFS4ERR_DELAY;\n\treturn NFS4ERR_NOMATCHING_LAYOUT;\n}\n\nstatic u32 do_callback_layoutrecall(struct nfs_client *clp,\n\t\t\t\t    struct cb_layoutrecallargs *args)\n{\n\tif (args->cbl_recall_type == RETURN_FILE)\n\t\treturn initiate_file_draining(clp, args);\n\treturn initiate_bulk_draining(clp, args);\n}\n\n__be32 nfs4_callback_layoutrecall(void *argp, void *resp,\n\t\t\t\t  struct cb_process_state *cps)\n{\n\tstruct cb_layoutrecallargs *args = argp;\n\tu32 res = NFS4ERR_OP_NOT_IN_SESSION;\n\n\tif (cps->clp)\n\t\tres = do_callback_layoutrecall(cps->clp, args);\n\treturn cpu_to_be32(res);\n}\n\nstatic void pnfs_recall_all_layouts(struct nfs_client *clp)\n{\n\tstruct cb_layoutrecallargs args;\n\n\t \n\tmemset(&args, 0, sizeof(args));\n\targs.cbl_recall_type = RETURN_ALL;\n\t \n\tdo_callback_layoutrecall(clp, &args);\n}\n\n__be32 nfs4_callback_devicenotify(void *argp, void *resp,\n\t\t\t\t  struct cb_process_state *cps)\n{\n\tstruct cb_devicenotifyargs *args = argp;\n\tconst struct pnfs_layoutdriver_type *ld = NULL;\n\tuint32_t i;\n\t__be32 res = 0;\n\n\tif (!cps->clp) {\n\t\tres = cpu_to_be32(NFS4ERR_OP_NOT_IN_SESSION);\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < args->ndevs; i++) {\n\t\tstruct cb_devicenotifyitem *dev = &args->devs[i];\n\n\t\tif (!ld || ld->id != dev->cbd_layout_type) {\n\t\t\tpnfs_put_layoutdriver(ld);\n\t\t\tld = pnfs_find_layoutdriver(dev->cbd_layout_type);\n\t\t\tif (!ld)\n\t\t\t\tcontinue;\n\t\t}\n\t\tnfs4_delete_deviceid(ld, cps->clp, &dev->cbd_dev_id);\n\t}\n\tpnfs_put_layoutdriver(ld);\nout:\n\tkfree(args->devs);\n\treturn res;\n}\n\n \nstatic __be32\nvalidate_seqid(const struct nfs4_slot_table *tbl, const struct nfs4_slot *slot,\n\t\tconst struct cb_sequenceargs * args)\n{\n\t__be32 ret;\n\n\tret = cpu_to_be32(NFS4ERR_BADSLOT);\n\tif (args->csa_slotid > tbl->server_highest_slotid)\n\t\tgoto out_err;\n\n\t \n\tif (args->csa_sequenceid == slot->seq_nr) {\n\t\tret = cpu_to_be32(NFS4ERR_DELAY);\n\t\tif (nfs4_test_locked_slot(tbl, slot->slot_nr))\n\t\t\tgoto out_err;\n\n\t\t \n\t\tret = cpu_to_be32(NFS4ERR_RETRY_UNCACHED_REP);\n\t\tif (args->csa_cachethis == 0)\n\t\t\tgoto out_err;\n\n\t\t \n\t\tret = cpu_to_be32(NFS4ERR_SEQ_FALSE_RETRY);\n\t\tgoto out_err;\n\t}\n\n\t \n\t \n\tret = cpu_to_be32(NFS4ERR_SEQ_MISORDERED);\n\tif (args->csa_sequenceid != slot->seq_nr + 1)\n\t\tgoto out_err;\n\n\treturn cpu_to_be32(NFS4_OK);\n\nout_err:\n\ttrace_nfs4_cb_seqid_err(args, ret);\n\treturn ret;\n}\n\n \nstatic int referring_call_exists(struct nfs_client *clp,\n\t\t\t\t  uint32_t nrclists,\n\t\t\t\t  struct referring_call_list *rclists,\n\t\t\t\t  spinlock_t *lock)\n\t__releases(lock)\n\t__acquires(lock)\n{\n\tint status = 0;\n\tint i, j;\n\tstruct nfs4_session *session;\n\tstruct nfs4_slot_table *tbl;\n\tstruct referring_call_list *rclist;\n\tstruct referring_call *ref;\n\n\t \n\tsession = clp->cl_session;\n\ttbl = &session->fc_slot_table;\n\n\tfor (i = 0; i < nrclists; i++) {\n\t\trclist = &rclists[i];\n\t\tif (memcmp(session->sess_id.data,\n\t\t\t   rclist->rcl_sessionid.data,\n\t\t\t   NFS4_MAX_SESSIONID_LEN) != 0)\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < rclist->rcl_nrefcalls; j++) {\n\t\t\tref = &rclist->rcl_refcalls[j];\n\t\t\tspin_unlock(lock);\n\t\t\tstatus = nfs4_slot_wait_on_seqid(tbl, ref->rc_slotid,\n\t\t\t\t\tref->rc_sequenceid, HZ >> 1) < 0;\n\t\t\tspin_lock(lock);\n\t\t\tif (status)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\treturn status;\n}\n\n__be32 nfs4_callback_sequence(void *argp, void *resp,\n\t\t\t      struct cb_process_state *cps)\n{\n\tstruct cb_sequenceargs *args = argp;\n\tstruct cb_sequenceres *res = resp;\n\tstruct nfs4_slot_table *tbl;\n\tstruct nfs4_slot *slot;\n\tstruct nfs_client *clp;\n\tint i;\n\t__be32 status = htonl(NFS4ERR_BADSESSION);\n\n\tclp = nfs4_find_client_sessionid(cps->net, args->csa_addr,\n\t\t\t\t\t &args->csa_sessionid, cps->minorversion);\n\tif (clp == NULL)\n\t\tgoto out;\n\n\tif (!(clp->cl_session->flags & SESSION4_BACK_CHAN))\n\t\tgoto out;\n\n\ttbl = &clp->cl_session->bc_slot_table;\n\n\t \n\tmemcpy(&res->csr_sessionid, &args->csa_sessionid,\n\t       sizeof(res->csr_sessionid));\n\tres->csr_sequenceid = args->csa_sequenceid;\n\tres->csr_slotid = args->csa_slotid;\n\n\tspin_lock(&tbl->slot_tbl_lock);\n\t \n\tif (test_bit(NFS4_SLOT_TBL_DRAINING, &tbl->slot_tbl_state)) {\n\t\tstatus = htonl(NFS4ERR_DELAY);\n\t\t \n\t\tif (test_bit(NFS4CLNT_SESSION_RESET, &clp->cl_state))\n\t\t\tstatus = htonl(NFS4ERR_BADSESSION);\n\t\tgoto out_unlock;\n\t}\n\n\tstatus = htonl(NFS4ERR_BADSLOT);\n\tslot = nfs4_lookup_slot(tbl, args->csa_slotid);\n\tif (IS_ERR(slot))\n\t\tgoto out_unlock;\n\n\tres->csr_highestslotid = tbl->server_highest_slotid;\n\tres->csr_target_highestslotid = tbl->target_highest_slotid;\n\n\tstatus = validate_seqid(tbl, slot, args);\n\tif (status)\n\t\tgoto out_unlock;\n\tif (!nfs4_try_to_lock_slot(tbl, slot)) {\n\t\tstatus = htonl(NFS4ERR_DELAY);\n\t\tgoto out_unlock;\n\t}\n\tcps->slot = slot;\n\n\t \n\tif (args->csa_cachethis != 0) {\n\t\tstatus = htonl(NFS4ERR_REP_TOO_BIG_TO_CACHE);\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tif (referring_call_exists(clp, args->csa_nrclists, args->csa_rclists,\n\t\t\t\t&tbl->slot_tbl_lock) < 0) {\n\t\tstatus = htonl(NFS4ERR_DELAY);\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tslot->seq_nr = args->csa_sequenceid;\nout_unlock:\n\tspin_unlock(&tbl->slot_tbl_lock);\n\nout:\n\tcps->clp = clp;  \n\tfor (i = 0; i < args->csa_nrclists; i++)\n\t\tkfree(args->csa_rclists[i].rcl_refcalls);\n\tkfree(args->csa_rclists);\n\n\tif (status == htonl(NFS4ERR_RETRY_UNCACHED_REP)) {\n\t\tcps->drc_status = status;\n\t\tstatus = 0;\n\t} else\n\t\tres->csr_status = status;\n\n\ttrace_nfs4_cb_sequence(args, res, status);\n\treturn status;\n}\n\nstatic bool\nvalidate_bitmap_values(unsigned int mask)\n{\n\treturn (mask & ~RCA4_TYPE_MASK_ALL) == 0;\n}\n\n__be32 nfs4_callback_recallany(void *argp, void *resp,\n\t\t\t       struct cb_process_state *cps)\n{\n\tstruct cb_recallanyargs *args = argp;\n\t__be32 status;\n\tfmode_t flags = 0;\n\tbool schedule_manager = false;\n\n\tstatus = cpu_to_be32(NFS4ERR_OP_NOT_IN_SESSION);\n\tif (!cps->clp)  \n\t\tgoto out;\n\n\tdprintk_rcu(\"NFS: RECALL_ANY callback request from %s\\n\",\n\t\trpc_peeraddr2str(cps->clp->cl_rpcclient, RPC_DISPLAY_ADDR));\n\n\tstatus = cpu_to_be32(NFS4ERR_INVAL);\n\tif (!validate_bitmap_values(args->craa_type_mask))\n\t\tgoto out;\n\n\tstatus = cpu_to_be32(NFS4_OK);\n\tif (args->craa_type_mask & BIT(RCA4_TYPE_MASK_RDATA_DLG))\n\t\tflags = FMODE_READ;\n\tif (args->craa_type_mask & BIT(RCA4_TYPE_MASK_WDATA_DLG))\n\t\tflags |= FMODE_WRITE;\n\tif (flags)\n\t\tnfs_expire_unused_delegation_types(cps->clp, flags);\n\n\tif (args->craa_type_mask & BIT(RCA4_TYPE_MASK_FILE_LAYOUT))\n\t\tpnfs_recall_all_layouts(cps->clp);\n\n\tif (args->craa_type_mask & BIT(PNFS_FF_RCA4_TYPE_MASK_READ)) {\n\t\tset_bit(NFS4CLNT_RECALL_ANY_LAYOUT_READ, &cps->clp->cl_state);\n\t\tschedule_manager = true;\n\t}\n\tif (args->craa_type_mask & BIT(PNFS_FF_RCA4_TYPE_MASK_RW)) {\n\t\tset_bit(NFS4CLNT_RECALL_ANY_LAYOUT_RW, &cps->clp->cl_state);\n\t\tschedule_manager = true;\n\t}\n\tif (schedule_manager)\n\t\tnfs4_schedule_state_manager(cps->clp);\n\nout:\n\tdprintk(\"%s: exit with status = %d\\n\", __func__, ntohl(status));\n\treturn status;\n}\n\n \n__be32 nfs4_callback_recallslot(void *argp, void *resp,\n\t\t\t\tstruct cb_process_state *cps)\n{\n\tstruct cb_recallslotargs *args = argp;\n\tstruct nfs4_slot_table *fc_tbl;\n\t__be32 status;\n\n\tstatus = htonl(NFS4ERR_OP_NOT_IN_SESSION);\n\tif (!cps->clp)  \n\t\tgoto out;\n\n\tdprintk_rcu(\"NFS: CB_RECALL_SLOT request from %s target highest slotid %u\\n\",\n\t\trpc_peeraddr2str(cps->clp->cl_rpcclient, RPC_DISPLAY_ADDR),\n\t\targs->crsa_target_highest_slotid);\n\n\tfc_tbl = &cps->clp->cl_session->fc_slot_table;\n\n\tstatus = htonl(NFS4_OK);\n\n\tnfs41_set_target_slotid(fc_tbl, args->crsa_target_highest_slotid);\n\tnfs41_notify_server(cps->clp);\nout:\n\tdprintk(\"%s: exit with status = %d\\n\", __func__, ntohl(status));\n\treturn status;\n}\n\n__be32 nfs4_callback_notify_lock(void *argp, void *resp,\n\t\t\t\t struct cb_process_state *cps)\n{\n\tstruct cb_notify_lock_args *args = argp;\n\n\tif (!cps->clp)  \n\t\treturn htonl(NFS4ERR_OP_NOT_IN_SESSION);\n\n\tdprintk_rcu(\"NFS: CB_NOTIFY_LOCK request from %s\\n\",\n\t\trpc_peeraddr2str(cps->clp->cl_rpcclient, RPC_DISPLAY_ADDR));\n\n\t \n\tif (args->cbnl_valid)\n\t\t__wake_up(&cps->clp->cl_lock_waitq, TASK_NORMAL, 0, args);\n\n\treturn htonl(NFS4_OK);\n}\n#endif  \n#ifdef CONFIG_NFS_V4_2\nstatic void nfs4_copy_cb_args(struct nfs4_copy_state *cp_state,\n\t\t\t\tstruct cb_offloadargs *args)\n{\n\tcp_state->count = args->wr_count;\n\tcp_state->error = args->error;\n\tif (!args->error) {\n\t\tcp_state->verf.committed = args->wr_writeverf.committed;\n\t\tmemcpy(&cp_state->verf.verifier.data[0],\n\t\t\t&args->wr_writeverf.verifier.data[0],\n\t\t\tNFS4_VERIFIER_SIZE);\n\t}\n}\n\n__be32 nfs4_callback_offload(void *data, void *dummy,\n\t\t\t     struct cb_process_state *cps)\n{\n\tstruct cb_offloadargs *args = data;\n\tstruct nfs_server *server;\n\tstruct nfs4_copy_state *copy, *tmp_copy;\n\tbool found = false;\n\n\tcopy = kzalloc(sizeof(struct nfs4_copy_state), GFP_KERNEL);\n\tif (!copy)\n\t\treturn htonl(NFS4ERR_SERVERFAULT);\n\n\tspin_lock(&cps->clp->cl_lock);\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(server, &cps->clp->cl_superblocks,\n\t\t\t\tclient_link) {\n\t\tlist_for_each_entry(tmp_copy, &server->ss_copies, copies) {\n\t\t\tif (memcmp(args->coa_stateid.other,\n\t\t\t\t\ttmp_copy->stateid.other,\n\t\t\t\t\tsizeof(args->coa_stateid.other)))\n\t\t\t\tcontinue;\n\t\t\tnfs4_copy_cb_args(tmp_copy, args);\n\t\t\tcomplete(&tmp_copy->completion);\n\t\t\tfound = true;\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\trcu_read_unlock();\n\tif (!found) {\n\t\tmemcpy(&copy->stateid, &args->coa_stateid, NFS4_STATEID_SIZE);\n\t\tnfs4_copy_cb_args(copy, args);\n\t\tlist_add_tail(&copy->copies, &cps->clp->pending_cb_stateids);\n\t} else\n\t\tkfree(copy);\n\tspin_unlock(&cps->clp->cl_lock);\n\n\ttrace_nfs4_cb_offload(&args->coa_fh, &args->coa_stateid,\n\t\t\targs->wr_count, args->error,\n\t\t\targs->wr_writeverf.committed);\n\treturn 0;\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}