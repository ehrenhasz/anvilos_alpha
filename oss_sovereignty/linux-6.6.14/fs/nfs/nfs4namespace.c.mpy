{
  "module_name": "nfs4namespace.c",
  "hash_id": "66cae0ca5eb96a5b2b30147b280e7417f55f0514593ae05ed2462fe7e6c3ac6e",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfs/nfs4namespace.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/dcache.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_mount.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/vfs.h>\n#include <linux/inet.h>\n#include \"internal.h\"\n#include \"nfs4_fs.h\"\n#include \"nfs.h\"\n#include \"dns_resolve.h\"\n\n#define NFSDBG_FACILITY\t\tNFSDBG_VFS\n\n \nstatic ssize_t nfs4_pathname_len(const struct nfs4_pathname *pathname)\n{\n\tssize_t len = 0;\n\tint i;\n\n\tfor (i = 0; i < pathname->ncomponents; i++) {\n\t\tconst struct nfs4_string *component = &pathname->components[i];\n\n\t\tif (component->len > NAME_MAX)\n\t\t\tgoto too_long;\n\t\tlen += 1 + component->len;  \n\t\tif (len > PATH_MAX)\n\t\t\tgoto too_long;\n\t}\n\treturn len;\n\ntoo_long:\n\treturn -ENAMETOOLONG;\n}\n\n \nstatic char *nfs4_pathname_string(const struct nfs4_pathname *pathname,\n\t\t\t\t  unsigned short *_len)\n{\n\tssize_t len;\n\tchar *buf, *p;\n\tint i;\n\n\tlen = nfs4_pathname_len(pathname);\n\tif (len < 0)\n\t\treturn ERR_PTR(len);\n\t*_len = len;\n\n\tp = buf = kmalloc(len + 1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (i = 0; i < pathname->ncomponents; i++) {\n\t\tconst struct nfs4_string *component = &pathname->components[i];\n\n\t\t*p++ = '/';\n\t\tmemcpy(p, component->data, component->len);\n\t\tp += component->len;\n\t}\n\n\t*p = 0;\n\treturn buf;\n}\n\n \nstatic char *nfs_path_component(const char *nfspath, const char *end)\n{\n\tchar *p;\n\n\tif (*nfspath == '[') {\n\t\t \n\t\tp = strchr(nfspath, ']');\n\t\tif (p != NULL && ++p < end && *p == ':')\n\t\t\treturn p + 1;\n\t} else {\n\t\t \n\t\tp = strchr(nfspath, ':');\n\t\tif (p != NULL && p < end)\n\t\t\treturn p + 1;\n\t}\n\treturn NULL;\n}\n\n \nstatic char *nfs4_path(struct dentry *dentry, char *buffer, ssize_t buflen)\n{\n\tchar *limit;\n\tchar *path = nfs_path(&limit, dentry, buffer, buflen,\n\t\t\t      NFS_PATH_CANONICAL);\n\tif (!IS_ERR(path)) {\n\t\tchar *path_component = nfs_path_component(path, limit);\n\t\tif (path_component)\n\t\t\treturn path_component;\n\t}\n\treturn path;\n}\n\n \nstatic int nfs4_validate_fspath(struct dentry *dentry,\n\t\t\t\tconst struct nfs4_fs_locations *locations,\n\t\t\t\tstruct nfs_fs_context *ctx)\n{\n\tconst char *path;\n\tchar *fs_path;\n\tunsigned short len;\n\tchar *buf;\n\tint n;\n\n\tbuf = kmalloc(4096, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tpath = nfs4_path(dentry, buf, 4096);\n\tif (IS_ERR(path)) {\n\t\tkfree(buf);\n\t\treturn PTR_ERR(path);\n\t}\n\n\tfs_path = nfs4_pathname_string(&locations->fs_path, &len);\n\tif (IS_ERR(fs_path)) {\n\t\tkfree(buf);\n\t\treturn PTR_ERR(fs_path);\n\t}\n\n\tn = strncmp(path, fs_path, len);\n\tkfree(buf);\n\tkfree(fs_path);\n\tif (n != 0) {\n\t\tdprintk(\"%s: path %s does not begin with fsroot %s\\n\",\n\t\t\t__func__, path, ctx->nfs_server.export_path);\n\t\treturn -ENOENT;\n\t}\n\n\treturn 0;\n}\n\nsize_t nfs_parse_server_name(char *string, size_t len, struct sockaddr_storage *ss,\n\t\t\t     size_t salen, struct net *net, int port)\n{\n\tstruct sockaddr *sa = (struct sockaddr *)ss;\n\tssize_t ret;\n\n\tret = rpc_pton(net, string, len, sa, salen);\n\tif (ret == 0) {\n\t\tret = rpc_uaddr2sockaddr(net, string, len, sa, salen);\n\t\tif (ret == 0) {\n\t\t\tret = nfs_dns_resolve_name(net, string, len, ss, salen);\n\t\t\tif (ret < 0)\n\t\t\t\tret = 0;\n\t\t}\n\t} else if (port) {\n\t\trpc_set_port(sa, port);\n\t}\n\treturn ret;\n}\n\n \nstatic struct rpc_clnt *nfs_find_best_sec(struct rpc_clnt *clnt,\n\t\t\t\t\t  struct nfs_server *server,\n\t\t\t\t\t  struct nfs4_secinfo_flavors *flavors)\n{\n\trpc_authflavor_t pflavor;\n\tstruct nfs4_secinfo4 *secinfo;\n\tunsigned int i;\n\n\tfor (i = 0; i < flavors->num_flavors; i++) {\n\t\tsecinfo = &flavors->flavors[i];\n\n\t\tswitch (secinfo->flavor) {\n\t\tcase RPC_AUTH_NULL:\n\t\tcase RPC_AUTH_UNIX:\n\t\tcase RPC_AUTH_GSS:\n\t\t\tpflavor = rpcauth_get_pseudoflavor(secinfo->flavor,\n\t\t\t\t\t\t\t&secinfo->flavor_info);\n\t\t\t \n\t\t\tif (pflavor != RPC_AUTH_MAXFLAVOR &&\n\t\t\t    nfs_auth_info_match(&server->auth_info, pflavor)) {\n\t\t\t\tstruct rpc_clnt *new;\n\t\t\t\tstruct rpc_cred *cred;\n\n\t\t\t\t \n\t\t\t\tnew = rpc_clone_client_set_auth(clnt, pflavor);\n\t\t\t\tif (IS_ERR(new))\n\t\t\t\t\tcontinue;\n\t\t\t\t \n\t\t\t\tcred = rpcauth_lookupcred(new->cl_auth, 0);\n\t\t\t\tif (IS_ERR(cred)) {\n\t\t\t\t\trpc_shutdown_client(new);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tput_rpccred(cred);\n\t\t\t\treturn new;\n\t\t\t}\n\t\t}\n\t}\n\treturn ERR_PTR(-EPERM);\n}\n\n \nstruct rpc_clnt *\nnfs4_negotiate_security(struct rpc_clnt *clnt, struct inode *inode,\n\t\t\t\t\tconst struct qstr *name)\n{\n\tstruct page *page;\n\tstruct nfs4_secinfo_flavors *flavors;\n\tstruct rpc_clnt *new;\n\tint err;\n\n\tpage = alloc_page(GFP_KERNEL);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tflavors = page_address(page);\n\n\terr = nfs4_proc_secinfo(inode, name, flavors);\n\tif (err < 0) {\n\t\tnew = ERR_PTR(err);\n\t\tgoto out;\n\t}\n\n\tnew = nfs_find_best_sec(clnt, NFS_SERVER(inode), flavors);\n\nout:\n\tput_page(page);\n\treturn new;\n}\n\nstatic int try_location(struct fs_context *fc,\n\t\t\tconst struct nfs4_fs_location *location)\n{\n\tstruct nfs_fs_context *ctx = nfs_fc2context(fc);\n\tunsigned int len, s;\n\tchar *export_path, *source, *p;\n\tint ret = -ENOENT;\n\n\t \n\tlen = 0;\n\tfor (s = 0; s < location->nservers; s++) {\n\t\tconst struct nfs4_string *buf = &location->servers[s];\n\t\tif (buf->len > len)\n\t\t\tlen = buf->len;\n\t}\n\n\tkfree(ctx->nfs_server.hostname);\n\tctx->nfs_server.hostname = kmalloc(len + 1, GFP_KERNEL);\n\tif (!ctx->nfs_server.hostname)\n\t\treturn -ENOMEM;\n\n\texport_path = nfs4_pathname_string(&location->rootpath,\n\t\t\t\t\t   &ctx->nfs_server.export_path_len);\n\tif (IS_ERR(export_path))\n\t\treturn PTR_ERR(export_path);\n\n\tkfree(ctx->nfs_server.export_path);\n\tctx->nfs_server.export_path = export_path;\n\n\tsource = kmalloc(len + 1 + ctx->nfs_server.export_path_len + 1,\n\t\t\t GFP_KERNEL);\n\tif (!source)\n\t\treturn -ENOMEM;\n\n\tkfree(fc->source);\n\tfc->source = source;\n\tfor (s = 0; s < location->nservers; s++) {\n\t\tconst struct nfs4_string *buf = &location->servers[s];\n\n\t\tif (memchr(buf->data, IPV6_SCOPE_DELIMITER, buf->len))\n\t\t\tcontinue;\n\n\t\tctx->nfs_server.addrlen =\n\t\t\tnfs_parse_server_name(buf->data, buf->len,\n\t\t\t\t\t      &ctx->nfs_server._address,\n\t\t\t\t\t      sizeof(ctx->nfs_server._address),\n\t\t\t\t\t      fc->net_ns, 0);\n\t\tif (ctx->nfs_server.addrlen == 0)\n\t\t\tcontinue;\n\n\t\trpc_set_port(&ctx->nfs_server.address, NFS_PORT);\n\n\t\tmemcpy(ctx->nfs_server.hostname, buf->data, buf->len);\n\t\tctx->nfs_server.hostname[buf->len] = '\\0';\n\n\t\tp = source;\n\t\tmemcpy(p, buf->data, buf->len);\n\t\tp += buf->len;\n\t\t*p++ = ':';\n\t\tmemcpy(p, ctx->nfs_server.export_path, ctx->nfs_server.export_path_len);\n\t\tp += ctx->nfs_server.export_path_len;\n\t\t*p = 0;\n\n\t\tret = nfs4_get_referral_tree(fc);\n\t\tif (ret == 0)\n\t\t\treturn 0;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int nfs_follow_referral(struct fs_context *fc,\n\t\t\t       const struct nfs4_fs_locations *locations)\n{\n\tstruct nfs_fs_context *ctx = nfs_fc2context(fc);\n\tint loc, error;\n\n\tif (locations == NULL || locations->nlocations <= 0)\n\t\treturn -ENOENT;\n\n\tdprintk(\"%s: referral at %pd2\\n\", __func__, ctx->clone_data.dentry);\n\n\t \n\terror = nfs4_validate_fspath(ctx->clone_data.dentry, locations, ctx);\n\tif (error < 0)\n\t\treturn error;\n\n\terror = -ENOENT;\n\tfor (loc = 0; loc < locations->nlocations; loc++) {\n\t\tconst struct nfs4_fs_location *location = &locations->locations[loc];\n\n\t\tif (location == NULL || location->nservers <= 0 ||\n\t\t    location->rootpath.ncomponents == 0)\n\t\t\tcontinue;\n\n\t\terror = try_location(fc, location);\n\t\tif (error == 0)\n\t\t\treturn 0;\n\t}\n\n\treturn error;\n}\n\n \nstatic int nfs_do_refmount(struct fs_context *fc, struct rpc_clnt *client)\n{\n\tstruct nfs_fs_context *ctx = nfs_fc2context(fc);\n\tstruct dentry *dentry, *parent;\n\tstruct nfs4_fs_locations *fs_locations = NULL;\n\tstruct page *page;\n\tint err = -ENOMEM;\n\n\t \n\tpage = alloc_page(GFP_KERNEL);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tfs_locations = kmalloc(sizeof(struct nfs4_fs_locations), GFP_KERNEL);\n\tif (!fs_locations)\n\t\tgoto out_free;\n\tfs_locations->fattr = nfs_alloc_fattr();\n\tif (!fs_locations->fattr)\n\t\tgoto out_free_2;\n\n\t \n\tdentry = ctx->clone_data.dentry;\n\tparent = dget_parent(dentry);\n\tdprintk(\"%s: getting locations for %pd2\\n\",\n\t\t__func__, dentry);\n\n\terr = nfs4_proc_fs_locations(client, d_inode(parent), &dentry->d_name, fs_locations, page);\n\tdput(parent);\n\tif (err != 0)\n\t\tgoto out_free_3;\n\n\terr = -ENOENT;\n\tif (fs_locations->nlocations <= 0 ||\n\t    fs_locations->fs_path.ncomponents <= 0)\n\t\tgoto out_free_3;\n\n\terr = nfs_follow_referral(fc, fs_locations);\nout_free_3:\n\tkfree(fs_locations->fattr);\nout_free_2:\n\tkfree(fs_locations);\nout_free:\n\t__free_page(page);\n\treturn err;\n}\n\nint nfs4_submount(struct fs_context *fc, struct nfs_server *server)\n{\n\tstruct nfs_fs_context *ctx = nfs_fc2context(fc);\n\tstruct dentry *dentry = ctx->clone_data.dentry;\n\tstruct dentry *parent = dget_parent(dentry);\n\tstruct inode *dir = d_inode(parent);\n\tstruct rpc_clnt *client;\n\tint ret;\n\n\t \n\tclient = nfs4_proc_lookup_mountpoint(dir, dentry, ctx->mntfh,\n\t\t\t\t\t     ctx->clone_data.fattr);\n\tdput(parent);\n\tif (IS_ERR(client))\n\t\treturn PTR_ERR(client);\n\n\tctx->selected_flavor = client->cl_auth->au_flavor;\n\tif (ctx->clone_data.fattr->valid & NFS_ATTR_FATTR_V4_REFERRAL) {\n\t\tret = nfs_do_refmount(fc, client);\n\t} else {\n\t\tret = nfs_do_submount(fc);\n\t}\n\n\trpc_shutdown_client(client);\n\treturn ret;\n}\n\n \nstatic int nfs4_try_replacing_one_location(struct nfs_server *server,\n\t\tchar *page, char *page2,\n\t\tconst struct nfs4_fs_location *location)\n{\n\tstruct net *net = rpc_net_ns(server->client);\n\tstruct sockaddr_storage *sap;\n\tunsigned int s;\n\tsize_t salen;\n\tint error;\n\n\tsap = kmalloc(sizeof(*sap), GFP_KERNEL);\n\tif (sap == NULL)\n\t\treturn -ENOMEM;\n\n\terror = -ENOENT;\n\tfor (s = 0; s < location->nservers; s++) {\n\t\tconst struct nfs4_string *buf = &location->servers[s];\n\t\tchar *hostname;\n\n\t\tif (buf->len <= 0 || buf->len > PAGE_SIZE)\n\t\t\tcontinue;\n\n\t\tif (memchr(buf->data, IPV6_SCOPE_DELIMITER, buf->len) != NULL)\n\t\t\tcontinue;\n\n\t\tsalen = nfs_parse_server_name(buf->data, buf->len,\n\t\t\t\t\t      sap, sizeof(*sap), net, 0);\n\t\tif (salen == 0)\n\t\t\tcontinue;\n\t\trpc_set_port((struct sockaddr *)sap, NFS_PORT);\n\n\t\terror = -ENOMEM;\n\t\thostname = kmemdup_nul(buf->data, buf->len, GFP_KERNEL);\n\t\tif (hostname == NULL)\n\t\t\tbreak;\n\n\t\terror = nfs4_update_server(server, hostname, sap, salen, net);\n\t\tkfree(hostname);\n\t\tif (error == 0)\n\t\t\tbreak;\n\t}\n\n\tkfree(sap);\n\treturn error;\n}\n\n \nint nfs4_replace_transport(struct nfs_server *server,\n\t\t\t   const struct nfs4_fs_locations *locations)\n{\n\tchar *page = NULL, *page2 = NULL;\n\tint loc, error;\n\n\terror = -ENOENT;\n\tif (locations == NULL || locations->nlocations <= 0)\n\t\tgoto out;\n\n\terror = -ENOMEM;\n\tpage = (char *) __get_free_page(GFP_USER);\n\tif (!page)\n\t\tgoto out;\n\tpage2 = (char *) __get_free_page(GFP_USER);\n\tif (!page2)\n\t\tgoto out;\n\n\tfor (loc = 0; loc < locations->nlocations; loc++) {\n\t\tconst struct nfs4_fs_location *location =\n\t\t\t\t\t\t&locations->locations[loc];\n\n\t\tif (location == NULL || location->nservers <= 0 ||\n\t\t    location->rootpath.ncomponents == 0)\n\t\t\tcontinue;\n\n\t\terror = nfs4_try_replacing_one_location(server, page,\n\t\t\t\t\t\t\tpage2, location);\n\t\tif (error == 0)\n\t\t\tbreak;\n\t}\n\nout:\n\tfree_page((unsigned long)page);\n\tfree_page((unsigned long)page2);\n\treturn error;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}