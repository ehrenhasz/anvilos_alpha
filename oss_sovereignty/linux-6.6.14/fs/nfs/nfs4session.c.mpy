{
  "module_name": "nfs4session.c",
  "hash_id": "edd4a02f3be680150f1d5bbd4596c384e96fb285a74ff6ed291693dd876fe451",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfs/nfs4session.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/nfs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs_fs.h>\n#include <linux/module.h>\n\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include \"callback.h\"\n\n#define NFSDBG_FACILITY\t\tNFSDBG_STATE\n\nstatic void nfs4_init_slot_table(struct nfs4_slot_table *tbl, const char *queue)\n{\n\ttbl->highest_used_slotid = NFS4_NO_SLOT;\n\tspin_lock_init(&tbl->slot_tbl_lock);\n\trpc_init_priority_wait_queue(&tbl->slot_tbl_waitq, queue);\n\tinit_waitqueue_head(&tbl->slot_waitq);\n\tinit_completion(&tbl->complete);\n}\n\n \nstatic void nfs4_shrink_slot_table(struct nfs4_slot_table  *tbl, u32 newsize)\n{\n\tstruct nfs4_slot **p;\n\tif (newsize >= tbl->max_slots)\n\t\treturn;\n\n\tp = &tbl->slots;\n\twhile (newsize--)\n\t\tp = &(*p)->next;\n\twhile (*p) {\n\t\tstruct nfs4_slot *slot = *p;\n\n\t\t*p = slot->next;\n\t\tkfree(slot);\n\t\ttbl->max_slots--;\n\t}\n}\n\n \nvoid nfs4_slot_tbl_drain_complete(struct nfs4_slot_table *tbl)\n{\n\tif (nfs4_slot_tbl_draining(tbl))\n\t\tcomplete(&tbl->complete);\n}\n\n \nvoid nfs4_free_slot(struct nfs4_slot_table *tbl, struct nfs4_slot *slot)\n{\n\tu32 slotid = slot->slot_nr;\n\n\t \n\t__clear_bit(slotid, tbl->used_slots);\n\n\t \n\tif (slotid == tbl->highest_used_slotid) {\n\t\tu32 new_max = find_last_bit(tbl->used_slots, slotid);\n\t\tif (new_max < slotid)\n\t\t\ttbl->highest_used_slotid = new_max;\n\t\telse {\n\t\t\ttbl->highest_used_slotid = NFS4_NO_SLOT;\n\t\t\tnfs4_slot_tbl_drain_complete(tbl);\n\t\t}\n\t}\n\tdprintk(\"%s: slotid %u highest_used_slotid %u\\n\", __func__,\n\t\tslotid, tbl->highest_used_slotid);\n}\n\nstatic struct nfs4_slot *nfs4_new_slot(struct nfs4_slot_table  *tbl,\n\t\tu32 slotid, u32 seq_init, gfp_t gfp_mask)\n{\n\tstruct nfs4_slot *slot;\n\n\tslot = kzalloc(sizeof(*slot), gfp_mask);\n\tif (slot) {\n\t\tslot->table = tbl;\n\t\tslot->slot_nr = slotid;\n\t\tslot->seq_nr = seq_init;\n\t\tslot->seq_nr_highest_sent = seq_init;\n\t\tslot->seq_nr_last_acked = seq_init - 1;\n\t}\n\treturn slot;\n}\n\nstatic struct nfs4_slot *nfs4_find_or_create_slot(struct nfs4_slot_table  *tbl,\n\t\tu32 slotid, u32 seq_init, gfp_t gfp_mask)\n{\n\tstruct nfs4_slot **p, *slot;\n\n\tp = &tbl->slots;\n\tfor (;;) {\n\t\tif (*p == NULL) {\n\t\t\t*p = nfs4_new_slot(tbl, tbl->max_slots,\n\t\t\t\t\tseq_init, gfp_mask);\n\t\t\tif (*p == NULL)\n\t\t\t\tbreak;\n\t\t\ttbl->max_slots++;\n\t\t}\n\t\tslot = *p;\n\t\tif (slot->slot_nr == slotid)\n\t\t\treturn slot;\n\t\tp = &slot->next;\n\t}\n\treturn ERR_PTR(-ENOMEM);\n}\n\nstatic void nfs4_lock_slot(struct nfs4_slot_table *tbl,\n\t\tstruct nfs4_slot *slot)\n{\n\tu32 slotid = slot->slot_nr;\n\n\t__set_bit(slotid, tbl->used_slots);\n\tif (slotid > tbl->highest_used_slotid ||\n\t    tbl->highest_used_slotid == NFS4_NO_SLOT)\n\t\ttbl->highest_used_slotid = slotid;\n\tslot->generation = tbl->generation;\n}\n\n \nbool nfs4_try_to_lock_slot(struct nfs4_slot_table *tbl, struct nfs4_slot *slot)\n{\n\tif (nfs4_test_locked_slot(tbl, slot->slot_nr))\n\t\treturn false;\n\tnfs4_lock_slot(tbl, slot);\n\treturn true;\n}\n\n \nstruct nfs4_slot *nfs4_lookup_slot(struct nfs4_slot_table *tbl, u32 slotid)\n{\n\tif (slotid <= tbl->max_slotid)\n\t\treturn nfs4_find_or_create_slot(tbl, slotid, 0, GFP_NOWAIT);\n\treturn ERR_PTR(-E2BIG);\n}\n\nstatic int nfs4_slot_get_seqid(struct nfs4_slot_table  *tbl, u32 slotid,\n\t\tu32 *seq_nr)\n\t__must_hold(&tbl->slot_tbl_lock)\n{\n\tstruct nfs4_slot *slot;\n\tint ret;\n\n\tslot = nfs4_lookup_slot(tbl, slotid);\n\tret = PTR_ERR_OR_ZERO(slot);\n\tif (!ret)\n\t\t*seq_nr = slot->seq_nr;\n\n\treturn ret;\n}\n\n \nstatic bool nfs4_slot_seqid_in_use(struct nfs4_slot_table *tbl,\n\t\tu32 slotid, u32 seq_nr)\n{\n\tu32 cur_seq = 0;\n\tbool ret = false;\n\n\tspin_lock(&tbl->slot_tbl_lock);\n\tif (nfs4_slot_get_seqid(tbl, slotid, &cur_seq) == 0 &&\n\t    cur_seq == seq_nr && test_bit(slotid, tbl->used_slots))\n\t\tret = true;\n\tspin_unlock(&tbl->slot_tbl_lock);\n\treturn ret;\n}\n\n \nint nfs4_slot_wait_on_seqid(struct nfs4_slot_table *tbl,\n\t\tu32 slotid, u32 seq_nr,\n\t\tunsigned long timeout)\n{\n\tif (wait_event_timeout(tbl->slot_waitq,\n\t\t\t!nfs4_slot_seqid_in_use(tbl, slotid, seq_nr),\n\t\t\ttimeout) == 0)\n\t\treturn -ETIMEDOUT;\n\treturn 0;\n}\n\n \nstruct nfs4_slot *nfs4_alloc_slot(struct nfs4_slot_table *tbl)\n{\n\tstruct nfs4_slot *ret = ERR_PTR(-EBUSY);\n\tu32 slotid;\n\n\tdprintk(\"--> %s used_slots=%04lx highest_used=%u max_slots=%u\\n\",\n\t\t__func__, tbl->used_slots[0], tbl->highest_used_slotid,\n\t\ttbl->max_slotid + 1);\n\tslotid = find_first_zero_bit(tbl->used_slots, tbl->max_slotid + 1);\n\tif (slotid <= tbl->max_slotid) {\n\t\tret = nfs4_find_or_create_slot(tbl, slotid, 1, GFP_NOWAIT);\n\t\tif (!IS_ERR(ret))\n\t\t\tnfs4_lock_slot(tbl, ret);\n\t}\n\tdprintk(\"<-- %s used_slots=%04lx highest_used=%u slotid=%u\\n\",\n\t\t__func__, tbl->used_slots[0], tbl->highest_used_slotid,\n\t\t!IS_ERR(ret) ? ret->slot_nr : NFS4_NO_SLOT);\n\treturn ret;\n}\n\nstatic int nfs4_grow_slot_table(struct nfs4_slot_table *tbl,\n\t\t u32 max_reqs, u32 ivalue)\n{\n\tif (max_reqs <= tbl->max_slots)\n\t\treturn 0;\n\tif (!IS_ERR(nfs4_find_or_create_slot(tbl, max_reqs - 1, ivalue, GFP_NOFS)))\n\t\treturn 0;\n\treturn -ENOMEM;\n}\n\nstatic void nfs4_reset_slot_table(struct nfs4_slot_table *tbl,\n\t\tu32 server_highest_slotid,\n\t\tu32 ivalue)\n{\n\tstruct nfs4_slot **p;\n\n\tnfs4_shrink_slot_table(tbl, server_highest_slotid + 1);\n\tp = &tbl->slots;\n\twhile (*p) {\n\t\t(*p)->seq_nr = ivalue;\n\t\t(*p)->seq_nr_highest_sent = ivalue;\n\t\t(*p)->seq_nr_last_acked = ivalue - 1;\n\t\tp = &(*p)->next;\n\t}\n\ttbl->highest_used_slotid = NFS4_NO_SLOT;\n\ttbl->target_highest_slotid = server_highest_slotid;\n\ttbl->server_highest_slotid = server_highest_slotid;\n\ttbl->d_target_highest_slotid = 0;\n\ttbl->d2_target_highest_slotid = 0;\n\ttbl->max_slotid = server_highest_slotid;\n}\n\n \nstatic int nfs4_realloc_slot_table(struct nfs4_slot_table *tbl,\n\t\tu32 max_reqs, u32 ivalue)\n{\n\tint ret;\n\n\tdprintk(\"--> %s: max_reqs=%u, tbl->max_slots %u\\n\", __func__,\n\t\tmax_reqs, tbl->max_slots);\n\n\tif (max_reqs > NFS4_MAX_SLOT_TABLE)\n\t\tmax_reqs = NFS4_MAX_SLOT_TABLE;\n\n\tret = nfs4_grow_slot_table(tbl, max_reqs, ivalue);\n\tif (ret)\n\t\tgoto out;\n\n\tspin_lock(&tbl->slot_tbl_lock);\n\tnfs4_reset_slot_table(tbl, max_reqs - 1, ivalue);\n\tspin_unlock(&tbl->slot_tbl_lock);\n\n\tdprintk(\"%s: tbl=%p slots=%p max_slots=%u\\n\", __func__,\n\t\ttbl, tbl->slots, tbl->max_slots);\nout:\n\tdprintk(\"<-- %s: return %d\\n\", __func__, ret);\n\treturn ret;\n}\n\n \nstatic void nfs4_release_slot_table(struct nfs4_slot_table *tbl)\n{\n\tnfs4_shrink_slot_table(tbl, 0);\n}\n\n \nvoid nfs4_shutdown_slot_table(struct nfs4_slot_table *tbl)\n{\n\tnfs4_release_slot_table(tbl);\n\trpc_destroy_wait_queue(&tbl->slot_tbl_waitq);\n}\n\n \nint nfs4_setup_slot_table(struct nfs4_slot_table *tbl, unsigned int max_reqs,\n\t\tconst char *queue)\n{\n\tnfs4_init_slot_table(tbl, queue);\n\treturn nfs4_realloc_slot_table(tbl, max_reqs, 0);\n}\n\nstatic bool nfs41_assign_slot(struct rpc_task *task, void *pslot)\n{\n\tstruct nfs4_sequence_args *args = task->tk_msg.rpc_argp;\n\tstruct nfs4_sequence_res *res = task->tk_msg.rpc_resp;\n\tstruct nfs4_slot *slot = pslot;\n\tstruct nfs4_slot_table *tbl = slot->table;\n\n\tif (nfs4_slot_tbl_draining(tbl) && !args->sa_privileged)\n\t\treturn false;\n\tslot->generation = tbl->generation;\n\targs->sa_slot = slot;\n\tres->sr_timestamp = jiffies;\n\tres->sr_slot = slot;\n\tres->sr_status_flags = 0;\n\tres->sr_status = 1;\n\treturn true;\n}\n\nstatic bool __nfs41_wake_and_assign_slot(struct nfs4_slot_table *tbl,\n\t\tstruct nfs4_slot *slot)\n{\n\tif (rpc_wake_up_first(&tbl->slot_tbl_waitq, nfs41_assign_slot, slot))\n\t\treturn true;\n\treturn false;\n}\n\nbool nfs41_wake_and_assign_slot(struct nfs4_slot_table *tbl,\n\t\tstruct nfs4_slot *slot)\n{\n\tif (slot->slot_nr > tbl->max_slotid)\n\t\treturn false;\n\treturn __nfs41_wake_and_assign_slot(tbl, slot);\n}\n\nstatic bool nfs41_try_wake_next_slot_table_entry(struct nfs4_slot_table *tbl)\n{\n\tstruct nfs4_slot *slot = nfs4_alloc_slot(tbl);\n\tif (!IS_ERR(slot)) {\n\t\tbool ret = __nfs41_wake_and_assign_slot(tbl, slot);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tnfs4_free_slot(tbl, slot);\n\t}\n\treturn false;\n}\n\nvoid nfs41_wake_slot_table(struct nfs4_slot_table *tbl)\n{\n\tfor (;;) {\n\t\tif (!nfs41_try_wake_next_slot_table_entry(tbl))\n\t\t\tbreak;\n\t}\n}\n\n#if defined(CONFIG_NFS_V4_1)\n\nstatic void nfs41_set_max_slotid_locked(struct nfs4_slot_table *tbl,\n\t\tu32 target_highest_slotid)\n{\n\tu32 max_slotid;\n\n\tmax_slotid = min(NFS4_MAX_SLOT_TABLE - 1, target_highest_slotid);\n\tif (max_slotid > tbl->server_highest_slotid)\n\t\tmax_slotid = tbl->server_highest_slotid;\n\tif (max_slotid > tbl->target_highest_slotid)\n\t\tmax_slotid = tbl->target_highest_slotid;\n\ttbl->max_slotid = max_slotid;\n\tnfs41_wake_slot_table(tbl);\n}\n\n \nstatic void nfs41_set_target_slotid_locked(struct nfs4_slot_table *tbl,\n\t\tu32 target_highest_slotid)\n{\n\tif (tbl->target_highest_slotid == target_highest_slotid)\n\t\treturn;\n\ttbl->target_highest_slotid = target_highest_slotid;\n\ttbl->generation++;\n}\n\nvoid nfs41_set_target_slotid(struct nfs4_slot_table *tbl,\n\t\tu32 target_highest_slotid)\n{\n\tspin_lock(&tbl->slot_tbl_lock);\n\tnfs41_set_target_slotid_locked(tbl, target_highest_slotid);\n\ttbl->d_target_highest_slotid = 0;\n\ttbl->d2_target_highest_slotid = 0;\n\tnfs41_set_max_slotid_locked(tbl, target_highest_slotid);\n\tspin_unlock(&tbl->slot_tbl_lock);\n}\n\nstatic void nfs41_set_server_slotid_locked(struct nfs4_slot_table *tbl,\n\t\tu32 highest_slotid)\n{\n\tif (tbl->server_highest_slotid == highest_slotid)\n\t\treturn;\n\tif (tbl->highest_used_slotid > highest_slotid)\n\t\treturn;\n\t \n\tnfs4_shrink_slot_table(tbl, highest_slotid + 1);\n\ttbl->server_highest_slotid = highest_slotid;\n}\n\nstatic s32 nfs41_derivative_target_slotid(s32 s1, s32 s2)\n{\n\ts1 -= s2;\n\tif (s1 == 0)\n\t\treturn 0;\n\tif (s1 < 0)\n\t\treturn (s1 - 1) >> 1;\n\treturn (s1 + 1) >> 1;\n}\n\nstatic int nfs41_sign_s32(s32 s1)\n{\n\tif (s1 > 0)\n\t\treturn 1;\n\tif (s1 < 0)\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic bool nfs41_same_sign_or_zero_s32(s32 s1, s32 s2)\n{\n\tif (!s1 || !s2)\n\t\treturn true;\n\treturn nfs41_sign_s32(s1) == nfs41_sign_s32(s2);\n}\n\n \nstatic bool nfs41_is_outlier_target_slotid(struct nfs4_slot_table *tbl,\n\t\tu32 new_target)\n{\n\ts32 d_target, d2_target;\n\tbool ret = true;\n\n\td_target = nfs41_derivative_target_slotid(new_target,\n\t\t\ttbl->target_highest_slotid);\n\td2_target = nfs41_derivative_target_slotid(d_target,\n\t\t\ttbl->d_target_highest_slotid);\n\t \n\tif (nfs41_same_sign_or_zero_s32(d_target, tbl->d_target_highest_slotid))\n\t\tret = false;\n\t \n\tif (nfs41_same_sign_or_zero_s32(d2_target, tbl->d2_target_highest_slotid))\n\t\tret = false;\n\ttbl->d_target_highest_slotid = d_target;\n\ttbl->d2_target_highest_slotid = d2_target;\n\treturn ret;\n}\n\nvoid nfs41_update_target_slotid(struct nfs4_slot_table *tbl,\n\t\tstruct nfs4_slot *slot,\n\t\tstruct nfs4_sequence_res *res)\n{\n\tu32 target_highest_slotid = min(res->sr_target_highest_slotid,\n\t\t\t\t\tNFS4_MAX_SLOTID);\n\tu32 highest_slotid = min(res->sr_highest_slotid, NFS4_MAX_SLOTID);\n\n\tspin_lock(&tbl->slot_tbl_lock);\n\tif (!nfs41_is_outlier_target_slotid(tbl, target_highest_slotid))\n\t\tnfs41_set_target_slotid_locked(tbl, target_highest_slotid);\n\tif (tbl->generation == slot->generation)\n\t\tnfs41_set_server_slotid_locked(tbl, highest_slotid);\n\tnfs41_set_max_slotid_locked(tbl, target_highest_slotid);\n\tspin_unlock(&tbl->slot_tbl_lock);\n}\n\nstatic void nfs4_release_session_slot_tables(struct nfs4_session *session)\n{\n\tnfs4_release_slot_table(&session->fc_slot_table);\n\tnfs4_release_slot_table(&session->bc_slot_table);\n}\n\n \nint nfs4_setup_session_slot_tables(struct nfs4_session *ses)\n{\n\tstruct nfs4_slot_table *tbl;\n\tint status;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\t \n\ttbl = &ses->fc_slot_table;\n\ttbl->session = ses;\n\tstatus = nfs4_realloc_slot_table(tbl, ses->fc_attrs.max_reqs, 1);\n\tif (status || !(ses->flags & SESSION4_BACK_CHAN))  \n\t\treturn status;\n\t \n\ttbl = &ses->bc_slot_table;\n\ttbl->session = ses;\n\tstatus = nfs4_realloc_slot_table(tbl, ses->bc_attrs.max_reqs, 0);\n\tif (status && tbl->slots == NULL)\n\t\t \n\t\tnfs4_release_session_slot_tables(ses);\n\treturn status;\n}\n\nstruct nfs4_session *nfs4_alloc_session(struct nfs_client *clp)\n{\n\tstruct nfs4_session *session;\n\n\tsession = kzalloc(sizeof(struct nfs4_session), GFP_NOFS);\n\tif (!session)\n\t\treturn NULL;\n\n\tnfs4_init_slot_table(&session->fc_slot_table, \"ForeChannel Slot table\");\n\tnfs4_init_slot_table(&session->bc_slot_table, \"BackChannel Slot table\");\n\tsession->session_state = 1<<NFS4_SESSION_INITING;\n\n\tsession->clp = clp;\n\treturn session;\n}\n\nstatic void nfs4_destroy_session_slot_tables(struct nfs4_session *session)\n{\n\tnfs4_shutdown_slot_table(&session->fc_slot_table);\n\tnfs4_shutdown_slot_table(&session->bc_slot_table);\n}\n\nvoid nfs4_destroy_session(struct nfs4_session *session)\n{\n\tstruct rpc_xprt *xprt;\n\tconst struct cred *cred;\n\n\tcred = nfs4_get_clid_cred(session->clp);\n\tnfs4_proc_destroy_session(session, cred);\n\tput_cred(cred);\n\n\trcu_read_lock();\n\txprt = rcu_dereference(session->clp->cl_rpcclient->cl_xprt);\n\trcu_read_unlock();\n\tdprintk(\"%s Destroy backchannel for xprt %p\\n\",\n\t\t__func__, xprt);\n\txprt_destroy_backchannel(xprt, NFS41_BC_MIN_CALLBACKS);\n\tnfs4_destroy_session_slot_tables(session);\n\tkfree(session);\n}\n\n \nstatic int nfs41_check_session_ready(struct nfs_client *clp)\n{\n\tint ret;\n\t\n\tif (clp->cl_cons_state == NFS_CS_SESSION_INITING) {\n\t\tret = nfs4_client_recover_expired_lease(clp);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tif (clp->cl_cons_state < NFS_CS_READY)\n\t\treturn -EPROTONOSUPPORT;\n\tsmp_rmb();\n\treturn 0;\n}\n\nint nfs4_init_session(struct nfs_client *clp)\n{\n\tif (!nfs4_has_session(clp))\n\t\treturn 0;\n\n\tclear_bit(NFS4_SESSION_INITING, &clp->cl_session->session_state);\n\treturn nfs41_check_session_ready(clp);\n}\n\nint nfs4_init_ds_session(struct nfs_client *clp, unsigned long lease_time)\n{\n\tstruct nfs4_session *session = clp->cl_session;\n\tint ret;\n\n\tspin_lock(&clp->cl_lock);\n\tif (test_and_clear_bit(NFS4_SESSION_INITING, &session->session_state)) {\n\t\t \n\t\tclp->cl_lease_time = lease_time;\n\t\tclp->cl_last_renewal = jiffies;\n\t}\n\tspin_unlock(&clp->cl_lock);\n\n\tret = nfs41_check_session_ready(clp);\n\tif (ret)\n\t\treturn ret;\n\t \n\tif (!is_ds_client(clp))\n\t\treturn -ENODEV;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nfs4_init_ds_session);\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}