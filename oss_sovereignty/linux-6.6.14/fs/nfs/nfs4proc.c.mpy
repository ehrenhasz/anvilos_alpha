{
  "module_name": "nfs4proc.c",
  "hash_id": "cee2fc25f19f24436e0c312c58aec7f5a880eee0d53648e52fa64c2959af902a",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfs/nfs4proc.c",
  "human_readable_source": " \n\n#include <linux/mm.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/nfs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/xattr.h>\n#include <linux/utsname.h>\n#include <linux/freezer.h>\n#include <linux/iversion.h>\n\n#include \"nfs4_fs.h\"\n#include \"delegation.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"callback.h\"\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"sysfs.h\"\n#include \"nfs4idmap.h\"\n#include \"nfs4session.h\"\n#include \"fscache.h\"\n#include \"nfs42.h\"\n\n#include \"nfs4trace.h\"\n\n#define NFSDBG_FACILITY\t\tNFSDBG_PROC\n\n#define NFS4_BITMASK_SZ\t\t3\n\n#define NFS4_POLL_RETRY_MIN\t(HZ/10)\n#define NFS4_POLL_RETRY_MAX\t(15*HZ)\n\n \n#define NFS4_VALID_ATTRS (ATTR_MODE \\\n\t| ATTR_UID \\\n\t| ATTR_GID \\\n\t| ATTR_SIZE \\\n\t| ATTR_ATIME \\\n\t| ATTR_MTIME \\\n\t| ATTR_CTIME \\\n\t| ATTR_ATIME_SET \\\n\t| ATTR_MTIME_SET)\n\nstruct nfs4_opendata;\nstatic int _nfs4_recover_proc_open(struct nfs4_opendata *data);\nstatic int nfs4_do_fsinfo(struct nfs_server *, struct nfs_fh *, struct nfs_fsinfo *);\nstatic void nfs_fixup_referral_attributes(struct nfs_fattr *fattr);\nstatic int _nfs4_proc_getattr(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\t\t      struct nfs_fattr *fattr, struct inode *inode);\nstatic int nfs4_do_setattr(struct inode *inode, const struct cred *cred,\n\t\t\t    struct nfs_fattr *fattr, struct iattr *sattr,\n\t\t\t    struct nfs_open_context *ctx, struct nfs4_label *ilabel);\n#ifdef CONFIG_NFS_V4_1\nstatic struct rpc_task *_nfs41_proc_sequence(struct nfs_client *clp,\n\t\tconst struct cred *cred,\n\t\tstruct nfs4_slot *slot,\n\t\tbool is_privileged);\nstatic int nfs41_test_stateid(struct nfs_server *, nfs4_stateid *,\n\t\tconst struct cred *);\nstatic int nfs41_free_stateid(struct nfs_server *, const nfs4_stateid *,\n\t\tconst struct cred *, bool);\n#endif\n\n#ifdef CONFIG_NFS_V4_SECURITY_LABEL\nstatic inline struct nfs4_label *\nnfs4_label_init_security(struct inode *dir, struct dentry *dentry,\n\tstruct iattr *sattr, struct nfs4_label *label)\n{\n\tint err;\n\n\tif (label == NULL)\n\t\treturn NULL;\n\n\tif (nfs_server_capable(dir, NFS_CAP_SECURITY_LABEL) == 0)\n\t\treturn NULL;\n\n\tlabel->lfs = 0;\n\tlabel->pi = 0;\n\tlabel->len = 0;\n\tlabel->label = NULL;\n\n\terr = security_dentry_init_security(dentry, sattr->ia_mode,\n\t\t\t\t&dentry->d_name, NULL,\n\t\t\t\t(void **)&label->label, &label->len);\n\tif (err == 0)\n\t\treturn label;\n\n\treturn NULL;\n}\nstatic inline void\nnfs4_label_release_security(struct nfs4_label *label)\n{\n\tif (label)\n\t\tsecurity_release_secctx(label->label, label->len);\n}\nstatic inline u32 *nfs4_bitmask(struct nfs_server *server, struct nfs4_label *label)\n{\n\tif (label)\n\t\treturn server->attr_bitmask;\n\n\treturn server->attr_bitmask_nl;\n}\n#else\nstatic inline struct nfs4_label *\nnfs4_label_init_security(struct inode *dir, struct dentry *dentry,\n\tstruct iattr *sattr, struct nfs4_label *l)\n{ return NULL; }\nstatic inline void\nnfs4_label_release_security(struct nfs4_label *label)\n{ return; }\nstatic inline u32 *\nnfs4_bitmask(struct nfs_server *server, struct nfs4_label *label)\n{ return server->attr_bitmask; }\n#endif\n\n \nstatic int nfs4_map_errors(int err)\n{\n\tif (err >= -1000)\n\t\treturn err;\n\tswitch (err) {\n\tcase -NFS4ERR_RESOURCE:\n\tcase -NFS4ERR_LAYOUTTRYLATER:\n\tcase -NFS4ERR_RECALLCONFLICT:\n\tcase -NFS4ERR_RETURNCONFLICT:\n\t\treturn -EREMOTEIO;\n\tcase -NFS4ERR_WRONGSEC:\n\tcase -NFS4ERR_WRONG_CRED:\n\t\treturn -EPERM;\n\tcase -NFS4ERR_BADOWNER:\n\tcase -NFS4ERR_BADNAME:\n\t\treturn -EINVAL;\n\tcase -NFS4ERR_SHARE_DENIED:\n\t\treturn -EACCES;\n\tcase -NFS4ERR_MINOR_VERS_MISMATCH:\n\t\treturn -EPROTONOSUPPORT;\n\tcase -NFS4ERR_FILE_OPEN:\n\t\treturn -EBUSY;\n\tcase -NFS4ERR_NOT_SAME:\n\t\treturn -ENOTSYNC;\n\tdefault:\n\t\tdprintk(\"%s could not handle NFSv4 error %d\\n\",\n\t\t\t\t__func__, -err);\n\t\tbreak;\n\t}\n\treturn -EIO;\n}\n\n \nconst u32 nfs4_fattr_bitmap[3] = {\n\tFATTR4_WORD0_TYPE\n\t| FATTR4_WORD0_CHANGE\n\t| FATTR4_WORD0_SIZE\n\t| FATTR4_WORD0_FSID\n\t| FATTR4_WORD0_FILEID,\n\tFATTR4_WORD1_MODE\n\t| FATTR4_WORD1_NUMLINKS\n\t| FATTR4_WORD1_OWNER\n\t| FATTR4_WORD1_OWNER_GROUP\n\t| FATTR4_WORD1_RAWDEV\n\t| FATTR4_WORD1_SPACE_USED\n\t| FATTR4_WORD1_TIME_ACCESS\n\t| FATTR4_WORD1_TIME_METADATA\n\t| FATTR4_WORD1_TIME_MODIFY\n\t| FATTR4_WORD1_MOUNTED_ON_FILEID,\n#ifdef CONFIG_NFS_V4_SECURITY_LABEL\n\tFATTR4_WORD2_SECURITY_LABEL\n#endif\n};\n\nstatic const u32 nfs4_pnfs_open_bitmap[3] = {\n\tFATTR4_WORD0_TYPE\n\t| FATTR4_WORD0_CHANGE\n\t| FATTR4_WORD0_SIZE\n\t| FATTR4_WORD0_FSID\n\t| FATTR4_WORD0_FILEID,\n\tFATTR4_WORD1_MODE\n\t| FATTR4_WORD1_NUMLINKS\n\t| FATTR4_WORD1_OWNER\n\t| FATTR4_WORD1_OWNER_GROUP\n\t| FATTR4_WORD1_RAWDEV\n\t| FATTR4_WORD1_SPACE_USED\n\t| FATTR4_WORD1_TIME_ACCESS\n\t| FATTR4_WORD1_TIME_METADATA\n\t| FATTR4_WORD1_TIME_MODIFY,\n\tFATTR4_WORD2_MDSTHRESHOLD\n#ifdef CONFIG_NFS_V4_SECURITY_LABEL\n\t| FATTR4_WORD2_SECURITY_LABEL\n#endif\n};\n\nstatic const u32 nfs4_open_noattr_bitmap[3] = {\n\tFATTR4_WORD0_TYPE\n\t| FATTR4_WORD0_FILEID,\n};\n\nconst u32 nfs4_statfs_bitmap[3] = {\n\tFATTR4_WORD0_FILES_AVAIL\n\t| FATTR4_WORD0_FILES_FREE\n\t| FATTR4_WORD0_FILES_TOTAL,\n\tFATTR4_WORD1_SPACE_AVAIL\n\t| FATTR4_WORD1_SPACE_FREE\n\t| FATTR4_WORD1_SPACE_TOTAL\n};\n\nconst u32 nfs4_pathconf_bitmap[3] = {\n\tFATTR4_WORD0_MAXLINK\n\t| FATTR4_WORD0_MAXNAME,\n\t0\n};\n\nconst u32 nfs4_fsinfo_bitmap[3] = { FATTR4_WORD0_MAXFILESIZE\n\t\t\t| FATTR4_WORD0_MAXREAD\n\t\t\t| FATTR4_WORD0_MAXWRITE\n\t\t\t| FATTR4_WORD0_LEASE_TIME,\n\t\t\tFATTR4_WORD1_TIME_DELTA\n\t\t\t| FATTR4_WORD1_FS_LAYOUT_TYPES,\n\t\t\tFATTR4_WORD2_LAYOUT_BLKSIZE\n\t\t\t| FATTR4_WORD2_CLONE_BLKSIZE\n\t\t\t| FATTR4_WORD2_CHANGE_ATTR_TYPE\n\t\t\t| FATTR4_WORD2_XATTR_SUPPORT\n};\n\nconst u32 nfs4_fs_locations_bitmap[3] = {\n\tFATTR4_WORD0_CHANGE\n\t| FATTR4_WORD0_SIZE\n\t| FATTR4_WORD0_FSID\n\t| FATTR4_WORD0_FILEID\n\t| FATTR4_WORD0_FS_LOCATIONS,\n\tFATTR4_WORD1_OWNER\n\t| FATTR4_WORD1_OWNER_GROUP\n\t| FATTR4_WORD1_RAWDEV\n\t| FATTR4_WORD1_SPACE_USED\n\t| FATTR4_WORD1_TIME_ACCESS\n\t| FATTR4_WORD1_TIME_METADATA\n\t| FATTR4_WORD1_TIME_MODIFY\n\t| FATTR4_WORD1_MOUNTED_ON_FILEID,\n};\n\nstatic void nfs4_bitmap_copy_adjust(__u32 *dst, const __u32 *src,\n\t\t\t\t    struct inode *inode, unsigned long flags)\n{\n\tunsigned long cache_validity;\n\n\tmemcpy(dst, src, NFS4_BITMASK_SZ*sizeof(*dst));\n\tif (!inode || !nfs4_have_delegation(inode, FMODE_READ))\n\t\treturn;\n\n\tcache_validity = READ_ONCE(NFS_I(inode)->cache_validity) | flags;\n\n\t \n\tdst[1] &= ~FATTR4_WORD1_RAWDEV;\n\tif (!(cache_validity & NFS_INO_INVALID_SIZE))\n\t\tdst[0] &= ~FATTR4_WORD0_SIZE;\n\n\tif (!(cache_validity & NFS_INO_INVALID_CHANGE))\n\t\tdst[0] &= ~FATTR4_WORD0_CHANGE;\n\n\tif (!(cache_validity & NFS_INO_INVALID_MODE))\n\t\tdst[1] &= ~FATTR4_WORD1_MODE;\n\tif (!(cache_validity & NFS_INO_INVALID_OTHER))\n\t\tdst[1] &= ~(FATTR4_WORD1_OWNER | FATTR4_WORD1_OWNER_GROUP);\n}\n\nstatic void nfs4_setup_readdir(u64 cookie, __be32 *verifier, struct dentry *dentry,\n\t\tstruct nfs4_readdir_arg *readdir)\n{\n\tunsigned int attrs = FATTR4_WORD0_FILEID | FATTR4_WORD0_TYPE;\n\t__be32 *start, *p;\n\n\tif (cookie > 2) {\n\t\treaddir->cookie = cookie;\n\t\tmemcpy(&readdir->verifier, verifier, sizeof(readdir->verifier));\n\t\treturn;\n\t}\n\n\treaddir->cookie = 0;\n\tmemset(&readdir->verifier, 0, sizeof(readdir->verifier));\n\tif (cookie == 2)\n\t\treturn;\n\t\n\t \n\tstart = p = kmap_atomic(*readdir->pages);\n\t\n\tif (cookie == 0) {\n\t\t*p++ = xdr_one;                                   \n\t\t*p++ = xdr_zero;                    \n\t\t*p++ = xdr_one;                    \n\t\t*p++ = xdr_one;                              \n\t\tmemcpy(p, \".\\0\\0\\0\", 4);                         \n\t\tp++;\n\t\t*p++ = xdr_one;                          \n\t\t*p++ = htonl(attrs);                            \n\t\t*p++ = htonl(12);              \n\t\t*p++ = htonl(NF4DIR);\n\t\tp = xdr_encode_hyper(p, NFS_FILEID(d_inode(dentry)));\n\t}\n\t\n\t*p++ = xdr_one;                                   \n\t*p++ = xdr_zero;                    \n\t*p++ = xdr_two;                    \n\t*p++ = xdr_two;                              \n\tmemcpy(p, \"..\\0\\0\", 4);                          \n\tp++;\n\t*p++ = xdr_one;                          \n\t*p++ = htonl(attrs);                            \n\t*p++ = htonl(12);              \n\t*p++ = htonl(NF4DIR);\n\tp = xdr_encode_hyper(p, NFS_FILEID(d_inode(dentry->d_parent)));\n\n\treaddir->pgbase = (char *)p - (char *)start;\n\treaddir->count -= readdir->pgbase;\n\tkunmap_atomic(start);\n}\n\nstatic void nfs4_fattr_set_prechange(struct nfs_fattr *fattr, u64 version)\n{\n\tif (!(fattr->valid & NFS_ATTR_FATTR_PRECHANGE)) {\n\t\tfattr->pre_change_attr = version;\n\t\tfattr->valid |= NFS_ATTR_FATTR_PRECHANGE;\n\t}\n}\n\nstatic void nfs4_test_and_free_stateid(struct nfs_server *server,\n\t\tnfs4_stateid *stateid,\n\t\tconst struct cred *cred)\n{\n\tconst struct nfs4_minor_version_ops *ops = server->nfs_client->cl_mvops;\n\n\tops->test_and_free_expired(server, stateid, cred);\n}\n\nstatic void __nfs4_free_revoked_stateid(struct nfs_server *server,\n\t\tnfs4_stateid *stateid,\n\t\tconst struct cred *cred)\n{\n\tstateid->type = NFS4_REVOKED_STATEID_TYPE;\n\tnfs4_test_and_free_stateid(server, stateid, cred);\n}\n\nstatic void nfs4_free_revoked_stateid(struct nfs_server *server,\n\t\tconst nfs4_stateid *stateid,\n\t\tconst struct cred *cred)\n{\n\tnfs4_stateid tmp;\n\n\tnfs4_stateid_copy(&tmp, stateid);\n\t__nfs4_free_revoked_stateid(server, &tmp, cred);\n}\n\nstatic long nfs4_update_delay(long *timeout)\n{\n\tlong ret;\n\tif (!timeout)\n\t\treturn NFS4_POLL_RETRY_MAX;\n\tif (*timeout <= 0)\n\t\t*timeout = NFS4_POLL_RETRY_MIN;\n\tif (*timeout > NFS4_POLL_RETRY_MAX)\n\t\t*timeout = NFS4_POLL_RETRY_MAX;\n\tret = *timeout;\n\t*timeout <<= 1;\n\treturn ret;\n}\n\nstatic int nfs4_delay_killable(long *timeout)\n{\n\tmight_sleep();\n\n\t__set_current_state(TASK_KILLABLE|TASK_FREEZABLE_UNSAFE);\n\tschedule_timeout(nfs4_update_delay(timeout));\n\tif (!__fatal_signal_pending(current))\n\t\treturn 0;\n\treturn -EINTR;\n}\n\nstatic int nfs4_delay_interruptible(long *timeout)\n{\n\tmight_sleep();\n\n\t__set_current_state(TASK_INTERRUPTIBLE|TASK_FREEZABLE_UNSAFE);\n\tschedule_timeout(nfs4_update_delay(timeout));\n\tif (!signal_pending(current))\n\t\treturn 0;\n\treturn __fatal_signal_pending(current) ? -EINTR :-ERESTARTSYS;\n}\n\nstatic int nfs4_delay(long *timeout, bool interruptible)\n{\n\tif (interruptible)\n\t\treturn nfs4_delay_interruptible(timeout);\n\treturn nfs4_delay_killable(timeout);\n}\n\nstatic const nfs4_stateid *\nnfs4_recoverable_stateid(const nfs4_stateid *stateid)\n{\n\tif (!stateid)\n\t\treturn NULL;\n\tswitch (stateid->type) {\n\tcase NFS4_OPEN_STATEID_TYPE:\n\tcase NFS4_LOCK_STATEID_TYPE:\n\tcase NFS4_DELEGATION_STATEID_TYPE:\n\t\treturn stateid;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn NULL;\n}\n\n \nstatic int nfs4_do_handle_exception(struct nfs_server *server,\n\t\tint errorcode, struct nfs4_exception *exception)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct nfs4_state *state = exception->state;\n\tconst nfs4_stateid *stateid;\n\tstruct inode *inode = exception->inode;\n\tint ret = errorcode;\n\n\texception->delay = 0;\n\texception->recovering = 0;\n\texception->retry = 0;\n\n\tstateid = nfs4_recoverable_stateid(exception->stateid);\n\tif (stateid == NULL && state != NULL)\n\t\tstateid = nfs4_recoverable_stateid(&state->stateid);\n\n\tswitch(errorcode) {\n\t\tcase 0:\n\t\t\treturn 0;\n\t\tcase -NFS4ERR_BADHANDLE:\n\t\tcase -ESTALE:\n\t\t\tif (inode != NULL && S_ISREG(inode->i_mode))\n\t\t\t\tpnfs_destroy_layout(NFS_I(inode));\n\t\t\tbreak;\n\t\tcase -NFS4ERR_DELEG_REVOKED:\n\t\tcase -NFS4ERR_ADMIN_REVOKED:\n\t\tcase -NFS4ERR_EXPIRED:\n\t\tcase -NFS4ERR_BAD_STATEID:\n\t\tcase -NFS4ERR_PARTNER_NO_AUTH:\n\t\t\tif (inode != NULL && stateid != NULL) {\n\t\t\t\tnfs_inode_find_state_and_recover(inode,\n\t\t\t\t\t\tstateid);\n\t\t\t\tgoto wait_on_recovery;\n\t\t\t}\n\t\t\tfallthrough;\n\t\tcase -NFS4ERR_OPENMODE:\n\t\t\tif (inode) {\n\t\t\t\tint err;\n\n\t\t\t\terr = nfs_async_inode_return_delegation(inode,\n\t\t\t\t\t\tstateid);\n\t\t\t\tif (err == 0)\n\t\t\t\t\tgoto wait_on_recovery;\n\t\t\t\tif (stateid != NULL && stateid->type == NFS4_DELEGATION_STATEID_TYPE) {\n\t\t\t\t\texception->retry = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (state == NULL)\n\t\t\t\tbreak;\n\t\t\tret = nfs4_schedule_stateid_recovery(server, state);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t\tgoto wait_on_recovery;\n\t\tcase -NFS4ERR_STALE_STATEID:\n\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\t\tnfs4_schedule_lease_recovery(clp);\n\t\t\tgoto wait_on_recovery;\n\t\tcase -NFS4ERR_MOVED:\n\t\t\tret = nfs4_schedule_migration_recovery(server);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t\tgoto wait_on_recovery;\n\t\tcase -NFS4ERR_LEASE_MOVED:\n\t\t\tnfs4_schedule_lease_moved_recovery(clp);\n\t\t\tgoto wait_on_recovery;\n#if defined(CONFIG_NFS_V4_1)\n\t\tcase -NFS4ERR_BADSESSION:\n\t\tcase -NFS4ERR_BADSLOT:\n\t\tcase -NFS4ERR_BAD_HIGH_SLOT:\n\t\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\t\tcase -NFS4ERR_DEADSESSION:\n\t\tcase -NFS4ERR_SEQ_FALSE_RETRY:\n\t\tcase -NFS4ERR_SEQ_MISORDERED:\n\t\t\t \n\t\t\tgoto wait_on_recovery;\n#endif  \n\t\tcase -NFS4ERR_FILE_OPEN:\n\t\t\tif (exception->timeout > HZ) {\n\t\t\t\t \n\t\t\t\tret = -EBUSY;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\n\t\tcase -NFS4ERR_DELAY:\n\t\t\tnfs_inc_server_stats(server, NFSIOS_DELAY);\n\t\t\tfallthrough;\n\t\tcase -NFS4ERR_GRACE:\n\t\tcase -NFS4ERR_LAYOUTTRYLATER:\n\t\tcase -NFS4ERR_RECALLCONFLICT:\n\t\tcase -NFS4ERR_RETURNCONFLICT:\n\t\t\texception->delay = 1;\n\t\t\treturn 0;\n\n\t\tcase -NFS4ERR_RETRY_UNCACHED_REP:\n\t\tcase -NFS4ERR_OLD_STATEID:\n\t\t\texception->retry = 1;\n\t\t\tbreak;\n\t\tcase -NFS4ERR_BADOWNER:\n\t\t\t \n\t\tcase -NFS4ERR_BADNAME:\n\t\t\tif (server->caps & NFS_CAP_UIDGID_NOMAP) {\n\t\t\t\tserver->caps &= ~NFS_CAP_UIDGID_NOMAP;\n\t\t\t\texception->retry = 1;\n\t\t\t\tprintk(KERN_WARNING \"NFS: v4 server %s \"\n\t\t\t\t\t\t\"does not accept raw \"\n\t\t\t\t\t\t\"uid/gids. \"\n\t\t\t\t\t\t\"Reenabling the idmapper.\\n\",\n\t\t\t\t\t\tserver->nfs_client->cl_hostname);\n\t\t\t}\n\t}\n\t \n\treturn nfs4_map_errors(ret);\nwait_on_recovery:\n\texception->recovering = 1;\n\treturn 0;\n}\n\n \nint nfs4_handle_exception(struct nfs_server *server, int errorcode, struct nfs4_exception *exception)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tint ret;\n\n\tret = nfs4_do_handle_exception(server, errorcode, exception);\n\tif (exception->delay) {\n\t\tret = nfs4_delay(&exception->timeout,\n\t\t\t\texception->interruptible);\n\t\tgoto out_retry;\n\t}\n\tif (exception->recovering) {\n\t\tif (exception->task_is_privileged)\n\t\t\treturn -EDEADLOCK;\n\t\tret = nfs4_wait_clnt_recover(clp);\n\t\tif (test_bit(NFS_MIG_FAILED, &server->mig_status))\n\t\t\treturn -EIO;\n\t\tgoto out_retry;\n\t}\n\treturn ret;\nout_retry:\n\tif (ret == 0)\n\t\texception->retry = 1;\n\treturn ret;\n}\n\nstatic int\nnfs4_async_handle_exception(struct rpc_task *task, struct nfs_server *server,\n\t\tint errorcode, struct nfs4_exception *exception)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tint ret;\n\n\tret = nfs4_do_handle_exception(server, errorcode, exception);\n\tif (exception->delay) {\n\t\trpc_delay(task, nfs4_update_delay(&exception->timeout));\n\t\tgoto out_retry;\n\t}\n\tif (exception->recovering) {\n\t\tif (exception->task_is_privileged)\n\t\t\treturn -EDEADLOCK;\n\t\trpc_sleep_on(&clp->cl_rpcwaitq, task, NULL);\n\t\tif (test_bit(NFS4CLNT_MANAGER_RUNNING, &clp->cl_state) == 0)\n\t\t\trpc_wake_up_queued_task(&clp->cl_rpcwaitq, task);\n\t\tgoto out_retry;\n\t}\n\tif (test_bit(NFS_MIG_FAILED, &server->mig_status))\n\t\tret = -EIO;\n\treturn ret;\nout_retry:\n\tif (ret == 0) {\n\t\texception->retry = 1;\n\t\t \n\t\tif (errorcode == -NFS4ERR_MOVED)\n\t\t\trpc_task_release_transport(task);\n\t}\n\treturn ret;\n}\n\nint\nnfs4_async_handle_error(struct rpc_task *task, struct nfs_server *server,\n\t\t\tstruct nfs4_state *state, long *timeout)\n{\n\tstruct nfs4_exception exception = {\n\t\t.state = state,\n\t};\n\n\tif (task->tk_status >= 0)\n\t\treturn 0;\n\tif (timeout)\n\t\texception.timeout = *timeout;\n\ttask->tk_status = nfs4_async_handle_exception(task, server,\n\t\t\ttask->tk_status,\n\t\t\t&exception);\n\tif (exception.delay && timeout)\n\t\t*timeout = exception.timeout;\n\tif (exception.retry)\n\t\treturn -EAGAIN;\n\treturn 0;\n}\n\n \nstatic bool _nfs4_is_integrity_protected(struct nfs_client *clp)\n{\n\trpc_authflavor_t flavor = clp->cl_rpcclient->cl_auth->au_flavor;\n\treturn (flavor == RPC_AUTH_GSS_KRB5I) || (flavor == RPC_AUTH_GSS_KRB5P);\n}\n\nstatic void do_renew_lease(struct nfs_client *clp, unsigned long timestamp)\n{\n\tspin_lock(&clp->cl_lock);\n\tif (time_before(clp->cl_last_renewal,timestamp))\n\t\tclp->cl_last_renewal = timestamp;\n\tspin_unlock(&clp->cl_lock);\n}\n\nstatic void renew_lease(const struct nfs_server *server, unsigned long timestamp)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\n\tif (!nfs4_has_session(clp))\n\t\tdo_renew_lease(clp, timestamp);\n}\n\nstruct nfs4_call_sync_data {\n\tconst struct nfs_server *seq_server;\n\tstruct nfs4_sequence_args *seq_args;\n\tstruct nfs4_sequence_res *seq_res;\n};\n\nvoid nfs4_init_sequence(struct nfs4_sequence_args *args,\n\t\t\tstruct nfs4_sequence_res *res, int cache_reply,\n\t\t\tint privileged)\n{\n\targs->sa_slot = NULL;\n\targs->sa_cache_this = cache_reply;\n\targs->sa_privileged = privileged;\n\n\tres->sr_slot = NULL;\n}\n\nstatic void nfs40_sequence_free_slot(struct nfs4_sequence_res *res)\n{\n\tstruct nfs4_slot *slot = res->sr_slot;\n\tstruct nfs4_slot_table *tbl;\n\n\ttbl = slot->table;\n\tspin_lock(&tbl->slot_tbl_lock);\n\tif (!nfs41_wake_and_assign_slot(tbl, slot))\n\t\tnfs4_free_slot(tbl, slot);\n\tspin_unlock(&tbl->slot_tbl_lock);\n\n\tres->sr_slot = NULL;\n}\n\nstatic int nfs40_sequence_done(struct rpc_task *task,\n\t\t\t       struct nfs4_sequence_res *res)\n{\n\tif (res->sr_slot != NULL)\n\t\tnfs40_sequence_free_slot(res);\n\treturn 1;\n}\n\n#if defined(CONFIG_NFS_V4_1)\n\nstatic void nfs41_release_slot(struct nfs4_slot *slot)\n{\n\tstruct nfs4_session *session;\n\tstruct nfs4_slot_table *tbl;\n\tbool send_new_highest_used_slotid = false;\n\n\tif (!slot)\n\t\treturn;\n\ttbl = slot->table;\n\tsession = tbl->session;\n\n\t \n\tif (slot->seq_done)\n\t\tslot->seq_nr++;\n\tslot->seq_done = 0;\n\n\tspin_lock(&tbl->slot_tbl_lock);\n\t \n\tif (tbl->highest_used_slotid > tbl->target_highest_slotid)\n\t\tsend_new_highest_used_slotid = true;\n\n\tif (nfs41_wake_and_assign_slot(tbl, slot)) {\n\t\tsend_new_highest_used_slotid = false;\n\t\tgoto out_unlock;\n\t}\n\tnfs4_free_slot(tbl, slot);\n\n\tif (tbl->highest_used_slotid != NFS4_NO_SLOT)\n\t\tsend_new_highest_used_slotid = false;\nout_unlock:\n\tspin_unlock(&tbl->slot_tbl_lock);\n\tif (send_new_highest_used_slotid)\n\t\tnfs41_notify_server(session->clp);\n\tif (waitqueue_active(&tbl->slot_waitq))\n\t\twake_up_all(&tbl->slot_waitq);\n}\n\nstatic void nfs41_sequence_free_slot(struct nfs4_sequence_res *res)\n{\n\tnfs41_release_slot(res->sr_slot);\n\tres->sr_slot = NULL;\n}\n\nstatic void nfs4_slot_sequence_record_sent(struct nfs4_slot *slot,\n\t\tu32 seqnr)\n{\n\tif ((s32)(seqnr - slot->seq_nr_highest_sent) > 0)\n\t\tslot->seq_nr_highest_sent = seqnr;\n}\nstatic void nfs4_slot_sequence_acked(struct nfs4_slot *slot, u32 seqnr)\n{\n\tnfs4_slot_sequence_record_sent(slot, seqnr);\n\tslot->seq_nr_last_acked = seqnr;\n}\n\nstatic void nfs4_probe_sequence(struct nfs_client *client, const struct cred *cred,\n\t\t\t\tstruct nfs4_slot *slot)\n{\n\tstruct rpc_task *task = _nfs41_proc_sequence(client, cred, slot, true);\n\tif (!IS_ERR(task))\n\t\trpc_put_task_async(task);\n}\n\nstatic int nfs41_sequence_process(struct rpc_task *task,\n\t\tstruct nfs4_sequence_res *res)\n{\n\tstruct nfs4_session *session;\n\tstruct nfs4_slot *slot = res->sr_slot;\n\tstruct nfs_client *clp;\n\tint status;\n\tint ret = 1;\n\n\tif (slot == NULL)\n\t\tgoto out_noaction;\n\t \n\tif (!RPC_WAS_SENT(task) || slot->seq_done)\n\t\tgoto out;\n\n\tsession = slot->table->session;\n\tclp = session->clp;\n\n\ttrace_nfs4_sequence_done(session, res);\n\n\tstatus = res->sr_status;\n\tif (task->tk_status == -NFS4ERR_DEADSESSION)\n\t\tstatus = -NFS4ERR_DEADSESSION;\n\n\t \n\tswitch (status) {\n\tcase 0:\n\t\t \n\t\tnfs4_slot_sequence_acked(slot, slot->seq_nr);\n\t\t \n\t\tslot->seq_done = 1;\n\t\tdo_renew_lease(clp, res->sr_timestamp);\n\t\t \n\t\tnfs41_handle_sequence_flag_errors(clp, res->sr_status_flags,\n\t\t\t\t!!slot->privileged);\n\t\tnfs41_update_target_slotid(slot->table, slot, res);\n\t\tbreak;\n\tcase 1:\n\t\t \n\t\tnfs4_slot_sequence_record_sent(slot, slot->seq_nr);\n\t\tslot->seq_done = 1;\n\t\tgoto out;\n\tcase -NFS4ERR_DELAY:\n\t\t \n\t\tdprintk(\"%s: slot=%u seq=%u: Operation in progress\\n\",\n\t\t\t__func__,\n\t\t\tslot->slot_nr,\n\t\t\tslot->seq_nr);\n\t\tgoto out_retry;\n\tcase -NFS4ERR_RETRY_UNCACHED_REP:\n\tcase -NFS4ERR_SEQ_FALSE_RETRY:\n\t\t \n\t\tnfs4_slot_sequence_acked(slot, slot->seq_nr);\n\t\tgoto retry_new_seq;\n\tcase -NFS4ERR_BADSLOT:\n\t\t \n\t\tif (slot->slot_nr < slot->table->target_highest_slotid)\n\t\t\tgoto session_recover;\n\t\tgoto retry_nowait;\n\tcase -NFS4ERR_SEQ_MISORDERED:\n\t\tnfs4_slot_sequence_record_sent(slot, slot->seq_nr);\n\t\t \n\t\tif ((s32)(slot->seq_nr - slot->seq_nr_last_acked) > 1) {\n\t\t\tslot->seq_nr--;\n\t\t\tif (task->tk_msg.rpc_proc != &nfs4_procedures[NFSPROC4_CLNT_SEQUENCE]) {\n\t\t\t\tnfs4_probe_sequence(clp, task->tk_msg.rpc_cred, slot);\n\t\t\t\tres->sr_slot = NULL;\n\t\t\t}\n\t\t\tgoto retry_nowait;\n\t\t}\n\t\t \n\t\tslot->seq_nr = slot->seq_nr_highest_sent;\n\t\tgoto out_retry;\n\tcase -NFS4ERR_BADSESSION:\n\tcase -NFS4ERR_DEADSESSION:\n\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\t\tgoto session_recover;\n\tdefault:\n\t\t \n\t\tslot->seq_done = 1;\n\t}\nout:\n\t \n\tdprintk(\"%s: Error %d free the slot \\n\", __func__, res->sr_status);\nout_noaction:\n\treturn ret;\nsession_recover:\n\tset_bit(NFS4_SLOT_TBL_DRAINING, &session->fc_slot_table.slot_tbl_state);\n\tnfs4_schedule_session_recovery(session, status);\n\tdprintk(\"%s ERROR: %d Reset session\\n\", __func__, status);\n\tnfs41_sequence_free_slot(res);\n\tgoto out;\nretry_new_seq:\n\t++slot->seq_nr;\nretry_nowait:\n\tif (rpc_restart_call_prepare(task)) {\n\t\tnfs41_sequence_free_slot(res);\n\t\ttask->tk_status = 0;\n\t\tret = 0;\n\t}\n\tgoto out;\nout_retry:\n\tif (!rpc_restart_call(task))\n\t\tgoto out;\n\trpc_delay(task, NFS4_POLL_RETRY_MAX);\n\treturn 0;\n}\n\nint nfs41_sequence_done(struct rpc_task *task, struct nfs4_sequence_res *res)\n{\n\tif (!nfs41_sequence_process(task, res))\n\t\treturn 0;\n\tif (res->sr_slot != NULL)\n\t\tnfs41_sequence_free_slot(res);\n\treturn 1;\n\n}\nEXPORT_SYMBOL_GPL(nfs41_sequence_done);\n\nstatic int nfs4_sequence_process(struct rpc_task *task, struct nfs4_sequence_res *res)\n{\n\tif (res->sr_slot == NULL)\n\t\treturn 1;\n\tif (res->sr_slot->table->session != NULL)\n\t\treturn nfs41_sequence_process(task, res);\n\treturn nfs40_sequence_done(task, res);\n}\n\nstatic void nfs4_sequence_free_slot(struct nfs4_sequence_res *res)\n{\n\tif (res->sr_slot != NULL) {\n\t\tif (res->sr_slot->table->session != NULL)\n\t\t\tnfs41_sequence_free_slot(res);\n\t\telse\n\t\t\tnfs40_sequence_free_slot(res);\n\t}\n}\n\nint nfs4_sequence_done(struct rpc_task *task, struct nfs4_sequence_res *res)\n{\n\tif (res->sr_slot == NULL)\n\t\treturn 1;\n\tif (!res->sr_slot->table->session)\n\t\treturn nfs40_sequence_done(task, res);\n\treturn nfs41_sequence_done(task, res);\n}\nEXPORT_SYMBOL_GPL(nfs4_sequence_done);\n\nstatic void nfs41_call_sync_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_call_sync_data *data = calldata;\n\n\tdprintk(\"--> %s data->seq_server %p\\n\", __func__, data->seq_server);\n\n\tnfs4_setup_sequence(data->seq_server->nfs_client,\n\t\t\t    data->seq_args, data->seq_res, task);\n}\n\nstatic void nfs41_call_sync_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_call_sync_data *data = calldata;\n\n\tnfs41_sequence_done(task, data->seq_res);\n}\n\nstatic const struct rpc_call_ops nfs41_call_sync_ops = {\n\t.rpc_call_prepare = nfs41_call_sync_prepare,\n\t.rpc_call_done = nfs41_call_sync_done,\n};\n\n#else\t \n\nstatic int nfs4_sequence_process(struct rpc_task *task, struct nfs4_sequence_res *res)\n{\n\treturn nfs40_sequence_done(task, res);\n}\n\nstatic void nfs4_sequence_free_slot(struct nfs4_sequence_res *res)\n{\n\tif (res->sr_slot != NULL)\n\t\tnfs40_sequence_free_slot(res);\n}\n\nint nfs4_sequence_done(struct rpc_task *task,\n\t\t       struct nfs4_sequence_res *res)\n{\n\treturn nfs40_sequence_done(task, res);\n}\nEXPORT_SYMBOL_GPL(nfs4_sequence_done);\n\n#endif\t \n\nstatic void nfs41_sequence_res_init(struct nfs4_sequence_res *res)\n{\n\tres->sr_timestamp = jiffies;\n\tres->sr_status_flags = 0;\n\tres->sr_status = 1;\n}\n\nstatic\nvoid nfs4_sequence_attach_slot(struct nfs4_sequence_args *args,\n\t\tstruct nfs4_sequence_res *res,\n\t\tstruct nfs4_slot *slot)\n{\n\tif (!slot)\n\t\treturn;\n\tslot->privileged = args->sa_privileged ? 1 : 0;\n\targs->sa_slot = slot;\n\n\tres->sr_slot = slot;\n}\n\nint nfs4_setup_sequence(struct nfs_client *client,\n\t\t\tstruct nfs4_sequence_args *args,\n\t\t\tstruct nfs4_sequence_res *res,\n\t\t\tstruct rpc_task *task)\n{\n\tstruct nfs4_session *session = nfs4_get_session(client);\n\tstruct nfs4_slot_table *tbl  = client->cl_slot_tbl;\n\tstruct nfs4_slot *slot;\n\n\t \n\tif (res->sr_slot != NULL)\n\t\tgoto out_start;\n\n\tif (session)\n\t\ttbl = &session->fc_slot_table;\n\n\tspin_lock(&tbl->slot_tbl_lock);\n\t \n\tif (nfs4_slot_tbl_draining(tbl) && !args->sa_privileged)\n\t\tgoto out_sleep;\n\n\tslot = nfs4_alloc_slot(tbl);\n\tif (IS_ERR(slot)) {\n\t\tif (slot == ERR_PTR(-ENOMEM))\n\t\t\tgoto out_sleep_timeout;\n\t\tgoto out_sleep;\n\t}\n\tspin_unlock(&tbl->slot_tbl_lock);\n\n\tnfs4_sequence_attach_slot(args, res, slot);\n\n\ttrace_nfs4_setup_sequence(session, args);\nout_start:\n\tnfs41_sequence_res_init(res);\n\trpc_call_start(task);\n\treturn 0;\nout_sleep_timeout:\n\t \n\tif (args->sa_privileged)\n\t\trpc_sleep_on_priority_timeout(&tbl->slot_tbl_waitq, task,\n\t\t\t\tjiffies + (HZ >> 2), RPC_PRIORITY_PRIVILEGED);\n\telse\n\t\trpc_sleep_on_timeout(&tbl->slot_tbl_waitq, task,\n\t\t\t\tNULL, jiffies + (HZ >> 2));\n\tspin_unlock(&tbl->slot_tbl_lock);\n\treturn -EAGAIN;\nout_sleep:\n\tif (args->sa_privileged)\n\t\trpc_sleep_on_priority(&tbl->slot_tbl_waitq, task,\n\t\t\t\tRPC_PRIORITY_PRIVILEGED);\n\telse\n\t\trpc_sleep_on(&tbl->slot_tbl_waitq, task, NULL);\n\tspin_unlock(&tbl->slot_tbl_lock);\n\treturn -EAGAIN;\n}\nEXPORT_SYMBOL_GPL(nfs4_setup_sequence);\n\nstatic void nfs40_call_sync_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_call_sync_data *data = calldata;\n\tnfs4_setup_sequence(data->seq_server->nfs_client,\n\t\t\t\tdata->seq_args, data->seq_res, task);\n}\n\nstatic void nfs40_call_sync_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_call_sync_data *data = calldata;\n\tnfs4_sequence_done(task, data->seq_res);\n}\n\nstatic const struct rpc_call_ops nfs40_call_sync_ops = {\n\t.rpc_call_prepare = nfs40_call_sync_prepare,\n\t.rpc_call_done = nfs40_call_sync_done,\n};\n\nstatic int nfs4_call_sync_custom(struct rpc_task_setup *task_setup)\n{\n\tint ret;\n\tstruct rpc_task *task;\n\n\ttask = rpc_run_task(task_setup);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\n\tret = task->tk_status;\n\trpc_put_task(task);\n\treturn ret;\n}\n\nstatic int nfs4_do_call_sync(struct rpc_clnt *clnt,\n\t\t\t     struct nfs_server *server,\n\t\t\t     struct rpc_message *msg,\n\t\t\t     struct nfs4_sequence_args *args,\n\t\t\t     struct nfs4_sequence_res *res,\n\t\t\t     unsigned short task_flags)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct nfs4_call_sync_data data = {\n\t\t.seq_server = server,\n\t\t.seq_args = args,\n\t\t.seq_res = res,\n\t};\n\tstruct rpc_task_setup task_setup = {\n\t\t.rpc_client = clnt,\n\t\t.rpc_message = msg,\n\t\t.callback_ops = clp->cl_mvops->call_sync_ops,\n\t\t.callback_data = &data,\n\t\t.flags = task_flags,\n\t};\n\n\treturn nfs4_call_sync_custom(&task_setup);\n}\n\nstatic int nfs4_call_sync_sequence(struct rpc_clnt *clnt,\n\t\t\t\t   struct nfs_server *server,\n\t\t\t\t   struct rpc_message *msg,\n\t\t\t\t   struct nfs4_sequence_args *args,\n\t\t\t\t   struct nfs4_sequence_res *res)\n{\n\tunsigned short task_flags = 0;\n\n\tif (server->caps & NFS_CAP_MOVEABLE)\n\t\ttask_flags = RPC_TASK_MOVEABLE;\n\treturn nfs4_do_call_sync(clnt, server, msg, args, res, task_flags);\n}\n\n\nint nfs4_call_sync(struct rpc_clnt *clnt,\n\t\t   struct nfs_server *server,\n\t\t   struct rpc_message *msg,\n\t\t   struct nfs4_sequence_args *args,\n\t\t   struct nfs4_sequence_res *res,\n\t\t   int cache_reply)\n{\n\tnfs4_init_sequence(args, res, cache_reply, 0);\n\treturn nfs4_call_sync_sequence(clnt, server, msg, args, res);\n}\n\nstatic void\nnfs4_inc_nlink_locked(struct inode *inode)\n{\n\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_CHANGE |\n\t\t\t\t\t     NFS_INO_INVALID_CTIME |\n\t\t\t\t\t     NFS_INO_INVALID_NLINK);\n\tinc_nlink(inode);\n}\n\nstatic void\nnfs4_inc_nlink(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tnfs4_inc_nlink_locked(inode);\n\tspin_unlock(&inode->i_lock);\n}\n\nstatic void\nnfs4_dec_nlink_locked(struct inode *inode)\n{\n\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_CHANGE |\n\t\t\t\t\t     NFS_INO_INVALID_CTIME |\n\t\t\t\t\t     NFS_INO_INVALID_NLINK);\n\tdrop_nlink(inode);\n}\n\nstatic void\nnfs4_update_changeattr_locked(struct inode *inode,\n\t\tstruct nfs4_change_info *cinfo,\n\t\tunsigned long timestamp, unsigned long cache_validity)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tu64 change_attr = inode_peek_iversion_raw(inode);\n\n\tcache_validity |= NFS_INO_INVALID_CTIME | NFS_INO_INVALID_MTIME;\n\tif (S_ISDIR(inode->i_mode))\n\t\tcache_validity |= NFS_INO_INVALID_DATA;\n\n\tswitch (NFS_SERVER(inode)->change_attr_type) {\n\tcase NFS4_CHANGE_TYPE_IS_UNDEFINED:\n\t\tif (cinfo->after == change_attr)\n\t\t\tgoto out;\n\t\tbreak;\n\tdefault:\n\t\tif ((s64)(change_attr - cinfo->after) >= 0)\n\t\t\tgoto out;\n\t}\n\n\tinode_set_iversion_raw(inode, cinfo->after);\n\tif (!cinfo->atomic || cinfo->before != change_attr) {\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\tnfs_force_lookup_revalidate(inode);\n\n\t\tif (!NFS_PROTO(inode)->have_delegation(inode, FMODE_READ))\n\t\t\tcache_validity |=\n\t\t\t\tNFS_INO_INVALID_ACCESS | NFS_INO_INVALID_ACL |\n\t\t\t\tNFS_INO_INVALID_SIZE | NFS_INO_INVALID_OTHER |\n\t\t\t\tNFS_INO_INVALID_BLOCKS | NFS_INO_INVALID_NLINK |\n\t\t\t\tNFS_INO_INVALID_MODE | NFS_INO_INVALID_XATTR;\n\t\tnfsi->attrtimeo = NFS_MINATTRTIMEO(inode);\n\t}\n\tnfsi->attrtimeo_timestamp = jiffies;\n\tnfsi->read_cache_jiffies = timestamp;\n\tnfsi->attr_gencount = nfs_inc_attr_generation_counter();\n\tnfsi->cache_validity &= ~NFS_INO_INVALID_CHANGE;\nout:\n\tnfs_set_cache_invalid(inode, cache_validity);\n}\n\nvoid\nnfs4_update_changeattr(struct inode *dir, struct nfs4_change_info *cinfo,\n\t\tunsigned long timestamp, unsigned long cache_validity)\n{\n\tspin_lock(&dir->i_lock);\n\tnfs4_update_changeattr_locked(dir, cinfo, timestamp, cache_validity);\n\tspin_unlock(&dir->i_lock);\n}\n\nstruct nfs4_open_createattrs {\n\tstruct nfs4_label *label;\n\tstruct iattr *sattr;\n\tconst __u32 verf[2];\n};\n\nstatic bool nfs4_clear_cap_atomic_open_v1(struct nfs_server *server,\n\t\tint err, struct nfs4_exception *exception)\n{\n\tif (err != -EINVAL)\n\t\treturn false;\n\tif (!(server->caps & NFS_CAP_ATOMIC_OPEN_V1))\n\t\treturn false;\n\tserver->caps &= ~NFS_CAP_ATOMIC_OPEN_V1;\n\texception->retry = 1;\n\treturn true;\n}\n\nstatic fmode_t _nfs4_ctx_to_accessmode(const struct nfs_open_context *ctx)\n{\n\t return ctx->mode & (FMODE_READ|FMODE_WRITE|FMODE_EXEC);\n}\n\nstatic fmode_t _nfs4_ctx_to_openmode(const struct nfs_open_context *ctx)\n{\n\tfmode_t ret = ctx->mode & (FMODE_READ|FMODE_WRITE);\n\n\treturn (ctx->mode & FMODE_EXEC) ? FMODE_READ | ret : ret;\n}\n\nstatic u32\nnfs4_map_atomic_open_share(struct nfs_server *server,\n\t\tfmode_t fmode, int openflags)\n{\n\tu32 res = 0;\n\n\tswitch (fmode & (FMODE_READ | FMODE_WRITE)) {\n\tcase FMODE_READ:\n\t\tres = NFS4_SHARE_ACCESS_READ;\n\t\tbreak;\n\tcase FMODE_WRITE:\n\t\tres = NFS4_SHARE_ACCESS_WRITE;\n\t\tbreak;\n\tcase FMODE_READ|FMODE_WRITE:\n\t\tres = NFS4_SHARE_ACCESS_BOTH;\n\t}\n\tif (!(server->caps & NFS_CAP_ATOMIC_OPEN_V1))\n\t\tgoto out;\n\t \n\tif (openflags & O_DIRECT)\n\t\tres |= NFS4_SHARE_WANT_NO_DELEG;\nout:\n\treturn res;\n}\n\nstatic enum open_claim_type4\nnfs4_map_atomic_open_claim(struct nfs_server *server,\n\t\tenum open_claim_type4 claim)\n{\n\tif (server->caps & NFS_CAP_ATOMIC_OPEN_V1)\n\t\treturn claim;\n\tswitch (claim) {\n\tdefault:\n\t\treturn claim;\n\tcase NFS4_OPEN_CLAIM_FH:\n\t\treturn NFS4_OPEN_CLAIM_NULL;\n\tcase NFS4_OPEN_CLAIM_DELEG_CUR_FH:\n\t\treturn NFS4_OPEN_CLAIM_DELEGATE_CUR;\n\tcase NFS4_OPEN_CLAIM_DELEG_PREV_FH:\n\t\treturn NFS4_OPEN_CLAIM_DELEGATE_PREV;\n\t}\n}\n\nstatic void nfs4_init_opendata_res(struct nfs4_opendata *p)\n{\n\tp->o_res.f_attr = &p->f_attr;\n\tp->o_res.seqid = p->o_arg.seqid;\n\tp->c_res.seqid = p->c_arg.seqid;\n\tp->o_res.server = p->o_arg.server;\n\tp->o_res.access_request = p->o_arg.access;\n\tnfs_fattr_init(&p->f_attr);\n\tnfs_fattr_init_names(&p->f_attr, &p->owner_name, &p->group_name);\n}\n\nstatic struct nfs4_opendata *nfs4_opendata_alloc(struct dentry *dentry,\n\t\tstruct nfs4_state_owner *sp, fmode_t fmode, int flags,\n\t\tconst struct nfs4_open_createattrs *c,\n\t\tenum open_claim_type4 claim,\n\t\tgfp_t gfp_mask)\n{\n\tstruct dentry *parent = dget_parent(dentry);\n\tstruct inode *dir = d_inode(parent);\n\tstruct nfs_server *server = NFS_SERVER(dir);\n\tstruct nfs_seqid *(*alloc_seqid)(struct nfs_seqid_counter *, gfp_t);\n\tstruct nfs4_label *label = (c != NULL) ? c->label : NULL;\n\tstruct nfs4_opendata *p;\n\n\tp = kzalloc(sizeof(*p), gfp_mask);\n\tif (p == NULL)\n\t\tgoto err;\n\n\tp->f_attr.label = nfs4_label_alloc(server, gfp_mask);\n\tif (IS_ERR(p->f_attr.label))\n\t\tgoto err_free_p;\n\n\tp->a_label = nfs4_label_alloc(server, gfp_mask);\n\tif (IS_ERR(p->a_label))\n\t\tgoto err_free_f;\n\n\talloc_seqid = server->nfs_client->cl_mvops->alloc_seqid;\n\tp->o_arg.seqid = alloc_seqid(&sp->so_seqid, gfp_mask);\n\tif (IS_ERR(p->o_arg.seqid))\n\t\tgoto err_free_label;\n\tnfs_sb_active(dentry->d_sb);\n\tp->dentry = dget(dentry);\n\tp->dir = parent;\n\tp->owner = sp;\n\tatomic_inc(&sp->so_count);\n\tp->o_arg.open_flags = flags;\n\tp->o_arg.fmode = fmode & (FMODE_READ|FMODE_WRITE);\n\tp->o_arg.claim = nfs4_map_atomic_open_claim(server, claim);\n\tp->o_arg.share_access = nfs4_map_atomic_open_share(server,\n\t\t\tfmode, flags);\n\tif (flags & O_CREAT) {\n\t\tp->o_arg.umask = current_umask();\n\t\tp->o_arg.label = nfs4_label_copy(p->a_label, label);\n\t\tif (c->sattr != NULL && c->sattr->ia_valid != 0) {\n\t\t\tp->o_arg.u.attrs = &p->attrs;\n\t\t\tmemcpy(&p->attrs, c->sattr, sizeof(p->attrs));\n\n\t\t\tmemcpy(p->o_arg.u.verifier.data, c->verf,\n\t\t\t\t\tsizeof(p->o_arg.u.verifier.data));\n\t\t}\n\t}\n\t \n\tswitch (p->o_arg.claim) {\n\tdefault:\n\t\tbreak;\n\tcase NFS4_OPEN_CLAIM_NULL:\n\tcase NFS4_OPEN_CLAIM_FH:\n\t\tp->o_arg.access = NFS4_ACCESS_READ | NFS4_ACCESS_MODIFY |\n\t\t\t\t  NFS4_ACCESS_EXTEND | NFS4_ACCESS_DELETE |\n\t\t\t\t  NFS4_ACCESS_EXECUTE |\n\t\t\t\t  nfs_access_xattr_mask(server);\n\t}\n\tp->o_arg.clientid = server->nfs_client->cl_clientid;\n\tp->o_arg.id.create_time = ktime_to_ns(sp->so_seqid.create_time);\n\tp->o_arg.id.uniquifier = sp->so_seqid.owner_id;\n\tp->o_arg.name = &dentry->d_name;\n\tp->o_arg.server = server;\n\tp->o_arg.bitmask = nfs4_bitmask(server, label);\n\tp->o_arg.open_bitmap = &nfs4_fattr_bitmap[0];\n\tswitch (p->o_arg.claim) {\n\tcase NFS4_OPEN_CLAIM_NULL:\n\tcase NFS4_OPEN_CLAIM_DELEGATE_CUR:\n\tcase NFS4_OPEN_CLAIM_DELEGATE_PREV:\n\t\tp->o_arg.fh = NFS_FH(dir);\n\t\tbreak;\n\tcase NFS4_OPEN_CLAIM_PREVIOUS:\n\tcase NFS4_OPEN_CLAIM_FH:\n\tcase NFS4_OPEN_CLAIM_DELEG_CUR_FH:\n\tcase NFS4_OPEN_CLAIM_DELEG_PREV_FH:\n\t\tp->o_arg.fh = NFS_FH(d_inode(dentry));\n\t}\n\tp->c_arg.fh = &p->o_res.fh;\n\tp->c_arg.stateid = &p->o_res.stateid;\n\tp->c_arg.seqid = p->o_arg.seqid;\n\tnfs4_init_opendata_res(p);\n\tkref_init(&p->kref);\n\treturn p;\n\nerr_free_label:\n\tnfs4_label_free(p->a_label);\nerr_free_f:\n\tnfs4_label_free(p->f_attr.label);\nerr_free_p:\n\tkfree(p);\nerr:\n\tdput(parent);\n\treturn NULL;\n}\n\nstatic void nfs4_opendata_free(struct kref *kref)\n{\n\tstruct nfs4_opendata *p = container_of(kref,\n\t\t\tstruct nfs4_opendata, kref);\n\tstruct super_block *sb = p->dentry->d_sb;\n\n\tnfs4_lgopen_release(p->lgp);\n\tnfs_free_seqid(p->o_arg.seqid);\n\tnfs4_sequence_free_slot(&p->o_res.seq_res);\n\tif (p->state != NULL)\n\t\tnfs4_put_open_state(p->state);\n\tnfs4_put_state_owner(p->owner);\n\n\tnfs4_label_free(p->a_label);\n\tnfs4_label_free(p->f_attr.label);\n\n\tdput(p->dir);\n\tdput(p->dentry);\n\tnfs_sb_deactive(sb);\n\tnfs_fattr_free_names(&p->f_attr);\n\tkfree(p->f_attr.mdsthreshold);\n\tkfree(p);\n}\n\nstatic void nfs4_opendata_put(struct nfs4_opendata *p)\n{\n\tif (p != NULL)\n\t\tkref_put(&p->kref, nfs4_opendata_free);\n}\n\nstatic bool nfs4_mode_match_open_stateid(struct nfs4_state *state,\n\t\tfmode_t fmode)\n{\n\tswitch(fmode & (FMODE_READ|FMODE_WRITE)) {\n\tcase FMODE_READ|FMODE_WRITE:\n\t\treturn state->n_rdwr != 0;\n\tcase FMODE_WRITE:\n\t\treturn state->n_wronly != 0;\n\tcase FMODE_READ:\n\t\treturn state->n_rdonly != 0;\n\t}\n\tWARN_ON_ONCE(1);\n\treturn false;\n}\n\nstatic int can_open_cached(struct nfs4_state *state, fmode_t mode,\n\t\tint open_mode, enum open_claim_type4 claim)\n{\n\tint ret = 0;\n\n\tif (open_mode & (O_EXCL|O_TRUNC))\n\t\tgoto out;\n\tswitch (claim) {\n\tcase NFS4_OPEN_CLAIM_NULL:\n\tcase NFS4_OPEN_CLAIM_FH:\n\t\tgoto out;\n\tdefault:\n\t\tbreak;\n\t}\n\tswitch (mode & (FMODE_READ|FMODE_WRITE)) {\n\t\tcase FMODE_READ:\n\t\t\tret |= test_bit(NFS_O_RDONLY_STATE, &state->flags) != 0\n\t\t\t\t&& state->n_rdonly != 0;\n\t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tret |= test_bit(NFS_O_WRONLY_STATE, &state->flags) != 0\n\t\t\t\t&& state->n_wronly != 0;\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tret |= test_bit(NFS_O_RDWR_STATE, &state->flags) != 0\n\t\t\t\t&& state->n_rdwr != 0;\n\t}\nout:\n\treturn ret;\n}\n\nstatic int can_open_delegated(struct nfs_delegation *delegation, fmode_t fmode,\n\t\tenum open_claim_type4 claim)\n{\n\tif (delegation == NULL)\n\t\treturn 0;\n\tif ((delegation->type & fmode) != fmode)\n\t\treturn 0;\n\tswitch (claim) {\n\tcase NFS4_OPEN_CLAIM_NULL:\n\tcase NFS4_OPEN_CLAIM_FH:\n\t\tbreak;\n\tcase NFS4_OPEN_CLAIM_PREVIOUS:\n\t\tif (!test_bit(NFS_DELEGATION_NEED_RECLAIM, &delegation->flags))\n\t\t\tbreak;\n\t\tfallthrough;\n\tdefault:\n\t\treturn 0;\n\t}\n\tnfs_mark_delegation_referenced(delegation);\n\treturn 1;\n}\n\nstatic void update_open_stateflags(struct nfs4_state *state, fmode_t fmode)\n{\n\tswitch (fmode) {\n\t\tcase FMODE_WRITE:\n\t\t\tstate->n_wronly++;\n\t\t\tbreak;\n\t\tcase FMODE_READ:\n\t\t\tstate->n_rdonly++;\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tstate->n_rdwr++;\n\t}\n\tnfs4_state_set_mode_locked(state, state->state | fmode);\n}\n\n#ifdef CONFIG_NFS_V4_1\nstatic bool nfs_open_stateid_recover_openmode(struct nfs4_state *state)\n{\n\tif (state->n_rdonly && !test_bit(NFS_O_RDONLY_STATE, &state->flags))\n\t\treturn true;\n\tif (state->n_wronly && !test_bit(NFS_O_WRONLY_STATE, &state->flags))\n\t\treturn true;\n\tif (state->n_rdwr && !test_bit(NFS_O_RDWR_STATE, &state->flags))\n\t\treturn true;\n\treturn false;\n}\n#endif  \n\nstatic void nfs_state_log_update_open_stateid(struct nfs4_state *state)\n{\n\tif (test_and_clear_bit(NFS_STATE_CHANGE_WAIT, &state->flags))\n\t\twake_up_all(&state->waitq);\n}\n\nstatic void nfs_test_and_clear_all_open_stateid(struct nfs4_state *state)\n{\n\tstruct nfs_client *clp = state->owner->so_server->nfs_client;\n\tbool need_recover = false;\n\n\tif (test_and_clear_bit(NFS_O_RDONLY_STATE, &state->flags) && state->n_rdonly)\n\t\tneed_recover = true;\n\tif (test_and_clear_bit(NFS_O_WRONLY_STATE, &state->flags) && state->n_wronly)\n\t\tneed_recover = true;\n\tif (test_and_clear_bit(NFS_O_RDWR_STATE, &state->flags) && state->n_rdwr)\n\t\tneed_recover = true;\n\tif (need_recover)\n\t\tnfs4_state_mark_reclaim_nograce(clp, state);\n}\n\n \nstatic bool nfs_stateid_is_sequential(struct nfs4_state *state,\n\t\tconst nfs4_stateid *stateid)\n{\n\tif (test_bit(NFS_OPEN_STATE, &state->flags)) {\n\t\t \n\t\tif (nfs4_stateid_match_other(stateid, &state->open_stateid)) {\n\t\t\tif (nfs4_stateid_is_next(&state->open_stateid, stateid))\n\t\t\t\treturn true;\n\t\t\treturn false;\n\t\t}\n\t\t \n\t}\n\t \n\tif (stateid->seqid == cpu_to_be32(1))\n\t\treturn true;\n\treturn false;\n}\n\nstatic void nfs_resync_open_stateid_locked(struct nfs4_state *state)\n{\n\tif (!(state->n_wronly || state->n_rdonly || state->n_rdwr))\n\t\treturn;\n\tif (state->n_wronly)\n\t\tset_bit(NFS_O_WRONLY_STATE, &state->flags);\n\tif (state->n_rdonly)\n\t\tset_bit(NFS_O_RDONLY_STATE, &state->flags);\n\tif (state->n_rdwr)\n\t\tset_bit(NFS_O_RDWR_STATE, &state->flags);\n\tset_bit(NFS_OPEN_STATE, &state->flags);\n}\n\nstatic void nfs_clear_open_stateid_locked(struct nfs4_state *state,\n\t\tnfs4_stateid *stateid, fmode_t fmode)\n{\n\tclear_bit(NFS_O_RDWR_STATE, &state->flags);\n\tswitch (fmode & (FMODE_READ|FMODE_WRITE)) {\n\tcase FMODE_WRITE:\n\t\tclear_bit(NFS_O_RDONLY_STATE, &state->flags);\n\t\tbreak;\n\tcase FMODE_READ:\n\t\tclear_bit(NFS_O_WRONLY_STATE, &state->flags);\n\t\tbreak;\n\tcase 0:\n\t\tclear_bit(NFS_O_RDONLY_STATE, &state->flags);\n\t\tclear_bit(NFS_O_WRONLY_STATE, &state->flags);\n\t\tclear_bit(NFS_OPEN_STATE, &state->flags);\n\t}\n\tif (stateid == NULL)\n\t\treturn;\n\t \n\tif (nfs4_stateid_match_other(stateid, &state->open_stateid) &&\n\t    !nfs4_stateid_is_newer(stateid, &state->open_stateid)) {\n\t\tnfs_resync_open_stateid_locked(state);\n\t\tgoto out;\n\t}\n\tif (test_bit(NFS_DELEGATED_STATE, &state->flags) == 0)\n\t\tnfs4_stateid_copy(&state->stateid, stateid);\n\tnfs4_stateid_copy(&state->open_stateid, stateid);\n\ttrace_nfs4_open_stateid_update(state->inode, stateid, 0);\nout:\n\tnfs_state_log_update_open_stateid(state);\n}\n\nstatic void nfs_clear_open_stateid(struct nfs4_state *state,\n\tnfs4_stateid *arg_stateid,\n\tnfs4_stateid *stateid, fmode_t fmode)\n{\n\twrite_seqlock(&state->seqlock);\n\t \n\tif (nfs4_state_match_open_stateid_other(state, arg_stateid))\n\t\tnfs_clear_open_stateid_locked(state, stateid, fmode);\n\twrite_sequnlock(&state->seqlock);\n\tif (test_bit(NFS_STATE_RECLAIM_NOGRACE, &state->flags))\n\t\tnfs4_schedule_state_manager(state->owner->so_server->nfs_client);\n}\n\nstatic void nfs_set_open_stateid_locked(struct nfs4_state *state,\n\t\tconst nfs4_stateid *stateid, nfs4_stateid *freeme)\n\t__must_hold(&state->owner->so_lock)\n\t__must_hold(&state->seqlock)\n\t__must_hold(RCU)\n\n{\n\tDEFINE_WAIT(wait);\n\tint status = 0;\n\tfor (;;) {\n\n\t\tif (nfs_stateid_is_sequential(state, stateid))\n\t\t\tbreak;\n\n\t\tif (status)\n\t\t\tbreak;\n\t\t \n\t\tif (!nfs4_has_session(NFS_SERVER(state->inode)->nfs_client))\n\t\t\tbreak;\n\n\t\tset_bit(NFS_STATE_CHANGE_WAIT, &state->flags);\n\t\tprepare_to_wait(&state->waitq, &wait, TASK_KILLABLE);\n\t\t \n\t\twrite_sequnlock(&state->seqlock);\n\t\tspin_unlock(&state->owner->so_lock);\n\t\trcu_read_unlock();\n\t\ttrace_nfs4_open_stateid_update_wait(state->inode, stateid, 0);\n\n\t\tif (!fatal_signal_pending(current)) {\n\t\t\tif (schedule_timeout(5*HZ) == 0)\n\t\t\t\tstatus = -EAGAIN;\n\t\t\telse\n\t\t\t\tstatus = 0;\n\t\t} else\n\t\t\tstatus = -EINTR;\n\t\tfinish_wait(&state->waitq, &wait);\n\t\trcu_read_lock();\n\t\tspin_lock(&state->owner->so_lock);\n\t\twrite_seqlock(&state->seqlock);\n\t}\n\n\tif (test_bit(NFS_OPEN_STATE, &state->flags) &&\n\t    !nfs4_stateid_match_other(stateid, &state->open_stateid)) {\n\t\tnfs4_stateid_copy(freeme, &state->open_stateid);\n\t\tnfs_test_and_clear_all_open_stateid(state);\n\t}\n\n\tif (test_bit(NFS_DELEGATED_STATE, &state->flags) == 0)\n\t\tnfs4_stateid_copy(&state->stateid, stateid);\n\tnfs4_stateid_copy(&state->open_stateid, stateid);\n\ttrace_nfs4_open_stateid_update(state->inode, stateid, status);\n\tnfs_state_log_update_open_stateid(state);\n}\n\nstatic void nfs_state_set_open_stateid(struct nfs4_state *state,\n\t\tconst nfs4_stateid *open_stateid,\n\t\tfmode_t fmode,\n\t\tnfs4_stateid *freeme)\n{\n\t \n\twrite_seqlock(&state->seqlock);\n\tnfs_set_open_stateid_locked(state, open_stateid, freeme);\n\tswitch (fmode) {\n\tcase FMODE_READ:\n\t\tset_bit(NFS_O_RDONLY_STATE, &state->flags);\n\t\tbreak;\n\tcase FMODE_WRITE:\n\t\tset_bit(NFS_O_WRONLY_STATE, &state->flags);\n\t\tbreak;\n\tcase FMODE_READ|FMODE_WRITE:\n\t\tset_bit(NFS_O_RDWR_STATE, &state->flags);\n\t}\n\tset_bit(NFS_OPEN_STATE, &state->flags);\n\twrite_sequnlock(&state->seqlock);\n}\n\nstatic void nfs_state_clear_open_state_flags(struct nfs4_state *state)\n{\n\tclear_bit(NFS_O_RDWR_STATE, &state->flags);\n\tclear_bit(NFS_O_WRONLY_STATE, &state->flags);\n\tclear_bit(NFS_O_RDONLY_STATE, &state->flags);\n\tclear_bit(NFS_OPEN_STATE, &state->flags);\n}\n\nstatic void nfs_state_set_delegation(struct nfs4_state *state,\n\t\tconst nfs4_stateid *deleg_stateid,\n\t\tfmode_t fmode)\n{\n\t \n\twrite_seqlock(&state->seqlock);\n\tnfs4_stateid_copy(&state->stateid, deleg_stateid);\n\tset_bit(NFS_DELEGATED_STATE, &state->flags);\n\twrite_sequnlock(&state->seqlock);\n}\n\nstatic void nfs_state_clear_delegation(struct nfs4_state *state)\n{\n\twrite_seqlock(&state->seqlock);\n\tnfs4_stateid_copy(&state->stateid, &state->open_stateid);\n\tclear_bit(NFS_DELEGATED_STATE, &state->flags);\n\twrite_sequnlock(&state->seqlock);\n}\n\nint update_open_stateid(struct nfs4_state *state,\n\t\tconst nfs4_stateid *open_stateid,\n\t\tconst nfs4_stateid *delegation,\n\t\tfmode_t fmode)\n{\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct nfs_inode *nfsi = NFS_I(state->inode);\n\tstruct nfs_delegation *deleg_cur;\n\tnfs4_stateid freeme = { };\n\tint ret = 0;\n\n\tfmode &= (FMODE_READ|FMODE_WRITE);\n\n\trcu_read_lock();\n\tspin_lock(&state->owner->so_lock);\n\tif (open_stateid != NULL) {\n\t\tnfs_state_set_open_stateid(state, open_stateid, fmode, &freeme);\n\t\tret = 1;\n\t}\n\n\tdeleg_cur = nfs4_get_valid_delegation(state->inode);\n\tif (deleg_cur == NULL)\n\t\tgoto no_delegation;\n\n\tspin_lock(&deleg_cur->lock);\n\tif (rcu_dereference(nfsi->delegation) != deleg_cur ||\n\t   test_bit(NFS_DELEGATION_RETURNING, &deleg_cur->flags) ||\n\t    (deleg_cur->type & fmode) != fmode)\n\t\tgoto no_delegation_unlock;\n\n\tif (delegation == NULL)\n\t\tdelegation = &deleg_cur->stateid;\n\telse if (!nfs4_stateid_match_other(&deleg_cur->stateid, delegation))\n\t\tgoto no_delegation_unlock;\n\n\tnfs_mark_delegation_referenced(deleg_cur);\n\tnfs_state_set_delegation(state, &deleg_cur->stateid, fmode);\n\tret = 1;\nno_delegation_unlock:\n\tspin_unlock(&deleg_cur->lock);\nno_delegation:\n\tif (ret)\n\t\tupdate_open_stateflags(state, fmode);\n\tspin_unlock(&state->owner->so_lock);\n\trcu_read_unlock();\n\n\tif (test_bit(NFS_STATE_RECLAIM_NOGRACE, &state->flags))\n\t\tnfs4_schedule_state_manager(clp);\n\tif (freeme.type != 0)\n\t\tnfs4_test_and_free_stateid(server, &freeme,\n\t\t\t\tstate->owner->so_cred);\n\n\treturn ret;\n}\n\nstatic bool nfs4_update_lock_stateid(struct nfs4_lock_state *lsp,\n\t\tconst nfs4_stateid *stateid)\n{\n\tstruct nfs4_state *state = lsp->ls_state;\n\tbool ret = false;\n\n\tspin_lock(&state->state_lock);\n\tif (!nfs4_stateid_match_other(stateid, &lsp->ls_stateid))\n\t\tgoto out_noupdate;\n\tif (!nfs4_stateid_is_newer(stateid, &lsp->ls_stateid))\n\t\tgoto out_noupdate;\n\tnfs4_stateid_copy(&lsp->ls_stateid, stateid);\n\tret = true;\nout_noupdate:\n\tspin_unlock(&state->state_lock);\n\treturn ret;\n}\n\nstatic void nfs4_return_incompatible_delegation(struct inode *inode, fmode_t fmode)\n{\n\tstruct nfs_delegation *delegation;\n\n\tfmode &= FMODE_READ|FMODE_WRITE;\n\trcu_read_lock();\n\tdelegation = nfs4_get_valid_delegation(inode);\n\tif (delegation == NULL || (delegation->type & fmode) == fmode) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\trcu_read_unlock();\n\tnfs4_inode_return_delegation(inode);\n}\n\nstatic struct nfs4_state *nfs4_try_open_cached(struct nfs4_opendata *opendata)\n{\n\tstruct nfs4_state *state = opendata->state;\n\tstruct nfs_delegation *delegation;\n\tint open_mode = opendata->o_arg.open_flags;\n\tfmode_t fmode = opendata->o_arg.fmode;\n\tenum open_claim_type4 claim = opendata->o_arg.claim;\n\tnfs4_stateid stateid;\n\tint ret = -EAGAIN;\n\n\tfor (;;) {\n\t\tspin_lock(&state->owner->so_lock);\n\t\tif (can_open_cached(state, fmode, open_mode, claim)) {\n\t\t\tupdate_open_stateflags(state, fmode);\n\t\t\tspin_unlock(&state->owner->so_lock);\n\t\t\tgoto out_return_state;\n\t\t}\n\t\tspin_unlock(&state->owner->so_lock);\n\t\trcu_read_lock();\n\t\tdelegation = nfs4_get_valid_delegation(state->inode);\n\t\tif (!can_open_delegated(delegation, fmode, claim)) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tnfs4_stateid_copy(&stateid, &delegation->stateid);\n\t\trcu_read_unlock();\n\t\tnfs_release_seqid(opendata->o_arg.seqid);\n\t\tif (!opendata->is_recover) {\n\t\t\tret = nfs_may_open(state->inode, state->owner->so_cred, open_mode);\n\t\t\tif (ret != 0)\n\t\t\t\tgoto out;\n\t\t}\n\t\tret = -EAGAIN;\n\n\t\t \n\t\tif (update_open_stateid(state, NULL, &stateid, fmode))\n\t\t\tgoto out_return_state;\n\t}\nout:\n\treturn ERR_PTR(ret);\nout_return_state:\n\trefcount_inc(&state->count);\n\treturn state;\n}\n\nstatic void\nnfs4_opendata_check_deleg(struct nfs4_opendata *data, struct nfs4_state *state)\n{\n\tstruct nfs_client *clp = NFS_SERVER(state->inode)->nfs_client;\n\tstruct nfs_delegation *delegation;\n\tint delegation_flags = 0;\n\n\trcu_read_lock();\n\tdelegation = rcu_dereference(NFS_I(state->inode)->delegation);\n\tif (delegation)\n\t\tdelegation_flags = delegation->flags;\n\trcu_read_unlock();\n\tswitch (data->o_arg.claim) {\n\tdefault:\n\t\tbreak;\n\tcase NFS4_OPEN_CLAIM_DELEGATE_CUR:\n\tcase NFS4_OPEN_CLAIM_DELEG_CUR_FH:\n\t\tpr_err_ratelimited(\"NFS: Broken NFSv4 server %s is \"\n\t\t\t\t   \"returning a delegation for \"\n\t\t\t\t   \"OPEN(CLAIM_DELEGATE_CUR)\\n\",\n\t\t\t\t   clp->cl_hostname);\n\t\treturn;\n\t}\n\tif ((delegation_flags & 1UL<<NFS_DELEGATION_NEED_RECLAIM) == 0)\n\t\tnfs_inode_set_delegation(state->inode,\n\t\t\t\tdata->owner->so_cred,\n\t\t\t\tdata->o_res.delegation_type,\n\t\t\t\t&data->o_res.delegation,\n\t\t\t\tdata->o_res.pagemod_limit);\n\telse\n\t\tnfs_inode_reclaim_delegation(state->inode,\n\t\t\t\tdata->owner->so_cred,\n\t\t\t\tdata->o_res.delegation_type,\n\t\t\t\t&data->o_res.delegation,\n\t\t\t\tdata->o_res.pagemod_limit);\n\n\tif (data->o_res.do_recall)\n\t\tnfs_async_inode_return_delegation(state->inode,\n\t\t\t\t\t\t  &data->o_res.delegation);\n}\n\n \nstatic struct nfs4_state *\n_nfs4_opendata_reclaim_to_nfs4_state(struct nfs4_opendata *data)\n{\n\tstruct inode *inode = data->state->inode;\n\tstruct nfs4_state *state = data->state;\n\tint ret;\n\n\tif (!data->rpc_done) {\n\t\tif (data->rpc_status)\n\t\t\treturn ERR_PTR(data->rpc_status);\n\t\treturn nfs4_try_open_cached(data);\n\t}\n\n\tret = nfs_refresh_inode(inode, &data->f_attr);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tif (data->o_res.delegation_type != 0)\n\t\tnfs4_opendata_check_deleg(data, state);\n\n\tif (!update_open_stateid(state, &data->o_res.stateid,\n\t\t\t\tNULL, data->o_arg.fmode))\n\t\treturn ERR_PTR(-EAGAIN);\n\trefcount_inc(&state->count);\n\n\treturn state;\n}\n\nstatic struct inode *\nnfs4_opendata_get_inode(struct nfs4_opendata *data)\n{\n\tstruct inode *inode;\n\n\tswitch (data->o_arg.claim) {\n\tcase NFS4_OPEN_CLAIM_NULL:\n\tcase NFS4_OPEN_CLAIM_DELEGATE_CUR:\n\tcase NFS4_OPEN_CLAIM_DELEGATE_PREV:\n\t\tif (!(data->f_attr.valid & NFS_ATTR_FATTR))\n\t\t\treturn ERR_PTR(-EAGAIN);\n\t\tinode = nfs_fhget(data->dir->d_sb, &data->o_res.fh,\n\t\t\t\t&data->f_attr);\n\t\tbreak;\n\tdefault:\n\t\tinode = d_inode(data->dentry);\n\t\tihold(inode);\n\t\tnfs_refresh_inode(inode, &data->f_attr);\n\t}\n\treturn inode;\n}\n\nstatic struct nfs4_state *\nnfs4_opendata_find_nfs4_state(struct nfs4_opendata *data)\n{\n\tstruct nfs4_state *state;\n\tstruct inode *inode;\n\n\tinode = nfs4_opendata_get_inode(data);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\tif (data->state != NULL && data->state->inode == inode) {\n\t\tstate = data->state;\n\t\trefcount_inc(&state->count);\n\t} else\n\t\tstate = nfs4_get_open_state(inode, data->owner);\n\tiput(inode);\n\tif (state == NULL)\n\t\tstate = ERR_PTR(-ENOMEM);\n\treturn state;\n}\n\nstatic struct nfs4_state *\n_nfs4_opendata_to_nfs4_state(struct nfs4_opendata *data)\n{\n\tstruct nfs4_state *state;\n\n\tif (!data->rpc_done) {\n\t\tstate = nfs4_try_open_cached(data);\n\t\ttrace_nfs4_cached_open(data->state);\n\t\tgoto out;\n\t}\n\n\tstate = nfs4_opendata_find_nfs4_state(data);\n\tif (IS_ERR(state))\n\t\tgoto out;\n\n\tif (data->o_res.delegation_type != 0)\n\t\tnfs4_opendata_check_deleg(data, state);\n\tif (!update_open_stateid(state, &data->o_res.stateid,\n\t\t\t\tNULL, data->o_arg.fmode)) {\n\t\tnfs4_put_open_state(state);\n\t\tstate = ERR_PTR(-EAGAIN);\n\t}\nout:\n\tnfs_release_seqid(data->o_arg.seqid);\n\treturn state;\n}\n\nstatic struct nfs4_state *\nnfs4_opendata_to_nfs4_state(struct nfs4_opendata *data)\n{\n\tstruct nfs4_state *ret;\n\n\tif (data->o_arg.claim == NFS4_OPEN_CLAIM_PREVIOUS)\n\t\tret =_nfs4_opendata_reclaim_to_nfs4_state(data);\n\telse\n\t\tret = _nfs4_opendata_to_nfs4_state(data);\n\tnfs4_sequence_free_slot(&data->o_res.seq_res);\n\treturn ret;\n}\n\nstatic struct nfs_open_context *\nnfs4_state_find_open_context_mode(struct nfs4_state *state, fmode_t mode)\n{\n\tstruct nfs_inode *nfsi = NFS_I(state->inode);\n\tstruct nfs_open_context *ctx;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(ctx, &nfsi->open_files, list) {\n\t\tif (ctx->state != state)\n\t\t\tcontinue;\n\t\tif ((ctx->mode & mode) != mode)\n\t\t\tcontinue;\n\t\tif (!get_nfs_open_context(ctx))\n\t\t\tcontinue;\n\t\trcu_read_unlock();\n\t\treturn ctx;\n\t}\n\trcu_read_unlock();\n\treturn ERR_PTR(-ENOENT);\n}\n\nstatic struct nfs_open_context *\nnfs4_state_find_open_context(struct nfs4_state *state)\n{\n\tstruct nfs_open_context *ctx;\n\n\tctx = nfs4_state_find_open_context_mode(state, FMODE_READ|FMODE_WRITE);\n\tif (!IS_ERR(ctx))\n\t\treturn ctx;\n\tctx = nfs4_state_find_open_context_mode(state, FMODE_WRITE);\n\tif (!IS_ERR(ctx))\n\t\treturn ctx;\n\treturn nfs4_state_find_open_context_mode(state, FMODE_READ);\n}\n\nstatic struct nfs4_opendata *nfs4_open_recoverdata_alloc(struct nfs_open_context *ctx,\n\t\tstruct nfs4_state *state, enum open_claim_type4 claim)\n{\n\tstruct nfs4_opendata *opendata;\n\n\topendata = nfs4_opendata_alloc(ctx->dentry, state->owner, 0, 0,\n\t\t\tNULL, claim, GFP_NOFS);\n\tif (opendata == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\topendata->state = state;\n\trefcount_inc(&state->count);\n\treturn opendata;\n}\n\nstatic int nfs4_open_recover_helper(struct nfs4_opendata *opendata,\n\t\t\t\t    fmode_t fmode)\n{\n\tstruct nfs4_state *newstate;\n\tstruct nfs_server *server = NFS_SB(opendata->dentry->d_sb);\n\tint openflags = opendata->o_arg.open_flags;\n\tint ret;\n\n\tif (!nfs4_mode_match_open_stateid(opendata->state, fmode))\n\t\treturn 0;\n\topendata->o_arg.fmode = fmode;\n\topendata->o_arg.share_access =\n\t\tnfs4_map_atomic_open_share(server, fmode, openflags);\n\tmemset(&opendata->o_res, 0, sizeof(opendata->o_res));\n\tmemset(&opendata->c_res, 0, sizeof(opendata->c_res));\n\tnfs4_init_opendata_res(opendata);\n\tret = _nfs4_recover_proc_open(opendata);\n\tif (ret != 0)\n\t\treturn ret; \n\tnewstate = nfs4_opendata_to_nfs4_state(opendata);\n\tif (IS_ERR(newstate))\n\t\treturn PTR_ERR(newstate);\n\tif (newstate != opendata->state)\n\t\tret = -ESTALE;\n\tnfs4_close_state(newstate, fmode);\n\treturn ret;\n}\n\nstatic int nfs4_open_recover(struct nfs4_opendata *opendata, struct nfs4_state *state)\n{\n\tint ret;\n\n\t \n\tsmp_rmb();\n\tret = nfs4_open_recover_helper(opendata, FMODE_READ|FMODE_WRITE);\n\tif (ret != 0)\n\t\treturn ret;\n\tret = nfs4_open_recover_helper(opendata, FMODE_WRITE);\n\tif (ret != 0)\n\t\treturn ret;\n\tret = nfs4_open_recover_helper(opendata, FMODE_READ);\n\tif (ret != 0)\n\t\treturn ret;\n\t \n\tif (test_bit(NFS_DELEGATED_STATE, &state->flags) == 0 &&\n\t    !nfs4_stateid_match(&state->stateid, &state->open_stateid)) {\n\t\twrite_seqlock(&state->seqlock);\n\t\tif (test_bit(NFS_DELEGATED_STATE, &state->flags) == 0)\n\t\t\tnfs4_stateid_copy(&state->stateid, &state->open_stateid);\n\t\twrite_sequnlock(&state->seqlock);\n\t}\n\treturn 0;\n}\n\n \nstatic int _nfs4_do_open_reclaim(struct nfs_open_context *ctx, struct nfs4_state *state)\n{\n\tstruct nfs_delegation *delegation;\n\tstruct nfs4_opendata *opendata;\n\tfmode_t delegation_type = 0;\n\tint status;\n\n\topendata = nfs4_open_recoverdata_alloc(ctx, state,\n\t\t\tNFS4_OPEN_CLAIM_PREVIOUS);\n\tif (IS_ERR(opendata))\n\t\treturn PTR_ERR(opendata);\n\trcu_read_lock();\n\tdelegation = rcu_dereference(NFS_I(state->inode)->delegation);\n\tif (delegation != NULL && test_bit(NFS_DELEGATION_NEED_RECLAIM, &delegation->flags) != 0)\n\t\tdelegation_type = delegation->type;\n\trcu_read_unlock();\n\topendata->o_arg.u.delegation_type = delegation_type;\n\tstatus = nfs4_open_recover(opendata, state);\n\tnfs4_opendata_put(opendata);\n\treturn status;\n}\n\nstatic int nfs4_do_open_reclaim(struct nfs_open_context *ctx, struct nfs4_state *state)\n{\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = _nfs4_do_open_reclaim(ctx, state);\n\t\ttrace_nfs4_open_reclaim(ctx, 0, err);\n\t\tif (nfs4_clear_cap_atomic_open_v1(server, err, &exception))\n\t\t\tcontinue;\n\t\tif (err != -NFS4ERR_DELAY)\n\t\t\tbreak;\n\t\tnfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int nfs4_open_reclaim(struct nfs4_state_owner *sp, struct nfs4_state *state)\n{\n\tstruct nfs_open_context *ctx;\n\tint ret;\n\n\tctx = nfs4_state_find_open_context(state);\n\tif (IS_ERR(ctx))\n\t\treturn -EAGAIN;\n\tclear_bit(NFS_DELEGATED_STATE, &state->flags);\n\tnfs_state_clear_open_state_flags(state);\n\tret = nfs4_do_open_reclaim(ctx, state);\n\tput_nfs_open_context(ctx);\n\treturn ret;\n}\n\nstatic int nfs4_handle_delegation_recall_error(struct nfs_server *server, struct nfs4_state *state, const nfs4_stateid *stateid, struct file_lock *fl, int err)\n{\n\tswitch (err) {\n\t\tdefault:\n\t\t\tprintk(KERN_ERR \"NFS: %s: unhandled error \"\n\t\t\t\t\t\"%d.\\n\", __func__, err);\n\t\t\tfallthrough;\n\t\tcase 0:\n\t\tcase -ENOENT:\n\t\tcase -EAGAIN:\n\t\tcase -ESTALE:\n\t\tcase -ETIMEDOUT:\n\t\t\tbreak;\n\t\tcase -NFS4ERR_BADSESSION:\n\t\tcase -NFS4ERR_BADSLOT:\n\t\tcase -NFS4ERR_BAD_HIGH_SLOT:\n\t\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\t\tcase -NFS4ERR_DEADSESSION:\n\t\t\treturn -EAGAIN;\n\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\tcase -NFS4ERR_STALE_STATEID:\n\t\t\t \n\t\t\tnfs4_schedule_lease_recovery(server->nfs_client);\n\t\t\treturn -EAGAIN;\n\t\tcase -NFS4ERR_MOVED:\n\t\t\tnfs4_schedule_migration_recovery(server);\n\t\t\treturn -EAGAIN;\n\t\tcase -NFS4ERR_LEASE_MOVED:\n\t\t\tnfs4_schedule_lease_moved_recovery(server->nfs_client);\n\t\t\treturn -EAGAIN;\n\t\tcase -NFS4ERR_DELEG_REVOKED:\n\t\tcase -NFS4ERR_ADMIN_REVOKED:\n\t\tcase -NFS4ERR_EXPIRED:\n\t\tcase -NFS4ERR_BAD_STATEID:\n\t\tcase -NFS4ERR_OPENMODE:\n\t\t\tnfs_inode_find_state_and_recover(state->inode,\n\t\t\t\t\tstateid);\n\t\t\tnfs4_schedule_stateid_recovery(server, state);\n\t\t\treturn -EAGAIN;\n\t\tcase -NFS4ERR_DELAY:\n\t\tcase -NFS4ERR_GRACE:\n\t\t\tssleep(1);\n\t\t\treturn -EAGAIN;\n\t\tcase -ENOMEM:\n\t\tcase -NFS4ERR_DENIED:\n\t\t\tif (fl) {\n\t\t\t\tstruct nfs4_lock_state *lsp = fl->fl_u.nfs4_fl.owner;\n\t\t\t\tif (lsp)\n\t\t\t\t\tset_bit(NFS_LOCK_LOST, &lsp->ls_flags);\n\t\t\t}\n\t\t\treturn 0;\n\t}\n\treturn err;\n}\n\nint nfs4_open_delegation_recall(struct nfs_open_context *ctx,\n\t\tstruct nfs4_state *state, const nfs4_stateid *stateid)\n{\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tstruct nfs4_opendata *opendata;\n\tint err = 0;\n\n\topendata = nfs4_open_recoverdata_alloc(ctx, state,\n\t\t\tNFS4_OPEN_CLAIM_DELEG_CUR_FH);\n\tif (IS_ERR(opendata))\n\t\treturn PTR_ERR(opendata);\n\tnfs4_stateid_copy(&opendata->o_arg.u.delegation, stateid);\n\tif (!test_bit(NFS_O_RDWR_STATE, &state->flags)) {\n\t\terr = nfs4_open_recover_helper(opendata, FMODE_READ|FMODE_WRITE);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\tif (!test_bit(NFS_O_WRONLY_STATE, &state->flags)) {\n\t\terr = nfs4_open_recover_helper(opendata, FMODE_WRITE);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\tif (!test_bit(NFS_O_RDONLY_STATE, &state->flags)) {\n\t\terr = nfs4_open_recover_helper(opendata, FMODE_READ);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\tnfs_state_clear_delegation(state);\nout:\n\tnfs4_opendata_put(opendata);\n\treturn nfs4_handle_delegation_recall_error(server, state, stateid, NULL, err);\n}\n\nstatic void nfs4_open_confirm_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_opendata *data = calldata;\n\n\tnfs4_setup_sequence(data->o_arg.server->nfs_client,\n\t\t\t   &data->c_arg.seq_args, &data->c_res.seq_res, task);\n}\n\nstatic void nfs4_open_confirm_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_opendata *data = calldata;\n\n\tnfs40_sequence_done(task, &data->c_res.seq_res);\n\n\tdata->rpc_status = task->tk_status;\n\tif (data->rpc_status == 0) {\n\t\tnfs4_stateid_copy(&data->o_res.stateid, &data->c_res.stateid);\n\t\tnfs_confirm_seqid(&data->owner->so_seqid, 0);\n\t\trenew_lease(data->o_res.server, data->timestamp);\n\t\tdata->rpc_done = true;\n\t}\n}\n\nstatic void nfs4_open_confirm_release(void *calldata)\n{\n\tstruct nfs4_opendata *data = calldata;\n\tstruct nfs4_state *state = NULL;\n\n\t \n\tif (!data->cancelled)\n\t\tgoto out_free;\n\t \n\tif (!data->rpc_done)\n\t\tgoto out_free;\n\tstate = nfs4_opendata_to_nfs4_state(data);\n\tif (!IS_ERR(state))\n\t\tnfs4_close_state(state, data->o_arg.fmode);\nout_free:\n\tnfs4_opendata_put(data);\n}\n\nstatic const struct rpc_call_ops nfs4_open_confirm_ops = {\n\t.rpc_call_prepare = nfs4_open_confirm_prepare,\n\t.rpc_call_done = nfs4_open_confirm_done,\n\t.rpc_release = nfs4_open_confirm_release,\n};\n\n \nstatic int _nfs4_proc_open_confirm(struct nfs4_opendata *data)\n{\n\tstruct nfs_server *server = NFS_SERVER(d_inode(data->dir));\n\tstruct rpc_task *task;\n\tstruct  rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_OPEN_CONFIRM],\n\t\t.rpc_argp = &data->c_arg,\n\t\t.rpc_resp = &data->c_res,\n\t\t.rpc_cred = data->owner->so_cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = server->client,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_open_confirm_ops,\n\t\t.callback_data = data,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC | RPC_TASK_CRED_NOREF,\n\t};\n\tint status;\n\n\tnfs4_init_sequence(&data->c_arg.seq_args, &data->c_res.seq_res, 1,\n\t\t\t\tdata->is_recover);\n\tkref_get(&data->kref);\n\tdata->rpc_done = false;\n\tdata->rpc_status = 0;\n\tdata->timestamp = jiffies;\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tstatus = rpc_wait_for_completion_task(task);\n\tif (status != 0) {\n\t\tdata->cancelled = true;\n\t\tsmp_wmb();\n\t} else\n\t\tstatus = data->rpc_status;\n\trpc_put_task(task);\n\treturn status;\n}\n\nstatic void nfs4_open_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_opendata *data = calldata;\n\tstruct nfs4_state_owner *sp = data->owner;\n\tstruct nfs_client *clp = sp->so_server->nfs_client;\n\tenum open_claim_type4 claim = data->o_arg.claim;\n\n\tif (nfs_wait_on_sequence(data->o_arg.seqid, task) != 0)\n\t\tgoto out_wait;\n\t \n\tif (data->state != NULL) {\n\t\tstruct nfs_delegation *delegation;\n\n\t\tif (can_open_cached(data->state, data->o_arg.fmode,\n\t\t\t\t\tdata->o_arg.open_flags, claim))\n\t\t\tgoto out_no_action;\n\t\trcu_read_lock();\n\t\tdelegation = nfs4_get_valid_delegation(data->state->inode);\n\t\tif (can_open_delegated(delegation, data->o_arg.fmode, claim))\n\t\t\tgoto unlock_no_action;\n\t\trcu_read_unlock();\n\t}\n\t \n\tdata->o_arg.clientid = clp->cl_clientid;\n\tswitch (claim) {\n\tdefault:\n\t\tbreak;\n\tcase NFS4_OPEN_CLAIM_PREVIOUS:\n\tcase NFS4_OPEN_CLAIM_DELEG_CUR_FH:\n\tcase NFS4_OPEN_CLAIM_DELEG_PREV_FH:\n\t\tdata->o_arg.open_bitmap = &nfs4_open_noattr_bitmap[0];\n\t\tfallthrough;\n\tcase NFS4_OPEN_CLAIM_FH:\n\t\ttask->tk_msg.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_OPEN_NOATTR];\n\t}\n\tdata->timestamp = jiffies;\n\tif (nfs4_setup_sequence(data->o_arg.server->nfs_client,\n\t\t\t\t&data->o_arg.seq_args,\n\t\t\t\t&data->o_res.seq_res,\n\t\t\t\ttask) != 0)\n\t\tnfs_release_seqid(data->o_arg.seqid);\n\n\t \n\tdata->o_arg.createmode = NFS4_CREATE_UNCHECKED;\n\tif (data->o_arg.open_flags & O_EXCL) {\n\t\tdata->o_arg.createmode = NFS4_CREATE_EXCLUSIVE4_1;\n\t\tif (clp->cl_mvops->minor_version == 0) {\n\t\t\tdata->o_arg.createmode = NFS4_CREATE_EXCLUSIVE;\n\t\t\t \n\t\t\tdata->o_res.access_request = data->o_arg.access = 0;\n\t\t} else if (nfs4_has_persistent_session(clp))\n\t\t\tdata->o_arg.createmode = NFS4_CREATE_GUARDED;\n\t}\n\treturn;\nunlock_no_action:\n\ttrace_nfs4_cached_open(data->state);\n\trcu_read_unlock();\nout_no_action:\n\ttask->tk_action = NULL;\nout_wait:\n\tnfs4_sequence_done(task, &data->o_res.seq_res);\n}\n\nstatic void nfs4_open_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_opendata *data = calldata;\n\n\tdata->rpc_status = task->tk_status;\n\n\tif (!nfs4_sequence_process(task, &data->o_res.seq_res))\n\t\treturn;\n\n\tif (task->tk_status == 0) {\n\t\tif (data->o_res.f_attr->valid & NFS_ATTR_FATTR_TYPE) {\n\t\t\tswitch (data->o_res.f_attr->mode & S_IFMT) {\n\t\t\tcase S_IFREG:\n\t\t\t\tbreak;\n\t\t\tcase S_IFLNK:\n\t\t\t\tdata->rpc_status = -ELOOP;\n\t\t\t\tbreak;\n\t\t\tcase S_IFDIR:\n\t\t\t\tdata->rpc_status = -EISDIR;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdata->rpc_status = -ENOTDIR;\n\t\t\t}\n\t\t}\n\t\trenew_lease(data->o_res.server, data->timestamp);\n\t\tif (!(data->o_res.rflags & NFS4_OPEN_RESULT_CONFIRM))\n\t\t\tnfs_confirm_seqid(&data->owner->so_seqid, 0);\n\t}\n\tdata->rpc_done = true;\n}\n\nstatic void nfs4_open_release(void *calldata)\n{\n\tstruct nfs4_opendata *data = calldata;\n\tstruct nfs4_state *state = NULL;\n\n\t \n\tif (!data->cancelled)\n\t\tgoto out_free;\n\t \n\tif (data->rpc_status != 0 || !data->rpc_done)\n\t\tgoto out_free;\n\t \n\tif (data->o_res.rflags & NFS4_OPEN_RESULT_CONFIRM)\n\t\tgoto out_free;\n\tstate = nfs4_opendata_to_nfs4_state(data);\n\tif (!IS_ERR(state))\n\t\tnfs4_close_state(state, data->o_arg.fmode);\nout_free:\n\tnfs4_opendata_put(data);\n}\n\nstatic const struct rpc_call_ops nfs4_open_ops = {\n\t.rpc_call_prepare = nfs4_open_prepare,\n\t.rpc_call_done = nfs4_open_done,\n\t.rpc_release = nfs4_open_release,\n};\n\nstatic int nfs4_run_open_task(struct nfs4_opendata *data,\n\t\t\t      struct nfs_open_context *ctx)\n{\n\tstruct inode *dir = d_inode(data->dir);\n\tstruct nfs_server *server = NFS_SERVER(dir);\n\tstruct nfs_openargs *o_arg = &data->o_arg;\n\tstruct nfs_openres *o_res = &data->o_res;\n\tstruct rpc_task *task;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_OPEN],\n\t\t.rpc_argp = o_arg,\n\t\t.rpc_resp = o_res,\n\t\t.rpc_cred = data->owner->so_cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = server->client,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_open_ops,\n\t\t.callback_data = data,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC | RPC_TASK_CRED_NOREF,\n\t};\n\tint status;\n\n\tif (nfs_server_capable(dir, NFS_CAP_MOVEABLE))\n\t\ttask_setup_data.flags |= RPC_TASK_MOVEABLE;\n\n\tkref_get(&data->kref);\n\tdata->rpc_done = false;\n\tdata->rpc_status = 0;\n\tdata->cancelled = false;\n\tdata->is_recover = false;\n\tif (!ctx) {\n\t\tnfs4_init_sequence(&o_arg->seq_args, &o_res->seq_res, 1, 1);\n\t\tdata->is_recover = true;\n\t\ttask_setup_data.flags |= RPC_TASK_TIMEOUT;\n\t} else {\n\t\tnfs4_init_sequence(&o_arg->seq_args, &o_res->seq_res, 1, 0);\n\t\tpnfs_lgopen_prepare(data, ctx);\n\t}\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tstatus = rpc_wait_for_completion_task(task);\n\tif (status != 0) {\n\t\tdata->cancelled = true;\n\t\tsmp_wmb();\n\t} else\n\t\tstatus = data->rpc_status;\n\trpc_put_task(task);\n\n\treturn status;\n}\n\nstatic int _nfs4_recover_proc_open(struct nfs4_opendata *data)\n{\n\tstruct inode *dir = d_inode(data->dir);\n\tstruct nfs_openres *o_res = &data->o_res;\n\tint status;\n\n\tstatus = nfs4_run_open_task(data, NULL);\n\tif (status != 0 || !data->rpc_done)\n\t\treturn status;\n\n\tnfs_fattr_map_and_free_names(NFS_SERVER(dir), &data->f_attr);\n\n\tif (o_res->rflags & NFS4_OPEN_RESULT_CONFIRM)\n\t\tstatus = _nfs4_proc_open_confirm(data);\n\n\treturn status;\n}\n\n \nstatic int nfs4_opendata_access(const struct cred *cred,\n\t\t\t\tstruct nfs4_opendata *opendata,\n\t\t\t\tstruct nfs4_state *state, fmode_t fmode)\n{\n\tstruct nfs_access_entry cache;\n\tu32 mask, flags;\n\n\t \n\tif (opendata->o_res.access_supported == 0)\n\t\treturn 0;\n\n\tmask = 0;\n\tif (fmode & FMODE_EXEC) {\n\t\t \n\t\tif (S_ISDIR(state->inode->i_mode))\n\t\t\tmask = NFS4_ACCESS_LOOKUP;\n\t\telse\n\t\t\tmask = NFS4_ACCESS_EXECUTE;\n\t} else if ((fmode & FMODE_READ) && !opendata->file_created)\n\t\tmask = NFS4_ACCESS_READ;\n\n\tnfs_access_set_mask(&cache, opendata->o_res.access_result);\n\tnfs_access_add_cache(state->inode, &cache, cred);\n\n\tflags = NFS4_ACCESS_READ | NFS4_ACCESS_EXECUTE | NFS4_ACCESS_LOOKUP;\n\tif ((mask & ~cache.mask & flags) == 0)\n\t\treturn 0;\n\n\treturn -EACCES;\n}\n\n \nstatic int _nfs4_proc_open(struct nfs4_opendata *data,\n\t\t\t   struct nfs_open_context *ctx)\n{\n\tstruct inode *dir = d_inode(data->dir);\n\tstruct nfs_server *server = NFS_SERVER(dir);\n\tstruct nfs_openargs *o_arg = &data->o_arg;\n\tstruct nfs_openres *o_res = &data->o_res;\n\tint status;\n\n\tstatus = nfs4_run_open_task(data, ctx);\n\tif (!data->rpc_done)\n\t\treturn status;\n\tif (status != 0) {\n\t\tif (status == -NFS4ERR_BADNAME &&\n\t\t\t\t!(o_arg->open_flags & O_CREAT))\n\t\t\treturn -ENOENT;\n\t\treturn status;\n\t}\n\n\tnfs_fattr_map_and_free_names(server, &data->f_attr);\n\n\tif (o_arg->open_flags & O_CREAT) {\n\t\tif (o_arg->open_flags & O_EXCL)\n\t\t\tdata->file_created = true;\n\t\telse if (o_res->cinfo.before != o_res->cinfo.after)\n\t\t\tdata->file_created = true;\n\t\tif (data->file_created ||\n\t\t    inode_peek_iversion_raw(dir) != o_res->cinfo.after)\n\t\t\tnfs4_update_changeattr(dir, &o_res->cinfo,\n\t\t\t\t\to_res->f_attr->time_start,\n\t\t\t\t\tNFS_INO_INVALID_DATA);\n\t}\n\tif ((o_res->rflags & NFS4_OPEN_RESULT_LOCKTYPE_POSIX) == 0)\n\t\tserver->caps &= ~NFS_CAP_POSIX_LOCK;\n\tif(o_res->rflags & NFS4_OPEN_RESULT_CONFIRM) {\n\t\tstatus = _nfs4_proc_open_confirm(data);\n\t\tif (status != 0)\n\t\t\treturn status;\n\t}\n\tif (!(o_res->f_attr->valid & NFS_ATTR_FATTR)) {\n\t\tstruct nfs_fh *fh = &o_res->fh;\n\n\t\tnfs4_sequence_free_slot(&o_res->seq_res);\n\t\tif (o_arg->claim == NFS4_OPEN_CLAIM_FH)\n\t\t\tfh = NFS_FH(d_inode(data->dentry));\n\t\tnfs4_proc_getattr(server, fh, o_res->f_attr, NULL);\n\t}\n\treturn 0;\n}\n\n \nstatic int _nfs4_open_expired(struct nfs_open_context *ctx, struct nfs4_state *state)\n{\n\tstruct nfs4_opendata *opendata;\n\tint ret;\n\n\topendata = nfs4_open_recoverdata_alloc(ctx, state, NFS4_OPEN_CLAIM_FH);\n\tif (IS_ERR(opendata))\n\t\treturn PTR_ERR(opendata);\n\t \n\topendata->o_arg.open_flags = O_DIRECT;\n\tret = nfs4_open_recover(opendata, state);\n\tif (ret == -ESTALE)\n\t\td_drop(ctx->dentry);\n\tnfs4_opendata_put(opendata);\n\treturn ret;\n}\n\nstatic int nfs4_do_open_expired(struct nfs_open_context *ctx, struct nfs4_state *state)\n{\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tstruct nfs4_exception exception = { };\n\tint err;\n\n\tdo {\n\t\terr = _nfs4_open_expired(ctx, state);\n\t\ttrace_nfs4_open_expired(ctx, 0, err);\n\t\tif (nfs4_clear_cap_atomic_open_v1(server, err, &exception))\n\t\t\tcontinue;\n\t\tswitch (err) {\n\t\tdefault:\n\t\t\tgoto out;\n\t\tcase -NFS4ERR_GRACE:\n\t\tcase -NFS4ERR_DELAY:\n\t\t\tnfs4_handle_exception(server, err, &exception);\n\t\t\terr = 0;\n\t\t}\n\t} while (exception.retry);\nout:\n\treturn err;\n}\n\nstatic int nfs4_open_expired(struct nfs4_state_owner *sp, struct nfs4_state *state)\n{\n\tstruct nfs_open_context *ctx;\n\tint ret;\n\n\tctx = nfs4_state_find_open_context(state);\n\tif (IS_ERR(ctx))\n\t\treturn -EAGAIN;\n\tret = nfs4_do_open_expired(ctx, state);\n\tput_nfs_open_context(ctx);\n\treturn ret;\n}\n\nstatic void nfs_finish_clear_delegation_stateid(struct nfs4_state *state,\n\t\tconst nfs4_stateid *stateid)\n{\n\tnfs_remove_bad_delegation(state->inode, stateid);\n\tnfs_state_clear_delegation(state);\n}\n\nstatic void nfs40_clear_delegation_stateid(struct nfs4_state *state)\n{\n\tif (rcu_access_pointer(NFS_I(state->inode)->delegation) != NULL)\n\t\tnfs_finish_clear_delegation_stateid(state, NULL);\n}\n\nstatic int nfs40_open_expired(struct nfs4_state_owner *sp, struct nfs4_state *state)\n{\n\t \n\tnfs40_clear_delegation_stateid(state);\n\tnfs_state_clear_open_state_flags(state);\n\treturn nfs4_open_expired(sp, state);\n}\n\nstatic int nfs40_test_and_free_expired_stateid(struct nfs_server *server,\n\t\tnfs4_stateid *stateid,\n\t\tconst struct cred *cred)\n{\n\treturn -NFS4ERR_BAD_STATEID;\n}\n\n#if defined(CONFIG_NFS_V4_1)\nstatic int nfs41_test_and_free_expired_stateid(struct nfs_server *server,\n\t\tnfs4_stateid *stateid,\n\t\tconst struct cred *cred)\n{\n\tint status;\n\n\tswitch (stateid->type) {\n\tdefault:\n\t\tbreak;\n\tcase NFS4_INVALID_STATEID_TYPE:\n\tcase NFS4_SPECIAL_STATEID_TYPE:\n\t\treturn -NFS4ERR_BAD_STATEID;\n\tcase NFS4_REVOKED_STATEID_TYPE:\n\t\tgoto out_free;\n\t}\n\n\tstatus = nfs41_test_stateid(server, stateid, cred);\n\tswitch (status) {\n\tcase -NFS4ERR_EXPIRED:\n\tcase -NFS4ERR_ADMIN_REVOKED:\n\tcase -NFS4ERR_DELEG_REVOKED:\n\t\tbreak;\n\tdefault:\n\t\treturn status;\n\t}\nout_free:\n\t \n\tnfs41_free_stateid(server, stateid, cred, true);\n\treturn -NFS4ERR_EXPIRED;\n}\n\nstatic int nfs41_check_delegation_stateid(struct nfs4_state *state)\n{\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tnfs4_stateid stateid;\n\tstruct nfs_delegation *delegation;\n\tconst struct cred *cred = NULL;\n\tint status, ret = NFS_OK;\n\n\t \n\trcu_read_lock();\n\tdelegation = rcu_dereference(NFS_I(state->inode)->delegation);\n\tif (delegation == NULL) {\n\t\trcu_read_unlock();\n\t\tnfs_state_clear_delegation(state);\n\t\treturn NFS_OK;\n\t}\n\n\tspin_lock(&delegation->lock);\n\tnfs4_stateid_copy(&stateid, &delegation->stateid);\n\n\tif (!test_and_clear_bit(NFS_DELEGATION_TEST_EXPIRED,\n\t\t\t\t&delegation->flags)) {\n\t\tspin_unlock(&delegation->lock);\n\t\trcu_read_unlock();\n\t\treturn NFS_OK;\n\t}\n\n\tif (delegation->cred)\n\t\tcred = get_cred(delegation->cred);\n\tspin_unlock(&delegation->lock);\n\trcu_read_unlock();\n\tstatus = nfs41_test_and_free_expired_stateid(server, &stateid, cred);\n\ttrace_nfs4_test_delegation_stateid(state, NULL, status);\n\tif (status == -NFS4ERR_EXPIRED || status == -NFS4ERR_BAD_STATEID)\n\t\tnfs_finish_clear_delegation_stateid(state, &stateid);\n\telse\n\t\tret = status;\n\n\tput_cred(cred);\n\treturn ret;\n}\n\nstatic void nfs41_delegation_recover_stateid(struct nfs4_state *state)\n{\n\tnfs4_stateid tmp;\n\n\tif (test_bit(NFS_DELEGATED_STATE, &state->flags) &&\n\t    nfs4_copy_delegation_stateid(state->inode, state->state,\n\t\t\t\t&tmp, NULL) &&\n\t    nfs4_stateid_match_other(&state->stateid, &tmp))\n\t\tnfs_state_set_delegation(state, &tmp, state->state);\n\telse\n\t\tnfs_state_clear_delegation(state);\n}\n\n \nstatic int nfs41_check_expired_locks(struct nfs4_state *state)\n{\n\tint status, ret = NFS_OK;\n\tstruct nfs4_lock_state *lsp, *prev = NULL;\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\n\tif (!test_bit(LK_STATE_IN_USE, &state->flags))\n\t\tgoto out;\n\n\tspin_lock(&state->state_lock);\n\tlist_for_each_entry(lsp, &state->lock_states, ls_locks) {\n\t\tif (test_bit(NFS_LOCK_INITIALIZED, &lsp->ls_flags)) {\n\t\t\tconst struct cred *cred = lsp->ls_state->owner->so_cred;\n\n\t\t\trefcount_inc(&lsp->ls_count);\n\t\t\tspin_unlock(&state->state_lock);\n\n\t\t\tnfs4_put_lock_state(prev);\n\t\t\tprev = lsp;\n\n\t\t\tstatus = nfs41_test_and_free_expired_stateid(server,\n\t\t\t\t\t&lsp->ls_stateid,\n\t\t\t\t\tcred);\n\t\t\ttrace_nfs4_test_lock_stateid(state, lsp, status);\n\t\t\tif (status == -NFS4ERR_EXPIRED ||\n\t\t\t    status == -NFS4ERR_BAD_STATEID) {\n\t\t\t\tclear_bit(NFS_LOCK_INITIALIZED, &lsp->ls_flags);\n\t\t\t\tlsp->ls_stateid.type = NFS4_INVALID_STATEID_TYPE;\n\t\t\t\tif (!recover_lost_locks)\n\t\t\t\t\tset_bit(NFS_LOCK_LOST, &lsp->ls_flags);\n\t\t\t} else if (status != NFS_OK) {\n\t\t\t\tret = status;\n\t\t\t\tnfs4_put_lock_state(prev);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tspin_lock(&state->state_lock);\n\t\t}\n\t}\n\tspin_unlock(&state->state_lock);\n\tnfs4_put_lock_state(prev);\nout:\n\treturn ret;\n}\n\n \nstatic int nfs41_check_open_stateid(struct nfs4_state *state)\n{\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tnfs4_stateid *stateid = &state->open_stateid;\n\tconst struct cred *cred = state->owner->so_cred;\n\tint status;\n\n\tif (test_bit(NFS_OPEN_STATE, &state->flags) == 0)\n\t\treturn -NFS4ERR_BAD_STATEID;\n\tstatus = nfs41_test_and_free_expired_stateid(server, stateid, cred);\n\ttrace_nfs4_test_open_stateid(state, NULL, status);\n\tif (status == -NFS4ERR_EXPIRED || status == -NFS4ERR_BAD_STATEID) {\n\t\tnfs_state_clear_open_state_flags(state);\n\t\tstateid->type = NFS4_INVALID_STATEID_TYPE;\n\t\treturn status;\n\t}\n\tif (nfs_open_stateid_recover_openmode(state))\n\t\treturn -NFS4ERR_OPENMODE;\n\treturn NFS_OK;\n}\n\nstatic int nfs41_open_expired(struct nfs4_state_owner *sp, struct nfs4_state *state)\n{\n\tint status;\n\n\tstatus = nfs41_check_delegation_stateid(state);\n\tif (status != NFS_OK)\n\t\treturn status;\n\tnfs41_delegation_recover_stateid(state);\n\n\tstatus = nfs41_check_expired_locks(state);\n\tif (status != NFS_OK)\n\t\treturn status;\n\tstatus = nfs41_check_open_stateid(state);\n\tif (status != NFS_OK)\n\t\tstatus = nfs4_open_expired(sp, state);\n\treturn status;\n}\n#endif\n\n \nstatic unsigned nfs4_exclusive_attrset(struct nfs4_opendata *opendata,\n\t\t\t\tstruct iattr *sattr, struct nfs4_label **label)\n{\n\tconst __u32 *bitmask = opendata->o_arg.server->exclcreat_bitmask;\n\t__u32 attrset[3];\n\tunsigned ret;\n\tunsigned i;\n\n\tfor (i = 0; i < ARRAY_SIZE(attrset); i++) {\n\t\tattrset[i] = opendata->o_res.attrset[i];\n\t\tif (opendata->o_arg.createmode == NFS4_CREATE_EXCLUSIVE4_1)\n\t\t\tattrset[i] &= ~bitmask[i];\n\t}\n\n\tret = (opendata->o_arg.createmode == NFS4_CREATE_EXCLUSIVE) ?\n\t\tsattr->ia_valid : 0;\n\n\tif ((attrset[1] & (FATTR4_WORD1_TIME_ACCESS|FATTR4_WORD1_TIME_ACCESS_SET))) {\n\t\tif (sattr->ia_valid & ATTR_ATIME_SET)\n\t\t\tret |= ATTR_ATIME_SET;\n\t\telse\n\t\t\tret |= ATTR_ATIME;\n\t}\n\n\tif ((attrset[1] & (FATTR4_WORD1_TIME_MODIFY|FATTR4_WORD1_TIME_MODIFY_SET))) {\n\t\tif (sattr->ia_valid & ATTR_MTIME_SET)\n\t\t\tret |= ATTR_MTIME_SET;\n\t\telse\n\t\t\tret |= ATTR_MTIME;\n\t}\n\n\tif (!(attrset[2] & FATTR4_WORD2_SECURITY_LABEL))\n\t\t*label = NULL;\n\treturn ret;\n}\n\nstatic int _nfs4_open_and_get_state(struct nfs4_opendata *opendata,\n\t\tstruct nfs_open_context *ctx)\n{\n\tstruct nfs4_state_owner *sp = opendata->owner;\n\tstruct nfs_server *server = sp->so_server;\n\tstruct dentry *dentry;\n\tstruct nfs4_state *state;\n\tfmode_t acc_mode = _nfs4_ctx_to_accessmode(ctx);\n\tstruct inode *dir = d_inode(opendata->dir);\n\tunsigned long dir_verifier;\n\tunsigned int seq;\n\tint ret;\n\n\tseq = raw_seqcount_begin(&sp->so_reclaim_seqcount);\n\tdir_verifier = nfs_save_change_attribute(dir);\n\n\tret = _nfs4_proc_open(opendata, ctx);\n\tif (ret != 0)\n\t\tgoto out;\n\n\tstate = _nfs4_opendata_to_nfs4_state(opendata);\n\tret = PTR_ERR(state);\n\tif (IS_ERR(state))\n\t\tgoto out;\n\tctx->state = state;\n\tif (server->caps & NFS_CAP_POSIX_LOCK)\n\t\tset_bit(NFS_STATE_POSIX_LOCKS, &state->flags);\n\tif (opendata->o_res.rflags & NFS4_OPEN_RESULT_MAY_NOTIFY_LOCK)\n\t\tset_bit(NFS_STATE_MAY_NOTIFY_LOCK, &state->flags);\n\tif (opendata->o_res.rflags & NFS4_OPEN_RESULT_PRESERVE_UNLINKED)\n\t\tset_bit(NFS_INO_PRESERVE_UNLINKED, &NFS_I(state->inode)->flags);\n\n\tdentry = opendata->dentry;\n\tif (d_really_is_negative(dentry)) {\n\t\tstruct dentry *alias;\n\t\td_drop(dentry);\n\t\talias = d_exact_alias(dentry, state->inode);\n\t\tif (!alias)\n\t\t\talias = d_splice_alias(igrab(state->inode), dentry);\n\t\t \n\t\tif (alias) {\n\t\t\tdput(ctx->dentry);\n\t\t\tctx->dentry = dentry = alias;\n\t\t}\n\t}\n\n\tswitch(opendata->o_arg.claim) {\n\tdefault:\n\t\tbreak;\n\tcase NFS4_OPEN_CLAIM_NULL:\n\tcase NFS4_OPEN_CLAIM_DELEGATE_CUR:\n\tcase NFS4_OPEN_CLAIM_DELEGATE_PREV:\n\t\tif (!opendata->rpc_done)\n\t\t\tbreak;\n\t\tif (opendata->o_res.delegation_type != 0)\n\t\t\tdir_verifier = nfs_save_change_attribute(dir);\n\t\tnfs_set_verifier(dentry, dir_verifier);\n\t}\n\n\t \n\tpnfs_parse_lgopen(state->inode, opendata->lgp, ctx);\n\n\tret = nfs4_opendata_access(sp->so_cred, opendata, state, acc_mode);\n\tif (ret != 0)\n\t\tgoto out;\n\n\tif (d_inode(dentry) == state->inode) {\n\t\tnfs_inode_attach_open_context(ctx);\n\t\tif (read_seqcount_retry(&sp->so_reclaim_seqcount, seq))\n\t\t\tnfs4_schedule_stateid_recovery(server, state);\n\t}\n\nout:\n\tif (!opendata->cancelled) {\n\t\tif (opendata->lgp) {\n\t\t\tnfs4_lgopen_release(opendata->lgp);\n\t\t\topendata->lgp = NULL;\n\t\t}\n\t\tnfs4_sequence_free_slot(&opendata->o_res.seq_res);\n\t}\n\treturn ret;\n}\n\n \nstatic int _nfs4_do_open(struct inode *dir,\n\t\t\tstruct nfs_open_context *ctx,\n\t\t\tint flags,\n\t\t\tconst struct nfs4_open_createattrs *c,\n\t\t\tint *opened)\n{\n\tstruct nfs4_state_owner  *sp;\n\tstruct nfs4_state     *state = NULL;\n\tstruct nfs_server       *server = NFS_SERVER(dir);\n\tstruct nfs4_opendata *opendata;\n\tstruct dentry *dentry = ctx->dentry;\n\tconst struct cred *cred = ctx->cred;\n\tstruct nfs4_threshold **ctx_th = &ctx->mdsthreshold;\n\tfmode_t fmode = _nfs4_ctx_to_openmode(ctx);\n\tenum open_claim_type4 claim = NFS4_OPEN_CLAIM_NULL;\n\tstruct iattr *sattr = c->sattr;\n\tstruct nfs4_label *label = c->label;\n\tint status;\n\n\t \n\tstatus = -ENOMEM;\n\tsp = nfs4_get_state_owner(server, cred, GFP_KERNEL);\n\tif (sp == NULL) {\n\t\tdprintk(\"nfs4_do_open: nfs4_get_state_owner failed!\\n\");\n\t\tgoto out_err;\n\t}\n\tstatus = nfs4_client_recover_expired_lease(server->nfs_client);\n\tif (status != 0)\n\t\tgoto err_put_state_owner;\n\tif (d_really_is_positive(dentry))\n\t\tnfs4_return_incompatible_delegation(d_inode(dentry), fmode);\n\tstatus = -ENOMEM;\n\tif (d_really_is_positive(dentry))\n\t\tclaim = NFS4_OPEN_CLAIM_FH;\n\topendata = nfs4_opendata_alloc(dentry, sp, fmode, flags,\n\t\t\tc, claim, GFP_KERNEL);\n\tif (opendata == NULL)\n\t\tgoto err_put_state_owner;\n\n\tif (server->attr_bitmask[2] & FATTR4_WORD2_MDSTHRESHOLD) {\n\t\tif (!opendata->f_attr.mdsthreshold) {\n\t\t\topendata->f_attr.mdsthreshold = pnfs_mdsthreshold_alloc();\n\t\t\tif (!opendata->f_attr.mdsthreshold)\n\t\t\t\tgoto err_opendata_put;\n\t\t}\n\t\topendata->o_arg.open_bitmap = &nfs4_pnfs_open_bitmap[0];\n\t}\n\tif (d_really_is_positive(dentry))\n\t\topendata->state = nfs4_get_open_state(d_inode(dentry), sp);\n\n\tstatus = _nfs4_open_and_get_state(opendata, ctx);\n\tif (status != 0)\n\t\tgoto err_opendata_put;\n\tstate = ctx->state;\n\n\tif ((opendata->o_arg.open_flags & (O_CREAT|O_EXCL)) == (O_CREAT|O_EXCL) &&\n\t    (opendata->o_arg.createmode != NFS4_CREATE_GUARDED)) {\n\t\tunsigned attrs = nfs4_exclusive_attrset(opendata, sattr, &label);\n\t\t \n\t\tif (attrs || label) {\n\t\t\tunsigned ia_old = sattr->ia_valid;\n\n\t\t\tsattr->ia_valid = attrs;\n\t\t\tnfs_fattr_init(opendata->o_res.f_attr);\n\t\t\tstatus = nfs4_do_setattr(state->inode, cred,\n\t\t\t\t\topendata->o_res.f_attr, sattr,\n\t\t\t\t\tctx, label);\n\t\t\tif (status == 0) {\n\t\t\t\tnfs_setattr_update_inode(state->inode, sattr,\n\t\t\t\t\t\topendata->o_res.f_attr);\n\t\t\t\tnfs_setsecurity(state->inode, opendata->o_res.f_attr);\n\t\t\t}\n\t\t\tsattr->ia_valid = ia_old;\n\t\t}\n\t}\n\tif (opened && opendata->file_created)\n\t\t*opened = 1;\n\n\tif (pnfs_use_threshold(ctx_th, opendata->f_attr.mdsthreshold, server)) {\n\t\t*ctx_th = opendata->f_attr.mdsthreshold;\n\t\topendata->f_attr.mdsthreshold = NULL;\n\t}\n\n\tnfs4_opendata_put(opendata);\n\tnfs4_put_state_owner(sp);\n\treturn 0;\nerr_opendata_put:\n\tnfs4_opendata_put(opendata);\nerr_put_state_owner:\n\tnfs4_put_state_owner(sp);\nout_err:\n\treturn status;\n}\n\n\nstatic struct nfs4_state *nfs4_do_open(struct inode *dir,\n\t\t\t\t\tstruct nfs_open_context *ctx,\n\t\t\t\t\tint flags,\n\t\t\t\t\tstruct iattr *sattr,\n\t\t\t\t\tstruct nfs4_label *label,\n\t\t\t\t\tint *opened)\n{\n\tstruct nfs_server *server = NFS_SERVER(dir);\n\tstruct nfs4_exception exception = {\n\t\t.interruptible = true,\n\t};\n\tstruct nfs4_state *res;\n\tstruct nfs4_open_createattrs c = {\n\t\t.label = label,\n\t\t.sattr = sattr,\n\t\t.verf = {\n\t\t\t[0] = (__u32)jiffies,\n\t\t\t[1] = (__u32)current->pid,\n\t\t},\n\t};\n\tint status;\n\n\tdo {\n\t\tstatus = _nfs4_do_open(dir, ctx, flags, &c, opened);\n\t\tres = ctx->state;\n\t\ttrace_nfs4_open_file(ctx, flags, status);\n\t\tif (status == 0)\n\t\t\tbreak;\n\t\t \n\t\tif (status == -NFS4ERR_BAD_SEQID) {\n\t\t\tpr_warn_ratelimited(\"NFS: v4 server %s \"\n\t\t\t\t\t\" returned a bad sequence-id error!\\n\",\n\t\t\t\t\tNFS_SERVER(dir)->nfs_client->cl_hostname);\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (status == -NFS4ERR_BAD_STATEID) {\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (status == -NFS4ERR_EXPIRED) {\n\t\t\tnfs4_schedule_lease_recovery(server->nfs_client);\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (status == -EAGAIN) {\n\t\t\t \n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (nfs4_clear_cap_atomic_open_v1(server, status, &exception))\n\t\t\tcontinue;\n\t\tres = ERR_PTR(nfs4_handle_exception(server,\n\t\t\t\t\tstatus, &exception));\n\t} while (exception.retry);\n\treturn res;\n}\n\nstatic int _nfs4_do_setattr(struct inode *inode,\n\t\t\t    struct nfs_setattrargs *arg,\n\t\t\t    struct nfs_setattrres *res,\n\t\t\t    const struct cred *cred,\n\t\t\t    struct nfs_open_context *ctx)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs4_procedures[NFSPROC4_CLNT_SETATTR],\n\t\t.rpc_argp\t= arg,\n\t\t.rpc_resp\t= res,\n\t\t.rpc_cred\t= cred,\n\t};\n\tconst struct cred *delegation_cred = NULL;\n\tunsigned long timestamp = jiffies;\n\tbool truncate;\n\tint status;\n\n\tnfs_fattr_init(res->fattr);\n\n\t \n\ttruncate = (arg->iap->ia_valid & ATTR_SIZE) ? true : false;\n\tif (!truncate) {\n\t\tnfs4_inode_make_writeable(inode);\n\t\tgoto zero_stateid;\n\t}\n\n\tif (nfs4_copy_delegation_stateid(inode, FMODE_WRITE, &arg->stateid, &delegation_cred)) {\n\t\t \n\t} else if (ctx != NULL && ctx->state) {\n\t\tstruct nfs_lock_context *l_ctx;\n\t\tif (!nfs4_valid_open_stateid(ctx->state))\n\t\t\treturn -EBADF;\n\t\tl_ctx = nfs_get_lock_context(ctx);\n\t\tif (IS_ERR(l_ctx))\n\t\t\treturn PTR_ERR(l_ctx);\n\t\tstatus = nfs4_select_rw_stateid(ctx->state, FMODE_WRITE, l_ctx,\n\t\t\t\t\t\t&arg->stateid, &delegation_cred);\n\t\tnfs_put_lock_context(l_ctx);\n\t\tif (status == -EIO)\n\t\t\treturn -EBADF;\n\t\telse if (status == -EAGAIN)\n\t\t\tgoto zero_stateid;\n\t} else {\nzero_stateid:\n\t\tnfs4_stateid_copy(&arg->stateid, &zero_stateid);\n\t}\n\tif (delegation_cred)\n\t\tmsg.rpc_cred = delegation_cred;\n\n\tstatus = nfs4_call_sync(server->client, server, &msg, &arg->seq_args, &res->seq_res, 1);\n\n\tput_cred(delegation_cred);\n\tif (status == 0 && ctx != NULL)\n\t\trenew_lease(server, timestamp);\n\ttrace_nfs4_setattr(inode, &arg->stateid, status);\n\treturn status;\n}\n\nstatic int nfs4_do_setattr(struct inode *inode, const struct cred *cred,\n\t\t\t   struct nfs_fattr *fattr, struct iattr *sattr,\n\t\t\t   struct nfs_open_context *ctx, struct nfs4_label *ilabel)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\t__u32 bitmask[NFS4_BITMASK_SZ];\n\tstruct nfs4_state *state = ctx ? ctx->state : NULL;\n\tstruct nfs_setattrargs\targ = {\n\t\t.fh\t\t= NFS_FH(inode),\n\t\t.iap\t\t= sattr,\n\t\t.server\t\t= server,\n\t\t.bitmask = bitmask,\n\t\t.label\t\t= ilabel,\n\t};\n\tstruct nfs_setattrres  res = {\n\t\t.fattr\t\t= fattr,\n\t\t.server\t\t= server,\n\t};\n\tstruct nfs4_exception exception = {\n\t\t.state = state,\n\t\t.inode = inode,\n\t\t.stateid = &arg.stateid,\n\t};\n\tunsigned long adjust_flags = NFS_INO_INVALID_CHANGE;\n\tint err;\n\n\tif (sattr->ia_valid & (ATTR_MODE | ATTR_KILL_SUID | ATTR_KILL_SGID))\n\t\tadjust_flags |= NFS_INO_INVALID_MODE;\n\tif (sattr->ia_valid & (ATTR_UID | ATTR_GID))\n\t\tadjust_flags |= NFS_INO_INVALID_OTHER;\n\n\tdo {\n\t\tnfs4_bitmap_copy_adjust(bitmask, nfs4_bitmask(server, fattr->label),\n\t\t\t\t\tinode, adjust_flags);\n\n\t\terr = _nfs4_do_setattr(inode, &arg, &res, cred, ctx);\n\t\tswitch (err) {\n\t\tcase -NFS4ERR_OPENMODE:\n\t\t\tif (!(sattr->ia_valid & ATTR_SIZE)) {\n\t\t\t\tpr_warn_once(\"NFSv4: server %s is incorrectly \"\n\t\t\t\t\t\t\"applying open mode checks to \"\n\t\t\t\t\t\t\"a SETATTR that is not \"\n\t\t\t\t\t\t\"changing file size.\\n\",\n\t\t\t\t\t\tserver->nfs_client->cl_hostname);\n\t\t\t}\n\t\t\tif (state && !(state->state & FMODE_WRITE)) {\n\t\t\t\terr = -EBADF;\n\t\t\t\tif (sattr->ia_valid & ATTR_OPEN)\n\t\t\t\t\terr = -EACCES;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\terr = nfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\nout:\n\treturn err;\n}\n\nstatic bool\nnfs4_wait_on_layoutreturn(struct inode *inode, struct rpc_task *task)\n{\n\tif (inode == NULL || !nfs_have_layout(inode))\n\t\treturn false;\n\n\treturn pnfs_wait_on_layoutreturn(inode, task);\n}\n\n \nstatic void nfs4_sync_open_stateid(nfs4_stateid *dst,\n\t\tstruct nfs4_state *state)\n{\n\t__be32 seqid_open;\n\tu32 dst_seqid;\n\tint seq;\n\n\tfor (;;) {\n\t\tif (!nfs4_valid_open_stateid(state))\n\t\t\tbreak;\n\t\tseq = read_seqbegin(&state->seqlock);\n\t\tif (!nfs4_state_match_open_stateid_other(state, dst)) {\n\t\t\tnfs4_stateid_copy(dst, &state->open_stateid);\n\t\t\tif (read_seqretry(&state->seqlock, seq))\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\t\tseqid_open = state->open_stateid.seqid;\n\t\tif (read_seqretry(&state->seqlock, seq))\n\t\t\tcontinue;\n\n\t\tdst_seqid = be32_to_cpu(dst->seqid);\n\t\tif ((s32)(dst_seqid - be32_to_cpu(seqid_open)) < 0)\n\t\t\tdst->seqid = seqid_open;\n\t\tbreak;\n\t}\n}\n\n \nstatic bool nfs4_refresh_open_old_stateid(nfs4_stateid *dst,\n\t\tstruct nfs4_state *state)\n{\n\t__be32 seqid_open;\n\tu32 dst_seqid;\n\tbool ret;\n\tint seq, status = -EAGAIN;\n\tDEFINE_WAIT(wait);\n\n\tfor (;;) {\n\t\tret = false;\n\t\tif (!nfs4_valid_open_stateid(state))\n\t\t\tbreak;\n\t\tseq = read_seqbegin(&state->seqlock);\n\t\tif (!nfs4_state_match_open_stateid_other(state, dst)) {\n\t\t\tif (read_seqretry(&state->seqlock, seq))\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\n\t\twrite_seqlock(&state->seqlock);\n\t\tseqid_open = state->open_stateid.seqid;\n\n\t\tdst_seqid = be32_to_cpu(dst->seqid);\n\n\t\t \n\t\tif ((s32)(be32_to_cpu(seqid_open) - dst_seqid) > 0) {\n\t\t\tdst->seqid = seqid_open;\n\t\t\twrite_sequnlock(&state->seqlock);\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tset_bit(NFS_STATE_CHANGE_WAIT, &state->flags);\n\t\tprepare_to_wait(&state->waitq, &wait, TASK_KILLABLE);\n\t\twrite_sequnlock(&state->seqlock);\n\t\ttrace_nfs4_close_stateid_update_wait(state->inode, dst, 0);\n\n\t\tif (fatal_signal_pending(current))\n\t\t\tstatus = -EINTR;\n\t\telse\n\t\t\tif (schedule_timeout(5*HZ) != 0)\n\t\t\t\tstatus = 0;\n\n\t\tfinish_wait(&state->waitq, &wait);\n\n\t\tif (!status)\n\t\t\tcontinue;\n\t\tif (status == -EINTR)\n\t\t\tbreak;\n\n\t\t \n\t\tdst->seqid = cpu_to_be32(dst_seqid + 1);\n\t\tret = true;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstruct nfs4_closedata {\n\tstruct inode *inode;\n\tstruct nfs4_state *state;\n\tstruct nfs_closeargs arg;\n\tstruct nfs_closeres res;\n\tstruct {\n\t\tstruct nfs4_layoutreturn_args arg;\n\t\tstruct nfs4_layoutreturn_res res;\n\t\tstruct nfs4_xdr_opaque_data ld_private;\n\t\tu32 roc_barrier;\n\t\tbool roc;\n\t} lr;\n\tstruct nfs_fattr fattr;\n\tunsigned long timestamp;\n};\n\nstatic void nfs4_free_closedata(void *data)\n{\n\tstruct nfs4_closedata *calldata = data;\n\tstruct nfs4_state_owner *sp = calldata->state->owner;\n\tstruct super_block *sb = calldata->state->inode->i_sb;\n\n\tif (calldata->lr.roc)\n\t\tpnfs_roc_release(&calldata->lr.arg, &calldata->lr.res,\n\t\t\t\tcalldata->res.lr_ret);\n\tnfs4_put_open_state(calldata->state);\n\tnfs_free_seqid(calldata->arg.seqid);\n\tnfs4_put_state_owner(sp);\n\tnfs_sb_deactive(sb);\n\tkfree(calldata);\n}\n\nstatic void nfs4_close_done(struct rpc_task *task, void *data)\n{\n\tstruct nfs4_closedata *calldata = data;\n\tstruct nfs4_state *state = calldata->state;\n\tstruct nfs_server *server = NFS_SERVER(calldata->inode);\n\tnfs4_stateid *res_stateid = NULL;\n\tstruct nfs4_exception exception = {\n\t\t.state = state,\n\t\t.inode = calldata->inode,\n\t\t.stateid = &calldata->arg.stateid,\n\t};\n\n\tif (!nfs4_sequence_done(task, &calldata->res.seq_res))\n\t\treturn;\n\ttrace_nfs4_close(state, &calldata->arg, &calldata->res, task->tk_status);\n\n\t \n\tif (pnfs_roc_done(task, &calldata->arg.lr_args, &calldata->res.lr_res,\n\t\t\t  &calldata->res.lr_ret) == -EAGAIN)\n\t\tgoto out_restart;\n\n\t \n\tswitch (task->tk_status) {\n\t\tcase 0:\n\t\t\tres_stateid = &calldata->res.stateid;\n\t\t\trenew_lease(server, calldata->timestamp);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_ACCESS:\n\t\t\tif (calldata->arg.bitmask != NULL) {\n\t\t\t\tcalldata->arg.bitmask = NULL;\n\t\t\t\tcalldata->res.fattr = NULL;\n\t\t\t\tgoto out_restart;\n\n\t\t\t}\n\t\t\tbreak;\n\t\tcase -NFS4ERR_OLD_STATEID:\n\t\t\t \n\t\t\tif (nfs4_refresh_open_old_stateid(&calldata->arg.stateid,\n\t\t\t\t\t\tstate))\n\t\t\t\tgoto out_restart;\n\t\t\tgoto out_release;\n\t\tcase -NFS4ERR_ADMIN_REVOKED:\n\t\tcase -NFS4ERR_STALE_STATEID:\n\t\tcase -NFS4ERR_EXPIRED:\n\t\t\tnfs4_free_revoked_stateid(server,\n\t\t\t\t\t&calldata->arg.stateid,\n\t\t\t\t\ttask->tk_msg.rpc_cred);\n\t\t\tfallthrough;\n\t\tcase -NFS4ERR_BAD_STATEID:\n\t\t\tif (calldata->arg.fmode == 0)\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\ttask->tk_status = nfs4_async_handle_exception(task,\n\t\t\t\t\tserver, task->tk_status, &exception);\n\t\t\tif (exception.retry)\n\t\t\t\tgoto out_restart;\n\t}\n\tnfs_clear_open_stateid(state, &calldata->arg.stateid,\n\t\t\tres_stateid, calldata->arg.fmode);\nout_release:\n\ttask->tk_status = 0;\n\tnfs_release_seqid(calldata->arg.seqid);\n\tnfs_refresh_inode(calldata->inode, &calldata->fattr);\n\tdprintk(\"%s: ret = %d\\n\", __func__, task->tk_status);\n\treturn;\nout_restart:\n\ttask->tk_status = 0;\n\trpc_restart_call_prepare(task);\n\tgoto out_release;\n}\n\nstatic void nfs4_close_prepare(struct rpc_task *task, void *data)\n{\n\tstruct nfs4_closedata *calldata = data;\n\tstruct nfs4_state *state = calldata->state;\n\tstruct inode *inode = calldata->inode;\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct pnfs_layout_hdr *lo;\n\tbool is_rdonly, is_wronly, is_rdwr;\n\tint call_close = 0;\n\n\tif (nfs_wait_on_sequence(calldata->arg.seqid, task) != 0)\n\t\tgoto out_wait;\n\n\ttask->tk_msg.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_OPEN_DOWNGRADE];\n\tspin_lock(&state->owner->so_lock);\n\tis_rdwr = test_bit(NFS_O_RDWR_STATE, &state->flags);\n\tis_rdonly = test_bit(NFS_O_RDONLY_STATE, &state->flags);\n\tis_wronly = test_bit(NFS_O_WRONLY_STATE, &state->flags);\n\t \n\tcalldata->arg.fmode = 0;\n\tif (state->n_rdwr == 0) {\n\t\tif (state->n_rdonly == 0)\n\t\t\tcall_close |= is_rdonly;\n\t\telse if (is_rdonly)\n\t\t\tcalldata->arg.fmode |= FMODE_READ;\n\t\tif (state->n_wronly == 0)\n\t\t\tcall_close |= is_wronly;\n\t\telse if (is_wronly)\n\t\t\tcalldata->arg.fmode |= FMODE_WRITE;\n\t\tif (calldata->arg.fmode != (FMODE_READ|FMODE_WRITE))\n\t\t\tcall_close |= is_rdwr;\n\t} else if (is_rdwr)\n\t\tcalldata->arg.fmode |= FMODE_READ|FMODE_WRITE;\n\n\tnfs4_sync_open_stateid(&calldata->arg.stateid, state);\n\tif (!nfs4_valid_open_stateid(state))\n\t\tcall_close = 0;\n\tspin_unlock(&state->owner->so_lock);\n\n\tif (!call_close) {\n\t\t \n\t\tgoto out_no_action;\n\t}\n\n\tif (!calldata->lr.roc && nfs4_wait_on_layoutreturn(inode, task)) {\n\t\tnfs_release_seqid(calldata->arg.seqid);\n\t\tgoto out_wait;\n\t}\n\n\tlo = calldata->arg.lr_args ? calldata->arg.lr_args->layout : NULL;\n\tif (lo && !pnfs_layout_is_valid(lo)) {\n\t\tcalldata->arg.lr_args = NULL;\n\t\tcalldata->res.lr_res = NULL;\n\t}\n\n\tif (calldata->arg.fmode == 0)\n\t\ttask->tk_msg.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_CLOSE];\n\n\tif (calldata->arg.fmode == 0 || calldata->arg.fmode == FMODE_READ) {\n\t\t \n\t\tif (!nfs4_have_delegation(inode, FMODE_READ)) {\n\t\t\tnfs4_bitmask_set(calldata->arg.bitmask_store,\n\t\t\t\t\t server->cache_consistency_bitmask,\n\t\t\t\t\t inode, 0);\n\t\t\tcalldata->arg.bitmask = calldata->arg.bitmask_store;\n\t\t} else\n\t\t\tcalldata->arg.bitmask = NULL;\n\t}\n\n\tcalldata->arg.share_access =\n\t\tnfs4_map_atomic_open_share(NFS_SERVER(inode),\n\t\t\t\tcalldata->arg.fmode, 0);\n\n\tif (calldata->res.fattr == NULL)\n\t\tcalldata->arg.bitmask = NULL;\n\telse if (calldata->arg.bitmask == NULL)\n\t\tcalldata->res.fattr = NULL;\n\tcalldata->timestamp = jiffies;\n\tif (nfs4_setup_sequence(NFS_SERVER(inode)->nfs_client,\n\t\t\t\t&calldata->arg.seq_args,\n\t\t\t\t&calldata->res.seq_res,\n\t\t\t\ttask) != 0)\n\t\tnfs_release_seqid(calldata->arg.seqid);\n\treturn;\nout_no_action:\n\ttask->tk_action = NULL;\nout_wait:\n\tnfs4_sequence_done(task, &calldata->res.seq_res);\n}\n\nstatic const struct rpc_call_ops nfs4_close_ops = {\n\t.rpc_call_prepare = nfs4_close_prepare,\n\t.rpc_call_done = nfs4_close_done,\n\t.rpc_release = nfs4_free_closedata,\n};\n\n \nint nfs4_do_close(struct nfs4_state *state, gfp_t gfp_mask, int wait)\n{\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tstruct nfs_seqid *(*alloc_seqid)(struct nfs_seqid_counter *, gfp_t);\n\tstruct nfs4_closedata *calldata;\n\tstruct nfs4_state_owner *sp = state->owner;\n\tstruct rpc_task *task;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_CLOSE],\n\t\t.rpc_cred = state->owner->so_cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = server->client,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_close_ops,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC | RPC_TASK_CRED_NOREF,\n\t};\n\tint status = -ENOMEM;\n\n\tif (nfs_server_capable(state->inode, NFS_CAP_MOVEABLE))\n\t\ttask_setup_data.flags |= RPC_TASK_MOVEABLE;\n\n\tnfs4_state_protect(server->nfs_client, NFS_SP4_MACH_CRED_CLEANUP,\n\t\t&task_setup_data.rpc_client, &msg);\n\n\tcalldata = kzalloc(sizeof(*calldata), gfp_mask);\n\tif (calldata == NULL)\n\t\tgoto out;\n\tnfs4_init_sequence(&calldata->arg.seq_args, &calldata->res.seq_res, 1, 0);\n\tcalldata->inode = state->inode;\n\tcalldata->state = state;\n\tcalldata->arg.fh = NFS_FH(state->inode);\n\tif (!nfs4_copy_open_stateid(&calldata->arg.stateid, state))\n\t\tgoto out_free_calldata;\n\t \n\talloc_seqid = server->nfs_client->cl_mvops->alloc_seqid;\n\tcalldata->arg.seqid = alloc_seqid(&state->owner->so_seqid, gfp_mask);\n\tif (IS_ERR(calldata->arg.seqid))\n\t\tgoto out_free_calldata;\n\tnfs_fattr_init(&calldata->fattr);\n\tcalldata->arg.fmode = 0;\n\tcalldata->lr.arg.ld_private = &calldata->lr.ld_private;\n\tcalldata->res.fattr = &calldata->fattr;\n\tcalldata->res.seqid = calldata->arg.seqid;\n\tcalldata->res.server = server;\n\tcalldata->res.lr_ret = -NFS4ERR_NOMATCHING_LAYOUT;\n\tcalldata->lr.roc = pnfs_roc(state->inode,\n\t\t\t&calldata->lr.arg, &calldata->lr.res, msg.rpc_cred);\n\tif (calldata->lr.roc) {\n\t\tcalldata->arg.lr_args = &calldata->lr.arg;\n\t\tcalldata->res.lr_res = &calldata->lr.res;\n\t}\n\tnfs_sb_active(calldata->inode->i_sb);\n\n\tmsg.rpc_argp = &calldata->arg;\n\tmsg.rpc_resp = &calldata->res;\n\ttask_setup_data.callback_data = calldata;\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tstatus = 0;\n\tif (wait)\n\t\tstatus = rpc_wait_for_completion_task(task);\n\trpc_put_task(task);\n\treturn status;\nout_free_calldata:\n\tkfree(calldata);\nout:\n\tnfs4_put_open_state(state);\n\tnfs4_put_state_owner(sp);\n\treturn status;\n}\n\nstatic struct inode *\nnfs4_atomic_open(struct inode *dir, struct nfs_open_context *ctx,\n\t\tint open_flags, struct iattr *attr, int *opened)\n{\n\tstruct nfs4_state *state;\n\tstruct nfs4_label l, *label;\n\n\tlabel = nfs4_label_init_security(dir, ctx->dentry, attr, &l);\n\n\t \n\tstate = nfs4_do_open(dir, ctx, open_flags, attr, label, opened);\n\n\tnfs4_label_release_security(label);\n\n\tif (IS_ERR(state))\n\t\treturn ERR_CAST(state);\n\treturn state->inode;\n}\n\nstatic void nfs4_close_context(struct nfs_open_context *ctx, int is_sync)\n{\n\tif (ctx->state == NULL)\n\t\treturn;\n\tif (is_sync)\n\t\tnfs4_close_sync(ctx->state, _nfs4_ctx_to_openmode(ctx));\n\telse\n\t\tnfs4_close_state(ctx->state, _nfs4_ctx_to_openmode(ctx));\n}\n\n#define FATTR4_WORD1_NFS40_MASK (2*FATTR4_WORD1_MOUNTED_ON_FILEID - 1UL)\n#define FATTR4_WORD2_NFS41_MASK (2*FATTR4_WORD2_SUPPATTR_EXCLCREAT - 1UL)\n#define FATTR4_WORD2_NFS42_MASK (2*FATTR4_WORD2_XATTR_SUPPORT - 1UL)\n\nstatic int _nfs4_server_capabilities(struct nfs_server *server, struct nfs_fh *fhandle)\n{\n\tu32 bitmask[3] = {}, minorversion = server->nfs_client->cl_minorversion;\n\tstruct nfs4_server_caps_arg args = {\n\t\t.fhandle = fhandle,\n\t\t.bitmask = bitmask,\n\t};\n\tstruct nfs4_server_caps_res res = {};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_SERVER_CAPS],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tint status;\n\tint i;\n\n\tbitmask[0] = FATTR4_WORD0_SUPPORTED_ATTRS |\n\t\t     FATTR4_WORD0_FH_EXPIRE_TYPE |\n\t\t     FATTR4_WORD0_LINK_SUPPORT |\n\t\t     FATTR4_WORD0_SYMLINK_SUPPORT |\n\t\t     FATTR4_WORD0_ACLSUPPORT |\n\t\t     FATTR4_WORD0_CASE_INSENSITIVE |\n\t\t     FATTR4_WORD0_CASE_PRESERVING;\n\tif (minorversion)\n\t\tbitmask[2] = FATTR4_WORD2_SUPPATTR_EXCLCREAT;\n\n\tstatus = nfs4_call_sync(server->client, server, &msg, &args.seq_args, &res.seq_res, 0);\n\tif (status == 0) {\n\t\t \n\t\tswitch (minorversion) {\n\t\tcase 0:\n\t\t\tres.attr_bitmask[1] &= FATTR4_WORD1_NFS40_MASK;\n\t\t\tres.attr_bitmask[2] = 0;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tres.attr_bitmask[2] &= FATTR4_WORD2_NFS41_MASK;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tres.attr_bitmask[2] &= FATTR4_WORD2_NFS42_MASK;\n\t\t}\n\t\tmemcpy(server->attr_bitmask, res.attr_bitmask, sizeof(server->attr_bitmask));\n\t\tserver->caps &= ~(NFS_CAP_ACLS | NFS_CAP_HARDLINKS |\n\t\t\t\t  NFS_CAP_SYMLINKS| NFS_CAP_SECURITY_LABEL);\n\t\tserver->fattr_valid = NFS_ATTR_FATTR_V4;\n\t\tif (res.attr_bitmask[0] & FATTR4_WORD0_ACL &&\n\t\t\t\tres.acl_bitmask & ACL4_SUPPORT_ALLOW_ACL)\n\t\t\tserver->caps |= NFS_CAP_ACLS;\n\t\tif (res.has_links != 0)\n\t\t\tserver->caps |= NFS_CAP_HARDLINKS;\n\t\tif (res.has_symlinks != 0)\n\t\t\tserver->caps |= NFS_CAP_SYMLINKS;\n\t\tif (res.case_insensitive)\n\t\t\tserver->caps |= NFS_CAP_CASE_INSENSITIVE;\n\t\tif (res.case_preserving)\n\t\t\tserver->caps |= NFS_CAP_CASE_PRESERVING;\n#ifdef CONFIG_NFS_V4_SECURITY_LABEL\n\t\tif (res.attr_bitmask[2] & FATTR4_WORD2_SECURITY_LABEL)\n\t\t\tserver->caps |= NFS_CAP_SECURITY_LABEL;\n#endif\n\t\tif (res.attr_bitmask[0] & FATTR4_WORD0_FS_LOCATIONS)\n\t\t\tserver->caps |= NFS_CAP_FS_LOCATIONS;\n\t\tif (!(res.attr_bitmask[0] & FATTR4_WORD0_FILEID))\n\t\t\tserver->fattr_valid &= ~NFS_ATTR_FATTR_FILEID;\n\t\tif (!(res.attr_bitmask[1] & FATTR4_WORD1_MODE))\n\t\t\tserver->fattr_valid &= ~NFS_ATTR_FATTR_MODE;\n\t\tif (!(res.attr_bitmask[1] & FATTR4_WORD1_NUMLINKS))\n\t\t\tserver->fattr_valid &= ~NFS_ATTR_FATTR_NLINK;\n\t\tif (!(res.attr_bitmask[1] & FATTR4_WORD1_OWNER))\n\t\t\tserver->fattr_valid &= ~(NFS_ATTR_FATTR_OWNER |\n\t\t\t\tNFS_ATTR_FATTR_OWNER_NAME);\n\t\tif (!(res.attr_bitmask[1] & FATTR4_WORD1_OWNER_GROUP))\n\t\t\tserver->fattr_valid &= ~(NFS_ATTR_FATTR_GROUP |\n\t\t\t\tNFS_ATTR_FATTR_GROUP_NAME);\n\t\tif (!(res.attr_bitmask[1] & FATTR4_WORD1_SPACE_USED))\n\t\t\tserver->fattr_valid &= ~NFS_ATTR_FATTR_SPACE_USED;\n\t\tif (!(res.attr_bitmask[1] & FATTR4_WORD1_TIME_ACCESS))\n\t\t\tserver->fattr_valid &= ~NFS_ATTR_FATTR_ATIME;\n\t\tif (!(res.attr_bitmask[1] & FATTR4_WORD1_TIME_METADATA))\n\t\t\tserver->fattr_valid &= ~NFS_ATTR_FATTR_CTIME;\n\t\tif (!(res.attr_bitmask[1] & FATTR4_WORD1_TIME_MODIFY))\n\t\t\tserver->fattr_valid &= ~NFS_ATTR_FATTR_MTIME;\n\t\tmemcpy(server->attr_bitmask_nl, res.attr_bitmask,\n\t\t\t\tsizeof(server->attr_bitmask));\n\t\tserver->attr_bitmask_nl[2] &= ~FATTR4_WORD2_SECURITY_LABEL;\n\n\t\tmemcpy(server->cache_consistency_bitmask, res.attr_bitmask, sizeof(server->cache_consistency_bitmask));\n\t\tserver->cache_consistency_bitmask[0] &= FATTR4_WORD0_CHANGE|FATTR4_WORD0_SIZE;\n\t\tserver->cache_consistency_bitmask[1] &= FATTR4_WORD1_TIME_METADATA|FATTR4_WORD1_TIME_MODIFY;\n\t\tserver->cache_consistency_bitmask[2] = 0;\n\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(res.exclcreat_bitmask); i++)\n\t\t\tres.exclcreat_bitmask[i] &= res.attr_bitmask[i];\n\t\tmemcpy(server->exclcreat_bitmask, res.exclcreat_bitmask,\n\t\t\tsizeof(server->exclcreat_bitmask));\n\n\t\tserver->acl_bitmask = res.acl_bitmask;\n\t\tserver->fh_expire_type = res.fh_expire_type;\n\t}\n\n\treturn status;\n}\n\nint nfs4_server_capabilities(struct nfs_server *server, struct nfs_fh *fhandle)\n{\n\tstruct nfs4_exception exception = {\n\t\t.interruptible = true,\n\t};\n\tint err;\n\n\tnfs4_server_set_init_caps(server);\n\tdo {\n\t\terr = nfs4_handle_exception(server,\n\t\t\t\t_nfs4_server_capabilities(server, fhandle),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic void test_fs_location_for_trunking(struct nfs4_fs_location *location,\n\t\t\t\t\t  struct nfs_client *clp,\n\t\t\t\t\t  struct nfs_server *server)\n{\n\tint i;\n\n\tfor (i = 0; i < location->nservers; i++) {\n\t\tstruct nfs4_string *srv_loc = &location->servers[i];\n\t\tstruct sockaddr_storage addr;\n\t\tsize_t addrlen;\n\t\tstruct xprt_create xprt_args = {\n\t\t\t.ident = 0,\n\t\t\t.net = clp->cl_net,\n\t\t};\n\t\tstruct nfs4_add_xprt_data xprtdata = {\n\t\t\t.clp = clp,\n\t\t};\n\t\tstruct rpc_add_xprt_test rpcdata = {\n\t\t\t.add_xprt_test = clp->cl_mvops->session_trunk,\n\t\t\t.data = &xprtdata,\n\t\t};\n\t\tchar *servername = NULL;\n\n\t\tif (!srv_loc->len)\n\t\t\tcontinue;\n\n\t\taddrlen = nfs_parse_server_name(srv_loc->data, srv_loc->len,\n\t\t\t\t\t\t&addr, sizeof(addr),\n\t\t\t\t\t\tclp->cl_net, server->port);\n\t\tif (!addrlen)\n\t\t\treturn;\n\t\txprt_args.dstaddr = (struct sockaddr *)&addr;\n\t\txprt_args.addrlen = addrlen;\n\t\tservername = kmalloc(srv_loc->len + 1, GFP_KERNEL);\n\t\tif (!servername)\n\t\t\treturn;\n\t\tmemcpy(servername, srv_loc->data, srv_loc->len);\n\t\tservername[srv_loc->len] = '\\0';\n\t\txprt_args.servername = servername;\n\n\t\txprtdata.cred = nfs4_get_clid_cred(clp);\n\t\trpc_clnt_add_xprt(clp->cl_rpcclient, &xprt_args,\n\t\t\t\t  rpc_clnt_setup_test_and_add_xprt,\n\t\t\t\t  &rpcdata);\n\t\tif (xprtdata.cred)\n\t\t\tput_cred(xprtdata.cred);\n\t\tkfree(servername);\n\t}\n}\n\nstatic int _nfs4_discover_trunking(struct nfs_server *server,\n\t\t\t\t   struct nfs_fh *fhandle)\n{\n\tstruct nfs4_fs_locations *locations = NULL;\n\tstruct page *page;\n\tconst struct cred *cred;\n\tstruct nfs_client *clp = server->nfs_client;\n\tconst struct nfs4_state_maintenance_ops *ops =\n\t\tclp->cl_mvops->state_renewal_ops;\n\tint status = -ENOMEM, i;\n\n\tcred = ops->get_state_renewal_cred(clp);\n\tif (cred == NULL) {\n\t\tcred = nfs4_get_clid_cred(clp);\n\t\tif (cred == NULL)\n\t\t\treturn -ENOKEY;\n\t}\n\n\tpage = alloc_page(GFP_KERNEL);\n\tif (!page)\n\t\tgoto out_put_cred;\n\tlocations = kmalloc(sizeof(struct nfs4_fs_locations), GFP_KERNEL);\n\tif (!locations)\n\t\tgoto out_free;\n\tlocations->fattr = nfs_alloc_fattr();\n\tif (!locations->fattr)\n\t\tgoto out_free_2;\n\n\tstatus = nfs4_proc_get_locations(server, fhandle, locations, page,\n\t\t\t\t\t cred);\n\tif (status)\n\t\tgoto out_free_3;\n\n\tfor (i = 0; i < locations->nlocations; i++)\n\t\ttest_fs_location_for_trunking(&locations->locations[i], clp,\n\t\t\t\t\t      server);\nout_free_3:\n\tkfree(locations->fattr);\nout_free_2:\n\tkfree(locations);\nout_free:\n\t__free_page(page);\nout_put_cred:\n\tput_cred(cred);\n\treturn status;\n}\n\nstatic int nfs4_discover_trunking(struct nfs_server *server,\n\t\t\t\t  struct nfs_fh *fhandle)\n{\n\tstruct nfs4_exception exception = {\n\t\t.interruptible = true,\n\t};\n\tstruct nfs_client *clp = server->nfs_client;\n\tint err = 0;\n\n\tif (!nfs4_has_session(clp))\n\t\tgoto out;\n\tdo {\n\t\terr = nfs4_handle_exception(server,\n\t\t\t\t_nfs4_discover_trunking(server, fhandle),\n\t\t\t\t&exception);\n\t} while (exception.retry);\nout:\n\treturn err;\n}\n\nstatic int _nfs4_lookup_root(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\tstruct nfs_fsinfo *info)\n{\n\tu32 bitmask[3];\n\tstruct nfs4_lookup_root_arg args = {\n\t\t.bitmask = bitmask,\n\t};\n\tstruct nfs4_lookup_res res = {\n\t\t.server = server,\n\t\t.fattr = info->fattr,\n\t\t.fh = fhandle,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LOOKUP_ROOT],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\n\tbitmask[0] = nfs4_fattr_bitmap[0];\n\tbitmask[1] = nfs4_fattr_bitmap[1];\n\t \n\tbitmask[2] = nfs4_fattr_bitmap[2] & ~FATTR4_WORD2_SECURITY_LABEL;\n\n\tnfs_fattr_init(info->fattr);\n\treturn nfs4_call_sync(server->client, server, &msg, &args.seq_args, &res.seq_res, 0);\n}\n\nstatic int nfs4_lookup_root(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\tstruct nfs_fsinfo *info)\n{\n\tstruct nfs4_exception exception = {\n\t\t.interruptible = true,\n\t};\n\tint err;\n\tdo {\n\t\terr = _nfs4_lookup_root(server, fhandle, info);\n\t\ttrace_nfs4_lookup_root(server, fhandle, info->fattr, err);\n\t\tswitch (err) {\n\t\tcase 0:\n\t\tcase -NFS4ERR_WRONGSEC:\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\terr = nfs4_handle_exception(server, err, &exception);\n\t\t}\n\t} while (exception.retry);\nout:\n\treturn err;\n}\n\nstatic int nfs4_lookup_root_sec(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\t\t\tstruct nfs_fsinfo *info, rpc_authflavor_t flavor)\n{\n\tstruct rpc_auth_create_args auth_args = {\n\t\t.pseudoflavor = flavor,\n\t};\n\tstruct rpc_auth *auth;\n\n\tauth = rpcauth_create(&auth_args, server->client);\n\tif (IS_ERR(auth))\n\t\treturn -EACCES;\n\treturn nfs4_lookup_root(server, fhandle, info);\n}\n\n \nstatic int nfs4_find_root_sec(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\t\t      struct nfs_fsinfo *info)\n{\n\t \n\tstatic const rpc_authflavor_t flav_array[] = {\n\t\tRPC_AUTH_GSS_KRB5P,\n\t\tRPC_AUTH_GSS_KRB5I,\n\t\tRPC_AUTH_GSS_KRB5,\n\t\tRPC_AUTH_UNIX,\t\t\t \n\t\tRPC_AUTH_NULL,\n\t};\n\tint status = -EPERM;\n\tsize_t i;\n\n\tif (server->auth_info.flavor_len > 0) {\n\t\t \n\t\tfor (i = 0; i < server->auth_info.flavor_len; i++) {\n\t\t\tstatus = nfs4_lookup_root_sec(server, fhandle, info,\n\t\t\t\t\t\tserver->auth_info.flavors[i]);\n\t\t\tif (status == -NFS4ERR_WRONGSEC || status == -EACCES)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(flav_array); i++) {\n\t\t\tstatus = nfs4_lookup_root_sec(server, fhandle, info,\n\t\t\t\t\t\t      flav_array[i]);\n\t\t\tif (status == -NFS4ERR_WRONGSEC || status == -EACCES)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (status == -EACCES)\n\t\tstatus = -EPERM;\n\treturn status;\n}\n\n \nint nfs4_proc_get_rootfh(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\t\t struct nfs_fsinfo *info,\n\t\t\t bool auth_probe)\n{\n\tint status = 0;\n\n\tif (!auth_probe)\n\t\tstatus = nfs4_lookup_root(server, fhandle, info);\n\n\tif (auth_probe || status == NFS4ERR_WRONGSEC)\n\t\tstatus = server->nfs_client->cl_mvops->find_root_sec(server,\n\t\t\t\tfhandle, info);\n\n\tif (status == 0)\n\t\tstatus = nfs4_server_capabilities(server, fhandle);\n\tif (status == 0)\n\t\tstatus = nfs4_do_fsinfo(server, fhandle, info);\n\n\treturn nfs4_map_errors(status);\n}\n\nstatic int nfs4_proc_get_root(struct nfs_server *server, struct nfs_fh *mntfh,\n\t\t\t      struct nfs_fsinfo *info)\n{\n\tint error;\n\tstruct nfs_fattr *fattr = info->fattr;\n\n\terror = nfs4_server_capabilities(server, mntfh);\n\tif (error < 0) {\n\t\tdprintk(\"nfs4_get_root: getcaps error = %d\\n\", -error);\n\t\treturn error;\n\t}\n\n\terror = nfs4_proc_getattr(server, mntfh, fattr, NULL);\n\tif (error < 0) {\n\t\tdprintk(\"nfs4_get_root: getattr error = %d\\n\", -error);\n\t\tgoto out;\n\t}\n\n\tif (fattr->valid & NFS_ATTR_FATTR_FSID &&\n\t    !nfs_fsid_equal(&server->fsid, &fattr->fsid))\n\t\tmemcpy(&server->fsid, &fattr->fsid, sizeof(server->fsid));\n\nout:\n\treturn error;\n}\n\n \nstatic int nfs4_get_referral(struct rpc_clnt *client, struct inode *dir,\n\t\t\t     const struct qstr *name, struct nfs_fattr *fattr,\n\t\t\t     struct nfs_fh *fhandle)\n{\n\tint status = -ENOMEM;\n\tstruct page *page = NULL;\n\tstruct nfs4_fs_locations *locations = NULL;\n\n\tpage = alloc_page(GFP_KERNEL);\n\tif (page == NULL)\n\t\tgoto out;\n\tlocations = kmalloc(sizeof(struct nfs4_fs_locations), GFP_KERNEL);\n\tif (locations == NULL)\n\t\tgoto out;\n\n\tlocations->fattr = fattr;\n\n\tstatus = nfs4_proc_fs_locations(client, dir, name, locations, page);\n\tif (status != 0)\n\t\tgoto out;\n\n\t \n\tif (nfs_fsid_equal(&NFS_SERVER(dir)->fsid, &fattr->fsid)) {\n\t\tdprintk(\"%s: server did not return a different fsid for\"\n\t\t\t\" a referral at %s\\n\", __func__, name->name);\n\t\tstatus = -NFS4ERR_MOVED;\n\t\tgoto out;\n\t}\n\t \n\tnfs_fixup_referral_attributes(fattr);\n\tmemset(fhandle, 0, sizeof(struct nfs_fh));\nout:\n\tif (page)\n\t\t__free_page(page);\n\tkfree(locations);\n\treturn status;\n}\n\nstatic int _nfs4_proc_getattr(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\t\t\tstruct nfs_fattr *fattr, struct inode *inode)\n{\n\t__u32 bitmask[NFS4_BITMASK_SZ];\n\tstruct nfs4_getattr_arg args = {\n\t\t.fh = fhandle,\n\t\t.bitmask = bitmask,\n\t};\n\tstruct nfs4_getattr_res res = {\n\t\t.fattr = fattr,\n\t\t.server = server,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETATTR],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned short task_flags = 0;\n\n\tif (nfs4_has_session(server->nfs_client))\n\t\ttask_flags = RPC_TASK_MOVEABLE;\n\n\t \n\tif (inode && (server->flags & NFS_MOUNT_SOFTREVAL))\n\t\ttask_flags |= RPC_TASK_TIMEOUT;\n\n\tnfs4_bitmap_copy_adjust(bitmask, nfs4_bitmask(server, fattr->label), inode, 0);\n\tnfs_fattr_init(fattr);\n\tnfs4_init_sequence(&args.seq_args, &res.seq_res, 0, 0);\n\treturn nfs4_do_call_sync(server->client, server, &msg,\n\t\t\t&args.seq_args, &res.seq_res, task_flags);\n}\n\nint nfs4_proc_getattr(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\t\t\tstruct nfs_fattr *fattr, struct inode *inode)\n{\n\tstruct nfs4_exception exception = {\n\t\t.interruptible = true,\n\t};\n\tint err;\n\tdo {\n\t\terr = _nfs4_proc_getattr(server, fhandle, fattr, inode);\n\t\ttrace_nfs4_getattr(server, fhandle, fattr, err);\n\t\terr = nfs4_handle_exception(server, err,\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\n \nstatic int\nnfs4_proc_setattr(struct dentry *dentry, struct nfs_fattr *fattr,\n\t\t  struct iattr *sattr)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tconst struct cred *cred = NULL;\n\tstruct nfs_open_context *ctx = NULL;\n\tint status;\n\n\tif (pnfs_ld_layoutret_on_setattr(inode) &&\n\t    sattr->ia_valid & ATTR_SIZE &&\n\t    sattr->ia_size < i_size_read(inode))\n\t\tpnfs_commit_and_return_layout(inode);\n\n\tnfs_fattr_init(fattr);\n\t\n\t \n\tif (sattr->ia_valid & ATTR_OPEN)\n\t\tsattr->ia_valid &= ~(ATTR_MTIME|ATTR_CTIME);\n\n\t \n\tif ((sattr->ia_valid & ~(ATTR_FILE|ATTR_OPEN)) == 0)\n\t\treturn 0;\n\n\t \n\tif (sattr->ia_valid & ATTR_FILE) {\n\n\t\tctx = nfs_file_open_context(sattr->ia_file);\n\t\tif (ctx)\n\t\t\tcred = ctx->cred;\n\t}\n\n\t \n\tif ((sattr->ia_valid & (ATTR_MODE|ATTR_UID|ATTR_GID)) != 0)\n\t\tnfs4_inode_make_writeable(inode);\n\n\tstatus = nfs4_do_setattr(inode, cred, fattr, sattr, ctx, NULL);\n\tif (status == 0) {\n\t\tnfs_setattr_update_inode(inode, sattr, fattr);\n\t\tnfs_setsecurity(inode, fattr);\n\t}\n\treturn status;\n}\n\nstatic int _nfs4_proc_lookup(struct rpc_clnt *clnt, struct inode *dir,\n\t\tstruct dentry *dentry, struct nfs_fh *fhandle,\n\t\tstruct nfs_fattr *fattr)\n{\n\tstruct nfs_server *server = NFS_SERVER(dir);\n\tint\t\t       status;\n\tstruct nfs4_lookup_arg args = {\n\t\t.bitmask = server->attr_bitmask,\n\t\t.dir_fh = NFS_FH(dir),\n\t\t.name = &dentry->d_name,\n\t};\n\tstruct nfs4_lookup_res res = {\n\t\t.server = server,\n\t\t.fattr = fattr,\n\t\t.fh = fhandle,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LOOKUP],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned short task_flags = 0;\n\n\tif (nfs_server_capable(dir, NFS_CAP_MOVEABLE))\n\t\ttask_flags = RPC_TASK_MOVEABLE;\n\n\t \n\tif (nfs_lookup_is_soft_revalidate(dentry))\n\t\ttask_flags |= RPC_TASK_TIMEOUT;\n\n\targs.bitmask = nfs4_bitmask(server, fattr->label);\n\n\tnfs_fattr_init(fattr);\n\n\tdprintk(\"NFS call  lookup %pd2\\n\", dentry);\n\tnfs4_init_sequence(&args.seq_args, &res.seq_res, 0, 0);\n\tstatus = nfs4_do_call_sync(clnt, server, &msg,\n\t\t\t&args.seq_args, &res.seq_res, task_flags);\n\tdprintk(\"NFS reply lookup: %d\\n\", status);\n\treturn status;\n}\n\nstatic void nfs_fixup_secinfo_attributes(struct nfs_fattr *fattr)\n{\n\tfattr->valid |= NFS_ATTR_FATTR_TYPE | NFS_ATTR_FATTR_MODE |\n\t\tNFS_ATTR_FATTR_NLINK | NFS_ATTR_FATTR_MOUNTPOINT;\n\tfattr->mode = S_IFDIR | S_IRUGO | S_IXUGO;\n\tfattr->nlink = 2;\n}\n\nstatic int nfs4_proc_lookup_common(struct rpc_clnt **clnt, struct inode *dir,\n\t\t\t\t   struct dentry *dentry, struct nfs_fh *fhandle,\n\t\t\t\t   struct nfs_fattr *fattr)\n{\n\tstruct nfs4_exception exception = {\n\t\t.interruptible = true,\n\t};\n\tstruct rpc_clnt *client = *clnt;\n\tconst struct qstr *name = &dentry->d_name;\n\tint err;\n\tdo {\n\t\terr = _nfs4_proc_lookup(client, dir, dentry, fhandle, fattr);\n\t\ttrace_nfs4_lookup(dir, name, err);\n\t\tswitch (err) {\n\t\tcase -NFS4ERR_BADNAME:\n\t\t\terr = -ENOENT;\n\t\t\tgoto out;\n\t\tcase -NFS4ERR_MOVED:\n\t\t\terr = nfs4_get_referral(client, dir, name, fattr, fhandle);\n\t\t\tif (err == -NFS4ERR_MOVED)\n\t\t\t\terr = nfs4_handle_exception(NFS_SERVER(dir), err, &exception);\n\t\t\tgoto out;\n\t\tcase -NFS4ERR_WRONGSEC:\n\t\t\terr = -EPERM;\n\t\t\tif (client != *clnt)\n\t\t\t\tgoto out;\n\t\t\tclient = nfs4_negotiate_security(client, dir, name);\n\t\t\tif (IS_ERR(client))\n\t\t\t\treturn PTR_ERR(client);\n\n\t\t\texception.retry = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = nfs4_handle_exception(NFS_SERVER(dir), err, &exception);\n\t\t}\n\t} while (exception.retry);\n\nout:\n\tif (err == 0)\n\t\t*clnt = client;\n\telse if (client != *clnt)\n\t\trpc_shutdown_client(client);\n\n\treturn err;\n}\n\nstatic int nfs4_proc_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t    struct nfs_fh *fhandle, struct nfs_fattr *fattr)\n{\n\tint status;\n\tstruct rpc_clnt *client = NFS_CLIENT(dir);\n\n\tstatus = nfs4_proc_lookup_common(&client, dir, dentry, fhandle, fattr);\n\tif (client != NFS_CLIENT(dir)) {\n\t\trpc_shutdown_client(client);\n\t\tnfs_fixup_secinfo_attributes(fattr);\n\t}\n\treturn status;\n}\n\nstruct rpc_clnt *\nnfs4_proc_lookup_mountpoint(struct inode *dir, struct dentry *dentry,\n\t\t\t    struct nfs_fh *fhandle, struct nfs_fattr *fattr)\n{\n\tstruct rpc_clnt *client = NFS_CLIENT(dir);\n\tint status;\n\n\tstatus = nfs4_proc_lookup_common(&client, dir, dentry, fhandle, fattr);\n\tif (status < 0)\n\t\treturn ERR_PTR(status);\n\treturn (client == NFS_CLIENT(dir)) ? rpc_clone_client(client) : client;\n}\n\nstatic int _nfs4_proc_lookupp(struct inode *inode,\n\t\tstruct nfs_fh *fhandle, struct nfs_fattr *fattr)\n{\n\tstruct rpc_clnt *clnt = NFS_CLIENT(inode);\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tint\t\t       status;\n\tstruct nfs4_lookupp_arg args = {\n\t\t.bitmask = server->attr_bitmask,\n\t\t.fh = NFS_FH(inode),\n\t};\n\tstruct nfs4_lookupp_res res = {\n\t\t.server = server,\n\t\t.fattr = fattr,\n\t\t.fh = fhandle,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LOOKUPP],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned short task_flags = 0;\n\n\tif (NFS_SERVER(inode)->flags & NFS_MOUNT_SOFTREVAL)\n\t\ttask_flags |= RPC_TASK_TIMEOUT;\n\n\targs.bitmask = nfs4_bitmask(server, fattr->label);\n\n\tnfs_fattr_init(fattr);\n\n\tdprintk(\"NFS call  lookupp ino=0x%lx\\n\", inode->i_ino);\n\tstatus = nfs4_call_sync(clnt, server, &msg, &args.seq_args,\n\t\t\t\t&res.seq_res, task_flags);\n\tdprintk(\"NFS reply lookupp: %d\\n\", status);\n\treturn status;\n}\n\nstatic int nfs4_proc_lookupp(struct inode *inode, struct nfs_fh *fhandle,\n\t\t\t     struct nfs_fattr *fattr)\n{\n\tstruct nfs4_exception exception = {\n\t\t.interruptible = true,\n\t};\n\tint err;\n\tdo {\n\t\terr = _nfs4_proc_lookupp(inode, fhandle, fattr);\n\t\ttrace_nfs4_lookupp(inode, err);\n\t\terr = nfs4_handle_exception(NFS_SERVER(inode), err,\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int _nfs4_proc_access(struct inode *inode, struct nfs_access_entry *entry,\n\t\t\t     const struct cred *cred)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs4_accessargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.access = entry->mask,\n\t};\n\tstruct nfs4_accessres res = {\n\t\t.server = server,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_ACCESS],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t\t.rpc_cred = cred,\n\t};\n\tint status = 0;\n\n\tif (!nfs4_have_delegation(inode, FMODE_READ)) {\n\t\tres.fattr = nfs_alloc_fattr();\n\t\tif (res.fattr == NULL)\n\t\t\treturn -ENOMEM;\n\t\targs.bitmask = server->cache_consistency_bitmask;\n\t}\n\tstatus = nfs4_call_sync(server->client, server, &msg, &args.seq_args, &res.seq_res, 0);\n\tif (!status) {\n\t\tnfs_access_set_mask(entry, res.access);\n\t\tif (res.fattr)\n\t\t\tnfs_refresh_inode(inode, res.fattr);\n\t}\n\tnfs_free_fattr(res.fattr);\n\treturn status;\n}\n\nstatic int nfs4_proc_access(struct inode *inode, struct nfs_access_entry *entry,\n\t\t\t    const struct cred *cred)\n{\n\tstruct nfs4_exception exception = {\n\t\t.interruptible = true,\n\t};\n\tint err;\n\tdo {\n\t\terr = _nfs4_proc_access(inode, entry, cred);\n\t\ttrace_nfs4_access(inode, err);\n\t\terr = nfs4_handle_exception(NFS_SERVER(inode), err,\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\n \nstatic int _nfs4_proc_readlink(struct inode *inode, struct page *page,\n\t\tunsigned int pgbase, unsigned int pglen)\n{\n\tstruct nfs4_readlink args = {\n\t\t.fh       = NFS_FH(inode),\n\t\t.pgbase\t  = pgbase,\n\t\t.pglen    = pglen,\n\t\t.pages    = &page,\n\t};\n\tstruct nfs4_readlink_res res;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_READLINK],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\n\treturn nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode), &msg, &args.seq_args, &res.seq_res, 0);\n}\n\nstatic int nfs4_proc_readlink(struct inode *inode, struct page *page,\n\t\tunsigned int pgbase, unsigned int pglen)\n{\n\tstruct nfs4_exception exception = {\n\t\t.interruptible = true,\n\t};\n\tint err;\n\tdo {\n\t\terr = _nfs4_proc_readlink(inode, page, pgbase, pglen);\n\t\ttrace_nfs4_readlink(inode, err);\n\t\terr = nfs4_handle_exception(NFS_SERVER(inode), err,\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\n \nstatic int\nnfs4_proc_create(struct inode *dir, struct dentry *dentry, struct iattr *sattr,\n\t\t int flags)\n{\n\tstruct nfs_server *server = NFS_SERVER(dir);\n\tstruct nfs4_label l, *ilabel;\n\tstruct nfs_open_context *ctx;\n\tstruct nfs4_state *state;\n\tint status = 0;\n\n\tctx = alloc_nfs_open_context(dentry, FMODE_READ, NULL);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\tilabel = nfs4_label_init_security(dir, dentry, sattr, &l);\n\n\tif (!(server->attr_bitmask[2] & FATTR4_WORD2_MODE_UMASK))\n\t\tsattr->ia_mode &= ~current_umask();\n\tstate = nfs4_do_open(dir, ctx, flags, sattr, ilabel, NULL);\n\tif (IS_ERR(state)) {\n\t\tstatus = PTR_ERR(state);\n\t\tgoto out;\n\t}\nout:\n\tnfs4_label_release_security(ilabel);\n\tput_nfs_open_context(ctx);\n\treturn status;\n}\n\nstatic int\n_nfs4_proc_remove(struct inode *dir, const struct qstr *name, u32 ftype)\n{\n\tstruct nfs_server *server = NFS_SERVER(dir);\n\tstruct nfs_removeargs args = {\n\t\t.fh = NFS_FH(dir),\n\t\t.name = *name,\n\t};\n\tstruct nfs_removeres res = {\n\t\t.server = server,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_REMOVE],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned long timestamp = jiffies;\n\tint status;\n\n\tstatus = nfs4_call_sync(server->client, server, &msg, &args.seq_args, &res.seq_res, 1);\n\tif (status == 0) {\n\t\tspin_lock(&dir->i_lock);\n\t\t \n\t\tif (ftype == NF4DIR && dir->i_nlink > 2)\n\t\t\tnfs4_dec_nlink_locked(dir);\n\t\tnfs4_update_changeattr_locked(dir, &res.cinfo, timestamp,\n\t\t\t\t\t      NFS_INO_INVALID_DATA);\n\t\tspin_unlock(&dir->i_lock);\n\t}\n\treturn status;\n}\n\nstatic int nfs4_proc_remove(struct inode *dir, struct dentry *dentry)\n{\n\tstruct nfs4_exception exception = {\n\t\t.interruptible = true,\n\t};\n\tstruct inode *inode = d_inode(dentry);\n\tint err;\n\n\tif (inode) {\n\t\tif (inode->i_nlink == 1)\n\t\t\tnfs4_inode_return_delegation(inode);\n\t\telse\n\t\t\tnfs4_inode_make_writeable(inode);\n\t}\n\tdo {\n\t\terr = _nfs4_proc_remove(dir, &dentry->d_name, NF4REG);\n\t\ttrace_nfs4_remove(dir, &dentry->d_name, err);\n\t\terr = nfs4_handle_exception(NFS_SERVER(dir), err,\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int nfs4_proc_rmdir(struct inode *dir, const struct qstr *name)\n{\n\tstruct nfs4_exception exception = {\n\t\t.interruptible = true,\n\t};\n\tint err;\n\n\tdo {\n\t\terr = _nfs4_proc_remove(dir, name, NF4DIR);\n\t\ttrace_nfs4_remove(dir, name, err);\n\t\terr = nfs4_handle_exception(NFS_SERVER(dir), err,\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic void nfs4_proc_unlink_setup(struct rpc_message *msg,\n\t\tstruct dentry *dentry,\n\t\tstruct inode *inode)\n{\n\tstruct nfs_removeargs *args = msg->rpc_argp;\n\tstruct nfs_removeres *res = msg->rpc_resp;\n\n\tres->server = NFS_SB(dentry->d_sb);\n\tmsg->rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_REMOVE];\n\tnfs4_init_sequence(&args->seq_args, &res->seq_res, 1, 0);\n\n\tnfs_fattr_init(res->dir_attr);\n\n\tif (inode) {\n\t\tnfs4_inode_return_delegation(inode);\n\t\tnfs_d_prune_case_insensitive_aliases(inode);\n\t}\n}\n\nstatic void nfs4_proc_unlink_rpc_prepare(struct rpc_task *task, struct nfs_unlinkdata *data)\n{\n\tnfs4_setup_sequence(NFS_SB(data->dentry->d_sb)->nfs_client,\n\t\t\t&data->args.seq_args,\n\t\t\t&data->res.seq_res,\n\t\t\ttask);\n}\n\nstatic int nfs4_proc_unlink_done(struct rpc_task *task, struct inode *dir)\n{\n\tstruct nfs_unlinkdata *data = task->tk_calldata;\n\tstruct nfs_removeres *res = &data->res;\n\n\tif (!nfs4_sequence_done(task, &res->seq_res))\n\t\treturn 0;\n\tif (nfs4_async_handle_error(task, res->server, NULL,\n\t\t\t\t    &data->timeout) == -EAGAIN)\n\t\treturn 0;\n\tif (task->tk_status == 0)\n\t\tnfs4_update_changeattr(dir, &res->cinfo,\n\t\t\t\tres->dir_attr->time_start,\n\t\t\t\tNFS_INO_INVALID_DATA);\n\treturn 1;\n}\n\nstatic void nfs4_proc_rename_setup(struct rpc_message *msg,\n\t\tstruct dentry *old_dentry,\n\t\tstruct dentry *new_dentry)\n{\n\tstruct nfs_renameargs *arg = msg->rpc_argp;\n\tstruct nfs_renameres *res = msg->rpc_resp;\n\tstruct inode *old_inode = d_inode(old_dentry);\n\tstruct inode *new_inode = d_inode(new_dentry);\n\n\tif (old_inode)\n\t\tnfs4_inode_make_writeable(old_inode);\n\tif (new_inode)\n\t\tnfs4_inode_return_delegation(new_inode);\n\tmsg->rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_RENAME];\n\tres->server = NFS_SB(old_dentry->d_sb);\n\tnfs4_init_sequence(&arg->seq_args, &res->seq_res, 1, 0);\n}\n\nstatic void nfs4_proc_rename_rpc_prepare(struct rpc_task *task, struct nfs_renamedata *data)\n{\n\tnfs4_setup_sequence(NFS_SERVER(data->old_dir)->nfs_client,\n\t\t\t&data->args.seq_args,\n\t\t\t&data->res.seq_res,\n\t\t\ttask);\n}\n\nstatic int nfs4_proc_rename_done(struct rpc_task *task, struct inode *old_dir,\n\t\t\t\t struct inode *new_dir)\n{\n\tstruct nfs_renamedata *data = task->tk_calldata;\n\tstruct nfs_renameres *res = &data->res;\n\n\tif (!nfs4_sequence_done(task, &res->seq_res))\n\t\treturn 0;\n\tif (nfs4_async_handle_error(task, res->server, NULL, &data->timeout) == -EAGAIN)\n\t\treturn 0;\n\n\tif (task->tk_status == 0) {\n\t\tnfs_d_prune_case_insensitive_aliases(d_inode(data->old_dentry));\n\t\tif (new_dir != old_dir) {\n\t\t\t \n\t\t\tnfs4_update_changeattr(old_dir, &res->old_cinfo,\n\t\t\t\t\tres->old_fattr->time_start,\n\t\t\t\t\tNFS_INO_INVALID_NLINK |\n\t\t\t\t\t    NFS_INO_INVALID_DATA);\n\t\t\tnfs4_update_changeattr(new_dir, &res->new_cinfo,\n\t\t\t\t\tres->new_fattr->time_start,\n\t\t\t\t\tNFS_INO_INVALID_NLINK |\n\t\t\t\t\t    NFS_INO_INVALID_DATA);\n\t\t} else\n\t\t\tnfs4_update_changeattr(old_dir, &res->old_cinfo,\n\t\t\t\t\tres->old_fattr->time_start,\n\t\t\t\t\tNFS_INO_INVALID_DATA);\n\t}\n\treturn 1;\n}\n\nstatic int _nfs4_proc_link(struct inode *inode, struct inode *dir, const struct qstr *name)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\t__u32 bitmask[NFS4_BITMASK_SZ];\n\tstruct nfs4_link_arg arg = {\n\t\t.fh     = NFS_FH(inode),\n\t\t.dir_fh = NFS_FH(dir),\n\t\t.name   = name,\n\t\t.bitmask = bitmask,\n\t};\n\tstruct nfs4_link_res res = {\n\t\t.server = server,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LINK],\n\t\t.rpc_argp = &arg,\n\t\t.rpc_resp = &res,\n\t};\n\tint status = -ENOMEM;\n\n\tres.fattr = nfs_alloc_fattr_with_label(server);\n\tif (res.fattr == NULL)\n\t\tgoto out;\n\n\tnfs4_inode_make_writeable(inode);\n\tnfs4_bitmap_copy_adjust(bitmask, nfs4_bitmask(server, res.fattr->label), inode,\n\t\t\t\tNFS_INO_INVALID_CHANGE);\n\tstatus = nfs4_call_sync(server->client, server, &msg, &arg.seq_args, &res.seq_res, 1);\n\tif (!status) {\n\t\tnfs4_update_changeattr(dir, &res.cinfo, res.fattr->time_start,\n\t\t\t\t       NFS_INO_INVALID_DATA);\n\t\tnfs4_inc_nlink(inode);\n\t\tstatus = nfs_post_op_update_inode(inode, res.fattr);\n\t\tif (!status)\n\t\t\tnfs_setsecurity(inode, res.fattr);\n\t}\n\nout:\n\tnfs_free_fattr(res.fattr);\n\treturn status;\n}\n\nstatic int nfs4_proc_link(struct inode *inode, struct inode *dir, const struct qstr *name)\n{\n\tstruct nfs4_exception exception = {\n\t\t.interruptible = true,\n\t};\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(NFS_SERVER(inode),\n\t\t\t\t_nfs4_proc_link(inode, dir, name),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstruct nfs4_createdata {\n\tstruct rpc_message msg;\n\tstruct nfs4_create_arg arg;\n\tstruct nfs4_create_res res;\n\tstruct nfs_fh fh;\n\tstruct nfs_fattr fattr;\n};\n\nstatic struct nfs4_createdata *nfs4_alloc_createdata(struct inode *dir,\n\t\tconst struct qstr *name, struct iattr *sattr, u32 ftype)\n{\n\tstruct nfs4_createdata *data;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (data != NULL) {\n\t\tstruct nfs_server *server = NFS_SERVER(dir);\n\n\t\tdata->fattr.label = nfs4_label_alloc(server, GFP_KERNEL);\n\t\tif (IS_ERR(data->fattr.label))\n\t\t\tgoto out_free;\n\n\t\tdata->msg.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_CREATE];\n\t\tdata->msg.rpc_argp = &data->arg;\n\t\tdata->msg.rpc_resp = &data->res;\n\t\tdata->arg.dir_fh = NFS_FH(dir);\n\t\tdata->arg.server = server;\n\t\tdata->arg.name = name;\n\t\tdata->arg.attrs = sattr;\n\t\tdata->arg.ftype = ftype;\n\t\tdata->arg.bitmask = nfs4_bitmask(server, data->fattr.label);\n\t\tdata->arg.umask = current_umask();\n\t\tdata->res.server = server;\n\t\tdata->res.fh = &data->fh;\n\t\tdata->res.fattr = &data->fattr;\n\t\tnfs_fattr_init(data->res.fattr);\n\t}\n\treturn data;\nout_free:\n\tkfree(data);\n\treturn NULL;\n}\n\nstatic int nfs4_do_create(struct inode *dir, struct dentry *dentry, struct nfs4_createdata *data)\n{\n\tint status = nfs4_call_sync(NFS_SERVER(dir)->client, NFS_SERVER(dir), &data->msg,\n\t\t\t\t    &data->arg.seq_args, &data->res.seq_res, 1);\n\tif (status == 0) {\n\t\tspin_lock(&dir->i_lock);\n\t\t \n\t\tif (data->arg.ftype == NF4DIR)\n\t\t\tnfs4_inc_nlink_locked(dir);\n\t\tnfs4_update_changeattr_locked(dir, &data->res.dir_cinfo,\n\t\t\t\t\t      data->res.fattr->time_start,\n\t\t\t\t\t      NFS_INO_INVALID_DATA);\n\t\tspin_unlock(&dir->i_lock);\n\t\tstatus = nfs_instantiate(dentry, data->res.fh, data->res.fattr);\n\t}\n\treturn status;\n}\n\nstatic void nfs4_free_createdata(struct nfs4_createdata *data)\n{\n\tnfs4_label_free(data->fattr.label);\n\tkfree(data);\n}\n\nstatic int _nfs4_proc_symlink(struct inode *dir, struct dentry *dentry,\n\t\tstruct page *page, unsigned int len, struct iattr *sattr,\n\t\tstruct nfs4_label *label)\n{\n\tstruct nfs4_createdata *data;\n\tint status = -ENAMETOOLONG;\n\n\tif (len > NFS4_MAXPATHLEN)\n\t\tgoto out;\n\n\tstatus = -ENOMEM;\n\tdata = nfs4_alloc_createdata(dir, &dentry->d_name, sattr, NF4LNK);\n\tif (data == NULL)\n\t\tgoto out;\n\n\tdata->msg.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_SYMLINK];\n\tdata->arg.u.symlink.pages = &page;\n\tdata->arg.u.symlink.len = len;\n\tdata->arg.label = label;\n\t\n\tstatus = nfs4_do_create(dir, dentry, data);\n\n\tnfs4_free_createdata(data);\nout:\n\treturn status;\n}\n\nstatic int nfs4_proc_symlink(struct inode *dir, struct dentry *dentry,\n\t\tstruct page *page, unsigned int len, struct iattr *sattr)\n{\n\tstruct nfs4_exception exception = {\n\t\t.interruptible = true,\n\t};\n\tstruct nfs4_label l, *label;\n\tint err;\n\n\tlabel = nfs4_label_init_security(dir, dentry, sattr, &l);\n\n\tdo {\n\t\terr = _nfs4_proc_symlink(dir, dentry, page, len, sattr, label);\n\t\ttrace_nfs4_symlink(dir, &dentry->d_name, err);\n\t\terr = nfs4_handle_exception(NFS_SERVER(dir), err,\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\n\tnfs4_label_release_security(label);\n\treturn err;\n}\n\nstatic int _nfs4_proc_mkdir(struct inode *dir, struct dentry *dentry,\n\t\tstruct iattr *sattr, struct nfs4_label *label)\n{\n\tstruct nfs4_createdata *data;\n\tint status = -ENOMEM;\n\n\tdata = nfs4_alloc_createdata(dir, &dentry->d_name, sattr, NF4DIR);\n\tif (data == NULL)\n\t\tgoto out;\n\n\tdata->arg.label = label;\n\tstatus = nfs4_do_create(dir, dentry, data);\n\n\tnfs4_free_createdata(data);\nout:\n\treturn status;\n}\n\nstatic int nfs4_proc_mkdir(struct inode *dir, struct dentry *dentry,\n\t\tstruct iattr *sattr)\n{\n\tstruct nfs_server *server = NFS_SERVER(dir);\n\tstruct nfs4_exception exception = {\n\t\t.interruptible = true,\n\t};\n\tstruct nfs4_label l, *label;\n\tint err;\n\n\tlabel = nfs4_label_init_security(dir, dentry, sattr, &l);\n\n\tif (!(server->attr_bitmask[2] & FATTR4_WORD2_MODE_UMASK))\n\t\tsattr->ia_mode &= ~current_umask();\n\tdo {\n\t\terr = _nfs4_proc_mkdir(dir, dentry, sattr, label);\n\t\ttrace_nfs4_mkdir(dir, &dentry->d_name, err);\n\t\terr = nfs4_handle_exception(NFS_SERVER(dir), err,\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\tnfs4_label_release_security(label);\n\n\treturn err;\n}\n\nstatic int _nfs4_proc_readdir(struct nfs_readdir_arg *nr_arg,\n\t\t\t      struct nfs_readdir_res *nr_res)\n{\n\tstruct inode\t\t*dir = d_inode(nr_arg->dentry);\n\tstruct nfs_server\t*server = NFS_SERVER(dir);\n\tstruct nfs4_readdir_arg args = {\n\t\t.fh = NFS_FH(dir),\n\t\t.pages = nr_arg->pages,\n\t\t.pgbase = 0,\n\t\t.count = nr_arg->page_len,\n\t\t.plus = nr_arg->plus,\n\t};\n\tstruct nfs4_readdir_res res;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_READDIR],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t\t.rpc_cred = nr_arg->cred,\n\t};\n\tint\t\t\tstatus;\n\n\tdprintk(\"%s: dentry = %pd2, cookie = %llu\\n\", __func__,\n\t\tnr_arg->dentry, (unsigned long long)nr_arg->cookie);\n\tif (!(server->caps & NFS_CAP_SECURITY_LABEL))\n\t\targs.bitmask = server->attr_bitmask_nl;\n\telse\n\t\targs.bitmask = server->attr_bitmask;\n\n\tnfs4_setup_readdir(nr_arg->cookie, nr_arg->verf, nr_arg->dentry, &args);\n\tres.pgbase = args.pgbase;\n\tstatus = nfs4_call_sync(server->client, server, &msg, &args.seq_args,\n\t\t\t&res.seq_res, 0);\n\tif (status >= 0) {\n\t\tmemcpy(nr_res->verf, res.verifier.data, NFS4_VERIFIER_SIZE);\n\t\tstatus += args.pgbase;\n\t}\n\n\tnfs_invalidate_atime(dir);\n\n\tdprintk(\"%s: returns %d\\n\", __func__, status);\n\treturn status;\n}\n\nstatic int nfs4_proc_readdir(struct nfs_readdir_arg *arg,\n\t\t\t     struct nfs_readdir_res *res)\n{\n\tstruct nfs4_exception exception = {\n\t\t.interruptible = true,\n\t};\n\tint err;\n\tdo {\n\t\terr = _nfs4_proc_readdir(arg, res);\n\t\ttrace_nfs4_readdir(d_inode(arg->dentry), err);\n\t\terr = nfs4_handle_exception(NFS_SERVER(d_inode(arg->dentry)),\n\t\t\t\t\t    err, &exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int _nfs4_proc_mknod(struct inode *dir, struct dentry *dentry,\n\t\tstruct iattr *sattr, struct nfs4_label *label, dev_t rdev)\n{\n\tstruct nfs4_createdata *data;\n\tint mode = sattr->ia_mode;\n\tint status = -ENOMEM;\n\n\tdata = nfs4_alloc_createdata(dir, &dentry->d_name, sattr, NF4SOCK);\n\tif (data == NULL)\n\t\tgoto out;\n\n\tif (S_ISFIFO(mode))\n\t\tdata->arg.ftype = NF4FIFO;\n\telse if (S_ISBLK(mode)) {\n\t\tdata->arg.ftype = NF4BLK;\n\t\tdata->arg.u.device.specdata1 = MAJOR(rdev);\n\t\tdata->arg.u.device.specdata2 = MINOR(rdev);\n\t}\n\telse if (S_ISCHR(mode)) {\n\t\tdata->arg.ftype = NF4CHR;\n\t\tdata->arg.u.device.specdata1 = MAJOR(rdev);\n\t\tdata->arg.u.device.specdata2 = MINOR(rdev);\n\t} else if (!S_ISSOCK(mode)) {\n\t\tstatus = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\tdata->arg.label = label;\n\tstatus = nfs4_do_create(dir, dentry, data);\nout_free:\n\tnfs4_free_createdata(data);\nout:\n\treturn status;\n}\n\nstatic int nfs4_proc_mknod(struct inode *dir, struct dentry *dentry,\n\t\tstruct iattr *sattr, dev_t rdev)\n{\n\tstruct nfs_server *server = NFS_SERVER(dir);\n\tstruct nfs4_exception exception = {\n\t\t.interruptible = true,\n\t};\n\tstruct nfs4_label l, *label;\n\tint err;\n\n\tlabel = nfs4_label_init_security(dir, dentry, sattr, &l);\n\n\tif (!(server->attr_bitmask[2] & FATTR4_WORD2_MODE_UMASK))\n\t\tsattr->ia_mode &= ~current_umask();\n\tdo {\n\t\terr = _nfs4_proc_mknod(dir, dentry, sattr, label, rdev);\n\t\ttrace_nfs4_mknod(dir, &dentry->d_name, err);\n\t\terr = nfs4_handle_exception(NFS_SERVER(dir), err,\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\n\tnfs4_label_release_security(label);\n\n\treturn err;\n}\n\nstatic int _nfs4_proc_statfs(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\t struct nfs_fsstat *fsstat)\n{\n\tstruct nfs4_statfs_arg args = {\n\t\t.fh = fhandle,\n\t\t.bitmask = server->attr_bitmask,\n\t};\n\tstruct nfs4_statfs_res res = {\n\t\t.fsstat = fsstat,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_STATFS],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\n\tnfs_fattr_init(fsstat->fattr);\n\treturn  nfs4_call_sync(server->client, server, &msg, &args.seq_args, &res.seq_res, 0);\n}\n\nstatic int nfs4_proc_statfs(struct nfs_server *server, struct nfs_fh *fhandle, struct nfs_fsstat *fsstat)\n{\n\tstruct nfs4_exception exception = {\n\t\t.interruptible = true,\n\t};\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(server,\n\t\t\t\t_nfs4_proc_statfs(server, fhandle, fsstat),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int _nfs4_do_fsinfo(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\tstruct nfs_fsinfo *fsinfo)\n{\n\tstruct nfs4_fsinfo_arg args = {\n\t\t.fh = fhandle,\n\t\t.bitmask = server->attr_bitmask,\n\t};\n\tstruct nfs4_fsinfo_res res = {\n\t\t.fsinfo = fsinfo,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_FSINFO],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\n\treturn nfs4_call_sync(server->client, server, &msg, &args.seq_args, &res.seq_res, 0);\n}\n\nstatic int nfs4_do_fsinfo(struct nfs_server *server, struct nfs_fh *fhandle, struct nfs_fsinfo *fsinfo)\n{\n\tstruct nfs4_exception exception = {\n\t\t.interruptible = true,\n\t};\n\tint err;\n\n\tdo {\n\t\terr = _nfs4_do_fsinfo(server, fhandle, fsinfo);\n\t\ttrace_nfs4_fsinfo(server, fhandle, fsinfo->fattr, err);\n\t\tif (err == 0) {\n\t\t\tnfs4_set_lease_period(server->nfs_client, fsinfo->lease_time * HZ);\n\t\t\tbreak;\n\t\t}\n\t\terr = nfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int nfs4_proc_fsinfo(struct nfs_server *server, struct nfs_fh *fhandle, struct nfs_fsinfo *fsinfo)\n{\n\tint error;\n\n\tnfs_fattr_init(fsinfo->fattr);\n\terror = nfs4_do_fsinfo(server, fhandle, fsinfo);\n\tif (error == 0) {\n\t\t \n\t\tserver->pnfs_blksize = fsinfo->blksize;\n\t\tset_pnfs_layoutdriver(server, fhandle, fsinfo);\n\t}\n\n\treturn error;\n}\n\nstatic int _nfs4_proc_pathconf(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\tstruct nfs_pathconf *pathconf)\n{\n\tstruct nfs4_pathconf_arg args = {\n\t\t.fh = fhandle,\n\t\t.bitmask = server->attr_bitmask,\n\t};\n\tstruct nfs4_pathconf_res res = {\n\t\t.pathconf = pathconf,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_PATHCONF],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\n\t \n\tif ((args.bitmask[0] & nfs4_pathconf_bitmap[0]) == 0) {\n\t\tmemset(pathconf, 0, sizeof(*pathconf));\n\t\treturn 0;\n\t}\n\n\tnfs_fattr_init(pathconf->fattr);\n\treturn nfs4_call_sync(server->client, server, &msg, &args.seq_args, &res.seq_res, 0);\n}\n\nstatic int nfs4_proc_pathconf(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\tstruct nfs_pathconf *pathconf)\n{\n\tstruct nfs4_exception exception = {\n\t\t.interruptible = true,\n\t};\n\tint err;\n\n\tdo {\n\t\terr = nfs4_handle_exception(server,\n\t\t\t\t_nfs4_proc_pathconf(server, fhandle, pathconf),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nint nfs4_set_rw_stateid(nfs4_stateid *stateid,\n\t\tconst struct nfs_open_context *ctx,\n\t\tconst struct nfs_lock_context *l_ctx,\n\t\tfmode_t fmode)\n{\n\treturn nfs4_select_rw_stateid(ctx->state, fmode, l_ctx, stateid, NULL);\n}\nEXPORT_SYMBOL_GPL(nfs4_set_rw_stateid);\n\nstatic bool nfs4_stateid_is_current(nfs4_stateid *stateid,\n\t\tconst struct nfs_open_context *ctx,\n\t\tconst struct nfs_lock_context *l_ctx,\n\t\tfmode_t fmode)\n{\n\tnfs4_stateid _current_stateid;\n\n\t \n\tif (nfs4_set_rw_stateid(&_current_stateid, ctx, l_ctx, fmode) == -EIO)\n\t\treturn true;\n\treturn nfs4_stateid_match(stateid, &_current_stateid);\n}\n\nstatic bool nfs4_error_stateid_expired(int err)\n{\n\tswitch (err) {\n\tcase -NFS4ERR_DELEG_REVOKED:\n\tcase -NFS4ERR_ADMIN_REVOKED:\n\tcase -NFS4ERR_BAD_STATEID:\n\tcase -NFS4ERR_STALE_STATEID:\n\tcase -NFS4ERR_OLD_STATEID:\n\tcase -NFS4ERR_OPENMODE:\n\tcase -NFS4ERR_EXPIRED:\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic int nfs4_read_done_cb(struct rpc_task *task, struct nfs_pgio_header *hdr)\n{\n\tstruct nfs_server *server = NFS_SERVER(hdr->inode);\n\n\ttrace_nfs4_read(hdr, task->tk_status);\n\tif (task->tk_status < 0) {\n\t\tstruct nfs4_exception exception = {\n\t\t\t.inode = hdr->inode,\n\t\t\t.state = hdr->args.context->state,\n\t\t\t.stateid = &hdr->args.stateid,\n\t\t};\n\t\ttask->tk_status = nfs4_async_handle_exception(task,\n\t\t\t\tserver, task->tk_status, &exception);\n\t\tif (exception.retry) {\n\t\t\trpc_restart_call_prepare(task);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t}\n\n\tif (task->tk_status > 0)\n\t\trenew_lease(server, hdr->timestamp);\n\treturn 0;\n}\n\nstatic bool nfs4_read_stateid_changed(struct rpc_task *task,\n\t\tstruct nfs_pgio_args *args)\n{\n\n\tif (!nfs4_error_stateid_expired(task->tk_status) ||\n\t\tnfs4_stateid_is_current(&args->stateid,\n\t\t\t\targs->context,\n\t\t\t\targs->lock_context,\n\t\t\t\tFMODE_READ))\n\t\treturn false;\n\trpc_restart_call_prepare(task);\n\treturn true;\n}\n\nstatic bool nfs4_read_plus_not_supported(struct rpc_task *task,\n\t\t\t\t\t struct nfs_pgio_header *hdr)\n{\n\tstruct nfs_server *server = NFS_SERVER(hdr->inode);\n\tstruct rpc_message *msg = &task->tk_msg;\n\n\tif (msg->rpc_proc == &nfs4_procedures[NFSPROC4_CLNT_READ_PLUS] &&\n\t    server->caps & NFS_CAP_READ_PLUS && task->tk_status == -ENOTSUPP) {\n\t\tserver->caps &= ~NFS_CAP_READ_PLUS;\n\t\tmsg->rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_READ];\n\t\trpc_restart_call_prepare(task);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic int nfs4_read_done(struct rpc_task *task, struct nfs_pgio_header *hdr)\n{\n\tif (!nfs4_sequence_done(task, &hdr->res.seq_res))\n\t\treturn -EAGAIN;\n\tif (nfs4_read_stateid_changed(task, &hdr->args))\n\t\treturn -EAGAIN;\n\tif (nfs4_read_plus_not_supported(task, hdr))\n\t\treturn -EAGAIN;\n\tif (task->tk_status > 0)\n\t\tnfs_invalidate_atime(hdr->inode);\n\treturn hdr->pgio_done_cb ? hdr->pgio_done_cb(task, hdr) :\n\t\t\t\t    nfs4_read_done_cb(task, hdr);\n}\n\n#if defined CONFIG_NFS_V4_2 && defined CONFIG_NFS_V4_2_READ_PLUS\nstatic bool nfs42_read_plus_support(struct nfs_pgio_header *hdr,\n\t\t\t\t    struct rpc_message *msg)\n{\n\t \n\tif (nfs_server_capable(hdr->inode, NFS_CAP_READ_PLUS) && !hdr->ds_clp) {\n\t\tmsg->rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_READ_PLUS];\n\t\treturn nfs_read_alloc_scratch(hdr, READ_PLUS_SCRATCH_SIZE);\n\t}\n\treturn false;\n}\n#else\nstatic bool nfs42_read_plus_support(struct nfs_pgio_header *hdr,\n\t\t\t\t    struct rpc_message *msg)\n{\n\treturn false;\n}\n#endif  \n\nstatic void nfs4_proc_read_setup(struct nfs_pgio_header *hdr,\n\t\t\t\t struct rpc_message *msg)\n{\n\thdr->timestamp   = jiffies;\n\tif (!hdr->pgio_done_cb)\n\t\thdr->pgio_done_cb = nfs4_read_done_cb;\n\tif (!nfs42_read_plus_support(hdr, msg))\n\t\tmsg->rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_READ];\n\tnfs4_init_sequence(&hdr->args.seq_args, &hdr->res.seq_res, 0, 0);\n}\n\nstatic int nfs4_proc_pgio_rpc_prepare(struct rpc_task *task,\n\t\t\t\t      struct nfs_pgio_header *hdr)\n{\n\tif (nfs4_setup_sequence(NFS_SERVER(hdr->inode)->nfs_client,\n\t\t\t&hdr->args.seq_args,\n\t\t\t&hdr->res.seq_res,\n\t\t\ttask))\n\t\treturn 0;\n\tif (nfs4_set_rw_stateid(&hdr->args.stateid, hdr->args.context,\n\t\t\t\thdr->args.lock_context,\n\t\t\t\thdr->rw_mode) == -EIO)\n\t\treturn -EIO;\n\tif (unlikely(test_bit(NFS_CONTEXT_BAD, &hdr->args.context->flags)))\n\t\treturn -EIO;\n\treturn 0;\n}\n\nstatic int nfs4_write_done_cb(struct rpc_task *task,\n\t\t\t      struct nfs_pgio_header *hdr)\n{\n\tstruct inode *inode = hdr->inode;\n\n\ttrace_nfs4_write(hdr, task->tk_status);\n\tif (task->tk_status < 0) {\n\t\tstruct nfs4_exception exception = {\n\t\t\t.inode = hdr->inode,\n\t\t\t.state = hdr->args.context->state,\n\t\t\t.stateid = &hdr->args.stateid,\n\t\t};\n\t\ttask->tk_status = nfs4_async_handle_exception(task,\n\t\t\t\tNFS_SERVER(inode), task->tk_status,\n\t\t\t\t&exception);\n\t\tif (exception.retry) {\n\t\t\trpc_restart_call_prepare(task);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t}\n\tif (task->tk_status >= 0) {\n\t\trenew_lease(NFS_SERVER(inode), hdr->timestamp);\n\t\tnfs_writeback_update_inode(hdr);\n\t}\n\treturn 0;\n}\n\nstatic bool nfs4_write_stateid_changed(struct rpc_task *task,\n\t\tstruct nfs_pgio_args *args)\n{\n\n\tif (!nfs4_error_stateid_expired(task->tk_status) ||\n\t\tnfs4_stateid_is_current(&args->stateid,\n\t\t\t\targs->context,\n\t\t\t\targs->lock_context,\n\t\t\t\tFMODE_WRITE))\n\t\treturn false;\n\trpc_restart_call_prepare(task);\n\treturn true;\n}\n\nstatic int nfs4_write_done(struct rpc_task *task, struct nfs_pgio_header *hdr)\n{\n\tif (!nfs4_sequence_done(task, &hdr->res.seq_res))\n\t\treturn -EAGAIN;\n\tif (nfs4_write_stateid_changed(task, &hdr->args))\n\t\treturn -EAGAIN;\n\treturn hdr->pgio_done_cb ? hdr->pgio_done_cb(task, hdr) :\n\t\tnfs4_write_done_cb(task, hdr);\n}\n\nstatic\nbool nfs4_write_need_cache_consistency_data(struct nfs_pgio_header *hdr)\n{\n\t \n\tif (hdr->ds_clp != NULL || hdr->dreq != NULL)\n\t\treturn false;\n\t \n\treturn nfs4_have_delegation(hdr->inode, FMODE_READ) == 0;\n}\n\nvoid nfs4_bitmask_set(__u32 bitmask[], const __u32 src[],\n\t\t      struct inode *inode, unsigned long cache_validity)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tunsigned int i;\n\n\tmemcpy(bitmask, src, sizeof(*bitmask) * NFS4_BITMASK_SZ);\n\tcache_validity |= READ_ONCE(NFS_I(inode)->cache_validity);\n\n\tif (cache_validity & NFS_INO_INVALID_CHANGE)\n\t\tbitmask[0] |= FATTR4_WORD0_CHANGE;\n\tif (cache_validity & NFS_INO_INVALID_ATIME)\n\t\tbitmask[1] |= FATTR4_WORD1_TIME_ACCESS;\n\tif (cache_validity & NFS_INO_INVALID_MODE)\n\t\tbitmask[1] |= FATTR4_WORD1_MODE;\n\tif (cache_validity & NFS_INO_INVALID_OTHER)\n\t\tbitmask[1] |= FATTR4_WORD1_OWNER | FATTR4_WORD1_OWNER_GROUP;\n\tif (cache_validity & NFS_INO_INVALID_NLINK)\n\t\tbitmask[1] |= FATTR4_WORD1_NUMLINKS;\n\tif (cache_validity & NFS_INO_INVALID_CTIME)\n\t\tbitmask[1] |= FATTR4_WORD1_TIME_METADATA;\n\tif (cache_validity & NFS_INO_INVALID_MTIME)\n\t\tbitmask[1] |= FATTR4_WORD1_TIME_MODIFY;\n\tif (cache_validity & NFS_INO_INVALID_BLOCKS)\n\t\tbitmask[1] |= FATTR4_WORD1_SPACE_USED;\n\n\tif (cache_validity & NFS_INO_INVALID_SIZE)\n\t\tbitmask[0] |= FATTR4_WORD0_SIZE;\n\n\tfor (i = 0; i < NFS4_BITMASK_SZ; i++)\n\t\tbitmask[i] &= server->attr_bitmask[i];\n}\n\nstatic void nfs4_proc_write_setup(struct nfs_pgio_header *hdr,\n\t\t\t\t  struct rpc_message *msg,\n\t\t\t\t  struct rpc_clnt **clnt)\n{\n\tstruct nfs_server *server = NFS_SERVER(hdr->inode);\n\n\tif (!nfs4_write_need_cache_consistency_data(hdr)) {\n\t\thdr->args.bitmask = NULL;\n\t\thdr->res.fattr = NULL;\n\t} else {\n\t\tnfs4_bitmask_set(hdr->args.bitmask_store,\n\t\t\t\t server->cache_consistency_bitmask,\n\t\t\t\t hdr->inode, NFS_INO_INVALID_BLOCKS);\n\t\thdr->args.bitmask = hdr->args.bitmask_store;\n\t}\n\n\tif (!hdr->pgio_done_cb)\n\t\thdr->pgio_done_cb = nfs4_write_done_cb;\n\thdr->res.server = server;\n\thdr->timestamp   = jiffies;\n\n\tmsg->rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_WRITE];\n\tnfs4_init_sequence(&hdr->args.seq_args, &hdr->res.seq_res, 0, 0);\n\tnfs4_state_protect_write(hdr->ds_clp ? hdr->ds_clp : server->nfs_client, clnt, msg, hdr);\n}\n\nstatic void nfs4_proc_commit_rpc_prepare(struct rpc_task *task, struct nfs_commit_data *data)\n{\n\tnfs4_setup_sequence(NFS_SERVER(data->inode)->nfs_client,\n\t\t\t&data->args.seq_args,\n\t\t\t&data->res.seq_res,\n\t\t\ttask);\n}\n\nstatic int nfs4_commit_done_cb(struct rpc_task *task, struct nfs_commit_data *data)\n{\n\tstruct inode *inode = data->inode;\n\n\ttrace_nfs4_commit(data, task->tk_status);\n\tif (nfs4_async_handle_error(task, NFS_SERVER(inode),\n\t\t\t\t    NULL, NULL) == -EAGAIN) {\n\t\trpc_restart_call_prepare(task);\n\t\treturn -EAGAIN;\n\t}\n\treturn 0;\n}\n\nstatic int nfs4_commit_done(struct rpc_task *task, struct nfs_commit_data *data)\n{\n\tif (!nfs4_sequence_done(task, &data->res.seq_res))\n\t\treturn -EAGAIN;\n\treturn data->commit_done_cb(task, data);\n}\n\nstatic void nfs4_proc_commit_setup(struct nfs_commit_data *data, struct rpc_message *msg,\n\t\t\t\t   struct rpc_clnt **clnt)\n{\n\tstruct nfs_server *server = NFS_SERVER(data->inode);\n\n\tif (data->commit_done_cb == NULL)\n\t\tdata->commit_done_cb = nfs4_commit_done_cb;\n\tdata->res.server = server;\n\tmsg->rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_COMMIT];\n\tnfs4_init_sequence(&data->args.seq_args, &data->res.seq_res, 1, 0);\n\tnfs4_state_protect(data->ds_clp ? data->ds_clp : server->nfs_client,\n\t\t\tNFS_SP4_MACH_CRED_COMMIT, clnt, msg);\n}\n\nstatic int _nfs4_proc_commit(struct file *dst, struct nfs_commitargs *args,\n\t\t\t\tstruct nfs_commitres *res)\n{\n\tstruct inode *dst_inode = file_inode(dst);\n\tstruct nfs_server *server = NFS_SERVER(dst_inode);\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_COMMIT],\n\t\t.rpc_argp = args,\n\t\t.rpc_resp = res,\n\t};\n\n\targs->fh = NFS_FH(dst_inode);\n\treturn nfs4_call_sync(server->client, server, &msg,\n\t\t\t&args->seq_args, &res->seq_res, 1);\n}\n\nint nfs4_proc_commit(struct file *dst, __u64 offset, __u32 count, struct nfs_commitres *res)\n{\n\tstruct nfs_commitargs args = {\n\t\t.offset = offset,\n\t\t.count = count,\n\t};\n\tstruct nfs_server *dst_server = NFS_SERVER(file_inode(dst));\n\tstruct nfs4_exception exception = { };\n\tint status;\n\n\tdo {\n\t\tstatus = _nfs4_proc_commit(dst, &args, res);\n\t\tstatus = nfs4_handle_exception(dst_server, status, &exception);\n\t} while (exception.retry);\n\n\treturn status;\n}\n\nstruct nfs4_renewdata {\n\tstruct nfs_client\t*client;\n\tunsigned long\t\ttimestamp;\n};\n\n \nstatic void nfs4_renew_release(void *calldata)\n{\n\tstruct nfs4_renewdata *data = calldata;\n\tstruct nfs_client *clp = data->client;\n\n\tif (refcount_read(&clp->cl_count) > 1)\n\t\tnfs4_schedule_state_renewal(clp);\n\tnfs_put_client(clp);\n\tkfree(data);\n}\n\nstatic void nfs4_renew_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_renewdata *data = calldata;\n\tstruct nfs_client *clp = data->client;\n\tunsigned long timestamp = data->timestamp;\n\n\ttrace_nfs4_renew_async(clp, task->tk_status);\n\tswitch (task->tk_status) {\n\tcase 0:\n\t\tbreak;\n\tcase -NFS4ERR_LEASE_MOVED:\n\t\tnfs4_schedule_lease_moved_recovery(clp);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tif (test_bit(NFS_CS_RENEWD, &clp->cl_res_state) == 0)\n\t\t\treturn;\n\t\tif (task->tk_status != NFS4ERR_CB_PATH_DOWN) {\n\t\t\tnfs4_schedule_lease_recovery(clp);\n\t\t\treturn;\n\t\t}\n\t\tnfs4_schedule_path_down_recovery(clp);\n\t}\n\tdo_renew_lease(clp, timestamp);\n}\n\nstatic const struct rpc_call_ops nfs4_renew_ops = {\n\t.rpc_call_done = nfs4_renew_done,\n\t.rpc_release = nfs4_renew_release,\n};\n\nstatic int nfs4_proc_async_renew(struct nfs_client *clp, const struct cred *cred, unsigned renew_flags)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs4_procedures[NFSPROC4_CLNT_RENEW],\n\t\t.rpc_argp\t= clp,\n\t\t.rpc_cred\t= cred,\n\t};\n\tstruct nfs4_renewdata *data;\n\n\tif (renew_flags == 0)\n\t\treturn 0;\n\tif (!refcount_inc_not_zero(&clp->cl_count))\n\t\treturn -EIO;\n\tdata = kmalloc(sizeof(*data), GFP_NOFS);\n\tif (data == NULL) {\n\t\tnfs_put_client(clp);\n\t\treturn -ENOMEM;\n\t}\n\tdata->client = clp;\n\tdata->timestamp = jiffies;\n\treturn rpc_call_async(clp->cl_rpcclient, &msg, RPC_TASK_TIMEOUT,\n\t\t\t&nfs4_renew_ops, data);\n}\n\nstatic int nfs4_proc_renew(struct nfs_client *clp, const struct cred *cred)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs4_procedures[NFSPROC4_CLNT_RENEW],\n\t\t.rpc_argp\t= clp,\n\t\t.rpc_cred\t= cred,\n\t};\n\tunsigned long now = jiffies;\n\tint status;\n\n\tstatus = rpc_call_sync(clp->cl_rpcclient, &msg, RPC_TASK_TIMEOUT);\n\tif (status < 0)\n\t\treturn status;\n\tdo_renew_lease(clp, now);\n\treturn 0;\n}\n\nstatic bool nfs4_server_supports_acls(const struct nfs_server *server,\n\t\t\t\t      enum nfs4_acl_type type)\n{\n\tswitch (type) {\n\tdefault:\n\t\treturn server->attr_bitmask[0] & FATTR4_WORD0_ACL;\n\tcase NFS4ACL_DACL:\n\t\treturn server->attr_bitmask[1] & FATTR4_WORD1_DACL;\n\tcase NFS4ACL_SACL:\n\t\treturn server->attr_bitmask[1] & FATTR4_WORD1_SACL;\n\t}\n}\n\n \n#define NFS4ACL_MAXPAGES DIV_ROUND_UP(XATTR_SIZE_MAX, PAGE_SIZE)\n\nint nfs4_buf_to_pages_noslab(const void *buf, size_t buflen,\n\t\tstruct page **pages)\n{\n\tstruct page *newpage, **spages;\n\tint rc = 0;\n\tsize_t len;\n\tspages = pages;\n\n\tdo {\n\t\tlen = min_t(size_t, PAGE_SIZE, buflen);\n\t\tnewpage = alloc_page(GFP_KERNEL);\n\n\t\tif (newpage == NULL)\n\t\t\tgoto unwind;\n\t\tmemcpy(page_address(newpage), buf, len);\n\t\tbuf += len;\n\t\tbuflen -= len;\n\t\t*pages++ = newpage;\n\t\trc++;\n\t} while (buflen != 0);\n\n\treturn rc;\n\nunwind:\n\tfor(; rc > 0; rc--)\n\t\t__free_page(spages[rc-1]);\n\treturn -ENOMEM;\n}\n\nstruct nfs4_cached_acl {\n\tenum nfs4_acl_type type;\n\tint cached;\n\tsize_t len;\n\tchar data[];\n};\n\nstatic void nfs4_set_cached_acl(struct inode *inode, struct nfs4_cached_acl *acl)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\tspin_lock(&inode->i_lock);\n\tkfree(nfsi->nfs4_acl);\n\tnfsi->nfs4_acl = acl;\n\tspin_unlock(&inode->i_lock);\n}\n\nstatic void nfs4_zap_acl_attr(struct inode *inode)\n{\n\tnfs4_set_cached_acl(inode, NULL);\n}\n\nstatic ssize_t nfs4_read_cached_acl(struct inode *inode, char *buf,\n\t\t\t\t    size_t buflen, enum nfs4_acl_type type)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs4_cached_acl *acl;\n\tint ret = -ENOENT;\n\n\tspin_lock(&inode->i_lock);\n\tacl = nfsi->nfs4_acl;\n\tif (acl == NULL)\n\t\tgoto out;\n\tif (acl->type != type)\n\t\tgoto out;\n\tif (buf == NULL)  \n\t\tgoto out_len;\n\tif (acl->cached == 0)\n\t\tgoto out;\n\tret = -ERANGE;  \n\tif (acl->len > buflen)\n\t\tgoto out;\n\tmemcpy(buf, acl->data, acl->len);\nout_len:\n\tret = acl->len;\nout:\n\tspin_unlock(&inode->i_lock);\n\treturn ret;\n}\n\nstatic void nfs4_write_cached_acl(struct inode *inode, struct page **pages,\n\t\t\t\t  size_t pgbase, size_t acl_len,\n\t\t\t\t  enum nfs4_acl_type type)\n{\n\tstruct nfs4_cached_acl *acl;\n\tsize_t buflen = sizeof(*acl) + acl_len;\n\n\tif (buflen <= PAGE_SIZE) {\n\t\tacl = kmalloc(buflen, GFP_KERNEL);\n\t\tif (acl == NULL)\n\t\t\tgoto out;\n\t\tacl->cached = 1;\n\t\t_copy_from_pages(acl->data, pages, pgbase, acl_len);\n\t} else {\n\t\tacl = kmalloc(sizeof(*acl), GFP_KERNEL);\n\t\tif (acl == NULL)\n\t\t\tgoto out;\n\t\tacl->cached = 0;\n\t}\n\tacl->type = type;\n\tacl->len = acl_len;\nout:\n\tnfs4_set_cached_acl(inode, acl);\n}\n\n \nstatic ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf,\n\t\t\t\t       size_t buflen, enum nfs4_acl_type type)\n{\n\tstruct page **pages;\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_type = type,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_type = type,\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned int npages;\n\tint ret = -ENOMEM, i;\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\n\tif (buflen == 0)\n\t\tbuflen = server->rsize;\n\n\tnpages = DIV_ROUND_UP(buflen, PAGE_SIZE) + 1;\n\tpages = kmalloc_array(npages, sizeof(struct page *), GFP_KERNEL);\n\tif (!pages)\n\t\treturn -ENOMEM;\n\n\targs.acl_pages = pages;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\n\t \n\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\tif (!res.acl_scratch)\n\t\tgoto out_free;\n\n\targs.acl_len = npages * PAGE_SIZE;\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\t \n\tif (res.acl_flags & NFS4_ACL_TRUNC) {\n\t\t \n\t\tif (buf == NULL)\n\t\t\tgoto out_ok;\n\t\tret = -ERANGE;\n\t\tgoto out_free;\n\t}\n\tnfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len,\n\t\t\t      type);\n\tif (buf) {\n\t\tif (res.acl_len > buflen) {\n\t\t\tret = -ERANGE;\n\t\t\tgoto out_free;\n\t\t}\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);\n\t}\nout_ok:\n\tret = res.acl_len;\nout_free:\n\twhile (--i >= 0)\n\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\tkfree(pages);\n\treturn ret;\n}\n\nstatic ssize_t nfs4_get_acl_uncached(struct inode *inode, void *buf,\n\t\t\t\t     size_t buflen, enum nfs4_acl_type type)\n{\n\tstruct nfs4_exception exception = {\n\t\t.interruptible = true,\n\t};\n\tssize_t ret;\n\tdo {\n\t\tret = __nfs4_get_acl_uncached(inode, buf, buflen, type);\n\t\ttrace_nfs4_get_acl(inode, ret);\n\t\tif (ret >= 0)\n\t\t\tbreak;\n\t\tret = nfs4_handle_exception(NFS_SERVER(inode), ret, &exception);\n\t} while (exception.retry);\n\treturn ret;\n}\n\nstatic ssize_t nfs4_proc_get_acl(struct inode *inode, void *buf, size_t buflen,\n\t\t\t\t enum nfs4_acl_type type)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tint ret;\n\n\tif (!nfs4_server_supports_acls(server, type))\n\t\treturn -EOPNOTSUPP;\n\tret = nfs_revalidate_inode(inode, NFS_INO_INVALID_CHANGE);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (NFS_I(inode)->cache_validity & NFS_INO_INVALID_ACL)\n\t\tnfs_zap_acl_cache(inode);\n\tret = nfs4_read_cached_acl(inode, buf, buflen, type);\n\tif (ret != -ENOENT)\n\t\t \n\t\treturn ret;\n\treturn nfs4_get_acl_uncached(inode, buf, buflen, type);\n}\n\nstatic int __nfs4_proc_set_acl(struct inode *inode, const void *buf,\n\t\t\t       size_t buflen, enum nfs4_acl_type type)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct page *pages[NFS4ACL_MAXPAGES];\n\tstruct nfs_setaclargs arg = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_type = type,\n\t\t.acl_len = buflen,\n\t\t.acl_pages = pages,\n\t};\n\tstruct nfs_setaclres res;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs4_procedures[NFSPROC4_CLNT_SETACL],\n\t\t.rpc_argp\t= &arg,\n\t\t.rpc_resp\t= &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret, i;\n\n\t \n\tif (buflen == 0)\n\t\treturn -EINVAL;\n\tif (!nfs4_server_supports_acls(server, type))\n\t\treturn -EOPNOTSUPP;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\ti = nfs4_buf_to_pages_noslab(buf, buflen, arg.acl_pages);\n\tif (i < 0)\n\t\treturn i;\n\tnfs4_inode_make_writeable(inode);\n\tret = nfs4_call_sync(server->client, server, &msg, &arg.seq_args, &res.seq_res, 1);\n\n\t \n\tfor (; i > 0; i--)\n\t\tput_page(pages[i-1]);\n\n\t \n\tspin_lock(&inode->i_lock);\n\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_CHANGE |\n\t\t\t\t\t     NFS_INO_INVALID_CTIME |\n\t\t\t\t\t     NFS_INO_REVAL_FORCED);\n\tspin_unlock(&inode->i_lock);\n\tnfs_access_zap_cache(inode);\n\tnfs_zap_acl_cache(inode);\n\treturn ret;\n}\n\nstatic int nfs4_proc_set_acl(struct inode *inode, const void *buf,\n\t\t\t     size_t buflen, enum nfs4_acl_type type)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = __nfs4_proc_set_acl(inode, buf, buflen, type);\n\t\ttrace_nfs4_set_acl(inode, err);\n\t\tif (err == -NFS4ERR_BADOWNER || err == -NFS4ERR_BADNAME) {\n\t\t\t \n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\terr = nfs4_handle_exception(NFS_SERVER(inode), err,\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\n#ifdef CONFIG_NFS_V4_SECURITY_LABEL\nstatic int _nfs4_get_security_label(struct inode *inode, void *buf,\n\t\t\t\t\tsize_t buflen)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs4_label label = {0, 0, buflen, buf};\n\n\tu32 bitmask[3] = { 0, 0, FATTR4_WORD2_SECURITY_LABEL };\n\tstruct nfs_fattr fattr = {\n\t\t.label = &label,\n\t};\n\tstruct nfs4_getattr_arg arg = {\n\t\t.fh\t\t= NFS_FH(inode),\n\t\t.bitmask\t= bitmask,\n\t};\n\tstruct nfs4_getattr_res res = {\n\t\t.fattr\t\t= &fattr,\n\t\t.server\t\t= server,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs4_procedures[NFSPROC4_CLNT_GETATTR],\n\t\t.rpc_argp\t= &arg,\n\t\t.rpc_resp\t= &res,\n\t};\n\tint ret;\n\n\tnfs_fattr_init(&fattr);\n\n\tret = nfs4_call_sync(server->client, server, &msg, &arg.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\treturn ret;\n\tif (!(fattr.valid & NFS_ATTR_FATTR_V4_SECURITY_LABEL))\n\t\treturn -ENOENT;\n\treturn label.len;\n}\n\nstatic int nfs4_get_security_label(struct inode *inode, void *buf,\n\t\t\t\t\tsize_t buflen)\n{\n\tstruct nfs4_exception exception = {\n\t\t.interruptible = true,\n\t};\n\tint err;\n\n\tif (!nfs_server_capable(inode, NFS_CAP_SECURITY_LABEL))\n\t\treturn -EOPNOTSUPP;\n\n\tdo {\n\t\terr = _nfs4_get_security_label(inode, buf, buflen);\n\t\ttrace_nfs4_get_security_label(inode, err);\n\t\terr = nfs4_handle_exception(NFS_SERVER(inode), err,\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int _nfs4_do_set_security_label(struct inode *inode,\n\t\tstruct nfs4_label *ilabel,\n\t\tstruct nfs_fattr *fattr)\n{\n\n\tstruct iattr sattr = {0};\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tconst u32 bitmask[3] = { 0, 0, FATTR4_WORD2_SECURITY_LABEL };\n\tstruct nfs_setattrargs arg = {\n\t\t.fh\t\t= NFS_FH(inode),\n\t\t.iap\t\t= &sattr,\n\t\t.server\t\t= server,\n\t\t.bitmask\t= bitmask,\n\t\t.label\t\t= ilabel,\n\t};\n\tstruct nfs_setattrres res = {\n\t\t.fattr\t\t= fattr,\n\t\t.server\t\t= server,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs4_procedures[NFSPROC4_CLNT_SETATTR],\n\t\t.rpc_argp\t= &arg,\n\t\t.rpc_resp\t= &res,\n\t};\n\tint status;\n\n\tnfs4_stateid_copy(&arg.stateid, &zero_stateid);\n\n\tstatus = nfs4_call_sync(server->client, server, &msg, &arg.seq_args, &res.seq_res, 1);\n\tif (status)\n\t\tdprintk(\"%s failed: %d\\n\", __func__, status);\n\n\treturn status;\n}\n\nstatic int nfs4_do_set_security_label(struct inode *inode,\n\t\tstruct nfs4_label *ilabel,\n\t\tstruct nfs_fattr *fattr)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\n\tdo {\n\t\terr = _nfs4_do_set_security_label(inode, ilabel, fattr);\n\t\ttrace_nfs4_set_security_label(inode, err);\n\t\terr = nfs4_handle_exception(NFS_SERVER(inode), err,\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int\nnfs4_set_security_label(struct inode *inode, const void *buf, size_t buflen)\n{\n\tstruct nfs4_label ilabel = {0, 0, buflen, (char *)buf };\n\tstruct nfs_fattr *fattr;\n\tint status;\n\n\tif (!nfs_server_capable(inode, NFS_CAP_SECURITY_LABEL))\n\t\treturn -EOPNOTSUPP;\n\n\tfattr = nfs_alloc_fattr_with_label(NFS_SERVER(inode));\n\tif (fattr == NULL)\n\t\treturn -ENOMEM;\n\n\tstatus = nfs4_do_set_security_label(inode, &ilabel, fattr);\n\tif (status == 0)\n\t\tnfs_setsecurity(inode, fattr);\n\n\treturn status;\n}\n#endif\t \n\n\nstatic void nfs4_init_boot_verifier(const struct nfs_client *clp,\n\t\t\t\t    nfs4_verifier *bootverf)\n{\n\t__be32 verf[2];\n\n\tif (test_bit(NFS4CLNT_PURGE_STATE, &clp->cl_state)) {\n\t\t \n\t\tverf[0] = cpu_to_be32(U32_MAX);\n\t\tverf[1] = cpu_to_be32(U32_MAX);\n\t} else {\n\t\tstruct nfs_net *nn = net_generic(clp->cl_net, nfs_net_id);\n\t\tu64 ns = ktime_to_ns(nn->boot_time);\n\n\t\tverf[0] = cpu_to_be32(ns >> 32);\n\t\tverf[1] = cpu_to_be32(ns);\n\t}\n\tmemcpy(bootverf->data, verf, sizeof(bootverf->data));\n}\n\nstatic size_t\nnfs4_get_uniquifier(struct nfs_client *clp, char *buf, size_t buflen)\n{\n\tstruct nfs_net *nn = net_generic(clp->cl_net, nfs_net_id);\n\tstruct nfs_netns_client *nn_clp = nn->nfs_client;\n\tconst char *id;\n\n\tbuf[0] = '\\0';\n\n\tif (nn_clp) {\n\t\trcu_read_lock();\n\t\tid = rcu_dereference(nn_clp->identifier);\n\t\tif (id)\n\t\t\tstrscpy(buf, id, buflen);\n\t\trcu_read_unlock();\n\t}\n\n\tif (nfs4_client_id_uniquifier[0] != '\\0' && buf[0] == '\\0')\n\t\tstrscpy(buf, nfs4_client_id_uniquifier, buflen);\n\n\treturn strlen(buf);\n}\n\nstatic int\nnfs4_init_nonuniform_client_string(struct nfs_client *clp)\n{\n\tchar buf[NFS4_CLIENT_ID_UNIQ_LEN];\n\tsize_t buflen;\n\tsize_t len;\n\tchar *str;\n\n\tif (clp->cl_owner_id != NULL)\n\t\treturn 0;\n\n\trcu_read_lock();\n\tlen = 14 +\n\t\tstrlen(clp->cl_rpcclient->cl_nodename) +\n\t\t1 +\n\t\tstrlen(rpc_peeraddr2str(clp->cl_rpcclient, RPC_DISPLAY_ADDR)) +\n\t\t1;\n\trcu_read_unlock();\n\n\tbuflen = nfs4_get_uniquifier(clp, buf, sizeof(buf));\n\tif (buflen)\n\t\tlen += buflen + 1;\n\n\tif (len > NFS4_OPAQUE_LIMIT + 1)\n\t\treturn -EINVAL;\n\n\t \n\tstr = kmalloc(len, GFP_KERNEL);\n\tif (!str)\n\t\treturn -ENOMEM;\n\n\trcu_read_lock();\n\tif (buflen)\n\t\tscnprintf(str, len, \"Linux NFSv4.0 %s/%s/%s\",\n\t\t\t  clp->cl_rpcclient->cl_nodename, buf,\n\t\t\t  rpc_peeraddr2str(clp->cl_rpcclient,\n\t\t\t\t\t   RPC_DISPLAY_ADDR));\n\telse\n\t\tscnprintf(str, len, \"Linux NFSv4.0 %s/%s\",\n\t\t\t  clp->cl_rpcclient->cl_nodename,\n\t\t\t  rpc_peeraddr2str(clp->cl_rpcclient,\n\t\t\t\t\t   RPC_DISPLAY_ADDR));\n\trcu_read_unlock();\n\n\tclp->cl_owner_id = str;\n\treturn 0;\n}\n\nstatic int\nnfs4_init_uniform_client_string(struct nfs_client *clp)\n{\n\tchar buf[NFS4_CLIENT_ID_UNIQ_LEN];\n\tsize_t buflen;\n\tsize_t len;\n\tchar *str;\n\n\tif (clp->cl_owner_id != NULL)\n\t\treturn 0;\n\n\tlen = 10 + 10 + 1 + 10 + 1 +\n\t\tstrlen(clp->cl_rpcclient->cl_nodename) + 1;\n\n\tbuflen = nfs4_get_uniquifier(clp, buf, sizeof(buf));\n\tif (buflen)\n\t\tlen += buflen + 1;\n\n\tif (len > NFS4_OPAQUE_LIMIT + 1)\n\t\treturn -EINVAL;\n\n\t \n\tstr = kmalloc(len, GFP_KERNEL);\n\tif (!str)\n\t\treturn -ENOMEM;\n\n\tif (buflen)\n\t\tscnprintf(str, len, \"Linux NFSv%u.%u %s/%s\",\n\t\t\t  clp->rpc_ops->version, clp->cl_minorversion,\n\t\t\t  buf, clp->cl_rpcclient->cl_nodename);\n\telse\n\t\tscnprintf(str, len, \"Linux NFSv%u.%u %s\",\n\t\t\t  clp->rpc_ops->version, clp->cl_minorversion,\n\t\t\t  clp->cl_rpcclient->cl_nodename);\n\tclp->cl_owner_id = str;\n\treturn 0;\n}\n\n \nstatic unsigned int\nnfs4_init_callback_netid(const struct nfs_client *clp, char *buf, size_t len)\n{\n\tif (strchr(clp->cl_ipaddr, ':') != NULL)\n\t\treturn scnprintf(buf, len, \"tcp6\");\n\telse\n\t\treturn scnprintf(buf, len, \"tcp\");\n}\n\nstatic void nfs4_setclientid_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_setclientid *sc = calldata;\n\n\tif (task->tk_status == 0)\n\t\tsc->sc_cred = get_rpccred(task->tk_rqstp->rq_cred);\n}\n\nstatic const struct rpc_call_ops nfs4_setclientid_ops = {\n\t.rpc_call_done = nfs4_setclientid_done,\n};\n\n \nint nfs4_proc_setclientid(struct nfs_client *clp, u32 program,\n\t\tunsigned short port, const struct cred *cred,\n\t\tstruct nfs4_setclientid_res *res)\n{\n\tnfs4_verifier sc_verifier;\n\tstruct nfs4_setclientid setclientid = {\n\t\t.sc_verifier = &sc_verifier,\n\t\t.sc_prog = program,\n\t\t.sc_clnt = clp,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_SETCLIENTID],\n\t\t.rpc_argp = &setclientid,\n\t\t.rpc_resp = res,\n\t\t.rpc_cred = cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = clp->cl_rpcclient,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_setclientid_ops,\n\t\t.callback_data = &setclientid,\n\t\t.flags = RPC_TASK_TIMEOUT | RPC_TASK_NO_ROUND_ROBIN,\n\t};\n\tunsigned long now = jiffies;\n\tint status;\n\n\t \n\tnfs4_init_boot_verifier(clp, &sc_verifier);\n\n\tif (test_bit(NFS_CS_MIGRATION, &clp->cl_flags))\n\t\tstatus = nfs4_init_uniform_client_string(clp);\n\telse\n\t\tstatus = nfs4_init_nonuniform_client_string(clp);\n\n\tif (status)\n\t\tgoto out;\n\n\t \n\tsetclientid.sc_netid_len =\n\t\t\t\tnfs4_init_callback_netid(clp,\n\t\t\t\t\t\tsetclientid.sc_netid,\n\t\t\t\t\t\tsizeof(setclientid.sc_netid));\n\tsetclientid.sc_uaddr_len = scnprintf(setclientid.sc_uaddr,\n\t\t\t\tsizeof(setclientid.sc_uaddr), \"%s.%u.%u\",\n\t\t\t\tclp->cl_ipaddr, port >> 8, port & 255);\n\n\tdprintk(\"NFS call  setclientid auth=%s, '%s'\\n\",\n\t\tclp->cl_rpcclient->cl_auth->au_ops->au_name,\n\t\tclp->cl_owner_id);\n\n\tstatus = nfs4_call_sync_custom(&task_setup_data);\n\tif (setclientid.sc_cred) {\n\t\tkfree(clp->cl_acceptor);\n\t\tclp->cl_acceptor = rpcauth_stringify_acceptor(setclientid.sc_cred);\n\t\tput_rpccred(setclientid.sc_cred);\n\t}\n\n\tif (status == 0)\n\t\tdo_renew_lease(clp, now);\nout:\n\ttrace_nfs4_setclientid(clp, status);\n\tdprintk(\"NFS reply setclientid: %d\\n\", status);\n\treturn status;\n}\n\n \nint nfs4_proc_setclientid_confirm(struct nfs_client *clp,\n\t\tstruct nfs4_setclientid_res *arg,\n\t\tconst struct cred *cred)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_SETCLIENTID_CONFIRM],\n\t\t.rpc_argp = arg,\n\t\t.rpc_cred = cred,\n\t};\n\tint status;\n\n\tdprintk(\"NFS call  setclientid_confirm auth=%s, (client ID %llx)\\n\",\n\t\tclp->cl_rpcclient->cl_auth->au_ops->au_name,\n\t\tclp->cl_clientid);\n\tstatus = rpc_call_sync(clp->cl_rpcclient, &msg,\n\t\t\t       RPC_TASK_TIMEOUT | RPC_TASK_NO_ROUND_ROBIN);\n\ttrace_nfs4_setclientid_confirm(clp, status);\n\tdprintk(\"NFS reply setclientid_confirm: %d\\n\", status);\n\treturn status;\n}\n\nstruct nfs4_delegreturndata {\n\tstruct nfs4_delegreturnargs args;\n\tstruct nfs4_delegreturnres res;\n\tstruct nfs_fh fh;\n\tnfs4_stateid stateid;\n\tunsigned long timestamp;\n\tstruct {\n\t\tstruct nfs4_layoutreturn_args arg;\n\t\tstruct nfs4_layoutreturn_res res;\n\t\tstruct nfs4_xdr_opaque_data ld_private;\n\t\tu32 roc_barrier;\n\t\tbool roc;\n\t} lr;\n\tstruct nfs_fattr fattr;\n\tint rpc_status;\n\tstruct inode *inode;\n};\n\nstatic void nfs4_delegreturn_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_delegreturndata *data = calldata;\n\tstruct nfs4_exception exception = {\n\t\t.inode = data->inode,\n\t\t.stateid = &data->stateid,\n\t\t.task_is_privileged = data->args.seq_args.sa_privileged,\n\t};\n\n\tif (!nfs4_sequence_done(task, &data->res.seq_res))\n\t\treturn;\n\n\ttrace_nfs4_delegreturn_exit(&data->args, &data->res, task->tk_status);\n\n\t \n\tif (pnfs_roc_done(task, &data->args.lr_args, &data->res.lr_res,\n\t\t\t  &data->res.lr_ret) == -EAGAIN)\n\t\tgoto out_restart;\n\n\tswitch (task->tk_status) {\n\tcase 0:\n\t\trenew_lease(data->res.server, data->timestamp);\n\t\tbreak;\n\tcase -NFS4ERR_ADMIN_REVOKED:\n\tcase -NFS4ERR_DELEG_REVOKED:\n\tcase -NFS4ERR_EXPIRED:\n\t\tnfs4_free_revoked_stateid(data->res.server,\n\t\t\t\tdata->args.stateid,\n\t\t\t\ttask->tk_msg.rpc_cred);\n\t\tfallthrough;\n\tcase -NFS4ERR_BAD_STATEID:\n\tcase -NFS4ERR_STALE_STATEID:\n\tcase -ETIMEDOUT:\n\t\ttask->tk_status = 0;\n\t\tbreak;\n\tcase -NFS4ERR_OLD_STATEID:\n\t\tif (!nfs4_refresh_delegation_stateid(&data->stateid, data->inode))\n\t\t\tnfs4_stateid_seqid_inc(&data->stateid);\n\t\tif (data->args.bitmask) {\n\t\t\tdata->args.bitmask = NULL;\n\t\t\tdata->res.fattr = NULL;\n\t\t}\n\t\tgoto out_restart;\n\tcase -NFS4ERR_ACCESS:\n\t\tif (data->args.bitmask) {\n\t\t\tdata->args.bitmask = NULL;\n\t\t\tdata->res.fattr = NULL;\n\t\t\tgoto out_restart;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\ttask->tk_status = nfs4_async_handle_exception(task,\n\t\t\t\tdata->res.server, task->tk_status,\n\t\t\t\t&exception);\n\t\tif (exception.retry)\n\t\t\tgoto out_restart;\n\t}\n\tnfs_delegation_mark_returned(data->inode, data->args.stateid);\n\tdata->rpc_status = task->tk_status;\n\treturn;\nout_restart:\n\ttask->tk_status = 0;\n\trpc_restart_call_prepare(task);\n}\n\nstatic void nfs4_delegreturn_release(void *calldata)\n{\n\tstruct nfs4_delegreturndata *data = calldata;\n\tstruct inode *inode = data->inode;\n\n\tif (data->lr.roc)\n\t\tpnfs_roc_release(&data->lr.arg, &data->lr.res,\n\t\t\t\t data->res.lr_ret);\n\tif (inode) {\n\t\tnfs4_fattr_set_prechange(&data->fattr,\n\t\t\t\t\t inode_peek_iversion_raw(inode));\n\t\tnfs_refresh_inode(inode, &data->fattr);\n\t\tnfs_iput_and_deactive(inode);\n\t}\n\tkfree(calldata);\n}\n\nstatic void nfs4_delegreturn_prepare(struct rpc_task *task, void *data)\n{\n\tstruct nfs4_delegreturndata *d_data;\n\tstruct pnfs_layout_hdr *lo;\n\n\td_data = data;\n\n\tif (!d_data->lr.roc && nfs4_wait_on_layoutreturn(d_data->inode, task)) {\n\t\tnfs4_sequence_done(task, &d_data->res.seq_res);\n\t\treturn;\n\t}\n\n\tlo = d_data->args.lr_args ? d_data->args.lr_args->layout : NULL;\n\tif (lo && !pnfs_layout_is_valid(lo)) {\n\t\td_data->args.lr_args = NULL;\n\t\td_data->res.lr_res = NULL;\n\t}\n\n\tnfs4_setup_sequence(d_data->res.server->nfs_client,\n\t\t\t&d_data->args.seq_args,\n\t\t\t&d_data->res.seq_res,\n\t\t\ttask);\n}\n\nstatic const struct rpc_call_ops nfs4_delegreturn_ops = {\n\t.rpc_call_prepare = nfs4_delegreturn_prepare,\n\t.rpc_call_done = nfs4_delegreturn_done,\n\t.rpc_release = nfs4_delegreturn_release,\n};\n\nstatic int _nfs4_proc_delegreturn(struct inode *inode, const struct cred *cred, const nfs4_stateid *stateid, int issync)\n{\n\tstruct nfs4_delegreturndata *data;\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct rpc_task *task;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_DELEGRETURN],\n\t\t.rpc_cred = cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = server->client,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_delegreturn_ops,\n\t\t.flags = RPC_TASK_ASYNC | RPC_TASK_TIMEOUT,\n\t};\n\tint status = 0;\n\n\tif (nfs_server_capable(inode, NFS_CAP_MOVEABLE))\n\t\ttask_setup_data.flags |= RPC_TASK_MOVEABLE;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (data == NULL)\n\t\treturn -ENOMEM;\n\n\tnfs4_state_protect(server->nfs_client,\n\t\t\tNFS_SP4_MACH_CRED_CLEANUP,\n\t\t\t&task_setup_data.rpc_client, &msg);\n\n\tdata->args.fhandle = &data->fh;\n\tdata->args.stateid = &data->stateid;\n\tnfs4_bitmask_set(data->args.bitmask_store,\n\t\t\t server->cache_consistency_bitmask, inode, 0);\n\tdata->args.bitmask = data->args.bitmask_store;\n\tnfs_copy_fh(&data->fh, NFS_FH(inode));\n\tnfs4_stateid_copy(&data->stateid, stateid);\n\tdata->res.fattr = &data->fattr;\n\tdata->res.server = server;\n\tdata->res.lr_ret = -NFS4ERR_NOMATCHING_LAYOUT;\n\tdata->lr.arg.ld_private = &data->lr.ld_private;\n\tnfs_fattr_init(data->res.fattr);\n\tdata->timestamp = jiffies;\n\tdata->rpc_status = 0;\n\tdata->inode = nfs_igrab_and_active(inode);\n\tif (data->inode || issync) {\n\t\tdata->lr.roc = pnfs_roc(inode, &data->lr.arg, &data->lr.res,\n\t\t\t\t\tcred);\n\t\tif (data->lr.roc) {\n\t\t\tdata->args.lr_args = &data->lr.arg;\n\t\t\tdata->res.lr_res = &data->lr.res;\n\t\t}\n\t}\n\n\tif (!data->inode)\n\t\tnfs4_init_sequence(&data->args.seq_args, &data->res.seq_res, 1,\n\t\t\t\t   1);\n\telse\n\t\tnfs4_init_sequence(&data->args.seq_args, &data->res.seq_res, 1,\n\t\t\t\t   0);\n\ttask_setup_data.callback_data = data;\n\tmsg.rpc_argp = &data->args;\n\tmsg.rpc_resp = &data->res;\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tif (!issync)\n\t\tgoto out;\n\tstatus = rpc_wait_for_completion_task(task);\n\tif (status != 0)\n\t\tgoto out;\n\tstatus = data->rpc_status;\nout:\n\trpc_put_task(task);\n\treturn status;\n}\n\nint nfs4_proc_delegreturn(struct inode *inode, const struct cred *cred, const nfs4_stateid *stateid, int issync)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = _nfs4_proc_delegreturn(inode, cred, stateid, issync);\n\t\ttrace_nfs4_delegreturn(inode, stateid, err);\n\t\tswitch (err) {\n\t\t\tcase -NFS4ERR_STALE_STATEID:\n\t\t\tcase -NFS4ERR_EXPIRED:\n\t\t\tcase 0:\n\t\t\t\treturn 0;\n\t\t}\n\t\terr = nfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int _nfs4_proc_getlk(struct nfs4_state *state, int cmd, struct file_lock *request)\n{\n\tstruct inode *inode = state->inode;\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct nfs_lockt_args arg = {\n\t\t.fh = NFS_FH(inode),\n\t\t.fl = request,\n\t};\n\tstruct nfs_lockt_res res = {\n\t\t.denied = request,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs4_procedures[NFSPROC4_CLNT_LOCKT],\n\t\t.rpc_argp\t= &arg,\n\t\t.rpc_resp\t= &res,\n\t\t.rpc_cred\t= state->owner->so_cred,\n\t};\n\tstruct nfs4_lock_state *lsp;\n\tint status;\n\n\targ.lock_owner.clientid = clp->cl_clientid;\n\tstatus = nfs4_set_lock_state(state, request);\n\tif (status != 0)\n\t\tgoto out;\n\tlsp = request->fl_u.nfs4_fl.owner;\n\targ.lock_owner.id = lsp->ls_seqid.owner_id;\n\targ.lock_owner.s_dev = server->s_dev;\n\tstatus = nfs4_call_sync(server->client, server, &msg, &arg.seq_args, &res.seq_res, 1);\n\tswitch (status) {\n\t\tcase 0:\n\t\t\trequest->fl_type = F_UNLCK;\n\t\t\tbreak;\n\t\tcase -NFS4ERR_DENIED:\n\t\t\tstatus = 0;\n\t}\n\trequest->fl_ops->fl_release_private(request);\n\trequest->fl_ops = NULL;\nout:\n\treturn status;\n}\n\nstatic int nfs4_proc_getlk(struct nfs4_state *state, int cmd, struct file_lock *request)\n{\n\tstruct nfs4_exception exception = {\n\t\t.interruptible = true,\n\t};\n\tint err;\n\n\tdo {\n\t\terr = _nfs4_proc_getlk(state, cmd, request);\n\t\ttrace_nfs4_get_lock(request, state, cmd, err);\n\t\terr = nfs4_handle_exception(NFS_SERVER(state->inode), err,\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\n \nstatic bool nfs4_refresh_lock_old_stateid(nfs4_stateid *dst,\n\t\tstruct nfs4_lock_state *lsp)\n{\n\tstruct nfs4_state *state = lsp->ls_state;\n\tbool ret = false;\n\n\tspin_lock(&state->state_lock);\n\tif (!nfs4_stateid_match_other(dst, &lsp->ls_stateid))\n\t\tgoto out;\n\tif (!nfs4_stateid_is_newer(&lsp->ls_stateid, dst))\n\t\tnfs4_stateid_seqid_inc(dst);\n\telse\n\t\tdst->seqid = lsp->ls_stateid.seqid;\n\tret = true;\nout:\n\tspin_unlock(&state->state_lock);\n\treturn ret;\n}\n\nstatic bool nfs4_sync_lock_stateid(nfs4_stateid *dst,\n\t\tstruct nfs4_lock_state *lsp)\n{\n\tstruct nfs4_state *state = lsp->ls_state;\n\tbool ret;\n\n\tspin_lock(&state->state_lock);\n\tret = !nfs4_stateid_match_other(dst, &lsp->ls_stateid);\n\tnfs4_stateid_copy(dst, &lsp->ls_stateid);\n\tspin_unlock(&state->state_lock);\n\treturn ret;\n}\n\nstruct nfs4_unlockdata {\n\tstruct nfs_locku_args arg;\n\tstruct nfs_locku_res res;\n\tstruct nfs4_lock_state *lsp;\n\tstruct nfs_open_context *ctx;\n\tstruct nfs_lock_context *l_ctx;\n\tstruct file_lock fl;\n\tstruct nfs_server *server;\n\tunsigned long timestamp;\n};\n\nstatic struct nfs4_unlockdata *nfs4_alloc_unlockdata(struct file_lock *fl,\n\t\tstruct nfs_open_context *ctx,\n\t\tstruct nfs4_lock_state *lsp,\n\t\tstruct nfs_seqid *seqid)\n{\n\tstruct nfs4_unlockdata *p;\n\tstruct nfs4_state *state = lsp->ls_state;\n\tstruct inode *inode = state->inode;\n\n\tp = kzalloc(sizeof(*p), GFP_KERNEL);\n\tif (p == NULL)\n\t\treturn NULL;\n\tp->arg.fh = NFS_FH(inode);\n\tp->arg.fl = &p->fl;\n\tp->arg.seqid = seqid;\n\tp->res.seqid = seqid;\n\tp->lsp = lsp;\n\t \n\tp->ctx = get_nfs_open_context(ctx);\n\tp->l_ctx = nfs_get_lock_context(ctx);\n\tlocks_init_lock(&p->fl);\n\tlocks_copy_lock(&p->fl, fl);\n\tp->server = NFS_SERVER(inode);\n\tspin_lock(&state->state_lock);\n\tnfs4_stateid_copy(&p->arg.stateid, &lsp->ls_stateid);\n\tspin_unlock(&state->state_lock);\n\treturn p;\n}\n\nstatic void nfs4_locku_release_calldata(void *data)\n{\n\tstruct nfs4_unlockdata *calldata = data;\n\tnfs_free_seqid(calldata->arg.seqid);\n\tnfs4_put_lock_state(calldata->lsp);\n\tnfs_put_lock_context(calldata->l_ctx);\n\tput_nfs_open_context(calldata->ctx);\n\tkfree(calldata);\n}\n\nstatic void nfs4_locku_done(struct rpc_task *task, void *data)\n{\n\tstruct nfs4_unlockdata *calldata = data;\n\tstruct nfs4_exception exception = {\n\t\t.inode = calldata->lsp->ls_state->inode,\n\t\t.stateid = &calldata->arg.stateid,\n\t};\n\n\tif (!nfs4_sequence_done(task, &calldata->res.seq_res))\n\t\treturn;\n\tswitch (task->tk_status) {\n\t\tcase 0:\n\t\t\trenew_lease(calldata->server, calldata->timestamp);\n\t\t\tlocks_lock_inode_wait(calldata->lsp->ls_state->inode, &calldata->fl);\n\t\t\tif (nfs4_update_lock_stateid(calldata->lsp,\n\t\t\t\t\t&calldata->res.stateid))\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\t\tcase -NFS4ERR_ADMIN_REVOKED:\n\t\tcase -NFS4ERR_EXPIRED:\n\t\t\tnfs4_free_revoked_stateid(calldata->server,\n\t\t\t\t\t&calldata->arg.stateid,\n\t\t\t\t\ttask->tk_msg.rpc_cred);\n\t\t\tfallthrough;\n\t\tcase -NFS4ERR_BAD_STATEID:\n\t\tcase -NFS4ERR_STALE_STATEID:\n\t\t\tif (nfs4_sync_lock_stateid(&calldata->arg.stateid,\n\t\t\t\t\t\tcalldata->lsp))\n\t\t\t\trpc_restart_call_prepare(task);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_OLD_STATEID:\n\t\t\tif (nfs4_refresh_lock_old_stateid(&calldata->arg.stateid,\n\t\t\t\t\t\tcalldata->lsp))\n\t\t\t\trpc_restart_call_prepare(task);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttask->tk_status = nfs4_async_handle_exception(task,\n\t\t\t\t\tcalldata->server, task->tk_status,\n\t\t\t\t\t&exception);\n\t\t\tif (exception.retry)\n\t\t\t\trpc_restart_call_prepare(task);\n\t}\n\tnfs_release_seqid(calldata->arg.seqid);\n}\n\nstatic void nfs4_locku_prepare(struct rpc_task *task, void *data)\n{\n\tstruct nfs4_unlockdata *calldata = data;\n\n\tif (test_bit(NFS_CONTEXT_UNLOCK, &calldata->l_ctx->open_context->flags) &&\n\t\tnfs_async_iocounter_wait(task, calldata->l_ctx))\n\t\treturn;\n\n\tif (nfs_wait_on_sequence(calldata->arg.seqid, task) != 0)\n\t\tgoto out_wait;\n\tif (test_bit(NFS_LOCK_INITIALIZED, &calldata->lsp->ls_flags) == 0) {\n\t\t \n\t\tgoto out_no_action;\n\t}\n\tcalldata->timestamp = jiffies;\n\tif (nfs4_setup_sequence(calldata->server->nfs_client,\n\t\t\t\t&calldata->arg.seq_args,\n\t\t\t\t&calldata->res.seq_res,\n\t\t\t\ttask) != 0)\n\t\tnfs_release_seqid(calldata->arg.seqid);\n\treturn;\nout_no_action:\n\ttask->tk_action = NULL;\nout_wait:\n\tnfs4_sequence_done(task, &calldata->res.seq_res);\n}\n\nstatic const struct rpc_call_ops nfs4_locku_ops = {\n\t.rpc_call_prepare = nfs4_locku_prepare,\n\t.rpc_call_done = nfs4_locku_done,\n\t.rpc_release = nfs4_locku_release_calldata,\n};\n\nstatic struct rpc_task *nfs4_do_unlck(struct file_lock *fl,\n\t\tstruct nfs_open_context *ctx,\n\t\tstruct nfs4_lock_state *lsp,\n\t\tstruct nfs_seqid *seqid)\n{\n\tstruct nfs4_unlockdata *data;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LOCKU],\n\t\t.rpc_cred = ctx->cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = NFS_CLIENT(lsp->ls_state->inode),\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_locku_ops,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\n\tif (nfs_server_capable(lsp->ls_state->inode, NFS_CAP_MOVEABLE))\n\t\ttask_setup_data.flags |= RPC_TASK_MOVEABLE;\n\n\tnfs4_state_protect(NFS_SERVER(lsp->ls_state->inode)->nfs_client,\n\t\tNFS_SP4_MACH_CRED_CLEANUP, &task_setup_data.rpc_client, &msg);\n\n\t \n\tfl->fl_type = F_UNLCK;\n\tif (fl->fl_flags & FL_CLOSE)\n\t\tset_bit(NFS_CONTEXT_UNLOCK, &ctx->flags);\n\n\tdata = nfs4_alloc_unlockdata(fl, ctx, lsp, seqid);\n\tif (data == NULL) {\n\t\tnfs_free_seqid(seqid);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tnfs4_init_sequence(&data->arg.seq_args, &data->res.seq_res, 1, 0);\n\tmsg.rpc_argp = &data->arg;\n\tmsg.rpc_resp = &data->res;\n\ttask_setup_data.callback_data = data;\n\treturn rpc_run_task(&task_setup_data);\n}\n\nstatic int nfs4_proc_unlck(struct nfs4_state *state, int cmd, struct file_lock *request)\n{\n\tstruct inode *inode = state->inode;\n\tstruct nfs4_state_owner *sp = state->owner;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs_seqid *seqid;\n\tstruct nfs4_lock_state *lsp;\n\tstruct rpc_task *task;\n\tstruct nfs_seqid *(*alloc_seqid)(struct nfs_seqid_counter *, gfp_t);\n\tint status = 0;\n\tunsigned char fl_flags = request->fl_flags;\n\n\tstatus = nfs4_set_lock_state(state, request);\n\t \n\trequest->fl_flags |= FL_EXISTS;\n\t \n\tmutex_lock(&sp->so_delegreturn_mutex);\n\t \n\tdown_read(&nfsi->rwsem);\n\tif (locks_lock_inode_wait(inode, request) == -ENOENT) {\n\t\tup_read(&nfsi->rwsem);\n\t\tmutex_unlock(&sp->so_delegreturn_mutex);\n\t\tgoto out;\n\t}\n\tlsp = request->fl_u.nfs4_fl.owner;\n\tset_bit(NFS_LOCK_UNLOCKING, &lsp->ls_flags);\n\tup_read(&nfsi->rwsem);\n\tmutex_unlock(&sp->so_delegreturn_mutex);\n\tif (status != 0)\n\t\tgoto out;\n\t \n\tif (test_bit(NFS_LOCK_INITIALIZED, &lsp->ls_flags) == 0)\n\t\tgoto out;\n\talloc_seqid = NFS_SERVER(inode)->nfs_client->cl_mvops->alloc_seqid;\n\tseqid = alloc_seqid(&lsp->ls_seqid, GFP_KERNEL);\n\tstatus = -ENOMEM;\n\tif (IS_ERR(seqid))\n\t\tgoto out;\n\ttask = nfs4_do_unlck(request, nfs_file_open_context(request->fl_file), lsp, seqid);\n\tstatus = PTR_ERR(task);\n\tif (IS_ERR(task))\n\t\tgoto out;\n\tstatus = rpc_wait_for_completion_task(task);\n\trpc_put_task(task);\nout:\n\trequest->fl_flags = fl_flags;\n\ttrace_nfs4_unlock(request, state, F_SETLK, status);\n\treturn status;\n}\n\nstruct nfs4_lockdata {\n\tstruct nfs_lock_args arg;\n\tstruct nfs_lock_res res;\n\tstruct nfs4_lock_state *lsp;\n\tstruct nfs_open_context *ctx;\n\tstruct file_lock fl;\n\tunsigned long timestamp;\n\tint rpc_status;\n\tint cancelled;\n\tstruct nfs_server *server;\n};\n\nstatic struct nfs4_lockdata *nfs4_alloc_lockdata(struct file_lock *fl,\n\t\tstruct nfs_open_context *ctx, struct nfs4_lock_state *lsp,\n\t\tgfp_t gfp_mask)\n{\n\tstruct nfs4_lockdata *p;\n\tstruct inode *inode = lsp->ls_state->inode;\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs_seqid *(*alloc_seqid)(struct nfs_seqid_counter *, gfp_t);\n\n\tp = kzalloc(sizeof(*p), gfp_mask);\n\tif (p == NULL)\n\t\treturn NULL;\n\n\tp->arg.fh = NFS_FH(inode);\n\tp->arg.fl = &p->fl;\n\tp->arg.open_seqid = nfs_alloc_seqid(&lsp->ls_state->owner->so_seqid, gfp_mask);\n\tif (IS_ERR(p->arg.open_seqid))\n\t\tgoto out_free;\n\talloc_seqid = server->nfs_client->cl_mvops->alloc_seqid;\n\tp->arg.lock_seqid = alloc_seqid(&lsp->ls_seqid, gfp_mask);\n\tif (IS_ERR(p->arg.lock_seqid))\n\t\tgoto out_free_seqid;\n\tp->arg.lock_owner.clientid = server->nfs_client->cl_clientid;\n\tp->arg.lock_owner.id = lsp->ls_seqid.owner_id;\n\tp->arg.lock_owner.s_dev = server->s_dev;\n\tp->res.lock_seqid = p->arg.lock_seqid;\n\tp->lsp = lsp;\n\tp->server = server;\n\tp->ctx = get_nfs_open_context(ctx);\n\tlocks_init_lock(&p->fl);\n\tlocks_copy_lock(&p->fl, fl);\n\treturn p;\nout_free_seqid:\n\tnfs_free_seqid(p->arg.open_seqid);\nout_free:\n\tkfree(p);\n\treturn NULL;\n}\n\nstatic void nfs4_lock_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_lockdata *data = calldata;\n\tstruct nfs4_state *state = data->lsp->ls_state;\n\n\tif (nfs_wait_on_sequence(data->arg.lock_seqid, task) != 0)\n\t\tgoto out_wait;\n\t \n\tif (!test_bit(NFS_LOCK_INITIALIZED, &data->lsp->ls_flags)) {\n\t\tif (nfs_wait_on_sequence(data->arg.open_seqid, task) != 0) {\n\t\t\tgoto out_release_lock_seqid;\n\t\t}\n\t\tnfs4_stateid_copy(&data->arg.open_stateid,\n\t\t\t\t&state->open_stateid);\n\t\tdata->arg.new_lock_owner = 1;\n\t\tdata->res.open_seqid = data->arg.open_seqid;\n\t} else {\n\t\tdata->arg.new_lock_owner = 0;\n\t\tnfs4_stateid_copy(&data->arg.lock_stateid,\n\t\t\t\t&data->lsp->ls_stateid);\n\t}\n\tif (!nfs4_valid_open_stateid(state)) {\n\t\tdata->rpc_status = -EBADF;\n\t\ttask->tk_action = NULL;\n\t\tgoto out_release_open_seqid;\n\t}\n\tdata->timestamp = jiffies;\n\tif (nfs4_setup_sequence(data->server->nfs_client,\n\t\t\t\t&data->arg.seq_args,\n\t\t\t\t&data->res.seq_res,\n\t\t\t\ttask) == 0)\n\t\treturn;\nout_release_open_seqid:\n\tnfs_release_seqid(data->arg.open_seqid);\nout_release_lock_seqid:\n\tnfs_release_seqid(data->arg.lock_seqid);\nout_wait:\n\tnfs4_sequence_done(task, &data->res.seq_res);\n\tdprintk(\"%s: ret = %d\\n\", __func__, data->rpc_status);\n}\n\nstatic void nfs4_lock_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_lockdata *data = calldata;\n\tstruct nfs4_lock_state *lsp = data->lsp;\n\n\tif (!nfs4_sequence_done(task, &data->res.seq_res))\n\t\treturn;\n\n\tdata->rpc_status = task->tk_status;\n\tswitch (task->tk_status) {\n\tcase 0:\n\t\trenew_lease(NFS_SERVER(d_inode(data->ctx->dentry)),\n\t\t\t\tdata->timestamp);\n\t\tif (data->arg.new_lock && !data->cancelled) {\n\t\t\tdata->fl.fl_flags &= ~(FL_SLEEP | FL_ACCESS);\n\t\t\tif (locks_lock_inode_wait(lsp->ls_state->inode, &data->fl) < 0)\n\t\t\t\tgoto out_restart;\n\t\t}\n\t\tif (data->arg.new_lock_owner != 0) {\n\t\t\tnfs_confirm_seqid(&lsp->ls_seqid, 0);\n\t\t\tnfs4_stateid_copy(&lsp->ls_stateid, &data->res.stateid);\n\t\t\tset_bit(NFS_LOCK_INITIALIZED, &lsp->ls_flags);\n\t\t} else if (!nfs4_update_lock_stateid(lsp, &data->res.stateid))\n\t\t\tgoto out_restart;\n\t\tbreak;\n\tcase -NFS4ERR_OLD_STATEID:\n\t\tif (data->arg.new_lock_owner != 0 &&\n\t\t\tnfs4_refresh_open_old_stateid(&data->arg.open_stateid,\n\t\t\t\t\tlsp->ls_state))\n\t\t\tgoto out_restart;\n\t\tif (nfs4_refresh_lock_old_stateid(&data->arg.lock_stateid, lsp))\n\t\t\tgoto out_restart;\n\t\tfallthrough;\n\tcase -NFS4ERR_BAD_STATEID:\n\tcase -NFS4ERR_STALE_STATEID:\n\tcase -NFS4ERR_EXPIRED:\n\t\tif (data->arg.new_lock_owner != 0) {\n\t\t\tif (!nfs4_stateid_match(&data->arg.open_stateid,\n\t\t\t\t\t\t&lsp->ls_state->open_stateid))\n\t\t\t\tgoto out_restart;\n\t\t} else if (!nfs4_stateid_match(&data->arg.lock_stateid,\n\t\t\t\t\t\t&lsp->ls_stateid))\n\t\t\t\tgoto out_restart;\n\t}\nout_done:\n\tdprintk(\"%s: ret = %d!\\n\", __func__, data->rpc_status);\n\treturn;\nout_restart:\n\tif (!data->cancelled)\n\t\trpc_restart_call_prepare(task);\n\tgoto out_done;\n}\n\nstatic void nfs4_lock_release(void *calldata)\n{\n\tstruct nfs4_lockdata *data = calldata;\n\n\tnfs_free_seqid(data->arg.open_seqid);\n\tif (data->cancelled && data->rpc_status == 0) {\n\t\tstruct rpc_task *task;\n\t\ttask = nfs4_do_unlck(&data->fl, data->ctx, data->lsp,\n\t\t\t\tdata->arg.lock_seqid);\n\t\tif (!IS_ERR(task))\n\t\t\trpc_put_task_async(task);\n\t\tdprintk(\"%s: cancelling lock!\\n\", __func__);\n\t} else\n\t\tnfs_free_seqid(data->arg.lock_seqid);\n\tnfs4_put_lock_state(data->lsp);\n\tput_nfs_open_context(data->ctx);\n\tkfree(data);\n}\n\nstatic const struct rpc_call_ops nfs4_lock_ops = {\n\t.rpc_call_prepare = nfs4_lock_prepare,\n\t.rpc_call_done = nfs4_lock_done,\n\t.rpc_release = nfs4_lock_release,\n};\n\nstatic void nfs4_handle_setlk_error(struct nfs_server *server, struct nfs4_lock_state *lsp, int new_lock_owner, int error)\n{\n\tswitch (error) {\n\tcase -NFS4ERR_ADMIN_REVOKED:\n\tcase -NFS4ERR_EXPIRED:\n\tcase -NFS4ERR_BAD_STATEID:\n\t\tlsp->ls_seqid.flags &= ~NFS_SEQID_CONFIRMED;\n\t\tif (new_lock_owner != 0 ||\n\t\t   test_bit(NFS_LOCK_INITIALIZED, &lsp->ls_flags) != 0)\n\t\t\tnfs4_schedule_stateid_recovery(server, lsp->ls_state);\n\t\tbreak;\n\tcase -NFS4ERR_STALE_STATEID:\n\t\tlsp->ls_seqid.flags &= ~NFS_SEQID_CONFIRMED;\n\t\tnfs4_schedule_lease_recovery(server->nfs_client);\n\t}\n}\n\nstatic int _nfs4_do_setlk(struct nfs4_state *state, int cmd, struct file_lock *fl, int recovery_type)\n{\n\tstruct nfs4_lockdata *data;\n\tstruct rpc_task *task;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LOCK],\n\t\t.rpc_cred = state->owner->so_cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = NFS_CLIENT(state->inode),\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_lock_ops,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC | RPC_TASK_CRED_NOREF,\n\t};\n\tint ret;\n\n\tif (nfs_server_capable(state->inode, NFS_CAP_MOVEABLE))\n\t\ttask_setup_data.flags |= RPC_TASK_MOVEABLE;\n\n\tdata = nfs4_alloc_lockdata(fl, nfs_file_open_context(fl->fl_file),\n\t\t\t\t   fl->fl_u.nfs4_fl.owner, GFP_KERNEL);\n\tif (data == NULL)\n\t\treturn -ENOMEM;\n\tif (IS_SETLKW(cmd))\n\t\tdata->arg.block = 1;\n\tnfs4_init_sequence(&data->arg.seq_args, &data->res.seq_res, 1,\n\t\t\t\trecovery_type > NFS_LOCK_NEW);\n\tmsg.rpc_argp = &data->arg;\n\tmsg.rpc_resp = &data->res;\n\ttask_setup_data.callback_data = data;\n\tif (recovery_type > NFS_LOCK_NEW) {\n\t\tif (recovery_type == NFS_LOCK_RECLAIM)\n\t\t\tdata->arg.reclaim = NFS_LOCK_RECLAIM;\n\t} else\n\t\tdata->arg.new_lock = 1;\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tret = rpc_wait_for_completion_task(task);\n\tif (ret == 0) {\n\t\tret = data->rpc_status;\n\t\tif (ret)\n\t\t\tnfs4_handle_setlk_error(data->server, data->lsp,\n\t\t\t\t\tdata->arg.new_lock_owner, ret);\n\t} else\n\t\tdata->cancelled = true;\n\ttrace_nfs4_set_lock(fl, state, &data->res.stateid, cmd, ret);\n\trpc_put_task(task);\n\tdprintk(\"%s: ret = %d\\n\", __func__, ret);\n\treturn ret;\n}\n\nstatic int nfs4_lock_reclaim(struct nfs4_state *state, struct file_lock *request)\n{\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tstruct nfs4_exception exception = {\n\t\t.inode = state->inode,\n\t};\n\tint err;\n\n\tdo {\n\t\t \n\t\tif (test_bit(NFS_DELEGATED_STATE, &state->flags) != 0)\n\t\t\treturn 0;\n\t\terr = _nfs4_do_setlk(state, F_SETLK, request, NFS_LOCK_RECLAIM);\n\t\tif (err != -NFS4ERR_DELAY)\n\t\t\tbreak;\n\t\tnfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int nfs4_lock_expired(struct nfs4_state *state, struct file_lock *request)\n{\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tstruct nfs4_exception exception = {\n\t\t.inode = state->inode,\n\t};\n\tint err;\n\n\terr = nfs4_set_lock_state(state, request);\n\tif (err != 0)\n\t\treturn err;\n\tif (!recover_lost_locks) {\n\t\tset_bit(NFS_LOCK_LOST, &request->fl_u.nfs4_fl.owner->ls_flags);\n\t\treturn 0;\n\t}\n\tdo {\n\t\tif (test_bit(NFS_DELEGATED_STATE, &state->flags) != 0)\n\t\t\treturn 0;\n\t\terr = _nfs4_do_setlk(state, F_SETLK, request, NFS_LOCK_EXPIRED);\n\t\tswitch (err) {\n\t\tdefault:\n\t\t\tgoto out;\n\t\tcase -NFS4ERR_GRACE:\n\t\tcase -NFS4ERR_DELAY:\n\t\t\tnfs4_handle_exception(server, err, &exception);\n\t\t\terr = 0;\n\t\t}\n\t} while (exception.retry);\nout:\n\treturn err;\n}\n\n#if defined(CONFIG_NFS_V4_1)\nstatic int nfs41_lock_expired(struct nfs4_state *state, struct file_lock *request)\n{\n\tstruct nfs4_lock_state *lsp;\n\tint status;\n\n\tstatus = nfs4_set_lock_state(state, request);\n\tif (status != 0)\n\t\treturn status;\n\tlsp = request->fl_u.nfs4_fl.owner;\n\tif (test_bit(NFS_LOCK_INITIALIZED, &lsp->ls_flags) ||\n\t    test_bit(NFS_LOCK_LOST, &lsp->ls_flags))\n\t\treturn 0;\n\treturn nfs4_lock_expired(state, request);\n}\n#endif\n\nstatic int _nfs4_proc_setlk(struct nfs4_state *state, int cmd, struct file_lock *request)\n{\n\tstruct nfs_inode *nfsi = NFS_I(state->inode);\n\tstruct nfs4_state_owner *sp = state->owner;\n\tunsigned char fl_flags = request->fl_flags;\n\tint status;\n\n\trequest->fl_flags |= FL_ACCESS;\n\tstatus = locks_lock_inode_wait(state->inode, request);\n\tif (status < 0)\n\t\tgoto out;\n\tmutex_lock(&sp->so_delegreturn_mutex);\n\tdown_read(&nfsi->rwsem);\n\tif (test_bit(NFS_DELEGATED_STATE, &state->flags)) {\n\t\t \n\t\t \n\t\trequest->fl_flags = fl_flags & ~FL_SLEEP;\n\t\tstatus = locks_lock_inode_wait(state->inode, request);\n\t\tup_read(&nfsi->rwsem);\n\t\tmutex_unlock(&sp->so_delegreturn_mutex);\n\t\tgoto out;\n\t}\n\tup_read(&nfsi->rwsem);\n\tmutex_unlock(&sp->so_delegreturn_mutex);\n\tstatus = _nfs4_do_setlk(state, cmd, request, NFS_LOCK_NEW);\nout:\n\trequest->fl_flags = fl_flags;\n\treturn status;\n}\n\nstatic int nfs4_proc_setlk(struct nfs4_state *state, int cmd, struct file_lock *request)\n{\n\tstruct nfs4_exception exception = {\n\t\t.state = state,\n\t\t.inode = state->inode,\n\t\t.interruptible = true,\n\t};\n\tint err;\n\n\tdo {\n\t\terr = _nfs4_proc_setlk(state, cmd, request);\n\t\tif (err == -NFS4ERR_DENIED)\n\t\t\terr = -EAGAIN;\n\t\terr = nfs4_handle_exception(NFS_SERVER(state->inode),\n\t\t\t\terr, &exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\n#define NFS4_LOCK_MINTIMEOUT (1 * HZ)\n#define NFS4_LOCK_MAXTIMEOUT (30 * HZ)\n\nstatic int\nnfs4_retry_setlk_simple(struct nfs4_state *state, int cmd,\n\t\t\tstruct file_lock *request)\n{\n\tint\t\tstatus = -ERESTARTSYS;\n\tunsigned long\ttimeout = NFS4_LOCK_MINTIMEOUT;\n\n\twhile(!signalled()) {\n\t\tstatus = nfs4_proc_setlk(state, cmd, request);\n\t\tif ((status != -EAGAIN) || IS_SETLK(cmd))\n\t\t\tbreak;\n\t\t__set_current_state(TASK_INTERRUPTIBLE|TASK_FREEZABLE);\n\t\tschedule_timeout(timeout);\n\t\ttimeout *= 2;\n\t\ttimeout = min_t(unsigned long, NFS4_LOCK_MAXTIMEOUT, timeout);\n\t\tstatus = -ERESTARTSYS;\n\t}\n\treturn status;\n}\n\n#ifdef CONFIG_NFS_V4_1\nstruct nfs4_lock_waiter {\n\tstruct inode\t\t*inode;\n\tstruct nfs_lowner\towner;\n\twait_queue_entry_t\twait;\n};\n\nstatic int\nnfs4_wake_lock_waiter(wait_queue_entry_t *wait, unsigned int mode, int flags, void *key)\n{\n\tstruct nfs4_lock_waiter\t*waiter\t=\n\t\tcontainer_of(wait, struct nfs4_lock_waiter, wait);\n\n\t \n\tif (key) {\n\t\tstruct cb_notify_lock_args\t*cbnl = key;\n\t\tstruct nfs_lowner\t\t*lowner = &cbnl->cbnl_owner,\n\t\t\t\t\t\t*wowner = &waiter->owner;\n\n\t\t \n\t\tif (lowner->id != wowner->id || lowner->s_dev != wowner->s_dev)\n\t\t\treturn 0;\n\n\t\t \n\t\tif (nfs_compare_fh(NFS_FH(waiter->inode), &cbnl->cbnl_fh))\n\t\t\treturn 0;\n\t}\n\n\treturn woken_wake_function(wait, mode, flags, key);\n}\n\nstatic int\nnfs4_retry_setlk(struct nfs4_state *state, int cmd, struct file_lock *request)\n{\n\tstruct nfs4_lock_state *lsp = request->fl_u.nfs4_fl.owner;\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tstruct nfs_client *clp = server->nfs_client;\n\twait_queue_head_t *q = &clp->cl_lock_waitq;\n\tstruct nfs4_lock_waiter waiter = {\n\t\t.inode = state->inode,\n\t\t.owner = { .clientid = clp->cl_clientid,\n\t\t\t   .id = lsp->ls_seqid.owner_id,\n\t\t\t   .s_dev = server->s_dev },\n\t};\n\tint status;\n\n\t \n\tif (!test_bit(NFS_STATE_MAY_NOTIFY_LOCK, &state->flags))\n\t\treturn nfs4_retry_setlk_simple(state, cmd, request);\n\n\tinit_wait(&waiter.wait);\n\twaiter.wait.func = nfs4_wake_lock_waiter;\n\tadd_wait_queue(q, &waiter.wait);\n\n\tdo {\n\t\tstatus = nfs4_proc_setlk(state, cmd, request);\n\t\tif (status != -EAGAIN || IS_SETLK(cmd))\n\t\t\tbreak;\n\n\t\tstatus = -ERESTARTSYS;\n\t\twait_woken(&waiter.wait, TASK_INTERRUPTIBLE|TASK_FREEZABLE,\n\t\t\t   NFS4_LOCK_MAXTIMEOUT);\n\t} while (!signalled());\n\n\tremove_wait_queue(q, &waiter.wait);\n\n\treturn status;\n}\n#else  \nstatic inline int\nnfs4_retry_setlk(struct nfs4_state *state, int cmd, struct file_lock *request)\n{\n\treturn nfs4_retry_setlk_simple(state, cmd, request);\n}\n#endif\n\nstatic int\nnfs4_proc_lock(struct file *filp, int cmd, struct file_lock *request)\n{\n\tstruct nfs_open_context *ctx;\n\tstruct nfs4_state *state;\n\tint status;\n\n\t \n\tctx = nfs_file_open_context(filp);\n\tstate = ctx->state;\n\n\tif (IS_GETLK(cmd)) {\n\t\tif (state != NULL)\n\t\t\treturn nfs4_proc_getlk(state, F_GETLK, request);\n\t\treturn 0;\n\t}\n\n\tif (!(IS_SETLK(cmd) || IS_SETLKW(cmd)))\n\t\treturn -EINVAL;\n\n\tif (request->fl_type == F_UNLCK) {\n\t\tif (state != NULL)\n\t\t\treturn nfs4_proc_unlck(state, cmd, request);\n\t\treturn 0;\n\t}\n\n\tif (state == NULL)\n\t\treturn -ENOLCK;\n\n\tif ((request->fl_flags & FL_POSIX) &&\n\t    !test_bit(NFS_STATE_POSIX_LOCKS, &state->flags))\n\t\treturn -ENOLCK;\n\n\t \n\tswitch (request->fl_type) {\n\tcase F_RDLCK:\n\t\tif (!(filp->f_mode & FMODE_READ))\n\t\t\treturn -EBADF;\n\t\tbreak;\n\tcase F_WRLCK:\n\t\tif (!(filp->f_mode & FMODE_WRITE))\n\t\t\treturn -EBADF;\n\t}\n\n\tstatus = nfs4_set_lock_state(state, request);\n\tif (status != 0)\n\t\treturn status;\n\n\treturn nfs4_retry_setlk(state, cmd, request);\n}\n\nstatic int nfs4_delete_lease(struct file *file, void **priv)\n{\n\treturn generic_setlease(file, F_UNLCK, NULL, priv);\n}\n\nstatic int nfs4_add_lease(struct file *file, int arg, struct file_lock **lease,\n\t\t\t  void **priv)\n{\n\tstruct inode *inode = file_inode(file);\n\tfmode_t type = arg == F_RDLCK ? FMODE_READ : FMODE_WRITE;\n\tint ret;\n\n\t \n\tif (!nfs4_have_delegation(inode, type))\n\t\treturn -EAGAIN;\n\tret = generic_setlease(file, arg, lease, priv);\n\tif (ret || nfs4_have_delegation(inode, type))\n\t\treturn ret;\n\t \n\tnfs4_delete_lease(file, priv);\n\treturn -EAGAIN;\n}\n\nint nfs4_proc_setlease(struct file *file, int arg, struct file_lock **lease,\n\t\t       void **priv)\n{\n\tswitch (arg) {\n\tcase F_RDLCK:\n\tcase F_WRLCK:\n\t\treturn nfs4_add_lease(file, arg, lease, priv);\n\tcase F_UNLCK:\n\t\treturn nfs4_delete_lease(file, priv);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nint nfs4_lock_delegation_recall(struct file_lock *fl, struct nfs4_state *state, const nfs4_stateid *stateid)\n{\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tint err;\n\n\terr = nfs4_set_lock_state(state, fl);\n\tif (err != 0)\n\t\treturn err;\n\tdo {\n\t\terr = _nfs4_do_setlk(state, F_SETLK, fl, NFS_LOCK_NEW);\n\t\tif (err != -NFS4ERR_DELAY)\n\t\t\tbreak;\n\t\tssleep(1);\n\t} while (err == -NFS4ERR_DELAY);\n\treturn nfs4_handle_delegation_recall_error(server, state, stateid, fl, err);\n}\n\nstruct nfs_release_lockowner_data {\n\tstruct nfs4_lock_state *lsp;\n\tstruct nfs_server *server;\n\tstruct nfs_release_lockowner_args args;\n\tstruct nfs_release_lockowner_res res;\n\tunsigned long timestamp;\n};\n\nstatic void nfs4_release_lockowner_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs_release_lockowner_data *data = calldata;\n\tstruct nfs_server *server = data->server;\n\tnfs4_setup_sequence(server->nfs_client, &data->args.seq_args,\n\t\t\t   &data->res.seq_res, task);\n\tdata->args.lock_owner.clientid = server->nfs_client->cl_clientid;\n\tdata->timestamp = jiffies;\n}\n\nstatic void nfs4_release_lockowner_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs_release_lockowner_data *data = calldata;\n\tstruct nfs_server *server = data->server;\n\n\tnfs40_sequence_done(task, &data->res.seq_res);\n\n\tswitch (task->tk_status) {\n\tcase 0:\n\t\trenew_lease(server, data->timestamp);\n\t\tbreak;\n\tcase -NFS4ERR_STALE_CLIENTID:\n\tcase -NFS4ERR_EXPIRED:\n\t\tnfs4_schedule_lease_recovery(server->nfs_client);\n\t\tbreak;\n\tcase -NFS4ERR_LEASE_MOVED:\n\tcase -NFS4ERR_DELAY:\n\t\tif (nfs4_async_handle_error(task, server,\n\t\t\t\t\t    NULL, NULL) == -EAGAIN)\n\t\t\trpc_restart_call_prepare(task);\n\t}\n}\n\nstatic void nfs4_release_lockowner_release(void *calldata)\n{\n\tstruct nfs_release_lockowner_data *data = calldata;\n\tnfs4_free_lock_state(data->server, data->lsp);\n\tkfree(calldata);\n}\n\nstatic const struct rpc_call_ops nfs4_release_lockowner_ops = {\n\t.rpc_call_prepare = nfs4_release_lockowner_prepare,\n\t.rpc_call_done = nfs4_release_lockowner_done,\n\t.rpc_release = nfs4_release_lockowner_release,\n};\n\nstatic void\nnfs4_release_lockowner(struct nfs_server *server, struct nfs4_lock_state *lsp)\n{\n\tstruct nfs_release_lockowner_data *data;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_RELEASE_LOCKOWNER],\n\t};\n\n\tif (server->nfs_client->cl_mvops->minor_version != 0)\n\t\treturn;\n\n\tdata = kmalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn;\n\tdata->lsp = lsp;\n\tdata->server = server;\n\tdata->args.lock_owner.clientid = server->nfs_client->cl_clientid;\n\tdata->args.lock_owner.id = lsp->ls_seqid.owner_id;\n\tdata->args.lock_owner.s_dev = server->s_dev;\n\n\tmsg.rpc_argp = &data->args;\n\tmsg.rpc_resp = &data->res;\n\tnfs4_init_sequence(&data->args.seq_args, &data->res.seq_res, 0, 0);\n\trpc_call_async(server->client, &msg, 0, &nfs4_release_lockowner_ops, data);\n}\n\n#define XATTR_NAME_NFSV4_ACL \"system.nfs4_acl\"\n\nstatic int nfs4_xattr_set_nfs4_acl(const struct xattr_handler *handler,\n\t\t\t\t   struct mnt_idmap *idmap,\n\t\t\t\t   struct dentry *unused, struct inode *inode,\n\t\t\t\t   const char *key, const void *buf,\n\t\t\t\t   size_t buflen, int flags)\n{\n\treturn nfs4_proc_set_acl(inode, buf, buflen, NFS4ACL_ACL);\n}\n\nstatic int nfs4_xattr_get_nfs4_acl(const struct xattr_handler *handler,\n\t\t\t\t   struct dentry *unused, struct inode *inode,\n\t\t\t\t   const char *key, void *buf, size_t buflen)\n{\n\treturn nfs4_proc_get_acl(inode, buf, buflen, NFS4ACL_ACL);\n}\n\nstatic bool nfs4_xattr_list_nfs4_acl(struct dentry *dentry)\n{\n\treturn nfs4_server_supports_acls(NFS_SB(dentry->d_sb), NFS4ACL_ACL);\n}\n\n#if defined(CONFIG_NFS_V4_1)\n#define XATTR_NAME_NFSV4_DACL \"system.nfs4_dacl\"\n\nstatic int nfs4_xattr_set_nfs4_dacl(const struct xattr_handler *handler,\n\t\t\t\t    struct mnt_idmap *idmap,\n\t\t\t\t    struct dentry *unused, struct inode *inode,\n\t\t\t\t    const char *key, const void *buf,\n\t\t\t\t    size_t buflen, int flags)\n{\n\treturn nfs4_proc_set_acl(inode, buf, buflen, NFS4ACL_DACL);\n}\n\nstatic int nfs4_xattr_get_nfs4_dacl(const struct xattr_handler *handler,\n\t\t\t\t    struct dentry *unused, struct inode *inode,\n\t\t\t\t    const char *key, void *buf, size_t buflen)\n{\n\treturn nfs4_proc_get_acl(inode, buf, buflen, NFS4ACL_DACL);\n}\n\nstatic bool nfs4_xattr_list_nfs4_dacl(struct dentry *dentry)\n{\n\treturn nfs4_server_supports_acls(NFS_SB(dentry->d_sb), NFS4ACL_DACL);\n}\n\n#define XATTR_NAME_NFSV4_SACL \"system.nfs4_sacl\"\n\nstatic int nfs4_xattr_set_nfs4_sacl(const struct xattr_handler *handler,\n\t\t\t\t    struct mnt_idmap *idmap,\n\t\t\t\t    struct dentry *unused, struct inode *inode,\n\t\t\t\t    const char *key, const void *buf,\n\t\t\t\t    size_t buflen, int flags)\n{\n\treturn nfs4_proc_set_acl(inode, buf, buflen, NFS4ACL_SACL);\n}\n\nstatic int nfs4_xattr_get_nfs4_sacl(const struct xattr_handler *handler,\n\t\t\t\t    struct dentry *unused, struct inode *inode,\n\t\t\t\t    const char *key, void *buf, size_t buflen)\n{\n\treturn nfs4_proc_get_acl(inode, buf, buflen, NFS4ACL_SACL);\n}\n\nstatic bool nfs4_xattr_list_nfs4_sacl(struct dentry *dentry)\n{\n\treturn nfs4_server_supports_acls(NFS_SB(dentry->d_sb), NFS4ACL_SACL);\n}\n\n#endif\n\n#ifdef CONFIG_NFS_V4_SECURITY_LABEL\n\nstatic int nfs4_xattr_set_nfs4_label(const struct xattr_handler *handler,\n\t\t\t\t     struct mnt_idmap *idmap,\n\t\t\t\t     struct dentry *unused, struct inode *inode,\n\t\t\t\t     const char *key, const void *buf,\n\t\t\t\t     size_t buflen, int flags)\n{\n\tif (security_ismaclabel(key))\n\t\treturn nfs4_set_security_label(inode, buf, buflen);\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int nfs4_xattr_get_nfs4_label(const struct xattr_handler *handler,\n\t\t\t\t     struct dentry *unused, struct inode *inode,\n\t\t\t\t     const char *key, void *buf, size_t buflen)\n{\n\tif (security_ismaclabel(key))\n\t\treturn nfs4_get_security_label(inode, buf, buflen);\n\treturn -EOPNOTSUPP;\n}\n\nstatic ssize_t\nnfs4_listxattr_nfs4_label(struct inode *inode, char *list, size_t list_len)\n{\n\tint len = 0;\n\n\tif (nfs_server_capable(inode, NFS_CAP_SECURITY_LABEL)) {\n\t\tlen = security_inode_listsecurity(inode, list, list_len);\n\t\tif (len >= 0 && list_len && len > list_len)\n\t\t\treturn -ERANGE;\n\t}\n\treturn len;\n}\n\nstatic const struct xattr_handler nfs4_xattr_nfs4_label_handler = {\n\t.prefix = XATTR_SECURITY_PREFIX,\n\t.get\t= nfs4_xattr_get_nfs4_label,\n\t.set\t= nfs4_xattr_set_nfs4_label,\n};\n\n#else\n\nstatic ssize_t\nnfs4_listxattr_nfs4_label(struct inode *inode, char *list, size_t list_len)\n{\n\treturn 0;\n}\n\n#endif\n\n#ifdef CONFIG_NFS_V4_2\nstatic int nfs4_xattr_set_nfs4_user(const struct xattr_handler *handler,\n\t\t\t\t    struct mnt_idmap *idmap,\n\t\t\t\t    struct dentry *unused, struct inode *inode,\n\t\t\t\t    const char *key, const void *buf,\n\t\t\t\t    size_t buflen, int flags)\n{\n\tu32 mask;\n\tint ret;\n\n\tif (!nfs_server_capable(inode, NFS_CAP_XATTR))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (!nfs_access_get_cached(inode, current_cred(), &mask, true)) {\n\t\tif (!(mask & NFS_ACCESS_XAWRITE))\n\t\t\treturn -EACCES;\n\t}\n\n\tif (buf == NULL) {\n\t\tret = nfs42_proc_removexattr(inode, key);\n\t\tif (!ret)\n\t\t\tnfs4_xattr_cache_remove(inode, key);\n\t} else {\n\t\tret = nfs42_proc_setxattr(inode, key, buf, buflen, flags);\n\t\tif (!ret)\n\t\t\tnfs4_xattr_cache_add(inode, key, buf, NULL, buflen);\n\t}\n\n\treturn ret;\n}\n\nstatic int nfs4_xattr_get_nfs4_user(const struct xattr_handler *handler,\n\t\t\t\t    struct dentry *unused, struct inode *inode,\n\t\t\t\t    const char *key, void *buf, size_t buflen)\n{\n\tu32 mask;\n\tssize_t ret;\n\n\tif (!nfs_server_capable(inode, NFS_CAP_XATTR))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!nfs_access_get_cached(inode, current_cred(), &mask, true)) {\n\t\tif (!(mask & NFS_ACCESS_XAREAD))\n\t\t\treturn -EACCES;\n\t}\n\n\tret = nfs_revalidate_inode(inode, NFS_INO_INVALID_CHANGE);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nfs4_xattr_cache_get(inode, key, buf, buflen);\n\tif (ret >= 0 || (ret < 0 && ret != -ENOENT))\n\t\treturn ret;\n\n\tret = nfs42_proc_getxattr(inode, key, buf, buflen);\n\n\treturn ret;\n}\n\nstatic ssize_t\nnfs4_listxattr_nfs4_user(struct inode *inode, char *list, size_t list_len)\n{\n\tu64 cookie;\n\tbool eof;\n\tssize_t ret, size;\n\tchar *buf;\n\tsize_t buflen;\n\tu32 mask;\n\n\tif (!nfs_server_capable(inode, NFS_CAP_XATTR))\n\t\treturn 0;\n\n\tif (!nfs_access_get_cached(inode, current_cred(), &mask, true)) {\n\t\tif (!(mask & NFS_ACCESS_XALIST))\n\t\t\treturn 0;\n\t}\n\n\tret = nfs_revalidate_inode(inode, NFS_INO_INVALID_CHANGE);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nfs4_xattr_cache_list(inode, list, list_len);\n\tif (ret >= 0 || (ret < 0 && ret != -ENOENT))\n\t\treturn ret;\n\n\tcookie = 0;\n\teof = false;\n\tbuflen = list_len ? list_len : XATTR_LIST_MAX;\n\tbuf = list_len ? list : NULL;\n\tsize = 0;\n\n\twhile (!eof) {\n\t\tret = nfs42_proc_listxattrs(inode, buf, buflen,\n\t\t    &cookie, &eof);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (list_len) {\n\t\t\tbuf += ret;\n\t\t\tbuflen -= ret;\n\t\t}\n\t\tsize += ret;\n\t}\n\n\tif (list_len)\n\t\tnfs4_xattr_cache_set_list(inode, list, size);\n\n\treturn size;\n}\n\n#else\n\nstatic ssize_t\nnfs4_listxattr_nfs4_user(struct inode *inode, char *list, size_t list_len)\n{\n\treturn 0;\n}\n#endif  \n\n \nstatic void nfs_fixup_referral_attributes(struct nfs_fattr *fattr)\n{\n\tif (!(((fattr->valid & NFS_ATTR_FATTR_MOUNTED_ON_FILEID) ||\n\t       (fattr->valid & NFS_ATTR_FATTR_FILEID)) &&\n\t      (fattr->valid & NFS_ATTR_FATTR_FSID) &&\n\t      (fattr->valid & NFS_ATTR_FATTR_V4_LOCATIONS)))\n\t\treturn;\n\n\tfattr->valid |= NFS_ATTR_FATTR_TYPE | NFS_ATTR_FATTR_MODE |\n\t\tNFS_ATTR_FATTR_NLINK | NFS_ATTR_FATTR_V4_REFERRAL;\n\tfattr->mode = S_IFDIR | S_IRUGO | S_IXUGO;\n\tfattr->nlink = 2;\n}\n\nstatic int _nfs4_proc_fs_locations(struct rpc_clnt *client, struct inode *dir,\n\t\t\t\t   const struct qstr *name,\n\t\t\t\t   struct nfs4_fs_locations *fs_locations,\n\t\t\t\t   struct page *page)\n{\n\tstruct nfs_server *server = NFS_SERVER(dir);\n\tu32 bitmask[3];\n\tstruct nfs4_fs_locations_arg args = {\n\t\t.dir_fh = NFS_FH(dir),\n\t\t.name = name,\n\t\t.page = page,\n\t\t.bitmask = bitmask,\n\t};\n\tstruct nfs4_fs_locations_res res = {\n\t\t.fs_locations = fs_locations,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_FS_LOCATIONS],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tint status;\n\n\tdprintk(\"%s: start\\n\", __func__);\n\n\tbitmask[0] = nfs4_fattr_bitmap[0] | FATTR4_WORD0_FS_LOCATIONS;\n\tbitmask[1] = nfs4_fattr_bitmap[1];\n\n\t \n\tif (NFS_SERVER(dir)->attr_bitmask[1] & FATTR4_WORD1_MOUNTED_ON_FILEID)\n\t\tbitmask[0] &= ~FATTR4_WORD0_FILEID;\n\telse\n\t\tbitmask[1] &= ~FATTR4_WORD1_MOUNTED_ON_FILEID;\n\n\tnfs_fattr_init(fs_locations->fattr);\n\tfs_locations->server = server;\n\tfs_locations->nlocations = 0;\n\tstatus = nfs4_call_sync(client, server, &msg, &args.seq_args, &res.seq_res, 0);\n\tdprintk(\"%s: returned status = %d\\n\", __func__, status);\n\treturn status;\n}\n\nint nfs4_proc_fs_locations(struct rpc_clnt *client, struct inode *dir,\n\t\t\t   const struct qstr *name,\n\t\t\t   struct nfs4_fs_locations *fs_locations,\n\t\t\t   struct page *page)\n{\n\tstruct nfs4_exception exception = {\n\t\t.interruptible = true,\n\t};\n\tint err;\n\tdo {\n\t\terr = _nfs4_proc_fs_locations(client, dir, name,\n\t\t\t\tfs_locations, page);\n\t\ttrace_nfs4_get_fs_locations(dir, name, err);\n\t\terr = nfs4_handle_exception(NFS_SERVER(dir), err,\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\n \nstatic int _nfs40_proc_get_locations(struct nfs_server *server,\n\t\t\t\t     struct nfs_fh *fhandle,\n\t\t\t\t     struct nfs4_fs_locations *locations,\n\t\t\t\t     struct page *page, const struct cred *cred)\n{\n\tstruct rpc_clnt *clnt = server->client;\n\tu32 bitmask[2] = {\n\t\t[0] = FATTR4_WORD0_FSID | FATTR4_WORD0_FS_LOCATIONS,\n\t};\n\tstruct nfs4_fs_locations_arg args = {\n\t\t.clientid\t= server->nfs_client->cl_clientid,\n\t\t.fh\t\t= fhandle,\n\t\t.page\t\t= page,\n\t\t.bitmask\t= bitmask,\n\t\t.migration\t= 1,\t\t \n\t\t.renew\t\t= 1,\t\t \n\t};\n\tstruct nfs4_fs_locations_res res = {\n\t\t.fs_locations\t= locations,\n\t\t.migration\t= 1,\n\t\t.renew\t\t= 1,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs4_procedures[NFSPROC4_CLNT_FS_LOCATIONS],\n\t\t.rpc_argp\t= &args,\n\t\t.rpc_resp\t= &res,\n\t\t.rpc_cred\t= cred,\n\t};\n\tunsigned long now = jiffies;\n\tint status;\n\n\tnfs_fattr_init(locations->fattr);\n\tlocations->server = server;\n\tlocations->nlocations = 0;\n\n\tnfs4_init_sequence(&args.seq_args, &res.seq_res, 0, 1);\n\tstatus = nfs4_call_sync_sequence(clnt, server, &msg,\n\t\t\t\t\t&args.seq_args, &res.seq_res);\n\tif (status)\n\t\treturn status;\n\n\trenew_lease(server, now);\n\treturn 0;\n}\n\n#ifdef CONFIG_NFS_V4_1\n\n \nstatic int _nfs41_proc_get_locations(struct nfs_server *server,\n\t\t\t\t     struct nfs_fh *fhandle,\n\t\t\t\t     struct nfs4_fs_locations *locations,\n\t\t\t\t     struct page *page, const struct cred *cred)\n{\n\tstruct rpc_clnt *clnt = server->client;\n\tu32 bitmask[2] = {\n\t\t[0] = FATTR4_WORD0_FSID | FATTR4_WORD0_FS_LOCATIONS,\n\t};\n\tstruct nfs4_fs_locations_arg args = {\n\t\t.fh\t\t= fhandle,\n\t\t.page\t\t= page,\n\t\t.bitmask\t= bitmask,\n\t\t.migration\t= 1,\t\t \n\t};\n\tstruct nfs4_fs_locations_res res = {\n\t\t.fs_locations\t= locations,\n\t\t.migration\t= 1,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs4_procedures[NFSPROC4_CLNT_FS_LOCATIONS],\n\t\t.rpc_argp\t= &args,\n\t\t.rpc_resp\t= &res,\n\t\t.rpc_cred\t= cred,\n\t};\n\tstruct nfs4_call_sync_data data = {\n\t\t.seq_server = server,\n\t\t.seq_args = &args.seq_args,\n\t\t.seq_res = &res.seq_res,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = clnt,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = server->nfs_client->cl_mvops->call_sync_ops,\n\t\t.callback_data = &data,\n\t\t.flags = RPC_TASK_NO_ROUND_ROBIN,\n\t};\n\tint status;\n\n\tnfs_fattr_init(locations->fattr);\n\tlocations->server = server;\n\tlocations->nlocations = 0;\n\n\tnfs4_init_sequence(&args.seq_args, &res.seq_res, 0, 1);\n\tstatus = nfs4_call_sync_custom(&task_setup_data);\n\tif (status == NFS4_OK &&\n\t    res.seq_res.sr_status_flags & SEQ4_STATUS_LEASE_MOVED)\n\t\tstatus = -NFS4ERR_LEASE_MOVED;\n\treturn status;\n}\n\n#endif\t \n\n \nint nfs4_proc_get_locations(struct nfs_server *server,\n\t\t\t    struct nfs_fh *fhandle,\n\t\t\t    struct nfs4_fs_locations *locations,\n\t\t\t    struct page *page, const struct cred *cred)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tconst struct nfs4_mig_recovery_ops *ops =\n\t\t\t\t\tclp->cl_mvops->mig_recovery_ops;\n\tstruct nfs4_exception exception = {\n\t\t.interruptible = true,\n\t};\n\tint status;\n\n\tdprintk(\"%s: FSID %llx:%llx on \\\"%s\\\"\\n\", __func__,\n\t\t(unsigned long long)server->fsid.major,\n\t\t(unsigned long long)server->fsid.minor,\n\t\tclp->cl_hostname);\n\tnfs_display_fhandle(fhandle, __func__);\n\n\tdo {\n\t\tstatus = ops->get_locations(server, fhandle, locations, page,\n\t\t\t\t\t    cred);\n\t\tif (status != -NFS4ERR_DELAY)\n\t\t\tbreak;\n\t\tnfs4_handle_exception(server, status, &exception);\n\t} while (exception.retry);\n\treturn status;\n}\n\n \nstatic int _nfs40_proc_fsid_present(struct inode *inode, const struct cred *cred)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs_client *clp = NFS_SERVER(inode)->nfs_client;\n\tstruct rpc_clnt *clnt = server->client;\n\tstruct nfs4_fsid_present_arg args = {\n\t\t.fh\t\t= NFS_FH(inode),\n\t\t.clientid\t= clp->cl_clientid,\n\t\t.renew\t\t= 1,\t\t \n\t};\n\tstruct nfs4_fsid_present_res res = {\n\t\t.renew\t\t= 1,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs4_procedures[NFSPROC4_CLNT_FSID_PRESENT],\n\t\t.rpc_argp\t= &args,\n\t\t.rpc_resp\t= &res,\n\t\t.rpc_cred\t= cred,\n\t};\n\tunsigned long now = jiffies;\n\tint status;\n\n\tres.fh = nfs_alloc_fhandle();\n\tif (res.fh == NULL)\n\t\treturn -ENOMEM;\n\n\tnfs4_init_sequence(&args.seq_args, &res.seq_res, 0, 1);\n\tstatus = nfs4_call_sync_sequence(clnt, server, &msg,\n\t\t\t\t\t\t&args.seq_args, &res.seq_res);\n\tnfs_free_fhandle(res.fh);\n\tif (status)\n\t\treturn status;\n\n\tdo_renew_lease(clp, now);\n\treturn 0;\n}\n\n#ifdef CONFIG_NFS_V4_1\n\n \nstatic int _nfs41_proc_fsid_present(struct inode *inode, const struct cred *cred)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct rpc_clnt *clnt = server->client;\n\tstruct nfs4_fsid_present_arg args = {\n\t\t.fh\t\t= NFS_FH(inode),\n\t};\n\tstruct nfs4_fsid_present_res res = {\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs4_procedures[NFSPROC4_CLNT_FSID_PRESENT],\n\t\t.rpc_argp\t= &args,\n\t\t.rpc_resp\t= &res,\n\t\t.rpc_cred\t= cred,\n\t};\n\tint status;\n\n\tres.fh = nfs_alloc_fhandle();\n\tif (res.fh == NULL)\n\t\treturn -ENOMEM;\n\n\tnfs4_init_sequence(&args.seq_args, &res.seq_res, 0, 1);\n\tstatus = nfs4_call_sync_sequence(clnt, server, &msg,\n\t\t\t\t\t\t&args.seq_args, &res.seq_res);\n\tnfs_free_fhandle(res.fh);\n\tif (status == NFS4_OK &&\n\t    res.seq_res.sr_status_flags & SEQ4_STATUS_LEASE_MOVED)\n\t\tstatus = -NFS4ERR_LEASE_MOVED;\n\treturn status;\n}\n\n#endif\t \n\n \nint nfs4_proc_fsid_present(struct inode *inode, const struct cred *cred)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs_client *clp = server->nfs_client;\n\tconst struct nfs4_mig_recovery_ops *ops =\n\t\t\t\t\tclp->cl_mvops->mig_recovery_ops;\n\tstruct nfs4_exception exception = {\n\t\t.interruptible = true,\n\t};\n\tint status;\n\n\tdprintk(\"%s: FSID %llx:%llx on \\\"%s\\\"\\n\", __func__,\n\t\t(unsigned long long)server->fsid.major,\n\t\t(unsigned long long)server->fsid.minor,\n\t\tclp->cl_hostname);\n\tnfs_display_fhandle(NFS_FH(inode), __func__);\n\n\tdo {\n\t\tstatus = ops->fsid_present(inode, cred);\n\t\tif (status != -NFS4ERR_DELAY)\n\t\t\tbreak;\n\t\tnfs4_handle_exception(server, status, &exception);\n\t} while (exception.retry);\n\treturn status;\n}\n\n \nstatic int _nfs4_proc_secinfo(struct inode *dir, const struct qstr *name, struct nfs4_secinfo_flavors *flavors, bool use_integrity)\n{\n\tint status;\n\tstruct rpc_clnt *clnt = NFS_SERVER(dir)->client;\n\tstruct nfs_client *clp = NFS_SERVER(dir)->nfs_client;\n\tstruct nfs4_secinfo_arg args = {\n\t\t.dir_fh = NFS_FH(dir),\n\t\t.name   = name,\n\t};\n\tstruct nfs4_secinfo_res res = {\n\t\t.flavors     = flavors,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_SECINFO],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tstruct nfs4_call_sync_data data = {\n\t\t.seq_server = NFS_SERVER(dir),\n\t\t.seq_args = &args.seq_args,\n\t\t.seq_res = &res.seq_res,\n\t};\n\tstruct rpc_task_setup task_setup = {\n\t\t.rpc_client = clnt,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = clp->cl_mvops->call_sync_ops,\n\t\t.callback_data = &data,\n\t\t.flags = RPC_TASK_NO_ROUND_ROBIN,\n\t};\n\tconst struct cred *cred = NULL;\n\n\tif (use_integrity) {\n\t\tclnt = clp->cl_rpcclient;\n\t\ttask_setup.rpc_client = clnt;\n\n\t\tcred = nfs4_get_clid_cred(clp);\n\t\tmsg.rpc_cred = cred;\n\t}\n\n\tdprintk(\"NFS call  secinfo %s\\n\", name->name);\n\n\tnfs4_state_protect(clp, NFS_SP4_MACH_CRED_SECINFO, &clnt, &msg);\n\tnfs4_init_sequence(&args.seq_args, &res.seq_res, 0, 0);\n\tstatus = nfs4_call_sync_custom(&task_setup);\n\n\tdprintk(\"NFS reply  secinfo: %d\\n\", status);\n\n\tput_cred(cred);\n\treturn status;\n}\n\nint nfs4_proc_secinfo(struct inode *dir, const struct qstr *name,\n\t\t      struct nfs4_secinfo_flavors *flavors)\n{\n\tstruct nfs4_exception exception = {\n\t\t.interruptible = true,\n\t};\n\tint err;\n\tdo {\n\t\terr = -NFS4ERR_WRONGSEC;\n\n\t\t \n\t\tif (_nfs4_is_integrity_protected(NFS_SERVER(dir)->nfs_client))\n\t\t\terr = _nfs4_proc_secinfo(dir, name, flavors, true);\n\n\t\t \n\t\tif (err == -NFS4ERR_WRONGSEC)\n\t\t\terr = _nfs4_proc_secinfo(dir, name, flavors, false);\n\n\t\ttrace_nfs4_secinfo(dir, name, err);\n\t\terr = nfs4_handle_exception(NFS_SERVER(dir), err,\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\n#ifdef CONFIG_NFS_V4_1\n \nstatic int nfs4_check_cl_exchange_flags(u32 flags, u32 version)\n{\n\tif (version >= 2 && (flags & ~EXCHGID4_2_FLAG_MASK_R))\n\t\tgoto out_inval;\n\telse if (version < 2 && (flags & ~EXCHGID4_FLAG_MASK_R))\n\t\tgoto out_inval;\n\tif ((flags & EXCHGID4_FLAG_USE_PNFS_MDS) &&\n\t    (flags & EXCHGID4_FLAG_USE_NON_PNFS))\n\t\tgoto out_inval;\n\tif (!(flags & (EXCHGID4_FLAG_MASK_PNFS)))\n\t\tgoto out_inval;\n\treturn NFS_OK;\nout_inval:\n\treturn -NFS4ERR_INVAL;\n}\n\nstatic bool\nnfs41_same_server_scope(struct nfs41_server_scope *a,\n\t\t\tstruct nfs41_server_scope *b)\n{\n\tif (a->server_scope_sz != b->server_scope_sz)\n\t\treturn false;\n\treturn memcmp(a->server_scope, b->server_scope, a->server_scope_sz) == 0;\n}\n\nstatic void\nnfs4_bind_one_conn_to_session_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs41_bind_conn_to_session_args *args = task->tk_msg.rpc_argp;\n\tstruct nfs41_bind_conn_to_session_res *res = task->tk_msg.rpc_resp;\n\tstruct nfs_client *clp = args->client;\n\n\tswitch (task->tk_status) {\n\tcase -NFS4ERR_BADSESSION:\n\tcase -NFS4ERR_DEADSESSION:\n\t\tnfs4_schedule_session_recovery(clp->cl_session,\n\t\t\t\ttask->tk_status);\n\t\treturn;\n\t}\n\tif (args->dir == NFS4_CDFC4_FORE_OR_BOTH &&\n\t\t\tres->dir != NFS4_CDFS4_BOTH) {\n\t\trpc_task_close_connection(task);\n\t\tif (args->retries++ < MAX_BIND_CONN_TO_SESSION_RETRIES)\n\t\t\trpc_restart_call(task);\n\t}\n}\n\nstatic const struct rpc_call_ops nfs4_bind_one_conn_to_session_ops = {\n\t.rpc_call_done =  nfs4_bind_one_conn_to_session_done,\n};\n\n \nstatic\nint nfs4_proc_bind_one_conn_to_session(struct rpc_clnt *clnt,\n\t\tstruct rpc_xprt *xprt,\n\t\tstruct nfs_client *clp,\n\t\tconst struct cred *cred)\n{\n\tint status;\n\tstruct nfs41_bind_conn_to_session_args args = {\n\t\t.client = clp,\n\t\t.dir = NFS4_CDFC4_FORE_OR_BOTH,\n\t\t.retries = 0,\n\t};\n\tstruct nfs41_bind_conn_to_session_res res;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc =\n\t\t\t&nfs4_procedures[NFSPROC4_CLNT_BIND_CONN_TO_SESSION],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t\t.rpc_cred = cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = clnt,\n\t\t.rpc_xprt = xprt,\n\t\t.callback_ops = &nfs4_bind_one_conn_to_session_ops,\n\t\t.rpc_message = &msg,\n\t\t.flags = RPC_TASK_TIMEOUT,\n\t};\n\tstruct rpc_task *task;\n\n\tnfs4_copy_sessionid(&args.sessionid, &clp->cl_session->sess_id);\n\tif (!(clp->cl_session->flags & SESSION4_BACK_CHAN))\n\t\targs.dir = NFS4_CDFC4_FORE;\n\n\t \n\tif (xprt != rcu_access_pointer(clnt->cl_xprt))\n\t\targs.dir = NFS4_CDFC4_FORE;\n\n\ttask = rpc_run_task(&task_setup_data);\n\tif (!IS_ERR(task)) {\n\t\tstatus = task->tk_status;\n\t\trpc_put_task(task);\n\t} else\n\t\tstatus = PTR_ERR(task);\n\ttrace_nfs4_bind_conn_to_session(clp, status);\n\tif (status == 0) {\n\t\tif (memcmp(res.sessionid.data,\n\t\t    clp->cl_session->sess_id.data, NFS4_MAX_SESSIONID_LEN)) {\n\t\t\tdprintk(\"NFS: %s: Session ID mismatch\\n\", __func__);\n\t\t\treturn -EIO;\n\t\t}\n\t\tif ((res.dir & args.dir) != res.dir || res.dir == 0) {\n\t\t\tdprintk(\"NFS: %s: Unexpected direction from server\\n\",\n\t\t\t\t__func__);\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (res.use_conn_in_rdma_mode != args.use_conn_in_rdma_mode) {\n\t\t\tdprintk(\"NFS: %s: Server returned RDMA mode = true\\n\",\n\t\t\t\t__func__);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\treturn status;\n}\n\nstruct rpc_bind_conn_calldata {\n\tstruct nfs_client *clp;\n\tconst struct cred *cred;\n};\n\nstatic int\nnfs4_proc_bind_conn_to_session_callback(struct rpc_clnt *clnt,\n\t\tstruct rpc_xprt *xprt,\n\t\tvoid *calldata)\n{\n\tstruct rpc_bind_conn_calldata *p = calldata;\n\n\treturn nfs4_proc_bind_one_conn_to_session(clnt, xprt, p->clp, p->cred);\n}\n\nint nfs4_proc_bind_conn_to_session(struct nfs_client *clp, const struct cred *cred)\n{\n\tstruct rpc_bind_conn_calldata data = {\n\t\t.clp = clp,\n\t\t.cred = cred,\n\t};\n\treturn rpc_clnt_iterate_for_each_xprt(clp->cl_rpcclient,\n\t\t\tnfs4_proc_bind_conn_to_session_callback, &data);\n}\n\n \nstatic const struct nfs41_state_protection nfs4_sp4_mach_cred_request = {\n\t.how = SP4_MACH_CRED,\n\t.enforce.u.words = {\n\t\t[1] = 1 << (OP_BIND_CONN_TO_SESSION - 32) |\n\t\t      1 << (OP_EXCHANGE_ID - 32) |\n\t\t      1 << (OP_CREATE_SESSION - 32) |\n\t\t      1 << (OP_DESTROY_SESSION - 32) |\n\t\t      1 << (OP_DESTROY_CLIENTID - 32)\n\t},\n\t.allow.u.words = {\n\t\t[0] = 1 << (OP_CLOSE) |\n\t\t      1 << (OP_OPEN_DOWNGRADE) |\n\t\t      1 << (OP_LOCKU) |\n\t\t      1 << (OP_DELEGRETURN) |\n\t\t      1 << (OP_COMMIT),\n\t\t[1] = 1 << (OP_SECINFO - 32) |\n\t\t      1 << (OP_SECINFO_NO_NAME - 32) |\n\t\t      1 << (OP_LAYOUTRETURN - 32) |\n\t\t      1 << (OP_TEST_STATEID - 32) |\n\t\t      1 << (OP_FREE_STATEID - 32) |\n\t\t      1 << (OP_WRITE - 32)\n\t}\n};\n\n \nstatic int nfs4_sp4_select_mode(struct nfs_client *clp,\n\t\t\t\t struct nfs41_state_protection *sp)\n{\n\tstatic const u32 supported_enforce[NFS4_OP_MAP_NUM_WORDS] = {\n\t\t[1] = 1 << (OP_BIND_CONN_TO_SESSION - 32) |\n\t\t      1 << (OP_EXCHANGE_ID - 32) |\n\t\t      1 << (OP_CREATE_SESSION - 32) |\n\t\t      1 << (OP_DESTROY_SESSION - 32) |\n\t\t      1 << (OP_DESTROY_CLIENTID - 32)\n\t};\n\tunsigned long flags = 0;\n\tunsigned int i;\n\tint ret = 0;\n\n\tif (sp->how == SP4_MACH_CRED) {\n\t\t \n\t\tdfprintk(MOUNT, \"Server SP4_MACH_CRED support:\\n\");\n\t\tfor (i = 0; i <= LAST_NFS4_OP; i++) {\n\t\t\tif (test_bit(i, sp->enforce.u.longs))\n\t\t\t\tdfprintk(MOUNT, \"  enforce op %d\\n\", i);\n\t\t\tif (test_bit(i, sp->allow.u.longs))\n\t\t\t\tdfprintk(MOUNT, \"  allow op %d\\n\", i);\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < NFS4_OP_MAP_NUM_WORDS; i++) {\n\t\t\tif (sp->enforce.u.words[i] & ~supported_enforce[i]) {\n\t\t\t\tdfprintk(MOUNT, \"sp4_mach_cred: disabled\\n\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (test_bit(OP_BIND_CONN_TO_SESSION, sp->enforce.u.longs) &&\n\t\t    test_bit(OP_CREATE_SESSION, sp->enforce.u.longs) &&\n\t\t    test_bit(OP_DESTROY_SESSION, sp->enforce.u.longs) &&\n\t\t    test_bit(OP_DESTROY_CLIENTID, sp->enforce.u.longs)) {\n\t\t\tdfprintk(MOUNT, \"sp4_mach_cred:\\n\");\n\t\t\tdfprintk(MOUNT, \"  minimal mode enabled\\n\");\n\t\t\t__set_bit(NFS_SP4_MACH_CRED_MINIMAL, &flags);\n\t\t} else {\n\t\t\tdfprintk(MOUNT, \"sp4_mach_cred: disabled\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (test_bit(OP_CLOSE, sp->allow.u.longs) &&\n\t\t    test_bit(OP_OPEN_DOWNGRADE, sp->allow.u.longs) &&\n\t\t    test_bit(OP_DELEGRETURN, sp->allow.u.longs) &&\n\t\t    test_bit(OP_LOCKU, sp->allow.u.longs)) {\n\t\t\tdfprintk(MOUNT, \"  cleanup mode enabled\\n\");\n\t\t\t__set_bit(NFS_SP4_MACH_CRED_CLEANUP, &flags);\n\t\t}\n\n\t\tif (test_bit(OP_LAYOUTRETURN, sp->allow.u.longs)) {\n\t\t\tdfprintk(MOUNT, \"  pnfs cleanup mode enabled\\n\");\n\t\t\t__set_bit(NFS_SP4_MACH_CRED_PNFS_CLEANUP, &flags);\n\t\t}\n\n\t\tif (test_bit(OP_SECINFO, sp->allow.u.longs) &&\n\t\t    test_bit(OP_SECINFO_NO_NAME, sp->allow.u.longs)) {\n\t\t\tdfprintk(MOUNT, \"  secinfo mode enabled\\n\");\n\t\t\t__set_bit(NFS_SP4_MACH_CRED_SECINFO, &flags);\n\t\t}\n\n\t\tif (test_bit(OP_TEST_STATEID, sp->allow.u.longs) &&\n\t\t    test_bit(OP_FREE_STATEID, sp->allow.u.longs)) {\n\t\t\tdfprintk(MOUNT, \"  stateid mode enabled\\n\");\n\t\t\t__set_bit(NFS_SP4_MACH_CRED_STATEID, &flags);\n\t\t}\n\n\t\tif (test_bit(OP_WRITE, sp->allow.u.longs)) {\n\t\t\tdfprintk(MOUNT, \"  write mode enabled\\n\");\n\t\t\t__set_bit(NFS_SP4_MACH_CRED_WRITE, &flags);\n\t\t}\n\n\t\tif (test_bit(OP_COMMIT, sp->allow.u.longs)) {\n\t\t\tdfprintk(MOUNT, \"  commit mode enabled\\n\");\n\t\t\t__set_bit(NFS_SP4_MACH_CRED_COMMIT, &flags);\n\t\t}\n\t}\nout:\n\tclp->cl_sp4_flags = flags;\n\treturn ret;\n}\n\nstruct nfs41_exchange_id_data {\n\tstruct nfs41_exchange_id_res res;\n\tstruct nfs41_exchange_id_args args;\n};\n\nstatic void nfs4_exchange_id_release(void *data)\n{\n\tstruct nfs41_exchange_id_data *cdata =\n\t\t\t\t\t(struct nfs41_exchange_id_data *)data;\n\n\tnfs_put_client(cdata->args.client);\n\tkfree(cdata->res.impl_id);\n\tkfree(cdata->res.server_scope);\n\tkfree(cdata->res.server_owner);\n\tkfree(cdata);\n}\n\nstatic const struct rpc_call_ops nfs4_exchange_id_call_ops = {\n\t.rpc_release = nfs4_exchange_id_release,\n};\n\n \nstatic struct rpc_task *\nnfs4_run_exchange_id(struct nfs_client *clp, const struct cred *cred,\n\t\t\tu32 sp4_how, struct rpc_xprt *xprt)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_EXCHANGE_ID],\n\t\t.rpc_cred = cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = clp->cl_rpcclient,\n\t\t.callback_ops = &nfs4_exchange_id_call_ops,\n\t\t.rpc_message = &msg,\n\t\t.flags = RPC_TASK_TIMEOUT | RPC_TASK_NO_ROUND_ROBIN,\n\t};\n\tstruct nfs41_exchange_id_data *calldata;\n\tint status;\n\n\tif (!refcount_inc_not_zero(&clp->cl_count))\n\t\treturn ERR_PTR(-EIO);\n\n\tstatus = -ENOMEM;\n\tcalldata = kzalloc(sizeof(*calldata), GFP_NOFS);\n\tif (!calldata)\n\t\tgoto out;\n\n\tnfs4_init_boot_verifier(clp, &calldata->args.verifier);\n\n\tstatus = nfs4_init_uniform_client_string(clp);\n\tif (status)\n\t\tgoto out_calldata;\n\n\tcalldata->res.server_owner = kzalloc(sizeof(struct nfs41_server_owner),\n\t\t\t\t\t\tGFP_NOFS);\n\tstatus = -ENOMEM;\n\tif (unlikely(calldata->res.server_owner == NULL))\n\t\tgoto out_calldata;\n\n\tcalldata->res.server_scope = kzalloc(sizeof(struct nfs41_server_scope),\n\t\t\t\t\tGFP_NOFS);\n\tif (unlikely(calldata->res.server_scope == NULL))\n\t\tgoto out_server_owner;\n\n\tcalldata->res.impl_id = kzalloc(sizeof(struct nfs41_impl_id), GFP_NOFS);\n\tif (unlikely(calldata->res.impl_id == NULL))\n\t\tgoto out_server_scope;\n\n\tswitch (sp4_how) {\n\tcase SP4_NONE:\n\t\tcalldata->args.state_protect.how = SP4_NONE;\n\t\tbreak;\n\n\tcase SP4_MACH_CRED:\n\t\tcalldata->args.state_protect = nfs4_sp4_mach_cred_request;\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tWARN_ON_ONCE(1);\n\t\tstatus = -EINVAL;\n\t\tgoto out_impl_id;\n\t}\n\tif (xprt) {\n\t\ttask_setup_data.rpc_xprt = xprt;\n\t\ttask_setup_data.flags |= RPC_TASK_SOFTCONN;\n\t\tmemcpy(calldata->args.verifier.data, clp->cl_confirm.data,\n\t\t\t\tsizeof(calldata->args.verifier.data));\n\t}\n\tcalldata->args.client = clp;\n\tcalldata->args.flags = EXCHGID4_FLAG_SUPP_MOVED_REFER |\n\tEXCHGID4_FLAG_BIND_PRINC_STATEID;\n#ifdef CONFIG_NFS_V4_1_MIGRATION\n\tcalldata->args.flags |= EXCHGID4_FLAG_SUPP_MOVED_MIGR;\n#endif\n\tif (test_bit(NFS_CS_DS, &clp->cl_flags))\n\t\tcalldata->args.flags |= EXCHGID4_FLAG_USE_PNFS_DS;\n\tmsg.rpc_argp = &calldata->args;\n\tmsg.rpc_resp = &calldata->res;\n\ttask_setup_data.callback_data = calldata;\n\n\treturn rpc_run_task(&task_setup_data);\n\nout_impl_id:\n\tkfree(calldata->res.impl_id);\nout_server_scope:\n\tkfree(calldata->res.server_scope);\nout_server_owner:\n\tkfree(calldata->res.server_owner);\nout_calldata:\n\tkfree(calldata);\nout:\n\tnfs_put_client(clp);\n\treturn ERR_PTR(status);\n}\n\n \nstatic int _nfs4_proc_exchange_id(struct nfs_client *clp, const struct cred *cred,\n\t\t\tu32 sp4_how)\n{\n\tstruct rpc_task *task;\n\tstruct nfs41_exchange_id_args *argp;\n\tstruct nfs41_exchange_id_res *resp;\n\tunsigned long now = jiffies;\n\tint status;\n\n\ttask = nfs4_run_exchange_id(clp, cred, sp4_how, NULL);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\n\targp = task->tk_msg.rpc_argp;\n\tresp = task->tk_msg.rpc_resp;\n\tstatus = task->tk_status;\n\tif (status  != 0)\n\t\tgoto out;\n\n\tstatus = nfs4_check_cl_exchange_flags(resp->flags,\n\t\t\tclp->cl_mvops->minor_version);\n\tif (status  != 0)\n\t\tgoto out;\n\n\tstatus = nfs4_sp4_select_mode(clp, &resp->state_protect);\n\tif (status != 0)\n\t\tgoto out;\n\n\tdo_renew_lease(clp, now);\n\n\tclp->cl_clientid = resp->clientid;\n\tclp->cl_exchange_flags = resp->flags;\n\tclp->cl_seqid = resp->seqid;\n\t \n\tif (!(resp->flags & EXCHGID4_FLAG_CONFIRMED_R))\n\t\tclear_bit(NFS4_SESSION_ESTABLISHED,\n\t\t\t  &clp->cl_session->session_state);\n\n\tif (clp->cl_serverscope != NULL &&\n\t    !nfs41_same_server_scope(clp->cl_serverscope,\n\t\t\t\tresp->server_scope)) {\n\t\tdprintk(\"%s: server_scope mismatch detected\\n\",\n\t\t\t__func__);\n\t\tset_bit(NFS4CLNT_SERVER_SCOPE_MISMATCH, &clp->cl_state);\n\t}\n\n\tswap(clp->cl_serverowner, resp->server_owner);\n\tswap(clp->cl_serverscope, resp->server_scope);\n\tswap(clp->cl_implid, resp->impl_id);\n\n\t \n\tmemcpy(clp->cl_confirm.data, argp->verifier.data,\n\t       sizeof(clp->cl_confirm.data));\nout:\n\ttrace_nfs4_exchange_id(clp, status);\n\trpc_put_task(task);\n\treturn status;\n}\n\n \nint nfs4_proc_exchange_id(struct nfs_client *clp, const struct cred *cred)\n{\n\trpc_authflavor_t authflavor = clp->cl_rpcclient->cl_auth->au_flavor;\n\tint status;\n\n\t \n\tif (authflavor == RPC_AUTH_GSS_KRB5I ||\n\t    authflavor == RPC_AUTH_GSS_KRB5P) {\n\t\tstatus = _nfs4_proc_exchange_id(clp, cred, SP4_MACH_CRED);\n\t\tif (!status)\n\t\t\treturn 0;\n\t}\n\n\t \n\treturn _nfs4_proc_exchange_id(clp, cred, SP4_NONE);\n}\n\n \nvoid nfs4_test_session_trunk(struct rpc_clnt *clnt, struct rpc_xprt *xprt,\n\t\t\t    void *data)\n{\n\tstruct nfs4_add_xprt_data *adata = data;\n\tstruct rpc_task *task;\n\tint status;\n\n\tu32 sp4_how;\n\n\tdprintk(\"--> %s try %s\\n\", __func__,\n\t\txprt->address_strings[RPC_DISPLAY_ADDR]);\n\n\tsp4_how = (adata->clp->cl_sp4_flags == 0 ? SP4_NONE : SP4_MACH_CRED);\n\ntry_again:\n\t \n\ttask = nfs4_run_exchange_id(adata->clp, adata->cred, sp4_how, xprt);\n\tif (IS_ERR(task))\n\t\treturn;\n\n\tstatus = task->tk_status;\n\tif (status == 0)\n\t\tstatus = nfs4_detect_session_trunking(adata->clp,\n\t\t\t\ttask->tk_msg.rpc_resp, xprt);\n\n\tif (status == 0)\n\t\trpc_clnt_xprt_switch_add_xprt(clnt, xprt);\n\telse if (status != -NFS4ERR_DELAY && rpc_clnt_xprt_switch_has_addr(clnt,\n\t\t\t\t(struct sockaddr *)&xprt->addr))\n\t\trpc_clnt_xprt_switch_remove_xprt(clnt, xprt);\n\n\trpc_put_task(task);\n\tif (status == -NFS4ERR_DELAY) {\n\t\tssleep(1);\n\t\tgoto try_again;\n\t}\n}\nEXPORT_SYMBOL_GPL(nfs4_test_session_trunk);\n\nstatic int _nfs4_proc_destroy_clientid(struct nfs_client *clp,\n\t\tconst struct cred *cred)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_DESTROY_CLIENTID],\n\t\t.rpc_argp = clp,\n\t\t.rpc_cred = cred,\n\t};\n\tint status;\n\n\tstatus = rpc_call_sync(clp->cl_rpcclient, &msg,\n\t\t\t       RPC_TASK_TIMEOUT | RPC_TASK_NO_ROUND_ROBIN);\n\ttrace_nfs4_destroy_clientid(clp, status);\n\tif (status)\n\t\tdprintk(\"NFS: Got error %d from the server %s on \"\n\t\t\t\"DESTROY_CLIENTID.\", status, clp->cl_hostname);\n\treturn status;\n}\n\nstatic int nfs4_proc_destroy_clientid(struct nfs_client *clp,\n\t\tconst struct cred *cred)\n{\n\tunsigned int loop;\n\tint ret;\n\n\tfor (loop = NFS4_MAX_LOOP_ON_RECOVER; loop != 0; loop--) {\n\t\tret = _nfs4_proc_destroy_clientid(clp, cred);\n\t\tswitch (ret) {\n\t\tcase -NFS4ERR_DELAY:\n\t\tcase -NFS4ERR_CLIENTID_BUSY:\n\t\t\tssleep(1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint nfs4_destroy_clientid(struct nfs_client *clp)\n{\n\tconst struct cred *cred;\n\tint ret = 0;\n\n\tif (clp->cl_mvops->minor_version < 1)\n\t\tgoto out;\n\tif (clp->cl_exchange_flags == 0)\n\t\tgoto out;\n\tif (clp->cl_preserve_clid)\n\t\tgoto out;\n\tcred = nfs4_get_clid_cred(clp);\n\tret = nfs4_proc_destroy_clientid(clp, cred);\n\tput_cred(cred);\n\tswitch (ret) {\n\tcase 0:\n\tcase -NFS4ERR_STALE_CLIENTID:\n\t\tclp->cl_exchange_flags = 0;\n\t}\nout:\n\treturn ret;\n}\n\n#endif  \n\nstruct nfs4_get_lease_time_data {\n\tstruct nfs4_get_lease_time_args *args;\n\tstruct nfs4_get_lease_time_res *res;\n\tstruct nfs_client *clp;\n};\n\nstatic void nfs4_get_lease_time_prepare(struct rpc_task *task,\n\t\t\t\t\tvoid *calldata)\n{\n\tstruct nfs4_get_lease_time_data *data =\n\t\t\t(struct nfs4_get_lease_time_data *)calldata;\n\n\t \n\tnfs4_setup_sequence(data->clp,\n\t\t\t&data->args->la_seq_args,\n\t\t\t&data->res->lr_seq_res,\n\t\t\ttask);\n}\n\n \nstatic void nfs4_get_lease_time_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_get_lease_time_data *data =\n\t\t\t(struct nfs4_get_lease_time_data *)calldata;\n\n\tif (!nfs4_sequence_done(task, &data->res->lr_seq_res))\n\t\treturn;\n\tswitch (task->tk_status) {\n\tcase -NFS4ERR_DELAY:\n\tcase -NFS4ERR_GRACE:\n\t\trpc_delay(task, NFS4_POLL_RETRY_MIN);\n\t\ttask->tk_status = 0;\n\t\tfallthrough;\n\tcase -NFS4ERR_RETRY_UNCACHED_REP:\n\t\trpc_restart_call_prepare(task);\n\t\treturn;\n\t}\n}\n\nstatic const struct rpc_call_ops nfs4_get_lease_time_ops = {\n\t.rpc_call_prepare = nfs4_get_lease_time_prepare,\n\t.rpc_call_done = nfs4_get_lease_time_done,\n};\n\nint nfs4_proc_get_lease_time(struct nfs_client *clp, struct nfs_fsinfo *fsinfo)\n{\n\tstruct nfs4_get_lease_time_args args;\n\tstruct nfs4_get_lease_time_res res = {\n\t\t.lr_fsinfo = fsinfo,\n\t};\n\tstruct nfs4_get_lease_time_data data = {\n\t\t.args = &args,\n\t\t.res = &res,\n\t\t.clp = clp,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GET_LEASE_TIME],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tstruct rpc_task_setup task_setup = {\n\t\t.rpc_client = clp->cl_rpcclient,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_get_lease_time_ops,\n\t\t.callback_data = &data,\n\t\t.flags = RPC_TASK_TIMEOUT,\n\t};\n\n\tnfs4_init_sequence(&args.la_seq_args, &res.lr_seq_res, 0, 1);\n\treturn nfs4_call_sync_custom(&task_setup);\n}\n\n#ifdef CONFIG_NFS_V4_1\n\n \nstatic void nfs4_init_channel_attrs(struct nfs41_create_session_args *args,\n\t\t\t\t    struct rpc_clnt *clnt)\n{\n\tunsigned int max_rqst_sz, max_resp_sz;\n\tunsigned int max_bc_payload = rpc_max_bc_payload(clnt);\n\tunsigned int max_bc_slots = rpc_num_bc_slots(clnt);\n\n\tmax_rqst_sz = NFS_MAX_FILE_IO_SIZE + nfs41_maxwrite_overhead;\n\tmax_resp_sz = NFS_MAX_FILE_IO_SIZE + nfs41_maxread_overhead;\n\n\t \n\targs->fc_attrs.max_rqst_sz = max_rqst_sz;\n\targs->fc_attrs.max_resp_sz = max_resp_sz;\n\targs->fc_attrs.max_ops = NFS4_MAX_OPS;\n\targs->fc_attrs.max_reqs = max_session_slots;\n\n\tdprintk(\"%s: Fore Channel : max_rqst_sz=%u max_resp_sz=%u \"\n\t\t\"max_ops=%u max_reqs=%u\\n\",\n\t\t__func__,\n\t\targs->fc_attrs.max_rqst_sz, args->fc_attrs.max_resp_sz,\n\t\targs->fc_attrs.max_ops, args->fc_attrs.max_reqs);\n\n\t \n\targs->bc_attrs.max_rqst_sz = max_bc_payload;\n\targs->bc_attrs.max_resp_sz = max_bc_payload;\n\targs->bc_attrs.max_resp_sz_cached = 0;\n\targs->bc_attrs.max_ops = NFS4_MAX_BACK_CHANNEL_OPS;\n\targs->bc_attrs.max_reqs = max_t(unsigned short, max_session_cb_slots, 1);\n\tif (args->bc_attrs.max_reqs > max_bc_slots)\n\t\targs->bc_attrs.max_reqs = max_bc_slots;\n\n\tdprintk(\"%s: Back Channel : max_rqst_sz=%u max_resp_sz=%u \"\n\t\t\"max_resp_sz_cached=%u max_ops=%u max_reqs=%u\\n\",\n\t\t__func__,\n\t\targs->bc_attrs.max_rqst_sz, args->bc_attrs.max_resp_sz,\n\t\targs->bc_attrs.max_resp_sz_cached, args->bc_attrs.max_ops,\n\t\targs->bc_attrs.max_reqs);\n}\n\nstatic int nfs4_verify_fore_channel_attrs(struct nfs41_create_session_args *args,\n\t\tstruct nfs41_create_session_res *res)\n{\n\tstruct nfs4_channel_attrs *sent = &args->fc_attrs;\n\tstruct nfs4_channel_attrs *rcvd = &res->fc_attrs;\n\n\tif (rcvd->max_resp_sz > sent->max_resp_sz)\n\t\treturn -EINVAL;\n\t \n\tif (rcvd->max_ops < sent->max_ops)\n\t\treturn -EINVAL;\n\tif (rcvd->max_reqs == 0)\n\t\treturn -EINVAL;\n\tif (rcvd->max_reqs > NFS4_MAX_SLOT_TABLE)\n\t\trcvd->max_reqs = NFS4_MAX_SLOT_TABLE;\n\treturn 0;\n}\n\nstatic int nfs4_verify_back_channel_attrs(struct nfs41_create_session_args *args,\n\t\tstruct nfs41_create_session_res *res)\n{\n\tstruct nfs4_channel_attrs *sent = &args->bc_attrs;\n\tstruct nfs4_channel_attrs *rcvd = &res->bc_attrs;\n\n\tif (!(res->flags & SESSION4_BACK_CHAN))\n\t\tgoto out;\n\tif (rcvd->max_rqst_sz > sent->max_rqst_sz)\n\t\treturn -EINVAL;\n\tif (rcvd->max_resp_sz < sent->max_resp_sz)\n\t\treturn -EINVAL;\n\tif (rcvd->max_resp_sz_cached > sent->max_resp_sz_cached)\n\t\treturn -EINVAL;\n\tif (rcvd->max_ops > sent->max_ops)\n\t\treturn -EINVAL;\n\tif (rcvd->max_reqs > sent->max_reqs)\n\t\treturn -EINVAL;\nout:\n\treturn 0;\n}\n\nstatic int nfs4_verify_channel_attrs(struct nfs41_create_session_args *args,\n\t\t\t\t     struct nfs41_create_session_res *res)\n{\n\tint ret;\n\n\tret = nfs4_verify_fore_channel_attrs(args, res);\n\tif (ret)\n\t\treturn ret;\n\treturn nfs4_verify_back_channel_attrs(args, res);\n}\n\nstatic void nfs4_update_session(struct nfs4_session *session,\n\t\tstruct nfs41_create_session_res *res)\n{\n\tnfs4_copy_sessionid(&session->sess_id, &res->sessionid);\n\t \n\tsession->clp->cl_exchange_flags |= EXCHGID4_FLAG_CONFIRMED_R;\n\tset_bit(NFS4_SESSION_ESTABLISHED, &session->session_state);\n\tsession->flags = res->flags;\n\tmemcpy(&session->fc_attrs, &res->fc_attrs, sizeof(session->fc_attrs));\n\tif (res->flags & SESSION4_BACK_CHAN)\n\t\tmemcpy(&session->bc_attrs, &res->bc_attrs,\n\t\t\t\tsizeof(session->bc_attrs));\n}\n\nstatic int _nfs4_proc_create_session(struct nfs_client *clp,\n\t\tconst struct cred *cred)\n{\n\tstruct nfs4_session *session = clp->cl_session;\n\tstruct nfs41_create_session_args args = {\n\t\t.client = clp,\n\t\t.clientid = clp->cl_clientid,\n\t\t.seqid = clp->cl_seqid,\n\t\t.cb_program = NFS4_CALLBACK,\n\t};\n\tstruct nfs41_create_session_res res;\n\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_CREATE_SESSION],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t\t.rpc_cred = cred,\n\t};\n\tint status;\n\n\tnfs4_init_channel_attrs(&args, clp->cl_rpcclient);\n\targs.flags = (SESSION4_PERSIST | SESSION4_BACK_CHAN);\n\n\tstatus = rpc_call_sync(session->clp->cl_rpcclient, &msg,\n\t\t\t       RPC_TASK_TIMEOUT | RPC_TASK_NO_ROUND_ROBIN);\n\ttrace_nfs4_create_session(clp, status);\n\n\tswitch (status) {\n\tcase -NFS4ERR_STALE_CLIENTID:\n\tcase -NFS4ERR_DELAY:\n\tcase -ETIMEDOUT:\n\tcase -EACCES:\n\tcase -EAGAIN:\n\t\tgoto out;\n\t}\n\n\tclp->cl_seqid++;\n\tif (!status) {\n\t\t \n\t\tstatus = nfs4_verify_channel_attrs(&args, &res);\n\t\t \n\t\tif (status)\n\t\t\tgoto out;\n\t\tnfs4_update_session(session, &res);\n\t}\nout:\n\treturn status;\n}\n\n \nint nfs4_proc_create_session(struct nfs_client *clp, const struct cred *cred)\n{\n\tint status;\n\tunsigned *ptr;\n\tstruct nfs4_session *session = clp->cl_session;\n\tstruct nfs4_add_xprt_data xprtdata = {\n\t\t.clp = clp,\n\t};\n\tstruct rpc_add_xprt_test rpcdata = {\n\t\t.add_xprt_test = clp->cl_mvops->session_trunk,\n\t\t.data = &xprtdata,\n\t};\n\n\tdprintk(\"--> %s clp=%p session=%p\\n\", __func__, clp, session);\n\n\tstatus = _nfs4_proc_create_session(clp, cred);\n\tif (status)\n\t\tgoto out;\n\n\t \n\tstatus = nfs4_setup_session_slot_tables(session);\n\tdprintk(\"slot table setup returned %d\\n\", status);\n\tif (status)\n\t\tgoto out;\n\n\tptr = (unsigned *)&session->sess_id.data[0];\n\tdprintk(\"%s client>seqid %d sessionid %u:%u:%u:%u\\n\", __func__,\n\t\tclp->cl_seqid, ptr[0], ptr[1], ptr[2], ptr[3]);\n\trpc_clnt_probe_trunked_xprts(clp->cl_rpcclient, &rpcdata);\nout:\n\treturn status;\n}\n\n \nint nfs4_proc_destroy_session(struct nfs4_session *session,\n\t\tconst struct cred *cred)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_DESTROY_SESSION],\n\t\t.rpc_argp = session,\n\t\t.rpc_cred = cred,\n\t};\n\tint status = 0;\n\n\t \n\tif (!test_and_clear_bit(NFS4_SESSION_ESTABLISHED, &session->session_state))\n\t\treturn 0;\n\n\tstatus = rpc_call_sync(session->clp->cl_rpcclient, &msg,\n\t\t\t       RPC_TASK_TIMEOUT | RPC_TASK_NO_ROUND_ROBIN);\n\ttrace_nfs4_destroy_session(session->clp, status);\n\n\tif (status)\n\t\tdprintk(\"NFS: Got error %d from the server on DESTROY_SESSION. \"\n\t\t\t\"Session has been destroyed regardless...\\n\", status);\n\trpc_clnt_manage_trunked_xprts(session->clp->cl_rpcclient);\n\treturn status;\n}\n\n \nstruct nfs4_sequence_data {\n\tstruct nfs_client *clp;\n\tstruct nfs4_sequence_args args;\n\tstruct nfs4_sequence_res res;\n};\n\nstatic void nfs41_sequence_release(void *data)\n{\n\tstruct nfs4_sequence_data *calldata = data;\n\tstruct nfs_client *clp = calldata->clp;\n\n\tif (refcount_read(&clp->cl_count) > 1)\n\t\tnfs4_schedule_state_renewal(clp);\n\tnfs_put_client(clp);\n\tkfree(calldata);\n}\n\nstatic int nfs41_sequence_handle_errors(struct rpc_task *task, struct nfs_client *clp)\n{\n\tswitch(task->tk_status) {\n\tcase -NFS4ERR_DELAY:\n\t\trpc_delay(task, NFS4_POLL_RETRY_MAX);\n\t\treturn -EAGAIN;\n\tdefault:\n\t\tnfs4_schedule_lease_recovery(clp);\n\t}\n\treturn 0;\n}\n\nstatic void nfs41_sequence_call_done(struct rpc_task *task, void *data)\n{\n\tstruct nfs4_sequence_data *calldata = data;\n\tstruct nfs_client *clp = calldata->clp;\n\n\tif (!nfs41_sequence_done(task, task->tk_msg.rpc_resp))\n\t\treturn;\n\n\ttrace_nfs4_sequence(clp, task->tk_status);\n\tif (task->tk_status < 0 && !task->tk_client->cl_shutdown) {\n\t\tdprintk(\"%s ERROR %d\\n\", __func__, task->tk_status);\n\t\tif (refcount_read(&clp->cl_count) == 1)\n\t\t\treturn;\n\n\t\tif (nfs41_sequence_handle_errors(task, clp) == -EAGAIN) {\n\t\t\trpc_restart_call_prepare(task);\n\t\t\treturn;\n\t\t}\n\t}\n\tdprintk(\"%s rpc_cred %p\\n\", __func__, task->tk_msg.rpc_cred);\n}\n\nstatic void nfs41_sequence_prepare(struct rpc_task *task, void *data)\n{\n\tstruct nfs4_sequence_data *calldata = data;\n\tstruct nfs_client *clp = calldata->clp;\n\tstruct nfs4_sequence_args *args;\n\tstruct nfs4_sequence_res *res;\n\n\targs = task->tk_msg.rpc_argp;\n\tres = task->tk_msg.rpc_resp;\n\n\tnfs4_setup_sequence(clp, args, res, task);\n}\n\nstatic const struct rpc_call_ops nfs41_sequence_ops = {\n\t.rpc_call_done = nfs41_sequence_call_done,\n\t.rpc_call_prepare = nfs41_sequence_prepare,\n\t.rpc_release = nfs41_sequence_release,\n};\n\nstatic struct rpc_task *_nfs41_proc_sequence(struct nfs_client *clp,\n\t\tconst struct cred *cred,\n\t\tstruct nfs4_slot *slot,\n\t\tbool is_privileged)\n{\n\tstruct nfs4_sequence_data *calldata;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_SEQUENCE],\n\t\t.rpc_cred = cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = clp->cl_rpcclient,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs41_sequence_ops,\n\t\t.flags = RPC_TASK_ASYNC | RPC_TASK_TIMEOUT | RPC_TASK_MOVEABLE,\n\t};\n\tstruct rpc_task *ret;\n\n\tret = ERR_PTR(-EIO);\n\tif (!refcount_inc_not_zero(&clp->cl_count))\n\t\tgoto out_err;\n\n\tret = ERR_PTR(-ENOMEM);\n\tcalldata = kzalloc(sizeof(*calldata), GFP_KERNEL);\n\tif (calldata == NULL)\n\t\tgoto out_put_clp;\n\tnfs4_init_sequence(&calldata->args, &calldata->res, 0, is_privileged);\n\tnfs4_sequence_attach_slot(&calldata->args, &calldata->res, slot);\n\tmsg.rpc_argp = &calldata->args;\n\tmsg.rpc_resp = &calldata->res;\n\tcalldata->clp = clp;\n\ttask_setup_data.callback_data = calldata;\n\n\tret = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(ret))\n\t\tgoto out_err;\n\treturn ret;\nout_put_clp:\n\tnfs_put_client(clp);\nout_err:\n\tnfs41_release_slot(slot);\n\treturn ret;\n}\n\nstatic int nfs41_proc_async_sequence(struct nfs_client *clp, const struct cred *cred, unsigned renew_flags)\n{\n\tstruct rpc_task *task;\n\tint ret = 0;\n\n\tif ((renew_flags & NFS4_RENEW_TIMEOUT) == 0)\n\t\treturn -EAGAIN;\n\ttask = _nfs41_proc_sequence(clp, cred, NULL, false);\n\tif (IS_ERR(task))\n\t\tret = PTR_ERR(task);\n\telse\n\t\trpc_put_task_async(task);\n\tdprintk(\"<-- %s status=%d\\n\", __func__, ret);\n\treturn ret;\n}\n\nstatic int nfs4_proc_sequence(struct nfs_client *clp, const struct cred *cred)\n{\n\tstruct rpc_task *task;\n\tint ret;\n\n\ttask = _nfs41_proc_sequence(clp, cred, NULL, true);\n\tif (IS_ERR(task)) {\n\t\tret = PTR_ERR(task);\n\t\tgoto out;\n\t}\n\tret = rpc_wait_for_completion_task(task);\n\tif (!ret)\n\t\tret = task->tk_status;\n\trpc_put_task(task);\nout:\n\tdprintk(\"<-- %s status=%d\\n\", __func__, ret);\n\treturn ret;\n}\n\nstruct nfs4_reclaim_complete_data {\n\tstruct nfs_client *clp;\n\tstruct nfs41_reclaim_complete_args arg;\n\tstruct nfs41_reclaim_complete_res res;\n};\n\nstatic void nfs4_reclaim_complete_prepare(struct rpc_task *task, void *data)\n{\n\tstruct nfs4_reclaim_complete_data *calldata = data;\n\n\tnfs4_setup_sequence(calldata->clp,\n\t\t\t&calldata->arg.seq_args,\n\t\t\t&calldata->res.seq_res,\n\t\t\ttask);\n}\n\nstatic int nfs41_reclaim_complete_handle_errors(struct rpc_task *task, struct nfs_client *clp)\n{\n\tswitch(task->tk_status) {\n\tcase 0:\n\t\twake_up_all(&clp->cl_lock_waitq);\n\t\tfallthrough;\n\tcase -NFS4ERR_COMPLETE_ALREADY:\n\tcase -NFS4ERR_WRONG_CRED:  \n\t\tbreak;\n\tcase -NFS4ERR_DELAY:\n\t\trpc_delay(task, NFS4_POLL_RETRY_MAX);\n\t\tfallthrough;\n\tcase -NFS4ERR_RETRY_UNCACHED_REP:\n\tcase -EACCES:\n\t\tdprintk(\"%s: failed to reclaim complete error %d for server %s, retrying\\n\",\n\t\t\t__func__, task->tk_status, clp->cl_hostname);\n\t\treturn -EAGAIN;\n\tcase -NFS4ERR_BADSESSION:\n\tcase -NFS4ERR_DEADSESSION:\n\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\t\tbreak;\n\tdefault:\n\t\tnfs4_schedule_lease_recovery(clp);\n\t}\n\treturn 0;\n}\n\nstatic void nfs4_reclaim_complete_done(struct rpc_task *task, void *data)\n{\n\tstruct nfs4_reclaim_complete_data *calldata = data;\n\tstruct nfs_client *clp = calldata->clp;\n\tstruct nfs4_sequence_res *res = &calldata->res.seq_res;\n\n\tif (!nfs41_sequence_done(task, res))\n\t\treturn;\n\n\ttrace_nfs4_reclaim_complete(clp, task->tk_status);\n\tif (nfs41_reclaim_complete_handle_errors(task, clp) == -EAGAIN) {\n\t\trpc_restart_call_prepare(task);\n\t\treturn;\n\t}\n}\n\nstatic void nfs4_free_reclaim_complete_data(void *data)\n{\n\tstruct nfs4_reclaim_complete_data *calldata = data;\n\n\tkfree(calldata);\n}\n\nstatic const struct rpc_call_ops nfs4_reclaim_complete_call_ops = {\n\t.rpc_call_prepare = nfs4_reclaim_complete_prepare,\n\t.rpc_call_done = nfs4_reclaim_complete_done,\n\t.rpc_release = nfs4_free_reclaim_complete_data,\n};\n\n \nstatic int nfs41_proc_reclaim_complete(struct nfs_client *clp,\n\t\tconst struct cred *cred)\n{\n\tstruct nfs4_reclaim_complete_data *calldata;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_RECLAIM_COMPLETE],\n\t\t.rpc_cred = cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = clp->cl_rpcclient,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_reclaim_complete_call_ops,\n\t\t.flags = RPC_TASK_NO_ROUND_ROBIN,\n\t};\n\tint status = -ENOMEM;\n\n\tcalldata = kzalloc(sizeof(*calldata), GFP_NOFS);\n\tif (calldata == NULL)\n\t\tgoto out;\n\tcalldata->clp = clp;\n\tcalldata->arg.one_fs = 0;\n\n\tnfs4_init_sequence(&calldata->arg.seq_args, &calldata->res.seq_res, 0, 1);\n\tmsg.rpc_argp = &calldata->arg;\n\tmsg.rpc_resp = &calldata->res;\n\ttask_setup_data.callback_data = calldata;\n\tstatus = nfs4_call_sync_custom(&task_setup_data);\nout:\n\tdprintk(\"<-- %s status=%d\\n\", __func__, status);\n\treturn status;\n}\n\nstatic void\nnfs4_layoutget_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_layoutget *lgp = calldata;\n\tstruct nfs_server *server = NFS_SERVER(lgp->args.inode);\n\n\tnfs4_setup_sequence(server->nfs_client, &lgp->args.seq_args,\n\t\t\t\t&lgp->res.seq_res, task);\n}\n\nstatic void nfs4_layoutget_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_layoutget *lgp = calldata;\n\n\tnfs41_sequence_process(task, &lgp->res.seq_res);\n}\n\nstatic int\nnfs4_layoutget_handle_exception(struct rpc_task *task,\n\t\tstruct nfs4_layoutget *lgp, struct nfs4_exception *exception)\n{\n\tstruct inode *inode = lgp->args.inode;\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct pnfs_layout_hdr *lo = lgp->lo;\n\tint nfs4err = task->tk_status;\n\tint err, status = 0;\n\tLIST_HEAD(head);\n\n\tdprintk(\"--> %s tk_status => %d\\n\", __func__, -task->tk_status);\n\n\tnfs4_sequence_free_slot(&lgp->res.seq_res);\n\n\tswitch (nfs4err) {\n\tcase 0:\n\t\tgoto out;\n\n\t \n\tcase -NFS4ERR_LAYOUTUNAVAILABLE:\n\t\tstatus = -ENODATA;\n\t\tgoto out;\n\t \n\tcase -NFS4ERR_BADLAYOUT:\n\t\tstatus = -EOVERFLOW;\n\t\tgoto out;\n\t \n\tcase -NFS4ERR_LAYOUTTRYLATER:\n\t\tif (lgp->args.minlength == 0) {\n\t\t\tstatus = -EOVERFLOW;\n\t\t\tgoto out;\n\t\t}\n\t\tstatus = -EBUSY;\n\t\tbreak;\n\tcase -NFS4ERR_RECALLCONFLICT:\n\tcase -NFS4ERR_RETURNCONFLICT:\n\t\tstatus = -ERECALLCONFLICT;\n\t\tbreak;\n\tcase -NFS4ERR_DELEG_REVOKED:\n\tcase -NFS4ERR_ADMIN_REVOKED:\n\tcase -NFS4ERR_EXPIRED:\n\tcase -NFS4ERR_BAD_STATEID:\n\t\texception->timeout = 0;\n\t\tspin_lock(&inode->i_lock);\n\t\t \n\t\tif (!lo || test_bit(NFS_LAYOUT_INVALID_STID, &lo->plh_flags) ||\n\t\t    !nfs4_stateid_match_other(&lgp->args.stateid, &lo->plh_stateid)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\texception->state = lgp->args.ctx->state;\n\t\t\texception->stateid = &lgp->args.stateid;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tpnfs_mark_layout_stateid_invalid(lo, &head);\n\t\tspin_unlock(&inode->i_lock);\n\t\tnfs_commit_inode(inode, 0);\n\t\tpnfs_free_lseg_list(&head);\n\t\tstatus = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\terr = nfs4_handle_exception(server, nfs4err, exception);\n\tif (!status) {\n\t\tif (exception->retry)\n\t\t\tstatus = -EAGAIN;\n\t\telse\n\t\t\tstatus = err;\n\t}\nout:\n\treturn status;\n}\n\nsize_t max_response_pages(struct nfs_server *server)\n{\n\tu32 max_resp_sz = server->nfs_client->cl_session->fc_attrs.max_resp_sz;\n\treturn nfs_page_array_len(0, max_resp_sz);\n}\n\nstatic void nfs4_layoutget_release(void *calldata)\n{\n\tstruct nfs4_layoutget *lgp = calldata;\n\n\tnfs4_sequence_free_slot(&lgp->res.seq_res);\n\tpnfs_layoutget_free(lgp);\n}\n\nstatic const struct rpc_call_ops nfs4_layoutget_call_ops = {\n\t.rpc_call_prepare = nfs4_layoutget_prepare,\n\t.rpc_call_done = nfs4_layoutget_done,\n\t.rpc_release = nfs4_layoutget_release,\n};\n\nstruct pnfs_layout_segment *\nnfs4_proc_layoutget(struct nfs4_layoutget *lgp, long *timeout)\n{\n\tstruct inode *inode = lgp->args.inode;\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct rpc_task *task;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LAYOUTGET],\n\t\t.rpc_argp = &lgp->args,\n\t\t.rpc_resp = &lgp->res,\n\t\t.rpc_cred = lgp->cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = server->client,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_layoutget_call_ops,\n\t\t.callback_data = lgp,\n\t\t.flags = RPC_TASK_ASYNC | RPC_TASK_CRED_NOREF |\n\t\t\t RPC_TASK_MOVEABLE,\n\t};\n\tstruct pnfs_layout_segment *lseg = NULL;\n\tstruct nfs4_exception exception = {\n\t\t.inode = inode,\n\t\t.timeout = *timeout,\n\t};\n\tint status = 0;\n\n\tnfs4_init_sequence(&lgp->args.seq_args, &lgp->res.seq_res, 0, 0);\n\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn ERR_CAST(task);\n\n\tstatus = rpc_wait_for_completion_task(task);\n\tif (status != 0)\n\t\tgoto out;\n\n\tif (task->tk_status < 0) {\n\t\tstatus = nfs4_layoutget_handle_exception(task, lgp, &exception);\n\t\t*timeout = exception.timeout;\n\t} else if (lgp->res.layoutp->len == 0) {\n\t\tstatus = -EAGAIN;\n\t\t*timeout = nfs4_update_delay(&exception.timeout);\n\t} else\n\t\tlseg = pnfs_layout_process(lgp);\nout:\n\ttrace_nfs4_layoutget(lgp->args.ctx,\n\t\t\t&lgp->args.range,\n\t\t\t&lgp->res.range,\n\t\t\t&lgp->res.stateid,\n\t\t\tstatus);\n\n\trpc_put_task(task);\n\tdprintk(\"<-- %s status=%d\\n\", __func__, status);\n\tif (status)\n\t\treturn ERR_PTR(status);\n\treturn lseg;\n}\n\nstatic void\nnfs4_layoutreturn_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_layoutreturn *lrp = calldata;\n\n\tnfs4_setup_sequence(lrp->clp,\n\t\t\t&lrp->args.seq_args,\n\t\t\t&lrp->res.seq_res,\n\t\t\ttask);\n\tif (!pnfs_layout_is_valid(lrp->args.layout))\n\t\trpc_exit(task, 0);\n}\n\nstatic void nfs4_layoutreturn_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_layoutreturn *lrp = calldata;\n\tstruct nfs_server *server;\n\n\tif (!nfs41_sequence_process(task, &lrp->res.seq_res))\n\t\treturn;\n\n\t \n\tif (task->tk_rpc_status != 0 && RPC_WAS_SENT(task)) {\n\t\tlrp->res.lrs_present = 0;\n\t\treturn;\n\t}\n\n\tserver = NFS_SERVER(lrp->args.inode);\n\tswitch (task->tk_status) {\n\tcase -NFS4ERR_OLD_STATEID:\n\t\tif (nfs4_layout_refresh_old_stateid(&lrp->args.stateid,\n\t\t\t\t\t&lrp->args.range,\n\t\t\t\t\tlrp->args.inode))\n\t\t\tgoto out_restart;\n\t\tfallthrough;\n\tdefault:\n\t\ttask->tk_status = 0;\n\t\tfallthrough;\n\tcase 0:\n\t\tbreak;\n\tcase -NFS4ERR_DELAY:\n\t\tif (nfs4_async_handle_error(task, server, NULL, NULL) != -EAGAIN)\n\t\t\tbreak;\n\t\tgoto out_restart;\n\t}\n\treturn;\nout_restart:\n\ttask->tk_status = 0;\n\tnfs4_sequence_free_slot(&lrp->res.seq_res);\n\trpc_restart_call_prepare(task);\n}\n\nstatic void nfs4_layoutreturn_release(void *calldata)\n{\n\tstruct nfs4_layoutreturn *lrp = calldata;\n\tstruct pnfs_layout_hdr *lo = lrp->args.layout;\n\n\tpnfs_layoutreturn_free_lsegs(lo, &lrp->args.stateid, &lrp->args.range,\n\t\t\tlrp->res.lrs_present ? &lrp->res.stateid : NULL);\n\tnfs4_sequence_free_slot(&lrp->res.seq_res);\n\tif (lrp->ld_private.ops && lrp->ld_private.ops->free)\n\t\tlrp->ld_private.ops->free(&lrp->ld_private);\n\tpnfs_put_layout_hdr(lrp->args.layout);\n\tnfs_iput_and_deactive(lrp->inode);\n\tput_cred(lrp->cred);\n\tkfree(calldata);\n}\n\nstatic const struct rpc_call_ops nfs4_layoutreturn_call_ops = {\n\t.rpc_call_prepare = nfs4_layoutreturn_prepare,\n\t.rpc_call_done = nfs4_layoutreturn_done,\n\t.rpc_release = nfs4_layoutreturn_release,\n};\n\nint nfs4_proc_layoutreturn(struct nfs4_layoutreturn *lrp, bool sync)\n{\n\tstruct rpc_task *task;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LAYOUTRETURN],\n\t\t.rpc_argp = &lrp->args,\n\t\t.rpc_resp = &lrp->res,\n\t\t.rpc_cred = lrp->cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = NFS_SERVER(lrp->args.inode)->client,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_layoutreturn_call_ops,\n\t\t.callback_data = lrp,\n\t\t.flags = RPC_TASK_MOVEABLE,\n\t};\n\tint status = 0;\n\n\tnfs4_state_protect(NFS_SERVER(lrp->args.inode)->nfs_client,\n\t\t\tNFS_SP4_MACH_CRED_PNFS_CLEANUP,\n\t\t\t&task_setup_data.rpc_client, &msg);\n\n\tlrp->inode = nfs_igrab_and_active(lrp->args.inode);\n\tif (!sync) {\n\t\tif (!lrp->inode) {\n\t\t\tnfs4_layoutreturn_release(lrp);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\ttask_setup_data.flags |= RPC_TASK_ASYNC;\n\t}\n\tif (!lrp->inode)\n\t\tnfs4_init_sequence(&lrp->args.seq_args, &lrp->res.seq_res, 1,\n\t\t\t\t   1);\n\telse\n\t\tnfs4_init_sequence(&lrp->args.seq_args, &lrp->res.seq_res, 1,\n\t\t\t\t   0);\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tif (sync)\n\t\tstatus = task->tk_status;\n\ttrace_nfs4_layoutreturn(lrp->args.inode, &lrp->args.stateid, status);\n\tdprintk(\"<-- %s status=%d\\n\", __func__, status);\n\trpc_put_task(task);\n\treturn status;\n}\n\nstatic int\n_nfs4_proc_getdeviceinfo(struct nfs_server *server,\n\t\tstruct pnfs_device *pdev,\n\t\tconst struct cred *cred)\n{\n\tstruct nfs4_getdeviceinfo_args args = {\n\t\t.pdev = pdev,\n\t\t.notify_types = NOTIFY_DEVICEID4_CHANGE |\n\t\t\tNOTIFY_DEVICEID4_DELETE,\n\t};\n\tstruct nfs4_getdeviceinfo_res res = {\n\t\t.pdev = pdev,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETDEVICEINFO],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t\t.rpc_cred = cred,\n\t};\n\tint status;\n\n\tstatus = nfs4_call_sync(server->client, server, &msg, &args.seq_args, &res.seq_res, 0);\n\tif (res.notification & ~args.notify_types)\n\t\tdprintk(\"%s: unsupported notification\\n\", __func__);\n\tif (res.notification != args.notify_types)\n\t\tpdev->nocache = 1;\n\n\ttrace_nfs4_getdeviceinfo(server, &pdev->dev_id, status);\n\n\tdprintk(\"<-- %s status=%d\\n\", __func__, status);\n\n\treturn status;\n}\n\nint nfs4_proc_getdeviceinfo(struct nfs_server *server,\n\t\tstruct pnfs_device *pdev,\n\t\tconst struct cred *cred)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\n\tdo {\n\t\terr = nfs4_handle_exception(server,\n\t\t\t\t\t_nfs4_proc_getdeviceinfo(server, pdev, cred),\n\t\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(nfs4_proc_getdeviceinfo);\n\nstatic void nfs4_layoutcommit_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_layoutcommit_data *data = calldata;\n\tstruct nfs_server *server = NFS_SERVER(data->args.inode);\n\n\tnfs4_setup_sequence(server->nfs_client,\n\t\t\t&data->args.seq_args,\n\t\t\t&data->res.seq_res,\n\t\t\ttask);\n}\n\nstatic void\nnfs4_layoutcommit_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_layoutcommit_data *data = calldata;\n\tstruct nfs_server *server = NFS_SERVER(data->args.inode);\n\n\tif (!nfs41_sequence_done(task, &data->res.seq_res))\n\t\treturn;\n\n\tswitch (task->tk_status) {  \n\tcase -NFS4ERR_DELEG_REVOKED:  \n\tcase -NFS4ERR_BADIOMODE:      \n\tcase -NFS4ERR_BADLAYOUT:      \n\tcase -NFS4ERR_GRACE:\t     \n\t\ttask->tk_status = 0;\n\t\tbreak;\n\tcase 0:\n\t\tbreak;\n\tdefault:\n\t\tif (nfs4_async_handle_error(task, server, NULL, NULL) == -EAGAIN) {\n\t\t\trpc_restart_call_prepare(task);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic void nfs4_layoutcommit_release(void *calldata)\n{\n\tstruct nfs4_layoutcommit_data *data = calldata;\n\n\tpnfs_cleanup_layoutcommit(data);\n\tnfs_post_op_update_inode_force_wcc(data->args.inode,\n\t\t\t\t\t   data->res.fattr);\n\tput_cred(data->cred);\n\tnfs_iput_and_deactive(data->inode);\n\tkfree(data);\n}\n\nstatic const struct rpc_call_ops nfs4_layoutcommit_ops = {\n\t.rpc_call_prepare = nfs4_layoutcommit_prepare,\n\t.rpc_call_done = nfs4_layoutcommit_done,\n\t.rpc_release = nfs4_layoutcommit_release,\n};\n\nint\nnfs4_proc_layoutcommit(struct nfs4_layoutcommit_data *data, bool sync)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LAYOUTCOMMIT],\n\t\t.rpc_argp = &data->args,\n\t\t.rpc_resp = &data->res,\n\t\t.rpc_cred = data->cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.task = &data->task,\n\t\t.rpc_client = NFS_CLIENT(data->args.inode),\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_layoutcommit_ops,\n\t\t.callback_data = data,\n\t\t.flags = RPC_TASK_MOVEABLE,\n\t};\n\tstruct rpc_task *task;\n\tint status = 0;\n\n\tdprintk(\"NFS: initiating layoutcommit call. sync %d \"\n\t\t\"lbw: %llu inode %lu\\n\", sync,\n\t\tdata->args.lastbytewritten,\n\t\tdata->args.inode->i_ino);\n\n\tif (!sync) {\n\t\tdata->inode = nfs_igrab_and_active(data->args.inode);\n\t\tif (data->inode == NULL) {\n\t\t\tnfs4_layoutcommit_release(data);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\ttask_setup_data.flags = RPC_TASK_ASYNC;\n\t}\n\tnfs4_init_sequence(&data->args.seq_args, &data->res.seq_res, 1, 0);\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tif (sync)\n\t\tstatus = task->tk_status;\n\ttrace_nfs4_layoutcommit(data->args.inode, &data->args.stateid, status);\n\tdprintk(\"%s: status %d\\n\", __func__, status);\n\trpc_put_task(task);\n\treturn status;\n}\n\n \nstatic int\n_nfs41_proc_secinfo_no_name(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\t    struct nfs_fsinfo *info,\n\t\t    struct nfs4_secinfo_flavors *flavors, bool use_integrity)\n{\n\tstruct nfs41_secinfo_no_name_args args = {\n\t\t.style = SECINFO_STYLE_CURRENT_FH,\n\t};\n\tstruct nfs4_secinfo_res res = {\n\t\t.flavors = flavors,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_SECINFO_NO_NAME],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tstruct nfs4_call_sync_data data = {\n\t\t.seq_server = server,\n\t\t.seq_args = &args.seq_args,\n\t\t.seq_res = &res.seq_res,\n\t};\n\tstruct rpc_task_setup task_setup = {\n\t\t.rpc_client = server->client,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = server->nfs_client->cl_mvops->call_sync_ops,\n\t\t.callback_data = &data,\n\t\t.flags = RPC_TASK_NO_ROUND_ROBIN,\n\t};\n\tconst struct cred *cred = NULL;\n\tint status;\n\n\tif (use_integrity) {\n\t\ttask_setup.rpc_client = server->nfs_client->cl_rpcclient;\n\n\t\tcred = nfs4_get_clid_cred(server->nfs_client);\n\t\tmsg.rpc_cred = cred;\n\t}\n\n\tnfs4_init_sequence(&args.seq_args, &res.seq_res, 0, 0);\n\tstatus = nfs4_call_sync_custom(&task_setup);\n\tdprintk(\"<-- %s status=%d\\n\", __func__, status);\n\n\tput_cred(cred);\n\n\treturn status;\n}\n\nstatic int\nnfs41_proc_secinfo_no_name(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\t\t   struct nfs_fsinfo *info, struct nfs4_secinfo_flavors *flavors)\n{\n\tstruct nfs4_exception exception = {\n\t\t.interruptible = true,\n\t};\n\tint err;\n\tdo {\n\t\t \n\t\terr = -NFS4ERR_WRONGSEC;\n\n\t\t \n\t\tif (_nfs4_is_integrity_protected(server->nfs_client))\n\t\t\terr = _nfs41_proc_secinfo_no_name(server, fhandle, info,\n\t\t\t\t\t\t\t  flavors, true);\n\n\t\t \n\t\tif (err == -NFS4ERR_WRONGSEC)\n\t\t\terr = _nfs41_proc_secinfo_no_name(server, fhandle, info,\n\t\t\t\t\t\t\t  flavors, false);\n\n\t\tswitch (err) {\n\t\tcase 0:\n\t\tcase -NFS4ERR_WRONGSEC:\n\t\tcase -ENOTSUPP:\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\terr = nfs4_handle_exception(server, err, &exception);\n\t\t}\n\t} while (exception.retry);\nout:\n\treturn err;\n}\n\nstatic int\nnfs41_find_root_sec(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\t    struct nfs_fsinfo *info)\n{\n\tint err;\n\tstruct page *page;\n\trpc_authflavor_t flavor = RPC_AUTH_MAXFLAVOR;\n\tstruct nfs4_secinfo_flavors *flavors;\n\tstruct nfs4_secinfo4 *secinfo;\n\tint i;\n\n\tpage = alloc_page(GFP_KERNEL);\n\tif (!page) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tflavors = page_address(page);\n\terr = nfs41_proc_secinfo_no_name(server, fhandle, info, flavors);\n\n\t \n\tif (err == -NFS4ERR_WRONGSEC || err == -ENOTSUPP) {\n\t\terr = nfs4_find_root_sec(server, fhandle, info);\n\t\tgoto out_freepage;\n\t}\n\tif (err)\n\t\tgoto out_freepage;\n\n\tfor (i = 0; i < flavors->num_flavors; i++) {\n\t\tsecinfo = &flavors->flavors[i];\n\n\t\tswitch (secinfo->flavor) {\n\t\tcase RPC_AUTH_NULL:\n\t\tcase RPC_AUTH_UNIX:\n\t\tcase RPC_AUTH_GSS:\n\t\t\tflavor = rpcauth_get_pseudoflavor(secinfo->flavor,\n\t\t\t\t\t&secinfo->flavor_info);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tflavor = RPC_AUTH_MAXFLAVOR;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!nfs_auth_info_match(&server->auth_info, flavor))\n\t\t\tflavor = RPC_AUTH_MAXFLAVOR;\n\n\t\tif (flavor != RPC_AUTH_MAXFLAVOR) {\n\t\t\terr = nfs4_lookup_root_sec(server, fhandle,\n\t\t\t\t\t\t   info, flavor);\n\t\t\tif (!err)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (flavor == RPC_AUTH_MAXFLAVOR)\n\t\terr = -EPERM;\n\nout_freepage:\n\tput_page(page);\n\tif (err == -EACCES)\n\t\treturn -EPERM;\nout:\n\treturn err;\n}\n\nstatic int _nfs41_test_stateid(struct nfs_server *server,\n\t\tnfs4_stateid *stateid,\n\t\tconst struct cred *cred)\n{\n\tint status;\n\tstruct nfs41_test_stateid_args args = {\n\t\t.stateid = stateid,\n\t};\n\tstruct nfs41_test_stateid_res res;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_TEST_STATEID],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t\t.rpc_cred = cred,\n\t};\n\tstruct rpc_clnt *rpc_client = server->client;\n\n\tnfs4_state_protect(server->nfs_client, NFS_SP4_MACH_CRED_STATEID,\n\t\t&rpc_client, &msg);\n\n\tdprintk(\"NFS call  test_stateid %p\\n\", stateid);\n\tnfs4_init_sequence(&args.seq_args, &res.seq_res, 0, 1);\n\tstatus = nfs4_call_sync_sequence(rpc_client, server, &msg,\n\t\t\t&args.seq_args, &res.seq_res);\n\tif (status != NFS_OK) {\n\t\tdprintk(\"NFS reply test_stateid: failed, %d\\n\", status);\n\t\treturn status;\n\t}\n\tdprintk(\"NFS reply test_stateid: succeeded, %d\\n\", -res.status);\n\treturn -res.status;\n}\n\nstatic void nfs4_handle_delay_or_session_error(struct nfs_server *server,\n\t\tint err, struct nfs4_exception *exception)\n{\n\texception->retry = 0;\n\tswitch(err) {\n\tcase -NFS4ERR_DELAY:\n\tcase -NFS4ERR_RETRY_UNCACHED_REP:\n\t\tnfs4_handle_exception(server, err, exception);\n\t\tbreak;\n\tcase -NFS4ERR_BADSESSION:\n\tcase -NFS4ERR_BADSLOT:\n\tcase -NFS4ERR_BAD_HIGH_SLOT:\n\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\tcase -NFS4ERR_DEADSESSION:\n\t\tnfs4_do_handle_exception(server, err, exception);\n\t}\n}\n\n \nstatic int nfs41_test_stateid(struct nfs_server *server,\n\t\tnfs4_stateid *stateid,\n\t\tconst struct cred *cred)\n{\n\tstruct nfs4_exception exception = {\n\t\t.interruptible = true,\n\t};\n\tint err;\n\tdo {\n\t\terr = _nfs41_test_stateid(server, stateid, cred);\n\t\tnfs4_handle_delay_or_session_error(server, err, &exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstruct nfs_free_stateid_data {\n\tstruct nfs_server *server;\n\tstruct nfs41_free_stateid_args args;\n\tstruct nfs41_free_stateid_res res;\n};\n\nstatic void nfs41_free_stateid_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs_free_stateid_data *data = calldata;\n\tnfs4_setup_sequence(data->server->nfs_client,\n\t\t\t&data->args.seq_args,\n\t\t\t&data->res.seq_res,\n\t\t\ttask);\n}\n\nstatic void nfs41_free_stateid_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs_free_stateid_data *data = calldata;\n\n\tnfs41_sequence_done(task, &data->res.seq_res);\n\n\tswitch (task->tk_status) {\n\tcase -NFS4ERR_DELAY:\n\t\tif (nfs4_async_handle_error(task, data->server, NULL, NULL) == -EAGAIN)\n\t\t\trpc_restart_call_prepare(task);\n\t}\n}\n\nstatic void nfs41_free_stateid_release(void *calldata)\n{\n\tstruct nfs_free_stateid_data *data = calldata;\n\tstruct nfs_client *clp = data->server->nfs_client;\n\n\tnfs_put_client(clp);\n\tkfree(calldata);\n}\n\nstatic const struct rpc_call_ops nfs41_free_stateid_ops = {\n\t.rpc_call_prepare = nfs41_free_stateid_prepare,\n\t.rpc_call_done = nfs41_free_stateid_done,\n\t.rpc_release = nfs41_free_stateid_release,\n};\n\n \nstatic int nfs41_free_stateid(struct nfs_server *server,\n\t\tconst nfs4_stateid *stateid,\n\t\tconst struct cred *cred,\n\t\tbool privileged)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_FREE_STATEID],\n\t\t.rpc_cred = cred,\n\t};\n\tstruct rpc_task_setup task_setup = {\n\t\t.rpc_client = server->client,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs41_free_stateid_ops,\n\t\t.flags = RPC_TASK_ASYNC | RPC_TASK_MOVEABLE,\n\t};\n\tstruct nfs_free_stateid_data *data;\n\tstruct rpc_task *task;\n\tstruct nfs_client *clp = server->nfs_client;\n\n\tif (!refcount_inc_not_zero(&clp->cl_count))\n\t\treturn -EIO;\n\n\tnfs4_state_protect(server->nfs_client, NFS_SP4_MACH_CRED_STATEID,\n\t\t&task_setup.rpc_client, &msg);\n\n\tdprintk(\"NFS call  free_stateid %p\\n\", stateid);\n\tdata = kmalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\tdata->server = server;\n\tnfs4_stateid_copy(&data->args.stateid, stateid);\n\n\ttask_setup.callback_data = data;\n\n\tmsg.rpc_argp = &data->args;\n\tmsg.rpc_resp = &data->res;\n\tnfs4_init_sequence(&data->args.seq_args, &data->res.seq_res, 1, privileged);\n\ttask = rpc_run_task(&task_setup);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\trpc_put_task(task);\n\treturn 0;\n}\n\nstatic void\nnfs41_free_lock_state(struct nfs_server *server, struct nfs4_lock_state *lsp)\n{\n\tconst struct cred *cred = lsp->ls_state->owner->so_cred;\n\n\tnfs41_free_stateid(server, &lsp->ls_stateid, cred, false);\n\tnfs4_free_lock_state(server, lsp);\n}\n\nstatic bool nfs41_match_stateid(const nfs4_stateid *s1,\n\t\tconst nfs4_stateid *s2)\n{\n\tif (s1->type != s2->type)\n\t\treturn false;\n\n\tif (memcmp(s1->other, s2->other, sizeof(s1->other)) != 0)\n\t\treturn false;\n\n\tif (s1->seqid == s2->seqid)\n\t\treturn true;\n\n\treturn s1->seqid == 0 || s2->seqid == 0;\n}\n\n#endif  \n\nstatic bool nfs4_match_stateid(const nfs4_stateid *s1,\n\t\tconst nfs4_stateid *s2)\n{\n\treturn nfs4_stateid_match(s1, s2);\n}\n\n\nstatic const struct nfs4_state_recovery_ops nfs40_reboot_recovery_ops = {\n\t.owner_flag_bit = NFS_OWNER_RECLAIM_REBOOT,\n\t.state_flag_bit\t= NFS_STATE_RECLAIM_REBOOT,\n\t.recover_open\t= nfs4_open_reclaim,\n\t.recover_lock\t= nfs4_lock_reclaim,\n\t.establish_clid = nfs4_init_clientid,\n\t.detect_trunking = nfs40_discover_server_trunking,\n};\n\n#if defined(CONFIG_NFS_V4_1)\nstatic const struct nfs4_state_recovery_ops nfs41_reboot_recovery_ops = {\n\t.owner_flag_bit = NFS_OWNER_RECLAIM_REBOOT,\n\t.state_flag_bit\t= NFS_STATE_RECLAIM_REBOOT,\n\t.recover_open\t= nfs4_open_reclaim,\n\t.recover_lock\t= nfs4_lock_reclaim,\n\t.establish_clid = nfs41_init_clientid,\n\t.reclaim_complete = nfs41_proc_reclaim_complete,\n\t.detect_trunking = nfs41_discover_server_trunking,\n};\n#endif  \n\nstatic const struct nfs4_state_recovery_ops nfs40_nograce_recovery_ops = {\n\t.owner_flag_bit = NFS_OWNER_RECLAIM_NOGRACE,\n\t.state_flag_bit\t= NFS_STATE_RECLAIM_NOGRACE,\n\t.recover_open\t= nfs40_open_expired,\n\t.recover_lock\t= nfs4_lock_expired,\n\t.establish_clid = nfs4_init_clientid,\n};\n\n#if defined(CONFIG_NFS_V4_1)\nstatic const struct nfs4_state_recovery_ops nfs41_nograce_recovery_ops = {\n\t.owner_flag_bit = NFS_OWNER_RECLAIM_NOGRACE,\n\t.state_flag_bit\t= NFS_STATE_RECLAIM_NOGRACE,\n\t.recover_open\t= nfs41_open_expired,\n\t.recover_lock\t= nfs41_lock_expired,\n\t.establish_clid = nfs41_init_clientid,\n};\n#endif  \n\nstatic const struct nfs4_state_maintenance_ops nfs40_state_renewal_ops = {\n\t.sched_state_renewal = nfs4_proc_async_renew,\n\t.get_state_renewal_cred = nfs4_get_renew_cred,\n\t.renew_lease = nfs4_proc_renew,\n};\n\n#if defined(CONFIG_NFS_V4_1)\nstatic const struct nfs4_state_maintenance_ops nfs41_state_renewal_ops = {\n\t.sched_state_renewal = nfs41_proc_async_sequence,\n\t.get_state_renewal_cred = nfs4_get_machine_cred,\n\t.renew_lease = nfs4_proc_sequence,\n};\n#endif\n\nstatic const struct nfs4_mig_recovery_ops nfs40_mig_recovery_ops = {\n\t.get_locations = _nfs40_proc_get_locations,\n\t.fsid_present = _nfs40_proc_fsid_present,\n};\n\n#if defined(CONFIG_NFS_V4_1)\nstatic const struct nfs4_mig_recovery_ops nfs41_mig_recovery_ops = {\n\t.get_locations = _nfs41_proc_get_locations,\n\t.fsid_present = _nfs41_proc_fsid_present,\n};\n#endif\t \n\nstatic const struct nfs4_minor_version_ops nfs_v4_0_minor_ops = {\n\t.minor_version = 0,\n\t.init_caps = NFS_CAP_READDIRPLUS\n\t\t| NFS_CAP_ATOMIC_OPEN\n\t\t| NFS_CAP_POSIX_LOCK,\n\t.init_client = nfs40_init_client,\n\t.shutdown_client = nfs40_shutdown_client,\n\t.match_stateid = nfs4_match_stateid,\n\t.find_root_sec = nfs4_find_root_sec,\n\t.free_lock_state = nfs4_release_lockowner,\n\t.test_and_free_expired = nfs40_test_and_free_expired_stateid,\n\t.alloc_seqid = nfs_alloc_seqid,\n\t.call_sync_ops = &nfs40_call_sync_ops,\n\t.reboot_recovery_ops = &nfs40_reboot_recovery_ops,\n\t.nograce_recovery_ops = &nfs40_nograce_recovery_ops,\n\t.state_renewal_ops = &nfs40_state_renewal_ops,\n\t.mig_recovery_ops = &nfs40_mig_recovery_ops,\n};\n\n#if defined(CONFIG_NFS_V4_1)\nstatic struct nfs_seqid *\nnfs_alloc_no_seqid(struct nfs_seqid_counter *arg1, gfp_t arg2)\n{\n\treturn NULL;\n}\n\nstatic const struct nfs4_minor_version_ops nfs_v4_1_minor_ops = {\n\t.minor_version = 1,\n\t.init_caps = NFS_CAP_READDIRPLUS\n\t\t| NFS_CAP_ATOMIC_OPEN\n\t\t| NFS_CAP_POSIX_LOCK\n\t\t| NFS_CAP_STATEID_NFSV41\n\t\t| NFS_CAP_ATOMIC_OPEN_V1\n\t\t| NFS_CAP_LGOPEN\n\t\t| NFS_CAP_MOVEABLE,\n\t.init_client = nfs41_init_client,\n\t.shutdown_client = nfs41_shutdown_client,\n\t.match_stateid = nfs41_match_stateid,\n\t.find_root_sec = nfs41_find_root_sec,\n\t.free_lock_state = nfs41_free_lock_state,\n\t.test_and_free_expired = nfs41_test_and_free_expired_stateid,\n\t.alloc_seqid = nfs_alloc_no_seqid,\n\t.session_trunk = nfs4_test_session_trunk,\n\t.call_sync_ops = &nfs41_call_sync_ops,\n\t.reboot_recovery_ops = &nfs41_reboot_recovery_ops,\n\t.nograce_recovery_ops = &nfs41_nograce_recovery_ops,\n\t.state_renewal_ops = &nfs41_state_renewal_ops,\n\t.mig_recovery_ops = &nfs41_mig_recovery_ops,\n};\n#endif\n\n#if defined(CONFIG_NFS_V4_2)\nstatic const struct nfs4_minor_version_ops nfs_v4_2_minor_ops = {\n\t.minor_version = 2,\n\t.init_caps = NFS_CAP_READDIRPLUS\n\t\t| NFS_CAP_ATOMIC_OPEN\n\t\t| NFS_CAP_POSIX_LOCK\n\t\t| NFS_CAP_STATEID_NFSV41\n\t\t| NFS_CAP_ATOMIC_OPEN_V1\n\t\t| NFS_CAP_LGOPEN\n\t\t| NFS_CAP_ALLOCATE\n\t\t| NFS_CAP_COPY\n\t\t| NFS_CAP_OFFLOAD_CANCEL\n\t\t| NFS_CAP_COPY_NOTIFY\n\t\t| NFS_CAP_DEALLOCATE\n\t\t| NFS_CAP_SEEK\n\t\t| NFS_CAP_LAYOUTSTATS\n\t\t| NFS_CAP_CLONE\n\t\t| NFS_CAP_LAYOUTERROR\n\t\t| NFS_CAP_READ_PLUS\n\t\t| NFS_CAP_MOVEABLE,\n\t.init_client = nfs41_init_client,\n\t.shutdown_client = nfs41_shutdown_client,\n\t.match_stateid = nfs41_match_stateid,\n\t.find_root_sec = nfs41_find_root_sec,\n\t.free_lock_state = nfs41_free_lock_state,\n\t.call_sync_ops = &nfs41_call_sync_ops,\n\t.test_and_free_expired = nfs41_test_and_free_expired_stateid,\n\t.alloc_seqid = nfs_alloc_no_seqid,\n\t.session_trunk = nfs4_test_session_trunk,\n\t.reboot_recovery_ops = &nfs41_reboot_recovery_ops,\n\t.nograce_recovery_ops = &nfs41_nograce_recovery_ops,\n\t.state_renewal_ops = &nfs41_state_renewal_ops,\n\t.mig_recovery_ops = &nfs41_mig_recovery_ops,\n};\n#endif\n\nconst struct nfs4_minor_version_ops *nfs_v4_minor_ops[] = {\n\t[0] = &nfs_v4_0_minor_ops,\n#if defined(CONFIG_NFS_V4_1)\n\t[1] = &nfs_v4_1_minor_ops,\n#endif\n#if defined(CONFIG_NFS_V4_2)\n\t[2] = &nfs_v4_2_minor_ops,\n#endif\n};\n\nstatic ssize_t nfs4_listxattr(struct dentry *dentry, char *list, size_t size)\n{\n\tssize_t error, error2, error3;\n\n\terror = generic_listxattr(dentry, list, size);\n\tif (error < 0)\n\t\treturn error;\n\tif (list) {\n\t\tlist += error;\n\t\tsize -= error;\n\t}\n\n\terror2 = nfs4_listxattr_nfs4_label(d_inode(dentry), list, size);\n\tif (error2 < 0)\n\t\treturn error2;\n\n\tif (list) {\n\t\tlist += error2;\n\t\tsize -= error2;\n\t}\n\n\terror3 = nfs4_listxattr_nfs4_user(d_inode(dentry), list, size);\n\tif (error3 < 0)\n\t\treturn error3;\n\n\treturn error + error2 + error3;\n}\n\nstatic void nfs4_enable_swap(struct inode *inode)\n{\n\t \n\tstruct nfs_client *clp = NFS_SERVER(inode)->nfs_client;\n\n\tnfs4_schedule_state_manager(clp);\n}\n\nstatic void nfs4_disable_swap(struct inode *inode)\n{\n\t \n\tstruct nfs_client *clp = NFS_SERVER(inode)->nfs_client;\n\n\tset_bit(NFS4CLNT_RUN_MANAGER, &clp->cl_state);\n\tclear_bit(NFS4CLNT_MANAGER_AVAILABLE, &clp->cl_state);\n\twake_up_var(&clp->cl_state);\n}\n\nstatic const struct inode_operations nfs4_dir_inode_operations = {\n\t.create\t\t= nfs_create,\n\t.lookup\t\t= nfs_lookup,\n\t.atomic_open\t= nfs_atomic_open,\n\t.link\t\t= nfs_link,\n\t.unlink\t\t= nfs_unlink,\n\t.symlink\t= nfs_symlink,\n\t.mkdir\t\t= nfs_mkdir,\n\t.rmdir\t\t= nfs_rmdir,\n\t.mknod\t\t= nfs_mknod,\n\t.rename\t\t= nfs_rename,\n\t.permission\t= nfs_permission,\n\t.getattr\t= nfs_getattr,\n\t.setattr\t= nfs_setattr,\n\t.listxattr\t= nfs4_listxattr,\n};\n\nstatic const struct inode_operations nfs4_file_inode_operations = {\n\t.permission\t= nfs_permission,\n\t.getattr\t= nfs_getattr,\n\t.setattr\t= nfs_setattr,\n\t.listxattr\t= nfs4_listxattr,\n};\n\nconst struct nfs_rpc_ops nfs_v4_clientops = {\n\t.version\t= 4,\t\t\t \n\t.dentry_ops\t= &nfs4_dentry_operations,\n\t.dir_inode_ops\t= &nfs4_dir_inode_operations,\n\t.file_inode_ops\t= &nfs4_file_inode_operations,\n\t.file_ops\t= &nfs4_file_operations,\n\t.getroot\t= nfs4_proc_get_root,\n\t.submount\t= nfs4_submount,\n\t.try_get_tree\t= nfs4_try_get_tree,\n\t.getattr\t= nfs4_proc_getattr,\n\t.setattr\t= nfs4_proc_setattr,\n\t.lookup\t\t= nfs4_proc_lookup,\n\t.lookupp\t= nfs4_proc_lookupp,\n\t.access\t\t= nfs4_proc_access,\n\t.readlink\t= nfs4_proc_readlink,\n\t.create\t\t= nfs4_proc_create,\n\t.remove\t\t= nfs4_proc_remove,\n\t.unlink_setup\t= nfs4_proc_unlink_setup,\n\t.unlink_rpc_prepare = nfs4_proc_unlink_rpc_prepare,\n\t.unlink_done\t= nfs4_proc_unlink_done,\n\t.rename_setup\t= nfs4_proc_rename_setup,\n\t.rename_rpc_prepare = nfs4_proc_rename_rpc_prepare,\n\t.rename_done\t= nfs4_proc_rename_done,\n\t.link\t\t= nfs4_proc_link,\n\t.symlink\t= nfs4_proc_symlink,\n\t.mkdir\t\t= nfs4_proc_mkdir,\n\t.rmdir\t\t= nfs4_proc_rmdir,\n\t.readdir\t= nfs4_proc_readdir,\n\t.mknod\t\t= nfs4_proc_mknod,\n\t.statfs\t\t= nfs4_proc_statfs,\n\t.fsinfo\t\t= nfs4_proc_fsinfo,\n\t.pathconf\t= nfs4_proc_pathconf,\n\t.set_capabilities = nfs4_server_capabilities,\n\t.decode_dirent\t= nfs4_decode_dirent,\n\t.pgio_rpc_prepare = nfs4_proc_pgio_rpc_prepare,\n\t.read_setup\t= nfs4_proc_read_setup,\n\t.read_done\t= nfs4_read_done,\n\t.write_setup\t= nfs4_proc_write_setup,\n\t.write_done\t= nfs4_write_done,\n\t.commit_setup\t= nfs4_proc_commit_setup,\n\t.commit_rpc_prepare = nfs4_proc_commit_rpc_prepare,\n\t.commit_done\t= nfs4_commit_done,\n\t.lock\t\t= nfs4_proc_lock,\n\t.clear_acl_cache = nfs4_zap_acl_attr,\n\t.close_context  = nfs4_close_context,\n\t.open_context\t= nfs4_atomic_open,\n\t.have_delegation = nfs4_have_delegation,\n\t.alloc_client\t= nfs4_alloc_client,\n\t.init_client\t= nfs4_init_client,\n\t.free_client\t= nfs4_free_client,\n\t.create_server\t= nfs4_create_server,\n\t.clone_server\t= nfs_clone_server,\n\t.discover_trunking = nfs4_discover_trunking,\n\t.enable_swap\t= nfs4_enable_swap,\n\t.disable_swap\t= nfs4_disable_swap,\n};\n\nstatic const struct xattr_handler nfs4_xattr_nfs4_acl_handler = {\n\t.name\t= XATTR_NAME_NFSV4_ACL,\n\t.list\t= nfs4_xattr_list_nfs4_acl,\n\t.get\t= nfs4_xattr_get_nfs4_acl,\n\t.set\t= nfs4_xattr_set_nfs4_acl,\n};\n\n#if defined(CONFIG_NFS_V4_1)\nstatic const struct xattr_handler nfs4_xattr_nfs4_dacl_handler = {\n\t.name\t= XATTR_NAME_NFSV4_DACL,\n\t.list\t= nfs4_xattr_list_nfs4_dacl,\n\t.get\t= nfs4_xattr_get_nfs4_dacl,\n\t.set\t= nfs4_xattr_set_nfs4_dacl,\n};\n\nstatic const struct xattr_handler nfs4_xattr_nfs4_sacl_handler = {\n\t.name\t= XATTR_NAME_NFSV4_SACL,\n\t.list\t= nfs4_xattr_list_nfs4_sacl,\n\t.get\t= nfs4_xattr_get_nfs4_sacl,\n\t.set\t= nfs4_xattr_set_nfs4_sacl,\n};\n#endif\n\n#ifdef CONFIG_NFS_V4_2\nstatic const struct xattr_handler nfs4_xattr_nfs4_user_handler = {\n\t.prefix\t= XATTR_USER_PREFIX,\n\t.get\t= nfs4_xattr_get_nfs4_user,\n\t.set\t= nfs4_xattr_set_nfs4_user,\n};\n#endif\n\nconst struct xattr_handler *nfs4_xattr_handlers[] = {\n\t&nfs4_xattr_nfs4_acl_handler,\n#if defined(CONFIG_NFS_V4_1)\n\t&nfs4_xattr_nfs4_dacl_handler,\n\t&nfs4_xattr_nfs4_sacl_handler,\n#endif\n#ifdef CONFIG_NFS_V4_SECURITY_LABEL\n\t&nfs4_xattr_nfs4_label_handler,\n#endif\n#ifdef CONFIG_NFS_V4_2\n\t&nfs4_xattr_nfs4_user_handler,\n#endif\n\tNULL\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}