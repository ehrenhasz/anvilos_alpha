{
  "module_name": "nfs42proc.c",
  "hash_id": "800121d73bee3b57f028786f5de01747c533c42c3e552a77e3ffe2cdf4549b11",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfs/nfs42proc.c",
  "human_readable_source": "\n \n#include <linux/fs.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/nfs.h>\n#include <linux/nfs3.h>\n#include <linux/nfs4.h>\n#include <linux/nfs_xdr.h>\n#include <linux/nfs_fs.h>\n#include \"nfs4_fs.h\"\n#include \"nfs42.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4trace.h\"\n\n#define NFSDBG_FACILITY NFSDBG_PROC\nstatic int nfs42_do_offload_cancel_async(struct file *dst, nfs4_stateid *std);\n\nstatic void nfs42_set_netaddr(struct file *filep, struct nfs42_netaddr *naddr)\n{\n\tstruct nfs_client *clp = (NFS_SERVER(file_inode(filep)))->nfs_client;\n\tunsigned short port = 2049;\n\n\trcu_read_lock();\n\tnaddr->netid_len = scnprintf(naddr->netid,\n\t\t\t\t\tsizeof(naddr->netid), \"%s\",\n\t\t\t\t\trpc_peeraddr2str(clp->cl_rpcclient,\n\t\t\t\t\tRPC_DISPLAY_NETID));\n\tnaddr->addr_len = scnprintf(naddr->addr,\n\t\t\t\t\tsizeof(naddr->addr),\n\t\t\t\t\t\"%s.%u.%u\",\n\t\t\t\t\trpc_peeraddr2str(clp->cl_rpcclient,\n\t\t\t\t\tRPC_DISPLAY_ADDR),\n\t\t\t\t\tport >> 8, port & 255);\n\trcu_read_unlock();\n}\n\nstatic int _nfs42_proc_fallocate(struct rpc_message *msg, struct file *filep,\n\t\tstruct nfs_lock_context *lock, loff_t offset, loff_t len)\n{\n\tstruct inode *inode = file_inode(filep);\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tu32 bitmask[NFS_BITMASK_SZ];\n\tstruct nfs42_falloc_args args = {\n\t\t.falloc_fh\t= NFS_FH(inode),\n\t\t.falloc_offset\t= offset,\n\t\t.falloc_length\t= len,\n\t\t.falloc_bitmask\t= bitmask,\n\t};\n\tstruct nfs42_falloc_res res = {\n\t\t.falloc_server\t= server,\n\t};\n\tint status;\n\n\tmsg->rpc_argp = &args;\n\tmsg->rpc_resp = &res;\n\n\tstatus = nfs4_set_rw_stateid(&args.falloc_stateid, lock->open_context,\n\t\t\tlock, FMODE_WRITE);\n\tif (status) {\n\t\tif (status == -EAGAIN)\n\t\t\tstatus = -NFS4ERR_BAD_STATEID;\n\t\treturn status;\n\t}\n\n\tnfs4_bitmask_set(bitmask, server->cache_consistency_bitmask, inode,\n\t\t\t NFS_INO_INVALID_BLOCKS);\n\n\tres.falloc_fattr = nfs_alloc_fattr();\n\tif (!res.falloc_fattr)\n\t\treturn -ENOMEM;\n\n\tstatus = nfs4_call_sync(server->client, server, msg,\n\t\t\t\t&args.seq_args, &res.seq_res, 0);\n\tif (status == 0) {\n\t\tif (nfs_should_remove_suid(inode)) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tnfs_set_cache_invalid(inode,\n\t\t\t\tNFS_INO_REVAL_FORCED | NFS_INO_INVALID_MODE);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t}\n\t\tstatus = nfs_post_op_update_inode_force_wcc(inode,\n\t\t\t\t\t\t\t    res.falloc_fattr);\n\t}\n\tif (msg->rpc_proc == &nfs4_procedures[NFSPROC4_CLNT_ALLOCATE])\n\t\ttrace_nfs4_fallocate(inode, &args, status);\n\telse\n\t\ttrace_nfs4_deallocate(inode, &args, status);\n\tkfree(res.falloc_fattr);\n\treturn status;\n}\n\nstatic int nfs42_proc_fallocate(struct rpc_message *msg, struct file *filep,\n\t\t\t\tloff_t offset, loff_t len)\n{\n\tstruct inode *inode = file_inode(filep);\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs4_exception exception = { };\n\tstruct nfs_lock_context *lock;\n\tint err;\n\n\tlock = nfs_get_lock_context(nfs_file_open_context(filep));\n\tif (IS_ERR(lock))\n\t\treturn PTR_ERR(lock);\n\n\texception.inode = inode;\n\texception.state = lock->open_context->state;\n\n\terr = nfs_sync_inode(inode);\n\tif (err)\n\t\tgoto out;\n\n\tdo {\n\t\terr = _nfs42_proc_fallocate(msg, filep, lock, offset, len);\n\t\tif (err == -ENOTSUPP) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tbreak;\n\t\t}\n\t\terr = nfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\nout:\n\tnfs_put_lock_context(lock);\n\treturn err;\n}\n\nint nfs42_proc_allocate(struct file *filep, loff_t offset, loff_t len)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_ALLOCATE],\n\t};\n\tstruct inode *inode = file_inode(filep);\n\tint err;\n\n\tif (!nfs_server_capable(inode, NFS_CAP_ALLOCATE))\n\t\treturn -EOPNOTSUPP;\n\n\tinode_lock(inode);\n\n\terr = nfs42_proc_fallocate(&msg, filep, offset, len);\n\tif (err == -EOPNOTSUPP)\n\t\tNFS_SERVER(inode)->caps &= ~NFS_CAP_ALLOCATE;\n\n\tinode_unlock(inode);\n\treturn err;\n}\n\nint nfs42_proc_deallocate(struct file *filep, loff_t offset, loff_t len)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_DEALLOCATE],\n\t};\n\tstruct inode *inode = file_inode(filep);\n\tint err;\n\n\tif (!nfs_server_capable(inode, NFS_CAP_DEALLOCATE))\n\t\treturn -EOPNOTSUPP;\n\n\tinode_lock(inode);\n\n\terr = nfs42_proc_fallocate(&msg, filep, offset, len);\n\tif (err == 0)\n\t\ttruncate_pagecache_range(inode, offset, (offset + len) -1);\n\tif (err == -EOPNOTSUPP)\n\t\tNFS_SERVER(inode)->caps &= ~NFS_CAP_DEALLOCATE;\n\n\tinode_unlock(inode);\n\treturn err;\n}\n\nstatic int handle_async_copy(struct nfs42_copy_res *res,\n\t\t\t     struct nfs_server *dst_server,\n\t\t\t     struct nfs_server *src_server,\n\t\t\t     struct file *src,\n\t\t\t     struct file *dst,\n\t\t\t     nfs4_stateid *src_stateid,\n\t\t\t     bool *restart)\n{\n\tstruct nfs4_copy_state *copy, *tmp_copy = NULL, *iter;\n\tint status = NFS4_OK;\n\tstruct nfs_open_context *dst_ctx = nfs_file_open_context(dst);\n\tstruct nfs_open_context *src_ctx = nfs_file_open_context(src);\n\n\tcopy = kzalloc(sizeof(struct nfs4_copy_state), GFP_KERNEL);\n\tif (!copy)\n\t\treturn -ENOMEM;\n\n\tspin_lock(&dst_server->nfs_client->cl_lock);\n\tlist_for_each_entry(iter,\n\t\t\t\t&dst_server->nfs_client->pending_cb_stateids,\n\t\t\t\tcopies) {\n\t\tif (memcmp(&res->write_res.stateid, &iter->stateid,\n\t\t\t\tNFS4_STATEID_SIZE))\n\t\t\tcontinue;\n\t\ttmp_copy = iter;\n\t\tlist_del(&iter->copies);\n\t\tbreak;\n\t}\n\tif (tmp_copy) {\n\t\tspin_unlock(&dst_server->nfs_client->cl_lock);\n\t\tkfree(copy);\n\t\tcopy = tmp_copy;\n\t\tgoto out;\n\t}\n\n\tmemcpy(&copy->stateid, &res->write_res.stateid, NFS4_STATEID_SIZE);\n\tinit_completion(&copy->completion);\n\tcopy->parent_dst_state = dst_ctx->state;\n\tcopy->parent_src_state = src_ctx->state;\n\n\tlist_add_tail(&copy->copies, &dst_server->ss_copies);\n\tspin_unlock(&dst_server->nfs_client->cl_lock);\n\n\tif (dst_server != src_server) {\n\t\tspin_lock(&src_server->nfs_client->cl_lock);\n\t\tlist_add_tail(&copy->src_copies, &src_server->ss_copies);\n\t\tspin_unlock(&src_server->nfs_client->cl_lock);\n\t}\n\n\tstatus = wait_for_completion_interruptible(&copy->completion);\n\tspin_lock(&dst_server->nfs_client->cl_lock);\n\tlist_del_init(&copy->copies);\n\tspin_unlock(&dst_server->nfs_client->cl_lock);\n\tif (dst_server != src_server) {\n\t\tspin_lock(&src_server->nfs_client->cl_lock);\n\t\tlist_del_init(&copy->src_copies);\n\t\tspin_unlock(&src_server->nfs_client->cl_lock);\n\t}\n\tif (status == -ERESTARTSYS) {\n\t\tgoto out_cancel;\n\t} else if (copy->flags || copy->error == NFS4ERR_PARTNER_NO_AUTH) {\n\t\tstatus = -EAGAIN;\n\t\t*restart = true;\n\t\tgoto out_cancel;\n\t}\nout:\n\tres->write_res.count = copy->count;\n\tmemcpy(&res->write_res.verifier, &copy->verf, sizeof(copy->verf));\n\tstatus = -copy->error;\n\nout_free:\n\tkfree(copy);\n\treturn status;\nout_cancel:\n\tnfs42_do_offload_cancel_async(dst, &copy->stateid);\n\tif (!nfs42_files_from_same_server(src, dst))\n\t\tnfs42_do_offload_cancel_async(src, src_stateid);\n\tgoto out_free;\n}\n\nstatic int process_copy_commit(struct file *dst, loff_t pos_dst,\n\t\t\t       struct nfs42_copy_res *res)\n{\n\tstruct nfs_commitres cres;\n\tint status = -ENOMEM;\n\n\tcres.verf = kzalloc(sizeof(struct nfs_writeverf), GFP_KERNEL);\n\tif (!cres.verf)\n\t\tgoto out;\n\n\tstatus = nfs4_proc_commit(dst, pos_dst, res->write_res.count, &cres);\n\tif (status)\n\t\tgoto out_free;\n\tif (nfs_write_verifier_cmp(&res->write_res.verifier.verifier,\n\t\t\t\t    &cres.verf->verifier)) {\n\t\tdprintk(\"commit verf differs from copy verf\\n\");\n\t\tstatus = -EAGAIN;\n\t}\nout_free:\n\tkfree(cres.verf);\nout:\n\treturn status;\n}\n\n \nstatic void nfs42_copy_dest_done(struct inode *inode, loff_t pos, loff_t len)\n{\n\tloff_t newsize = pos + len;\n\tloff_t end = newsize - 1;\n\n\tWARN_ON_ONCE(invalidate_inode_pages2_range(inode->i_mapping,\n\t\t\t\tpos >> PAGE_SHIFT, end >> PAGE_SHIFT));\n\n\tspin_lock(&inode->i_lock);\n\tif (newsize > i_size_read(inode))\n\t\ti_size_write(inode, newsize);\n\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_CHANGE |\n\t\t\t\t\t     NFS_INO_INVALID_CTIME |\n\t\t\t\t\t     NFS_INO_INVALID_MTIME |\n\t\t\t\t\t     NFS_INO_INVALID_BLOCKS);\n\tspin_unlock(&inode->i_lock);\n}\n\nstatic ssize_t _nfs42_proc_copy(struct file *src,\n\t\t\t\tstruct nfs_lock_context *src_lock,\n\t\t\t\tstruct file *dst,\n\t\t\t\tstruct nfs_lock_context *dst_lock,\n\t\t\t\tstruct nfs42_copy_args *args,\n\t\t\t\tstruct nfs42_copy_res *res,\n\t\t\t\tstruct nl4_server *nss,\n\t\t\t\tnfs4_stateid *cnr_stateid,\n\t\t\t\tbool *restart)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_COPY],\n\t\t.rpc_argp = args,\n\t\t.rpc_resp = res,\n\t};\n\tstruct inode *dst_inode = file_inode(dst);\n\tstruct inode *src_inode = file_inode(src);\n\tstruct nfs_server *dst_server = NFS_SERVER(dst_inode);\n\tstruct nfs_server *src_server = NFS_SERVER(src_inode);\n\tloff_t pos_src = args->src_pos;\n\tloff_t pos_dst = args->dst_pos;\n\tsize_t count = args->count;\n\tssize_t status;\n\n\tif (nss) {\n\t\targs->cp_src = nss;\n\t\tnfs4_stateid_copy(&args->src_stateid, cnr_stateid);\n\t} else {\n\t\tstatus = nfs4_set_rw_stateid(&args->src_stateid,\n\t\t\t\tsrc_lock->open_context, src_lock, FMODE_READ);\n\t\tif (status) {\n\t\t\tif (status == -EAGAIN)\n\t\t\t\tstatus = -NFS4ERR_BAD_STATEID;\n\t\t\treturn status;\n\t\t}\n\t}\n\tstatus = nfs_filemap_write_and_wait_range(src->f_mapping,\n\t\t\tpos_src, pos_src + (loff_t)count - 1);\n\tif (status)\n\t\treturn status;\n\n\tstatus = nfs4_set_rw_stateid(&args->dst_stateid, dst_lock->open_context,\n\t\t\t\t     dst_lock, FMODE_WRITE);\n\tif (status) {\n\t\tif (status == -EAGAIN)\n\t\t\tstatus = -NFS4ERR_BAD_STATEID;\n\t\treturn status;\n\t}\n\n\tstatus = nfs_sync_inode(dst_inode);\n\tif (status)\n\t\treturn status;\n\n\tres->commit_res.verf = NULL;\n\tif (args->sync) {\n\t\tres->commit_res.verf =\n\t\t\tkzalloc(sizeof(struct nfs_writeverf), GFP_KERNEL);\n\t\tif (!res->commit_res.verf)\n\t\t\treturn -ENOMEM;\n\t}\n\tset_bit(NFS_CLNT_SRC_SSC_COPY_STATE,\n\t\t&src_lock->open_context->state->flags);\n\tset_bit(NFS_CLNT_DST_SSC_COPY_STATE,\n\t\t&dst_lock->open_context->state->flags);\n\n\tstatus = nfs4_call_sync(dst_server->client, dst_server, &msg,\n\t\t\t\t&args->seq_args, &res->seq_res, 0);\n\ttrace_nfs4_copy(src_inode, dst_inode, args, res, nss, status);\n\tif (status == -ENOTSUPP)\n\t\tdst_server->caps &= ~NFS_CAP_COPY;\n\tif (status)\n\t\tgoto out;\n\n\tif (args->sync &&\n\t\tnfs_write_verifier_cmp(&res->write_res.verifier.verifier,\n\t\t\t\t    &res->commit_res.verf->verifier)) {\n\t\tstatus = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tif (!res->synchronous) {\n\t\tstatus = handle_async_copy(res, dst_server, src_server, src,\n\t\t\t\tdst, &args->src_stateid, restart);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\tif ((!res->synchronous || !args->sync) &&\n\t\t\tres->write_res.verifier.committed != NFS_FILE_SYNC) {\n\t\tstatus = process_copy_commit(dst, pos_dst, res);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\tnfs42_copy_dest_done(dst_inode, pos_dst, res->write_res.count);\n\tnfs_invalidate_atime(src_inode);\n\tstatus = res->write_res.count;\nout:\n\tif (args->sync)\n\t\tkfree(res->commit_res.verf);\n\treturn status;\n}\n\nssize_t nfs42_proc_copy(struct file *src, loff_t pos_src,\n\t\t\tstruct file *dst, loff_t pos_dst, size_t count,\n\t\t\tstruct nl4_server *nss,\n\t\t\tnfs4_stateid *cnr_stateid, bool sync)\n{\n\tstruct nfs_server *server = NFS_SERVER(file_inode(dst));\n\tstruct nfs_lock_context *src_lock;\n\tstruct nfs_lock_context *dst_lock;\n\tstruct nfs42_copy_args args = {\n\t\t.src_fh\t\t= NFS_FH(file_inode(src)),\n\t\t.src_pos\t= pos_src,\n\t\t.dst_fh\t\t= NFS_FH(file_inode(dst)),\n\t\t.dst_pos\t= pos_dst,\n\t\t.count\t\t= count,\n\t\t.sync\t\t= sync,\n\t};\n\tstruct nfs42_copy_res res;\n\tstruct nfs4_exception src_exception = {\n\t\t.inode\t\t= file_inode(src),\n\t\t.stateid\t= &args.src_stateid,\n\t};\n\tstruct nfs4_exception dst_exception = {\n\t\t.inode\t\t= file_inode(dst),\n\t\t.stateid\t= &args.dst_stateid,\n\t};\n\tssize_t err, err2;\n\tbool restart = false;\n\n\tsrc_lock = nfs_get_lock_context(nfs_file_open_context(src));\n\tif (IS_ERR(src_lock))\n\t\treturn PTR_ERR(src_lock);\n\n\tsrc_exception.state = src_lock->open_context->state;\n\n\tdst_lock = nfs_get_lock_context(nfs_file_open_context(dst));\n\tif (IS_ERR(dst_lock)) {\n\t\terr = PTR_ERR(dst_lock);\n\t\tgoto out_put_src_lock;\n\t}\n\n\tdst_exception.state = dst_lock->open_context->state;\n\n\tdo {\n\t\tinode_lock(file_inode(dst));\n\t\terr = _nfs42_proc_copy(src, src_lock,\n\t\t\t\tdst, dst_lock,\n\t\t\t\t&args, &res,\n\t\t\t\tnss, cnr_stateid, &restart);\n\t\tinode_unlock(file_inode(dst));\n\n\t\tif (err >= 0)\n\t\t\tbreak;\n\t\tif ((err == -ENOTSUPP ||\n\t\t\t\terr == -NFS4ERR_OFFLOAD_DENIED) &&\n\t\t\t\tnfs42_files_from_same_server(src, dst)) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tbreak;\n\t\t} else if (err == -EAGAIN) {\n\t\t\tif (!restart) {\n\t\t\t\tdst_exception.retry = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t} else if (err == -NFS4ERR_OFFLOAD_NO_REQS &&\n\t\t\t\targs.sync != res.synchronous) {\n\t\t\targs.sync = res.synchronous;\n\t\t\tdst_exception.retry = 1;\n\t\t\tcontinue;\n\t\t} else if ((err == -ESTALE ||\n\t\t\t\terr == -NFS4ERR_OFFLOAD_DENIED ||\n\t\t\t\terr == -ENOTSUPP) &&\n\t\t\t\t!nfs42_files_from_same_server(src, dst)) {\n\t\t\tnfs42_do_offload_cancel_async(src, &args.src_stateid);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tbreak;\n\t\t}\n\n\t\terr2 = nfs4_handle_exception(server, err, &src_exception);\n\t\terr  = nfs4_handle_exception(server, err, &dst_exception);\n\t\tif (!err)\n\t\t\terr = err2;\n\t} while (src_exception.retry || dst_exception.retry);\n\n\tnfs_put_lock_context(dst_lock);\nout_put_src_lock:\n\tnfs_put_lock_context(src_lock);\n\treturn err;\n}\n\nstruct nfs42_offloadcancel_data {\n\tstruct nfs_server *seq_server;\n\tstruct nfs42_offload_status_args args;\n\tstruct nfs42_offload_status_res res;\n};\n\nstatic void nfs42_offload_cancel_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs42_offloadcancel_data *data = calldata;\n\n\tnfs4_setup_sequence(data->seq_server->nfs_client,\n\t\t\t\t&data->args.osa_seq_args,\n\t\t\t\t&data->res.osr_seq_res, task);\n}\n\nstatic void nfs42_offload_cancel_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs42_offloadcancel_data *data = calldata;\n\n\ttrace_nfs4_offload_cancel(&data->args, task->tk_status);\n\tnfs41_sequence_done(task, &data->res.osr_seq_res);\n\tif (task->tk_status &&\n\t\tnfs4_async_handle_error(task, data->seq_server, NULL,\n\t\t\tNULL) == -EAGAIN)\n\t\trpc_restart_call_prepare(task);\n}\n\nstatic void nfs42_free_offloadcancel_data(void *data)\n{\n\tkfree(data);\n}\n\nstatic const struct rpc_call_ops nfs42_offload_cancel_ops = {\n\t.rpc_call_prepare = nfs42_offload_cancel_prepare,\n\t.rpc_call_done = nfs42_offload_cancel_done,\n\t.rpc_release = nfs42_free_offloadcancel_data,\n};\n\nstatic int nfs42_do_offload_cancel_async(struct file *dst,\n\t\t\t\t\t nfs4_stateid *stateid)\n{\n\tstruct nfs_server *dst_server = NFS_SERVER(file_inode(dst));\n\tstruct nfs42_offloadcancel_data *data = NULL;\n\tstruct nfs_open_context *ctx = nfs_file_open_context(dst);\n\tstruct rpc_task *task;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_OFFLOAD_CANCEL],\n\t\t.rpc_cred = ctx->cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = dst_server->client,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs42_offload_cancel_ops,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\tint status;\n\n\tif (!(dst_server->caps & NFS_CAP_OFFLOAD_CANCEL))\n\t\treturn -EOPNOTSUPP;\n\n\tdata = kzalloc(sizeof(struct nfs42_offloadcancel_data), GFP_KERNEL);\n\tif (data == NULL)\n\t\treturn -ENOMEM;\n\n\tdata->seq_server = dst_server;\n\tdata->args.osa_src_fh = NFS_FH(file_inode(dst));\n\tmemcpy(&data->args.osa_stateid, stateid,\n\t\tsizeof(data->args.osa_stateid));\n\tmsg.rpc_argp = &data->args;\n\tmsg.rpc_resp = &data->res;\n\ttask_setup_data.callback_data = data;\n\tnfs4_init_sequence(&data->args.osa_seq_args, &data->res.osr_seq_res,\n\t\t\t   1, 0);\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tstatus = rpc_wait_for_completion_task(task);\n\tif (status == -ENOTSUPP)\n\t\tdst_server->caps &= ~NFS_CAP_OFFLOAD_CANCEL;\n\trpc_put_task(task);\n\treturn status;\n}\n\nstatic int _nfs42_proc_copy_notify(struct file *src, struct file *dst,\n\t\t\t\t   struct nfs42_copy_notify_args *args,\n\t\t\t\t   struct nfs42_copy_notify_res *res)\n{\n\tstruct nfs_server *src_server = NFS_SERVER(file_inode(src));\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_COPY_NOTIFY],\n\t\t.rpc_argp = args,\n\t\t.rpc_resp = res,\n\t};\n\tint status;\n\tstruct nfs_open_context *ctx;\n\tstruct nfs_lock_context *l_ctx;\n\n\tctx = get_nfs_open_context(nfs_file_open_context(src));\n\tl_ctx = nfs_get_lock_context(ctx);\n\tif (IS_ERR(l_ctx)) {\n\t\tstatus = PTR_ERR(l_ctx);\n\t\tgoto out;\n\t}\n\n\tstatus = nfs4_set_rw_stateid(&args->cna_src_stateid, ctx, l_ctx,\n\t\t\t\t     FMODE_READ);\n\tnfs_put_lock_context(l_ctx);\n\tif (status) {\n\t\tif (status == -EAGAIN)\n\t\t\tstatus = -NFS4ERR_BAD_STATEID;\n\t\tgoto out;\n\t}\n\n\tstatus = nfs4_call_sync(src_server->client, src_server, &msg,\n\t\t\t\t&args->cna_seq_args, &res->cnr_seq_res, 0);\n\ttrace_nfs4_copy_notify(file_inode(src), args, res, status);\n\tif (status == -ENOTSUPP)\n\t\tsrc_server->caps &= ~NFS_CAP_COPY_NOTIFY;\n\nout:\n\tput_nfs_open_context(nfs_file_open_context(src));\n\treturn status;\n}\n\nint nfs42_proc_copy_notify(struct file *src, struct file *dst,\n\t\t\t\tstruct nfs42_copy_notify_res *res)\n{\n\tstruct nfs_server *src_server = NFS_SERVER(file_inode(src));\n\tstruct nfs42_copy_notify_args *args;\n\tstruct nfs4_exception exception = {\n\t\t.inode = file_inode(src),\n\t};\n\tint status;\n\n\tif (!(src_server->caps & NFS_CAP_COPY_NOTIFY))\n\t\treturn -EOPNOTSUPP;\n\n\targs = kzalloc(sizeof(struct nfs42_copy_notify_args), GFP_KERNEL);\n\tif (args == NULL)\n\t\treturn -ENOMEM;\n\n\targs->cna_src_fh  = NFS_FH(file_inode(src)),\n\targs->cna_dst.nl4_type = NL4_NETADDR;\n\tnfs42_set_netaddr(dst, &args->cna_dst.u.nl4_addr);\n\texception.stateid = &args->cna_src_stateid;\n\n\tdo {\n\t\tstatus = _nfs42_proc_copy_notify(src, dst, args, res);\n\t\tif (status == -ENOTSUPP) {\n\t\t\tstatus = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\t\tstatus = nfs4_handle_exception(src_server, status, &exception);\n\t} while (exception.retry);\n\nout:\n\tkfree(args);\n\treturn status;\n}\n\nstatic loff_t _nfs42_proc_llseek(struct file *filep,\n\t\tstruct nfs_lock_context *lock, loff_t offset, int whence)\n{\n\tstruct inode *inode = file_inode(filep);\n\tstruct nfs42_seek_args args = {\n\t\t.sa_fh\t\t= NFS_FH(inode),\n\t\t.sa_offset\t= offset,\n\t\t.sa_what\t= (whence == SEEK_HOLE) ?\n\t\t\t\t\tNFS4_CONTENT_HOLE : NFS4_CONTENT_DATA,\n\t};\n\tstruct nfs42_seek_res res;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_SEEK],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tint status;\n\n\tif (!nfs_server_capable(inode, NFS_CAP_SEEK))\n\t\treturn -ENOTSUPP;\n\n\tstatus = nfs4_set_rw_stateid(&args.sa_stateid, lock->open_context,\n\t\t\tlock, FMODE_READ);\n\tif (status) {\n\t\tif (status == -EAGAIN)\n\t\t\tstatus = -NFS4ERR_BAD_STATEID;\n\t\treturn status;\n\t}\n\n\tstatus = nfs_filemap_write_and_wait_range(inode->i_mapping,\n\t\t\toffset, LLONG_MAX);\n\tif (status)\n\t\treturn status;\n\n\tstatus = nfs4_call_sync(server->client, server, &msg,\n\t\t\t\t&args.seq_args, &res.seq_res, 0);\n\ttrace_nfs4_llseek(inode, &args, &res, status);\n\tif (status == -ENOTSUPP)\n\t\tserver->caps &= ~NFS_CAP_SEEK;\n\tif (status)\n\t\treturn status;\n\n\tif (whence == SEEK_DATA && res.sr_eof)\n\t\treturn -NFS4ERR_NXIO;\n\telse\n\t\treturn vfs_setpos(filep, res.sr_offset, inode->i_sb->s_maxbytes);\n}\n\nloff_t nfs42_proc_llseek(struct file *filep, loff_t offset, int whence)\n{\n\tstruct nfs_server *server = NFS_SERVER(file_inode(filep));\n\tstruct nfs4_exception exception = { };\n\tstruct nfs_lock_context *lock;\n\tloff_t err;\n\n\tlock = nfs_get_lock_context(nfs_file_open_context(filep));\n\tif (IS_ERR(lock))\n\t\treturn PTR_ERR(lock);\n\n\texception.inode = file_inode(filep);\n\texception.state = lock->open_context->state;\n\n\tdo {\n\t\terr = _nfs42_proc_llseek(filep, lock, offset, whence);\n\t\tif (err >= 0)\n\t\t\tbreak;\n\t\tif (err == -ENOTSUPP) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tbreak;\n\t\t}\n\t\terr = nfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\n\n\tnfs_put_lock_context(lock);\n\treturn err;\n}\n\n\nstatic void\nnfs42_layoutstat_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs42_layoutstat_data *data = calldata;\n\tstruct inode *inode = data->inode;\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct pnfs_layout_hdr *lo;\n\n\tspin_lock(&inode->i_lock);\n\tlo = NFS_I(inode)->layout;\n\tif (!pnfs_layout_is_valid(lo)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\trpc_exit(task, 0);\n\t\treturn;\n\t}\n\tnfs4_stateid_copy(&data->args.stateid, &lo->plh_stateid);\n\tspin_unlock(&inode->i_lock);\n\tnfs4_setup_sequence(server->nfs_client, &data->args.seq_args,\n\t\t\t    &data->res.seq_res, task);\n}\n\nstatic void\nnfs42_layoutstat_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs42_layoutstat_data *data = calldata;\n\tstruct inode *inode = data->inode;\n\tstruct pnfs_layout_hdr *lo;\n\n\tif (!nfs4_sequence_done(task, &data->res.seq_res))\n\t\treturn;\n\n\tswitch (task->tk_status) {\n\tcase 0:\n\t\treturn;\n\tcase -NFS4ERR_BADHANDLE:\n\tcase -ESTALE:\n\t\tpnfs_destroy_layout(NFS_I(inode));\n\t\tbreak;\n\tcase -NFS4ERR_EXPIRED:\n\tcase -NFS4ERR_ADMIN_REVOKED:\n\tcase -NFS4ERR_DELEG_REVOKED:\n\tcase -NFS4ERR_STALE_STATEID:\n\tcase -NFS4ERR_BAD_STATEID:\n\t\tspin_lock(&inode->i_lock);\n\t\tlo = NFS_I(inode)->layout;\n\t\tif (pnfs_layout_is_valid(lo) &&\n\t\t    nfs4_stateid_match(&data->args.stateid,\n\t\t\t\t\t     &lo->plh_stateid)) {\n\t\t\tLIST_HEAD(head);\n\n\t\t\t \n\t\t\tpnfs_mark_layout_stateid_invalid(lo, &head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tpnfs_free_lseg_list(&head);\n\t\t\tnfs_commit_inode(inode, 0);\n\t\t} else\n\t\t\tspin_unlock(&inode->i_lock);\n\t\tbreak;\n\tcase -NFS4ERR_OLD_STATEID:\n\t\tspin_lock(&inode->i_lock);\n\t\tlo = NFS_I(inode)->layout;\n\t\tif (pnfs_layout_is_valid(lo) &&\n\t\t    nfs4_stateid_match_other(&data->args.stateid,\n\t\t\t\t\t&lo->plh_stateid)) {\n\t\t\t \n\t\t\tif (!nfs4_stateid_is_newer(&lo->plh_stateid,\n\t\t\t\t\t\t&data->args.stateid))\n\t\t\t\trpc_delay(task, HZ);\n\t\t\trpc_restart_call_prepare(task);\n\t\t}\n\t\tspin_unlock(&inode->i_lock);\n\t\tbreak;\n\tcase -ENOTSUPP:\n\tcase -EOPNOTSUPP:\n\t\tNFS_SERVER(inode)->caps &= ~NFS_CAP_LAYOUTSTATS;\n\t}\n\n\ttrace_nfs4_layoutstats(inode, &data->args.stateid, task->tk_status);\n}\n\nstatic void\nnfs42_layoutstat_release(void *calldata)\n{\n\tstruct nfs42_layoutstat_data *data = calldata;\n\tstruct nfs42_layoutstat_devinfo *devinfo = data->args.devinfo;\n\tint i;\n\n\tfor (i = 0; i < data->args.num_dev; i++) {\n\t\tif (devinfo[i].ld_private.ops && devinfo[i].ld_private.ops->free)\n\t\t\tdevinfo[i].ld_private.ops->free(&devinfo[i].ld_private);\n\t}\n\n\tpnfs_put_layout_hdr(NFS_I(data->args.inode)->layout);\n\tsmp_mb__before_atomic();\n\tclear_bit(NFS_INO_LAYOUTSTATS, &NFS_I(data->args.inode)->flags);\n\tsmp_mb__after_atomic();\n\tnfs_iput_and_deactive(data->inode);\n\tkfree(data->args.devinfo);\n\tkfree(data);\n}\n\nstatic const struct rpc_call_ops nfs42_layoutstat_ops = {\n\t.rpc_call_prepare = nfs42_layoutstat_prepare,\n\t.rpc_call_done = nfs42_layoutstat_done,\n\t.rpc_release = nfs42_layoutstat_release,\n};\n\nint nfs42_proc_layoutstats_generic(struct nfs_server *server,\n\t\t\t\t   struct nfs42_layoutstat_data *data)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LAYOUTSTATS],\n\t\t.rpc_argp = &data->args,\n\t\t.rpc_resp = &data->res,\n\t};\n\tstruct rpc_task_setup task_setup = {\n\t\t.rpc_client = server->client,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs42_layoutstat_ops,\n\t\t.callback_data = data,\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\tstruct rpc_task *task;\n\n\tdata->inode = nfs_igrab_and_active(data->args.inode);\n\tif (!data->inode) {\n\t\tnfs42_layoutstat_release(data);\n\t\treturn -EAGAIN;\n\t}\n\tnfs4_init_sequence(&data->args.seq_args, &data->res.seq_res, 0, 0);\n\ttask = rpc_run_task(&task_setup);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\trpc_put_task(task);\n\treturn 0;\n}\n\nstatic struct nfs42_layouterror_data *\nnfs42_alloc_layouterror_data(struct pnfs_layout_segment *lseg, gfp_t gfp_flags)\n{\n\tstruct nfs42_layouterror_data *data;\n\tstruct inode *inode = lseg->pls_layout->plh_inode;\n\n\tdata = kzalloc(sizeof(*data), gfp_flags);\n\tif (data) {\n\t\tdata->args.inode = data->inode = nfs_igrab_and_active(inode);\n\t\tif (data->inode) {\n\t\t\tdata->lseg = pnfs_get_lseg(lseg);\n\t\t\tif (data->lseg)\n\t\t\t\treturn data;\n\t\t\tnfs_iput_and_deactive(data->inode);\n\t\t}\n\t\tkfree(data);\n\t}\n\treturn NULL;\n}\n\nstatic void\nnfs42_free_layouterror_data(struct nfs42_layouterror_data *data)\n{\n\tpnfs_put_lseg(data->lseg);\n\tnfs_iput_and_deactive(data->inode);\n\tkfree(data);\n}\n\nstatic void\nnfs42_layouterror_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs42_layouterror_data *data = calldata;\n\tstruct inode *inode = data->inode;\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct pnfs_layout_hdr *lo = data->lseg->pls_layout;\n\tunsigned i;\n\n\tspin_lock(&inode->i_lock);\n\tif (!pnfs_layout_is_valid(lo)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\trpc_exit(task, 0);\n\t\treturn;\n\t}\n\tfor (i = 0; i < data->args.num_errors; i++)\n\t\tnfs4_stateid_copy(&data->args.errors[i].stateid,\n\t\t\t\t&lo->plh_stateid);\n\tspin_unlock(&inode->i_lock);\n\tnfs4_setup_sequence(server->nfs_client, &data->args.seq_args,\n\t\t\t    &data->res.seq_res, task);\n}\n\nstatic void\nnfs42_layouterror_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs42_layouterror_data *data = calldata;\n\tstruct inode *inode = data->inode;\n\tstruct pnfs_layout_hdr *lo = data->lseg->pls_layout;\n\n\tif (!nfs4_sequence_done(task, &data->res.seq_res))\n\t\treturn;\n\n\tswitch (task->tk_status) {\n\tcase 0:\n\t\treturn;\n\tcase -NFS4ERR_BADHANDLE:\n\tcase -ESTALE:\n\t\tpnfs_destroy_layout(NFS_I(inode));\n\t\tbreak;\n\tcase -NFS4ERR_EXPIRED:\n\tcase -NFS4ERR_ADMIN_REVOKED:\n\tcase -NFS4ERR_DELEG_REVOKED:\n\tcase -NFS4ERR_STALE_STATEID:\n\tcase -NFS4ERR_BAD_STATEID:\n\t\tspin_lock(&inode->i_lock);\n\t\tif (pnfs_layout_is_valid(lo) &&\n\t\t    nfs4_stateid_match(&data->args.errors[0].stateid,\n\t\t\t\t\t     &lo->plh_stateid)) {\n\t\t\tLIST_HEAD(head);\n\n\t\t\t \n\t\t\tpnfs_mark_layout_stateid_invalid(lo, &head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tpnfs_free_lseg_list(&head);\n\t\t\tnfs_commit_inode(inode, 0);\n\t\t} else\n\t\t\tspin_unlock(&inode->i_lock);\n\t\tbreak;\n\tcase -NFS4ERR_OLD_STATEID:\n\t\tspin_lock(&inode->i_lock);\n\t\tif (pnfs_layout_is_valid(lo) &&\n\t\t    nfs4_stateid_match_other(&data->args.errors[0].stateid,\n\t\t\t\t\t&lo->plh_stateid)) {\n\t\t\t \n\t\t\tif (!nfs4_stateid_is_newer(&lo->plh_stateid,\n\t\t\t\t\t\t&data->args.errors[0].stateid))\n\t\t\t\trpc_delay(task, HZ);\n\t\t\trpc_restart_call_prepare(task);\n\t\t}\n\t\tspin_unlock(&inode->i_lock);\n\t\tbreak;\n\tcase -ENOTSUPP:\n\tcase -EOPNOTSUPP:\n\t\tNFS_SERVER(inode)->caps &= ~NFS_CAP_LAYOUTERROR;\n\t}\n\n\ttrace_nfs4_layouterror(inode, &data->args.errors[0].stateid,\n\t\t\t       task->tk_status);\n}\n\nstatic void\nnfs42_layouterror_release(void *calldata)\n{\n\tstruct nfs42_layouterror_data *data = calldata;\n\n\tnfs42_free_layouterror_data(data);\n}\n\nstatic const struct rpc_call_ops nfs42_layouterror_ops = {\n\t.rpc_call_prepare = nfs42_layouterror_prepare,\n\t.rpc_call_done = nfs42_layouterror_done,\n\t.rpc_release = nfs42_layouterror_release,\n};\n\nint nfs42_proc_layouterror(struct pnfs_layout_segment *lseg,\n\t\tconst struct nfs42_layout_error *errors, size_t n)\n{\n\tstruct inode *inode = lseg->pls_layout->plh_inode;\n\tstruct nfs42_layouterror_data *data;\n\tstruct rpc_task *task;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LAYOUTERROR],\n\t};\n\tstruct rpc_task_setup task_setup = {\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs42_layouterror_ops,\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\tunsigned int i;\n\n\tif (!nfs_server_capable(inode, NFS_CAP_LAYOUTERROR))\n\t\treturn -EOPNOTSUPP;\n\tif (n > NFS42_LAYOUTERROR_MAX)\n\t\treturn -EINVAL;\n\tdata = nfs42_alloc_layouterror_data(lseg, nfs_io_gfp_mask());\n\tif (!data)\n\t\treturn -ENOMEM;\n\tfor (i = 0; i < n; i++) {\n\t\tdata->args.errors[i] = errors[i];\n\t\tdata->args.num_errors++;\n\t\tdata->res.num_errors++;\n\t}\n\tmsg.rpc_argp = &data->args;\n\tmsg.rpc_resp = &data->res;\n\ttask_setup.callback_data = data;\n\ttask_setup.rpc_client = NFS_SERVER(inode)->client;\n\tnfs4_init_sequence(&data->args.seq_args, &data->res.seq_res, 0, 0);\n\ttask = rpc_run_task(&task_setup);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\trpc_put_task(task);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nfs42_proc_layouterror);\n\nstatic int _nfs42_proc_clone(struct rpc_message *msg, struct file *src_f,\n\t\tstruct file *dst_f, struct nfs_lock_context *src_lock,\n\t\tstruct nfs_lock_context *dst_lock, loff_t src_offset,\n\t\tloff_t dst_offset, loff_t count)\n{\n\tstruct inode *src_inode = file_inode(src_f);\n\tstruct inode *dst_inode = file_inode(dst_f);\n\tstruct nfs_server *server = NFS_SERVER(dst_inode);\n\t__u32 dst_bitmask[NFS_BITMASK_SZ];\n\tstruct nfs42_clone_args args = {\n\t\t.src_fh = NFS_FH(src_inode),\n\t\t.dst_fh = NFS_FH(dst_inode),\n\t\t.src_offset = src_offset,\n\t\t.dst_offset = dst_offset,\n\t\t.count = count,\n\t\t.dst_bitmask = dst_bitmask,\n\t};\n\tstruct nfs42_clone_res res = {\n\t\t.server\t= server,\n\t};\n\tint status;\n\n\tmsg->rpc_argp = &args;\n\tmsg->rpc_resp = &res;\n\n\tstatus = nfs4_set_rw_stateid(&args.src_stateid, src_lock->open_context,\n\t\t\tsrc_lock, FMODE_READ);\n\tif (status) {\n\t\tif (status == -EAGAIN)\n\t\t\tstatus = -NFS4ERR_BAD_STATEID;\n\t\treturn status;\n\t}\n\tstatus = nfs4_set_rw_stateid(&args.dst_stateid, dst_lock->open_context,\n\t\t\tdst_lock, FMODE_WRITE);\n\tif (status) {\n\t\tif (status == -EAGAIN)\n\t\t\tstatus = -NFS4ERR_BAD_STATEID;\n\t\treturn status;\n\t}\n\n\tres.dst_fattr = nfs_alloc_fattr();\n\tif (!res.dst_fattr)\n\t\treturn -ENOMEM;\n\n\tnfs4_bitmask_set(dst_bitmask, server->cache_consistency_bitmask,\n\t\t\t dst_inode, NFS_INO_INVALID_BLOCKS);\n\n\tstatus = nfs4_call_sync(server->client, server, msg,\n\t\t\t\t&args.seq_args, &res.seq_res, 0);\n\ttrace_nfs4_clone(src_inode, dst_inode, &args, status);\n\tif (status == 0) {\n\t\t \n\t\tif (count == 0 && res.dst_fattr->valid & NFS_ATTR_FATTR_SIZE)\n\t\t\tcount = nfs_size_to_loff_t(res.dst_fattr->size) - dst_offset;\n\t\tnfs42_copy_dest_done(dst_inode, dst_offset, count);\n\t\tstatus = nfs_post_op_update_inode(dst_inode, res.dst_fattr);\n\t}\n\n\tkfree(res.dst_fattr);\n\treturn status;\n}\n\nint nfs42_proc_clone(struct file *src_f, struct file *dst_f,\n\t\t     loff_t src_offset, loff_t dst_offset, loff_t count)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_CLONE],\n\t};\n\tstruct inode *inode = file_inode(src_f);\n\tstruct nfs_server *server = NFS_SERVER(file_inode(src_f));\n\tstruct nfs_lock_context *src_lock;\n\tstruct nfs_lock_context *dst_lock;\n\tstruct nfs4_exception src_exception = { };\n\tstruct nfs4_exception dst_exception = { };\n\tint err, err2;\n\n\tif (!nfs_server_capable(inode, NFS_CAP_CLONE))\n\t\treturn -EOPNOTSUPP;\n\n\tsrc_lock = nfs_get_lock_context(nfs_file_open_context(src_f));\n\tif (IS_ERR(src_lock))\n\t\treturn PTR_ERR(src_lock);\n\n\tsrc_exception.inode = file_inode(src_f);\n\tsrc_exception.state = src_lock->open_context->state;\n\n\tdst_lock = nfs_get_lock_context(nfs_file_open_context(dst_f));\n\tif (IS_ERR(dst_lock)) {\n\t\terr = PTR_ERR(dst_lock);\n\t\tgoto out_put_src_lock;\n\t}\n\n\tdst_exception.inode = file_inode(dst_f);\n\tdst_exception.state = dst_lock->open_context->state;\n\n\tdo {\n\t\terr = _nfs42_proc_clone(&msg, src_f, dst_f, src_lock, dst_lock,\n\t\t\t\t\tsrc_offset, dst_offset, count);\n\t\tif (err == -ENOTSUPP || err == -EOPNOTSUPP) {\n\t\t\tNFS_SERVER(inode)->caps &= ~NFS_CAP_CLONE;\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tbreak;\n\t\t}\n\n\t\terr2 = nfs4_handle_exception(server, err, &src_exception);\n\t\terr = nfs4_handle_exception(server, err, &dst_exception);\n\t\tif (!err)\n\t\t\terr = err2;\n\t} while (src_exception.retry || dst_exception.retry);\n\n\tnfs_put_lock_context(dst_lock);\nout_put_src_lock:\n\tnfs_put_lock_context(src_lock);\n\treturn err;\n}\n\n#define NFS4XATTR_MAXPAGES DIV_ROUND_UP(XATTR_SIZE_MAX, PAGE_SIZE)\n\nstatic int _nfs42_proc_removexattr(struct inode *inode, const char *name)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs42_removexattrargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.xattr_name = name,\n\t};\n\tstruct nfs42_removexattrres res;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_REMOVEXATTR],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tint ret;\n\tunsigned long timestamp = jiffies;\n\n\tret = nfs4_call_sync(server->client, server, &msg, &args.seq_args,\n\t    &res.seq_res, 1);\n\ttrace_nfs4_removexattr(inode, name, ret);\n\tif (!ret)\n\t\tnfs4_update_changeattr(inode, &res.cinfo, timestamp, 0);\n\n\treturn ret;\n}\n\nstatic int _nfs42_proc_setxattr(struct inode *inode, const char *name,\n\t\t\t\tconst void *buf, size_t buflen, int flags)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\t__u32 bitmask[NFS_BITMASK_SZ];\n\tstruct page *pages[NFS4XATTR_MAXPAGES];\n\tstruct nfs42_setxattrargs arg = {\n\t\t.fh\t\t= NFS_FH(inode),\n\t\t.bitmask\t= bitmask,\n\t\t.xattr_pages\t= pages,\n\t\t.xattr_len\t= buflen,\n\t\t.xattr_name\t= name,\n\t\t.xattr_flags\t= flags,\n\t};\n\tstruct nfs42_setxattrres res = {\n\t\t.server\t\t= server,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs4_procedures[NFSPROC4_CLNT_SETXATTR],\n\t\t.rpc_argp\t= &arg,\n\t\t.rpc_resp\t= &res,\n\t};\n\tint ret, np;\n\tunsigned long timestamp = jiffies;\n\n\tif (buflen > server->sxasize)\n\t\treturn -ERANGE;\n\n\tres.fattr = nfs_alloc_fattr();\n\tif (!res.fattr)\n\t\treturn -ENOMEM;\n\n\tif (buflen > 0) {\n\t\tnp = nfs4_buf_to_pages_noslab(buf, buflen, arg.xattr_pages);\n\t\tif (np < 0) {\n\t\t\tret = np;\n\t\t\tgoto out;\n\t\t}\n\t} else\n\t\tnp = 0;\n\n\tnfs4_bitmask_set(bitmask, server->cache_consistency_bitmask,\n\t\t\t inode, NFS_INO_INVALID_CHANGE);\n\n\tret = nfs4_call_sync(server->client, server, &msg, &arg.seq_args,\n\t    &res.seq_res, 1);\n\ttrace_nfs4_setxattr(inode, name, ret);\n\n\tfor (; np > 0; np--)\n\t\tput_page(pages[np - 1]);\n\n\tif (!ret) {\n\t\tnfs4_update_changeattr(inode, &res.cinfo, timestamp, 0);\n\t\tret = nfs_post_op_update_inode(inode, res.fattr);\n\t}\n\nout:\n\tkfree(res.fattr);\n\treturn ret;\n}\n\nstatic ssize_t _nfs42_proc_getxattr(struct inode *inode, const char *name,\n\t\t\t\tvoid *buf, size_t buflen, struct page **pages,\n\t\t\t\tsize_t plen)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs42_getxattrargs arg = {\n\t\t.fh\t\t= NFS_FH(inode),\n\t\t.xattr_name\t= name,\n\t};\n\tstruct nfs42_getxattrres res;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs4_procedures[NFSPROC4_CLNT_GETXATTR],\n\t\t.rpc_argp\t= &arg,\n\t\t.rpc_resp\t= &res,\n\t};\n\tssize_t ret;\n\n\targ.xattr_len = plen;\n\targ.xattr_pages = pages;\n\n\tret = nfs4_call_sync(server->client, server, &msg, &arg.seq_args,\n\t    &res.seq_res, 0);\n\ttrace_nfs4_getxattr(inode, name, ret);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\n\tnfs4_xattr_cache_add(inode, name, NULL, pages, res.xattr_len);\n\n\tif (buflen) {\n\t\tif (res.xattr_len > buflen)\n\t\t\treturn -ERANGE;\n\t\t_copy_from_pages(buf, pages, 0, res.xattr_len);\n\t}\n\n\treturn res.xattr_len;\n}\n\nstatic ssize_t _nfs42_proc_listxattrs(struct inode *inode, void *buf,\n\t\t\t\t size_t buflen, u64 *cookiep, bool *eofp)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct page **pages;\n\tstruct nfs42_listxattrsargs arg = {\n\t\t.fh\t\t= NFS_FH(inode),\n\t\t.cookie\t\t= *cookiep,\n\t};\n\tstruct nfs42_listxattrsres res = {\n\t\t.eof = false,\n\t\t.xattr_buf = buf,\n\t\t.xattr_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs4_procedures[NFSPROC4_CLNT_LISTXATTRS],\n\t\t.rpc_argp\t= &arg,\n\t\t.rpc_resp\t= &res,\n\t};\n\tu32 xdrlen;\n\tint ret, np, i;\n\n\n\tret = -ENOMEM;\n\tres.scratch = alloc_page(GFP_KERNEL);\n\tif (!res.scratch)\n\t\tgoto out;\n\n\txdrlen = nfs42_listxattr_xdrsize(buflen);\n\tif (xdrlen > server->lxasize)\n\t\txdrlen = server->lxasize;\n\tnp = xdrlen / PAGE_SIZE + 1;\n\n\tpages = kcalloc(np, sizeof(struct page *), GFP_KERNEL);\n\tif (!pages)\n\t\tgoto out_free_scratch;\n\tfor (i = 0; i < np; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free_pages;\n\t}\n\n\targ.xattr_pages = pages;\n\targ.count = xdrlen;\n\n\tret = nfs4_call_sync(server->client, server, &msg, &arg.seq_args,\n\t    &res.seq_res, 0);\n\ttrace_nfs4_listxattr(inode, ret);\n\n\tif (ret >= 0) {\n\t\tret = res.copied;\n\t\t*cookiep = res.cookie;\n\t\t*eofp = res.eof;\n\t}\n\nout_free_pages:\n\twhile (--np >= 0) {\n\t\tif (pages[np])\n\t\t\t__free_page(pages[np]);\n\t}\n\tkfree(pages);\nout_free_scratch:\n\t__free_page(res.scratch);\nout:\n\treturn ret;\n\n}\n\nssize_t nfs42_proc_getxattr(struct inode *inode, const char *name,\n\t\t\t      void *buf, size_t buflen)\n{\n\tstruct nfs4_exception exception = { };\n\tssize_t err, np, i;\n\tstruct page **pages;\n\n\tnp = nfs_page_array_len(0, buflen ?: XATTR_SIZE_MAX);\n\tpages = kmalloc_array(np, sizeof(*pages), GFP_KERNEL);\n\tif (!pages)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < np; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i]) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tdo {\n\t\terr = _nfs42_proc_getxattr(inode, name, buf, buflen,\n\t\t\tpages, np * PAGE_SIZE);\n\t\tif (err >= 0)\n\t\t\tbreak;\n\t\terr = nfs4_handle_exception(NFS_SERVER(inode), err,\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\nout:\n\twhile (--i >= 0)\n\t\t__free_page(pages[i]);\n\tkfree(pages);\n\n\treturn err;\n}\n\nint nfs42_proc_setxattr(struct inode *inode, const char *name,\n\t\t\t      const void *buf, size_t buflen, int flags)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\n\tdo {\n\t\terr = _nfs42_proc_setxattr(inode, name, buf, buflen, flags);\n\t\tif (!err)\n\t\t\tbreak;\n\t\terr = nfs4_handle_exception(NFS_SERVER(inode), err,\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\n\treturn err;\n}\n\nssize_t nfs42_proc_listxattrs(struct inode *inode, void *buf,\n\t\t\t      size_t buflen, u64 *cookiep, bool *eofp)\n{\n\tstruct nfs4_exception exception = { };\n\tssize_t err;\n\n\tdo {\n\t\terr = _nfs42_proc_listxattrs(inode, buf, buflen,\n\t\t    cookiep, eofp);\n\t\tif (err >= 0)\n\t\t\tbreak;\n\t\terr = nfs4_handle_exception(NFS_SERVER(inode), err,\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\n\treturn err;\n}\n\nint nfs42_proc_removexattr(struct inode *inode, const char *name)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\n\tdo {\n\t\terr = _nfs42_proc_removexattr(inode, name);\n\t\tif (!err)\n\t\t\tbreak;\n\t\terr = nfs4_handle_exception(NFS_SERVER(inode), err,\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}