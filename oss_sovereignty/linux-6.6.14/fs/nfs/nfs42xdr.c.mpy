{
  "module_name": "nfs42xdr.c",
  "hash_id": "2de6d3f5293033ed332edeac0c103da57dc6dd7f505abdd355dd6c096880ebf1",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfs/nfs42xdr.c",
  "human_readable_source": "\n \n#ifndef __LINUX_FS_NFS_NFS4_2XDR_H\n#define __LINUX_FS_NFS_NFS4_2XDR_H\n\n#include \"nfs42.h\"\n\n \n#define nfs4_xattr_name_maxsz   XDR_QUADLEN(XATTR_NAME_MAX)\n\n#define encode_fallocate_maxsz\t\t(encode_stateid_maxsz + \\\n\t\t\t\t\t 2   + \\\n\t\t\t\t\t 2  )\n#define NFS42_WRITE_RES_SIZE\t\t(1   +\\\n\t\t\t\t\t XDR_QUADLEN(NFS4_STATEID_SIZE) + \\\n\t\t\t\t\t 2   + \\\n\t\t\t\t\t 1   + \\\n\t\t\t\t\t XDR_QUADLEN(NFS4_VERIFIER_SIZE))\n#define encode_allocate_maxsz\t\t(op_encode_hdr_maxsz + \\\n\t\t\t\t\t encode_fallocate_maxsz)\n#define decode_allocate_maxsz\t\t(op_decode_hdr_maxsz)\n#define encode_copy_maxsz\t\t(op_encode_hdr_maxsz +          \\\n\t\t\t\t\t XDR_QUADLEN(NFS4_STATEID_SIZE) + \\\n\t\t\t\t\t XDR_QUADLEN(NFS4_STATEID_SIZE) + \\\n\t\t\t\t\t 2 + 2 + 2 + 1 + 1 + 1 +\\\n\t\t\t\t\t 1 +  \\\n\t\t\t\t\t 1 +   \\\n\t\t\t\t\t 1 + XDR_QUADLEN(NFS4_OPAQUE_LIMIT))\n#define decode_copy_maxsz\t\t(op_decode_hdr_maxsz + \\\n\t\t\t\t\t NFS42_WRITE_RES_SIZE + \\\n\t\t\t\t\t 1   + \\\n\t\t\t\t\t 1  )\n#define encode_offload_cancel_maxsz\t(op_encode_hdr_maxsz + \\\n\t\t\t\t\t XDR_QUADLEN(NFS4_STATEID_SIZE))\n#define decode_offload_cancel_maxsz\t(op_decode_hdr_maxsz)\n#define encode_copy_notify_maxsz\t(op_encode_hdr_maxsz + \\\n\t\t\t\t\t XDR_QUADLEN(NFS4_STATEID_SIZE) + \\\n\t\t\t\t\t 1 +   \\\n\t\t\t\t\t 1 + XDR_QUADLEN(NFS4_OPAQUE_LIMIT))\n#define decode_copy_notify_maxsz\t(op_decode_hdr_maxsz + \\\n\t\t\t\t\t 3 +  \\\n\t\t\t\t\t XDR_QUADLEN(NFS4_STATEID_SIZE) + \\\n\t\t\t\t\t 1 +  \\\n\t\t\t\t\t 1 +   \\\n\t\t\t\t\t 1 + XDR_QUADLEN(NFS4_OPAQUE_LIMIT))\n#define encode_deallocate_maxsz\t\t(op_encode_hdr_maxsz + \\\n\t\t\t\t\t encode_fallocate_maxsz)\n#define decode_deallocate_maxsz\t\t(op_decode_hdr_maxsz)\n#define encode_read_plus_maxsz\t\t(op_encode_hdr_maxsz + \\\n\t\t\t\t\t encode_stateid_maxsz + 3)\n#define NFS42_READ_PLUS_DATA_SEGMENT_SIZE \\\n\t\t\t\t\t(1   + \\\n\t\t\t\t\t 2   + \\\n\t\t\t\t\t 1  )\n#define NFS42_READ_PLUS_HOLE_SEGMENT_SIZE \\\n\t\t\t\t\t(1   + \\\n\t\t\t\t\t 2   + \\\n\t\t\t\t\t 2  )\n#define READ_PLUS_SEGMENT_SIZE_DIFF\t(NFS42_READ_PLUS_HOLE_SEGMENT_SIZE - \\\n\t\t\t\t\t NFS42_READ_PLUS_DATA_SEGMENT_SIZE)\n#define decode_read_plus_maxsz\t\t(op_decode_hdr_maxsz + \\\n\t\t\t\t\t 1   + \\\n\t\t\t\t\t 1   + \\\n\t\t\t\t\t NFS42_READ_PLUS_HOLE_SEGMENT_SIZE)\n#define encode_seek_maxsz\t\t(op_encode_hdr_maxsz + \\\n\t\t\t\t\t encode_stateid_maxsz + \\\n\t\t\t\t\t 2   + \\\n\t\t\t\t\t 1  )\n#define decode_seek_maxsz\t\t(op_decode_hdr_maxsz + \\\n\t\t\t\t\t 1   + \\\n\t\t\t\t\t 1   + \\\n\t\t\t\t\t 2   + \\\n\t\t\t\t\t 2  )\n#define encode_io_info_maxsz\t\t4\n#define encode_layoutstats_maxsz\t(op_decode_hdr_maxsz + \\\n\t\t\t\t\t2   + \\\n\t\t\t\t\t2   + \\\n\t\t\t\t\tencode_stateid_maxsz + \\\n\t\t\t\t\tencode_io_info_maxsz + \\\n\t\t\t\t\tencode_io_info_maxsz + \\\n\t\t\t\t\t1   + \\\n\t\t\t\t\tXDR_QUADLEN(PNFS_LAYOUTSTATS_MAXSIZE))\n#define decode_layoutstats_maxsz\t(op_decode_hdr_maxsz)\n#define encode_device_error_maxsz\t(XDR_QUADLEN(NFS4_DEVICEID4_SIZE) + \\\n\t\t\t\t\t1   + 1  )\n#define encode_layouterror_maxsz\t(op_decode_hdr_maxsz + \\\n\t\t\t\t\t2   + \\\n\t\t\t\t\t2   + \\\n\t\t\t\t\tencode_stateid_maxsz + \\\n\t\t\t\t\t1   + \\\n\t\t\t\t\tencode_device_error_maxsz)\n#define decode_layouterror_maxsz\t(op_decode_hdr_maxsz)\n#define encode_clone_maxsz\t\t(encode_stateid_maxsz + \\\n\t\t\t\t\tencode_stateid_maxsz + \\\n\t\t\t\t\t2   + \\\n\t\t\t\t\t2   + \\\n\t\t\t\t\t2  )\n#define decode_clone_maxsz\t\t(op_decode_hdr_maxsz)\n#define encode_getxattr_maxsz\t\t(op_encode_hdr_maxsz + 1 + \\\n\t\t\t\t\t nfs4_xattr_name_maxsz)\n#define decode_getxattr_maxsz\t\t(op_decode_hdr_maxsz + 1 + pagepad_maxsz)\n#define encode_setxattr_maxsz\t\t(op_encode_hdr_maxsz + \\\n\t\t\t\t\t 1 + nfs4_xattr_name_maxsz + 1)\n#define decode_setxattr_maxsz\t\t(op_decode_hdr_maxsz + decode_change_info_maxsz)\n#define encode_listxattrs_maxsz\t\t(op_encode_hdr_maxsz + 2 + 1)\n#define decode_listxattrs_maxsz\t\t(op_decode_hdr_maxsz + 2 + 1 + 1 + 1)\n#define encode_removexattr_maxsz\t(op_encode_hdr_maxsz + 1 + \\\n\t\t\t\t\t nfs4_xattr_name_maxsz)\n#define decode_removexattr_maxsz\t(op_decode_hdr_maxsz + \\\n\t\t\t\t\t decode_change_info_maxsz)\n\n#define NFS4_enc_allocate_sz\t\t(compound_encode_hdr_maxsz + \\\n\t\t\t\t\t encode_sequence_maxsz + \\\n\t\t\t\t\t encode_putfh_maxsz + \\\n\t\t\t\t\t encode_allocate_maxsz + \\\n\t\t\t\t\t encode_getattr_maxsz)\n#define NFS4_dec_allocate_sz\t\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t\t decode_sequence_maxsz + \\\n\t\t\t\t\t decode_putfh_maxsz + \\\n\t\t\t\t\t decode_allocate_maxsz + \\\n\t\t\t\t\t decode_getattr_maxsz)\n#define NFS4_enc_copy_sz\t\t(compound_encode_hdr_maxsz + \\\n\t\t\t\t\t encode_sequence_maxsz + \\\n\t\t\t\t\t encode_putfh_maxsz + \\\n\t\t\t\t\t encode_savefh_maxsz + \\\n\t\t\t\t\t encode_putfh_maxsz + \\\n\t\t\t\t\t encode_copy_maxsz + \\\n\t\t\t\t\t encode_commit_maxsz)\n#define NFS4_dec_copy_sz\t\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t\t decode_sequence_maxsz + \\\n\t\t\t\t\t decode_putfh_maxsz + \\\n\t\t\t\t\t decode_savefh_maxsz + \\\n\t\t\t\t\t decode_putfh_maxsz + \\\n\t\t\t\t\t decode_copy_maxsz + \\\n\t\t\t\t\t decode_commit_maxsz)\n#define NFS4_enc_offload_cancel_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\t\t encode_sequence_maxsz + \\\n\t\t\t\t\t encode_putfh_maxsz + \\\n\t\t\t\t\t encode_offload_cancel_maxsz)\n#define NFS4_dec_offload_cancel_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t\t decode_sequence_maxsz + \\\n\t\t\t\t\t decode_putfh_maxsz + \\\n\t\t\t\t\t decode_offload_cancel_maxsz)\n#define NFS4_enc_copy_notify_sz\t\t(compound_encode_hdr_maxsz + \\\n\t\t\t\t\t encode_putfh_maxsz + \\\n\t\t\t\t\t encode_copy_notify_maxsz)\n#define NFS4_dec_copy_notify_sz\t\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t\t decode_putfh_maxsz + \\\n\t\t\t\t\t decode_copy_notify_maxsz)\n#define NFS4_enc_deallocate_sz\t\t(compound_encode_hdr_maxsz + \\\n\t\t\t\t\t encode_sequence_maxsz + \\\n\t\t\t\t\t encode_putfh_maxsz + \\\n\t\t\t\t\t encode_deallocate_maxsz + \\\n\t\t\t\t\t encode_getattr_maxsz)\n#define NFS4_dec_deallocate_sz\t\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t\t decode_sequence_maxsz + \\\n\t\t\t\t\t decode_putfh_maxsz + \\\n\t\t\t\t\t decode_deallocate_maxsz + \\\n\t\t\t\t\t decode_getattr_maxsz)\n#define NFS4_enc_read_plus_sz\t\t(compound_encode_hdr_maxsz + \\\n\t\t\t\t\t encode_sequence_maxsz + \\\n\t\t\t\t\t encode_putfh_maxsz + \\\n\t\t\t\t\t encode_read_plus_maxsz)\n#define NFS4_dec_read_plus_sz\t\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t\t decode_sequence_maxsz + \\\n\t\t\t\t\t decode_putfh_maxsz + \\\n\t\t\t\t\t decode_read_plus_maxsz)\n#define NFS4_enc_seek_sz\t\t(compound_encode_hdr_maxsz + \\\n\t\t\t\t\t encode_sequence_maxsz + \\\n\t\t\t\t\t encode_putfh_maxsz + \\\n\t\t\t\t\t encode_seek_maxsz)\n#define NFS4_dec_seek_sz\t\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t\t decode_sequence_maxsz + \\\n\t\t\t\t\t decode_putfh_maxsz + \\\n\t\t\t\t\t decode_seek_maxsz)\n#define NFS4_enc_layoutstats_sz\t\t(compound_encode_hdr_maxsz + \\\n\t\t\t\t\t encode_sequence_maxsz + \\\n\t\t\t\t\t encode_putfh_maxsz + \\\n\t\t\t\t\t PNFS_LAYOUTSTATS_MAXDEV * encode_layoutstats_maxsz)\n#define NFS4_dec_layoutstats_sz\t\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t\t decode_sequence_maxsz + \\\n\t\t\t\t\t decode_putfh_maxsz + \\\n\t\t\t\t\t PNFS_LAYOUTSTATS_MAXDEV * decode_layoutstats_maxsz)\n#define NFS4_enc_layouterror_sz\t\t(compound_encode_hdr_maxsz + \\\n\t\t\t\t\t encode_sequence_maxsz + \\\n\t\t\t\t\t encode_putfh_maxsz + \\\n\t\t\t\t\t NFS42_LAYOUTERROR_MAX * \\\n\t\t\t\t\t encode_layouterror_maxsz)\n#define NFS4_dec_layouterror_sz\t\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t\t decode_sequence_maxsz + \\\n\t\t\t\t\t decode_putfh_maxsz + \\\n\t\t\t\t\t NFS42_LAYOUTERROR_MAX * \\\n\t\t\t\t\t decode_layouterror_maxsz)\n#define NFS4_enc_clone_sz\t\t(compound_encode_hdr_maxsz + \\\n\t\t\t\t\t encode_sequence_maxsz + \\\n\t\t\t\t\t encode_putfh_maxsz + \\\n\t\t\t\t\t encode_savefh_maxsz + \\\n\t\t\t\t\t encode_putfh_maxsz + \\\n\t\t\t\t\t encode_clone_maxsz + \\\n\t\t\t\t\t encode_getattr_maxsz)\n#define NFS4_dec_clone_sz\t\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t\t decode_sequence_maxsz + \\\n\t\t\t\t\t decode_putfh_maxsz + \\\n\t\t\t\t\t decode_savefh_maxsz + \\\n\t\t\t\t\t decode_putfh_maxsz + \\\n\t\t\t\t\t decode_clone_maxsz + \\\n\t\t\t\t\t decode_getattr_maxsz)\n#define NFS4_enc_getxattr_sz\t\t(compound_encode_hdr_maxsz + \\\n\t\t\t\t\t encode_sequence_maxsz + \\\n\t\t\t\t\t encode_putfh_maxsz + \\\n\t\t\t\t\t encode_getxattr_maxsz)\n#define NFS4_dec_getxattr_sz\t\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t\t decode_sequence_maxsz + \\\n\t\t\t\t\t decode_putfh_maxsz + \\\n\t\t\t\t\t decode_getxattr_maxsz)\n#define NFS4_enc_setxattr_sz\t\t(compound_encode_hdr_maxsz + \\\n\t\t\t\t\t encode_sequence_maxsz + \\\n\t\t\t\t\t encode_putfh_maxsz + \\\n\t\t\t\t\t encode_setxattr_maxsz + \\\n\t\t\t\t\t encode_getattr_maxsz)\n#define NFS4_dec_setxattr_sz\t\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t\t decode_sequence_maxsz + \\\n\t\t\t\t\t decode_putfh_maxsz + \\\n\t\t\t\t\t decode_setxattr_maxsz + \\\n\t\t\t\t\t decode_getattr_maxsz)\n#define NFS4_enc_listxattrs_sz\t\t(compound_encode_hdr_maxsz + \\\n\t\t\t\t\t encode_sequence_maxsz + \\\n\t\t\t\t\t encode_putfh_maxsz + \\\n\t\t\t\t\t encode_listxattrs_maxsz)\n#define NFS4_dec_listxattrs_sz\t\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t\t decode_sequence_maxsz + \\\n\t\t\t\t\t decode_putfh_maxsz + \\\n\t\t\t\t\t decode_listxattrs_maxsz)\n#define NFS4_enc_removexattr_sz\t\t(compound_encode_hdr_maxsz + \\\n\t\t\t\t\t encode_sequence_maxsz + \\\n\t\t\t\t\t encode_putfh_maxsz + \\\n\t\t\t\t\t encode_removexattr_maxsz)\n#define NFS4_dec_removexattr_sz\t\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t\t decode_sequence_maxsz + \\\n\t\t\t\t\t decode_putfh_maxsz + \\\n\t\t\t\t\t decode_removexattr_maxsz)\n\n \nconst u32 nfs42_maxsetxattr_overhead = ((RPC_MAX_HEADER_WITH_AUTH +\n\t\t\t\t\tcompound_encode_hdr_maxsz +\n\t\t\t\t\tencode_sequence_maxsz +\n\t\t\t\t\tencode_putfh_maxsz + 1 +\n\t\t\t\t\tnfs4_xattr_name_maxsz)\n\t\t\t\t\t* XDR_UNIT);\n\nconst u32 nfs42_maxgetxattr_overhead = ((RPC_MAX_HEADER_WITH_AUTH +\n\t\t\t\t\tcompound_decode_hdr_maxsz +\n\t\t\t\t\tdecode_sequence_maxsz +\n\t\t\t\t\tdecode_putfh_maxsz + 1) * XDR_UNIT);\n\nconst u32 nfs42_maxlistxattrs_overhead = ((RPC_MAX_HEADER_WITH_AUTH +\n\t\t\t\t\tcompound_decode_hdr_maxsz +\n\t\t\t\t\tdecode_sequence_maxsz +\n\t\t\t\t\tdecode_putfh_maxsz + 3) * XDR_UNIT);\n\nstatic void encode_fallocate(struct xdr_stream *xdr,\n\t\t\t     const struct nfs42_falloc_args *args)\n{\n\tencode_nfs4_stateid(xdr, &args->falloc_stateid);\n\tencode_uint64(xdr, args->falloc_offset);\n\tencode_uint64(xdr, args->falloc_length);\n}\n\nstatic void encode_allocate(struct xdr_stream *xdr,\n\t\t\t    const struct nfs42_falloc_args *args,\n\t\t\t    struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_ALLOCATE, decode_allocate_maxsz, hdr);\n\tencode_fallocate(xdr, args);\n}\n\nstatic void encode_nl4_server(struct xdr_stream *xdr,\n\t\t\t      const struct nl4_server *ns)\n{\n\tencode_uint32(xdr, ns->nl4_type);\n\tswitch (ns->nl4_type) {\n\tcase NL4_NAME:\n\tcase NL4_URL:\n\t\tencode_string(xdr, ns->u.nl4_str_sz, ns->u.nl4_str);\n\t\tbreak;\n\tcase NL4_NETADDR:\n\t\tencode_string(xdr, ns->u.nl4_addr.netid_len,\n\t\t\t      ns->u.nl4_addr.netid);\n\t\tencode_string(xdr, ns->u.nl4_addr.addr_len,\n\t\t\t      ns->u.nl4_addr.addr);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t}\n}\n\nstatic void encode_copy(struct xdr_stream *xdr,\n\t\t\tconst struct nfs42_copy_args *args,\n\t\t\tstruct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_COPY, decode_copy_maxsz, hdr);\n\tencode_nfs4_stateid(xdr, &args->src_stateid);\n\tencode_nfs4_stateid(xdr, &args->dst_stateid);\n\n\tencode_uint64(xdr, args->src_pos);\n\tencode_uint64(xdr, args->dst_pos);\n\tencode_uint64(xdr, args->count);\n\n\tencode_uint32(xdr, 1);  \n\tencode_uint32(xdr, args->sync);\n\tif (args->cp_src == NULL) {  \n\t\tencode_uint32(xdr, 0);  \n\t\treturn;\n\t}\n\tencode_uint32(xdr, 1);  \n\tencode_nl4_server(xdr, args->cp_src);\n}\n\nstatic void encode_copy_commit(struct xdr_stream *xdr,\n\t\t\t  const struct nfs42_copy_args *args,\n\t\t\t  struct compound_hdr *hdr)\n{\n\t__be32 *p;\n\n\tencode_op_hdr(xdr, OP_COMMIT, decode_commit_maxsz, hdr);\n\tp = reserve_space(xdr, 12);\n\tp = xdr_encode_hyper(p, args->dst_pos);\n\t*p = cpu_to_be32(args->count);\n}\n\nstatic void encode_offload_cancel(struct xdr_stream *xdr,\n\t\t\t\t  const struct nfs42_offload_status_args *args,\n\t\t\t\t  struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_OFFLOAD_CANCEL, decode_offload_cancel_maxsz, hdr);\n\tencode_nfs4_stateid(xdr, &args->osa_stateid);\n}\n\nstatic void encode_copy_notify(struct xdr_stream *xdr,\n\t\t\t       const struct nfs42_copy_notify_args *args,\n\t\t\t       struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_COPY_NOTIFY, decode_copy_notify_maxsz, hdr);\n\tencode_nfs4_stateid(xdr, &args->cna_src_stateid);\n\tencode_nl4_server(xdr, &args->cna_dst);\n}\n\nstatic void encode_deallocate(struct xdr_stream *xdr,\n\t\t\t      const struct nfs42_falloc_args *args,\n\t\t\t      struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_DEALLOCATE, decode_deallocate_maxsz, hdr);\n\tencode_fallocate(xdr, args);\n}\n\nstatic void encode_read_plus(struct xdr_stream *xdr,\n\t\t\t     const struct nfs_pgio_args *args,\n\t\t\t     struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_READ_PLUS, decode_read_plus_maxsz, hdr);\n\tencode_nfs4_stateid(xdr, &args->stateid);\n\tencode_uint64(xdr, args->offset);\n\tencode_uint32(xdr, args->count);\n}\n\nstatic void encode_seek(struct xdr_stream *xdr,\n\t\t\tconst struct nfs42_seek_args *args,\n\t\t\tstruct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_SEEK, decode_seek_maxsz, hdr);\n\tencode_nfs4_stateid(xdr, &args->sa_stateid);\n\tencode_uint64(xdr, args->sa_offset);\n\tencode_uint32(xdr, args->sa_what);\n}\n\nstatic void encode_layoutstats(struct xdr_stream *xdr,\n\t\t\t       const struct nfs42_layoutstat_args *args,\n\t\t\t       struct nfs42_layoutstat_devinfo *devinfo,\n\t\t\t       struct compound_hdr *hdr)\n{\n\t__be32 *p;\n\n\tencode_op_hdr(xdr, OP_LAYOUTSTATS, decode_layoutstats_maxsz, hdr);\n\tp = reserve_space(xdr, 8 + 8);\n\tp = xdr_encode_hyper(p, devinfo->offset);\n\tp = xdr_encode_hyper(p, devinfo->length);\n\tencode_nfs4_stateid(xdr, &args->stateid);\n\tp = reserve_space(xdr, 4*8 + NFS4_DEVICEID4_SIZE + 4);\n\tp = xdr_encode_hyper(p, devinfo->read_count);\n\tp = xdr_encode_hyper(p, devinfo->read_bytes);\n\tp = xdr_encode_hyper(p, devinfo->write_count);\n\tp = xdr_encode_hyper(p, devinfo->write_bytes);\n\tp = xdr_encode_opaque_fixed(p, devinfo->dev_id.data,\n\t\t\tNFS4_DEVICEID4_SIZE);\n\t \n\t*p++ = cpu_to_be32(devinfo->layout_type);\n\tif (devinfo->ld_private.ops)\n\t\tdevinfo->ld_private.ops->encode(xdr, args,\n\t\t\t\t&devinfo->ld_private);\n\telse\n\t\tencode_uint32(xdr, 0);\n}\n\nstatic void encode_clone(struct xdr_stream *xdr,\n\t\t\t const struct nfs42_clone_args *args,\n\t\t\t struct compound_hdr *hdr)\n{\n\t__be32 *p;\n\n\tencode_op_hdr(xdr, OP_CLONE, decode_clone_maxsz, hdr);\n\tencode_nfs4_stateid(xdr, &args->src_stateid);\n\tencode_nfs4_stateid(xdr, &args->dst_stateid);\n\tp = reserve_space(xdr, 3*8);\n\tp = xdr_encode_hyper(p, args->src_offset);\n\tp = xdr_encode_hyper(p, args->dst_offset);\n\txdr_encode_hyper(p, args->count);\n}\n\nstatic void encode_device_error(struct xdr_stream *xdr,\n\t\t\t\tconst struct nfs42_device_error *error)\n{\n\t__be32 *p;\n\n\tp = reserve_space(xdr, NFS4_DEVICEID4_SIZE + 2*4);\n\tp = xdr_encode_opaque_fixed(p, error->dev_id.data,\n\t\t\tNFS4_DEVICEID4_SIZE);\n\t*p++ = cpu_to_be32(error->status);\n\t*p = cpu_to_be32(error->opnum);\n}\n\nstatic void encode_layouterror(struct xdr_stream *xdr,\n\t\t\t       const struct nfs42_layout_error *args,\n\t\t\t       struct compound_hdr *hdr)\n{\n\t__be32 *p;\n\n\tencode_op_hdr(xdr, OP_LAYOUTERROR, decode_layouterror_maxsz, hdr);\n\tp = reserve_space(xdr, 8 + 8);\n\tp = xdr_encode_hyper(p, args->offset);\n\tp = xdr_encode_hyper(p, args->length);\n\tencode_nfs4_stateid(xdr, &args->stateid);\n\tp = reserve_space(xdr, 4);\n\t*p = cpu_to_be32(1);\n\tencode_device_error(xdr, &args->errors[0]);\n}\n\nstatic void encode_setxattr(struct xdr_stream *xdr,\n\t\t\t    const struct nfs42_setxattrargs *arg,\n\t\t\t    struct compound_hdr *hdr)\n{\n\t__be32 *p;\n\n\tBUILD_BUG_ON(XATTR_CREATE != SETXATTR4_CREATE);\n\tBUILD_BUG_ON(XATTR_REPLACE != SETXATTR4_REPLACE);\n\n\tencode_op_hdr(xdr, OP_SETXATTR, decode_setxattr_maxsz, hdr);\n\tp = reserve_space(xdr, 4);\n\t*p = cpu_to_be32(arg->xattr_flags);\n\tencode_string(xdr, strlen(arg->xattr_name), arg->xattr_name);\n\tp = reserve_space(xdr, 4);\n\t*p = cpu_to_be32(arg->xattr_len);\n\tif (arg->xattr_len)\n\t\txdr_write_pages(xdr, arg->xattr_pages, 0, arg->xattr_len);\n}\n\nstatic void encode_getxattr(struct xdr_stream *xdr, const char *name,\n\t\t\t    struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_GETXATTR, decode_getxattr_maxsz, hdr);\n\tencode_string(xdr, strlen(name), name);\n}\n\nstatic void encode_removexattr(struct xdr_stream *xdr, const char *name,\n\t\t\t       struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_REMOVEXATTR, decode_removexattr_maxsz, hdr);\n\tencode_string(xdr, strlen(name), name);\n}\n\nstatic void encode_listxattrs(struct xdr_stream *xdr,\n\t\t\t     const struct nfs42_listxattrsargs *arg,\n\t\t\t     struct compound_hdr *hdr)\n{\n\t__be32 *p;\n\n\tencode_op_hdr(xdr, OP_LISTXATTRS, decode_listxattrs_maxsz, hdr);\n\n\tp = reserve_space(xdr, 12);\n\tif (unlikely(!p))\n\t\treturn;\n\n\tp = xdr_encode_hyper(p, arg->cookie);\n\t \n\t*p = cpu_to_be32(arg->count + 8 + 4);\n}\n\n \nstatic void nfs4_xdr_enc_allocate(struct rpc_rqst *req,\n\t\t\t\t  struct xdr_stream *xdr,\n\t\t\t\t  const void *data)\n{\n\tconst struct nfs42_falloc_args *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->falloc_fh, &hdr);\n\tencode_allocate(xdr, args, &hdr);\n\tencode_getfattr(xdr, args->falloc_bitmask, &hdr);\n\tencode_nops(&hdr);\n}\n\n \nstatic void nfs4_xdr_enc_copy(struct rpc_rqst *req,\n\t\t\t      struct xdr_stream *xdr,\n\t\t\t      const void *data)\n{\n\tconst struct nfs42_copy_args *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->src_fh, &hdr);\n\tencode_savefh(xdr, &hdr);\n\tencode_putfh(xdr, args->dst_fh, &hdr);\n\tencode_copy(xdr, args, &hdr);\n\tif (args->sync)\n\t\tencode_copy_commit(xdr, args, &hdr);\n\tencode_nops(&hdr);\n}\n\n \nstatic void nfs4_xdr_enc_offload_cancel(struct rpc_rqst *req,\n\t\t\t\t\tstruct xdr_stream *xdr,\n\t\t\t\t\tconst void *data)\n{\n\tconst struct nfs42_offload_status_args *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->osa_seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->osa_seq_args, &hdr);\n\tencode_putfh(xdr, args->osa_src_fh, &hdr);\n\tencode_offload_cancel(xdr, args, &hdr);\n\tencode_nops(&hdr);\n}\n\n \nstatic void nfs4_xdr_enc_copy_notify(struct rpc_rqst *req,\n\t\t\t\t     struct xdr_stream *xdr,\n\t\t\t\t     const void *data)\n{\n\tconst struct nfs42_copy_notify_args *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->cna_seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->cna_seq_args, &hdr);\n\tencode_putfh(xdr, args->cna_src_fh, &hdr);\n\tencode_copy_notify(xdr, args, &hdr);\n\tencode_nops(&hdr);\n}\n\n \nstatic void nfs4_xdr_enc_deallocate(struct rpc_rqst *req,\n\t\t\t\t    struct xdr_stream *xdr,\n\t\t\t\t    const void *data)\n{\n\tconst struct nfs42_falloc_args *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->falloc_fh, &hdr);\n\tencode_deallocate(xdr, args, &hdr);\n\tencode_getfattr(xdr, args->falloc_bitmask, &hdr);\n\tencode_nops(&hdr);\n}\n\n \nstatic void nfs4_xdr_enc_read_plus(struct rpc_rqst *req,\n\t\t\t\t   struct xdr_stream *xdr,\n\t\t\t\t   const void *data)\n{\n\tconst struct nfs_pgio_args *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tencode_read_plus(xdr, args, &hdr);\n\n\trpc_prepare_reply_pages(req, args->pages, args->pgbase, args->count,\n\t\t\t\thdr.replen - READ_PLUS_SEGMENT_SIZE_DIFF);\n\tencode_nops(&hdr);\n}\n\n \nstatic void nfs4_xdr_enc_seek(struct rpc_rqst *req,\n\t\t\t      struct xdr_stream *xdr,\n\t\t\t      const void *data)\n{\n\tconst struct nfs42_seek_args *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->sa_fh, &hdr);\n\tencode_seek(xdr, args, &hdr);\n\tencode_nops(&hdr);\n}\n\n \nstatic void nfs4_xdr_enc_layoutstats(struct rpc_rqst *req,\n\t\t\t\t     struct xdr_stream *xdr,\n\t\t\t\t     const void *data)\n{\n\tconst struct nfs42_layoutstat_args *args = data;\n\tint i;\n\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tWARN_ON(args->num_dev > PNFS_LAYOUTSTATS_MAXDEV);\n\tfor (i = 0; i < args->num_dev; i++)\n\t\tencode_layoutstats(xdr, args, &args->devinfo[i], &hdr);\n\tencode_nops(&hdr);\n}\n\n \nstatic void nfs4_xdr_enc_clone(struct rpc_rqst *req,\n\t\t\t       struct xdr_stream *xdr,\n\t\t\t       const void *data)\n{\n\tconst struct nfs42_clone_args *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->src_fh, &hdr);\n\tencode_savefh(xdr, &hdr);\n\tencode_putfh(xdr, args->dst_fh, &hdr);\n\tencode_clone(xdr, args, &hdr);\n\tencode_getfattr(xdr, args->dst_bitmask, &hdr);\n\tencode_nops(&hdr);\n}\n\n \nstatic void nfs4_xdr_enc_layouterror(struct rpc_rqst *req,\n\t\t\t\t     struct xdr_stream *xdr,\n\t\t\t\t     const void *data)\n{\n\tconst struct nfs42_layouterror_args *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\tint i;\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, NFS_FH(args->inode), &hdr);\n\tfor (i = 0; i < args->num_errors; i++)\n\t\tencode_layouterror(xdr, &args->errors[i], &hdr);\n\tencode_nops(&hdr);\n}\n\n \nstatic void nfs4_xdr_enc_setxattr(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\t  const void *data)\n{\n\tconst struct nfs42_setxattrargs *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tencode_setxattr(xdr, args, &hdr);\n\tencode_getfattr(xdr, args->bitmask, &hdr);\n\tencode_nops(&hdr);\n}\n\n \nstatic void nfs4_xdr_enc_getxattr(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\t  const void *data)\n{\n\tconst struct nfs42_getxattrargs *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\tuint32_t replen;\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\treplen = hdr.replen + op_decode_hdr_maxsz + 1;\n\tencode_getxattr(xdr, args->xattr_name, &hdr);\n\n\trpc_prepare_reply_pages(req, args->xattr_pages, 0, args->xattr_len,\n\t\t\t\treplen);\n\n\tencode_nops(&hdr);\n}\n\n \nstatic void nfs4_xdr_enc_listxattrs(struct rpc_rqst *req,\n\t\t\t\t    struct xdr_stream *xdr, const void *data)\n{\n\tconst struct nfs42_listxattrsargs *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\tuint32_t replen;\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\treplen = hdr.replen + op_decode_hdr_maxsz + 2 + 1;\n\tencode_listxattrs(xdr, args, &hdr);\n\n\trpc_prepare_reply_pages(req, args->xattr_pages, 0, args->count, replen);\n\n\tencode_nops(&hdr);\n}\n\n \nstatic void nfs4_xdr_enc_removexattr(struct rpc_rqst *req,\n\t\t\t\t     struct xdr_stream *xdr, const void *data)\n{\n\tconst struct nfs42_removexattrargs *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tencode_removexattr(xdr, args->xattr_name, &hdr);\n\tencode_nops(&hdr);\n}\n\nstatic int decode_allocate(struct xdr_stream *xdr, struct nfs42_falloc_res *res)\n{\n\treturn decode_op_hdr(xdr, OP_ALLOCATE);\n}\n\nstatic int decode_write_response(struct xdr_stream *xdr,\n\t\t\t\t struct nfs42_write_res *res)\n{\n\t__be32 *p;\n\tint status, count;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tcount = be32_to_cpup(p);\n\tif (count > 1)\n\t\treturn -EREMOTEIO;\n\telse if (count == 1) {\n\t\tstatus = decode_opaque_fixed(xdr, &res->stateid,\n\t\t\t\tNFS4_STATEID_SIZE);\n\t\tif (unlikely(status))\n\t\t\treturn -EIO;\n\t}\n\tp = xdr_inline_decode(xdr, 8 + 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tp = xdr_decode_hyper(p, &res->count);\n\tres->verifier.committed = be32_to_cpup(p);\n\treturn decode_verifier(xdr, &res->verifier.verifier);\n}\n\nstatic int decode_nl4_server(struct xdr_stream *xdr, struct nl4_server *ns)\n{\n\tstruct nfs42_netaddr *naddr;\n\tuint32_t dummy;\n\tchar *dummy_str;\n\t__be32 *p;\n\tint status;\n\n\t \n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tns->nl4_type = be32_to_cpup(p);\n\tswitch (ns->nl4_type) {\n\tcase NL4_NAME:\n\tcase NL4_URL:\n\t\tstatus = decode_opaque_inline(xdr, &dummy, &dummy_str);\n\t\tif (unlikely(status))\n\t\t\treturn status;\n\t\tif (unlikely(dummy > NFS4_OPAQUE_LIMIT))\n\t\t\treturn -EIO;\n\t\tmemcpy(&ns->u.nl4_str, dummy_str, dummy);\n\t\tns->u.nl4_str_sz = dummy;\n\t\tbreak;\n\tcase NL4_NETADDR:\n\t\tnaddr = &ns->u.nl4_addr;\n\n\t\t \n\t\tstatus = decode_opaque_inline(xdr, &dummy, &dummy_str);\n\t\tif (unlikely(status))\n\t\t\treturn status;\n\t\tif (unlikely(dummy > RPCBIND_MAXNETIDLEN))\n\t\t\treturn -EIO;\n\t\tnaddr->netid_len = dummy;\n\t\tmemcpy(naddr->netid, dummy_str, naddr->netid_len);\n\n\t\t \n\t\tstatus = decode_opaque_inline(xdr, &dummy, &dummy_str);\n\t\tif (unlikely(status))\n\t\t\treturn status;\n\t\tif (unlikely(dummy > RPCBIND_MAXUADDRLEN))\n\t\t\treturn -EIO;\n\t\tnaddr->addr_len = dummy;\n\t\tmemcpy(naddr->addr, dummy_str, naddr->addr_len);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic int decode_copy_requirements(struct xdr_stream *xdr,\n\t\t\t\t    struct nfs42_copy_res *res) {\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4 + 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\n\tres->consecutive = be32_to_cpup(p++);\n\tres->synchronous = be32_to_cpup(p++);\n\treturn 0;\n}\n\nstatic int decode_copy(struct xdr_stream *xdr, struct nfs42_copy_res *res)\n{\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_COPY);\n\tif (status == NFS4ERR_OFFLOAD_NO_REQS) {\n\t\tstatus = decode_copy_requirements(xdr, res);\n\t\tif (status)\n\t\t\treturn status;\n\t\treturn NFS4ERR_OFFLOAD_NO_REQS;\n\t} else if (status)\n\t\treturn status;\n\n\tstatus = decode_write_response(xdr, &res->write_res);\n\tif (status)\n\t\treturn status;\n\n\treturn decode_copy_requirements(xdr, res);\n}\n\nstatic int decode_offload_cancel(struct xdr_stream *xdr,\n\t\t\t\t struct nfs42_offload_status_res *res)\n{\n\treturn decode_op_hdr(xdr, OP_OFFLOAD_CANCEL);\n}\n\nstatic int decode_copy_notify(struct xdr_stream *xdr,\n\t\t\t      struct nfs42_copy_notify_res *res)\n{\n\t__be32 *p;\n\tint status, count;\n\n\tstatus = decode_op_hdr(xdr, OP_COPY_NOTIFY);\n\tif (status)\n\t\treturn status;\n\t \n\tp = xdr_inline_decode(xdr, 12);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tp = xdr_decode_hyper(p, &res->cnr_lease_time.seconds);\n\tres->cnr_lease_time.nseconds = be32_to_cpup(p);\n\n\tstatus = decode_opaque_fixed(xdr, &res->cnr_stateid, NFS4_STATEID_SIZE);\n\tif (unlikely(status))\n\t\treturn -EIO;\n\n\t \n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\n\tcount = be32_to_cpup(p);\n\tif (count > 1)\n\t\tpr_warn(\"NFS: %s: nsvr %d > Supported. Use first servers\\n\",\n\t\t\t __func__, count);\n\n\tstatus = decode_nl4_server(xdr, &res->cnr_src);\n\tif (unlikely(status))\n\t\treturn -EIO;\n\treturn 0;\n}\n\nstatic int decode_deallocate(struct xdr_stream *xdr, struct nfs42_falloc_res *res)\n{\n\treturn decode_op_hdr(xdr, OP_DEALLOCATE);\n}\n\nstruct read_plus_segment {\n\tenum data_content4 type;\n\tuint64_t offset;\n\tunion {\n\t\tstruct {\n\t\t\tuint64_t length;\n\t\t} hole;\n\n\t\tstruct {\n\t\t\tuint32_t length;\n\t\t\tunsigned int from;\n\t\t} data;\n\t};\n};\n\nstatic inline uint64_t read_plus_segment_length(struct read_plus_segment *seg)\n{\n\treturn seg->type == NFS4_CONTENT_DATA ? seg->data.length : seg->hole.length;\n}\n\nstatic int decode_read_plus_segment(struct xdr_stream *xdr,\n\t\t\t\t    struct read_plus_segment *seg)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (!p)\n\t\treturn -EIO;\n\tseg->type = be32_to_cpup(p++);\n\n\tp = xdr_inline_decode(xdr, seg->type == NFS4_CONTENT_DATA ? 12 : 16);\n\tif (!p)\n\t\treturn -EIO;\n\tp = xdr_decode_hyper(p, &seg->offset);\n\n\tif (seg->type == NFS4_CONTENT_DATA) {\n\t\tstruct xdr_buf buf;\n\t\tuint32_t len = be32_to_cpup(p);\n\n\t\tseg->data.length = len;\n\t\tseg->data.from = xdr_stream_pos(xdr);\n\n\t\tif (!xdr_stream_subsegment(xdr, &buf, xdr_align_size(len)))\n\t\t\treturn -EIO;\n\t} else if (seg->type == NFS4_CONTENT_HOLE) {\n\t\txdr_decode_hyper(p, &seg->hole.length);\n\t} else\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int process_read_plus_segment(struct xdr_stream *xdr,\n\t\t\t\t     struct nfs_pgio_args *args,\n\t\t\t\t     struct nfs_pgio_res *res,\n\t\t\t\t     struct read_plus_segment *seg)\n{\n\tunsigned long offset = seg->offset;\n\tunsigned long length = read_plus_segment_length(seg);\n\tunsigned int bufpos;\n\n\tif (offset + length < args->offset)\n\t\treturn 0;\n\telse if (offset > args->offset + args->count) {\n\t\tres->eof = 0;\n\t\treturn 0;\n\t} else if (offset < args->offset) {\n\t\tlength -= (args->offset - offset);\n\t\toffset = args->offset;\n\t} else if (offset + length > args->offset + args->count) {\n\t\tlength = (args->offset + args->count) - offset;\n\t\tres->eof = 0;\n\t}\n\n\tbufpos = xdr->buf->head[0].iov_len + (offset - args->offset);\n\tif (seg->type == NFS4_CONTENT_HOLE)\n\t\treturn xdr_stream_zero(xdr, bufpos, length);\n\telse\n\t\treturn xdr_stream_move_subsegment(xdr, seg->data.from, bufpos, length);\n}\n\nstatic int decode_read_plus(struct xdr_stream *xdr, struct nfs_pgio_res *res)\n{\n\tstruct nfs_pgio_header *hdr =\n\t\tcontainer_of(res, struct nfs_pgio_header, res);\n\tstruct nfs_pgio_args *args = &hdr->args;\n\tuint32_t segments;\n\tstruct read_plus_segment *segs;\n\tint status, i;\n\t__be32 *p;\n\n\tstatus = decode_op_hdr(xdr, OP_READ_PLUS);\n\tif (status)\n\t\treturn status;\n\n\tp = xdr_inline_decode(xdr, 4 + 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\n\tres->count = 0;\n\tres->eof = be32_to_cpup(p++);\n\tsegments = be32_to_cpup(p++);\n\tif (segments == 0)\n\t\treturn 0;\n\n\tsegs = kmalloc_array(segments, sizeof(*segs), GFP_KERNEL);\n\tif (!segs)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < segments; i++) {\n\t\tstatus = decode_read_plus_segment(xdr, &segs[i]);\n\t\tif (status < 0)\n\t\t\tgoto out;\n\t}\n\n\txdr_set_pagelen(xdr, xdr_align_size(args->count));\n\tfor (i = segments; i > 0; i--)\n\t\tres->count += process_read_plus_segment(xdr, args, res, &segs[i-1]);\n\tstatus = 0;\n\nout:\n\tkfree(segs);\n\treturn status;\n}\n\nstatic int decode_seek(struct xdr_stream *xdr, struct nfs42_seek_res *res)\n{\n\tint status;\n\t__be32 *p;\n\n\tstatus = decode_op_hdr(xdr, OP_SEEK);\n\tif (status)\n\t\treturn status;\n\n\tp = xdr_inline_decode(xdr, 4 + 8);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\n\tres->sr_eof = be32_to_cpup(p++);\n\tp = xdr_decode_hyper(p, &res->sr_offset);\n\treturn 0;\n}\n\nstatic int decode_layoutstats(struct xdr_stream *xdr)\n{\n\treturn decode_op_hdr(xdr, OP_LAYOUTSTATS);\n}\n\nstatic int decode_clone(struct xdr_stream *xdr)\n{\n\treturn decode_op_hdr(xdr, OP_CLONE);\n}\n\nstatic int decode_layouterror(struct xdr_stream *xdr)\n{\n\treturn decode_op_hdr(xdr, OP_LAYOUTERROR);\n}\n\nstatic int decode_setxattr(struct xdr_stream *xdr,\n\t\t\t   struct nfs4_change_info *cinfo)\n{\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_SETXATTR);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_change_info(xdr, cinfo);\nout:\n\treturn status;\n}\n\nstatic int decode_getxattr(struct xdr_stream *xdr,\n\t\t\t   struct nfs42_getxattrres *res,\n\t\t\t   struct rpc_rqst *req)\n{\n\tint status;\n\t__be32 *p;\n\tu32 len, rdlen;\n\n\tstatus = decode_op_hdr(xdr, OP_GETXATTR);\n\tif (status)\n\t\treturn status;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\n\tlen = be32_to_cpup(p);\n\n\t \n\tif (len > req->rq_rcv_buf.page_len)\n\t\treturn -ERANGE;\n\n\tres->xattr_len = len;\n\n\tif (len > 0) {\n\t\trdlen = xdr_read_pages(xdr, len);\n\t\tif (rdlen < len)\n\t\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int decode_removexattr(struct xdr_stream *xdr,\n\t\t\t   struct nfs4_change_info *cinfo)\n{\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_REMOVEXATTR);\n\tif (status)\n\t\tgoto out;\n\n\tstatus = decode_change_info(xdr, cinfo);\nout:\n\treturn status;\n}\n\nstatic int decode_listxattrs(struct xdr_stream *xdr,\n\t\t\t    struct nfs42_listxattrsres *res)\n{\n\tint status;\n\t__be32 *p;\n\tu32 count, len, ulen;\n\tsize_t left, copied;\n\tchar *buf;\n\n\tstatus = decode_op_hdr(xdr, OP_LISTXATTRS);\n\tif (status) {\n\t\t \n\t\tif (status == -ETOOSMALL)\n\t\t\tstatus = -ERANGE;\n\t\t \n\t\tif (status == -ENODATA) {\n\t\t\tres->eof = true;\n\t\t\tstatus = 0;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tp = xdr_inline_decode(xdr, 8);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\n\txdr_decode_hyper(p, &res->cookie);\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\n\tleft = res->xattr_len;\n\tbuf = res->xattr_buf;\n\n\tcount = be32_to_cpup(p);\n\tcopied = 0;\n\n\t \n\twhile (count--) {\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\n\t\tlen = be32_to_cpup(p);\n\t\tif (len > (XATTR_NAME_MAX - XATTR_USER_PREFIX_LEN)) {\n\t\t\tstatus = -ERANGE;\n\t\t\tgoto out;\n\t\t}\n\n\t\tp = xdr_inline_decode(xdr, len);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\n\t\tulen = len + XATTR_USER_PREFIX_LEN + 1;\n\t\tif (buf) {\n\t\t\tif (ulen > left) {\n\t\t\t\tstatus = -ERANGE;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tmemcpy(buf, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN);\n\t\t\tmemcpy(buf + XATTR_USER_PREFIX_LEN, p, len);\n\n\t\t\tbuf[ulen - 1] = 0;\n\t\t\tbuf += ulen;\n\t\t\tleft -= ulen;\n\t\t}\n\t\tcopied += ulen;\n\t}\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\n\tres->eof = be32_to_cpup(p);\n\tres->copied = copied;\n\nout:\n\tif (status == -ERANGE && res->xattr_len == XATTR_LIST_MAX)\n\t\tstatus = -E2BIG;\n\n\treturn status;\n}\n\n \nstatic int nfs4_xdr_dec_allocate(struct rpc_rqst *rqstp,\n\t\t\t\t struct xdr_stream *xdr,\n\t\t\t\t void *data)\n{\n\tstruct nfs42_falloc_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_allocate(xdr, res);\n\tif (status)\n\t\tgoto out;\n\tdecode_getfattr(xdr, res->falloc_fattr, res->falloc_server);\nout:\n\treturn status;\n}\n\n \nstatic int nfs4_xdr_dec_copy(struct rpc_rqst *rqstp,\n\t\t\t     struct xdr_stream *xdr,\n\t\t\t     void *data)\n{\n\tstruct nfs42_copy_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_savefh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_copy(xdr, res);\n\tif (status)\n\t\tgoto out;\n\tif (res->commit_res.verf)\n\t\tstatus = decode_commit(xdr, &res->commit_res);\nout:\n\treturn status;\n}\n\n \nstatic int nfs4_xdr_dec_offload_cancel(struct rpc_rqst *rqstp,\n\t\t\t\t       struct xdr_stream *xdr,\n\t\t\t\t       void *data)\n{\n\tstruct nfs42_offload_status_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->osr_seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_offload_cancel(xdr, res);\n\nout:\n\treturn status;\n}\n\n \nstatic int nfs4_xdr_dec_copy_notify(struct rpc_rqst *rqstp,\n\t\t\t\t    struct xdr_stream *xdr,\n\t\t\t\t    void *data)\n{\n\tstruct nfs42_copy_notify_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->cnr_seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_copy_notify(xdr, res);\n\nout:\n\treturn status;\n}\n\n \nstatic int nfs4_xdr_dec_deallocate(struct rpc_rqst *rqstp,\n\t\t\t\t   struct xdr_stream *xdr,\n\t\t\t\t   void *data)\n{\n\tstruct nfs42_falloc_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_deallocate(xdr, res);\n\tif (status)\n\t\tgoto out;\n\tdecode_getfattr(xdr, res->falloc_fattr, res->falloc_server);\nout:\n\treturn status;\n}\n\n \nstatic int nfs4_xdr_dec_read_plus(struct rpc_rqst *rqstp,\n\t\t\t\t  struct xdr_stream *xdr,\n\t\t\t\t  void *data)\n{\n\tstruct nfs_pgio_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\txdr_set_scratch_buffer(xdr, res->scratch, READ_PLUS_SCRATCH_SIZE);\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_read_plus(xdr, res);\n\tif (!status)\n\t\tstatus = res->count;\nout:\n\treturn status;\n}\n\n \nstatic int nfs4_xdr_dec_seek(struct rpc_rqst *rqstp,\n\t\t\t     struct xdr_stream *xdr,\n\t\t\t     void *data)\n{\n\tstruct nfs42_seek_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_seek(xdr, res);\nout:\n\treturn status;\n}\n\n \nstatic int nfs4_xdr_dec_layoutstats(struct rpc_rqst *rqstp,\n\t\t\t\t    struct xdr_stream *xdr,\n\t\t\t\t    void *data)\n{\n\tstruct nfs42_layoutstat_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status, i;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tWARN_ON(res->num_dev > PNFS_LAYOUTSTATS_MAXDEV);\n\tfor (i = 0; i < res->num_dev; i++) {\n\t\tstatus = decode_layoutstats(xdr);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\nout:\n\tres->rpc_status = status;\n\treturn status;\n}\n\n \nstatic int nfs4_xdr_dec_clone(struct rpc_rqst *rqstp,\n\t\t\t      struct xdr_stream *xdr,\n\t\t\t      void *data)\n{\n\tstruct nfs42_clone_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_savefh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_clone(xdr);\n\tif (status)\n\t\tgoto out;\n\tdecode_getfattr(xdr, res->dst_fattr, res->server);\nout:\n\tres->rpc_status = status;\n\treturn status;\n}\n\n \nstatic int nfs4_xdr_dec_layouterror(struct rpc_rqst *rqstp,\n\t\t\t\t    struct xdr_stream *xdr,\n\t\t\t\t    void *data)\n{\n\tstruct nfs42_layouterror_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status, i;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\n\tfor (i = 0; i < res->num_errors && status == 0; i++)\n\t\tstatus = decode_layouterror(xdr);\nout:\n\tres->rpc_status = status;\n\treturn status;\n}\n\n \nstatic int nfs4_xdr_dec_setxattr(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\t void *data)\n{\n\tstruct nfs42_setxattrres *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, req);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_setxattr(xdr, &res->cinfo);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_getfattr(xdr, res->fattr, res->server);\nout:\n\treturn status;\n}\n\n \nstatic int nfs4_xdr_dec_getxattr(struct rpc_rqst *rqstp,\n\t\t\t\t struct xdr_stream *xdr, void *data)\n{\n\tstruct nfs42_getxattrres *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_getxattr(xdr, res, rqstp);\nout:\n\treturn status;\n}\n\n \nstatic int nfs4_xdr_dec_listxattrs(struct rpc_rqst *rqstp,\n\t\t\t\t   struct xdr_stream *xdr, void *data)\n{\n\tstruct nfs42_listxattrsres *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\txdr_set_scratch_page(xdr, res->scratch);\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_listxattrs(xdr, res);\nout:\n\treturn status;\n}\n\n \nstatic int nfs4_xdr_dec_removexattr(struct rpc_rqst *req,\n\t\t\t\t    struct xdr_stream *xdr, void *data)\n{\n\tstruct nfs42_removexattrres *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, req);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\n\tstatus = decode_removexattr(xdr, &res->cinfo);\nout:\n\treturn status;\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}