{
  "module_name": "callback.c",
  "hash_id": "e8d82f1502391812466116ea4c864582f1ecea443214d6cccc9bc48ae65e8f65",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfs/callback.c",
  "human_readable_source": "\n \n\n#include <linux/completion.h>\n#include <linux/ip.h>\n#include <linux/module.h>\n#include <linux/sched/signal.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/nfs_fs.h>\n#include <linux/errno.h>\n#include <linux/mutex.h>\n#include <linux/freezer.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/sunrpc/bc_xprt.h>\n\n#include <net/inet_sock.h>\n\n#include \"nfs4_fs.h\"\n#include \"callback.h\"\n#include \"internal.h\"\n#include \"netns.h\"\n\n#define NFSDBG_FACILITY NFSDBG_CALLBACK\n\nstruct nfs_callback_data {\n\tunsigned int users;\n\tstruct svc_serv *serv;\n};\n\nstatic struct nfs_callback_data nfs_callback_info[NFS4_MAX_MINOR_VERSION + 1];\nstatic DEFINE_MUTEX(nfs_callback_mutex);\nstatic struct svc_program nfs4_callback_program;\n\nstatic int nfs4_callback_up_net(struct svc_serv *serv, struct net *net)\n{\n\tconst struct cred *cred = current_cred();\n\tint ret;\n\tstruct nfs_net *nn = net_generic(net, nfs_net_id);\n\n\tret = svc_xprt_create(serv, \"tcp\", net, PF_INET,\n\t\t\t      nfs_callback_set_tcpport, SVC_SOCK_ANONYMOUS,\n\t\t\t      cred);\n\tif (ret <= 0)\n\t\tgoto out_err;\n\tnn->nfs_callback_tcpport = ret;\n\tdprintk(\"NFS: Callback listener port = %u (af %u, net %x)\\n\",\n\t\tnn->nfs_callback_tcpport, PF_INET, net->ns.inum);\n\n\tret = svc_xprt_create(serv, \"tcp\", net, PF_INET6,\n\t\t\t      nfs_callback_set_tcpport, SVC_SOCK_ANONYMOUS,\n\t\t\t      cred);\n\tif (ret > 0) {\n\t\tnn->nfs_callback_tcpport6 = ret;\n\t\tdprintk(\"NFS: Callback listener port = %u (af %u, net %x)\\n\",\n\t\t\tnn->nfs_callback_tcpport6, PF_INET6, net->ns.inum);\n\t} else if (ret != -EAFNOSUPPORT)\n\t\tgoto out_err;\n\treturn 0;\n\nout_err:\n\treturn (ret) ? ret : -ENOMEM;\n}\n\n \nstatic int\nnfs4_callback_svc(void *vrqstp)\n{\n\tstruct svc_rqst *rqstp = vrqstp;\n\n\tset_freezable();\n\n\twhile (!kthread_freezable_should_stop(NULL))\n\t\tsvc_recv(rqstp);\n\n\tsvc_exit_thread(rqstp);\n\treturn 0;\n}\n\n#if defined(CONFIG_NFS_V4_1)\n \nstatic int\nnfs41_callback_svc(void *vrqstp)\n{\n\tstruct svc_rqst *rqstp = vrqstp;\n\tstruct svc_serv *serv = rqstp->rq_server;\n\tstruct rpc_rqst *req;\n\tint error;\n\tDEFINE_WAIT(wq);\n\n\tset_freezable();\n\n\twhile (!kthread_freezable_should_stop(NULL)) {\n\t\tprepare_to_wait(&serv->sv_cb_waitq, &wq, TASK_IDLE);\n\t\tspin_lock_bh(&serv->sv_cb_lock);\n\t\tif (!list_empty(&serv->sv_cb_list)) {\n\t\t\treq = list_first_entry(&serv->sv_cb_list,\n\t\t\t\t\tstruct rpc_rqst, rq_bc_list);\n\t\t\tlist_del(&req->rq_bc_list);\n\t\t\tspin_unlock_bh(&serv->sv_cb_lock);\n\t\t\tfinish_wait(&serv->sv_cb_waitq, &wq);\n\t\t\tdprintk(\"Invoking bc_svc_process()\\n\");\n\t\t\terror = bc_svc_process(serv, req, rqstp);\n\t\t\tdprintk(\"bc_svc_process() returned w/ error code= %d\\n\",\n\t\t\t\terror);\n\t\t} else {\n\t\t\tspin_unlock_bh(&serv->sv_cb_lock);\n\t\t\tif (!kthread_should_stop())\n\t\t\t\tschedule();\n\t\t\tfinish_wait(&serv->sv_cb_waitq, &wq);\n\t\t}\n\t}\n\n\tsvc_exit_thread(rqstp);\n\treturn 0;\n}\n\nstatic inline void nfs_callback_bc_serv(u32 minorversion, struct rpc_xprt *xprt,\n\t\tstruct svc_serv *serv)\n{\n\tif (minorversion)\n\t\t \n\t\txprt->bc_serv = serv;\n}\n#else\nstatic inline void nfs_callback_bc_serv(u32 minorversion, struct rpc_xprt *xprt,\n\t\tstruct svc_serv *serv)\n{\n}\n#endif  \n\nstatic int nfs_callback_start_svc(int minorversion, struct rpc_xprt *xprt,\n\t\t\t\t  struct svc_serv *serv)\n{\n\tint nrservs = nfs_callback_nr_threads;\n\tint ret;\n\n\tnfs_callback_bc_serv(minorversion, xprt, serv);\n\n\tif (nrservs < NFS4_MIN_NR_CALLBACK_THREADS)\n\t\tnrservs = NFS4_MIN_NR_CALLBACK_THREADS;\n\n\tif (serv->sv_nrthreads == nrservs)\n\t\treturn 0;\n\n\tret = svc_set_num_threads(serv, NULL, nrservs);\n\tif (ret) {\n\t\tsvc_set_num_threads(serv, NULL, 0);\n\t\treturn ret;\n\t}\n\tdprintk(\"nfs_callback_up: service started\\n\");\n\treturn 0;\n}\n\nstatic void nfs_callback_down_net(u32 minorversion, struct svc_serv *serv, struct net *net)\n{\n\tstruct nfs_net *nn = net_generic(net, nfs_net_id);\n\n\tif (--nn->cb_users[minorversion])\n\t\treturn;\n\n\tdprintk(\"NFS: destroy per-net callback data; net=%x\\n\", net->ns.inum);\n\tsvc_xprt_destroy_all(serv, net);\n}\n\nstatic int nfs_callback_up_net(int minorversion, struct svc_serv *serv,\n\t\t\t       struct net *net, struct rpc_xprt *xprt)\n{\n\tstruct nfs_net *nn = net_generic(net, nfs_net_id);\n\tint ret;\n\n\tif (nn->cb_users[minorversion]++)\n\t\treturn 0;\n\n\tdprintk(\"NFS: create per-net callback data; net=%x\\n\", net->ns.inum);\n\n\tret = svc_bind(serv, net);\n\tif (ret < 0) {\n\t\tprintk(KERN_WARNING \"NFS: bind callback service failed\\n\");\n\t\tgoto err_bind;\n\t}\n\n\tret = 0;\n\tif (!IS_ENABLED(CONFIG_NFS_V4_1) || minorversion == 0)\n\t\tret = nfs4_callback_up_net(serv, net);\n\telse if (xprt->ops->bc_setup)\n\t\tset_bc_enabled(serv);\n\telse\n\t\tret = -EPROTONOSUPPORT;\n\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR \"NFS: callback service start failed\\n\");\n\t\tgoto err_socks;\n\t}\n\treturn 0;\n\nerr_socks:\n\tsvc_rpcb_cleanup(serv, net);\nerr_bind:\n\tnn->cb_users[minorversion]--;\n\tdprintk(\"NFS: Couldn't create callback socket: err = %d; \"\n\t\t\t\"net = %x\\n\", ret, net->ns.inum);\n\treturn ret;\n}\n\nstatic struct svc_serv *nfs_callback_create_svc(int minorversion)\n{\n\tstruct nfs_callback_data *cb_info = &nfs_callback_info[minorversion];\n\tint (*threadfn)(void *data);\n\tstruct svc_serv *serv;\n\n\t \n\tif (cb_info->serv)\n\t\treturn svc_get(cb_info->serv);\n\n\t \n\tif (cb_info->users)\n\t\tprintk(KERN_WARNING \"nfs_callback_create_svc: no kthread, %d users??\\n\",\n\t\t\tcb_info->users);\n\n\tthreadfn = nfs4_callback_svc;\n#if defined(CONFIG_NFS_V4_1)\n\tif (minorversion)\n\t\tthreadfn = nfs41_callback_svc;\n#else\n\tif (minorversion)\n\t\treturn ERR_PTR(-ENOTSUPP);\n#endif\n\tserv = svc_create(&nfs4_callback_program, NFS4_CALLBACK_BUFSIZE,\n\t\t\t  threadfn);\n\tif (!serv) {\n\t\tprintk(KERN_ERR \"nfs_callback_create_svc: create service failed\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tcb_info->serv = serv;\n\t \n\tserv->sv_maxconn = 1024;\n\tdprintk(\"nfs_callback_create_svc: service created\\n\");\n\treturn serv;\n}\n\n \nint nfs_callback_up(u32 minorversion, struct rpc_xprt *xprt)\n{\n\tstruct svc_serv *serv;\n\tstruct nfs_callback_data *cb_info = &nfs_callback_info[minorversion];\n\tint ret;\n\tstruct net *net = xprt->xprt_net;\n\n\tmutex_lock(&nfs_callback_mutex);\n\n\tserv = nfs_callback_create_svc(minorversion);\n\tif (IS_ERR(serv)) {\n\t\tret = PTR_ERR(serv);\n\t\tgoto err_create;\n\t}\n\n\tret = nfs_callback_up_net(minorversion, serv, net, xprt);\n\tif (ret < 0)\n\t\tgoto err_net;\n\n\tret = nfs_callback_start_svc(minorversion, xprt, serv);\n\tif (ret < 0)\n\t\tgoto err_start;\n\n\tcb_info->users++;\nerr_net:\n\tif (!cb_info->users)\n\t\tcb_info->serv = NULL;\n\tsvc_put(serv);\nerr_create:\n\tmutex_unlock(&nfs_callback_mutex);\n\treturn ret;\n\nerr_start:\n\tnfs_callback_down_net(minorversion, serv, net);\n\tdprintk(\"NFS: Couldn't create server thread; err = %d\\n\", ret);\n\tgoto err_net;\n}\n\n \nvoid nfs_callback_down(int minorversion, struct net *net)\n{\n\tstruct nfs_callback_data *cb_info = &nfs_callback_info[minorversion];\n\tstruct svc_serv *serv;\n\n\tmutex_lock(&nfs_callback_mutex);\n\tserv = cb_info->serv;\n\tnfs_callback_down_net(minorversion, serv, net);\n\tcb_info->users--;\n\tif (cb_info->users == 0) {\n\t\tsvc_get(serv);\n\t\tsvc_set_num_threads(serv, NULL, 0);\n\t\tsvc_put(serv);\n\t\tdprintk(\"nfs_callback_down: service destroyed\\n\");\n\t\tcb_info->serv = NULL;\n\t}\n\tmutex_unlock(&nfs_callback_mutex);\n}\n\n \nint\ncheck_gss_callback_principal(struct nfs_client *clp, struct svc_rqst *rqstp)\n{\n\tchar *p = rqstp->rq_cred.cr_principal;\n\n\tif (rqstp->rq_authop->flavour != RPC_AUTH_GSS)\n\t\treturn 1;\n\n\t \n\tif (clp->cl_minorversion != 0)\n\t\treturn 0;\n\t \n\tif (p == NULL)\n\t\treturn 0;\n\n\t \n\tif (clp->cl_acceptor)\n\t\treturn !strcmp(p, clp->cl_acceptor);\n\n\t \n\n\t \n\n\tif (memcmp(p, \"nfs@\", 4) != 0)\n\t\treturn 0;\n\tp += 4;\n\tif (strcmp(p, clp->cl_hostname) != 0)\n\t\treturn 0;\n\treturn 1;\n}\n\n \nstatic enum svc_auth_status nfs_callback_authenticate(struct svc_rqst *rqstp)\n{\n\trqstp->rq_auth_stat = rpc_autherr_badcred;\n\n\tswitch (rqstp->rq_authop->flavour) {\n\tcase RPC_AUTH_NULL:\n\t\tif (rqstp->rq_proc != CB_NULL)\n\t\t\treturn SVC_DENIED;\n\t\tbreak;\n\tcase RPC_AUTH_GSS:\n\t\t \n\t\t if (svc_is_backchannel(rqstp))\n\t\t\treturn SVC_DENIED;\n\t}\n\n\trqstp->rq_auth_stat = rpc_auth_ok;\n\treturn SVC_OK;\n}\n\n \nstatic const struct svc_version *nfs4_callback_version[] = {\n\t[1] = &nfs4_callback_version1,\n\t[4] = &nfs4_callback_version4,\n};\n\nstatic struct svc_stat nfs4_callback_stats;\n\nstatic struct svc_program nfs4_callback_program = {\n\t.pg_prog = NFS4_CALLBACK,\t\t\t \n\t.pg_nvers = ARRAY_SIZE(nfs4_callback_version),\t \n\t.pg_vers = nfs4_callback_version,\t\t \n\t.pg_name = \"NFSv4 callback\",\t\t\t \n\t.pg_class = \"nfs\",\t\t\t\t \n\t.pg_stats = &nfs4_callback_stats,\n\t.pg_authenticate = nfs_callback_authenticate,\n\t.pg_init_request = svc_generic_init_request,\n\t.pg_rpcbind_set\t= svc_generic_rpcbind_set,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}