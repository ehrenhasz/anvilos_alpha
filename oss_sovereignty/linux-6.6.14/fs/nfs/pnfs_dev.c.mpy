{
  "module_name": "pnfs_dev.c",
  "hash_id": "09ffac25c1048ab38ec49f6aa4bdad22212ae91c5c9f6059c51c996379d4ed91",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfs/pnfs_dev.c",
  "human_readable_source": " \n\n#include <linux/export.h>\n#include <linux/nfs_fs.h>\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"pnfs.h\"\n\n#include \"nfs4trace.h\"\n\n#define NFSDBG_FACILITY\t\tNFSDBG_PNFS\n\n \n#define NFS4_DEVICE_ID_HASH_BITS\t5\n#define NFS4_DEVICE_ID_HASH_SIZE\t(1 << NFS4_DEVICE_ID_HASH_BITS)\n#define NFS4_DEVICE_ID_HASH_MASK\t(NFS4_DEVICE_ID_HASH_SIZE - 1)\n\n\nstatic struct hlist_head nfs4_deviceid_cache[NFS4_DEVICE_ID_HASH_SIZE];\nstatic DEFINE_SPINLOCK(nfs4_deviceid_lock);\n\n#ifdef NFS_DEBUG\nvoid\nnfs4_print_deviceid(const struct nfs4_deviceid *id)\n{\n\tu32 *p = (u32 *)id;\n\n\tdprintk(\"%s: device id= [%x%x%x%x]\\n\", __func__,\n\t\tp[0], p[1], p[2], p[3]);\n}\nEXPORT_SYMBOL_GPL(nfs4_print_deviceid);\n#endif\n\nstatic inline u32\nnfs4_deviceid_hash(const struct nfs4_deviceid *id)\n{\n\tunsigned char *cptr = (unsigned char *)id->data;\n\tunsigned int nbytes = NFS4_DEVICEID4_SIZE;\n\tu32 x = 0;\n\n\twhile (nbytes--) {\n\t\tx *= 37;\n\t\tx += *cptr++;\n\t}\n\treturn x & NFS4_DEVICE_ID_HASH_MASK;\n}\n\nstatic struct nfs4_deviceid_node *\n_lookup_deviceid(const struct pnfs_layoutdriver_type *ld,\n\t\t const struct nfs_client *clp, const struct nfs4_deviceid *id,\n\t\t long hash)\n{\n\tstruct nfs4_deviceid_node *d;\n\n\thlist_for_each_entry_rcu(d, &nfs4_deviceid_cache[hash], node)\n\t\tif (d->ld == ld && d->nfs_client == clp &&\n\t\t    !memcmp(&d->deviceid, id, sizeof(*id))) {\n\t\t\tif (atomic_read(&d->ref))\n\t\t\t\treturn d;\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\treturn NULL;\n}\n\nstatic struct nfs4_deviceid_node *\nnfs4_get_device_info(struct nfs_server *server,\n\t\tconst struct nfs4_deviceid *dev_id,\n\t\tconst struct cred *cred, gfp_t gfp_flags)\n{\n\tstruct nfs4_deviceid_node *d = NULL;\n\tstruct pnfs_device *pdev = NULL;\n\tstruct page **pages = NULL;\n\tu32 max_resp_sz;\n\tint max_pages;\n\tint rc, i;\n\n\t \n\tmax_resp_sz = server->nfs_client->cl_session->fc_attrs.max_resp_sz;\n\tif (server->pnfs_curr_ld->max_deviceinfo_size &&\n\t    server->pnfs_curr_ld->max_deviceinfo_size < max_resp_sz)\n\t\tmax_resp_sz = server->pnfs_curr_ld->max_deviceinfo_size;\n\tmax_pages = nfs_page_array_len(0, max_resp_sz);\n\tdprintk(\"%s: server %p max_resp_sz %u max_pages %d\\n\",\n\t\t__func__, server, max_resp_sz, max_pages);\n\n\tpdev = kzalloc(sizeof(*pdev), gfp_flags);\n\tif (!pdev)\n\t\treturn NULL;\n\n\tpages = kcalloc(max_pages, sizeof(struct page *), gfp_flags);\n\tif (!pages)\n\t\tgoto out_free_pdev;\n\n\tfor (i = 0; i < max_pages; i++) {\n\t\tpages[i] = alloc_page(gfp_flags);\n\t\tif (!pages[i])\n\t\t\tgoto out_free_pages;\n\t}\n\n\tmemcpy(&pdev->dev_id, dev_id, sizeof(*dev_id));\n\tpdev->layout_type = server->pnfs_curr_ld->id;\n\tpdev->pages = pages;\n\tpdev->pgbase = 0;\n\tpdev->pglen = max_resp_sz;\n\tpdev->mincount = 0;\n\tpdev->maxcount = max_resp_sz - nfs41_maxgetdevinfo_overhead;\n\n\trc = nfs4_proc_getdeviceinfo(server, pdev, cred);\n\tdprintk(\"%s getdevice info returns %d\\n\", __func__, rc);\n\tif (rc)\n\t\tgoto out_free_pages;\n\n\t \n\td = server->pnfs_curr_ld->alloc_deviceid_node(server, pdev,\n\t\t\tgfp_flags);\n\tif (d && pdev->nocache)\n\t\tset_bit(NFS_DEVICEID_NOCACHE, &d->flags);\n\nout_free_pages:\n\twhile (--i >= 0)\n\t\t__free_page(pages[i]);\n\tkfree(pages);\nout_free_pdev:\n\tkfree(pdev);\n\tdprintk(\"<-- %s d %p\\n\", __func__, d);\n\treturn d;\n}\n\n \nstatic struct nfs4_deviceid_node *\n__nfs4_find_get_deviceid(struct nfs_server *server,\n\t\tconst struct nfs4_deviceid *id, long hash)\n{\n\tstruct nfs4_deviceid_node *d;\n\n\trcu_read_lock();\n\td = _lookup_deviceid(server->pnfs_curr_ld, server->nfs_client, id,\n\t\t\thash);\n\tif (d != NULL && !atomic_inc_not_zero(&d->ref))\n\t\td = NULL;\n\trcu_read_unlock();\n\treturn d;\n}\n\nstruct nfs4_deviceid_node *\nnfs4_find_get_deviceid(struct nfs_server *server,\n\t\tconst struct nfs4_deviceid *id, const struct cred *cred,\n\t\tgfp_t gfp_mask)\n{\n\tlong hash = nfs4_deviceid_hash(id);\n\tstruct nfs4_deviceid_node *d, *new;\n\n\td = __nfs4_find_get_deviceid(server, id, hash);\n\tif (d)\n\t\tgoto found;\n\n\tnew = nfs4_get_device_info(server, id, cred, gfp_mask);\n\tif (!new) {\n\t\ttrace_nfs4_find_deviceid(server, id, -ENOENT);\n\t\treturn new;\n\t}\n\n\tspin_lock(&nfs4_deviceid_lock);\n\td = __nfs4_find_get_deviceid(server, id, hash);\n\tif (d) {\n\t\tspin_unlock(&nfs4_deviceid_lock);\n\t\tserver->pnfs_curr_ld->free_deviceid_node(new);\n\t} else {\n\t\tatomic_inc(&new->ref);\n\t\thlist_add_head_rcu(&new->node, &nfs4_deviceid_cache[hash]);\n\t\tspin_unlock(&nfs4_deviceid_lock);\n\t\td = new;\n\t}\nfound:\n\ttrace_nfs4_find_deviceid(server, id, 0);\n\treturn d;\n}\nEXPORT_SYMBOL_GPL(nfs4_find_get_deviceid);\n\n \nvoid\nnfs4_delete_deviceid(const struct pnfs_layoutdriver_type *ld,\n\t\t\t const struct nfs_client *clp, const struct nfs4_deviceid *id)\n{\n\tstruct nfs4_deviceid_node *d;\n\n\tspin_lock(&nfs4_deviceid_lock);\n\trcu_read_lock();\n\td = _lookup_deviceid(ld, clp, id, nfs4_deviceid_hash(id));\n\trcu_read_unlock();\n\tif (!d) {\n\t\tspin_unlock(&nfs4_deviceid_lock);\n\t\treturn;\n\t}\n\thlist_del_init_rcu(&d->node);\n\tclear_bit(NFS_DEVICEID_NOCACHE, &d->flags);\n\tspin_unlock(&nfs4_deviceid_lock);\n\n\t \n\tnfs4_put_deviceid_node(d);\n}\nEXPORT_SYMBOL_GPL(nfs4_delete_deviceid);\n\nvoid\nnfs4_init_deviceid_node(struct nfs4_deviceid_node *d, struct nfs_server *server,\n\t\t\tconst struct nfs4_deviceid *id)\n{\n\tINIT_HLIST_NODE(&d->node);\n\tINIT_HLIST_NODE(&d->tmpnode);\n\td->ld = server->pnfs_curr_ld;\n\td->nfs_client = server->nfs_client;\n\td->flags = 0;\n\td->deviceid = *id;\n\tatomic_set(&d->ref, 1);\n}\nEXPORT_SYMBOL_GPL(nfs4_init_deviceid_node);\n\n \nbool\nnfs4_put_deviceid_node(struct nfs4_deviceid_node *d)\n{\n\tif (test_bit(NFS_DEVICEID_NOCACHE, &d->flags)) {\n\t\tif (atomic_add_unless(&d->ref, -1, 2))\n\t\t\treturn false;\n\t\tnfs4_delete_deviceid(d->ld, d->nfs_client, &d->deviceid);\n\t}\n\tif (!atomic_dec_and_test(&d->ref))\n\t\treturn false;\n\ttrace_nfs4_deviceid_free(d->nfs_client, &d->deviceid);\n\td->ld->free_deviceid_node(d);\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(nfs4_put_deviceid_node);\n\nvoid\nnfs4_mark_deviceid_available(struct nfs4_deviceid_node *node)\n{\n\tif (test_bit(NFS_DEVICEID_UNAVAILABLE, &node->flags)) {\n\t\tclear_bit(NFS_DEVICEID_UNAVAILABLE, &node->flags);\n\t\tsmp_mb__after_atomic();\n\t}\n}\nEXPORT_SYMBOL_GPL(nfs4_mark_deviceid_available);\n\nvoid\nnfs4_mark_deviceid_unavailable(struct nfs4_deviceid_node *node)\n{\n\tnode->timestamp_unavailable = jiffies;\n\tsmp_mb__before_atomic();\n\tset_bit(NFS_DEVICEID_UNAVAILABLE, &node->flags);\n\tsmp_mb__after_atomic();\n}\nEXPORT_SYMBOL_GPL(nfs4_mark_deviceid_unavailable);\n\nbool\nnfs4_test_deviceid_unavailable(struct nfs4_deviceid_node *node)\n{\n\tif (test_bit(NFS_DEVICEID_UNAVAILABLE, &node->flags)) {\n\t\tunsigned long start, end;\n\n\t\tend = jiffies;\n\t\tstart = end - PNFS_DEVICE_RETRY_TIMEOUT;\n\t\tif (time_in_range(node->timestamp_unavailable, start, end))\n\t\t\treturn true;\n\t\tclear_bit(NFS_DEVICEID_UNAVAILABLE, &node->flags);\n\t\tsmp_mb__after_atomic();\n\t}\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(nfs4_test_deviceid_unavailable);\n\nstatic void\n_deviceid_purge_client(const struct nfs_client *clp, long hash)\n{\n\tstruct nfs4_deviceid_node *d;\n\tHLIST_HEAD(tmp);\n\n\tspin_lock(&nfs4_deviceid_lock);\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(d, &nfs4_deviceid_cache[hash], node)\n\t\tif (d->nfs_client == clp && atomic_read(&d->ref)) {\n\t\t\thlist_del_init_rcu(&d->node);\n\t\t\thlist_add_head(&d->tmpnode, &tmp);\n\t\t\tclear_bit(NFS_DEVICEID_NOCACHE, &d->flags);\n\t\t}\n\trcu_read_unlock();\n\tspin_unlock(&nfs4_deviceid_lock);\n\n\tif (hlist_empty(&tmp))\n\t\treturn;\n\n\twhile (!hlist_empty(&tmp)) {\n\t\td = hlist_entry(tmp.first, struct nfs4_deviceid_node, tmpnode);\n\t\thlist_del(&d->tmpnode);\n\t\tnfs4_put_deviceid_node(d);\n\t}\n}\n\nvoid\nnfs4_deviceid_purge_client(const struct nfs_client *clp)\n{\n\tlong h;\n\n\tif (!(clp->cl_exchange_flags & EXCHGID4_FLAG_USE_PNFS_MDS))\n\t\treturn;\n\tfor (h = 0; h < NFS4_DEVICE_ID_HASH_SIZE; h++)\n\t\t_deviceid_purge_client(clp, h);\n}\n\n \nvoid\nnfs4_deviceid_mark_client_invalid(struct nfs_client *clp)\n{\n\tstruct nfs4_deviceid_node *d;\n\tint i;\n\n\trcu_read_lock();\n\tfor (i = 0; i < NFS4_DEVICE_ID_HASH_SIZE; i ++){\n\t\thlist_for_each_entry_rcu(d, &nfs4_deviceid_cache[i], node)\n\t\t\tif (d->nfs_client == clp)\n\t\t\t\tset_bit(NFS_DEVICEID_INVALID, &d->flags);\n\t}\n\trcu_read_unlock();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}