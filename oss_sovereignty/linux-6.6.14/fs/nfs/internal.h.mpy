{
  "module_name": "internal.h",
  "hash_id": "449c3cb0f76d367b39202bc71517f4371a64d04a8ba48cda9e3f9cce2a4c11b8",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfs/internal.h",
  "human_readable_source": " \n \n\n#include \"nfs4_fs.h\"\n#include <linux/fs_context.h>\n#include <linux/security.h>\n#include <linux/crc32.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/wait_bit.h>\n\n#define NFS_SB_MASK (SB_RDONLY|SB_NOSUID|SB_NODEV|SB_NOEXEC|SB_SYNCHRONOUS)\n\nextern const struct export_operations nfs_export_ops;\n\nstruct nfs_string;\nstruct nfs_pageio_descriptor;\n\nstatic inline void nfs_attr_check_mountpoint(struct super_block *parent, struct nfs_fattr *fattr)\n{\n\tif (!nfs_fsid_equal(&NFS_SB(parent)->fsid, &fattr->fsid))\n\t\tfattr->valid |= NFS_ATTR_FATTR_MOUNTPOINT;\n}\n\nstatic inline int nfs_attr_use_mounted_on_fileid(struct nfs_fattr *fattr)\n{\n\tif (((fattr->valid & NFS_ATTR_FATTR_MOUNTED_ON_FILEID) == 0) ||\n\t    (((fattr->valid & NFS_ATTR_FATTR_MOUNTPOINT) == 0) &&\n\t     ((fattr->valid & NFS_ATTR_FATTR_V4_REFERRAL) == 0)))\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic inline bool nfs_lookup_is_soft_revalidate(const struct dentry *dentry)\n{\n\tif (!(NFS_SB(dentry->d_sb)->flags & NFS_MOUNT_SOFTREVAL))\n\t\treturn false;\n\tif (!d_is_positive(dentry) || !NFS_FH(d_inode(dentry))->size)\n\t\treturn false;\n\treturn true;\n}\n\nstatic inline fmode_t flags_to_mode(int flags)\n{\n\tfmode_t res = (__force fmode_t)flags & FMODE_EXEC;\n\tif ((flags & O_ACCMODE) != O_WRONLY)\n\t\tres |= FMODE_READ;\n\tif ((flags & O_ACCMODE) != O_RDONLY)\n\t\tres |= FMODE_WRITE;\n\treturn res;\n}\n\n \n#define NFS_MAX_SECFLAVORS\t(12)\n\n \n#define NFS_UNSPEC_PORT\t\t(-1)\n\n#define NFS_UNSPEC_RETRANS\t(UINT_MAX)\n#define NFS_UNSPEC_TIMEO\t(UINT_MAX)\n\nstruct nfs_client_initdata {\n\tunsigned long init_flags;\n\tconst char *hostname;\t\t\t \n\tconst struct sockaddr_storage *addr;\t \n\tconst char *nodename;\t\t\t \n\tconst char *ip_addr;\t\t\t \n\tsize_t addrlen;\n\tstruct nfs_subversion *nfs_mod;\n\tint proto;\n\tu32 minorversion;\n\tunsigned int nconnect;\n\tunsigned int max_connect;\n\tstruct net *net;\n\tconst struct rpc_timeout *timeparms;\n\tconst struct cred *cred;\n\tstruct xprtsec_parms xprtsec;\n\tunsigned long connect_timeout;\n\tunsigned long reconnect_timeout;\n};\n\n \nstruct nfs_fs_context {\n\tbool\t\t\tinternal;\n\tbool\t\t\tskip_reconfig_option_check;\n\tbool\t\t\tneed_mount;\n\tbool\t\t\tsloppy;\n\tunsigned int\t\tflags;\t\t \n\tunsigned int\t\trsize, wsize;\n\tunsigned int\t\ttimeo, retrans;\n\tunsigned int\t\tacregmin, acregmax;\n\tunsigned int\t\tacdirmin, acdirmax;\n\tunsigned int\t\tnamlen;\n\tunsigned int\t\toptions;\n\tunsigned int\t\tbsize;\n\tstruct nfs_auth_info\tauth_info;\n\trpc_authflavor_t\tselected_flavor;\n\tstruct xprtsec_parms\txprtsec;\n\tchar\t\t\t*client_address;\n\tunsigned int\t\tversion;\n\tunsigned int\t\tminorversion;\n\tchar\t\t\t*fscache_uniq;\n\tunsigned short\t\tprotofamily;\n\tunsigned short\t\tmountfamily;\n\tbool\t\t\thas_sec_mnt_opts;\n\n\tstruct {\n\t\tunion {\n\t\t\tstruct sockaddr\taddress;\n\t\t\tstruct sockaddr_storage\t_address;\n\t\t};\n\t\tsize_t\t\t\taddrlen;\n\t\tchar\t\t\t*hostname;\n\t\tu32\t\t\tversion;\n\t\tint\t\t\tport;\n\t\tunsigned short\t\tprotocol;\n\t} mount_server;\n\n\tstruct {\n\t\tunion {\n\t\t\tstruct sockaddr\taddress;\n\t\t\tstruct sockaddr_storage\t_address;\n\t\t};\n\t\tsize_t\t\t\taddrlen;\n\t\tchar\t\t\t*hostname;\n\t\tchar\t\t\t*export_path;\n\t\tint\t\t\tport;\n\t\tunsigned short\t\tprotocol;\n\t\tunsigned short\t\tnconnect;\n\t\tunsigned short\t\tmax_connect;\n\t\tunsigned short\t\texport_path_len;\n\t} nfs_server;\n\n\tstruct nfs_fh\t\t*mntfh;\n\tstruct nfs_server\t*server;\n\tstruct nfs_subversion\t*nfs_mod;\n\n\t \n\tstruct nfs_clone_mount {\n\t\tstruct super_block\t*sb;\n\t\tstruct dentry\t\t*dentry;\n\t\tstruct nfs_fattr\t*fattr;\n\t\tunsigned int\t\tinherited_bsize;\n\t} clone_data;\n};\n\n#define nfs_errorf(fc, fmt, ...) ((fc)->log.log ?\t\t\\\n\terrorf(fc, fmt, ## __VA_ARGS__) :\t\t\t\\\n\t({ dprintk(fmt \"\\n\", ## __VA_ARGS__); }))\n\n#define nfs_ferrorf(fc, fac, fmt, ...) ((fc)->log.log ?\t\t\\\n\terrorf(fc, fmt, ## __VA_ARGS__) :\t\t\t\\\n\t({ dfprintk(fac, fmt \"\\n\", ## __VA_ARGS__); }))\n\n#define nfs_invalf(fc, fmt, ...) ((fc)->log.log ?\t\t\\\n\tinvalf(fc, fmt, ## __VA_ARGS__) :\t\t\t\\\n\t({ dprintk(fmt \"\\n\", ## __VA_ARGS__);  -EINVAL; }))\n\n#define nfs_finvalf(fc, fac, fmt, ...) ((fc)->log.log ?\t\t\\\n\tinvalf(fc, fmt, ## __VA_ARGS__) :\t\t\t\\\n\t({ dfprintk(fac, fmt \"\\n\", ## __VA_ARGS__);  -EINVAL; }))\n\n#define nfs_warnf(fc, fmt, ...) ((fc)->log.log ?\t\t\\\n\twarnf(fc, fmt, ## __VA_ARGS__) :\t\t\t\\\n\t({ dprintk(fmt \"\\n\", ## __VA_ARGS__); }))\n\n#define nfs_fwarnf(fc, fac, fmt, ...) ((fc)->log.log ?\t\t\\\n\twarnf(fc, fmt, ## __VA_ARGS__) :\t\t\t\\\n\t({ dfprintk(fac, fmt \"\\n\", ## __VA_ARGS__); }))\n\nstatic inline struct nfs_fs_context *nfs_fc2context(const struct fs_context *fc)\n{\n\treturn fc->fs_private;\n}\n\n \nstruct nfs_mount_request {\n\tstruct sockaddr_storage\t*sap;\n\tsize_t\t\t\tsalen;\n\tchar\t\t\t*hostname;\n\tchar\t\t\t*dirpath;\n\tu32\t\t\tversion;\n\tunsigned short\t\tprotocol;\n\tstruct nfs_fh\t\t*fh;\n\tint\t\t\tnoresvport;\n\tunsigned int\t\t*auth_flav_len;\n\trpc_authflavor_t\t*auth_flavs;\n\tstruct net\t\t*net;\n};\n\nextern int nfs_mount(struct nfs_mount_request *info, int timeo, int retrans);\nextern void nfs_umount(const struct nfs_mount_request *info);\n\n \nextern const struct rpc_program nfs_program;\nextern void nfs_clients_init(struct net *net);\nextern void nfs_clients_exit(struct net *net);\nextern struct nfs_client *nfs_alloc_client(const struct nfs_client_initdata *);\nint nfs_create_rpc_client(struct nfs_client *, const struct nfs_client_initdata *, rpc_authflavor_t);\nstruct nfs_client *nfs_get_client(const struct nfs_client_initdata *);\nint nfs_probe_server(struct nfs_server *, struct nfs_fh *);\nvoid nfs_server_insert_lists(struct nfs_server *);\nvoid nfs_server_remove_lists(struct nfs_server *);\nvoid nfs_init_timeout_values(struct rpc_timeout *to, int proto, int timeo, int retrans);\nint nfs_init_server_rpcclient(struct nfs_server *, const struct rpc_timeout *t,\n\t\trpc_authflavor_t);\nstruct nfs_server *nfs_alloc_server(void);\nvoid nfs_server_copy_userdata(struct nfs_server *, struct nfs_server *);\n\nextern void nfs_put_client(struct nfs_client *);\nextern void nfs_free_client(struct nfs_client *);\nextern struct nfs_client *nfs4_find_client_ident(struct net *, int);\nextern struct nfs_client *\nnfs4_find_client_sessionid(struct net *, const struct sockaddr *,\n\t\t\t\tstruct nfs4_sessionid *, u32);\nextern struct nfs_server *nfs_create_server(struct fs_context *);\nextern void nfs4_server_set_init_caps(struct nfs_server *);\nextern struct nfs_server *nfs4_create_server(struct fs_context *);\nextern struct nfs_server *nfs4_create_referral_server(struct fs_context *);\nextern int nfs4_update_server(struct nfs_server *server, const char *hostname,\n\t\t\t\t\tstruct sockaddr_storage *sap, size_t salen,\n\t\t\t\t\tstruct net *net);\nextern void nfs_free_server(struct nfs_server *server);\nextern struct nfs_server *nfs_clone_server(struct nfs_server *,\n\t\t\t\t\t   struct nfs_fh *,\n\t\t\t\t\t   struct nfs_fattr *,\n\t\t\t\t\t   rpc_authflavor_t);\nextern bool nfs_client_init_is_complete(const struct nfs_client *clp);\nextern int nfs_client_init_status(const struct nfs_client *clp);\nextern int nfs_wait_client_init_complete(const struct nfs_client *clp);\nextern void nfs_mark_client_ready(struct nfs_client *clp, int state);\nextern struct nfs_client *nfs4_set_ds_client(struct nfs_server *mds_srv,\n\t\t\t\t\t     const struct sockaddr_storage *ds_addr,\n\t\t\t\t\t     int ds_addrlen, int ds_proto,\n\t\t\t\t\t     unsigned int ds_timeo,\n\t\t\t\t\t     unsigned int ds_retrans,\n\t\t\t\t\t     u32 minor_version);\nextern struct rpc_clnt *nfs4_find_or_create_ds_client(struct nfs_client *,\n\t\t\t\t\t\tstruct inode *);\nextern struct nfs_client *nfs3_set_ds_client(struct nfs_server *mds_srv,\n\t\t\tconst struct sockaddr_storage *ds_addr, int ds_addrlen,\n\t\t\tint ds_proto, unsigned int ds_timeo,\n\t\t\tunsigned int ds_retrans);\n#ifdef CONFIG_PROC_FS\nextern int __init nfs_fs_proc_init(void);\nextern void nfs_fs_proc_exit(void);\nextern int nfs_fs_proc_net_init(struct net *net);\nextern void nfs_fs_proc_net_exit(struct net *net);\n#else\nstatic inline int nfs_fs_proc_net_init(struct net *net)\n{\n\treturn 0;\n}\nstatic inline void nfs_fs_proc_net_exit(struct net *net)\n{\n}\nstatic inline int nfs_fs_proc_init(void)\n{\n\treturn 0;\n}\nstatic inline void nfs_fs_proc_exit(void)\n{\n}\n#endif\n\n \nextern const struct svc_version nfs4_callback_version1;\nextern const struct svc_version nfs4_callback_version4;\n\n \nextern struct file_system_type nfs_fs_type;\n\n \nextern int __init nfs_init_nfspagecache(void);\nextern void nfs_destroy_nfspagecache(void);\nextern int __init nfs_init_readpagecache(void);\nextern void nfs_destroy_readpagecache(void);\nextern int __init nfs_init_writepagecache(void);\nextern void nfs_destroy_writepagecache(void);\n\nextern int __init nfs_init_directcache(void);\nextern void nfs_destroy_directcache(void);\nextern void nfs_pgheader_init(struct nfs_pageio_descriptor *desc,\n\t\t\t      struct nfs_pgio_header *hdr,\n\t\t\t      void (*release)(struct nfs_pgio_header *hdr));\nvoid nfs_set_pgio_error(struct nfs_pgio_header *hdr, int error, loff_t pos);\nint nfs_iocounter_wait(struct nfs_lock_context *l_ctx);\n\nextern const struct nfs_pageio_ops nfs_pgio_rw_ops;\nstruct nfs_pgio_header *nfs_pgio_header_alloc(const struct nfs_rw_ops *);\nvoid nfs_pgio_header_free(struct nfs_pgio_header *);\nint nfs_generic_pgio(struct nfs_pageio_descriptor *, struct nfs_pgio_header *);\nint nfs_initiate_pgio(struct rpc_clnt *clnt, struct nfs_pgio_header *hdr,\n\t\t      const struct cred *cred, const struct nfs_rpc_ops *rpc_ops,\n\t\t      const struct rpc_call_ops *call_ops, int how, int flags);\nvoid nfs_free_request(struct nfs_page *req);\nstruct nfs_pgio_mirror *\nnfs_pgio_current_mirror(struct nfs_pageio_descriptor *desc);\n\nstatic inline bool nfs_match_open_context(const struct nfs_open_context *ctx1,\n\t\tconst struct nfs_open_context *ctx2)\n{\n\treturn cred_fscmp(ctx1->cred, ctx2->cred) == 0 && ctx1->state == ctx2->state;\n}\n\n \nextern const struct rpc_procinfo nfs_procedures[];\nextern int nfs2_decode_dirent(struct xdr_stream *,\n\t\t\t\tstruct nfs_entry *, bool);\n\n \nextern const struct rpc_procinfo nfs3_procedures[];\nextern int nfs3_decode_dirent(struct xdr_stream *,\n\t\t\t\tstruct nfs_entry *, bool);\n\n \n#if IS_ENABLED(CONFIG_NFS_V4)\nextern int nfs4_decode_dirent(struct xdr_stream *,\n\t\t\t\tstruct nfs_entry *, bool);\n#endif\n#ifdef CONFIG_NFS_V4_1\nextern const u32 nfs41_maxread_overhead;\nextern const u32 nfs41_maxwrite_overhead;\nextern const u32 nfs41_maxgetdevinfo_overhead;\n#endif\n\n \n#if IS_ENABLED(CONFIG_NFS_V4)\nextern const struct rpc_procinfo nfs4_procedures[];\n#endif\n\n#ifdef CONFIG_NFS_V4_SECURITY_LABEL\nextern struct nfs4_label *nfs4_label_alloc(struct nfs_server *server, gfp_t flags);\nstatic inline struct nfs4_label *\nnfs4_label_copy(struct nfs4_label *dst, struct nfs4_label *src)\n{\n\tif (!dst || !src)\n\t\treturn NULL;\n\n\tif (src->len > NFS4_MAXLABELLEN)\n\t\treturn NULL;\n\n\tdst->lfs = src->lfs;\n\tdst->pi = src->pi;\n\tdst->len = src->len;\n\tmemcpy(dst->label, src->label, src->len);\n\n\treturn dst;\n}\n\nstatic inline void nfs_zap_label_cache_locked(struct nfs_inode *nfsi)\n{\n\tif (nfs_server_capable(&nfsi->vfs_inode, NFS_CAP_SECURITY_LABEL))\n\t\tnfsi->cache_validity |= NFS_INO_INVALID_LABEL;\n}\n#else\nstatic inline struct nfs4_label *nfs4_label_alloc(struct nfs_server *server, gfp_t flags) { return NULL; }\nstatic inline void nfs_zap_label_cache_locked(struct nfs_inode *nfsi)\n{\n}\nstatic inline struct nfs4_label *\nnfs4_label_copy(struct nfs4_label *dst, struct nfs4_label *src)\n{\n\treturn NULL;\n}\n#endif  \n\n \nvoid nfs_close_context(struct nfs_open_context *ctx, int is_sync);\nextern struct nfs_client *nfs_init_client(struct nfs_client *clp,\n\t\t\t   const struct nfs_client_initdata *);\n\n \nextern void nfs_readdir_record_entry_cache_hit(struct inode *dir);\nextern void nfs_readdir_record_entry_cache_miss(struct inode *dir);\nextern unsigned long nfs_access_cache_count(struct shrinker *shrink,\n\t\t\t\t\t    struct shrink_control *sc);\nextern unsigned long nfs_access_cache_scan(struct shrinker *shrink,\n\t\t\t\t\t   struct shrink_control *sc);\nstruct dentry *nfs_lookup(struct inode *, struct dentry *, unsigned int);\nvoid nfs_d_prune_case_insensitive_aliases(struct inode *inode);\nint nfs_create(struct mnt_idmap *, struct inode *, struct dentry *,\n\t       umode_t, bool);\nint nfs_mkdir(struct mnt_idmap *, struct inode *, struct dentry *,\n\t      umode_t);\nint nfs_rmdir(struct inode *, struct dentry *);\nint nfs_unlink(struct inode *, struct dentry *);\nint nfs_symlink(struct mnt_idmap *, struct inode *, struct dentry *,\n\t\tconst char *);\nint nfs_link(struct dentry *, struct inode *, struct dentry *);\nint nfs_mknod(struct mnt_idmap *, struct inode *, struct dentry *, umode_t,\n\t      dev_t);\nint nfs_rename(struct mnt_idmap *, struct inode *, struct dentry *,\n\t       struct inode *, struct dentry *, unsigned int);\n\n#ifdef CONFIG_NFS_V4_2\nstatic inline __u32 nfs_access_xattr_mask(const struct nfs_server *server)\n{\n\tif (!(server->caps & NFS_CAP_XATTR))\n\t\treturn 0;\n\treturn NFS4_ACCESS_XAREAD | NFS4_ACCESS_XAWRITE | NFS4_ACCESS_XALIST;\n}\n#else\nstatic inline __u32 nfs_access_xattr_mask(const struct nfs_server *server)\n{\n\treturn 0;\n}\n#endif\n\n \nint nfs_file_fsync(struct file *file, loff_t start, loff_t end, int datasync);\nloff_t nfs_file_llseek(struct file *, loff_t, int);\nssize_t nfs_file_read(struct kiocb *, struct iov_iter *);\nssize_t nfs_file_splice_read(struct file *in, loff_t *ppos, struct pipe_inode_info *pipe,\n\t\t\t     size_t len, unsigned int flags);\nint nfs_file_mmap(struct file *, struct vm_area_struct *);\nssize_t nfs_file_write(struct kiocb *, struct iov_iter *);\nint nfs_file_release(struct inode *, struct file *);\nint nfs_lock(struct file *, int, struct file_lock *);\nint nfs_flock(struct file *, int, struct file_lock *);\nint nfs_check_flags(int);\n\n \nextern struct workqueue_struct *nfsiod_workqueue;\nextern struct inode *nfs_alloc_inode(struct super_block *sb);\nextern void nfs_free_inode(struct inode *);\nextern int nfs_write_inode(struct inode *, struct writeback_control *);\nextern int nfs_drop_inode(struct inode *);\nextern void nfs_clear_inode(struct inode *);\nextern void nfs_evict_inode(struct inode *);\nextern void nfs_zap_acl_cache(struct inode *inode);\nextern void nfs_set_cache_invalid(struct inode *inode, unsigned long flags);\nextern bool nfs_check_cache_invalid(struct inode *, unsigned long);\nextern int nfs_wait_bit_killable(struct wait_bit_key *key, int mode);\n\n \nextern const struct super_operations nfs_sops;\nbool nfs_auth_info_match(const struct nfs_auth_info *, rpc_authflavor_t);\nint nfs_try_get_tree(struct fs_context *);\nint nfs_get_tree_common(struct fs_context *);\nvoid nfs_kill_super(struct super_block *);\n\nextern struct rpc_stat nfs_rpcstat;\n\nextern int __init register_nfs_fs(void);\nextern void __exit unregister_nfs_fs(void);\nextern bool nfs_sb_active(struct super_block *sb);\nextern void nfs_sb_deactive(struct super_block *sb);\nextern int nfs_client_for_each_server(struct nfs_client *clp,\n\t\t\t\t      int (*fn)(struct nfs_server *, void *),\n\t\t\t\t      void *data);\n#ifdef CONFIG_NFS_FSCACHE\nextern const struct netfs_request_ops nfs_netfs_ops;\n#endif\n\n \nextern void nfs_start_io_read(struct inode *inode);\nextern void nfs_end_io_read(struct inode *inode);\nextern void nfs_start_io_write(struct inode *inode);\nextern void nfs_end_io_write(struct inode *inode);\nextern void nfs_start_io_direct(struct inode *inode);\nextern void nfs_end_io_direct(struct inode *inode);\n\nstatic inline bool nfs_file_io_is_buffered(struct nfs_inode *nfsi)\n{\n\treturn test_bit(NFS_INO_ODIRECT, &nfsi->flags) == 0;\n}\n\n \n#define NFS_PATH_CANONICAL 1\nextern char *nfs_path(char **p, struct dentry *dentry,\n\t\t      char *buffer, ssize_t buflen, unsigned flags);\nextern struct vfsmount *nfs_d_automount(struct path *path);\nint nfs_submount(struct fs_context *, struct nfs_server *);\nint nfs_do_submount(struct fs_context *);\n\n \nextern int nfs_get_root(struct super_block *s, struct fs_context *fc);\n#if IS_ENABLED(CONFIG_NFS_V4)\nextern int nfs4_get_rootfh(struct nfs_server *server, struct nfs_fh *mntfh, bool);\n#endif\n\nstruct nfs_pgio_completion_ops;\n \nextern const struct nfs_pgio_completion_ops nfs_async_read_completion_ops;\nextern void nfs_pageio_init_read(struct nfs_pageio_descriptor *pgio,\n\t\t\tstruct inode *inode, bool force_mds,\n\t\t\tconst struct nfs_pgio_completion_ops *compl_ops);\nextern bool nfs_read_alloc_scratch(struct nfs_pgio_header *hdr, size_t size);\nextern int nfs_read_add_folio(struct nfs_pageio_descriptor *pgio,\n\t\t\t       struct nfs_open_context *ctx,\n\t\t\t       struct folio *folio);\nextern void nfs_pageio_complete_read(struct nfs_pageio_descriptor *pgio);\nextern void nfs_read_prepare(struct rpc_task *task, void *calldata);\nextern void nfs_pageio_reset_read_mds(struct nfs_pageio_descriptor *pgio);\n\n \nvoid nfs_umount_begin(struct super_block *);\nint  nfs_statfs(struct dentry *, struct kstatfs *);\nint  nfs_show_options(struct seq_file *, struct dentry *);\nint  nfs_show_devname(struct seq_file *, struct dentry *);\nint  nfs_show_path(struct seq_file *, struct dentry *);\nint  nfs_show_stats(struct seq_file *, struct dentry *);\nint  nfs_reconfigure(struct fs_context *);\n\n \nextern void nfs_pageio_init_write(struct nfs_pageio_descriptor *pgio,\n\t\t\tstruct inode *inode, int ioflags, bool force_mds,\n\t\t\tconst struct nfs_pgio_completion_ops *compl_ops);\nextern void nfs_pageio_reset_write_mds(struct nfs_pageio_descriptor *pgio);\nextern void nfs_commit_free(struct nfs_commit_data *p);\nextern void nfs_commit_prepare(struct rpc_task *task, void *calldata);\nextern int nfs_initiate_commit(struct rpc_clnt *clnt,\n\t\t\t       struct nfs_commit_data *data,\n\t\t\t       const struct nfs_rpc_ops *nfs_ops,\n\t\t\t       const struct rpc_call_ops *call_ops,\n\t\t\t       int how, int flags);\nextern void nfs_init_commit(struct nfs_commit_data *data,\n\t\t\t    struct list_head *head,\n\t\t\t    struct pnfs_layout_segment *lseg,\n\t\t\t    struct nfs_commit_info *cinfo);\nint nfs_scan_commit_list(struct list_head *src, struct list_head *dst,\n\t\t\t struct nfs_commit_info *cinfo, int max);\nunsigned long nfs_reqs_to_commit(struct nfs_commit_info *);\nint nfs_scan_commit(struct inode *inode, struct list_head *dst,\n\t\t    struct nfs_commit_info *cinfo);\nvoid nfs_mark_request_commit(struct nfs_page *req,\n\t\t\t     struct pnfs_layout_segment *lseg,\n\t\t\t     struct nfs_commit_info *cinfo,\n\t\t\t     u32 ds_commit_idx);\nint nfs_write_need_commit(struct nfs_pgio_header *);\nvoid nfs_writeback_update_inode(struct nfs_pgio_header *hdr);\nint nfs_generic_commit_list(struct inode *inode, struct list_head *head,\n\t\t\t    int how, struct nfs_commit_info *cinfo);\nvoid nfs_retry_commit(struct list_head *page_list,\n\t\t      struct pnfs_layout_segment *lseg,\n\t\t      struct nfs_commit_info *cinfo,\n\t\t      u32 ds_commit_idx);\nvoid nfs_commitdata_release(struct nfs_commit_data *data);\nvoid nfs_request_add_commit_list(struct nfs_page *req,\n\t\t\t\t struct nfs_commit_info *cinfo);\nvoid nfs_request_add_commit_list_locked(struct nfs_page *req,\n\t\tstruct list_head *dst,\n\t\tstruct nfs_commit_info *cinfo);\nvoid nfs_request_remove_commit_list(struct nfs_page *req,\n\t\t\t\t    struct nfs_commit_info *cinfo);\nvoid nfs_init_cinfo(struct nfs_commit_info *cinfo,\n\t\t    struct inode *inode,\n\t\t    struct nfs_direct_req *dreq);\nint nfs_key_timeout_notify(struct file *filp, struct inode *inode);\nbool nfs_ctx_key_to_expire(struct nfs_open_context *ctx, struct inode *inode);\nvoid nfs_pageio_stop_mirroring(struct nfs_pageio_descriptor *pgio);\n\nint nfs_filemap_write_and_wait_range(struct address_space *mapping,\n\t\tloff_t lstart, loff_t lend);\n\n#ifdef CONFIG_NFS_V4_1\nstatic inline void\npnfs_bucket_clear_pnfs_ds_commit_verifiers(struct pnfs_commit_bucket *buckets,\n\t\tunsigned int nbuckets)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < nbuckets; i++)\n\t\tbuckets[i].direct_verf.committed = NFS_INVALID_STABLE_HOW;\n}\nstatic inline\nvoid nfs_clear_pnfs_ds_commit_verifiers(struct pnfs_ds_commit_info *cinfo)\n{\n\tstruct pnfs_commit_array *array;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(array, &cinfo->commits, cinfo_list)\n\t\tpnfs_bucket_clear_pnfs_ds_commit_verifiers(array->buckets,\n\t\t\t\tarray->nbuckets);\n\trcu_read_unlock();\n}\n#else\nstatic inline\nvoid nfs_clear_pnfs_ds_commit_verifiers(struct pnfs_ds_commit_info *cinfo)\n{\n}\n#endif\n\n#ifdef CONFIG_MIGRATION\nint nfs_migrate_folio(struct address_space *, struct folio *dst,\n\t\tstruct folio *src, enum migrate_mode);\n#else\n#define nfs_migrate_folio NULL\n#endif\n\nstatic inline int\nnfs_write_verifier_cmp(const struct nfs_write_verifier *v1,\n\t\tconst struct nfs_write_verifier *v2)\n{\n\treturn memcmp(v1->data, v2->data, sizeof(v1->data));\n}\n\nstatic inline bool\nnfs_write_match_verf(const struct nfs_writeverf *verf,\n\t\tstruct nfs_page *req)\n{\n\treturn verf->committed > NFS_UNSTABLE &&\n\t\t!nfs_write_verifier_cmp(&req->wb_verf, &verf->verifier);\n}\n\nstatic inline gfp_t nfs_io_gfp_mask(void)\n{\n\tif (current->flags & PF_WQ_WORKER)\n\t\treturn GFP_KERNEL | __GFP_NORETRY | __GFP_NOWARN;\n\treturn GFP_KERNEL;\n}\n\n \nstatic inline int nfs_should_remove_suid(const struct inode *inode)\n{\n\tumode_t mode = inode->i_mode;\n\tint kill = 0;\n\n\t \n\tif (unlikely(mode & S_ISUID))\n\t\tkill = ATTR_KILL_SUID;\n\n\t \n\tif (unlikely((mode & S_ISGID) && (mode & S_IXGRP)))\n\t\tkill |= ATTR_KILL_SGID;\n\n\tif (unlikely(kill && S_ISREG(mode)))\n\t\treturn kill;\n\n\treturn 0;\n}\n\n \nextern struct rpc_task *\nnfs_async_rename(struct inode *old_dir, struct inode *new_dir,\n\t\t struct dentry *old_dentry, struct dentry *new_dentry,\n\t\t void (*complete)(struct rpc_task *, struct nfs_renamedata *));\nextern int nfs_sillyrename(struct inode *dir, struct dentry *dentry);\n\n \nvoid nfs_init_cinfo_from_dreq(struct nfs_commit_info *cinfo,\n\t\t\t      struct nfs_direct_req *dreq);\nextern ssize_t nfs_dreq_bytes_left(struct nfs_direct_req *dreq, loff_t offset);\n\n \nextern struct nfs_client *nfs4_init_client(struct nfs_client *clp,\n\t\t\t    const struct nfs_client_initdata *);\nextern int nfs40_walk_client_list(struct nfs_client *clp,\n\t\t\t\tstruct nfs_client **result,\n\t\t\t\tconst struct cred *cred);\nextern int nfs41_walk_client_list(struct nfs_client *clp,\n\t\t\t\tstruct nfs_client **result,\n\t\t\t\tconst struct cred *cred);\nextern void nfs4_test_session_trunk(struct rpc_clnt *clnt,\n\t\t\t\tstruct rpc_xprt *xprt,\n\t\t\t\tvoid *data);\n\nstatic inline struct inode *nfs_igrab_and_active(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (sb && nfs_sb_active(sb)) {\n\t\tif (igrab(inode))\n\t\t\treturn inode;\n\t\tnfs_sb_deactive(sb);\n\t}\n\treturn NULL;\n}\n\nstatic inline void nfs_iput_and_deactive(struct inode *inode)\n{\n\tif (inode != NULL) {\n\t\tstruct super_block *sb = inode->i_sb;\n\n\t\tiput(inode);\n\t\tnfs_sb_deactive(sb);\n\t}\n}\n\n \nstatic inline char *nfs_devname(struct dentry *dentry,\n\t\t\t\tchar *buffer, ssize_t buflen)\n{\n\tchar *dummy;\n\treturn nfs_path(&dummy, dentry, buffer, buflen, NFS_PATH_CANONICAL);\n}\n\n \nstatic inline\nunsigned long nfs_block_bits(unsigned long bsize, unsigned char *nrbitsp)\n{\n\t \n\tif ((bsize & (bsize - 1)) || nrbitsp) {\n\t\tunsigned char\tnrbits;\n\n\t\tfor (nrbits = 31; nrbits && !(bsize & (1 << nrbits)); nrbits--)\n\t\t\t;\n\t\tbsize = 1 << nrbits;\n\t\tif (nrbitsp)\n\t\t\t*nrbitsp = nrbits;\n\t}\n\n\treturn bsize;\n}\n\n \nstatic inline blkcnt_t nfs_calc_block_size(u64 tsize)\n{\n\tblkcnt_t used = (tsize + 511) >> 9;\n\treturn (used > ULONG_MAX) ? ULONG_MAX : used;\n}\n\n \nstatic inline\nunsigned long nfs_block_size(unsigned long bsize, unsigned char *nrbitsp)\n{\n\tif (bsize < NFS_MIN_FILE_IO_SIZE)\n\t\tbsize = NFS_DEF_FILE_IO_SIZE;\n\telse if (bsize >= NFS_MAX_FILE_IO_SIZE)\n\t\tbsize = NFS_MAX_FILE_IO_SIZE;\n\n\treturn nfs_block_bits(bsize, nrbitsp);\n}\n\n \nstatic inline\nunsigned long nfs_io_size(unsigned long iosize, enum xprt_transports proto)\n{\n\tif (iosize < NFS_MIN_FILE_IO_SIZE)\n\t\tiosize = NFS_DEF_FILE_IO_SIZE;\n\telse if (iosize >= NFS_MAX_FILE_IO_SIZE)\n\t\tiosize = NFS_MAX_FILE_IO_SIZE;\n\n\tif (proto == XPRT_TRANSPORT_UDP || iosize < PAGE_SIZE)\n\t\treturn nfs_block_bits(iosize, NULL);\n\treturn iosize & PAGE_MASK;\n}\n\n \nstatic inline\nvoid nfs_super_set_maxbytes(struct super_block *sb, __u64 maxfilesize)\n{\n\tsb->s_maxbytes = (loff_t)maxfilesize;\n\tif (sb->s_maxbytes > MAX_LFS_FILESIZE || sb->s_maxbytes <= 0)\n\t\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n}\n\n \nstatic inline void nfs_folio_mark_unstable(struct folio *folio,\n\t\t\t\t\t   struct nfs_commit_info *cinfo)\n{\n\tif (folio && !cinfo->dreq) {\n\t\tstruct inode *inode = folio_file_mapping(folio)->host;\n\t\tlong nr = folio_nr_pages(folio);\n\n\t\t \n\t\tnode_stat_mod_folio(folio, NR_WRITEBACK, nr);\n\t\twb_stat_mod(&inode_to_bdi(inode)->wb, WB_WRITEBACK, nr);\n\t\t__mark_inode_dirty(inode, I_DIRTY_DATASYNC);\n\t}\n}\n\n \nstatic inline\nunsigned int nfs_page_length(struct page *page)\n{\n\tloff_t i_size = i_size_read(page_file_mapping(page)->host);\n\n\tif (i_size > 0) {\n\t\tpgoff_t index = page_index(page);\n\t\tpgoff_t end_index = (i_size - 1) >> PAGE_SHIFT;\n\t\tif (index < end_index)\n\t\t\treturn PAGE_SIZE;\n\t\tif (index == end_index)\n\t\t\treturn ((i_size - 1) & ~PAGE_MASK) + 1;\n\t}\n\treturn 0;\n}\n\n \nstatic inline size_t nfs_folio_length(struct folio *folio)\n{\n\tloff_t i_size = i_size_read(folio_file_mapping(folio)->host);\n\n\tif (i_size > 0) {\n\t\tpgoff_t index = folio_index(folio) >> folio_order(folio);\n\t\tpgoff_t end_index = (i_size - 1) >> folio_shift(folio);\n\t\tif (index < end_index)\n\t\t\treturn folio_size(folio);\n\t\tif (index == end_index)\n\t\t\treturn offset_in_folio(folio, i_size - 1) + 1;\n\t}\n\treturn 0;\n}\n\n \nstatic inline\nunsigned char nfs_umode_to_dtype(umode_t mode)\n{\n\treturn (mode >> 12) & 15;\n}\n\n \nstatic inline unsigned int nfs_page_array_len(unsigned int base, size_t len)\n{\n\treturn ((unsigned long)len + (unsigned long)base + PAGE_SIZE - 1) >>\n\t       PAGE_SHIFT;\n}\n\n \nstatic inline\nu64 nfs_timespec_to_change_attr(const struct timespec64 *ts)\n{\n\treturn ((u64)ts->tv_sec << 30) + ts->tv_nsec;\n}\n\n#ifdef CONFIG_CRC32\nstatic inline u32 nfs_stateid_hash(const nfs4_stateid *stateid)\n{\n\treturn ~crc32_le(0xFFFFFFFF, &stateid->other[0],\n\t\t\t\tNFS4_STATEID_OTHER_SIZE);\n}\n#else\nstatic inline u32 nfs_stateid_hash(nfs4_stateid *stateid)\n{\n\treturn 0;\n}\n#endif\n\nstatic inline bool nfs_error_is_fatal(int err)\n{\n\tswitch (err) {\n\tcase -ERESTARTSYS:\n\tcase -EINTR:\n\tcase -EACCES:\n\tcase -EDQUOT:\n\tcase -EFBIG:\n\tcase -EIO:\n\tcase -ENOSPC:\n\tcase -EROFS:\n\tcase -ESTALE:\n\tcase -E2BIG:\n\tcase -ENOMEM:\n\tcase -ETIMEDOUT:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic inline bool nfs_error_is_fatal_on_server(int err)\n{\n\tswitch (err) {\n\tcase 0:\n\tcase -ERESTARTSYS:\n\tcase -EINTR:\n\tcase -ENOMEM:\n\t\treturn false;\n\t}\n\treturn nfs_error_is_fatal(err);\n}\n\n \nstatic inline void nfs_set_port(struct sockaddr_storage *sap, int *port,\n\t\t\t\tconst unsigned short default_port)\n{\n\tif (*port == NFS_UNSPEC_PORT)\n\t\t*port = default_port;\n\n\trpc_set_port((struct sockaddr *)sap, *port);\n}\n\nstruct nfs_direct_req {\n\tstruct kref\t\tkref;\t\t \n\n\t \n\tstruct nfs_open_context\t*ctx;\t\t \n\tstruct nfs_lock_context *l_ctx;\t\t \n\tstruct kiocb *\t\tiocb;\t\t \n\tstruct inode *\t\tinode;\t\t \n\n\t \n\tatomic_t\t\tio_count;\t \n\tspinlock_t\t\tlock;\t\t \n\n\tloff_t\t\t\tio_start;\t \n\tssize_t\t\t\tcount,\t\t \n\t\t\t\tmax_count,\t \n\t\t\t\tbytes_left,\t \n\t\t\t\terror;\t\t \n\tstruct completion\tcompletion;\t \n\n\t \n\tstruct nfs_mds_commit_info mds_cinfo;\t \n\tstruct pnfs_ds_commit_info ds_cinfo;\t \n\tstruct work_struct\twork;\n\tint\t\t\tflags;\n\t \n#define NFS_ODIRECT_DO_COMMIT\t\t(1)\t \n#define NFS_ODIRECT_RESCHED_WRITES\t(2)\t \n\t \n#define NFS_ODIRECT_SHOULD_DIRTY\t(3)\t \n#define NFS_ODIRECT_DONE\t\tINT_MAX\t \n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}