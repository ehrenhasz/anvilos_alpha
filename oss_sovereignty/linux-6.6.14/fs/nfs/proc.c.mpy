{
  "module_name": "proc.c",
  "hash_id": "fa76add7b5937658fae4e788b9bcc9af11a81e07cafb41ee1ce686362c6ae9b8",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfs/proc.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/param.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/in.h>\n#include <linux/pagemap.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/nfs.h>\n#include <linux/nfs2.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/lockd/bind.h>\n#include <linux/freezer.h>\n#include \"internal.h\"\n\n#define NFSDBG_FACILITY\t\tNFSDBG_PROC\n\n \nstatic int\nnfs_proc_get_root(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\t  struct nfs_fsinfo *info)\n{\n\tstruct nfs_fattr *fattr = info->fattr;\n\tstruct nfs2_fsstat fsinfo;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs_procedures[NFSPROC_GETATTR],\n\t\t.rpc_argp\t= fhandle,\n\t\t.rpc_resp\t= fattr,\n\t};\n\tint status;\n\n\tdprintk(\"%s: call getattr\\n\", __func__);\n\tnfs_fattr_init(fattr);\n\tstatus = rpc_call_sync(server->client, &msg, 0);\n\t \n\tif (status && server->nfs_client->cl_rpcclient != server->client)\n\t\tstatus = rpc_call_sync(server->nfs_client->cl_rpcclient, &msg, 0);\n\tdprintk(\"%s: reply getattr: %d\\n\", __func__, status);\n\tif (status)\n\t\treturn status;\n\tdprintk(\"%s: call statfs\\n\", __func__);\n\tmsg.rpc_proc = &nfs_procedures[NFSPROC_STATFS];\n\tmsg.rpc_resp = &fsinfo;\n\tstatus = rpc_call_sync(server->client, &msg, 0);\n\t \n\tif (status && server->nfs_client->cl_rpcclient != server->client)\n\t\tstatus = rpc_call_sync(server->nfs_client->cl_rpcclient, &msg, 0);\n\tdprintk(\"%s: reply statfs: %d\\n\", __func__, status);\n\tif (status)\n\t\treturn status;\n\tinfo->rtmax  = NFS_MAXDATA;\n\tinfo->rtpref = fsinfo.tsize;\n\tinfo->rtmult = fsinfo.bsize;\n\tinfo->wtmax  = NFS_MAXDATA;\n\tinfo->wtpref = fsinfo.tsize;\n\tinfo->wtmult = fsinfo.bsize;\n\tinfo->dtpref = fsinfo.tsize;\n\tinfo->maxfilesize = 0x7FFFFFFF;\n\tinfo->lease_time = 0;\n\tinfo->change_attr_type = NFS4_CHANGE_TYPE_IS_UNDEFINED;\n\tinfo->xattr_support = 0;\n\treturn 0;\n}\n\n \nstatic int\nnfs_proc_getattr(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\tstruct nfs_fattr *fattr, struct inode *inode)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs_procedures[NFSPROC_GETATTR],\n\t\t.rpc_argp\t= fhandle,\n\t\t.rpc_resp\t= fattr,\n\t};\n\tint\tstatus;\n\tunsigned short task_flags = 0;\n\n\t \n\tif (inode && (server->flags & NFS_MOUNT_SOFTREVAL))\n\t\ttask_flags |= RPC_TASK_TIMEOUT;\n\n\tdprintk(\"NFS call  getattr\\n\");\n\tnfs_fattr_init(fattr);\n\tstatus = rpc_call_sync(server->client, &msg, task_flags);\n\tdprintk(\"NFS reply getattr: %d\\n\", status);\n\treturn status;\n}\n\nstatic int\nnfs_proc_setattr(struct dentry *dentry, struct nfs_fattr *fattr,\n\t\t struct iattr *sattr)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct nfs_sattrargs\targ = { \n\t\t.fh\t= NFS_FH(inode),\n\t\t.sattr\t= sattr\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs_procedures[NFSPROC_SETATTR],\n\t\t.rpc_argp\t= &arg,\n\t\t.rpc_resp\t= fattr,\n\t};\n\tint\tstatus;\n\n\t \n\tsattr->ia_mode &= S_IALLUGO;\n\n\tdprintk(\"NFS call  setattr\\n\");\n\tif (sattr->ia_valid & ATTR_FILE)\n\t\tmsg.rpc_cred = nfs_file_cred(sattr->ia_file);\n\tnfs_fattr_init(fattr);\n\tstatus = rpc_call_sync(NFS_CLIENT(inode), &msg, 0);\n\tif (status == 0)\n\t\tnfs_setattr_update_inode(inode, sattr, fattr);\n\tdprintk(\"NFS reply setattr: %d\\n\", status);\n\treturn status;\n}\n\nstatic int\nnfs_proc_lookup(struct inode *dir, struct dentry *dentry,\n\t\tstruct nfs_fh *fhandle, struct nfs_fattr *fattr)\n{\n\tstruct nfs_diropargs\targ = {\n\t\t.fh\t\t= NFS_FH(dir),\n\t\t.name\t\t= dentry->d_name.name,\n\t\t.len\t\t= dentry->d_name.len\n\t};\n\tstruct nfs_diropok\tres = {\n\t\t.fh\t\t= fhandle,\n\t\t.fattr\t\t= fattr\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs_procedures[NFSPROC_LOOKUP],\n\t\t.rpc_argp\t= &arg,\n\t\t.rpc_resp\t= &res,\n\t};\n\tint\t\t\tstatus;\n\tunsigned short task_flags = 0;\n\n\t \n\tif (nfs_lookup_is_soft_revalidate(dentry))\n\t\ttask_flags |= RPC_TASK_TIMEOUT;\n\n\tdprintk(\"NFS call  lookup %pd2\\n\", dentry);\n\tnfs_fattr_init(fattr);\n\tstatus = rpc_call_sync(NFS_CLIENT(dir), &msg, task_flags);\n\tdprintk(\"NFS reply lookup: %d\\n\", status);\n\treturn status;\n}\n\nstatic int nfs_proc_readlink(struct inode *inode, struct page *page,\n\t\tunsigned int pgbase, unsigned int pglen)\n{\n\tstruct nfs_readlinkargs\targs = {\n\t\t.fh\t\t= NFS_FH(inode),\n\t\t.pgbase\t\t= pgbase,\n\t\t.pglen\t\t= pglen,\n\t\t.pages\t\t= &page\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs_procedures[NFSPROC_READLINK],\n\t\t.rpc_argp\t= &args,\n\t};\n\tint\t\t\tstatus;\n\n\tdprintk(\"NFS call  readlink\\n\");\n\tstatus = rpc_call_sync(NFS_CLIENT(inode), &msg, 0);\n\tdprintk(\"NFS reply readlink: %d\\n\", status);\n\treturn status;\n}\n\nstruct nfs_createdata {\n\tstruct nfs_createargs arg;\n\tstruct nfs_diropok res;\n\tstruct nfs_fh fhandle;\n\tstruct nfs_fattr fattr;\n};\n\nstatic struct nfs_createdata *nfs_alloc_createdata(struct inode *dir,\n\t\tstruct dentry *dentry, struct iattr *sattr)\n{\n\tstruct nfs_createdata *data;\n\n\tdata = kmalloc(sizeof(*data), GFP_KERNEL);\n\n\tif (data != NULL) {\n\t\tdata->arg.fh = NFS_FH(dir);\n\t\tdata->arg.name = dentry->d_name.name;\n\t\tdata->arg.len = dentry->d_name.len;\n\t\tdata->arg.sattr = sattr;\n\t\tnfs_fattr_init(&data->fattr);\n\t\tdata->fhandle.size = 0;\n\t\tdata->res.fh = &data->fhandle;\n\t\tdata->res.fattr = &data->fattr;\n\t}\n\treturn data;\n};\n\nstatic void nfs_free_createdata(const struct nfs_createdata *data)\n{\n\tkfree(data);\n}\n\nstatic int\nnfs_proc_create(struct inode *dir, struct dentry *dentry, struct iattr *sattr,\n\t\tint flags)\n{\n\tstruct nfs_createdata *data;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs_procedures[NFSPROC_CREATE],\n\t};\n\tint status = -ENOMEM;\n\n\tdprintk(\"NFS call  create %pd\\n\", dentry);\n\tdata = nfs_alloc_createdata(dir, dentry, sattr);\n\tif (data == NULL)\n\t\tgoto out;\n\tmsg.rpc_argp = &data->arg;\n\tmsg.rpc_resp = &data->res;\n\tstatus = rpc_call_sync(NFS_CLIENT(dir), &msg, 0);\n\tnfs_mark_for_revalidate(dir);\n\tif (status == 0)\n\t\tstatus = nfs_instantiate(dentry, data->res.fh, data->res.fattr);\n\tnfs_free_createdata(data);\nout:\n\tdprintk(\"NFS reply create: %d\\n\", status);\n\treturn status;\n}\n\n \nstatic int\nnfs_proc_mknod(struct inode *dir, struct dentry *dentry, struct iattr *sattr,\n\t       dev_t rdev)\n{\n\tstruct nfs_createdata *data;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs_procedures[NFSPROC_CREATE],\n\t};\n\tumode_t mode;\n\tint status = -ENOMEM;\n\n\tdprintk(\"NFS call  mknod %pd\\n\", dentry);\n\n\tmode = sattr->ia_mode;\n\tif (S_ISFIFO(mode)) {\n\t\tsattr->ia_mode = (mode & ~S_IFMT) | S_IFCHR;\n\t\tsattr->ia_valid &= ~ATTR_SIZE;\n\t} else if (S_ISCHR(mode) || S_ISBLK(mode)) {\n\t\tsattr->ia_valid |= ATTR_SIZE;\n\t\tsattr->ia_size = new_encode_dev(rdev); \n\t}\n\n\tdata = nfs_alloc_createdata(dir, dentry, sattr);\n\tif (data == NULL)\n\t\tgoto out;\n\tmsg.rpc_argp = &data->arg;\n\tmsg.rpc_resp = &data->res;\n\n\tstatus = rpc_call_sync(NFS_CLIENT(dir), &msg, 0);\n\tnfs_mark_for_revalidate(dir);\n\n\tif (status == -EINVAL && S_ISFIFO(mode)) {\n\t\tsattr->ia_mode = mode;\n\t\tnfs_fattr_init(data->res.fattr);\n\t\tstatus = rpc_call_sync(NFS_CLIENT(dir), &msg, 0);\n\t}\n\tif (status == 0)\n\t\tstatus = nfs_instantiate(dentry, data->res.fh, data->res.fattr);\n\tnfs_free_createdata(data);\nout:\n\tdprintk(\"NFS reply mknod: %d\\n\", status);\n\treturn status;\n}\n  \nstatic int\nnfs_proc_remove(struct inode *dir, struct dentry *dentry)\n{\n\tstruct nfs_removeargs arg = {\n\t\t.fh = NFS_FH(dir),\n\t\t.name = dentry->d_name,\n\t};\n\tstruct rpc_message msg = { \n\t\t.rpc_proc = &nfs_procedures[NFSPROC_REMOVE],\n\t\t.rpc_argp = &arg,\n\t};\n\tint\t\t\tstatus;\n\n\tdprintk(\"NFS call  remove %pd2\\n\",dentry);\n\tstatus = rpc_call_sync(NFS_CLIENT(dir), &msg, 0);\n\tnfs_mark_for_revalidate(dir);\n\n\tdprintk(\"NFS reply remove: %d\\n\", status);\n\treturn status;\n}\n\nstatic void\nnfs_proc_unlink_setup(struct rpc_message *msg,\n\t\tstruct dentry *dentry,\n\t\tstruct inode *inode)\n{\n\tmsg->rpc_proc = &nfs_procedures[NFSPROC_REMOVE];\n}\n\nstatic void nfs_proc_unlink_rpc_prepare(struct rpc_task *task, struct nfs_unlinkdata *data)\n{\n\trpc_call_start(task);\n}\n\nstatic int nfs_proc_unlink_done(struct rpc_task *task, struct inode *dir)\n{\n\tnfs_mark_for_revalidate(dir);\n\treturn 1;\n}\n\nstatic void\nnfs_proc_rename_setup(struct rpc_message *msg,\n\t\tstruct dentry *old_dentry,\n\t\tstruct dentry *new_dentry)\n{\n\tmsg->rpc_proc = &nfs_procedures[NFSPROC_RENAME];\n}\n\nstatic void nfs_proc_rename_rpc_prepare(struct rpc_task *task, struct nfs_renamedata *data)\n{\n\trpc_call_start(task);\n}\n\nstatic int\nnfs_proc_rename_done(struct rpc_task *task, struct inode *old_dir,\n\t\t     struct inode *new_dir)\n{\n\tnfs_mark_for_revalidate(old_dir);\n\tnfs_mark_for_revalidate(new_dir);\n\treturn 1;\n}\n\nstatic int\nnfs_proc_link(struct inode *inode, struct inode *dir, const struct qstr *name)\n{\n\tstruct nfs_linkargs\targ = {\n\t\t.fromfh\t\t= NFS_FH(inode),\n\t\t.tofh\t\t= NFS_FH(dir),\n\t\t.toname\t\t= name->name,\n\t\t.tolen\t\t= name->len\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs_procedures[NFSPROC_LINK],\n\t\t.rpc_argp\t= &arg,\n\t};\n\tint\t\t\tstatus;\n\n\tdprintk(\"NFS call  link %s\\n\", name->name);\n\tstatus = rpc_call_sync(NFS_CLIENT(inode), &msg, 0);\n\tnfs_mark_for_revalidate(inode);\n\tnfs_mark_for_revalidate(dir);\n\tdprintk(\"NFS reply link: %d\\n\", status);\n\treturn status;\n}\n\nstatic int\nnfs_proc_symlink(struct inode *dir, struct dentry *dentry, struct page *page,\n\t\t unsigned int len, struct iattr *sattr)\n{\n\tstruct nfs_fh *fh;\n\tstruct nfs_fattr *fattr;\n\tstruct nfs_symlinkargs\targ = {\n\t\t.fromfh\t\t= NFS_FH(dir),\n\t\t.fromname\t= dentry->d_name.name,\n\t\t.fromlen\t= dentry->d_name.len,\n\t\t.pages\t\t= &page,\n\t\t.pathlen\t= len,\n\t\t.sattr\t\t= sattr\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs_procedures[NFSPROC_SYMLINK],\n\t\t.rpc_argp\t= &arg,\n\t};\n\tint status = -ENAMETOOLONG;\n\n\tdprintk(\"NFS call  symlink %pd\\n\", dentry);\n\n\tif (len > NFS2_MAXPATHLEN)\n\t\tgoto out;\n\n\tfh = nfs_alloc_fhandle();\n\tfattr = nfs_alloc_fattr();\n\tstatus = -ENOMEM;\n\tif (fh == NULL || fattr == NULL)\n\t\tgoto out_free;\n\n\tstatus = rpc_call_sync(NFS_CLIENT(dir), &msg, 0);\n\tnfs_mark_for_revalidate(dir);\n\n\t \n\tif (status == 0)\n\t\tstatus = nfs_instantiate(dentry, fh, fattr);\n\nout_free:\n\tnfs_free_fattr(fattr);\n\tnfs_free_fhandle(fh);\nout:\n\tdprintk(\"NFS reply symlink: %d\\n\", status);\n\treturn status;\n}\n\nstatic int\nnfs_proc_mkdir(struct inode *dir, struct dentry *dentry, struct iattr *sattr)\n{\n\tstruct nfs_createdata *data;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs_procedures[NFSPROC_MKDIR],\n\t};\n\tint status = -ENOMEM;\n\n\tdprintk(\"NFS call  mkdir %pd\\n\", dentry);\n\tdata = nfs_alloc_createdata(dir, dentry, sattr);\n\tif (data == NULL)\n\t\tgoto out;\n\tmsg.rpc_argp = &data->arg;\n\tmsg.rpc_resp = &data->res;\n\n\tstatus = rpc_call_sync(NFS_CLIENT(dir), &msg, 0);\n\tnfs_mark_for_revalidate(dir);\n\tif (status == 0)\n\t\tstatus = nfs_instantiate(dentry, data->res.fh, data->res.fattr);\n\tnfs_free_createdata(data);\nout:\n\tdprintk(\"NFS reply mkdir: %d\\n\", status);\n\treturn status;\n}\n\nstatic int\nnfs_proc_rmdir(struct inode *dir, const struct qstr *name)\n{\n\tstruct nfs_diropargs\targ = {\n\t\t.fh\t\t= NFS_FH(dir),\n\t\t.name\t\t= name->name,\n\t\t.len\t\t= name->len\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs_procedures[NFSPROC_RMDIR],\n\t\t.rpc_argp\t= &arg,\n\t};\n\tint\t\t\tstatus;\n\n\tdprintk(\"NFS call  rmdir %s\\n\", name->name);\n\tstatus = rpc_call_sync(NFS_CLIENT(dir), &msg, 0);\n\tnfs_mark_for_revalidate(dir);\n\tdprintk(\"NFS reply rmdir: %d\\n\", status);\n\treturn status;\n}\n\n \nstatic int nfs_proc_readdir(struct nfs_readdir_arg *nr_arg,\n\t\t\t    struct nfs_readdir_res *nr_res)\n{\n\tstruct inode\t\t*dir = d_inode(nr_arg->dentry);\n\tstruct nfs_readdirargs\targ = {\n\t\t.fh\t\t= NFS_FH(dir),\n\t\t.cookie\t\t= nr_arg->cookie,\n\t\t.count\t\t= nr_arg->page_len,\n\t\t.pages\t\t= nr_arg->pages,\n\t};\n\tstruct rpc_message\tmsg = {\n\t\t.rpc_proc\t= &nfs_procedures[NFSPROC_READDIR],\n\t\t.rpc_argp\t= &arg,\n\t\t.rpc_cred\t= nr_arg->cred,\n\t};\n\tint\t\t\tstatus;\n\n\tdprintk(\"NFS call  readdir %llu\\n\", (unsigned long long)nr_arg->cookie);\n\tstatus = rpc_call_sync(NFS_CLIENT(dir), &msg, 0);\n\tnr_res->verf[0] = nr_res->verf[1] = 0;\n\n\tnfs_invalidate_atime(dir);\n\n\tdprintk(\"NFS reply readdir: %d\\n\", status);\n\treturn status;\n}\n\nstatic int\nnfs_proc_statfs(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\t\tstruct nfs_fsstat *stat)\n{\n\tstruct nfs2_fsstat fsinfo;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs_procedures[NFSPROC_STATFS],\n\t\t.rpc_argp\t= fhandle,\n\t\t.rpc_resp\t= &fsinfo,\n\t};\n\tint\tstatus;\n\n\tdprintk(\"NFS call  statfs\\n\");\n\tnfs_fattr_init(stat->fattr);\n\tstatus = rpc_call_sync(server->client, &msg, 0);\n\tdprintk(\"NFS reply statfs: %d\\n\", status);\n\tif (status)\n\t\tgoto out;\n\tstat->tbytes = (u64)fsinfo.blocks * fsinfo.bsize;\n\tstat->fbytes = (u64)fsinfo.bfree  * fsinfo.bsize;\n\tstat->abytes = (u64)fsinfo.bavail * fsinfo.bsize;\n\tstat->tfiles = 0;\n\tstat->ffiles = 0;\n\tstat->afiles = 0;\nout:\n\treturn status;\n}\n\nstatic int\nnfs_proc_fsinfo(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\t\tstruct nfs_fsinfo *info)\n{\n\tstruct nfs2_fsstat fsinfo;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs_procedures[NFSPROC_STATFS],\n\t\t.rpc_argp\t= fhandle,\n\t\t.rpc_resp\t= &fsinfo,\n\t};\n\tint\tstatus;\n\n\tdprintk(\"NFS call  fsinfo\\n\");\n\tnfs_fattr_init(info->fattr);\n\tstatus = rpc_call_sync(server->client, &msg, 0);\n\tdprintk(\"NFS reply fsinfo: %d\\n\", status);\n\tif (status)\n\t\tgoto out;\n\tinfo->rtmax  = NFS_MAXDATA;\n\tinfo->rtpref = fsinfo.tsize;\n\tinfo->rtmult = fsinfo.bsize;\n\tinfo->wtmax  = NFS_MAXDATA;\n\tinfo->wtpref = fsinfo.tsize;\n\tinfo->wtmult = fsinfo.bsize;\n\tinfo->dtpref = fsinfo.tsize;\n\tinfo->maxfilesize = 0x7FFFFFFF;\n\tinfo->lease_time = 0;\nout:\n\treturn status;\n}\n\nstatic int\nnfs_proc_pathconf(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\t  struct nfs_pathconf *info)\n{\n\tinfo->max_link = 0;\n\tinfo->max_namelen = NFS2_MAXNAMLEN;\n\treturn 0;\n}\n\nstatic int nfs_read_done(struct rpc_task *task, struct nfs_pgio_header *hdr)\n{\n\tstruct inode *inode = hdr->inode;\n\n\tnfs_invalidate_atime(inode);\n\tif (task->tk_status >= 0) {\n\t\tnfs_refresh_inode(inode, hdr->res.fattr);\n\t\t \n\t\tif ((hdr->res.count == 0 && hdr->args.count > 0) ||\n\t\t    hdr->args.offset + hdr->res.count >= hdr->res.fattr->size)\n\t\t\thdr->res.eof = 1;\n\t}\n\treturn 0;\n}\n\nstatic void nfs_proc_read_setup(struct nfs_pgio_header *hdr,\n\t\t\t\tstruct rpc_message *msg)\n{\n\tmsg->rpc_proc = &nfs_procedures[NFSPROC_READ];\n}\n\nstatic int nfs_proc_pgio_rpc_prepare(struct rpc_task *task,\n\t\t\t\t     struct nfs_pgio_header *hdr)\n{\n\trpc_call_start(task);\n\treturn 0;\n}\n\nstatic int nfs_write_done(struct rpc_task *task, struct nfs_pgio_header *hdr)\n{\n\tif (task->tk_status >= 0) {\n\t\thdr->res.count = hdr->args.count;\n\t\tnfs_writeback_update_inode(hdr);\n\t}\n\treturn 0;\n}\n\nstatic void nfs_proc_write_setup(struct nfs_pgio_header *hdr,\n\t\t\t\t struct rpc_message *msg,\n\t\t\t\t struct rpc_clnt **clnt)\n{\n\t \n\thdr->args.stable = NFS_FILE_SYNC;\n\tmsg->rpc_proc = &nfs_procedures[NFSPROC_WRITE];\n}\n\nstatic void nfs_proc_commit_rpc_prepare(struct rpc_task *task, struct nfs_commit_data *data)\n{\n\tBUG();\n}\n\nstatic void\nnfs_proc_commit_setup(struct nfs_commit_data *data, struct rpc_message *msg,\n\t\t\tstruct rpc_clnt **clnt)\n{\n\tBUG();\n}\n\nstatic int\nnfs_proc_lock(struct file *filp, int cmd, struct file_lock *fl)\n{\n\tstruct inode *inode = file_inode(filp);\n\n\treturn nlmclnt_proc(NFS_SERVER(inode)->nlm_host, cmd, fl, NULL);\n}\n\n \n#define NFS_LOCK32_OFFSET_MAX ((__s32)0x7fffffffUL)\nstatic int nfs_lock_check_bounds(const struct file_lock *fl)\n{\n\t__s32 start, end;\n\n\tstart = (__s32)fl->fl_start;\n\tif ((loff_t)start != fl->fl_start)\n\t\tgoto out_einval;\n\n\tif (fl->fl_end != OFFSET_MAX) {\n\t\tend = (__s32)fl->fl_end;\n\t\tif ((loff_t)end != fl->fl_end)\n\t\t\tgoto out_einval;\n\t} else\n\t\tend = NFS_LOCK32_OFFSET_MAX;\n\n\tif (start < 0 || start > end)\n\t\tgoto out_einval;\n\treturn 0;\nout_einval:\n\treturn -EINVAL;\n}\n\nstatic int nfs_have_delegation(struct inode *inode, fmode_t flags)\n{\n\treturn 0;\n}\n\nstatic const struct inode_operations nfs_dir_inode_operations = {\n\t.create\t\t= nfs_create,\n\t.lookup\t\t= nfs_lookup,\n\t.link\t\t= nfs_link,\n\t.unlink\t\t= nfs_unlink,\n\t.symlink\t= nfs_symlink,\n\t.mkdir\t\t= nfs_mkdir,\n\t.rmdir\t\t= nfs_rmdir,\n\t.mknod\t\t= nfs_mknod,\n\t.rename\t\t= nfs_rename,\n\t.permission\t= nfs_permission,\n\t.getattr\t= nfs_getattr,\n\t.setattr\t= nfs_setattr,\n};\n\nstatic const struct inode_operations nfs_file_inode_operations = {\n\t.permission\t= nfs_permission,\n\t.getattr\t= nfs_getattr,\n\t.setattr\t= nfs_setattr,\n};\n\nconst struct nfs_rpc_ops nfs_v2_clientops = {\n\t.version\t= 2,\t\t        \n\t.dentry_ops\t= &nfs_dentry_operations,\n\t.dir_inode_ops\t= &nfs_dir_inode_operations,\n\t.file_inode_ops\t= &nfs_file_inode_operations,\n\t.file_ops\t= &nfs_file_operations,\n\t.getroot\t= nfs_proc_get_root,\n\t.submount\t= nfs_submount,\n\t.try_get_tree\t= nfs_try_get_tree,\n\t.getattr\t= nfs_proc_getattr,\n\t.setattr\t= nfs_proc_setattr,\n\t.lookup\t\t= nfs_proc_lookup,\n\t.access\t\t= NULL,\t\t        \n\t.readlink\t= nfs_proc_readlink,\n\t.create\t\t= nfs_proc_create,\n\t.remove\t\t= nfs_proc_remove,\n\t.unlink_setup\t= nfs_proc_unlink_setup,\n\t.unlink_rpc_prepare = nfs_proc_unlink_rpc_prepare,\n\t.unlink_done\t= nfs_proc_unlink_done,\n\t.rename_setup\t= nfs_proc_rename_setup,\n\t.rename_rpc_prepare = nfs_proc_rename_rpc_prepare,\n\t.rename_done\t= nfs_proc_rename_done,\n\t.link\t\t= nfs_proc_link,\n\t.symlink\t= nfs_proc_symlink,\n\t.mkdir\t\t= nfs_proc_mkdir,\n\t.rmdir\t\t= nfs_proc_rmdir,\n\t.readdir\t= nfs_proc_readdir,\n\t.mknod\t\t= nfs_proc_mknod,\n\t.statfs\t\t= nfs_proc_statfs,\n\t.fsinfo\t\t= nfs_proc_fsinfo,\n\t.pathconf\t= nfs_proc_pathconf,\n\t.decode_dirent\t= nfs2_decode_dirent,\n\t.pgio_rpc_prepare = nfs_proc_pgio_rpc_prepare,\n\t.read_setup\t= nfs_proc_read_setup,\n\t.read_done\t= nfs_read_done,\n\t.write_setup\t= nfs_proc_write_setup,\n\t.write_done\t= nfs_write_done,\n\t.commit_setup\t= nfs_proc_commit_setup,\n\t.commit_rpc_prepare = nfs_proc_commit_rpc_prepare,\n\t.lock\t\t= nfs_proc_lock,\n\t.lock_check_bounds = nfs_lock_check_bounds,\n\t.close_context\t= nfs_close_context,\n\t.have_delegation = nfs_have_delegation,\n\t.alloc_client\t= nfs_alloc_client,\n\t.init_client\t= nfs_init_client,\n\t.free_client\t= nfs_free_client,\n\t.create_server\t= nfs_create_server,\n\t.clone_server\t= nfs_clone_server,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}