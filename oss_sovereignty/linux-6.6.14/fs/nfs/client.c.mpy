{
  "module_name": "client.c",
  "hash_id": "9564bb9231fb93eda3f56967f37b7cd59debd915901b7e05c74aeac9c41d6212",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfs/client.c",
  "human_readable_source": "\n \n\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/unistd.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/xprtsock.h>\n#include <linux/sunrpc/xprtrdma.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs4_mount.h>\n#include <linux/lockd/bind.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/inet.h>\n#include <linux/in6.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <net/ipv6.h>\n#include <linux/nfs_xdr.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n\n\n#include \"nfs4_fs.h\"\n#include \"callback.h\"\n#include \"delegation.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"fscache.h\"\n#include \"pnfs.h\"\n#include \"nfs.h\"\n#include \"netns.h\"\n#include \"sysfs.h\"\n#include \"nfs42.h\"\n\n#define NFSDBG_FACILITY\t\tNFSDBG_CLIENT\n\nstatic DECLARE_WAIT_QUEUE_HEAD(nfs_client_active_wq);\nstatic DEFINE_SPINLOCK(nfs_version_lock);\nstatic DEFINE_MUTEX(nfs_version_mutex);\nstatic LIST_HEAD(nfs_versions);\n\n \nstatic const struct rpc_version *nfs_version[5] = {\n\t[2] = NULL,\n\t[3] = NULL,\n\t[4] = NULL,\n};\n\nconst struct rpc_program nfs_program = {\n\t.name\t\t\t= \"nfs\",\n\t.number\t\t\t= NFS_PROGRAM,\n\t.nrvers\t\t\t= ARRAY_SIZE(nfs_version),\n\t.version\t\t= nfs_version,\n\t.stats\t\t\t= &nfs_rpcstat,\n\t.pipe_dir_name\t\t= NFS_PIPE_DIRNAME,\n};\n\nstruct rpc_stat nfs_rpcstat = {\n\t.program\t\t= &nfs_program\n};\n\nstatic struct nfs_subversion *find_nfs_version(unsigned int version)\n{\n\tstruct nfs_subversion *nfs;\n\tspin_lock(&nfs_version_lock);\n\n\tlist_for_each_entry(nfs, &nfs_versions, list) {\n\t\tif (nfs->rpc_ops->version == version) {\n\t\t\tspin_unlock(&nfs_version_lock);\n\t\t\treturn nfs;\n\t\t}\n\t}\n\n\tspin_unlock(&nfs_version_lock);\n\treturn ERR_PTR(-EPROTONOSUPPORT);\n}\n\nstruct nfs_subversion *get_nfs_version(unsigned int version)\n{\n\tstruct nfs_subversion *nfs = find_nfs_version(version);\n\n\tif (IS_ERR(nfs)) {\n\t\tmutex_lock(&nfs_version_mutex);\n\t\trequest_module(\"nfsv%d\", version);\n\t\tnfs = find_nfs_version(version);\n\t\tmutex_unlock(&nfs_version_mutex);\n\t}\n\n\tif (!IS_ERR(nfs) && !try_module_get(nfs->owner))\n\t\treturn ERR_PTR(-EAGAIN);\n\treturn nfs;\n}\n\nvoid put_nfs_version(struct nfs_subversion *nfs)\n{\n\tmodule_put(nfs->owner);\n}\n\nvoid register_nfs_version(struct nfs_subversion *nfs)\n{\n\tspin_lock(&nfs_version_lock);\n\n\tlist_add(&nfs->list, &nfs_versions);\n\tnfs_version[nfs->rpc_ops->version] = nfs->rpc_vers;\n\n\tspin_unlock(&nfs_version_lock);\n}\nEXPORT_SYMBOL_GPL(register_nfs_version);\n\nvoid unregister_nfs_version(struct nfs_subversion *nfs)\n{\n\tspin_lock(&nfs_version_lock);\n\n\tnfs_version[nfs->rpc_ops->version] = NULL;\n\tlist_del(&nfs->list);\n\n\tspin_unlock(&nfs_version_lock);\n}\nEXPORT_SYMBOL_GPL(unregister_nfs_version);\n\n \nstruct nfs_client *nfs_alloc_client(const struct nfs_client_initdata *cl_init)\n{\n\tstruct nfs_client *clp;\n\tint err = -ENOMEM;\n\n\tif ((clp = kzalloc(sizeof(*clp), GFP_KERNEL)) == NULL)\n\t\tgoto error_0;\n\n\tclp->cl_minorversion = cl_init->minorversion;\n\tclp->cl_nfs_mod = cl_init->nfs_mod;\n\tif (!try_module_get(clp->cl_nfs_mod->owner))\n\t\tgoto error_dealloc;\n\n\tclp->rpc_ops = clp->cl_nfs_mod->rpc_ops;\n\n\trefcount_set(&clp->cl_count, 1);\n\tclp->cl_cons_state = NFS_CS_INITING;\n\n\tmemcpy(&clp->cl_addr, cl_init->addr, cl_init->addrlen);\n\tclp->cl_addrlen = cl_init->addrlen;\n\n\tif (cl_init->hostname) {\n\t\terr = -ENOMEM;\n\t\tclp->cl_hostname = kstrdup(cl_init->hostname, GFP_KERNEL);\n\t\tif (!clp->cl_hostname)\n\t\t\tgoto error_cleanup;\n\t}\n\n\tINIT_LIST_HEAD(&clp->cl_superblocks);\n\tclp->cl_rpcclient = ERR_PTR(-EINVAL);\n\n\tclp->cl_flags = cl_init->init_flags;\n\tclp->cl_proto = cl_init->proto;\n\tclp->cl_nconnect = cl_init->nconnect;\n\tclp->cl_max_connect = cl_init->max_connect ? cl_init->max_connect : 1;\n\tclp->cl_net = get_net(cl_init->net);\n\n\tclp->cl_principal = \"*\";\n\tclp->cl_xprtsec = cl_init->xprtsec;\n\treturn clp;\n\nerror_cleanup:\n\tput_nfs_version(clp->cl_nfs_mod);\nerror_dealloc:\n\tkfree(clp);\nerror_0:\n\treturn ERR_PTR(err);\n}\nEXPORT_SYMBOL_GPL(nfs_alloc_client);\n\n#if IS_ENABLED(CONFIG_NFS_V4)\nstatic void nfs_cleanup_cb_ident_idr(struct net *net)\n{\n\tstruct nfs_net *nn = net_generic(net, nfs_net_id);\n\n\tidr_destroy(&nn->cb_ident_idr);\n}\n\n \nstatic void nfs_cb_idr_remove_locked(struct nfs_client *clp)\n{\n\tstruct nfs_net *nn = net_generic(clp->cl_net, nfs_net_id);\n\n\tif (clp->cl_cb_ident)\n\t\tidr_remove(&nn->cb_ident_idr, clp->cl_cb_ident);\n}\n\nstatic void pnfs_init_server(struct nfs_server *server)\n{\n\trpc_init_wait_queue(&server->roc_rpcwaitq, \"pNFS ROC\");\n}\n\n#else\nstatic void nfs_cleanup_cb_ident_idr(struct net *net)\n{\n}\n\nstatic void nfs_cb_idr_remove_locked(struct nfs_client *clp)\n{\n}\n\nstatic void pnfs_init_server(struct nfs_server *server)\n{\n}\n\n#endif  \n\n \nvoid nfs_free_client(struct nfs_client *clp)\n{\n\t \n\tif (!IS_ERR(clp->cl_rpcclient))\n\t\trpc_shutdown_client(clp->cl_rpcclient);\n\n\tput_net(clp->cl_net);\n\tput_nfs_version(clp->cl_nfs_mod);\n\tkfree(clp->cl_hostname);\n\tkfree(clp->cl_acceptor);\n\tkfree(clp);\n}\nEXPORT_SYMBOL_GPL(nfs_free_client);\n\n \nvoid nfs_put_client(struct nfs_client *clp)\n{\n\tstruct nfs_net *nn;\n\n\tif (!clp)\n\t\treturn;\n\n\tnn = net_generic(clp->cl_net, nfs_net_id);\n\n\tif (refcount_dec_and_lock(&clp->cl_count, &nn->nfs_client_lock)) {\n\t\tlist_del(&clp->cl_share_link);\n\t\tnfs_cb_idr_remove_locked(clp);\n\t\tspin_unlock(&nn->nfs_client_lock);\n\n\t\tWARN_ON_ONCE(!list_empty(&clp->cl_superblocks));\n\n\t\tclp->rpc_ops->free_client(clp);\n\t}\n}\nEXPORT_SYMBOL_GPL(nfs_put_client);\n\n \nstatic struct nfs_client *nfs_match_client(const struct nfs_client_initdata *data)\n{\n\tstruct nfs_client *clp;\n\tconst struct sockaddr *sap = (struct sockaddr *)data->addr;\n\tstruct nfs_net *nn = net_generic(data->net, nfs_net_id);\n\tint error;\n\nagain:\n\tlist_for_each_entry(clp, &nn->nfs_client_list, cl_share_link) {\n\t        const struct sockaddr *clap = (struct sockaddr *)&clp->cl_addr;\n\t\t \n\t\tif (clp->cl_cons_state < 0)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (clp->cl_cons_state > NFS_CS_READY) {\n\t\t\trefcount_inc(&clp->cl_count);\n\t\t\tspin_unlock(&nn->nfs_client_lock);\n\t\t\terror = nfs_wait_client_init_complete(clp);\n\t\t\tnfs_put_client(clp);\n\t\t\tspin_lock(&nn->nfs_client_lock);\n\t\t\tif (error < 0)\n\t\t\t\treturn ERR_PTR(error);\n\t\t\tgoto again;\n\t\t}\n\n\t\t \n\t\tif (clp->rpc_ops != data->nfs_mod->rpc_ops)\n\t\t\tcontinue;\n\n\t\tif (clp->cl_proto != data->proto)\n\t\t\tcontinue;\n\t\t \n\t\tif (clp->cl_minorversion != data->minorversion)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (test_bit(NFS_CS_DS, &data->init_flags) !=\n\t\t    test_bit(NFS_CS_DS, &clp->cl_flags))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!rpc_cmp_addr_port(sap, clap))\n\t\t\t \n\t\t\tif (IS_ERR(clp->cl_rpcclient) ||\n                            !rpc_clnt_xprt_switch_has_addr(clp->cl_rpcclient,\n\t\t\t\t\t\t\t   sap))\n\t\t\t\tcontinue;\n\n\t\t \n\t\tif (clp->cl_xprtsec.policy != data->xprtsec.policy)\n\t\t\tcontinue;\n\n\t\trefcount_inc(&clp->cl_count);\n\t\treturn clp;\n\t}\n\treturn NULL;\n}\n\n \nbool nfs_client_init_is_complete(const struct nfs_client *clp)\n{\n\treturn clp->cl_cons_state <= NFS_CS_READY;\n}\nEXPORT_SYMBOL_GPL(nfs_client_init_is_complete);\n\n \nint nfs_client_init_status(const struct nfs_client *clp)\n{\n\t \n\tif (clp->cl_cons_state > NFS_CS_READY) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn -EINVAL;\n\t}\n\treturn clp->cl_cons_state;\n}\nEXPORT_SYMBOL_GPL(nfs_client_init_status);\n\nint nfs_wait_client_init_complete(const struct nfs_client *clp)\n{\n\treturn wait_event_killable(nfs_client_active_wq,\n\t\t\tnfs_client_init_is_complete(clp));\n}\nEXPORT_SYMBOL_GPL(nfs_wait_client_init_complete);\n\n \nstatic struct nfs_client *\nnfs_found_client(const struct nfs_client_initdata *cl_init,\n\t\t struct nfs_client *clp)\n{\n\tint error;\n\n\terror = nfs_wait_client_init_complete(clp);\n\tif (error < 0) {\n\t\tnfs_put_client(clp);\n\t\treturn ERR_PTR(-ERESTARTSYS);\n\t}\n\n\tif (clp->cl_cons_state < NFS_CS_READY) {\n\t\terror = clp->cl_cons_state;\n\t\tnfs_put_client(clp);\n\t\treturn ERR_PTR(error);\n\t}\n\n\tsmp_rmb();\n\treturn clp;\n}\n\n \nstruct nfs_client *nfs_get_client(const struct nfs_client_initdata *cl_init)\n{\n\tstruct nfs_client *clp, *new = NULL;\n\tstruct nfs_net *nn = net_generic(cl_init->net, nfs_net_id);\n\tconst struct nfs_rpc_ops *rpc_ops = cl_init->nfs_mod->rpc_ops;\n\n\tif (cl_init->hostname == NULL) {\n\t\tWARN_ON(1);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t \n\tdo {\n\t\tspin_lock(&nn->nfs_client_lock);\n\n\t\tclp = nfs_match_client(cl_init);\n\t\tif (clp) {\n\t\t\tspin_unlock(&nn->nfs_client_lock);\n\t\t\tif (new)\n\t\t\t\tnew->rpc_ops->free_client(new);\n\t\t\tif (IS_ERR(clp))\n\t\t\t\treturn clp;\n\t\t\treturn nfs_found_client(cl_init, clp);\n\t\t}\n\t\tif (new) {\n\t\t\tlist_add_tail(&new->cl_share_link,\n\t\t\t\t\t&nn->nfs_client_list);\n\t\t\tspin_unlock(&nn->nfs_client_lock);\n\t\t\treturn rpc_ops->init_client(new, cl_init);\n\t\t}\n\n\t\tspin_unlock(&nn->nfs_client_lock);\n\n\t\tnew = rpc_ops->alloc_client(cl_init);\n\t} while (!IS_ERR(new));\n\n\treturn new;\n}\nEXPORT_SYMBOL_GPL(nfs_get_client);\n\n \nvoid nfs_mark_client_ready(struct nfs_client *clp, int state)\n{\n\tsmp_wmb();\n\tclp->cl_cons_state = state;\n\twake_up_all(&nfs_client_active_wq);\n}\nEXPORT_SYMBOL_GPL(nfs_mark_client_ready);\n\n \nvoid nfs_init_timeout_values(struct rpc_timeout *to, int proto,\n\t\t\t\t    int timeo, int retrans)\n{\n\tto->to_initval = timeo * HZ / 10;\n\tto->to_retries = retrans;\n\n\tswitch (proto) {\n\tcase XPRT_TRANSPORT_TCP:\n\tcase XPRT_TRANSPORT_TCP_TLS:\n\tcase XPRT_TRANSPORT_RDMA:\n\t\tif (retrans == NFS_UNSPEC_RETRANS)\n\t\t\tto->to_retries = NFS_DEF_TCP_RETRANS;\n\t\tif (timeo == NFS_UNSPEC_TIMEO || to->to_initval == 0)\n\t\t\tto->to_initval = NFS_DEF_TCP_TIMEO * HZ / 10;\n\t\tif (to->to_initval > NFS_MAX_TCP_TIMEOUT)\n\t\t\tto->to_initval = NFS_MAX_TCP_TIMEOUT;\n\t\tto->to_increment = to->to_initval;\n\t\tto->to_maxval = to->to_initval + (to->to_increment * to->to_retries);\n\t\tif (to->to_maxval > NFS_MAX_TCP_TIMEOUT)\n\t\t\tto->to_maxval = NFS_MAX_TCP_TIMEOUT;\n\t\tif (to->to_maxval < to->to_initval)\n\t\t\tto->to_maxval = to->to_initval;\n\t\tto->to_exponential = 0;\n\t\tbreak;\n\tcase XPRT_TRANSPORT_UDP:\n\t\tif (retrans == NFS_UNSPEC_RETRANS)\n\t\t\tto->to_retries = NFS_DEF_UDP_RETRANS;\n\t\tif (timeo == NFS_UNSPEC_TIMEO || to->to_initval == 0)\n\t\t\tto->to_initval = NFS_DEF_UDP_TIMEO * HZ / 10;\n\t\tif (to->to_initval > NFS_MAX_UDP_TIMEOUT)\n\t\t\tto->to_initval = NFS_MAX_UDP_TIMEOUT;\n\t\tto->to_maxval = NFS_MAX_UDP_TIMEOUT;\n\t\tto->to_exponential = 1;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}\nEXPORT_SYMBOL_GPL(nfs_init_timeout_values);\n\n \nint nfs_create_rpc_client(struct nfs_client *clp,\n\t\t\t  const struct nfs_client_initdata *cl_init,\n\t\t\t  rpc_authflavor_t flavor)\n{\n\tstruct rpc_clnt\t\t*clnt = NULL;\n\tstruct rpc_create_args args = {\n\t\t.net\t\t= clp->cl_net,\n\t\t.protocol\t= clp->cl_proto,\n\t\t.nconnect\t= clp->cl_nconnect,\n\t\t.address\t= (struct sockaddr *)&clp->cl_addr,\n\t\t.addrsize\t= clp->cl_addrlen,\n\t\t.timeout\t= cl_init->timeparms,\n\t\t.servername\t= clp->cl_hostname,\n\t\t.nodename\t= cl_init->nodename,\n\t\t.program\t= &nfs_program,\n\t\t.version\t= clp->rpc_ops->version,\n\t\t.authflavor\t= flavor,\n\t\t.cred\t\t= cl_init->cred,\n\t\t.xprtsec\t= cl_init->xprtsec,\n\t\t.connect_timeout = cl_init->connect_timeout,\n\t\t.reconnect_timeout = cl_init->reconnect_timeout,\n\t};\n\n\tif (test_bit(NFS_CS_DISCRTRY, &clp->cl_flags))\n\t\targs.flags |= RPC_CLNT_CREATE_DISCRTRY;\n\tif (test_bit(NFS_CS_NO_RETRANS_TIMEOUT, &clp->cl_flags))\n\t\targs.flags |= RPC_CLNT_CREATE_NO_RETRANS_TIMEOUT;\n\tif (test_bit(NFS_CS_NORESVPORT, &clp->cl_flags))\n\t\targs.flags |= RPC_CLNT_CREATE_NONPRIVPORT;\n\tif (test_bit(NFS_CS_INFINITE_SLOTS, &clp->cl_flags))\n\t\targs.flags |= RPC_CLNT_CREATE_INFINITE_SLOTS;\n\tif (test_bit(NFS_CS_NOPING, &clp->cl_flags))\n\t\targs.flags |= RPC_CLNT_CREATE_NOPING;\n\tif (test_bit(NFS_CS_REUSEPORT, &clp->cl_flags))\n\t\targs.flags |= RPC_CLNT_CREATE_REUSEPORT;\n\n\tif (!IS_ERR(clp->cl_rpcclient))\n\t\treturn 0;\n\n\tclnt = rpc_create(&args);\n\tif (IS_ERR(clnt)) {\n\t\tdprintk(\"%s: cannot create RPC client. Error = %ld\\n\",\n\t\t\t\t__func__, PTR_ERR(clnt));\n\t\treturn PTR_ERR(clnt);\n\t}\n\n\tclnt->cl_principal = clp->cl_principal;\n\tclp->cl_rpcclient = clnt;\n\tclnt->cl_max_connect = clp->cl_max_connect;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nfs_create_rpc_client);\n\n \nstatic void nfs_destroy_server(struct nfs_server *server)\n{\n\tif (server->nlm_host)\n\t\tnlmclnt_done(server->nlm_host);\n}\n\n \nstatic int nfs_start_lockd(struct nfs_server *server)\n{\n\tstruct nlm_host *host;\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct nlmclnt_initdata nlm_init = {\n\t\t.hostname\t= clp->cl_hostname,\n\t\t.address\t= (struct sockaddr *)&clp->cl_addr,\n\t\t.addrlen\t= clp->cl_addrlen,\n\t\t.nfs_version\t= clp->rpc_ops->version,\n\t\t.noresvport\t= server->flags & NFS_MOUNT_NORESVPORT ?\n\t\t\t\t\t1 : 0,\n\t\t.net\t\t= clp->cl_net,\n\t\t.nlmclnt_ops \t= clp->cl_nfs_mod->rpc_ops->nlmclnt_ops,\n\t\t.cred\t\t= server->cred,\n\t};\n\n\tif (nlm_init.nfs_version > 3)\n\t\treturn 0;\n\tif ((server->flags & NFS_MOUNT_LOCAL_FLOCK) &&\n\t\t\t(server->flags & NFS_MOUNT_LOCAL_FCNTL))\n\t\treturn 0;\n\n\tswitch (clp->cl_proto) {\n\t\tdefault:\n\t\t\tnlm_init.protocol = IPPROTO_TCP;\n\t\t\tbreak;\n#ifndef CONFIG_NFS_DISABLE_UDP_SUPPORT\n\t\tcase XPRT_TRANSPORT_UDP:\n\t\t\tnlm_init.protocol = IPPROTO_UDP;\n#endif\n\t}\n\n\thost = nlmclnt_init(&nlm_init);\n\tif (IS_ERR(host))\n\t\treturn PTR_ERR(host);\n\n\tserver->nlm_host = host;\n\tserver->destroy = nfs_destroy_server;\n\tnfs_sysfs_link_rpc_client(server, nlmclnt_rpc_clnt(host), NULL);\n\treturn 0;\n}\n\n \nint nfs_init_server_rpcclient(struct nfs_server *server,\n\t\tconst struct rpc_timeout *timeo,\n\t\trpc_authflavor_t pseudoflavour)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\n\tserver->client = rpc_clone_client_set_auth(clp->cl_rpcclient,\n\t\t\t\t\t\t\tpseudoflavour);\n\tif (IS_ERR(server->client)) {\n\t\tdprintk(\"%s: couldn't create rpc_client!\\n\", __func__);\n\t\treturn PTR_ERR(server->client);\n\t}\n\n\tmemcpy(&server->client->cl_timeout_default,\n\t\t\ttimeo,\n\t\t\tsizeof(server->client->cl_timeout_default));\n\tserver->client->cl_timeout = &server->client->cl_timeout_default;\n\tserver->client->cl_softrtry = 0;\n\tif (server->flags & NFS_MOUNT_SOFTERR)\n\t\tserver->client->cl_softerr = 1;\n\tif (server->flags & NFS_MOUNT_SOFT)\n\t\tserver->client->cl_softrtry = 1;\n\n\tnfs_sysfs_link_rpc_client(server, server->client, NULL);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nfs_init_server_rpcclient);\n\n \nstruct nfs_client *nfs_init_client(struct nfs_client *clp,\n\t\t\t\t   const struct nfs_client_initdata *cl_init)\n{\n\tint error;\n\n\t \n\tif (clp->cl_cons_state == NFS_CS_READY)\n\t\treturn clp;\n\n\t \n\terror = nfs_create_rpc_client(clp, cl_init, RPC_AUTH_UNIX);\n\tnfs_mark_client_ready(clp, error == 0 ? NFS_CS_READY : error);\n\tif (error < 0) {\n\t\tnfs_put_client(clp);\n\t\tclp = ERR_PTR(error);\n\t}\n\treturn clp;\n}\nEXPORT_SYMBOL_GPL(nfs_init_client);\n\n \nstatic int nfs_init_server(struct nfs_server *server,\n\t\t\t   const struct fs_context *fc)\n{\n\tconst struct nfs_fs_context *ctx = nfs_fc2context(fc);\n\tstruct rpc_timeout timeparms;\n\tstruct nfs_client_initdata cl_init = {\n\t\t.hostname = ctx->nfs_server.hostname,\n\t\t.addr = &ctx->nfs_server._address,\n\t\t.addrlen = ctx->nfs_server.addrlen,\n\t\t.nfs_mod = ctx->nfs_mod,\n\t\t.proto = ctx->nfs_server.protocol,\n\t\t.net = fc->net_ns,\n\t\t.timeparms = &timeparms,\n\t\t.cred = server->cred,\n\t\t.nconnect = ctx->nfs_server.nconnect,\n\t\t.init_flags = (1UL << NFS_CS_REUSEPORT),\n\t\t.xprtsec = ctx->xprtsec,\n\t};\n\tstruct nfs_client *clp;\n\tint error;\n\n\tnfs_init_timeout_values(&timeparms, ctx->nfs_server.protocol,\n\t\t\t\tctx->timeo, ctx->retrans);\n\tif (ctx->flags & NFS_MOUNT_NORESVPORT)\n\t\tset_bit(NFS_CS_NORESVPORT, &cl_init.init_flags);\n\n\t \n\tclp = nfs_get_client(&cl_init);\n\tif (IS_ERR(clp))\n\t\treturn PTR_ERR(clp);\n\n\tserver->nfs_client = clp;\n\tnfs_sysfs_add_server(server);\n\tnfs_sysfs_link_rpc_client(server, clp->cl_rpcclient, \"_state\");\n\n\t \n\tserver->flags = ctx->flags;\n\tserver->options = ctx->options;\n\tserver->caps |= NFS_CAP_HARDLINKS | NFS_CAP_SYMLINKS;\n\n\tswitch (clp->rpc_ops->version) {\n\tcase 2:\n\t\tserver->fattr_valid = NFS_ATTR_FATTR_V2;\n\t\tbreak;\n\tcase 3:\n\t\tserver->fattr_valid = NFS_ATTR_FATTR_V3;\n\t\tbreak;\n\tdefault:\n\t\tserver->fattr_valid = NFS_ATTR_FATTR_V4;\n\t}\n\n\tif (ctx->rsize)\n\t\tserver->rsize = nfs_io_size(ctx->rsize, clp->cl_proto);\n\tif (ctx->wsize)\n\t\tserver->wsize = nfs_io_size(ctx->wsize, clp->cl_proto);\n\n\tserver->acregmin = ctx->acregmin * HZ;\n\tserver->acregmax = ctx->acregmax * HZ;\n\tserver->acdirmin = ctx->acdirmin * HZ;\n\tserver->acdirmax = ctx->acdirmax * HZ;\n\n\t \n\terror = nfs_start_lockd(server);\n\tif (error < 0)\n\t\tgoto error;\n\n\tserver->port = ctx->nfs_server.port;\n\tserver->auth_info = ctx->auth_info;\n\n\terror = nfs_init_server_rpcclient(server, &timeparms,\n\t\t\t\t\t  ctx->selected_flavor);\n\tif (error < 0)\n\t\tgoto error;\n\n\t \n\tif (ctx->mount_server.addrlen) {\n\t\tmemcpy(&server->mountd_address, &ctx->mount_server.address,\n\t\t\tctx->mount_server.addrlen);\n\t\tserver->mountd_addrlen = ctx->mount_server.addrlen;\n\t}\n\tserver->mountd_version = ctx->mount_server.version;\n\tserver->mountd_port = ctx->mount_server.port;\n\tserver->mountd_protocol = ctx->mount_server.protocol;\n\n\tserver->namelen  = ctx->namlen;\n\treturn 0;\n\nerror:\n\tserver->nfs_client = NULL;\n\tnfs_put_client(clp);\n\treturn error;\n}\n\n \nstatic void nfs_server_set_fsinfo(struct nfs_server *server,\n\t\t\t\t  struct nfs_fsinfo *fsinfo)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tunsigned long max_rpc_payload, raw_max_rpc_payload;\n\n\t \n\tif (server->rsize == 0)\n\t\tserver->rsize = nfs_io_size(fsinfo->rtpref, clp->cl_proto);\n\tif (server->wsize == 0)\n\t\tserver->wsize = nfs_io_size(fsinfo->wtpref, clp->cl_proto);\n\n\tif (fsinfo->rtmax >= 512 && server->rsize > fsinfo->rtmax)\n\t\tserver->rsize = nfs_io_size(fsinfo->rtmax, clp->cl_proto);\n\tif (fsinfo->wtmax >= 512 && server->wsize > fsinfo->wtmax)\n\t\tserver->wsize = nfs_io_size(fsinfo->wtmax, clp->cl_proto);\n\n\traw_max_rpc_payload = rpc_max_payload(server->client);\n\tmax_rpc_payload = nfs_block_size(raw_max_rpc_payload, NULL);\n\n\tif (server->rsize > max_rpc_payload)\n\t\tserver->rsize = max_rpc_payload;\n\tif (server->rsize > NFS_MAX_FILE_IO_SIZE)\n\t\tserver->rsize = NFS_MAX_FILE_IO_SIZE;\n\tserver->rpages = (server->rsize + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\n\tif (server->wsize > max_rpc_payload)\n\t\tserver->wsize = max_rpc_payload;\n\tif (server->wsize > NFS_MAX_FILE_IO_SIZE)\n\t\tserver->wsize = NFS_MAX_FILE_IO_SIZE;\n\tserver->wpages = (server->wsize + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\n\tserver->wtmult = nfs_block_bits(fsinfo->wtmult, NULL);\n\n\tserver->dtsize = nfs_block_size(fsinfo->dtpref, NULL);\n\tif (server->dtsize > NFS_MAX_FILE_IO_SIZE)\n\t\tserver->dtsize = NFS_MAX_FILE_IO_SIZE;\n\tif (server->dtsize > server->rsize)\n\t\tserver->dtsize = server->rsize;\n\n\tif (server->flags & NFS_MOUNT_NOAC) {\n\t\tserver->acregmin = server->acregmax = 0;\n\t\tserver->acdirmin = server->acdirmax = 0;\n\t}\n\n\tserver->maxfilesize = fsinfo->maxfilesize;\n\n\tserver->time_delta = fsinfo->time_delta;\n\tserver->change_attr_type = fsinfo->change_attr_type;\n\n\tserver->clone_blksize = fsinfo->clone_blksize;\n\t \n\trpc_setbufsize(server->client, server->wsize + 100, server->rsize + 100);\n\n#ifdef CONFIG_NFS_V4_2\n\t \n\tserver->gxasize = min_t(unsigned int, raw_max_rpc_payload,\n\t\t\t\tXATTR_SIZE_MAX);\n\tserver->sxasize = min_t(unsigned int, raw_max_rpc_payload,\n\t\t\t\tXATTR_SIZE_MAX);\n\tserver->lxasize = min_t(unsigned int, raw_max_rpc_payload,\n\t\t\t\tnfs42_listxattr_xdrsize(XATTR_LIST_MAX));\n\n\tif (fsinfo->xattr_support)\n\t\tserver->caps |= NFS_CAP_XATTR;\n#endif\n}\n\n \nstatic int nfs_probe_fsinfo(struct nfs_server *server, struct nfs_fh *mntfh, struct nfs_fattr *fattr)\n{\n\tstruct nfs_fsinfo fsinfo;\n\tstruct nfs_client *clp = server->nfs_client;\n\tint error;\n\n\tif (clp->rpc_ops->set_capabilities != NULL) {\n\t\terror = clp->rpc_ops->set_capabilities(server, mntfh);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t}\n\n\tfsinfo.fattr = fattr;\n\tfsinfo.nlayouttypes = 0;\n\tmemset(fsinfo.layouttype, 0, sizeof(fsinfo.layouttype));\n\terror = clp->rpc_ops->fsinfo(server, mntfh, &fsinfo);\n\tif (error < 0)\n\t\treturn error;\n\n\tnfs_server_set_fsinfo(server, &fsinfo);\n\n\t \n\tif (server->namelen == 0) {\n\t\tstruct nfs_pathconf pathinfo;\n\n\t\tpathinfo.fattr = fattr;\n\t\tnfs_fattr_init(fattr);\n\n\t\tif (clp->rpc_ops->pathconf(server, mntfh, &pathinfo) >= 0)\n\t\t\tserver->namelen = pathinfo.max_namelen;\n\t}\n\n\tif (clp->rpc_ops->discover_trunking != NULL &&\n\t\t\t(server->caps & NFS_CAP_FS_LOCATIONS &&\n\t\t\t (server->flags & NFS_MOUNT_TRUNK_DISCOVERY))) {\n\t\terror = clp->rpc_ops->discover_trunking(server, mntfh);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\n \nint nfs_probe_server(struct nfs_server *server, struct nfs_fh *mntfh)\n{\n\tstruct nfs_fattr *fattr;\n\tint error;\n\n\tfattr = nfs_alloc_fattr();\n\tif (fattr == NULL)\n\t\treturn -ENOMEM;\n\n\t \n\terror = nfs_probe_fsinfo(server, mntfh, fattr);\n\n\tnfs_free_fattr(fattr);\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(nfs_probe_server);\n\n \nvoid nfs_server_copy_userdata(struct nfs_server *target, struct nfs_server *source)\n{\n\ttarget->flags = source->flags;\n\ttarget->rsize = source->rsize;\n\ttarget->wsize = source->wsize;\n\ttarget->acregmin = source->acregmin;\n\ttarget->acregmax = source->acregmax;\n\ttarget->acdirmin = source->acdirmin;\n\ttarget->acdirmax = source->acdirmax;\n\ttarget->caps = source->caps;\n\ttarget->options = source->options;\n\ttarget->auth_info = source->auth_info;\n\ttarget->port = source->port;\n}\nEXPORT_SYMBOL_GPL(nfs_server_copy_userdata);\n\nvoid nfs_server_insert_lists(struct nfs_server *server)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct nfs_net *nn = net_generic(clp->cl_net, nfs_net_id);\n\n\tspin_lock(&nn->nfs_client_lock);\n\tlist_add_tail_rcu(&server->client_link, &clp->cl_superblocks);\n\tlist_add_tail(&server->master_link, &nn->nfs_volume_list);\n\tclear_bit(NFS_CS_STOP_RENEW, &clp->cl_res_state);\n\tspin_unlock(&nn->nfs_client_lock);\n\n}\nEXPORT_SYMBOL_GPL(nfs_server_insert_lists);\n\nvoid nfs_server_remove_lists(struct nfs_server *server)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct nfs_net *nn;\n\n\tif (clp == NULL)\n\t\treturn;\n\tnn = net_generic(clp->cl_net, nfs_net_id);\n\tspin_lock(&nn->nfs_client_lock);\n\tlist_del_rcu(&server->client_link);\n\tif (list_empty(&clp->cl_superblocks))\n\t\tset_bit(NFS_CS_STOP_RENEW, &clp->cl_res_state);\n\tlist_del(&server->master_link);\n\tspin_unlock(&nn->nfs_client_lock);\n\n\tsynchronize_rcu();\n}\nEXPORT_SYMBOL_GPL(nfs_server_remove_lists);\n\nstatic DEFINE_IDA(s_sysfs_ids);\n\n \nstruct nfs_server *nfs_alloc_server(void)\n{\n\tstruct nfs_server *server;\n\n\tserver = kzalloc(sizeof(struct nfs_server), GFP_KERNEL);\n\tif (!server)\n\t\treturn NULL;\n\n\tserver->s_sysfs_id = ida_alloc(&s_sysfs_ids, GFP_KERNEL);\n\tif (server->s_sysfs_id < 0) {\n\t\tkfree(server);\n\t\treturn NULL;\n\t}\n\n\tserver->client = server->client_acl = ERR_PTR(-EINVAL);\n\n\t \n\tINIT_LIST_HEAD(&server->client_link);\n\tINIT_LIST_HEAD(&server->master_link);\n\tINIT_LIST_HEAD(&server->delegations);\n\tINIT_LIST_HEAD(&server->layouts);\n\tINIT_LIST_HEAD(&server->state_owners_lru);\n\tINIT_LIST_HEAD(&server->ss_copies);\n\n\tatomic_set(&server->active, 0);\n\n\tserver->io_stats = nfs_alloc_iostats();\n\tif (!server->io_stats) {\n\t\tkfree(server);\n\t\treturn NULL;\n\t}\n\n\tserver->change_attr_type = NFS4_CHANGE_TYPE_IS_UNDEFINED;\n\n\tida_init(&server->openowner_id);\n\tida_init(&server->lockowner_id);\n\tpnfs_init_server(server);\n\trpc_init_wait_queue(&server->uoc_rpcwaitq, \"NFS UOC\");\n\n\treturn server;\n}\nEXPORT_SYMBOL_GPL(nfs_alloc_server);\n\n \nvoid nfs_free_server(struct nfs_server *server)\n{\n\tnfs_server_remove_lists(server);\n\n\tif (server->destroy != NULL)\n\t\tserver->destroy(server);\n\n\tif (!IS_ERR(server->client_acl))\n\t\trpc_shutdown_client(server->client_acl);\n\tif (!IS_ERR(server->client))\n\t\trpc_shutdown_client(server->client);\n\n\tnfs_put_client(server->nfs_client);\n\n\tif (server->kobj.state_initialized) {\n\t\tnfs_sysfs_remove_server(server);\n\t\tkobject_put(&server->kobj);\n\t}\n\tida_free(&s_sysfs_ids, server->s_sysfs_id);\n\n\tida_destroy(&server->lockowner_id);\n\tida_destroy(&server->openowner_id);\n\tnfs_free_iostats(server->io_stats);\n\tput_cred(server->cred);\n\tkfree(server);\n\tnfs_release_automount_timer();\n}\nEXPORT_SYMBOL_GPL(nfs_free_server);\n\n \nstruct nfs_server *nfs_create_server(struct fs_context *fc)\n{\n\tstruct nfs_fs_context *ctx = nfs_fc2context(fc);\n\tstruct nfs_server *server;\n\tstruct nfs_fattr *fattr;\n\tint error;\n\n\tserver = nfs_alloc_server();\n\tif (!server)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tserver->cred = get_cred(fc->cred);\n\n\terror = -ENOMEM;\n\tfattr = nfs_alloc_fattr();\n\tif (fattr == NULL)\n\t\tgoto error;\n\n\t \n\terror = nfs_init_server(server, fc);\n\tif (error < 0)\n\t\tgoto error;\n\n\t \n\terror = nfs_probe_fsinfo(server, ctx->mntfh, fattr);\n\tif (error < 0)\n\t\tgoto error;\n\tif (server->nfs_client->rpc_ops->version == 3) {\n\t\tif (server->namelen == 0 || server->namelen > NFS3_MAXNAMLEN)\n\t\t\tserver->namelen = NFS3_MAXNAMLEN;\n\t\tif (!(ctx->flags & NFS_MOUNT_NORDIRPLUS))\n\t\t\tserver->caps |= NFS_CAP_READDIRPLUS;\n\t} else {\n\t\tif (server->namelen == 0 || server->namelen > NFS2_MAXNAMLEN)\n\t\t\tserver->namelen = NFS2_MAXNAMLEN;\n\t}\n\n\tif (!(fattr->valid & NFS_ATTR_FATTR)) {\n\t\terror = ctx->nfs_mod->rpc_ops->getattr(server, ctx->mntfh,\n\t\t\t\t\t\t       fattr, NULL);\n\t\tif (error < 0) {\n\t\t\tdprintk(\"nfs_create_server: getattr error = %d\\n\", -error);\n\t\t\tgoto error;\n\t\t}\n\t}\n\tmemcpy(&server->fsid, &fattr->fsid, sizeof(server->fsid));\n\n\tdprintk(\"Server FSID: %llx:%llx\\n\",\n\t\t(unsigned long long) server->fsid.major,\n\t\t(unsigned long long) server->fsid.minor);\n\n\tnfs_server_insert_lists(server);\n\tserver->mount_time = jiffies;\n\tnfs_free_fattr(fattr);\n\treturn server;\n\nerror:\n\tnfs_free_fattr(fattr);\n\tnfs_free_server(server);\n\treturn ERR_PTR(error);\n}\nEXPORT_SYMBOL_GPL(nfs_create_server);\n\n \nstruct nfs_server *nfs_clone_server(struct nfs_server *source,\n\t\t\t\t    struct nfs_fh *fh,\n\t\t\t\t    struct nfs_fattr *fattr,\n\t\t\t\t    rpc_authflavor_t flavor)\n{\n\tstruct nfs_server *server;\n\tint error;\n\n\tserver = nfs_alloc_server();\n\tif (!server)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tserver->cred = get_cred(source->cred);\n\n\t \n\tserver->nfs_client = source->nfs_client;\n\tserver->destroy = source->destroy;\n\trefcount_inc(&server->nfs_client->cl_count);\n\tnfs_server_copy_userdata(server, source);\n\n\tserver->fsid = fattr->fsid;\n\n\tnfs_sysfs_add_server(server);\n\n\tnfs_sysfs_link_rpc_client(server,\n\t\tserver->nfs_client->cl_rpcclient, \"_state\");\n\n\terror = nfs_init_server_rpcclient(server,\n\t\t\tsource->client->cl_timeout,\n\t\t\tflavor);\n\tif (error < 0)\n\t\tgoto out_free_server;\n\n\t \n\terror = nfs_probe_server(server, fh);\n\tif (error < 0)\n\t\tgoto out_free_server;\n\n\tif (server->namelen == 0 || server->namelen > NFS4_MAXNAMLEN)\n\t\tserver->namelen = NFS4_MAXNAMLEN;\n\n\terror = nfs_start_lockd(server);\n\tif (error < 0)\n\t\tgoto out_free_server;\n\n\tnfs_server_insert_lists(server);\n\tserver->mount_time = jiffies;\n\n\treturn server;\n\nout_free_server:\n\tnfs_free_server(server);\n\treturn ERR_PTR(error);\n}\nEXPORT_SYMBOL_GPL(nfs_clone_server);\n\nvoid nfs_clients_init(struct net *net)\n{\n\tstruct nfs_net *nn = net_generic(net, nfs_net_id);\n\n\tINIT_LIST_HEAD(&nn->nfs_client_list);\n\tINIT_LIST_HEAD(&nn->nfs_volume_list);\n#if IS_ENABLED(CONFIG_NFS_V4)\n\tidr_init(&nn->cb_ident_idr);\n#endif\n\tspin_lock_init(&nn->nfs_client_lock);\n\tnn->boot_time = ktime_get_real();\n\n\tnfs_netns_sysfs_setup(nn, net);\n}\n\nvoid nfs_clients_exit(struct net *net)\n{\n\tstruct nfs_net *nn = net_generic(net, nfs_net_id);\n\n\tnfs_netns_sysfs_destroy(nn);\n\tnfs_cleanup_cb_ident_idr(net);\n\tWARN_ON_ONCE(!list_empty(&nn->nfs_client_list));\n\tWARN_ON_ONCE(!list_empty(&nn->nfs_volume_list));\n}\n\n#ifdef CONFIG_PROC_FS\nstatic void *nfs_server_list_start(struct seq_file *p, loff_t *pos);\nstatic void *nfs_server_list_next(struct seq_file *p, void *v, loff_t *pos);\nstatic void nfs_server_list_stop(struct seq_file *p, void *v);\nstatic int nfs_server_list_show(struct seq_file *m, void *v);\n\nstatic const struct seq_operations nfs_server_list_ops = {\n\t.start\t= nfs_server_list_start,\n\t.next\t= nfs_server_list_next,\n\t.stop\t= nfs_server_list_stop,\n\t.show\t= nfs_server_list_show,\n};\n\nstatic void *nfs_volume_list_start(struct seq_file *p, loff_t *pos);\nstatic void *nfs_volume_list_next(struct seq_file *p, void *v, loff_t *pos);\nstatic void nfs_volume_list_stop(struct seq_file *p, void *v);\nstatic int nfs_volume_list_show(struct seq_file *m, void *v);\n\nstatic const struct seq_operations nfs_volume_list_ops = {\n\t.start\t= nfs_volume_list_start,\n\t.next\t= nfs_volume_list_next,\n\t.stop\t= nfs_volume_list_stop,\n\t.show\t= nfs_volume_list_show,\n};\n\n \nstatic void *nfs_server_list_start(struct seq_file *m, loff_t *_pos)\n\t\t\t\t__acquires(&nn->nfs_client_lock)\n{\n\tstruct nfs_net *nn = net_generic(seq_file_net(m), nfs_net_id);\n\n\t \n\tspin_lock(&nn->nfs_client_lock);\n\treturn seq_list_start_head(&nn->nfs_client_list, *_pos);\n}\n\n \nstatic void *nfs_server_list_next(struct seq_file *p, void *v, loff_t *pos)\n{\n\tstruct nfs_net *nn = net_generic(seq_file_net(p), nfs_net_id);\n\n\treturn seq_list_next(v, &nn->nfs_client_list, pos);\n}\n\n \nstatic void nfs_server_list_stop(struct seq_file *p, void *v)\n\t\t\t\t__releases(&nn->nfs_client_lock)\n{\n\tstruct nfs_net *nn = net_generic(seq_file_net(p), nfs_net_id);\n\n\tspin_unlock(&nn->nfs_client_lock);\n}\n\n \nstatic int nfs_server_list_show(struct seq_file *m, void *v)\n{\n\tstruct nfs_client *clp;\n\tstruct nfs_net *nn = net_generic(seq_file_net(m), nfs_net_id);\n\n\t \n\tif (v == &nn->nfs_client_list) {\n\t\tseq_puts(m, \"NV SERVER   PORT USE HOSTNAME\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tclp = list_entry(v, struct nfs_client, cl_share_link);\n\n\t \n\tif (clp->cl_cons_state != NFS_CS_READY)\n\t\treturn 0;\n\n\trcu_read_lock();\n\tseq_printf(m, \"v%u %s %s %3d %s\\n\",\n\t\t   clp->rpc_ops->version,\n\t\t   rpc_peeraddr2str(clp->cl_rpcclient, RPC_DISPLAY_HEX_ADDR),\n\t\t   rpc_peeraddr2str(clp->cl_rpcclient, RPC_DISPLAY_HEX_PORT),\n\t\t   refcount_read(&clp->cl_count),\n\t\t   clp->cl_hostname);\n\trcu_read_unlock();\n\n\treturn 0;\n}\n\n \nstatic void *nfs_volume_list_start(struct seq_file *m, loff_t *_pos)\n\t\t\t\t__acquires(&nn->nfs_client_lock)\n{\n\tstruct nfs_net *nn = net_generic(seq_file_net(m), nfs_net_id);\n\n\t \n\tspin_lock(&nn->nfs_client_lock);\n\treturn seq_list_start_head(&nn->nfs_volume_list, *_pos);\n}\n\n \nstatic void *nfs_volume_list_next(struct seq_file *p, void *v, loff_t *pos)\n{\n\tstruct nfs_net *nn = net_generic(seq_file_net(p), nfs_net_id);\n\n\treturn seq_list_next(v, &nn->nfs_volume_list, pos);\n}\n\n \nstatic void nfs_volume_list_stop(struct seq_file *p, void *v)\n\t\t\t\t__releases(&nn->nfs_client_lock)\n{\n\tstruct nfs_net *nn = net_generic(seq_file_net(p), nfs_net_id);\n\n\tspin_unlock(&nn->nfs_client_lock);\n}\n\n \nstatic int nfs_volume_list_show(struct seq_file *m, void *v)\n{\n\tstruct nfs_server *server;\n\tstruct nfs_client *clp;\n\tchar dev[13];\t \n\tchar fsid[34];\t \n\tstruct nfs_net *nn = net_generic(seq_file_net(m), nfs_net_id);\n\n\t \n\tif (v == &nn->nfs_volume_list) {\n\t\tseq_puts(m, \"NV SERVER   PORT DEV          FSID\"\n\t\t\t    \"                              FSC\\n\");\n\t\treturn 0;\n\t}\n\t \n\tserver = list_entry(v, struct nfs_server, master_link);\n\tclp = server->nfs_client;\n\n\tsnprintf(dev, sizeof(dev), \"%u:%u\",\n\t\t MAJOR(server->s_dev), MINOR(server->s_dev));\n\n\tsnprintf(fsid, sizeof(fsid), \"%llx:%llx\",\n\t\t (unsigned long long) server->fsid.major,\n\t\t (unsigned long long) server->fsid.minor);\n\n\trcu_read_lock();\n\tseq_printf(m, \"v%u %s %s %-12s %-33s %s\\n\",\n\t\t   clp->rpc_ops->version,\n\t\t   rpc_peeraddr2str(clp->cl_rpcclient, RPC_DISPLAY_HEX_ADDR),\n\t\t   rpc_peeraddr2str(clp->cl_rpcclient, RPC_DISPLAY_HEX_PORT),\n\t\t   dev,\n\t\t   fsid,\n\t\t   nfs_server_fscache_state(server));\n\trcu_read_unlock();\n\n\treturn 0;\n}\n\nint nfs_fs_proc_net_init(struct net *net)\n{\n\tstruct nfs_net *nn = net_generic(net, nfs_net_id);\n\tstruct proc_dir_entry *p;\n\n\tnn->proc_nfsfs = proc_net_mkdir(net, \"nfsfs\", net->proc_net);\n\tif (!nn->proc_nfsfs)\n\t\tgoto error_0;\n\n\t \n\tp = proc_create_net(\"servers\", S_IFREG|S_IRUGO, nn->proc_nfsfs,\n\t\t\t&nfs_server_list_ops, sizeof(struct seq_net_private));\n\tif (!p)\n\t\tgoto error_1;\n\n\t \n\tp = proc_create_net(\"volumes\", S_IFREG|S_IRUGO, nn->proc_nfsfs,\n\t\t\t&nfs_volume_list_ops, sizeof(struct seq_net_private));\n\tif (!p)\n\t\tgoto error_1;\n\treturn 0;\n\nerror_1:\n\tremove_proc_subtree(\"nfsfs\", net->proc_net);\nerror_0:\n\treturn -ENOMEM;\n}\n\nvoid nfs_fs_proc_net_exit(struct net *net)\n{\n\tremove_proc_subtree(\"nfsfs\", net->proc_net);\n}\n\n \nint __init nfs_fs_proc_init(void)\n{\n\tif (!proc_mkdir(\"fs/nfsfs\", NULL))\n\t\tgoto error_0;\n\n\t \n\tif (!proc_symlink(\"fs/nfsfs/servers\", NULL, \"../../net/nfsfs/servers\"))\n\t\tgoto error_1;\n\n\t \n\tif (!proc_symlink(\"fs/nfsfs/volumes\", NULL, \"../../net/nfsfs/volumes\"))\n\t\tgoto error_1;\n\n\treturn 0;\nerror_1:\n\tremove_proc_subtree(\"fs/nfsfs\", NULL);\nerror_0:\n\treturn -ENOMEM;\n}\n\n \nvoid nfs_fs_proc_exit(void)\n{\n\tremove_proc_subtree(\"fs/nfsfs\", NULL);\n\tida_destroy(&s_sysfs_ids);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}