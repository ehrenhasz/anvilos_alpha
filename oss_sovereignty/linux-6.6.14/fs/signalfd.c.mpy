{
  "module_name": "signalfd.c",
  "hash_id": "c7e5ac256e9d1100d57a6e2f1dd2530cce305172f5334ce0ddd93febe9862dbf",
  "original_prompt": "Ingested from linux-6.6.14/fs/signalfd.c",
  "human_readable_source": "\n \n\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/signal.h>\n#include <linux/list.h>\n#include <linux/anon_inodes.h>\n#include <linux/signalfd.h>\n#include <linux/syscalls.h>\n#include <linux/proc_fs.h>\n#include <linux/compat.h>\n\nvoid signalfd_cleanup(struct sighand_struct *sighand)\n{\n\twake_up_pollfree(&sighand->signalfd_wqh);\n}\n\nstruct signalfd_ctx {\n\tsigset_t sigmask;\n};\n\nstatic int signalfd_release(struct inode *inode, struct file *file)\n{\n\tkfree(file->private_data);\n\treturn 0;\n}\n\nstatic __poll_t signalfd_poll(struct file *file, poll_table *wait)\n{\n\tstruct signalfd_ctx *ctx = file->private_data;\n\t__poll_t events = 0;\n\n\tpoll_wait(file, &current->sighand->signalfd_wqh, wait);\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tif (next_signal(&current->pending, &ctx->sigmask) ||\n\t    next_signal(&current->signal->shared_pending,\n\t\t\t&ctx->sigmask))\n\t\tevents |= EPOLLIN;\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\treturn events;\n}\n\n \nstatic int signalfd_copyinfo(struct signalfd_siginfo __user *uinfo,\n\t\t\t     kernel_siginfo_t const *kinfo)\n{\n\tstruct signalfd_siginfo new;\n\n\tBUILD_BUG_ON(sizeof(struct signalfd_siginfo) != 128);\n\n\t \n\tmemset(&new, 0, sizeof(new));\n\n\t \n\tnew.ssi_signo = kinfo->si_signo;\n\tnew.ssi_errno = kinfo->si_errno;\n\tnew.ssi_code  = kinfo->si_code;\n\tswitch (siginfo_layout(kinfo->si_signo, kinfo->si_code)) {\n\tcase SIL_KILL:\n\t\tnew.ssi_pid = kinfo->si_pid;\n\t\tnew.ssi_uid = kinfo->si_uid;\n\t\tbreak;\n\tcase SIL_TIMER:\n\t\tnew.ssi_tid = kinfo->si_tid;\n\t\tnew.ssi_overrun = kinfo->si_overrun;\n\t\tnew.ssi_ptr = (long) kinfo->si_ptr;\n\t\tnew.ssi_int = kinfo->si_int;\n\t\tbreak;\n\tcase SIL_POLL:\n\t\tnew.ssi_band = kinfo->si_band;\n\t\tnew.ssi_fd   = kinfo->si_fd;\n\t\tbreak;\n\tcase SIL_FAULT_BNDERR:\n\tcase SIL_FAULT_PKUERR:\n\tcase SIL_FAULT_PERF_EVENT:\n\t\t \n\tcase SIL_FAULT:\n\t\tnew.ssi_addr = (long) kinfo->si_addr;\n\t\tbreak;\n\tcase SIL_FAULT_TRAPNO:\n\t\tnew.ssi_addr = (long) kinfo->si_addr;\n\t\tnew.ssi_trapno = kinfo->si_trapno;\n\t\tbreak;\n\tcase SIL_FAULT_MCEERR:\n\t\tnew.ssi_addr = (long) kinfo->si_addr;\n\t\tnew.ssi_addr_lsb = (short) kinfo->si_addr_lsb;\n\t\tbreak;\n\tcase SIL_CHLD:\n\t\tnew.ssi_pid    = kinfo->si_pid;\n\t\tnew.ssi_uid    = kinfo->si_uid;\n\t\tnew.ssi_status = kinfo->si_status;\n\t\tnew.ssi_utime  = kinfo->si_utime;\n\t\tnew.ssi_stime  = kinfo->si_stime;\n\t\tbreak;\n\tcase SIL_RT:\n\t\t \n\t\tnew.ssi_pid = kinfo->si_pid;\n\t\tnew.ssi_uid = kinfo->si_uid;\n\t\tnew.ssi_ptr = (long) kinfo->si_ptr;\n\t\tnew.ssi_int = kinfo->si_int;\n\t\tbreak;\n\tcase SIL_SYS:\n\t\tnew.ssi_call_addr = (long) kinfo->si_call_addr;\n\t\tnew.ssi_syscall   = kinfo->si_syscall;\n\t\tnew.ssi_arch      = kinfo->si_arch;\n\t\tbreak;\n\t}\n\n\tif (copy_to_user(uinfo, &new, sizeof(struct signalfd_siginfo)))\n\t\treturn -EFAULT;\n\n\treturn sizeof(*uinfo);\n}\n\nstatic ssize_t signalfd_dequeue(struct signalfd_ctx *ctx, kernel_siginfo_t *info,\n\t\t\t\tint nonblock)\n{\n\tenum pid_type type;\n\tssize_t ret;\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tret = dequeue_signal(current, &ctx->sigmask, info, &type);\n\tswitch (ret) {\n\tcase 0:\n\t\tif (!nonblock)\n\t\t\tbreak;\n\t\tret = -EAGAIN;\n\t\tfallthrough;\n\tdefault:\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\treturn ret;\n\t}\n\n\tadd_wait_queue(&current->sighand->signalfd_wqh, &wait);\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tret = dequeue_signal(current, &ctx->sigmask, info, &type);\n\t\tif (ret != 0)\n\t\t\tbreak;\n\t\tif (signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\tschedule();\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t}\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\tremove_wait_queue(&current->sighand->signalfd_wqh, &wait);\n\t__set_current_state(TASK_RUNNING);\n\n\treturn ret;\n}\n\n \nstatic ssize_t signalfd_read(struct file *file, char __user *buf, size_t count,\n\t\t\t     loff_t *ppos)\n{\n\tstruct signalfd_ctx *ctx = file->private_data;\n\tstruct signalfd_siginfo __user *siginfo;\n\tint nonblock = file->f_flags & O_NONBLOCK;\n\tssize_t ret, total = 0;\n\tkernel_siginfo_t info;\n\n\tcount /= sizeof(struct signalfd_siginfo);\n\tif (!count)\n\t\treturn -EINVAL;\n\n\tsiginfo = (struct signalfd_siginfo __user *) buf;\n\tdo {\n\t\tret = signalfd_dequeue(ctx, &info, nonblock);\n\t\tif (unlikely(ret <= 0))\n\t\t\tbreak;\n\t\tret = signalfd_copyinfo(siginfo, &info);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tsiginfo++;\n\t\ttotal += ret;\n\t\tnonblock = 1;\n\t} while (--count);\n\n\treturn total ? total: ret;\n}\n\n#ifdef CONFIG_PROC_FS\nstatic void signalfd_show_fdinfo(struct seq_file *m, struct file *f)\n{\n\tstruct signalfd_ctx *ctx = f->private_data;\n\tsigset_t sigmask;\n\n\tsigmask = ctx->sigmask;\n\tsignotset(&sigmask);\n\trender_sigset_t(m, \"sigmask:\\t\", &sigmask);\n}\n#endif\n\nstatic const struct file_operations signalfd_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= signalfd_show_fdinfo,\n#endif\n\t.release\t= signalfd_release,\n\t.poll\t\t= signalfd_poll,\n\t.read\t\t= signalfd_read,\n\t.llseek\t\t= noop_llseek,\n};\n\nstatic int do_signalfd4(int ufd, sigset_t *mask, int flags)\n{\n\tstruct signalfd_ctx *ctx;\n\n\t \n\tBUILD_BUG_ON(SFD_CLOEXEC != O_CLOEXEC);\n\tBUILD_BUG_ON(SFD_NONBLOCK != O_NONBLOCK);\n\n\tif (flags & ~(SFD_CLOEXEC | SFD_NONBLOCK))\n\t\treturn -EINVAL;\n\n\tsigdelsetmask(mask, sigmask(SIGKILL) | sigmask(SIGSTOP));\n\tsignotset(mask);\n\n\tif (ufd == -1) {\n\t\tctx = kmalloc(sizeof(*ctx), GFP_KERNEL);\n\t\tif (!ctx)\n\t\t\treturn -ENOMEM;\n\n\t\tctx->sigmask = *mask;\n\n\t\t \n\t\tufd = anon_inode_getfd(\"[signalfd]\", &signalfd_fops, ctx,\n\t\t\t\t       O_RDWR | (flags & (O_CLOEXEC | O_NONBLOCK)));\n\t\tif (ufd < 0)\n\t\t\tkfree(ctx);\n\t} else {\n\t\tstruct fd f = fdget(ufd);\n\t\tif (!f.file)\n\t\t\treturn -EBADF;\n\t\tctx = f.file->private_data;\n\t\tif (f.file->f_op != &signalfd_fops) {\n\t\t\tfdput(f);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t\tctx->sigmask = *mask;\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\n\t\twake_up(&current->sighand->signalfd_wqh);\n\t\tfdput(f);\n\t}\n\n\treturn ufd;\n}\n\nSYSCALL_DEFINE4(signalfd4, int, ufd, sigset_t __user *, user_mask,\n\t\tsize_t, sizemask, int, flags)\n{\n\tsigset_t mask;\n\n\tif (sizemask != sizeof(sigset_t))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&mask, user_mask, sizeof(mask)))\n\t\treturn -EFAULT;\n\treturn do_signalfd4(ufd, &mask, flags);\n}\n\nSYSCALL_DEFINE3(signalfd, int, ufd, sigset_t __user *, user_mask,\n\t\tsize_t, sizemask)\n{\n\tsigset_t mask;\n\n\tif (sizemask != sizeof(sigset_t))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&mask, user_mask, sizeof(mask)))\n\t\treturn -EFAULT;\n\treturn do_signalfd4(ufd, &mask, 0);\n}\n\n#ifdef CONFIG_COMPAT\nstatic long do_compat_signalfd4(int ufd,\n\t\t\tconst compat_sigset_t __user *user_mask,\n\t\t\tcompat_size_t sigsetsize, int flags)\n{\n\tsigset_t mask;\n\n\tif (sigsetsize != sizeof(compat_sigset_t))\n\t\treturn -EINVAL;\n\tif (get_compat_sigset(&mask, user_mask))\n\t\treturn -EFAULT;\n\treturn do_signalfd4(ufd, &mask, flags);\n}\n\nCOMPAT_SYSCALL_DEFINE4(signalfd4, int, ufd,\n\t\t     const compat_sigset_t __user *, user_mask,\n\t\t     compat_size_t, sigsetsize,\n\t\t     int, flags)\n{\n\treturn do_compat_signalfd4(ufd, user_mask, sigsetsize, flags);\n}\n\nCOMPAT_SYSCALL_DEFINE3(signalfd, int, ufd,\n\t\t     const compat_sigset_t __user *, user_mask,\n\t\t     compat_size_t, sigsetsize)\n{\n\treturn do_compat_signalfd4(ufd, user_mask, sigsetsize, 0);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}