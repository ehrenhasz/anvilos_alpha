{
  "module_name": "proc_namespace.c",
  "hash_id": "b8d9103e1825405e5e1d5faee005657b71d7f211645cb752690f71a231b77223",
  "original_prompt": "Ingested from linux-6.6.14/fs/proc_namespace.c",
  "human_readable_source": "\n \n#include <linux/mnt_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/security.h>\n#include <linux/fs_struct.h>\n#include <linux/sched/task.h>\n\n#include \"proc/internal.h\"  \n\n#include \"pnode.h\"\n#include \"internal.h\"\n\nstatic __poll_t mounts_poll(struct file *file, poll_table *wait)\n{\n\tstruct seq_file *m = file->private_data;\n\tstruct proc_mounts *p = m->private;\n\tstruct mnt_namespace *ns = p->ns;\n\t__poll_t res = EPOLLIN | EPOLLRDNORM;\n\tint event;\n\n\tpoll_wait(file, &p->ns->poll, wait);\n\n\tevent = READ_ONCE(ns->event);\n\tif (m->poll_event != event) {\n\t\tm->poll_event = event;\n\t\tres |= EPOLLERR | EPOLLPRI;\n\t}\n\n\treturn res;\n}\n\nstruct proc_fs_opts {\n\tint flag;\n\tconst char *str;\n};\n\nstatic int show_sb_opts(struct seq_file *m, struct super_block *sb)\n{\n\tstatic const struct proc_fs_opts fs_opts[] = {\n\t\t{ SB_SYNCHRONOUS, \",sync\" },\n\t\t{ SB_DIRSYNC, \",dirsync\" },\n\t\t{ SB_MANDLOCK, \",mand\" },\n\t\t{ SB_LAZYTIME, \",lazytime\" },\n\t\t{ 0, NULL }\n\t};\n\tconst struct proc_fs_opts *fs_infop;\n\n\tfor (fs_infop = fs_opts; fs_infop->flag; fs_infop++) {\n\t\tif (sb->s_flags & fs_infop->flag)\n\t\t\tseq_puts(m, fs_infop->str);\n\t}\n\n\treturn security_sb_show_options(m, sb);\n}\n\nstatic void show_mnt_opts(struct seq_file *m, struct vfsmount *mnt)\n{\n\tstatic const struct proc_fs_opts mnt_opts[] = {\n\t\t{ MNT_NOSUID, \",nosuid\" },\n\t\t{ MNT_NODEV, \",nodev\" },\n\t\t{ MNT_NOEXEC, \",noexec\" },\n\t\t{ MNT_NOATIME, \",noatime\" },\n\t\t{ MNT_NODIRATIME, \",nodiratime\" },\n\t\t{ MNT_RELATIME, \",relatime\" },\n\t\t{ MNT_NOSYMFOLLOW, \",nosymfollow\" },\n\t\t{ 0, NULL }\n\t};\n\tconst struct proc_fs_opts *fs_infop;\n\n\tfor (fs_infop = mnt_opts; fs_infop->flag; fs_infop++) {\n\t\tif (mnt->mnt_flags & fs_infop->flag)\n\t\t\tseq_puts(m, fs_infop->str);\n\t}\n\n\tif (is_idmapped_mnt(mnt))\n\t\tseq_puts(m, \",idmapped\");\n}\n\nstatic inline void mangle(struct seq_file *m, const char *s)\n{\n\tseq_escape(m, s, \" \\t\\n\\\\#\");\n}\n\nstatic void show_type(struct seq_file *m, struct super_block *sb)\n{\n\tmangle(m, sb->s_type->name);\n\tif (sb->s_subtype) {\n\t\tseq_putc(m, '.');\n\t\tmangle(m, sb->s_subtype);\n\t}\n}\n\nstatic int show_vfsmnt(struct seq_file *m, struct vfsmount *mnt)\n{\n\tstruct proc_mounts *p = m->private;\n\tstruct mount *r = real_mount(mnt);\n\tstruct path mnt_path = { .dentry = mnt->mnt_root, .mnt = mnt };\n\tstruct super_block *sb = mnt_path.dentry->d_sb;\n\tint err;\n\n\tif (sb->s_op->show_devname) {\n\t\terr = sb->s_op->show_devname(m, mnt_path.dentry);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\tmangle(m, r->mnt_devname ? r->mnt_devname : \"none\");\n\t}\n\tseq_putc(m, ' ');\n\t \n\terr = seq_path_root(m, &mnt_path, &p->root, \" \\t\\n\\\\\");\n\tif (err)\n\t\tgoto out;\n\tseq_putc(m, ' ');\n\tshow_type(m, sb);\n\tseq_puts(m, __mnt_is_readonly(mnt) ? \" ro\" : \" rw\");\n\terr = show_sb_opts(m, sb);\n\tif (err)\n\t\tgoto out;\n\tshow_mnt_opts(m, mnt);\n\tif (sb->s_op->show_options)\n\t\terr = sb->s_op->show_options(m, mnt_path.dentry);\n\tseq_puts(m, \" 0 0\\n\");\nout:\n\treturn err;\n}\n\nstatic int show_mountinfo(struct seq_file *m, struct vfsmount *mnt)\n{\n\tstruct proc_mounts *p = m->private;\n\tstruct mount *r = real_mount(mnt);\n\tstruct super_block *sb = mnt->mnt_sb;\n\tstruct path mnt_path = { .dentry = mnt->mnt_root, .mnt = mnt };\n\tint err;\n\n\tseq_printf(m, \"%i %i %u:%u \", r->mnt_id, r->mnt_parent->mnt_id,\n\t\t   MAJOR(sb->s_dev), MINOR(sb->s_dev));\n\tif (sb->s_op->show_path) {\n\t\terr = sb->s_op->show_path(m, mnt->mnt_root);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\tseq_dentry(m, mnt->mnt_root, \" \\t\\n\\\\\");\n\t}\n\tseq_putc(m, ' ');\n\n\t \n\terr = seq_path_root(m, &mnt_path, &p->root, \" \\t\\n\\\\\");\n\tif (err)\n\t\tgoto out;\n\n\tseq_puts(m, mnt->mnt_flags & MNT_READONLY ? \" ro\" : \" rw\");\n\tshow_mnt_opts(m, mnt);\n\n\t \n\tif (IS_MNT_SHARED(r))\n\t\tseq_printf(m, \" shared:%i\", r->mnt_group_id);\n\tif (IS_MNT_SLAVE(r)) {\n\t\tint master = r->mnt_master->mnt_group_id;\n\t\tint dom = get_dominating_id(r, &p->root);\n\t\tseq_printf(m, \" master:%i\", master);\n\t\tif (dom && dom != master)\n\t\t\tseq_printf(m, \" propagate_from:%i\", dom);\n\t}\n\tif (IS_MNT_UNBINDABLE(r))\n\t\tseq_puts(m, \" unbindable\");\n\n\t \n\tseq_puts(m, \" - \");\n\tshow_type(m, sb);\n\tseq_putc(m, ' ');\n\tif (sb->s_op->show_devname) {\n\t\terr = sb->s_op->show_devname(m, mnt->mnt_root);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\tmangle(m, r->mnt_devname ? r->mnt_devname : \"none\");\n\t}\n\tseq_puts(m, sb_rdonly(sb) ? \" ro\" : \" rw\");\n\terr = show_sb_opts(m, sb);\n\tif (err)\n\t\tgoto out;\n\tif (sb->s_op->show_options)\n\t\terr = sb->s_op->show_options(m, mnt->mnt_root);\n\tseq_putc(m, '\\n');\nout:\n\treturn err;\n}\n\nstatic int show_vfsstat(struct seq_file *m, struct vfsmount *mnt)\n{\n\tstruct proc_mounts *p = m->private;\n\tstruct mount *r = real_mount(mnt);\n\tstruct path mnt_path = { .dentry = mnt->mnt_root, .mnt = mnt };\n\tstruct super_block *sb = mnt_path.dentry->d_sb;\n\tint err;\n\n\t \n\tif (sb->s_op->show_devname) {\n\t\tseq_puts(m, \"device \");\n\t\terr = sb->s_op->show_devname(m, mnt_path.dentry);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\tif (r->mnt_devname) {\n\t\t\tseq_puts(m, \"device \");\n\t\t\tmangle(m, r->mnt_devname);\n\t\t} else\n\t\t\tseq_puts(m, \"no device\");\n\t}\n\n\t \n\tseq_puts(m, \" mounted on \");\n\t \n\terr = seq_path_root(m, &mnt_path, &p->root, \" \\t\\n\\\\\");\n\tif (err)\n\t\tgoto out;\n\tseq_putc(m, ' ');\n\n\t \n\tseq_puts(m, \"with fstype \");\n\tshow_type(m, sb);\n\n\t \n\tif (sb->s_op->show_stats) {\n\t\tseq_putc(m, ' ');\n\t\terr = sb->s_op->show_stats(m, mnt_path.dentry);\n\t}\n\n\tseq_putc(m, '\\n');\nout:\n\treturn err;\n}\n\nstatic int mounts_open_common(struct inode *inode, struct file *file,\n\t\t\t      int (*show)(struct seq_file *, struct vfsmount *))\n{\n\tstruct task_struct *task = get_proc_task(inode);\n\tstruct nsproxy *nsp;\n\tstruct mnt_namespace *ns = NULL;\n\tstruct path root;\n\tstruct proc_mounts *p;\n\tstruct seq_file *m;\n\tint ret = -EINVAL;\n\n\tif (!task)\n\t\tgoto err;\n\n\ttask_lock(task);\n\tnsp = task->nsproxy;\n\tif (!nsp || !nsp->mnt_ns) {\n\t\ttask_unlock(task);\n\t\tput_task_struct(task);\n\t\tgoto err;\n\t}\n\tns = nsp->mnt_ns;\n\tget_mnt_ns(ns);\n\tif (!task->fs) {\n\t\ttask_unlock(task);\n\t\tput_task_struct(task);\n\t\tret = -ENOENT;\n\t\tgoto err_put_ns;\n\t}\n\tget_fs_root(task->fs, &root);\n\ttask_unlock(task);\n\tput_task_struct(task);\n\n\tret = seq_open_private(file, &mounts_op, sizeof(struct proc_mounts));\n\tif (ret)\n\t\tgoto err_put_path;\n\n\tm = file->private_data;\n\tm->poll_event = ns->event;\n\n\tp = m->private;\n\tp->ns = ns;\n\tp->root = root;\n\tp->show = show;\n\tINIT_LIST_HEAD(&p->cursor.mnt_list);\n\tp->cursor.mnt.mnt_flags = MNT_CURSOR;\n\n\treturn 0;\n\n err_put_path:\n\tpath_put(&root);\n err_put_ns:\n\tput_mnt_ns(ns);\n err:\n\treturn ret;\n}\n\nstatic int mounts_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *m = file->private_data;\n\tstruct proc_mounts *p = m->private;\n\tpath_put(&p->root);\n\tmnt_cursor_del(p->ns, &p->cursor);\n\tput_mnt_ns(p->ns);\n\treturn seq_release_private(inode, file);\n}\n\nstatic int mounts_open(struct inode *inode, struct file *file)\n{\n\treturn mounts_open_common(inode, file, show_vfsmnt);\n}\n\nstatic int mountinfo_open(struct inode *inode, struct file *file)\n{\n\treturn mounts_open_common(inode, file, show_mountinfo);\n}\n\nstatic int mountstats_open(struct inode *inode, struct file *file)\n{\n\treturn mounts_open_common(inode, file, show_vfsstat);\n}\n\nconst struct file_operations proc_mounts_operations = {\n\t.open\t\t= mounts_open,\n\t.read_iter\t= seq_read_iter,\n\t.splice_read\t= copy_splice_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= mounts_release,\n\t.poll\t\t= mounts_poll,\n};\n\nconst struct file_operations proc_mountinfo_operations = {\n\t.open\t\t= mountinfo_open,\n\t.read_iter\t= seq_read_iter,\n\t.splice_read\t= copy_splice_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= mounts_release,\n\t.poll\t\t= mounts_poll,\n};\n\nconst struct file_operations proc_mountstats_operations = {\n\t.open\t\t= mountstats_open,\n\t.read_iter\t= seq_read_iter,\n\t.splice_read\t= copy_splice_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= mounts_release,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}