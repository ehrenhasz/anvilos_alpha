{
  "module_name": "dir.c",
  "hash_id": "c1015b5b41ff35ef31cadb991c9b919c7038942b3130582a51f77ad7e15c6191",
  "original_prompt": "Ingested from linux-6.6.14/fs/bfs/dir.c",
  "human_readable_source": "\n \n\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include \"bfs.h\"\n\n#undef DEBUG\n\n#ifdef DEBUG\n#define dprintf(x...)\tprintf(x)\n#else\n#define dprintf(x...)\n#endif\n\nstatic int bfs_add_entry(struct inode *dir, const struct qstr *child, int ino);\nstatic struct buffer_head *bfs_find_entry(struct inode *dir,\n\t\t\t\tconst struct qstr *child,\n\t\t\t\tstruct bfs_dirent **res_dir);\n\nstatic int bfs_readdir(struct file *f, struct dir_context *ctx)\n{\n\tstruct inode *dir = file_inode(f);\n\tstruct buffer_head *bh;\n\tstruct bfs_dirent *de;\n\tunsigned int offset;\n\tint block;\n\n\tif (ctx->pos & (BFS_DIRENT_SIZE - 1)) {\n\t\tprintf(\"Bad f_pos=%08lx for %s:%08lx\\n\",\n\t\t\t\t\t(unsigned long)ctx->pos,\n\t\t\t\t\tdir->i_sb->s_id, dir->i_ino);\n\t\treturn -EINVAL;\n\t}\n\n\twhile (ctx->pos < dir->i_size) {\n\t\toffset = ctx->pos & (BFS_BSIZE - 1);\n\t\tblock = BFS_I(dir)->i_sblock + (ctx->pos >> BFS_BSIZE_BITS);\n\t\tbh = sb_bread(dir->i_sb, block);\n\t\tif (!bh) {\n\t\t\tctx->pos += BFS_BSIZE - offset;\n\t\t\tcontinue;\n\t\t}\n\t\tdo {\n\t\t\tde = (struct bfs_dirent *)(bh->b_data + offset);\n\t\t\tif (de->ino) {\n\t\t\t\tint size = strnlen(de->name, BFS_NAMELEN);\n\t\t\t\tif (!dir_emit(ctx, de->name, size,\n\t\t\t\t\t\tle16_to_cpu(de->ino),\n\t\t\t\t\t\tDT_UNKNOWN)) {\n\t\t\t\t\tbrelse(bh);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\toffset += BFS_DIRENT_SIZE;\n\t\t\tctx->pos += BFS_DIRENT_SIZE;\n\t\t} while ((offset < BFS_BSIZE) && (ctx->pos < dir->i_size));\n\t\tbrelse(bh);\n\t}\n\treturn 0;\n}\n\nconst struct file_operations bfs_dir_operations = {\n\t.read\t\t= generic_read_dir,\n\t.iterate_shared\t= bfs_readdir,\n\t.fsync\t\t= generic_file_fsync,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic int bfs_create(struct mnt_idmap *idmap, struct inode *dir,\n\t\t      struct dentry *dentry, umode_t mode, bool excl)\n{\n\tint err;\n\tstruct inode *inode;\n\tstruct super_block *s = dir->i_sb;\n\tstruct bfs_sb_info *info = BFS_SB(s);\n\tunsigned long ino;\n\n\tinode = new_inode(s);\n\tif (!inode)\n\t\treturn -ENOMEM;\n\tmutex_lock(&info->bfs_lock);\n\tino = find_first_zero_bit(info->si_imap, info->si_lasti + 1);\n\tif (ino > info->si_lasti) {\n\t\tmutex_unlock(&info->bfs_lock);\n\t\tiput(inode);\n\t\treturn -ENOSPC;\n\t}\n\tset_bit(ino, info->si_imap);\n\tinfo->si_freei--;\n\tinode_init_owner(&nop_mnt_idmap, inode, dir, mode);\n\tinode->i_mtime = inode->i_atime = inode_set_ctime_current(inode);\n\tinode->i_blocks = 0;\n\tinode->i_op = &bfs_file_inops;\n\tinode->i_fop = &bfs_file_operations;\n\tinode->i_mapping->a_ops = &bfs_aops;\n\tinode->i_ino = ino;\n\tBFS_I(inode)->i_dsk_ino = ino;\n\tBFS_I(inode)->i_sblock = 0;\n\tBFS_I(inode)->i_eblock = 0;\n\tinsert_inode_hash(inode);\n        mark_inode_dirty(inode);\n\tbfs_dump_imap(\"create\", s);\n\n\terr = bfs_add_entry(dir, &dentry->d_name, inode->i_ino);\n\tif (err) {\n\t\tinode_dec_link_count(inode);\n\t\tmutex_unlock(&info->bfs_lock);\n\t\tiput(inode);\n\t\treturn err;\n\t}\n\tmutex_unlock(&info->bfs_lock);\n\td_instantiate(dentry, inode);\n\treturn 0;\n}\n\nstatic struct dentry *bfs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t\t\tunsigned int flags)\n{\n\tstruct inode *inode = NULL;\n\tstruct buffer_head *bh;\n\tstruct bfs_dirent *de;\n\tstruct bfs_sb_info *info = BFS_SB(dir->i_sb);\n\n\tif (dentry->d_name.len > BFS_NAMELEN)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tmutex_lock(&info->bfs_lock);\n\tbh = bfs_find_entry(dir, &dentry->d_name, &de);\n\tif (bh) {\n\t\tunsigned long ino = (unsigned long)le16_to_cpu(de->ino);\n\t\tbrelse(bh);\n\t\tinode = bfs_iget(dir->i_sb, ino);\n\t}\n\tmutex_unlock(&info->bfs_lock);\n\treturn d_splice_alias(inode, dentry);\n}\n\nstatic int bfs_link(struct dentry *old, struct inode *dir,\n\t\t\t\t\t\tstruct dentry *new)\n{\n\tstruct inode *inode = d_inode(old);\n\tstruct bfs_sb_info *info = BFS_SB(inode->i_sb);\n\tint err;\n\n\tmutex_lock(&info->bfs_lock);\n\terr = bfs_add_entry(dir, &new->d_name, inode->i_ino);\n\tif (err) {\n\t\tmutex_unlock(&info->bfs_lock);\n\t\treturn err;\n\t}\n\tinc_nlink(inode);\n\tinode_set_ctime_current(inode);\n\tmark_inode_dirty(inode);\n\tihold(inode);\n\td_instantiate(new, inode);\n\tmutex_unlock(&info->bfs_lock);\n\treturn 0;\n}\n\nstatic int bfs_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tint error = -ENOENT;\n\tstruct inode *inode = d_inode(dentry);\n\tstruct buffer_head *bh;\n\tstruct bfs_dirent *de;\n\tstruct bfs_sb_info *info = BFS_SB(inode->i_sb);\n\n\tmutex_lock(&info->bfs_lock);\n\tbh = bfs_find_entry(dir, &dentry->d_name, &de);\n\tif (!bh || (le16_to_cpu(de->ino) != inode->i_ino))\n\t\tgoto out_brelse;\n\n\tif (!inode->i_nlink) {\n\t\tprintf(\"unlinking non-existent file %s:%lu (nlink=%d)\\n\",\n\t\t\t\t\tinode->i_sb->s_id, inode->i_ino,\n\t\t\t\t\tinode->i_nlink);\n\t\tset_nlink(inode, 1);\n\t}\n\tde->ino = 0;\n\tmark_buffer_dirty_inode(bh, dir);\n\tdir->i_mtime = inode_set_ctime_current(dir);\n\tmark_inode_dirty(dir);\n\tinode_set_ctime_to_ts(inode, inode_get_ctime(dir));\n\tinode_dec_link_count(inode);\n\terror = 0;\n\nout_brelse:\n\tbrelse(bh);\n\tmutex_unlock(&info->bfs_lock);\n\treturn error;\n}\n\nstatic int bfs_rename(struct mnt_idmap *idmap, struct inode *old_dir,\n\t\t      struct dentry *old_dentry, struct inode *new_dir,\n\t\t      struct dentry *new_dentry, unsigned int flags)\n{\n\tstruct inode *old_inode, *new_inode;\n\tstruct buffer_head *old_bh, *new_bh;\n\tstruct bfs_dirent *old_de, *new_de;\n\tstruct bfs_sb_info *info;\n\tint error = -ENOENT;\n\n\tif (flags & ~RENAME_NOREPLACE)\n\t\treturn -EINVAL;\n\n\told_bh = new_bh = NULL;\n\told_inode = d_inode(old_dentry);\n\tif (S_ISDIR(old_inode->i_mode))\n\t\treturn -EINVAL;\n\n\tinfo = BFS_SB(old_inode->i_sb);\n\n\tmutex_lock(&info->bfs_lock);\n\told_bh = bfs_find_entry(old_dir, &old_dentry->d_name, &old_de);\n\n\tif (!old_bh || (le16_to_cpu(old_de->ino) != old_inode->i_ino))\n\t\tgoto end_rename;\n\n\terror = -EPERM;\n\tnew_inode = d_inode(new_dentry);\n\tnew_bh = bfs_find_entry(new_dir, &new_dentry->d_name, &new_de);\n\n\tif (new_bh && !new_inode) {\n\t\tbrelse(new_bh);\n\t\tnew_bh = NULL;\n\t}\n\tif (!new_bh) {\n\t\terror = bfs_add_entry(new_dir, &new_dentry->d_name,\n\t\t\t\t\told_inode->i_ino);\n\t\tif (error)\n\t\t\tgoto end_rename;\n\t}\n\told_de->ino = 0;\n\told_dir->i_mtime = inode_set_ctime_current(old_dir);\n\tmark_inode_dirty(old_dir);\n\tif (new_inode) {\n\t\tinode_set_ctime_current(new_inode);\n\t\tinode_dec_link_count(new_inode);\n\t}\n\tmark_buffer_dirty_inode(old_bh, old_dir);\n\terror = 0;\n\nend_rename:\n\tmutex_unlock(&info->bfs_lock);\n\tbrelse(old_bh);\n\tbrelse(new_bh);\n\treturn error;\n}\n\nconst struct inode_operations bfs_dir_inops = {\n\t.create\t\t\t= bfs_create,\n\t.lookup\t\t\t= bfs_lookup,\n\t.link\t\t\t= bfs_link,\n\t.unlink\t\t\t= bfs_unlink,\n\t.rename\t\t\t= bfs_rename,\n};\n\nstatic int bfs_add_entry(struct inode *dir, const struct qstr *child, int ino)\n{\n\tconst unsigned char *name = child->name;\n\tint namelen = child->len;\n\tstruct buffer_head *bh;\n\tstruct bfs_dirent *de;\n\tint block, sblock, eblock, off, pos;\n\tint i;\n\n\tdprintf(\"name=%s, namelen=%d\\n\", name, namelen);\n\n\tif (!namelen)\n\t\treturn -ENOENT;\n\tif (namelen > BFS_NAMELEN)\n\t\treturn -ENAMETOOLONG;\n\n\tsblock = BFS_I(dir)->i_sblock;\n\teblock = BFS_I(dir)->i_eblock;\n\tfor (block = sblock; block <= eblock; block++) {\n\t\tbh = sb_bread(dir->i_sb, block);\n\t\tif (!bh)\n\t\t\treturn -EIO;\n\t\tfor (off = 0; off < BFS_BSIZE; off += BFS_DIRENT_SIZE) {\n\t\t\tde = (struct bfs_dirent *)(bh->b_data + off);\n\t\t\tif (!de->ino) {\n\t\t\t\tpos = (block - sblock) * BFS_BSIZE + off;\n\t\t\t\tif (pos >= dir->i_size) {\n\t\t\t\t\tdir->i_size += BFS_DIRENT_SIZE;\n\t\t\t\t\tinode_set_ctime_current(dir);\n\t\t\t\t}\n\t\t\t\tdir->i_mtime = inode_set_ctime_current(dir);\n\t\t\t\tmark_inode_dirty(dir);\n\t\t\t\tde->ino = cpu_to_le16((u16)ino);\n\t\t\t\tfor (i = 0; i < BFS_NAMELEN; i++)\n\t\t\t\t\tde->name[i] =\n\t\t\t\t\t\t(i < namelen) ? name[i] : 0;\n\t\t\t\tmark_buffer_dirty_inode(bh, dir);\n\t\t\t\tbrelse(bh);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tbrelse(bh);\n\t}\n\treturn -ENOSPC;\n}\n\nstatic inline int bfs_namecmp(int len, const unsigned char *name,\n\t\t\t\t\t\t\tconst char *buffer)\n{\n\tif ((len < BFS_NAMELEN) && buffer[len])\n\t\treturn 0;\n\treturn !memcmp(name, buffer, len);\n}\n\nstatic struct buffer_head *bfs_find_entry(struct inode *dir,\n\t\t\tconst struct qstr *child,\n\t\t\tstruct bfs_dirent **res_dir)\n{\n\tunsigned long block = 0, offset = 0;\n\tstruct buffer_head *bh = NULL;\n\tstruct bfs_dirent *de;\n\tconst unsigned char *name = child->name;\n\tint namelen = child->len;\n\n\t*res_dir = NULL;\n\tif (namelen > BFS_NAMELEN)\n\t\treturn NULL;\n\n\twhile (block * BFS_BSIZE + offset < dir->i_size) {\n\t\tif (!bh) {\n\t\t\tbh = sb_bread(dir->i_sb, BFS_I(dir)->i_sblock + block);\n\t\t\tif (!bh) {\n\t\t\t\tblock++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tde = (struct bfs_dirent *)(bh->b_data + offset);\n\t\toffset += BFS_DIRENT_SIZE;\n\t\tif (le16_to_cpu(de->ino) &&\n\t\t\t\tbfs_namecmp(namelen, name, de->name)) {\n\t\t\t*res_dir = de;\n\t\t\treturn bh;\n\t\t}\n\t\tif (offset < bh->b_size)\n\t\t\tcontinue;\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\t\toffset = 0;\n\t\tblock++;\n\t}\n\tbrelse(bh);\n\treturn NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}