{
  "module_name": "inode.c",
  "hash_id": "1150627b2d9725f27586a99465dcc5eff135bf96d97062ec986ca86f9177dfa8",
  "original_prompt": "Ingested from linux-6.6.14/fs/bfs/inode.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/vfs.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/uaccess.h>\n#include \"bfs.h\"\n\nMODULE_AUTHOR(\"Tigran Aivazian <aivazian.tigran@gmail.com>\");\nMODULE_DESCRIPTION(\"SCO UnixWare BFS filesystem for Linux\");\nMODULE_LICENSE(\"GPL\");\n\n#undef DEBUG\n\n#ifdef DEBUG\n#define dprintf(x...)\tprintf(x)\n#else\n#define dprintf(x...)\n#endif\n\nstruct inode *bfs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct bfs_inode *di;\n\tstruct inode *inode;\n\tstruct buffer_head *bh;\n\tint block, off;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tif ((ino < BFS_ROOT_INO) || (ino > BFS_SB(inode->i_sb)->si_lasti)) {\n\t\tprintf(\"Bad inode number %s:%08lx\\n\", inode->i_sb->s_id, ino);\n\t\tgoto error;\n\t}\n\n\tblock = (ino - BFS_ROOT_INO) / BFS_INODES_PER_BLOCK + 1;\n\tbh = sb_bread(inode->i_sb, block);\n\tif (!bh) {\n\t\tprintf(\"Unable to read inode %s:%08lx\\n\", inode->i_sb->s_id,\n\t\t\t\t\t\t\t\t\tino);\n\t\tgoto error;\n\t}\n\n\toff = (ino - BFS_ROOT_INO) % BFS_INODES_PER_BLOCK;\n\tdi = (struct bfs_inode *)bh->b_data + off;\n\n\tinode->i_mode = 0x0000FFFF & le32_to_cpu(di->i_mode);\n\tif (le32_to_cpu(di->i_vtype) == BFS_VDIR) {\n\t\tinode->i_mode |= S_IFDIR;\n\t\tinode->i_op = &bfs_dir_inops;\n\t\tinode->i_fop = &bfs_dir_operations;\n\t} else if (le32_to_cpu(di->i_vtype) == BFS_VREG) {\n\t\tinode->i_mode |= S_IFREG;\n\t\tinode->i_op = &bfs_file_inops;\n\t\tinode->i_fop = &bfs_file_operations;\n\t\tinode->i_mapping->a_ops = &bfs_aops;\n\t}\n\n\tBFS_I(inode)->i_sblock =  le32_to_cpu(di->i_sblock);\n\tBFS_I(inode)->i_eblock =  le32_to_cpu(di->i_eblock);\n\tBFS_I(inode)->i_dsk_ino = le16_to_cpu(di->i_ino);\n\ti_uid_write(inode, le32_to_cpu(di->i_uid));\n\ti_gid_write(inode,  le32_to_cpu(di->i_gid));\n\tset_nlink(inode, le32_to_cpu(di->i_nlink));\n\tinode->i_size = BFS_FILESIZE(di);\n\tinode->i_blocks = BFS_FILEBLOCKS(di);\n\tinode->i_atime.tv_sec =  le32_to_cpu(di->i_atime);\n\tinode->i_mtime.tv_sec =  le32_to_cpu(di->i_mtime);\n\tinode_set_ctime(inode, le32_to_cpu(di->i_ctime), 0);\n\tinode->i_atime.tv_nsec = 0;\n\tinode->i_mtime.tv_nsec = 0;\n\n\tbrelse(bh);\n\tunlock_new_inode(inode);\n\treturn inode;\n\nerror:\n\tiget_failed(inode);\n\treturn ERR_PTR(-EIO);\n}\n\nstatic struct bfs_inode *find_inode(struct super_block *sb, u16 ino, struct buffer_head **p)\n{\n\tif ((ino < BFS_ROOT_INO) || (ino > BFS_SB(sb)->si_lasti)) {\n\t\tprintf(\"Bad inode number %s:%08x\\n\", sb->s_id, ino);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\tino -= BFS_ROOT_INO;\n\n\t*p = sb_bread(sb, 1 + ino / BFS_INODES_PER_BLOCK);\n\tif (!*p) {\n\t\tprintf(\"Unable to read inode %s:%08x\\n\", sb->s_id, ino);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\treturn (struct bfs_inode *)(*p)->b_data +  ino % BFS_INODES_PER_BLOCK;\n}\n\nstatic int bfs_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tstruct bfs_sb_info *info = BFS_SB(inode->i_sb);\n\tunsigned int ino = (u16)inode->i_ino;\n\tunsigned long i_sblock;\n\tstruct bfs_inode *di;\n\tstruct buffer_head *bh;\n\tint err = 0;\n\n\tdprintf(\"ino=%08x\\n\", ino);\n\n\tdi = find_inode(inode->i_sb, ino, &bh);\n\tif (IS_ERR(di))\n\t\treturn PTR_ERR(di);\n\n\tmutex_lock(&info->bfs_lock);\n\n\tif (ino == BFS_ROOT_INO)\n\t\tdi->i_vtype = cpu_to_le32(BFS_VDIR);\n\telse\n\t\tdi->i_vtype = cpu_to_le32(BFS_VREG);\n\n\tdi->i_ino = cpu_to_le16(ino);\n\tdi->i_mode = cpu_to_le32(inode->i_mode);\n\tdi->i_uid = cpu_to_le32(i_uid_read(inode));\n\tdi->i_gid = cpu_to_le32(i_gid_read(inode));\n\tdi->i_nlink = cpu_to_le32(inode->i_nlink);\n\tdi->i_atime = cpu_to_le32(inode->i_atime.tv_sec);\n\tdi->i_mtime = cpu_to_le32(inode->i_mtime.tv_sec);\n\tdi->i_ctime = cpu_to_le32(inode_get_ctime(inode).tv_sec);\n\ti_sblock = BFS_I(inode)->i_sblock;\n\tdi->i_sblock = cpu_to_le32(i_sblock);\n\tdi->i_eblock = cpu_to_le32(BFS_I(inode)->i_eblock);\n\tdi->i_eoffset = cpu_to_le32(i_sblock * BFS_BSIZE + inode->i_size - 1);\n\n\tmark_buffer_dirty(bh);\n\tif (wbc->sync_mode == WB_SYNC_ALL) {\n\t\tsync_dirty_buffer(bh);\n\t\tif (buffer_req(bh) && !buffer_uptodate(bh))\n\t\t\terr = -EIO;\n\t}\n\tbrelse(bh);\n\tmutex_unlock(&info->bfs_lock);\n\treturn err;\n}\n\nstatic void bfs_evict_inode(struct inode *inode)\n{\n\tunsigned long ino = inode->i_ino;\n\tstruct bfs_inode *di;\n\tstruct buffer_head *bh;\n\tstruct super_block *s = inode->i_sb;\n\tstruct bfs_sb_info *info = BFS_SB(s);\n\tstruct bfs_inode_info *bi = BFS_I(inode);\n\n\tdprintf(\"ino=%08lx\\n\", ino);\n\n\ttruncate_inode_pages_final(&inode->i_data);\n\tinvalidate_inode_buffers(inode);\n\tclear_inode(inode);\n\n\tif (inode->i_nlink)\n\t\treturn;\n\n\tdi = find_inode(s, inode->i_ino, &bh);\n\tif (IS_ERR(di))\n\t\treturn;\n\n\tmutex_lock(&info->bfs_lock);\n\t \n\tmemset(di, 0, sizeof(struct bfs_inode));\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n\n\tif (bi->i_dsk_ino) {\n\t\tif (bi->i_sblock)\n\t\t\tinfo->si_freeb += bi->i_eblock + 1 - bi->i_sblock;\n\t\tinfo->si_freei++;\n\t\tclear_bit(ino, info->si_imap);\n\t\tbfs_dump_imap(\"evict_inode\", s);\n\t}\n\n\t \n\tif (info->si_lf_eblk == bi->i_eblock)\n\t\tinfo->si_lf_eblk = bi->i_sblock - 1;\n\tmutex_unlock(&info->bfs_lock);\n}\n\nstatic void bfs_put_super(struct super_block *s)\n{\n\tstruct bfs_sb_info *info = BFS_SB(s);\n\n\tif (!info)\n\t\treturn;\n\n\tmutex_destroy(&info->bfs_lock);\n\tkfree(info);\n\ts->s_fs_info = NULL;\n}\n\nstatic int bfs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *s = dentry->d_sb;\n\tstruct bfs_sb_info *info = BFS_SB(s);\n\tu64 id = huge_encode_dev(s->s_bdev->bd_dev);\n\tbuf->f_type = BFS_MAGIC;\n\tbuf->f_bsize = s->s_blocksize;\n\tbuf->f_blocks = info->si_blocks;\n\tbuf->f_bfree = buf->f_bavail = info->si_freeb;\n\tbuf->f_files = info->si_lasti + 1 - BFS_ROOT_INO;\n\tbuf->f_ffree = info->si_freei;\n\tbuf->f_fsid = u64_to_fsid(id);\n\tbuf->f_namelen = BFS_NAMELEN;\n\treturn 0;\n}\n\nstatic struct kmem_cache *bfs_inode_cachep;\n\nstatic struct inode *bfs_alloc_inode(struct super_block *sb)\n{\n\tstruct bfs_inode_info *bi;\n\tbi = alloc_inode_sb(sb, bfs_inode_cachep, GFP_KERNEL);\n\tif (!bi)\n\t\treturn NULL;\n\treturn &bi->vfs_inode;\n}\n\nstatic void bfs_free_inode(struct inode *inode)\n{\n\tkmem_cache_free(bfs_inode_cachep, BFS_I(inode));\n}\n\nstatic void init_once(void *foo)\n{\n\tstruct bfs_inode_info *bi = foo;\n\n\tinode_init_once(&bi->vfs_inode);\n}\n\nstatic int __init init_inodecache(void)\n{\n\tbfs_inode_cachep = kmem_cache_create(\"bfs_inode_cache\",\n\t\t\t\t\t     sizeof(struct bfs_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD|SLAB_ACCOUNT),\n\t\t\t\t\t     init_once);\n\tif (bfs_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic void destroy_inodecache(void)\n{\n\t \n\trcu_barrier();\n\tkmem_cache_destroy(bfs_inode_cachep);\n}\n\nstatic const struct super_operations bfs_sops = {\n\t.alloc_inode\t= bfs_alloc_inode,\n\t.free_inode\t= bfs_free_inode,\n\t.write_inode\t= bfs_write_inode,\n\t.evict_inode\t= bfs_evict_inode,\n\t.put_super\t= bfs_put_super,\n\t.statfs\t\t= bfs_statfs,\n};\n\nvoid bfs_dump_imap(const char *prefix, struct super_block *s)\n{\n#ifdef DEBUG\n\tint i;\n\tchar *tmpbuf = (char *)get_zeroed_page(GFP_KERNEL);\n\n\tif (!tmpbuf)\n\t\treturn;\n\tfor (i = BFS_SB(s)->si_lasti; i >= 0; i--) {\n\t\tif (i > PAGE_SIZE - 100) break;\n\t\tif (test_bit(i, BFS_SB(s)->si_imap))\n\t\t\tstrcat(tmpbuf, \"1\");\n\t\telse\n\t\t\tstrcat(tmpbuf, \"0\");\n\t}\n\tprintf(\"%s: lasti=%08lx <%s>\\n\", prefix, BFS_SB(s)->si_lasti, tmpbuf);\n\tfree_page((unsigned long)tmpbuf);\n#endif\n}\n\nstatic int bfs_fill_super(struct super_block *s, void *data, int silent)\n{\n\tstruct buffer_head *bh, *sbh;\n\tstruct bfs_super_block *bfs_sb;\n\tstruct inode *inode;\n\tunsigned i;\n\tstruct bfs_sb_info *info;\n\tint ret = -EINVAL;\n\tunsigned long i_sblock, i_eblock, i_eoff, s_size;\n\n\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\tmutex_init(&info->bfs_lock);\n\ts->s_fs_info = info;\n\ts->s_time_min = 0;\n\ts->s_time_max = U32_MAX;\n\n\tsb_set_blocksize(s, BFS_BSIZE);\n\n\tsbh = sb_bread(s, 0);\n\tif (!sbh)\n\t\tgoto out;\n\tbfs_sb = (struct bfs_super_block *)sbh->b_data;\n\tif (le32_to_cpu(bfs_sb->s_magic) != BFS_MAGIC) {\n\t\tif (!silent)\n\t\t\tprintf(\"No BFS filesystem on %s (magic=%08x)\\n\", s->s_id,  le32_to_cpu(bfs_sb->s_magic));\n\t\tgoto out1;\n\t}\n\tif (BFS_UNCLEAN(bfs_sb, s) && !silent)\n\t\tprintf(\"%s is unclean, continuing\\n\", s->s_id);\n\n\ts->s_magic = BFS_MAGIC;\n\n\tif (le32_to_cpu(bfs_sb->s_start) > le32_to_cpu(bfs_sb->s_end) ||\n\t    le32_to_cpu(bfs_sb->s_start) < sizeof(struct bfs_super_block) + sizeof(struct bfs_dirent)) {\n\t\tprintf(\"Superblock is corrupted on %s\\n\", s->s_id);\n\t\tgoto out1;\n\t}\n\n\tinfo->si_lasti = (le32_to_cpu(bfs_sb->s_start) - BFS_BSIZE) / sizeof(struct bfs_inode) + BFS_ROOT_INO - 1;\n\tif (info->si_lasti == BFS_MAX_LASTI)\n\t\tprintf(\"NOTE: filesystem %s was created with 512 inodes, the real maximum is 511, mounting anyway\\n\", s->s_id);\n\telse if (info->si_lasti > BFS_MAX_LASTI) {\n\t\tprintf(\"Impossible last inode number %lu > %d on %s\\n\", info->si_lasti, BFS_MAX_LASTI, s->s_id);\n\t\tgoto out1;\n\t}\n\tfor (i = 0; i < BFS_ROOT_INO; i++)\n\t\tset_bit(i, info->si_imap);\n\n\ts->s_op = &bfs_sops;\n\tinode = bfs_iget(s, BFS_ROOT_INO);\n\tif (IS_ERR(inode)) {\n\t\tret = PTR_ERR(inode);\n\t\tgoto out1;\n\t}\n\ts->s_root = d_make_root(inode);\n\tif (!s->s_root) {\n\t\tret = -ENOMEM;\n\t\tgoto out1;\n\t}\n\n\tinfo->si_blocks = (le32_to_cpu(bfs_sb->s_end) + 1) >> BFS_BSIZE_BITS;\n\tinfo->si_freeb = (le32_to_cpu(bfs_sb->s_end) + 1 - le32_to_cpu(bfs_sb->s_start)) >> BFS_BSIZE_BITS;\n\tinfo->si_freei = 0;\n\tinfo->si_lf_eblk = 0;\n\n\t \n\tbh = sb_bread(s, info->si_blocks - 1);\n\tif (!bh) {\n\t\tprintf(\"Last block not available on %s: %lu\\n\", s->s_id, info->si_blocks - 1);\n\t\tret = -EIO;\n\t\tgoto out2;\n\t}\n\tbrelse(bh);\n\n\tbh = NULL;\n\tfor (i = BFS_ROOT_INO; i <= info->si_lasti; i++) {\n\t\tstruct bfs_inode *di;\n\t\tint block = (i - BFS_ROOT_INO) / BFS_INODES_PER_BLOCK + 1;\n\t\tint off = (i - BFS_ROOT_INO) % BFS_INODES_PER_BLOCK;\n\t\tunsigned long eblock;\n\n\t\tif (!off) {\n\t\t\tbrelse(bh);\n\t\t\tbh = sb_bread(s, block);\n\t\t}\n\n\t\tif (!bh)\n\t\t\tcontinue;\n\n\t\tdi = (struct bfs_inode *)bh->b_data + off;\n\n\t\t \n\n\t\ti_eoff = le32_to_cpu(di->i_eoffset);\n\t\ti_sblock = le32_to_cpu(di->i_sblock);\n\t\ti_eblock = le32_to_cpu(di->i_eblock);\n\t\ts_size = le32_to_cpu(bfs_sb->s_end);\n\n\t\tif (i_sblock > info->si_blocks ||\n\t\t\ti_eblock > info->si_blocks ||\n\t\t\ti_sblock > i_eblock ||\n\t\t\t(i_eoff != le32_to_cpu(-1) && i_eoff > s_size) ||\n\t\t\ti_sblock * BFS_BSIZE > i_eoff) {\n\n\t\t\tprintf(\"Inode 0x%08x corrupted on %s\\n\", i, s->s_id);\n\n\t\t\tbrelse(bh);\n\t\t\tret = -EIO;\n\t\t\tgoto out2;\n\t\t}\n\n\t\tif (!di->i_ino) {\n\t\t\tinfo->si_freei++;\n\t\t\tcontinue;\n\t\t}\n\t\tset_bit(i, info->si_imap);\n\t\tinfo->si_freeb -= BFS_FILEBLOCKS(di);\n\n\t\teblock =  le32_to_cpu(di->i_eblock);\n\t\tif (eblock > info->si_lf_eblk)\n\t\t\tinfo->si_lf_eblk = eblock;\n\t}\n\tbrelse(bh);\n\tbrelse(sbh);\n\tbfs_dump_imap(\"fill_super\", s);\n\treturn 0;\n\nout2:\n\tdput(s->s_root);\n\ts->s_root = NULL;\nout1:\n\tbrelse(sbh);\nout:\n\tmutex_destroy(&info->bfs_lock);\n\tkfree(info);\n\ts->s_fs_info = NULL;\n\treturn ret;\n}\n\nstatic struct dentry *bfs_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, bfs_fill_super);\n}\n\nstatic struct file_system_type bfs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"bfs\",\n\t.mount\t\t= bfs_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\nMODULE_ALIAS_FS(\"bfs\");\n\nstatic int __init init_bfs_fs(void)\n{\n\tint err = init_inodecache();\n\tif (err)\n\t\tgoto out1;\n\terr = register_filesystem(&bfs_fs_type);\n\tif (err)\n\t\tgoto out;\n\treturn 0;\nout:\n\tdestroy_inodecache();\nout1:\n\treturn err;\n}\n\nstatic void __exit exit_bfs_fs(void)\n{\n\tunregister_filesystem(&bfs_fs_type);\n\tdestroy_inodecache();\n}\n\nmodule_init(init_bfs_fs)\nmodule_exit(exit_bfs_fs)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}