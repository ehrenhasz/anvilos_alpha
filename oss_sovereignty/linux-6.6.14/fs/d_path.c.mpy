{
  "module_name": "d_path.c",
  "hash_id": "f70d61cc713a5912225732170c9ad5c70ee8026beaab78c089c5de3754b458e0",
  "original_prompt": "Ingested from linux-6.6.14/fs/d_path.c",
  "human_readable_source": " \n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/fs_struct.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/prefetch.h>\n#include \"mount.h\"\n#include \"internal.h\"\n\nstruct prepend_buffer {\n\tchar *buf;\n\tint len;\n};\n#define DECLARE_BUFFER(__name, __buf, __len) \\\n\tstruct prepend_buffer __name = {.buf = __buf + __len, .len = __len}\n\nstatic char *extract_string(struct prepend_buffer *p)\n{\n\tif (likely(p->len >= 0))\n\t\treturn p->buf;\n\treturn ERR_PTR(-ENAMETOOLONG);\n}\n\nstatic bool prepend_char(struct prepend_buffer *p, unsigned char c)\n{\n\tif (likely(p->len > 0)) {\n\t\tp->len--;\n\t\t*--p->buf = c;\n\t\treturn true;\n\t}\n\tp->len = -1;\n\treturn false;\n}\n\n \nstatic bool prepend_copy(void *dst, const void *src, int len)\n{\n\tif (unlikely(copy_from_kernel_nofault(dst, src, len))) {\n\t\tmemset(dst, 'x', len);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic bool prepend(struct prepend_buffer *p, const char *str, int namelen)\n{\n\t \n\tif (p->len < 0)\n\t\treturn false;\n\n\t \n\tif (p->len < namelen) {\n\t\t \n\t\tstr += namelen - p->len;\n\t\tp->buf -= p->len;\n\t\tprepend_copy(p->buf, str, p->len);\n\t\tp->len = -1;\n\t\treturn false;\n\t}\n\n\t \n\tp->len -= namelen;\n\tp->buf -= namelen;\n\treturn prepend_copy(p->buf, str, namelen);\n}\n\n \nstatic bool prepend_name(struct prepend_buffer *p, const struct qstr *name)\n{\n\tconst char *dname = smp_load_acquire(&name->name);  \n\tu32 dlen = READ_ONCE(name->len);\n\n\treturn prepend(p, dname, dlen) && prepend_char(p, '/');\n}\n\nstatic int __prepend_path(const struct dentry *dentry, const struct mount *mnt,\n\t\t\t  const struct path *root, struct prepend_buffer *p)\n{\n\twhile (dentry != root->dentry || &mnt->mnt != root->mnt) {\n\t\tconst struct dentry *parent = READ_ONCE(dentry->d_parent);\n\n\t\tif (dentry == mnt->mnt.mnt_root) {\n\t\t\tstruct mount *m = READ_ONCE(mnt->mnt_parent);\n\t\t\tstruct mnt_namespace *mnt_ns;\n\n\t\t\tif (likely(mnt != m)) {\n\t\t\t\tdentry = READ_ONCE(mnt->mnt_mountpoint);\n\t\t\t\tmnt = m;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t \n\t\t\tmnt_ns = READ_ONCE(mnt->mnt_ns);\n\t\t\t \n\t\t\tif (!IS_ERR_OR_NULL(mnt_ns) && !is_anon_ns(mnt_ns))\n\t\t\t\treturn 1;\t \n\t\t\telse\n\t\t\t\treturn 2;\t \n\t\t}\n\n\t\tif (unlikely(dentry == parent))\n\t\t\t \n\t\t\treturn 3;\n\n\t\tprefetch(parent);\n\t\tif (!prepend_name(p, &dentry->d_name))\n\t\t\tbreak;\n\t\tdentry = parent;\n\t}\n\treturn 0;\n}\n\n \nstatic int prepend_path(const struct path *path,\n\t\t\tconst struct path *root,\n\t\t\tstruct prepend_buffer *p)\n{\n\tunsigned seq, m_seq = 0;\n\tstruct prepend_buffer b;\n\tint error;\n\n\trcu_read_lock();\nrestart_mnt:\n\tread_seqbegin_or_lock(&mount_lock, &m_seq);\n\tseq = 0;\n\trcu_read_lock();\nrestart:\n\tb = *p;\n\tread_seqbegin_or_lock(&rename_lock, &seq);\n\terror = __prepend_path(path->dentry, real_mount(path->mnt), root, &b);\n\tif (!(seq & 1))\n\t\trcu_read_unlock();\n\tif (need_seqretry(&rename_lock, seq)) {\n\t\tseq = 1;\n\t\tgoto restart;\n\t}\n\tdone_seqretry(&rename_lock, seq);\n\n\tif (!(m_seq & 1))\n\t\trcu_read_unlock();\n\tif (need_seqretry(&mount_lock, m_seq)) {\n\t\tm_seq = 1;\n\t\tgoto restart_mnt;\n\t}\n\tdone_seqretry(&mount_lock, m_seq);\n\n\tif (unlikely(error == 3))\n\t\tb = *p;\n\n\tif (b.len == p->len)\n\t\tprepend_char(&b, '/');\n\n\t*p = b;\n\treturn error;\n}\n\n \nchar *__d_path(const struct path *path,\n\t       const struct path *root,\n\t       char *buf, int buflen)\n{\n\tDECLARE_BUFFER(b, buf, buflen);\n\n\tprepend_char(&b, 0);\n\tif (unlikely(prepend_path(path, root, &b) > 0))\n\t\treturn NULL;\n\treturn extract_string(&b);\n}\n\nchar *d_absolute_path(const struct path *path,\n\t       char *buf, int buflen)\n{\n\tstruct path root = {};\n\tDECLARE_BUFFER(b, buf, buflen);\n\n\tprepend_char(&b, 0);\n\tif (unlikely(prepend_path(path, &root, &b) > 1))\n\t\treturn ERR_PTR(-EINVAL);\n\treturn extract_string(&b);\n}\n\nstatic void get_fs_root_rcu(struct fs_struct *fs, struct path *root)\n{\n\tunsigned seq;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&fs->seq);\n\t\t*root = fs->root;\n\t} while (read_seqcount_retry(&fs->seq, seq));\n}\n\n \nchar *d_path(const struct path *path, char *buf, int buflen)\n{\n\tDECLARE_BUFFER(b, buf, buflen);\n\tstruct path root;\n\n\t \n\tif (path->dentry->d_op && path->dentry->d_op->d_dname &&\n\t    (!IS_ROOT(path->dentry) || path->dentry != path->mnt->mnt_root))\n\t\treturn path->dentry->d_op->d_dname(path->dentry, buf, buflen);\n\n\trcu_read_lock();\n\tget_fs_root_rcu(current->fs, &root);\n\tif (unlikely(d_unlinked(path->dentry)))\n\t\tprepend(&b, \" (deleted)\", 11);\n\telse\n\t\tprepend_char(&b, 0);\n\tprepend_path(path, &root, &b);\n\trcu_read_unlock();\n\n\treturn extract_string(&b);\n}\nEXPORT_SYMBOL(d_path);\n\n \nchar *dynamic_dname(char *buffer, int buflen, const char *fmt, ...)\n{\n\tva_list args;\n\tchar temp[64];\n\tint sz;\n\n\tva_start(args, fmt);\n\tsz = vsnprintf(temp, sizeof(temp), fmt, args) + 1;\n\tva_end(args);\n\n\tif (sz > sizeof(temp) || sz > buflen)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tbuffer += buflen - sz;\n\treturn memcpy(buffer, temp, sz);\n}\n\nchar *simple_dname(struct dentry *dentry, char *buffer, int buflen)\n{\n\tDECLARE_BUFFER(b, buffer, buflen);\n\t \n\tprepend(&b, \" (deleted)\", 11);\n\tprepend(&b, dentry->d_name.name, dentry->d_name.len);\n\tprepend_char(&b, '/');\n\treturn extract_string(&b);\n}\n\n \nstatic char *__dentry_path(const struct dentry *d, struct prepend_buffer *p)\n{\n\tconst struct dentry *dentry;\n\tstruct prepend_buffer b;\n\tint seq = 0;\n\n\trcu_read_lock();\nrestart:\n\tdentry = d;\n\tb = *p;\n\tread_seqbegin_or_lock(&rename_lock, &seq);\n\twhile (!IS_ROOT(dentry)) {\n\t\tconst struct dentry *parent = dentry->d_parent;\n\n\t\tprefetch(parent);\n\t\tif (!prepend_name(&b, &dentry->d_name))\n\t\t\tbreak;\n\t\tdentry = parent;\n\t}\n\tif (!(seq & 1))\n\t\trcu_read_unlock();\n\tif (need_seqretry(&rename_lock, seq)) {\n\t\tseq = 1;\n\t\tgoto restart;\n\t}\n\tdone_seqretry(&rename_lock, seq);\n\tif (b.len == p->len)\n\t\tprepend_char(&b, '/');\n\treturn extract_string(&b);\n}\n\nchar *dentry_path_raw(const struct dentry *dentry, char *buf, int buflen)\n{\n\tDECLARE_BUFFER(b, buf, buflen);\n\n\tprepend_char(&b, 0);\n\treturn __dentry_path(dentry, &b);\n}\nEXPORT_SYMBOL(dentry_path_raw);\n\nchar *dentry_path(const struct dentry *dentry, char *buf, int buflen)\n{\n\tDECLARE_BUFFER(b, buf, buflen);\n\n\tif (unlikely(d_unlinked(dentry)))\n\t\tprepend(&b, \"//deleted\", 10);\n\telse\n\t\tprepend_char(&b, 0);\n\treturn __dentry_path(dentry, &b);\n}\n\nstatic void get_fs_root_and_pwd_rcu(struct fs_struct *fs, struct path *root,\n\t\t\t\t    struct path *pwd)\n{\n\tunsigned seq;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&fs->seq);\n\t\t*root = fs->root;\n\t\t*pwd = fs->pwd;\n\t} while (read_seqcount_retry(&fs->seq, seq));\n}\n\n \nSYSCALL_DEFINE2(getcwd, char __user *, buf, unsigned long, size)\n{\n\tint error;\n\tstruct path pwd, root;\n\tchar *page = __getname();\n\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\trcu_read_lock();\n\tget_fs_root_and_pwd_rcu(current->fs, &root, &pwd);\n\n\tif (unlikely(d_unlinked(pwd.dentry))) {\n\t\trcu_read_unlock();\n\t\terror = -ENOENT;\n\t} else {\n\t\tunsigned len;\n\t\tDECLARE_BUFFER(b, page, PATH_MAX);\n\n\t\tprepend_char(&b, 0);\n\t\tif (unlikely(prepend_path(&pwd, &root, &b) > 0))\n\t\t\tprepend(&b, \"(unreachable)\", 13);\n\t\trcu_read_unlock();\n\n\t\tlen = PATH_MAX - b.len;\n\t\tif (unlikely(len > PATH_MAX))\n\t\t\terror = -ENAMETOOLONG;\n\t\telse if (unlikely(len > size))\n\t\t\terror = -ERANGE;\n\t\telse if (copy_to_user(buf, b.buf, len))\n\t\t\terror = -EFAULT;\n\t\telse\n\t\t\terror = len;\n\t}\n\t__putname(page);\n\treturn error;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}