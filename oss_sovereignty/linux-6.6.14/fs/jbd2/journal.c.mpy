{
  "module_name": "journal.c",
  "hash_id": "7c2628225fd99dd8da8bd529f5d1030fcb0cac7561022b2ea60e0a91c20bcef5",
  "original_prompt": "Ingested from linux-6.6.14/fs/jbd2/journal.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/jbd2.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/freezer.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/poison.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/math64.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/vmalloc.h>\n#include <linux/backing-dev.h>\n#include <linux/bitops.h>\n#include <linux/ratelimit.h>\n#include <linux/sched/mm.h>\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/jbd2.h>\n\n#include <linux/uaccess.h>\n#include <asm/page.h>\n\n#ifdef CONFIG_JBD2_DEBUG\nstatic ushort jbd2_journal_enable_debug __read_mostly;\n\nmodule_param_named(jbd2_debug, jbd2_journal_enable_debug, ushort, 0644);\nMODULE_PARM_DESC(jbd2_debug, \"Debugging level for jbd2\");\n#endif\n\nEXPORT_SYMBOL(jbd2_journal_extend);\nEXPORT_SYMBOL(jbd2_journal_stop);\nEXPORT_SYMBOL(jbd2_journal_lock_updates);\nEXPORT_SYMBOL(jbd2_journal_unlock_updates);\nEXPORT_SYMBOL(jbd2_journal_get_write_access);\nEXPORT_SYMBOL(jbd2_journal_get_create_access);\nEXPORT_SYMBOL(jbd2_journal_get_undo_access);\nEXPORT_SYMBOL(jbd2_journal_set_triggers);\nEXPORT_SYMBOL(jbd2_journal_dirty_metadata);\nEXPORT_SYMBOL(jbd2_journal_forget);\nEXPORT_SYMBOL(jbd2_journal_flush);\nEXPORT_SYMBOL(jbd2_journal_revoke);\n\nEXPORT_SYMBOL(jbd2_journal_init_dev);\nEXPORT_SYMBOL(jbd2_journal_init_inode);\nEXPORT_SYMBOL(jbd2_journal_check_used_features);\nEXPORT_SYMBOL(jbd2_journal_check_available_features);\nEXPORT_SYMBOL(jbd2_journal_set_features);\nEXPORT_SYMBOL(jbd2_journal_load);\nEXPORT_SYMBOL(jbd2_journal_destroy);\nEXPORT_SYMBOL(jbd2_journal_abort);\nEXPORT_SYMBOL(jbd2_journal_errno);\nEXPORT_SYMBOL(jbd2_journal_ack_err);\nEXPORT_SYMBOL(jbd2_journal_clear_err);\nEXPORT_SYMBOL(jbd2_log_wait_commit);\nEXPORT_SYMBOL(jbd2_journal_start_commit);\nEXPORT_SYMBOL(jbd2_journal_force_commit_nested);\nEXPORT_SYMBOL(jbd2_journal_wipe);\nEXPORT_SYMBOL(jbd2_journal_blocks_per_page);\nEXPORT_SYMBOL(jbd2_journal_invalidate_folio);\nEXPORT_SYMBOL(jbd2_journal_try_to_free_buffers);\nEXPORT_SYMBOL(jbd2_journal_force_commit);\nEXPORT_SYMBOL(jbd2_journal_inode_ranged_write);\nEXPORT_SYMBOL(jbd2_journal_inode_ranged_wait);\nEXPORT_SYMBOL(jbd2_journal_finish_inode_data_buffers);\nEXPORT_SYMBOL(jbd2_journal_init_jbd_inode);\nEXPORT_SYMBOL(jbd2_journal_release_jbd_inode);\nEXPORT_SYMBOL(jbd2_journal_begin_ordered_truncate);\nEXPORT_SYMBOL(jbd2_inode_cache);\n\nstatic int jbd2_journal_create_slab(size_t slab_size);\n\n#ifdef CONFIG_JBD2_DEBUG\nvoid __jbd2_debug(int level, const char *file, const char *func,\n\t\t  unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (level > jbd2_journal_enable_debug)\n\t\treturn;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_DEBUG \"%s: (%s, %u): %pV\", file, func, line, &vaf);\n\tva_end(args);\n}\n#endif\n\n \nstatic __be32 jbd2_superblock_csum(journal_t *j, journal_superblock_t *sb)\n{\n\t__u32 csum;\n\t__be32 old_csum;\n\n\told_csum = sb->s_checksum;\n\tsb->s_checksum = 0;\n\tcsum = jbd2_chksum(j, ~0, (char *)sb, sizeof(journal_superblock_t));\n\tsb->s_checksum = old_csum;\n\n\treturn cpu_to_be32(csum);\n}\n\n \n\nstatic void commit_timeout(struct timer_list *t)\n{\n\tjournal_t *journal = from_timer(journal, t, j_commit_timer);\n\n\twake_up_process(journal->j_task);\n}\n\n \n\nstatic int kjournald2(void *arg)\n{\n\tjournal_t *journal = arg;\n\ttransaction_t *transaction;\n\n\t \n\ttimer_setup(&journal->j_commit_timer, commit_timeout, 0);\n\n\tset_freezable();\n\n\t \n\tjournal->j_task = current;\n\twake_up(&journal->j_wait_done_commit);\n\n\t \n\tmemalloc_nofs_save();\n\n\t \n\twrite_lock(&journal->j_state_lock);\n\nloop:\n\tif (journal->j_flags & JBD2_UNMOUNT)\n\t\tgoto end_loop;\n\n\tjbd2_debug(1, \"commit_sequence=%u, commit_request=%u\\n\",\n\t\tjournal->j_commit_sequence, journal->j_commit_request);\n\n\tif (journal->j_commit_sequence != journal->j_commit_request) {\n\t\tjbd2_debug(1, \"OK, requests differ\\n\");\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tdel_timer_sync(&journal->j_commit_timer);\n\t\tjbd2_journal_commit_transaction(journal);\n\t\twrite_lock(&journal->j_state_lock);\n\t\tgoto loop;\n\t}\n\n\twake_up(&journal->j_wait_done_commit);\n\tif (freezing(current)) {\n\t\t \n\t\tjbd2_debug(1, \"Now suspending kjournald2\\n\");\n\t\twrite_unlock(&journal->j_state_lock);\n\t\ttry_to_freeze();\n\t\twrite_lock(&journal->j_state_lock);\n\t} else {\n\t\t \n\t\tDEFINE_WAIT(wait);\n\t\tint should_sleep = 1;\n\n\t\tprepare_to_wait(&journal->j_wait_commit, &wait,\n\t\t\t\tTASK_INTERRUPTIBLE);\n\t\tif (journal->j_commit_sequence != journal->j_commit_request)\n\t\t\tshould_sleep = 0;\n\t\ttransaction = journal->j_running_transaction;\n\t\tif (transaction && time_after_eq(jiffies,\n\t\t\t\t\t\ttransaction->t_expires))\n\t\t\tshould_sleep = 0;\n\t\tif (journal->j_flags & JBD2_UNMOUNT)\n\t\t\tshould_sleep = 0;\n\t\tif (should_sleep) {\n\t\t\twrite_unlock(&journal->j_state_lock);\n\t\t\tschedule();\n\t\t\twrite_lock(&journal->j_state_lock);\n\t\t}\n\t\tfinish_wait(&journal->j_wait_commit, &wait);\n\t}\n\n\tjbd2_debug(1, \"kjournald2 wakes\\n\");\n\n\t \n\ttransaction = journal->j_running_transaction;\n\tif (transaction && time_after_eq(jiffies, transaction->t_expires)) {\n\t\tjournal->j_commit_request = transaction->t_tid;\n\t\tjbd2_debug(1, \"woke because of timeout\\n\");\n\t}\n\tgoto loop;\n\nend_loop:\n\tdel_timer_sync(&journal->j_commit_timer);\n\tjournal->j_task = NULL;\n\twake_up(&journal->j_wait_done_commit);\n\tjbd2_debug(1, \"Journal thread exiting.\\n\");\n\twrite_unlock(&journal->j_state_lock);\n\treturn 0;\n}\n\nstatic int jbd2_journal_start_thread(journal_t *journal)\n{\n\tstruct task_struct *t;\n\n\tt = kthread_run(kjournald2, journal, \"jbd2/%s\",\n\t\t\tjournal->j_devname);\n\tif (IS_ERR(t))\n\t\treturn PTR_ERR(t);\n\n\twait_event(journal->j_wait_done_commit, journal->j_task != NULL);\n\treturn 0;\n}\n\nstatic void journal_kill_thread(journal_t *journal)\n{\n\twrite_lock(&journal->j_state_lock);\n\tjournal->j_flags |= JBD2_UNMOUNT;\n\n\twhile (journal->j_task) {\n\t\twrite_unlock(&journal->j_state_lock);\n\t\twake_up(&journal->j_wait_commit);\n\t\twait_event(journal->j_wait_done_commit, journal->j_task == NULL);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n\twrite_unlock(&journal->j_state_lock);\n}\n\n \n\nint jbd2_journal_write_metadata_buffer(transaction_t *transaction,\n\t\t\t\t  struct journal_head  *jh_in,\n\t\t\t\t  struct buffer_head **bh_out,\n\t\t\t\t  sector_t blocknr)\n{\n\tint need_copy_out = 0;\n\tint done_copy_out = 0;\n\tint do_escape = 0;\n\tchar *mapped_data;\n\tstruct buffer_head *new_bh;\n\tstruct folio *new_folio;\n\tunsigned int new_offset;\n\tstruct buffer_head *bh_in = jh2bh(jh_in);\n\tjournal_t *journal = transaction->t_journal;\n\n\t \n\tJ_ASSERT_BH(bh_in, buffer_jbddirty(bh_in));\n\n\tnew_bh = alloc_buffer_head(GFP_NOFS|__GFP_NOFAIL);\n\n\t \n\tatomic_set(&new_bh->b_count, 1);\n\n\tspin_lock(&jh_in->b_state_lock);\nrepeat:\n\t \n\tif (jh_in->b_frozen_data) {\n\t\tdone_copy_out = 1;\n\t\tnew_folio = virt_to_folio(jh_in->b_frozen_data);\n\t\tnew_offset = offset_in_folio(new_folio, jh_in->b_frozen_data);\n\t} else {\n\t\tnew_folio = jh2bh(jh_in)->b_folio;\n\t\tnew_offset = offset_in_folio(new_folio, jh2bh(jh_in)->b_data);\n\t}\n\n\tmapped_data = kmap_local_folio(new_folio, new_offset);\n\t \n\tif (!done_copy_out)\n\t\tjbd2_buffer_frozen_trigger(jh_in, mapped_data,\n\t\t\t\t\t   jh_in->b_triggers);\n\n\t \n\tif (*((__be32 *)mapped_data) == cpu_to_be32(JBD2_MAGIC_NUMBER)) {\n\t\tneed_copy_out = 1;\n\t\tdo_escape = 1;\n\t}\n\tkunmap_local(mapped_data);\n\n\t \n\tif (need_copy_out && !done_copy_out) {\n\t\tchar *tmp;\n\n\t\tspin_unlock(&jh_in->b_state_lock);\n\t\ttmp = jbd2_alloc(bh_in->b_size, GFP_NOFS);\n\t\tif (!tmp) {\n\t\t\tbrelse(new_bh);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tspin_lock(&jh_in->b_state_lock);\n\t\tif (jh_in->b_frozen_data) {\n\t\t\tjbd2_free(tmp, bh_in->b_size);\n\t\t\tgoto repeat;\n\t\t}\n\n\t\tjh_in->b_frozen_data = tmp;\n\t\tmemcpy_from_folio(tmp, new_folio, new_offset, bh_in->b_size);\n\n\t\tnew_folio = virt_to_folio(tmp);\n\t\tnew_offset = offset_in_folio(new_folio, tmp);\n\t\tdone_copy_out = 1;\n\n\t\t \n\t\tjh_in->b_frozen_triggers = jh_in->b_triggers;\n\t}\n\n\t \n\tif (do_escape) {\n\t\tmapped_data = kmap_local_folio(new_folio, new_offset);\n\t\t*((unsigned int *)mapped_data) = 0;\n\t\tkunmap_local(mapped_data);\n\t}\n\n\tfolio_set_bh(new_bh, new_folio, new_offset);\n\tnew_bh->b_size = bh_in->b_size;\n\tnew_bh->b_bdev = journal->j_dev;\n\tnew_bh->b_blocknr = blocknr;\n\tnew_bh->b_private = bh_in;\n\tset_buffer_mapped(new_bh);\n\tset_buffer_dirty(new_bh);\n\n\t*bh_out = new_bh;\n\n\t \n\tJBUFFER_TRACE(jh_in, \"file as BJ_Shadow\");\n\tspin_lock(&journal->j_list_lock);\n\t__jbd2_journal_file_buffer(jh_in, transaction, BJ_Shadow);\n\tspin_unlock(&journal->j_list_lock);\n\tset_buffer_shadow(bh_in);\n\tspin_unlock(&jh_in->b_state_lock);\n\n\treturn do_escape | (done_copy_out << 1);\n}\n\n \n\n \nstatic int __jbd2_log_start_commit(journal_t *journal, tid_t target)\n{\n\t \n\tif (journal->j_commit_request == target)\n\t\treturn 0;\n\n\t \n\tif (journal->j_running_transaction &&\n\t    journal->j_running_transaction->t_tid == target) {\n\t\t \n\n\t\tjournal->j_commit_request = target;\n\t\tjbd2_debug(1, \"JBD2: requesting commit %u/%u\\n\",\n\t\t\t  journal->j_commit_request,\n\t\t\t  journal->j_commit_sequence);\n\t\tjournal->j_running_transaction->t_requested = jiffies;\n\t\twake_up(&journal->j_wait_commit);\n\t\treturn 1;\n\t} else if (!tid_geq(journal->j_commit_request, target))\n\t\t \n\t\tWARN_ONCE(1, \"JBD2: bad log_start_commit: %u %u %u %u\\n\",\n\t\t\t  journal->j_commit_request,\n\t\t\t  journal->j_commit_sequence,\n\t\t\t  target, journal->j_running_transaction ?\n\t\t\t  journal->j_running_transaction->t_tid : 0);\n\treturn 0;\n}\n\nint jbd2_log_start_commit(journal_t *journal, tid_t tid)\n{\n\tint ret;\n\n\twrite_lock(&journal->j_state_lock);\n\tret = __jbd2_log_start_commit(journal, tid);\n\twrite_unlock(&journal->j_state_lock);\n\treturn ret;\n}\n\n \nstatic int __jbd2_journal_force_commit(journal_t *journal)\n{\n\ttransaction_t *transaction = NULL;\n\ttid_t tid;\n\tint need_to_start = 0, ret = 0;\n\n\tread_lock(&journal->j_state_lock);\n\tif (journal->j_running_transaction && !current->journal_info) {\n\t\ttransaction = journal->j_running_transaction;\n\t\tif (!tid_geq(journal->j_commit_request, transaction->t_tid))\n\t\t\tneed_to_start = 1;\n\t} else if (journal->j_committing_transaction)\n\t\ttransaction = journal->j_committing_transaction;\n\n\tif (!transaction) {\n\t\t \n\t\tread_unlock(&journal->j_state_lock);\n\t\treturn 0;\n\t}\n\ttid = transaction->t_tid;\n\tread_unlock(&journal->j_state_lock);\n\tif (need_to_start)\n\t\tjbd2_log_start_commit(journal, tid);\n\tret = jbd2_log_wait_commit(journal, tid);\n\tif (!ret)\n\t\tret = 1;\n\n\treturn ret;\n}\n\n \nint jbd2_journal_force_commit_nested(journal_t *journal)\n{\n\tint ret;\n\n\tret = __jbd2_journal_force_commit(journal);\n\treturn ret > 0;\n}\n\n \nint jbd2_journal_force_commit(journal_t *journal)\n{\n\tint ret;\n\n\tJ_ASSERT(!current->journal_info);\n\tret = __jbd2_journal_force_commit(journal);\n\tif (ret > 0)\n\t\tret = 0;\n\treturn ret;\n}\n\n \nint jbd2_journal_start_commit(journal_t *journal, tid_t *ptid)\n{\n\tint ret = 0;\n\n\twrite_lock(&journal->j_state_lock);\n\tif (journal->j_running_transaction) {\n\t\ttid_t tid = journal->j_running_transaction->t_tid;\n\n\t\t__jbd2_log_start_commit(journal, tid);\n\t\t \n\t\tif (ptid)\n\t\t\t*ptid = tid;\n\t\tret = 1;\n\t} else if (journal->j_committing_transaction) {\n\t\t \n\t\tif (ptid)\n\t\t\t*ptid = journal->j_committing_transaction->t_tid;\n\t\tret = 1;\n\t}\n\twrite_unlock(&journal->j_state_lock);\n\treturn ret;\n}\n\n \nint jbd2_trans_will_send_data_barrier(journal_t *journal, tid_t tid)\n{\n\tint ret = 0;\n\ttransaction_t *commit_trans;\n\n\tif (!(journal->j_flags & JBD2_BARRIER))\n\t\treturn 0;\n\tread_lock(&journal->j_state_lock);\n\t \n\tif (tid_geq(journal->j_commit_sequence, tid))\n\t\tgoto out;\n\tcommit_trans = journal->j_committing_transaction;\n\tif (!commit_trans || commit_trans->t_tid != tid) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\t \n\tif (journal->j_fs_dev != journal->j_dev) {\n\t\tif (!commit_trans->t_need_data_flush ||\n\t\t    commit_trans->t_state >= T_COMMIT_DFLUSH)\n\t\t\tgoto out;\n\t} else {\n\t\tif (commit_trans->t_state >= T_COMMIT_JFLUSH)\n\t\t\tgoto out;\n\t}\n\tret = 1;\nout:\n\tread_unlock(&journal->j_state_lock);\n\treturn ret;\n}\nEXPORT_SYMBOL(jbd2_trans_will_send_data_barrier);\n\n \nint jbd2_log_wait_commit(journal_t *journal, tid_t tid)\n{\n\tint err = 0;\n\n\tread_lock(&journal->j_state_lock);\n#ifdef CONFIG_PROVE_LOCKING\n\t \n\tif (tid_gt(tid, journal->j_commit_sequence) &&\n\t    (!journal->j_committing_transaction ||\n\t     journal->j_committing_transaction->t_tid != tid)) {\n\t\tread_unlock(&journal->j_state_lock);\n\t\tjbd2_might_wait_for_commit(journal);\n\t\tread_lock(&journal->j_state_lock);\n\t}\n#endif\n#ifdef CONFIG_JBD2_DEBUG\n\tif (!tid_geq(journal->j_commit_request, tid)) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: error: j_commit_request=%u, tid=%u\\n\",\n\t\t       __func__, journal->j_commit_request, tid);\n\t}\n#endif\n\twhile (tid_gt(tid, journal->j_commit_sequence)) {\n\t\tjbd2_debug(1, \"JBD2: want %u, j_commit_sequence=%u\\n\",\n\t\t\t\t  tid, journal->j_commit_sequence);\n\t\tread_unlock(&journal->j_state_lock);\n\t\twake_up(&journal->j_wait_commit);\n\t\twait_event(journal->j_wait_done_commit,\n\t\t\t\t!tid_gt(tid, journal->j_commit_sequence));\n\t\tread_lock(&journal->j_state_lock);\n\t}\n\tread_unlock(&journal->j_state_lock);\n\n\tif (unlikely(is_journal_aborted(journal)))\n\t\terr = -EIO;\n\treturn err;\n}\n\n \nint jbd2_fc_begin_commit(journal_t *journal, tid_t tid)\n{\n\tif (unlikely(is_journal_aborted(journal)))\n\t\treturn -EIO;\n\t \n\tif (!journal->j_stats.ts_tid)\n\t\treturn -EINVAL;\n\n\twrite_lock(&journal->j_state_lock);\n\tif (tid <= journal->j_commit_sequence) {\n\t\twrite_unlock(&journal->j_state_lock);\n\t\treturn -EALREADY;\n\t}\n\n\tif (journal->j_flags & JBD2_FULL_COMMIT_ONGOING ||\n\t    (journal->j_flags & JBD2_FAST_COMMIT_ONGOING)) {\n\t\tDEFINE_WAIT(wait);\n\n\t\tprepare_to_wait(&journal->j_fc_wait, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tschedule();\n\t\tfinish_wait(&journal->j_fc_wait, &wait);\n\t\treturn -EALREADY;\n\t}\n\tjournal->j_flags |= JBD2_FAST_COMMIT_ONGOING;\n\twrite_unlock(&journal->j_state_lock);\n\tjbd2_journal_lock_updates(journal);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(jbd2_fc_begin_commit);\n\n \nstatic int __jbd2_fc_end_commit(journal_t *journal, tid_t tid, bool fallback)\n{\n\tjbd2_journal_unlock_updates(journal);\n\tif (journal->j_fc_cleanup_callback)\n\t\tjournal->j_fc_cleanup_callback(journal, 0, tid);\n\twrite_lock(&journal->j_state_lock);\n\tjournal->j_flags &= ~JBD2_FAST_COMMIT_ONGOING;\n\tif (fallback)\n\t\tjournal->j_flags |= JBD2_FULL_COMMIT_ONGOING;\n\twrite_unlock(&journal->j_state_lock);\n\twake_up(&journal->j_fc_wait);\n\tif (fallback)\n\t\treturn jbd2_complete_transaction(journal, tid);\n\treturn 0;\n}\n\nint jbd2_fc_end_commit(journal_t *journal)\n{\n\treturn __jbd2_fc_end_commit(journal, 0, false);\n}\nEXPORT_SYMBOL(jbd2_fc_end_commit);\n\nint jbd2_fc_end_commit_fallback(journal_t *journal)\n{\n\ttid_t tid;\n\n\tread_lock(&journal->j_state_lock);\n\ttid = journal->j_running_transaction ?\n\t\tjournal->j_running_transaction->t_tid : 0;\n\tread_unlock(&journal->j_state_lock);\n\treturn __jbd2_fc_end_commit(journal, tid, true);\n}\nEXPORT_SYMBOL(jbd2_fc_end_commit_fallback);\n\n \nint jbd2_transaction_committed(journal_t *journal, tid_t tid)\n{\n\tint ret = 1;\n\n\tread_lock(&journal->j_state_lock);\n\tif (journal->j_running_transaction &&\n\t    journal->j_running_transaction->t_tid == tid)\n\t\tret = 0;\n\tif (journal->j_committing_transaction &&\n\t    journal->j_committing_transaction->t_tid == tid)\n\t\tret = 0;\n\tread_unlock(&journal->j_state_lock);\n\treturn ret;\n}\nEXPORT_SYMBOL(jbd2_transaction_committed);\n\n \nint jbd2_complete_transaction(journal_t *journal, tid_t tid)\n{\n\tint\tneed_to_wait = 1;\n\n\tread_lock(&journal->j_state_lock);\n\tif (journal->j_running_transaction &&\n\t    journal->j_running_transaction->t_tid == tid) {\n\t\tif (journal->j_commit_request != tid) {\n\t\t\t \n\t\t\tread_unlock(&journal->j_state_lock);\n\t\t\tjbd2_log_start_commit(journal, tid);\n\t\t\tgoto wait_commit;\n\t\t}\n\t} else if (!(journal->j_committing_transaction &&\n\t\t     journal->j_committing_transaction->t_tid == tid))\n\t\tneed_to_wait = 0;\n\tread_unlock(&journal->j_state_lock);\n\tif (!need_to_wait)\n\t\treturn 0;\nwait_commit:\n\treturn jbd2_log_wait_commit(journal, tid);\n}\nEXPORT_SYMBOL(jbd2_complete_transaction);\n\n \n\nint jbd2_journal_next_log_block(journal_t *journal, unsigned long long *retp)\n{\n\tunsigned long blocknr;\n\n\twrite_lock(&journal->j_state_lock);\n\tJ_ASSERT(journal->j_free > 1);\n\n\tblocknr = journal->j_head;\n\tjournal->j_head++;\n\tjournal->j_free--;\n\tif (journal->j_head == journal->j_last)\n\t\tjournal->j_head = journal->j_first;\n\twrite_unlock(&journal->j_state_lock);\n\treturn jbd2_journal_bmap(journal, blocknr, retp);\n}\n\n \nint jbd2_fc_get_buf(journal_t *journal, struct buffer_head **bh_out)\n{\n\tunsigned long long pblock;\n\tunsigned long blocknr;\n\tint ret = 0;\n\tstruct buffer_head *bh;\n\tint fc_off;\n\n\t*bh_out = NULL;\n\n\tif (journal->j_fc_off + journal->j_fc_first < journal->j_fc_last) {\n\t\tfc_off = journal->j_fc_off;\n\t\tblocknr = journal->j_fc_first + fc_off;\n\t\tjournal->j_fc_off++;\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\tret = jbd2_journal_bmap(journal, blocknr, &pblock);\n\tif (ret)\n\t\treturn ret;\n\n\tbh = __getblk(journal->j_dev, pblock, journal->j_blocksize);\n\tif (!bh)\n\t\treturn -ENOMEM;\n\n\n\tjournal->j_fc_wbuf[fc_off] = bh;\n\n\t*bh_out = bh;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(jbd2_fc_get_buf);\n\n \nint jbd2_fc_wait_bufs(journal_t *journal, int num_blks)\n{\n\tstruct buffer_head *bh;\n\tint i, j_fc_off;\n\n\tj_fc_off = journal->j_fc_off;\n\n\t \n\tfor (i = j_fc_off - 1; i >= j_fc_off - num_blks; i--) {\n\t\tbh = journal->j_fc_wbuf[i];\n\t\twait_on_buffer(bh);\n\t\t \n\t\tif (unlikely(!buffer_uptodate(bh))) {\n\t\t\tjournal->j_fc_off = i + 1;\n\t\t\treturn -EIO;\n\t\t}\n\t\tput_bh(bh);\n\t\tjournal->j_fc_wbuf[i] = NULL;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(jbd2_fc_wait_bufs);\n\nint jbd2_fc_release_bufs(journal_t *journal)\n{\n\tstruct buffer_head *bh;\n\tint i, j_fc_off;\n\n\tj_fc_off = journal->j_fc_off;\n\n\tfor (i = j_fc_off - 1; i >= 0; i--) {\n\t\tbh = journal->j_fc_wbuf[i];\n\t\tif (!bh)\n\t\t\tbreak;\n\t\tput_bh(bh);\n\t\tjournal->j_fc_wbuf[i] = NULL;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(jbd2_fc_release_bufs);\n\n \nint jbd2_journal_bmap(journal_t *journal, unsigned long blocknr,\n\t\t unsigned long long *retp)\n{\n\tint err = 0;\n\tunsigned long long ret;\n\tsector_t block = blocknr;\n\n\tif (journal->j_bmap) {\n\t\terr = journal->j_bmap(journal, &block);\n\t\tif (err == 0)\n\t\t\t*retp = block;\n\t} else if (journal->j_inode) {\n\t\tret = bmap(journal->j_inode, &block);\n\n\t\tif (ret || !block) {\n\t\t\tprintk(KERN_ALERT \"%s: journal block not found \"\n\t\t\t\t\t\"at offset %lu on %s\\n\",\n\t\t\t       __func__, blocknr, journal->j_devname);\n\t\t\terr = -EIO;\n\t\t\tjbd2_journal_abort(journal, err);\n\t\t} else {\n\t\t\t*retp = block;\n\t\t}\n\n\t} else {\n\t\t*retp = blocknr;  \n\t}\n\treturn err;\n}\n\n \nstruct buffer_head *\njbd2_journal_get_descriptor_buffer(transaction_t *transaction, int type)\n{\n\tjournal_t *journal = transaction->t_journal;\n\tstruct buffer_head *bh;\n\tunsigned long long blocknr;\n\tjournal_header_t *header;\n\tint err;\n\n\terr = jbd2_journal_next_log_block(journal, &blocknr);\n\n\tif (err)\n\t\treturn NULL;\n\n\tbh = __getblk(journal->j_dev, blocknr, journal->j_blocksize);\n\tif (!bh)\n\t\treturn NULL;\n\tatomic_dec(&transaction->t_outstanding_credits);\n\tlock_buffer(bh);\n\tmemset(bh->b_data, 0, journal->j_blocksize);\n\theader = (journal_header_t *)bh->b_data;\n\theader->h_magic = cpu_to_be32(JBD2_MAGIC_NUMBER);\n\theader->h_blocktype = cpu_to_be32(type);\n\theader->h_sequence = cpu_to_be32(transaction->t_tid);\n\tset_buffer_uptodate(bh);\n\tunlock_buffer(bh);\n\tBUFFER_TRACE(bh, \"return this buffer\");\n\treturn bh;\n}\n\nvoid jbd2_descriptor_block_csum_set(journal_t *j, struct buffer_head *bh)\n{\n\tstruct jbd2_journal_block_tail *tail;\n\t__u32 csum;\n\n\tif (!jbd2_journal_has_csum_v2or3(j))\n\t\treturn;\n\n\ttail = (struct jbd2_journal_block_tail *)(bh->b_data + j->j_blocksize -\n\t\t\tsizeof(struct jbd2_journal_block_tail));\n\ttail->t_checksum = 0;\n\tcsum = jbd2_chksum(j, j->j_csum_seed, bh->b_data, j->j_blocksize);\n\ttail->t_checksum = cpu_to_be32(csum);\n}\n\n \nint jbd2_journal_get_log_tail(journal_t *journal, tid_t *tid,\n\t\t\t      unsigned long *block)\n{\n\ttransaction_t *transaction;\n\tint ret;\n\n\tread_lock(&journal->j_state_lock);\n\tspin_lock(&journal->j_list_lock);\n\ttransaction = journal->j_checkpoint_transactions;\n\tif (transaction) {\n\t\t*tid = transaction->t_tid;\n\t\t*block = transaction->t_log_start;\n\t} else if ((transaction = journal->j_committing_transaction) != NULL) {\n\t\t*tid = transaction->t_tid;\n\t\t*block = transaction->t_log_start;\n\t} else if ((transaction = journal->j_running_transaction) != NULL) {\n\t\t*tid = transaction->t_tid;\n\t\t*block = journal->j_head;\n\t} else {\n\t\t*tid = journal->j_transaction_sequence;\n\t\t*block = journal->j_head;\n\t}\n\tret = tid_gt(*tid, journal->j_tail_sequence);\n\tspin_unlock(&journal->j_list_lock);\n\tread_unlock(&journal->j_state_lock);\n\n\treturn ret;\n}\n\n \nint __jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block)\n{\n\tunsigned long freed;\n\tint ret;\n\n\tBUG_ON(!mutex_is_locked(&journal->j_checkpoint_mutex));\n\n\t \n\tret = jbd2_journal_update_sb_log_tail(journal, tid, block, REQ_FUA);\n\tif (ret)\n\t\tgoto out;\n\n\twrite_lock(&journal->j_state_lock);\n\tfreed = block - journal->j_tail;\n\tif (block < journal->j_tail)\n\t\tfreed += journal->j_last - journal->j_first;\n\n\ttrace_jbd2_update_log_tail(journal, tid, block, freed);\n\tjbd2_debug(1,\n\t\t  \"Cleaning journal tail from %u to %u (offset %lu), \"\n\t\t  \"freeing %lu\\n\",\n\t\t  journal->j_tail_sequence, tid, block, freed);\n\n\tjournal->j_free += freed;\n\tjournal->j_tail_sequence = tid;\n\tjournal->j_tail = block;\n\twrite_unlock(&journal->j_state_lock);\n\nout:\n\treturn ret;\n}\n\n \nvoid jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block)\n{\n\tmutex_lock_io(&journal->j_checkpoint_mutex);\n\tif (tid_gt(tid, journal->j_tail_sequence))\n\t\t__jbd2_update_log_tail(journal, tid, block);\n\tmutex_unlock(&journal->j_checkpoint_mutex);\n}\n\nstruct jbd2_stats_proc_session {\n\tjournal_t *journal;\n\tstruct transaction_stats_s *stats;\n\tint start;\n\tint max;\n};\n\nstatic void *jbd2_seq_info_start(struct seq_file *seq, loff_t *pos)\n{\n\treturn *pos ? NULL : SEQ_START_TOKEN;\n}\n\nstatic void *jbd2_seq_info_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\t(*pos)++;\n\treturn NULL;\n}\n\nstatic int jbd2_seq_info_show(struct seq_file *seq, void *v)\n{\n\tstruct jbd2_stats_proc_session *s = seq->private;\n\n\tif (v != SEQ_START_TOKEN)\n\t\treturn 0;\n\tseq_printf(seq, \"%lu transactions (%lu requested), \"\n\t\t   \"each up to %u blocks\\n\",\n\t\t   s->stats->ts_tid, s->stats->ts_requested,\n\t\t   s->journal->j_max_transaction_buffers);\n\tif (s->stats->ts_tid == 0)\n\t\treturn 0;\n\tseq_printf(seq, \"average: \\n  %ums waiting for transaction\\n\",\n\t    jiffies_to_msecs(s->stats->run.rs_wait / s->stats->ts_tid));\n\tseq_printf(seq, \"  %ums request delay\\n\",\n\t    (s->stats->ts_requested == 0) ? 0 :\n\t    jiffies_to_msecs(s->stats->run.rs_request_delay /\n\t\t\t     s->stats->ts_requested));\n\tseq_printf(seq, \"  %ums running transaction\\n\",\n\t    jiffies_to_msecs(s->stats->run.rs_running / s->stats->ts_tid));\n\tseq_printf(seq, \"  %ums transaction was being locked\\n\",\n\t    jiffies_to_msecs(s->stats->run.rs_locked / s->stats->ts_tid));\n\tseq_printf(seq, \"  %ums flushing data (in ordered mode)\\n\",\n\t    jiffies_to_msecs(s->stats->run.rs_flushing / s->stats->ts_tid));\n\tseq_printf(seq, \"  %ums logging transaction\\n\",\n\t    jiffies_to_msecs(s->stats->run.rs_logging / s->stats->ts_tid));\n\tseq_printf(seq, \"  %lluus average transaction commit time\\n\",\n\t\t   div_u64(s->journal->j_average_commit_time, 1000));\n\tseq_printf(seq, \"  %lu handles per transaction\\n\",\n\t    s->stats->run.rs_handle_count / s->stats->ts_tid);\n\tseq_printf(seq, \"  %lu blocks per transaction\\n\",\n\t    s->stats->run.rs_blocks / s->stats->ts_tid);\n\tseq_printf(seq, \"  %lu logged blocks per transaction\\n\",\n\t    s->stats->run.rs_blocks_logged / s->stats->ts_tid);\n\treturn 0;\n}\n\nstatic void jbd2_seq_info_stop(struct seq_file *seq, void *v)\n{\n}\n\nstatic const struct seq_operations jbd2_seq_info_ops = {\n\t.start  = jbd2_seq_info_start,\n\t.next   = jbd2_seq_info_next,\n\t.stop   = jbd2_seq_info_stop,\n\t.show   = jbd2_seq_info_show,\n};\n\nstatic int jbd2_seq_info_open(struct inode *inode, struct file *file)\n{\n\tjournal_t *journal = pde_data(inode);\n\tstruct jbd2_stats_proc_session *s;\n\tint rc, size;\n\n\ts = kmalloc(sizeof(*s), GFP_KERNEL);\n\tif (s == NULL)\n\t\treturn -ENOMEM;\n\tsize = sizeof(struct transaction_stats_s);\n\ts->stats = kmalloc(size, GFP_KERNEL);\n\tif (s->stats == NULL) {\n\t\tkfree(s);\n\t\treturn -ENOMEM;\n\t}\n\tspin_lock(&journal->j_history_lock);\n\tmemcpy(s->stats, &journal->j_stats, size);\n\ts->journal = journal;\n\tspin_unlock(&journal->j_history_lock);\n\n\trc = seq_open(file, &jbd2_seq_info_ops);\n\tif (rc == 0) {\n\t\tstruct seq_file *m = file->private_data;\n\t\tm->private = s;\n\t} else {\n\t\tkfree(s->stats);\n\t\tkfree(s);\n\t}\n\treturn rc;\n\n}\n\nstatic int jbd2_seq_info_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\tstruct jbd2_stats_proc_session *s = seq->private;\n\tkfree(s->stats);\n\tkfree(s);\n\treturn seq_release(inode, file);\n}\n\nstatic const struct proc_ops jbd2_info_proc_ops = {\n\t.proc_open\t= jbd2_seq_info_open,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_release\t= jbd2_seq_info_release,\n};\n\nstatic struct proc_dir_entry *proc_jbd2_stats;\n\nstatic void jbd2_stats_proc_init(journal_t *journal)\n{\n\tjournal->j_proc_entry = proc_mkdir(journal->j_devname, proc_jbd2_stats);\n\tif (journal->j_proc_entry) {\n\t\tproc_create_data(\"info\", S_IRUGO, journal->j_proc_entry,\n\t\t\t\t &jbd2_info_proc_ops, journal);\n\t}\n}\n\nstatic void jbd2_stats_proc_exit(journal_t *journal)\n{\n\tremove_proc_entry(\"info\", journal->j_proc_entry);\n\tremove_proc_entry(journal->j_devname, proc_jbd2_stats);\n}\n\n \nstatic int jbd2_min_tag_size(void)\n{\n\t \n\treturn sizeof(journal_block_tag_t) - 4;\n}\n\n \nstatic unsigned long jbd2_journal_shrink_scan(struct shrinker *shrink,\n\t\t\t\t\t      struct shrink_control *sc)\n{\n\tjournal_t *journal = container_of(shrink, journal_t, j_shrinker);\n\tunsigned long nr_to_scan = sc->nr_to_scan;\n\tunsigned long nr_shrunk;\n\tunsigned long count;\n\n\tcount = percpu_counter_read_positive(&journal->j_checkpoint_jh_count);\n\ttrace_jbd2_shrink_scan_enter(journal, sc->nr_to_scan, count);\n\n\tnr_shrunk = jbd2_journal_shrink_checkpoint_list(journal, &nr_to_scan);\n\n\tcount = percpu_counter_read_positive(&journal->j_checkpoint_jh_count);\n\ttrace_jbd2_shrink_scan_exit(journal, nr_to_scan, nr_shrunk, count);\n\n\treturn nr_shrunk;\n}\n\n \nstatic unsigned long jbd2_journal_shrink_count(struct shrinker *shrink,\n\t\t\t\t\t       struct shrink_control *sc)\n{\n\tjournal_t *journal = container_of(shrink, journal_t, j_shrinker);\n\tunsigned long count;\n\n\tcount = percpu_counter_read_positive(&journal->j_checkpoint_jh_count);\n\ttrace_jbd2_shrink_count(journal, sc->nr_to_scan, count);\n\n\treturn count;\n}\n\n \nstatic void journal_fail_superblock(journal_t *journal)\n{\n\tstruct buffer_head *bh = journal->j_sb_buffer;\n\tbrelse(bh);\n\tjournal->j_sb_buffer = NULL;\n}\n\n \nstatic int journal_check_superblock(journal_t *journal)\n{\n\tjournal_superblock_t *sb = journal->j_superblock;\n\tint num_fc_blks;\n\tint err = -EINVAL;\n\n\tif (sb->s_header.h_magic != cpu_to_be32(JBD2_MAGIC_NUMBER) ||\n\t    sb->s_blocksize != cpu_to_be32(journal->j_blocksize)) {\n\t\tprintk(KERN_WARNING \"JBD2: no valid journal superblock found\\n\");\n\t\treturn err;\n\t}\n\n\tif (be32_to_cpu(sb->s_header.h_blocktype) != JBD2_SUPERBLOCK_V1 &&\n\t    be32_to_cpu(sb->s_header.h_blocktype) != JBD2_SUPERBLOCK_V2) {\n\t\tprintk(KERN_WARNING \"JBD2: unrecognised superblock format ID\\n\");\n\t\treturn err;\n\t}\n\n\tif (be32_to_cpu(sb->s_maxlen) > journal->j_total_len) {\n\t\tprintk(KERN_WARNING \"JBD2: journal file too short\\n\");\n\t\treturn err;\n\t}\n\n\tif (be32_to_cpu(sb->s_first) == 0 ||\n\t    be32_to_cpu(sb->s_first) >= journal->j_total_len) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"JBD2: Invalid start block of journal: %u\\n\",\n\t\t\tbe32_to_cpu(sb->s_first));\n\t\treturn err;\n\t}\n\n\t \n\tif (!jbd2_format_support_feature(journal))\n\t\treturn 0;\n\n\tif ((sb->s_feature_ro_compat &\n\t\t\t~cpu_to_be32(JBD2_KNOWN_ROCOMPAT_FEATURES)) ||\n\t    (sb->s_feature_incompat &\n\t\t\t~cpu_to_be32(JBD2_KNOWN_INCOMPAT_FEATURES))) {\n\t\tprintk(KERN_WARNING \"JBD2: Unrecognised features on journal\\n\");\n\t\treturn err;\n\t}\n\n\tnum_fc_blks = jbd2_has_feature_fast_commit(journal) ?\n\t\t\t\tjbd2_journal_get_num_fc_blks(sb) : 0;\n\tif (be32_to_cpu(sb->s_maxlen) < JBD2_MIN_JOURNAL_BLOCKS ||\n\t    be32_to_cpu(sb->s_maxlen) - JBD2_MIN_JOURNAL_BLOCKS < num_fc_blks) {\n\t\tprintk(KERN_ERR \"JBD2: journal file too short %u,%d\\n\",\n\t\t       be32_to_cpu(sb->s_maxlen), num_fc_blks);\n\t\treturn err;\n\t}\n\n\tif (jbd2_has_feature_csum2(journal) &&\n\t    jbd2_has_feature_csum3(journal)) {\n\t\t \n\t\tprintk(KERN_ERR \"JBD2: Can't enable checksumming v2 and v3 \"\n\t\t       \"at the same time!\\n\");\n\t\treturn err;\n\t}\n\n\tif (jbd2_journal_has_csum_v2or3_feature(journal) &&\n\t    jbd2_has_feature_checksum(journal)) {\n\t\t \n\t\tprintk(KERN_ERR \"JBD2: Can't enable checksumming v1 and v2/3 \"\n\t\t       \"at the same time!\\n\");\n\t\treturn err;\n\t}\n\n\t \n\tif (jbd2_journal_has_csum_v2or3_feature(journal)) {\n\t\tif (sb->s_checksum_type != JBD2_CRC32C_CHKSUM) {\n\t\t\tprintk(KERN_ERR \"JBD2: Unknown checksum type\\n\");\n\t\t\treturn err;\n\t\t}\n\n\t\tjournal->j_chksum_driver = crypto_alloc_shash(\"crc32c\", 0, 0);\n\t\tif (IS_ERR(journal->j_chksum_driver)) {\n\t\t\tprintk(KERN_ERR \"JBD2: Cannot load crc32c driver.\\n\");\n\t\t\terr = PTR_ERR(journal->j_chksum_driver);\n\t\t\tjournal->j_chksum_driver = NULL;\n\t\t\treturn err;\n\t\t}\n\t\t \n\t\tif (sb->s_checksum != jbd2_superblock_csum(journal, sb)) {\n\t\t\tprintk(KERN_ERR \"JBD2: journal checksum error\\n\");\n\t\t\terr = -EFSBADCRC;\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int journal_revoke_records_per_block(journal_t *journal)\n{\n\tint record_size;\n\tint space = journal->j_blocksize - sizeof(jbd2_journal_revoke_header_t);\n\n\tif (jbd2_has_feature_64bit(journal))\n\t\trecord_size = 8;\n\telse\n\t\trecord_size = 4;\n\n\tif (jbd2_journal_has_csum_v2or3(journal))\n\t\tspace -= sizeof(struct jbd2_journal_block_tail);\n\treturn space / record_size;\n}\n\n \nstatic int journal_load_superblock(journal_t *journal)\n{\n\tint err;\n\tstruct buffer_head *bh;\n\tjournal_superblock_t *sb;\n\n\tbh = getblk_unmovable(journal->j_dev, journal->j_blk_offset,\n\t\t\t      journal->j_blocksize);\n\tif (bh)\n\t\terr = bh_read(bh, 0);\n\tif (!bh || err < 0) {\n\t\tpr_err(\"%s: Cannot read journal superblock\\n\", __func__);\n\t\tbrelse(bh);\n\t\treturn -EIO;\n\t}\n\n\tjournal->j_sb_buffer = bh;\n\tsb = (journal_superblock_t *)bh->b_data;\n\tjournal->j_superblock = sb;\n\terr = journal_check_superblock(journal);\n\tif (err) {\n\t\tjournal_fail_superblock(journal);\n\t\treturn err;\n\t}\n\n\tjournal->j_tail_sequence = be32_to_cpu(sb->s_sequence);\n\tjournal->j_tail = be32_to_cpu(sb->s_start);\n\tjournal->j_first = be32_to_cpu(sb->s_first);\n\tjournal->j_errno = be32_to_cpu(sb->s_errno);\n\tjournal->j_last = be32_to_cpu(sb->s_maxlen);\n\n\tif (be32_to_cpu(sb->s_maxlen) < journal->j_total_len)\n\t\tjournal->j_total_len = be32_to_cpu(sb->s_maxlen);\n\t \n\tif (jbd2_journal_has_csum_v2or3(journal))\n\t\tjournal->j_csum_seed = jbd2_chksum(journal, ~0, sb->s_uuid,\n\t\t\t\t\t\t   sizeof(sb->s_uuid));\n\tjournal->j_revoke_records_per_block =\n\t\t\t\tjournal_revoke_records_per_block(journal);\n\n\tif (jbd2_has_feature_fast_commit(journal)) {\n\t\tjournal->j_fc_last = be32_to_cpu(sb->s_maxlen);\n\t\tjournal->j_last = journal->j_fc_last -\n\t\t\t\t  jbd2_journal_get_num_fc_blks(sb);\n\t\tjournal->j_fc_first = journal->j_last + 1;\n\t\tjournal->j_fc_off = 0;\n\t}\n\n\treturn 0;\n}\n\n\n \n\n \n\nstatic journal_t *journal_init_common(struct block_device *bdev,\n\t\t\tstruct block_device *fs_dev,\n\t\t\tunsigned long long start, int len, int blocksize)\n{\n\tstatic struct lock_class_key jbd2_trans_commit_key;\n\tjournal_t *journal;\n\tint err;\n\tint n;\n\n\tjournal = kzalloc(sizeof(*journal), GFP_KERNEL);\n\tif (!journal)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tjournal->j_blocksize = blocksize;\n\tjournal->j_dev = bdev;\n\tjournal->j_fs_dev = fs_dev;\n\tjournal->j_blk_offset = start;\n\tjournal->j_total_len = len;\n\n\terr = journal_load_superblock(journal);\n\tif (err)\n\t\tgoto err_cleanup;\n\n\tinit_waitqueue_head(&journal->j_wait_transaction_locked);\n\tinit_waitqueue_head(&journal->j_wait_done_commit);\n\tinit_waitqueue_head(&journal->j_wait_commit);\n\tinit_waitqueue_head(&journal->j_wait_updates);\n\tinit_waitqueue_head(&journal->j_wait_reserved);\n\tinit_waitqueue_head(&journal->j_fc_wait);\n\tmutex_init(&journal->j_abort_mutex);\n\tmutex_init(&journal->j_barrier);\n\tmutex_init(&journal->j_checkpoint_mutex);\n\tspin_lock_init(&journal->j_revoke_lock);\n\tspin_lock_init(&journal->j_list_lock);\n\tspin_lock_init(&journal->j_history_lock);\n\trwlock_init(&journal->j_state_lock);\n\n\tjournal->j_commit_interval = (HZ * JBD2_DEFAULT_MAX_COMMIT_AGE);\n\tjournal->j_min_batch_time = 0;\n\tjournal->j_max_batch_time = 15000;  \n\tatomic_set(&journal->j_reserved_credits, 0);\n\tlockdep_init_map(&journal->j_trans_commit_map, \"jbd2_handle\",\n\t\t\t &jbd2_trans_commit_key, 0);\n\n\t \n\tjournal->j_flags = JBD2_ABORT;\n\n\t \n\terr = jbd2_journal_init_revoke(journal, JOURNAL_REVOKE_DEFAULT_HASH);\n\tif (err)\n\t\tgoto err_cleanup;\n\n\t \n\terr = -ENOMEM;\n\tn = journal->j_blocksize / jbd2_min_tag_size();\n\tjournal->j_wbufsize = n;\n\tjournal->j_fc_wbuf = NULL;\n\tjournal->j_wbuf = kmalloc_array(n, sizeof(struct buffer_head *),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!journal->j_wbuf)\n\t\tgoto err_cleanup;\n\n\terr = percpu_counter_init(&journal->j_checkpoint_jh_count, 0,\n\t\t\t\t  GFP_KERNEL);\n\tif (err)\n\t\tgoto err_cleanup;\n\n\tjournal->j_shrink_transaction = NULL;\n\tjournal->j_shrinker.scan_objects = jbd2_journal_shrink_scan;\n\tjournal->j_shrinker.count_objects = jbd2_journal_shrink_count;\n\tjournal->j_shrinker.seeks = DEFAULT_SEEKS;\n\tjournal->j_shrinker.batch = journal->j_max_transaction_buffers;\n\terr = register_shrinker(&journal->j_shrinker, \"jbd2-journal:(%u:%u)\",\n\t\t\t\tMAJOR(bdev->bd_dev), MINOR(bdev->bd_dev));\n\tif (err)\n\t\tgoto err_cleanup;\n\n\treturn journal;\n\nerr_cleanup:\n\tpercpu_counter_destroy(&journal->j_checkpoint_jh_count);\n\tif (journal->j_chksum_driver)\n\t\tcrypto_free_shash(journal->j_chksum_driver);\n\tkfree(journal->j_wbuf);\n\tjbd2_journal_destroy_revoke(journal);\n\tjournal_fail_superblock(journal);\n\tkfree(journal);\n\treturn ERR_PTR(err);\n}\n\n \n\n \njournal_t *jbd2_journal_init_dev(struct block_device *bdev,\n\t\t\tstruct block_device *fs_dev,\n\t\t\tunsigned long long start, int len, int blocksize)\n{\n\tjournal_t *journal;\n\n\tjournal = journal_init_common(bdev, fs_dev, start, len, blocksize);\n\tif (IS_ERR(journal))\n\t\treturn ERR_CAST(journal);\n\n\tsnprintf(journal->j_devname, sizeof(journal->j_devname),\n\t\t \"%pg\", journal->j_dev);\n\tstrreplace(journal->j_devname, '/', '!');\n\tjbd2_stats_proc_init(journal);\n\n\treturn journal;\n}\n\n \njournal_t *jbd2_journal_init_inode(struct inode *inode)\n{\n\tjournal_t *journal;\n\tsector_t blocknr;\n\tint err = 0;\n\n\tblocknr = 0;\n\terr = bmap(inode, &blocknr);\n\tif (err || !blocknr) {\n\t\tpr_err(\"%s: Cannot locate journal superblock\\n\", __func__);\n\t\treturn err ? ERR_PTR(err) : ERR_PTR(-EINVAL);\n\t}\n\n\tjbd2_debug(1, \"JBD2: inode %s/%ld, size %lld, bits %d, blksize %ld\\n\",\n\t\t  inode->i_sb->s_id, inode->i_ino, (long long) inode->i_size,\n\t\t  inode->i_sb->s_blocksize_bits, inode->i_sb->s_blocksize);\n\n\tjournal = journal_init_common(inode->i_sb->s_bdev, inode->i_sb->s_bdev,\n\t\t\tblocknr, inode->i_size >> inode->i_sb->s_blocksize_bits,\n\t\t\tinode->i_sb->s_blocksize);\n\tif (IS_ERR(journal))\n\t\treturn ERR_CAST(journal);\n\n\tjournal->j_inode = inode;\n\tsnprintf(journal->j_devname, sizeof(journal->j_devname),\n\t\t \"%pg-%lu\", journal->j_dev, journal->j_inode->i_ino);\n\tstrreplace(journal->j_devname, '/', '!');\n\tjbd2_stats_proc_init(journal);\n\n\treturn journal;\n}\n\n \n\nstatic int journal_reset(journal_t *journal)\n{\n\tjournal_superblock_t *sb = journal->j_superblock;\n\tunsigned long long first, last;\n\n\tfirst = be32_to_cpu(sb->s_first);\n\tlast = be32_to_cpu(sb->s_maxlen);\n\tif (first + JBD2_MIN_JOURNAL_BLOCKS > last + 1) {\n\t\tprintk(KERN_ERR \"JBD2: Journal too short (blocks %llu-%llu).\\n\",\n\t\t       first, last);\n\t\tjournal_fail_superblock(journal);\n\t\treturn -EINVAL;\n\t}\n\n\tjournal->j_first = first;\n\tjournal->j_last = last;\n\n\tif (journal->j_head != 0 && journal->j_flags & JBD2_CYCLE_RECORD) {\n\t\t \n\t\tif (journal->j_head < first || journal->j_head >= last) {\n\t\t\tprintk(KERN_WARNING \"JBD2: Incorrect Journal head block %lu, \"\n\t\t\t       \"disable journal_cycle_record\\n\",\n\t\t\t       journal->j_head);\n\t\t\tjournal->j_head = journal->j_first;\n\t\t}\n\t} else {\n\t\tjournal->j_head = journal->j_first;\n\t}\n\tjournal->j_tail = journal->j_head;\n\tjournal->j_free = journal->j_last - journal->j_first;\n\n\tjournal->j_tail_sequence = journal->j_transaction_sequence;\n\tjournal->j_commit_sequence = journal->j_transaction_sequence - 1;\n\tjournal->j_commit_request = journal->j_commit_sequence;\n\n\tjournal->j_max_transaction_buffers = jbd2_journal_get_max_txn_bufs(journal);\n\n\t \n\tjbd2_clear_feature_fast_commit(journal);\n\n\t \n\tif (sb->s_start == 0) {\n\t\tjbd2_debug(1, \"JBD2: Skipping superblock update on recovered sb \"\n\t\t\t\"(start %ld, seq %u, errno %d)\\n\",\n\t\t\tjournal->j_tail, journal->j_tail_sequence,\n\t\t\tjournal->j_errno);\n\t\tjournal->j_flags |= JBD2_FLUSHED;\n\t} else {\n\t\t \n\t\tmutex_lock_io(&journal->j_checkpoint_mutex);\n\t\t \n\t\tjbd2_journal_update_sb_log_tail(journal,\n\t\t\t\t\t\tjournal->j_tail_sequence,\n\t\t\t\t\t\tjournal->j_tail, REQ_FUA);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t}\n\treturn jbd2_journal_start_thread(journal);\n}\n\n \nstatic int jbd2_write_superblock(journal_t *journal, blk_opf_t write_flags)\n{\n\tstruct buffer_head *bh = journal->j_sb_buffer;\n\tjournal_superblock_t *sb = journal->j_superblock;\n\tint ret = 0;\n\n\t \n\tif (!buffer_mapped(bh)) {\n\t\tunlock_buffer(bh);\n\t\treturn -EIO;\n\t}\n\n\t \n\twrite_flags |= JBD2_JOURNAL_REQ_FLAGS;\n\tif (!(journal->j_flags & JBD2_BARRIER))\n\t\twrite_flags &= ~(REQ_FUA | REQ_PREFLUSH);\n\n\ttrace_jbd2_write_superblock(journal, write_flags);\n\n\tif (buffer_write_io_error(bh)) {\n\t\t \n\t\tprintk(KERN_ERR \"JBD2: previous I/O error detected \"\n\t\t       \"for journal superblock update for %s.\\n\",\n\t\t       journal->j_devname);\n\t\tclear_buffer_write_io_error(bh);\n\t\tset_buffer_uptodate(bh);\n\t}\n\tif (jbd2_journal_has_csum_v2or3(journal))\n\t\tsb->s_checksum = jbd2_superblock_csum(journal, sb);\n\tget_bh(bh);\n\tbh->b_end_io = end_buffer_write_sync;\n\tsubmit_bh(REQ_OP_WRITE | write_flags, bh);\n\twait_on_buffer(bh);\n\tif (buffer_write_io_error(bh)) {\n\t\tclear_buffer_write_io_error(bh);\n\t\tset_buffer_uptodate(bh);\n\t\tret = -EIO;\n\t}\n\tif (ret) {\n\t\tprintk(KERN_ERR \"JBD2: I/O error when updating journal superblock for %s.\\n\",\n\t\t\t\tjournal->j_devname);\n\t\tif (!is_journal_aborted(journal))\n\t\t\tjbd2_journal_abort(journal, ret);\n\t}\n\n\treturn ret;\n}\n\n \nint jbd2_journal_update_sb_log_tail(journal_t *journal, tid_t tail_tid,\n\t\t\t\t    unsigned long tail_block,\n\t\t\t\t    blk_opf_t write_flags)\n{\n\tjournal_superblock_t *sb = journal->j_superblock;\n\tint ret;\n\n\tif (is_journal_aborted(journal))\n\t\treturn -EIO;\n\tif (test_bit(JBD2_CHECKPOINT_IO_ERROR, &journal->j_atomic_flags)) {\n\t\tjbd2_journal_abort(journal, -EIO);\n\t\treturn -EIO;\n\t}\n\n\tBUG_ON(!mutex_is_locked(&journal->j_checkpoint_mutex));\n\tjbd2_debug(1, \"JBD2: updating superblock (start %lu, seq %u)\\n\",\n\t\t  tail_block, tail_tid);\n\n\tlock_buffer(journal->j_sb_buffer);\n\tsb->s_sequence = cpu_to_be32(tail_tid);\n\tsb->s_start    = cpu_to_be32(tail_block);\n\n\tret = jbd2_write_superblock(journal, write_flags);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\twrite_lock(&journal->j_state_lock);\n\tWARN_ON(!sb->s_sequence);\n\tjournal->j_flags &= ~JBD2_FLUSHED;\n\twrite_unlock(&journal->j_state_lock);\n\nout:\n\treturn ret;\n}\n\n \nstatic void jbd2_mark_journal_empty(journal_t *journal, blk_opf_t write_flags)\n{\n\tjournal_superblock_t *sb = journal->j_superblock;\n\tbool had_fast_commit = false;\n\n\tBUG_ON(!mutex_is_locked(&journal->j_checkpoint_mutex));\n\tlock_buffer(journal->j_sb_buffer);\n\tif (sb->s_start == 0) {\t\t \n\t\tunlock_buffer(journal->j_sb_buffer);\n\t\treturn;\n\t}\n\n\tjbd2_debug(1, \"JBD2: Marking journal as empty (seq %u)\\n\",\n\t\t  journal->j_tail_sequence);\n\n\tsb->s_sequence = cpu_to_be32(journal->j_tail_sequence);\n\tsb->s_start    = cpu_to_be32(0);\n\tsb->s_head     = cpu_to_be32(journal->j_head);\n\tif (jbd2_has_feature_fast_commit(journal)) {\n\t\t \n\t\tjbd2_clear_feature_fast_commit(journal);\n\t\thad_fast_commit = true;\n\t}\n\n\tjbd2_write_superblock(journal, write_flags);\n\n\tif (had_fast_commit)\n\t\tjbd2_set_feature_fast_commit(journal);\n\n\t \n\twrite_lock(&journal->j_state_lock);\n\tjournal->j_flags |= JBD2_FLUSHED;\n\twrite_unlock(&journal->j_state_lock);\n}\n\n \nstatic int __jbd2_journal_erase(journal_t *journal, unsigned int flags)\n{\n\tint err = 0;\n\tunsigned long block, log_offset;  \n\tunsigned long long phys_block, block_start, block_stop;  \n\tloff_t byte_start, byte_stop, byte_count;\n\n\t \n\tif ((flags & ~JBD2_JOURNAL_FLUSH_VALID) || !flags ||\n\t\t\t((flags & JBD2_JOURNAL_FLUSH_DISCARD) &&\n\t\t\t(flags & JBD2_JOURNAL_FLUSH_ZEROOUT)))\n\t\treturn -EINVAL;\n\n\tif ((flags & JBD2_JOURNAL_FLUSH_DISCARD) &&\n\t    !bdev_max_discard_sectors(journal->j_dev))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tlog_offset = be32_to_cpu(journal->j_superblock->s_first);\n\tblock_start =  ~0ULL;\n\tfor (block = log_offset; block < journal->j_total_len; block++) {\n\t\terr = jbd2_journal_bmap(journal, block, &phys_block);\n\t\tif (err) {\n\t\t\tpr_err(\"JBD2: bad block at offset %lu\", block);\n\t\t\treturn err;\n\t\t}\n\n\t\tif (block_start == ~0ULL) {\n\t\t\tblock_start = phys_block;\n\t\t\tblock_stop = block_start - 1;\n\t\t}\n\n\t\t \n\t\tif (phys_block != block_stop + 1) {\n\t\t\tblock--;\n\t\t} else {\n\t\t\tblock_stop++;\n\t\t\t \n\t\t\tif (block != journal->j_total_len - 1)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tbyte_start = block_start * journal->j_blocksize;\n\t\tbyte_stop = block_stop * journal->j_blocksize;\n\t\tbyte_count = (block_stop - block_start + 1) *\n\t\t\t\tjournal->j_blocksize;\n\n\t\ttruncate_inode_pages_range(journal->j_dev->bd_inode->i_mapping,\n\t\t\t\tbyte_start, byte_stop);\n\n\t\tif (flags & JBD2_JOURNAL_FLUSH_DISCARD) {\n\t\t\terr = blkdev_issue_discard(journal->j_dev,\n\t\t\t\t\tbyte_start >> SECTOR_SHIFT,\n\t\t\t\t\tbyte_count >> SECTOR_SHIFT,\n\t\t\t\t\tGFP_NOFS);\n\t\t} else if (flags & JBD2_JOURNAL_FLUSH_ZEROOUT) {\n\t\t\terr = blkdev_issue_zeroout(journal->j_dev,\n\t\t\t\t\tbyte_start >> SECTOR_SHIFT,\n\t\t\t\t\tbyte_count >> SECTOR_SHIFT,\n\t\t\t\t\tGFP_NOFS, 0);\n\t\t}\n\n\t\tif (unlikely(err != 0)) {\n\t\t\tpr_err(\"JBD2: (error %d) unable to wipe journal at physical blocks %llu - %llu\",\n\t\t\t\t\terr, block_start, block_stop);\n\t\t\treturn err;\n\t\t}\n\n\t\t \n\t\tblock_start = ~0ULL;\n\t}\n\n\treturn blkdev_issue_flush(journal->j_dev);\n}\n\n \nvoid jbd2_journal_update_sb_errno(journal_t *journal)\n{\n\tjournal_superblock_t *sb = journal->j_superblock;\n\tint errcode;\n\n\tlock_buffer(journal->j_sb_buffer);\n\terrcode = journal->j_errno;\n\tif (errcode == -ESHUTDOWN)\n\t\terrcode = 0;\n\tjbd2_debug(1, \"JBD2: updating superblock error (errno %d)\\n\", errcode);\n\tsb->s_errno    = cpu_to_be32(errcode);\n\n\tjbd2_write_superblock(journal, REQ_FUA);\n}\nEXPORT_SYMBOL(jbd2_journal_update_sb_errno);\n\n \nint jbd2_journal_load(journal_t *journal)\n{\n\tint err;\n\tjournal_superblock_t *sb = journal->j_superblock;\n\n\t \n\terr = jbd2_journal_create_slab(be32_to_cpu(sb->s_blocksize));\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = jbd2_journal_recover(journal);\n\tif (err) {\n\t\tpr_warn(\"JBD2: journal recovery failed\\n\");\n\t\treturn err;\n\t}\n\n\tif (journal->j_failed_commit) {\n\t\tprintk(KERN_ERR \"JBD2: journal transaction %u on %s \"\n\t\t       \"is corrupt.\\n\", journal->j_failed_commit,\n\t\t       journal->j_devname);\n\t\treturn -EFSCORRUPTED;\n\t}\n\t \n\tjournal->j_flags &= ~JBD2_ABORT;\n\n\t \n\terr = journal_reset(journal);\n\tif (err) {\n\t\tpr_warn(\"JBD2: journal reset failed\\n\");\n\t\treturn err;\n\t}\n\n\tjournal->j_flags |= JBD2_LOADED;\n\treturn 0;\n}\n\n \nint jbd2_journal_destroy(journal_t *journal)\n{\n\tint err = 0;\n\n\t \n\tjournal_kill_thread(journal);\n\n\t \n\tif (journal->j_running_transaction)\n\t\tjbd2_journal_commit_transaction(journal);\n\n\t \n\n\t \n\tspin_lock(&journal->j_list_lock);\n\twhile (journal->j_checkpoint_transactions != NULL) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tmutex_lock_io(&journal->j_checkpoint_mutex);\n\t\terr = jbd2_log_do_checkpoint(journal);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t\t \n\t\tif (err) {\n\t\t\tjbd2_journal_destroy_checkpoint(journal);\n\t\t\tspin_lock(&journal->j_list_lock);\n\t\t\tbreak;\n\t\t}\n\t\tspin_lock(&journal->j_list_lock);\n\t}\n\n\tJ_ASSERT(journal->j_running_transaction == NULL);\n\tJ_ASSERT(journal->j_committing_transaction == NULL);\n\tJ_ASSERT(journal->j_checkpoint_transactions == NULL);\n\tspin_unlock(&journal->j_list_lock);\n\n\t \n\tif (!is_journal_aborted(journal) &&\n\t    test_bit(JBD2_CHECKPOINT_IO_ERROR, &journal->j_atomic_flags))\n\t\tjbd2_journal_abort(journal, -EIO);\n\n\tif (journal->j_sb_buffer) {\n\t\tif (!is_journal_aborted(journal)) {\n\t\t\tmutex_lock_io(&journal->j_checkpoint_mutex);\n\n\t\t\twrite_lock(&journal->j_state_lock);\n\t\t\tjournal->j_tail_sequence =\n\t\t\t\t++journal->j_transaction_sequence;\n\t\t\twrite_unlock(&journal->j_state_lock);\n\n\t\t\tjbd2_mark_journal_empty(journal, REQ_PREFLUSH | REQ_FUA);\n\t\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t\t} else\n\t\t\terr = -EIO;\n\t\tbrelse(journal->j_sb_buffer);\n\t}\n\n\tif (journal->j_shrinker.flags & SHRINKER_REGISTERED) {\n\t\tpercpu_counter_destroy(&journal->j_checkpoint_jh_count);\n\t\tunregister_shrinker(&journal->j_shrinker);\n\t}\n\tif (journal->j_proc_entry)\n\t\tjbd2_stats_proc_exit(journal);\n\tiput(journal->j_inode);\n\tif (journal->j_revoke)\n\t\tjbd2_journal_destroy_revoke(journal);\n\tif (journal->j_chksum_driver)\n\t\tcrypto_free_shash(journal->j_chksum_driver);\n\tkfree(journal->j_fc_wbuf);\n\tkfree(journal->j_wbuf);\n\tkfree(journal);\n\n\treturn err;\n}\n\n\n \n\nint jbd2_journal_check_used_features(journal_t *journal, unsigned long compat,\n\t\t\t\t unsigned long ro, unsigned long incompat)\n{\n\tjournal_superblock_t *sb;\n\n\tif (!compat && !ro && !incompat)\n\t\treturn 1;\n\tif (!jbd2_format_support_feature(journal))\n\t\treturn 0;\n\n\tsb = journal->j_superblock;\n\n\tif (((be32_to_cpu(sb->s_feature_compat) & compat) == compat) &&\n\t    ((be32_to_cpu(sb->s_feature_ro_compat) & ro) == ro) &&\n\t    ((be32_to_cpu(sb->s_feature_incompat) & incompat) == incompat))\n\t\treturn 1;\n\n\treturn 0;\n}\n\n \n\nint jbd2_journal_check_available_features(journal_t *journal, unsigned long compat,\n\t\t\t\t      unsigned long ro, unsigned long incompat)\n{\n\tif (!compat && !ro && !incompat)\n\t\treturn 1;\n\n\tif (!jbd2_format_support_feature(journal))\n\t\treturn 0;\n\n\tif ((compat   & JBD2_KNOWN_COMPAT_FEATURES) == compat &&\n\t    (ro       & JBD2_KNOWN_ROCOMPAT_FEATURES) == ro &&\n\t    (incompat & JBD2_KNOWN_INCOMPAT_FEATURES) == incompat)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int\njbd2_journal_initialize_fast_commit(journal_t *journal)\n{\n\tjournal_superblock_t *sb = journal->j_superblock;\n\tunsigned long long num_fc_blks;\n\n\tnum_fc_blks = jbd2_journal_get_num_fc_blks(sb);\n\tif (journal->j_last - num_fc_blks < JBD2_MIN_JOURNAL_BLOCKS)\n\t\treturn -ENOSPC;\n\n\t \n\tWARN_ON(journal->j_fc_wbuf != NULL);\n\tjournal->j_fc_wbuf = kmalloc_array(num_fc_blks,\n\t\t\t\tsizeof(struct buffer_head *), GFP_KERNEL);\n\tif (!journal->j_fc_wbuf)\n\t\treturn -ENOMEM;\n\n\tjournal->j_fc_wbufsize = num_fc_blks;\n\tjournal->j_fc_last = journal->j_last;\n\tjournal->j_last = journal->j_fc_last - num_fc_blks;\n\tjournal->j_fc_first = journal->j_last + 1;\n\tjournal->j_fc_off = 0;\n\tjournal->j_free = journal->j_last - journal->j_first;\n\tjournal->j_max_transaction_buffers =\n\t\tjbd2_journal_get_max_txn_bufs(journal);\n\n\treturn 0;\n}\n\n \n\nint jbd2_journal_set_features(journal_t *journal, unsigned long compat,\n\t\t\t  unsigned long ro, unsigned long incompat)\n{\n#define INCOMPAT_FEATURE_ON(f) \\\n\t\t((incompat & (f)) && !(sb->s_feature_incompat & cpu_to_be32(f)))\n#define COMPAT_FEATURE_ON(f) \\\n\t\t((compat & (f)) && !(sb->s_feature_compat & cpu_to_be32(f)))\n\tjournal_superblock_t *sb;\n\n\tif (jbd2_journal_check_used_features(journal, compat, ro, incompat))\n\t\treturn 1;\n\n\tif (!jbd2_journal_check_available_features(journal, compat, ro, incompat))\n\t\treturn 0;\n\n\t \n\tif (incompat & JBD2_FEATURE_INCOMPAT_CSUM_V2) {\n\t\tincompat &= ~JBD2_FEATURE_INCOMPAT_CSUM_V2;\n\t\tincompat |= JBD2_FEATURE_INCOMPAT_CSUM_V3;\n\t}\n\n\t \n\tif (incompat & JBD2_FEATURE_INCOMPAT_CSUM_V3 &&\n\t    compat & JBD2_FEATURE_COMPAT_CHECKSUM)\n\t\tcompat &= ~JBD2_FEATURE_COMPAT_CHECKSUM;\n\n\tjbd2_debug(1, \"Setting new features 0x%lx/0x%lx/0x%lx\\n\",\n\t\t  compat, ro, incompat);\n\n\tsb = journal->j_superblock;\n\n\tif (incompat & JBD2_FEATURE_INCOMPAT_FAST_COMMIT) {\n\t\tif (jbd2_journal_initialize_fast_commit(journal)) {\n\t\t\tpr_err(\"JBD2: Cannot enable fast commits.\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\tif ((journal->j_chksum_driver == NULL) &&\n\t    INCOMPAT_FEATURE_ON(JBD2_FEATURE_INCOMPAT_CSUM_V3)) {\n\t\tjournal->j_chksum_driver = crypto_alloc_shash(\"crc32c\", 0, 0);\n\t\tif (IS_ERR(journal->j_chksum_driver)) {\n\t\t\tprintk(KERN_ERR \"JBD2: Cannot load crc32c driver.\\n\");\n\t\t\tjournal->j_chksum_driver = NULL;\n\t\t\treturn 0;\n\t\t}\n\t\t \n\t\tjournal->j_csum_seed = jbd2_chksum(journal, ~0, sb->s_uuid,\n\t\t\t\t\t\t   sizeof(sb->s_uuid));\n\t}\n\n\tlock_buffer(journal->j_sb_buffer);\n\n\t \n\tif (INCOMPAT_FEATURE_ON(JBD2_FEATURE_INCOMPAT_CSUM_V3)) {\n\t\tsb->s_checksum_type = JBD2_CRC32C_CHKSUM;\n\t\tsb->s_feature_compat &=\n\t\t\t~cpu_to_be32(JBD2_FEATURE_COMPAT_CHECKSUM);\n\t}\n\n\t \n\tif (COMPAT_FEATURE_ON(JBD2_FEATURE_COMPAT_CHECKSUM))\n\t\tsb->s_feature_incompat &=\n\t\t\t~cpu_to_be32(JBD2_FEATURE_INCOMPAT_CSUM_V2 |\n\t\t\t\t     JBD2_FEATURE_INCOMPAT_CSUM_V3);\n\n\tsb->s_feature_compat    |= cpu_to_be32(compat);\n\tsb->s_feature_ro_compat |= cpu_to_be32(ro);\n\tsb->s_feature_incompat  |= cpu_to_be32(incompat);\n\tunlock_buffer(journal->j_sb_buffer);\n\tjournal->j_revoke_records_per_block =\n\t\t\t\tjournal_revoke_records_per_block(journal);\n\n\treturn 1;\n#undef COMPAT_FEATURE_ON\n#undef INCOMPAT_FEATURE_ON\n}\n\n \nvoid jbd2_journal_clear_features(journal_t *journal, unsigned long compat,\n\t\t\t\tunsigned long ro, unsigned long incompat)\n{\n\tjournal_superblock_t *sb;\n\n\tjbd2_debug(1, \"Clear features 0x%lx/0x%lx/0x%lx\\n\",\n\t\t  compat, ro, incompat);\n\n\tsb = journal->j_superblock;\n\n\tsb->s_feature_compat    &= ~cpu_to_be32(compat);\n\tsb->s_feature_ro_compat &= ~cpu_to_be32(ro);\n\tsb->s_feature_incompat  &= ~cpu_to_be32(incompat);\n\tjournal->j_revoke_records_per_block =\n\t\t\t\tjournal_revoke_records_per_block(journal);\n}\nEXPORT_SYMBOL(jbd2_journal_clear_features);\n\n \nint jbd2_journal_flush(journal_t *journal, unsigned int flags)\n{\n\tint err = 0;\n\ttransaction_t *transaction = NULL;\n\n\twrite_lock(&journal->j_state_lock);\n\n\t \n\tif (journal->j_running_transaction) {\n\t\ttransaction = journal->j_running_transaction;\n\t\t__jbd2_log_start_commit(journal, transaction->t_tid);\n\t} else if (journal->j_committing_transaction)\n\t\ttransaction = journal->j_committing_transaction;\n\n\t \n\tif (transaction) {\n\t\ttid_t tid = transaction->t_tid;\n\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tjbd2_log_wait_commit(journal, tid);\n\t} else {\n\t\twrite_unlock(&journal->j_state_lock);\n\t}\n\n\t \n\tspin_lock(&journal->j_list_lock);\n\twhile (!err && journal->j_checkpoint_transactions != NULL) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tmutex_lock_io(&journal->j_checkpoint_mutex);\n\t\terr = jbd2_log_do_checkpoint(journal);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t\tspin_lock(&journal->j_list_lock);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\n\tif (is_journal_aborted(journal))\n\t\treturn -EIO;\n\n\tmutex_lock_io(&journal->j_checkpoint_mutex);\n\tif (!err) {\n\t\terr = jbd2_cleanup_journal_tail(journal);\n\t\tif (err < 0) {\n\t\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t\t\tgoto out;\n\t\t}\n\t\terr = 0;\n\t}\n\n\t \n\tjbd2_mark_journal_empty(journal, REQ_FUA);\n\n\tif (flags)\n\t\terr = __jbd2_journal_erase(journal, flags);\n\n\tmutex_unlock(&journal->j_checkpoint_mutex);\n\twrite_lock(&journal->j_state_lock);\n\tJ_ASSERT(!journal->j_running_transaction);\n\tJ_ASSERT(!journal->j_committing_transaction);\n\tJ_ASSERT(!journal->j_checkpoint_transactions);\n\tJ_ASSERT(journal->j_head == journal->j_tail);\n\tJ_ASSERT(journal->j_tail_sequence == journal->j_transaction_sequence);\n\twrite_unlock(&journal->j_state_lock);\nout:\n\treturn err;\n}\n\n \n\nint jbd2_journal_wipe(journal_t *journal, int write)\n{\n\tint err;\n\n\tJ_ASSERT (!(journal->j_flags & JBD2_LOADED));\n\n\tif (!journal->j_tail)\n\t\treturn 0;\n\n\tprintk(KERN_WARNING \"JBD2: %s recovery information on journal\\n\",\n\t\twrite ? \"Clearing\" : \"Ignoring\");\n\n\terr = jbd2_journal_skip_recovery(journal);\n\tif (write) {\n\t\t \n\t\tmutex_lock_io(&journal->j_checkpoint_mutex);\n\t\tjbd2_mark_journal_empty(journal, REQ_FUA);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t}\n\n\treturn err;\n}\n\n \n\nvoid jbd2_journal_abort(journal_t *journal, int errno)\n{\n\ttransaction_t *transaction;\n\n\t \n\tmutex_lock(&journal->j_abort_mutex);\n\t \n\twrite_lock(&journal->j_state_lock);\n\tif (journal->j_flags & JBD2_ABORT) {\n\t\tint old_errno = journal->j_errno;\n\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tif (old_errno != -ESHUTDOWN && errno == -ESHUTDOWN) {\n\t\t\tjournal->j_errno = errno;\n\t\t\tjbd2_journal_update_sb_errno(journal);\n\t\t}\n\t\tmutex_unlock(&journal->j_abort_mutex);\n\t\treturn;\n\t}\n\n\t \n\tpr_err(\"Aborting journal on device %s.\\n\", journal->j_devname);\n\n\tjournal->j_flags |= JBD2_ABORT;\n\tjournal->j_errno = errno;\n\ttransaction = journal->j_running_transaction;\n\tif (transaction)\n\t\t__jbd2_log_start_commit(journal, transaction->t_tid);\n\twrite_unlock(&journal->j_state_lock);\n\n\t \n\tjbd2_journal_update_sb_errno(journal);\n\tmutex_unlock(&journal->j_abort_mutex);\n}\n\n \nint jbd2_journal_errno(journal_t *journal)\n{\n\tint err;\n\n\tread_lock(&journal->j_state_lock);\n\tif (journal->j_flags & JBD2_ABORT)\n\t\terr = -EROFS;\n\telse\n\t\terr = journal->j_errno;\n\tread_unlock(&journal->j_state_lock);\n\treturn err;\n}\n\n \nint jbd2_journal_clear_err(journal_t *journal)\n{\n\tint err = 0;\n\n\twrite_lock(&journal->j_state_lock);\n\tif (journal->j_flags & JBD2_ABORT)\n\t\terr = -EROFS;\n\telse\n\t\tjournal->j_errno = 0;\n\twrite_unlock(&journal->j_state_lock);\n\treturn err;\n}\n\n \nvoid jbd2_journal_ack_err(journal_t *journal)\n{\n\twrite_lock(&journal->j_state_lock);\n\tif (journal->j_errno)\n\t\tjournal->j_flags |= JBD2_ACK_ERR;\n\twrite_unlock(&journal->j_state_lock);\n}\n\nint jbd2_journal_blocks_per_page(struct inode *inode)\n{\n\treturn 1 << (PAGE_SHIFT - inode->i_sb->s_blocksize_bits);\n}\n\n \nsize_t journal_tag_bytes(journal_t *journal)\n{\n\tsize_t sz;\n\n\tif (jbd2_has_feature_csum3(journal))\n\t\treturn sizeof(journal_block_tag3_t);\n\n\tsz = sizeof(journal_block_tag_t);\n\n\tif (jbd2_has_feature_csum2(journal))\n\t\tsz += sizeof(__u16);\n\n\tif (jbd2_has_feature_64bit(journal))\n\t\treturn sz;\n\telse\n\t\treturn sz - sizeof(__u32);\n}\n\n \n#define JBD2_MAX_SLABS 8\nstatic struct kmem_cache *jbd2_slab[JBD2_MAX_SLABS];\n\nstatic const char *jbd2_slab_names[JBD2_MAX_SLABS] = {\n\t\"jbd2_1k\", \"jbd2_2k\", \"jbd2_4k\", \"jbd2_8k\",\n\t\"jbd2_16k\", \"jbd2_32k\", \"jbd2_64k\", \"jbd2_128k\"\n};\n\n\nstatic void jbd2_journal_destroy_slabs(void)\n{\n\tint i;\n\n\tfor (i = 0; i < JBD2_MAX_SLABS; i++) {\n\t\tkmem_cache_destroy(jbd2_slab[i]);\n\t\tjbd2_slab[i] = NULL;\n\t}\n}\n\nstatic int jbd2_journal_create_slab(size_t size)\n{\n\tstatic DEFINE_MUTEX(jbd2_slab_create_mutex);\n\tint i = order_base_2(size) - 10;\n\tsize_t slab_size;\n\n\tif (size == PAGE_SIZE)\n\t\treturn 0;\n\n\tif (i >= JBD2_MAX_SLABS)\n\t\treturn -EINVAL;\n\n\tif (unlikely(i < 0))\n\t\ti = 0;\n\tmutex_lock(&jbd2_slab_create_mutex);\n\tif (jbd2_slab[i]) {\n\t\tmutex_unlock(&jbd2_slab_create_mutex);\n\t\treturn 0;\t \n\t}\n\n\tslab_size = 1 << (i+10);\n\tjbd2_slab[i] = kmem_cache_create(jbd2_slab_names[i], slab_size,\n\t\t\t\t\t slab_size, 0, NULL);\n\tmutex_unlock(&jbd2_slab_create_mutex);\n\tif (!jbd2_slab[i]) {\n\t\tprintk(KERN_EMERG \"JBD2: no memory for jbd2_slab cache\\n\");\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nstatic struct kmem_cache *get_slab(size_t size)\n{\n\tint i = order_base_2(size) - 10;\n\n\tBUG_ON(i >= JBD2_MAX_SLABS);\n\tif (unlikely(i < 0))\n\t\ti = 0;\n\tBUG_ON(jbd2_slab[i] == NULL);\n\treturn jbd2_slab[i];\n}\n\nvoid *jbd2_alloc(size_t size, gfp_t flags)\n{\n\tvoid *ptr;\n\n\tBUG_ON(size & (size-1));  \n\n\tif (size < PAGE_SIZE)\n\t\tptr = kmem_cache_alloc(get_slab(size), flags);\n\telse\n\t\tptr = (void *)__get_free_pages(flags, get_order(size));\n\n\t \n\tBUG_ON(((unsigned long) ptr) & (size-1));\n\n\treturn ptr;\n}\n\nvoid jbd2_free(void *ptr, size_t size)\n{\n\tif (size < PAGE_SIZE)\n\t\tkmem_cache_free(get_slab(size), ptr);\n\telse\n\t\tfree_pages((unsigned long)ptr, get_order(size));\n};\n\n \nstatic struct kmem_cache *jbd2_journal_head_cache;\n#ifdef CONFIG_JBD2_DEBUG\nstatic atomic_t nr_journal_heads = ATOMIC_INIT(0);\n#endif\n\nstatic int __init jbd2_journal_init_journal_head_cache(void)\n{\n\tJ_ASSERT(!jbd2_journal_head_cache);\n\tjbd2_journal_head_cache = kmem_cache_create(\"jbd2_journal_head\",\n\t\t\t\tsizeof(struct journal_head),\n\t\t\t\t0,\t\t \n\t\t\t\tSLAB_TEMPORARY | SLAB_TYPESAFE_BY_RCU,\n\t\t\t\tNULL);\t\t \n\tif (!jbd2_journal_head_cache) {\n\t\tprintk(KERN_EMERG \"JBD2: no memory for journal_head cache\\n\");\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nstatic void jbd2_journal_destroy_journal_head_cache(void)\n{\n\tkmem_cache_destroy(jbd2_journal_head_cache);\n\tjbd2_journal_head_cache = NULL;\n}\n\n \nstatic struct journal_head *journal_alloc_journal_head(void)\n{\n\tstruct journal_head *ret;\n\n#ifdef CONFIG_JBD2_DEBUG\n\tatomic_inc(&nr_journal_heads);\n#endif\n\tret = kmem_cache_zalloc(jbd2_journal_head_cache, GFP_NOFS);\n\tif (!ret) {\n\t\tjbd2_debug(1, \"out of memory for journal_head\\n\");\n\t\tpr_notice_ratelimited(\"ENOMEM in %s, retrying.\\n\", __func__);\n\t\tret = kmem_cache_zalloc(jbd2_journal_head_cache,\n\t\t\t\tGFP_NOFS | __GFP_NOFAIL);\n\t}\n\tif (ret)\n\t\tspin_lock_init(&ret->b_state_lock);\n\treturn ret;\n}\n\nstatic void journal_free_journal_head(struct journal_head *jh)\n{\n#ifdef CONFIG_JBD2_DEBUG\n\tatomic_dec(&nr_journal_heads);\n\tmemset(jh, JBD2_POISON_FREE, sizeof(*jh));\n#endif\n\tkmem_cache_free(jbd2_journal_head_cache, jh);\n}\n\n \n\n \nstruct journal_head *jbd2_journal_add_journal_head(struct buffer_head *bh)\n{\n\tstruct journal_head *jh;\n\tstruct journal_head *new_jh = NULL;\n\nrepeat:\n\tif (!buffer_jbd(bh))\n\t\tnew_jh = journal_alloc_journal_head();\n\n\tjbd_lock_bh_journal_head(bh);\n\tif (buffer_jbd(bh)) {\n\t\tjh = bh2jh(bh);\n\t} else {\n\t\tJ_ASSERT_BH(bh,\n\t\t\t(atomic_read(&bh->b_count) > 0) ||\n\t\t\t(bh->b_folio && bh->b_folio->mapping));\n\n\t\tif (!new_jh) {\n\t\t\tjbd_unlock_bh_journal_head(bh);\n\t\t\tgoto repeat;\n\t\t}\n\n\t\tjh = new_jh;\n\t\tnew_jh = NULL;\t\t \n\t\tset_buffer_jbd(bh);\n\t\tbh->b_private = jh;\n\t\tjh->b_bh = bh;\n\t\tget_bh(bh);\n\t\tBUFFER_TRACE(bh, \"added journal_head\");\n\t}\n\tjh->b_jcount++;\n\tjbd_unlock_bh_journal_head(bh);\n\tif (new_jh)\n\t\tjournal_free_journal_head(new_jh);\n\treturn bh->b_private;\n}\n\n \nstruct journal_head *jbd2_journal_grab_journal_head(struct buffer_head *bh)\n{\n\tstruct journal_head *jh = NULL;\n\n\tjbd_lock_bh_journal_head(bh);\n\tif (buffer_jbd(bh)) {\n\t\tjh = bh2jh(bh);\n\t\tjh->b_jcount++;\n\t}\n\tjbd_unlock_bh_journal_head(bh);\n\treturn jh;\n}\nEXPORT_SYMBOL(jbd2_journal_grab_journal_head);\n\nstatic void __journal_remove_journal_head(struct buffer_head *bh)\n{\n\tstruct journal_head *jh = bh2jh(bh);\n\n\tJ_ASSERT_JH(jh, jh->b_transaction == NULL);\n\tJ_ASSERT_JH(jh, jh->b_next_transaction == NULL);\n\tJ_ASSERT_JH(jh, jh->b_cp_transaction == NULL);\n\tJ_ASSERT_JH(jh, jh->b_jlist == BJ_None);\n\tJ_ASSERT_BH(bh, buffer_jbd(bh));\n\tJ_ASSERT_BH(bh, jh2bh(jh) == bh);\n\tBUFFER_TRACE(bh, \"remove journal_head\");\n\n\t \n\tbh->b_private = NULL;\n\tjh->b_bh = NULL;\t \n\tclear_buffer_jbd(bh);\n}\n\nstatic void journal_release_journal_head(struct journal_head *jh, size_t b_size)\n{\n\tif (jh->b_frozen_data) {\n\t\tprintk(KERN_WARNING \"%s: freeing b_frozen_data\\n\", __func__);\n\t\tjbd2_free(jh->b_frozen_data, b_size);\n\t}\n\tif (jh->b_committed_data) {\n\t\tprintk(KERN_WARNING \"%s: freeing b_committed_data\\n\", __func__);\n\t\tjbd2_free(jh->b_committed_data, b_size);\n\t}\n\tjournal_free_journal_head(jh);\n}\n\n \nvoid jbd2_journal_put_journal_head(struct journal_head *jh)\n{\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tjbd_lock_bh_journal_head(bh);\n\tJ_ASSERT_JH(jh, jh->b_jcount > 0);\n\t--jh->b_jcount;\n\tif (!jh->b_jcount) {\n\t\t__journal_remove_journal_head(bh);\n\t\tjbd_unlock_bh_journal_head(bh);\n\t\tjournal_release_journal_head(jh, bh->b_size);\n\t\t__brelse(bh);\n\t} else {\n\t\tjbd_unlock_bh_journal_head(bh);\n\t}\n}\nEXPORT_SYMBOL(jbd2_journal_put_journal_head);\n\n \nvoid jbd2_journal_init_jbd_inode(struct jbd2_inode *jinode, struct inode *inode)\n{\n\tjinode->i_transaction = NULL;\n\tjinode->i_next_transaction = NULL;\n\tjinode->i_vfs_inode = inode;\n\tjinode->i_flags = 0;\n\tjinode->i_dirty_start = 0;\n\tjinode->i_dirty_end = 0;\n\tINIT_LIST_HEAD(&jinode->i_list);\n}\n\n \nvoid jbd2_journal_release_jbd_inode(journal_t *journal,\n\t\t\t\t    struct jbd2_inode *jinode)\n{\n\tif (!journal)\n\t\treturn;\nrestart:\n\tspin_lock(&journal->j_list_lock);\n\t \n\tif (jinode->i_flags & JI_COMMIT_RUNNING) {\n\t\twait_queue_head_t *wq;\n\t\tDEFINE_WAIT_BIT(wait, &jinode->i_flags, __JI_COMMIT_RUNNING);\n\t\twq = bit_waitqueue(&jinode->i_flags, __JI_COMMIT_RUNNING);\n\t\tprepare_to_wait(wq, &wait.wq_entry, TASK_UNINTERRUPTIBLE);\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tschedule();\n\t\tfinish_wait(wq, &wait.wq_entry);\n\t\tgoto restart;\n\t}\n\n\tif (jinode->i_transaction) {\n\t\tlist_del(&jinode->i_list);\n\t\tjinode->i_transaction = NULL;\n\t}\n\tspin_unlock(&journal->j_list_lock);\n}\n\n\n#ifdef CONFIG_PROC_FS\n\n#define JBD2_STATS_PROC_NAME \"fs/jbd2\"\n\nstatic void __init jbd2_create_jbd_stats_proc_entry(void)\n{\n\tproc_jbd2_stats = proc_mkdir(JBD2_STATS_PROC_NAME, NULL);\n}\n\nstatic void __exit jbd2_remove_jbd_stats_proc_entry(void)\n{\n\tif (proc_jbd2_stats)\n\t\tremove_proc_entry(JBD2_STATS_PROC_NAME, NULL);\n}\n\n#else\n\n#define jbd2_create_jbd_stats_proc_entry() do {} while (0)\n#define jbd2_remove_jbd_stats_proc_entry() do {} while (0)\n\n#endif\n\nstruct kmem_cache *jbd2_handle_cache, *jbd2_inode_cache;\n\nstatic int __init jbd2_journal_init_inode_cache(void)\n{\n\tJ_ASSERT(!jbd2_inode_cache);\n\tjbd2_inode_cache = KMEM_CACHE(jbd2_inode, 0);\n\tif (!jbd2_inode_cache) {\n\t\tpr_emerg(\"JBD2: failed to create inode cache\\n\");\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nstatic int __init jbd2_journal_init_handle_cache(void)\n{\n\tJ_ASSERT(!jbd2_handle_cache);\n\tjbd2_handle_cache = KMEM_CACHE(jbd2_journal_handle, SLAB_TEMPORARY);\n\tif (!jbd2_handle_cache) {\n\t\tprintk(KERN_EMERG \"JBD2: failed to create handle cache\\n\");\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nstatic void jbd2_journal_destroy_inode_cache(void)\n{\n\tkmem_cache_destroy(jbd2_inode_cache);\n\tjbd2_inode_cache = NULL;\n}\n\nstatic void jbd2_journal_destroy_handle_cache(void)\n{\n\tkmem_cache_destroy(jbd2_handle_cache);\n\tjbd2_handle_cache = NULL;\n}\n\n \n\nstatic int __init journal_init_caches(void)\n{\n\tint ret;\n\n\tret = jbd2_journal_init_revoke_record_cache();\n\tif (ret == 0)\n\t\tret = jbd2_journal_init_revoke_table_cache();\n\tif (ret == 0)\n\t\tret = jbd2_journal_init_journal_head_cache();\n\tif (ret == 0)\n\t\tret = jbd2_journal_init_handle_cache();\n\tif (ret == 0)\n\t\tret = jbd2_journal_init_inode_cache();\n\tif (ret == 0)\n\t\tret = jbd2_journal_init_transaction_cache();\n\treturn ret;\n}\n\nstatic void jbd2_journal_destroy_caches(void)\n{\n\tjbd2_journal_destroy_revoke_record_cache();\n\tjbd2_journal_destroy_revoke_table_cache();\n\tjbd2_journal_destroy_journal_head_cache();\n\tjbd2_journal_destroy_handle_cache();\n\tjbd2_journal_destroy_inode_cache();\n\tjbd2_journal_destroy_transaction_cache();\n\tjbd2_journal_destroy_slabs();\n}\n\nstatic int __init journal_init(void)\n{\n\tint ret;\n\n\tBUILD_BUG_ON(sizeof(struct journal_superblock_s) != 1024);\n\n\tret = journal_init_caches();\n\tif (ret == 0) {\n\t\tjbd2_create_jbd_stats_proc_entry();\n\t} else {\n\t\tjbd2_journal_destroy_caches();\n\t}\n\treturn ret;\n}\n\nstatic void __exit journal_exit(void)\n{\n#ifdef CONFIG_JBD2_DEBUG\n\tint n = atomic_read(&nr_journal_heads);\n\tif (n)\n\t\tprintk(KERN_ERR \"JBD2: leaked %d journal_heads!\\n\", n);\n#endif\n\tjbd2_remove_jbd_stats_proc_entry();\n\tjbd2_journal_destroy_caches();\n}\n\nMODULE_LICENSE(\"GPL\");\nmodule_init(journal_init);\nmodule_exit(journal_exit);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}