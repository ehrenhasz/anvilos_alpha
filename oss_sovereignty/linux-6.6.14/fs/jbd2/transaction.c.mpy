{
  "module_name": "transaction.c",
  "hash_id": "cd9665f4b5619425b7d3c7697851e8a344bd74cc87e0e292f6cd7052d12d4432",
  "original_prompt": "Ingested from linux-6.6.14/fs/jbd2/transaction.c",
  "human_readable_source": "\n \n\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/jbd2.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/hrtimer.h>\n#include <linux/backing-dev.h>\n#include <linux/bug.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n\n#include <trace/events/jbd2.h>\n\nstatic void __jbd2_journal_temp_unlink_buffer(struct journal_head *jh);\nstatic void __jbd2_journal_unfile_buffer(struct journal_head *jh);\n\nstatic struct kmem_cache *transaction_cache;\nint __init jbd2_journal_init_transaction_cache(void)\n{\n\tJ_ASSERT(!transaction_cache);\n\ttransaction_cache = kmem_cache_create(\"jbd2_transaction_s\",\n\t\t\t\t\tsizeof(transaction_t),\n\t\t\t\t\t0,\n\t\t\t\t\tSLAB_HWCACHE_ALIGN|SLAB_TEMPORARY,\n\t\t\t\t\tNULL);\n\tif (!transaction_cache) {\n\t\tpr_emerg(\"JBD2: failed to create transaction cache\\n\");\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nvoid jbd2_journal_destroy_transaction_cache(void)\n{\n\tkmem_cache_destroy(transaction_cache);\n\ttransaction_cache = NULL;\n}\n\nvoid jbd2_journal_free_transaction(transaction_t *transaction)\n{\n\tif (unlikely(ZERO_OR_NULL_PTR(transaction)))\n\t\treturn;\n\tkmem_cache_free(transaction_cache, transaction);\n}\n\n \nstatic int jbd2_descriptor_blocks_per_trans(journal_t *journal)\n{\n\tint tag_space = journal->j_blocksize - sizeof(journal_header_t);\n\tint tags_per_block;\n\n\t \n\ttag_space -= 16;\n\tif (jbd2_journal_has_csum_v2or3(journal))\n\t\ttag_space -= sizeof(struct jbd2_journal_block_tail);\n\t \n\ttags_per_block = (tag_space - 16) / journal_tag_bytes(journal);\n\t \n\treturn 1 + DIV_ROUND_UP(journal->j_max_transaction_buffers,\n\t\t\t\ttags_per_block);\n}\n\n \n\nstatic void jbd2_get_transaction(journal_t *journal,\n\t\t\t\ttransaction_t *transaction)\n{\n\ttransaction->t_journal = journal;\n\ttransaction->t_state = T_RUNNING;\n\ttransaction->t_start_time = ktime_get();\n\ttransaction->t_tid = journal->j_transaction_sequence++;\n\ttransaction->t_expires = jiffies + journal->j_commit_interval;\n\tatomic_set(&transaction->t_updates, 0);\n\tatomic_set(&transaction->t_outstanding_credits,\n\t\t   jbd2_descriptor_blocks_per_trans(journal) +\n\t\t   atomic_read(&journal->j_reserved_credits));\n\tatomic_set(&transaction->t_outstanding_revokes, 0);\n\tatomic_set(&transaction->t_handle_count, 0);\n\tINIT_LIST_HEAD(&transaction->t_inode_list);\n\tINIT_LIST_HEAD(&transaction->t_private_list);\n\n\t \n\tjournal->j_commit_timer.expires = round_jiffies_up(transaction->t_expires);\n\tadd_timer(&journal->j_commit_timer);\n\n\tJ_ASSERT(journal->j_running_transaction == NULL);\n\tjournal->j_running_transaction = transaction;\n\ttransaction->t_max_wait = 0;\n\ttransaction->t_start = jiffies;\n\ttransaction->t_requested = 0;\n}\n\n \n\n \nstatic inline void update_t_max_wait(transaction_t *transaction,\n\t\t\t\t     unsigned long ts)\n{\n\tunsigned long oldts, newts;\n\n\tif (time_after(transaction->t_start, ts)) {\n\t\tnewts = jbd2_time_diff(ts, transaction->t_start);\n\t\toldts = READ_ONCE(transaction->t_max_wait);\n\t\twhile (oldts < newts)\n\t\t\toldts = cmpxchg(&transaction->t_max_wait, oldts, newts);\n\t}\n}\n\n \nstatic void wait_transaction_locked(journal_t *journal)\n\t__releases(journal->j_state_lock)\n{\n\tDEFINE_WAIT(wait);\n\tint need_to_start;\n\ttid_t tid = journal->j_running_transaction->t_tid;\n\n\tprepare_to_wait_exclusive(&journal->j_wait_transaction_locked, &wait,\n\t\t\tTASK_UNINTERRUPTIBLE);\n\tneed_to_start = !tid_geq(journal->j_commit_request, tid);\n\tread_unlock(&journal->j_state_lock);\n\tif (need_to_start)\n\t\tjbd2_log_start_commit(journal, tid);\n\tjbd2_might_wait_for_commit(journal);\n\tschedule();\n\tfinish_wait(&journal->j_wait_transaction_locked, &wait);\n}\n\n \nstatic void wait_transaction_switching(journal_t *journal)\n\t__releases(journal->j_state_lock)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (WARN_ON(!journal->j_running_transaction ||\n\t\t    journal->j_running_transaction->t_state != T_SWITCH)) {\n\t\tread_unlock(&journal->j_state_lock);\n\t\treturn;\n\t}\n\tprepare_to_wait_exclusive(&journal->j_wait_transaction_locked, &wait,\n\t\t\tTASK_UNINTERRUPTIBLE);\n\tread_unlock(&journal->j_state_lock);\n\t \n\tschedule();\n\tfinish_wait(&journal->j_wait_transaction_locked, &wait);\n}\n\nstatic void sub_reserved_credits(journal_t *journal, int blocks)\n{\n\tatomic_sub(blocks, &journal->j_reserved_credits);\n\twake_up(&journal->j_wait_reserved);\n}\n\n \nstatic int add_transaction_credits(journal_t *journal, int blocks,\n\t\t\t\t   int rsv_blocks)\n__must_hold(&journal->j_state_lock)\n{\n\ttransaction_t *t = journal->j_running_transaction;\n\tint needed;\n\tint total = blocks + rsv_blocks;\n\n\t \n\tif (t->t_state != T_RUNNING) {\n\t\tWARN_ON_ONCE(t->t_state >= T_FLUSH);\n\t\twait_transaction_locked(journal);\n\t\t__acquire(&journal->j_state_lock);  \n\t\treturn 1;\n\t}\n\n\t \n\tneeded = atomic_add_return(total, &t->t_outstanding_credits);\n\tif (needed > journal->j_max_transaction_buffers) {\n\t\t \n\t\tatomic_sub(total, &t->t_outstanding_credits);\n\n\t\t \n\t\tif (atomic_read(&journal->j_reserved_credits) + total >\n\t\t    journal->j_max_transaction_buffers) {\n\t\t\tread_unlock(&journal->j_state_lock);\n\t\t\tjbd2_might_wait_for_commit(journal);\n\t\t\twait_event(journal->j_wait_reserved,\n\t\t\t\t   atomic_read(&journal->j_reserved_credits) + total <=\n\t\t\t\t   journal->j_max_transaction_buffers);\n\t\t\t__acquire(&journal->j_state_lock);  \n\t\t\treturn 1;\n\t\t}\n\n\t\twait_transaction_locked(journal);\n\t\t__acquire(&journal->j_state_lock);  \n\t\treturn 1;\n\t}\n\n\t \n\tif (jbd2_log_space_left(journal) < journal->j_max_transaction_buffers) {\n\t\tatomic_sub(total, &t->t_outstanding_credits);\n\t\tread_unlock(&journal->j_state_lock);\n\t\tjbd2_might_wait_for_commit(journal);\n\t\twrite_lock(&journal->j_state_lock);\n\t\tif (jbd2_log_space_left(journal) <\n\t\t\t\t\tjournal->j_max_transaction_buffers)\n\t\t\t__jbd2_log_wait_for_space(journal);\n\t\twrite_unlock(&journal->j_state_lock);\n\t\t__acquire(&journal->j_state_lock);  \n\t\treturn 1;\n\t}\n\n\t \n\tif (!rsv_blocks)\n\t\treturn 0;\n\n\tneeded = atomic_add_return(rsv_blocks, &journal->j_reserved_credits);\n\t \n\tif (needed > journal->j_max_transaction_buffers / 2) {\n\t\tsub_reserved_credits(journal, rsv_blocks);\n\t\tatomic_sub(total, &t->t_outstanding_credits);\n\t\tread_unlock(&journal->j_state_lock);\n\t\tjbd2_might_wait_for_commit(journal);\n\t\twait_event(journal->j_wait_reserved,\n\t\t\t atomic_read(&journal->j_reserved_credits) + rsv_blocks\n\t\t\t <= journal->j_max_transaction_buffers / 2);\n\t\t__acquire(&journal->j_state_lock);  \n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \n\nstatic int start_this_handle(journal_t *journal, handle_t *handle,\n\t\t\t     gfp_t gfp_mask)\n{\n\ttransaction_t\t*transaction, *new_transaction = NULL;\n\tint\t\tblocks = handle->h_total_credits;\n\tint\t\trsv_blocks = 0;\n\tunsigned long ts = jiffies;\n\n\tif (handle->h_rsv_handle)\n\t\trsv_blocks = handle->h_rsv_handle->h_total_credits;\n\n\t \n\tif ((rsv_blocks > journal->j_max_transaction_buffers / 2) ||\n\t    (rsv_blocks + blocks > journal->j_max_transaction_buffers)) {\n\t\tprintk(KERN_ERR \"JBD2: %s wants too many credits \"\n\t\t       \"credits:%d rsv_credits:%d max:%d\\n\",\n\t\t       current->comm, blocks, rsv_blocks,\n\t\t       journal->j_max_transaction_buffers);\n\t\tWARN_ON(1);\n\t\treturn -ENOSPC;\n\t}\n\nalloc_transaction:\n\t \n\tif (!data_race(journal->j_running_transaction)) {\n\t\t \n\t\tif ((gfp_mask & __GFP_FS) == 0)\n\t\t\tgfp_mask |= __GFP_NOFAIL;\n\t\tnew_transaction = kmem_cache_zalloc(transaction_cache,\n\t\t\t\t\t\t    gfp_mask);\n\t\tif (!new_transaction)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tjbd2_debug(3, \"New handle %p going live.\\n\", handle);\n\n\t \nrepeat:\n\tread_lock(&journal->j_state_lock);\n\tBUG_ON(journal->j_flags & JBD2_UNMOUNT);\n\tif (is_journal_aborted(journal) ||\n\t    (journal->j_errno != 0 && !(journal->j_flags & JBD2_ACK_ERR))) {\n\t\tread_unlock(&journal->j_state_lock);\n\t\tjbd2_journal_free_transaction(new_transaction);\n\t\treturn -EROFS;\n\t}\n\n\t \n\tif (!handle->h_reserved && journal->j_barrier_count) {\n\t\tread_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_transaction_locked,\n\t\t\t\tjournal->j_barrier_count == 0);\n\t\tgoto repeat;\n\t}\n\n\tif (!journal->j_running_transaction) {\n\t\tread_unlock(&journal->j_state_lock);\n\t\tif (!new_transaction)\n\t\t\tgoto alloc_transaction;\n\t\twrite_lock(&journal->j_state_lock);\n\t\tif (!journal->j_running_transaction &&\n\t\t    (handle->h_reserved || !journal->j_barrier_count)) {\n\t\t\tjbd2_get_transaction(journal, new_transaction);\n\t\t\tnew_transaction = NULL;\n\t\t}\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tgoto repeat;\n\t}\n\n\ttransaction = journal->j_running_transaction;\n\n\tif (!handle->h_reserved) {\n\t\t \n\t\tif (add_transaction_credits(journal, blocks, rsv_blocks)) {\n\t\t\t \n\t\t\t__release(&journal->j_state_lock);\n\t\t\tgoto repeat;\n\t\t}\n\t} else {\n\t\t \n\t\tif (transaction->t_state == T_SWITCH) {\n\t\t\twait_transaction_switching(journal);\n\t\t\tgoto repeat;\n\t\t}\n\t\tsub_reserved_credits(journal, blocks);\n\t\thandle->h_reserved = 0;\n\t}\n\n\t \n\tupdate_t_max_wait(transaction, ts);\n\thandle->h_transaction = transaction;\n\thandle->h_requested_credits = blocks;\n\thandle->h_revoke_credits_requested = handle->h_revoke_credits;\n\thandle->h_start_jiffies = jiffies;\n\tatomic_inc(&transaction->t_updates);\n\tatomic_inc(&transaction->t_handle_count);\n\tjbd2_debug(4, \"Handle %p given %d credits (total %d, free %lu)\\n\",\n\t\t  handle, blocks,\n\t\t  atomic_read(&transaction->t_outstanding_credits),\n\t\t  jbd2_log_space_left(journal));\n\tread_unlock(&journal->j_state_lock);\n\tcurrent->journal_info = handle;\n\n\trwsem_acquire_read(&journal->j_trans_commit_map, 0, 0, _THIS_IP_);\n\tjbd2_journal_free_transaction(new_transaction);\n\t \n\thandle->saved_alloc_context = memalloc_nofs_save();\n\treturn 0;\n}\n\n \nstatic handle_t *new_handle(int nblocks)\n{\n\thandle_t *handle = jbd2_alloc_handle(GFP_NOFS);\n\tif (!handle)\n\t\treturn NULL;\n\thandle->h_total_credits = nblocks;\n\thandle->h_ref = 1;\n\n\treturn handle;\n}\n\nhandle_t *jbd2__journal_start(journal_t *journal, int nblocks, int rsv_blocks,\n\t\t\t      int revoke_records, gfp_t gfp_mask,\n\t\t\t      unsigned int type, unsigned int line_no)\n{\n\thandle_t *handle = journal_current_handle();\n\tint err;\n\n\tif (!journal)\n\t\treturn ERR_PTR(-EROFS);\n\n\tif (handle) {\n\t\tJ_ASSERT(handle->h_transaction->t_journal == journal);\n\t\thandle->h_ref++;\n\t\treturn handle;\n\t}\n\n\tnblocks += DIV_ROUND_UP(revoke_records,\n\t\t\t\tjournal->j_revoke_records_per_block);\n\thandle = new_handle(nblocks);\n\tif (!handle)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (rsv_blocks) {\n\t\thandle_t *rsv_handle;\n\n\t\trsv_handle = new_handle(rsv_blocks);\n\t\tif (!rsv_handle) {\n\t\t\tjbd2_free_handle(handle);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t\trsv_handle->h_reserved = 1;\n\t\trsv_handle->h_journal = journal;\n\t\thandle->h_rsv_handle = rsv_handle;\n\t}\n\thandle->h_revoke_credits = revoke_records;\n\n\terr = start_this_handle(journal, handle, gfp_mask);\n\tif (err < 0) {\n\t\tif (handle->h_rsv_handle)\n\t\t\tjbd2_free_handle(handle->h_rsv_handle);\n\t\tjbd2_free_handle(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\thandle->h_type = type;\n\thandle->h_line_no = line_no;\n\ttrace_jbd2_handle_start(journal->j_fs_dev->bd_dev,\n\t\t\t\thandle->h_transaction->t_tid, type,\n\t\t\t\tline_no, nblocks);\n\n\treturn handle;\n}\nEXPORT_SYMBOL(jbd2__journal_start);\n\n\n \nhandle_t *jbd2_journal_start(journal_t *journal, int nblocks)\n{\n\treturn jbd2__journal_start(journal, nblocks, 0, 0, GFP_NOFS, 0, 0);\n}\nEXPORT_SYMBOL(jbd2_journal_start);\n\nstatic void __jbd2_journal_unreserve_handle(handle_t *handle, transaction_t *t)\n{\n\tjournal_t *journal = handle->h_journal;\n\n\tWARN_ON(!handle->h_reserved);\n\tsub_reserved_credits(journal, handle->h_total_credits);\n\tif (t)\n\t\tatomic_sub(handle->h_total_credits, &t->t_outstanding_credits);\n}\n\nvoid jbd2_journal_free_reserved(handle_t *handle)\n{\n\tjournal_t *journal = handle->h_journal;\n\n\t \n\tread_lock(&journal->j_state_lock);\n\t__jbd2_journal_unreserve_handle(handle, journal->j_running_transaction);\n\tread_unlock(&journal->j_state_lock);\n\tjbd2_free_handle(handle);\n}\nEXPORT_SYMBOL(jbd2_journal_free_reserved);\n\n \nint jbd2_journal_start_reserved(handle_t *handle, unsigned int type,\n\t\t\t\tunsigned int line_no)\n{\n\tjournal_t *journal = handle->h_journal;\n\tint ret = -EIO;\n\n\tif (WARN_ON(!handle->h_reserved)) {\n\t\t \n\t\tjbd2_journal_stop(handle);\n\t\treturn ret;\n\t}\n\t \n\tif (WARN_ON(current->journal_info)) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ret;\n\t}\n\n\thandle->h_journal = NULL;\n\t \n\tret = start_this_handle(journal, handle, GFP_NOFS);\n\tif (ret < 0) {\n\t\thandle->h_journal = journal;\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ret;\n\t}\n\thandle->h_type = type;\n\thandle->h_line_no = line_no;\n\ttrace_jbd2_handle_start(journal->j_fs_dev->bd_dev,\n\t\t\t\thandle->h_transaction->t_tid, type,\n\t\t\t\tline_no, handle->h_total_credits);\n\treturn 0;\n}\nEXPORT_SYMBOL(jbd2_journal_start_reserved);\n\n \nint jbd2_journal_extend(handle_t *handle, int nblocks, int revoke_records)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal;\n\tint result;\n\tint wanted;\n\n\tif (is_handle_aborted(handle))\n\t\treturn -EROFS;\n\tjournal = transaction->t_journal;\n\n\tresult = 1;\n\n\tread_lock(&journal->j_state_lock);\n\n\t \n\tif (transaction->t_state != T_RUNNING) {\n\t\tjbd2_debug(3, \"denied handle %p %d blocks: \"\n\t\t\t  \"transaction not running\\n\", handle, nblocks);\n\t\tgoto error_out;\n\t}\n\n\tnblocks += DIV_ROUND_UP(\n\t\t\thandle->h_revoke_credits_requested + revoke_records,\n\t\t\tjournal->j_revoke_records_per_block) -\n\t\tDIV_ROUND_UP(\n\t\t\thandle->h_revoke_credits_requested,\n\t\t\tjournal->j_revoke_records_per_block);\n\twanted = atomic_add_return(nblocks,\n\t\t\t\t   &transaction->t_outstanding_credits);\n\n\tif (wanted > journal->j_max_transaction_buffers) {\n\t\tjbd2_debug(3, \"denied handle %p %d blocks: \"\n\t\t\t  \"transaction too large\\n\", handle, nblocks);\n\t\tatomic_sub(nblocks, &transaction->t_outstanding_credits);\n\t\tgoto error_out;\n\t}\n\n\ttrace_jbd2_handle_extend(journal->j_fs_dev->bd_dev,\n\t\t\t\t transaction->t_tid,\n\t\t\t\t handle->h_type, handle->h_line_no,\n\t\t\t\t handle->h_total_credits,\n\t\t\t\t nblocks);\n\n\thandle->h_total_credits += nblocks;\n\thandle->h_requested_credits += nblocks;\n\thandle->h_revoke_credits += revoke_records;\n\thandle->h_revoke_credits_requested += revoke_records;\n\tresult = 0;\n\n\tjbd2_debug(3, \"extended handle %p by %d\\n\", handle, nblocks);\nerror_out:\n\tread_unlock(&journal->j_state_lock);\n\treturn result;\n}\n\nstatic void stop_this_handle(handle_t *handle)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal = transaction->t_journal;\n\tint revokes;\n\n\tJ_ASSERT(journal_current_handle() == handle);\n\tJ_ASSERT(atomic_read(&transaction->t_updates) > 0);\n\tcurrent->journal_info = NULL;\n\t \n\trevokes = handle->h_revoke_credits_requested - handle->h_revoke_credits;\n\tif (revokes) {\n\t\tint t_revokes, revoke_descriptors;\n\t\tint rr_per_blk = journal->j_revoke_records_per_block;\n\n\t\tWARN_ON_ONCE(DIV_ROUND_UP(revokes, rr_per_blk)\n\t\t\t\t> handle->h_total_credits);\n\t\tt_revokes = atomic_add_return(revokes,\n\t\t\t\t&transaction->t_outstanding_revokes);\n\t\trevoke_descriptors =\n\t\t\tDIV_ROUND_UP(t_revokes, rr_per_blk) -\n\t\t\tDIV_ROUND_UP(t_revokes - revokes, rr_per_blk);\n\t\thandle->h_total_credits -= revoke_descriptors;\n\t}\n\tatomic_sub(handle->h_total_credits,\n\t\t   &transaction->t_outstanding_credits);\n\tif (handle->h_rsv_handle)\n\t\t__jbd2_journal_unreserve_handle(handle->h_rsv_handle,\n\t\t\t\t\t\ttransaction);\n\tif (atomic_dec_and_test(&transaction->t_updates))\n\t\twake_up(&journal->j_wait_updates);\n\n\trwsem_release(&journal->j_trans_commit_map, _THIS_IP_);\n\t \n\tmemalloc_nofs_restore(handle->saved_alloc_context);\n}\n\n \nint jbd2__journal_restart(handle_t *handle, int nblocks, int revoke_records,\n\t\t\t  gfp_t gfp_mask)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal;\n\ttid_t\t\ttid;\n\tint\t\tneed_to_start;\n\tint\t\tret;\n\n\t \n\tif (is_handle_aborted(handle))\n\t\treturn 0;\n\tjournal = transaction->t_journal;\n\ttid = transaction->t_tid;\n\n\t \n\tjbd2_debug(2, \"restarting handle %p\\n\", handle);\n\tstop_this_handle(handle);\n\thandle->h_transaction = NULL;\n\n\t \n\tread_lock(&journal->j_state_lock);\n\tneed_to_start = !tid_geq(journal->j_commit_request, tid);\n\tread_unlock(&journal->j_state_lock);\n\tif (need_to_start)\n\t\tjbd2_log_start_commit(journal, tid);\n\thandle->h_total_credits = nblocks +\n\t\tDIV_ROUND_UP(revoke_records,\n\t\t\t     journal->j_revoke_records_per_block);\n\thandle->h_revoke_credits = revoke_records;\n\tret = start_this_handle(journal, handle, gfp_mask);\n\ttrace_jbd2_handle_restart(journal->j_fs_dev->bd_dev,\n\t\t\t\t ret ? 0 : handle->h_transaction->t_tid,\n\t\t\t\t handle->h_type, handle->h_line_no,\n\t\t\t\t handle->h_total_credits);\n\treturn ret;\n}\nEXPORT_SYMBOL(jbd2__journal_restart);\n\n\nint jbd2_journal_restart(handle_t *handle, int nblocks)\n{\n\treturn jbd2__journal_restart(handle, nblocks, 0, GFP_NOFS);\n}\nEXPORT_SYMBOL(jbd2_journal_restart);\n\n \nvoid jbd2_journal_wait_updates(journal_t *journal)\n{\n\tDEFINE_WAIT(wait);\n\n\twhile (1) {\n\t\t \n\t\ttransaction_t *transaction = journal->j_running_transaction;\n\n\t\tif (!transaction)\n\t\t\tbreak;\n\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!atomic_read(&transaction->t_updates)) {\n\t\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\t\tbreak;\n\t\t}\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tschedule();\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n}\n\n \nvoid jbd2_journal_lock_updates(journal_t *journal)\n{\n\tjbd2_might_wait_for_commit(journal);\n\n\twrite_lock(&journal->j_state_lock);\n\t++journal->j_barrier_count;\n\n\t \n\tif (atomic_read(&journal->j_reserved_credits)) {\n\t\twrite_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_reserved,\n\t\t\t   atomic_read(&journal->j_reserved_credits) == 0);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n\n\t \n\tjbd2_journal_wait_updates(journal);\n\n\twrite_unlock(&journal->j_state_lock);\n\n\t \n\tmutex_lock(&journal->j_barrier);\n}\n\n \nvoid jbd2_journal_unlock_updates (journal_t *journal)\n{\n\tJ_ASSERT(journal->j_barrier_count != 0);\n\n\tmutex_unlock(&journal->j_barrier);\n\twrite_lock(&journal->j_state_lock);\n\t--journal->j_barrier_count;\n\twrite_unlock(&journal->j_state_lock);\n\twake_up_all(&journal->j_wait_transaction_locked);\n}\n\nstatic void warn_dirty_buffer(struct buffer_head *bh)\n{\n\tprintk(KERN_WARNING\n\t       \"JBD2: Spotted dirty metadata buffer (dev = %pg, blocknr = %llu). \"\n\t       \"There's a risk of filesystem corruption in case of system \"\n\t       \"crash.\\n\",\n\t       bh->b_bdev, (unsigned long long)bh->b_blocknr);\n}\n\n \nstatic void jbd2_freeze_jh_data(struct journal_head *jh)\n{\n\tchar *source;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tJ_EXPECT_JH(jh, buffer_uptodate(bh), \"Possible IO failure.\\n\");\n\tsource = kmap_local_folio(bh->b_folio, bh_offset(bh));\n\t \n\tjbd2_buffer_frozen_trigger(jh, source, jh->b_triggers);\n\tmemcpy(jh->b_frozen_data, source, bh->b_size);\n\tkunmap_local(source);\n\n\t \n\tjh->b_frozen_triggers = jh->b_triggers;\n}\n\n \nstatic int\ndo_get_write_access(handle_t *handle, struct journal_head *jh,\n\t\t\tint force_copy)\n{\n\tstruct buffer_head *bh;\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal;\n\tint error;\n\tchar *frozen_buffer = NULL;\n\tunsigned long start_lock, time_lock;\n\n\tjournal = transaction->t_journal;\n\n\tjbd2_debug(5, \"journal_head %p, force_copy %d\\n\", jh, force_copy);\n\n\tJBUFFER_TRACE(jh, \"entry\");\nrepeat:\n\tbh = jh2bh(jh);\n\n\t \n\n \tstart_lock = jiffies;\n\tlock_buffer(bh);\n\tspin_lock(&jh->b_state_lock);\n\n\t \n\ttime_lock = jbd2_time_diff(start_lock, jiffies);\n\tif (time_lock > HZ/10)\n\t\ttrace_jbd2_lock_buffer_stall(bh->b_bdev->bd_dev,\n\t\t\tjiffies_to_msecs(time_lock));\n\n\t \n\n\tif (buffer_dirty(bh) && jh->b_transaction) {\n\t\twarn_dirty_buffer(bh);\n\t\t \n\t\tJBUFFER_TRACE(jh, \"Journalling dirty buffer\");\n\t\tclear_buffer_dirty(bh);\n\t\t \n\t\tset_buffer_jbddirty(bh);\n\t}\n\n\terror = -EROFS;\n\tif (is_handle_aborted(handle)) {\n\t\tspin_unlock(&jh->b_state_lock);\n\t\tunlock_buffer(bh);\n\t\tgoto out;\n\t}\n\terror = 0;\n\n\t \n\tif (jh->b_transaction == transaction ||\n\t    jh->b_next_transaction == transaction) {\n\t\tunlock_buffer(bh);\n\t\tgoto done;\n\t}\n\n\t \n\tjh->b_modified = 0;\n\n\t \n\tif (!jh->b_transaction) {\n\t\tJBUFFER_TRACE(jh, \"no transaction\");\n\t\tJ_ASSERT_JH(jh, !jh->b_next_transaction);\n\t\tJBUFFER_TRACE(jh, \"file as BJ_Reserved\");\n\t\t \n\t\tsmp_wmb();\n\t\tspin_lock(&journal->j_list_lock);\n\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t \n\t\t\tJBUFFER_TRACE(jh, \"Journalling dirty buffer\");\n\t\t\tset_buffer_jbddirty(bh);\n\t\t}\n\t\t__jbd2_journal_file_buffer(jh, transaction, BJ_Reserved);\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tunlock_buffer(bh);\n\t\tgoto done;\n\t}\n\tunlock_buffer(bh);\n\n\t \n\tif (jh->b_frozen_data) {\n\t\tJBUFFER_TRACE(jh, \"has frozen data\");\n\t\tJ_ASSERT_JH(jh, jh->b_next_transaction == NULL);\n\t\tgoto attach_next;\n\t}\n\n\tJBUFFER_TRACE(jh, \"owned by older transaction\");\n\tJ_ASSERT_JH(jh, jh->b_next_transaction == NULL);\n\tJ_ASSERT_JH(jh, jh->b_transaction == journal->j_committing_transaction);\n\n\t \n\tif (buffer_shadow(bh)) {\n\t\tJBUFFER_TRACE(jh, \"on shadow: sleep\");\n\t\tspin_unlock(&jh->b_state_lock);\n\t\twait_on_bit_io(&bh->b_state, BH_Shadow, TASK_UNINTERRUPTIBLE);\n\t\tgoto repeat;\n\t}\n\n\t \n\tif (jh->b_jlist == BJ_Metadata || force_copy) {\n\t\tJBUFFER_TRACE(jh, \"generate frozen data\");\n\t\tif (!frozen_buffer) {\n\t\t\tJBUFFER_TRACE(jh, \"allocate memory for buffer\");\n\t\t\tspin_unlock(&jh->b_state_lock);\n\t\t\tfrozen_buffer = jbd2_alloc(jh2bh(jh)->b_size,\n\t\t\t\t\t\t   GFP_NOFS | __GFP_NOFAIL);\n\t\t\tgoto repeat;\n\t\t}\n\t\tjh->b_frozen_data = frozen_buffer;\n\t\tfrozen_buffer = NULL;\n\t\tjbd2_freeze_jh_data(jh);\n\t}\nattach_next:\n\t \n\tsmp_wmb();\n\tjh->b_next_transaction = transaction;\n\ndone:\n\tspin_unlock(&jh->b_state_lock);\n\n\t \n\tjbd2_journal_cancel_revoke(handle, jh);\n\nout:\n\tif (unlikely(frozen_buffer))\t \n\t\tjbd2_free(frozen_buffer, bh->b_size);\n\n\tJBUFFER_TRACE(jh, \"exit\");\n\treturn error;\n}\n\n \nstatic bool jbd2_write_access_granted(handle_t *handle, struct buffer_head *bh,\n\t\t\t\t\t\t\tbool undo)\n{\n\tstruct journal_head *jh;\n\tbool ret = false;\n\n\t \n\tif (buffer_dirty(bh))\n\t\treturn false;\n\n\t \n\trcu_read_lock();\n\tif (!buffer_jbd(bh))\n\t\tgoto out;\n\t \n\tjh = READ_ONCE(bh->b_private);\n\tif (!jh)\n\t\tgoto out;\n\t \n\tif (undo && !jh->b_committed_data)\n\t\tgoto out;\n\tif (READ_ONCE(jh->b_transaction) != handle->h_transaction &&\n\t    READ_ONCE(jh->b_next_transaction) != handle->h_transaction)\n\t\tgoto out;\n\t \n\tsmp_mb();\n\tif (unlikely(jh->b_bh != bh))\n\t\tgoto out;\n\tret = true;\nout:\n\trcu_read_unlock();\n\treturn ret;\n}\n\n \n\nint jbd2_journal_get_write_access(handle_t *handle, struct buffer_head *bh)\n{\n\tstruct journal_head *jh;\n\tint rc;\n\n\tif (is_handle_aborted(handle))\n\t\treturn -EROFS;\n\n\tif (jbd2_write_access_granted(handle, bh, false))\n\t\treturn 0;\n\n\tjh = jbd2_journal_add_journal_head(bh);\n\t \n\trc = do_get_write_access(handle, jh, 0);\n\tjbd2_journal_put_journal_head(jh);\n\treturn rc;\n}\n\n\n \n\n \nint jbd2_journal_get_create_access(handle_t *handle, struct buffer_head *bh)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal;\n\tstruct journal_head *jh = jbd2_journal_add_journal_head(bh);\n\tint err;\n\n\tjbd2_debug(5, \"journal_head %p\\n\", jh);\n\terr = -EROFS;\n\tif (is_handle_aborted(handle))\n\t\tgoto out;\n\tjournal = transaction->t_journal;\n\terr = 0;\n\n\tJBUFFER_TRACE(jh, \"entry\");\n\t \n\tspin_lock(&jh->b_state_lock);\n\tJ_ASSERT_JH(jh, (jh->b_transaction == transaction ||\n\t\tjh->b_transaction == NULL ||\n\t\t(jh->b_transaction == journal->j_committing_transaction &&\n\t\t\t  jh->b_jlist == BJ_Forget)));\n\n\tJ_ASSERT_JH(jh, jh->b_next_transaction == NULL);\n\tJ_ASSERT_JH(jh, buffer_locked(jh2bh(jh)));\n\n\tif (jh->b_transaction == NULL) {\n\t\t \n\t\tclear_buffer_dirty(jh2bh(jh));\n\t\t \n\t\tjh->b_modified = 0;\n\n\t\tJBUFFER_TRACE(jh, \"file as BJ_Reserved\");\n\t\tspin_lock(&journal->j_list_lock);\n\t\t__jbd2_journal_file_buffer(jh, transaction, BJ_Reserved);\n\t\tspin_unlock(&journal->j_list_lock);\n\t} else if (jh->b_transaction == journal->j_committing_transaction) {\n\t\t \n\t\tjh->b_modified = 0;\n\n\t\tJBUFFER_TRACE(jh, \"set next transaction\");\n\t\tspin_lock(&journal->j_list_lock);\n\t\tjh->b_next_transaction = transaction;\n\t\tspin_unlock(&journal->j_list_lock);\n\t}\n\tspin_unlock(&jh->b_state_lock);\n\n\t \n\tJBUFFER_TRACE(jh, \"cancelling revoke\");\n\tjbd2_journal_cancel_revoke(handle, jh);\nout:\n\tjbd2_journal_put_journal_head(jh);\n\treturn err;\n}\n\n \nint jbd2_journal_get_undo_access(handle_t *handle, struct buffer_head *bh)\n{\n\tint err;\n\tstruct journal_head *jh;\n\tchar *committed_data = NULL;\n\n\tif (is_handle_aborted(handle))\n\t\treturn -EROFS;\n\n\tif (jbd2_write_access_granted(handle, bh, true))\n\t\treturn 0;\n\n\tjh = jbd2_journal_add_journal_head(bh);\n\tJBUFFER_TRACE(jh, \"entry\");\n\n\t \n\terr = do_get_write_access(handle, jh, 1);\n\tif (err)\n\t\tgoto out;\n\nrepeat:\n\tif (!jh->b_committed_data)\n\t\tcommitted_data = jbd2_alloc(jh2bh(jh)->b_size,\n\t\t\t\t\t    GFP_NOFS|__GFP_NOFAIL);\n\n\tspin_lock(&jh->b_state_lock);\n\tif (!jh->b_committed_data) {\n\t\t \n\t\tJBUFFER_TRACE(jh, \"generate b_committed data\");\n\t\tif (!committed_data) {\n\t\t\tspin_unlock(&jh->b_state_lock);\n\t\t\tgoto repeat;\n\t\t}\n\n\t\tjh->b_committed_data = committed_data;\n\t\tcommitted_data = NULL;\n\t\tmemcpy(jh->b_committed_data, bh->b_data, bh->b_size);\n\t}\n\tspin_unlock(&jh->b_state_lock);\nout:\n\tjbd2_journal_put_journal_head(jh);\n\tif (unlikely(committed_data))\n\t\tjbd2_free(committed_data, bh->b_size);\n\treturn err;\n}\n\n \nvoid jbd2_journal_set_triggers(struct buffer_head *bh,\n\t\t\t       struct jbd2_buffer_trigger_type *type)\n{\n\tstruct journal_head *jh = jbd2_journal_grab_journal_head(bh);\n\n\tif (WARN_ON_ONCE(!jh))\n\t\treturn;\n\tjh->b_triggers = type;\n\tjbd2_journal_put_journal_head(jh);\n}\n\nvoid jbd2_buffer_frozen_trigger(struct journal_head *jh, void *mapped_data,\n\t\t\t\tstruct jbd2_buffer_trigger_type *triggers)\n{\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tif (!triggers || !triggers->t_frozen)\n\t\treturn;\n\n\ttriggers->t_frozen(triggers, bh, mapped_data, bh->b_size);\n}\n\nvoid jbd2_buffer_abort_trigger(struct journal_head *jh,\n\t\t\t       struct jbd2_buffer_trigger_type *triggers)\n{\n\tif (!triggers || !triggers->t_abort)\n\t\treturn;\n\n\ttriggers->t_abort(triggers, jh2bh(jh));\n}\n\n \nint jbd2_journal_dirty_metadata(handle_t *handle, struct buffer_head *bh)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal;\n\tstruct journal_head *jh;\n\tint ret = 0;\n\n\tif (!buffer_jbd(bh))\n\t\treturn -EUCLEAN;\n\n\t \n\tjh = bh2jh(bh);\n\tjbd2_debug(5, \"journal_head %p\\n\", jh);\n\tJBUFFER_TRACE(jh, \"entry\");\n\n\t \n\tif (data_race(jh->b_transaction != transaction &&\n\t    jh->b_next_transaction != transaction)) {\n\t\tspin_lock(&jh->b_state_lock);\n\t\tJ_ASSERT_JH(jh, jh->b_transaction == transaction ||\n\t\t\t\tjh->b_next_transaction == transaction);\n\t\tspin_unlock(&jh->b_state_lock);\n\t}\n\tif (jh->b_modified == 1) {\n\t\t \n\t\tif (data_race(jh->b_transaction == transaction &&\n\t\t    jh->b_jlist != BJ_Metadata)) {\n\t\t\tspin_lock(&jh->b_state_lock);\n\t\t\tif (jh->b_transaction == transaction &&\n\t\t\t    jh->b_jlist != BJ_Metadata)\n\t\t\t\tpr_err(\"JBD2: assertion failure: h_type=%u \"\n\t\t\t\t       \"h_line_no=%u block_no=%llu jlist=%u\\n\",\n\t\t\t\t       handle->h_type, handle->h_line_no,\n\t\t\t\t       (unsigned long long) bh->b_blocknr,\n\t\t\t\t       jh->b_jlist);\n\t\t\tJ_ASSERT_JH(jh, jh->b_transaction != transaction ||\n\t\t\t\t\tjh->b_jlist == BJ_Metadata);\n\t\t\tspin_unlock(&jh->b_state_lock);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tjournal = transaction->t_journal;\n\tspin_lock(&jh->b_state_lock);\n\n\tif (is_handle_aborted(handle)) {\n\t\t \n\t\tret = -EROFS;\n\t\tgoto out_unlock_bh;\n\t}\n\n\tif (jh->b_modified == 0) {\n\t\t \n\t\tif (WARN_ON_ONCE(jbd2_handle_buffer_credits(handle) <= 0)) {\n\t\t\tret = -ENOSPC;\n\t\t\tgoto out_unlock_bh;\n\t\t}\n\t\tjh->b_modified = 1;\n\t\thandle->h_total_credits--;\n\t}\n\n\t \n\tif (jh->b_transaction == transaction && jh->b_jlist == BJ_Metadata) {\n\t\tJBUFFER_TRACE(jh, \"fastpath\");\n\t\tif (unlikely(jh->b_transaction !=\n\t\t\t     journal->j_running_transaction)) {\n\t\t\tprintk(KERN_ERR \"JBD2: %s: \"\n\t\t\t       \"jh->b_transaction (%llu, %p, %u) != \"\n\t\t\t       \"journal->j_running_transaction (%p, %u)\\n\",\n\t\t\t       journal->j_devname,\n\t\t\t       (unsigned long long) bh->b_blocknr,\n\t\t\t       jh->b_transaction,\n\t\t\t       jh->b_transaction ? jh->b_transaction->t_tid : 0,\n\t\t\t       journal->j_running_transaction,\n\t\t\t       journal->j_running_transaction ?\n\t\t\t       journal->j_running_transaction->t_tid : 0);\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tgoto out_unlock_bh;\n\t}\n\n\tset_buffer_jbddirty(bh);\n\n\t \n\tif (jh->b_transaction != transaction) {\n\t\tJBUFFER_TRACE(jh, \"already on other transaction\");\n\t\tif (unlikely(((jh->b_transaction !=\n\t\t\t       journal->j_committing_transaction)) ||\n\t\t\t     (jh->b_next_transaction != transaction))) {\n\t\t\tprintk(KERN_ERR \"jbd2_journal_dirty_metadata: %s: \"\n\t\t\t       \"bad jh for block %llu: \"\n\t\t\t       \"transaction (%p, %u), \"\n\t\t\t       \"jh->b_transaction (%p, %u), \"\n\t\t\t       \"jh->b_next_transaction (%p, %u), jlist %u\\n\",\n\t\t\t       journal->j_devname,\n\t\t\t       (unsigned long long) bh->b_blocknr,\n\t\t\t       transaction, transaction->t_tid,\n\t\t\t       jh->b_transaction,\n\t\t\t       jh->b_transaction ?\n\t\t\t       jh->b_transaction->t_tid : 0,\n\t\t\t       jh->b_next_transaction,\n\t\t\t       jh->b_next_transaction ?\n\t\t\t       jh->b_next_transaction->t_tid : 0,\n\t\t\t       jh->b_jlist);\n\t\t\tWARN_ON(1);\n\t\t\tret = -EINVAL;\n\t\t}\n\t\t \n\t\tgoto out_unlock_bh;\n\t}\n\n\t \n\tJ_ASSERT_JH(jh, jh->b_frozen_data == NULL);\n\n\tJBUFFER_TRACE(jh, \"file as BJ_Metadata\");\n\tspin_lock(&journal->j_list_lock);\n\t__jbd2_journal_file_buffer(jh, transaction, BJ_Metadata);\n\tspin_unlock(&journal->j_list_lock);\nout_unlock_bh:\n\tspin_unlock(&jh->b_state_lock);\nout:\n\tJBUFFER_TRACE(jh, \"exit\");\n\treturn ret;\n}\n\n \nint jbd2_journal_forget(handle_t *handle, struct buffer_head *bh)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal;\n\tstruct journal_head *jh;\n\tint drop_reserve = 0;\n\tint err = 0;\n\tint was_modified = 0;\n\n\tif (is_handle_aborted(handle))\n\t\treturn -EROFS;\n\tjournal = transaction->t_journal;\n\n\tBUFFER_TRACE(bh, \"entry\");\n\n\tjh = jbd2_journal_grab_journal_head(bh);\n\tif (!jh) {\n\t\t__bforget(bh);\n\t\treturn 0;\n\t}\n\n\tspin_lock(&jh->b_state_lock);\n\n\t \n\tif (!J_EXPECT_JH(jh, !jh->b_committed_data,\n\t\t\t \"inconsistent data on disk\")) {\n\t\terr = -EIO;\n\t\tgoto drop;\n\t}\n\n\t \n\twas_modified = jh->b_modified;\n\n\t \n\tjh->b_modified = 0;\n\n\tif (jh->b_transaction == transaction) {\n\t\tJ_ASSERT_JH(jh, !jh->b_frozen_data);\n\n\t\t \n\t\tclear_buffer_dirty(bh);\n\t\tclear_buffer_jbddirty(bh);\n\n\t\tJBUFFER_TRACE(jh, \"belongs to current transaction: unfile\");\n\n\t\t \n\t\tif (was_modified)\n\t\t\tdrop_reserve = 1;\n\n\t\t \n\n\t\tspin_lock(&journal->j_list_lock);\n\t\tif (jh->b_cp_transaction) {\n\t\t\t__jbd2_journal_temp_unlink_buffer(jh);\n\t\t\t__jbd2_journal_file_buffer(jh, transaction, BJ_Forget);\n\t\t} else {\n\t\t\t__jbd2_journal_unfile_buffer(jh);\n\t\t\tjbd2_journal_put_journal_head(jh);\n\t\t}\n\t\tspin_unlock(&journal->j_list_lock);\n\t} else if (jh->b_transaction) {\n\t\tJ_ASSERT_JH(jh, (jh->b_transaction ==\n\t\t\t\t journal->j_committing_transaction));\n\t\t \n\t\tJBUFFER_TRACE(jh, \"belongs to older transaction\");\n\t\t \n\n\t\tset_buffer_freed(bh);\n\n\t\tif (!jh->b_next_transaction) {\n\t\t\tspin_lock(&journal->j_list_lock);\n\t\t\tjh->b_next_transaction = transaction;\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t} else {\n\t\t\tJ_ASSERT(jh->b_next_transaction == transaction);\n\n\t\t\t \n\t\t\tif (was_modified)\n\t\t\t\tdrop_reserve = 1;\n\t\t}\n\t} else {\n\t\t \n\t\tspin_lock(&journal->j_list_lock);\n\t\tif (!jh->b_cp_transaction) {\n\t\t\tJBUFFER_TRACE(jh, \"belongs to none transaction\");\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\tgoto drop;\n\t\t}\n\n\t\t \n\t\tif (jbd2_journal_try_remove_checkpoint(jh) >= 0) {\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\tgoto drop;\n\t\t}\n\n\t\t \n\t\tclear_buffer_dirty(bh);\n\t\t__jbd2_journal_file_buffer(jh, transaction, BJ_Forget);\n\t\tspin_unlock(&journal->j_list_lock);\n\t}\ndrop:\n\t__brelse(bh);\n\tspin_unlock(&jh->b_state_lock);\n\tjbd2_journal_put_journal_head(jh);\n\tif (drop_reserve) {\n\t\t \n\t\thandle->h_total_credits++;\n\t}\n\treturn err;\n}\n\n \nint jbd2_journal_stop(handle_t *handle)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal;\n\tint err = 0, wait_for_commit = 0;\n\ttid_t tid;\n\tpid_t pid;\n\n\tif (--handle->h_ref > 0) {\n\t\tjbd2_debug(4, \"h_ref %d -> %d\\n\", handle->h_ref + 1,\n\t\t\t\t\t\t handle->h_ref);\n\t\tif (is_handle_aborted(handle))\n\t\t\treturn -EIO;\n\t\treturn 0;\n\t}\n\tif (!transaction) {\n\t\t \n\t\tmemalloc_nofs_restore(handle->saved_alloc_context);\n\t\tgoto free_and_exit;\n\t}\n\tjournal = transaction->t_journal;\n\ttid = transaction->t_tid;\n\n\tif (is_handle_aborted(handle))\n\t\terr = -EIO;\n\n\tjbd2_debug(4, \"Handle %p going down\\n\", handle);\n\ttrace_jbd2_handle_stats(journal->j_fs_dev->bd_dev,\n\t\t\t\ttid, handle->h_type, handle->h_line_no,\n\t\t\t\tjiffies - handle->h_start_jiffies,\n\t\t\t\thandle->h_sync, handle->h_requested_credits,\n\t\t\t\t(handle->h_requested_credits -\n\t\t\t\t handle->h_total_credits));\n\n\t \n\tpid = current->pid;\n\tif (handle->h_sync && journal->j_last_sync_writer != pid &&\n\t    journal->j_max_batch_time) {\n\t\tu64 commit_time, trans_time;\n\n\t\tjournal->j_last_sync_writer = pid;\n\n\t\tread_lock(&journal->j_state_lock);\n\t\tcommit_time = journal->j_average_commit_time;\n\t\tread_unlock(&journal->j_state_lock);\n\n\t\ttrans_time = ktime_to_ns(ktime_sub(ktime_get(),\n\t\t\t\t\t\t   transaction->t_start_time));\n\n\t\tcommit_time = max_t(u64, commit_time,\n\t\t\t\t    1000*journal->j_min_batch_time);\n\t\tcommit_time = min_t(u64, commit_time,\n\t\t\t\t    1000*journal->j_max_batch_time);\n\n\t\tif (trans_time < commit_time) {\n\t\t\tktime_t expires = ktime_add_ns(ktime_get(),\n\t\t\t\t\t\t       commit_time);\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tschedule_hrtimeout(&expires, HRTIMER_MODE_ABS);\n\t\t}\n\t}\n\n\tif (handle->h_sync)\n\t\ttransaction->t_synchronous_commit = 1;\n\n\t \n\tif (handle->h_sync ||\n\t    time_after_eq(jiffies, transaction->t_expires)) {\n\t\t \n\n\t\tjbd2_debug(2, \"transaction too old, requesting commit for \"\n\t\t\t\t\t\"handle %p\\n\", handle);\n\t\t \n\t\tjbd2_log_start_commit(journal, tid);\n\n\t\t \n\t\tif (handle->h_sync && !(current->flags & PF_MEMALLOC))\n\t\t\twait_for_commit = 1;\n\t}\n\n\t \n\tstop_this_handle(handle);\n\n\tif (wait_for_commit)\n\t\terr = jbd2_log_wait_commit(journal, tid);\n\nfree_and_exit:\n\tif (handle->h_rsv_handle)\n\t\tjbd2_free_handle(handle->h_rsv_handle);\n\tjbd2_free_handle(handle);\n\treturn err;\n}\n\n \n\n \n\nstatic inline void\n__blist_add_buffer(struct journal_head **list, struct journal_head *jh)\n{\n\tif (!*list) {\n\t\tjh->b_tnext = jh->b_tprev = jh;\n\t\t*list = jh;\n\t} else {\n\t\t \n\t\tstruct journal_head *first = *list, *last = first->b_tprev;\n\t\tjh->b_tprev = last;\n\t\tjh->b_tnext = first;\n\t\tlast->b_tnext = first->b_tprev = jh;\n\t}\n}\n\n \n\nstatic inline void\n__blist_del_buffer(struct journal_head **list, struct journal_head *jh)\n{\n\tif (*list == jh) {\n\t\t*list = jh->b_tnext;\n\t\tif (*list == jh)\n\t\t\t*list = NULL;\n\t}\n\tjh->b_tprev->b_tnext = jh->b_tnext;\n\tjh->b_tnext->b_tprev = jh->b_tprev;\n}\n\n \nstatic void __jbd2_journal_temp_unlink_buffer(struct journal_head *jh)\n{\n\tstruct journal_head **list = NULL;\n\ttransaction_t *transaction;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tlockdep_assert_held(&jh->b_state_lock);\n\ttransaction = jh->b_transaction;\n\tif (transaction)\n\t\tassert_spin_locked(&transaction->t_journal->j_list_lock);\n\n\tJ_ASSERT_JH(jh, jh->b_jlist < BJ_Types);\n\tif (jh->b_jlist != BJ_None)\n\t\tJ_ASSERT_JH(jh, transaction != NULL);\n\n\tswitch (jh->b_jlist) {\n\tcase BJ_None:\n\t\treturn;\n\tcase BJ_Metadata:\n\t\ttransaction->t_nr_buffers--;\n\t\tJ_ASSERT_JH(jh, transaction->t_nr_buffers >= 0);\n\t\tlist = &transaction->t_buffers;\n\t\tbreak;\n\tcase BJ_Forget:\n\t\tlist = &transaction->t_forget;\n\t\tbreak;\n\tcase BJ_Shadow:\n\t\tlist = &transaction->t_shadow_list;\n\t\tbreak;\n\tcase BJ_Reserved:\n\t\tlist = &transaction->t_reserved_list;\n\t\tbreak;\n\t}\n\n\t__blist_del_buffer(list, jh);\n\tjh->b_jlist = BJ_None;\n\tif (transaction && is_journal_aborted(transaction->t_journal))\n\t\tclear_buffer_jbddirty(bh);\n\telse if (test_clear_buffer_jbddirty(bh))\n\t\tmark_buffer_dirty(bh);\t \n}\n\n \nstatic void __jbd2_journal_unfile_buffer(struct journal_head *jh)\n{\n\tJ_ASSERT_JH(jh, jh->b_transaction != NULL);\n\tJ_ASSERT_JH(jh, jh->b_next_transaction == NULL);\n\n\t__jbd2_journal_temp_unlink_buffer(jh);\n\tjh->b_transaction = NULL;\n}\n\nvoid jbd2_journal_unfile_buffer(journal_t *journal, struct journal_head *jh)\n{\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\t \n\tget_bh(bh);\n\tspin_lock(&jh->b_state_lock);\n\tspin_lock(&journal->j_list_lock);\n\t__jbd2_journal_unfile_buffer(jh);\n\tspin_unlock(&journal->j_list_lock);\n\tspin_unlock(&jh->b_state_lock);\n\tjbd2_journal_put_journal_head(jh);\n\t__brelse(bh);\n}\n\n \nbool jbd2_journal_try_to_free_buffers(journal_t *journal, struct folio *folio)\n{\n\tstruct buffer_head *head;\n\tstruct buffer_head *bh;\n\tbool ret = false;\n\n\tJ_ASSERT(folio_test_locked(folio));\n\n\thead = folio_buffers(folio);\n\tbh = head;\n\tdo {\n\t\tstruct journal_head *jh;\n\n\t\t \n\t\tjh = jbd2_journal_grab_journal_head(bh);\n\t\tif (!jh)\n\t\t\tcontinue;\n\n\t\tspin_lock(&jh->b_state_lock);\n\t\tif (!jh->b_transaction && !jh->b_next_transaction) {\n\t\t\tspin_lock(&journal->j_list_lock);\n\t\t\t \n\t\t\tif (jh->b_cp_transaction != NULL)\n\t\t\t\tjbd2_journal_try_remove_checkpoint(jh);\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t}\n\t\tspin_unlock(&jh->b_state_lock);\n\t\tjbd2_journal_put_journal_head(jh);\n\t\tif (buffer_jbd(bh))\n\t\t\tgoto busy;\n\t} while ((bh = bh->b_this_page) != head);\n\n\tret = try_to_free_buffers(folio);\nbusy:\n\treturn ret;\n}\n\n \nstatic int __dispose_buffer(struct journal_head *jh, transaction_t *transaction)\n{\n\tint may_free = 1;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tif (jh->b_cp_transaction) {\n\t\tJBUFFER_TRACE(jh, \"on running+cp transaction\");\n\t\t__jbd2_journal_temp_unlink_buffer(jh);\n\t\t \n\t\tclear_buffer_dirty(bh);\n\t\t__jbd2_journal_file_buffer(jh, transaction, BJ_Forget);\n\t\tmay_free = 0;\n\t} else {\n\t\tJBUFFER_TRACE(jh, \"on running transaction\");\n\t\t__jbd2_journal_unfile_buffer(jh);\n\t\tjbd2_journal_put_journal_head(jh);\n\t}\n\treturn may_free;\n}\n\n \n\n \nstatic int journal_unmap_buffer(journal_t *journal, struct buffer_head *bh,\n\t\t\t\tint partial_page)\n{\n\ttransaction_t *transaction;\n\tstruct journal_head *jh;\n\tint may_free = 1;\n\n\tBUFFER_TRACE(bh, \"entry\");\n\n\t \n\n\tjh = jbd2_journal_grab_journal_head(bh);\n\tif (!jh)\n\t\tgoto zap_buffer_unlocked;\n\n\t \n\twrite_lock(&journal->j_state_lock);\n\tspin_lock(&jh->b_state_lock);\n\tspin_lock(&journal->j_list_lock);\n\n\t \n\ttransaction = jh->b_transaction;\n\tif (transaction == NULL) {\n\t\t \n\t\tif (!jh->b_cp_transaction) {\n\t\t\tJBUFFER_TRACE(jh, \"not on any transaction: zap\");\n\t\t\tgoto zap_buffer;\n\t\t}\n\n\t\tif (!buffer_dirty(bh)) {\n\t\t\t \n\t\t\t__jbd2_journal_remove_checkpoint(jh);\n\t\t\tgoto zap_buffer;\n\t\t}\n\n\t\t \n\n\t\tif (journal->j_running_transaction) {\n\t\t\t \n\t\t\tJBUFFER_TRACE(jh, \"checkpointed: add to BJ_Forget\");\n\t\t\tmay_free = __dispose_buffer(jh,\n\t\t\t\t\tjournal->j_running_transaction);\n\t\t\tgoto zap_buffer;\n\t\t} else {\n\t\t\t \n\t\t\tif (journal->j_committing_transaction) {\n\t\t\t\tJBUFFER_TRACE(jh, \"give to committing trans\");\n\t\t\t\tmay_free = __dispose_buffer(jh,\n\t\t\t\t\tjournal->j_committing_transaction);\n\t\t\t\tgoto zap_buffer;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tclear_buffer_jbddirty(bh);\n\t\t\t\t__jbd2_journal_remove_checkpoint(jh);\n\t\t\t\tgoto zap_buffer;\n\t\t\t}\n\t\t}\n\t} else if (transaction == journal->j_committing_transaction) {\n\t\tJBUFFER_TRACE(jh, \"on committing transaction\");\n\t\t \n\t\tif (partial_page) {\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\tspin_unlock(&jh->b_state_lock);\n\t\t\twrite_unlock(&journal->j_state_lock);\n\t\t\tjbd2_journal_put_journal_head(jh);\n\t\t\t \n\t\t\tif (!bh->b_bdev)\n\t\t\t\treturn 0;\n\t\t\treturn -EBUSY;\n\t\t}\n\t\t \n\t\tset_buffer_freed(bh);\n\t\tif (journal->j_running_transaction && buffer_jbddirty(bh))\n\t\t\tjh->b_next_transaction = journal->j_running_transaction;\n\t\tjh->b_modified = 0;\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tspin_unlock(&jh->b_state_lock);\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tjbd2_journal_put_journal_head(jh);\n\t\treturn 0;\n\t} else {\n\t\t \n\t\tJ_ASSERT_JH(jh, transaction == journal->j_running_transaction);\n\t\tJBUFFER_TRACE(jh, \"on running transaction\");\n\t\tmay_free = __dispose_buffer(jh, transaction);\n\t}\n\nzap_buffer:\n\t \n\tjh->b_modified = 0;\n\tspin_unlock(&journal->j_list_lock);\n\tspin_unlock(&jh->b_state_lock);\n\twrite_unlock(&journal->j_state_lock);\n\tjbd2_journal_put_journal_head(jh);\nzap_buffer_unlocked:\n\tclear_buffer_dirty(bh);\n\tJ_ASSERT_BH(bh, !buffer_jbddirty(bh));\n\tclear_buffer_mapped(bh);\n\tclear_buffer_req(bh);\n\tclear_buffer_new(bh);\n\tclear_buffer_delay(bh);\n\tclear_buffer_unwritten(bh);\n\tbh->b_bdev = NULL;\n\treturn may_free;\n}\n\n \nint jbd2_journal_invalidate_folio(journal_t *journal, struct folio *folio,\n\t\t\t\tsize_t offset, size_t length)\n{\n\tstruct buffer_head *head, *bh, *next;\n\tunsigned int stop = offset + length;\n\tunsigned int curr_off = 0;\n\tint partial_page = (offset || length < folio_size(folio));\n\tint may_free = 1;\n\tint ret = 0;\n\n\tif (!folio_test_locked(folio))\n\t\tBUG();\n\thead = folio_buffers(folio);\n\tif (!head)\n\t\treturn 0;\n\n\tBUG_ON(stop > folio_size(folio) || stop < length);\n\n\t \n\n\tbh = head;\n\tdo {\n\t\tunsigned int next_off = curr_off + bh->b_size;\n\t\tnext = bh->b_this_page;\n\n\t\tif (next_off > stop)\n\t\t\treturn 0;\n\n\t\tif (offset <= curr_off) {\n\t\t\t \n\t\t\tlock_buffer(bh);\n\t\t\tret = journal_unmap_buffer(journal, bh, partial_page);\n\t\t\tunlock_buffer(bh);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tmay_free &= ret;\n\t\t}\n\t\tcurr_off = next_off;\n\t\tbh = next;\n\n\t} while (bh != head);\n\n\tif (!partial_page) {\n\t\tif (may_free && try_to_free_buffers(folio))\n\t\t\tJ_ASSERT(!folio_buffers(folio));\n\t}\n\treturn 0;\n}\n\n \nvoid __jbd2_journal_file_buffer(struct journal_head *jh,\n\t\t\ttransaction_t *transaction, int jlist)\n{\n\tstruct journal_head **list = NULL;\n\tint was_dirty = 0;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tlockdep_assert_held(&jh->b_state_lock);\n\tassert_spin_locked(&transaction->t_journal->j_list_lock);\n\n\tJ_ASSERT_JH(jh, jh->b_jlist < BJ_Types);\n\tJ_ASSERT_JH(jh, jh->b_transaction == transaction ||\n\t\t\t\tjh->b_transaction == NULL);\n\n\tif (jh->b_transaction && jh->b_jlist == jlist)\n\t\treturn;\n\n\tif (jlist == BJ_Metadata || jlist == BJ_Reserved ||\n\t    jlist == BJ_Shadow || jlist == BJ_Forget) {\n\t\t \n\t\tif (buffer_dirty(bh))\n\t\t\twarn_dirty_buffer(bh);\n\t\tif (test_clear_buffer_dirty(bh) ||\n\t\t    test_clear_buffer_jbddirty(bh))\n\t\t\twas_dirty = 1;\n\t}\n\n\tif (jh->b_transaction)\n\t\t__jbd2_journal_temp_unlink_buffer(jh);\n\telse\n\t\tjbd2_journal_grab_journal_head(bh);\n\tjh->b_transaction = transaction;\n\n\tswitch (jlist) {\n\tcase BJ_None:\n\t\tJ_ASSERT_JH(jh, !jh->b_committed_data);\n\t\tJ_ASSERT_JH(jh, !jh->b_frozen_data);\n\t\treturn;\n\tcase BJ_Metadata:\n\t\ttransaction->t_nr_buffers++;\n\t\tlist = &transaction->t_buffers;\n\t\tbreak;\n\tcase BJ_Forget:\n\t\tlist = &transaction->t_forget;\n\t\tbreak;\n\tcase BJ_Shadow:\n\t\tlist = &transaction->t_shadow_list;\n\t\tbreak;\n\tcase BJ_Reserved:\n\t\tlist = &transaction->t_reserved_list;\n\t\tbreak;\n\t}\n\n\t__blist_add_buffer(list, jh);\n\tjh->b_jlist = jlist;\n\n\tif (was_dirty)\n\t\tset_buffer_jbddirty(bh);\n}\n\nvoid jbd2_journal_file_buffer(struct journal_head *jh,\n\t\t\t\ttransaction_t *transaction, int jlist)\n{\n\tspin_lock(&jh->b_state_lock);\n\tspin_lock(&transaction->t_journal->j_list_lock);\n\t__jbd2_journal_file_buffer(jh, transaction, jlist);\n\tspin_unlock(&transaction->t_journal->j_list_lock);\n\tspin_unlock(&jh->b_state_lock);\n}\n\n \nbool __jbd2_journal_refile_buffer(struct journal_head *jh)\n{\n\tint was_dirty, jlist;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tlockdep_assert_held(&jh->b_state_lock);\n\tif (jh->b_transaction)\n\t\tassert_spin_locked(&jh->b_transaction->t_journal->j_list_lock);\n\n\t \n\tif (jh->b_next_transaction == NULL) {\n\t\t__jbd2_journal_unfile_buffer(jh);\n\t\treturn true;\n\t}\n\n\t \n\n\twas_dirty = test_clear_buffer_jbddirty(bh);\n\t__jbd2_journal_temp_unlink_buffer(jh);\n\n\t \n\tJ_ASSERT_JH(jh, jh->b_transaction != NULL);\n\n\t \n\tWRITE_ONCE(jh->b_transaction, jh->b_next_transaction);\n\tWRITE_ONCE(jh->b_next_transaction, NULL);\n\tif (buffer_freed(bh))\n\t\tjlist = BJ_Forget;\n\telse if (jh->b_modified)\n\t\tjlist = BJ_Metadata;\n\telse\n\t\tjlist = BJ_Reserved;\n\t__jbd2_journal_file_buffer(jh, jh->b_transaction, jlist);\n\tJ_ASSERT_JH(jh, jh->b_transaction->t_state == T_RUNNING);\n\n\tif (was_dirty)\n\t\tset_buffer_jbddirty(bh);\n\treturn false;\n}\n\n \nvoid jbd2_journal_refile_buffer(journal_t *journal, struct journal_head *jh)\n{\n\tbool drop;\n\n\tspin_lock(&jh->b_state_lock);\n\tspin_lock(&journal->j_list_lock);\n\tdrop = __jbd2_journal_refile_buffer(jh);\n\tspin_unlock(&jh->b_state_lock);\n\tspin_unlock(&journal->j_list_lock);\n\tif (drop)\n\t\tjbd2_journal_put_journal_head(jh);\n}\n\n \nstatic int jbd2_journal_file_inode(handle_t *handle, struct jbd2_inode *jinode,\n\t\tunsigned long flags, loff_t start_byte, loff_t end_byte)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal;\n\n\tif (is_handle_aborted(handle))\n\t\treturn -EROFS;\n\tjournal = transaction->t_journal;\n\n\tjbd2_debug(4, \"Adding inode %lu, tid:%d\\n\", jinode->i_vfs_inode->i_ino,\n\t\t\ttransaction->t_tid);\n\n\tspin_lock(&journal->j_list_lock);\n\tjinode->i_flags |= flags;\n\n\tif (jinode->i_dirty_end) {\n\t\tjinode->i_dirty_start = min(jinode->i_dirty_start, start_byte);\n\t\tjinode->i_dirty_end = max(jinode->i_dirty_end, end_byte);\n\t} else {\n\t\tjinode->i_dirty_start = start_byte;\n\t\tjinode->i_dirty_end = end_byte;\n\t}\n\n\t \n\tif (jinode->i_transaction == transaction ||\n\t    jinode->i_next_transaction == transaction)\n\t\tgoto done;\n\n\t \n\tif (!transaction->t_need_data_flush)\n\t\ttransaction->t_need_data_flush = 1;\n\t \n\tif (jinode->i_transaction) {\n\t\tJ_ASSERT(jinode->i_next_transaction == NULL);\n\t\tJ_ASSERT(jinode->i_transaction ==\n\t\t\t\t\tjournal->j_committing_transaction);\n\t\tjinode->i_next_transaction = transaction;\n\t\tgoto done;\n\t}\n\t \n\tJ_ASSERT(!jinode->i_next_transaction);\n\tjinode->i_transaction = transaction;\n\tlist_add(&jinode->i_list, &transaction->t_inode_list);\ndone:\n\tspin_unlock(&journal->j_list_lock);\n\n\treturn 0;\n}\n\nint jbd2_journal_inode_ranged_write(handle_t *handle,\n\t\tstruct jbd2_inode *jinode, loff_t start_byte, loff_t length)\n{\n\treturn jbd2_journal_file_inode(handle, jinode,\n\t\t\tJI_WRITE_DATA | JI_WAIT_DATA, start_byte,\n\t\t\tstart_byte + length - 1);\n}\n\nint jbd2_journal_inode_ranged_wait(handle_t *handle, struct jbd2_inode *jinode,\n\t\tloff_t start_byte, loff_t length)\n{\n\treturn jbd2_journal_file_inode(handle, jinode, JI_WAIT_DATA,\n\t\t\tstart_byte, start_byte + length - 1);\n}\n\n \nint jbd2_journal_begin_ordered_truncate(journal_t *journal,\n\t\t\t\t\tstruct jbd2_inode *jinode,\n\t\t\t\t\tloff_t new_size)\n{\n\ttransaction_t *inode_trans, *commit_trans;\n\tint ret = 0;\n\n\t \n\tif (!jinode->i_transaction)\n\t\tgoto out;\n\t \n\tread_lock(&journal->j_state_lock);\n\tcommit_trans = journal->j_committing_transaction;\n\tread_unlock(&journal->j_state_lock);\n\tspin_lock(&journal->j_list_lock);\n\tinode_trans = jinode->i_transaction;\n\tspin_unlock(&journal->j_list_lock);\n\tif (inode_trans == commit_trans) {\n\t\tret = filemap_fdatawrite_range(jinode->i_vfs_inode->i_mapping,\n\t\t\tnew_size, LLONG_MAX);\n\t\tif (ret)\n\t\t\tjbd2_journal_abort(journal, ret);\n\t}\nout:\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}