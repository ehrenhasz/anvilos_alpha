{
  "module_name": "revoke.c",
  "hash_id": "75084ba96b735e1ff6af063048c882dac4fc0e39594024ffa34cc849d010ac48",
  "original_prompt": "Ingested from linux-6.6.14/fs/jbd2/revoke.c",
  "human_readable_source": "\n \n\n#ifndef __KERNEL__\n#include \"jfs_user.h\"\n#else\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/jbd2.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/bio.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#endif\n\nstatic struct kmem_cache *jbd2_revoke_record_cache;\nstatic struct kmem_cache *jbd2_revoke_table_cache;\n\n \n\nstruct jbd2_revoke_record_s\n{\n\tstruct list_head  hash;\n\ttid_t\t\t  sequence;\t \n\tunsigned long long\t  blocknr;\n};\n\n\n \nstruct jbd2_revoke_table_s\n{\n\t \n\tint\t\t  hash_size;\n\tint\t\t  hash_shift;\n\tstruct list_head *hash_table;\n};\n\n\n#ifdef __KERNEL__\nstatic void write_one_revoke_record(transaction_t *,\n\t\t\t\t    struct list_head *,\n\t\t\t\t    struct buffer_head **, int *,\n\t\t\t\t    struct jbd2_revoke_record_s *);\nstatic void flush_descriptor(journal_t *, struct buffer_head *, int);\n#endif\n\n \n\nstatic inline int hash(journal_t *journal, unsigned long long block)\n{\n\treturn hash_64(block, journal->j_revoke->hash_shift);\n}\n\nstatic int insert_revoke_hash(journal_t *journal, unsigned long long blocknr,\n\t\t\t      tid_t seq)\n{\n\tstruct list_head *hash_list;\n\tstruct jbd2_revoke_record_s *record;\n\tgfp_t gfp_mask = GFP_NOFS;\n\n\tif (journal_oom_retry)\n\t\tgfp_mask |= __GFP_NOFAIL;\n\trecord = kmem_cache_alloc(jbd2_revoke_record_cache, gfp_mask);\n\tif (!record)\n\t\treturn -ENOMEM;\n\n\trecord->sequence = seq;\n\trecord->blocknr = blocknr;\n\thash_list = &journal->j_revoke->hash_table[hash(journal, blocknr)];\n\tspin_lock(&journal->j_revoke_lock);\n\tlist_add(&record->hash, hash_list);\n\tspin_unlock(&journal->j_revoke_lock);\n\treturn 0;\n}\n\n \n\nstatic struct jbd2_revoke_record_s *find_revoke_record(journal_t *journal,\n\t\t\t\t\t\t      unsigned long long blocknr)\n{\n\tstruct list_head *hash_list;\n\tstruct jbd2_revoke_record_s *record;\n\n\thash_list = &journal->j_revoke->hash_table[hash(journal, blocknr)];\n\n\tspin_lock(&journal->j_revoke_lock);\n\trecord = (struct jbd2_revoke_record_s *) hash_list->next;\n\twhile (&(record->hash) != hash_list) {\n\t\tif (record->blocknr == blocknr) {\n\t\t\tspin_unlock(&journal->j_revoke_lock);\n\t\t\treturn record;\n\t\t}\n\t\trecord = (struct jbd2_revoke_record_s *) record->hash.next;\n\t}\n\tspin_unlock(&journal->j_revoke_lock);\n\treturn NULL;\n}\n\nvoid jbd2_journal_destroy_revoke_record_cache(void)\n{\n\tkmem_cache_destroy(jbd2_revoke_record_cache);\n\tjbd2_revoke_record_cache = NULL;\n}\n\nvoid jbd2_journal_destroy_revoke_table_cache(void)\n{\n\tkmem_cache_destroy(jbd2_revoke_table_cache);\n\tjbd2_revoke_table_cache = NULL;\n}\n\nint __init jbd2_journal_init_revoke_record_cache(void)\n{\n\tJ_ASSERT(!jbd2_revoke_record_cache);\n\tjbd2_revoke_record_cache = KMEM_CACHE(jbd2_revoke_record_s,\n\t\t\t\t\tSLAB_HWCACHE_ALIGN|SLAB_TEMPORARY);\n\n\tif (!jbd2_revoke_record_cache) {\n\t\tpr_emerg(\"JBD2: failed to create revoke_record cache\\n\");\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nint __init jbd2_journal_init_revoke_table_cache(void)\n{\n\tJ_ASSERT(!jbd2_revoke_table_cache);\n\tjbd2_revoke_table_cache = KMEM_CACHE(jbd2_revoke_table_s,\n\t\t\t\t\t     SLAB_TEMPORARY);\n\tif (!jbd2_revoke_table_cache) {\n\t\tpr_emerg(\"JBD2: failed to create revoke_table cache\\n\");\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nstatic struct jbd2_revoke_table_s *jbd2_journal_init_revoke_table(int hash_size)\n{\n\tint shift = 0;\n\tint tmp = hash_size;\n\tstruct jbd2_revoke_table_s *table;\n\n\ttable = kmem_cache_alloc(jbd2_revoke_table_cache, GFP_KERNEL);\n\tif (!table)\n\t\tgoto out;\n\n\twhile((tmp >>= 1UL) != 0UL)\n\t\tshift++;\n\n\ttable->hash_size = hash_size;\n\ttable->hash_shift = shift;\n\ttable->hash_table =\n\t\tkmalloc_array(hash_size, sizeof(struct list_head), GFP_KERNEL);\n\tif (!table->hash_table) {\n\t\tkmem_cache_free(jbd2_revoke_table_cache, table);\n\t\ttable = NULL;\n\t\tgoto out;\n\t}\n\n\tfor (tmp = 0; tmp < hash_size; tmp++)\n\t\tINIT_LIST_HEAD(&table->hash_table[tmp]);\n\nout:\n\treturn table;\n}\n\nstatic void jbd2_journal_destroy_revoke_table(struct jbd2_revoke_table_s *table)\n{\n\tint i;\n\tstruct list_head *hash_list;\n\n\tfor (i = 0; i < table->hash_size; i++) {\n\t\thash_list = &table->hash_table[i];\n\t\tJ_ASSERT(list_empty(hash_list));\n\t}\n\n\tkfree(table->hash_table);\n\tkmem_cache_free(jbd2_revoke_table_cache, table);\n}\n\n \nint jbd2_journal_init_revoke(journal_t *journal, int hash_size)\n{\n\tJ_ASSERT(journal->j_revoke_table[0] == NULL);\n\tJ_ASSERT(is_power_of_2(hash_size));\n\n\tjournal->j_revoke_table[0] = jbd2_journal_init_revoke_table(hash_size);\n\tif (!journal->j_revoke_table[0])\n\t\tgoto fail0;\n\n\tjournal->j_revoke_table[1] = jbd2_journal_init_revoke_table(hash_size);\n\tif (!journal->j_revoke_table[1])\n\t\tgoto fail1;\n\n\tjournal->j_revoke = journal->j_revoke_table[1];\n\n\tspin_lock_init(&journal->j_revoke_lock);\n\n\treturn 0;\n\nfail1:\n\tjbd2_journal_destroy_revoke_table(journal->j_revoke_table[0]);\n\tjournal->j_revoke_table[0] = NULL;\nfail0:\n\treturn -ENOMEM;\n}\n\n \nvoid jbd2_journal_destroy_revoke(journal_t *journal)\n{\n\tjournal->j_revoke = NULL;\n\tif (journal->j_revoke_table[0])\n\t\tjbd2_journal_destroy_revoke_table(journal->j_revoke_table[0]);\n\tif (journal->j_revoke_table[1])\n\t\tjbd2_journal_destroy_revoke_table(journal->j_revoke_table[1]);\n}\n\n\n#ifdef __KERNEL__\n\n \n\nint jbd2_journal_revoke(handle_t *handle, unsigned long long blocknr,\n\t\t   struct buffer_head *bh_in)\n{\n\tstruct buffer_head *bh = NULL;\n\tjournal_t *journal;\n\tstruct block_device *bdev;\n\tint err;\n\n\tmight_sleep();\n\tif (bh_in)\n\t\tBUFFER_TRACE(bh_in, \"enter\");\n\n\tjournal = handle->h_transaction->t_journal;\n\tif (!jbd2_journal_set_features(journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE)){\n\t\tJ_ASSERT (!\"Cannot set revoke feature!\");\n\t\treturn -EINVAL;\n\t}\n\n\tbdev = journal->j_fs_dev;\n\tbh = bh_in;\n\n\tif (!bh) {\n\t\tbh = __find_get_block(bdev, blocknr, journal->j_blocksize);\n\t\tif (bh)\n\t\t\tBUFFER_TRACE(bh, \"found on hash\");\n\t}\n#ifdef JBD2_EXPENSIVE_CHECKING\n\telse {\n\t\tstruct buffer_head *bh2;\n\n\t\t \n\t\tbh2 = __find_get_block(bdev, blocknr, journal->j_blocksize);\n\t\tif (bh2) {\n\t\t\t \n\t\t\tif (bh2 != bh && buffer_revokevalid(bh2))\n\t\t\t\t \n\t\t\t\tJ_ASSERT_BH(bh2, buffer_revoked(bh2));\n\t\t\tput_bh(bh2);\n\t\t}\n\t}\n#endif\n\n\tif (WARN_ON_ONCE(handle->h_revoke_credits <= 0)) {\n\t\tif (!bh_in)\n\t\t\tbrelse(bh);\n\t\treturn -EIO;\n\t}\n\t \n\tif (bh) {\n\t\tif (!J_EXPECT_BH(bh, !buffer_revoked(bh),\n\t\t\t\t \"inconsistent data on disk\")) {\n\t\t\tif (!bh_in)\n\t\t\t\tbrelse(bh);\n\t\t\treturn -EIO;\n\t\t}\n\t\tset_buffer_revoked(bh);\n\t\tset_buffer_revokevalid(bh);\n\t\tif (bh_in) {\n\t\t\tBUFFER_TRACE(bh_in, \"call jbd2_journal_forget\");\n\t\t\tjbd2_journal_forget(handle, bh_in);\n\t\t} else {\n\t\t\tBUFFER_TRACE(bh, \"call brelse\");\n\t\t\t__brelse(bh);\n\t\t}\n\t}\n\thandle->h_revoke_credits--;\n\n\tjbd2_debug(2, \"insert revoke for block %llu, bh_in=%p\\n\",blocknr, bh_in);\n\terr = insert_revoke_hash(journal, blocknr,\n\t\t\t\thandle->h_transaction->t_tid);\n\tBUFFER_TRACE(bh_in, \"exit\");\n\treturn err;\n}\n\n \nint jbd2_journal_cancel_revoke(handle_t *handle, struct journal_head *jh)\n{\n\tstruct jbd2_revoke_record_s *record;\n\tjournal_t *journal = handle->h_transaction->t_journal;\n\tint need_cancel;\n\tint did_revoke = 0;\t \n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tjbd2_debug(4, \"journal_head %p, cancelling revoke\\n\", jh);\n\n\t \n\tif (test_set_buffer_revokevalid(bh)) {\n\t\tneed_cancel = test_clear_buffer_revoked(bh);\n\t} else {\n\t\tneed_cancel = 1;\n\t\tclear_buffer_revoked(bh);\n\t}\n\n\tif (need_cancel) {\n\t\trecord = find_revoke_record(journal, bh->b_blocknr);\n\t\tif (record) {\n\t\t\tjbd2_debug(4, \"cancelled existing revoke on \"\n\t\t\t\t  \"blocknr %llu\\n\", (unsigned long long)bh->b_blocknr);\n\t\t\tspin_lock(&journal->j_revoke_lock);\n\t\t\tlist_del(&record->hash);\n\t\t\tspin_unlock(&journal->j_revoke_lock);\n\t\t\tkmem_cache_free(jbd2_revoke_record_cache, record);\n\t\t\tdid_revoke = 1;\n\t\t}\n\t}\n\n#ifdef JBD2_EXPENSIVE_CHECKING\n\t \n\trecord = find_revoke_record(journal, bh->b_blocknr);\n\tJ_ASSERT_JH(jh, record == NULL);\n#endif\n\n\t \n\tif (need_cancel) {\n\t\tstruct buffer_head *bh2;\n\t\tbh2 = __find_get_block(bh->b_bdev, bh->b_blocknr, bh->b_size);\n\t\tif (bh2) {\n\t\t\tif (bh2 != bh)\n\t\t\t\tclear_buffer_revoked(bh2);\n\t\t\t__brelse(bh2);\n\t\t}\n\t}\n\treturn did_revoke;\n}\n\n \nvoid jbd2_clear_buffer_revoked_flags(journal_t *journal)\n{\n\tstruct jbd2_revoke_table_s *revoke = journal->j_revoke;\n\tint i = 0;\n\n\tfor (i = 0; i < revoke->hash_size; i++) {\n\t\tstruct list_head *hash_list;\n\t\tstruct list_head *list_entry;\n\t\thash_list = &revoke->hash_table[i];\n\n\t\tlist_for_each(list_entry, hash_list) {\n\t\t\tstruct jbd2_revoke_record_s *record;\n\t\t\tstruct buffer_head *bh;\n\t\t\trecord = (struct jbd2_revoke_record_s *)list_entry;\n\t\t\tbh = __find_get_block(journal->j_fs_dev,\n\t\t\t\t\t      record->blocknr,\n\t\t\t\t\t      journal->j_blocksize);\n\t\t\tif (bh) {\n\t\t\t\tclear_buffer_revoked(bh);\n\t\t\t\t__brelse(bh);\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nvoid jbd2_journal_switch_revoke_table(journal_t *journal)\n{\n\tint i;\n\n\tif (journal->j_revoke == journal->j_revoke_table[0])\n\t\tjournal->j_revoke = journal->j_revoke_table[1];\n\telse\n\t\tjournal->j_revoke = journal->j_revoke_table[0];\n\n\tfor (i = 0; i < journal->j_revoke->hash_size; i++)\n\t\tINIT_LIST_HEAD(&journal->j_revoke->hash_table[i]);\n}\n\n \nvoid jbd2_journal_write_revoke_records(transaction_t *transaction,\n\t\t\t\t       struct list_head *log_bufs)\n{\n\tjournal_t *journal = transaction->t_journal;\n\tstruct buffer_head *descriptor;\n\tstruct jbd2_revoke_record_s *record;\n\tstruct jbd2_revoke_table_s *revoke;\n\tstruct list_head *hash_list;\n\tint i, offset, count;\n\n\tdescriptor = NULL;\n\toffset = 0;\n\tcount = 0;\n\n\t \n\trevoke = journal->j_revoke == journal->j_revoke_table[0] ?\n\t\tjournal->j_revoke_table[1] : journal->j_revoke_table[0];\n\n\tfor (i = 0; i < revoke->hash_size; i++) {\n\t\thash_list = &revoke->hash_table[i];\n\n\t\twhile (!list_empty(hash_list)) {\n\t\t\trecord = (struct jbd2_revoke_record_s *)\n\t\t\t\thash_list->next;\n\t\t\twrite_one_revoke_record(transaction, log_bufs,\n\t\t\t\t\t\t&descriptor, &offset, record);\n\t\t\tcount++;\n\t\t\tlist_del(&record->hash);\n\t\t\tkmem_cache_free(jbd2_revoke_record_cache, record);\n\t\t}\n\t}\n\tif (descriptor)\n\t\tflush_descriptor(journal, descriptor, offset);\n\tjbd2_debug(1, \"Wrote %d revoke records\\n\", count);\n}\n\n \n\nstatic void write_one_revoke_record(transaction_t *transaction,\n\t\t\t\t    struct list_head *log_bufs,\n\t\t\t\t    struct buffer_head **descriptorp,\n\t\t\t\t    int *offsetp,\n\t\t\t\t    struct jbd2_revoke_record_s *record)\n{\n\tjournal_t *journal = transaction->t_journal;\n\tint csum_size = 0;\n\tstruct buffer_head *descriptor;\n\tint sz, offset;\n\n\t \n\tif (is_journal_aborted(journal))\n\t\treturn;\n\n\tdescriptor = *descriptorp;\n\toffset = *offsetp;\n\n\t \n\tif (jbd2_journal_has_csum_v2or3(journal))\n\t\tcsum_size = sizeof(struct jbd2_journal_block_tail);\n\n\tif (jbd2_has_feature_64bit(journal))\n\t\tsz = 8;\n\telse\n\t\tsz = 4;\n\n\t \n\tif (descriptor) {\n\t\tif (offset + sz > journal->j_blocksize - csum_size) {\n\t\t\tflush_descriptor(journal, descriptor, offset);\n\t\t\tdescriptor = NULL;\n\t\t}\n\t}\n\n\tif (!descriptor) {\n\t\tdescriptor = jbd2_journal_get_descriptor_buffer(transaction,\n\t\t\t\t\t\t\tJBD2_REVOKE_BLOCK);\n\t\tif (!descriptor)\n\t\t\treturn;\n\n\t\t \n\t\tBUFFER_TRACE(descriptor, \"file in log_bufs\");\n\t\tjbd2_file_log_bh(log_bufs, descriptor);\n\n\t\toffset = sizeof(jbd2_journal_revoke_header_t);\n\t\t*descriptorp = descriptor;\n\t}\n\n\tif (jbd2_has_feature_64bit(journal))\n\t\t* ((__be64 *)(&descriptor->b_data[offset])) =\n\t\t\tcpu_to_be64(record->blocknr);\n\telse\n\t\t* ((__be32 *)(&descriptor->b_data[offset])) =\n\t\t\tcpu_to_be32(record->blocknr);\n\toffset += sz;\n\n\t*offsetp = offset;\n}\n\n \n\nstatic void flush_descriptor(journal_t *journal,\n\t\t\t     struct buffer_head *descriptor,\n\t\t\t     int offset)\n{\n\tjbd2_journal_revoke_header_t *header;\n\n\tif (is_journal_aborted(journal))\n\t\treturn;\n\n\theader = (jbd2_journal_revoke_header_t *)descriptor->b_data;\n\theader->r_count = cpu_to_be32(offset);\n\tjbd2_descriptor_block_csum_set(journal, descriptor);\n\n\tset_buffer_jwrite(descriptor);\n\tBUFFER_TRACE(descriptor, \"write\");\n\tset_buffer_dirty(descriptor);\n\twrite_dirty_buffer(descriptor, REQ_SYNC);\n}\n#endif\n\n \n\n \n\nint jbd2_journal_set_revoke(journal_t *journal,\n\t\t       unsigned long long blocknr,\n\t\t       tid_t sequence)\n{\n\tstruct jbd2_revoke_record_s *record;\n\n\trecord = find_revoke_record(journal, blocknr);\n\tif (record) {\n\t\t \n\t\tif (tid_gt(sequence, record->sequence))\n\t\t\trecord->sequence = sequence;\n\t\treturn 0;\n\t}\n\treturn insert_revoke_hash(journal, blocknr, sequence);\n}\n\n \n\nint jbd2_journal_test_revoke(journal_t *journal,\n\t\t\tunsigned long long blocknr,\n\t\t\ttid_t sequence)\n{\n\tstruct jbd2_revoke_record_s *record;\n\n\trecord = find_revoke_record(journal, blocknr);\n\tif (!record)\n\t\treturn 0;\n\tif (tid_gt(sequence, record->sequence))\n\t\treturn 0;\n\treturn 1;\n}\n\n \n\nvoid jbd2_journal_clear_revoke(journal_t *journal)\n{\n\tint i;\n\tstruct list_head *hash_list;\n\tstruct jbd2_revoke_record_s *record;\n\tstruct jbd2_revoke_table_s *revoke;\n\n\trevoke = journal->j_revoke;\n\n\tfor (i = 0; i < revoke->hash_size; i++) {\n\t\thash_list = &revoke->hash_table[i];\n\t\twhile (!list_empty(hash_list)) {\n\t\t\trecord = (struct jbd2_revoke_record_s*) hash_list->next;\n\t\t\tlist_del(&record->hash);\n\t\t\tkmem_cache_free(jbd2_revoke_record_cache, record);\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}