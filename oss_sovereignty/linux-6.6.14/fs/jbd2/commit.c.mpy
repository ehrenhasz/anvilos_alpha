{
  "module_name": "commit.c",
  "hash_id": "83e42ac00889dfcc9fe3d80fa203f08225211d090ef6000bb0c32f506aeb47da",
  "original_prompt": "Ingested from linux-6.6.14/fs/jbd2/commit.c",
  "human_readable_source": "\n \n\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/jbd2.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/pagemap.h>\n#include <linux/jiffies.h>\n#include <linux/crc32.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/bitops.h>\n#include <trace/events/jbd2.h>\n\n \nstatic void journal_end_buffer_io_sync(struct buffer_head *bh, int uptodate)\n{\n\tstruct buffer_head *orig_bh = bh->b_private;\n\n\tBUFFER_TRACE(bh, \"\");\n\tif (uptodate)\n\t\tset_buffer_uptodate(bh);\n\telse\n\t\tclear_buffer_uptodate(bh);\n\tif (orig_bh) {\n\t\tclear_bit_unlock(BH_Shadow, &orig_bh->b_state);\n\t\tsmp_mb__after_atomic();\n\t\twake_up_bit(&orig_bh->b_state, BH_Shadow);\n\t}\n\tunlock_buffer(bh);\n}\n\n \nstatic void release_buffer_page(struct buffer_head *bh)\n{\n\tstruct folio *folio;\n\n\tif (buffer_dirty(bh))\n\t\tgoto nope;\n\tif (atomic_read(&bh->b_count) != 1)\n\t\tgoto nope;\n\tfolio = bh->b_folio;\n\tif (folio->mapping)\n\t\tgoto nope;\n\n\t \n\tif (!folio_trylock(folio))\n\t\tgoto nope;\n\n\tfolio_get(folio);\n\t__brelse(bh);\n\ttry_to_free_buffers(folio);\n\tfolio_unlock(folio);\n\tfolio_put(folio);\n\treturn;\n\nnope:\n\t__brelse(bh);\n}\n\nstatic void jbd2_commit_block_csum_set(journal_t *j, struct buffer_head *bh)\n{\n\tstruct commit_header *h;\n\t__u32 csum;\n\n\tif (!jbd2_journal_has_csum_v2or3(j))\n\t\treturn;\n\n\th = (struct commit_header *)(bh->b_data);\n\th->h_chksum_type = 0;\n\th->h_chksum_size = 0;\n\th->h_chksum[0] = 0;\n\tcsum = jbd2_chksum(j, j->j_csum_seed, bh->b_data, j->j_blocksize);\n\th->h_chksum[0] = cpu_to_be32(csum);\n}\n\n \nstatic int journal_submit_commit_record(journal_t *journal,\n\t\t\t\t\ttransaction_t *commit_transaction,\n\t\t\t\t\tstruct buffer_head **cbh,\n\t\t\t\t\t__u32 crc32_sum)\n{\n\tstruct commit_header *tmp;\n\tstruct buffer_head *bh;\n\tstruct timespec64 now;\n\tblk_opf_t write_flags = REQ_OP_WRITE | JBD2_JOURNAL_REQ_FLAGS;\n\n\t*cbh = NULL;\n\n\tif (is_journal_aborted(journal))\n\t\treturn 0;\n\n\tbh = jbd2_journal_get_descriptor_buffer(commit_transaction,\n\t\t\t\t\t\tJBD2_COMMIT_BLOCK);\n\tif (!bh)\n\t\treturn 1;\n\n\ttmp = (struct commit_header *)bh->b_data;\n\tktime_get_coarse_real_ts64(&now);\n\ttmp->h_commit_sec = cpu_to_be64(now.tv_sec);\n\ttmp->h_commit_nsec = cpu_to_be32(now.tv_nsec);\n\n\tif (jbd2_has_feature_checksum(journal)) {\n\t\ttmp->h_chksum_type \t= JBD2_CRC32_CHKSUM;\n\t\ttmp->h_chksum_size \t= JBD2_CRC32_CHKSUM_SIZE;\n\t\ttmp->h_chksum[0] \t= cpu_to_be32(crc32_sum);\n\t}\n\tjbd2_commit_block_csum_set(journal, bh);\n\n\tBUFFER_TRACE(bh, \"submit commit block\");\n\tlock_buffer(bh);\n\tclear_buffer_dirty(bh);\n\tset_buffer_uptodate(bh);\n\tbh->b_end_io = journal_end_buffer_io_sync;\n\n\tif (journal->j_flags & JBD2_BARRIER &&\n\t    !jbd2_has_feature_async_commit(journal))\n\t\twrite_flags |= REQ_PREFLUSH | REQ_FUA;\n\n\tsubmit_bh(write_flags, bh);\n\t*cbh = bh;\n\treturn 0;\n}\n\n \nstatic int journal_wait_on_commit_record(journal_t *journal,\n\t\t\t\t\t struct buffer_head *bh)\n{\n\tint ret = 0;\n\n\tclear_buffer_dirty(bh);\n\twait_on_buffer(bh);\n\n\tif (unlikely(!buffer_uptodate(bh)))\n\t\tret = -EIO;\n\tput_bh(bh);             \n\n\treturn ret;\n}\n\n \nint jbd2_submit_inode_data(journal_t *journal, struct jbd2_inode *jinode)\n{\n\tif (!jinode || !(jinode->i_flags & JI_WRITE_DATA))\n\t\treturn 0;\n\n\ttrace_jbd2_submit_inode_data(jinode->i_vfs_inode);\n\treturn journal->j_submit_inode_data_buffers(jinode);\n\n}\nEXPORT_SYMBOL(jbd2_submit_inode_data);\n\nint jbd2_wait_inode_data(journal_t *journal, struct jbd2_inode *jinode)\n{\n\tif (!jinode || !(jinode->i_flags & JI_WAIT_DATA) ||\n\t\t!jinode->i_vfs_inode || !jinode->i_vfs_inode->i_mapping)\n\t\treturn 0;\n\treturn filemap_fdatawait_range_keep_errors(\n\t\tjinode->i_vfs_inode->i_mapping, jinode->i_dirty_start,\n\t\tjinode->i_dirty_end);\n}\nEXPORT_SYMBOL(jbd2_wait_inode_data);\n\n \nstatic int journal_submit_data_buffers(journal_t *journal,\n\t\ttransaction_t *commit_transaction)\n{\n\tstruct jbd2_inode *jinode;\n\tint err, ret = 0;\n\n\tspin_lock(&journal->j_list_lock);\n\tlist_for_each_entry(jinode, &commit_transaction->t_inode_list, i_list) {\n\t\tif (!(jinode->i_flags & JI_WRITE_DATA))\n\t\t\tcontinue;\n\t\tjinode->i_flags |= JI_COMMIT_RUNNING;\n\t\tspin_unlock(&journal->j_list_lock);\n\t\t \n\t\ttrace_jbd2_submit_inode_data(jinode->i_vfs_inode);\n\t\tif (journal->j_submit_inode_data_buffers) {\n\t\t\terr = journal->j_submit_inode_data_buffers(jinode);\n\t\t\tif (!ret)\n\t\t\t\tret = err;\n\t\t}\n\t\tspin_lock(&journal->j_list_lock);\n\t\tJ_ASSERT(jinode->i_transaction == commit_transaction);\n\t\tjinode->i_flags &= ~JI_COMMIT_RUNNING;\n\t\tsmp_mb();\n\t\twake_up_bit(&jinode->i_flags, __JI_COMMIT_RUNNING);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\treturn ret;\n}\n\nint jbd2_journal_finish_inode_data_buffers(struct jbd2_inode *jinode)\n{\n\tstruct address_space *mapping = jinode->i_vfs_inode->i_mapping;\n\n\treturn filemap_fdatawait_range_keep_errors(mapping,\n\t\t\t\t\t\t   jinode->i_dirty_start,\n\t\t\t\t\t\t   jinode->i_dirty_end);\n}\n\n \nstatic int journal_finish_inode_data_buffers(journal_t *journal,\n\t\ttransaction_t *commit_transaction)\n{\n\tstruct jbd2_inode *jinode, *next_i;\n\tint err, ret = 0;\n\n\t \n\tspin_lock(&journal->j_list_lock);\n\tlist_for_each_entry(jinode, &commit_transaction->t_inode_list, i_list) {\n\t\tif (!(jinode->i_flags & JI_WAIT_DATA))\n\t\t\tcontinue;\n\t\tjinode->i_flags |= JI_COMMIT_RUNNING;\n\t\tspin_unlock(&journal->j_list_lock);\n\t\t \n\t\tif (journal->j_finish_inode_data_buffers) {\n\t\t\terr = journal->j_finish_inode_data_buffers(jinode);\n\t\t\tif (!ret)\n\t\t\t\tret = err;\n\t\t}\n\t\tcond_resched();\n\t\tspin_lock(&journal->j_list_lock);\n\t\tjinode->i_flags &= ~JI_COMMIT_RUNNING;\n\t\tsmp_mb();\n\t\twake_up_bit(&jinode->i_flags, __JI_COMMIT_RUNNING);\n\t}\n\n\t \n\tlist_for_each_entry_safe(jinode, next_i,\n\t\t\t\t &commit_transaction->t_inode_list, i_list) {\n\t\tlist_del(&jinode->i_list);\n\t\tif (jinode->i_next_transaction) {\n\t\t\tjinode->i_transaction = jinode->i_next_transaction;\n\t\t\tjinode->i_next_transaction = NULL;\n\t\t\tlist_add(&jinode->i_list,\n\t\t\t\t&jinode->i_transaction->t_inode_list);\n\t\t} else {\n\t\t\tjinode->i_transaction = NULL;\n\t\t\tjinode->i_dirty_start = 0;\n\t\t\tjinode->i_dirty_end = 0;\n\t\t}\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\n\treturn ret;\n}\n\nstatic __u32 jbd2_checksum_data(__u32 crc32_sum, struct buffer_head *bh)\n{\n\tchar *addr;\n\t__u32 checksum;\n\n\taddr = kmap_local_folio(bh->b_folio, bh_offset(bh));\n\tchecksum = crc32_be(crc32_sum, addr, bh->b_size);\n\tkunmap_local(addr);\n\n\treturn checksum;\n}\n\nstatic void write_tag_block(journal_t *j, journal_block_tag_t *tag,\n\t\t\t\t   unsigned long long block)\n{\n\ttag->t_blocknr = cpu_to_be32(block & (u32)~0);\n\tif (jbd2_has_feature_64bit(j))\n\t\ttag->t_blocknr_high = cpu_to_be32((block >> 31) >> 1);\n}\n\nstatic void jbd2_block_tag_csum_set(journal_t *j, journal_block_tag_t *tag,\n\t\t\t\t    struct buffer_head *bh, __u32 sequence)\n{\n\tjournal_block_tag3_t *tag3 = (journal_block_tag3_t *)tag;\n\t__u8 *addr;\n\t__u32 csum32;\n\t__be32 seq;\n\n\tif (!jbd2_journal_has_csum_v2or3(j))\n\t\treturn;\n\n\tseq = cpu_to_be32(sequence);\n\taddr = kmap_local_folio(bh->b_folio, bh_offset(bh));\n\tcsum32 = jbd2_chksum(j, j->j_csum_seed, (__u8 *)&seq, sizeof(seq));\n\tcsum32 = jbd2_chksum(j, csum32, addr, bh->b_size);\n\tkunmap_local(addr);\n\n\tif (jbd2_has_feature_csum3(j))\n\t\ttag3->t_checksum = cpu_to_be32(csum32);\n\telse\n\t\ttag->t_checksum = cpu_to_be16(csum32);\n}\n \nvoid jbd2_journal_commit_transaction(journal_t *journal)\n{\n\tstruct transaction_stats_s stats;\n\ttransaction_t *commit_transaction;\n\tstruct journal_head *jh;\n\tstruct buffer_head *descriptor;\n\tstruct buffer_head **wbuf = journal->j_wbuf;\n\tint bufs;\n\tint flags;\n\tint err;\n\tunsigned long long blocknr;\n\tktime_t start_time;\n\tu64 commit_time;\n\tchar *tagp = NULL;\n\tjournal_block_tag_t *tag = NULL;\n\tint space_left = 0;\n\tint first_tag = 0;\n\tint tag_flag;\n\tint i;\n\tint tag_bytes = journal_tag_bytes(journal);\n\tstruct buffer_head *cbh = NULL;  \n\t__u32 crc32_sum = ~0;\n\tstruct blk_plug plug;\n\t \n\tunsigned long first_block;\n\ttid_t first_tid;\n\tint update_tail;\n\tint csum_size = 0;\n\tLIST_HEAD(io_bufs);\n\tLIST_HEAD(log_bufs);\n\n\tif (jbd2_journal_has_csum_v2or3(journal))\n\t\tcsum_size = sizeof(struct jbd2_journal_block_tail);\n\n\t \n\n\t \n\tif (journal->j_flags & JBD2_FLUSHED) {\n\t\tjbd2_debug(3, \"super block updated\\n\");\n\t\tmutex_lock_io(&journal->j_checkpoint_mutex);\n\t\t \n\t\tjbd2_journal_update_sb_log_tail(journal,\n\t\t\t\t\t\tjournal->j_tail_sequence,\n\t\t\t\t\t\tjournal->j_tail, 0);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t} else {\n\t\tjbd2_debug(3, \"superblock not updated\\n\");\n\t}\n\n\tJ_ASSERT(journal->j_running_transaction != NULL);\n\tJ_ASSERT(journal->j_committing_transaction == NULL);\n\n\twrite_lock(&journal->j_state_lock);\n\tjournal->j_flags |= JBD2_FULL_COMMIT_ONGOING;\n\twhile (journal->j_flags & JBD2_FAST_COMMIT_ONGOING) {\n\t\tDEFINE_WAIT(wait);\n\n\t\tprepare_to_wait(&journal->j_fc_wait, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tschedule();\n\t\twrite_lock(&journal->j_state_lock);\n\t\tfinish_wait(&journal->j_fc_wait, &wait);\n\t\t \n\t}\n\twrite_unlock(&journal->j_state_lock);\n\n\tcommit_transaction = journal->j_running_transaction;\n\n\ttrace_jbd2_start_commit(journal, commit_transaction);\n\tjbd2_debug(1, \"JBD2: starting commit of transaction %d\\n\",\n\t\t\tcommit_transaction->t_tid);\n\n\twrite_lock(&journal->j_state_lock);\n\tjournal->j_fc_off = 0;\n\tJ_ASSERT(commit_transaction->t_state == T_RUNNING);\n\tcommit_transaction->t_state = T_LOCKED;\n\n\ttrace_jbd2_commit_locking(journal, commit_transaction);\n\tstats.run.rs_wait = commit_transaction->t_max_wait;\n\tstats.run.rs_request_delay = 0;\n\tstats.run.rs_locked = jiffies;\n\tif (commit_transaction->t_requested)\n\t\tstats.run.rs_request_delay =\n\t\t\tjbd2_time_diff(commit_transaction->t_requested,\n\t\t\t\t       stats.run.rs_locked);\n\tstats.run.rs_running = jbd2_time_diff(commit_transaction->t_start,\n\t\t\t\t\t      stats.run.rs_locked);\n\n\t \n\tjbd2_journal_wait_updates(journal);\n\n\tcommit_transaction->t_state = T_SWITCH;\n\n\tJ_ASSERT (atomic_read(&commit_transaction->t_outstanding_credits) <=\n\t\t\tjournal->j_max_transaction_buffers);\n\n\t \n\twhile (commit_transaction->t_reserved_list) {\n\t\tjh = commit_transaction->t_reserved_list;\n\t\tJBUFFER_TRACE(jh, \"reserved, unused: refile\");\n\t\t \n\t\tif (jh->b_committed_data) {\n\t\t\tstruct buffer_head *bh = jh2bh(jh);\n\n\t\t\tspin_lock(&jh->b_state_lock);\n\t\t\tjbd2_free(jh->b_committed_data, bh->b_size);\n\t\t\tjh->b_committed_data = NULL;\n\t\t\tspin_unlock(&jh->b_state_lock);\n\t\t}\n\t\tjbd2_journal_refile_buffer(journal, jh);\n\t}\n\n\twrite_unlock(&journal->j_state_lock);\n\t \n\tspin_lock(&journal->j_list_lock);\n\t__jbd2_journal_clean_checkpoint_list(journal, false);\n\tspin_unlock(&journal->j_list_lock);\n\n\tjbd2_debug(3, \"JBD2: commit phase 1\\n\");\n\n\t \n\tjbd2_clear_buffer_revoked_flags(journal);\n\n\t \n\tjbd2_journal_switch_revoke_table(journal);\n\n\twrite_lock(&journal->j_state_lock);\n\t \n\tatomic_sub(atomic_read(&journal->j_reserved_credits),\n\t\t   &commit_transaction->t_outstanding_credits);\n\n\ttrace_jbd2_commit_flushing(journal, commit_transaction);\n\tstats.run.rs_flushing = jiffies;\n\tstats.run.rs_locked = jbd2_time_diff(stats.run.rs_locked,\n\t\t\t\t\t     stats.run.rs_flushing);\n\n\tcommit_transaction->t_state = T_FLUSH;\n\tjournal->j_committing_transaction = commit_transaction;\n\tjournal->j_running_transaction = NULL;\n\tstart_time = ktime_get();\n\tcommit_transaction->t_log_start = journal->j_head;\n\twake_up_all(&journal->j_wait_transaction_locked);\n\twrite_unlock(&journal->j_state_lock);\n\n\tjbd2_debug(3, \"JBD2: commit phase 2a\\n\");\n\n\t \n\terr = journal_submit_data_buffers(journal, commit_transaction);\n\tif (err)\n\t\tjbd2_journal_abort(journal, err);\n\n\tblk_start_plug(&plug);\n\tjbd2_journal_write_revoke_records(commit_transaction, &log_bufs);\n\n\tjbd2_debug(3, \"JBD2: commit phase 2b\\n\");\n\n\t \n\twrite_lock(&journal->j_state_lock);\n\tcommit_transaction->t_state = T_COMMIT;\n\twrite_unlock(&journal->j_state_lock);\n\n\ttrace_jbd2_commit_logging(journal, commit_transaction);\n\tstats.run.rs_logging = jiffies;\n\tstats.run.rs_flushing = jbd2_time_diff(stats.run.rs_flushing,\n\t\t\t\t\t       stats.run.rs_logging);\n\tstats.run.rs_blocks = commit_transaction->t_nr_buffers;\n\tstats.run.rs_blocks_logged = 0;\n\n\tJ_ASSERT(commit_transaction->t_nr_buffers <=\n\t\t atomic_read(&commit_transaction->t_outstanding_credits));\n\n\terr = 0;\n\tbufs = 0;\n\tdescriptor = NULL;\n\twhile (commit_transaction->t_buffers) {\n\n\t\t \n\n\t\tjh = commit_transaction->t_buffers;\n\n\t\t \n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tclear_buffer_jbddirty(jh2bh(jh));\n\t\t\tJBUFFER_TRACE(jh, \"journal is aborting: refile\");\n\t\t\tjbd2_buffer_abort_trigger(jh,\n\t\t\t\t\t\t  jh->b_frozen_data ?\n\t\t\t\t\t\t  jh->b_frozen_triggers :\n\t\t\t\t\t\t  jh->b_triggers);\n\t\t\tjbd2_journal_refile_buffer(journal, jh);\n\t\t\t \n\t\t\tif (!commit_transaction->t_buffers)\n\t\t\t\tgoto start_journal_io;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\n\t\tif (!descriptor) {\n\t\t\tJ_ASSERT (bufs == 0);\n\n\t\t\tjbd2_debug(4, \"JBD2: get descriptor\\n\");\n\n\t\t\tdescriptor = jbd2_journal_get_descriptor_buffer(\n\t\t\t\t\t\t\tcommit_transaction,\n\t\t\t\t\t\t\tJBD2_DESCRIPTOR_BLOCK);\n\t\t\tif (!descriptor) {\n\t\t\t\tjbd2_journal_abort(journal, -EIO);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tjbd2_debug(4, \"JBD2: got buffer %llu (%p)\\n\",\n\t\t\t\t(unsigned long long)descriptor->b_blocknr,\n\t\t\t\tdescriptor->b_data);\n\t\t\ttagp = &descriptor->b_data[sizeof(journal_header_t)];\n\t\t\tspace_left = descriptor->b_size -\n\t\t\t\t\t\tsizeof(journal_header_t);\n\t\t\tfirst_tag = 1;\n\t\t\tset_buffer_jwrite(descriptor);\n\t\t\tset_buffer_dirty(descriptor);\n\t\t\twbuf[bufs++] = descriptor;\n\n\t\t\t \n\t\t\tBUFFER_TRACE(descriptor, \"ph3: file as descriptor\");\n\t\t\tjbd2_file_log_bh(&log_bufs, descriptor);\n\t\t}\n\n\t\t \n\n\t\terr = jbd2_journal_next_log_block(journal, &blocknr);\n\t\t \n\t\tif (err) {\n\t\t\tjbd2_journal_abort(journal, err);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tatomic_dec(&commit_transaction->t_outstanding_credits);\n\n\t\t \n\t\tatomic_inc(&jh2bh(jh)->b_count);\n\n\t\t \n\t\tset_bit(BH_JWrite, &jh2bh(jh)->b_state);\n\t\tJBUFFER_TRACE(jh, \"ph3: write metadata\");\n\t\tflags = jbd2_journal_write_metadata_buffer(commit_transaction,\n\t\t\t\t\t\tjh, &wbuf[bufs], blocknr);\n\t\tif (flags < 0) {\n\t\t\tjbd2_journal_abort(journal, flags);\n\t\t\tcontinue;\n\t\t}\n\t\tjbd2_file_log_bh(&io_bufs, wbuf[bufs]);\n\n\t\t \n\n\t\ttag_flag = 0;\n\t\tif (flags & 1)\n\t\t\ttag_flag |= JBD2_FLAG_ESCAPE;\n\t\tif (!first_tag)\n\t\t\ttag_flag |= JBD2_FLAG_SAME_UUID;\n\n\t\ttag = (journal_block_tag_t *) tagp;\n\t\twrite_tag_block(journal, tag, jh2bh(jh)->b_blocknr);\n\t\ttag->t_flags = cpu_to_be16(tag_flag);\n\t\tjbd2_block_tag_csum_set(journal, tag, wbuf[bufs],\n\t\t\t\t\tcommit_transaction->t_tid);\n\t\ttagp += tag_bytes;\n\t\tspace_left -= tag_bytes;\n\t\tbufs++;\n\n\t\tif (first_tag) {\n\t\t\tmemcpy (tagp, journal->j_uuid, 16);\n\t\t\ttagp += 16;\n\t\t\tspace_left -= 16;\n\t\t\tfirst_tag = 0;\n\t\t}\n\n\t\t \n\n\t\tif (bufs == journal->j_wbufsize ||\n\t\t    commit_transaction->t_buffers == NULL ||\n\t\t    space_left < tag_bytes + 16 + csum_size) {\n\n\t\t\tjbd2_debug(4, \"JBD2: Submit %d IOs\\n\", bufs);\n\n\t\t\t \n\n\t\t\ttag->t_flags |= cpu_to_be16(JBD2_FLAG_LAST_TAG);\nstart_journal_io:\n\t\t\tif (descriptor)\n\t\t\t\tjbd2_descriptor_block_csum_set(journal,\n\t\t\t\t\t\t\tdescriptor);\n\n\t\t\tfor (i = 0; i < bufs; i++) {\n\t\t\t\tstruct buffer_head *bh = wbuf[i];\n\n\t\t\t\t \n\t\t\t\tif (jbd2_has_feature_checksum(journal)) {\n\t\t\t\t\tcrc32_sum =\n\t\t\t\t\t    jbd2_checksum_data(crc32_sum, bh);\n\t\t\t\t}\n\n\t\t\t\tlock_buffer(bh);\n\t\t\t\tclear_buffer_dirty(bh);\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tbh->b_end_io = journal_end_buffer_io_sync;\n\t\t\t\tsubmit_bh(REQ_OP_WRITE | JBD2_JOURNAL_REQ_FLAGS,\n\t\t\t\t\t  bh);\n\t\t\t}\n\t\t\tcond_resched();\n\n\t\t\t \n\t\t\tdescriptor = NULL;\n\t\t\tbufs = 0;\n\t\t}\n\t}\n\n\terr = journal_finish_inode_data_buffers(journal, commit_transaction);\n\tif (err) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"JBD2: Detected IO errors while flushing file data \"\n\t\t       \"on %s\\n\", journal->j_devname);\n\t\tif (journal->j_flags & JBD2_ABORT_ON_SYNCDATA_ERR)\n\t\t\tjbd2_journal_abort(journal, err);\n\t\terr = 0;\n\t}\n\n\t \n\tupdate_tail =\n\t\tjbd2_journal_get_log_tail(journal, &first_tid, &first_block);\n\n\twrite_lock(&journal->j_state_lock);\n\tif (update_tail) {\n\t\tlong freed = first_block - journal->j_tail;\n\n\t\tif (first_block < journal->j_tail)\n\t\t\tfreed += journal->j_last - journal->j_first;\n\t\t \n\t\tif (freed < jbd2_journal_get_max_txn_bufs(journal))\n\t\t\tupdate_tail = 0;\n\t}\n\tJ_ASSERT(commit_transaction->t_state == T_COMMIT);\n\tcommit_transaction->t_state = T_COMMIT_DFLUSH;\n\twrite_unlock(&journal->j_state_lock);\n\n\t \n\tif (commit_transaction->t_need_data_flush &&\n\t    (journal->j_fs_dev != journal->j_dev) &&\n\t    (journal->j_flags & JBD2_BARRIER))\n\t\tblkdev_issue_flush(journal->j_fs_dev);\n\n\t \n\tif (jbd2_has_feature_async_commit(journal)) {\n\t\terr = journal_submit_commit_record(journal, commit_transaction,\n\t\t\t\t\t\t &cbh, crc32_sum);\n\t\tif (err)\n\t\t\tjbd2_journal_abort(journal, err);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\t \n\n\tjbd2_debug(3, \"JBD2: commit phase 3\\n\");\n\n\twhile (!list_empty(&io_bufs)) {\n\t\tstruct buffer_head *bh = list_entry(io_bufs.prev,\n\t\t\t\t\t\t    struct buffer_head,\n\t\t\t\t\t\t    b_assoc_buffers);\n\n\t\twait_on_buffer(bh);\n\t\tcond_resched();\n\n\t\tif (unlikely(!buffer_uptodate(bh)))\n\t\t\terr = -EIO;\n\t\tjbd2_unfile_log_bh(bh);\n\t\tstats.run.rs_blocks_logged++;\n\n\t\t \n\t\tBUFFER_TRACE(bh, \"dumping temporary bh\");\n\t\t__brelse(bh);\n\t\tJ_ASSERT_BH(bh, atomic_read(&bh->b_count) == 0);\n\t\tfree_buffer_head(bh);\n\n\t\t \n\t\tjh = commit_transaction->t_shadow_list->b_tprev;\n\t\tbh = jh2bh(jh);\n\t\tclear_buffer_jwrite(bh);\n\t\tJ_ASSERT_BH(bh, buffer_jbddirty(bh));\n\t\tJ_ASSERT_BH(bh, !buffer_shadow(bh));\n\n\t\t \n\t\tJBUFFER_TRACE(jh, \"file as BJ_Forget\");\n\t\tjbd2_journal_file_buffer(jh, commit_transaction, BJ_Forget);\n\t\tJBUFFER_TRACE(jh, \"brelse shadowed buffer\");\n\t\t__brelse(bh);\n\t}\n\n\tJ_ASSERT (commit_transaction->t_shadow_list == NULL);\n\n\tjbd2_debug(3, \"JBD2: commit phase 4\\n\");\n\n\t \n\twhile (!list_empty(&log_bufs)) {\n\t\tstruct buffer_head *bh;\n\n\t\tbh = list_entry(log_bufs.prev, struct buffer_head, b_assoc_buffers);\n\t\twait_on_buffer(bh);\n\t\tcond_resched();\n\n\t\tif (unlikely(!buffer_uptodate(bh)))\n\t\t\terr = -EIO;\n\n\t\tBUFFER_TRACE(bh, \"ph5: control buffer writeout done: unfile\");\n\t\tclear_buffer_jwrite(bh);\n\t\tjbd2_unfile_log_bh(bh);\n\t\tstats.run.rs_blocks_logged++;\n\t\t__brelse(bh);\t\t \n\t\t \n\t}\n\n\tif (err)\n\t\tjbd2_journal_abort(journal, err);\n\n\tjbd2_debug(3, \"JBD2: commit phase 5\\n\");\n\twrite_lock(&journal->j_state_lock);\n\tJ_ASSERT(commit_transaction->t_state == T_COMMIT_DFLUSH);\n\tcommit_transaction->t_state = T_COMMIT_JFLUSH;\n\twrite_unlock(&journal->j_state_lock);\n\n\tif (!jbd2_has_feature_async_commit(journal)) {\n\t\terr = journal_submit_commit_record(journal, commit_transaction,\n\t\t\t\t\t\t&cbh, crc32_sum);\n\t\tif (err)\n\t\t\tjbd2_journal_abort(journal, err);\n\t}\n\tif (cbh)\n\t\terr = journal_wait_on_commit_record(journal, cbh);\n\tstats.run.rs_blocks_logged++;\n\tif (jbd2_has_feature_async_commit(journal) &&\n\t    journal->j_flags & JBD2_BARRIER) {\n\t\tblkdev_issue_flush(journal->j_dev);\n\t}\n\n\tif (err)\n\t\tjbd2_journal_abort(journal, err);\n\n\tWARN_ON_ONCE(\n\t\tatomic_read(&commit_transaction->t_outstanding_credits) < 0);\n\n\t \n\tif (update_tail)\n\t\tjbd2_update_log_tail(journal, first_tid, first_block);\n\n\t \n\n\tjbd2_debug(3, \"JBD2: commit phase 6\\n\");\n\n\tJ_ASSERT(list_empty(&commit_transaction->t_inode_list));\n\tJ_ASSERT(commit_transaction->t_buffers == NULL);\n\tJ_ASSERT(commit_transaction->t_checkpoint_list == NULL);\n\tJ_ASSERT(commit_transaction->t_shadow_list == NULL);\n\nrestart_loop:\n\t \n\tspin_lock(&journal->j_list_lock);\n\twhile (commit_transaction->t_forget) {\n\t\ttransaction_t *cp_transaction;\n\t\tstruct buffer_head *bh;\n\t\tint try_to_free = 0;\n\t\tbool drop_ref;\n\n\t\tjh = commit_transaction->t_forget;\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tbh = jh2bh(jh);\n\t\t \n\t\tget_bh(bh);\n\t\tspin_lock(&jh->b_state_lock);\n\t\tJ_ASSERT_JH(jh,\tjh->b_transaction == commit_transaction);\n\n\t\t \n\t\tif (jh->b_committed_data) {\n\t\t\tjbd2_free(jh->b_committed_data, bh->b_size);\n\t\t\tjh->b_committed_data = NULL;\n\t\t\tif (jh->b_frozen_data) {\n\t\t\t\tjh->b_committed_data = jh->b_frozen_data;\n\t\t\t\tjh->b_frozen_data = NULL;\n\t\t\t\tjh->b_frozen_triggers = NULL;\n\t\t\t}\n\t\t} else if (jh->b_frozen_data) {\n\t\t\tjbd2_free(jh->b_frozen_data, bh->b_size);\n\t\t\tjh->b_frozen_data = NULL;\n\t\t\tjh->b_frozen_triggers = NULL;\n\t\t}\n\n\t\tspin_lock(&journal->j_list_lock);\n\t\tcp_transaction = jh->b_cp_transaction;\n\t\tif (cp_transaction) {\n\t\t\tJBUFFER_TRACE(jh, \"remove from old cp transaction\");\n\t\t\tcp_transaction->t_chp_stats.cs_dropped++;\n\t\t\t__jbd2_journal_remove_checkpoint(jh);\n\t\t}\n\n\t\t \n\n\t\t \n\t\tif (buffer_freed(bh) && !jh->b_next_transaction) {\n\t\t\tstruct address_space *mapping;\n\n\t\t\tclear_buffer_freed(bh);\n\t\t\tclear_buffer_jbddirty(bh);\n\n\t\t\t \n\t\t\tmapping = READ_ONCE(bh->b_folio->mapping);\n\t\t\tif (mapping && !sb_is_blkdev_sb(mapping->host->i_sb)) {\n\t\t\t\tclear_buffer_mapped(bh);\n\t\t\t\tclear_buffer_new(bh);\n\t\t\t\tclear_buffer_req(bh);\n\t\t\t\tbh->b_bdev = NULL;\n\t\t\t}\n\t\t}\n\n\t\tif (buffer_jbddirty(bh)) {\n\t\t\tJBUFFER_TRACE(jh, \"add to new checkpointing trans\");\n\t\t\t__jbd2_journal_insert_checkpoint(jh, commit_transaction);\n\t\t\tif (is_journal_aborted(journal))\n\t\t\t\tclear_buffer_jbddirty(bh);\n\t\t} else {\n\t\t\tJ_ASSERT_BH(bh, !buffer_dirty(bh));\n\t\t\t \n\t\t\tif (!jh->b_next_transaction)\n\t\t\t\ttry_to_free = 1;\n\t\t}\n\t\tJBUFFER_TRACE(jh, \"refile or unfile buffer\");\n\t\tdrop_ref = __jbd2_journal_refile_buffer(jh);\n\t\tspin_unlock(&jh->b_state_lock);\n\t\tif (drop_ref)\n\t\t\tjbd2_journal_put_journal_head(jh);\n\t\tif (try_to_free)\n\t\t\trelease_buffer_page(bh);\t \n\t\telse\n\t\t\t__brelse(bh);\n\t\tcond_resched_lock(&journal->j_list_lock);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\t \n\twrite_lock(&journal->j_state_lock);\n\tspin_lock(&journal->j_list_lock);\n\t \n\tif (commit_transaction->t_forget) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tgoto restart_loop;\n\t}\n\n\t \n\tif (journal->j_checkpoint_transactions == NULL) {\n\t\tjournal->j_checkpoint_transactions = commit_transaction;\n\t\tcommit_transaction->t_cpnext = commit_transaction;\n\t\tcommit_transaction->t_cpprev = commit_transaction;\n\t} else {\n\t\tcommit_transaction->t_cpnext =\n\t\t\tjournal->j_checkpoint_transactions;\n\t\tcommit_transaction->t_cpprev =\n\t\t\tcommit_transaction->t_cpnext->t_cpprev;\n\t\tcommit_transaction->t_cpnext->t_cpprev =\n\t\t\tcommit_transaction;\n\t\tcommit_transaction->t_cpprev->t_cpnext =\n\t\t\t\tcommit_transaction;\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\n\t \n\n\tjbd2_debug(3, \"JBD2: commit phase 7\\n\");\n\n\tJ_ASSERT(commit_transaction->t_state == T_COMMIT_JFLUSH);\n\n\tcommit_transaction->t_start = jiffies;\n\tstats.run.rs_logging = jbd2_time_diff(stats.run.rs_logging,\n\t\t\t\t\t      commit_transaction->t_start);\n\n\t \n\tstats.ts_tid = commit_transaction->t_tid;\n\tstats.run.rs_handle_count =\n\t\tatomic_read(&commit_transaction->t_handle_count);\n\ttrace_jbd2_run_stats(journal->j_fs_dev->bd_dev,\n\t\t\t     commit_transaction->t_tid, &stats.run);\n\tstats.ts_requested = (commit_transaction->t_requested) ? 1 : 0;\n\n\tcommit_transaction->t_state = T_COMMIT_CALLBACK;\n\tJ_ASSERT(commit_transaction == journal->j_committing_transaction);\n\tjournal->j_commit_sequence = commit_transaction->t_tid;\n\tjournal->j_committing_transaction = NULL;\n\tcommit_time = ktime_to_ns(ktime_sub(ktime_get(), start_time));\n\n\t \n\tif (likely(journal->j_average_commit_time))\n\t\tjournal->j_average_commit_time = (commit_time +\n\t\t\t\tjournal->j_average_commit_time*3) / 4;\n\telse\n\t\tjournal->j_average_commit_time = commit_time;\n\n\twrite_unlock(&journal->j_state_lock);\n\n\tif (journal->j_commit_callback)\n\t\tjournal->j_commit_callback(journal, commit_transaction);\n\tif (journal->j_fc_cleanup_callback)\n\t\tjournal->j_fc_cleanup_callback(journal, 1, commit_transaction->t_tid);\n\n\ttrace_jbd2_end_commit(journal, commit_transaction);\n\tjbd2_debug(1, \"JBD2: commit %d complete, head %d\\n\",\n\t\t  journal->j_commit_sequence, journal->j_tail_sequence);\n\n\twrite_lock(&journal->j_state_lock);\n\tjournal->j_flags &= ~JBD2_FULL_COMMIT_ONGOING;\n\tjournal->j_flags &= ~JBD2_FAST_COMMIT_ONGOING;\n\tspin_lock(&journal->j_list_lock);\n\tcommit_transaction->t_state = T_FINISHED;\n\t \n\tif (commit_transaction->t_checkpoint_list == NULL) {\n\t\t__jbd2_journal_drop_transaction(journal, commit_transaction);\n\t\tjbd2_journal_free_transaction(commit_transaction);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\twrite_unlock(&journal->j_state_lock);\n\twake_up(&journal->j_wait_done_commit);\n\twake_up(&journal->j_fc_wait);\n\n\t \n\tspin_lock(&journal->j_history_lock);\n\tjournal->j_stats.ts_tid++;\n\tjournal->j_stats.ts_requested += stats.ts_requested;\n\tjournal->j_stats.run.rs_wait += stats.run.rs_wait;\n\tjournal->j_stats.run.rs_request_delay += stats.run.rs_request_delay;\n\tjournal->j_stats.run.rs_running += stats.run.rs_running;\n\tjournal->j_stats.run.rs_locked += stats.run.rs_locked;\n\tjournal->j_stats.run.rs_flushing += stats.run.rs_flushing;\n\tjournal->j_stats.run.rs_logging += stats.run.rs_logging;\n\tjournal->j_stats.run.rs_handle_count += stats.run.rs_handle_count;\n\tjournal->j_stats.run.rs_blocks += stats.run.rs_blocks;\n\tjournal->j_stats.run.rs_blocks_logged += stats.run.rs_blocks_logged;\n\tspin_unlock(&journal->j_history_lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}