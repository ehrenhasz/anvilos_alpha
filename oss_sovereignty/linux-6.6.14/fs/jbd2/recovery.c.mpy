{
  "module_name": "recovery.c",
  "hash_id": "bcb97cfeabb27ef34f53bad2292f1cabd5932d7ac4586e21a3839d8bd4b431cd",
  "original_prompt": "Ingested from linux-6.6.14/fs/jbd2/recovery.c",
  "human_readable_source": "\n \n\n#ifndef __KERNEL__\n#include \"jfs_user.h\"\n#else\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/jbd2.h>\n#include <linux/errno.h>\n#include <linux/crc32.h>\n#include <linux/blkdev.h>\n#endif\n\n \nstruct recovery_info\n{\n\ttid_t\t\tstart_transaction;\n\ttid_t\t\tend_transaction;\n\tunsigned long\thead_block;\n\n\tint\t\tnr_replays;\n\tint\t\tnr_revokes;\n\tint\t\tnr_revoke_hits;\n};\n\nstatic int do_one_pass(journal_t *journal,\n\t\t\t\tstruct recovery_info *info, enum passtype pass);\nstatic int scan_revoke_records(journal_t *, struct buffer_head *,\n\t\t\t\ttid_t, struct recovery_info *);\n\n#ifdef __KERNEL__\n\n \nstatic void journal_brelse_array(struct buffer_head *b[], int n)\n{\n\twhile (--n >= 0)\n\t\tbrelse (b[n]);\n}\n\n\n \n\n#define MAXBUF 8\nstatic int do_readahead(journal_t *journal, unsigned int start)\n{\n\tint err;\n\tunsigned int max, nbufs, next;\n\tunsigned long long blocknr;\n\tstruct buffer_head *bh;\n\n\tstruct buffer_head * bufs[MAXBUF];\n\n\t \n\tmax = start + (128 * 1024 / journal->j_blocksize);\n\tif (max > journal->j_total_len)\n\t\tmax = journal->j_total_len;\n\n\t \n\n\tnbufs = 0;\n\n\tfor (next = start; next < max; next++) {\n\t\terr = jbd2_journal_bmap(journal, next, &blocknr);\n\n\t\tif (err) {\n\t\t\tprintk(KERN_ERR \"JBD2: bad block at offset %u\\n\",\n\t\t\t\tnext);\n\t\t\tgoto failed;\n\t\t}\n\n\t\tbh = __getblk(journal->j_dev, blocknr, journal->j_blocksize);\n\t\tif (!bh) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto failed;\n\t\t}\n\n\t\tif (!buffer_uptodate(bh) && !buffer_locked(bh)) {\n\t\t\tbufs[nbufs++] = bh;\n\t\t\tif (nbufs == MAXBUF) {\n\t\t\t\tbh_readahead_batch(nbufs, bufs, 0);\n\t\t\t\tjournal_brelse_array(bufs, nbufs);\n\t\t\t\tnbufs = 0;\n\t\t\t}\n\t\t} else\n\t\t\tbrelse(bh);\n\t}\n\n\tif (nbufs)\n\t\tbh_readahead_batch(nbufs, bufs, 0);\n\terr = 0;\n\nfailed:\n\tif (nbufs)\n\t\tjournal_brelse_array(bufs, nbufs);\n\treturn err;\n}\n\n#endif  \n\n\n \n\nstatic int jread(struct buffer_head **bhp, journal_t *journal,\n\t\t unsigned int offset)\n{\n\tint err;\n\tunsigned long long blocknr;\n\tstruct buffer_head *bh;\n\n\t*bhp = NULL;\n\n\tif (offset >= journal->j_total_len) {\n\t\tprintk(KERN_ERR \"JBD2: corrupted journal superblock\\n\");\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\terr = jbd2_journal_bmap(journal, offset, &blocknr);\n\n\tif (err) {\n\t\tprintk(KERN_ERR \"JBD2: bad block at offset %u\\n\",\n\t\t\toffset);\n\t\treturn err;\n\t}\n\n\tbh = __getblk(journal->j_dev, blocknr, journal->j_blocksize);\n\tif (!bh)\n\t\treturn -ENOMEM;\n\n\tif (!buffer_uptodate(bh)) {\n\t\t \n\t\tbool need_readahead = !buffer_req(bh);\n\n\t\tbh_read_nowait(bh, 0);\n\t\tif (need_readahead)\n\t\t\tdo_readahead(journal, offset);\n\t\twait_on_buffer(bh);\n\t}\n\n\tif (!buffer_uptodate(bh)) {\n\t\tprintk(KERN_ERR \"JBD2: Failed to read block at offset %u\\n\",\n\t\t\toffset);\n\t\tbrelse(bh);\n\t\treturn -EIO;\n\t}\n\n\t*bhp = bh;\n\treturn 0;\n}\n\nstatic int jbd2_descriptor_block_csum_verify(journal_t *j, void *buf)\n{\n\tstruct jbd2_journal_block_tail *tail;\n\t__be32 provided;\n\t__u32 calculated;\n\n\tif (!jbd2_journal_has_csum_v2or3(j))\n\t\treturn 1;\n\n\ttail = (struct jbd2_journal_block_tail *)((char *)buf +\n\t\tj->j_blocksize - sizeof(struct jbd2_journal_block_tail));\n\tprovided = tail->t_checksum;\n\ttail->t_checksum = 0;\n\tcalculated = jbd2_chksum(j, j->j_csum_seed, buf, j->j_blocksize);\n\ttail->t_checksum = provided;\n\n\treturn provided == cpu_to_be32(calculated);\n}\n\n \n\nstatic int count_tags(journal_t *journal, struct buffer_head *bh)\n{\n\tchar *\t\t\ttagp;\n\tjournal_block_tag_t\ttag;\n\tint\t\t\tnr = 0, size = journal->j_blocksize;\n\tint\t\t\ttag_bytes = journal_tag_bytes(journal);\n\n\tif (jbd2_journal_has_csum_v2or3(journal))\n\t\tsize -= sizeof(struct jbd2_journal_block_tail);\n\n\ttagp = &bh->b_data[sizeof(journal_header_t)];\n\n\twhile ((tagp - bh->b_data + tag_bytes) <= size) {\n\t\tmemcpy(&tag, tagp, sizeof(tag));\n\n\t\tnr++;\n\t\ttagp += tag_bytes;\n\t\tif (!(tag.t_flags & cpu_to_be16(JBD2_FLAG_SAME_UUID)))\n\t\t\ttagp += 16;\n\n\t\tif (tag.t_flags & cpu_to_be16(JBD2_FLAG_LAST_TAG))\n\t\t\tbreak;\n\t}\n\n\treturn nr;\n}\n\n\n \n#define wrap(journal, var)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (var >= (journal)->j_last)\t\t\t\t\t\\\n\t\tvar -= ((journal)->j_last - (journal)->j_first);\t\\\n} while (0)\n\nstatic int fc_do_one_pass(journal_t *journal,\n\t\t\t  struct recovery_info *info, enum passtype pass)\n{\n\tunsigned int expected_commit_id = info->end_transaction;\n\tunsigned long next_fc_block;\n\tstruct buffer_head *bh;\n\tint err = 0;\n\n\tnext_fc_block = journal->j_fc_first;\n\tif (!journal->j_fc_replay_callback)\n\t\treturn 0;\n\n\twhile (next_fc_block <= journal->j_fc_last) {\n\t\tjbd2_debug(3, \"Fast commit replay: next block %ld\\n\",\n\t\t\t  next_fc_block);\n\t\terr = jread(&bh, journal, next_fc_block);\n\t\tif (err) {\n\t\t\tjbd2_debug(3, \"Fast commit replay: read error\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\terr = journal->j_fc_replay_callback(journal, bh, pass,\n\t\t\t\t\tnext_fc_block - journal->j_fc_first,\n\t\t\t\t\texpected_commit_id);\n\t\tbrelse(bh);\n\t\tnext_fc_block++;\n\t\tif (err < 0 || err == JBD2_FC_REPLAY_STOP)\n\t\t\tbreak;\n\t\terr = 0;\n\t}\n\n\tif (err)\n\t\tjbd2_debug(3, \"Fast commit replay failed, err = %d\\n\", err);\n\n\treturn err;\n}\n\n \nint jbd2_journal_recover(journal_t *journal)\n{\n\tint\t\t\terr, err2;\n\tjournal_superblock_t *\tsb;\n\n\tstruct recovery_info\tinfo;\n\terrseq_t\t\twb_err;\n\tstruct address_space\t*mapping;\n\n\tmemset(&info, 0, sizeof(info));\n\tsb = journal->j_superblock;\n\n\t \n\tif (!sb->s_start) {\n\t\tjbd2_debug(1, \"No recovery required, last transaction %d, head block %u\\n\",\n\t\t\t  be32_to_cpu(sb->s_sequence), be32_to_cpu(sb->s_head));\n\t\tjournal->j_transaction_sequence = be32_to_cpu(sb->s_sequence) + 1;\n\t\tjournal->j_head = be32_to_cpu(sb->s_head);\n\t\treturn 0;\n\t}\n\n\twb_err = 0;\n\tmapping = journal->j_fs_dev->bd_inode->i_mapping;\n\terrseq_check_and_advance(&mapping->wb_err, &wb_err);\n\terr = do_one_pass(journal, &info, PASS_SCAN);\n\tif (!err)\n\t\terr = do_one_pass(journal, &info, PASS_REVOKE);\n\tif (!err)\n\t\terr = do_one_pass(journal, &info, PASS_REPLAY);\n\n\tjbd2_debug(1, \"JBD2: recovery, exit status %d, \"\n\t\t  \"recovered transactions %u to %u\\n\",\n\t\t  err, info.start_transaction, info.end_transaction);\n\tjbd2_debug(1, \"JBD2: Replayed %d and revoked %d/%d blocks\\n\",\n\t\t  info.nr_replays, info.nr_revoke_hits, info.nr_revokes);\n\n\t \n\tjournal->j_transaction_sequence = ++info.end_transaction;\n\tjournal->j_head = info.head_block;\n\tjbd2_debug(1, \"JBD2: last transaction %d, head block %lu\\n\",\n\t\t  journal->j_transaction_sequence, journal->j_head);\n\n\tjbd2_journal_clear_revoke(journal);\n\terr2 = sync_blockdev(journal->j_fs_dev);\n\tif (!err)\n\t\terr = err2;\n\terr2 = errseq_check_and_advance(&mapping->wb_err, &wb_err);\n\tif (!err)\n\t\terr = err2;\n\t \n\tif (journal->j_flags & JBD2_BARRIER) {\n\t\terr2 = blkdev_issue_flush(journal->j_fs_dev);\n\t\tif (!err)\n\t\t\terr = err2;\n\t}\n\treturn err;\n}\n\n \nint jbd2_journal_skip_recovery(journal_t *journal)\n{\n\tint\t\t\terr;\n\n\tstruct recovery_info\tinfo;\n\n\tmemset (&info, 0, sizeof(info));\n\n\terr = do_one_pass(journal, &info, PASS_SCAN);\n\n\tif (err) {\n\t\tprintk(KERN_ERR \"JBD2: error %d scanning journal\\n\", err);\n\t\t++journal->j_transaction_sequence;\n\t\tjournal->j_head = journal->j_first;\n\t} else {\n#ifdef CONFIG_JBD2_DEBUG\n\t\tint dropped = info.end_transaction - \n\t\t\tbe32_to_cpu(journal->j_superblock->s_sequence);\n\t\tjbd2_debug(1,\n\t\t\t  \"JBD2: ignoring %d transaction%s from the journal.\\n\",\n\t\t\t  dropped, (dropped == 1) ? \"\" : \"s\");\n#endif\n\t\tjournal->j_transaction_sequence = ++info.end_transaction;\n\t\tjournal->j_head = info.head_block;\n\t}\n\n\tjournal->j_tail = 0;\n\treturn err;\n}\n\nstatic inline unsigned long long read_tag_block(journal_t *journal,\n\t\t\t\t\t\tjournal_block_tag_t *tag)\n{\n\tunsigned long long block = be32_to_cpu(tag->t_blocknr);\n\tif (jbd2_has_feature_64bit(journal))\n\t\tblock |= (u64)be32_to_cpu(tag->t_blocknr_high) << 32;\n\treturn block;\n}\n\n \nstatic int calc_chksums(journal_t *journal, struct buffer_head *bh,\n\t\t\tunsigned long *next_log_block, __u32 *crc32_sum)\n{\n\tint i, num_blks, err;\n\tunsigned long io_block;\n\tstruct buffer_head *obh;\n\n\tnum_blks = count_tags(journal, bh);\n\t \n\t*crc32_sum = crc32_be(*crc32_sum, (void *)bh->b_data, bh->b_size);\n\n\tfor (i = 0; i < num_blks; i++) {\n\t\tio_block = (*next_log_block)++;\n\t\twrap(journal, *next_log_block);\n\t\terr = jread(&obh, journal, io_block);\n\t\tif (err) {\n\t\t\tprintk(KERN_ERR \"JBD2: IO error %d recovering block \"\n\t\t\t\t\"%lu in log\\n\", err, io_block);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\t*crc32_sum = crc32_be(*crc32_sum, (void *)obh->b_data,\n\t\t\t\t     obh->b_size);\n\t\t}\n\t\tput_bh(obh);\n\t}\n\treturn 0;\n}\n\nstatic int jbd2_commit_block_csum_verify(journal_t *j, void *buf)\n{\n\tstruct commit_header *h;\n\t__be32 provided;\n\t__u32 calculated;\n\n\tif (!jbd2_journal_has_csum_v2or3(j))\n\t\treturn 1;\n\n\th = buf;\n\tprovided = h->h_chksum[0];\n\th->h_chksum[0] = 0;\n\tcalculated = jbd2_chksum(j, j->j_csum_seed, buf, j->j_blocksize);\n\th->h_chksum[0] = provided;\n\n\treturn provided == cpu_to_be32(calculated);\n}\n\nstatic int jbd2_block_tag_csum_verify(journal_t *j, journal_block_tag_t *tag,\n\t\t\t\t      journal_block_tag3_t *tag3,\n\t\t\t\t      void *buf, __u32 sequence)\n{\n\t__u32 csum32;\n\t__be32 seq;\n\n\tif (!jbd2_journal_has_csum_v2or3(j))\n\t\treturn 1;\n\n\tseq = cpu_to_be32(sequence);\n\tcsum32 = jbd2_chksum(j, j->j_csum_seed, (__u8 *)&seq, sizeof(seq));\n\tcsum32 = jbd2_chksum(j, csum32, buf, j->j_blocksize);\n\n\tif (jbd2_has_feature_csum3(j))\n\t\treturn tag3->t_checksum == cpu_to_be32(csum32);\n\telse\n\t\treturn tag->t_checksum == cpu_to_be16(csum32);\n}\n\nstatic int do_one_pass(journal_t *journal,\n\t\t\tstruct recovery_info *info, enum passtype pass)\n{\n\tunsigned int\t\tfirst_commit_ID, next_commit_ID;\n\tunsigned long\t\tnext_log_block, head_block;\n\tint\t\t\terr, success = 0;\n\tjournal_superblock_t *\tsb;\n\tjournal_header_t *\ttmp;\n\tstruct buffer_head *\tbh;\n\tunsigned int\t\tsequence;\n\tint\t\t\tblocktype;\n\tint\t\t\ttag_bytes = journal_tag_bytes(journal);\n\t__u32\t\t\tcrc32_sum = ~0;  \n\tint\t\t\tdescr_csum_size = 0;\n\tint\t\t\tblock_error = 0;\n\tbool\t\t\tneed_check_commit_time = false;\n\t__u64\t\t\tlast_trans_commit_time = 0, commit_time;\n\n\t \n\n\tsb = journal->j_superblock;\n\tnext_commit_ID = be32_to_cpu(sb->s_sequence);\n\tnext_log_block = be32_to_cpu(sb->s_start);\n\thead_block = next_log_block;\n\n\tfirst_commit_ID = next_commit_ID;\n\tif (pass == PASS_SCAN)\n\t\tinfo->start_transaction = first_commit_ID;\n\n\tjbd2_debug(1, \"Starting recovery pass %d\\n\", pass);\n\n\t \n\n\twhile (1) {\n\t\tint\t\t\tflags;\n\t\tchar *\t\t\ttagp;\n\t\tjournal_block_tag_t\ttag;\n\t\tstruct buffer_head *\tobh;\n\t\tstruct buffer_head *\tnbh;\n\n\t\tcond_resched();\n\n\t\t \n\n\t\tif (pass != PASS_SCAN)\n\t\t\tif (tid_geq(next_commit_ID, info->end_transaction))\n\t\t\t\tbreak;\n\n\t\tjbd2_debug(2, \"Scanning for sequence ID %u at %lu/%lu\\n\",\n\t\t\t  next_commit_ID, next_log_block, journal->j_last);\n\n\t\t \n\n\t\tjbd2_debug(3, \"JBD2: checking block %ld\\n\", next_log_block);\n\t\terr = jread(&bh, journal, next_log_block);\n\t\tif (err)\n\t\t\tgoto failed;\n\n\t\tnext_log_block++;\n\t\twrap(journal, next_log_block);\n\n\t\t \n\n\t\ttmp = (journal_header_t *)bh->b_data;\n\n\t\tif (tmp->h_magic != cpu_to_be32(JBD2_MAGIC_NUMBER)) {\n\t\t\tbrelse(bh);\n\t\t\tbreak;\n\t\t}\n\n\t\tblocktype = be32_to_cpu(tmp->h_blocktype);\n\t\tsequence = be32_to_cpu(tmp->h_sequence);\n\t\tjbd2_debug(3, \"Found magic %d, sequence %d\\n\",\n\t\t\t  blocktype, sequence);\n\n\t\tif (sequence != next_commit_ID) {\n\t\t\tbrelse(bh);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\n\t\tswitch(blocktype) {\n\t\tcase JBD2_DESCRIPTOR_BLOCK:\n\t\t\t \n\t\t\tif (jbd2_journal_has_csum_v2or3(journal))\n\t\t\t\tdescr_csum_size =\n\t\t\t\t\tsizeof(struct jbd2_journal_block_tail);\n\t\t\tif (descr_csum_size > 0 &&\n\t\t\t    !jbd2_descriptor_block_csum_verify(journal,\n\t\t\t\t\t\t\t       bh->b_data)) {\n\t\t\t\t \n\t\t\t\tif (pass != PASS_SCAN) {\n\t\t\t\t\tpr_err(\"JBD2: Invalid checksum recovering block %lu in log\\n\",\n\t\t\t\t\t       next_log_block);\n\t\t\t\t\terr = -EFSBADCRC;\n\t\t\t\t\tbrelse(bh);\n\t\t\t\t\tgoto failed;\n\t\t\t\t}\n\t\t\t\tneed_check_commit_time = true;\n\t\t\t\tjbd2_debug(1,\n\t\t\t\t\t\"invalid descriptor block found in %lu\\n\",\n\t\t\t\t\tnext_log_block);\n\t\t\t}\n\n\t\t\t \n\t\t\tif (pass != PASS_REPLAY) {\n\t\t\t\tif (pass == PASS_SCAN &&\n\t\t\t\t    jbd2_has_feature_checksum(journal) &&\n\t\t\t\t    !need_check_commit_time &&\n\t\t\t\t    !info->end_transaction) {\n\t\t\t\t\tif (calc_chksums(journal, bh,\n\t\t\t\t\t\t\t&next_log_block,\n\t\t\t\t\t\t\t&crc32_sum)) {\n\t\t\t\t\t\tput_bh(bh);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tput_bh(bh);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tnext_log_block += count_tags(journal, bh);\n\t\t\t\twrap(journal, next_log_block);\n\t\t\t\tput_bh(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\n\t\t\ttagp = &bh->b_data[sizeof(journal_header_t)];\n\t\t\twhile ((tagp - bh->b_data + tag_bytes)\n\t\t\t       <= journal->j_blocksize - descr_csum_size) {\n\t\t\t\tunsigned long io_block;\n\n\t\t\t\tmemcpy(&tag, tagp, sizeof(tag));\n\t\t\t\tflags = be16_to_cpu(tag.t_flags);\n\n\t\t\t\tio_block = next_log_block++;\n\t\t\t\twrap(journal, next_log_block);\n\t\t\t\terr = jread(&obh, journal, io_block);\n\t\t\t\tif (err) {\n\t\t\t\t\t \n\t\t\t\t\tsuccess = err;\n\t\t\t\t\tprintk(KERN_ERR\n\t\t\t\t\t\t\"JBD2: IO error %d recovering \"\n\t\t\t\t\t\t\"block %ld in log\\n\",\n\t\t\t\t\t\terr, io_block);\n\t\t\t\t} else {\n\t\t\t\t\tunsigned long long blocknr;\n\n\t\t\t\t\tJ_ASSERT(obh != NULL);\n\t\t\t\t\tblocknr = read_tag_block(journal,\n\t\t\t\t\t\t\t\t &tag);\n\n\t\t\t\t\t \n\t\t\t\t\tif (jbd2_journal_test_revoke\n\t\t\t\t\t    (journal, blocknr,\n\t\t\t\t\t     next_commit_ID)) {\n\t\t\t\t\t\tbrelse(obh);\n\t\t\t\t\t\t++info->nr_revoke_hits;\n\t\t\t\t\t\tgoto skip_write;\n\t\t\t\t\t}\n\n\t\t\t\t\t \n\t\t\t\t\tif (!jbd2_block_tag_csum_verify(\n\t\t\tjournal, &tag, (journal_block_tag3_t *)tagp,\n\t\t\tobh->b_data, be32_to_cpu(tmp->h_sequence))) {\n\t\t\t\t\t\tbrelse(obh);\n\t\t\t\t\t\tsuccess = -EFSBADCRC;\n\t\t\t\t\t\tprintk(KERN_ERR \"JBD2: Invalid \"\n\t\t\t\t\t\t       \"checksum recovering \"\n\t\t\t\t\t\t       \"data block %llu in \"\n\t\t\t\t\t\t       \"log\\n\", blocknr);\n\t\t\t\t\t\tblock_error = 1;\n\t\t\t\t\t\tgoto skip_write;\n\t\t\t\t\t}\n\n\t\t\t\t\t \n\t\t\t\t\tnbh = __getblk(journal->j_fs_dev,\n\t\t\t\t\t\t\tblocknr,\n\t\t\t\t\t\t\tjournal->j_blocksize);\n\t\t\t\t\tif (nbh == NULL) {\n\t\t\t\t\t\tprintk(KERN_ERR\n\t\t\t\t\t\t       \"JBD2: Out of memory \"\n\t\t\t\t\t\t       \"during recovery.\\n\");\n\t\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\t\tbrelse(bh);\n\t\t\t\t\t\tbrelse(obh);\n\t\t\t\t\t\tgoto failed;\n\t\t\t\t\t}\n\n\t\t\t\t\tlock_buffer(nbh);\n\t\t\t\t\tmemcpy(nbh->b_data, obh->b_data,\n\t\t\t\t\t\t\tjournal->j_blocksize);\n\t\t\t\t\tif (flags & JBD2_FLAG_ESCAPE) {\n\t\t\t\t\t\t*((__be32 *)nbh->b_data) =\n\t\t\t\t\t\tcpu_to_be32(JBD2_MAGIC_NUMBER);\n\t\t\t\t\t}\n\n\t\t\t\t\tBUFFER_TRACE(nbh, \"marking dirty\");\n\t\t\t\t\tset_buffer_uptodate(nbh);\n\t\t\t\t\tmark_buffer_dirty(nbh);\n\t\t\t\t\tBUFFER_TRACE(nbh, \"marking uptodate\");\n\t\t\t\t\t++info->nr_replays;\n\t\t\t\t\tunlock_buffer(nbh);\n\t\t\t\t\tbrelse(obh);\n\t\t\t\t\tbrelse(nbh);\n\t\t\t\t}\n\n\t\t\tskip_write:\n\t\t\t\ttagp += tag_bytes;\n\t\t\t\tif (!(flags & JBD2_FLAG_SAME_UUID))\n\t\t\t\t\ttagp += 16;\n\n\t\t\t\tif (flags & JBD2_FLAG_LAST_TAG)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbrelse(bh);\n\t\t\tcontinue;\n\n\t\tcase JBD2_COMMIT_BLOCK:\n\t\t\t \n\t\t\tcommit_time = be64_to_cpu(\n\t\t\t\t((struct commit_header *)bh->b_data)->h_commit_sec);\n\t\t\t \n\t\t\tif (need_check_commit_time) {\n\t\t\t\tif (commit_time >= last_trans_commit_time) {\n\t\t\t\t\tpr_err(\"JBD2: Invalid checksum found in transaction %u\\n\",\n\t\t\t\t\t       next_commit_ID);\n\t\t\t\t\terr = -EFSBADCRC;\n\t\t\t\t\tbrelse(bh);\n\t\t\t\t\tgoto failed;\n\t\t\t\t}\n\t\t\tignore_crc_mismatch:\n\t\t\t\t \n\t\t\t\tjbd2_debug(1, \"JBD2: Invalid checksum ignored in transaction %u, likely stale data\\n\",\n\t\t\t\t\t  next_commit_ID);\n\t\t\t\tbrelse(bh);\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (pass == PASS_SCAN &&\n\t\t\t    jbd2_has_feature_checksum(journal)) {\n\t\t\t\tstruct commit_header *cbh =\n\t\t\t\t\t(struct commit_header *)bh->b_data;\n\t\t\t\tunsigned found_chksum =\n\t\t\t\t\tbe32_to_cpu(cbh->h_chksum[0]);\n\n\t\t\t\tif (info->end_transaction) {\n\t\t\t\t\tjournal->j_failed_commit =\n\t\t\t\t\t\tinfo->end_transaction;\n\t\t\t\t\tbrelse(bh);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tif (!((crc32_sum == found_chksum &&\n\t\t\t\t       cbh->h_chksum_type ==\n\t\t\t\t\t\tJBD2_CRC32_CHKSUM &&\n\t\t\t\t       cbh->h_chksum_size ==\n\t\t\t\t\t\tJBD2_CRC32_CHKSUM_SIZE) ||\n\t\t\t\t      (cbh->h_chksum_type == 0 &&\n\t\t\t\t       cbh->h_chksum_size == 0 &&\n\t\t\t\t       found_chksum == 0)))\n\t\t\t\t\tgoto chksum_error;\n\n\t\t\t\tcrc32_sum = ~0;\n\t\t\t}\n\t\t\tif (pass == PASS_SCAN &&\n\t\t\t    !jbd2_commit_block_csum_verify(journal,\n\t\t\t\t\t\t\t   bh->b_data)) {\n\t\t\tchksum_error:\n\t\t\t\tif (commit_time < last_trans_commit_time)\n\t\t\t\t\tgoto ignore_crc_mismatch;\n\t\t\t\tinfo->end_transaction = next_commit_ID;\n\t\t\t\tinfo->head_block = head_block;\n\n\t\t\t\tif (!jbd2_has_feature_async_commit(journal)) {\n\t\t\t\t\tjournal->j_failed_commit =\n\t\t\t\t\t\tnext_commit_ID;\n\t\t\t\t\tbrelse(bh);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pass == PASS_SCAN) {\n\t\t\t\tlast_trans_commit_time = commit_time;\n\t\t\t\thead_block = next_log_block;\n\t\t\t}\n\t\t\tbrelse(bh);\n\t\t\tnext_commit_ID++;\n\t\t\tcontinue;\n\n\t\tcase JBD2_REVOKE_BLOCK:\n\t\t\t \n\t\t\tif (pass == PASS_SCAN &&\n\t\t\t    !jbd2_descriptor_block_csum_verify(journal,\n\t\t\t\t\t\t\t       bh->b_data)) {\n\t\t\t\tjbd2_debug(1, \"JBD2: invalid revoke block found in %lu\\n\",\n\t\t\t\t\t  next_log_block);\n\t\t\t\tneed_check_commit_time = true;\n\t\t\t}\n\t\t\t \n\t\t\tif (pass != PASS_REVOKE) {\n\t\t\t\tbrelse(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\terr = scan_revoke_records(journal, bh,\n\t\t\t\t\t\t  next_commit_ID, info);\n\t\t\tbrelse(bh);\n\t\t\tif (err)\n\t\t\t\tgoto failed;\n\t\t\tcontinue;\n\n\t\tdefault:\n\t\t\tjbd2_debug(3, \"Unrecognised magic %d, end of scan.\\n\",\n\t\t\t\t  blocktype);\n\t\t\tbrelse(bh);\n\t\t\tgoto done;\n\t\t}\n\t}\n\n done:\n\t \n\n\tif (pass == PASS_SCAN) {\n\t\tif (!info->end_transaction)\n\t\t\tinfo->end_transaction = next_commit_ID;\n\t\tif (!info->head_block)\n\t\t\tinfo->head_block = head_block;\n\t} else {\n\t\t \n\t\tif (info->end_transaction != next_commit_ID) {\n\t\t\tprintk(KERN_ERR \"JBD2: recovery pass %d ended at \"\n\t\t\t\t\"transaction %u, expected %u\\n\",\n\t\t\t\tpass, next_commit_ID, info->end_transaction);\n\t\t\tif (!success)\n\t\t\t\tsuccess = -EIO;\n\t\t}\n\t}\n\n\tif (jbd2_has_feature_fast_commit(journal) &&  pass != PASS_REVOKE) {\n\t\terr = fc_do_one_pass(journal, info, pass);\n\t\tif (err)\n\t\t\tsuccess = err;\n\t}\n\n\tif (block_error && success == 0)\n\t\tsuccess = -EIO;\n\treturn success;\n\n failed:\n\treturn err;\n}\n\n \n\nstatic int scan_revoke_records(journal_t *journal, struct buffer_head *bh,\n\t\t\t       tid_t sequence, struct recovery_info *info)\n{\n\tjbd2_journal_revoke_header_t *header;\n\tint offset, max;\n\tunsigned csum_size = 0;\n\t__u32 rcount;\n\tint record_len = 4;\n\n\theader = (jbd2_journal_revoke_header_t *) bh->b_data;\n\toffset = sizeof(jbd2_journal_revoke_header_t);\n\trcount = be32_to_cpu(header->r_count);\n\n\tif (jbd2_journal_has_csum_v2or3(journal))\n\t\tcsum_size = sizeof(struct jbd2_journal_block_tail);\n\tif (rcount > journal->j_blocksize - csum_size)\n\t\treturn -EINVAL;\n\tmax = rcount;\n\n\tif (jbd2_has_feature_64bit(journal))\n\t\trecord_len = 8;\n\n\twhile (offset + record_len <= max) {\n\t\tunsigned long long blocknr;\n\t\tint err;\n\n\t\tif (record_len == 4)\n\t\t\tblocknr = be32_to_cpu(* ((__be32 *) (bh->b_data+offset)));\n\t\telse\n\t\t\tblocknr = be64_to_cpu(* ((__be64 *) (bh->b_data+offset)));\n\t\toffset += record_len;\n\t\terr = jbd2_journal_set_revoke(journal, blocknr, sequence);\n\t\tif (err)\n\t\t\treturn err;\n\t\t++info->nr_revokes;\n\t}\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}