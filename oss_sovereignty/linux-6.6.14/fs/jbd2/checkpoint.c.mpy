{
  "module_name": "checkpoint.c",
  "hash_id": "6cdcc8d94e118a3ccab81b0f3855f17d9df0ba321cc692cda7d7b2cce776eac4",
  "original_prompt": "Ingested from linux-6.6.14/fs/jbd2/checkpoint.c",
  "human_readable_source": "\n \n\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/jbd2.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <trace/events/jbd2.h>\n\n \nstatic inline void __buffer_unlink(struct journal_head *jh)\n{\n\ttransaction_t *transaction = jh->b_cp_transaction;\n\n\tjh->b_cpnext->b_cpprev = jh->b_cpprev;\n\tjh->b_cpprev->b_cpnext = jh->b_cpnext;\n\tif (transaction->t_checkpoint_list == jh) {\n\t\ttransaction->t_checkpoint_list = jh->b_cpnext;\n\t\tif (transaction->t_checkpoint_list == jh)\n\t\t\ttransaction->t_checkpoint_list = NULL;\n\t}\n}\n\n \nvoid __jbd2_log_wait_for_space(journal_t *journal)\n__acquires(&journal->j_state_lock)\n__releases(&journal->j_state_lock)\n{\n\tint nblocks, space_left;\n\t \n\n\tnblocks = journal->j_max_transaction_buffers;\n\twhile (jbd2_log_space_left(journal) < nblocks) {\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tmutex_lock_io(&journal->j_checkpoint_mutex);\n\n\t\t \n\t\twrite_lock(&journal->j_state_lock);\n\t\tif (journal->j_flags & JBD2_ABORT) {\n\t\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t\t\treturn;\n\t\t}\n\t\tspin_lock(&journal->j_list_lock);\n\t\tspace_left = jbd2_log_space_left(journal);\n\t\tif (space_left < nblocks) {\n\t\t\tint chkpt = journal->j_checkpoint_transactions != NULL;\n\t\t\ttid_t tid = 0;\n\n\t\t\tif (journal->j_committing_transaction)\n\t\t\t\ttid = journal->j_committing_transaction->t_tid;\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\twrite_unlock(&journal->j_state_lock);\n\t\t\tif (chkpt) {\n\t\t\t\tjbd2_log_do_checkpoint(journal);\n\t\t\t} else if (jbd2_cleanup_journal_tail(journal) == 0) {\n\t\t\t\t \n\t\t\t\t;\n\t\t\t} else if (tid) {\n\t\t\t\t \n\t\t\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t\t\t\tjbd2_log_wait_commit(journal, tid);\n\t\t\t\twrite_lock(&journal->j_state_lock);\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tprintk(KERN_ERR \"%s: needed %d blocks and \"\n\t\t\t\t       \"only had %d space available\\n\",\n\t\t\t\t       __func__, nblocks, space_left);\n\t\t\t\tprintk(KERN_ERR \"%s: no way to get more \"\n\t\t\t\t       \"journal space in %s\\n\", __func__,\n\t\t\t\t       journal->j_devname);\n\t\t\t\tWARN_ON(1);\n\t\t\t\tjbd2_journal_abort(journal, -EIO);\n\t\t\t}\n\t\t\twrite_lock(&journal->j_state_lock);\n\t\t} else {\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t}\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t}\n}\n\nstatic void\n__flush_batch(journal_t *journal, int *batch_count)\n{\n\tint i;\n\tstruct blk_plug plug;\n\n\tblk_start_plug(&plug);\n\tfor (i = 0; i < *batch_count; i++)\n\t\twrite_dirty_buffer(journal->j_chkpt_bhs[i], REQ_SYNC);\n\tblk_finish_plug(&plug);\n\n\tfor (i = 0; i < *batch_count; i++) {\n\t\tstruct buffer_head *bh = journal->j_chkpt_bhs[i];\n\t\tBUFFER_TRACE(bh, \"brelse\");\n\t\t__brelse(bh);\n\t\tjournal->j_chkpt_bhs[i] = NULL;\n\t}\n\t*batch_count = 0;\n}\n\n \nint jbd2_log_do_checkpoint(journal_t *journal)\n{\n\tstruct journal_head\t*jh;\n\tstruct buffer_head\t*bh;\n\ttransaction_t\t\t*transaction;\n\ttid_t\t\t\tthis_tid;\n\tint\t\t\tresult, batch_count = 0;\n\n\tjbd2_debug(1, \"Start checkpoint\\n\");\n\n\t \n\tresult = jbd2_cleanup_journal_tail(journal);\n\ttrace_jbd2_checkpoint(journal, result);\n\tjbd2_debug(1, \"cleanup_journal_tail returned %d\\n\", result);\n\tif (result <= 0)\n\t\treturn result;\n\n\t \n\tspin_lock(&journal->j_list_lock);\n\tif (!journal->j_checkpoint_transactions)\n\t\tgoto out;\n\ttransaction = journal->j_checkpoint_transactions;\n\tif (transaction->t_chp_stats.cs_chp_time == 0)\n\t\ttransaction->t_chp_stats.cs_chp_time = jiffies;\n\tthis_tid = transaction->t_tid;\nrestart:\n\t \n\tif (journal->j_checkpoint_transactions != transaction ||\n\t    transaction->t_tid != this_tid)\n\t\tgoto out;\n\n\t \n\twhile (transaction->t_checkpoint_list) {\n\t\tjh = transaction->t_checkpoint_list;\n\t\tbh = jh2bh(jh);\n\n\t\tif (jh->b_transaction != NULL) {\n\t\t\ttransaction_t *t = jh->b_transaction;\n\t\t\ttid_t tid = t->t_tid;\n\n\t\t\ttransaction->t_chp_stats.cs_forced_to_close++;\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\tif (unlikely(journal->j_flags & JBD2_UNMOUNT))\n\t\t\t\t \n\t\t\t\tprintk(KERN_ERR\n\t\t\"JBD2: %s: Waiting for Godot: block %llu\\n\",\n\t\tjournal->j_devname, (unsigned long long) bh->b_blocknr);\n\n\t\t\tif (batch_count)\n\t\t\t\t__flush_batch(journal, &batch_count);\n\t\t\tjbd2_log_start_commit(journal, tid);\n\t\t\t \n\t\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t\t\tjbd2_log_wait_commit(journal, tid);\n\t\t\tmutex_lock_io(&journal->j_checkpoint_mutex);\n\t\t\tspin_lock(&journal->j_list_lock);\n\t\t\tgoto restart;\n\t\t}\n\t\tif (!trylock_buffer(bh)) {\n\t\t\t \n\t\t\tget_bh(bh);\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\twait_on_buffer(bh);\n\t\t\t \n\t\t\tBUFFER_TRACE(bh, \"brelse\");\n\t\t\t__brelse(bh);\n\t\t\tgoto retry;\n\t\t} else if (!buffer_dirty(bh)) {\n\t\t\tunlock_buffer(bh);\n\t\t\tBUFFER_TRACE(bh, \"remove from checkpoint\");\n\t\t\t \n\t\t\tif (__jbd2_journal_remove_checkpoint(jh) ||\n\t\t\t    !transaction->t_checkpoint_list)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\tunlock_buffer(bh);\n\t\t\t \n\t\t\tBUFFER_TRACE(bh, \"queue\");\n\t\t\tget_bh(bh);\n\t\t\tJ_ASSERT_BH(bh, !buffer_jwrite(bh));\n\t\t\tjournal->j_chkpt_bhs[batch_count++] = bh;\n\t\t\ttransaction->t_chp_stats.cs_written++;\n\t\t\ttransaction->t_checkpoint_list = jh->b_cpnext;\n\t\t}\n\n\t\tif ((batch_count == JBD2_NR_BATCH) ||\n\t\t    need_resched() || spin_needbreak(&journal->j_list_lock) ||\n\t\t    jh2bh(transaction->t_checkpoint_list) == journal->j_chkpt_bhs[0])\n\t\t\tgoto unlock_and_flush;\n\t}\n\n\tif (batch_count) {\n\t\tunlock_and_flush:\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\tretry:\n\t\t\tif (batch_count)\n\t\t\t\t__flush_batch(journal, &batch_count);\n\t\t\tspin_lock(&journal->j_list_lock);\n\t\t\tgoto restart;\n\t}\n\nout:\n\tspin_unlock(&journal->j_list_lock);\n\tresult = jbd2_cleanup_journal_tail(journal);\n\n\treturn (result < 0) ? result : 0;\n}\n\n \n\nint jbd2_cleanup_journal_tail(journal_t *journal)\n{\n\ttid_t\t\tfirst_tid;\n\tunsigned long\tblocknr;\n\n\tif (is_journal_aborted(journal))\n\t\treturn -EIO;\n\n\tif (!jbd2_journal_get_log_tail(journal, &first_tid, &blocknr))\n\t\treturn 1;\n\tJ_ASSERT(blocknr != 0);\n\n\t \n\tif (journal->j_flags & JBD2_BARRIER)\n\t\tblkdev_issue_flush(journal->j_fs_dev);\n\n\treturn __jbd2_update_log_tail(journal, first_tid, blocknr);\n}\n\n\n \n\nenum shrink_type {SHRINK_DESTROY, SHRINK_BUSY_STOP, SHRINK_BUSY_SKIP};\n\n \nstatic unsigned long journal_shrink_one_cp_list(struct journal_head *jh,\n\t\t\t\t\t\tenum shrink_type type,\n\t\t\t\t\t\tbool *released)\n{\n\tstruct journal_head *last_jh;\n\tstruct journal_head *next_jh = jh;\n\tunsigned long nr_freed = 0;\n\tint ret;\n\n\t*released = false;\n\tif (!jh)\n\t\treturn 0;\n\n\tlast_jh = jh->b_cpprev;\n\tdo {\n\t\tjh = next_jh;\n\t\tnext_jh = jh->b_cpnext;\n\n\t\tif (type == SHRINK_DESTROY) {\n\t\t\tret = __jbd2_journal_remove_checkpoint(jh);\n\t\t} else {\n\t\t\tret = jbd2_journal_try_remove_checkpoint(jh);\n\t\t\tif (ret < 0) {\n\t\t\t\tif (type == SHRINK_BUSY_SKIP)\n\t\t\t\t\tcontinue;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tnr_freed++;\n\t\tif (ret) {\n\t\t\t*released = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (need_resched())\n\t\t\tbreak;\n\t} while (jh != last_jh);\n\n\treturn nr_freed;\n}\n\n \nunsigned long jbd2_journal_shrink_checkpoint_list(journal_t *journal,\n\t\t\t\t\t\t  unsigned long *nr_to_scan)\n{\n\ttransaction_t *transaction, *last_transaction, *next_transaction;\n\tbool __maybe_unused released;\n\ttid_t first_tid = 0, last_tid = 0, next_tid = 0;\n\ttid_t tid = 0;\n\tunsigned long nr_freed = 0;\n\tunsigned long freed;\n\nagain:\n\tspin_lock(&journal->j_list_lock);\n\tif (!journal->j_checkpoint_transactions) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tgoto out;\n\t}\n\n\t \n\tif (journal->j_shrink_transaction)\n\t\ttransaction = journal->j_shrink_transaction;\n\telse\n\t\ttransaction = journal->j_checkpoint_transactions;\n\n\tif (!first_tid)\n\t\tfirst_tid = transaction->t_tid;\n\tlast_transaction = journal->j_checkpoint_transactions->t_cpprev;\n\tnext_transaction = transaction;\n\tlast_tid = last_transaction->t_tid;\n\tdo {\n\t\ttransaction = next_transaction;\n\t\tnext_transaction = transaction->t_cpnext;\n\t\ttid = transaction->t_tid;\n\n\t\tfreed = journal_shrink_one_cp_list(transaction->t_checkpoint_list,\n\t\t\t\t\t\t   SHRINK_BUSY_SKIP, &released);\n\t\tnr_freed += freed;\n\t\t(*nr_to_scan) -= min(*nr_to_scan, freed);\n\t\tif (*nr_to_scan == 0)\n\t\t\tbreak;\n\t\tif (need_resched() || spin_needbreak(&journal->j_list_lock))\n\t\t\tbreak;\n\t} while (transaction != last_transaction);\n\n\tif (transaction != last_transaction) {\n\t\tjournal->j_shrink_transaction = next_transaction;\n\t\tnext_tid = next_transaction->t_tid;\n\t} else {\n\t\tjournal->j_shrink_transaction = NULL;\n\t\tnext_tid = 0;\n\t}\n\n\tspin_unlock(&journal->j_list_lock);\n\tcond_resched();\n\n\tif (*nr_to_scan && next_tid)\n\t\tgoto again;\nout:\n\ttrace_jbd2_shrink_checkpoint_list(journal, first_tid, tid, last_tid,\n\t\t\t\t\t  nr_freed, next_tid);\n\n\treturn nr_freed;\n}\n\n \nvoid __jbd2_journal_clean_checkpoint_list(journal_t *journal, bool destroy)\n{\n\ttransaction_t *transaction, *last_transaction, *next_transaction;\n\tenum shrink_type type;\n\tbool released;\n\n\ttransaction = journal->j_checkpoint_transactions;\n\tif (!transaction)\n\t\treturn;\n\n\ttype = destroy ? SHRINK_DESTROY : SHRINK_BUSY_STOP;\n\tlast_transaction = transaction->t_cpprev;\n\tnext_transaction = transaction;\n\tdo {\n\t\ttransaction = next_transaction;\n\t\tnext_transaction = transaction->t_cpnext;\n\t\tjournal_shrink_one_cp_list(transaction->t_checkpoint_list,\n\t\t\t\t\t   type, &released);\n\t\t \n\t\tif (need_resched())\n\t\t\treturn;\n\t\t \n\t\tif (!released)\n\t\t\treturn;\n\t} while (transaction != last_transaction);\n}\n\n \nvoid jbd2_journal_destroy_checkpoint(journal_t *journal)\n{\n\t \n\twhile (1) {\n\t\tspin_lock(&journal->j_list_lock);\n\t\tif (!journal->j_checkpoint_transactions) {\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\tbreak;\n\t\t}\n\t\t__jbd2_journal_clean_checkpoint_list(journal, true);\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tcond_resched();\n\t}\n}\n\n \nint __jbd2_journal_remove_checkpoint(struct journal_head *jh)\n{\n\tstruct transaction_chp_stats_s *stats;\n\ttransaction_t *transaction;\n\tjournal_t *journal;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tJBUFFER_TRACE(jh, \"entry\");\n\n\ttransaction = jh->b_cp_transaction;\n\tif (!transaction) {\n\t\tJBUFFER_TRACE(jh, \"not on transaction\");\n\t\treturn 0;\n\t}\n\tjournal = transaction->t_journal;\n\n\tJBUFFER_TRACE(jh, \"removing from transaction\");\n\n\t \n\tif (buffer_write_io_error(bh))\n\t\tset_bit(JBD2_CHECKPOINT_IO_ERROR, &journal->j_atomic_flags);\n\n\t__buffer_unlink(jh);\n\tjh->b_cp_transaction = NULL;\n\tpercpu_counter_dec(&journal->j_checkpoint_jh_count);\n\tjbd2_journal_put_journal_head(jh);\n\n\t \n\tif (transaction->t_checkpoint_list)\n\t\treturn 0;\n\n\t \n\tif (transaction->t_state != T_FINISHED)\n\t\treturn 0;\n\n\t \n\tstats = &transaction->t_chp_stats;\n\tif (stats->cs_chp_time)\n\t\tstats->cs_chp_time = jbd2_time_diff(stats->cs_chp_time,\n\t\t\t\t\t\t    jiffies);\n\ttrace_jbd2_checkpoint_stats(journal->j_fs_dev->bd_dev,\n\t\t\t\t    transaction->t_tid, stats);\n\n\t__jbd2_journal_drop_transaction(journal, transaction);\n\tjbd2_journal_free_transaction(transaction);\n\treturn 1;\n}\n\n \nint jbd2_journal_try_remove_checkpoint(struct journal_head *jh)\n{\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tif (jh->b_transaction)\n\t\treturn -EBUSY;\n\tif (!trylock_buffer(bh))\n\t\treturn -EBUSY;\n\tif (buffer_dirty(bh)) {\n\t\tunlock_buffer(bh);\n\t\treturn -EBUSY;\n\t}\n\tunlock_buffer(bh);\n\n\t \n\tJBUFFER_TRACE(jh, \"remove from checkpoint list\");\n\treturn __jbd2_journal_remove_checkpoint(jh);\n}\n\n \nvoid __jbd2_journal_insert_checkpoint(struct journal_head *jh,\n\t\t\t       transaction_t *transaction)\n{\n\tJBUFFER_TRACE(jh, \"entry\");\n\tJ_ASSERT_JH(jh, buffer_dirty(jh2bh(jh)) || buffer_jbddirty(jh2bh(jh)));\n\tJ_ASSERT_JH(jh, jh->b_cp_transaction == NULL);\n\n\t \n\tjbd2_journal_grab_journal_head(jh2bh(jh));\n\tjh->b_cp_transaction = transaction;\n\n\tif (!transaction->t_checkpoint_list) {\n\t\tjh->b_cpnext = jh->b_cpprev = jh;\n\t} else {\n\t\tjh->b_cpnext = transaction->t_checkpoint_list;\n\t\tjh->b_cpprev = transaction->t_checkpoint_list->b_cpprev;\n\t\tjh->b_cpprev->b_cpnext = jh;\n\t\tjh->b_cpnext->b_cpprev = jh;\n\t}\n\ttransaction->t_checkpoint_list = jh;\n\tpercpu_counter_inc(&transaction->t_journal->j_checkpoint_jh_count);\n}\n\n \n\nvoid __jbd2_journal_drop_transaction(journal_t *journal, transaction_t *transaction)\n{\n\tassert_spin_locked(&journal->j_list_lock);\n\n\tjournal->j_shrink_transaction = NULL;\n\tif (transaction->t_cpnext) {\n\t\ttransaction->t_cpnext->t_cpprev = transaction->t_cpprev;\n\t\ttransaction->t_cpprev->t_cpnext = transaction->t_cpnext;\n\t\tif (journal->j_checkpoint_transactions == transaction)\n\t\t\tjournal->j_checkpoint_transactions =\n\t\t\t\ttransaction->t_cpnext;\n\t\tif (journal->j_checkpoint_transactions == transaction)\n\t\t\tjournal->j_checkpoint_transactions = NULL;\n\t}\n\n\tJ_ASSERT(transaction->t_state == T_FINISHED);\n\tJ_ASSERT(transaction->t_buffers == NULL);\n\tJ_ASSERT(transaction->t_forget == NULL);\n\tJ_ASSERT(transaction->t_shadow_list == NULL);\n\tJ_ASSERT(transaction->t_checkpoint_list == NULL);\n\tJ_ASSERT(atomic_read(&transaction->t_updates) == 0);\n\tJ_ASSERT(journal->j_committing_transaction != transaction);\n\tJ_ASSERT(journal->j_running_transaction != transaction);\n\n\ttrace_jbd2_drop_transaction(journal, transaction);\n\n\tjbd2_debug(1, \"Dropping transaction %d, all done\\n\", transaction->t_tid);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}