{
  "module_name": "platform.c",
  "hash_id": "7e6ba3b37299015767b0a662828ad28cc103606e23f4c224469ae6b7e9813f2f",
  "original_prompt": "Ingested from linux-6.6.14/fs/pstore/platform.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"pstore: \" fmt\n\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/pstore.h>\n#include <linux/string.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/jiffies.h>\n#include <linux/vmalloc.h>\n#include <linux/workqueue.h>\n#include <linux/zlib.h>\n\n#include \"internal.h\"\n\n \nstatic int pstore_update_ms = -1;\nmodule_param_named(update_ms, pstore_update_ms, int, 0600);\nMODULE_PARM_DESC(update_ms, \"milliseconds before pstore updates its content \"\n\t\t \"(default is -1, which means runtime updates are disabled; \"\n\t\t \"enabling this option may not be safe; it may lead to further \"\n\t\t \"corruption on Oopses)\");\n\n \nstatic const char * const pstore_type_names[] = {\n\t\"dmesg\",\n\t\"mce\",\n\t\"console\",\n\t\"ftrace\",\n\t\"rtas\",\n\t\"powerpc-ofw\",\n\t\"powerpc-common\",\n\t\"pmsg\",\n\t\"powerpc-opal\",\n};\n\nstatic int pstore_new_entry;\n\nstatic void pstore_timefunc(struct timer_list *);\nstatic DEFINE_TIMER(pstore_timer, pstore_timefunc);\n\nstatic void pstore_dowork(struct work_struct *);\nstatic DECLARE_WORK(pstore_work, pstore_dowork);\n\n \nstatic DEFINE_MUTEX(psinfo_lock);\nstruct pstore_info *psinfo;\n\nstatic char *backend;\nmodule_param(backend, charp, 0444);\nMODULE_PARM_DESC(backend, \"specific backend to use\");\n\n \nstatic char *compress = \"deflate\";\nmodule_param(compress, charp, 0444);\nMODULE_PARM_DESC(compress, \"compression to use\");\n\n \nunsigned long kmsg_bytes = CONFIG_PSTORE_DEFAULT_KMSG_BYTES;\nmodule_param(kmsg_bytes, ulong, 0444);\nMODULE_PARM_DESC(kmsg_bytes, \"amount of kernel log to snapshot (in bytes)\");\n\nstatic void *compress_workspace;\n\n \n#define DMESG_COMP_PERCENT\t60\n\nstatic char *big_oops_buf;\nstatic size_t max_compressed_size;\n\nvoid pstore_set_kmsg_bytes(int bytes)\n{\n\tkmsg_bytes = bytes;\n}\n\n \nstatic int\toopscount;\n\nconst char *pstore_type_to_name(enum pstore_type_id type)\n{\n\tBUILD_BUG_ON(ARRAY_SIZE(pstore_type_names) != PSTORE_TYPE_MAX);\n\n\tif (WARN_ON_ONCE(type >= PSTORE_TYPE_MAX))\n\t\treturn \"unknown\";\n\n\treturn pstore_type_names[type];\n}\nEXPORT_SYMBOL_GPL(pstore_type_to_name);\n\nenum pstore_type_id pstore_name_to_type(const char *name)\n{\n\tint i;\n\n\tfor (i = 0; i < PSTORE_TYPE_MAX; i++) {\n\t\tif (!strcmp(pstore_type_names[i], name))\n\t\t\treturn i;\n\t}\n\n\treturn PSTORE_TYPE_MAX;\n}\nEXPORT_SYMBOL_GPL(pstore_name_to_type);\n\nstatic void pstore_timer_kick(void)\n{\n\tif (pstore_update_ms < 0)\n\t\treturn;\n\n\tmod_timer(&pstore_timer, jiffies + msecs_to_jiffies(pstore_update_ms));\n}\n\nstatic bool pstore_cannot_block_path(enum kmsg_dump_reason reason)\n{\n\t \n\tif (in_nmi())\n\t\treturn true;\n\n\tswitch (reason) {\n\t \n\tcase KMSG_DUMP_PANIC:\n\t \n\tcase KMSG_DUMP_EMERG:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int pstore_compress(const void *in, void *out,\n\t\t\t   unsigned int inlen, unsigned int outlen)\n{\n\tstruct z_stream_s zstream = {\n\t\t.next_in\t= in,\n\t\t.avail_in\t= inlen,\n\t\t.next_out\t= out,\n\t\t.avail_out\t= outlen,\n\t\t.workspace\t= compress_workspace,\n\t};\n\tint ret;\n\n\tif (!IS_ENABLED(CONFIG_PSTORE_COMPRESS))\n\t\treturn -EINVAL;\n\n\tret = zlib_deflateInit2(&zstream, Z_DEFAULT_COMPRESSION, Z_DEFLATED,\n\t\t\t\t-MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n\tif (ret != Z_OK)\n\t\treturn -EINVAL;\n\n\tret = zlib_deflate(&zstream, Z_FINISH);\n\tif (ret != Z_STREAM_END)\n\t\treturn -EINVAL;\n\n\tret = zlib_deflateEnd(&zstream);\n\tif (ret != Z_OK)\n\t\tpr_warn_once(\"zlib_deflateEnd() failed: %d\\n\", ret);\n\n\treturn zstream.total_out;\n}\n\nstatic void allocate_buf_for_compression(void)\n{\n\tsize_t compressed_size;\n\tchar *buf;\n\n\t \n\tif (!IS_ENABLED(CONFIG_PSTORE_COMPRESS) || !compress ||\n\t    !strcmp(compress, \"none\")) {\n\t\tcompress = NULL;\n\t\treturn;\n\t}\n\n\tif (strcmp(compress, \"deflate\")) {\n\t\tpr_err(\"Unsupported compression '%s', falling back to deflate\\n\",\n\t\t       compress);\n\t\tcompress = \"deflate\";\n\t}\n\n\t \n\tcompressed_size = (psinfo->bufsize * 100) / DMESG_COMP_PERCENT;\n\tbuf = kvzalloc(compressed_size, GFP_KERNEL);\n\tif (!buf) {\n\t\tpr_err(\"Failed %zu byte compression buffer allocation for: %s\\n\",\n\t\t       psinfo->bufsize, compress);\n\t\treturn;\n\t}\n\n\tcompress_workspace =\n\t\tvmalloc(zlib_deflate_workspacesize(MAX_WBITS, DEF_MEM_LEVEL));\n\tif (!compress_workspace) {\n\t\tpr_err(\"Failed to allocate zlib deflate workspace\\n\");\n\t\tkvfree(buf);\n\t\treturn;\n\t}\n\n\t \n\tbig_oops_buf = buf;\n\tmax_compressed_size = compressed_size;\n\n\tpr_info(\"Using crash dump compression: %s\\n\", compress);\n}\n\nstatic void free_buf_for_compression(void)\n{\n\tif (IS_ENABLED(CONFIG_PSTORE_COMPRESS) && compress_workspace) {\n\t\tvfree(compress_workspace);\n\t\tcompress_workspace = NULL;\n\t}\n\n\tkvfree(big_oops_buf);\n\tbig_oops_buf = NULL;\n\tmax_compressed_size = 0;\n}\n\nvoid pstore_record_init(struct pstore_record *record,\n\t\t\tstruct pstore_info *psinfo)\n{\n\tmemset(record, 0, sizeof(*record));\n\n\trecord->psi = psinfo;\n\n\t \n\trecord->time = ns_to_timespec64(ktime_get_real_fast_ns());\n}\n\n \nstatic void pstore_dump(struct kmsg_dumper *dumper,\n\t\t\tenum kmsg_dump_reason reason)\n{\n\tstruct kmsg_dump_iter iter;\n\tunsigned long\ttotal = 0;\n\tconst char\t*why;\n\tunsigned int\tpart = 1;\n\tunsigned long\tflags = 0;\n\tint\t\tsaved_ret = 0;\n\tint\t\tret;\n\n\twhy = kmsg_dump_reason_str(reason);\n\n\tif (pstore_cannot_block_path(reason)) {\n\t\tif (!spin_trylock_irqsave(&psinfo->buf_lock, flags)) {\n\t\t\tpr_err(\"dump skipped in %s path because of concurrent dump\\n\",\n\t\t\t\t\tin_nmi() ? \"NMI\" : why);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tspin_lock_irqsave(&psinfo->buf_lock, flags);\n\t}\n\n\tkmsg_dump_rewind(&iter);\n\n\toopscount++;\n\twhile (total < kmsg_bytes) {\n\t\tchar *dst;\n\t\tsize_t dst_size;\n\t\tint header_size;\n\t\tint zipped_len = -1;\n\t\tsize_t dump_size;\n\t\tstruct pstore_record record;\n\n\t\tpstore_record_init(&record, psinfo);\n\t\trecord.type = PSTORE_TYPE_DMESG;\n\t\trecord.count = oopscount;\n\t\trecord.reason = reason;\n\t\trecord.part = part;\n\t\trecord.buf = psinfo->buf;\n\n\t\tdst = big_oops_buf ?: psinfo->buf;\n\t\tdst_size = max_compressed_size ?: psinfo->bufsize;\n\n\t\t \n\t\theader_size = snprintf(dst, dst_size, \"%s#%d Part%u\\n\", why,\n\t\t\t\t oopscount, part);\n\t\tdst_size -= header_size;\n\n\t\t \n\t\tif (!kmsg_dump_get_buffer(&iter, true, dst + header_size,\n\t\t\t\t\t  dst_size, &dump_size))\n\t\t\tbreak;\n\n\t\tif (big_oops_buf) {\n\t\t\tzipped_len = pstore_compress(dst, psinfo->buf,\n\t\t\t\t\t\theader_size + dump_size,\n\t\t\t\t\t\tpsinfo->bufsize);\n\n\t\t\tif (zipped_len > 0) {\n\t\t\t\trecord.compressed = true;\n\t\t\t\trecord.size = zipped_len;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\trecord.size = psinfo->bufsize;\n\t\t\t\tmemcpy(psinfo->buf, dst, psinfo->bufsize);\n\t\t\t}\n\t\t} else {\n\t\t\trecord.size = header_size + dump_size;\n\t\t}\n\n\t\tret = psinfo->write(&record);\n\t\tif (ret == 0 && reason == KMSG_DUMP_OOPS) {\n\t\t\tpstore_new_entry = 1;\n\t\t\tpstore_timer_kick();\n\t\t} else {\n\t\t\t \n\t\t\tif (!saved_ret)\n\t\t\t\tsaved_ret = ret;\n\t\t}\n\n\t\ttotal += record.size;\n\t\tpart++;\n\t}\n\tspin_unlock_irqrestore(&psinfo->buf_lock, flags);\n\n\tif (saved_ret) {\n\t\tpr_err_once(\"backend (%s) writing error (%d)\\n\", psinfo->name,\n\t\t\t    saved_ret);\n\t}\n}\n\nstatic struct kmsg_dumper pstore_dumper = {\n\t.dump = pstore_dump,\n};\n\n \nstatic void pstore_register_kmsg(void)\n{\n\tkmsg_dump_register(&pstore_dumper);\n}\n\nstatic void pstore_unregister_kmsg(void)\n{\n\tkmsg_dump_unregister(&pstore_dumper);\n}\n\n#ifdef CONFIG_PSTORE_CONSOLE\nstatic void pstore_console_write(struct console *con, const char *s, unsigned c)\n{\n\tstruct pstore_record record;\n\n\tif (!c)\n\t\treturn;\n\n\tpstore_record_init(&record, psinfo);\n\trecord.type = PSTORE_TYPE_CONSOLE;\n\n\trecord.buf = (char *)s;\n\trecord.size = c;\n\tpsinfo->write(&record);\n}\n\nstatic struct console pstore_console = {\n\t.write\t= pstore_console_write,\n\t.index\t= -1,\n};\n\nstatic void pstore_register_console(void)\n{\n\t \n\tstrscpy(pstore_console.name, psinfo->name,\n\t\tsizeof(pstore_console.name));\n\t \n\tpstore_console.flags = CON_PRINTBUFFER | CON_ENABLED | CON_ANYTIME;\n\tregister_console(&pstore_console);\n}\n\nstatic void pstore_unregister_console(void)\n{\n\tunregister_console(&pstore_console);\n}\n#else\nstatic void pstore_register_console(void) {}\nstatic void pstore_unregister_console(void) {}\n#endif\n\nstatic int pstore_write_user_compat(struct pstore_record *record,\n\t\t\t\t    const char __user *buf)\n{\n\tint ret = 0;\n\n\tif (record->buf)\n\t\treturn -EINVAL;\n\n\trecord->buf = vmemdup_user(buf, record->size);\n\tif (IS_ERR(record->buf)) {\n\t\tret = PTR_ERR(record->buf);\n\t\tgoto out;\n\t}\n\n\tret = record->psi->write(record);\n\n\tkvfree(record->buf);\nout:\n\trecord->buf = NULL;\n\n\treturn unlikely(ret < 0) ? ret : record->size;\n}\n\n \nint pstore_register(struct pstore_info *psi)\n{\n\tchar *new_backend;\n\n\tif (backend && strcmp(backend, psi->name)) {\n\t\tpr_warn(\"backend '%s' already in use: ignoring '%s'\\n\",\n\t\t\tbackend, psi->name);\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tif (!psi->flags) {\n\t\tpr_warn(\"backend '%s' must support at least one frontend\\n\",\n\t\t\tpsi->name);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!psi->read || !psi->write) {\n\t\tpr_warn(\"backend '%s' must implement read() and write()\\n\",\n\t\t\tpsi->name);\n\t\treturn -EINVAL;\n\t}\n\n\tnew_backend = kstrdup(psi->name, GFP_KERNEL);\n\tif (!new_backend)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&psinfo_lock);\n\tif (psinfo) {\n\t\tpr_warn(\"backend '%s' already loaded: ignoring '%s'\\n\",\n\t\t\tpsinfo->name, psi->name);\n\t\tmutex_unlock(&psinfo_lock);\n\t\tkfree(new_backend);\n\t\treturn -EBUSY;\n\t}\n\n\tif (!psi->write_user)\n\t\tpsi->write_user = pstore_write_user_compat;\n\tpsinfo = psi;\n\tmutex_init(&psinfo->read_mutex);\n\tspin_lock_init(&psinfo->buf_lock);\n\n\tif (psi->flags & PSTORE_FLAGS_DMESG)\n\t\tallocate_buf_for_compression();\n\n\tpstore_get_records(0);\n\n\tif (psi->flags & PSTORE_FLAGS_DMESG) {\n\t\tpstore_dumper.max_reason = psinfo->max_reason;\n\t\tpstore_register_kmsg();\n\t}\n\tif (psi->flags & PSTORE_FLAGS_CONSOLE)\n\t\tpstore_register_console();\n\tif (psi->flags & PSTORE_FLAGS_FTRACE)\n\t\tpstore_register_ftrace();\n\tif (psi->flags & PSTORE_FLAGS_PMSG)\n\t\tpstore_register_pmsg();\n\n\t \n\tpstore_timer_kick();\n\n\t \n\tbackend = new_backend;\n\n\tpr_info(\"Registered %s as persistent store backend\\n\", psi->name);\n\n\tmutex_unlock(&psinfo_lock);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(pstore_register);\n\nvoid pstore_unregister(struct pstore_info *psi)\n{\n\t \n\tif (!psi)\n\t\treturn;\n\n\tmutex_lock(&psinfo_lock);\n\n\t \n\tif (WARN_ON(psi != psinfo)) {\n\t\tmutex_unlock(&psinfo_lock);\n\t\treturn;\n\t}\n\n\t \n\tif (psi->flags & PSTORE_FLAGS_PMSG)\n\t\tpstore_unregister_pmsg();\n\tif (psi->flags & PSTORE_FLAGS_FTRACE)\n\t\tpstore_unregister_ftrace();\n\tif (psi->flags & PSTORE_FLAGS_CONSOLE)\n\t\tpstore_unregister_console();\n\tif (psi->flags & PSTORE_FLAGS_DMESG)\n\t\tpstore_unregister_kmsg();\n\n\t \n\tdel_timer_sync(&pstore_timer);\n\tflush_work(&pstore_work);\n\n\t \n\tpstore_put_backend_records(psi);\n\n\tfree_buf_for_compression();\n\n\tpsinfo = NULL;\n\tkfree(backend);\n\tbackend = NULL;\n\n\tpr_info(\"Unregistered %s as persistent store backend\\n\", psi->name);\n\tmutex_unlock(&psinfo_lock);\n}\nEXPORT_SYMBOL_GPL(pstore_unregister);\n\nstatic void decompress_record(struct pstore_record *record,\n\t\t\t      struct z_stream_s *zstream)\n{\n\tint ret;\n\tint unzipped_len;\n\tchar *unzipped, *workspace;\n\tsize_t max_uncompressed_size;\n\n\tif (!IS_ENABLED(CONFIG_PSTORE_COMPRESS) || !record->compressed)\n\t\treturn;\n\n\t \n\tif (record->type != PSTORE_TYPE_DMESG) {\n\t\tpr_warn(\"ignored compressed record type %d\\n\", record->type);\n\t\treturn;\n\t}\n\n\t \n\tif (!zstream->workspace) {\n\t\tpr_warn(\"no decompression method initialized!\\n\");\n\t\treturn;\n\t}\n\n\tret = zlib_inflateReset(zstream);\n\tif (ret != Z_OK) {\n\t\tpr_err(\"zlib_inflateReset() failed, ret = %d!\\n\", ret);\n\t\treturn;\n\t}\n\n\t \n\tmax_uncompressed_size = 3 * psinfo->bufsize;\n\tworkspace = kvzalloc(max_uncompressed_size + record->ecc_notice_size,\n\t\t\t     GFP_KERNEL);\n\tif (!workspace)\n\t\treturn;\n\n\tzstream->next_in\t= record->buf;\n\tzstream->avail_in\t= record->size;\n\tzstream->next_out\t= workspace;\n\tzstream->avail_out\t= max_uncompressed_size;\n\n\tret = zlib_inflate(zstream, Z_FINISH);\n\tif (ret != Z_STREAM_END) {\n\t\tpr_err_ratelimited(\"zlib_inflate() failed, ret = %d!\\n\", ret);\n\t\tkvfree(workspace);\n\t\treturn;\n\t}\n\n\tunzipped_len = zstream->total_out;\n\n\t \n\tmemcpy(workspace + unzipped_len, record->buf + record->size,\n\t       record->ecc_notice_size);\n\n\t \n\tunzipped = kvmemdup(workspace, unzipped_len + record->ecc_notice_size,\n\t\t\t    GFP_KERNEL);\n\tkvfree(workspace);\n\tif (!unzipped)\n\t\treturn;\n\n\t \n\tkvfree(record->buf);\n\trecord->buf = unzipped;\n\trecord->size = unzipped_len;\n\trecord->compressed = false;\n}\n\n \nvoid pstore_get_backend_records(struct pstore_info *psi,\n\t\t\t\tstruct dentry *root, int quiet)\n{\n\tint failed = 0;\n\tunsigned int stop_loop = 65536;\n\tstruct z_stream_s zstream = {};\n\n\tif (!psi || !root)\n\t\treturn;\n\n\tif (IS_ENABLED(CONFIG_PSTORE_COMPRESS) && compress) {\n\t\tzstream.workspace = kvmalloc(zlib_inflate_workspacesize(),\n\t\t\t\t\t     GFP_KERNEL);\n\t\tzlib_inflateInit2(&zstream, -DEF_WBITS);\n\t}\n\n\tmutex_lock(&psi->read_mutex);\n\tif (psi->open && psi->open(psi))\n\t\tgoto out;\n\n\t \n\tfor (; stop_loop; stop_loop--) {\n\t\tstruct pstore_record *record;\n\t\tint rc;\n\n\t\trecord = kzalloc(sizeof(*record), GFP_KERNEL);\n\t\tif (!record) {\n\t\t\tpr_err(\"out of memory creating record\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tpstore_record_init(record, psi);\n\n\t\trecord->size = psi->read(record);\n\n\t\t \n\t\tif (record->size <= 0) {\n\t\t\tkfree(record);\n\t\t\tbreak;\n\t\t}\n\n\t\tdecompress_record(record, &zstream);\n\t\trc = pstore_mkfile(root, record);\n\t\tif (rc) {\n\t\t\t \n\t\t\tkvfree(record->buf);\n\t\t\tkfree(record->priv);\n\t\t\tkfree(record);\n\t\t\tif (rc != -EEXIST || !quiet)\n\t\t\t\tfailed++;\n\t\t}\n\t}\n\tif (psi->close)\n\t\tpsi->close(psi);\nout:\n\tmutex_unlock(&psi->read_mutex);\n\n\tif (IS_ENABLED(CONFIG_PSTORE_COMPRESS) && compress) {\n\t\tif (zlib_inflateEnd(&zstream) != Z_OK)\n\t\t\tpr_warn(\"zlib_inflateEnd() failed\\n\");\n\t\tkvfree(zstream.workspace);\n\t}\n\n\tif (failed)\n\t\tpr_warn(\"failed to create %d record(s) from '%s'\\n\",\n\t\t\tfailed, psi->name);\n\tif (!stop_loop)\n\t\tpr_err(\"looping? Too many records seen from '%s'\\n\",\n\t\t\tpsi->name);\n}\n\nstatic void pstore_dowork(struct work_struct *work)\n{\n\tpstore_get_records(1);\n}\n\nstatic void pstore_timefunc(struct timer_list *unused)\n{\n\tif (pstore_new_entry) {\n\t\tpstore_new_entry = 0;\n\t\tschedule_work(&pstore_work);\n\t}\n\n\tpstore_timer_kick();\n}\n\nstatic int __init pstore_init(void)\n{\n\tint ret;\n\n\tret = pstore_init_fs();\n\tif (ret)\n\t\tfree_buf_for_compression();\n\n\treturn ret;\n}\nlate_initcall(pstore_init);\n\nstatic void __exit pstore_exit(void)\n{\n\tpstore_exit_fs();\n}\nmodule_exit(pstore_exit)\n\nMODULE_AUTHOR(\"Tony Luck <tony.luck@intel.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}