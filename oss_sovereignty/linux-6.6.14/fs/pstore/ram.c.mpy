{
  "module_name": "ram.c",
  "hash_id": "a59bdd98a58e324ea13013049d9b422eb3628de8a4e520e430ff90b959944345",
  "original_prompt": "Ingested from linux-6.6.14/fs/pstore/ram.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/version.h>\n#include <linux/pstore.h>\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/compiler.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/mm.h>\n\n#include \"internal.h\"\n#include \"ram_internal.h\"\n\n#define RAMOOPS_KERNMSG_HDR \"====\"\n#define MIN_MEM_SIZE 4096UL\n\nstatic ulong record_size = MIN_MEM_SIZE;\nmodule_param(record_size, ulong, 0400);\nMODULE_PARM_DESC(record_size,\n\t\t\"size of each dump done on oops/panic\");\n\nstatic ulong ramoops_console_size = MIN_MEM_SIZE;\nmodule_param_named(console_size, ramoops_console_size, ulong, 0400);\nMODULE_PARM_DESC(console_size, \"size of kernel console log\");\n\nstatic ulong ramoops_ftrace_size = MIN_MEM_SIZE;\nmodule_param_named(ftrace_size, ramoops_ftrace_size, ulong, 0400);\nMODULE_PARM_DESC(ftrace_size, \"size of ftrace log\");\n\nstatic ulong ramoops_pmsg_size = MIN_MEM_SIZE;\nmodule_param_named(pmsg_size, ramoops_pmsg_size, ulong, 0400);\nMODULE_PARM_DESC(pmsg_size, \"size of user space message log\");\n\nstatic unsigned long long mem_address;\nmodule_param_hw(mem_address, ullong, other, 0400);\nMODULE_PARM_DESC(mem_address,\n\t\t\"start of reserved RAM used to store oops/panic logs\");\n\nstatic ulong mem_size;\nmodule_param(mem_size, ulong, 0400);\nMODULE_PARM_DESC(mem_size,\n\t\t\"size of reserved RAM used to store oops/panic logs\");\n\nstatic unsigned int mem_type;\nmodule_param(mem_type, uint, 0400);\nMODULE_PARM_DESC(mem_type,\n\t\t\"memory type: 0=write-combined (default), 1=unbuffered, 2=cached\");\n\nstatic int ramoops_max_reason = -1;\nmodule_param_named(max_reason, ramoops_max_reason, int, 0400);\nMODULE_PARM_DESC(max_reason,\n\t\t \"maximum reason for kmsg dump (default 2: Oops and Panic) \");\n\nstatic int ramoops_ecc;\nmodule_param_named(ecc, ramoops_ecc, int, 0400);\nMODULE_PARM_DESC(ramoops_ecc,\n\t\t\"if non-zero, the option enables ECC support and specifies \"\n\t\t\"ECC buffer size in bytes (1 is a special value, means 16 \"\n\t\t\"bytes ECC)\");\n\nstatic int ramoops_dump_oops = -1;\nmodule_param_named(dump_oops, ramoops_dump_oops, int, 0400);\nMODULE_PARM_DESC(dump_oops,\n\t\t \"(deprecated: use max_reason instead) set to 1 to dump oopses & panics, 0 to only dump panics\");\n\nstruct ramoops_context {\n\tstruct persistent_ram_zone **dprzs;\t \n\tstruct persistent_ram_zone *cprz;\t \n\tstruct persistent_ram_zone **fprzs;\t \n\tstruct persistent_ram_zone *mprz;\t \n\tphys_addr_t phys_addr;\n\tunsigned long size;\n\tunsigned int memtype;\n\tsize_t record_size;\n\tsize_t console_size;\n\tsize_t ftrace_size;\n\tsize_t pmsg_size;\n\tu32 flags;\n\tstruct persistent_ram_ecc_info ecc_info;\n\tunsigned int max_dump_cnt;\n\tunsigned int dump_write_cnt;\n\t \n\tunsigned int dump_read_cnt;\n\tunsigned int console_read_cnt;\n\tunsigned int max_ftrace_cnt;\n\tunsigned int ftrace_read_cnt;\n\tunsigned int pmsg_read_cnt;\n\tstruct pstore_info pstore;\n};\n\nstatic struct platform_device *dummy;\n\nstatic int ramoops_pstore_open(struct pstore_info *psi)\n{\n\tstruct ramoops_context *cxt = psi->data;\n\n\tcxt->dump_read_cnt = 0;\n\tcxt->console_read_cnt = 0;\n\tcxt->ftrace_read_cnt = 0;\n\tcxt->pmsg_read_cnt = 0;\n\treturn 0;\n}\n\nstatic struct persistent_ram_zone *\nramoops_get_next_prz(struct persistent_ram_zone *przs[], int id,\n\t\t     struct pstore_record *record)\n{\n\tstruct persistent_ram_zone *prz;\n\n\t \n\tif (!przs)\n\t\treturn NULL;\n\n\tprz = przs[id];\n\tif (!prz)\n\t\treturn NULL;\n\n\t \n\tif (prz->type == PSTORE_TYPE_DMESG)\n\t\tpersistent_ram_save_old(prz);\n\n\tif (!persistent_ram_old_size(prz))\n\t\treturn NULL;\n\n\trecord->type = prz->type;\n\trecord->id = id;\n\n\treturn prz;\n}\n\nstatic int ramoops_read_kmsg_hdr(char *buffer, struct timespec64 *time,\n\t\t\t\t  bool *compressed)\n{\n\tchar data_type;\n\tint header_length = 0;\n\n\tif (sscanf(buffer, RAMOOPS_KERNMSG_HDR \"%lld.%lu-%c\\n%n\",\n\t\t   (time64_t *)&time->tv_sec, &time->tv_nsec, &data_type,\n\t\t   &header_length) == 3) {\n\t\ttime->tv_nsec *= 1000;\n\t\tif (data_type == 'C')\n\t\t\t*compressed = true;\n\t\telse\n\t\t\t*compressed = false;\n\t} else if (sscanf(buffer, RAMOOPS_KERNMSG_HDR \"%lld.%lu\\n%n\",\n\t\t\t  (time64_t *)&time->tv_sec, &time->tv_nsec,\n\t\t\t  &header_length) == 2) {\n\t\ttime->tv_nsec *= 1000;\n\t\t*compressed = false;\n\t} else {\n\t\ttime->tv_sec = 0;\n\t\ttime->tv_nsec = 0;\n\t\t*compressed = false;\n\t}\n\treturn header_length;\n}\n\nstatic bool prz_ok(struct persistent_ram_zone *prz)\n{\n\treturn !!prz && !!(persistent_ram_old_size(prz) +\n\t\t\t   persistent_ram_ecc_string(prz, NULL, 0));\n}\n\nstatic ssize_t ramoops_pstore_read(struct pstore_record *record)\n{\n\tssize_t size = 0;\n\tstruct ramoops_context *cxt = record->psi->data;\n\tstruct persistent_ram_zone *prz = NULL;\n\tint header_length = 0;\n\tbool free_prz = false;\n\n\t \n\trecord->time.tv_sec = 0;\n\trecord->time.tv_nsec = 0;\n\trecord->compressed = false;\n\n\t \n\twhile (cxt->dump_read_cnt < cxt->max_dump_cnt && !prz) {\n\t\tprz = ramoops_get_next_prz(cxt->dprzs, cxt->dump_read_cnt++,\n\t\t\t\t\t   record);\n\t\tif (!prz_ok(prz))\n\t\t\tcontinue;\n\t\theader_length = ramoops_read_kmsg_hdr(persistent_ram_old(prz),\n\t\t\t\t\t\t      &record->time,\n\t\t\t\t\t\t      &record->compressed);\n\t\t \n\t\tif (!header_length) {\n\t\t\tpersistent_ram_free_old(prz);\n\t\t\tpersistent_ram_zap(prz);\n\t\t\tprz = NULL;\n\t\t}\n\t}\n\n\tif (!prz_ok(prz) && !cxt->console_read_cnt++)\n\t\tprz = ramoops_get_next_prz(&cxt->cprz, 0  , record);\n\n\tif (!prz_ok(prz) && !cxt->pmsg_read_cnt++)\n\t\tprz = ramoops_get_next_prz(&cxt->mprz, 0  , record);\n\n\t \n\tif (!prz_ok(prz)) {\n\t\tif (!(cxt->flags & RAMOOPS_FLAG_FTRACE_PER_CPU) &&\n\t\t    !cxt->ftrace_read_cnt++) {\n\t\t\tprz = ramoops_get_next_prz(cxt->fprzs, 0  ,\n\t\t\t\t\t\t   record);\n\t\t} else {\n\t\t\t \n\t\t\tstruct persistent_ram_zone *tmp_prz, *prz_next;\n\n\t\t\ttmp_prz = kzalloc(sizeof(struct persistent_ram_zone),\n\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (!tmp_prz)\n\t\t\t\treturn -ENOMEM;\n\t\t\tprz = tmp_prz;\n\t\t\tfree_prz = true;\n\n\t\t\twhile (cxt->ftrace_read_cnt < cxt->max_ftrace_cnt) {\n\t\t\t\tprz_next = ramoops_get_next_prz(cxt->fprzs,\n\t\t\t\t\t\tcxt->ftrace_read_cnt++, record);\n\n\t\t\t\tif (!prz_ok(prz_next))\n\t\t\t\t\tcontinue;\n\n\t\t\t\ttmp_prz->ecc_info = prz_next->ecc_info;\n\t\t\t\ttmp_prz->corrected_bytes +=\n\t\t\t\t\t\tprz_next->corrected_bytes;\n\t\t\t\ttmp_prz->bad_blocks += prz_next->bad_blocks;\n\n\t\t\t\tsize = pstore_ftrace_combine_log(\n\t\t\t\t\t\t&tmp_prz->old_log,\n\t\t\t\t\t\t&tmp_prz->old_log_size,\n\t\t\t\t\t\tprz_next->old_log,\n\t\t\t\t\t\tprz_next->old_log_size);\n\t\t\t\tif (size)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\trecord->id = 0;\n\t\t}\n\t}\n\n\tif (!prz_ok(prz)) {\n\t\tsize = 0;\n\t\tgoto out;\n\t}\n\n\tsize = persistent_ram_old_size(prz) - header_length;\n\n\t \n\trecord->ecc_notice_size = persistent_ram_ecc_string(prz, NULL, 0);\n\n\trecord->buf = kvzalloc(size + record->ecc_notice_size + 1, GFP_KERNEL);\n\tif (record->buf == NULL) {\n\t\tsize = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmemcpy(record->buf, (char *)persistent_ram_old(prz) + header_length,\n\t       size);\n\n\tpersistent_ram_ecc_string(prz, record->buf + size,\n\t\t\t\t  record->ecc_notice_size + 1);\n\nout:\n\tif (free_prz) {\n\t\tkvfree(prz->old_log);\n\t\tkfree(prz);\n\t}\n\n\treturn size;\n}\n\nstatic size_t ramoops_write_kmsg_hdr(struct persistent_ram_zone *prz,\n\t\t\t\t     struct pstore_record *record)\n{\n\tchar hdr[36];  \n\tsize_t len;\n\n\tlen = scnprintf(hdr, sizeof(hdr),\n\t\tRAMOOPS_KERNMSG_HDR \"%lld.%06lu-%c\\n\",\n\t\t(time64_t)record->time.tv_sec,\n\t\trecord->time.tv_nsec / 1000,\n\t\trecord->compressed ? 'C' : 'D');\n\tpersistent_ram_write(prz, hdr, len);\n\n\treturn len;\n}\n\nstatic int notrace ramoops_pstore_write(struct pstore_record *record)\n{\n\tstruct ramoops_context *cxt = record->psi->data;\n\tstruct persistent_ram_zone *prz;\n\tsize_t size, hlen;\n\n\tif (record->type == PSTORE_TYPE_CONSOLE) {\n\t\tif (!cxt->cprz)\n\t\t\treturn -ENOMEM;\n\t\tpersistent_ram_write(cxt->cprz, record->buf, record->size);\n\t\treturn 0;\n\t} else if (record->type == PSTORE_TYPE_FTRACE) {\n\t\tint zonenum;\n\n\t\tif (!cxt->fprzs)\n\t\t\treturn -ENOMEM;\n\t\t \n\t\tif (cxt->flags & RAMOOPS_FLAG_FTRACE_PER_CPU)\n\t\t\tzonenum = smp_processor_id();\n\t\telse\n\t\t\tzonenum = 0;\n\n\t\tpersistent_ram_write(cxt->fprzs[zonenum], record->buf,\n\t\t\t\t     record->size);\n\t\treturn 0;\n\t} else if (record->type == PSTORE_TYPE_PMSG) {\n\t\tpr_warn_ratelimited(\"PMSG shouldn't call %s\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (record->type != PSTORE_TYPE_DMESG)\n\t\treturn -EINVAL;\n\n\t \n\n\t \n\tif (record->part != 1)\n\t\treturn -ENOSPC;\n\n\tif (!cxt->dprzs)\n\t\treturn -ENOSPC;\n\n\tprz = cxt->dprzs[cxt->dump_write_cnt];\n\n\t \n\tpersistent_ram_zap(prz);\n\n\t \n\thlen = ramoops_write_kmsg_hdr(prz, record);\n\tif (!hlen)\n\t\treturn -ENOMEM;\n\n\tsize = record->size;\n\tif (size + hlen > prz->buffer_size)\n\t\tsize = prz->buffer_size - hlen;\n\tpersistent_ram_write(prz, record->buf, size);\n\n\tcxt->dump_write_cnt = (cxt->dump_write_cnt + 1) % cxt->max_dump_cnt;\n\n\treturn 0;\n}\n\nstatic int notrace ramoops_pstore_write_user(struct pstore_record *record,\n\t\t\t\t\t     const char __user *buf)\n{\n\tif (record->type == PSTORE_TYPE_PMSG) {\n\t\tstruct ramoops_context *cxt = record->psi->data;\n\n\t\tif (!cxt->mprz)\n\t\t\treturn -ENOMEM;\n\t\treturn persistent_ram_write_user(cxt->mprz, buf, record->size);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int ramoops_pstore_erase(struct pstore_record *record)\n{\n\tstruct ramoops_context *cxt = record->psi->data;\n\tstruct persistent_ram_zone *prz;\n\n\tswitch (record->type) {\n\tcase PSTORE_TYPE_DMESG:\n\t\tif (record->id >= cxt->max_dump_cnt)\n\t\t\treturn -EINVAL;\n\t\tprz = cxt->dprzs[record->id];\n\t\tbreak;\n\tcase PSTORE_TYPE_CONSOLE:\n\t\tprz = cxt->cprz;\n\t\tbreak;\n\tcase PSTORE_TYPE_FTRACE:\n\t\tif (record->id >= cxt->max_ftrace_cnt)\n\t\t\treturn -EINVAL;\n\t\tprz = cxt->fprzs[record->id];\n\t\tbreak;\n\tcase PSTORE_TYPE_PMSG:\n\t\tprz = cxt->mprz;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tpersistent_ram_free_old(prz);\n\tpersistent_ram_zap(prz);\n\n\treturn 0;\n}\n\nstatic struct ramoops_context oops_cxt = {\n\t.pstore = {\n\t\t.owner\t= THIS_MODULE,\n\t\t.name\t= \"ramoops\",\n\t\t.open\t= ramoops_pstore_open,\n\t\t.read\t= ramoops_pstore_read,\n\t\t.write\t= ramoops_pstore_write,\n\t\t.write_user\t= ramoops_pstore_write_user,\n\t\t.erase\t= ramoops_pstore_erase,\n\t},\n};\n\nstatic void ramoops_free_przs(struct ramoops_context *cxt)\n{\n\tint i;\n\n\t \n\tpersistent_ram_free(&cxt->mprz);\n\n\t \n\tpersistent_ram_free(&cxt->cprz);\n\n\t \n\tif (cxt->dprzs) {\n\t\tfor (i = 0; i < cxt->max_dump_cnt; i++)\n\t\t\tpersistent_ram_free(&cxt->dprzs[i]);\n\n\t\tkfree(cxt->dprzs);\n\t\tcxt->dprzs = NULL;\n\t\tcxt->max_dump_cnt = 0;\n\t}\n\n\t \n\tif (cxt->fprzs) {\n\t\tfor (i = 0; i < cxt->max_ftrace_cnt; i++)\n\t\t\tpersistent_ram_free(&cxt->fprzs[i]);\n\t\tkfree(cxt->fprzs);\n\t\tcxt->fprzs = NULL;\n\t\tcxt->max_ftrace_cnt = 0;\n\t}\n}\n\nstatic int ramoops_init_przs(const char *name,\n\t\t\t     struct device *dev, struct ramoops_context *cxt,\n\t\t\t     struct persistent_ram_zone ***przs,\n\t\t\t     phys_addr_t *paddr, size_t mem_sz,\n\t\t\t     ssize_t record_size,\n\t\t\t     unsigned int *cnt, u32 sig, u32 flags)\n{\n\tint err = -ENOMEM;\n\tint i;\n\tsize_t zone_sz;\n\tstruct persistent_ram_zone **prz_ar;\n\n\t \n\tif (mem_sz == 0 || record_size == 0) {\n\t\t*cnt = 0;\n\t\treturn 0;\n\t}\n\n\t \n\tif (record_size < 0) {\n\t\tif (*cnt == 0)\n\t\t\treturn 0;\n\t\trecord_size = mem_sz / *cnt;\n\t\tif (record_size == 0) {\n\t\t\tdev_err(dev, \"%s record size == 0 (%zu / %u)\\n\",\n\t\t\t\tname, mem_sz, *cnt);\n\t\t\tgoto fail;\n\t\t}\n\t} else {\n\t\t*cnt = mem_sz / record_size;\n\t\tif (*cnt == 0) {\n\t\t\tdev_err(dev, \"%s record count == 0 (%zu / %zu)\\n\",\n\t\t\t\tname, mem_sz, record_size);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tif (*paddr + mem_sz - cxt->phys_addr > cxt->size) {\n\t\tdev_err(dev, \"no room for %s mem region (0x%zx@0x%llx) in (0x%lx@0x%llx)\\n\",\n\t\t\tname,\n\t\t\tmem_sz, (unsigned long long)*paddr,\n\t\t\tcxt->size, (unsigned long long)cxt->phys_addr);\n\t\tgoto fail;\n\t}\n\n\tzone_sz = mem_sz / *cnt;\n\tif (!zone_sz) {\n\t\tdev_err(dev, \"%s zone size == 0\\n\", name);\n\t\tgoto fail;\n\t}\n\n\tprz_ar = kcalloc(*cnt, sizeof(**przs), GFP_KERNEL);\n\tif (!prz_ar)\n\t\tgoto fail;\n\n\tfor (i = 0; i < *cnt; i++) {\n\t\tchar *label;\n\n\t\tif (*cnt == 1)\n\t\t\tlabel = kasprintf(GFP_KERNEL, \"ramoops:%s\", name);\n\t\telse\n\t\t\tlabel = kasprintf(GFP_KERNEL, \"ramoops:%s(%d/%d)\",\n\t\t\t\t\t  name, i, *cnt - 1);\n\t\tprz_ar[i] = persistent_ram_new(*paddr, zone_sz, sig,\n\t\t\t\t\t       &cxt->ecc_info,\n\t\t\t\t\t       cxt->memtype, flags, label);\n\t\tkfree(label);\n\t\tif (IS_ERR(prz_ar[i])) {\n\t\t\terr = PTR_ERR(prz_ar[i]);\n\t\t\tdev_err(dev, \"failed to request %s mem region (0x%zx@0x%llx): %d\\n\",\n\t\t\t\tname, record_size,\n\t\t\t\t(unsigned long long)*paddr, err);\n\n\t\t\twhile (i > 0) {\n\t\t\t\ti--;\n\t\t\t\tpersistent_ram_free(&prz_ar[i]);\n\t\t\t}\n\t\t\tkfree(prz_ar);\n\t\t\tprz_ar = NULL;\n\t\t\tgoto fail;\n\t\t}\n\t\t*paddr += zone_sz;\n\t\tprz_ar[i]->type = pstore_name_to_type(name);\n\t}\n\n\t*przs = prz_ar;\n\treturn 0;\n\nfail:\n\t*cnt = 0;\n\treturn err;\n}\n\nstatic int ramoops_init_prz(const char *name,\n\t\t\t    struct device *dev, struct ramoops_context *cxt,\n\t\t\t    struct persistent_ram_zone **prz,\n\t\t\t    phys_addr_t *paddr, size_t sz, u32 sig)\n{\n\tchar *label;\n\n\tif (!sz)\n\t\treturn 0;\n\n\tif (*paddr + sz - cxt->phys_addr > cxt->size) {\n\t\tdev_err(dev, \"no room for %s mem region (0x%zx@0x%llx) in (0x%lx@0x%llx)\\n\",\n\t\t\tname, sz, (unsigned long long)*paddr,\n\t\t\tcxt->size, (unsigned long long)cxt->phys_addr);\n\t\treturn -ENOMEM;\n\t}\n\n\tlabel = kasprintf(GFP_KERNEL, \"ramoops:%s\", name);\n\t*prz = persistent_ram_new(*paddr, sz, sig, &cxt->ecc_info,\n\t\t\t\t  cxt->memtype, PRZ_FLAG_ZAP_OLD, label);\n\tkfree(label);\n\tif (IS_ERR(*prz)) {\n\t\tint err = PTR_ERR(*prz);\n\n\t\tdev_err(dev, \"failed to request %s mem region (0x%zx@0x%llx): %d\\n\",\n\t\t\tname, sz, (unsigned long long)*paddr, err);\n\t\treturn err;\n\t}\n\n\t*paddr += sz;\n\t(*prz)->type = pstore_name_to_type(name);\n\n\treturn 0;\n}\n\n \nstatic int ramoops_parse_dt_u32(struct platform_device *pdev,\n\t\t\t\tconst char *propname,\n\t\t\t\tu32 default_value, u32 *value)\n{\n\tu32 val32 = 0;\n\tint ret;\n\n\tret = of_property_read_u32(pdev->dev.of_node, propname, &val32);\n\tif (ret == -EINVAL) {\n\t\t \n\t\tval32 = default_value;\n\t} else if (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to parse property %s: %d\\n\",\n\t\t\tpropname, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (val32 > INT_MAX) {\n\t\tdev_err(&pdev->dev, \"%s %u > INT_MAX\\n\", propname, val32);\n\t\treturn -EOVERFLOW;\n\t}\n\n\t*value = val32;\n\treturn 0;\n}\n\nstatic int ramoops_parse_dt(struct platform_device *pdev,\n\t\t\t    struct ramoops_platform_data *pdata)\n{\n\tstruct device_node *of_node = pdev->dev.of_node;\n\tstruct device_node *parent_node;\n\tstruct resource *res;\n\tu32 value;\n\tint ret;\n\n\tdev_dbg(&pdev->dev, \"using Device Tree\\n\");\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"failed to locate DT /reserved-memory resource\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpdata->mem_size = resource_size(res);\n\tpdata->mem_address = res->start;\n\t \n\tpdata->mem_type = of_property_read_bool(of_node, \"unbuffered\");\n\t \n\tif (of_property_read_bool(of_node, \"no-dump-oops\"))\n\t\tpdata->max_reason = KMSG_DUMP_PANIC;\n\telse\n\t\tpdata->max_reason = KMSG_DUMP_OOPS;\n\n#define parse_u32(name, field, default_value) {\t\t\t\t\\\n\t\tret = ramoops_parse_dt_u32(pdev, name, default_value,\t\\\n\t\t\t\t\t    &value);\t\t\t\\\n\t\tif (ret < 0)\t\t\t\t\t\t\\\n\t\t\treturn ret;\t\t\t\t\t\\\n\t\tfield = value;\t\t\t\t\t\t\\\n\t}\n\n\tparse_u32(\"mem-type\", pdata->mem_type, pdata->mem_type);\n\tparse_u32(\"record-size\", pdata->record_size, 0);\n\tparse_u32(\"console-size\", pdata->console_size, 0);\n\tparse_u32(\"ftrace-size\", pdata->ftrace_size, 0);\n\tparse_u32(\"pmsg-size\", pdata->pmsg_size, 0);\n\tparse_u32(\"ecc-size\", pdata->ecc_info.ecc_size, 0);\n\tparse_u32(\"flags\", pdata->flags, 0);\n\tparse_u32(\"max-reason\", pdata->max_reason, pdata->max_reason);\n\n#undef parse_u32\n\n\t \n\tparent_node = of_get_parent(of_node);\n\tif (!of_node_name_eq(parent_node, \"reserved-memory\") &&\n\t    !pdata->console_size && !pdata->ftrace_size &&\n\t    !pdata->pmsg_size && !pdata->ecc_info.ecc_size) {\n\t\tpdata->console_size = pdata->record_size;\n\t\tpdata->pmsg_size = pdata->record_size;\n\t}\n\tof_node_put(parent_node);\n\n\treturn 0;\n}\n\nstatic int ramoops_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct ramoops_platform_data *pdata = dev->platform_data;\n\tstruct ramoops_platform_data pdata_local;\n\tstruct ramoops_context *cxt = &oops_cxt;\n\tsize_t dump_mem_sz;\n\tphys_addr_t paddr;\n\tint err = -EINVAL;\n\n\t \n\tif (cxt->max_dump_cnt) {\n\t\tpr_err(\"already initialized\\n\");\n\t\tgoto fail_out;\n\t}\n\n\tif (dev_of_node(dev) && !pdata) {\n\t\tpdata = &pdata_local;\n\t\tmemset(pdata, 0, sizeof(*pdata));\n\n\t\terr = ramoops_parse_dt(pdev, pdata);\n\t\tif (err < 0)\n\t\t\tgoto fail_out;\n\t}\n\n\t \n\tif (!pdata) {\n\t\tpr_err(\"NULL platform data\\n\");\n\t\terr = -EINVAL;\n\t\tgoto fail_out;\n\t}\n\n\tif (!pdata->mem_size || (!pdata->record_size && !pdata->console_size &&\n\t\t\t!pdata->ftrace_size && !pdata->pmsg_size)) {\n\t\tpr_err(\"The memory size and the record/console size must be \"\n\t\t\t\"non-zero\\n\");\n\t\terr = -EINVAL;\n\t\tgoto fail_out;\n\t}\n\n\tif (pdata->record_size && !is_power_of_2(pdata->record_size))\n\t\tpdata->record_size = rounddown_pow_of_two(pdata->record_size);\n\tif (pdata->console_size && !is_power_of_2(pdata->console_size))\n\t\tpdata->console_size = rounddown_pow_of_two(pdata->console_size);\n\tif (pdata->ftrace_size && !is_power_of_2(pdata->ftrace_size))\n\t\tpdata->ftrace_size = rounddown_pow_of_two(pdata->ftrace_size);\n\tif (pdata->pmsg_size && !is_power_of_2(pdata->pmsg_size))\n\t\tpdata->pmsg_size = rounddown_pow_of_two(pdata->pmsg_size);\n\n\tcxt->size = pdata->mem_size;\n\tcxt->phys_addr = pdata->mem_address;\n\tcxt->memtype = pdata->mem_type;\n\tcxt->record_size = pdata->record_size;\n\tcxt->console_size = pdata->console_size;\n\tcxt->ftrace_size = pdata->ftrace_size;\n\tcxt->pmsg_size = pdata->pmsg_size;\n\tcxt->flags = pdata->flags;\n\tcxt->ecc_info = pdata->ecc_info;\n\n\tpaddr = cxt->phys_addr;\n\n\tdump_mem_sz = cxt->size - cxt->console_size - cxt->ftrace_size\n\t\t\t- cxt->pmsg_size;\n\terr = ramoops_init_przs(\"dmesg\", dev, cxt, &cxt->dprzs, &paddr,\n\t\t\t\tdump_mem_sz, cxt->record_size,\n\t\t\t\t&cxt->max_dump_cnt, 0, 0);\n\tif (err)\n\t\tgoto fail_init;\n\n\terr = ramoops_init_prz(\"console\", dev, cxt, &cxt->cprz, &paddr,\n\t\t\t       cxt->console_size, 0);\n\tif (err)\n\t\tgoto fail_init;\n\n\terr = ramoops_init_prz(\"pmsg\", dev, cxt, &cxt->mprz, &paddr,\n\t\t\t\tcxt->pmsg_size, 0);\n\tif (err)\n\t\tgoto fail_init;\n\n\tcxt->max_ftrace_cnt = (cxt->flags & RAMOOPS_FLAG_FTRACE_PER_CPU)\n\t\t\t\t? nr_cpu_ids\n\t\t\t\t: 1;\n\terr = ramoops_init_przs(\"ftrace\", dev, cxt, &cxt->fprzs, &paddr,\n\t\t\t\tcxt->ftrace_size, -1,\n\t\t\t\t&cxt->max_ftrace_cnt, LINUX_VERSION_CODE,\n\t\t\t\t(cxt->flags & RAMOOPS_FLAG_FTRACE_PER_CPU)\n\t\t\t\t\t? PRZ_FLAG_NO_LOCK : 0);\n\tif (err)\n\t\tgoto fail_init;\n\n\tcxt->pstore.data = cxt;\n\t \n\tcxt->pstore.flags = 0;\n\tif (cxt->max_dump_cnt) {\n\t\tcxt->pstore.flags |= PSTORE_FLAGS_DMESG;\n\t\tcxt->pstore.max_reason = pdata->max_reason;\n\t}\n\tif (cxt->console_size)\n\t\tcxt->pstore.flags |= PSTORE_FLAGS_CONSOLE;\n\tif (cxt->max_ftrace_cnt)\n\t\tcxt->pstore.flags |= PSTORE_FLAGS_FTRACE;\n\tif (cxt->pmsg_size)\n\t\tcxt->pstore.flags |= PSTORE_FLAGS_PMSG;\n\n\t \n\tif (cxt->pstore.flags & PSTORE_FLAGS_DMESG) {\n\t\tcxt->pstore.bufsize = cxt->dprzs[0]->buffer_size;\n\t\tcxt->pstore.buf = kvzalloc(cxt->pstore.bufsize, GFP_KERNEL);\n\t\tif (!cxt->pstore.buf) {\n\t\t\tpr_err(\"cannot allocate pstore crash dump buffer\\n\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto fail_clear;\n\t\t}\n\t}\n\n\terr = pstore_register(&cxt->pstore);\n\tif (err) {\n\t\tpr_err(\"registering with pstore failed\\n\");\n\t\tgoto fail_buf;\n\t}\n\n\t \n\tmem_size = pdata->mem_size;\n\tmem_address = pdata->mem_address;\n\trecord_size = pdata->record_size;\n\tramoops_max_reason = pdata->max_reason;\n\tramoops_console_size = pdata->console_size;\n\tramoops_pmsg_size = pdata->pmsg_size;\n\tramoops_ftrace_size = pdata->ftrace_size;\n\n\tpr_info(\"using 0x%lx@0x%llx, ecc: %d\\n\",\n\t\tcxt->size, (unsigned long long)cxt->phys_addr,\n\t\tcxt->ecc_info.ecc_size);\n\n\treturn 0;\n\nfail_buf:\n\tkvfree(cxt->pstore.buf);\nfail_clear:\n\tcxt->pstore.bufsize = 0;\nfail_init:\n\tramoops_free_przs(cxt);\nfail_out:\n\treturn err;\n}\n\nstatic void ramoops_remove(struct platform_device *pdev)\n{\n\tstruct ramoops_context *cxt = &oops_cxt;\n\n\tpstore_unregister(&cxt->pstore);\n\n\tkvfree(cxt->pstore.buf);\n\tcxt->pstore.bufsize = 0;\n\n\tramoops_free_przs(cxt);\n}\n\nstatic const struct of_device_id dt_match[] = {\n\t{ .compatible = \"ramoops\" },\n\t{}\n};\n\nstatic struct platform_driver ramoops_driver = {\n\t.probe\t\t= ramoops_probe,\n\t.remove_new\t= ramoops_remove,\n\t.driver\t\t= {\n\t\t.name\t\t= \"ramoops\",\n\t\t.of_match_table\t= dt_match,\n\t},\n};\n\nstatic inline void ramoops_unregister_dummy(void)\n{\n\tplatform_device_unregister(dummy);\n\tdummy = NULL;\n}\n\nstatic void __init ramoops_register_dummy(void)\n{\n\tstruct ramoops_platform_data pdata;\n\n\t \n\tif (!mem_size)\n\t\treturn;\n\n\tpr_info(\"using module parameters\\n\");\n\n\tmemset(&pdata, 0, sizeof(pdata));\n\tpdata.mem_size = mem_size;\n\tpdata.mem_address = mem_address;\n\tpdata.mem_type = mem_type;\n\tpdata.record_size = record_size;\n\tpdata.console_size = ramoops_console_size;\n\tpdata.ftrace_size = ramoops_ftrace_size;\n\tpdata.pmsg_size = ramoops_pmsg_size;\n\t \n\tif (ramoops_max_reason >= 0)\n\t\tpdata.max_reason = ramoops_max_reason;\n\t \n\telse if (ramoops_dump_oops != -1)\n\t\tpdata.max_reason = ramoops_dump_oops ? KMSG_DUMP_OOPS\n\t\t\t\t\t\t     : KMSG_DUMP_PANIC;\n\t \n\telse\n\t\tpdata.max_reason = KMSG_DUMP_OOPS;\n\tpdata.flags = RAMOOPS_FLAG_FTRACE_PER_CPU;\n\n\t \n\tpdata.ecc_info.ecc_size = ramoops_ecc == 1 ? 16 : ramoops_ecc;\n\n\tdummy = platform_device_register_data(NULL, \"ramoops\", -1,\n\t\t\t&pdata, sizeof(pdata));\n\tif (IS_ERR(dummy)) {\n\t\tpr_info(\"could not create platform device: %ld\\n\",\n\t\t\tPTR_ERR(dummy));\n\t\tdummy = NULL;\n\t}\n}\n\nstatic int __init ramoops_init(void)\n{\n\tint ret;\n\n\tramoops_register_dummy();\n\tret = platform_driver_register(&ramoops_driver);\n\tif (ret != 0)\n\t\tramoops_unregister_dummy();\n\n\treturn ret;\n}\npostcore_initcall(ramoops_init);\n\nstatic void __exit ramoops_exit(void)\n{\n\tplatform_driver_unregister(&ramoops_driver);\n\tramoops_unregister_dummy();\n}\nmodule_exit(ramoops_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Marco Stornelli <marco.stornelli@gmail.com>\");\nMODULE_DESCRIPTION(\"RAM Oops/Panic logger/driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}