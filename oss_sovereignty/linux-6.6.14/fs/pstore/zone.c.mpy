{
  "module_name": "zone.c",
  "hash_id": "bb82ea944e864506a44b515b8c1dea2e8554ee1bb212778329faa756c57e860c",
  "original_prompt": "Ingested from linux-6.6.14/fs/pstore/zone.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/fs.h>\n#include <linux/pstore_zone.h>\n#include <linux/kdev_t.h>\n#include <linux/device.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/uio.h>\n#include <linux/writeback.h>\n#include \"internal.h\"\n\n \nstruct psz_buffer {\n#define PSZ_SIG (0x43474244)  \n\tuint32_t sig;\n\tatomic_t datalen;\n\tatomic_t start;\n\tuint8_t data[];\n};\n\n \nstruct psz_kmsg_header {\n#define PSTORE_KMSG_HEADER_MAGIC 0x4dfc3ae5  \n\tuint32_t magic;\n\tstruct timespec64 time;\n\tbool compressed;\n\tuint32_t counter;\n\tenum kmsg_dump_reason reason;\n\tuint8_t data[];\n};\n\n \nstruct pstore_zone {\n\tloff_t off;\n\tconst char *name;\n\tenum pstore_type_id type;\n\n\tstruct psz_buffer *buffer;\n\tstruct psz_buffer *oldbuf;\n\tsize_t buffer_size;\n\tbool should_recover;\n\tatomic_t dirty;\n};\n\n \nstruct psz_context {\n\tstruct pstore_zone **kpszs;\n\tstruct pstore_zone *ppsz;\n\tstruct pstore_zone *cpsz;\n\tstruct pstore_zone **fpszs;\n\tunsigned int kmsg_max_cnt;\n\tunsigned int kmsg_read_cnt;\n\tunsigned int kmsg_write_cnt;\n\tunsigned int pmsg_read_cnt;\n\tunsigned int console_read_cnt;\n\tunsigned int ftrace_max_cnt;\n\tunsigned int ftrace_read_cnt;\n\t \n\tunsigned int oops_counter;\n\tunsigned int panic_counter;\n\tatomic_t recovered;\n\tatomic_t on_panic;\n\n\t \n\tstruct mutex pstore_zone_info_lock;\n\tstruct pstore_zone_info *pstore_zone_info;\n\tstruct pstore_info pstore;\n};\nstatic struct psz_context pstore_zone_cxt;\n\nstatic void psz_flush_all_dirty_zones(struct work_struct *);\nstatic DECLARE_DELAYED_WORK(psz_cleaner, psz_flush_all_dirty_zones);\n\n \nenum psz_flush_mode {\n\tFLUSH_NONE = 0,\n\tFLUSH_PART,\n\tFLUSH_META,\n\tFLUSH_ALL,\n};\n\nstatic inline int buffer_datalen(struct pstore_zone *zone)\n{\n\treturn atomic_read(&zone->buffer->datalen);\n}\n\nstatic inline int buffer_start(struct pstore_zone *zone)\n{\n\treturn atomic_read(&zone->buffer->start);\n}\n\nstatic inline bool is_on_panic(void)\n{\n\treturn atomic_read(&pstore_zone_cxt.on_panic);\n}\n\nstatic ssize_t psz_zone_read_buffer(struct pstore_zone *zone, char *buf,\n\t\tsize_t len, unsigned long off)\n{\n\tif (!buf || !zone || !zone->buffer)\n\t\treturn -EINVAL;\n\tif (off > zone->buffer_size)\n\t\treturn -EINVAL;\n\tlen = min_t(size_t, len, zone->buffer_size - off);\n\tmemcpy(buf, zone->buffer->data + off, len);\n\treturn len;\n}\n\nstatic int psz_zone_read_oldbuf(struct pstore_zone *zone, char *buf,\n\t\tsize_t len, unsigned long off)\n{\n\tif (!buf || !zone || !zone->oldbuf)\n\t\treturn -EINVAL;\n\tif (off > zone->buffer_size)\n\t\treturn -EINVAL;\n\tlen = min_t(size_t, len, zone->buffer_size - off);\n\tmemcpy(buf, zone->oldbuf->data + off, len);\n\treturn 0;\n}\n\nstatic int psz_zone_write(struct pstore_zone *zone,\n\t\tenum psz_flush_mode flush_mode, const char *buf,\n\t\tsize_t len, unsigned long off)\n{\n\tstruct pstore_zone_info *info = pstore_zone_cxt.pstore_zone_info;\n\tssize_t wcnt = 0;\n\tssize_t (*writeop)(const char *buf, size_t bytes, loff_t pos);\n\tsize_t wlen;\n\n\tif (off > zone->buffer_size)\n\t\treturn -EINVAL;\n\n\twlen = min_t(size_t, len, zone->buffer_size - off);\n\tif (buf && wlen) {\n\t\tmemcpy(zone->buffer->data + off, buf, wlen);\n\t\tatomic_set(&zone->buffer->datalen, wlen + off);\n\t}\n\n\t \n\tif (!is_on_panic() && !atomic_read(&pstore_zone_cxt.recovered))\n\t\tgoto dirty;\n\n\twriteop = is_on_panic() ? info->panic_write : info->write;\n\tif (!writeop)\n\t\tgoto dirty;\n\n\tswitch (flush_mode) {\n\tcase FLUSH_NONE:\n\t\tif (unlikely(buf && wlen))\n\t\t\tgoto dirty;\n\t\treturn 0;\n\tcase FLUSH_PART:\n\t\twcnt = writeop((const char *)zone->buffer->data + off, wlen,\n\t\t\t\tzone->off + sizeof(*zone->buffer) + off);\n\t\tif (wcnt != wlen)\n\t\t\tgoto dirty;\n\t\tfallthrough;\n\tcase FLUSH_META:\n\t\twlen = sizeof(struct psz_buffer);\n\t\twcnt = writeop((const char *)zone->buffer, wlen, zone->off);\n\t\tif (wcnt != wlen)\n\t\t\tgoto dirty;\n\t\tbreak;\n\tcase FLUSH_ALL:\n\t\twlen = zone->buffer_size + sizeof(*zone->buffer);\n\t\twcnt = writeop((const char *)zone->buffer, wlen, zone->off);\n\t\tif (wcnt != wlen)\n\t\t\tgoto dirty;\n\t\tbreak;\n\t}\n\n\treturn 0;\ndirty:\n\t \n\tif (wcnt == -ENOMSG)\n\t\treturn -ENOMSG;\n\tatomic_set(&zone->dirty, true);\n\t \n\tif (wcnt == -EBUSY && !is_on_panic())\n\t\tschedule_delayed_work(&psz_cleaner, msecs_to_jiffies(500));\n\treturn -EBUSY;\n}\n\nstatic int psz_flush_dirty_zone(struct pstore_zone *zone)\n{\n\tint ret;\n\n\tif (unlikely(!zone))\n\t\treturn -EINVAL;\n\n\tif (unlikely(!atomic_read(&pstore_zone_cxt.recovered)))\n\t\treturn -EBUSY;\n\n\tif (!atomic_xchg(&zone->dirty, false))\n\t\treturn 0;\n\n\tret = psz_zone_write(zone, FLUSH_ALL, NULL, 0, 0);\n\tif (ret)\n\t\tatomic_set(&zone->dirty, true);\n\treturn ret;\n}\n\nstatic int psz_flush_dirty_zones(struct pstore_zone **zones, unsigned int cnt)\n{\n\tint i, ret;\n\tstruct pstore_zone *zone;\n\n\tif (!zones)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < cnt; i++) {\n\t\tzone = zones[i];\n\t\tif (!zone)\n\t\t\treturn -EINVAL;\n\t\tret = psz_flush_dirty_zone(zone);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int psz_move_zone(struct pstore_zone *old, struct pstore_zone *new)\n{\n\tconst char *data = (const char *)old->buffer->data;\n\tint ret;\n\n\tret = psz_zone_write(new, FLUSH_ALL, data, buffer_datalen(old), 0);\n\tif (ret) {\n\t\tatomic_set(&new->buffer->datalen, 0);\n\t\tatomic_set(&new->dirty, false);\n\t\treturn ret;\n\t}\n\tatomic_set(&old->buffer->datalen, 0);\n\treturn 0;\n}\n\nstatic void psz_flush_all_dirty_zones(struct work_struct *work)\n{\n\tstruct psz_context *cxt = &pstore_zone_cxt;\n\tint ret = 0;\n\n\tif (cxt->ppsz)\n\t\tret |= psz_flush_dirty_zone(cxt->ppsz);\n\tif (cxt->cpsz)\n\t\tret |= psz_flush_dirty_zone(cxt->cpsz);\n\tif (cxt->kpszs)\n\t\tret |= psz_flush_dirty_zones(cxt->kpszs, cxt->kmsg_max_cnt);\n\tif (cxt->fpszs)\n\t\tret |= psz_flush_dirty_zones(cxt->fpszs, cxt->ftrace_max_cnt);\n\tif (ret && cxt->pstore_zone_info)\n\t\tschedule_delayed_work(&psz_cleaner, msecs_to_jiffies(1000));\n}\n\nstatic int psz_kmsg_recover_data(struct psz_context *cxt)\n{\n\tstruct pstore_zone_info *info = cxt->pstore_zone_info;\n\tstruct pstore_zone *zone = NULL;\n\tstruct psz_buffer *buf;\n\tunsigned long i;\n\tssize_t rcnt;\n\n\tif (!info->read)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < cxt->kmsg_max_cnt; i++) {\n\t\tzone = cxt->kpszs[i];\n\t\tif (unlikely(!zone))\n\t\t\treturn -EINVAL;\n\t\tif (atomic_read(&zone->dirty)) {\n\t\t\tunsigned int wcnt = cxt->kmsg_write_cnt;\n\t\t\tstruct pstore_zone *new = cxt->kpszs[wcnt];\n\t\t\tint ret;\n\n\t\t\tret = psz_move_zone(zone, new);\n\t\t\tif (ret) {\n\t\t\t\tpr_err(\"move zone from %lu to %d failed\\n\",\n\t\t\t\t\t\ti, wcnt);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tcxt->kmsg_write_cnt = (wcnt + 1) % cxt->kmsg_max_cnt;\n\t\t}\n\t\tif (!zone->should_recover)\n\t\t\tcontinue;\n\t\tbuf = zone->buffer;\n\t\trcnt = info->read((char *)buf, zone->buffer_size + sizeof(*buf),\n\t\t\t\tzone->off);\n\t\tif (rcnt != zone->buffer_size + sizeof(*buf))\n\t\t\treturn rcnt < 0 ? rcnt : -EIO;\n\t}\n\treturn 0;\n}\n\nstatic int psz_kmsg_recover_meta(struct psz_context *cxt)\n{\n\tstruct pstore_zone_info *info = cxt->pstore_zone_info;\n\tstruct pstore_zone *zone;\n\tssize_t rcnt, len;\n\tstruct psz_buffer *buf;\n\tstruct psz_kmsg_header *hdr;\n\tstruct timespec64 time = { };\n\tunsigned long i;\n\t \n\tchar buffer_header[sizeof(*buf) + sizeof(*hdr)] = {0};\n\n\tif (!info->read)\n\t\treturn -EINVAL;\n\n\tlen = sizeof(*buf) + sizeof(*hdr);\n\tbuf = (struct psz_buffer *)buffer_header;\n\tfor (i = 0; i < cxt->kmsg_max_cnt; i++) {\n\t\tzone = cxt->kpszs[i];\n\t\tif (unlikely(!zone))\n\t\t\treturn -EINVAL;\n\n\t\trcnt = info->read((char *)buf, len, zone->off);\n\t\tif (rcnt == -ENOMSG) {\n\t\t\tpr_debug(\"%s with id %lu may be broken, skip\\n\",\n\t\t\t\t\tzone->name, i);\n\t\t\tcontinue;\n\t\t} else if (rcnt != len) {\n\t\t\tpr_err(\"read %s with id %lu failed\\n\", zone->name, i);\n\t\t\treturn rcnt < 0 ? rcnt : -EIO;\n\t\t}\n\n\t\tif (buf->sig != zone->buffer->sig) {\n\t\t\tpr_debug(\"no valid data in kmsg dump zone %lu\\n\", i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (zone->buffer_size < atomic_read(&buf->datalen)) {\n\t\t\tpr_info(\"found overtop zone: %s: id %lu, off %lld, size %zu\\n\",\n\t\t\t\t\tzone->name, i, zone->off,\n\t\t\t\t\tzone->buffer_size);\n\t\t\tcontinue;\n\t\t}\n\n\t\thdr = (struct psz_kmsg_header *)buf->data;\n\t\tif (hdr->magic != PSTORE_KMSG_HEADER_MAGIC) {\n\t\t\tpr_info(\"found invalid zone: %s: id %lu, off %lld, size %zu\\n\",\n\t\t\t\t\tzone->name, i, zone->off,\n\t\t\t\t\tzone->buffer_size);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (hdr->time.tv_sec >= time.tv_sec) {\n\t\t\ttime.tv_sec = hdr->time.tv_sec;\n\t\t\tcxt->kmsg_write_cnt = (i + 1) % cxt->kmsg_max_cnt;\n\t\t}\n\n\t\tif (hdr->reason == KMSG_DUMP_OOPS)\n\t\t\tcxt->oops_counter =\n\t\t\t\tmax(cxt->oops_counter, hdr->counter);\n\t\telse if (hdr->reason == KMSG_DUMP_PANIC)\n\t\t\tcxt->panic_counter =\n\t\t\t\tmax(cxt->panic_counter, hdr->counter);\n\n\t\tif (!atomic_read(&buf->datalen)) {\n\t\t\tpr_debug(\"found erased zone: %s: id %lu, off %lld, size %zu, datalen %d\\n\",\n\t\t\t\t\tzone->name, i, zone->off,\n\t\t\t\t\tzone->buffer_size,\n\t\t\t\t\tatomic_read(&buf->datalen));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!is_on_panic())\n\t\t\tzone->should_recover = true;\n\t\tpr_debug(\"found nice zone: %s: id %lu, off %lld, size %zu, datalen %d\\n\",\n\t\t\t\tzone->name, i, zone->off,\n\t\t\t\tzone->buffer_size, atomic_read(&buf->datalen));\n\t}\n\n\treturn 0;\n}\n\nstatic int psz_kmsg_recover(struct psz_context *cxt)\n{\n\tint ret;\n\n\tif (!cxt->kpszs)\n\t\treturn 0;\n\n\tret = psz_kmsg_recover_meta(cxt);\n\tif (ret)\n\t\tgoto recover_fail;\n\n\tret = psz_kmsg_recover_data(cxt);\n\tif (ret)\n\t\tgoto recover_fail;\n\n\treturn 0;\nrecover_fail:\n\tpr_debug(\"psz_recover_kmsg failed\\n\");\n\treturn ret;\n}\n\nstatic int psz_recover_zone(struct psz_context *cxt, struct pstore_zone *zone)\n{\n\tstruct pstore_zone_info *info = cxt->pstore_zone_info;\n\tstruct psz_buffer *oldbuf, tmpbuf;\n\tint ret = 0;\n\tchar *buf;\n\tssize_t rcnt, len, start, off;\n\n\tif (!zone || zone->oldbuf)\n\t\treturn 0;\n\n\tif (is_on_panic()) {\n\t\t \n\t\tpsz_flush_dirty_zone(zone);\n\t\treturn 0;\n\t}\n\n\tif (unlikely(!info->read))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(struct psz_buffer);\n\trcnt = info->read((char *)&tmpbuf, len, zone->off);\n\tif (rcnt != len) {\n\t\tpr_debug(\"read zone %s failed\\n\", zone->name);\n\t\treturn rcnt < 0 ? rcnt : -EIO;\n\t}\n\n\tif (tmpbuf.sig != zone->buffer->sig) {\n\t\tpr_debug(\"no valid data in zone %s\\n\", zone->name);\n\t\treturn 0;\n\t}\n\n\tif (zone->buffer_size < atomic_read(&tmpbuf.datalen) ||\n\t\tzone->buffer_size < atomic_read(&tmpbuf.start)) {\n\t\tpr_info(\"found overtop zone: %s: off %lld, size %zu\\n\",\n\t\t\t\tzone->name, zone->off, zone->buffer_size);\n\t\t \n\t\treturn 0;\n\t}\n\n\tif (!atomic_read(&tmpbuf.datalen)) {\n\t\tpr_debug(\"found erased zone: %s: off %lld, size %zu, datalen %d\\n\",\n\t\t\t\tzone->name, zone->off, zone->buffer_size,\n\t\t\t\tatomic_read(&tmpbuf.datalen));\n\t\treturn 0;\n\t}\n\n\tpr_debug(\"found nice zone: %s: off %lld, size %zu, datalen %d\\n\",\n\t\t\tzone->name, zone->off, zone->buffer_size,\n\t\t\tatomic_read(&tmpbuf.datalen));\n\n\tlen = atomic_read(&tmpbuf.datalen) + sizeof(*oldbuf);\n\toldbuf = kzalloc(len, GFP_KERNEL);\n\tif (!oldbuf)\n\t\treturn -ENOMEM;\n\n\tmemcpy(oldbuf, &tmpbuf, sizeof(*oldbuf));\n\tbuf = (char *)oldbuf + sizeof(*oldbuf);\n\tlen = atomic_read(&oldbuf->datalen);\n\tstart = atomic_read(&oldbuf->start);\n\toff = zone->off + sizeof(*oldbuf);\n\n\t \n\trcnt = info->read(buf, len - start, off + start);\n\tif (rcnt != len - start) {\n\t\tpr_err(\"read zone %s failed\\n\", zone->name);\n\t\tret = rcnt < 0 ? rcnt : -EIO;\n\t\tgoto free_oldbuf;\n\t}\n\n\t \n\trcnt = info->read(buf + len - start, start, off);\n\tif (rcnt != start) {\n\t\tpr_err(\"read zone %s failed\\n\", zone->name);\n\t\tret = rcnt < 0 ? rcnt : -EIO;\n\t\tgoto free_oldbuf;\n\t}\n\n\tzone->oldbuf = oldbuf;\n\tpsz_flush_dirty_zone(zone);\n\treturn 0;\n\nfree_oldbuf:\n\tkfree(oldbuf);\n\treturn ret;\n}\n\nstatic int psz_recover_zones(struct psz_context *cxt,\n\t\tstruct pstore_zone **zones, unsigned int cnt)\n{\n\tint ret;\n\tunsigned int i;\n\tstruct pstore_zone *zone;\n\n\tif (!zones)\n\t\treturn 0;\n\n\tfor (i = 0; i < cnt; i++) {\n\t\tzone = zones[i];\n\t\tif (unlikely(!zone))\n\t\t\tcontinue;\n\t\tret = psz_recover_zone(cxt, zone);\n\t\tif (ret)\n\t\t\tgoto recover_fail;\n\t}\n\n\treturn 0;\nrecover_fail:\n\tpr_debug(\"recover %s[%u] failed\\n\", zone->name, i);\n\treturn ret;\n}\n\n \nstatic inline int psz_recovery(struct psz_context *cxt)\n{\n\tint ret;\n\n\tif (atomic_read(&cxt->recovered))\n\t\treturn 0;\n\n\tret = psz_kmsg_recover(cxt);\n\tif (ret)\n\t\tgoto out;\n\n\tret = psz_recover_zone(cxt, cxt->ppsz);\n\tif (ret)\n\t\tgoto out;\n\n\tret = psz_recover_zone(cxt, cxt->cpsz);\n\tif (ret)\n\t\tgoto out;\n\n\tret = psz_recover_zones(cxt, cxt->fpszs, cxt->ftrace_max_cnt);\n\nout:\n\tif (unlikely(ret))\n\t\tpr_err(\"recover failed\\n\");\n\telse {\n\t\tpr_debug(\"recover end!\\n\");\n\t\tatomic_set(&cxt->recovered, 1);\n\t}\n\treturn ret;\n}\n\nstatic int psz_pstore_open(struct pstore_info *psi)\n{\n\tstruct psz_context *cxt = psi->data;\n\n\tcxt->kmsg_read_cnt = 0;\n\tcxt->pmsg_read_cnt = 0;\n\tcxt->console_read_cnt = 0;\n\tcxt->ftrace_read_cnt = 0;\n\treturn 0;\n}\n\nstatic inline bool psz_old_ok(struct pstore_zone *zone)\n{\n\tif (zone && zone->oldbuf && atomic_read(&zone->oldbuf->datalen))\n\t\treturn true;\n\treturn false;\n}\n\nstatic inline bool psz_ok(struct pstore_zone *zone)\n{\n\tif (zone && zone->buffer && buffer_datalen(zone))\n\t\treturn true;\n\treturn false;\n}\n\nstatic inline int psz_kmsg_erase(struct psz_context *cxt,\n\t\tstruct pstore_zone *zone, struct pstore_record *record)\n{\n\tstruct psz_buffer *buffer = zone->buffer;\n\tstruct psz_kmsg_header *hdr =\n\t\t(struct psz_kmsg_header *)buffer->data;\n\tsize_t size;\n\n\tif (unlikely(!psz_ok(zone)))\n\t\treturn 0;\n\n\t \n\tif (record->count != hdr->counter)\n\t\treturn 0;\n\n\tsize = buffer_datalen(zone) + sizeof(*zone->buffer);\n\tatomic_set(&zone->buffer->datalen, 0);\n\tif (cxt->pstore_zone_info->erase)\n\t\treturn cxt->pstore_zone_info->erase(size, zone->off);\n\telse\n\t\treturn psz_zone_write(zone, FLUSH_META, NULL, 0, 0);\n}\n\nstatic inline int psz_record_erase(struct psz_context *cxt,\n\t\tstruct pstore_zone *zone)\n{\n\tif (unlikely(!psz_old_ok(zone)))\n\t\treturn 0;\n\n\tkfree(zone->oldbuf);\n\tzone->oldbuf = NULL;\n\t \n\tif (!buffer_datalen(zone))\n\t\treturn psz_zone_write(zone, FLUSH_META, NULL, 0, 0);\n\tpsz_flush_dirty_zone(zone);\n\treturn 0;\n}\n\nstatic int psz_pstore_erase(struct pstore_record *record)\n{\n\tstruct psz_context *cxt = record->psi->data;\n\n\tswitch (record->type) {\n\tcase PSTORE_TYPE_DMESG:\n\t\tif (record->id >= cxt->kmsg_max_cnt)\n\t\t\treturn -EINVAL;\n\t\treturn psz_kmsg_erase(cxt, cxt->kpszs[record->id], record);\n\tcase PSTORE_TYPE_PMSG:\n\t\treturn psz_record_erase(cxt, cxt->ppsz);\n\tcase PSTORE_TYPE_CONSOLE:\n\t\treturn psz_record_erase(cxt, cxt->cpsz);\n\tcase PSTORE_TYPE_FTRACE:\n\t\tif (record->id >= cxt->ftrace_max_cnt)\n\t\t\treturn -EINVAL;\n\t\treturn psz_record_erase(cxt, cxt->fpszs[record->id]);\n\tdefault: return -EINVAL;\n\t}\n}\n\nstatic void psz_write_kmsg_hdr(struct pstore_zone *zone,\n\t\tstruct pstore_record *record)\n{\n\tstruct psz_context *cxt = record->psi->data;\n\tstruct psz_buffer *buffer = zone->buffer;\n\tstruct psz_kmsg_header *hdr =\n\t\t(struct psz_kmsg_header *)buffer->data;\n\n\thdr->magic = PSTORE_KMSG_HEADER_MAGIC;\n\thdr->compressed = record->compressed;\n\thdr->time.tv_sec = record->time.tv_sec;\n\thdr->time.tv_nsec = record->time.tv_nsec;\n\thdr->reason = record->reason;\n\tif (hdr->reason == KMSG_DUMP_OOPS)\n\t\thdr->counter = ++cxt->oops_counter;\n\telse if (hdr->reason == KMSG_DUMP_PANIC)\n\t\thdr->counter = ++cxt->panic_counter;\n\telse\n\t\thdr->counter = 0;\n}\n\n \nstatic inline int notrace psz_kmsg_write_record(struct psz_context *cxt,\n\t\tstruct pstore_record *record)\n{\n\tsize_t size, hlen;\n\tstruct pstore_zone *zone;\n\tunsigned int i;\n\n\tfor (i = 0; i < cxt->kmsg_max_cnt; i++) {\n\t\tunsigned int zonenum, len;\n\t\tint ret;\n\n\t\tzonenum = (cxt->kmsg_write_cnt + i) % cxt->kmsg_max_cnt;\n\t\tzone = cxt->kpszs[zonenum];\n\t\tif (unlikely(!zone))\n\t\t\treturn -ENOSPC;\n\n\t\t \n\t\tlen = zone->buffer_size + sizeof(*zone->buffer);\n\t\tzone->oldbuf = zone->buffer;\n\t\tzone->buffer = kzalloc(len, GFP_ATOMIC);\n\t\tif (!zone->buffer) {\n\t\t\tzone->buffer = zone->oldbuf;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tzone->buffer->sig = zone->oldbuf->sig;\n\n\t\tpr_debug(\"write %s to zone id %d\\n\", zone->name, zonenum);\n\t\tpsz_write_kmsg_hdr(zone, record);\n\t\thlen = sizeof(struct psz_kmsg_header);\n\t\tsize = min_t(size_t, record->size, zone->buffer_size - hlen);\n\t\tret = psz_zone_write(zone, FLUSH_ALL, record->buf, size, hlen);\n\t\tif (likely(!ret || ret != -ENOMSG)) {\n\t\t\tcxt->kmsg_write_cnt = zonenum + 1;\n\t\t\tcxt->kmsg_write_cnt %= cxt->kmsg_max_cnt;\n\t\t\t \n\t\t\tkfree(zone->oldbuf);\n\t\t\tzone->oldbuf = NULL;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpr_debug(\"zone %u may be broken, try next dmesg zone\\n\",\n\t\t\t\tzonenum);\n\t\tkfree(zone->buffer);\n\t\tzone->buffer = zone->oldbuf;\n\t\tzone->oldbuf = NULL;\n\t}\n\n\treturn -EBUSY;\n}\n\nstatic int notrace psz_kmsg_write(struct psz_context *cxt,\n\t\tstruct pstore_record *record)\n{\n\tint ret;\n\n\t \n\tif (record->part != 1)\n\t\treturn -ENOSPC;\n\n\tif (!cxt->kpszs)\n\t\treturn -ENOSPC;\n\n\tret = psz_kmsg_write_record(cxt, record);\n\tif (!ret && is_on_panic()) {\n\t\t \n\t\tpr_debug(\"try to flush other dirty zones\\n\");\n\t\tpsz_flush_all_dirty_zones(NULL);\n\t}\n\n\t \n\treturn 0;\n}\n\nstatic int notrace psz_record_write(struct pstore_zone *zone,\n\t\tstruct pstore_record *record)\n{\n\tsize_t start, rem;\n\tbool is_full_data = false;\n\tchar *buf;\n\tint cnt;\n\n\tif (!zone || !record)\n\t\treturn -ENOSPC;\n\n\tif (atomic_read(&zone->buffer->datalen) >= zone->buffer_size)\n\t\tis_full_data = true;\n\n\tcnt = record->size;\n\tbuf = record->buf;\n\tif (unlikely(cnt > zone->buffer_size)) {\n\t\tbuf += cnt - zone->buffer_size;\n\t\tcnt = zone->buffer_size;\n\t}\n\n\tstart = buffer_start(zone);\n\trem = zone->buffer_size - start;\n\tif (unlikely(rem < cnt)) {\n\t\tpsz_zone_write(zone, FLUSH_PART, buf, rem, start);\n\t\tbuf += rem;\n\t\tcnt -= rem;\n\t\tstart = 0;\n\t\tis_full_data = true;\n\t}\n\n\tatomic_set(&zone->buffer->start, cnt + start);\n\tpsz_zone_write(zone, FLUSH_PART, buf, cnt, start);\n\n\t \n\tif (is_full_data) {\n\t\tatomic_set(&zone->buffer->datalen, zone->buffer_size);\n\t\tpsz_zone_write(zone, FLUSH_META, NULL, 0, 0);\n\t}\n\treturn 0;\n}\n\nstatic int notrace psz_pstore_write(struct pstore_record *record)\n{\n\tstruct psz_context *cxt = record->psi->data;\n\n\tif (record->type == PSTORE_TYPE_DMESG &&\n\t\t\trecord->reason == KMSG_DUMP_PANIC)\n\t\tatomic_set(&cxt->on_panic, 1);\n\n\t \n\tif (is_on_panic() && record->type != PSTORE_TYPE_DMESG)\n\t\treturn -EBUSY;\n\n\tswitch (record->type) {\n\tcase PSTORE_TYPE_DMESG:\n\t\treturn psz_kmsg_write(cxt, record);\n\tcase PSTORE_TYPE_CONSOLE:\n\t\treturn psz_record_write(cxt->cpsz, record);\n\tcase PSTORE_TYPE_PMSG:\n\t\treturn psz_record_write(cxt->ppsz, record);\n\tcase PSTORE_TYPE_FTRACE: {\n\t\tint zonenum = smp_processor_id();\n\n\t\tif (!cxt->fpszs)\n\t\t\treturn -ENOSPC;\n\t\treturn psz_record_write(cxt->fpszs[zonenum], record);\n\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic struct pstore_zone *psz_read_next_zone(struct psz_context *cxt)\n{\n\tstruct pstore_zone *zone = NULL;\n\n\twhile (cxt->kmsg_read_cnt < cxt->kmsg_max_cnt) {\n\t\tzone = cxt->kpszs[cxt->kmsg_read_cnt++];\n\t\tif (psz_ok(zone))\n\t\t\treturn zone;\n\t}\n\n\tif (cxt->ftrace_read_cnt < cxt->ftrace_max_cnt)\n\t\t \n\t\treturn cxt->fpszs[cxt->ftrace_read_cnt++];\n\n\tif (cxt->pmsg_read_cnt == 0) {\n\t\tcxt->pmsg_read_cnt++;\n\t\tzone = cxt->ppsz;\n\t\tif (psz_old_ok(zone))\n\t\t\treturn zone;\n\t}\n\n\tif (cxt->console_read_cnt == 0) {\n\t\tcxt->console_read_cnt++;\n\t\tzone = cxt->cpsz;\n\t\tif (psz_old_ok(zone))\n\t\t\treturn zone;\n\t}\n\n\treturn NULL;\n}\n\nstatic int psz_kmsg_read_hdr(struct pstore_zone *zone,\n\t\tstruct pstore_record *record)\n{\n\tstruct psz_buffer *buffer = zone->buffer;\n\tstruct psz_kmsg_header *hdr =\n\t\t(struct psz_kmsg_header *)buffer->data;\n\n\tif (hdr->magic != PSTORE_KMSG_HEADER_MAGIC)\n\t\treturn -EINVAL;\n\trecord->compressed = hdr->compressed;\n\trecord->time.tv_sec = hdr->time.tv_sec;\n\trecord->time.tv_nsec = hdr->time.tv_nsec;\n\trecord->reason = hdr->reason;\n\trecord->count = hdr->counter;\n\treturn 0;\n}\n\nstatic ssize_t psz_kmsg_read(struct pstore_zone *zone,\n\t\tstruct pstore_record *record)\n{\n\tssize_t size, hlen = 0;\n\n\tsize = buffer_datalen(zone);\n\t \n\tif (psz_kmsg_read_hdr(zone, record)) {\n\t\tatomic_set(&zone->buffer->datalen, 0);\n\t\tatomic_set(&zone->dirty, 0);\n\t\treturn -ENOMSG;\n\t}\n\tsize -= sizeof(struct psz_kmsg_header);\n\n\tif (!record->compressed) {\n\t\tchar *buf = kasprintf(GFP_KERNEL, \"%s: Total %d times\\n\",\n\t\t\t\t      kmsg_dump_reason_str(record->reason),\n\t\t\t\t      record->count);\n\t\thlen = strlen(buf);\n\t\trecord->buf = krealloc(buf, hlen + size, GFP_KERNEL);\n\t\tif (!record->buf) {\n\t\t\tkfree(buf);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t} else {\n\t\trecord->buf = kmalloc(size, GFP_KERNEL);\n\t\tif (!record->buf)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tsize = psz_zone_read_buffer(zone, record->buf + hlen, size,\n\t\t\tsizeof(struct psz_kmsg_header));\n\tif (unlikely(size < 0)) {\n\t\tkfree(record->buf);\n\t\treturn -ENOMSG;\n\t}\n\n\treturn size + hlen;\n}\n\n \nstatic ssize_t psz_ftrace_read(struct pstore_zone *zone,\n\t\tstruct pstore_record *record)\n{\n\tstruct psz_context *cxt;\n\tstruct psz_buffer *buf;\n\tint ret;\n\n\tif (!zone || !record)\n\t\treturn -ENOSPC;\n\n\tif (!psz_old_ok(zone))\n\t\tgoto out;\n\n\tbuf = (struct psz_buffer *)zone->oldbuf;\n\tif (!buf)\n\t\treturn -ENOMSG;\n\n\tret = pstore_ftrace_combine_log(&record->buf, &record->size,\n\t\t\t(char *)buf->data, atomic_read(&buf->datalen));\n\tif (unlikely(ret))\n\t\treturn ret;\n\nout:\n\tcxt = record->psi->data;\n\tif (cxt->ftrace_read_cnt < cxt->ftrace_max_cnt)\n\t\t \n\t\treturn -ENOMSG;\n\trecord->id = 0;\n\treturn record->size ? record->size : -ENOMSG;\n}\n\nstatic ssize_t psz_record_read(struct pstore_zone *zone,\n\t\tstruct pstore_record *record)\n{\n\tsize_t len;\n\tstruct psz_buffer *buf;\n\n\tif (!zone || !record)\n\t\treturn -ENOSPC;\n\n\tbuf = (struct psz_buffer *)zone->oldbuf;\n\tif (!buf)\n\t\treturn -ENOMSG;\n\n\tlen = atomic_read(&buf->datalen);\n\trecord->buf = kmalloc(len, GFP_KERNEL);\n\tif (!record->buf)\n\t\treturn -ENOMEM;\n\n\tif (unlikely(psz_zone_read_oldbuf(zone, record->buf, len, 0))) {\n\t\tkfree(record->buf);\n\t\treturn -ENOMSG;\n\t}\n\n\treturn len;\n}\n\nstatic ssize_t psz_pstore_read(struct pstore_record *record)\n{\n\tstruct psz_context *cxt = record->psi->data;\n\tssize_t (*readop)(struct pstore_zone *zone,\n\t\t\tstruct pstore_record *record);\n\tstruct pstore_zone *zone;\n\tssize_t ret;\n\n\t \n\tret = psz_recovery(cxt);\n\tif (ret)\n\t\treturn ret;\n\nnext_zone:\n\tzone = psz_read_next_zone(cxt);\n\tif (!zone)\n\t\treturn 0;\n\n\trecord->type = zone->type;\n\tswitch (record->type) {\n\tcase PSTORE_TYPE_DMESG:\n\t\treadop = psz_kmsg_read;\n\t\trecord->id = cxt->kmsg_read_cnt - 1;\n\t\tbreak;\n\tcase PSTORE_TYPE_FTRACE:\n\t\treadop = psz_ftrace_read;\n\t\tbreak;\n\tcase PSTORE_TYPE_CONSOLE:\n\tcase PSTORE_TYPE_PMSG:\n\t\treadop = psz_record_read;\n\t\tbreak;\n\tdefault:\n\t\tgoto next_zone;\n\t}\n\n\tret = readop(zone, record);\n\tif (ret == -ENOMSG)\n\t\tgoto next_zone;\n\treturn ret;\n}\n\nstatic struct psz_context pstore_zone_cxt = {\n\t.pstore_zone_info_lock =\n\t\t__MUTEX_INITIALIZER(pstore_zone_cxt.pstore_zone_info_lock),\n\t.recovered = ATOMIC_INIT(0),\n\t.on_panic = ATOMIC_INIT(0),\n\t.pstore = {\n\t\t.owner = THIS_MODULE,\n\t\t.open = psz_pstore_open,\n\t\t.read = psz_pstore_read,\n\t\t.write = psz_pstore_write,\n\t\t.erase = psz_pstore_erase,\n\t},\n};\n\nstatic void psz_free_zone(struct pstore_zone **pszone)\n{\n\tstruct pstore_zone *zone = *pszone;\n\n\tif (!zone)\n\t\treturn;\n\n\tkfree(zone->buffer);\n\tkfree(zone);\n\t*pszone = NULL;\n}\n\nstatic void psz_free_zones(struct pstore_zone ***pszones, unsigned int *cnt)\n{\n\tstruct pstore_zone **zones = *pszones;\n\n\tif (!zones)\n\t\treturn;\n\n\twhile (*cnt > 0) {\n\t\t(*cnt)--;\n\t\tpsz_free_zone(&(zones[*cnt]));\n\t}\n\tkfree(zones);\n\t*pszones = NULL;\n}\n\nstatic void psz_free_all_zones(struct psz_context *cxt)\n{\n\tif (cxt->kpszs)\n\t\tpsz_free_zones(&cxt->kpszs, &cxt->kmsg_max_cnt);\n\tif (cxt->ppsz)\n\t\tpsz_free_zone(&cxt->ppsz);\n\tif (cxt->cpsz)\n\t\tpsz_free_zone(&cxt->cpsz);\n\tif (cxt->fpszs)\n\t\tpsz_free_zones(&cxt->fpszs, &cxt->ftrace_max_cnt);\n}\n\nstatic struct pstore_zone *psz_init_zone(enum pstore_type_id type,\n\t\tloff_t *off, size_t size)\n{\n\tstruct pstore_zone_info *info = pstore_zone_cxt.pstore_zone_info;\n\tstruct pstore_zone *zone;\n\tconst char *name = pstore_type_to_name(type);\n\n\tif (!size)\n\t\treturn NULL;\n\n\tif (*off + size > info->total_size) {\n\t\tpr_err(\"no room for %s (0x%zx@0x%llx over 0x%lx)\\n\",\n\t\t\tname, size, *off, info->total_size);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tzone = kzalloc(sizeof(struct pstore_zone), GFP_KERNEL);\n\tif (!zone)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tzone->buffer = kmalloc(size, GFP_KERNEL);\n\tif (!zone->buffer) {\n\t\tkfree(zone);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tmemset(zone->buffer, 0xFF, size);\n\tzone->off = *off;\n\tzone->name = name;\n\tzone->type = type;\n\tzone->buffer_size = size - sizeof(struct psz_buffer);\n\tzone->buffer->sig = type ^ PSZ_SIG;\n\tzone->oldbuf = NULL;\n\tatomic_set(&zone->dirty, 0);\n\tatomic_set(&zone->buffer->datalen, 0);\n\tatomic_set(&zone->buffer->start, 0);\n\n\t*off += size;\n\n\tpr_debug(\"pszone %s: off 0x%llx, %zu header, %zu data\\n\", zone->name,\n\t\t\tzone->off, sizeof(*zone->buffer), zone->buffer_size);\n\treturn zone;\n}\n\nstatic struct pstore_zone **psz_init_zones(enum pstore_type_id type,\n\tloff_t *off, size_t total_size, ssize_t record_size,\n\tunsigned int *cnt)\n{\n\tstruct pstore_zone_info *info = pstore_zone_cxt.pstore_zone_info;\n\tstruct pstore_zone **zones, *zone;\n\tconst char *name = pstore_type_to_name(type);\n\tint c, i;\n\n\t*cnt = 0;\n\tif (!total_size || !record_size)\n\t\treturn NULL;\n\n\tif (*off + total_size > info->total_size) {\n\t\tpr_err(\"no room for zones %s (0x%zx@0x%llx over 0x%lx)\\n\",\n\t\t\tname, total_size, *off, info->total_size);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tc = total_size / record_size;\n\tzones = kcalloc(c, sizeof(*zones), GFP_KERNEL);\n\tif (!zones) {\n\t\tpr_err(\"allocate for zones %s failed\\n\", name);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tmemset(zones, 0, c * sizeof(*zones));\n\n\tfor (i = 0; i < c; i++) {\n\t\tzone = psz_init_zone(type, off, record_size);\n\t\tif (!zone || IS_ERR(zone)) {\n\t\t\tpr_err(\"initialize zones %s failed\\n\", name);\n\t\t\tpsz_free_zones(&zones, &i);\n\t\t\treturn (void *)zone;\n\t\t}\n\t\tzones[i] = zone;\n\t}\n\n\t*cnt = c;\n\treturn zones;\n}\n\nstatic int psz_alloc_zones(struct psz_context *cxt)\n{\n\tstruct pstore_zone_info *info = cxt->pstore_zone_info;\n\tloff_t off = 0;\n\tint err;\n\tsize_t off_size = 0;\n\n\toff_size += info->pmsg_size;\n\tcxt->ppsz = psz_init_zone(PSTORE_TYPE_PMSG, &off, info->pmsg_size);\n\tif (IS_ERR(cxt->ppsz)) {\n\t\terr = PTR_ERR(cxt->ppsz);\n\t\tcxt->ppsz = NULL;\n\t\tgoto free_out;\n\t}\n\n\toff_size += info->console_size;\n\tcxt->cpsz = psz_init_zone(PSTORE_TYPE_CONSOLE, &off,\n\t\t\tinfo->console_size);\n\tif (IS_ERR(cxt->cpsz)) {\n\t\terr = PTR_ERR(cxt->cpsz);\n\t\tcxt->cpsz = NULL;\n\t\tgoto free_out;\n\t}\n\n\toff_size += info->ftrace_size;\n\tcxt->fpszs = psz_init_zones(PSTORE_TYPE_FTRACE, &off,\n\t\t\tinfo->ftrace_size,\n\t\t\tinfo->ftrace_size / nr_cpu_ids,\n\t\t\t&cxt->ftrace_max_cnt);\n\tif (IS_ERR(cxt->fpszs)) {\n\t\terr = PTR_ERR(cxt->fpszs);\n\t\tcxt->fpszs = NULL;\n\t\tgoto free_out;\n\t}\n\n\tcxt->kpszs = psz_init_zones(PSTORE_TYPE_DMESG, &off,\n\t\t\tinfo->total_size - off_size,\n\t\t\tinfo->kmsg_size, &cxt->kmsg_max_cnt);\n\tif (IS_ERR(cxt->kpszs)) {\n\t\terr = PTR_ERR(cxt->kpszs);\n\t\tcxt->kpszs = NULL;\n\t\tgoto free_out;\n\t}\n\n\treturn 0;\nfree_out:\n\tpsz_free_all_zones(cxt);\n\treturn err;\n}\n\n \nint register_pstore_zone(struct pstore_zone_info *info)\n{\n\tint err = -EINVAL;\n\tstruct psz_context *cxt = &pstore_zone_cxt;\n\n\tif (info->total_size < 4096) {\n\t\tpr_warn(\"total_size must be >= 4096\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (info->total_size > SZ_128M) {\n\t\tpr_warn(\"capping size to 128MiB\\n\");\n\t\tinfo->total_size = SZ_128M;\n\t}\n\n\tif (!info->kmsg_size && !info->pmsg_size && !info->console_size &&\n\t    !info->ftrace_size) {\n\t\tpr_warn(\"at least one record size must be non-zero\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!info->name || !info->name[0])\n\t\treturn -EINVAL;\n\n#define check_size(name, size) {\t\t\t\t\t\\\n\t\tif (info->name > 0 && info->name < (size)) {\t\t\\\n\t\t\tpr_err(#name \" must be over %d\\n\", (size));\t\\\n\t\t\treturn -EINVAL;\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t\tif (info->name & (size - 1)) {\t\t\t\t\\\n\t\t\tpr_err(#name \" must be a multiple of %d\\n\",\t\\\n\t\t\t\t\t(size));\t\t\t\\\n\t\t\treturn -EINVAL;\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t}\n\n\tcheck_size(total_size, 4096);\n\tcheck_size(kmsg_size, SECTOR_SIZE);\n\tcheck_size(pmsg_size, SECTOR_SIZE);\n\tcheck_size(console_size, SECTOR_SIZE);\n\tcheck_size(ftrace_size, SECTOR_SIZE);\n\n#undef check_size\n\n\t \n\tif (!info->read || !info->write) {\n\t\tpr_err(\"no valid general read/write interface\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&cxt->pstore_zone_info_lock);\n\tif (cxt->pstore_zone_info) {\n\t\tpr_warn(\"'%s' already loaded: ignoring '%s'\\n\",\n\t\t\t\tcxt->pstore_zone_info->name, info->name);\n\t\tmutex_unlock(&cxt->pstore_zone_info_lock);\n\t\treturn -EBUSY;\n\t}\n\tcxt->pstore_zone_info = info;\n\n\tpr_debug(\"register %s with properties:\\n\", info->name);\n\tpr_debug(\"\\ttotal size : %ld Bytes\\n\", info->total_size);\n\tpr_debug(\"\\tkmsg size : %ld Bytes\\n\", info->kmsg_size);\n\tpr_debug(\"\\tpmsg size : %ld Bytes\\n\", info->pmsg_size);\n\tpr_debug(\"\\tconsole size : %ld Bytes\\n\", info->console_size);\n\tpr_debug(\"\\tftrace size : %ld Bytes\\n\", info->ftrace_size);\n\n\terr = psz_alloc_zones(cxt);\n\tif (err) {\n\t\tpr_err(\"alloc zones failed\\n\");\n\t\tgoto fail_out;\n\t}\n\n\tif (info->kmsg_size) {\n\t\tcxt->pstore.bufsize = cxt->kpszs[0]->buffer_size -\n\t\t\tsizeof(struct psz_kmsg_header);\n\t\tcxt->pstore.buf = kzalloc(cxt->pstore.bufsize, GFP_KERNEL);\n\t\tif (!cxt->pstore.buf) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto fail_free;\n\t\t}\n\t}\n\tcxt->pstore.data = cxt;\n\n\tpr_info(\"registered %s as backend for\", info->name);\n\tcxt->pstore.max_reason = info->max_reason;\n\tcxt->pstore.name = info->name;\n\tif (info->kmsg_size) {\n\t\tcxt->pstore.flags |= PSTORE_FLAGS_DMESG;\n\t\tpr_cont(\" kmsg(%s\",\n\t\t\tkmsg_dump_reason_str(cxt->pstore.max_reason));\n\t\tif (cxt->pstore_zone_info->panic_write)\n\t\t\tpr_cont(\",panic_write\");\n\t\tpr_cont(\")\");\n\t}\n\tif (info->pmsg_size) {\n\t\tcxt->pstore.flags |= PSTORE_FLAGS_PMSG;\n\t\tpr_cont(\" pmsg\");\n\t}\n\tif (info->console_size) {\n\t\tcxt->pstore.flags |= PSTORE_FLAGS_CONSOLE;\n\t\tpr_cont(\" console\");\n\t}\n\tif (info->ftrace_size) {\n\t\tcxt->pstore.flags |= PSTORE_FLAGS_FTRACE;\n\t\tpr_cont(\" ftrace\");\n\t}\n\tpr_cont(\"\\n\");\n\n\terr = pstore_register(&cxt->pstore);\n\tif (err) {\n\t\tpr_err(\"registering with pstore failed\\n\");\n\t\tgoto fail_free;\n\t}\n\tmutex_unlock(&pstore_zone_cxt.pstore_zone_info_lock);\n\n\treturn 0;\n\nfail_free:\n\tkfree(cxt->pstore.buf);\n\tcxt->pstore.buf = NULL;\n\tcxt->pstore.bufsize = 0;\n\tpsz_free_all_zones(cxt);\nfail_out:\n\tpstore_zone_cxt.pstore_zone_info = NULL;\n\tmutex_unlock(&pstore_zone_cxt.pstore_zone_info_lock);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(register_pstore_zone);\n\n \nvoid unregister_pstore_zone(struct pstore_zone_info *info)\n{\n\tstruct psz_context *cxt = &pstore_zone_cxt;\n\n\tmutex_lock(&cxt->pstore_zone_info_lock);\n\tif (!cxt->pstore_zone_info) {\n\t\tmutex_unlock(&cxt->pstore_zone_info_lock);\n\t\treturn;\n\t}\n\n\t \n\tpstore_unregister(&cxt->pstore);\n\n\t \n\tpsz_flush_all_dirty_zones(NULL);\n\tflush_delayed_work(&psz_cleaner);\n\n\t \n\tkfree(cxt->pstore.buf);\n\tcxt->pstore.buf = NULL;\n\tcxt->pstore.bufsize = 0;\n\tcxt->pstore_zone_info = NULL;\n\n\tpsz_free_all_zones(cxt);\n\n\t \n\tcxt->oops_counter = 0;\n\tcxt->panic_counter = 0;\n\tatomic_set(&cxt->recovered, 0);\n\tatomic_set(&cxt->on_panic, 0);\n\n\tmutex_unlock(&cxt->pstore_zone_info_lock);\n}\nEXPORT_SYMBOL_GPL(unregister_pstore_zone);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"WeiXiong Liao <liaoweixiong@allwinnertech.com>\");\nMODULE_AUTHOR(\"Kees Cook <keescook@chromium.org>\");\nMODULE_DESCRIPTION(\"Storage Manager for pstore/blk\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}