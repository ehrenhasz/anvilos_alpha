{
  "module_name": "blk.c",
  "hash_id": "26db207f714c49c56029554f889c82e455c46d1ccd9b12f6ee56114af0cf66a5",
  "original_prompt": "Ingested from linux-6.6.14/fs/pstore/blk.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/pstore_blk.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init_syscalls.h>\n#include <linux/mount.h>\n\nstatic long kmsg_size = CONFIG_PSTORE_BLK_KMSG_SIZE;\nmodule_param(kmsg_size, long, 0400);\nMODULE_PARM_DESC(kmsg_size, \"kmsg dump record size in kbytes\");\n\nstatic int max_reason = CONFIG_PSTORE_BLK_MAX_REASON;\nmodule_param(max_reason, int, 0400);\nMODULE_PARM_DESC(max_reason,\n\t\t \"maximum reason for kmsg dump (default 2: Oops and Panic)\");\n\n#if IS_ENABLED(CONFIG_PSTORE_PMSG)\nstatic long pmsg_size = CONFIG_PSTORE_BLK_PMSG_SIZE;\n#else\nstatic long pmsg_size = -1;\n#endif\nmodule_param(pmsg_size, long, 0400);\nMODULE_PARM_DESC(pmsg_size, \"pmsg size in kbytes\");\n\n#if IS_ENABLED(CONFIG_PSTORE_CONSOLE)\nstatic long console_size = CONFIG_PSTORE_BLK_CONSOLE_SIZE;\n#else\nstatic long console_size = -1;\n#endif\nmodule_param(console_size, long, 0400);\nMODULE_PARM_DESC(console_size, \"console size in kbytes\");\n\n#if IS_ENABLED(CONFIG_PSTORE_FTRACE)\nstatic long ftrace_size = CONFIG_PSTORE_BLK_FTRACE_SIZE;\n#else\nstatic long ftrace_size = -1;\n#endif\nmodule_param(ftrace_size, long, 0400);\nMODULE_PARM_DESC(ftrace_size, \"ftrace size in kbytes\");\n\nstatic bool best_effort;\nmodule_param(best_effort, bool, 0400);\nMODULE_PARM_DESC(best_effort, \"use best effort to write (i.e. do not require storage driver pstore support, default: off)\");\n\n \nstatic char blkdev[80] = CONFIG_PSTORE_BLK_BLKDEV;\nmodule_param_string(blkdev, blkdev, 80, 0400);\nMODULE_PARM_DESC(blkdev, \"block device for pstore storage\");\n\n \nstatic DEFINE_MUTEX(pstore_blk_lock);\nstatic struct file *psblk_file;\nstatic struct pstore_device_info *pstore_device_info;\n\n#define check_size(name, alignsize) ({\t\t\t\t\\\n\tlong _##name_ = (name);\t\t\t\t\t\\\n\t_##name_ = _##name_ <= 0 ? 0 : (_##name_ * 1024);\t\\\n\tif (_##name_ & ((alignsize) - 1)) {\t\t\t\\\n\t\tpr_info(#name \" must align to %d\\n\",\t\t\\\n\t\t\t\t(alignsize));\t\t\t\\\n\t\t_##name_ = ALIGN(name, (alignsize));\t\t\\\n\t}\t\t\t\t\t\t\t\\\n\t_##name_;\t\t\t\t\t\t\\\n})\n\n#define verify_size(name, alignsize, enabled) {\t\t\t\\\n\tlong _##name_;\t\t\t\t\t\t\\\n\tif (enabled)\t\t\t\t\t\t\\\n\t\t_##name_ = check_size(name, alignsize);\t\t\\\n\telse\t\t\t\t\t\t\t\\\n\t\t_##name_ = 0;\t\t\t\t\t\\\n\t \t\\\n\tname = _##name_ / 1024;\t\t\t\t\t\\\n\tdev->zone.name = _##name_;\t\t\t\t\\\n}\n\nstatic int __register_pstore_device(struct pstore_device_info *dev)\n{\n\tint ret;\n\n\tlockdep_assert_held(&pstore_blk_lock);\n\n\tif (!dev) {\n\t\tpr_err(\"NULL device info\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (!dev->zone.total_size) {\n\t\tpr_err(\"zero sized device\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (!dev->zone.read) {\n\t\tpr_err(\"no read handler for device\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (!dev->zone.write) {\n\t\tpr_err(\"no write handler for device\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (pstore_device_info)\n\t\treturn -EBUSY;\n\n\t \n\tif (!dev->flags)\n\t\tdev->flags = UINT_MAX;\n\n\t \n\tverify_size(kmsg_size, 4096, dev->flags & PSTORE_FLAGS_DMESG);\n\tverify_size(pmsg_size, 4096, dev->flags & PSTORE_FLAGS_PMSG);\n\tverify_size(console_size, 4096, dev->flags & PSTORE_FLAGS_CONSOLE);\n\tverify_size(ftrace_size, 4096, dev->flags & PSTORE_FLAGS_FTRACE);\n\tdev->zone.max_reason = max_reason;\n\n\t \n\tdev->zone.name = KBUILD_MODNAME;\n\tdev->zone.owner = THIS_MODULE;\n\n\tret = register_pstore_zone(&dev->zone);\n\tif (ret == 0)\n\t\tpstore_device_info = dev;\n\n\treturn ret;\n}\n \nint register_pstore_device(struct pstore_device_info *dev)\n{\n\tint ret;\n\n\tmutex_lock(&pstore_blk_lock);\n\tret = __register_pstore_device(dev);\n\tmutex_unlock(&pstore_blk_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(register_pstore_device);\n\nstatic void __unregister_pstore_device(struct pstore_device_info *dev)\n{\n\tlockdep_assert_held(&pstore_blk_lock);\n\tif (pstore_device_info && pstore_device_info == dev) {\n\t\tunregister_pstore_zone(&dev->zone);\n\t\tpstore_device_info = NULL;\n\t}\n}\n\n \nvoid unregister_pstore_device(struct pstore_device_info *dev)\n{\n\tmutex_lock(&pstore_blk_lock);\n\t__unregister_pstore_device(dev);\n\tmutex_unlock(&pstore_blk_lock);\n}\nEXPORT_SYMBOL_GPL(unregister_pstore_device);\n\nstatic ssize_t psblk_generic_blk_read(char *buf, size_t bytes, loff_t pos)\n{\n\treturn kernel_read(psblk_file, buf, bytes, &pos);\n}\n\nstatic ssize_t psblk_generic_blk_write(const char *buf, size_t bytes,\n\t\tloff_t pos)\n{\n\t \n\tif (in_interrupt() || irqs_disabled())\n\t\treturn -EBUSY;\n\treturn kernel_write(psblk_file, buf, bytes, &pos);\n}\n\n \nstatic int __register_pstore_blk(struct pstore_device_info *dev,\n\t\t\t\t const char *devpath)\n{\n\tint ret = -ENODEV;\n\n\tlockdep_assert_held(&pstore_blk_lock);\n\n\tpsblk_file = filp_open(devpath, O_RDWR | O_DSYNC | O_NOATIME | O_EXCL, 0);\n\tif (IS_ERR(psblk_file)) {\n\t\tret = PTR_ERR(psblk_file);\n\t\tpr_err(\"failed to open '%s': %d!\\n\", devpath, ret);\n\t\tgoto err;\n\t}\n\n\tif (!S_ISBLK(file_inode(psblk_file)->i_mode)) {\n\t\tpr_err(\"'%s' is not block device!\\n\", devpath);\n\t\tgoto err_fput;\n\t}\n\n\tdev->zone.total_size =\n\t\tbdev_nr_bytes(I_BDEV(psblk_file->f_mapping->host));\n\n\tret = __register_pstore_device(dev);\n\tif (ret)\n\t\tgoto err_fput;\n\n\treturn 0;\n\nerr_fput:\n\tfput(psblk_file);\nerr:\n\tpsblk_file = NULL;\n\n\treturn ret;\n}\n\n \nint pstore_blk_get_config(struct pstore_blk_config *info)\n{\n\tstrncpy(info->device, blkdev, 80);\n\tinfo->max_reason = max_reason;\n\tinfo->kmsg_size = check_size(kmsg_size, 4096);\n\tinfo->pmsg_size = check_size(pmsg_size, 4096);\n\tinfo->ftrace_size = check_size(ftrace_size, 4096);\n\tinfo->console_size = check_size(console_size, 4096);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(pstore_blk_get_config);\n\n\n#ifndef MODULE\nstatic const char devname[] = \"/dev/pstore-blk\";\nstatic __init const char *early_boot_devpath(const char *initial_devname)\n{\n\t \n\tdev_t dev;\n\n\tif (early_lookup_bdev(initial_devname, &dev)) {\n\t\tpr_err(\"failed to resolve '%s'!\\n\", initial_devname);\n\t\treturn initial_devname;\n\t}\n\n\tinit_unlink(devname);\n\tinit_mknod(devname, S_IFBLK | 0600, new_encode_dev(dev));\n\n\treturn devname;\n}\n#else\nstatic inline const char *early_boot_devpath(const char *initial_devname)\n{\n\treturn initial_devname;\n}\n#endif\n\nstatic int __init __best_effort_init(void)\n{\n\tstruct pstore_device_info *best_effort_dev;\n\tint ret;\n\n\t \n\tif (!best_effort)\n\t\treturn 0;\n\n\t \n\tif (!blkdev[0]) {\n\t\tpr_err(\"blkdev empty with best_effort=Y\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbest_effort_dev = kzalloc(sizeof(*best_effort_dev), GFP_KERNEL);\n\tif (!best_effort_dev)\n\t\treturn -ENOMEM;\n\n\tbest_effort_dev->zone.read = psblk_generic_blk_read;\n\tbest_effort_dev->zone.write = psblk_generic_blk_write;\n\n\tret = __register_pstore_blk(best_effort_dev,\n\t\t\t\t    early_boot_devpath(blkdev));\n\tif (ret)\n\t\tkfree(best_effort_dev);\n\telse\n\t\tpr_info(\"attached %s (%lu) (no dedicated panic_write!)\\n\",\n\t\t\tblkdev, best_effort_dev->zone.total_size);\n\n\treturn ret;\n}\n\nstatic void __exit __best_effort_exit(void)\n{\n\t \n\tif (psblk_file) {\n\t\tstruct pstore_device_info *dev = pstore_device_info;\n\n\t\t__unregister_pstore_device(dev);\n\t\tkfree(dev);\n\t\tfput(psblk_file);\n\t\tpsblk_file = NULL;\n\t}\n}\n\nstatic int __init pstore_blk_init(void)\n{\n\tint ret;\n\n\tmutex_lock(&pstore_blk_lock);\n\tret = __best_effort_init();\n\tmutex_unlock(&pstore_blk_lock);\n\n\treturn ret;\n}\nlate_initcall(pstore_blk_init);\n\nstatic void __exit pstore_blk_exit(void)\n{\n\tmutex_lock(&pstore_blk_lock);\n\t__best_effort_exit();\n\t \n\t__unregister_pstore_device(pstore_device_info);\n\tmutex_unlock(&pstore_blk_lock);\n}\nmodule_exit(pstore_blk_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"WeiXiong Liao <liaoweixiong@allwinnertech.com>\");\nMODULE_AUTHOR(\"Kees Cook <keescook@chromium.org>\");\nMODULE_DESCRIPTION(\"pstore backend for block devices\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}