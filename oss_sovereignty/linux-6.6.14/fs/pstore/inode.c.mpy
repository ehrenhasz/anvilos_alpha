{
  "module_name": "inode.c",
  "hash_id": "e21cc791bd0c91a80557e69b7d020c64c348233b9db420cb40734fed463f9ca7",
  "original_prompt": "Ingested from linux-6.6.14/fs/pstore/inode.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/ramfs.h>\n#include <linux/parser.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/pstore.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\n#include \"internal.h\"\n\n#define\tPSTORE_NAMELEN\t64\n\nstatic DEFINE_MUTEX(records_list_lock);\nstatic LIST_HEAD(records_list);\n\nstatic DEFINE_MUTEX(pstore_sb_lock);\nstatic struct super_block *pstore_sb;\n\nstruct pstore_private {\n\tstruct list_head list;\n\tstruct dentry *dentry;\n\tstruct pstore_record *record;\n\tsize_t total_size;\n};\n\nstruct pstore_ftrace_seq_data {\n\tconst void *ptr;\n\tsize_t off;\n\tsize_t size;\n};\n\n#define REC_SIZE sizeof(struct pstore_ftrace_record)\n\nstatic void free_pstore_private(struct pstore_private *private)\n{\n\tif (!private)\n\t\treturn;\n\tif (private->record) {\n\t\tkvfree(private->record->buf);\n\t\tkfree(private->record->priv);\n\t\tkfree(private->record);\n\t}\n\tkfree(private);\n}\n\nstatic void *pstore_ftrace_seq_start(struct seq_file *s, loff_t *pos)\n{\n\tstruct pstore_private *ps = s->private;\n\tstruct pstore_ftrace_seq_data *data;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn NULL;\n\n\tdata->off = ps->total_size % REC_SIZE;\n\tdata->off += *pos * REC_SIZE;\n\tif (data->off + REC_SIZE > ps->total_size) {\n\t\tkfree(data);\n\t\treturn NULL;\n\t}\n\n\treturn data;\n\n}\n\nstatic void pstore_ftrace_seq_stop(struct seq_file *s, void *v)\n{\n\tkfree(v);\n}\n\nstatic void *pstore_ftrace_seq_next(struct seq_file *s, void *v, loff_t *pos)\n{\n\tstruct pstore_private *ps = s->private;\n\tstruct pstore_ftrace_seq_data *data = v;\n\n\t(*pos)++;\n\tdata->off += REC_SIZE;\n\tif (data->off + REC_SIZE > ps->total_size)\n\t\treturn NULL;\n\n\treturn data;\n}\n\nstatic int pstore_ftrace_seq_show(struct seq_file *s, void *v)\n{\n\tstruct pstore_private *ps = s->private;\n\tstruct pstore_ftrace_seq_data *data = v;\n\tstruct pstore_ftrace_record *rec;\n\n\tif (!data)\n\t\treturn 0;\n\n\trec = (struct pstore_ftrace_record *)(ps->record->buf + data->off);\n\n\tseq_printf(s, \"CPU:%d ts:%llu %08lx  %08lx  %ps <- %pS\\n\",\n\t\t   pstore_ftrace_decode_cpu(rec),\n\t\t   pstore_ftrace_read_timestamp(rec),\n\t\t   rec->ip, rec->parent_ip, (void *)rec->ip,\n\t\t   (void *)rec->parent_ip);\n\n\treturn 0;\n}\n\nstatic const struct seq_operations pstore_ftrace_seq_ops = {\n\t.start\t= pstore_ftrace_seq_start,\n\t.next\t= pstore_ftrace_seq_next,\n\t.stop\t= pstore_ftrace_seq_stop,\n\t.show\t= pstore_ftrace_seq_show,\n};\n\nstatic ssize_t pstore_file_read(struct file *file, char __user *userbuf,\n\t\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct seq_file *sf = file->private_data;\n\tstruct pstore_private *ps = sf->private;\n\n\tif (ps->record->type == PSTORE_TYPE_FTRACE)\n\t\treturn seq_read(file, userbuf, count, ppos);\n\treturn simple_read_from_buffer(userbuf, count, ppos,\n\t\t\t\t       ps->record->buf, ps->total_size);\n}\n\nstatic int pstore_file_open(struct inode *inode, struct file *file)\n{\n\tstruct pstore_private *ps = inode->i_private;\n\tstruct seq_file *sf;\n\tint err;\n\tconst struct seq_operations *sops = NULL;\n\n\tif (ps->record->type == PSTORE_TYPE_FTRACE)\n\t\tsops = &pstore_ftrace_seq_ops;\n\n\terr = seq_open(file, sops);\n\tif (err < 0)\n\t\treturn err;\n\n\tsf = file->private_data;\n\tsf->private = ps;\n\n\treturn 0;\n}\n\nstatic loff_t pstore_file_llseek(struct file *file, loff_t off, int whence)\n{\n\tstruct seq_file *sf = file->private_data;\n\n\tif (sf->op)\n\t\treturn seq_lseek(file, off, whence);\n\treturn default_llseek(file, off, whence);\n}\n\nstatic const struct file_operations pstore_file_operations = {\n\t.open\t\t= pstore_file_open,\n\t.read\t\t= pstore_file_read,\n\t.llseek\t\t= pstore_file_llseek,\n\t.release\t= seq_release,\n};\n\n \nstatic int pstore_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct pstore_private *p = d_inode(dentry)->i_private;\n\tstruct pstore_record *record = p->record;\n\tint rc = 0;\n\n\tif (!record->psi->erase)\n\t\treturn -EPERM;\n\n\t \n\tmutex_lock(&records_list_lock);\n\tif (!list_empty(&p->list))\n\t\tlist_del_init(&p->list);\n\telse\n\t\trc = -ENOENT;\n\tp->dentry = NULL;\n\tmutex_unlock(&records_list_lock);\n\tif (rc)\n\t\treturn rc;\n\n\tmutex_lock(&record->psi->read_mutex);\n\trecord->psi->erase(record);\n\tmutex_unlock(&record->psi->read_mutex);\n\n\treturn simple_unlink(dir, dentry);\n}\n\nstatic void pstore_evict_inode(struct inode *inode)\n{\n\tstruct pstore_private\t*p = inode->i_private;\n\n\tclear_inode(inode);\n\tfree_pstore_private(p);\n}\n\nstatic const struct inode_operations pstore_dir_inode_operations = {\n\t.lookup\t\t= simple_lookup,\n\t.unlink\t\t= pstore_unlink,\n};\n\nstatic struct inode *pstore_get_inode(struct super_block *sb)\n{\n\tstruct inode *inode = new_inode(sb);\n\tif (inode) {\n\t\tinode->i_ino = get_next_ino();\n\t\tinode->i_atime = inode->i_mtime = inode_set_ctime_current(inode);\n\t}\n\treturn inode;\n}\n\nenum {\n\tOpt_kmsg_bytes, Opt_err\n};\n\nstatic const match_table_t tokens = {\n\t{Opt_kmsg_bytes, \"kmsg_bytes=%u\"},\n\t{Opt_err, NULL}\n};\n\nstatic void parse_options(char *options)\n{\n\tchar\t\t*p;\n\tsubstring_t\targs[MAX_OPT_ARGS];\n\tint\t\toption;\n\n\tif (!options)\n\t\treturn;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_kmsg_bytes:\n\t\t\tif (!match_int(&args[0], &option))\n\t\t\t\tpstore_set_kmsg_bytes(option);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nstatic int pstore_show_options(struct seq_file *m, struct dentry *root)\n{\n\tif (kmsg_bytes != CONFIG_PSTORE_DEFAULT_KMSG_BYTES)\n\t\tseq_printf(m, \",kmsg_bytes=%lu\", kmsg_bytes);\n\treturn 0;\n}\n\nstatic int pstore_remount(struct super_block *sb, int *flags, char *data)\n{\n\tsync_filesystem(sb);\n\tparse_options(data);\n\n\treturn 0;\n}\n\nstatic const struct super_operations pstore_ops = {\n\t.statfs\t\t= simple_statfs,\n\t.drop_inode\t= generic_delete_inode,\n\t.evict_inode\t= pstore_evict_inode,\n\t.remount_fs\t= pstore_remount,\n\t.show_options\t= pstore_show_options,\n};\n\nstatic struct dentry *psinfo_lock_root(void)\n{\n\tstruct dentry *root;\n\n\tmutex_lock(&pstore_sb_lock);\n\t \n\tif (!psinfo || !pstore_sb) {\n\t\tmutex_unlock(&pstore_sb_lock);\n\t\treturn NULL;\n\t}\n\n\troot = pstore_sb->s_root;\n\tinode_lock(d_inode(root));\n\tmutex_unlock(&pstore_sb_lock);\n\n\treturn root;\n}\n\nint pstore_put_backend_records(struct pstore_info *psi)\n{\n\tstruct pstore_private *pos, *tmp;\n\tstruct dentry *root;\n\tint rc = 0;\n\n\troot = psinfo_lock_root();\n\tif (!root)\n\t\treturn 0;\n\n\tmutex_lock(&records_list_lock);\n\tlist_for_each_entry_safe(pos, tmp, &records_list, list) {\n\t\tif (pos->record->psi == psi) {\n\t\t\tlist_del_init(&pos->list);\n\t\t\trc = simple_unlink(d_inode(root), pos->dentry);\n\t\t\tif (WARN_ON(rc))\n\t\t\t\tbreak;\n\t\t\td_drop(pos->dentry);\n\t\t\tdput(pos->dentry);\n\t\t\tpos->dentry = NULL;\n\t\t}\n\t}\n\tmutex_unlock(&records_list_lock);\n\n\tinode_unlock(d_inode(root));\n\n\treturn rc;\n}\n\n \nint pstore_mkfile(struct dentry *root, struct pstore_record *record)\n{\n\tstruct dentry\t\t*dentry;\n\tstruct inode\t\t*inode;\n\tint\t\t\trc = 0;\n\tchar\t\t\tname[PSTORE_NAMELEN];\n\tstruct pstore_private\t*private, *pos;\n\tsize_t\t\t\tsize = record->size + record->ecc_notice_size;\n\n\tif (WARN_ON(!inode_is_locked(d_inode(root))))\n\t\treturn -EINVAL;\n\n\trc = -EEXIST;\n\t \n\tmutex_lock(&records_list_lock);\n\tlist_for_each_entry(pos, &records_list, list) {\n\t\tif (pos->record->type == record->type &&\n\t\t    pos->record->id == record->id &&\n\t\t    pos->record->psi == record->psi)\n\t\t\tgoto fail;\n\t}\n\n\trc = -ENOMEM;\n\tinode = pstore_get_inode(root->d_sb);\n\tif (!inode)\n\t\tgoto fail;\n\tinode->i_mode = S_IFREG | 0444;\n\tinode->i_fop = &pstore_file_operations;\n\tscnprintf(name, sizeof(name), \"%s-%s-%llu%s\",\n\t\t\tpstore_type_to_name(record->type),\n\t\t\trecord->psi->name, record->id,\n\t\t\trecord->compressed ? \".enc.z\" : \"\");\n\n\tprivate = kzalloc(sizeof(*private), GFP_KERNEL);\n\tif (!private)\n\t\tgoto fail_inode;\n\n\tdentry = d_alloc_name(root, name);\n\tif (!dentry)\n\t\tgoto fail_private;\n\n\tprivate->dentry = dentry;\n\tprivate->record = record;\n\tinode->i_size = private->total_size = size;\n\tinode->i_private = private;\n\n\tif (record->time.tv_sec)\n\t\tinode->i_mtime = inode_set_ctime_to_ts(inode, record->time);\n\n\td_add(dentry, inode);\n\n\tlist_add(&private->list, &records_list);\n\tmutex_unlock(&records_list_lock);\n\n\treturn 0;\n\nfail_private:\n\tfree_pstore_private(private);\nfail_inode:\n\tiput(inode);\nfail:\n\tmutex_unlock(&records_list_lock);\n\treturn rc;\n}\n\n \nvoid pstore_get_records(int quiet)\n{\n\tstruct dentry *root;\n\n\troot = psinfo_lock_root();\n\tif (!root)\n\t\treturn;\n\n\tpstore_get_backend_records(psinfo, root, quiet);\n\tinode_unlock(d_inode(root));\n}\n\nstatic int pstore_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct inode *inode;\n\n\tsb->s_maxbytes\t\t= MAX_LFS_FILESIZE;\n\tsb->s_blocksize\t\t= PAGE_SIZE;\n\tsb->s_blocksize_bits\t= PAGE_SHIFT;\n\tsb->s_magic\t\t= PSTOREFS_MAGIC;\n\tsb->s_op\t\t= &pstore_ops;\n\tsb->s_time_gran\t\t= 1;\n\n\tparse_options(data);\n\n\tinode = pstore_get_inode(sb);\n\tif (inode) {\n\t\tinode->i_mode = S_IFDIR | 0750;\n\t\tinode->i_op = &pstore_dir_inode_operations;\n\t\tinode->i_fop = &simple_dir_operations;\n\t\tinc_nlink(inode);\n\t}\n\tsb->s_root = d_make_root(inode);\n\tif (!sb->s_root)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&pstore_sb_lock);\n\tpstore_sb = sb;\n\tmutex_unlock(&pstore_sb_lock);\n\n\tpstore_get_records(0);\n\n\treturn 0;\n}\n\nstatic struct dentry *pstore_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_single(fs_type, flags, data, pstore_fill_super);\n}\n\nstatic void pstore_kill_sb(struct super_block *sb)\n{\n\tmutex_lock(&pstore_sb_lock);\n\tWARN_ON(pstore_sb && pstore_sb != sb);\n\n\tkill_litter_super(sb);\n\tpstore_sb = NULL;\n\n\tmutex_lock(&records_list_lock);\n\tINIT_LIST_HEAD(&records_list);\n\tmutex_unlock(&records_list_lock);\n\n\tmutex_unlock(&pstore_sb_lock);\n}\n\nstatic struct file_system_type pstore_fs_type = {\n\t.owner          = THIS_MODULE,\n\t.name\t\t= \"pstore\",\n\t.mount\t\t= pstore_mount,\n\t.kill_sb\t= pstore_kill_sb,\n};\n\nint __init pstore_init_fs(void)\n{\n\tint err;\n\n\t \n\terr = sysfs_create_mount_point(fs_kobj, \"pstore\");\n\tif (err)\n\t\tgoto out;\n\n\terr = register_filesystem(&pstore_fs_type);\n\tif (err < 0)\n\t\tsysfs_remove_mount_point(fs_kobj, \"pstore\");\n\nout:\n\treturn err;\n}\n\nvoid __exit pstore_exit_fs(void)\n{\n\tunregister_filesystem(&pstore_fs_type);\n\tsysfs_remove_mount_point(fs_kobj, \"pstore\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}