{
  "module_name": "ram_core.c",
  "hash_id": "5bcb69cb648a83de0f633dfc9ac95899cfe299b9a39375023c61a918f480167f",
  "original_prompt": "Ingested from linux-6.6.14/fs/pstore/ram_core.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/memblock.h>\n#include <linux/rslib.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <asm/page.h>\n\n#include \"ram_internal.h\"\n\n \nstruct persistent_ram_buffer {\n\tuint32_t    sig;\n\tatomic_t    start;\n\tatomic_t    size;\n\tuint8_t     data[];\n};\n\n#define PERSISTENT_RAM_SIG (0x43474244)  \n\nstatic inline size_t buffer_size(struct persistent_ram_zone *prz)\n{\n\treturn atomic_read(&prz->buffer->size);\n}\n\nstatic inline size_t buffer_start(struct persistent_ram_zone *prz)\n{\n\treturn atomic_read(&prz->buffer->start);\n}\n\n \nstatic size_t buffer_start_add(struct persistent_ram_zone *prz, size_t a)\n{\n\tint old;\n\tint new;\n\tunsigned long flags = 0;\n\n\tif (!(prz->flags & PRZ_FLAG_NO_LOCK))\n\t\traw_spin_lock_irqsave(&prz->buffer_lock, flags);\n\n\told = atomic_read(&prz->buffer->start);\n\tnew = old + a;\n\twhile (unlikely(new >= prz->buffer_size))\n\t\tnew -= prz->buffer_size;\n\tatomic_set(&prz->buffer->start, new);\n\n\tif (!(prz->flags & PRZ_FLAG_NO_LOCK))\n\t\traw_spin_unlock_irqrestore(&prz->buffer_lock, flags);\n\n\treturn old;\n}\n\n \nstatic void buffer_size_add(struct persistent_ram_zone *prz, size_t a)\n{\n\tsize_t old;\n\tsize_t new;\n\tunsigned long flags = 0;\n\n\tif (!(prz->flags & PRZ_FLAG_NO_LOCK))\n\t\traw_spin_lock_irqsave(&prz->buffer_lock, flags);\n\n\told = atomic_read(&prz->buffer->size);\n\tif (old == prz->buffer_size)\n\t\tgoto exit;\n\n\tnew = old + a;\n\tif (new > prz->buffer_size)\n\t\tnew = prz->buffer_size;\n\tatomic_set(&prz->buffer->size, new);\n\nexit:\n\tif (!(prz->flags & PRZ_FLAG_NO_LOCK))\n\t\traw_spin_unlock_irqrestore(&prz->buffer_lock, flags);\n}\n\nstatic void notrace persistent_ram_encode_rs8(struct persistent_ram_zone *prz,\n\tuint8_t *data, size_t len, uint8_t *ecc)\n{\n\tint i;\n\n\t \n\tmemset(prz->ecc_info.par, 0,\n\t       prz->ecc_info.ecc_size * sizeof(prz->ecc_info.par[0]));\n\tencode_rs8(prz->rs_decoder, data, len, prz->ecc_info.par, 0);\n\tfor (i = 0; i < prz->ecc_info.ecc_size; i++)\n\t\tecc[i] = prz->ecc_info.par[i];\n}\n\nstatic int persistent_ram_decode_rs8(struct persistent_ram_zone *prz,\n\tvoid *data, size_t len, uint8_t *ecc)\n{\n\tint i;\n\n\tfor (i = 0; i < prz->ecc_info.ecc_size; i++)\n\t\tprz->ecc_info.par[i] = ecc[i];\n\treturn decode_rs8(prz->rs_decoder, data, prz->ecc_info.par, len,\n\t\t\t\tNULL, 0, NULL, 0, NULL);\n}\n\nstatic void notrace persistent_ram_update_ecc(struct persistent_ram_zone *prz,\n\tunsigned int start, unsigned int count)\n{\n\tstruct persistent_ram_buffer *buffer = prz->buffer;\n\tuint8_t *buffer_end = buffer->data + prz->buffer_size;\n\tuint8_t *block;\n\tuint8_t *par;\n\tint ecc_block_size = prz->ecc_info.block_size;\n\tint ecc_size = prz->ecc_info.ecc_size;\n\tint size = ecc_block_size;\n\n\tif (!ecc_size)\n\t\treturn;\n\n\tblock = buffer->data + (start & ~(ecc_block_size - 1));\n\tpar = prz->par_buffer + (start / ecc_block_size) * ecc_size;\n\n\tdo {\n\t\tif (block + ecc_block_size > buffer_end)\n\t\t\tsize = buffer_end - block;\n\t\tpersistent_ram_encode_rs8(prz, block, size, par);\n\t\tblock += ecc_block_size;\n\t\tpar += ecc_size;\n\t} while (block < buffer->data + start + count);\n}\n\nstatic void persistent_ram_update_header_ecc(struct persistent_ram_zone *prz)\n{\n\tstruct persistent_ram_buffer *buffer = prz->buffer;\n\n\tif (!prz->ecc_info.ecc_size)\n\t\treturn;\n\n\tpersistent_ram_encode_rs8(prz, (uint8_t *)buffer, sizeof(*buffer),\n\t\t\t\t  prz->par_header);\n}\n\nstatic void persistent_ram_ecc_old(struct persistent_ram_zone *prz)\n{\n\tstruct persistent_ram_buffer *buffer = prz->buffer;\n\tuint8_t *block;\n\tuint8_t *par;\n\n\tif (!prz->ecc_info.ecc_size)\n\t\treturn;\n\n\tblock = buffer->data;\n\tpar = prz->par_buffer;\n\twhile (block < buffer->data + buffer_size(prz)) {\n\t\tint numerr;\n\t\tint size = prz->ecc_info.block_size;\n\t\tif (block + size > buffer->data + prz->buffer_size)\n\t\t\tsize = buffer->data + prz->buffer_size - block;\n\t\tnumerr = persistent_ram_decode_rs8(prz, block, size, par);\n\t\tif (numerr > 0) {\n\t\t\tpr_devel(\"error in block %p, %d\\n\", block, numerr);\n\t\t\tprz->corrected_bytes += numerr;\n\t\t} else if (numerr < 0) {\n\t\t\tpr_devel(\"uncorrectable error in block %p\\n\", block);\n\t\t\tprz->bad_blocks++;\n\t\t}\n\t\tblock += prz->ecc_info.block_size;\n\t\tpar += prz->ecc_info.ecc_size;\n\t}\n}\n\nstatic int persistent_ram_init_ecc(struct persistent_ram_zone *prz,\n\t\t\t\t   struct persistent_ram_ecc_info *ecc_info)\n{\n\tint numerr;\n\tstruct persistent_ram_buffer *buffer = prz->buffer;\n\tsize_t ecc_blocks;\n\tsize_t ecc_total;\n\n\tif (!ecc_info || !ecc_info->ecc_size)\n\t\treturn 0;\n\n\tprz->ecc_info.block_size = ecc_info->block_size ?: 128;\n\tprz->ecc_info.ecc_size = ecc_info->ecc_size ?: 16;\n\tprz->ecc_info.symsize = ecc_info->symsize ?: 8;\n\tprz->ecc_info.poly = ecc_info->poly ?: 0x11d;\n\n\tecc_blocks = DIV_ROUND_UP(prz->buffer_size - prz->ecc_info.ecc_size,\n\t\t\t\t  prz->ecc_info.block_size +\n\t\t\t\t  prz->ecc_info.ecc_size);\n\tecc_total = (ecc_blocks + 1) * prz->ecc_info.ecc_size;\n\tif (ecc_total >= prz->buffer_size) {\n\t\tpr_err(\"%s: invalid ecc_size %u (total %zu, buffer size %zu)\\n\",\n\t\t       __func__, prz->ecc_info.ecc_size,\n\t\t       ecc_total, prz->buffer_size);\n\t\treturn -EINVAL;\n\t}\n\n\tprz->buffer_size -= ecc_total;\n\tprz->par_buffer = buffer->data + prz->buffer_size;\n\tprz->par_header = prz->par_buffer +\n\t\t\t  ecc_blocks * prz->ecc_info.ecc_size;\n\n\t \n\tprz->rs_decoder = init_rs(prz->ecc_info.symsize, prz->ecc_info.poly,\n\t\t\t\t  0, 1, prz->ecc_info.ecc_size);\n\tif (prz->rs_decoder == NULL) {\n\t\tpr_info(\"init_rs failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tprz->ecc_info.par = kmalloc_array(prz->ecc_info.ecc_size,\n\t\t\t\t\t  sizeof(*prz->ecc_info.par),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!prz->ecc_info.par) {\n\t\tpr_err(\"cannot allocate ECC parity workspace\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tprz->corrected_bytes = 0;\n\tprz->bad_blocks = 0;\n\n\tnumerr = persistent_ram_decode_rs8(prz, buffer, sizeof(*buffer),\n\t\t\t\t\t   prz->par_header);\n\tif (numerr > 0) {\n\t\tpr_info(\"error in header, %d\\n\", numerr);\n\t\tprz->corrected_bytes += numerr;\n\t} else if (numerr < 0) {\n\t\tpr_info_ratelimited(\"uncorrectable error in header\\n\");\n\t\tprz->bad_blocks++;\n\t}\n\n\treturn 0;\n}\n\nssize_t persistent_ram_ecc_string(struct persistent_ram_zone *prz,\n\tchar *str, size_t len)\n{\n\tssize_t ret;\n\n\tif (!prz->ecc_info.ecc_size)\n\t\treturn 0;\n\n\tif (prz->corrected_bytes || prz->bad_blocks)\n\t\tret = snprintf(str, len, \"\"\n\t\t\t\"\\nECC: %d Corrected bytes, %d unrecoverable blocks\\n\",\n\t\t\tprz->corrected_bytes, prz->bad_blocks);\n\telse\n\t\tret = snprintf(str, len, \"\\nECC: No errors detected\\n\");\n\n\treturn ret;\n}\n\nstatic void notrace persistent_ram_update(struct persistent_ram_zone *prz,\n\tconst void *s, unsigned int start, unsigned int count)\n{\n\tstruct persistent_ram_buffer *buffer = prz->buffer;\n\tmemcpy_toio(buffer->data + start, s, count);\n\tpersistent_ram_update_ecc(prz, start, count);\n}\n\nstatic int notrace persistent_ram_update_user(struct persistent_ram_zone *prz,\n\tconst void __user *s, unsigned int start, unsigned int count)\n{\n\tstruct persistent_ram_buffer *buffer = prz->buffer;\n\tint ret = unlikely(copy_from_user(buffer->data + start, s, count)) ?\n\t\t-EFAULT : 0;\n\tpersistent_ram_update_ecc(prz, start, count);\n\treturn ret;\n}\n\nvoid persistent_ram_save_old(struct persistent_ram_zone *prz)\n{\n\tstruct persistent_ram_buffer *buffer = prz->buffer;\n\tsize_t size = buffer_size(prz);\n\tsize_t start = buffer_start(prz);\n\n\tif (!size)\n\t\treturn;\n\n\tif (!prz->old_log) {\n\t\tpersistent_ram_ecc_old(prz);\n\t\tprz->old_log = kvzalloc(size, GFP_KERNEL);\n\t}\n\tif (!prz->old_log) {\n\t\tpr_err(\"failed to allocate buffer\\n\");\n\t\treturn;\n\t}\n\n\tprz->old_log_size = size;\n\tmemcpy_fromio(prz->old_log, &buffer->data[start], size - start);\n\tmemcpy_fromio(prz->old_log + size - start, &buffer->data[0], start);\n}\n\nint notrace persistent_ram_write(struct persistent_ram_zone *prz,\n\tconst void *s, unsigned int count)\n{\n\tint rem;\n\tint c = count;\n\tsize_t start;\n\n\tif (unlikely(c > prz->buffer_size)) {\n\t\ts += c - prz->buffer_size;\n\t\tc = prz->buffer_size;\n\t}\n\n\tbuffer_size_add(prz, c);\n\n\tstart = buffer_start_add(prz, c);\n\n\trem = prz->buffer_size - start;\n\tif (unlikely(rem < c)) {\n\t\tpersistent_ram_update(prz, s, start, rem);\n\t\ts += rem;\n\t\tc -= rem;\n\t\tstart = 0;\n\t}\n\tpersistent_ram_update(prz, s, start, c);\n\n\tpersistent_ram_update_header_ecc(prz);\n\n\treturn count;\n}\n\nint notrace persistent_ram_write_user(struct persistent_ram_zone *prz,\n\tconst void __user *s, unsigned int count)\n{\n\tint rem, ret = 0, c = count;\n\tsize_t start;\n\n\tif (unlikely(c > prz->buffer_size)) {\n\t\ts += c - prz->buffer_size;\n\t\tc = prz->buffer_size;\n\t}\n\n\tbuffer_size_add(prz, c);\n\n\tstart = buffer_start_add(prz, c);\n\n\trem = prz->buffer_size - start;\n\tif (unlikely(rem < c)) {\n\t\tret = persistent_ram_update_user(prz, s, start, rem);\n\t\ts += rem;\n\t\tc -= rem;\n\t\tstart = 0;\n\t}\n\tif (likely(!ret))\n\t\tret = persistent_ram_update_user(prz, s, start, c);\n\n\tpersistent_ram_update_header_ecc(prz);\n\n\treturn unlikely(ret) ? ret : count;\n}\n\nsize_t persistent_ram_old_size(struct persistent_ram_zone *prz)\n{\n\treturn prz->old_log_size;\n}\n\nvoid *persistent_ram_old(struct persistent_ram_zone *prz)\n{\n\treturn prz->old_log;\n}\n\nvoid persistent_ram_free_old(struct persistent_ram_zone *prz)\n{\n\tkvfree(prz->old_log);\n\tprz->old_log = NULL;\n\tprz->old_log_size = 0;\n}\n\nvoid persistent_ram_zap(struct persistent_ram_zone *prz)\n{\n\tatomic_set(&prz->buffer->start, 0);\n\tatomic_set(&prz->buffer->size, 0);\n\tpersistent_ram_update_header_ecc(prz);\n}\n\n#define MEM_TYPE_WCOMBINE\t0\n#define MEM_TYPE_NONCACHED\t1\n#define MEM_TYPE_NORMAL\t\t2\n\nstatic void *persistent_ram_vmap(phys_addr_t start, size_t size,\n\t\tunsigned int memtype)\n{\n\tstruct page **pages;\n\tphys_addr_t page_start;\n\tunsigned int page_count;\n\tpgprot_t prot;\n\tunsigned int i;\n\tvoid *vaddr;\n\n\tpage_start = start - offset_in_page(start);\n\tpage_count = DIV_ROUND_UP(size + offset_in_page(start), PAGE_SIZE);\n\n\tswitch (memtype) {\n\tcase MEM_TYPE_NORMAL:\n\t\tprot = PAGE_KERNEL;\n\t\tbreak;\n\tcase MEM_TYPE_NONCACHED:\n\t\tprot = pgprot_noncached(PAGE_KERNEL);\n\t\tbreak;\n\tcase MEM_TYPE_WCOMBINE:\n\t\tprot = pgprot_writecombine(PAGE_KERNEL);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"invalid mem_type=%d\\n\", memtype);\n\t\treturn NULL;\n\t}\n\n\tpages = kmalloc_array(page_count, sizeof(struct page *), GFP_KERNEL);\n\tif (!pages) {\n\t\tpr_err(\"%s: Failed to allocate array for %u pages\\n\",\n\t\t       __func__, page_count);\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < page_count; i++) {\n\t\tphys_addr_t addr = page_start + i * PAGE_SIZE;\n\t\tpages[i] = pfn_to_page(addr >> PAGE_SHIFT);\n\t}\n\t \n\tvaddr = vmap(pages, page_count, VM_MAP | VM_IOREMAP, prot);\n\tkfree(pages);\n\n\t \n\treturn vaddr + offset_in_page(start);\n}\n\nstatic void *persistent_ram_iomap(phys_addr_t start, size_t size,\n\t\tunsigned int memtype, char *label)\n{\n\tvoid *va;\n\n\tif (!request_mem_region(start, size, label ?: \"ramoops\")) {\n\t\tpr_err(\"request mem region (%s 0x%llx@0x%llx) failed\\n\",\n\t\t\tlabel ?: \"ramoops\",\n\t\t\t(unsigned long long)size, (unsigned long long)start);\n\t\treturn NULL;\n\t}\n\n\tif (memtype)\n\t\tva = ioremap(start, size);\n\telse\n\t\tva = ioremap_wc(start, size);\n\n\t \n\treturn va;\n}\n\nstatic int persistent_ram_buffer_map(phys_addr_t start, phys_addr_t size,\n\t\tstruct persistent_ram_zone *prz, int memtype)\n{\n\tprz->paddr = start;\n\tprz->size = size;\n\n\tif (pfn_valid(start >> PAGE_SHIFT))\n\t\tprz->vaddr = persistent_ram_vmap(start, size, memtype);\n\telse\n\t\tprz->vaddr = persistent_ram_iomap(start, size, memtype,\n\t\t\t\t\t\t  prz->label);\n\n\tif (!prz->vaddr) {\n\t\tpr_err(\"%s: Failed to map 0x%llx pages at 0x%llx\\n\", __func__,\n\t\t\t(unsigned long long)size, (unsigned long long)start);\n\t\treturn -ENOMEM;\n\t}\n\n\tprz->buffer = prz->vaddr;\n\tprz->buffer_size = size - sizeof(struct persistent_ram_buffer);\n\n\treturn 0;\n}\n\nstatic int persistent_ram_post_init(struct persistent_ram_zone *prz, u32 sig,\n\t\t\t\t    struct persistent_ram_ecc_info *ecc_info)\n{\n\tint ret;\n\tbool zap = !!(prz->flags & PRZ_FLAG_ZAP_OLD);\n\n\tret = persistent_ram_init_ecc(prz, ecc_info);\n\tif (ret) {\n\t\tpr_warn(\"ECC failed %s\\n\", prz->label);\n\t\treturn ret;\n\t}\n\n\tsig ^= PERSISTENT_RAM_SIG;\n\n\tif (prz->buffer->sig == sig) {\n\t\tif (buffer_size(prz) == 0 && buffer_start(prz) == 0) {\n\t\t\tpr_debug(\"found existing empty buffer\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (buffer_size(prz) > prz->buffer_size ||\n\t\t    buffer_start(prz) > buffer_size(prz)) {\n\t\t\tpr_info(\"found existing invalid buffer, size %zu, start %zu\\n\",\n\t\t\t\tbuffer_size(prz), buffer_start(prz));\n\t\t\tzap = true;\n\t\t} else {\n\t\t\tpr_debug(\"found existing buffer, size %zu, start %zu\\n\",\n\t\t\t\t buffer_size(prz), buffer_start(prz));\n\t\t\tpersistent_ram_save_old(prz);\n\t\t}\n\t} else {\n\t\tpr_debug(\"no valid data in buffer (sig = 0x%08x)\\n\",\n\t\t\t prz->buffer->sig);\n\t\tprz->buffer->sig = sig;\n\t\tzap = true;\n\t}\n\n\t \n\tif (zap)\n\t\tpersistent_ram_zap(prz);\n\n\treturn 0;\n}\n\nvoid persistent_ram_free(struct persistent_ram_zone **_prz)\n{\n\tstruct persistent_ram_zone *prz;\n\n\tif (!_prz)\n\t\treturn;\n\n\tprz = *_prz;\n\tif (!prz)\n\t\treturn;\n\n\tif (prz->vaddr) {\n\t\tif (pfn_valid(prz->paddr >> PAGE_SHIFT)) {\n\t\t\t \n\t\t\tvunmap(prz->vaddr - offset_in_page(prz->paddr));\n\t\t} else {\n\t\t\tiounmap(prz->vaddr);\n\t\t\trelease_mem_region(prz->paddr, prz->size);\n\t\t}\n\t\tprz->vaddr = NULL;\n\t}\n\tif (prz->rs_decoder) {\n\t\tfree_rs(prz->rs_decoder);\n\t\tprz->rs_decoder = NULL;\n\t}\n\tkfree(prz->ecc_info.par);\n\tprz->ecc_info.par = NULL;\n\n\tpersistent_ram_free_old(prz);\n\tkfree(prz->label);\n\tkfree(prz);\n\t*_prz = NULL;\n}\n\nstruct persistent_ram_zone *persistent_ram_new(phys_addr_t start, size_t size,\n\t\t\tu32 sig, struct persistent_ram_ecc_info *ecc_info,\n\t\t\tunsigned int memtype, u32 flags, char *label)\n{\n\tstruct persistent_ram_zone *prz;\n\tint ret = -ENOMEM;\n\n\tprz = kzalloc(sizeof(struct persistent_ram_zone), GFP_KERNEL);\n\tif (!prz) {\n\t\tpr_err(\"failed to allocate persistent ram zone\\n\");\n\t\tgoto err;\n\t}\n\n\t \n\traw_spin_lock_init(&prz->buffer_lock);\n\tprz->flags = flags;\n\tprz->label = kstrdup(label, GFP_KERNEL);\n\tif (!prz->label)\n\t\tgoto err;\n\n\tret = persistent_ram_buffer_map(start, size, prz, memtype);\n\tif (ret)\n\t\tgoto err;\n\n\tret = persistent_ram_post_init(prz, sig, ecc_info);\n\tif (ret)\n\t\tgoto err;\n\n\tpr_debug(\"attached %s 0x%zx@0x%llx: %zu header, %zu data, %zu ecc (%d/%d)\\n\",\n\t\tprz->label, prz->size, (unsigned long long)prz->paddr,\n\t\tsizeof(*prz->buffer), prz->buffer_size,\n\t\tprz->size - sizeof(*prz->buffer) - prz->buffer_size,\n\t\tprz->ecc_info.ecc_size, prz->ecc_info.block_size);\n\n\treturn prz;\nerr:\n\tpersistent_ram_free(&prz);\n\treturn ERR_PTR(ret);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}