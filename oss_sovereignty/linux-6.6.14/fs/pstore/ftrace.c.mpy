{
  "module_name": "ftrace.c",
  "hash_id": "4031842120cd4cbed955b609832b1f87c18fb64c9647d505f7272fcb93a4850b",
  "original_prompt": "Ingested from linux-6.6.14/fs/pstore/ftrace.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/irqflags.h>\n#include <linux/percpu.h>\n#include <linux/smp.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/ftrace.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/cache.h>\n#include <linux/slab.h>\n#include <asm/barrier.h>\n#include \"internal.h\"\n\n \nstatic u64 pstore_ftrace_stamp;\n\nstatic void notrace pstore_ftrace_call(unsigned long ip,\n\t\t\t\t       unsigned long parent_ip,\n\t\t\t\t       struct ftrace_ops *op,\n\t\t\t\t       struct ftrace_regs *fregs)\n{\n\tint bit;\n\tunsigned long flags;\n\tstruct pstore_ftrace_record rec = {};\n\tstruct pstore_record record = {\n\t\t.type = PSTORE_TYPE_FTRACE,\n\t\t.buf = (char *)&rec,\n\t\t.size = sizeof(rec),\n\t\t.psi = psinfo,\n\t};\n\n\tif (unlikely(oops_in_progress))\n\t\treturn;\n\n\tbit = ftrace_test_recursion_trylock(ip, parent_ip);\n\tif (bit < 0)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\n\trec.ip = ip;\n\trec.parent_ip = parent_ip;\n\tpstore_ftrace_write_timestamp(&rec, pstore_ftrace_stamp++);\n\tpstore_ftrace_encode_cpu(&rec, raw_smp_processor_id());\n\tpsinfo->write(&record);\n\n\tlocal_irq_restore(flags);\n\tftrace_test_recursion_unlock(bit);\n}\n\nstatic struct ftrace_ops pstore_ftrace_ops __read_mostly = {\n\t.func\t= pstore_ftrace_call,\n};\n\nstatic DEFINE_MUTEX(pstore_ftrace_lock);\nstatic bool pstore_ftrace_enabled;\n\nstatic int pstore_set_ftrace_enabled(bool on)\n{\n\tssize_t ret;\n\n\tif (on == pstore_ftrace_enabled)\n\t\treturn 0;\n\n\tif (on) {\n\t\tftrace_ops_set_global_filter(&pstore_ftrace_ops);\n\t\tret = register_ftrace_function(&pstore_ftrace_ops);\n\t} else {\n\t\tret = unregister_ftrace_function(&pstore_ftrace_ops);\n\t}\n\n\tif (ret) {\n\t\tpr_err(\"%s: unable to %sregister ftrace ops: %zd\\n\",\n\t\t       __func__, on ? \"\" : \"un\", ret);\n\t} else {\n\t\tpstore_ftrace_enabled = on;\n\t}\n\n\treturn ret;\n}\n\nstatic ssize_t pstore_ftrace_knob_write(struct file *f, const char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tu8 on;\n\tssize_t ret;\n\n\tret = kstrtou8_from_user(buf, count, 2, &on);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&pstore_ftrace_lock);\n\tret = pstore_set_ftrace_enabled(on);\n\tmutex_unlock(&pstore_ftrace_lock);\n\n\tif (ret == 0)\n\t\tret = count;\n\n\treturn ret;\n}\n\nstatic ssize_t pstore_ftrace_knob_read(struct file *f, char __user *buf,\n\t\t\t\t       size_t count, loff_t *ppos)\n{\n\tchar val[] = { '0' + pstore_ftrace_enabled, '\\n' };\n\n\treturn simple_read_from_buffer(buf, count, ppos, val, sizeof(val));\n}\n\nstatic const struct file_operations pstore_knob_fops = {\n\t.open\t= simple_open,\n\t.read\t= pstore_ftrace_knob_read,\n\t.write\t= pstore_ftrace_knob_write,\n};\n\nstatic struct dentry *pstore_ftrace_dir;\n\nstatic bool record_ftrace;\nmodule_param(record_ftrace, bool, 0400);\nMODULE_PARM_DESC(record_ftrace,\n\t\t \"enable ftrace recording immediately (default: off)\");\n\nvoid pstore_register_ftrace(void)\n{\n\tif (!psinfo->write)\n\t\treturn;\n\n\tpstore_ftrace_dir = debugfs_create_dir(\"pstore\", NULL);\n\n\tpstore_set_ftrace_enabled(record_ftrace);\n\n\tdebugfs_create_file(\"record_ftrace\", 0600, pstore_ftrace_dir, NULL,\n\t\t\t    &pstore_knob_fops);\n}\n\nvoid pstore_unregister_ftrace(void)\n{\n\tmutex_lock(&pstore_ftrace_lock);\n\tif (pstore_ftrace_enabled) {\n\t\tunregister_ftrace_function(&pstore_ftrace_ops);\n\t\tpstore_ftrace_enabled = false;\n\t}\n\tmutex_unlock(&pstore_ftrace_lock);\n\n\tdebugfs_remove_recursive(pstore_ftrace_dir);\n}\n\nssize_t pstore_ftrace_combine_log(char **dest_log, size_t *dest_log_size,\n\t\t\t\t  const char *src_log, size_t src_log_size)\n{\n\tsize_t dest_size, src_size, total, dest_off, src_off;\n\tsize_t dest_idx = 0, src_idx = 0, merged_idx = 0;\n\tvoid *merged_buf;\n\tstruct pstore_ftrace_record *drec, *srec, *mrec;\n\tsize_t record_size = sizeof(struct pstore_ftrace_record);\n\n\tdest_off = *dest_log_size % record_size;\n\tdest_size = *dest_log_size - dest_off;\n\n\tsrc_off = src_log_size % record_size;\n\tsrc_size = src_log_size - src_off;\n\n\ttotal = dest_size + src_size;\n\tmerged_buf = kmalloc(total, GFP_KERNEL);\n\tif (!merged_buf)\n\t\treturn -ENOMEM;\n\n\tdrec = (struct pstore_ftrace_record *)(*dest_log + dest_off);\n\tsrec = (struct pstore_ftrace_record *)(src_log + src_off);\n\tmrec = (struct pstore_ftrace_record *)(merged_buf);\n\n\twhile (dest_size > 0 && src_size > 0) {\n\t\tif (pstore_ftrace_read_timestamp(&drec[dest_idx]) <\n\t\t    pstore_ftrace_read_timestamp(&srec[src_idx])) {\n\t\t\tmrec[merged_idx++] = drec[dest_idx++];\n\t\t\tdest_size -= record_size;\n\t\t} else {\n\t\t\tmrec[merged_idx++] = srec[src_idx++];\n\t\t\tsrc_size -= record_size;\n\t\t}\n\t}\n\n\twhile (dest_size > 0) {\n\t\tmrec[merged_idx++] = drec[dest_idx++];\n\t\tdest_size -= record_size;\n\t}\n\n\twhile (src_size > 0) {\n\t\tmrec[merged_idx++] = srec[src_idx++];\n\t\tsrc_size -= record_size;\n\t}\n\n\tkfree(*dest_log);\n\t*dest_log = merged_buf;\n\t*dest_log_size = total;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(pstore_ftrace_combine_log);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}