{
  "module_name": "endian.h",
  "hash_id": "ad97d2c2524000853d8279ea5eed726de9dfccd103c2c58468be19b9114bffe6",
  "original_prompt": "Ingested from linux-6.6.14/fs/befs/endian.h",
  "human_readable_source": " \n \n\n#ifndef LINUX_BEFS_ENDIAN\n#define LINUX_BEFS_ENDIAN\n\n#include <asm/byteorder.h>\n\nstatic inline u64\nfs64_to_cpu(const struct super_block *sb, fs64 n)\n{\n\tif (BEFS_SB(sb)->byte_order == BEFS_BYTESEX_LE)\n\t\treturn le64_to_cpu((__force __le64)n);\n\telse\n\t\treturn be64_to_cpu((__force __be64)n);\n}\n\nstatic inline fs64\ncpu_to_fs64(const struct super_block *sb, u64 n)\n{\n\tif (BEFS_SB(sb)->byte_order == BEFS_BYTESEX_LE)\n\t\treturn (__force fs64)cpu_to_le64(n);\n\telse\n\t\treturn (__force fs64)cpu_to_be64(n);\n}\n\nstatic inline u32\nfs32_to_cpu(const struct super_block *sb, fs32 n)\n{\n\tif (BEFS_SB(sb)->byte_order == BEFS_BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}\n\nstatic inline fs32\ncpu_to_fs32(const struct super_block *sb, u32 n)\n{\n\tif (BEFS_SB(sb)->byte_order == BEFS_BYTESEX_LE)\n\t\treturn (__force fs32)cpu_to_le32(n);\n\telse\n\t\treturn (__force fs32)cpu_to_be32(n);\n}\n\nstatic inline u16\nfs16_to_cpu(const struct super_block *sb, fs16 n)\n{\n\tif (BEFS_SB(sb)->byte_order == BEFS_BYTESEX_LE)\n\t\treturn le16_to_cpu((__force __le16)n);\n\telse\n\t\treturn be16_to_cpu((__force __be16)n);\n}\n\nstatic inline fs16\ncpu_to_fs16(const struct super_block *sb, u16 n)\n{\n\tif (BEFS_SB(sb)->byte_order == BEFS_BYTESEX_LE)\n\t\treturn (__force fs16)cpu_to_le16(n);\n\telse\n\t\treturn (__force fs16)cpu_to_be16(n);\n}\n\n \n\nstatic inline befs_block_run\nfsrun_to_cpu(const struct super_block *sb, befs_disk_block_run n)\n{\n\tbefs_block_run run;\n\n\tif (BEFS_SB(sb)->byte_order == BEFS_BYTESEX_LE) {\n\t\trun.allocation_group = le32_to_cpu((__force __le32)n.allocation_group);\n\t\trun.start = le16_to_cpu((__force __le16)n.start);\n\t\trun.len = le16_to_cpu((__force __le16)n.len);\n\t} else {\n\t\trun.allocation_group = be32_to_cpu((__force __be32)n.allocation_group);\n\t\trun.start = be16_to_cpu((__force __be16)n.start);\n\t\trun.len = be16_to_cpu((__force __be16)n.len);\n\t}\n\treturn run;\n}\n\nstatic inline befs_disk_block_run\ncpu_to_fsrun(const struct super_block *sb, befs_block_run n)\n{\n\tbefs_disk_block_run run;\n\n\tif (BEFS_SB(sb)->byte_order == BEFS_BYTESEX_LE) {\n\t\trun.allocation_group = cpu_to_le32(n.allocation_group);\n\t\trun.start = cpu_to_le16(n.start);\n\t\trun.len = cpu_to_le16(n.len);\n\t} else {\n\t\trun.allocation_group = cpu_to_be32(n.allocation_group);\n\t\trun.start = cpu_to_be16(n.start);\n\t\trun.len = cpu_to_be16(n.len);\n\t}\n\treturn run;\n}\n\nstatic inline befs_data_stream\nfsds_to_cpu(const struct super_block *sb, const befs_disk_data_stream *n)\n{\n\tbefs_data_stream data;\n\tint i;\n\n\tfor (i = 0; i < BEFS_NUM_DIRECT_BLOCKS; ++i)\n\t\tdata.direct[i] = fsrun_to_cpu(sb, n->direct[i]);\n\n\tdata.max_direct_range = fs64_to_cpu(sb, n->max_direct_range);\n\tdata.indirect = fsrun_to_cpu(sb, n->indirect);\n\tdata.max_indirect_range = fs64_to_cpu(sb, n->max_indirect_range);\n\tdata.double_indirect = fsrun_to_cpu(sb, n->double_indirect);\n\tdata.max_double_indirect_range = fs64_to_cpu(sb,\n\t\t\t\t\t\t     n->\n\t\t\t\t\t\t     max_double_indirect_range);\n\tdata.size = fs64_to_cpu(sb, n->size);\n\n\treturn data;\n}\n\n#endif\t\t\t\t\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}