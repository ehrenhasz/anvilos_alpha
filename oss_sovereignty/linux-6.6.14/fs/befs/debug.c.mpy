{
  "module_name": "debug.c",
  "hash_id": "e1b5c4a78ae52d2e69dbeb6c499a63e76360e09876e33e12c6ffa7e62da8bdc3",
  "original_prompt": "Ingested from linux-6.6.14/fs/befs/debug.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#ifdef __KERNEL__\n\n#include <linux/stdarg.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n\n#endif\t\t\t\t \n\n#include \"befs.h\"\n\nvoid\nbefs_error(const struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_err(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n}\n\nvoid\nbefs_warning(const struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n}\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t\n}\n\nvoid\nbefs_dump_inode(const struct super_block *sb, befs_inode *inode)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tbefs_block_run tmp_run;\n\n\tbefs_debug(sb, \"befs_inode information\");\n\n\tbefs_debug(sb, \"  magic1 %08x\", fs32_to_cpu(sb, inode->magic1));\n\n\ttmp_run = fsrun_to_cpu(sb, inode->inode_num);\n\tbefs_debug(sb, \"  inode_num %u, %hu, %hu\",\n\t\t   tmp_run.allocation_group, tmp_run.start, tmp_run.len);\n\n\tbefs_debug(sb, \"  uid %u\", fs32_to_cpu(sb, inode->uid));\n\tbefs_debug(sb, \"  gid %u\", fs32_to_cpu(sb, inode->gid));\n\tbefs_debug(sb, \"  mode %08x\", fs32_to_cpu(sb, inode->mode));\n\tbefs_debug(sb, \"  flags %08x\", fs32_to_cpu(sb, inode->flags));\n\tbefs_debug(sb, \"  create_time %llu\",\n\t\t   fs64_to_cpu(sb, inode->create_time));\n\tbefs_debug(sb, \"  last_modified_time %llu\",\n\t\t   fs64_to_cpu(sb, inode->last_modified_time));\n\n\ttmp_run = fsrun_to_cpu(sb, inode->parent);\n\tbefs_debug(sb, \"  parent [%u, %hu, %hu]\",\n\t\t   tmp_run.allocation_group, tmp_run.start, tmp_run.len);\n\n\ttmp_run = fsrun_to_cpu(sb, inode->attributes);\n\tbefs_debug(sb, \"  attributes [%u, %hu, %hu]\",\n\t\t   tmp_run.allocation_group, tmp_run.start, tmp_run.len);\n\n\tbefs_debug(sb, \"  type %08x\", fs32_to_cpu(sb, inode->type));\n\tbefs_debug(sb, \"  inode_size %u\", fs32_to_cpu(sb, inode->inode_size));\n\n\tif (S_ISLNK(fs32_to_cpu(sb, inode->mode))) {\n\t\tbefs_debug(sb, \"  Symbolic link [%s]\", inode->data.symlink);\n\t} else {\n\t\tint i;\n\n\t\tfor (i = 0; i < BEFS_NUM_DIRECT_BLOCKS; i++) {\n\t\t\ttmp_run =\n\t\t\t    fsrun_to_cpu(sb, inode->data.datastream.direct[i]);\n\t\t\tbefs_debug(sb, \"  direct %d [%u, %hu, %hu]\", i,\n\t\t\t\t   tmp_run.allocation_group, tmp_run.start,\n\t\t\t\t   tmp_run.len);\n\t\t}\n\t\tbefs_debug(sb, \"  max_direct_range %llu\",\n\t\t\t   fs64_to_cpu(sb,\n\t\t\t\t       inode->data.datastream.\n\t\t\t\t       max_direct_range));\n\n\t\ttmp_run = fsrun_to_cpu(sb, inode->data.datastream.indirect);\n\t\tbefs_debug(sb, \"  indirect [%u, %hu, %hu]\",\n\t\t\t   tmp_run.allocation_group,\n\t\t\t   tmp_run.start, tmp_run.len);\n\n\t\tbefs_debug(sb, \"  max_indirect_range %llu\",\n\t\t\t   fs64_to_cpu(sb,\n\t\t\t\t       inode->data.datastream.\n\t\t\t\t       max_indirect_range));\n\n\t\ttmp_run =\n\t\t    fsrun_to_cpu(sb, inode->data.datastream.double_indirect);\n\t\tbefs_debug(sb, \"  double indirect [%u, %hu, %hu]\",\n\t\t\t   tmp_run.allocation_group, tmp_run.start,\n\t\t\t   tmp_run.len);\n\n\t\tbefs_debug(sb, \"  max_double_indirect_range %llu\",\n\t\t\t   fs64_to_cpu(sb,\n\t\t\t\t       inode->data.datastream.\n\t\t\t\t       max_double_indirect_range));\n\n\t\tbefs_debug(sb, \"  size %llu\",\n\t\t\t   fs64_to_cpu(sb, inode->data.datastream.size));\n\t}\n\n#endif\t\t\t\t\n}\n\n \n\nvoid\nbefs_dump_super_block(const struct super_block *sb, befs_super_block *sup)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tbefs_block_run tmp_run;\n\n\tbefs_debug(sb, \"befs_super_block information\");\n\n\tbefs_debug(sb, \"  name %s\", sup->name);\n\tbefs_debug(sb, \"  magic1 %08x\", fs32_to_cpu(sb, sup->magic1));\n\tbefs_debug(sb, \"  fs_byte_order %08x\",\n\t\t   fs32_to_cpu(sb, sup->fs_byte_order));\n\n\tbefs_debug(sb, \"  block_size %u\", fs32_to_cpu(sb, sup->block_size));\n\tbefs_debug(sb, \"  block_shift %u\", fs32_to_cpu(sb, sup->block_shift));\n\n\tbefs_debug(sb, \"  num_blocks %llu\", fs64_to_cpu(sb, sup->num_blocks));\n\tbefs_debug(sb, \"  used_blocks %llu\", fs64_to_cpu(sb, sup->used_blocks));\n\tbefs_debug(sb, \"  inode_size %u\", fs32_to_cpu(sb, sup->inode_size));\n\n\tbefs_debug(sb, \"  magic2 %08x\", fs32_to_cpu(sb, sup->magic2));\n\tbefs_debug(sb, \"  blocks_per_ag %u\",\n\t\t   fs32_to_cpu(sb, sup->blocks_per_ag));\n\tbefs_debug(sb, \"  ag_shift %u\", fs32_to_cpu(sb, sup->ag_shift));\n\tbefs_debug(sb, \"  num_ags %u\", fs32_to_cpu(sb, sup->num_ags));\n\n\tbefs_debug(sb, \"  flags %08x\", fs32_to_cpu(sb, sup->flags));\n\n\ttmp_run = fsrun_to_cpu(sb, sup->log_blocks);\n\tbefs_debug(sb, \"  log_blocks %u, %hu, %hu\",\n\t\t   tmp_run.allocation_group, tmp_run.start, tmp_run.len);\n\n\tbefs_debug(sb, \"  log_start %lld\", fs64_to_cpu(sb, sup->log_start));\n\tbefs_debug(sb, \"  log_end %lld\", fs64_to_cpu(sb, sup->log_end));\n\n\tbefs_debug(sb, \"  magic3 %08x\", fs32_to_cpu(sb, sup->magic3));\n\n\ttmp_run = fsrun_to_cpu(sb, sup->root_dir);\n\tbefs_debug(sb, \"  root_dir %u, %hu, %hu\",\n\t\t   tmp_run.allocation_group, tmp_run.start, tmp_run.len);\n\n\ttmp_run = fsrun_to_cpu(sb, sup->indices);\n\tbefs_debug(sb, \"  indices %u, %hu, %hu\",\n\t\t   tmp_run.allocation_group, tmp_run.start, tmp_run.len);\n\n#endif\t\t\t\t\n}\n\n#if 0\n \nvoid\nbefs_dump_small_data(const struct super_block *sb, befs_small_data *sd)\n{\n}\n\n \nvoid\nbefs_dump_run(const struct super_block *sb, befs_disk_block_run run)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tbefs_block_run n = fsrun_to_cpu(sb, run);\n\n\tbefs_debug(sb, \"[%u, %hu, %hu]\", n.allocation_group, n.start, n.len);\n\n#endif\t\t\t\t\n}\n#endif   \n\nvoid\nbefs_dump_index_entry(const struct super_block *sb,\n\t\t      befs_disk_btree_super *super)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tbefs_debug(sb, \"Btree super structure\");\n\tbefs_debug(sb, \"  magic %08x\", fs32_to_cpu(sb, super->magic));\n\tbefs_debug(sb, \"  node_size %u\", fs32_to_cpu(sb, super->node_size));\n\tbefs_debug(sb, \"  max_depth %08x\", fs32_to_cpu(sb, super->max_depth));\n\n\tbefs_debug(sb, \"  data_type %08x\", fs32_to_cpu(sb, super->data_type));\n\tbefs_debug(sb, \"  root_node_pointer %016LX\",\n\t\t   fs64_to_cpu(sb, super->root_node_ptr));\n\tbefs_debug(sb, \"  free_node_pointer %016LX\",\n\t\t   fs64_to_cpu(sb, super->free_node_ptr));\n\tbefs_debug(sb, \"  maximum size %016LX\",\n\t\t   fs64_to_cpu(sb, super->max_size));\n\n#endif\t\t\t\t\n}\n\nvoid\nbefs_dump_index_node(const struct super_block *sb, befs_btree_nodehead *node)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tbefs_debug(sb, \"Btree node structure\");\n\tbefs_debug(sb, \"  left %016LX\", fs64_to_cpu(sb, node->left));\n\tbefs_debug(sb, \"  right %016LX\", fs64_to_cpu(sb, node->right));\n\tbefs_debug(sb, \"  overflow %016LX\", fs64_to_cpu(sb, node->overflow));\n\tbefs_debug(sb, \"  all_key_count %hu\",\n\t\t   fs16_to_cpu(sb, node->all_key_count));\n\tbefs_debug(sb, \"  all_key_length %hu\",\n\t\t   fs16_to_cpu(sb, node->all_key_length));\n\n#endif\t\t\t\t\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}