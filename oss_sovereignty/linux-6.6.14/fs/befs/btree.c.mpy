{
  "module_name": "btree.c",
  "hash_id": "dd63fcf29f85ff3e3b58234004a7cce0d616c29e9d4c4a12bd84ee0627718017",
  "original_prompt": "Ingested from linux-6.6.14/fs/befs/btree.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n\n#include \"befs.h\"\n#include \"btree.h\"\n#include \"datastream.h\"\n\n \n\n \n\n \n\n \n\n \nstruct befs_btree_node {\n\tbefs_host_btree_nodehead head;\t \n\tstruct buffer_head *bh;\n\tbefs_btree_nodehead *od_node;\t \n};\n\n \nstatic const befs_off_t BEFS_BT_INVAL = 0xffffffffffffffffULL;\n\n \nstatic int befs_btree_seekleaf(struct super_block *sb, const befs_data_stream *ds,\n\t\t\t       befs_btree_super * bt_super,\n\t\t\t       struct befs_btree_node *this_node,\n\t\t\t       befs_off_t * node_off);\n\nstatic int befs_bt_read_super(struct super_block *sb, const befs_data_stream *ds,\n\t\t\t      befs_btree_super * sup);\n\nstatic int befs_bt_read_node(struct super_block *sb, const befs_data_stream *ds,\n\t\t\t     struct befs_btree_node *node,\n\t\t\t     befs_off_t node_off);\n\nstatic int befs_leafnode(struct befs_btree_node *node);\n\nstatic fs16 *befs_bt_keylen_index(struct befs_btree_node *node);\n\nstatic fs64 *befs_bt_valarray(struct befs_btree_node *node);\n\nstatic char *befs_bt_keydata(struct befs_btree_node *node);\n\nstatic int befs_find_key(struct super_block *sb,\n\t\t\t struct befs_btree_node *node,\n\t\t\t const char *findkey, befs_off_t * value);\n\nstatic char *befs_bt_get_key(struct super_block *sb,\n\t\t\t     struct befs_btree_node *node,\n\t\t\t     int index, u16 * keylen);\n\nstatic int befs_compare_strings(const void *key1, int keylen1,\n\t\t\t\tconst void *key2, int keylen2);\n\n \nstatic int\nbefs_bt_read_super(struct super_block *sb, const befs_data_stream *ds,\n\t\t   befs_btree_super * sup)\n{\n\tstruct buffer_head *bh;\n\tbefs_disk_btree_super *od_sup;\n\n\tbefs_debug(sb, \"---> %s\", __func__);\n\n\tbh = befs_read_datastream(sb, ds, 0, NULL);\n\n\tif (!bh) {\n\t\tbefs_error(sb, \"Couldn't read index header.\");\n\t\tgoto error;\n\t}\n\tod_sup = (befs_disk_btree_super *) bh->b_data;\n\tbefs_dump_index_entry(sb, od_sup);\n\n\tsup->magic = fs32_to_cpu(sb, od_sup->magic);\n\tsup->node_size = fs32_to_cpu(sb, od_sup->node_size);\n\tsup->max_depth = fs32_to_cpu(sb, od_sup->max_depth);\n\tsup->data_type = fs32_to_cpu(sb, od_sup->data_type);\n\tsup->root_node_ptr = fs64_to_cpu(sb, od_sup->root_node_ptr);\n\n\tbrelse(bh);\n\tif (sup->magic != BEFS_BTREE_MAGIC) {\n\t\tbefs_error(sb, \"Index header has bad magic.\");\n\t\tgoto error;\n\t}\n\n\tbefs_debug(sb, \"<--- %s\", __func__);\n\treturn BEFS_OK;\n\n      error:\n\tbefs_debug(sb, \"<--- %s ERROR\", __func__);\n\treturn BEFS_ERR;\n}\n\n \n\nstatic int\nbefs_bt_read_node(struct super_block *sb, const befs_data_stream *ds,\n\t\t  struct befs_btree_node *node, befs_off_t node_off)\n{\n\tuint off = 0;\n\n\tbefs_debug(sb, \"---> %s\", __func__);\n\n\tif (node->bh)\n\t\tbrelse(node->bh);\n\n\tnode->bh = befs_read_datastream(sb, ds, node_off, &off);\n\tif (!node->bh) {\n\t\tbefs_error(sb, \"%s failed to read \"\n\t\t\t   \"node at %llu\", __func__, node_off);\n\t\tbefs_debug(sb, \"<--- %s ERROR\", __func__);\n\n\t\treturn BEFS_ERR;\n\t}\n\tnode->od_node =\n\t    (befs_btree_nodehead *) ((void *) node->bh->b_data + off);\n\n\tbefs_dump_index_node(sb, node->od_node);\n\n\tnode->head.left = fs64_to_cpu(sb, node->od_node->left);\n\tnode->head.right = fs64_to_cpu(sb, node->od_node->right);\n\tnode->head.overflow = fs64_to_cpu(sb, node->od_node->overflow);\n\tnode->head.all_key_count =\n\t    fs16_to_cpu(sb, node->od_node->all_key_count);\n\tnode->head.all_key_length =\n\t    fs16_to_cpu(sb, node->od_node->all_key_length);\n\n\tbefs_debug(sb, \"<--- %s\", __func__);\n\treturn BEFS_OK;\n}\n\n \nint\nbefs_btree_find(struct super_block *sb, const befs_data_stream *ds,\n\t\tconst char *key, befs_off_t * value)\n{\n\tstruct befs_btree_node *this_node;\n\tbefs_btree_super bt_super;\n\tbefs_off_t node_off;\n\tint res;\n\n\tbefs_debug(sb, \"---> %s Key: %s\", __func__, key);\n\n\tif (befs_bt_read_super(sb, ds, &bt_super) != BEFS_OK) {\n\t\tbefs_error(sb,\n\t\t\t   \"befs_btree_find() failed to read index superblock\");\n\t\tgoto error;\n\t}\n\n\tthis_node = kmalloc(sizeof(struct befs_btree_node),\n\t\t\t\t\t\tGFP_NOFS);\n\tif (!this_node) {\n\t\tbefs_error(sb, \"befs_btree_find() failed to allocate %zu \"\n\t\t\t   \"bytes of memory\", sizeof(struct befs_btree_node));\n\t\tgoto error;\n\t}\n\n\tthis_node->bh = NULL;\n\n\t \n\tnode_off = bt_super.root_node_ptr;\n\tif (befs_bt_read_node(sb, ds, this_node, node_off) != BEFS_OK) {\n\t\tbefs_error(sb, \"befs_btree_find() failed to read \"\n\t\t\t   \"node at %llu\", node_off);\n\t\tgoto error_alloc;\n\t}\n\n\twhile (!befs_leafnode(this_node)) {\n\t\tres = befs_find_key(sb, this_node, key, &node_off);\n\t\t \n\t\tif (res == BEFS_BT_OVERFLOW)\n\t\t\tnode_off = this_node->head.overflow;\n\t\tif (befs_bt_read_node(sb, ds, this_node, node_off) != BEFS_OK) {\n\t\t\tbefs_error(sb, \"befs_btree_find() failed to read \"\n\t\t\t\t   \"node at %llu\", node_off);\n\t\t\tgoto error_alloc;\n\t\t}\n\t}\n\n\t \n\tres = befs_find_key(sb, this_node, key, value);\n\n\tbrelse(this_node->bh);\n\tkfree(this_node);\n\n\tif (res != BEFS_BT_MATCH) {\n\t\tbefs_error(sb, \"<--- %s Key %s not found\", __func__, key);\n\t\tbefs_debug(sb, \"<--- %s ERROR\", __func__);\n\t\t*value = 0;\n\t\treturn BEFS_BT_NOT_FOUND;\n\t}\n\tbefs_debug(sb, \"<--- %s Found key %s, value %llu\", __func__,\n\t\t   key, *value);\n\treturn BEFS_OK;\n\n      error_alloc:\n\tkfree(this_node);\n      error:\n\t*value = 0;\n\tbefs_debug(sb, \"<--- %s ERROR\", __func__);\n\treturn BEFS_ERR;\n}\n\n \nstatic int\nbefs_find_key(struct super_block *sb, struct befs_btree_node *node,\n\t      const char *findkey, befs_off_t * value)\n{\n\tint first, last, mid;\n\tint eq;\n\tu16 keylen;\n\tint findkey_len;\n\tchar *thiskey;\n\tfs64 *valarray;\n\n\tbefs_debug(sb, \"---> %s %s\", __func__, findkey);\n\n\tfindkey_len = strlen(findkey);\n\n\t \n\tlast = node->head.all_key_count - 1;\n\tthiskey = befs_bt_get_key(sb, node, last, &keylen);\n\n\teq = befs_compare_strings(thiskey, keylen, findkey, findkey_len);\n\tif (eq < 0) {\n\t\tbefs_debug(sb, \"<--- node can't contain %s\", findkey);\n\t\treturn BEFS_BT_OVERFLOW;\n\t}\n\n\tvalarray = befs_bt_valarray(node);\n\n\t \n\tfirst = 0;\n\tmid = 0;\n\twhile (last >= first) {\n\t\tmid = (last + first) / 2;\n\t\tbefs_debug(sb, \"first: %d, last: %d, mid: %d\", first, last,\n\t\t\t   mid);\n\t\tthiskey = befs_bt_get_key(sb, node, mid, &keylen);\n\t\teq = befs_compare_strings(thiskey, keylen, findkey,\n\t\t\t\t\t  findkey_len);\n\n\t\tif (eq == 0) {\n\t\t\tbefs_debug(sb, \"<--- %s found %s at %d\",\n\t\t\t\t   __func__, thiskey, mid);\n\n\t\t\t*value = fs64_to_cpu(sb, valarray[mid]);\n\t\t\treturn BEFS_BT_MATCH;\n\t\t}\n\t\tif (eq > 0)\n\t\t\tlast = mid - 1;\n\t\telse\n\t\t\tfirst = mid + 1;\n\t}\n\n\t \n\tif (eq < 0)\n\t\t*value = fs64_to_cpu(sb, valarray[mid + 1]);\n\telse\n\t\t*value = fs64_to_cpu(sb, valarray[mid]);\n\tbefs_error(sb, \"<--- %s %s not found\", __func__, findkey);\n\tbefs_debug(sb, \"<--- %s ERROR\", __func__);\n\treturn BEFS_BT_NOT_FOUND;\n}\n\n \nint\nbefs_btree_read(struct super_block *sb, const befs_data_stream *ds,\n\t\tloff_t key_no, size_t bufsize, char *keybuf, size_t * keysize,\n\t\tbefs_off_t * value)\n{\n\tstruct befs_btree_node *this_node;\n\tbefs_btree_super bt_super;\n\tbefs_off_t node_off;\n\tint cur_key;\n\tfs64 *valarray;\n\tchar *keystart;\n\tu16 keylen;\n\tint res;\n\n\tuint key_sum = 0;\n\n\tbefs_debug(sb, \"---> %s\", __func__);\n\n\tif (befs_bt_read_super(sb, ds, &bt_super) != BEFS_OK) {\n\t\tbefs_error(sb,\n\t\t\t   \"befs_btree_read() failed to read index superblock\");\n\t\tgoto error;\n\t}\n\n\tthis_node = kmalloc(sizeof(struct befs_btree_node), GFP_NOFS);\n\tif (this_node == NULL) {\n\t\tbefs_error(sb, \"befs_btree_read() failed to allocate %zu \"\n\t\t\t   \"bytes of memory\", sizeof(struct befs_btree_node));\n\t\tgoto error;\n\t}\n\n\tnode_off = bt_super.root_node_ptr;\n\tthis_node->bh = NULL;\n\n\t \n\tres = befs_btree_seekleaf(sb, ds, &bt_super, this_node, &node_off);\n\tif (res == BEFS_BT_EMPTY) {\n\t\tbrelse(this_node->bh);\n\t\tkfree(this_node);\n\t\t*value = 0;\n\t\t*keysize = 0;\n\t\tbefs_debug(sb, \"<--- %s Tree is EMPTY\", __func__);\n\t\treturn BEFS_BT_EMPTY;\n\t} else if (res == BEFS_ERR) {\n\t\tgoto error_alloc;\n\t}\n\n\t \n\n\twhile (key_sum + this_node->head.all_key_count <= key_no) {\n\n\t\t \n\t\tif (this_node->head.right == BEFS_BT_INVAL) {\n\t\t\t*keysize = 0;\n\t\t\t*value = 0;\n\t\t\tbefs_debug(sb,\n\t\t\t\t   \"<--- %s END of keys at %llu\", __func__,\n\t\t\t\t   (unsigned long long)\n\t\t\t\t   key_sum + this_node->head.all_key_count);\n\t\t\tbrelse(this_node->bh);\n\t\t\tkfree(this_node);\n\t\t\treturn BEFS_BT_END;\n\t\t}\n\n\t\tkey_sum += this_node->head.all_key_count;\n\t\tnode_off = this_node->head.right;\n\n\t\tif (befs_bt_read_node(sb, ds, this_node, node_off) != BEFS_OK) {\n\t\t\tbefs_error(sb, \"%s failed to read node at %llu\",\n\t\t\t\t  __func__, (unsigned long long)node_off);\n\t\t\tgoto error_alloc;\n\t\t}\n\t}\n\n\t \n\tcur_key = key_no - key_sum;\n\n\t \n\tvalarray = befs_bt_valarray(this_node);\n\n\tkeystart = befs_bt_get_key(sb, this_node, cur_key, &keylen);\n\n\tbefs_debug(sb, \"Read [%llu,%d]: keysize %d\",\n\t\t   (long long unsigned int)node_off, (int)cur_key,\n\t\t   (int)keylen);\n\n\tif (bufsize < keylen + 1) {\n\t\tbefs_error(sb, \"%s keybuf too small (%zu) \"\n\t\t\t   \"for key of size %d\", __func__, bufsize, keylen);\n\t\tbrelse(this_node->bh);\n\t\tgoto error_alloc;\n\t}\n\n\tstrscpy(keybuf, keystart, keylen + 1);\n\t*value = fs64_to_cpu(sb, valarray[cur_key]);\n\t*keysize = keylen;\n\n\tbefs_debug(sb, \"Read [%llu,%d]: Key \\\"%.*s\\\", Value %llu\", node_off,\n\t\t   cur_key, keylen, keybuf, *value);\n\n\tbrelse(this_node->bh);\n\tkfree(this_node);\n\n\tbefs_debug(sb, \"<--- %s\", __func__);\n\n\treturn BEFS_OK;\n\n      error_alloc:\n\tkfree(this_node);\n\n      error:\n\t*keysize = 0;\n\t*value = 0;\n\tbefs_debug(sb, \"<--- %s ERROR\", __func__);\n\treturn BEFS_ERR;\n}\n\n \nstatic int\nbefs_btree_seekleaf(struct super_block *sb, const befs_data_stream *ds,\n\t\t    befs_btree_super *bt_super,\n\t\t    struct befs_btree_node *this_node,\n\t\t    befs_off_t * node_off)\n{\n\n\tbefs_debug(sb, \"---> %s\", __func__);\n\n\tif (befs_bt_read_node(sb, ds, this_node, *node_off) != BEFS_OK) {\n\t\tbefs_error(sb, \"%s failed to read \"\n\t\t\t   \"node at %llu\", __func__, *node_off);\n\t\tgoto error;\n\t}\n\tbefs_debug(sb, \"Seekleaf to root node %llu\", *node_off);\n\n\tif (this_node->head.all_key_count == 0 && befs_leafnode(this_node)) {\n\t\tbefs_debug(sb, \"<--- %s Tree is EMPTY\", __func__);\n\t\treturn BEFS_BT_EMPTY;\n\t}\n\n\twhile (!befs_leafnode(this_node)) {\n\n\t\tif (this_node->head.all_key_count == 0) {\n\t\t\tbefs_debug(sb, \"%s encountered \"\n\t\t\t\t   \"an empty interior node: %llu. Using Overflow \"\n\t\t\t\t   \"node: %llu\", __func__, *node_off,\n\t\t\t\t   this_node->head.overflow);\n\t\t\t*node_off = this_node->head.overflow;\n\t\t} else {\n\t\t\tfs64 *valarray = befs_bt_valarray(this_node);\n\t\t\t*node_off = fs64_to_cpu(sb, valarray[0]);\n\t\t}\n\t\tif (befs_bt_read_node(sb, ds, this_node, *node_off) != BEFS_OK) {\n\t\t\tbefs_error(sb, \"%s failed to read \"\n\t\t\t\t   \"node at %llu\", __func__, *node_off);\n\t\t\tgoto error;\n\t\t}\n\n\t\tbefs_debug(sb, \"Seekleaf to child node %llu\", *node_off);\n\t}\n\tbefs_debug(sb, \"Node %llu is a leaf node\", *node_off);\n\n\treturn BEFS_OK;\n\n      error:\n\tbefs_debug(sb, \"<--- %s ERROR\", __func__);\n\treturn BEFS_ERR;\n}\n\n \nstatic int\nbefs_leafnode(struct befs_btree_node *node)\n{\n\t \n\tif (node->head.overflow == BEFS_BT_INVAL)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\n \nstatic fs16 *\nbefs_bt_keylen_index(struct befs_btree_node *node)\n{\n\tconst int keylen_align = 8;\n\tunsigned long int off =\n\t    (sizeof (befs_btree_nodehead) + node->head.all_key_length);\n\tulong tmp = off % keylen_align;\n\n\tif (tmp)\n\t\toff += keylen_align - tmp;\n\n\treturn (fs16 *) ((void *) node->od_node + off);\n}\n\n \nstatic fs64 *\nbefs_bt_valarray(struct befs_btree_node *node)\n{\n\tvoid *keylen_index_start = (void *) befs_bt_keylen_index(node);\n\tsize_t keylen_index_size = node->head.all_key_count * sizeof (fs16);\n\n\treturn (fs64 *) (keylen_index_start + keylen_index_size);\n}\n\n \nstatic char *\nbefs_bt_keydata(struct befs_btree_node *node)\n{\n\treturn (char *) ((void *) node->od_node + sizeof (befs_btree_nodehead));\n}\n\n \nstatic char *\nbefs_bt_get_key(struct super_block *sb, struct befs_btree_node *node,\n\t\tint index, u16 * keylen)\n{\n\tint prev_key_end;\n\tchar *keystart;\n\tfs16 *keylen_index;\n\n\tif (index < 0 || index > node->head.all_key_count) {\n\t\t*keylen = 0;\n\t\treturn NULL;\n\t}\n\n\tkeystart = befs_bt_keydata(node);\n\tkeylen_index = befs_bt_keylen_index(node);\n\n\tif (index == 0)\n\t\tprev_key_end = 0;\n\telse\n\t\tprev_key_end = fs16_to_cpu(sb, keylen_index[index - 1]);\n\n\t*keylen = fs16_to_cpu(sb, keylen_index[index]) - prev_key_end;\n\n\treturn keystart + prev_key_end;\n}\n\n \nstatic int\nbefs_compare_strings(const void *key1, int keylen1,\n\t\t     const void *key2, int keylen2)\n{\n\tint len = min_t(int, keylen1, keylen2);\n\tint result = strncmp(key1, key2, len);\n\tif (result == 0)\n\t\tresult = keylen1 - keylen2;\n\treturn result;\n}\n\n \n#if 0\nstatic int\nbtree_compare_int32(cont void *key1, int keylen1, const void *key2, int keylen2)\n{\n\treturn *(int32_t *) key1 - *(int32_t *) key2;\n}\n\nstatic int\nbtree_compare_uint32(cont void *key1, int keylen1,\n\t\t     const void *key2, int keylen2)\n{\n\tif (*(u_int32_t *) key1 == *(u_int32_t *) key2)\n\t\treturn 0;\n\telse if (*(u_int32_t *) key1 > *(u_int32_t *) key2)\n\t\treturn 1;\n\n\treturn -1;\n}\nstatic int\nbtree_compare_int64(cont void *key1, int keylen1, const void *key2, int keylen2)\n{\n\tif (*(int64_t *) key1 == *(int64_t *) key2)\n\t\treturn 0;\n\telse if (*(int64_t *) key1 > *(int64_t *) key2)\n\t\treturn 1;\n\n\treturn -1;\n}\n\nstatic int\nbtree_compare_uint64(cont void *key1, int keylen1,\n\t\t     const void *key2, int keylen2)\n{\n\tif (*(u_int64_t *) key1 == *(u_int64_t *) key2)\n\t\treturn 0;\n\telse if (*(u_int64_t *) key1 > *(u_int64_t *) key2)\n\t\treturn 1;\n\n\treturn -1;\n}\n\nstatic int\nbtree_compare_float(cont void *key1, int keylen1, const void *key2, int keylen2)\n{\n\tfloat result = *(float *) key1 - *(float *) key2;\n\tif (result == 0.0f)\n\t\treturn 0;\n\n\treturn (result < 0.0f) ? -1 : 1;\n}\n\nstatic int\nbtree_compare_double(cont void *key1, int keylen1,\n\t\t     const void *key2, int keylen2)\n{\n\tdouble result = *(double *) key1 - *(double *) key2;\n\tif (result == 0.0)\n\t\treturn 0;\n\n\treturn (result < 0.0) ? -1 : 1;\n}\n#endif\t\t\t\t\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}