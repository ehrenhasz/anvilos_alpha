{
  "module_name": "linuxvfs.c",
  "hash_id": "ec7b03643b1700072ef807839c5ea84b863aa123a43c39005df09fcef5ac61a4",
  "original_prompt": "Ingested from linux-6.6.14/fs/befs/linuxvfs.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/nls.h>\n#include <linux/buffer_head.h>\n#include <linux/vfs.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/cred.h>\n#include <linux/exportfs.h>\n#include <linux/seq_file.h>\n#include <linux/blkdev.h>\n\n#include \"befs.h\"\n#include \"btree.h\"\n#include \"inode.h\"\n#include \"datastream.h\"\n#include \"super.h\"\n#include \"io.h\"\n\nMODULE_DESCRIPTION(\"BeOS File System (BeFS) driver\");\nMODULE_AUTHOR(\"Will Dyson\");\nMODULE_LICENSE(\"GPL\");\n\n \n#define VFS_BLOCK_SIZE 512\n\nstatic int befs_readdir(struct file *, struct dir_context *);\nstatic int befs_get_block(struct inode *, sector_t, struct buffer_head *, int);\nstatic int befs_read_folio(struct file *file, struct folio *folio);\nstatic sector_t befs_bmap(struct address_space *mapping, sector_t block);\nstatic struct dentry *befs_lookup(struct inode *, struct dentry *,\n\t\t\t\t  unsigned int);\nstatic struct inode *befs_iget(struct super_block *, unsigned long);\nstatic struct inode *befs_alloc_inode(struct super_block *sb);\nstatic void befs_free_inode(struct inode *inode);\nstatic void befs_destroy_inodecache(void);\nstatic int befs_symlink_read_folio(struct file *, struct folio *);\nstatic int befs_utf2nls(struct super_block *sb, const char *in, int in_len,\n\t\t\tchar **out, int *out_len);\nstatic int befs_nls2utf(struct super_block *sb, const char *in, int in_len,\n\t\t\tchar **out, int *out_len);\nstatic void befs_put_super(struct super_block *);\nstatic int befs_remount(struct super_block *, int *, char *);\nstatic int befs_statfs(struct dentry *, struct kstatfs *);\nstatic int befs_show_options(struct seq_file *, struct dentry *);\nstatic int parse_options(char *, struct befs_mount_options *);\nstatic struct dentry *befs_fh_to_dentry(struct super_block *sb,\n\t\t\t\tstruct fid *fid, int fh_len, int fh_type);\nstatic struct dentry *befs_fh_to_parent(struct super_block *sb,\n\t\t\t\tstruct fid *fid, int fh_len, int fh_type);\nstatic struct dentry *befs_get_parent(struct dentry *child);\n\nstatic const struct super_operations befs_sops = {\n\t.alloc_inode\t= befs_alloc_inode,\t \n\t.free_inode\t= befs_free_inode,  \n\t.put_super\t= befs_put_super,\t \n\t.statfs\t\t= befs_statfs,\t \n\t.remount_fs\t= befs_remount,\n\t.show_options\t= befs_show_options,\n};\n\n \nstatic struct kmem_cache *befs_inode_cachep;\n\nstatic const struct file_operations befs_dir_operations = {\n\t.read\t\t= generic_read_dir,\n\t.iterate_shared\t= befs_readdir,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic const struct inode_operations befs_dir_inode_operations = {\n\t.lookup\t\t= befs_lookup,\n};\n\nstatic const struct address_space_operations befs_aops = {\n\t.read_folio\t= befs_read_folio,\n\t.bmap\t\t= befs_bmap,\n};\n\nstatic const struct address_space_operations befs_symlink_aops = {\n\t.read_folio\t= befs_symlink_read_folio,\n};\n\nstatic const struct export_operations befs_export_operations = {\n\t.fh_to_dentry\t= befs_fh_to_dentry,\n\t.fh_to_parent\t= befs_fh_to_parent,\n\t.get_parent\t= befs_get_parent,\n};\n\n \nstatic int befs_read_folio(struct file *file, struct folio *folio)\n{\n\treturn block_read_full_folio(folio, befs_get_block);\n}\n\nstatic sector_t\nbefs_bmap(struct address_space *mapping, sector_t block)\n{\n\treturn generic_block_bmap(mapping, block, befs_get_block);\n}\n\n \n\nstatic int\nbefs_get_block(struct inode *inode, sector_t block,\n\t       struct buffer_head *bh_result, int create)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tbefs_data_stream *ds = &BEFS_I(inode)->i_data.ds;\n\tbefs_block_run run = BAD_IADDR;\n\tint res;\n\tulong disk_off;\n\n\tbefs_debug(sb, \"---> befs_get_block() for inode %lu, block %ld\",\n\t\t   (unsigned long)inode->i_ino, (long)block);\n\tif (create) {\n\t\tbefs_error(sb, \"befs_get_block() was asked to write to \"\n\t\t\t   \"block %ld in inode %lu\", (long)block,\n\t\t\t   (unsigned long)inode->i_ino);\n\t\treturn -EPERM;\n\t}\n\n\tres = befs_fblock2brun(sb, ds, block, &run);\n\tif (res != BEFS_OK) {\n\t\tbefs_error(sb,\n\t\t\t   \"<--- %s for inode %lu, block %ld ERROR\",\n\t\t\t   __func__, (unsigned long)inode->i_ino,\n\t\t\t   (long)block);\n\t\treturn -EFBIG;\n\t}\n\n\tdisk_off = (ulong) iaddr2blockno(sb, &run);\n\n\tmap_bh(bh_result, inode->i_sb, disk_off);\n\n\tbefs_debug(sb, \"<--- %s for inode %lu, block %ld, disk address %lu\",\n\t\t  __func__, (unsigned long)inode->i_ino, (long)block,\n\t\t  (unsigned long)disk_off);\n\n\treturn 0;\n}\n\nstatic struct dentry *\nbefs_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags)\n{\n\tstruct inode *inode;\n\tstruct super_block *sb = dir->i_sb;\n\tconst befs_data_stream *ds = &BEFS_I(dir)->i_data.ds;\n\tbefs_off_t offset;\n\tint ret;\n\tint utfnamelen;\n\tchar *utfname;\n\tconst char *name = dentry->d_name.name;\n\n\tbefs_debug(sb, \"---> %s name %pd inode %ld\", __func__,\n\t\t   dentry, dir->i_ino);\n\n\t \n\tif (BEFS_SB(sb)->nls) {\n\t\tret =\n\t\t    befs_nls2utf(sb, name, strlen(name), &utfname, &utfnamelen);\n\t\tif (ret < 0) {\n\t\t\tbefs_debug(sb, \"<--- %s ERROR\", __func__);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t\tret = befs_btree_find(sb, ds, utfname, &offset);\n\t\tkfree(utfname);\n\n\t} else {\n\t\tret = befs_btree_find(sb, ds, name, &offset);\n\t}\n\n\tif (ret == BEFS_BT_NOT_FOUND) {\n\t\tbefs_debug(sb, \"<--- %s %pd not found\", __func__, dentry);\n\t\tinode = NULL;\n\t} else if (ret != BEFS_OK || offset == 0) {\n\t\tbefs_error(sb, \"<--- %s Error\", __func__);\n\t\tinode = ERR_PTR(-ENODATA);\n\t} else {\n\t\tinode = befs_iget(dir->i_sb, (ino_t) offset);\n\t}\n\tbefs_debug(sb, \"<--- %s\", __func__);\n\n\treturn d_splice_alias(inode, dentry);\n}\n\nstatic int\nbefs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct super_block *sb = inode->i_sb;\n\tconst befs_data_stream *ds = &BEFS_I(inode)->i_data.ds;\n\tbefs_off_t value;\n\tint result;\n\tsize_t keysize;\n\tchar keybuf[BEFS_NAME_LEN + 1];\n\n\tbefs_debug(sb, \"---> %s name %pD, inode %ld, ctx->pos %lld\",\n\t\t  __func__, file, inode->i_ino, ctx->pos);\n\n\twhile (1) {\n\t\tresult = befs_btree_read(sb, ds, ctx->pos, BEFS_NAME_LEN + 1,\n\t\t\t\t\t keybuf, &keysize, &value);\n\n\t\tif (result == BEFS_ERR) {\n\t\t\tbefs_debug(sb, \"<--- %s ERROR\", __func__);\n\t\t\tbefs_error(sb, \"IO error reading %pD (inode %lu)\",\n\t\t\t\t   file, inode->i_ino);\n\t\t\treturn -EIO;\n\n\t\t} else if (result == BEFS_BT_END) {\n\t\t\tbefs_debug(sb, \"<--- %s END\", __func__);\n\t\t\treturn 0;\n\n\t\t} else if (result == BEFS_BT_EMPTY) {\n\t\t\tbefs_debug(sb, \"<--- %s Empty directory\", __func__);\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tif (BEFS_SB(sb)->nls) {\n\t\t\tchar *nlsname;\n\t\t\tint nlsnamelen;\n\n\t\t\tresult =\n\t\t\t    befs_utf2nls(sb, keybuf, keysize, &nlsname,\n\t\t\t\t\t &nlsnamelen);\n\t\t\tif (result < 0) {\n\t\t\t\tbefs_debug(sb, \"<--- %s ERROR\", __func__);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tif (!dir_emit(ctx, nlsname, nlsnamelen,\n\t\t\t\t      (ino_t) value, DT_UNKNOWN)) {\n\t\t\t\tkfree(nlsname);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tkfree(nlsname);\n\t\t} else {\n\t\t\tif (!dir_emit(ctx, keybuf, keysize,\n\t\t\t\t      (ino_t) value, DT_UNKNOWN))\n\t\t\t\treturn 0;\n\t\t}\n\t\tctx->pos++;\n\t}\n}\n\nstatic struct inode *\nbefs_alloc_inode(struct super_block *sb)\n{\n\tstruct befs_inode_info *bi;\n\n\tbi = alloc_inode_sb(sb, befs_inode_cachep, GFP_KERNEL);\n\tif (!bi)\n\t\treturn NULL;\n\treturn &bi->vfs_inode;\n}\n\nstatic void befs_free_inode(struct inode *inode)\n{\n\tkmem_cache_free(befs_inode_cachep, BEFS_I(inode));\n}\n\nstatic void init_once(void *foo)\n{\n\tstruct befs_inode_info *bi = (struct befs_inode_info *) foo;\n\n\tinode_init_once(&bi->vfs_inode);\n}\n\nstatic struct inode *befs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct buffer_head *bh;\n\tbefs_inode *raw_inode;\n\tstruct befs_sb_info *befs_sb = BEFS_SB(sb);\n\tstruct befs_inode_info *befs_ino;\n\tstruct inode *inode;\n\n\tbefs_debug(sb, \"---> %s inode = %lu\", __func__, ino);\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tbefs_ino = BEFS_I(inode);\n\n\t \n\tbefs_ino->i_inode_num = blockno2iaddr(sb, inode->i_ino);\n\n\tbefs_debug(sb, \"  real inode number [%u, %hu, %hu]\",\n\t\t   befs_ino->i_inode_num.allocation_group,\n\t\t   befs_ino->i_inode_num.start, befs_ino->i_inode_num.len);\n\n\tbh = sb_bread(sb, inode->i_ino);\n\tif (!bh) {\n\t\tbefs_error(sb, \"unable to read inode block - \"\n\t\t\t   \"inode = %lu\", inode->i_ino);\n\t\tgoto unacquire_none;\n\t}\n\n\traw_inode = (befs_inode *) bh->b_data;\n\n\tbefs_dump_inode(sb, raw_inode);\n\n\tif (befs_check_inode(sb, raw_inode, inode->i_ino) != BEFS_OK) {\n\t\tbefs_error(sb, \"Bad inode: %lu\", inode->i_ino);\n\t\tgoto unacquire_bh;\n\t}\n\n\tinode->i_mode = (umode_t) fs32_to_cpu(sb, raw_inode->mode);\n\n\t \n\n\tinode->i_uid = befs_sb->mount_opts.use_uid ?\n\t\tbefs_sb->mount_opts.uid :\n\t\tmake_kuid(&init_user_ns, fs32_to_cpu(sb, raw_inode->uid));\n\tinode->i_gid = befs_sb->mount_opts.use_gid ?\n\t\tbefs_sb->mount_opts.gid :\n\t\tmake_kgid(&init_user_ns, fs32_to_cpu(sb, raw_inode->gid));\n\n\tset_nlink(inode, 1);\n\n\t \n\n\tinode->i_mtime.tv_sec =\n\t    fs64_to_cpu(sb, raw_inode->last_modified_time) >> 16;\n\tinode->i_mtime.tv_nsec = 0;    \n\tinode_set_ctime_to_ts(inode, inode->i_mtime);\n\tinode->i_atime = inode->i_mtime;\n\n\tbefs_ino->i_inode_num = fsrun_to_cpu(sb, raw_inode->inode_num);\n\tbefs_ino->i_parent = fsrun_to_cpu(sb, raw_inode->parent);\n\tbefs_ino->i_attribute = fsrun_to_cpu(sb, raw_inode->attributes);\n\tbefs_ino->i_flags = fs32_to_cpu(sb, raw_inode->flags);\n\n\tif (S_ISLNK(inode->i_mode) && !(befs_ino->i_flags & BEFS_LONG_SYMLINK)){\n\t\tinode->i_size = 0;\n\t\tinode->i_blocks = befs_sb->block_size / VFS_BLOCK_SIZE;\n\t\tstrscpy(befs_ino->i_data.symlink, raw_inode->data.symlink,\n\t\t\tBEFS_SYMLINK_LEN);\n\t} else {\n\t\tint num_blks;\n\n\t\tbefs_ino->i_data.ds =\n\t\t    fsds_to_cpu(sb, &raw_inode->data.datastream);\n\n\t\tnum_blks = befs_count_blocks(sb, &befs_ino->i_data.ds);\n\t\tinode->i_blocks =\n\t\t    num_blks * (befs_sb->block_size / VFS_BLOCK_SIZE);\n\t\tinode->i_size = befs_ino->i_data.ds.size;\n\t}\n\n\tinode->i_mapping->a_ops = &befs_aops;\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_fop = &generic_ro_fops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &befs_dir_inode_operations;\n\t\tinode->i_fop = &befs_dir_operations;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (befs_ino->i_flags & BEFS_LONG_SYMLINK) {\n\t\t\tinode->i_op = &page_symlink_inode_operations;\n\t\t\tinode_nohighmem(inode);\n\t\t\tinode->i_mapping->a_ops = &befs_symlink_aops;\n\t\t} else {\n\t\t\tinode->i_link = befs_ino->i_data.symlink;\n\t\t\tinode->i_op = &simple_symlink_inode_operations;\n\t\t}\n\t} else {\n\t\tbefs_error(sb, \"Inode %lu is not a regular file, \"\n\t\t\t   \"directory or symlink. THAT IS WRONG! BeFS has no \"\n\t\t\t   \"on disk special files\", inode->i_ino);\n\t\tgoto unacquire_bh;\n\t}\n\n\tbrelse(bh);\n\tbefs_debug(sb, \"<--- %s\", __func__);\n\tunlock_new_inode(inode);\n\treturn inode;\n\nunacquire_bh:\n\tbrelse(bh);\n\nunacquire_none:\n\tiget_failed(inode);\n\tbefs_debug(sb, \"<--- %s - Bad inode\", __func__);\n\treturn ERR_PTR(-EIO);\n}\n\n \nstatic int __init\nbefs_init_inodecache(void)\n{\n\tbefs_inode_cachep = kmem_cache_create_usercopy(\"befs_inode_cache\",\n\t\t\t\tsizeof(struct befs_inode_info), 0,\n\t\t\t\t(SLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD|\n\t\t\t\t\tSLAB_ACCOUNT),\n\t\t\t\toffsetof(struct befs_inode_info,\n\t\t\t\t\ti_data.symlink),\n\t\t\t\tsizeof_field(struct befs_inode_info,\n\t\t\t\t\ti_data.symlink),\n\t\t\t\tinit_once);\n\tif (befs_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\n \nstatic void\nbefs_destroy_inodecache(void)\n{\n\t \n\trcu_barrier();\n\tkmem_cache_destroy(befs_inode_cachep);\n}\n\n \nstatic int befs_symlink_read_folio(struct file *unused, struct folio *folio)\n{\n\tstruct inode *inode = folio->mapping->host;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct befs_inode_info *befs_ino = BEFS_I(inode);\n\tbefs_data_stream *data = &befs_ino->i_data.ds;\n\tbefs_off_t len = data->size;\n\tchar *link = folio_address(folio);\n\n\tif (len == 0 || len > PAGE_SIZE) {\n\t\tbefs_error(sb, \"Long symlink with illegal length\");\n\t\tgoto fail;\n\t}\n\tbefs_debug(sb, \"Follow long symlink\");\n\n\tif (befs_read_lsymlink(sb, data, link, len) != len) {\n\t\tbefs_error(sb, \"Failed to read entire long symlink\");\n\t\tgoto fail;\n\t}\n\tlink[len - 1] = '\\0';\n\tfolio_mark_uptodate(folio);\n\tfolio_unlock(folio);\n\treturn 0;\nfail:\n\tfolio_set_error(folio);\n\tfolio_unlock(folio);\n\treturn -EIO;\n}\n\n \nstatic int\nbefs_utf2nls(struct super_block *sb, const char *in,\n\t     int in_len, char **out, int *out_len)\n{\n\tstruct nls_table *nls = BEFS_SB(sb)->nls;\n\tint i, o;\n\tunicode_t uni;\n\tint unilen, utflen;\n\tchar *result;\n\t \n\tint maxlen = in_len + 1;\n\n\tbefs_debug(sb, \"---> %s\", __func__);\n\n\tif (!nls) {\n\t\tbefs_error(sb, \"%s called with no NLS table loaded\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t*out = result = kmalloc(maxlen, GFP_NOFS);\n\tif (!*out)\n\t\treturn -ENOMEM;\n\n\tfor (i = o = 0; i < in_len; i += utflen, o += unilen) {\n\n\t\t \n\t\tutflen = utf8_to_utf32(&in[i], in_len - i, &uni);\n\t\tif (utflen < 0)\n\t\t\tgoto conv_err;\n\n\t\t \n\t\tif (uni > MAX_WCHAR_T)\n\t\t\tgoto conv_err;\n\t\tunilen = nls->uni2char(uni, &result[o], in_len - o);\n\t\tif (unilen < 0)\n\t\t\tgoto conv_err;\n\t}\n\tresult[o] = '\\0';\n\t*out_len = o;\n\n\tbefs_debug(sb, \"<--- %s\", __func__);\n\n\treturn o;\n\nconv_err:\n\tbefs_error(sb, \"Name using character set %s contains a character that \"\n\t\t   \"cannot be converted to unicode.\", nls->charset);\n\tbefs_debug(sb, \"<--- %s\", __func__);\n\tkfree(result);\n\treturn -EILSEQ;\n}\n\n \n\nstatic int\nbefs_nls2utf(struct super_block *sb, const char *in,\n\t     int in_len, char **out, int *out_len)\n{\n\tstruct nls_table *nls = BEFS_SB(sb)->nls;\n\tint i, o;\n\twchar_t uni;\n\tint unilen, utflen;\n\tchar *result;\n\t \n\tint maxlen = (3 * in_len) + 1;\n\n\tbefs_debug(sb, \"---> %s\\n\", __func__);\n\n\tif (!nls) {\n\t\tbefs_error(sb, \"%s called with no NLS table loaded.\",\n\t\t\t   __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t*out = result = kmalloc(maxlen, GFP_NOFS);\n\tif (!*out) {\n\t\t*out_len = 0;\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = o = 0; i < in_len; i += unilen, o += utflen) {\n\n\t\t \n\t\tunilen = nls->char2uni(&in[i], in_len - i, &uni);\n\t\tif (unilen < 0)\n\t\t\tgoto conv_err;\n\n\t\t \n\t\tutflen = utf32_to_utf8(uni, &result[o], 3);\n\t\tif (utflen <= 0)\n\t\t\tgoto conv_err;\n\t}\n\n\tresult[o] = '\\0';\n\t*out_len = o;\n\n\tbefs_debug(sb, \"<--- %s\", __func__);\n\n\treturn i;\n\nconv_err:\n\tbefs_error(sb, \"Name using character set %s contains a character that \"\n\t\t   \"cannot be converted to unicode.\", nls->charset);\n\tbefs_debug(sb, \"<--- %s\", __func__);\n\tkfree(result);\n\treturn -EILSEQ;\n}\n\nstatic struct inode *befs_nfs_get_inode(struct super_block *sb, uint64_t ino,\n\t\t\t\t\t uint32_t generation)\n{\n\t \n\treturn befs_iget(sb, ino);\n}\n\n \nstatic struct dentry *befs_fh_to_dentry(struct super_block *sb,\n\t\t\t\tstruct fid *fid, int fh_len, int fh_type)\n{\n\treturn generic_fh_to_dentry(sb, fid, fh_len, fh_type,\n\t\t\t\t    befs_nfs_get_inode);\n}\n\n \nstatic struct dentry *befs_fh_to_parent(struct super_block *sb,\n\t\t\t\tstruct fid *fid, int fh_len, int fh_type)\n{\n\treturn generic_fh_to_parent(sb, fid, fh_len, fh_type,\n\t\t\t\t    befs_nfs_get_inode);\n}\n\nstatic struct dentry *befs_get_parent(struct dentry *child)\n{\n\tstruct inode *parent;\n\tstruct befs_inode_info *befs_ino = BEFS_I(d_inode(child));\n\n\tparent = befs_iget(child->d_sb,\n\t\t\t   (unsigned long)befs_ino->i_parent.start);\n\tif (IS_ERR(parent))\n\t\treturn ERR_CAST(parent);\n\n\treturn d_obtain_alias(parent);\n}\n\nenum {\n\tOpt_uid, Opt_gid, Opt_charset, Opt_debug, Opt_err,\n};\n\nstatic const match_table_t befs_tokens = {\n\t{Opt_uid, \"uid=%d\"},\n\t{Opt_gid, \"gid=%d\"},\n\t{Opt_charset, \"iocharset=%s\"},\n\t{Opt_debug, \"debug\"},\n\t{Opt_err, NULL}\n};\n\nstatic int\nparse_options(char *options, struct befs_mount_options *opts)\n{\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\tkuid_t uid;\n\tkgid_t gid;\n\n\t \n\topts->uid = GLOBAL_ROOT_UID;\n\topts->gid = GLOBAL_ROOT_GID;\n\topts->use_uid = 0;\n\topts->use_gid = 0;\n\topts->iocharset = NULL;\n\topts->debug = 0;\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, befs_tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_uid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tuid = INVALID_UID;\n\t\t\tif (option >= 0)\n\t\t\t\tuid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(uid)) {\n\t\t\t\tpr_err(\"Invalid uid %d, \"\n\t\t\t\t       \"using default\\n\", option);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\topts->uid = uid;\n\t\t\topts->use_uid = 1;\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tgid = INVALID_GID;\n\t\t\tif (option >= 0)\n\t\t\t\tgid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(gid)) {\n\t\t\t\tpr_err(\"Invalid gid %d, \"\n\t\t\t\t       \"using default\\n\", option);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\topts->gid = gid;\n\t\t\topts->use_gid = 1;\n\t\t\tbreak;\n\t\tcase Opt_charset:\n\t\t\tkfree(opts->iocharset);\n\t\t\topts->iocharset = match_strdup(&args[0]);\n\t\t\tif (!opts->iocharset) {\n\t\t\t\tpr_err(\"allocation failure for \"\n\t\t\t\t       \"iocharset string\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_debug:\n\t\t\topts->debug = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"Unrecognized mount option \\\"%s\\\" \"\n\t\t\t       \"or missing value\\n\", p);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic int befs_show_options(struct seq_file *m, struct dentry *root)\n{\n\tstruct befs_sb_info *befs_sb = BEFS_SB(root->d_sb);\n\tstruct befs_mount_options *opts = &befs_sb->mount_opts;\n\n\tif (!uid_eq(opts->uid, GLOBAL_ROOT_UID))\n\t\tseq_printf(m, \",uid=%u\",\n\t\t\t   from_kuid_munged(&init_user_ns, opts->uid));\n\tif (!gid_eq(opts->gid, GLOBAL_ROOT_GID))\n\t\tseq_printf(m, \",gid=%u\",\n\t\t\t   from_kgid_munged(&init_user_ns, opts->gid));\n\tif (opts->iocharset)\n\t\tseq_printf(m, \",charset=%s\", opts->iocharset);\n\tif (opts->debug)\n\t\tseq_puts(m, \",debug\");\n\treturn 0;\n}\n\n \nstatic void\nbefs_put_super(struct super_block *sb)\n{\n\tkfree(BEFS_SB(sb)->mount_opts.iocharset);\n\tBEFS_SB(sb)->mount_opts.iocharset = NULL;\n\tunload_nls(BEFS_SB(sb)->nls);\n\tkfree(sb->s_fs_info);\n\tsb->s_fs_info = NULL;\n}\n\n \nstatic int\nbefs_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct buffer_head *bh;\n\tstruct befs_sb_info *befs_sb;\n\tbefs_super_block *disk_sb;\n\tstruct inode *root;\n\tlong ret = -EINVAL;\n\tconst unsigned long sb_block = 0;\n\tconst off_t x86_sb_off = 512;\n\tint blocksize;\n\n\tsb->s_fs_info = kzalloc(sizeof(*befs_sb), GFP_KERNEL);\n\tif (sb->s_fs_info == NULL)\n\t\tgoto unacquire_none;\n\n\tbefs_sb = BEFS_SB(sb);\n\n\tif (!parse_options((char *) data, &befs_sb->mount_opts)) {\n\t\tif (!silent)\n\t\t\tbefs_error(sb, \"cannot parse mount options\");\n\t\tgoto unacquire_priv_sbp;\n\t}\n\n\tbefs_debug(sb, \"---> %s\", __func__);\n\n\tif (!sb_rdonly(sb)) {\n\t\tbefs_warning(sb,\n\t\t\t     \"No write support. Marking filesystem read-only\");\n\t\tsb->s_flags |= SB_RDONLY;\n\t}\n\n\t \n\tblocksize = sb_min_blocksize(sb, 1024);\n\tif (!blocksize) {\n\t\tif (!silent)\n\t\t\tbefs_error(sb, \"unable to set blocksize\");\n\t\tgoto unacquire_priv_sbp;\n\t}\n\n\tbh = sb_bread(sb, sb_block);\n\tif (!bh) {\n\t\tif (!silent)\n\t\t\tbefs_error(sb, \"unable to read superblock\");\n\t\tgoto unacquire_priv_sbp;\n\t}\n\n\t \n\tdisk_sb = (befs_super_block *) bh->b_data;\n\tif ((disk_sb->magic1 == BEFS_SUPER_MAGIC1_LE) ||\n\t    (disk_sb->magic1 == BEFS_SUPER_MAGIC1_BE)) {\n\t\tbefs_debug(sb, \"Using PPC superblock location\");\n\t} else {\n\t\tbefs_debug(sb, \"Using x86 superblock location\");\n\t\tdisk_sb =\n\t\t    (befs_super_block *) ((void *) bh->b_data + x86_sb_off);\n\t}\n\n\tif ((befs_load_sb(sb, disk_sb) != BEFS_OK) ||\n\t    (befs_check_sb(sb) != BEFS_OK))\n\t\tgoto unacquire_bh;\n\n\tbefs_dump_super_block(sb, disk_sb);\n\n\tbrelse(bh);\n\n\tif (befs_sb->num_blocks > ~((sector_t)0)) {\n\t\tif (!silent)\n\t\t\tbefs_error(sb, \"blocks count: %llu is larger than the host can use\",\n\t\t\t\t\tbefs_sb->num_blocks);\n\t\tgoto unacquire_priv_sbp;\n\t}\n\n\t \n\tsb->s_magic = BEFS_SUPER_MAGIC;\n\t \n\tsb_set_blocksize(sb, (ulong) befs_sb->block_size);\n\tsb->s_op = &befs_sops;\n\tsb->s_export_op = &befs_export_operations;\n\tsb->s_time_min = 0;\n\tsb->s_time_max = 0xffffffffffffll;\n\troot = befs_iget(sb, iaddr2blockno(sb, &(befs_sb->root_dir)));\n\tif (IS_ERR(root)) {\n\t\tret = PTR_ERR(root);\n\t\tgoto unacquire_priv_sbp;\n\t}\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\tif (!silent)\n\t\t\tbefs_error(sb, \"get root inode failed\");\n\t\tgoto unacquire_priv_sbp;\n\t}\n\n\t \n\tif (befs_sb->mount_opts.iocharset) {\n\t\tbefs_debug(sb, \"Loading nls: %s\",\n\t\t\t   befs_sb->mount_opts.iocharset);\n\t\tbefs_sb->nls = load_nls(befs_sb->mount_opts.iocharset);\n\t\tif (!befs_sb->nls) {\n\t\t\tbefs_warning(sb, \"Cannot load nls %s\"\n\t\t\t\t\t\" loading default nls\",\n\t\t\t\t\tbefs_sb->mount_opts.iocharset);\n\t\t\tbefs_sb->nls = load_nls_default();\n\t\t}\n\t \n\t} else {\n\t\tbefs_debug(sb, \"Loading default nls\");\n\t\tbefs_sb->nls = load_nls_default();\n\t}\n\n\treturn 0;\n\nunacquire_bh:\n\tbrelse(bh);\n\nunacquire_priv_sbp:\n\tkfree(befs_sb->mount_opts.iocharset);\n\tkfree(sb->s_fs_info);\n\tsb->s_fs_info = NULL;\n\nunacquire_none:\n\treturn ret;\n}\n\nstatic int\nbefs_remount(struct super_block *sb, int *flags, char *data)\n{\n\tsync_filesystem(sb);\n\tif (!(*flags & SB_RDONLY))\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int\nbefs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tu64 id = huge_encode_dev(sb->s_bdev->bd_dev);\n\n\tbefs_debug(sb, \"---> %s\", __func__);\n\n\tbuf->f_type = BEFS_SUPER_MAGIC;\n\tbuf->f_bsize = sb->s_blocksize;\n\tbuf->f_blocks = BEFS_SB(sb)->num_blocks;\n\tbuf->f_bfree = BEFS_SB(sb)->num_blocks - BEFS_SB(sb)->used_blocks;\n\tbuf->f_bavail = buf->f_bfree;\n\tbuf->f_files = 0;\t \n\tbuf->f_ffree = 0;\t \n\tbuf->f_fsid = u64_to_fsid(id);\n\tbuf->f_namelen = BEFS_NAME_LEN;\n\n\tbefs_debug(sb, \"<--- %s\", __func__);\n\n\treturn 0;\n}\n\nstatic struct dentry *\nbefs_mount(struct file_system_type *fs_type, int flags, const char *dev_name,\n\t    void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, befs_fill_super);\n}\n\nstatic struct file_system_type befs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"befs\",\n\t.mount\t\t= befs_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\nMODULE_ALIAS_FS(\"befs\");\n\nstatic int __init\ninit_befs_fs(void)\n{\n\tint err;\n\n\tpr_info(\"version: %s\\n\", BEFS_VERSION);\n\n\terr = befs_init_inodecache();\n\tif (err)\n\t\tgoto unacquire_none;\n\n\terr = register_filesystem(&befs_fs_type);\n\tif (err)\n\t\tgoto unacquire_inodecache;\n\n\treturn 0;\n\nunacquire_inodecache:\n\tbefs_destroy_inodecache();\n\nunacquire_none:\n\treturn err;\n}\n\nstatic void __exit\nexit_befs_fs(void)\n{\n\tbefs_destroy_inodecache();\n\n\tunregister_filesystem(&befs_fs_type);\n}\n\n \nmodule_init(init_befs_fs)\nmodule_exit(exit_befs_fs)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}