{
  "module_name": "namei_msdos.c",
  "hash_id": "fda92f83f35b6870e93d11386b8dcf4f0697160a5e3278c4b0d8f2a32e0ccef1",
  "original_prompt": "Ingested from linux-6.6.14/fs/fat/namei_msdos.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/iversion.h>\n#include \"fat.h\"\n\n \nstatic unsigned char bad_chars[] = \"*?<>|\\\"\";\nstatic unsigned char bad_if_strict[] = \"+=,; \";\n\n \nstatic int msdos_format_name(const unsigned char *name, int len,\n\t\t\t     unsigned char *res, struct fat_mount_options *opts)\n\t \n{\n\tunsigned char *walk;\n\tunsigned char c;\n\tint space;\n\n\tif (name[0] == '.') {\t \n\t\tif (opts->dotsOK) {\n\t\t\t \n\t\t\tname++;\n\t\t\tlen--;\n\t\t} else\n\t\t\treturn -EINVAL;\n\t}\n\t \n\tspace = 1;\n\tc = 0;\n\tfor (walk = res; len && walk - res < 8; walk++) {\n\t\tc = *name++;\n\t\tlen--;\n\t\tif (opts->name_check != 'r' && strchr(bad_chars, c))\n\t\t\treturn -EINVAL;\n\t\tif (opts->name_check == 's' && strchr(bad_if_strict, c))\n\t\t\treturn -EINVAL;\n\t\tif (c >= 'A' && c <= 'Z' && opts->name_check == 's')\n\t\t\treturn -EINVAL;\n\t\tif (c < ' ' || c == ':' || c == '\\\\')\n\t\t\treturn -EINVAL;\n\t \n\t\tif ((res == walk) && (c == 0xE5))\n\t\t\tc = 0x05;\n\t\tif (c == '.')\n\t\t\tbreak;\n\t\tspace = (c == ' ');\n\t\t*walk = (!opts->nocase && c >= 'a' && c <= 'z') ? c - 32 : c;\n\t}\n\tif (space)\n\t\treturn -EINVAL;\n\tif (opts->name_check == 's' && len && c != '.') {\n\t\tc = *name++;\n\t\tlen--;\n\t\tif (c != '.')\n\t\t\treturn -EINVAL;\n\t}\n\twhile (c != '.' && len--)\n\t\tc = *name++;\n\tif (c == '.') {\n\t\twhile (walk - res < 8)\n\t\t\t*walk++ = ' ';\n\t\twhile (len > 0 && walk - res < MSDOS_NAME) {\n\t\t\tc = *name++;\n\t\t\tlen--;\n\t\t\tif (opts->name_check != 'r' && strchr(bad_chars, c))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (opts->name_check == 's' &&\n\t\t\t    strchr(bad_if_strict, c))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (c < ' ' || c == ':' || c == '\\\\')\n\t\t\t\treturn -EINVAL;\n\t\t\tif (c == '.') {\n\t\t\t\tif (opts->name_check == 's')\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (c >= 'A' && c <= 'Z' && opts->name_check == 's')\n\t\t\t\treturn -EINVAL;\n\t\t\tspace = c == ' ';\n\t\t\tif (!opts->nocase && c >= 'a' && c <= 'z')\n\t\t\t\t*walk++ = c - 32;\n\t\t\telse\n\t\t\t\t*walk++ = c;\n\t\t}\n\t\tif (space)\n\t\t\treturn -EINVAL;\n\t\tif (opts->name_check == 's' && len)\n\t\t\treturn -EINVAL;\n\t}\n\twhile (walk - res < MSDOS_NAME)\n\t\t*walk++ = ' ';\n\n\treturn 0;\n}\n\n \nstatic int msdos_find(struct inode *dir, const unsigned char *name, int len,\n\t\t      struct fat_slot_info *sinfo)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(dir->i_sb);\n\tunsigned char msdos_name[MSDOS_NAME];\n\tint err;\n\n\terr = msdos_format_name(name, len, msdos_name, &sbi->options);\n\tif (err)\n\t\treturn -ENOENT;\n\n\terr = fat_scan(dir, msdos_name, sinfo);\n\tif (!err && sbi->options.dotsOK) {\n\t\tif (name[0] == '.') {\n\t\t\tif (!(sinfo->de->attr & ATTR_HIDDEN))\n\t\t\t\terr = -ENOENT;\n\t\t} else {\n\t\t\tif (sinfo->de->attr & ATTR_HIDDEN)\n\t\t\t\terr = -ENOENT;\n\t\t}\n\t\tif (err)\n\t\t\tbrelse(sinfo->bh);\n\t}\n\treturn err;\n}\n\n \nstatic int msdos_hash(const struct dentry *dentry, struct qstr *qstr)\n{\n\tstruct fat_mount_options *options = &MSDOS_SB(dentry->d_sb)->options;\n\tunsigned char msdos_name[MSDOS_NAME];\n\tint error;\n\n\terror = msdos_format_name(qstr->name, qstr->len, msdos_name, options);\n\tif (!error)\n\t\tqstr->hash = full_name_hash(dentry, msdos_name, MSDOS_NAME);\n\treturn 0;\n}\n\n \nstatic int msdos_cmp(const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name)\n{\n\tstruct fat_mount_options *options = &MSDOS_SB(dentry->d_sb)->options;\n\tunsigned char a_msdos_name[MSDOS_NAME], b_msdos_name[MSDOS_NAME];\n\tint error;\n\n\terror = msdos_format_name(name->name, name->len, a_msdos_name, options);\n\tif (error)\n\t\tgoto old_compare;\n\terror = msdos_format_name(str, len, b_msdos_name, options);\n\tif (error)\n\t\tgoto old_compare;\n\terror = memcmp(a_msdos_name, b_msdos_name, MSDOS_NAME);\nout:\n\treturn error;\n\nold_compare:\n\terror = 1;\n\tif (name->len == len)\n\t\terror = memcmp(name->name, str, len);\n\tgoto out;\n}\n\nstatic const struct dentry_operations msdos_dentry_operations = {\n\t.d_hash\t\t= msdos_hash,\n\t.d_compare\t= msdos_cmp,\n};\n\n \n\n \nstatic struct dentry *msdos_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t   unsigned int flags)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct fat_slot_info sinfo;\n\tstruct inode *inode;\n\tint err;\n\n\tmutex_lock(&MSDOS_SB(sb)->s_lock);\n\terr = msdos_find(dir, dentry->d_name.name, dentry->d_name.len, &sinfo);\n\tswitch (err) {\n\tcase -ENOENT:\n\t\tinode = NULL;\n\t\tbreak;\n\tcase 0:\n\t\tinode = fat_build_inode(sb, sinfo.de, sinfo.i_pos);\n\t\tbrelse(sinfo.bh);\n\t\tbreak;\n\tdefault:\n\t\tinode = ERR_PTR(err);\n\t}\n\tmutex_unlock(&MSDOS_SB(sb)->s_lock);\n\treturn d_splice_alias(inode, dentry);\n}\n\n \nstatic int msdos_add_entry(struct inode *dir, const unsigned char *name,\n\t\t\t   int is_dir, int is_hid, int cluster,\n\t\t\t   struct timespec64 *ts, struct fat_slot_info *sinfo)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(dir->i_sb);\n\tstruct msdos_dir_entry de;\n\t__le16 time, date;\n\tint err;\n\n\tmemcpy(de.name, name, MSDOS_NAME);\n\tde.attr = is_dir ? ATTR_DIR : ATTR_ARCH;\n\tif (is_hid)\n\t\tde.attr |= ATTR_HIDDEN;\n\tde.lcase = 0;\n\tfat_time_unix2fat(sbi, ts, &time, &date, NULL);\n\tde.cdate = de.adate = 0;\n\tde.ctime = 0;\n\tde.ctime_cs = 0;\n\tde.time = time;\n\tde.date = date;\n\tfat_set_start(&de, cluster);\n\tde.size = 0;\n\n\terr = fat_add_entries(dir, &de, 1, sinfo);\n\tif (err)\n\t\treturn err;\n\n\tfat_truncate_time(dir, ts, S_CTIME|S_MTIME);\n\tif (IS_DIRSYNC(dir))\n\t\t(void)fat_sync_inode(dir);\n\telse\n\t\tmark_inode_dirty(dir);\n\n\treturn 0;\n}\n\n \nstatic int msdos_create(struct mnt_idmap *idmap, struct inode *dir,\n\t\t\tstruct dentry *dentry, umode_t mode, bool excl)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct inode *inode = NULL;\n\tstruct fat_slot_info sinfo;\n\tstruct timespec64 ts;\n\tunsigned char msdos_name[MSDOS_NAME];\n\tint err, is_hid;\n\n\tmutex_lock(&MSDOS_SB(sb)->s_lock);\n\n\terr = msdos_format_name(dentry->d_name.name, dentry->d_name.len,\n\t\t\t\tmsdos_name, &MSDOS_SB(sb)->options);\n\tif (err)\n\t\tgoto out;\n\tis_hid = (dentry->d_name.name[0] == '.') && (msdos_name[0] != '.');\n\t \n\tif (!fat_scan(dir, msdos_name, &sinfo)) {\n\t\tbrelse(sinfo.bh);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tts = current_time(dir);\n\terr = msdos_add_entry(dir, msdos_name, 0, is_hid, 0, &ts, &sinfo);\n\tif (err)\n\t\tgoto out;\n\tinode = fat_build_inode(sb, sinfo.de, sinfo.i_pos);\n\tbrelse(sinfo.bh);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tgoto out;\n\t}\n\tfat_truncate_time(inode, &ts, S_ATIME|S_CTIME|S_MTIME);\n\t \n\n\td_instantiate(dentry, inode);\nout:\n\tmutex_unlock(&MSDOS_SB(sb)->s_lock);\n\tif (!err)\n\t\terr = fat_flush_inodes(sb, dir, inode);\n\treturn err;\n}\n\n \nstatic int msdos_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct inode *inode = d_inode(dentry);\n\tstruct fat_slot_info sinfo;\n\tint err;\n\n\tmutex_lock(&MSDOS_SB(sb)->s_lock);\n\terr = fat_dir_empty(inode);\n\tif (err)\n\t\tgoto out;\n\terr = msdos_find(dir, dentry->d_name.name, dentry->d_name.len, &sinfo);\n\tif (err)\n\t\tgoto out;\n\n\terr = fat_remove_entries(dir, &sinfo);\t \n\tif (err)\n\t\tgoto out;\n\tdrop_nlink(dir);\n\n\tclear_nlink(inode);\n\tfat_truncate_time(inode, NULL, S_CTIME);\n\tfat_detach(inode);\nout:\n\tmutex_unlock(&MSDOS_SB(sb)->s_lock);\n\tif (!err)\n\t\terr = fat_flush_inodes(sb, dir, inode);\n\n\treturn err;\n}\n\n \nstatic int msdos_mkdir(struct mnt_idmap *idmap, struct inode *dir,\n\t\t       struct dentry *dentry, umode_t mode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct fat_slot_info sinfo;\n\tstruct inode *inode;\n\tunsigned char msdos_name[MSDOS_NAME];\n\tstruct timespec64 ts;\n\tint err, is_hid, cluster;\n\n\tmutex_lock(&MSDOS_SB(sb)->s_lock);\n\n\terr = msdos_format_name(dentry->d_name.name, dentry->d_name.len,\n\t\t\t\tmsdos_name, &MSDOS_SB(sb)->options);\n\tif (err)\n\t\tgoto out;\n\tis_hid = (dentry->d_name.name[0] == '.') && (msdos_name[0] != '.');\n\t \n\tif (!fat_scan(dir, msdos_name, &sinfo)) {\n\t\tbrelse(sinfo.bh);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tts = current_time(dir);\n\tcluster = fat_alloc_new_dir(dir, &ts);\n\tif (cluster < 0) {\n\t\terr = cluster;\n\t\tgoto out;\n\t}\n\terr = msdos_add_entry(dir, msdos_name, 1, is_hid, cluster, &ts, &sinfo);\n\tif (err)\n\t\tgoto out_free;\n\tinc_nlink(dir);\n\n\tinode = fat_build_inode(sb, sinfo.de, sinfo.i_pos);\n\tbrelse(sinfo.bh);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\t \n\t\tgoto out;\n\t}\n\tset_nlink(inode, 2);\n\tfat_truncate_time(inode, &ts, S_ATIME|S_CTIME|S_MTIME);\n\t \n\n\td_instantiate(dentry, inode);\n\n\tmutex_unlock(&MSDOS_SB(sb)->s_lock);\n\tfat_flush_inodes(sb, dir, inode);\n\treturn 0;\n\nout_free:\n\tfat_free_clusters(dir, cluster);\nout:\n\tmutex_unlock(&MSDOS_SB(sb)->s_lock);\n\treturn err;\n}\n\n \nstatic int msdos_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct fat_slot_info sinfo;\n\tint err;\n\n\tmutex_lock(&MSDOS_SB(sb)->s_lock);\n\terr = msdos_find(dir, dentry->d_name.name, dentry->d_name.len, &sinfo);\n\tif (err)\n\t\tgoto out;\n\n\terr = fat_remove_entries(dir, &sinfo);\t \n\tif (err)\n\t\tgoto out;\n\tclear_nlink(inode);\n\tfat_truncate_time(inode, NULL, S_CTIME);\n\tfat_detach(inode);\nout:\n\tmutex_unlock(&MSDOS_SB(sb)->s_lock);\n\tif (!err)\n\t\terr = fat_flush_inodes(sb, dir, inode);\n\n\treturn err;\n}\n\nstatic int do_msdos_rename(struct inode *old_dir, unsigned char *old_name,\n\t\t\t   struct dentry *old_dentry,\n\t\t\t   struct inode *new_dir, unsigned char *new_name,\n\t\t\t   struct dentry *new_dentry, int is_hid)\n{\n\tstruct buffer_head *dotdot_bh;\n\tstruct msdos_dir_entry *dotdot_de;\n\tstruct inode *old_inode, *new_inode;\n\tstruct fat_slot_info old_sinfo, sinfo;\n\tstruct timespec64 ts;\n\tloff_t new_i_pos;\n\tint err, old_attrs, is_dir, update_dotdot, corrupt = 0;\n\n\told_sinfo.bh = sinfo.bh = dotdot_bh = NULL;\n\told_inode = d_inode(old_dentry);\n\tnew_inode = d_inode(new_dentry);\n\n\terr = fat_scan(old_dir, old_name, &old_sinfo);\n\tif (err) {\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\n\tis_dir = S_ISDIR(old_inode->i_mode);\n\tupdate_dotdot = (is_dir && old_dir != new_dir);\n\tif (update_dotdot) {\n\t\tif (fat_get_dotdot_entry(old_inode, &dotdot_bh, &dotdot_de)) {\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\told_attrs = MSDOS_I(old_inode)->i_attrs;\n\terr = fat_scan(new_dir, new_name, &sinfo);\n\tif (!err) {\n\t\tif (!new_inode) {\n\t\t\t \n\t\t\tif (sinfo.de != old_sinfo.de) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (is_hid)\n\t\t\t\tMSDOS_I(old_inode)->i_attrs |= ATTR_HIDDEN;\n\t\t\telse\n\t\t\t\tMSDOS_I(old_inode)->i_attrs &= ~ATTR_HIDDEN;\n\t\t\tif (IS_DIRSYNC(old_dir)) {\n\t\t\t\terr = fat_sync_inode(old_inode);\n\t\t\t\tif (err) {\n\t\t\t\t\tMSDOS_I(old_inode)->i_attrs = old_attrs;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tmark_inode_dirty(old_inode);\n\n\t\t\tinode_inc_iversion(old_dir);\n\t\t\tfat_truncate_time(old_dir, NULL, S_CTIME|S_MTIME);\n\t\t\tif (IS_DIRSYNC(old_dir))\n\t\t\t\t(void)fat_sync_inode(old_dir);\n\t\t\telse\n\t\t\t\tmark_inode_dirty(old_dir);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tts = current_time(old_inode);\n\tif (new_inode) {\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (is_dir) {\n\t\t\terr = fat_dir_empty(new_inode);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t\tnew_i_pos = MSDOS_I(new_inode)->i_pos;\n\t\tfat_detach(new_inode);\n\t} else {\n\t\terr = msdos_add_entry(new_dir, new_name, is_dir, is_hid, 0,\n\t\t\t\t      &ts, &sinfo);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tnew_i_pos = sinfo.i_pos;\n\t}\n\tinode_inc_iversion(new_dir);\n\n\tfat_detach(old_inode);\n\tfat_attach(old_inode, new_i_pos);\n\tif (is_hid)\n\t\tMSDOS_I(old_inode)->i_attrs |= ATTR_HIDDEN;\n\telse\n\t\tMSDOS_I(old_inode)->i_attrs &= ~ATTR_HIDDEN;\n\tif (IS_DIRSYNC(new_dir)) {\n\t\terr = fat_sync_inode(old_inode);\n\t\tif (err)\n\t\t\tgoto error_inode;\n\t} else\n\t\tmark_inode_dirty(old_inode);\n\n\tif (update_dotdot) {\n\t\tfat_set_start(dotdot_de, MSDOS_I(new_dir)->i_logstart);\n\t\tmark_buffer_dirty_inode(dotdot_bh, old_inode);\n\t\tif (IS_DIRSYNC(new_dir)) {\n\t\t\terr = sync_dirty_buffer(dotdot_bh);\n\t\t\tif (err)\n\t\t\t\tgoto error_dotdot;\n\t\t}\n\t\tdrop_nlink(old_dir);\n\t\tif (!new_inode)\n\t\t\tinc_nlink(new_dir);\n\t}\n\n\terr = fat_remove_entries(old_dir, &old_sinfo);\t \n\told_sinfo.bh = NULL;\n\tif (err)\n\t\tgoto error_dotdot;\n\tinode_inc_iversion(old_dir);\n\tfat_truncate_time(old_dir, &ts, S_CTIME|S_MTIME);\n\tif (IS_DIRSYNC(old_dir))\n\t\t(void)fat_sync_inode(old_dir);\n\telse\n\t\tmark_inode_dirty(old_dir);\n\n\tif (new_inode) {\n\t\tdrop_nlink(new_inode);\n\t\tif (is_dir)\n\t\t\tdrop_nlink(new_inode);\n\t\tfat_truncate_time(new_inode, &ts, S_CTIME);\n\t}\nout:\n\tbrelse(sinfo.bh);\n\tbrelse(dotdot_bh);\n\tbrelse(old_sinfo.bh);\n\treturn err;\n\nerror_dotdot:\n\t \n\tcorrupt = 1;\n\n\tif (update_dotdot) {\n\t\tfat_set_start(dotdot_de, MSDOS_I(old_dir)->i_logstart);\n\t\tmark_buffer_dirty_inode(dotdot_bh, old_inode);\n\t\tcorrupt |= sync_dirty_buffer(dotdot_bh);\n\t}\nerror_inode:\n\tfat_detach(old_inode);\n\tfat_attach(old_inode, old_sinfo.i_pos);\n\tMSDOS_I(old_inode)->i_attrs = old_attrs;\n\tif (new_inode) {\n\t\tfat_attach(new_inode, new_i_pos);\n\t\tif (corrupt)\n\t\t\tcorrupt |= fat_sync_inode(new_inode);\n\t} else {\n\t\t \n\t\tint err2 = fat_remove_entries(new_dir, &sinfo);\n\t\tif (corrupt)\n\t\t\tcorrupt |= err2;\n\t\tsinfo.bh = NULL;\n\t}\n\tif (corrupt < 0) {\n\t\tfat_fs_error(new_dir->i_sb,\n\t\t\t     \"%s: Filesystem corrupted (i_pos %lld)\",\n\t\t\t     __func__, sinfo.i_pos);\n\t}\n\tgoto out;\n}\n\n \nstatic int msdos_rename(struct mnt_idmap *idmap,\n\t\t\tstruct inode *old_dir, struct dentry *old_dentry,\n\t\t\tstruct inode *new_dir, struct dentry *new_dentry,\n\t\t\tunsigned int flags)\n{\n\tstruct super_block *sb = old_dir->i_sb;\n\tunsigned char old_msdos_name[MSDOS_NAME], new_msdos_name[MSDOS_NAME];\n\tint err, is_hid;\n\n\tif (flags & ~RENAME_NOREPLACE)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&MSDOS_SB(sb)->s_lock);\n\n\terr = msdos_format_name(old_dentry->d_name.name,\n\t\t\t\told_dentry->d_name.len, old_msdos_name,\n\t\t\t\t&MSDOS_SB(old_dir->i_sb)->options);\n\tif (err)\n\t\tgoto out;\n\terr = msdos_format_name(new_dentry->d_name.name,\n\t\t\t\tnew_dentry->d_name.len, new_msdos_name,\n\t\t\t\t&MSDOS_SB(new_dir->i_sb)->options);\n\tif (err)\n\t\tgoto out;\n\n\tis_hid =\n\t     (new_dentry->d_name.name[0] == '.') && (new_msdos_name[0] != '.');\n\n\terr = do_msdos_rename(old_dir, old_msdos_name, old_dentry,\n\t\t\t      new_dir, new_msdos_name, new_dentry, is_hid);\nout:\n\tmutex_unlock(&MSDOS_SB(sb)->s_lock);\n\tif (!err)\n\t\terr = fat_flush_inodes(sb, old_dir, new_dir);\n\treturn err;\n}\n\nstatic const struct inode_operations msdos_dir_inode_operations = {\n\t.create\t\t= msdos_create,\n\t.lookup\t\t= msdos_lookup,\n\t.unlink\t\t= msdos_unlink,\n\t.mkdir\t\t= msdos_mkdir,\n\t.rmdir\t\t= msdos_rmdir,\n\t.rename\t\t= msdos_rename,\n\t.setattr\t= fat_setattr,\n\t.getattr\t= fat_getattr,\n\t.update_time\t= fat_update_time,\n};\n\nstatic void setup(struct super_block *sb)\n{\n\tMSDOS_SB(sb)->dir_ops = &msdos_dir_inode_operations;\n\tsb->s_d_op = &msdos_dentry_operations;\n\tsb->s_flags |= SB_NOATIME;\n}\n\nstatic int msdos_fill_super(struct super_block *sb, void *data, int silent)\n{\n\treturn fat_fill_super(sb, data, silent, 0, setup);\n}\n\nstatic struct dentry *msdos_mount(struct file_system_type *fs_type,\n\t\t\tint flags, const char *dev_name,\n\t\t\tvoid *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, msdos_fill_super);\n}\n\nstatic struct file_system_type msdos_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"msdos\",\n\t.mount\t\t= msdos_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV | FS_ALLOW_IDMAP,\n};\nMODULE_ALIAS_FS(\"msdos\");\n\nstatic int __init init_msdos_fs(void)\n{\n\treturn register_filesystem(&msdos_fs_type);\n}\n\nstatic void __exit exit_msdos_fs(void)\n{\n\tunregister_filesystem(&msdos_fs_type);\n}\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Werner Almesberger\");\nMODULE_DESCRIPTION(\"MS-DOS filesystem support\");\n\nmodule_init(init_msdos_fs)\nmodule_exit(exit_msdos_fs)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}