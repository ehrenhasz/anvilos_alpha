{
  "module_name": "namei_vfat.c",
  "hash_id": "051c1a010a312fef0b684f5c424df2e04ca2b2a7aaff39669cd404db337f1b4f",
  "original_prompt": "Ingested from linux-6.6.14/fs/fat/namei_vfat.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/iversion.h>\n#include \"fat.h\"\n\nstatic inline unsigned long vfat_d_version(struct dentry *dentry)\n{\n\treturn (unsigned long) dentry->d_fsdata;\n}\n\nstatic inline void vfat_d_version_set(struct dentry *dentry,\n\t\t\t\t      unsigned long version)\n{\n\tdentry->d_fsdata = (void *) version;\n}\n\n \nstatic int vfat_revalidate_shortname(struct dentry *dentry)\n{\n\tint ret = 1;\n\tspin_lock(&dentry->d_lock);\n\tif (!inode_eq_iversion(d_inode(dentry->d_parent), vfat_d_version(dentry)))\n\t\tret = 0;\n\tspin_unlock(&dentry->d_lock);\n\treturn ret;\n}\n\nstatic int vfat_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\t \n\tif (d_really_is_positive(dentry))\n\t\treturn 1;\n\treturn vfat_revalidate_shortname(dentry);\n}\n\nstatic int vfat_revalidate_ci(struct dentry *dentry, unsigned int flags)\n{\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\t \n\tif (d_really_is_positive(dentry))\n\t\treturn 1;\n\n\t \n\tif (!flags)\n\t\treturn 0;\n\n\t \n\tif (flags & (LOOKUP_CREATE | LOOKUP_RENAME_TARGET))\n\t\treturn 0;\n\n\treturn vfat_revalidate_shortname(dentry);\n}\n\n \nstatic unsigned int __vfat_striptail_len(unsigned int len, const char *name)\n{\n\twhile (len && name[len - 1] == '.')\n\t\tlen--;\n\treturn len;\n}\n\nstatic unsigned int vfat_striptail_len(const struct qstr *qstr)\n{\n\treturn __vfat_striptail_len(qstr->len, qstr->name);\n}\n\n \nstatic int vfat_hash(const struct dentry *dentry, struct qstr *qstr)\n{\n\tqstr->hash = full_name_hash(dentry, qstr->name, vfat_striptail_len(qstr));\n\treturn 0;\n}\n\n \nstatic int vfat_hashi(const struct dentry *dentry, struct qstr *qstr)\n{\n\tstruct nls_table *t = MSDOS_SB(dentry->d_sb)->nls_io;\n\tconst unsigned char *name;\n\tunsigned int len;\n\tunsigned long hash;\n\n\tname = qstr->name;\n\tlen = vfat_striptail_len(qstr);\n\n\thash = init_name_hash(dentry);\n\twhile (len--)\n\t\thash = partial_name_hash(nls_tolower(t, *name++), hash);\n\tqstr->hash = end_name_hash(hash);\n\n\treturn 0;\n}\n\n \nstatic int vfat_cmpi(const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name)\n{\n\tstruct nls_table *t = MSDOS_SB(dentry->d_sb)->nls_io;\n\tunsigned int alen, blen;\n\n\t \n\talen = vfat_striptail_len(name);\n\tblen = __vfat_striptail_len(len, str);\n\tif (alen == blen) {\n\t\tif (nls_strnicmp(t, name->name, str, alen) == 0)\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n \nstatic int vfat_cmp(const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name)\n{\n\tunsigned int alen, blen;\n\n\t \n\talen = vfat_striptail_len(name);\n\tblen = __vfat_striptail_len(len, str);\n\tif (alen == blen) {\n\t\tif (strncmp(name->name, str, alen) == 0)\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic const struct dentry_operations vfat_ci_dentry_ops = {\n\t.d_revalidate\t= vfat_revalidate_ci,\n\t.d_hash\t\t= vfat_hashi,\n\t.d_compare\t= vfat_cmpi,\n};\n\nstatic const struct dentry_operations vfat_dentry_ops = {\n\t.d_revalidate\t= vfat_revalidate,\n\t.d_hash\t\t= vfat_hash,\n\t.d_compare\t= vfat_cmp,\n};\n\n \n\nstatic inline bool vfat_bad_char(wchar_t w)\n{\n\treturn (w < 0x0020)\n\t    || (w == '*') || (w == '?') || (w == '<') || (w == '>')\n\t    || (w == '|') || (w == '\"') || (w == ':') || (w == '/')\n\t    || (w == '\\\\');\n}\n\nstatic inline bool vfat_replace_char(wchar_t w)\n{\n\treturn (w == '[') || (w == ']') || (w == ';') || (w == ',')\n\t    || (w == '+') || (w == '=');\n}\n\nstatic wchar_t vfat_skip_char(wchar_t w)\n{\n\treturn (w == '.') || (w == ' ');\n}\n\nstatic inline int vfat_is_used_badchars(const wchar_t *s, int len)\n{\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\tif (vfat_bad_char(s[i]))\n\t\t\treturn -EINVAL;\n\n\tif (s[i - 1] == ' ')  \n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int vfat_find_form(struct inode *dir, unsigned char *name)\n{\n\tstruct fat_slot_info sinfo;\n\tint err = fat_scan(dir, name, &sinfo);\n\tif (err)\n\t\treturn -ENOENT;\n\tbrelse(sinfo.bh);\n\treturn 0;\n}\n\n \nstruct shortname_info {\n\tunsigned char lower:1,\n\t\t      upper:1,\n\t\t      valid:1;\n};\n#define INIT_SHORTNAME_INFO(x)\tdo {\t\t\\\n\t(x)->lower = 1;\t\t\t\t\\\n\t(x)->upper = 1;\t\t\t\t\\\n\t(x)->valid = 1;\t\t\t\t\\\n} while (0)\n\nstatic inline int to_shortname_char(struct nls_table *nls,\n\t\t\t\t    unsigned char *buf, int buf_size,\n\t\t\t\t    wchar_t *src, struct shortname_info *info)\n{\n\tint len;\n\n\tif (vfat_skip_char(*src)) {\n\t\tinfo->valid = 0;\n\t\treturn 0;\n\t}\n\tif (vfat_replace_char(*src)) {\n\t\tinfo->valid = 0;\n\t\tbuf[0] = '_';\n\t\treturn 1;\n\t}\n\n\tlen = nls->uni2char(*src, buf, buf_size);\n\tif (len <= 0) {\n\t\tinfo->valid = 0;\n\t\tbuf[0] = '_';\n\t\tlen = 1;\n\t} else if (len == 1) {\n\t\tunsigned char prev = buf[0];\n\n\t\tif (buf[0] >= 0x7F) {\n\t\t\tinfo->lower = 0;\n\t\t\tinfo->upper = 0;\n\t\t}\n\n\t\tbuf[0] = nls_toupper(nls, buf[0]);\n\t\tif (isalpha(buf[0])) {\n\t\t\tif (buf[0] == prev)\n\t\t\t\tinfo->lower = 0;\n\t\t\telse\n\t\t\t\tinfo->upper = 0;\n\t\t}\n\t} else {\n\t\tinfo->lower = 0;\n\t\tinfo->upper = 0;\n\t}\n\n\treturn len;\n}\n\n \nstatic int vfat_create_shortname(struct inode *dir, struct nls_table *nls,\n\t\t\t\t wchar_t *uname, int ulen,\n\t\t\t\t unsigned char *name_res, unsigned char *lcase)\n{\n\tstruct fat_mount_options *opts = &MSDOS_SB(dir->i_sb)->options;\n\twchar_t *ip, *ext_start, *end, *name_start;\n\tunsigned char base[9], ext[4], buf[5], *p;\n\tunsigned char charbuf[NLS_MAX_CHARSET_SIZE];\n\tint chl, chi;\n\tint sz = 0, extlen, baselen, i, numtail_baselen, numtail2_baselen;\n\tint is_shortname;\n\tstruct shortname_info base_info, ext_info;\n\n\tis_shortname = 1;\n\tINIT_SHORTNAME_INFO(&base_info);\n\tINIT_SHORTNAME_INFO(&ext_info);\n\n\t \n\text_start = end = &uname[ulen];\n\twhile (--ext_start >= uname) {\n\t\tif (*ext_start == 0x002E) {\t \n\t\t\tif (ext_start == end - 1) {\n\t\t\t\tsz = ulen;\n\t\t\t\text_start = NULL;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ext_start == uname - 1) {\n\t\tsz = ulen;\n\t\text_start = NULL;\n\t} else if (ext_start) {\n\t\t \n\t\tname_start = &uname[0];\n\t\twhile (name_start < ext_start) {\n\t\t\tif (!vfat_skip_char(*name_start))\n\t\t\t\tbreak;\n\t\t\tname_start++;\n\t\t}\n\t\tif (name_start != ext_start) {\n\t\t\tsz = ext_start - uname;\n\t\t\text_start++;\n\t\t} else {\n\t\t\tsz = ulen;\n\t\t\text_start = NULL;\n\t\t}\n\t}\n\n\tnumtail_baselen = 6;\n\tnumtail2_baselen = 2;\n\tfor (baselen = i = 0, p = base, ip = uname; i < sz; i++, ip++) {\n\t\tchl = to_shortname_char(nls, charbuf, sizeof(charbuf),\n\t\t\t\t\tip, &base_info);\n\t\tif (chl == 0)\n\t\t\tcontinue;\n\n\t\tif (baselen < 2 && (baselen + chl) > 2)\n\t\t\tnumtail2_baselen = baselen;\n\t\tif (baselen < 6 && (baselen + chl) > 6)\n\t\t\tnumtail_baselen = baselen;\n\t\tfor (chi = 0; chi < chl; chi++) {\n\t\t\t*p++ = charbuf[chi];\n\t\t\tbaselen++;\n\t\t\tif (baselen >= 8)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (baselen >= 8) {\n\t\t\tif ((chi < chl - 1) || (ip + 1) - uname < sz)\n\t\t\t\tis_shortname = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (baselen == 0) {\n\t\treturn -EINVAL;\n\t}\n\n\textlen = 0;\n\tif (ext_start) {\n\t\tfor (p = ext, ip = ext_start; extlen < 3 && ip < end; ip++) {\n\t\t\tchl = to_shortname_char(nls, charbuf, sizeof(charbuf),\n\t\t\t\t\t\tip, &ext_info);\n\t\t\tif (chl == 0)\n\t\t\t\tcontinue;\n\n\t\t\tif ((extlen + chl) > 3) {\n\t\t\t\tis_shortname = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (chi = 0; chi < chl; chi++) {\n\t\t\t\t*p++ = charbuf[chi];\n\t\t\t\textlen++;\n\t\t\t}\n\t\t\tif (extlen >= 3) {\n\t\t\t\tif (ip + 1 != end)\n\t\t\t\t\tis_shortname = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\text[extlen] = '\\0';\n\tbase[baselen] = '\\0';\n\n\t \n\tif (base[0] == DELETED_FLAG)\n\t\tbase[0] = 0x05;\n\n\t \n\n\tmemset(name_res, ' ', MSDOS_NAME);\n\tmemcpy(name_res, base, baselen);\n\tmemcpy(name_res + 8, ext, extlen);\n\t*lcase = 0;\n\tif (is_shortname && base_info.valid && ext_info.valid) {\n\t\tif (vfat_find_form(dir, name_res) == 0)\n\t\t\treturn -EEXIST;\n\n\t\tif (opts->shortname & VFAT_SFN_CREATE_WIN95) {\n\t\t\treturn (base_info.upper && ext_info.upper);\n\t\t} else if (opts->shortname & VFAT_SFN_CREATE_WINNT) {\n\t\t\tif ((base_info.upper || base_info.lower) &&\n\t\t\t    (ext_info.upper || ext_info.lower)) {\n\t\t\t\tif (!base_info.upper && base_info.lower)\n\t\t\t\t\t*lcase |= CASE_LOWER_BASE;\n\t\t\t\tif (!ext_info.upper && ext_info.lower)\n\t\t\t\t\t*lcase |= CASE_LOWER_EXT;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tBUG();\n\t\t}\n\t}\n\n\tif (opts->numtail == 0)\n\t\tif (vfat_find_form(dir, name_res) < 0)\n\t\t\treturn 0;\n\n\t \n\n\tif (baselen > 6) {\n\t\tbaselen = numtail_baselen;\n\t\tname_res[7] = ' ';\n\t}\n\tname_res[baselen] = '~';\n\tfor (i = 1; i < 10; i++) {\n\t\tname_res[baselen + 1] = i + '0';\n\t\tif (vfat_find_form(dir, name_res) < 0)\n\t\t\treturn 0;\n\t}\n\n\ti = jiffies;\n\tsz = (jiffies >> 16) & 0x7;\n\tif (baselen > 2) {\n\t\tbaselen = numtail2_baselen;\n\t\tname_res[7] = ' ';\n\t}\n\tname_res[baselen + 4] = '~';\n\tname_res[baselen + 5] = '1' + sz;\n\twhile (1) {\n\t\tsnprintf(buf, sizeof(buf), \"%04X\", i & 0xffff);\n\t\tmemcpy(&name_res[baselen], buf, 4);\n\t\tif (vfat_find_form(dir, name_res) < 0)\n\t\t\tbreak;\n\t\ti -= 11;\n\t}\n\treturn 0;\n}\n\n \nstatic int\nxlate_to_uni(const unsigned char *name, int len, unsigned char *outname,\n\t     int *longlen, int *outlen, int escape, int utf8,\n\t     struct nls_table *nls)\n{\n\tconst unsigned char *ip;\n\tunsigned char *op;\n\tint i, fill;\n\tint charlen;\n\n\tif (utf8) {\n\t\t*outlen = utf8s_to_utf16s(name, len, UTF16_HOST_ENDIAN,\n\t\t\t\t(wchar_t *) outname, FAT_LFN_LEN + 2);\n\t\tif (*outlen < 0)\n\t\t\treturn *outlen;\n\t\telse if (*outlen > FAT_LFN_LEN)\n\t\t\treturn -ENAMETOOLONG;\n\n\t\top = &outname[*outlen * sizeof(wchar_t)];\n\t} else {\n\t\tfor (i = 0, ip = name, op = outname, *outlen = 0;\n\t\t\t i < len && *outlen < FAT_LFN_LEN;\n\t\t\t *outlen += 1) {\n\t\t\tif (escape && (*ip == ':')) {\n\t\t\t\tu8 uc[2];\n\n\t\t\t\tif (i > len - 5)\n\t\t\t\t\treturn -EINVAL;\n\n\t\t\t\tif (hex2bin(uc, ip + 1, 2) < 0)\n\t\t\t\t\treturn -EINVAL;\n\n\t\t\t\t*(wchar_t *)op = uc[0] << 8 | uc[1];\n\n\t\t\t\top += 2;\n\t\t\t\tip += 5;\n\t\t\t\ti += 5;\n\t\t\t} else {\n\t\t\t\tcharlen = nls->char2uni(ip, len - i,\n\t\t\t\t\t\t\t(wchar_t *)op);\n\t\t\t\tif (charlen < 0)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tip += charlen;\n\t\t\t\ti += charlen;\n\t\t\t\top += 2;\n\t\t\t}\n\t\t}\n\t\tif (i < len)\n\t\t\treturn -ENAMETOOLONG;\n\t}\n\n\t*longlen = *outlen;\n\tif (*outlen % 13) {\n\t\t*op++ = 0;\n\t\t*op++ = 0;\n\t\t*outlen += 1;\n\t\tif (*outlen % 13) {\n\t\t\tfill = 13 - (*outlen % 13);\n\t\t\tfor (i = 0; i < fill; i++) {\n\t\t\t\t*op++ = 0xff;\n\t\t\t\t*op++ = 0xff;\n\t\t\t}\n\t\t\t*outlen += fill;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int vfat_build_slots(struct inode *dir, const unsigned char *name,\n\t\t\t    int len, int is_dir, int cluster,\n\t\t\t    struct timespec64 *ts,\n\t\t\t    struct msdos_dir_slot *slots, int *nr_slots)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(dir->i_sb);\n\tstruct fat_mount_options *opts = &sbi->options;\n\tstruct msdos_dir_slot *ps;\n\tstruct msdos_dir_entry *de;\n\tunsigned char cksum, lcase;\n\tunsigned char msdos_name[MSDOS_NAME];\n\twchar_t *uname;\n\t__le16 time, date;\n\tu8 time_cs;\n\tint err, ulen, usize, i;\n\tloff_t offset;\n\n\t*nr_slots = 0;\n\n\tuname = __getname();\n\tif (!uname)\n\t\treturn -ENOMEM;\n\n\terr = xlate_to_uni(name, len, (unsigned char *)uname, &ulen, &usize,\n\t\t\t   opts->unicode_xlate, opts->utf8, sbi->nls_io);\n\tif (err)\n\t\tgoto out_free;\n\n\terr = vfat_is_used_badchars(uname, ulen);\n\tif (err)\n\t\tgoto out_free;\n\n\terr = vfat_create_shortname(dir, sbi->nls_disk, uname, ulen,\n\t\t\t\t    msdos_name, &lcase);\n\tif (err < 0)\n\t\tgoto out_free;\n\telse if (err == 1) {\n\t\tde = (struct msdos_dir_entry *)slots;\n\t\terr = 0;\n\t\tgoto shortname;\n\t}\n\n\t \n\tcksum = fat_checksum(msdos_name);\n\n\t*nr_slots = usize / 13;\n\tfor (ps = slots, i = *nr_slots; i > 0; i--, ps++) {\n\t\tps->id = i;\n\t\tps->attr = ATTR_EXT;\n\t\tps->reserved = 0;\n\t\tps->alias_checksum = cksum;\n\t\tps->start = 0;\n\t\toffset = (i - 1) * 13;\n\t\tfatwchar_to16(ps->name0_4, uname + offset, 5);\n\t\tfatwchar_to16(ps->name5_10, uname + offset + 5, 6);\n\t\tfatwchar_to16(ps->name11_12, uname + offset + 11, 2);\n\t}\n\tslots[0].id |= 0x40;\n\tde = (struct msdos_dir_entry *)ps;\n\nshortname:\n\t \n\t(*nr_slots)++;\n\tmemcpy(de->name, msdos_name, MSDOS_NAME);\n\tde->attr = is_dir ? ATTR_DIR : ATTR_ARCH;\n\tde->lcase = lcase;\n\tfat_time_unix2fat(sbi, ts, &time, &date, &time_cs);\n\tde->time = de->ctime = time;\n\tde->date = de->cdate = de->adate = date;\n\tde->ctime_cs = time_cs;\n\tfat_set_start(de, cluster);\n\tde->size = 0;\nout_free:\n\t__putname(uname);\n\treturn err;\n}\n\nstatic int vfat_add_entry(struct inode *dir, const struct qstr *qname,\n\t\t\t  int is_dir, int cluster, struct timespec64 *ts,\n\t\t\t  struct fat_slot_info *sinfo)\n{\n\tstruct msdos_dir_slot *slots;\n\tunsigned int len;\n\tint err, nr_slots;\n\n\tlen = vfat_striptail_len(qname);\n\tif (len == 0)\n\t\treturn -ENOENT;\n\n\tslots = kmalloc_array(MSDOS_SLOTS, sizeof(*slots), GFP_NOFS);\n\tif (slots == NULL)\n\t\treturn -ENOMEM;\n\n\terr = vfat_build_slots(dir, qname->name, len, is_dir, cluster, ts,\n\t\t\t       slots, &nr_slots);\n\tif (err)\n\t\tgoto cleanup;\n\n\terr = fat_add_entries(dir, slots, nr_slots, sinfo);\n\tif (err)\n\t\tgoto cleanup;\n\n\t \n\tfat_truncate_time(dir, ts, S_CTIME|S_MTIME);\n\tif (IS_DIRSYNC(dir))\n\t\t(void)fat_sync_inode(dir);\n\telse\n\t\tmark_inode_dirty(dir);\ncleanup:\n\tkfree(slots);\n\treturn err;\n}\n\nstatic int vfat_find(struct inode *dir, const struct qstr *qname,\n\t\t     struct fat_slot_info *sinfo)\n{\n\tunsigned int len = vfat_striptail_len(qname);\n\tif (len == 0)\n\t\treturn -ENOENT;\n\treturn fat_search_long(dir, qname->name, len, sinfo);\n}\n\nstatic struct dentry *vfat_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t  unsigned int flags)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct fat_slot_info sinfo;\n\tstruct inode *inode;\n\tstruct dentry *alias;\n\tint err;\n\n\tmutex_lock(&MSDOS_SB(sb)->s_lock);\n\n\terr = vfat_find(dir, &dentry->d_name, &sinfo);\n\tif (err) {\n\t\tif (err == -ENOENT) {\n\t\t\tinode = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tgoto error;\n\t}\n\n\tinode = fat_build_inode(sb, sinfo.de, sinfo.i_pos);\n\tbrelse(sinfo.bh);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tgoto error;\n\t}\n\n\talias = d_find_alias(inode);\n\t \n\tif (alias && alias->d_parent == dentry->d_parent) {\n\t\t \n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\td_move(alias, dentry);\n\t\tiput(inode);\n\t\tmutex_unlock(&MSDOS_SB(sb)->s_lock);\n\t\treturn alias;\n\t} else\n\t\tdput(alias);\n\nout:\n\tmutex_unlock(&MSDOS_SB(sb)->s_lock);\n\tif (!inode)\n\t\tvfat_d_version_set(dentry, inode_query_iversion(dir));\n\treturn d_splice_alias(inode, dentry);\nerror:\n\tmutex_unlock(&MSDOS_SB(sb)->s_lock);\n\treturn ERR_PTR(err);\n}\n\nstatic int vfat_create(struct mnt_idmap *idmap, struct inode *dir,\n\t\t       struct dentry *dentry, umode_t mode, bool excl)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct inode *inode;\n\tstruct fat_slot_info sinfo;\n\tstruct timespec64 ts;\n\tint err;\n\n\tmutex_lock(&MSDOS_SB(sb)->s_lock);\n\n\tts = current_time(dir);\n\terr = vfat_add_entry(dir, &dentry->d_name, 0, 0, &ts, &sinfo);\n\tif (err)\n\t\tgoto out;\n\tinode_inc_iversion(dir);\n\n\tinode = fat_build_inode(sb, sinfo.de, sinfo.i_pos);\n\tbrelse(sinfo.bh);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tgoto out;\n\t}\n\tinode_inc_iversion(inode);\n\n\td_instantiate(dentry, inode);\nout:\n\tmutex_unlock(&MSDOS_SB(sb)->s_lock);\n\treturn err;\n}\n\nstatic int vfat_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct super_block *sb = dir->i_sb;\n\tstruct fat_slot_info sinfo;\n\tint err;\n\n\tmutex_lock(&MSDOS_SB(sb)->s_lock);\n\n\terr = fat_dir_empty(inode);\n\tif (err)\n\t\tgoto out;\n\terr = vfat_find(dir, &dentry->d_name, &sinfo);\n\tif (err)\n\t\tgoto out;\n\n\terr = fat_remove_entries(dir, &sinfo);\t \n\tif (err)\n\t\tgoto out;\n\tdrop_nlink(dir);\n\n\tclear_nlink(inode);\n\tfat_truncate_time(inode, NULL, S_ATIME|S_MTIME);\n\tfat_detach(inode);\n\tvfat_d_version_set(dentry, inode_query_iversion(dir));\nout:\n\tmutex_unlock(&MSDOS_SB(sb)->s_lock);\n\n\treturn err;\n}\n\nstatic int vfat_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct super_block *sb = dir->i_sb;\n\tstruct fat_slot_info sinfo;\n\tint err;\n\n\tmutex_lock(&MSDOS_SB(sb)->s_lock);\n\n\terr = vfat_find(dir, &dentry->d_name, &sinfo);\n\tif (err)\n\t\tgoto out;\n\n\terr = fat_remove_entries(dir, &sinfo);\t \n\tif (err)\n\t\tgoto out;\n\tclear_nlink(inode);\n\tfat_truncate_time(inode, NULL, S_ATIME|S_MTIME);\n\tfat_detach(inode);\n\tvfat_d_version_set(dentry, inode_query_iversion(dir));\nout:\n\tmutex_unlock(&MSDOS_SB(sb)->s_lock);\n\n\treturn err;\n}\n\nstatic int vfat_mkdir(struct mnt_idmap *idmap, struct inode *dir,\n\t\t      struct dentry *dentry, umode_t mode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct inode *inode;\n\tstruct fat_slot_info sinfo;\n\tstruct timespec64 ts;\n\tint err, cluster;\n\n\tmutex_lock(&MSDOS_SB(sb)->s_lock);\n\n\tts = current_time(dir);\n\tcluster = fat_alloc_new_dir(dir, &ts);\n\tif (cluster < 0) {\n\t\terr = cluster;\n\t\tgoto out;\n\t}\n\terr = vfat_add_entry(dir, &dentry->d_name, 1, cluster, &ts, &sinfo);\n\tif (err)\n\t\tgoto out_free;\n\tinode_inc_iversion(dir);\n\tinc_nlink(dir);\n\n\tinode = fat_build_inode(sb, sinfo.de, sinfo.i_pos);\n\tbrelse(sinfo.bh);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\t \n\t\tgoto out;\n\t}\n\tinode_inc_iversion(inode);\n\tset_nlink(inode, 2);\n\n\td_instantiate(dentry, inode);\n\n\tmutex_unlock(&MSDOS_SB(sb)->s_lock);\n\treturn 0;\n\nout_free:\n\tfat_free_clusters(dir, cluster);\nout:\n\tmutex_unlock(&MSDOS_SB(sb)->s_lock);\n\treturn err;\n}\n\nstatic int vfat_get_dotdot_de(struct inode *inode, struct buffer_head **bh,\n\t\t\t      struct msdos_dir_entry **de)\n{\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tif (fat_get_dotdot_entry(inode, bh, de))\n\t\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic int vfat_sync_ipos(struct inode *dir, struct inode *inode)\n{\n\tif (IS_DIRSYNC(dir))\n\t\treturn fat_sync_inode(inode);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}\n\nstatic int vfat_update_dotdot_de(struct inode *dir, struct inode *inode,\n\t\t\t\t struct buffer_head *dotdot_bh,\n\t\t\t\t struct msdos_dir_entry *dotdot_de)\n{\n\tfat_set_start(dotdot_de, MSDOS_I(dir)->i_logstart);\n\tmark_buffer_dirty_inode(dotdot_bh, inode);\n\tif (IS_DIRSYNC(dir))\n\t\treturn sync_dirty_buffer(dotdot_bh);\n\treturn 0;\n}\n\nstatic void vfat_update_dir_metadata(struct inode *dir, struct timespec64 *ts)\n{\n\tinode_inc_iversion(dir);\n\tfat_truncate_time(dir, ts, S_CTIME | S_MTIME);\n\tif (IS_DIRSYNC(dir))\n\t\t(void)fat_sync_inode(dir);\n\telse\n\t\tmark_inode_dirty(dir);\n}\n\nstatic int vfat_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t       struct inode *new_dir, struct dentry *new_dentry)\n{\n\tstruct buffer_head *dotdot_bh;\n\tstruct msdos_dir_entry *dotdot_de = NULL;\n\tstruct inode *old_inode, *new_inode;\n\tstruct fat_slot_info old_sinfo, sinfo;\n\tstruct timespec64 ts;\n\tloff_t new_i_pos;\n\tint err, is_dir, corrupt = 0;\n\tstruct super_block *sb = old_dir->i_sb;\n\n\told_sinfo.bh = sinfo.bh = dotdot_bh = NULL;\n\told_inode = d_inode(old_dentry);\n\tnew_inode = d_inode(new_dentry);\n\tmutex_lock(&MSDOS_SB(sb)->s_lock);\n\terr = vfat_find(old_dir, &old_dentry->d_name, &old_sinfo);\n\tif (err)\n\t\tgoto out;\n\n\tif (old_dir != new_dir) {\n\t\terr = vfat_get_dotdot_de(old_inode, &dotdot_bh, &dotdot_de);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tis_dir = S_ISDIR(old_inode->i_mode);\n\tts = current_time(old_dir);\n\tif (new_inode) {\n\t\tif (is_dir) {\n\t\t\terr = fat_dir_empty(new_inode);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t\tnew_i_pos = MSDOS_I(new_inode)->i_pos;\n\t\tfat_detach(new_inode);\n\t} else {\n\t\terr = vfat_add_entry(new_dir, &new_dentry->d_name, is_dir, 0,\n\t\t\t\t     &ts, &sinfo);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tnew_i_pos = sinfo.i_pos;\n\t}\n\tinode_inc_iversion(new_dir);\n\n\tfat_detach(old_inode);\n\tfat_attach(old_inode, new_i_pos);\n\terr = vfat_sync_ipos(new_dir, old_inode);\n\tif (err)\n\t\tgoto error_inode;\n\n\tif (dotdot_de) {\n\t\terr = vfat_update_dotdot_de(new_dir, old_inode, dotdot_bh,\n\t\t\t\t\t    dotdot_de);\n\t\tif (err)\n\t\t\tgoto error_dotdot;\n\t\tdrop_nlink(old_dir);\n\t\tif (!new_inode)\n \t\t\tinc_nlink(new_dir);\n\t}\n\n\terr = fat_remove_entries(old_dir, &old_sinfo);\t \n\told_sinfo.bh = NULL;\n\tif (err)\n\t\tgoto error_dotdot;\n\tvfat_update_dir_metadata(old_dir, &ts);\n\n\tif (new_inode) {\n\t\tdrop_nlink(new_inode);\n\t\tif (is_dir)\n\t\t\tdrop_nlink(new_inode);\n\t\tfat_truncate_time(new_inode, &ts, S_CTIME);\n\t}\nout:\n\tbrelse(sinfo.bh);\n\tbrelse(dotdot_bh);\n\tbrelse(old_sinfo.bh);\n\tmutex_unlock(&MSDOS_SB(sb)->s_lock);\n\n\treturn err;\n\nerror_dotdot:\n\t \n\tcorrupt = 1;\n\n\tif (dotdot_de) {\n\t\tcorrupt |= vfat_update_dotdot_de(old_dir, old_inode, dotdot_bh,\n\t\t\t\t\t\t dotdot_de);\n\t}\nerror_inode:\n\tfat_detach(old_inode);\n\tfat_attach(old_inode, old_sinfo.i_pos);\n\tif (new_inode) {\n\t\tfat_attach(new_inode, new_i_pos);\n\t\tif (corrupt)\n\t\t\tcorrupt |= fat_sync_inode(new_inode);\n\t} else {\n\t\t \n\t\tint err2 = fat_remove_entries(new_dir, &sinfo);\n\t\tif (corrupt)\n\t\t\tcorrupt |= err2;\n\t\tsinfo.bh = NULL;\n\t}\n\tif (corrupt < 0) {\n\t\tfat_fs_error(new_dir->i_sb,\n\t\t\t     \"%s: Filesystem corrupted (i_pos %lld)\",\n\t\t\t     __func__, sinfo.i_pos);\n\t}\n\tgoto out;\n}\n\nstatic void vfat_exchange_ipos(struct inode *old_inode, struct inode *new_inode,\n\t\t\t       loff_t old_i_pos, loff_t new_i_pos)\n{\n\tfat_detach(old_inode);\n\tfat_detach(new_inode);\n\tfat_attach(old_inode, new_i_pos);\n\tfat_attach(new_inode, old_i_pos);\n}\n\nstatic void vfat_move_nlink(struct inode *src, struct inode *dst)\n{\n\tdrop_nlink(src);\n\tinc_nlink(dst);\n}\n\nstatic int vfat_rename_exchange(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\t\tstruct inode *new_dir, struct dentry *new_dentry)\n{\n\tstruct buffer_head *old_dotdot_bh = NULL, *new_dotdot_bh = NULL;\n\tstruct msdos_dir_entry *old_dotdot_de = NULL, *new_dotdot_de = NULL;\n\tstruct inode *old_inode, *new_inode;\n\tstruct timespec64 ts = current_time(old_dir);\n\tloff_t old_i_pos, new_i_pos;\n\tint err, corrupt = 0;\n\tstruct super_block *sb = old_dir->i_sb;\n\n\told_inode = d_inode(old_dentry);\n\tnew_inode = d_inode(new_dentry);\n\n\t \n\tmutex_lock(&MSDOS_SB(sb)->s_lock);\n\n\t \n\tif (old_dir != new_dir) {\n\t\terr = vfat_get_dotdot_de(old_inode, &old_dotdot_bh,\n\t\t\t\t\t &old_dotdot_de);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = vfat_get_dotdot_de(new_inode, &new_dotdot_bh,\n\t\t\t\t\t &new_dotdot_de);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\told_i_pos = MSDOS_I(old_inode)->i_pos;\n\tnew_i_pos = MSDOS_I(new_inode)->i_pos;\n\n\tvfat_exchange_ipos(old_inode, new_inode, old_i_pos, new_i_pos);\n\n\terr = vfat_sync_ipos(old_dir, new_inode);\n\tif (err)\n\t\tgoto error_exchange;\n\terr = vfat_sync_ipos(new_dir, old_inode);\n\tif (err)\n\t\tgoto error_exchange;\n\n\t \n\tif (old_dotdot_de) {\n\t\terr = vfat_update_dotdot_de(new_dir, old_inode, old_dotdot_bh,\n\t\t\t\t\t    old_dotdot_de);\n\t\tif (err)\n\t\t\tgoto error_old_dotdot;\n\t}\n\tif (new_dotdot_de) {\n\t\terr = vfat_update_dotdot_de(old_dir, new_inode, new_dotdot_bh,\n\t\t\t\t\t    new_dotdot_de);\n\t\tif (err)\n\t\t\tgoto error_new_dotdot;\n\t}\n\n\t \n\tif (!old_dotdot_de != !new_dotdot_de) {\n\t\tif (old_dotdot_de)\n\t\t\tvfat_move_nlink(old_dir, new_dir);\n\t\telse\n\t\t\tvfat_move_nlink(new_dir, old_dir);\n\t}\n\n\tvfat_update_dir_metadata(old_dir, &ts);\n\t \n\tif (old_dir != new_dir)\n\t\tvfat_update_dir_metadata(new_dir, &ts);\n\nout:\n\tbrelse(old_dotdot_bh);\n\tbrelse(new_dotdot_bh);\n\tmutex_unlock(&MSDOS_SB(sb)->s_lock);\n\n\treturn err;\n\nerror_new_dotdot:\n\tif (new_dotdot_de) {\n\t\tcorrupt |= vfat_update_dotdot_de(new_dir, new_inode,\n\t\t\t\t\t\t new_dotdot_bh, new_dotdot_de);\n\t}\n\nerror_old_dotdot:\n\tif (old_dotdot_de) {\n\t\tcorrupt |= vfat_update_dotdot_de(old_dir, old_inode,\n\t\t\t\t\t\t old_dotdot_bh, old_dotdot_de);\n\t}\n\nerror_exchange:\n\tvfat_exchange_ipos(old_inode, new_inode, new_i_pos, old_i_pos);\n\tcorrupt |= vfat_sync_ipos(new_dir, new_inode);\n\tcorrupt |= vfat_sync_ipos(old_dir, old_inode);\n\n\tif (corrupt < 0) {\n\t\tfat_fs_error(new_dir->i_sb,\n\t\t\t     \"%s: Filesystem corrupted (i_pos %lld, %lld)\",\n\t\t\t     __func__, old_i_pos, new_i_pos);\n\t}\n\tgoto out;\n}\n\nstatic int vfat_rename2(struct mnt_idmap *idmap, struct inode *old_dir,\n\t\t\tstruct dentry *old_dentry, struct inode *new_dir,\n\t\t\tstruct dentry *new_dentry, unsigned int flags)\n{\n\tif (flags & ~(RENAME_NOREPLACE | RENAME_EXCHANGE))\n\t\treturn -EINVAL;\n\n\tif (flags & RENAME_EXCHANGE) {\n\t\treturn vfat_rename_exchange(old_dir, old_dentry,\n\t\t\t\t\t    new_dir, new_dentry);\n\t}\n\n\t \n\treturn vfat_rename(old_dir, old_dentry, new_dir, new_dentry);\n}\n\nstatic const struct inode_operations vfat_dir_inode_operations = {\n\t.create\t\t= vfat_create,\n\t.lookup\t\t= vfat_lookup,\n\t.unlink\t\t= vfat_unlink,\n\t.mkdir\t\t= vfat_mkdir,\n\t.rmdir\t\t= vfat_rmdir,\n\t.rename\t\t= vfat_rename2,\n\t.setattr\t= fat_setattr,\n\t.getattr\t= fat_getattr,\n\t.update_time\t= fat_update_time,\n};\n\nstatic void setup(struct super_block *sb)\n{\n\tMSDOS_SB(sb)->dir_ops = &vfat_dir_inode_operations;\n\tif (MSDOS_SB(sb)->options.name_check != 's')\n\t\tsb->s_d_op = &vfat_ci_dentry_ops;\n\telse\n\t\tsb->s_d_op = &vfat_dentry_ops;\n}\n\nstatic int vfat_fill_super(struct super_block *sb, void *data, int silent)\n{\n\treturn fat_fill_super(sb, data, silent, 1, setup);\n}\n\nstatic struct dentry *vfat_mount(struct file_system_type *fs_type,\n\t\t       int flags, const char *dev_name,\n\t\t       void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, vfat_fill_super);\n}\n\nstatic struct file_system_type vfat_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"vfat\",\n\t.mount\t\t= vfat_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV | FS_ALLOW_IDMAP,\n};\nMODULE_ALIAS_FS(\"vfat\");\n\nstatic int __init init_vfat_fs(void)\n{\n\treturn register_filesystem(&vfat_fs_type);\n}\n\nstatic void __exit exit_vfat_fs(void)\n{\n\tunregister_filesystem(&vfat_fs_type);\n}\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"VFAT filesystem support\");\nMODULE_AUTHOR(\"Gordon Chaffee\");\n\nmodule_init(init_vfat_fs)\nmodule_exit(exit_vfat_fs)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}