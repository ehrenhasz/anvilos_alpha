{
  "module_name": "cache.c",
  "hash_id": "c2215e36bbbdc3e047d216637b99f43cdbcaab69ca2f7b66ba4d56109857174e",
  "original_prompt": "Ingested from linux-6.6.14/fs/fat/cache.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include \"fat.h\"\n\n \n#define FAT_MAX_CACHE\t8\n\nstruct fat_cache {\n\tstruct list_head cache_list;\n\tint nr_contig;\t \n\tint fcluster;\t \n\tint dcluster;\t \n};\n\nstruct fat_cache_id {\n\tunsigned int id;\n\tint nr_contig;\n\tint fcluster;\n\tint dcluster;\n};\n\nstatic inline int fat_max_cache(struct inode *inode)\n{\n\treturn FAT_MAX_CACHE;\n}\n\nstatic struct kmem_cache *fat_cache_cachep;\n\nstatic void init_once(void *foo)\n{\n\tstruct fat_cache *cache = (struct fat_cache *)foo;\n\n\tINIT_LIST_HEAD(&cache->cache_list);\n}\n\nint __init fat_cache_init(void)\n{\n\tfat_cache_cachep = kmem_cache_create(\"fat_cache\",\n\t\t\t\tsizeof(struct fat_cache),\n\t\t\t\t0, SLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD,\n\t\t\t\tinit_once);\n\tif (fat_cache_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nvoid fat_cache_destroy(void)\n{\n\tkmem_cache_destroy(fat_cache_cachep);\n}\n\nstatic inline struct fat_cache *fat_cache_alloc(struct inode *inode)\n{\n\treturn kmem_cache_alloc(fat_cache_cachep, GFP_NOFS);\n}\n\nstatic inline void fat_cache_free(struct fat_cache *cache)\n{\n\tBUG_ON(!list_empty(&cache->cache_list));\n\tkmem_cache_free(fat_cache_cachep, cache);\n}\n\nstatic inline void fat_cache_update_lru(struct inode *inode,\n\t\t\t\t\tstruct fat_cache *cache)\n{\n\tif (MSDOS_I(inode)->cache_lru.next != &cache->cache_list)\n\t\tlist_move(&cache->cache_list, &MSDOS_I(inode)->cache_lru);\n}\n\nstatic int fat_cache_lookup(struct inode *inode, int fclus,\n\t\t\t    struct fat_cache_id *cid,\n\t\t\t    int *cached_fclus, int *cached_dclus)\n{\n\tstatic struct fat_cache nohit = { .fcluster = 0, };\n\n\tstruct fat_cache *hit = &nohit, *p;\n\tint offset = -1;\n\n\tspin_lock(&MSDOS_I(inode)->cache_lru_lock);\n\tlist_for_each_entry(p, &MSDOS_I(inode)->cache_lru, cache_list) {\n\t\t \n\t\tif (p->fcluster <= fclus && hit->fcluster < p->fcluster) {\n\t\t\thit = p;\n\t\t\tif ((hit->fcluster + hit->nr_contig) < fclus) {\n\t\t\t\toffset = hit->nr_contig;\n\t\t\t} else {\n\t\t\t\toffset = fclus - hit->fcluster;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (hit != &nohit) {\n\t\tfat_cache_update_lru(inode, hit);\n\n\t\tcid->id = MSDOS_I(inode)->cache_valid_id;\n\t\tcid->nr_contig = hit->nr_contig;\n\t\tcid->fcluster = hit->fcluster;\n\t\tcid->dcluster = hit->dcluster;\n\t\t*cached_fclus = cid->fcluster + offset;\n\t\t*cached_dclus = cid->dcluster + offset;\n\t}\n\tspin_unlock(&MSDOS_I(inode)->cache_lru_lock);\n\n\treturn offset;\n}\n\nstatic struct fat_cache *fat_cache_merge(struct inode *inode,\n\t\t\t\t\t struct fat_cache_id *new)\n{\n\tstruct fat_cache *p;\n\n\tlist_for_each_entry(p, &MSDOS_I(inode)->cache_lru, cache_list) {\n\t\t \n\t\tif (p->fcluster == new->fcluster) {\n\t\t\tBUG_ON(p->dcluster != new->dcluster);\n\t\t\tif (new->nr_contig > p->nr_contig)\n\t\t\t\tp->nr_contig = new->nr_contig;\n\t\t\treturn p;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic void fat_cache_add(struct inode *inode, struct fat_cache_id *new)\n{\n\tstruct fat_cache *cache, *tmp;\n\n\tif (new->fcluster == -1)  \n\t\treturn;\n\n\tspin_lock(&MSDOS_I(inode)->cache_lru_lock);\n\tif (new->id != FAT_CACHE_VALID &&\n\t    new->id != MSDOS_I(inode)->cache_valid_id)\n\t\tgoto out;\t \n\n\tcache = fat_cache_merge(inode, new);\n\tif (cache == NULL) {\n\t\tif (MSDOS_I(inode)->nr_caches < fat_max_cache(inode)) {\n\t\t\tMSDOS_I(inode)->nr_caches++;\n\t\t\tspin_unlock(&MSDOS_I(inode)->cache_lru_lock);\n\n\t\t\ttmp = fat_cache_alloc(inode);\n\t\t\tif (!tmp) {\n\t\t\t\tspin_lock(&MSDOS_I(inode)->cache_lru_lock);\n\t\t\t\tMSDOS_I(inode)->nr_caches--;\n\t\t\t\tspin_unlock(&MSDOS_I(inode)->cache_lru_lock);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tspin_lock(&MSDOS_I(inode)->cache_lru_lock);\n\t\t\tcache = fat_cache_merge(inode, new);\n\t\t\tif (cache != NULL) {\n\t\t\t\tMSDOS_I(inode)->nr_caches--;\n\t\t\t\tfat_cache_free(tmp);\n\t\t\t\tgoto out_update_lru;\n\t\t\t}\n\t\t\tcache = tmp;\n\t\t} else {\n\t\t\tstruct list_head *p = MSDOS_I(inode)->cache_lru.prev;\n\t\t\tcache = list_entry(p, struct fat_cache, cache_list);\n\t\t}\n\t\tcache->fcluster = new->fcluster;\n\t\tcache->dcluster = new->dcluster;\n\t\tcache->nr_contig = new->nr_contig;\n\t}\nout_update_lru:\n\tfat_cache_update_lru(inode, cache);\nout:\n\tspin_unlock(&MSDOS_I(inode)->cache_lru_lock);\n}\n\n \nstatic void __fat_cache_inval_inode(struct inode *inode)\n{\n\tstruct msdos_inode_info *i = MSDOS_I(inode);\n\tstruct fat_cache *cache;\n\n\twhile (!list_empty(&i->cache_lru)) {\n\t\tcache = list_entry(i->cache_lru.next,\n\t\t\t\t   struct fat_cache, cache_list);\n\t\tlist_del_init(&cache->cache_list);\n\t\ti->nr_caches--;\n\t\tfat_cache_free(cache);\n\t}\n\t \n\ti->cache_valid_id++;\n\tif (i->cache_valid_id == FAT_CACHE_VALID)\n\t\ti->cache_valid_id++;\n}\n\nvoid fat_cache_inval_inode(struct inode *inode)\n{\n\tspin_lock(&MSDOS_I(inode)->cache_lru_lock);\n\t__fat_cache_inval_inode(inode);\n\tspin_unlock(&MSDOS_I(inode)->cache_lru_lock);\n}\n\nstatic inline int cache_contiguous(struct fat_cache_id *cid, int dclus)\n{\n\tcid->nr_contig++;\n\treturn ((cid->dcluster + cid->nr_contig) == dclus);\n}\n\nstatic inline void cache_init(struct fat_cache_id *cid, int fclus, int dclus)\n{\n\tcid->id = FAT_CACHE_VALID;\n\tcid->fcluster = fclus;\n\tcid->dcluster = dclus;\n\tcid->nr_contig = 0;\n}\n\nint fat_get_cluster(struct inode *inode, int cluster, int *fclus, int *dclus)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tconst int limit = sb->s_maxbytes >> sbi->cluster_bits;\n\tstruct fat_entry fatent;\n\tstruct fat_cache_id cid;\n\tint nr;\n\n\tBUG_ON(MSDOS_I(inode)->i_start == 0);\n\n\t*fclus = 0;\n\t*dclus = MSDOS_I(inode)->i_start;\n\tif (!fat_valid_entry(sbi, *dclus)) {\n\t\tfat_fs_error_ratelimit(sb,\n\t\t\t\"%s: invalid start cluster (i_pos %lld, start %08x)\",\n\t\t\t__func__, MSDOS_I(inode)->i_pos, *dclus);\n\t\treturn -EIO;\n\t}\n\tif (cluster == 0)\n\t\treturn 0;\n\n\tif (fat_cache_lookup(inode, cluster, &cid, fclus, dclus) < 0) {\n\t\t \n\t\tcache_init(&cid, -1, -1);\n\t}\n\n\tfatent_init(&fatent);\n\twhile (*fclus < cluster) {\n\t\t \n\t\tif (*fclus > limit) {\n\t\t\tfat_fs_error_ratelimit(sb,\n\t\t\t\t\"%s: detected the cluster chain loop (i_pos %lld)\",\n\t\t\t\t__func__, MSDOS_I(inode)->i_pos);\n\t\t\tnr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\tnr = fat_ent_read(inode, &fatent, *dclus);\n\t\tif (nr < 0)\n\t\t\tgoto out;\n\t\telse if (nr == FAT_ENT_FREE) {\n\t\t\tfat_fs_error_ratelimit(sb,\n\t\t\t\t\"%s: invalid cluster chain (i_pos %lld)\",\n\t\t\t\t__func__, MSDOS_I(inode)->i_pos);\n\t\t\tnr = -EIO;\n\t\t\tgoto out;\n\t\t} else if (nr == FAT_ENT_EOF) {\n\t\t\tfat_cache_add(inode, &cid);\n\t\t\tgoto out;\n\t\t}\n\t\t(*fclus)++;\n\t\t*dclus = nr;\n\t\tif (!cache_contiguous(&cid, *dclus))\n\t\t\tcache_init(&cid, *fclus, *dclus);\n\t}\n\tnr = 0;\n\tfat_cache_add(inode, &cid);\nout:\n\tfatent_brelse(&fatent);\n\treturn nr;\n}\n\nstatic int fat_bmap_cluster(struct inode *inode, int cluster)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint ret, fclus, dclus;\n\n\tif (MSDOS_I(inode)->i_start == 0)\n\t\treturn 0;\n\n\tret = fat_get_cluster(inode, cluster, &fclus, &dclus);\n\tif (ret < 0)\n\t\treturn ret;\n\telse if (ret == FAT_ENT_EOF) {\n\t\tfat_fs_error(sb, \"%s: request beyond EOF (i_pos %lld)\",\n\t\t\t     __func__, MSDOS_I(inode)->i_pos);\n\t\treturn -EIO;\n\t}\n\treturn dclus;\n}\n\nint fat_get_mapped_cluster(struct inode *inode, sector_t sector,\n\t\t\t   sector_t last_block,\n\t\t\t   unsigned long *mapped_blocks, sector_t *bmap)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tint cluster, offset;\n\n\tcluster = sector >> (sbi->cluster_bits - sb->s_blocksize_bits);\n\toffset  = sector & (sbi->sec_per_clus - 1);\n\tcluster = fat_bmap_cluster(inode, cluster);\n\tif (cluster < 0)\n\t\treturn cluster;\n\telse if (cluster) {\n\t\t*bmap = fat_clus_to_blknr(sbi, cluster) + offset;\n\t\t*mapped_blocks = sbi->sec_per_clus - offset;\n\t\tif (*mapped_blocks > last_block - sector)\n\t\t\t*mapped_blocks = last_block - sector;\n\t}\n\n\treturn 0;\n}\n\nstatic int is_exceed_eof(struct inode *inode, sector_t sector,\n\t\t\t sector_t *last_block, int create)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tconst unsigned long blocksize = sb->s_blocksize;\n\tconst unsigned char blocksize_bits = sb->s_blocksize_bits;\n\n\t*last_block = (i_size_read(inode) + (blocksize - 1)) >> blocksize_bits;\n\tif (sector >= *last_block) {\n\t\tif (!create)\n\t\t\treturn 1;\n\n\t\t \n\t\t*last_block = (MSDOS_I(inode)->mmu_private + (blocksize - 1))\n\t\t\t>> blocksize_bits;\n\t\tif (sector >= *last_block)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nint fat_bmap(struct inode *inode, sector_t sector, sector_t *phys,\n\t     unsigned long *mapped_blocks, int create, bool from_bmap)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\tsector_t last_block;\n\n\t*phys = 0;\n\t*mapped_blocks = 0;\n\tif (!is_fat32(sbi) && (inode->i_ino == MSDOS_ROOT_INO)) {\n\t\tif (sector < (sbi->dir_entries >> sbi->dir_per_block_bits)) {\n\t\t\t*phys = sector + sbi->dir_start;\n\t\t\t*mapped_blocks = 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (!from_bmap) {\n\t\tif (is_exceed_eof(inode, sector, &last_block, create))\n\t\t\treturn 0;\n\t} else {\n\t\tlast_block = inode->i_blocks >>\n\t\t\t\t(inode->i_sb->s_blocksize_bits - 9);\n\t\tif (sector >= last_block)\n\t\t\treturn 0;\n\t}\n\n\treturn fat_get_mapped_cluster(inode, sector, last_block, mapped_blocks,\n\t\t\t\t      phys);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}