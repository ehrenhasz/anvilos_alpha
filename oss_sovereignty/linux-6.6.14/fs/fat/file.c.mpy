{
  "module_name": "file.c",
  "hash_id": "39b9e56d37a86c88fbd8253ef9e3de78c2089a087952152f8c60dc34c3c38544",
  "original_prompt": "Ingested from linux-6.6.14/fs/fat/file.c",
  "human_readable_source": "\n \n\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/falloc.h>\n#include \"fat.h\"\n\nstatic long fat_fallocate(struct file *file, int mode,\n\t\t\t  loff_t offset, loff_t len);\n\nstatic int fat_ioctl_get_attributes(struct inode *inode, u32 __user *user_attr)\n{\n\tu32 attr;\n\n\tinode_lock_shared(inode);\n\tattr = fat_make_attrs(inode);\n\tinode_unlock_shared(inode);\n\n\treturn put_user(attr, user_attr);\n}\n\nstatic int fat_ioctl_set_attributes(struct file *file, u32 __user *user_attr)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\tint is_dir = S_ISDIR(inode->i_mode);\n\tu32 attr, oldattr;\n\tstruct iattr ia;\n\tint err;\n\n\terr = get_user(attr, user_attr);\n\tif (err)\n\t\tgoto out;\n\n\terr = mnt_want_write_file(file);\n\tif (err)\n\t\tgoto out;\n\tinode_lock(inode);\n\n\t \n\tattr &= 0xff & ~(ATTR_VOLUME | ATTR_DIR);\n\t \n\tattr |= (MSDOS_I(inode)->i_attrs & ATTR_VOLUME) |\n\t\t(is_dir ? ATTR_DIR : 0);\n\toldattr = fat_make_attrs(inode);\n\n\t \n\tia.ia_valid = ATTR_MODE | ATTR_CTIME;\n\tia.ia_ctime = current_time(inode);\n\tif (is_dir)\n\t\tia.ia_mode = fat_make_mode(sbi, attr, S_IRWXUGO);\n\telse {\n\t\tia.ia_mode = fat_make_mode(sbi, attr,\n\t\t\tS_IRUGO | S_IWUGO | (inode->i_mode & S_IXUGO));\n\t}\n\n\t \n\tif (inode->i_ino == MSDOS_ROOT_INO && attr != ATTR_DIR) {\n\t\terr = -EINVAL;\n\t\tgoto out_unlock_inode;\n\t}\n\n\tif (sbi->options.sys_immutable &&\n\t    ((attr | oldattr) & ATTR_SYS) &&\n\t    !capable(CAP_LINUX_IMMUTABLE)) {\n\t\terr = -EPERM;\n\t\tgoto out_unlock_inode;\n\t}\n\n\t \n\terr = security_inode_setattr(file_mnt_idmap(file),\n\t\t\t\t     file->f_path.dentry, &ia);\n\tif (err)\n\t\tgoto out_unlock_inode;\n\n\t \n\terr = fat_setattr(file_mnt_idmap(file), file->f_path.dentry, &ia);\n\tif (err)\n\t\tgoto out_unlock_inode;\n\n\tfsnotify_change(file->f_path.dentry, ia.ia_valid);\n\tif (sbi->options.sys_immutable) {\n\t\tif (attr & ATTR_SYS)\n\t\t\tinode->i_flags |= S_IMMUTABLE;\n\t\telse\n\t\t\tinode->i_flags &= ~S_IMMUTABLE;\n\t}\n\n\tfat_save_attrs(inode, attr);\n\tmark_inode_dirty(inode);\nout_unlock_inode:\n\tinode_unlock(inode);\n\tmnt_drop_write_file(file);\nout:\n\treturn err;\n}\n\nstatic int fat_ioctl_get_volume_id(struct inode *inode, u32 __user *user_attr)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\treturn put_user(sbi->vol_id, user_attr);\n}\n\nstatic int fat_ioctl_fitrim(struct inode *inode, unsigned long arg)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct fstrim_range __user *user_range;\n\tstruct fstrim_range range;\n\tint err;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!bdev_max_discard_sectors(sb->s_bdev))\n\t\treturn -EOPNOTSUPP;\n\n\tuser_range = (struct fstrim_range __user *)arg;\n\tif (copy_from_user(&range, user_range, sizeof(range)))\n\t\treturn -EFAULT;\n\n\trange.minlen = max_t(unsigned int, range.minlen,\n\t\t\t     bdev_discard_granularity(sb->s_bdev));\n\n\terr = fat_trim_fs(inode, &range);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (copy_to_user(user_range, &range, sizeof(range)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nlong fat_generic_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tu32 __user *user_attr = (u32 __user *)arg;\n\n\tswitch (cmd) {\n\tcase FAT_IOCTL_GET_ATTRIBUTES:\n\t\treturn fat_ioctl_get_attributes(inode, user_attr);\n\tcase FAT_IOCTL_SET_ATTRIBUTES:\n\t\treturn fat_ioctl_set_attributes(filp, user_attr);\n\tcase FAT_IOCTL_GET_VOLUME_ID:\n\t\treturn fat_ioctl_get_volume_id(inode, user_attr);\n\tcase FITRIM:\n\t\treturn fat_ioctl_fitrim(inode, arg);\n\tdefault:\n\t\treturn -ENOTTY;\t \n\t}\n}\n\nstatic int fat_file_release(struct inode *inode, struct file *filp)\n{\n\tif ((filp->f_mode & FMODE_WRITE) &&\n\t    MSDOS_SB(inode->i_sb)->options.flush) {\n\t\tfat_flush_inodes(inode->i_sb, inode, NULL);\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tio_schedule_timeout(HZ/10);\n\t}\n\treturn 0;\n}\n\nint fat_file_fsync(struct file *filp, loff_t start, loff_t end, int datasync)\n{\n\tstruct inode *inode = filp->f_mapping->host;\n\tint err;\n\n\terr = __generic_file_fsync(filp, start, end, datasync);\n\tif (err)\n\t\treturn err;\n\n\terr = sync_mapping_buffers(MSDOS_SB(inode->i_sb)->fat_inode->i_mapping);\n\tif (err)\n\t\treturn err;\n\n\treturn blkdev_issue_flush(inode->i_sb->s_bdev);\n}\n\n\nconst struct file_operations fat_file_operations = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read_iter\t= generic_file_read_iter,\n\t.write_iter\t= generic_file_write_iter,\n\t.mmap\t\t= generic_file_mmap,\n\t.release\t= fat_file_release,\n\t.unlocked_ioctl\t= fat_generic_ioctl,\n\t.compat_ioctl\t= compat_ptr_ioctl,\n\t.fsync\t\t= fat_file_fsync,\n\t.splice_read\t= filemap_splice_read,\n\t.splice_write\t= iter_file_splice_write,\n\t.fallocate\t= fat_fallocate,\n};\n\nstatic int fat_cont_expand(struct inode *inode, loff_t size)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tloff_t start = inode->i_size, count = size - inode->i_size;\n\tint err;\n\n\terr = generic_cont_expand_simple(inode, size);\n\tif (err)\n\t\tgoto out;\n\n\tfat_truncate_time(inode, NULL, S_CTIME|S_MTIME);\n\tmark_inode_dirty(inode);\n\tif (IS_SYNC(inode)) {\n\t\tint err2;\n\n\t\t \n\t\terr = filemap_fdatawrite_range(mapping, start,\n\t\t\t\t\t       start + count - 1);\n\t\terr2 = sync_mapping_buffers(mapping);\n\t\tif (!err)\n\t\t\terr = err2;\n\t\terr2 = write_inode_now(inode, 1);\n\t\tif (!err)\n\t\t\terr = err2;\n\t\tif (!err) {\n\t\t\terr =  filemap_fdatawait_range(mapping, start,\n\t\t\t\t\t\t       start + count - 1);\n\t\t}\n\t}\nout:\n\treturn err;\n}\n\n \nstatic long fat_fallocate(struct file *file, int mode,\n\t\t\t  loff_t offset, loff_t len)\n{\n\tint nr_cluster;  \n\tloff_t mm_bytes;  \n\tloff_t ondisksize;  \n\tstruct inode *inode = file->f_mapping->host;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tint err = 0;\n\n\t \n\tif (mode & ~FALLOC_FL_KEEP_SIZE)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\n\tinode_lock(inode);\n\tif (mode & FALLOC_FL_KEEP_SIZE) {\n\t\tondisksize = inode->i_blocks << 9;\n\t\tif ((offset + len) <= ondisksize)\n\t\t\tgoto error;\n\n\t\t \n\t\tmm_bytes = offset + len - ondisksize;\n\t\tnr_cluster = (mm_bytes + (sbi->cluster_size - 1)) >>\n\t\t\tsbi->cluster_bits;\n\n\t\t \n\t\twhile (nr_cluster-- > 0) {\n\t\t\terr = fat_add_cluster(inode);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\t\t}\n\t} else {\n\t\tif ((offset + len) <= i_size_read(inode))\n\t\t\tgoto error;\n\n\t\t \n\t\terr = fat_cont_expand(inode, (offset + len));\n\t}\n\nerror:\n\tinode_unlock(inode);\n\treturn err;\n}\n\n \nstatic int fat_free(struct inode *inode, int skip)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint err, wait, free_start, i_start, i_logstart;\n\n\tif (MSDOS_I(inode)->i_start == 0)\n\t\treturn 0;\n\n\tfat_cache_inval_inode(inode);\n\n\twait = IS_DIRSYNC(inode);\n\ti_start = free_start = MSDOS_I(inode)->i_start;\n\ti_logstart = MSDOS_I(inode)->i_logstart;\n\n\t \n\tif (!skip) {\n\t\tMSDOS_I(inode)->i_start = 0;\n\t\tMSDOS_I(inode)->i_logstart = 0;\n\t}\n\tMSDOS_I(inode)->i_attrs |= ATTR_ARCH;\n\tfat_truncate_time(inode, NULL, S_CTIME|S_MTIME);\n\tif (wait) {\n\t\terr = fat_sync_inode(inode);\n\t\tif (err) {\n\t\t\tMSDOS_I(inode)->i_start = i_start;\n\t\t\tMSDOS_I(inode)->i_logstart = i_logstart;\n\t\t\treturn err;\n\t\t}\n\t} else\n\t\tmark_inode_dirty(inode);\n\n\t \n\tif (skip) {\n\t\tstruct fat_entry fatent;\n\t\tint ret, fclus, dclus;\n\n\t\tret = fat_get_cluster(inode, skip - 1, &fclus, &dclus);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\telse if (ret == FAT_ENT_EOF)\n\t\t\treturn 0;\n\n\t\tfatent_init(&fatent);\n\t\tret = fat_ent_read(inode, &fatent, dclus);\n\t\tif (ret == FAT_ENT_EOF) {\n\t\t\tfatent_brelse(&fatent);\n\t\t\treturn 0;\n\t\t} else if (ret == FAT_ENT_FREE) {\n\t\t\tfat_fs_error(sb,\n\t\t\t\t     \"%s: invalid cluster chain (i_pos %lld)\",\n\t\t\t\t     __func__, MSDOS_I(inode)->i_pos);\n\t\t\tret = -EIO;\n\t\t} else if (ret > 0) {\n\t\t\terr = fat_ent_write(inode, &fatent, FAT_ENT_EOF, wait);\n\t\t\tif (err)\n\t\t\t\tret = err;\n\t\t}\n\t\tfatent_brelse(&fatent);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tfree_start = ret;\n\t}\n\tinode->i_blocks = skip << (MSDOS_SB(sb)->cluster_bits - 9);\n\n\t \n\treturn fat_free_clusters(inode, free_start);\n}\n\nvoid fat_truncate_blocks(struct inode *inode, loff_t offset)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\tconst unsigned int cluster_size = sbi->cluster_size;\n\tint nr_clusters;\n\n\t \n\tif (MSDOS_I(inode)->mmu_private > offset)\n\t\tMSDOS_I(inode)->mmu_private = offset;\n\n\tnr_clusters = (offset + (cluster_size - 1)) >> sbi->cluster_bits;\n\n\tfat_free(inode, nr_clusters);\n\tfat_flush_inodes(inode->i_sb, inode, NULL);\n}\n\nint fat_getattr(struct mnt_idmap *idmap, const struct path *path,\n\t\tstruct kstat *stat, u32 request_mask, unsigned int flags)\n{\n\tstruct inode *inode = d_inode(path->dentry);\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\n\tgeneric_fillattr(idmap, request_mask, inode, stat);\n\tstat->blksize = sbi->cluster_size;\n\n\tif (sbi->options.nfs == FAT_NFS_NOSTALE_RO) {\n\t\t \n\t\tstat->ino = fat_i_pos_read(sbi, inode);\n\t}\n\n\tif (sbi->options.isvfat && request_mask & STATX_BTIME) {\n\t\tstat->result_mask |= STATX_BTIME;\n\t\tstat->btime = MSDOS_I(inode)->i_crtime;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(fat_getattr);\n\nstatic int fat_sanitize_mode(const struct msdos_sb_info *sbi,\n\t\t\t     struct inode *inode, umode_t *mode_ptr)\n{\n\tumode_t mask, perm;\n\n\t \n\n\tif (S_ISREG(inode->i_mode))\n\t\tmask = sbi->options.fs_fmask;\n\telse\n\t\tmask = sbi->options.fs_dmask;\n\n\tperm = *mode_ptr & ~(S_IFMT | mask);\n\n\t \n\tif ((perm & (S_IRUGO | S_IXUGO)) != (inode->i_mode & (S_IRUGO|S_IXUGO)))\n\t\treturn -EPERM;\n\tif (fat_mode_can_hold_ro(inode)) {\n\t\tif ((perm & S_IWUGO) && ((perm & S_IWUGO) != (S_IWUGO & ~mask)))\n\t\t\treturn -EPERM;\n\t} else {\n\t\tif ((perm & S_IWUGO) != (S_IWUGO & ~mask))\n\t\t\treturn -EPERM;\n\t}\n\n\t*mode_ptr &= S_IFMT | perm;\n\n\treturn 0;\n}\n\nstatic int fat_allow_set_time(struct mnt_idmap *idmap,\n\t\t\t      struct msdos_sb_info *sbi, struct inode *inode)\n{\n\tumode_t allow_utime = sbi->options.allow_utime;\n\n\tif (!vfsuid_eq_kuid(i_uid_into_vfsuid(idmap, inode),\n\t\t\t    current_fsuid())) {\n\t\tif (vfsgid_in_group_p(i_gid_into_vfsgid(idmap, inode)))\n\t\t\tallow_utime >>= 3;\n\t\tif (allow_utime & MAY_WRITE)\n\t\t\treturn 1;\n\t}\n\n\t \n\treturn 0;\n}\n\n#define TIMES_SET_FLAGS\t(ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)\n \n#define FAT_VALID_MODE\t(S_IFREG | S_IFDIR | S_IRWXUGO)\n\nint fat_setattr(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\tstruct iattr *attr)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(dentry->d_sb);\n\tstruct inode *inode = d_inode(dentry);\n\tunsigned int ia_valid;\n\tint error;\n\n\t \n\tia_valid = attr->ia_valid;\n\tif (ia_valid & TIMES_SET_FLAGS) {\n\t\tif (fat_allow_set_time(idmap, sbi, inode))\n\t\t\tattr->ia_valid &= ~TIMES_SET_FLAGS;\n\t}\n\n\terror = setattr_prepare(idmap, dentry, attr);\n\tattr->ia_valid = ia_valid;\n\tif (error) {\n\t\tif (sbi->options.quiet)\n\t\t\terror = 0;\n\t\tgoto out;\n\t}\n\n\t \n\tif (attr->ia_valid & ATTR_SIZE) {\n\t\tinode_dio_wait(inode);\n\n\t\tif (attr->ia_size > inode->i_size) {\n\t\t\terror = fat_cont_expand(inode, attr->ia_size);\n\t\t\tif (error || attr->ia_valid == ATTR_SIZE)\n\t\t\t\tgoto out;\n\t\t\tattr->ia_valid &= ~ATTR_SIZE;\n\t\t}\n\t}\n\n\tif (((attr->ia_valid & ATTR_UID) &&\n\t     (!uid_eq(from_vfsuid(idmap, i_user_ns(inode), attr->ia_vfsuid),\n\t\t      sbi->options.fs_uid))) ||\n\t    ((attr->ia_valid & ATTR_GID) &&\n\t     (!gid_eq(from_vfsgid(idmap, i_user_ns(inode), attr->ia_vfsgid),\n\t\t      sbi->options.fs_gid))) ||\n\t    ((attr->ia_valid & ATTR_MODE) &&\n\t     (attr->ia_mode & ~FAT_VALID_MODE)))\n\t\terror = -EPERM;\n\n\tif (error) {\n\t\tif (sbi->options.quiet)\n\t\t\terror = 0;\n\t\tgoto out;\n\t}\n\n\t \n\tif (attr->ia_valid & ATTR_MODE) {\n\t\tif (fat_sanitize_mode(sbi, inode, &attr->ia_mode) < 0)\n\t\t\tattr->ia_valid &= ~ATTR_MODE;\n\t}\n\n\tif (attr->ia_valid & ATTR_SIZE) {\n\t\terror = fat_block_truncate_page(inode, attr->ia_size);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tdown_write(&MSDOS_I(inode)->truncate_lock);\n\t\ttruncate_setsize(inode, attr->ia_size);\n\t\tfat_truncate_blocks(inode, attr->ia_size);\n\t\tup_write(&MSDOS_I(inode)->truncate_lock);\n\t}\n\n\t \n\tif (attr->ia_valid & ATTR_ATIME)\n\t\tfat_truncate_time(inode, &attr->ia_atime, S_ATIME);\n\tif (attr->ia_valid & ATTR_CTIME)\n\t\tfat_truncate_time(inode, &attr->ia_ctime, S_CTIME);\n\tif (attr->ia_valid & ATTR_MTIME)\n\t\tfat_truncate_time(inode, &attr->ia_mtime, S_MTIME);\n\tattr->ia_valid &= ~(ATTR_ATIME|ATTR_CTIME|ATTR_MTIME);\n\n\tsetattr_copy(idmap, inode, attr);\n\tmark_inode_dirty(inode);\nout:\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(fat_setattr);\n\nconst struct inode_operations fat_file_inode_operations = {\n\t.setattr\t= fat_setattr,\n\t.getattr\t= fat_getattr,\n\t.update_time\t= fat_update_time,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}