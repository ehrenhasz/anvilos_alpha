{
  "module_name": "inode.c",
  "hash_id": "c2d7acb933ed0f8e5a5e7460e7f661c8e3688323e2516767ddd374bd72ddc16d",
  "original_prompt": "Ingested from linux-6.6.14/fs/fat/inode.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/vfs.h>\n#include <linux/seq_file.h>\n#include <linux/parser.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/random.h>\n#include <linux/iversion.h>\n#include \"fat.h\"\n\n#ifndef CONFIG_FAT_DEFAULT_IOCHARSET\n \n#define CONFIG_FAT_DEFAULT_IOCHARSET\t\"\"\n#endif\n\n#define KB_IN_SECTORS 2\n\n \n#define FAT_DATE_MIN (0<<9 | 1<<5 | 1)\n#define FAT_DATE_MAX (127<<9 | 12<<5 | 31)\n#define FAT_TIME_MAX (23<<11 | 59<<5 | 29)\n\n \nstruct fat_bios_param_block {\n\tu16\tfat_sector_size;\n\tu8\tfat_sec_per_clus;\n\tu16\tfat_reserved;\n\tu8\tfat_fats;\n\tu16\tfat_dir_entries;\n\tu16\tfat_sectors;\n\tu16\tfat_fat_length;\n\tu32\tfat_total_sect;\n\n\tu8\tfat16_state;\n\tu32\tfat16_vol_id;\n\n\tu32\tfat32_length;\n\tu32\tfat32_root_cluster;\n\tu16\tfat32_info_sector;\n\tu8\tfat32_state;\n\tu32\tfat32_vol_id;\n};\n\nstatic int fat_default_codepage = CONFIG_FAT_DEFAULT_CODEPAGE;\nstatic char fat_default_iocharset[] = CONFIG_FAT_DEFAULT_IOCHARSET;\n\nstatic struct fat_floppy_defaults {\n\tunsigned nr_sectors;\n\tunsigned sec_per_clus;\n\tunsigned dir_entries;\n\tunsigned media;\n\tunsigned fat_length;\n} floppy_defaults[] = {\n{\n\t.nr_sectors = 160 * KB_IN_SECTORS,\n\t.sec_per_clus = 1,\n\t.dir_entries = 64,\n\t.media = 0xFE,\n\t.fat_length = 1,\n},\n{\n\t.nr_sectors = 180 * KB_IN_SECTORS,\n\t.sec_per_clus = 1,\n\t.dir_entries = 64,\n\t.media = 0xFC,\n\t.fat_length = 2,\n},\n{\n\t.nr_sectors = 320 * KB_IN_SECTORS,\n\t.sec_per_clus = 2,\n\t.dir_entries = 112,\n\t.media = 0xFF,\n\t.fat_length = 1,\n},\n{\n\t.nr_sectors = 360 * KB_IN_SECTORS,\n\t.sec_per_clus = 2,\n\t.dir_entries = 112,\n\t.media = 0xFD,\n\t.fat_length = 2,\n},\n};\n\nint fat_add_cluster(struct inode *inode)\n{\n\tint err, cluster;\n\n\terr = fat_alloc_clusters(inode, &cluster, 1);\n\tif (err)\n\t\treturn err;\n\t \n\terr = fat_chain_add(inode, cluster, 1);\n\tif (err)\n\t\tfat_free_clusters(inode, cluster);\n\treturn err;\n}\n\nstatic inline int __fat_get_block(struct inode *inode, sector_t iblock,\n\t\t\t\t  unsigned long *max_blocks,\n\t\t\t\t  struct buffer_head *bh_result, int create)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tunsigned long mapped_blocks;\n\tsector_t phys, last_block;\n\tint err, offset;\n\n\terr = fat_bmap(inode, iblock, &phys, &mapped_blocks, create, false);\n\tif (err)\n\t\treturn err;\n\tif (phys) {\n\t\tmap_bh(bh_result, sb, phys);\n\t\t*max_blocks = min(mapped_blocks, *max_blocks);\n\t\treturn 0;\n\t}\n\tif (!create)\n\t\treturn 0;\n\n\tif (iblock != MSDOS_I(inode)->mmu_private >> sb->s_blocksize_bits) {\n\t\tfat_fs_error(sb, \"corrupted file size (i_pos %lld, %lld)\",\n\t\t\tMSDOS_I(inode)->i_pos, MSDOS_I(inode)->mmu_private);\n\t\treturn -EIO;\n\t}\n\n\tlast_block = inode->i_blocks >> (sb->s_blocksize_bits - 9);\n\toffset = (unsigned long)iblock & (sbi->sec_per_clus - 1);\n\t \n\tif (!offset && !(iblock < last_block)) {\n\t\t \n\t\terr = fat_add_cluster(inode);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\t \n\tmapped_blocks = sbi->sec_per_clus - offset;\n\n\t*max_blocks = min(mapped_blocks, *max_blocks);\n\tMSDOS_I(inode)->mmu_private += *max_blocks << sb->s_blocksize_bits;\n\n\terr = fat_bmap(inode, iblock, &phys, &mapped_blocks, create, false);\n\tif (err)\n\t\treturn err;\n\tif (!phys) {\n\t\tfat_fs_error(sb,\n\t\t\t     \"invalid FAT chain (i_pos %lld, last_block %llu)\",\n\t\t\t     MSDOS_I(inode)->i_pos,\n\t\t\t     (unsigned long long)last_block);\n\t\treturn -EIO;\n\t}\n\n\tBUG_ON(*max_blocks != mapped_blocks);\n\tset_buffer_new(bh_result);\n\tmap_bh(bh_result, sb, phys);\n\n\treturn 0;\n}\n\nstatic int fat_get_block(struct inode *inode, sector_t iblock,\n\t\t\t struct buffer_head *bh_result, int create)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tunsigned long max_blocks = bh_result->b_size >> inode->i_blkbits;\n\tint err;\n\n\terr = __fat_get_block(inode, iblock, &max_blocks, bh_result, create);\n\tif (err)\n\t\treturn err;\n\tbh_result->b_size = max_blocks << sb->s_blocksize_bits;\n\treturn 0;\n}\n\nstatic int fat_writepages(struct address_space *mapping,\n\t\t\t  struct writeback_control *wbc)\n{\n\treturn mpage_writepages(mapping, wbc, fat_get_block);\n}\n\nstatic int fat_read_folio(struct file *file, struct folio *folio)\n{\n\treturn mpage_read_folio(folio, fat_get_block);\n}\n\nstatic void fat_readahead(struct readahead_control *rac)\n{\n\tmpage_readahead(rac, fat_get_block);\n}\n\nstatic void fat_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\tfat_truncate_blocks(inode, inode->i_size);\n\t}\n}\n\nstatic int fat_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len,\n\t\t\tstruct page **pagep, void **fsdata)\n{\n\tint err;\n\n\t*pagep = NULL;\n\terr = cont_write_begin(file, mapping, pos, len,\n\t\t\t\tpagep, fsdata, fat_get_block,\n\t\t\t\t&MSDOS_I(mapping->host)->mmu_private);\n\tif (err < 0)\n\t\tfat_write_failed(mapping, pos + len);\n\treturn err;\n}\n\nstatic int fat_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *pagep, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tint err;\n\terr = generic_write_end(file, mapping, pos, len, copied, pagep, fsdata);\n\tif (err < len)\n\t\tfat_write_failed(mapping, pos + len);\n\tif (!(err < 0) && !(MSDOS_I(inode)->i_attrs & ATTR_ARCH)) {\n\t\tfat_truncate_time(inode, NULL, S_CTIME|S_MTIME);\n\t\tMSDOS_I(inode)->i_attrs |= ATTR_ARCH;\n\t\tmark_inode_dirty(inode);\n\t}\n\treturn err;\n}\n\nstatic ssize_t fat_direct_IO(struct kiocb *iocb, struct iov_iter *iter)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tsize_t count = iov_iter_count(iter);\n\tloff_t offset = iocb->ki_pos;\n\tssize_t ret;\n\n\tif (iov_iter_rw(iter) == WRITE) {\n\t\t \n\t\tloff_t size = offset + count;\n\t\tif (MSDOS_I(inode)->mmu_private < size)\n\t\t\treturn 0;\n\t}\n\n\t \n\tret = blockdev_direct_IO(iocb, inode, iter, fat_get_block);\n\tif (ret < 0 && iov_iter_rw(iter) == WRITE)\n\t\tfat_write_failed(mapping, offset + count);\n\n\treturn ret;\n}\n\nstatic int fat_get_block_bmap(struct inode *inode, sector_t iblock,\n\t\tstruct buffer_head *bh_result, int create)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tunsigned long max_blocks = bh_result->b_size >> inode->i_blkbits;\n\tint err;\n\tsector_t bmap;\n\tunsigned long mapped_blocks;\n\n\tBUG_ON(create != 0);\n\n\terr = fat_bmap(inode, iblock, &bmap, &mapped_blocks, create, true);\n\tif (err)\n\t\treturn err;\n\n\tif (bmap) {\n\t\tmap_bh(bh_result, sb, bmap);\n\t\tmax_blocks = min(mapped_blocks, max_blocks);\n\t}\n\n\tbh_result->b_size = max_blocks << sb->s_blocksize_bits;\n\n\treturn 0;\n}\n\nstatic sector_t _fat_bmap(struct address_space *mapping, sector_t block)\n{\n\tsector_t blocknr;\n\n\t \n\tdown_read(&MSDOS_I(mapping->host)->truncate_lock);\n\tblocknr = generic_block_bmap(mapping, block, fat_get_block_bmap);\n\tup_read(&MSDOS_I(mapping->host)->truncate_lock);\n\n\treturn blocknr;\n}\n\n \nint fat_block_truncate_page(struct inode *inode, loff_t from)\n{\n\treturn block_truncate_page(inode->i_mapping, from, fat_get_block);\n}\n\nstatic const struct address_space_operations fat_aops = {\n\t.dirty_folio\t= block_dirty_folio,\n\t.invalidate_folio = block_invalidate_folio,\n\t.read_folio\t= fat_read_folio,\n\t.readahead\t= fat_readahead,\n\t.writepages\t= fat_writepages,\n\t.write_begin\t= fat_write_begin,\n\t.write_end\t= fat_write_end,\n\t.direct_IO\t= fat_direct_IO,\n\t.bmap\t\t= _fat_bmap,\n\t.migrate_folio\t= buffer_migrate_folio,\n};\n\n \n\nstatic void fat_hash_init(struct super_block *sb)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tint i;\n\n\tspin_lock_init(&sbi->inode_hash_lock);\n\tfor (i = 0; i < FAT_HASH_SIZE; i++)\n\t\tINIT_HLIST_HEAD(&sbi->inode_hashtable[i]);\n}\n\nstatic inline unsigned long fat_hash(loff_t i_pos)\n{\n\treturn hash_32(i_pos, FAT_HASH_BITS);\n}\n\nstatic void dir_hash_init(struct super_block *sb)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tint i;\n\n\tspin_lock_init(&sbi->dir_hash_lock);\n\tfor (i = 0; i < FAT_HASH_SIZE; i++)\n\t\tINIT_HLIST_HEAD(&sbi->dir_hashtable[i]);\n}\n\nvoid fat_attach(struct inode *inode, loff_t i_pos)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\n\tif (inode->i_ino != MSDOS_ROOT_INO) {\n\t\tstruct hlist_head *head =   sbi->inode_hashtable\n\t\t\t\t\t  + fat_hash(i_pos);\n\n\t\tspin_lock(&sbi->inode_hash_lock);\n\t\tMSDOS_I(inode)->i_pos = i_pos;\n\t\thlist_add_head(&MSDOS_I(inode)->i_fat_hash, head);\n\t\tspin_unlock(&sbi->inode_hash_lock);\n\t}\n\n\t \n\tif (S_ISDIR(inode->i_mode) && sbi->options.nfs) {\n\t\tstruct hlist_head *d_head = sbi->dir_hashtable;\n\t\td_head += fat_dir_hash(MSDOS_I(inode)->i_logstart);\n\n\t\tspin_lock(&sbi->dir_hash_lock);\n\t\thlist_add_head(&MSDOS_I(inode)->i_dir_hash, d_head);\n\t\tspin_unlock(&sbi->dir_hash_lock);\n\t}\n}\nEXPORT_SYMBOL_GPL(fat_attach);\n\nvoid fat_detach(struct inode *inode)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\tspin_lock(&sbi->inode_hash_lock);\n\tMSDOS_I(inode)->i_pos = 0;\n\thlist_del_init(&MSDOS_I(inode)->i_fat_hash);\n\tspin_unlock(&sbi->inode_hash_lock);\n\n\tif (S_ISDIR(inode->i_mode) && sbi->options.nfs) {\n\t\tspin_lock(&sbi->dir_hash_lock);\n\t\thlist_del_init(&MSDOS_I(inode)->i_dir_hash);\n\t\tspin_unlock(&sbi->dir_hash_lock);\n\t}\n}\nEXPORT_SYMBOL_GPL(fat_detach);\n\nstruct inode *fat_iget(struct super_block *sb, loff_t i_pos)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct hlist_head *head = sbi->inode_hashtable + fat_hash(i_pos);\n\tstruct msdos_inode_info *i;\n\tstruct inode *inode = NULL;\n\n\tspin_lock(&sbi->inode_hash_lock);\n\thlist_for_each_entry(i, head, i_fat_hash) {\n\t\tBUG_ON(i->vfs_inode.i_sb != sb);\n\t\tif (i->i_pos != i_pos)\n\t\t\tcontinue;\n\t\tinode = igrab(&i->vfs_inode);\n\t\tif (inode)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&sbi->inode_hash_lock);\n\treturn inode;\n}\n\nstatic int is_exec(unsigned char *extension)\n{\n\tunsigned char exe_extensions[] = \"EXECOMBAT\", *walk;\n\n\tfor (walk = exe_extensions; *walk; walk += 3)\n\t\tif (!strncmp(extension, walk, 3))\n\t\t\treturn 1;\n\treturn 0;\n}\n\nstatic int fat_calc_dir_size(struct inode *inode)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\tint ret, fclus, dclus;\n\n\tinode->i_size = 0;\n\tif (MSDOS_I(inode)->i_start == 0)\n\t\treturn 0;\n\n\tret = fat_get_cluster(inode, FAT_ENT_EOF, &fclus, &dclus);\n\tif (ret < 0)\n\t\treturn ret;\n\tinode->i_size = (fclus + 1) << sbi->cluster_bits;\n\n\treturn 0;\n}\n\nstatic int fat_validate_dir(struct inode *dir)\n{\n\tstruct super_block *sb = dir->i_sb;\n\n\tif (dir->i_nlink < 2) {\n\t\t \n\t\tfat_fs_error(sb, \"corrupted directory (invalid entries)\");\n\t\treturn -EIO;\n\t}\n\tif (MSDOS_I(dir)->i_start == 0 ||\n\t    MSDOS_I(dir)->i_start == MSDOS_SB(sb)->root_cluster) {\n\t\t \n\t\tfat_fs_error(sb, \"corrupted directory (invalid i_start)\");\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\n \nint fat_fill_inode(struct inode *inode, struct msdos_dir_entry *de)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\tint error;\n\n\tMSDOS_I(inode)->i_pos = 0;\n\tinode->i_uid = sbi->options.fs_uid;\n\tinode->i_gid = sbi->options.fs_gid;\n\tinode_inc_iversion(inode);\n\tinode->i_generation = get_random_u32();\n\n\tif ((de->attr & ATTR_DIR) && !IS_FREE(de->name)) {\n\t\tinode->i_generation &= ~1;\n\t\tinode->i_mode = fat_make_mode(sbi, de->attr, S_IRWXUGO);\n\t\tinode->i_op = sbi->dir_ops;\n\t\tinode->i_fop = &fat_dir_operations;\n\n\t\tMSDOS_I(inode)->i_start = fat_get_start(sbi, de);\n\t\tMSDOS_I(inode)->i_logstart = MSDOS_I(inode)->i_start;\n\t\terror = fat_calc_dir_size(inode);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t\tMSDOS_I(inode)->mmu_private = inode->i_size;\n\n\t\tset_nlink(inode, fat_subdirs(inode));\n\n\t\terror = fat_validate_dir(inode);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t} else {  \n\t\tinode->i_generation |= 1;\n\t\tinode->i_mode = fat_make_mode(sbi, de->attr,\n\t\t\t((sbi->options.showexec && !is_exec(de->name + 8))\n\t\t\t ? S_IRUGO|S_IWUGO : S_IRWXUGO));\n\t\tMSDOS_I(inode)->i_start = fat_get_start(sbi, de);\n\n\t\tMSDOS_I(inode)->i_logstart = MSDOS_I(inode)->i_start;\n\t\tinode->i_size = le32_to_cpu(de->size);\n\t\tinode->i_op = &fat_file_inode_operations;\n\t\tinode->i_fop = &fat_file_operations;\n\t\tinode->i_mapping->a_ops = &fat_aops;\n\t\tMSDOS_I(inode)->mmu_private = inode->i_size;\n\t}\n\tif (de->attr & ATTR_SYS) {\n\t\tif (sbi->options.sys_immutable)\n\t\t\tinode->i_flags |= S_IMMUTABLE;\n\t}\n\tfat_save_attrs(inode, de->attr);\n\n\tinode->i_blocks = ((inode->i_size + (sbi->cluster_size - 1))\n\t\t\t   & ~((loff_t)sbi->cluster_size - 1)) >> 9;\n\n\tfat_time_fat2unix(sbi, &inode->i_mtime, de->time, de->date, 0);\n\tinode_set_ctime_to_ts(inode, inode->i_mtime);\n\tif (sbi->options.isvfat) {\n\t\tfat_time_fat2unix(sbi, &inode->i_atime, 0, de->adate, 0);\n\t\tfat_time_fat2unix(sbi, &MSDOS_I(inode)->i_crtime, de->ctime,\n\t\t\t\t  de->cdate, de->ctime_cs);\n\t} else\n\t\tinode->i_atime = fat_truncate_atime(sbi, &inode->i_mtime);\n\n\treturn 0;\n}\n\nstatic inline void fat_lock_build_inode(struct msdos_sb_info *sbi)\n{\n\tif (sbi->options.nfs == FAT_NFS_NOSTALE_RO)\n\t\tmutex_lock(&sbi->nfs_build_inode_lock);\n}\n\nstatic inline void fat_unlock_build_inode(struct msdos_sb_info *sbi)\n{\n\tif (sbi->options.nfs == FAT_NFS_NOSTALE_RO)\n\t\tmutex_unlock(&sbi->nfs_build_inode_lock);\n}\n\nstruct inode *fat_build_inode(struct super_block *sb,\n\t\t\tstruct msdos_dir_entry *de, loff_t i_pos)\n{\n\tstruct inode *inode;\n\tint err;\n\n\tfat_lock_build_inode(MSDOS_SB(sb));\n\tinode = fat_iget(sb, i_pos);\n\tif (inode)\n\t\tgoto out;\n\tinode = new_inode(sb);\n\tif (!inode) {\n\t\tinode = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\tinode->i_ino = iunique(sb, MSDOS_ROOT_INO);\n\tinode_set_iversion(inode, 1);\n\terr = fat_fill_inode(inode, de);\n\tif (err) {\n\t\tiput(inode);\n\t\tinode = ERR_PTR(err);\n\t\tgoto out;\n\t}\n\tfat_attach(inode, i_pos);\n\tinsert_inode_hash(inode);\nout:\n\tfat_unlock_build_inode(MSDOS_SB(sb));\n\treturn inode;\n}\n\nEXPORT_SYMBOL_GPL(fat_build_inode);\n\nstatic int __fat_write_inode(struct inode *inode, int wait);\n\nstatic void fat_free_eofblocks(struct inode *inode)\n{\n\t \n\tif ((inode->i_blocks << 9) >\n\t\t\tround_up(MSDOS_I(inode)->mmu_private,\n\t\t\t\tMSDOS_SB(inode->i_sb)->cluster_size)) {\n\t\tint err;\n\n\t\tfat_truncate_blocks(inode, MSDOS_I(inode)->mmu_private);\n\t\t \n\t\terr = __fat_write_inode(inode, inode_needs_sync(inode));\n\t\tif (err) {\n\t\t\tfat_msg(inode->i_sb, KERN_WARNING, \"Failed to \"\n\t\t\t\t\t\"update on disk inode for unused \"\n\t\t\t\t\t\"fallocated blocks, inode could be \"\n\t\t\t\t\t\"corrupted. Please run fsck\");\n\t\t}\n\n\t}\n}\n\nstatic void fat_evict_inode(struct inode *inode)\n{\n\ttruncate_inode_pages_final(&inode->i_data);\n\tif (!inode->i_nlink) {\n\t\tinode->i_size = 0;\n\t\tfat_truncate_blocks(inode, 0);\n\t} else\n\t\tfat_free_eofblocks(inode);\n\n\tinvalidate_inode_buffers(inode);\n\tclear_inode(inode);\n\tfat_cache_inval_inode(inode);\n\tfat_detach(inode);\n}\n\nstatic void fat_set_state(struct super_block *sb,\n\t\t\tunsigned int set, unsigned int force)\n{\n\tstruct buffer_head *bh;\n\tstruct fat_boot_sector *b;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\n\t \n\tif (sb_rdonly(sb) && !force)\n\t\treturn;\n\n\t \n\tif (sbi->dirty) {\n\t\t \n\t\tif (set)\n\t\t\tfat_msg(sb, KERN_WARNING, \"Volume was not properly \"\n\t\t\t\t\"unmounted. Some data may be corrupt. \"\n\t\t\t\t\"Please run fsck.\");\n\t\treturn;\n\t}\n\n\tbh = sb_bread(sb, 0);\n\tif (bh == NULL) {\n\t\tfat_msg(sb, KERN_ERR, \"unable to read boot sector \"\n\t\t\t\"to mark fs as dirty\");\n\t\treturn;\n\t}\n\n\tb = (struct fat_boot_sector *) bh->b_data;\n\n\tif (is_fat32(sbi)) {\n\t\tif (set)\n\t\t\tb->fat32.state |= FAT_STATE_DIRTY;\n\t\telse\n\t\t\tb->fat32.state &= ~FAT_STATE_DIRTY;\n\t} else   {\n\t\tif (set)\n\t\t\tb->fat16.state |= FAT_STATE_DIRTY;\n\t\telse\n\t\t\tb->fat16.state &= ~FAT_STATE_DIRTY;\n\t}\n\n\tmark_buffer_dirty(bh);\n\tsync_dirty_buffer(bh);\n\tbrelse(bh);\n}\n\nstatic void fat_reset_iocharset(struct fat_mount_options *opts)\n{\n\tif (opts->iocharset != fat_default_iocharset) {\n\t\t \n\t\tkfree(opts->iocharset);\n\t\topts->iocharset = fat_default_iocharset;\n\t}\n}\n\nstatic void delayed_free(struct rcu_head *p)\n{\n\tstruct msdos_sb_info *sbi = container_of(p, struct msdos_sb_info, rcu);\n\tunload_nls(sbi->nls_disk);\n\tunload_nls(sbi->nls_io);\n\tfat_reset_iocharset(&sbi->options);\n\tkfree(sbi);\n}\n\nstatic void fat_put_super(struct super_block *sb)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\n\tfat_set_state(sb, 0, 0);\n\n\tiput(sbi->fsinfo_inode);\n\tiput(sbi->fat_inode);\n\n\tcall_rcu(&sbi->rcu, delayed_free);\n}\n\nstatic struct kmem_cache *fat_inode_cachep;\n\nstatic struct inode *fat_alloc_inode(struct super_block *sb)\n{\n\tstruct msdos_inode_info *ei;\n\tei = alloc_inode_sb(sb, fat_inode_cachep, GFP_NOFS);\n\tif (!ei)\n\t\treturn NULL;\n\n\tinit_rwsem(&ei->truncate_lock);\n\t \n\tei->mmu_private = 0;\n\tei->i_start = 0;\n\tei->i_logstart = 0;\n\tei->i_attrs = 0;\n\tei->i_pos = 0;\n\tei->i_crtime.tv_sec = 0;\n\tei->i_crtime.tv_nsec = 0;\n\n\treturn &ei->vfs_inode;\n}\n\nstatic void fat_free_inode(struct inode *inode)\n{\n\tkmem_cache_free(fat_inode_cachep, MSDOS_I(inode));\n}\n\nstatic void init_once(void *foo)\n{\n\tstruct msdos_inode_info *ei = (struct msdos_inode_info *)foo;\n\n\tspin_lock_init(&ei->cache_lru_lock);\n\tei->nr_caches = 0;\n\tei->cache_valid_id = FAT_CACHE_VALID + 1;\n\tINIT_LIST_HEAD(&ei->cache_lru);\n\tINIT_HLIST_NODE(&ei->i_fat_hash);\n\tINIT_HLIST_NODE(&ei->i_dir_hash);\n\tinode_init_once(&ei->vfs_inode);\n}\n\nstatic int __init fat_init_inodecache(void)\n{\n\tfat_inode_cachep = kmem_cache_create(\"fat_inode_cache\",\n\t\t\t\t\t     sizeof(struct msdos_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD|SLAB_ACCOUNT),\n\t\t\t\t\t     init_once);\n\tif (fat_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic void __exit fat_destroy_inodecache(void)\n{\n\t \n\trcu_barrier();\n\tkmem_cache_destroy(fat_inode_cachep);\n}\n\nstatic int fat_remount(struct super_block *sb, int *flags, char *data)\n{\n\tbool new_rdonly;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\t*flags |= SB_NODIRATIME | (sbi->options.isvfat ? 0 : SB_NOATIME);\n\n\tsync_filesystem(sb);\n\n\t \n\tnew_rdonly = *flags & SB_RDONLY;\n\tif (new_rdonly != sb_rdonly(sb)) {\n\t\tif (new_rdonly)\n\t\t\tfat_set_state(sb, 0, 0);\n\t\telse\n\t\t\tfat_set_state(sb, 1, 1);\n\t}\n\treturn 0;\n}\n\nstatic int fat_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tu64 id = huge_encode_dev(sb->s_bdev->bd_dev);\n\n\t \n\tif (sbi->free_clusters == -1 || !sbi->free_clus_valid) {\n\t\tint err = fat_count_free_clusters(dentry->d_sb);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tbuf->f_type = dentry->d_sb->s_magic;\n\tbuf->f_bsize = sbi->cluster_size;\n\tbuf->f_blocks = sbi->max_cluster - FAT_START_ENT;\n\tbuf->f_bfree = sbi->free_clusters;\n\tbuf->f_bavail = sbi->free_clusters;\n\tbuf->f_fsid = u64_to_fsid(id);\n\tbuf->f_namelen =\n\t\t(sbi->options.isvfat ? FAT_LFN_LEN : 12) * NLS_MAX_CHARSET_SIZE;\n\n\treturn 0;\n}\n\nstatic int __fat_write_inode(struct inode *inode, int wait)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct buffer_head *bh;\n\tstruct msdos_dir_entry *raw_entry;\n\tloff_t i_pos;\n\tsector_t blocknr;\n\tint err, offset;\n\n\tif (inode->i_ino == MSDOS_ROOT_INO)\n\t\treturn 0;\n\nretry:\n\ti_pos = fat_i_pos_read(sbi, inode);\n\tif (!i_pos)\n\t\treturn 0;\n\n\tfat_get_blknr_offset(sbi, i_pos, &blocknr, &offset);\n\tbh = sb_bread(sb, blocknr);\n\tif (!bh) {\n\t\tfat_msg(sb, KERN_ERR, \"unable to read inode block \"\n\t\t       \"for updating (i_pos %lld)\", i_pos);\n\t\treturn -EIO;\n\t}\n\tspin_lock(&sbi->inode_hash_lock);\n\tif (i_pos != MSDOS_I(inode)->i_pos) {\n\t\tspin_unlock(&sbi->inode_hash_lock);\n\t\tbrelse(bh);\n\t\tgoto retry;\n\t}\n\n\traw_entry = &((struct msdos_dir_entry *) (bh->b_data))[offset];\n\tif (S_ISDIR(inode->i_mode))\n\t\traw_entry->size = 0;\n\telse\n\t\traw_entry->size = cpu_to_le32(inode->i_size);\n\traw_entry->attr = fat_make_attrs(inode);\n\tfat_set_start(raw_entry, MSDOS_I(inode)->i_logstart);\n\tfat_time_unix2fat(sbi, &inode->i_mtime, &raw_entry->time,\n\t\t\t  &raw_entry->date, NULL);\n\tif (sbi->options.isvfat) {\n\t\t__le16 atime;\n\t\tfat_time_unix2fat(sbi, &inode->i_atime, &atime,\n\t\t\t\t  &raw_entry->adate, NULL);\n\t\tfat_time_unix2fat(sbi, &MSDOS_I(inode)->i_crtime, &raw_entry->ctime,\n\t\t\t\t  &raw_entry->cdate, &raw_entry->ctime_cs);\n\t}\n\tspin_unlock(&sbi->inode_hash_lock);\n\tmark_buffer_dirty(bh);\n\terr = 0;\n\tif (wait)\n\t\terr = sync_dirty_buffer(bh);\n\tbrelse(bh);\n\treturn err;\n}\n\nstatic int fat_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tint err;\n\n\tif (inode->i_ino == MSDOS_FSINFO_INO) {\n\t\tstruct super_block *sb = inode->i_sb;\n\n\t\tmutex_lock(&MSDOS_SB(sb)->s_lock);\n\t\terr = fat_clusters_flush(sb);\n\t\tmutex_unlock(&MSDOS_SB(sb)->s_lock);\n\t} else\n\t\terr = __fat_write_inode(inode, wbc->sync_mode == WB_SYNC_ALL);\n\n\treturn err;\n}\n\nint fat_sync_inode(struct inode *inode)\n{\n\treturn __fat_write_inode(inode, 1);\n}\n\nEXPORT_SYMBOL_GPL(fat_sync_inode);\n\nstatic int fat_show_options(struct seq_file *m, struct dentry *root);\nstatic const struct super_operations fat_sops = {\n\t.alloc_inode\t= fat_alloc_inode,\n\t.free_inode\t= fat_free_inode,\n\t.write_inode\t= fat_write_inode,\n\t.evict_inode\t= fat_evict_inode,\n\t.put_super\t= fat_put_super,\n\t.statfs\t\t= fat_statfs,\n\t.remount_fs\t= fat_remount,\n\n\t.show_options\t= fat_show_options,\n};\n\nstatic int fat_show_options(struct seq_file *m, struct dentry *root)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(root->d_sb);\n\tstruct fat_mount_options *opts = &sbi->options;\n\tint isvfat = opts->isvfat;\n\n\tif (!uid_eq(opts->fs_uid, GLOBAL_ROOT_UID))\n\t\tseq_printf(m, \",uid=%u\",\n\t\t\t\tfrom_kuid_munged(&init_user_ns, opts->fs_uid));\n\tif (!gid_eq(opts->fs_gid, GLOBAL_ROOT_GID))\n\t\tseq_printf(m, \",gid=%u\",\n\t\t\t\tfrom_kgid_munged(&init_user_ns, opts->fs_gid));\n\tseq_printf(m, \",fmask=%04o\", opts->fs_fmask);\n\tseq_printf(m, \",dmask=%04o\", opts->fs_dmask);\n\tif (opts->allow_utime)\n\t\tseq_printf(m, \",allow_utime=%04o\", opts->allow_utime);\n\tif (sbi->nls_disk)\n\t\t \n\t\tseq_printf(m, \",codepage=%s\", &sbi->nls_disk->charset[2]);\n\tif (isvfat) {\n\t\tif (sbi->nls_io)\n\t\t\tseq_printf(m, \",iocharset=%s\", sbi->nls_io->charset);\n\n\t\tswitch (opts->shortname) {\n\t\tcase VFAT_SFN_DISPLAY_WIN95 | VFAT_SFN_CREATE_WIN95:\n\t\t\tseq_puts(m, \",shortname=win95\");\n\t\t\tbreak;\n\t\tcase VFAT_SFN_DISPLAY_WINNT | VFAT_SFN_CREATE_WINNT:\n\t\t\tseq_puts(m, \",shortname=winnt\");\n\t\t\tbreak;\n\t\tcase VFAT_SFN_DISPLAY_WINNT | VFAT_SFN_CREATE_WIN95:\n\t\t\tseq_puts(m, \",shortname=mixed\");\n\t\t\tbreak;\n\t\tcase VFAT_SFN_DISPLAY_LOWER | VFAT_SFN_CREATE_WIN95:\n\t\t\tseq_puts(m, \",shortname=lower\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tseq_puts(m, \",shortname=unknown\");\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (opts->name_check != 'n')\n\t\tseq_printf(m, \",check=%c\", opts->name_check);\n\tif (opts->usefree)\n\t\tseq_puts(m, \",usefree\");\n\tif (opts->quiet)\n\t\tseq_puts(m, \",quiet\");\n\tif (opts->showexec)\n\t\tseq_puts(m, \",showexec\");\n\tif (opts->sys_immutable)\n\t\tseq_puts(m, \",sys_immutable\");\n\tif (!isvfat) {\n\t\tif (opts->dotsOK)\n\t\t\tseq_puts(m, \",dotsOK=yes\");\n\t\tif (opts->nocase)\n\t\t\tseq_puts(m, \",nocase\");\n\t} else {\n\t\tif (opts->utf8)\n\t\t\tseq_puts(m, \",utf8\");\n\t\tif (opts->unicode_xlate)\n\t\t\tseq_puts(m, \",uni_xlate\");\n\t\tif (!opts->numtail)\n\t\t\tseq_puts(m, \",nonumtail\");\n\t\tif (opts->rodir)\n\t\t\tseq_puts(m, \",rodir\");\n\t}\n\tif (opts->flush)\n\t\tseq_puts(m, \",flush\");\n\tif (opts->tz_set) {\n\t\tif (opts->time_offset)\n\t\t\tseq_printf(m, \",time_offset=%d\", opts->time_offset);\n\t\telse\n\t\t\tseq_puts(m, \",tz=UTC\");\n\t}\n\tif (opts->errors == FAT_ERRORS_CONT)\n\t\tseq_puts(m, \",errors=continue\");\n\telse if (opts->errors == FAT_ERRORS_PANIC)\n\t\tseq_puts(m, \",errors=panic\");\n\telse\n\t\tseq_puts(m, \",errors=remount-ro\");\n\tif (opts->nfs == FAT_NFS_NOSTALE_RO)\n\t\tseq_puts(m, \",nfs=nostale_ro\");\n\telse if (opts->nfs)\n\t\tseq_puts(m, \",nfs=stale_rw\");\n\tif (opts->discard)\n\t\tseq_puts(m, \",discard\");\n\tif (opts->dos1xfloppy)\n\t\tseq_puts(m, \",dos1xfloppy\");\n\n\treturn 0;\n}\n\nenum {\n\tOpt_check_n, Opt_check_r, Opt_check_s, Opt_uid, Opt_gid,\n\tOpt_umask, Opt_dmask, Opt_fmask, Opt_allow_utime, Opt_codepage,\n\tOpt_usefree, Opt_nocase, Opt_quiet, Opt_showexec, Opt_debug,\n\tOpt_immutable, Opt_dots, Opt_nodots,\n\tOpt_charset, Opt_shortname_lower, Opt_shortname_win95,\n\tOpt_shortname_winnt, Opt_shortname_mixed, Opt_utf8_no, Opt_utf8_yes,\n\tOpt_uni_xl_no, Opt_uni_xl_yes, Opt_nonumtail_no, Opt_nonumtail_yes,\n\tOpt_obsolete, Opt_flush, Opt_tz_utc, Opt_rodir, Opt_err_cont,\n\tOpt_err_panic, Opt_err_ro, Opt_discard, Opt_nfs, Opt_time_offset,\n\tOpt_nfs_stale_rw, Opt_nfs_nostale_ro, Opt_err, Opt_dos1xfloppy,\n};\n\nstatic const match_table_t fat_tokens = {\n\t{Opt_check_r, \"check=relaxed\"},\n\t{Opt_check_s, \"check=strict\"},\n\t{Opt_check_n, \"check=normal\"},\n\t{Opt_check_r, \"check=r\"},\n\t{Opt_check_s, \"check=s\"},\n\t{Opt_check_n, \"check=n\"},\n\t{Opt_uid, \"uid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_umask, \"umask=%o\"},\n\t{Opt_dmask, \"dmask=%o\"},\n\t{Opt_fmask, \"fmask=%o\"},\n\t{Opt_allow_utime, \"allow_utime=%o\"},\n\t{Opt_codepage, \"codepage=%u\"},\n\t{Opt_usefree, \"usefree\"},\n\t{Opt_nocase, \"nocase\"},\n\t{Opt_quiet, \"quiet\"},\n\t{Opt_showexec, \"showexec\"},\n\t{Opt_debug, \"debug\"},\n\t{Opt_immutable, \"sys_immutable\"},\n\t{Opt_flush, \"flush\"},\n\t{Opt_tz_utc, \"tz=UTC\"},\n\t{Opt_time_offset, \"time_offset=%d\"},\n\t{Opt_err_cont, \"errors=continue\"},\n\t{Opt_err_panic, \"errors=panic\"},\n\t{Opt_err_ro, \"errors=remount-ro\"},\n\t{Opt_discard, \"discard\"},\n\t{Opt_nfs_stale_rw, \"nfs\"},\n\t{Opt_nfs_stale_rw, \"nfs=stale_rw\"},\n\t{Opt_nfs_nostale_ro, \"nfs=nostale_ro\"},\n\t{Opt_dos1xfloppy, \"dos1xfloppy\"},\n\t{Opt_obsolete, \"conv=binary\"},\n\t{Opt_obsolete, \"conv=text\"},\n\t{Opt_obsolete, \"conv=auto\"},\n\t{Opt_obsolete, \"conv=b\"},\n\t{Opt_obsolete, \"conv=t\"},\n\t{Opt_obsolete, \"conv=a\"},\n\t{Opt_obsolete, \"fat=%u\"},\n\t{Opt_obsolete, \"blocksize=%u\"},\n\t{Opt_obsolete, \"cvf_format=%20s\"},\n\t{Opt_obsolete, \"cvf_options=%100s\"},\n\t{Opt_obsolete, \"posix\"},\n\t{Opt_err, NULL},\n};\nstatic const match_table_t msdos_tokens = {\n\t{Opt_nodots, \"nodots\"},\n\t{Opt_nodots, \"dotsOK=no\"},\n\t{Opt_dots, \"dots\"},\n\t{Opt_dots, \"dotsOK=yes\"},\n\t{Opt_err, NULL}\n};\nstatic const match_table_t vfat_tokens = {\n\t{Opt_charset, \"iocharset=%s\"},\n\t{Opt_shortname_lower, \"shortname=lower\"},\n\t{Opt_shortname_win95, \"shortname=win95\"},\n\t{Opt_shortname_winnt, \"shortname=winnt\"},\n\t{Opt_shortname_mixed, \"shortname=mixed\"},\n\t{Opt_utf8_no, \"utf8=0\"},\t\t \n\t{Opt_utf8_no, \"utf8=no\"},\n\t{Opt_utf8_no, \"utf8=false\"},\n\t{Opt_utf8_yes, \"utf8=1\"},\t\t \n\t{Opt_utf8_yes, \"utf8=yes\"},\n\t{Opt_utf8_yes, \"utf8=true\"},\n\t{Opt_utf8_yes, \"utf8\"},\n\t{Opt_uni_xl_no, \"uni_xlate=0\"},\t\t \n\t{Opt_uni_xl_no, \"uni_xlate=no\"},\n\t{Opt_uni_xl_no, \"uni_xlate=false\"},\n\t{Opt_uni_xl_yes, \"uni_xlate=1\"},\t \n\t{Opt_uni_xl_yes, \"uni_xlate=yes\"},\n\t{Opt_uni_xl_yes, \"uni_xlate=true\"},\n\t{Opt_uni_xl_yes, \"uni_xlate\"},\n\t{Opt_nonumtail_no, \"nonumtail=0\"},\t \n\t{Opt_nonumtail_no, \"nonumtail=no\"},\n\t{Opt_nonumtail_no, \"nonumtail=false\"},\n\t{Opt_nonumtail_yes, \"nonumtail=1\"},\t \n\t{Opt_nonumtail_yes, \"nonumtail=yes\"},\n\t{Opt_nonumtail_yes, \"nonumtail=true\"},\n\t{Opt_nonumtail_yes, \"nonumtail\"},\n\t{Opt_rodir, \"rodir\"},\n\t{Opt_err, NULL}\n};\n\nstatic int parse_options(struct super_block *sb, char *options, int is_vfat,\n\t\t\t int silent, int *debug, struct fat_mount_options *opts)\n{\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\tchar *iocharset;\n\n\topts->isvfat = is_vfat;\n\n\topts->fs_uid = current_uid();\n\topts->fs_gid = current_gid();\n\topts->fs_fmask = opts->fs_dmask = current_umask();\n\topts->allow_utime = -1;\n\topts->codepage = fat_default_codepage;\n\tfat_reset_iocharset(opts);\n\tif (is_vfat) {\n\t\topts->shortname = VFAT_SFN_DISPLAY_WINNT|VFAT_SFN_CREATE_WIN95;\n\t\topts->rodir = 0;\n\t} else {\n\t\topts->shortname = 0;\n\t\topts->rodir = 1;\n\t}\n\topts->name_check = 'n';\n\topts->quiet = opts->showexec = opts->sys_immutable = opts->dotsOK =  0;\n\topts->unicode_xlate = 0;\n\topts->numtail = 1;\n\topts->usefree = opts->nocase = 0;\n\topts->tz_set = 0;\n\topts->nfs = 0;\n\topts->errors = FAT_ERRORS_RO;\n\t*debug = 0;\n\n\topts->utf8 = IS_ENABLED(CONFIG_FAT_DEFAULT_UTF8) && is_vfat;\n\n\tif (!options)\n\t\tgoto out;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, fat_tokens, args);\n\t\tif (token == Opt_err) {\n\t\t\tif (is_vfat)\n\t\t\t\ttoken = match_token(p, vfat_tokens, args);\n\t\t\telse\n\t\t\t\ttoken = match_token(p, msdos_tokens, args);\n\t\t}\n\t\tswitch (token) {\n\t\tcase Opt_check_s:\n\t\t\topts->name_check = 's';\n\t\t\tbreak;\n\t\tcase Opt_check_r:\n\t\t\topts->name_check = 'r';\n\t\t\tbreak;\n\t\tcase Opt_check_n:\n\t\t\topts->name_check = 'n';\n\t\t\tbreak;\n\t\tcase Opt_usefree:\n\t\t\topts->usefree = 1;\n\t\t\tbreak;\n\t\tcase Opt_nocase:\n\t\t\tif (!is_vfat)\n\t\t\t\topts->nocase = 1;\n\t\t\telse {\n\t\t\t\t \n\t\t\t\topts->shortname = VFAT_SFN_DISPLAY_WIN95\n\t\t\t\t\t| VFAT_SFN_CREATE_WIN95;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_quiet:\n\t\t\topts->quiet = 1;\n\t\t\tbreak;\n\t\tcase Opt_showexec:\n\t\t\topts->showexec = 1;\n\t\t\tbreak;\n\t\tcase Opt_debug:\n\t\t\t*debug = 1;\n\t\t\tbreak;\n\t\tcase Opt_immutable:\n\t\t\topts->sys_immutable = 1;\n\t\t\tbreak;\n\t\tcase Opt_uid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->fs_uid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(opts->fs_uid))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->fs_gid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(opts->fs_gid))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_umask:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->fs_fmask = opts->fs_dmask = option;\n\t\t\tbreak;\n\t\tcase Opt_dmask:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->fs_dmask = option;\n\t\t\tbreak;\n\t\tcase Opt_fmask:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->fs_fmask = option;\n\t\t\tbreak;\n\t\tcase Opt_allow_utime:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->allow_utime = option & (S_IWGRP | S_IWOTH);\n\t\t\tbreak;\n\t\tcase Opt_codepage:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->codepage = option;\n\t\t\tbreak;\n\t\tcase Opt_flush:\n\t\t\topts->flush = 1;\n\t\t\tbreak;\n\t\tcase Opt_time_offset:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\t \n\t\t\tif (option < -24 * 60 || option > 24 * 60)\n\t\t\t\treturn -EINVAL;\n\t\t\topts->tz_set = 1;\n\t\t\topts->time_offset = option;\n\t\t\tbreak;\n\t\tcase Opt_tz_utc:\n\t\t\topts->tz_set = 1;\n\t\t\topts->time_offset = 0;\n\t\t\tbreak;\n\t\tcase Opt_err_cont:\n\t\t\topts->errors = FAT_ERRORS_CONT;\n\t\t\tbreak;\n\t\tcase Opt_err_panic:\n\t\t\topts->errors = FAT_ERRORS_PANIC;\n\t\t\tbreak;\n\t\tcase Opt_err_ro:\n\t\t\topts->errors = FAT_ERRORS_RO;\n\t\t\tbreak;\n\t\tcase Opt_nfs_stale_rw:\n\t\t\topts->nfs = FAT_NFS_STALE_RW;\n\t\t\tbreak;\n\t\tcase Opt_nfs_nostale_ro:\n\t\t\topts->nfs = FAT_NFS_NOSTALE_RO;\n\t\t\tbreak;\n\t\tcase Opt_dos1xfloppy:\n\t\t\topts->dos1xfloppy = 1;\n\t\t\tbreak;\n\n\t\t \n\t\tcase Opt_dots:\n\t\t\topts->dotsOK = 1;\n\t\t\tbreak;\n\t\tcase Opt_nodots:\n\t\t\topts->dotsOK = 0;\n\t\t\tbreak;\n\n\t\t \n\t\tcase Opt_charset:\n\t\t\tfat_reset_iocharset(opts);\n\t\t\tiocharset = match_strdup(&args[0]);\n\t\t\tif (!iocharset)\n\t\t\t\treturn -ENOMEM;\n\t\t\topts->iocharset = iocharset;\n\t\t\tbreak;\n\t\tcase Opt_shortname_lower:\n\t\t\topts->shortname = VFAT_SFN_DISPLAY_LOWER\n\t\t\t\t\t| VFAT_SFN_CREATE_WIN95;\n\t\t\tbreak;\n\t\tcase Opt_shortname_win95:\n\t\t\topts->shortname = VFAT_SFN_DISPLAY_WIN95\n\t\t\t\t\t| VFAT_SFN_CREATE_WIN95;\n\t\t\tbreak;\n\t\tcase Opt_shortname_winnt:\n\t\t\topts->shortname = VFAT_SFN_DISPLAY_WINNT\n\t\t\t\t\t| VFAT_SFN_CREATE_WINNT;\n\t\t\tbreak;\n\t\tcase Opt_shortname_mixed:\n\t\t\topts->shortname = VFAT_SFN_DISPLAY_WINNT\n\t\t\t\t\t| VFAT_SFN_CREATE_WIN95;\n\t\t\tbreak;\n\t\tcase Opt_utf8_no:\t\t \n\t\t\topts->utf8 = 0;\n\t\t\tbreak;\n\t\tcase Opt_utf8_yes:\t\t \n\t\t\topts->utf8 = 1;\n\t\t\tbreak;\n\t\tcase Opt_uni_xl_no:\t\t \n\t\t\topts->unicode_xlate = 0;\n\t\t\tbreak;\n\t\tcase Opt_uni_xl_yes:\t\t \n\t\t\topts->unicode_xlate = 1;\n\t\t\tbreak;\n\t\tcase Opt_nonumtail_no:\t\t \n\t\t\topts->numtail = 1;\t \n\t\t\tbreak;\n\t\tcase Opt_nonumtail_yes:\t\t \n\t\t\topts->numtail = 0;\t \n\t\t\tbreak;\n\t\tcase Opt_rodir:\n\t\t\topts->rodir = 1;\n\t\t\tbreak;\n\t\tcase Opt_discard:\n\t\t\topts->discard = 1;\n\t\t\tbreak;\n\n\t\t \n\t\tcase Opt_obsolete:\n\t\t\tfat_msg(sb, KERN_INFO, \"\\\"%s\\\" option is obsolete, \"\n\t\t\t       \"not supported now\", p);\n\t\t\tbreak;\n\t\t \n\t\tdefault:\n\t\t\tif (!silent) {\n\t\t\t\tfat_msg(sb, KERN_ERR,\n\t\t\t\t       \"Unrecognized mount option \\\"%s\\\" \"\n\t\t\t\t       \"or missing value\", p);\n\t\t\t}\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\nout:\n\t \n\tif (!strcmp(opts->iocharset, \"utf8\")) {\n\t\tfat_msg(sb, KERN_WARNING, \"utf8 is not a recommended IO charset\"\n\t\t       \" for FAT filesystems, filesystem will be \"\n\t\t       \"case sensitive!\");\n\t}\n\n\t \n\tif (opts->allow_utime == (unsigned short)-1)\n\t\topts->allow_utime = ~opts->fs_dmask & (S_IWGRP | S_IWOTH);\n\tif (opts->unicode_xlate)\n\t\topts->utf8 = 0;\n\tif (opts->nfs == FAT_NFS_NOSTALE_RO) {\n\t\tsb->s_flags |= SB_RDONLY;\n\t\tsb->s_export_op = &fat_export_ops_nostale;\n\t}\n\n\treturn 0;\n}\n\nstatic int fat_read_root(struct inode *inode)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\tint error;\n\n\tMSDOS_I(inode)->i_pos = MSDOS_ROOT_INO;\n\tinode->i_uid = sbi->options.fs_uid;\n\tinode->i_gid = sbi->options.fs_gid;\n\tinode_inc_iversion(inode);\n\tinode->i_generation = 0;\n\tinode->i_mode = fat_make_mode(sbi, ATTR_DIR, S_IRWXUGO);\n\tinode->i_op = sbi->dir_ops;\n\tinode->i_fop = &fat_dir_operations;\n\tif (is_fat32(sbi)) {\n\t\tMSDOS_I(inode)->i_start = sbi->root_cluster;\n\t\terror = fat_calc_dir_size(inode);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t} else {\n\t\tMSDOS_I(inode)->i_start = 0;\n\t\tinode->i_size = sbi->dir_entries * sizeof(struct msdos_dir_entry);\n\t}\n\tinode->i_blocks = ((inode->i_size + (sbi->cluster_size - 1))\n\t\t\t   & ~((loff_t)sbi->cluster_size - 1)) >> 9;\n\tMSDOS_I(inode)->i_logstart = 0;\n\tMSDOS_I(inode)->mmu_private = inode->i_size;\n\n\tfat_save_attrs(inode, ATTR_DIR);\n\tinode->i_mtime = inode->i_atime = inode_set_ctime(inode, 0, 0);\n\tset_nlink(inode, fat_subdirs(inode)+2);\n\n\treturn 0;\n}\n\nstatic unsigned long calc_fat_clusters(struct super_block *sb)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\n\t \n\tif (!is_fat12(sbi)) {\n\t\tunsigned long ent_per_sec = sb->s_blocksize * 8 / sbi->fat_bits;\n\t\treturn ent_per_sec * sbi->fat_length;\n\t}\n\n\treturn sbi->fat_length * sb->s_blocksize * 8 / sbi->fat_bits;\n}\n\nstatic bool fat_bpb_is_zero(struct fat_boot_sector *b)\n{\n\tif (get_unaligned_le16(&b->sector_size))\n\t\treturn false;\n\tif (b->sec_per_clus)\n\t\treturn false;\n\tif (b->reserved)\n\t\treturn false;\n\tif (b->fats)\n\t\treturn false;\n\tif (get_unaligned_le16(&b->dir_entries))\n\t\treturn false;\n\tif (get_unaligned_le16(&b->sectors))\n\t\treturn false;\n\tif (b->media)\n\t\treturn false;\n\tif (b->fat_length)\n\t\treturn false;\n\tif (b->secs_track)\n\t\treturn false;\n\tif (b->heads)\n\t\treturn false;\n\treturn true;\n}\n\nstatic int fat_read_bpb(struct super_block *sb, struct fat_boot_sector *b,\n\tint silent, struct fat_bios_param_block *bpb)\n{\n\tint error = -EINVAL;\n\n\t \n\tmemset(bpb, 0, sizeof(*bpb));\n\tbpb->fat_sector_size = get_unaligned_le16(&b->sector_size);\n\tbpb->fat_sec_per_clus = b->sec_per_clus;\n\tbpb->fat_reserved = le16_to_cpu(b->reserved);\n\tbpb->fat_fats = b->fats;\n\tbpb->fat_dir_entries = get_unaligned_le16(&b->dir_entries);\n\tbpb->fat_sectors = get_unaligned_le16(&b->sectors);\n\tbpb->fat_fat_length = le16_to_cpu(b->fat_length);\n\tbpb->fat_total_sect = le32_to_cpu(b->total_sect);\n\n\tbpb->fat16_state = b->fat16.state;\n\tbpb->fat16_vol_id = get_unaligned_le32(b->fat16.vol_id);\n\n\tbpb->fat32_length = le32_to_cpu(b->fat32.length);\n\tbpb->fat32_root_cluster = le32_to_cpu(b->fat32.root_cluster);\n\tbpb->fat32_info_sector = le16_to_cpu(b->fat32.info_sector);\n\tbpb->fat32_state = b->fat32.state;\n\tbpb->fat32_vol_id = get_unaligned_le32(b->fat32.vol_id);\n\n\t \n\tif (!bpb->fat_reserved) {\n\t\tif (!silent)\n\t\t\tfat_msg(sb, KERN_ERR,\n\t\t\t\t\"bogus number of reserved sectors\");\n\t\tgoto out;\n\t}\n\tif (!bpb->fat_fats) {\n\t\tif (!silent)\n\t\t\tfat_msg(sb, KERN_ERR, \"bogus number of FAT structure\");\n\t\tgoto out;\n\t}\n\n\t \n\n\tif (!fat_valid_media(b->media)) {\n\t\tif (!silent)\n\t\t\tfat_msg(sb, KERN_ERR, \"invalid media value (0x%02x)\",\n\t\t\t\t(unsigned)b->media);\n\t\tgoto out;\n\t}\n\n\tif (!is_power_of_2(bpb->fat_sector_size)\n\t    || (bpb->fat_sector_size < 512)\n\t    || (bpb->fat_sector_size > 4096)) {\n\t\tif (!silent)\n\t\t\tfat_msg(sb, KERN_ERR, \"bogus logical sector size %u\",\n\t\t\t       (unsigned)bpb->fat_sector_size);\n\t\tgoto out;\n\t}\n\n\tif (!is_power_of_2(bpb->fat_sec_per_clus)) {\n\t\tif (!silent)\n\t\t\tfat_msg(sb, KERN_ERR, \"bogus sectors per cluster %u\",\n\t\t\t\t(unsigned)bpb->fat_sec_per_clus);\n\t\tgoto out;\n\t}\n\n\tif (bpb->fat_fat_length == 0 && bpb->fat32_length == 0) {\n\t\tif (!silent)\n\t\t\tfat_msg(sb, KERN_ERR, \"bogus number of FAT sectors\");\n\t\tgoto out;\n\t}\n\n\terror = 0;\n\nout:\n\treturn error;\n}\n\nstatic int fat_read_static_bpb(struct super_block *sb,\n\tstruct fat_boot_sector *b, int silent,\n\tstruct fat_bios_param_block *bpb)\n{\n\tstatic const char *notdos1x = \"This doesn't look like a DOS 1.x volume\";\n\tsector_t bd_sects = bdev_nr_sectors(sb->s_bdev);\n\tstruct fat_floppy_defaults *fdefaults = NULL;\n\tint error = -EINVAL;\n\tunsigned i;\n\n\t \n\tif (b->ignored[0] != 0xeb || b->ignored[2] != 0x90) {\n\t\tif (!silent)\n\t\t\tfat_msg(sb, KERN_ERR,\n\t\t\t\t\"%s; no bootstrapping code\", notdos1x);\n\t\tgoto out;\n\t}\n\n\t \n\tif (!fat_bpb_is_zero(b)) {\n\t\tif (!silent)\n\t\t\tfat_msg(sb, KERN_ERR,\n\t\t\t\t\"%s; DOS 2.x BPB is non-zero\", notdos1x);\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(floppy_defaults); i++) {\n\t\tif (floppy_defaults[i].nr_sectors == bd_sects) {\n\t\t\tfdefaults = &floppy_defaults[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (fdefaults == NULL) {\n\t\tif (!silent)\n\t\t\tfat_msg(sb, KERN_WARNING,\n\t\t\t\t\"This looks like a DOS 1.x volume, but isn't a recognized floppy size (%llu sectors)\",\n\t\t\t\t(u64)bd_sects);\n\t\tgoto out;\n\t}\n\n\tif (!silent)\n\t\tfat_msg(sb, KERN_INFO,\n\t\t\t\"This looks like a DOS 1.x volume; assuming default BPB values\");\n\n\tmemset(bpb, 0, sizeof(*bpb));\n\tbpb->fat_sector_size = SECTOR_SIZE;\n\tbpb->fat_sec_per_clus = fdefaults->sec_per_clus;\n\tbpb->fat_reserved = 1;\n\tbpb->fat_fats = 2;\n\tbpb->fat_dir_entries = fdefaults->dir_entries;\n\tbpb->fat_sectors = fdefaults->nr_sectors;\n\tbpb->fat_fat_length = fdefaults->fat_length;\n\n\terror = 0;\n\nout:\n\treturn error;\n}\n\n \nint fat_fill_super(struct super_block *sb, void *data, int silent, int isvfat,\n\t\t   void (*setup)(struct super_block *))\n{\n\tstruct inode *root_inode = NULL, *fat_inode = NULL;\n\tstruct inode *fsinfo_inode = NULL;\n\tstruct buffer_head *bh;\n\tstruct fat_bios_param_block bpb;\n\tstruct msdos_sb_info *sbi;\n\tu16 logical_sector_size;\n\tu32 total_sectors, total_clusters, fat_clusters, rootdir_sectors;\n\tint debug;\n\tlong error;\n\tchar buf[50];\n\tstruct timespec64 ts;\n\n\t \n\tsbi = kzalloc(sizeof(struct msdos_sb_info), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\tsb->s_fs_info = sbi;\n\n\tsb->s_flags |= SB_NODIRATIME;\n\tsb->s_magic = MSDOS_SUPER_MAGIC;\n\tsb->s_op = &fat_sops;\n\tsb->s_export_op = &fat_export_ops;\n\t \n\tsb->s_time_gran = 1;\n\tmutex_init(&sbi->nfs_build_inode_lock);\n\tratelimit_state_init(&sbi->ratelimit, DEFAULT_RATELIMIT_INTERVAL,\n\t\t\t     DEFAULT_RATELIMIT_BURST);\n\n\terror = parse_options(sb, data, isvfat, silent, &debug, &sbi->options);\n\tif (error)\n\t\tgoto out_fail;\n\n\tsetup(sb);  \n\n\terror = -EIO;\n\tsb_min_blocksize(sb, 512);\n\tbh = sb_bread(sb, 0);\n\tif (bh == NULL) {\n\t\tfat_msg(sb, KERN_ERR, \"unable to read boot sector\");\n\t\tgoto out_fail;\n\t}\n\n\terror = fat_read_bpb(sb, (struct fat_boot_sector *)bh->b_data, silent,\n\t\t&bpb);\n\tif (error == -EINVAL && sbi->options.dos1xfloppy)\n\t\terror = fat_read_static_bpb(sb,\n\t\t\t(struct fat_boot_sector *)bh->b_data, silent, &bpb);\n\tbrelse(bh);\n\n\tif (error == -EINVAL)\n\t\tgoto out_invalid;\n\telse if (error)\n\t\tgoto out_fail;\n\n\tlogical_sector_size = bpb.fat_sector_size;\n\tsbi->sec_per_clus = bpb.fat_sec_per_clus;\n\n\terror = -EIO;\n\tif (logical_sector_size < sb->s_blocksize) {\n\t\tfat_msg(sb, KERN_ERR, \"logical sector size too small for device\"\n\t\t       \" (logical sector size = %u)\", logical_sector_size);\n\t\tgoto out_fail;\n\t}\n\n\tif (logical_sector_size > sb->s_blocksize) {\n\t\tstruct buffer_head *bh_resize;\n\n\t\tif (!sb_set_blocksize(sb, logical_sector_size)) {\n\t\t\tfat_msg(sb, KERN_ERR, \"unable to set blocksize %u\",\n\t\t\t       logical_sector_size);\n\t\t\tgoto out_fail;\n\t\t}\n\n\t\t \n\t\tbh_resize = sb_bread(sb, 0);\n\t\tif (bh_resize == NULL) {\n\t\t\tfat_msg(sb, KERN_ERR, \"unable to read boot sector\"\n\t\t\t       \" (logical sector size = %lu)\",\n\t\t\t       sb->s_blocksize);\n\t\t\tgoto out_fail;\n\t\t}\n\t\tbrelse(bh_resize);\n\t}\n\n\tmutex_init(&sbi->s_lock);\n\tsbi->cluster_size = sb->s_blocksize * sbi->sec_per_clus;\n\tsbi->cluster_bits = ffs(sbi->cluster_size) - 1;\n\tsbi->fats = bpb.fat_fats;\n\tsbi->fat_bits = 0;\t\t \n\tsbi->fat_start = bpb.fat_reserved;\n\tsbi->fat_length = bpb.fat_fat_length;\n\tsbi->root_cluster = 0;\n\tsbi->free_clusters = -1;\t \n\tsbi->free_clus_valid = 0;\n\tsbi->prev_free = FAT_START_ENT;\n\tsb->s_maxbytes = 0xffffffff;\n\tfat_time_fat2unix(sbi, &ts, 0, cpu_to_le16(FAT_DATE_MIN), 0);\n\tsb->s_time_min = ts.tv_sec;\n\n\tfat_time_fat2unix(sbi, &ts, cpu_to_le16(FAT_TIME_MAX),\n\t\t\t  cpu_to_le16(FAT_DATE_MAX), 0);\n\tsb->s_time_max = ts.tv_sec;\n\n\tif (!sbi->fat_length && bpb.fat32_length) {\n\t\tstruct fat_boot_fsinfo *fsinfo;\n\t\tstruct buffer_head *fsinfo_bh;\n\n\t\t \n\t\tsbi->fat_bits = 32;\n\t\tsbi->fat_length = bpb.fat32_length;\n\t\tsbi->root_cluster = bpb.fat32_root_cluster;\n\n\t\t \n\t\tsbi->fsinfo_sector = bpb.fat32_info_sector;\n\t\tif (sbi->fsinfo_sector == 0)\n\t\t\tsbi->fsinfo_sector = 1;\n\n\t\tfsinfo_bh = sb_bread(sb, sbi->fsinfo_sector);\n\t\tif (fsinfo_bh == NULL) {\n\t\t\tfat_msg(sb, KERN_ERR, \"bread failed, FSINFO block\"\n\t\t\t       \" (sector = %lu)\", sbi->fsinfo_sector);\n\t\t\tgoto out_fail;\n\t\t}\n\n\t\tfsinfo = (struct fat_boot_fsinfo *)fsinfo_bh->b_data;\n\t\tif (!IS_FSINFO(fsinfo)) {\n\t\t\tfat_msg(sb, KERN_WARNING, \"Invalid FSINFO signature: \"\n\t\t\t       \"0x%08x, 0x%08x (sector = %lu)\",\n\t\t\t       le32_to_cpu(fsinfo->signature1),\n\t\t\t       le32_to_cpu(fsinfo->signature2),\n\t\t\t       sbi->fsinfo_sector);\n\t\t} else {\n\t\t\tif (sbi->options.usefree)\n\t\t\t\tsbi->free_clus_valid = 1;\n\t\t\tsbi->free_clusters = le32_to_cpu(fsinfo->free_clusters);\n\t\t\tsbi->prev_free = le32_to_cpu(fsinfo->next_cluster);\n\t\t}\n\n\t\tbrelse(fsinfo_bh);\n\t}\n\n\t \n\tif (is_fat32(sbi))\n\t\tsbi->vol_id = bpb.fat32_vol_id;\n\telse  \n\t\tsbi->vol_id = bpb.fat16_vol_id;\n\n\tsbi->dir_per_block = sb->s_blocksize / sizeof(struct msdos_dir_entry);\n\tsbi->dir_per_block_bits = ffs(sbi->dir_per_block) - 1;\n\n\tsbi->dir_start = sbi->fat_start + sbi->fats * sbi->fat_length;\n\tsbi->dir_entries = bpb.fat_dir_entries;\n\tif (sbi->dir_entries & (sbi->dir_per_block - 1)) {\n\t\tif (!silent)\n\t\t\tfat_msg(sb, KERN_ERR, \"bogus number of directory entries\"\n\t\t\t       \" (%u)\", sbi->dir_entries);\n\t\tgoto out_invalid;\n\t}\n\n\trootdir_sectors = sbi->dir_entries\n\t\t* sizeof(struct msdos_dir_entry) / sb->s_blocksize;\n\tsbi->data_start = sbi->dir_start + rootdir_sectors;\n\ttotal_sectors = bpb.fat_sectors;\n\tif (total_sectors == 0)\n\t\ttotal_sectors = bpb.fat_total_sect;\n\n\ttotal_clusters = (total_sectors - sbi->data_start) / sbi->sec_per_clus;\n\n\tif (!is_fat32(sbi))\n\t\tsbi->fat_bits = (total_clusters > MAX_FAT12) ? 16 : 12;\n\n\t \n\tif (is_fat32(sbi))\n\t\tsbi->dirty = bpb.fat32_state & FAT_STATE_DIRTY;\n\telse  \n\t\tsbi->dirty = bpb.fat16_state & FAT_STATE_DIRTY;\n\n\t \n\tfat_clusters = calc_fat_clusters(sb);\n\ttotal_clusters = min(total_clusters, fat_clusters - FAT_START_ENT);\n\tif (total_clusters > max_fat(sb)) {\n\t\tif (!silent)\n\t\t\tfat_msg(sb, KERN_ERR, \"count of clusters too big (%u)\",\n\t\t\t       total_clusters);\n\t\tgoto out_invalid;\n\t}\n\n\tsbi->max_cluster = total_clusters + FAT_START_ENT;\n\t \n\tif (sbi->free_clusters != -1 && sbi->free_clusters > total_clusters)\n\t\tsbi->free_clusters = -1;\n\t \n\tsbi->prev_free %= sbi->max_cluster;\n\tif (sbi->prev_free < FAT_START_ENT)\n\t\tsbi->prev_free = FAT_START_ENT;\n\n\t \n\tfat_hash_init(sb);\n\tdir_hash_init(sb);\n\tfat_ent_access_init(sb);\n\n\t \n\n\terror = -EINVAL;\n\tsprintf(buf, \"cp%d\", sbi->options.codepage);\n\tsbi->nls_disk = load_nls(buf);\n\tif (!sbi->nls_disk) {\n\t\tfat_msg(sb, KERN_ERR, \"codepage %s not found\", buf);\n\t\tgoto out_fail;\n\t}\n\n\t \n\tif (sbi->options.isvfat) {\n\t\tsbi->nls_io = load_nls(sbi->options.iocharset);\n\t\tif (!sbi->nls_io) {\n\t\t\tfat_msg(sb, KERN_ERR, \"IO charset %s not found\",\n\t\t\t       sbi->options.iocharset);\n\t\t\tgoto out_fail;\n\t\t}\n\t}\n\n\terror = -ENOMEM;\n\tfat_inode = new_inode(sb);\n\tif (!fat_inode)\n\t\tgoto out_fail;\n\tsbi->fat_inode = fat_inode;\n\n\tfsinfo_inode = new_inode(sb);\n\tif (!fsinfo_inode)\n\t\tgoto out_fail;\n\tfsinfo_inode->i_ino = MSDOS_FSINFO_INO;\n\tsbi->fsinfo_inode = fsinfo_inode;\n\tinsert_inode_hash(fsinfo_inode);\n\n\troot_inode = new_inode(sb);\n\tif (!root_inode)\n\t\tgoto out_fail;\n\troot_inode->i_ino = MSDOS_ROOT_INO;\n\tinode_set_iversion(root_inode, 1);\n\terror = fat_read_root(root_inode);\n\tif (error < 0) {\n\t\tiput(root_inode);\n\t\tgoto out_fail;\n\t}\n\terror = -ENOMEM;\n\tinsert_inode_hash(root_inode);\n\tfat_attach(root_inode, 0);\n\tsb->s_root = d_make_root(root_inode);\n\tif (!sb->s_root) {\n\t\tfat_msg(sb, KERN_ERR, \"get root inode failed\");\n\t\tgoto out_fail;\n\t}\n\n\tif (sbi->options.discard && !bdev_max_discard_sectors(sb->s_bdev))\n\t\tfat_msg(sb, KERN_WARNING,\n\t\t\t\"mounting with \\\"discard\\\" option, but the device does not support discard\");\n\n\tfat_set_state(sb, 1, 0);\n\treturn 0;\n\nout_invalid:\n\terror = -EINVAL;\n\tif (!silent)\n\t\tfat_msg(sb, KERN_INFO, \"Can't find a valid FAT filesystem\");\n\nout_fail:\n\tiput(fsinfo_inode);\n\tiput(fat_inode);\n\tunload_nls(sbi->nls_io);\n\tunload_nls(sbi->nls_disk);\n\tfat_reset_iocharset(&sbi->options);\n\tsb->s_fs_info = NULL;\n\tkfree(sbi);\n\treturn error;\n}\n\nEXPORT_SYMBOL_GPL(fat_fill_super);\n\n \nstatic int writeback_inode(struct inode *inode)\n{\n\n\tint ret;\n\n\t \n\tret = sync_inode_metadata(inode, 0);\n\tif (!ret)\n\t\tret = filemap_fdatawrite(inode->i_mapping);\n\treturn ret;\n}\n\n \nint fat_flush_inodes(struct super_block *sb, struct inode *i1, struct inode *i2)\n{\n\tint ret = 0;\n\tif (!MSDOS_SB(sb)->options.flush)\n\t\treturn 0;\n\tif (i1)\n\t\tret = writeback_inode(i1);\n\tif (!ret && i2)\n\t\tret = writeback_inode(i2);\n\tif (!ret)\n\t\tret = sync_blockdev_nowait(sb->s_bdev);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(fat_flush_inodes);\n\nstatic int __init init_fat_fs(void)\n{\n\tint err;\n\n\terr = fat_cache_init();\n\tif (err)\n\t\treturn err;\n\n\terr = fat_init_inodecache();\n\tif (err)\n\t\tgoto failed;\n\n\treturn 0;\n\nfailed:\n\tfat_cache_destroy();\n\treturn err;\n}\n\nstatic void __exit exit_fat_fs(void)\n{\n\tfat_cache_destroy();\n\tfat_destroy_inodecache();\n}\n\nmodule_init(init_fat_fs)\nmodule_exit(exit_fat_fs)\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}