{
  "module_name": "misc.c",
  "hash_id": "859ce209ce713f95fedbda7c08043f937f9c8bc86d426b3421717a661a4d760b",
  "original_prompt": "Ingested from linux-6.6.14/fs/fat/misc.c",
  "human_readable_source": "\n \n\n#include \"fat.h\"\n#include <linux/iversion.h>\n\n \nvoid __fat_fs_error(struct super_block *sb, int report, const char *fmt, ...)\n{\n\tstruct fat_mount_options *opts = &MSDOS_SB(sb)->options;\n\tva_list args;\n\tstruct va_format vaf;\n\n\tif (report) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tfat_msg(sb, KERN_ERR, \"error, %pV\", &vaf);\n\t\tva_end(args);\n\t}\n\n\tif (opts->errors == FAT_ERRORS_PANIC)\n\t\tpanic(\"FAT-fs (%s): fs panic from previous error\\n\", sb->s_id);\n\telse if (opts->errors == FAT_ERRORS_RO && !sb_rdonly(sb)) {\n\t\tsb->s_flags |= SB_RDONLY;\n\t\tfat_msg(sb, KERN_ERR, \"Filesystem has been set read-only\");\n\t}\n}\nEXPORT_SYMBOL_GPL(__fat_fs_error);\n\n \nvoid _fat_msg(struct super_block *sb, const char *level, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\t_printk(FAT_PRINTK_PREFIX \"%pV\\n\", level, sb->s_id, &vaf);\n\tva_end(args);\n}\n\n \n \nint fat_clusters_flush(struct super_block *sb)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct buffer_head *bh;\n\tstruct fat_boot_fsinfo *fsinfo;\n\n\tif (!is_fat32(sbi))\n\t\treturn 0;\n\n\tbh = sb_bread(sb, sbi->fsinfo_sector);\n\tif (bh == NULL) {\n\t\tfat_msg(sb, KERN_ERR, \"bread failed in fat_clusters_flush\");\n\t\treturn -EIO;\n\t}\n\n\tfsinfo = (struct fat_boot_fsinfo *)bh->b_data;\n\t \n\tif (!IS_FSINFO(fsinfo)) {\n\t\tfat_msg(sb, KERN_ERR, \"Invalid FSINFO signature: \"\n\t\t       \"0x%08x, 0x%08x (sector = %lu)\",\n\t\t       le32_to_cpu(fsinfo->signature1),\n\t\t       le32_to_cpu(fsinfo->signature2),\n\t\t       sbi->fsinfo_sector);\n\t} else {\n\t\tif (sbi->free_clusters != -1)\n\t\t\tfsinfo->free_clusters = cpu_to_le32(sbi->free_clusters);\n\t\tif (sbi->prev_free != -1)\n\t\t\tfsinfo->next_cluster = cpu_to_le32(sbi->prev_free);\n\t\tmark_buffer_dirty(bh);\n\t}\n\tbrelse(bh);\n\n\treturn 0;\n}\n\n \nint fat_chain_add(struct inode *inode, int new_dclus, int nr_cluster)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tint ret, new_fclus, last;\n\n\t \n\tlast = new_fclus = 0;\n\tif (MSDOS_I(inode)->i_start) {\n\t\tint fclus, dclus;\n\n\t\tret = fat_get_cluster(inode, FAT_ENT_EOF, &fclus, &dclus);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tnew_fclus = fclus + 1;\n\t\tlast = dclus;\n\t}\n\n\t \n\tif (last) {\n\t\tstruct fat_entry fatent;\n\n\t\tfatent_init(&fatent);\n\t\tret = fat_ent_read(inode, &fatent, last);\n\t\tif (ret >= 0) {\n\t\t\tint wait = inode_needs_sync(inode);\n\t\t\tret = fat_ent_write(inode, &fatent, new_dclus, wait);\n\t\t\tfatent_brelse(&fatent);\n\t\t}\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t \n\n\t} else {\n\t\tMSDOS_I(inode)->i_start = new_dclus;\n\t\tMSDOS_I(inode)->i_logstart = new_dclus;\n\t\t \n\t\tif (S_ISDIR(inode->i_mode) && IS_DIRSYNC(inode)) {\n\t\t\tret = fat_sync_inode(inode);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t} else\n\t\t\tmark_inode_dirty(inode);\n\t}\n\tif (new_fclus != (inode->i_blocks >> (sbi->cluster_bits - 9))) {\n\t\tfat_fs_error(sb, \"clusters badly computed (%d != %llu)\",\n\t\t\t     new_fclus,\n\t\t\t     (llu)(inode->i_blocks >> (sbi->cluster_bits - 9)));\n\t\tfat_cache_inval_inode(inode);\n\t}\n\tinode->i_blocks += nr_cluster << (sbi->cluster_bits - 9);\n\n\treturn 0;\n}\n\n \n#define SECS_PER_MIN\t60\n#define SECS_PER_HOUR\t(60 * 60)\n#define SECS_PER_DAY\t(SECS_PER_HOUR * 24)\n \n#define DAYS_DELTA\t(365 * 10 + 2)\n \n#define YEAR_2100\t120\n#define IS_LEAP_YEAR(y)\t(!((y) & 3) && (y) != YEAR_2100)\n\n \nstatic long days_in_year[] = {\n\t \n\t0,   0,  31,  59,  90, 120, 151, 181, 212, 243, 273, 304, 334, 0, 0, 0,\n};\n\nstatic inline int fat_tz_offset(const struct msdos_sb_info *sbi)\n{\n\treturn (sbi->options.tz_set ?\n\t       -sbi->options.time_offset :\n\t       sys_tz.tz_minuteswest) * SECS_PER_MIN;\n}\n\n \nvoid fat_time_fat2unix(struct msdos_sb_info *sbi, struct timespec64 *ts,\n\t\t       __le16 __time, __le16 __date, u8 time_cs)\n{\n\tu16 time = le16_to_cpu(__time), date = le16_to_cpu(__date);\n\ttime64_t second;\n\tlong day, leap_day, month, year;\n\n\tyear  = date >> 9;\n\tmonth = max(1, (date >> 5) & 0xf);\n\tday   = max(1, date & 0x1f) - 1;\n\n\tleap_day = (year + 3) / 4;\n\tif (year > YEAR_2100)\t\t \n\t\tleap_day--;\n\tif (IS_LEAP_YEAR(year) && month > 2)\n\t\tleap_day++;\n\n\tsecond =  (time & 0x1f) << 1;\n\tsecond += ((time >> 5) & 0x3f) * SECS_PER_MIN;\n\tsecond += (time >> 11) * SECS_PER_HOUR;\n\tsecond += (time64_t)(year * 365 + leap_day\n\t\t   + days_in_year[month] + day\n\t\t   + DAYS_DELTA) * SECS_PER_DAY;\n\n\tsecond += fat_tz_offset(sbi);\n\n\tif (time_cs) {\n\t\tts->tv_sec = second + (time_cs / 100);\n\t\tts->tv_nsec = (time_cs % 100) * 10000000;\n\t} else {\n\t\tts->tv_sec = second;\n\t\tts->tv_nsec = 0;\n\t}\n}\n\n \nEXPORT_SYMBOL_GPL(fat_time_fat2unix);\n\n \nvoid fat_time_unix2fat(struct msdos_sb_info *sbi, struct timespec64 *ts,\n\t\t       __le16 *time, __le16 *date, u8 *time_cs)\n{\n\tstruct tm tm;\n\ttime64_to_tm(ts->tv_sec, -fat_tz_offset(sbi), &tm);\n\n\t \n\tif (tm.tm_year < 1980 - 1900) {\n\t\t*time = 0;\n\t\t*date = cpu_to_le16((0 << 9) | (1 << 5) | 1);\n\t\tif (time_cs)\n\t\t\t*time_cs = 0;\n\t\treturn;\n\t}\n\tif (tm.tm_year > 2107 - 1900) {\n\t\t*time = cpu_to_le16((23 << 11) | (59 << 5) | 29);\n\t\t*date = cpu_to_le16((127 << 9) | (12 << 5) | 31);\n\t\tif (time_cs)\n\t\t\t*time_cs = 199;\n\t\treturn;\n\t}\n\n\t \n\ttm.tm_year -= 80;\n\t \n\ttm.tm_mon++;\n\t \n\ttm.tm_sec >>= 1;\n\n\t*time = cpu_to_le16(tm.tm_hour << 11 | tm.tm_min << 5 | tm.tm_sec);\n\t*date = cpu_to_le16(tm.tm_year << 9 | tm.tm_mon << 5 | tm.tm_mday);\n\tif (time_cs)\n\t\t*time_cs = (ts->tv_sec & 1) * 100 + ts->tv_nsec / 10000000;\n}\nEXPORT_SYMBOL_GPL(fat_time_unix2fat);\n\nstatic inline struct timespec64 fat_timespec64_trunc_2secs(struct timespec64 ts)\n{\n\treturn (struct timespec64){ ts.tv_sec & ~1ULL, 0 };\n}\n\n \nstruct timespec64 fat_truncate_atime(const struct msdos_sb_info *sbi,\n\t\t\t\t     const struct timespec64 *ts)\n{\n\t \n\ttime64_t seconds = ts->tv_sec - fat_tz_offset(sbi);\n\ts32 remainder;\n\n\tdiv_s64_rem(seconds, SECS_PER_DAY, &remainder);\n\t \n\tseconds = seconds + fat_tz_offset(sbi) - remainder;\n\n\treturn (struct timespec64){ seconds, 0 };\n}\n\n \nstruct timespec64 fat_truncate_mtime(const struct msdos_sb_info *sbi,\n\t\t\t\t     const struct timespec64 *ts)\n{\n\treturn fat_timespec64_trunc_2secs(*ts);\n}\n\n \nint fat_truncate_time(struct inode *inode, struct timespec64 *now, int flags)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\tstruct timespec64 ts;\n\n\tif (inode->i_ino == MSDOS_ROOT_INO)\n\t\treturn 0;\n\n\tif (now == NULL) {\n\t\tnow = &ts;\n\t\tts = current_time(inode);\n\t}\n\n\tif (flags & S_ATIME)\n\t\tinode->i_atime = fat_truncate_atime(sbi, now);\n\t \n\tif (flags & S_MTIME)\n\t\tinode->i_mtime = inode_set_ctime_to_ts(inode,\n\t\t\t\t\t\t       fat_truncate_mtime(sbi, now));\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(fat_truncate_time);\n\nint fat_update_time(struct inode *inode, int flags)\n{\n\tint dirty_flags = 0;\n\n\tif (inode->i_ino == MSDOS_ROOT_INO)\n\t\treturn 0;\n\n\tif (flags & (S_ATIME | S_CTIME | S_MTIME)) {\n\t\tfat_truncate_time(inode, NULL, flags);\n\t\tif (inode->i_sb->s_flags & SB_LAZYTIME)\n\t\t\tdirty_flags |= I_DIRTY_TIME;\n\t\telse\n\t\t\tdirty_flags |= I_DIRTY_SYNC;\n\t}\n\n\t__mark_inode_dirty(inode, dirty_flags);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(fat_update_time);\n\nint fat_sync_bhs(struct buffer_head **bhs, int nr_bhs)\n{\n\tint i, err = 0;\n\n\tfor (i = 0; i < nr_bhs; i++)\n\t\twrite_dirty_buffer(bhs[i], 0);\n\n\tfor (i = 0; i < nr_bhs; i++) {\n\t\twait_on_buffer(bhs[i]);\n\t\tif (!err && !buffer_uptodate(bhs[i]))\n\t\t\terr = -EIO;\n\t}\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}