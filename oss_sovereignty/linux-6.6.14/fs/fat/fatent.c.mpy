{
  "module_name": "fatent.c",
  "hash_id": "afa0402e868e81aace4fd5dcf39de094d35969a32e050ff09a7a1b007d4da8e8",
  "original_prompt": "Ingested from linux-6.6.14/fs/fat/fatent.c",
  "human_readable_source": "\n \n\n#include <linux/blkdev.h>\n#include <linux/sched/signal.h>\n#include <linux/backing-dev-defs.h>\n#include \"fat.h\"\n\nstruct fatent_operations {\n\tvoid (*ent_blocknr)(struct super_block *, int, int *, sector_t *);\n\tvoid (*ent_set_ptr)(struct fat_entry *, int);\n\tint (*ent_bread)(struct super_block *, struct fat_entry *,\n\t\t\t int, sector_t);\n\tint (*ent_get)(struct fat_entry *);\n\tvoid (*ent_put)(struct fat_entry *, int);\n\tint (*ent_next)(struct fat_entry *);\n};\n\nstatic DEFINE_SPINLOCK(fat12_entry_lock);\n\nstatic void fat12_ent_blocknr(struct super_block *sb, int entry,\n\t\t\t      int *offset, sector_t *blocknr)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tint bytes = entry + (entry >> 1);\n\tWARN_ON(!fat_valid_entry(sbi, entry));\n\t*offset = bytes & (sb->s_blocksize - 1);\n\t*blocknr = sbi->fat_start + (bytes >> sb->s_blocksize_bits);\n}\n\nstatic void fat_ent_blocknr(struct super_block *sb, int entry,\n\t\t\t    int *offset, sector_t *blocknr)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tint bytes = (entry << sbi->fatent_shift);\n\tWARN_ON(!fat_valid_entry(sbi, entry));\n\t*offset = bytes & (sb->s_blocksize - 1);\n\t*blocknr = sbi->fat_start + (bytes >> sb->s_blocksize_bits);\n}\n\nstatic void fat12_ent_set_ptr(struct fat_entry *fatent, int offset)\n{\n\tstruct buffer_head **bhs = fatent->bhs;\n\tif (fatent->nr_bhs == 1) {\n\t\tWARN_ON(offset >= (bhs[0]->b_size - 1));\n\t\tfatent->u.ent12_p[0] = bhs[0]->b_data + offset;\n\t\tfatent->u.ent12_p[1] = bhs[0]->b_data + (offset + 1);\n\t} else {\n\t\tWARN_ON(offset != (bhs[0]->b_size - 1));\n\t\tfatent->u.ent12_p[0] = bhs[0]->b_data + offset;\n\t\tfatent->u.ent12_p[1] = bhs[1]->b_data;\n\t}\n}\n\nstatic void fat16_ent_set_ptr(struct fat_entry *fatent, int offset)\n{\n\tWARN_ON(offset & (2 - 1));\n\tfatent->u.ent16_p = (__le16 *)(fatent->bhs[0]->b_data + offset);\n}\n\nstatic void fat32_ent_set_ptr(struct fat_entry *fatent, int offset)\n{\n\tWARN_ON(offset & (4 - 1));\n\tfatent->u.ent32_p = (__le32 *)(fatent->bhs[0]->b_data + offset);\n}\n\nstatic int fat12_ent_bread(struct super_block *sb, struct fat_entry *fatent,\n\t\t\t   int offset, sector_t blocknr)\n{\n\tstruct buffer_head **bhs = fatent->bhs;\n\n\tWARN_ON(blocknr < MSDOS_SB(sb)->fat_start);\n\tfatent->fat_inode = MSDOS_SB(sb)->fat_inode;\n\n\tbhs[0] = sb_bread(sb, blocknr);\n\tif (!bhs[0])\n\t\tgoto err;\n\n\tif ((offset + 1) < sb->s_blocksize)\n\t\tfatent->nr_bhs = 1;\n\telse {\n\t\t \n\t\tblocknr++;\n\t\tbhs[1] = sb_bread(sb, blocknr);\n\t\tif (!bhs[1])\n\t\t\tgoto err_brelse;\n\t\tfatent->nr_bhs = 2;\n\t}\n\tfat12_ent_set_ptr(fatent, offset);\n\treturn 0;\n\nerr_brelse:\n\tbrelse(bhs[0]);\nerr:\n\tfat_msg_ratelimit(sb, KERN_ERR, \"FAT read failed (blocknr %llu)\",\n\t\t\t  (llu)blocknr);\n\treturn -EIO;\n}\n\nstatic int fat_ent_bread(struct super_block *sb, struct fat_entry *fatent,\n\t\t\t int offset, sector_t blocknr)\n{\n\tconst struct fatent_operations *ops = MSDOS_SB(sb)->fatent_ops;\n\n\tWARN_ON(blocknr < MSDOS_SB(sb)->fat_start);\n\tfatent->fat_inode = MSDOS_SB(sb)->fat_inode;\n\tfatent->bhs[0] = sb_bread(sb, blocknr);\n\tif (!fatent->bhs[0]) {\n\t\tfat_msg_ratelimit(sb, KERN_ERR, \"FAT read failed (blocknr %llu)\",\n\t\t\t\t  (llu)blocknr);\n\t\treturn -EIO;\n\t}\n\tfatent->nr_bhs = 1;\n\tops->ent_set_ptr(fatent, offset);\n\treturn 0;\n}\n\nstatic int fat12_ent_get(struct fat_entry *fatent)\n{\n\tu8 **ent12_p = fatent->u.ent12_p;\n\tint next;\n\n\tspin_lock(&fat12_entry_lock);\n\tif (fatent->entry & 1)\n\t\tnext = (*ent12_p[0] >> 4) | (*ent12_p[1] << 4);\n\telse\n\t\tnext = (*ent12_p[1] << 8) | *ent12_p[0];\n\tspin_unlock(&fat12_entry_lock);\n\n\tnext &= 0x0fff;\n\tif (next >= BAD_FAT12)\n\t\tnext = FAT_ENT_EOF;\n\treturn next;\n}\n\nstatic int fat16_ent_get(struct fat_entry *fatent)\n{\n\tint next = le16_to_cpu(*fatent->u.ent16_p);\n\tWARN_ON((unsigned long)fatent->u.ent16_p & (2 - 1));\n\tif (next >= BAD_FAT16)\n\t\tnext = FAT_ENT_EOF;\n\treturn next;\n}\n\nstatic int fat32_ent_get(struct fat_entry *fatent)\n{\n\tint next = le32_to_cpu(*fatent->u.ent32_p) & 0x0fffffff;\n\tWARN_ON((unsigned long)fatent->u.ent32_p & (4 - 1));\n\tif (next >= BAD_FAT32)\n\t\tnext = FAT_ENT_EOF;\n\treturn next;\n}\n\nstatic void fat12_ent_put(struct fat_entry *fatent, int new)\n{\n\tu8 **ent12_p = fatent->u.ent12_p;\n\n\tif (new == FAT_ENT_EOF)\n\t\tnew = EOF_FAT12;\n\n\tspin_lock(&fat12_entry_lock);\n\tif (fatent->entry & 1) {\n\t\t*ent12_p[0] = (new << 4) | (*ent12_p[0] & 0x0f);\n\t\t*ent12_p[1] = new >> 4;\n\t} else {\n\t\t*ent12_p[0] = new & 0xff;\n\t\t*ent12_p[1] = (*ent12_p[1] & 0xf0) | (new >> 8);\n\t}\n\tspin_unlock(&fat12_entry_lock);\n\n\tmark_buffer_dirty_inode(fatent->bhs[0], fatent->fat_inode);\n\tif (fatent->nr_bhs == 2)\n\t\tmark_buffer_dirty_inode(fatent->bhs[1], fatent->fat_inode);\n}\n\nstatic void fat16_ent_put(struct fat_entry *fatent, int new)\n{\n\tif (new == FAT_ENT_EOF)\n\t\tnew = EOF_FAT16;\n\n\t*fatent->u.ent16_p = cpu_to_le16(new);\n\tmark_buffer_dirty_inode(fatent->bhs[0], fatent->fat_inode);\n}\n\nstatic void fat32_ent_put(struct fat_entry *fatent, int new)\n{\n\tWARN_ON(new & 0xf0000000);\n\tnew |= le32_to_cpu(*fatent->u.ent32_p) & ~0x0fffffff;\n\t*fatent->u.ent32_p = cpu_to_le32(new);\n\tmark_buffer_dirty_inode(fatent->bhs[0], fatent->fat_inode);\n}\n\nstatic int fat12_ent_next(struct fat_entry *fatent)\n{\n\tu8 **ent12_p = fatent->u.ent12_p;\n\tstruct buffer_head **bhs = fatent->bhs;\n\tu8 *nextp = ent12_p[1] + 1 + (fatent->entry & 1);\n\n\tfatent->entry++;\n\tif (fatent->nr_bhs == 1) {\n\t\tWARN_ON(ent12_p[0] > (u8 *)(bhs[0]->b_data +\n\t\t\t\t\t\t\t(bhs[0]->b_size - 2)));\n\t\tWARN_ON(ent12_p[1] > (u8 *)(bhs[0]->b_data +\n\t\t\t\t\t\t\t(bhs[0]->b_size - 1)));\n\t\tif (nextp < (u8 *)(bhs[0]->b_data + (bhs[0]->b_size - 1))) {\n\t\t\tent12_p[0] = nextp - 1;\n\t\t\tent12_p[1] = nextp;\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\tWARN_ON(ent12_p[0] != (u8 *)(bhs[0]->b_data +\n\t\t\t\t\t\t\t(bhs[0]->b_size - 1)));\n\t\tWARN_ON(ent12_p[1] != (u8 *)bhs[1]->b_data);\n\t\tent12_p[0] = nextp - 1;\n\t\tent12_p[1] = nextp;\n\t\tbrelse(bhs[0]);\n\t\tbhs[0] = bhs[1];\n\t\tfatent->nr_bhs = 1;\n\t\treturn 1;\n\t}\n\tent12_p[0] = NULL;\n\tent12_p[1] = NULL;\n\treturn 0;\n}\n\nstatic int fat16_ent_next(struct fat_entry *fatent)\n{\n\tconst struct buffer_head *bh = fatent->bhs[0];\n\tfatent->entry++;\n\tif (fatent->u.ent16_p < (__le16 *)(bh->b_data + (bh->b_size - 2))) {\n\t\tfatent->u.ent16_p++;\n\t\treturn 1;\n\t}\n\tfatent->u.ent16_p = NULL;\n\treturn 0;\n}\n\nstatic int fat32_ent_next(struct fat_entry *fatent)\n{\n\tconst struct buffer_head *bh = fatent->bhs[0];\n\tfatent->entry++;\n\tif (fatent->u.ent32_p < (__le32 *)(bh->b_data + (bh->b_size - 4))) {\n\t\tfatent->u.ent32_p++;\n\t\treturn 1;\n\t}\n\tfatent->u.ent32_p = NULL;\n\treturn 0;\n}\n\nstatic const struct fatent_operations fat12_ops = {\n\t.ent_blocknr\t= fat12_ent_blocknr,\n\t.ent_set_ptr\t= fat12_ent_set_ptr,\n\t.ent_bread\t= fat12_ent_bread,\n\t.ent_get\t= fat12_ent_get,\n\t.ent_put\t= fat12_ent_put,\n\t.ent_next\t= fat12_ent_next,\n};\n\nstatic const struct fatent_operations fat16_ops = {\n\t.ent_blocknr\t= fat_ent_blocknr,\n\t.ent_set_ptr\t= fat16_ent_set_ptr,\n\t.ent_bread\t= fat_ent_bread,\n\t.ent_get\t= fat16_ent_get,\n\t.ent_put\t= fat16_ent_put,\n\t.ent_next\t= fat16_ent_next,\n};\n\nstatic const struct fatent_operations fat32_ops = {\n\t.ent_blocknr\t= fat_ent_blocknr,\n\t.ent_set_ptr\t= fat32_ent_set_ptr,\n\t.ent_bread\t= fat_ent_bread,\n\t.ent_get\t= fat32_ent_get,\n\t.ent_put\t= fat32_ent_put,\n\t.ent_next\t= fat32_ent_next,\n};\n\nstatic inline void lock_fat(struct msdos_sb_info *sbi)\n{\n\tmutex_lock(&sbi->fat_lock);\n}\n\nstatic inline void unlock_fat(struct msdos_sb_info *sbi)\n{\n\tmutex_unlock(&sbi->fat_lock);\n}\n\nvoid fat_ent_access_init(struct super_block *sb)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\n\tmutex_init(&sbi->fat_lock);\n\n\tif (is_fat32(sbi)) {\n\t\tsbi->fatent_shift = 2;\n\t\tsbi->fatent_ops = &fat32_ops;\n\t} else if (is_fat16(sbi)) {\n\t\tsbi->fatent_shift = 1;\n\t\tsbi->fatent_ops = &fat16_ops;\n\t} else if (is_fat12(sbi)) {\n\t\tsbi->fatent_shift = -1;\n\t\tsbi->fatent_ops = &fat12_ops;\n\t} else {\n\t\tfat_fs_error(sb, \"invalid FAT variant, %u bits\", sbi->fat_bits);\n\t}\n}\n\nstatic void mark_fsinfo_dirty(struct super_block *sb)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\n\tif (sb_rdonly(sb) || !is_fat32(sbi))\n\t\treturn;\n\n\t__mark_inode_dirty(sbi->fsinfo_inode, I_DIRTY_SYNC);\n}\n\nstatic inline int fat_ent_update_ptr(struct super_block *sb,\n\t\t\t\t     struct fat_entry *fatent,\n\t\t\t\t     int offset, sector_t blocknr)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tconst struct fatent_operations *ops = sbi->fatent_ops;\n\tstruct buffer_head **bhs = fatent->bhs;\n\n\t \n\tif (!fatent->nr_bhs || bhs[0]->b_blocknr != blocknr)\n\t\treturn 0;\n\tif (is_fat12(sbi)) {\n\t\tif ((offset + 1) < sb->s_blocksize) {\n\t\t\t \n\t\t\tif (fatent->nr_bhs == 2) {\n\t\t\t\tbrelse(bhs[1]);\n\t\t\t\tfatent->nr_bhs = 1;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif (fatent->nr_bhs != 2)\n\t\t\t\treturn 0;\n\t\t\tif (bhs[1]->b_blocknr != (blocknr + 1))\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\tops->ent_set_ptr(fatent, offset);\n\treturn 1;\n}\n\nint fat_ent_read(struct inode *inode, struct fat_entry *fatent, int entry)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\tconst struct fatent_operations *ops = sbi->fatent_ops;\n\tint err, offset;\n\tsector_t blocknr;\n\n\tif (!fat_valid_entry(sbi, entry)) {\n\t\tfatent_brelse(fatent);\n\t\tfat_fs_error(sb, \"invalid access to FAT (entry 0x%08x)\", entry);\n\t\treturn -EIO;\n\t}\n\n\tfatent_set_entry(fatent, entry);\n\tops->ent_blocknr(sb, entry, &offset, &blocknr);\n\n\tif (!fat_ent_update_ptr(sb, fatent, offset, blocknr)) {\n\t\tfatent_brelse(fatent);\n\t\terr = ops->ent_bread(sb, fatent, offset, blocknr);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn ops->ent_get(fatent);\n}\n\n \nstatic int fat_mirror_bhs(struct super_block *sb, struct buffer_head **bhs,\n\t\t\t  int nr_bhs)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct buffer_head *c_bh;\n\tint err, n, copy;\n\n\terr = 0;\n\tfor (copy = 1; copy < sbi->fats; copy++) {\n\t\tsector_t backup_fat = sbi->fat_length * copy;\n\n\t\tfor (n = 0; n < nr_bhs; n++) {\n\t\t\tc_bh = sb_getblk(sb, backup_fat + bhs[n]->b_blocknr);\n\t\t\tif (!c_bh) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\t \n\t\t\tlock_buffer(c_bh);\n\t\t\tmemcpy(c_bh->b_data, bhs[n]->b_data, sb->s_blocksize);\n\t\t\tset_buffer_uptodate(c_bh);\n\t\t\tunlock_buffer(c_bh);\n\t\t\tmark_buffer_dirty_inode(c_bh, sbi->fat_inode);\n\t\t\tif (sb->s_flags & SB_SYNCHRONOUS)\n\t\t\t\terr = sync_dirty_buffer(c_bh);\n\t\t\tbrelse(c_bh);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\t\t}\n\t}\nerror:\n\treturn err;\n}\n\nint fat_ent_write(struct inode *inode, struct fat_entry *fatent,\n\t\t  int new, int wait)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tconst struct fatent_operations *ops = MSDOS_SB(sb)->fatent_ops;\n\tint err;\n\n\tops->ent_put(fatent, new);\n\tif (wait) {\n\t\terr = fat_sync_bhs(fatent->bhs, fatent->nr_bhs);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn fat_mirror_bhs(sb, fatent->bhs, fatent->nr_bhs);\n}\n\nstatic inline int fat_ent_next(struct msdos_sb_info *sbi,\n\t\t\t       struct fat_entry *fatent)\n{\n\tif (sbi->fatent_ops->ent_next(fatent)) {\n\t\tif (fatent->entry < sbi->max_cluster)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic inline int fat_ent_read_block(struct super_block *sb,\n\t\t\t\t     struct fat_entry *fatent)\n{\n\tconst struct fatent_operations *ops = MSDOS_SB(sb)->fatent_ops;\n\tsector_t blocknr;\n\tint offset;\n\n\tfatent_brelse(fatent);\n\tops->ent_blocknr(sb, fatent->entry, &offset, &blocknr);\n\treturn ops->ent_bread(sb, fatent, offset, blocknr);\n}\n\nstatic void fat_collect_bhs(struct buffer_head **bhs, int *nr_bhs,\n\t\t\t    struct fat_entry *fatent)\n{\n\tint n, i;\n\n\tfor (n = 0; n < fatent->nr_bhs; n++) {\n\t\tfor (i = 0; i < *nr_bhs; i++) {\n\t\t\tif (fatent->bhs[n] == bhs[i])\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i == *nr_bhs) {\n\t\t\tget_bh(fatent->bhs[n]);\n\t\t\tbhs[i] = fatent->bhs[n];\n\t\t\t(*nr_bhs)++;\n\t\t}\n\t}\n}\n\nint fat_alloc_clusters(struct inode *inode, int *cluster, int nr_cluster)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tconst struct fatent_operations *ops = sbi->fatent_ops;\n\tstruct fat_entry fatent, prev_ent;\n\tstruct buffer_head *bhs[MAX_BUF_PER_PAGE];\n\tint i, count, err, nr_bhs, idx_clus;\n\n\tBUG_ON(nr_cluster > (MAX_BUF_PER_PAGE / 2));\t \n\n\tlock_fat(sbi);\n\tif (sbi->free_clusters != -1 && sbi->free_clus_valid &&\n\t    sbi->free_clusters < nr_cluster) {\n\t\tunlock_fat(sbi);\n\t\treturn -ENOSPC;\n\t}\n\n\terr = nr_bhs = idx_clus = 0;\n\tcount = FAT_START_ENT;\n\tfatent_init(&prev_ent);\n\tfatent_init(&fatent);\n\tfatent_set_entry(&fatent, sbi->prev_free + 1);\n\twhile (count < sbi->max_cluster) {\n\t\tif (fatent.entry >= sbi->max_cluster)\n\t\t\tfatent.entry = FAT_START_ENT;\n\t\tfatent_set_entry(&fatent, fatent.entry);\n\t\terr = fat_ent_read_block(sb, &fatent);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\t \n\t\tdo {\n\t\t\tif (ops->ent_get(&fatent) == FAT_ENT_FREE) {\n\t\t\t\tint entry = fatent.entry;\n\n\t\t\t\t \n\t\t\t\tops->ent_put(&fatent, FAT_ENT_EOF);\n\t\t\t\tif (prev_ent.nr_bhs)\n\t\t\t\t\tops->ent_put(&prev_ent, entry);\n\n\t\t\t\tfat_collect_bhs(bhs, &nr_bhs, &fatent);\n\n\t\t\t\tsbi->prev_free = entry;\n\t\t\t\tif (sbi->free_clusters != -1)\n\t\t\t\t\tsbi->free_clusters--;\n\n\t\t\t\tcluster[idx_clus] = entry;\n\t\t\t\tidx_clus++;\n\t\t\t\tif (idx_clus == nr_cluster)\n\t\t\t\t\tgoto out;\n\n\t\t\t\t \n\t\t\t\tprev_ent = fatent;\n\t\t\t}\n\t\t\tcount++;\n\t\t\tif (count == sbi->max_cluster)\n\t\t\t\tbreak;\n\t\t} while (fat_ent_next(sbi, &fatent));\n\t}\n\n\t \n\tsbi->free_clusters = 0;\n\tsbi->free_clus_valid = 1;\n\terr = -ENOSPC;\n\nout:\n\tunlock_fat(sbi);\n\tmark_fsinfo_dirty(sb);\n\tfatent_brelse(&fatent);\n\tif (!err) {\n\t\tif (inode_needs_sync(inode))\n\t\t\terr = fat_sync_bhs(bhs, nr_bhs);\n\t\tif (!err)\n\t\t\terr = fat_mirror_bhs(sb, bhs, nr_bhs);\n\t}\n\tfor (i = 0; i < nr_bhs; i++)\n\t\tbrelse(bhs[i]);\n\n\tif (err && idx_clus)\n\t\tfat_free_clusters(inode, cluster[0]);\n\n\treturn err;\n}\n\nint fat_free_clusters(struct inode *inode, int cluster)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tconst struct fatent_operations *ops = sbi->fatent_ops;\n\tstruct fat_entry fatent;\n\tstruct buffer_head *bhs[MAX_BUF_PER_PAGE];\n\tint i, err, nr_bhs;\n\tint first_cl = cluster, dirty_fsinfo = 0;\n\n\tnr_bhs = 0;\n\tfatent_init(&fatent);\n\tlock_fat(sbi);\n\tdo {\n\t\tcluster = fat_ent_read(inode, &fatent, cluster);\n\t\tif (cluster < 0) {\n\t\t\terr = cluster;\n\t\t\tgoto error;\n\t\t} else if (cluster == FAT_ENT_FREE) {\n\t\t\tfat_fs_error(sb, \"%s: deleting FAT entry beyond EOF\",\n\t\t\t\t     __func__);\n\t\t\terr = -EIO;\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (sbi->options.discard) {\n\t\t\t \n\t\t\tif (cluster != fatent.entry + 1) {\n\t\t\t\tint nr_clus = fatent.entry - first_cl + 1;\n\n\t\t\t\tsb_issue_discard(sb,\n\t\t\t\t\tfat_clus_to_blknr(sbi, first_cl),\n\t\t\t\t\tnr_clus * sbi->sec_per_clus,\n\t\t\t\t\tGFP_NOFS, 0);\n\n\t\t\t\tfirst_cl = cluster;\n\t\t\t}\n\t\t}\n\n\t\tops->ent_put(&fatent, FAT_ENT_FREE);\n\t\tif (sbi->free_clusters != -1) {\n\t\t\tsbi->free_clusters++;\n\t\t\tdirty_fsinfo = 1;\n\t\t}\n\n\t\tif (nr_bhs + fatent.nr_bhs > MAX_BUF_PER_PAGE) {\n\t\t\tif (sb->s_flags & SB_SYNCHRONOUS) {\n\t\t\t\terr = fat_sync_bhs(bhs, nr_bhs);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto error;\n\t\t\t}\n\t\t\terr = fat_mirror_bhs(sb, bhs, nr_bhs);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\t\t\tfor (i = 0; i < nr_bhs; i++)\n\t\t\t\tbrelse(bhs[i]);\n\t\t\tnr_bhs = 0;\n\t\t}\n\t\tfat_collect_bhs(bhs, &nr_bhs, &fatent);\n\t} while (cluster != FAT_ENT_EOF);\n\n\tif (sb->s_flags & SB_SYNCHRONOUS) {\n\t\terr = fat_sync_bhs(bhs, nr_bhs);\n\t\tif (err)\n\t\t\tgoto error;\n\t}\n\terr = fat_mirror_bhs(sb, bhs, nr_bhs);\nerror:\n\tfatent_brelse(&fatent);\n\tfor (i = 0; i < nr_bhs; i++)\n\t\tbrelse(bhs[i]);\n\tunlock_fat(sbi);\n\tif (dirty_fsinfo)\n\t\tmark_fsinfo_dirty(sb);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(fat_free_clusters);\n\nstruct fatent_ra {\n\tsector_t cur;\n\tsector_t limit;\n\n\tunsigned int ra_blocks;\n\tsector_t ra_advance;\n\tsector_t ra_next;\n\tsector_t ra_limit;\n};\n\nstatic void fat_ra_init(struct super_block *sb, struct fatent_ra *ra,\n\t\t\tstruct fat_entry *fatent, int ent_limit)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tconst struct fatent_operations *ops = sbi->fatent_ops;\n\tsector_t blocknr, block_end;\n\tint offset;\n\t \n\tunsigned long ra_pages = sb->s_bdi->ra_pages;\n\tunsigned int reada_blocks;\n\n\tif (fatent->entry >= ent_limit)\n\t\treturn;\n\n\tif (ra_pages > sb->s_bdi->io_pages)\n\t\tra_pages = rounddown(ra_pages, sb->s_bdi->io_pages);\n\treada_blocks = ra_pages << (PAGE_SHIFT - sb->s_blocksize_bits + 1);\n\n\t \n\tops->ent_blocknr(sb, fatent->entry, &offset, &blocknr);\n\tops->ent_blocknr(sb, ent_limit - 1, &offset, &block_end);\n\tra->cur = 0;\n\tra->limit = (block_end + 1) - blocknr;\n\n\t \n\tra->ra_blocks = reada_blocks >> 1;\n\tra->ra_advance = ra->cur;\n\tra->ra_next = ra->cur;\n\tra->ra_limit = ra->cur + min_t(sector_t, reada_blocks, ra->limit);\n}\n\n \nstatic void fat_ent_reada(struct super_block *sb, struct fatent_ra *ra,\n\t\t\t  struct fat_entry *fatent)\n{\n\tif (ra->ra_next >= ra->ra_limit)\n\t\treturn;\n\n\tif (ra->cur >= ra->ra_advance) {\n\t\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\t\tconst struct fatent_operations *ops = sbi->fatent_ops;\n\t\tstruct blk_plug plug;\n\t\tsector_t blocknr, diff;\n\t\tint offset;\n\n\t\tops->ent_blocknr(sb, fatent->entry, &offset, &blocknr);\n\n\t\tdiff = blocknr - ra->cur;\n\t\tblk_start_plug(&plug);\n\t\t \n\t\tfor (; ra->ra_next < ra->ra_limit; ra->ra_next++)\n\t\t\tsb_breadahead(sb, ra->ra_next + diff);\n\t\tblk_finish_plug(&plug);\n\n\t\t \n\t\tra->ra_advance += ra->ra_blocks;\n\t\tra->ra_limit += min_t(sector_t,\n\t\t\t\t      ra->ra_blocks, ra->limit - ra->ra_limit);\n\t}\n\tra->cur++;\n}\n\nint fat_count_free_clusters(struct super_block *sb)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tconst struct fatent_operations *ops = sbi->fatent_ops;\n\tstruct fat_entry fatent;\n\tstruct fatent_ra fatent_ra;\n\tint err = 0, free;\n\n\tlock_fat(sbi);\n\tif (sbi->free_clusters != -1 && sbi->free_clus_valid)\n\t\tgoto out;\n\n\tfree = 0;\n\tfatent_init(&fatent);\n\tfatent_set_entry(&fatent, FAT_START_ENT);\n\tfat_ra_init(sb, &fatent_ra, &fatent, sbi->max_cluster);\n\twhile (fatent.entry < sbi->max_cluster) {\n\t\t \n\t\tfat_ent_reada(sb, &fatent_ra, &fatent);\n\n\t\terr = fat_ent_read_block(sb, &fatent);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tdo {\n\t\t\tif (ops->ent_get(&fatent) == FAT_ENT_FREE)\n\t\t\t\tfree++;\n\t\t} while (fat_ent_next(sbi, &fatent));\n\t\tcond_resched();\n\t}\n\tsbi->free_clusters = free;\n\tsbi->free_clus_valid = 1;\n\tmark_fsinfo_dirty(sb);\n\tfatent_brelse(&fatent);\nout:\n\tunlock_fat(sbi);\n\treturn err;\n}\n\nstatic int fat_trim_clusters(struct super_block *sb, u32 clus, u32 nr_clus)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\treturn sb_issue_discard(sb, fat_clus_to_blknr(sbi, clus),\n\t\t\t\tnr_clus * sbi->sec_per_clus, GFP_NOFS, 0);\n}\n\nint fat_trim_fs(struct inode *inode, struct fstrim_range *range)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tconst struct fatent_operations *ops = sbi->fatent_ops;\n\tstruct fat_entry fatent;\n\tstruct fatent_ra fatent_ra;\n\tu64 ent_start, ent_end, minlen, trimmed = 0;\n\tu32 free = 0;\n\tint err = 0;\n\n\t \n\tent_start = max_t(u64, range->start>>sbi->cluster_bits, FAT_START_ENT);\n\tent_end = ent_start + (range->len >> sbi->cluster_bits) - 1;\n\tminlen = range->minlen >> sbi->cluster_bits;\n\n\tif (ent_start >= sbi->max_cluster || range->len < sbi->cluster_size)\n\t\treturn -EINVAL;\n\tif (ent_end >= sbi->max_cluster)\n\t\tent_end = sbi->max_cluster - 1;\n\n\tfatent_init(&fatent);\n\tlock_fat(sbi);\n\tfatent_set_entry(&fatent, ent_start);\n\tfat_ra_init(sb, &fatent_ra, &fatent, ent_end + 1);\n\twhile (fatent.entry <= ent_end) {\n\t\t \n\t\tfat_ent_reada(sb, &fatent_ra, &fatent);\n\n\t\terr = fat_ent_read_block(sb, &fatent);\n\t\tif (err)\n\t\t\tgoto error;\n\t\tdo {\n\t\t\tif (ops->ent_get(&fatent) == FAT_ENT_FREE) {\n\t\t\t\tfree++;\n\t\t\t} else if (free) {\n\t\t\t\tif (free >= minlen) {\n\t\t\t\t\tu32 clus = fatent.entry - free;\n\n\t\t\t\t\terr = fat_trim_clusters(sb, clus, free);\n\t\t\t\t\tif (err && err != -EOPNOTSUPP)\n\t\t\t\t\t\tgoto error;\n\t\t\t\t\tif (!err)\n\t\t\t\t\t\ttrimmed += free;\n\t\t\t\t\terr = 0;\n\t\t\t\t}\n\t\t\t\tfree = 0;\n\t\t\t}\n\t\t} while (fat_ent_next(sbi, &fatent) && fatent.entry <= ent_end);\n\n\t\tif (fatal_signal_pending(current)) {\n\t\t\terr = -ERESTARTSYS;\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (need_resched()) {\n\t\t\tfatent_brelse(&fatent);\n\t\t\tunlock_fat(sbi);\n\t\t\tcond_resched();\n\t\t\tlock_fat(sbi);\n\t\t}\n\t}\n\t \n\tif (free && free >= minlen) {\n\t\tu32 clus = fatent.entry - free;\n\n\t\terr = fat_trim_clusters(sb, clus, free);\n\t\tif (err && err != -EOPNOTSUPP)\n\t\t\tgoto error;\n\t\tif (!err)\n\t\t\ttrimmed += free;\n\t\terr = 0;\n\t}\n\nerror:\n\tfatent_brelse(&fatent);\n\tunlock_fat(sbi);\n\n\trange->len = trimmed << sbi->cluster_bits;\n\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}