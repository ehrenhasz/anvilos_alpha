{
  "module_name": "dir.c",
  "hash_id": "353cdf1c24c68a68b86d315e0be0d39c2c86aed7f73600b199319d0d01f6cd6b",
  "original_prompt": "Ingested from linux-6.6.14/fs/fat/dir.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/iversion.h>\n#include \"fat.h\"\n\n \n#define FAT_MAX_SHORT_SIZE\t((MSDOS_NAME + 1) * NLS_MAX_CHARSET_SIZE + 1)\n \n#define FAT_MAX_UNI_CHARS\t((MSDOS_SLOTS - 1) * 13 + 1)\n#define FAT_MAX_UNI_SIZE\t(FAT_MAX_UNI_CHARS * sizeof(wchar_t))\n\nstatic inline unsigned char fat_tolower(unsigned char c)\n{\n\treturn ((c >= 'A') && (c <= 'Z')) ? c+32 : c;\n}\n\nstatic inline loff_t fat_make_i_pos(struct super_block *sb,\n\t\t\t\t    struct buffer_head *bh,\n\t\t\t\t    struct msdos_dir_entry *de)\n{\n\treturn ((loff_t)bh->b_blocknr << MSDOS_SB(sb)->dir_per_block_bits)\n\t\t| (de - (struct msdos_dir_entry *)bh->b_data);\n}\n\nstatic inline void fat_dir_readahead(struct inode *dir, sector_t iblock,\n\t\t\t\t     sector_t phys)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct buffer_head *bh;\n\tint sec;\n\n\t \n\tif ((iblock & (sbi->sec_per_clus - 1)) || sbi->sec_per_clus == 1)\n\t\treturn;\n\t \n\tif (!is_fat32(sbi) && (dir->i_ino == MSDOS_ROOT_INO))\n\t\treturn;\n\n\tbh = sb_find_get_block(sb, phys);\n\tif (bh == NULL || !buffer_uptodate(bh)) {\n\t\tfor (sec = 0; sec < sbi->sec_per_clus; sec++)\n\t\t\tsb_breadahead(sb, phys + sec);\n\t}\n\tbrelse(bh);\n}\n\n \nstatic int fat__get_entry(struct inode *dir, loff_t *pos,\n\t\t\t  struct buffer_head **bh, struct msdos_dir_entry **de)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tsector_t phys, iblock;\n\tunsigned long mapped_blocks;\n\tint err, offset;\n\nnext:\n\tbrelse(*bh);\n\t*bh = NULL;\n\tiblock = *pos >> sb->s_blocksize_bits;\n\terr = fat_bmap(dir, iblock, &phys, &mapped_blocks, 0, false);\n\tif (err || !phys)\n\t\treturn -1;\t \n\n\tfat_dir_readahead(dir, iblock, phys);\n\n\t*bh = sb_bread(sb, phys);\n\tif (*bh == NULL) {\n\t\tfat_msg_ratelimit(sb, KERN_ERR,\n\t\t\t\"Directory bread(block %llu) failed\", (llu)phys);\n\t\t \n\t\t*pos = (iblock + 1) << sb->s_blocksize_bits;\n\t\tgoto next;\n\t}\n\n\toffset = *pos & (sb->s_blocksize - 1);\n\t*pos += sizeof(struct msdos_dir_entry);\n\t*de = (struct msdos_dir_entry *)((*bh)->b_data + offset);\n\n\treturn 0;\n}\n\nstatic inline int fat_get_entry(struct inode *dir, loff_t *pos,\n\t\t\t\tstruct buffer_head **bh,\n\t\t\t\tstruct msdos_dir_entry **de)\n{\n\t \n\tif (*bh && *de &&\n\t   (*de - (struct msdos_dir_entry *)(*bh)->b_data) <\n\t\t\t\tMSDOS_SB(dir->i_sb)->dir_per_block - 1) {\n\t\t*pos += sizeof(struct msdos_dir_entry);\n\t\t(*de)++;\n\t\treturn 0;\n\t}\n\treturn fat__get_entry(dir, pos, bh, de);\n}\n\n \nstatic int uni16_to_x8(struct super_block *sb, unsigned char *ascii,\n\t\t       const wchar_t *uni, int len, struct nls_table *nls)\n{\n\tint uni_xlate = MSDOS_SB(sb)->options.unicode_xlate;\n\tconst wchar_t *ip;\n\twchar_t ec;\n\tunsigned char *op;\n\tint charlen;\n\n\tip = uni;\n\top = ascii;\n\n\twhile (*ip && ((len - NLS_MAX_CHARSET_SIZE) > 0)) {\n\t\tec = *ip++;\n\t\tcharlen = nls->uni2char(ec, op, NLS_MAX_CHARSET_SIZE);\n\t\tif (charlen > 0) {\n\t\t\top += charlen;\n\t\t\tlen -= charlen;\n\t\t} else {\n\t\t\tif (uni_xlate == 1) {\n\t\t\t\t*op++ = ':';\n\t\t\t\top = hex_byte_pack(op, ec >> 8);\n\t\t\t\top = hex_byte_pack(op, ec);\n\t\t\t\tlen -= 5;\n\t\t\t} else {\n\t\t\t\t*op++ = '?';\n\t\t\t\tlen--;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (unlikely(*ip)) {\n\t\tfat_msg(sb, KERN_WARNING,\n\t\t\t\"filename was truncated while converting.\");\n\t}\n\n\t*op = 0;\n\treturn op - ascii;\n}\n\nstatic inline int fat_uni_to_x8(struct super_block *sb, const wchar_t *uni,\n\t\t\t\tunsigned char *buf, int size)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tif (sbi->options.utf8)\n\t\treturn utf16s_to_utf8s(uni, FAT_MAX_UNI_CHARS,\n\t\t\t\tUTF16_HOST_ENDIAN, buf, size);\n\telse\n\t\treturn uni16_to_x8(sb, buf, uni, size, sbi->nls_io);\n}\n\nstatic inline int\nfat_short2uni(struct nls_table *t, unsigned char *c, int clen, wchar_t *uni)\n{\n\tint charlen;\n\n\tcharlen = t->char2uni(c, clen, uni);\n\tif (charlen < 0) {\n\t\t*uni = 0x003f;\t \n\t\tcharlen = 1;\n\t}\n\treturn charlen;\n}\n\nstatic inline int\nfat_short2lower_uni(struct nls_table *t, unsigned char *c,\n\t\t    int clen, wchar_t *uni)\n{\n\tint charlen;\n\twchar_t wc;\n\n\tcharlen = t->char2uni(c, clen, &wc);\n\tif (charlen < 0) {\n\t\t*uni = 0x003f;\t \n\t\tcharlen = 1;\n\t} else if (charlen <= 1) {\n\t\tunsigned char nc = t->charset2lower[*c];\n\n\t\tif (!nc)\n\t\t\tnc = *c;\n\n\t\tcharlen = t->char2uni(&nc, 1, uni);\n\t\tif (charlen < 0) {\n\t\t\t*uni = 0x003f;\t \n\t\t\tcharlen = 1;\n\t\t}\n\t} else\n\t\t*uni = wc;\n\n\treturn charlen;\n}\n\nstatic inline int\nfat_shortname2uni(struct nls_table *nls, unsigned char *buf, int buf_size,\n\t\t  wchar_t *uni_buf, unsigned short opt, int lower)\n{\n\tint len = 0;\n\n\tif (opt & VFAT_SFN_DISPLAY_LOWER)\n\t\tlen =  fat_short2lower_uni(nls, buf, buf_size, uni_buf);\n\telse if (opt & VFAT_SFN_DISPLAY_WIN95)\n\t\tlen = fat_short2uni(nls, buf, buf_size, uni_buf);\n\telse if (opt & VFAT_SFN_DISPLAY_WINNT) {\n\t\tif (lower)\n\t\t\tlen = fat_short2lower_uni(nls, buf, buf_size, uni_buf);\n\t\telse\n\t\t\tlen = fat_short2uni(nls, buf, buf_size, uni_buf);\n\t} else\n\t\tlen = fat_short2uni(nls, buf, buf_size, uni_buf);\n\n\treturn len;\n}\n\nstatic inline int fat_name_match(struct msdos_sb_info *sbi,\n\t\t\t\t const unsigned char *a, int a_len,\n\t\t\t\t const unsigned char *b, int b_len)\n{\n\tif (a_len != b_len)\n\t\treturn 0;\n\n\tif (sbi->options.name_check != 's')\n\t\treturn !nls_strnicmp(sbi->nls_io, a, b, a_len);\n\telse\n\t\treturn !memcmp(a, b, a_len);\n}\n\nenum { PARSE_INVALID = 1, PARSE_NOT_LONGNAME, PARSE_EOF, };\n\n \nstatic int fat_parse_long(struct inode *dir, loff_t *pos,\n\t\t\t  struct buffer_head **bh, struct msdos_dir_entry **de,\n\t\t\t  wchar_t **unicode, unsigned char *nr_slots)\n{\n\tstruct msdos_dir_slot *ds;\n\tunsigned char id, slot, slots, alias_checksum;\n\n\tif (!*unicode) {\n\t\t*unicode = __getname();\n\t\tif (!*unicode) {\n\t\t\tbrelse(*bh);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\nparse_long:\n\tds = (struct msdos_dir_slot *)*de;\n\tid = ds->id;\n\tif (!(id & 0x40))\n\t\treturn PARSE_INVALID;\n\tslots = id & ~0x40;\n\tif (slots > 20 || !slots)\t \n\t\treturn PARSE_INVALID;\n\t*nr_slots = slots;\n\talias_checksum = ds->alias_checksum;\n\n\tslot = slots;\n\twhile (1) {\n\t\tint offset;\n\n\t\tslot--;\n\t\toffset = slot * 13;\n\t\tfat16_towchar(*unicode + offset, ds->name0_4, 5);\n\t\tfat16_towchar(*unicode + offset + 5, ds->name5_10, 6);\n\t\tfat16_towchar(*unicode + offset + 11, ds->name11_12, 2);\n\n\t\tif (ds->id & 0x40)\n\t\t\t(*unicode)[offset + 13] = 0;\n\t\tif (fat_get_entry(dir, pos, bh, de) < 0)\n\t\t\treturn PARSE_EOF;\n\t\tif (slot == 0)\n\t\t\tbreak;\n\t\tds = (struct msdos_dir_slot *)*de;\n\t\tif (ds->attr != ATTR_EXT)\n\t\t\treturn PARSE_NOT_LONGNAME;\n\t\tif ((ds->id & ~0x40) != slot)\n\t\t\tgoto parse_long;\n\t\tif (ds->alias_checksum != alias_checksum)\n\t\t\tgoto parse_long;\n\t}\n\tif ((*de)->name[0] == DELETED_FLAG)\n\t\treturn PARSE_INVALID;\n\tif ((*de)->attr == ATTR_EXT)\n\t\tgoto parse_long;\n\tif (IS_FREE((*de)->name) || ((*de)->attr & ATTR_VOLUME))\n\t\treturn PARSE_INVALID;\n\tif (fat_checksum((*de)->name) != alias_checksum)\n\t\t*nr_slots = 0;\n\n\treturn 0;\n}\n\n \nstatic int fat_parse_short(struct super_block *sb,\n\t\t\t   const struct msdos_dir_entry *de,\n\t\t\t   unsigned char *name, int dot_hidden)\n{\n\tconst struct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tint isvfat = sbi->options.isvfat;\n\tint nocase = sbi->options.nocase;\n\tunsigned short opt_shortname = sbi->options.shortname;\n\tstruct nls_table *nls_disk = sbi->nls_disk;\n\twchar_t uni_name[14];\n\tunsigned char c, work[MSDOS_NAME];\n\tunsigned char *ptname = name;\n\tint chi, chl, i, j, k;\n\tint dotoffset = 0;\n\tint name_len = 0, uni_len = 0;\n\n\tif (!isvfat && dot_hidden && (de->attr & ATTR_HIDDEN)) {\n\t\t*ptname++ = '.';\n\t\tdotoffset = 1;\n\t}\n\n\tmemcpy(work, de->name, sizeof(work));\n\t \n\tif (work[0] == 0x05)\n\t\twork[0] = 0xE5;\n\n\t \n\tfor (i = 0, j = 0; i < 8;) {\n\t\tc = work[i];\n\t\tif (!c)\n\t\t\tbreak;\n\t\tchl = fat_shortname2uni(nls_disk, &work[i], 8 - i,\n\t\t\t\t\t&uni_name[j++], opt_shortname,\n\t\t\t\t\tde->lcase & CASE_LOWER_BASE);\n\t\tif (chl <= 1) {\n\t\t\tif (!isvfat)\n\t\t\t\tptname[i] = nocase ? c : fat_tolower(c);\n\t\t\ti++;\n\t\t\tif (c != ' ') {\n\t\t\t\tname_len = i;\n\t\t\t\tuni_len  = j;\n\t\t\t}\n\t\t} else {\n\t\t\tuni_len = j;\n\t\t\tif (isvfat)\n\t\t\t\ti += min(chl, 8-i);\n\t\t\telse {\n\t\t\t\tfor (chi = 0; chi < chl && i < 8; chi++, i++)\n\t\t\t\t\tptname[i] = work[i];\n\t\t\t}\n\t\t\tif (chl)\n\t\t\t\tname_len = i;\n\t\t}\n\t}\n\n\ti = name_len;\n\tj = uni_len;\n\tfat_short2uni(nls_disk, \".\", 1, &uni_name[j++]);\n\tif (!isvfat)\n\t\tptname[i] = '.';\n\ti++;\n\n\t \n\tfor (k = 8; k < MSDOS_NAME;) {\n\t\tc = work[k];\n\t\tif (!c)\n\t\t\tbreak;\n\t\tchl = fat_shortname2uni(nls_disk, &work[k], MSDOS_NAME - k,\n\t\t\t\t\t&uni_name[j++], opt_shortname,\n\t\t\t\t\tde->lcase & CASE_LOWER_EXT);\n\t\tif (chl <= 1) {\n\t\t\tk++;\n\t\t\tif (!isvfat)\n\t\t\t\tptname[i] = nocase ? c : fat_tolower(c);\n\t\t\ti++;\n\t\t\tif (c != ' ') {\n\t\t\t\tname_len = i;\n\t\t\t\tuni_len  = j;\n\t\t\t}\n\t\t} else {\n\t\t\tuni_len = j;\n\t\t\tif (isvfat) {\n\t\t\t\tint offset = min(chl, MSDOS_NAME-k);\n\t\t\t\tk += offset;\n\t\t\t\ti += offset;\n\t\t\t} else {\n\t\t\t\tfor (chi = 0; chi < chl && k < MSDOS_NAME;\n\t\t\t\t     chi++, i++, k++) {\n\t\t\t\t\t\tptname[i] = work[k];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (chl)\n\t\t\t\tname_len = i;\n\t\t}\n\t}\n\n\tif (name_len > 0) {\n\t\tname_len += dotoffset;\n\n\t\tif (sbi->options.isvfat) {\n\t\t\tuni_name[uni_len] = 0x0000;\n\t\t\tname_len = fat_uni_to_x8(sb, uni_name, name,\n\t\t\t\t\t\t FAT_MAX_SHORT_SIZE);\n\t\t}\n\t}\n\n\treturn name_len;\n}\n\n \nint fat_search_long(struct inode *inode, const unsigned char *name,\n\t\t    int name_len, struct fat_slot_info *sinfo)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct buffer_head *bh = NULL;\n\tstruct msdos_dir_entry *de;\n\tunsigned char nr_slots;\n\twchar_t *unicode = NULL;\n\tunsigned char bufname[FAT_MAX_SHORT_SIZE];\n\tloff_t cpos = 0;\n\tint err, len;\n\n\terr = -ENOENT;\n\twhile (1) {\n\t\tif (fat_get_entry(inode, &cpos, &bh, &de) == -1)\n\t\t\tgoto end_of_dir;\nparse_record:\n\t\tnr_slots = 0;\n\t\tif (de->name[0] == DELETED_FLAG)\n\t\t\tcontinue;\n\t\tif (de->attr != ATTR_EXT && (de->attr & ATTR_VOLUME))\n\t\t\tcontinue;\n\t\tif (de->attr != ATTR_EXT && IS_FREE(de->name))\n\t\t\tcontinue;\n\t\tif (de->attr == ATTR_EXT) {\n\t\t\tint status = fat_parse_long(inode, &cpos, &bh, &de,\n\t\t\t\t\t\t    &unicode, &nr_slots);\n\t\t\tif (status < 0) {\n\t\t\t\terr = status;\n\t\t\t\tgoto end_of_dir;\n\t\t\t} else if (status == PARSE_INVALID)\n\t\t\t\tcontinue;\n\t\t\telse if (status == PARSE_NOT_LONGNAME)\n\t\t\t\tgoto parse_record;\n\t\t\telse if (status == PARSE_EOF)\n\t\t\t\tgoto end_of_dir;\n\t\t}\n\n\t\t \n\t\tlen = fat_parse_short(sb, de, bufname, 0);\n\t\tif (len == 0)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (fat_name_match(sbi, name, name_len, bufname, len))\n\t\t\tgoto found;\n\n\t\tif (nr_slots) {\n\t\t\tvoid *longname = unicode + FAT_MAX_UNI_CHARS;\n\t\t\tint size = PATH_MAX - FAT_MAX_UNI_SIZE;\n\n\t\t\t \n\t\t\tlen = fat_uni_to_x8(sb, unicode, longname, size);\n\t\t\tif (fat_name_match(sbi, name, name_len, longname, len))\n\t\t\t\tgoto found;\n\t\t}\n\t}\n\nfound:\n\tnr_slots++;\t \n\tsinfo->slot_off = cpos - nr_slots * sizeof(*de);\n\tsinfo->nr_slots = nr_slots;\n\tsinfo->de = de;\n\tsinfo->bh = bh;\n\tsinfo->i_pos = fat_make_i_pos(sb, sinfo->bh, sinfo->de);\n\terr = 0;\nend_of_dir:\n\tif (unicode)\n\t\t__putname(unicode);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(fat_search_long);\n\nstruct fat_ioctl_filldir_callback {\n\tstruct dir_context ctx;\n\tvoid __user *dirent;\n\tint result;\n\t \n\tconst char *longname;\n\tint long_len;\n\tconst char *shortname;\n\tint short_len;\n};\n\nstatic int __fat_readdir(struct inode *inode, struct file *file,\n\t\t\t struct dir_context *ctx, int short_only,\n\t\t\t struct fat_ioctl_filldir_callback *both)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct buffer_head *bh;\n\tstruct msdos_dir_entry *de;\n\tunsigned char nr_slots;\n\twchar_t *unicode = NULL;\n\tunsigned char bufname[FAT_MAX_SHORT_SIZE];\n\tint isvfat = sbi->options.isvfat;\n\tconst char *fill_name = NULL;\n\tint fake_offset = 0;\n\tloff_t cpos;\n\tint short_len = 0, fill_len = 0;\n\tint ret = 0;\n\n\tmutex_lock(&sbi->s_lock);\n\n\tcpos = ctx->pos;\n\t \n\tif (inode->i_ino == MSDOS_ROOT_INO) {\n\t\tif (!dir_emit_dots(file, ctx))\n\t\t\tgoto out;\n\t\tif (ctx->pos == 2) {\n\t\t\tfake_offset = 1;\n\t\t\tcpos = 0;\n\t\t}\n\t}\n\tif (cpos & (sizeof(struct msdos_dir_entry) - 1)) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tbh = NULL;\nget_new:\n\tif (fat_get_entry(inode, &cpos, &bh, &de) == -1)\n\t\tgoto end_of_dir;\nparse_record:\n\tnr_slots = 0;\n\t \n\tif (isvfat && !short_only) {\n\t\tif (de->name[0] == DELETED_FLAG)\n\t\t\tgoto record_end;\n\t\tif (de->attr != ATTR_EXT && (de->attr & ATTR_VOLUME))\n\t\t\tgoto record_end;\n\t\tif (de->attr != ATTR_EXT && IS_FREE(de->name))\n\t\t\tgoto record_end;\n\t} else {\n\t\tif ((de->attr & ATTR_VOLUME) || IS_FREE(de->name))\n\t\t\tgoto record_end;\n\t}\n\n\tif (isvfat && de->attr == ATTR_EXT) {\n\t\tint status = fat_parse_long(inode, &cpos, &bh, &de,\n\t\t\t\t\t    &unicode, &nr_slots);\n\t\tif (status < 0) {\n\t\t\tbh = NULL;\n\t\t\tret = status;\n\t\t\tgoto end_of_dir;\n\t\t} else if (status == PARSE_INVALID)\n\t\t\tgoto record_end;\n\t\telse if (status == PARSE_NOT_LONGNAME)\n\t\t\tgoto parse_record;\n\t\telse if (status == PARSE_EOF)\n\t\t\tgoto end_of_dir;\n\n\t\tif (nr_slots) {\n\t\t\tvoid *longname = unicode + FAT_MAX_UNI_CHARS;\n\t\t\tint size = PATH_MAX - FAT_MAX_UNI_SIZE;\n\t\t\tint len = fat_uni_to_x8(sb, unicode, longname, size);\n\n\t\t\tfill_name = longname;\n\t\t\tfill_len = len;\n\t\t\t \n\t\t\tif (!both)\n\t\t\t\tgoto start_filldir;\n\n\t\t\tshort_len = fat_parse_short(sb, de, bufname,\n\t\t\t\t\t\t    sbi->options.dotsOK);\n\t\t\tif (short_len == 0)\n\t\t\t\tgoto record_end;\n\t\t\t \n\t\t\tboth->longname = fill_name;\n\t\t\tboth->long_len = fill_len;\n\t\t\tboth->shortname = bufname;\n\t\t\tboth->short_len = short_len;\n\t\t\tfill_name = NULL;\n\t\t\tfill_len = 0;\n\t\t\tgoto start_filldir;\n\t\t}\n\t}\n\n\tshort_len = fat_parse_short(sb, de, bufname, sbi->options.dotsOK);\n\tif (short_len == 0)\n\t\tgoto record_end;\n\n\tfill_name = bufname;\n\tfill_len = short_len;\n\nstart_filldir:\n\tctx->pos = cpos - (nr_slots + 1) * sizeof(struct msdos_dir_entry);\n\tif (fake_offset && ctx->pos < 2)\n\t\tctx->pos = 2;\n\n\tif (!memcmp(de->name, MSDOS_DOT, MSDOS_NAME)) {\n\t\tif (!dir_emit_dot(file, ctx))\n\t\t\tgoto fill_failed;\n\t} else if (!memcmp(de->name, MSDOS_DOTDOT, MSDOS_NAME)) {\n\t\tif (!dir_emit_dotdot(file, ctx))\n\t\t\tgoto fill_failed;\n\t} else {\n\t\tunsigned long inum;\n\t\tloff_t i_pos = fat_make_i_pos(sb, bh, de);\n\t\tstruct inode *tmp = fat_iget(sb, i_pos);\n\t\tif (tmp) {\n\t\t\tinum = tmp->i_ino;\n\t\t\tiput(tmp);\n\t\t} else\n\t\t\tinum = iunique(sb, MSDOS_ROOT_INO);\n\t\tif (!dir_emit(ctx, fill_name, fill_len, inum,\n\t\t\t    (de->attr & ATTR_DIR) ? DT_DIR : DT_REG))\n\t\t\tgoto fill_failed;\n\t}\n\nrecord_end:\n\tfake_offset = 0;\n\tctx->pos = cpos;\n\tgoto get_new;\n\nend_of_dir:\n\tif (fake_offset && cpos < 2)\n\t\tctx->pos = 2;\n\telse\n\t\tctx->pos = cpos;\nfill_failed:\n\tbrelse(bh);\n\tif (unicode)\n\t\t__putname(unicode);\nout:\n\tmutex_unlock(&sbi->s_lock);\n\n\treturn ret;\n}\n\nstatic int fat_readdir(struct file *file, struct dir_context *ctx)\n{\n\treturn __fat_readdir(file_inode(file), file, ctx, 0, NULL);\n}\n\n#define FAT_IOCTL_FILLDIR_FUNC(func, dirent_type)\t\t\t   \\\nstatic bool func(struct dir_context *ctx, const char *name, int name_len,  \\\n\t\t\t     loff_t offset, u64 ino, unsigned int d_type)  \\\n{\t\t\t\t\t\t\t\t\t   \\\n\tstruct fat_ioctl_filldir_callback *buf =\t\t\t   \\\n\t\tcontainer_of(ctx, struct fat_ioctl_filldir_callback, ctx); \\\n\tstruct dirent_type __user *d1 = buf->dirent;\t\t\t   \\\n\tstruct dirent_type __user *d2 = d1 + 1;\t\t\t\t   \\\n\t\t\t\t\t\t\t\t\t   \\\n\tif (buf->result)\t\t\t\t\t\t   \\\n\t\treturn false;\t\t\t\t\t\t   \\\n\tbuf->result++;\t\t\t\t\t\t\t   \\\n\t\t\t\t\t\t\t\t\t   \\\n\tif (name != NULL) {\t\t\t\t\t\t   \\\n\t\t \t\t\t   \\\n\t\tif (name_len >= sizeof(d1->d_name))\t\t\t   \\\n\t\t\tname_len = sizeof(d1->d_name) - 1;\t\t   \\\n\t\t\t\t\t\t\t\t\t   \\\n\t\tif (put_user(0, &d2->d_name[0])\t\t\t||\t   \\\n\t\t    put_user(0, &d2->d_reclen)\t\t\t||\t   \\\n\t\t    copy_to_user(d1->d_name, name, name_len)\t||\t   \\\n\t\t    put_user(0, d1->d_name + name_len)\t\t||\t   \\\n\t\t    put_user(name_len, &d1->d_reclen))\t\t\t   \\\n\t\t\tgoto efault;\t\t\t\t\t   \\\n\t} else {\t\t\t\t\t\t\t   \\\n\t\t \t\t\t   \\\n\t\tconst char *longname = buf->longname;\t\t\t   \\\n\t\tint long_len = buf->long_len;\t\t\t\t   \\\n\t\tconst char *shortname = buf->shortname;\t\t\t   \\\n\t\tint short_len = buf->short_len;\t\t\t\t   \\\n\t\t\t\t\t\t\t\t\t   \\\n\t\tif (long_len >= sizeof(d1->d_name))\t\t\t   \\\n\t\t\tlong_len = sizeof(d1->d_name) - 1;\t\t   \\\n\t\tif (short_len >= sizeof(d1->d_name))\t\t\t   \\\n\t\t\tshort_len = sizeof(d1->d_name) - 1;\t\t   \\\n\t\t\t\t\t\t\t\t\t   \\\n\t\tif (copy_to_user(d2->d_name, longname, long_len)\t|| \\\n\t\t    put_user(0, d2->d_name + long_len)\t\t\t|| \\\n\t\t    put_user(long_len, &d2->d_reclen)\t\t\t|| \\\n\t\t    put_user(ino, &d2->d_ino)\t\t\t\t|| \\\n\t\t    put_user(offset, &d2->d_off)\t\t\t|| \\\n\t\t    copy_to_user(d1->d_name, shortname, short_len)\t|| \\\n\t\t    put_user(0, d1->d_name + short_len)\t\t\t|| \\\n\t\t    put_user(short_len, &d1->d_reclen))\t\t\t   \\\n\t\t\tgoto efault;\t\t\t\t\t   \\\n\t}\t\t\t\t\t\t\t\t   \\\n\treturn true;\t\t\t\t\t\t\t   \\\nefault:\t\t\t\t\t\t\t\t\t   \\\n\tbuf->result = -EFAULT;\t\t\t\t\t\t   \\\n\treturn false;\t\t\t\t\t\t\t   \\\n}\n\nFAT_IOCTL_FILLDIR_FUNC(fat_ioctl_filldir, __fat_dirent)\n\nstatic int fat_ioctl_readdir(struct inode *inode, struct file *file,\n\t\t\t     void __user *dirent, filldir_t filldir,\n\t\t\t     int short_only, int both)\n{\n\tstruct fat_ioctl_filldir_callback buf = {\n\t\t.ctx.actor = filldir,\n\t\t.dirent = dirent\n\t};\n\tint ret;\n\n\tbuf.dirent = dirent;\n\tbuf.result = 0;\n\tinode_lock_shared(inode);\n\tbuf.ctx.pos = file->f_pos;\n\tret = -ENOENT;\n\tif (!IS_DEADDIR(inode)) {\n\t\tret = __fat_readdir(inode, file, &buf.ctx,\n\t\t\t\t    short_only, both ? &buf : NULL);\n\t\tfile->f_pos = buf.ctx.pos;\n\t}\n\tinode_unlock_shared(inode);\n\tif (ret >= 0)\n\t\tret = buf.result;\n\treturn ret;\n}\n\nstatic long fat_dir_ioctl(struct file *filp, unsigned int cmd,\n\t\t\t  unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct __fat_dirent __user *d1 = (struct __fat_dirent __user *)arg;\n\tint short_only, both;\n\n\tswitch (cmd) {\n\tcase VFAT_IOCTL_READDIR_SHORT:\n\t\tshort_only = 1;\n\t\tboth = 0;\n\t\tbreak;\n\tcase VFAT_IOCTL_READDIR_BOTH:\n\t\tshort_only = 0;\n\t\tboth = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn fat_generic_ioctl(filp, cmd, arg);\n\t}\n\n\t \n\tif (put_user(0, &d1->d_reclen))\n\t\treturn -EFAULT;\n\n\treturn fat_ioctl_readdir(inode, filp, d1, fat_ioctl_filldir,\n\t\t\t\t short_only, both);\n}\n\n#ifdef CONFIG_COMPAT\n#define\tVFAT_IOCTL_READDIR_BOTH32\t_IOR('r', 1, struct compat_dirent[2])\n#define\tVFAT_IOCTL_READDIR_SHORT32\t_IOR('r', 2, struct compat_dirent[2])\n\nFAT_IOCTL_FILLDIR_FUNC(fat_compat_ioctl_filldir, compat_dirent)\n\nstatic long fat_compat_dir_ioctl(struct file *filp, unsigned cmd,\n\t\t\t\t unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct compat_dirent __user *d1 = compat_ptr(arg);\n\tint short_only, both;\n\n\tswitch (cmd) {\n\tcase VFAT_IOCTL_READDIR_SHORT32:\n\t\tshort_only = 1;\n\t\tboth = 0;\n\t\tbreak;\n\tcase VFAT_IOCTL_READDIR_BOTH32:\n\t\tshort_only = 0;\n\t\tboth = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn fat_generic_ioctl(filp, cmd, (unsigned long)arg);\n\t}\n\n\t \n\tif (put_user(0, &d1->d_reclen))\n\t\treturn -EFAULT;\n\n\treturn fat_ioctl_readdir(inode, filp, d1, fat_compat_ioctl_filldir,\n\t\t\t\t short_only, both);\n}\n#endif  \n\nconst struct file_operations fat_dir_operations = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= generic_read_dir,\n\t.iterate_shared\t= fat_readdir,\n\t.unlocked_ioctl\t= fat_dir_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t= fat_compat_dir_ioctl,\n#endif\n\t.fsync\t\t= fat_file_fsync,\n};\n\nstatic int fat_get_short_entry(struct inode *dir, loff_t *pos,\n\t\t\t       struct buffer_head **bh,\n\t\t\t       struct msdos_dir_entry **de)\n{\n\twhile (fat_get_entry(dir, pos, bh, de) >= 0) {\n\t\t \n\t\tif (!IS_FREE((*de)->name) && !((*de)->attr & ATTR_VOLUME))\n\t\t\treturn 0;\n\t}\n\treturn -ENOENT;\n}\n\n \nint fat_get_dotdot_entry(struct inode *dir, struct buffer_head **bh,\n\t\t\t struct msdos_dir_entry **de)\n{\n\tloff_t offset = 0;\n\n\t*de = NULL;\n\twhile (fat_get_short_entry(dir, &offset, bh, de) >= 0) {\n\t\tif (!strncmp((*de)->name, MSDOS_DOTDOT, MSDOS_NAME))\n\t\t\treturn 0;\n\t}\n\treturn -ENOENT;\n}\nEXPORT_SYMBOL_GPL(fat_get_dotdot_entry);\n\n \nint fat_dir_empty(struct inode *dir)\n{\n\tstruct buffer_head *bh;\n\tstruct msdos_dir_entry *de;\n\tloff_t cpos;\n\tint result = 0;\n\n\tbh = NULL;\n\tcpos = 0;\n\twhile (fat_get_short_entry(dir, &cpos, &bh, &de) >= 0) {\n\t\tif (strncmp(de->name, MSDOS_DOT   , MSDOS_NAME) &&\n\t\t    strncmp(de->name, MSDOS_DOTDOT, MSDOS_NAME)) {\n\t\t\tresult = -ENOTEMPTY;\n\t\t\tbreak;\n\t\t}\n\t}\n\tbrelse(bh);\n\treturn result;\n}\nEXPORT_SYMBOL_GPL(fat_dir_empty);\n\n \nint fat_subdirs(struct inode *dir)\n{\n\tstruct buffer_head *bh;\n\tstruct msdos_dir_entry *de;\n\tloff_t cpos;\n\tint count = 0;\n\n\tbh = NULL;\n\tcpos = 0;\n\twhile (fat_get_short_entry(dir, &cpos, &bh, &de) >= 0) {\n\t\tif (de->attr & ATTR_DIR)\n\t\t\tcount++;\n\t}\n\tbrelse(bh);\n\treturn count;\n}\n\n \nint fat_scan(struct inode *dir, const unsigned char *name,\n\t     struct fat_slot_info *sinfo)\n{\n\tstruct super_block *sb = dir->i_sb;\n\n\tsinfo->slot_off = 0;\n\tsinfo->bh = NULL;\n\twhile (fat_get_short_entry(dir, &sinfo->slot_off, &sinfo->bh,\n\t\t\t\t   &sinfo->de) >= 0) {\n\t\tif (!strncmp(sinfo->de->name, name, MSDOS_NAME)) {\n\t\t\tsinfo->slot_off -= sizeof(*sinfo->de);\n\t\t\tsinfo->nr_slots = 1;\n\t\t\tsinfo->i_pos = fat_make_i_pos(sb, sinfo->bh, sinfo->de);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOENT;\n}\nEXPORT_SYMBOL_GPL(fat_scan);\n\n \nint fat_scan_logstart(struct inode *dir, int i_logstart,\n\t\t      struct fat_slot_info *sinfo)\n{\n\tstruct super_block *sb = dir->i_sb;\n\n\tsinfo->slot_off = 0;\n\tsinfo->bh = NULL;\n\twhile (fat_get_short_entry(dir, &sinfo->slot_off, &sinfo->bh,\n\t\t\t\t   &sinfo->de) >= 0) {\n\t\tif (fat_get_start(MSDOS_SB(sb), sinfo->de) == i_logstart) {\n\t\t\tsinfo->slot_off -= sizeof(*sinfo->de);\n\t\t\tsinfo->nr_slots = 1;\n\t\t\tsinfo->i_pos = fat_make_i_pos(sb, sinfo->bh, sinfo->de);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOENT;\n}\n\nstatic int __fat_remove_entries(struct inode *dir, loff_t pos, int nr_slots)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct buffer_head *bh;\n\tstruct msdos_dir_entry *de, *endp;\n\tint err = 0, orig_slots;\n\n\twhile (nr_slots) {\n\t\tbh = NULL;\n\t\tif (fat_get_entry(dir, &pos, &bh, &de) < 0) {\n\t\t\terr = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\torig_slots = nr_slots;\n\t\tendp = (struct msdos_dir_entry *)(bh->b_data + sb->s_blocksize);\n\t\twhile (nr_slots && de < endp) {\n\t\t\tde->name[0] = DELETED_FLAG;\n\t\t\tde++;\n\t\t\tnr_slots--;\n\t\t}\n\t\tmark_buffer_dirty_inode(bh, dir);\n\t\tif (IS_DIRSYNC(dir))\n\t\t\terr = sync_dirty_buffer(bh);\n\t\tbrelse(bh);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\t \n\t\tpos += ((orig_slots - nr_slots) * sizeof(*de)) - sizeof(*de);\n\t}\n\n\treturn err;\n}\n\nint fat_remove_entries(struct inode *dir, struct fat_slot_info *sinfo)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct msdos_dir_entry *de;\n\tstruct buffer_head *bh;\n\tint err = 0, nr_slots;\n\n\t \n\tnr_slots = sinfo->nr_slots;\n\tde = sinfo->de;\n\tsinfo->de = NULL;\n\tbh = sinfo->bh;\n\tsinfo->bh = NULL;\n\twhile (nr_slots && de >= (struct msdos_dir_entry *)bh->b_data) {\n\t\tde->name[0] = DELETED_FLAG;\n\t\tde--;\n\t\tnr_slots--;\n\t}\n\tmark_buffer_dirty_inode(bh, dir);\n\tif (IS_DIRSYNC(dir))\n\t\terr = sync_dirty_buffer(bh);\n\tbrelse(bh);\n\tif (err)\n\t\treturn err;\n\tinode_inc_iversion(dir);\n\n\tif (nr_slots) {\n\t\t \n\t\terr = __fat_remove_entries(dir, sinfo->slot_off, nr_slots);\n\t\tif (err) {\n\t\t\tfat_msg(sb, KERN_WARNING,\n\t\t\t       \"Couldn't remove the long name slots\");\n\t\t}\n\t}\n\n\tfat_truncate_time(dir, NULL, S_ATIME|S_MTIME);\n\tif (IS_DIRSYNC(dir))\n\t\t(void)fat_sync_inode(dir);\n\telse\n\t\tmark_inode_dirty(dir);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(fat_remove_entries);\n\nstatic int fat_zeroed_cluster(struct inode *dir, sector_t blknr, int nr_used,\n\t\t\t      struct buffer_head **bhs, int nr_bhs)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tsector_t last_blknr = blknr + MSDOS_SB(sb)->sec_per_clus;\n\tint err, i, n;\n\n\t \n\tblknr += nr_used;\n\tn = nr_used;\n\twhile (blknr < last_blknr) {\n\t\tbhs[n] = sb_getblk(sb, blknr);\n\t\tif (!bhs[n]) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\t\t \n\t\tlock_buffer(bhs[n]);\n\t\tmemset(bhs[n]->b_data, 0, sb->s_blocksize);\n\t\tset_buffer_uptodate(bhs[n]);\n\t\tunlock_buffer(bhs[n]);\n\t\tmark_buffer_dirty_inode(bhs[n], dir);\n\n\t\tn++;\n\t\tblknr++;\n\t\tif (n == nr_bhs) {\n\t\t\tif (IS_DIRSYNC(dir)) {\n\t\t\t\terr = fat_sync_bhs(bhs, n);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tfor (i = 0; i < n; i++)\n\t\t\t\tbrelse(bhs[i]);\n\t\t\tn = 0;\n\t\t}\n\t}\n\tif (IS_DIRSYNC(dir)) {\n\t\terr = fat_sync_bhs(bhs, n);\n\t\tif (err)\n\t\t\tgoto error;\n\t}\n\tfor (i = 0; i < n; i++)\n\t\tbrelse(bhs[i]);\n\n\treturn 0;\n\nerror:\n\tfor (i = 0; i < n; i++)\n\t\tbforget(bhs[i]);\n\treturn err;\n}\n\nint fat_alloc_new_dir(struct inode *dir, struct timespec64 *ts)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct buffer_head *bhs[MAX_BUF_PER_PAGE];\n\tstruct msdos_dir_entry *de;\n\tsector_t blknr;\n\t__le16 date, time;\n\tu8 time_cs;\n\tint err, cluster;\n\n\terr = fat_alloc_clusters(dir, &cluster, 1);\n\tif (err)\n\t\tgoto error;\n\n\tblknr = fat_clus_to_blknr(sbi, cluster);\n\tbhs[0] = sb_getblk(sb, blknr);\n\tif (!bhs[0]) {\n\t\terr = -ENOMEM;\n\t\tgoto error_free;\n\t}\n\n\tfat_time_unix2fat(sbi, ts, &time, &date, &time_cs);\n\n\tde = (struct msdos_dir_entry *)bhs[0]->b_data;\n\t \n\tlock_buffer(bhs[0]);\n\t \n\tmemcpy(de[0].name, MSDOS_DOT, MSDOS_NAME);\n\tmemcpy(de[1].name, MSDOS_DOTDOT, MSDOS_NAME);\n\tde->attr = de[1].attr = ATTR_DIR;\n\tde[0].lcase = de[1].lcase = 0;\n\tde[0].time = de[1].time = time;\n\tde[0].date = de[1].date = date;\n\tif (sbi->options.isvfat) {\n\t\t \n\t\tde[0].ctime = de[1].ctime = time;\n\t\tde[0].ctime_cs = de[1].ctime_cs = time_cs;\n\t\tde[0].adate = de[0].cdate = de[1].adate = de[1].cdate = date;\n\t} else {\n\t\tde[0].ctime = de[1].ctime = 0;\n\t\tde[0].ctime_cs = de[1].ctime_cs = 0;\n\t\tde[0].adate = de[0].cdate = de[1].adate = de[1].cdate = 0;\n\t}\n\tfat_set_start(&de[0], cluster);\n\tfat_set_start(&de[1], MSDOS_I(dir)->i_logstart);\n\tde[0].size = de[1].size = 0;\n\tmemset(de + 2, 0, sb->s_blocksize - 2 * sizeof(*de));\n\tset_buffer_uptodate(bhs[0]);\n\tunlock_buffer(bhs[0]);\n\tmark_buffer_dirty_inode(bhs[0], dir);\n\n\terr = fat_zeroed_cluster(dir, blknr, 1, bhs, MAX_BUF_PER_PAGE);\n\tif (err)\n\t\tgoto error_free;\n\n\treturn cluster;\n\nerror_free:\n\tfat_free_clusters(dir, cluster);\nerror:\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(fat_alloc_new_dir);\n\nstatic int fat_add_new_entries(struct inode *dir, void *slots, int nr_slots,\n\t\t\t       int *nr_cluster, struct msdos_dir_entry **de,\n\t\t\t       struct buffer_head **bh, loff_t *i_pos)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct buffer_head *bhs[MAX_BUF_PER_PAGE];\n\tsector_t blknr, start_blknr, last_blknr;\n\tunsigned long size, copy;\n\tint err, i, n, offset, cluster[2];\n\n\t \n\tsize = nr_slots * sizeof(struct msdos_dir_entry);\n\t*nr_cluster = (size + (sbi->cluster_size - 1)) >> sbi->cluster_bits;\n\tBUG_ON(*nr_cluster > 2);\n\n\terr = fat_alloc_clusters(dir, cluster, *nr_cluster);\n\tif (err)\n\t\tgoto error;\n\n\t \n\ti = n = copy = 0;\n\tdo {\n\t\tstart_blknr = blknr = fat_clus_to_blknr(sbi, cluster[i]);\n\t\tlast_blknr = start_blknr + sbi->sec_per_clus;\n\t\twhile (blknr < last_blknr) {\n\t\t\tbhs[n] = sb_getblk(sb, blknr);\n\t\t\tif (!bhs[n]) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto error_nomem;\n\t\t\t}\n\n\t\t\t \n\t\t\tcopy = min(size, sb->s_blocksize);\n\t\t\t \n\t\t\tlock_buffer(bhs[n]);\n\t\t\tmemcpy(bhs[n]->b_data, slots, copy);\n\t\t\tset_buffer_uptodate(bhs[n]);\n\t\t\tunlock_buffer(bhs[n]);\n\t\t\tmark_buffer_dirty_inode(bhs[n], dir);\n\t\t\tslots += copy;\n\t\t\tsize -= copy;\n\t\t\tif (!size)\n\t\t\t\tbreak;\n\t\t\tn++;\n\t\t\tblknr++;\n\t\t}\n\t} while (++i < *nr_cluster);\n\n\tmemset(bhs[n]->b_data + copy, 0, sb->s_blocksize - copy);\n\toffset = copy - sizeof(struct msdos_dir_entry);\n\tget_bh(bhs[n]);\n\t*bh = bhs[n];\n\t*de = (struct msdos_dir_entry *)((*bh)->b_data + offset);\n\t*i_pos = fat_make_i_pos(sb, *bh, *de);\n\n\t \n\terr = fat_zeroed_cluster(dir, start_blknr, ++n, bhs, MAX_BUF_PER_PAGE);\n\tif (err)\n\t\tgoto error_free;\n\n\treturn cluster[0];\n\nerror_free:\n\tbrelse(*bh);\n\t*bh = NULL;\n\tn = 0;\nerror_nomem:\n\tfor (i = 0; i < n; i++)\n\t\tbforget(bhs[i]);\n\tfat_free_clusters(dir, cluster[0]);\nerror:\n\treturn err;\n}\n\nint fat_add_entries(struct inode *dir, void *slots, int nr_slots,\n\t\t    struct fat_slot_info *sinfo)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct buffer_head *bh, *prev, *bhs[3];  \n\tstruct msdos_dir_entry *de;\n\tint err, free_slots, i, nr_bhs;\n\tloff_t pos, i_pos;\n\n\tsinfo->nr_slots = nr_slots;\n\n\t \n\tfree_slots = nr_bhs = 0;\n\tbh = prev = NULL;\n\tpos = 0;\n\terr = -ENOSPC;\n\twhile (fat_get_entry(dir, &pos, &bh, &de) > -1) {\n\t\t \n\t\tif (pos >= FAT_MAX_DIR_SIZE)\n\t\t\tgoto error;\n\n\t\tif (IS_FREE(de->name)) {\n\t\t\tif (prev != bh) {\n\t\t\t\tget_bh(bh);\n\t\t\t\tbhs[nr_bhs] = prev = bh;\n\t\t\t\tnr_bhs++;\n\t\t\t}\n\t\t\tfree_slots++;\n\t\t\tif (free_slots == nr_slots)\n\t\t\t\tgoto found;\n\t\t} else {\n\t\t\tfor (i = 0; i < nr_bhs; i++)\n\t\t\t\tbrelse(bhs[i]);\n\t\t\tprev = NULL;\n\t\t\tfree_slots = nr_bhs = 0;\n\t\t}\n\t}\n\tif (dir->i_ino == MSDOS_ROOT_INO) {\n\t\tif (!is_fat32(sbi))\n\t\t\tgoto error;\n\t} else if (MSDOS_I(dir)->i_start == 0) {\n\t\tfat_msg(sb, KERN_ERR, \"Corrupted directory (i_pos %lld)\",\n\t\t       MSDOS_I(dir)->i_pos);\n\t\terr = -EIO;\n\t\tgoto error;\n\t}\n\nfound:\n\terr = 0;\n\tpos -= free_slots * sizeof(*de);\n\tnr_slots -= free_slots;\n\tif (free_slots) {\n\t\t \n\t\tint size = free_slots * sizeof(*de);\n\t\tint offset = pos & (sb->s_blocksize - 1);\n\t\tint long_bhs = nr_bhs - (nr_slots == 0);\n\n\t\t \n\t\tfor (i = 0; i < long_bhs; i++) {\n\t\t\tint copy = min_t(int, sb->s_blocksize - offset, size);\n\t\t\tmemcpy(bhs[i]->b_data + offset, slots, copy);\n\t\t\tmark_buffer_dirty_inode(bhs[i], dir);\n\t\t\toffset = 0;\n\t\t\tslots += copy;\n\t\t\tsize -= copy;\n\t\t}\n\t\tif (long_bhs && IS_DIRSYNC(dir))\n\t\t\terr = fat_sync_bhs(bhs, long_bhs);\n\t\tif (!err && i < nr_bhs) {\n\t\t\t \n\t\t\tint copy = min_t(int, sb->s_blocksize - offset, size);\n\t\t\tmemcpy(bhs[i]->b_data + offset, slots, copy);\n\t\t\tmark_buffer_dirty_inode(bhs[i], dir);\n\t\t\tif (IS_DIRSYNC(dir))\n\t\t\t\terr = sync_dirty_buffer(bhs[i]);\n\t\t}\n\t\tfor (i = 0; i < nr_bhs; i++)\n\t\t\tbrelse(bhs[i]);\n\t\tif (err)\n\t\t\tgoto error_remove;\n\t}\n\n\tif (nr_slots) {\n\t\tint cluster, nr_cluster;\n\n\t\t \n\t\tcluster = fat_add_new_entries(dir, slots, nr_slots, &nr_cluster,\n\t\t\t\t\t      &de, &bh, &i_pos);\n\t\tif (cluster < 0) {\n\t\t\terr = cluster;\n\t\t\tgoto error_remove;\n\t\t}\n\t\terr = fat_chain_add(dir, cluster, nr_cluster);\n\t\tif (err) {\n\t\t\tfat_free_clusters(dir, cluster);\n\t\t\tgoto error_remove;\n\t\t}\n\t\tif (dir->i_size & (sbi->cluster_size - 1)) {\n\t\t\tfat_fs_error(sb, \"Odd directory size\");\n\t\t\tdir->i_size = (dir->i_size + sbi->cluster_size - 1)\n\t\t\t\t& ~((loff_t)sbi->cluster_size - 1);\n\t\t}\n\t\tdir->i_size += nr_cluster << sbi->cluster_bits;\n\t\tMSDOS_I(dir)->mmu_private += nr_cluster << sbi->cluster_bits;\n\t}\n\tsinfo->slot_off = pos;\n\tsinfo->de = de;\n\tsinfo->bh = bh;\n\tsinfo->i_pos = fat_make_i_pos(sb, sinfo->bh, sinfo->de);\n\n\treturn 0;\n\nerror:\n\tbrelse(bh);\n\tfor (i = 0; i < nr_bhs; i++)\n\t\tbrelse(bhs[i]);\n\treturn err;\n\nerror_remove:\n\tbrelse(bh);\n\tif (free_slots)\n\t\t__fat_remove_entries(dir, pos, free_slots);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(fat_add_entries);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}