{
  "module_name": "fat_test.c",
  "hash_id": "2d0bca962048ce7c58b5b77c8f78428ff80441adab3099e3add6587cc8c59baa",
  "original_prompt": "Ingested from linux-6.6.14/fs/fat/fat_test.c",
  "human_readable_source": "\n \n\n#include <kunit/test.h>\n\n#include \"fat.h\"\n\nstatic void fat_checksum_test(struct kunit *test)\n{\n\t \n\tKUNIT_EXPECT_EQ(test, fat_checksum(\"VMLINUX    \"), (u8)44);\n\t \n\tKUNIT_EXPECT_EQ(test, fat_checksum(\"README  TXT\"), (u8)115);\n\t \n\tKUNIT_EXPECT_EQ(test, fat_checksum(\"ABCDEFGHA  \"), (u8)98);\n}\n\nstruct fat_timestamp_testcase {\n\tconst char *name;\n\tstruct timespec64 ts;\n\t__le16 time;\n\t__le16 date;\n\tu8 cs;\n\tint time_offset;\n};\n\nstatic struct fat_timestamp_testcase time_test_cases[] = {\n\t{\n\t\t.name = \"Earliest possible UTC (1980-01-01 00:00:00)\",\n\t\t.ts = {.tv_sec = 315532800LL, .tv_nsec = 0L},\n\t\t.time = cpu_to_le16(0),\n\t\t.date = cpu_to_le16(33),\n\t\t.cs = 0,\n\t\t.time_offset = 0,\n\t},\n\t{\n\t\t.name = \"Latest possible UTC (2107-12-31 23:59:58)\",\n\t\t.ts = {.tv_sec = 4354819198LL, .tv_nsec = 0L},\n\t\t.time = cpu_to_le16(49021),\n\t\t.date = cpu_to_le16(65439),\n\t\t.cs = 0,\n\t\t.time_offset = 0,\n\t},\n\t{\n\t\t.name = \"Earliest possible (UTC-11) (== 1979-12-31 13:00:00 UTC)\",\n\t\t.ts = {.tv_sec = 315493200LL, .tv_nsec = 0L},\n\t\t.time = cpu_to_le16(0),\n\t\t.date = cpu_to_le16(33),\n\t\t.cs = 0,\n\t\t.time_offset = 11 * 60,\n\t},\n\t{\n\t\t.name = \"Latest possible (UTC+11) (== 2108-01-01 10:59:58 UTC)\",\n\t\t.ts = {.tv_sec = 4354858798LL, .tv_nsec = 0L},\n\t\t.time = cpu_to_le16(49021),\n\t\t.date = cpu_to_le16(65439),\n\t\t.cs = 0,\n\t\t.time_offset = -11 * 60,\n\t},\n\t{\n\t\t.name = \"Leap Day / Year (1996-02-29 00:00:00)\",\n\t\t.ts = {.tv_sec = 825552000LL, .tv_nsec = 0L},\n\t\t.time = cpu_to_le16(0),\n\t\t.date = cpu_to_le16(8285),\n\t\t.cs = 0,\n\t\t.time_offset = 0,\n\t},\n\t{\n\t\t.name = \"Year 2000 is leap year (2000-02-29 00:00:00)\",\n\t\t.ts = {.tv_sec = 951782400LL, .tv_nsec = 0L},\n\t\t.time = cpu_to_le16(0),\n\t\t.date = cpu_to_le16(10333),\n\t\t.cs = 0,\n\t\t.time_offset = 0,\n\t},\n\t{\n\t\t.name = \"Year 2100 not leap year (2100-03-01 00:00:00)\",\n\t\t.ts = {.tv_sec = 4107542400LL, .tv_nsec = 0L},\n\t\t.time = cpu_to_le16(0),\n\t\t.date = cpu_to_le16(61537),\n\t\t.cs = 0,\n\t\t.time_offset = 0,\n\t},\n\t{\n\t\t.name = \"Leap year + timezone UTC+1 (== 2004-02-29 00:30:00 UTC)\",\n\t\t.ts = {.tv_sec = 1078014600LL, .tv_nsec = 0L},\n\t\t.time = cpu_to_le16(48064),\n\t\t.date = cpu_to_le16(12380),\n\t\t.cs = 0,\n\t\t.time_offset = -60,\n\t},\n\t{\n\t\t.name = \"Leap year + timezone UTC-1 (== 2004-02-29 23:30:00 UTC)\",\n\t\t.ts = {.tv_sec = 1078097400LL, .tv_nsec = 0L},\n\t\t.time = cpu_to_le16(960),\n\t\t.date = cpu_to_le16(12385),\n\t\t.cs = 0,\n\t\t.time_offset = 60,\n\t},\n\t{\n\t\t.name = \"VFAT odd-second resolution (1999-12-31 23:59:59)\",\n\t\t.ts = {.tv_sec = 946684799LL, .tv_nsec = 0L},\n\t\t.time = cpu_to_le16(49021),\n\t\t.date = cpu_to_le16(10143),\n\t\t.cs = 100,\n\t\t.time_offset = 0,\n\t},\n\t{\n\t\t.name = \"VFAT 10ms resolution (1980-01-01 00:00:00:0010)\",\n\t\t.ts = {.tv_sec = 315532800LL, .tv_nsec = 10000000L},\n\t\t.time = cpu_to_le16(0),\n\t\t.date = cpu_to_le16(33),\n\t\t.cs = 1,\n\t\t.time_offset = 0,\n\t},\n};\n\nstatic void time_testcase_desc(struct fat_timestamp_testcase *t,\n\t\t\t       char *desc)\n{\n\tstrscpy(desc, t->name, KUNIT_PARAM_DESC_SIZE);\n}\n\nKUNIT_ARRAY_PARAM(fat_time, time_test_cases, time_testcase_desc);\n\nstatic void fat_time_fat2unix_test(struct kunit *test)\n{\n\tstatic struct msdos_sb_info fake_sb;\n\tstruct timespec64 ts;\n\tstruct fat_timestamp_testcase *testcase =\n\t\t(struct fat_timestamp_testcase *)test->param_value;\n\n\tfake_sb.options.tz_set = 1;\n\tfake_sb.options.time_offset = testcase->time_offset;\n\n\tfat_time_fat2unix(&fake_sb, &ts,\n\t\t\t  testcase->time,\n\t\t\t  testcase->date,\n\t\t\t  testcase->cs);\n\tKUNIT_EXPECT_EQ_MSG(test,\n\t\t\t    testcase->ts.tv_sec,\n\t\t\t    ts.tv_sec,\n\t\t\t    \"Timestamp mismatch (seconds)\\n\");\n\tKUNIT_EXPECT_EQ_MSG(test,\n\t\t\t    testcase->ts.tv_nsec,\n\t\t\t    ts.tv_nsec,\n\t\t\t    \"Timestamp mismatch (nanoseconds)\\n\");\n}\n\nstatic void fat_time_unix2fat_test(struct kunit *test)\n{\n\tstatic struct msdos_sb_info fake_sb;\n\t__le16 date, time;\n\tu8 cs;\n\tstruct fat_timestamp_testcase *testcase =\n\t\t(struct fat_timestamp_testcase *)test->param_value;\n\n\tfake_sb.options.tz_set = 1;\n\tfake_sb.options.time_offset = testcase->time_offset;\n\n\tfat_time_unix2fat(&fake_sb, &testcase->ts,\n\t\t\t  &time, &date, &cs);\n\tKUNIT_EXPECT_EQ_MSG(test,\n\t\t\t    le16_to_cpu(testcase->time),\n\t\t\t    le16_to_cpu(time),\n\t\t\t    \"Time mismatch\\n\");\n\tKUNIT_EXPECT_EQ_MSG(test,\n\t\t\t    le16_to_cpu(testcase->date),\n\t\t\t    le16_to_cpu(date),\n\t\t\t    \"Date mismatch\\n\");\n\tKUNIT_EXPECT_EQ_MSG(test,\n\t\t\t    testcase->cs,\n\t\t\t    cs,\n\t\t\t    \"Centisecond mismatch\\n\");\n}\n\nstatic struct kunit_case fat_test_cases[] = {\n\tKUNIT_CASE(fat_checksum_test),\n\tKUNIT_CASE_PARAM(fat_time_fat2unix_test, fat_time_gen_params),\n\tKUNIT_CASE_PARAM(fat_time_unix2fat_test, fat_time_gen_params),\n\t{},\n};\n\nstatic struct kunit_suite fat_test_suite = {\n\t.name = \"fat_test\",\n\t.test_cases = fat_test_cases,\n};\n\nkunit_test_suites(&fat_test_suite);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}