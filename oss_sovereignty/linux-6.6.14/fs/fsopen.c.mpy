{
  "module_name": "fsopen.c",
  "hash_id": "598f863bc5fa98c94bf3fed92fec1c9f9af4501795f077c861ea41e1fa259b52",
  "original_prompt": "Ingested from linux-6.6.14/fs/fsopen.c",
  "human_readable_source": "\n \n\n#include <linux/fs_context.h>\n#include <linux/fs_parser.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/anon_inodes.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <uapi/linux/mount.h>\n#include \"internal.h\"\n#include \"mount.h\"\n\n \nstatic ssize_t fscontext_read(struct file *file,\n\t\t\t      char __user *_buf, size_t len, loff_t *pos)\n{\n\tstruct fs_context *fc = file->private_data;\n\tstruct fc_log *log = fc->log.log;\n\tunsigned int logsize = ARRAY_SIZE(log->buffer);\n\tssize_t ret;\n\tchar *p;\n\tbool need_free;\n\tint index, n;\n\n\tret = mutex_lock_interruptible(&fc->uapi_mutex);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (log->head == log->tail) {\n\t\tmutex_unlock(&fc->uapi_mutex);\n\t\treturn -ENODATA;\n\t}\n\n\tindex = log->tail & (logsize - 1);\n\tp = log->buffer[index];\n\tneed_free = log->need_free & (1 << index);\n\tlog->buffer[index] = NULL;\n\tlog->need_free &= ~(1 << index);\n\tlog->tail++;\n\tmutex_unlock(&fc->uapi_mutex);\n\n\tret = -EMSGSIZE;\n\tn = strlen(p);\n\tif (n > len)\n\t\tgoto err_free;\n\tret = -EFAULT;\n\tif (copy_to_user(_buf, p, n) != 0)\n\t\tgoto err_free;\n\tret = n;\n\nerr_free:\n\tif (need_free)\n\t\tkfree(p);\n\treturn ret;\n}\n\nstatic int fscontext_release(struct inode *inode, struct file *file)\n{\n\tstruct fs_context *fc = file->private_data;\n\n\tif (fc) {\n\t\tfile->private_data = NULL;\n\t\tput_fs_context(fc);\n\t}\n\treturn 0;\n}\n\nconst struct file_operations fscontext_fops = {\n\t.read\t\t= fscontext_read,\n\t.release\t= fscontext_release,\n\t.llseek\t\t= no_llseek,\n};\n\n \nstatic int fscontext_create_fd(struct fs_context *fc, unsigned int o_flags)\n{\n\tint fd;\n\n\tfd = anon_inode_getfd(\"[fscontext]\", &fscontext_fops, fc,\n\t\t\t      O_RDWR | o_flags);\n\tif (fd < 0)\n\t\tput_fs_context(fc);\n\treturn fd;\n}\n\nstatic int fscontext_alloc_log(struct fs_context *fc)\n{\n\tfc->log.log = kzalloc(sizeof(*fc->log.log), GFP_KERNEL);\n\tif (!fc->log.log)\n\t\treturn -ENOMEM;\n\trefcount_set(&fc->log.log->usage, 1);\n\tfc->log.log->owner = fc->fs_type->owner;\n\treturn 0;\n}\n\n \nSYSCALL_DEFINE2(fsopen, const char __user *, _fs_name, unsigned int, flags)\n{\n\tstruct file_system_type *fs_type;\n\tstruct fs_context *fc;\n\tconst char *fs_name;\n\tint ret;\n\n\tif (!may_mount())\n\t\treturn -EPERM;\n\n\tif (flags & ~FSOPEN_CLOEXEC)\n\t\treturn -EINVAL;\n\n\tfs_name = strndup_user(_fs_name, PAGE_SIZE);\n\tif (IS_ERR(fs_name))\n\t\treturn PTR_ERR(fs_name);\n\n\tfs_type = get_fs_type(fs_name);\n\tkfree(fs_name);\n\tif (!fs_type)\n\t\treturn -ENODEV;\n\n\tfc = fs_context_for_mount(fs_type, 0);\n\tput_filesystem(fs_type);\n\tif (IS_ERR(fc))\n\t\treturn PTR_ERR(fc);\n\n\tfc->phase = FS_CONTEXT_CREATE_PARAMS;\n\n\tret = fscontext_alloc_log(fc);\n\tif (ret < 0)\n\t\tgoto err_fc;\n\n\treturn fscontext_create_fd(fc, flags & FSOPEN_CLOEXEC ? O_CLOEXEC : 0);\n\nerr_fc:\n\tput_fs_context(fc);\n\treturn ret;\n}\n\n \nSYSCALL_DEFINE3(fspick, int, dfd, const char __user *, path, unsigned int, flags)\n{\n\tstruct fs_context *fc;\n\tstruct path target;\n\tunsigned int lookup_flags;\n\tint ret;\n\n\tif (!may_mount())\n\t\treturn -EPERM;\n\n\tif ((flags & ~(FSPICK_CLOEXEC |\n\t\t       FSPICK_SYMLINK_NOFOLLOW |\n\t\t       FSPICK_NO_AUTOMOUNT |\n\t\t       FSPICK_EMPTY_PATH)) != 0)\n\t\treturn -EINVAL;\n\n\tlookup_flags = LOOKUP_FOLLOW | LOOKUP_AUTOMOUNT;\n\tif (flags & FSPICK_SYMLINK_NOFOLLOW)\n\t\tlookup_flags &= ~LOOKUP_FOLLOW;\n\tif (flags & FSPICK_NO_AUTOMOUNT)\n\t\tlookup_flags &= ~LOOKUP_AUTOMOUNT;\n\tif (flags & FSPICK_EMPTY_PATH)\n\t\tlookup_flags |= LOOKUP_EMPTY;\n\tret = user_path_at(dfd, path, lookup_flags, &target);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tret = -EINVAL;\n\tif (target.mnt->mnt_root != target.dentry)\n\t\tgoto err_path;\n\n\tfc = fs_context_for_reconfigure(target.dentry, 0, 0);\n\tif (IS_ERR(fc)) {\n\t\tret = PTR_ERR(fc);\n\t\tgoto err_path;\n\t}\n\n\tfc->phase = FS_CONTEXT_RECONF_PARAMS;\n\n\tret = fscontext_alloc_log(fc);\n\tif (ret < 0)\n\t\tgoto err_fc;\n\n\tpath_put(&target);\n\treturn fscontext_create_fd(fc, flags & FSPICK_CLOEXEC ? O_CLOEXEC : 0);\n\nerr_fc:\n\tput_fs_context(fc);\nerr_path:\n\tpath_put(&target);\nerr:\n\treturn ret;\n}\n\nstatic int vfs_cmd_create(struct fs_context *fc, bool exclusive)\n{\n\tstruct super_block *sb;\n\tint ret;\n\n\tif (fc->phase != FS_CONTEXT_CREATE_PARAMS)\n\t\treturn -EBUSY;\n\n\tif (!mount_capable(fc))\n\t\treturn -EPERM;\n\n\t \n\tif (exclusive && fc->ops == &legacy_fs_context_ops)\n\t\treturn -EOPNOTSUPP;\n\n\tfc->phase = FS_CONTEXT_CREATING;\n\tfc->exclusive = exclusive;\n\n\tret = vfs_get_tree(fc);\n\tif (ret) {\n\t\tfc->phase = FS_CONTEXT_FAILED;\n\t\treturn ret;\n\t}\n\n\tsb = fc->root->d_sb;\n\tret = security_sb_kern_mount(sb);\n\tif (unlikely(ret)) {\n\t\tfc_drop_locked(fc);\n\t\tfc->phase = FS_CONTEXT_FAILED;\n\t\treturn ret;\n\t}\n\n\t \n\tup_write(&sb->s_umount);\n\tfc->phase = FS_CONTEXT_AWAITING_MOUNT;\n\treturn 0;\n}\n\nstatic int vfs_cmd_reconfigure(struct fs_context *fc)\n{\n\tstruct super_block *sb;\n\tint ret;\n\n\tif (fc->phase != FS_CONTEXT_RECONF_PARAMS)\n\t\treturn -EBUSY;\n\n\tfc->phase = FS_CONTEXT_RECONFIGURING;\n\n\tsb = fc->root->d_sb;\n\tif (!ns_capable(sb->s_user_ns, CAP_SYS_ADMIN)) {\n\t\tfc->phase = FS_CONTEXT_FAILED;\n\t\treturn -EPERM;\n\t}\n\n\tdown_write(&sb->s_umount);\n\tret = reconfigure_super(fc);\n\tup_write(&sb->s_umount);\n\tif (ret) {\n\t\tfc->phase = FS_CONTEXT_FAILED;\n\t\treturn ret;\n\t}\n\n\tvfs_clean_context(fc);\n\treturn 0;\n}\n\n \nstatic int vfs_fsconfig_locked(struct fs_context *fc, int cmd,\n\t\t\t       struct fs_parameter *param)\n{\n\tint ret;\n\n\tret = finish_clean_context(fc);\n\tif (ret)\n\t\treturn ret;\n\tswitch (cmd) {\n\tcase FSCONFIG_CMD_CREATE:\n\t\treturn vfs_cmd_create(fc, false);\n\tcase FSCONFIG_CMD_CREATE_EXCL:\n\t\treturn vfs_cmd_create(fc, true);\n\tcase FSCONFIG_CMD_RECONFIGURE:\n\t\treturn vfs_cmd_reconfigure(fc);\n\tdefault:\n\t\tif (fc->phase != FS_CONTEXT_CREATE_PARAMS &&\n\t\t    fc->phase != FS_CONTEXT_RECONF_PARAMS)\n\t\t\treturn -EBUSY;\n\n\t\treturn vfs_parse_fs_param(fc, param);\n\t}\n}\n\n \nSYSCALL_DEFINE5(fsconfig,\n\t\tint, fd,\n\t\tunsigned int, cmd,\n\t\tconst char __user *, _key,\n\t\tconst void __user *, _value,\n\t\tint, aux)\n{\n\tstruct fs_context *fc;\n\tstruct fd f;\n\tint ret;\n\tint lookup_flags = 0;\n\n\tstruct fs_parameter param = {\n\t\t.type\t= fs_value_is_undefined,\n\t};\n\n\tif (fd < 0)\n\t\treturn -EINVAL;\n\n\tswitch (cmd) {\n\tcase FSCONFIG_SET_FLAG:\n\t\tif (!_key || _value || aux)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase FSCONFIG_SET_STRING:\n\t\tif (!_key || !_value || aux)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase FSCONFIG_SET_BINARY:\n\t\tif (!_key || !_value || aux <= 0 || aux > 1024 * 1024)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase FSCONFIG_SET_PATH:\n\tcase FSCONFIG_SET_PATH_EMPTY:\n\t\tif (!_key || !_value || (aux != AT_FDCWD && aux < 0))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase FSCONFIG_SET_FD:\n\t\tif (!_key || _value || aux < 0)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase FSCONFIG_CMD_CREATE:\n\tcase FSCONFIG_CMD_CREATE_EXCL:\n\tcase FSCONFIG_CMD_RECONFIGURE:\n\t\tif (_key || _value || aux)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tf = fdget(fd);\n\tif (!f.file)\n\t\treturn -EBADF;\n\tret = -EINVAL;\n\tif (f.file->f_op != &fscontext_fops)\n\t\tgoto out_f;\n\n\tfc = f.file->private_data;\n\tif (fc->ops == &legacy_fs_context_ops) {\n\t\tswitch (cmd) {\n\t\tcase FSCONFIG_SET_BINARY:\n\t\tcase FSCONFIG_SET_PATH:\n\t\tcase FSCONFIG_SET_PATH_EMPTY:\n\t\tcase FSCONFIG_SET_FD:\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto out_f;\n\t\t}\n\t}\n\n\tif (_key) {\n\t\tparam.key = strndup_user(_key, 256);\n\t\tif (IS_ERR(param.key)) {\n\t\t\tret = PTR_ERR(param.key);\n\t\t\tgoto out_f;\n\t\t}\n\t}\n\n\tswitch (cmd) {\n\tcase FSCONFIG_SET_FLAG:\n\t\tparam.type = fs_value_is_flag;\n\t\tbreak;\n\tcase FSCONFIG_SET_STRING:\n\t\tparam.type = fs_value_is_string;\n\t\tparam.string = strndup_user(_value, 256);\n\t\tif (IS_ERR(param.string)) {\n\t\t\tret = PTR_ERR(param.string);\n\t\t\tgoto out_key;\n\t\t}\n\t\tparam.size = strlen(param.string);\n\t\tbreak;\n\tcase FSCONFIG_SET_BINARY:\n\t\tparam.type = fs_value_is_blob;\n\t\tparam.size = aux;\n\t\tparam.blob = memdup_user_nul(_value, aux);\n\t\tif (IS_ERR(param.blob)) {\n\t\t\tret = PTR_ERR(param.blob);\n\t\t\tgoto out_key;\n\t\t}\n\t\tbreak;\n\tcase FSCONFIG_SET_PATH_EMPTY:\n\t\tlookup_flags = LOOKUP_EMPTY;\n\t\tfallthrough;\n\tcase FSCONFIG_SET_PATH:\n\t\tparam.type = fs_value_is_filename;\n\t\tparam.name = getname_flags(_value, lookup_flags, NULL);\n\t\tif (IS_ERR(param.name)) {\n\t\t\tret = PTR_ERR(param.name);\n\t\t\tgoto out_key;\n\t\t}\n\t\tparam.dirfd = aux;\n\t\tparam.size = strlen(param.name->name);\n\t\tbreak;\n\tcase FSCONFIG_SET_FD:\n\t\tparam.type = fs_value_is_file;\n\t\tret = -EBADF;\n\t\tparam.file = fget(aux);\n\t\tif (!param.file)\n\t\t\tgoto out_key;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tret = mutex_lock_interruptible(&fc->uapi_mutex);\n\tif (ret == 0) {\n\t\tret = vfs_fsconfig_locked(fc, cmd, &param);\n\t\tmutex_unlock(&fc->uapi_mutex);\n\t}\n\n\t \n\tswitch (cmd) {\n\tcase FSCONFIG_SET_STRING:\n\tcase FSCONFIG_SET_BINARY:\n\t\tkfree(param.string);\n\t\tbreak;\n\tcase FSCONFIG_SET_PATH:\n\tcase FSCONFIG_SET_PATH_EMPTY:\n\t\tif (param.name)\n\t\t\tputname(param.name);\n\t\tbreak;\n\tcase FSCONFIG_SET_FD:\n\t\tif (param.file)\n\t\t\tfput(param.file);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\nout_key:\n\tkfree(param.key);\nout_f:\n\tfdput(f);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}