{
  "module_name": "fs_context.c",
  "hash_id": "f670b3c72dfaa9a8a11a216ead9b73d1de38c17590775c19ff5aff4608bd3576",
  "original_prompt": "Ingested from linux-6.6.14/fs/fs_context.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#include <linux/module.h>\n#include <linux/fs_context.h>\n#include <linux/fs_parser.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/nsproxy.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/mnt_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/user_namespace.h>\n#include <net/net_namespace.h>\n#include <asm/sections.h>\n#include \"mount.h\"\n#include \"internal.h\"\n\nenum legacy_fs_param {\n\tLEGACY_FS_UNSET_PARAMS,\n\tLEGACY_FS_MONOLITHIC_PARAMS,\n\tLEGACY_FS_INDIVIDUAL_PARAMS,\n};\n\nstruct legacy_fs_context {\n\tchar\t\t\t*legacy_data;\t \n\tsize_t\t\t\tdata_size;\n\tenum legacy_fs_param\tparam_type;\n};\n\nstatic int legacy_init_fs_context(struct fs_context *fc);\n\nstatic const struct constant_table common_set_sb_flag[] = {\n\t{ \"dirsync\",\tSB_DIRSYNC },\n\t{ \"lazytime\",\tSB_LAZYTIME },\n\t{ \"mand\",\tSB_MANDLOCK },\n\t{ \"ro\",\t\tSB_RDONLY },\n\t{ \"sync\",\tSB_SYNCHRONOUS },\n\t{ },\n};\n\nstatic const struct constant_table common_clear_sb_flag[] = {\n\t{ \"async\",\tSB_SYNCHRONOUS },\n\t{ \"nolazytime\",\tSB_LAZYTIME },\n\t{ \"nomand\",\tSB_MANDLOCK },\n\t{ \"rw\",\t\tSB_RDONLY },\n\t{ },\n};\n\n \nstatic int vfs_parse_sb_flag(struct fs_context *fc, const char *key)\n{\n\tunsigned int token;\n\n\ttoken = lookup_constant(common_set_sb_flag, key, 0);\n\tif (token) {\n\t\tfc->sb_flags |= token;\n\t\tfc->sb_flags_mask |= token;\n\t\treturn 0;\n\t}\n\n\ttoken = lookup_constant(common_clear_sb_flag, key, 0);\n\tif (token) {\n\t\tfc->sb_flags &= ~token;\n\t\tfc->sb_flags_mask |= token;\n\t\treturn 0;\n\t}\n\n\treturn -ENOPARAM;\n}\n\n \nint vfs_parse_fs_param_source(struct fs_context *fc, struct fs_parameter *param)\n{\n\tif (strcmp(param->key, \"source\") != 0)\n\t\treturn -ENOPARAM;\n\n\tif (param->type != fs_value_is_string)\n\t\treturn invalf(fc, \"Non-string source\");\n\n\tif (fc->source)\n\t\treturn invalf(fc, \"Multiple sources\");\n\n\tfc->source = param->string;\n\tparam->string = NULL;\n\treturn 0;\n}\nEXPORT_SYMBOL(vfs_parse_fs_param_source);\n\n \nint vfs_parse_fs_param(struct fs_context *fc, struct fs_parameter *param)\n{\n\tint ret;\n\n\tif (!param->key)\n\t\treturn invalf(fc, \"Unnamed parameter\\n\");\n\n\tret = vfs_parse_sb_flag(fc, param->key);\n\tif (ret != -ENOPARAM)\n\t\treturn ret;\n\n\tret = security_fs_context_parse_param(fc, param);\n\tif (ret != -ENOPARAM)\n\t\t \n\t\treturn ret;\n\n\tif (fc->ops->parse_param) {\n\t\tret = fc->ops->parse_param(fc, param);\n\t\tif (ret != -ENOPARAM)\n\t\t\treturn ret;\n\t}\n\n\t \n\tret = vfs_parse_fs_param_source(fc, param);\n\tif (ret != -ENOPARAM)\n\t\treturn ret;\n\n\treturn invalf(fc, \"%s: Unknown parameter '%s'\",\n\t\t      fc->fs_type->name, param->key);\n}\nEXPORT_SYMBOL(vfs_parse_fs_param);\n\n \nint vfs_parse_fs_string(struct fs_context *fc, const char *key,\n\t\t\tconst char *value, size_t v_size)\n{\n\tint ret;\n\n\tstruct fs_parameter param = {\n\t\t.key\t= key,\n\t\t.type\t= fs_value_is_flag,\n\t\t.size\t= v_size,\n\t};\n\n\tif (value) {\n\t\tparam.string = kmemdup_nul(value, v_size, GFP_KERNEL);\n\t\tif (!param.string)\n\t\t\treturn -ENOMEM;\n\t\tparam.type = fs_value_is_string;\n\t}\n\n\tret = vfs_parse_fs_param(fc, &param);\n\tkfree(param.string);\n\treturn ret;\n}\nEXPORT_SYMBOL(vfs_parse_fs_string);\n\n \nint vfs_parse_monolithic_sep(struct fs_context *fc, void *data,\n\t\t\t     char *(*sep)(char **))\n{\n\tchar *options = data, *key;\n\tint ret = 0;\n\n\tif (!options)\n\t\treturn 0;\n\n\tret = security_sb_eat_lsm_opts(options, &fc->security);\n\tif (ret)\n\t\treturn ret;\n\n\twhile ((key = sep(&options)) != NULL) {\n\t\tif (*key) {\n\t\t\tsize_t v_len = 0;\n\t\t\tchar *value = strchr(key, '=');\n\n\t\t\tif (value) {\n\t\t\t\tif (value == key)\n\t\t\t\t\tcontinue;\n\t\t\t\t*value++ = 0;\n\t\t\t\tv_len = strlen(value);\n\t\t\t}\n\t\t\tret = vfs_parse_fs_string(fc, key, value, v_len);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL(vfs_parse_monolithic_sep);\n\nstatic char *vfs_parse_comma_sep(char **s)\n{\n\treturn strsep(s, \",\");\n}\n\n \nint generic_parse_monolithic(struct fs_context *fc, void *data)\n{\n\treturn vfs_parse_monolithic_sep(fc, data, vfs_parse_comma_sep);\n}\nEXPORT_SYMBOL(generic_parse_monolithic);\n\n \nstatic struct fs_context *alloc_fs_context(struct file_system_type *fs_type,\n\t\t\t\t      struct dentry *reference,\n\t\t\t\t      unsigned int sb_flags,\n\t\t\t\t      unsigned int sb_flags_mask,\n\t\t\t\t      enum fs_context_purpose purpose)\n{\n\tint (*init_fs_context)(struct fs_context *);\n\tstruct fs_context *fc;\n\tint ret = -ENOMEM;\n\n\tfc = kzalloc(sizeof(struct fs_context), GFP_KERNEL_ACCOUNT);\n\tif (!fc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfc->purpose\t= purpose;\n\tfc->sb_flags\t= sb_flags;\n\tfc->sb_flags_mask = sb_flags_mask;\n\tfc->fs_type\t= get_filesystem(fs_type);\n\tfc->cred\t= get_current_cred();\n\tfc->net_ns\t= get_net(current->nsproxy->net_ns);\n\tfc->log.prefix\t= fs_type->name;\n\n\tmutex_init(&fc->uapi_mutex);\n\n\tswitch (purpose) {\n\tcase FS_CONTEXT_FOR_MOUNT:\n\t\tfc->user_ns = get_user_ns(fc->cred->user_ns);\n\t\tbreak;\n\tcase FS_CONTEXT_FOR_SUBMOUNT:\n\t\tfc->user_ns = get_user_ns(reference->d_sb->s_user_ns);\n\t\tbreak;\n\tcase FS_CONTEXT_FOR_RECONFIGURE:\n\t\tatomic_inc(&reference->d_sb->s_active);\n\t\tfc->user_ns = get_user_ns(reference->d_sb->s_user_ns);\n\t\tfc->root = dget(reference);\n\t\tbreak;\n\t}\n\n\t \n\tinit_fs_context = fc->fs_type->init_fs_context;\n\tif (!init_fs_context)\n\t\tinit_fs_context = legacy_init_fs_context;\n\n\tret = init_fs_context(fc);\n\tif (ret < 0)\n\t\tgoto err_fc;\n\tfc->need_free = true;\n\treturn fc;\n\nerr_fc:\n\tput_fs_context(fc);\n\treturn ERR_PTR(ret);\n}\n\nstruct fs_context *fs_context_for_mount(struct file_system_type *fs_type,\n\t\t\t\t\tunsigned int sb_flags)\n{\n\treturn alloc_fs_context(fs_type, NULL, sb_flags, 0,\n\t\t\t\t\tFS_CONTEXT_FOR_MOUNT);\n}\nEXPORT_SYMBOL(fs_context_for_mount);\n\nstruct fs_context *fs_context_for_reconfigure(struct dentry *dentry,\n\t\t\t\t\tunsigned int sb_flags,\n\t\t\t\t\tunsigned int sb_flags_mask)\n{\n\treturn alloc_fs_context(dentry->d_sb->s_type, dentry, sb_flags,\n\t\t\t\tsb_flags_mask, FS_CONTEXT_FOR_RECONFIGURE);\n}\nEXPORT_SYMBOL(fs_context_for_reconfigure);\n\n \nstruct fs_context *fs_context_for_submount(struct file_system_type *type,\n\t\t\t\t\t   struct dentry *reference)\n{\n\tstruct fs_context *fc;\n\tint ret;\n\n\tfc = alloc_fs_context(type, reference, 0, 0, FS_CONTEXT_FOR_SUBMOUNT);\n\tif (IS_ERR(fc))\n\t\treturn fc;\n\n\tret = security_fs_context_submount(fc, reference->d_sb);\n\tif (ret) {\n\t\tput_fs_context(fc);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn fc;\n}\nEXPORT_SYMBOL(fs_context_for_submount);\n\nvoid fc_drop_locked(struct fs_context *fc)\n{\n\tstruct super_block *sb = fc->root->d_sb;\n\tdput(fc->root);\n\tfc->root = NULL;\n\tdeactivate_locked_super(sb);\n}\n\nstatic void legacy_fs_context_free(struct fs_context *fc);\n\n \nstruct fs_context *vfs_dup_fs_context(struct fs_context *src_fc)\n{\n\tstruct fs_context *fc;\n\tint ret;\n\n\tif (!src_fc->ops->dup)\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tfc = kmemdup(src_fc, sizeof(struct fs_context), GFP_KERNEL);\n\tif (!fc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&fc->uapi_mutex);\n\n\tfc->fs_private\t= NULL;\n\tfc->s_fs_info\t= NULL;\n\tfc->source\t= NULL;\n\tfc->security\t= NULL;\n\tget_filesystem(fc->fs_type);\n\tget_net(fc->net_ns);\n\tget_user_ns(fc->user_ns);\n\tget_cred(fc->cred);\n\tif (fc->log.log)\n\t\trefcount_inc(&fc->log.log->usage);\n\n\t \n\tret = fc->ops->dup(fc, src_fc);\n\tif (ret < 0)\n\t\tgoto err_fc;\n\n\tret = security_fs_context_dup(fc, src_fc);\n\tif (ret < 0)\n\t\tgoto err_fc;\n\treturn fc;\n\nerr_fc:\n\tput_fs_context(fc);\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL(vfs_dup_fs_context);\n\n \nvoid logfc(struct fc_log *log, const char *prefix, char level, const char *fmt, ...)\n{\n\tva_list va;\n\tstruct va_format vaf = {.fmt = fmt, .va = &va};\n\n\tva_start(va, fmt);\n\tif (!log) {\n\t\tswitch (level) {\n\t\tcase 'w':\n\t\t\tprintk(KERN_WARNING \"%s%s%pV\\n\", prefix ? prefix : \"\",\n\t\t\t\t\t\tprefix ? \": \" : \"\", &vaf);\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tprintk(KERN_ERR \"%s%s%pV\\n\", prefix ? prefix : \"\",\n\t\t\t\t\t\tprefix ? \": \" : \"\", &vaf);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_NOTICE \"%s%s%pV\\n\", prefix ? prefix : \"\",\n\t\t\t\t\t\tprefix ? \": \" : \"\", &vaf);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tunsigned int logsize = ARRAY_SIZE(log->buffer);\n\t\tu8 index;\n\t\tchar *q = kasprintf(GFP_KERNEL, \"%c %s%s%pV\\n\", level,\n\t\t\t\t\t\tprefix ? prefix : \"\",\n\t\t\t\t\t\tprefix ? \": \" : \"\", &vaf);\n\n\t\tindex = log->head & (logsize - 1);\n\t\tBUILD_BUG_ON(sizeof(log->head) != sizeof(u8) ||\n\t\t\t     sizeof(log->tail) != sizeof(u8));\n\t\tif ((u8)(log->head - log->tail) == logsize) {\n\t\t\t \n\t\t\tif (log->need_free & (1 << index))\n\t\t\t\tkfree(log->buffer[index]);\n\t\t\tlog->tail++;\n\t\t}\n\n\t\tlog->buffer[index] = q ? q : \"OOM: Can't store error string\";\n\t\tif (q)\n\t\t\tlog->need_free |= 1 << index;\n\t\telse\n\t\t\tlog->need_free &= ~(1 << index);\n\t\tlog->head++;\n\t}\n\tva_end(va);\n}\nEXPORT_SYMBOL(logfc);\n\n \nstatic void put_fc_log(struct fs_context *fc)\n{\n\tstruct fc_log *log = fc->log.log;\n\tint i;\n\n\tif (log) {\n\t\tif (refcount_dec_and_test(&log->usage)) {\n\t\t\tfc->log.log = NULL;\n\t\t\tfor (i = 0; i <= 7; i++)\n\t\t\t\tif (log->need_free & (1 << i))\n\t\t\t\t\tkfree(log->buffer[i]);\n\t\t\tkfree(log);\n\t\t}\n\t}\n}\n\n \nvoid put_fs_context(struct fs_context *fc)\n{\n\tstruct super_block *sb;\n\n\tif (fc->root) {\n\t\tsb = fc->root->d_sb;\n\t\tdput(fc->root);\n\t\tfc->root = NULL;\n\t\tdeactivate_super(sb);\n\t}\n\n\tif (fc->need_free && fc->ops && fc->ops->free)\n\t\tfc->ops->free(fc);\n\n\tsecurity_free_mnt_opts(&fc->security);\n\tput_net(fc->net_ns);\n\tput_user_ns(fc->user_ns);\n\tput_cred(fc->cred);\n\tput_fc_log(fc);\n\tput_filesystem(fc->fs_type);\n\tkfree(fc->source);\n\tkfree(fc);\n}\nEXPORT_SYMBOL(put_fs_context);\n\n \nstatic void legacy_fs_context_free(struct fs_context *fc)\n{\n\tstruct legacy_fs_context *ctx = fc->fs_private;\n\n\tif (ctx) {\n\t\tif (ctx->param_type == LEGACY_FS_INDIVIDUAL_PARAMS)\n\t\t\tkfree(ctx->legacy_data);\n\t\tkfree(ctx);\n\t}\n}\n\n \nstatic int legacy_fs_context_dup(struct fs_context *fc, struct fs_context *src_fc)\n{\n\tstruct legacy_fs_context *ctx;\n\tstruct legacy_fs_context *src_ctx = src_fc->fs_private;\n\n\tctx = kmemdup(src_ctx, sizeof(*src_ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tif (ctx->param_type == LEGACY_FS_INDIVIDUAL_PARAMS) {\n\t\tctx->legacy_data = kmemdup(src_ctx->legacy_data,\n\t\t\t\t\t   src_ctx->data_size, GFP_KERNEL);\n\t\tif (!ctx->legacy_data) {\n\t\t\tkfree(ctx);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tfc->fs_private = ctx;\n\treturn 0;\n}\n\n \nstatic int legacy_parse_param(struct fs_context *fc, struct fs_parameter *param)\n{\n\tstruct legacy_fs_context *ctx = fc->fs_private;\n\tunsigned int size = ctx->data_size;\n\tsize_t len = 0;\n\tint ret;\n\n\tret = vfs_parse_fs_param_source(fc, param);\n\tif (ret != -ENOPARAM)\n\t\treturn ret;\n\n\tif (ctx->param_type == LEGACY_FS_MONOLITHIC_PARAMS)\n\t\treturn invalf(fc, \"VFS: Legacy: Can't mix monolithic and individual options\");\n\n\tswitch (param->type) {\n\tcase fs_value_is_string:\n\t\tlen = 1 + param->size;\n\t\tfallthrough;\n\tcase fs_value_is_flag:\n\t\tlen += strlen(param->key);\n\t\tbreak;\n\tdefault:\n\t\treturn invalf(fc, \"VFS: Legacy: Parameter type for '%s' not supported\",\n\t\t\t      param->key);\n\t}\n\n\tif (size + len + 2 > PAGE_SIZE)\n\t\treturn invalf(fc, \"VFS: Legacy: Cumulative options too large\");\n\tif (strchr(param->key, ',') ||\n\t    (param->type == fs_value_is_string &&\n\t     memchr(param->string, ',', param->size)))\n\t\treturn invalf(fc, \"VFS: Legacy: Option '%s' contained comma\",\n\t\t\t      param->key);\n\tif (!ctx->legacy_data) {\n\t\tctx->legacy_data = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\t\tif (!ctx->legacy_data)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (size)\n\t\tctx->legacy_data[size++] = ',';\n\tlen = strlen(param->key);\n\tmemcpy(ctx->legacy_data + size, param->key, len);\n\tsize += len;\n\tif (param->type == fs_value_is_string) {\n\t\tctx->legacy_data[size++] = '=';\n\t\tmemcpy(ctx->legacy_data + size, param->string, param->size);\n\t\tsize += param->size;\n\t}\n\tctx->legacy_data[size] = '\\0';\n\tctx->data_size = size;\n\tctx->param_type = LEGACY_FS_INDIVIDUAL_PARAMS;\n\treturn 0;\n}\n\n \nstatic int legacy_parse_monolithic(struct fs_context *fc, void *data)\n{\n\tstruct legacy_fs_context *ctx = fc->fs_private;\n\n\tif (ctx->param_type != LEGACY_FS_UNSET_PARAMS) {\n\t\tpr_warn(\"VFS: Can't mix monolithic and individual options\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tctx->legacy_data = data;\n\tctx->param_type = LEGACY_FS_MONOLITHIC_PARAMS;\n\tif (!ctx->legacy_data)\n\t\treturn 0;\n\n\tif (fc->fs_type->fs_flags & FS_BINARY_MOUNTDATA)\n\t\treturn 0;\n\treturn security_sb_eat_lsm_opts(ctx->legacy_data, &fc->security);\n}\n\n \nstatic int legacy_get_tree(struct fs_context *fc)\n{\n\tstruct legacy_fs_context *ctx = fc->fs_private;\n\tstruct super_block *sb;\n\tstruct dentry *root;\n\n\troot = fc->fs_type->mount(fc->fs_type, fc->sb_flags,\n\t\t\t\t      fc->source, ctx->legacy_data);\n\tif (IS_ERR(root))\n\t\treturn PTR_ERR(root);\n\n\tsb = root->d_sb;\n\tBUG_ON(!sb);\n\n\tfc->root = root;\n\treturn 0;\n}\n\n \nstatic int legacy_reconfigure(struct fs_context *fc)\n{\n\tstruct legacy_fs_context *ctx = fc->fs_private;\n\tstruct super_block *sb = fc->root->d_sb;\n\n\tif (!sb->s_op->remount_fs)\n\t\treturn 0;\n\n\treturn sb->s_op->remount_fs(sb, &fc->sb_flags,\n\t\t\t\t    ctx ? ctx->legacy_data : NULL);\n}\n\nconst struct fs_context_operations legacy_fs_context_ops = {\n\t.free\t\t\t= legacy_fs_context_free,\n\t.dup\t\t\t= legacy_fs_context_dup,\n\t.parse_param\t\t= legacy_parse_param,\n\t.parse_monolithic\t= legacy_parse_monolithic,\n\t.get_tree\t\t= legacy_get_tree,\n\t.reconfigure\t\t= legacy_reconfigure,\n};\n\n \nstatic int legacy_init_fs_context(struct fs_context *fc)\n{\n\tfc->fs_private = kzalloc(sizeof(struct legacy_fs_context), GFP_KERNEL_ACCOUNT);\n\tif (!fc->fs_private)\n\t\treturn -ENOMEM;\n\tfc->ops = &legacy_fs_context_ops;\n\treturn 0;\n}\n\nint parse_monolithic_mount_data(struct fs_context *fc, void *data)\n{\n\tint (*monolithic_mount_data)(struct fs_context *, void *);\n\n\tmonolithic_mount_data = fc->ops->parse_monolithic;\n\tif (!monolithic_mount_data)\n\t\tmonolithic_mount_data = generic_parse_monolithic;\n\n\treturn monolithic_mount_data(fc, data);\n}\n\n \nvoid vfs_clean_context(struct fs_context *fc)\n{\n\tif (fc->need_free && fc->ops && fc->ops->free)\n\t\tfc->ops->free(fc);\n\tfc->need_free = false;\n\tfc->fs_private = NULL;\n\tfc->s_fs_info = NULL;\n\tfc->sb_flags = 0;\n\tsecurity_free_mnt_opts(&fc->security);\n\tkfree(fc->source);\n\tfc->source = NULL;\n\tfc->exclusive = false;\n\n\tfc->purpose = FS_CONTEXT_FOR_RECONFIGURE;\n\tfc->phase = FS_CONTEXT_AWAITING_RECONF;\n}\n\nint finish_clean_context(struct fs_context *fc)\n{\n\tint error;\n\n\tif (fc->phase != FS_CONTEXT_AWAITING_RECONF)\n\t\treturn 0;\n\n\tif (fc->fs_type->init_fs_context)\n\t\terror = fc->fs_type->init_fs_context(fc);\n\telse\n\t\terror = legacy_init_fs_context(fc);\n\tif (unlikely(error)) {\n\t\tfc->phase = FS_CONTEXT_FAILED;\n\t\treturn error;\n\t}\n\tfc->need_free = true;\n\tfc->phase = FS_CONTEXT_RECONF_PARAMS;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}