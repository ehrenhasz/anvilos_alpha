{
  "module_name": "ialloc.c",
  "hash_id": "f1a114068b2d6c85cb554d066146da41fe2aebbdcf552d8e2657699dae142cb9",
  "original_prompt": "Ingested from linux-6.6.14/fs/sysv/ialloc.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include \"sysv.h\"\n\n \n\n \n\n \nstatic inline sysv_ino_t *\nsv_sb_fic_inode(struct super_block * sb, unsigned int i)\n{\n\tstruct sysv_sb_info *sbi = SYSV_SB(sb);\n\n\tif (sbi->s_bh1 == sbi->s_bh2)\n\t\treturn &sbi->s_sb_fic_inodes[i];\n\telse {\n\t\t \n\t\tunsigned int offset = offsetof(struct xenix_super_block, s_inode[i]);\n\t\tif (offset < 512)\n\t\t\treturn (sysv_ino_t*)(sbi->s_sbd1 + offset);\n\t\telse\n\t\t\treturn (sysv_ino_t*)(sbi->s_sbd2 + offset);\n\t}\n}\n\nstruct sysv_inode *\nsysv_raw_inode(struct super_block *sb, unsigned ino, struct buffer_head **bh)\n{\n\tstruct sysv_sb_info *sbi = SYSV_SB(sb);\n\tstruct sysv_inode *res;\n\tint block = sbi->s_firstinodezone + sbi->s_block_base;\n\n\tblock += (ino-1) >> sbi->s_inodes_per_block_bits;\n\t*bh = sb_bread(sb, block);\n\tif (!*bh)\n\t\treturn NULL;\n\tres = (struct sysv_inode *)(*bh)->b_data;\n\treturn res + ((ino-1) & sbi->s_inodes_per_block_1);\n}\n\nstatic int refill_free_cache(struct super_block *sb)\n{\n\tstruct sysv_sb_info *sbi = SYSV_SB(sb);\n\tstruct buffer_head * bh;\n\tstruct sysv_inode * raw_inode;\n\tint i = 0, ino;\n\n\tino = SYSV_ROOT_INO+1;\n\traw_inode = sysv_raw_inode(sb, ino, &bh);\n\tif (!raw_inode)\n\t\tgoto out;\n\twhile (ino <= sbi->s_ninodes) {\n\t\tif (raw_inode->i_mode == 0 && raw_inode->i_nlink == 0) {\n\t\t\t*sv_sb_fic_inode(sb,i++) = cpu_to_fs16(SYSV_SB(sb), ino);\n\t\t\tif (i == sbi->s_fic_size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif ((ino++ & sbi->s_inodes_per_block_1) == 0) {\n\t\t\tbrelse(bh);\n\t\t\traw_inode = sysv_raw_inode(sb, ino, &bh);\n\t\t\tif (!raw_inode)\n\t\t\t\tgoto out;\n\t\t} else\n\t\t\traw_inode++;\n\t}\n\tbrelse(bh);\nout:\n\treturn i;\n}\n\nvoid sysv_free_inode(struct inode * inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct sysv_sb_info *sbi = SYSV_SB(sb);\n\tunsigned int ino;\n\tstruct buffer_head * bh;\n\tstruct sysv_inode * raw_inode;\n\tunsigned count;\n\n\tsb = inode->i_sb;\n\tino = inode->i_ino;\n\tif (ino <= SYSV_ROOT_INO || ino > sbi->s_ninodes) {\n\t\tprintk(\"sysv_free_inode: inode 0,1,2 or nonexistent inode\\n\");\n\t\treturn;\n\t}\n\traw_inode = sysv_raw_inode(sb, ino, &bh);\n\tif (!raw_inode) {\n\t\tprintk(\"sysv_free_inode: unable to read inode block on device \"\n\t\t       \"%s\\n\", inode->i_sb->s_id);\n\t\treturn;\n\t}\n\tmutex_lock(&sbi->s_lock);\n\tcount = fs16_to_cpu(sbi, *sbi->s_sb_fic_count);\n\tif (count < sbi->s_fic_size) {\n\t\t*sv_sb_fic_inode(sb,count++) = cpu_to_fs16(sbi, ino);\n\t\t*sbi->s_sb_fic_count = cpu_to_fs16(sbi, count);\n\t}\n\tfs16_add(sbi, sbi->s_sb_total_free_inodes, 1);\n\tdirty_sb(sb);\n\tmemset(raw_inode, 0, sizeof(struct sysv_inode));\n\tmark_buffer_dirty(bh);\n\tmutex_unlock(&sbi->s_lock);\n\tbrelse(bh);\n}\n\nstruct inode * sysv_new_inode(const struct inode * dir, umode_t mode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct sysv_sb_info *sbi = SYSV_SB(sb);\n\tstruct inode *inode;\n\tsysv_ino_t ino;\n\tunsigned count;\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = WB_SYNC_NONE\n\t};\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_lock(&sbi->s_lock);\n\tcount = fs16_to_cpu(sbi, *sbi->s_sb_fic_count);\n\tif (count == 0 || (*sv_sb_fic_inode(sb,count-1) == 0)) {\n\t\tcount = refill_free_cache(sb);\n\t\tif (count == 0) {\n\t\t\tiput(inode);\n\t\t\tmutex_unlock(&sbi->s_lock);\n\t\t\treturn ERR_PTR(-ENOSPC);\n\t\t}\n\t}\n\t \n\tino = *sv_sb_fic_inode(sb,--count);\n\t*sbi->s_sb_fic_count = cpu_to_fs16(sbi, count);\n\tfs16_add(sbi, sbi->s_sb_total_free_inodes, -1);\n\tdirty_sb(sb);\n\tinode_init_owner(&nop_mnt_idmap, inode, dir, mode);\n\tinode->i_ino = fs16_to_cpu(sbi, ino);\n\tinode->i_mtime = inode->i_atime = inode_set_ctime_current(inode);\n\tinode->i_blocks = 0;\n\tmemset(SYSV_I(inode)->i_data, 0, sizeof(SYSV_I(inode)->i_data));\n\tSYSV_I(inode)->i_dir_start_lookup = 0;\n\tinsert_inode_hash(inode);\n\tmark_inode_dirty(inode);\n\n\tsysv_write_inode(inode, &wbc);\t \n\tmark_inode_dirty(inode);\t \n\t \n\tmutex_unlock(&sbi->s_lock);\n\treturn inode;\n}\n\nunsigned long sysv_count_free_inodes(struct super_block * sb)\n{\n\tstruct sysv_sb_info *sbi = SYSV_SB(sb);\n\tstruct buffer_head * bh;\n\tstruct sysv_inode * raw_inode;\n\tint ino, count, sb_count;\n\n\tmutex_lock(&sbi->s_lock);\n\n\tsb_count = fs16_to_cpu(sbi, *sbi->s_sb_total_free_inodes);\n\n\tif (0)\n\t\tgoto trust_sb;\n\n\t \n\tcount = 0;\n\tino = SYSV_ROOT_INO+1;\n\traw_inode = sysv_raw_inode(sb, ino, &bh);\n\tif (!raw_inode)\n\t\tgoto Eio;\n\twhile (ino <= sbi->s_ninodes) {\n\t\tif (raw_inode->i_mode == 0 && raw_inode->i_nlink == 0)\n\t\t\tcount++;\n\t\tif ((ino++ & sbi->s_inodes_per_block_1) == 0) {\n\t\t\tbrelse(bh);\n\t\t\traw_inode = sysv_raw_inode(sb, ino, &bh);\n\t\t\tif (!raw_inode)\n\t\t\t\tgoto Eio;\n\t\t} else\n\t\t\traw_inode++;\n\t}\n\tbrelse(bh);\n\tif (count != sb_count)\n\t\tgoto Einval;\nout:\n\tmutex_unlock(&sbi->s_lock);\n\treturn count;\n\nEinval:\n\tprintk(\"sysv_count_free_inodes: \"\n\t\t\"free inode count was %d, correcting to %d\\n\",\n\t\tsb_count, count);\n\tif (!sb_rdonly(sb)) {\n\t\t*sbi->s_sb_total_free_inodes = cpu_to_fs16(SYSV_SB(sb), count);\n\t\tdirty_sb(sb);\n\t}\n\tgoto out;\n\nEio:\n\tprintk(\"sysv_count_free_inodes: unable to read inode table\\n\");\ntrust_sb:\n\tcount = sb_count;\n\tgoto out;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}