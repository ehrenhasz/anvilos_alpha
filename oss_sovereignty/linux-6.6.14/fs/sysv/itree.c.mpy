{
  "module_name": "itree.c",
  "hash_id": "c36cd8fffb6bfdcbcdaba3e6d2e2e98301c33f2fb7f4bc988cf85462ff2f88bf",
  "original_prompt": "Ingested from linux-6.6.14/fs/sysv/itree.c",
  "human_readable_source": "\n \n\n#include <linux/buffer_head.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include \"sysv.h\"\n\nenum {DIRECT = 10, DEPTH = 4};\t \n\nstatic inline void dirty_indirect(struct buffer_head *bh, struct inode *inode)\n{\n\tmark_buffer_dirty_inode(bh, inode);\n\tif (IS_SYNC(inode))\n\t\tsync_dirty_buffer(bh);\n}\n\nstatic int block_to_path(struct inode *inode, long block, int offsets[DEPTH])\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct sysv_sb_info *sbi = SYSV_SB(sb);\n\tint ptrs_bits = sbi->s_ind_per_block_bits;\n\tunsigned long\tindirect_blocks = sbi->s_ind_per_block,\n\t\t\tdouble_blocks = sbi->s_ind_per_block_2;\n\tint n = 0;\n\n\tif (block < 0) {\n\t\tprintk(\"sysv_block_map: block < 0\\n\");\n\t} else if (block < DIRECT) {\n\t\toffsets[n++] = block;\n\t} else if ( (block -= DIRECT) < indirect_blocks) {\n\t\toffsets[n++] = DIRECT;\n\t\toffsets[n++] = block;\n\t} else if ((block -= indirect_blocks) < double_blocks) {\n\t\toffsets[n++] = DIRECT+1;\n\t\toffsets[n++] = block >> ptrs_bits;\n\t\toffsets[n++] = block & (indirect_blocks - 1);\n\t} else if (((block -= double_blocks) >> (ptrs_bits * 2)) < indirect_blocks) {\n\t\toffsets[n++] = DIRECT+2;\n\t\toffsets[n++] = block >> (ptrs_bits * 2);\n\t\toffsets[n++] = (block >> ptrs_bits) & (indirect_blocks - 1);\n\t\toffsets[n++] = block & (indirect_blocks - 1);\n\t} else {\n\t\t ;\n\t}\n\treturn n;\n}\n\nstatic inline int block_to_cpu(struct sysv_sb_info *sbi, sysv_zone_t nr)\n{\n\treturn sbi->s_block_base + fs32_to_cpu(sbi, nr);\n}\n\ntypedef struct {\n\tsysv_zone_t     *p;\n\tsysv_zone_t     key;\n\tstruct buffer_head *bh;\n} Indirect;\n\nstatic DEFINE_RWLOCK(pointers_lock);\n\nstatic inline void add_chain(Indirect *p, struct buffer_head *bh, sysv_zone_t *v)\n{\n\tp->key = *(p->p = v);\n\tp->bh = bh;\n}\n\nstatic inline int verify_chain(Indirect *from, Indirect *to)\n{\n\twhile (from <= to && from->key == *from->p)\n\t\tfrom++;\n\treturn (from > to);\n}\n\nstatic inline sysv_zone_t *block_end(struct buffer_head *bh)\n{\n\treturn (sysv_zone_t*)((char*)bh->b_data + bh->b_size);\n}\n\n \nstatic Indirect *get_branch(struct inode *inode,\n\t\t\t    int depth,\n\t\t\t    int offsets[],\n\t\t\t    Indirect chain[],\n\t\t\t    int *err)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tIndirect *p = chain;\n\tstruct buffer_head *bh;\n\n\t*err = 0;\n\tadd_chain(chain, NULL, SYSV_I(inode)->i_data + *offsets);\n\tif (!p->key)\n\t\tgoto no_block;\n\twhile (--depth) {\n\t\tint block = block_to_cpu(SYSV_SB(sb), p->key);\n\t\tbh = sb_bread(sb, block);\n\t\tif (!bh)\n\t\t\tgoto failure;\n\t\tif (!verify_chain(chain, p))\n\t\t\tgoto changed;\n\t\tadd_chain(++p, bh, (sysv_zone_t*)bh->b_data + *++offsets);\n\t\tif (!p->key)\n\t\t\tgoto no_block;\n\t}\n\treturn NULL;\n\nchanged:\n\tbrelse(bh);\n\t*err = -EAGAIN;\n\tgoto no_block;\nfailure:\n\t*err = -EIO;\nno_block:\n\treturn p;\n}\n\nstatic int alloc_branch(struct inode *inode,\n\t\t\tint num,\n\t\t\tint *offsets,\n\t\t\tIndirect *branch)\n{\n\tint blocksize = inode->i_sb->s_blocksize;\n\tint n = 0;\n\tint i;\n\n\tbranch[0].key = sysv_new_block(inode->i_sb);\n\tif (branch[0].key) for (n = 1; n < num; n++) {\n\t\tstruct buffer_head *bh;\n\t\tint parent;\n\t\t \n\t\tbranch[n].key = sysv_new_block(inode->i_sb);\n\t\tif (!branch[n].key)\n\t\t\tbreak;\n\t\t \n\t\tparent = block_to_cpu(SYSV_SB(inode->i_sb), branch[n-1].key);\n\t\tbh = sb_getblk(inode->i_sb, parent);\n\t\tif (!bh) {\n\t\t\tsysv_free_block(inode->i_sb, branch[n].key);\n\t\t\tbreak;\n\t\t}\n\t\tlock_buffer(bh);\n\t\tmemset(bh->b_data, 0, blocksize);\n\t\tbranch[n].bh = bh;\n\t\tbranch[n].p = (sysv_zone_t*) bh->b_data + offsets[n];\n\t\t*branch[n].p = branch[n].key;\n\t\tset_buffer_uptodate(bh);\n\t\tunlock_buffer(bh);\n\t\tdirty_indirect(bh, inode);\n\t}\n\tif (n == num)\n\t\treturn 0;\n\n\t \n\tfor (i = 1; i < n; i++)\n\t\tbforget(branch[i].bh);\n\tfor (i = 0; i < n; i++)\n\t\tsysv_free_block(inode->i_sb, branch[i].key);\n\treturn -ENOSPC;\n}\n\nstatic inline int splice_branch(struct inode *inode,\n\t\t\t\tIndirect chain[],\n\t\t\t\tIndirect *where,\n\t\t\t\tint num)\n{\n\tint i;\n\n\t \n\twrite_lock(&pointers_lock);\n\tif (!verify_chain(chain, where-1) || *where->p)\n\t\tgoto changed;\n\t*where->p = where->key;\n\twrite_unlock(&pointers_lock);\n\n\tinode_set_ctime_current(inode);\n\n\t \n\tif (where->bh)\n\t\tdirty_indirect(where->bh, inode);\n\n\tif (IS_SYNC(inode))\n\t\tsysv_sync_inode(inode);\n\telse\n\t\tmark_inode_dirty(inode);\n\treturn 0;\n\nchanged:\n\twrite_unlock(&pointers_lock);\n\tfor (i = 1; i < num; i++)\n\t\tbforget(where[i].bh);\n\tfor (i = 0; i < num; i++)\n\t\tsysv_free_block(inode->i_sb, where[i].key);\n\treturn -EAGAIN;\n}\n\nstatic int get_block(struct inode *inode, sector_t iblock, struct buffer_head *bh_result, int create)\n{\n\tint err = -EIO;\n\tint offsets[DEPTH];\n\tIndirect chain[DEPTH];\n\tstruct super_block *sb = inode->i_sb;\n\tIndirect *partial;\n\tint left;\n\tint depth = block_to_path(inode, iblock, offsets);\n\n\tif (depth == 0)\n\t\tgoto out;\n\nreread:\n\tread_lock(&pointers_lock);\n\tpartial = get_branch(inode, depth, offsets, chain, &err);\n\tread_unlock(&pointers_lock);\n\n\t \n\tif (!partial) {\ngot_it:\n\t\tmap_bh(bh_result, sb, block_to_cpu(SYSV_SB(sb),\n\t\t\t\t\tchain[depth-1].key));\n\t\t \n\t\tpartial = chain+depth-1;  \n\t\tgoto cleanup;\n\t}\n\n\t \n\tif (!create || err == -EIO) {\ncleanup:\n\t\twhile (partial > chain) {\n\t\t\tbrelse(partial->bh);\n\t\t\tpartial--;\n\t\t}\nout:\n\t\treturn err;\n\t}\n\n\t \n\tif (err == -EAGAIN)\n\t\tgoto changed;\n\n\tleft = (chain + depth) - partial;\n\terr = alloc_branch(inode, left, offsets+(partial-chain), partial);\n\tif (err)\n\t\tgoto cleanup;\n\n\tif (splice_branch(inode, chain, partial, left) < 0)\n\t\tgoto changed;\n\n\tset_buffer_new(bh_result);\n\tgoto got_it;\n\nchanged:\n\twhile (partial > chain) {\n\t\tbrelse(partial->bh);\n\t\tpartial--;\n\t}\n\tgoto reread;\n}\n\nstatic inline int all_zeroes(sysv_zone_t *p, sysv_zone_t *q)\n{\n\twhile (p < q)\n\t\tif (*p++)\n\t\t\treturn 0;\n\treturn 1;\n}\n\nstatic Indirect *find_shared(struct inode *inode,\n\t\t\t\tint depth,\n\t\t\t\tint offsets[],\n\t\t\t\tIndirect chain[],\n\t\t\t\tsysv_zone_t *top)\n{\n\tIndirect *partial, *p;\n\tint k, err;\n\n\t*top = 0;\n\tfor (k = depth; k > 1 && !offsets[k-1]; k--)\n\t\t;\n\n\twrite_lock(&pointers_lock);\n\tpartial = get_branch(inode, k, offsets, chain, &err);\n\tif (!partial)\n\t\tpartial = chain + k-1;\n\t \n\tif (!partial->key && *partial->p) {\n\t\twrite_unlock(&pointers_lock);\n\t\tgoto no_top;\n\t}\n\tfor (p=partial; p>chain && all_zeroes((sysv_zone_t*)p->bh->b_data,p->p); p--)\n\t\t;\n\t \n\tif (p == chain + k - 1 && p > chain) {\n\t\tp->p--;\n\t} else {\n\t\t*top = *p->p;\n\t\t*p->p = 0;\n\t}\n\twrite_unlock(&pointers_lock);\n\n\twhile (partial > p) {\n\t\tbrelse(partial->bh);\n\t\tpartial--;\n\t}\nno_top:\n\treturn partial;\n}\n\nstatic inline void free_data(struct inode *inode, sysv_zone_t *p, sysv_zone_t *q)\n{\n\tfor ( ; p < q ; p++) {\n\t\tsysv_zone_t nr = *p;\n\t\tif (nr) {\n\t\t\t*p = 0;\n\t\t\tsysv_free_block(inode->i_sb, nr);\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t}\n}\n\nstatic void free_branches(struct inode *inode, sysv_zone_t *p, sysv_zone_t *q, int depth)\n{\n\tstruct buffer_head * bh;\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (depth--) {\n\t\tfor ( ; p < q ; p++) {\n\t\t\tint block;\n\t\t\tsysv_zone_t nr = *p;\n\t\t\tif (!nr)\n\t\t\t\tcontinue;\n\t\t\t*p = 0;\n\t\t\tblock = block_to_cpu(SYSV_SB(sb), nr);\n\t\t\tbh = sb_bread(sb, block);\n\t\t\tif (!bh)\n\t\t\t\tcontinue;\n\t\t\tfree_branches(inode, (sysv_zone_t*)bh->b_data,\n\t\t\t\t\tblock_end(bh), depth);\n\t\t\tbforget(bh);\n\t\t\tsysv_free_block(sb, nr);\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t} else\n\t\tfree_data(inode, p, q);\n}\n\nvoid sysv_truncate (struct inode * inode)\n{\n\tsysv_zone_t *i_data = SYSV_I(inode)->i_data;\n\tint offsets[DEPTH];\n\tIndirect chain[DEPTH];\n\tIndirect *partial;\n\tsysv_zone_t nr = 0;\n\tint n;\n\tlong iblock;\n\tunsigned blocksize;\n\n\tif (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t    S_ISLNK(inode->i_mode)))\n\t\treturn;\n\n\tblocksize = inode->i_sb->s_blocksize;\n\tiblock = (inode->i_size + blocksize-1)\n\t\t\t\t\t>> inode->i_sb->s_blocksize_bits;\n\n\tblock_truncate_page(inode->i_mapping, inode->i_size, get_block);\n\n\tn = block_to_path(inode, iblock, offsets);\n\tif (n == 0)\n\t\treturn;\n\n\tif (n == 1) {\n\t\tfree_data(inode, i_data+offsets[0], i_data + DIRECT);\n\t\tgoto do_indirects;\n\t}\n\n\tpartial = find_shared(inode, n, offsets, chain, &nr);\n\t \n\tif (nr) {\n\t\tif (partial == chain)\n\t\t\tmark_inode_dirty(inode);\n\t\telse\n\t\t\tdirty_indirect(partial->bh, inode);\n\t\tfree_branches(inode, &nr, &nr+1, (chain+n-1) - partial);\n\t}\n\t \n\twhile (partial > chain) {\n\t\tfree_branches(inode, partial->p + 1, block_end(partial->bh),\n\t\t\t\t(chain+n-1) - partial);\n\t\tdirty_indirect(partial->bh, inode);\n\t\tbrelse (partial->bh);\n\t\tpartial--;\n\t}\ndo_indirects:\n\t \n\twhile (n < DEPTH) {\n\t\tnr = i_data[DIRECT + n - 1];\n\t\tif (nr) {\n\t\t\ti_data[DIRECT + n - 1] = 0;\n\t\t\tmark_inode_dirty(inode);\n\t\t\tfree_branches(inode, &nr, &nr+1, n);\n\t\t}\n\t\tn++;\n\t}\n\tinode->i_mtime = inode_set_ctime_current(inode);\n\tif (IS_SYNC(inode))\n\t\tsysv_sync_inode (inode);\n\telse\n\t\tmark_inode_dirty(inode);\n}\n\nstatic unsigned sysv_nblocks(struct super_block *s, loff_t size)\n{\n\tstruct sysv_sb_info *sbi = SYSV_SB(s);\n\tint ptrs_bits = sbi->s_ind_per_block_bits;\n\tunsigned blocks, res, direct = DIRECT, i = DEPTH;\n\tblocks = (size + s->s_blocksize - 1) >> s->s_blocksize_bits;\n\tres = blocks;\n\twhile (--i && blocks > direct) {\n\t\tblocks = ((blocks - direct - 1) >> ptrs_bits) + 1;\n\t\tres += blocks;\n\t\tdirect = 1;\n\t}\n\treturn res;\n}\n\nint sysv_getattr(struct mnt_idmap *idmap, const struct path *path,\n\t\t struct kstat *stat, u32 request_mask, unsigned int flags)\n{\n\tstruct super_block *s = path->dentry->d_sb;\n\tgeneric_fillattr(&nop_mnt_idmap, request_mask, d_inode(path->dentry),\n\t\t\t stat);\n\tstat->blocks = (s->s_blocksize / 512) * sysv_nblocks(s, stat->size);\n\tstat->blksize = s->s_blocksize;\n\treturn 0;\n}\n\nstatic int sysv_writepage(struct page *page, struct writeback_control *wbc)\n{\n\treturn block_write_full_page(page,get_block,wbc);\n}\n\nstatic int sysv_read_folio(struct file *file, struct folio *folio)\n{\n\treturn block_read_full_folio(folio, get_block);\n}\n\nint sysv_prepare_chunk(struct page *page, loff_t pos, unsigned len)\n{\n\treturn __block_write_begin(page, pos, len, get_block);\n}\n\nstatic void sysv_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\tsysv_truncate(inode);\n\t}\n}\n\nstatic int sysv_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len,\n\t\t\tstruct page **pagep, void **fsdata)\n{\n\tint ret;\n\n\tret = block_write_begin(mapping, pos, len, pagep, get_block);\n\tif (unlikely(ret))\n\t\tsysv_write_failed(mapping, pos + len);\n\n\treturn ret;\n}\n\nstatic sector_t sysv_bmap(struct address_space *mapping, sector_t block)\n{\n\treturn generic_block_bmap(mapping,block,get_block);\n}\n\nconst struct address_space_operations sysv_aops = {\n\t.dirty_folio = block_dirty_folio,\n\t.invalidate_folio = block_invalidate_folio,\n\t.read_folio = sysv_read_folio,\n\t.writepage = sysv_writepage,\n\t.write_begin = sysv_write_begin,\n\t.write_end = generic_write_end,\n\t.bmap = sysv_bmap\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}