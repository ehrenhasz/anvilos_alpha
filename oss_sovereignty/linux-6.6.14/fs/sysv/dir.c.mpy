{
  "module_name": "dir.c",
  "hash_id": "88cf64ff2e680df8b2d52bf48522e8d3f394ebaf968fd76568195572d1581044",
  "original_prompt": "Ingested from linux-6.6.14/fs/sysv/dir.c",
  "human_readable_source": "\n \n\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include \"sysv.h\"\n\nstatic int sysv_readdir(struct file *, struct dir_context *);\n\nconst struct file_operations sysv_dir_operations = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= generic_read_dir,\n\t.iterate_shared\t= sysv_readdir,\n\t.fsync\t\t= generic_file_fsync,\n};\n\nstatic void dir_commit_chunk(struct page *page, loff_t pos, unsigned len)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *dir = mapping->host;\n\n\tblock_write_end(NULL, mapping, pos, len, len, page, NULL);\n\tif (pos+len > dir->i_size) {\n\t\ti_size_write(dir, pos+len);\n\t\tmark_inode_dirty(dir);\n\t}\n\tunlock_page(page);\n}\n\nstatic int sysv_handle_dirsync(struct inode *dir)\n{\n\tint err;\n\n\terr = filemap_write_and_wait(dir->i_mapping);\n\tif (!err)\n\t\terr = sync_inode_metadata(dir, 1);\n\treturn err;\n}\n\n \nstatic void *dir_get_page(struct inode *dir, unsigned long n, struct page **p)\n{\n\tstruct address_space *mapping = dir->i_mapping;\n\tstruct page *page = read_mapping_page(mapping, n, NULL);\n\tif (IS_ERR(page))\n\t\treturn ERR_CAST(page);\n\t*p = page;\n\treturn kmap_local_page(page);\n}\n\nstatic int sysv_readdir(struct file *file, struct dir_context *ctx)\n{\n\tunsigned long pos = ctx->pos;\n\tstruct inode *inode = file_inode(file);\n\tstruct super_block *sb = inode->i_sb;\n\tunsigned long npages = dir_pages(inode);\n\tunsigned offset;\n\tunsigned long n;\n\n\tctx->pos = pos = (pos + SYSV_DIRSIZE-1) & ~(SYSV_DIRSIZE-1);\n\tif (pos >= inode->i_size)\n\t\treturn 0;\n\n\toffset = pos & ~PAGE_MASK;\n\tn = pos >> PAGE_SHIFT;\n\n\tfor ( ; n < npages; n++, offset = 0) {\n\t\tchar *kaddr, *limit;\n\t\tstruct sysv_dir_entry *de;\n\t\tstruct page *page;\n\n\t\tkaddr = dir_get_page(inode, n, &page);\n\t\tif (IS_ERR(kaddr))\n\t\t\tcontinue;\n\t\tde = (struct sysv_dir_entry *)(kaddr+offset);\n\t\tlimit = kaddr + PAGE_SIZE - SYSV_DIRSIZE;\n\t\tfor ( ;(char*)de <= limit; de++, ctx->pos += sizeof(*de)) {\n\t\t\tchar *name = de->name;\n\n\t\t\tif (!de->inode)\n\t\t\t\tcontinue;\n\n\t\t\tif (!dir_emit(ctx, name, strnlen(name,SYSV_NAMELEN),\n\t\t\t\t\tfs16_to_cpu(SYSV_SB(sb), de->inode),\n\t\t\t\t\tDT_UNKNOWN)) {\n\t\t\t\tunmap_and_put_page(page, kaddr);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tunmap_and_put_page(page, kaddr);\n\t}\n\treturn 0;\n}\n\n \nstatic inline int namecompare(int len, int maxlen,\n\tconst char * name, const char * buffer)\n{\n\tif (len < maxlen && buffer[len])\n\t\treturn 0;\n\treturn !memcmp(name, buffer, len);\n}\n\n \nstruct sysv_dir_entry *sysv_find_entry(struct dentry *dentry, struct page **res_page)\n{\n\tconst char * name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tstruct inode * dir = d_inode(dentry->d_parent);\n\tunsigned long start, n;\n\tunsigned long npages = dir_pages(dir);\n\tstruct page *page = NULL;\n\tstruct sysv_dir_entry *de;\n\n\t*res_page = NULL;\n\n\tstart = SYSV_I(dir)->i_dir_start_lookup;\n\tif (start >= npages)\n\t\tstart = 0;\n\tn = start;\n\n\tdo {\n\t\tchar *kaddr = dir_get_page(dir, n, &page);\n\n\t\tif (!IS_ERR(kaddr)) {\n\t\t\tde = (struct sysv_dir_entry *)kaddr;\n\t\t\tkaddr += PAGE_SIZE - SYSV_DIRSIZE;\n\t\t\tfor ( ; (char *) de <= kaddr ; de++) {\n\t\t\t\tif (!de->inode)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (namecompare(namelen, SYSV_NAMELEN,\n\t\t\t\t\t\t\tname, de->name))\n\t\t\t\t\tgoto found;\n\t\t\t}\n\t\t\tunmap_and_put_page(page, kaddr);\n\t\t}\n\n\t\tif (++n >= npages)\n\t\t\tn = 0;\n\t} while (n != start);\n\n\treturn NULL;\n\nfound:\n\tSYSV_I(dir)->i_dir_start_lookup = n;\n\t*res_page = page;\n\treturn de;\n}\n\nint sysv_add_link(struct dentry *dentry, struct inode *inode)\n{\n\tstruct inode *dir = d_inode(dentry->d_parent);\n\tconst char * name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tstruct page *page = NULL;\n\tstruct sysv_dir_entry * de;\n\tunsigned long npages = dir_pages(dir);\n\tunsigned long n;\n\tchar *kaddr;\n\tloff_t pos;\n\tint err;\n\n\t \n\tfor (n = 0; n <= npages; n++) {\n\t\tkaddr = dir_get_page(dir, n, &page);\n\t\tif (IS_ERR(kaddr))\n\t\t\treturn PTR_ERR(kaddr);\n\t\tde = (struct sysv_dir_entry *)kaddr;\n\t\tkaddr += PAGE_SIZE - SYSV_DIRSIZE;\n\t\twhile ((char *)de <= kaddr) {\n\t\t\tif (!de->inode)\n\t\t\t\tgoto got_it;\n\t\t\terr = -EEXIST;\n\t\t\tif (namecompare(namelen, SYSV_NAMELEN, name, de->name)) \n\t\t\t\tgoto out_page;\n\t\t\tde++;\n\t\t}\n\t\tunmap_and_put_page(page, kaddr);\n\t}\n\tBUG();\n\treturn -EINVAL;\n\ngot_it:\n\tpos = page_offset(page) + offset_in_page(de);\n\tlock_page(page);\n\terr = sysv_prepare_chunk(page, pos, SYSV_DIRSIZE);\n\tif (err)\n\t\tgoto out_unlock;\n\tmemcpy (de->name, name, namelen);\n\tmemset (de->name + namelen, 0, SYSV_DIRSIZE - namelen - 2);\n\tde->inode = cpu_to_fs16(SYSV_SB(inode->i_sb), inode->i_ino);\n\tdir_commit_chunk(page, pos, SYSV_DIRSIZE);\n\tdir->i_mtime = inode_set_ctime_current(dir);\n\tmark_inode_dirty(dir);\n\terr = sysv_handle_dirsync(dir);\nout_page:\n\tunmap_and_put_page(page, kaddr);\n\treturn err;\nout_unlock:\n\tunlock_page(page);\n\tgoto out_page;\n}\n\nint sysv_delete_entry(struct sysv_dir_entry *de, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tloff_t pos = page_offset(page) + offset_in_page(de);\n\tint err;\n\n\tlock_page(page);\n\terr = sysv_prepare_chunk(page, pos, SYSV_DIRSIZE);\n\tif (err) {\n\t\tunlock_page(page);\n\t\treturn err;\n\t}\n\tde->inode = 0;\n\tdir_commit_chunk(page, pos, SYSV_DIRSIZE);\n\tinode->i_mtime = inode_set_ctime_current(inode);\n\tmark_inode_dirty(inode);\n\treturn sysv_handle_dirsync(inode);\n}\n\nint sysv_make_empty(struct inode *inode, struct inode *dir)\n{\n\tstruct page *page = grab_cache_page(inode->i_mapping, 0);\n\tstruct sysv_dir_entry * de;\n\tchar *base;\n\tint err;\n\n\tif (!page)\n\t\treturn -ENOMEM;\n\terr = sysv_prepare_chunk(page, 0, 2 * SYSV_DIRSIZE);\n\tif (err) {\n\t\tunlock_page(page);\n\t\tgoto fail;\n\t}\n\tbase = kmap_local_page(page);\n\tmemset(base, 0, PAGE_SIZE);\n\n\tde = (struct sysv_dir_entry *) base;\n\tde->inode = cpu_to_fs16(SYSV_SB(inode->i_sb), inode->i_ino);\n\tstrcpy(de->name,\".\");\n\tde++;\n\tde->inode = cpu_to_fs16(SYSV_SB(inode->i_sb), dir->i_ino);\n\tstrcpy(de->name,\"..\");\n\n\tkunmap_local(base);\n\tdir_commit_chunk(page, 0, 2 * SYSV_DIRSIZE);\n\terr = sysv_handle_dirsync(inode);\nfail:\n\tput_page(page);\n\treturn err;\n}\n\n \nint sysv_empty_dir(struct inode * inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct page *page = NULL;\n\tunsigned long i, npages = dir_pages(inode);\n\tchar *kaddr;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tstruct sysv_dir_entry *de;\n\n\t\tkaddr = dir_get_page(inode, i, &page);\n\t\tif (IS_ERR(kaddr))\n\t\t\tcontinue;\n\n\t\tde = (struct sysv_dir_entry *)kaddr;\n\t\tkaddr += PAGE_SIZE-SYSV_DIRSIZE;\n\n\t\tfor ( ;(char *)de <= kaddr; de++) {\n\t\t\tif (!de->inode)\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tif (de->name[0] != '.')\n\t\t\t\tgoto not_empty;\n\t\t\tif (!de->name[1]) {\n\t\t\t\tif (de->inode == cpu_to_fs16(SYSV_SB(sb),\n\t\t\t\t\t\t\tinode->i_ino))\n\t\t\t\t\tcontinue;\n\t\t\t\tgoto not_empty;\n\t\t\t}\n\t\t\tif (de->name[1] != '.' || de->name[2])\n\t\t\t\tgoto not_empty;\n\t\t}\n\t\tunmap_and_put_page(page, kaddr);\n\t}\n\treturn 1;\n\nnot_empty:\n\tunmap_and_put_page(page, kaddr);\n\treturn 0;\n}\n\n \nint sysv_set_link(struct sysv_dir_entry *de, struct page *page,\n\tstruct inode *inode)\n{\n\tstruct inode *dir = page->mapping->host;\n\tloff_t pos = page_offset(page) + offset_in_page(de);\n\tint err;\n\n\tlock_page(page);\n\terr = sysv_prepare_chunk(page, pos, SYSV_DIRSIZE);\n\tif (err) {\n\t\tunlock_page(page);\n\t\treturn err;\n\t}\n\tde->inode = cpu_to_fs16(SYSV_SB(inode->i_sb), inode->i_ino);\n\tdir_commit_chunk(page, pos, SYSV_DIRSIZE);\n\tdir->i_mtime = inode_set_ctime_current(dir);\n\tmark_inode_dirty(dir);\n\treturn sysv_handle_dirsync(inode);\n}\n\n \nstruct sysv_dir_entry *sysv_dotdot(struct inode *dir, struct page **p)\n{\n\tstruct sysv_dir_entry *de = dir_get_page(dir, 0, p);\n\n\tif (IS_ERR(de))\n\t\treturn NULL;\n\t \n\treturn de + 1;\n}\n\nino_t sysv_inode_by_name(struct dentry *dentry)\n{\n\tstruct page *page;\n\tstruct sysv_dir_entry *de = sysv_find_entry (dentry, &page);\n\tino_t res = 0;\n\t\n\tif (de) {\n\t\tres = fs16_to_cpu(SYSV_SB(dentry->d_sb), de->inode);\n\t\tunmap_and_put_page(page, de);\n\t}\n\treturn res;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}