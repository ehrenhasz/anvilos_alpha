{
  "module_name": "super.c",
  "hash_id": "3663ab4d5947fc8cf51453a70aa9a0fadcaf4116af7a27462a3c813930e6aed4",
  "original_prompt": "Ingested from linux-6.6.14/fs/sysv/super.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"sysv.h\"\n\n \n\nenum {\n\tJAN_1_1980 = (10*365 + 2) * 24 * 60 * 60\n};\n\nstatic void detected_xenix(struct sysv_sb_info *sbi, unsigned *max_links)\n{\n\tstruct buffer_head *bh1 = sbi->s_bh1;\n\tstruct buffer_head *bh2 = sbi->s_bh2;\n\tstruct xenix_super_block * sbd1;\n\tstruct xenix_super_block * sbd2;\n\n\tif (bh1 != bh2)\n\t\tsbd1 = sbd2 = (struct xenix_super_block *) bh1->b_data;\n\telse {\n\t\t \n\t\tsbd1 = (struct xenix_super_block *) bh1->b_data;\n\t\tsbd2 = (struct xenix_super_block *) (bh2->b_data - 512);\n\t}\n\n\t*max_links = XENIX_LINK_MAX;\n\tsbi->s_fic_size = XENIX_NICINOD;\n\tsbi->s_flc_size = XENIX_NICFREE;\n\tsbi->s_sbd1 = (char *)sbd1;\n\tsbi->s_sbd2 = (char *)sbd2;\n\tsbi->s_sb_fic_count = &sbd1->s_ninode;\n\tsbi->s_sb_fic_inodes = &sbd1->s_inode[0];\n\tsbi->s_sb_total_free_inodes = &sbd2->s_tinode;\n\tsbi->s_bcache_count = &sbd1->s_nfree;\n\tsbi->s_bcache = &sbd1->s_free[0];\n\tsbi->s_free_blocks = &sbd2->s_tfree;\n\tsbi->s_sb_time = &sbd2->s_time;\n\tsbi->s_firstdatazone = fs16_to_cpu(sbi, sbd1->s_isize);\n\tsbi->s_nzones = fs32_to_cpu(sbi, sbd1->s_fsize);\n}\n\nstatic void detected_sysv4(struct sysv_sb_info *sbi, unsigned *max_links)\n{\n\tstruct sysv4_super_block * sbd;\n\tstruct buffer_head *bh1 = sbi->s_bh1;\n\tstruct buffer_head *bh2 = sbi->s_bh2;\n\n\tif (bh1 == bh2)\n\t\tsbd = (struct sysv4_super_block *) (bh1->b_data + BLOCK_SIZE/2);\n\telse\n\t\tsbd = (struct sysv4_super_block *) bh2->b_data;\n\n\t*max_links = SYSV_LINK_MAX;\n\tsbi->s_fic_size = SYSV_NICINOD;\n\tsbi->s_flc_size = SYSV_NICFREE;\n\tsbi->s_sbd1 = (char *)sbd;\n\tsbi->s_sbd2 = (char *)sbd;\n\tsbi->s_sb_fic_count = &sbd->s_ninode;\n\tsbi->s_sb_fic_inodes = &sbd->s_inode[0];\n\tsbi->s_sb_total_free_inodes = &sbd->s_tinode;\n\tsbi->s_bcache_count = &sbd->s_nfree;\n\tsbi->s_bcache = &sbd->s_free[0];\n\tsbi->s_free_blocks = &sbd->s_tfree;\n\tsbi->s_sb_time = &sbd->s_time;\n\tsbi->s_sb_state = &sbd->s_state;\n\tsbi->s_firstdatazone = fs16_to_cpu(sbi, sbd->s_isize);\n\tsbi->s_nzones = fs32_to_cpu(sbi, sbd->s_fsize);\n}\n\nstatic void detected_sysv2(struct sysv_sb_info *sbi, unsigned *max_links)\n{\n\tstruct sysv2_super_block *sbd;\n\tstruct buffer_head *bh1 = sbi->s_bh1;\n\tstruct buffer_head *bh2 = sbi->s_bh2;\n\n\tif (bh1 == bh2)\n\t\tsbd = (struct sysv2_super_block *) (bh1->b_data + BLOCK_SIZE/2);\n\telse\n\t\tsbd = (struct sysv2_super_block *) bh2->b_data;\n\n\t*max_links = SYSV_LINK_MAX;\n\tsbi->s_fic_size = SYSV_NICINOD;\n\tsbi->s_flc_size = SYSV_NICFREE;\n\tsbi->s_sbd1 = (char *)sbd;\n\tsbi->s_sbd2 = (char *)sbd;\n\tsbi->s_sb_fic_count = &sbd->s_ninode;\n\tsbi->s_sb_fic_inodes = &sbd->s_inode[0];\n\tsbi->s_sb_total_free_inodes = &sbd->s_tinode;\n\tsbi->s_bcache_count = &sbd->s_nfree;\n\tsbi->s_bcache = &sbd->s_free[0];\n\tsbi->s_free_blocks = &sbd->s_tfree;\n\tsbi->s_sb_time = &sbd->s_time;\n\tsbi->s_sb_state = &sbd->s_state;\n\tsbi->s_firstdatazone = fs16_to_cpu(sbi, sbd->s_isize);\n\tsbi->s_nzones = fs32_to_cpu(sbi, sbd->s_fsize);\n}\n\nstatic void detected_coherent(struct sysv_sb_info *sbi, unsigned *max_links)\n{\n\tstruct coh_super_block * sbd;\n\tstruct buffer_head *bh1 = sbi->s_bh1;\n\n\tsbd = (struct coh_super_block *) bh1->b_data;\n\n\t*max_links = COH_LINK_MAX;\n\tsbi->s_fic_size = COH_NICINOD;\n\tsbi->s_flc_size = COH_NICFREE;\n\tsbi->s_sbd1 = (char *)sbd;\n\tsbi->s_sbd2 = (char *)sbd;\n\tsbi->s_sb_fic_count = &sbd->s_ninode;\n\tsbi->s_sb_fic_inodes = &sbd->s_inode[0];\n\tsbi->s_sb_total_free_inodes = &sbd->s_tinode;\n\tsbi->s_bcache_count = &sbd->s_nfree;\n\tsbi->s_bcache = &sbd->s_free[0];\n\tsbi->s_free_blocks = &sbd->s_tfree;\n\tsbi->s_sb_time = &sbd->s_time;\n\tsbi->s_firstdatazone = fs16_to_cpu(sbi, sbd->s_isize);\n\tsbi->s_nzones = fs32_to_cpu(sbi, sbd->s_fsize);\n}\n\nstatic void detected_v7(struct sysv_sb_info *sbi, unsigned *max_links)\n{\n\tstruct buffer_head *bh2 = sbi->s_bh2;\n\tstruct v7_super_block *sbd = (struct v7_super_block *)bh2->b_data;\n\n\t*max_links = V7_LINK_MAX;\n\tsbi->s_fic_size = V7_NICINOD;\n\tsbi->s_flc_size = V7_NICFREE;\n\tsbi->s_sbd1 = (char *)sbd;\n\tsbi->s_sbd2 = (char *)sbd;\n\tsbi->s_sb_fic_count = &sbd->s_ninode;\n\tsbi->s_sb_fic_inodes = &sbd->s_inode[0];\n\tsbi->s_sb_total_free_inodes = &sbd->s_tinode;\n\tsbi->s_bcache_count = &sbd->s_nfree;\n\tsbi->s_bcache = &sbd->s_free[0];\n\tsbi->s_free_blocks = &sbd->s_tfree;\n\tsbi->s_sb_time = &sbd->s_time;\n\tsbi->s_firstdatazone = fs16_to_cpu(sbi, sbd->s_isize);\n\tsbi->s_nzones = fs32_to_cpu(sbi, sbd->s_fsize);\n}\n\nstatic int detect_xenix(struct sysv_sb_info *sbi, struct buffer_head *bh)\n{\n\tstruct xenix_super_block *sbd = (struct xenix_super_block *)bh->b_data;\n\tif (*(__le32 *)&sbd->s_magic == cpu_to_le32(0x2b5544))\n\t\tsbi->s_bytesex = BYTESEX_LE;\n\telse if (*(__be32 *)&sbd->s_magic == cpu_to_be32(0x2b5544))\n\t\tsbi->s_bytesex = BYTESEX_BE;\n\telse\n\t\treturn 0;\n\tswitch (fs32_to_cpu(sbi, sbd->s_type)) {\n\tcase 1:\n\t\tsbi->s_type = FSTYPE_XENIX;\n\t\treturn 1;\n\tcase 2:\n\t\tsbi->s_type = FSTYPE_XENIX;\n\t\treturn 2;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int detect_sysv(struct sysv_sb_info *sbi, struct buffer_head *bh)\n{\n\tstruct super_block *sb = sbi->s_sb;\n\t \n\tstruct sysv4_super_block * sbd;\n\tu32 type;\n\n\tsbd = (struct sysv4_super_block *) (bh->b_data + BLOCK_SIZE/2);\n\tif (*(__le32 *)&sbd->s_magic == cpu_to_le32(0xfd187e20))\n\t\tsbi->s_bytesex = BYTESEX_LE;\n\telse if (*(__be32 *)&sbd->s_magic == cpu_to_be32(0xfd187e20))\n\t\tsbi->s_bytesex = BYTESEX_BE;\n\telse\n\t\treturn 0;\n\n\ttype = fs32_to_cpu(sbi, sbd->s_type);\n \n \tif (fs16_to_cpu(sbi, sbd->s_nfree) == 0xffff) {\n \t\tsbi->s_type = FSTYPE_AFS;\n\t\tsbi->s_forced_ro = 1;\n \t\tif (!sb_rdonly(sb)) {\n \t\t\tprintk(\"SysV FS: SCO EAFS on %s detected, \" \n \t\t\t\t\"forcing read-only mode.\\n\", \n \t\t\t\tsb->s_id);\n \t\t}\n \t\treturn type;\n \t}\n \n\tif (fs32_to_cpu(sbi, sbd->s_time) < JAN_1_1980) {\n\t\t \n\t\tif (type > 3 || type < 1)\n\t\t\treturn 0;\n\t\tsbi->s_type = FSTYPE_SYSV2;\n\t\treturn type;\n\t}\n\tif ((type > 3 || type < 1) && (type > 0x30 || type < 0x10))\n\t\treturn 0;\n\n\t \n\n\tif (type >= 0x10) {\n\t\tprintk(\"SysV FS: can't handle long file names on %s, \"\n\t\t       \"forcing read-only mode.\\n\", sb->s_id);\n\t\tsbi->s_forced_ro = 1;\n\t}\n\n\tsbi->s_type = FSTYPE_SYSV4;\n\treturn type >= 0x10 ? type >> 4 : type;\n}\n\nstatic int detect_coherent(struct sysv_sb_info *sbi, struct buffer_head *bh)\n{\n\tstruct coh_super_block * sbd;\n\n\tsbd = (struct coh_super_block *) (bh->b_data + BLOCK_SIZE/2);\n\tif ((memcmp(sbd->s_fname,\"noname\",6) && memcmp(sbd->s_fname,\"xxxxx \",6))\n\t    || (memcmp(sbd->s_fpack,\"nopack\",6) && memcmp(sbd->s_fpack,\"xxxxx\\n\",6)))\n\t\treturn 0;\n\tsbi->s_bytesex = BYTESEX_PDP;\n\tsbi->s_type = FSTYPE_COH;\n\treturn 1;\n}\n\nstatic int detect_sysv_odd(struct sysv_sb_info *sbi, struct buffer_head *bh)\n{\n\tint size = detect_sysv(sbi, bh);\n\n\treturn size>2 ? 0 : size;\n}\n\nstatic struct {\n\tint block;\n\tint (*test)(struct sysv_sb_info *, struct buffer_head *);\n} flavours[] = {\n\t{1, detect_xenix},\n\t{0, detect_sysv},\n\t{0, detect_coherent},\n\t{9, detect_sysv_odd},\n\t{15,detect_sysv_odd},\n\t{18,detect_sysv},\n};\n\nstatic char *flavour_names[] = {\n\t[FSTYPE_XENIX]\t= \"Xenix\",\n\t[FSTYPE_SYSV4]\t= \"SystemV\",\n\t[FSTYPE_SYSV2]\t= \"SystemV Release 2\",\n\t[FSTYPE_COH]\t= \"Coherent\",\n\t[FSTYPE_V7]\t= \"V7\",\n\t[FSTYPE_AFS]\t= \"AFS\",\n};\n\nstatic void (*flavour_setup[])(struct sysv_sb_info *, unsigned *) = {\n\t[FSTYPE_XENIX]\t= detected_xenix,\n\t[FSTYPE_SYSV4]\t= detected_sysv4,\n\t[FSTYPE_SYSV2]\t= detected_sysv2,\n\t[FSTYPE_COH]\t= detected_coherent,\n\t[FSTYPE_V7]\t= detected_v7,\n\t[FSTYPE_AFS]\t= detected_sysv4,\n};\n\nstatic int complete_read_super(struct super_block *sb, int silent, int size)\n{\n\tstruct sysv_sb_info *sbi = SYSV_SB(sb);\n\tstruct inode *root_inode;\n\tchar *found = flavour_names[sbi->s_type];\n\tu_char n_bits = size+8;\n\tint bsize = 1 << n_bits;\n\tint bsize_4 = bsize >> 2;\n\n\tsbi->s_firstinodezone = 2;\n\n\tflavour_setup[sbi->s_type](sbi, &sb->s_max_links);\n\tif (sbi->s_firstdatazone < sbi->s_firstinodezone)\n\t\treturn 0;\n\n\tsbi->s_ndatazones = sbi->s_nzones - sbi->s_firstdatazone;\n\tsbi->s_inodes_per_block = bsize >> 6;\n\tsbi->s_inodes_per_block_1 = (bsize >> 6)-1;\n\tsbi->s_inodes_per_block_bits = n_bits-6;\n\tsbi->s_ind_per_block = bsize_4;\n\tsbi->s_ind_per_block_2 = bsize_4*bsize_4;\n\tsbi->s_toobig_block = 10 + bsize_4 * (1 + bsize_4 * (1 + bsize_4));\n\tsbi->s_ind_per_block_bits = n_bits-2;\n\n\tsbi->s_ninodes = (sbi->s_firstdatazone - sbi->s_firstinodezone)\n\t\t<< sbi->s_inodes_per_block_bits;\n\n\tif (!silent)\n\t\tprintk(\"VFS: Found a %s FS (block size = %ld) on device %s\\n\",\n\t\t       found, sb->s_blocksize, sb->s_id);\n\n\tsb->s_magic = SYSV_MAGIC_BASE + sbi->s_type;\n\t \n\tsb->s_op = &sysv_sops;\n\tif (sbi->s_forced_ro)\n\t\tsb->s_flags |= SB_RDONLY;\n\troot_inode = sysv_iget(sb, SYSV_ROOT_INO);\n\tif (IS_ERR(root_inode)) {\n\t\tprintk(\"SysV FS: get root inode failed\\n\");\n\t\treturn 0;\n\t}\n\tsb->s_root = d_make_root(root_inode);\n\tif (!sb->s_root) {\n\t\tprintk(\"SysV FS: get root dentry failed\\n\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int sysv_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct buffer_head *bh1, *bh = NULL;\n\tstruct sysv_sb_info *sbi;\n\tunsigned long blocknr;\n\tint size = 0, i;\n\t\n\tBUILD_BUG_ON(1024 != sizeof (struct xenix_super_block));\n\tBUILD_BUG_ON(512 != sizeof (struct sysv4_super_block));\n\tBUILD_BUG_ON(512 != sizeof (struct sysv2_super_block));\n\tBUILD_BUG_ON(500 != sizeof (struct coh_super_block));\n\tBUILD_BUG_ON(64 != sizeof (struct sysv_inode));\n\n\tsbi = kzalloc(sizeof(struct sysv_sb_info), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\n\tsbi->s_sb = sb;\n\tsbi->s_block_base = 0;\n\tmutex_init(&sbi->s_lock);\n\tsb->s_fs_info = sbi;\n\tsb->s_time_min = 0;\n\tsb->s_time_max = U32_MAX;\n\tsb_set_blocksize(sb, BLOCK_SIZE);\n\n\tfor (i = 0; i < ARRAY_SIZE(flavours) && !size; i++) {\n\t\tbrelse(bh);\n\t\tbh = sb_bread(sb, flavours[i].block);\n\t\tif (!bh)\n\t\t\tcontinue;\n\t\tsize = flavours[i].test(SYSV_SB(sb), bh);\n\t}\n\n\tif (!size)\n\t\tgoto Eunknown;\n\n\tswitch (size) {\n\t\tcase 1:\n\t\t\tblocknr = bh->b_blocknr << 1;\n\t\t\tbrelse(bh);\n\t\t\tsb_set_blocksize(sb, 512);\n\t\t\tbh1 = sb_bread(sb, blocknr);\n\t\t\tbh = sb_bread(sb, blocknr + 1);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tbh1 = bh;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tblocknr = bh->b_blocknr >> 1;\n\t\t\tbrelse(bh);\n\t\t\tsb_set_blocksize(sb, 2048);\n\t\t\tbh1 = bh = sb_bread(sb, blocknr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto Ebadsize;\n\t}\n\n\tif (bh && bh1) {\n\t\tsbi->s_bh1 = bh1;\n\t\tsbi->s_bh2 = bh;\n\t\tif (complete_read_super(sb, silent, size))\n\t\t\treturn 0;\n\t}\n\n\tbrelse(bh1);\n\tbrelse(bh);\n\tsb_set_blocksize(sb, BLOCK_SIZE);\n\tprintk(\"oldfs: cannot read superblock\\n\");\nfailed:\n\tkfree(sbi);\n\treturn -EINVAL;\n\nEunknown:\n\tbrelse(bh);\n\tif (!silent)\n\t\tprintk(\"VFS: unable to find oldfs superblock on device %s\\n\",\n\t\t\tsb->s_id);\n\tgoto failed;\nEbadsize:\n\tbrelse(bh);\n\tif (!silent)\n\t\tprintk(\"VFS: oldfs: unsupported block size (%dKb)\\n\",\n\t\t\t1<<(size-2));\n\tgoto failed;\n}\n\nstatic int v7_sanity_check(struct super_block *sb, struct buffer_head *bh)\n{\n\tstruct v7_super_block *v7sb;\n\tstruct sysv_inode *v7i;\n\tstruct buffer_head *bh2;\n\tstruct sysv_sb_info *sbi;\n\n\tsbi = sb->s_fs_info;\n\n\t \n\tv7sb = (struct v7_super_block *) bh->b_data;\n\tif (fs16_to_cpu(sbi, v7sb->s_nfree) > V7_NICFREE ||\n\t    fs16_to_cpu(sbi, v7sb->s_ninode) > V7_NICINOD ||\n\t    fs32_to_cpu(sbi, v7sb->s_fsize) > V7_MAXSIZE)\n\t\treturn 0;\n\n\t \n\tbh2 = sb_bread(sb, 2);\n\tif (bh2 == NULL)\n\t\treturn 0;\n\n\tv7i = (struct sysv_inode *)(bh2->b_data + 64);\n\tif ((fs16_to_cpu(sbi, v7i->i_mode) & ~0777) != S_IFDIR ||\n\t    (fs32_to_cpu(sbi, v7i->i_size) == 0) ||\n\t    (fs32_to_cpu(sbi, v7i->i_size) & 017) ||\n\t    (fs32_to_cpu(sbi, v7i->i_size) > V7_NFILES *\n\t     sizeof(struct sysv_dir_entry))) {\n\t\tbrelse(bh2);\n\t\treturn 0;\n\t}\n\n\tbrelse(bh2);\n\treturn 1;\n}\n\nstatic int v7_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct sysv_sb_info *sbi;\n\tstruct buffer_head *bh;\n\n\tBUILD_BUG_ON(sizeof(struct v7_super_block) != 440);\n\tBUILD_BUG_ON(sizeof(struct sysv_inode) != 64);\n\n\tsbi = kzalloc(sizeof(struct sysv_sb_info), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\n\tsbi->s_sb = sb;\n\tsbi->s_block_base = 0;\n\tsbi->s_type = FSTYPE_V7;\n\tmutex_init(&sbi->s_lock);\n\tsb->s_fs_info = sbi;\n\tsb->s_time_min = 0;\n\tsb->s_time_max = U32_MAX;\n\t\n\tsb_set_blocksize(sb, 512);\n\n\tif ((bh = sb_bread(sb, 1)) == NULL) {\n\t\tif (!silent)\n\t\t\tprintk(\"VFS: unable to read V7 FS superblock on \"\n\t\t\t       \"device %s.\\n\", sb->s_id);\n\t\tgoto failed;\n\t}\n\n\t \n\tsbi->s_bytesex = BYTESEX_PDP;\n\tif (v7_sanity_check(sb, bh))\n\t\tgoto detected;\n\n\t \n\tsbi->s_bytesex = BYTESEX_LE;\n\tif (v7_sanity_check(sb, bh))\n\t\tgoto detected;\n\n\tgoto failed;\n\ndetected:\n\tsbi->s_bh1 = bh;\n\tsbi->s_bh2 = bh;\n\tif (complete_read_super(sb, silent, 1))\n\t\treturn 0;\n\nfailed:\n\tprintk(KERN_ERR \"VFS: could not find a valid V7 on %s.\\n\",\n\t\tsb->s_id);\n\tbrelse(bh);\n\tkfree(sbi);\n\treturn -EINVAL;\n}\n\n \n\nstatic struct dentry *sysv_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, sysv_fill_super);\n}\n\nstatic struct dentry *v7_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, v7_fill_super);\n}\n\nstatic struct file_system_type sysv_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"sysv\",\n\t.mount\t\t= sysv_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\nMODULE_ALIAS_FS(\"sysv\");\n\nstatic struct file_system_type v7_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"v7\",\n\t.mount\t\t= v7_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\nMODULE_ALIAS_FS(\"v7\");\nMODULE_ALIAS(\"v7\");\n\nstatic int __init init_sysv_fs(void)\n{\n\tint error;\n\n\terror = sysv_init_icache();\n\tif (error)\n\t\tgoto out;\n\terror = register_filesystem(&sysv_fs_type);\n\tif (error)\n\t\tgoto destroy_icache;\n\terror = register_filesystem(&v7_fs_type);\n\tif (error)\n\t\tgoto unregister;\n\treturn 0;\n\nunregister:\n\tunregister_filesystem(&sysv_fs_type);\ndestroy_icache:\n\tsysv_destroy_icache();\nout:\n\treturn error;\n}\n\nstatic void __exit exit_sysv_fs(void)\n{\n\tunregister_filesystem(&sysv_fs_type);\n\tunregister_filesystem(&v7_fs_type);\n\tsysv_destroy_icache();\n}\n\nmodule_init(init_sysv_fs)\nmodule_exit(exit_sysv_fs)\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}