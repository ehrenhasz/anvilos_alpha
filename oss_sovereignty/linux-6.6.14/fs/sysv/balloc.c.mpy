{
  "module_name": "balloc.c",
  "hash_id": "56292e9aea54e09c25c7bacd9ca606f8c8a6ce4002d63b402b40d4c25b81e3d8",
  "original_prompt": "Ingested from linux-6.6.14/fs/sysv/balloc.c",
  "human_readable_source": "\n \n\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"sysv.h\"\n\n \n\nstatic inline sysv_zone_t *get_chunk(struct super_block *sb, struct buffer_head *bh)\n{\n\tchar *bh_data = bh->b_data;\n\n\tif (SYSV_SB(sb)->s_type == FSTYPE_SYSV4)\n\t\treturn (sysv_zone_t*)(bh_data+4);\n\telse\n\t\treturn (sysv_zone_t*)(bh_data+2);\n}\n\n \n\nvoid sysv_free_block(struct super_block * sb, sysv_zone_t nr)\n{\n\tstruct sysv_sb_info * sbi = SYSV_SB(sb);\n\tstruct buffer_head * bh;\n\tsysv_zone_t *blocks = sbi->s_bcache;\n\tunsigned count;\n\tunsigned block = fs32_to_cpu(sbi, nr);\n\n\t \n\tif (sbi->s_type == FSTYPE_AFS)\n\t\treturn;\n\n\tif (block < sbi->s_firstdatazone || block >= sbi->s_nzones) {\n\t\tprintk(\"sysv_free_block: trying to free block not in datazone\\n\");\n\t\treturn;\n\t}\n\n\tmutex_lock(&sbi->s_lock);\n\tcount = fs16_to_cpu(sbi, *sbi->s_bcache_count);\n\n\tif (count > sbi->s_flc_size) {\n\t\tprintk(\"sysv_free_block: flc_count > flc_size\\n\");\n\t\tmutex_unlock(&sbi->s_lock);\n\t\treturn;\n\t}\n\t \n\tif (count == sbi->s_flc_size || count == 0) {\n\t\tblock += sbi->s_block_base;\n\t\tbh = sb_getblk(sb, block);\n\t\tif (!bh) {\n\t\t\tprintk(\"sysv_free_block: getblk() failed\\n\");\n\t\t\tmutex_unlock(&sbi->s_lock);\n\t\t\treturn;\n\t\t}\n\t\tmemset(bh->b_data, 0, sb->s_blocksize);\n\t\t*(__fs16*)bh->b_data = cpu_to_fs16(sbi, count);\n\t\tmemcpy(get_chunk(sb,bh), blocks, count * sizeof(sysv_zone_t));\n\t\tmark_buffer_dirty(bh);\n\t\tset_buffer_uptodate(bh);\n\t\tbrelse(bh);\n\t\tcount = 0;\n\t}\n\tsbi->s_bcache[count++] = nr;\n\n\t*sbi->s_bcache_count = cpu_to_fs16(sbi, count);\n\tfs32_add(sbi, sbi->s_free_blocks, 1);\n\tdirty_sb(sb);\n\tmutex_unlock(&sbi->s_lock);\n}\n\nsysv_zone_t sysv_new_block(struct super_block * sb)\n{\n\tstruct sysv_sb_info *sbi = SYSV_SB(sb);\n\tunsigned int block;\n\tsysv_zone_t nr;\n\tstruct buffer_head * bh;\n\tunsigned count;\n\n\tmutex_lock(&sbi->s_lock);\n\tcount = fs16_to_cpu(sbi, *sbi->s_bcache_count);\n\n\tif (count == 0)  \n\t\tgoto Enospc;\n\tnr = sbi->s_bcache[--count];\n\tif (nr == 0)   \n\t\tgoto Enospc;\n\n\tblock = fs32_to_cpu(sbi, nr);\n\n\t*sbi->s_bcache_count = cpu_to_fs16(sbi, count);\n\n\tif (block < sbi->s_firstdatazone || block >= sbi->s_nzones) {\n\t\tprintk(\"sysv_new_block: new block %d is not in data zone\\n\",\n\t\t\tblock);\n\t\tgoto Enospc;\n\t}\n\n\tif (count == 0) {  \n\t\tunsigned count;\n\n\t\tblock += sbi->s_block_base;\n\t\tif (!(bh = sb_bread(sb, block))) {\n\t\t\tprintk(\"sysv_new_block: cannot read free-list block\\n\");\n\t\t\t \n\t\t\t*sbi->s_bcache_count = cpu_to_fs16(sbi, 1);\n\t\t\tgoto Enospc;\n\t\t}\n\t\tcount = fs16_to_cpu(sbi, *(__fs16*)bh->b_data);\n\t\tif (count > sbi->s_flc_size) {\n\t\t\tprintk(\"sysv_new_block: free-list block with >flc_size entries\\n\");\n\t\t\tbrelse(bh);\n\t\t\tgoto Enospc;\n\t\t}\n\t\t*sbi->s_bcache_count = cpu_to_fs16(sbi, count);\n\t\tmemcpy(sbi->s_bcache, get_chunk(sb, bh),\n\t\t\t\tcount * sizeof(sysv_zone_t));\n\t\tbrelse(bh);\n\t}\n\t \n\tfs32_add(sbi, sbi->s_free_blocks, -1);\n\tdirty_sb(sb);\n\tmutex_unlock(&sbi->s_lock);\n\treturn nr;\n\nEnospc:\n\tmutex_unlock(&sbi->s_lock);\n\treturn 0;\n}\n\nunsigned long sysv_count_free_blocks(struct super_block * sb)\n{\n\tstruct sysv_sb_info * sbi = SYSV_SB(sb);\n\tint sb_count;\n\tint count;\n\tstruct buffer_head * bh = NULL;\n\tsysv_zone_t *blocks;\n\tunsigned block;\n\tint n;\n\n\t \n\tif (sbi->s_type == FSTYPE_AFS)\n\t\treturn 0;\n\n\tmutex_lock(&sbi->s_lock);\n\tsb_count = fs32_to_cpu(sbi, *sbi->s_free_blocks);\n\n\tif (0)\n\t\tgoto trust_sb;\n\n\t \n\tcount = 0;\n\tn = fs16_to_cpu(sbi, *sbi->s_bcache_count);\n\tblocks = sbi->s_bcache;\n\twhile (1) {\n\t\tsysv_zone_t zone;\n\t\tif (n > sbi->s_flc_size)\n\t\t\tgoto E2big;\n\t\tzone = 0;\n\t\twhile (n && (zone = blocks[--n]) != 0)\n\t\t\tcount++;\n\t\tif (zone == 0)\n\t\t\tbreak;\n\n\t\tblock = fs32_to_cpu(sbi, zone);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\n\t\tif (block < sbi->s_firstdatazone || block >= sbi->s_nzones)\n\t\t\tgoto Einval;\n\t\tblock += sbi->s_block_base;\n\t\tbh = sb_bread(sb, block);\n\t\tif (!bh)\n\t\t\tgoto Eio;\n\t\tn = fs16_to_cpu(sbi, *(__fs16*)bh->b_data);\n\t\tblocks = get_chunk(sb, bh);\n\t}\n\tif (bh)\n\t\tbrelse(bh);\n\tif (count != sb_count)\n\t\tgoto Ecount;\ndone:\n\tmutex_unlock(&sbi->s_lock);\n\treturn count;\n\nEinval:\n\tprintk(\"sysv_count_free_blocks: new block %d is not in data zone\\n\",\n\t\tblock);\n\tgoto trust_sb;\nEio:\n\tprintk(\"sysv_count_free_blocks: cannot read free-list block\\n\");\n\tgoto trust_sb;\nE2big:\n\tprintk(\"sysv_count_free_blocks: >flc_size entries in free-list block\\n\");\n\tif (bh)\n\t\tbrelse(bh);\ntrust_sb:\n\tcount = sb_count;\n\tgoto done;\nEcount:\n\tprintk(\"sysv_count_free_blocks: free block count was %d, \"\n\t\t\"correcting to %d\\n\", sb_count, count);\n\tif (!sb_rdonly(sb)) {\n\t\t*sbi->s_free_blocks = cpu_to_fs32(sbi, count);\n\t\tdirty_sb(sb);\n\t}\n\tgoto done;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}