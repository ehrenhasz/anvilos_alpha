{
  "module_name": "inode.c",
  "hash_id": "0a95216227bc381985e0fb334a789a77f2fe209c50503de1ff891aea5f35073e",
  "original_prompt": "Ingested from linux-6.6.14/fs/sysv/inode.c",
  "human_readable_source": "\n \n\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/buffer_head.h>\n#include <linux/vfs.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <asm/byteorder.h>\n#include \"sysv.h\"\n\nstatic int sysv_sync_fs(struct super_block *sb, int wait)\n{\n\tstruct sysv_sb_info *sbi = SYSV_SB(sb);\n\tu32 time = (u32)ktime_get_real_seconds(), old_time;\n\n\tmutex_lock(&sbi->s_lock);\n\n\t \n\told_time = fs32_to_cpu(sbi, *sbi->s_sb_time);\n\tif (sbi->s_type == FSTYPE_SYSV4) {\n\t\tif (*sbi->s_sb_state == cpu_to_fs32(sbi, 0x7c269d38u - old_time))\n\t\t\t*sbi->s_sb_state = cpu_to_fs32(sbi, 0x7c269d38u - time);\n\t\t*sbi->s_sb_time = cpu_to_fs32(sbi, time);\n\t\tmark_buffer_dirty(sbi->s_bh2);\n\t}\n\n\tmutex_unlock(&sbi->s_lock);\n\n\treturn 0;\n}\n\nstatic int sysv_remount(struct super_block *sb, int *flags, char *data)\n{\n\tstruct sysv_sb_info *sbi = SYSV_SB(sb);\n\n\tsync_filesystem(sb);\n\tif (sbi->s_forced_ro)\n\t\t*flags |= SB_RDONLY;\n\treturn 0;\n}\n\nstatic void sysv_put_super(struct super_block *sb)\n{\n\tstruct sysv_sb_info *sbi = SYSV_SB(sb);\n\n\tif (!sb_rdonly(sb)) {\n\t\t \n\t\tmark_buffer_dirty(sbi->s_bh1);\n\t\tif (sbi->s_bh1 != sbi->s_bh2)\n\t\t\tmark_buffer_dirty(sbi->s_bh2);\n\t}\n\n\tbrelse(sbi->s_bh1);\n\tif (sbi->s_bh1 != sbi->s_bh2)\n\t\tbrelse(sbi->s_bh2);\n\n\tkfree(sbi);\n}\n\nstatic int sysv_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct sysv_sb_info *sbi = SYSV_SB(sb);\n\tu64 id = huge_encode_dev(sb->s_bdev->bd_dev);\n\n\tbuf->f_type = sb->s_magic;\n\tbuf->f_bsize = sb->s_blocksize;\n\tbuf->f_blocks = sbi->s_ndatazones;\n\tbuf->f_bavail = buf->f_bfree = sysv_count_free_blocks(sb);\n\tbuf->f_files = sbi->s_ninodes;\n\tbuf->f_ffree = sysv_count_free_inodes(sb);\n\tbuf->f_namelen = SYSV_NAMELEN;\n\tbuf->f_fsid = u64_to_fsid(id);\n\treturn 0;\n}\n\n \nstatic inline void read3byte(struct sysv_sb_info *sbi,\n\tunsigned char * from, unsigned char * to)\n{\n\tif (sbi->s_bytesex == BYTESEX_PDP) {\n\t\tto[0] = from[0];\n\t\tto[1] = 0;\n\t\tto[2] = from[1];\n\t\tto[3] = from[2];\n\t} else if (sbi->s_bytesex == BYTESEX_LE) {\n\t\tto[0] = from[0];\n\t\tto[1] = from[1];\n\t\tto[2] = from[2];\n\t\tto[3] = 0;\n\t} else {\n\t\tto[0] = 0;\n\t\tto[1] = from[0];\n\t\tto[2] = from[1];\n\t\tto[3] = from[2];\n\t}\n}\n\nstatic inline void write3byte(struct sysv_sb_info *sbi,\n\tunsigned char * from, unsigned char * to)\n{\n\tif (sbi->s_bytesex == BYTESEX_PDP) {\n\t\tto[0] = from[0];\n\t\tto[1] = from[2];\n\t\tto[2] = from[3];\n\t} else if (sbi->s_bytesex == BYTESEX_LE) {\n\t\tto[0] = from[0];\n\t\tto[1] = from[1];\n\t\tto[2] = from[2];\n\t} else {\n\t\tto[0] = from[1];\n\t\tto[1] = from[2];\n\t\tto[2] = from[3];\n\t}\n}\n\nstatic const struct inode_operations sysv_symlink_inode_operations = {\n\t.get_link\t= page_get_link,\n\t.getattr\t= sysv_getattr,\n};\n\nvoid sysv_set_inode(struct inode *inode, dev_t rdev)\n{\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &sysv_file_inode_operations;\n\t\tinode->i_fop = &sysv_file_operations;\n\t\tinode->i_mapping->a_ops = &sysv_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &sysv_dir_inode_operations;\n\t\tinode->i_fop = &sysv_dir_operations;\n\t\tinode->i_mapping->a_ops = &sysv_aops;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &sysv_symlink_inode_operations;\n\t\tinode_nohighmem(inode);\n\t\tinode->i_mapping->a_ops = &sysv_aops;\n\t} else\n\t\tinit_special_inode(inode, inode->i_mode, rdev);\n}\n\nstruct inode *sysv_iget(struct super_block *sb, unsigned int ino)\n{\n\tstruct sysv_sb_info * sbi = SYSV_SB(sb);\n\tstruct buffer_head * bh;\n\tstruct sysv_inode * raw_inode;\n\tstruct sysv_inode_info * si;\n\tstruct inode *inode;\n\tunsigned int block;\n\n\tif (!ino || ino > sbi->s_ninodes) {\n\t\tprintk(\"Bad inode number on dev %s: %d is out of range\\n\",\n\t\t       sb->s_id, ino);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\traw_inode = sysv_raw_inode(sb, ino, &bh);\n\tif (!raw_inode) {\n\t\tprintk(\"Major problem: unable to read inode from dev %s\\n\",\n\t\t       inode->i_sb->s_id);\n\t\tgoto bad_inode;\n\t}\n\t \n\tinode->i_mode = fs16_to_cpu(sbi, raw_inode->i_mode);\n\ti_uid_write(inode, (uid_t)fs16_to_cpu(sbi, raw_inode->i_uid));\n\ti_gid_write(inode, (gid_t)fs16_to_cpu(sbi, raw_inode->i_gid));\n\tset_nlink(inode, fs16_to_cpu(sbi, raw_inode->i_nlink));\n\tinode->i_size = fs32_to_cpu(sbi, raw_inode->i_size);\n\tinode->i_atime.tv_sec = fs32_to_cpu(sbi, raw_inode->i_atime);\n\tinode->i_mtime.tv_sec = fs32_to_cpu(sbi, raw_inode->i_mtime);\n\tinode_set_ctime(inode, fs32_to_cpu(sbi, raw_inode->i_ctime), 0);\n\tinode->i_atime.tv_nsec = 0;\n\tinode->i_mtime.tv_nsec = 0;\n\tinode->i_blocks = 0;\n\n\tsi = SYSV_I(inode);\n\tfor (block = 0; block < 10+1+1+1; block++)\n\t\tread3byte(sbi, &raw_inode->i_data[3*block],\n\t\t\t\t(u8 *)&si->i_data[block]);\n\tbrelse(bh);\n\tsi->i_dir_start_lookup = 0;\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))\n\t\tsysv_set_inode(inode,\n\t\t\t       old_decode_dev(fs32_to_cpu(sbi, si->i_data[0])));\n\telse\n\t\tsysv_set_inode(inode, 0);\n\tunlock_new_inode(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\treturn ERR_PTR(-EIO);\n}\n\nstatic int __sysv_write_inode(struct inode *inode, int wait)\n{\n\tstruct super_block * sb = inode->i_sb;\n\tstruct sysv_sb_info * sbi = SYSV_SB(sb);\n\tstruct buffer_head * bh;\n\tstruct sysv_inode * raw_inode;\n\tstruct sysv_inode_info * si;\n\tunsigned int ino, block;\n\tint err = 0;\n\n\tino = inode->i_ino;\n\tif (!ino || ino > sbi->s_ninodes) {\n\t\tprintk(\"Bad inode number on dev %s: %d is out of range\\n\",\n\t\t       inode->i_sb->s_id, ino);\n\t\treturn -EIO;\n\t}\n\traw_inode = sysv_raw_inode(sb, ino, &bh);\n\tif (!raw_inode) {\n\t\tprintk(\"unable to read i-node block\\n\");\n\t\treturn -EIO;\n\t}\n\n\traw_inode->i_mode = cpu_to_fs16(sbi, inode->i_mode);\n\traw_inode->i_uid = cpu_to_fs16(sbi, fs_high2lowuid(i_uid_read(inode)));\n\traw_inode->i_gid = cpu_to_fs16(sbi, fs_high2lowgid(i_gid_read(inode)));\n\traw_inode->i_nlink = cpu_to_fs16(sbi, inode->i_nlink);\n\traw_inode->i_size = cpu_to_fs32(sbi, inode->i_size);\n\traw_inode->i_atime = cpu_to_fs32(sbi, inode->i_atime.tv_sec);\n\traw_inode->i_mtime = cpu_to_fs32(sbi, inode->i_mtime.tv_sec);\n\traw_inode->i_ctime = cpu_to_fs32(sbi, inode_get_ctime(inode).tv_sec);\n\n\tsi = SYSV_I(inode);\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))\n\t\tsi->i_data[0] = cpu_to_fs32(sbi, old_encode_dev(inode->i_rdev));\n\tfor (block = 0; block < 10+1+1+1; block++)\n\t\twrite3byte(sbi, (u8 *)&si->i_data[block],\n\t\t\t&raw_inode->i_data[3*block]);\n\tmark_buffer_dirty(bh);\n\tif (wait) {\n                sync_dirty_buffer(bh);\n                if (buffer_req(bh) && !buffer_uptodate(bh)) {\n                        printk (\"IO error syncing sysv inode [%s:%08x]\\n\",\n                                sb->s_id, ino);\n                        err = -EIO;\n                }\n        }\n\tbrelse(bh);\n\treturn err;\n}\n\nint sysv_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\treturn __sysv_write_inode(inode, wbc->sync_mode == WB_SYNC_ALL);\n}\n\nint sysv_sync_inode(struct inode *inode)\n{\n\treturn __sysv_write_inode(inode, 1);\n}\n\nstatic void sysv_evict_inode(struct inode *inode)\n{\n\ttruncate_inode_pages_final(&inode->i_data);\n\tif (!inode->i_nlink) {\n\t\tinode->i_size = 0;\n\t\tsysv_truncate(inode);\n\t}\n\tinvalidate_inode_buffers(inode);\n\tclear_inode(inode);\n\tif (!inode->i_nlink)\n\t\tsysv_free_inode(inode);\n}\n\nstatic struct kmem_cache *sysv_inode_cachep;\n\nstatic struct inode *sysv_alloc_inode(struct super_block *sb)\n{\n\tstruct sysv_inode_info *si;\n\n\tsi = alloc_inode_sb(sb, sysv_inode_cachep, GFP_KERNEL);\n\tif (!si)\n\t\treturn NULL;\n\treturn &si->vfs_inode;\n}\n\nstatic void sysv_free_in_core_inode(struct inode *inode)\n{\n\tkmem_cache_free(sysv_inode_cachep, SYSV_I(inode));\n}\n\nstatic void init_once(void *p)\n{\n\tstruct sysv_inode_info *si = (struct sysv_inode_info *)p;\n\n\tinode_init_once(&si->vfs_inode);\n}\n\nconst struct super_operations sysv_sops = {\n\t.alloc_inode\t= sysv_alloc_inode,\n\t.free_inode\t= sysv_free_in_core_inode,\n\t.write_inode\t= sysv_write_inode,\n\t.evict_inode\t= sysv_evict_inode,\n\t.put_super\t= sysv_put_super,\n\t.sync_fs\t= sysv_sync_fs,\n\t.remount_fs\t= sysv_remount,\n\t.statfs\t\t= sysv_statfs,\n};\n\nint __init sysv_init_icache(void)\n{\n\tsysv_inode_cachep = kmem_cache_create(\"sysv_inode_cache\",\n\t\t\tsizeof(struct sysv_inode_info), 0,\n\t\t\tSLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD|SLAB_ACCOUNT,\n\t\t\tinit_once);\n\tif (!sysv_inode_cachep)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nvoid sysv_destroy_icache(void)\n{\n\t \n\trcu_barrier();\n\tkmem_cache_destroy(sysv_inode_cachep);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}