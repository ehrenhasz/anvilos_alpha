{
  "module_name": "sysv.h",
  "hash_id": "3b5d7628626a349f4058cfb7b88a6d2427751cddf77ec8f91a34be541c87b9eb",
  "original_prompt": "Ingested from linux-6.6.14/fs/sysv/sysv.h",
  "human_readable_source": " \n#ifndef _SYSV_H\n#define _SYSV_H\n\n#include <linux/buffer_head.h>\n\ntypedef __u16 __bitwise __fs16;\ntypedef __u32 __bitwise __fs32;\n\n#include <linux/sysv_fs.h>\n\n \n\nstruct sysv_sb_info {\n\tstruct super_block *s_sb;\t \n\tint\t       s_type;\t\t \n\tchar\t       s_bytesex;\t \n\tunsigned int   s_inodes_per_block;\t \n\tunsigned int   s_inodes_per_block_1;\t \n\tunsigned int   s_inodes_per_block_bits;\t \n\tunsigned int   s_ind_per_block;\t\t \n\tunsigned int   s_ind_per_block_bits;\t \n\tunsigned int   s_ind_per_block_2;\t \n\tunsigned int   s_toobig_block;\t\t \n\tunsigned int   s_block_base;\t \n\tunsigned short s_fic_size;\t \n\tunsigned short s_flc_size;\t \n\t \n\tstruct buffer_head *s_bh1;\n\tstruct buffer_head *s_bh2;\n\t \n\tchar *         s_sbd1;\t\t \n\tchar *         s_sbd2;\t\t \n\t__fs16         *s_sb_fic_count;\t \n        sysv_ino_t     *s_sb_fic_inodes;  \n\t__fs16         *s_sb_total_free_inodes;  \n\t__fs16         *s_bcache_count;\t \n\tsysv_zone_t    *s_bcache;\t \n\t__fs32         *s_free_blocks;\t \n\t__fs32         *s_sb_time;\t \n\t__fs32         *s_sb_state;\t \n\t \n\tu32            s_firstinodezone;  \n\tu32            s_firstdatazone;\t \n\tu32            s_ninodes;\t \n\tu32            s_ndatazones;\t \n\tu32            s_nzones;\t \n\tu16\t       s_namelen;        \n\tint\t       s_forced_ro;\n\tstruct mutex s_lock;\n};\n\n \nstruct sysv_inode_info {\n\t__fs32\t\ti_data[13];\n\tu32\t\ti_dir_start_lookup;\n\tstruct inode\tvfs_inode;\n};\n\n\nstatic inline struct sysv_inode_info *SYSV_I(struct inode *inode)\n{\n\treturn container_of(inode, struct sysv_inode_info, vfs_inode);\n}\n\nstatic inline struct sysv_sb_info *SYSV_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}\n\n\n \nenum {\n\tFSTYPE_NONE = 0,\n\tFSTYPE_XENIX,\n\tFSTYPE_SYSV4,\n\tFSTYPE_SYSV2,\n\tFSTYPE_COH,\n\tFSTYPE_V7,\n\tFSTYPE_AFS,\n\tFSTYPE_END,\n};\n\n#define SYSV_MAGIC_BASE\t\t0x012FF7B3\n\n#define XENIX_SUPER_MAGIC\t(SYSV_MAGIC_BASE+FSTYPE_XENIX)\n#define SYSV4_SUPER_MAGIC\t(SYSV_MAGIC_BASE+FSTYPE_SYSV4)\n#define SYSV2_SUPER_MAGIC\t(SYSV_MAGIC_BASE+FSTYPE_SYSV2)\n#define COH_SUPER_MAGIC\t\t(SYSV_MAGIC_BASE+FSTYPE_COH)\n\n\n \nenum {\n\tXENIX_LINK_MAX\t=\t126,\t \n\tSYSV_LINK_MAX\t=\t126,\t \n\tV7_LINK_MAX     =\t126,\t \n\tCOH_LINK_MAX\t=\t10000,\n};\n\n\nstatic inline void dirty_sb(struct super_block *sb)\n{\n\tstruct sysv_sb_info *sbi = SYSV_SB(sb);\n\n\tmark_buffer_dirty(sbi->s_bh1);\n\tif (sbi->s_bh1 != sbi->s_bh2)\n\t\tmark_buffer_dirty(sbi->s_bh2);\n}\n\n\n \nextern struct sysv_inode *sysv_raw_inode(struct super_block *, unsigned,\n\t\t\tstruct buffer_head **);\nextern struct inode * sysv_new_inode(const struct inode *, umode_t);\nextern void sysv_free_inode(struct inode *);\nextern unsigned long sysv_count_free_inodes(struct super_block *);\n\n \nextern sysv_zone_t sysv_new_block(struct super_block *);\nextern void sysv_free_block(struct super_block *, sysv_zone_t);\nextern unsigned long sysv_count_free_blocks(struct super_block *);\n\n \nextern void sysv_truncate(struct inode *);\nextern int sysv_prepare_chunk(struct page *page, loff_t pos, unsigned len);\n\n \nextern struct inode *sysv_iget(struct super_block *, unsigned int);\nextern int sysv_write_inode(struct inode *, struct writeback_control *wbc);\nextern int sysv_sync_inode(struct inode *);\nextern void sysv_set_inode(struct inode *, dev_t);\nextern int sysv_getattr(struct mnt_idmap *, const struct path *,\n\t\t\tstruct kstat *, u32, unsigned int);\nextern int sysv_init_icache(void);\nextern void sysv_destroy_icache(void);\n\n\n \nextern struct sysv_dir_entry *sysv_find_entry(struct dentry *, struct page **);\nextern int sysv_add_link(struct dentry *, struct inode *);\nextern int sysv_delete_entry(struct sysv_dir_entry *, struct page *);\nextern int sysv_make_empty(struct inode *, struct inode *);\nextern int sysv_empty_dir(struct inode *);\nextern int sysv_set_link(struct sysv_dir_entry *, struct page *,\n\t\t\tstruct inode *);\nextern struct sysv_dir_entry *sysv_dotdot(struct inode *, struct page **);\nextern ino_t sysv_inode_by_name(struct dentry *);\n\n\nextern const struct inode_operations sysv_file_inode_operations;\nextern const struct inode_operations sysv_dir_inode_operations;\nextern const struct file_operations sysv_file_operations;\nextern const struct file_operations sysv_dir_operations;\nextern const struct address_space_operations sysv_aops;\nextern const struct super_operations sysv_sops;\n\n\nenum {\n\tBYTESEX_LE,\n\tBYTESEX_PDP,\n\tBYTESEX_BE,\n};\n\nstatic inline u32 PDP_swab(u32 x)\n{\n#ifdef __LITTLE_ENDIAN\n\treturn ((x & 0xffff) << 16) | ((x & 0xffff0000) >> 16);\n#else\n#ifdef __BIG_ENDIAN\n\treturn ((x & 0xff00ff) << 8) | ((x & 0xff00ff00) >> 8);\n#else\n#error BYTESEX\n#endif\n#endif\n}\n\nstatic inline __u32 fs32_to_cpu(struct sysv_sb_info *sbi, __fs32 n)\n{\n\tif (sbi->s_bytesex == BYTESEX_PDP)\n\t\treturn PDP_swab((__force __u32)n);\n\telse if (sbi->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}\n\nstatic inline __fs32 cpu_to_fs32(struct sysv_sb_info *sbi, __u32 n)\n{\n\tif (sbi->s_bytesex == BYTESEX_PDP)\n\t\treturn (__force __fs32)PDP_swab(n);\n\telse if (sbi->s_bytesex == BYTESEX_LE)\n\t\treturn (__force __fs32)cpu_to_le32(n);\n\telse\n\t\treturn (__force __fs32)cpu_to_be32(n);\n}\n\nstatic inline __fs32 fs32_add(struct sysv_sb_info *sbi, __fs32 *n, int d)\n{\n\tif (sbi->s_bytesex == BYTESEX_PDP)\n\t\t*(__u32*)n = PDP_swab(PDP_swab(*(__u32*)n)+d);\n\telse if (sbi->s_bytesex == BYTESEX_LE)\n\t\tle32_add_cpu((__le32 *)n, d);\n\telse\n\t\tbe32_add_cpu((__be32 *)n, d);\n\treturn *n;\n}\n\nstatic inline __u16 fs16_to_cpu(struct sysv_sb_info *sbi, __fs16 n)\n{\n\tif (sbi->s_bytesex != BYTESEX_BE)\n\t\treturn le16_to_cpu((__force __le16)n);\n\telse\n\t\treturn be16_to_cpu((__force __be16)n);\n}\n\nstatic inline __fs16 cpu_to_fs16(struct sysv_sb_info *sbi, __u16 n)\n{\n\tif (sbi->s_bytesex != BYTESEX_BE)\n\t\treturn (__force __fs16)cpu_to_le16(n);\n\telse\n\t\treturn (__force __fs16)cpu_to_be16(n);\n}\n\nstatic inline __fs16 fs16_add(struct sysv_sb_info *sbi, __fs16 *n, int d)\n{\n\tif (sbi->s_bytesex != BYTESEX_BE)\n\t\tle16_add_cpu((__le16 *)n, d);\n\telse\n\t\tbe16_add_cpu((__be16 *)n, d);\n\treturn *n;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}