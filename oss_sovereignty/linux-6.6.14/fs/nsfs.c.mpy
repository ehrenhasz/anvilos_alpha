{
  "module_name": "nsfs.c",
  "hash_id": "bcbeaf4dee62aa4c89c4192ed52d8cb52efcea1d683604dbc39570100ef3366e",
  "original_prompt": "Ingested from linux-6.6.14/fs/nsfs.c",
  "human_readable_source": "\n#include <linux/mount.h>\n#include <linux/pseudo_fs.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/proc_fs.h>\n#include <linux/proc_ns.h>\n#include <linux/magic.h>\n#include <linux/ktime.h>\n#include <linux/seq_file.h>\n#include <linux/user_namespace.h>\n#include <linux/nsfs.h>\n#include <linux/uaccess.h>\n\n#include \"internal.h\"\n\nstatic struct vfsmount *nsfs_mnt;\n\nstatic long ns_ioctl(struct file *filp, unsigned int ioctl,\n\t\t\tunsigned long arg);\nstatic const struct file_operations ns_file_operations = {\n\t.llseek\t\t= no_llseek,\n\t.unlocked_ioctl = ns_ioctl,\n\t.compat_ioctl   = compat_ptr_ioctl,\n};\n\nstatic char *ns_dname(struct dentry *dentry, char *buffer, int buflen)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tconst struct proc_ns_operations *ns_ops = dentry->d_fsdata;\n\n\treturn dynamic_dname(buffer, buflen, \"%s:[%lu]\",\n\t\tns_ops->name, inode->i_ino);\n}\n\nstatic void ns_prune_dentry(struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tif (inode) {\n\t\tstruct ns_common *ns = inode->i_private;\n\t\tatomic_long_set(&ns->stashed, 0);\n\t}\n}\n\nconst struct dentry_operations ns_dentry_operations =\n{\n\t.d_prune\t= ns_prune_dentry,\n\t.d_delete\t= always_delete_dentry,\n\t.d_dname\t= ns_dname,\n};\n\nstatic void nsfs_evict(struct inode *inode)\n{\n\tstruct ns_common *ns = inode->i_private;\n\tclear_inode(inode);\n\tns->ops->put(ns);\n}\n\nstatic int __ns_get_path(struct path *path, struct ns_common *ns)\n{\n\tstruct vfsmount *mnt = nsfs_mnt;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tunsigned long d;\n\n\trcu_read_lock();\n\td = atomic_long_read(&ns->stashed);\n\tif (!d)\n\t\tgoto slow;\n\tdentry = (struct dentry *)d;\n\tif (!lockref_get_not_dead(&dentry->d_lockref))\n\t\tgoto slow;\n\trcu_read_unlock();\n\tns->ops->put(ns);\ngot_it:\n\tpath->mnt = mntget(mnt);\n\tpath->dentry = dentry;\n\treturn 0;\nslow:\n\trcu_read_unlock();\n\tinode = new_inode_pseudo(mnt->mnt_sb);\n\tif (!inode) {\n\t\tns->ops->put(ns);\n\t\treturn -ENOMEM;\n\t}\n\tinode->i_ino = ns->inum;\n\tinode->i_mtime = inode->i_atime = inode_set_ctime_current(inode);\n\tinode->i_flags |= S_IMMUTABLE;\n\tinode->i_mode = S_IFREG | S_IRUGO;\n\tinode->i_fop = &ns_file_operations;\n\tinode->i_private = ns;\n\n\tdentry = d_alloc_anon(mnt->mnt_sb);\n\tif (!dentry) {\n\t\tiput(inode);\n\t\treturn -ENOMEM;\n\t}\n\td_instantiate(dentry, inode);\n\tdentry->d_fsdata = (void *)ns->ops;\n\td = atomic_long_cmpxchg(&ns->stashed, 0, (unsigned long)dentry);\n\tif (d) {\n\t\td_delete(dentry);\t \n\t\tdput(dentry);\n\t\tcpu_relax();\n\t\treturn -EAGAIN;\n\t}\n\tgoto got_it;\n}\n\nint ns_get_path_cb(struct path *path, ns_get_path_helper_t *ns_get_cb,\n\t\t     void *private_data)\n{\n\tint ret;\n\n\tdo {\n\t\tstruct ns_common *ns = ns_get_cb(private_data);\n\t\tif (!ns)\n\t\t\treturn -ENOENT;\n\t\tret = __ns_get_path(path, ns);\n\t} while (ret == -EAGAIN);\n\n\treturn ret;\n}\n\nstruct ns_get_path_task_args {\n\tconst struct proc_ns_operations *ns_ops;\n\tstruct task_struct *task;\n};\n\nstatic struct ns_common *ns_get_path_task(void *private_data)\n{\n\tstruct ns_get_path_task_args *args = private_data;\n\n\treturn args->ns_ops->get(args->task);\n}\n\nint ns_get_path(struct path *path, struct task_struct *task,\n\t\t  const struct proc_ns_operations *ns_ops)\n{\n\tstruct ns_get_path_task_args args = {\n\t\t.ns_ops\t= ns_ops,\n\t\t.task\t= task,\n\t};\n\n\treturn ns_get_path_cb(path, ns_get_path_task, &args);\n}\n\nint open_related_ns(struct ns_common *ns,\n\t\t   struct ns_common *(*get_ns)(struct ns_common *ns))\n{\n\tstruct path path = {};\n\tstruct file *f;\n\tint err;\n\tint fd;\n\n\tfd = get_unused_fd_flags(O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn fd;\n\n\tdo {\n\t\tstruct ns_common *relative;\n\n\t\trelative = get_ns(ns);\n\t\tif (IS_ERR(relative)) {\n\t\t\tput_unused_fd(fd);\n\t\t\treturn PTR_ERR(relative);\n\t\t}\n\n\t\terr = __ns_get_path(&path, relative);\n\t} while (err == -EAGAIN);\n\n\tif (err) {\n\t\tput_unused_fd(fd);\n\t\treturn err;\n\t}\n\n\tf = dentry_open(&path, O_RDONLY, current_cred());\n\tpath_put(&path);\n\tif (IS_ERR(f)) {\n\t\tput_unused_fd(fd);\n\t\tfd = PTR_ERR(f);\n\t} else\n\t\tfd_install(fd, f);\n\n\treturn fd;\n}\nEXPORT_SYMBOL_GPL(open_related_ns);\n\nstatic long ns_ioctl(struct file *filp, unsigned int ioctl,\n\t\t\tunsigned long arg)\n{\n\tstruct user_namespace *user_ns;\n\tstruct ns_common *ns = get_proc_ns(file_inode(filp));\n\tuid_t __user *argp;\n\tuid_t uid;\n\n\tswitch (ioctl) {\n\tcase NS_GET_USERNS:\n\t\treturn open_related_ns(ns, ns_get_owner);\n\tcase NS_GET_PARENT:\n\t\tif (!ns->ops->get_parent)\n\t\t\treturn -EINVAL;\n\t\treturn open_related_ns(ns, ns->ops->get_parent);\n\tcase NS_GET_NSTYPE:\n\t\treturn ns->ops->type;\n\tcase NS_GET_OWNER_UID:\n\t\tif (ns->ops->type != CLONE_NEWUSER)\n\t\t\treturn -EINVAL;\n\t\tuser_ns = container_of(ns, struct user_namespace, ns);\n\t\targp = (uid_t __user *) arg;\n\t\tuid = from_kuid_munged(current_user_ns(), user_ns->owner);\n\t\treturn put_user(uid, argp);\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}\n\nint ns_get_name(char *buf, size_t size, struct task_struct *task,\n\t\t\tconst struct proc_ns_operations *ns_ops)\n{\n\tstruct ns_common *ns;\n\tint res = -ENOENT;\n\tconst char *name;\n\tns = ns_ops->get(task);\n\tif (ns) {\n\t\tname = ns_ops->real_ns_name ? : ns_ops->name;\n\t\tres = snprintf(buf, size, \"%s:[%u]\", name, ns->inum);\n\t\tns_ops->put(ns);\n\t}\n\treturn res;\n}\n\nbool proc_ns_file(const struct file *file)\n{\n\treturn file->f_op == &ns_file_operations;\n}\n\n \nbool ns_match(const struct ns_common *ns, dev_t dev, ino_t ino)\n{\n\treturn (ns->inum == ino) && (nsfs_mnt->mnt_sb->s_dev == dev);\n}\n\n\nstatic int nsfs_show_path(struct seq_file *seq, struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tconst struct proc_ns_operations *ns_ops = dentry->d_fsdata;\n\n\tseq_printf(seq, \"%s:[%lu]\", ns_ops->name, inode->i_ino);\n\treturn 0;\n}\n\nstatic const struct super_operations nsfs_ops = {\n\t.statfs = simple_statfs,\n\t.evict_inode = nsfs_evict,\n\t.show_path = nsfs_show_path,\n};\n\nstatic int nsfs_init_fs_context(struct fs_context *fc)\n{\n\tstruct pseudo_fs_context *ctx = init_pseudo(fc, NSFS_MAGIC);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\tctx->ops = &nsfs_ops;\n\tctx->dops = &ns_dentry_operations;\n\treturn 0;\n}\n\nstatic struct file_system_type nsfs = {\n\t.name = \"nsfs\",\n\t.init_fs_context = nsfs_init_fs_context,\n\t.kill_sb = kill_anon_super,\n};\n\nvoid __init nsfs_init(void)\n{\n\tnsfs_mnt = kern_mount(&nsfs);\n\tif (IS_ERR(nsfs_mnt))\n\t\tpanic(\"can't set nsfs up\\n\");\n\tnsfs_mnt->mnt_sb->s_flags &= ~SB_NOUSER;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}