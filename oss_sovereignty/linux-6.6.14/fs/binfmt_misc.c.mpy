{
  "module_name": "binfmt_misc.c",
  "hash_id": "8c6732f75055104c2ae1b610da225e44ee17038e0fb43d1a268ade3797e8cdf7",
  "original_prompt": "Ingested from linux-6.6.14/fs/binfmt_misc.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/binfmts.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/string_helpers.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/fs_context.h>\n#include <linux/syscalls.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n\n#include \"internal.h\"\n\n#ifdef DEBUG\n# define USE_DEBUG 1\n#else\n# define USE_DEBUG 0\n#endif\n\nenum {\n\tVERBOSE_STATUS = 1  \n};\n\nstatic LIST_HEAD(entries);\nstatic int enabled = 1;\n\nenum {Enabled, Magic};\n#define MISC_FMT_PRESERVE_ARGV0 (1UL << 31)\n#define MISC_FMT_OPEN_BINARY (1UL << 30)\n#define MISC_FMT_CREDENTIALS (1UL << 29)\n#define MISC_FMT_OPEN_FILE (1UL << 28)\n\ntypedef struct {\n\tstruct list_head list;\n\tunsigned long flags;\t\t \n\tint offset;\t\t\t \n\tint size;\t\t\t \n\tchar *magic;\t\t\t \n\tchar *mask;\t\t\t \n\tconst char *interpreter;\t \n\tchar *name;\n\tstruct dentry *dentry;\n\tstruct file *interp_file;\n} Node;\n\nstatic DEFINE_RWLOCK(entries_lock);\nstatic struct file_system_type bm_fs_type;\nstatic struct vfsmount *bm_mnt;\nstatic int entry_count;\n\n \n#define MAX_REGISTER_LENGTH 1920\n\n \nstatic Node *check_file(struct linux_binprm *bprm)\n{\n\tchar *p = strrchr(bprm->interp, '.');\n\tstruct list_head *l;\n\n\t \n\tlist_for_each(l, &entries) {\n\t\tNode *e = list_entry(l, Node, list);\n\t\tchar *s;\n\t\tint j;\n\n\t\t \n\t\tif (!test_bit(Enabled, &e->flags))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!test_bit(Magic, &e->flags)) {\n\t\t\tif (p && !strcmp(e->magic, p + 1))\n\t\t\t\treturn e;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\ts = bprm->buf + e->offset;\n\t\tif (e->mask) {\n\t\t\tfor (j = 0; j < e->size; j++)\n\t\t\t\tif ((*s++ ^ e->magic[j]) & e->mask[j])\n\t\t\t\t\tbreak;\n\t\t} else {\n\t\t\tfor (j = 0; j < e->size; j++)\n\t\t\t\tif ((*s++ ^ e->magic[j]))\n\t\t\t\t\tbreak;\n\t\t}\n\t\tif (j == e->size)\n\t\t\treturn e;\n\t}\n\treturn NULL;\n}\n\n \nstatic int load_misc_binary(struct linux_binprm *bprm)\n{\n\tNode *fmt;\n\tstruct file *interp_file = NULL;\n\tint retval;\n\n\tretval = -ENOEXEC;\n\tif (!enabled)\n\t\treturn retval;\n\n\t \n\tread_lock(&entries_lock);\n\tfmt = check_file(bprm);\n\tif (fmt)\n\t\tdget(fmt->dentry);\n\tread_unlock(&entries_lock);\n\tif (!fmt)\n\t\treturn retval;\n\n\t \n\tretval = -ENOENT;\n\tif (bprm->interp_flags & BINPRM_FLAGS_PATH_INACCESSIBLE)\n\t\tgoto ret;\n\n\tif (fmt->flags & MISC_FMT_PRESERVE_ARGV0) {\n\t\tbprm->interp_flags |= BINPRM_FLAGS_PRESERVE_ARGV0;\n\t} else {\n\t\tretval = remove_arg_zero(bprm);\n\t\tif (retval)\n\t\t\tgoto ret;\n\t}\n\n\tif (fmt->flags & MISC_FMT_OPEN_BINARY)\n\t\tbprm->have_execfd = 1;\n\n\t \n\tretval = copy_string_kernel(bprm->interp, bprm);\n\tif (retval < 0)\n\t\tgoto ret;\n\tbprm->argc++;\n\n\t \n\tretval = copy_string_kernel(fmt->interpreter, bprm);\n\tif (retval < 0)\n\t\tgoto ret;\n\tbprm->argc++;\n\n\t \n\tretval = bprm_change_interp(fmt->interpreter, bprm);\n\tif (retval < 0)\n\t\tgoto ret;\n\n\tif (fmt->flags & MISC_FMT_OPEN_FILE) {\n\t\tinterp_file = file_clone_open(fmt->interp_file);\n\t\tif (!IS_ERR(interp_file))\n\t\t\tdeny_write_access(interp_file);\n\t} else {\n\t\tinterp_file = open_exec(fmt->interpreter);\n\t}\n\tretval = PTR_ERR(interp_file);\n\tif (IS_ERR(interp_file))\n\t\tgoto ret;\n\n\tbprm->interpreter = interp_file;\n\tif (fmt->flags & MISC_FMT_CREDENTIALS)\n\t\tbprm->execfd_creds = 1;\n\n\tretval = 0;\nret:\n\tdput(fmt->dentry);\n\treturn retval;\n}\n\n \n\n \nstatic char *scanarg(char *s, char del)\n{\n\tchar c;\n\n\twhile ((c = *s++) != del) {\n\t\tif (c == '\\\\' && *s == 'x') {\n\t\t\ts++;\n\t\t\tif (!isxdigit(*s++))\n\t\t\t\treturn NULL;\n\t\t\tif (!isxdigit(*s++))\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\ts[-1] ='\\0';\n\treturn s;\n}\n\nstatic char *check_special_flags(char *sfs, Node *e)\n{\n\tchar *p = sfs;\n\tint cont = 1;\n\n\t \n\twhile (cont) {\n\t\tswitch (*p) {\n\t\tcase 'P':\n\t\t\tpr_debug(\"register: flag: P (preserve argv0)\\n\");\n\t\t\tp++;\n\t\t\te->flags |= MISC_FMT_PRESERVE_ARGV0;\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tpr_debug(\"register: flag: O (open binary)\\n\");\n\t\t\tp++;\n\t\t\te->flags |= MISC_FMT_OPEN_BINARY;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tpr_debug(\"register: flag: C (preserve creds)\\n\");\n\t\t\tp++;\n\t\t\t \n\t\t\te->flags |= (MISC_FMT_CREDENTIALS |\n\t\t\t\t\tMISC_FMT_OPEN_BINARY);\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tpr_debug(\"register: flag: F: open interpreter file now\\n\");\n\t\t\tp++;\n\t\t\te->flags |= MISC_FMT_OPEN_FILE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcont = 0;\n\t\t}\n\t}\n\n\treturn p;\n}\n\n \nstatic Node *create_entry(const char __user *buffer, size_t count)\n{\n\tNode *e;\n\tint memsize, err;\n\tchar *buf, *p;\n\tchar del;\n\n\tpr_debug(\"register: received %zu bytes\\n\", count);\n\n\t \n\terr = -EINVAL;\n\tif ((count < 11) || (count > MAX_REGISTER_LENGTH))\n\t\tgoto out;\n\n\terr = -ENOMEM;\n\tmemsize = sizeof(Node) + count + 8;\n\te = kmalloc(memsize, GFP_KERNEL);\n\tif (!e)\n\t\tgoto out;\n\n\tp = buf = (char *)e + sizeof(Node);\n\n\tmemset(e, 0, sizeof(Node));\n\tif (copy_from_user(buf, buffer, count))\n\t\tgoto efault;\n\n\tdel = *p++;\t \n\n\tpr_debug(\"register: delim: %#x {%c}\\n\", del, del);\n\n\t \n\tmemset(buf + count, del, 8);\n\n\t \n\te->name = p;\n\tp = strchr(p, del);\n\tif (!p)\n\t\tgoto einval;\n\t*p++ = '\\0';\n\tif (!e->name[0] ||\n\t    !strcmp(e->name, \".\") ||\n\t    !strcmp(e->name, \"..\") ||\n\t    strchr(e->name, '/'))\n\t\tgoto einval;\n\n\tpr_debug(\"register: name: {%s}\\n\", e->name);\n\n\t \n\tswitch (*p++) {\n\tcase 'E':\n\t\tpr_debug(\"register: type: E (extension)\\n\");\n\t\te->flags = 1 << Enabled;\n\t\tbreak;\n\tcase 'M':\n\t\tpr_debug(\"register: type: M (magic)\\n\");\n\t\te->flags = (1 << Enabled) | (1 << Magic);\n\t\tbreak;\n\tdefault:\n\t\tgoto einval;\n\t}\n\tif (*p++ != del)\n\t\tgoto einval;\n\n\tif (test_bit(Magic, &e->flags)) {\n\t\t \n\t\tchar *s;\n\n\t\t \n\t\ts = strchr(p, del);\n\t\tif (!s)\n\t\t\tgoto einval;\n\t\t*s = '\\0';\n\t\tif (p != s) {\n\t\t\tint r = kstrtoint(p, 10, &e->offset);\n\t\t\tif (r != 0 || e->offset < 0)\n\t\t\t\tgoto einval;\n\t\t}\n\t\tp = s;\n\t\tif (*p++)\n\t\t\tgoto einval;\n\t\tpr_debug(\"register: offset: %#x\\n\", e->offset);\n\n\t\t \n\t\te->magic = p;\n\t\tp = scanarg(p, del);\n\t\tif (!p)\n\t\t\tgoto einval;\n\t\tif (!e->magic[0])\n\t\t\tgoto einval;\n\t\tif (USE_DEBUG)\n\t\t\tprint_hex_dump_bytes(\n\t\t\t\tKBUILD_MODNAME \": register: magic[raw]: \",\n\t\t\t\tDUMP_PREFIX_NONE, e->magic, p - e->magic);\n\n\t\t \n\t\te->mask = p;\n\t\tp = scanarg(p, del);\n\t\tif (!p)\n\t\t\tgoto einval;\n\t\tif (!e->mask[0]) {\n\t\t\te->mask = NULL;\n\t\t\tpr_debug(\"register:  mask[raw]: none\\n\");\n\t\t} else if (USE_DEBUG)\n\t\t\tprint_hex_dump_bytes(\n\t\t\t\tKBUILD_MODNAME \": register:  mask[raw]: \",\n\t\t\t\tDUMP_PREFIX_NONE, e->mask, p - e->mask);\n\n\t\t \n\t\te->size = string_unescape_inplace(e->magic, UNESCAPE_HEX);\n\t\tif (e->mask &&\n\t\t    string_unescape_inplace(e->mask, UNESCAPE_HEX) != e->size)\n\t\t\tgoto einval;\n\t\tif (e->size > BINPRM_BUF_SIZE ||\n\t\t    BINPRM_BUF_SIZE - e->size < e->offset)\n\t\t\tgoto einval;\n\t\tpr_debug(\"register: magic/mask length: %i\\n\", e->size);\n\t\tif (USE_DEBUG) {\n\t\t\tprint_hex_dump_bytes(\n\t\t\t\tKBUILD_MODNAME \": register: magic[decoded]: \",\n\t\t\t\tDUMP_PREFIX_NONE, e->magic, e->size);\n\n\t\t\tif (e->mask) {\n\t\t\t\tint i;\n\t\t\t\tchar *masked = kmalloc(e->size, GFP_KERNEL);\n\n\t\t\t\tprint_hex_dump_bytes(\n\t\t\t\t\tKBUILD_MODNAME \": register:  mask[decoded]: \",\n\t\t\t\t\tDUMP_PREFIX_NONE, e->mask, e->size);\n\n\t\t\t\tif (masked) {\n\t\t\t\t\tfor (i = 0; i < e->size; ++i)\n\t\t\t\t\t\tmasked[i] = e->magic[i] & e->mask[i];\n\t\t\t\t\tprint_hex_dump_bytes(\n\t\t\t\t\t\tKBUILD_MODNAME \": register:  magic[masked]: \",\n\t\t\t\t\t\tDUMP_PREFIX_NONE, masked, e->size);\n\n\t\t\t\t\tkfree(masked);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\n\t\t \n\t\tp = strchr(p, del);\n\t\tif (!p)\n\t\t\tgoto einval;\n\t\t*p++ = '\\0';\n\n\t\t \n\t\te->magic = p;\n\t\tp = strchr(p, del);\n\t\tif (!p)\n\t\t\tgoto einval;\n\t\t*p++ = '\\0';\n\t\tif (!e->magic[0] || strchr(e->magic, '/'))\n\t\t\tgoto einval;\n\t\tpr_debug(\"register: extension: {%s}\\n\", e->magic);\n\n\t\t \n\t\tp = strchr(p, del);\n\t\tif (!p)\n\t\t\tgoto einval;\n\t\t*p++ = '\\0';\n\t}\n\n\t \n\te->interpreter = p;\n\tp = strchr(p, del);\n\tif (!p)\n\t\tgoto einval;\n\t*p++ = '\\0';\n\tif (!e->interpreter[0])\n\t\tgoto einval;\n\tpr_debug(\"register: interpreter: {%s}\\n\", e->interpreter);\n\n\t \n\tp = check_special_flags(p, e);\n\tif (*p == '\\n')\n\t\tp++;\n\tif (p != buf + count)\n\t\tgoto einval;\n\n\treturn e;\n\nout:\n\treturn ERR_PTR(err);\n\nefault:\n\tkfree(e);\n\treturn ERR_PTR(-EFAULT);\neinval:\n\tkfree(e);\n\treturn ERR_PTR(-EINVAL);\n}\n\n \nstatic int parse_command(const char __user *buffer, size_t count)\n{\n\tchar s[4];\n\n\tif (count > 3)\n\t\treturn -EINVAL;\n\tif (copy_from_user(s, buffer, count))\n\t\treturn -EFAULT;\n\tif (!count)\n\t\treturn 0;\n\tif (s[count - 1] == '\\n')\n\t\tcount--;\n\tif (count == 1 && s[0] == '0')\n\t\treturn 1;\n\tif (count == 1 && s[0] == '1')\n\t\treturn 2;\n\tif (count == 2 && s[0] == '-' && s[1] == '1')\n\t\treturn 3;\n\treturn -EINVAL;\n}\n\n \n\nstatic void entry_status(Node *e, char *page)\n{\n\tchar *dp = page;\n\tconst char *status = \"disabled\";\n\n\tif (test_bit(Enabled, &e->flags))\n\t\tstatus = \"enabled\";\n\n\tif (!VERBOSE_STATUS) {\n\t\tsprintf(page, \"%s\\n\", status);\n\t\treturn;\n\t}\n\n\tdp += sprintf(dp, \"%s\\ninterpreter %s\\n\", status, e->interpreter);\n\n\t \n\tdp += sprintf(dp, \"flags: \");\n\tif (e->flags & MISC_FMT_PRESERVE_ARGV0)\n\t\t*dp++ = 'P';\n\tif (e->flags & MISC_FMT_OPEN_BINARY)\n\t\t*dp++ = 'O';\n\tif (e->flags & MISC_FMT_CREDENTIALS)\n\t\t*dp++ = 'C';\n\tif (e->flags & MISC_FMT_OPEN_FILE)\n\t\t*dp++ = 'F';\n\t*dp++ = '\\n';\n\n\tif (!test_bit(Magic, &e->flags)) {\n\t\tsprintf(dp, \"extension .%s\\n\", e->magic);\n\t} else {\n\t\tdp += sprintf(dp, \"offset %i\\nmagic \", e->offset);\n\t\tdp = bin2hex(dp, e->magic, e->size);\n\t\tif (e->mask) {\n\t\t\tdp += sprintf(dp, \"\\nmask \");\n\t\t\tdp = bin2hex(dp, e->mask, e->size);\n\t\t}\n\t\t*dp++ = '\\n';\n\t\t*dp = '\\0';\n\t}\n}\n\nstatic struct inode *bm_get_inode(struct super_block *sb, int mode)\n{\n\tstruct inode *inode = new_inode(sb);\n\n\tif (inode) {\n\t\tinode->i_ino = get_next_ino();\n\t\tinode->i_mode = mode;\n\t\tinode->i_atime = inode->i_mtime = inode_set_ctime_current(inode);\n\t}\n\treturn inode;\n}\n\nstatic void bm_evict_inode(struct inode *inode)\n{\n\tNode *e = inode->i_private;\n\n\tif (e && e->flags & MISC_FMT_OPEN_FILE)\n\t\tfilp_close(e->interp_file, NULL);\n\n\tclear_inode(inode);\n\tkfree(e);\n}\n\nstatic void kill_node(Node *e)\n{\n\tstruct dentry *dentry;\n\n\twrite_lock(&entries_lock);\n\tlist_del_init(&e->list);\n\twrite_unlock(&entries_lock);\n\n\tdentry = e->dentry;\n\tdrop_nlink(d_inode(dentry));\n\td_drop(dentry);\n\tdput(dentry);\n\tsimple_release_fs(&bm_mnt, &entry_count);\n}\n\n \n\nstatic ssize_t\nbm_entry_read(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos)\n{\n\tNode *e = file_inode(file)->i_private;\n\tssize_t res;\n\tchar *page;\n\n\tpage = (char *) __get_free_page(GFP_KERNEL);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tentry_status(e, page);\n\n\tres = simple_read_from_buffer(buf, nbytes, ppos, page, strlen(page));\n\n\tfree_page((unsigned long) page);\n\treturn res;\n}\n\nstatic ssize_t bm_entry_write(struct file *file, const char __user *buffer,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct dentry *root;\n\tNode *e = file_inode(file)->i_private;\n\tint res = parse_command(buffer, count);\n\n\tswitch (res) {\n\tcase 1:\n\t\t \n\t\tclear_bit(Enabled, &e->flags);\n\t\tbreak;\n\tcase 2:\n\t\t \n\t\tset_bit(Enabled, &e->flags);\n\t\tbreak;\n\tcase 3:\n\t\t \n\t\troot = file_inode(file)->i_sb->s_root;\n\t\tinode_lock(d_inode(root));\n\n\t\tif (!list_empty(&e->list))\n\t\t\tkill_node(e);\n\n\t\tinode_unlock(d_inode(root));\n\t\tbreak;\n\tdefault:\n\t\treturn res;\n\t}\n\n\treturn count;\n}\n\nstatic const struct file_operations bm_entry_operations = {\n\t.read\t\t= bm_entry_read,\n\t.write\t\t= bm_entry_write,\n\t.llseek\t\t= default_llseek,\n};\n\n \n\nstatic ssize_t bm_register_write(struct file *file, const char __user *buffer,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tNode *e;\n\tstruct inode *inode;\n\tstruct super_block *sb = file_inode(file)->i_sb;\n\tstruct dentry *root = sb->s_root, *dentry;\n\tint err = 0;\n\tstruct file *f = NULL;\n\n\te = create_entry(buffer, count);\n\n\tif (IS_ERR(e))\n\t\treturn PTR_ERR(e);\n\n\tif (e->flags & MISC_FMT_OPEN_FILE) {\n\t\tf = open_exec(e->interpreter);\n\t\tif (IS_ERR(f)) {\n\t\t\tpr_notice(\"register: failed to install interpreter file %s\\n\",\n\t\t\t\t e->interpreter);\n\t\t\tkfree(e);\n\t\t\treturn PTR_ERR(f);\n\t\t}\n\t\te->interp_file = f;\n\t}\n\n\tinode_lock(d_inode(root));\n\tdentry = lookup_one_len(e->name, root, strlen(e->name));\n\terr = PTR_ERR(dentry);\n\tif (IS_ERR(dentry))\n\t\tgoto out;\n\n\terr = -EEXIST;\n\tif (d_really_is_positive(dentry))\n\t\tgoto out2;\n\n\tinode = bm_get_inode(sb, S_IFREG | 0644);\n\n\terr = -ENOMEM;\n\tif (!inode)\n\t\tgoto out2;\n\n\terr = simple_pin_fs(&bm_fs_type, &bm_mnt, &entry_count);\n\tif (err) {\n\t\tiput(inode);\n\t\tinode = NULL;\n\t\tgoto out2;\n\t}\n\n\te->dentry = dget(dentry);\n\tinode->i_private = e;\n\tinode->i_fop = &bm_entry_operations;\n\n\td_instantiate(dentry, inode);\n\twrite_lock(&entries_lock);\n\tlist_add(&e->list, &entries);\n\twrite_unlock(&entries_lock);\n\n\terr = 0;\nout2:\n\tdput(dentry);\nout:\n\tinode_unlock(d_inode(root));\n\n\tif (err) {\n\t\tif (f)\n\t\t\tfilp_close(f, NULL);\n\t\tkfree(e);\n\t\treturn err;\n\t}\n\treturn count;\n}\n\nstatic const struct file_operations bm_register_operations = {\n\t.write\t\t= bm_register_write,\n\t.llseek\t\t= noop_llseek,\n};\n\n \n\nstatic ssize_t\nbm_status_read(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos)\n{\n\tchar *s = enabled ? \"enabled\\n\" : \"disabled\\n\";\n\n\treturn simple_read_from_buffer(buf, nbytes, ppos, s, strlen(s));\n}\n\nstatic ssize_t bm_status_write(struct file *file, const char __user *buffer,\n\t\tsize_t count, loff_t *ppos)\n{\n\tint res = parse_command(buffer, count);\n\tstruct dentry *root;\n\n\tswitch (res) {\n\tcase 1:\n\t\t \n\t\tenabled = 0;\n\t\tbreak;\n\tcase 2:\n\t\t \n\t\tenabled = 1;\n\t\tbreak;\n\tcase 3:\n\t\t \n\t\troot = file_inode(file)->i_sb->s_root;\n\t\tinode_lock(d_inode(root));\n\n\t\twhile (!list_empty(&entries))\n\t\t\tkill_node(list_first_entry(&entries, Node, list));\n\n\t\tinode_unlock(d_inode(root));\n\t\tbreak;\n\tdefault:\n\t\treturn res;\n\t}\n\n\treturn count;\n}\n\nstatic const struct file_operations bm_status_operations = {\n\t.read\t\t= bm_status_read,\n\t.write\t\t= bm_status_write,\n\t.llseek\t\t= default_llseek,\n};\n\n \n\nstatic const struct super_operations s_ops = {\n\t.statfs\t\t= simple_statfs,\n\t.evict_inode\t= bm_evict_inode,\n};\n\nstatic int bm_fill_super(struct super_block *sb, struct fs_context *fc)\n{\n\tint err;\n\tstatic const struct tree_descr bm_files[] = {\n\t\t[2] = {\"status\", &bm_status_operations, S_IWUSR|S_IRUGO},\n\t\t[3] = {\"register\", &bm_register_operations, S_IWUSR},\n\t\t  {\"\"}\n\t};\n\n\terr = simple_fill_super(sb, BINFMTFS_MAGIC, bm_files);\n\tif (!err)\n\t\tsb->s_op = &s_ops;\n\treturn err;\n}\n\nstatic int bm_get_tree(struct fs_context *fc)\n{\n\treturn get_tree_single(fc, bm_fill_super);\n}\n\nstatic const struct fs_context_operations bm_context_ops = {\n\t.get_tree\t= bm_get_tree,\n};\n\nstatic int bm_init_fs_context(struct fs_context *fc)\n{\n\tfc->ops = &bm_context_ops;\n\treturn 0;\n}\n\nstatic struct linux_binfmt misc_format = {\n\t.module = THIS_MODULE,\n\t.load_binary = load_misc_binary,\n};\n\nstatic struct file_system_type bm_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"binfmt_misc\",\n\t.init_fs_context = bm_init_fs_context,\n\t.kill_sb\t= kill_litter_super,\n};\nMODULE_ALIAS_FS(\"binfmt_misc\");\n\nstatic int __init init_misc_binfmt(void)\n{\n\tint err = register_filesystem(&bm_fs_type);\n\tif (!err)\n\t\tinsert_binfmt(&misc_format);\n\treturn err;\n}\n\nstatic void __exit exit_misc_binfmt(void)\n{\n\tunregister_binfmt(&misc_format);\n\tunregister_filesystem(&bm_fs_type);\n}\n\ncore_initcall(init_misc_binfmt);\nmodule_exit(exit_misc_binfmt);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}