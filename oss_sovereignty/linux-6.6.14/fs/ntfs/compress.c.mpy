{
  "module_name": "compress.c",
  "hash_id": "561d37a6505a8af025963677a41615dbcbdd9b4bc8a12790bfc1f838a808891c",
  "original_prompt": "Ingested from linux-6.6.14/fs/ntfs/compress.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"ntfs.h\"\n\n \ntypedef enum {\n\t \n\tNTFS_SYMBOL_TOKEN\t=\t0,\n\tNTFS_PHRASE_TOKEN\t=\t1,\n\tNTFS_TOKEN_MASK\t\t=\t1,\n\n\t \n\tNTFS_SB_SIZE_MASK\t=\t0x0fff,\n\tNTFS_SB_SIZE\t\t=\t0x1000,\n\tNTFS_SB_IS_COMPRESSED\t=\t0x8000,\n\n\t \n\tNTFS_MAX_CB_SIZE\t= 64 * 1024,\n} ntfs_compression_constants;\n\n \nstatic u8 *ntfs_compression_buffer;\n\n \nstatic DEFINE_SPINLOCK(ntfs_cb_lock);\n\n \nint allocate_compression_buffers(void)\n{\n\tBUG_ON(ntfs_compression_buffer);\n\n\tntfs_compression_buffer = vmalloc(NTFS_MAX_CB_SIZE);\n\tif (!ntfs_compression_buffer)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\n \nvoid free_compression_buffers(void)\n{\n\tBUG_ON(!ntfs_compression_buffer);\n\tvfree(ntfs_compression_buffer);\n\tntfs_compression_buffer = NULL;\n}\n\n \nstatic void zero_partial_compressed_page(struct page *page,\n\t\tconst s64 initialized_size)\n{\n\tu8 *kp = page_address(page);\n\tunsigned int kp_ofs;\n\n\tntfs_debug(\"Zeroing page region outside initialized size.\");\n\tif (((s64)page->index << PAGE_SHIFT) >= initialized_size) {\n\t\tclear_page(kp);\n\t\treturn;\n\t}\n\tkp_ofs = initialized_size & ~PAGE_MASK;\n\tmemset(kp + kp_ofs, 0, PAGE_SIZE - kp_ofs);\n\treturn;\n}\n\n \nstatic inline void handle_bounds_compressed_page(struct page *page,\n\t\tconst loff_t i_size, const s64 initialized_size)\n{\n\tif ((page->index >= (initialized_size >> PAGE_SHIFT)) &&\n\t\t\t(initialized_size < i_size))\n\t\tzero_partial_compressed_page(page, initialized_size);\n\treturn;\n}\n\n \nstatic int ntfs_decompress(struct page *dest_pages[], int completed_pages[],\n\t\tint *dest_index, int *dest_ofs, const int dest_max_index,\n\t\tconst int dest_max_ofs, const int xpage, char *xpage_done,\n\t\tu8 *const cb_start, const u32 cb_size, const loff_t i_size,\n\t\tconst s64 initialized_size)\n{\n\t \n\tu8 *cb_end = cb_start + cb_size;  \n\tu8 *cb = cb_start;\t \n\tu8 *cb_sb_start;\t \n\tu8 *cb_sb_end;\t\t \n\n\t \n\tstruct page *dp;\t \n\tu8 *dp_addr;\t\t \n\tu8 *dp_sb_start;\t \n\tu8 *dp_sb_end;\t\t \n\tu16 do_sb_start;\t \n\tu16 do_sb_end;\t\t \n\n\t \n\tu8 tag;\t\t\t \n\tint token;\t\t \n\tint nr_completed_pages = 0;\n\n\t \n\tint err = -EOVERFLOW;\n\n\tntfs_debug(\"Entering, cb_size = 0x%x.\", cb_size);\ndo_next_sb:\n\tntfs_debug(\"Beginning sub-block at offset = 0x%zx in the cb.\",\n\t\t\tcb - cb_start);\n\t \n\tif (cb == cb_end || !le16_to_cpup((le16*)cb) ||\n\t\t\t(*dest_index == dest_max_index &&\n\t\t\t*dest_ofs == dest_max_ofs)) {\n\t\tint i;\n\n\t\tntfs_debug(\"Completed. Returning success (0).\");\n\t\terr = 0;\nreturn_error:\n\t\t \n\t\tspin_unlock(&ntfs_cb_lock);\n\t\t \n\t\tif (nr_completed_pages > 0) {\n\t\t\tfor (i = 0; i < nr_completed_pages; i++) {\n\t\t\t\tint di = completed_pages[i];\n\n\t\t\t\tdp = dest_pages[di];\n\t\t\t\t \n\t\t\t\thandle_bounds_compressed_page(dp, i_size,\n\t\t\t\t\t\tinitialized_size);\n\t\t\t\tflush_dcache_page(dp);\n\t\t\t\tkunmap(dp);\n\t\t\t\tSetPageUptodate(dp);\n\t\t\t\tunlock_page(dp);\n\t\t\t\tif (di == xpage)\n\t\t\t\t\t*xpage_done = 1;\n\t\t\t\telse\n\t\t\t\t\tput_page(dp);\n\t\t\t\tdest_pages[di] = NULL;\n\t\t\t}\n\t\t}\n\t\treturn err;\n\t}\n\n\t \n\tdo_sb_start = *dest_ofs;\n\tdo_sb_end = do_sb_start + NTFS_SB_SIZE;\n\n\t \n\tif (*dest_index == dest_max_index && do_sb_end > dest_max_ofs)\n\t\tgoto return_overflow;\n\n\t \n\tif (cb + 6 > cb_end)\n\t\tgoto return_overflow;\n\n\t \n\tcb_sb_start = cb;\n\tcb_sb_end = cb_sb_start + (le16_to_cpup((le16*)cb) & NTFS_SB_SIZE_MASK)\n\t\t\t+ 3;\n\tif (cb_sb_end > cb_end)\n\t\tgoto return_overflow;\n\n\t \n\tdp = dest_pages[*dest_index];\n\tif (!dp) {\n\t\t \n\t\tcb = cb_sb_end;\n\n\t\t \n\t\t*dest_ofs = (*dest_ofs + NTFS_SB_SIZE) & ~PAGE_MASK;\n\t\tif (!*dest_ofs && (++*dest_index > dest_max_index))\n\t\t\tgoto return_overflow;\n\t\tgoto do_next_sb;\n\t}\n\n\t \n\tdp_addr = (u8*)page_address(dp) + do_sb_start;\n\n\t \n\tif (!(le16_to_cpup((le16*)cb) & NTFS_SB_IS_COMPRESSED)) {\n\t\tntfs_debug(\"Found uncompressed sub-block.\");\n\t\t \n\n\t\t \n\t\tcb += 2;\n\n\t\t \n\t\tif (cb_sb_end - cb != NTFS_SB_SIZE)\n\t\t\tgoto return_overflow;\n\n\t\t \n\t\tmemcpy(dp_addr, cb, NTFS_SB_SIZE);\n\t\tcb += NTFS_SB_SIZE;\n\n\t\t \n\t\t*dest_ofs += NTFS_SB_SIZE;\n\t\tif (!(*dest_ofs &= ~PAGE_MASK)) {\nfinalize_page:\n\t\t\t \n\t\t\tcompleted_pages[nr_completed_pages++] = *dest_index;\n\t\t\tif (++*dest_index > dest_max_index)\n\t\t\t\tgoto return_overflow;\n\t\t}\n\t\tgoto do_next_sb;\n\t}\n\tntfs_debug(\"Found compressed sub-block.\");\n\t \n\n\t \n\tdp_sb_start = dp_addr;\n\tdp_sb_end = dp_sb_start + NTFS_SB_SIZE;\n\n\t \n\tcb += 2;\ndo_next_tag:\n\tif (cb == cb_sb_end) {\n\t\t \n\t\tif (dp_addr < dp_sb_end) {\n\t\t\tint nr_bytes = do_sb_end - *dest_ofs;\n\n\t\t\tntfs_debug(\"Filling incomplete sub-block with \"\n\t\t\t\t\t\"zeroes.\");\n\t\t\t \n\t\t\tmemset(dp_addr, 0, nr_bytes);\n\t\t\t*dest_ofs += nr_bytes;\n\t\t}\n\t\t \n\t\tif (!(*dest_ofs &= ~PAGE_MASK))\n\t\t\tgoto finalize_page;\n\t\tgoto do_next_sb;\n\t}\n\n\t \n\tif (cb > cb_sb_end || dp_addr > dp_sb_end)\n\t\tgoto return_overflow;\n\n\t \n\ttag = *cb++;\n\n\t \n\tfor (token = 0; token < 8; token++, tag >>= 1) {\n\t\tu16 lg, pt, length, max_non_overlap;\n\t\tregister u16 i;\n\t\tu8 *dp_back_addr;\n\n\t\t \n\t\tif (cb >= cb_sb_end || dp_addr > dp_sb_end)\n\t\t\tbreak;\n\n\t\t \n\t\tif ((tag & NTFS_TOKEN_MASK) == NTFS_SYMBOL_TOKEN) {\n\t\t\t \n\t\t\t*dp_addr++ = *cb++;\n\t\t\t++*dest_ofs;\n\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (dp_addr == dp_sb_start)\n\t\t\tgoto return_overflow;\n\n\t\t \n\t\tlg = 0;\n\t\tfor (i = *dest_ofs - do_sb_start - 1; i >= 0x10; i >>= 1)\n\t\t\tlg++;\n\n\t\t \n\t\tpt = le16_to_cpup((le16*)cb);\n\n\t\t \n\t\tdp_back_addr = dp_addr - (pt >> (12 - lg)) - 1;\n\t\tif (dp_back_addr < dp_sb_start)\n\t\t\tgoto return_overflow;\n\n\t\t \n\t\tlength = (pt & (0xfff >> lg)) + 3;\n\n\t\t \n\t\t*dest_ofs += length;\n\t\tif (*dest_ofs > do_sb_end)\n\t\t\tgoto return_overflow;\n\n\t\t \n\t\tmax_non_overlap = dp_addr - dp_back_addr;\n\n\t\tif (length <= max_non_overlap) {\n\t\t\t \n\t\t\tmemcpy(dp_addr, dp_back_addr, length);\n\n\t\t\t \n\t\t\tdp_addr += length;\n\t\t} else {\n\t\t\t \n\t\t\tmemcpy(dp_addr, dp_back_addr, max_non_overlap);\n\t\t\tdp_addr += max_non_overlap;\n\t\t\tdp_back_addr += max_non_overlap;\n\t\t\tlength -= max_non_overlap;\n\t\t\twhile (length--)\n\t\t\t\t*dp_addr++ = *dp_back_addr++;\n\t\t}\n\n\t\t \n\t\tcb += 2;\n\t}\n\n\t \n\tgoto do_next_tag;\n\nreturn_overflow:\n\tntfs_error(NULL, \"Failed. Returning -EOVERFLOW.\");\n\tgoto return_error;\n}\n\n \nint ntfs_read_compressed_block(struct page *page)\n{\n\tloff_t i_size;\n\ts64 initialized_size;\n\tstruct address_space *mapping = page->mapping;\n\tntfs_inode *ni = NTFS_I(mapping->host);\n\tntfs_volume *vol = ni->vol;\n\tstruct super_block *sb = vol->sb;\n\trunlist_element *rl;\n\tunsigned long flags, block_size = sb->s_blocksize;\n\tunsigned char block_size_bits = sb->s_blocksize_bits;\n\tu8 *cb, *cb_pos, *cb_end;\n\tstruct buffer_head **bhs;\n\tunsigned long offset, index = page->index;\n\tu32 cb_size = ni->itype.compressed.block_size;\n\tu64 cb_size_mask = cb_size - 1UL;\n\tVCN vcn;\n\tLCN lcn;\n\t \n\tVCN start_vcn = (((s64)index << PAGE_SHIFT) & ~cb_size_mask) >>\n\t\t\tvol->cluster_size_bits;\n\t \n\tVCN end_vcn = ((((s64)(index + 1UL) << PAGE_SHIFT) + cb_size - 1)\n\t\t\t& ~cb_size_mask) >> vol->cluster_size_bits;\n\t \n\tunsigned int nr_cbs = (end_vcn - start_vcn) << vol->cluster_size_bits\n\t\t\t>> ni->itype.compressed.block_size_bits;\n\t \n\tunsigned int nr_pages = (end_vcn - start_vcn) <<\n\t\t\tvol->cluster_size_bits >> PAGE_SHIFT;\n\tunsigned int xpage, max_page, cur_page, cur_ofs, i;\n\tunsigned int cb_clusters, cb_max_ofs;\n\tint block, max_block, cb_max_page, bhs_size, nr_bhs, err = 0;\n\tstruct page **pages;\n\tint *completed_pages;\n\tunsigned char xpage_done = 0;\n\n\tntfs_debug(\"Entering, page->index = 0x%lx, cb_size = 0x%x, nr_pages = \"\n\t\t\t\"%i.\", index, cb_size, nr_pages);\n\t \n\tBUG_ON(ni->type != AT_DATA);\n\tBUG_ON(ni->name_len);\n\n\tpages = kmalloc_array(nr_pages, sizeof(struct page *), GFP_NOFS);\n\tcompleted_pages = kmalloc_array(nr_pages + 1, sizeof(int), GFP_NOFS);\n\n\t \n\tbhs_size = cb_size / block_size * sizeof(struct buffer_head *);\n\tbhs = kmalloc(bhs_size, GFP_NOFS);\n\n\tif (unlikely(!pages || !bhs || !completed_pages)) {\n\t\tkfree(bhs);\n\t\tkfree(pages);\n\t\tkfree(completed_pages);\n\t\tunlock_page(page);\n\t\tntfs_error(vol->sb, \"Failed to allocate internal buffers.\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\toffset = start_vcn << vol->cluster_size_bits >> PAGE_SHIFT;\n\txpage = index - offset;\n\tpages[xpage] = page;\n\t \n\tread_lock_irqsave(&ni->size_lock, flags);\n\ti_size = i_size_read(VFS_I(ni));\n\tinitialized_size = ni->initialized_size;\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\tmax_page = ((i_size + PAGE_SIZE - 1) >> PAGE_SHIFT) -\n\t\t\toffset;\n\t \n\tif (xpage >= max_page) {\n\t\tkfree(bhs);\n\t\tkfree(pages);\n\t\tkfree(completed_pages);\n\t\tzero_user(page, 0, PAGE_SIZE);\n\t\tntfs_debug(\"Compressed read outside i_size - truncated?\");\n\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\tif (nr_pages < max_page)\n\t\tmax_page = nr_pages;\n\tfor (i = 0; i < max_page; i++, offset++) {\n\t\tif (i != xpage)\n\t\t\tpages[i] = grab_cache_page_nowait(mapping, offset);\n\t\tpage = pages[i];\n\t\tif (page) {\n\t\t\t \n\t\t\tif (!PageDirty(page) && (!PageUptodate(page) ||\n\t\t\t\t\tPageError(page))) {\n\t\t\t\tClearPageError(page);\n\t\t\t\tkmap(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\tpages[i] = NULL;\n\t\t}\n\t}\n\n\t \n\tcur_page = 0;\n\tcur_ofs = 0;\n\tcb_clusters = ni->itype.compressed.block_clusters;\ndo_next_cb:\n\tnr_cbs--;\n\tnr_bhs = 0;\n\n\t \n\trl = NULL;\n\tfor (vcn = start_vcn, start_vcn += cb_clusters; vcn < start_vcn;\n\t\t\tvcn++) {\n\t\tbool is_retry = false;\n\n\t\tif (!rl) {\nlock_retry_remap:\n\t\t\tdown_read(&ni->runlist.lock);\n\t\t\trl = ni->runlist.rl;\n\t\t}\n\t\tif (likely(rl != NULL)) {\n\t\t\t \n\t\t\twhile (rl->length && rl[1].vcn <= vcn)\n\t\t\t\trl++;\n\t\t\tlcn = ntfs_rl_vcn_to_lcn(rl, vcn);\n\t\t} else\n\t\t\tlcn = LCN_RL_NOT_MAPPED;\n\t\tntfs_debug(\"Reading vcn = 0x%llx, lcn = 0x%llx.\",\n\t\t\t\t(unsigned long long)vcn,\n\t\t\t\t(unsigned long long)lcn);\n\t\tif (lcn < 0) {\n\t\t\t \n\t\t\tif (lcn == LCN_HOLE)\n\t\t\t\tbreak;\n\t\t\tif (is_retry || lcn != LCN_RL_NOT_MAPPED)\n\t\t\t\tgoto rl_err;\n\t\t\tis_retry = true;\n\t\t\t \n\t\t\tup_read(&ni->runlist.lock);\n\t\t\tif (!ntfs_map_runlist(ni, vcn))\n\t\t\t\tgoto lock_retry_remap;\n\t\t\tgoto map_rl_err;\n\t\t}\n\t\tblock = lcn << vol->cluster_size_bits >> block_size_bits;\n\t\t \n\t\tmax_block = block + (vol->cluster_size >> block_size_bits);\n\t\tdo {\n\t\t\tntfs_debug(\"block = 0x%x.\", block);\n\t\t\tif (unlikely(!(bhs[nr_bhs] = sb_getblk(sb, block))))\n\t\t\t\tgoto getblk_err;\n\t\t\tnr_bhs++;\n\t\t} while (++block < max_block);\n\t}\n\n\t \n\tif (rl)\n\t\tup_read(&ni->runlist.lock);\n\n\t \n\tfor (i = 0; i < nr_bhs; i++) {\n\t\tstruct buffer_head *tbh = bhs[i];\n\n\t\tif (!trylock_buffer(tbh))\n\t\t\tcontinue;\n\t\tif (unlikely(buffer_uptodate(tbh))) {\n\t\t\tunlock_buffer(tbh);\n\t\t\tcontinue;\n\t\t}\n\t\tget_bh(tbh);\n\t\ttbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(REQ_OP_READ, tbh);\n\t}\n\n\t \n\tfor (i = 0; i < nr_bhs; i++) {\n\t\tstruct buffer_head *tbh = bhs[i];\n\n\t\tif (buffer_uptodate(tbh))\n\t\t\tcontinue;\n\t\twait_on_buffer(tbh);\n\t\t \n\t\tbarrier();\n\t\tif (unlikely(!buffer_uptodate(tbh))) {\n\t\t\tntfs_warning(vol->sb, \"Buffer is unlocked but not \"\n\t\t\t\t\t\"uptodate! Unplugging the disk queue \"\n\t\t\t\t\t\"and rescheduling.\");\n\t\t\tget_bh(tbh);\n\t\t\tio_schedule();\n\t\t\tput_bh(tbh);\n\t\t\tif (unlikely(!buffer_uptodate(tbh)))\n\t\t\t\tgoto read_err;\n\t\t\tntfs_warning(vol->sb, \"Buffer is now uptodate. Good.\");\n\t\t}\n\t}\n\n\t \n\tspin_lock(&ntfs_cb_lock);\n\tcb = ntfs_compression_buffer;\n\n\tBUG_ON(!cb);\n\n\tcb_pos = cb;\n\tcb_end = cb + cb_size;\n\n\t \n\tfor (i = 0; i < nr_bhs; i++) {\n\t\tmemcpy(cb_pos, bhs[i]->b_data, block_size);\n\t\tcb_pos += block_size;\n\t}\n\n\t \n\tif (cb_pos + 2 <= cb + cb_size)\n\t\t*(u16*)cb_pos = 0;\n\n\t \n\tcb_pos = cb;\n\n\t \n\tntfs_debug(\"Successfully read the compression block.\");\n\n\t \n\tcb_max_page = (cur_page << PAGE_SHIFT) + cur_ofs + cb_size;\n\tcb_max_ofs = cb_max_page & ~PAGE_MASK;\n\tcb_max_page >>= PAGE_SHIFT;\n\n\t \n\tif (cb_max_page > max_page)\n\t\tcb_max_page = max_page;\n\n\tif (vcn == start_vcn - cb_clusters) {\n\t\t \n\t\tntfs_debug(\"Found sparse compression block.\");\n\t\t \n\t\tspin_unlock(&ntfs_cb_lock);\n\t\tif (cb_max_ofs)\n\t\t\tcb_max_page--;\n\t\tfor (; cur_page < cb_max_page; cur_page++) {\n\t\t\tpage = pages[cur_page];\n\t\t\tif (page) {\n\t\t\t\tif (likely(!cur_ofs))\n\t\t\t\t\tclear_page(page_address(page));\n\t\t\t\telse\n\t\t\t\t\tmemset(page_address(page) + cur_ofs, 0,\n\t\t\t\t\t\t\tPAGE_SIZE -\n\t\t\t\t\t\t\tcur_ofs);\n\t\t\t\tflush_dcache_page(page);\n\t\t\t\tkunmap(page);\n\t\t\t\tSetPageUptodate(page);\n\t\t\t\tunlock_page(page);\n\t\t\t\tif (cur_page == xpage)\n\t\t\t\t\txpage_done = 1;\n\t\t\t\telse\n\t\t\t\t\tput_page(page);\n\t\t\t\tpages[cur_page] = NULL;\n\t\t\t}\n\t\t\tcb_pos += PAGE_SIZE - cur_ofs;\n\t\t\tcur_ofs = 0;\n\t\t\tif (cb_pos >= cb_end)\n\t\t\t\tbreak;\n\t\t}\n\t\t \n\t\tif (cb_max_ofs && cb_pos < cb_end) {\n\t\t\tpage = pages[cur_page];\n\t\t\tif (page)\n\t\t\t\tmemset(page_address(page) + cur_ofs, 0,\n\t\t\t\t\t\tcb_max_ofs - cur_ofs);\n\t\t\t \n\t\t\tcur_ofs = cb_max_ofs;\n\t\t}\n\t} else if (vcn == start_vcn) {\n\t\t \n\t\tunsigned int cur2_page = cur_page;\n\t\tunsigned int cur_ofs2 = cur_ofs;\n\t\tu8 *cb_pos2 = cb_pos;\n\n\t\tntfs_debug(\"Found uncompressed compression block.\");\n\t\t \n\t\t \n\t\tif (cb_max_ofs)\n\t\t\tcb_max_page--;\n\t\t \n\t\tfor (; cur_page < cb_max_page; cur_page++) {\n\t\t\tpage = pages[cur_page];\n\t\t\tif (page)\n\t\t\t\tmemcpy(page_address(page) + cur_ofs, cb_pos,\n\t\t\t\t\t\tPAGE_SIZE - cur_ofs);\n\t\t\tcb_pos += PAGE_SIZE - cur_ofs;\n\t\t\tcur_ofs = 0;\n\t\t\tif (cb_pos >= cb_end)\n\t\t\t\tbreak;\n\t\t}\n\t\t \n\t\tif (cb_max_ofs && cb_pos < cb_end) {\n\t\t\tpage = pages[cur_page];\n\t\t\tif (page)\n\t\t\t\tmemcpy(page_address(page) + cur_ofs, cb_pos,\n\t\t\t\t\t\tcb_max_ofs - cur_ofs);\n\t\t\tcb_pos += cb_max_ofs - cur_ofs;\n\t\t\tcur_ofs = cb_max_ofs;\n\t\t}\n\t\t \n\t\tspin_unlock(&ntfs_cb_lock);\n\t\t \n\t\tfor (; cur2_page < cb_max_page; cur2_page++) {\n\t\t\tpage = pages[cur2_page];\n\t\t\tif (page) {\n\t\t\t\t \n\t\t\t\thandle_bounds_compressed_page(page, i_size,\n\t\t\t\t\t\tinitialized_size);\n\t\t\t\tflush_dcache_page(page);\n\t\t\t\tkunmap(page);\n\t\t\t\tSetPageUptodate(page);\n\t\t\t\tunlock_page(page);\n\t\t\t\tif (cur2_page == xpage)\n\t\t\t\t\txpage_done = 1;\n\t\t\t\telse\n\t\t\t\t\tput_page(page);\n\t\t\t\tpages[cur2_page] = NULL;\n\t\t\t}\n\t\t\tcb_pos2 += PAGE_SIZE - cur_ofs2;\n\t\t\tcur_ofs2 = 0;\n\t\t\tif (cb_pos2 >= cb_end)\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t \n\t\tunsigned int prev_cur_page = cur_page;\n\n\t\tntfs_debug(\"Found compressed compression block.\");\n\t\terr = ntfs_decompress(pages, completed_pages, &cur_page,\n\t\t\t\t&cur_ofs, cb_max_page, cb_max_ofs, xpage,\n\t\t\t\t&xpage_done, cb_pos, cb_size - (cb_pos - cb),\n\t\t\t\ti_size, initialized_size);\n\t\t \n\t\tif (err) {\n\t\t\tntfs_error(vol->sb, \"ntfs_decompress() failed in inode \"\n\t\t\t\t\t\"0x%lx with error code %i. Skipping \"\n\t\t\t\t\t\"this compression block.\",\n\t\t\t\t\tni->mft_no, -err);\n\t\t\t \n\t\t\tfor (; prev_cur_page < cur_page; prev_cur_page++) {\n\t\t\t\tpage = pages[prev_cur_page];\n\t\t\t\tif (page) {\n\t\t\t\t\tflush_dcache_page(page);\n\t\t\t\t\tkunmap(page);\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tif (prev_cur_page != xpage)\n\t\t\t\t\t\tput_page(page);\n\t\t\t\t\tpages[prev_cur_page] = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < nr_bhs; i++)\n\t\tbrelse(bhs[i]);\n\n\t \n\tif (nr_cbs)\n\t\tgoto do_next_cb;\n\n\t \n\tkfree(bhs);\n\n\t \n\tfor (cur_page = 0; cur_page < max_page; cur_page++) {\n\t\tpage = pages[cur_page];\n\t\tif (page) {\n\t\t\tntfs_error(vol->sb, \"Still have pages left! \"\n\t\t\t\t\t\"Terminating them with extreme \"\n\t\t\t\t\t\"prejudice.  Inode 0x%lx, page index \"\n\t\t\t\t\t\"0x%lx.\", ni->mft_no, page->index);\n\t\t\tflush_dcache_page(page);\n\t\t\tkunmap(page);\n\t\t\tunlock_page(page);\n\t\t\tif (cur_page != xpage)\n\t\t\t\tput_page(page);\n\t\t\tpages[cur_page] = NULL;\n\t\t}\n\t}\n\n\t \n\tkfree(pages);\n\tkfree(completed_pages);\n\n\t \n\tif (likely(xpage_done))\n\t\treturn 0;\n\n\tntfs_debug(\"Failed. Returning error code %s.\", err == -EOVERFLOW ?\n\t\t\t\"EOVERFLOW\" : (!err ? \"EIO\" : \"unknown error\"));\n\treturn err < 0 ? err : -EIO;\n\nread_err:\n\tntfs_error(vol->sb, \"IO error while reading compressed data.\");\n\t \n\tfor (i = 0; i < nr_bhs; i++)\n\t\tbrelse(bhs[i]);\n\tgoto err_out;\n\nmap_rl_err:\n\tntfs_error(vol->sb, \"ntfs_map_runlist() failed. Cannot read \"\n\t\t\t\"compression block.\");\n\tgoto err_out;\n\nrl_err:\n\tup_read(&ni->runlist.lock);\n\tntfs_error(vol->sb, \"ntfs_rl_vcn_to_lcn() failed. Cannot read \"\n\t\t\t\"compression block.\");\n\tgoto err_out;\n\ngetblk_err:\n\tup_read(&ni->runlist.lock);\n\tntfs_error(vol->sb, \"getblk() failed. Cannot read compression block.\");\n\nerr_out:\n\tkfree(bhs);\n\tfor (i = cur_page; i < max_page; i++) {\n\t\tpage = pages[i];\n\t\tif (page) {\n\t\t\tflush_dcache_page(page);\n\t\t\tkunmap(page);\n\t\t\tunlock_page(page);\n\t\t\tif (i != xpage)\n\t\t\t\tput_page(page);\n\t\t}\n\t}\n\tkfree(pages);\n\tkfree(completed_pages);\n\treturn -EIO;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}