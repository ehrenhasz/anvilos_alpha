{
  "module_name": "layout.h",
  "hash_id": "d78890c30e89233cf50fb08668e84e097f7ce00720f228917748d6e36840b4ed",
  "original_prompt": "Ingested from linux-6.6.14/fs/ntfs/layout.h",
  "human_readable_source": " \n \n\n#ifndef _LINUX_NTFS_LAYOUT_H\n#define _LINUX_NTFS_LAYOUT_H\n\n#include <linux/types.h>\n#include <linux/bitops.h>\n#include <linux/list.h>\n#include <asm/byteorder.h>\n\n#include \"types.h\"\n\n \n#define magicNTFS\tcpu_to_le64(0x202020205346544eULL)\n\n \n\n \ntypedef struct {\n\tle16 bytes_per_sector;\t\t \n\tu8  sectors_per_cluster;\t \n\tle16 reserved_sectors;\t\t \n\tu8  fats;\t\t\t \n\tle16 root_entries;\t\t \n\tle16 sectors;\t\t\t \n\tu8  media_type;\t\t\t \n\tle16 sectors_per_fat;\t\t \n\tle16 sectors_per_track;\t\t \n\tle16 heads;\t\t\t \n\tle32 hidden_sectors;\t\t \n\tle32 large_sectors;\t\t \n} __attribute__ ((__packed__)) BIOS_PARAMETER_BLOCK;\n\n \ntypedef struct {\n\tu8  jump[3];\t\t\t \n\tle64 oem_id;\t\t\t \n\tBIOS_PARAMETER_BLOCK bpb;\t \n\tu8  unused[4];\t\t\t \n sle64 number_of_sectors;\t \n\tsle64 mft_lcn;\t\t\t \n\tsle64 mftmirr_lcn;\t\t \n\ts8  clusters_per_mft_record;\t \n\tu8  reserved0[3];\t\t \n\ts8  clusters_per_index_record;\t \n\tu8  reserved1[3];\t\t \n\tle64 volume_serial_number;\t \n\tle32 checksum;\t\t\t \n u8  bootstrap[426];\t\t \n\tle16 end_of_sector_marker;\t \n \n} __attribute__ ((__packed__)) NTFS_BOOT_SECTOR;\n\n \nenum {\n\t \n\tmagic_FILE = cpu_to_le32(0x454c4946),  \n\tmagic_INDX = cpu_to_le32(0x58444e49),  \n\tmagic_HOLE = cpu_to_le32(0x454c4f48),  \n\n\t \n\tmagic_RSTR = cpu_to_le32(0x52545352),  \n\tmagic_RCRD = cpu_to_le32(0x44524352),  \n\n\t \n\tmagic_CHKD = cpu_to_le32(0x444b4843),  \n\n\t \n\tmagic_BAAD = cpu_to_le32(0x44414142),  \n\t \n\tmagic_empty = cpu_to_le32(0xffffffff)  \n};\n\ntypedef le32 NTFS_RECORD_TYPE;\n\n \n\nstatic inline bool __ntfs_is_magic(le32 x, NTFS_RECORD_TYPE r)\n{\n\treturn (x == r);\n}\n#define ntfs_is_magic(x, m)\t__ntfs_is_magic(x, magic_##m)\n\nstatic inline bool __ntfs_is_magicp(le32 *p, NTFS_RECORD_TYPE r)\n{\n\treturn (*p == r);\n}\n#define ntfs_is_magicp(p, m)\t__ntfs_is_magicp(p, magic_##m)\n\n \n#define ntfs_is_file_record(x)\t\t( ntfs_is_magic (x, FILE) )\n#define ntfs_is_file_recordp(p)\t\t( ntfs_is_magicp(p, FILE) )\n#define ntfs_is_mft_record(x)\t\t( ntfs_is_file_record (x) )\n#define ntfs_is_mft_recordp(p)\t\t( ntfs_is_file_recordp(p) )\n#define ntfs_is_indx_record(x)\t\t( ntfs_is_magic (x, INDX) )\n#define ntfs_is_indx_recordp(p)\t\t( ntfs_is_magicp(p, INDX) )\n#define ntfs_is_hole_record(x)\t\t( ntfs_is_magic (x, HOLE) )\n#define ntfs_is_hole_recordp(p)\t\t( ntfs_is_magicp(p, HOLE) )\n\n#define ntfs_is_rstr_record(x)\t\t( ntfs_is_magic (x, RSTR) )\n#define ntfs_is_rstr_recordp(p)\t\t( ntfs_is_magicp(p, RSTR) )\n#define ntfs_is_rcrd_record(x)\t\t( ntfs_is_magic (x, RCRD) )\n#define ntfs_is_rcrd_recordp(p)\t\t( ntfs_is_magicp(p, RCRD) )\n\n#define ntfs_is_chkd_record(x)\t\t( ntfs_is_magic (x, CHKD) )\n#define ntfs_is_chkd_recordp(p)\t\t( ntfs_is_magicp(p, CHKD) )\n\n#define ntfs_is_baad_record(x)\t\t( ntfs_is_magic (x, BAAD) )\n#define ntfs_is_baad_recordp(p)\t\t( ntfs_is_magicp(p, BAAD) )\n\n#define ntfs_is_empty_record(x)\t\t( ntfs_is_magic (x, empty) )\n#define ntfs_is_empty_recordp(p)\t( ntfs_is_magicp(p, empty) )\n\n \ntypedef struct {\n\tNTFS_RECORD_TYPE magic;\t \n\tle16 usa_ofs;\t\t \n\tle16 usa_count;\t\t \n} __attribute__ ((__packed__)) NTFS_RECORD;\n\n \ntypedef enum {\n\tFILE_MFT       = 0,\t \n\tFILE_MFTMirr   = 1,\t \n\tFILE_LogFile   = 2,\t \n\tFILE_Volume    = 3,\t \n\tFILE_AttrDef   = 4,\t \n\tFILE_root      = 5,\t \n\tFILE_Bitmap    = 6,\t \n\tFILE_Boot      = 7,\t \n\tFILE_BadClus   = 8,\t \n\tFILE_Secure    = 9,\t \n\tFILE_UpCase    = 10,\t \n\tFILE_Extend    = 11,\t \n\tFILE_reserved12 = 12,\t \n\tFILE_reserved13 = 13,\n\tFILE_reserved14 = 14,\n\tFILE_reserved15 = 15,\n\tFILE_first_user = 16,\t \n} NTFS_SYSTEM_FILES;\n\n \nenum {\n\tMFT_RECORD_IN_USE\t= cpu_to_le16(0x0001),\n\tMFT_RECORD_IS_DIRECTORY = cpu_to_le16(0x0002),\n} __attribute__ ((__packed__));\n\ntypedef le16 MFT_RECORD_FLAGS;\n\n \n\n \n#define MFT_REF_MASK_CPU 0x0000ffffffffffffULL\n#define MFT_REF_MASK_LE cpu_to_le64(MFT_REF_MASK_CPU)\n\ntypedef u64 MFT_REF;\ntypedef le64 leMFT_REF;\n\n#define MK_MREF(m, s)\t((MFT_REF)(((MFT_REF)(s) << 48) |\t\t\\\n\t\t\t\t\t((MFT_REF)(m) & MFT_REF_MASK_CPU)))\n#define MK_LE_MREF(m, s) cpu_to_le64(MK_MREF(m, s))\n\n#define MREF(x)\t\t((unsigned long)((x) & MFT_REF_MASK_CPU))\n#define MSEQNO(x)\t((u16)(((x) >> 48) & 0xffff))\n#define MREF_LE(x)\t((unsigned long)(le64_to_cpu(x) & MFT_REF_MASK_CPU))\n#define MSEQNO_LE(x)\t((u16)((le64_to_cpu(x) >> 48) & 0xffff))\n\n#define IS_ERR_MREF(x)\t(((x) & 0x0000800000000000ULL) ? true : false)\n#define ERR_MREF(x)\t((u64)((s64)(x)))\n#define MREF_ERR(x)\t((int)((s64)(x)))\n\n \ntypedef struct {\n \n \n\tNTFS_RECORD_TYPE magic;\t \n\tle16 usa_ofs;\t\t \n\tle16 usa_count;\t\t \n\n \tle64 lsn;\t\t \n \tle16 sequence_number;\t \n \tle16 link_count;\t \n \tle16 attrs_offset;\t \n \tMFT_RECORD_FLAGS flags;\t \n \tle32 bytes_in_use;\t \n \tle32 bytes_allocated;\t \n \tleMFT_REF base_mft_record; \n \tle16 next_attr_instance; \n \n  le16 reserved;\t\t \n  le32 mft_record_number;\t \n \n \n} __attribute__ ((__packed__)) MFT_RECORD;\n\n \ntypedef struct {\n \n \n\tNTFS_RECORD_TYPE magic;\t \n\tle16 usa_ofs;\t\t \n\tle16 usa_count;\t\t \n\n \tle64 lsn;\t\t \n \tle16 sequence_number;\t \n \tle16 link_count;\t \n \tle16 attrs_offset;\t \n \tMFT_RECORD_FLAGS flags;\t \n \tle32 bytes_in_use;\t \n \tle32 bytes_allocated;\t \n \tleMFT_REF base_mft_record; \n \tle16 next_attr_instance; \n \n \n} __attribute__ ((__packed__)) MFT_RECORD_OLD;\n\n \nenum {\n\tAT_UNUSED\t\t\t= cpu_to_le32(         0),\n\tAT_STANDARD_INFORMATION\t\t= cpu_to_le32(      0x10),\n\tAT_ATTRIBUTE_LIST\t\t= cpu_to_le32(      0x20),\n\tAT_FILE_NAME\t\t\t= cpu_to_le32(      0x30),\n\tAT_OBJECT_ID\t\t\t= cpu_to_le32(      0x40),\n\tAT_SECURITY_DESCRIPTOR\t\t= cpu_to_le32(      0x50),\n\tAT_VOLUME_NAME\t\t\t= cpu_to_le32(      0x60),\n\tAT_VOLUME_INFORMATION\t\t= cpu_to_le32(      0x70),\n\tAT_DATA\t\t\t\t= cpu_to_le32(      0x80),\n\tAT_INDEX_ROOT\t\t\t= cpu_to_le32(      0x90),\n\tAT_INDEX_ALLOCATION\t\t= cpu_to_le32(      0xa0),\n\tAT_BITMAP\t\t\t= cpu_to_le32(      0xb0),\n\tAT_REPARSE_POINT\t\t= cpu_to_le32(      0xc0),\n\tAT_EA_INFORMATION\t\t= cpu_to_le32(      0xd0),\n\tAT_EA\t\t\t\t= cpu_to_le32(      0xe0),\n\tAT_PROPERTY_SET\t\t\t= cpu_to_le32(      0xf0),\n\tAT_LOGGED_UTILITY_STREAM\t= cpu_to_le32(     0x100),\n\tAT_FIRST_USER_DEFINED_ATTRIBUTE\t= cpu_to_le32(    0x1000),\n\tAT_END\t\t\t\t= cpu_to_le32(0xffffffff)\n};\n\ntypedef le32 ATTR_TYPE;\n\n \nenum {\n\tCOLLATION_BINARY\t\t= cpu_to_le32(0x00),\n\tCOLLATION_FILE_NAME\t\t= cpu_to_le32(0x01),\n\tCOLLATION_UNICODE_STRING\t= cpu_to_le32(0x02),\n\tCOLLATION_NTOFS_ULONG\t\t= cpu_to_le32(0x10),\n\tCOLLATION_NTOFS_SID\t\t= cpu_to_le32(0x11),\n\tCOLLATION_NTOFS_SECURITY_HASH\t= cpu_to_le32(0x12),\n\tCOLLATION_NTOFS_ULONGS\t\t= cpu_to_le32(0x13),\n};\n\ntypedef le32 COLLATION_RULE;\n\n \nenum {\n\tATTR_DEF_INDEXABLE\t= cpu_to_le32(0x02),  \n\tATTR_DEF_MULTIPLE\t= cpu_to_le32(0x04),  \n\tATTR_DEF_NOT_ZERO\t= cpu_to_le32(0x08),  \n\tATTR_DEF_INDEXED_UNIQUE\t= cpu_to_le32(0x10),  \n\tATTR_DEF_NAMED_UNIQUE\t= cpu_to_le32(0x20),  \n\tATTR_DEF_RESIDENT\t= cpu_to_le32(0x40),  \n\tATTR_DEF_ALWAYS_LOG\t= cpu_to_le32(0x80),  \n};\n\ntypedef le32 ATTR_DEF_FLAGS;\n\n \ntypedef struct {\n \n \tntfschar name[0x40];\t\t \n \tATTR_TYPE type;\t\t\t \n \tle32 display_rule;\t\t \n  COLLATION_RULE collation_rule;\t \n \tATTR_DEF_FLAGS flags;\t\t \n \tsle64 min_size;\t\t\t \n \tsle64 max_size;\t\t\t \n \n} __attribute__ ((__packed__)) ATTR_DEF;\n\n \nenum {\n\tATTR_IS_COMPRESSED    = cpu_to_le16(0x0001),\n\tATTR_COMPRESSION_MASK = cpu_to_le16(0x00ff),  \n\tATTR_IS_ENCRYPTED     = cpu_to_le16(0x4000),\n\tATTR_IS_SPARSE\t      = cpu_to_le16(0x8000),\n} __attribute__ ((__packed__));\n\ntypedef le16 ATTR_FLAGS;\n\n \n\n \nenum {\n\tRESIDENT_ATTR_IS_INDEXED = 0x01,  \n} __attribute__ ((__packed__));\n\ntypedef u8 RESIDENT_ATTR_FLAGS;\n\n \ntypedef struct {\n \n \tATTR_TYPE type;\t\t \n \tle32 length;\t\t \n \tu8 non_resident;\t \n \tu8 name_length;\t\t \n \tle16 name_offset;\t \n \tATTR_FLAGS flags;\t \n \tle16 instance;\t\t \n \tunion {\n\t\t \n\t\tstruct {\n \t\tle32 value_length; \n \t\tle16 value_offset; \n \t\tRESIDENT_ATTR_FLAGS flags;  \n \t\ts8 reserved;\t   \n\t\t} __attribute__ ((__packed__)) resident;\n\t\t \n\t\tstruct {\n \t\t\tleVCN lowest_vcn; \n \t\t\tleVCN highest_vcn; \n \t\t\tle16 mapping_pairs_offset;  \n \t\t\tu8 compression_unit;  \n \t\t\tu8 reserved[5];\t\t \n \n \t\t\tsle64 allocated_size;\t \n \t\t\tsle64 data_size;\t \n \t\t\tsle64 initialized_size;\t \n \n \t\t\tsle64 compressed_size;\t \n \n\t\t} __attribute__ ((__packed__)) non_resident;\n\t} __attribute__ ((__packed__)) data;\n} __attribute__ ((__packed__)) ATTR_RECORD;\n\ntypedef ATTR_RECORD ATTR_REC;\n\n \nenum {\n\tFILE_ATTR_READONLY\t\t= cpu_to_le32(0x00000001),\n\tFILE_ATTR_HIDDEN\t\t= cpu_to_le32(0x00000002),\n\tFILE_ATTR_SYSTEM\t\t= cpu_to_le32(0x00000004),\n\t \n\n\tFILE_ATTR_DIRECTORY\t\t= cpu_to_le32(0x00000010),\n\t \n\tFILE_ATTR_ARCHIVE\t\t= cpu_to_le32(0x00000020),\n\tFILE_ATTR_DEVICE\t\t= cpu_to_le32(0x00000040),\n\tFILE_ATTR_NORMAL\t\t= cpu_to_le32(0x00000080),\n\n\tFILE_ATTR_TEMPORARY\t\t= cpu_to_le32(0x00000100),\n\tFILE_ATTR_SPARSE_FILE\t\t= cpu_to_le32(0x00000200),\n\tFILE_ATTR_REPARSE_POINT\t\t= cpu_to_le32(0x00000400),\n\tFILE_ATTR_COMPRESSED\t\t= cpu_to_le32(0x00000800),\n\n\tFILE_ATTR_OFFLINE\t\t= cpu_to_le32(0x00001000),\n\tFILE_ATTR_NOT_CONTENT_INDEXED\t= cpu_to_le32(0x00002000),\n\tFILE_ATTR_ENCRYPTED\t\t= cpu_to_le32(0x00004000),\n\n\tFILE_ATTR_VALID_FLAGS\t\t= cpu_to_le32(0x00007fb7),\n\t \n\tFILE_ATTR_VALID_SET_FLAGS\t= cpu_to_le32(0x000031a7),\n\t \n\t \n\tFILE_ATTR_DUP_FILE_NAME_INDEX_PRESENT\t= cpu_to_le32(0x10000000),\n\t \n\tFILE_ATTR_DUP_VIEW_INDEX_PRESENT\t= cpu_to_le32(0x20000000),\n\t \n};\n\ntypedef le32 FILE_ATTR_FLAGS;\n\n \n\n \ntypedef struct {\n \n \tsle64 creation_time;\t\t \n \tsle64 last_data_change_time;\t \n \tsle64 last_mft_change_time;\t \n \tsle64 last_access_time;\t\t \n \tFILE_ATTR_FLAGS file_attributes;  \n \tunion {\n\t \n\t\tstruct {\n\t\t \tu8 reserved12[12];\t \n\t\t} __attribute__ ((__packed__)) v1;\n\t \n\t \n\t\tstruct {\n \n\t\t \tle32 maximum_versions;\t \n\t\t \tle32 version_number;\t \n\t\t \tle32 class_id;\t\t \n\t\t \tle32 owner_id;\t\t \n\t\t \tle32 security_id;\t \n\t\t \tle64 quota_charged;\t \n\t\t \tleUSN usn;\t\t \n\t\t} __attribute__ ((__packed__)) v3;\n\t \n\t} __attribute__ ((__packed__)) ver;\n} __attribute__ ((__packed__)) STANDARD_INFORMATION;\n\n \ntypedef struct {\n \n \tATTR_TYPE type;\t\t \n \tle16 length;\t\t \n \tu8 name_length;\t\t \n \tu8 name_offset;\t\t \n \tleVCN lowest_vcn;\t \n \tleMFT_REF mft_reference; \n \tle16 instance;\t\t \n \tntfschar name[0];\t \n \n} __attribute__ ((__packed__)) ATTR_LIST_ENTRY;\n\n \n#define MAXIMUM_FILE_NAME_LENGTH\t255\n\n \nenum {\n\tFILE_NAME_POSIX\t\t= 0x00,\n\t \n\tFILE_NAME_WIN32\t\t= 0x01,\n\t \n\tFILE_NAME_DOS\t\t= 0x02,\n\t \n\tFILE_NAME_WIN32_AND_DOS\t= 0x03,\n\t \n} __attribute__ ((__packed__));\n\ntypedef u8 FILE_NAME_TYPE_FLAGS;\n\n \ntypedef struct {\n \n \tleMFT_REF parent_directory;\t \n \tsle64 creation_time;\t\t \n \tsle64 last_data_change_time;\t \n \tsle64 last_mft_change_time;\t \n \tsle64 last_access_time;\t\t \n \tsle64 allocated_size;\t\t \n \tsle64 data_size;\t\t \n \tFILE_ATTR_FLAGS file_attributes;\t \n \tunion {\n\t \tstruct {\n\t\t \tle16 packed_ea_size;\t \n\t\t \tle16 reserved;\t\t \n\t\t} __attribute__ ((__packed__)) ea;\n\t \tstruct {\n\t\t \tle32 reparse_point_tag;\t \n\t\t} __attribute__ ((__packed__)) rp;\n\t} __attribute__ ((__packed__)) type;\n \tu8 file_name_length;\t\t\t \n \tFILE_NAME_TYPE_FLAGS file_name_type;\t \n \tntfschar file_name[0];\t\t\t \n} __attribute__ ((__packed__)) FILE_NAME_ATTR;\n\n \ntypedef struct {\n\tle32 data1;\t \n\tle16 data2;\t \n\tle16 data3;\t \n\tu8 data4[8];\t \n} __attribute__ ((__packed__)) GUID;\n\n \ntypedef struct {\n\tleMFT_REF mft_reference; \n\tunion {\n\t\tstruct {\n\t\t\tGUID birth_volume_id;\n\t\t\tGUID birth_object_id;\n\t\t\tGUID domain_id;\n\t\t} __attribute__ ((__packed__)) origin;\n\t\tu8 extended_info[48];\n\t} __attribute__ ((__packed__)) opt;\n} __attribute__ ((__packed__)) OBJ_ID_INDEX_DATA;\n\n \ntypedef struct {\n\tGUID object_id;\t\t\t\t \n\t \n\tunion {\n\t\tstruct {\n\t\t\tGUID birth_volume_id;\t \n\t\t\tGUID birth_object_id;\t \n\t\t\tGUID domain_id;\t\t \n\t\t} __attribute__ ((__packed__)) origin;\n\t\tu8 extended_info[48];\n\t} __attribute__ ((__packed__)) opt;\n} __attribute__ ((__packed__)) OBJECT_ID_ATTR;\n\n \n \n \n \n \n \n \n \n \n\n \ntypedef enum {\t\t\t\t\t \n\tSECURITY_NULL_RID\t\t  = 0,\t \n\tSECURITY_WORLD_RID\t\t  = 0,\t \n\tSECURITY_LOCAL_RID\t\t  = 0,\t \n\n\tSECURITY_CREATOR_OWNER_RID\t  = 0,\t \n\tSECURITY_CREATOR_GROUP_RID\t  = 1,\t \n\n\tSECURITY_CREATOR_OWNER_SERVER_RID = 2,\t \n\tSECURITY_CREATOR_GROUP_SERVER_RID = 3,\t \n\n\tSECURITY_DIALUP_RID\t\t  = 1,\n\tSECURITY_NETWORK_RID\t\t  = 2,\n\tSECURITY_BATCH_RID\t\t  = 3,\n\tSECURITY_INTERACTIVE_RID\t  = 4,\n\tSECURITY_SERVICE_RID\t\t  = 6,\n\tSECURITY_ANONYMOUS_LOGON_RID\t  = 7,\n\tSECURITY_PROXY_RID\t\t  = 8,\n\tSECURITY_ENTERPRISE_CONTROLLERS_RID=9,\n\tSECURITY_SERVER_LOGON_RID\t  = 9,\n\tSECURITY_PRINCIPAL_SELF_RID\t  = 0xa,\n\tSECURITY_AUTHENTICATED_USER_RID\t  = 0xb,\n\tSECURITY_RESTRICTED_CODE_RID\t  = 0xc,\n\tSECURITY_TERMINAL_SERVER_RID\t  = 0xd,\n\n\tSECURITY_LOGON_IDS_RID\t\t  = 5,\n\tSECURITY_LOGON_IDS_RID_COUNT\t  = 3,\n\n\tSECURITY_LOCAL_SYSTEM_RID\t  = 0x12,\n\n\tSECURITY_NT_NON_UNIQUE\t\t  = 0x15,\n\n\tSECURITY_BUILTIN_DOMAIN_RID\t  = 0x20,\n\n\t \n\n\t \n\tDOMAIN_USER_RID_ADMIN\t\t  = 0x1f4,\n\tDOMAIN_USER_RID_GUEST\t\t  = 0x1f5,\n\tDOMAIN_USER_RID_KRBTGT\t\t  = 0x1f6,\n\n\t \n\tDOMAIN_GROUP_RID_ADMINS\t\t  = 0x200,\n\tDOMAIN_GROUP_RID_USERS\t\t  = 0x201,\n\tDOMAIN_GROUP_RID_GUESTS\t\t  = 0x202,\n\tDOMAIN_GROUP_RID_COMPUTERS\t  = 0x203,\n\tDOMAIN_GROUP_RID_CONTROLLERS\t  = 0x204,\n\tDOMAIN_GROUP_RID_CERT_ADMINS\t  = 0x205,\n\tDOMAIN_GROUP_RID_SCHEMA_ADMINS\t  = 0x206,\n\tDOMAIN_GROUP_RID_ENTERPRISE_ADMINS= 0x207,\n\tDOMAIN_GROUP_RID_POLICY_ADMINS\t  = 0x208,\n\n\t \n\tDOMAIN_ALIAS_RID_ADMINS\t\t  = 0x220,\n\tDOMAIN_ALIAS_RID_USERS\t\t  = 0x221,\n\tDOMAIN_ALIAS_RID_GUESTS\t\t  = 0x222,\n\tDOMAIN_ALIAS_RID_POWER_USERS\t  = 0x223,\n\n\tDOMAIN_ALIAS_RID_ACCOUNT_OPS\t  = 0x224,\n\tDOMAIN_ALIAS_RID_SYSTEM_OPS\t  = 0x225,\n\tDOMAIN_ALIAS_RID_PRINT_OPS\t  = 0x226,\n\tDOMAIN_ALIAS_RID_BACKUP_OPS\t  = 0x227,\n\n\tDOMAIN_ALIAS_RID_REPLICATOR\t  = 0x228,\n\tDOMAIN_ALIAS_RID_RAS_SERVERS\t  = 0x229,\n\tDOMAIN_ALIAS_RID_PREW2KCOMPACCESS = 0x22a,\n} RELATIVE_IDENTIFIERS;\n\n \n\n \ntypedef union {\n\tstruct {\n\t\tu16 high_part;\t \n\t\tu32 low_part;\t \n\t} __attribute__ ((__packed__)) parts;\n\tu8 value[6];\t\t \n} __attribute__ ((__packed__)) SID_IDENTIFIER_AUTHORITY;\n\n \ntypedef struct {\n\tu8 revision;\n\tu8 sub_authority_count;\n\tSID_IDENTIFIER_AUTHORITY identifier_authority;\n\tle32 sub_authority[1];\t\t \n} __attribute__ ((__packed__)) SID;\n\n \ntypedef enum {\n\tSID_REVISION\t\t\t=  1,\t \n\tSID_MAX_SUB_AUTHORITIES\t\t= 15,\t \n\tSID_RECOMMENDED_SUB_AUTHORITIES\t=  1,\t \n} SID_CONSTANTS;\n\n \nenum {\n\tACCESS_MIN_MS_ACE_TYPE\t\t= 0,\n\tACCESS_ALLOWED_ACE_TYPE\t\t= 0,\n\tACCESS_DENIED_ACE_TYPE\t\t= 1,\n\tSYSTEM_AUDIT_ACE_TYPE\t\t= 2,\n\tSYSTEM_ALARM_ACE_TYPE\t\t= 3,  \n\tACCESS_MAX_MS_V2_ACE_TYPE\t= 3,\n\n\tACCESS_ALLOWED_COMPOUND_ACE_TYPE= 4,\n\tACCESS_MAX_MS_V3_ACE_TYPE\t= 4,\n\n\t \n\tACCESS_MIN_MS_OBJECT_ACE_TYPE\t= 5,\n\tACCESS_ALLOWED_OBJECT_ACE_TYPE\t= 5,\n\tACCESS_DENIED_OBJECT_ACE_TYPE\t= 6,\n\tSYSTEM_AUDIT_OBJECT_ACE_TYPE\t= 7,\n\tSYSTEM_ALARM_OBJECT_ACE_TYPE\t= 8,\n\tACCESS_MAX_MS_OBJECT_ACE_TYPE\t= 8,\n\n\tACCESS_MAX_MS_V4_ACE_TYPE\t= 8,\n\n\t \n\tACCESS_MAX_MS_ACE_TYPE\t\t= 8,\n} __attribute__ ((__packed__));\n\ntypedef u8 ACE_TYPES;\n\n \nenum {\n\t \n\tOBJECT_INHERIT_ACE\t\t= 0x01,\n\tCONTAINER_INHERIT_ACE\t\t= 0x02,\n\tNO_PROPAGATE_INHERIT_ACE\t= 0x04,\n\tINHERIT_ONLY_ACE\t\t= 0x08,\n\tINHERITED_ACE\t\t\t= 0x10,\t \n\tVALID_INHERIT_FLAGS\t\t= 0x1f,\n\n\t \n\tSUCCESSFUL_ACCESS_ACE_FLAG\t= 0x40,\n\tFAILED_ACCESS_ACE_FLAG\t\t= 0x80,\n} __attribute__ ((__packed__));\n\ntypedef u8 ACE_FLAGS;\n\n \ntypedef struct {\n \n \tACE_TYPES type;\t\t \n \tACE_FLAGS flags;\t \n \tle16 size;\t\t \n} __attribute__ ((__packed__)) ACE_HEADER;\n\n \nenum {\n\t \n\n\t \n\tFILE_READ_DATA\t\t\t= cpu_to_le32(0x00000001),\n\t \n\tFILE_LIST_DIRECTORY\t\t= cpu_to_le32(0x00000001),\n\n\t \n\tFILE_WRITE_DATA\t\t\t= cpu_to_le32(0x00000002),\n\t \n\tFILE_ADD_FILE\t\t\t= cpu_to_le32(0x00000002),\n\n\t \n\tFILE_APPEND_DATA\t\t= cpu_to_le32(0x00000004),\n\t \n\tFILE_ADD_SUBDIRECTORY\t\t= cpu_to_le32(0x00000004),\n\n\t \n\tFILE_READ_EA\t\t\t= cpu_to_le32(0x00000008),\n\n\t \n\tFILE_WRITE_EA\t\t\t= cpu_to_le32(0x00000010),\n\n\t \n\tFILE_EXECUTE\t\t\t= cpu_to_le32(0x00000020),\n\t \n\tFILE_TRAVERSE\t\t\t= cpu_to_le32(0x00000020),\n\n\t \n\tFILE_DELETE_CHILD\t\t= cpu_to_le32(0x00000040),\n\n\t \n\tFILE_READ_ATTRIBUTES\t\t= cpu_to_le32(0x00000080),\n\n\t \n\tFILE_WRITE_ATTRIBUTES\t\t= cpu_to_le32(0x00000100),\n\n\t \n\n\t \n\tDELETE\t\t\t\t= cpu_to_le32(0x00010000),\n\n\t \n\tREAD_CONTROL\t\t\t= cpu_to_le32(0x00020000),\n\n\t \n\tWRITE_DAC\t\t\t= cpu_to_le32(0x00040000),\n\n\t \n\tWRITE_OWNER\t\t\t= cpu_to_le32(0x00080000),\n\n\t \n\tSYNCHRONIZE\t\t\t= cpu_to_le32(0x00100000),\n\n\t \n\n\t \n\tSTANDARD_RIGHTS_READ\t\t= cpu_to_le32(0x00020000),\n\tSTANDARD_RIGHTS_WRITE\t\t= cpu_to_le32(0x00020000),\n\tSTANDARD_RIGHTS_EXECUTE\t\t= cpu_to_le32(0x00020000),\n\n\t \n\tSTANDARD_RIGHTS_REQUIRED\t= cpu_to_le32(0x000f0000),\n\n\t \n\tSTANDARD_RIGHTS_ALL\t\t= cpu_to_le32(0x001f0000),\n\n\t \n\tACCESS_SYSTEM_SECURITY\t\t= cpu_to_le32(0x01000000),\n\tMAXIMUM_ALLOWED\t\t\t= cpu_to_le32(0x02000000),\n\n\t \n\n\t \n\tGENERIC_ALL\t\t\t= cpu_to_le32(0x10000000),\n\n\t \n\tGENERIC_EXECUTE\t\t\t= cpu_to_le32(0x20000000),\n\n\t \n\tGENERIC_WRITE\t\t\t= cpu_to_le32(0x40000000),\n\n\t \n\tGENERIC_READ\t\t\t= cpu_to_le32(0x80000000),\n};\n\ntypedef le32 ACCESS_MASK;\n\n \ntypedef struct {\n\tACCESS_MASK generic_read;\n\tACCESS_MASK generic_write;\n\tACCESS_MASK generic_execute;\n\tACCESS_MASK generic_all;\n} __attribute__ ((__packed__)) GENERIC_MAPPING;\n\n \n\n \ntypedef struct {\n \n\tACE_TYPES type;\t\t \n\tACE_FLAGS flags;\t \n\tle16 size;\t\t \n \tACCESS_MASK mask;\t \n\n \tSID sid;\t\t \n} __attribute__ ((__packed__)) ACCESS_ALLOWED_ACE, ACCESS_DENIED_ACE,\n\t\t\t       SYSTEM_AUDIT_ACE, SYSTEM_ALARM_ACE;\n\n \nenum {\n\tACE_OBJECT_TYPE_PRESENT\t\t\t= cpu_to_le32(1),\n\tACE_INHERITED_OBJECT_TYPE_PRESENT\t= cpu_to_le32(2),\n};\n\ntypedef le32 OBJECT_ACE_FLAGS;\n\ntypedef struct {\n \n\tACE_TYPES type;\t\t \n\tACE_FLAGS flags;\t \n\tle16 size;\t\t \n \tACCESS_MASK mask;\t \n\n \tOBJECT_ACE_FLAGS object_flags;\t \n \tGUID object_type;\n \tGUID inherited_object_type;\n\n \tSID sid;\t\t \n} __attribute__ ((__packed__)) ACCESS_ALLOWED_OBJECT_ACE,\n\t\t\t       ACCESS_DENIED_OBJECT_ACE,\n\t\t\t       SYSTEM_AUDIT_OBJECT_ACE,\n\t\t\t       SYSTEM_ALARM_OBJECT_ACE;\n\n \ntypedef struct {\n\tu8 revision;\t \n\tu8 alignment1;\n\tle16 size;\t \n\tle16 ace_count;\t \n\tle16 alignment2;\n \n} __attribute__ ((__packed__)) ACL;\n\n \ntypedef enum {\n\t \n\tACL_REVISION\t\t= 2,\n\tACL_REVISION_DS\t\t= 4,\n\n\t \n\tACL_REVISION1\t\t= 1,\n\tMIN_ACL_REVISION\t= 2,\n\tACL_REVISION2\t\t= 2,\n\tACL_REVISION3\t\t= 3,\n\tACL_REVISION4\t\t= 4,\n\tMAX_ACL_REVISION\t= 4,\n} ACL_CONSTANTS;\n\n \nenum {\n\tSE_OWNER_DEFAULTED\t\t= cpu_to_le16(0x0001),\n\tSE_GROUP_DEFAULTED\t\t= cpu_to_le16(0x0002),\n\tSE_DACL_PRESENT\t\t\t= cpu_to_le16(0x0004),\n\tSE_DACL_DEFAULTED\t\t= cpu_to_le16(0x0008),\n\n\tSE_SACL_PRESENT\t\t\t= cpu_to_le16(0x0010),\n\tSE_SACL_DEFAULTED\t\t= cpu_to_le16(0x0020),\n\n\tSE_DACL_AUTO_INHERIT_REQ\t= cpu_to_le16(0x0100),\n\tSE_SACL_AUTO_INHERIT_REQ\t= cpu_to_le16(0x0200),\n\tSE_DACL_AUTO_INHERITED\t\t= cpu_to_le16(0x0400),\n\tSE_SACL_AUTO_INHERITED\t\t= cpu_to_le16(0x0800),\n\n\tSE_DACL_PROTECTED\t\t= cpu_to_le16(0x1000),\n\tSE_SACL_PROTECTED\t\t= cpu_to_le16(0x2000),\n\tSE_RM_CONTROL_VALID\t\t= cpu_to_le16(0x4000),\n\tSE_SELF_RELATIVE\t\t= cpu_to_le16(0x8000)\n} __attribute__ ((__packed__));\n\ntypedef le16 SECURITY_DESCRIPTOR_CONTROL;\n\n \ntypedef struct {\n\tu8 revision;\t \n\tu8 alignment;\n\tSECURITY_DESCRIPTOR_CONTROL control;  \n\tle32 owner;\t \n\tle32 group;\t \n\tle32 sacl;\t \n\tle32 dacl;\t \n \n} __attribute__ ((__packed__)) SECURITY_DESCRIPTOR_RELATIVE;\n\n \ntypedef struct {\n\tu8 revision;\t \n\tu8 alignment;\n\tSECURITY_DESCRIPTOR_CONTROL control;\t \n\tSID *owner;\t \n\tSID *group;\t \n\tACL *sacl;\t \n\tACL *dacl;\t \n} __attribute__ ((__packed__)) SECURITY_DESCRIPTOR;\n\n \ntypedef enum {\n\t \n\tSECURITY_DESCRIPTOR_REVISION\t= 1,\n\tSECURITY_DESCRIPTOR_REVISION1\t= 1,\n\n\t \n\tSECURITY_DESCRIPTOR_MIN_LENGTH\t= sizeof(SECURITY_DESCRIPTOR),\n} SECURITY_DESCRIPTOR_CONSTANTS;\n\n \ntypedef SECURITY_DESCRIPTOR_RELATIVE SECURITY_DESCRIPTOR_ATTR;\n\n \n\n \ntypedef struct {\n\tle32 hash;\t   \n\tle32 security_id;  \n\tle64 offset;\t   \n\tle32 length;\t   \n} __attribute__ ((__packed__)) SECURITY_DESCRIPTOR_HEADER;\n\n \ntypedef struct {\n \n \n\tle32 hash;\t   \n\tle32 security_id;  \n\tle64 offset;\t   \n\tle32 length;\t   \n \tSECURITY_DESCRIPTOR_RELATIVE sid;  \n} __attribute__ ((__packed__)) SDS_ENTRY;\n\n \ntypedef struct {\n\tle32 security_id;  \n} __attribute__ ((__packed__)) SII_INDEX_KEY;\n\n \ntypedef struct {\n\tle32 hash;\t   \n\tle32 security_id;  \n} __attribute__ ((__packed__)) SDH_INDEX_KEY;\n\n \ntypedef struct {\n\tntfschar name[0];\t \n} __attribute__ ((__packed__)) VOLUME_NAME;\n\n \nenum {\n\tVOLUME_IS_DIRTY\t\t\t= cpu_to_le16(0x0001),\n\tVOLUME_RESIZE_LOG_FILE\t\t= cpu_to_le16(0x0002),\n\tVOLUME_UPGRADE_ON_MOUNT\t\t= cpu_to_le16(0x0004),\n\tVOLUME_MOUNTED_ON_NT4\t\t= cpu_to_le16(0x0008),\n\n\tVOLUME_DELETE_USN_UNDERWAY\t= cpu_to_le16(0x0010),\n\tVOLUME_REPAIR_OBJECT_ID\t\t= cpu_to_le16(0x0020),\n\n\tVOLUME_CHKDSK_UNDERWAY\t\t= cpu_to_le16(0x4000),\n\tVOLUME_MODIFIED_BY_CHKDSK\t= cpu_to_le16(0x8000),\n\n\tVOLUME_FLAGS_MASK\t\t= cpu_to_le16(0xc03f),\n\n\t \n\tVOLUME_MUST_MOUNT_RO_MASK\t= cpu_to_le16(0xc027),\n} __attribute__ ((__packed__));\n\ntypedef le16 VOLUME_FLAGS;\n\n \ntypedef struct {\n\tle64 reserved;\t\t \n\tu8 major_ver;\t\t \n\tu8 minor_ver;\t\t \n\tVOLUME_FLAGS flags;\t \n} __attribute__ ((__packed__)) VOLUME_INFORMATION;\n\n \ntypedef struct {\n\tu8 data[0];\t\t \n} __attribute__ ((__packed__)) DATA_ATTR;\n\n \nenum {\n\t \n\tSMALL_INDEX = 0,  \n\tLARGE_INDEX = 1,  \n\t \n\tLEAF_NODE  = 0,  \n\tINDEX_NODE = 1,  \n\tNODE_MASK  = 1,  \n} __attribute__ ((__packed__));\n\ntypedef u8 INDEX_HEADER_FLAGS;\n\n \ntypedef struct {\n\tle32 entries_offset;\t\t \n\tle32 index_length;\t\t \n\tle32 allocated_size;\t\t \n\t \n\tINDEX_HEADER_FLAGS flags;\t \n\tu8 reserved[3];\t\t\t \n} __attribute__ ((__packed__)) INDEX_HEADER;\n\n \ntypedef struct {\n\tATTR_TYPE type;\t\t\t \n\tCOLLATION_RULE collation_rule;\t \n\tle32 index_block_size;\t\t \n\tu8 clusters_per_index_block;\t \n\tu8 reserved[3];\t\t\t \n\tINDEX_HEADER index;\t\t \n} __attribute__ ((__packed__)) INDEX_ROOT;\n\n \ntypedef struct {\n \n\tNTFS_RECORD_TYPE magic;\t \n\tle16 usa_ofs;\t\t \n\tle16 usa_count;\t\t \n\n \tsle64 lsn;\t\t \n \tleVCN index_block_vcn;\t \n \tINDEX_HEADER index;\t \n \n \n} __attribute__ ((__packed__)) INDEX_BLOCK;\n\ntypedef INDEX_BLOCK INDEX_ALLOCATION;\n\n \ntypedef struct {\n\tle32 reparse_tag;\t \n\tleMFT_REF file_id;\t \n} __attribute__ ((__packed__)) REPARSE_INDEX_KEY;\n\n \nenum {\n\tQUOTA_FLAG_DEFAULT_LIMITS\t= cpu_to_le32(0x00000001),\n\tQUOTA_FLAG_LIMIT_REACHED\t= cpu_to_le32(0x00000002),\n\tQUOTA_FLAG_ID_DELETED\t\t= cpu_to_le32(0x00000004),\n\n\tQUOTA_FLAG_USER_MASK\t\t= cpu_to_le32(0x00000007),\n\t \n\n\t \n\tQUOTA_FLAG_TRACKING_ENABLED\t= cpu_to_le32(0x00000010),\n\tQUOTA_FLAG_ENFORCEMENT_ENABLED\t= cpu_to_le32(0x00000020),\n\tQUOTA_FLAG_TRACKING_REQUESTED\t= cpu_to_le32(0x00000040),\n\tQUOTA_FLAG_LOG_THRESHOLD\t= cpu_to_le32(0x00000080),\n\n\tQUOTA_FLAG_LOG_LIMIT\t\t= cpu_to_le32(0x00000100),\n\tQUOTA_FLAG_OUT_OF_DATE\t\t= cpu_to_le32(0x00000200),\n\tQUOTA_FLAG_CORRUPT\t\t= cpu_to_le32(0x00000400),\n\tQUOTA_FLAG_PENDING_DELETES\t= cpu_to_le32(0x00000800),\n};\n\ntypedef le32 QUOTA_FLAGS;\n\n \ntypedef struct {\n\tle32 version;\t\t \n\tQUOTA_FLAGS flags;\t \n\tle64 bytes_used;\t \n\tsle64 change_time;\t \n\tsle64 threshold;\t \n\tsle64 limit;\t\t \n\tsle64 exceeded_time;\t \n\tSID sid;\t\t \n} __attribute__ ((__packed__)) QUOTA_CONTROL_ENTRY;\n\n \nenum {\n\tQUOTA_INVALID_ID\t= cpu_to_le32(0x00000000),\n\tQUOTA_DEFAULTS_ID\t= cpu_to_le32(0x00000001),\n\tQUOTA_FIRST_USER_ID\t= cpu_to_le32(0x00000100),\n};\n\n \ntypedef enum {\n\t \n\tQUOTA_VERSION\t= 2,\n} QUOTA_CONTROL_ENTRY_CONSTANTS;\n\n \nenum {\n\tINDEX_ENTRY_NODE = cpu_to_le16(1),  \n\tINDEX_ENTRY_END  = cpu_to_le16(2),  \n\n\tINDEX_ENTRY_SPACE_FILLER = cpu_to_le16(0xffff),  \n} __attribute__ ((__packed__));\n\ntypedef le16 INDEX_ENTRY_FLAGS;\n\n \ntypedef struct {\n \tunion {\n\t\tstruct {  \n\t\t\tleMFT_REF indexed_file;\t \n\t\t} __attribute__ ((__packed__)) dir;\n\t\tstruct {  \n\t\t\tle16 data_offset;\t \n\t\t\tle16 data_length;\t \n\t\t\tle32 reservedV;\t\t \n\t\t} __attribute__ ((__packed__)) vi;\n\t} __attribute__ ((__packed__)) data;\n \tle16 length;\t\t  \n \tle16 key_length;\t  \n \tINDEX_ENTRY_FLAGS flags;  \n \tle16 reserved;\t\t  \n \n} __attribute__ ((__packed__)) INDEX_ENTRY_HEADER;\n\n \ntypedef struct {\n \n \n\tunion {\n\t\tstruct {  \n\t\t\tleMFT_REF indexed_file;\t \n\t\t} __attribute__ ((__packed__)) dir;\n\t\tstruct {  \n\t\t\tle16 data_offset;\t \n\t\t\tle16 data_length;\t \n\t\t\tle32 reservedV;\t\t \n\t\t} __attribute__ ((__packed__)) vi;\n\t} __attribute__ ((__packed__)) data;\n\tle16 length;\t\t  \n\tle16 key_length;\t  \n\tINDEX_ENTRY_FLAGS flags;  \n\tle16 reserved;\t\t  \n\n \tunion {\t\t \n\t\tFILE_NAME_ATTR file_name; \n\t\tSII_INDEX_KEY sii;\t \n\t\tSDH_INDEX_KEY sdh;\t \n\t\tGUID object_id;\t\t \n\t\tREPARSE_INDEX_KEY reparse;\t \n\t\tSID sid;\t\t \n\t\tle32 owner_id;\t\t \n\t} __attribute__ ((__packed__)) key;\n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n} __attribute__ ((__packed__)) INDEX_ENTRY;\n\n \ntypedef struct {\n\tu8 bitmap[0];\t\t\t \n} __attribute__ ((__packed__)) BITMAP_ATTR;\n\n \nenum {\n\tIO_REPARSE_TAG_IS_ALIAS\t\t= cpu_to_le32(0x20000000),\n\tIO_REPARSE_TAG_IS_HIGH_LATENCY\t= cpu_to_le32(0x40000000),\n\tIO_REPARSE_TAG_IS_MICROSOFT\t= cpu_to_le32(0x80000000),\n\n\tIO_REPARSE_TAG_RESERVED_ZERO\t= cpu_to_le32(0x00000000),\n\tIO_REPARSE_TAG_RESERVED_ONE\t= cpu_to_le32(0x00000001),\n\tIO_REPARSE_TAG_RESERVED_RANGE\t= cpu_to_le32(0x00000001),\n\n\tIO_REPARSE_TAG_NSS\t\t= cpu_to_le32(0x68000005),\n\tIO_REPARSE_TAG_NSS_RECOVER\t= cpu_to_le32(0x68000006),\n\tIO_REPARSE_TAG_SIS\t\t= cpu_to_le32(0x68000007),\n\tIO_REPARSE_TAG_DFS\t\t= cpu_to_le32(0x68000008),\n\n\tIO_REPARSE_TAG_MOUNT_POINT\t= cpu_to_le32(0x88000003),\n\n\tIO_REPARSE_TAG_HSM\t\t= cpu_to_le32(0xa8000004),\n\n\tIO_REPARSE_TAG_SYMBOLIC_LINK\t= cpu_to_le32(0xe8000000),\n\n\tIO_REPARSE_TAG_VALID_VALUES\t= cpu_to_le32(0xe000ffff),\n};\n\n \ntypedef struct {\n\tle32 reparse_tag;\t\t \n\tle16 reparse_data_length;\t \n\tle16 reserved;\t\t\t \n\tu8 reparse_data[0];\t\t \n} __attribute__ ((__packed__)) REPARSE_POINT;\n\n \ntypedef struct {\n\tle16 ea_length;\t\t \n\tle16 need_ea_count;\t \n\tle32 ea_query_length;\t \n} __attribute__ ((__packed__)) EA_INFORMATION;\n\n \nenum {\n\tNEED_EA\t= 0x80\t\t \n} __attribute__ ((__packed__));\n\ntypedef u8 EA_FLAGS;\n\n \ntypedef struct {\n\tle32 next_entry_offset;\t \n\tEA_FLAGS flags;\t\t \n\tu8 ea_name_length;\t \n\tle16 ea_value_length;\t \n\tu8 ea_name[0];\t\t \n\tu8 ea_value[0];\t\t \n} __attribute__ ((__packed__)) EA_ATTR;\n\n \ntypedef struct {\n\t \n} __attribute__ ((__packed__)) PROPERTY_SET;\n\n \ntypedef struct {\n\t \n\t \n\t\n} __attribute__ ((__packed__)) LOGGED_UTILITY_STREAM, EFS_ATTR;\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}