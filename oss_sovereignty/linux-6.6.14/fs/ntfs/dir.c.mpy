{
  "module_name": "dir.c",
  "hash_id": "216d79202977ed056898f3f226f09a07795b7528b1b8d301dddccd30ba585f3b",
  "original_prompt": "Ingested from linux-6.6.14/fs/ntfs/dir.c",
  "human_readable_source": "\n \n\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include \"mft.h\"\n#include \"debug.h\"\n#include \"ntfs.h\"\n\n \nntfschar I30[5] = { cpu_to_le16('$'), cpu_to_le16('I'),\n\t\tcpu_to_le16('3'),\tcpu_to_le16('0'), 0 };\n\n \nMFT_REF ntfs_lookup_inode_by_name(ntfs_inode *dir_ni, const ntfschar *uname,\n\t\tconst int uname_len, ntfs_name **res)\n{\n\tntfs_volume *vol = dir_ni->vol;\n\tstruct super_block *sb = vol->sb;\n\tMFT_RECORD *m;\n\tINDEX_ROOT *ir;\n\tINDEX_ENTRY *ie;\n\tINDEX_ALLOCATION *ia;\n\tu8 *index_end;\n\tu64 mref;\n\tntfs_attr_search_ctx *ctx;\n\tint err, rc;\n\tVCN vcn, old_vcn;\n\tstruct address_space *ia_mapping;\n\tstruct page *page;\n\tu8 *kaddr;\n\tntfs_name *name = NULL;\n\n\tBUG_ON(!S_ISDIR(VFS_I(dir_ni)->i_mode));\n\tBUG_ON(NInoAttr(dir_ni));\n\t \n\tm = map_mft_record(dir_ni);\n\tif (IS_ERR(m)) {\n\t\tntfs_error(sb, \"map_mft_record() failed with error code %ld.\",\n\t\t\t\t-PTR_ERR(m));\n\t\treturn ERR_MREF(PTR_ERR(m));\n\t}\n\tctx = ntfs_attr_get_search_ctx(dir_ni, m);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\t \n\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE, 0, NULL,\n\t\t\t0, ctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\tntfs_error(sb, \"Index root attribute missing in \"\n\t\t\t\t\t\"directory inode 0x%lx.\",\n\t\t\t\t\tdir_ni->mft_no);\n\t\t\terr = -EIO;\n\t\t}\n\t\tgoto err_out;\n\t}\n\t \n\tir = (INDEX_ROOT*)((u8*)ctx->attr +\n\t\t\tle16_to_cpu(ctx->attr->data.resident.value_offset));\n\tindex_end = (u8*)&ir->index + le32_to_cpu(ir->index.index_length);\n\t \n\tie = (INDEX_ENTRY*)((u8*)&ir->index +\n\t\t\tle32_to_cpu(ir->index.entries_offset));\n\t \n\tfor (;; ie = (INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie->length))) {\n\t\t \n\t\tif ((u8*)ie < (u8*)ctx->mrec || (u8*)ie +\n\t\t\t\tsizeof(INDEX_ENTRY_HEADER) > index_end ||\n\t\t\t\t(u8*)ie + le16_to_cpu(ie->key_length) >\n\t\t\t\tindex_end)\n\t\t\tgoto dir_err_out;\n\t\t \n\t\tif (ie->flags & INDEX_ENTRY_END)\n\t\t\tbreak;\n\t\t \n\t\tif (ntfs_are_names_equal(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length,\n\t\t\t\tCASE_SENSITIVE, vol->upcase, vol->upcase_len)) {\nfound_it:\n\t\t\t \n\t\t\tif (ie->key.file_name.file_name_type == FILE_NAME_DOS) {\n\t\t\t\tif (!name) {\n\t\t\t\t\tname = kmalloc(sizeof(ntfs_name),\n\t\t\t\t\t\t\tGFP_NOFS);\n\t\t\t\t\tif (!name) {\n\t\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\t\tgoto err_out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tname->mref = le64_to_cpu(\n\t\t\t\t\t\tie->data.dir.indexed_file);\n\t\t\t\tname->type = FILE_NAME_DOS;\n\t\t\t\tname->len = 0;\n\t\t\t\t*res = name;\n\t\t\t} else {\n\t\t\t\tkfree(name);\n\t\t\t\t*res = NULL;\n\t\t\t}\n\t\t\tmref = le64_to_cpu(ie->data.dir.indexed_file);\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(dir_ni);\n\t\t\treturn mref;\n\t\t}\n\t\t \n\t\tif (!NVolCaseSensitive(vol) &&\n\t\t\t\tie->key.file_name.file_name_type &&\n\t\t\t\tntfs_are_names_equal(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length,\n\t\t\t\tIGNORE_CASE, vol->upcase, vol->upcase_len)) {\n\t\t\tint name_size = sizeof(ntfs_name);\n\t\t\tu8 type = ie->key.file_name.file_name_type;\n\t\t\tu8 len = ie->key.file_name.file_name_length;\n\n\t\t\t \n\t\t\tif (name) {\n\t\t\t\tntfs_error(sb, \"Found already allocated name \"\n\t\t\t\t\t\t\"in phase 1. Please run chkdsk \"\n\t\t\t\t\t\t\"and if that doesn't find any \"\n\t\t\t\t\t\t\"errors please report you saw \"\n\t\t\t\t\t\t\"this message to \"\n\t\t\t\t\t\t\"linux-ntfs-dev@lists.\"\n\t\t\t\t\t\t\"sourceforge.net.\");\n\t\t\t\tgoto dir_err_out;\n\t\t\t}\n\n\t\t\tif (type != FILE_NAME_DOS)\n\t\t\t\tname_size += len * sizeof(ntfschar);\n\t\t\tname = kmalloc(name_size, GFP_NOFS);\n\t\t\tif (!name) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\tname->mref = le64_to_cpu(ie->data.dir.indexed_file);\n\t\t\tname->type = type;\n\t\t\tif (type != FILE_NAME_DOS) {\n\t\t\t\tname->len = len;\n\t\t\t\tmemcpy(name->name, ie->key.file_name.file_name,\n\t\t\t\t\t\tlen * sizeof(ntfschar));\n\t\t\t} else\n\t\t\t\tname->len = 0;\n\t\t\t*res = name;\n\t\t}\n\t\t \n\t\trc = ntfs_collate_names(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length, 1,\n\t\t\t\tIGNORE_CASE, vol->upcase, vol->upcase_len);\n\t\t \n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\t \n\t\tif (rc)\n\t\t\tcontinue;\n\t\t \n\t\trc = ntfs_collate_names(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length, 1,\n\t\t\t\tCASE_SENSITIVE, vol->upcase, vol->upcase_len);\n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\tif (rc)\n\t\t\tcontinue;\n\t\t \n\t\tgoto found_it;\n\t}\n\t \n\tif (!(ie->flags & INDEX_ENTRY_NODE)) {\n\t\tif (name) {\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(dir_ni);\n\t\t\treturn name->mref;\n\t\t}\n\t\tntfs_debug(\"Entry not found.\");\n\t\terr = -ENOENT;\n\t\tgoto err_out;\n\t}  \n\t \n\tif (!NInoIndexAllocPresent(dir_ni)) {\n\t\tntfs_error(sb, \"No index allocation attribute but index entry \"\n\t\t\t\t\"requires one. Directory inode 0x%lx is \"\n\t\t\t\t\"corrupt or driver bug.\", dir_ni->mft_no);\n\t\tgoto err_out;\n\t}\n\t \n\tvcn = sle64_to_cpup((sle64*)((u8*)ie + le16_to_cpu(ie->length) - 8));\n\tia_mapping = VFS_I(dir_ni)->i_mapping;\n\t \n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(dir_ni);\n\tm = NULL;\n\tctx = NULL;\ndescend_into_child_node:\n\t \n\tpage = ntfs_map_page(ia_mapping, vcn <<\n\t\t\tdir_ni->itype.index.vcn_size_bits >> PAGE_SHIFT);\n\tif (IS_ERR(page)) {\n\t\tntfs_error(sb, \"Failed to map directory index page, error %ld.\",\n\t\t\t\t-PTR_ERR(page));\n\t\terr = PTR_ERR(page);\n\t\tgoto err_out;\n\t}\n\tlock_page(page);\n\tkaddr = (u8*)page_address(page);\nfast_descend_into_child_node:\n\t \n\tia = (INDEX_ALLOCATION*)(kaddr + ((vcn <<\n\t\t\tdir_ni->itype.index.vcn_size_bits) & ~PAGE_MASK));\n\t \n\tif ((u8*)ia < kaddr || (u8*)ia > kaddr + PAGE_SIZE) {\n\t\tntfs_error(sb, \"Out of bounds check failed. Corrupt directory \"\n\t\t\t\t\"inode 0x%lx or driver bug.\", dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\t \n\tif (unlikely(!ntfs_is_indx_record(ia->magic))) {\n\t\tntfs_error(sb, \"Directory index record with vcn 0x%llx is \"\n\t\t\t\t\"corrupt.  Corrupt inode 0x%lx.  Run chkdsk.\",\n\t\t\t\t(unsigned long long)vcn, dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\tif (sle64_to_cpu(ia->index_block_vcn) != vcn) {\n\t\tntfs_error(sb, \"Actual VCN (0x%llx) of index buffer is \"\n\t\t\t\t\"different from expected VCN (0x%llx). \"\n\t\t\t\t\"Directory inode 0x%lx is corrupt or driver \"\n\t\t\t\t\"bug.\", (unsigned long long)\n\t\t\t\tsle64_to_cpu(ia->index_block_vcn),\n\t\t\t\t(unsigned long long)vcn, dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\tif (le32_to_cpu(ia->index.allocated_size) + 0x18 !=\n\t\t\tdir_ni->itype.index.block_size) {\n\t\tntfs_error(sb, \"Index buffer (VCN 0x%llx) of directory inode \"\n\t\t\t\t\"0x%lx has a size (%u) differing from the \"\n\t\t\t\t\"directory specified size (%u). Directory \"\n\t\t\t\t\"inode is corrupt or driver bug.\",\n\t\t\t\t(unsigned long long)vcn, dir_ni->mft_no,\n\t\t\t\tle32_to_cpu(ia->index.allocated_size) + 0x18,\n\t\t\t\tdir_ni->itype.index.block_size);\n\t\tgoto unm_err_out;\n\t}\n\tindex_end = (u8*)ia + dir_ni->itype.index.block_size;\n\tif (index_end > kaddr + PAGE_SIZE) {\n\t\tntfs_error(sb, \"Index buffer (VCN 0x%llx) of directory inode \"\n\t\t\t\t\"0x%lx crosses page boundary. Impossible! \"\n\t\t\t\t\"Cannot access! This is probably a bug in the \"\n\t\t\t\t\"driver.\", (unsigned long long)vcn,\n\t\t\t\tdir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\tindex_end = (u8*)&ia->index + le32_to_cpu(ia->index.index_length);\n\tif (index_end > (u8*)ia + dir_ni->itype.index.block_size) {\n\t\tntfs_error(sb, \"Size of index buffer (VCN 0x%llx) of directory \"\n\t\t\t\t\"inode 0x%lx exceeds maximum size.\",\n\t\t\t\t(unsigned long long)vcn, dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\t \n\tie = (INDEX_ENTRY*)((u8*)&ia->index +\n\t\t\tle32_to_cpu(ia->index.entries_offset));\n\t \n\tfor (;; ie = (INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie->length))) {\n\t\t \n\t\tif ((u8*)ie < (u8*)ia || (u8*)ie +\n\t\t\t\tsizeof(INDEX_ENTRY_HEADER) > index_end ||\n\t\t\t\t(u8*)ie + le16_to_cpu(ie->key_length) >\n\t\t\t\tindex_end) {\n\t\t\tntfs_error(sb, \"Index entry out of bounds in \"\n\t\t\t\t\t\"directory inode 0x%lx.\",\n\t\t\t\t\tdir_ni->mft_no);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t \n\t\tif (ie->flags & INDEX_ENTRY_END)\n\t\t\tbreak;\n\t\t \n\t\tif (ntfs_are_names_equal(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length,\n\t\t\t\tCASE_SENSITIVE, vol->upcase, vol->upcase_len)) {\nfound_it2:\n\t\t\t \n\t\t\tif (ie->key.file_name.file_name_type == FILE_NAME_DOS) {\n\t\t\t\tif (!name) {\n\t\t\t\t\tname = kmalloc(sizeof(ntfs_name),\n\t\t\t\t\t\t\tGFP_NOFS);\n\t\t\t\t\tif (!name) {\n\t\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tname->mref = le64_to_cpu(\n\t\t\t\t\t\tie->data.dir.indexed_file);\n\t\t\t\tname->type = FILE_NAME_DOS;\n\t\t\t\tname->len = 0;\n\t\t\t\t*res = name;\n\t\t\t} else {\n\t\t\t\tkfree(name);\n\t\t\t\t*res = NULL;\n\t\t\t}\n\t\t\tmref = le64_to_cpu(ie->data.dir.indexed_file);\n\t\t\tunlock_page(page);\n\t\t\tntfs_unmap_page(page);\n\t\t\treturn mref;\n\t\t}\n\t\t \n\t\tif (!NVolCaseSensitive(vol) &&\n\t\t\t\tie->key.file_name.file_name_type &&\n\t\t\t\tntfs_are_names_equal(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length,\n\t\t\t\tIGNORE_CASE, vol->upcase, vol->upcase_len)) {\n\t\t\tint name_size = sizeof(ntfs_name);\n\t\t\tu8 type = ie->key.file_name.file_name_type;\n\t\t\tu8 len = ie->key.file_name.file_name_length;\n\n\t\t\t \n\t\t\tif (name) {\n\t\t\t\tntfs_error(sb, \"Found already allocated name \"\n\t\t\t\t\t\t\"in phase 2. Please run chkdsk \"\n\t\t\t\t\t\t\"and if that doesn't find any \"\n\t\t\t\t\t\t\"errors please report you saw \"\n\t\t\t\t\t\t\"this message to \"\n\t\t\t\t\t\t\"linux-ntfs-dev@lists.\"\n\t\t\t\t\t\t\"sourceforge.net.\");\n\t\t\t\tunlock_page(page);\n\t\t\t\tntfs_unmap_page(page);\n\t\t\t\tgoto dir_err_out;\n\t\t\t}\n\n\t\t\tif (type != FILE_NAME_DOS)\n\t\t\t\tname_size += len * sizeof(ntfschar);\n\t\t\tname = kmalloc(name_size, GFP_NOFS);\n\t\t\tif (!name) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tname->mref = le64_to_cpu(ie->data.dir.indexed_file);\n\t\t\tname->type = type;\n\t\t\tif (type != FILE_NAME_DOS) {\n\t\t\t\tname->len = len;\n\t\t\t\tmemcpy(name->name, ie->key.file_name.file_name,\n\t\t\t\t\t\tlen * sizeof(ntfschar));\n\t\t\t} else\n\t\t\t\tname->len = 0;\n\t\t\t*res = name;\n\t\t}\n\t\t \n\t\trc = ntfs_collate_names(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length, 1,\n\t\t\t\tIGNORE_CASE, vol->upcase, vol->upcase_len);\n\t\t \n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\t \n\t\tif (rc)\n\t\t\tcontinue;\n\t\t \n\t\trc = ntfs_collate_names(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length, 1,\n\t\t\t\tCASE_SENSITIVE, vol->upcase, vol->upcase_len);\n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\tif (rc)\n\t\t\tcontinue;\n\t\t \n\t\tgoto found_it2;\n\t}\n\t \n\tif (ie->flags & INDEX_ENTRY_NODE) {\n\t\tif ((ia->index.flags & NODE_MASK) == LEAF_NODE) {\n\t\t\tntfs_error(sb, \"Index entry with child node found in \"\n\t\t\t\t\t\"a leaf node in directory inode 0x%lx.\",\n\t\t\t\t\tdir_ni->mft_no);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t \n\t\told_vcn = vcn;\n\t\tvcn = sle64_to_cpup((sle64*)((u8*)ie +\n\t\t\t\tle16_to_cpu(ie->length) - 8));\n\t\tif (vcn >= 0) {\n\t\t\t \n\t\t\tif (old_vcn << vol->cluster_size_bits >>\n\t\t\t\t\tPAGE_SHIFT == vcn <<\n\t\t\t\t\tvol->cluster_size_bits >>\n\t\t\t\t\tPAGE_SHIFT)\n\t\t\t\tgoto fast_descend_into_child_node;\n\t\t\tunlock_page(page);\n\t\t\tntfs_unmap_page(page);\n\t\t\tgoto descend_into_child_node;\n\t\t}\n\t\tntfs_error(sb, \"Negative child node vcn in directory inode \"\n\t\t\t\t\"0x%lx.\", dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\t \n\tif (name) {\n\t\tunlock_page(page);\n\t\tntfs_unmap_page(page);\n\t\treturn name->mref;\n\t}\n\tntfs_debug(\"Entry not found.\");\n\terr = -ENOENT;\nunm_err_out:\n\tunlock_page(page);\n\tntfs_unmap_page(page);\nerr_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(dir_ni);\n\tif (name) {\n\t\tkfree(name);\n\t\t*res = NULL;\n\t}\n\treturn ERR_MREF(err);\ndir_err_out:\n\tntfs_error(sb, \"Corrupt directory.  Aborting lookup.\");\n\tgoto err_out;\n}\n\n#if 0\n\n \n \n \n \n\n \nu64 ntfs_lookup_inode_by_name(ntfs_inode *dir_ni, const ntfschar *uname,\n\t\tconst int uname_len)\n{\n\tntfs_volume *vol = dir_ni->vol;\n\tstruct super_block *sb = vol->sb;\n\tMFT_RECORD *m;\n\tINDEX_ROOT *ir;\n\tINDEX_ENTRY *ie;\n\tINDEX_ALLOCATION *ia;\n\tu8 *index_end;\n\tu64 mref;\n\tntfs_attr_search_ctx *ctx;\n\tint err, rc;\n\tIGNORE_CASE_BOOL ic;\n\tVCN vcn, old_vcn;\n\tstruct address_space *ia_mapping;\n\tstruct page *page;\n\tu8 *kaddr;\n\n\t \n\tm = map_mft_record(dir_ni);\n\tif (IS_ERR(m)) {\n\t\tntfs_error(sb, \"map_mft_record() failed with error code %ld.\",\n\t\t\t\t-PTR_ERR(m));\n\t\treturn ERR_MREF(PTR_ERR(m));\n\t}\n\tctx = ntfs_attr_get_search_ctx(dir_ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\t \n\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE, 0, NULL,\n\t\t\t0, ctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\tntfs_error(sb, \"Index root attribute missing in \"\n\t\t\t\t\t\"directory inode 0x%lx.\",\n\t\t\t\t\tdir_ni->mft_no);\n\t\t\terr = -EIO;\n\t\t}\n\t\tgoto err_out;\n\t}\n\t \n\tir = (INDEX_ROOT*)((u8*)ctx->attr +\n\t\t\tle16_to_cpu(ctx->attr->data.resident.value_offset));\n\tindex_end = (u8*)&ir->index + le32_to_cpu(ir->index.index_length);\n\t \n\tie = (INDEX_ENTRY*)((u8*)&ir->index +\n\t\t\tle32_to_cpu(ir->index.entries_offset));\n\t \n\tfor (;; ie = (INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie->length))) {\n\t\t \n\t\tif ((u8*)ie < (u8*)ctx->mrec || (u8*)ie +\n\t\t\t\tsizeof(INDEX_ENTRY_HEADER) > index_end ||\n\t\t\t\t(u8*)ie + le16_to_cpu(ie->key_length) >\n\t\t\t\tindex_end)\n\t\t\tgoto dir_err_out;\n\t\t \n\t\tif (ie->flags & INDEX_ENTRY_END)\n\t\t\tbreak;\n\t\t \n\t\tic = ie->key.file_name.file_name_type ? IGNORE_CASE :\n\t\t\t\tCASE_SENSITIVE;\n\t\t \n\t\tif (ntfs_are_names_equal(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length, ic,\n\t\t\t\tvol->upcase, vol->upcase_len)) {\nfound_it:\n\t\t\tmref = le64_to_cpu(ie->data.dir.indexed_file);\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(dir_ni);\n\t\t\treturn mref;\n\t\t}\n\t\t \n\t\trc = ntfs_collate_names(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length, 1,\n\t\t\t\tIGNORE_CASE, vol->upcase, vol->upcase_len);\n\t\t \n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\t \n\t\tif (rc)\n\t\t\tcontinue;\n\t\t \n\t\trc = ntfs_collate_names(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length, 1,\n\t\t\t\tCASE_SENSITIVE, vol->upcase, vol->upcase_len);\n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\tif (rc)\n\t\t\tcontinue;\n\t\t \n\t\tgoto found_it;\n\t}\n\t \n\tif (!(ie->flags & INDEX_ENTRY_NODE)) {\n\t\t \n\t\terr = -ENOENT;\n\t\tgoto err_out;\n\t}  \n\t \n\tif (!NInoIndexAllocPresent(dir_ni)) {\n\t\tntfs_error(sb, \"No index allocation attribute but index entry \"\n\t\t\t\t\"requires one. Directory inode 0x%lx is \"\n\t\t\t\t\"corrupt or driver bug.\", dir_ni->mft_no);\n\t\tgoto err_out;\n\t}\n\t \n\tvcn = sle64_to_cpup((u8*)ie + le16_to_cpu(ie->length) - 8);\n\tia_mapping = VFS_I(dir_ni)->i_mapping;\n\t \n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(dir_ni);\n\tm = NULL;\n\tctx = NULL;\ndescend_into_child_node:\n\t \n\tpage = ntfs_map_page(ia_mapping, vcn <<\n\t\t\tdir_ni->itype.index.vcn_size_bits >> PAGE_SHIFT);\n\tif (IS_ERR(page)) {\n\t\tntfs_error(sb, \"Failed to map directory index page, error %ld.\",\n\t\t\t\t-PTR_ERR(page));\n\t\terr = PTR_ERR(page);\n\t\tgoto err_out;\n\t}\n\tlock_page(page);\n\tkaddr = (u8*)page_address(page);\nfast_descend_into_child_node:\n\t \n\tia = (INDEX_ALLOCATION*)(kaddr + ((vcn <<\n\t\t\tdir_ni->itype.index.vcn_size_bits) & ~PAGE_MASK));\n\t \n\tif ((u8*)ia < kaddr || (u8*)ia > kaddr + PAGE_SIZE) {\n\t\tntfs_error(sb, \"Out of bounds check failed. Corrupt directory \"\n\t\t\t\t\"inode 0x%lx or driver bug.\", dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\t \n\tif (unlikely(!ntfs_is_indx_record(ia->magic))) {\n\t\tntfs_error(sb, \"Directory index record with vcn 0x%llx is \"\n\t\t\t\t\"corrupt.  Corrupt inode 0x%lx.  Run chkdsk.\",\n\t\t\t\t(unsigned long long)vcn, dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\tif (sle64_to_cpu(ia->index_block_vcn) != vcn) {\n\t\tntfs_error(sb, \"Actual VCN (0x%llx) of index buffer is \"\n\t\t\t\t\"different from expected VCN (0x%llx). \"\n\t\t\t\t\"Directory inode 0x%lx is corrupt or driver \"\n\t\t\t\t\"bug.\", (unsigned long long)\n\t\t\t\tsle64_to_cpu(ia->index_block_vcn),\n\t\t\t\t(unsigned long long)vcn, dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\tif (le32_to_cpu(ia->index.allocated_size) + 0x18 !=\n\t\t\tdir_ni->itype.index.block_size) {\n\t\tntfs_error(sb, \"Index buffer (VCN 0x%llx) of directory inode \"\n\t\t\t\t\"0x%lx has a size (%u) differing from the \"\n\t\t\t\t\"directory specified size (%u). Directory \"\n\t\t\t\t\"inode is corrupt or driver bug.\",\n\t\t\t\t(unsigned long long)vcn, dir_ni->mft_no,\n\t\t\t\tle32_to_cpu(ia->index.allocated_size) + 0x18,\n\t\t\t\tdir_ni->itype.index.block_size);\n\t\tgoto unm_err_out;\n\t}\n\tindex_end = (u8*)ia + dir_ni->itype.index.block_size;\n\tif (index_end > kaddr + PAGE_SIZE) {\n\t\tntfs_error(sb, \"Index buffer (VCN 0x%llx) of directory inode \"\n\t\t\t\t\"0x%lx crosses page boundary. Impossible! \"\n\t\t\t\t\"Cannot access! This is probably a bug in the \"\n\t\t\t\t\"driver.\", (unsigned long long)vcn,\n\t\t\t\tdir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\tindex_end = (u8*)&ia->index + le32_to_cpu(ia->index.index_length);\n\tif (index_end > (u8*)ia + dir_ni->itype.index.block_size) {\n\t\tntfs_error(sb, \"Size of index buffer (VCN 0x%llx) of directory \"\n\t\t\t\t\"inode 0x%lx exceeds maximum size.\",\n\t\t\t\t(unsigned long long)vcn, dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\t \n\tie = (INDEX_ENTRY*)((u8*)&ia->index +\n\t\t\tle32_to_cpu(ia->index.entries_offset));\n\t \n\tfor (;; ie = (INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie->length))) {\n\t\t \n\t\tif ((u8*)ie < (u8*)ia || (u8*)ie +\n\t\t\t\tsizeof(INDEX_ENTRY_HEADER) > index_end ||\n\t\t\t\t(u8*)ie + le16_to_cpu(ie->key_length) >\n\t\t\t\tindex_end) {\n\t\t\tntfs_error(sb, \"Index entry out of bounds in \"\n\t\t\t\t\t\"directory inode 0x%lx.\",\n\t\t\t\t\tdir_ni->mft_no);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t \n\t\tif (ie->flags & INDEX_ENTRY_END)\n\t\t\tbreak;\n\t\t \n\t\tic = ie->key.file_name.file_name_type ? IGNORE_CASE :\n\t\t\t\tCASE_SENSITIVE;\n\t\t \n\t\tif (ntfs_are_names_equal(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length, ic,\n\t\t\t\tvol->upcase, vol->upcase_len)) {\nfound_it2:\n\t\t\tmref = le64_to_cpu(ie->data.dir.indexed_file);\n\t\t\tunlock_page(page);\n\t\t\tntfs_unmap_page(page);\n\t\t\treturn mref;\n\t\t}\n\t\t \n\t\trc = ntfs_collate_names(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length, 1,\n\t\t\t\tIGNORE_CASE, vol->upcase, vol->upcase_len);\n\t\t \n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\t \n\t\tif (rc)\n\t\t\tcontinue;\n\t\t \n\t\trc = ntfs_collate_names(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length, 1,\n\t\t\t\tCASE_SENSITIVE, vol->upcase, vol->upcase_len);\n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\tif (rc)\n\t\t\tcontinue;\n\t\t \n\t\tgoto found_it2;\n\t}\n\t \n\tif (ie->flags & INDEX_ENTRY_NODE) {\n\t\tif ((ia->index.flags & NODE_MASK) == LEAF_NODE) {\n\t\t\tntfs_error(sb, \"Index entry with child node found in \"\n\t\t\t\t\t\"a leaf node in directory inode 0x%lx.\",\n\t\t\t\t\tdir_ni->mft_no);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t \n\t\told_vcn = vcn;\n\t\tvcn = sle64_to_cpup((u8*)ie + le16_to_cpu(ie->length) - 8);\n\t\tif (vcn >= 0) {\n\t\t\t \n\t\t\tif (old_vcn << vol->cluster_size_bits >>\n\t\t\t\t\tPAGE_SHIFT == vcn <<\n\t\t\t\t\tvol->cluster_size_bits >>\n\t\t\t\t\tPAGE_SHIFT)\n\t\t\t\tgoto fast_descend_into_child_node;\n\t\t\tunlock_page(page);\n\t\t\tntfs_unmap_page(page);\n\t\t\tgoto descend_into_child_node;\n\t\t}\n\t\tntfs_error(sb, \"Negative child node vcn in directory inode \"\n\t\t\t\t\"0x%lx.\", dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\t \n\tntfs_debug(\"Entry not found.\");\n\terr = -ENOENT;\nunm_err_out:\n\tunlock_page(page);\n\tntfs_unmap_page(page);\nerr_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(dir_ni);\n\treturn ERR_MREF(err);\ndir_err_out:\n\tntfs_error(sb, \"Corrupt directory. Aborting lookup.\");\n\tgoto err_out;\n}\n\n#endif\n\n \nstatic inline int ntfs_filldir(ntfs_volume *vol,\n\t\tntfs_inode *ndir, struct page *ia_page, INDEX_ENTRY *ie,\n\t\tu8 *name, struct dir_context *actor)\n{\n\tunsigned long mref;\n\tint name_len;\n\tunsigned dt_type;\n\tFILE_NAME_TYPE_FLAGS name_type;\n\n\tname_type = ie->key.file_name.file_name_type;\n\tif (name_type == FILE_NAME_DOS) {\n\t\tntfs_debug(\"Skipping DOS name space entry.\");\n\t\treturn 0;\n\t}\n\tif (MREF_LE(ie->data.dir.indexed_file) == FILE_root) {\n\t\tntfs_debug(\"Skipping root directory self reference entry.\");\n\t\treturn 0;\n\t}\n\tif (MREF_LE(ie->data.dir.indexed_file) < FILE_first_user &&\n\t\t\t!NVolShowSystemFiles(vol)) {\n\t\tntfs_debug(\"Skipping system file.\");\n\t\treturn 0;\n\t}\n\tname_len = ntfs_ucstonls(vol, (ntfschar*)&ie->key.file_name.file_name,\n\t\t\tie->key.file_name.file_name_length, &name,\n\t\t\tNTFS_MAX_NAME_LEN * NLS_MAX_CHARSET_SIZE + 1);\n\tif (name_len <= 0) {\n\t\tntfs_warning(vol->sb, \"Skipping unrepresentable inode 0x%llx.\",\n\t\t\t\t(long long)MREF_LE(ie->data.dir.indexed_file));\n\t\treturn 0;\n\t}\n\tif (ie->key.file_name.file_attributes &\n\t\t\tFILE_ATTR_DUP_FILE_NAME_INDEX_PRESENT)\n\t\tdt_type = DT_DIR;\n\telse\n\t\tdt_type = DT_REG;\n\tmref = MREF_LE(ie->data.dir.indexed_file);\n\t \n\tif (ia_page)\n\t\tunlock_page(ia_page);\n\tntfs_debug(\"Calling filldir for %s with len %i, fpos 0x%llx, inode \"\n\t\t\t\"0x%lx, DT_%s.\", name, name_len, actor->pos, mref,\n\t\t\tdt_type == DT_DIR ? \"DIR\" : \"REG\");\n\tif (!dir_emit(actor, name, name_len, mref, dt_type))\n\t\treturn 1;\n\t \n\tif (ia_page)\n\t\tlock_page(ia_page);\n\treturn 0;\n}\n\n \nstatic int ntfs_readdir(struct file *file, struct dir_context *actor)\n{\n\ts64 ia_pos, ia_start, prev_ia_pos, bmp_pos;\n\tloff_t i_size;\n\tstruct inode *bmp_vi, *vdir = file_inode(file);\n\tstruct super_block *sb = vdir->i_sb;\n\tntfs_inode *ndir = NTFS_I(vdir);\n\tntfs_volume *vol = NTFS_SB(sb);\n\tMFT_RECORD *m;\n\tINDEX_ROOT *ir = NULL;\n\tINDEX_ENTRY *ie;\n\tINDEX_ALLOCATION *ia;\n\tu8 *name = NULL;\n\tint rc, err, ir_pos, cur_bmp_pos;\n\tstruct address_space *ia_mapping, *bmp_mapping;\n\tstruct page *bmp_page = NULL, *ia_page = NULL;\n\tu8 *kaddr, *bmp, *index_end;\n\tntfs_attr_search_ctx *ctx;\n\n\tntfs_debug(\"Entering for inode 0x%lx, fpos 0x%llx.\",\n\t\t\tvdir->i_ino, actor->pos);\n\trc = err = 0;\n\t \n\ti_size = i_size_read(vdir);\n\tif (actor->pos >= i_size + vol->mft_record_size)\n\t\treturn 0;\n\t \n\tif (!dir_emit_dots(file, actor))\n\t\treturn 0;\n\tm = NULL;\n\tctx = NULL;\n\t \n\tname = kmalloc(NTFS_MAX_NAME_LEN * NLS_MAX_CHARSET_SIZE + 1, GFP_NOFS);\n\tif (unlikely(!name)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\t \n\tif (actor->pos >= vol->mft_record_size)\n\t\tgoto skip_index_root;\n\t \n\tm = map_mft_record(ndir);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tm = NULL;\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ndir, m);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\t \n\tir_pos = (s64)actor->pos;\n\t \n\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE, 0, NULL,\n\t\t\t0, ctx);\n\tif (unlikely(err)) {\n\t\tntfs_error(sb, \"Index root attribute missing in directory \"\n\t\t\t\t\"inode 0x%lx.\", vdir->i_ino);\n\t\tgoto err_out;\n\t}\n\t \n\trc = le32_to_cpu(ctx->attr->data.resident.value_length);\n\tir = kmalloc(rc, GFP_NOFS);\n\tif (unlikely(!ir)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\t \n\tmemcpy(ir, (u8*)ctx->attr +\n\t\t\tle16_to_cpu(ctx->attr->data.resident.value_offset), rc);\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(ndir);\n\tctx = NULL;\n\tm = NULL;\n\tindex_end = (u8*)&ir->index + le32_to_cpu(ir->index.index_length);\n\t \n\tie = (INDEX_ENTRY*)((u8*)&ir->index +\n\t\t\tle32_to_cpu(ir->index.entries_offset));\n\t \n\tfor (;; ie = (INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie->length))) {\n\t\tntfs_debug(\"In index root, offset 0x%zx.\", (u8*)ie - (u8*)ir);\n\t\t \n\t\tif (unlikely((u8*)ie < (u8*)ir || (u8*)ie +\n\t\t\t\tsizeof(INDEX_ENTRY_HEADER) > index_end ||\n\t\t\t\t(u8*)ie + le16_to_cpu(ie->key_length) >\n\t\t\t\tindex_end))\n\t\t\tgoto err_out;\n\t\t \n\t\tif (ie->flags & INDEX_ENTRY_END)\n\t\t\tbreak;\n\t\t \n\t\tif (ir_pos > (u8*)ie - (u8*)ir)\n\t\t\tcontinue;\n\t\t \n\t\tactor->pos = (u8*)ie - (u8*)ir;\n\t\t \n\t\trc = ntfs_filldir(vol, ndir, NULL, ie, name, actor);\n\t\tif (rc) {\n\t\t\tkfree(ir);\n\t\t\tgoto abort;\n\t\t}\n\t}\n\t \n\tkfree(ir);\n\tir = NULL;\n\t \n\tif (!NInoIndexAllocPresent(ndir))\n\t\tgoto EOD;\n\t \n\tactor->pos = vol->mft_record_size;\nskip_index_root:\n\tkaddr = NULL;\n\tprev_ia_pos = -1LL;\n\t \n\tia_pos = (s64)actor->pos - vol->mft_record_size;\n\tia_mapping = vdir->i_mapping;\n\tntfs_debug(\"Inode 0x%lx, getting index bitmap.\", vdir->i_ino);\n\tbmp_vi = ntfs_attr_iget(vdir, AT_BITMAP, I30, 4);\n\tif (IS_ERR(bmp_vi)) {\n\t\tntfs_error(sb, \"Failed to get bitmap attribute.\");\n\t\terr = PTR_ERR(bmp_vi);\n\t\tgoto err_out;\n\t}\n\tbmp_mapping = bmp_vi->i_mapping;\n\t \n\tbmp_pos = ia_pos >> ndir->itype.index.block_size_bits;\n\tif (unlikely(bmp_pos >> 3 >= i_size_read(bmp_vi))) {\n\t\tntfs_error(sb, \"Current index allocation position exceeds \"\n\t\t\t\t\"index bitmap size.\");\n\t\tgoto iput_err_out;\n\t}\n\t \n\tcur_bmp_pos = bmp_pos & ((PAGE_SIZE * 8) - 1);\n\tbmp_pos &= ~(u64)((PAGE_SIZE * 8) - 1);\nget_next_bmp_page:\n\tntfs_debug(\"Reading bitmap with page index 0x%llx, bit ofs 0x%llx\",\n\t\t\t(unsigned long long)bmp_pos >> (3 + PAGE_SHIFT),\n\t\t\t(unsigned long long)bmp_pos &\n\t\t\t(unsigned long long)((PAGE_SIZE * 8) - 1));\n\tbmp_page = ntfs_map_page(bmp_mapping,\n\t\t\tbmp_pos >> (3 + PAGE_SHIFT));\n\tif (IS_ERR(bmp_page)) {\n\t\tntfs_error(sb, \"Reading index bitmap failed.\");\n\t\terr = PTR_ERR(bmp_page);\n\t\tbmp_page = NULL;\n\t\tgoto iput_err_out;\n\t}\n\tbmp = (u8*)page_address(bmp_page);\n\t \n\twhile (!(bmp[cur_bmp_pos >> 3] & (1 << (cur_bmp_pos & 7)))) {\nfind_next_index_buffer:\n\t\tcur_bmp_pos++;\n\t\t \n\t\tif (unlikely((cur_bmp_pos >> 3) >= PAGE_SIZE)) {\n\t\t\tntfs_unmap_page(bmp_page);\n\t\t\tbmp_pos += PAGE_SIZE * 8;\n\t\t\tcur_bmp_pos = 0;\n\t\t\tgoto get_next_bmp_page;\n\t\t}\n\t\t \n\t\tif (unlikely(((bmp_pos + cur_bmp_pos) >> 3) >= i_size))\n\t\t\tgoto unm_EOD;\n\t\tia_pos = (bmp_pos + cur_bmp_pos) <<\n\t\t\t\tndir->itype.index.block_size_bits;\n\t}\n\tntfs_debug(\"Handling index buffer 0x%llx.\",\n\t\t\t(unsigned long long)bmp_pos + cur_bmp_pos);\n\t \n\tif ((prev_ia_pos & (s64)PAGE_MASK) !=\n\t\t\t(ia_pos & (s64)PAGE_MASK)) {\n\t\tprev_ia_pos = ia_pos;\n\t\tif (likely(ia_page != NULL)) {\n\t\t\tunlock_page(ia_page);\n\t\t\tntfs_unmap_page(ia_page);\n\t\t}\n\t\t \n\t\tia_page = ntfs_map_page(ia_mapping, ia_pos >> PAGE_SHIFT);\n\t\tif (IS_ERR(ia_page)) {\n\t\t\tntfs_error(sb, \"Reading index allocation data failed.\");\n\t\t\terr = PTR_ERR(ia_page);\n\t\t\tia_page = NULL;\n\t\t\tgoto err_out;\n\t\t}\n\t\tlock_page(ia_page);\n\t\tkaddr = (u8*)page_address(ia_page);\n\t}\n\t \n\tia = (INDEX_ALLOCATION*)(kaddr + (ia_pos & ~PAGE_MASK &\n\t\t\t\t\t  ~(s64)(ndir->itype.index.block_size - 1)));\n\t \n\tif (unlikely((u8*)ia < kaddr || (u8*)ia > kaddr + PAGE_SIZE)) {\n\t\tntfs_error(sb, \"Out of bounds check failed. Corrupt directory \"\n\t\t\t\t\"inode 0x%lx or driver bug.\", vdir->i_ino);\n\t\tgoto err_out;\n\t}\n\t \n\tif (unlikely(!ntfs_is_indx_record(ia->magic))) {\n\t\tntfs_error(sb, \"Directory index record with vcn 0x%llx is \"\n\t\t\t\t\"corrupt.  Corrupt inode 0x%lx.  Run chkdsk.\",\n\t\t\t\t(unsigned long long)ia_pos >>\n\t\t\t\tndir->itype.index.vcn_size_bits, vdir->i_ino);\n\t\tgoto err_out;\n\t}\n\tif (unlikely(sle64_to_cpu(ia->index_block_vcn) != (ia_pos &\n\t\t\t~(s64)(ndir->itype.index.block_size - 1)) >>\n\t\t\tndir->itype.index.vcn_size_bits)) {\n\t\tntfs_error(sb, \"Actual VCN (0x%llx) of index buffer is \"\n\t\t\t\t\"different from expected VCN (0x%llx). \"\n\t\t\t\t\"Directory inode 0x%lx is corrupt or driver \"\n\t\t\t\t\"bug. \", (unsigned long long)\n\t\t\t\tsle64_to_cpu(ia->index_block_vcn),\n\t\t\t\t(unsigned long long)ia_pos >>\n\t\t\t\tndir->itype.index.vcn_size_bits, vdir->i_ino);\n\t\tgoto err_out;\n\t}\n\tif (unlikely(le32_to_cpu(ia->index.allocated_size) + 0x18 !=\n\t\t\tndir->itype.index.block_size)) {\n\t\tntfs_error(sb, \"Index buffer (VCN 0x%llx) of directory inode \"\n\t\t\t\t\"0x%lx has a size (%u) differing from the \"\n\t\t\t\t\"directory specified size (%u). Directory \"\n\t\t\t\t\"inode is corrupt or driver bug.\",\n\t\t\t\t(unsigned long long)ia_pos >>\n\t\t\t\tndir->itype.index.vcn_size_bits, vdir->i_ino,\n\t\t\t\tle32_to_cpu(ia->index.allocated_size) + 0x18,\n\t\t\t\tndir->itype.index.block_size);\n\t\tgoto err_out;\n\t}\n\tindex_end = (u8*)ia + ndir->itype.index.block_size;\n\tif (unlikely(index_end > kaddr + PAGE_SIZE)) {\n\t\tntfs_error(sb, \"Index buffer (VCN 0x%llx) of directory inode \"\n\t\t\t\t\"0x%lx crosses page boundary. Impossible! \"\n\t\t\t\t\"Cannot access! This is probably a bug in the \"\n\t\t\t\t\"driver.\", (unsigned long long)ia_pos >>\n\t\t\t\tndir->itype.index.vcn_size_bits, vdir->i_ino);\n\t\tgoto err_out;\n\t}\n\tia_start = ia_pos & ~(s64)(ndir->itype.index.block_size - 1);\n\tindex_end = (u8*)&ia->index + le32_to_cpu(ia->index.index_length);\n\tif (unlikely(index_end > (u8*)ia + ndir->itype.index.block_size)) {\n\t\tntfs_error(sb, \"Size of index buffer (VCN 0x%llx) of directory \"\n\t\t\t\t\"inode 0x%lx exceeds maximum size.\",\n\t\t\t\t(unsigned long long)ia_pos >>\n\t\t\t\tndir->itype.index.vcn_size_bits, vdir->i_ino);\n\t\tgoto err_out;\n\t}\n\t \n\tie = (INDEX_ENTRY*)((u8*)&ia->index +\n\t\t\tle32_to_cpu(ia->index.entries_offset));\n\t \n\tfor (;; ie = (INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie->length))) {\n\t\tntfs_debug(\"In index allocation, offset 0x%llx.\",\n\t\t\t\t(unsigned long long)ia_start +\n\t\t\t\t(unsigned long long)((u8*)ie - (u8*)ia));\n\t\t \n\t\tif (unlikely((u8*)ie < (u8*)ia || (u8*)ie +\n\t\t\t\tsizeof(INDEX_ENTRY_HEADER) > index_end ||\n\t\t\t\t(u8*)ie + le16_to_cpu(ie->key_length) >\n\t\t\t\tindex_end))\n\t\t\tgoto err_out;\n\t\t \n\t\tif (ie->flags & INDEX_ENTRY_END)\n\t\t\tbreak;\n\t\t \n\t\tif (ia_pos - ia_start > (u8*)ie - (u8*)ia)\n\t\t\tcontinue;\n\t\t \n\t\tactor->pos = (u8*)ie - (u8*)ia +\n\t\t\t\t(sle64_to_cpu(ia->index_block_vcn) <<\n\t\t\t\tndir->itype.index.vcn_size_bits) +\n\t\t\t\tvol->mft_record_size;\n\t\t \n\t\trc = ntfs_filldir(vol, ndir, ia_page, ie, name, actor);\n\t\tif (rc) {\n\t\t\t \n\t\t\tntfs_unmap_page(ia_page);\n\t\t\tntfs_unmap_page(bmp_page);\n\t\t\tiput(bmp_vi);\n\t\t\tgoto abort;\n\t\t}\n\t}\n\tgoto find_next_index_buffer;\nunm_EOD:\n\tif (ia_page) {\n\t\tunlock_page(ia_page);\n\t\tntfs_unmap_page(ia_page);\n\t}\n\tntfs_unmap_page(bmp_page);\n\tiput(bmp_vi);\nEOD:\n\t \n\tactor->pos = i_size + vol->mft_record_size;\nabort:\n\tkfree(name);\n\treturn 0;\nerr_out:\n\tif (bmp_page) {\n\t\tntfs_unmap_page(bmp_page);\niput_err_out:\n\t\tiput(bmp_vi);\n\t}\n\tif (ia_page) {\n\t\tunlock_page(ia_page);\n\t\tntfs_unmap_page(ia_page);\n\t}\n\tkfree(ir);\n\tkfree(name);\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ndir);\n\tif (!err)\n\t\terr = -EIO;\n\tntfs_debug(\"Failed. Returning error code %i.\", -err);\n\treturn err;\n}\n\n \nstatic int ntfs_dir_open(struct inode *vi, struct file *filp)\n{\n\tif (sizeof(unsigned long) < 8) {\n\t\tif (i_size_read(vi) > MAX_LFS_FILESIZE)\n\t\t\treturn -EFBIG;\n\t}\n\treturn 0;\n}\n\n#ifdef NTFS_RW\n\n \nstatic int ntfs_dir_fsync(struct file *filp, loff_t start, loff_t end,\n\t\t\t  int datasync)\n{\n\tstruct inode *bmp_vi, *vi = filp->f_mapping->host;\n\tint err, ret;\n\tntfs_attr na;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", vi->i_ino);\n\n\terr = file_write_and_wait_range(filp, start, end);\n\tif (err)\n\t\treturn err;\n\tinode_lock(vi);\n\n\tBUG_ON(!S_ISDIR(vi->i_mode));\n\t \n\tna.mft_no = vi->i_ino;\n\tna.type = AT_BITMAP;\n\tna.name = I30;\n\tna.name_len = 4;\n\tbmp_vi = ilookup5(vi->i_sb, vi->i_ino, ntfs_test_inode, &na);\n\tif (bmp_vi) {\n \t\twrite_inode_now(bmp_vi, !datasync);\n\t\tiput(bmp_vi);\n\t}\n\tret = __ntfs_write_inode(vi, 1);\n\twrite_inode_now(vi, !datasync);\n\terr = sync_blockdev(vi->i_sb->s_bdev);\n\tif (unlikely(err && !ret))\n\t\tret = err;\n\tif (likely(!ret))\n\t\tntfs_debug(\"Done.\");\n\telse\n\t\tntfs_warning(vi->i_sb, \"Failed to f%ssync inode 0x%lx.  Error \"\n\t\t\t\t\"%u.\", datasync ? \"data\" : \"\", vi->i_ino, -ret);\n\tinode_unlock(vi);\n\treturn ret;\n}\n\n#endif  \n\nWRAP_DIR_ITER(ntfs_readdir) \nconst struct file_operations ntfs_dir_ops = {\n\t.llseek\t\t= generic_file_llseek,\t \n\t.read\t\t= generic_read_dir,\t \n\t.iterate_shared\t= shared_ntfs_readdir,\t \n#ifdef NTFS_RW\n\t.fsync\t\t= ntfs_dir_fsync,\t \n#endif  \n\t \t\t\t \n\t.open\t\t= ntfs_dir_open,\t \n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}