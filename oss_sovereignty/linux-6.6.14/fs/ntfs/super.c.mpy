{
  "module_name": "super.c",
  "hash_id": "ad000f921be3e4017ae8324357d6b1ee1533b5b6876d17dcc9e92ceb7349ab26",
  "original_prompt": "Ingested from linux-6.6.14/fs/ntfs/super.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/stddef.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/blkdev.h>\t \n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/vfs.h>\n#include <linux/moduleparam.h>\n#include <linux/bitmap.h>\n\n#include \"sysctl.h\"\n#include \"logfile.h\"\n#include \"quota.h\"\n#include \"usnjrnl.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"index.h\"\n#include \"inode.h\"\n#include \"aops.h\"\n#include \"layout.h\"\n#include \"malloc.h\"\n#include \"ntfs.h\"\n\n \nstatic unsigned long ntfs_nr_compression_users;\n\n \nstatic ntfschar *default_upcase;\nstatic unsigned long ntfs_nr_upcase_users;\n\n \ntypedef enum {\n\t \n\tON_ERRORS_PANIC\t\t\t= 0x01,\n\tON_ERRORS_REMOUNT_RO\t\t= 0x02,\n\tON_ERRORS_CONTINUE\t\t= 0x04,\n\t \n\tON_ERRORS_RECOVER\t\t= 0x10,\n} ON_ERRORS_ACTIONS;\n\nconst option_t on_errors_arr[] = {\n\t{ ON_ERRORS_PANIC,\t\"panic\" },\n\t{ ON_ERRORS_REMOUNT_RO,\t\"remount-ro\", },\n\t{ ON_ERRORS_CONTINUE,\t\"continue\", },\n\t{ ON_ERRORS_RECOVER,\t\"recover\" },\n\t{ 0,\t\t\tNULL }\n};\n\n \nstatic int simple_getbool(char *s, bool *setval)\n{\n\tif (s) {\n\t\tif (!strcmp(s, \"1\") || !strcmp(s, \"yes\") || !strcmp(s, \"true\"))\n\t\t\t*setval = true;\n\t\telse if (!strcmp(s, \"0\") || !strcmp(s, \"no\") ||\n\t\t\t\t\t\t\t!strcmp(s, \"false\"))\n\t\t\t*setval = false;\n\t\telse\n\t\t\treturn 0;\n\t} else\n\t\t*setval = true;\n\treturn 1;\n}\n\n \nstatic bool parse_options(ntfs_volume *vol, char *opt)\n{\n\tchar *p, *v, *ov;\n\tstatic char *utf8 = \"utf8\";\n\tint errors = 0, sloppy = 0;\n\tkuid_t uid = INVALID_UID;\n\tkgid_t gid = INVALID_GID;\n\tumode_t fmask = (umode_t)-1, dmask = (umode_t)-1;\n\tint mft_zone_multiplier = -1, on_errors = -1;\n\tint show_sys_files = -1, case_sensitive = -1, disable_sparse = -1;\n\tstruct nls_table *nls_map = NULL, *old_nls;\n\n\t \n#define NTFS_GETOPT_WITH_DEFAULT(option, variable, default_value)\t\\\n\tif (!strcmp(p, option)) {\t\t\t\t\t\\\n\t\tif (!v || !*v)\t\t\t\t\t\t\\\n\t\t\tvariable = default_value;\t\t\t\\\n\t\telse {\t\t\t\t\t\t\t\\\n\t\t\tvariable = simple_strtoul(ov = v, &v, 0);\t\\\n\t\t\tif (*v)\t\t\t\t\t\t\\\n\t\t\t\tgoto needs_val;\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t}\n#define NTFS_GETOPT(option, variable)\t\t\t\t\t\\\n\tif (!strcmp(p, option)) {\t\t\t\t\t\\\n\t\tif (!v || !*v)\t\t\t\t\t\t\\\n\t\t\tgoto needs_arg;\t\t\t\t\t\\\n\t\tvariable = simple_strtoul(ov = v, &v, 0);\t\t\\\n\t\tif (*v)\t\t\t\t\t\t\t\\\n\t\t\tgoto needs_val;\t\t\t\t\t\\\n\t}\n#define NTFS_GETOPT_UID(option, variable)\t\t\t\t\\\n\tif (!strcmp(p, option)) {\t\t\t\t\t\\\n\t\tuid_t uid_value;\t\t\t\t\t\\\n\t\tif (!v || !*v)\t\t\t\t\t\t\\\n\t\t\tgoto needs_arg;\t\t\t\t\t\\\n\t\tuid_value = simple_strtoul(ov = v, &v, 0);\t\t\\\n\t\tif (*v)\t\t\t\t\t\t\t\\\n\t\t\tgoto needs_val;\t\t\t\t\t\\\n\t\tvariable = make_kuid(current_user_ns(), uid_value);\t\\\n\t\tif (!uid_valid(variable))\t\t\t\t\\\n\t\t\tgoto needs_val;\t\t\t\t\t\\\n\t}\n#define NTFS_GETOPT_GID(option, variable)\t\t\t\t\\\n\tif (!strcmp(p, option)) {\t\t\t\t\t\\\n\t\tgid_t gid_value;\t\t\t\t\t\\\n\t\tif (!v || !*v)\t\t\t\t\t\t\\\n\t\t\tgoto needs_arg;\t\t\t\t\t\\\n\t\tgid_value = simple_strtoul(ov = v, &v, 0);\t\t\\\n\t\tif (*v)\t\t\t\t\t\t\t\\\n\t\t\tgoto needs_val;\t\t\t\t\t\\\n\t\tvariable = make_kgid(current_user_ns(), gid_value);\t\\\n\t\tif (!gid_valid(variable))\t\t\t\t\\\n\t\t\tgoto needs_val;\t\t\t\t\t\\\n\t}\n#define NTFS_GETOPT_OCTAL(option, variable)\t\t\t\t\\\n\tif (!strcmp(p, option)) {\t\t\t\t\t\\\n\t\tif (!v || !*v)\t\t\t\t\t\t\\\n\t\t\tgoto needs_arg;\t\t\t\t\t\\\n\t\tvariable = simple_strtoul(ov = v, &v, 8);\t\t\\\n\t\tif (*v)\t\t\t\t\t\t\t\\\n\t\t\tgoto needs_val;\t\t\t\t\t\\\n\t}\n#define NTFS_GETOPT_BOOL(option, variable)\t\t\t\t\\\n\tif (!strcmp(p, option)) {\t\t\t\t\t\\\n\t\tbool val;\t\t\t\t\t\t\\\n\t\tif (!simple_getbool(v, &val))\t\t\t\t\\\n\t\t\tgoto needs_bool;\t\t\t\t\\\n\t\tvariable = val;\t\t\t\t\t\t\\\n\t}\n#define NTFS_GETOPT_OPTIONS_ARRAY(option, variable, opt_array)\t\t\\\n\tif (!strcmp(p, option)) {\t\t\t\t\t\\\n\t\tint _i;\t\t\t\t\t\t\t\\\n\t\tif (!v || !*v)\t\t\t\t\t\t\\\n\t\t\tgoto needs_arg;\t\t\t\t\t\\\n\t\tov = v;\t\t\t\t\t\t\t\\\n\t\tif (variable == -1)\t\t\t\t\t\\\n\t\t\tvariable = 0;\t\t\t\t\t\\\n\t\tfor (_i = 0; opt_array[_i].str && *opt_array[_i].str; _i++) \\\n\t\t\tif (!strcmp(opt_array[_i].str, v)) {\t\t\\\n\t\t\t\tvariable |= opt_array[_i].val;\t\t\\\n\t\t\t\tbreak;\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\tif (!opt_array[_i].str || !*opt_array[_i].str)\t\t\\\n\t\t\tgoto needs_val;\t\t\t\t\t\\\n\t}\n\tif (!opt || !*opt)\n\t\tgoto no_mount_options;\n\tntfs_debug(\"Entering with mount options string: %s\", opt);\n\twhile ((p = strsep(&opt, \",\"))) {\n\t\tif ((v = strchr(p, '=')))\n\t\t\t*v++ = 0;\n\t\tNTFS_GETOPT_UID(\"uid\", uid)\n\t\telse NTFS_GETOPT_GID(\"gid\", gid)\n\t\telse NTFS_GETOPT_OCTAL(\"umask\", fmask = dmask)\n\t\telse NTFS_GETOPT_OCTAL(\"fmask\", fmask)\n\t\telse NTFS_GETOPT_OCTAL(\"dmask\", dmask)\n\t\telse NTFS_GETOPT(\"mft_zone_multiplier\", mft_zone_multiplier)\n\t\telse NTFS_GETOPT_WITH_DEFAULT(\"sloppy\", sloppy, true)\n\t\telse NTFS_GETOPT_BOOL(\"show_sys_files\", show_sys_files)\n\t\telse NTFS_GETOPT_BOOL(\"case_sensitive\", case_sensitive)\n\t\telse NTFS_GETOPT_BOOL(\"disable_sparse\", disable_sparse)\n\t\telse NTFS_GETOPT_OPTIONS_ARRAY(\"errors\", on_errors,\n\t\t\t\ton_errors_arr)\n\t\telse if (!strcmp(p, \"posix\") || !strcmp(p, \"show_inodes\"))\n\t\t\tntfs_warning(vol->sb, \"Ignoring obsolete option %s.\",\n\t\t\t\t\tp);\n\t\telse if (!strcmp(p, \"nls\") || !strcmp(p, \"iocharset\")) {\n\t\t\tif (!strcmp(p, \"iocharset\"))\n\t\t\t\tntfs_warning(vol->sb, \"Option iocharset is \"\n\t\t\t\t\t\t\"deprecated. Please use \"\n\t\t\t\t\t\t\"option nls=<charsetname> in \"\n\t\t\t\t\t\t\"the future.\");\n\t\t\tif (!v || !*v)\n\t\t\t\tgoto needs_arg;\nuse_utf8:\n\t\t\told_nls = nls_map;\n\t\t\tnls_map = load_nls(v);\n\t\t\tif (!nls_map) {\n\t\t\t\tif (!old_nls) {\n\t\t\t\t\tntfs_error(vol->sb, \"NLS character set \"\n\t\t\t\t\t\t\t\"%s not found.\", v);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tntfs_error(vol->sb, \"NLS character set %s not \"\n\t\t\t\t\t\t\"found. Using previous one %s.\",\n\t\t\t\t\t\tv, old_nls->charset);\n\t\t\t\tnls_map = old_nls;\n\t\t\t} else   {\n\t\t\t\tunload_nls(old_nls);\n\t\t\t}\n\t\t} else if (!strcmp(p, \"utf8\")) {\n\t\t\tbool val = false;\n\t\t\tntfs_warning(vol->sb, \"Option utf8 is no longer \"\n\t\t\t\t   \"supported, using option nls=utf8. Please \"\n\t\t\t\t   \"use option nls=utf8 in the future and \"\n\t\t\t\t   \"make sure utf8 is compiled either as a \"\n\t\t\t\t   \"module or into the kernel.\");\n\t\t\tif (!v || !*v)\n\t\t\t\tval = true;\n\t\t\telse if (!simple_getbool(v, &val))\n\t\t\t\tgoto needs_bool;\n\t\t\tif (val) {\n\t\t\t\tv = utf8;\n\t\t\t\tgoto use_utf8;\n\t\t\t}\n\t\t} else {\n\t\t\tntfs_error(vol->sb, \"Unrecognized mount option %s.\", p);\n\t\t\tif (errors < INT_MAX)\n\t\t\t\terrors++;\n\t\t}\n#undef NTFS_GETOPT_OPTIONS_ARRAY\n#undef NTFS_GETOPT_BOOL\n#undef NTFS_GETOPT\n#undef NTFS_GETOPT_WITH_DEFAULT\n\t}\nno_mount_options:\n\tif (errors && !sloppy)\n\t\treturn false;\n\tif (sloppy)\n\t\tntfs_warning(vol->sb, \"Sloppy option given. Ignoring \"\n\t\t\t\t\"unrecognized mount option(s) and continuing.\");\n\t \n\tif (on_errors != -1) {\n\t\tif (!on_errors) {\n\t\t\tntfs_error(vol->sb, \"Invalid errors option argument \"\n\t\t\t\t\t\"or bug in options parser.\");\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (nls_map) {\n\t\tif (vol->nls_map && vol->nls_map != nls_map) {\n\t\t\tntfs_error(vol->sb, \"Cannot change NLS character set \"\n\t\t\t\t\t\"on remount.\");\n\t\t\treturn false;\n\t\t}  \n\t\tntfs_debug(\"Using NLS character set %s.\", nls_map->charset);\n\t\tvol->nls_map = nls_map;\n\t} else   {\n\t\tif (!vol->nls_map) {\n\t\t\tvol->nls_map = load_nls_default();\n\t\t\tif (!vol->nls_map) {\n\t\t\t\tntfs_error(vol->sb, \"Failed to load default \"\n\t\t\t\t\t\t\"NLS character set.\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tntfs_debug(\"Using default NLS character set (%s).\",\n\t\t\t\t\tvol->nls_map->charset);\n\t\t}\n\t}\n\tif (mft_zone_multiplier != -1) {\n\t\tif (vol->mft_zone_multiplier && vol->mft_zone_multiplier !=\n\t\t\t\tmft_zone_multiplier) {\n\t\t\tntfs_error(vol->sb, \"Cannot change mft_zone_multiplier \"\n\t\t\t\t\t\"on remount.\");\n\t\t\treturn false;\n\t\t}\n\t\tif (mft_zone_multiplier < 1 || mft_zone_multiplier > 4) {\n\t\t\tntfs_error(vol->sb, \"Invalid mft_zone_multiplier. \"\n\t\t\t\t\t\"Using default value, i.e. 1.\");\n\t\t\tmft_zone_multiplier = 1;\n\t\t}\n\t\tvol->mft_zone_multiplier = mft_zone_multiplier;\n\t}\n\tif (!vol->mft_zone_multiplier)\n\t\tvol->mft_zone_multiplier = 1;\n\tif (on_errors != -1)\n\t\tvol->on_errors = on_errors;\n\tif (!vol->on_errors || vol->on_errors == ON_ERRORS_RECOVER)\n\t\tvol->on_errors |= ON_ERRORS_CONTINUE;\n\tif (uid_valid(uid))\n\t\tvol->uid = uid;\n\tif (gid_valid(gid))\n\t\tvol->gid = gid;\n\tif (fmask != (umode_t)-1)\n\t\tvol->fmask = fmask;\n\tif (dmask != (umode_t)-1)\n\t\tvol->dmask = dmask;\n\tif (show_sys_files != -1) {\n\t\tif (show_sys_files)\n\t\t\tNVolSetShowSystemFiles(vol);\n\t\telse\n\t\t\tNVolClearShowSystemFiles(vol);\n\t}\n\tif (case_sensitive != -1) {\n\t\tif (case_sensitive)\n\t\t\tNVolSetCaseSensitive(vol);\n\t\telse\n\t\t\tNVolClearCaseSensitive(vol);\n\t}\n\tif (disable_sparse != -1) {\n\t\tif (disable_sparse)\n\t\t\tNVolClearSparseEnabled(vol);\n\t\telse {\n\t\t\tif (!NVolSparseEnabled(vol) &&\n\t\t\t\t\tvol->major_ver && vol->major_ver < 3)\n\t\t\t\tntfs_warning(vol->sb, \"Not enabling sparse \"\n\t\t\t\t\t\t\"support due to NTFS volume \"\n\t\t\t\t\t\t\"version %i.%i (need at least \"\n\t\t\t\t\t\t\"version 3.0).\", vol->major_ver,\n\t\t\t\t\t\tvol->minor_ver);\n\t\t\telse\n\t\t\t\tNVolSetSparseEnabled(vol);\n\t\t}\n\t}\n\treturn true;\nneeds_arg:\n\tntfs_error(vol->sb, \"The %s option requires an argument.\", p);\n\treturn false;\nneeds_bool:\n\tntfs_error(vol->sb, \"The %s option requires a boolean argument.\", p);\n\treturn false;\nneeds_val:\n\tntfs_error(vol->sb, \"Invalid %s option argument: %s\", p, ov);\n\treturn false;\n}\n\n#ifdef NTFS_RW\n\n \nstatic int ntfs_write_volume_flags(ntfs_volume *vol, const VOLUME_FLAGS flags)\n{\n\tntfs_inode *ni = NTFS_I(vol->vol_ino);\n\tMFT_RECORD *m;\n\tVOLUME_INFORMATION *vi;\n\tntfs_attr_search_ctx *ctx;\n\tint err;\n\n\tntfs_debug(\"Entering, old flags = 0x%x, new flags = 0x%x.\",\n\t\t\tle16_to_cpu(vol->vol_flags), le16_to_cpu(flags));\n\tif (vol->vol_flags == flags)\n\t\tgoto done;\n\tBUG_ON(!ni);\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto put_unm_err_out;\n\t}\n\terr = ntfs_attr_lookup(AT_VOLUME_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (err)\n\t\tgoto put_unm_err_out;\n\tvi = (VOLUME_INFORMATION*)((u8*)ctx->attr +\n\t\t\tle16_to_cpu(ctx->attr->data.resident.value_offset));\n\tvol->vol_flags = vi->flags = flags;\n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(ni);\ndone:\n\tntfs_debug(\"Done.\");\n\treturn 0;\nput_unm_err_out:\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.\", -err);\n\treturn err;\n}\n\n \nstatic inline int ntfs_set_volume_flags(ntfs_volume *vol, VOLUME_FLAGS flags)\n{\n\tflags &= VOLUME_FLAGS_MASK;\n\treturn ntfs_write_volume_flags(vol, vol->vol_flags | flags);\n}\n\n \nstatic inline int ntfs_clear_volume_flags(ntfs_volume *vol, VOLUME_FLAGS flags)\n{\n\tflags &= VOLUME_FLAGS_MASK;\n\tflags = vol->vol_flags & cpu_to_le16(~le16_to_cpu(flags));\n\treturn ntfs_write_volume_flags(vol, flags);\n}\n\n#endif  \n\n \nstatic int ntfs_remount(struct super_block *sb, int *flags, char *opt)\n{\n\tntfs_volume *vol = NTFS_SB(sb);\n\n\tntfs_debug(\"Entering with remount options string: %s\", opt);\n\n\tsync_filesystem(sb);\n\n#ifndef NTFS_RW\n\t \n\t*flags |= SB_RDONLY;\n#else  \n\t \n\tif (sb_rdonly(sb) && !(*flags & SB_RDONLY)) {\n\t\tstatic const char *es = \".  Cannot remount read-write.\";\n\n\t\t \n\t\tif (NVolErrors(vol)) {\n\t\t\tntfs_error(sb, \"Volume has errors and is read-only%s\",\n\t\t\t\t\tes);\n\t\t\treturn -EROFS;\n\t\t}\n\t\tif (vol->vol_flags & VOLUME_IS_DIRTY) {\n\t\t\tntfs_error(sb, \"Volume is dirty and read-only%s\", es);\n\t\t\treturn -EROFS;\n\t\t}\n\t\tif (vol->vol_flags & VOLUME_MODIFIED_BY_CHKDSK) {\n\t\t\tntfs_error(sb, \"Volume has been modified by chkdsk \"\n\t\t\t\t\t\"and is read-only%s\", es);\n\t\t\treturn -EROFS;\n\t\t}\n\t\tif (vol->vol_flags & VOLUME_MUST_MOUNT_RO_MASK) {\n\t\t\tntfs_error(sb, \"Volume has unsupported flags set \"\n\t\t\t\t\t\"(0x%x) and is read-only%s\",\n\t\t\t\t\t(unsigned)le16_to_cpu(vol->vol_flags),\n\t\t\t\t\tes);\n\t\t\treturn -EROFS;\n\t\t}\n\t\tif (ntfs_set_volume_flags(vol, VOLUME_IS_DIRTY)) {\n\t\t\tntfs_error(sb, \"Failed to set dirty bit in volume \"\n\t\t\t\t\t\"information flags%s\", es);\n\t\t\treturn -EROFS;\n\t\t}\n#if 0\n\t\t\n\t\t\n\t\t \n\t\tif ((vol->major_ver > 1)) {\n\t\t\tif (ntfs_set_volume_flags(vol, VOLUME_MOUNTED_ON_NT4)) {\n\t\t\t\tntfs_error(sb, \"Failed to set NT4 \"\n\t\t\t\t\t\t\"compatibility flag%s\", es);\n\t\t\t\tNVolSetErrors(vol);\n\t\t\t\treturn -EROFS;\n\t\t\t}\n\t\t}\n#endif\n\t\tif (!ntfs_empty_logfile(vol->logfile_ino)) {\n\t\t\tntfs_error(sb, \"Failed to empty journal $LogFile%s\",\n\t\t\t\t\tes);\n\t\t\tNVolSetErrors(vol);\n\t\t\treturn -EROFS;\n\t\t}\n\t\tif (!ntfs_mark_quotas_out_of_date(vol)) {\n\t\t\tntfs_error(sb, \"Failed to mark quotas out of date%s\",\n\t\t\t\t\tes);\n\t\t\tNVolSetErrors(vol);\n\t\t\treturn -EROFS;\n\t\t}\n\t\tif (!ntfs_stamp_usnjrnl(vol)) {\n\t\t\tntfs_error(sb, \"Failed to stamp transaction log \"\n\t\t\t\t\t\"($UsnJrnl)%s\", es);\n\t\t\tNVolSetErrors(vol);\n\t\t\treturn -EROFS;\n\t\t}\n\t} else if (!sb_rdonly(sb) && (*flags & SB_RDONLY)) {\n\t\t \n\t\tif (!NVolErrors(vol)) {\n\t\t\tif (ntfs_clear_volume_flags(vol, VOLUME_IS_DIRTY))\n\t\t\t\tntfs_warning(sb, \"Failed to clear dirty bit \"\n\t\t\t\t\t\t\"in volume information \"\n\t\t\t\t\t\t\"flags.  Run chkdsk.\");\n\t\t}\n\t}\n#endif  \n\n\t\n\n\tif (!parse_options(vol, opt))\n\t\treturn -EINVAL;\n\n\tntfs_debug(\"Done.\");\n\treturn 0;\n}\n\n \nstatic bool is_boot_sector_ntfs(const struct super_block *sb,\n\t\tconst NTFS_BOOT_SECTOR *b, const bool silent)\n{\n\t \n\tif ((void*)b < (void*)&b->checksum && b->checksum && !silent) {\n\t\tle32 *u;\n\t\tu32 i;\n\n\t\tfor (i = 0, u = (le32*)b; u < (le32*)(&b->checksum); ++u)\n\t\t\ti += le32_to_cpup(u);\n\t\tif (le32_to_cpu(b->checksum) != i)\n\t\t\tntfs_warning(sb, \"Invalid boot sector checksum.\");\n\t}\n\t \n\tif (b->oem_id != magicNTFS)\n\t\tgoto not_ntfs;\n\t \n\tif (le16_to_cpu(b->bpb.bytes_per_sector) < 0x100 ||\n\t\t\tle16_to_cpu(b->bpb.bytes_per_sector) > 0x1000)\n\t\tgoto not_ntfs;\n\t \n\tswitch (b->bpb.sectors_per_cluster) {\n\tcase 1: case 2: case 4: case 8: case 16: case 32: case 64: case 128:\n\t\tbreak;\n\tdefault:\n\t\tgoto not_ntfs;\n\t}\n\t \n\tif ((u32)le16_to_cpu(b->bpb.bytes_per_sector) *\n\t\t\tb->bpb.sectors_per_cluster > NTFS_MAX_CLUSTER_SIZE)\n\t\tgoto not_ntfs;\n\t \n\tif (le16_to_cpu(b->bpb.reserved_sectors) ||\n\t\t\tle16_to_cpu(b->bpb.root_entries) ||\n\t\t\tle16_to_cpu(b->bpb.sectors) ||\n\t\t\tle16_to_cpu(b->bpb.sectors_per_fat) ||\n\t\t\tle32_to_cpu(b->bpb.large_sectors) || b->bpb.fats)\n\t\tgoto not_ntfs;\n\t \n\tif ((u8)b->clusters_per_mft_record < 0xe1 ||\n\t\t\t(u8)b->clusters_per_mft_record > 0xf7)\n\t\tswitch (b->clusters_per_mft_record) {\n\t\tcase 1: case 2: case 4: case 8: case 16: case 32: case 64:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto not_ntfs;\n\t\t}\n\t \n\tif ((u8)b->clusters_per_index_record < 0xe1 ||\n\t\t\t(u8)b->clusters_per_index_record > 0xf7)\n\t\tswitch (b->clusters_per_index_record) {\n\t\tcase 1: case 2: case 4: case 8: case 16: case 32: case 64:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto not_ntfs;\n\t\t}\n\t \n\tif (!silent && b->end_of_sector_marker != cpu_to_le16(0xaa55))\n\t\tntfs_warning(sb, \"Invalid end of sector marker.\");\n\treturn true;\nnot_ntfs:\n\treturn false;\n}\n\n \nstatic struct buffer_head *read_ntfs_boot_sector(struct super_block *sb,\n\t\tconst int silent)\n{\n\tconst char *read_err_str = \"Unable to read %s boot sector.\";\n\tstruct buffer_head *bh_primary, *bh_backup;\n\tsector_t nr_blocks = NTFS_SB(sb)->nr_blocks;\n\n\t \n\tif ((bh_primary = sb_bread(sb, 0))) {\n\t\tif (is_boot_sector_ntfs(sb, (NTFS_BOOT_SECTOR*)\n\t\t\t\tbh_primary->b_data, silent))\n\t\t\treturn bh_primary;\n\t\tif (!silent)\n\t\t\tntfs_error(sb, \"Primary boot sector is invalid.\");\n\t} else if (!silent)\n\t\tntfs_error(sb, read_err_str, \"primary\");\n\tif (!(NTFS_SB(sb)->on_errors & ON_ERRORS_RECOVER)) {\n\t\tif (bh_primary)\n\t\t\tbrelse(bh_primary);\n\t\tif (!silent)\n\t\t\tntfs_error(sb, \"Mount option errors=recover not used. \"\n\t\t\t\t\t\"Aborting without trying to recover.\");\n\t\treturn NULL;\n\t}\n\t \n\tif ((bh_backup = sb_bread(sb, nr_blocks - 1))) {\n\t\tif (is_boot_sector_ntfs(sb, (NTFS_BOOT_SECTOR*)\n\t\t\t\tbh_backup->b_data, silent))\n\t\t\tgoto hotfix_primary_boot_sector;\n\t\tbrelse(bh_backup);\n\t} else if (!silent)\n\t\tntfs_error(sb, read_err_str, \"backup\");\n\t \n\tif ((bh_backup = sb_bread(sb, nr_blocks >> 1))) {\n\t\tif (is_boot_sector_ntfs(sb, (NTFS_BOOT_SECTOR*)\n\t\t\t\tbh_backup->b_data, silent))\n\t\t\tgoto hotfix_primary_boot_sector;\n\t\tif (!silent)\n\t\t\tntfs_error(sb, \"Could not find a valid backup boot \"\n\t\t\t\t\t\"sector.\");\n\t\tbrelse(bh_backup);\n\t} else if (!silent)\n\t\tntfs_error(sb, read_err_str, \"backup\");\n\t \n\tif (bh_primary)\n\t\tbrelse(bh_primary);\n\treturn NULL;\nhotfix_primary_boot_sector:\n\tif (bh_primary) {\n\t\t \n\t\tif (!sb_rdonly(sb)) {\n\t\t\tntfs_warning(sb, \"Hot-fix: Recovering invalid primary \"\n\t\t\t\t\t\"boot sector from backup copy.\");\n\t\t\tmemcpy(bh_primary->b_data, bh_backup->b_data,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\tmark_buffer_dirty(bh_primary);\n\t\t\tsync_dirty_buffer(bh_primary);\n\t\t\tif (buffer_uptodate(bh_primary)) {\n\t\t\t\tbrelse(bh_backup);\n\t\t\t\treturn bh_primary;\n\t\t\t}\n\t\t\tntfs_error(sb, \"Hot-fix: Device write error while \"\n\t\t\t\t\t\"recovering primary boot sector.\");\n\t\t} else {\n\t\t\tntfs_warning(sb, \"Hot-fix: Recovery of primary boot \"\n\t\t\t\t\t\"sector failed: Read-only mount.\");\n\t\t}\n\t\tbrelse(bh_primary);\n\t}\n\tntfs_warning(sb, \"Using backup boot sector.\");\n\treturn bh_backup;\n}\n\n \nstatic bool parse_ntfs_boot_sector(ntfs_volume *vol, const NTFS_BOOT_SECTOR *b)\n{\n\tunsigned int sectors_per_cluster_bits, nr_hidden_sects;\n\tint clusters_per_mft_record, clusters_per_index_record;\n\ts64 ll;\n\n\tvol->sector_size = le16_to_cpu(b->bpb.bytes_per_sector);\n\tvol->sector_size_bits = ffs(vol->sector_size) - 1;\n\tntfs_debug(\"vol->sector_size = %i (0x%x)\", vol->sector_size,\n\t\t\tvol->sector_size);\n\tntfs_debug(\"vol->sector_size_bits = %i (0x%x)\", vol->sector_size_bits,\n\t\t\tvol->sector_size_bits);\n\tif (vol->sector_size < vol->sb->s_blocksize) {\n\t\tntfs_error(vol->sb, \"Sector size (%i) is smaller than the \"\n\t\t\t\t\"device block size (%lu).  This is not \"\n\t\t\t\t\"supported.  Sorry.\", vol->sector_size,\n\t\t\t\tvol->sb->s_blocksize);\n\t\treturn false;\n\t}\n\tntfs_debug(\"sectors_per_cluster = 0x%x\", b->bpb.sectors_per_cluster);\n\tsectors_per_cluster_bits = ffs(b->bpb.sectors_per_cluster) - 1;\n\tntfs_debug(\"sectors_per_cluster_bits = 0x%x\",\n\t\t\tsectors_per_cluster_bits);\n\tnr_hidden_sects = le32_to_cpu(b->bpb.hidden_sectors);\n\tntfs_debug(\"number of hidden sectors = 0x%x\", nr_hidden_sects);\n\tvol->cluster_size = vol->sector_size << sectors_per_cluster_bits;\n\tvol->cluster_size_mask = vol->cluster_size - 1;\n\tvol->cluster_size_bits = ffs(vol->cluster_size) - 1;\n\tntfs_debug(\"vol->cluster_size = %i (0x%x)\", vol->cluster_size,\n\t\t\tvol->cluster_size);\n\tntfs_debug(\"vol->cluster_size_mask = 0x%x\", vol->cluster_size_mask);\n\tntfs_debug(\"vol->cluster_size_bits = %i\", vol->cluster_size_bits);\n\tif (vol->cluster_size < vol->sector_size) {\n\t\tntfs_error(vol->sb, \"Cluster size (%i) is smaller than the \"\n\t\t\t\t\"sector size (%i).  This is not supported.  \"\n\t\t\t\t\"Sorry.\", vol->cluster_size, vol->sector_size);\n\t\treturn false;\n\t}\n\tclusters_per_mft_record = b->clusters_per_mft_record;\n\tntfs_debug(\"clusters_per_mft_record = %i (0x%x)\",\n\t\t\tclusters_per_mft_record, clusters_per_mft_record);\n\tif (clusters_per_mft_record > 0)\n\t\tvol->mft_record_size = vol->cluster_size <<\n\t\t\t\t(ffs(clusters_per_mft_record) - 1);\n\telse\n\t\t \n\t\tvol->mft_record_size = 1 << -clusters_per_mft_record;\n\tvol->mft_record_size_mask = vol->mft_record_size - 1;\n\tvol->mft_record_size_bits = ffs(vol->mft_record_size) - 1;\n\tntfs_debug(\"vol->mft_record_size = %i (0x%x)\", vol->mft_record_size,\n\t\t\tvol->mft_record_size);\n\tntfs_debug(\"vol->mft_record_size_mask = 0x%x\",\n\t\t\tvol->mft_record_size_mask);\n\tntfs_debug(\"vol->mft_record_size_bits = %i (0x%x)\",\n\t\t\tvol->mft_record_size_bits, vol->mft_record_size_bits);\n\t \n\tif (vol->mft_record_size > PAGE_SIZE) {\n\t\tntfs_error(vol->sb, \"Mft record size (%i) exceeds the \"\n\t\t\t\t\"PAGE_SIZE on your system (%lu).  \"\n\t\t\t\t\"This is not supported.  Sorry.\",\n\t\t\t\tvol->mft_record_size, PAGE_SIZE);\n\t\treturn false;\n\t}\n\t \n\tif (vol->mft_record_size < vol->sector_size) {\n\t\tntfs_error(vol->sb, \"Mft record size (%i) is smaller than the \"\n\t\t\t\t\"sector size (%i).  This is not supported.  \"\n\t\t\t\t\"Sorry.\", vol->mft_record_size,\n\t\t\t\tvol->sector_size);\n\t\treturn false;\n\t}\n\tclusters_per_index_record = b->clusters_per_index_record;\n\tntfs_debug(\"clusters_per_index_record = %i (0x%x)\",\n\t\t\tclusters_per_index_record, clusters_per_index_record);\n\tif (clusters_per_index_record > 0)\n\t\tvol->index_record_size = vol->cluster_size <<\n\t\t\t\t(ffs(clusters_per_index_record) - 1);\n\telse\n\t\t \n\t\tvol->index_record_size = 1 << -clusters_per_index_record;\n\tvol->index_record_size_mask = vol->index_record_size - 1;\n\tvol->index_record_size_bits = ffs(vol->index_record_size) - 1;\n\tntfs_debug(\"vol->index_record_size = %i (0x%x)\",\n\t\t\tvol->index_record_size, vol->index_record_size);\n\tntfs_debug(\"vol->index_record_size_mask = 0x%x\",\n\t\t\tvol->index_record_size_mask);\n\tntfs_debug(\"vol->index_record_size_bits = %i (0x%x)\",\n\t\t\tvol->index_record_size_bits,\n\t\t\tvol->index_record_size_bits);\n\t \n\tif (vol->index_record_size < vol->sector_size) {\n\t\tntfs_error(vol->sb, \"Index record size (%i) is smaller than \"\n\t\t\t\t\"the sector size (%i).  This is not \"\n\t\t\t\t\"supported.  Sorry.\", vol->index_record_size,\n\t\t\t\tvol->sector_size);\n\t\treturn false;\n\t}\n\t \n\tll = sle64_to_cpu(b->number_of_sectors) >> sectors_per_cluster_bits;\n\tif ((u64)ll >= 1ULL << 32) {\n\t\tntfs_error(vol->sb, \"Cannot handle 64-bit clusters.  Sorry.\");\n\t\treturn false;\n\t}\n\tvol->nr_clusters = ll;\n\tntfs_debug(\"vol->nr_clusters = 0x%llx\", (long long)vol->nr_clusters);\n\t \n\tif (sizeof(unsigned long) < 8) {\n\t\tif ((ll << vol->cluster_size_bits) >= (1ULL << 41)) {\n\t\t\tntfs_error(vol->sb, \"Volume size (%lluTiB) is too \"\n\t\t\t\t\t\"large for this architecture.  \"\n\t\t\t\t\t\"Maximum supported is 2TiB.  Sorry.\",\n\t\t\t\t\t(unsigned long long)ll >> (40 -\n\t\t\t\t\tvol->cluster_size_bits));\n\t\t\treturn false;\n\t\t}\n\t}\n\tll = sle64_to_cpu(b->mft_lcn);\n\tif (ll >= vol->nr_clusters) {\n\t\tntfs_error(vol->sb, \"MFT LCN (%lli, 0x%llx) is beyond end of \"\n\t\t\t\t\"volume.  Weird.\", (unsigned long long)ll,\n\t\t\t\t(unsigned long long)ll);\n\t\treturn false;\n\t}\n\tvol->mft_lcn = ll;\n\tntfs_debug(\"vol->mft_lcn = 0x%llx\", (long long)vol->mft_lcn);\n\tll = sle64_to_cpu(b->mftmirr_lcn);\n\tif (ll >= vol->nr_clusters) {\n\t\tntfs_error(vol->sb, \"MFTMirr LCN (%lli, 0x%llx) is beyond end \"\n\t\t\t\t\"of volume.  Weird.\", (unsigned long long)ll,\n\t\t\t\t(unsigned long long)ll);\n\t\treturn false;\n\t}\n\tvol->mftmirr_lcn = ll;\n\tntfs_debug(\"vol->mftmirr_lcn = 0x%llx\", (long long)vol->mftmirr_lcn);\n#ifdef NTFS_RW\n\t \n\tif (vol->cluster_size <= (4 << vol->mft_record_size_bits))\n\t\tvol->mftmirr_size = 4;\n\telse\n\t\tvol->mftmirr_size = vol->cluster_size >>\n\t\t\t\tvol->mft_record_size_bits;\n\tntfs_debug(\"vol->mftmirr_size = %i\", vol->mftmirr_size);\n#endif  \n\tvol->serial_no = le64_to_cpu(b->volume_serial_number);\n\tntfs_debug(\"vol->serial_no = 0x%llx\",\n\t\t\t(unsigned long long)vol->serial_no);\n\treturn true;\n}\n\n \nstatic void ntfs_setup_allocators(ntfs_volume *vol)\n{\n#ifdef NTFS_RW\n\tLCN mft_zone_size, mft_lcn;\n#endif  \n\n\tntfs_debug(\"vol->mft_zone_multiplier = 0x%x\",\n\t\t\tvol->mft_zone_multiplier);\n#ifdef NTFS_RW\n\t \n\tmft_zone_size = vol->nr_clusters;\n\tswitch (vol->mft_zone_multiplier) {   \n\tcase 4:\n\t\tmft_zone_size >>= 1;\t\t\t \n\t\tbreak;\n\tcase 3:\n\t\tmft_zone_size = (mft_zone_size +\n\t\t\t\t(mft_zone_size >> 1)) >> 2;\t \n\t\tbreak;\n\tcase 2:\n\t\tmft_zone_size >>= 2;\t\t\t \n\t\tbreak;\n\t \n\tdefault:\n\t\tmft_zone_size >>= 3;\t\t\t \n\t\tbreak;\n\t}\n\t \n\tvol->mft_zone_start = vol->mft_zone_pos = vol->mft_lcn;\n\tntfs_debug(\"vol->mft_zone_pos = 0x%llx\",\n\t\t\t(unsigned long long)vol->mft_zone_pos);\n\t \n\tmft_lcn = (8192 + 2 * vol->cluster_size - 1) / vol->cluster_size;\n\tif (mft_lcn * vol->cluster_size < 16 * 1024)\n\t\tmft_lcn = (16 * 1024 + vol->cluster_size - 1) /\n\t\t\t\tvol->cluster_size;\n\tif (vol->mft_zone_start <= mft_lcn)\n\t\tvol->mft_zone_start = 0;\n\tntfs_debug(\"vol->mft_zone_start = 0x%llx\",\n\t\t\t(unsigned long long)vol->mft_zone_start);\n\t \n\tvol->mft_zone_end = vol->mft_lcn + mft_zone_size;\n\twhile (vol->mft_zone_end >= vol->nr_clusters) {\n\t\tmft_zone_size >>= 1;\n\t\tvol->mft_zone_end = vol->mft_lcn + mft_zone_size;\n\t}\n\tntfs_debug(\"vol->mft_zone_end = 0x%llx\",\n\t\t\t(unsigned long long)vol->mft_zone_end);\n\t \n\tvol->data1_zone_pos = vol->mft_zone_end;\n\tntfs_debug(\"vol->data1_zone_pos = 0x%llx\",\n\t\t\t(unsigned long long)vol->data1_zone_pos);\n\tvol->data2_zone_pos = 0;\n\tntfs_debug(\"vol->data2_zone_pos = 0x%llx\",\n\t\t\t(unsigned long long)vol->data2_zone_pos);\n\n\t \n\tvol->mft_data_pos = 24;\n\tntfs_debug(\"vol->mft_data_pos = 0x%llx\",\n\t\t\t(unsigned long long)vol->mft_data_pos);\n#endif  \n}\n\n#ifdef NTFS_RW\n\n \nstatic bool load_and_init_mft_mirror(ntfs_volume *vol)\n{\n\tstruct inode *tmp_ino;\n\tntfs_inode *tmp_ni;\n\n\tntfs_debug(\"Entering.\");\n\t \n\ttmp_ino = ntfs_iget(vol->sb, FILE_MFTMirr);\n\tif (IS_ERR(tmp_ino) || is_bad_inode(tmp_ino)) {\n\t\tif (!IS_ERR(tmp_ino))\n\t\t\tiput(tmp_ino);\n\t\t \n\t\treturn false;\n\t}\n\t \n\t \n\ttmp_ino->i_uid = GLOBAL_ROOT_UID;\n\ttmp_ino->i_gid = GLOBAL_ROOT_GID;\n\t \n\ttmp_ino->i_mode = S_IFREG;\n\t \n\ttmp_ino->i_op = &ntfs_empty_inode_ops;\n\ttmp_ino->i_fop = &ntfs_empty_file_ops;\n\t \n\ttmp_ino->i_mapping->a_ops = &ntfs_mst_aops;\n\ttmp_ni = NTFS_I(tmp_ino);\n\t \n\tNInoSetMstProtected(tmp_ni);\n\tNInoSetSparseDisabled(tmp_ni);\n\t \n\ttmp_ni->itype.index.block_size = vol->mft_record_size;\n\ttmp_ni->itype.index.block_size_bits = vol->mft_record_size_bits;\n\tvol->mftmirr_ino = tmp_ino;\n\tntfs_debug(\"Done.\");\n\treturn true;\n}\n\n \nstatic bool check_mft_mirror(ntfs_volume *vol)\n{\n\tstruct super_block *sb = vol->sb;\n\tntfs_inode *mirr_ni;\n\tstruct page *mft_page, *mirr_page;\n\tu8 *kmft, *kmirr;\n\trunlist_element *rl, rl2[2];\n\tpgoff_t index;\n\tint mrecs_per_page, i;\n\n\tntfs_debug(\"Entering.\");\n\t \n\tmrecs_per_page = PAGE_SIZE / vol->mft_record_size;\n\tBUG_ON(!mrecs_per_page);\n\tBUG_ON(!vol->mftmirr_size);\n\tmft_page = mirr_page = NULL;\n\tkmft = kmirr = NULL;\n\tindex = i = 0;\n\tdo {\n\t\tu32 bytes;\n\n\t\t \n\t\tif (!(i % mrecs_per_page)) {\n\t\t\tif (index) {\n\t\t\t\tntfs_unmap_page(mft_page);\n\t\t\t\tntfs_unmap_page(mirr_page);\n\t\t\t}\n\t\t\t \n\t\t\tmft_page = ntfs_map_page(vol->mft_ino->i_mapping,\n\t\t\t\t\tindex);\n\t\t\tif (IS_ERR(mft_page)) {\n\t\t\t\tntfs_error(sb, \"Failed to read $MFT.\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tkmft = page_address(mft_page);\n\t\t\t \n\t\t\tmirr_page = ntfs_map_page(vol->mftmirr_ino->i_mapping,\n\t\t\t\t\tindex);\n\t\t\tif (IS_ERR(mirr_page)) {\n\t\t\t\tntfs_error(sb, \"Failed to read $MFTMirr.\");\n\t\t\t\tgoto mft_unmap_out;\n\t\t\t}\n\t\t\tkmirr = page_address(mirr_page);\n\t\t\t++index;\n\t\t}\n\t\t \n\t\tif (((MFT_RECORD*)kmft)->flags & MFT_RECORD_IN_USE) {\n\t\t\t \n\t\t\tif (ntfs_is_baad_recordp((le32*)kmft)) {\n\t\t\t\tntfs_error(sb, \"Incomplete multi sector \"\n\t\t\t\t\t\t\"transfer detected in mft \"\n\t\t\t\t\t\t\"record %i.\", i);\nmm_unmap_out:\n\t\t\t\tntfs_unmap_page(mirr_page);\nmft_unmap_out:\n\t\t\t\tntfs_unmap_page(mft_page);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (((MFT_RECORD*)kmirr)->flags & MFT_RECORD_IN_USE) {\n\t\t\tif (ntfs_is_baad_recordp((le32*)kmirr)) {\n\t\t\t\tntfs_error(sb, \"Incomplete multi sector \"\n\t\t\t\t\t\t\"transfer detected in mft \"\n\t\t\t\t\t\t\"mirror record %i.\", i);\n\t\t\t\tgoto mm_unmap_out;\n\t\t\t}\n\t\t}\n\t\t \n\t\tbytes = le32_to_cpu(((MFT_RECORD*)kmft)->bytes_in_use);\n\t\tif (bytes < sizeof(MFT_RECORD_OLD) ||\n\t\t\t\tbytes > vol->mft_record_size ||\n\t\t\t\tntfs_is_baad_recordp((le32*)kmft)) {\n\t\t\tbytes = le32_to_cpu(((MFT_RECORD*)kmirr)->bytes_in_use);\n\t\t\tif (bytes < sizeof(MFT_RECORD_OLD) ||\n\t\t\t\t\tbytes > vol->mft_record_size ||\n\t\t\t\t\tntfs_is_baad_recordp((le32*)kmirr))\n\t\t\t\tbytes = vol->mft_record_size;\n\t\t}\n\t\t \n\t\tif (memcmp(kmft, kmirr, bytes)) {\n\t\t\tntfs_error(sb, \"$MFT and $MFTMirr (record %i) do not \"\n\t\t\t\t\t\"match.  Run ntfsfix or chkdsk.\", i);\n\t\t\tgoto mm_unmap_out;\n\t\t}\n\t\tkmft += vol->mft_record_size;\n\t\tkmirr += vol->mft_record_size;\n\t} while (++i < vol->mftmirr_size);\n\t \n\tntfs_unmap_page(mft_page);\n\tntfs_unmap_page(mirr_page);\n\n\t \n\trl2[0].vcn = 0;\n\trl2[0].lcn = vol->mftmirr_lcn;\n\trl2[0].length = (vol->mftmirr_size * vol->mft_record_size +\n\t\t\tvol->cluster_size - 1) / vol->cluster_size;\n\trl2[1].vcn = rl2[0].length;\n\trl2[1].lcn = LCN_ENOENT;\n\trl2[1].length = 0;\n\t \n\tmirr_ni = NTFS_I(vol->mftmirr_ino);\n\tdown_read(&mirr_ni->runlist.lock);\n\trl = mirr_ni->runlist.rl;\n\t \n\ti = 0;\n\tdo {\n\t\tif (rl2[i].vcn != rl[i].vcn || rl2[i].lcn != rl[i].lcn ||\n\t\t\t\trl2[i].length != rl[i].length) {\n\t\t\tntfs_error(sb, \"$MFTMirr location mismatch.  \"\n\t\t\t\t\t\"Run chkdsk.\");\n\t\t\tup_read(&mirr_ni->runlist.lock);\n\t\t\treturn false;\n\t\t}\n\t} while (rl2[i++].length);\n\tup_read(&mirr_ni->runlist.lock);\n\tntfs_debug(\"Done.\");\n\treturn true;\n}\n\n \nstatic bool load_and_check_logfile(ntfs_volume *vol,\n\t\tRESTART_PAGE_HEADER **rp)\n{\n\tstruct inode *tmp_ino;\n\n\tntfs_debug(\"Entering.\");\n\ttmp_ino = ntfs_iget(vol->sb, FILE_LogFile);\n\tif (IS_ERR(tmp_ino) || is_bad_inode(tmp_ino)) {\n\t\tif (!IS_ERR(tmp_ino))\n\t\t\tiput(tmp_ino);\n\t\t \n\t\treturn false;\n\t}\n\tif (!ntfs_check_logfile(tmp_ino, rp)) {\n\t\tiput(tmp_ino);\n\t\t \n\t\treturn false;\n\t}\n\tNInoSetSparseDisabled(NTFS_I(tmp_ino));\n\tvol->logfile_ino = tmp_ino;\n\tntfs_debug(\"Done.\");\n\treturn true;\n}\n\n#define NTFS_HIBERFIL_HEADER_SIZE\t4096\n\n \nstatic int check_windows_hibernation_status(ntfs_volume *vol)\n{\n\tMFT_REF mref;\n\tstruct inode *vi;\n\tstruct page *page;\n\tu32 *kaddr, *kend;\n\tntfs_name *name = NULL;\n\tint ret = 1;\n\tstatic const ntfschar hiberfil[13] = { cpu_to_le16('h'),\n\t\t\tcpu_to_le16('i'), cpu_to_le16('b'),\n\t\t\tcpu_to_le16('e'), cpu_to_le16('r'),\n\t\t\tcpu_to_le16('f'), cpu_to_le16('i'),\n\t\t\tcpu_to_le16('l'), cpu_to_le16('.'),\n\t\t\tcpu_to_le16('s'), cpu_to_le16('y'),\n\t\t\tcpu_to_le16('s'), 0 };\n\n\tntfs_debug(\"Entering.\");\n\t \n\tinode_lock(vol->root_ino);\n\tmref = ntfs_lookup_inode_by_name(NTFS_I(vol->root_ino), hiberfil, 12,\n\t\t\t&name);\n\tinode_unlock(vol->root_ino);\n\tif (IS_ERR_MREF(mref)) {\n\t\tret = MREF_ERR(mref);\n\t\t \n\t\tif (ret == -ENOENT) {\n\t\t\tntfs_debug(\"hiberfil.sys not present.  Windows is not \"\n\t\t\t\t\t\"hibernated on the volume.\");\n\t\t\treturn 0;\n\t\t}\n\t\t \n\t\tntfs_error(vol->sb, \"Failed to find inode number for \"\n\t\t\t\t\"hiberfil.sys.\");\n\t\treturn ret;\n\t}\n\t \n\tkfree(name);\n\t \n\tvi = ntfs_iget(vol->sb, MREF(mref));\n\tif (IS_ERR(vi) || is_bad_inode(vi)) {\n\t\tif (!IS_ERR(vi))\n\t\t\tiput(vi);\n\t\tntfs_error(vol->sb, \"Failed to load hiberfil.sys.\");\n\t\treturn IS_ERR(vi) ? PTR_ERR(vi) : -EIO;\n\t}\n\tif (unlikely(i_size_read(vi) < NTFS_HIBERFIL_HEADER_SIZE)) {\n\t\tntfs_debug(\"hiberfil.sys is smaller than 4kiB (0x%llx).  \"\n\t\t\t\t\"Windows is hibernated on the volume.  This \"\n\t\t\t\t\"is not the system volume.\", i_size_read(vi));\n\t\tgoto iput_out;\n\t}\n\tpage = ntfs_map_page(vi->i_mapping, 0);\n\tif (IS_ERR(page)) {\n\t\tntfs_error(vol->sb, \"Failed to read from hiberfil.sys.\");\n\t\tret = PTR_ERR(page);\n\t\tgoto iput_out;\n\t}\n\tkaddr = (u32*)page_address(page);\n\tif (*(le32*)kaddr == cpu_to_le32(0x72626968) ) {\n\t\tntfs_debug(\"Magic \\\"hibr\\\" found in hiberfil.sys.  Windows is \"\n\t\t\t\t\"hibernated on the volume.  This is the \"\n\t\t\t\t\"system volume.\");\n\t\tgoto unm_iput_out;\n\t}\n\tkend = kaddr + NTFS_HIBERFIL_HEADER_SIZE/sizeof(*kaddr);\n\tdo {\n\t\tif (unlikely(*kaddr)) {\n\t\t\tntfs_debug(\"hiberfil.sys is larger than 4kiB \"\n\t\t\t\t\t\"(0x%llx), does not contain the \"\n\t\t\t\t\t\"\\\"hibr\\\" magic, and does not have a \"\n\t\t\t\t\t\"zero header.  Windows is hibernated \"\n\t\t\t\t\t\"on the volume.  This is not the \"\n\t\t\t\t\t\"system volume.\", i_size_read(vi));\n\t\t\tgoto unm_iput_out;\n\t\t}\n\t} while (++kaddr < kend);\n\tntfs_debug(\"hiberfil.sys contains a zero header.  Windows is not \"\n\t\t\t\"hibernated on the volume.  This is the system \"\n\t\t\t\"volume.\");\n\tret = 0;\nunm_iput_out:\n\tntfs_unmap_page(page);\niput_out:\n\tiput(vi);\n\treturn ret;\n}\n\n \nstatic bool load_and_init_quota(ntfs_volume *vol)\n{\n\tMFT_REF mref;\n\tstruct inode *tmp_ino;\n\tntfs_name *name = NULL;\n\tstatic const ntfschar Quota[7] = { cpu_to_le16('$'),\n\t\t\tcpu_to_le16('Q'), cpu_to_le16('u'),\n\t\t\tcpu_to_le16('o'), cpu_to_le16('t'),\n\t\t\tcpu_to_le16('a'), 0 };\n\tstatic ntfschar Q[3] = { cpu_to_le16('$'),\n\t\t\tcpu_to_le16('Q'), 0 };\n\n\tntfs_debug(\"Entering.\");\n\t \n\tinode_lock(vol->extend_ino);\n\tmref = ntfs_lookup_inode_by_name(NTFS_I(vol->extend_ino), Quota, 6,\n\t\t\t&name);\n\tinode_unlock(vol->extend_ino);\n\tif (IS_ERR_MREF(mref)) {\n\t\t \n\t\tif (MREF_ERR(mref) == -ENOENT) {\n\t\t\tntfs_debug(\"$Quota not present.  Volume does not have \"\n\t\t\t\t\t\"quotas enabled.\");\n\t\t\t \n\t\t\tNVolSetQuotaOutOfDate(vol);\n\t\t\treturn true;\n\t\t}\n\t\t \n\t\tntfs_error(vol->sb, \"Failed to find inode number for $Quota.\");\n\t\treturn false;\n\t}\n\t \n\tkfree(name);\n\t \n\ttmp_ino = ntfs_iget(vol->sb, MREF(mref));\n\tif (IS_ERR(tmp_ino) || is_bad_inode(tmp_ino)) {\n\t\tif (!IS_ERR(tmp_ino))\n\t\t\tiput(tmp_ino);\n\t\tntfs_error(vol->sb, \"Failed to load $Quota.\");\n\t\treturn false;\n\t}\n\tvol->quota_ino = tmp_ino;\n\t \n\ttmp_ino = ntfs_index_iget(vol->quota_ino, Q, 2);\n\tif (IS_ERR(tmp_ino)) {\n\t\tntfs_error(vol->sb, \"Failed to load $Quota/$Q index.\");\n\t\treturn false;\n\t}\n\tvol->quota_q_ino = tmp_ino;\n\tntfs_debug(\"Done.\");\n\treturn true;\n}\n\n \nstatic bool load_and_init_usnjrnl(ntfs_volume *vol)\n{\n\tMFT_REF mref;\n\tstruct inode *tmp_ino;\n\tntfs_inode *tmp_ni;\n\tstruct page *page;\n\tntfs_name *name = NULL;\n\tUSN_HEADER *uh;\n\tstatic const ntfschar UsnJrnl[9] = { cpu_to_le16('$'),\n\t\t\tcpu_to_le16('U'), cpu_to_le16('s'),\n\t\t\tcpu_to_le16('n'), cpu_to_le16('J'),\n\t\t\tcpu_to_le16('r'), cpu_to_le16('n'),\n\t\t\tcpu_to_le16('l'), 0 };\n\tstatic ntfschar Max[5] = { cpu_to_le16('$'),\n\t\t\tcpu_to_le16('M'), cpu_to_le16('a'),\n\t\t\tcpu_to_le16('x'), 0 };\n\tstatic ntfschar J[3] = { cpu_to_le16('$'),\n\t\t\tcpu_to_le16('J'), 0 };\n\n\tntfs_debug(\"Entering.\");\n\t \n\tinode_lock(vol->extend_ino);\n\tmref = ntfs_lookup_inode_by_name(NTFS_I(vol->extend_ino), UsnJrnl, 8,\n\t\t\t&name);\n\tinode_unlock(vol->extend_ino);\n\tif (IS_ERR_MREF(mref)) {\n\t\t \n\t\tif (MREF_ERR(mref) == -ENOENT) {\n\t\t\tntfs_debug(\"$UsnJrnl not present.  Volume does not \"\n\t\t\t\t\t\"have transaction logging enabled.\");\nnot_enabled:\n\t\t\t \n\t\t\tNVolSetUsnJrnlStamped(vol);\n\t\t\treturn true;\n\t\t}\n\t\t \n\t\tntfs_error(vol->sb, \"Failed to find inode number for \"\n\t\t\t\t\"$UsnJrnl.\");\n\t\treturn false;\n\t}\n\t \n\tkfree(name);\n\t \n\ttmp_ino = ntfs_iget(vol->sb, MREF(mref));\n\tif (IS_ERR(tmp_ino) || unlikely(is_bad_inode(tmp_ino))) {\n\t\tif (!IS_ERR(tmp_ino))\n\t\t\tiput(tmp_ino);\n\t\tntfs_error(vol->sb, \"Failed to load $UsnJrnl.\");\n\t\treturn false;\n\t}\n\tvol->usnjrnl_ino = tmp_ino;\n\t \n\tif (unlikely(vol->vol_flags & VOLUME_DELETE_USN_UNDERWAY)) {\n\t\tntfs_debug(\"$UsnJrnl in the process of being disabled.  \"\n\t\t\t\t\"Volume does not have transaction logging \"\n\t\t\t\t\"enabled.\");\n\t\tgoto not_enabled;\n\t}\n\t \n\ttmp_ino = ntfs_attr_iget(vol->usnjrnl_ino, AT_DATA, Max, 4);\n\tif (IS_ERR(tmp_ino)) {\n\t\tntfs_error(vol->sb, \"Failed to load $UsnJrnl/$DATA/$Max \"\n\t\t\t\t\"attribute.\");\n\t\treturn false;\n\t}\n\tvol->usnjrnl_max_ino = tmp_ino;\n\tif (unlikely(i_size_read(tmp_ino) < sizeof(USN_HEADER))) {\n\t\tntfs_error(vol->sb, \"Found corrupt $UsnJrnl/$DATA/$Max \"\n\t\t\t\t\"attribute (size is 0x%llx but should be at \"\n\t\t\t\t\"least 0x%zx bytes).\", i_size_read(tmp_ino),\n\t\t\t\tsizeof(USN_HEADER));\n\t\treturn false;\n\t}\n\t \n\ttmp_ino = ntfs_attr_iget(vol->usnjrnl_ino, AT_DATA, J, 2);\n\tif (IS_ERR(tmp_ino)) {\n\t\tntfs_error(vol->sb, \"Failed to load $UsnJrnl/$DATA/$J \"\n\t\t\t\t\"attribute.\");\n\t\treturn false;\n\t}\n\tvol->usnjrnl_j_ino = tmp_ino;\n\t \n\ttmp_ni = NTFS_I(vol->usnjrnl_j_ino);\n\tif (unlikely(!NInoNonResident(tmp_ni) || !NInoSparse(tmp_ni))) {\n\t\tntfs_error(vol->sb, \"$UsnJrnl/$DATA/$J attribute is resident \"\n\t\t\t\t\"and/or not sparse.\");\n\t\treturn false;\n\t}\n\t \n\tpage = ntfs_map_page(vol->usnjrnl_max_ino->i_mapping, 0);\n\tif (IS_ERR(page)) {\n\t\tntfs_error(vol->sb, \"Failed to read from $UsnJrnl/$DATA/$Max \"\n\t\t\t\t\"attribute.\");\n\t\treturn false;\n\t}\n\tuh = (USN_HEADER*)page_address(page);\n\t \n\tif (unlikely(sle64_to_cpu(uh->allocation_delta) >\n\t\t\tsle64_to_cpu(uh->maximum_size))) {\n\t\tntfs_error(vol->sb, \"Allocation delta (0x%llx) exceeds \"\n\t\t\t\t\"maximum size (0x%llx).  $UsnJrnl is corrupt.\",\n\t\t\t\t(long long)sle64_to_cpu(uh->allocation_delta),\n\t\t\t\t(long long)sle64_to_cpu(uh->maximum_size));\n\t\tntfs_unmap_page(page);\n\t\treturn false;\n\t}\n\t \n\tif (unlikely(sle64_to_cpu(uh->lowest_valid_usn) >=\n\t\t\ti_size_read(vol->usnjrnl_j_ino))) {\n\t\tif (likely(sle64_to_cpu(uh->lowest_valid_usn) ==\n\t\t\t\ti_size_read(vol->usnjrnl_j_ino))) {\n\t\t\tntfs_unmap_page(page);\n\t\t\tntfs_debug(\"$UsnJrnl is enabled but nothing has been \"\n\t\t\t\t\t\"logged since it was last stamped.  \"\n\t\t\t\t\t\"Treating this as if the volume does \"\n\t\t\t\t\t\"not have transaction logging \"\n\t\t\t\t\t\"enabled.\");\n\t\t\tgoto not_enabled;\n\t\t}\n\t\tntfs_error(vol->sb, \"$UsnJrnl has lowest valid usn (0x%llx) \"\n\t\t\t\t\"which is out of bounds (0x%llx).  $UsnJrnl \"\n\t\t\t\t\"is corrupt.\",\n\t\t\t\t(long long)sle64_to_cpu(uh->lowest_valid_usn),\n\t\t\t\ti_size_read(vol->usnjrnl_j_ino));\n\t\tntfs_unmap_page(page);\n\t\treturn false;\n\t}\n\tntfs_unmap_page(page);\n\tntfs_debug(\"Done.\");\n\treturn true;\n}\n\n \nstatic bool load_and_init_attrdef(ntfs_volume *vol)\n{\n\tloff_t i_size;\n\tstruct super_block *sb = vol->sb;\n\tstruct inode *ino;\n\tstruct page *page;\n\tpgoff_t index, max_index;\n\tunsigned int size;\n\n\tntfs_debug(\"Entering.\");\n\t \n\tino = ntfs_iget(sb, FILE_AttrDef);\n\tif (IS_ERR(ino) || is_bad_inode(ino)) {\n\t\tif (!IS_ERR(ino))\n\t\t\tiput(ino);\n\t\tgoto failed;\n\t}\n\tNInoSetSparseDisabled(NTFS_I(ino));\n\t \n\ti_size = i_size_read(ino);\n\tif (i_size <= 0 || i_size > 0x7fffffff)\n\t\tgoto iput_failed;\n\tvol->attrdef = (ATTR_DEF*)ntfs_malloc_nofs(i_size);\n\tif (!vol->attrdef)\n\t\tgoto iput_failed;\n\tindex = 0;\n\tmax_index = i_size >> PAGE_SHIFT;\n\tsize = PAGE_SIZE;\n\twhile (index < max_index) {\n\t\t \nread_partial_attrdef_page:\n\t\tpage = ntfs_map_page(ino->i_mapping, index);\n\t\tif (IS_ERR(page))\n\t\t\tgoto free_iput_failed;\n\t\tmemcpy((u8*)vol->attrdef + (index++ << PAGE_SHIFT),\n\t\t\t\tpage_address(page), size);\n\t\tntfs_unmap_page(page);\n\t}\n\tif (size == PAGE_SIZE) {\n\t\tsize = i_size & ~PAGE_MASK;\n\t\tif (size)\n\t\t\tgoto read_partial_attrdef_page;\n\t}\n\tvol->attrdef_size = i_size;\n\tntfs_debug(\"Read %llu bytes from $AttrDef.\", i_size);\n\tiput(ino);\n\treturn true;\nfree_iput_failed:\n\tntfs_free(vol->attrdef);\n\tvol->attrdef = NULL;\niput_failed:\n\tiput(ino);\nfailed:\n\tntfs_error(sb, \"Failed to initialize attribute definition table.\");\n\treturn false;\n}\n\n#endif  \n\n \nstatic bool load_and_init_upcase(ntfs_volume *vol)\n{\n\tloff_t i_size;\n\tstruct super_block *sb = vol->sb;\n\tstruct inode *ino;\n\tstruct page *page;\n\tpgoff_t index, max_index;\n\tunsigned int size;\n\tint i, max;\n\n\tntfs_debug(\"Entering.\");\n\t \n\tino = ntfs_iget(sb, FILE_UpCase);\n\tif (IS_ERR(ino) || is_bad_inode(ino)) {\n\t\tif (!IS_ERR(ino))\n\t\t\tiput(ino);\n\t\tgoto upcase_failed;\n\t}\n\t \n\ti_size = i_size_read(ino);\n\tif (!i_size || i_size & (sizeof(ntfschar) - 1) ||\n\t\t\ti_size > 64ULL * 1024 * sizeof(ntfschar))\n\t\tgoto iput_upcase_failed;\n\tvol->upcase = (ntfschar*)ntfs_malloc_nofs(i_size);\n\tif (!vol->upcase)\n\t\tgoto iput_upcase_failed;\n\tindex = 0;\n\tmax_index = i_size >> PAGE_SHIFT;\n\tsize = PAGE_SIZE;\n\twhile (index < max_index) {\n\t\t \nread_partial_upcase_page:\n\t\tpage = ntfs_map_page(ino->i_mapping, index);\n\t\tif (IS_ERR(page))\n\t\t\tgoto iput_upcase_failed;\n\t\tmemcpy((char*)vol->upcase + (index++ << PAGE_SHIFT),\n\t\t\t\tpage_address(page), size);\n\t\tntfs_unmap_page(page);\n\t}\n\tif (size == PAGE_SIZE) {\n\t\tsize = i_size & ~PAGE_MASK;\n\t\tif (size)\n\t\t\tgoto read_partial_upcase_page;\n\t}\n\tvol->upcase_len = i_size >> UCHAR_T_SIZE_BITS;\n\tntfs_debug(\"Read %llu bytes from $UpCase (expected %zu bytes).\",\n\t\t\ti_size, 64 * 1024 * sizeof(ntfschar));\n\tiput(ino);\n\tmutex_lock(&ntfs_lock);\n\tif (!default_upcase) {\n\t\tntfs_debug(\"Using volume specified $UpCase since default is \"\n\t\t\t\t\"not present.\");\n\t\tmutex_unlock(&ntfs_lock);\n\t\treturn true;\n\t}\n\tmax = default_upcase_len;\n\tif (max > vol->upcase_len)\n\t\tmax = vol->upcase_len;\n\tfor (i = 0; i < max; i++)\n\t\tif (vol->upcase[i] != default_upcase[i])\n\t\t\tbreak;\n\tif (i == max) {\n\t\tntfs_free(vol->upcase);\n\t\tvol->upcase = default_upcase;\n\t\tvol->upcase_len = max;\n\t\tntfs_nr_upcase_users++;\n\t\tmutex_unlock(&ntfs_lock);\n\t\tntfs_debug(\"Volume specified $UpCase matches default. Using \"\n\t\t\t\t\"default.\");\n\t\treturn true;\n\t}\n\tmutex_unlock(&ntfs_lock);\n\tntfs_debug(\"Using volume specified $UpCase since it does not match \"\n\t\t\t\"the default.\");\n\treturn true;\niput_upcase_failed:\n\tiput(ino);\n\tntfs_free(vol->upcase);\n\tvol->upcase = NULL;\nupcase_failed:\n\tmutex_lock(&ntfs_lock);\n\tif (default_upcase) {\n\t\tvol->upcase = default_upcase;\n\t\tvol->upcase_len = default_upcase_len;\n\t\tntfs_nr_upcase_users++;\n\t\tmutex_unlock(&ntfs_lock);\n\t\tntfs_error(sb, \"Failed to load $UpCase from the volume. Using \"\n\t\t\t\t\"default.\");\n\t\treturn true;\n\t}\n\tmutex_unlock(&ntfs_lock);\n\tntfs_error(sb, \"Failed to initialize upcase table.\");\n\treturn false;\n}\n\n \nstatic struct lock_class_key\n\tlcnbmp_runlist_lock_key, lcnbmp_mrec_lock_key,\n\tmftbmp_runlist_lock_key, mftbmp_mrec_lock_key;\n\n \nstatic bool load_system_files(ntfs_volume *vol)\n{\n\tstruct super_block *sb = vol->sb;\n\tMFT_RECORD *m;\n\tVOLUME_INFORMATION *vi;\n\tntfs_attr_search_ctx *ctx;\n#ifdef NTFS_RW\n\tRESTART_PAGE_HEADER *rp;\n\tint err;\n#endif  \n\n\tntfs_debug(\"Entering.\");\n#ifdef NTFS_RW\n\t \n\tif (!load_and_init_mft_mirror(vol) || !check_mft_mirror(vol)) {\n\t\tstatic const char *es1 = \"Failed to load $MFTMirr\";\n\t\tstatic const char *es2 = \"$MFTMirr does not match $MFT\";\n\t\tstatic const char *es3 = \".  Run ntfsfix and/or chkdsk.\";\n\n\t\t \n\t\tif (!sb_rdonly(sb)) {\n\t\t\tif (!(vol->on_errors & (ON_ERRORS_REMOUNT_RO |\n\t\t\t\t\tON_ERRORS_CONTINUE))) {\n\t\t\t\tntfs_error(sb, \"%s and neither on_errors=\"\n\t\t\t\t\t\t\"continue nor on_errors=\"\n\t\t\t\t\t\t\"remount-ro was specified%s\",\n\t\t\t\t\t\t!vol->mftmirr_ino ? es1 : es2,\n\t\t\t\t\t\tes3);\n\t\t\t\tgoto iput_mirr_err_out;\n\t\t\t}\n\t\t\tsb->s_flags |= SB_RDONLY;\n\t\t\tntfs_error(sb, \"%s.  Mounting read-only%s\",\n\t\t\t\t\t!vol->mftmirr_ino ? es1 : es2, es3);\n\t\t} else\n\t\t\tntfs_warning(sb, \"%s.  Will not be able to remount \"\n\t\t\t\t\t\"read-write%s\",\n\t\t\t\t\t!vol->mftmirr_ino ? es1 : es2, es3);\n\t\t \n\t\tNVolSetErrors(vol);\n\t}\n#endif  \n\t \n\tvol->mftbmp_ino = ntfs_attr_iget(vol->mft_ino, AT_BITMAP, NULL, 0);\n\tif (IS_ERR(vol->mftbmp_ino)) {\n\t\tntfs_error(sb, \"Failed to load $MFT/$BITMAP attribute.\");\n\t\tgoto iput_mirr_err_out;\n\t}\n\tlockdep_set_class(&NTFS_I(vol->mftbmp_ino)->runlist.lock,\n\t\t\t   &mftbmp_runlist_lock_key);\n\tlockdep_set_class(&NTFS_I(vol->mftbmp_ino)->mrec_lock,\n\t\t\t   &mftbmp_mrec_lock_key);\n\t \n\tif (!load_and_init_upcase(vol))\n\t\tgoto iput_mftbmp_err_out;\n#ifdef NTFS_RW\n\t \n\tif (!load_and_init_attrdef(vol))\n\t\tgoto iput_upcase_err_out;\n#endif  \n\t \n\tvol->lcnbmp_ino = ntfs_iget(sb, FILE_Bitmap);\n\tif (IS_ERR(vol->lcnbmp_ino) || is_bad_inode(vol->lcnbmp_ino)) {\n\t\tif (!IS_ERR(vol->lcnbmp_ino))\n\t\t\tiput(vol->lcnbmp_ino);\n\t\tgoto bitmap_failed;\n\t}\n\tlockdep_set_class(&NTFS_I(vol->lcnbmp_ino)->runlist.lock,\n\t\t\t   &lcnbmp_runlist_lock_key);\n\tlockdep_set_class(&NTFS_I(vol->lcnbmp_ino)->mrec_lock,\n\t\t\t   &lcnbmp_mrec_lock_key);\n\n\tNInoSetSparseDisabled(NTFS_I(vol->lcnbmp_ino));\n\tif ((vol->nr_clusters + 7) >> 3 > i_size_read(vol->lcnbmp_ino)) {\n\t\tiput(vol->lcnbmp_ino);\nbitmap_failed:\n\t\tntfs_error(sb, \"Failed to load $Bitmap.\");\n\t\tgoto iput_attrdef_err_out;\n\t}\n\t \n\tvol->vol_ino = ntfs_iget(sb, FILE_Volume);\n\tif (IS_ERR(vol->vol_ino) || is_bad_inode(vol->vol_ino)) {\n\t\tif (!IS_ERR(vol->vol_ino))\n\t\t\tiput(vol->vol_ino);\nvolume_failed:\n\t\tntfs_error(sb, \"Failed to load $Volume.\");\n\t\tgoto iput_lcnbmp_err_out;\n\t}\n\tm = map_mft_record(NTFS_I(vol->vol_ino));\n\tif (IS_ERR(m)) {\niput_volume_failed:\n\t\tiput(vol->vol_ino);\n\t\tgoto volume_failed;\n\t}\n\tif (!(ctx = ntfs_attr_get_search_ctx(NTFS_I(vol->vol_ino), m))) {\n\t\tntfs_error(sb, \"Failed to get attribute search context.\");\n\t\tgoto get_ctx_vol_failed;\n\t}\n\tif (ntfs_attr_lookup(AT_VOLUME_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx) || ctx->attr->non_resident || ctx->attr->flags) {\nerr_put_vol:\n\t\tntfs_attr_put_search_ctx(ctx);\nget_ctx_vol_failed:\n\t\tunmap_mft_record(NTFS_I(vol->vol_ino));\n\t\tgoto iput_volume_failed;\n\t}\n\tvi = (VOLUME_INFORMATION*)((char*)ctx->attr +\n\t\t\tle16_to_cpu(ctx->attr->data.resident.value_offset));\n\t \n\tif ((u8*)vi < (u8*)ctx->attr || (u8*)vi +\n\t\t\tle32_to_cpu(ctx->attr->data.resident.value_length) >\n\t\t\t(u8*)ctx->attr + le32_to_cpu(ctx->attr->length))\n\t\tgoto err_put_vol;\n\t \n\tvol->vol_flags = vi->flags;\n\tvol->major_ver = vi->major_ver;\n\tvol->minor_ver = vi->minor_ver;\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(NTFS_I(vol->vol_ino));\n\tpr_info(\"volume version %i.%i.\\n\", vol->major_ver,\n\t\t\tvol->minor_ver);\n\tif (vol->major_ver < 3 && NVolSparseEnabled(vol)) {\n\t\tntfs_warning(vol->sb, \"Disabling sparse support due to NTFS \"\n\t\t\t\t\"volume version %i.%i (need at least version \"\n\t\t\t\t\"3.0).\", vol->major_ver, vol->minor_ver);\n\t\tNVolClearSparseEnabled(vol);\n\t}\n#ifdef NTFS_RW\n\t \n\tif (vol->vol_flags & VOLUME_MUST_MOUNT_RO_MASK) {\n\t\tstatic const char *es1a = \"Volume is dirty\";\n\t\tstatic const char *es1b = \"Volume has been modified by chkdsk\";\n\t\tstatic const char *es1c = \"Volume has unsupported flags set\";\n\t\tstatic const char *es2a = \".  Run chkdsk and mount in Windows.\";\n\t\tstatic const char *es2b = \".  Mount in Windows.\";\n\t\tconst char *es1, *es2;\n\n\t\tes2 = es2a;\n\t\tif (vol->vol_flags & VOLUME_IS_DIRTY)\n\t\t\tes1 = es1a;\n\t\telse if (vol->vol_flags & VOLUME_MODIFIED_BY_CHKDSK) {\n\t\t\tes1 = es1b;\n\t\t\tes2 = es2b;\n\t\t} else {\n\t\t\tes1 = es1c;\n\t\t\tntfs_warning(sb, \"Unsupported volume flags 0x%x \"\n\t\t\t\t\t\"encountered.\",\n\t\t\t\t\t(unsigned)le16_to_cpu(vol->vol_flags));\n\t\t}\n\t\t \n\t\tif (!sb_rdonly(sb)) {\n\t\t\tif (!(vol->on_errors & (ON_ERRORS_REMOUNT_RO |\n\t\t\t\t\tON_ERRORS_CONTINUE))) {\n\t\t\t\tntfs_error(sb, \"%s and neither on_errors=\"\n\t\t\t\t\t\t\"continue nor on_errors=\"\n\t\t\t\t\t\t\"remount-ro was specified%s\",\n\t\t\t\t\t\tes1, es2);\n\t\t\t\tgoto iput_vol_err_out;\n\t\t\t}\n\t\t\tsb->s_flags |= SB_RDONLY;\n\t\t\tntfs_error(sb, \"%s.  Mounting read-only%s\", es1, es2);\n\t\t} else\n\t\t\tntfs_warning(sb, \"%s.  Will not be able to remount \"\n\t\t\t\t\t\"read-write%s\", es1, es2);\n\t\t \n\t}\n\t \n\trp = NULL;\n\tif (!load_and_check_logfile(vol, &rp) ||\n\t\t\t!ntfs_is_logfile_clean(vol->logfile_ino, rp)) {\n\t\tstatic const char *es1a = \"Failed to load $LogFile\";\n\t\tstatic const char *es1b = \"$LogFile is not clean\";\n\t\tstatic const char *es2 = \".  Mount in Windows.\";\n\t\tconst char *es1;\n\n\t\tes1 = !vol->logfile_ino ? es1a : es1b;\n\t\t \n\t\tif (!sb_rdonly(sb)) {\n\t\t\tif (!(vol->on_errors & (ON_ERRORS_REMOUNT_RO |\n\t\t\t\t\tON_ERRORS_CONTINUE))) {\n\t\t\t\tntfs_error(sb, \"%s and neither on_errors=\"\n\t\t\t\t\t\t\"continue nor on_errors=\"\n\t\t\t\t\t\t\"remount-ro was specified%s\",\n\t\t\t\t\t\tes1, es2);\n\t\t\t\tif (vol->logfile_ino) {\n\t\t\t\t\tBUG_ON(!rp);\n\t\t\t\t\tntfs_free(rp);\n\t\t\t\t}\n\t\t\t\tgoto iput_logfile_err_out;\n\t\t\t}\n\t\t\tsb->s_flags |= SB_RDONLY;\n\t\t\tntfs_error(sb, \"%s.  Mounting read-only%s\", es1, es2);\n\t\t} else\n\t\t\tntfs_warning(sb, \"%s.  Will not be able to remount \"\n\t\t\t\t\t\"read-write%s\", es1, es2);\n\t\t \n\t\tNVolSetErrors(vol);\n\t}\n\tntfs_free(rp);\n#endif  \n\t \n\tvol->root_ino = ntfs_iget(sb, FILE_root);\n\tif (IS_ERR(vol->root_ino) || is_bad_inode(vol->root_ino)) {\n\t\tif (!IS_ERR(vol->root_ino))\n\t\t\tiput(vol->root_ino);\n\t\tntfs_error(sb, \"Failed to load root directory.\");\n\t\tgoto iput_logfile_err_out;\n\t}\n#ifdef NTFS_RW\n\t \n\terr = check_windows_hibernation_status(vol);\n\tif (unlikely(err)) {\n\t\tstatic const char *es1a = \"Failed to determine if Windows is \"\n\t\t\t\t\"hibernated\";\n\t\tstatic const char *es1b = \"Windows is hibernated\";\n\t\tstatic const char *es2 = \".  Run chkdsk.\";\n\t\tconst char *es1;\n\n\t\tes1 = err < 0 ? es1a : es1b;\n\t\t \n\t\tif (!sb_rdonly(sb)) {\n\t\t\tif (!(vol->on_errors & (ON_ERRORS_REMOUNT_RO |\n\t\t\t\t\tON_ERRORS_CONTINUE))) {\n\t\t\t\tntfs_error(sb, \"%s and neither on_errors=\"\n\t\t\t\t\t\t\"continue nor on_errors=\"\n\t\t\t\t\t\t\"remount-ro was specified%s\",\n\t\t\t\t\t\tes1, es2);\n\t\t\t\tgoto iput_root_err_out;\n\t\t\t}\n\t\t\tsb->s_flags |= SB_RDONLY;\n\t\t\tntfs_error(sb, \"%s.  Mounting read-only%s\", es1, es2);\n\t\t} else\n\t\t\tntfs_warning(sb, \"%s.  Will not be able to remount \"\n\t\t\t\t\t\"read-write%s\", es1, es2);\n\t\t \n\t\tNVolSetErrors(vol);\n\t}\n\t \n\tif (!sb_rdonly(sb) && ntfs_set_volume_flags(vol, VOLUME_IS_DIRTY)) {\n\t\tstatic const char *es1 = \"Failed to set dirty bit in volume \"\n\t\t\t\t\"information flags\";\n\t\tstatic const char *es2 = \".  Run chkdsk.\";\n\n\t\t \n\t\tif (!(vol->on_errors & (ON_ERRORS_REMOUNT_RO |\n\t\t\t\tON_ERRORS_CONTINUE))) {\n\t\t\tntfs_error(sb, \"%s and neither on_errors=continue nor \"\n\t\t\t\t\t\"on_errors=remount-ro was specified%s\",\n\t\t\t\t\tes1, es2);\n\t\t\tgoto iput_root_err_out;\n\t\t}\n\t\tntfs_error(sb, \"%s.  Mounting read-only%s\", es1, es2);\n\t\tsb->s_flags |= SB_RDONLY;\n\t\t \n\t}\n#if 0\n\t \n\t \n\t \n\tif (!(sb->s_flags & SB_RDONLY) && (vol->major_ver > 1) &&\n\t\t\tntfs_set_volume_flags(vol, VOLUME_MOUNTED_ON_NT4)) {\n\t\tstatic const char *es1 = \"Failed to set NT4 compatibility flag\";\n\t\tstatic const char *es2 = \".  Run chkdsk.\";\n\n\t\t \n\t\tif (!(vol->on_errors & (ON_ERRORS_REMOUNT_RO |\n\t\t\t\tON_ERRORS_CONTINUE))) {\n\t\t\tntfs_error(sb, \"%s and neither on_errors=continue nor \"\n\t\t\t\t\t\"on_errors=remount-ro was specified%s\",\n\t\t\t\t\tes1, es2);\n\t\t\tgoto iput_root_err_out;\n\t\t}\n\t\tntfs_error(sb, \"%s.  Mounting read-only%s\", es1, es2);\n\t\tsb->s_flags |= SB_RDONLY;\n\t\tNVolSetErrors(vol);\n\t}\n#endif\n\t \n\tif (!sb_rdonly(sb) && !ntfs_empty_logfile(vol->logfile_ino)) {\n\t\tstatic const char *es1 = \"Failed to empty $LogFile\";\n\t\tstatic const char *es2 = \".  Mount in Windows.\";\n\n\t\t \n\t\tif (!(vol->on_errors & (ON_ERRORS_REMOUNT_RO |\n\t\t\t\tON_ERRORS_CONTINUE))) {\n\t\t\tntfs_error(sb, \"%s and neither on_errors=continue nor \"\n\t\t\t\t\t\"on_errors=remount-ro was specified%s\",\n\t\t\t\t\tes1, es2);\n\t\t\tgoto iput_root_err_out;\n\t\t}\n\t\tntfs_error(sb, \"%s.  Mounting read-only%s\", es1, es2);\n\t\tsb->s_flags |= SB_RDONLY;\n\t\tNVolSetErrors(vol);\n\t}\n#endif  \n\t \n\tif (unlikely(vol->major_ver < 3))\n\t\treturn true;\n\t \n\t \n\tvol->secure_ino = ntfs_iget(sb, FILE_Secure);\n\tif (IS_ERR(vol->secure_ino) || is_bad_inode(vol->secure_ino)) {\n\t\tif (!IS_ERR(vol->secure_ino))\n\t\t\tiput(vol->secure_ino);\n\t\tntfs_error(sb, \"Failed to load $Secure.\");\n\t\tgoto iput_root_err_out;\n\t}\n\t \n\t \n\tvol->extend_ino = ntfs_iget(sb, FILE_Extend);\n\tif (IS_ERR(vol->extend_ino) || is_bad_inode(vol->extend_ino) ||\n\t    !S_ISDIR(vol->extend_ino->i_mode)) {\n\t\tif (!IS_ERR(vol->extend_ino))\n\t\t\tiput(vol->extend_ino);\n\t\tntfs_error(sb, \"Failed to load $Extend.\");\n\t\tgoto iput_sec_err_out;\n\t}\n#ifdef NTFS_RW\n\t \n\tif (!load_and_init_quota(vol)) {\n\t\tstatic const char *es1 = \"Failed to load $Quota\";\n\t\tstatic const char *es2 = \".  Run chkdsk.\";\n\n\t\t \n\t\tif (!sb_rdonly(sb)) {\n\t\t\tif (!(vol->on_errors & (ON_ERRORS_REMOUNT_RO |\n\t\t\t\t\tON_ERRORS_CONTINUE))) {\n\t\t\t\tntfs_error(sb, \"%s and neither on_errors=\"\n\t\t\t\t\t\t\"continue nor on_errors=\"\n\t\t\t\t\t\t\"remount-ro was specified%s\",\n\t\t\t\t\t\tes1, es2);\n\t\t\t\tgoto iput_quota_err_out;\n\t\t\t}\n\t\t\tsb->s_flags |= SB_RDONLY;\n\t\t\tntfs_error(sb, \"%s.  Mounting read-only%s\", es1, es2);\n\t\t} else\n\t\t\tntfs_warning(sb, \"%s.  Will not be able to remount \"\n\t\t\t\t\t\"read-write%s\", es1, es2);\n\t\t \n\t\tNVolSetErrors(vol);\n\t}\n\t \n\tif (!sb_rdonly(sb) && !ntfs_mark_quotas_out_of_date(vol)) {\n\t\tstatic const char *es1 = \"Failed to mark quotas out of date\";\n\t\tstatic const char *es2 = \".  Run chkdsk.\";\n\n\t\t \n\t\tif (!(vol->on_errors & (ON_ERRORS_REMOUNT_RO |\n\t\t\t\tON_ERRORS_CONTINUE))) {\n\t\t\tntfs_error(sb, \"%s and neither on_errors=continue nor \"\n\t\t\t\t\t\"on_errors=remount-ro was specified%s\",\n\t\t\t\t\tes1, es2);\n\t\t\tgoto iput_quota_err_out;\n\t\t}\n\t\tntfs_error(sb, \"%s.  Mounting read-only%s\", es1, es2);\n\t\tsb->s_flags |= SB_RDONLY;\n\t\tNVolSetErrors(vol);\n\t}\n\t \n\tif (!load_and_init_usnjrnl(vol)) {\n\t\tstatic const char *es1 = \"Failed to load $UsnJrnl\";\n\t\tstatic const char *es2 = \".  Run chkdsk.\";\n\n\t\t \n\t\tif (!sb_rdonly(sb)) {\n\t\t\tif (!(vol->on_errors & (ON_ERRORS_REMOUNT_RO |\n\t\t\t\t\tON_ERRORS_CONTINUE))) {\n\t\t\t\tntfs_error(sb, \"%s and neither on_errors=\"\n\t\t\t\t\t\t\"continue nor on_errors=\"\n\t\t\t\t\t\t\"remount-ro was specified%s\",\n\t\t\t\t\t\tes1, es2);\n\t\t\t\tgoto iput_usnjrnl_err_out;\n\t\t\t}\n\t\t\tsb->s_flags |= SB_RDONLY;\n\t\t\tntfs_error(sb, \"%s.  Mounting read-only%s\", es1, es2);\n\t\t} else\n\t\t\tntfs_warning(sb, \"%s.  Will not be able to remount \"\n\t\t\t\t\t\"read-write%s\", es1, es2);\n\t\t \n\t\tNVolSetErrors(vol);\n\t}\n\t \n\tif (!sb_rdonly(sb) && !ntfs_stamp_usnjrnl(vol)) {\n\t\tstatic const char *es1 = \"Failed to stamp transaction log \"\n\t\t\t\t\"($UsnJrnl)\";\n\t\tstatic const char *es2 = \".  Run chkdsk.\";\n\n\t\t \n\t\tif (!(vol->on_errors & (ON_ERRORS_REMOUNT_RO |\n\t\t\t\tON_ERRORS_CONTINUE))) {\n\t\t\tntfs_error(sb, \"%s and neither on_errors=continue nor \"\n\t\t\t\t\t\"on_errors=remount-ro was specified%s\",\n\t\t\t\t\tes1, es2);\n\t\t\tgoto iput_usnjrnl_err_out;\n\t\t}\n\t\tntfs_error(sb, \"%s.  Mounting read-only%s\", es1, es2);\n\t\tsb->s_flags |= SB_RDONLY;\n\t\tNVolSetErrors(vol);\n\t}\n#endif  \n\treturn true;\n#ifdef NTFS_RW\niput_usnjrnl_err_out:\n\tiput(vol->usnjrnl_j_ino);\n\tiput(vol->usnjrnl_max_ino);\n\tiput(vol->usnjrnl_ino);\niput_quota_err_out:\n\tiput(vol->quota_q_ino);\n\tiput(vol->quota_ino);\n\tiput(vol->extend_ino);\n#endif  \niput_sec_err_out:\n\tiput(vol->secure_ino);\niput_root_err_out:\n\tiput(vol->root_ino);\niput_logfile_err_out:\n#ifdef NTFS_RW\n\tiput(vol->logfile_ino);\niput_vol_err_out:\n#endif  \n\tiput(vol->vol_ino);\niput_lcnbmp_err_out:\n\tiput(vol->lcnbmp_ino);\niput_attrdef_err_out:\n\tvol->attrdef_size = 0;\n\tif (vol->attrdef) {\n\t\tntfs_free(vol->attrdef);\n\t\tvol->attrdef = NULL;\n\t}\n#ifdef NTFS_RW\niput_upcase_err_out:\n#endif  \n\tvol->upcase_len = 0;\n\tmutex_lock(&ntfs_lock);\n\tif (vol->upcase == default_upcase) {\n\t\tntfs_nr_upcase_users--;\n\t\tvol->upcase = NULL;\n\t}\n\tmutex_unlock(&ntfs_lock);\n\tif (vol->upcase) {\n\t\tntfs_free(vol->upcase);\n\t\tvol->upcase = NULL;\n\t}\niput_mftbmp_err_out:\n\tiput(vol->mftbmp_ino);\niput_mirr_err_out:\n#ifdef NTFS_RW\n\tiput(vol->mftmirr_ino);\n#endif  \n\treturn false;\n}\n\n \nstatic void ntfs_put_super(struct super_block *sb)\n{\n\tntfs_volume *vol = NTFS_SB(sb);\n\n\tntfs_debug(\"Entering.\");\n\n#ifdef NTFS_RW\n\t \n\tntfs_commit_inode(vol->vol_ino);\n\n\t \n\tif (vol->major_ver >= 3) {\n\t\tif (vol->usnjrnl_j_ino)\n\t\t\tntfs_commit_inode(vol->usnjrnl_j_ino);\n\t\tif (vol->usnjrnl_max_ino)\n\t\t\tntfs_commit_inode(vol->usnjrnl_max_ino);\n\t\tif (vol->usnjrnl_ino)\n\t\t\tntfs_commit_inode(vol->usnjrnl_ino);\n\t\tif (vol->quota_q_ino)\n\t\t\tntfs_commit_inode(vol->quota_q_ino);\n\t\tif (vol->quota_ino)\n\t\t\tntfs_commit_inode(vol->quota_ino);\n\t\tif (vol->extend_ino)\n\t\t\tntfs_commit_inode(vol->extend_ino);\n\t\tif (vol->secure_ino)\n\t\t\tntfs_commit_inode(vol->secure_ino);\n\t}\n\n\tntfs_commit_inode(vol->root_ino);\n\n\tdown_write(&vol->lcnbmp_lock);\n\tntfs_commit_inode(vol->lcnbmp_ino);\n\tup_write(&vol->lcnbmp_lock);\n\n\tdown_write(&vol->mftbmp_lock);\n\tntfs_commit_inode(vol->mftbmp_ino);\n\tup_write(&vol->mftbmp_lock);\n\n\tif (vol->logfile_ino)\n\t\tntfs_commit_inode(vol->logfile_ino);\n\n\tif (vol->mftmirr_ino)\n\t\tntfs_commit_inode(vol->mftmirr_ino);\n\tntfs_commit_inode(vol->mft_ino);\n\n\t \n\tif (!sb_rdonly(sb)) {\n\t\tif (!NVolErrors(vol)) {\n\t\t\tif (ntfs_clear_volume_flags(vol, VOLUME_IS_DIRTY))\n\t\t\t\tntfs_warning(sb, \"Failed to clear dirty bit \"\n\t\t\t\t\t\t\"in volume information \"\n\t\t\t\t\t\t\"flags.  Run chkdsk.\");\n\t\t\tntfs_commit_inode(vol->vol_ino);\n\t\t\tntfs_commit_inode(vol->root_ino);\n\t\t\tif (vol->mftmirr_ino)\n\t\t\t\tntfs_commit_inode(vol->mftmirr_ino);\n\t\t\tntfs_commit_inode(vol->mft_ino);\n\t\t} else {\n\t\t\tntfs_warning(sb, \"Volume has errors.  Leaving volume \"\n\t\t\t\t\t\"marked dirty.  Run chkdsk.\");\n\t\t}\n\t}\n#endif  \n\n\tiput(vol->vol_ino);\n\tvol->vol_ino = NULL;\n\n\t \n\tif (vol->major_ver >= 3) {\n#ifdef NTFS_RW\n\t\tif (vol->usnjrnl_j_ino) {\n\t\t\tiput(vol->usnjrnl_j_ino);\n\t\t\tvol->usnjrnl_j_ino = NULL;\n\t\t}\n\t\tif (vol->usnjrnl_max_ino) {\n\t\t\tiput(vol->usnjrnl_max_ino);\n\t\t\tvol->usnjrnl_max_ino = NULL;\n\t\t}\n\t\tif (vol->usnjrnl_ino) {\n\t\t\tiput(vol->usnjrnl_ino);\n\t\t\tvol->usnjrnl_ino = NULL;\n\t\t}\n\t\tif (vol->quota_q_ino) {\n\t\t\tiput(vol->quota_q_ino);\n\t\t\tvol->quota_q_ino = NULL;\n\t\t}\n\t\tif (vol->quota_ino) {\n\t\t\tiput(vol->quota_ino);\n\t\t\tvol->quota_ino = NULL;\n\t\t}\n#endif  \n\t\tif (vol->extend_ino) {\n\t\t\tiput(vol->extend_ino);\n\t\t\tvol->extend_ino = NULL;\n\t\t}\n\t\tif (vol->secure_ino) {\n\t\t\tiput(vol->secure_ino);\n\t\t\tvol->secure_ino = NULL;\n\t\t}\n\t}\n\n\tiput(vol->root_ino);\n\tvol->root_ino = NULL;\n\n\tdown_write(&vol->lcnbmp_lock);\n\tiput(vol->lcnbmp_ino);\n\tvol->lcnbmp_ino = NULL;\n\tup_write(&vol->lcnbmp_lock);\n\n\tdown_write(&vol->mftbmp_lock);\n\tiput(vol->mftbmp_ino);\n\tvol->mftbmp_ino = NULL;\n\tup_write(&vol->mftbmp_lock);\n\n#ifdef NTFS_RW\n\tif (vol->logfile_ino) {\n\t\tiput(vol->logfile_ino);\n\t\tvol->logfile_ino = NULL;\n\t}\n\tif (vol->mftmirr_ino) {\n\t\t \n\t\tntfs_commit_inode(vol->mftmirr_ino);\n\t\tntfs_commit_inode(vol->mft_ino);\n\t\tiput(vol->mftmirr_ino);\n\t\tvol->mftmirr_ino = NULL;\n\t}\n\t \n\tntfs_commit_inode(vol->mft_ino);\n\twrite_inode_now(vol->mft_ino, 1);\n#endif  \n\n\tiput(vol->mft_ino);\n\tvol->mft_ino = NULL;\n\n\t \n\tvol->attrdef_size = 0;\n\tif (vol->attrdef) {\n\t\tntfs_free(vol->attrdef);\n\t\tvol->attrdef = NULL;\n\t}\n\tvol->upcase_len = 0;\n\t \n\tmutex_lock(&ntfs_lock);\n\tif (vol->upcase == default_upcase) {\n\t\tntfs_nr_upcase_users--;\n\t\tvol->upcase = NULL;\n\t}\n\tif (!ntfs_nr_upcase_users && default_upcase) {\n\t\tntfs_free(default_upcase);\n\t\tdefault_upcase = NULL;\n\t}\n\tif (vol->cluster_size <= 4096 && !--ntfs_nr_compression_users)\n\t\tfree_compression_buffers();\n\tmutex_unlock(&ntfs_lock);\n\tif (vol->upcase) {\n\t\tntfs_free(vol->upcase);\n\t\tvol->upcase = NULL;\n\t}\n\n\tunload_nls(vol->nls_map);\n\n\tsb->s_fs_info = NULL;\n\tkfree(vol);\n}\n\n \nstatic s64 get_nr_free_clusters(ntfs_volume *vol)\n{\n\ts64 nr_free = vol->nr_clusters;\n\tstruct address_space *mapping = vol->lcnbmp_ino->i_mapping;\n\tstruct page *page;\n\tpgoff_t index, max_index;\n\n\tntfs_debug(\"Entering.\");\n\t \n\tdown_read(&vol->lcnbmp_lock);\n\t \n\tmax_index = (((vol->nr_clusters + 7) >> 3) + PAGE_SIZE - 1) >>\n\t\t\tPAGE_SHIFT;\n\t \n\tntfs_debug(\"Reading $Bitmap, max_index = 0x%lx, max_size = 0x%lx.\",\n\t\t\tmax_index, PAGE_SIZE / 4);\n\tfor (index = 0; index < max_index; index++) {\n\t\tunsigned long *kaddr;\n\n\t\t \n\t\tpage = read_mapping_page(mapping, index, NULL);\n\t\t \n\t\tif (IS_ERR(page)) {\n\t\t\tntfs_debug(\"read_mapping_page() error. Skipping \"\n\t\t\t\t\t\"page (index 0x%lx).\", index);\n\t\t\tnr_free -= PAGE_SIZE * 8;\n\t\t\tcontinue;\n\t\t}\n\t\tkaddr = kmap_atomic(page);\n\t\t \n\t\tnr_free -= bitmap_weight(kaddr,\n\t\t\t\t\tPAGE_SIZE * BITS_PER_BYTE);\n\t\tkunmap_atomic(kaddr);\n\t\tput_page(page);\n\t}\n\tntfs_debug(\"Finished reading $Bitmap, last index = 0x%lx.\", index - 1);\n\t \n\tif (vol->nr_clusters & 63)\n\t\tnr_free += 64 - (vol->nr_clusters & 63);\n\tup_read(&vol->lcnbmp_lock);\n\t \n\tif (nr_free < 0)\n\t\tnr_free = 0;\n\tntfs_debug(\"Exiting.\");\n\treturn nr_free;\n}\n\n \nstatic unsigned long __get_nr_free_mft_records(ntfs_volume *vol,\n\t\ts64 nr_free, const pgoff_t max_index)\n{\n\tstruct address_space *mapping = vol->mftbmp_ino->i_mapping;\n\tstruct page *page;\n\tpgoff_t index;\n\n\tntfs_debug(\"Entering.\");\n\t \n\tntfs_debug(\"Reading $MFT/$BITMAP, max_index = 0x%lx, max_size = \"\n\t\t\t\"0x%lx.\", max_index, PAGE_SIZE / 4);\n\tfor (index = 0; index < max_index; index++) {\n\t\tunsigned long *kaddr;\n\n\t\t \n\t\tpage = read_mapping_page(mapping, index, NULL);\n\t\t \n\t\tif (IS_ERR(page)) {\n\t\t\tntfs_debug(\"read_mapping_page() error. Skipping \"\n\t\t\t\t\t\"page (index 0x%lx).\", index);\n\t\t\tnr_free -= PAGE_SIZE * 8;\n\t\t\tcontinue;\n\t\t}\n\t\tkaddr = kmap_atomic(page);\n\t\t \n\t\tnr_free -= bitmap_weight(kaddr,\n\t\t\t\t\tPAGE_SIZE * BITS_PER_BYTE);\n\t\tkunmap_atomic(kaddr);\n\t\tput_page(page);\n\t}\n\tntfs_debug(\"Finished reading $MFT/$BITMAP, last index = 0x%lx.\",\n\t\t\tindex - 1);\n\t \n\tif (nr_free < 0)\n\t\tnr_free = 0;\n\tntfs_debug(\"Exiting.\");\n\treturn nr_free;\n}\n\n \nstatic int ntfs_statfs(struct dentry *dentry, struct kstatfs *sfs)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\ts64 size;\n\tntfs_volume *vol = NTFS_SB(sb);\n\tntfs_inode *mft_ni = NTFS_I(vol->mft_ino);\n\tpgoff_t max_index;\n\tunsigned long flags;\n\n\tntfs_debug(\"Entering.\");\n\t \n\tsfs->f_type   = NTFS_SB_MAGIC;\n\t \n\tsfs->f_bsize  = PAGE_SIZE;\n\t \n\tsfs->f_blocks = vol->nr_clusters << vol->cluster_size_bits >>\n\t\t\t\tPAGE_SHIFT;\n\t \n\tsize\t      = get_nr_free_clusters(vol) << vol->cluster_size_bits >>\n\t\t\t\tPAGE_SHIFT;\n\tif (size < 0LL)\n\t\tsize = 0LL;\n\t \n\tsfs->f_bavail = sfs->f_bfree = size;\n\t \n\tdown_read(&vol->mftbmp_lock);\n\tread_lock_irqsave(&mft_ni->size_lock, flags);\n\tsize = i_size_read(vol->mft_ino) >> vol->mft_record_size_bits;\n\t \n\tmax_index = ((((mft_ni->initialized_size >> vol->mft_record_size_bits)\n\t\t\t+ 7) >> 3) + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tread_unlock_irqrestore(&mft_ni->size_lock, flags);\n\t \n\tsfs->f_files = size;\n\t \n\tsfs->f_ffree = __get_nr_free_mft_records(vol, size, max_index);\n\tup_read(&vol->mftbmp_lock);\n\t \n\tsfs->f_fsid = u64_to_fsid(vol->serial_no);\n\t \n\tsfs->f_namelen\t   = NTFS_MAX_NAME_LEN;\n\treturn 0;\n}\n\n#ifdef NTFS_RW\nstatic int ntfs_write_inode(struct inode *vi, struct writeback_control *wbc)\n{\n\treturn __ntfs_write_inode(vi, wbc->sync_mode == WB_SYNC_ALL);\n}\n#endif\n\n \nstatic const struct super_operations ntfs_sops = {\n\t.alloc_inode\t= ntfs_alloc_big_inode,\t   \n\t.free_inode\t= ntfs_free_big_inode,  \n#ifdef NTFS_RW\n\t.write_inode\t= ntfs_write_inode,\t \n#endif  \n\t.put_super\t= ntfs_put_super,\t \n\t.statfs\t\t= ntfs_statfs,\t\t \n\t.remount_fs\t= ntfs_remount,\t\t \n\t.evict_inode\t= ntfs_evict_big_inode,\t \n\t.show_options\t= ntfs_show_options,\t \n};\n\n \nstatic int ntfs_fill_super(struct super_block *sb, void *opt, const int silent)\n{\n\tntfs_volume *vol;\n\tstruct buffer_head *bh;\n\tstruct inode *tmp_ino;\n\tint blocksize, result;\n\n\t \n\tlockdep_off();\n\tntfs_debug(\"Entering.\");\n#ifndef NTFS_RW\n\tsb->s_flags |= SB_RDONLY;\n#endif  \n\t \n\tsb->s_fs_info = kmalloc(sizeof(ntfs_volume), GFP_NOFS);\n\tvol = NTFS_SB(sb);\n\tif (!vol) {\n\t\tif (!silent)\n\t\t\tntfs_error(sb, \"Allocation of NTFS volume structure \"\n\t\t\t\t\t\"failed. Aborting mount...\");\n\t\tlockdep_on();\n\t\treturn -ENOMEM;\n\t}\n\t \n\t*vol = (ntfs_volume) {\n\t\t.sb = sb,\n\t\t \n\t\t.fmask = 0177,\n\t\t.dmask = 0077,\n\t};\n\tinit_rwsem(&vol->mftbmp_lock);\n\tinit_rwsem(&vol->lcnbmp_lock);\n\n\t \n\tNVolSetSparseEnabled(vol);\n\n\t \n\tif (!parse_options(vol, (char*)opt))\n\t\tgoto err_out_now;\n\n\t \n\tif (bdev_logical_block_size(sb->s_bdev) > PAGE_SIZE) {\n\t\tif (!silent)\n\t\t\tntfs_error(sb, \"Device has unsupported sector size \"\n\t\t\t\t\t\"(%i).  The maximum supported sector \"\n\t\t\t\t\t\"size on this architecture is %lu \"\n\t\t\t\t\t\"bytes.\",\n\t\t\t\t\tbdev_logical_block_size(sb->s_bdev),\n\t\t\t\t\tPAGE_SIZE);\n\t\tgoto err_out_now;\n\t}\n\t \n\tblocksize = sb_min_blocksize(sb, NTFS_BLOCK_SIZE);\n\tif (blocksize < NTFS_BLOCK_SIZE) {\n\t\tif (!silent)\n\t\t\tntfs_error(sb, \"Unable to set device block size.\");\n\t\tgoto err_out_now;\n\t}\n\tBUG_ON(blocksize != sb->s_blocksize);\n\tntfs_debug(\"Set device block size to %i bytes (block size bits %i).\",\n\t\t\tblocksize, sb->s_blocksize_bits);\n\t \n\tvol->nr_blocks = sb_bdev_nr_blocks(sb);\n\tif (!vol->nr_blocks) {\n\t\tif (!silent)\n\t\t\tntfs_error(sb, \"Unable to determine device size.\");\n\t\tgoto err_out_now;\n\t}\n\t \n\tif (!(bh = read_ntfs_boot_sector(sb, silent))) {\n\t\tif (!silent)\n\t\t\tntfs_error(sb, \"Not an NTFS volume.\");\n\t\tgoto err_out_now;\n\t}\n\t \n\tresult = parse_ntfs_boot_sector(vol, (NTFS_BOOT_SECTOR*)bh->b_data);\n\tbrelse(bh);\n\tif (!result) {\n\t\tif (!silent)\n\t\t\tntfs_error(sb, \"Unsupported NTFS filesystem.\");\n\t\tgoto err_out_now;\n\t}\n\t \n\tif (vol->sector_size > blocksize) {\n\t\tblocksize = sb_set_blocksize(sb, vol->sector_size);\n\t\tif (blocksize != vol->sector_size) {\n\t\t\tif (!silent)\n\t\t\t\tntfs_error(sb, \"Unable to set device block \"\n\t\t\t\t\t\t\"size to sector size (%i).\",\n\t\t\t\t\t\tvol->sector_size);\n\t\t\tgoto err_out_now;\n\t\t}\n\t\tBUG_ON(blocksize != sb->s_blocksize);\n\t\tvol->nr_blocks = sb_bdev_nr_blocks(sb);\n\t\tntfs_debug(\"Changed device block size to %i bytes (block size \"\n\t\t\t\t\"bits %i) to match volume sector size.\",\n\t\t\t\tblocksize, sb->s_blocksize_bits);\n\t}\n\t \n\tntfs_setup_allocators(vol);\n\t \n\tsb->s_magic = NTFS_SB_MAGIC;\n\t \n\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\t \n\tsb->s_time_gran = 100;\n\t \n\tsb->s_op = &ntfs_sops;\n\ttmp_ino = new_inode(sb);\n\tif (!tmp_ino) {\n\t\tif (!silent)\n\t\t\tntfs_error(sb, \"Failed to load essential metadata.\");\n\t\tgoto err_out_now;\n\t}\n\ttmp_ino->i_ino = FILE_MFT;\n\tinsert_inode_hash(tmp_ino);\n\tif (ntfs_read_inode_mount(tmp_ino) < 0) {\n\t\tif (!silent)\n\t\t\tntfs_error(sb, \"Failed to load essential metadata.\");\n\t\tgoto iput_tmp_ino_err_out_now;\n\t}\n\tmutex_lock(&ntfs_lock);\n\t \n\tif (vol->cluster_size <= 4096 && !ntfs_nr_compression_users++) {\n\t\tresult = allocate_compression_buffers();\n\t\tif (result) {\n\t\t\tntfs_error(NULL, \"Failed to allocate buffers \"\n\t\t\t\t\t\"for compression engine.\");\n\t\t\tntfs_nr_compression_users--;\n\t\t\tmutex_unlock(&ntfs_lock);\n\t\t\tgoto iput_tmp_ino_err_out_now;\n\t\t}\n\t}\n\t \n\tif (!default_upcase)\n\t\tdefault_upcase = generate_default_upcase();\n\tntfs_nr_upcase_users++;\n\tmutex_unlock(&ntfs_lock);\n\t \n\t \n\tif (!load_system_files(vol)) {\n\t\tntfs_error(sb, \"Failed to load system files.\");\n\t\tgoto unl_upcase_iput_tmp_ino_err_out_now;\n\t}\n\n\t \n\tihold(vol->root_ino);\n\tif ((sb->s_root = d_make_root(vol->root_ino))) {\n\t\tntfs_debug(\"Exiting, status successful.\");\n\t\t \n\t\tmutex_lock(&ntfs_lock);\n\t\tif (!--ntfs_nr_upcase_users && default_upcase) {\n\t\t\tntfs_free(default_upcase);\n\t\t\tdefault_upcase = NULL;\n\t\t}\n\t\tmutex_unlock(&ntfs_lock);\n\t\tsb->s_export_op = &ntfs_export_ops;\n\t\tlockdep_on();\n\t\treturn 0;\n\t}\n\tntfs_error(sb, \"Failed to allocate root directory.\");\n\t \n\t\n\t\n\t\n\tiput(vol->vol_ino);\n\tvol->vol_ino = NULL;\n\t \n\tif (vol->major_ver >= 3) {\n#ifdef NTFS_RW\n\t\tif (vol->usnjrnl_j_ino) {\n\t\t\tiput(vol->usnjrnl_j_ino);\n\t\t\tvol->usnjrnl_j_ino = NULL;\n\t\t}\n\t\tif (vol->usnjrnl_max_ino) {\n\t\t\tiput(vol->usnjrnl_max_ino);\n\t\t\tvol->usnjrnl_max_ino = NULL;\n\t\t}\n\t\tif (vol->usnjrnl_ino) {\n\t\t\tiput(vol->usnjrnl_ino);\n\t\t\tvol->usnjrnl_ino = NULL;\n\t\t}\n\t\tif (vol->quota_q_ino) {\n\t\t\tiput(vol->quota_q_ino);\n\t\t\tvol->quota_q_ino = NULL;\n\t\t}\n\t\tif (vol->quota_ino) {\n\t\t\tiput(vol->quota_ino);\n\t\t\tvol->quota_ino = NULL;\n\t\t}\n#endif  \n\t\tif (vol->extend_ino) {\n\t\t\tiput(vol->extend_ino);\n\t\t\tvol->extend_ino = NULL;\n\t\t}\n\t\tif (vol->secure_ino) {\n\t\t\tiput(vol->secure_ino);\n\t\t\tvol->secure_ino = NULL;\n\t\t}\n\t}\n\tiput(vol->root_ino);\n\tvol->root_ino = NULL;\n\tiput(vol->lcnbmp_ino);\n\tvol->lcnbmp_ino = NULL;\n\tiput(vol->mftbmp_ino);\n\tvol->mftbmp_ino = NULL;\n#ifdef NTFS_RW\n\tif (vol->logfile_ino) {\n\t\tiput(vol->logfile_ino);\n\t\tvol->logfile_ino = NULL;\n\t}\n\tif (vol->mftmirr_ino) {\n\t\tiput(vol->mftmirr_ino);\n\t\tvol->mftmirr_ino = NULL;\n\t}\n#endif  \n\t \n\tvol->attrdef_size = 0;\n\tif (vol->attrdef) {\n\t\tntfs_free(vol->attrdef);\n\t\tvol->attrdef = NULL;\n\t}\n\tvol->upcase_len = 0;\n\tmutex_lock(&ntfs_lock);\n\tif (vol->upcase == default_upcase) {\n\t\tntfs_nr_upcase_users--;\n\t\tvol->upcase = NULL;\n\t}\n\tmutex_unlock(&ntfs_lock);\n\tif (vol->upcase) {\n\t\tntfs_free(vol->upcase);\n\t\tvol->upcase = NULL;\n\t}\n\tif (vol->nls_map) {\n\t\tunload_nls(vol->nls_map);\n\t\tvol->nls_map = NULL;\n\t}\n\t \nunl_upcase_iput_tmp_ino_err_out_now:\n\t \n\tmutex_lock(&ntfs_lock);\n\tif (!--ntfs_nr_upcase_users && default_upcase) {\n\t\tntfs_free(default_upcase);\n\t\tdefault_upcase = NULL;\n\t}\n\tif (vol->cluster_size <= 4096 && !--ntfs_nr_compression_users)\n\t\tfree_compression_buffers();\n\tmutex_unlock(&ntfs_lock);\niput_tmp_ino_err_out_now:\n\tiput(tmp_ino);\n\tif (vol->mft_ino && vol->mft_ino != tmp_ino)\n\t\tiput(vol->mft_ino);\n\tvol->mft_ino = NULL;\n\t \nerr_out_now:\n\tsb->s_fs_info = NULL;\n\tkfree(vol);\n\tntfs_debug(\"Failed, returning -EINVAL.\");\n\tlockdep_on();\n\treturn -EINVAL;\n}\n\n \nstruct kmem_cache *ntfs_name_cache;\n\n \nstruct kmem_cache *ntfs_inode_cache;\nstruct kmem_cache *ntfs_big_inode_cache;\n\n \nstatic void ntfs_big_inode_init_once(void *foo)\n{\n\tntfs_inode *ni = (ntfs_inode *)foo;\n\n\tinode_init_once(VFS_I(ni));\n}\n\n \nstruct kmem_cache *ntfs_attr_ctx_cache;\nstruct kmem_cache *ntfs_index_ctx_cache;\n\n \nDEFINE_MUTEX(ntfs_lock);\n\nstatic struct dentry *ntfs_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, ntfs_fill_super);\n}\n\nstatic struct file_system_type ntfs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"ntfs\",\n\t.mount\t\t= ntfs_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\nMODULE_ALIAS_FS(\"ntfs\");\n\n \nstatic const char ntfs_index_ctx_cache_name[] = \"ntfs_index_ctx_cache\";\nstatic const char ntfs_attr_ctx_cache_name[] = \"ntfs_attr_ctx_cache\";\nstatic const char ntfs_name_cache_name[] = \"ntfs_name_cache\";\nstatic const char ntfs_inode_cache_name[] = \"ntfs_inode_cache\";\nstatic const char ntfs_big_inode_cache_name[] = \"ntfs_big_inode_cache\";\n\nstatic int __init init_ntfs_fs(void)\n{\n\tint err = 0;\n\n\t \n\tpr_info(\"driver \" NTFS_VERSION \" [Flags: R/\"\n#ifdef NTFS_RW\n\t\t\t\"W\"\n#else\n\t\t\t\"O\"\n#endif\n#ifdef DEBUG\n\t\t\t\" DEBUG\"\n#endif\n#ifdef MODULE\n\t\t\t\" MODULE\"\n#endif\n\t\t\t\"].\\n\");\n\n\tntfs_debug(\"Debug messages are enabled.\");\n\n\tntfs_index_ctx_cache = kmem_cache_create(ntfs_index_ctx_cache_name,\n\t\t\tsizeof(ntfs_index_context), 0  ,\n\t\t\tSLAB_HWCACHE_ALIGN, NULL  );\n\tif (!ntfs_index_ctx_cache) {\n\t\tpr_crit(\"Failed to create %s!\\n\", ntfs_index_ctx_cache_name);\n\t\tgoto ictx_err_out;\n\t}\n\tntfs_attr_ctx_cache = kmem_cache_create(ntfs_attr_ctx_cache_name,\n\t\t\tsizeof(ntfs_attr_search_ctx), 0  ,\n\t\t\tSLAB_HWCACHE_ALIGN, NULL  );\n\tif (!ntfs_attr_ctx_cache) {\n\t\tpr_crit(\"NTFS: Failed to create %s!\\n\",\n\t\t\tntfs_attr_ctx_cache_name);\n\t\tgoto actx_err_out;\n\t}\n\n\tntfs_name_cache = kmem_cache_create(ntfs_name_cache_name,\n\t\t\t(NTFS_MAX_NAME_LEN+1) * sizeof(ntfschar), 0,\n\t\t\tSLAB_HWCACHE_ALIGN, NULL);\n\tif (!ntfs_name_cache) {\n\t\tpr_crit(\"Failed to create %s!\\n\", ntfs_name_cache_name);\n\t\tgoto name_err_out;\n\t}\n\n\tntfs_inode_cache = kmem_cache_create(ntfs_inode_cache_name,\n\t\t\tsizeof(ntfs_inode), 0,\n\t\t\tSLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD, NULL);\n\tif (!ntfs_inode_cache) {\n\t\tpr_crit(\"Failed to create %s!\\n\", ntfs_inode_cache_name);\n\t\tgoto inode_err_out;\n\t}\n\n\tntfs_big_inode_cache = kmem_cache_create(ntfs_big_inode_cache_name,\n\t\t\tsizeof(big_ntfs_inode), 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD|\n\t\t\tSLAB_ACCOUNT, ntfs_big_inode_init_once);\n\tif (!ntfs_big_inode_cache) {\n\t\tpr_crit(\"Failed to create %s!\\n\", ntfs_big_inode_cache_name);\n\t\tgoto big_inode_err_out;\n\t}\n\n\t \n\terr = ntfs_sysctl(1);\n\tif (err) {\n\t\tpr_crit(\"Failed to register NTFS sysctls!\\n\");\n\t\tgoto sysctl_err_out;\n\t}\n\n\terr = register_filesystem(&ntfs_fs_type);\n\tif (!err) {\n\t\tntfs_debug(\"NTFS driver registered successfully.\");\n\t\treturn 0;  \n\t}\n\tpr_crit(\"Failed to register NTFS filesystem driver!\\n\");\n\n\t \n\tntfs_sysctl(0);\nsysctl_err_out:\n\tkmem_cache_destroy(ntfs_big_inode_cache);\nbig_inode_err_out:\n\tkmem_cache_destroy(ntfs_inode_cache);\ninode_err_out:\n\tkmem_cache_destroy(ntfs_name_cache);\nname_err_out:\n\tkmem_cache_destroy(ntfs_attr_ctx_cache);\nactx_err_out:\n\tkmem_cache_destroy(ntfs_index_ctx_cache);\nictx_err_out:\n\tif (!err) {\n\t\tpr_crit(\"Aborting NTFS filesystem driver registration...\\n\");\n\t\terr = -ENOMEM;\n\t}\n\treturn err;\n}\n\nstatic void __exit exit_ntfs_fs(void)\n{\n\tntfs_debug(\"Unregistering NTFS driver.\");\n\n\tunregister_filesystem(&ntfs_fs_type);\n\n\t \n\trcu_barrier();\n\tkmem_cache_destroy(ntfs_big_inode_cache);\n\tkmem_cache_destroy(ntfs_inode_cache);\n\tkmem_cache_destroy(ntfs_name_cache);\n\tkmem_cache_destroy(ntfs_attr_ctx_cache);\n\tkmem_cache_destroy(ntfs_index_ctx_cache);\n\t \n\tntfs_sysctl(0);\n}\n\nMODULE_AUTHOR(\"Anton Altaparmakov <anton@tuxera.com>\");\nMODULE_DESCRIPTION(\"NTFS 1.2/3.x driver - Copyright (c) 2001-2014 Anton Altaparmakov and Tuxera Inc.\");\nMODULE_VERSION(NTFS_VERSION);\nMODULE_LICENSE(\"GPL\");\n#ifdef DEBUG\nmodule_param(debug_msgs, bint, 0);\nMODULE_PARM_DESC(debug_msgs, \"Enable debug messages.\");\n#endif\n\nmodule_init(init_ntfs_fs)\nmodule_exit(exit_ntfs_fs)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}