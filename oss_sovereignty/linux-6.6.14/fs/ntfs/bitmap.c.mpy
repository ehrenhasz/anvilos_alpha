{
  "module_name": "bitmap.c",
  "hash_id": "1ef357e74e3c2fcddd5e88ccd090373f24759026f90fbb90969710b383c3e3ba",
  "original_prompt": "Ingested from linux-6.6.14/fs/ntfs/bitmap.c",
  "human_readable_source": "\n \n\n#ifdef NTFS_RW\n\n#include <linux/pagemap.h>\n\n#include \"bitmap.h\"\n#include \"debug.h\"\n#include \"aops.h\"\n#include \"ntfs.h\"\n\n \nint __ntfs_bitmap_set_bits_in_run(struct inode *vi, const s64 start_bit,\n\t\tconst s64 count, const u8 value, const bool is_rollback)\n{\n\ts64 cnt = count;\n\tpgoff_t index, end_index;\n\tstruct address_space *mapping;\n\tstruct page *page;\n\tu8 *kaddr;\n\tint pos, len;\n\tu8 bit;\n\n\tBUG_ON(!vi);\n\tntfs_debug(\"Entering for i_ino 0x%lx, start_bit 0x%llx, count 0x%llx, \"\n\t\t\t\"value %u.%s\", vi->i_ino, (unsigned long long)start_bit,\n\t\t\t(unsigned long long)cnt, (unsigned int)value,\n\t\t\tis_rollback ? \" (rollback)\" : \"\");\n\tBUG_ON(start_bit < 0);\n\tBUG_ON(cnt < 0);\n\tBUG_ON(value > 1);\n\t \n\tindex = start_bit >> (3 + PAGE_SHIFT);\n\tend_index = (start_bit + cnt - 1) >> (3 + PAGE_SHIFT);\n\n\t \n\tmapping = vi->i_mapping;\n\tpage = ntfs_map_page(mapping, index);\n\tif (IS_ERR(page)) {\n\t\tif (!is_rollback)\n\t\t\tntfs_error(vi->i_sb, \"Failed to map first page (error \"\n\t\t\t\t\t\"%li), aborting.\", PTR_ERR(page));\n\t\treturn PTR_ERR(page);\n\t}\n\tkaddr = page_address(page);\n\n\t \n\tpos = (start_bit >> 3) & ~PAGE_MASK;\n\n\t \n\tbit = start_bit & 7;\n\n\t \n\tif (bit) {\n\t\tu8 *byte = kaddr + pos;\n\t\twhile ((bit & 7) && cnt) {\n\t\t\tcnt--;\n\t\t\tif (value)\n\t\t\t\t*byte |= 1 << bit++;\n\t\t\telse\n\t\t\t\t*byte &= ~(1 << bit++);\n\t\t}\n\t\t \n\t\tif (!cnt)\n\t\t\tgoto done;\n\n\t\t \n\t\tpos++;\n\t}\n\t \n\tlen = min_t(s64, cnt >> 3, PAGE_SIZE - pos);\n\tmemset(kaddr + pos, value ? 0xff : 0, len);\n\tcnt -= len << 3;\n\n\t \n\tif (cnt < 8)\n\t\tlen += pos;\n\n\t \n\twhile (index < end_index) {\n\t\tBUG_ON(cnt <= 0);\n\n\t\t \n\t\tflush_dcache_page(page);\n\t\tset_page_dirty(page);\n\t\tntfs_unmap_page(page);\n\t\tpage = ntfs_map_page(mapping, ++index);\n\t\tif (IS_ERR(page))\n\t\t\tgoto rollback;\n\t\tkaddr = page_address(page);\n\t\t \n\t\tlen = min_t(s64, cnt >> 3, PAGE_SIZE);\n\t\tmemset(kaddr, value ? 0xff : 0, len);\n\t\tcnt -= len << 3;\n\t}\n\t \n\tif (cnt) {\n\t\tu8 *byte;\n\n\t\tBUG_ON(cnt > 7);\n\n\t\tbit = cnt;\n\t\tbyte = kaddr + len;\n\t\twhile (bit--) {\n\t\t\tif (value)\n\t\t\t\t*byte |= 1 << bit;\n\t\t\telse\n\t\t\t\t*byte &= ~(1 << bit);\n\t\t}\n\t}\ndone:\n\t \n\tflush_dcache_page(page);\n\tset_page_dirty(page);\n\tntfs_unmap_page(page);\n\tntfs_debug(\"Done.\");\n\treturn 0;\nrollback:\n\t \n\tif (is_rollback)\n\t\treturn PTR_ERR(page);\n\tif (count != cnt)\n\t\tpos = __ntfs_bitmap_set_bits_in_run(vi, start_bit, count - cnt,\n\t\t\t\tvalue ? 0 : 1, true);\n\telse\n\t\tpos = 0;\n\tif (!pos) {\n\t\t \n\t\tntfs_error(vi->i_sb, \"Failed to map subsequent page (error \"\n\t\t\t\t\"%li), aborting.\", PTR_ERR(page));\n\t} else {\n\t\t \n\t\tntfs_error(vi->i_sb, \"Failed to map subsequent page (error \"\n\t\t\t\t\"%li) and rollback failed (error %i).  \"\n\t\t\t\t\"Aborting and leaving inconsistent metadata.  \"\n\t\t\t\t\"Unmount and run chkdsk.\", PTR_ERR(page), pos);\n\t\tNVolSetErrors(NTFS_SB(vi->i_sb));\n\t}\n\treturn PTR_ERR(page);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}