{
  "module_name": "unistr.c",
  "hash_id": "5973cd111b72e3b01167029cdd2299347b208d2b7257899628f7a06882d3b167",
  "original_prompt": "Ingested from linux-6.6.14/fs/ntfs/unistr.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n\n#include \"types.h\"\n#include \"debug.h\"\n#include \"ntfs.h\"\n\n \n\n \nstatic const u8 legal_ansi_char_array[0x40] = {\n\t0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,\n\t0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,\n\n\t0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,\n\t0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,\n\n\t0x17, 0x07, 0x18, 0x17, 0x17, 0x17, 0x17, 0x17,\n\t0x17, 0x17, 0x18, 0x16, 0x16, 0x17, 0x07, 0x00,\n\n\t0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17,\n\t0x17, 0x17, 0x04, 0x16, 0x18, 0x16, 0x18, 0x18,\n};\n\n \nbool ntfs_are_names_equal(const ntfschar *s1, size_t s1_len,\n\t\tconst ntfschar *s2, size_t s2_len, const IGNORE_CASE_BOOL ic,\n\t\tconst ntfschar *upcase, const u32 upcase_size)\n{\n\tif (s1_len != s2_len)\n\t\treturn false;\n\tif (ic == CASE_SENSITIVE)\n\t\treturn !ntfs_ucsncmp(s1, s2, s1_len);\n\treturn !ntfs_ucsncasecmp(s1, s2, s1_len, upcase, upcase_size);\n}\n\n \nint ntfs_collate_names(const ntfschar *name1, const u32 name1_len,\n\t\tconst ntfschar *name2, const u32 name2_len,\n\t\tconst int err_val, const IGNORE_CASE_BOOL ic,\n\t\tconst ntfschar *upcase, const u32 upcase_len)\n{\n\tu32 cnt, min_len;\n\tu16 c1, c2;\n\n\tmin_len = name1_len;\n\tif (name1_len > name2_len)\n\t\tmin_len = name2_len;\n\tfor (cnt = 0; cnt < min_len; ++cnt) {\n\t\tc1 = le16_to_cpu(*name1++);\n\t\tc2 = le16_to_cpu(*name2++);\n\t\tif (ic) {\n\t\t\tif (c1 < upcase_len)\n\t\t\t\tc1 = le16_to_cpu(upcase[c1]);\n\t\t\tif (c2 < upcase_len)\n\t\t\t\tc2 = le16_to_cpu(upcase[c2]);\n\t\t}\n\t\tif (c1 < 64 && legal_ansi_char_array[c1] & 8)\n\t\t\treturn err_val;\n\t\tif (c1 < c2)\n\t\t\treturn -1;\n\t\tif (c1 > c2)\n\t\t\treturn 1;\n\t}\n\tif (name1_len < name2_len)\n\t\treturn -1;\n\tif (name1_len == name2_len)\n\t\treturn 0;\n\t \n\tc1 = le16_to_cpu(*name1);\n\tif (c1 < 64 && legal_ansi_char_array[c1] & 8)\n\t\treturn err_val;\n\treturn 1;\n}\n\n \nint ntfs_ucsncmp(const ntfschar *s1, const ntfschar *s2, size_t n)\n{\n\tu16 c1, c2;\n\tsize_t i;\n\n\tfor (i = 0; i < n; ++i) {\n\t\tc1 = le16_to_cpu(s1[i]);\n\t\tc2 = le16_to_cpu(s2[i]);\n\t\tif (c1 < c2)\n\t\t\treturn -1;\n\t\tif (c1 > c2)\n\t\t\treturn 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}\n\n \nint ntfs_ucsncasecmp(const ntfschar *s1, const ntfschar *s2, size_t n,\n\t\tconst ntfschar *upcase, const u32 upcase_size)\n{\n\tsize_t i;\n\tu16 c1, c2;\n\n\tfor (i = 0; i < n; ++i) {\n\t\tif ((c1 = le16_to_cpu(s1[i])) < upcase_size)\n\t\t\tc1 = le16_to_cpu(upcase[c1]);\n\t\tif ((c2 = le16_to_cpu(s2[i])) < upcase_size)\n\t\t\tc2 = le16_to_cpu(upcase[c2]);\n\t\tif (c1 < c2)\n\t\t\treturn -1;\n\t\tif (c1 > c2)\n\t\t\treturn 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}\n\nvoid ntfs_upcase_name(ntfschar *name, u32 name_len, const ntfschar *upcase,\n\t\tconst u32 upcase_len)\n{\n\tu32 i;\n\tu16 u;\n\n\tfor (i = 0; i < name_len; i++)\n\t\tif ((u = le16_to_cpu(name[i])) < upcase_len)\n\t\t\tname[i] = upcase[u];\n}\n\nvoid ntfs_file_upcase_value(FILE_NAME_ATTR *file_name_attr,\n\t\tconst ntfschar *upcase, const u32 upcase_len)\n{\n\tntfs_upcase_name((ntfschar*)&file_name_attr->file_name,\n\t\t\tfile_name_attr->file_name_length, upcase, upcase_len);\n}\n\nint ntfs_file_compare_values(FILE_NAME_ATTR *file_name_attr1,\n\t\tFILE_NAME_ATTR *file_name_attr2,\n\t\tconst int err_val, const IGNORE_CASE_BOOL ic,\n\t\tconst ntfschar *upcase, const u32 upcase_len)\n{\n\treturn ntfs_collate_names((ntfschar*)&file_name_attr1->file_name,\n\t\t\tfile_name_attr1->file_name_length,\n\t\t\t(ntfschar*)&file_name_attr2->file_name,\n\t\t\tfile_name_attr2->file_name_length,\n\t\t\terr_val, ic, upcase, upcase_len);\n}\n\n \nint ntfs_nlstoucs(const ntfs_volume *vol, const char *ins,\n\t\tconst int ins_len, ntfschar **outs)\n{\n\tstruct nls_table *nls = vol->nls_map;\n\tntfschar *ucs;\n\twchar_t wc;\n\tint i, o, wc_len;\n\n\t \n\tif (likely(ins)) {\n\t\tucs = kmem_cache_alloc(ntfs_name_cache, GFP_NOFS);\n\t\tif (likely(ucs)) {\n\t\t\tfor (i = o = 0; i < ins_len; i += wc_len) {\n\t\t\t\twc_len = nls->char2uni(ins + i, ins_len - i,\n\t\t\t\t\t\t&wc);\n\t\t\t\tif (likely(wc_len >= 0 &&\n\t\t\t\t\t\to < NTFS_MAX_NAME_LEN)) {\n\t\t\t\t\tif (likely(wc)) {\n\t\t\t\t\t\tucs[o++] = cpu_to_le16(wc);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}  \n\t\t\t\t\tbreak;\n\t\t\t\t}  \n\t\t\t\tgoto name_err;\n\t\t\t}\n\t\t\tucs[o] = 0;\n\t\t\t*outs = ucs;\n\t\t\treturn o;\n\t\t}  \n\t\tntfs_error(vol->sb, \"Failed to allocate buffer for converted \"\n\t\t\t\t\"name from ntfs_name_cache.\");\n\t\treturn -ENOMEM;\n\t}  \n\tntfs_error(vol->sb, \"Received NULL pointer.\");\n\treturn -EINVAL;\nname_err:\n\tkmem_cache_free(ntfs_name_cache, ucs);\n\tif (wc_len < 0) {\n\t\tntfs_error(vol->sb, \"Name using character set %s contains \"\n\t\t\t\t\"characters that cannot be converted to \"\n\t\t\t\t\"Unicode.\", nls->charset);\n\t\ti = -EILSEQ;\n\t} else   {\n\t\tntfs_error(vol->sb, \"Name is too long (maximum length for a \"\n\t\t\t\t\"name on NTFS is %d Unicode characters.\",\n\t\t\t\tNTFS_MAX_NAME_LEN);\n\t\ti = -ENAMETOOLONG;\n\t}\n\treturn i;\n}\n\n \nint ntfs_ucstonls(const ntfs_volume *vol, const ntfschar *ins,\n\t\tconst int ins_len, unsigned char **outs, int outs_len)\n{\n\tstruct nls_table *nls = vol->nls_map;\n\tunsigned char *ns;\n\tint i, o, ns_len, wc;\n\n\t \n\tif (ins) {\n\t\tns = *outs;\n\t\tns_len = outs_len;\n\t\tif (ns && !ns_len) {\n\t\t\twc = -ENAMETOOLONG;\n\t\t\tgoto conversion_err;\n\t\t}\n\t\tif (!ns) {\n\t\t\tns_len = ins_len * NLS_MAX_CHARSET_SIZE;\n\t\t\tns = kmalloc(ns_len + 1, GFP_NOFS);\n\t\t\tif (!ns)\n\t\t\t\tgoto mem_err_out;\n\t\t}\n\t\tfor (i = o = 0; i < ins_len; i++) {\nretry:\t\t\twc = nls->uni2char(le16_to_cpu(ins[i]), ns + o,\n\t\t\t\t\tns_len - o);\n\t\t\tif (wc > 0) {\n\t\t\t\to += wc;\n\t\t\t\tcontinue;\n\t\t\t} else if (!wc)\n\t\t\t\tbreak;\n\t\t\telse if (wc == -ENAMETOOLONG && ns != *outs) {\n\t\t\t\tunsigned char *tc;\n\t\t\t\t \n\t\t\t\ttc = kmalloc((ns_len + 64) &\n\t\t\t\t\t\t~63, GFP_NOFS);\n\t\t\t\tif (tc) {\n\t\t\t\t\tmemcpy(tc, ns, ns_len);\n\t\t\t\t\tns_len = ((ns_len + 64) & ~63) - 1;\n\t\t\t\t\tkfree(ns);\n\t\t\t\t\tns = tc;\n\t\t\t\t\tgoto retry;\n\t\t\t\t}  \n\t\t\t}  \n\t\t\tgoto conversion_err;\n\t\t}\n\t\tns[o] = 0;\n\t\t*outs = ns;\n\t\treturn o;\n\t}  \n\tntfs_error(vol->sb, \"Received NULL pointer.\");\n\treturn -EINVAL;\nconversion_err:\n\tntfs_error(vol->sb, \"Unicode name contains characters that cannot be \"\n\t\t\t\"converted to character set %s.  You might want to \"\n\t\t\t\"try to use the mount option nls=utf8.\", nls->charset);\n\tif (ns != *outs)\n\t\tkfree(ns);\n\tif (wc != -ENAMETOOLONG)\n\t\twc = -EILSEQ;\n\treturn wc;\nmem_err_out:\n\tntfs_error(vol->sb, \"Failed to allocate name!\");\n\treturn -ENOMEM;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}