{
  "module_name": "attrib.c",
  "hash_id": "4b5efd311812f57369d74e5adf51faab6c4cf3562e147c76ab7d91d434a53b38",
  "original_prompt": "Ingested from linux-6.6.14/fs/ntfs/attrib.c",
  "human_readable_source": "\n \n\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n\n#include \"attrib.h\"\n#include \"debug.h\"\n#include \"layout.h\"\n#include \"lcnalloc.h\"\n#include \"malloc.h\"\n#include \"mft.h\"\n#include \"ntfs.h\"\n#include \"types.h\"\n\n \nint ntfs_map_runlist_nolock(ntfs_inode *ni, VCN vcn, ntfs_attr_search_ctx *ctx)\n{\n\tVCN end_vcn;\n\tunsigned long flags;\n\tntfs_inode *base_ni;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\trunlist_element *rl;\n\tstruct page *put_this_page = NULL;\n\tint err = 0;\n\tbool ctx_is_temporary, ctx_needs_reset;\n\tntfs_attr_search_ctx old_ctx = { NULL, };\n\n\tntfs_debug(\"Mapping runlist part containing vcn 0x%llx.\",\n\t\t\t(unsigned long long)vcn);\n\tif (!NInoAttr(ni))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tif (!ctx) {\n\t\tctx_is_temporary = ctx_needs_reset = true;\n\t\tm = map_mft_record(base_ni);\n\t\tif (IS_ERR(m))\n\t\t\treturn PTR_ERR(m);\n\t\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\t\tif (unlikely(!ctx)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_out;\n\t\t}\n\t} else {\n\t\tVCN allocated_size_vcn;\n\n\t\tBUG_ON(IS_ERR(ctx->mrec));\n\t\ta = ctx->attr;\n\t\tBUG_ON(!a->non_resident);\n\t\tctx_is_temporary = false;\n\t\tend_vcn = sle64_to_cpu(a->data.non_resident.highest_vcn);\n\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\tallocated_size_vcn = ni->allocated_size >>\n\t\t\t\tni->vol->cluster_size_bits;\n\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\tif (!a->data.non_resident.lowest_vcn && end_vcn <= 0)\n\t\t\tend_vcn = allocated_size_vcn - 1;\n\t\t \n\t\tif (vcn >= allocated_size_vcn || (a->type == ni->type &&\n\t\t\t\ta->name_length == ni->name_len &&\n\t\t\t\t!memcmp((u8*)a + le16_to_cpu(a->name_offset),\n\t\t\t\tni->name, ni->name_len) &&\n\t\t\t\tsle64_to_cpu(a->data.non_resident.lowest_vcn)\n\t\t\t\t<= vcn && end_vcn >= vcn))\n\t\t\tctx_needs_reset = false;\n\t\telse {\n\t\t\t \n\t\t\told_ctx = *ctx;\n\t\t\t \n\t\t\tif (old_ctx.base_ntfs_ino && old_ctx.ntfs_ino !=\n\t\t\t\t\told_ctx.base_ntfs_ino) {\n\t\t\t\tput_this_page = old_ctx.ntfs_ino->page;\n\t\t\t\tget_page(put_this_page);\n\t\t\t}\n\t\t\t \n\t\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\t\tctx_needs_reset = true;\n\t\t}\n\t}\n\tif (ctx_needs_reset) {\n\t\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\t\tCASE_SENSITIVE, vcn, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\terr = -EIO;\n\t\t\tgoto err_out;\n\t\t}\n\t\tBUG_ON(!ctx->attr->non_resident);\n\t}\n\ta = ctx->attr;\n\t \n\tend_vcn = sle64_to_cpu(a->data.non_resident.highest_vcn) + 1;\n\tif (unlikely(vcn && vcn >= end_vcn)) {\n\t\terr = -ENOENT;\n\t\tgoto err_out;\n\t}\n\trl = ntfs_mapping_pairs_decompress(ni->vol, a, ni->runlist.rl);\n\tif (IS_ERR(rl))\n\t\terr = PTR_ERR(rl);\n\telse\n\t\tni->runlist.rl = rl;\nerr_out:\n\tif (ctx_is_temporary) {\n\t\tif (likely(ctx))\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(base_ni);\n\t} else if (ctx_needs_reset) {\n\t\t \n\t\tif (NInoAttrList(base_ni)) {\n\t\t\t \n\t\t\tif (ctx->ntfs_ino != old_ctx.ntfs_ino) {\n\t\t\t\t \n\t\t\t\tif (ctx->base_ntfs_ino && ctx->ntfs_ino !=\n\t\t\t\t\t\tctx->base_ntfs_ino) {\n\t\t\t\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\t\t\t\t\tctx->mrec = ctx->base_mrec;\n\t\t\t\t\tBUG_ON(!ctx->mrec);\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tif (old_ctx.base_ntfs_ino &&\n\t\t\t\t\t\told_ctx.ntfs_ino !=\n\t\t\t\t\t\told_ctx.base_ntfs_ino) {\nretry_map:\n\t\t\t\t\tctx->mrec = map_mft_record(\n\t\t\t\t\t\t\told_ctx.ntfs_ino);\n\t\t\t\t\t \n\t\t\t\t\tif (IS_ERR(ctx->mrec)) {\n\t\t\t\t\t\tif (PTR_ERR(ctx->mrec) ==\n\t\t\t\t\t\t\t\t-ENOMEM) {\n\t\t\t\t\t\t\tschedule();\n\t\t\t\t\t\t\tgoto retry_map;\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\told_ctx.ntfs_ino =\n\t\t\t\t\t\t\t\told_ctx.\n\t\t\t\t\t\t\t\tbase_ntfs_ino;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t \n\t\t\tif (ctx->mrec != old_ctx.mrec) {\n\t\t\t\tif (!IS_ERR(ctx->mrec))\n\t\t\t\t\told_ctx.attr = (ATTR_RECORD*)(\n\t\t\t\t\t\t\t(u8*)ctx->mrec +\n\t\t\t\t\t\t\t((u8*)old_ctx.attr -\n\t\t\t\t\t\t\t(u8*)old_ctx.mrec));\n\t\t\t\told_ctx.mrec = ctx->mrec;\n\t\t\t}\n\t\t}\n\t\t \n\t\t*ctx = old_ctx;\n\t\t \n\t\tif (put_this_page)\n\t\t\tput_page(put_this_page);\n\t}\n\treturn err;\n}\n\n \nint ntfs_map_runlist(ntfs_inode *ni, VCN vcn)\n{\n\tint err = 0;\n\n\tdown_write(&ni->runlist.lock);\n\t \n\tif (likely(ntfs_rl_vcn_to_lcn(ni->runlist.rl, vcn) <=\n\t\t\tLCN_RL_NOT_MAPPED))\n\t\terr = ntfs_map_runlist_nolock(ni, vcn, NULL);\n\tup_write(&ni->runlist.lock);\n\treturn err;\n}\n\n \nLCN ntfs_attr_vcn_to_lcn_nolock(ntfs_inode *ni, const VCN vcn,\n\t\tconst bool write_locked)\n{\n\tLCN lcn;\n\tunsigned long flags;\n\tbool is_retry = false;\n\n\tBUG_ON(!ni);\n\tntfs_debug(\"Entering for i_ino 0x%lx, vcn 0x%llx, %s_locked.\",\n\t\t\tni->mft_no, (unsigned long long)vcn,\n\t\t\twrite_locked ? \"write\" : \"read\");\n\tBUG_ON(!NInoNonResident(ni));\n\tBUG_ON(vcn < 0);\n\tif (!ni->runlist.rl) {\n\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\tif (!ni->allocated_size) {\n\t\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\t\treturn LCN_ENOENT;\n\t\t}\n\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t}\nretry_remap:\n\t \n\tlcn = ntfs_rl_vcn_to_lcn(ni->runlist.rl, vcn);\n\tif (likely(lcn >= LCN_HOLE)) {\n\t\tntfs_debug(\"Done, lcn 0x%llx.\", (long long)lcn);\n\t\treturn lcn;\n\t}\n\tif (lcn != LCN_RL_NOT_MAPPED) {\n\t\tif (lcn != LCN_ENOENT)\n\t\t\tlcn = LCN_EIO;\n\t} else if (!is_retry) {\n\t\tint err;\n\n\t\tif (!write_locked) {\n\t\t\tup_read(&ni->runlist.lock);\n\t\t\tdown_write(&ni->runlist.lock);\n\t\t\tif (unlikely(ntfs_rl_vcn_to_lcn(ni->runlist.rl, vcn) !=\n\t\t\t\t\tLCN_RL_NOT_MAPPED)) {\n\t\t\t\tup_write(&ni->runlist.lock);\n\t\t\t\tdown_read(&ni->runlist.lock);\n\t\t\t\tgoto retry_remap;\n\t\t\t}\n\t\t}\n\t\terr = ntfs_map_runlist_nolock(ni, vcn, NULL);\n\t\tif (!write_locked) {\n\t\t\tup_write(&ni->runlist.lock);\n\t\t\tdown_read(&ni->runlist.lock);\n\t\t}\n\t\tif (likely(!err)) {\n\t\t\tis_retry = true;\n\t\t\tgoto retry_remap;\n\t\t}\n\t\tif (err == -ENOENT)\n\t\t\tlcn = LCN_ENOENT;\n\t\telse if (err == -ENOMEM)\n\t\t\tlcn = LCN_ENOMEM;\n\t\telse\n\t\t\tlcn = LCN_EIO;\n\t}\n\tif (lcn != LCN_ENOENT)\n\t\tntfs_error(ni->vol->sb, \"Failed with error code %lli.\",\n\t\t\t\t(long long)lcn);\n\treturn lcn;\n}\n\n \nrunlist_element *ntfs_attr_find_vcn_nolock(ntfs_inode *ni, const VCN vcn,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tunsigned long flags;\n\trunlist_element *rl;\n\tint err = 0;\n\tbool is_retry = false;\n\n\tBUG_ON(!ni);\n\tntfs_debug(\"Entering for i_ino 0x%lx, vcn 0x%llx, with%s ctx.\",\n\t\t\tni->mft_no, (unsigned long long)vcn, ctx ? \"\" : \"out\");\n\tBUG_ON(!NInoNonResident(ni));\n\tBUG_ON(vcn < 0);\n\tif (!ni->runlist.rl) {\n\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\tif (!ni->allocated_size) {\n\t\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\t\treturn ERR_PTR(-ENOENT);\n\t\t}\n\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t}\nretry_remap:\n\trl = ni->runlist.rl;\n\tif (likely(rl && vcn >= rl[0].vcn)) {\n\t\twhile (likely(rl->length)) {\n\t\t\tif (unlikely(vcn < rl[1].vcn)) {\n\t\t\t\tif (likely(rl->lcn >= LCN_HOLE)) {\n\t\t\t\t\tntfs_debug(\"Done.\");\n\t\t\t\t\treturn rl;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trl++;\n\t\t}\n\t\tif (likely(rl->lcn != LCN_RL_NOT_MAPPED)) {\n\t\t\tif (likely(rl->lcn == LCN_ENOENT))\n\t\t\t\terr = -ENOENT;\n\t\t\telse\n\t\t\t\terr = -EIO;\n\t\t}\n\t}\n\tif (!err && !is_retry) {\n\t\t \n\t\tif (IS_ERR(ctx->mrec))\n\t\t\terr = PTR_ERR(ctx->mrec);\n\t\telse {\n\t\t\t \n\t\t\terr = ntfs_map_runlist_nolock(ni, vcn, ctx);\n\t\t\tif (likely(!err)) {\n\t\t\t\tis_retry = true;\n\t\t\t\tgoto retry_remap;\n\t\t\t}\n\t\t}\n\t\tif (err == -EINVAL)\n\t\t\terr = -EIO;\n\t} else if (!err)\n\t\terr = -EIO;\n\tif (err != -ENOENT)\n\t\tntfs_error(ni->vol->sb, \"Failed with error code %i.\", err);\n\treturn ERR_PTR(err);\n}\n\n \nstatic int ntfs_attr_find(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst u8 *val, const u32 val_len, ntfs_attr_search_ctx *ctx)\n{\n\tATTR_RECORD *a;\n\tntfs_volume *vol = ctx->ntfs_ino->vol;\n\tntfschar *upcase = vol->upcase;\n\tu32 upcase_len = vol->upcase_len;\n\n\t \n\tif (ctx->is_first) {\n\t\ta = ctx->attr;\n\t\tctx->is_first = false;\n\t} else\n\t\ta = (ATTR_RECORD*)((u8*)ctx->attr +\n\t\t\t\tle32_to_cpu(ctx->attr->length));\n\tfor (;;\ta = (ATTR_RECORD*)((u8*)a + le32_to_cpu(a->length))) {\n\t\tu8 *mrec_end = (u8 *)ctx->mrec +\n\t\t               le32_to_cpu(ctx->mrec->bytes_allocated);\n\t\tu8 *name_end;\n\n\t\t \n\t\tif ((u8 *)a < (u8 *)ctx->mrec)\n\t\t\tbreak;\n\n\t\t \n\t\tif ((u8 *)a > mrec_end ||\n\t\t    (u8 *)a + sizeof(ATTR_RECORD) > mrec_end)\n\t\t\tbreak;\n\n\t\t \n\t\tname_end = (u8 *)a + le16_to_cpu(a->name_offset) +\n\t\t\t   a->name_length * sizeof(ntfschar);\n\t\tif (name_end > mrec_end)\n\t\t\tbreak;\n\n\t\tctx->attr = a;\n\t\tif (unlikely(le32_to_cpu(a->type) > le32_to_cpu(type) ||\n\t\t\t\ta->type == AT_END))\n\t\t\treturn -ENOENT;\n\t\tif (unlikely(!a->length))\n\t\t\tbreak;\n\n\t\t \n\t\tif ((u8 *)a + le32_to_cpu(a->length) < (u8 *)a)\n\t\t\tbreak;\n\t\t \n\t\tif ((u8 *)a + le32_to_cpu(a->length) > mrec_end)\n\t\t\tbreak;\n\n\t\tif (a->type != type)\n\t\t\tcontinue;\n\t\t \n\t\tif (!name) {\n\t\t\t \n\t\t\tif (a->name_length)\n\t\t\t\treturn -ENOENT;\n\t\t} else if (!ntfs_are_names_equal(name, name_len,\n\t\t\t    (ntfschar*)((u8*)a + le16_to_cpu(a->name_offset)),\n\t\t\t    a->name_length, ic, upcase, upcase_len)) {\n\t\t\tregister int rc;\n\n\t\t\trc = ntfs_collate_names(name, name_len,\n\t\t\t\t\t(ntfschar*)((u8*)a +\n\t\t\t\t\tle16_to_cpu(a->name_offset)),\n\t\t\t\t\ta->name_length, 1, IGNORE_CASE,\n\t\t\t\t\tupcase, upcase_len);\n\t\t\t \n\t\t\tif (rc == -1)\n\t\t\t\treturn -ENOENT;\n\t\t\t \n\t\t\tif (rc)\n\t\t\t\tcontinue;\n\t\t\trc = ntfs_collate_names(name, name_len,\n\t\t\t\t\t(ntfschar*)((u8*)a +\n\t\t\t\t\tle16_to_cpu(a->name_offset)),\n\t\t\t\t\ta->name_length, 1, CASE_SENSITIVE,\n\t\t\t\t\tupcase, upcase_len);\n\t\t\tif (rc == -1)\n\t\t\t\treturn -ENOENT;\n\t\t\tif (rc)\n\t\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (!val)\n\t\t\treturn 0;\n\t\t \n\t\telse {\n\t\t\tregister int rc;\n\n\t\t\trc = memcmp(val, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tmin_t(u32, val_len, le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length)));\n\t\t\t \n\t\t\tif (!rc) {\n\t\t\t\tregister u32 avl;\n\n\t\t\t\tavl = le32_to_cpu(\n\t\t\t\t\t\ta->data.resident.value_length);\n\t\t\t\tif (val_len == avl)\n\t\t\t\t\treturn 0;\n\t\t\t\tif (val_len < avl)\n\t\t\t\t\treturn -ENOENT;\n\t\t\t} else if (rc < 0)\n\t\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\tntfs_error(vol->sb, \"Inode is corrupt.  Run chkdsk.\");\n\tNVolSetErrors(vol);\n\treturn -EIO;\n}\n\n \nint load_attribute_list(ntfs_volume *vol, runlist *runlist, u8 *al_start,\n\t\tconst s64 size, const s64 initialized_size)\n{\n\tLCN lcn;\n\tu8 *al = al_start;\n\tu8 *al_end = al + initialized_size;\n\trunlist_element *rl;\n\tstruct buffer_head *bh;\n\tstruct super_block *sb;\n\tunsigned long block_size;\n\tunsigned long block, max_block;\n\tint err = 0;\n\tunsigned char block_size_bits;\n\n\tntfs_debug(\"Entering.\");\n\tif (!vol || !runlist || !al || size <= 0 || initialized_size < 0 ||\n\t\t\tinitialized_size > size)\n\t\treturn -EINVAL;\n\tif (!initialized_size) {\n\t\tmemset(al, 0, size);\n\t\treturn 0;\n\t}\n\tsb = vol->sb;\n\tblock_size = sb->s_blocksize;\n\tblock_size_bits = sb->s_blocksize_bits;\n\tdown_read(&runlist->lock);\n\trl = runlist->rl;\n\tif (!rl) {\n\t\tntfs_error(sb, \"Cannot read attribute list since runlist is \"\n\t\t\t\t\"missing.\");\n\t\tgoto err_out;\t\n\t}\n\t \n\twhile (rl->length) {\n\t\tlcn = ntfs_rl_vcn_to_lcn(rl, rl->vcn);\n\t\tntfs_debug(\"Reading vcn = 0x%llx, lcn = 0x%llx.\",\n\t\t\t\t(unsigned long long)rl->vcn,\n\t\t\t\t(unsigned long long)lcn);\n\t\t \n\t\tif (lcn < 0) {\n\t\t\tntfs_error(sb, \"ntfs_rl_vcn_to_lcn() failed.  Cannot \"\n\t\t\t\t\t\"read attribute list.\");\n\t\t\tgoto err_out;\n\t\t}\n\t\tblock = lcn << vol->cluster_size_bits >> block_size_bits;\n\t\t \n\t\tmax_block = block + (rl->length << vol->cluster_size_bits >>\n\t\t\t\tblock_size_bits);\n\t\tntfs_debug(\"max_block = 0x%lx.\", max_block);\n\t\tdo {\n\t\t\tntfs_debug(\"Reading block = 0x%lx.\", block);\n\t\t\tbh = sb_bread(sb, block);\n\t\t\tif (!bh) {\n\t\t\t\tntfs_error(sb, \"sb_bread() failed. Cannot \"\n\t\t\t\t\t\t\"read attribute list.\");\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\tif (al + block_size >= al_end)\n\t\t\t\tgoto do_final;\n\t\t\tmemcpy(al, bh->b_data, block_size);\n\t\t\tbrelse(bh);\n\t\t\tal += block_size;\n\t\t} while (++block < max_block);\n\t\trl++;\n\t}\n\tif (initialized_size < size) {\ninitialize:\n\t\tmemset(al_start + initialized_size, 0, size - initialized_size);\n\t}\ndone:\n\tup_read(&runlist->lock);\n\treturn err;\ndo_final:\n\tif (al < al_end) {\n\t\t \n\t\tmemcpy(al, bh->b_data, al_end - al);\n\t\tbrelse(bh);\n\t\tif (initialized_size < size)\n\t\t\tgoto initialize;\n\t\tgoto done;\n\t}\n\tbrelse(bh);\n\t \n\tntfs_error(sb, \"Attribute list buffer overflow. Read attribute list \"\n\t\t\t\"is truncated.\");\nerr_out:\n\terr = -EIO;\n\tgoto done;\n}\n\n \nstatic int ntfs_external_attr_find(const ATTR_TYPE type,\n\t\tconst ntfschar *name, const u32 name_len,\n\t\tconst IGNORE_CASE_BOOL ic, const VCN lowest_vcn,\n\t\tconst u8 *val, const u32 val_len, ntfs_attr_search_ctx *ctx)\n{\n\tntfs_inode *base_ni, *ni;\n\tntfs_volume *vol;\n\tATTR_LIST_ENTRY *al_entry, *next_al_entry;\n\tu8 *al_start, *al_end;\n\tATTR_RECORD *a;\n\tntfschar *al_name;\n\tu32 al_name_len;\n\tint err = 0;\n\tstatic const char *es = \" Unmount and run chkdsk.\";\n\n\tni = ctx->ntfs_ino;\n\tbase_ni = ctx->base_ntfs_ino;\n\tntfs_debug(\"Entering for inode 0x%lx, type 0x%x.\", ni->mft_no, type);\n\tif (!base_ni) {\n\t\t \n\t\tbase_ni = ctx->base_ntfs_ino = ctx->ntfs_ino;\n\t\tctx->base_mrec = ctx->mrec;\n\t}\n\tif (ni == base_ni)\n\t\tctx->base_attr = ctx->attr;\n\tif (type == AT_END)\n\t\tgoto not_found;\n\tvol = base_ni->vol;\n\tal_start = base_ni->attr_list;\n\tal_end = al_start + base_ni->attr_list_size;\n\tif (!ctx->al_entry)\n\t\tctx->al_entry = (ATTR_LIST_ENTRY*)al_start;\n\t \n\tif (ctx->is_first) {\n\t\tal_entry = ctx->al_entry;\n\t\tctx->is_first = false;\n\t} else\n\t\tal_entry = (ATTR_LIST_ENTRY*)((u8*)ctx->al_entry +\n\t\t\t\tle16_to_cpu(ctx->al_entry->length));\n\tfor (;; al_entry = next_al_entry) {\n\t\t \n\t\tif ((u8*)al_entry < base_ni->attr_list ||\n\t\t\t\t(u8*)al_entry > al_end)\n\t\t\tbreak;\t \n\t\tctx->al_entry = al_entry;\n\t\t \n\t\tif ((u8*)al_entry == al_end)\n\t\t\tgoto not_found;\n\t\tif (!al_entry->length)\n\t\t\tbreak;\n\t\tif ((u8*)al_entry + 6 > al_end || (u8*)al_entry +\n\t\t\t\tle16_to_cpu(al_entry->length) > al_end)\n\t\t\tbreak;\n\t\tnext_al_entry = (ATTR_LIST_ENTRY*)((u8*)al_entry +\n\t\t\t\tle16_to_cpu(al_entry->length));\n\t\tif (le32_to_cpu(al_entry->type) > le32_to_cpu(type))\n\t\t\tgoto not_found;\n\t\tif (type != al_entry->type)\n\t\t\tcontinue;\n\t\t \n\t\tal_name_len = al_entry->name_length;\n\t\tal_name = (ntfschar*)((u8*)al_entry + al_entry->name_offset);\n\t\tif (!name) {\n\t\t\tif (al_name_len)\n\t\t\t\tgoto not_found;\n\t\t} else if (!ntfs_are_names_equal(al_name, al_name_len, name,\n\t\t\t\tname_len, ic, vol->upcase, vol->upcase_len)) {\n\t\t\tregister int rc;\n\n\t\t\trc = ntfs_collate_names(name, name_len, al_name,\n\t\t\t\t\tal_name_len, 1, IGNORE_CASE,\n\t\t\t\t\tvol->upcase, vol->upcase_len);\n\t\t\t \n\t\t\tif (rc == -1)\n\t\t\t\tgoto not_found;\n\t\t\t \n\t\t\tif (rc)\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\trc = ntfs_collate_names(name, name_len, al_name,\n\t\t\t\t\tal_name_len, 1, CASE_SENSITIVE,\n\t\t\t\t\tvol->upcase, vol->upcase_len);\n\t\t\tif (rc == -1)\n\t\t\t\tgoto not_found;\n\t\t\tif (rc)\n\t\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (lowest_vcn && (u8*)next_al_entry >= al_start\t    &&\n\t\t\t\t(u8*)next_al_entry + 6 < al_end\t\t    &&\n\t\t\t\t(u8*)next_al_entry + le16_to_cpu(\n\t\t\t\t\tnext_al_entry->length) <= al_end    &&\n\t\t\t\tsle64_to_cpu(next_al_entry->lowest_vcn) <=\n\t\t\t\t\tlowest_vcn\t\t\t    &&\n\t\t\t\tnext_al_entry->type == al_entry->type\t    &&\n\t\t\t\tnext_al_entry->name_length == al_name_len   &&\n\t\t\t\tntfs_are_names_equal((ntfschar*)((u8*)\n\t\t\t\t\tnext_al_entry +\n\t\t\t\t\tnext_al_entry->name_offset),\n\t\t\t\t\tnext_al_entry->name_length,\n\t\t\t\t\tal_name, al_name_len, CASE_SENSITIVE,\n\t\t\t\t\tvol->upcase, vol->upcase_len))\n\t\t\tcontinue;\n\t\tif (MREF_LE(al_entry->mft_reference) == ni->mft_no) {\n\t\t\tif (MSEQNO_LE(al_entry->mft_reference) != ni->seq_no) {\n\t\t\t\tntfs_error(vol->sb, \"Found stale mft \"\n\t\t\t\t\t\t\"reference in attribute list \"\n\t\t\t\t\t\t\"of base inode 0x%lx.%s\",\n\t\t\t\t\t\tbase_ni->mft_no, es);\n\t\t\t\terr = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {  \n\t\t\t \n\t\t\tif (ni != base_ni)\n\t\t\t\tunmap_extent_mft_record(ni);\n\t\t\t \n\t\t\tif (MREF_LE(al_entry->mft_reference) ==\n\t\t\t\t\tbase_ni->mft_no) {\n\t\t\t\tni = ctx->ntfs_ino = base_ni;\n\t\t\t\tctx->mrec = ctx->base_mrec;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tctx->mrec = map_extent_mft_record(base_ni,\n\t\t\t\t\t\tle64_to_cpu(\n\t\t\t\t\t\tal_entry->mft_reference), &ni);\n\t\t\t\tif (IS_ERR(ctx->mrec)) {\n\t\t\t\t\tntfs_error(vol->sb, \"Failed to map \"\n\t\t\t\t\t\t\t\"extent mft record \"\n\t\t\t\t\t\t\t\"0x%lx of base inode \"\n\t\t\t\t\t\t\t\"0x%lx.%s\",\n\t\t\t\t\t\t\tMREF_LE(al_entry->\n\t\t\t\t\t\t\tmft_reference),\n\t\t\t\t\t\t\tbase_ni->mft_no, es);\n\t\t\t\t\terr = PTR_ERR(ctx->mrec);\n\t\t\t\t\tif (err == -ENOENT)\n\t\t\t\t\t\terr = -EIO;\n\t\t\t\t\t \n\t\t\t\t\tni = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tctx->ntfs_ino = ni;\n\t\t\t}\n\t\t\tctx->attr = (ATTR_RECORD*)((u8*)ctx->mrec +\n\t\t\t\t\tle16_to_cpu(ctx->mrec->attrs_offset));\n\t\t}\n\t\t \n\t\t \n\t\ta = ctx->attr;\n\t\t \ndo_next_attr_loop:\n\t\tif ((u8*)a < (u8*)ctx->mrec || (u8*)a > (u8*)ctx->mrec +\n\t\t\t\tle32_to_cpu(ctx->mrec->bytes_allocated))\n\t\t\tbreak;\n\t\tif (a->type == AT_END)\n\t\t\tbreak;\n\t\tif (!a->length)\n\t\t\tbreak;\n\t\tif (al_entry->instance != a->instance)\n\t\t\tgoto do_next_attr;\n\t\t \n\t\tif (al_entry->type != a->type)\n\t\t\tbreak;\n\t\tif (!ntfs_are_names_equal((ntfschar*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->name_offset)), a->name_length,\n\t\t\t\tal_name, al_name_len, CASE_SENSITIVE,\n\t\t\t\tvol->upcase, vol->upcase_len))\n\t\t\tbreak;\n\t\tctx->attr = a;\n\t\t \n\t\tif (!val || (!a->non_resident && le32_to_cpu(\n\t\t\t\ta->data.resident.value_length) == val_len &&\n\t\t\t\t!memcmp((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset),\n\t\t\t\tval, val_len))) {\n\t\t\tntfs_debug(\"Done, found.\");\n\t\t\treturn 0;\n\t\t}\ndo_next_attr:\n\t\t \n\t\ta = (ATTR_RECORD*)((u8*)a + le32_to_cpu(a->length));\n\t\tgoto do_next_attr_loop;\n\t}\n\tif (!err) {\n\t\tntfs_error(vol->sb, \"Base inode 0x%lx contains corrupt \"\n\t\t\t\t\"attribute list attribute.%s\", base_ni->mft_no,\n\t\t\t\tes);\n\t\terr = -EIO;\n\t}\n\tif (ni != base_ni) {\n\t\tif (ni)\n\t\t\tunmap_extent_mft_record(ni);\n\t\tctx->ntfs_ino = base_ni;\n\t\tctx->mrec = ctx->base_mrec;\n\t\tctx->attr = ctx->base_attr;\n\t}\n\tif (err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\nnot_found:\n\t \n\tif (type == AT_END) {\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\treturn ntfs_attr_find(AT_END, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\t}\n\t \n\tif (ni != base_ni)\n\t\tunmap_extent_mft_record(ni);\n\tctx->mrec = ctx->base_mrec;\n\tctx->attr = (ATTR_RECORD*)((u8*)ctx->mrec +\n\t\t\tle16_to_cpu(ctx->mrec->attrs_offset));\n\tctx->is_first = true;\n\tctx->ntfs_ino = base_ni;\n\tctx->base_ntfs_ino = NULL;\n\tctx->base_mrec = NULL;\n\tctx->base_attr = NULL;\n\t \n\tdo {\n\t\terr = ntfs_attr_find(type, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\t} while (!err);\n\tntfs_debug(\"Done, not found.\");\n\treturn err;\n}\n\n \nint ntfs_attr_lookup(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst VCN lowest_vcn, const u8 *val, const u32 val_len,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(IS_ERR(ctx->mrec));\n\tif (ctx->base_ntfs_ino)\n\t\tbase_ni = ctx->base_ntfs_ino;\n\telse\n\t\tbase_ni = ctx->ntfs_ino;\n\t \n\tBUG_ON(!base_ni);\n\tif (!NInoAttrList(base_ni) || type == AT_ATTRIBUTE_LIST)\n\t\treturn ntfs_attr_find(type, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\treturn ntfs_external_attr_find(type, name, name_len, ic, lowest_vcn,\n\t\t\tval, val_len, ctx);\n}\n\n \nstatic inline void ntfs_attr_init_search_ctx(ntfs_attr_search_ctx *ctx,\n\t\tntfs_inode *ni, MFT_RECORD *mrec)\n{\n\t*ctx = (ntfs_attr_search_ctx) {\n\t\t.mrec = mrec,\n\t\t \n\t\t.attr = (ATTR_RECORD*)((u8*)mrec +\n\t\t\t\tle16_to_cpu(mrec->attrs_offset)),\n\t\t.is_first = true,\n\t\t.ntfs_ino = ni,\n\t};\n}\n\n \nvoid ntfs_attr_reinit_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (likely(!ctx->base_ntfs_ino)) {\n\t\t \n\t\tctx->is_first = true;\n\t\t \n\t\tctx->attr = (ATTR_RECORD*)((u8*)ctx->mrec +\n\t\t\t\tle16_to_cpu(ctx->mrec->attrs_offset));\n\t\t \n\t\tctx->al_entry = NULL;\n\t\treturn;\n\t}  \n\tif (ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tntfs_attr_init_search_ctx(ctx, ctx->base_ntfs_ino, ctx->base_mrec);\n\treturn;\n}\n\n \nntfs_attr_search_ctx *ntfs_attr_get_search_ctx(ntfs_inode *ni, MFT_RECORD *mrec)\n{\n\tntfs_attr_search_ctx *ctx;\n\n\tctx = kmem_cache_alloc(ntfs_attr_ctx_cache, GFP_NOFS);\n\tif (ctx)\n\t\tntfs_attr_init_search_ctx(ctx, ni, mrec);\n\treturn ctx;\n}\n\n \nvoid ntfs_attr_put_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (ctx->base_ntfs_ino && ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tkmem_cache_free(ntfs_attr_ctx_cache, ctx);\n\treturn;\n}\n\n#ifdef NTFS_RW\n\n \nstatic ATTR_DEF *ntfs_attr_find_in_attrdef(const ntfs_volume *vol,\n\t\tconst ATTR_TYPE type)\n{\n\tATTR_DEF *ad;\n\n\tBUG_ON(!vol->attrdef);\n\tBUG_ON(!type);\n\tfor (ad = vol->attrdef; (u8*)ad - (u8*)vol->attrdef <\n\t\t\tvol->attrdef_size && ad->type; ++ad) {\n\t\t \n\t\tif (likely(le32_to_cpu(ad->type) < le32_to_cpu(type)))\n\t\t\tcontinue;\n\t\t \n\t\tif (likely(ad->type == type))\n\t\t\treturn ad;\n\t\t \n\t\tbreak;\n\t}\n\t \n\tntfs_debug(\"Attribute type 0x%x not found in $AttrDef.\",\n\t\t\tle32_to_cpu(type));\n\treturn NULL;\n}\n\n \nint ntfs_attr_size_bounds_check(const ntfs_volume *vol, const ATTR_TYPE type,\n\t\tconst s64 size)\n{\n\tATTR_DEF *ad;\n\n\tBUG_ON(size < 0);\n\t \n\tif (unlikely(type == AT_ATTRIBUTE_LIST && size > 256 * 1024))\n\t\treturn -ERANGE;\n\t \n\tad = ntfs_attr_find_in_attrdef(vol, type);\n\tif (unlikely(!ad))\n\t\treturn -ENOENT;\n\t \n\tif (((sle64_to_cpu(ad->min_size) > 0) &&\n\t\t\tsize < sle64_to_cpu(ad->min_size)) ||\n\t\t\t((sle64_to_cpu(ad->max_size) > 0) && size >\n\t\t\tsle64_to_cpu(ad->max_size)))\n\t\treturn -ERANGE;\n\treturn 0;\n}\n\n \nint ntfs_attr_can_be_non_resident(const ntfs_volume *vol, const ATTR_TYPE type)\n{\n\tATTR_DEF *ad;\n\n\t \n\tad = ntfs_attr_find_in_attrdef(vol, type);\n\tif (unlikely(!ad))\n\t\treturn -ENOENT;\n\t \n\tif (ad->flags & ATTR_DEF_RESIDENT)\n\t\treturn -EPERM;\n\treturn 0;\n}\n\n \nint ntfs_attr_can_be_resident(const ntfs_volume *vol, const ATTR_TYPE type)\n{\n\tif (type == AT_INDEX_ALLOCATION)\n\t\treturn -EPERM;\n\treturn 0;\n}\n\n \nint ntfs_attr_record_resize(MFT_RECORD *m, ATTR_RECORD *a, u32 new_size)\n{\n\tntfs_debug(\"Entering for new_size %u.\", new_size);\n\t \n\tif (new_size & 7)\n\t\tnew_size = (new_size + 7) & ~7;\n\t \n\tif (new_size != le32_to_cpu(a->length)) {\n\t\tu32 new_muse = le32_to_cpu(m->bytes_in_use) -\n\t\t\t\tle32_to_cpu(a->length) + new_size;\n\t\t \n\t\tif (new_muse > le32_to_cpu(m->bytes_allocated))\n\t\t\treturn -ENOSPC;\n\t\t \n\t\tmemmove((u8*)a + new_size, (u8*)a + le32_to_cpu(a->length),\n\t\t\t\tle32_to_cpu(m->bytes_in_use) - ((u8*)a -\n\t\t\t\t(u8*)m) - le32_to_cpu(a->length));\n\t\t \n\t\tm->bytes_in_use = cpu_to_le32(new_muse);\n\t\t \n\t\tif (new_size >= offsetof(ATTR_REC, length) + sizeof(a->length))\n\t\t\ta->length = cpu_to_le32(new_size);\n\t}\n\treturn 0;\n}\n\n \nint ntfs_resident_attr_value_resize(MFT_RECORD *m, ATTR_RECORD *a,\n\t\tconst u32 new_size)\n{\n\tu32 old_size;\n\n\t \n\tif (ntfs_attr_record_resize(m, a,\n\t\t\tle16_to_cpu(a->data.resident.value_offset) + new_size))\n\t\treturn -ENOSPC;\n\t \n\told_size = le32_to_cpu(a->data.resident.value_length);\n\tif (new_size > old_size)\n\t\tmemset((u8*)a + le16_to_cpu(a->data.resident.value_offset) +\n\t\t\t\told_size, 0, new_size - old_size);\n\t \n\ta->data.resident.value_length = cpu_to_le32(new_size);\n\treturn 0;\n}\n\n \nint ntfs_attr_make_non_resident(ntfs_inode *ni, const u32 data_size)\n{\n\ts64 new_size;\n\tstruct inode *vi = VFS_I(ni);\n\tntfs_volume *vol = ni->vol;\n\tntfs_inode *base_ni;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tntfs_attr_search_ctx *ctx;\n\tstruct page *page;\n\trunlist_element *rl;\n\tu8 *kaddr;\n\tunsigned long flags;\n\tint mp_size, mp_ofs, name_ofs, arec_size, err, err2;\n\tu32 attr_size;\n\tu8 old_res_attr_flags;\n\n\t \n\terr = ntfs_attr_can_be_non_resident(vol, ni->type);\n\tif (unlikely(err)) {\n\t\tif (err == -EPERM)\n\t\t\tntfs_debug(\"Attribute is not allowed to be \"\n\t\t\t\t\t\"non-resident.\");\n\t\telse\n\t\t\tntfs_debug(\"Attribute not defined on the NTFS \"\n\t\t\t\t\t\"volume!\");\n\t\treturn err;\n\t}\n\t \n\tBUG_ON(NInoCompressed(ni));\n\tBUG_ON(NInoEncrypted(ni));\n\t \n\tnew_size = (data_size + vol->cluster_size - 1) &\n\t\t\t~(vol->cluster_size - 1);\n\tif (new_size > 0) {\n\t\t \n\t\tpage = find_or_create_page(vi->i_mapping, 0,\n\t\t\t\tmapping_gfp_mask(vi->i_mapping));\n\t\tif (unlikely(!page))\n\t\t\treturn -ENOMEM;\n\t\t \n\t\trl = ntfs_cluster_alloc(vol, 0, new_size >>\n\t\t\t\tvol->cluster_size_bits, -1, DATA_ZONE, true);\n\t\tif (IS_ERR(rl)) {\n\t\t\terr = PTR_ERR(rl);\n\t\t\tntfs_debug(\"Failed to allocate cluster%s, error code \"\n\t\t\t\t\t\"%i.\", (new_size >>\n\t\t\t\t\tvol->cluster_size_bits) > 1 ? \"s\" : \"\",\n\t\t\t\t\terr);\n\t\t\tgoto page_err_out;\n\t\t}\n\t} else {\n\t\trl = NULL;\n\t\tpage = NULL;\n\t}\n\t \n\tmp_size = ntfs_get_size_for_mapping_pairs(vol, rl, 0, -1);\n\tif (unlikely(mp_size < 0)) {\n\t\terr = mp_size;\n\t\tntfs_debug(\"Failed to get size for mapping pairs array, error \"\n\t\t\t\t\"code %i.\", err);\n\t\tgoto rl_err_out;\n\t}\n\tdown_write(&ni->runlist.lock);\n\tif (!NInoAttr(ni))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tm = map_mft_record(base_ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT)\n\t\t\terr = -EIO;\n\t\tgoto err_out;\n\t}\n\tm = ctx->mrec;\n\ta = ctx->attr;\n\tBUG_ON(NInoNonResident(ni));\n\tBUG_ON(a->non_resident);\n\t \n\tif (NInoSparse(ni) || NInoCompressed(ni))\n\t\tname_ofs = (offsetof(ATTR_REC,\n\t\t\t\tdata.non_resident.compressed_size) +\n\t\t\t\tsizeof(a->data.non_resident.compressed_size) +\n\t\t\t\t7) & ~7;\n\telse\n\t\tname_ofs = (offsetof(ATTR_REC,\n\t\t\t\tdata.non_resident.compressed_size) + 7) & ~7;\n\tmp_ofs = (name_ofs + a->name_length * sizeof(ntfschar) + 7) & ~7;\n\t \n\tarec_size = (mp_ofs + mp_size + 7) & ~7;\n\t \n\tattr_size = le32_to_cpu(a->data.resident.value_length);\n\tBUG_ON(attr_size != data_size);\n\tif (page && !PageUptodate(page)) {\n\t\tkaddr = kmap_atomic(page);\n\t\tmemcpy(kaddr, (u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset),\n\t\t\t\tattr_size);\n\t\tmemset(kaddr + attr_size, 0, PAGE_SIZE - attr_size);\n\t\tkunmap_atomic(kaddr);\n\t\tflush_dcache_page(page);\n\t\tSetPageUptodate(page);\n\t}\n\t \n\told_res_attr_flags = a->data.resident.flags;\n\t \n\terr = ntfs_attr_record_resize(m, a, arec_size);\n\tif (unlikely(err))\n\t\tgoto err_out;\n\t \n\ta->non_resident = 1;\n\t \n\tif (a->name_length)\n\t\tmemmove((u8*)a + name_ofs, (u8*)a + le16_to_cpu(a->name_offset),\n\t\t\t\ta->name_length * sizeof(ntfschar));\n\ta->name_offset = cpu_to_le16(name_ofs);\n\t \n\ta->data.non_resident.lowest_vcn = 0;\n\ta->data.non_resident.highest_vcn = cpu_to_sle64((new_size - 1) >>\n\t\t\tvol->cluster_size_bits);\n\ta->data.non_resident.mapping_pairs_offset = cpu_to_le16(mp_ofs);\n\tmemset(&a->data.non_resident.reserved, 0,\n\t\t\tsizeof(a->data.non_resident.reserved));\n\ta->data.non_resident.allocated_size = cpu_to_sle64(new_size);\n\ta->data.non_resident.data_size =\n\t\t\ta->data.non_resident.initialized_size =\n\t\t\tcpu_to_sle64(attr_size);\n\tif (NInoSparse(ni) || NInoCompressed(ni)) {\n\t\ta->data.non_resident.compression_unit = 0;\n\t\tif (NInoCompressed(ni) || vol->major_ver < 3)\n\t\t\ta->data.non_resident.compression_unit = 4;\n\t\ta->data.non_resident.compressed_size =\n\t\t\t\ta->data.non_resident.allocated_size;\n\t} else\n\t\ta->data.non_resident.compression_unit = 0;\n\t \n\terr = ntfs_mapping_pairs_build(vol, (u8*)a + mp_ofs,\n\t\t\tarec_size - mp_ofs, rl, 0, -1, NULL);\n\tif (unlikely(err)) {\n\t\tntfs_debug(\"Failed to build mapping pairs, error code %i.\",\n\t\t\t\terr);\n\t\tgoto undo_err_out;\n\t}\n\t \n\tni->runlist.rl = rl;\n\twrite_lock_irqsave(&ni->size_lock, flags);\n\tni->allocated_size = new_size;\n\tif (NInoSparse(ni) || NInoCompressed(ni)) {\n\t\tni->itype.compressed.size = ni->allocated_size;\n\t\tif (a->data.non_resident.compression_unit) {\n\t\t\tni->itype.compressed.block_size = 1U << (a->data.\n\t\t\t\t\tnon_resident.compression_unit +\n\t\t\t\t\tvol->cluster_size_bits);\n\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\tffs(ni->itype.compressed.block_size) -\n\t\t\t\t\t1;\n\t\t\tni->itype.compressed.block_clusters = 1U <<\n\t\t\t\t\ta->data.non_resident.compression_unit;\n\t\t} else {\n\t\t\tni->itype.compressed.block_size = 0;\n\t\t\tni->itype.compressed.block_size_bits = 0;\n\t\t\tni->itype.compressed.block_clusters = 0;\n\t\t}\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\t} else\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t \n\tNInoSetNonResident(ni);\n\t \n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(base_ni);\n\tup_write(&ni->runlist.lock);\n\tif (page) {\n\t\tset_page_dirty(page);\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t}\n\tntfs_debug(\"Done.\");\n\treturn 0;\nundo_err_out:\n\t \n\ta->non_resident = 0;\n\t \n\tname_ofs = (offsetof(ATTR_RECORD, data.resident.reserved) +\n\t\t\tsizeof(a->data.resident.reserved) + 7) & ~7;\n\tif (a->name_length)\n\t\tmemmove((u8*)a + name_ofs, (u8*)a + le16_to_cpu(a->name_offset),\n\t\t\t\ta->name_length * sizeof(ntfschar));\n\tmp_ofs = (name_ofs + a->name_length * sizeof(ntfschar) + 7) & ~7;\n\ta->name_offset = cpu_to_le16(name_ofs);\n\tarec_size = (mp_ofs + attr_size + 7) & ~7;\n\t \n\terr2 = ntfs_attr_record_resize(m, a, arec_size);\n\tif (unlikely(err2)) {\n\t\t \n\t\tarec_size = le32_to_cpu(a->length);\n\t\tif ((mp_ofs + attr_size) > arec_size) {\n\t\t\terr2 = attr_size;\n\t\t\tattr_size = arec_size - mp_ofs;\n\t\t\tntfs_error(vol->sb, \"Failed to undo partial resident \"\n\t\t\t\t\t\"to non-resident attribute \"\n\t\t\t\t\t\"conversion.  Truncating inode 0x%lx, \"\n\t\t\t\t\t\"attribute type 0x%x from %i bytes to \"\n\t\t\t\t\t\"%i bytes to maintain metadata \"\n\t\t\t\t\t\"consistency.  THIS MEANS YOU ARE \"\n\t\t\t\t\t\"LOSING %i BYTES DATA FROM THIS %s.\",\n\t\t\t\t\tvi->i_ino,\n\t\t\t\t\t(unsigned)le32_to_cpu(ni->type),\n\t\t\t\t\terr2, attr_size, err2 - attr_size,\n\t\t\t\t\t((ni->type == AT_DATA) &&\n\t\t\t\t\t!ni->name_len) ? \"FILE\": \"ATTRIBUTE\");\n\t\t\twrite_lock_irqsave(&ni->size_lock, flags);\n\t\t\tni->initialized_size = attr_size;\n\t\t\ti_size_write(vi, attr_size);\n\t\t\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t\t}\n\t}\n\t \n\ta->data.resident.value_length = cpu_to_le32(attr_size);\n\ta->data.resident.value_offset = cpu_to_le16(mp_ofs);\n\ta->data.resident.flags = old_res_attr_flags;\n\tmemset(&a->data.resident.reserved, 0,\n\t\t\tsizeof(a->data.resident.reserved));\n\t \n\tif (page) {\n\t\tkaddr = kmap_atomic(page);\n\t\tmemcpy((u8*)a + mp_ofs, kaddr, attr_size);\n\t\tkunmap_atomic(kaddr);\n\t}\n\t \n\twrite_lock_irqsave(&ni->size_lock, flags);\n\tni->allocated_size = arec_size - mp_ofs;\n\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t \n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\nerr_out:\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(base_ni);\n\tni->runlist.rl = NULL;\n\tup_write(&ni->runlist.lock);\nrl_err_out:\n\tif (rl) {\n\t\tif (ntfs_cluster_free_from_rl(vol, rl) < 0) {\n\t\t\tntfs_error(vol->sb, \"Failed to release allocated \"\n\t\t\t\t\t\"cluster(s) in error code path.  Run \"\n\t\t\t\t\t\"chkdsk to recover the lost \"\n\t\t\t\t\t\"cluster(s).\");\n\t\t\tNVolSetErrors(vol);\n\t\t}\n\t\tntfs_free(rl);\npage_err_out:\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t}\n\tif (err == -EINVAL)\n\t\terr = -EIO;\n\treturn err;\n}\n\n \ns64 ntfs_attr_extend_allocation(ntfs_inode *ni, s64 new_alloc_size,\n\t\tconst s64 new_data_size, const s64 data_start)\n{\n\tVCN vcn;\n\ts64 ll, allocated_size, start = data_start;\n\tstruct inode *vi = VFS_I(ni);\n\tntfs_volume *vol = ni->vol;\n\tntfs_inode *base_ni;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tntfs_attr_search_ctx *ctx;\n\trunlist_element *rl, *rl2;\n\tunsigned long flags;\n\tint err, mp_size;\n\tu32 attr_len = 0;  \n\tbool mp_rebuilt;\n\n#ifdef DEBUG\n\tread_lock_irqsave(&ni->size_lock, flags);\n\tallocated_size = ni->allocated_size;\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\tntfs_debug(\"Entering for i_ino 0x%lx, attribute type 0x%x, \"\n\t\t\t\"old_allocated_size 0x%llx, \"\n\t\t\t\"new_allocated_size 0x%llx, new_data_size 0x%llx, \"\n\t\t\t\"data_start 0x%llx.\", vi->i_ino,\n\t\t\t(unsigned)le32_to_cpu(ni->type),\n\t\t\t(unsigned long long)allocated_size,\n\t\t\t(unsigned long long)new_alloc_size,\n\t\t\t(unsigned long long)new_data_size,\n\t\t\t(unsigned long long)start);\n#endif\nretry_extend:\n\t \n\tif (NInoNonResident(ni)) {\n\t\tif (start > 0)\n\t\t\tstart &= ~(s64)vol->cluster_size_mask;\n\t\tnew_alloc_size = (new_alloc_size + vol->cluster_size - 1) &\n\t\t\t\t~(s64)vol->cluster_size_mask;\n\t}\n\tBUG_ON(new_data_size >= 0 && new_data_size > new_alloc_size);\n\t \n\terr = ntfs_attr_size_bounds_check(vol, ni->type, new_alloc_size);\n\tif (unlikely(err)) {\n\t\t \n\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\tallocated_size = ni->allocated_size;\n\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\tif (start < 0 || start >= allocated_size) {\n\t\t\tif (err == -ERANGE) {\n\t\t\t\tntfs_error(vol->sb, \"Cannot extend allocation \"\n\t\t\t\t\t\t\"of inode 0x%lx, attribute \"\n\t\t\t\t\t\t\"type 0x%x, because the new \"\n\t\t\t\t\t\t\"allocation would exceed the \"\n\t\t\t\t\t\t\"maximum allowed size for \"\n\t\t\t\t\t\t\"this attribute type.\",\n\t\t\t\t\t\tvi->i_ino, (unsigned)\n\t\t\t\t\t\tle32_to_cpu(ni->type));\n\t\t\t} else {\n\t\t\t\tntfs_error(vol->sb, \"Cannot extend allocation \"\n\t\t\t\t\t\t\"of inode 0x%lx, attribute \"\n\t\t\t\t\t\t\"type 0x%x, because this \"\n\t\t\t\t\t\t\"attribute type is not \"\n\t\t\t\t\t\t\"defined on the NTFS volume.  \"\n\t\t\t\t\t\t\"Possible corruption!  You \"\n\t\t\t\t\t\t\"should run chkdsk!\",\n\t\t\t\t\t\tvi->i_ino, (unsigned)\n\t\t\t\t\t\tle32_to_cpu(ni->type));\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (err == -ERANGE)\n\t\t\terr = -EFBIG;\n\t\telse\n\t\t\terr = -EIO;\n\t\treturn err;\n\t}\n\tif (!NInoAttr(ni))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\t \n\tdown_write(&ni->runlist.lock);\n\tm = map_mft_record(base_ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\tread_lock_irqsave(&ni->size_lock, flags);\n\tallocated_size = ni->allocated_size;\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t \n\tvcn = NInoNonResident(ni) ? allocated_size >> vol->cluster_size_bits :\n\t\t\t0;\n\t \n\tif (unlikely(new_alloc_size <= allocated_size)) {\n\t\tntfs_debug(\"Allocated size already exceeds requested size.\");\n\t\tnew_alloc_size = allocated_size;\n\t\tif (new_data_size < 0)\n\t\t\tgoto done;\n\t\t \n\t\tvcn = 0;\n\t}\n\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\tCASE_SENSITIVE, vcn, NULL, 0, ctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT)\n\t\t\terr = -EIO;\n\t\tgoto err_out;\n\t}\n\tm = ctx->mrec;\n\ta = ctx->attr;\n\t \n\tif (a->non_resident)\n\t\tgoto do_non_resident_extend;\n\tBUG_ON(NInoNonResident(ni));\n\t \n\tattr_len = le32_to_cpu(a->data.resident.value_length);\n\t \n\tif (new_alloc_size < vol->mft_record_size &&\n\t\t\t!ntfs_attr_record_resize(m, a,\n\t\t\tle16_to_cpu(a->data.resident.value_offset) +\n\t\t\tnew_alloc_size)) {\n\t\t \n\t\twrite_lock_irqsave(&ni->size_lock, flags);\n\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset);\n\t\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t\tif (new_data_size >= 0) {\n\t\t\tBUG_ON(new_data_size < attr_len);\n\t\t\ta->data.resident.value_length =\n\t\t\t\t\tcpu_to_le32((u32)new_data_size);\n\t\t}\n\t\tgoto flush_done;\n\t}\n\t \n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(base_ni);\n\tup_write(&ni->runlist.lock);\n\t \n\terr = ntfs_attr_make_non_resident(ni, attr_len);\n\tif (likely(!err))\n\t\tgoto retry_extend;\n\t \n\tif (unlikely(err != -EPERM && err != -ENOSPC)) {\n\t\t \n\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\tallocated_size = ni->allocated_size;\n\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\tif (start < 0 || start >= allocated_size)\n\t\t\tntfs_error(vol->sb, \"Cannot extend allocation of \"\n\t\t\t\t\t\"inode 0x%lx, attribute type 0x%x, \"\n\t\t\t\t\t\"because the conversion from resident \"\n\t\t\t\t\t\"to non-resident attribute failed \"\n\t\t\t\t\t\"with error code %i.\", vi->i_ino,\n\t\t\t\t\t(unsigned)le32_to_cpu(ni->type), err);\n\t\tif (err != -ENOMEM)\n\t\t\terr = -EIO;\n\t\tgoto conv_err_out;\n\t}\n\t \n\tread_lock_irqsave(&ni->size_lock, flags);\n\tallocated_size = ni->allocated_size;\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\tif (start < 0 || start >= allocated_size) {\n\t\tif (err == -ENOSPC)\n\t\t\tntfs_error(vol->sb, \"Not enough space in the mft \"\n\t\t\t\t\t\"record/on disk for the non-resident \"\n\t\t\t\t\t\"attribute value.  This case is not \"\n\t\t\t\t\t\"implemented yet.\");\n\t\telse  \n\t\t\tntfs_error(vol->sb, \"This attribute type may not be \"\n\t\t\t\t\t\"non-resident.  This case is not \"\n\t\t\t\t\t\"implemented yet.\");\n\t}\n\terr = -EOPNOTSUPP;\n\tgoto conv_err_out;\n#if 0\n\t\n\tif (!err)\n\t\tgoto do_resident_extend;\n\t \n\tif (ni->type == AT_ATTRIBUTE_LIST ||\n\t\t\tni->type == AT_STANDARD_INFORMATION) {\n\t\t\n\t\t\n\t\terr = -EOPNOTSUPP;\n\t\tif (!err)\n\t\t\tgoto do_resident_extend;\n\t\tgoto err_out;\n\t}\n\t\n\t\n\t\n\terr = -EOPNOTSUPP;\n\tif (!err)\n\t\tgoto do_resident_extend;\n\t \n\tgoto err_out;\n#endif\ndo_non_resident_extend:\n\tBUG_ON(!NInoNonResident(ni));\n\tif (new_alloc_size == allocated_size) {\n\t\tBUG_ON(vcn);\n\t\tgoto alloc_done;\n\t}\n\t \n\tif ((start >= 0 && start <= allocated_size) || ni->type != AT_DATA ||\n\t\t\t!NVolSparseEnabled(vol) || NInoSparseDisabled(ni))\n\t\tgoto skip_sparse;\n\t\n\t\n\tntfs_debug(\"Inserting holes is not-implemented yet.  Falling back to \"\n\t\t\t\"allocating real clusters instead.\");\nskip_sparse:\n\trl = ni->runlist.rl;\n\tif (likely(rl)) {\n\t\t \n\t\twhile (rl->length)\n\t\t\trl++;\n\t}\n\t \n\tif (unlikely(!rl || rl->lcn == LCN_RL_NOT_MAPPED ||\n\t\t\t(rl->lcn == LCN_ENOENT && rl > ni->runlist.rl &&\n\t\t\t(rl-1)->lcn == LCN_RL_NOT_MAPPED))) {\n\t\tif (!rl && !allocated_size)\n\t\t\tgoto first_alloc;\n\t\trl = ntfs_mapping_pairs_decompress(vol, a, ni->runlist.rl);\n\t\tif (IS_ERR(rl)) {\n\t\t\terr = PTR_ERR(rl);\n\t\t\tif (start < 0 || start >= allocated_size)\n\t\t\t\tntfs_error(vol->sb, \"Cannot extend allocation \"\n\t\t\t\t\t\t\"of inode 0x%lx, attribute \"\n\t\t\t\t\t\t\"type 0x%x, because the \"\n\t\t\t\t\t\t\"mapping of a runlist \"\n\t\t\t\t\t\t\"fragment failed with error \"\n\t\t\t\t\t\t\"code %i.\", vi->i_ino,\n\t\t\t\t\t\t(unsigned)le32_to_cpu(ni->type),\n\t\t\t\t\t\terr);\n\t\t\tif (err != -ENOMEM)\n\t\t\t\terr = -EIO;\n\t\t\tgoto err_out;\n\t\t}\n\t\tni->runlist.rl = rl;\n\t\t \n\t\twhile (rl->length)\n\t\t\trl++;\n\t}\n\t \n\t \n\twhile (rl->lcn < 0 && rl > ni->runlist.rl)\n\t\trl--;\nfirst_alloc:\n\t\n\t\n\t\n\trl2 = ntfs_cluster_alloc(vol, allocated_size >> vol->cluster_size_bits,\n\t\t\t(new_alloc_size - allocated_size) >>\n\t\t\tvol->cluster_size_bits, (rl && (rl->lcn >= 0)) ?\n\t\t\trl->lcn + rl->length : -1, DATA_ZONE, true);\n\tif (IS_ERR(rl2)) {\n\t\terr = PTR_ERR(rl2);\n\t\tif (start < 0 || start >= allocated_size)\n\t\t\tntfs_error(vol->sb, \"Cannot extend allocation of \"\n\t\t\t\t\t\"inode 0x%lx, attribute type 0x%x, \"\n\t\t\t\t\t\"because the allocation of clusters \"\n\t\t\t\t\t\"failed with error code %i.\", vi->i_ino,\n\t\t\t\t\t(unsigned)le32_to_cpu(ni->type), err);\n\t\tif (err != -ENOMEM && err != -ENOSPC)\n\t\t\terr = -EIO;\n\t\tgoto err_out;\n\t}\n\trl = ntfs_runlists_merge(ni->runlist.rl, rl2);\n\tif (IS_ERR(rl)) {\n\t\terr = PTR_ERR(rl);\n\t\tif (start < 0 || start >= allocated_size)\n\t\t\tntfs_error(vol->sb, \"Cannot extend allocation of \"\n\t\t\t\t\t\"inode 0x%lx, attribute type 0x%x, \"\n\t\t\t\t\t\"because the runlist merge failed \"\n\t\t\t\t\t\"with error code %i.\", vi->i_ino,\n\t\t\t\t\t(unsigned)le32_to_cpu(ni->type), err);\n\t\tif (err != -ENOMEM)\n\t\t\terr = -EIO;\n\t\tif (ntfs_cluster_free_from_rl(vol, rl2)) {\n\t\t\tntfs_error(vol->sb, \"Failed to release allocated \"\n\t\t\t\t\t\"cluster(s) in error code path.  Run \"\n\t\t\t\t\t\"chkdsk to recover the lost \"\n\t\t\t\t\t\"cluster(s).\");\n\t\t\tNVolSetErrors(vol);\n\t\t}\n\t\tntfs_free(rl2);\n\t\tgoto err_out;\n\t}\n\tni->runlist.rl = rl;\n\tntfs_debug(\"Allocated 0x%llx clusters.\", (long long)(new_alloc_size -\n\t\t\tallocated_size) >> vol->cluster_size_bits);\n\t \n\tll = sle64_to_cpu(a->data.non_resident.lowest_vcn);\n\trl2 = ntfs_rl_find_vcn_nolock(rl, ll);\n\tBUG_ON(!rl2);\n\tBUG_ON(!rl2->length);\n\tBUG_ON(rl2->lcn < LCN_HOLE);\n\tmp_rebuilt = false;\n\t \n\tmp_size = ntfs_get_size_for_mapping_pairs(vol, rl2, ll, -1);\n\tif (unlikely(mp_size <= 0)) {\n\t\terr = mp_size;\n\t\tif (start < 0 || start >= allocated_size)\n\t\t\tntfs_error(vol->sb, \"Cannot extend allocation of \"\n\t\t\t\t\t\"inode 0x%lx, attribute type 0x%x, \"\n\t\t\t\t\t\"because determining the size for the \"\n\t\t\t\t\t\"mapping pairs failed with error code \"\n\t\t\t\t\t\"%i.\", vi->i_ino,\n\t\t\t\t\t(unsigned)le32_to_cpu(ni->type), err);\n\t\terr = -EIO;\n\t\tgoto undo_alloc;\n\t}\n\t \n\tattr_len = le32_to_cpu(a->length);\n\terr = ntfs_attr_record_resize(m, a, mp_size +\n\t\t\tle16_to_cpu(a->data.non_resident.mapping_pairs_offset));\n\tif (unlikely(err)) {\n\t\tBUG_ON(err != -ENOSPC);\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tif (start < 0 || start >= allocated_size)\n\t\t\tntfs_error(vol->sb, \"Not enough space in the mft \"\n\t\t\t\t\t\"record for the extended attribute \"\n\t\t\t\t\t\"record.  This case is not \"\n\t\t\t\t\t\"implemented yet.\");\n\t\terr = -EOPNOTSUPP;\n\t\tgoto undo_alloc;\n\t}\n\tmp_rebuilt = true;\n\t \n\terr = ntfs_mapping_pairs_build(vol, (u8*)a +\n\t\t\tle16_to_cpu(a->data.non_resident.mapping_pairs_offset),\n\t\t\tmp_size, rl2, ll, -1, NULL);\n\tif (unlikely(err)) {\n\t\tif (start < 0 || start >= allocated_size)\n\t\t\tntfs_error(vol->sb, \"Cannot extend allocation of \"\n\t\t\t\t\t\"inode 0x%lx, attribute type 0x%x, \"\n\t\t\t\t\t\"because building the mapping pairs \"\n\t\t\t\t\t\"failed with error code %i.\", vi->i_ino,\n\t\t\t\t\t(unsigned)le32_to_cpu(ni->type), err);\n\t\terr = -EIO;\n\t\tgoto undo_alloc;\n\t}\n\t \n\ta->data.non_resident.highest_vcn = cpu_to_sle64((new_alloc_size >>\n\t\t\tvol->cluster_size_bits) - 1);\n\t \n\tif (a->data.non_resident.lowest_vcn) {\n\t\t \n\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err))\n\t\t\tgoto restore_undo_alloc;\n\t\t \n\t\ta = ctx->attr;\n\t}\n\twrite_lock_irqsave(&ni->size_lock, flags);\n\tni->allocated_size = new_alloc_size;\n\ta->data.non_resident.allocated_size = cpu_to_sle64(new_alloc_size);\n\t \n\tif (NInoSparse(ni) || NInoCompressed(ni)) {\n\t\tni->itype.compressed.size += new_alloc_size - allocated_size;\n\t\ta->data.non_resident.compressed_size =\n\t\t\t\tcpu_to_sle64(ni->itype.compressed.size);\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\t} else\n\t\tvi->i_blocks = new_alloc_size >> 9;\n\twrite_unlock_irqrestore(&ni->size_lock, flags);\nalloc_done:\n\tif (new_data_size >= 0) {\n\t\tBUG_ON(new_data_size <\n\t\t\t\tsle64_to_cpu(a->data.non_resident.data_size));\n\t\ta->data.non_resident.data_size = cpu_to_sle64(new_data_size);\n\t}\nflush_done:\n\t \n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\ndone:\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(base_ni);\n\tup_write(&ni->runlist.lock);\n\tntfs_debug(\"Done, new_allocated_size 0x%llx.\",\n\t\t\t(unsigned long long)new_alloc_size);\n\treturn new_alloc_size;\nrestore_undo_alloc:\n\tif (start < 0 || start >= allocated_size)\n\t\tntfs_error(vol->sb, \"Cannot complete extension of allocation \"\n\t\t\t\t\"of inode 0x%lx, attribute type 0x%x, because \"\n\t\t\t\t\"lookup of first attribute extent failed with \"\n\t\t\t\t\"error code %i.\", vi->i_ino,\n\t\t\t\t(unsigned)le32_to_cpu(ni->type), err);\n\tif (err == -ENOENT)\n\t\terr = -EIO;\n\tntfs_attr_reinit_search_ctx(ctx);\n\tif (ntfs_attr_lookup(ni->type, ni->name, ni->name_len, CASE_SENSITIVE,\n\t\t\tallocated_size >> vol->cluster_size_bits, NULL, 0,\n\t\t\tctx)) {\n\t\tntfs_error(vol->sb, \"Failed to find last attribute extent of \"\n\t\t\t\t\"attribute in error code path.  Run chkdsk to \"\n\t\t\t\t\"recover.\");\n\t\twrite_lock_irqsave(&ni->size_lock, flags);\n\t\tni->allocated_size = new_alloc_size;\n\t\t \n\t\tif (NInoSparse(ni) || NInoCompressed(ni)) {\n\t\t\tni->itype.compressed.size += new_alloc_size -\n\t\t\t\t\tallocated_size;\n\t\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\t\t} else\n\t\t\tvi->i_blocks = new_alloc_size >> 9;\n\t\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(base_ni);\n\t\tup_write(&ni->runlist.lock);\n\t\t \n\t\tNVolSetErrors(vol);\n\t\treturn err;\n\t}\n\tctx->attr->data.non_resident.highest_vcn = cpu_to_sle64(\n\t\t\t(allocated_size >> vol->cluster_size_bits) - 1);\nundo_alloc:\n\tll = allocated_size >> vol->cluster_size_bits;\n\tif (ntfs_cluster_free(ni, ll, -1, ctx) < 0) {\n\t\tntfs_error(vol->sb, \"Failed to release allocated cluster(s) \"\n\t\t\t\t\"in error code path.  Run chkdsk to recover \"\n\t\t\t\t\"the lost cluster(s).\");\n\t\tNVolSetErrors(vol);\n\t}\n\tm = ctx->mrec;\n\ta = ctx->attr;\n\t \n\tif (ntfs_rl_truncate_nolock(vol, &ni->runlist, ll) || IS_ERR(m)) {\n\t\tntfs_error(vol->sb, \"Failed to %s in error code path.  Run \"\n\t\t\t\t\"chkdsk to recover.\", IS_ERR(m) ?\n\t\t\t\t\"restore attribute search context\" :\n\t\t\t\t\"truncate attribute runlist\");\n\t\tNVolSetErrors(vol);\n\t} else if (mp_rebuilt) {\n\t\tif (ntfs_attr_record_resize(m, a, attr_len)) {\n\t\t\tntfs_error(vol->sb, \"Failed to restore attribute \"\n\t\t\t\t\t\"record in error code path.  Run \"\n\t\t\t\t\t\"chkdsk to recover.\");\n\t\t\tNVolSetErrors(vol);\n\t\t} else   {\n\t\t\tif (ntfs_mapping_pairs_build(vol, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\tmapping_pairs_offset), attr_len -\n\t\t\t\t\tle16_to_cpu(a->data.non_resident.\n\t\t\t\t\tmapping_pairs_offset), rl2, ll, -1,\n\t\t\t\t\tNULL)) {\n\t\t\t\tntfs_error(vol->sb, \"Failed to restore \"\n\t\t\t\t\t\t\"mapping pairs array in error \"\n\t\t\t\t\t\t\"code path.  Run chkdsk to \"\n\t\t\t\t\t\t\"recover.\");\n\t\t\t\tNVolSetErrors(vol);\n\t\t\t}\n\t\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t\t}\n\t}\nerr_out:\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(base_ni);\n\tup_write(&ni->runlist.lock);\nconv_err_out:\n\tntfs_debug(\"Failed.  Returning error code %i.\", err);\n\treturn err;\n}\n\n \nint ntfs_attr_set(ntfs_inode *ni, const s64 ofs, const s64 cnt, const u8 val)\n{\n\tntfs_volume *vol = ni->vol;\n\tstruct address_space *mapping;\n\tstruct page *page;\n\tu8 *kaddr;\n\tpgoff_t idx, end;\n\tunsigned start_ofs, end_ofs, size;\n\n\tntfs_debug(\"Entering for ofs 0x%llx, cnt 0x%llx, val 0x%hx.\",\n\t\t\t(long long)ofs, (long long)cnt, val);\n\tBUG_ON(ofs < 0);\n\tBUG_ON(cnt < 0);\n\tif (!cnt)\n\t\tgoto done;\n\t \n\tBUG_ON(NInoCompressed(ni));\n\tBUG_ON(NInoEncrypted(ni));\n\tmapping = VFS_I(ni)->i_mapping;\n\t \n\tidx = ofs >> PAGE_SHIFT;\n\tstart_ofs = ofs & ~PAGE_MASK;\n\t \n\tend = ofs + cnt;\n\tend_ofs = end & ~PAGE_MASK;\n\t \n\tif (unlikely(end > i_size_read(VFS_I(ni)))) {\n\t\tntfs_error(vol->sb, \"Request exceeds end of attribute.\");\n\t\treturn -ESPIPE;\n\t}\n\tend >>= PAGE_SHIFT;\n\t \n\tif (start_ofs) {\n\t\tpage = read_mapping_page(mapping, idx, NULL);\n\t\tif (IS_ERR(page)) {\n\t\t\tntfs_error(vol->sb, \"Failed to read first partial \"\n\t\t\t\t\t\"page (error, index 0x%lx).\", idx);\n\t\t\treturn PTR_ERR(page);\n\t\t}\n\t\t \n\t\tsize = PAGE_SIZE;\n\t\tif (idx == end)\n\t\t\tsize = end_ofs;\n\t\tkaddr = kmap_atomic(page);\n\t\tmemset(kaddr + start_ofs, val, size - start_ofs);\n\t\tflush_dcache_page(page);\n\t\tkunmap_atomic(kaddr);\n\t\tset_page_dirty(page);\n\t\tput_page(page);\n\t\tbalance_dirty_pages_ratelimited(mapping);\n\t\tcond_resched();\n\t\tif (idx == end)\n\t\t\tgoto done;\n\t\tidx++;\n\t}\n\t \n\tfor (; idx < end; idx++) {\n\t\t \n\t\tpage = grab_cache_page(mapping, idx);\n\t\tif (unlikely(!page)) {\n\t\t\tntfs_error(vol->sb, \"Insufficient memory to grab \"\n\t\t\t\t\t\"page (index 0x%lx).\", idx);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tkaddr = kmap_atomic(page);\n\t\tmemset(kaddr, val, PAGE_SIZE);\n\t\tflush_dcache_page(page);\n\t\tkunmap_atomic(kaddr);\n\t\t \n\t\tif (page_has_buffers(page)) {\n\t\t\tstruct buffer_head *bh, *head;\n\n\t\t\tbh = head = page_buffers(page);\n\t\t\tdo {\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t} while ((bh = bh->b_this_page) != head);\n\t\t}\n\t\t \n\t\tSetPageUptodate(page);\n\t\t \n\t\tset_page_dirty(page);\n\t\t \n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\tbalance_dirty_pages_ratelimited(mapping);\n\t\tcond_resched();\n\t}\n\t \n\tif (end_ofs) {\n\t\tpage = read_mapping_page(mapping, idx, NULL);\n\t\tif (IS_ERR(page)) {\n\t\t\tntfs_error(vol->sb, \"Failed to read last partial page \"\n\t\t\t\t\t\"(error, index 0x%lx).\", idx);\n\t\t\treturn PTR_ERR(page);\n\t\t}\n\t\tkaddr = kmap_atomic(page);\n\t\tmemset(kaddr, val, end_ofs);\n\t\tflush_dcache_page(page);\n\t\tkunmap_atomic(kaddr);\n\t\tset_page_dirty(page);\n\t\tput_page(page);\n\t\tbalance_dirty_pages_ratelimited(mapping);\n\t\tcond_resched();\n\t}\ndone:\n\tntfs_debug(\"Done.\");\n\treturn 0;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}