{
  "module_name": "file.c",
  "hash_id": "775bf1b0c1fb634f42222d716ecb02723d5372b63ea718ef796948147e17a318",
  "original_prompt": "Ingested from linux-6.6.14/fs/ntfs/file.c",
  "human_readable_source": "\n \n\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/gfp.h>\n#include <linux/pagemap.h>\n#include <linux/pagevec.h>\n#include <linux/sched/signal.h>\n#include <linux/swap.h>\n#include <linux/uio.h>\n#include <linux/writeback.h>\n\n#include <asm/page.h>\n#include <linux/uaccess.h>\n\n#include \"attrib.h\"\n#include \"bitmap.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"lcnalloc.h\"\n#include \"malloc.h\"\n#include \"mft.h\"\n#include \"ntfs.h\"\n\n \nstatic int ntfs_file_open(struct inode *vi, struct file *filp)\n{\n\tif (sizeof(unsigned long) < 8) {\n\t\tif (i_size_read(vi) > MAX_LFS_FILESIZE)\n\t\t\treturn -EOVERFLOW;\n\t}\n\treturn generic_file_open(vi, filp);\n}\n\n#ifdef NTFS_RW\n\n \nstatic int ntfs_attr_extend_initialized(ntfs_inode *ni, const s64 new_init_size)\n{\n\ts64 old_init_size;\n\tloff_t old_i_size;\n\tpgoff_t index, end_index;\n\tunsigned long flags;\n\tstruct inode *vi = VFS_I(ni);\n\tntfs_inode *base_ni;\n\tMFT_RECORD *m = NULL;\n\tATTR_RECORD *a;\n\tntfs_attr_search_ctx *ctx = NULL;\n\tstruct address_space *mapping;\n\tstruct page *page = NULL;\n\tu8 *kattr;\n\tint err;\n\tu32 attr_len;\n\n\tread_lock_irqsave(&ni->size_lock, flags);\n\told_init_size = ni->initialized_size;\n\told_i_size = i_size_read(vi);\n\tBUG_ON(new_init_size > ni->allocated_size);\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\tntfs_debug(\"Entering for i_ino 0x%lx, attribute type 0x%x, \"\n\t\t\t\"old_initialized_size 0x%llx, \"\n\t\t\t\"new_initialized_size 0x%llx, i_size 0x%llx.\",\n\t\t\tvi->i_ino, (unsigned)le32_to_cpu(ni->type),\n\t\t\t(unsigned long long)old_init_size,\n\t\t\t(unsigned long long)new_init_size, old_i_size);\n\tif (!NInoAttr(ni))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\t \n\tif (NInoNonResident(ni))\n\t\tgoto do_non_resident_extend;\n\tBUG_ON(old_init_size != old_i_size);\n\tm = map_mft_record(base_ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tm = NULL;\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT)\n\t\t\terr = -EIO;\n\t\tgoto err_out;\n\t}\n\tm = ctx->mrec;\n\ta = ctx->attr;\n\tBUG_ON(a->non_resident);\n\t \n\tattr_len = le32_to_cpu(a->data.resident.value_length);\n\tBUG_ON(old_i_size != (loff_t)attr_len);\n\t \n\tkattr = (u8*)a + le16_to_cpu(a->data.resident.value_offset);\n\tmemset(kattr + attr_len, 0, new_init_size - attr_len);\n\ta->data.resident.value_length = cpu_to_le32((u32)new_init_size);\n\t \n\twrite_lock_irqsave(&ni->size_lock, flags);\n\ti_size_write(vi, new_init_size);\n\tni->initialized_size = new_init_size;\n\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\tgoto done;\ndo_non_resident_extend:\n\t \n\tif (new_init_size > old_i_size) {\n\t\tm = map_mft_record(base_ni);\n\t\tif (IS_ERR(m)) {\n\t\t\terr = PTR_ERR(m);\n\t\t\tm = NULL;\n\t\t\tgoto err_out;\n\t\t}\n\t\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\t\tif (unlikely(!ctx)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_out;\n\t\t}\n\t\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\terr = -EIO;\n\t\t\tgoto err_out;\n\t\t}\n\t\tm = ctx->mrec;\n\t\ta = ctx->attr;\n\t\tBUG_ON(!a->non_resident);\n\t\tBUG_ON(old_i_size != (loff_t)\n\t\t\t\tsle64_to_cpu(a->data.non_resident.data_size));\n\t\ta->data.non_resident.data_size = cpu_to_sle64(new_init_size);\n\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t\t \n\t\ti_size_write(vi, new_init_size);\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tctx = NULL;\n\t\tunmap_mft_record(base_ni);\n\t\tm = NULL;\n\t}\n\tmapping = vi->i_mapping;\n\tindex = old_init_size >> PAGE_SHIFT;\n\tend_index = (new_init_size + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tdo {\n\t\t \n\t\tpage = read_mapping_page(mapping, index, NULL);\n\t\tif (IS_ERR(page)) {\n\t\t\terr = PTR_ERR(page);\n\t\t\tgoto init_err_out;\n\t\t}\n\t\t \n\t\twrite_lock_irqsave(&ni->size_lock, flags);\n\t\tni->initialized_size = (s64)(index + 1) << PAGE_SHIFT;\n\t\tif (ni->initialized_size > new_init_size)\n\t\t\tni->initialized_size = new_init_size;\n\t\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t\t \n\t\tset_page_dirty(page);\n\t\tput_page(page);\n\t\t \n\t\tbalance_dirty_pages_ratelimited(mapping);\n\t\tcond_resched();\n\t} while (++index < end_index);\n\tread_lock_irqsave(&ni->size_lock, flags);\n\tBUG_ON(ni->initialized_size != new_init_size);\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t \n\tm = map_mft_record(base_ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tm = NULL;\n\t\tgoto init_err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto init_err_out;\n\t}\n\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT)\n\t\t\terr = -EIO;\n\t\tgoto init_err_out;\n\t}\n\tm = ctx->mrec;\n\ta = ctx->attr;\n\tBUG_ON(!a->non_resident);\n\ta->data.non_resident.initialized_size = cpu_to_sle64(new_init_size);\ndone:\n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(base_ni);\n\tntfs_debug(\"Done, initialized_size 0x%llx, i_size 0x%llx.\",\n\t\t\t(unsigned long long)new_init_size, i_size_read(vi));\n\treturn 0;\ninit_err_out:\n\twrite_lock_irqsave(&ni->size_lock, flags);\n\tni->initialized_size = old_init_size;\n\twrite_unlock_irqrestore(&ni->size_lock, flags);\nerr_out:\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(base_ni);\n\tntfs_debug(\"Failed.  Returning error code %i.\", err);\n\treturn err;\n}\n\nstatic ssize_t ntfs_prepare_file_for_write(struct kiocb *iocb,\n\t\tstruct iov_iter *from)\n{\n\tloff_t pos;\n\ts64 end, ll;\n\tssize_t err;\n\tunsigned long flags;\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *vi = file_inode(file);\n\tntfs_inode *ni = NTFS_I(vi);\n\tntfs_volume *vol = ni->vol;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx, attribute type 0x%x, pos \"\n\t\t\t\"0x%llx, count 0x%zx.\", vi->i_ino,\n\t\t\t(unsigned)le32_to_cpu(ni->type),\n\t\t\t(unsigned long long)iocb->ki_pos,\n\t\t\tiov_iter_count(from));\n\terr = generic_write_checks(iocb, from);\n\tif (unlikely(err <= 0))\n\t\tgoto out;\n\t \n\tBUG_ON(NInoMstProtected(ni));\n\tBUG_ON(ni->type != AT_DATA);\n\t \n\tif (NInoEncrypted(ni)) {\n\t\t \n\t\t \n\t\tntfs_debug(\"Denying write access to encrypted file.\");\n\t\terr = -EACCES;\n\t\tgoto out;\n\t}\n\tif (NInoCompressed(ni)) {\n\t\t \n\t\tBUG_ON(ni->name_len);\n\t\t \n\t\tntfs_error(vi->i_sb, \"Writing to compressed files is not \"\n\t\t\t\t\"implemented yet.  Sorry.\");\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\terr = file_remove_privs(file);\n\tif (unlikely(err))\n\t\tgoto out;\n\t \n\tfile_update_time(file);\n\tpos = iocb->ki_pos;\n\t \n\tend = (pos + iov_iter_count(from) + vol->cluster_size_mask) &\n\t\t\t~(u64)vol->cluster_size_mask;\n\t \n\tread_lock_irqsave(&ni->size_lock, flags);\n\tll = ni->allocated_size;\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\tif (end > ll) {\n\t\t \n\t\tll = ntfs_attr_extend_allocation(ni, end, -1, pos);\n\t\tif (likely(ll >= 0)) {\n\t\t\tBUG_ON(pos >= ll);\n\t\t\t \n\t\t\tif (end > ll) {\n\t\t\t\tntfs_debug(\"Truncating write to inode 0x%lx, \"\n\t\t\t\t\t\t\"attribute type 0x%x, because \"\n\t\t\t\t\t\t\"the allocation was only \"\n\t\t\t\t\t\t\"partially extended.\",\n\t\t\t\t\t\tvi->i_ino, (unsigned)\n\t\t\t\t\t\tle32_to_cpu(ni->type));\n\t\t\t\tiov_iter_truncate(from, ll - pos);\n\t\t\t}\n\t\t} else {\n\t\t\terr = ll;\n\t\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\t\tll = ni->allocated_size;\n\t\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\t\t \n\t\t\tif (pos < ll) {\n\t\t\t\tntfs_debug(\"Truncating write to inode 0x%lx \"\n\t\t\t\t\t\t\"attribute type 0x%x, because \"\n\t\t\t\t\t\t\"extending the allocation \"\n\t\t\t\t\t\t\"failed (error %d).\",\n\t\t\t\t\t\tvi->i_ino, (unsigned)\n\t\t\t\t\t\tle32_to_cpu(ni->type),\n\t\t\t\t\t\t(int)-err);\n\t\t\t\tiov_iter_truncate(from, ll - pos);\n\t\t\t} else {\n\t\t\t\tif (err != -ENOSPC)\n\t\t\t\t\tntfs_error(vi->i_sb, \"Cannot perform \"\n\t\t\t\t\t\t\t\"write to inode \"\n\t\t\t\t\t\t\t\"0x%lx, attribute \"\n\t\t\t\t\t\t\t\"type 0x%x, because \"\n\t\t\t\t\t\t\t\"extending the \"\n\t\t\t\t\t\t\t\"allocation failed \"\n\t\t\t\t\t\t\t\"(error %ld).\",\n\t\t\t\t\t\t\tvi->i_ino, (unsigned)\n\t\t\t\t\t\t\tle32_to_cpu(ni->type),\n\t\t\t\t\t\t\t(long)-err);\n\t\t\t\telse\n\t\t\t\t\tntfs_debug(\"Cannot perform write to \"\n\t\t\t\t\t\t\t\"inode 0x%lx, \"\n\t\t\t\t\t\t\t\"attribute type 0x%x, \"\n\t\t\t\t\t\t\t\"because there is not \"\n\t\t\t\t\t\t\t\"space left.\",\n\t\t\t\t\t\t\tvi->i_ino, (unsigned)\n\t\t\t\t\t\t\tle32_to_cpu(ni->type));\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\t \n\tread_lock_irqsave(&ni->size_lock, flags);\n\tll = ni->initialized_size;\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\tif (pos > ll) {\n\t\t \n\t\tinode_dio_wait(vi);\n\t\terr = ntfs_attr_extend_initialized(ni, pos);\n\t\tif (unlikely(err < 0))\n\t\t\tntfs_error(vi->i_sb, \"Cannot perform write to inode \"\n\t\t\t\t\t\"0x%lx, attribute type 0x%x, because \"\n\t\t\t\t\t\"extending the initialized size \"\n\t\t\t\t\t\"failed (error %d).\", vi->i_ino,\n\t\t\t\t\t(unsigned)le32_to_cpu(ni->type),\n\t\t\t\t\t(int)-err);\n\t}\nout:\n\treturn err;\n}\n\n \nstatic inline int __ntfs_grab_cache_pages(struct address_space *mapping,\n\t\tpgoff_t index, const unsigned nr_pages, struct page **pages,\n\t\tstruct page **cached_page)\n{\n\tint err, nr;\n\n\tBUG_ON(!nr_pages);\n\terr = nr = 0;\n\tdo {\n\t\tpages[nr] = find_get_page_flags(mapping, index, FGP_LOCK |\n\t\t\t\tFGP_ACCESSED);\n\t\tif (!pages[nr]) {\n\t\t\tif (!*cached_page) {\n\t\t\t\t*cached_page = page_cache_alloc(mapping);\n\t\t\t\tif (unlikely(!*cached_page)) {\n\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\tgoto err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\terr = add_to_page_cache_lru(*cached_page, mapping,\n\t\t\t\t   index,\n\t\t\t\t   mapping_gfp_constraint(mapping, GFP_KERNEL));\n\t\t\tif (unlikely(err)) {\n\t\t\t\tif (err == -EEXIST)\n\t\t\t\t\tcontinue;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\tpages[nr] = *cached_page;\n\t\t\t*cached_page = NULL;\n\t\t}\n\t\tindex++;\n\t\tnr++;\n\t} while (nr < nr_pages);\nout:\n\treturn err;\nerr_out:\n\twhile (nr > 0) {\n\t\tunlock_page(pages[--nr]);\n\t\tput_page(pages[nr]);\n\t}\n\tgoto out;\n}\n\nstatic inline void ntfs_submit_bh_for_read(struct buffer_head *bh)\n{\n\tlock_buffer(bh);\n\tget_bh(bh);\n\tbh->b_end_io = end_buffer_read_sync;\n\tsubmit_bh(REQ_OP_READ, bh);\n}\n\n \nstatic int ntfs_prepare_pages_for_non_resident_write(struct page **pages,\n\t\tunsigned nr_pages, s64 pos, size_t bytes)\n{\n\tVCN vcn, highest_vcn = 0, cpos, cend, bh_cpos, bh_cend;\n\tLCN lcn;\n\ts64 bh_pos, vcn_len, end, initialized_size;\n\tsector_t lcn_block;\n\tstruct page *page;\n\tstruct inode *vi;\n\tntfs_inode *ni, *base_ni = NULL;\n\tntfs_volume *vol;\n\trunlist_element *rl, *rl2;\n\tstruct buffer_head *bh, *head, *wait[2], **wait_bh = wait;\n\tntfs_attr_search_ctx *ctx = NULL;\n\tMFT_RECORD *m = NULL;\n\tATTR_RECORD *a = NULL;\n\tunsigned long flags;\n\tu32 attr_rec_len = 0;\n\tunsigned blocksize, u;\n\tint err, mp_size;\n\tbool rl_write_locked, was_hole, is_retry;\n\tunsigned char blocksize_bits;\n\tstruct {\n\t\tu8 runlist_merged:1;\n\t\tu8 mft_attr_mapped:1;\n\t\tu8 mp_rebuilt:1;\n\t\tu8 attr_switched:1;\n\t} status = { 0, 0, 0, 0 };\n\n\tBUG_ON(!nr_pages);\n\tBUG_ON(!pages);\n\tBUG_ON(!*pages);\n\tvi = pages[0]->mapping->host;\n\tni = NTFS_I(vi);\n\tvol = ni->vol;\n\tntfs_debug(\"Entering for inode 0x%lx, attribute type 0x%x, start page \"\n\t\t\t\"index 0x%lx, nr_pages 0x%x, pos 0x%llx, bytes 0x%zx.\",\n\t\t\tvi->i_ino, ni->type, pages[0]->index, nr_pages,\n\t\t\t(long long)pos, bytes);\n\tblocksize = vol->sb->s_blocksize;\n\tblocksize_bits = vol->sb->s_blocksize_bits;\n\tu = 0;\n\tdo {\n\t\tpage = pages[u];\n\t\tBUG_ON(!page);\n\t\t \n\t\tif (!page_has_buffers(page)) {\n\t\t\tcreate_empty_buffers(page, blocksize, 0);\n\t\t\tif (unlikely(!page_has_buffers(page)))\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t} while (++u < nr_pages);\n\trl_write_locked = false;\n\trl = NULL;\n\terr = 0;\n\tvcn = lcn = -1;\n\tvcn_len = 0;\n\tlcn_block = -1;\n\twas_hole = false;\n\tcpos = pos >> vol->cluster_size_bits;\n\tend = pos + bytes;\n\tcend = (end + vol->cluster_size - 1) >> vol->cluster_size_bits;\n\t \n\tu = 0;\ndo_next_page:\n\tpage = pages[u];\n\tbh_pos = (s64)page->index << PAGE_SHIFT;\n\tbh = head = page_buffers(page);\n\tdo {\n\t\tVCN cdelta;\n\t\ts64 bh_end;\n\t\tunsigned bh_cofs;\n\n\t\t \n\t\tif (buffer_new(bh))\n\t\t\tclear_buffer_new(bh);\n\t\tbh_end = bh_pos + blocksize;\n\t\tbh_cpos = bh_pos >> vol->cluster_size_bits;\n\t\tbh_cofs = bh_pos & vol->cluster_size_mask;\n\t\tif (buffer_mapped(bh)) {\n\t\t\t \n\t\t\tif (buffer_uptodate(bh))\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t \n\t\t\tif ((bh_pos < pos && bh_end > pos) ||\n\t\t\t\t\t(bh_pos < end && bh_end > end)) {\n\t\t\t\t \n\t\t\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\t\t\tinitialized_size = ni->initialized_size;\n\t\t\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\t\t\tif (bh_pos < initialized_size) {\n\t\t\t\t\tntfs_submit_bh_for_read(bh);\n\t\t\t\t\t*wait_bh++ = bh;\n\t\t\t\t} else {\n\t\t\t\t\tzero_user(page, bh_offset(bh),\n\t\t\t\t\t\t\tblocksize);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tbh->b_bdev = vol->sb->s_bdev;\n\t\t \n\t\tcdelta = bh_cpos - vcn;\n\t\tif (likely(!cdelta || (cdelta > 0 && cdelta < vcn_len))) {\nmap_buffer_cached:\n\t\t\tBUG_ON(lcn < 0);\n\t\t\tbh->b_blocknr = lcn_block +\n\t\t\t\t\t(cdelta << (vol->cluster_size_bits -\n\t\t\t\t\tblocksize_bits)) +\n\t\t\t\t\t(bh_cofs >> blocksize_bits);\n\t\t\tset_buffer_mapped(bh);\n\t\t\t \n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tif (unlikely(was_hole)) {\n\t\t\t\t\t \n\t\t\t\t\tclean_bdev_bh_alias(bh);\n\t\t\t\t\tif (bh_end <= pos || bh_pos >= end)\n\t\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t\telse\n\t\t\t\t\t\tset_buffer_new(bh);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t \n\t\t\tif (likely(!was_hole)) {\n\t\t\t\t \n\t\t\t\tif (!buffer_uptodate(bh) && bh_pos < end &&\n\t\t\t\t\t\tbh_end > pos &&\n\t\t\t\t\t\t(bh_pos < pos ||\n\t\t\t\t\t\tbh_end > end)) {\n\t\t\t\t\t \n\t\t\t\t\tread_lock_irqsave(&ni->size_lock,\n\t\t\t\t\t\t\tflags);\n\t\t\t\t\tinitialized_size = ni->initialized_size;\n\t\t\t\t\tread_unlock_irqrestore(&ni->size_lock,\n\t\t\t\t\t\t\tflags);\n\t\t\t\t\tif (bh_pos < initialized_size) {\n\t\t\t\t\t\tntfs_submit_bh_for_read(bh);\n\t\t\t\t\t\t*wait_bh++ = bh;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tzero_user(page, bh_offset(bh),\n\t\t\t\t\t\t\t\tblocksize);\n\t\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t \n\t\t\tclean_bdev_bh_alias(bh);\n\t\t\t \n\t\t\tif (bh_end <= pos || bh_pos >= end) {\n\t\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\t\tzero_user(page, bh_offset(bh),\n\t\t\t\t\t\t\tblocksize);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t}\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tset_buffer_new(bh);\n\t\t\tif (!buffer_uptodate(bh) &&\n\t\t\t\t\t(bh_pos < pos || bh_end > end)) {\n\t\t\t\tu8 *kaddr;\n\t\t\t\tunsigned pofs;\n\t\t\t\t\t\n\t\t\t\tkaddr = kmap_atomic(page);\n\t\t\t\tif (bh_pos < pos) {\n\t\t\t\t\tpofs = bh_pos & ~PAGE_MASK;\n\t\t\t\t\tmemset(kaddr + pofs, 0, pos - bh_pos);\n\t\t\t\t}\n\t\t\t\tif (bh_end > end) {\n\t\t\t\t\tpofs = end & ~PAGE_MASK;\n\t\t\t\t\tmemset(kaddr + pofs, 0, bh_end - end);\n\t\t\t\t}\n\t\t\t\tkunmap_atomic(kaddr);\n\t\t\t\tflush_dcache_page(page);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\tinitialized_size = ni->allocated_size;\n\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\tif (bh_pos > initialized_size) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t} else if (!buffer_uptodate(bh)) {\n\t\t\t\tzero_user(page, bh_offset(bh), blocksize);\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tis_retry = false;\n\t\tif (!rl) {\n\t\t\tdown_read(&ni->runlist.lock);\nretry_remap:\n\t\t\trl = ni->runlist.rl;\n\t\t}\n\t\tif (likely(rl != NULL)) {\n\t\t\t \n\t\t\twhile (rl->length && rl[1].vcn <= bh_cpos)\n\t\t\t\trl++;\n\t\t\tlcn = ntfs_rl_vcn_to_lcn(rl, bh_cpos);\n\t\t\tif (likely(lcn >= 0)) {\n\t\t\t\t \n\t\t\t\twas_hole = false;\n\t\t\t\tvcn = bh_cpos;\n\t\t\t\tvcn_len = rl[1].vcn - vcn;\n\t\t\t\tlcn_block = lcn << (vol->cluster_size_bits -\n\t\t\t\t\t\tblocksize_bits);\n\t\t\t\tcdelta = 0;\n\t\t\t\t \n\t\t\t\tif (likely(vcn + vcn_len >= cend)) {\n\t\t\t\t\tif (rl_write_locked) {\n\t\t\t\t\t\tup_write(&ni->runlist.lock);\n\t\t\t\t\t\trl_write_locked = false;\n\t\t\t\t\t} else\n\t\t\t\t\t\tup_read(&ni->runlist.lock);\n\t\t\t\t\trl = NULL;\n\t\t\t\t}\n\t\t\t\tgoto map_buffer_cached;\n\t\t\t}\n\t\t} else\n\t\t\tlcn = LCN_RL_NOT_MAPPED;\n\t\t \n\t\tif (unlikely(lcn != LCN_HOLE && lcn != LCN_ENOENT)) {\n\t\t\tif (likely(!is_retry && lcn == LCN_RL_NOT_MAPPED)) {\n\t\t\t\t \n\t\t\t\tif (!rl_write_locked) {\n\t\t\t\t\t \n\t\t\t\t\tup_read(&ni->runlist.lock);\n\t\t\t\t\tdown_write(&ni->runlist.lock);\n\t\t\t\t\trl_write_locked = true;\n\t\t\t\t\tgoto retry_remap;\n\t\t\t\t}\n\t\t\t\terr = ntfs_map_runlist_nolock(ni, bh_cpos,\n\t\t\t\t\t\tNULL);\n\t\t\t\tif (likely(!err)) {\n\t\t\t\t\tis_retry = true;\n\t\t\t\t\tgoto retry_remap;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tif (err == -ENOENT) {\n\t\t\t\t\tlcn = LCN_ENOENT;\n\t\t\t\t\terr = 0;\n\t\t\t\t\tgoto rl_not_mapped_enoent;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\terr = -EIO;\n\t\t\t \n\t\t\tbh->b_blocknr = -1;\n\t\t\tntfs_error(vol->sb, \"Failed to write to inode 0x%lx, \"\n\t\t\t\t\t\"attribute type 0x%x, vcn 0x%llx, \"\n\t\t\t\t\t\"vcn offset 0x%x, because its \"\n\t\t\t\t\t\"location on disk could not be \"\n\t\t\t\t\t\"determined%s (error code %i).\",\n\t\t\t\t\tni->mft_no, ni->type,\n\t\t\t\t\t(unsigned long long)bh_cpos,\n\t\t\t\t\t(unsigned)bh_pos &\n\t\t\t\t\tvol->cluster_size_mask,\n\t\t\t\t\tis_retry ? \" even after retrying\" : \"\",\n\t\t\t\t\terr);\n\t\t\tbreak;\n\t\t}\nrl_not_mapped_enoent:\n\t\t \n\t\tif (unlikely(vol->cluster_size < PAGE_SIZE)) {\n\t\t\tbh_cend = (bh_end + vol->cluster_size - 1) >>\n\t\t\t\t\tvol->cluster_size_bits;\n\t\t\tif ((bh_cend <= cpos || bh_cpos >= cend)) {\n\t\t\t\tbh->b_blocknr = -1;\n\t\t\t\t \n\t\t\t\tif (PageUptodate(page)) {\n\t\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t} else if (!buffer_uptodate(bh)) {\n\t\t\t\t\tzero_user(page, bh_offset(bh),\n\t\t\t\t\t\tblocksize);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t \n\t\tBUG_ON(lcn != LCN_HOLE);\n\t\t \n\t\tBUG_ON(!rl);\n\t\tif (!rl_write_locked) {\n\t\t\tup_read(&ni->runlist.lock);\n\t\t\tdown_write(&ni->runlist.lock);\n\t\t\trl_write_locked = true;\n\t\t\tgoto retry_remap;\n\t\t}\n\t\t \n\t\tBUG_ON(rl->lcn != LCN_HOLE);\n\t\tlcn = -1;\n\t\trl2 = rl;\n\t\twhile (--rl2 >= ni->runlist.rl) {\n\t\t\tif (rl2->lcn >= 0) {\n\t\t\t\tlcn = rl2->lcn + rl2->length;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trl2 = ntfs_cluster_alloc(vol, bh_cpos, 1, lcn, DATA_ZONE,\n\t\t\t\tfalse);\n\t\tif (IS_ERR(rl2)) {\n\t\t\terr = PTR_ERR(rl2);\n\t\t\tntfs_debug(\"Failed to allocate cluster, error code %i.\",\n\t\t\t\t\terr);\n\t\t\tbreak;\n\t\t}\n\t\tlcn = rl2->lcn;\n\t\trl = ntfs_runlists_merge(ni->runlist.rl, rl2);\n\t\tif (IS_ERR(rl)) {\n\t\t\terr = PTR_ERR(rl);\n\t\t\tif (err != -ENOMEM)\n\t\t\t\terr = -EIO;\n\t\t\tif (ntfs_cluster_free_from_rl(vol, rl2)) {\n\t\t\t\tntfs_error(vol->sb, \"Failed to release \"\n\t\t\t\t\t\t\"allocated cluster in error \"\n\t\t\t\t\t\t\"code path.  Run chkdsk to \"\n\t\t\t\t\t\t\"recover the lost cluster.\");\n\t\t\t\tNVolSetErrors(vol);\n\t\t\t}\n\t\t\tntfs_free(rl2);\n\t\t\tbreak;\n\t\t}\n\t\tni->runlist.rl = rl;\n\t\tstatus.runlist_merged = 1;\n\t\tntfs_debug(\"Allocated cluster, lcn 0x%llx.\",\n\t\t\t\t(unsigned long long)lcn);\n\t\t \n\t\tif (!NInoAttr(ni))\n\t\t\tbase_ni = ni;\n\t\telse\n\t\t\tbase_ni = ni->ext.base_ntfs_ino;\n\t\tm = map_mft_record(base_ni);\n\t\tif (IS_ERR(m)) {\n\t\t\terr = PTR_ERR(m);\n\t\t\tbreak;\n\t\t}\n\t\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\t\tif (unlikely(!ctx)) {\n\t\t\terr = -ENOMEM;\n\t\t\tunmap_mft_record(base_ni);\n\t\t\tbreak;\n\t\t}\n\t\tstatus.mft_attr_mapped = 1;\n\t\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\t\tCASE_SENSITIVE, bh_cpos, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\terr = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tm = ctx->mrec;\n\t\ta = ctx->attr;\n\t\t \n\t\tvcn = sle64_to_cpu(a->data.non_resident.lowest_vcn);\n\t\trl2 = ntfs_rl_find_vcn_nolock(rl, vcn);\n\t\tBUG_ON(!rl2);\n\t\tBUG_ON(!rl2->length);\n\t\tBUG_ON(rl2->lcn < LCN_HOLE);\n\t\thighest_vcn = sle64_to_cpu(a->data.non_resident.highest_vcn);\n\t\t \n\t\tif (!highest_vcn)\n\t\t\thighest_vcn = (sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size) >>\n\t\t\t\t\tvol->cluster_size_bits) - 1;\n\t\t \n\t\tmp_size = ntfs_get_size_for_mapping_pairs(vol, rl2, vcn,\n\t\t\t\thighest_vcn);\n\t\tif (unlikely(mp_size <= 0)) {\n\t\t\tif (!(err = mp_size))\n\t\t\t\terr = -EIO;\n\t\t\tntfs_debug(\"Failed to get size for mapping pairs \"\n\t\t\t\t\t\"array, error code %i.\", err);\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tattr_rec_len = le32_to_cpu(a->length);\n\t\terr = ntfs_attr_record_resize(m, a, mp_size + le16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset));\n\t\tif (unlikely(err)) {\n\t\t\tBUG_ON(err != -ENOSPC);\n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\tntfs_error(vol->sb, \"Not enough space in the mft \"\n\t\t\t\t\t\"record for the extended attribute \"\n\t\t\t\t\t\"record.  This case is not \"\n\t\t\t\t\t\"implemented yet.\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tbreak ;\n\t\t}\n\t\tstatus.mp_rebuilt = 1;\n\t\t \n\t\terr = ntfs_mapping_pairs_build(vol, (u8*)a + le16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset),\n\t\t\t\tmp_size, rl2, vcn, highest_vcn, NULL);\n\t\tif (unlikely(err)) {\n\t\t\tntfs_error(vol->sb, \"Cannot fill hole in inode 0x%lx, \"\n\t\t\t\t\t\"attribute type 0x%x, because building \"\n\t\t\t\t\t\"the mapping pairs failed with error \"\n\t\t\t\t\t\"code %i.\", vi->i_ino,\n\t\t\t\t\t(unsigned)le32_to_cpu(ni->type), err);\n\t\t\terr = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tif (unlikely(!a->data.non_resident.highest_vcn))\n\t\t\ta->data.non_resident.highest_vcn =\n\t\t\t\t\tcpu_to_sle64(highest_vcn);\n\t\t \n\t\tif (likely(NInoSparse(ni) || NInoCompressed(ni))) {\n\t\t\t \n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\t\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t\t\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\t\t\terr = ntfs_attr_lookup(ni->type, ni->name,\n\t\t\t\t\t\tni->name_len, CASE_SENSITIVE,\n\t\t\t\t\t\t0, NULL, 0, ctx);\n\t\t\t\tif (unlikely(err)) {\n\t\t\t\t\tstatus.attr_switched = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\ta = ctx->attr;\n\t\t\t}\n\t\t\twrite_lock_irqsave(&ni->size_lock, flags);\n\t\t\tni->itype.compressed.size += vol->cluster_size;\n\t\t\ta->data.non_resident.compressed_size =\n\t\t\t\t\tcpu_to_sle64(ni->itype.compressed.size);\n\t\t\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t\t}\n\t\t \n\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(base_ni);\n\t\t \n\t\tstatus.runlist_merged = 0;\n\t\tstatus.mft_attr_mapped = 0;\n\t\tstatus.mp_rebuilt = 0;\n\t\t \n\t\twas_hole = true;\n\t\tvcn = bh_cpos;\n\t\tvcn_len = 1;\n\t\tlcn_block = lcn << (vol->cluster_size_bits - blocksize_bits);\n\t\tcdelta = 0;\n\t\t \n\t\tif (likely(vcn + vcn_len >= cend)) {\n\t\t\tup_write(&ni->runlist.lock);\n\t\t\trl_write_locked = false;\n\t\t\trl = NULL;\n\t\t}\n\t\tgoto map_buffer_cached;\n\t} while (bh_pos += blocksize, (bh = bh->b_this_page) != head);\n\t \n\tif (likely(!err && ++u < nr_pages))\n\t\tgoto do_next_page;\n\t \n\tif (likely(!err)) {\n\t\tif (unlikely(rl_write_locked)) {\n\t\t\tup_write(&ni->runlist.lock);\n\t\t\trl_write_locked = false;\n\t\t} else if (unlikely(rl))\n\t\t\tup_read(&ni->runlist.lock);\n\t\trl = NULL;\n\t}\n\t \n\tread_lock_irqsave(&ni->size_lock, flags);\n\tinitialized_size = ni->initialized_size;\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\twhile (wait_bh > wait) {\n\t\tbh = *--wait_bh;\n\t\twait_on_buffer(bh);\n\t\tif (likely(buffer_uptodate(bh))) {\n\t\t\tpage = bh->b_page;\n\t\t\tbh_pos = ((s64)page->index << PAGE_SHIFT) +\n\t\t\t\t\tbh_offset(bh);\n\t\t\t \n\t\t\tif (unlikely(bh_pos + blocksize > initialized_size)) {\n\t\t\t\tint ofs = 0;\n\n\t\t\t\tif (likely(bh_pos < initialized_size))\n\t\t\t\t\tofs = initialized_size - bh_pos;\n\t\t\t\tzero_user_segment(page, bh_offset(bh) + ofs,\n\t\t\t\t\t\tblocksize);\n\t\t\t}\n\t\t} else  \n\t\t\terr = -EIO;\n\t}\n\tif (likely(!err)) {\n\t\t \n\t\tu = 0;\n\t\tdo {\n\t\t\tbh = head = page_buffers(pages[u]);\n\t\t\tdo {\n\t\t\t\tif (buffer_new(bh))\n\t\t\t\t\tclear_buffer_new(bh);\n\t\t\t} while ((bh = bh->b_this_page) != head);\n\t\t} while (++u < nr_pages);\n\t\tntfs_debug(\"Done.\");\n\t\treturn err;\n\t}\n\tif (status.attr_switched) {\n\t\t \n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\tif (ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\t\tCASE_SENSITIVE, bh_cpos, NULL, 0, ctx)) {\n\t\t\tntfs_error(vol->sb, \"Failed to find required \"\n\t\t\t\t\t\"attribute extent of attribute in \"\n\t\t\t\t\t\"error code path.  Run chkdsk to \"\n\t\t\t\t\t\"recover.\");\n\t\t\twrite_lock_irqsave(&ni->size_lock, flags);\n\t\t\tni->itype.compressed.size += vol->cluster_size;\n\t\t\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t\t\t \n\t\t\tNVolSetErrors(vol);\n\t\t} else {\n\t\t\tm = ctx->mrec;\n\t\t\ta = ctx->attr;\n\t\t\tstatus.attr_switched = 0;\n\t\t}\n\t}\n\t \n\tif (status.runlist_merged && !status.attr_switched) {\n\t\tBUG_ON(!rl_write_locked);\n\t\t \n\t\tif (ntfs_rl_punch_nolock(vol, &ni->runlist, bh_cpos, 1)) {\n\t\t\tntfs_error(vol->sb, \"Failed to punch hole into \"\n\t\t\t\t\t\"attribute runlist in error code \"\n\t\t\t\t\t\"path.  Run chkdsk to recover the \"\n\t\t\t\t\t\"lost cluster.\");\n\t\t\tNVolSetErrors(vol);\n\t\t} else   {\n\t\t\tstatus.runlist_merged = 0;\n\t\t\t \n\t\t\tdown_write(&vol->lcnbmp_lock);\n\t\t\tif (ntfs_bitmap_clear_bit(vol->lcnbmp_ino, lcn)) {\n\t\t\t\tntfs_error(vol->sb, \"Failed to release \"\n\t\t\t\t\t\t\"allocated cluster in error \"\n\t\t\t\t\t\t\"code path.  Run chkdsk to \"\n\t\t\t\t\t\t\"recover the lost cluster.\");\n\t\t\t\tNVolSetErrors(vol);\n\t\t\t}\n\t\t\tup_write(&vol->lcnbmp_lock);\n\t\t}\n\t}\n\t \n\tif (status.mp_rebuilt && !status.runlist_merged) {\n\t\tif (ntfs_attr_record_resize(m, a, attr_rec_len)) {\n\t\t\tntfs_error(vol->sb, \"Failed to restore attribute \"\n\t\t\t\t\t\"record in error code path.  Run \"\n\t\t\t\t\t\"chkdsk to recover.\");\n\t\t\tNVolSetErrors(vol);\n\t\t} else   {\n\t\t\tif (ntfs_mapping_pairs_build(vol, (u8*)a +\n\t\t\t\t\tle16_to_cpu(a->data.non_resident.\n\t\t\t\t\tmapping_pairs_offset), attr_rec_len -\n\t\t\t\t\tle16_to_cpu(a->data.non_resident.\n\t\t\t\t\tmapping_pairs_offset), ni->runlist.rl,\n\t\t\t\t\tvcn, highest_vcn, NULL)) {\n\t\t\t\tntfs_error(vol->sb, \"Failed to restore \"\n\t\t\t\t\t\t\"mapping pairs array in error \"\n\t\t\t\t\t\t\"code path.  Run chkdsk to \"\n\t\t\t\t\t\t\"recover.\");\n\t\t\t\tNVolSetErrors(vol);\n\t\t\t}\n\t\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t\t}\n\t}\n\t \n\tif (status.mft_attr_mapped) {\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(base_ni);\n\t}\n\t \n\tif (rl_write_locked)\n\t\tup_write(&ni->runlist.lock);\n\telse if (rl)\n\t\tup_read(&ni->runlist.lock);\n\t \n\tnr_pages = u;\n\tu = 0;\n\tend = bh_cpos << vol->cluster_size_bits;\n\tdo {\n\t\tpage = pages[u];\n\t\tbh = head = page_buffers(page);\n\t\tdo {\n\t\t\tif (u == nr_pages &&\n\t\t\t\t\t((s64)page->index << PAGE_SHIFT) +\n\t\t\t\t\tbh_offset(bh) >= end)\n\t\t\t\tbreak;\n\t\t\tif (!buffer_new(bh))\n\t\t\t\tcontinue;\n\t\t\tclear_buffer_new(bh);\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tif (PageUptodate(page))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\telse {\n\t\t\t\t\tzero_user(page, bh_offset(bh),\n\t\t\t\t\t\t\tblocksize);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmark_buffer_dirty(bh);\n\t\t} while ((bh = bh->b_this_page) != head);\n\t} while (++u <= nr_pages);\n\tntfs_error(vol->sb, \"Failed.  Returning error code %i.\", err);\n\treturn err;\n}\n\nstatic inline void ntfs_flush_dcache_pages(struct page **pages,\n\t\tunsigned nr_pages)\n{\n\tBUG_ON(!nr_pages);\n\t \n\tdo {\n\t\t--nr_pages;\n\t\tflush_dcache_page(pages[nr_pages]);\n\t} while (nr_pages > 0);\n}\n\n \nstatic inline int ntfs_commit_pages_after_non_resident_write(\n\t\tstruct page **pages, const unsigned nr_pages,\n\t\ts64 pos, size_t bytes)\n{\n\ts64 end, initialized_size;\n\tstruct inode *vi;\n\tntfs_inode *ni, *base_ni;\n\tstruct buffer_head *bh, *head;\n\tntfs_attr_search_ctx *ctx;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tunsigned long flags;\n\tunsigned blocksize, u;\n\tint err;\n\n\tvi = pages[0]->mapping->host;\n\tni = NTFS_I(vi);\n\tblocksize = vi->i_sb->s_blocksize;\n\tend = pos + bytes;\n\tu = 0;\n\tdo {\n\t\ts64 bh_pos;\n\t\tstruct page *page;\n\t\tbool partial;\n\n\t\tpage = pages[u];\n\t\tbh_pos = (s64)page->index << PAGE_SHIFT;\n\t\tbh = head = page_buffers(page);\n\t\tpartial = false;\n\t\tdo {\n\t\t\ts64 bh_end;\n\n\t\t\tbh_end = bh_pos + blocksize;\n\t\t\tif (bh_end <= pos || bh_pos >= end) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tpartial = true;\n\t\t\t} else {\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t}\n\t\t} while (bh_pos += blocksize, (bh = bh->b_this_page) != head);\n\t\t \n\t\tif (!partial && !PageUptodate(page))\n\t\t\tSetPageUptodate(page);\n\t} while (++u < nr_pages);\n\t \n\tread_lock_irqsave(&ni->size_lock, flags);\n\tinitialized_size = ni->initialized_size;\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\tif (end <= initialized_size) {\n\t\tntfs_debug(\"Done.\");\n\t\treturn 0;\n\t}\n\t \n\tif (!NInoAttr(ni))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\t \n\tm = map_mft_record(base_ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\tgoto err_out;\n\t}\n\tBUG_ON(!NInoNonResident(ni));\n\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT)\n\t\t\terr = -EIO;\n\t\tgoto err_out;\n\t}\n\ta = ctx->attr;\n\tBUG_ON(!a->non_resident);\n\twrite_lock_irqsave(&ni->size_lock, flags);\n\tBUG_ON(end > ni->allocated_size);\n\tni->initialized_size = end;\n\ta->data.non_resident.initialized_size = cpu_to_sle64(end);\n\tif (end > i_size_read(vi)) {\n\t\ti_size_write(vi, end);\n\t\ta->data.non_resident.data_size =\n\t\t\t\ta->data.non_resident.initialized_size;\n\t}\n\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t \n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(base_ni);\n\tntfs_debug(\"Done.\");\n\treturn 0;\nerr_out:\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(base_ni);\n\tntfs_error(vi->i_sb, \"Failed to update initialized_size/i_size (error \"\n\t\t\t\"code %i).\", err);\n\tif (err != -ENOMEM)\n\t\tNVolSetErrors(ni->vol);\n\treturn err;\n}\n\n \nstatic int ntfs_commit_pages_after_write(struct page **pages,\n\t\tconst unsigned nr_pages, s64 pos, size_t bytes)\n{\n\ts64 end, initialized_size;\n\tloff_t i_size;\n\tstruct inode *vi;\n\tntfs_inode *ni, *base_ni;\n\tstruct page *page;\n\tntfs_attr_search_ctx *ctx;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tchar *kattr, *kaddr;\n\tunsigned long flags;\n\tu32 attr_len;\n\tint err;\n\n\tBUG_ON(!nr_pages);\n\tBUG_ON(!pages);\n\tpage = pages[0];\n\tBUG_ON(!page);\n\tvi = page->mapping->host;\n\tni = NTFS_I(vi);\n\tntfs_debug(\"Entering for inode 0x%lx, attribute type 0x%x, start page \"\n\t\t\t\"index 0x%lx, nr_pages 0x%x, pos 0x%llx, bytes 0x%zx.\",\n\t\t\tvi->i_ino, ni->type, page->index, nr_pages,\n\t\t\t(long long)pos, bytes);\n\tif (NInoNonResident(ni))\n\t\treturn ntfs_commit_pages_after_non_resident_write(pages,\n\t\t\t\tnr_pages, pos, bytes);\n\tBUG_ON(nr_pages > 1);\n\t \n\tif (!NInoAttr(ni))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tBUG_ON(NInoNonResident(ni));\n\t \n\tm = map_mft_record(base_ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT)\n\t\t\terr = -EIO;\n\t\tgoto err_out;\n\t}\n\ta = ctx->attr;\n\tBUG_ON(a->non_resident);\n\t \n\tattr_len = le32_to_cpu(a->data.resident.value_length);\n\ti_size = i_size_read(vi);\n\tBUG_ON(attr_len != i_size);\n\tBUG_ON(pos > attr_len);\n\tend = pos + bytes;\n\tBUG_ON(end > le32_to_cpu(a->length) -\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\tkattr = (u8*)a + le16_to_cpu(a->data.resident.value_offset);\n\tkaddr = kmap_atomic(page);\n\t \n\tmemcpy(kattr + pos, kaddr + pos, bytes);\n\t \n\tif (end > attr_len) {\n\t\tattr_len = end;\n\t\ta->data.resident.value_length = cpu_to_le32(attr_len);\n\t}\n\t \n\tif (!PageUptodate(page)) {\n\t\tif (pos > 0)\n\t\t\tmemcpy(kaddr, kattr, pos);\n\t\tif (end < attr_len)\n\t\t\tmemcpy(kaddr + end, kattr + end, attr_len - end);\n\t\t \n\t\tmemset(kaddr + attr_len, 0, PAGE_SIZE - attr_len);\n\t\tflush_dcache_page(page);\n\t\tSetPageUptodate(page);\n\t}\n\tkunmap_atomic(kaddr);\n\t \n\tread_lock_irqsave(&ni->size_lock, flags);\n\tinitialized_size = ni->initialized_size;\n\tBUG_ON(end > ni->allocated_size);\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\tBUG_ON(initialized_size != i_size);\n\tif (end > initialized_size) {\n\t\twrite_lock_irqsave(&ni->size_lock, flags);\n\t\tni->initialized_size = end;\n\t\ti_size_write(vi, end);\n\t\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t}\n\t \n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(base_ni);\n\tntfs_debug(\"Done.\");\n\treturn 0;\nerr_out:\n\tif (err == -ENOMEM) {\n\t\tntfs_warning(vi->i_sb, \"Error allocating memory required to \"\n\t\t\t\t\"commit the write.\");\n\t\tif (PageUptodate(page)) {\n\t\t\tntfs_warning(vi->i_sb, \"Page is uptodate, setting \"\n\t\t\t\t\t\"dirty so the write will be retried \"\n\t\t\t\t\t\"later on by the VM.\");\n\t\t\t \n\t\t\t__set_page_dirty_nobuffers(page);\n\t\t\terr = 0;\n\t\t} else\n\t\t\tntfs_error(vi->i_sb, \"Page is not uptodate.  Written \"\n\t\t\t\t\t\"data has been lost.\");\n\t} else {\n\t\tntfs_error(vi->i_sb, \"Resident attribute commit write failed \"\n\t\t\t\t\"with error %i.\", err);\n\t\tNVolSetErrors(ni->vol);\n\t}\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(base_ni);\n\treturn err;\n}\n\n \nstatic size_t ntfs_copy_from_user_iter(struct page **pages, unsigned nr_pages,\n\t\tunsigned ofs, struct iov_iter *i, size_t bytes)\n{\n\tstruct page **last_page = pages + nr_pages;\n\tsize_t total = 0;\n\tunsigned len, copied;\n\n\tdo {\n\t\tlen = PAGE_SIZE - ofs;\n\t\tif (len > bytes)\n\t\t\tlen = bytes;\n\t\tcopied = copy_page_from_iter_atomic(*pages, ofs, len, i);\n\t\ttotal += copied;\n\t\tbytes -= copied;\n\t\tif (!bytes)\n\t\t\tbreak;\n\t\tif (copied < len)\n\t\t\tgoto err;\n\t\tofs = 0;\n\t} while (++pages < last_page);\nout:\n\treturn total;\nerr:\n\t \n\tlen = PAGE_SIZE - copied;\n\tdo {\n\t\tif (len > bytes)\n\t\t\tlen = bytes;\n\t\tzero_user(*pages, copied, len);\n\t\tbytes -= len;\n\t\tcopied = 0;\n\t\tlen = PAGE_SIZE;\n\t} while (++pages < last_page);\n\tgoto out;\n}\n\n \nstatic ssize_t ntfs_perform_write(struct file *file, struct iov_iter *i,\n\t\tloff_t pos)\n{\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct inode *vi = mapping->host;\n\tntfs_inode *ni = NTFS_I(vi);\n\tntfs_volume *vol = ni->vol;\n\tstruct page *pages[NTFS_MAX_PAGES_PER_CLUSTER];\n\tstruct page *cached_page = NULL;\n\tVCN last_vcn;\n\tLCN lcn;\n\tsize_t bytes;\n\tssize_t status, written = 0;\n\tunsigned nr_pages;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx, attribute type 0x%x, pos \"\n\t\t\t\"0x%llx, count 0x%lx.\", vi->i_ino,\n\t\t\t(unsigned)le32_to_cpu(ni->type),\n\t\t\t(unsigned long long)pos,\n\t\t\t(unsigned long)iov_iter_count(i));\n\t \n\tif (unlikely(NInoTruncateFailed(ni))) {\n\t\tint err;\n\n\t\tinode_dio_wait(vi);\n\t\terr = ntfs_truncate(vi);\n\t\tif (err || NInoTruncateFailed(ni)) {\n\t\t\tif (!err)\n\t\t\t\terr = -EIO;\n\t\t\tntfs_error(vol->sb, \"Cannot perform write to inode \"\n\t\t\t\t\t\"0x%lx, attribute type 0x%x, because \"\n\t\t\t\t\t\"ntfs_truncate() failed (error code \"\n\t\t\t\t\t\"%i).\", vi->i_ino,\n\t\t\t\t\t(unsigned)le32_to_cpu(ni->type), err);\n\t\t\treturn err;\n\t\t}\n\t}\n\t \n\tnr_pages = 1;\n\tif (vol->cluster_size > PAGE_SIZE && NInoNonResident(ni))\n\t\tnr_pages = vol->cluster_size >> PAGE_SHIFT;\n\tlast_vcn = -1;\n\tdo {\n\t\tVCN vcn;\n\t\tpgoff_t start_idx;\n\t\tunsigned ofs, do_pages, u;\n\t\tsize_t copied;\n\n\t\tstart_idx = pos >> PAGE_SHIFT;\n\t\tofs = pos & ~PAGE_MASK;\n\t\tbytes = PAGE_SIZE - ofs;\n\t\tdo_pages = 1;\n\t\tif (nr_pages > 1) {\n\t\t\tvcn = pos >> vol->cluster_size_bits;\n\t\t\tif (vcn != last_vcn) {\n\t\t\t\tlast_vcn = vcn;\n\t\t\t\t \n\t\t\t\tdown_read(&ni->runlist.lock);\n\t\t\t\tlcn = ntfs_attr_vcn_to_lcn_nolock(ni, pos >>\n\t\t\t\t\t\tvol->cluster_size_bits, false);\n\t\t\t\tup_read(&ni->runlist.lock);\n\t\t\t\tif (unlikely(lcn < LCN_HOLE)) {\n\t\t\t\t\tif (lcn == LCN_ENOMEM)\n\t\t\t\t\t\tstatus = -ENOMEM;\n\t\t\t\t\telse {\n\t\t\t\t\t\tstatus = -EIO;\n\t\t\t\t\t\tntfs_error(vol->sb, \"Cannot \"\n\t\t\t\t\t\t\t\"perform write to \"\n\t\t\t\t\t\t\t\"inode 0x%lx, \"\n\t\t\t\t\t\t\t\"attribute type 0x%x, \"\n\t\t\t\t\t\t\t\"because the attribute \"\n\t\t\t\t\t\t\t\"is corrupt.\",\n\t\t\t\t\t\t\tvi->i_ino, (unsigned)\n\t\t\t\t\t\t\tle32_to_cpu(ni->type));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (lcn == LCN_HOLE) {\n\t\t\t\t\tstart_idx = (pos & ~(s64)\n\t\t\t\t\t\t\tvol->cluster_size_mask)\n\t\t\t\t\t\t\t>> PAGE_SHIFT;\n\t\t\t\t\tbytes = vol->cluster_size - (pos &\n\t\t\t\t\t\t\tvol->cluster_size_mask);\n\t\t\t\t\tdo_pages = nr_pages;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (bytes > iov_iter_count(i))\n\t\t\tbytes = iov_iter_count(i);\nagain:\n\t\t \n\t\tif (unlikely(fault_in_iov_iter_readable(i, bytes))) {\n\t\t\tstatus = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tstatus = __ntfs_grab_cache_pages(mapping, start_idx, do_pages,\n\t\t\t\tpages, &cached_page);\n\t\tif (unlikely(status))\n\t\t\tbreak;\n\t\t \n\t\tif (NInoNonResident(ni)) {\n\t\t\tstatus = ntfs_prepare_pages_for_non_resident_write(\n\t\t\t\t\tpages, do_pages, pos, bytes);\n\t\t\tif (unlikely(status)) {\n\t\t\t\tdo {\n\t\t\t\t\tunlock_page(pages[--do_pages]);\n\t\t\t\t\tput_page(pages[do_pages]);\n\t\t\t\t} while (do_pages);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tu = (pos >> PAGE_SHIFT) - pages[0]->index;\n\t\tcopied = ntfs_copy_from_user_iter(pages + u, do_pages - u, ofs,\n\t\t\t\t\ti, bytes);\n\t\tntfs_flush_dcache_pages(pages + u, do_pages - u);\n\t\tstatus = 0;\n\t\tif (likely(copied == bytes)) {\n\t\t\tstatus = ntfs_commit_pages_after_write(pages, do_pages,\n\t\t\t\t\tpos, bytes);\n\t\t}\n\t\tdo {\n\t\t\tunlock_page(pages[--do_pages]);\n\t\t\tput_page(pages[do_pages]);\n\t\t} while (do_pages);\n\t\tif (unlikely(status < 0)) {\n\t\t\tiov_iter_revert(i, copied);\n\t\t\tbreak;\n\t\t}\n\t\tcond_resched();\n\t\tif (unlikely(copied < bytes)) {\n\t\t\tiov_iter_revert(i, copied);\n\t\t\tif (copied)\n\t\t\t\tbytes = copied;\n\t\t\telse if (bytes > PAGE_SIZE - ofs)\n\t\t\t\tbytes = PAGE_SIZE - ofs;\n\t\t\tgoto again;\n\t\t}\n\t\tpos += copied;\n\t\twritten += copied;\n\t\tbalance_dirty_pages_ratelimited(mapping);\n\t\tif (fatal_signal_pending(current)) {\n\t\t\tstatus = -EINTR;\n\t\t\tbreak;\n\t\t}\n\t} while (iov_iter_count(i));\n\tif (cached_page)\n\t\tput_page(cached_page);\n\tntfs_debug(\"Done.  Returning %s (written 0x%lx, status %li).\",\n\t\t\twritten ? \"written\" : \"status\", (unsigned long)written,\n\t\t\t(long)status);\n\treturn written ? written : status;\n}\n\n \nstatic ssize_t ntfs_file_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *vi = file_inode(file);\n\tssize_t written = 0;\n\tssize_t err;\n\n\tinode_lock(vi);\n\t \n\terr = ntfs_prepare_file_for_write(iocb, from);\n\tif (iov_iter_count(from) && !err)\n\t\twritten = ntfs_perform_write(file, from, iocb->ki_pos);\n\tinode_unlock(vi);\n\tiocb->ki_pos += written;\n\tif (likely(written > 0))\n\t\twritten = generic_write_sync(iocb, written);\n\treturn written ? written : err;\n}\n\n \nstatic int ntfs_file_fsync(struct file *filp, loff_t start, loff_t end,\n\t\t\t   int datasync)\n{\n\tstruct inode *vi = filp->f_mapping->host;\n\tint err, ret = 0;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", vi->i_ino);\n\n\terr = file_write_and_wait_range(filp, start, end);\n\tif (err)\n\t\treturn err;\n\tinode_lock(vi);\n\n\tBUG_ON(S_ISDIR(vi->i_mode));\n\tif (!datasync || !NInoNonResident(NTFS_I(vi)))\n\t\tret = __ntfs_write_inode(vi, 1);\n\twrite_inode_now(vi, !datasync);\n\t \n\terr = sync_blockdev(vi->i_sb->s_bdev);\n\tif (unlikely(err && !ret))\n\t\tret = err;\n\tif (likely(!ret))\n\t\tntfs_debug(\"Done.\");\n\telse\n\t\tntfs_warning(vi->i_sb, \"Failed to f%ssync inode 0x%lx.  Error \"\n\t\t\t\t\"%u.\", datasync ? \"data\" : \"\", vi->i_ino, -ret);\n\tinode_unlock(vi);\n\treturn ret;\n}\n\n#endif  \n\nconst struct file_operations ntfs_file_ops = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read_iter\t= generic_file_read_iter,\n#ifdef NTFS_RW\n\t.write_iter\t= ntfs_file_write_iter,\n\t.fsync\t\t= ntfs_file_fsync,\n#endif  \n\t.mmap\t\t= generic_file_mmap,\n\t.open\t\t= ntfs_file_open,\n\t.splice_read\t= filemap_splice_read,\n};\n\nconst struct inode_operations ntfs_file_inode_ops = {\n#ifdef NTFS_RW\n\t.setattr\t= ntfs_setattr,\n#endif  \n};\n\nconst struct file_operations ntfs_empty_file_ops = {};\n\nconst struct inode_operations ntfs_empty_inode_ops = {};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}