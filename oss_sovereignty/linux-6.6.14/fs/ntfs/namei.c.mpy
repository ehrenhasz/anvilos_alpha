{
  "module_name": "namei.c",
  "hash_id": "9f63109175599e9f5b0e261fef0997e1f66865a302000d056315c3753d41443d",
  "original_prompt": "Ingested from linux-6.6.14/fs/ntfs/namei.c",
  "human_readable_source": "\n \n\n#include <linux/dcache.h>\n#include <linux/exportfs.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n\n#include \"attrib.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"mft.h\"\n#include \"ntfs.h\"\n\n \nstatic struct dentry *ntfs_lookup(struct inode *dir_ino, struct dentry *dent,\n\t\tunsigned int flags)\n{\n\tntfs_volume *vol = NTFS_SB(dir_ino->i_sb);\n\tstruct inode *dent_inode;\n\tntfschar *uname;\n\tntfs_name *name = NULL;\n\tMFT_REF mref;\n\tunsigned long dent_ino;\n\tint uname_len;\n\n\tntfs_debug(\"Looking up %pd in directory inode 0x%lx.\",\n\t\t\tdent, dir_ino->i_ino);\n\t \n\tuname_len = ntfs_nlstoucs(vol, dent->d_name.name, dent->d_name.len,\n\t\t\t&uname);\n\tif (uname_len < 0) {\n\t\tif (uname_len != -ENAMETOOLONG)\n\t\t\tntfs_error(vol->sb, \"Failed to convert name to \"\n\t\t\t\t\t\"Unicode.\");\n\t\treturn ERR_PTR(uname_len);\n\t}\n\tmref = ntfs_lookup_inode_by_name(NTFS_I(dir_ino), uname, uname_len,\n\t\t\t&name);\n\tkmem_cache_free(ntfs_name_cache, uname);\n\tif (!IS_ERR_MREF(mref)) {\n\t\tdent_ino = MREF(mref);\n\t\tntfs_debug(\"Found inode 0x%lx. Calling ntfs_iget.\", dent_ino);\n\t\tdent_inode = ntfs_iget(vol->sb, dent_ino);\n\t\tif (!IS_ERR(dent_inode)) {\n\t\t\t \n\t\t\tif (is_bad_inode(dent_inode) || MSEQNO(mref) ==\n\t\t\t\t\tNTFS_I(dent_inode)->seq_no ||\n\t\t\t\t\tdent_ino == FILE_MFT) {\n\t\t\t\t \n\t\t\t\tif (!name) {\n\t\t\t\t\tntfs_debug(\"Done.  (Case 1.)\");\n\t\t\t\t\treturn d_splice_alias(dent_inode, dent);\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tgoto handle_name;\n\t\t\t}\n\t\t\tntfs_error(vol->sb, \"Found stale reference to inode \"\n\t\t\t\t\t\"0x%lx (reference sequence number = \"\n\t\t\t\t\t\"0x%x, inode sequence number = 0x%x), \"\n\t\t\t\t\t\"returning -EIO. Run chkdsk.\",\n\t\t\t\t\tdent_ino, MSEQNO(mref),\n\t\t\t\t\tNTFS_I(dent_inode)->seq_no);\n\t\t\tiput(dent_inode);\n\t\t\tdent_inode = ERR_PTR(-EIO);\n\t\t} else\n\t\t\tntfs_error(vol->sb, \"ntfs_iget(0x%lx) failed with \"\n\t\t\t\t\t\"error code %li.\", dent_ino,\n\t\t\t\t\tPTR_ERR(dent_inode));\n\t\tkfree(name);\n\t\t \n\t\treturn ERR_CAST(dent_inode);\n\t}\n\t \n\tif (MREF_ERR(mref) == -ENOENT) {\n\t\tntfs_debug(\"Entry was not found, adding negative dentry.\");\n\t\t \n\t\td_add(dent, NULL);\n\t\tntfs_debug(\"Done.\");\n\t\treturn NULL;\n\t}\n\tntfs_error(vol->sb, \"ntfs_lookup_ino_by_name() failed with error \"\n\t\t\t\"code %i.\", -MREF_ERR(mref));\n\treturn ERR_PTR(MREF_ERR(mref));\n\t\nhandle_name:\n   {\n\tMFT_RECORD *m;\n\tntfs_attr_search_ctx *ctx;\n\tntfs_inode *ni = NTFS_I(dent_inode);\n\tint err;\n\tstruct qstr nls_name;\n\n\tnls_name.name = NULL;\n\tif (name->type != FILE_NAME_DOS) {\t\t\t \n\t\tntfs_debug(\"Case 2.\");\n\t\tnls_name.len = (unsigned)ntfs_ucstonls(vol,\n\t\t\t\t(ntfschar*)&name->name, name->len,\n\t\t\t\t(unsigned char**)&nls_name.name, 0);\n\t\tkfree(name);\n\t} else   {\t\t \n\t\tFILE_NAME_ATTR *fn;\n\n\t\tntfs_debug(\"Case 3.\");\n\t\tkfree(name);\n\n\t\t \n\t\tni = NTFS_I(dent_inode);\n\t\tm = map_mft_record(ni);\n\t\tif (IS_ERR(m)) {\n\t\t\terr = PTR_ERR(m);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto err_out;\n\t\t}\n\t\tctx = ntfs_attr_get_search_ctx(ni, m);\n\t\tif (unlikely(!ctx)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_out;\n\t\t}\n\t\tdo {\n\t\t\tATTR_RECORD *a;\n\t\t\tu32 val_len;\n\n\t\t\terr = ntfs_attr_lookup(AT_FILE_NAME, NULL, 0, 0, 0,\n\t\t\t\t\tNULL, 0, ctx);\n\t\t\tif (unlikely(err)) {\n\t\t\t\tntfs_error(vol->sb, \"Inode corrupt: No WIN32 \"\n\t\t\t\t\t\t\"namespace counterpart to DOS \"\n\t\t\t\t\t\t\"file name. Run chkdsk.\");\n\t\t\t\tif (err == -ENOENT)\n\t\t\t\t\terr = -EIO;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\t \n\t\t\ta = ctx->attr;\n\t\t\tif (a->non_resident || a->flags)\n\t\t\t\tgoto eio_err_out;\n\t\t\tval_len = le32_to_cpu(a->data.resident.value_length);\n\t\t\tif (le16_to_cpu(a->data.resident.value_offset) +\n\t\t\t\t\tval_len > le32_to_cpu(a->length))\n\t\t\t\tgoto eio_err_out;\n\t\t\tfn = (FILE_NAME_ATTR*)((u8*)ctx->attr + le16_to_cpu(\n\t\t\t\t\tctx->attr->data.resident.value_offset));\n\t\t\tif ((u32)(fn->file_name_length * sizeof(ntfschar) +\n\t\t\t\t\tsizeof(FILE_NAME_ATTR)) > val_len)\n\t\t\t\tgoto eio_err_out;\n\t\t} while (fn->file_name_type != FILE_NAME_WIN32);\n\n\t\t \n\t\tnls_name.len = (unsigned)ntfs_ucstonls(vol,\n\t\t\t\t(ntfschar*)&fn->file_name, fn->file_name_length,\n\t\t\t\t(unsigned char**)&nls_name.name, 0);\n\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t}\n\tm = NULL;\n\tctx = NULL;\n\n\t \n\tif ((signed)nls_name.len < 0) {\n\t\terr = (signed)nls_name.len;\n\t\tgoto err_out;\n\t}\n\tnls_name.hash = full_name_hash(dent, nls_name.name, nls_name.len);\n\n\tdent = d_add_ci(dent, dent_inode, &nls_name);\n\tkfree(nls_name.name);\n\treturn dent;\n\neio_err_out:\n\tntfs_error(vol->sb, \"Illegal file name attribute. Run chkdsk.\");\n\terr = -EIO;\nerr_out:\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\n\tiput(dent_inode);\n\tntfs_error(vol->sb, \"Failed, returning error code %i.\", err);\n\treturn ERR_PTR(err);\n   }\n}\n\n \nconst struct inode_operations ntfs_dir_inode_ops = {\n\t.lookup\t= ntfs_lookup,\t \n};\n\n \nstatic struct dentry *ntfs_get_parent(struct dentry *child_dent)\n{\n\tstruct inode *vi = d_inode(child_dent);\n\tntfs_inode *ni = NTFS_I(vi);\n\tMFT_RECORD *mrec;\n\tntfs_attr_search_ctx *ctx;\n\tATTR_RECORD *attr;\n\tFILE_NAME_ATTR *fn;\n\tunsigned long parent_ino;\n\tint err;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", vi->i_ino);\n\t \n\tmrec = map_mft_record(ni);\n\tif (IS_ERR(mrec))\n\t\treturn ERR_CAST(mrec);\n\t \n\tctx = ntfs_attr_get_search_ctx(ni, mrec);\n\tif (unlikely(!ctx)) {\n\t\tunmap_mft_record(ni);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\ntry_next:\n\terr = ntfs_attr_lookup(AT_FILE_NAME, NULL, 0, CASE_SENSITIVE, 0, NULL,\n\t\t\t0, ctx);\n\tif (unlikely(err)) {\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tif (err == -ENOENT)\n\t\t\tntfs_error(vi->i_sb, \"Inode 0x%lx does not have a \"\n\t\t\t\t\t\"file name attribute.  Run chkdsk.\",\n\t\t\t\t\tvi->i_ino);\n\t\treturn ERR_PTR(err);\n\t}\n\tattr = ctx->attr;\n\tif (unlikely(attr->non_resident))\n\t\tgoto try_next;\n\tfn = (FILE_NAME_ATTR *)((u8 *)attr +\n\t\t\tle16_to_cpu(attr->data.resident.value_offset));\n\tif (unlikely((u8 *)fn + le32_to_cpu(attr->data.resident.value_length) >\n\t\t\t(u8*)attr + le32_to_cpu(attr->length)))\n\t\tgoto try_next;\n\t \n\tparent_ino = MREF_LE(fn->parent_directory);\n\t \n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(ni);\n\n\treturn d_obtain_alias(ntfs_iget(vi->i_sb, parent_ino));\n}\n\nstatic struct inode *ntfs_nfs_get_inode(struct super_block *sb,\n\t\tu64 ino, u32 generation)\n{\n\tstruct inode *inode;\n\n\tinode = ntfs_iget(sb, ino);\n\tif (!IS_ERR(inode)) {\n\t\tif (is_bad_inode(inode) || inode->i_generation != generation) {\n\t\t\tiput(inode);\n\t\t\tinode = ERR_PTR(-ESTALE);\n\t\t}\n\t}\n\n\treturn inode;\n}\n\nstatic struct dentry *ntfs_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type)\n{\n\treturn generic_fh_to_dentry(sb, fid, fh_len, fh_type,\n\t\t\t\t    ntfs_nfs_get_inode);\n}\n\nstatic struct dentry *ntfs_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type)\n{\n\treturn generic_fh_to_parent(sb, fid, fh_len, fh_type,\n\t\t\t\t    ntfs_nfs_get_inode);\n}\n\n \nconst struct export_operations ntfs_export_ops = {\n\t.get_parent\t= ntfs_get_parent,\t \n\t.fh_to_dentry\t= ntfs_fh_to_dentry,\n\t.fh_to_parent\t= ntfs_fh_to_parent,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}