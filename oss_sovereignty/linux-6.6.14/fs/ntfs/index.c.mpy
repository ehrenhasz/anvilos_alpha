{
  "module_name": "index.c",
  "hash_id": "bf5f9e3240eb74927f1e97a666f67a268aa53690ec5560733e7620961f05cd2b",
  "original_prompt": "Ingested from linux-6.6.14/fs/ntfs/index.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n\n#include \"aops.h\"\n#include \"collate.h\"\n#include \"debug.h\"\n#include \"index.h\"\n#include \"ntfs.h\"\n\n \nntfs_index_context *ntfs_index_ctx_get(ntfs_inode *idx_ni)\n{\n\tntfs_index_context *ictx;\n\n\tictx = kmem_cache_alloc(ntfs_index_ctx_cache, GFP_NOFS);\n\tif (ictx)\n\t\t*ictx = (ntfs_index_context){ .idx_ni = idx_ni };\n\treturn ictx;\n}\n\n \nvoid ntfs_index_ctx_put(ntfs_index_context *ictx)\n{\n\tif (ictx->entry) {\n\t\tif (ictx->is_in_root) {\n\t\t\tif (ictx->actx)\n\t\t\t\tntfs_attr_put_search_ctx(ictx->actx);\n\t\t\tif (ictx->base_ni)\n\t\t\t\tunmap_mft_record(ictx->base_ni);\n\t\t} else {\n\t\t\tstruct page *page = ictx->page;\n\t\t\tif (page) {\n\t\t\t\tBUG_ON(!PageLocked(page));\n\t\t\t\tunlock_page(page);\n\t\t\t\tntfs_unmap_page(page);\n\t\t\t}\n\t\t}\n\t}\n\tkmem_cache_free(ntfs_index_ctx_cache, ictx);\n\treturn;\n}\n\n \nint ntfs_index_lookup(const void *key, const int key_len,\n\t\tntfs_index_context *ictx)\n{\n\tVCN vcn, old_vcn;\n\tntfs_inode *idx_ni = ictx->idx_ni;\n\tntfs_volume *vol = idx_ni->vol;\n\tstruct super_block *sb = vol->sb;\n\tntfs_inode *base_ni = idx_ni->ext.base_ntfs_ino;\n\tMFT_RECORD *m;\n\tINDEX_ROOT *ir;\n\tINDEX_ENTRY *ie;\n\tINDEX_ALLOCATION *ia;\n\tu8 *index_end, *kaddr;\n\tntfs_attr_search_ctx *actx;\n\tstruct address_space *ia_mapping;\n\tstruct page *page;\n\tint rc, err = 0;\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(!NInoAttr(idx_ni));\n\tBUG_ON(idx_ni->type != AT_INDEX_ALLOCATION);\n\tBUG_ON(idx_ni->nr_extents != -1);\n\tBUG_ON(!base_ni);\n\tBUG_ON(!key);\n\tBUG_ON(key_len <= 0);\n\tif (!ntfs_is_collation_rule_supported(\n\t\t\tidx_ni->itype.index.collation_rule)) {\n\t\tntfs_error(sb, \"Index uses unsupported collation rule 0x%x.  \"\n\t\t\t\t\"Aborting lookup.\", le32_to_cpu(\n\t\t\t\tidx_ni->itype.index.collation_rule));\n\t\treturn -EOPNOTSUPP;\n\t}\n\t \n\tm = map_mft_record(base_ni);\n\tif (IS_ERR(m)) {\n\t\tntfs_error(sb, \"map_mft_record() failed with error code %ld.\",\n\t\t\t\t-PTR_ERR(m));\n\t\treturn PTR_ERR(m);\n\t}\n\tactx = ntfs_attr_get_search_ctx(base_ni, m);\n\tif (unlikely(!actx)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\t \n\terr = ntfs_attr_lookup(AT_INDEX_ROOT, idx_ni->name, idx_ni->name_len,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, actx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\tntfs_error(sb, \"Index root attribute missing in inode \"\n\t\t\t\t\t\"0x%lx.\", idx_ni->mft_no);\n\t\t\terr = -EIO;\n\t\t}\n\t\tgoto err_out;\n\t}\n\t \n\tir = (INDEX_ROOT*)((u8*)actx->attr +\n\t\t\tle16_to_cpu(actx->attr->data.resident.value_offset));\n\tindex_end = (u8*)&ir->index + le32_to_cpu(ir->index.index_length);\n\t \n\tie = (INDEX_ENTRY*)((u8*)&ir->index +\n\t\t\tle32_to_cpu(ir->index.entries_offset));\n\t \n\tfor (;; ie = (INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie->length))) {\n\t\t \n\t\tif ((u8*)ie < (u8*)actx->mrec || (u8*)ie +\n\t\t\t\tsizeof(INDEX_ENTRY_HEADER) > index_end ||\n\t\t\t\t(u8*)ie + le16_to_cpu(ie->length) > index_end)\n\t\t\tgoto idx_err_out;\n\t\t \n\t\tif (ie->flags & INDEX_ENTRY_END)\n\t\t\tbreak;\n\t\t \n\t\tif ((u32)sizeof(INDEX_ENTRY_HEADER) +\n\t\t\t\tle16_to_cpu(ie->key_length) >\n\t\t\t\tle16_to_cpu(ie->data.vi.data_offset) ||\n\t\t\t\t(u32)le16_to_cpu(ie->data.vi.data_offset) +\n\t\t\t\tle16_to_cpu(ie->data.vi.data_length) >\n\t\t\t\tle16_to_cpu(ie->length))\n\t\t\tgoto idx_err_out;\n\t\t \n\t\tif ((key_len == le16_to_cpu(ie->key_length)) && !memcmp(key,\n\t\t\t\t&ie->key, key_len)) {\nir_done:\n\t\t\tictx->is_in_root = true;\n\t\t\tictx->ir = ir;\n\t\t\tictx->actx = actx;\n\t\t\tictx->base_ni = base_ni;\n\t\t\tictx->ia = NULL;\n\t\t\tictx->page = NULL;\ndone:\n\t\t\tictx->entry = ie;\n\t\t\tictx->data = (u8*)ie +\n\t\t\t\t\tle16_to_cpu(ie->data.vi.data_offset);\n\t\t\tictx->data_len = le16_to_cpu(ie->data.vi.data_length);\n\t\t\tntfs_debug(\"Done.\");\n\t\t\treturn err;\n\t\t}\n\t\t \n\t\trc = ntfs_collate(vol, idx_ni->itype.index.collation_rule, key,\n\t\t\t\tkey_len, &ie->key, le16_to_cpu(ie->key_length));\n\t\t \n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\t \n\t\tif (!rc)\n\t\t\tgoto ir_done;\n\t\t \n\t}\n\t \n\tif (!(ie->flags & INDEX_ENTRY_NODE)) {\n\t\tntfs_debug(\"Entry not found.\");\n\t\terr = -ENOENT;\n\t\tgoto ir_done;\n\t}  \n\t \n\tif (!NInoIndexAllocPresent(idx_ni)) {\n\t\tntfs_error(sb, \"No index allocation attribute but index entry \"\n\t\t\t\t\"requires one.  Inode 0x%lx is corrupt or \"\n\t\t\t\t\"driver bug.\", idx_ni->mft_no);\n\t\tgoto err_out;\n\t}\n\t \n\tvcn = sle64_to_cpup((sle64*)((u8*)ie + le16_to_cpu(ie->length) - 8));\n\tia_mapping = VFS_I(idx_ni)->i_mapping;\n\t \n\tntfs_attr_put_search_ctx(actx);\n\tunmap_mft_record(base_ni);\n\tm = NULL;\n\tactx = NULL;\ndescend_into_child_node:\n\t \n\tpage = ntfs_map_page(ia_mapping, vcn <<\n\t\t\tidx_ni->itype.index.vcn_size_bits >> PAGE_SHIFT);\n\tif (IS_ERR(page)) {\n\t\tntfs_error(sb, \"Failed to map index page, error %ld.\",\n\t\t\t\t-PTR_ERR(page));\n\t\terr = PTR_ERR(page);\n\t\tgoto err_out;\n\t}\n\tlock_page(page);\n\tkaddr = (u8*)page_address(page);\nfast_descend_into_child_node:\n\t \n\tia = (INDEX_ALLOCATION*)(kaddr + ((vcn <<\n\t\t\tidx_ni->itype.index.vcn_size_bits) & ~PAGE_MASK));\n\t \n\tif ((u8*)ia < kaddr || (u8*)ia > kaddr + PAGE_SIZE) {\n\t\tntfs_error(sb, \"Out of bounds check failed.  Corrupt inode \"\n\t\t\t\t\"0x%lx or driver bug.\", idx_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\t \n\tif (unlikely(!ntfs_is_indx_record(ia->magic))) {\n\t\tntfs_error(sb, \"Index record with vcn 0x%llx is corrupt.  \"\n\t\t\t\t\"Corrupt inode 0x%lx.  Run chkdsk.\",\n\t\t\t\t(long long)vcn, idx_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\tif (sle64_to_cpu(ia->index_block_vcn) != vcn) {\n\t\tntfs_error(sb, \"Actual VCN (0x%llx) of index buffer is \"\n\t\t\t\t\"different from expected VCN (0x%llx).  Inode \"\n\t\t\t\t\"0x%lx is corrupt or driver bug.\",\n\t\t\t\t(unsigned long long)\n\t\t\t\tsle64_to_cpu(ia->index_block_vcn),\n\t\t\t\t(unsigned long long)vcn, idx_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\tif (le32_to_cpu(ia->index.allocated_size) + 0x18 !=\n\t\t\tidx_ni->itype.index.block_size) {\n\t\tntfs_error(sb, \"Index buffer (VCN 0x%llx) of inode 0x%lx has \"\n\t\t\t\t\"a size (%u) differing from the index \"\n\t\t\t\t\"specified size (%u).  Inode is corrupt or \"\n\t\t\t\t\"driver bug.\", (unsigned long long)vcn,\n\t\t\t\tidx_ni->mft_no,\n\t\t\t\tle32_to_cpu(ia->index.allocated_size) + 0x18,\n\t\t\t\tidx_ni->itype.index.block_size);\n\t\tgoto unm_err_out;\n\t}\n\tindex_end = (u8*)ia + idx_ni->itype.index.block_size;\n\tif (index_end > kaddr + PAGE_SIZE) {\n\t\tntfs_error(sb, \"Index buffer (VCN 0x%llx) of inode 0x%lx \"\n\t\t\t\t\"crosses page boundary.  Impossible!  Cannot \"\n\t\t\t\t\"access!  This is probably a bug in the \"\n\t\t\t\t\"driver.\", (unsigned long long)vcn,\n\t\t\t\tidx_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\tindex_end = (u8*)&ia->index + le32_to_cpu(ia->index.index_length);\n\tif (index_end > (u8*)ia + idx_ni->itype.index.block_size) {\n\t\tntfs_error(sb, \"Size of index buffer (VCN 0x%llx) of inode \"\n\t\t\t\t\"0x%lx exceeds maximum size.\",\n\t\t\t\t(unsigned long long)vcn, idx_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\t \n\tie = (INDEX_ENTRY*)((u8*)&ia->index +\n\t\t\tle32_to_cpu(ia->index.entries_offset));\n\t \n\tfor (;; ie = (INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie->length))) {\n\t\t \n\t\tif ((u8*)ie < (u8*)ia || (u8*)ie +\n\t\t\t\tsizeof(INDEX_ENTRY_HEADER) > index_end ||\n\t\t\t\t(u8*)ie + le16_to_cpu(ie->length) > index_end) {\n\t\t\tntfs_error(sb, \"Index entry out of bounds in inode \"\n\t\t\t\t\t\"0x%lx.\", idx_ni->mft_no);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t \n\t\tif (ie->flags & INDEX_ENTRY_END)\n\t\t\tbreak;\n\t\t \n\t\tif ((u32)sizeof(INDEX_ENTRY_HEADER) +\n\t\t\t\tle16_to_cpu(ie->key_length) >\n\t\t\t\tle16_to_cpu(ie->data.vi.data_offset) ||\n\t\t\t\t(u32)le16_to_cpu(ie->data.vi.data_offset) +\n\t\t\t\tle16_to_cpu(ie->data.vi.data_length) >\n\t\t\t\tle16_to_cpu(ie->length)) {\n\t\t\tntfs_error(sb, \"Index entry out of bounds in inode \"\n\t\t\t\t\t\"0x%lx.\", idx_ni->mft_no);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t \n\t\tif ((key_len == le16_to_cpu(ie->key_length)) && !memcmp(key,\n\t\t\t\t&ie->key, key_len)) {\nia_done:\n\t\t\tictx->is_in_root = false;\n\t\t\tictx->actx = NULL;\n\t\t\tictx->base_ni = NULL;\n\t\t\tictx->ia = ia;\n\t\t\tictx->page = page;\n\t\t\tgoto done;\n\t\t}\n\t\t \n\t\trc = ntfs_collate(vol, idx_ni->itype.index.collation_rule, key,\n\t\t\t\tkey_len, &ie->key, le16_to_cpu(ie->key_length));\n\t\t \n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\t \n\t\tif (!rc)\n\t\t\tgoto ia_done;\n\t\t \n\t}\n\t \n\tif (!(ie->flags & INDEX_ENTRY_NODE)) {\n\t\tntfs_debug(\"Entry not found.\");\n\t\terr = -ENOENT;\n\t\tgoto ia_done;\n\t}\n\tif ((ia->index.flags & NODE_MASK) == LEAF_NODE) {\n\t\tntfs_error(sb, \"Index entry with child node found in a leaf \"\n\t\t\t\t\"node in inode 0x%lx.\", idx_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\t \n\told_vcn = vcn;\n\tvcn = sle64_to_cpup((sle64*)((u8*)ie + le16_to_cpu(ie->length) - 8));\n\tif (vcn >= 0) {\n\t\t \n\t\tif (old_vcn << vol->cluster_size_bits >>\n\t\t\t\tPAGE_SHIFT == vcn <<\n\t\t\t\tvol->cluster_size_bits >>\n\t\t\t\tPAGE_SHIFT)\n\t\t\tgoto fast_descend_into_child_node;\n\t\tunlock_page(page);\n\t\tntfs_unmap_page(page);\n\t\tgoto descend_into_child_node;\n\t}\n\tntfs_error(sb, \"Negative child node vcn in inode 0x%lx.\",\n\t\t\tidx_ni->mft_no);\nunm_err_out:\n\tunlock_page(page);\n\tntfs_unmap_page(page);\nerr_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (actx)\n\t\tntfs_attr_put_search_ctx(actx);\n\tif (m)\n\t\tunmap_mft_record(base_ni);\n\treturn err;\nidx_err_out:\n\tntfs_error(sb, \"Corrupt index.  Aborting lookup.\");\n\tgoto err_out;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}