{
  "module_name": "aops.c",
  "hash_id": "f8c9261a96a3f87a38f89db769c2ce8f487fd4ef7338831f11058defbf4afe88",
  "original_prompt": "Ingested from linux-6.6.14/fs/ntfs/aops.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/bit_spinlock.h>\n#include <linux/bio.h>\n\n#include \"aops.h\"\n#include \"attrib.h\"\n#include \"debug.h\"\n#include \"inode.h\"\n#include \"mft.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"ntfs.h\"\n\n \nstatic void ntfs_end_buffer_async_read(struct buffer_head *bh, int uptodate)\n{\n\tunsigned long flags;\n\tstruct buffer_head *first, *tmp;\n\tstruct page *page;\n\tstruct inode *vi;\n\tntfs_inode *ni;\n\tint page_uptodate = 1;\n\n\tpage = bh->b_page;\n\tvi = page->mapping->host;\n\tni = NTFS_I(vi);\n\n\tif (likely(uptodate)) {\n\t\tloff_t i_size;\n\t\ts64 file_ofs, init_size;\n\n\t\tset_buffer_uptodate(bh);\n\n\t\tfile_ofs = ((s64)page->index << PAGE_SHIFT) +\n\t\t\t\tbh_offset(bh);\n\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\tinit_size = ni->initialized_size;\n\t\ti_size = i_size_read(vi);\n\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\tif (unlikely(init_size > i_size)) {\n\t\t\t \n\t\t\tinit_size = i_size;\n\t\t}\n\t\t \n\t\tif (unlikely(file_ofs + bh->b_size > init_size)) {\n\t\t\tint ofs;\n\t\t\tvoid *kaddr;\n\n\t\t\tofs = 0;\n\t\t\tif (file_ofs < init_size)\n\t\t\t\tofs = init_size - file_ofs;\n\t\t\tkaddr = kmap_atomic(page);\n\t\t\tmemset(kaddr + bh_offset(bh) + ofs, 0,\n\t\t\t\t\tbh->b_size - ofs);\n\t\t\tflush_dcache_page(page);\n\t\t\tkunmap_atomic(kaddr);\n\t\t}\n\t} else {\n\t\tclear_buffer_uptodate(bh);\n\t\tSetPageError(page);\n\t\tntfs_error(ni->vol->sb, \"Buffer I/O error, logical block \"\n\t\t\t\t\"0x%llx.\", (unsigned long long)bh->b_blocknr);\n\t}\n\tfirst = page_buffers(page);\n\tspin_lock_irqsave(&first->b_uptodate_lock, flags);\n\tclear_buffer_async_read(bh);\n\tunlock_buffer(bh);\n\ttmp = bh;\n\tdo {\n\t\tif (!buffer_uptodate(tmp))\n\t\t\tpage_uptodate = 0;\n\t\tif (buffer_async_read(tmp)) {\n\t\t\tif (likely(buffer_locked(tmp)))\n\t\t\t\tgoto still_busy;\n\t\t\t \n\t\t\tBUG();\n\t\t}\n\t\ttmp = tmp->b_this_page;\n\t} while (tmp != bh);\n\tspin_unlock_irqrestore(&first->b_uptodate_lock, flags);\n\t \n\tif (!NInoMstProtected(ni)) {\n\t\tif (likely(page_uptodate && !PageError(page)))\n\t\t\tSetPageUptodate(page);\n\t} else {\n\t\tu8 *kaddr;\n\t\tunsigned int i, recs;\n\t\tu32 rec_size;\n\n\t\trec_size = ni->itype.index.block_size;\n\t\trecs = PAGE_SIZE / rec_size;\n\t\t \n\t\tBUG_ON(!recs);\n\t\tkaddr = kmap_atomic(page);\n\t\tfor (i = 0; i < recs; i++)\n\t\t\tpost_read_mst_fixup((NTFS_RECORD*)(kaddr +\n\t\t\t\t\ti * rec_size), rec_size);\n\t\tkunmap_atomic(kaddr);\n\t\tflush_dcache_page(page);\n\t\tif (likely(page_uptodate && !PageError(page)))\n\t\t\tSetPageUptodate(page);\n\t}\n\tunlock_page(page);\n\treturn;\nstill_busy:\n\tspin_unlock_irqrestore(&first->b_uptodate_lock, flags);\n\treturn;\n}\n\n \nstatic int ntfs_read_block(struct page *page)\n{\n\tloff_t i_size;\n\tVCN vcn;\n\tLCN lcn;\n\ts64 init_size;\n\tstruct inode *vi;\n\tntfs_inode *ni;\n\tntfs_volume *vol;\n\trunlist_element *rl;\n\tstruct buffer_head *bh, *head, *arr[MAX_BUF_PER_PAGE];\n\tsector_t iblock, lblock, zblock;\n\tunsigned long flags;\n\tunsigned int blocksize, vcn_ofs;\n\tint i, nr;\n\tunsigned char blocksize_bits;\n\n\tvi = page->mapping->host;\n\tni = NTFS_I(vi);\n\tvol = ni->vol;\n\n\t \n\tBUG_ON(!ni->runlist.rl && !ni->mft_no && !NInoAttr(ni));\n\n\tblocksize = vol->sb->s_blocksize;\n\tblocksize_bits = vol->sb->s_blocksize_bits;\n\n\tif (!page_has_buffers(page)) {\n\t\tcreate_empty_buffers(page, blocksize, 0);\n\t\tif (unlikely(!page_has_buffers(page))) {\n\t\t\tunlock_page(page);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\tbh = head = page_buffers(page);\n\tBUG_ON(!bh);\n\n\t \n\tiblock = (s64)page->index << (PAGE_SHIFT - blocksize_bits);\n\tread_lock_irqsave(&ni->size_lock, flags);\n\tlblock = (ni->allocated_size + blocksize - 1) >> blocksize_bits;\n\tinit_size = ni->initialized_size;\n\ti_size = i_size_read(vi);\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\tif (unlikely(init_size > i_size)) {\n\t\t \n\t\tinit_size = i_size;\n\t}\n\tzblock = (init_size + blocksize - 1) >> blocksize_bits;\n\n\t \n\trl = NULL;\n\tnr = i = 0;\n\tdo {\n\t\tint err = 0;\n\n\t\tif (unlikely(buffer_uptodate(bh)))\n\t\t\tcontinue;\n\t\tif (unlikely(buffer_mapped(bh))) {\n\t\t\tarr[nr++] = bh;\n\t\t\tcontinue;\n\t\t}\n\t\tbh->b_bdev = vol->sb->s_bdev;\n\t\t \n\t\tif (iblock < lblock) {\n\t\t\tbool is_retry = false;\n\n\t\t\t \n\t\t\tvcn = (VCN)iblock << blocksize_bits >>\n\t\t\t\t\tvol->cluster_size_bits;\n\t\t\tvcn_ofs = ((VCN)iblock << blocksize_bits) &\n\t\t\t\t\tvol->cluster_size_mask;\n\t\t\tif (!rl) {\nlock_retry_remap:\n\t\t\t\tdown_read(&ni->runlist.lock);\n\t\t\t\trl = ni->runlist.rl;\n\t\t\t}\n\t\t\tif (likely(rl != NULL)) {\n\t\t\t\t \n\t\t\t\twhile (rl->length && rl[1].vcn <= vcn)\n\t\t\t\t\trl++;\n\t\t\t\tlcn = ntfs_rl_vcn_to_lcn(rl, vcn);\n\t\t\t} else\n\t\t\t\tlcn = LCN_RL_NOT_MAPPED;\n\t\t\t \n\t\t\tif (lcn >= 0) {\n\t\t\t\t \n\t\t\t\tbh->b_blocknr = ((lcn << vol->cluster_size_bits)\n\t\t\t\t\t\t+ vcn_ofs) >> blocksize_bits;\n\t\t\t\tset_buffer_mapped(bh);\n\t\t\t\t \n\t\t\t\tif (iblock < zblock) {\n\t\t\t\t\tarr[nr++] = bh;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tgoto handle_zblock;\n\t\t\t}\n\t\t\t \n\t\t\tif (lcn == LCN_HOLE)\n\t\t\t\tgoto handle_hole;\n\t\t\t \n\t\t\tif (!is_retry && lcn == LCN_RL_NOT_MAPPED) {\n\t\t\t\tis_retry = true;\n\t\t\t\t \n\t\t\t\tup_read(&ni->runlist.lock);\n\t\t\t\terr = ntfs_map_runlist(ni, vcn);\n\t\t\t\tif (likely(!err))\n\t\t\t\t\tgoto lock_retry_remap;\n\t\t\t\trl = NULL;\n\t\t\t} else if (!rl)\n\t\t\t\tup_read(&ni->runlist.lock);\n\t\t\t \n\t\t\tif (err == -ENOENT || lcn == LCN_ENOENT) {\n\t\t\t\terr = 0;\n\t\t\t\tgoto handle_hole;\n\t\t\t}\n\t\t\t \n\t\t\tif (!err)\n\t\t\t\terr = -EIO;\n\t\t\tbh->b_blocknr = -1;\n\t\t\tSetPageError(page);\n\t\t\tntfs_error(vol->sb, \"Failed to read from inode 0x%lx, \"\n\t\t\t\t\t\"attribute type 0x%x, vcn 0x%llx, \"\n\t\t\t\t\t\"offset 0x%x because its location on \"\n\t\t\t\t\t\"disk could not be determined%s \"\n\t\t\t\t\t\"(error code %i).\", ni->mft_no,\n\t\t\t\t\tni->type, (unsigned long long)vcn,\n\t\t\t\t\tvcn_ofs, is_retry ? \" even after \"\n\t\t\t\t\t\"retrying\" : \"\", err);\n\t\t}\n\t\t \nhandle_hole:\n\t\tbh->b_blocknr = -1UL;\n\t\tclear_buffer_mapped(bh);\nhandle_zblock:\n\t\tzero_user(page, i * blocksize, blocksize);\n\t\tif (likely(!err))\n\t\t\tset_buffer_uptodate(bh);\n\t} while (i++, iblock++, (bh = bh->b_this_page) != head);\n\n\t \n\tif (rl)\n\t\tup_read(&ni->runlist.lock);\n\n\t \n\tif (nr) {\n\t\tstruct buffer_head *tbh;\n\n\t\t \n\t\tfor (i = 0; i < nr; i++) {\n\t\t\ttbh = arr[i];\n\t\t\tlock_buffer(tbh);\n\t\t\ttbh->b_end_io = ntfs_end_buffer_async_read;\n\t\t\tset_buffer_async_read(tbh);\n\t\t}\n\t\t \n\t\tfor (i = 0; i < nr; i++) {\n\t\t\ttbh = arr[i];\n\t\t\tif (likely(!buffer_uptodate(tbh)))\n\t\t\t\tsubmit_bh(REQ_OP_READ, tbh);\n\t\t\telse\n\t\t\t\tntfs_end_buffer_async_read(tbh, 1);\n\t\t}\n\t\treturn 0;\n\t}\n\t \n\tif (likely(!PageError(page)))\n\t\tSetPageUptodate(page);\n\telse  \n\t\tnr = -EIO;\n\tunlock_page(page);\n\treturn nr;\n}\n\n \nstatic int ntfs_read_folio(struct file *file, struct folio *folio)\n{\n\tstruct page *page = &folio->page;\n\tloff_t i_size;\n\tstruct inode *vi;\n\tntfs_inode *ni, *base_ni;\n\tu8 *addr;\n\tntfs_attr_search_ctx *ctx;\n\tMFT_RECORD *mrec;\n\tunsigned long flags;\n\tu32 attr_len;\n\tint err = 0;\n\nretry_readpage:\n\tBUG_ON(!PageLocked(page));\n\tvi = page->mapping->host;\n\ti_size = i_size_read(vi);\n\t \n\tif (unlikely(page->index >= (i_size + PAGE_SIZE - 1) >>\n\t\t\tPAGE_SHIFT)) {\n\t\tzero_user(page, 0, PAGE_SIZE);\n\t\tntfs_debug(\"Read outside i_size - truncated?\");\n\t\tgoto done;\n\t}\n\t \n\tif (PageUptodate(page)) {\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\tni = NTFS_I(vi);\n\t \n\tif (ni->type != AT_INDEX_ALLOCATION) {\n\t\t \n\t\tif (NInoEncrypted(ni)) {\n\t\t\tBUG_ON(ni->type != AT_DATA);\n\t\t\terr = -EACCES;\n\t\t\tgoto err_out;\n\t\t}\n\t\t \n\t\tif (NInoNonResident(ni) && NInoCompressed(ni)) {\n\t\t\tBUG_ON(ni->type != AT_DATA);\n\t\t\tBUG_ON(ni->name_len);\n\t\t\treturn ntfs_read_compressed_block(page);\n\t\t}\n\t}\n\t \n\tif (NInoNonResident(ni)) {\n\t\t \n\t\treturn ntfs_read_block(page);\n\t}\n\t \n\tif (unlikely(page->index > 0)) {\n\t\tzero_user(page, 0, PAGE_SIZE);\n\t\tgoto done;\n\t}\n\tif (!NInoAttr(ni))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\t \n\tmrec = map_mft_record(base_ni);\n\tif (IS_ERR(mrec)) {\n\t\terr = PTR_ERR(mrec);\n\t\tgoto err_out;\n\t}\n\t \n\tif (unlikely(NInoNonResident(ni))) {\n\t\tunmap_mft_record(base_ni);\n\t\tgoto retry_readpage;\n\t}\n\tctx = ntfs_attr_get_search_ctx(base_ni, mrec);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err))\n\t\tgoto put_unm_err_out;\n\tattr_len = le32_to_cpu(ctx->attr->data.resident.value_length);\n\tread_lock_irqsave(&ni->size_lock, flags);\n\tif (unlikely(attr_len > ni->initialized_size))\n\t\tattr_len = ni->initialized_size;\n\ti_size = i_size_read(vi);\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\tif (unlikely(attr_len > i_size)) {\n\t\t \n\t\tattr_len = i_size;\n\t}\n\taddr = kmap_atomic(page);\n\t \n\tmemcpy(addr, (u8*)ctx->attr +\n\t\t\tle16_to_cpu(ctx->attr->data.resident.value_offset),\n\t\t\tattr_len);\n\t \n\tmemset(addr + attr_len, 0, PAGE_SIZE - attr_len);\n\tflush_dcache_page(page);\n\tkunmap_atomic(addr);\nput_unm_err_out:\n\tntfs_attr_put_search_ctx(ctx);\nunm_err_out:\n\tunmap_mft_record(base_ni);\ndone:\n\tSetPageUptodate(page);\nerr_out:\n\tunlock_page(page);\n\treturn err;\n}\n\n#ifdef NTFS_RW\n\n \nstatic int ntfs_write_block(struct page *page, struct writeback_control *wbc)\n{\n\tVCN vcn;\n\tLCN lcn;\n\ts64 initialized_size;\n\tloff_t i_size;\n\tsector_t block, dblock, iblock;\n\tstruct inode *vi;\n\tntfs_inode *ni;\n\tntfs_volume *vol;\n\trunlist_element *rl;\n\tstruct buffer_head *bh, *head;\n\tunsigned long flags;\n\tunsigned int blocksize, vcn_ofs;\n\tint err;\n\tbool need_end_writeback;\n\tunsigned char blocksize_bits;\n\n\tvi = page->mapping->host;\n\tni = NTFS_I(vi);\n\tvol = ni->vol;\n\n\tntfs_debug(\"Entering for inode 0x%lx, attribute type 0x%x, page index \"\n\t\t\t\"0x%lx.\", ni->mft_no, ni->type, page->index);\n\n\tBUG_ON(!NInoNonResident(ni));\n\tBUG_ON(NInoMstProtected(ni));\n\tblocksize = vol->sb->s_blocksize;\n\tblocksize_bits = vol->sb->s_blocksize_bits;\n\tif (!page_has_buffers(page)) {\n\t\tBUG_ON(!PageUptodate(page));\n\t\tcreate_empty_buffers(page, blocksize,\n\t\t\t\t(1 << BH_Uptodate) | (1 << BH_Dirty));\n\t\tif (unlikely(!page_has_buffers(page))) {\n\t\t\tntfs_warning(vol->sb, \"Error allocating page \"\n\t\t\t\t\t\"buffers.  Redirtying page so we try \"\n\t\t\t\t\t\"again later.\");\n\t\t\t \n\t\t\tredirty_page_for_writepage(wbc, page);\n\t\t\tunlock_page(page);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tbh = head = page_buffers(page);\n\tBUG_ON(!bh);\n\n\t \n\n\t \n\tblock = (s64)page->index << (PAGE_SHIFT - blocksize_bits);\n\n\tread_lock_irqsave(&ni->size_lock, flags);\n\ti_size = i_size_read(vi);\n\tinitialized_size = ni->initialized_size;\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\n\t \n\tdblock = (i_size + blocksize - 1) >> blocksize_bits;\n\n\t \n\tiblock = initialized_size >> blocksize_bits;\n\n\t \n\n\t \n\trl = NULL;\n\terr = 0;\n\tdo {\n\t\tbool is_retry = false;\n\n\t\tif (unlikely(block >= dblock)) {\n\t\t\t \n\t\t\tclear_buffer_dirty(bh);\n\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (!buffer_dirty(bh))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (unlikely((block >= iblock) &&\n\t\t\t\t(initialized_size < i_size))) {\n\t\t\t \n\t\t\tif (block > iblock) {\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t\t \n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\t \n\t\t\t\t \n\t\t\t\t \n\t\t\t}\n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\tntfs_error(vol->sb, \"Writing beyond initialized size \"\n\t\t\t\t\t\"is not supported yet. Sorry.\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tbreak;\n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t}\n\n\t\t \n\t\tif (buffer_mapped(bh))\n\t\t\tcontinue;\n\n\t\t \n\t\tbh->b_bdev = vol->sb->s_bdev;\n\n\t\t \n\t\tvcn = (VCN)block << blocksize_bits;\n\t\tvcn_ofs = vcn & vol->cluster_size_mask;\n\t\tvcn >>= vol->cluster_size_bits;\n\t\tif (!rl) {\nlock_retry_remap:\n\t\t\tdown_read(&ni->runlist.lock);\n\t\t\trl = ni->runlist.rl;\n\t\t}\n\t\tif (likely(rl != NULL)) {\n\t\t\t \n\t\t\twhile (rl->length && rl[1].vcn <= vcn)\n\t\t\t\trl++;\n\t\t\tlcn = ntfs_rl_vcn_to_lcn(rl, vcn);\n\t\t} else\n\t\t\tlcn = LCN_RL_NOT_MAPPED;\n\t\t \n\t\tif (lcn >= 0) {\n\t\t\t \n\t\t\tbh->b_blocknr = ((lcn << vol->cluster_size_bits) +\n\t\t\t\t\tvcn_ofs) >> blocksize_bits;\n\t\t\tset_buffer_mapped(bh);\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (lcn == LCN_HOLE) {\n\t\t\tu8 *kaddr;\n\t\t\tunsigned long *bpos, *bend;\n\n\t\t\t \n\t\t\tkaddr = kmap_atomic(page);\n\t\t\tbpos = (unsigned long *)(kaddr + bh_offset(bh));\n\t\t\tbend = (unsigned long *)((u8*)bpos + blocksize);\n\t\t\tdo {\n\t\t\t\tif (unlikely(*bpos))\n\t\t\t\t\tbreak;\n\t\t\t} while (likely(++bpos < bend));\n\t\t\tkunmap_atomic(kaddr);\n\t\t\tif (bpos == bend) {\n\t\t\t\t \n\t\t\t\tbh->b_blocknr = -1;\n\t\t\t\tclear_buffer_dirty(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\tntfs_error(vol->sb, \"Writing into sparse regions is \"\n\t\t\t\t\t\"not supported yet. Sorry.\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tif (!is_retry && lcn == LCN_RL_NOT_MAPPED) {\n\t\t\tis_retry = true;\n\t\t\t \n\t\t\tup_read(&ni->runlist.lock);\n\t\t\terr = ntfs_map_runlist(ni, vcn);\n\t\t\tif (likely(!err))\n\t\t\t\tgoto lock_retry_remap;\n\t\t\trl = NULL;\n\t\t} else if (!rl)\n\t\t\tup_read(&ni->runlist.lock);\n\t\t \n\t\tif (err == -ENOENT || lcn == LCN_ENOENT) {\n\t\t\tbh->b_blocknr = -1;\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tzero_user(page, bh_offset(bh), blocksize);\n\t\t\tset_buffer_uptodate(bh);\n\t\t\terr = 0;\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (!err)\n\t\t\terr = -EIO;\n\t\tbh->b_blocknr = -1;\n\t\tntfs_error(vol->sb, \"Failed to write to inode 0x%lx, \"\n\t\t\t\t\"attribute type 0x%x, vcn 0x%llx, offset 0x%x \"\n\t\t\t\t\"because its location on disk could not be \"\n\t\t\t\t\"determined%s (error code %i).\", ni->mft_no,\n\t\t\t\tni->type, (unsigned long long)vcn,\n\t\t\t\tvcn_ofs, is_retry ? \" even after \"\n\t\t\t\t\"retrying\" : \"\", err);\n\t\tbreak;\n\t} while (block++, (bh = bh->b_this_page) != head);\n\n\t \n\tif (rl)\n\t\tup_read(&ni->runlist.lock);\n\n\t \n\tbh = head;\n\n\t \n\tif (unlikely(!PageUptodate(page))) {\n\t\tint uptodate = 1;\n\t\tdo {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tuptodate = 0;\n\t\t\t\tbh = head;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while ((bh = bh->b_this_page) != head);\n\t\tif (uptodate)\n\t\t\tSetPageUptodate(page);\n\t}\n\n\t \n\tdo {\n\t\tif (buffer_mapped(bh) && buffer_dirty(bh)) {\n\t\t\tlock_buffer(bh);\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tBUG_ON(!buffer_uptodate(bh));\n\t\t\t\tmark_buffer_async_write(bh);\n\t\t\t} else\n\t\t\t\tunlock_buffer(bh);\n\t\t} else if (unlikely(err)) {\n\t\t\t \n\t\t\tif (err != -ENOMEM)\n\t\t\t\tclear_buffer_dirty(bh);\n\t\t}\n\t} while ((bh = bh->b_this_page) != head);\n\n\tif (unlikely(err)) {\n\t\t \n\t\tif (unlikely(err == -EOPNOTSUPP))\n\t\t\terr = 0;\n\t\telse if (err == -ENOMEM) {\n\t\t\tntfs_warning(vol->sb, \"Error allocating memory. \"\n\t\t\t\t\t\"Redirtying page so we try again \"\n\t\t\t\t\t\"later.\");\n\t\t\t \n\t\t\tredirty_page_for_writepage(wbc, page);\n\t\t\terr = 0;\n\t\t} else\n\t\t\tSetPageError(page);\n\t}\n\n\tBUG_ON(PageWriteback(page));\n\tset_page_writeback(page);\t \n\n\t \n\tneed_end_writeback = true;\n\tdo {\n\t\tstruct buffer_head *next = bh->b_this_page;\n\t\tif (buffer_async_write(bh)) {\n\t\t\tsubmit_bh(REQ_OP_WRITE, bh);\n\t\t\tneed_end_writeback = false;\n\t\t}\n\t\tbh = next;\n\t} while (bh != head);\n\tunlock_page(page);\n\n\t \n\tif (unlikely(need_end_writeback))\n\t\tend_page_writeback(page);\n\n\tntfs_debug(\"Done.\");\n\treturn err;\n}\n\n \nstatic int ntfs_write_mst_block(struct page *page,\n\t\tstruct writeback_control *wbc)\n{\n\tsector_t block, dblock, rec_block;\n\tstruct inode *vi = page->mapping->host;\n\tntfs_inode *ni = NTFS_I(vi);\n\tntfs_volume *vol = ni->vol;\n\tu8 *kaddr;\n\tunsigned int rec_size = ni->itype.index.block_size;\n\tntfs_inode *locked_nis[PAGE_SIZE / NTFS_BLOCK_SIZE];\n\tstruct buffer_head *bh, *head, *tbh, *rec_start_bh;\n\tstruct buffer_head *bhs[MAX_BUF_PER_PAGE];\n\trunlist_element *rl;\n\tint i, nr_locked_nis, nr_recs, nr_bhs, max_bhs, bhs_per_rec, err, err2;\n\tunsigned bh_size, rec_size_bits;\n\tbool sync, is_mft, page_is_dirty, rec_is_dirty;\n\tunsigned char bh_size_bits;\n\n\tif (WARN_ON(rec_size < NTFS_BLOCK_SIZE))\n\t\treturn -EINVAL;\n\n\tntfs_debug(\"Entering for inode 0x%lx, attribute type 0x%x, page index \"\n\t\t\t\"0x%lx.\", vi->i_ino, ni->type, page->index);\n\tBUG_ON(!NInoNonResident(ni));\n\tBUG_ON(!NInoMstProtected(ni));\n\tis_mft = (S_ISREG(vi->i_mode) && !vi->i_ino);\n\t \n\tBUG_ON(!(is_mft || S_ISDIR(vi->i_mode) ||\n\t\t\t(NInoAttr(ni) && ni->type == AT_INDEX_ALLOCATION)));\n\tbh_size = vol->sb->s_blocksize;\n\tbh_size_bits = vol->sb->s_blocksize_bits;\n\tmax_bhs = PAGE_SIZE / bh_size;\n\tBUG_ON(!max_bhs);\n\tBUG_ON(max_bhs > MAX_BUF_PER_PAGE);\n\n\t \n\tsync = (wbc->sync_mode == WB_SYNC_ALL);\n\n\t \n\tbh = head = page_buffers(page);\n\tBUG_ON(!bh);\n\n\trec_size_bits = ni->itype.index.block_size_bits;\n\tBUG_ON(!(PAGE_SIZE >> rec_size_bits));\n\tbhs_per_rec = rec_size >> bh_size_bits;\n\tBUG_ON(!bhs_per_rec);\n\n\t \n\trec_block = block = (sector_t)page->index <<\n\t\t\t(PAGE_SHIFT - bh_size_bits);\n\n\t \n\tdblock = (i_size_read(vi) + bh_size - 1) >> bh_size_bits;\n\n\trl = NULL;\n\terr = err2 = nr_bhs = nr_recs = nr_locked_nis = 0;\n\tpage_is_dirty = rec_is_dirty = false;\n\trec_start_bh = NULL;\n\tdo {\n\t\tbool is_retry = false;\n\n\t\tif (likely(block < rec_block)) {\n\t\t\tif (unlikely(block >= dblock)) {\n\t\t\t\tclear_buffer_dirty(bh);\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t \n\t\t\tif (!rec_is_dirty)\n\t\t\t\tcontinue;\n\t\t\tif (unlikely(err2)) {\n\t\t\t\tif (err2 != -ENOMEM)\n\t\t\t\t\tclear_buffer_dirty(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else   {\n\t\t\tBUG_ON(block > rec_block);\n\t\t\t \n\t\t\trec_block += bhs_per_rec;\n\t\t\terr2 = 0;\n\t\t\tif (unlikely(block >= dblock)) {\n\t\t\t\tclear_buffer_dirty(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!buffer_dirty(bh)) {\n\t\t\t\t \n\t\t\t\trec_is_dirty = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trec_is_dirty = true;\n\t\t\trec_start_bh = bh;\n\t\t}\n\t\t \n\t\tif (unlikely(!buffer_mapped(bh))) {\n\t\t\tVCN vcn;\n\t\t\tLCN lcn;\n\t\t\tunsigned int vcn_ofs;\n\n\t\t\tbh->b_bdev = vol->sb->s_bdev;\n\t\t\t \n\t\t\tvcn = (VCN)block << bh_size_bits;\n\t\t\tvcn_ofs = vcn & vol->cluster_size_mask;\n\t\t\tvcn >>= vol->cluster_size_bits;\n\t\t\tif (!rl) {\nlock_retry_remap:\n\t\t\t\tdown_read(&ni->runlist.lock);\n\t\t\t\trl = ni->runlist.rl;\n\t\t\t}\n\t\t\tif (likely(rl != NULL)) {\n\t\t\t\t \n\t\t\t\twhile (rl->length && rl[1].vcn <= vcn)\n\t\t\t\t\trl++;\n\t\t\t\tlcn = ntfs_rl_vcn_to_lcn(rl, vcn);\n\t\t\t} else\n\t\t\t\tlcn = LCN_RL_NOT_MAPPED;\n\t\t\t \n\t\t\tif (likely(lcn >= 0)) {\n\t\t\t\t \n\t\t\t\tbh->b_blocknr = ((lcn <<\n\t\t\t\t\t\tvol->cluster_size_bits) +\n\t\t\t\t\t\tvcn_ofs) >> bh_size_bits;\n\t\t\t\tset_buffer_mapped(bh);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (!is_mft && !is_retry &&\n\t\t\t\t\t\tlcn == LCN_RL_NOT_MAPPED) {\n\t\t\t\t\tis_retry = true;\n\t\t\t\t\t \n\t\t\t\t\tup_read(&ni->runlist.lock);\n\t\t\t\t\terr2 = ntfs_map_runlist(ni, vcn);\n\t\t\t\t\tif (likely(!err2))\n\t\t\t\t\t\tgoto lock_retry_remap;\n\t\t\t\t\tif (err2 == -ENOMEM)\n\t\t\t\t\t\tpage_is_dirty = true;\n\t\t\t\t\tlcn = err2;\n\t\t\t\t} else {\n\t\t\t\t\terr2 = -EIO;\n\t\t\t\t\tif (!rl)\n\t\t\t\t\t\tup_read(&ni->runlist.lock);\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tif (!err || err == -ENOMEM)\n\t\t\t\t\terr = err2;\n\t\t\t\tbh->b_blocknr = -1;\n\t\t\t\tntfs_error(vol->sb, \"Cannot write ntfs record \"\n\t\t\t\t\t\t\"0x%llx (inode 0x%lx, \"\n\t\t\t\t\t\t\"attribute type 0x%x) because \"\n\t\t\t\t\t\t\"its location on disk could \"\n\t\t\t\t\t\t\"not be determined (error \"\n\t\t\t\t\t\t\"code %lli).\",\n\t\t\t\t\t\t(long long)block <<\n\t\t\t\t\t\tbh_size_bits >>\n\t\t\t\t\t\tvol->mft_record_size_bits,\n\t\t\t\t\t\tni->mft_no, ni->type,\n\t\t\t\t\t\t(long long)lcn);\n\t\t\t\t \n\t\t\t\tif (rec_start_bh != bh) {\n\t\t\t\t\twhile (bhs[--nr_bhs] != rec_start_bh)\n\t\t\t\t\t\t;\n\t\t\t\t\tif (err2 != -ENOMEM) {\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tclear_buffer_dirty(\n\t\t\t\t\t\t\t\trec_start_bh);\n\t\t\t\t\t\t} while ((rec_start_bh =\n\t\t\t\t\t\t\t\trec_start_bh->\n\t\t\t\t\t\t\t\tb_this_page) !=\n\t\t\t\t\t\t\t\tbh);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tBUG_ON(!buffer_uptodate(bh));\n\t\tBUG_ON(nr_bhs >= max_bhs);\n\t\tbhs[nr_bhs++] = bh;\n\t} while (block++, (bh = bh->b_this_page) != head);\n\tif (unlikely(rl))\n\t\tup_read(&ni->runlist.lock);\n\t \n\tif (!nr_bhs)\n\t\tgoto done;\n\t \n\tkaddr = kmap(page);\n\t \n\tBUG_ON(!PageUptodate(page));\n\tClearPageUptodate(page);\n\tfor (i = 0; i < nr_bhs; i++) {\n\t\tunsigned int ofs;\n\n\t\t \n\t\tif (i % bhs_per_rec)\n\t\t\tcontinue;\n\t\ttbh = bhs[i];\n\t\tofs = bh_offset(tbh);\n\t\tif (is_mft) {\n\t\t\tntfs_inode *tni;\n\t\t\tunsigned long mft_no;\n\n\t\t\t \n\t\t\tmft_no = (((s64)page->index << PAGE_SHIFT) + ofs)\n\t\t\t\t\t>> rec_size_bits;\n\t\t\t \n\t\t\ttni = NULL;\n\t\t\tif (!ntfs_may_write_mft_record(vol, mft_no,\n\t\t\t\t\t(MFT_RECORD*)(kaddr + ofs), &tni)) {\n\t\t\t\t \n\t\t\t\tpage_is_dirty = true;\n\t\t\t\t \n\t\t\t\tdo {\n\t\t\t\t\tbhs[i] = NULL;\n\t\t\t\t} while (++i % bhs_per_rec);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t \n\t\t\tif (tni)\n\t\t\t\tlocked_nis[nr_locked_nis++] = tni;\n\t\t}\n\t\t \n\t\terr2 = pre_write_mst_fixup((NTFS_RECORD*)(kaddr + ofs),\n\t\t\t\trec_size);\n\t\tif (unlikely(err2)) {\n\t\t\tif (!err || err == -ENOMEM)\n\t\t\t\terr = -EIO;\n\t\t\tntfs_error(vol->sb, \"Failed to apply mst fixups \"\n\t\t\t\t\t\"(inode 0x%lx, attribute type 0x%x, \"\n\t\t\t\t\t\"page index 0x%lx, page offset 0x%x)!\"\n\t\t\t\t\t\"  Unmount and run chkdsk.\", vi->i_ino,\n\t\t\t\t\tni->type, page->index, ofs);\n\t\t\t \n\t\t\tdo {\n\t\t\t\tclear_buffer_dirty(bhs[i]);\n\t\t\t\tbhs[i] = NULL;\n\t\t\t} while (++i % bhs_per_rec);\n\t\t\tcontinue;\n\t\t}\n\t\tnr_recs++;\n\t}\n\t \n\tif (!nr_recs)\n\t\tgoto unm_done;\n\tflush_dcache_page(page);\n\t \n\tfor (i = 0; i < nr_bhs; i++) {\n\t\ttbh = bhs[i];\n\t\tif (!tbh)\n\t\t\tcontinue;\n\t\tif (!trylock_buffer(tbh))\n\t\t\tBUG();\n\t\t \n\t\tclear_buffer_dirty(tbh);\n\t\tBUG_ON(!buffer_uptodate(tbh));\n\t\tBUG_ON(!buffer_mapped(tbh));\n\t\tget_bh(tbh);\n\t\ttbh->b_end_io = end_buffer_write_sync;\n\t\tsubmit_bh(REQ_OP_WRITE, tbh);\n\t}\n\t \n\tif (is_mft && !sync)\n\t\tgoto do_mirror;\ndo_wait:\n\t \n\tfor (i = 0; i < nr_bhs; i++) {\n\t\ttbh = bhs[i];\n\t\tif (!tbh)\n\t\t\tcontinue;\n\t\twait_on_buffer(tbh);\n\t\tif (unlikely(!buffer_uptodate(tbh))) {\n\t\t\tntfs_error(vol->sb, \"I/O error while writing ntfs \"\n\t\t\t\t\t\"record buffer (inode 0x%lx, \"\n\t\t\t\t\t\"attribute type 0x%x, page index \"\n\t\t\t\t\t\"0x%lx, page offset 0x%lx)!  Unmount \"\n\t\t\t\t\t\"and run chkdsk.\", vi->i_ino, ni->type,\n\t\t\t\t\tpage->index, bh_offset(tbh));\n\t\t\tif (!err || err == -ENOMEM)\n\t\t\t\terr = -EIO;\n\t\t\t \n\t\t\tset_buffer_uptodate(tbh);\n\t\t}\n\t}\n\t \n\tif (is_mft && sync) {\ndo_mirror:\n\t\tfor (i = 0; i < nr_bhs; i++) {\n\t\t\tunsigned long mft_no;\n\t\t\tunsigned int ofs;\n\n\t\t\t \n\t\t\tif (i % bhs_per_rec)\n\t\t\t\tcontinue;\n\t\t\ttbh = bhs[i];\n\t\t\t \n\t\t\tif (!tbh)\n\t\t\t\tcontinue;\n\t\t\tofs = bh_offset(tbh);\n\t\t\t \n\t\t\tmft_no = (((s64)page->index << PAGE_SHIFT) + ofs)\n\t\t\t\t\t>> rec_size_bits;\n\t\t\tif (mft_no < vol->mftmirr_size)\n\t\t\t\tntfs_sync_mft_mirror(vol, mft_no,\n\t\t\t\t\t\t(MFT_RECORD*)(kaddr + ofs),\n\t\t\t\t\t\tsync);\n\t\t}\n\t\tif (!sync)\n\t\t\tgoto do_wait;\n\t}\n\t \n\tfor (i = 0; i < nr_bhs; i++) {\n\t\tif (!(i % bhs_per_rec)) {\n\t\t\ttbh = bhs[i];\n\t\t\tif (!tbh)\n\t\t\t\tcontinue;\n\t\t\tpost_write_mst_fixup((NTFS_RECORD*)(kaddr +\n\t\t\t\t\tbh_offset(tbh)));\n\t\t}\n\t}\n\tflush_dcache_page(page);\nunm_done:\n\t \n\twhile (nr_locked_nis-- > 0) {\n\t\tntfs_inode *tni, *base_tni;\n\t\t\n\t\ttni = locked_nis[nr_locked_nis];\n\t\t \n\t\tmutex_lock(&tni->extent_lock);\n\t\tif (tni->nr_extents >= 0)\n\t\t\tbase_tni = tni;\n\t\telse {\n\t\t\tbase_tni = tni->ext.base_ntfs_ino;\n\t\t\tBUG_ON(!base_tni);\n\t\t}\n\t\tmutex_unlock(&tni->extent_lock);\n\t\tntfs_debug(\"Unlocking %s inode 0x%lx.\",\n\t\t\t\ttni == base_tni ? \"base\" : \"extent\",\n\t\t\t\ttni->mft_no);\n\t\tmutex_unlock(&tni->mrec_lock);\n\t\tatomic_dec(&tni->count);\n\t\tiput(VFS_I(base_tni));\n\t}\n\tSetPageUptodate(page);\n\tkunmap(page);\ndone:\n\tif (unlikely(err && err != -ENOMEM)) {\n\t\t \n\t\tif (ni->itype.index.block_size == PAGE_SIZE)\n\t\t\tSetPageError(page);\n\t\tNVolSetErrors(vol);\n\t}\n\tif (page_is_dirty) {\n\t\tntfs_debug(\"Page still contains one or more dirty ntfs \"\n\t\t\t\t\"records.  Redirtying the page starting at \"\n\t\t\t\t\"record 0x%lx.\", page->index <<\n\t\t\t\t(PAGE_SHIFT - rec_size_bits));\n\t\tredirty_page_for_writepage(wbc, page);\n\t\tunlock_page(page);\n\t} else {\n\t\t \n\t\tBUG_ON(PageWriteback(page));\n\t\tset_page_writeback(page);\n\t\tunlock_page(page);\n\t\tend_page_writeback(page);\n\t}\n\tif (likely(!err))\n\t\tntfs_debug(\"Done.\");\n\treturn err;\n}\n\n \nstatic int ntfs_writepage(struct page *page, struct writeback_control *wbc)\n{\n\tloff_t i_size;\n\tstruct inode *vi = page->mapping->host;\n\tntfs_inode *base_ni = NULL, *ni = NTFS_I(vi);\n\tchar *addr;\n\tntfs_attr_search_ctx *ctx = NULL;\n\tMFT_RECORD *m = NULL;\n\tu32 attr_len;\n\tint err;\n\nretry_writepage:\n\tBUG_ON(!PageLocked(page));\n\ti_size = i_size_read(vi);\n\t \n\tif (unlikely(page->index >= (i_size + PAGE_SIZE - 1) >>\n\t\t\tPAGE_SHIFT)) {\n\t\tstruct folio *folio = page_folio(page);\n\t\t \n\t\tblock_invalidate_folio(folio, 0, folio_size(folio));\n\t\tfolio_unlock(folio);\n\t\tntfs_debug(\"Write outside i_size - truncated?\");\n\t\treturn 0;\n\t}\n\t \n\tif (ni->type != AT_INDEX_ALLOCATION) {\n\t\t \n\t\tif (NInoEncrypted(ni)) {\n\t\t\tunlock_page(page);\n\t\t\tBUG_ON(ni->type != AT_DATA);\n\t\t\tntfs_debug(\"Denying write access to encrypted file.\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\t \n\t\tif (NInoNonResident(ni) && NInoCompressed(ni)) {\n\t\t\tBUG_ON(ni->type != AT_DATA);\n\t\t\tBUG_ON(ni->name_len);\n\t\t\t \n\t\t\t \n\t\t\tunlock_page(page);\n\t\t\tntfs_error(vi->i_sb, \"Writing to compressed files is \"\n\t\t\t\t\t\"not supported yet.  Sorry.\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\t \n\t\tif (NInoNonResident(ni) && NInoSparse(ni)) {\n\t\t\tunlock_page(page);\n\t\t\tntfs_error(vi->i_sb, \"Writing to sparse files is not \"\n\t\t\t\t\t\"supported yet.  Sorry.\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\t \n\tif (NInoNonResident(ni)) {\n\t\t \n\t\tif (page->index >= (i_size >> PAGE_SHIFT)) {\n\t\t\t \n\t\t\tunsigned int ofs = i_size & ~PAGE_MASK;\n\t\t\tzero_user_segment(page, ofs, PAGE_SIZE);\n\t\t}\n\t\t \n\t\tif (NInoMstProtected(ni))\n\t\t\treturn ntfs_write_mst_block(page, wbc);\n\t\t \n\t\treturn ntfs_write_block(page, wbc);\n\t}\n\t \n\tBUG_ON(page_has_buffers(page));\n\tBUG_ON(!PageUptodate(page));\n\tif (unlikely(page->index > 0)) {\n\t\tntfs_error(vi->i_sb, \"BUG()! page->index (0x%lx) > 0.  \"\n\t\t\t\t\"Aborting write.\", page->index);\n\t\tBUG_ON(PageWriteback(page));\n\t\tset_page_writeback(page);\n\t\tunlock_page(page);\n\t\tend_page_writeback(page);\n\t\treturn -EIO;\n\t}\n\tif (!NInoAttr(ni))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\t \n\tm = map_mft_record(base_ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\tgoto err_out;\n\t}\n\t \n\tif (unlikely(NInoNonResident(ni))) {\n\t\tunmap_mft_record(base_ni);\n\t\tgoto retry_writepage;\n\t}\n\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err))\n\t\tgoto err_out;\n\t \n\tBUG_ON(PageWriteback(page));\n\tset_page_writeback(page);\n\tunlock_page(page);\n\tattr_len = le32_to_cpu(ctx->attr->data.resident.value_length);\n\ti_size = i_size_read(vi);\n\tif (unlikely(attr_len > i_size)) {\n\t\t \n\t\tattr_len = i_size;\n\t\t \n\t\terr = ntfs_resident_attr_value_resize(ctx->mrec, ctx->attr,\n\t\t\t\tattr_len);\n\t\t \n\t\tBUG_ON(err);\n\t}\n\taddr = kmap_atomic(page);\n\t \n\tmemcpy((u8*)ctx->attr +\n\t\t\tle16_to_cpu(ctx->attr->data.resident.value_offset),\n\t\t\taddr, attr_len);\n\t \n\tmemset(addr + attr_len, 0, PAGE_SIZE - attr_len);\n\tkunmap_atomic(addr);\n\tflush_dcache_page(page);\n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t \n\tend_page_writeback(page);\n\t \n\tmark_mft_record_dirty(ctx->ntfs_ino);\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(base_ni);\n\treturn 0;\nerr_out:\n\tif (err == -ENOMEM) {\n\t\tntfs_warning(vi->i_sb, \"Error allocating memory. Redirtying \"\n\t\t\t\t\"page so we try again later.\");\n\t\t \n\t\tredirty_page_for_writepage(wbc, page);\n\t\terr = 0;\n\t} else {\n\t\tntfs_error(vi->i_sb, \"Resident attribute write failed with \"\n\t\t\t\t\"error %i.\", err);\n\t\tSetPageError(page);\n\t\tNVolSetErrors(ni->vol);\n\t}\n\tunlock_page(page);\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(base_ni);\n\treturn err;\n}\n\n#endif\t \n\n \nstatic sector_t ntfs_bmap(struct address_space *mapping, sector_t block)\n{\n\ts64 ofs, size;\n\tloff_t i_size;\n\tLCN lcn;\n\tunsigned long blocksize, flags;\n\tntfs_inode *ni = NTFS_I(mapping->host);\n\tntfs_volume *vol = ni->vol;\n\tunsigned delta;\n\tunsigned char blocksize_bits, cluster_size_shift;\n\n\tntfs_debug(\"Entering for mft_no 0x%lx, logical block 0x%llx.\",\n\t\t\tni->mft_no, (unsigned long long)block);\n\tif (ni->type != AT_DATA || !NInoNonResident(ni) || NInoEncrypted(ni)) {\n\t\tntfs_error(vol->sb, \"BMAP does not make sense for %s \"\n\t\t\t\t\"attributes, returning 0.\",\n\t\t\t\t(ni->type != AT_DATA) ? \"non-data\" :\n\t\t\t\t(!NInoNonResident(ni) ? \"resident\" :\n\t\t\t\t\"encrypted\"));\n\t\treturn 0;\n\t}\n\t \n\tBUG_ON(NInoCompressed(ni));\n\tBUG_ON(NInoMstProtected(ni));\n\tblocksize = vol->sb->s_blocksize;\n\tblocksize_bits = vol->sb->s_blocksize_bits;\n\tofs = (s64)block << blocksize_bits;\n\tread_lock_irqsave(&ni->size_lock, flags);\n\tsize = ni->initialized_size;\n\ti_size = i_size_read(VFS_I(ni));\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t \n\tif (unlikely(ofs >= size || (ofs + blocksize > size && size < i_size)))\n\t\tgoto hole;\n\tcluster_size_shift = vol->cluster_size_bits;\n\tdown_read(&ni->runlist.lock);\n\tlcn = ntfs_attr_vcn_to_lcn_nolock(ni, ofs >> cluster_size_shift, false);\n\tup_read(&ni->runlist.lock);\n\tif (unlikely(lcn < LCN_HOLE)) {\n\t\t \n\t\tswitch ((int)lcn) {\n\t\tcase LCN_ENOENT:\n\t\t\t \n\t\t\tgoto hole;\n\t\tcase LCN_ENOMEM:\n\t\t\tntfs_error(vol->sb, \"Not enough memory to complete \"\n\t\t\t\t\t\"mapping for inode 0x%lx.  \"\n\t\t\t\t\t\"Returning 0.\", ni->mft_no);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tntfs_error(vol->sb, \"Failed to complete mapping for \"\n\t\t\t\t\t\"inode 0x%lx.  Run chkdsk.  \"\n\t\t\t\t\t\"Returning 0.\", ni->mft_no);\n\t\t\tbreak;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (lcn < 0) {\n\t\t \nhole:\n\t\tntfs_debug(\"Done (returning hole).\");\n\t\treturn 0;\n\t}\n\t \n\tdelta = ofs & vol->cluster_size_mask;\n\tif (unlikely(sizeof(block) < sizeof(lcn))) {\n\t\tblock = lcn = ((lcn << cluster_size_shift) + delta) >>\n\t\t\t\tblocksize_bits;\n\t\t \n\t\tif (unlikely(block != lcn)) {\n\t\t\tntfs_error(vol->sb, \"Physical block 0x%llx is too \"\n\t\t\t\t\t\"large to be returned, returning 0.\",\n\t\t\t\t\t(long long)lcn);\n\t\t\treturn 0;\n\t\t}\n\t} else\n\t\tblock = ((lcn << cluster_size_shift) + delta) >>\n\t\t\t\tblocksize_bits;\n\tntfs_debug(\"Done (returning block 0x%llx).\", (unsigned long long)lcn);\n\treturn block;\n}\n\n \nconst struct address_space_operations ntfs_normal_aops = {\n\t.read_folio\t= ntfs_read_folio,\n#ifdef NTFS_RW\n\t.writepage\t= ntfs_writepage,\n\t.dirty_folio\t= block_dirty_folio,\n#endif  \n\t.bmap\t\t= ntfs_bmap,\n\t.migrate_folio\t= buffer_migrate_folio,\n\t.is_partially_uptodate = block_is_partially_uptodate,\n\t.error_remove_page = generic_error_remove_page,\n};\n\n \nconst struct address_space_operations ntfs_compressed_aops = {\n\t.read_folio\t= ntfs_read_folio,\n#ifdef NTFS_RW\n\t.writepage\t= ntfs_writepage,\n\t.dirty_folio\t= block_dirty_folio,\n#endif  \n\t.migrate_folio\t= buffer_migrate_folio,\n\t.is_partially_uptodate = block_is_partially_uptodate,\n\t.error_remove_page = generic_error_remove_page,\n};\n\n \nconst struct address_space_operations ntfs_mst_aops = {\n\t.read_folio\t= ntfs_read_folio,\t \n#ifdef NTFS_RW\n\t.writepage\t= ntfs_writepage,\t \n\t.dirty_folio\t= filemap_dirty_folio,\n#endif  \n\t.migrate_folio\t= buffer_migrate_folio,\n\t.is_partially_uptodate\t= block_is_partially_uptodate,\n\t.error_remove_page = generic_error_remove_page,\n};\n\n#ifdef NTFS_RW\n\n \nvoid mark_ntfs_record_dirty(struct page *page, const unsigned int ofs) {\n\tstruct address_space *mapping = page->mapping;\n\tntfs_inode *ni = NTFS_I(mapping->host);\n\tstruct buffer_head *bh, *head, *buffers_to_free = NULL;\n\tunsigned int end, bh_size, bh_ofs;\n\n\tBUG_ON(!PageUptodate(page));\n\tend = ofs + ni->itype.index.block_size;\n\tbh_size = VFS_I(ni)->i_sb->s_blocksize;\n\tspin_lock(&mapping->private_lock);\n\tif (unlikely(!page_has_buffers(page))) {\n\t\tspin_unlock(&mapping->private_lock);\n\t\tbh = head = alloc_page_buffers(page, bh_size, true);\n\t\tspin_lock(&mapping->private_lock);\n\t\tif (likely(!page_has_buffers(page))) {\n\t\t\tstruct buffer_head *tail;\n\n\t\t\tdo {\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\ttail = bh;\n\t\t\t\tbh = bh->b_this_page;\n\t\t\t} while (bh);\n\t\t\ttail->b_this_page = head;\n\t\t\tattach_page_private(page, head);\n\t\t} else\n\t\t\tbuffers_to_free = bh;\n\t}\n\tbh = head = page_buffers(page);\n\tBUG_ON(!bh);\n\tdo {\n\t\tbh_ofs = bh_offset(bh);\n\t\tif (bh_ofs + bh_size <= ofs)\n\t\t\tcontinue;\n\t\tif (unlikely(bh_ofs >= end))\n\t\t\tbreak;\n\t\tset_buffer_dirty(bh);\n\t} while ((bh = bh->b_this_page) != head);\n\tspin_unlock(&mapping->private_lock);\n\tfilemap_dirty_folio(mapping, page_folio(page));\n\tif (unlikely(buffers_to_free)) {\n\t\tdo {\n\t\t\tbh = buffers_to_free->b_this_page;\n\t\t\tfree_buffer_head(buffers_to_free);\n\t\t\tbuffers_to_free = bh;\n\t\t} while (buffers_to_free);\n\t}\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}