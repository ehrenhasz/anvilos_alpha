{
  "module_name": "inode.c",
  "hash_id": "8da73daeff68a28fd82048a6d84f68a68f0cb2aa15250a1b0a5fb1e2cb4065f1",
  "original_prompt": "Ingested from linux-6.6.14/fs/ntfs/inode.c",
  "human_readable_source": "\n \n\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/pagemap.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/log2.h>\n\n#include \"aops.h\"\n#include \"attrib.h\"\n#include \"bitmap.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"inode.h\"\n#include \"lcnalloc.h\"\n#include \"malloc.h\"\n#include \"mft.h\"\n#include \"time.h\"\n#include \"ntfs.h\"\n\n \nint ntfs_test_inode(struct inode *vi, void *data)\n{\n\tntfs_attr *na = (ntfs_attr *)data;\n\tntfs_inode *ni;\n\n\tif (vi->i_ino != na->mft_no)\n\t\treturn 0;\n\tni = NTFS_I(vi);\n\t \n\tif (likely(!NInoAttr(ni))) {\n\t\t \n\t\tif (unlikely(na->type != AT_UNUSED))\n\t\t\treturn 0;\n\t} else {\n\t\t \n\t\tif (ni->type != na->type)\n\t\t\treturn 0;\n\t\tif (ni->name_len != na->name_len)\n\t\t\treturn 0;\n\t\tif (na->name_len && memcmp(ni->name, na->name,\n\t\t\t\tna->name_len * sizeof(ntfschar)))\n\t\t\treturn 0;\n\t}\n\t \n\treturn 1;\n}\n\n \nstatic int ntfs_init_locked_inode(struct inode *vi, void *data)\n{\n\tntfs_attr *na = (ntfs_attr *)data;\n\tntfs_inode *ni = NTFS_I(vi);\n\n\tvi->i_ino = na->mft_no;\n\n\tni->type = na->type;\n\tif (na->type == AT_INDEX_ALLOCATION)\n\t\tNInoSetMstProtected(ni);\n\n\tni->name = na->name;\n\tni->name_len = na->name_len;\n\n\t \n\tif (likely(na->type == AT_UNUSED)) {\n\t\tBUG_ON(na->name);\n\t\tBUG_ON(na->name_len);\n\t\treturn 0;\n\t}\n\n\t \n\tNInoSetAttr(ni);\n\n\t \n\tif (na->name_len && na->name != I30) {\n\t\tunsigned int i;\n\n\t\tBUG_ON(!na->name);\n\t\ti = na->name_len * sizeof(ntfschar);\n\t\tni->name = kmalloc(i + sizeof(ntfschar), GFP_ATOMIC);\n\t\tif (!ni->name)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy(ni->name, na->name, i);\n\t\tni->name[na->name_len] = 0;\n\t}\n\treturn 0;\n}\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\n \nstruct inode *ntfs_iget(struct super_block *sb, unsigned long mft_no)\n{\n\tstruct inode *vi;\n\tint err;\n\tntfs_attr na;\n\n\tna.mft_no = mft_no;\n\tna.type = AT_UNUSED;\n\tna.name = NULL;\n\tna.name_len = 0;\n\n\tvi = iget5_locked(sb, mft_no, ntfs_test_inode,\n\t\t\tntfs_init_locked_inode, &na);\n\tif (unlikely(!vi))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = 0;\n\n\t \n\tif (vi->i_state & I_NEW) {\n\t\terr = ntfs_read_locked_inode(vi);\n\t\tunlock_new_inode(vi);\n\t}\n\t \n\tif (unlikely(err == -ENOMEM)) {\n\t\tiput(vi);\n\t\tvi = ERR_PTR(err);\n\t}\n\treturn vi;\n}\n\n \nstruct inode *ntfs_attr_iget(struct inode *base_vi, ATTR_TYPE type,\n\t\tntfschar *name, u32 name_len)\n{\n\tstruct inode *vi;\n\tint err;\n\tntfs_attr na;\n\n\t \n\tBUG_ON(type == AT_INDEX_ALLOCATION);\n\n\tna.mft_no = base_vi->i_ino;\n\tna.type = type;\n\tna.name = name;\n\tna.name_len = name_len;\n\n\tvi = iget5_locked(base_vi->i_sb, na.mft_no, ntfs_test_inode,\n\t\t\tntfs_init_locked_inode, &na);\n\tif (unlikely(!vi))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = 0;\n\n\t \n\tif (vi->i_state & I_NEW) {\n\t\terr = ntfs_read_locked_attr_inode(base_vi, vi);\n\t\tunlock_new_inode(vi);\n\t}\n\t \n\tif (unlikely(err)) {\n\t\tiput(vi);\n\t\tvi = ERR_PTR(err);\n\t}\n\treturn vi;\n}\n\n \nstruct inode *ntfs_index_iget(struct inode *base_vi, ntfschar *name,\n\t\tu32 name_len)\n{\n\tstruct inode *vi;\n\tint err;\n\tntfs_attr na;\n\n\tna.mft_no = base_vi->i_ino;\n\tna.type = AT_INDEX_ALLOCATION;\n\tna.name = name;\n\tna.name_len = name_len;\n\n\tvi = iget5_locked(base_vi->i_sb, na.mft_no, ntfs_test_inode,\n\t\t\tntfs_init_locked_inode, &na);\n\tif (unlikely(!vi))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = 0;\n\n\t \n\tif (vi->i_state & I_NEW) {\n\t\terr = ntfs_read_locked_index_inode(base_vi, vi);\n\t\tunlock_new_inode(vi);\n\t}\n\t \n\tif (unlikely(err)) {\n\t\tiput(vi);\n\t\tvi = ERR_PTR(err);\n\t}\n\treturn vi;\n}\n\nstruct inode *ntfs_alloc_big_inode(struct super_block *sb)\n{\n\tntfs_inode *ni;\n\n\tntfs_debug(\"Entering.\");\n\tni = alloc_inode_sb(sb, ntfs_big_inode_cache, GFP_NOFS);\n\tif (likely(ni != NULL)) {\n\t\tni->state = 0;\n\t\treturn VFS_I(ni);\n\t}\n\tntfs_error(sb, \"Allocation of NTFS big inode structure failed.\");\n\treturn NULL;\n}\n\nvoid ntfs_free_big_inode(struct inode *inode)\n{\n\tkmem_cache_free(ntfs_big_inode_cache, NTFS_I(inode));\n}\n\nstatic inline ntfs_inode *ntfs_alloc_extent_inode(void)\n{\n\tntfs_inode *ni;\n\n\tntfs_debug(\"Entering.\");\n\tni = kmem_cache_alloc(ntfs_inode_cache, GFP_NOFS);\n\tif (likely(ni != NULL)) {\n\t\tni->state = 0;\n\t\treturn ni;\n\t}\n\tntfs_error(NULL, \"Allocation of NTFS inode structure failed.\");\n\treturn NULL;\n}\n\nstatic void ntfs_destroy_extent_inode(ntfs_inode *ni)\n{\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(ni->page);\n\tif (!atomic_dec_and_test(&ni->count))\n\t\tBUG();\n\tkmem_cache_free(ntfs_inode_cache, ni);\n}\n\n \nstatic struct lock_class_key attr_list_rl_lock_class;\n\n \nvoid __ntfs_init_inode(struct super_block *sb, ntfs_inode *ni)\n{\n\tntfs_debug(\"Entering.\");\n\trwlock_init(&ni->size_lock);\n\tni->initialized_size = ni->allocated_size = 0;\n\tni->seq_no = 0;\n\tatomic_set(&ni->count, 1);\n\tni->vol = NTFS_SB(sb);\n\tntfs_init_runlist(&ni->runlist);\n\tmutex_init(&ni->mrec_lock);\n\tni->page = NULL;\n\tni->page_ofs = 0;\n\tni->attr_list_size = 0;\n\tni->attr_list = NULL;\n\tntfs_init_runlist(&ni->attr_list_rl);\n\tlockdep_set_class(&ni->attr_list_rl.lock,\n\t\t\t\t&attr_list_rl_lock_class);\n\tni->itype.index.block_size = 0;\n\tni->itype.index.vcn_size = 0;\n\tni->itype.index.collation_rule = 0;\n\tni->itype.index.block_size_bits = 0;\n\tni->itype.index.vcn_size_bits = 0;\n\tmutex_init(&ni->extent_lock);\n\tni->nr_extents = 0;\n\tni->ext.base_ntfs_ino = NULL;\n}\n\n \nstatic struct lock_class_key extent_inode_mrec_lock_key;\n\ninline ntfs_inode *ntfs_new_extent_inode(struct super_block *sb,\n\t\tunsigned long mft_no)\n{\n\tntfs_inode *ni = ntfs_alloc_extent_inode();\n\n\tntfs_debug(\"Entering.\");\n\tif (likely(ni != NULL)) {\n\t\t__ntfs_init_inode(sb, ni);\n\t\tlockdep_set_class(&ni->mrec_lock, &extent_inode_mrec_lock_key);\n\t\tni->mft_no = mft_no;\n\t\tni->type = AT_UNUSED;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\t}\n\treturn ni;\n}\n\n \nstatic int ntfs_is_extended_system_file(ntfs_attr_search_ctx *ctx)\n{\n\tint nr_links, err;\n\n\t \n\tntfs_attr_reinit_search_ctx(ctx);\n\n\t \n\tnr_links = le16_to_cpu(ctx->mrec->link_count);\n\n\t \n\twhile (!(err = ntfs_attr_lookup(AT_FILE_NAME, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx))) {\n\t\tFILE_NAME_ATTR *file_name_attr;\n\t\tATTR_RECORD *attr = ctx->attr;\n\t\tu8 *p, *p2;\n\n\t\tnr_links--;\n\t\t \n\t\tp = (u8*)attr + le32_to_cpu(attr->length);\n\t\tif (p < (u8*)ctx->mrec || (u8*)p > (u8*)ctx->mrec +\n\t\t\t\tle32_to_cpu(ctx->mrec->bytes_in_use)) {\nerr_corrupt_attr:\n\t\t\tntfs_error(ctx->ntfs_ino->vol->sb, \"Corrupt file name \"\n\t\t\t\t\t\"attribute. You should run chkdsk.\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (attr->non_resident) {\n\t\t\tntfs_error(ctx->ntfs_ino->vol->sb, \"Non-resident file \"\n\t\t\t\t\t\"name. You should run chkdsk.\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (attr->flags) {\n\t\t\tntfs_error(ctx->ntfs_ino->vol->sb, \"File name with \"\n\t\t\t\t\t\"invalid flags. You should run \"\n\t\t\t\t\t\"chkdsk.\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (!(attr->data.resident.flags & RESIDENT_ATTR_IS_INDEXED)) {\n\t\t\tntfs_error(ctx->ntfs_ino->vol->sb, \"Unindexed file \"\n\t\t\t\t\t\"name. You should run chkdsk.\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tfile_name_attr = (FILE_NAME_ATTR*)((u8*)attr +\n\t\t\t\tle16_to_cpu(attr->data.resident.value_offset));\n\t\tp2 = (u8 *)file_name_attr + le32_to_cpu(attr->data.resident.value_length);\n\t\tif (p2 < (u8*)attr || p2 > p)\n\t\t\tgoto err_corrupt_attr;\n\t\t \n\t\tif (MREF_LE(file_name_attr->parent_directory) == FILE_Extend)\n\t\t\treturn 1;\t \n\t}\n\tif (unlikely(err != -ENOENT))\n\t\treturn err;\n\tif (unlikely(nr_links)) {\n\t\tntfs_error(ctx->ntfs_ino->vol->sb, \"Inode hard link count \"\n\t\t\t\t\"doesn't match number of name attributes. You \"\n\t\t\t\t\"should run chkdsk.\");\n\t\treturn -EIO;\n\t}\n\treturn 0;\t \n}\n\n \nstatic int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t \n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t \n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t \n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t \n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t \n\t \n\tvi->i_mode |= S_IRWXUGO;\n\t \n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t \n\t\tvi->i_mode &= ~vol->dmask;\n\t\t \n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t \n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t \n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t \n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t \n\tif ((u8 *)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t+ le32_to_cpu(a->data.resident.value_length) >\n\t\t\t(u8 *)ctx->mrec + vol->mft_record_size) {\n\t\tntfs_error(vi->i_sb, \"Corrupt standard information attribute in inode.\");\n\t\tgoto unm_err_out;\n\t}\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t \n\t \n\t \n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t \n\tinode_set_ctime_to_ts(vi, ntfs2utc(si->last_mft_change_time));\n\t \n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t \n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else   {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t \n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t \n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t \n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else   {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t \n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t \n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t \n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t \n\t\t\t\t \n\t\t\t\t \n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t \n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t \n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t \n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t \n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t \n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t \n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t \n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t}  \n\t\tNInoSetIndexAllocPresent(ni);\n\t\t \n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t \n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t \n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t \n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t \n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t \n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t \n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t \n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t \n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t \n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t \n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t \n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t \n\t\t\t \n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t \n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else {  \n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t \n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t \n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t \n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}\n\n \nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni, *base_ni;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\tntfs_init_big_inode(vi);\n\n\tni\t= NTFS_I(vi);\n\tbase_ni = NTFS_I(base_vi);\n\n\t \n\tvi->i_uid\t= base_vi->i_uid;\n\tvi->i_gid\t= base_vi->i_gid;\n\tset_nlink(vi, base_vi->i_nlink);\n\tvi->i_mtime\t= base_vi->i_mtime;\n\tinode_set_ctime_to_ts(vi, inode_get_ctime(base_vi));\n\tvi->i_atime\t= base_vi->i_atime;\n\tvi->i_generation = ni->seq_no = base_ni->seq_no;\n\n\t \n\tvi->i_mode\t= base_vi->i_mode & ~S_IFMT;\n\n\tm = map_mft_record(base_ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\t \n\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err))\n\t\tgoto unm_err_out;\n\ta = ctx->attr;\n\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tNInoSetCompressed(ni);\n\t\t\tif ((ni->type != AT_DATA) || (ni->type == AT_DATA &&\n\t\t\t\t\tni->name_len)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found compressed \"\n\t\t\t\t\t\t\"non-data or named data \"\n\t\t\t\t\t\t\"attribute.  Please report \"\n\t\t\t\t\t\t\"you saw this message to \"\n\t\t\t\t\t\t\"linux-ntfs-dev@lists.\"\n\t\t\t\t\t\t\"sourceforge.net\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found compressed \"\n\t\t\t\t\t\t\"attribute but compression is \"\n\t\t\t\t\t\t\"disabled due to cluster size \"\n\t\t\t\t\t\t\"(%i) > 4kiB.\",\n\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK) !=\n\t\t\t\t\tATTR_IS_COMPRESSED) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\"compression method.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (NInoMstProtected(ni) && ni->type != AT_INDEX_ROOT) {\n\t\t\tntfs_error(vi->i_sb, \"Found mst protected attribute \"\n\t\t\t\t\t\"but the attribute is %s.  Please \"\n\t\t\t\t\t\"report you saw this message to \"\n\t\t\t\t\t\"linux-ntfs-dev@lists.sourceforge.net\",\n\t\t\t\t\tNInoCompressed(ni) ? \"compressed\" :\n\t\t\t\t\t\"sparse\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t}\n\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\tif (NInoCompressed(ni)) {\n\t\t\tntfs_error(vi->i_sb, \"Found encrypted and compressed \"\n\t\t\t\t\t\"data.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t \n\t\tif (NInoMstProtected(ni) && ni->type != AT_INDEX_ROOT) {\n\t\t\tntfs_error(vi->i_sb, \"Found mst protected attribute \"\n\t\t\t\t\t\"but the attribute is encrypted.  \"\n\t\t\t\t\t\"Please report you saw this message \"\n\t\t\t\t\t\"to linux-ntfs-dev@lists.sourceforge.\"\n\t\t\t\t\t\"net\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->type != AT_DATA) {\n\t\t\tntfs_error(vi->i_sb, \"Found encrypted non-data \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tNInoSetEncrypted(ni);\n\t}\n\tif (!a->non_resident) {\n\t\t \n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"Attribute name is placed after \"\n\t\t\t\t\t\"the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (NInoMstProtected(ni)) {\n\t\t\tntfs_error(vi->i_sb, \"Found mst protected attribute \"\n\t\t\t\t\t\"but the attribute is resident.  \"\n\t\t\t\t\t\"Please report you saw this message to \"\n\t\t\t\t\t\"linux-ntfs-dev@lists.sourceforge.net\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\ta->data.resident.value_length);\n\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset);\n\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\tntfs_error(vi->i_sb, \"Resident attribute is corrupt \"\n\t\t\t\t\t\"(size exceeds allocation).\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else {\n\t\tNInoSetNonResident(ni);\n\t\t \n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"Attribute name is placed after \"\n\t\t\t\t\t\"the mapping pairs array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found non-standard \"\n\t\t\t\t\t\t\"compression unit (%u instead \"\n\t\t\t\t\t\t\"of 4).  Cannot handle this.\",\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompression_unit);\n\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\tffs(ni->itype.compressed.\n\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\tni->itype.compressed.block_clusters = 1U <<\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompression_unit;\n\t\t\t} else {\n\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\tni->itype.compressed.block_size_bits = 0;\n\t\t\t\tni->itype.compressed.block_clusters = 0;\n\t\t\t}\n\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.compressed_size);\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of attribute has \"\n\t\t\t\t\t\"non-zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t}\n\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\tif (NInoMstProtected(ni))\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\telse if (NInoCompressed(ni))\n\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\tif ((NInoCompressed(ni) || NInoSparse(ni)) && ni->type != AT_INDEX_ROOT)\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\t \n\tigrab(base_vi);\n\tni->ext.base_ntfs_ino = base_ni;\n\tni->nr_extents = -1;\n\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(base_ni);\n\n\tntfs_debug(\"Done.\");\n\treturn 0;\n\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(base_ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i while reading attribute \"\n\t\t\t\"inode (mft_no 0x%lx, type 0x%x, name_len %i).  \"\n\t\t\t\"Marking corrupt inode and base inode 0x%lx as bad.  \"\n\t\t\t\"Run chkdsk.\", err, vi->i_ino, ni->type, ni->name_len,\n\t\t\tbase_vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}\n\n \nstatic int ntfs_read_locked_index_inode(struct inode *base_vi, struct inode *vi)\n{\n\tloff_t bvi_size;\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni, *base_ni, *bni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tntfs_attr_search_ctx *ctx;\n\tINDEX_ROOT *ir;\n\tu8 *ir_end, *index_end;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\tntfs_init_big_inode(vi);\n\tni\t= NTFS_I(vi);\n\tbase_ni = NTFS_I(base_vi);\n\t \n\tvi->i_uid\t= base_vi->i_uid;\n\tvi->i_gid\t= base_vi->i_gid;\n\tset_nlink(vi, base_vi->i_nlink);\n\tvi->i_mtime\t= base_vi->i_mtime;\n\tinode_set_ctime_to_ts(vi, inode_get_ctime(base_vi));\n\tvi->i_atime\t= base_vi->i_atime;\n\tvi->i_generation = ni->seq_no = base_ni->seq_no;\n\t \n\tvi->i_mode\t= base_vi->i_mode & ~S_IFMT;\n\t \n\tm = map_mft_record(base_ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\t \n\terr = ntfs_attr_lookup(AT_INDEX_ROOT, ni->name, ni->name_len,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT)\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"missing.\");\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t \n\tif (unlikely(a->non_resident)) {\n\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not resident.\");\n\t\tgoto unm_err_out;\n\t}\n\t \n\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is placed \"\n\t\t\t\t\"after the attribute value.\");\n\t\tgoto unm_err_out;\n\t}\n\t \n\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_ENCRYPTED |\n\t\t\tATTR_IS_SPARSE)) {\n\t\tntfs_error(vi->i_sb, \"Found compressed/encrypted/sparse index \"\n\t\t\t\t\"root attribute.\");\n\t\tgoto unm_err_out;\n\t}\n\tir = (INDEX_ROOT*)((u8*)a + le16_to_cpu(a->data.resident.value_offset));\n\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is corrupt.\");\n\t\tgoto unm_err_out;\n\t}\n\tindex_end = (u8*)&ir->index + le32_to_cpu(ir->index.index_length);\n\tif (index_end > ir_end) {\n\t\tntfs_error(vi->i_sb, \"Index is corrupt.\");\n\t\tgoto unm_err_out;\n\t}\n\tif (ir->type) {\n\t\tntfs_error(vi->i_sb, \"Index type is not 0 (type is 0x%x).\",\n\t\t\t\tle32_to_cpu(ir->type));\n\t\tgoto unm_err_out;\n\t}\n\tni->itype.index.collation_rule = ir->collation_rule;\n\tntfs_debug(\"Index collation rule is 0x%x.\",\n\t\t\tle32_to_cpu(ir->collation_rule));\n\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\tif (!is_power_of_2(ni->itype.index.block_size)) {\n\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a power of \"\n\t\t\t\t\"two.\", ni->itype.index.block_size);\n\t\tgoto unm_err_out;\n\t}\n\tif (ni->itype.index.block_size > PAGE_SIZE) {\n\t\tntfs_error(vi->i_sb, \"Index block size (%u) > PAGE_SIZE \"\n\t\t\t\t\"(%ld) is not supported.  Sorry.\",\n\t\t\t\tni->itype.index.block_size, PAGE_SIZE);\n\t\terr = -EOPNOTSUPP;\n\t\tgoto unm_err_out;\n\t}\n\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\tntfs_error(vi->i_sb, \"Index block size (%u) < NTFS_BLOCK_SIZE \"\n\t\t\t\t\"(%i) is not supported.  Sorry.\",\n\t\t\t\tni->itype.index.block_size, NTFS_BLOCK_SIZE);\n\t\terr = -EOPNOTSUPP;\n\t\tgoto unm_err_out;\n\t}\n\tni->itype.index.block_size_bits = ffs(ni->itype.index.block_size) - 1;\n\t \n\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t} else {\n\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t}\n\t \n\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t \n\t\tvi->i_size = ni->initialized_size = ni->allocated_size = 0;\n\t\t \n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(base_ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\tgoto skip_large_index_stuff;\n\t}  \n\tNInoSetIndexAllocPresent(ni);\n\t \n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, ni->name, ni->name_len,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT)\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute is \"\n\t\t\t\t\t\"not present but $INDEX_ROOT \"\n\t\t\t\t\t\"indicated it is.\");\n\t\telse\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute.\");\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\tif (!a->non_resident) {\n\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute is \"\n\t\t\t\t\"resident.\");\n\t\tgoto unm_err_out;\n\t}\n\t \n\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\tle16_to_cpu(\n\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name is \"\n\t\t\t\t\"placed after the mapping pairs array.\");\n\t\tgoto unm_err_out;\n\t}\n\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute is \"\n\t\t\t\t\"encrypted.\");\n\t\tgoto unm_err_out;\n\t}\n\tif (a->flags & ATTR_IS_SPARSE) {\n\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute is sparse.\");\n\t\tgoto unm_err_out;\n\t}\n\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute is \"\n\t\t\t\t\"compressed.\");\n\t\tgoto unm_err_out;\n\t}\n\tif (a->data.non_resident.lowest_vcn) {\n\t\tntfs_error(vi->i_sb, \"First extent of $INDEX_ALLOCATION \"\n\t\t\t\t\"attribute has non zero lowest_vcn.\");\n\t\tgoto unm_err_out;\n\t}\n\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\tni->initialized_size = sle64_to_cpu(\n\t\t\ta->data.non_resident.initialized_size);\n\tni->allocated_size = sle64_to_cpu(a->data.non_resident.allocated_size);\n\t \n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(base_ni);\n\tm = NULL;\n\tctx = NULL;\n\t \n\tbvi = ntfs_attr_iget(base_vi, AT_BITMAP, ni->name, ni->name_len);\n\tif (IS_ERR(bvi)) {\n\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\terr = PTR_ERR(bvi);\n\t\tgoto unm_err_out;\n\t}\n\tbni = NTFS_I(bvi);\n\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\tNInoSparse(bni)) {\n\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed and/or \"\n\t\t\t\t\"encrypted and/or sparse.\");\n\t\tgoto iput_unm_err_out;\n\t}\n\t \n\tbvi_size = i_size_read(bvi);\n\tif ((bvi_size << 3) < (vi->i_size >> ni->itype.index.block_size_bits)) {\n\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) for \"\n\t\t\t\t\"index allocation (0x%llx).\", bvi_size << 3,\n\t\t\t\tvi->i_size);\n\t\tgoto iput_unm_err_out;\n\t}\n\tiput(bvi);\nskip_large_index_stuff:\n\t \n\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\tvi->i_blocks = ni->allocated_size >> 9;\n\t \n\tigrab(base_vi);\n\tni->ext.base_ntfs_ino = base_ni;\n\tni->nr_extents = -1;\n\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(base_ni);\nerr_out:\n\tntfs_error(vi->i_sb, \"Failed with error code %i while reading index \"\n\t\t\t\"inode (mft_no 0x%lx, name_len %i.\", err, vi->i_ino,\n\t\t\tni->name_len);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}\n\n \nstatic struct lock_class_key mft_ni_runlist_lock_key, mft_ni_mrec_lock_key;\n\n \nint ntfs_read_inode_mount(struct inode *vi)\n{\n\tVCN next_vcn, last_vcn, highest_vcn;\n\ts64 block;\n\tstruct super_block *sb = vi->i_sb;\n\tntfs_volume *vol = NTFS_SB(sb);\n\tstruct buffer_head *bh;\n\tntfs_inode *ni;\n\tMFT_RECORD *m = NULL;\n\tATTR_RECORD *a;\n\tntfs_attr_search_ctx *ctx;\n\tunsigned int i, nr_blocks;\n\tint err;\n\n\tntfs_debug(\"Entering.\");\n\n\t \n\tntfs_init_big_inode(vi);\n\n\tni = NTFS_I(vi);\n\n\t \n\tNInoSetNonResident(ni);\n\tNInoSetMstProtected(ni);\n\tNInoSetSparseDisabled(ni);\n\tni->type = AT_DATA;\n\tni->name = NULL;\n\tni->name_len = 0;\n\t \n\tni->itype.index.block_size = vol->mft_record_size;\n\tni->itype.index.block_size_bits = vol->mft_record_size_bits;\n\n\t \n\tvol->mft_ino = vi;\n\n\t \n\tif (vol->mft_record_size > 64 * 1024) {\n\t\tntfs_error(sb, \"Unsupported mft record size %i (max 64kiB).\",\n\t\t\t\tvol->mft_record_size);\n\t\tgoto err_out;\n\t}\n\ti = vol->mft_record_size;\n\tif (i < sb->s_blocksize)\n\t\ti = sb->s_blocksize;\n\tm = (MFT_RECORD*)ntfs_malloc_nofs(i);\n\tif (!m) {\n\t\tntfs_error(sb, \"Failed to allocate buffer for $MFT record 0.\");\n\t\tgoto err_out;\n\t}\n\n\t \n\tblock = vol->mft_lcn << vol->cluster_size_bits >>\n\t\t\tsb->s_blocksize_bits;\n\tnr_blocks = vol->mft_record_size >> sb->s_blocksize_bits;\n\tif (!nr_blocks)\n\t\tnr_blocks = 1;\n\n\t \n\tfor (i = 0; i < nr_blocks; i++) {\n\t\tbh = sb_bread(sb, block++);\n\t\tif (!bh) {\n\t\t\tntfs_error(sb, \"Device read failed.\");\n\t\t\tgoto err_out;\n\t\t}\n\t\tmemcpy((char*)m + (i << sb->s_blocksize_bits), bh->b_data,\n\t\t\t\tsb->s_blocksize);\n\t\tbrelse(bh);\n\t}\n\n\tif (le32_to_cpu(m->bytes_allocated) != vol->mft_record_size) {\n\t\tntfs_error(sb, \"Incorrect mft record size %u in superblock, should be %u.\",\n\t\t\t\tle32_to_cpu(m->bytes_allocated), vol->mft_record_size);\n\t\tgoto err_out;\n\t}\n\n\t \n\tif (post_read_mst_fixup((NTFS_RECORD*)m, vol->mft_record_size)) {\n\t\t \n\t\tntfs_error(sb, \"MST fixup failed. $MFT is corrupt.\");\n\t\tgoto err_out;\n\t}\n\n\t \n\tif (le16_to_cpu(m->attrs_offset) >= le32_to_cpu(m->bytes_allocated)) {\n\t\tntfs_error(sb, \"Incorrect mft offset to the first attribute %u in superblock.\",\n\t\t\t       le16_to_cpu(m->attrs_offset));\n\t\tgoto err_out;\n\t}\n\n\t \n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t \n\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\t \n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute. You should run chkdsk.\");\n\t\t\tgoto put_err_out;\n\t\t}\n\t} else   {\n\t\tATTR_LIST_ENTRY *al_entry, *next_al_entry;\n\t\tu8 *al_end;\n\t\tstatic const char *es = \"  Not allowed.  $MFT is corrupt.  \"\n\t\t\t\t\"You should run chkdsk.\";\n\n\t\tntfs_debug(\"Attribute list attribute found in $MFT.\");\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.%s\", es);\n\t\t\tgoto put_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(sb, \"Non-resident attribute list \"\n\t\t\t\t\t\t\"attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.%s\", es);\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\tntfs_warning(sb, \"Resident attribute list attribute \"\n\t\t\t\t\t\"in $MFT system file is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\");\n\t\t}\n\t\t \n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tif (!ni->attr_list_size) {\n\t\t\tntfs_error(sb, \"Attr_list_size is zero\");\n\t\t\tgoto put_err_out;\n\t\t}\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(sb, \"Not enough memory to allocate buffer \"\n\t\t\t\t\t\"for attribute list.\");\n\t\t\tgoto put_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(sb, \"Attribute list has non zero \"\n\t\t\t\t\t\t\"lowest_vcn. $MFT is corrupt. \"\n\t\t\t\t\t\t\"You should run chkdsk.\");\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\t \n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(sb, \"Mapping pairs decompression \"\n\t\t\t\t\t\t\"failed with error code %i.\",\n\t\t\t\t\t\t-err);\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\t \n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.\n\t\t\t\t\tnon_resident.initialized_size)))) {\n\t\t\t\tntfs_error(sb, \"Failed to load attribute list \"\n\t\t\t\t\t\t\"attribute with error code %i.\",\n\t\t\t\t\t\t-err);\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t} else   {\n\t\t\tif ((u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset) +\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\t \n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t\t \n\t\t \n\t\tal_entry = (ATTR_LIST_ENTRY*)ni->attr_list;\n\t\tal_end = (u8*)al_entry + ni->attr_list_size;\n\t\tfor (;; al_entry = next_al_entry) {\n\t\t\t \n\t\t\tif ((u8*)al_entry < ni->attr_list ||\n\t\t\t\t\t(u8*)al_entry > al_end)\n\t\t\t\tgoto em_put_err_out;\n\t\t\t \n\t\t\tif ((u8*)al_entry == al_end)\n\t\t\t\tgoto em_put_err_out;\n\t\t\tif (!al_entry->length)\n\t\t\t\tgoto em_put_err_out;\n\t\t\tif ((u8*)al_entry + 6 > al_end || (u8*)al_entry +\n\t\t\t\t\tle16_to_cpu(al_entry->length) > al_end)\n\t\t\t\tgoto em_put_err_out;\n\t\t\tnext_al_entry = (ATTR_LIST_ENTRY*)((u8*)al_entry +\n\t\t\t\t\tle16_to_cpu(al_entry->length));\n\t\t\tif (le32_to_cpu(al_entry->type) > le32_to_cpu(AT_DATA))\n\t\t\t\tgoto em_put_err_out;\n\t\t\tif (AT_DATA != al_entry->type)\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tif (al_entry->name_length)\n\t\t\t\tgoto em_put_err_out;\n\t\t\t \n\t\t\tif (al_entry->lowest_vcn)\n\t\t\t\tgoto em_put_err_out;\n\t\t\t \n\t\t\tif (MREF_LE(al_entry->mft_reference) != vi->i_ino) {\n\t\t\t\t \n\t\t\t\tntfs_error(sb, \"BUG: The first $DATA extent \"\n\t\t\t\t\t\t\"of $MFT is not in the base \"\n\t\t\t\t\t\t\"mft record. Please report \"\n\t\t\t\t\t\t\"you saw this message to \"\n\t\t\t\t\t\t\"linux-ntfs-dev@lists.\"\n\t\t\t\t\t\t\"sourceforge.net\");\n\t\t\t\tgoto put_err_out;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (MSEQNO_LE(al_entry->mft_reference) !=\n\t\t\t\t\t\tni->seq_no)\n\t\t\t\t\tgoto em_put_err_out;\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tntfs_attr_reinit_search_ctx(ctx);\n\n\t \n\ta = NULL;\n\tnext_vcn = last_vcn = highest_vcn = 0;\n\twhile (!(err = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, next_vcn, NULL, 0,\n\t\t\tctx))) {\n\t\trunlist_element *nrl;\n\n\t\t \n\t\ta = ctx->attr;\n\t\t \n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(sb, \"$MFT must be non-resident but a \"\n\t\t\t\t\t\"resident extent was found. $MFT is \"\n\t\t\t\t\t\"corrupt. Run chkdsk.\");\n\t\t\tgoto put_err_out;\n\t\t}\n\t\t \n\t\tif (a->flags & ATTR_COMPRESSION_MASK ||\n\t\t\t\ta->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(sb, \"$MFT must be uncompressed, \"\n\t\t\t\t\t\"non-sparse, and unencrypted but a \"\n\t\t\t\t\t\"compressed/sparse/encrypted extent \"\n\t\t\t\t\t\"was found. $MFT is corrupt. Run \"\n\t\t\t\t\t\"chkdsk.\");\n\t\t\tgoto put_err_out;\n\t\t}\n\t\t \n\t\tnrl = ntfs_mapping_pairs_decompress(vol, a, ni->runlist.rl);\n\t\tif (IS_ERR(nrl)) {\n\t\t\tntfs_error(sb, \"ntfs_mapping_pairs_decompress() \"\n\t\t\t\t\t\"failed with error code %ld.  $MFT is \"\n\t\t\t\t\t\"corrupt.\", PTR_ERR(nrl));\n\t\t\tgoto put_err_out;\n\t\t}\n\t\tni->runlist.rl = nrl;\n\n\t\t \n\t\tif (!next_vcn) {\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn. $MFT is corrupt. \"\n\t\t\t\t\t\t\"You should run chkdsk.\");\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\t \n\t\t\tlast_vcn = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size)\n\t\t\t\t\t>> vol->cluster_size_bits;\n\t\t\t \n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t\t \n\t\t\tif ((vi->i_size >> vol->mft_record_size_bits) >=\n\t\t\t\t\t(1ULL << 32)) {\n\t\t\t\tntfs_error(sb, \"$MFT is too big! Aborting.\");\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\t \n\t\t\tntfs_read_locked_inode(vi);\n\t\t\tif (is_bad_inode(vi)) {\n\t\t\t\tntfs_error(sb, \"ntfs_read_inode() of $MFT \"\n\t\t\t\t\t\t\"failed. BUG or corrupt $MFT. \"\n\t\t\t\t\t\t\"Run chkdsk and if no errors \"\n\t\t\t\t\t\t\"are found, please report you \"\n\t\t\t\t\t\t\"saw this message to \"\n\t\t\t\t\t\t\"linux-ntfs-dev@lists.\"\n\t\t\t\t\t\t\"sourceforge.net\");\n\t\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\t\t \n\t\t\t\tntfs_free(m);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t \n\t\t\t \n\t\t\tvi->i_uid = GLOBAL_ROOT_UID;\n\t\t\tvi->i_gid = GLOBAL_ROOT_GID;\n\t\t\t \n\t\t\tvi->i_mode = S_IFREG;\n\t\t\t \n\t\t\tvi->i_op = &ntfs_empty_inode_ops;\n\t\t\tvi->i_fop = &ntfs_empty_file_ops;\n\t\t}\n\n\t\t \n\t\thighest_vcn = sle64_to_cpu(a->data.non_resident.highest_vcn);\n\t\tnext_vcn = highest_vcn + 1;\n\n\t\t \n\t\tif (next_vcn <= 0)\n\t\t\tbreak;\n\n\t\t \n\t\tif (next_vcn < sle64_to_cpu(\n\t\t\t\ta->data.non_resident.lowest_vcn)) {\n\t\t\tntfs_error(sb, \"$MFT has corrupt attribute list \"\n\t\t\t\t\t\"attribute. Run chkdsk.\");\n\t\t\tgoto put_err_out;\n\t\t}\n\t}\n\tif (err != -ENOENT) {\n\t\tntfs_error(sb, \"Failed to lookup $MFT/$DATA attribute extent. \"\n\t\t\t\t\"$MFT is corrupt. Run chkdsk.\");\n\t\tgoto put_err_out;\n\t}\n\tif (!a) {\n\t\tntfs_error(sb, \"$MFT/$DATA attribute not found. $MFT is \"\n\t\t\t\t\"corrupt. Run chkdsk.\");\n\t\tgoto put_err_out;\n\t}\n\tif (highest_vcn && highest_vcn != last_vcn - 1) {\n\t\tntfs_error(sb, \"Failed to load the complete runlist for \"\n\t\t\t\t\"$MFT/$DATA. Driver bug or corrupt $MFT. \"\n\t\t\t\t\"Run chkdsk.\");\n\t\tntfs_debug(\"highest_vcn = 0x%llx, last_vcn - 1 = 0x%llx\",\n\t\t\t\t(unsigned long long)highest_vcn,\n\t\t\t\t(unsigned long long)last_vcn - 1);\n\t\tgoto put_err_out;\n\t}\n\tntfs_attr_put_search_ctx(ctx);\n\tntfs_debug(\"Done.\");\n\tntfs_free(m);\n\n\t \n\tlockdep_set_class(&ni->runlist.lock, &mft_ni_runlist_lock_key);\n\tlockdep_set_class(&ni->mrec_lock, &mft_ni_mrec_lock_key);\n\n\treturn 0;\n\nem_put_err_out:\n\tntfs_error(sb, \"Couldn't find first extent of $DATA attribute in \"\n\t\t\t\"attribute list. $MFT is corrupt. Run chkdsk.\");\nput_err_out:\n\tntfs_attr_put_search_ctx(ctx);\nerr_out:\n\tntfs_error(sb, \"Failed. Marking inode as bad.\");\n\tmake_bad_inode(vi);\n\tntfs_free(m);\n\treturn -1;\n}\n\nstatic void __ntfs_clear_inode(ntfs_inode *ni)\n{\n\t \n\tdown_write(&ni->runlist.lock);\n\tif (ni->runlist.rl) {\n\t\tntfs_free(ni->runlist.rl);\n\t\tni->runlist.rl = NULL;\n\t}\n\tup_write(&ni->runlist.lock);\n\n\tif (ni->attr_list) {\n\t\tntfs_free(ni->attr_list);\n\t\tni->attr_list = NULL;\n\t}\n\n\tdown_write(&ni->attr_list_rl.lock);\n\tif (ni->attr_list_rl.rl) {\n\t\tntfs_free(ni->attr_list_rl.rl);\n\t\tni->attr_list_rl.rl = NULL;\n\t}\n\tup_write(&ni->attr_list_rl.lock);\n\n\tif (ni->name_len && ni->name != I30) {\n\t\t \n\t\tBUG_ON(!ni->name);\n\t\tkfree(ni->name);\n\t}\n}\n\nvoid ntfs_clear_extent_inode(ntfs_inode *ni)\n{\n\tntfs_debug(\"Entering for inode 0x%lx.\", ni->mft_no);\n\n\tBUG_ON(NInoAttr(ni));\n\tBUG_ON(ni->nr_extents != -1);\n\n#ifdef NTFS_RW\n\tif (NInoDirty(ni)) {\n\t\tif (!is_bad_inode(VFS_I(ni->ext.base_ntfs_ino)))\n\t\t\tntfs_error(ni->vol->sb, \"Clearing dirty extent inode!  \"\n\t\t\t\t\t\"Losing data!  This is a BUG!!!\");\n\t\t \n\t}\n#endif  \n\n\t__ntfs_clear_inode(ni);\n\n\t \n\tntfs_destroy_extent_inode(ni);\n}\n\n \nvoid ntfs_evict_big_inode(struct inode *vi)\n{\n\tntfs_inode *ni = NTFS_I(vi);\n\n\ttruncate_inode_pages_final(&vi->i_data);\n\tclear_inode(vi);\n\n#ifdef NTFS_RW\n\tif (NInoDirty(ni)) {\n\t\tbool was_bad = (is_bad_inode(vi));\n\n\t\t \n\t\tntfs_commit_inode(vi);\n\n\t\tif (!was_bad && (is_bad_inode(vi) || NInoDirty(ni))) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to commit dirty inode \"\n\t\t\t\t\t\"0x%lx.  Losing data!\", vi->i_ino);\n\t\t\t \n\t\t}\n\t}\n#endif  \n\n\t \n\tif (ni->nr_extents > 0) {\n\t\tint i;\n\n\t\tfor (i = 0; i < ni->nr_extents; i++)\n\t\t\tntfs_clear_extent_inode(ni->ext.extent_ntfs_inos[i]);\n\t\tkfree(ni->ext.extent_ntfs_inos);\n\t}\n\n\t__ntfs_clear_inode(ni);\n\n\tif (NInoAttr(ni)) {\n\t\t \n\t\tif (ni->nr_extents == -1) {\n\t\t\tiput(VFS_I(ni->ext.base_ntfs_ino));\n\t\t\tni->nr_extents = 0;\n\t\t\tni->ext.base_ntfs_ino = NULL;\n\t\t}\n\t}\n\tBUG_ON(ni->page);\n\tif (!atomic_dec_and_test(&ni->count))\n\t\tBUG();\n\treturn;\n}\n\n \nint ntfs_show_options(struct seq_file *sf, struct dentry *root)\n{\n\tntfs_volume *vol = NTFS_SB(root->d_sb);\n\tint i;\n\n\tseq_printf(sf, \",uid=%i\", from_kuid_munged(&init_user_ns, vol->uid));\n\tseq_printf(sf, \",gid=%i\", from_kgid_munged(&init_user_ns, vol->gid));\n\tif (vol->fmask == vol->dmask)\n\t\tseq_printf(sf, \",umask=0%o\", vol->fmask);\n\telse {\n\t\tseq_printf(sf, \",fmask=0%o\", vol->fmask);\n\t\tseq_printf(sf, \",dmask=0%o\", vol->dmask);\n\t}\n\tseq_printf(sf, \",nls=%s\", vol->nls_map->charset);\n\tif (NVolCaseSensitive(vol))\n\t\tseq_printf(sf, \",case_sensitive\");\n\tif (NVolShowSystemFiles(vol))\n\t\tseq_printf(sf, \",show_sys_files\");\n\tif (!NVolSparseEnabled(vol))\n\t\tseq_printf(sf, \",disable_sparse\");\n\tfor (i = 0; on_errors_arr[i].val; i++) {\n\t\tif (on_errors_arr[i].val & vol->on_errors)\n\t\t\tseq_printf(sf, \",errors=%s\", on_errors_arr[i].str);\n\t}\n\tseq_printf(sf, \",mft_zone_multiplier=%i\", vol->mft_zone_multiplier);\n\treturn 0;\n}\n\n#ifdef NTFS_RW\n\nstatic const char *es = \"  Leaving inconsistent metadata.  Unmount and run \"\n\t\t\"chkdsk.\";\n\n \nint ntfs_truncate(struct inode *vi)\n{\n\ts64 new_size, old_size, nr_freed, new_alloc_size, old_alloc_size;\n\tVCN highest_vcn;\n\tunsigned long flags;\n\tntfs_inode *base_ni, *ni = NTFS_I(vi);\n\tntfs_volume *vol = ni->vol;\n\tntfs_attr_search_ctx *ctx;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tconst char *te = \"  Leaving file length out of sync with i_size.\";\n\tint err, mp_size, size_change, alloc_change;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", vi->i_ino);\n\tBUG_ON(NInoAttr(ni));\n\tBUG_ON(S_ISDIR(vi->i_mode));\n\tBUG_ON(NInoMstProtected(ni));\n\tBUG_ON(ni->nr_extents < 0);\nretry_truncate:\n\t \n\tdown_write(&ni->runlist.lock);\n\tif (!NInoAttr(ni))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tm = map_mft_record(base_ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tntfs_error(vi->i_sb, \"Failed to map mft record for inode 0x%lx \"\n\t\t\t\t\"(error code %d).%s\", vi->i_ino, err, te);\n\t\tctx = NULL;\n\t\tm = NULL;\n\t\tgoto old_bad_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\tif (unlikely(!ctx)) {\n\t\tntfs_error(vi->i_sb, \"Failed to allocate a search context for \"\n\t\t\t\t\"inode 0x%lx (not enough memory).%s\",\n\t\t\t\tvi->i_ino, te);\n\t\terr = -ENOMEM;\n\t\tgoto old_bad_out;\n\t}\n\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\tntfs_error(vi->i_sb, \"Open attribute is missing from \"\n\t\t\t\t\t\"mft record.  Inode 0x%lx is corrupt.  \"\n\t\t\t\t\t\"Run chkdsk.%s\", vi->i_ino, te);\n\t\t\terr = -EIO;\n\t\t} else\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute in \"\n\t\t\t\t\t\"inode 0x%lx (error code %d).%s\",\n\t\t\t\t\tvi->i_ino, err, te);\n\t\tgoto old_bad_out;\n\t}\n\tm = ctx->mrec;\n\ta = ctx->attr;\n\t \n\tnew_size = i_size_read(vi);\n\t \n\told_size = ntfs_attr_size(a);\n\t \n\tif (NInoNonResident(ni))\n\t\tnew_alloc_size = (new_size + vol->cluster_size - 1) &\n\t\t\t\t~(s64)vol->cluster_size_mask;\n\telse\n\t\tnew_alloc_size = (new_size + 7) & ~7;\n\t \n\tread_lock_irqsave(&ni->size_lock, flags);\n\told_alloc_size = ni->allocated_size;\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t \n\tsize_change = -1;\n\tif (new_size - old_size >= 0) {\n\t\tsize_change = 1;\n\t\tif (new_size == old_size)\n\t\t\tsize_change = 0;\n\t}\n\t \n\talloc_change = -1;\n\tif (new_alloc_size - old_alloc_size >= 0) {\n\t\talloc_change = 1;\n\t\tif (new_alloc_size == old_alloc_size)\n\t\t\talloc_change = 0;\n\t}\n\t \n\tif (!size_change && !alloc_change)\n\t\tgoto unm_done;\n\t \n\tif (size_change) {\n\t\terr = ntfs_attr_size_bounds_check(vol, ni->type, new_size);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ERANGE) {\n\t\t\t\tntfs_error(vol->sb, \"Truncate would cause the \"\n\t\t\t\t\t\t\"inode 0x%lx to %simum size \"\n\t\t\t\t\t\t\"for its attribute type \"\n\t\t\t\t\t\t\"(0x%x).  Aborting truncate.\",\n\t\t\t\t\t\tvi->i_ino,\n\t\t\t\t\t\tnew_size > old_size ? \"exceed \"\n\t\t\t\t\t\t\"the max\" : \"go under the min\",\n\t\t\t\t\t\tle32_to_cpu(ni->type));\n\t\t\t\terr = -EFBIG;\n\t\t\t} else {\n\t\t\t\tntfs_error(vol->sb, \"Inode 0x%lx has unknown \"\n\t\t\t\t\t\t\"attribute type 0x%x.  \"\n\t\t\t\t\t\t\"Aborting truncate.\",\n\t\t\t\t\t\tvi->i_ino,\n\t\t\t\t\t\tle32_to_cpu(ni->type));\n\t\t\t\terr = -EIO;\n\t\t\t}\n\t\t\t \n\t\t\ti_size_write(vi, old_size);\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\tif (NInoCompressed(ni) || NInoEncrypted(ni)) {\n\t\tntfs_warning(vi->i_sb, \"Changes in inode size are not \"\n\t\t\t\t\"supported yet for %s files, ignoring.\",\n\t\t\t\tNInoCompressed(ni) ? \"compressed\" :\n\t\t\t\t\"encrypted\");\n\t\terr = -EOPNOTSUPP;\n\t\tgoto bad_out;\n\t}\n\tif (a->non_resident)\n\t\tgoto do_non_resident_truncate;\n\tBUG_ON(NInoNonResident(ni));\n\t \n\tif (new_size < vol->mft_record_size &&\n\t\t\t!ntfs_resident_attr_value_resize(m, a, new_size)) {\n\t\t \n\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t\twrite_lock_irqsave(&ni->size_lock, flags);\n\t\t \n\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset);\n\t\t \n\t\tni->initialized_size = new_size;\n\t\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t\tgoto unm_done;\n\t}\n\t \n\tBUG_ON(size_change < 0);\n\t \n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(base_ni);\n\tup_write(&ni->runlist.lock);\n\t \n\terr = ntfs_attr_make_non_resident(ni, old_size);\n\tif (likely(!err))\n\t\tgoto retry_truncate;\n\t \n\tif (unlikely(err != -EPERM && err != -ENOSPC)) {\n\t\tntfs_error(vol->sb, \"Cannot truncate inode 0x%lx, attribute \"\n\t\t\t\t\"type 0x%x, because the conversion from \"\n\t\t\t\t\"resident to non-resident attribute failed \"\n\t\t\t\t\"with error code %i.\", vi->i_ino,\n\t\t\t\t(unsigned)le32_to_cpu(ni->type), err);\n\t\tif (err != -ENOMEM)\n\t\t\terr = -EIO;\n\t\tgoto conv_err_out;\n\t}\n\t \n\tif (err == -ENOSPC)\n\t\tntfs_error(vol->sb, \"Not enough space in the mft record/on \"\n\t\t\t\t\"disk for the non-resident attribute value.  \"\n\t\t\t\t\"This case is not implemented yet.\");\n\telse  \n\t\tntfs_error(vol->sb, \"This attribute type may not be \"\n\t\t\t\t\"non-resident.  This case is not implemented \"\n\t\t\t\t\"yet.\");\n\terr = -EOPNOTSUPP;\n\tgoto conv_err_out;\n#if 0\n\t \n\tif (!err)\n\t\tgoto do_resident_extend;\n\t \n\tif (ni->type == AT_ATTRIBUTE_LIST ||\n\t\t\tni->type == AT_STANDARD_INFORMATION) {\n\t\t \n\t\t \n\t\terr = -EOPNOTSUPP;\n\t\tif (!err)\n\t\t\tgoto do_resident_extend;\n\t\tgoto err_out;\n\t}\n\t \n\t \n\t \n\terr = -EOPNOTSUPP;\n\tif (!err)\n\t\tgoto do_resident_extend;\n\t \n\tgoto err_out;\n#endif\ndo_non_resident_truncate:\n\tBUG_ON(!NInoNonResident(ni));\n\tif (alloc_change < 0) {\n\t\thighest_vcn = sle64_to_cpu(a->data.non_resident.highest_vcn);\n\t\tif (highest_vcn > 0 &&\n\t\t\t\told_alloc_size >> vol->cluster_size_bits >\n\t\t\t\thighest_vcn + 1) {\n\t\t\t \n\t\t\tntfs_error(vol->sb, \"Cannot truncate inode 0x%lx, \"\n\t\t\t\t\t\"attribute type 0x%x, because the \"\n\t\t\t\t\t\"attribute is highly fragmented (it \"\n\t\t\t\t\t\"consists of multiple extents) and \"\n\t\t\t\t\t\"this case is not implemented yet.\",\n\t\t\t\t\tvi->i_ino,\n\t\t\t\t\t(unsigned)le32_to_cpu(ni->type));\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto bad_out;\n\t\t}\n\t}\n\t \n\tif (size_change < 0) {\n\t\t \n\t\twrite_lock_irqsave(&ni->size_lock, flags);\n\t\tif (new_size < ni->initialized_size) {\n\t\t\tni->initialized_size = new_size;\n\t\t\ta->data.non_resident.initialized_size =\n\t\t\t\t\tcpu_to_sle64(new_size);\n\t\t}\n\t\ta->data.non_resident.data_size = cpu_to_sle64(new_size);\n\t\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t\t \n\t\tif (!alloc_change)\n\t\t\tgoto unm_done;\n\t\t \n\t\tBUG_ON(alloc_change > 0);\n\t} else   {\n\t\t \n\t\tif (alloc_change > 0) {\n\t\t\t \n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(base_ni);\n\t\t\tup_write(&ni->runlist.lock);\n\t\t\terr = ntfs_attr_extend_allocation(ni, new_size,\n\t\t\t\t\tsize_change > 0 ? new_size : -1, -1);\n\t\t\t \n\t\t\tgoto done;\n\t\t}\n\t\tif (!alloc_change)\n\t\t\tgoto alloc_done;\n\t}\n\t \n\t \n\tnr_freed = ntfs_cluster_free(ni, new_alloc_size >>\n\t\t\tvol->cluster_size_bits, -1, ctx);\n\tm = ctx->mrec;\n\ta = ctx->attr;\n\tif (unlikely(nr_freed < 0)) {\n\t\tntfs_error(vol->sb, \"Failed to release cluster(s) (error code \"\n\t\t\t\t\"%lli).  Unmount and run chkdsk to recover \"\n\t\t\t\t\"the lost cluster(s).\", (long long)nr_freed);\n\t\tNVolSetErrors(vol);\n\t\tnr_freed = 0;\n\t}\n\t \n\terr = ntfs_rl_truncate_nolock(vol, &ni->runlist,\n\t\t\tnew_alloc_size >> vol->cluster_size_bits);\n\t \n\tif (unlikely(err || IS_ERR(m))) {\n\t\tntfs_error(vol->sb, \"Failed to %s (error code %li).%s\",\n\t\t\t\tIS_ERR(m) ?\n\t\t\t\t\"restore attribute search context\" :\n\t\t\t\t\"truncate attribute runlist\",\n\t\t\t\tIS_ERR(m) ? PTR_ERR(m) : err, es);\n\t\terr = -EIO;\n\t\tgoto bad_out;\n\t}\n\t \n\tmp_size = ntfs_get_size_for_mapping_pairs(vol, ni->runlist.rl, 0, -1);\n\tif (unlikely(mp_size <= 0)) {\n\t\tntfs_error(vol->sb, \"Cannot shrink allocation of inode 0x%lx, \"\n\t\t\t\t\"attribute type 0x%x, because determining the \"\n\t\t\t\t\"size for the mapping pairs failed with error \"\n\t\t\t\t\"code %i.%s\", vi->i_ino,\n\t\t\t\t(unsigned)le32_to_cpu(ni->type), mp_size, es);\n\t\terr = -EIO;\n\t\tgoto bad_out;\n\t}\n\t \n\terr = ntfs_attr_record_resize(m, a, mp_size +\n\t\t\tle16_to_cpu(a->data.non_resident.mapping_pairs_offset));\n\tBUG_ON(err);\n\t \n\terr = ntfs_mapping_pairs_build(vol, (u8*)a +\n\t\t\tle16_to_cpu(a->data.non_resident.mapping_pairs_offset),\n\t\t\tmp_size, ni->runlist.rl, 0, -1, NULL);\n\tif (unlikely(err)) {\n\t\tntfs_error(vol->sb, \"Cannot shrink allocation of inode 0x%lx, \"\n\t\t\t\t\"attribute type 0x%x, because building the \"\n\t\t\t\t\"mapping pairs failed with error code %i.%s\",\n\t\t\t\tvi->i_ino, (unsigned)le32_to_cpu(ni->type),\n\t\t\t\terr, es);\n\t\terr = -EIO;\n\t\tgoto bad_out;\n\t}\n\t \n\ta->data.non_resident.highest_vcn = cpu_to_sle64((new_alloc_size >>\n\t\t\tvol->cluster_size_bits) - 1);\n\twrite_lock_irqsave(&ni->size_lock, flags);\n\tni->allocated_size = new_alloc_size;\n\ta->data.non_resident.allocated_size = cpu_to_sle64(new_alloc_size);\n\tif (NInoSparse(ni) || NInoCompressed(ni)) {\n\t\tif (nr_freed) {\n\t\t\tni->itype.compressed.size -= nr_freed <<\n\t\t\t\t\tvol->cluster_size_bits;\n\t\t\tBUG_ON(ni->itype.compressed.size < 0);\n\t\t\ta->data.non_resident.compressed_size = cpu_to_sle64(\n\t\t\t\t\tni->itype.compressed.size);\n\t\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\t\t}\n\t} else\n\t\tvi->i_blocks = new_alloc_size >> 9;\n\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t \nalloc_done:\n\t \n\tif (size_change > 0)\n\t\ta->data.non_resident.data_size = cpu_to_sle64(new_size);\n\t \n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\nunm_done:\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(base_ni);\n\tup_write(&ni->runlist.lock);\ndone:\n\t \n\t \n\tif (!IS_NOCMTIME(VFS_I(base_ni)) && !IS_RDONLY(VFS_I(base_ni))) {\n\t\tstruct timespec64 now = current_time(VFS_I(base_ni));\n\t\tstruct timespec64 ctime = inode_get_ctime(VFS_I(base_ni));\n\t\tint sync_it = 0;\n\n\t\tif (!timespec64_equal(&VFS_I(base_ni)->i_mtime, &now) ||\n\t\t    !timespec64_equal(&ctime, &now))\n\t\t\tsync_it = 1;\n\t\tinode_set_ctime_to_ts(VFS_I(base_ni), now);\n\t\tVFS_I(base_ni)->i_mtime = now;\n\n\t\tif (sync_it)\n\t\t\tmark_inode_dirty_sync(VFS_I(base_ni));\n\t}\n\n\tif (likely(!err)) {\n\t\tNInoClearTruncateFailed(ni);\n\t\tntfs_debug(\"Done.\");\n\t}\n\treturn err;\nold_bad_out:\n\told_size = -1;\nbad_out:\n\tif (err != -ENOMEM && err != -EOPNOTSUPP)\n\t\tNVolSetErrors(vol);\n\tif (err != -EOPNOTSUPP)\n\t\tNInoSetTruncateFailed(ni);\n\telse if (old_size >= 0)\n\t\ti_size_write(vi, old_size);\nerr_out:\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(base_ni);\n\tup_write(&ni->runlist.lock);\nout:\n\tntfs_debug(\"Failed.  Returning error code %i.\", err);\n\treturn err;\nconv_err_out:\n\tif (err != -ENOMEM && err != -EOPNOTSUPP)\n\t\tNVolSetErrors(vol);\n\tif (err != -EOPNOTSUPP)\n\t\tNInoSetTruncateFailed(ni);\n\telse\n\t\ti_size_write(vi, old_size);\n\tgoto out;\n}\n\n \n#ifdef NTFS_RW\nvoid ntfs_truncate_vfs(struct inode *vi) {\n\tntfs_truncate(vi);\n}\n#endif\n\n \nint ntfs_setattr(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\t struct iattr *attr)\n{\n\tstruct inode *vi = d_inode(dentry);\n\tint err;\n\tunsigned int ia_valid = attr->ia_valid;\n\n\terr = setattr_prepare(&nop_mnt_idmap, dentry, attr);\n\tif (err)\n\t\tgoto out;\n\t \n\tif (ia_valid & (ATTR_UID | ATTR_GID | ATTR_MODE)) {\n\t\tntfs_warning(vi->i_sb, \"Changes in user/group/mode are not \"\n\t\t\t\t\"supported yet, ignoring.\");\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\tif (ia_valid & ATTR_SIZE) {\n\t\tif (attr->ia_size != i_size_read(vi)) {\n\t\t\tntfs_inode *ni = NTFS_I(vi);\n\t\t\t \n\t\t\tif (NInoCompressed(ni) || NInoEncrypted(ni)) {\n\t\t\t\tntfs_warning(vi->i_sb, \"Changes in inode size \"\n\t\t\t\t\t\t\"are not supported yet for \"\n\t\t\t\t\t\t\"%s files, ignoring.\",\n\t\t\t\t\t\tNInoCompressed(ni) ?\n\t\t\t\t\t\t\"compressed\" : \"encrypted\");\n\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t} else {\n\t\t\t\ttruncate_setsize(vi, attr->ia_size);\n\t\t\t\tntfs_truncate_vfs(vi);\n\t\t\t}\n\t\t\tif (err || ia_valid == ATTR_SIZE)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\t \n\t\t\tia_valid |= ATTR_MTIME | ATTR_CTIME;\n\t\t}\n\t}\n\tif (ia_valid & ATTR_ATIME)\n\t\tvi->i_atime = attr->ia_atime;\n\tif (ia_valid & ATTR_MTIME)\n\t\tvi->i_mtime = attr->ia_mtime;\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode_set_ctime_to_ts(vi, attr->ia_ctime);\n\tmark_inode_dirty(vi);\nout:\n\treturn err;\n}\n\n \nint __ntfs_write_inode(struct inode *vi, int sync)\n{\n\tsle64 nt;\n\tntfs_inode *ni = NTFS_I(vi);\n\tntfs_attr_search_ctx *ctx;\n\tMFT_RECORD *m;\n\tSTANDARD_INFORMATION *si;\n\tint err = 0;\n\tbool modified = false;\n\n\tntfs_debug(\"Entering for %sinode 0x%lx.\", NInoAttr(ni) ? \"attr \" : \"\",\n\t\t\tvi->i_ino);\n\t \n\tif (NInoAttr(ni)) {\n\t\tNInoClearDirty(ni);\n\t\tntfs_debug(\"Done.\");\n\t\treturn 0;\n\t}\n\t \n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\t \n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err)) {\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tgoto unm_err_out;\n\t}\n\tsi = (STANDARD_INFORMATION*)((u8*)ctx->attr +\n\t\t\tle16_to_cpu(ctx->attr->data.resident.value_offset));\n\t \n\tnt = utc2ntfs(vi->i_mtime);\n\tif (si->last_data_change_time != nt) {\n\t\tntfs_debug(\"Updating mtime for inode 0x%lx: old = 0x%llx, \"\n\t\t\t\t\"new = 0x%llx\", vi->i_ino, (long long)\n\t\t\t\tsle64_to_cpu(si->last_data_change_time),\n\t\t\t\t(long long)sle64_to_cpu(nt));\n\t\tsi->last_data_change_time = nt;\n\t\tmodified = true;\n\t}\n\tnt = utc2ntfs(inode_get_ctime(vi));\n\tif (si->last_mft_change_time != nt) {\n\t\tntfs_debug(\"Updating ctime for inode 0x%lx: old = 0x%llx, \"\n\t\t\t\t\"new = 0x%llx\", vi->i_ino, (long long)\n\t\t\t\tsle64_to_cpu(si->last_mft_change_time),\n\t\t\t\t(long long)sle64_to_cpu(nt));\n\t\tsi->last_mft_change_time = nt;\n\t\tmodified = true;\n\t}\n\tnt = utc2ntfs(vi->i_atime);\n\tif (si->last_access_time != nt) {\n\t\tntfs_debug(\"Updating atime for inode 0x%lx: old = 0x%llx, \"\n\t\t\t\t\"new = 0x%llx\", vi->i_ino,\n\t\t\t\t(long long)sle64_to_cpu(si->last_access_time),\n\t\t\t\t(long long)sle64_to_cpu(nt));\n\t\tsi->last_access_time = nt;\n\t\tmodified = true;\n\t}\n\t \n\tif (modified) {\n\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\tif (!NInoTestSetDirty(ctx->ntfs_ino))\n\t\t\tmark_ntfs_record_dirty(ctx->ntfs_ino->page,\n\t\t\t\t\tctx->ntfs_ino->page_ofs);\n\t}\n\tntfs_attr_put_search_ctx(ctx);\n\t \n\tif (NInoDirty(ni))\n\t\terr = write_mft_record(ni, m, sync);\n\t \n\tmutex_lock(&ni->extent_lock);\n\tif (ni->nr_extents > 0) {\n\t\tntfs_inode **extent_nis = ni->ext.extent_ntfs_inos;\n\t\tint i;\n\n\t\tntfs_debug(\"Writing %i extent inodes.\", ni->nr_extents);\n\t\tfor (i = 0; i < ni->nr_extents; i++) {\n\t\t\tntfs_inode *tni = extent_nis[i];\n\n\t\t\tif (NInoDirty(tni)) {\n\t\t\t\tMFT_RECORD *tm = map_mft_record(tni);\n\t\t\t\tint ret;\n\n\t\t\t\tif (IS_ERR(tm)) {\n\t\t\t\t\tif (!err || err == -ENOMEM)\n\t\t\t\t\t\terr = PTR_ERR(tm);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tret = write_mft_record(tni, tm, sync);\n\t\t\t\tunmap_mft_record(tni);\n\t\t\t\tif (unlikely(ret)) {\n\t\t\t\t\tif (!err || err == -ENOMEM)\n\t\t\t\t\t\terr = ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&ni->extent_lock);\n\tunmap_mft_record(ni);\n\tif (unlikely(err))\n\t\tgoto err_out;\n\tntfs_debug(\"Done.\");\n\treturn 0;\nunm_err_out:\n\tunmap_mft_record(ni);\nerr_out:\n\tif (err == -ENOMEM) {\n\t\tntfs_warning(vi->i_sb, \"Not enough memory to write inode.  \"\n\t\t\t\t\"Marking the inode dirty again, so the VFS \"\n\t\t\t\t\"retries later.\");\n\t\tmark_inode_dirty(vi);\n\t} else {\n\t\tntfs_error(vi->i_sb, \"Failed (error %i):  Run chkdsk.\", -err);\n\t\tNVolSetErrors(ni->vol);\n\t}\n\treturn err;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}