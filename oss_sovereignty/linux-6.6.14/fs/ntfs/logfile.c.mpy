{
  "module_name": "logfile.c",
  "hash_id": "4ec58c7826e0fd597a53e196efc92d457e1afd40ea3d1a4a7c0f7b3ecc63e402",
  "original_prompt": "Ingested from linux-6.6.14/fs/ntfs/logfile.c",
  "human_readable_source": "\n \n\n#ifdef NTFS_RW\n\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include <linux/bitops.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n\n#include \"attrib.h\"\n#include \"aops.h\"\n#include \"debug.h\"\n#include \"logfile.h\"\n#include \"malloc.h\"\n#include \"volume.h\"\n#include \"ntfs.h\"\n\n \nstatic bool ntfs_check_restart_page_header(struct inode *vi,\n\t\tRESTART_PAGE_HEADER *rp, s64 pos)\n{\n\tu32 logfile_system_page_size, logfile_log_page_size;\n\tu16 ra_ofs, usa_count, usa_ofs, usa_end = 0;\n\tbool have_usa = true;\n\n\tntfs_debug(\"Entering.\");\n\t \n\tlogfile_system_page_size = le32_to_cpu(rp->system_page_size);\n\tlogfile_log_page_size = le32_to_cpu(rp->log_page_size);\n\tif (logfile_system_page_size < NTFS_BLOCK_SIZE ||\n\t\t\tlogfile_log_page_size < NTFS_BLOCK_SIZE ||\n\t\t\tlogfile_system_page_size &\n\t\t\t(logfile_system_page_size - 1) ||\n\t\t\t!is_power_of_2(logfile_log_page_size)) {\n\t\tntfs_error(vi->i_sb, \"$LogFile uses unsupported page size.\");\n\t\treturn false;\n\t}\n\t \n\tif (pos && pos != logfile_system_page_size) {\n\t\tntfs_error(vi->i_sb, \"Found restart area in incorrect \"\n\t\t\t\t\"position in $LogFile.\");\n\t\treturn false;\n\t}\n\t \n\tif (sle16_to_cpu(rp->major_ver) != 1 ||\n\t\t\tsle16_to_cpu(rp->minor_ver) != 1) {\n\t\tntfs_error(vi->i_sb, \"$LogFile version %i.%i is not \"\n\t\t\t\t\"supported.  (This driver supports version \"\n\t\t\t\t\"1.1 only.)\", (int)sle16_to_cpu(rp->major_ver),\n\t\t\t\t(int)sle16_to_cpu(rp->minor_ver));\n\t\treturn false;\n\t}\n\t \n\tif (ntfs_is_chkd_record(rp->magic) && !le16_to_cpu(rp->usa_count)) {\n\t\thave_usa = false;\n\t\tgoto skip_usa_checks;\n\t}\n\t \n\tusa_count = 1 + (logfile_system_page_size >> NTFS_BLOCK_SIZE_BITS);\n\tif (usa_count != le16_to_cpu(rp->usa_count)) {\n\t\tntfs_error(vi->i_sb, \"$LogFile restart page specifies \"\n\t\t\t\t\"inconsistent update sequence array count.\");\n\t\treturn false;\n\t}\n\t \n\tusa_ofs = le16_to_cpu(rp->usa_ofs);\n\tusa_end = usa_ofs + usa_count * sizeof(u16);\n\tif (usa_ofs < sizeof(RESTART_PAGE_HEADER) ||\n\t\t\tusa_end > NTFS_BLOCK_SIZE - sizeof(u16)) {\n\t\tntfs_error(vi->i_sb, \"$LogFile restart page specifies \"\n\t\t\t\t\"inconsistent update sequence array offset.\");\n\t\treturn false;\n\t}\nskip_usa_checks:\n\t \n\tra_ofs = le16_to_cpu(rp->restart_area_offset);\n\tif (ra_ofs & 7 || (have_usa ? ra_ofs < usa_end :\n\t\t\tra_ofs < sizeof(RESTART_PAGE_HEADER)) ||\n\t\t\tra_ofs > logfile_system_page_size) {\n\t\tntfs_error(vi->i_sb, \"$LogFile restart page specifies \"\n\t\t\t\t\"inconsistent restart area offset.\");\n\t\treturn false;\n\t}\n\t \n\tif (!ntfs_is_chkd_record(rp->magic) && sle64_to_cpu(rp->chkdsk_lsn)) {\n\t\tntfs_error(vi->i_sb, \"$LogFile restart page is not modified \"\n\t\t\t\t\"by chkdsk but a chkdsk LSN is specified.\");\n\t\treturn false;\n\t}\n\tntfs_debug(\"Done.\");\n\treturn true;\n}\n\n \nstatic bool ntfs_check_restart_area(struct inode *vi, RESTART_PAGE_HEADER *rp)\n{\n\tu64 file_size;\n\tRESTART_AREA *ra;\n\tu16 ra_ofs, ra_len, ca_ofs;\n\tu8 fs_bits;\n\n\tntfs_debug(\"Entering.\");\n\tra_ofs = le16_to_cpu(rp->restart_area_offset);\n\tra = (RESTART_AREA*)((u8*)rp + ra_ofs);\n\t \n\tif (ra_ofs + offsetof(RESTART_AREA, file_size) >\n\t\t\tNTFS_BLOCK_SIZE - sizeof(u16)) {\n\t\tntfs_error(vi->i_sb, \"$LogFile restart area specifies \"\n\t\t\t\t\"inconsistent file offset.\");\n\t\treturn false;\n\t}\n\t \n\tca_ofs = le16_to_cpu(ra->client_array_offset);\n\tif (((ca_ofs + 7) & ~7) != ca_ofs ||\n\t\t\tra_ofs + ca_ofs > NTFS_BLOCK_SIZE - sizeof(u16)) {\n\t\tntfs_error(vi->i_sb, \"$LogFile restart area specifies \"\n\t\t\t\t\"inconsistent client array offset.\");\n\t\treturn false;\n\t}\n\t \n\tra_len = ca_ofs + le16_to_cpu(ra->log_clients) *\n\t\t\tsizeof(LOG_CLIENT_RECORD);\n\tif (ra_ofs + ra_len > le32_to_cpu(rp->system_page_size) ||\n\t\t\tra_ofs + le16_to_cpu(ra->restart_area_length) >\n\t\t\tle32_to_cpu(rp->system_page_size) ||\n\t\t\tra_len > le16_to_cpu(ra->restart_area_length)) {\n\t\tntfs_error(vi->i_sb, \"$LogFile restart area is out of bounds \"\n\t\t\t\t\"of the system page size specified by the \"\n\t\t\t\t\"restart page header and/or the specified \"\n\t\t\t\t\"restart area length is inconsistent.\");\n\t\treturn false;\n\t}\n\t \n\tif ((ra->client_free_list != LOGFILE_NO_CLIENT &&\n\t\t\tle16_to_cpu(ra->client_free_list) >=\n\t\t\tle16_to_cpu(ra->log_clients)) ||\n\t\t\t(ra->client_in_use_list != LOGFILE_NO_CLIENT &&\n\t\t\tle16_to_cpu(ra->client_in_use_list) >=\n\t\t\tle16_to_cpu(ra->log_clients))) {\n\t\tntfs_error(vi->i_sb, \"$LogFile restart area specifies \"\n\t\t\t\t\"overflowing client free and/or in use lists.\");\n\t\treturn false;\n\t}\n\t \n\tfile_size = (u64)sle64_to_cpu(ra->file_size);\n\tfs_bits = 0;\n\twhile (file_size) {\n\t\tfile_size >>= 1;\n\t\tfs_bits++;\n\t}\n\tif (le32_to_cpu(ra->seq_number_bits) != 67 - fs_bits) {\n\t\tntfs_error(vi->i_sb, \"$LogFile restart area specifies \"\n\t\t\t\t\"inconsistent sequence number bits.\");\n\t\treturn false;\n\t}\n\t \n\tif (((le16_to_cpu(ra->log_record_header_length) + 7) & ~7) !=\n\t\t\tle16_to_cpu(ra->log_record_header_length)) {\n\t\tntfs_error(vi->i_sb, \"$LogFile restart area specifies \"\n\t\t\t\t\"inconsistent log record header length.\");\n\t\treturn false;\n\t}\n\t \n\tif (((le16_to_cpu(ra->log_page_data_offset) + 7) & ~7) !=\n\t\t\tle16_to_cpu(ra->log_page_data_offset)) {\n\t\tntfs_error(vi->i_sb, \"$LogFile restart area specifies \"\n\t\t\t\t\"inconsistent log page data offset.\");\n\t\treturn false;\n\t}\n\tntfs_debug(\"Done.\");\n\treturn true;\n}\n\n \nstatic bool ntfs_check_log_client_array(struct inode *vi,\n\t\tRESTART_PAGE_HEADER *rp)\n{\n\tRESTART_AREA *ra;\n\tLOG_CLIENT_RECORD *ca, *cr;\n\tu16 nr_clients, idx;\n\tbool in_free_list, idx_is_first;\n\n\tntfs_debug(\"Entering.\");\n\tra = (RESTART_AREA*)((u8*)rp + le16_to_cpu(rp->restart_area_offset));\n\tca = (LOG_CLIENT_RECORD*)((u8*)ra +\n\t\t\tle16_to_cpu(ra->client_array_offset));\n\t \n\tnr_clients = le16_to_cpu(ra->log_clients);\n\tidx = le16_to_cpu(ra->client_free_list);\n\tin_free_list = true;\ncheck_list:\n\tfor (idx_is_first = true; idx != LOGFILE_NO_CLIENT_CPU; nr_clients--,\n\t\t\tidx = le16_to_cpu(cr->next_client)) {\n\t\tif (!nr_clients || idx >= le16_to_cpu(ra->log_clients))\n\t\t\tgoto err_out;\n\t\t \n\t\tcr = ca + idx;\n\t\t \n\t\tif (idx_is_first) {\n\t\t\tif (cr->prev_client != LOGFILE_NO_CLIENT)\n\t\t\t\tgoto err_out;\n\t\t\tidx_is_first = false;\n\t\t}\n\t}\n\t \n\tif (in_free_list) {\n\t\tin_free_list = false;\n\t\tidx = le16_to_cpu(ra->client_in_use_list);\n\t\tgoto check_list;\n\t}\n\tntfs_debug(\"Done.\");\n\treturn true;\nerr_out:\n\tntfs_error(vi->i_sb, \"$LogFile log client array is corrupt.\");\n\treturn false;\n}\n\n \nstatic int ntfs_check_and_load_restart_page(struct inode *vi,\n\t\tRESTART_PAGE_HEADER *rp, s64 pos, RESTART_PAGE_HEADER **wrp,\n\t\tLSN *lsn)\n{\n\tRESTART_AREA *ra;\n\tRESTART_PAGE_HEADER *trp;\n\tint size, err;\n\n\tntfs_debug(\"Entering.\");\n\t \n\tif (!ntfs_check_restart_page_header(vi, rp, pos)) {\n\t\t \n\t\treturn -EINVAL;\n\t}\n\t \n\tif (!ntfs_check_restart_area(vi, rp)) {\n\t\t \n\t\treturn -EINVAL;\n\t}\n\tra = (RESTART_AREA*)((u8*)rp + le16_to_cpu(rp->restart_area_offset));\n\t \n\ttrp = ntfs_malloc_nofs(le32_to_cpu(rp->system_page_size));\n\tif (!trp) {\n\t\tntfs_error(vi->i_sb, \"Failed to allocate memory for $LogFile \"\n\t\t\t\t\"restart page buffer.\");\n\t\treturn -ENOMEM;\n\t}\n\t \n\tsize = PAGE_SIZE - (pos & ~PAGE_MASK);\n\tif (size >= le32_to_cpu(rp->system_page_size)) {\n\t\tmemcpy(trp, rp, le32_to_cpu(rp->system_page_size));\n\t} else {\n\t\tpgoff_t idx;\n\t\tstruct page *page;\n\t\tint have_read, to_read;\n\n\t\t \n\t\tmemcpy(trp, rp, size);\n\t\t \n\t\thave_read = size;\n\t\tto_read = le32_to_cpu(rp->system_page_size) - size;\n\t\tidx = (pos + size) >> PAGE_SHIFT;\n\t\tBUG_ON((pos + size) & ~PAGE_MASK);\n\t\tdo {\n\t\t\tpage = ntfs_map_page(vi->i_mapping, idx);\n\t\t\tif (IS_ERR(page)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Error mapping $LogFile \"\n\t\t\t\t\t\t\"page (index %lu).\", idx);\n\t\t\t\terr = PTR_ERR(page);\n\t\t\t\tif (err != -EIO && err != -ENOMEM)\n\t\t\t\t\terr = -EIO;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\tsize = min_t(int, to_read, PAGE_SIZE);\n\t\t\tmemcpy((u8*)trp + have_read, page_address(page), size);\n\t\t\tntfs_unmap_page(page);\n\t\t\thave_read += size;\n\t\t\tto_read -= size;\n\t\t\tidx++;\n\t\t} while (to_read > 0);\n\t}\n\t \n\tif ((!ntfs_is_chkd_record(trp->magic) || le16_to_cpu(trp->usa_count))\n\t\t\t&& post_read_mst_fixup((NTFS_RECORD*)trp,\n\t\t\tle32_to_cpu(rp->system_page_size))) {\n\t\t \n\t\tif (le16_to_cpu(rp->restart_area_offset) +\n\t\t\t\tle16_to_cpu(ra->restart_area_length) >\n\t\t\t\tNTFS_BLOCK_SIZE - sizeof(u16)) {\n\t\t\tntfs_error(vi->i_sb, \"Multi sector transfer error \"\n\t\t\t\t\t\"detected in $LogFile restart page.\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\t \n\terr = 0;\n\tif (ntfs_is_rstr_record(rp->magic) &&\n\t\t\tra->client_in_use_list != LOGFILE_NO_CLIENT) {\n\t\tif (!ntfs_check_log_client_array(vi, trp)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\tif (lsn) {\n\t\tif (ntfs_is_rstr_record(rp->magic))\n\t\t\t*lsn = sle64_to_cpu(ra->current_lsn);\n\t\telse  \n\t\t\t*lsn = sle64_to_cpu(rp->chkdsk_lsn);\n\t}\n\tntfs_debug(\"Done.\");\n\tif (wrp)\n\t\t*wrp = trp;\n\telse {\nerr_out:\n\t\tntfs_free(trp);\n\t}\n\treturn err;\n}\n\n \nbool ntfs_check_logfile(struct inode *log_vi, RESTART_PAGE_HEADER **rp)\n{\n\ts64 size, pos;\n\tLSN rstr1_lsn, rstr2_lsn;\n\tntfs_volume *vol = NTFS_SB(log_vi->i_sb);\n\tstruct address_space *mapping = log_vi->i_mapping;\n\tstruct page *page = NULL;\n\tu8 *kaddr = NULL;\n\tRESTART_PAGE_HEADER *rstr1_ph = NULL;\n\tRESTART_PAGE_HEADER *rstr2_ph = NULL;\n\tint log_page_size, err;\n\tbool logfile_is_empty = true;\n\tu8 log_page_bits;\n\n\tntfs_debug(\"Entering.\");\n\t \n\tif (NVolLogFileEmpty(vol))\n\t\tgoto is_empty;\n\tsize = i_size_read(log_vi);\n\t \n\tif (size > MaxLogFileSize)\n\t\tsize = MaxLogFileSize;\n\t \n\tif (PAGE_SIZE >= DefaultLogPageSize && PAGE_SIZE <=\n\t\t\tDefaultLogPageSize * 2)\n\t\tlog_page_size = DefaultLogPageSize;\n\telse\n\t\tlog_page_size = PAGE_SIZE;\n\t \n\tlog_page_bits = ntfs_ffs(log_page_size) - 1;\n\tsize &= ~(s64)(log_page_size - 1);\n\t \n\tif (size < log_page_size * 2 || (size - log_page_size * 2) >>\n\t\t\tlog_page_bits < MinLogRecordPages) {\n\t\tntfs_error(vol->sb, \"$LogFile is too small.\");\n\t\treturn false;\n\t}\n\t \n\tfor (pos = 0; pos < size; pos <<= 1) {\n\t\tpgoff_t idx = pos >> PAGE_SHIFT;\n\t\tif (!page || page->index != idx) {\n\t\t\tif (page)\n\t\t\t\tntfs_unmap_page(page);\n\t\t\tpage = ntfs_map_page(mapping, idx);\n\t\t\tif (IS_ERR(page)) {\n\t\t\t\tntfs_error(vol->sb, \"Error mapping $LogFile \"\n\t\t\t\t\t\t\"page (index %lu).\", idx);\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t}\n\t\tkaddr = (u8*)page_address(page) + (pos & ~PAGE_MASK);\n\t\t \n\t\tif (!ntfs_is_empty_recordp((le32*)kaddr))\n\t\t\tlogfile_is_empty = false;\n\t\telse if (!logfile_is_empty)\n\t\t\tbreak;\n\t\t \n\t\tif (ntfs_is_rcrd_recordp((le32*)kaddr))\n\t\t\tbreak;\n\t\t \n\t\tif (!ntfs_is_rstr_recordp((le32*)kaddr) &&\n\t\t\t\t!ntfs_is_chkd_recordp((le32*)kaddr)) {\n\t\t\tif (!pos)\n\t\t\t\tpos = NTFS_BLOCK_SIZE >> 1;\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\terr = ntfs_check_and_load_restart_page(log_vi,\n\t\t\t\t(RESTART_PAGE_HEADER*)kaddr, pos,\n\t\t\t\t!rstr1_ph ? &rstr1_ph : &rstr2_ph,\n\t\t\t\t!rstr1_ph ? &rstr1_lsn : &rstr2_lsn);\n\t\tif (!err) {\n\t\t\t \n\t\t\tif (!pos) {\n\t\t\t\tpos = NTFS_BLOCK_SIZE >> 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tif (err != -EINVAL) {\n\t\t\tntfs_unmap_page(page);\n\t\t\tgoto err_out;\n\t\t}\n\t\t \n\t\tif (!pos)\n\t\t\tpos = NTFS_BLOCK_SIZE >> 1;\n\t}\n\tif (page)\n\t\tntfs_unmap_page(page);\n\tif (logfile_is_empty) {\n\t\tNVolSetLogFileEmpty(vol);\nis_empty:\n\t\tntfs_debug(\"Done.  ($LogFile is empty.)\");\n\t\treturn true;\n\t}\n\tif (!rstr1_ph) {\n\t\tBUG_ON(rstr2_ph);\n\t\tntfs_error(vol->sb, \"Did not find any restart pages in \"\n\t\t\t\t\"$LogFile and it was not empty.\");\n\t\treturn false;\n\t}\n\t \n\tif (rstr2_ph) {\n\t\t \n\t\tif (rstr2_lsn > rstr1_lsn) {\n\t\t\tntfs_debug(\"Using second restart page as it is more \"\n\t\t\t\t\t\"recent.\");\n\t\t\tntfs_free(rstr1_ph);\n\t\t\trstr1_ph = rstr2_ph;\n\t\t\t \n\t\t} else {\n\t\t\tntfs_debug(\"Using first restart page as it is more \"\n\t\t\t\t\t\"recent.\");\n\t\t\tntfs_free(rstr2_ph);\n\t\t}\n\t\trstr2_ph = NULL;\n\t}\n\t \n\tif (rp)\n\t\t*rp = rstr1_ph;\n\telse\n\t\tntfs_free(rstr1_ph);\n\tntfs_debug(\"Done.\");\n\treturn true;\nerr_out:\n\tif (rstr1_ph)\n\t\tntfs_free(rstr1_ph);\n\treturn false;\n}\n\n \nbool ntfs_is_logfile_clean(struct inode *log_vi, const RESTART_PAGE_HEADER *rp)\n{\n\tntfs_volume *vol = NTFS_SB(log_vi->i_sb);\n\tRESTART_AREA *ra;\n\n\tntfs_debug(\"Entering.\");\n\t \n\tif (NVolLogFileEmpty(vol)) {\n\t\tntfs_debug(\"Done.  ($LogFile is empty.)\");\n\t\treturn true;\n\t}\n\tBUG_ON(!rp);\n\tif (!ntfs_is_rstr_record(rp->magic) &&\n\t\t\t!ntfs_is_chkd_record(rp->magic)) {\n\t\tntfs_error(vol->sb, \"Restart page buffer is invalid.  This is \"\n\t\t\t\t\"probably a bug in that the $LogFile should \"\n\t\t\t\t\"have been consistency checked before calling \"\n\t\t\t\t\"this function.\");\n\t\treturn false;\n\t}\n\tra = (RESTART_AREA*)((u8*)rp + le16_to_cpu(rp->restart_area_offset));\n\t \n\tif (ra->client_in_use_list != LOGFILE_NO_CLIENT &&\n\t\t\t!(ra->flags & RESTART_VOLUME_IS_CLEAN)) {\n\t\tntfs_debug(\"Done.  $LogFile indicates a dirty shutdown.\");\n\t\treturn false;\n\t}\n\t \n\tntfs_debug(\"Done.  $LogFile indicates a clean shutdown.\");\n\treturn true;\n}\n\n \nbool ntfs_empty_logfile(struct inode *log_vi)\n{\n\tVCN vcn, end_vcn;\n\tntfs_inode *log_ni = NTFS_I(log_vi);\n\tntfs_volume *vol = log_ni->vol;\n\tstruct super_block *sb = vol->sb;\n\trunlist_element *rl;\n\tunsigned long flags;\n\tunsigned block_size, block_size_bits;\n\tint err;\n\tbool should_wait = true;\n\n\tntfs_debug(\"Entering.\");\n\tif (NVolLogFileEmpty(vol)) {\n\t\tntfs_debug(\"Done.\");\n\t\treturn true;\n\t}\n\t \n\tblock_size = sb->s_blocksize;\n\tblock_size_bits = sb->s_blocksize_bits;\n\tvcn = 0;\n\tread_lock_irqsave(&log_ni->size_lock, flags);\n\tend_vcn = (log_ni->initialized_size + vol->cluster_size_mask) >>\n\t\t\tvol->cluster_size_bits;\n\tread_unlock_irqrestore(&log_ni->size_lock, flags);\n\ttruncate_inode_pages(log_vi->i_mapping, 0);\n\tdown_write(&log_ni->runlist.lock);\n\trl = log_ni->runlist.rl;\n\tif (unlikely(!rl || vcn < rl->vcn || !rl->length)) {\nmap_vcn:\n\t\terr = ntfs_map_runlist_nolock(log_ni, vcn, NULL);\n\t\tif (err) {\n\t\t\tntfs_error(sb, \"Failed to map runlist fragment (error \"\n\t\t\t\t\t\"%d).\", -err);\n\t\t\tgoto err;\n\t\t}\n\t\trl = log_ni->runlist.rl;\n\t\tBUG_ON(!rl || vcn < rl->vcn || !rl->length);\n\t}\n\t \n\twhile (rl->length && vcn >= rl[1].vcn)\n\t\trl++;\n\tdo {\n\t\tLCN lcn;\n\t\tsector_t block, end_block;\n\t\ts64 len;\n\n\t\t \n\t\tlcn = rl->lcn;\n\t\tif (unlikely(lcn == LCN_RL_NOT_MAPPED)) {\n\t\t\tvcn = rl->vcn;\n\t\t\tgoto map_vcn;\n\t\t}\n\t\t \n\t\tif (unlikely(!rl->length || lcn < LCN_HOLE))\n\t\t\tgoto rl_err;\n\t\t \n\t\tif (lcn == LCN_HOLE)\n\t\t\tcontinue;\n\t\tblock = lcn << vol->cluster_size_bits >> block_size_bits;\n\t\tlen = rl->length;\n\t\tif (rl[1].vcn > end_vcn)\n\t\t\tlen = end_vcn - rl->vcn;\n\t\tend_block = (lcn + len) << vol->cluster_size_bits >>\n\t\t\t\tblock_size_bits;\n\t\t \n\t\tdo {\n\t\t\tstruct buffer_head *bh;\n\n\t\t\t \n\t\t\tbh = sb_getblk(sb, block);\n\t\t\tBUG_ON(!bh);\n\t\t\t \n\t\t\tlock_buffer(bh);\n\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\tget_bh(bh);\n\t\t\t \n\t\t\tmemset(bh->b_data, -1, block_size);\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tif (buffer_dirty(bh))\n\t\t\t\tclear_buffer_dirty(bh);\n\t\t\t \n\t\t\tsubmit_bh(REQ_OP_WRITE, bh);\n\t\t\tif (should_wait) {\n\t\t\t\tshould_wait = false;\n\t\t\t\twait_on_buffer(bh);\n\t\t\t\tif (unlikely(!buffer_uptodate(bh)))\n\t\t\t\t\tgoto io_err;\n\t\t\t}\n\t\t\tbrelse(bh);\n\t\t} while (++block < end_block);\n\t} while ((++rl)->vcn < end_vcn);\n\tup_write(&log_ni->runlist.lock);\n\t \n\ttruncate_inode_pages(log_vi->i_mapping, 0);\n\t \n\tNVolSetLogFileEmpty(vol);\n\tntfs_debug(\"Done.\");\n\treturn true;\nio_err:\n\tntfs_error(sb, \"Failed to write buffer.  Unmount and run chkdsk.\");\n\tgoto dirty_err;\nrl_err:\n\tntfs_error(sb, \"Runlist is corrupt.  Unmount and run chkdsk.\");\ndirty_err:\n\tNVolSetErrors(vol);\n\terr = -EIO;\nerr:\n\tup_write(&log_ni->runlist.lock);\n\tntfs_error(sb, \"Failed to fill $LogFile with 0xff bytes (error %d).\",\n\t\t\t-err);\n\treturn false;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}