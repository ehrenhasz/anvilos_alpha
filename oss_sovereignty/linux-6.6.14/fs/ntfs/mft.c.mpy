{
  "module_name": "mft.c",
  "hash_id": "449ca167100c1cc793587d4829e9b8db7397adfb92ca992a42ea5419c9ecd0a3",
  "original_prompt": "Ingested from linux-6.6.14/fs/ntfs/mft.c",
  "human_readable_source": "\n \n\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/bio.h>\n\n#include \"attrib.h\"\n#include \"aops.h\"\n#include \"bitmap.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"lcnalloc.h\"\n#include \"malloc.h\"\n#include \"mft.h\"\n#include \"ntfs.h\"\n\n#define MAX_BHS\t(PAGE_SIZE / NTFS_BLOCK_SIZE)\n\n \nstatic inline MFT_RECORD *map_mft_record_page(ntfs_inode *ni)\n{\n\tloff_t i_size;\n\tntfs_volume *vol = ni->vol;\n\tstruct inode *mft_vi = vol->mft_ino;\n\tstruct page *page;\n\tunsigned long index, end_index;\n\tunsigned ofs;\n\n\tBUG_ON(ni->page);\n\t \n\tindex = (u64)ni->mft_no << vol->mft_record_size_bits >>\n\t\t\tPAGE_SHIFT;\n\tofs = (ni->mft_no << vol->mft_record_size_bits) & ~PAGE_MASK;\n\n\ti_size = i_size_read(mft_vi);\n\t \n\tend_index = i_size >> PAGE_SHIFT;\n\n\t \n\tif (unlikely(index >= end_index)) {\n\t\tif (index > end_index || (i_size & ~PAGE_MASK) < ofs +\n\t\t\t\tvol->mft_record_size) {\n\t\t\tpage = ERR_PTR(-ENOENT);\n\t\t\tntfs_error(vol->sb, \"Attempt to read mft record 0x%lx, \"\n\t\t\t\t\t\"which is beyond the end of the mft.  \"\n\t\t\t\t\t\"This is probably a bug in the ntfs \"\n\t\t\t\t\t\"driver.\", ni->mft_no);\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\t \n\tpage = ntfs_map_page(mft_vi->i_mapping, index);\n\tif (!IS_ERR(page)) {\n\t\t \n\t\tif (likely(ntfs_is_mft_recordp((le32*)(page_address(page) +\n\t\t\t\tofs)))) {\n\t\t\tni->page = page;\n\t\t\tni->page_ofs = ofs;\n\t\t\treturn page_address(page) + ofs;\n\t\t}\n\t\tntfs_error(vol->sb, \"Mft record 0x%lx is corrupt.  \"\n\t\t\t\t\"Run chkdsk.\", ni->mft_no);\n\t\tntfs_unmap_page(page);\n\t\tpage = ERR_PTR(-EIO);\n\t\tNVolSetErrors(vol);\n\t}\nerr_out:\n\tni->page = NULL;\n\tni->page_ofs = 0;\n\treturn (void*)page;\n}\n\n \nMFT_RECORD *map_mft_record(ntfs_inode *ni)\n{\n\tMFT_RECORD *m;\n\n\tntfs_debug(\"Entering for mft_no 0x%lx.\", ni->mft_no);\n\n\t \n\tatomic_inc(&ni->count);\n\n\t \n\tmutex_lock(&ni->mrec_lock);\n\n\tm = map_mft_record_page(ni);\n\tif (!IS_ERR(m))\n\t\treturn m;\n\n\tmutex_unlock(&ni->mrec_lock);\n\tatomic_dec(&ni->count);\n\tntfs_error(ni->vol->sb, \"Failed with error code %lu.\", -PTR_ERR(m));\n\treturn m;\n}\n\n \nstatic inline void unmap_mft_record_page(ntfs_inode *ni)\n{\n\tBUG_ON(!ni->page);\n\n\t \n\tntfs_unmap_page(ni->page);\n\tni->page = NULL;\n\tni->page_ofs = 0;\n\treturn;\n}\n\n \nvoid unmap_mft_record(ntfs_inode *ni)\n{\n\tstruct page *page = ni->page;\n\n\tBUG_ON(!page);\n\n\tntfs_debug(\"Entering for mft_no 0x%lx.\", ni->mft_no);\n\n\tunmap_mft_record_page(ni);\n\tmutex_unlock(&ni->mrec_lock);\n\tatomic_dec(&ni->count);\n\t \n\treturn;\n}\n\n \nMFT_RECORD *map_extent_mft_record(ntfs_inode *base_ni, MFT_REF mref,\n\t\tntfs_inode **ntfs_ino)\n{\n\tMFT_RECORD *m;\n\tntfs_inode *ni = NULL;\n\tntfs_inode **extent_nis = NULL;\n\tint i;\n\tunsigned long mft_no = MREF(mref);\n\tu16 seq_no = MSEQNO(mref);\n\tbool destroy_ni = false;\n\n\tntfs_debug(\"Mapping extent mft record 0x%lx (base mft record 0x%lx).\",\n\t\t\tmft_no, base_ni->mft_no);\n\t \n\tatomic_inc(&base_ni->count);\n\t \n\tmutex_lock(&base_ni->extent_lock);\n\tif (base_ni->nr_extents > 0) {\n\t\textent_nis = base_ni->ext.extent_ntfs_inos;\n\t\tfor (i = 0; i < base_ni->nr_extents; i++) {\n\t\t\tif (mft_no != extent_nis[i]->mft_no)\n\t\t\t\tcontinue;\n\t\t\tni = extent_nis[i];\n\t\t\t \n\t\t\tatomic_inc(&ni->count);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (likely(ni != NULL)) {\n\t\tmutex_unlock(&base_ni->extent_lock);\n\t\tatomic_dec(&base_ni->count);\n\t\t \n\t\tm = map_mft_record(ni);\n\t\t \n\t\tatomic_dec(&ni->count);\n\t\tif (!IS_ERR(m)) {\n\t\t\t \n\t\t\tif (likely(le16_to_cpu(m->sequence_number) == seq_no)) {\n\t\t\t\tntfs_debug(\"Done 1.\");\n\t\t\t\t*ntfs_ino = ni;\n\t\t\t\treturn m;\n\t\t\t}\n\t\t\tunmap_mft_record(ni);\n\t\t\tntfs_error(base_ni->vol->sb, \"Found stale extent mft \"\n\t\t\t\t\t\"reference! Corrupt filesystem. \"\n\t\t\t\t\t\"Run chkdsk.\");\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\nmap_err_out:\n\t\tntfs_error(base_ni->vol->sb, \"Failed to map extent \"\n\t\t\t\t\"mft record, error code %ld.\", -PTR_ERR(m));\n\t\treturn m;\n\t}\n\t \n\tni = ntfs_new_extent_inode(base_ni->vol->sb, mft_no);\n\tif (unlikely(!ni)) {\n\t\tmutex_unlock(&base_ni->extent_lock);\n\t\tatomic_dec(&base_ni->count);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tni->vol = base_ni->vol;\n\tni->seq_no = seq_no;\n\tni->nr_extents = -1;\n\tni->ext.base_ntfs_ino = base_ni;\n\t \n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\tmutex_unlock(&base_ni->extent_lock);\n\t\tatomic_dec(&base_ni->count);\n\t\tntfs_clear_extent_inode(ni);\n\t\tgoto map_err_out;\n\t}\n\t \n\tif (seq_no && (le16_to_cpu(m->sequence_number) != seq_no)) {\n\t\tntfs_error(base_ni->vol->sb, \"Found stale extent mft \"\n\t\t\t\t\"reference! Corrupt filesystem. Run chkdsk.\");\n\t\tdestroy_ni = true;\n\t\tm = ERR_PTR(-EIO);\n\t\tgoto unm_err_out;\n\t}\n\t \n\tif (!(base_ni->nr_extents & 3)) {\n\t\tntfs_inode **tmp;\n\t\tint new_size = (base_ni->nr_extents + 4) * sizeof(ntfs_inode *);\n\n\t\ttmp = kmalloc(new_size, GFP_NOFS);\n\t\tif (unlikely(!tmp)) {\n\t\t\tntfs_error(base_ni->vol->sb, \"Failed to allocate \"\n\t\t\t\t\t\"internal buffer.\");\n\t\t\tdestroy_ni = true;\n\t\t\tm = ERR_PTR(-ENOMEM);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (base_ni->nr_extents) {\n\t\t\tBUG_ON(!base_ni->ext.extent_ntfs_inos);\n\t\t\tmemcpy(tmp, base_ni->ext.extent_ntfs_inos, new_size -\n\t\t\t\t\t4 * sizeof(ntfs_inode *));\n\t\t\tkfree(base_ni->ext.extent_ntfs_inos);\n\t\t}\n\t\tbase_ni->ext.extent_ntfs_inos = tmp;\n\t}\n\tbase_ni->ext.extent_ntfs_inos[base_ni->nr_extents++] = ni;\n\tmutex_unlock(&base_ni->extent_lock);\n\tatomic_dec(&base_ni->count);\n\tntfs_debug(\"Done 2.\");\n\t*ntfs_ino = ni;\n\treturn m;\nunm_err_out:\n\tunmap_mft_record(ni);\n\tmutex_unlock(&base_ni->extent_lock);\n\tatomic_dec(&base_ni->count);\n\t \n\tif (destroy_ni)\n\t\tntfs_clear_extent_inode(ni);\n\treturn m;\n}\n\n#ifdef NTFS_RW\n\n \nvoid __mark_mft_record_dirty(ntfs_inode *ni)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", ni->mft_no);\n\tBUG_ON(NInoAttr(ni));\n\tmark_ntfs_record_dirty(ni->page, ni->page_ofs);\n\t \n\tmutex_lock(&ni->extent_lock);\n\tif (likely(ni->nr_extents >= 0))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tmutex_unlock(&ni->extent_lock);\n\t__mark_inode_dirty(VFS_I(base_ni), I_DIRTY_DATASYNC);\n}\n\nstatic const char *ntfs_please_email = \"Please email \"\n\t\t\"linux-ntfs-dev@lists.sourceforge.net and say that you saw \"\n\t\t\"this message.  Thank you.\";\n\n \nstatic int ntfs_sync_mft_mirror_umount(ntfs_volume *vol,\n\t\tconst unsigned long mft_no, MFT_RECORD *m)\n{\n\tBUG_ON(vol->mftmirr_ino);\n\tntfs_error(vol->sb, \"Umount time mft mirror syncing is not \"\n\t\t\t\"implemented yet.  %s\", ntfs_please_email);\n\treturn -EOPNOTSUPP;\n}\n\n \nint ntfs_sync_mft_mirror(ntfs_volume *vol, const unsigned long mft_no,\n\t\tMFT_RECORD *m, int sync)\n{\n\tstruct page *page;\n\tunsigned int blocksize = vol->sb->s_blocksize;\n\tint max_bhs = vol->mft_record_size / blocksize;\n\tstruct buffer_head *bhs[MAX_BHS];\n\tstruct buffer_head *bh, *head;\n\tu8 *kmirr;\n\trunlist_element *rl;\n\tunsigned int block_start, block_end, m_start, m_end, page_ofs;\n\tint i_bhs, nr_bhs, err = 0;\n\tunsigned char blocksize_bits = vol->sb->s_blocksize_bits;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", mft_no);\n\tBUG_ON(!max_bhs);\n\tif (WARN_ON(max_bhs > MAX_BHS))\n\t\treturn -EINVAL;\n\tif (unlikely(!vol->mftmirr_ino)) {\n\t\t \n\t\terr = ntfs_sync_mft_mirror_umount(vol, mft_no, m);\n\t\tif (likely(!err))\n\t\t\treturn err;\n\t\tgoto err_out;\n\t}\n\t \n\tpage = ntfs_map_page(vol->mftmirr_ino->i_mapping, mft_no >>\n\t\t\t(PAGE_SHIFT - vol->mft_record_size_bits));\n\tif (IS_ERR(page)) {\n\t\tntfs_error(vol->sb, \"Failed to map mft mirror page.\");\n\t\terr = PTR_ERR(page);\n\t\tgoto err_out;\n\t}\n\tlock_page(page);\n\tBUG_ON(!PageUptodate(page));\n\tClearPageUptodate(page);\n\t \n\tpage_ofs = (mft_no << vol->mft_record_size_bits) & ~PAGE_MASK;\n\t \n\tkmirr = page_address(page) + page_ofs;\n\t \n\tmemcpy(kmirr, m, vol->mft_record_size);\n\t \n\tif (unlikely(!page_has_buffers(page))) {\n\t\tstruct buffer_head *tail;\n\n\t\tbh = head = alloc_page_buffers(page, blocksize, true);\n\t\tdo {\n\t\t\tset_buffer_uptodate(bh);\n\t\t\ttail = bh;\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh);\n\t\ttail->b_this_page = head;\n\t\tattach_page_private(page, head);\n\t}\n\tbh = head = page_buffers(page);\n\tBUG_ON(!bh);\n\trl = NULL;\n\tnr_bhs = 0;\n\tblock_start = 0;\n\tm_start = kmirr - (u8*)page_address(page);\n\tm_end = m_start + vol->mft_record_size;\n\tdo {\n\t\tblock_end = block_start + blocksize;\n\t\t \n\t\tif (block_end <= m_start)\n\t\t\tcontinue;\n\t\tif (unlikely(block_start >= m_end))\n\t\t\tbreak;\n\t\t \n\t\tif (unlikely(!buffer_mapped(bh))) {\n\t\t\tVCN vcn;\n\t\t\tLCN lcn;\n\t\t\tunsigned int vcn_ofs;\n\n\t\t\tbh->b_bdev = vol->sb->s_bdev;\n\t\t\t \n\t\t\tvcn = ((VCN)mft_no << vol->mft_record_size_bits) +\n\t\t\t\t\t(block_start - m_start);\n\t\t\tvcn_ofs = vcn & vol->cluster_size_mask;\n\t\t\tvcn >>= vol->cluster_size_bits;\n\t\t\tif (!rl) {\n\t\t\t\tdown_read(&NTFS_I(vol->mftmirr_ino)->\n\t\t\t\t\t\trunlist.lock);\n\t\t\t\trl = NTFS_I(vol->mftmirr_ino)->runlist.rl;\n\t\t\t\t \n\t\t\t\tBUG_ON(!rl);\n\t\t\t}\n\t\t\t \n\t\t\twhile (rl->length && rl[1].vcn <= vcn)\n\t\t\t\trl++;\n\t\t\tlcn = ntfs_rl_vcn_to_lcn(rl, vcn);\n\t\t\t \n\t\t\tif (likely(lcn >= 0)) {\n\t\t\t\t \n\t\t\t\tbh->b_blocknr = ((lcn <<\n\t\t\t\t\t\tvol->cluster_size_bits) +\n\t\t\t\t\t\tvcn_ofs) >> blocksize_bits;\n\t\t\t\tset_buffer_mapped(bh);\n\t\t\t} else {\n\t\t\t\tbh->b_blocknr = -1;\n\t\t\t\tntfs_error(vol->sb, \"Cannot write mft mirror \"\n\t\t\t\t\t\t\"record 0x%lx because its \"\n\t\t\t\t\t\t\"location on disk could not \"\n\t\t\t\t\t\t\"be determined (error code \"\n\t\t\t\t\t\t\"%lli).\", mft_no,\n\t\t\t\t\t\t(long long)lcn);\n\t\t\t\terr = -EIO;\n\t\t\t}\n\t\t}\n\t\tBUG_ON(!buffer_uptodate(bh));\n\t\tBUG_ON(!nr_bhs && (m_start != block_start));\n\t\tBUG_ON(nr_bhs >= max_bhs);\n\t\tbhs[nr_bhs++] = bh;\n\t\tBUG_ON((nr_bhs >= max_bhs) && (m_end != block_end));\n\t} while (block_start = block_end, (bh = bh->b_this_page) != head);\n\tif (unlikely(rl))\n\t\tup_read(&NTFS_I(vol->mftmirr_ino)->runlist.lock);\n\tif (likely(!err)) {\n\t\t \n\t\tfor (i_bhs = 0; i_bhs < nr_bhs; i_bhs++) {\n\t\t\tstruct buffer_head *tbh = bhs[i_bhs];\n\n\t\t\tif (!trylock_buffer(tbh))\n\t\t\t\tBUG();\n\t\t\tBUG_ON(!buffer_uptodate(tbh));\n\t\t\tclear_buffer_dirty(tbh);\n\t\t\tget_bh(tbh);\n\t\t\ttbh->b_end_io = end_buffer_write_sync;\n\t\t\tsubmit_bh(REQ_OP_WRITE, tbh);\n\t\t}\n\t\t \n\t\tfor (i_bhs = 0; i_bhs < nr_bhs; i_bhs++) {\n\t\t\tstruct buffer_head *tbh = bhs[i_bhs];\n\n\t\t\twait_on_buffer(tbh);\n\t\t\tif (unlikely(!buffer_uptodate(tbh))) {\n\t\t\t\terr = -EIO;\n\t\t\t\t \n\t\t\t\tset_buffer_uptodate(tbh);\n\t\t\t}\n\t\t}\n\t} else   {\n\t\t \n\t\tfor (i_bhs = 0; i_bhs < nr_bhs; i_bhs++)\n\t\t\tclear_buffer_dirty(bhs[i_bhs]);\n\t}\n\t \n\t \n\tpost_write_mst_fixup((NTFS_RECORD*)kmirr);\n\tflush_dcache_page(page);\n\tSetPageUptodate(page);\n\tunlock_page(page);\n\tntfs_unmap_page(page);\n\tif (likely(!err)) {\n\t\tntfs_debug(\"Done.\");\n\t} else {\n\t\tntfs_error(vol->sb, \"I/O error while writing mft mirror \"\n\t\t\t\t\"record 0x%lx!\", mft_no);\nerr_out:\n\t\tntfs_error(vol->sb, \"Failed to synchronize $MFTMirr (error \"\n\t\t\t\t\"code %i).  Volume will be left marked dirty \"\n\t\t\t\t\"on umount.  Run ntfsfix on the partition \"\n\t\t\t\t\"after umounting to correct this.\", -err);\n\t\tNVolSetErrors(vol);\n\t}\n\treturn err;\n}\n\n \nint write_mft_record_nolock(ntfs_inode *ni, MFT_RECORD *m, int sync)\n{\n\tntfs_volume *vol = ni->vol;\n\tstruct page *page = ni->page;\n\tunsigned int blocksize = vol->sb->s_blocksize;\n\tunsigned char blocksize_bits = vol->sb->s_blocksize_bits;\n\tint max_bhs = vol->mft_record_size / blocksize;\n\tstruct buffer_head *bhs[MAX_BHS];\n\tstruct buffer_head *bh, *head;\n\trunlist_element *rl;\n\tunsigned int block_start, block_end, m_start, m_end;\n\tint i_bhs, nr_bhs, err = 0;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", ni->mft_no);\n\tBUG_ON(NInoAttr(ni));\n\tBUG_ON(!max_bhs);\n\tBUG_ON(!PageLocked(page));\n\tif (WARN_ON(max_bhs > MAX_BHS)) {\n\t\terr = -EINVAL;\n\t\tgoto err_out;\n\t}\n\t \n\tif (!NInoTestClearDirty(ni))\n\t\tgoto done;\n\tbh = head = page_buffers(page);\n\tBUG_ON(!bh);\n\trl = NULL;\n\tnr_bhs = 0;\n\tblock_start = 0;\n\tm_start = ni->page_ofs;\n\tm_end = m_start + vol->mft_record_size;\n\tdo {\n\t\tblock_end = block_start + blocksize;\n\t\t \n\t\tif (block_end <= m_start)\n\t\t\tcontinue;\n\t\tif (unlikely(block_start >= m_end))\n\t\t\tbreak;\n\t\t \n\t\tif (block_start == m_start) {\n\t\t\t \n\t\t\tif (!buffer_dirty(bh)) {\n\t\t\t\tBUG_ON(nr_bhs);\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (unlikely(!buffer_mapped(bh))) {\n\t\t\tVCN vcn;\n\t\t\tLCN lcn;\n\t\t\tunsigned int vcn_ofs;\n\n\t\t\tbh->b_bdev = vol->sb->s_bdev;\n\t\t\t \n\t\t\tvcn = ((VCN)ni->mft_no << vol->mft_record_size_bits) +\n\t\t\t\t\t(block_start - m_start);\n\t\t\tvcn_ofs = vcn & vol->cluster_size_mask;\n\t\t\tvcn >>= vol->cluster_size_bits;\n\t\t\tif (!rl) {\n\t\t\t\tdown_read(&NTFS_I(vol->mft_ino)->runlist.lock);\n\t\t\t\trl = NTFS_I(vol->mft_ino)->runlist.rl;\n\t\t\t\tBUG_ON(!rl);\n\t\t\t}\n\t\t\t \n\t\t\twhile (rl->length && rl[1].vcn <= vcn)\n\t\t\t\trl++;\n\t\t\tlcn = ntfs_rl_vcn_to_lcn(rl, vcn);\n\t\t\t \n\t\t\tif (likely(lcn >= 0)) {\n\t\t\t\t \n\t\t\t\tbh->b_blocknr = ((lcn <<\n\t\t\t\t\t\tvol->cluster_size_bits) +\n\t\t\t\t\t\tvcn_ofs) >> blocksize_bits;\n\t\t\t\tset_buffer_mapped(bh);\n\t\t\t} else {\n\t\t\t\tbh->b_blocknr = -1;\n\t\t\t\tntfs_error(vol->sb, \"Cannot write mft record \"\n\t\t\t\t\t\t\"0x%lx because its location \"\n\t\t\t\t\t\t\"on disk could not be \"\n\t\t\t\t\t\t\"determined (error code %lli).\",\n\t\t\t\t\t\tni->mft_no, (long long)lcn);\n\t\t\t\terr = -EIO;\n\t\t\t}\n\t\t}\n\t\tBUG_ON(!buffer_uptodate(bh));\n\t\tBUG_ON(!nr_bhs && (m_start != block_start));\n\t\tBUG_ON(nr_bhs >= max_bhs);\n\t\tbhs[nr_bhs++] = bh;\n\t\tBUG_ON((nr_bhs >= max_bhs) && (m_end != block_end));\n\t} while (block_start = block_end, (bh = bh->b_this_page) != head);\n\tif (unlikely(rl))\n\t\tup_read(&NTFS_I(vol->mft_ino)->runlist.lock);\n\tif (!nr_bhs)\n\t\tgoto done;\n\tif (unlikely(err))\n\t\tgoto cleanup_out;\n\t \n\terr = pre_write_mst_fixup((NTFS_RECORD*)m, vol->mft_record_size);\n\tif (err) {\n\t\tntfs_error(vol->sb, \"Failed to apply mst fixups!\");\n\t\tgoto cleanup_out;\n\t}\n\tflush_dcache_mft_record_page(ni);\n\t \n\tfor (i_bhs = 0; i_bhs < nr_bhs; i_bhs++) {\n\t\tstruct buffer_head *tbh = bhs[i_bhs];\n\n\t\tif (!trylock_buffer(tbh))\n\t\t\tBUG();\n\t\tBUG_ON(!buffer_uptodate(tbh));\n\t\tclear_buffer_dirty(tbh);\n\t\tget_bh(tbh);\n\t\ttbh->b_end_io = end_buffer_write_sync;\n\t\tsubmit_bh(REQ_OP_WRITE, tbh);\n\t}\n\t \n\tif (!sync && ni->mft_no < vol->mftmirr_size)\n\t\tntfs_sync_mft_mirror(vol, ni->mft_no, m, sync);\n\t \n\tfor (i_bhs = 0; i_bhs < nr_bhs; i_bhs++) {\n\t\tstruct buffer_head *tbh = bhs[i_bhs];\n\n\t\twait_on_buffer(tbh);\n\t\tif (unlikely(!buffer_uptodate(tbh))) {\n\t\t\terr = -EIO;\n\t\t\t \n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(tbh);\n\t\t}\n\t}\n\t \n\tif (sync && ni->mft_no < vol->mftmirr_size)\n\t\tntfs_sync_mft_mirror(vol, ni->mft_no, m, sync);\n\t \n\tpost_write_mst_fixup((NTFS_RECORD*)m);\n\tflush_dcache_mft_record_page(ni);\n\tif (unlikely(err)) {\n\t\t \n\t\tntfs_error(vol->sb, \"I/O error while writing mft record \"\n\t\t\t\t\"0x%lx!  Marking base inode as bad.  You \"\n\t\t\t\t\"should unmount the volume and run chkdsk.\",\n\t\t\t\tni->mft_no);\n\t\tgoto err_out;\n\t}\ndone:\n\tntfs_debug(\"Done.\");\n\treturn 0;\ncleanup_out:\n\t \n\tfor (i_bhs = 0; i_bhs < nr_bhs; i_bhs++)\n\t\tclear_buffer_dirty(bhs[i_bhs]);\nerr_out:\n\t \n\tif (err == -ENOMEM) {\n\t\tntfs_error(vol->sb, \"Not enough memory to write mft record.  \"\n\t\t\t\t\"Redirtying so the write is retried later.\");\n\t\tmark_mft_record_dirty(ni);\n\t\terr = 0;\n\t} else\n\t\tNVolSetErrors(vol);\n\treturn err;\n}\n\n \nbool ntfs_may_write_mft_record(ntfs_volume *vol, const unsigned long mft_no,\n\t\tconst MFT_RECORD *m, ntfs_inode **locked_ni)\n{\n\tstruct super_block *sb = vol->sb;\n\tstruct inode *mft_vi = vol->mft_ino;\n\tstruct inode *vi;\n\tntfs_inode *ni, *eni, **extent_nis;\n\tint i;\n\tntfs_attr na;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", mft_no);\n\t \n\tBUG_ON(!locked_ni);\n\t*locked_ni = NULL;\n\t \n\tntfs_debug(\"Looking for inode 0x%lx in icache.\", mft_no);\n\tna.mft_no = mft_no;\n\tna.name = NULL;\n\tna.name_len = 0;\n\tna.type = AT_UNUSED;\n\t \n\tif (!mft_no) {\n\t\t \n\t\tvi = igrab(mft_vi);\n\t\tBUG_ON(vi != mft_vi);\n\t} else {\n\t\t \n\t\tvi = ilookup5_nowait(sb, mft_no, ntfs_test_inode, &na);\n\t}\n\tif (vi) {\n\t\tntfs_debug(\"Base inode 0x%lx is in icache.\", mft_no);\n\t\t \n\t\tni = NTFS_I(vi);\n\t\t \n\t\tatomic_inc(&ni->count);\n\t\t \n\t\tif (NInoDirty(ni)) {\n\t\t\tntfs_debug(\"Inode 0x%lx is dirty, do not write it.\",\n\t\t\t\t\tmft_no);\n\t\t\tatomic_dec(&ni->count);\n\t\t\tiput(vi);\n\t\t\treturn false;\n\t\t}\n\t\tntfs_debug(\"Inode 0x%lx is not dirty.\", mft_no);\n\t\t \n\t\tif (unlikely(!mutex_trylock(&ni->mrec_lock))) {\n\t\t\tntfs_debug(\"Mft record 0x%lx is already locked, do \"\n\t\t\t\t\t\"not write it.\", mft_no);\n\t\t\tatomic_dec(&ni->count);\n\t\t\tiput(vi);\n\t\t\treturn false;\n\t\t}\n\t\tntfs_debug(\"Managed to lock mft record 0x%lx, write it.\",\n\t\t\t\tmft_no);\n\t\t \n\t\t*locked_ni = ni;\n\t\treturn true;\n\t}\n\tntfs_debug(\"Inode 0x%lx is not in icache.\", mft_no);\n\t \n\t \n\tif (!ntfs_is_mft_record(m->magic)) {\n\t\tntfs_debug(\"Mft record 0x%lx is not a FILE record, write it.\",\n\t\t\t\tmft_no);\n\t\treturn true;\n\t}\n\t \n\tif (!m->base_mft_record) {\n\t\tntfs_debug(\"Mft record 0x%lx is a base record, write it.\",\n\t\t\t\tmft_no);\n\t\treturn true;\n\t}\n\t \n\tna.mft_no = MREF_LE(m->base_mft_record);\n\tntfs_debug(\"Mft record 0x%lx is an extent record.  Looking for base \"\n\t\t\t\"inode 0x%lx in icache.\", mft_no, na.mft_no);\n\tif (!na.mft_no) {\n\t\t \n\t\tvi = igrab(mft_vi);\n\t\tBUG_ON(vi != mft_vi);\n\t} else\n\t\tvi = ilookup5_nowait(sb, na.mft_no, ntfs_test_inode,\n\t\t\t\t&na);\n\tif (!vi) {\n\t\t \n\t\tntfs_debug(\"Base inode 0x%lx is not in icache, write the \"\n\t\t\t\t\"extent record.\", na.mft_no);\n\t\treturn true;\n\t}\n\tntfs_debug(\"Base inode 0x%lx is in icache.\", na.mft_no);\n\t \n\tni = NTFS_I(vi);\n\tmutex_lock(&ni->extent_lock);\n\tif (ni->nr_extents <= 0) {\n\t\t \n\t\tmutex_unlock(&ni->extent_lock);\n\t\tiput(vi);\n\t\tntfs_debug(\"Base inode 0x%lx has no attached extent inodes, \"\n\t\t\t\t\"write the extent record.\", na.mft_no);\n\t\treturn true;\n\t}\n\t \n\textent_nis = ni->ext.extent_ntfs_inos;\n\tfor (eni = NULL, i = 0; i < ni->nr_extents; ++i) {\n\t\tif (mft_no == extent_nis[i]->mft_no) {\n\t\t\t \n\t\t\teni = extent_nis[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\t \n\tif (!eni) {\n\t\tmutex_unlock(&ni->extent_lock);\n\t\tiput(vi);\n\t\tntfs_debug(\"Extent inode 0x%lx is not attached to its base \"\n\t\t\t\t\"inode 0x%lx, write the extent record.\",\n\t\t\t\tmft_no, na.mft_no);\n\t\treturn true;\n\t}\n\tntfs_debug(\"Extent inode 0x%lx is attached to its base inode 0x%lx.\",\n\t\t\tmft_no, na.mft_no);\n\t \n\tatomic_inc(&eni->count);\n\tmutex_unlock(&ni->extent_lock);\n\t \n\tif (unlikely(!mutex_trylock(&eni->mrec_lock))) {\n\t\tatomic_dec(&eni->count);\n\t\tiput(vi);\n\t\tntfs_debug(\"Extent mft record 0x%lx is already locked, do \"\n\t\t\t\t\"not write it.\", mft_no);\n\t\treturn false;\n\t}\n\tntfs_debug(\"Managed to lock extent mft record 0x%lx, write it.\",\n\t\t\tmft_no);\n\tif (NInoTestClearDirty(eni))\n\t\tntfs_debug(\"Extent inode 0x%lx is dirty, marking it clean.\",\n\t\t\t\tmft_no);\n\t \n\t*locked_ni = eni;\n\treturn true;\n}\n\nstatic const char *es = \"  Leaving inconsistent metadata.  Unmount and run \"\n\t\t\"chkdsk.\";\n\n \nstatic int ntfs_mft_bitmap_find_and_alloc_free_rec_nolock(ntfs_volume *vol,\n\t\tntfs_inode *base_ni)\n{\n\ts64 pass_end, ll, data_pos, pass_start, ofs, bit;\n\tunsigned long flags;\n\tstruct address_space *mftbmp_mapping;\n\tu8 *buf, *byte;\n\tstruct page *page;\n\tunsigned int page_ofs, size;\n\tu8 pass, b;\n\n\tntfs_debug(\"Searching for free mft record in the currently \"\n\t\t\t\"initialized mft bitmap.\");\n\tmftbmp_mapping = vol->mftbmp_ino->i_mapping;\n\t \n\tread_lock_irqsave(&NTFS_I(vol->mft_ino)->size_lock, flags);\n\tpass_end = NTFS_I(vol->mft_ino)->allocated_size >>\n\t\t\tvol->mft_record_size_bits;\n\tread_unlock_irqrestore(&NTFS_I(vol->mft_ino)->size_lock, flags);\n\tread_lock_irqsave(&NTFS_I(vol->mftbmp_ino)->size_lock, flags);\n\tll = NTFS_I(vol->mftbmp_ino)->initialized_size << 3;\n\tread_unlock_irqrestore(&NTFS_I(vol->mftbmp_ino)->size_lock, flags);\n\tif (pass_end > ll)\n\t\tpass_end = ll;\n\tpass = 1;\n\tif (!base_ni)\n\t\tdata_pos = vol->mft_data_pos;\n\telse\n\t\tdata_pos = base_ni->mft_no + 1;\n\tif (data_pos < 24)\n\t\tdata_pos = 24;\n\tif (data_pos >= pass_end) {\n\t\tdata_pos = 24;\n\t\tpass = 2;\n\t\t \n\t\tif (data_pos >= pass_end)\n\t\t\treturn -ENOSPC;\n\t}\n\tpass_start = data_pos;\n\tntfs_debug(\"Starting bitmap search: pass %u, pass_start 0x%llx, \"\n\t\t\t\"pass_end 0x%llx, data_pos 0x%llx.\", pass,\n\t\t\t(long long)pass_start, (long long)pass_end,\n\t\t\t(long long)data_pos);\n\t \n\tfor (; pass <= 2;) {\n\t\t \n\t\tofs = data_pos >> 3;\n\t\tpage_ofs = ofs & ~PAGE_MASK;\n\t\tsize = PAGE_SIZE - page_ofs;\n\t\tll = ((pass_end + 7) >> 3) - ofs;\n\t\tif (size > ll)\n\t\t\tsize = ll;\n\t\tsize <<= 3;\n\t\t \n\t\tif (size) {\n\t\t\tpage = ntfs_map_page(mftbmp_mapping,\n\t\t\t\t\tofs >> PAGE_SHIFT);\n\t\t\tif (IS_ERR(page)) {\n\t\t\t\tntfs_error(vol->sb, \"Failed to read mft \"\n\t\t\t\t\t\t\"bitmap, aborting.\");\n\t\t\t\treturn PTR_ERR(page);\n\t\t\t}\n\t\t\tbuf = (u8*)page_address(page) + page_ofs;\n\t\t\tbit = data_pos & 7;\n\t\t\tdata_pos &= ~7ull;\n\t\t\tntfs_debug(\"Before inner for loop: size 0x%x, \"\n\t\t\t\t\t\"data_pos 0x%llx, bit 0x%llx\", size,\n\t\t\t\t\t(long long)data_pos, (long long)bit);\n\t\t\tfor (; bit < size && data_pos + bit < pass_end;\n\t\t\t\t\tbit &= ~7ull, bit += 8) {\n\t\t\t\tbyte = buf + (bit >> 3);\n\t\t\t\tif (*byte == 0xff)\n\t\t\t\t\tcontinue;\n\t\t\t\tb = ffz((unsigned long)*byte);\n\t\t\t\tif (b < 8 && b >= (bit & 7)) {\n\t\t\t\t\tll = data_pos + (bit & ~7ull) + b;\n\t\t\t\t\tif (unlikely(ll > (1ll << 32))) {\n\t\t\t\t\t\tntfs_unmap_page(page);\n\t\t\t\t\t\treturn -ENOSPC;\n\t\t\t\t\t}\n\t\t\t\t\t*byte |= 1 << b;\n\t\t\t\t\tflush_dcache_page(page);\n\t\t\t\t\tset_page_dirty(page);\n\t\t\t\t\tntfs_unmap_page(page);\n\t\t\t\t\tntfs_debug(\"Done.  (Found and \"\n\t\t\t\t\t\t\t\"allocated mft record \"\n\t\t\t\t\t\t\t\"0x%llx.)\",\n\t\t\t\t\t\t\t(long long)ll);\n\t\t\t\t\treturn ll;\n\t\t\t\t}\n\t\t\t}\n\t\t\tntfs_debug(\"After inner for loop: size 0x%x, \"\n\t\t\t\t\t\"data_pos 0x%llx, bit 0x%llx\", size,\n\t\t\t\t\t(long long)data_pos, (long long)bit);\n\t\t\tdata_pos += size;\n\t\t\tntfs_unmap_page(page);\n\t\t\t \n\t\t\tif (data_pos < pass_end)\n\t\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (++pass == 2) {\n\t\t\t \n\t\t\tpass_end = pass_start;\n\t\t\tdata_pos = pass_start = 24;\n\t\t\tntfs_debug(\"pass %i, pass_start 0x%llx, pass_end \"\n\t\t\t\t\t\"0x%llx.\", pass, (long long)pass_start,\n\t\t\t\t\t(long long)pass_end);\n\t\t\tif (data_pos >= pass_end)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t \n\tntfs_debug(\"Done.  (No free mft records left in currently initialized \"\n\t\t\t\"mft bitmap.)\");\n\treturn -ENOSPC;\n}\n\n \nstatic int ntfs_mft_bitmap_extend_allocation_nolock(ntfs_volume *vol)\n{\n\tLCN lcn;\n\ts64 ll;\n\tunsigned long flags;\n\tstruct page *page;\n\tntfs_inode *mft_ni, *mftbmp_ni;\n\trunlist_element *rl, *rl2 = NULL;\n\tntfs_attr_search_ctx *ctx = NULL;\n\tMFT_RECORD *mrec;\n\tATTR_RECORD *a = NULL;\n\tint ret, mp_size;\n\tu32 old_alen = 0;\n\tu8 *b, tb;\n\tstruct {\n\t\tu8 added_cluster:1;\n\t\tu8 added_run:1;\n\t\tu8 mp_rebuilt:1;\n\t} status = { 0, 0, 0 };\n\n\tntfs_debug(\"Extending mft bitmap allocation.\");\n\tmft_ni = NTFS_I(vol->mft_ino);\n\tmftbmp_ni = NTFS_I(vol->mftbmp_ino);\n\t \n\tdown_write(&mftbmp_ni->runlist.lock);\n\tread_lock_irqsave(&mftbmp_ni->size_lock, flags);\n\tll = mftbmp_ni->allocated_size;\n\tread_unlock_irqrestore(&mftbmp_ni->size_lock, flags);\n\trl = ntfs_attr_find_vcn_nolock(mftbmp_ni,\n\t\t\t(ll - 1) >> vol->cluster_size_bits, NULL);\n\tif (IS_ERR(rl) || unlikely(!rl->length || rl->lcn < 0)) {\n\t\tup_write(&mftbmp_ni->runlist.lock);\n\t\tntfs_error(vol->sb, \"Failed to determine last allocated \"\n\t\t\t\t\"cluster of mft bitmap attribute.\");\n\t\tif (!IS_ERR(rl))\n\t\t\tret = -EIO;\n\t\telse\n\t\t\tret = PTR_ERR(rl);\n\t\treturn ret;\n\t}\n\tlcn = rl->lcn + rl->length;\n\tntfs_debug(\"Last lcn of mft bitmap attribute is 0x%llx.\",\n\t\t\t(long long)lcn);\n\t \n\tll = lcn >> 3;\n\tpage = ntfs_map_page(vol->lcnbmp_ino->i_mapping,\n\t\t\tll >> PAGE_SHIFT);\n\tif (IS_ERR(page)) {\n\t\tup_write(&mftbmp_ni->runlist.lock);\n\t\tntfs_error(vol->sb, \"Failed to read from lcn bitmap.\");\n\t\treturn PTR_ERR(page);\n\t}\n\tb = (u8*)page_address(page) + (ll & ~PAGE_MASK);\n\ttb = 1 << (lcn & 7ull);\n\tdown_write(&vol->lcnbmp_lock);\n\tif (*b != 0xff && !(*b & tb)) {\n\t\t \n\t\t*b |= tb;\n\t\tflush_dcache_page(page);\n\t\tset_page_dirty(page);\n\t\tup_write(&vol->lcnbmp_lock);\n\t\tntfs_unmap_page(page);\n\t\t \n\t\trl->length++;\n\t\trl[1].vcn++;\n\t\tstatus.added_cluster = 1;\n\t\tntfs_debug(\"Appending one cluster to mft bitmap.\");\n\t} else {\n\t\tup_write(&vol->lcnbmp_lock);\n\t\tntfs_unmap_page(page);\n\t\t \n\t\trl2 = ntfs_cluster_alloc(vol, rl[1].vcn, 1, lcn, DATA_ZONE,\n\t\t\t\ttrue);\n\t\tif (IS_ERR(rl2)) {\n\t\t\tup_write(&mftbmp_ni->runlist.lock);\n\t\t\tntfs_error(vol->sb, \"Failed to allocate a cluster for \"\n\t\t\t\t\t\"the mft bitmap.\");\n\t\t\treturn PTR_ERR(rl2);\n\t\t}\n\t\trl = ntfs_runlists_merge(mftbmp_ni->runlist.rl, rl2);\n\t\tif (IS_ERR(rl)) {\n\t\t\tup_write(&mftbmp_ni->runlist.lock);\n\t\t\tntfs_error(vol->sb, \"Failed to merge runlists for mft \"\n\t\t\t\t\t\"bitmap.\");\n\t\t\tif (ntfs_cluster_free_from_rl(vol, rl2)) {\n\t\t\t\tntfs_error(vol->sb, \"Failed to deallocate \"\n\t\t\t\t\t\t\"allocated cluster.%s\", es);\n\t\t\t\tNVolSetErrors(vol);\n\t\t\t}\n\t\t\tntfs_free(rl2);\n\t\t\treturn PTR_ERR(rl);\n\t\t}\n\t\tmftbmp_ni->runlist.rl = rl;\n\t\tstatus.added_run = 1;\n\t\tntfs_debug(\"Adding one run to mft bitmap.\");\n\t\t \n\t\tfor (; rl[1].length; rl++)\n\t\t\t;\n\t}\n\t \n\tmrec = map_mft_record(mft_ni);\n\tif (IS_ERR(mrec)) {\n\t\tntfs_error(vol->sb, \"Failed to map mft record.\");\n\t\tret = PTR_ERR(mrec);\n\t\tgoto undo_alloc;\n\t}\n\tctx = ntfs_attr_get_search_ctx(mft_ni, mrec);\n\tif (unlikely(!ctx)) {\n\t\tntfs_error(vol->sb, \"Failed to get search context.\");\n\t\tret = -ENOMEM;\n\t\tgoto undo_alloc;\n\t}\n\tret = ntfs_attr_lookup(mftbmp_ni->type, mftbmp_ni->name,\n\t\t\tmftbmp_ni->name_len, CASE_SENSITIVE, rl[1].vcn, NULL,\n\t\t\t0, ctx);\n\tif (unlikely(ret)) {\n\t\tntfs_error(vol->sb, \"Failed to find last attribute extent of \"\n\t\t\t\t\"mft bitmap attribute.\");\n\t\tif (ret == -ENOENT)\n\t\t\tret = -EIO;\n\t\tgoto undo_alloc;\n\t}\n\ta = ctx->attr;\n\tll = sle64_to_cpu(a->data.non_resident.lowest_vcn);\n\t \n\tfor (rl2 = rl; rl2 > mftbmp_ni->runlist.rl; rl2--) {\n\t\tif (ll >= rl2->vcn)\n\t\t\tbreak;\n\t}\n\tBUG_ON(ll < rl2->vcn);\n\tBUG_ON(ll >= rl2->vcn + rl2->length);\n\t \n\tmp_size = ntfs_get_size_for_mapping_pairs(vol, rl2, ll, -1);\n\tif (unlikely(mp_size <= 0)) {\n\t\tntfs_error(vol->sb, \"Get size for mapping pairs failed for \"\n\t\t\t\t\"mft bitmap attribute extent.\");\n\t\tret = mp_size;\n\t\tif (!ret)\n\t\t\tret = -EIO;\n\t\tgoto undo_alloc;\n\t}\n\t \n\told_alen = le32_to_cpu(a->length);\n\tret = ntfs_attr_record_resize(ctx->mrec, a, mp_size +\n\t\t\tle16_to_cpu(a->data.non_resident.mapping_pairs_offset));\n\tif (unlikely(ret)) {\n\t\tif (ret != -ENOSPC) {\n\t\t\tntfs_error(vol->sb, \"Failed to resize attribute \"\n\t\t\t\t\t\"record for mft bitmap attribute.\");\n\t\t\tgoto undo_alloc;\n\t\t}\n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\tntfs_error(vol->sb, \"Not enough space in this mft record to \"\n\t\t\t\t\"accommodate extended mft bitmap attribute \"\n\t\t\t\t\"extent.  Cannot handle this yet.\");\n\t\tret = -EOPNOTSUPP;\n\t\tgoto undo_alloc;\n\t}\n\tstatus.mp_rebuilt = 1;\n\t \n\tret = ntfs_mapping_pairs_build(vol, (u8*)a +\n\t\t\tle16_to_cpu(a->data.non_resident.mapping_pairs_offset),\n\t\t\tmp_size, rl2, ll, -1, NULL);\n\tif (unlikely(ret)) {\n\t\tntfs_error(vol->sb, \"Failed to build mapping pairs array for \"\n\t\t\t\t\"mft bitmap attribute.\");\n\t\tgoto undo_alloc;\n\t}\n\t \n\ta->data.non_resident.highest_vcn = cpu_to_sle64(rl[1].vcn - 1);\n\t \n\tif (a->data.non_resident.lowest_vcn) {\n\t\t \n\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\tret = ntfs_attr_lookup(mftbmp_ni->type, mftbmp_ni->name,\n\t\t\t\tmftbmp_ni->name_len, CASE_SENSITIVE, 0, NULL,\n\t\t\t\t0, ctx);\n\t\tif (unlikely(ret)) {\n\t\t\tntfs_error(vol->sb, \"Failed to find first attribute \"\n\t\t\t\t\t\"extent of mft bitmap attribute.\");\n\t\t\tgoto restore_undo_alloc;\n\t\t}\n\t\ta = ctx->attr;\n\t}\n\twrite_lock_irqsave(&mftbmp_ni->size_lock, flags);\n\tmftbmp_ni->allocated_size += vol->cluster_size;\n\ta->data.non_resident.allocated_size =\n\t\t\tcpu_to_sle64(mftbmp_ni->allocated_size);\n\twrite_unlock_irqrestore(&mftbmp_ni->size_lock, flags);\n\t \n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(mft_ni);\n\tup_write(&mftbmp_ni->runlist.lock);\n\tntfs_debug(\"Done.\");\n\treturn 0;\nrestore_undo_alloc:\n\tntfs_attr_reinit_search_ctx(ctx);\n\tif (ntfs_attr_lookup(mftbmp_ni->type, mftbmp_ni->name,\n\t\t\tmftbmp_ni->name_len, CASE_SENSITIVE, rl[1].vcn, NULL,\n\t\t\t0, ctx)) {\n\t\tntfs_error(vol->sb, \"Failed to find last attribute extent of \"\n\t\t\t\t\"mft bitmap attribute.%s\", es);\n\t\twrite_lock_irqsave(&mftbmp_ni->size_lock, flags);\n\t\tmftbmp_ni->allocated_size += vol->cluster_size;\n\t\twrite_unlock_irqrestore(&mftbmp_ni->size_lock, flags);\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(mft_ni);\n\t\tup_write(&mftbmp_ni->runlist.lock);\n\t\t \n\t\tNVolSetErrors(vol);\n\t\treturn ret;\n\t}\n\ta = ctx->attr;\n\ta->data.non_resident.highest_vcn = cpu_to_sle64(rl[1].vcn - 2);\nundo_alloc:\n\tif (status.added_cluster) {\n\t\t \n\t\trl->length--;\n\t\trl[1].vcn--;\n\t} else if (status.added_run) {\n\t\tlcn = rl->lcn;\n\t\t \n\t\trl->lcn = rl[1].lcn;\n\t\trl->length = 0;\n\t}\n\t \n\tdown_write(&vol->lcnbmp_lock);\n\tif (ntfs_bitmap_clear_bit(vol->lcnbmp_ino, lcn)) {\n\t\tntfs_error(vol->sb, \"Failed to free allocated cluster.%s\", es);\n\t\tNVolSetErrors(vol);\n\t}\n\tup_write(&vol->lcnbmp_lock);\n\tif (status.mp_rebuilt) {\n\t\tif (ntfs_mapping_pairs_build(vol, (u8*)a + le16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset),\n\t\t\t\told_alen - le16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset),\n\t\t\t\trl2, ll, -1, NULL)) {\n\t\t\tntfs_error(vol->sb, \"Failed to restore mapping pairs \"\n\t\t\t\t\t\"array.%s\", es);\n\t\t\tNVolSetErrors(vol);\n\t\t}\n\t\tif (ntfs_attr_record_resize(ctx->mrec, a, old_alen)) {\n\t\t\tntfs_error(vol->sb, \"Failed to restore attribute \"\n\t\t\t\t\t\"record.%s\", es);\n\t\t\tNVolSetErrors(vol);\n\t\t}\n\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t}\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (!IS_ERR(mrec))\n\t\tunmap_mft_record(mft_ni);\n\tup_write(&mftbmp_ni->runlist.lock);\n\treturn ret;\n}\n\n \nstatic int ntfs_mft_bitmap_extend_initialized_nolock(ntfs_volume *vol)\n{\n\ts64 old_data_size, old_initialized_size;\n\tunsigned long flags;\n\tstruct inode *mftbmp_vi;\n\tntfs_inode *mft_ni, *mftbmp_ni;\n\tntfs_attr_search_ctx *ctx;\n\tMFT_RECORD *mrec;\n\tATTR_RECORD *a;\n\tint ret;\n\n\tntfs_debug(\"Extending mft bitmap initiailized (and data) size.\");\n\tmft_ni = NTFS_I(vol->mft_ino);\n\tmftbmp_vi = vol->mftbmp_ino;\n\tmftbmp_ni = NTFS_I(mftbmp_vi);\n\t \n\tmrec = map_mft_record(mft_ni);\n\tif (IS_ERR(mrec)) {\n\t\tntfs_error(vol->sb, \"Failed to map mft record.\");\n\t\treturn PTR_ERR(mrec);\n\t}\n\tctx = ntfs_attr_get_search_ctx(mft_ni, mrec);\n\tif (unlikely(!ctx)) {\n\t\tntfs_error(vol->sb, \"Failed to get search context.\");\n\t\tret = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\tret = ntfs_attr_lookup(mftbmp_ni->type, mftbmp_ni->name,\n\t\t\tmftbmp_ni->name_len, CASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(ret)) {\n\t\tntfs_error(vol->sb, \"Failed to find first attribute extent of \"\n\t\t\t\t\"mft bitmap attribute.\");\n\t\tif (ret == -ENOENT)\n\t\t\tret = -EIO;\n\t\tgoto put_err_out;\n\t}\n\ta = ctx->attr;\n\twrite_lock_irqsave(&mftbmp_ni->size_lock, flags);\n\told_data_size = i_size_read(mftbmp_vi);\n\told_initialized_size = mftbmp_ni->initialized_size;\n\t \n\tmftbmp_ni->initialized_size += 8;\n\ta->data.non_resident.initialized_size =\n\t\t\tcpu_to_sle64(mftbmp_ni->initialized_size);\n\tif (mftbmp_ni->initialized_size > old_data_size) {\n\t\ti_size_write(mftbmp_vi, mftbmp_ni->initialized_size);\n\t\ta->data.non_resident.data_size =\n\t\t\t\tcpu_to_sle64(mftbmp_ni->initialized_size);\n\t}\n\twrite_unlock_irqrestore(&mftbmp_ni->size_lock, flags);\n\t \n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(mft_ni);\n\t \n\tret = ntfs_attr_set(mftbmp_ni, old_initialized_size, 8, 0);\n\tif (likely(!ret)) {\n\t\tntfs_debug(\"Done.  (Wrote eight initialized bytes to mft \"\n\t\t\t\t\"bitmap.\");\n\t\treturn 0;\n\t}\n\tntfs_error(vol->sb, \"Failed to write to mft bitmap.\");\n\t \n\tmrec = map_mft_record(mft_ni);\n\tif (IS_ERR(mrec)) {\n\t\tntfs_error(vol->sb, \"Failed to map mft record.%s\", es);\n\t\tNVolSetErrors(vol);\n\t\treturn ret;\n\t}\n\tctx = ntfs_attr_get_search_ctx(mft_ni, mrec);\n\tif (unlikely(!ctx)) {\n\t\tntfs_error(vol->sb, \"Failed to get search context.%s\", es);\n\t\tNVolSetErrors(vol);\n\t\tgoto unm_err_out;\n\t}\n\tif (ntfs_attr_lookup(mftbmp_ni->type, mftbmp_ni->name,\n\t\t\tmftbmp_ni->name_len, CASE_SENSITIVE, 0, NULL, 0, ctx)) {\n\t\tntfs_error(vol->sb, \"Failed to find first attribute extent of \"\n\t\t\t\t\"mft bitmap attribute.%s\", es);\n\t\tNVolSetErrors(vol);\nput_err_out:\n\t\tntfs_attr_put_search_ctx(ctx);\nunm_err_out:\n\t\tunmap_mft_record(mft_ni);\n\t\tgoto err_out;\n\t}\n\ta = ctx->attr;\n\twrite_lock_irqsave(&mftbmp_ni->size_lock, flags);\n\tmftbmp_ni->initialized_size = old_initialized_size;\n\ta->data.non_resident.initialized_size =\n\t\t\tcpu_to_sle64(old_initialized_size);\n\tif (i_size_read(mftbmp_vi) != old_data_size) {\n\t\ti_size_write(mftbmp_vi, old_data_size);\n\t\ta->data.non_resident.data_size = cpu_to_sle64(old_data_size);\n\t}\n\twrite_unlock_irqrestore(&mftbmp_ni->size_lock, flags);\n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(mft_ni);\n#ifdef DEBUG\n\tread_lock_irqsave(&mftbmp_ni->size_lock, flags);\n\tntfs_debug(\"Restored status of mftbmp: allocated_size 0x%llx, \"\n\t\t\t\"data_size 0x%llx, initialized_size 0x%llx.\",\n\t\t\t(long long)mftbmp_ni->allocated_size,\n\t\t\t(long long)i_size_read(mftbmp_vi),\n\t\t\t(long long)mftbmp_ni->initialized_size);\n\tread_unlock_irqrestore(&mftbmp_ni->size_lock, flags);\n#endif  \nerr_out:\n\treturn ret;\n}\n\n \nstatic int ntfs_mft_data_extend_allocation_nolock(ntfs_volume *vol)\n{\n\tLCN lcn;\n\tVCN old_last_vcn;\n\ts64 min_nr, nr, ll;\n\tunsigned long flags;\n\tntfs_inode *mft_ni;\n\trunlist_element *rl, *rl2;\n\tntfs_attr_search_ctx *ctx = NULL;\n\tMFT_RECORD *mrec;\n\tATTR_RECORD *a = NULL;\n\tint ret, mp_size;\n\tu32 old_alen = 0;\n\tbool mp_rebuilt = false;\n\n\tntfs_debug(\"Extending mft data allocation.\");\n\tmft_ni = NTFS_I(vol->mft_ino);\n\t \n\tdown_write(&mft_ni->runlist.lock);\n\tread_lock_irqsave(&mft_ni->size_lock, flags);\n\tll = mft_ni->allocated_size;\n\tread_unlock_irqrestore(&mft_ni->size_lock, flags);\n\trl = ntfs_attr_find_vcn_nolock(mft_ni,\n\t\t\t(ll - 1) >> vol->cluster_size_bits, NULL);\n\tif (IS_ERR(rl) || unlikely(!rl->length || rl->lcn < 0)) {\n\t\tup_write(&mft_ni->runlist.lock);\n\t\tntfs_error(vol->sb, \"Failed to determine last allocated \"\n\t\t\t\t\"cluster of mft data attribute.\");\n\t\tif (!IS_ERR(rl))\n\t\t\tret = -EIO;\n\t\telse\n\t\t\tret = PTR_ERR(rl);\n\t\treturn ret;\n\t}\n\tlcn = rl->lcn + rl->length;\n\tntfs_debug(\"Last lcn of mft data attribute is 0x%llx.\", (long long)lcn);\n\t \n\tmin_nr = vol->mft_record_size >> vol->cluster_size_bits;\n\tif (!min_nr)\n\t\tmin_nr = 1;\n\t \n\tnr = vol->mft_record_size << 4 >> vol->cluster_size_bits;\n\tif (!nr)\n\t\tnr = min_nr;\n\t \n\tread_lock_irqsave(&mft_ni->size_lock, flags);\n\tll = mft_ni->allocated_size;\n\tread_unlock_irqrestore(&mft_ni->size_lock, flags);\n\tif (unlikely((ll + (nr << vol->cluster_size_bits)) >>\n\t\t\tvol->mft_record_size_bits >= (1ll << 32))) {\n\t\tnr = min_nr;\n\t\tif (unlikely((ll + (nr << vol->cluster_size_bits)) >>\n\t\t\t\tvol->mft_record_size_bits >= (1ll << 32))) {\n\t\t\tntfs_warning(vol->sb, \"Cannot allocate mft record \"\n\t\t\t\t\t\"because the maximum number of inodes \"\n\t\t\t\t\t\"(2^32) has already been reached.\");\n\t\t\tup_write(&mft_ni->runlist.lock);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t}\n\tntfs_debug(\"Trying mft data allocation with %s cluster count %lli.\",\n\t\t\tnr > min_nr ? \"default\" : \"minimal\", (long long)nr);\n\told_last_vcn = rl[1].vcn;\n\tdo {\n\t\trl2 = ntfs_cluster_alloc(vol, old_last_vcn, nr, lcn, MFT_ZONE,\n\t\t\t\ttrue);\n\t\tif (!IS_ERR(rl2))\n\t\t\tbreak;\n\t\tif (PTR_ERR(rl2) != -ENOSPC || nr == min_nr) {\n\t\t\tntfs_error(vol->sb, \"Failed to allocate the minimal \"\n\t\t\t\t\t\"number of clusters (%lli) for the \"\n\t\t\t\t\t\"mft data attribute.\", (long long)nr);\n\t\t\tup_write(&mft_ni->runlist.lock);\n\t\t\treturn PTR_ERR(rl2);\n\t\t}\n\t\t \n\t\tnr = min_nr;\n\t\tntfs_debug(\"Retrying mft data allocation with minimal cluster \"\n\t\t\t\t\"count %lli.\", (long long)nr);\n\t} while (1);\n\trl = ntfs_runlists_merge(mft_ni->runlist.rl, rl2);\n\tif (IS_ERR(rl)) {\n\t\tup_write(&mft_ni->runlist.lock);\n\t\tntfs_error(vol->sb, \"Failed to merge runlists for mft data \"\n\t\t\t\t\"attribute.\");\n\t\tif (ntfs_cluster_free_from_rl(vol, rl2)) {\n\t\t\tntfs_error(vol->sb, \"Failed to deallocate clusters \"\n\t\t\t\t\t\"from the mft data attribute.%s\", es);\n\t\t\tNVolSetErrors(vol);\n\t\t}\n\t\tntfs_free(rl2);\n\t\treturn PTR_ERR(rl);\n\t}\n\tmft_ni->runlist.rl = rl;\n\tntfs_debug(\"Allocated %lli clusters.\", (long long)nr);\n\t \n\tfor (; rl[1].length; rl++)\n\t\t;\n\t \n\tmrec = map_mft_record(mft_ni);\n\tif (IS_ERR(mrec)) {\n\t\tntfs_error(vol->sb, \"Failed to map mft record.\");\n\t\tret = PTR_ERR(mrec);\n\t\tgoto undo_alloc;\n\t}\n\tctx = ntfs_attr_get_search_ctx(mft_ni, mrec);\n\tif (unlikely(!ctx)) {\n\t\tntfs_error(vol->sb, \"Failed to get search context.\");\n\t\tret = -ENOMEM;\n\t\tgoto undo_alloc;\n\t}\n\tret = ntfs_attr_lookup(mft_ni->type, mft_ni->name, mft_ni->name_len,\n\t\t\tCASE_SENSITIVE, rl[1].vcn, NULL, 0, ctx);\n\tif (unlikely(ret)) {\n\t\tntfs_error(vol->sb, \"Failed to find last attribute extent of \"\n\t\t\t\t\"mft data attribute.\");\n\t\tif (ret == -ENOENT)\n\t\t\tret = -EIO;\n\t\tgoto undo_alloc;\n\t}\n\ta = ctx->attr;\n\tll = sle64_to_cpu(a->data.non_resident.lowest_vcn);\n\t \n\tfor (rl2 = rl; rl2 > mft_ni->runlist.rl; rl2--) {\n\t\tif (ll >= rl2->vcn)\n\t\t\tbreak;\n\t}\n\tBUG_ON(ll < rl2->vcn);\n\tBUG_ON(ll >= rl2->vcn + rl2->length);\n\t \n\tmp_size = ntfs_get_size_for_mapping_pairs(vol, rl2, ll, -1);\n\tif (unlikely(mp_size <= 0)) {\n\t\tntfs_error(vol->sb, \"Get size for mapping pairs failed for \"\n\t\t\t\t\"mft data attribute extent.\");\n\t\tret = mp_size;\n\t\tif (!ret)\n\t\t\tret = -EIO;\n\t\tgoto undo_alloc;\n\t}\n\t \n\told_alen = le32_to_cpu(a->length);\n\tret = ntfs_attr_record_resize(ctx->mrec, a, mp_size +\n\t\t\tle16_to_cpu(a->data.non_resident.mapping_pairs_offset));\n\tif (unlikely(ret)) {\n\t\tif (ret != -ENOSPC) {\n\t\t\tntfs_error(vol->sb, \"Failed to resize attribute \"\n\t\t\t\t\t\"record for mft data attribute.\");\n\t\t\tgoto undo_alloc;\n\t\t}\n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\tntfs_error(vol->sb, \"Not enough space in this mft record to \"\n\t\t\t\t\"accommodate extended mft data attribute \"\n\t\t\t\t\"extent.  Cannot handle this yet.\");\n\t\tret = -EOPNOTSUPP;\n\t\tgoto undo_alloc;\n\t}\n\tmp_rebuilt = true;\n\t \n\tret = ntfs_mapping_pairs_build(vol, (u8*)a +\n\t\t\tle16_to_cpu(a->data.non_resident.mapping_pairs_offset),\n\t\t\tmp_size, rl2, ll, -1, NULL);\n\tif (unlikely(ret)) {\n\t\tntfs_error(vol->sb, \"Failed to build mapping pairs array of \"\n\t\t\t\t\"mft data attribute.\");\n\t\tgoto undo_alloc;\n\t}\n\t \n\ta->data.non_resident.highest_vcn = cpu_to_sle64(rl[1].vcn - 1);\n\t \n\tif (a->data.non_resident.lowest_vcn) {\n\t\t \n\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\tret = ntfs_attr_lookup(mft_ni->type, mft_ni->name,\n\t\t\t\tmft_ni->name_len, CASE_SENSITIVE, 0, NULL, 0,\n\t\t\t\tctx);\n\t\tif (unlikely(ret)) {\n\t\t\tntfs_error(vol->sb, \"Failed to find first attribute \"\n\t\t\t\t\t\"extent of mft data attribute.\");\n\t\t\tgoto restore_undo_alloc;\n\t\t}\n\t\ta = ctx->attr;\n\t}\n\twrite_lock_irqsave(&mft_ni->size_lock, flags);\n\tmft_ni->allocated_size += nr << vol->cluster_size_bits;\n\ta->data.non_resident.allocated_size =\n\t\t\tcpu_to_sle64(mft_ni->allocated_size);\n\twrite_unlock_irqrestore(&mft_ni->size_lock, flags);\n\t \n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(mft_ni);\n\tup_write(&mft_ni->runlist.lock);\n\tntfs_debug(\"Done.\");\n\treturn 0;\nrestore_undo_alloc:\n\tntfs_attr_reinit_search_ctx(ctx);\n\tif (ntfs_attr_lookup(mft_ni->type, mft_ni->name, mft_ni->name_len,\n\t\t\tCASE_SENSITIVE, rl[1].vcn, NULL, 0, ctx)) {\n\t\tntfs_error(vol->sb, \"Failed to find last attribute extent of \"\n\t\t\t\t\"mft data attribute.%s\", es);\n\t\twrite_lock_irqsave(&mft_ni->size_lock, flags);\n\t\tmft_ni->allocated_size += nr << vol->cluster_size_bits;\n\t\twrite_unlock_irqrestore(&mft_ni->size_lock, flags);\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(mft_ni);\n\t\tup_write(&mft_ni->runlist.lock);\n\t\t \n\t\tNVolSetErrors(vol);\n\t\treturn ret;\n\t}\n\tctx->attr->data.non_resident.highest_vcn =\n\t\t\tcpu_to_sle64(old_last_vcn - 1);\nundo_alloc:\n\tif (ntfs_cluster_free(mft_ni, old_last_vcn, -1, ctx) < 0) {\n\t\tntfs_error(vol->sb, \"Failed to free clusters from mft data \"\n\t\t\t\t\"attribute.%s\", es);\n\t\tNVolSetErrors(vol);\n\t}\n\n\tif (ntfs_rl_truncate_nolock(vol, &mft_ni->runlist, old_last_vcn)) {\n\t\tntfs_error(vol->sb, \"Failed to truncate mft data attribute \"\n\t\t\t\t\"runlist.%s\", es);\n\t\tNVolSetErrors(vol);\n\t}\n\tif (ctx) {\n\t\ta = ctx->attr;\n\t\tif (mp_rebuilt && !IS_ERR(ctx->mrec)) {\n\t\t\tif (ntfs_mapping_pairs_build(vol, (u8 *)a + le16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset),\n\t\t\t\told_alen - le16_to_cpu(\n\t\t\t\t\ta->data.non_resident.mapping_pairs_offset),\n\t\t\t\trl2, ll, -1, NULL)) {\n\t\t\t\tntfs_error(vol->sb, \"Failed to restore mapping pairs \"\n\t\t\t\t\t\"array.%s\", es);\n\t\t\t\tNVolSetErrors(vol);\n\t\t\t}\n\t\t\tif (ntfs_attr_record_resize(ctx->mrec, a, old_alen)) {\n\t\t\t\tntfs_error(vol->sb, \"Failed to restore attribute \"\n\t\t\t\t\t\"record.%s\", es);\n\t\t\t\tNVolSetErrors(vol);\n\t\t\t}\n\t\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t\t} else if (IS_ERR(ctx->mrec)) {\n\t\t\tntfs_error(vol->sb, \"Failed to restore attribute search \"\n\t\t\t\t\"context.%s\", es);\n\t\t\tNVolSetErrors(vol);\n\t\t}\n\t\tntfs_attr_put_search_ctx(ctx);\n\t}\n\tif (!IS_ERR(mrec))\n\t\tunmap_mft_record(mft_ni);\n\tup_write(&mft_ni->runlist.lock);\n\treturn ret;\n}\n\n \nstatic int ntfs_mft_record_layout(const ntfs_volume *vol, const s64 mft_no,\n\t\tMFT_RECORD *m)\n{\n\tATTR_RECORD *a;\n\n\tntfs_debug(\"Entering for mft record 0x%llx.\", (long long)mft_no);\n\tif (mft_no >= (1ll << 32)) {\n\t\tntfs_error(vol->sb, \"Mft record number 0x%llx exceeds \"\n\t\t\t\t\"maximum of 2^32.\", (long long)mft_no);\n\t\treturn -ERANGE;\n\t}\n\t \n\tmemset(m, 0, vol->mft_record_size);\n\t \n\tif (vol->major_ver < 3 || (vol->major_ver == 3 && !vol->minor_ver))\n\t\tm->usa_ofs = cpu_to_le16((sizeof(MFT_RECORD_OLD) + 1) & ~1);\n\telse {\n\t\tm->usa_ofs = cpu_to_le16((sizeof(MFT_RECORD) + 1) & ~1);\n\t\t \n\t\tm->reserved = 0;\n\t\tm->mft_record_number = cpu_to_le32((u32)mft_no);\n\t}\n\tm->magic = magic_FILE;\n\tif (vol->mft_record_size >= NTFS_BLOCK_SIZE)\n\t\tm->usa_count = cpu_to_le16(vol->mft_record_size /\n\t\t\t\tNTFS_BLOCK_SIZE + 1);\n\telse {\n\t\tm->usa_count = cpu_to_le16(1);\n\t\tntfs_warning(vol->sb, \"Sector size is bigger than mft record \"\n\t\t\t\t\"size.  Setting usa_count to 1.  If chkdsk \"\n\t\t\t\t\"reports this as corruption, please email \"\n\t\t\t\t\"linux-ntfs-dev@lists.sourceforge.net stating \"\n\t\t\t\t\"that you saw this message and that the \"\n\t\t\t\t\"modified filesystem created was corrupt.  \"\n\t\t\t\t\"Thank you.\");\n\t}\n\t \n\t*(le16*)((u8*)m + le16_to_cpu(m->usa_ofs)) = cpu_to_le16(1);\n\tm->lsn = 0;\n\tm->sequence_number = cpu_to_le16(1);\n\tm->link_count = 0;\n\t \n\tm->attrs_offset = cpu_to_le16((le16_to_cpu(m->usa_ofs) +\n\t\t\t(le16_to_cpu(m->usa_count) << 1) + 7) & ~7);\n\tm->flags = 0;\n\t \n\tm->bytes_in_use = cpu_to_le32(le16_to_cpu(m->attrs_offset) + 8);\n\tm->bytes_allocated = cpu_to_le32(vol->mft_record_size);\n\tm->base_mft_record = 0;\n\tm->next_attr_instance = 0;\n\t \n\ta = (ATTR_RECORD*)((u8*)m + le16_to_cpu(m->attrs_offset));\n\ta->type = AT_END;\n\ta->length = 0;\n\tntfs_debug(\"Done.\");\n\treturn 0;\n}\n\n \nstatic int ntfs_mft_record_format(const ntfs_volume *vol, const s64 mft_no)\n{\n\tloff_t i_size;\n\tstruct inode *mft_vi = vol->mft_ino;\n\tstruct page *page;\n\tMFT_RECORD *m;\n\tpgoff_t index, end_index;\n\tunsigned int ofs;\n\tint err;\n\n\tntfs_debug(\"Entering for mft record 0x%llx.\", (long long)mft_no);\n\t \n\tindex = mft_no << vol->mft_record_size_bits >> PAGE_SHIFT;\n\tofs = (mft_no << vol->mft_record_size_bits) & ~PAGE_MASK;\n\t \n\ti_size = i_size_read(mft_vi);\n\tend_index = i_size >> PAGE_SHIFT;\n\tif (unlikely(index >= end_index)) {\n\t\tif (unlikely(index > end_index || ofs + vol->mft_record_size >=\n\t\t\t\t(i_size & ~PAGE_MASK))) {\n\t\t\tntfs_error(vol->sb, \"Tried to format non-existing mft \"\n\t\t\t\t\t\"record 0x%llx.\", (long long)mft_no);\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\t \n\tpage = ntfs_map_page(mft_vi->i_mapping, index);\n\tif (IS_ERR(page)) {\n\t\tntfs_error(vol->sb, \"Failed to map page containing mft record \"\n\t\t\t\t\"to format 0x%llx.\", (long long)mft_no);\n\t\treturn PTR_ERR(page);\n\t}\n\tlock_page(page);\n\tBUG_ON(!PageUptodate(page));\n\tClearPageUptodate(page);\n\tm = (MFT_RECORD*)((u8*)page_address(page) + ofs);\n\terr = ntfs_mft_record_layout(vol, mft_no, m);\n\tif (unlikely(err)) {\n\t\tntfs_error(vol->sb, \"Failed to layout mft record 0x%llx.\",\n\t\t\t\t(long long)mft_no);\n\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\tntfs_unmap_page(page);\n\t\treturn err;\n\t}\n\tflush_dcache_page(page);\n\tSetPageUptodate(page);\n\tunlock_page(page);\n\t \n\tmark_ntfs_record_dirty(page, ofs);\n\tntfs_unmap_page(page);\n\tntfs_debug(\"Done.\");\n\treturn 0;\n}\n\n \nntfs_inode *ntfs_mft_record_alloc(ntfs_volume *vol, const int mode,\n\t\tntfs_inode *base_ni, MFT_RECORD **mrec)\n{\n\ts64 ll, bit, old_data_initialized, old_data_size;\n\tunsigned long flags;\n\tstruct inode *vi;\n\tstruct page *page;\n\tntfs_inode *mft_ni, *mftbmp_ni, *ni;\n\tntfs_attr_search_ctx *ctx;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tpgoff_t index;\n\tunsigned int ofs;\n\tint err;\n\tle16 seq_no, usn;\n\tbool record_formatted = false;\n\n\tif (base_ni) {\n\t\tntfs_debug(\"Entering (allocating an extent mft record for \"\n\t\t\t\t\"base mft record 0x%llx).\",\n\t\t\t\t(long long)base_ni->mft_no);\n\t\t \n\t\tBUG_ON(mode);\n\t} else\n\t\tntfs_debug(\"Entering (allocating a base mft record).\");\n\tif (mode) {\n\t\t \n\t\tBUG_ON(base_ni);\n\t\t \n\t\tif (!S_ISREG(mode) && !S_ISDIR(mode))\n\t\t\treturn ERR_PTR(-EOPNOTSUPP);\n\t}\n\tBUG_ON(!mrec);\n\tmft_ni = NTFS_I(vol->mft_ino);\n\tmftbmp_ni = NTFS_I(vol->mftbmp_ino);\n\tdown_write(&vol->mftbmp_lock);\n\tbit = ntfs_mft_bitmap_find_and_alloc_free_rec_nolock(vol, base_ni);\n\tif (bit >= 0) {\n\t\tntfs_debug(\"Found and allocated free record (#1), bit 0x%llx.\",\n\t\t\t\t(long long)bit);\n\t\tgoto have_alloc_rec;\n\t}\n\tif (bit != -ENOSPC) {\n\t\tup_write(&vol->mftbmp_lock);\n\t\treturn ERR_PTR(bit);\n\t}\n\t \n\tread_lock_irqsave(&mft_ni->size_lock, flags);\n\tll = mft_ni->initialized_size >> vol->mft_record_size_bits;\n\tread_unlock_irqrestore(&mft_ni->size_lock, flags);\n\tread_lock_irqsave(&mftbmp_ni->size_lock, flags);\n\told_data_initialized = mftbmp_ni->initialized_size;\n\tread_unlock_irqrestore(&mftbmp_ni->size_lock, flags);\n\tif (old_data_initialized << 3 > ll && old_data_initialized > 3) {\n\t\tbit = ll;\n\t\tif (bit < 24)\n\t\t\tbit = 24;\n\t\tif (unlikely(bit >= (1ll << 32)))\n\t\t\tgoto max_err_out;\n\t\tntfs_debug(\"Found free record (#2), bit 0x%llx.\",\n\t\t\t\t(long long)bit);\n\t\tgoto found_free_rec;\n\t}\n\t \n\tbit = old_data_initialized << 3;\n\tif (unlikely(bit >= (1ll << 32)))\n\t\tgoto max_err_out;\n\tread_lock_irqsave(&mftbmp_ni->size_lock, flags);\n\told_data_size = mftbmp_ni->allocated_size;\n\tntfs_debug(\"Status of mftbmp before extension: allocated_size 0x%llx, \"\n\t\t\t\"data_size 0x%llx, initialized_size 0x%llx.\",\n\t\t\t(long long)old_data_size,\n\t\t\t(long long)i_size_read(vol->mftbmp_ino),\n\t\t\t(long long)old_data_initialized);\n\tread_unlock_irqrestore(&mftbmp_ni->size_lock, flags);\n\tif (old_data_initialized + 8 > old_data_size) {\n\t\t \n\t\tntfs_debug(\"mftbmp: initialized_size + 8 > allocated_size.\");\n\t\terr = ntfs_mft_bitmap_extend_allocation_nolock(vol);\n\t\tif (unlikely(err)) {\n\t\t\tup_write(&vol->mftbmp_lock);\n\t\t\tgoto err_out;\n\t\t}\n#ifdef DEBUG\n\t\tread_lock_irqsave(&mftbmp_ni->size_lock, flags);\n\t\tntfs_debug(\"Status of mftbmp after allocation extension: \"\n\t\t\t\t\"allocated_size 0x%llx, data_size 0x%llx, \"\n\t\t\t\t\"initialized_size 0x%llx.\",\n\t\t\t\t(long long)mftbmp_ni->allocated_size,\n\t\t\t\t(long long)i_size_read(vol->mftbmp_ino),\n\t\t\t\t(long long)mftbmp_ni->initialized_size);\n\t\tread_unlock_irqrestore(&mftbmp_ni->size_lock, flags);\n#endif  \n\t}\n\t \n\terr = ntfs_mft_bitmap_extend_initialized_nolock(vol);\n\tif (unlikely(err)) {\n\t\tup_write(&vol->mftbmp_lock);\n\t\tgoto err_out;\n\t}\n#ifdef DEBUG\n\tread_lock_irqsave(&mftbmp_ni->size_lock, flags);\n\tntfs_debug(\"Status of mftbmp after initialized extension: \"\n\t\t\t\"allocated_size 0x%llx, data_size 0x%llx, \"\n\t\t\t\"initialized_size 0x%llx.\",\n\t\t\t(long long)mftbmp_ni->allocated_size,\n\t\t\t(long long)i_size_read(vol->mftbmp_ino),\n\t\t\t(long long)mftbmp_ni->initialized_size);\n\tread_unlock_irqrestore(&mftbmp_ni->size_lock, flags);\n#endif  \n\tntfs_debug(\"Found free record (#3), bit 0x%llx.\", (long long)bit);\nfound_free_rec:\n\t \n\tntfs_debug(\"At found_free_rec.\");\n\terr = ntfs_bitmap_set_bit(vol->mftbmp_ino, bit);\n\tif (unlikely(err)) {\n\t\tntfs_error(vol->sb, \"Failed to allocate bit in mft bitmap.\");\n\t\tup_write(&vol->mftbmp_lock);\n\t\tgoto err_out;\n\t}\n\tntfs_debug(\"Set bit 0x%llx in mft bitmap.\", (long long)bit);\nhave_alloc_rec:\n\t \n\tll = (bit + 1) << vol->mft_record_size_bits;\n\tread_lock_irqsave(&mft_ni->size_lock, flags);\n\told_data_initialized = mft_ni->initialized_size;\n\tread_unlock_irqrestore(&mft_ni->size_lock, flags);\n\tif (ll <= old_data_initialized) {\n\t\tntfs_debug(\"Allocated mft record already initialized.\");\n\t\tgoto mft_rec_already_initialized;\n\t}\n\tntfs_debug(\"Initializing allocated mft record.\");\n\t \n\tread_lock_irqsave(&mft_ni->size_lock, flags);\n\tntfs_debug(\"Status of mft data before extension: \"\n\t\t\t\"allocated_size 0x%llx, data_size 0x%llx, \"\n\t\t\t\"initialized_size 0x%llx.\",\n\t\t\t(long long)mft_ni->allocated_size,\n\t\t\t(long long)i_size_read(vol->mft_ino),\n\t\t\t(long long)mft_ni->initialized_size);\n\twhile (ll > mft_ni->allocated_size) {\n\t\tread_unlock_irqrestore(&mft_ni->size_lock, flags);\n\t\terr = ntfs_mft_data_extend_allocation_nolock(vol);\n\t\tif (unlikely(err)) {\n\t\t\tntfs_error(vol->sb, \"Failed to extend mft data \"\n\t\t\t\t\t\"allocation.\");\n\t\t\tgoto undo_mftbmp_alloc_nolock;\n\t\t}\n\t\tread_lock_irqsave(&mft_ni->size_lock, flags);\n\t\tntfs_debug(\"Status of mft data after allocation extension: \"\n\t\t\t\t\"allocated_size 0x%llx, data_size 0x%llx, \"\n\t\t\t\t\"initialized_size 0x%llx.\",\n\t\t\t\t(long long)mft_ni->allocated_size,\n\t\t\t\t(long long)i_size_read(vol->mft_ino),\n\t\t\t\t(long long)mft_ni->initialized_size);\n\t}\n\tread_unlock_irqrestore(&mft_ni->size_lock, flags);\n\t \n\twrite_lock_irqsave(&mft_ni->size_lock, flags);\n\told_data_initialized = mft_ni->initialized_size;\n\told_data_size = vol->mft_ino->i_size;\n\twhile (ll > mft_ni->initialized_size) {\n\t\ts64 new_initialized_size, mft_no;\n\t\t\n\t\tnew_initialized_size = mft_ni->initialized_size +\n\t\t\t\tvol->mft_record_size;\n\t\tmft_no = mft_ni->initialized_size >> vol->mft_record_size_bits;\n\t\tif (new_initialized_size > i_size_read(vol->mft_ino))\n\t\t\ti_size_write(vol->mft_ino, new_initialized_size);\n\t\twrite_unlock_irqrestore(&mft_ni->size_lock, flags);\n\t\tntfs_debug(\"Initializing mft record 0x%llx.\",\n\t\t\t\t(long long)mft_no);\n\t\terr = ntfs_mft_record_format(vol, mft_no);\n\t\tif (unlikely(err)) {\n\t\t\tntfs_error(vol->sb, \"Failed to format mft record.\");\n\t\t\tgoto undo_data_init;\n\t\t}\n\t\twrite_lock_irqsave(&mft_ni->size_lock, flags);\n\t\tmft_ni->initialized_size = new_initialized_size;\n\t}\n\twrite_unlock_irqrestore(&mft_ni->size_lock, flags);\n\trecord_formatted = true;\n\t \n\tm = map_mft_record(mft_ni);\n\tif (IS_ERR(m)) {\n\t\tntfs_error(vol->sb, \"Failed to map mft record.\");\n\t\terr = PTR_ERR(m);\n\t\tgoto undo_data_init;\n\t}\n\tctx = ntfs_attr_get_search_ctx(mft_ni, m);\n\tif (unlikely(!ctx)) {\n\t\tntfs_error(vol->sb, \"Failed to get search context.\");\n\t\terr = -ENOMEM;\n\t\tunmap_mft_record(mft_ni);\n\t\tgoto undo_data_init;\n\t}\n\terr = ntfs_attr_lookup(mft_ni->type, mft_ni->name, mft_ni->name_len,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err)) {\n\t\tntfs_error(vol->sb, \"Failed to find first attribute extent of \"\n\t\t\t\t\"mft data attribute.\");\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(mft_ni);\n\t\tgoto undo_data_init;\n\t}\n\ta = ctx->attr;\n\tread_lock_irqsave(&mft_ni->size_lock, flags);\n\ta->data.non_resident.initialized_size =\n\t\t\tcpu_to_sle64(mft_ni->initialized_size);\n\ta->data.non_resident.data_size =\n\t\t\tcpu_to_sle64(i_size_read(vol->mft_ino));\n\tread_unlock_irqrestore(&mft_ni->size_lock, flags);\n\t \n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(mft_ni);\n\tread_lock_irqsave(&mft_ni->size_lock, flags);\n\tntfs_debug(\"Status of mft data after mft record initialization: \"\n\t\t\t\"allocated_size 0x%llx, data_size 0x%llx, \"\n\t\t\t\"initialized_size 0x%llx.\",\n\t\t\t(long long)mft_ni->allocated_size,\n\t\t\t(long long)i_size_read(vol->mft_ino),\n\t\t\t(long long)mft_ni->initialized_size);\n\tBUG_ON(i_size_read(vol->mft_ino) > mft_ni->allocated_size);\n\tBUG_ON(mft_ni->initialized_size > i_size_read(vol->mft_ino));\n\tread_unlock_irqrestore(&mft_ni->size_lock, flags);\nmft_rec_already_initialized:\n\t \n\tup_write(&vol->mftbmp_lock);\n\t \n\tindex = bit << vol->mft_record_size_bits >> PAGE_SHIFT;\n\tofs = (bit << vol->mft_record_size_bits) & ~PAGE_MASK;\n\t \n\tpage = ntfs_map_page(vol->mft_ino->i_mapping, index);\n\tif (IS_ERR(page)) {\n\t\tntfs_error(vol->sb, \"Failed to map page containing allocated \"\n\t\t\t\t\"mft record 0x%llx.\", (long long)bit);\n\t\terr = PTR_ERR(page);\n\t\tgoto undo_mftbmp_alloc;\n\t}\n\tlock_page(page);\n\tBUG_ON(!PageUptodate(page));\n\tClearPageUptodate(page);\n\tm = (MFT_RECORD*)((u8*)page_address(page) + ofs);\n\t \n\tif (!record_formatted) {\n\t\t \n\t\tif (ntfs_is_file_record(m->magic) &&\n\t\t\t\t(m->flags & MFT_RECORD_IN_USE)) {\n\t\t\tntfs_error(vol->sb, \"Mft record 0x%llx was marked \"\n\t\t\t\t\t\"free in mft bitmap but is marked \"\n\t\t\t\t\t\"used itself.  Corrupt filesystem.  \"\n\t\t\t\t\t\"Unmount and run chkdsk.\",\n\t\t\t\t\t(long long)bit);\n\t\t\terr = -EIO;\n\t\t\tSetPageUptodate(page);\n\t\t\tunlock_page(page);\n\t\t\tntfs_unmap_page(page);\n\t\t\tNVolSetErrors(vol);\n\t\t\tgoto undo_mftbmp_alloc;\n\t\t}\n\t\t \n\t\tseq_no = m->sequence_number;\n\t\tusn = *(le16*)((u8*)m + le16_to_cpu(m->usa_ofs));\n\t\terr = ntfs_mft_record_layout(vol, bit, m);\n\t\tif (unlikely(err)) {\n\t\t\tntfs_error(vol->sb, \"Failed to layout allocated mft \"\n\t\t\t\t\t\"record 0x%llx.\", (long long)bit);\n\t\t\tSetPageUptodate(page);\n\t\t\tunlock_page(page);\n\t\t\tntfs_unmap_page(page);\n\t\t\tgoto undo_mftbmp_alloc;\n\t\t}\n\t\tif (seq_no)\n\t\t\tm->sequence_number = seq_no;\n\t\tif (usn && le16_to_cpu(usn) != 0xffff)\n\t\t\t*(le16*)((u8*)m + le16_to_cpu(m->usa_ofs)) = usn;\n\t}\n\t \n\tm->flags |= MFT_RECORD_IN_USE;\n\tif (S_ISDIR(mode))\n\t\tm->flags |= MFT_RECORD_IS_DIRECTORY;\n\tflush_dcache_page(page);\n\tSetPageUptodate(page);\n\tif (base_ni) {\n\t\tMFT_RECORD *m_tmp;\n\n\t\t \n\t\tm->base_mft_record = MK_LE_MREF(base_ni->mft_no,\n\t\t\t\tbase_ni->seq_no);\n\t\t \n\t\tm_tmp = map_extent_mft_record(base_ni, bit, &ni);\n\t\tif (IS_ERR(m_tmp)) {\n\t\t\tntfs_error(vol->sb, \"Failed to map allocated extent \"\n\t\t\t\t\t\"mft record 0x%llx.\", (long long)bit);\n\t\t\terr = PTR_ERR(m_tmp);\n\t\t\t \n\t\t\tm->flags &= cpu_to_le16(\n\t\t\t\t\t~le16_to_cpu(MFT_RECORD_IN_USE));\n\t\t\tflush_dcache_page(page);\n\t\t\t \n\t\t\tmark_ntfs_record_dirty(page, ofs);\n\t\t\tunlock_page(page);\n\t\t\tntfs_unmap_page(page);\n\t\t\tgoto undo_mftbmp_alloc;\n\t\t}\n\t\tBUG_ON(m != m_tmp);\n\t\t \n\t\tmark_ntfs_record_dirty(page, ofs);\n\t\tunlock_page(page);\n\t\t \n\t\tntfs_unmap_page(page);\n\t} else {\n\t\t \n\t\tvi = new_inode(vol->sb);\n\t\tif (unlikely(!vi)) {\n\t\t\terr = -ENOMEM;\n\t\t\t \n\t\t\tm->flags &= cpu_to_le16(\n\t\t\t\t\t~le16_to_cpu(MFT_RECORD_IN_USE));\n\t\t\tflush_dcache_page(page);\n\t\t\t \n\t\t\tmark_ntfs_record_dirty(page, ofs);\n\t\t\tunlock_page(page);\n\t\t\tntfs_unmap_page(page);\n\t\t\tgoto undo_mftbmp_alloc;\n\t\t}\n\t\tvi->i_ino = bit;\n\n\t\t \n\t\tvi->i_uid = vol->uid;\n\t\tvi->i_gid = vol->gid;\n\n\t\t \n\t\tntfs_init_big_inode(vi);\n\t\tni = NTFS_I(vi);\n\t\t \n\t\tif (S_ISDIR(mode)) {\n\t\t\tvi->i_mode = S_IFDIR | S_IRWXUGO;\n\t\t\tvi->i_mode &= ~vol->dmask;\n\n\t\t\tNInoSetMstProtected(ni);\n\t\t\tni->type = AT_INDEX_ALLOCATION;\n\t\t\tni->name = I30;\n\t\t\tni->name_len = 4;\n\n\t\t\tni->itype.index.block_size = 4096;\n\t\t\tni->itype.index.block_size_bits = ntfs_ffs(4096) - 1;\n\t\t\tni->itype.index.collation_rule = COLLATION_FILE_NAME;\n\t\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\t\tni->itype.index.vcn_size_bits =\n\t\t\t\t\t\tvol->cluster_size_bits;\n\t\t\t} else {\n\t\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\t\tni->itype.index.vcn_size_bits =\n\t\t\t\t\t\tvol->sector_size_bits;\n\t\t\t}\n\t\t} else {\n\t\t\tvi->i_mode = S_IFREG | S_IRWXUGO;\n\t\t\tvi->i_mode &= ~vol->fmask;\n\n\t\t\tni->type = AT_DATA;\n\t\t\tni->name = NULL;\n\t\t\tni->name_len = 0;\n\t\t}\n\t\tif (IS_RDONLY(vi))\n\t\t\tvi->i_mode &= ~S_IWUGO;\n\n\t\t \n\t\tvi->i_atime = vi->i_mtime = inode_set_ctime_current(vi);\n\t\t \n\t\tvi->i_size = 0;\n\t\tvi->i_blocks = 0;\n\n\t\t \n\t\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\t\t \n\t\tatomic_inc(&ni->count);\n\t\tmutex_lock(&ni->mrec_lock);\n\t\tni->page = page;\n\t\tni->page_ofs = ofs;\n\t\t \n\t\tmark_ntfs_record_dirty(page, ofs);\n\t\tunlock_page(page);\n\n\t\t \n\t\tinsert_inode_hash(vi);\n\n\t\t \n\t\tvol->mft_data_pos = bit + 1;\n\t}\n\t \n\tntfs_debug(\"Returning opened, allocated %sinode 0x%llx.\",\n\t\t\tbase_ni ? \"extent \" : \"\", (long long)bit);\n\t*mrec = m;\n\treturn ni;\nundo_data_init:\n\twrite_lock_irqsave(&mft_ni->size_lock, flags);\n\tmft_ni->initialized_size = old_data_initialized;\n\ti_size_write(vol->mft_ino, old_data_size);\n\twrite_unlock_irqrestore(&mft_ni->size_lock, flags);\n\tgoto undo_mftbmp_alloc_nolock;\nundo_mftbmp_alloc:\n\tdown_write(&vol->mftbmp_lock);\nundo_mftbmp_alloc_nolock:\n\tif (ntfs_bitmap_clear_bit(vol->mftbmp_ino, bit)) {\n\t\tntfs_error(vol->sb, \"Failed to clear bit in mft bitmap.%s\", es);\n\t\tNVolSetErrors(vol);\n\t}\n\tup_write(&vol->mftbmp_lock);\nerr_out:\n\treturn ERR_PTR(err);\nmax_err_out:\n\tntfs_warning(vol->sb, \"Cannot allocate mft record because the maximum \"\n\t\t\t\"number of inodes (2^32) has already been reached.\");\n\tup_write(&vol->mftbmp_lock);\n\treturn ERR_PTR(-ENOSPC);\n}\n\n \nint ntfs_extent_mft_record_free(ntfs_inode *ni, MFT_RECORD *m)\n{\n\tunsigned long mft_no = ni->mft_no;\n\tntfs_volume *vol = ni->vol;\n\tntfs_inode *base_ni;\n\tntfs_inode **extent_nis;\n\tint i, err;\n\tle16 old_seq_no;\n\tu16 seq_no;\n\t\n\tBUG_ON(NInoAttr(ni));\n\tBUG_ON(ni->nr_extents != -1);\n\n\tmutex_lock(&ni->extent_lock);\n\tbase_ni = ni->ext.base_ntfs_ino;\n\tmutex_unlock(&ni->extent_lock);\n\n\tBUG_ON(base_ni->nr_extents <= 0);\n\n\tntfs_debug(\"Entering for extent inode 0x%lx, base inode 0x%lx.\\n\",\n\t\t\tmft_no, base_ni->mft_no);\n\n\tmutex_lock(&base_ni->extent_lock);\n\n\t \n\tif (atomic_read(&ni->count) > 2) {\n\t\tntfs_error(vol->sb, \"Tried to free busy extent inode 0x%lx, \"\n\t\t\t\t\"not freeing.\", base_ni->mft_no);\n\t\tmutex_unlock(&base_ni->extent_lock);\n\t\treturn -EBUSY;\n\t}\n\n\t \n\textent_nis = base_ni->ext.extent_ntfs_inos;\n\terr = -ENOENT;\n\tfor (i = 0; i < base_ni->nr_extents; i++) {\n\t\tif (ni != extent_nis[i])\n\t\t\tcontinue;\n\t\textent_nis += i;\n\t\tbase_ni->nr_extents--;\n\t\tmemmove(extent_nis, extent_nis + 1, (base_ni->nr_extents - i) *\n\t\t\t\tsizeof(ntfs_inode*));\n\t\terr = 0;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&base_ni->extent_lock);\n\n\tif (unlikely(err)) {\n\t\tntfs_error(vol->sb, \"Extent inode 0x%lx is not attached to \"\n\t\t\t\t\"its base inode 0x%lx.\", mft_no,\n\t\t\t\tbase_ni->mft_no);\n\t\tBUG();\n\t}\n\n\t \n\n\t \n\tm->flags &= ~MFT_RECORD_IN_USE;\n\n\t \n\told_seq_no = m->sequence_number;\n\tseq_no = le16_to_cpu(old_seq_no);\n\tif (seq_no == 0xffff)\n\t\tseq_no = 1;\n\telse if (seq_no)\n\t\tseq_no++;\n\tm->sequence_number = cpu_to_le16(seq_no);\n\n\t \n\tNInoSetDirty(ni);\n\terr = write_mft_record(ni, m, 0);\n\tif (unlikely(err)) {\n\t\tntfs_error(vol->sb, \"Failed to write mft record 0x%lx, not \"\n\t\t\t\t\"freeing.\", mft_no);\n\t\tgoto rollback;\n\t}\nrollback_error:\n\t \n\tunmap_extent_mft_record(ni);\n\tntfs_clear_extent_inode(ni);\n\n\t \n\tdown_write(&vol->mftbmp_lock);\n\terr = ntfs_bitmap_clear_bit(vol->mftbmp_ino, mft_no);\n\tup_write(&vol->mftbmp_lock);\n\tif (unlikely(err)) {\n\t\t \n\t\tntfs_error(vol->sb, \"Failed to clear bit in mft bitmap.%s\", es);\n\t\tNVolSetErrors(vol);\n\t}\n\treturn 0;\nrollback:\n\t \n\tmutex_lock(&base_ni->extent_lock);\n\textent_nis = base_ni->ext.extent_ntfs_inos;\n\tif (!(base_ni->nr_extents & 3)) {\n\t\tint new_size = (base_ni->nr_extents + 4) * sizeof(ntfs_inode*);\n\n\t\textent_nis = kmalloc(new_size, GFP_NOFS);\n\t\tif (unlikely(!extent_nis)) {\n\t\t\tntfs_error(vol->sb, \"Failed to allocate internal \"\n\t\t\t\t\t\"buffer during rollback.%s\", es);\n\t\t\tmutex_unlock(&base_ni->extent_lock);\n\t\t\tNVolSetErrors(vol);\n\t\t\tgoto rollback_error;\n\t\t}\n\t\tif (base_ni->nr_extents) {\n\t\t\tBUG_ON(!base_ni->ext.extent_ntfs_inos);\n\t\t\tmemcpy(extent_nis, base_ni->ext.extent_ntfs_inos,\n\t\t\t\t\tnew_size - 4 * sizeof(ntfs_inode*));\n\t\t\tkfree(base_ni->ext.extent_ntfs_inos);\n\t\t}\n\t\tbase_ni->ext.extent_ntfs_inos = extent_nis;\n\t}\n\tm->flags |= MFT_RECORD_IN_USE;\n\tm->sequence_number = old_seq_no;\n\textent_nis[base_ni->nr_extents++] = ni;\n\tmutex_unlock(&base_ni->extent_lock);\n\tmark_mft_record_dirty(ni);\n\treturn err;\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}