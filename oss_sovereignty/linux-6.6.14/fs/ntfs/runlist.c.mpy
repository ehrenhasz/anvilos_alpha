{
  "module_name": "runlist.c",
  "hash_id": "c2fb764df71b13a211b3490e9efaaaca2283537c85c1727fa40846d3758efa7b",
  "original_prompt": "Ingested from linux-6.6.14/fs/ntfs/runlist.c",
  "human_readable_source": "\n \n\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"endian.h\"\n#include \"malloc.h\"\n#include \"ntfs.h\"\n\n \nstatic inline void ntfs_rl_mm(runlist_element *base, int dst, int src,\n\t\tint size)\n{\n\tif (likely((dst != src) && (size > 0)))\n\t\tmemmove(base + dst, base + src, size * sizeof(*base));\n}\n\n \nstatic inline void ntfs_rl_mc(runlist_element *dstbase, int dst,\n\t\trunlist_element *srcbase, int src, int size)\n{\n\tif (likely(size > 0))\n\t\tmemcpy(dstbase + dst, srcbase + src, size * sizeof(*dstbase));\n}\n\n \nstatic inline runlist_element *ntfs_rl_realloc(runlist_element *rl,\n\t\tint old_size, int new_size)\n{\n\trunlist_element *new_rl;\n\n\told_size = PAGE_ALIGN(old_size * sizeof(*rl));\n\tnew_size = PAGE_ALIGN(new_size * sizeof(*rl));\n\tif (old_size == new_size)\n\t\treturn rl;\n\n\tnew_rl = ntfs_malloc_nofs(new_size);\n\tif (unlikely(!new_rl))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (likely(rl != NULL)) {\n\t\tif (unlikely(old_size > new_size))\n\t\t\told_size = new_size;\n\t\tmemcpy(new_rl, rl, old_size);\n\t\tntfs_free(rl);\n\t}\n\treturn new_rl;\n}\n\n \nstatic inline runlist_element *ntfs_rl_realloc_nofail(runlist_element *rl,\n\t\tint old_size, int new_size)\n{\n\trunlist_element *new_rl;\n\n\told_size = PAGE_ALIGN(old_size * sizeof(*rl));\n\tnew_size = PAGE_ALIGN(new_size * sizeof(*rl));\n\tif (old_size == new_size)\n\t\treturn rl;\n\n\tnew_rl = ntfs_malloc_nofs_nofail(new_size);\n\tBUG_ON(!new_rl);\n\n\tif (likely(rl != NULL)) {\n\t\tif (unlikely(old_size > new_size))\n\t\t\told_size = new_size;\n\t\tmemcpy(new_rl, rl, old_size);\n\t\tntfs_free(rl);\n\t}\n\treturn new_rl;\n}\n\n \nstatic inline bool ntfs_are_rl_mergeable(runlist_element *dst,\n\t\trunlist_element *src)\n{\n\tBUG_ON(!dst);\n\tBUG_ON(!src);\n\n\t \n\tif ((dst->lcn == LCN_RL_NOT_MAPPED) && (src->lcn == LCN_RL_NOT_MAPPED))\n\t\treturn true;\n\t \n\tif ((dst->vcn + dst->length) != src->vcn)\n\t\treturn false;\n\t \n\tif ((dst->lcn >= 0) && (src->lcn >= 0) &&\n\t\t\t((dst->lcn + dst->length) == src->lcn))\n\t\treturn true;\n\t \n\tif ((dst->lcn == LCN_HOLE) && (src->lcn == LCN_HOLE))\n\t\treturn true;\n\t \n\treturn false;\n}\n\n \nstatic inline void __ntfs_rl_merge(runlist_element *dst, runlist_element *src)\n{\n\tdst->length += src->length;\n}\n\n \nstatic inline runlist_element *ntfs_rl_append(runlist_element *dst,\n\t\tint dsize, runlist_element *src, int ssize, int loc)\n{\n\tbool right = false;\t \n\tint marker;\t\t \n\n\tBUG_ON(!dst);\n\tBUG_ON(!src);\n\n\t \n\tif ((loc + 1) < dsize)\n\t\tright = ntfs_are_rl_mergeable(src + ssize - 1, dst + loc + 1);\n\n\t \n\tdst = ntfs_rl_realloc(dst, dsize, dsize + ssize - right);\n\tif (IS_ERR(dst))\n\t\treturn dst;\n\t \n\n\t \n\tif (right)\n\t\t__ntfs_rl_merge(src + ssize - 1, dst + loc + 1);\n\n\t \n\tmarker = loc + ssize + 1;\n\n\t \n\tntfs_rl_mm(dst, marker, loc + 1 + right, dsize - (loc + 1 + right));\n\tntfs_rl_mc(dst, loc + 1, src, 0, ssize);\n\n\t \n\tdst[loc].length = dst[loc + 1].vcn - dst[loc].vcn;\n\n\t \n\tif (dst[marker].lcn == LCN_ENOENT)\n\t\tdst[marker].vcn = dst[marker - 1].vcn + dst[marker - 1].length;\n\n\treturn dst;\n}\n\n \nstatic inline runlist_element *ntfs_rl_insert(runlist_element *dst,\n\t\tint dsize, runlist_element *src, int ssize, int loc)\n{\n\tbool left = false;\t \n\tbool disc = false;\t \n\tint marker;\t\t \n\n\tBUG_ON(!dst);\n\tBUG_ON(!src);\n\n\t \n\tif (loc == 0)\n\t\tdisc = (src[0].vcn > 0);\n\telse {\n\t\ts64 merged_length;\n\n\t\tleft = ntfs_are_rl_mergeable(dst + loc - 1, src);\n\n\t\tmerged_length = dst[loc - 1].length;\n\t\tif (left)\n\t\t\tmerged_length += src->length;\n\n\t\tdisc = (src[0].vcn > dst[loc - 1].vcn + merged_length);\n\t}\n\t \n\tdst = ntfs_rl_realloc(dst, dsize, dsize + ssize - left + disc);\n\tif (IS_ERR(dst))\n\t\treturn dst;\n\t \n\tif (left)\n\t\t__ntfs_rl_merge(dst + loc - 1, src);\n\t \n\tmarker = loc + ssize - left + disc;\n\n\t \n\tntfs_rl_mm(dst, marker, loc, dsize - loc);\n\tntfs_rl_mc(dst, loc + disc, src, left, ssize - left);\n\n\t \n\tdst[marker].vcn = dst[marker - 1].vcn + dst[marker - 1].length;\n\t \n\tif (dst[marker].lcn == LCN_HOLE || dst[marker].lcn == LCN_RL_NOT_MAPPED)\n\t\tdst[marker].length = dst[marker + 1].vcn - dst[marker].vcn;\n\n\t \n\tif (disc) {\n\t\tif (loc > 0) {\n\t\t\tdst[loc].vcn = dst[loc - 1].vcn + dst[loc - 1].length;\n\t\t\tdst[loc].length = dst[loc + 1].vcn - dst[loc].vcn;\n\t\t} else {\n\t\t\tdst[loc].vcn = 0;\n\t\t\tdst[loc].length = dst[loc + 1].vcn;\n\t\t}\n\t\tdst[loc].lcn = LCN_RL_NOT_MAPPED;\n\t}\n\treturn dst;\n}\n\n \nstatic inline runlist_element *ntfs_rl_replace(runlist_element *dst,\n\t\tint dsize, runlist_element *src, int ssize, int loc)\n{\n\tsigned delta;\n\tbool left = false;\t \n\tbool right = false;\t \n\tint tail;\t\t \n\tint marker;\t\t \n\n\tBUG_ON(!dst);\n\tBUG_ON(!src);\n\n\t \n\tif ((loc + 1) < dsize)\n\t\tright = ntfs_are_rl_mergeable(src + ssize - 1, dst + loc + 1);\n\tif (loc > 0)\n\t\tleft = ntfs_are_rl_mergeable(dst + loc - 1, src);\n\t \n\tdelta = ssize - 1 - left - right;\n\tif (delta > 0) {\n\t\tdst = ntfs_rl_realloc(dst, dsize, dsize + delta);\n\t\tif (IS_ERR(dst))\n\t\t\treturn dst;\n\t}\n\t \n\n\t \n\tif (right)\n\t\t__ntfs_rl_merge(src + ssize - 1, dst + loc + 1);\n\tif (left)\n\t\t__ntfs_rl_merge(dst + loc - 1, src);\n\t \n\ttail = loc + right + 1;\n\t \n\tmarker = loc + ssize - left;\n\n\t \n\tntfs_rl_mm(dst, marker, tail, dsize - tail);\n\tntfs_rl_mc(dst, loc, src, left, ssize - left);\n\n\t \n\tif (dsize - tail > 0 && dst[marker].lcn == LCN_ENOENT)\n\t\tdst[marker].vcn = dst[marker - 1].vcn + dst[marker - 1].length;\n\treturn dst;\n}\n\n \nstatic inline runlist_element *ntfs_rl_split(runlist_element *dst, int dsize,\n\t\trunlist_element *src, int ssize, int loc)\n{\n\tBUG_ON(!dst);\n\tBUG_ON(!src);\n\n\t \n\tdst = ntfs_rl_realloc(dst, dsize, dsize + ssize + 1);\n\tif (IS_ERR(dst))\n\t\treturn dst;\n\t \n\n\t \n\tntfs_rl_mm(dst, loc + 1 + ssize, loc, dsize - loc);\n\tntfs_rl_mc(dst, loc + 1, src, 0, ssize);\n\n\t \n\tdst[loc].length\t\t= dst[loc+1].vcn       - dst[loc].vcn;\n\tdst[loc+ssize+1].vcn    = dst[loc+ssize].vcn   + dst[loc+ssize].length;\n\tdst[loc+ssize+1].length = dst[loc+ssize+2].vcn - dst[loc+ssize+1].vcn;\n\n\treturn dst;\n}\n\n \nrunlist_element *ntfs_runlists_merge(runlist_element *drl,\n\t\trunlist_element *srl)\n{\n\tint di, si;\t\t \n\tint sstart;\t\t \n\tint dins;\t\t \n\tint dend, send;\t\t \n\tint dfinal, sfinal;\t \n\tint marker = 0;\n\tVCN marker_vcn = 0;\n\n#ifdef DEBUG\n\tntfs_debug(\"dst:\");\n\tntfs_debug_dump_runlist(drl);\n\tntfs_debug(\"src:\");\n\tntfs_debug_dump_runlist(srl);\n#endif\n\n\t \n\tif (unlikely(!srl))\n\t\treturn drl;\n\tif (IS_ERR(srl) || IS_ERR(drl))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t \n\tif (unlikely(!drl)) {\n\t\tdrl = srl;\n\t\t \n\t\tif (unlikely(drl[0].vcn)) {\n\t\t\t \n\t\t\tfor (dend = 0; likely(drl[dend].length); dend++)\n\t\t\t\t;\n\t\t\tdend++;\n\t\t\tdrl = ntfs_rl_realloc(drl, dend, dend + 1);\n\t\t\tif (IS_ERR(drl))\n\t\t\t\treturn drl;\n\t\t\t \n\t\t\tntfs_rl_mm(drl, 1, 0, dend);\n\t\t\tdrl[0].vcn = 0;\n\t\t\tdrl[0].lcn = LCN_RL_NOT_MAPPED;\n\t\t\tdrl[0].length = drl[1].vcn;\n\t\t}\n\t\tgoto finished;\n\t}\n\n\tsi = di = 0;\n\n\t \n\twhile (srl[si].length && srl[si].lcn < LCN_HOLE)\n\t\tsi++;\n\n\t \n\tBUG_ON(!srl[si].length);\n\n\t \n\tsstart = si;\n\n\t \n\tfor (; drl[di].length; di++) {\n\t\tif (drl[di].vcn + drl[di].length > srl[sstart].vcn)\n\t\t\tbreak;\n\t}\n\tdins = di;\n\n\t \n\tif ((drl[di].vcn == srl[si].vcn) && (drl[di].lcn >= 0) &&\n\t\t\t(srl[si].lcn >= 0)) {\n\t\tntfs_error(NULL, \"Run lists overlap. Cannot merge!\");\n\t\treturn ERR_PTR(-ERANGE);\n\t}\n\n\t \n\tfor (send = si; srl[send].length; send++)\n\t\t;\n\tfor (dend = di; drl[dend].length; dend++)\n\t\t;\n\n\tif (srl[send].lcn == LCN_ENOENT)\n\t\tmarker_vcn = srl[marker = send].vcn;\n\n\t \n\tfor (sfinal = send; sfinal >= 0 && srl[sfinal].lcn < LCN_HOLE; sfinal--)\n\t\t;\n\tfor (dfinal = dend; dfinal >= 0 && drl[dfinal].lcn < LCN_HOLE; dfinal--)\n\t\t;\n\n\t{\n\tbool start;\n\tbool finish;\n\tint ds = dend + 1;\t\t \n\tint ss = sfinal - sstart + 1;\n\n\tstart  = ((drl[dins].lcn <  LCN_RL_NOT_MAPPED) ||     \n\t\t  (drl[dins].vcn == srl[sstart].vcn));\t      \n\tfinish = ((drl[dins].lcn >= LCN_RL_NOT_MAPPED) &&     \n\t\t ((drl[dins].vcn + drl[dins].length) <=       \n\t\t  (srl[send - 1].vcn + srl[send - 1].length)));\n\n\t \n\tif (finish && !drl[dins].length)\n\t\tss++;\n\tif (marker && (drl[dins].vcn + drl[dins].length > srl[send - 1].vcn))\n\t\tfinish = false;\n#if 0\n\tntfs_debug(\"dfinal = %i, dend = %i\", dfinal, dend);\n\tntfs_debug(\"sstart = %i, sfinal = %i, send = %i\", sstart, sfinal, send);\n\tntfs_debug(\"start = %i, finish = %i\", start, finish);\n\tntfs_debug(\"ds = %i, ss = %i, dins = %i\", ds, ss, dins);\n#endif\n\tif (start) {\n\t\tif (finish)\n\t\t\tdrl = ntfs_rl_replace(drl, ds, srl + sstart, ss, dins);\n\t\telse\n\t\t\tdrl = ntfs_rl_insert(drl, ds, srl + sstart, ss, dins);\n\t} else {\n\t\tif (finish)\n\t\t\tdrl = ntfs_rl_append(drl, ds, srl + sstart, ss, dins);\n\t\telse\n\t\t\tdrl = ntfs_rl_split(drl, ds, srl + sstart, ss, dins);\n\t}\n\tif (IS_ERR(drl)) {\n\t\tntfs_error(NULL, \"Merge failed.\");\n\t\treturn drl;\n\t}\n\tntfs_free(srl);\n\tif (marker) {\n\t\tntfs_debug(\"Triggering marker code.\");\n\t\tfor (ds = dend; drl[ds].length; ds++)\n\t\t\t;\n\t\t \n\t\tif (drl[ds].vcn <= marker_vcn) {\n\t\t\tint slots = 0;\n\n\t\t\tif (drl[ds].vcn == marker_vcn) {\n\t\t\t\tntfs_debug(\"Old marker = 0x%llx, replacing \"\n\t\t\t\t\t\t\"with LCN_ENOENT.\",\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\tdrl[ds].lcn);\n\t\t\t\tdrl[ds].lcn = LCN_ENOENT;\n\t\t\t\tgoto finished;\n\t\t\t}\n\t\t\t \n\t\t\tif (drl[ds].lcn == LCN_ENOENT) {\n\t\t\t\tds--;\n\t\t\t\tslots = 1;\n\t\t\t}\n\t\t\tif (drl[ds].lcn != LCN_RL_NOT_MAPPED) {\n\t\t\t\t \n\t\t\t\tif (!slots) {\n\t\t\t\t\tdrl = ntfs_rl_realloc_nofail(drl, ds,\n\t\t\t\t\t\t\tds + 2);\n\t\t\t\t\tslots = 2;\n\t\t\t\t}\n\t\t\t\tds++;\n\t\t\t\t \n\t\t\t\tif (slots != 1)\n\t\t\t\t\tdrl[ds].vcn = drl[ds - 1].vcn +\n\t\t\t\t\t\t\tdrl[ds - 1].length;\n\t\t\t\tdrl[ds].lcn = LCN_RL_NOT_MAPPED;\n\t\t\t\t \n\t\t\t\tslots--;\n\t\t\t}\n\t\t\tdrl[ds].length = marker_vcn - drl[ds].vcn;\n\t\t\t \n\t\t\tds++;\n\t\t\tif (!slots)\n\t\t\t\tdrl = ntfs_rl_realloc_nofail(drl, ds, ds + 1);\n\t\t\tdrl[ds].vcn = marker_vcn;\n\t\t\tdrl[ds].lcn = LCN_ENOENT;\n\t\t\tdrl[ds].length = (s64)0;\n\t\t}\n\t}\n\t}\n\nfinished:\n\t \n\tntfs_debug(\"Merged runlist:\");\n\tntfs_debug_dump_runlist(drl);\n\treturn drl;\n}\n\n \nrunlist_element *ntfs_mapping_pairs_decompress(const ntfs_volume *vol,\n\t\tconst ATTR_RECORD *attr, runlist_element *old_rl)\n{\n\tVCN vcn;\t\t \n\tLCN lcn;\t\t \n\ts64 deltaxcn;\t\t \n\trunlist_element *rl;\t \n\tu8 *buf;\t\t \n\tu8 *attr_end;\t\t \n\tint rlsize;\t\t \n\tu16 rlpos;\t\t \n\tu8 b;\t\t\t \n\n#ifdef DEBUG\n\t \n\tif (!attr || !attr->non_resident || sle64_to_cpu(\n\t\t\tattr->data.non_resident.lowest_vcn) < (VCN)0) {\n\t\tntfs_error(vol->sb, \"Invalid arguments.\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n#endif\n\t \n\tvcn = sle64_to_cpu(attr->data.non_resident.lowest_vcn);\n\tlcn = 0;\n\t \n\tbuf = (u8*)attr + le16_to_cpu(\n\t\t\tattr->data.non_resident.mapping_pairs_offset);\n\tattr_end = (u8*)attr + le32_to_cpu(attr->length);\n\tif (unlikely(buf < (u8*)attr || buf > attr_end)) {\n\t\tntfs_error(vol->sb, \"Corrupt attribute.\");\n\t\treturn ERR_PTR(-EIO);\n\t}\n\t \n\tif (!vcn && !*buf)\n\t\treturn old_rl;\n\t \n\trlpos = 0;\n\t \n\trl = ntfs_malloc_nofs(rlsize = PAGE_SIZE);\n\tif (unlikely(!rl))\n\t\treturn ERR_PTR(-ENOMEM);\n\t \n\tif (vcn) {\n\t\trl->vcn = 0;\n\t\trl->lcn = LCN_RL_NOT_MAPPED;\n\t\trl->length = vcn;\n\t\trlpos++;\n\t}\n\twhile (buf < attr_end && *buf) {\n\t\t \n\t\tif (((rlpos + 3) * sizeof(*old_rl)) > rlsize) {\n\t\t\trunlist_element *rl2;\n\n\t\t\trl2 = ntfs_malloc_nofs(rlsize + (int)PAGE_SIZE);\n\t\t\tif (unlikely(!rl2)) {\n\t\t\t\tntfs_free(rl);\n\t\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t\t}\n\t\t\tmemcpy(rl2, rl, rlsize);\n\t\t\tntfs_free(rl);\n\t\t\trl = rl2;\n\t\t\trlsize += PAGE_SIZE;\n\t\t}\n\t\t \n\t\trl[rlpos].vcn = vcn;\n\t\t \n\t\tb = *buf & 0xf;\n\t\tif (b) {\n\t\t\tif (unlikely(buf + b > attr_end))\n\t\t\t\tgoto io_error;\n\t\t\tfor (deltaxcn = (s8)buf[b--]; b; b--)\n\t\t\t\tdeltaxcn = (deltaxcn << 8) + buf[b];\n\t\t} else {  \n\t\t\tntfs_error(vol->sb, \"Missing length entry in mapping \"\n\t\t\t\t\t\"pairs array.\");\n\t\t\tdeltaxcn = (s64)-1;\n\t\t}\n\t\t \n\t\tif (unlikely(deltaxcn < 0)) {\n\t\t\tntfs_error(vol->sb, \"Invalid length in mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto err_out;\n\t\t}\n\t\t \n\t\trl[rlpos].length = deltaxcn;\n\t\t \n\t\tvcn += deltaxcn;\n\t\t \n\t\tif (!(*buf & 0xf0))\n\t\t\trl[rlpos].lcn = LCN_HOLE;\n\t\telse {\n\t\t\t \n\t\t\tu8 b2 = *buf & 0xf;\n\t\t\tb = b2 + ((*buf >> 4) & 0xf);\n\t\t\tif (buf + b > attr_end)\n\t\t\t\tgoto io_error;\n\t\t\tfor (deltaxcn = (s8)buf[b--]; b > b2; b--)\n\t\t\t\tdeltaxcn = (deltaxcn << 8) + buf[b];\n\t\t\t \n\t\t\tlcn += deltaxcn;\n#ifdef DEBUG\n\t\t\t \n\t\t\tif (vol->major_ver < 3) {\n\t\t\t\tif (unlikely(deltaxcn == (LCN)-1))\n\t\t\t\t\tntfs_error(vol->sb, \"lcn delta == -1\");\n\t\t\t\tif (unlikely(lcn == (LCN)-1))\n\t\t\t\t\tntfs_error(vol->sb, \"lcn == -1\");\n\t\t\t}\n#endif\n\t\t\t \n\t\t\tif (unlikely(lcn < (LCN)-1)) {\n\t\t\t\tntfs_error(vol->sb, \"Invalid LCN < -1 in \"\n\t\t\t\t\t\t\"mapping pairs array.\");\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\t \n\t\t\trl[rlpos].lcn = lcn;\n\t\t}\n\t\t \n\t\trlpos++;\n\t\t \n\t\tbuf += (*buf & 0xf) + ((*buf >> 4) & 0xf) + 1;\n\t}\n\tif (unlikely(buf >= attr_end))\n\t\tgoto io_error;\n\t \n\tdeltaxcn = sle64_to_cpu(attr->data.non_resident.highest_vcn);\n\tif (unlikely(deltaxcn && vcn - 1 != deltaxcn)) {\nmpa_err:\n\t\tntfs_error(vol->sb, \"Corrupt mapping pairs array in \"\n\t\t\t\t\"non-resident attribute.\");\n\t\tgoto err_out;\n\t}\n\t \n\tif (!attr->data.non_resident.lowest_vcn) {\n\t\tVCN max_cluster;\n\n\t\tmax_cluster = ((sle64_to_cpu(\n\t\t\t\tattr->data.non_resident.allocated_size) +\n\t\t\t\tvol->cluster_size - 1) >>\n\t\t\t\tvol->cluster_size_bits) - 1;\n\t\t \n\t\tif (deltaxcn) {\n\t\t\t \n\t\t\tif (deltaxcn < max_cluster) {\n\t\t\t\tntfs_debug(\"More extents to follow; deltaxcn \"\n\t\t\t\t\t\t\"= 0x%llx, max_cluster = \"\n\t\t\t\t\t\t\"0x%llx\",\n\t\t\t\t\t\t(unsigned long long)deltaxcn,\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\tmax_cluster);\n\t\t\t\trl[rlpos].vcn = vcn;\n\t\t\t\tvcn += rl[rlpos].length = max_cluster -\n\t\t\t\t\t\tdeltaxcn;\n\t\t\t\trl[rlpos].lcn = LCN_RL_NOT_MAPPED;\n\t\t\t\trlpos++;\n\t\t\t} else if (unlikely(deltaxcn > max_cluster)) {\n\t\t\t\tntfs_error(vol->sb, \"Corrupt attribute.  \"\n\t\t\t\t\t\t\"deltaxcn = 0x%llx, \"\n\t\t\t\t\t\t\"max_cluster = 0x%llx\",\n\t\t\t\t\t\t(unsigned long long)deltaxcn,\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\tmax_cluster);\n\t\t\t\tgoto mpa_err;\n\t\t\t}\n\t\t}\n\t\trl[rlpos].lcn = LCN_ENOENT;\n\t} else  \n\t\trl[rlpos].lcn = LCN_RL_NOT_MAPPED;\n\n\t \n\trl[rlpos].vcn = vcn;\n\trl[rlpos].length = (s64)0;\n\t \n\tif (!old_rl) {\n\t\tntfs_debug(\"Mapping pairs array successfully decompressed:\");\n\t\tntfs_debug_dump_runlist(rl);\n\t\treturn rl;\n\t}\n\t \n\told_rl = ntfs_runlists_merge(old_rl, rl);\n\tif (!IS_ERR(old_rl))\n\t\treturn old_rl;\n\tntfs_free(rl);\n\tntfs_error(vol->sb, \"Failed to merge runlists.\");\n\treturn old_rl;\nio_error:\n\tntfs_error(vol->sb, \"Corrupt attribute.\");\nerr_out:\n\tntfs_free(rl);\n\treturn ERR_PTR(-EIO);\n}\n\n \nLCN ntfs_rl_vcn_to_lcn(const runlist_element *rl, const VCN vcn)\n{\n\tint i;\n\n\tBUG_ON(vcn < 0);\n\t \n\tif (unlikely(!rl))\n\t\treturn LCN_RL_NOT_MAPPED;\n\n\t \n\tif (unlikely(vcn < rl[0].vcn))\n\t\treturn LCN_ENOENT;\n\n\tfor (i = 0; likely(rl[i].length); i++) {\n\t\tif (unlikely(vcn < rl[i+1].vcn)) {\n\t\t\tif (likely(rl[i].lcn >= (LCN)0))\n\t\t\t\treturn rl[i].lcn + (vcn - rl[i].vcn);\n\t\t\treturn rl[i].lcn;\n\t\t}\n\t}\n\t \n\tif (likely(rl[i].lcn < (LCN)0))\n\t\treturn rl[i].lcn;\n\t \n\treturn LCN_ENOENT;\n}\n\n#ifdef NTFS_RW\n\n \nrunlist_element *ntfs_rl_find_vcn_nolock(runlist_element *rl, const VCN vcn)\n{\n\tBUG_ON(vcn < 0);\n\tif (unlikely(!rl || vcn < rl[0].vcn))\n\t\treturn NULL;\n\twhile (likely(rl->length)) {\n\t\tif (unlikely(vcn < rl[1].vcn)) {\n\t\t\tif (likely(rl->lcn >= LCN_HOLE))\n\t\t\t\treturn rl;\n\t\t\treturn NULL;\n\t\t}\n\t\trl++;\n\t}\n\tif (likely(rl->lcn == LCN_ENOENT))\n\t\treturn rl;\n\treturn NULL;\n}\n\n \nstatic inline int ntfs_get_nr_significant_bytes(const s64 n)\n{\n\ts64 l = n;\n\tint i;\n\ts8 j;\n\n\ti = 0;\n\tdo {\n\t\tl >>= 8;\n\t\ti++;\n\t} while (l != 0 && l != -1);\n\tj = (n >> 8 * (i - 1)) & 0xff;\n\t \n\tif ((n < 0 && j >= 0) || (n > 0 && j < 0))\n\t\ti++;\n\treturn i;\n}\n\n \nint ntfs_get_size_for_mapping_pairs(const ntfs_volume *vol,\n\t\tconst runlist_element *rl, const VCN first_vcn,\n\t\tconst VCN last_vcn)\n{\n\tLCN prev_lcn;\n\tint rls;\n\tbool the_end = false;\n\n\tBUG_ON(first_vcn < 0);\n\tBUG_ON(last_vcn < -1);\n\tBUG_ON(last_vcn >= 0 && first_vcn > last_vcn);\n\tif (!rl) {\n\t\tBUG_ON(first_vcn);\n\t\tBUG_ON(last_vcn > 0);\n\t\treturn 1;\n\t}\n\t \n\twhile (rl->length && first_vcn >= rl[1].vcn)\n\t\trl++;\n\tif (unlikely((!rl->length && first_vcn > rl->vcn) ||\n\t\t\tfirst_vcn < rl->vcn))\n\t\treturn -EINVAL;\n\tprev_lcn = 0;\n\t \n\trls = 1;\n\t \n\tif (first_vcn > rl->vcn) {\n\t\ts64 delta, length = rl->length;\n\n\t\t \n\t\tif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\n\t\t\tgoto err_out;\n\t\t \n\t\tif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\n\t\t\ts64 s1 = last_vcn + 1;\n\t\t\tif (unlikely(rl[1].vcn > s1))\n\t\t\t\tlength = s1 - rl->vcn;\n\t\t\tthe_end = true;\n\t\t}\n\t\tdelta = first_vcn - rl->vcn;\n\t\t \n\t\trls += 1 + ntfs_get_nr_significant_bytes(length - delta);\n\t\t \n\t\tif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\n\t\t\tprev_lcn = rl->lcn;\n\t\t\tif (likely(rl->lcn >= 0))\n\t\t\t\tprev_lcn += delta;\n\t\t\t \n\t\t\trls += ntfs_get_nr_significant_bytes(prev_lcn);\n\t\t}\n\t\t \n\t\trl++;\n\t}\n\t \n\tfor (; rl->length && !the_end; rl++) {\n\t\ts64 length = rl->length;\n\n\t\tif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\n\t\t\tgoto err_out;\n\t\t \n\t\tif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\n\t\t\ts64 s1 = last_vcn + 1;\n\t\t\tif (unlikely(rl[1].vcn > s1))\n\t\t\t\tlength = s1 - rl->vcn;\n\t\t\tthe_end = true;\n\t\t}\n\t\t \n\t\trls += 1 + ntfs_get_nr_significant_bytes(length);\n\t\t \n\t\tif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\n\t\t\t \n\t\t\trls += ntfs_get_nr_significant_bytes(rl->lcn -\n\t\t\t\t\tprev_lcn);\n\t\t\tprev_lcn = rl->lcn;\n\t\t}\n\t}\n\treturn rls;\nerr_out:\n\tif (rl->lcn == LCN_RL_NOT_MAPPED)\n\t\trls = -EINVAL;\n\telse\n\t\trls = -EIO;\n\treturn rls;\n}\n\n \nstatic inline int ntfs_write_significant_bytes(s8 *dst, const s8 *dst_max,\n\t\tconst s64 n)\n{\n\ts64 l = n;\n\tint i;\n\ts8 j;\n\n\ti = 0;\n\tdo {\n\t\tif (unlikely(dst > dst_max))\n\t\t\tgoto err_out;\n\t\t*dst++ = l & 0xffll;\n\t\tl >>= 8;\n\t\ti++;\n\t} while (l != 0 && l != -1);\n\tj = (n >> 8 * (i - 1)) & 0xff;\n\t \n\tif (n < 0 && j >= 0) {\n\t\tif (unlikely(dst > dst_max))\n\t\t\tgoto err_out;\n\t\ti++;\n\t\t*dst = (s8)-1;\n\t} else if (n > 0 && j < 0) {\n\t\tif (unlikely(dst > dst_max))\n\t\t\tgoto err_out;\n\t\ti++;\n\t\t*dst = (s8)0;\n\t}\n\treturn i;\nerr_out:\n\treturn -ENOSPC;\n}\n\n \nint ntfs_mapping_pairs_build(const ntfs_volume *vol, s8 *dst,\n\t\tconst int dst_len, const runlist_element *rl,\n\t\tconst VCN first_vcn, const VCN last_vcn, VCN *const stop_vcn)\n{\n\tLCN prev_lcn;\n\ts8 *dst_max, *dst_next;\n\tint err = -ENOSPC;\n\tbool the_end = false;\n\ts8 len_len, lcn_len;\n\n\tBUG_ON(first_vcn < 0);\n\tBUG_ON(last_vcn < -1);\n\tBUG_ON(last_vcn >= 0 && first_vcn > last_vcn);\n\tBUG_ON(dst_len < 1);\n\tif (!rl) {\n\t\tBUG_ON(first_vcn);\n\t\tBUG_ON(last_vcn > 0);\n\t\tif (stop_vcn)\n\t\t\t*stop_vcn = 0;\n\t\t \n\t\t*dst = 0;\n\t\treturn 0;\n\t}\n\t \n\twhile (rl->length && first_vcn >= rl[1].vcn)\n\t\trl++;\n\tif (unlikely((!rl->length && first_vcn > rl->vcn) ||\n\t\t\tfirst_vcn < rl->vcn))\n\t\treturn -EINVAL;\n\t \n\tdst_max = dst + dst_len - 1;\n\tprev_lcn = 0;\n\t \n\tif (first_vcn > rl->vcn) {\n\t\ts64 delta, length = rl->length;\n\n\t\t \n\t\tif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\n\t\t\tgoto err_out;\n\t\t \n\t\tif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\n\t\t\ts64 s1 = last_vcn + 1;\n\t\t\tif (unlikely(rl[1].vcn > s1))\n\t\t\t\tlength = s1 - rl->vcn;\n\t\t\tthe_end = true;\n\t\t}\n\t\tdelta = first_vcn - rl->vcn;\n\t\t \n\t\tlen_len = ntfs_write_significant_bytes(dst + 1, dst_max,\n\t\t\t\tlength - delta);\n\t\tif (unlikely(len_len < 0))\n\t\t\tgoto size_err;\n\t\t \n\t\tif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\n\t\t\tprev_lcn = rl->lcn;\n\t\t\tif (likely(rl->lcn >= 0))\n\t\t\t\tprev_lcn += delta;\n\t\t\t \n\t\t\tlcn_len = ntfs_write_significant_bytes(dst + 1 +\n\t\t\t\t\tlen_len, dst_max, prev_lcn);\n\t\t\tif (unlikely(lcn_len < 0))\n\t\t\t\tgoto size_err;\n\t\t} else\n\t\t\tlcn_len = 0;\n\t\tdst_next = dst + len_len + lcn_len + 1;\n\t\tif (unlikely(dst_next > dst_max))\n\t\t\tgoto size_err;\n\t\t \n\t\t*dst = lcn_len << 4 | len_len;\n\t\t \n\t\tdst = dst_next;\n\t\t \n\t\trl++;\n\t}\n\t \n\tfor (; rl->length && !the_end; rl++) {\n\t\ts64 length = rl->length;\n\n\t\tif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\n\t\t\tgoto err_out;\n\t\t \n\t\tif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\n\t\t\ts64 s1 = last_vcn + 1;\n\t\t\tif (unlikely(rl[1].vcn > s1))\n\t\t\t\tlength = s1 - rl->vcn;\n\t\t\tthe_end = true;\n\t\t}\n\t\t \n\t\tlen_len = ntfs_write_significant_bytes(dst + 1, dst_max,\n\t\t\t\tlength);\n\t\tif (unlikely(len_len < 0))\n\t\t\tgoto size_err;\n\t\t \n\t\tif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\n\t\t\t \n\t\t\tlcn_len = ntfs_write_significant_bytes(dst + 1 +\n\t\t\t\t\tlen_len, dst_max, rl->lcn - prev_lcn);\n\t\t\tif (unlikely(lcn_len < 0))\n\t\t\t\tgoto size_err;\n\t\t\tprev_lcn = rl->lcn;\n\t\t} else\n\t\t\tlcn_len = 0;\n\t\tdst_next = dst + len_len + lcn_len + 1;\n\t\tif (unlikely(dst_next > dst_max))\n\t\t\tgoto size_err;\n\t\t \n\t\t*dst = lcn_len << 4 | len_len;\n\t\t \n\t\tdst = dst_next;\n\t}\n\t \n\terr = 0;\nsize_err:\n\t \n\tif (stop_vcn)\n\t\t*stop_vcn = rl->vcn;\n\t \n\t*dst = 0;\n\treturn err;\nerr_out:\n\tif (rl->lcn == LCN_RL_NOT_MAPPED)\n\t\terr = -EINVAL;\n\telse\n\t\terr = -EIO;\n\treturn err;\n}\n\n \nint ntfs_rl_truncate_nolock(const ntfs_volume *vol, runlist *const runlist,\n\t\tconst s64 new_length)\n{\n\trunlist_element *rl;\n\tint old_size;\n\n\tntfs_debug(\"Entering for new_length 0x%llx.\", (long long)new_length);\n\tBUG_ON(!runlist);\n\tBUG_ON(new_length < 0);\n\trl = runlist->rl;\n\tif (!new_length) {\n\t\tntfs_debug(\"Freeing runlist.\");\n\t\trunlist->rl = NULL;\n\t\tif (rl)\n\t\t\tntfs_free(rl);\n\t\treturn 0;\n\t}\n\tif (unlikely(!rl)) {\n\t\t \n\t\trl = ntfs_malloc_nofs(PAGE_SIZE);\n\t\tif (unlikely(!rl)) {\n\t\t\tntfs_error(vol->sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"runlist element buffer.\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\trunlist->rl = rl;\n\t\trl[1].length = rl->vcn = 0;\n\t\trl->lcn = LCN_HOLE;\n\t\trl[1].vcn = rl->length = new_length;\n\t\trl[1].lcn = LCN_ENOENT;\n\t\treturn 0;\n\t}\n\tBUG_ON(new_length < rl->vcn);\n\t \n\twhile (likely(rl->length && new_length >= rl[1].vcn))\n\t\trl++;\n\t \n\tif (rl->length) {\n\t\trunlist_element *trl;\n\t\tbool is_end;\n\n\t\tntfs_debug(\"Shrinking runlist.\");\n\t\t \n\t\ttrl = rl + 1;\n\t\twhile (likely(trl->length))\n\t\t\ttrl++;\n\t\told_size = trl - runlist->rl + 1;\n\t\t \n\t\trl->length = new_length - rl->vcn;\n\t\t \n\t\tis_end = false;\n\t\tif (rl->length) {\n\t\t\trl++;\n\t\t\tif (!rl->length)\n\t\t\t\tis_end = true;\n\t\t\trl->vcn = new_length;\n\t\t\trl->length = 0;\n\t\t}\n\t\trl->lcn = LCN_ENOENT;\n\t\t \n\t\tif (!is_end) {\n\t\t\tint new_size = rl - runlist->rl + 1;\n\t\t\trl = ntfs_rl_realloc(runlist->rl, old_size, new_size);\n\t\t\tif (IS_ERR(rl))\n\t\t\t\tntfs_warning(vol->sb, \"Failed to shrink \"\n\t\t\t\t\t\t\"runlist buffer.  This just \"\n\t\t\t\t\t\t\"wastes a bit of memory \"\n\t\t\t\t\t\t\"temporarily so we ignore it \"\n\t\t\t\t\t\t\"and return success.\");\n\t\t\telse\n\t\t\t\trunlist->rl = rl;\n\t\t}\n\t} else if (likely(  new_length > rl->vcn)) {\n\t\tntfs_debug(\"Expanding runlist.\");\n\t\t \n\t\tif ((rl > runlist->rl) && ((rl - 1)->lcn == LCN_HOLE))\n\t\t\t(rl - 1)->length = new_length - (rl - 1)->vcn;\n\t\telse {\n\t\t\t \n\t\t\told_size = rl - runlist->rl + 1;\n\t\t\t \n\t\t\trl = ntfs_rl_realloc(runlist->rl, old_size,\n\t\t\t\t\told_size + 1);\n\t\t\tif (IS_ERR(rl)) {\n\t\t\t\tntfs_error(vol->sb, \"Failed to expand runlist \"\n\t\t\t\t\t\t\"buffer, aborting.\");\n\t\t\t\treturn PTR_ERR(rl);\n\t\t\t}\n\t\t\trunlist->rl = rl;\n\t\t\t \n\t\t\trl += old_size - 1;\n\t\t\t \n\t\t\trl->lcn = LCN_HOLE;\n\t\t\trl->length = new_length - rl->vcn;\n\t\t\t \n\t\t\trl++;\n\t\t\trl->length = 0;\n\t\t}\n\t\trl->vcn = new_length;\n\t\trl->lcn = LCN_ENOENT;\n\t} else   {\n\t\t \n\t\trl->lcn = LCN_ENOENT;\n\t}\n\tntfs_debug(\"Done.\");\n\treturn 0;\n}\n\n \nint ntfs_rl_punch_nolock(const ntfs_volume *vol, runlist *const runlist,\n\t\tconst VCN start, const s64 length)\n{\n\tconst VCN end = start + length;\n\ts64 delta;\n\trunlist_element *rl, *rl_end, *rl_real_end, *trl;\n\tint old_size;\n\tbool lcn_fixup = false;\n\n\tntfs_debug(\"Entering for start 0x%llx, length 0x%llx.\",\n\t\t\t(long long)start, (long long)length);\n\tBUG_ON(!runlist);\n\tBUG_ON(start < 0);\n\tBUG_ON(length < 0);\n\tBUG_ON(end < 0);\n\trl = runlist->rl;\n\tif (unlikely(!rl)) {\n\t\tif (likely(!start && !length))\n\t\t\treturn 0;\n\t\treturn -ENOENT;\n\t}\n\t \n\twhile (likely(rl->length && start >= rl[1].vcn))\n\t\trl++;\n\trl_end = rl;\n\t \n\twhile (likely(rl_end->length && end >= rl_end[1].vcn)) {\n\t\t \n\t\tif (unlikely(rl_end->lcn < LCN_HOLE))\n\t\t\treturn -EINVAL;\n\t\trl_end++;\n\t}\n\t \n\tif (unlikely(rl_end->length && rl_end->lcn < LCN_HOLE))\n\t\treturn -EINVAL;\n\t \n\tif (!rl_end->length && end > rl_end->vcn)\n\t\treturn -ENOENT;\n\tif (!length)\n\t\treturn 0;\n\tif (!rl->length)\n\t\treturn -ENOENT;\n\trl_real_end = rl_end;\n\t \n\twhile (likely(rl_real_end->length))\n\t\trl_real_end++;\n\told_size = rl_real_end - runlist->rl + 1;\n\t \n\tif (rl->lcn == LCN_HOLE) {\n\t\t \n\t\tif (end <= rl[1].vcn) {\n\t\t\tntfs_debug(\"Done (requested hole is already sparse).\");\n\t\t\treturn 0;\n\t\t}\nextend_hole:\n\t\t \n\t\trl->length = end - rl->vcn;\n\t\t \n\t\tif (rl_end->lcn == LCN_HOLE) {\n\t\t\trl_end++;\n\t\t\trl->length = rl_end->vcn - rl->vcn;\n\t\t}\n\t\t \n\t\trl++;\n\t\t \n\t\tif (rl < rl_end)\n\t\t\tmemmove(rl, rl_end, (rl_real_end - rl_end + 1) *\n\t\t\t\t\tsizeof(*rl));\n\t\t \n\t\tif (end > rl->vcn) {\n\t\t\tdelta = end - rl->vcn;\n\t\t\trl->vcn = end;\n\t\t\trl->length -= delta;\n\t\t\t \n\t\t\tif (rl->lcn >= 0)\n\t\t\t\trl->lcn += delta;\n\t\t}\nshrink_allocation:\n\t\t \n\t\tif (rl < rl_end) {\n\t\t\trl = ntfs_rl_realloc(runlist->rl, old_size,\n\t\t\t\t\told_size - (rl_end - rl));\n\t\t\tif (IS_ERR(rl))\n\t\t\t\tntfs_warning(vol->sb, \"Failed to shrink \"\n\t\t\t\t\t\t\"runlist buffer.  This just \"\n\t\t\t\t\t\t\"wastes a bit of memory \"\n\t\t\t\t\t\t\"temporarily so we ignore it \"\n\t\t\t\t\t\t\"and return success.\");\n\t\t\telse\n\t\t\t\trunlist->rl = rl;\n\t\t}\n\t\tntfs_debug(\"Done (extend hole).\");\n\t\treturn 0;\n\t}\n\t \n\tif (start == rl->vcn) {\n\t\t \n\t\tif (rl > runlist->rl && (rl - 1)->lcn == LCN_HOLE) {\n\t\t\trl--;\n\t\t\tgoto extend_hole;\n\t\t}\n\t\tif (end >= rl[1].vcn) {\n\t\t\trl->lcn = LCN_HOLE;\n\t\t\tgoto extend_hole;\n\t\t}\n\t\t \n\t\ttrl = ntfs_rl_realloc(runlist->rl, old_size, old_size + 1);\n\t\tif (IS_ERR(trl))\n\t\t\tgoto enomem_out;\n\t\told_size++;\n\t\tif (runlist->rl != trl) {\n\t\t\trl = trl + (rl - runlist->rl);\n\t\t\trl_end = trl + (rl_end - runlist->rl);\n\t\t\trl_real_end = trl + (rl_real_end - runlist->rl);\n\t\t\trunlist->rl = trl;\n\t\t}\nsplit_end:\n\t\t \n\t\tmemmove(rl + 1, rl, (rl_real_end - rl + 1) * sizeof(*rl));\n\t\t \n\t\trl->lcn = LCN_HOLE;\n\t\trl->length = length;\n\t\trl++;\n\t\trl->vcn += length;\n\t\t \n\t\tif (rl->lcn >= 0 || lcn_fixup)\n\t\t\trl->lcn += length;\n\t\trl->length -= length;\n\t\tntfs_debug(\"Done (split one).\");\n\t\treturn 0;\n\t}\n\t \n\tif (rl_end->lcn == LCN_HOLE) {\n\t\t \n\t\trl->length = start - rl->vcn;\n\t\trl++;\n\t\t \n\t\tif (rl < rl_end)\n\t\t\tmemmove(rl, rl_end, (rl_real_end - rl_end + 1) *\n\t\t\t\t\tsizeof(*rl));\n\t\t \n\t\trl->vcn = start;\n\t\trl->length = rl[1].vcn - start;\n\t\tgoto shrink_allocation;\n\t}\n\t \n\tif (end >= rl[1].vcn) {\n\t\t \n\t\tif (rl[1].length && end >= rl[2].vcn) {\n\t\t\t \n\t\t\trl->length = start - rl->vcn;\n\t\t\trl++;\n\t\t\trl->vcn = start;\n\t\t\trl->lcn = LCN_HOLE;\n\t\t\tgoto extend_hole;\n\t\t}\n\t\ttrl = ntfs_rl_realloc(runlist->rl, old_size, old_size + 1);\n\t\tif (IS_ERR(trl))\n\t\t\tgoto enomem_out;\n\t\told_size++;\n\t\tif (runlist->rl != trl) {\n\t\t\trl = trl + (rl - runlist->rl);\n\t\t\trl_end = trl + (rl_end - runlist->rl);\n\t\t\trl_real_end = trl + (rl_real_end - runlist->rl);\n\t\t\trunlist->rl = trl;\n\t\t}\n\t\t \n\t\trl->length = start - rl->vcn;\n\t\trl++;\n\t\t \n\t\tdelta = rl->vcn - start;\n\t\trl->vcn = start;\n\t\tif (rl->lcn >= 0) {\n\t\t\trl->lcn -= delta;\n\t\t\t \n\t\t\tlcn_fixup = true;\n\t\t}\n\t\trl->length += delta;\n\t\tgoto split_end;\n\t}\n\t \n\ttrl = ntfs_rl_realloc(runlist->rl, old_size, old_size + 2);\n\tif (IS_ERR(trl))\n\t\tgoto enomem_out;\n\told_size += 2;\n\tif (runlist->rl != trl) {\n\t\trl = trl + (rl - runlist->rl);\n\t\trl_end = trl + (rl_end - runlist->rl);\n\t\trl_real_end = trl + (rl_real_end - runlist->rl);\n\t\trunlist->rl = trl;\n\t}\n\t \n\tmemmove(rl + 2, rl, (rl_real_end - rl + 1) * sizeof(*rl));\n\t \n\trl->length = start - rl->vcn;\n\trl++;\n\trl->vcn = start;\n\trl->lcn = LCN_HOLE;\n\trl->length = length;\n\trl++;\n\tdelta = end - rl->vcn;\n\trl->vcn = end;\n\trl->lcn += delta;\n\trl->length -= delta;\n\tntfs_debug(\"Done (split both).\");\n\treturn 0;\nenomem_out:\n\tntfs_error(vol->sb, \"Not enough memory to extend runlist buffer.\");\n\treturn -ENOMEM;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}