{
  "module_name": "lpt_commit.c",
  "hash_id": "c7e71169322dd0206078419329ca549db4d09b1c7b92b6c62096bdcad583f095",
  "original_prompt": "Ingested from linux-6.6.14/fs/ubifs/lpt_commit.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/crc16.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include \"ubifs.h\"\n\nstatic int dbg_populate_lsave(struct ubifs_info *c);\n\n \nstatic struct ubifs_cnode *first_dirty_cnode(const struct ubifs_info *c, struct ubifs_nnode *nnode)\n{\n\tubifs_assert(c, nnode);\n\twhile (1) {\n\t\tint i, cont = 0;\n\n\t\tfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\n\t\t\tstruct ubifs_cnode *cnode;\n\n\t\t\tcnode = nnode->nbranch[i].cnode;\n\t\t\tif (cnode &&\n\t\t\t    test_bit(DIRTY_CNODE, &cnode->flags)) {\n\t\t\t\tif (cnode->level == 0)\n\t\t\t\t\treturn cnode;\n\t\t\t\tnnode = (struct ubifs_nnode *)cnode;\n\t\t\t\tcont = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!cont)\n\t\t\treturn (struct ubifs_cnode *)nnode;\n\t}\n}\n\n \nstatic struct ubifs_cnode *next_dirty_cnode(const struct ubifs_info *c, struct ubifs_cnode *cnode)\n{\n\tstruct ubifs_nnode *nnode;\n\tint i;\n\n\tubifs_assert(c, cnode);\n\tnnode = cnode->parent;\n\tif (!nnode)\n\t\treturn NULL;\n\tfor (i = cnode->iip + 1; i < UBIFS_LPT_FANOUT; i++) {\n\t\tcnode = nnode->nbranch[i].cnode;\n\t\tif (cnode && test_bit(DIRTY_CNODE, &cnode->flags)) {\n\t\t\tif (cnode->level == 0)\n\t\t\t\treturn cnode;  \n\t\t\t \n\t\t\treturn first_dirty_cnode(c, (struct ubifs_nnode *)cnode);\n\t\t}\n\t}\n\treturn (struct ubifs_cnode *)nnode;\n}\n\n \nstatic int get_cnodes_to_commit(struct ubifs_info *c)\n{\n\tstruct ubifs_cnode *cnode, *cnext;\n\tint cnt = 0;\n\n\tif (!c->nroot)\n\t\treturn 0;\n\n\tif (!test_bit(DIRTY_CNODE, &c->nroot->flags))\n\t\treturn 0;\n\n\tc->lpt_cnext = first_dirty_cnode(c, c->nroot);\n\tcnode = c->lpt_cnext;\n\tif (!cnode)\n\t\treturn 0;\n\tcnt += 1;\n\twhile (1) {\n\t\tubifs_assert(c, !test_bit(COW_CNODE, &cnode->flags));\n\t\t__set_bit(COW_CNODE, &cnode->flags);\n\t\tcnext = next_dirty_cnode(c, cnode);\n\t\tif (!cnext) {\n\t\t\tcnode->cnext = c->lpt_cnext;\n\t\t\tbreak;\n\t\t}\n\t\tcnode->cnext = cnext;\n\t\tcnode = cnext;\n\t\tcnt += 1;\n\t}\n\tdbg_cmt(\"committing %d cnodes\", cnt);\n\tdbg_lp(\"committing %d cnodes\", cnt);\n\tubifs_assert(c, cnt == c->dirty_nn_cnt + c->dirty_pn_cnt);\n\treturn cnt;\n}\n\n \nstatic void upd_ltab(struct ubifs_info *c, int lnum, int free, int dirty)\n{\n\tdbg_lp(\"LEB %d free %d dirty %d to %d +%d\",\n\t       lnum, c->ltab[lnum - c->lpt_first].free,\n\t       c->ltab[lnum - c->lpt_first].dirty, free, dirty);\n\tubifs_assert(c, lnum >= c->lpt_first && lnum <= c->lpt_last);\n\tc->ltab[lnum - c->lpt_first].free = free;\n\tc->ltab[lnum - c->lpt_first].dirty += dirty;\n}\n\n \nstatic int alloc_lpt_leb(struct ubifs_info *c, int *lnum)\n{\n\tint i, n;\n\n\tn = *lnum - c->lpt_first + 1;\n\tfor (i = n; i < c->lpt_lebs; i++) {\n\t\tif (c->ltab[i].tgc || c->ltab[i].cmt)\n\t\t\tcontinue;\n\t\tif (c->ltab[i].free == c->leb_size) {\n\t\t\tc->ltab[i].cmt = 1;\n\t\t\t*lnum = i + c->lpt_first;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (c->ltab[i].tgc || c->ltab[i].cmt)\n\t\t\tcontinue;\n\t\tif (c->ltab[i].free == c->leb_size) {\n\t\t\tc->ltab[i].cmt = 1;\n\t\t\t*lnum = i + c->lpt_first;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOSPC;\n}\n\n \nstatic int layout_cnodes(struct ubifs_info *c)\n{\n\tint lnum, offs, len, alen, done_lsave, done_ltab, err;\n\tstruct ubifs_cnode *cnode;\n\n\terr = dbg_chk_lpt_sz(c, 0, 0);\n\tif (err)\n\t\treturn err;\n\tcnode = c->lpt_cnext;\n\tif (!cnode)\n\t\treturn 0;\n\tlnum = c->nhead_lnum;\n\toffs = c->nhead_offs;\n\t \n\tdone_lsave = !c->big_lpt;\n\tdone_ltab = 0;\n\tif (!done_lsave && offs + c->lsave_sz <= c->leb_size) {\n\t\tdone_lsave = 1;\n\t\tc->lsave_lnum = lnum;\n\t\tc->lsave_offs = offs;\n\t\toffs += c->lsave_sz;\n\t\tdbg_chk_lpt_sz(c, 1, c->lsave_sz);\n\t}\n\n\tif (offs + c->ltab_sz <= c->leb_size) {\n\t\tdone_ltab = 1;\n\t\tc->ltab_lnum = lnum;\n\t\tc->ltab_offs = offs;\n\t\toffs += c->ltab_sz;\n\t\tdbg_chk_lpt_sz(c, 1, c->ltab_sz);\n\t}\n\n\tdo {\n\t\tif (cnode->level) {\n\t\t\tlen = c->nnode_sz;\n\t\t\tc->dirty_nn_cnt -= 1;\n\t\t} else {\n\t\t\tlen = c->pnode_sz;\n\t\t\tc->dirty_pn_cnt -= 1;\n\t\t}\n\t\twhile (offs + len > c->leb_size) {\n\t\t\talen = ALIGN(offs, c->min_io_size);\n\t\t\tupd_ltab(c, lnum, c->leb_size - alen, alen - offs);\n\t\t\tdbg_chk_lpt_sz(c, 2, c->leb_size - offs);\n\t\t\terr = alloc_lpt_leb(c, &lnum);\n\t\t\tif (err)\n\t\t\t\tgoto no_space;\n\t\t\toffs = 0;\n\t\t\tubifs_assert(c, lnum >= c->lpt_first &&\n\t\t\t\t     lnum <= c->lpt_last);\n\t\t\t \n\t\t\tif (!done_lsave) {\n\t\t\t\tdone_lsave = 1;\n\t\t\t\tc->lsave_lnum = lnum;\n\t\t\t\tc->lsave_offs = offs;\n\t\t\t\toffs += c->lsave_sz;\n\t\t\t\tdbg_chk_lpt_sz(c, 1, c->lsave_sz);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!done_ltab) {\n\t\t\t\tdone_ltab = 1;\n\t\t\t\tc->ltab_lnum = lnum;\n\t\t\t\tc->ltab_offs = offs;\n\t\t\t\toffs += c->ltab_sz;\n\t\t\t\tdbg_chk_lpt_sz(c, 1, c->ltab_sz);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (cnode->parent) {\n\t\t\tcnode->parent->nbranch[cnode->iip].lnum = lnum;\n\t\t\tcnode->parent->nbranch[cnode->iip].offs = offs;\n\t\t} else {\n\t\t\tc->lpt_lnum = lnum;\n\t\t\tc->lpt_offs = offs;\n\t\t}\n\t\toffs += len;\n\t\tdbg_chk_lpt_sz(c, 1, len);\n\t\tcnode = cnode->cnext;\n\t} while (cnode && cnode != c->lpt_cnext);\n\n\t \n\tif (!done_lsave) {\n\t\tif (offs + c->lsave_sz > c->leb_size) {\n\t\t\talen = ALIGN(offs, c->min_io_size);\n\t\t\tupd_ltab(c, lnum, c->leb_size - alen, alen - offs);\n\t\t\tdbg_chk_lpt_sz(c, 2, c->leb_size - offs);\n\t\t\terr = alloc_lpt_leb(c, &lnum);\n\t\t\tif (err)\n\t\t\t\tgoto no_space;\n\t\t\toffs = 0;\n\t\t\tubifs_assert(c, lnum >= c->lpt_first &&\n\t\t\t\t     lnum <= c->lpt_last);\n\t\t}\n\t\tdone_lsave = 1;\n\t\tc->lsave_lnum = lnum;\n\t\tc->lsave_offs = offs;\n\t\toffs += c->lsave_sz;\n\t\tdbg_chk_lpt_sz(c, 1, c->lsave_sz);\n\t}\n\n\t \n\tif (!done_ltab) {\n\t\tif (offs + c->ltab_sz > c->leb_size) {\n\t\t\talen = ALIGN(offs, c->min_io_size);\n\t\t\tupd_ltab(c, lnum, c->leb_size - alen, alen - offs);\n\t\t\tdbg_chk_lpt_sz(c, 2, c->leb_size - offs);\n\t\t\terr = alloc_lpt_leb(c, &lnum);\n\t\t\tif (err)\n\t\t\t\tgoto no_space;\n\t\t\toffs = 0;\n\t\t\tubifs_assert(c, lnum >= c->lpt_first &&\n\t\t\t\t     lnum <= c->lpt_last);\n\t\t}\n\t\tc->ltab_lnum = lnum;\n\t\tc->ltab_offs = offs;\n\t\toffs += c->ltab_sz;\n\t\tdbg_chk_lpt_sz(c, 1, c->ltab_sz);\n\t}\n\n\talen = ALIGN(offs, c->min_io_size);\n\tupd_ltab(c, lnum, c->leb_size - alen, alen - offs);\n\tdbg_chk_lpt_sz(c, 4, alen - offs);\n\terr = dbg_chk_lpt_sz(c, 3, alen);\n\tif (err)\n\t\treturn err;\n\treturn 0;\n\nno_space:\n\tubifs_err(c, \"LPT out of space at LEB %d:%d needing %d, done_ltab %d, done_lsave %d\",\n\t\t  lnum, offs, len, done_ltab, done_lsave);\n\tubifs_dump_lpt_info(c);\n\tubifs_dump_lpt_lebs(c);\n\tdump_stack();\n\treturn err;\n}\n\n \nstatic int realloc_lpt_leb(struct ubifs_info *c, int *lnum)\n{\n\tint i, n;\n\n\tn = *lnum - c->lpt_first + 1;\n\tfor (i = n; i < c->lpt_lebs; i++)\n\t\tif (c->ltab[i].cmt) {\n\t\t\tc->ltab[i].cmt = 0;\n\t\t\t*lnum = i + c->lpt_first;\n\t\t\treturn 0;\n\t\t}\n\n\tfor (i = 0; i < n; i++)\n\t\tif (c->ltab[i].cmt) {\n\t\t\tc->ltab[i].cmt = 0;\n\t\t\t*lnum = i + c->lpt_first;\n\t\t\treturn 0;\n\t\t}\n\treturn -ENOSPC;\n}\n\n \nstatic int write_cnodes(struct ubifs_info *c)\n{\n\tint lnum, offs, len, from, err, wlen, alen, done_ltab, done_lsave;\n\tstruct ubifs_cnode *cnode;\n\tvoid *buf = c->lpt_buf;\n\n\tcnode = c->lpt_cnext;\n\tif (!cnode)\n\t\treturn 0;\n\tlnum = c->nhead_lnum;\n\toffs = c->nhead_offs;\n\tfrom = offs;\n\t \n\tif (offs == 0) {\n\t\terr = ubifs_leb_unmap(c, lnum);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\t \n\tdone_lsave = !c->big_lpt;\n\tdone_ltab = 0;\n\tif (!done_lsave && offs + c->lsave_sz <= c->leb_size) {\n\t\tdone_lsave = 1;\n\t\tubifs_pack_lsave(c, buf + offs, c->lsave);\n\t\toffs += c->lsave_sz;\n\t\tdbg_chk_lpt_sz(c, 1, c->lsave_sz);\n\t}\n\n\tif (offs + c->ltab_sz <= c->leb_size) {\n\t\tdone_ltab = 1;\n\t\tubifs_pack_ltab(c, buf + offs, c->ltab_cmt);\n\t\toffs += c->ltab_sz;\n\t\tdbg_chk_lpt_sz(c, 1, c->ltab_sz);\n\t}\n\n\t \n\tdo {\n\t\tif (cnode->level)\n\t\t\tlen = c->nnode_sz;\n\t\telse\n\t\t\tlen = c->pnode_sz;\n\t\twhile (offs + len > c->leb_size) {\n\t\t\twlen = offs - from;\n\t\t\tif (wlen) {\n\t\t\t\talen = ALIGN(wlen, c->min_io_size);\n\t\t\t\tmemset(buf + offs, 0xff, alen - wlen);\n\t\t\t\terr = ubifs_leb_write(c, lnum, buf + from, from,\n\t\t\t\t\t\t       alen);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t\tdbg_chk_lpt_sz(c, 2, c->leb_size - offs);\n\t\t\terr = realloc_lpt_leb(c, &lnum);\n\t\t\tif (err)\n\t\t\t\tgoto no_space;\n\t\t\toffs = from = 0;\n\t\t\tubifs_assert(c, lnum >= c->lpt_first &&\n\t\t\t\t     lnum <= c->lpt_last);\n\t\t\terr = ubifs_leb_unmap(c, lnum);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\t \n\t\t\tif (!done_lsave) {\n\t\t\t\tdone_lsave = 1;\n\t\t\t\tubifs_pack_lsave(c, buf + offs, c->lsave);\n\t\t\t\toffs += c->lsave_sz;\n\t\t\t\tdbg_chk_lpt_sz(c, 1, c->lsave_sz);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!done_ltab) {\n\t\t\t\tdone_ltab = 1;\n\t\t\t\tubifs_pack_ltab(c, buf + offs, c->ltab_cmt);\n\t\t\t\toffs += c->ltab_sz;\n\t\t\t\tdbg_chk_lpt_sz(c, 1, c->ltab_sz);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (cnode->level)\n\t\t\tubifs_pack_nnode(c, buf + offs,\n\t\t\t\t\t (struct ubifs_nnode *)cnode);\n\t\telse\n\t\t\tubifs_pack_pnode(c, buf + offs,\n\t\t\t\t\t (struct ubifs_pnode *)cnode);\n\t\t \n\t\tclear_bit(DIRTY_CNODE, &cnode->flags);\n\t\tsmp_mb__before_atomic();\n\t\tclear_bit(COW_CNODE, &cnode->flags);\n\t\tsmp_mb__after_atomic();\n\t\toffs += len;\n\t\tdbg_chk_lpt_sz(c, 1, len);\n\t\tcnode = cnode->cnext;\n\t} while (cnode && cnode != c->lpt_cnext);\n\n\t \n\tif (!done_lsave) {\n\t\tif (offs + c->lsave_sz > c->leb_size) {\n\t\t\twlen = offs - from;\n\t\t\talen = ALIGN(wlen, c->min_io_size);\n\t\t\tmemset(buf + offs, 0xff, alen - wlen);\n\t\t\terr = ubifs_leb_write(c, lnum, buf + from, from, alen);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tdbg_chk_lpt_sz(c, 2, c->leb_size - offs);\n\t\t\terr = realloc_lpt_leb(c, &lnum);\n\t\t\tif (err)\n\t\t\t\tgoto no_space;\n\t\t\toffs = from = 0;\n\t\t\tubifs_assert(c, lnum >= c->lpt_first &&\n\t\t\t\t     lnum <= c->lpt_last);\n\t\t\terr = ubifs_leb_unmap(c, lnum);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tdone_lsave = 1;\n\t\tubifs_pack_lsave(c, buf + offs, c->lsave);\n\t\toffs += c->lsave_sz;\n\t\tdbg_chk_lpt_sz(c, 1, c->lsave_sz);\n\t}\n\n\t \n\tif (!done_ltab) {\n\t\tif (offs + c->ltab_sz > c->leb_size) {\n\t\t\twlen = offs - from;\n\t\t\talen = ALIGN(wlen, c->min_io_size);\n\t\t\tmemset(buf + offs, 0xff, alen - wlen);\n\t\t\terr = ubifs_leb_write(c, lnum, buf + from, from, alen);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tdbg_chk_lpt_sz(c, 2, c->leb_size - offs);\n\t\t\terr = realloc_lpt_leb(c, &lnum);\n\t\t\tif (err)\n\t\t\t\tgoto no_space;\n\t\t\toffs = from = 0;\n\t\t\tubifs_assert(c, lnum >= c->lpt_first &&\n\t\t\t\t     lnum <= c->lpt_last);\n\t\t\terr = ubifs_leb_unmap(c, lnum);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tubifs_pack_ltab(c, buf + offs, c->ltab_cmt);\n\t\toffs += c->ltab_sz;\n\t\tdbg_chk_lpt_sz(c, 1, c->ltab_sz);\n\t}\n\n\t \n\twlen = offs - from;\n\talen = ALIGN(wlen, c->min_io_size);\n\tmemset(buf + offs, 0xff, alen - wlen);\n\terr = ubifs_leb_write(c, lnum, buf + from, from, alen);\n\tif (err)\n\t\treturn err;\n\n\tdbg_chk_lpt_sz(c, 4, alen - wlen);\n\terr = dbg_chk_lpt_sz(c, 3, ALIGN(offs, c->min_io_size));\n\tif (err)\n\t\treturn err;\n\n\tc->nhead_lnum = lnum;\n\tc->nhead_offs = ALIGN(offs, c->min_io_size);\n\n\tdbg_lp(\"LPT root is at %d:%d\", c->lpt_lnum, c->lpt_offs);\n\tdbg_lp(\"LPT head is at %d:%d\", c->nhead_lnum, c->nhead_offs);\n\tdbg_lp(\"LPT ltab is at %d:%d\", c->ltab_lnum, c->ltab_offs);\n\tif (c->big_lpt)\n\t\tdbg_lp(\"LPT lsave is at %d:%d\", c->lsave_lnum, c->lsave_offs);\n\n\treturn 0;\n\nno_space:\n\tubifs_err(c, \"LPT out of space mismatch at LEB %d:%d needing %d, done_ltab %d, done_lsave %d\",\n\t\t  lnum, offs, len, done_ltab, done_lsave);\n\tubifs_dump_lpt_info(c);\n\tubifs_dump_lpt_lebs(c);\n\tdump_stack();\n\treturn err;\n}\n\n \nstatic struct ubifs_pnode *next_pnode_to_dirty(struct ubifs_info *c,\n\t\t\t\t\t       struct ubifs_pnode *pnode)\n{\n\tstruct ubifs_nnode *nnode;\n\tint iip;\n\n\t \n\tnnode = pnode->parent;\n\tfor (iip = pnode->iip + 1; iip < UBIFS_LPT_FANOUT; iip++) {\n\t\tif (nnode->nbranch[iip].lnum)\n\t\t\treturn ubifs_get_pnode(c, nnode, iip);\n\t}\n\n\t \n\tdo {\n\t\tiip = nnode->iip + 1;\n\t\tnnode = nnode->parent;\n\t\tif (!nnode)\n\t\t\treturn NULL;\n\t\tfor (; iip < UBIFS_LPT_FANOUT; iip++) {\n\t\t\tif (nnode->nbranch[iip].lnum)\n\t\t\t\tbreak;\n\t\t}\n\t} while (iip >= UBIFS_LPT_FANOUT);\n\n\t \n\tnnode = ubifs_get_nnode(c, nnode, iip);\n\tif (IS_ERR(nnode))\n\t\treturn (void *)nnode;\n\n\t \n\twhile (nnode->level > 1) {\n\t\tfor (iip = 0; iip < UBIFS_LPT_FANOUT; iip++) {\n\t\t\tif (nnode->nbranch[iip].lnum)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (iip >= UBIFS_LPT_FANOUT) {\n\t\t\t \n\t\t\tiip = 0;\n\t\t}\n\t\tnnode = ubifs_get_nnode(c, nnode, iip);\n\t\tif (IS_ERR(nnode))\n\t\t\treturn (void *)nnode;\n\t}\n\n\tfor (iip = 0; iip < UBIFS_LPT_FANOUT; iip++)\n\t\tif (nnode->nbranch[iip].lnum)\n\t\t\tbreak;\n\tif (iip >= UBIFS_LPT_FANOUT)\n\t\t \n\t\tiip = 0;\n\treturn ubifs_get_pnode(c, nnode, iip);\n}\n\n \nstatic void add_pnode_dirt(struct ubifs_info *c, struct ubifs_pnode *pnode)\n{\n\tubifs_add_lpt_dirt(c, pnode->parent->nbranch[pnode->iip].lnum,\n\t\t\t   c->pnode_sz);\n}\n\n \nstatic void do_make_pnode_dirty(struct ubifs_info *c, struct ubifs_pnode *pnode)\n{\n\t \n\tif (!test_and_set_bit(DIRTY_CNODE, &pnode->flags)) {\n\t\tstruct ubifs_nnode *nnode;\n\n\t\tc->dirty_pn_cnt += 1;\n\t\tadd_pnode_dirt(c, pnode);\n\t\t \n\t\tnnode = pnode->parent;\n\t\twhile (nnode) {\n\t\t\tif (!test_and_set_bit(DIRTY_CNODE, &nnode->flags)) {\n\t\t\t\tc->dirty_nn_cnt += 1;\n\t\t\t\tubifs_add_nnode_dirt(c, nnode);\n\t\t\t\tnnode = nnode->parent;\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nstatic int make_tree_dirty(struct ubifs_info *c)\n{\n\tstruct ubifs_pnode *pnode;\n\n\tpnode = ubifs_pnode_lookup(c, 0);\n\tif (IS_ERR(pnode))\n\t\treturn PTR_ERR(pnode);\n\n\twhile (pnode) {\n\t\tdo_make_pnode_dirty(c, pnode);\n\t\tpnode = next_pnode_to_dirty(c, pnode);\n\t\tif (IS_ERR(pnode))\n\t\t\treturn PTR_ERR(pnode);\n\t}\n\treturn 0;\n}\n\n \nstatic int need_write_all(struct ubifs_info *c)\n{\n\tlong long free = 0;\n\tint i;\n\n\tfor (i = 0; i < c->lpt_lebs; i++) {\n\t\tif (i + c->lpt_first == c->nhead_lnum)\n\t\t\tfree += c->leb_size - c->nhead_offs;\n\t\telse if (c->ltab[i].free == c->leb_size)\n\t\t\tfree += c->leb_size;\n\t\telse if (c->ltab[i].free + c->ltab[i].dirty == c->leb_size)\n\t\t\tfree += c->leb_size;\n\t}\n\t \n\tif (free <= c->lpt_sz * 2)\n\t\treturn 1;\n\treturn 0;\n}\n\n \nstatic void lpt_tgc_start(struct ubifs_info *c)\n{\n\tint i;\n\n\tfor (i = 0; i < c->lpt_lebs; i++) {\n\t\tif (i + c->lpt_first == c->nhead_lnum)\n\t\t\tcontinue;\n\t\tif (c->ltab[i].dirty > 0 &&\n\t\t    c->ltab[i].free + c->ltab[i].dirty == c->leb_size) {\n\t\t\tc->ltab[i].tgc = 1;\n\t\t\tc->ltab[i].free = c->leb_size;\n\t\t\tc->ltab[i].dirty = 0;\n\t\t\tdbg_lp(\"LEB %d\", i + c->lpt_first);\n\t\t}\n\t}\n}\n\n \nstatic int lpt_tgc_end(struct ubifs_info *c)\n{\n\tint i, err;\n\n\tfor (i = 0; i < c->lpt_lebs; i++)\n\t\tif (c->ltab[i].tgc) {\n\t\t\terr = ubifs_leb_unmap(c, i + c->lpt_first);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tc->ltab[i].tgc = 0;\n\t\t\tdbg_lp(\"LEB %d\", i + c->lpt_first);\n\t\t}\n\treturn 0;\n}\n\n \nstatic void populate_lsave(struct ubifs_info *c)\n{\n\tstruct ubifs_lprops *lprops;\n\tstruct ubifs_lpt_heap *heap;\n\tint i, cnt = 0;\n\n\tubifs_assert(c, c->big_lpt);\n\tif (!(c->lpt_drty_flgs & LSAVE_DIRTY)) {\n\t\tc->lpt_drty_flgs |= LSAVE_DIRTY;\n\t\tubifs_add_lpt_dirt(c, c->lsave_lnum, c->lsave_sz);\n\t}\n\n\tif (dbg_populate_lsave(c))\n\t\treturn;\n\n\tlist_for_each_entry(lprops, &c->empty_list, list) {\n\t\tc->lsave[cnt++] = lprops->lnum;\n\t\tif (cnt >= c->lsave_cnt)\n\t\t\treturn;\n\t}\n\tlist_for_each_entry(lprops, &c->freeable_list, list) {\n\t\tc->lsave[cnt++] = lprops->lnum;\n\t\tif (cnt >= c->lsave_cnt)\n\t\t\treturn;\n\t}\n\tlist_for_each_entry(lprops, &c->frdi_idx_list, list) {\n\t\tc->lsave[cnt++] = lprops->lnum;\n\t\tif (cnt >= c->lsave_cnt)\n\t\t\treturn;\n\t}\n\theap = &c->lpt_heap[LPROPS_DIRTY_IDX - 1];\n\tfor (i = 0; i < heap->cnt; i++) {\n\t\tc->lsave[cnt++] = heap->arr[i]->lnum;\n\t\tif (cnt >= c->lsave_cnt)\n\t\t\treturn;\n\t}\n\theap = &c->lpt_heap[LPROPS_DIRTY - 1];\n\tfor (i = 0; i < heap->cnt; i++) {\n\t\tc->lsave[cnt++] = heap->arr[i]->lnum;\n\t\tif (cnt >= c->lsave_cnt)\n\t\t\treturn;\n\t}\n\theap = &c->lpt_heap[LPROPS_FREE - 1];\n\tfor (i = 0; i < heap->cnt; i++) {\n\t\tc->lsave[cnt++] = heap->arr[i]->lnum;\n\t\tif (cnt >= c->lsave_cnt)\n\t\t\treturn;\n\t}\n\t \n\twhile (cnt < c->lsave_cnt)\n\t\tc->lsave[cnt++] = c->main_first;\n}\n\n \nstatic struct ubifs_nnode *nnode_lookup(struct ubifs_info *c, int i)\n{\n\tint err, iip;\n\tstruct ubifs_nnode *nnode;\n\n\tif (!c->nroot) {\n\t\terr = ubifs_read_nnode(c, NULL, 0);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\t}\n\tnnode = c->nroot;\n\twhile (1) {\n\t\tiip = i & (UBIFS_LPT_FANOUT - 1);\n\t\ti >>= UBIFS_LPT_FANOUT_SHIFT;\n\t\tif (!i)\n\t\t\tbreak;\n\t\tnnode = ubifs_get_nnode(c, nnode, iip);\n\t\tif (IS_ERR(nnode))\n\t\t\treturn nnode;\n\t}\n\treturn nnode;\n}\n\n \nstatic int make_nnode_dirty(struct ubifs_info *c, int node_num, int lnum,\n\t\t\t    int offs)\n{\n\tstruct ubifs_nnode *nnode;\n\n\tnnode = nnode_lookup(c, node_num);\n\tif (IS_ERR(nnode))\n\t\treturn PTR_ERR(nnode);\n\tif (nnode->parent) {\n\t\tstruct ubifs_nbranch *branch;\n\n\t\tbranch = &nnode->parent->nbranch[nnode->iip];\n\t\tif (branch->lnum != lnum || branch->offs != offs)\n\t\t\treturn 0;  \n\t} else if (c->lpt_lnum != lnum || c->lpt_offs != offs)\n\t\t\treturn 0;  \n\t \n\tif (!test_and_set_bit(DIRTY_CNODE, &nnode->flags)) {\n\t\tc->dirty_nn_cnt += 1;\n\t\tubifs_add_nnode_dirt(c, nnode);\n\t\t \n\t\tnnode = nnode->parent;\n\t\twhile (nnode) {\n\t\t\tif (!test_and_set_bit(DIRTY_CNODE, &nnode->flags)) {\n\t\t\t\tc->dirty_nn_cnt += 1;\n\t\t\t\tubifs_add_nnode_dirt(c, nnode);\n\t\t\t\tnnode = nnode->parent;\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int make_pnode_dirty(struct ubifs_info *c, int node_num, int lnum,\n\t\t\t    int offs)\n{\n\tstruct ubifs_pnode *pnode;\n\tstruct ubifs_nbranch *branch;\n\n\tpnode = ubifs_pnode_lookup(c, node_num);\n\tif (IS_ERR(pnode))\n\t\treturn PTR_ERR(pnode);\n\tbranch = &pnode->parent->nbranch[pnode->iip];\n\tif (branch->lnum != lnum || branch->offs != offs)\n\t\treturn 0;\n\tdo_make_pnode_dirty(c, pnode);\n\treturn 0;\n}\n\n \nstatic int make_ltab_dirty(struct ubifs_info *c, int lnum, int offs)\n{\n\tif (lnum != c->ltab_lnum || offs != c->ltab_offs)\n\t\treturn 0;  \n\tif (!(c->lpt_drty_flgs & LTAB_DIRTY)) {\n\t\tc->lpt_drty_flgs |= LTAB_DIRTY;\n\t\tubifs_add_lpt_dirt(c, c->ltab_lnum, c->ltab_sz);\n\t}\n\treturn 0;\n}\n\n \nstatic int make_lsave_dirty(struct ubifs_info *c, int lnum, int offs)\n{\n\tif (lnum != c->lsave_lnum || offs != c->lsave_offs)\n\t\treturn 0;  \n\tif (!(c->lpt_drty_flgs & LSAVE_DIRTY)) {\n\t\tc->lpt_drty_flgs |= LSAVE_DIRTY;\n\t\tubifs_add_lpt_dirt(c, c->lsave_lnum, c->lsave_sz);\n\t}\n\treturn 0;\n}\n\n \nstatic int make_node_dirty(struct ubifs_info *c, int node_type, int node_num,\n\t\t\t   int lnum, int offs)\n{\n\tswitch (node_type) {\n\tcase UBIFS_LPT_NNODE:\n\t\treturn make_nnode_dirty(c, node_num, lnum, offs);\n\tcase UBIFS_LPT_PNODE:\n\t\treturn make_pnode_dirty(c, node_num, lnum, offs);\n\tcase UBIFS_LPT_LTAB:\n\t\treturn make_ltab_dirty(c, lnum, offs);\n\tcase UBIFS_LPT_LSAVE:\n\t\treturn make_lsave_dirty(c, lnum, offs);\n\t}\n\treturn -EINVAL;\n}\n\n \nstatic int get_lpt_node_len(const struct ubifs_info *c, int node_type)\n{\n\tswitch (node_type) {\n\tcase UBIFS_LPT_NNODE:\n\t\treturn c->nnode_sz;\n\tcase UBIFS_LPT_PNODE:\n\t\treturn c->pnode_sz;\n\tcase UBIFS_LPT_LTAB:\n\t\treturn c->ltab_sz;\n\tcase UBIFS_LPT_LSAVE:\n\t\treturn c->lsave_sz;\n\t}\n\treturn 0;\n}\n\n \nstatic int get_pad_len(const struct ubifs_info *c, uint8_t *buf, int len)\n{\n\tint offs, pad_len;\n\n\tif (c->min_io_size == 1)\n\t\treturn 0;\n\toffs = c->leb_size - len;\n\tpad_len = ALIGN(offs, c->min_io_size) - offs;\n\treturn pad_len;\n}\n\n \nstatic int get_lpt_node_type(const struct ubifs_info *c, uint8_t *buf,\n\t\t\t     int *node_num)\n{\n\tuint8_t *addr = buf + UBIFS_LPT_CRC_BYTES;\n\tint pos = 0, node_type;\n\n\tnode_type = ubifs_unpack_bits(c, &addr, &pos, UBIFS_LPT_TYPE_BITS);\n\t*node_num = ubifs_unpack_bits(c, &addr, &pos, c->pcnt_bits);\n\treturn node_type;\n}\n\n \nstatic int is_a_node(const struct ubifs_info *c, uint8_t *buf, int len)\n{\n\tuint8_t *addr = buf + UBIFS_LPT_CRC_BYTES;\n\tint pos = 0, node_type, node_len;\n\tuint16_t crc, calc_crc;\n\n\tif (len < UBIFS_LPT_CRC_BYTES + (UBIFS_LPT_TYPE_BITS + 7) / 8)\n\t\treturn 0;\n\tnode_type = ubifs_unpack_bits(c, &addr, &pos, UBIFS_LPT_TYPE_BITS);\n\tif (node_type == UBIFS_LPT_NOT_A_NODE)\n\t\treturn 0;\n\tnode_len = get_lpt_node_len(c, node_type);\n\tif (!node_len || node_len > len)\n\t\treturn 0;\n\tpos = 0;\n\taddr = buf;\n\tcrc = ubifs_unpack_bits(c, &addr, &pos, UBIFS_LPT_CRC_BITS);\n\tcalc_crc = crc16(-1, buf + UBIFS_LPT_CRC_BYTES,\n\t\t\t node_len - UBIFS_LPT_CRC_BYTES);\n\tif (crc != calc_crc)\n\t\treturn 0;\n\treturn 1;\n}\n\n \nstatic int lpt_gc_lnum(struct ubifs_info *c, int lnum)\n{\n\tint err, len = c->leb_size, node_type, node_num, node_len, offs;\n\tvoid *buf = c->lpt_buf;\n\n\tdbg_lp(\"LEB %d\", lnum);\n\n\terr = ubifs_leb_read(c, lnum, buf, 0, c->leb_size, 1);\n\tif (err)\n\t\treturn err;\n\n\twhile (1) {\n\t\tif (!is_a_node(c, buf, len)) {\n\t\t\tint pad_len;\n\n\t\t\tpad_len = get_pad_len(c, buf, len);\n\t\t\tif (pad_len) {\n\t\t\t\tbuf += pad_len;\n\t\t\t\tlen -= pad_len;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tnode_type = get_lpt_node_type(c, buf, &node_num);\n\t\tnode_len = get_lpt_node_len(c, node_type);\n\t\toffs = c->leb_size - len;\n\t\tubifs_assert(c, node_len != 0);\n\t\tmutex_lock(&c->lp_mutex);\n\t\terr = make_node_dirty(c, node_type, node_num, lnum, offs);\n\t\tmutex_unlock(&c->lp_mutex);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbuf += node_len;\n\t\tlen -= node_len;\n\t}\n\treturn 0;\n}\n\n \nstatic int lpt_gc(struct ubifs_info *c)\n{\n\tint i, lnum = -1, dirty = 0;\n\n\tmutex_lock(&c->lp_mutex);\n\tfor (i = 0; i < c->lpt_lebs; i++) {\n\t\tubifs_assert(c, !c->ltab[i].tgc);\n\t\tif (i + c->lpt_first == c->nhead_lnum ||\n\t\t    c->ltab[i].free + c->ltab[i].dirty == c->leb_size)\n\t\t\tcontinue;\n\t\tif (c->ltab[i].dirty > dirty) {\n\t\t\tdirty = c->ltab[i].dirty;\n\t\t\tlnum = i + c->lpt_first;\n\t\t}\n\t}\n\tmutex_unlock(&c->lp_mutex);\n\tif (lnum == -1)\n\t\treturn -ENOSPC;\n\treturn lpt_gc_lnum(c, lnum);\n}\n\n \nint ubifs_lpt_start_commit(struct ubifs_info *c)\n{\n\tint err, cnt;\n\n\tdbg_lp(\"\");\n\n\tmutex_lock(&c->lp_mutex);\n\terr = dbg_chk_lpt_free_spc(c);\n\tif (err)\n\t\tgoto out;\n\terr = dbg_check_ltab(c);\n\tif (err)\n\t\tgoto out;\n\n\tif (c->check_lpt_free) {\n\t\t \n\t\tc->check_lpt_free = 0;\n\t\twhile (need_write_all(c)) {\n\t\t\tmutex_unlock(&c->lp_mutex);\n\t\t\terr = lpt_gc(c);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tmutex_lock(&c->lp_mutex);\n\t\t}\n\t}\n\n\tlpt_tgc_start(c);\n\n\tif (!c->dirty_pn_cnt) {\n\t\tdbg_cmt(\"no cnodes to commit\");\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\tif (!c->big_lpt && need_write_all(c)) {\n\t\t \n\t\terr = make_tree_dirty(c);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tlpt_tgc_start(c);\n\t}\n\n\tif (c->big_lpt)\n\t\tpopulate_lsave(c);\n\n\tcnt = get_cnodes_to_commit(c);\n\tubifs_assert(c, cnt != 0);\n\n\terr = layout_cnodes(c);\n\tif (err)\n\t\tgoto out;\n\n\terr = ubifs_lpt_calc_hash(c, c->mst_node->hash_lpt);\n\tif (err)\n\t\tgoto out;\n\n\t \n\tmemcpy(c->ltab_cmt, c->ltab,\n\t       sizeof(struct ubifs_lpt_lprops) * c->lpt_lebs);\n\tc->lpt_drty_flgs &= ~(LTAB_DIRTY | LSAVE_DIRTY);\n\nout:\n\tmutex_unlock(&c->lp_mutex);\n\treturn err;\n}\n\n \nstatic void free_obsolete_cnodes(struct ubifs_info *c)\n{\n\tstruct ubifs_cnode *cnode, *cnext;\n\n\tcnext = c->lpt_cnext;\n\tif (!cnext)\n\t\treturn;\n\tdo {\n\t\tcnode = cnext;\n\t\tcnext = cnode->cnext;\n\t\tif (test_bit(OBSOLETE_CNODE, &cnode->flags))\n\t\t\tkfree(cnode);\n\t\telse\n\t\t\tcnode->cnext = NULL;\n\t} while (cnext != c->lpt_cnext);\n\tc->lpt_cnext = NULL;\n}\n\n \nint ubifs_lpt_end_commit(struct ubifs_info *c)\n{\n\tint err;\n\n\tdbg_lp(\"\");\n\n\tif (!c->lpt_cnext)\n\t\treturn 0;\n\n\terr = write_cnodes(c);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&c->lp_mutex);\n\tfree_obsolete_cnodes(c);\n\tmutex_unlock(&c->lp_mutex);\n\n\treturn 0;\n}\n\n \nint ubifs_lpt_post_commit(struct ubifs_info *c)\n{\n\tint err;\n\n\tmutex_lock(&c->lp_mutex);\n\terr = lpt_tgc_end(c);\n\tif (err)\n\t\tgoto out;\n\tif (c->big_lpt)\n\t\twhile (need_write_all(c)) {\n\t\t\tmutex_unlock(&c->lp_mutex);\n\t\t\terr = lpt_gc(c);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tmutex_lock(&c->lp_mutex);\n\t\t}\nout:\n\tmutex_unlock(&c->lp_mutex);\n\treturn err;\n}\n\n \nstatic struct ubifs_nnode *first_nnode(struct ubifs_info *c, int *hght)\n{\n\tstruct ubifs_nnode *nnode;\n\tint h, i, found;\n\n\tnnode = c->nroot;\n\t*hght = 0;\n\tif (!nnode)\n\t\treturn NULL;\n\tfor (h = 1; h < c->lpt_hght; h++) {\n\t\tfound = 0;\n\t\tfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\n\t\t\tif (nnode->nbranch[i].nnode) {\n\t\t\t\tfound = 1;\n\t\t\t\tnnode = nnode->nbranch[i].nnode;\n\t\t\t\t*hght = h;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found)\n\t\t\tbreak;\n\t}\n\treturn nnode;\n}\n\n \nstatic struct ubifs_nnode *next_nnode(struct ubifs_info *c,\n\t\t\t\t      struct ubifs_nnode *nnode, int *hght)\n{\n\tstruct ubifs_nnode *parent;\n\tint iip, h, i, found;\n\n\tparent = nnode->parent;\n\tif (!parent)\n\t\treturn NULL;\n\tif (nnode->iip == UBIFS_LPT_FANOUT - 1) {\n\t\t*hght -= 1;\n\t\treturn parent;\n\t}\n\tfor (iip = nnode->iip + 1; iip < UBIFS_LPT_FANOUT; iip++) {\n\t\tnnode = parent->nbranch[iip].nnode;\n\t\tif (nnode)\n\t\t\tbreak;\n\t}\n\tif (!nnode) {\n\t\t*hght -= 1;\n\t\treturn parent;\n\t}\n\tfor (h = *hght + 1; h < c->lpt_hght; h++) {\n\t\tfound = 0;\n\t\tfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\n\t\t\tif (nnode->nbranch[i].nnode) {\n\t\t\t\tfound = 1;\n\t\t\t\tnnode = nnode->nbranch[i].nnode;\n\t\t\t\t*hght = h;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found)\n\t\t\tbreak;\n\t}\n\treturn nnode;\n}\n\n \nvoid ubifs_lpt_free(struct ubifs_info *c, int wr_only)\n{\n\tstruct ubifs_nnode *nnode;\n\tint i, hght;\n\n\t \n\n\tfree_obsolete_cnodes(c);  \n\n\tvfree(c->ltab_cmt);\n\tc->ltab_cmt = NULL;\n\tvfree(c->lpt_buf);\n\tc->lpt_buf = NULL;\n\tkfree(c->lsave);\n\tc->lsave = NULL;\n\n\tif (wr_only)\n\t\treturn;\n\n\t \n\n\tnnode = first_nnode(c, &hght);\n\twhile (nnode) {\n\t\tfor (i = 0; i < UBIFS_LPT_FANOUT; i++)\n\t\t\tkfree(nnode->nbranch[i].nnode);\n\t\tnnode = next_nnode(c, nnode, &hght);\n\t}\n\tfor (i = 0; i < LPROPS_HEAP_CNT; i++)\n\t\tkfree(c->lpt_heap[i].arr);\n\tkfree(c->dirty_idx.arr);\n\tkfree(c->nroot);\n\tvfree(c->ltab);\n\tkfree(c->lpt_nod_buf);\n}\n\n \n\n \nstatic int dbg_is_all_ff(uint8_t *buf, int len)\n{\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\tif (buf[i] != 0xff)\n\t\t\treturn 0;\n\treturn 1;\n}\n\n \nstatic int dbg_is_nnode_dirty(struct ubifs_info *c, int lnum, int offs)\n{\n\tstruct ubifs_nnode *nnode;\n\tint hght;\n\n\t \n\tnnode = first_nnode(c, &hght);\n\tfor (; nnode; nnode = next_nnode(c, nnode, &hght)) {\n\t\tstruct ubifs_nbranch *branch;\n\n\t\tcond_resched();\n\t\tif (nnode->parent) {\n\t\t\tbranch = &nnode->parent->nbranch[nnode->iip];\n\t\t\tif (branch->lnum != lnum || branch->offs != offs)\n\t\t\t\tcontinue;\n\t\t\tif (test_bit(DIRTY_CNODE, &nnode->flags))\n\t\t\t\treturn 1;\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (c->lpt_lnum != lnum || c->lpt_offs != offs)\n\t\t\t\tcontinue;\n\t\t\tif (test_bit(DIRTY_CNODE, &nnode->flags))\n\t\t\t\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\n \nstatic int dbg_is_pnode_dirty(struct ubifs_info *c, int lnum, int offs)\n{\n\tint i, cnt;\n\n\tcnt = DIV_ROUND_UP(c->main_lebs, UBIFS_LPT_FANOUT);\n\tfor (i = 0; i < cnt; i++) {\n\t\tstruct ubifs_pnode *pnode;\n\t\tstruct ubifs_nbranch *branch;\n\n\t\tcond_resched();\n\t\tpnode = ubifs_pnode_lookup(c, i);\n\t\tif (IS_ERR(pnode))\n\t\t\treturn PTR_ERR(pnode);\n\t\tbranch = &pnode->parent->nbranch[pnode->iip];\n\t\tif (branch->lnum != lnum || branch->offs != offs)\n\t\t\tcontinue;\n\t\tif (test_bit(DIRTY_CNODE, &pnode->flags))\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n \nstatic int dbg_is_ltab_dirty(struct ubifs_info *c, int lnum, int offs)\n{\n\tif (lnum != c->ltab_lnum || offs != c->ltab_offs)\n\t\treturn 1;\n\treturn (c->lpt_drty_flgs & LTAB_DIRTY) != 0;\n}\n\n \nstatic int dbg_is_lsave_dirty(struct ubifs_info *c, int lnum, int offs)\n{\n\tif (lnum != c->lsave_lnum || offs != c->lsave_offs)\n\t\treturn 1;\n\treturn (c->lpt_drty_flgs & LSAVE_DIRTY) != 0;\n}\n\n \nstatic int dbg_is_node_dirty(struct ubifs_info *c, int node_type, int lnum,\n\t\t\t     int offs)\n{\n\tswitch (node_type) {\n\tcase UBIFS_LPT_NNODE:\n\t\treturn dbg_is_nnode_dirty(c, lnum, offs);\n\tcase UBIFS_LPT_PNODE:\n\t\treturn dbg_is_pnode_dirty(c, lnum, offs);\n\tcase UBIFS_LPT_LTAB:\n\t\treturn dbg_is_ltab_dirty(c, lnum, offs);\n\tcase UBIFS_LPT_LSAVE:\n\t\treturn dbg_is_lsave_dirty(c, lnum, offs);\n\t}\n\treturn 1;\n}\n\n \nstatic int dbg_check_ltab_lnum(struct ubifs_info *c, int lnum)\n{\n\tint err, len = c->leb_size, dirty = 0, node_type, node_num, node_len;\n\tint ret;\n\tvoid *buf, *p;\n\n\tif (!dbg_is_chk_lprops(c))\n\t\treturn 0;\n\n\tbuf = p = __vmalloc(c->leb_size, GFP_NOFS);\n\tif (!buf) {\n\t\tubifs_err(c, \"cannot allocate memory for ltab checking\");\n\t\treturn 0;\n\t}\n\n\tdbg_lp(\"LEB %d\", lnum);\n\n\terr = ubifs_leb_read(c, lnum, buf, 0, c->leb_size, 1);\n\tif (err)\n\t\tgoto out;\n\n\twhile (1) {\n\t\tif (!is_a_node(c, p, len)) {\n\t\t\tint i, pad_len;\n\n\t\t\tpad_len = get_pad_len(c, p, len);\n\t\t\tif (pad_len) {\n\t\t\t\tp += pad_len;\n\t\t\t\tlen -= pad_len;\n\t\t\t\tdirty += pad_len;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!dbg_is_all_ff(p, len)) {\n\t\t\t\tubifs_err(c, \"invalid empty space in LEB %d at %d\",\n\t\t\t\t\t  lnum, c->leb_size - len);\n\t\t\t\terr = -EINVAL;\n\t\t\t}\n\t\t\ti = lnum - c->lpt_first;\n\t\t\tif (len != c->ltab[i].free) {\n\t\t\t\tubifs_err(c, \"invalid free space in LEB %d (free %d, expected %d)\",\n\t\t\t\t\t  lnum, len, c->ltab[i].free);\n\t\t\t\terr = -EINVAL;\n\t\t\t}\n\t\t\tif (dirty != c->ltab[i].dirty) {\n\t\t\t\tubifs_err(c, \"invalid dirty space in LEB %d (dirty %d, expected %d)\",\n\t\t\t\t\t  lnum, dirty, c->ltab[i].dirty);\n\t\t\t\terr = -EINVAL;\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\t\tnode_type = get_lpt_node_type(c, p, &node_num);\n\t\tnode_len = get_lpt_node_len(c, node_type);\n\t\tret = dbg_is_node_dirty(c, node_type, lnum, c->leb_size - len);\n\t\tif (ret == 1)\n\t\t\tdirty += node_len;\n\t\tp += node_len;\n\t\tlen -= node_len;\n\t}\n\n\terr = 0;\nout:\n\tvfree(buf);\n\treturn err;\n}\n\n \nint dbg_check_ltab(struct ubifs_info *c)\n{\n\tint lnum, err, i, cnt;\n\n\tif (!dbg_is_chk_lprops(c))\n\t\treturn 0;\n\n\t \n\tcnt = DIV_ROUND_UP(c->main_lebs, UBIFS_LPT_FANOUT);\n\tfor (i = 0; i < cnt; i++) {\n\t\tstruct ubifs_pnode *pnode;\n\n\t\tpnode = ubifs_pnode_lookup(c, i);\n\t\tif (IS_ERR(pnode))\n\t\t\treturn PTR_ERR(pnode);\n\t\tcond_resched();\n\t}\n\n\t \n\terr = dbg_check_lpt_nodes(c, (struct ubifs_cnode *)c->nroot, 0, 0);\n\tif (err)\n\t\treturn err;\n\n\t \n\tfor (lnum = c->lpt_first; lnum <= c->lpt_last; lnum++) {\n\t\terr = dbg_check_ltab_lnum(c, lnum);\n\t\tif (err) {\n\t\t\tubifs_err(c, \"failed at LEB %d\", lnum);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tdbg_lp(\"succeeded\");\n\treturn 0;\n}\n\n \nint dbg_chk_lpt_free_spc(struct ubifs_info *c)\n{\n\tlong long free = 0;\n\tint i;\n\n\tif (!dbg_is_chk_lprops(c))\n\t\treturn 0;\n\n\tfor (i = 0; i < c->lpt_lebs; i++) {\n\t\tif (c->ltab[i].tgc || c->ltab[i].cmt)\n\t\t\tcontinue;\n\t\tif (i + c->lpt_first == c->nhead_lnum)\n\t\t\tfree += c->leb_size - c->nhead_offs;\n\t\telse if (c->ltab[i].free == c->leb_size)\n\t\t\tfree += c->leb_size;\n\t}\n\tif (free < c->lpt_sz) {\n\t\tubifs_err(c, \"LPT space error: free %lld lpt_sz %lld\",\n\t\t\t  free, c->lpt_sz);\n\t\tubifs_dump_lpt_info(c);\n\t\tubifs_dump_lpt_lebs(c);\n\t\tdump_stack();\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nint dbg_chk_lpt_sz(struct ubifs_info *c, int action, int len)\n{\n\tstruct ubifs_debug_info *d = c->dbg;\n\tlong long chk_lpt_sz, lpt_sz;\n\tint err = 0;\n\n\tif (!dbg_is_chk_lprops(c))\n\t\treturn 0;\n\n\tswitch (action) {\n\tcase 0:\n\t\td->chk_lpt_sz = 0;\n\t\td->chk_lpt_sz2 = 0;\n\t\td->chk_lpt_lebs = 0;\n\t\td->chk_lpt_wastage = 0;\n\t\tif (c->dirty_pn_cnt > c->pnode_cnt) {\n\t\t\tubifs_err(c, \"dirty pnodes %d exceed max %d\",\n\t\t\t\t  c->dirty_pn_cnt, c->pnode_cnt);\n\t\t\terr = -EINVAL;\n\t\t}\n\t\tif (c->dirty_nn_cnt > c->nnode_cnt) {\n\t\t\tubifs_err(c, \"dirty nnodes %d exceed max %d\",\n\t\t\t\t  c->dirty_nn_cnt, c->nnode_cnt);\n\t\t\terr = -EINVAL;\n\t\t}\n\t\treturn err;\n\tcase 1:\n\t\td->chk_lpt_sz += len;\n\t\treturn 0;\n\tcase 2:\n\t\td->chk_lpt_sz += len;\n\t\td->chk_lpt_wastage += len;\n\t\td->chk_lpt_lebs += 1;\n\t\treturn 0;\n\tcase 3:\n\t\tchk_lpt_sz = c->leb_size;\n\t\tchk_lpt_sz *= d->chk_lpt_lebs;\n\t\tchk_lpt_sz += len - c->nhead_offs;\n\t\tif (d->chk_lpt_sz != chk_lpt_sz) {\n\t\t\tubifs_err(c, \"LPT wrote %lld but space used was %lld\",\n\t\t\t\t  d->chk_lpt_sz, chk_lpt_sz);\n\t\t\terr = -EINVAL;\n\t\t}\n\t\tif (d->chk_lpt_sz > c->lpt_sz) {\n\t\t\tubifs_err(c, \"LPT wrote %lld but lpt_sz is %lld\",\n\t\t\t\t  d->chk_lpt_sz, c->lpt_sz);\n\t\t\terr = -EINVAL;\n\t\t}\n\t\tif (d->chk_lpt_sz2 && d->chk_lpt_sz != d->chk_lpt_sz2) {\n\t\t\tubifs_err(c, \"LPT layout size %lld but wrote %lld\",\n\t\t\t\t  d->chk_lpt_sz, d->chk_lpt_sz2);\n\t\t\terr = -EINVAL;\n\t\t}\n\t\tif (d->chk_lpt_sz2 && d->new_nhead_offs != len) {\n\t\t\tubifs_err(c, \"LPT new nhead offs: expected %d was %d\",\n\t\t\t\t  d->new_nhead_offs, len);\n\t\t\terr = -EINVAL;\n\t\t}\n\t\tlpt_sz = (long long)c->pnode_cnt * c->pnode_sz;\n\t\tlpt_sz += (long long)c->nnode_cnt * c->nnode_sz;\n\t\tlpt_sz += c->ltab_sz;\n\t\tif (c->big_lpt)\n\t\t\tlpt_sz += c->lsave_sz;\n\t\tif (d->chk_lpt_sz - d->chk_lpt_wastage > lpt_sz) {\n\t\t\tubifs_err(c, \"LPT chk_lpt_sz %lld + waste %lld exceeds %lld\",\n\t\t\t\t  d->chk_lpt_sz, d->chk_lpt_wastage, lpt_sz);\n\t\t\terr = -EINVAL;\n\t\t}\n\t\tif (err) {\n\t\t\tubifs_dump_lpt_info(c);\n\t\t\tubifs_dump_lpt_lebs(c);\n\t\t\tdump_stack();\n\t\t}\n\t\td->chk_lpt_sz2 = d->chk_lpt_sz;\n\t\td->chk_lpt_sz = 0;\n\t\td->chk_lpt_wastage = 0;\n\t\td->chk_lpt_lebs = 0;\n\t\td->new_nhead_offs = len;\n\t\treturn err;\n\tcase 4:\n\t\td->chk_lpt_sz += len;\n\t\td->chk_lpt_wastage += len;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n \nstatic void dump_lpt_leb(const struct ubifs_info *c, int lnum)\n{\n\tint err, len = c->leb_size, node_type, node_num, node_len, offs;\n\tvoid *buf, *p;\n\n\tpr_err(\"(pid %d) start dumping LEB %d\\n\", current->pid, lnum);\n\tbuf = p = __vmalloc(c->leb_size, GFP_NOFS);\n\tif (!buf) {\n\t\tubifs_err(c, \"cannot allocate memory to dump LPT\");\n\t\treturn;\n\t}\n\n\terr = ubifs_leb_read(c, lnum, buf, 0, c->leb_size, 1);\n\tif (err)\n\t\tgoto out;\n\n\twhile (1) {\n\t\toffs = c->leb_size - len;\n\t\tif (!is_a_node(c, p, len)) {\n\t\t\tint pad_len;\n\n\t\t\tpad_len = get_pad_len(c, p, len);\n\t\t\tif (pad_len) {\n\t\t\t\tpr_err(\"LEB %d:%d, pad %d bytes\\n\",\n\t\t\t\t       lnum, offs, pad_len);\n\t\t\t\tp += pad_len;\n\t\t\t\tlen -= pad_len;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (len)\n\t\t\t\tpr_err(\"LEB %d:%d, free %d bytes\\n\",\n\t\t\t\t       lnum, offs, len);\n\t\t\tbreak;\n\t\t}\n\n\t\tnode_type = get_lpt_node_type(c, p, &node_num);\n\t\tswitch (node_type) {\n\t\tcase UBIFS_LPT_PNODE:\n\t\t{\n\t\t\tnode_len = c->pnode_sz;\n\t\t\tif (c->big_lpt)\n\t\t\t\tpr_err(\"LEB %d:%d, pnode num %d\\n\",\n\t\t\t\t       lnum, offs, node_num);\n\t\t\telse\n\t\t\t\tpr_err(\"LEB %d:%d, pnode\\n\", lnum, offs);\n\t\t\tbreak;\n\t\t}\n\t\tcase UBIFS_LPT_NNODE:\n\t\t{\n\t\t\tint i;\n\t\t\tstruct ubifs_nnode nnode;\n\n\t\t\tnode_len = c->nnode_sz;\n\t\t\tif (c->big_lpt)\n\t\t\t\tpr_err(\"LEB %d:%d, nnode num %d, \",\n\t\t\t\t       lnum, offs, node_num);\n\t\t\telse\n\t\t\t\tpr_err(\"LEB %d:%d, nnode, \",\n\t\t\t\t       lnum, offs);\n\t\t\terr = ubifs_unpack_nnode(c, p, &nnode);\n\t\t\tif (err) {\n\t\t\t\tpr_err(\"failed to unpack_node, error %d\\n\",\n\t\t\t\t       err);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\n\t\t\t\tpr_cont(\"%d:%d\", nnode.nbranch[i].lnum,\n\t\t\t\t       nnode.nbranch[i].offs);\n\t\t\t\tif (i != UBIFS_LPT_FANOUT - 1)\n\t\t\t\t\tpr_cont(\", \");\n\t\t\t}\n\t\t\tpr_cont(\"\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tcase UBIFS_LPT_LTAB:\n\t\t\tnode_len = c->ltab_sz;\n\t\t\tpr_err(\"LEB %d:%d, ltab\\n\", lnum, offs);\n\t\t\tbreak;\n\t\tcase UBIFS_LPT_LSAVE:\n\t\t\tnode_len = c->lsave_sz;\n\t\t\tpr_err(\"LEB %d:%d, lsave len\\n\", lnum, offs);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tubifs_err(c, \"LPT node type %d not recognized\", node_type);\n\t\t\tgoto out;\n\t\t}\n\n\t\tp += node_len;\n\t\tlen -= node_len;\n\t}\n\n\tpr_err(\"(pid %d) finish dumping LEB %d\\n\", current->pid, lnum);\nout:\n\tvfree(buf);\n\treturn;\n}\n\n \nvoid ubifs_dump_lpt_lebs(const struct ubifs_info *c)\n{\n\tint i;\n\n\tpr_err(\"(pid %d) start dumping all LPT LEBs\\n\", current->pid);\n\tfor (i = 0; i < c->lpt_lebs; i++)\n\t\tdump_lpt_leb(c, i + c->lpt_first);\n\tpr_err(\"(pid %d) finish dumping all LPT LEBs\\n\", current->pid);\n}\n\n \nstatic int dbg_populate_lsave(struct ubifs_info *c)\n{\n\tstruct ubifs_lprops *lprops;\n\tstruct ubifs_lpt_heap *heap;\n\tint i;\n\n\tif (!dbg_is_chk_gen(c))\n\t\treturn 0;\n\tif (get_random_u32_below(4))\n\t\treturn 0;\n\n\tfor (i = 0; i < c->lsave_cnt; i++)\n\t\tc->lsave[i] = c->main_first;\n\n\tlist_for_each_entry(lprops, &c->empty_list, list)\n\t\tc->lsave[get_random_u32_below(c->lsave_cnt)] = lprops->lnum;\n\tlist_for_each_entry(lprops, &c->freeable_list, list)\n\t\tc->lsave[get_random_u32_below(c->lsave_cnt)] = lprops->lnum;\n\tlist_for_each_entry(lprops, &c->frdi_idx_list, list)\n\t\tc->lsave[get_random_u32_below(c->lsave_cnt)] = lprops->lnum;\n\n\theap = &c->lpt_heap[LPROPS_DIRTY_IDX - 1];\n\tfor (i = 0; i < heap->cnt; i++)\n\t\tc->lsave[get_random_u32_below(c->lsave_cnt)] = heap->arr[i]->lnum;\n\theap = &c->lpt_heap[LPROPS_DIRTY - 1];\n\tfor (i = 0; i < heap->cnt; i++)\n\t\tc->lsave[get_random_u32_below(c->lsave_cnt)] = heap->arr[i]->lnum;\n\theap = &c->lpt_heap[LPROPS_FREE - 1];\n\tfor (i = 0; i < heap->cnt; i++)\n\t\tc->lsave[get_random_u32_below(c->lsave_cnt)] = heap->arr[i]->lnum;\n\n\treturn 1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}