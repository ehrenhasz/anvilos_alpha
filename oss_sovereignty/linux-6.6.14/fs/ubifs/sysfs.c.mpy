{
  "module_name": "sysfs.c",
  "hash_id": "de3ad3cfd9d725595481961253bd17305682ad7c54501ef7506f6112811b54a6",
  "original_prompt": "Ingested from linux-6.6.14/fs/ubifs/sysfs.c",
  "human_readable_source": "\n \n\n\n#include <linux/fs.h>\n#include \"ubifs.h\"\n\nenum attr_id_t {\n\tattr_errors_magic,\n\tattr_errors_node,\n\tattr_errors_crc,\n};\n\nstruct ubifs_attr {\n\tstruct attribute attr;\n\tenum attr_id_t attr_id;\n};\n\n#define UBIFS_ATTR(_name, _mode, _id)\t\t\t\t\t\\\nstatic struct ubifs_attr ubifs_attr_##_name = {\t\t\t\t\\\n\t.attr = {.name = __stringify(_name), .mode = _mode },\t\t\\\n\t.attr_id = attr_##_id,\t\t\t\t\t\t\\\n}\n\n#define UBIFS_ATTR_FUNC(_name, _mode) UBIFS_ATTR(_name, _mode, _name)\n\nUBIFS_ATTR_FUNC(errors_magic, 0444);\nUBIFS_ATTR_FUNC(errors_crc, 0444);\nUBIFS_ATTR_FUNC(errors_node, 0444);\n\n#define ATTR_LIST(name) (&ubifs_attr_##name.attr)\n\nstatic struct attribute *ubifs_attrs[] = {\n\tATTR_LIST(errors_magic),\n\tATTR_LIST(errors_node),\n\tATTR_LIST(errors_crc),\n\tNULL,\n};\nATTRIBUTE_GROUPS(ubifs);\n\nstatic ssize_t ubifs_attr_show(struct kobject *kobj,\n\t\t\t       struct attribute *attr, char *buf)\n{\n\tstruct ubifs_info *sbi = container_of(kobj, struct ubifs_info,\n\t\t\t\t\t      kobj);\n\n\tstruct ubifs_attr *a = container_of(attr, struct ubifs_attr, attr);\n\n\tswitch (a->attr_id) {\n\tcase attr_errors_magic:\n\t\treturn sysfs_emit(buf, \"%u\\n\", sbi->stats->magic_errors);\n\tcase attr_errors_node:\n\t\treturn sysfs_emit(buf, \"%u\\n\", sbi->stats->node_errors);\n\tcase attr_errors_crc:\n\t\treturn sysfs_emit(buf, \"%u\\n\", sbi->stats->crc_errors);\n\t}\n\treturn 0;\n};\n\nstatic void ubifs_sb_release(struct kobject *kobj)\n{\n\tstruct ubifs_info *c = container_of(kobj, struct ubifs_info, kobj);\n\n\tcomplete(&c->kobj_unregister);\n}\n\nstatic const struct sysfs_ops ubifs_attr_ops = {\n\t.show\t= ubifs_attr_show,\n};\n\nstatic const struct kobj_type ubifs_sb_ktype = {\n\t.default_groups\t= ubifs_groups,\n\t.sysfs_ops\t= &ubifs_attr_ops,\n\t.release\t= ubifs_sb_release,\n};\n\nstatic const struct kobj_type ubifs_ktype = {\n\t.sysfs_ops\t= &ubifs_attr_ops,\n};\n\nstatic struct kset ubifs_kset = {\n\t.kobj\t= {.ktype = &ubifs_ktype},\n};\n\nint ubifs_sysfs_register(struct ubifs_info *c)\n{\n\tint ret, n;\n\tchar dfs_dir_name[UBIFS_DFS_DIR_LEN+1];\n\n\tc->stats = kzalloc(sizeof(struct ubifs_stats_info), GFP_KERNEL);\n\tif (!c->stats) {\n\t\tret = -ENOMEM;\n\t\tgoto out_last;\n\t}\n\tn = snprintf(dfs_dir_name, UBIFS_DFS_DIR_LEN + 1, UBIFS_DFS_DIR_NAME,\n\t\t     c->vi.ubi_num, c->vi.vol_id);\n\n\tif (n > UBIFS_DFS_DIR_LEN) {\n\t\t \n\t\tret = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\tc->kobj.kset = &ubifs_kset;\n\tinit_completion(&c->kobj_unregister);\n\n\tret = kobject_init_and_add(&c->kobj, &ubifs_sb_ktype, NULL,\n\t\t\t\t   \"%s\", dfs_dir_name);\n\tif (ret)\n\t\tgoto out_put;\n\n\treturn 0;\n\nout_put:\n\tkobject_put(&c->kobj);\n\twait_for_completion(&c->kobj_unregister);\nout_free:\n\tkfree(c->stats);\nout_last:\n\tubifs_err(c, \"cannot create sysfs entry for ubifs%d_%d, error %d\\n\",\n\t\t  c->vi.ubi_num, c->vi.vol_id, ret);\n\treturn ret;\n}\n\nvoid ubifs_sysfs_unregister(struct ubifs_info *c)\n{\n\tkobject_del(&c->kobj);\n\tkobject_put(&c->kobj);\n\twait_for_completion(&c->kobj_unregister);\n\n\tkfree(c->stats);\n}\n\nint __init ubifs_sysfs_init(void)\n{\n\tint ret;\n\n\tkobject_set_name(&ubifs_kset.kobj, \"ubifs\");\n\tubifs_kset.kobj.parent = fs_kobj;\n\tret = kset_register(&ubifs_kset);\n\tif (ret)\n\t\tkset_put(&ubifs_kset);\n\n\treturn ret;\n}\n\nvoid ubifs_sysfs_exit(void)\n{\n\tkset_unregister(&ubifs_kset);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}