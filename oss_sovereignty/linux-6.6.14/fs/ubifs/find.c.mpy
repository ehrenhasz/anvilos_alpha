{
  "module_name": "find.c",
  "hash_id": "17fefcd14c8a7d0eec218c794fe61a94a24642fe1d5a504bb657628b32e4b3e6",
  "original_prompt": "Ingested from linux-6.6.14/fs/ubifs/find.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/sort.h>\n#include \"ubifs.h\"\n\n \nstruct scan_data {\n\tint min_space;\n\tint pick_free;\n\tint lnum;\n\tint exclude_index;\n};\n\n \nstatic int valuable(struct ubifs_info *c, const struct ubifs_lprops *lprops)\n{\n\tint n, cat = lprops->flags & LPROPS_CAT_MASK;\n\tstruct ubifs_lpt_heap *heap;\n\n\tswitch (cat) {\n\tcase LPROPS_DIRTY:\n\tcase LPROPS_DIRTY_IDX:\n\tcase LPROPS_FREE:\n\t\theap = &c->lpt_heap[cat - 1];\n\t\tif (heap->cnt < heap->max_cnt)\n\t\t\treturn 1;\n\t\tif (lprops->free + lprops->dirty >= c->dark_wm)\n\t\t\treturn 1;\n\t\treturn 0;\n\tcase LPROPS_EMPTY:\n\t\tn = c->lst.empty_lebs + c->freeable_cnt -\n\t\t    c->lst.taken_empty_lebs;\n\t\tif (n < c->lsave_cnt)\n\t\t\treturn 1;\n\t\treturn 0;\n\tcase LPROPS_FREEABLE:\n\t\treturn 1;\n\tcase LPROPS_FRDI_IDX:\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \nstatic int scan_for_dirty_cb(struct ubifs_info *c,\n\t\t\t     const struct ubifs_lprops *lprops, int in_tree,\n\t\t\t     struct scan_data *data)\n{\n\tint ret = LPT_SCAN_CONTINUE;\n\n\t \n\tif (lprops->flags & LPROPS_TAKEN)\n\t\treturn LPT_SCAN_CONTINUE;\n\t \n\tif (!in_tree && valuable(c, lprops))\n\t\tret |= LPT_SCAN_ADD;\n\t \n\tif (lprops->free + lprops->dirty < data->min_space)\n\t\treturn ret;\n\t \n\tif (data->exclude_index && lprops->flags & LPROPS_INDEX)\n\t\treturn ret;\n\t \n\tif (lprops->free + lprops->dirty == c->leb_size) {\n\t\tif (!data->pick_free)\n\t\t\treturn ret;\n\t \n\t} else if (lprops->dirty < c->dead_wm)\n\t\treturn ret;\n\t \n\tdata->lnum = lprops->lnum;\n\treturn LPT_SCAN_ADD | LPT_SCAN_STOP;\n}\n\n \nstatic const struct ubifs_lprops *scan_for_dirty(struct ubifs_info *c,\n\t\t\t\t\t\t int min_space, int pick_free,\n\t\t\t\t\t\t int exclude_index)\n{\n\tconst struct ubifs_lprops *lprops;\n\tstruct ubifs_lpt_heap *heap;\n\tstruct scan_data data;\n\tint err, i;\n\n\t \n\theap = &c->lpt_heap[LPROPS_FREE - 1];\n\tfor (i = 0; i < heap->cnt; i++) {\n\t\tlprops = heap->arr[i];\n\t\tif (lprops->free + lprops->dirty < min_space)\n\t\t\tcontinue;\n\t\tif (lprops->dirty < c->dead_wm)\n\t\t\tcontinue;\n\t\treturn lprops;\n\t}\n\t \n\tlist_for_each_entry(lprops, &c->uncat_list, list) {\n\t\tif (lprops->flags & LPROPS_TAKEN)\n\t\t\tcontinue;\n\t\tif (lprops->free + lprops->dirty < min_space)\n\t\t\tcontinue;\n\t\tif (exclude_index && (lprops->flags & LPROPS_INDEX))\n\t\t\tcontinue;\n\t\tif (lprops->dirty < c->dead_wm)\n\t\t\tcontinue;\n\t\treturn lprops;\n\t}\n\t \n\tif (c->pnodes_have >= c->pnode_cnt)\n\t\t \n\t\treturn ERR_PTR(-ENOSPC);\n\tdata.min_space = min_space;\n\tdata.pick_free = pick_free;\n\tdata.lnum = -1;\n\tdata.exclude_index = exclude_index;\n\terr = ubifs_lpt_scan_nolock(c, -1, c->lscan_lnum,\n\t\t\t\t    (ubifs_lpt_scan_callback)scan_for_dirty_cb,\n\t\t\t\t    &data);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\tubifs_assert(c, data.lnum >= c->main_first && data.lnum < c->leb_cnt);\n\tc->lscan_lnum = data.lnum;\n\tlprops = ubifs_lpt_lookup_dirty(c, data.lnum);\n\tif (IS_ERR(lprops))\n\t\treturn lprops;\n\tubifs_assert(c, lprops->lnum == data.lnum);\n\tubifs_assert(c, lprops->free + lprops->dirty >= min_space);\n\tubifs_assert(c, lprops->dirty >= c->dead_wm ||\n\t\t     (pick_free &&\n\t\t      lprops->free + lprops->dirty == c->leb_size));\n\tubifs_assert(c, !(lprops->flags & LPROPS_TAKEN));\n\tubifs_assert(c, !exclude_index || !(lprops->flags & LPROPS_INDEX));\n\treturn lprops;\n}\n\n \nint ubifs_find_dirty_leb(struct ubifs_info *c, struct ubifs_lprops *ret_lp,\n\t\t\t int min_space, int pick_free)\n{\n\tint err = 0, sum, exclude_index = pick_free == 2 ? 1 : 0;\n\tconst struct ubifs_lprops *lp = NULL, *idx_lp = NULL;\n\tstruct ubifs_lpt_heap *heap, *idx_heap;\n\n\tubifs_get_lprops(c);\n\n\tif (pick_free) {\n\t\tint lebs, rsvd_idx_lebs = 0;\n\n\t\tspin_lock(&c->space_lock);\n\t\tlebs = c->lst.empty_lebs + c->idx_gc_cnt;\n\t\tlebs += c->freeable_cnt - c->lst.taken_empty_lebs;\n\n\t\t \n\t\tif (c->bi.min_idx_lebs >= c->lst.idx_lebs) {\n\t\t\trsvd_idx_lebs = c->bi.min_idx_lebs -  c->lst.idx_lebs;\n\t\t\texclude_index = 1;\n\t\t}\n\t\tspin_unlock(&c->space_lock);\n\n\t\t \n\t\tif (rsvd_idx_lebs < lebs) {\n\t\t\t \n\t\t\tlp = ubifs_fast_find_empty(c);\n\t\t\tif (lp)\n\t\t\t\tgoto found;\n\n\t\t\t \n\t\t\tlp = ubifs_fast_find_freeable(c);\n\t\t\tif (lp)\n\t\t\t\tgoto found;\n\t\t} else\n\t\t\t \n\t\t\tpick_free = 0;\n\t} else {\n\t\tspin_lock(&c->space_lock);\n\t\texclude_index = (c->bi.min_idx_lebs >= c->lst.idx_lebs);\n\t\tspin_unlock(&c->space_lock);\n\t}\n\n\t \n\theap = &c->lpt_heap[LPROPS_DIRTY - 1];\n\tidx_heap = &c->lpt_heap[LPROPS_DIRTY_IDX - 1];\n\n\tif (idx_heap->cnt && !exclude_index) {\n\t\tidx_lp = idx_heap->arr[0];\n\t\tsum = idx_lp->free + idx_lp->dirty;\n\t\t \n\t\tif (sum < min_space || sum < c->half_leb_size)\n\t\t\tidx_lp = NULL;\n\t}\n\n\tif (heap->cnt) {\n\t\tlp = heap->arr[0];\n\t\tif (lp->dirty + lp->free < min_space)\n\t\t\tlp = NULL;\n\t}\n\n\t \n\tif (idx_lp && lp) {\n\t\tif (idx_lp->free + idx_lp->dirty >= lp->free + lp->dirty)\n\t\t\tlp = idx_lp;\n\t} else if (idx_lp && !lp)\n\t\tlp = idx_lp;\n\n\tif (lp) {\n\t\tubifs_assert(c, lp->free + lp->dirty >= c->dead_wm);\n\t\tgoto found;\n\t}\n\n\t \n\tdbg_find(\"scanning LPT for a dirty LEB\");\n\tlp = scan_for_dirty(c, min_space, pick_free, exclude_index);\n\tif (IS_ERR(lp)) {\n\t\terr = PTR_ERR(lp);\n\t\tgoto out;\n\t}\n\tubifs_assert(c, lp->dirty >= c->dead_wm ||\n\t\t     (pick_free && lp->free + lp->dirty == c->leb_size));\n\nfound:\n\tdbg_find(\"found LEB %d, free %d, dirty %d, flags %#x\",\n\t\t lp->lnum, lp->free, lp->dirty, lp->flags);\n\n\tlp = ubifs_change_lp(c, lp, LPROPS_NC, LPROPS_NC,\n\t\t\t     lp->flags | LPROPS_TAKEN, 0);\n\tif (IS_ERR(lp)) {\n\t\terr = PTR_ERR(lp);\n\t\tgoto out;\n\t}\n\n\tmemcpy(ret_lp, lp, sizeof(struct ubifs_lprops));\n\nout:\n\tubifs_release_lprops(c);\n\treturn err;\n}\n\n \nstatic int scan_for_free_cb(struct ubifs_info *c,\n\t\t\t    const struct ubifs_lprops *lprops, int in_tree,\n\t\t\t    struct scan_data *data)\n{\n\tint ret = LPT_SCAN_CONTINUE;\n\n\t \n\tif (lprops->flags & LPROPS_TAKEN)\n\t\treturn LPT_SCAN_CONTINUE;\n\t \n\tif (!in_tree && valuable(c, lprops))\n\t\tret |= LPT_SCAN_ADD;\n\t \n\tif (lprops->flags & LPROPS_INDEX)\n\t\treturn ret;\n\t \n\tif (lprops->free < data->min_space)\n\t\treturn ret;\n\t \n\tif (!data->pick_free && lprops->free == c->leb_size)\n\t\treturn ret;\n\t \n\tif (lprops->free + lprops->dirty == c->leb_size && lprops->dirty > 0)\n\t\treturn ret;\n\t \n\tdata->lnum = lprops->lnum;\n\treturn LPT_SCAN_ADD | LPT_SCAN_STOP;\n}\n\n \nstatic\nconst struct ubifs_lprops *do_find_free_space(struct ubifs_info *c,\n\t\t\t\t\t      int min_space, int pick_free,\n\t\t\t\t\t      int squeeze)\n{\n\tconst struct ubifs_lprops *lprops;\n\tstruct ubifs_lpt_heap *heap;\n\tstruct scan_data data;\n\tint err, i;\n\n\tif (squeeze) {\n\t\tlprops = ubifs_fast_find_free(c);\n\t\tif (lprops && lprops->free >= min_space)\n\t\t\treturn lprops;\n\t}\n\tif (pick_free) {\n\t\tlprops = ubifs_fast_find_empty(c);\n\t\tif (lprops)\n\t\t\treturn lprops;\n\t}\n\tif (!squeeze) {\n\t\tlprops = ubifs_fast_find_free(c);\n\t\tif (lprops && lprops->free >= min_space)\n\t\t\treturn lprops;\n\t}\n\t \n\theap = &c->lpt_heap[LPROPS_DIRTY - 1];\n\tfor (i = 0; i < heap->cnt; i++) {\n\t\tlprops = heap->arr[i];\n\t\tif (lprops->free >= min_space)\n\t\t\treturn lprops;\n\t}\n\t \n\tlist_for_each_entry(lprops, &c->uncat_list, list) {\n\t\tif (lprops->flags & LPROPS_TAKEN)\n\t\t\tcontinue;\n\t\tif (lprops->flags & LPROPS_INDEX)\n\t\t\tcontinue;\n\t\tif (lprops->free >= min_space)\n\t\t\treturn lprops;\n\t}\n\t \n\tif (c->pnodes_have >= c->pnode_cnt)\n\t\t \n\t\treturn ERR_PTR(-ENOSPC);\n\tdata.min_space = min_space;\n\tdata.pick_free = pick_free;\n\tdata.lnum = -1;\n\terr = ubifs_lpt_scan_nolock(c, -1, c->lscan_lnum,\n\t\t\t\t    (ubifs_lpt_scan_callback)scan_for_free_cb,\n\t\t\t\t    &data);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\tubifs_assert(c, data.lnum >= c->main_first && data.lnum < c->leb_cnt);\n\tc->lscan_lnum = data.lnum;\n\tlprops = ubifs_lpt_lookup_dirty(c, data.lnum);\n\tif (IS_ERR(lprops))\n\t\treturn lprops;\n\tubifs_assert(c, lprops->lnum == data.lnum);\n\tubifs_assert(c, lprops->free >= min_space);\n\tubifs_assert(c, !(lprops->flags & LPROPS_TAKEN));\n\tubifs_assert(c, !(lprops->flags & LPROPS_INDEX));\n\treturn lprops;\n}\n\n \nint ubifs_find_free_space(struct ubifs_info *c, int min_space, int *offs,\n\t\t\t  int squeeze)\n{\n\tconst struct ubifs_lprops *lprops;\n\tint lebs, rsvd_idx_lebs, pick_free = 0, err, lnum, flags;\n\n\tdbg_find(\"min_space %d\", min_space);\n\tubifs_get_lprops(c);\n\n\t \n\tspin_lock(&c->space_lock);\n\tif (c->bi.min_idx_lebs > c->lst.idx_lebs)\n\t\trsvd_idx_lebs = c->bi.min_idx_lebs -  c->lst.idx_lebs;\n\telse\n\t\trsvd_idx_lebs = 0;\n\tlebs = c->lst.empty_lebs + c->freeable_cnt + c->idx_gc_cnt -\n\t       c->lst.taken_empty_lebs;\n\tif (rsvd_idx_lebs < lebs)\n\t\t \n\t\tif (c->lst.empty_lebs - c->lst.taken_empty_lebs > 0) {\n\t\t\tpick_free = 1;\n\t\t\t \n\t\t\tc->lst.taken_empty_lebs += 1;\n\t\t}\n\tspin_unlock(&c->space_lock);\n\n\tlprops = do_find_free_space(c, min_space, pick_free, squeeze);\n\tif (IS_ERR(lprops)) {\n\t\terr = PTR_ERR(lprops);\n\t\tgoto out;\n\t}\n\n\tlnum = lprops->lnum;\n\tflags = lprops->flags | LPROPS_TAKEN;\n\n\tlprops = ubifs_change_lp(c, lprops, LPROPS_NC, LPROPS_NC, flags, 0);\n\tif (IS_ERR(lprops)) {\n\t\terr = PTR_ERR(lprops);\n\t\tgoto out;\n\t}\n\n\tif (pick_free) {\n\t\tspin_lock(&c->space_lock);\n\t\tc->lst.taken_empty_lebs -= 1;\n\t\tspin_unlock(&c->space_lock);\n\t}\n\n\t*offs = c->leb_size - lprops->free;\n\tubifs_release_lprops(c);\n\n\tif (*offs == 0) {\n\t\t \n\t\terr = ubifs_leb_unmap(c, lnum);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tdbg_find(\"found LEB %d, free %d\", lnum, c->leb_size - *offs);\n\tubifs_assert(c, *offs <= c->leb_size - min_space);\n\treturn lnum;\n\nout:\n\tif (pick_free) {\n\t\tspin_lock(&c->space_lock);\n\t\tc->lst.taken_empty_lebs -= 1;\n\t\tspin_unlock(&c->space_lock);\n\t}\n\tubifs_release_lprops(c);\n\treturn err;\n}\n\n \nstatic int scan_for_idx_cb(struct ubifs_info *c,\n\t\t\t   const struct ubifs_lprops *lprops, int in_tree,\n\t\t\t   struct scan_data *data)\n{\n\tint ret = LPT_SCAN_CONTINUE;\n\n\t \n\tif (lprops->flags & LPROPS_TAKEN)\n\t\treturn LPT_SCAN_CONTINUE;\n\t \n\tif (!in_tree && valuable(c, lprops))\n\t\tret |= LPT_SCAN_ADD;\n\t \n\tif (lprops->flags & LPROPS_INDEX)\n\t\treturn ret;\n\t \n\tif (lprops->free + lprops->dirty != c->leb_size)\n\t\treturn ret;\n\t \n\tdata->lnum = lprops->lnum;\n\treturn LPT_SCAN_ADD | LPT_SCAN_STOP;\n}\n\n \nstatic const struct ubifs_lprops *scan_for_leb_for_idx(struct ubifs_info *c)\n{\n\tconst struct ubifs_lprops *lprops;\n\tstruct scan_data data;\n\tint err;\n\n\tdata.lnum = -1;\n\terr = ubifs_lpt_scan_nolock(c, -1, c->lscan_lnum,\n\t\t\t\t    (ubifs_lpt_scan_callback)scan_for_idx_cb,\n\t\t\t\t    &data);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\tubifs_assert(c, data.lnum >= c->main_first && data.lnum < c->leb_cnt);\n\tc->lscan_lnum = data.lnum;\n\tlprops = ubifs_lpt_lookup_dirty(c, data.lnum);\n\tif (IS_ERR(lprops))\n\t\treturn lprops;\n\tubifs_assert(c, lprops->lnum == data.lnum);\n\tubifs_assert(c, lprops->free + lprops->dirty == c->leb_size);\n\tubifs_assert(c, !(lprops->flags & LPROPS_TAKEN));\n\tubifs_assert(c, !(lprops->flags & LPROPS_INDEX));\n\treturn lprops;\n}\n\n \nint ubifs_find_free_leb_for_idx(struct ubifs_info *c)\n{\n\tconst struct ubifs_lprops *lprops;\n\tint lnum = -1, err, flags;\n\n\tubifs_get_lprops(c);\n\n\tlprops = ubifs_fast_find_empty(c);\n\tif (!lprops) {\n\t\tlprops = ubifs_fast_find_freeable(c);\n\t\tif (!lprops) {\n\t\t\t \n\t\t\tif (c->in_a_category_cnt != c->main_lebs ||\n\t\t\t    c->lst.empty_lebs - c->lst.taken_empty_lebs > 0) {\n\t\t\t\tubifs_assert(c, c->freeable_cnt == 0);\n\t\t\t\tlprops = scan_for_leb_for_idx(c);\n\t\t\t\tif (IS_ERR(lprops)) {\n\t\t\t\t\terr = PTR_ERR(lprops);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!lprops) {\n\t\terr = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\tlnum = lprops->lnum;\n\n\tdbg_find(\"found LEB %d, free %d, dirty %d, flags %#x\",\n\t\t lnum, lprops->free, lprops->dirty, lprops->flags);\n\n\tflags = lprops->flags | LPROPS_TAKEN | LPROPS_INDEX;\n\tlprops = ubifs_change_lp(c, lprops, c->leb_size, 0, flags, 0);\n\tif (IS_ERR(lprops)) {\n\t\terr = PTR_ERR(lprops);\n\t\tgoto out;\n\t}\n\n\tubifs_release_lprops(c);\n\n\t \n\terr = ubifs_leb_unmap(c, lnum);\n\tif (err) {\n\t\tubifs_change_one_lp(c, lnum, LPROPS_NC, LPROPS_NC, 0,\n\t\t\t\t    LPROPS_TAKEN | LPROPS_INDEX, 0);\n\t\treturn err;\n\t}\n\n\treturn lnum;\n\nout:\n\tubifs_release_lprops(c);\n\treturn err;\n}\n\nstatic int cmp_dirty_idx(const struct ubifs_lprops **a,\n\t\t\t const struct ubifs_lprops **b)\n{\n\tconst struct ubifs_lprops *lpa = *a;\n\tconst struct ubifs_lprops *lpb = *b;\n\n\treturn lpa->dirty + lpa->free - lpb->dirty - lpb->free;\n}\n\n \nint ubifs_save_dirty_idx_lnums(struct ubifs_info *c)\n{\n\tint i;\n\n\tubifs_get_lprops(c);\n\t \n\tc->dirty_idx.cnt = c->lpt_heap[LPROPS_DIRTY_IDX - 1].cnt;\n\tmemcpy(c->dirty_idx.arr, c->lpt_heap[LPROPS_DIRTY_IDX - 1].arr,\n\t       sizeof(void *) * c->dirty_idx.cnt);\n\t \n\tsort(c->dirty_idx.arr, c->dirty_idx.cnt, sizeof(void *),\n\t     (int (*)(const void *, const void *))cmp_dirty_idx, NULL);\n\tdbg_find(\"found %d dirty index LEBs\", c->dirty_idx.cnt);\n\tif (c->dirty_idx.cnt)\n\t\tdbg_find(\"dirtiest index LEB is %d with dirty %d and free %d\",\n\t\t\t c->dirty_idx.arr[c->dirty_idx.cnt - 1]->lnum,\n\t\t\t c->dirty_idx.arr[c->dirty_idx.cnt - 1]->dirty,\n\t\t\t c->dirty_idx.arr[c->dirty_idx.cnt - 1]->free);\n\t \n\tfor (i = 0; i < c->dirty_idx.cnt; i++)\n\t\tc->dirty_idx.arr[i] = (void *)(size_t)c->dirty_idx.arr[i]->lnum;\n\tubifs_release_lprops(c);\n\treturn 0;\n}\n\n \nstatic int scan_dirty_idx_cb(struct ubifs_info *c,\n\t\t\t   const struct ubifs_lprops *lprops, int in_tree,\n\t\t\t   struct scan_data *data)\n{\n\tint ret = LPT_SCAN_CONTINUE;\n\n\t \n\tif (lprops->flags & LPROPS_TAKEN)\n\t\treturn LPT_SCAN_CONTINUE;\n\t \n\tif (!in_tree && valuable(c, lprops))\n\t\tret |= LPT_SCAN_ADD;\n\t \n\tif (!(lprops->flags & LPROPS_INDEX))\n\t\treturn ret;\n\t \n\tif (lprops->free + lprops->dirty < c->min_idx_node_sz)\n\t\treturn ret;\n\t \n\tdata->lnum = lprops->lnum;\n\treturn LPT_SCAN_ADD | LPT_SCAN_STOP;\n}\n\n \nstatic int find_dirty_idx_leb(struct ubifs_info *c)\n{\n\tconst struct ubifs_lprops *lprops;\n\tstruct ubifs_lpt_heap *heap;\n\tstruct scan_data data;\n\tint err, i, ret;\n\n\t \n\tdata.lnum = -1;\n\theap = &c->lpt_heap[LPROPS_DIRTY_IDX - 1];\n\tfor (i = 0; i < heap->cnt; i++) {\n\t\tlprops = heap->arr[i];\n\t\tret = scan_dirty_idx_cb(c, lprops, 1, &data);\n\t\tif (ret & LPT_SCAN_STOP)\n\t\t\tgoto found;\n\t}\n\tlist_for_each_entry(lprops, &c->frdi_idx_list, list) {\n\t\tret = scan_dirty_idx_cb(c, lprops, 1, &data);\n\t\tif (ret & LPT_SCAN_STOP)\n\t\t\tgoto found;\n\t}\n\tlist_for_each_entry(lprops, &c->uncat_list, list) {\n\t\tret = scan_dirty_idx_cb(c, lprops, 1, &data);\n\t\tif (ret & LPT_SCAN_STOP)\n\t\t\tgoto found;\n\t}\n\tif (c->pnodes_have >= c->pnode_cnt)\n\t\t \n\t\treturn -ENOSPC;\n\terr = ubifs_lpt_scan_nolock(c, -1, c->lscan_lnum,\n\t\t\t\t    (ubifs_lpt_scan_callback)scan_dirty_idx_cb,\n\t\t\t\t    &data);\n\tif (err)\n\t\treturn err;\nfound:\n\tubifs_assert(c, data.lnum >= c->main_first && data.lnum < c->leb_cnt);\n\tc->lscan_lnum = data.lnum;\n\tlprops = ubifs_lpt_lookup_dirty(c, data.lnum);\n\tif (IS_ERR(lprops))\n\t\treturn PTR_ERR(lprops);\n\tubifs_assert(c, lprops->lnum == data.lnum);\n\tubifs_assert(c, lprops->free + lprops->dirty >= c->min_idx_node_sz);\n\tubifs_assert(c, !(lprops->flags & LPROPS_TAKEN));\n\tubifs_assert(c, (lprops->flags & LPROPS_INDEX));\n\n\tdbg_find(\"found dirty LEB %d, free %d, dirty %d, flags %#x\",\n\t\t lprops->lnum, lprops->free, lprops->dirty, lprops->flags);\n\n\tlprops = ubifs_change_lp(c, lprops, LPROPS_NC, LPROPS_NC,\n\t\t\t\t lprops->flags | LPROPS_TAKEN, 0);\n\tif (IS_ERR(lprops))\n\t\treturn PTR_ERR(lprops);\n\n\treturn lprops->lnum;\n}\n\n \nstatic int get_idx_gc_leb(struct ubifs_info *c)\n{\n\tconst struct ubifs_lprops *lp;\n\tint err, lnum;\n\n\terr = ubifs_get_idx_gc_leb(c);\n\tif (err < 0)\n\t\treturn err;\n\tlnum = err;\n\t \n\tlp = ubifs_lpt_lookup_dirty(c, lnum);\n\tif (IS_ERR(lp))\n\t\treturn PTR_ERR(lp);\n\tlp = ubifs_change_lp(c, lp, LPROPS_NC, LPROPS_NC,\n\t\t\t     lp->flags | LPROPS_INDEX, -1);\n\tif (IS_ERR(lp))\n\t\treturn PTR_ERR(lp);\n\tdbg_find(\"LEB %d, dirty %d and free %d flags %#x\",\n\t\t lp->lnum, lp->dirty, lp->free, lp->flags);\n\treturn lnum;\n}\n\n \nstatic int find_dirtiest_idx_leb(struct ubifs_info *c)\n{\n\tconst struct ubifs_lprops *lp;\n\tint lnum;\n\n\twhile (1) {\n\t\tif (!c->dirty_idx.cnt)\n\t\t\treturn -ENOSPC;\n\t\t \n\t\tlnum = (size_t)c->dirty_idx.arr[--c->dirty_idx.cnt];\n\t\tlp = ubifs_lpt_lookup(c, lnum);\n\t\tif (IS_ERR(lp))\n\t\t\treturn PTR_ERR(lp);\n\t\tif ((lp->flags & LPROPS_TAKEN) || !(lp->flags & LPROPS_INDEX))\n\t\t\tcontinue;\n\t\tlp = ubifs_change_lp(c, lp, LPROPS_NC, LPROPS_NC,\n\t\t\t\t     lp->flags | LPROPS_TAKEN, 0);\n\t\tif (IS_ERR(lp))\n\t\t\treturn PTR_ERR(lp);\n\t\tbreak;\n\t}\n\tdbg_find(\"LEB %d, dirty %d and free %d flags %#x\", lp->lnum, lp->dirty,\n\t\t lp->free, lp->flags);\n\tubifs_assert(c, lp->flags & LPROPS_TAKEN);\n\tubifs_assert(c, lp->flags & LPROPS_INDEX);\n\treturn lnum;\n}\n\n \nint ubifs_find_dirty_idx_leb(struct ubifs_info *c)\n{\n\tint err;\n\n\tubifs_get_lprops(c);\n\n\t \n\terr = find_dirtiest_idx_leb(c);\n\n\t \n\tif (err == -ENOSPC)\n\t\terr = find_dirty_idx_leb(c);\n\n\t \n\tif (err == -ENOSPC)\n\t\terr = get_idx_gc_leb(c);\n\n\tubifs_release_lprops(c);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}