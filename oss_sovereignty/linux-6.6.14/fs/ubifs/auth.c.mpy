{
  "module_name": "auth.c",
  "hash_id": "cc1e07ec5710d62f2d18a3973a26a6752316499dc3512aa48d9dda4fb9a3332d",
  "original_prompt": "Ingested from linux-6.6.14/fs/ubifs/auth.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/crypto.h>\n#include <linux/verification.h>\n#include <crypto/hash.h>\n#include <crypto/algapi.h>\n#include <keys/user-type.h>\n#include <keys/asymmetric-type.h>\n\n#include \"ubifs.h\"\n\n \nint __ubifs_node_calc_hash(const struct ubifs_info *c, const void *node,\n\t\t\t    u8 *hash)\n{\n\tconst struct ubifs_ch *ch = node;\n\n\treturn crypto_shash_tfm_digest(c->hash_tfm, node, le32_to_cpu(ch->len),\n\t\t\t\t       hash);\n}\n\n \nstatic int ubifs_hash_calc_hmac(const struct ubifs_info *c, const u8 *hash,\n\t\t\t\t u8 *hmac)\n{\n\treturn crypto_shash_tfm_digest(c->hmac_tfm, hash, c->hash_len, hmac);\n}\n\n \nint ubifs_prepare_auth_node(struct ubifs_info *c, void *node,\n\t\t\t     struct shash_desc *inhash)\n{\n\tstruct ubifs_auth_node *auth = node;\n\tu8 hash[UBIFS_HASH_ARR_SZ];\n\tint err;\n\n\t{\n\t\tSHASH_DESC_ON_STACK(hash_desc, c->hash_tfm);\n\n\t\thash_desc->tfm = c->hash_tfm;\n\t\tubifs_shash_copy_state(c, inhash, hash_desc);\n\n\t\terr = crypto_shash_final(hash_desc, hash);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = ubifs_hash_calc_hmac(c, hash, auth->hmac);\n\tif (err)\n\t\treturn err;\n\n\tauth->ch.node_type = UBIFS_AUTH_NODE;\n\tubifs_prepare_node(c, auth, ubifs_auth_node_sz(c), 0);\n\treturn 0;\n}\n\nstatic struct shash_desc *ubifs_get_desc(const struct ubifs_info *c,\n\t\t\t\t\t struct crypto_shash *tfm)\n{\n\tstruct shash_desc *desc;\n\tint err;\n\n\tif (!ubifs_authenticated(c))\n\t\treturn NULL;\n\n\tdesc = kmalloc(sizeof(*desc) + crypto_shash_descsize(tfm), GFP_KERNEL);\n\tif (!desc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdesc->tfm = tfm;\n\n\terr = crypto_shash_init(desc);\n\tif (err) {\n\t\tkfree(desc);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn desc;\n}\n\n \nstruct shash_desc *__ubifs_hash_get_desc(const struct ubifs_info *c)\n{\n\treturn ubifs_get_desc(c, c->hash_tfm);\n}\n\n \nvoid ubifs_bad_hash(const struct ubifs_info *c, const void *node, const u8 *hash,\n\t\t    int lnum, int offs)\n{\n\tint len = min(c->hash_len, 20);\n\tint cropped = len != c->hash_len;\n\tconst char *cont = cropped ? \"...\" : \"\";\n\n\tu8 calc[UBIFS_HASH_ARR_SZ];\n\n\t__ubifs_node_calc_hash(c, node, calc);\n\n\tubifs_err(c, \"hash mismatch on node at LEB %d:%d\", lnum, offs);\n\tubifs_err(c, \"hash expected:   %*ph%s\", len, hash, cont);\n\tubifs_err(c, \"hash calculated: %*ph%s\", len, calc, cont);\n}\n\n \nint __ubifs_node_check_hash(const struct ubifs_info *c, const void *node,\n\t\t\t    const u8 *expected)\n{\n\tu8 calc[UBIFS_HASH_ARR_SZ];\n\tint err;\n\n\terr = __ubifs_node_calc_hash(c, node, calc);\n\tif (err)\n\t\treturn err;\n\n\tif (ubifs_check_hash(c, expected, calc))\n\t\treturn -EPERM;\n\n\treturn 0;\n}\n\n \nint ubifs_sb_verify_signature(struct ubifs_info *c,\n\t\t\t      const struct ubifs_sb_node *sup)\n{\n\tint err;\n\tstruct ubifs_scan_leb *sleb;\n\tstruct ubifs_scan_node *snod;\n\tconst struct ubifs_sig_node *signode;\n\n\tsleb = ubifs_scan(c, UBIFS_SB_LNUM, UBIFS_SB_NODE_SZ, c->sbuf, 0);\n\tif (IS_ERR(sleb)) {\n\t\terr = PTR_ERR(sleb);\n\t\treturn err;\n\t}\n\n\tif (sleb->nodes_cnt == 0) {\n\t\tubifs_err(c, \"Unable to find signature node\");\n\t\terr = -EINVAL;\n\t\tgoto out_destroy;\n\t}\n\n\tsnod = list_first_entry(&sleb->nodes, struct ubifs_scan_node, list);\n\n\tif (snod->type != UBIFS_SIG_NODE) {\n\t\tubifs_err(c, \"Signature node is of wrong type\");\n\t\terr = -EINVAL;\n\t\tgoto out_destroy;\n\t}\n\n\tsignode = snod->node;\n\n\tif (le32_to_cpu(signode->len) > snod->len + sizeof(struct ubifs_sig_node)) {\n\t\tubifs_err(c, \"invalid signature len %d\", le32_to_cpu(signode->len));\n\t\terr = -EINVAL;\n\t\tgoto out_destroy;\n\t}\n\n\tif (le32_to_cpu(signode->type) != UBIFS_SIGNATURE_TYPE_PKCS7) {\n\t\tubifs_err(c, \"Signature type %d is not supported\\n\",\n\t\t\t  le32_to_cpu(signode->type));\n\t\terr = -EINVAL;\n\t\tgoto out_destroy;\n\t}\n\n\terr = verify_pkcs7_signature(sup, sizeof(struct ubifs_sb_node),\n\t\t\t\t     signode->sig, le32_to_cpu(signode->len),\n\t\t\t\t     NULL, VERIFYING_UNSPECIFIED_SIGNATURE,\n\t\t\t\t     NULL, NULL);\n\n\tif (err)\n\t\tubifs_err(c, \"Failed to verify signature\");\n\telse\n\t\tubifs_msg(c, \"Successfully verified super block signature\");\n\nout_destroy:\n\tubifs_scan_destroy(sleb);\n\n\treturn err;\n}\n\n \nint ubifs_init_authentication(struct ubifs_info *c)\n{\n\tstruct key *keyring_key;\n\tconst struct user_key_payload *ukp;\n\tint err;\n\tchar hmac_name[CRYPTO_MAX_ALG_NAME];\n\n\tif (!c->auth_hash_name) {\n\t\tubifs_err(c, \"authentication hash name needed with authentication\");\n\t\treturn -EINVAL;\n\t}\n\n\tc->auth_hash_algo = match_string(hash_algo_name, HASH_ALGO__LAST,\n\t\t\t\t\t c->auth_hash_name);\n\tif ((int)c->auth_hash_algo < 0) {\n\t\tubifs_err(c, \"Unknown hash algo %s specified\",\n\t\t\t  c->auth_hash_name);\n\t\treturn -EINVAL;\n\t}\n\n\tsnprintf(hmac_name, CRYPTO_MAX_ALG_NAME, \"hmac(%s)\",\n\t\t c->auth_hash_name);\n\n\tkeyring_key = request_key(&key_type_logon, c->auth_key_name, NULL);\n\n\tif (IS_ERR(keyring_key)) {\n\t\tubifs_err(c, \"Failed to request key: %ld\",\n\t\t\t  PTR_ERR(keyring_key));\n\t\treturn PTR_ERR(keyring_key);\n\t}\n\n\tdown_read(&keyring_key->sem);\n\n\tif (keyring_key->type != &key_type_logon) {\n\t\tubifs_err(c, \"key type must be logon\");\n\t\terr = -ENOKEY;\n\t\tgoto out;\n\t}\n\n\tukp = user_key_payload_locked(keyring_key);\n\tif (!ukp) {\n\t\t \n\t\terr = -EKEYREVOKED;\n\t\tgoto out;\n\t}\n\n\tc->hash_tfm = crypto_alloc_shash(c->auth_hash_name, 0, 0);\n\tif (IS_ERR(c->hash_tfm)) {\n\t\terr = PTR_ERR(c->hash_tfm);\n\t\tubifs_err(c, \"Can not allocate %s: %d\",\n\t\t\t  c->auth_hash_name, err);\n\t\tgoto out;\n\t}\n\n\tc->hash_len = crypto_shash_digestsize(c->hash_tfm);\n\tif (c->hash_len > UBIFS_HASH_ARR_SZ) {\n\t\tubifs_err(c, \"hash %s is bigger than maximum allowed hash size (%d > %d)\",\n\t\t\t  c->auth_hash_name, c->hash_len, UBIFS_HASH_ARR_SZ);\n\t\terr = -EINVAL;\n\t\tgoto out_free_hash;\n\t}\n\n\tc->hmac_tfm = crypto_alloc_shash(hmac_name, 0, 0);\n\tif (IS_ERR(c->hmac_tfm)) {\n\t\terr = PTR_ERR(c->hmac_tfm);\n\t\tubifs_err(c, \"Can not allocate %s: %d\", hmac_name, err);\n\t\tgoto out_free_hash;\n\t}\n\n\tc->hmac_desc_len = crypto_shash_digestsize(c->hmac_tfm);\n\tif (c->hmac_desc_len > UBIFS_HMAC_ARR_SZ) {\n\t\tubifs_err(c, \"hmac %s is bigger than maximum allowed hmac size (%d > %d)\",\n\t\t\t  hmac_name, c->hmac_desc_len, UBIFS_HMAC_ARR_SZ);\n\t\terr = -EINVAL;\n\t\tgoto out_free_hmac;\n\t}\n\n\terr = crypto_shash_setkey(c->hmac_tfm, ukp->data, ukp->datalen);\n\tif (err)\n\t\tgoto out_free_hmac;\n\n\tc->authenticated = true;\n\n\tc->log_hash = ubifs_hash_get_desc(c);\n\tif (IS_ERR(c->log_hash)) {\n\t\terr = PTR_ERR(c->log_hash);\n\t\tgoto out_free_hmac;\n\t}\n\n\terr = 0;\n\nout_free_hmac:\n\tif (err)\n\t\tcrypto_free_shash(c->hmac_tfm);\nout_free_hash:\n\tif (err)\n\t\tcrypto_free_shash(c->hash_tfm);\nout:\n\tup_read(&keyring_key->sem);\n\tkey_put(keyring_key);\n\n\treturn err;\n}\n\n \nvoid __ubifs_exit_authentication(struct ubifs_info *c)\n{\n\tif (!ubifs_authenticated(c))\n\t\treturn;\n\n\tcrypto_free_shash(c->hmac_tfm);\n\tcrypto_free_shash(c->hash_tfm);\n\tkfree(c->log_hash);\n}\n\n \nstatic int ubifs_node_calc_hmac(const struct ubifs_info *c, const void *node,\n\t\t\t\tint len, int ofs_hmac, void *hmac)\n{\n\tSHASH_DESC_ON_STACK(shash, c->hmac_tfm);\n\tint hmac_len = c->hmac_desc_len;\n\tint err;\n\n\tubifs_assert(c, ofs_hmac > 8);\n\tubifs_assert(c, ofs_hmac + hmac_len < len);\n\n\tshash->tfm = c->hmac_tfm;\n\n\terr = crypto_shash_init(shash);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = crypto_shash_update(shash, node + 8, ofs_hmac - 8);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tif (len - ofs_hmac - hmac_len > 0) {\n\t\terr = crypto_shash_update(shash, node + ofs_hmac + hmac_len,\n\t\t\t    len - ofs_hmac - hmac_len);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn crypto_shash_final(shash, hmac);\n}\n\n \nint __ubifs_node_insert_hmac(const struct ubifs_info *c, void *node, int len,\n\t\t\t    int ofs_hmac)\n{\n\treturn ubifs_node_calc_hmac(c, node, len, ofs_hmac, node + ofs_hmac);\n}\n\n \nint __ubifs_node_verify_hmac(const struct ubifs_info *c, const void *node,\n\t\t\t     int len, int ofs_hmac)\n{\n\tint hmac_len = c->hmac_desc_len;\n\tu8 *hmac;\n\tint err;\n\n\thmac = kmalloc(hmac_len, GFP_NOFS);\n\tif (!hmac)\n\t\treturn -ENOMEM;\n\n\terr = ubifs_node_calc_hmac(c, node, len, ofs_hmac, hmac);\n\tif (err) {\n\t\tkfree(hmac);\n\t\treturn err;\n\t}\n\n\terr = crypto_memneq(hmac, node + ofs_hmac, hmac_len);\n\n\tkfree(hmac);\n\n\tif (!err)\n\t\treturn 0;\n\n\treturn -EPERM;\n}\n\nint __ubifs_shash_copy_state(const struct ubifs_info *c, struct shash_desc *src,\n\t\t\t     struct shash_desc *target)\n{\n\tu8 *state;\n\tint err;\n\n\tstate = kmalloc(crypto_shash_descsize(src->tfm), GFP_NOFS);\n\tif (!state)\n\t\treturn -ENOMEM;\n\n\terr = crypto_shash_export(src, state);\n\tif (err)\n\t\tgoto out;\n\n\terr = crypto_shash_import(target, state);\n\nout:\n\tkfree(state);\n\n\treturn err;\n}\n\n \nint ubifs_hmac_wkm(struct ubifs_info *c, u8 *hmac)\n{\n\tSHASH_DESC_ON_STACK(shash, c->hmac_tfm);\n\tint err;\n\tconst char well_known_message[] = \"UBIFS\";\n\n\tif (!ubifs_authenticated(c))\n\t\treturn 0;\n\n\tshash->tfm = c->hmac_tfm;\n\n\terr = crypto_shash_init(shash);\n\tif (err)\n\t\treturn err;\n\n\terr = crypto_shash_update(shash, well_known_message,\n\t\t\t\t  sizeof(well_known_message) - 1);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = crypto_shash_final(shash, hmac);\n\tif (err)\n\t\treturn err;\n\treturn 0;\n}\n\n \nbool ubifs_hmac_zero(struct ubifs_info *c, const u8 *hmac)\n{\n\treturn !memchr_inv(hmac, 0, c->hmac_desc_len);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}