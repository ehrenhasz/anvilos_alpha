{
  "module_name": "scan.c",
  "hash_id": "5531aff6269e19eeb88e41301e32ad9a0851045ffa334d4cee71728c9fa16f58",
  "original_prompt": "Ingested from linux-6.6.14/fs/ubifs/scan.c",
  "human_readable_source": "\n \n\n \n\n#include \"ubifs.h\"\n\n \nstatic int scan_padding_bytes(void *buf, int len)\n{\n\tint pad_len = 0, max_pad_len = min_t(int, UBIFS_PAD_NODE_SZ, len);\n\tuint8_t *p = buf;\n\n\tdbg_scan(\"not a node\");\n\n\twhile (pad_len < max_pad_len && *p++ == UBIFS_PADDING_BYTE)\n\t\tpad_len += 1;\n\n\tif (!pad_len || (pad_len & 7))\n\t\treturn SCANNED_GARBAGE;\n\n\tdbg_scan(\"%d padding bytes\", pad_len);\n\n\treturn pad_len;\n}\n\n \nint ubifs_scan_a_node(const struct ubifs_info *c, void *buf, int len, int lnum,\n\t\t      int offs, int quiet)\n{\n\tstruct ubifs_ch *ch = buf;\n\tuint32_t magic;\n\n\tmagic = le32_to_cpu(ch->magic);\n\n\tif (magic == 0xFFFFFFFF) {\n\t\tdbg_scan(\"hit empty space at LEB %d:%d\", lnum, offs);\n\t\treturn SCANNED_EMPTY_SPACE;\n\t}\n\n\tif (magic != UBIFS_NODE_MAGIC)\n\t\treturn scan_padding_bytes(buf, len);\n\n\tif (len < UBIFS_CH_SZ)\n\t\treturn SCANNED_GARBAGE;\n\n\tdbg_scan(\"scanning %s at LEB %d:%d\",\n\t\t dbg_ntype(ch->node_type), lnum, offs);\n\n\tif (ubifs_check_node(c, buf, len, lnum, offs, quiet, 1))\n\t\treturn SCANNED_A_CORRUPT_NODE;\n\n\tif (ch->node_type == UBIFS_PAD_NODE) {\n\t\tstruct ubifs_pad_node *pad = buf;\n\t\tint pad_len = le32_to_cpu(pad->pad_len);\n\t\tint node_len = le32_to_cpu(ch->len);\n\n\t\t \n\t\tif (pad_len < 0 ||\n\t\t    offs + node_len + pad_len > c->leb_size) {\n\t\t\tif (!quiet) {\n\t\t\t\tubifs_err(c, \"bad pad node at LEB %d:%d\",\n\t\t\t\t\t  lnum, offs);\n\t\t\t\tubifs_dump_node(c, pad, len);\n\t\t\t}\n\t\t\treturn SCANNED_A_BAD_PAD_NODE;\n\t\t}\n\n\t\t \n\t\tif ((node_len + pad_len) & 7) {\n\t\t\tif (!quiet)\n\t\t\t\tubifs_err(c, \"bad padding length %d - %d\",\n\t\t\t\t\t  offs, offs + node_len + pad_len);\n\t\t\treturn SCANNED_A_BAD_PAD_NODE;\n\t\t}\n\n\t\tdbg_scan(\"%d bytes padded at LEB %d:%d, offset now %d\", pad_len,\n\t\t\t lnum, offs, ALIGN(offs + node_len + pad_len, 8));\n\n\t\treturn node_len + pad_len;\n\t}\n\n\treturn SCANNED_A_NODE;\n}\n\n \nstruct ubifs_scan_leb *ubifs_start_scan(const struct ubifs_info *c, int lnum,\n\t\t\t\t\tint offs, void *sbuf)\n{\n\tstruct ubifs_scan_leb *sleb;\n\tint err;\n\n\tdbg_scan(\"scan LEB %d:%d\", lnum, offs);\n\n\tsleb = kzalloc(sizeof(struct ubifs_scan_leb), GFP_NOFS);\n\tif (!sleb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tsleb->lnum = lnum;\n\tINIT_LIST_HEAD(&sleb->nodes);\n\tsleb->buf = sbuf;\n\n\terr = ubifs_leb_read(c, lnum, sbuf + offs, offs, c->leb_size - offs, 0);\n\tif (err && err != -EBADMSG) {\n\t\tubifs_err(c, \"cannot read %d bytes from LEB %d:%d, error %d\",\n\t\t\t  c->leb_size - offs, lnum, offs, err);\n\t\tkfree(sleb);\n\t\treturn ERR_PTR(err);\n\t}\n\n\t \n\treturn sleb;\n}\n\n \nvoid ubifs_end_scan(const struct ubifs_info *c, struct ubifs_scan_leb *sleb,\n\t\t    int lnum, int offs)\n{\n\tdbg_scan(\"stop scanning LEB %d at offset %d\", lnum, offs);\n\tubifs_assert(c, offs % c->min_io_size == 0);\n\n\tsleb->endpt = ALIGN(offs, c->min_io_size);\n}\n\n \nint ubifs_add_snod(const struct ubifs_info *c, struct ubifs_scan_leb *sleb,\n\t\t   void *buf, int offs)\n{\n\tstruct ubifs_ch *ch = buf;\n\tstruct ubifs_ino_node *ino = buf;\n\tstruct ubifs_scan_node *snod;\n\n\tsnod = kmalloc(sizeof(struct ubifs_scan_node), GFP_NOFS);\n\tif (!snod)\n\t\treturn -ENOMEM;\n\n\tsnod->sqnum = le64_to_cpu(ch->sqnum);\n\tsnod->type = ch->node_type;\n\tsnod->offs = offs;\n\tsnod->len = le32_to_cpu(ch->len);\n\tsnod->node = buf;\n\n\tswitch (ch->node_type) {\n\tcase UBIFS_INO_NODE:\n\tcase UBIFS_DENT_NODE:\n\tcase UBIFS_XENT_NODE:\n\tcase UBIFS_DATA_NODE:\n\t\t \n\t\tkey_read(c, &ino->key, &snod->key);\n\t\tbreak;\n\tdefault:\n\t\tinvalid_key_init(c, &snod->key);\n\t\tbreak;\n\t}\n\tlist_add_tail(&snod->list, &sleb->nodes);\n\tsleb->nodes_cnt += 1;\n\treturn 0;\n}\n\n \nvoid ubifs_scanned_corruption(const struct ubifs_info *c, int lnum, int offs,\n\t\t\t      void *buf)\n{\n\tint len;\n\n\tubifs_err(c, \"corruption at LEB %d:%d\", lnum, offs);\n\tlen = c->leb_size - offs;\n\tif (len > 8192)\n\t\tlen = 8192;\n\tubifs_err(c, \"first %d bytes from LEB %d:%d\", len, lnum, offs);\n\tprint_hex_dump(KERN_DEBUG, \"\", DUMP_PREFIX_OFFSET, 32, 4, buf, len, 1);\n}\n\n \nstruct ubifs_scan_leb *ubifs_scan(const struct ubifs_info *c, int lnum,\n\t\t\t\t  int offs, void *sbuf, int quiet)\n{\n\tvoid *buf = sbuf + offs;\n\tint err, len = c->leb_size - offs;\n\tstruct ubifs_scan_leb *sleb;\n\n\tsleb = ubifs_start_scan(c, lnum, offs, sbuf);\n\tif (IS_ERR(sleb))\n\t\treturn sleb;\n\n\twhile (len >= 8) {\n\t\tstruct ubifs_ch *ch = buf;\n\t\tint node_len, ret;\n\n\t\tdbg_scan(\"look at LEB %d:%d (%d bytes left)\",\n\t\t\t lnum, offs, len);\n\n\t\tcond_resched();\n\n\t\tret = ubifs_scan_a_node(c, buf, len, lnum, offs, quiet);\n\t\tif (ret > 0) {\n\t\t\t \n\t\t\toffs += ret;\n\t\t\tbuf += ret;\n\t\t\tlen -= ret;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ret == SCANNED_EMPTY_SPACE)\n\t\t\t \n\t\t\tbreak;\n\n\t\tswitch (ret) {\n\t\tcase SCANNED_GARBAGE:\n\t\t\tubifs_err(c, \"garbage\");\n\t\t\tgoto corrupted;\n\t\tcase SCANNED_A_NODE:\n\t\t\tbreak;\n\t\tcase SCANNED_A_CORRUPT_NODE:\n\t\tcase SCANNED_A_BAD_PAD_NODE:\n\t\t\tubifs_err(c, \"bad node\");\n\t\t\tgoto corrupted;\n\t\tdefault:\n\t\t\tubifs_err(c, \"unknown\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\n\t\terr = ubifs_add_snod(c, sleb, buf, offs);\n\t\tif (err)\n\t\t\tgoto error;\n\n\t\tnode_len = ALIGN(le32_to_cpu(ch->len), 8);\n\t\toffs += node_len;\n\t\tbuf += node_len;\n\t\tlen -= node_len;\n\t}\n\n\tif (offs % c->min_io_size) {\n\t\tif (!quiet)\n\t\t\tubifs_err(c, \"empty space starts at non-aligned offset %d\",\n\t\t\t\t  offs);\n\t\tgoto corrupted;\n\t}\n\n\tubifs_end_scan(c, sleb, lnum, offs);\n\n\tfor (; len > 4; offs += 4, buf = buf + 4, len -= 4)\n\t\tif (*(uint32_t *)buf != 0xffffffff)\n\t\t\tbreak;\n\tfor (; len; offs++, buf++, len--)\n\t\tif (*(uint8_t *)buf != 0xff) {\n\t\t\tif (!quiet)\n\t\t\t\tubifs_err(c, \"corrupt empty space at LEB %d:%d\",\n\t\t\t\t\t  lnum, offs);\n\t\t\tgoto corrupted;\n\t\t}\n\n\treturn sleb;\n\ncorrupted:\n\tif (!quiet) {\n\t\tubifs_scanned_corruption(c, lnum, offs, buf);\n\t\tubifs_err(c, \"LEB %d scanning failed\", lnum);\n\t}\n\terr = -EUCLEAN;\n\tubifs_scan_destroy(sleb);\n\treturn ERR_PTR(err);\n\nerror:\n\tubifs_err(c, \"LEB %d scanning failed, error %d\", lnum, err);\n\tubifs_scan_destroy(sleb);\n\treturn ERR_PTR(err);\n}\n\n \nvoid ubifs_scan_destroy(struct ubifs_scan_leb *sleb)\n{\n\tstruct ubifs_scan_node *node;\n\tstruct list_head *head;\n\n\thead = &sleb->nodes;\n\twhile (!list_empty(head)) {\n\t\tnode = list_entry(head->next, struct ubifs_scan_node, list);\n\t\tlist_del(&node->list);\n\t\tkfree(node);\n\t}\n\tkfree(sleb);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}