{
  "module_name": "dir.c",
  "hash_id": "faa4eb0db36d34f5f1fc4d8a34898fad77829bedfa41d4f5efc5fcdcd510e022",
  "original_prompt": "Ingested from linux-6.6.14/fs/ubifs/dir.c",
  "human_readable_source": "\n \n\n \n\n#include \"ubifs.h\"\n\n \nstatic int inherit_flags(const struct inode *dir, umode_t mode)\n{\n\tint flags;\n\tconst struct ubifs_inode *ui = ubifs_inode(dir);\n\n\tif (!S_ISDIR(dir->i_mode))\n\t\t \n\t\treturn 0;\n\n\tflags = ui->flags & (UBIFS_COMPR_FL | UBIFS_SYNC_FL | UBIFS_DIRSYNC_FL);\n\tif (!S_ISDIR(mode))\n\t\t \n\t\tflags &= ~UBIFS_DIRSYNC_FL;\n\treturn flags;\n}\n\n \nstruct inode *ubifs_new_inode(struct ubifs_info *c, struct inode *dir,\n\t\t\t      umode_t mode, bool is_xattr)\n{\n\tint err;\n\tstruct inode *inode;\n\tstruct ubifs_inode *ui;\n\tbool encrypted = false;\n\n\tinode = new_inode(c->vfs_sb);\n\tui = ubifs_inode(inode);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tinode->i_flags |= S_NOCMTIME;\n\n\tinode_init_owner(&nop_mnt_idmap, inode, dir, mode);\n\tinode->i_mtime = inode->i_atime = inode_set_ctime_current(inode);\n\tinode->i_mapping->nrpages = 0;\n\n\tif (!is_xattr) {\n\t\terr = fscrypt_prepare_new_inode(dir, inode, &encrypted);\n\t\tif (err) {\n\t\t\tubifs_err(c, \"fscrypt_prepare_new_inode failed: %i\", err);\n\t\t\tgoto out_iput;\n\t\t}\n\t}\n\n\tswitch (mode & S_IFMT) {\n\tcase S_IFREG:\n\t\tinode->i_mapping->a_ops = &ubifs_file_address_operations;\n\t\tinode->i_op = &ubifs_file_inode_operations;\n\t\tinode->i_fop = &ubifs_file_operations;\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tinode->i_op  = &ubifs_dir_inode_operations;\n\t\tinode->i_fop = &ubifs_dir_operations;\n\t\tinode->i_size = ui->ui_size = UBIFS_INO_NODE_SZ;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &ubifs_symlink_inode_operations;\n\t\tbreak;\n\tcase S_IFSOCK:\n\tcase S_IFIFO:\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\t\tinode->i_op  = &ubifs_file_inode_operations;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tui->flags = inherit_flags(dir, mode);\n\tubifs_set_inode_flags(inode);\n\tif (S_ISREG(mode))\n\t\tui->compr_type = c->default_compr;\n\telse\n\t\tui->compr_type = UBIFS_COMPR_NONE;\n\tui->synced_i_size = 0;\n\n\tspin_lock(&c->cnt_lock);\n\t \n\tif (c->highest_inum >= INUM_WARN_WATERMARK) {\n\t\tif (c->highest_inum >= INUM_WATERMARK) {\n\t\t\tspin_unlock(&c->cnt_lock);\n\t\t\tubifs_err(c, \"out of inode numbers\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_iput;\n\t\t}\n\t\tubifs_warn(c, \"running out of inode numbers (current %lu, max %u)\",\n\t\t\t   (unsigned long)c->highest_inum, INUM_WATERMARK);\n\t}\n\n\tinode->i_ino = ++c->highest_inum;\n\t \n\tui->creat_sqnum = ++c->max_sqnum;\n\tspin_unlock(&c->cnt_lock);\n\n\tif (encrypted) {\n\t\terr = fscrypt_set_context(inode, NULL);\n\t\tif (err) {\n\t\t\tubifs_err(c, \"fscrypt_set_context failed: %i\", err);\n\t\t\tgoto out_iput;\n\t\t}\n\t}\n\n\treturn inode;\n\nout_iput:\n\tmake_bad_inode(inode);\n\tiput(inode);\n\treturn ERR_PTR(err);\n}\n\nstatic int dbg_check_name(const struct ubifs_info *c,\n\t\t\t  const struct ubifs_dent_node *dent,\n\t\t\t  const struct fscrypt_name *nm)\n{\n\tif (!dbg_is_chk_gen(c))\n\t\treturn 0;\n\tif (le16_to_cpu(dent->nlen) != fname_len(nm))\n\t\treturn -EINVAL;\n\tif (memcmp(dent->name, fname_name(nm), fname_len(nm)))\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic struct dentry *ubifs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t   unsigned int flags)\n{\n\tint err;\n\tunion ubifs_key key;\n\tstruct inode *inode = NULL;\n\tstruct ubifs_dent_node *dent = NULL;\n\tstruct ubifs_info *c = dir->i_sb->s_fs_info;\n\tstruct fscrypt_name nm;\n\n\tdbg_gen(\"'%pd' in dir ino %lu\", dentry, dir->i_ino);\n\n\terr = fscrypt_prepare_lookup(dir, dentry, &nm);\n\tgeneric_set_encrypted_ci_d_ops(dentry);\n\tif (err == -ENOENT)\n\t\treturn d_splice_alias(NULL, dentry);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tif (fname_len(&nm) > UBIFS_MAX_NLEN) {\n\t\tinode = ERR_PTR(-ENAMETOOLONG);\n\t\tgoto done;\n\t}\n\n\tdent = kmalloc(UBIFS_MAX_DENT_NODE_SZ, GFP_NOFS);\n\tif (!dent) {\n\t\tinode = ERR_PTR(-ENOMEM);\n\t\tgoto done;\n\t}\n\n\tif (fname_name(&nm) == NULL) {\n\t\tif (nm.hash & ~UBIFS_S_KEY_HASH_MASK)\n\t\t\tgoto done;  \n\t\tdent_key_init_hash(c, &key, dir->i_ino, nm.hash);\n\t\terr = ubifs_tnc_lookup_dh(c, &key, dent, nm.minor_hash);\n\t} else {\n\t\tdent_key_init(c, &key, dir->i_ino, &nm);\n\t\terr = ubifs_tnc_lookup_nm(c, &key, dent, &nm);\n\t}\n\n\tif (err) {\n\t\tif (err == -ENOENT)\n\t\t\tdbg_gen(\"not found\");\n\t\telse\n\t\t\tinode = ERR_PTR(err);\n\t\tgoto done;\n\t}\n\n\tif (dbg_check_name(c, dent, &nm)) {\n\t\tinode = ERR_PTR(-EINVAL);\n\t\tgoto done;\n\t}\n\n\tinode = ubifs_iget(dir->i_sb, le64_to_cpu(dent->inum));\n\tif (IS_ERR(inode)) {\n\t\t \n\t\terr = PTR_ERR(inode);\n\t\tubifs_err(c, \"dead directory entry '%pd', error %d\",\n\t\t\t  dentry, err);\n\t\tubifs_ro_mode(c, err);\n\t\tgoto done;\n\t}\n\n\tif (IS_ENCRYPTED(dir) &&\n\t    (S_ISDIR(inode->i_mode) || S_ISLNK(inode->i_mode)) &&\n\t    !fscrypt_has_permitted_context(dir, inode)) {\n\t\tubifs_warn(c, \"Inconsistent encryption contexts: %lu/%lu\",\n\t\t\t   dir->i_ino, inode->i_ino);\n\t\tiput(inode);\n\t\tinode = ERR_PTR(-EPERM);\n\t}\n\ndone:\n\tkfree(dent);\n\tfscrypt_free_filename(&nm);\n\treturn d_splice_alias(inode, dentry);\n}\n\nstatic int ubifs_prepare_create(struct inode *dir, struct dentry *dentry,\n\t\t\t\tstruct fscrypt_name *nm)\n{\n\tif (fscrypt_is_nokey_name(dentry))\n\t\treturn -ENOKEY;\n\n\treturn fscrypt_setup_filename(dir, &dentry->d_name, 0, nm);\n}\n\nstatic int ubifs_create(struct mnt_idmap *idmap, struct inode *dir,\n\t\t\tstruct dentry *dentry, umode_t mode, bool excl)\n{\n\tstruct inode *inode;\n\tstruct ubifs_info *c = dir->i_sb->s_fs_info;\n\tstruct ubifs_budget_req req = { .new_ino = 1, .new_dent = 1,\n\t\t\t\t\t.dirtied_ino = 1 };\n\tstruct ubifs_inode *dir_ui = ubifs_inode(dir);\n\tstruct fscrypt_name nm;\n\tint err, sz_change;\n\n\t \n\n\tdbg_gen(\"dent '%pd', mode %#hx in dir ino %lu\",\n\t\tdentry, mode, dir->i_ino);\n\n\terr = ubifs_budget_space(c, &req);\n\tif (err)\n\t\treturn err;\n\n\terr = ubifs_prepare_create(dir, dentry, &nm);\n\tif (err)\n\t\tgoto out_budg;\n\n\tsz_change = CALC_DENT_SIZE(fname_len(&nm));\n\n\tinode = ubifs_new_inode(c, dir, mode, false);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tgoto out_fname;\n\t}\n\n\terr = ubifs_init_security(dir, inode, &dentry->d_name);\n\tif (err)\n\t\tgoto out_inode;\n\n\tmutex_lock(&dir_ui->ui_mutex);\n\tdir->i_size += sz_change;\n\tdir_ui->ui_size = dir->i_size;\n\tdir->i_mtime = inode_set_ctime_to_ts(dir, inode_get_ctime(inode));\n\terr = ubifs_jnl_update(c, dir, &nm, inode, 0, 0);\n\tif (err)\n\t\tgoto out_cancel;\n\tmutex_unlock(&dir_ui->ui_mutex);\n\n\tubifs_release_budget(c, &req);\n\tfscrypt_free_filename(&nm);\n\tinsert_inode_hash(inode);\n\td_instantiate(dentry, inode);\n\treturn 0;\n\nout_cancel:\n\tdir->i_size -= sz_change;\n\tdir_ui->ui_size = dir->i_size;\n\tmutex_unlock(&dir_ui->ui_mutex);\nout_inode:\n\tmake_bad_inode(inode);\n\tiput(inode);\nout_fname:\n\tfscrypt_free_filename(&nm);\nout_budg:\n\tubifs_release_budget(c, &req);\n\tubifs_err(c, \"cannot create regular file, error %d\", err);\n\treturn err;\n}\n\nstatic struct inode *create_whiteout(struct inode *dir, struct dentry *dentry)\n{\n\tint err;\n\tumode_t mode = S_IFCHR | WHITEOUT_MODE;\n\tstruct inode *inode;\n\tstruct ubifs_info *c = dir->i_sb->s_fs_info;\n\n\t \n\n\tdbg_gen(\"dent '%pd', mode %#hx in dir ino %lu\",\n\t\tdentry, mode, dir->i_ino);\n\n\tinode = ubifs_new_inode(c, dir, mode, false);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tgoto out_free;\n\t}\n\n\tinit_special_inode(inode, inode->i_mode, WHITEOUT_DEV);\n\tubifs_assert(c, inode->i_op == &ubifs_file_inode_operations);\n\n\terr = ubifs_init_security(dir, inode, &dentry->d_name);\n\tif (err)\n\t\tgoto out_inode;\n\n\t \n\tinsert_inode_hash(inode);\n\n\treturn inode;\n\nout_inode:\n\tmake_bad_inode(inode);\n\tiput(inode);\nout_free:\n\tubifs_err(c, \"cannot create whiteout file, error %d\", err);\n\treturn ERR_PTR(err);\n}\n\n \nstatic void lock_2_inodes(struct inode *inode1, struct inode *inode2)\n{\n\tmutex_lock_nested(&ubifs_inode(inode1)->ui_mutex, WB_MUTEX_1);\n\tmutex_lock_nested(&ubifs_inode(inode2)->ui_mutex, WB_MUTEX_2);\n}\n\n \nstatic void unlock_2_inodes(struct inode *inode1, struct inode *inode2)\n{\n\tmutex_unlock(&ubifs_inode(inode2)->ui_mutex);\n\tmutex_unlock(&ubifs_inode(inode1)->ui_mutex);\n}\n\nstatic int ubifs_tmpfile(struct mnt_idmap *idmap, struct inode *dir,\n\t\t\t struct file *file, umode_t mode)\n{\n\tstruct dentry *dentry = file->f_path.dentry;\n\tstruct inode *inode;\n\tstruct ubifs_info *c = dir->i_sb->s_fs_info;\n\tstruct ubifs_budget_req req = { .new_ino = 1, .new_dent = 1,\n\t\t\t\t\t.dirtied_ino = 1};\n\tstruct ubifs_budget_req ino_req = { .dirtied_ino = 1 };\n\tstruct ubifs_inode *ui;\n\tint err, instantiated = 0;\n\tstruct fscrypt_name nm;\n\n\t \n\n\tdbg_gen(\"dent '%pd', mode %#hx in dir ino %lu\",\n\t\tdentry, mode, dir->i_ino);\n\n\terr = fscrypt_setup_filename(dir, &dentry->d_name, 0, &nm);\n\tif (err)\n\t\treturn err;\n\n\terr = ubifs_budget_space(c, &req);\n\tif (err) {\n\t\tfscrypt_free_filename(&nm);\n\t\treturn err;\n\t}\n\n\terr = ubifs_budget_space(c, &ino_req);\n\tif (err) {\n\t\tubifs_release_budget(c, &req);\n\t\tfscrypt_free_filename(&nm);\n\t\treturn err;\n\t}\n\n\tinode = ubifs_new_inode(c, dir, mode, false);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tgoto out_budg;\n\t}\n\tui = ubifs_inode(inode);\n\n\terr = ubifs_init_security(dir, inode, &dentry->d_name);\n\tif (err)\n\t\tgoto out_inode;\n\n\tmutex_lock(&ui->ui_mutex);\n\tinsert_inode_hash(inode);\n\td_tmpfile(file, inode);\n\tubifs_assert(c, ui->dirty);\n\n\tinstantiated = 1;\n\tmutex_unlock(&ui->ui_mutex);\n\n\tlock_2_inodes(dir, inode);\n\terr = ubifs_jnl_update(c, dir, &nm, inode, 1, 0);\n\tif (err)\n\t\tgoto out_cancel;\n\tunlock_2_inodes(dir, inode);\n\n\tubifs_release_budget(c, &req);\n\tfscrypt_free_filename(&nm);\n\n\treturn finish_open_simple(file, 0);\n\nout_cancel:\n\tunlock_2_inodes(dir, inode);\nout_inode:\n\tmake_bad_inode(inode);\n\tif (!instantiated)\n\t\tiput(inode);\nout_budg:\n\tubifs_release_budget(c, &req);\n\tif (!instantiated)\n\t\tubifs_release_budget(c, &ino_req);\n\tfscrypt_free_filename(&nm);\n\tubifs_err(c, \"cannot create temporary file, error %d\", err);\n\treturn err;\n}\n\n \nstatic unsigned int vfs_dent_type(uint8_t type)\n{\n\tswitch (type) {\n\tcase UBIFS_ITYPE_REG:\n\t\treturn DT_REG;\n\tcase UBIFS_ITYPE_DIR:\n\t\treturn DT_DIR;\n\tcase UBIFS_ITYPE_LNK:\n\t\treturn DT_LNK;\n\tcase UBIFS_ITYPE_BLK:\n\t\treturn DT_BLK;\n\tcase UBIFS_ITYPE_CHR:\n\t\treturn DT_CHR;\n\tcase UBIFS_ITYPE_FIFO:\n\t\treturn DT_FIFO;\n\tcase UBIFS_ITYPE_SOCK:\n\t\treturn DT_SOCK;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn 0;\n}\n\n \nstatic int ubifs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tint fstr_real_len = 0, err = 0;\n\tstruct fscrypt_name nm;\n\tstruct fscrypt_str fstr = {0};\n\tunion ubifs_key key;\n\tstruct ubifs_dent_node *dent;\n\tstruct inode *dir = file_inode(file);\n\tstruct ubifs_info *c = dir->i_sb->s_fs_info;\n\tbool encrypted = IS_ENCRYPTED(dir);\n\n\tdbg_gen(\"dir ino %lu, f_pos %#llx\", dir->i_ino, ctx->pos);\n\n\tif (ctx->pos > UBIFS_S_KEY_HASH_MASK || ctx->pos == 2)\n\t\t \n\t\treturn 0;\n\n\tif (encrypted) {\n\t\terr = fscrypt_prepare_readdir(dir);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = fscrypt_fname_alloc_buffer(UBIFS_MAX_NLEN, &fstr);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tfstr_real_len = fstr.len;\n\t}\n\n\tif (file->f_version == 0) {\n\t\t \n\t\tkfree(file->private_data);\n\t\tfile->private_data = NULL;\n\t}\n\n\t \n\tfile->f_version = 1;\n\n\t \n\tif (ctx->pos < 2) {\n\t\tubifs_assert(c, !file->private_data);\n\t\tif (!dir_emit_dots(file, ctx)) {\n\t\t\tif (encrypted)\n\t\t\t\tfscrypt_fname_free_buffer(&fstr);\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tlowest_dent_key(c, &key, dir->i_ino);\n\t\tfname_len(&nm) = 0;\n\t\tdent = ubifs_tnc_next_ent(c, &key, &nm);\n\t\tif (IS_ERR(dent)) {\n\t\t\terr = PTR_ERR(dent);\n\t\t\tgoto out;\n\t\t}\n\n\t\tctx->pos = key_hash_flash(c, &dent->key);\n\t\tfile->private_data = dent;\n\t}\n\n\tdent = file->private_data;\n\tif (!dent) {\n\t\t \n\t\tdent_key_init_hash(c, &key, dir->i_ino, ctx->pos);\n\t\tfname_len(&nm) = 0;\n\t\tdent = ubifs_tnc_next_ent(c, &key, &nm);\n\t\tif (IS_ERR(dent)) {\n\t\t\terr = PTR_ERR(dent);\n\t\t\tgoto out;\n\t\t}\n\t\tctx->pos = key_hash_flash(c, &dent->key);\n\t\tfile->private_data = dent;\n\t}\n\n\twhile (1) {\n\t\tdbg_gen(\"ino %llu, new f_pos %#x\",\n\t\t\t(unsigned long long)le64_to_cpu(dent->inum),\n\t\t\tkey_hash_flash(c, &dent->key));\n\t\tubifs_assert(c, le64_to_cpu(dent->ch.sqnum) >\n\t\t\t     ubifs_inode(dir)->creat_sqnum);\n\n\t\tfname_len(&nm) = le16_to_cpu(dent->nlen);\n\t\tfname_name(&nm) = dent->name;\n\n\t\tif (encrypted) {\n\t\t\tfstr.len = fstr_real_len;\n\n\t\t\terr = fscrypt_fname_disk_to_usr(dir, key_hash_flash(c,\n\t\t\t\t\t\t\t&dent->key),\n\t\t\t\t\t\t\tle32_to_cpu(dent->cookie),\n\t\t\t\t\t\t\t&nm.disk_name, &fstr);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\tfstr.len = fname_len(&nm);\n\t\t\tfstr.name = fname_name(&nm);\n\t\t}\n\n\t\tif (!dir_emit(ctx, fstr.name, fstr.len,\n\t\t\t       le64_to_cpu(dent->inum),\n\t\t\t       vfs_dent_type(dent->type))) {\n\t\t\tif (encrypted)\n\t\t\t\tfscrypt_fname_free_buffer(&fstr);\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tkey_read(c, &dent->key, &key);\n\t\tdent = ubifs_tnc_next_ent(c, &key, &nm);\n\t\tif (IS_ERR(dent)) {\n\t\t\terr = PTR_ERR(dent);\n\t\t\tgoto out;\n\t\t}\n\n\t\tkfree(file->private_data);\n\t\tctx->pos = key_hash_flash(c, &dent->key);\n\t\tfile->private_data = dent;\n\t\tcond_resched();\n\t}\n\nout:\n\tkfree(file->private_data);\n\tfile->private_data = NULL;\n\n\tif (encrypted)\n\t\tfscrypt_fname_free_buffer(&fstr);\n\n\tif (err != -ENOENT)\n\t\tubifs_err(c, \"cannot find next direntry, error %d\", err);\n\telse\n\t\t \n\t\terr = 0;\n\n\n\t \n\tctx->pos = 2;\n\treturn err;\n}\n\n \nstatic int ubifs_dir_release(struct inode *dir, struct file *file)\n{\n\tkfree(file->private_data);\n\tfile->private_data = NULL;\n\treturn 0;\n}\n\nstatic int ubifs_link(struct dentry *old_dentry, struct inode *dir,\n\t\t      struct dentry *dentry)\n{\n\tstruct ubifs_info *c = dir->i_sb->s_fs_info;\n\tstruct inode *inode = d_inode(old_dentry);\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\tstruct ubifs_inode *dir_ui = ubifs_inode(dir);\n\tint err, sz_change = CALC_DENT_SIZE(dentry->d_name.len);\n\tstruct ubifs_budget_req req = { .new_dent = 1, .dirtied_ino = 2,\n\t\t\t\t.dirtied_ino_d = ALIGN(ui->data_len, 8) };\n\tstruct fscrypt_name nm;\n\n\t \n\n\tdbg_gen(\"dent '%pd' to ino %lu (nlink %d) in dir ino %lu\",\n\t\tdentry, inode->i_ino,\n\t\tinode->i_nlink, dir->i_ino);\n\tubifs_assert(c, inode_is_locked(dir));\n\tubifs_assert(c, inode_is_locked(inode));\n\n\terr = fscrypt_prepare_link(old_dentry, dir, dentry);\n\tif (err)\n\t\treturn err;\n\n\terr = fscrypt_setup_filename(dir, &dentry->d_name, 0, &nm);\n\tif (err)\n\t\treturn err;\n\n\terr = dbg_check_synced_i_size(c, inode);\n\tif (err)\n\t\tgoto out_fname;\n\n\terr = ubifs_budget_space(c, &req);\n\tif (err)\n\t\tgoto out_fname;\n\n\tlock_2_inodes(dir, inode);\n\n\t \n\tif (inode->i_nlink == 0)\n\t\tubifs_delete_orphan(c, inode->i_ino);\n\n\tinc_nlink(inode);\n\tihold(inode);\n\tinode_set_ctime_current(inode);\n\tdir->i_size += sz_change;\n\tdir_ui->ui_size = dir->i_size;\n\tdir->i_mtime = inode_set_ctime_to_ts(dir, inode_get_ctime(inode));\n\terr = ubifs_jnl_update(c, dir, &nm, inode, 0, 0);\n\tif (err)\n\t\tgoto out_cancel;\n\tunlock_2_inodes(dir, inode);\n\n\tubifs_release_budget(c, &req);\n\td_instantiate(dentry, inode);\n\tfscrypt_free_filename(&nm);\n\treturn 0;\n\nout_cancel:\n\tdir->i_size -= sz_change;\n\tdir_ui->ui_size = dir->i_size;\n\tdrop_nlink(inode);\n\tif (inode->i_nlink == 0)\n\t\tubifs_add_orphan(c, inode->i_ino);\n\tunlock_2_inodes(dir, inode);\n\tubifs_release_budget(c, &req);\n\tiput(inode);\nout_fname:\n\tfscrypt_free_filename(&nm);\n\treturn err;\n}\n\nstatic int ubifs_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct ubifs_info *c = dir->i_sb->s_fs_info;\n\tstruct inode *inode = d_inode(dentry);\n\tstruct ubifs_inode *dir_ui = ubifs_inode(dir);\n\tint err, sz_change, budgeted = 1;\n\tstruct ubifs_budget_req req = { .mod_dent = 1, .dirtied_ino = 2 };\n\tunsigned int saved_nlink = inode->i_nlink;\n\tstruct fscrypt_name nm;\n\n\t \n\n\tdbg_gen(\"dent '%pd' from ino %lu (nlink %d) in dir ino %lu\",\n\t\tdentry, inode->i_ino,\n\t\tinode->i_nlink, dir->i_ino);\n\n\terr = fscrypt_setup_filename(dir, &dentry->d_name, 1, &nm);\n\tif (err)\n\t\treturn err;\n\n\terr = ubifs_purge_xattrs(inode);\n\tif (err)\n\t\treturn err;\n\n\tsz_change = CALC_DENT_SIZE(fname_len(&nm));\n\n\tubifs_assert(c, inode_is_locked(dir));\n\tubifs_assert(c, inode_is_locked(inode));\n\terr = dbg_check_synced_i_size(c, inode);\n\tif (err)\n\t\tgoto out_fname;\n\n\terr = ubifs_budget_space(c, &req);\n\tif (err) {\n\t\tif (err != -ENOSPC)\n\t\t\tgoto out_fname;\n\t\tbudgeted = 0;\n\t}\n\n\tlock_2_inodes(dir, inode);\n\tinode_set_ctime_current(inode);\n\tdrop_nlink(inode);\n\tdir->i_size -= sz_change;\n\tdir_ui->ui_size = dir->i_size;\n\tdir->i_mtime = inode_set_ctime_to_ts(dir, inode_get_ctime(inode));\n\terr = ubifs_jnl_update(c, dir, &nm, inode, 1, 0);\n\tif (err)\n\t\tgoto out_cancel;\n\tunlock_2_inodes(dir, inode);\n\n\tif (budgeted)\n\t\tubifs_release_budget(c, &req);\n\telse {\n\t\t \n\t\tc->bi.nospace = c->bi.nospace_rp = 0;\n\t\tsmp_wmb();\n\t}\n\tfscrypt_free_filename(&nm);\n\treturn 0;\n\nout_cancel:\n\tdir->i_size += sz_change;\n\tdir_ui->ui_size = dir->i_size;\n\tset_nlink(inode, saved_nlink);\n\tunlock_2_inodes(dir, inode);\n\tif (budgeted)\n\t\tubifs_release_budget(c, &req);\nout_fname:\n\tfscrypt_free_filename(&nm);\n\treturn err;\n}\n\n \nint ubifs_check_dir_empty(struct inode *dir)\n{\n\tstruct ubifs_info *c = dir->i_sb->s_fs_info;\n\tstruct fscrypt_name nm = { 0 };\n\tstruct ubifs_dent_node *dent;\n\tunion ubifs_key key;\n\tint err;\n\n\tlowest_dent_key(c, &key, dir->i_ino);\n\tdent = ubifs_tnc_next_ent(c, &key, &nm);\n\tif (IS_ERR(dent)) {\n\t\terr = PTR_ERR(dent);\n\t\tif (err == -ENOENT)\n\t\t\terr = 0;\n\t} else {\n\t\tkfree(dent);\n\t\terr = -ENOTEMPTY;\n\t}\n\treturn err;\n}\n\nstatic int ubifs_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tstruct ubifs_info *c = dir->i_sb->s_fs_info;\n\tstruct inode *inode = d_inode(dentry);\n\tint err, sz_change, budgeted = 1;\n\tstruct ubifs_inode *dir_ui = ubifs_inode(dir);\n\tstruct ubifs_budget_req req = { .mod_dent = 1, .dirtied_ino = 2 };\n\tstruct fscrypt_name nm;\n\n\t \n\n\tdbg_gen(\"directory '%pd', ino %lu in dir ino %lu\", dentry,\n\t\tinode->i_ino, dir->i_ino);\n\tubifs_assert(c, inode_is_locked(dir));\n\tubifs_assert(c, inode_is_locked(inode));\n\terr = ubifs_check_dir_empty(d_inode(dentry));\n\tif (err)\n\t\treturn err;\n\n\terr = fscrypt_setup_filename(dir, &dentry->d_name, 1, &nm);\n\tif (err)\n\t\treturn err;\n\n\terr = ubifs_purge_xattrs(inode);\n\tif (err)\n\t\treturn err;\n\n\tsz_change = CALC_DENT_SIZE(fname_len(&nm));\n\n\terr = ubifs_budget_space(c, &req);\n\tif (err) {\n\t\tif (err != -ENOSPC)\n\t\t\tgoto out_fname;\n\t\tbudgeted = 0;\n\t}\n\n\tlock_2_inodes(dir, inode);\n\tinode_set_ctime_current(inode);\n\tclear_nlink(inode);\n\tdrop_nlink(dir);\n\tdir->i_size -= sz_change;\n\tdir_ui->ui_size = dir->i_size;\n\tdir->i_mtime = inode_set_ctime_to_ts(dir, inode_get_ctime(inode));\n\terr = ubifs_jnl_update(c, dir, &nm, inode, 1, 0);\n\tif (err)\n\t\tgoto out_cancel;\n\tunlock_2_inodes(dir, inode);\n\n\tif (budgeted)\n\t\tubifs_release_budget(c, &req);\n\telse {\n\t\t \n\t\tc->bi.nospace = c->bi.nospace_rp = 0;\n\t\tsmp_wmb();\n\t}\n\tfscrypt_free_filename(&nm);\n\treturn 0;\n\nout_cancel:\n\tdir->i_size += sz_change;\n\tdir_ui->ui_size = dir->i_size;\n\tinc_nlink(dir);\n\tset_nlink(inode, 2);\n\tunlock_2_inodes(dir, inode);\n\tif (budgeted)\n\t\tubifs_release_budget(c, &req);\nout_fname:\n\tfscrypt_free_filename(&nm);\n\treturn err;\n}\n\nstatic int ubifs_mkdir(struct mnt_idmap *idmap, struct inode *dir,\n\t\t       struct dentry *dentry, umode_t mode)\n{\n\tstruct inode *inode;\n\tstruct ubifs_inode *dir_ui = ubifs_inode(dir);\n\tstruct ubifs_info *c = dir->i_sb->s_fs_info;\n\tint err, sz_change;\n\tstruct ubifs_budget_req req = { .new_ino = 1, .new_dent = 1,\n\t\t\t\t\t.dirtied_ino = 1};\n\tstruct fscrypt_name nm;\n\n\t \n\n\tdbg_gen(\"dent '%pd', mode %#hx in dir ino %lu\",\n\t\tdentry, mode, dir->i_ino);\n\n\terr = ubifs_budget_space(c, &req);\n\tif (err)\n\t\treturn err;\n\n\terr = ubifs_prepare_create(dir, dentry, &nm);\n\tif (err)\n\t\tgoto out_budg;\n\n\tsz_change = CALC_DENT_SIZE(fname_len(&nm));\n\n\tinode = ubifs_new_inode(c, dir, S_IFDIR | mode, false);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tgoto out_fname;\n\t}\n\n\terr = ubifs_init_security(dir, inode, &dentry->d_name);\n\tif (err)\n\t\tgoto out_inode;\n\n\tmutex_lock(&dir_ui->ui_mutex);\n\tinsert_inode_hash(inode);\n\tinc_nlink(inode);\n\tinc_nlink(dir);\n\tdir->i_size += sz_change;\n\tdir_ui->ui_size = dir->i_size;\n\tdir->i_mtime = inode_set_ctime_to_ts(dir, inode_get_ctime(inode));\n\terr = ubifs_jnl_update(c, dir, &nm, inode, 0, 0);\n\tif (err) {\n\t\tubifs_err(c, \"cannot create directory, error %d\", err);\n\t\tgoto out_cancel;\n\t}\n\tmutex_unlock(&dir_ui->ui_mutex);\n\n\tubifs_release_budget(c, &req);\n\td_instantiate(dentry, inode);\n\tfscrypt_free_filename(&nm);\n\treturn 0;\n\nout_cancel:\n\tdir->i_size -= sz_change;\n\tdir_ui->ui_size = dir->i_size;\n\tdrop_nlink(dir);\n\tmutex_unlock(&dir_ui->ui_mutex);\nout_inode:\n\tmake_bad_inode(inode);\n\tiput(inode);\nout_fname:\n\tfscrypt_free_filename(&nm);\nout_budg:\n\tubifs_release_budget(c, &req);\n\treturn err;\n}\n\nstatic int ubifs_mknod(struct mnt_idmap *idmap, struct inode *dir,\n\t\t       struct dentry *dentry, umode_t mode, dev_t rdev)\n{\n\tstruct inode *inode;\n\tstruct ubifs_inode *ui;\n\tstruct ubifs_inode *dir_ui = ubifs_inode(dir);\n\tstruct ubifs_info *c = dir->i_sb->s_fs_info;\n\tunion ubifs_dev_desc *dev = NULL;\n\tint sz_change;\n\tint err, devlen = 0;\n\tstruct ubifs_budget_req req = { .new_ino = 1, .new_dent = 1,\n\t\t\t\t\t.dirtied_ino = 1 };\n\tstruct fscrypt_name nm;\n\n\t \n\n\tdbg_gen(\"dent '%pd' in dir ino %lu\", dentry, dir->i_ino);\n\n\tif (S_ISBLK(mode) || S_ISCHR(mode)) {\n\t\tdev = kmalloc(sizeof(union ubifs_dev_desc), GFP_NOFS);\n\t\tif (!dev)\n\t\t\treturn -ENOMEM;\n\t\tdevlen = ubifs_encode_dev(dev, rdev);\n\t}\n\n\treq.new_ino_d = ALIGN(devlen, 8);\n\terr = ubifs_budget_space(c, &req);\n\tif (err) {\n\t\tkfree(dev);\n\t\treturn err;\n\t}\n\n\terr = ubifs_prepare_create(dir, dentry, &nm);\n\tif (err) {\n\t\tkfree(dev);\n\t\tgoto out_budg;\n\t}\n\n\tsz_change = CALC_DENT_SIZE(fname_len(&nm));\n\n\tinode = ubifs_new_inode(c, dir, mode, false);\n\tif (IS_ERR(inode)) {\n\t\tkfree(dev);\n\t\terr = PTR_ERR(inode);\n\t\tgoto out_fname;\n\t}\n\n\tinit_special_inode(inode, inode->i_mode, rdev);\n\tinode->i_size = ubifs_inode(inode)->ui_size = devlen;\n\tui = ubifs_inode(inode);\n\tui->data = dev;\n\tui->data_len = devlen;\n\n\terr = ubifs_init_security(dir, inode, &dentry->d_name);\n\tif (err)\n\t\tgoto out_inode;\n\n\tmutex_lock(&dir_ui->ui_mutex);\n\tdir->i_size += sz_change;\n\tdir_ui->ui_size = dir->i_size;\n\tdir->i_mtime = inode_set_ctime_to_ts(dir, inode_get_ctime(inode));\n\terr = ubifs_jnl_update(c, dir, &nm, inode, 0, 0);\n\tif (err)\n\t\tgoto out_cancel;\n\tmutex_unlock(&dir_ui->ui_mutex);\n\n\tubifs_release_budget(c, &req);\n\tinsert_inode_hash(inode);\n\td_instantiate(dentry, inode);\n\tfscrypt_free_filename(&nm);\n\treturn 0;\n\nout_cancel:\n\tdir->i_size -= sz_change;\n\tdir_ui->ui_size = dir->i_size;\n\tmutex_unlock(&dir_ui->ui_mutex);\nout_inode:\n\tmake_bad_inode(inode);\n\tiput(inode);\nout_fname:\n\tfscrypt_free_filename(&nm);\nout_budg:\n\tubifs_release_budget(c, &req);\n\treturn err;\n}\n\nstatic int ubifs_symlink(struct mnt_idmap *idmap, struct inode *dir,\n\t\t\t struct dentry *dentry, const char *symname)\n{\n\tstruct inode *inode;\n\tstruct ubifs_inode *ui;\n\tstruct ubifs_inode *dir_ui = ubifs_inode(dir);\n\tstruct ubifs_info *c = dir->i_sb->s_fs_info;\n\tint err, sz_change, len = strlen(symname);\n\tstruct fscrypt_str disk_link;\n\tstruct ubifs_budget_req req = { .new_ino = 1, .new_dent = 1,\n\t\t\t\t\t.dirtied_ino = 1 };\n\tstruct fscrypt_name nm;\n\n\tdbg_gen(\"dent '%pd', target '%s' in dir ino %lu\", dentry,\n\t\tsymname, dir->i_ino);\n\n\terr = fscrypt_prepare_symlink(dir, symname, len, UBIFS_MAX_INO_DATA,\n\t\t\t\t      &disk_link);\n\tif (err)\n\t\treturn err;\n\n\t \n\treq.new_ino_d = ALIGN(disk_link.len - 1, 8);\n\terr = ubifs_budget_space(c, &req);\n\tif (err)\n\t\treturn err;\n\n\terr = ubifs_prepare_create(dir, dentry, &nm);\n\tif (err)\n\t\tgoto out_budg;\n\n\tsz_change = CALC_DENT_SIZE(fname_len(&nm));\n\n\tinode = ubifs_new_inode(c, dir, S_IFLNK | S_IRWXUGO, false);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tgoto out_fname;\n\t}\n\n\tui = ubifs_inode(inode);\n\tui->data = kmalloc(disk_link.len, GFP_NOFS);\n\tif (!ui->data) {\n\t\terr = -ENOMEM;\n\t\tgoto out_inode;\n\t}\n\n\tif (IS_ENCRYPTED(inode)) {\n\t\tdisk_link.name = ui->data;  \n\t\terr = fscrypt_encrypt_symlink(inode, symname, len, &disk_link);\n\t\tif (err)\n\t\t\tgoto out_inode;\n\t} else {\n\t\tmemcpy(ui->data, disk_link.name, disk_link.len);\n\t\tinode->i_link = ui->data;\n\t}\n\n\t \n\tui->data_len = disk_link.len - 1;\n\tinode->i_size = ubifs_inode(inode)->ui_size = disk_link.len - 1;\n\n\terr = ubifs_init_security(dir, inode, &dentry->d_name);\n\tif (err)\n\t\tgoto out_inode;\n\n\tmutex_lock(&dir_ui->ui_mutex);\n\tdir->i_size += sz_change;\n\tdir_ui->ui_size = dir->i_size;\n\tdir->i_mtime = inode_set_ctime_to_ts(dir, inode_get_ctime(inode));\n\terr = ubifs_jnl_update(c, dir, &nm, inode, 0, 0);\n\tif (err)\n\t\tgoto out_cancel;\n\tmutex_unlock(&dir_ui->ui_mutex);\n\n\tinsert_inode_hash(inode);\n\td_instantiate(dentry, inode);\n\terr = 0;\n\tgoto out_fname;\n\nout_cancel:\n\tdir->i_size -= sz_change;\n\tdir_ui->ui_size = dir->i_size;\n\tmutex_unlock(&dir_ui->ui_mutex);\nout_inode:\n\tmake_bad_inode(inode);\n\tiput(inode);\nout_fname:\n\tfscrypt_free_filename(&nm);\nout_budg:\n\tubifs_release_budget(c, &req);\n\treturn err;\n}\n\n \nstatic void lock_4_inodes(struct inode *inode1, struct inode *inode2,\n\t\t\t  struct inode *inode3, struct inode *inode4)\n{\n\tmutex_lock_nested(&ubifs_inode(inode1)->ui_mutex, WB_MUTEX_1);\n\tif (inode2 != inode1)\n\t\tmutex_lock_nested(&ubifs_inode(inode2)->ui_mutex, WB_MUTEX_2);\n\tif (inode3)\n\t\tmutex_lock_nested(&ubifs_inode(inode3)->ui_mutex, WB_MUTEX_3);\n\tif (inode4)\n\t\tmutex_lock_nested(&ubifs_inode(inode4)->ui_mutex, WB_MUTEX_4);\n}\n\n \nstatic void unlock_4_inodes(struct inode *inode1, struct inode *inode2,\n\t\t\t    struct inode *inode3, struct inode *inode4)\n{\n\tif (inode4)\n\t\tmutex_unlock(&ubifs_inode(inode4)->ui_mutex);\n\tif (inode3)\n\t\tmutex_unlock(&ubifs_inode(inode3)->ui_mutex);\n\tif (inode1 != inode2)\n\t\tmutex_unlock(&ubifs_inode(inode2)->ui_mutex);\n\tmutex_unlock(&ubifs_inode(inode1)->ui_mutex);\n}\n\nstatic int do_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t     struct inode *new_dir, struct dentry *new_dentry,\n\t\t     unsigned int flags)\n{\n\tstruct ubifs_info *c = old_dir->i_sb->s_fs_info;\n\tstruct inode *old_inode = d_inode(old_dentry);\n\tstruct inode *new_inode = d_inode(new_dentry);\n\tstruct inode *whiteout = NULL;\n\tstruct ubifs_inode *old_inode_ui = ubifs_inode(old_inode);\n\tstruct ubifs_inode *whiteout_ui = NULL;\n\tint err, release, sync = 0, move = (new_dir != old_dir);\n\tint is_dir = S_ISDIR(old_inode->i_mode);\n\tint unlink = !!new_inode, new_sz, old_sz;\n\tstruct ubifs_budget_req req = { .new_dent = 1, .mod_dent = 1,\n\t\t\t\t\t.dirtied_ino = 3 };\n\tstruct ubifs_budget_req ino_req = { .dirtied_ino = 1,\n\t\t\t.dirtied_ino_d = ALIGN(old_inode_ui->data_len, 8) };\n\tstruct ubifs_budget_req wht_req;\n\tunsigned int saved_nlink;\n\tstruct fscrypt_name old_nm, new_nm;\n\n\t \n\n\tdbg_gen(\"dent '%pd' ino %lu in dir ino %lu to dent '%pd' in dir ino %lu flags 0x%x\",\n\t\told_dentry, old_inode->i_ino, old_dir->i_ino,\n\t\tnew_dentry, new_dir->i_ino, flags);\n\n\tif (unlink) {\n\t\tubifs_assert(c, inode_is_locked(new_inode));\n\n\t\t \n\t\treq.dirtied_ino_d = ALIGN(ubifs_inode(new_inode)->data_len, 8);\n\t\terr = ubifs_purge_xattrs(new_inode);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (unlink && is_dir) {\n\t\terr = ubifs_check_dir_empty(new_inode);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = fscrypt_setup_filename(old_dir, &old_dentry->d_name, 0, &old_nm);\n\tif (err)\n\t\treturn err;\n\n\terr = fscrypt_setup_filename(new_dir, &new_dentry->d_name, 0, &new_nm);\n\tif (err) {\n\t\tfscrypt_free_filename(&old_nm);\n\t\treturn err;\n\t}\n\n\tnew_sz = CALC_DENT_SIZE(fname_len(&new_nm));\n\told_sz = CALC_DENT_SIZE(fname_len(&old_nm));\n\n\terr = ubifs_budget_space(c, &req);\n\tif (err) {\n\t\tfscrypt_free_filename(&old_nm);\n\t\tfscrypt_free_filename(&new_nm);\n\t\treturn err;\n\t}\n\terr = ubifs_budget_space(c, &ino_req);\n\tif (err) {\n\t\tfscrypt_free_filename(&old_nm);\n\t\tfscrypt_free_filename(&new_nm);\n\t\tubifs_release_budget(c, &req);\n\t\treturn err;\n\t}\n\n\tif (flags & RENAME_WHITEOUT) {\n\t\tunion ubifs_dev_desc *dev = NULL;\n\n\t\tdev = kmalloc(sizeof(union ubifs_dev_desc), GFP_NOFS);\n\t\tif (!dev) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_release;\n\t\t}\n\n\t\t \n\t\twhiteout = create_whiteout(old_dir, old_dentry);\n\t\tif (IS_ERR(whiteout)) {\n\t\t\terr = PTR_ERR(whiteout);\n\t\t\tkfree(dev);\n\t\t\tgoto out_release;\n\t\t}\n\n\t\twhiteout_ui = ubifs_inode(whiteout);\n\t\twhiteout_ui->data = dev;\n\t\twhiteout_ui->data_len = ubifs_encode_dev(dev, MKDEV(0, 0));\n\t\tubifs_assert(c, !whiteout_ui->dirty);\n\n\t\tmemset(&wht_req, 0, sizeof(struct ubifs_budget_req));\n\t\twht_req.new_ino = 1;\n\t\twht_req.new_ino_d = ALIGN(whiteout_ui->data_len, 8);\n\t\t \n\t\terr = ubifs_budget_space(c, &wht_req);\n\t\tif (err) {\n\t\t\t \n\t\t\tiput(whiteout);\n\t\t\tgoto out_release;\n\t\t}\n\n\t\t \n\t\told_sz -= CALC_DENT_SIZE(fname_len(&old_nm));\n\t}\n\n\tlock_4_inodes(old_dir, new_dir, new_inode, whiteout);\n\n\t \n\tsimple_rename_timestamp(old_dir, old_dentry, new_dir, new_dentry);\n\n\t \n\tif (is_dir) {\n\t\tif (move) {\n\t\t\t \n\t\t\tdrop_nlink(old_dir);\n\t\t\t \n\t\t\tif (!unlink)\n\t\t\t\tinc_nlink(new_dir);\n\t\t} else {\n\t\t\t \n\t\t\tif (unlink)\n\t\t\t\tdrop_nlink(old_dir);\n\t\t}\n\t}\n\n\told_dir->i_size -= old_sz;\n\tubifs_inode(old_dir)->ui_size = old_dir->i_size;\n\n\t \n\tif (unlink) {\n\t\t \n\t\tsaved_nlink = new_inode->i_nlink;\n\t\tif (is_dir)\n\t\t\tclear_nlink(new_inode);\n\t\telse\n\t\t\tdrop_nlink(new_inode);\n\t} else {\n\t\tnew_dir->i_size += new_sz;\n\t\tubifs_inode(new_dir)->ui_size = new_dir->i_size;\n\t}\n\n\t \n\tif (IS_SYNC(old_inode)) {\n\t\tsync = IS_DIRSYNC(old_dir) || IS_DIRSYNC(new_dir);\n\t\tif (unlink && IS_SYNC(new_inode))\n\t\t\tsync = 1;\n\t\t \n\t}\n\n\terr = ubifs_jnl_rename(c, old_dir, old_inode, &old_nm, new_dir,\n\t\t\t       new_inode, &new_nm, whiteout, sync);\n\tif (err)\n\t\tgoto out_cancel;\n\n\tunlock_4_inodes(old_dir, new_dir, new_inode, whiteout);\n\tubifs_release_budget(c, &req);\n\n\tif (whiteout) {\n\t\tubifs_release_budget(c, &wht_req);\n\t\tiput(whiteout);\n\t}\n\n\tmutex_lock(&old_inode_ui->ui_mutex);\n\trelease = old_inode_ui->dirty;\n\tmark_inode_dirty_sync(old_inode);\n\tmutex_unlock(&old_inode_ui->ui_mutex);\n\n\tif (release)\n\t\tubifs_release_budget(c, &ino_req);\n\tif (IS_SYNC(old_inode))\n\t\t \n\t\told_inode->i_sb->s_op->write_inode(old_inode, NULL);\n\n\tfscrypt_free_filename(&old_nm);\n\tfscrypt_free_filename(&new_nm);\n\treturn 0;\n\nout_cancel:\n\tif (unlink) {\n\t\tset_nlink(new_inode, saved_nlink);\n\t} else {\n\t\tnew_dir->i_size -= new_sz;\n\t\tubifs_inode(new_dir)->ui_size = new_dir->i_size;\n\t}\n\told_dir->i_size += old_sz;\n\tubifs_inode(old_dir)->ui_size = old_dir->i_size;\n\tif (is_dir) {\n\t\tif (move) {\n\t\t\tinc_nlink(old_dir);\n\t\t\tif (!unlink)\n\t\t\t\tdrop_nlink(new_dir);\n\t\t} else {\n\t\t\tif (unlink)\n\t\t\t\tinc_nlink(old_dir);\n\t\t}\n\t}\n\tunlock_4_inodes(old_dir, new_dir, new_inode, whiteout);\n\tif (whiteout) {\n\t\tubifs_release_budget(c, &wht_req);\n\t\tiput(whiteout);\n\t}\nout_release:\n\tubifs_release_budget(c, &ino_req);\n\tubifs_release_budget(c, &req);\n\tfscrypt_free_filename(&old_nm);\n\tfscrypt_free_filename(&new_nm);\n\treturn err;\n}\n\nstatic int ubifs_xrename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\tstruct inode *new_dir, struct dentry *new_dentry)\n{\n\tstruct ubifs_info *c = old_dir->i_sb->s_fs_info;\n\tstruct ubifs_budget_req req = { .new_dent = 1, .mod_dent = 1,\n\t\t\t\t.dirtied_ino = 2 };\n\tint sync = IS_DIRSYNC(old_dir) || IS_DIRSYNC(new_dir);\n\tstruct inode *fst_inode = d_inode(old_dentry);\n\tstruct inode *snd_inode = d_inode(new_dentry);\n\tint err;\n\tstruct fscrypt_name fst_nm, snd_nm;\n\n\tubifs_assert(c, fst_inode && snd_inode);\n\n\t \n\n\tdbg_gen(\"dent '%pd' ino %lu in dir ino %lu exchange dent '%pd' ino %lu in dir ino %lu\",\n\t\told_dentry, fst_inode->i_ino, old_dir->i_ino,\n\t\tnew_dentry, snd_inode->i_ino, new_dir->i_ino);\n\n\terr = fscrypt_setup_filename(old_dir, &old_dentry->d_name, 0, &fst_nm);\n\tif (err)\n\t\treturn err;\n\n\terr = fscrypt_setup_filename(new_dir, &new_dentry->d_name, 0, &snd_nm);\n\tif (err) {\n\t\tfscrypt_free_filename(&fst_nm);\n\t\treturn err;\n\t}\n\n\terr = ubifs_budget_space(c, &req);\n\tif (err)\n\t\tgoto out;\n\n\tlock_4_inodes(old_dir, new_dir, NULL, NULL);\n\n\tsimple_rename_timestamp(old_dir, old_dentry, new_dir, new_dentry);\n\n\tif (old_dir != new_dir) {\n\t\tif (S_ISDIR(fst_inode->i_mode) && !S_ISDIR(snd_inode->i_mode)) {\n\t\t\tinc_nlink(new_dir);\n\t\t\tdrop_nlink(old_dir);\n\t\t}\n\t\telse if (!S_ISDIR(fst_inode->i_mode) && S_ISDIR(snd_inode->i_mode)) {\n\t\t\tdrop_nlink(new_dir);\n\t\t\tinc_nlink(old_dir);\n\t\t}\n\t}\n\n\terr = ubifs_jnl_xrename(c, old_dir, fst_inode, &fst_nm, new_dir,\n\t\t\t\tsnd_inode, &snd_nm, sync);\n\n\tunlock_4_inodes(old_dir, new_dir, NULL, NULL);\n\tubifs_release_budget(c, &req);\n\nout:\n\tfscrypt_free_filename(&fst_nm);\n\tfscrypt_free_filename(&snd_nm);\n\treturn err;\n}\n\nstatic int ubifs_rename(struct mnt_idmap *idmap,\n\t\t\tstruct inode *old_dir, struct dentry *old_dentry,\n\t\t\tstruct inode *new_dir, struct dentry *new_dentry,\n\t\t\tunsigned int flags)\n{\n\tint err;\n\tstruct ubifs_info *c = old_dir->i_sb->s_fs_info;\n\n\tif (flags & ~(RENAME_NOREPLACE | RENAME_WHITEOUT | RENAME_EXCHANGE))\n\t\treturn -EINVAL;\n\n\tubifs_assert(c, inode_is_locked(old_dir));\n\tubifs_assert(c, inode_is_locked(new_dir));\n\n\terr = fscrypt_prepare_rename(old_dir, old_dentry, new_dir, new_dentry,\n\t\t\t\t     flags);\n\tif (err)\n\t\treturn err;\n\n\tif (flags & RENAME_EXCHANGE)\n\t\treturn ubifs_xrename(old_dir, old_dentry, new_dir, new_dentry);\n\n\treturn do_rename(old_dir, old_dentry, new_dir, new_dentry, flags);\n}\n\nint ubifs_getattr(struct mnt_idmap *idmap, const struct path *path,\n\t\t  struct kstat *stat, u32 request_mask, unsigned int flags)\n{\n\tloff_t size;\n\tstruct inode *inode = d_inode(path->dentry);\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\n\tmutex_lock(&ui->ui_mutex);\n\n\tif (ui->flags & UBIFS_APPEND_FL)\n\t\tstat->attributes |= STATX_ATTR_APPEND;\n\tif (ui->flags & UBIFS_COMPR_FL)\n\t\tstat->attributes |= STATX_ATTR_COMPRESSED;\n\tif (ui->flags & UBIFS_CRYPT_FL)\n\t\tstat->attributes |= STATX_ATTR_ENCRYPTED;\n\tif (ui->flags & UBIFS_IMMUTABLE_FL)\n\t\tstat->attributes |= STATX_ATTR_IMMUTABLE;\n\n\tstat->attributes_mask |= (STATX_ATTR_APPEND |\n\t\t\t\tSTATX_ATTR_COMPRESSED |\n\t\t\t\tSTATX_ATTR_ENCRYPTED |\n\t\t\t\tSTATX_ATTR_IMMUTABLE);\n\n\tgeneric_fillattr(&nop_mnt_idmap, request_mask, inode, stat);\n\tstat->blksize = UBIFS_BLOCK_SIZE;\n\tstat->size = ui->ui_size;\n\n\t \n\tif (S_ISREG(inode->i_mode)) {\n\t\tsize = ui->xattr_size;\n\t\tsize += stat->size;\n\t\tsize = ALIGN(size, UBIFS_BLOCK_SIZE);\n\t\t \n\t\tstat->blocks = size >> 9;\n\t} else\n\t\tstat->blocks = 0;\n\tmutex_unlock(&ui->ui_mutex);\n\treturn 0;\n}\n\nconst struct inode_operations ubifs_dir_inode_operations = {\n\t.lookup      = ubifs_lookup,\n\t.create      = ubifs_create,\n\t.link        = ubifs_link,\n\t.symlink     = ubifs_symlink,\n\t.unlink      = ubifs_unlink,\n\t.mkdir       = ubifs_mkdir,\n\t.rmdir       = ubifs_rmdir,\n\t.mknod       = ubifs_mknod,\n\t.rename      = ubifs_rename,\n\t.setattr     = ubifs_setattr,\n\t.getattr     = ubifs_getattr,\n\t.listxattr   = ubifs_listxattr,\n\t.update_time = ubifs_update_time,\n\t.tmpfile     = ubifs_tmpfile,\n\t.fileattr_get = ubifs_fileattr_get,\n\t.fileattr_set = ubifs_fileattr_set,\n};\n\nconst struct file_operations ubifs_dir_operations = {\n\t.llseek         = generic_file_llseek,\n\t.release        = ubifs_dir_release,\n\t.read           = generic_read_dir,\n\t.iterate_shared = ubifs_readdir,\n\t.fsync          = ubifs_fsync,\n\t.unlocked_ioctl = ubifs_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl   = ubifs_compat_ioctl,\n#endif\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}