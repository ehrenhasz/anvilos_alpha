{
  "module_name": "lpt.c",
  "hash_id": "004d9d60323a79d1de088258099475b4ca35ce122e28266be47e7ef00ab31b28",
  "original_prompt": "Ingested from linux-6.6.14/fs/ubifs/lpt.c",
  "human_readable_source": "\n \n\n \n\n#include \"ubifs.h\"\n#include <linux/crc16.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n\n \nstatic void do_calc_lpt_geom(struct ubifs_info *c)\n{\n\tint i, n, bits, per_leb_wastage, max_pnode_cnt;\n\tlong long sz, tot_wastage;\n\n\tn = c->main_lebs + c->max_leb_cnt - c->leb_cnt;\n\tmax_pnode_cnt = DIV_ROUND_UP(n, UBIFS_LPT_FANOUT);\n\n\tc->lpt_hght = 1;\n\tn = UBIFS_LPT_FANOUT;\n\twhile (n < max_pnode_cnt) {\n\t\tc->lpt_hght += 1;\n\t\tn <<= UBIFS_LPT_FANOUT_SHIFT;\n\t}\n\n\tc->pnode_cnt = DIV_ROUND_UP(c->main_lebs, UBIFS_LPT_FANOUT);\n\n\tn = DIV_ROUND_UP(c->pnode_cnt, UBIFS_LPT_FANOUT);\n\tc->nnode_cnt = n;\n\tfor (i = 1; i < c->lpt_hght; i++) {\n\t\tn = DIV_ROUND_UP(n, UBIFS_LPT_FANOUT);\n\t\tc->nnode_cnt += n;\n\t}\n\n\tc->space_bits = fls(c->leb_size) - 3;\n\tc->lpt_lnum_bits = fls(c->lpt_lebs);\n\tc->lpt_offs_bits = fls(c->leb_size - 1);\n\tc->lpt_spc_bits = fls(c->leb_size);\n\n\tn = DIV_ROUND_UP(c->max_leb_cnt, UBIFS_LPT_FANOUT);\n\tc->pcnt_bits = fls(n - 1);\n\n\tc->lnum_bits = fls(c->max_leb_cnt - 1);\n\n\tbits = UBIFS_LPT_CRC_BITS + UBIFS_LPT_TYPE_BITS +\n\t       (c->big_lpt ? c->pcnt_bits : 0) +\n\t       (c->space_bits * 2 + 1) * UBIFS_LPT_FANOUT;\n\tc->pnode_sz = (bits + 7) / 8;\n\n\tbits = UBIFS_LPT_CRC_BITS + UBIFS_LPT_TYPE_BITS +\n\t       (c->big_lpt ? c->pcnt_bits : 0) +\n\t       (c->lpt_lnum_bits + c->lpt_offs_bits) * UBIFS_LPT_FANOUT;\n\tc->nnode_sz = (bits + 7) / 8;\n\n\tbits = UBIFS_LPT_CRC_BITS + UBIFS_LPT_TYPE_BITS +\n\t       c->lpt_lebs * c->lpt_spc_bits * 2;\n\tc->ltab_sz = (bits + 7) / 8;\n\n\tbits = UBIFS_LPT_CRC_BITS + UBIFS_LPT_TYPE_BITS +\n\t       c->lnum_bits * c->lsave_cnt;\n\tc->lsave_sz = (bits + 7) / 8;\n\n\t \n\tc->lpt_sz = (long long)c->pnode_cnt * c->pnode_sz;\n\tc->lpt_sz += (long long)c->nnode_cnt * c->nnode_sz;\n\tc->lpt_sz += c->ltab_sz;\n\tif (c->big_lpt)\n\t\tc->lpt_sz += c->lsave_sz;\n\n\t \n\tsz = c->lpt_sz;\n\tper_leb_wastage = max_t(int, c->pnode_sz, c->nnode_sz);\n\tsz += per_leb_wastage;\n\ttot_wastage = per_leb_wastage;\n\twhile (sz > c->leb_size) {\n\t\tsz += per_leb_wastage;\n\t\tsz -= c->leb_size;\n\t\ttot_wastage += per_leb_wastage;\n\t}\n\ttot_wastage += ALIGN(sz, c->min_io_size) - sz;\n\tc->lpt_sz += tot_wastage;\n}\n\n \nint ubifs_calc_lpt_geom(struct ubifs_info *c)\n{\n\tint lebs_needed;\n\tlong long sz;\n\n\tdo_calc_lpt_geom(c);\n\n\t \n\tsz = c->lpt_sz * 2;  \n\tlebs_needed = div_u64(sz + c->leb_size - 1, c->leb_size);\n\tif (lebs_needed > c->lpt_lebs) {\n\t\tubifs_err(c, \"too few LPT LEBs\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (c->ltab_sz > c->leb_size) {\n\t\tubifs_err(c, \"LPT ltab too big\");\n\t\treturn -EINVAL;\n\t}\n\n\tc->check_lpt_free = c->big_lpt;\n\treturn 0;\n}\n\n \nstatic int calc_dflt_lpt_geom(struct ubifs_info *c, int *main_lebs,\n\t\t\t      int *big_lpt)\n{\n\tint i, lebs_needed;\n\tlong long sz;\n\n\t \n\tc->lpt_lebs = UBIFS_MIN_LPT_LEBS;\n\tc->main_lebs = *main_lebs - c->lpt_lebs;\n\tif (c->main_lebs <= 0)\n\t\treturn -EINVAL;\n\n\t \n\tc->big_lpt = 0;\n\n\t \n\tdo_calc_lpt_geom(c);\n\n\t \n\tif (c->lpt_sz > c->leb_size) {\n\t\t \n\t\tc->big_lpt = 1;\n\t\tdo_calc_lpt_geom(c);\n\t}\n\n\t \n\tfor (i = 0; i < 64 ; i++) {\n\t\tsz = c->lpt_sz * 4;  \n\t\tlebs_needed = div_u64(sz + c->leb_size - 1, c->leb_size);\n\t\tif (lebs_needed > c->lpt_lebs) {\n\t\t\t \n\t\t\tc->lpt_lebs = lebs_needed;\n\t\t\tc->main_lebs = *main_lebs - c->lpt_lebs;\n\t\t\tif (c->main_lebs <= 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tdo_calc_lpt_geom(c);\n\t\t\tcontinue;\n\t\t}\n\t\tif (c->ltab_sz > c->leb_size) {\n\t\t\tubifs_err(c, \"LPT ltab too big\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*main_lebs = c->main_lebs;\n\t\t*big_lpt = c->big_lpt;\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\n \nstatic void pack_bits(const struct ubifs_info *c, uint8_t **addr, int *pos, uint32_t val, int nrbits)\n{\n\tuint8_t *p = *addr;\n\tint b = *pos;\n\n\tubifs_assert(c, nrbits > 0);\n\tubifs_assert(c, nrbits <= 32);\n\tubifs_assert(c, *pos >= 0);\n\tubifs_assert(c, *pos < 8);\n\tubifs_assert(c, (val >> nrbits) == 0 || nrbits == 32);\n\tif (b) {\n\t\t*p |= ((uint8_t)val) << b;\n\t\tnrbits += b;\n\t\tif (nrbits > 8) {\n\t\t\t*++p = (uint8_t)(val >>= (8 - b));\n\t\t\tif (nrbits > 16) {\n\t\t\t\t*++p = (uint8_t)(val >>= 8);\n\t\t\t\tif (nrbits > 24) {\n\t\t\t\t\t*++p = (uint8_t)(val >>= 8);\n\t\t\t\t\tif (nrbits > 32)\n\t\t\t\t\t\t*++p = (uint8_t)(val >>= 8);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\t*p = (uint8_t)val;\n\t\tif (nrbits > 8) {\n\t\t\t*++p = (uint8_t)(val >>= 8);\n\t\t\tif (nrbits > 16) {\n\t\t\t\t*++p = (uint8_t)(val >>= 8);\n\t\t\t\tif (nrbits > 24)\n\t\t\t\t\t*++p = (uint8_t)(val >>= 8);\n\t\t\t}\n\t\t}\n\t}\n\tb = nrbits & 7;\n\tif (b == 0)\n\t\tp++;\n\t*addr = p;\n\t*pos = b;\n}\n\n \nuint32_t ubifs_unpack_bits(const struct ubifs_info *c, uint8_t **addr, int *pos, int nrbits)\n{\n\tconst int k = 32 - nrbits;\n\tuint8_t *p = *addr;\n\tint b = *pos;\n\tuint32_t val;\n\tconst int bytes = (nrbits + b + 7) >> 3;\n\n\tubifs_assert(c, nrbits > 0);\n\tubifs_assert(c, nrbits <= 32);\n\tubifs_assert(c, *pos >= 0);\n\tubifs_assert(c, *pos < 8);\n\tif (b) {\n\t\tswitch (bytes) {\n\t\tcase 2:\n\t\t\tval = p[1];\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tval = p[1] | ((uint32_t)p[2] << 8);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tval = p[1] | ((uint32_t)p[2] << 8) |\n\t\t\t\t     ((uint32_t)p[3] << 16);\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tval = p[1] | ((uint32_t)p[2] << 8) |\n\t\t\t\t     ((uint32_t)p[3] << 16) |\n\t\t\t\t     ((uint32_t)p[4] << 24);\n\t\t}\n\t\tval <<= (8 - b);\n\t\tval |= *p >> b;\n\t\tnrbits += b;\n\t} else {\n\t\tswitch (bytes) {\n\t\tcase 1:\n\t\t\tval = p[0];\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tval = p[0] | ((uint32_t)p[1] << 8);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tval = p[0] | ((uint32_t)p[1] << 8) |\n\t\t\t\t     ((uint32_t)p[2] << 16);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tval = p[0] | ((uint32_t)p[1] << 8) |\n\t\t\t\t     ((uint32_t)p[2] << 16) |\n\t\t\t\t     ((uint32_t)p[3] << 24);\n\t\t\tbreak;\n\t\t}\n\t}\n\tval <<= k;\n\tval >>= k;\n\tb = nrbits & 7;\n\tp += nrbits >> 3;\n\t*addr = p;\n\t*pos = b;\n\tubifs_assert(c, (val >> nrbits) == 0 || nrbits - b == 32);\n\treturn val;\n}\n\n \nvoid ubifs_pack_pnode(struct ubifs_info *c, void *buf,\n\t\t      struct ubifs_pnode *pnode)\n{\n\tuint8_t *addr = buf + UBIFS_LPT_CRC_BYTES;\n\tint i, pos = 0;\n\tuint16_t crc;\n\n\tpack_bits(c, &addr, &pos, UBIFS_LPT_PNODE, UBIFS_LPT_TYPE_BITS);\n\tif (c->big_lpt)\n\t\tpack_bits(c, &addr, &pos, pnode->num, c->pcnt_bits);\n\tfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\n\t\tpack_bits(c, &addr, &pos, pnode->lprops[i].free >> 3,\n\t\t\t  c->space_bits);\n\t\tpack_bits(c, &addr, &pos, pnode->lprops[i].dirty >> 3,\n\t\t\t  c->space_bits);\n\t\tif (pnode->lprops[i].flags & LPROPS_INDEX)\n\t\t\tpack_bits(c, &addr, &pos, 1, 1);\n\t\telse\n\t\t\tpack_bits(c, &addr, &pos, 0, 1);\n\t}\n\tcrc = crc16(-1, buf + UBIFS_LPT_CRC_BYTES,\n\t\t    c->pnode_sz - UBIFS_LPT_CRC_BYTES);\n\taddr = buf;\n\tpos = 0;\n\tpack_bits(c, &addr, &pos, crc, UBIFS_LPT_CRC_BITS);\n}\n\n \nvoid ubifs_pack_nnode(struct ubifs_info *c, void *buf,\n\t\t      struct ubifs_nnode *nnode)\n{\n\tuint8_t *addr = buf + UBIFS_LPT_CRC_BYTES;\n\tint i, pos = 0;\n\tuint16_t crc;\n\n\tpack_bits(c, &addr, &pos, UBIFS_LPT_NNODE, UBIFS_LPT_TYPE_BITS);\n\tif (c->big_lpt)\n\t\tpack_bits(c, &addr, &pos, nnode->num, c->pcnt_bits);\n\tfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\n\t\tint lnum = nnode->nbranch[i].lnum;\n\n\t\tif (lnum == 0)\n\t\t\tlnum = c->lpt_last + 1;\n\t\tpack_bits(c, &addr, &pos, lnum - c->lpt_first, c->lpt_lnum_bits);\n\t\tpack_bits(c, &addr, &pos, nnode->nbranch[i].offs,\n\t\t\t  c->lpt_offs_bits);\n\t}\n\tcrc = crc16(-1, buf + UBIFS_LPT_CRC_BYTES,\n\t\t    c->nnode_sz - UBIFS_LPT_CRC_BYTES);\n\taddr = buf;\n\tpos = 0;\n\tpack_bits(c, &addr, &pos, crc, UBIFS_LPT_CRC_BITS);\n}\n\n \nvoid ubifs_pack_ltab(struct ubifs_info *c, void *buf,\n\t\t     struct ubifs_lpt_lprops *ltab)\n{\n\tuint8_t *addr = buf + UBIFS_LPT_CRC_BYTES;\n\tint i, pos = 0;\n\tuint16_t crc;\n\n\tpack_bits(c, &addr, &pos, UBIFS_LPT_LTAB, UBIFS_LPT_TYPE_BITS);\n\tfor (i = 0; i < c->lpt_lebs; i++) {\n\t\tpack_bits(c, &addr, &pos, ltab[i].free, c->lpt_spc_bits);\n\t\tpack_bits(c, &addr, &pos, ltab[i].dirty, c->lpt_spc_bits);\n\t}\n\tcrc = crc16(-1, buf + UBIFS_LPT_CRC_BYTES,\n\t\t    c->ltab_sz - UBIFS_LPT_CRC_BYTES);\n\taddr = buf;\n\tpos = 0;\n\tpack_bits(c, &addr, &pos, crc, UBIFS_LPT_CRC_BITS);\n}\n\n \nvoid ubifs_pack_lsave(struct ubifs_info *c, void *buf, int *lsave)\n{\n\tuint8_t *addr = buf + UBIFS_LPT_CRC_BYTES;\n\tint i, pos = 0;\n\tuint16_t crc;\n\n\tpack_bits(c, &addr, &pos, UBIFS_LPT_LSAVE, UBIFS_LPT_TYPE_BITS);\n\tfor (i = 0; i < c->lsave_cnt; i++)\n\t\tpack_bits(c, &addr, &pos, lsave[i], c->lnum_bits);\n\tcrc = crc16(-1, buf + UBIFS_LPT_CRC_BYTES,\n\t\t    c->lsave_sz - UBIFS_LPT_CRC_BYTES);\n\taddr = buf;\n\tpos = 0;\n\tpack_bits(c, &addr, &pos, crc, UBIFS_LPT_CRC_BITS);\n}\n\n \nvoid ubifs_add_lpt_dirt(struct ubifs_info *c, int lnum, int dirty)\n{\n\tif (!dirty || !lnum)\n\t\treturn;\n\tdbg_lp(\"LEB %d add %d to %d\",\n\t       lnum, dirty, c->ltab[lnum - c->lpt_first].dirty);\n\tubifs_assert(c, lnum >= c->lpt_first && lnum <= c->lpt_last);\n\tc->ltab[lnum - c->lpt_first].dirty += dirty;\n}\n\n \nstatic void set_ltab(struct ubifs_info *c, int lnum, int free, int dirty)\n{\n\tdbg_lp(\"LEB %d free %d dirty %d to %d %d\",\n\t       lnum, c->ltab[lnum - c->lpt_first].free,\n\t       c->ltab[lnum - c->lpt_first].dirty, free, dirty);\n\tubifs_assert(c, lnum >= c->lpt_first && lnum <= c->lpt_last);\n\tc->ltab[lnum - c->lpt_first].free = free;\n\tc->ltab[lnum - c->lpt_first].dirty = dirty;\n}\n\n \nvoid ubifs_add_nnode_dirt(struct ubifs_info *c, struct ubifs_nnode *nnode)\n{\n\tstruct ubifs_nnode *np = nnode->parent;\n\n\tif (np)\n\t\tubifs_add_lpt_dirt(c, np->nbranch[nnode->iip].lnum,\n\t\t\t\t   c->nnode_sz);\n\telse {\n\t\tubifs_add_lpt_dirt(c, c->lpt_lnum, c->nnode_sz);\n\t\tif (!(c->lpt_drty_flgs & LTAB_DIRTY)) {\n\t\t\tc->lpt_drty_flgs |= LTAB_DIRTY;\n\t\t\tubifs_add_lpt_dirt(c, c->ltab_lnum, c->ltab_sz);\n\t\t}\n\t}\n}\n\n \nstatic void add_pnode_dirt(struct ubifs_info *c, struct ubifs_pnode *pnode)\n{\n\tubifs_add_lpt_dirt(c, pnode->parent->nbranch[pnode->iip].lnum,\n\t\t\t   c->pnode_sz);\n}\n\n \nstatic int calc_nnode_num(int row, int col)\n{\n\tint num, bits;\n\n\tnum = 1;\n\twhile (row--) {\n\t\tbits = (col & (UBIFS_LPT_FANOUT - 1));\n\t\tcol >>= UBIFS_LPT_FANOUT_SHIFT;\n\t\tnum <<= UBIFS_LPT_FANOUT_SHIFT;\n\t\tnum |= bits;\n\t}\n\treturn num;\n}\n\n \nstatic int calc_nnode_num_from_parent(const struct ubifs_info *c,\n\t\t\t\t      struct ubifs_nnode *parent, int iip)\n{\n\tint num, shft;\n\n\tif (!parent)\n\t\treturn 1;\n\tshft = (c->lpt_hght - parent->level) * UBIFS_LPT_FANOUT_SHIFT;\n\tnum = parent->num ^ (1 << shft);\n\tnum |= (UBIFS_LPT_FANOUT + iip) << shft;\n\treturn num;\n}\n\n \nstatic int calc_pnode_num_from_parent(const struct ubifs_info *c,\n\t\t\t\t      struct ubifs_nnode *parent, int iip)\n{\n\tint i, n = c->lpt_hght - 1, pnum = parent->num, num = 0;\n\n\tfor (i = 0; i < n; i++) {\n\t\tnum <<= UBIFS_LPT_FANOUT_SHIFT;\n\t\tnum |= pnum & (UBIFS_LPT_FANOUT - 1);\n\t\tpnum >>= UBIFS_LPT_FANOUT_SHIFT;\n\t}\n\tnum <<= UBIFS_LPT_FANOUT_SHIFT;\n\tnum |= iip;\n\treturn num;\n}\n\n \nint ubifs_create_dflt_lpt(struct ubifs_info *c, int *main_lebs, int lpt_first,\n\t\t\t  int *lpt_lebs, int *big_lpt, u8 *hash)\n{\n\tint lnum, err = 0, node_sz, iopos, i, j, cnt, len, alen, row;\n\tint blnum, boffs, bsz, bcnt;\n\tstruct ubifs_pnode *pnode = NULL;\n\tstruct ubifs_nnode *nnode = NULL;\n\tvoid *buf = NULL, *p;\n\tstruct ubifs_lpt_lprops *ltab = NULL;\n\tint *lsave = NULL;\n\tstruct shash_desc *desc;\n\n\terr = calc_dflt_lpt_geom(c, main_lebs, big_lpt);\n\tif (err)\n\t\treturn err;\n\t*lpt_lebs = c->lpt_lebs;\n\n\t \n\tc->lpt_first = lpt_first;\n\t \n\tc->lpt_last = lpt_first + c->lpt_lebs - 1;\n\t \n\tc->main_first = c->leb_cnt - *main_lebs;\n\n\tdesc = ubifs_hash_get_desc(c);\n\tif (IS_ERR(desc))\n\t\treturn PTR_ERR(desc);\n\n\tlsave = kmalloc_array(c->lsave_cnt, sizeof(int), GFP_KERNEL);\n\tpnode = kzalloc(sizeof(struct ubifs_pnode), GFP_KERNEL);\n\tnnode = kzalloc(sizeof(struct ubifs_nnode), GFP_KERNEL);\n\tbuf = vmalloc(c->leb_size);\n\tltab = vmalloc(array_size(sizeof(struct ubifs_lpt_lprops),\n\t\t\t\t  c->lpt_lebs));\n\tif (!pnode || !nnode || !buf || !ltab || !lsave) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tubifs_assert(c, !c->ltab);\n\tc->ltab = ltab;  \n\n\t \n\tfor (i = 0; i < c->lpt_lebs; i++) {\n\t\tltab[i].free = c->leb_size;\n\t\tltab[i].dirty = 0;\n\t\tltab[i].tgc = 0;\n\t\tltab[i].cmt = 0;\n\t}\n\n\tlnum = lpt_first;\n\tp = buf;\n\t \n\tcnt = c->pnode_cnt;\n\n\t \n\tnode_sz = ALIGN(ubifs_idx_node_sz(c, 1), 8);\n\tiopos = ALIGN(node_sz, c->min_io_size);\n\tpnode->lprops[0].free = c->leb_size - iopos;\n\tpnode->lprops[0].dirty = iopos - node_sz;\n\tpnode->lprops[0].flags = LPROPS_INDEX;\n\n\tnode_sz = UBIFS_INO_NODE_SZ;\n\tiopos = ALIGN(node_sz, c->min_io_size);\n\tpnode->lprops[1].free = c->leb_size - iopos;\n\tpnode->lprops[1].dirty = iopos - node_sz;\n\n\tfor (i = 2; i < UBIFS_LPT_FANOUT; i++)\n\t\tpnode->lprops[i].free = c->leb_size;\n\n\t \n\tubifs_pack_pnode(c, p, pnode);\n\terr = ubifs_shash_update(c, desc, p, c->pnode_sz);\n\tif (err)\n\t\tgoto out;\n\n\tp += c->pnode_sz;\n\tlen = c->pnode_sz;\n\tpnode->num += 1;\n\n\t \n\tpnode->lprops[0].free = c->leb_size;\n\tpnode->lprops[0].dirty = 0;\n\tpnode->lprops[0].flags = 0;\n\n\tpnode->lprops[1].free = c->leb_size;\n\tpnode->lprops[1].dirty = 0;\n\n\t \n\tblnum = lnum;  \n\tboffs = 0;  \n\tbcnt = cnt;  \n\tbsz = c->pnode_sz;  \n\n\t \n\tfor (i = 1; i < cnt; i++) {\n\t\tif (len + c->pnode_sz > c->leb_size) {\n\t\t\talen = ALIGN(len, c->min_io_size);\n\t\t\tset_ltab(c, lnum, c->leb_size - alen, alen - len);\n\t\t\tmemset(p, 0xff, alen - len);\n\t\t\terr = ubifs_leb_change(c, lnum++, buf, alen);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tp = buf;\n\t\t\tlen = 0;\n\t\t}\n\t\tubifs_pack_pnode(c, p, pnode);\n\t\terr = ubifs_shash_update(c, desc, p, c->pnode_sz);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tp += c->pnode_sz;\n\t\tlen += c->pnode_sz;\n\t\t \n\t\tpnode->num += 1;\n\t}\n\n\trow = 0;\n\tfor (i = UBIFS_LPT_FANOUT; cnt > i; i <<= UBIFS_LPT_FANOUT_SHIFT)\n\t\trow += 1;\n\t \n\twhile (1) {\n\t\t \n\t\tcnt = DIV_ROUND_UP(cnt, UBIFS_LPT_FANOUT);\n\t\tfor (i = 0; i < cnt; i++) {\n\t\t\tif (len + c->nnode_sz > c->leb_size) {\n\t\t\t\talen = ALIGN(len, c->min_io_size);\n\t\t\t\tset_ltab(c, lnum, c->leb_size - alen,\n\t\t\t\t\t    alen - len);\n\t\t\t\tmemset(p, 0xff, alen - len);\n\t\t\t\terr = ubifs_leb_change(c, lnum++, buf, alen);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out;\n\t\t\t\tp = buf;\n\t\t\t\tlen = 0;\n\t\t\t}\n\t\t\t \n\t\t\tif (cnt == 1) {\n\t\t\t\tc->lpt_lnum = lnum;\n\t\t\t\tc->lpt_offs = len;\n\t\t\t}\n\t\t\t \n\t\t\tfor (j = 0; j < UBIFS_LPT_FANOUT; j++) {\n\t\t\t\tif (bcnt) {\n\t\t\t\t\tif (boffs + bsz > c->leb_size) {\n\t\t\t\t\t\tblnum += 1;\n\t\t\t\t\t\tboffs = 0;\n\t\t\t\t\t}\n\t\t\t\t\tnnode->nbranch[j].lnum = blnum;\n\t\t\t\t\tnnode->nbranch[j].offs = boffs;\n\t\t\t\t\tboffs += bsz;\n\t\t\t\t\tbcnt--;\n\t\t\t\t} else {\n\t\t\t\t\tnnode->nbranch[j].lnum = 0;\n\t\t\t\t\tnnode->nbranch[j].offs = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnnode->num = calc_nnode_num(row, i);\n\t\t\tubifs_pack_nnode(c, p, nnode);\n\t\t\tp += c->nnode_sz;\n\t\t\tlen += c->nnode_sz;\n\t\t}\n\t\t \n\t\tif (cnt == 1)\n\t\t\tbreak;\n\t\t \n\t\tbcnt = cnt;\n\t\tbsz = c->nnode_sz;\n\t\trow -= 1;\n\t}\n\n\tif (*big_lpt) {\n\t\t \n\t\tif (len + c->lsave_sz > c->leb_size) {\n\t\t\talen = ALIGN(len, c->min_io_size);\n\t\t\tset_ltab(c, lnum, c->leb_size - alen, alen - len);\n\t\t\tmemset(p, 0xff, alen - len);\n\t\t\terr = ubifs_leb_change(c, lnum++, buf, alen);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tp = buf;\n\t\t\tlen = 0;\n\t\t}\n\n\t\tc->lsave_lnum = lnum;\n\t\tc->lsave_offs = len;\n\n\t\tfor (i = 0; i < c->lsave_cnt && i < *main_lebs; i++)\n\t\t\tlsave[i] = c->main_first + i;\n\t\tfor (; i < c->lsave_cnt; i++)\n\t\t\tlsave[i] = c->main_first;\n\n\t\tubifs_pack_lsave(c, p, lsave);\n\t\tp += c->lsave_sz;\n\t\tlen += c->lsave_sz;\n\t}\n\n\t \n\tif (len + c->ltab_sz > c->leb_size) {\n\t\talen = ALIGN(len, c->min_io_size);\n\t\tset_ltab(c, lnum, c->leb_size - alen, alen - len);\n\t\tmemset(p, 0xff, alen - len);\n\t\terr = ubifs_leb_change(c, lnum++, buf, alen);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tp = buf;\n\t\tlen = 0;\n\t}\n\n\tc->ltab_lnum = lnum;\n\tc->ltab_offs = len;\n\n\t \n\tlen += c->ltab_sz;\n\talen = ALIGN(len, c->min_io_size);\n\tset_ltab(c, lnum, c->leb_size - alen, alen - len);\n\n\tubifs_pack_ltab(c, p, ltab);\n\tp += c->ltab_sz;\n\n\t \n\tmemset(p, 0xff, alen - len);\n\terr = ubifs_leb_change(c, lnum, buf, alen);\n\tif (err)\n\t\tgoto out;\n\n\terr = ubifs_shash_final(c, desc, hash);\n\tif (err)\n\t\tgoto out;\n\n\tc->nhead_lnum = lnum;\n\tc->nhead_offs = ALIGN(len, c->min_io_size);\n\n\tdbg_lp(\"space_bits %d\", c->space_bits);\n\tdbg_lp(\"lpt_lnum_bits %d\", c->lpt_lnum_bits);\n\tdbg_lp(\"lpt_offs_bits %d\", c->lpt_offs_bits);\n\tdbg_lp(\"lpt_spc_bits %d\", c->lpt_spc_bits);\n\tdbg_lp(\"pcnt_bits %d\", c->pcnt_bits);\n\tdbg_lp(\"lnum_bits %d\", c->lnum_bits);\n\tdbg_lp(\"pnode_sz %d\", c->pnode_sz);\n\tdbg_lp(\"nnode_sz %d\", c->nnode_sz);\n\tdbg_lp(\"ltab_sz %d\", c->ltab_sz);\n\tdbg_lp(\"lsave_sz %d\", c->lsave_sz);\n\tdbg_lp(\"lsave_cnt %d\", c->lsave_cnt);\n\tdbg_lp(\"lpt_hght %d\", c->lpt_hght);\n\tdbg_lp(\"big_lpt %u\", c->big_lpt);\n\tdbg_lp(\"LPT root is at %d:%d\", c->lpt_lnum, c->lpt_offs);\n\tdbg_lp(\"LPT head is at %d:%d\", c->nhead_lnum, c->nhead_offs);\n\tdbg_lp(\"LPT ltab is at %d:%d\", c->ltab_lnum, c->ltab_offs);\n\tif (c->big_lpt)\n\t\tdbg_lp(\"LPT lsave is at %d:%d\", c->lsave_lnum, c->lsave_offs);\nout:\n\tc->ltab = NULL;\n\tkfree(desc);\n\tkfree(lsave);\n\tvfree(ltab);\n\tvfree(buf);\n\tkfree(nnode);\n\tkfree(pnode);\n\treturn err;\n}\n\n \nstatic void update_cats(struct ubifs_info *c, struct ubifs_pnode *pnode)\n{\n\tint i;\n\n\tfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\n\t\tint cat = pnode->lprops[i].flags & LPROPS_CAT_MASK;\n\t\tint lnum = pnode->lprops[i].lnum;\n\n\t\tif (!lnum)\n\t\t\treturn;\n\t\tubifs_add_to_cat(c, &pnode->lprops[i], cat);\n\t}\n}\n\n \nstatic void replace_cats(struct ubifs_info *c, struct ubifs_pnode *old_pnode,\n\t\t\t struct ubifs_pnode *new_pnode)\n{\n\tint i;\n\n\tfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\n\t\tif (!new_pnode->lprops[i].lnum)\n\t\t\treturn;\n\t\tubifs_replace_cat(c, &old_pnode->lprops[i],\n\t\t\t\t  &new_pnode->lprops[i]);\n\t}\n}\n\n \nstatic int check_lpt_crc(const struct ubifs_info *c, void *buf, int len)\n{\n\tint pos = 0;\n\tuint8_t *addr = buf;\n\tuint16_t crc, calc_crc;\n\n\tcrc = ubifs_unpack_bits(c, &addr, &pos, UBIFS_LPT_CRC_BITS);\n\tcalc_crc = crc16(-1, buf + UBIFS_LPT_CRC_BYTES,\n\t\t\t len - UBIFS_LPT_CRC_BYTES);\n\tif (crc != calc_crc) {\n\t\tubifs_err(c, \"invalid crc in LPT node: crc %hx calc %hx\",\n\t\t\t  crc, calc_crc);\n\t\tdump_stack();\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nstatic int check_lpt_type(const struct ubifs_info *c, uint8_t **addr,\n\t\t\t  int *pos, int type)\n{\n\tint node_type;\n\n\tnode_type = ubifs_unpack_bits(c, addr, pos, UBIFS_LPT_TYPE_BITS);\n\tif (node_type != type) {\n\t\tubifs_err(c, \"invalid type (%d) in LPT node type %d\",\n\t\t\t  node_type, type);\n\t\tdump_stack();\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nstatic int unpack_pnode(const struct ubifs_info *c, void *buf,\n\t\t\tstruct ubifs_pnode *pnode)\n{\n\tuint8_t *addr = buf + UBIFS_LPT_CRC_BYTES;\n\tint i, pos = 0, err;\n\n\terr = check_lpt_type(c, &addr, &pos, UBIFS_LPT_PNODE);\n\tif (err)\n\t\treturn err;\n\tif (c->big_lpt)\n\t\tpnode->num = ubifs_unpack_bits(c, &addr, &pos, c->pcnt_bits);\n\tfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\n\t\tstruct ubifs_lprops * const lprops = &pnode->lprops[i];\n\n\t\tlprops->free = ubifs_unpack_bits(c, &addr, &pos, c->space_bits);\n\t\tlprops->free <<= 3;\n\t\tlprops->dirty = ubifs_unpack_bits(c, &addr, &pos, c->space_bits);\n\t\tlprops->dirty <<= 3;\n\n\t\tif (ubifs_unpack_bits(c, &addr, &pos, 1))\n\t\t\tlprops->flags = LPROPS_INDEX;\n\t\telse\n\t\t\tlprops->flags = 0;\n\t\tlprops->flags |= ubifs_categorize_lprops(c, lprops);\n\t}\n\terr = check_lpt_crc(c, buf, c->pnode_sz);\n\treturn err;\n}\n\n \nint ubifs_unpack_nnode(const struct ubifs_info *c, void *buf,\n\t\t       struct ubifs_nnode *nnode)\n{\n\tuint8_t *addr = buf + UBIFS_LPT_CRC_BYTES;\n\tint i, pos = 0, err;\n\n\terr = check_lpt_type(c, &addr, &pos, UBIFS_LPT_NNODE);\n\tif (err)\n\t\treturn err;\n\tif (c->big_lpt)\n\t\tnnode->num = ubifs_unpack_bits(c, &addr, &pos, c->pcnt_bits);\n\tfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\n\t\tint lnum;\n\n\t\tlnum = ubifs_unpack_bits(c, &addr, &pos, c->lpt_lnum_bits) +\n\t\t       c->lpt_first;\n\t\tif (lnum == c->lpt_last + 1)\n\t\t\tlnum = 0;\n\t\tnnode->nbranch[i].lnum = lnum;\n\t\tnnode->nbranch[i].offs = ubifs_unpack_bits(c, &addr, &pos,\n\t\t\t\t\t\t     c->lpt_offs_bits);\n\t}\n\terr = check_lpt_crc(c, buf, c->nnode_sz);\n\treturn err;\n}\n\n \nstatic int unpack_ltab(const struct ubifs_info *c, void *buf)\n{\n\tuint8_t *addr = buf + UBIFS_LPT_CRC_BYTES;\n\tint i, pos = 0, err;\n\n\terr = check_lpt_type(c, &addr, &pos, UBIFS_LPT_LTAB);\n\tif (err)\n\t\treturn err;\n\tfor (i = 0; i < c->lpt_lebs; i++) {\n\t\tint free = ubifs_unpack_bits(c, &addr, &pos, c->lpt_spc_bits);\n\t\tint dirty = ubifs_unpack_bits(c, &addr, &pos, c->lpt_spc_bits);\n\n\t\tif (free < 0 || free > c->leb_size || dirty < 0 ||\n\t\t    dirty > c->leb_size || free + dirty > c->leb_size)\n\t\t\treturn -EINVAL;\n\n\t\tc->ltab[i].free = free;\n\t\tc->ltab[i].dirty = dirty;\n\t\tc->ltab[i].tgc = 0;\n\t\tc->ltab[i].cmt = 0;\n\t}\n\terr = check_lpt_crc(c, buf, c->ltab_sz);\n\treturn err;\n}\n\n \nstatic int unpack_lsave(const struct ubifs_info *c, void *buf)\n{\n\tuint8_t *addr = buf + UBIFS_LPT_CRC_BYTES;\n\tint i, pos = 0, err;\n\n\terr = check_lpt_type(c, &addr, &pos, UBIFS_LPT_LSAVE);\n\tif (err)\n\t\treturn err;\n\tfor (i = 0; i < c->lsave_cnt; i++) {\n\t\tint lnum = ubifs_unpack_bits(c, &addr, &pos, c->lnum_bits);\n\n\t\tif (lnum < c->main_first || lnum >= c->leb_cnt)\n\t\t\treturn -EINVAL;\n\t\tc->lsave[i] = lnum;\n\t}\n\terr = check_lpt_crc(c, buf, c->lsave_sz);\n\treturn err;\n}\n\n \nstatic int validate_nnode(const struct ubifs_info *c, struct ubifs_nnode *nnode,\n\t\t\t  struct ubifs_nnode *parent, int iip)\n{\n\tint i, lvl, max_offs;\n\n\tif (c->big_lpt) {\n\t\tint num = calc_nnode_num_from_parent(c, parent, iip);\n\n\t\tif (nnode->num != num)\n\t\t\treturn -EINVAL;\n\t}\n\tlvl = parent ? parent->level - 1 : c->lpt_hght;\n\tif (lvl < 1)\n\t\treturn -EINVAL;\n\tif (lvl == 1)\n\t\tmax_offs = c->leb_size - c->pnode_sz;\n\telse\n\t\tmax_offs = c->leb_size - c->nnode_sz;\n\tfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\n\t\tint lnum = nnode->nbranch[i].lnum;\n\t\tint offs = nnode->nbranch[i].offs;\n\n\t\tif (lnum == 0) {\n\t\t\tif (offs != 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tcontinue;\n\t\t}\n\t\tif (lnum < c->lpt_first || lnum > c->lpt_last)\n\t\t\treturn -EINVAL;\n\t\tif (offs < 0 || offs > max_offs)\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nstatic int validate_pnode(const struct ubifs_info *c, struct ubifs_pnode *pnode,\n\t\t\t  struct ubifs_nnode *parent, int iip)\n{\n\tint i;\n\n\tif (c->big_lpt) {\n\t\tint num = calc_pnode_num_from_parent(c, parent, iip);\n\n\t\tif (pnode->num != num)\n\t\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\n\t\tint free = pnode->lprops[i].free;\n\t\tint dirty = pnode->lprops[i].dirty;\n\n\t\tif (free < 0 || free > c->leb_size || free % c->min_io_size ||\n\t\t    (free & 7))\n\t\t\treturn -EINVAL;\n\t\tif (dirty < 0 || dirty > c->leb_size || (dirty & 7))\n\t\t\treturn -EINVAL;\n\t\tif (dirty + free > c->leb_size)\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nstatic void set_pnode_lnum(const struct ubifs_info *c,\n\t\t\t   struct ubifs_pnode *pnode)\n{\n\tint i, lnum;\n\n\tlnum = (pnode->num << UBIFS_LPT_FANOUT_SHIFT) + c->main_first;\n\tfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\n\t\tif (lnum >= c->leb_cnt)\n\t\t\treturn;\n\t\tpnode->lprops[i].lnum = lnum++;\n\t}\n}\n\n \nint ubifs_read_nnode(struct ubifs_info *c, struct ubifs_nnode *parent, int iip)\n{\n\tstruct ubifs_nbranch *branch = NULL;\n\tstruct ubifs_nnode *nnode = NULL;\n\tvoid *buf = c->lpt_nod_buf;\n\tint err, lnum, offs;\n\n\tif (parent) {\n\t\tbranch = &parent->nbranch[iip];\n\t\tlnum = branch->lnum;\n\t\toffs = branch->offs;\n\t} else {\n\t\tlnum = c->lpt_lnum;\n\t\toffs = c->lpt_offs;\n\t}\n\tnnode = kzalloc(sizeof(struct ubifs_nnode), GFP_NOFS);\n\tif (!nnode) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\tif (lnum == 0) {\n\t\t \n\t\tif (c->big_lpt)\n\t\t\tnnode->num = calc_nnode_num_from_parent(c, parent, iip);\n\t} else {\n\t\terr = ubifs_leb_read(c, lnum, buf, offs, c->nnode_sz, 1);\n\t\tif (err)\n\t\t\tgoto out;\n\t\terr = ubifs_unpack_nnode(c, buf, nnode);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\terr = validate_nnode(c, nnode, parent, iip);\n\tif (err)\n\t\tgoto out;\n\tif (!c->big_lpt)\n\t\tnnode->num = calc_nnode_num_from_parent(c, parent, iip);\n\tif (parent) {\n\t\tbranch->nnode = nnode;\n\t\tnnode->level = parent->level - 1;\n\t} else {\n\t\tc->nroot = nnode;\n\t\tnnode->level = c->lpt_hght;\n\t}\n\tnnode->parent = parent;\n\tnnode->iip = iip;\n\treturn 0;\n\nout:\n\tubifs_err(c, \"error %d reading nnode at %d:%d\", err, lnum, offs);\n\tdump_stack();\n\tkfree(nnode);\n\treturn err;\n}\n\n \nstatic int read_pnode(struct ubifs_info *c, struct ubifs_nnode *parent, int iip)\n{\n\tstruct ubifs_nbranch *branch;\n\tstruct ubifs_pnode *pnode = NULL;\n\tvoid *buf = c->lpt_nod_buf;\n\tint err, lnum, offs;\n\n\tbranch = &parent->nbranch[iip];\n\tlnum = branch->lnum;\n\toffs = branch->offs;\n\tpnode = kzalloc(sizeof(struct ubifs_pnode), GFP_NOFS);\n\tif (!pnode)\n\t\treturn -ENOMEM;\n\n\tif (lnum == 0) {\n\t\t \n\t\tint i;\n\n\t\tif (c->big_lpt)\n\t\t\tpnode->num = calc_pnode_num_from_parent(c, parent, iip);\n\t\tfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\n\t\t\tstruct ubifs_lprops * const lprops = &pnode->lprops[i];\n\n\t\t\tlprops->free = c->leb_size;\n\t\t\tlprops->flags = ubifs_categorize_lprops(c, lprops);\n\t\t}\n\t} else {\n\t\terr = ubifs_leb_read(c, lnum, buf, offs, c->pnode_sz, 1);\n\t\tif (err)\n\t\t\tgoto out;\n\t\terr = unpack_pnode(c, buf, pnode);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\terr = validate_pnode(c, pnode, parent, iip);\n\tif (err)\n\t\tgoto out;\n\tif (!c->big_lpt)\n\t\tpnode->num = calc_pnode_num_from_parent(c, parent, iip);\n\tbranch->pnode = pnode;\n\tpnode->parent = parent;\n\tpnode->iip = iip;\n\tset_pnode_lnum(c, pnode);\n\tc->pnodes_have += 1;\n\treturn 0;\n\nout:\n\tubifs_err(c, \"error %d reading pnode at %d:%d\", err, lnum, offs);\n\tubifs_dump_pnode(c, pnode, parent, iip);\n\tdump_stack();\n\tubifs_err(c, \"calc num: %d\", calc_pnode_num_from_parent(c, parent, iip));\n\tkfree(pnode);\n\treturn err;\n}\n\n \nstatic int read_ltab(struct ubifs_info *c)\n{\n\tint err;\n\tvoid *buf;\n\n\tbuf = vmalloc(c->ltab_sz);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\terr = ubifs_leb_read(c, c->ltab_lnum, buf, c->ltab_offs, c->ltab_sz, 1);\n\tif (err)\n\t\tgoto out;\n\terr = unpack_ltab(c, buf);\nout:\n\tvfree(buf);\n\treturn err;\n}\n\n \nstatic int read_lsave(struct ubifs_info *c)\n{\n\tint err, i;\n\tvoid *buf;\n\n\tbuf = vmalloc(c->lsave_sz);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\terr = ubifs_leb_read(c, c->lsave_lnum, buf, c->lsave_offs,\n\t\t\t     c->lsave_sz, 1);\n\tif (err)\n\t\tgoto out;\n\terr = unpack_lsave(c, buf);\n\tif (err)\n\t\tgoto out;\n\tfor (i = 0; i < c->lsave_cnt; i++) {\n\t\tint lnum = c->lsave[i];\n\t\tstruct ubifs_lprops *lprops;\n\n\t\t \n\t\tif (lnum >= c->leb_cnt)\n\t\t\tcontinue;\n\t\tlprops = ubifs_lpt_lookup(c, lnum);\n\t\tif (IS_ERR(lprops)) {\n\t\t\terr = PTR_ERR(lprops);\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tvfree(buf);\n\treturn err;\n}\n\n \nstruct ubifs_nnode *ubifs_get_nnode(struct ubifs_info *c,\n\t\t\t\t    struct ubifs_nnode *parent, int iip)\n{\n\tstruct ubifs_nbranch *branch;\n\tstruct ubifs_nnode *nnode;\n\tint err;\n\n\tbranch = &parent->nbranch[iip];\n\tnnode = branch->nnode;\n\tif (nnode)\n\t\treturn nnode;\n\terr = ubifs_read_nnode(c, parent, iip);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\treturn branch->nnode;\n}\n\n \nstruct ubifs_pnode *ubifs_get_pnode(struct ubifs_info *c,\n\t\t\t\t    struct ubifs_nnode *parent, int iip)\n{\n\tstruct ubifs_nbranch *branch;\n\tstruct ubifs_pnode *pnode;\n\tint err;\n\n\tbranch = &parent->nbranch[iip];\n\tpnode = branch->pnode;\n\tif (pnode)\n\t\treturn pnode;\n\terr = read_pnode(c, parent, iip);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\tupdate_cats(c, branch->pnode);\n\treturn branch->pnode;\n}\n\n \nstruct ubifs_pnode *ubifs_pnode_lookup(struct ubifs_info *c, int i)\n{\n\tint err, h, iip, shft;\n\tstruct ubifs_nnode *nnode;\n\n\tif (!c->nroot) {\n\t\terr = ubifs_read_nnode(c, NULL, 0);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\t}\n\ti <<= UBIFS_LPT_FANOUT_SHIFT;\n\tnnode = c->nroot;\n\tshft = c->lpt_hght * UBIFS_LPT_FANOUT_SHIFT;\n\tfor (h = 1; h < c->lpt_hght; h++) {\n\t\tiip = ((i >> shft) & (UBIFS_LPT_FANOUT - 1));\n\t\tshft -= UBIFS_LPT_FANOUT_SHIFT;\n\t\tnnode = ubifs_get_nnode(c, nnode, iip);\n\t\tif (IS_ERR(nnode))\n\t\t\treturn ERR_CAST(nnode);\n\t}\n\tiip = ((i >> shft) & (UBIFS_LPT_FANOUT - 1));\n\treturn ubifs_get_pnode(c, nnode, iip);\n}\n\n \nstruct ubifs_lprops *ubifs_lpt_lookup(struct ubifs_info *c, int lnum)\n{\n\tint i, iip;\n\tstruct ubifs_pnode *pnode;\n\n\ti = lnum - c->main_first;\n\tpnode = ubifs_pnode_lookup(c, i >> UBIFS_LPT_FANOUT_SHIFT);\n\tif (IS_ERR(pnode))\n\t\treturn ERR_CAST(pnode);\n\tiip = (i & (UBIFS_LPT_FANOUT - 1));\n\tdbg_lp(\"LEB %d, free %d, dirty %d, flags %d\", lnum,\n\t       pnode->lprops[iip].free, pnode->lprops[iip].dirty,\n\t       pnode->lprops[iip].flags);\n\treturn &pnode->lprops[iip];\n}\n\n \nstatic struct ubifs_nnode *dirty_cow_nnode(struct ubifs_info *c,\n\t\t\t\t\t   struct ubifs_nnode *nnode)\n{\n\tstruct ubifs_nnode *n;\n\tint i;\n\n\tif (!test_bit(COW_CNODE, &nnode->flags)) {\n\t\t \n\t\tif (!test_and_set_bit(DIRTY_CNODE, &nnode->flags)) {\n\t\t\tc->dirty_nn_cnt += 1;\n\t\t\tubifs_add_nnode_dirt(c, nnode);\n\t\t}\n\t\treturn nnode;\n\t}\n\n\t \n\tn = kmemdup(nnode, sizeof(struct ubifs_nnode), GFP_NOFS);\n\tif (unlikely(!n))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tn->cnext = NULL;\n\t__set_bit(DIRTY_CNODE, &n->flags);\n\t__clear_bit(COW_CNODE, &n->flags);\n\n\t \n\tfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\n\t\tstruct ubifs_nbranch *branch = &n->nbranch[i];\n\n\t\tif (branch->cnode)\n\t\t\tbranch->cnode->parent = n;\n\t}\n\n\tubifs_assert(c, !test_bit(OBSOLETE_CNODE, &nnode->flags));\n\t__set_bit(OBSOLETE_CNODE, &nnode->flags);\n\n\tc->dirty_nn_cnt += 1;\n\tubifs_add_nnode_dirt(c, nnode);\n\tif (nnode->parent)\n\t\tnnode->parent->nbranch[n->iip].nnode = n;\n\telse\n\t\tc->nroot = n;\n\treturn n;\n}\n\n \nstatic struct ubifs_pnode *dirty_cow_pnode(struct ubifs_info *c,\n\t\t\t\t\t   struct ubifs_pnode *pnode)\n{\n\tstruct ubifs_pnode *p;\n\n\tif (!test_bit(COW_CNODE, &pnode->flags)) {\n\t\t \n\t\tif (!test_and_set_bit(DIRTY_CNODE, &pnode->flags)) {\n\t\t\tc->dirty_pn_cnt += 1;\n\t\t\tadd_pnode_dirt(c, pnode);\n\t\t}\n\t\treturn pnode;\n\t}\n\n\t \n\tp = kmemdup(pnode, sizeof(struct ubifs_pnode), GFP_NOFS);\n\tif (unlikely(!p))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tp->cnext = NULL;\n\t__set_bit(DIRTY_CNODE, &p->flags);\n\t__clear_bit(COW_CNODE, &p->flags);\n\treplace_cats(c, pnode, p);\n\n\tubifs_assert(c, !test_bit(OBSOLETE_CNODE, &pnode->flags));\n\t__set_bit(OBSOLETE_CNODE, &pnode->flags);\n\n\tc->dirty_pn_cnt += 1;\n\tadd_pnode_dirt(c, pnode);\n\tpnode->parent->nbranch[p->iip].pnode = p;\n\treturn p;\n}\n\n \nstruct ubifs_lprops *ubifs_lpt_lookup_dirty(struct ubifs_info *c, int lnum)\n{\n\tint err, i, h, iip, shft;\n\tstruct ubifs_nnode *nnode;\n\tstruct ubifs_pnode *pnode;\n\n\tif (!c->nroot) {\n\t\terr = ubifs_read_nnode(c, NULL, 0);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\t}\n\tnnode = c->nroot;\n\tnnode = dirty_cow_nnode(c, nnode);\n\tif (IS_ERR(nnode))\n\t\treturn ERR_CAST(nnode);\n\ti = lnum - c->main_first;\n\tshft = c->lpt_hght * UBIFS_LPT_FANOUT_SHIFT;\n\tfor (h = 1; h < c->lpt_hght; h++) {\n\t\tiip = ((i >> shft) & (UBIFS_LPT_FANOUT - 1));\n\t\tshft -= UBIFS_LPT_FANOUT_SHIFT;\n\t\tnnode = ubifs_get_nnode(c, nnode, iip);\n\t\tif (IS_ERR(nnode))\n\t\t\treturn ERR_CAST(nnode);\n\t\tnnode = dirty_cow_nnode(c, nnode);\n\t\tif (IS_ERR(nnode))\n\t\t\treturn ERR_CAST(nnode);\n\t}\n\tiip = ((i >> shft) & (UBIFS_LPT_FANOUT - 1));\n\tpnode = ubifs_get_pnode(c, nnode, iip);\n\tif (IS_ERR(pnode))\n\t\treturn ERR_CAST(pnode);\n\tpnode = dirty_cow_pnode(c, pnode);\n\tif (IS_ERR(pnode))\n\t\treturn ERR_CAST(pnode);\n\tiip = (i & (UBIFS_LPT_FANOUT - 1));\n\tdbg_lp(\"LEB %d, free %d, dirty %d, flags %d\", lnum,\n\t       pnode->lprops[iip].free, pnode->lprops[iip].dirty,\n\t       pnode->lprops[iip].flags);\n\tubifs_assert(c, test_bit(DIRTY_CNODE, &pnode->flags));\n\treturn &pnode->lprops[iip];\n}\n\n \nint ubifs_lpt_calc_hash(struct ubifs_info *c, u8 *hash)\n{\n\tstruct ubifs_nnode *nnode, *nn;\n\tstruct ubifs_cnode *cnode;\n\tstruct shash_desc *desc;\n\tint iip = 0, i;\n\tint bufsiz = max_t(int, c->nnode_sz, c->pnode_sz);\n\tvoid *buf;\n\tint err;\n\n\tif (!ubifs_authenticated(c))\n\t\treturn 0;\n\n\tif (!c->nroot) {\n\t\terr = ubifs_read_nnode(c, NULL, 0);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tdesc = ubifs_hash_get_desc(c);\n\tif (IS_ERR(desc))\n\t\treturn PTR_ERR(desc);\n\n\tbuf = kmalloc(bufsiz, GFP_NOFS);\n\tif (!buf) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tcnode = (struct ubifs_cnode *)c->nroot;\n\n\twhile (cnode) {\n\t\tnnode = cnode->parent;\n\t\tnn = (struct ubifs_nnode *)cnode;\n\t\tif (cnode->level > 1) {\n\t\t\twhile (iip < UBIFS_LPT_FANOUT) {\n\t\t\t\tif (nn->nbranch[iip].lnum == 0) {\n\t\t\t\t\t \n\t\t\t\t\tiip++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tnnode = ubifs_get_nnode(c, nn, iip);\n\t\t\t\tif (IS_ERR(nnode)) {\n\t\t\t\t\terr = PTR_ERR(nnode);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tiip = 0;\n\t\t\t\tcnode = (struct ubifs_cnode *)nnode;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (iip < UBIFS_LPT_FANOUT)\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tstruct ubifs_pnode *pnode;\n\n\t\t\tfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\n\t\t\t\tif (nn->nbranch[i].lnum == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tpnode = ubifs_get_pnode(c, nn, i);\n\t\t\t\tif (IS_ERR(pnode)) {\n\t\t\t\t\terr = PTR_ERR(pnode);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tubifs_pack_pnode(c, buf, pnode);\n\t\t\t\terr = ubifs_shash_update(c, desc, buf,\n\t\t\t\t\t\t\t c->pnode_sz);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\t \n\t\tiip = cnode->iip + 1;\n\t\tcnode = (struct ubifs_cnode *)nnode;\n\t}\n\n\terr = ubifs_shash_final(c, desc, hash);\nout:\n\tkfree(desc);\n\tkfree(buf);\n\n\treturn err;\n}\n\n \nstatic int lpt_check_hash(struct ubifs_info *c)\n{\n\tint err;\n\tu8 hash[UBIFS_HASH_ARR_SZ];\n\n\tif (!ubifs_authenticated(c))\n\t\treturn 0;\n\n\terr = ubifs_lpt_calc_hash(c, hash);\n\tif (err)\n\t\treturn err;\n\n\tif (ubifs_check_hash(c, c->mst_node->hash_lpt, hash)) {\n\t\terr = -EPERM;\n\t\tubifs_err(c, \"Failed to authenticate LPT\");\n\t} else {\n\t\terr = 0;\n\t}\n\n\treturn err;\n}\n\n \nstatic int lpt_init_rd(struct ubifs_info *c)\n{\n\tint err, i;\n\n\tc->ltab = vmalloc(array_size(sizeof(struct ubifs_lpt_lprops),\n\t\t\t\t     c->lpt_lebs));\n\tif (!c->ltab)\n\t\treturn -ENOMEM;\n\n\ti = max_t(int, c->nnode_sz, c->pnode_sz);\n\tc->lpt_nod_buf = kmalloc(i, GFP_KERNEL);\n\tif (!c->lpt_nod_buf)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < LPROPS_HEAP_CNT; i++) {\n\t\tc->lpt_heap[i].arr = kmalloc_array(LPT_HEAP_SZ,\n\t\t\t\t\t\t   sizeof(void *),\n\t\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!c->lpt_heap[i].arr)\n\t\t\treturn -ENOMEM;\n\t\tc->lpt_heap[i].cnt = 0;\n\t\tc->lpt_heap[i].max_cnt = LPT_HEAP_SZ;\n\t}\n\n\tc->dirty_idx.arr = kmalloc_array(LPT_HEAP_SZ, sizeof(void *),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!c->dirty_idx.arr)\n\t\treturn -ENOMEM;\n\tc->dirty_idx.cnt = 0;\n\tc->dirty_idx.max_cnt = LPT_HEAP_SZ;\n\n\terr = read_ltab(c);\n\tif (err)\n\t\treturn err;\n\n\terr = lpt_check_hash(c);\n\tif (err)\n\t\treturn err;\n\n\tdbg_lp(\"space_bits %d\", c->space_bits);\n\tdbg_lp(\"lpt_lnum_bits %d\", c->lpt_lnum_bits);\n\tdbg_lp(\"lpt_offs_bits %d\", c->lpt_offs_bits);\n\tdbg_lp(\"lpt_spc_bits %d\", c->lpt_spc_bits);\n\tdbg_lp(\"pcnt_bits %d\", c->pcnt_bits);\n\tdbg_lp(\"lnum_bits %d\", c->lnum_bits);\n\tdbg_lp(\"pnode_sz %d\", c->pnode_sz);\n\tdbg_lp(\"nnode_sz %d\", c->nnode_sz);\n\tdbg_lp(\"ltab_sz %d\", c->ltab_sz);\n\tdbg_lp(\"lsave_sz %d\", c->lsave_sz);\n\tdbg_lp(\"lsave_cnt %d\", c->lsave_cnt);\n\tdbg_lp(\"lpt_hght %d\", c->lpt_hght);\n\tdbg_lp(\"big_lpt %u\", c->big_lpt);\n\tdbg_lp(\"LPT root is at %d:%d\", c->lpt_lnum, c->lpt_offs);\n\tdbg_lp(\"LPT head is at %d:%d\", c->nhead_lnum, c->nhead_offs);\n\tdbg_lp(\"LPT ltab is at %d:%d\", c->ltab_lnum, c->ltab_offs);\n\tif (c->big_lpt)\n\t\tdbg_lp(\"LPT lsave is at %d:%d\", c->lsave_lnum, c->lsave_offs);\n\n\treturn 0;\n}\n\n \nstatic int lpt_init_wr(struct ubifs_info *c)\n{\n\tint err, i;\n\n\tc->ltab_cmt = vmalloc(array_size(sizeof(struct ubifs_lpt_lprops),\n\t\t\t\t\t c->lpt_lebs));\n\tif (!c->ltab_cmt)\n\t\treturn -ENOMEM;\n\n\tc->lpt_buf = vmalloc(c->leb_size);\n\tif (!c->lpt_buf)\n\t\treturn -ENOMEM;\n\n\tif (c->big_lpt) {\n\t\tc->lsave = kmalloc_array(c->lsave_cnt, sizeof(int), GFP_NOFS);\n\t\tif (!c->lsave)\n\t\t\treturn -ENOMEM;\n\t\terr = read_lsave(c);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tfor (i = 0; i < c->lpt_lebs; i++)\n\t\tif (c->ltab[i].free == c->leb_size) {\n\t\t\terr = ubifs_leb_unmap(c, i + c->lpt_first);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\treturn 0;\n}\n\n \nint ubifs_lpt_init(struct ubifs_info *c, int rd, int wr)\n{\n\tint err;\n\n\tif (rd) {\n\t\terr = lpt_init_rd(c);\n\t\tif (err)\n\t\t\tgoto out_err;\n\t}\n\n\tif (wr) {\n\t\terr = lpt_init_wr(c);\n\t\tif (err)\n\t\t\tgoto out_err;\n\t}\n\n\treturn 0;\n\nout_err:\n\tif (wr)\n\t\tubifs_lpt_free(c, 1);\n\tif (rd)\n\t\tubifs_lpt_free(c, 0);\n\treturn err;\n}\n\n \nstruct lpt_scan_node {\n\tunion {\n\t\tstruct ubifs_nnode nnode;\n\t\tstruct ubifs_pnode pnode;\n\t\tstruct ubifs_cnode cnode;\n\t};\n\tint in_tree;\n\tunion {\n\t\tstruct ubifs_nnode *nnode;\n\t\tstruct ubifs_pnode *pnode;\n\t\tstruct ubifs_cnode *cnode;\n\t} ptr;\n};\n\n \nstatic struct ubifs_nnode *scan_get_nnode(struct ubifs_info *c,\n\t\t\t\t\t  struct lpt_scan_node *path,\n\t\t\t\t\t  struct ubifs_nnode *parent, int iip)\n{\n\tstruct ubifs_nbranch *branch;\n\tstruct ubifs_nnode *nnode;\n\tvoid *buf = c->lpt_nod_buf;\n\tint err;\n\n\tbranch = &parent->nbranch[iip];\n\tnnode = branch->nnode;\n\tif (nnode) {\n\t\tpath->in_tree = 1;\n\t\tpath->ptr.nnode = nnode;\n\t\treturn nnode;\n\t}\n\tnnode = &path->nnode;\n\tpath->in_tree = 0;\n\tpath->ptr.nnode = nnode;\n\tmemset(nnode, 0, sizeof(struct ubifs_nnode));\n\tif (branch->lnum == 0) {\n\t\t \n\t\tif (c->big_lpt)\n\t\t\tnnode->num = calc_nnode_num_from_parent(c, parent, iip);\n\t} else {\n\t\terr = ubifs_leb_read(c, branch->lnum, buf, branch->offs,\n\t\t\t\t     c->nnode_sz, 1);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\t\terr = ubifs_unpack_nnode(c, buf, nnode);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\t}\n\terr = validate_nnode(c, nnode, parent, iip);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\tif (!c->big_lpt)\n\t\tnnode->num = calc_nnode_num_from_parent(c, parent, iip);\n\tnnode->level = parent->level - 1;\n\tnnode->parent = parent;\n\tnnode->iip = iip;\n\treturn nnode;\n}\n\n \nstatic struct ubifs_pnode *scan_get_pnode(struct ubifs_info *c,\n\t\t\t\t\t  struct lpt_scan_node *path,\n\t\t\t\t\t  struct ubifs_nnode *parent, int iip)\n{\n\tstruct ubifs_nbranch *branch;\n\tstruct ubifs_pnode *pnode;\n\tvoid *buf = c->lpt_nod_buf;\n\tint err;\n\n\tbranch = &parent->nbranch[iip];\n\tpnode = branch->pnode;\n\tif (pnode) {\n\t\tpath->in_tree = 1;\n\t\tpath->ptr.pnode = pnode;\n\t\treturn pnode;\n\t}\n\tpnode = &path->pnode;\n\tpath->in_tree = 0;\n\tpath->ptr.pnode = pnode;\n\tmemset(pnode, 0, sizeof(struct ubifs_pnode));\n\tif (branch->lnum == 0) {\n\t\t \n\t\tint i;\n\n\t\tif (c->big_lpt)\n\t\t\tpnode->num = calc_pnode_num_from_parent(c, parent, iip);\n\t\tfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\n\t\t\tstruct ubifs_lprops * const lprops = &pnode->lprops[i];\n\n\t\t\tlprops->free = c->leb_size;\n\t\t\tlprops->flags = ubifs_categorize_lprops(c, lprops);\n\t\t}\n\t} else {\n\t\tubifs_assert(c, branch->lnum >= c->lpt_first &&\n\t\t\t     branch->lnum <= c->lpt_last);\n\t\tubifs_assert(c, branch->offs >= 0 && branch->offs < c->leb_size);\n\t\terr = ubifs_leb_read(c, branch->lnum, buf, branch->offs,\n\t\t\t\t     c->pnode_sz, 1);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\t\terr = unpack_pnode(c, buf, pnode);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\t}\n\terr = validate_pnode(c, pnode, parent, iip);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\tif (!c->big_lpt)\n\t\tpnode->num = calc_pnode_num_from_parent(c, parent, iip);\n\tpnode->parent = parent;\n\tpnode->iip = iip;\n\tset_pnode_lnum(c, pnode);\n\treturn pnode;\n}\n\n \nint ubifs_lpt_scan_nolock(struct ubifs_info *c, int start_lnum, int end_lnum,\n\t\t\t  ubifs_lpt_scan_callback scan_cb, void *data)\n{\n\tint err = 0, i, h, iip, shft;\n\tstruct ubifs_nnode *nnode;\n\tstruct ubifs_pnode *pnode;\n\tstruct lpt_scan_node *path;\n\n\tif (start_lnum == -1) {\n\t\tstart_lnum = end_lnum + 1;\n\t\tif (start_lnum >= c->leb_cnt)\n\t\t\tstart_lnum = c->main_first;\n\t}\n\n\tubifs_assert(c, start_lnum >= c->main_first && start_lnum < c->leb_cnt);\n\tubifs_assert(c, end_lnum >= c->main_first && end_lnum < c->leb_cnt);\n\n\tif (!c->nroot) {\n\t\terr = ubifs_read_nnode(c, NULL, 0);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tpath = kmalloc_array(c->lpt_hght + 1, sizeof(struct lpt_scan_node),\n\t\t\t     GFP_NOFS);\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tpath[0].ptr.nnode = c->nroot;\n\tpath[0].in_tree = 1;\nagain:\n\t \n\tnnode = c->nroot;\n\ti = start_lnum - c->main_first;\n\tshft = c->lpt_hght * UBIFS_LPT_FANOUT_SHIFT;\n\tfor (h = 1; h < c->lpt_hght; h++) {\n\t\tiip = ((i >> shft) & (UBIFS_LPT_FANOUT - 1));\n\t\tshft -= UBIFS_LPT_FANOUT_SHIFT;\n\t\tnnode = scan_get_nnode(c, path + h, nnode, iip);\n\t\tif (IS_ERR(nnode)) {\n\t\t\terr = PTR_ERR(nnode);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tiip = ((i >> shft) & (UBIFS_LPT_FANOUT - 1));\n\tpnode = scan_get_pnode(c, path + h, nnode, iip);\n\tif (IS_ERR(pnode)) {\n\t\terr = PTR_ERR(pnode);\n\t\tgoto out;\n\t}\n\tiip = (i & (UBIFS_LPT_FANOUT - 1));\n\n\t \n\twhile (1) {\n\t\tstruct ubifs_lprops *lprops = &pnode->lprops[iip];\n\t\tint ret, lnum = lprops->lnum;\n\n\t\tret = scan_cb(c, lprops, path[h].in_tree, data);\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto out;\n\t\t}\n\t\tif (ret & LPT_SCAN_ADD) {\n\t\t\t \n\t\t\tfor (h = 1; h < c->lpt_hght; h++) {\n\t\t\t\tconst size_t sz = sizeof(struct ubifs_nnode);\n\t\t\t\tstruct ubifs_nnode *parent;\n\n\t\t\t\tif (path[h].in_tree)\n\t\t\t\t\tcontinue;\n\t\t\t\tnnode = kmemdup(&path[h].nnode, sz, GFP_NOFS);\n\t\t\t\tif (!nnode) {\n\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tparent = nnode->parent;\n\t\t\t\tparent->nbranch[nnode->iip].nnode = nnode;\n\t\t\t\tpath[h].ptr.nnode = nnode;\n\t\t\t\tpath[h].in_tree = 1;\n\t\t\t\tpath[h + 1].cnode.parent = nnode;\n\t\t\t}\n\t\t\tif (path[h].in_tree)\n\t\t\t\tubifs_ensure_cat(c, lprops);\n\t\t\telse {\n\t\t\t\tconst size_t sz = sizeof(struct ubifs_pnode);\n\t\t\t\tstruct ubifs_nnode *parent;\n\n\t\t\t\tpnode = kmemdup(&path[h].pnode, sz, GFP_NOFS);\n\t\t\t\tif (!pnode) {\n\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tparent = pnode->parent;\n\t\t\t\tparent->nbranch[pnode->iip].pnode = pnode;\n\t\t\t\tpath[h].ptr.pnode = pnode;\n\t\t\t\tpath[h].in_tree = 1;\n\t\t\t\tupdate_cats(c, pnode);\n\t\t\t\tc->pnodes_have += 1;\n\t\t\t}\n\t\t\terr = dbg_check_lpt_nodes(c, (struct ubifs_cnode *)\n\t\t\t\t\t\t  c->nroot, 0, 0);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\terr = dbg_check_cats(c);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t\tif (ret & LPT_SCAN_STOP) {\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tif (lnum == end_lnum) {\n\t\t\t \n\t\t\terr = -ENOSPC;\n\t\t\tgoto out;\n\t\t}\n\t\tif (lnum + 1 >= c->leb_cnt) {\n\t\t\t \n\t\t\tstart_lnum = c->main_first;\n\t\t\tgoto again;\n\t\t}\n\t\tif (iip + 1 < UBIFS_LPT_FANOUT) {\n\t\t\t \n\t\t\tiip += 1;\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tiip = pnode->iip;\n\t\twhile (1) {\n\t\t\th -= 1;\n\t\t\tubifs_assert(c, h >= 0);\n\t\t\tnnode = path[h].ptr.nnode;\n\t\t\tif (iip + 1 < UBIFS_LPT_FANOUT)\n\t\t\t\tbreak;\n\t\t\tiip = nnode->iip;\n\t\t}\n\t\t \n\t\tiip += 1;\n\t\t \n\t\th += 1;\n\t\tfor (; h < c->lpt_hght; h++) {\n\t\t\tnnode = scan_get_nnode(c, path + h, nnode, iip);\n\t\t\tif (IS_ERR(nnode)) {\n\t\t\t\terr = PTR_ERR(nnode);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tiip = 0;\n\t\t}\n\t\tpnode = scan_get_pnode(c, path + h, nnode, iip);\n\t\tif (IS_ERR(pnode)) {\n\t\t\terr = PTR_ERR(pnode);\n\t\t\tgoto out;\n\t\t}\n\t\tiip = 0;\n\t}\nout:\n\tkfree(path);\n\treturn err;\n}\n\n \nstatic int dbg_chk_pnode(struct ubifs_info *c, struct ubifs_pnode *pnode,\n\t\t\t int col)\n{\n\tint i;\n\n\tif (pnode->num != col) {\n\t\tubifs_err(c, \"pnode num %d expected %d parent num %d iip %d\",\n\t\t\t  pnode->num, col, pnode->parent->num, pnode->iip);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\n\t\tstruct ubifs_lprops *lp, *lprops = &pnode->lprops[i];\n\t\tint lnum = (pnode->num << UBIFS_LPT_FANOUT_SHIFT) + i +\n\t\t\t   c->main_first;\n\t\tint found, cat = lprops->flags & LPROPS_CAT_MASK;\n\t\tstruct ubifs_lpt_heap *heap;\n\t\tstruct list_head *list = NULL;\n\n\t\tif (lnum >= c->leb_cnt)\n\t\t\tcontinue;\n\t\tif (lprops->lnum != lnum) {\n\t\t\tubifs_err(c, \"bad LEB number %d expected %d\",\n\t\t\t\t  lprops->lnum, lnum);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (lprops->flags & LPROPS_TAKEN) {\n\t\t\tif (cat != LPROPS_UNCAT) {\n\t\t\t\tubifs_err(c, \"LEB %d taken but not uncat %d\",\n\t\t\t\t\t  lprops->lnum, cat);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (lprops->flags & LPROPS_INDEX) {\n\t\t\tswitch (cat) {\n\t\t\tcase LPROPS_UNCAT:\n\t\t\tcase LPROPS_DIRTY_IDX:\n\t\t\tcase LPROPS_FRDI_IDX:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tubifs_err(c, \"LEB %d index but cat %d\",\n\t\t\t\t\t  lprops->lnum, cat);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (cat) {\n\t\t\tcase LPROPS_UNCAT:\n\t\t\tcase LPROPS_DIRTY:\n\t\t\tcase LPROPS_FREE:\n\t\t\tcase LPROPS_EMPTY:\n\t\t\tcase LPROPS_FREEABLE:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tubifs_err(c, \"LEB %d not index but cat %d\",\n\t\t\t\t\t  lprops->lnum, cat);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\tswitch (cat) {\n\t\tcase LPROPS_UNCAT:\n\t\t\tlist = &c->uncat_list;\n\t\t\tbreak;\n\t\tcase LPROPS_EMPTY:\n\t\t\tlist = &c->empty_list;\n\t\t\tbreak;\n\t\tcase LPROPS_FREEABLE:\n\t\t\tlist = &c->freeable_list;\n\t\t\tbreak;\n\t\tcase LPROPS_FRDI_IDX:\n\t\t\tlist = &c->frdi_idx_list;\n\t\t\tbreak;\n\t\t}\n\t\tfound = 0;\n\t\tswitch (cat) {\n\t\tcase LPROPS_DIRTY:\n\t\tcase LPROPS_DIRTY_IDX:\n\t\tcase LPROPS_FREE:\n\t\t\theap = &c->lpt_heap[cat - 1];\n\t\t\tif (lprops->hpos < heap->cnt &&\n\t\t\t    heap->arr[lprops->hpos] == lprops)\n\t\t\t\tfound = 1;\n\t\t\tbreak;\n\t\tcase LPROPS_UNCAT:\n\t\tcase LPROPS_EMPTY:\n\t\tcase LPROPS_FREEABLE:\n\t\tcase LPROPS_FRDI_IDX:\n\t\t\tlist_for_each_entry(lp, list, list)\n\t\t\t\tif (lprops == lp) {\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (!found) {\n\t\t\tubifs_err(c, \"LEB %d cat %d not found in cat heap/list\",\n\t\t\t\t  lprops->lnum, cat);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tswitch (cat) {\n\t\tcase LPROPS_EMPTY:\n\t\t\tif (lprops->free != c->leb_size) {\n\t\t\t\tubifs_err(c, \"LEB %d cat %d free %d dirty %d\",\n\t\t\t\t\t  lprops->lnum, cat, lprops->free,\n\t\t\t\t\t  lprops->dirty);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LPROPS_FREEABLE:\n\t\tcase LPROPS_FRDI_IDX:\n\t\t\tif (lprops->free + lprops->dirty != c->leb_size) {\n\t\t\t\tubifs_err(c, \"LEB %d cat %d free %d dirty %d\",\n\t\t\t\t\t  lprops->lnum, cat, lprops->free,\n\t\t\t\t\t  lprops->dirty);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nint dbg_check_lpt_nodes(struct ubifs_info *c, struct ubifs_cnode *cnode,\n\t\t\tint row, int col)\n{\n\tstruct ubifs_nnode *nnode, *nn;\n\tstruct ubifs_cnode *cn;\n\tint num, iip = 0, err;\n\n\tif (!dbg_is_chk_lprops(c))\n\t\treturn 0;\n\n\twhile (cnode) {\n\t\tubifs_assert(c, row >= 0);\n\t\tnnode = cnode->parent;\n\t\tif (cnode->level) {\n\t\t\t \n\t\t\tnum = calc_nnode_num(row, col);\n\t\t\tif (cnode->num != num) {\n\t\t\t\tubifs_err(c, \"nnode num %d expected %d parent num %d iip %d\",\n\t\t\t\t\t  cnode->num, num,\n\t\t\t\t\t  (nnode ? nnode->num : 0), cnode->iip);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnn = (struct ubifs_nnode *)cnode;\n\t\t\twhile (iip < UBIFS_LPT_FANOUT) {\n\t\t\t\tcn = nn->nbranch[iip].cnode;\n\t\t\t\tif (cn) {\n\t\t\t\t\t \n\t\t\t\t\trow += 1;\n\t\t\t\t\tcol <<= UBIFS_LPT_FANOUT_SHIFT;\n\t\t\t\t\tcol += iip;\n\t\t\t\t\tiip = 0;\n\t\t\t\t\tcnode = cn;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tiip += 1;\n\t\t\t}\n\t\t\tif (iip < UBIFS_LPT_FANOUT)\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tstruct ubifs_pnode *pnode;\n\n\t\t\t \n\t\t\tpnode = (struct ubifs_pnode *)cnode;\n\t\t\terr = dbg_chk_pnode(c, pnode, col);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\t \n\t\trow -= 1;\n\t\tcol >>= UBIFS_LPT_FANOUT_SHIFT;\n\t\tiip = cnode->iip + 1;\n\t\tcnode = (struct ubifs_cnode *)nnode;\n\t}\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}