{
  "module_name": "lprops.c",
  "hash_id": "5e83941506bed11c6204ac3cace52579c13885eb1e1de89be90c239be8057830",
  "original_prompt": "Ingested from linux-6.6.14/fs/ubifs/lprops.c",
  "human_readable_source": "\n \n\n \n\n#include \"ubifs.h\"\n\n \nstatic int get_heap_comp_val(struct ubifs_lprops *lprops, int cat)\n{\n\tswitch (cat) {\n\tcase LPROPS_FREE:\n\t\treturn lprops->free;\n\tcase LPROPS_DIRTY_IDX:\n\t\treturn lprops->free + lprops->dirty;\n\tdefault:\n\t\treturn lprops->dirty;\n\t}\n}\n\n \nstatic void move_up_lpt_heap(struct ubifs_info *c, struct ubifs_lpt_heap *heap,\n\t\t\t     struct ubifs_lprops *lprops, int cat)\n{\n\tint val1, val2, hpos;\n\n\thpos = lprops->hpos;\n\tif (!hpos)\n\t\treturn;  \n\tval1 = get_heap_comp_val(lprops, cat);\n\t \n\tdo {\n\t\tint ppos = (hpos - 1) / 2;\n\n\t\tval2 = get_heap_comp_val(heap->arr[ppos], cat);\n\t\tif (val2 >= val1)\n\t\t\treturn;\n\t\t \n\t\theap->arr[ppos]->hpos = hpos;\n\t\theap->arr[hpos] = heap->arr[ppos];\n\t\theap->arr[ppos] = lprops;\n\t\tlprops->hpos = ppos;\n\t\thpos = ppos;\n\t} while (hpos);\n}\n\n \nstatic void adjust_lpt_heap(struct ubifs_info *c, struct ubifs_lpt_heap *heap,\n\t\t\t    struct ubifs_lprops *lprops, int hpos, int cat)\n{\n\tint val1, val2, val3, cpos;\n\n\tval1 = get_heap_comp_val(lprops, cat);\n\t \n\tif (hpos) {\n\t\tint ppos = (hpos - 1) / 2;\n\n\t\tval2 = get_heap_comp_val(heap->arr[ppos], cat);\n\t\tif (val1 > val2) {\n\t\t\t \n\t\t\twhile (1) {\n\t\t\t\theap->arr[ppos]->hpos = hpos;\n\t\t\t\theap->arr[hpos] = heap->arr[ppos];\n\t\t\t\theap->arr[ppos] = lprops;\n\t\t\t\tlprops->hpos = ppos;\n\t\t\t\thpos = ppos;\n\t\t\t\tif (!hpos)\n\t\t\t\t\treturn;\n\t\t\t\tppos = (hpos - 1) / 2;\n\t\t\t\tval2 = get_heap_comp_val(heap->arr[ppos], cat);\n\t\t\t\tif (val1 <= val2)\n\t\t\t\t\treturn;\n\t\t\t\t \n\t\t\t}\n\t\t}\n\t}\n\n\t \n\twhile (1) {\n\t\t \n\t\tcpos = hpos * 2 + 1;\n\t\tif (cpos >= heap->cnt)\n\t\t\treturn;\n\t\tval2 = get_heap_comp_val(heap->arr[cpos], cat);\n\t\tif (val1 < val2) {\n\t\t\t \n\t\t\tif (cpos + 1 < heap->cnt) {\n\t\t\t\tval3 = get_heap_comp_val(heap->arr[cpos + 1],\n\t\t\t\t\t\t\t cat);\n\t\t\t\tif (val3 > val2)\n\t\t\t\t\tcpos += 1;  \n\t\t\t}\n\t\t\theap->arr[cpos]->hpos = hpos;\n\t\t\theap->arr[hpos] = heap->arr[cpos];\n\t\t\theap->arr[cpos] = lprops;\n\t\t\tlprops->hpos = cpos;\n\t\t\thpos = cpos;\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tcpos += 1;\n\t\tif (cpos >= heap->cnt)\n\t\t\treturn;\n\t\tval3 = get_heap_comp_val(heap->arr[cpos], cat);\n\t\tif (val1 < val3) {\n\t\t\t \n\t\t\theap->arr[cpos]->hpos = hpos;\n\t\t\theap->arr[hpos] = heap->arr[cpos];\n\t\t\theap->arr[cpos] = lprops;\n\t\t\tlprops->hpos = cpos;\n\t\t\thpos = cpos;\n\t\t\tcontinue;\n\t\t}\n\t\treturn;\n\t}\n}\n\n \nstatic int add_to_lpt_heap(struct ubifs_info *c, struct ubifs_lprops *lprops,\n\t\t\t   int cat)\n{\n\tstruct ubifs_lpt_heap *heap = &c->lpt_heap[cat - 1];\n\n\tif (heap->cnt >= heap->max_cnt) {\n\t\tconst int b = LPT_HEAP_SZ / 2 - 1;\n\t\tint cpos, val1, val2;\n\n\t\t \n\t\t \n\t\tcpos = (((size_t)lprops >> 4) & b) + b;\n\t\tubifs_assert(c, cpos >= b);\n\t\tubifs_assert(c, cpos < LPT_HEAP_SZ);\n\t\tubifs_assert(c, cpos < heap->cnt);\n\n\t\tval1 = get_heap_comp_val(lprops, cat);\n\t\tval2 = get_heap_comp_val(heap->arr[cpos], cat);\n\t\tif (val1 > val2) {\n\t\t\tstruct ubifs_lprops *lp;\n\n\t\t\tlp = heap->arr[cpos];\n\t\t\tlp->flags &= ~LPROPS_CAT_MASK;\n\t\t\tlp->flags |= LPROPS_UNCAT;\n\t\t\tlist_add(&lp->list, &c->uncat_list);\n\t\t\tlprops->hpos = cpos;\n\t\t\theap->arr[cpos] = lprops;\n\t\t\tmove_up_lpt_heap(c, heap, lprops, cat);\n\t\t\tdbg_check_heap(c, heap, cat, lprops->hpos);\n\t\t\treturn 1;  \n\t\t}\n\t\tdbg_check_heap(c, heap, cat, -1);\n\t\treturn 0;  \n\t} else {\n\t\tlprops->hpos = heap->cnt++;\n\t\theap->arr[lprops->hpos] = lprops;\n\t\tmove_up_lpt_heap(c, heap, lprops, cat);\n\t\tdbg_check_heap(c, heap, cat, lprops->hpos);\n\t\treturn 1;  \n\t}\n}\n\n \nstatic void remove_from_lpt_heap(struct ubifs_info *c,\n\t\t\t\t struct ubifs_lprops *lprops, int cat)\n{\n\tstruct ubifs_lpt_heap *heap;\n\tint hpos = lprops->hpos;\n\n\theap = &c->lpt_heap[cat - 1];\n\tubifs_assert(c, hpos >= 0 && hpos < heap->cnt);\n\tubifs_assert(c, heap->arr[hpos] == lprops);\n\theap->cnt -= 1;\n\tif (hpos < heap->cnt) {\n\t\theap->arr[hpos] = heap->arr[heap->cnt];\n\t\theap->arr[hpos]->hpos = hpos;\n\t\tadjust_lpt_heap(c, heap, heap->arr[hpos], hpos, cat);\n\t}\n\tdbg_check_heap(c, heap, cat, -1);\n}\n\n \nstatic void lpt_heap_replace(struct ubifs_info *c,\n\t\t\t     struct ubifs_lprops *new_lprops, int cat)\n{\n\tstruct ubifs_lpt_heap *heap;\n\tint hpos = new_lprops->hpos;\n\n\theap = &c->lpt_heap[cat - 1];\n\theap->arr[hpos] = new_lprops;\n}\n\n \nvoid ubifs_add_to_cat(struct ubifs_info *c, struct ubifs_lprops *lprops,\n\t\t      int cat)\n{\n\tswitch (cat) {\n\tcase LPROPS_DIRTY:\n\tcase LPROPS_DIRTY_IDX:\n\tcase LPROPS_FREE:\n\t\tif (add_to_lpt_heap(c, lprops, cat))\n\t\t\tbreak;\n\t\t \n\t\tcat = LPROPS_UNCAT;\n\t\tfallthrough;\n\tcase LPROPS_UNCAT:\n\t\tlist_add(&lprops->list, &c->uncat_list);\n\t\tbreak;\n\tcase LPROPS_EMPTY:\n\t\tlist_add(&lprops->list, &c->empty_list);\n\t\tbreak;\n\tcase LPROPS_FREEABLE:\n\t\tlist_add(&lprops->list, &c->freeable_list);\n\t\tc->freeable_cnt += 1;\n\t\tbreak;\n\tcase LPROPS_FRDI_IDX:\n\t\tlist_add(&lprops->list, &c->frdi_idx_list);\n\t\tbreak;\n\tdefault:\n\t\tubifs_assert(c, 0);\n\t}\n\n\tlprops->flags &= ~LPROPS_CAT_MASK;\n\tlprops->flags |= cat;\n\tc->in_a_category_cnt += 1;\n\tubifs_assert(c, c->in_a_category_cnt <= c->main_lebs);\n}\n\n \nstatic void ubifs_remove_from_cat(struct ubifs_info *c,\n\t\t\t\t  struct ubifs_lprops *lprops, int cat)\n{\n\tswitch (cat) {\n\tcase LPROPS_DIRTY:\n\tcase LPROPS_DIRTY_IDX:\n\tcase LPROPS_FREE:\n\t\tremove_from_lpt_heap(c, lprops, cat);\n\t\tbreak;\n\tcase LPROPS_FREEABLE:\n\t\tc->freeable_cnt -= 1;\n\t\tubifs_assert(c, c->freeable_cnt >= 0);\n\t\tfallthrough;\n\tcase LPROPS_UNCAT:\n\tcase LPROPS_EMPTY:\n\tcase LPROPS_FRDI_IDX:\n\t\tubifs_assert(c, !list_empty(&lprops->list));\n\t\tlist_del(&lprops->list);\n\t\tbreak;\n\tdefault:\n\t\tubifs_assert(c, 0);\n\t}\n\n\tc->in_a_category_cnt -= 1;\n\tubifs_assert(c, c->in_a_category_cnt >= 0);\n}\n\n \nvoid ubifs_replace_cat(struct ubifs_info *c, struct ubifs_lprops *old_lprops,\n\t\t       struct ubifs_lprops *new_lprops)\n{\n\tint cat;\n\n\tcat = new_lprops->flags & LPROPS_CAT_MASK;\n\tswitch (cat) {\n\tcase LPROPS_DIRTY:\n\tcase LPROPS_DIRTY_IDX:\n\tcase LPROPS_FREE:\n\t\tlpt_heap_replace(c, new_lprops, cat);\n\t\tbreak;\n\tcase LPROPS_UNCAT:\n\tcase LPROPS_EMPTY:\n\tcase LPROPS_FREEABLE:\n\tcase LPROPS_FRDI_IDX:\n\t\tlist_replace(&old_lprops->list, &new_lprops->list);\n\t\tbreak;\n\tdefault:\n\t\tubifs_assert(c, 0);\n\t}\n}\n\n \nvoid ubifs_ensure_cat(struct ubifs_info *c, struct ubifs_lprops *lprops)\n{\n\tint cat = lprops->flags & LPROPS_CAT_MASK;\n\n\tif (cat != LPROPS_UNCAT)\n\t\treturn;\n\tcat = ubifs_categorize_lprops(c, lprops);\n\tif (cat == LPROPS_UNCAT)\n\t\treturn;\n\tubifs_remove_from_cat(c, lprops, LPROPS_UNCAT);\n\tubifs_add_to_cat(c, lprops, cat);\n}\n\n \nint ubifs_categorize_lprops(const struct ubifs_info *c,\n\t\t\t    const struct ubifs_lprops *lprops)\n{\n\tif (lprops->flags & LPROPS_TAKEN)\n\t\treturn LPROPS_UNCAT;\n\n\tif (lprops->free == c->leb_size) {\n\t\tubifs_assert(c, !(lprops->flags & LPROPS_INDEX));\n\t\treturn LPROPS_EMPTY;\n\t}\n\n\tif (lprops->free + lprops->dirty == c->leb_size) {\n\t\tif (lprops->flags & LPROPS_INDEX)\n\t\t\treturn LPROPS_FRDI_IDX;\n\t\telse\n\t\t\treturn LPROPS_FREEABLE;\n\t}\n\n\tif (lprops->flags & LPROPS_INDEX) {\n\t\tif (lprops->dirty + lprops->free >= c->min_idx_node_sz)\n\t\t\treturn LPROPS_DIRTY_IDX;\n\t} else {\n\t\tif (lprops->dirty >= c->dead_wm &&\n\t\t    lprops->dirty > lprops->free)\n\t\t\treturn LPROPS_DIRTY;\n\t\tif (lprops->free > 0)\n\t\t\treturn LPROPS_FREE;\n\t}\n\n\treturn LPROPS_UNCAT;\n}\n\n \nstatic void change_category(struct ubifs_info *c, struct ubifs_lprops *lprops)\n{\n\tint old_cat = lprops->flags & LPROPS_CAT_MASK;\n\tint new_cat = ubifs_categorize_lprops(c, lprops);\n\n\tif (old_cat == new_cat) {\n\t\tstruct ubifs_lpt_heap *heap;\n\n\t\t \n\t\tif (new_cat < 1 || new_cat > LPROPS_HEAP_CNT)\n\t\t\treturn;  \n\t\theap = &c->lpt_heap[new_cat - 1];\n\t\tadjust_lpt_heap(c, heap, lprops, lprops->hpos, new_cat);\n\t} else {\n\t\tubifs_remove_from_cat(c, lprops, old_cat);\n\t\tubifs_add_to_cat(c, lprops, new_cat);\n\t}\n}\n\n \nint ubifs_calc_dark(const struct ubifs_info *c, int spc)\n{\n\tubifs_assert(c, !(spc & 7));\n\n\tif (spc < c->dark_wm)\n\t\treturn spc;\n\n\t \n\tif (spc - c->dark_wm < MIN_WRITE_SZ)\n\t\treturn spc - MIN_WRITE_SZ;\n\n\treturn c->dark_wm;\n}\n\n \nstatic int is_lprops_dirty(struct ubifs_info *c, struct ubifs_lprops *lprops)\n{\n\tstruct ubifs_pnode *pnode;\n\tint pos;\n\n\tpos = (lprops->lnum - c->main_first) & (UBIFS_LPT_FANOUT - 1);\n\tpnode = (struct ubifs_pnode *)container_of(lprops - pos,\n\t\t\t\t\t\t   struct ubifs_pnode,\n\t\t\t\t\t\t   lprops[0]);\n\treturn !test_bit(COW_CNODE, &pnode->flags) &&\n\t       test_bit(DIRTY_CNODE, &pnode->flags);\n}\n\n \nconst struct ubifs_lprops *ubifs_change_lp(struct ubifs_info *c,\n\t\t\t\t\t   const struct ubifs_lprops *lp,\n\t\t\t\t\t   int free, int dirty, int flags,\n\t\t\t\t\t   int idx_gc_cnt)\n{\n\t \n\tstruct ubifs_lprops *lprops = (struct ubifs_lprops *)lp;\n\n\tdbg_lp(\"LEB %d, free %d, dirty %d, flags %d\",\n\t       lprops->lnum, free, dirty, flags);\n\n\tubifs_assert(c, mutex_is_locked(&c->lp_mutex));\n\tubifs_assert(c, c->lst.empty_lebs >= 0 &&\n\t\t     c->lst.empty_lebs <= c->main_lebs);\n\tubifs_assert(c, c->freeable_cnt >= 0);\n\tubifs_assert(c, c->freeable_cnt <= c->main_lebs);\n\tubifs_assert(c, c->lst.taken_empty_lebs >= 0);\n\tubifs_assert(c, c->lst.taken_empty_lebs <= c->lst.empty_lebs);\n\tubifs_assert(c, !(c->lst.total_free & 7) && !(c->lst.total_dirty & 7));\n\tubifs_assert(c, !(c->lst.total_dead & 7) && !(c->lst.total_dark & 7));\n\tubifs_assert(c, !(c->lst.total_used & 7));\n\tubifs_assert(c, free == LPROPS_NC || free >= 0);\n\tubifs_assert(c, dirty == LPROPS_NC || dirty >= 0);\n\n\tif (!is_lprops_dirty(c, lprops)) {\n\t\tlprops = ubifs_lpt_lookup_dirty(c, lprops->lnum);\n\t\tif (IS_ERR(lprops))\n\t\t\treturn lprops;\n\t} else\n\t\tubifs_assert(c, lprops == ubifs_lpt_lookup_dirty(c, lprops->lnum));\n\n\tubifs_assert(c, !(lprops->free & 7) && !(lprops->dirty & 7));\n\n\tspin_lock(&c->space_lock);\n\tif ((lprops->flags & LPROPS_TAKEN) && lprops->free == c->leb_size)\n\t\tc->lst.taken_empty_lebs -= 1;\n\n\tif (!(lprops->flags & LPROPS_INDEX)) {\n\t\tint old_spc;\n\n\t\told_spc = lprops->free + lprops->dirty;\n\t\tif (old_spc < c->dead_wm)\n\t\t\tc->lst.total_dead -= old_spc;\n\t\telse\n\t\t\tc->lst.total_dark -= ubifs_calc_dark(c, old_spc);\n\n\t\tc->lst.total_used -= c->leb_size - old_spc;\n\t}\n\n\tif (free != LPROPS_NC) {\n\t\tfree = ALIGN(free, 8);\n\t\tc->lst.total_free += free - lprops->free;\n\n\t\t \n\t\tif (free == c->leb_size) {\n\t\t\tif (lprops->free != c->leb_size)\n\t\t\t\tc->lst.empty_lebs += 1;\n\t\t} else if (lprops->free == c->leb_size)\n\t\t\tc->lst.empty_lebs -= 1;\n\t\tlprops->free = free;\n\t}\n\n\tif (dirty != LPROPS_NC) {\n\t\tdirty = ALIGN(dirty, 8);\n\t\tc->lst.total_dirty += dirty - lprops->dirty;\n\t\tlprops->dirty = dirty;\n\t}\n\n\tif (flags != LPROPS_NC) {\n\t\t \n\t\tif ((lprops->flags & LPROPS_INDEX)) {\n\t\t\tif (!(flags & LPROPS_INDEX))\n\t\t\t\tc->lst.idx_lebs -= 1;\n\t\t} else if (flags & LPROPS_INDEX)\n\t\t\tc->lst.idx_lebs += 1;\n\t\tlprops->flags = flags;\n\t}\n\n\tif (!(lprops->flags & LPROPS_INDEX)) {\n\t\tint new_spc;\n\n\t\tnew_spc = lprops->free + lprops->dirty;\n\t\tif (new_spc < c->dead_wm)\n\t\t\tc->lst.total_dead += new_spc;\n\t\telse\n\t\t\tc->lst.total_dark += ubifs_calc_dark(c, new_spc);\n\n\t\tc->lst.total_used += c->leb_size - new_spc;\n\t}\n\n\tif ((lprops->flags & LPROPS_TAKEN) && lprops->free == c->leb_size)\n\t\tc->lst.taken_empty_lebs += 1;\n\n\tchange_category(c, lprops);\n\tc->idx_gc_cnt += idx_gc_cnt;\n\tspin_unlock(&c->space_lock);\n\treturn lprops;\n}\n\n \nvoid ubifs_get_lp_stats(struct ubifs_info *c, struct ubifs_lp_stats *lst)\n{\n\tspin_lock(&c->space_lock);\n\tmemcpy(lst, &c->lst, sizeof(struct ubifs_lp_stats));\n\tspin_unlock(&c->space_lock);\n}\n\n \nint ubifs_change_one_lp(struct ubifs_info *c, int lnum, int free, int dirty,\n\t\t\tint flags_set, int flags_clean, int idx_gc_cnt)\n{\n\tint err = 0, flags;\n\tconst struct ubifs_lprops *lp;\n\n\tubifs_get_lprops(c);\n\n\tlp = ubifs_lpt_lookup_dirty(c, lnum);\n\tif (IS_ERR(lp)) {\n\t\terr = PTR_ERR(lp);\n\t\tgoto out;\n\t}\n\n\tflags = (lp->flags | flags_set) & ~flags_clean;\n\tlp = ubifs_change_lp(c, lp, free, dirty, flags, idx_gc_cnt);\n\tif (IS_ERR(lp))\n\t\terr = PTR_ERR(lp);\n\nout:\n\tubifs_release_lprops(c);\n\tif (err)\n\t\tubifs_err(c, \"cannot change properties of LEB %d, error %d\",\n\t\t\t  lnum, err);\n\treturn err;\n}\n\n \nint ubifs_update_one_lp(struct ubifs_info *c, int lnum, int free, int dirty,\n\t\t\tint flags_set, int flags_clean)\n{\n\tint err = 0, flags;\n\tconst struct ubifs_lprops *lp;\n\n\tubifs_get_lprops(c);\n\n\tlp = ubifs_lpt_lookup_dirty(c, lnum);\n\tif (IS_ERR(lp)) {\n\t\terr = PTR_ERR(lp);\n\t\tgoto out;\n\t}\n\n\tflags = (lp->flags | flags_set) & ~flags_clean;\n\tlp = ubifs_change_lp(c, lp, free, lp->dirty + dirty, flags, 0);\n\tif (IS_ERR(lp))\n\t\terr = PTR_ERR(lp);\n\nout:\n\tubifs_release_lprops(c);\n\tif (err)\n\t\tubifs_err(c, \"cannot update properties of LEB %d, error %d\",\n\t\t\t  lnum, err);\n\treturn err;\n}\n\n \nint ubifs_read_one_lp(struct ubifs_info *c, int lnum, struct ubifs_lprops *lp)\n{\n\tint err = 0;\n\tconst struct ubifs_lprops *lpp;\n\n\tubifs_get_lprops(c);\n\n\tlpp = ubifs_lpt_lookup(c, lnum);\n\tif (IS_ERR(lpp)) {\n\t\terr = PTR_ERR(lpp);\n\t\tubifs_err(c, \"cannot read properties of LEB %d, error %d\",\n\t\t\t  lnum, err);\n\t\tgoto out;\n\t}\n\n\tmemcpy(lp, lpp, sizeof(struct ubifs_lprops));\n\nout:\n\tubifs_release_lprops(c);\n\treturn err;\n}\n\n \nconst struct ubifs_lprops *ubifs_fast_find_free(struct ubifs_info *c)\n{\n\tstruct ubifs_lprops *lprops;\n\tstruct ubifs_lpt_heap *heap;\n\n\tubifs_assert(c, mutex_is_locked(&c->lp_mutex));\n\n\theap = &c->lpt_heap[LPROPS_FREE - 1];\n\tif (heap->cnt == 0)\n\t\treturn NULL;\n\n\tlprops = heap->arr[0];\n\tubifs_assert(c, !(lprops->flags & LPROPS_TAKEN));\n\tubifs_assert(c, !(lprops->flags & LPROPS_INDEX));\n\treturn lprops;\n}\n\n \nconst struct ubifs_lprops *ubifs_fast_find_empty(struct ubifs_info *c)\n{\n\tstruct ubifs_lprops *lprops;\n\n\tubifs_assert(c, mutex_is_locked(&c->lp_mutex));\n\n\tif (list_empty(&c->empty_list))\n\t\treturn NULL;\n\n\tlprops = list_entry(c->empty_list.next, struct ubifs_lprops, list);\n\tubifs_assert(c, !(lprops->flags & LPROPS_TAKEN));\n\tubifs_assert(c, !(lprops->flags & LPROPS_INDEX));\n\tubifs_assert(c, lprops->free == c->leb_size);\n\treturn lprops;\n}\n\n \nconst struct ubifs_lprops *ubifs_fast_find_freeable(struct ubifs_info *c)\n{\n\tstruct ubifs_lprops *lprops;\n\n\tubifs_assert(c, mutex_is_locked(&c->lp_mutex));\n\n\tif (list_empty(&c->freeable_list))\n\t\treturn NULL;\n\n\tlprops = list_entry(c->freeable_list.next, struct ubifs_lprops, list);\n\tubifs_assert(c, !(lprops->flags & LPROPS_TAKEN));\n\tubifs_assert(c, !(lprops->flags & LPROPS_INDEX));\n\tubifs_assert(c, lprops->free + lprops->dirty == c->leb_size);\n\tubifs_assert(c, c->freeable_cnt > 0);\n\treturn lprops;\n}\n\n \nconst struct ubifs_lprops *ubifs_fast_find_frdi_idx(struct ubifs_info *c)\n{\n\tstruct ubifs_lprops *lprops;\n\n\tubifs_assert(c, mutex_is_locked(&c->lp_mutex));\n\n\tif (list_empty(&c->frdi_idx_list))\n\t\treturn NULL;\n\n\tlprops = list_entry(c->frdi_idx_list.next, struct ubifs_lprops, list);\n\tubifs_assert(c, !(lprops->flags & LPROPS_TAKEN));\n\tubifs_assert(c, (lprops->flags & LPROPS_INDEX));\n\tubifs_assert(c, lprops->free + lprops->dirty == c->leb_size);\n\treturn lprops;\n}\n\n \n\n \nint dbg_check_cats(struct ubifs_info *c)\n{\n\tstruct ubifs_lprops *lprops;\n\tstruct list_head *pos;\n\tint i, cat;\n\n\tif (!dbg_is_chk_gen(c) && !dbg_is_chk_lprops(c))\n\t\treturn 0;\n\n\tlist_for_each_entry(lprops, &c->empty_list, list) {\n\t\tif (lprops->free != c->leb_size) {\n\t\t\tubifs_err(c, \"non-empty LEB %d on empty list (free %d dirty %d flags %d)\",\n\t\t\t\t  lprops->lnum, lprops->free, lprops->dirty,\n\t\t\t\t  lprops->flags);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (lprops->flags & LPROPS_TAKEN) {\n\t\t\tubifs_err(c, \"taken LEB %d on empty list (free %d dirty %d flags %d)\",\n\t\t\t\t  lprops->lnum, lprops->free, lprops->dirty,\n\t\t\t\t  lprops->flags);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\ti = 0;\n\tlist_for_each_entry(lprops, &c->freeable_list, list) {\n\t\tif (lprops->free + lprops->dirty != c->leb_size) {\n\t\t\tubifs_err(c, \"non-freeable LEB %d on freeable list (free %d dirty %d flags %d)\",\n\t\t\t\t  lprops->lnum, lprops->free, lprops->dirty,\n\t\t\t\t  lprops->flags);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (lprops->flags & LPROPS_TAKEN) {\n\t\t\tubifs_err(c, \"taken LEB %d on freeable list (free %d dirty %d flags %d)\",\n\t\t\t\t  lprops->lnum, lprops->free, lprops->dirty,\n\t\t\t\t  lprops->flags);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ti += 1;\n\t}\n\tif (i != c->freeable_cnt) {\n\t\tubifs_err(c, \"freeable list count %d expected %d\", i,\n\t\t\t  c->freeable_cnt);\n\t\treturn -EINVAL;\n\t}\n\n\ti = 0;\n\tlist_for_each(pos, &c->idx_gc)\n\t\ti += 1;\n\tif (i != c->idx_gc_cnt) {\n\t\tubifs_err(c, \"idx_gc list count %d expected %d\", i,\n\t\t\t  c->idx_gc_cnt);\n\t\treturn -EINVAL;\n\t}\n\n\tlist_for_each_entry(lprops, &c->frdi_idx_list, list) {\n\t\tif (lprops->free + lprops->dirty != c->leb_size) {\n\t\t\tubifs_err(c, \"non-freeable LEB %d on frdi_idx list (free %d dirty %d flags %d)\",\n\t\t\t\t  lprops->lnum, lprops->free, lprops->dirty,\n\t\t\t\t  lprops->flags);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (lprops->flags & LPROPS_TAKEN) {\n\t\t\tubifs_err(c, \"taken LEB %d on frdi_idx list (free %d dirty %d flags %d)\",\n\t\t\t\t  lprops->lnum, lprops->free, lprops->dirty,\n\t\t\t\t  lprops->flags);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!(lprops->flags & LPROPS_INDEX)) {\n\t\t\tubifs_err(c, \"non-index LEB %d on frdi_idx list (free %d dirty %d flags %d)\",\n\t\t\t\t  lprops->lnum, lprops->free, lprops->dirty,\n\t\t\t\t  lprops->flags);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tfor (cat = 1; cat <= LPROPS_HEAP_CNT; cat++) {\n\t\tstruct ubifs_lpt_heap *heap = &c->lpt_heap[cat - 1];\n\n\t\tfor (i = 0; i < heap->cnt; i++) {\n\t\t\tlprops = heap->arr[i];\n\t\t\tif (!lprops) {\n\t\t\t\tubifs_err(c, \"null ptr in LPT heap cat %d\", cat);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (lprops->hpos != i) {\n\t\t\t\tubifs_err(c, \"bad ptr in LPT heap cat %d\", cat);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (lprops->flags & LPROPS_TAKEN) {\n\t\t\t\tubifs_err(c, \"taken LEB in LPT heap cat %d\", cat);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid dbg_check_heap(struct ubifs_info *c, struct ubifs_lpt_heap *heap, int cat,\n\t\t    int add_pos)\n{\n\tint i = 0, j, err = 0;\n\n\tif (!dbg_is_chk_gen(c) && !dbg_is_chk_lprops(c))\n\t\treturn;\n\n\tfor (i = 0; i < heap->cnt; i++) {\n\t\tstruct ubifs_lprops *lprops = heap->arr[i];\n\t\tstruct ubifs_lprops *lp;\n\n\t\tif (i != add_pos)\n\t\t\tif ((lprops->flags & LPROPS_CAT_MASK) != cat) {\n\t\t\t\terr = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\tif (lprops->hpos != i) {\n\t\t\terr = 2;\n\t\t\tgoto out;\n\t\t}\n\t\tlp = ubifs_lpt_lookup(c, lprops->lnum);\n\t\tif (IS_ERR(lp)) {\n\t\t\terr = 3;\n\t\t\tgoto out;\n\t\t}\n\t\tif (lprops != lp) {\n\t\t\tubifs_err(c, \"lprops %zx lp %zx lprops->lnum %d lp->lnum %d\",\n\t\t\t\t  (size_t)lprops, (size_t)lp, lprops->lnum,\n\t\t\t\t  lp->lnum);\n\t\t\terr = 4;\n\t\t\tgoto out;\n\t\t}\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tlp = heap->arr[j];\n\t\t\tif (lp == lprops) {\n\t\t\t\terr = 5;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (lp->lnum == lprops->lnum) {\n\t\t\t\terr = 6;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\nout:\n\tif (err) {\n\t\tubifs_err(c, \"failed cat %d hpos %d err %d\", cat, i, err);\n\t\tdump_stack();\n\t\tubifs_dump_heap(c, heap, cat);\n\t}\n}\n\n \nstatic int scan_check_cb(struct ubifs_info *c,\n\t\t\t const struct ubifs_lprops *lp, int in_tree,\n\t\t\t struct ubifs_lp_stats *lst)\n{\n\tstruct ubifs_scan_leb *sleb;\n\tstruct ubifs_scan_node *snod;\n\tint cat, lnum = lp->lnum, is_idx = 0, used = 0, free, dirty, ret;\n\tvoid *buf = NULL;\n\n\tcat = lp->flags & LPROPS_CAT_MASK;\n\tif (cat != LPROPS_UNCAT) {\n\t\tcat = ubifs_categorize_lprops(c, lp);\n\t\tif (cat != (lp->flags & LPROPS_CAT_MASK)) {\n\t\t\tubifs_err(c, \"bad LEB category %d expected %d\",\n\t\t\t\t  (lp->flags & LPROPS_CAT_MASK), cat);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tif (in_tree) {\n\t\tstruct list_head *list = NULL;\n\n\t\tswitch (cat) {\n\t\tcase LPROPS_EMPTY:\n\t\t\tlist = &c->empty_list;\n\t\t\tbreak;\n\t\tcase LPROPS_FREEABLE:\n\t\t\tlist = &c->freeable_list;\n\t\t\tbreak;\n\t\tcase LPROPS_FRDI_IDX:\n\t\t\tlist = &c->frdi_idx_list;\n\t\t\tbreak;\n\t\tcase LPROPS_UNCAT:\n\t\t\tlist = &c->uncat_list;\n\t\t\tbreak;\n\t\t}\n\t\tif (list) {\n\t\t\tstruct ubifs_lprops *lprops;\n\t\t\tint found = 0;\n\n\t\t\tlist_for_each_entry(lprops, list, list) {\n\t\t\t\tif (lprops == lp) {\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\tubifs_err(c, \"bad LPT list (category %d)\", cat);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (in_tree && cat > 0 && cat <= LPROPS_HEAP_CNT) {\n\t\tstruct ubifs_lpt_heap *heap = &c->lpt_heap[cat - 1];\n\n\t\tif ((lp->hpos != -1 && heap->arr[lp->hpos]->lnum != lnum) ||\n\t\t    lp != heap->arr[lp->hpos]) {\n\t\t\tubifs_err(c, \"bad LPT heap (category %d)\", cat);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tif (lp->free == c->leb_size) {\n\t\tlst->empty_lebs += 1;\n\t\tlst->total_free += c->leb_size;\n\t\tlst->total_dark += ubifs_calc_dark(c, c->leb_size);\n\t\treturn LPT_SCAN_CONTINUE;\n\t}\n\tif (lp->free + lp->dirty == c->leb_size &&\n\t    !(lp->flags & LPROPS_INDEX)) {\n\t\tlst->total_free  += lp->free;\n\t\tlst->total_dirty += lp->dirty;\n\t\tlst->total_dark  +=  ubifs_calc_dark(c, c->leb_size);\n\t\treturn LPT_SCAN_CONTINUE;\n\t}\n\n\tbuf = __vmalloc(c->leb_size, GFP_NOFS);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tsleb = ubifs_scan(c, lnum, 0, buf, 0);\n\tif (IS_ERR(sleb)) {\n\t\tret = PTR_ERR(sleb);\n\t\tif (ret == -EUCLEAN) {\n\t\t\tubifs_dump_lprops(c);\n\t\t\tubifs_dump_budg(c, &c->bi);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tis_idx = -1;\n\tlist_for_each_entry(snod, &sleb->nodes, list) {\n\t\tint found, level = 0;\n\n\t\tcond_resched();\n\n\t\tif (is_idx == -1)\n\t\t\tis_idx = (snod->type == UBIFS_IDX_NODE) ? 1 : 0;\n\n\t\tif (is_idx && snod->type != UBIFS_IDX_NODE) {\n\t\t\tubifs_err(c, \"indexing node in data LEB %d:%d\",\n\t\t\t\t  lnum, snod->offs);\n\t\t\tgoto out_destroy;\n\t\t}\n\n\t\tif (snod->type == UBIFS_IDX_NODE) {\n\t\t\tstruct ubifs_idx_node *idx = snod->node;\n\n\t\t\tkey_read(c, ubifs_idx_key(c, idx), &snod->key);\n\t\t\tlevel = le16_to_cpu(idx->level);\n\t\t}\n\n\t\tfound = ubifs_tnc_has_node(c, &snod->key, level, lnum,\n\t\t\t\t\t   snod->offs, is_idx);\n\t\tif (found) {\n\t\t\tif (found < 0)\n\t\t\t\tgoto out_destroy;\n\t\t\tused += ALIGN(snod->len, 8);\n\t\t}\n\t}\n\n\tfree = c->leb_size - sleb->endpt;\n\tdirty = sleb->endpt - used;\n\n\tif (free > c->leb_size || free < 0 || dirty > c->leb_size ||\n\t    dirty < 0) {\n\t\tubifs_err(c, \"bad calculated accounting for LEB %d: free %d, dirty %d\",\n\t\t\t  lnum, free, dirty);\n\t\tgoto out_destroy;\n\t}\n\n\tif (lp->free + lp->dirty == c->leb_size &&\n\t    free + dirty == c->leb_size)\n\t\tif ((is_idx && !(lp->flags & LPROPS_INDEX)) ||\n\t\t    (!is_idx && free == c->leb_size) ||\n\t\t    lp->free == c->leb_size) {\n\t\t\t \n\t\t\tfree = lp->free;\n\t\t\tdirty = lp->dirty;\n\t\t\tis_idx = 0;\n\t\t    }\n\n\tif (is_idx && lp->free + lp->dirty == free + dirty &&\n\t    lnum != c->ihead_lnum) {\n\t\t \n\t\tfree = lp->free;\n\t\tdirty = lp->dirty;\n\t}\n\n\tif (lp->free != free || lp->dirty != dirty)\n\t\tgoto out_print;\n\n\tif (is_idx && !(lp->flags & LPROPS_INDEX)) {\n\t\tif (free == c->leb_size)\n\t\t\t \n\t\t\tis_idx = 0;\n\t\telse {\n\t\t\tubifs_err(c, \"indexing node without indexing flag\");\n\t\t\tgoto out_print;\n\t\t}\n\t}\n\n\tif (!is_idx && (lp->flags & LPROPS_INDEX)) {\n\t\tubifs_err(c, \"data node with indexing flag\");\n\t\tgoto out_print;\n\t}\n\n\tif (free == c->leb_size)\n\t\tlst->empty_lebs += 1;\n\n\tif (is_idx)\n\t\tlst->idx_lebs += 1;\n\n\tif (!(lp->flags & LPROPS_INDEX))\n\t\tlst->total_used += c->leb_size - free - dirty;\n\tlst->total_free += free;\n\tlst->total_dirty += dirty;\n\n\tif (!(lp->flags & LPROPS_INDEX)) {\n\t\tint spc = free + dirty;\n\n\t\tif (spc < c->dead_wm)\n\t\t\tlst->total_dead += spc;\n\t\telse\n\t\t\tlst->total_dark += ubifs_calc_dark(c, spc);\n\t}\n\n\tubifs_scan_destroy(sleb);\n\tvfree(buf);\n\treturn LPT_SCAN_CONTINUE;\n\nout_print:\n\tubifs_err(c, \"bad accounting of LEB %d: free %d, dirty %d flags %#x, should be free %d, dirty %d\",\n\t\t  lnum, lp->free, lp->dirty, lp->flags, free, dirty);\n\tubifs_dump_leb(c, lnum);\nout_destroy:\n\tubifs_scan_destroy(sleb);\n\tret = -EINVAL;\nout:\n\tvfree(buf);\n\treturn ret;\n}\n\n \nint dbg_check_lprops(struct ubifs_info *c)\n{\n\tint i, err;\n\tstruct ubifs_lp_stats lst;\n\n\tif (!dbg_is_chk_lprops(c))\n\t\treturn 0;\n\n\t \n\tfor (i = 0; i < c->jhead_cnt; i++) {\n\t\terr = ubifs_wbuf_sync(&c->jheads[i].wbuf);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tmemset(&lst, 0, sizeof(struct ubifs_lp_stats));\n\terr = ubifs_lpt_scan_nolock(c, c->main_first, c->leb_cnt - 1,\n\t\t\t\t    (ubifs_lpt_scan_callback)scan_check_cb,\n\t\t\t\t    &lst);\n\tif (err && err != -ENOSPC)\n\t\tgoto out;\n\n\tif (lst.empty_lebs != c->lst.empty_lebs ||\n\t    lst.idx_lebs != c->lst.idx_lebs ||\n\t    lst.total_free != c->lst.total_free ||\n\t    lst.total_dirty != c->lst.total_dirty ||\n\t    lst.total_used != c->lst.total_used) {\n\t\tubifs_err(c, \"bad overall accounting\");\n\t\tubifs_err(c, \"calculated: empty_lebs %d, idx_lebs %d, total_free %lld, total_dirty %lld, total_used %lld\",\n\t\t\t  lst.empty_lebs, lst.idx_lebs, lst.total_free,\n\t\t\t  lst.total_dirty, lst.total_used);\n\t\tubifs_err(c, \"read from lprops: empty_lebs %d, idx_lebs %d, total_free %lld, total_dirty %lld, total_used %lld\",\n\t\t\t  c->lst.empty_lebs, c->lst.idx_lebs, c->lst.total_free,\n\t\t\t  c->lst.total_dirty, c->lst.total_used);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (lst.total_dead != c->lst.total_dead ||\n\t    lst.total_dark != c->lst.total_dark) {\n\t\tubifs_err(c, \"bad dead/dark space accounting\");\n\t\tubifs_err(c, \"calculated: total_dead %lld, total_dark %lld\",\n\t\t\t  lst.total_dead, lst.total_dark);\n\t\tubifs_err(c, \"read from lprops: total_dead %lld, total_dark %lld\",\n\t\t\t  c->lst.total_dead, c->lst.total_dark);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\terr = dbg_check_cats(c);\nout:\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}