{
  "module_name": "super.c",
  "hash_id": "da68d92e7a3355cdc0a1de05b5cef0197201540b0911801754351ac2b781add7",
  "original_prompt": "Ingested from linux-6.6.14/fs/ubifs/super.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/kthread.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/math64.h>\n#include <linux/writeback.h>\n#include \"ubifs.h\"\n\nstatic int ubifs_default_version_set(const char *val, const struct kernel_param *kp)\n{\n\tint n = 0, ret;\n\n\tret = kstrtoint(val, 10, &n);\n\tif (ret != 0 || n < 4 || n > UBIFS_FORMAT_VERSION)\n\t\treturn -EINVAL;\n\treturn param_set_int(val, kp);\n}\n\nstatic const struct kernel_param_ops ubifs_default_version_ops = {\n\t.set = ubifs_default_version_set,\n\t.get = param_get_int,\n};\n\nint ubifs_default_version = UBIFS_FORMAT_VERSION;\nmodule_param_cb(default_version, &ubifs_default_version_ops, &ubifs_default_version, 0600);\n\n \n#define UBIFS_KMALLOC_OK (128*1024)\n\n \nstatic struct kmem_cache *ubifs_inode_slab;\n\n \nstatic struct shrinker ubifs_shrinker_info = {\n\t.scan_objects = ubifs_shrink_scan,\n\t.count_objects = ubifs_shrink_count,\n\t.seeks = DEFAULT_SEEKS,\n};\n\n \nstatic int validate_inode(struct ubifs_info *c, const struct inode *inode)\n{\n\tint err;\n\tconst struct ubifs_inode *ui = ubifs_inode(inode);\n\n\tif (inode->i_size > c->max_inode_sz) {\n\t\tubifs_err(c, \"inode is too large (%lld)\",\n\t\t\t  (long long)inode->i_size);\n\t\treturn 1;\n\t}\n\n\tif (ui->compr_type >= UBIFS_COMPR_TYPES_CNT) {\n\t\tubifs_err(c, \"unknown compression type %d\", ui->compr_type);\n\t\treturn 2;\n\t}\n\n\tif (ui->xattr_names + ui->xattr_cnt > XATTR_LIST_MAX)\n\t\treturn 3;\n\n\tif (ui->data_len < 0 || ui->data_len > UBIFS_MAX_INO_DATA)\n\t\treturn 4;\n\n\tif (ui->xattr && !S_ISREG(inode->i_mode))\n\t\treturn 5;\n\n\tif (!ubifs_compr_present(c, ui->compr_type)) {\n\t\tubifs_warn(c, \"inode %lu uses '%s' compression, but it was not compiled in\",\n\t\t\t   inode->i_ino, ubifs_compr_name(c, ui->compr_type));\n\t}\n\n\terr = dbg_check_dir(c, inode);\n\treturn err;\n}\n\nstruct inode *ubifs_iget(struct super_block *sb, unsigned long inum)\n{\n\tint err;\n\tunion ubifs_key key;\n\tstruct ubifs_ino_node *ino;\n\tstruct ubifs_info *c = sb->s_fs_info;\n\tstruct inode *inode;\n\tstruct ubifs_inode *ui;\n\n\tdbg_gen(\"inode %lu\", inum);\n\n\tinode = iget_locked(sb, inum);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\tui = ubifs_inode(inode);\n\n\tino = kmalloc(UBIFS_MAX_INO_NODE_SZ, GFP_NOFS);\n\tif (!ino) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tino_key_init(c, &key, inode->i_ino);\n\n\terr = ubifs_tnc_lookup(c, &key, ino);\n\tif (err)\n\t\tgoto out_ino;\n\n\tinode->i_flags |= S_NOCMTIME;\n\n\tif (!IS_ENABLED(CONFIG_UBIFS_ATIME_SUPPORT))\n\t\tinode->i_flags |= S_NOATIME;\n\n\tset_nlink(inode, le32_to_cpu(ino->nlink));\n\ti_uid_write(inode, le32_to_cpu(ino->uid));\n\ti_gid_write(inode, le32_to_cpu(ino->gid));\n\tinode->i_atime.tv_sec  = (int64_t)le64_to_cpu(ino->atime_sec);\n\tinode->i_atime.tv_nsec = le32_to_cpu(ino->atime_nsec);\n\tinode->i_mtime.tv_sec  = (int64_t)le64_to_cpu(ino->mtime_sec);\n\tinode->i_mtime.tv_nsec = le32_to_cpu(ino->mtime_nsec);\n\tinode_set_ctime(inode, (int64_t)le64_to_cpu(ino->ctime_sec),\n\t\t\tle32_to_cpu(ino->ctime_nsec));\n\tinode->i_mode = le32_to_cpu(ino->mode);\n\tinode->i_size = le64_to_cpu(ino->size);\n\n\tui->data_len    = le32_to_cpu(ino->data_len);\n\tui->flags       = le32_to_cpu(ino->flags);\n\tui->compr_type  = le16_to_cpu(ino->compr_type);\n\tui->creat_sqnum = le64_to_cpu(ino->creat_sqnum);\n\tui->xattr_cnt   = le32_to_cpu(ino->xattr_cnt);\n\tui->xattr_size  = le32_to_cpu(ino->xattr_size);\n\tui->xattr_names = le32_to_cpu(ino->xattr_names);\n\tui->synced_i_size = ui->ui_size = inode->i_size;\n\n\tui->xattr = (ui->flags & UBIFS_XATTR_FL) ? 1 : 0;\n\n\terr = validate_inode(c, inode);\n\tif (err)\n\t\tgoto out_invalid;\n\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFREG:\n\t\tinode->i_mapping->a_ops = &ubifs_file_address_operations;\n\t\tinode->i_op = &ubifs_file_inode_operations;\n\t\tinode->i_fop = &ubifs_file_operations;\n\t\tif (ui->xattr) {\n\t\t\tui->data = kmalloc(ui->data_len + 1, GFP_NOFS);\n\t\t\tif (!ui->data) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out_ino;\n\t\t\t}\n\t\t\tmemcpy(ui->data, ino->data, ui->data_len);\n\t\t\t((char *)ui->data)[ui->data_len] = '\\0';\n\t\t} else if (ui->data_len != 0) {\n\t\t\terr = 10;\n\t\t\tgoto out_invalid;\n\t\t}\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tinode->i_op  = &ubifs_dir_inode_operations;\n\t\tinode->i_fop = &ubifs_dir_operations;\n\t\tif (ui->data_len != 0) {\n\t\t\terr = 11;\n\t\t\tgoto out_invalid;\n\t\t}\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &ubifs_symlink_inode_operations;\n\t\tif (ui->data_len <= 0 || ui->data_len > UBIFS_MAX_INO_DATA) {\n\t\t\terr = 12;\n\t\t\tgoto out_invalid;\n\t\t}\n\t\tui->data = kmalloc(ui->data_len + 1, GFP_NOFS);\n\t\tif (!ui->data) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_ino;\n\t\t}\n\t\tmemcpy(ui->data, ino->data, ui->data_len);\n\t\t((char *)ui->data)[ui->data_len] = '\\0';\n\t\tbreak;\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\t{\n\t\tdev_t rdev;\n\t\tunion ubifs_dev_desc *dev;\n\n\t\tui->data = kmalloc(sizeof(union ubifs_dev_desc), GFP_NOFS);\n\t\tif (!ui->data) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_ino;\n\t\t}\n\n\t\tdev = (union ubifs_dev_desc *)ino->data;\n\t\tif (ui->data_len == sizeof(dev->new))\n\t\t\trdev = new_decode_dev(le32_to_cpu(dev->new));\n\t\telse if (ui->data_len == sizeof(dev->huge))\n\t\t\trdev = huge_decode_dev(le64_to_cpu(dev->huge));\n\t\telse {\n\t\t\terr = 13;\n\t\t\tgoto out_invalid;\n\t\t}\n\t\tmemcpy(ui->data, ino->data, ui->data_len);\n\t\tinode->i_op = &ubifs_file_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, rdev);\n\t\tbreak;\n\t}\n\tcase S_IFSOCK:\n\tcase S_IFIFO:\n\t\tinode->i_op = &ubifs_file_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, 0);\n\t\tif (ui->data_len != 0) {\n\t\t\terr = 14;\n\t\t\tgoto out_invalid;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\terr = 15;\n\t\tgoto out_invalid;\n\t}\n\n\tkfree(ino);\n\tubifs_set_inode_flags(inode);\n\tunlock_new_inode(inode);\n\treturn inode;\n\nout_invalid:\n\tubifs_err(c, \"inode %lu validation failed, error %d\", inode->i_ino, err);\n\tubifs_dump_node(c, ino, UBIFS_MAX_INO_NODE_SZ);\n\tubifs_dump_inode(c, inode);\n\terr = -EINVAL;\nout_ino:\n\tkfree(ino);\nout:\n\tubifs_err(c, \"failed to read inode %lu, error %d\", inode->i_ino, err);\n\tiget_failed(inode);\n\treturn ERR_PTR(err);\n}\n\nstatic struct inode *ubifs_alloc_inode(struct super_block *sb)\n{\n\tstruct ubifs_inode *ui;\n\n\tui = alloc_inode_sb(sb, ubifs_inode_slab, GFP_NOFS);\n\tif (!ui)\n\t\treturn NULL;\n\n\tmemset((void *)ui + sizeof(struct inode), 0,\n\t       sizeof(struct ubifs_inode) - sizeof(struct inode));\n\tmutex_init(&ui->ui_mutex);\n\tinit_rwsem(&ui->xattr_sem);\n\tspin_lock_init(&ui->ui_lock);\n\treturn &ui->vfs_inode;\n};\n\nstatic void ubifs_free_inode(struct inode *inode)\n{\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\n\tkfree(ui->data);\n\tfscrypt_free_inode(inode);\n\n\tkmem_cache_free(ubifs_inode_slab, ui);\n}\n\n \nstatic int ubifs_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tint err = 0;\n\tstruct ubifs_info *c = inode->i_sb->s_fs_info;\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\n\tubifs_assert(c, !ui->xattr);\n\tif (is_bad_inode(inode))\n\t\treturn 0;\n\n\tmutex_lock(&ui->ui_mutex);\n\t \n\tif (!ui->dirty) {\n\t\tmutex_unlock(&ui->ui_mutex);\n\t\treturn 0;\n\t}\n\n\t \n\tdbg_gen(\"inode %lu, mode %#x, nlink %u\",\n\t\tinode->i_ino, (int)inode->i_mode, inode->i_nlink);\n\tif (inode->i_nlink) {\n\t\terr = ubifs_jnl_write_inode(c, inode);\n\t\tif (err)\n\t\t\tubifs_err(c, \"can't write inode %lu, error %d\",\n\t\t\t\t  inode->i_ino, err);\n\t\telse\n\t\t\terr = dbg_check_inode_size(c, inode, ui->ui_size);\n\t}\n\n\tui->dirty = 0;\n\tmutex_unlock(&ui->ui_mutex);\n\tubifs_release_dirty_inode_budget(c, ui);\n\treturn err;\n}\n\nstatic int ubifs_drop_inode(struct inode *inode)\n{\n\tint drop = generic_drop_inode(inode);\n\n\tif (!drop)\n\t\tdrop = fscrypt_drop_inode(inode);\n\n\treturn drop;\n}\n\nstatic void ubifs_evict_inode(struct inode *inode)\n{\n\tint err;\n\tstruct ubifs_info *c = inode->i_sb->s_fs_info;\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\n\tif (ui->xattr)\n\t\t \n\t\tgoto out;\n\n\tdbg_gen(\"inode %lu, mode %#x\", inode->i_ino, (int)inode->i_mode);\n\tubifs_assert(c, !atomic_read(&inode->i_count));\n\n\ttruncate_inode_pages_final(&inode->i_data);\n\n\tif (inode->i_nlink)\n\t\tgoto done;\n\n\tif (is_bad_inode(inode))\n\t\tgoto out;\n\n\tui->ui_size = inode->i_size = 0;\n\terr = ubifs_jnl_delete_inode(c, inode);\n\tif (err)\n\t\t \n\t\tubifs_err(c, \"can't delete inode %lu, error %d\",\n\t\t\t  inode->i_ino, err);\n\nout:\n\tif (ui->dirty)\n\t\tubifs_release_dirty_inode_budget(c, ui);\n\telse {\n\t\t \n\t\tc->bi.nospace = c->bi.nospace_rp = 0;\n\t\tsmp_wmb();\n\t}\ndone:\n\tclear_inode(inode);\n\tfscrypt_put_encryption_info(inode);\n}\n\nstatic void ubifs_dirty_inode(struct inode *inode, int flags)\n{\n\tstruct ubifs_info *c = inode->i_sb->s_fs_info;\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\n\tubifs_assert(c, mutex_is_locked(&ui->ui_mutex));\n\tif (!ui->dirty) {\n\t\tui->dirty = 1;\n\t\tdbg_gen(\"inode %lu\",  inode->i_ino);\n\t}\n}\n\nstatic int ubifs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct ubifs_info *c = dentry->d_sb->s_fs_info;\n\tunsigned long long free;\n\t__le32 *uuid = (__le32 *)c->uuid;\n\n\tfree = ubifs_get_free_space(c);\n\tdbg_gen(\"free space %lld bytes (%lld blocks)\",\n\t\tfree, free >> UBIFS_BLOCK_SHIFT);\n\n\tbuf->f_type = UBIFS_SUPER_MAGIC;\n\tbuf->f_bsize = UBIFS_BLOCK_SIZE;\n\tbuf->f_blocks = c->block_cnt;\n\tbuf->f_bfree = free >> UBIFS_BLOCK_SHIFT;\n\tif (free > c->report_rp_size)\n\t\tbuf->f_bavail = (free - c->report_rp_size) >> UBIFS_BLOCK_SHIFT;\n\telse\n\t\tbuf->f_bavail = 0;\n\tbuf->f_files = 0;\n\tbuf->f_ffree = 0;\n\tbuf->f_namelen = UBIFS_MAX_NLEN;\n\tbuf->f_fsid.val[0] = le32_to_cpu(uuid[0]) ^ le32_to_cpu(uuid[2]);\n\tbuf->f_fsid.val[1] = le32_to_cpu(uuid[1]) ^ le32_to_cpu(uuid[3]);\n\tubifs_assert(c, buf->f_bfree <= c->block_cnt);\n\treturn 0;\n}\n\nstatic int ubifs_show_options(struct seq_file *s, struct dentry *root)\n{\n\tstruct ubifs_info *c = root->d_sb->s_fs_info;\n\n\tif (c->mount_opts.unmount_mode == 2)\n\t\tseq_puts(s, \",fast_unmount\");\n\telse if (c->mount_opts.unmount_mode == 1)\n\t\tseq_puts(s, \",norm_unmount\");\n\n\tif (c->mount_opts.bulk_read == 2)\n\t\tseq_puts(s, \",bulk_read\");\n\telse if (c->mount_opts.bulk_read == 1)\n\t\tseq_puts(s, \",no_bulk_read\");\n\n\tif (c->mount_opts.chk_data_crc == 2)\n\t\tseq_puts(s, \",chk_data_crc\");\n\telse if (c->mount_opts.chk_data_crc == 1)\n\t\tseq_puts(s, \",no_chk_data_crc\");\n\n\tif (c->mount_opts.override_compr) {\n\t\tseq_printf(s, \",compr=%s\",\n\t\t\t   ubifs_compr_name(c, c->mount_opts.compr_type));\n\t}\n\n\tseq_printf(s, \",assert=%s\", ubifs_assert_action_name(c));\n\tseq_printf(s, \",ubi=%d,vol=%d\", c->vi.ubi_num, c->vi.vol_id);\n\n\treturn 0;\n}\n\nstatic int ubifs_sync_fs(struct super_block *sb, int wait)\n{\n\tint i, err;\n\tstruct ubifs_info *c = sb->s_fs_info;\n\n\t \n\tif (!wait)\n\t\treturn 0;\n\n\t \n\tfor (i = 0; i < c->jhead_cnt; i++) {\n\t\terr = ubifs_wbuf_sync(&c->jheads[i].wbuf);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\terr = ubifs_run_commit(c);\n\tif (err)\n\t\treturn err;\n\n\treturn ubi_sync(c->vi.ubi_num);\n}\n\n \nstatic int init_constants_early(struct ubifs_info *c)\n{\n\tif (c->vi.corrupted) {\n\t\tubifs_warn(c, \"UBI volume is corrupted - read-only mode\");\n\t\tc->ro_media = 1;\n\t}\n\n\tif (c->di.ro_mode) {\n\t\tubifs_msg(c, \"read-only UBI device\");\n\t\tc->ro_media = 1;\n\t}\n\n\tif (c->vi.vol_type == UBI_STATIC_VOLUME) {\n\t\tubifs_msg(c, \"static UBI volume - read-only mode\");\n\t\tc->ro_media = 1;\n\t}\n\n\tc->leb_cnt = c->vi.size;\n\tc->leb_size = c->vi.usable_leb_size;\n\tc->leb_start = c->di.leb_start;\n\tc->half_leb_size = c->leb_size / 2;\n\tc->min_io_size = c->di.min_io_size;\n\tc->min_io_shift = fls(c->min_io_size) - 1;\n\tc->max_write_size = c->di.max_write_size;\n\tc->max_write_shift = fls(c->max_write_size) - 1;\n\n\tif (c->leb_size < UBIFS_MIN_LEB_SZ) {\n\t\tubifs_errc(c, \"too small LEBs (%d bytes), min. is %d bytes\",\n\t\t\t   c->leb_size, UBIFS_MIN_LEB_SZ);\n\t\treturn -EINVAL;\n\t}\n\n\tif (c->leb_cnt < UBIFS_MIN_LEB_CNT) {\n\t\tubifs_errc(c, \"too few LEBs (%d), min. is %d\",\n\t\t\t   c->leb_cnt, UBIFS_MIN_LEB_CNT);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!is_power_of_2(c->min_io_size)) {\n\t\tubifs_errc(c, \"bad min. I/O size %d\", c->min_io_size);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (c->max_write_size < c->min_io_size ||\n\t    c->max_write_size % c->min_io_size ||\n\t    !is_power_of_2(c->max_write_size)) {\n\t\tubifs_errc(c, \"bad write buffer size %d for %d min. I/O unit\",\n\t\t\t   c->max_write_size, c->min_io_size);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (c->min_io_size < 8) {\n\t\tc->min_io_size = 8;\n\t\tc->min_io_shift = 3;\n\t\tif (c->max_write_size < c->min_io_size) {\n\t\t\tc->max_write_size = c->min_io_size;\n\t\t\tc->max_write_shift = c->min_io_shift;\n\t\t}\n\t}\n\n\tc->ref_node_alsz = ALIGN(UBIFS_REF_NODE_SZ, c->min_io_size);\n\tc->mst_node_alsz = ALIGN(UBIFS_MST_NODE_SZ, c->min_io_size);\n\n\t \n\tc->ranges[UBIFS_PAD_NODE].len  = UBIFS_PAD_NODE_SZ;\n\tc->ranges[UBIFS_SB_NODE].len   = UBIFS_SB_NODE_SZ;\n\tc->ranges[UBIFS_MST_NODE].len  = UBIFS_MST_NODE_SZ;\n\tc->ranges[UBIFS_REF_NODE].len  = UBIFS_REF_NODE_SZ;\n\tc->ranges[UBIFS_TRUN_NODE].len = UBIFS_TRUN_NODE_SZ;\n\tc->ranges[UBIFS_CS_NODE].len   = UBIFS_CS_NODE_SZ;\n\tc->ranges[UBIFS_AUTH_NODE].min_len = UBIFS_AUTH_NODE_SZ;\n\tc->ranges[UBIFS_AUTH_NODE].max_len = UBIFS_AUTH_NODE_SZ +\n\t\t\t\tUBIFS_MAX_HMAC_LEN;\n\tc->ranges[UBIFS_SIG_NODE].min_len = UBIFS_SIG_NODE_SZ;\n\tc->ranges[UBIFS_SIG_NODE].max_len = c->leb_size - UBIFS_SB_NODE_SZ;\n\n\tc->ranges[UBIFS_INO_NODE].min_len  = UBIFS_INO_NODE_SZ;\n\tc->ranges[UBIFS_INO_NODE].max_len  = UBIFS_MAX_INO_NODE_SZ;\n\tc->ranges[UBIFS_ORPH_NODE].min_len =\n\t\t\t\tUBIFS_ORPH_NODE_SZ + sizeof(__le64);\n\tc->ranges[UBIFS_ORPH_NODE].max_len = c->leb_size;\n\tc->ranges[UBIFS_DENT_NODE].min_len = UBIFS_DENT_NODE_SZ;\n\tc->ranges[UBIFS_DENT_NODE].max_len = UBIFS_MAX_DENT_NODE_SZ;\n\tc->ranges[UBIFS_XENT_NODE].min_len = UBIFS_XENT_NODE_SZ;\n\tc->ranges[UBIFS_XENT_NODE].max_len = UBIFS_MAX_XENT_NODE_SZ;\n\tc->ranges[UBIFS_DATA_NODE].min_len = UBIFS_DATA_NODE_SZ;\n\tc->ranges[UBIFS_DATA_NODE].max_len = UBIFS_MAX_DATA_NODE_SZ;\n\t \n\tc->ranges[UBIFS_IDX_NODE].min_len = UBIFS_IDX_NODE_SZ + UBIFS_BRANCH_SZ;\n\t \n\tc->ranges[UBIFS_IDX_NODE].max_len = INT_MAX;\n\n\t \n\tc->dead_wm = ALIGN(MIN_WRITE_SZ, c->min_io_size);\n\tc->dark_wm = ALIGN(UBIFS_MAX_NODE_SZ, c->min_io_size);\n\n\t \n\tc->leb_overhead = c->leb_size % UBIFS_MAX_DATA_NODE_SZ;\n\n\t \n\tc->max_bu_buf_len = UBIFS_MAX_BULK_READ * UBIFS_MAX_DATA_NODE_SZ;\n\tif (c->max_bu_buf_len > c->leb_size)\n\t\tc->max_bu_buf_len = c->leb_size;\n\n\t \n\tc->min_log_bytes = c->leb_size;\n\n\treturn 0;\n}\n\n \nstatic int bud_wbuf_callback(struct ubifs_info *c, int lnum, int free, int pad)\n{\n\treturn ubifs_update_one_lp(c, lnum, free, pad, 0, 0);\n}\n\n \nstatic int init_constants_sb(struct ubifs_info *c)\n{\n\tint tmp, err;\n\tlong long tmp64;\n\n\tc->main_bytes = (long long)c->main_lebs * c->leb_size;\n\tc->max_znode_sz = sizeof(struct ubifs_znode) +\n\t\t\t\tc->fanout * sizeof(struct ubifs_zbranch);\n\n\ttmp = ubifs_idx_node_sz(c, 1);\n\tc->ranges[UBIFS_IDX_NODE].min_len = tmp;\n\tc->min_idx_node_sz = ALIGN(tmp, 8);\n\n\ttmp = ubifs_idx_node_sz(c, c->fanout);\n\tc->ranges[UBIFS_IDX_NODE].max_len = tmp;\n\tc->max_idx_node_sz = ALIGN(tmp, 8);\n\n\t \n\ttmp = UBIFS_CS_NODE_SZ + UBIFS_REF_NODE_SZ * c->jhead_cnt;\n\ttmp = ALIGN(tmp, c->min_io_size);\n\tif (tmp > c->leb_size) {\n\t\tubifs_err(c, \"too small LEB size %d, at least %d needed\",\n\t\t\t  c->leb_size, tmp);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\ttmp64 = c->max_bud_bytes + c->leb_size - 1;\n\tc->max_bud_cnt = div_u64(tmp64, c->leb_size);\n\ttmp = (c->ref_node_alsz * c->max_bud_cnt + c->leb_size - 1);\n\ttmp /= c->leb_size;\n\ttmp += 1;\n\tif (c->log_lebs < tmp) {\n\t\tubifs_err(c, \"too small log %d LEBs, required min. %d LEBs\",\n\t\t\t  c->log_lebs, tmp);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tc->bi.page_budget = UBIFS_MAX_DATA_NODE_SZ * UBIFS_BLOCKS_PER_PAGE;\n\tc->bi.inode_budget = UBIFS_INO_NODE_SZ;\n\tc->bi.dent_budget = UBIFS_MAX_DENT_NODE_SZ;\n\n\t \n\tc->bg_bud_bytes = (c->max_bud_bytes * 13) >> 4;\n\n\t \n\ttmp64 = (long long)(c->jhead_cnt + 1) * c->leb_size + 1;\n\tif (c->bg_bud_bytes < tmp64)\n\t\tc->bg_bud_bytes = tmp64;\n\tif (c->max_bud_bytes < tmp64 + c->leb_size)\n\t\tc->max_bud_bytes = tmp64 + c->leb_size;\n\n\terr = ubifs_calc_lpt_geom(c);\n\tif (err)\n\t\treturn err;\n\n\t \n\tc->idx_leb_size = c->leb_size - c->max_idx_node_sz;\n\treturn 0;\n}\n\n \nstatic void init_constants_master(struct ubifs_info *c)\n{\n\tlong long tmp64;\n\n\tc->bi.min_idx_lebs = ubifs_calc_min_idx_lebs(c);\n\tc->report_rp_size = ubifs_reported_space(c, c->rp_size);\n\n\t \n\ttmp64 = c->main_lebs - 1 - 1 - MIN_INDEX_LEBS - c->jhead_cnt + 1;\n\ttmp64 *= (long long)c->leb_size - c->leb_overhead;\n\ttmp64 = ubifs_reported_space(c, tmp64);\n\tc->block_cnt = tmp64 >> UBIFS_BLOCK_SHIFT;\n}\n\n \nstatic int take_gc_lnum(struct ubifs_info *c)\n{\n\tint err;\n\n\tif (c->gc_lnum == -1) {\n\t\tubifs_err(c, \"no LEB for GC\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\terr = ubifs_change_one_lp(c, c->gc_lnum, c->leb_size, 0,\n\t\t\t\t  LPROPS_TAKEN, 0, 0);\n\treturn err;\n}\n\n \nstatic int alloc_wbufs(struct ubifs_info *c)\n{\n\tint i, err;\n\n\tc->jheads = kcalloc(c->jhead_cnt, sizeof(struct ubifs_jhead),\n\t\t\t    GFP_KERNEL);\n\tif (!c->jheads)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = 0; i < c->jhead_cnt; i++) {\n\t\tINIT_LIST_HEAD(&c->jheads[i].buds_list);\n\t\terr = ubifs_wbuf_init(c, &c->jheads[i].wbuf);\n\t\tif (err)\n\t\t\tgoto out_wbuf;\n\n\t\tc->jheads[i].wbuf.sync_callback = &bud_wbuf_callback;\n\t\tc->jheads[i].wbuf.jhead = i;\n\t\tc->jheads[i].grouped = 1;\n\t\tc->jheads[i].log_hash = ubifs_hash_get_desc(c);\n\t\tif (IS_ERR(c->jheads[i].log_hash)) {\n\t\t\terr = PTR_ERR(c->jheads[i].log_hash);\n\t\t\tgoto out_log_hash;\n\t\t}\n\t}\n\n\t \n\tc->jheads[GCHD].wbuf.no_timer = 1;\n\tc->jheads[GCHD].grouped = 0;\n\n\treturn 0;\n\nout_log_hash:\n\tkfree(c->jheads[i].wbuf.buf);\n\tkfree(c->jheads[i].wbuf.inodes);\n\nout_wbuf:\n\twhile (i--) {\n\t\tkfree(c->jheads[i].wbuf.buf);\n\t\tkfree(c->jheads[i].wbuf.inodes);\n\t\tkfree(c->jheads[i].log_hash);\n\t}\n\tkfree(c->jheads);\n\tc->jheads = NULL;\n\n\treturn err;\n}\n\n \nstatic void free_wbufs(struct ubifs_info *c)\n{\n\tint i;\n\n\tif (c->jheads) {\n\t\tfor (i = 0; i < c->jhead_cnt; i++) {\n\t\t\tkfree(c->jheads[i].wbuf.buf);\n\t\t\tkfree(c->jheads[i].wbuf.inodes);\n\t\t\tkfree(c->jheads[i].log_hash);\n\t\t}\n\t\tkfree(c->jheads);\n\t\tc->jheads = NULL;\n\t}\n}\n\n \nstatic void free_orphans(struct ubifs_info *c)\n{\n\tstruct ubifs_orphan *orph;\n\n\twhile (c->orph_dnext) {\n\t\torph = c->orph_dnext;\n\t\tc->orph_dnext = orph->dnext;\n\t\tlist_del(&orph->list);\n\t\tkfree(orph);\n\t}\n\n\twhile (!list_empty(&c->orph_list)) {\n\t\torph = list_entry(c->orph_list.next, struct ubifs_orphan, list);\n\t\tlist_del(&orph->list);\n\t\tkfree(orph);\n\t\tubifs_err(c, \"orphan list not empty at unmount\");\n\t}\n\n\tvfree(c->orph_buf);\n\tc->orph_buf = NULL;\n}\n\n \nstatic void free_buds(struct ubifs_info *c)\n{\n\tstruct ubifs_bud *bud, *n;\n\n\trbtree_postorder_for_each_entry_safe(bud, n, &c->buds, rb)\n\t\tkfree(bud);\n}\n\n \nstatic int check_volume_empty(struct ubifs_info *c)\n{\n\tint lnum, err;\n\n\tc->empty = 1;\n\tfor (lnum = 0; lnum < c->leb_cnt; lnum++) {\n\t\terr = ubifs_is_mapped(c, lnum);\n\t\tif (unlikely(err < 0))\n\t\t\treturn err;\n\t\tif (err == 1) {\n\t\t\tc->empty = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}\n\n \nenum {\n\tOpt_fast_unmount,\n\tOpt_norm_unmount,\n\tOpt_bulk_read,\n\tOpt_no_bulk_read,\n\tOpt_chk_data_crc,\n\tOpt_no_chk_data_crc,\n\tOpt_override_compr,\n\tOpt_assert,\n\tOpt_auth_key,\n\tOpt_auth_hash_name,\n\tOpt_ignore,\n\tOpt_err,\n};\n\nstatic const match_table_t tokens = {\n\t{Opt_fast_unmount, \"fast_unmount\"},\n\t{Opt_norm_unmount, \"norm_unmount\"},\n\t{Opt_bulk_read, \"bulk_read\"},\n\t{Opt_no_bulk_read, \"no_bulk_read\"},\n\t{Opt_chk_data_crc, \"chk_data_crc\"},\n\t{Opt_no_chk_data_crc, \"no_chk_data_crc\"},\n\t{Opt_override_compr, \"compr=%s\"},\n\t{Opt_auth_key, \"auth_key=%s\"},\n\t{Opt_auth_hash_name, \"auth_hash_name=%s\"},\n\t{Opt_ignore, \"ubi=%s\"},\n\t{Opt_ignore, \"vol=%s\"},\n\t{Opt_assert, \"assert=%s\"},\n\t{Opt_err, NULL},\n};\n\n \nstatic int parse_standard_option(const char *option)\n{\n\n\tpr_notice(\"UBIFS: parse %s\\n\", option);\n\tif (!strcmp(option, \"sync\"))\n\t\treturn SB_SYNCHRONOUS;\n\treturn 0;\n}\n\n \nstatic int ubifs_parse_options(struct ubifs_info *c, char *options,\n\t\t\t       int is_remount)\n{\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\n\tif (!options)\n\t\treturn 0;\n\n\twhile ((p = strsep(&options, \",\"))) {\n\t\tint token;\n\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\t \n\t\tcase Opt_fast_unmount:\n\t\t\tc->mount_opts.unmount_mode = 2;\n\t\t\tbreak;\n\t\tcase Opt_norm_unmount:\n\t\t\tc->mount_opts.unmount_mode = 1;\n\t\t\tbreak;\n\t\tcase Opt_bulk_read:\n\t\t\tc->mount_opts.bulk_read = 2;\n\t\t\tc->bulk_read = 1;\n\t\t\tbreak;\n\t\tcase Opt_no_bulk_read:\n\t\t\tc->mount_opts.bulk_read = 1;\n\t\t\tc->bulk_read = 0;\n\t\t\tbreak;\n\t\tcase Opt_chk_data_crc:\n\t\t\tc->mount_opts.chk_data_crc = 2;\n\t\t\tc->no_chk_data_crc = 0;\n\t\t\tbreak;\n\t\tcase Opt_no_chk_data_crc:\n\t\t\tc->mount_opts.chk_data_crc = 1;\n\t\t\tc->no_chk_data_crc = 1;\n\t\t\tbreak;\n\t\tcase Opt_override_compr:\n\t\t{\n\t\t\tchar *name = match_strdup(&args[0]);\n\n\t\t\tif (!name)\n\t\t\t\treturn -ENOMEM;\n\t\t\tif (!strcmp(name, \"none\"))\n\t\t\t\tc->mount_opts.compr_type = UBIFS_COMPR_NONE;\n\t\t\telse if (!strcmp(name, \"lzo\"))\n\t\t\t\tc->mount_opts.compr_type = UBIFS_COMPR_LZO;\n\t\t\telse if (!strcmp(name, \"zlib\"))\n\t\t\t\tc->mount_opts.compr_type = UBIFS_COMPR_ZLIB;\n\t\t\telse if (!strcmp(name, \"zstd\"))\n\t\t\t\tc->mount_opts.compr_type = UBIFS_COMPR_ZSTD;\n\t\t\telse {\n\t\t\t\tubifs_err(c, \"unknown compressor \\\"%s\\\"\", name);  \n\t\t\t\tkfree(name);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tkfree(name);\n\t\t\tc->mount_opts.override_compr = 1;\n\t\t\tc->default_compr = c->mount_opts.compr_type;\n\t\t\tbreak;\n\t\t}\n\t\tcase Opt_assert:\n\t\t{\n\t\t\tchar *act = match_strdup(&args[0]);\n\n\t\t\tif (!act)\n\t\t\t\treturn -ENOMEM;\n\t\t\tif (!strcmp(act, \"report\"))\n\t\t\t\tc->assert_action = ASSACT_REPORT;\n\t\t\telse if (!strcmp(act, \"read-only\"))\n\t\t\t\tc->assert_action = ASSACT_RO;\n\t\t\telse if (!strcmp(act, \"panic\"))\n\t\t\t\tc->assert_action = ASSACT_PANIC;\n\t\t\telse {\n\t\t\t\tubifs_err(c, \"unknown assert action \\\"%s\\\"\", act);\n\t\t\t\tkfree(act);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tkfree(act);\n\t\t\tbreak;\n\t\t}\n\t\tcase Opt_auth_key:\n\t\t\tif (!is_remount) {\n\t\t\t\tc->auth_key_name = kstrdup(args[0].from,\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\t\t\t\tif (!c->auth_key_name)\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_auth_hash_name:\n\t\t\tif (!is_remount) {\n\t\t\t\tc->auth_hash_name = kstrdup(args[0].from,\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\t\t\t\tif (!c->auth_hash_name)\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_ignore:\n\t\t\tbreak;\n\t\tdefault:\n\t\t{\n\t\t\tunsigned long flag;\n\t\t\tstruct super_block *sb = c->vfs_sb;\n\n\t\t\tflag = parse_standard_option(p);\n\t\t\tif (!flag) {\n\t\t\t\tubifs_err(c, \"unrecognized mount option \\\"%s\\\" or missing value\",\n\t\t\t\t\t  p);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tsb->s_flags |= flag;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic void ubifs_release_options(struct ubifs_info *c)\n{\n\tkfree(c->auth_key_name);\n\tc->auth_key_name = NULL;\n\tkfree(c->auth_hash_name);\n\tc->auth_hash_name = NULL;\n}\n\n \nstatic void destroy_journal(struct ubifs_info *c)\n{\n\twhile (!list_empty(&c->unclean_leb_list)) {\n\t\tstruct ubifs_unclean_leb *ucleb;\n\n\t\tucleb = list_entry(c->unclean_leb_list.next,\n\t\t\t\t   struct ubifs_unclean_leb, list);\n\t\tlist_del(&ucleb->list);\n\t\tkfree(ucleb);\n\t}\n\twhile (!list_empty(&c->old_buds)) {\n\t\tstruct ubifs_bud *bud;\n\n\t\tbud = list_entry(c->old_buds.next, struct ubifs_bud, list);\n\t\tlist_del(&bud->list);\n\t\tkfree(bud);\n\t}\n\tubifs_destroy_idx_gc(c);\n\tubifs_destroy_size_tree(c);\n\tubifs_tnc_close(c);\n\tfree_buds(c);\n}\n\n \nstatic void bu_init(struct ubifs_info *c)\n{\n\tubifs_assert(c, c->bulk_read == 1);\n\n\tif (c->bu.buf)\n\t\treturn;  \n\nagain:\n\tc->bu.buf = kmalloc(c->max_bu_buf_len, GFP_KERNEL | __GFP_NOWARN);\n\tif (!c->bu.buf) {\n\t\tif (c->max_bu_buf_len > UBIFS_KMALLOC_OK) {\n\t\t\tc->max_bu_buf_len = UBIFS_KMALLOC_OK;\n\t\t\tgoto again;\n\t\t}\n\n\t\t \n\t\tubifs_warn(c, \"cannot allocate %d bytes of memory for bulk-read, disabling it\",\n\t\t\t   c->max_bu_buf_len);\n\t\tc->mount_opts.bulk_read = 1;\n\t\tc->bulk_read = 0;\n\t\treturn;\n\t}\n}\n\n \nstatic int check_free_space(struct ubifs_info *c)\n{\n\tubifs_assert(c, c->dark_wm > 0);\n\tif (c->lst.total_free + c->lst.total_dirty < c->dark_wm) {\n\t\tubifs_err(c, \"insufficient free space to mount in R/W mode\");\n\t\tubifs_dump_budg(c, &c->bi);\n\t\tubifs_dump_lprops(c);\n\t\treturn -ENOSPC;\n\t}\n\treturn 0;\n}\n\n \nstatic int mount_ubifs(struct ubifs_info *c)\n{\n\tint err;\n\tlong long x, y;\n\tsize_t sz;\n\n\tc->ro_mount = !!sb_rdonly(c->vfs_sb);\n\t \n\tc->probing = !!(c->vfs_sb->s_flags & SB_SILENT);\n\n\terr = init_constants_early(c);\n\tif (err)\n\t\treturn err;\n\n\terr = ubifs_debugging_init(c);\n\tif (err)\n\t\treturn err;\n\n\terr = ubifs_sysfs_register(c);\n\tif (err)\n\t\tgoto out_debugging;\n\n\terr = check_volume_empty(c);\n\tif (err)\n\t\tgoto out_free;\n\n\tif (c->empty && (c->ro_mount || c->ro_media)) {\n\t\t \n\t\tubifs_err(c, \"can't format empty UBI volume: read-only %s\",\n\t\t\t  c->ro_media ? \"UBI volume\" : \"mount\");\n\t\terr = -EROFS;\n\t\tgoto out_free;\n\t}\n\n\tif (c->ro_media && !c->ro_mount) {\n\t\tubifs_err(c, \"cannot mount read-write - read-only media\");\n\t\terr = -EROFS;\n\t\tgoto out_free;\n\t}\n\n\t \n\terr = -ENOMEM;\n\tc->bottom_up_buf = kmalloc_array(BOTTOM_UP_HEIGHT, sizeof(int),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!c->bottom_up_buf)\n\t\tgoto out_free;\n\n\tc->sbuf = vmalloc(c->leb_size);\n\tif (!c->sbuf)\n\t\tgoto out_free;\n\n\tif (!c->ro_mount) {\n\t\tc->ileb_buf = vmalloc(c->leb_size);\n\t\tif (!c->ileb_buf)\n\t\t\tgoto out_free;\n\t}\n\n\tif (c->bulk_read == 1)\n\t\tbu_init(c);\n\n\tif (!c->ro_mount) {\n\t\tc->write_reserve_buf = kmalloc(COMPRESSED_DATA_NODE_BUF_SZ + \\\n\t\t\t\t\t       UBIFS_CIPHER_BLOCK_SIZE,\n\t\t\t\t\t       GFP_KERNEL);\n\t\tif (!c->write_reserve_buf)\n\t\t\tgoto out_free;\n\t}\n\n\tc->mounting = 1;\n\n\tif (c->auth_key_name) {\n\t\tif (IS_ENABLED(CONFIG_UBIFS_FS_AUTHENTICATION)) {\n\t\t\terr = ubifs_init_authentication(c);\n\t\t\tif (err)\n\t\t\t\tgoto out_free;\n\t\t} else {\n\t\t\tubifs_err(c, \"auth_key_name, but UBIFS is built without\"\n\t\t\t\t  \" authentication support\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\terr = ubifs_read_superblock(c);\n\tif (err)\n\t\tgoto out_auth;\n\n\tc->probing = 0;\n\n\t \n\tif (!ubifs_compr_present(c, c->default_compr)) {\n\t\tubifs_err(c, \"'compressor \\\"%s\\\" is not compiled in\",\n\t\t\t  ubifs_compr_name(c, c->default_compr));\n\t\terr = -ENOTSUPP;\n\t\tgoto out_auth;\n\t}\n\n\terr = init_constants_sb(c);\n\tif (err)\n\t\tgoto out_auth;\n\n\tsz = ALIGN(c->max_idx_node_sz, c->min_io_size) * 2;\n\tc->cbuf = kmalloc(sz, GFP_NOFS);\n\tif (!c->cbuf) {\n\t\terr = -ENOMEM;\n\t\tgoto out_auth;\n\t}\n\n\terr = alloc_wbufs(c);\n\tif (err)\n\t\tgoto out_cbuf;\n\n\tsprintf(c->bgt_name, BGT_NAME_PATTERN, c->vi.ubi_num, c->vi.vol_id);\n\tif (!c->ro_mount) {\n\t\t \n\t\tc->bgt = kthread_run(ubifs_bg_thread, c, \"%s\", c->bgt_name);\n\t\tif (IS_ERR(c->bgt)) {\n\t\t\terr = PTR_ERR(c->bgt);\n\t\t\tc->bgt = NULL;\n\t\t\tubifs_err(c, \"cannot spawn \\\"%s\\\", error %d\",\n\t\t\t\t  c->bgt_name, err);\n\t\t\tgoto out_wbufs;\n\t\t}\n\t}\n\n\terr = ubifs_read_master(c);\n\tif (err)\n\t\tgoto out_master;\n\n\tinit_constants_master(c);\n\n\tif ((c->mst_node->flags & cpu_to_le32(UBIFS_MST_DIRTY)) != 0) {\n\t\tubifs_msg(c, \"recovery needed\");\n\t\tc->need_recovery = 1;\n\t}\n\n\tif (c->need_recovery && !c->ro_mount) {\n\t\terr = ubifs_recover_inl_heads(c, c->sbuf);\n\t\tif (err)\n\t\t\tgoto out_master;\n\t}\n\n\terr = ubifs_lpt_init(c, 1, !c->ro_mount);\n\tif (err)\n\t\tgoto out_master;\n\n\tif (!c->ro_mount && c->space_fixup) {\n\t\terr = ubifs_fixup_free_space(c);\n\t\tif (err)\n\t\t\tgoto out_lpt;\n\t}\n\n\tif (!c->ro_mount && !c->need_recovery) {\n\t\t \n\t\tc->mst_node->flags |= cpu_to_le32(UBIFS_MST_DIRTY);\n\t\terr = ubifs_write_master(c);\n\t\tif (err)\n\t\t\tgoto out_lpt;\n\t}\n\n\t \n\tif (ubifs_authenticated(c) && ubifs_hmac_zero(c, c->sup_node->hmac)) {\n\t\terr = ubifs_hmac_wkm(c, c->sup_node->hmac_wkm);\n\t\tif (err)\n\t\t\tgoto out_lpt;\n\t\tc->superblock_need_write = 1;\n\t}\n\n\tif (!c->ro_mount && c->superblock_need_write) {\n\t\terr = ubifs_write_sb_node(c, c->sup_node);\n\t\tif (err)\n\t\t\tgoto out_lpt;\n\t\tc->superblock_need_write = 0;\n\t}\n\n\terr = dbg_check_idx_size(c, c->bi.old_idx_sz);\n\tif (err)\n\t\tgoto out_lpt;\n\n\terr = ubifs_replay_journal(c);\n\tif (err)\n\t\tgoto out_journal;\n\n\t \n\tc->bi.min_idx_lebs = ubifs_calc_min_idx_lebs(c);\n\n\terr = ubifs_mount_orphans(c, c->need_recovery, c->ro_mount);\n\tif (err)\n\t\tgoto out_orphans;\n\n\tif (!c->ro_mount) {\n\t\tint lnum;\n\n\t\terr = check_free_space(c);\n\t\tif (err)\n\t\t\tgoto out_orphans;\n\n\t\t \n\t\tlnum = c->lhead_lnum + 1;\n\t\tif (lnum >= UBIFS_LOG_LNUM + c->log_lebs)\n\t\t\tlnum = UBIFS_LOG_LNUM;\n\t\tif (lnum == c->ltail_lnum) {\n\t\t\terr = ubifs_consolidate_log(c);\n\t\t\tif (err)\n\t\t\t\tgoto out_orphans;\n\t\t}\n\n\t\tif (c->need_recovery) {\n\t\t\tif (!ubifs_authenticated(c)) {\n\t\t\t\terr = ubifs_recover_size(c, true);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out_orphans;\n\t\t\t}\n\n\t\t\terr = ubifs_rcvry_gc_commit(c);\n\t\t\tif (err)\n\t\t\t\tgoto out_orphans;\n\n\t\t\tif (ubifs_authenticated(c)) {\n\t\t\t\terr = ubifs_recover_size(c, false);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out_orphans;\n\t\t\t}\n\t\t} else {\n\t\t\terr = take_gc_lnum(c);\n\t\t\tif (err)\n\t\t\t\tgoto out_orphans;\n\n\t\t\t \n\t\t\terr = ubifs_leb_unmap(c, c->gc_lnum);\n\t\t\tif (err)\n\t\t\t\tgoto out_orphans;\n\t\t}\n\n\t\terr = dbg_check_lprops(c);\n\t\tif (err)\n\t\t\tgoto out_orphans;\n\t} else if (c->need_recovery) {\n\t\terr = ubifs_recover_size(c, false);\n\t\tif (err)\n\t\t\tgoto out_orphans;\n\t} else {\n\t\t \n\t\terr = take_gc_lnum(c);\n\t\tif (err)\n\t\t\tgoto out_orphans;\n\t}\n\n\tspin_lock(&ubifs_infos_lock);\n\tlist_add_tail(&c->infos_list, &ubifs_infos);\n\tspin_unlock(&ubifs_infos_lock);\n\n\tif (c->need_recovery) {\n\t\tif (c->ro_mount)\n\t\t\tubifs_msg(c, \"recovery deferred\");\n\t\telse {\n\t\t\tc->need_recovery = 0;\n\t\t\tubifs_msg(c, \"recovery completed\");\n\t\t\t \n\t\t\tubifs_assert(c, c->lst.taken_empty_lebs > 0);\n\t\t}\n\t} else\n\t\tubifs_assert(c, c->lst.taken_empty_lebs > 0);\n\n\terr = dbg_check_filesystem(c);\n\tif (err)\n\t\tgoto out_infos;\n\n\tdbg_debugfs_init_fs(c);\n\n\tc->mounting = 0;\n\n\tubifs_msg(c, \"UBIFS: mounted UBI device %d, volume %d, name \\\"%s\\\"%s\",\n\t\t  c->vi.ubi_num, c->vi.vol_id, c->vi.name,\n\t\t  c->ro_mount ? \", R/O mode\" : \"\");\n\tx = (long long)c->main_lebs * c->leb_size;\n\ty = (long long)c->log_lebs * c->leb_size + c->max_bud_bytes;\n\tubifs_msg(c, \"LEB size: %d bytes (%d KiB), min./max. I/O unit sizes: %d bytes/%d bytes\",\n\t\t  c->leb_size, c->leb_size >> 10, c->min_io_size,\n\t\t  c->max_write_size);\n\tubifs_msg(c, \"FS size: %lld bytes (%lld MiB, %d LEBs), max %d LEBs, journal size %lld bytes (%lld MiB, %d LEBs)\",\n\t\t  x, x >> 20, c->main_lebs, c->max_leb_cnt,\n\t\t  y, y >> 20, c->log_lebs + c->max_bud_cnt);\n\tubifs_msg(c, \"reserved for root: %llu bytes (%llu KiB)\",\n\t\t  c->report_rp_size, c->report_rp_size >> 10);\n\tubifs_msg(c, \"media format: w%d/r%d (latest is w%d/r%d), UUID %pUB%s\",\n\t\t  c->fmt_version, c->ro_compat_version,\n\t\t  UBIFS_FORMAT_VERSION, UBIFS_RO_COMPAT_VERSION, c->uuid,\n\t\t  c->big_lpt ? \", big LPT model\" : \", small LPT model\");\n\n\tdbg_gen(\"default compressor:  %s\", ubifs_compr_name(c, c->default_compr));\n\tdbg_gen(\"data journal heads:  %d\",\n\t\tc->jhead_cnt - NONDATA_JHEADS_CNT);\n\tdbg_gen(\"log LEBs:            %d (%d - %d)\",\n\t\tc->log_lebs, UBIFS_LOG_LNUM, c->log_last);\n\tdbg_gen(\"LPT area LEBs:       %d (%d - %d)\",\n\t\tc->lpt_lebs, c->lpt_first, c->lpt_last);\n\tdbg_gen(\"orphan area LEBs:    %d (%d - %d)\",\n\t\tc->orph_lebs, c->orph_first, c->orph_last);\n\tdbg_gen(\"main area LEBs:      %d (%d - %d)\",\n\t\tc->main_lebs, c->main_first, c->leb_cnt - 1);\n\tdbg_gen(\"index LEBs:          %d\", c->lst.idx_lebs);\n\tdbg_gen(\"total index bytes:   %llu (%llu KiB, %llu MiB)\",\n\t\tc->bi.old_idx_sz, c->bi.old_idx_sz >> 10,\n\t\tc->bi.old_idx_sz >> 20);\n\tdbg_gen(\"key hash type:       %d\", c->key_hash_type);\n\tdbg_gen(\"tree fanout:         %d\", c->fanout);\n\tdbg_gen(\"reserved GC LEB:     %d\", c->gc_lnum);\n\tdbg_gen(\"max. znode size      %d\", c->max_znode_sz);\n\tdbg_gen(\"max. index node size %d\", c->max_idx_node_sz);\n\tdbg_gen(\"node sizes:          data %zu, inode %zu, dentry %zu\",\n\t\tUBIFS_DATA_NODE_SZ, UBIFS_INO_NODE_SZ, UBIFS_DENT_NODE_SZ);\n\tdbg_gen(\"node sizes:          trun %zu, sb %zu, master %zu\",\n\t\tUBIFS_TRUN_NODE_SZ, UBIFS_SB_NODE_SZ, UBIFS_MST_NODE_SZ);\n\tdbg_gen(\"node sizes:          ref %zu, cmt. start %zu, orph %zu\",\n\t\tUBIFS_REF_NODE_SZ, UBIFS_CS_NODE_SZ, UBIFS_ORPH_NODE_SZ);\n\tdbg_gen(\"max. node sizes:     data %zu, inode %zu dentry %zu, idx %d\",\n\t\tUBIFS_MAX_DATA_NODE_SZ, UBIFS_MAX_INO_NODE_SZ,\n\t\tUBIFS_MAX_DENT_NODE_SZ, ubifs_idx_node_sz(c, c->fanout));\n\tdbg_gen(\"dead watermark:      %d\", c->dead_wm);\n\tdbg_gen(\"dark watermark:      %d\", c->dark_wm);\n\tdbg_gen(\"LEB overhead:        %d\", c->leb_overhead);\n\tx = (long long)c->main_lebs * c->dark_wm;\n\tdbg_gen(\"max. dark space:     %lld (%lld KiB, %lld MiB)\",\n\t\tx, x >> 10, x >> 20);\n\tdbg_gen(\"maximum bud bytes:   %lld (%lld KiB, %lld MiB)\",\n\t\tc->max_bud_bytes, c->max_bud_bytes >> 10,\n\t\tc->max_bud_bytes >> 20);\n\tdbg_gen(\"BG commit bud bytes: %lld (%lld KiB, %lld MiB)\",\n\t\tc->bg_bud_bytes, c->bg_bud_bytes >> 10,\n\t\tc->bg_bud_bytes >> 20);\n\tdbg_gen(\"current bud bytes    %lld (%lld KiB, %lld MiB)\",\n\t\tc->bud_bytes, c->bud_bytes >> 10, c->bud_bytes >> 20);\n\tdbg_gen(\"max. seq. number:    %llu\", c->max_sqnum);\n\tdbg_gen(\"commit number:       %llu\", c->cmt_no);\n\tdbg_gen(\"max. xattrs per inode: %d\", ubifs_xattr_max_cnt(c));\n\tdbg_gen(\"max orphans:           %d\", c->max_orphans);\n\n\treturn 0;\n\nout_infos:\n\tspin_lock(&ubifs_infos_lock);\n\tlist_del(&c->infos_list);\n\tspin_unlock(&ubifs_infos_lock);\nout_orphans:\n\tfree_orphans(c);\nout_journal:\n\tdestroy_journal(c);\nout_lpt:\n\tubifs_lpt_free(c, 0);\nout_master:\n\tkfree(c->mst_node);\n\tkfree(c->rcvrd_mst_node);\n\tif (c->bgt)\n\t\tkthread_stop(c->bgt);\nout_wbufs:\n\tfree_wbufs(c);\nout_cbuf:\n\tkfree(c->cbuf);\nout_auth:\n\tubifs_exit_authentication(c);\nout_free:\n\tkfree(c->write_reserve_buf);\n\tkfree(c->bu.buf);\n\tvfree(c->ileb_buf);\n\tvfree(c->sbuf);\n\tkfree(c->bottom_up_buf);\n\tkfree(c->sup_node);\n\tubifs_sysfs_unregister(c);\nout_debugging:\n\tubifs_debugging_exit(c);\n\treturn err;\n}\n\n \nstatic void ubifs_umount(struct ubifs_info *c)\n{\n\tdbg_gen(\"un-mounting UBI device %d, volume %d\", c->vi.ubi_num,\n\t\tc->vi.vol_id);\n\n\tdbg_debugfs_exit_fs(c);\n\tspin_lock(&ubifs_infos_lock);\n\tlist_del(&c->infos_list);\n\tspin_unlock(&ubifs_infos_lock);\n\n\tif (c->bgt)\n\t\tkthread_stop(c->bgt);\n\n\tdestroy_journal(c);\n\tfree_wbufs(c);\n\tfree_orphans(c);\n\tubifs_lpt_free(c, 0);\n\tubifs_exit_authentication(c);\n\n\tubifs_release_options(c);\n\tkfree(c->cbuf);\n\tkfree(c->rcvrd_mst_node);\n\tkfree(c->mst_node);\n\tkfree(c->write_reserve_buf);\n\tkfree(c->bu.buf);\n\tvfree(c->ileb_buf);\n\tvfree(c->sbuf);\n\tkfree(c->bottom_up_buf);\n\tkfree(c->sup_node);\n\tubifs_debugging_exit(c);\n\tubifs_sysfs_unregister(c);\n}\n\n \nstatic int ubifs_remount_rw(struct ubifs_info *c)\n{\n\tint err, lnum;\n\n\tif (c->rw_incompat) {\n\t\tubifs_err(c, \"the file-system is not R/W-compatible\");\n\t\tubifs_msg(c, \"on-flash format version is w%d/r%d, but software only supports up to version w%d/r%d\",\n\t\t\t  c->fmt_version, c->ro_compat_version,\n\t\t\t  UBIFS_FORMAT_VERSION, UBIFS_RO_COMPAT_VERSION);\n\t\treturn -EROFS;\n\t}\n\n\tmutex_lock(&c->umount_mutex);\n\tdbg_save_space_info(c);\n\tc->remounting_rw = 1;\n\tc->ro_mount = 0;\n\n\tif (c->space_fixup) {\n\t\terr = ubifs_fixup_free_space(c);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\terr = check_free_space(c);\n\tif (err)\n\t\tgoto out;\n\n\tif (c->need_recovery) {\n\t\tubifs_msg(c, \"completing deferred recovery\");\n\t\terr = ubifs_write_rcvrd_mst_node(c);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (!ubifs_authenticated(c)) {\n\t\t\terr = ubifs_recover_size(c, true);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t\terr = ubifs_clean_lebs(c, c->sbuf);\n\t\tif (err)\n\t\t\tgoto out;\n\t\terr = ubifs_recover_inl_heads(c, c->sbuf);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\t \n\t\tubifs_assert(c, c->tot_orphans == 0);\n\t\terr = ubifs_clear_orphans(c);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (!(c->mst_node->flags & cpu_to_le32(UBIFS_MST_DIRTY))) {\n\t\tc->mst_node->flags |= cpu_to_le32(UBIFS_MST_DIRTY);\n\t\terr = ubifs_write_master(c);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (c->superblock_need_write) {\n\t\tstruct ubifs_sb_node *sup = c->sup_node;\n\n\t\terr = ubifs_write_sb_node(c, sup);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tc->superblock_need_write = 0;\n\t}\n\n\tc->ileb_buf = vmalloc(c->leb_size);\n\tif (!c->ileb_buf) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tc->write_reserve_buf = kmalloc(COMPRESSED_DATA_NODE_BUF_SZ + \\\n\t\t\t\t       UBIFS_CIPHER_BLOCK_SIZE, GFP_KERNEL);\n\tif (!c->write_reserve_buf) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\terr = ubifs_lpt_init(c, 0, 1);\n\tif (err)\n\t\tgoto out;\n\n\t \n\tc->bgt = kthread_run(ubifs_bg_thread, c, \"%s\", c->bgt_name);\n\tif (IS_ERR(c->bgt)) {\n\t\terr = PTR_ERR(c->bgt);\n\t\tc->bgt = NULL;\n\t\tubifs_err(c, \"cannot spawn \\\"%s\\\", error %d\",\n\t\t\t  c->bgt_name, err);\n\t\tgoto out;\n\t}\n\n\tc->orph_buf = vmalloc(c->leb_size);\n\tif (!c->orph_buf) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\tlnum = c->lhead_lnum + 1;\n\tif (lnum >= UBIFS_LOG_LNUM + c->log_lebs)\n\t\tlnum = UBIFS_LOG_LNUM;\n\tif (lnum == c->ltail_lnum) {\n\t\terr = ubifs_consolidate_log(c);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (c->need_recovery) {\n\t\terr = ubifs_rcvry_gc_commit(c);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tif (ubifs_authenticated(c)) {\n\t\t\terr = ubifs_recover_size(c, false);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\terr = ubifs_leb_unmap(c, c->gc_lnum);\n\t}\n\tif (err)\n\t\tgoto out;\n\n\tdbg_gen(\"re-mounted read-write\");\n\tc->remounting_rw = 0;\n\n\tif (c->need_recovery) {\n\t\tc->need_recovery = 0;\n\t\tubifs_msg(c, \"deferred recovery completed\");\n\t} else {\n\t\t \n\t\terr = dbg_check_space_info(c);\n\t}\n\n\tmutex_unlock(&c->umount_mutex);\n\treturn err;\n\nout:\n\tc->ro_mount = 1;\n\tvfree(c->orph_buf);\n\tc->orph_buf = NULL;\n\tif (c->bgt) {\n\t\tkthread_stop(c->bgt);\n\t\tc->bgt = NULL;\n\t}\n\tkfree(c->write_reserve_buf);\n\tc->write_reserve_buf = NULL;\n\tvfree(c->ileb_buf);\n\tc->ileb_buf = NULL;\n\tubifs_lpt_free(c, 1);\n\tc->remounting_rw = 0;\n\tmutex_unlock(&c->umount_mutex);\n\treturn err;\n}\n\n \nstatic void ubifs_remount_ro(struct ubifs_info *c)\n{\n\tint i, err;\n\n\tubifs_assert(c, !c->need_recovery);\n\tubifs_assert(c, !c->ro_mount);\n\n\tmutex_lock(&c->umount_mutex);\n\tif (c->bgt) {\n\t\tkthread_stop(c->bgt);\n\t\tc->bgt = NULL;\n\t}\n\n\tdbg_save_space_info(c);\n\n\tfor (i = 0; i < c->jhead_cnt; i++) {\n\t\terr = ubifs_wbuf_sync(&c->jheads[i].wbuf);\n\t\tif (err)\n\t\t\tubifs_ro_mode(c, err);\n\t}\n\n\tc->mst_node->flags &= ~cpu_to_le32(UBIFS_MST_DIRTY);\n\tc->mst_node->flags |= cpu_to_le32(UBIFS_MST_NO_ORPHS);\n\tc->mst_node->gc_lnum = cpu_to_le32(c->gc_lnum);\n\terr = ubifs_write_master(c);\n\tif (err)\n\t\tubifs_ro_mode(c, err);\n\n\tvfree(c->orph_buf);\n\tc->orph_buf = NULL;\n\tkfree(c->write_reserve_buf);\n\tc->write_reserve_buf = NULL;\n\tvfree(c->ileb_buf);\n\tc->ileb_buf = NULL;\n\tubifs_lpt_free(c, 1);\n\tc->ro_mount = 1;\n\terr = dbg_check_space_info(c);\n\tif (err)\n\t\tubifs_ro_mode(c, err);\n\tmutex_unlock(&c->umount_mutex);\n}\n\nstatic void ubifs_put_super(struct super_block *sb)\n{\n\tint i;\n\tstruct ubifs_info *c = sb->s_fs_info;\n\n\tubifs_msg(c, \"un-mount UBI device %d\", c->vi.ubi_num);\n\n\t \n\tif (!c->ro_error) {\n\t\tubifs_assert(c, c->bi.idx_growth == 0);\n\t\tubifs_assert(c, c->bi.dd_growth == 0);\n\t\tubifs_assert(c, c->bi.data_growth == 0);\n\t}\n\n\t \n\tmutex_lock(&c->umount_mutex);\n\tif (!c->ro_mount) {\n\t\t \n\t\tif (c->bgt) {\n\t\t\tkthread_stop(c->bgt);\n\t\t\tc->bgt = NULL;\n\t\t}\n\n\t\t \n\t\tif (!c->ro_error) {\n\t\t\tint err;\n\n\t\t\t \n\t\t\tfor (i = 0; i < c->jhead_cnt; i++) {\n\t\t\t\terr = ubifs_wbuf_sync(&c->jheads[i].wbuf);\n\t\t\t\tif (err)\n\t\t\t\t\tubifs_ro_mode(c, err);\n\t\t\t}\n\n\t\t\t \n\t\t\tc->mst_node->flags &= ~cpu_to_le32(UBIFS_MST_DIRTY);\n\t\t\tc->mst_node->flags |= cpu_to_le32(UBIFS_MST_NO_ORPHS);\n\t\t\tc->mst_node->gc_lnum = cpu_to_le32(c->gc_lnum);\n\t\t\terr = ubifs_write_master(c);\n\t\t\tif (err)\n\t\t\t\t \n\t\t\t\tubifs_err(c, \"failed to write master node, error %d\",\n\t\t\t\t\t  err);\n\t\t} else {\n\t\t\tfor (i = 0; i < c->jhead_cnt; i++)\n\t\t\t\t \n\t\t\t\thrtimer_cancel(&c->jheads[i].wbuf.timer);\n\t\t}\n\t}\n\n\tubifs_umount(c);\n\tubi_close_volume(c->ubi);\n\tmutex_unlock(&c->umount_mutex);\n}\n\nstatic int ubifs_remount_fs(struct super_block *sb, int *flags, char *data)\n{\n\tint err;\n\tstruct ubifs_info *c = sb->s_fs_info;\n\n\tsync_filesystem(sb);\n\tdbg_gen(\"old flags %#lx, new flags %#x\", sb->s_flags, *flags);\n\n\terr = ubifs_parse_options(c, data, 1);\n\tif (err) {\n\t\tubifs_err(c, \"invalid or unknown remount parameter\");\n\t\treturn err;\n\t}\n\n\tif (c->ro_mount && !(*flags & SB_RDONLY)) {\n\t\tif (c->ro_error) {\n\t\t\tubifs_msg(c, \"cannot re-mount R/W due to prior errors\");\n\t\t\treturn -EROFS;\n\t\t}\n\t\tif (c->ro_media) {\n\t\t\tubifs_msg(c, \"cannot re-mount R/W - UBI volume is R/O\");\n\t\t\treturn -EROFS;\n\t\t}\n\t\terr = ubifs_remount_rw(c);\n\t\tif (err)\n\t\t\treturn err;\n\t} else if (!c->ro_mount && (*flags & SB_RDONLY)) {\n\t\tif (c->ro_error) {\n\t\t\tubifs_msg(c, \"cannot re-mount R/O due to prior errors\");\n\t\t\treturn -EROFS;\n\t\t}\n\t\tubifs_remount_ro(c);\n\t}\n\n\tif (c->bulk_read == 1)\n\t\tbu_init(c);\n\telse {\n\t\tdbg_gen(\"disable bulk-read\");\n\t\tmutex_lock(&c->bu_mutex);\n\t\tkfree(c->bu.buf);\n\t\tc->bu.buf = NULL;\n\t\tmutex_unlock(&c->bu_mutex);\n\t}\n\n\tif (!c->need_recovery)\n\t\tubifs_assert(c, c->lst.taken_empty_lebs > 0);\n\n\treturn 0;\n}\n\nconst struct super_operations ubifs_super_operations = {\n\t.alloc_inode   = ubifs_alloc_inode,\n\t.free_inode    = ubifs_free_inode,\n\t.put_super     = ubifs_put_super,\n\t.write_inode   = ubifs_write_inode,\n\t.drop_inode    = ubifs_drop_inode,\n\t.evict_inode   = ubifs_evict_inode,\n\t.statfs        = ubifs_statfs,\n\t.dirty_inode   = ubifs_dirty_inode,\n\t.remount_fs    = ubifs_remount_fs,\n\t.show_options  = ubifs_show_options,\n\t.sync_fs       = ubifs_sync_fs,\n};\n\n \nstatic struct ubi_volume_desc *open_ubi(const char *name, int mode)\n{\n\tstruct ubi_volume_desc *ubi;\n\tint dev, vol;\n\tchar *endptr;\n\n\tif (!name || !*name)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t \n\tubi = ubi_open_volume_path(name, mode);\n\tif (!IS_ERR(ubi))\n\t\treturn ubi;\n\n\t \n\tif (name[0] != 'u' || name[1] != 'b' || name[2] != 'i')\n\t\treturn ERR_PTR(-EINVAL);\n\n\t \n\tif ((name[3] == ':' || name[3] == '!') && name[4] != '\\0')\n\t\treturn ubi_open_volume_nm(0, name + 4, mode);\n\n\tif (!isdigit(name[3]))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdev = simple_strtoul(name + 3, &endptr, 0);\n\n\t \n\tif (*endptr == '\\0')\n\t\treturn ubi_open_volume(0, dev, mode);\n\n\t \n\tif (*endptr == '_' && isdigit(endptr[1])) {\n\t\tvol = simple_strtoul(endptr + 1, &endptr, 0);\n\t\tif (*endptr != '\\0')\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\treturn ubi_open_volume(dev, vol, mode);\n\t}\n\n\t \n\tif ((*endptr == ':' || *endptr == '!') && endptr[1] != '\\0')\n\t\treturn ubi_open_volume_nm(dev, ++endptr, mode);\n\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic struct ubifs_info *alloc_ubifs_info(struct ubi_volume_desc *ubi)\n{\n\tstruct ubifs_info *c;\n\n\tc = kzalloc(sizeof(struct ubifs_info), GFP_KERNEL);\n\tif (c) {\n\t\tspin_lock_init(&c->cnt_lock);\n\t\tspin_lock_init(&c->cs_lock);\n\t\tspin_lock_init(&c->buds_lock);\n\t\tspin_lock_init(&c->space_lock);\n\t\tspin_lock_init(&c->orphan_lock);\n\t\tinit_rwsem(&c->commit_sem);\n\t\tmutex_init(&c->lp_mutex);\n\t\tmutex_init(&c->tnc_mutex);\n\t\tmutex_init(&c->log_mutex);\n\t\tmutex_init(&c->umount_mutex);\n\t\tmutex_init(&c->bu_mutex);\n\t\tmutex_init(&c->write_reserve_mutex);\n\t\tinit_waitqueue_head(&c->cmt_wq);\n\t\tc->buds = RB_ROOT;\n\t\tc->old_idx = RB_ROOT;\n\t\tc->size_tree = RB_ROOT;\n\t\tc->orph_tree = RB_ROOT;\n\t\tINIT_LIST_HEAD(&c->infos_list);\n\t\tINIT_LIST_HEAD(&c->idx_gc);\n\t\tINIT_LIST_HEAD(&c->replay_list);\n\t\tINIT_LIST_HEAD(&c->replay_buds);\n\t\tINIT_LIST_HEAD(&c->uncat_list);\n\t\tINIT_LIST_HEAD(&c->empty_list);\n\t\tINIT_LIST_HEAD(&c->freeable_list);\n\t\tINIT_LIST_HEAD(&c->frdi_idx_list);\n\t\tINIT_LIST_HEAD(&c->unclean_leb_list);\n\t\tINIT_LIST_HEAD(&c->old_buds);\n\t\tINIT_LIST_HEAD(&c->orph_list);\n\t\tINIT_LIST_HEAD(&c->orph_new);\n\t\tc->no_chk_data_crc = 1;\n\t\tc->assert_action = ASSACT_RO;\n\n\t\tc->highest_inum = UBIFS_FIRST_INO;\n\t\tc->lhead_lnum = c->ltail_lnum = UBIFS_LOG_LNUM;\n\n\t\tubi_get_volume_info(ubi, &c->vi);\n\t\tubi_get_device_info(c->vi.ubi_num, &c->di);\n\t}\n\treturn c;\n}\n\nstatic int ubifs_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct ubifs_info *c = sb->s_fs_info;\n\tstruct inode *root;\n\tint err;\n\n\tc->vfs_sb = sb;\n\t \n\tc->ubi = ubi_open_volume(c->vi.ubi_num, c->vi.vol_id, UBI_READWRITE);\n\tif (IS_ERR(c->ubi)) {\n\t\terr = PTR_ERR(c->ubi);\n\t\tgoto out;\n\t}\n\n\terr = ubifs_parse_options(c, data, 0);\n\tif (err)\n\t\tgoto out_close;\n\n\t \n\terr = super_setup_bdi_name(sb, \"ubifs_%d_%d\", c->vi.ubi_num,\n\t\t\t\t   c->vi.vol_id);\n\tif (err)\n\t\tgoto out_close;\n\tsb->s_bdi->ra_pages = 0;\n\tsb->s_bdi->io_pages = 0;\n\n\tsb->s_fs_info = c;\n\tsb->s_magic = UBIFS_SUPER_MAGIC;\n\tsb->s_blocksize = UBIFS_BLOCK_SIZE;\n\tsb->s_blocksize_bits = UBIFS_BLOCK_SHIFT;\n\tsb->s_maxbytes = c->max_inode_sz = key_max_inode_size(c);\n\tif (c->max_inode_sz > MAX_LFS_FILESIZE)\n\t\tsb->s_maxbytes = c->max_inode_sz = MAX_LFS_FILESIZE;\n\tsb->s_op = &ubifs_super_operations;\n\tsb->s_xattr = ubifs_xattr_handlers;\n\tfscrypt_set_ops(sb, &ubifs_crypt_operations);\n\n\tmutex_lock(&c->umount_mutex);\n\terr = mount_ubifs(c);\n\tif (err) {\n\t\tubifs_assert(c, err < 0);\n\t\tgoto out_unlock;\n\t}\n\n\t \n\troot = ubifs_iget(sb, UBIFS_ROOT_INO);\n\tif (IS_ERR(root)) {\n\t\terr = PTR_ERR(root);\n\t\tgoto out_umount;\n\t}\n\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\terr = -ENOMEM;\n\t\tgoto out_umount;\n\t}\n\n\timport_uuid(&sb->s_uuid, c->uuid);\n\n\tmutex_unlock(&c->umount_mutex);\n\treturn 0;\n\nout_umount:\n\tubifs_umount(c);\nout_unlock:\n\tmutex_unlock(&c->umount_mutex);\nout_close:\n\tubifs_release_options(c);\n\tubi_close_volume(c->ubi);\nout:\n\treturn err;\n}\n\nstatic int sb_test(struct super_block *sb, void *data)\n{\n\tstruct ubifs_info *c1 = data;\n\tstruct ubifs_info *c = sb->s_fs_info;\n\n\treturn c->vi.cdev == c1->vi.cdev;\n}\n\nstatic int sb_set(struct super_block *sb, void *data)\n{\n\tsb->s_fs_info = data;\n\treturn set_anon_super(sb, NULL);\n}\n\nstatic struct dentry *ubifs_mount(struct file_system_type *fs_type, int flags,\n\t\t\tconst char *name, void *data)\n{\n\tstruct ubi_volume_desc *ubi;\n\tstruct ubifs_info *c;\n\tstruct super_block *sb;\n\tint err;\n\n\tdbg_gen(\"name %s, flags %#x\", name, flags);\n\n\t \n\tubi = open_ubi(name, UBI_READONLY);\n\tif (IS_ERR(ubi)) {\n\t\tif (!(flags & SB_SILENT))\n\t\t\tpr_err(\"UBIFS error (pid: %d): cannot open \\\"%s\\\", error %d\",\n\t\t\t       current->pid, name, (int)PTR_ERR(ubi));\n\t\treturn ERR_CAST(ubi);\n\t}\n\n\tc = alloc_ubifs_info(ubi);\n\tif (!c) {\n\t\terr = -ENOMEM;\n\t\tgoto out_close;\n\t}\n\n\tdbg_gen(\"opened ubi%d_%d\", c->vi.ubi_num, c->vi.vol_id);\n\n\tsb = sget(fs_type, sb_test, sb_set, flags, c);\n\tif (IS_ERR(sb)) {\n\t\terr = PTR_ERR(sb);\n\t\tkfree(c);\n\t\tgoto out_close;\n\t}\n\n\tif (sb->s_root) {\n\t\tstruct ubifs_info *c1 = sb->s_fs_info;\n\t\tkfree(c);\n\t\t \n\t\tdbg_gen(\"this ubi volume is already mounted\");\n\t\tif (!!(flags & SB_RDONLY) != c1->ro_mount) {\n\t\t\terr = -EBUSY;\n\t\t\tgoto out_deact;\n\t\t}\n\t} else {\n\t\terr = ubifs_fill_super(sb, data, flags & SB_SILENT ? 1 : 0);\n\t\tif (err)\n\t\t\tgoto out_deact;\n\t\t \n\t\tsb->s_flags |= SB_ACTIVE;\n\t\tif (IS_ENABLED(CONFIG_UBIFS_ATIME_SUPPORT))\n\t\t\tubifs_msg(c, \"full atime support is enabled.\");\n\t\telse\n\t\t\tsb->s_flags |= SB_NOATIME;\n\t}\n\n\t \n\tubi_close_volume(ubi);\n\n\treturn dget(sb->s_root);\n\nout_deact:\n\tdeactivate_locked_super(sb);\nout_close:\n\tubi_close_volume(ubi);\n\treturn ERR_PTR(err);\n}\n\nstatic void kill_ubifs_super(struct super_block *s)\n{\n\tstruct ubifs_info *c = s->s_fs_info;\n\tkill_anon_super(s);\n\tkfree(c);\n}\n\nstatic struct file_system_type ubifs_fs_type = {\n\t.name    = \"ubifs\",\n\t.owner   = THIS_MODULE,\n\t.mount   = ubifs_mount,\n\t.kill_sb = kill_ubifs_super,\n};\nMODULE_ALIAS_FS(\"ubifs\");\n\n \nstatic void inode_slab_ctor(void *obj)\n{\n\tstruct ubifs_inode *ui = obj;\n\tinode_init_once(&ui->vfs_inode);\n}\n\nstatic int __init ubifs_init(void)\n{\n\tint err;\n\n\tBUILD_BUG_ON(sizeof(struct ubifs_ch) != 24);\n\n\t \n\tBUILD_BUG_ON(UBIFS_CH_SZ        & 7);\n\tBUILD_BUG_ON(UBIFS_INO_NODE_SZ  & 7);\n\tBUILD_BUG_ON(UBIFS_DENT_NODE_SZ & 7);\n\tBUILD_BUG_ON(UBIFS_XENT_NODE_SZ & 7);\n\tBUILD_BUG_ON(UBIFS_DATA_NODE_SZ & 7);\n\tBUILD_BUG_ON(UBIFS_TRUN_NODE_SZ & 7);\n\tBUILD_BUG_ON(UBIFS_SB_NODE_SZ   & 7);\n\tBUILD_BUG_ON(UBIFS_MST_NODE_SZ  & 7);\n\tBUILD_BUG_ON(UBIFS_REF_NODE_SZ  & 7);\n\tBUILD_BUG_ON(UBIFS_CS_NODE_SZ   & 7);\n\tBUILD_BUG_ON(UBIFS_ORPH_NODE_SZ & 7);\n\n\tBUILD_BUG_ON(UBIFS_MAX_DENT_NODE_SZ & 7);\n\tBUILD_BUG_ON(UBIFS_MAX_XENT_NODE_SZ & 7);\n\tBUILD_BUG_ON(UBIFS_MAX_DATA_NODE_SZ & 7);\n\tBUILD_BUG_ON(UBIFS_MAX_INO_NODE_SZ  & 7);\n\tBUILD_BUG_ON(UBIFS_MAX_NODE_SZ      & 7);\n\tBUILD_BUG_ON(MIN_WRITE_SZ           & 7);\n\n\t \n\tBUILD_BUG_ON(UBIFS_INO_NODE_SZ  < MIN_WRITE_SZ);\n\tBUILD_BUG_ON(UBIFS_DENT_NODE_SZ < MIN_WRITE_SZ);\n\tBUILD_BUG_ON(UBIFS_XENT_NODE_SZ < MIN_WRITE_SZ);\n\tBUILD_BUG_ON(UBIFS_TRUN_NODE_SZ < MIN_WRITE_SZ);\n\n\tBUILD_BUG_ON(UBIFS_MAX_DENT_NODE_SZ > UBIFS_MAX_NODE_SZ);\n\tBUILD_BUG_ON(UBIFS_MAX_XENT_NODE_SZ > UBIFS_MAX_NODE_SZ);\n\tBUILD_BUG_ON(UBIFS_MAX_DATA_NODE_SZ > UBIFS_MAX_NODE_SZ);\n\tBUILD_BUG_ON(UBIFS_MAX_INO_NODE_SZ  > UBIFS_MAX_NODE_SZ);\n\n\t \n\tBUILD_BUG_ON(UBIFS_SB_NODE_SZ  != 4096);\n\tBUILD_BUG_ON(UBIFS_MST_NODE_SZ != 512);\n\tBUILD_BUG_ON(UBIFS_INO_NODE_SZ != 160);\n\tBUILD_BUG_ON(UBIFS_REF_NODE_SZ != 64);\n\n\t \n\tBUILD_BUG_ON(UBIFS_COMPR_TYPES_CNT > 4);\n\n\t \n\tif (PAGE_SIZE < UBIFS_BLOCK_SIZE) {\n\t\tpr_err(\"UBIFS error (pid %d): VFS page cache size is %u bytes, but UBIFS requires at least 4096 bytes\",\n\t\t       current->pid, (unsigned int)PAGE_SIZE);\n\t\treturn -EINVAL;\n\t}\n\n\tubifs_inode_slab = kmem_cache_create(\"ubifs_inode_slab\",\n\t\t\t\tsizeof(struct ubifs_inode), 0,\n\t\t\t\tSLAB_MEM_SPREAD | SLAB_RECLAIM_ACCOUNT |\n\t\t\t\tSLAB_ACCOUNT, &inode_slab_ctor);\n\tif (!ubifs_inode_slab)\n\t\treturn -ENOMEM;\n\n\terr = register_shrinker(&ubifs_shrinker_info, \"ubifs-slab\");\n\tif (err)\n\t\tgoto out_slab;\n\n\terr = ubifs_compressors_init();\n\tif (err)\n\t\tgoto out_shrinker;\n\n\tdbg_debugfs_init();\n\n\terr = ubifs_sysfs_init();\n\tif (err)\n\t\tgoto out_dbg;\n\n\terr = register_filesystem(&ubifs_fs_type);\n\tif (err) {\n\t\tpr_err(\"UBIFS error (pid %d): cannot register file system, error %d\",\n\t\t       current->pid, err);\n\t\tgoto out_sysfs;\n\t}\n\treturn 0;\n\nout_sysfs:\n\tubifs_sysfs_exit();\nout_dbg:\n\tdbg_debugfs_exit();\n\tubifs_compressors_exit();\nout_shrinker:\n\tunregister_shrinker(&ubifs_shrinker_info);\nout_slab:\n\tkmem_cache_destroy(ubifs_inode_slab);\n\treturn err;\n}\n \nlate_initcall(ubifs_init);\n\nstatic void __exit ubifs_exit(void)\n{\n\tWARN_ON(!list_empty(&ubifs_infos));\n\tWARN_ON(atomic_long_read(&ubifs_clean_zn_cnt) != 0);\n\n\tdbg_debugfs_exit();\n\tubifs_sysfs_exit();\n\tubifs_compressors_exit();\n\tunregister_shrinker(&ubifs_shrinker_info);\n\n\t \n\trcu_barrier();\n\tkmem_cache_destroy(ubifs_inode_slab);\n\tunregister_filesystem(&ubifs_fs_type);\n}\nmodule_exit(ubifs_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(__stringify(UBIFS_VERSION));\nMODULE_AUTHOR(\"Artem Bityutskiy, Adrian Hunter\");\nMODULE_DESCRIPTION(\"UBIFS - UBI File System\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}