{
  "module_name": "replay.c",
  "hash_id": "c19f168e53c1186854a97c0ab7ae634dddb227a7073acd3b892e5117fd3b1355",
  "original_prompt": "Ingested from linux-6.6.14/fs/ubifs/replay.c",
  "human_readable_source": "\n \n\n \n\n#include \"ubifs.h\"\n#include <linux/list_sort.h>\n#include <crypto/hash.h>\n#include <crypto/algapi.h>\n\n \nstruct replay_entry {\n\tint lnum;\n\tint offs;\n\tint len;\n\tu8 hash[UBIFS_HASH_ARR_SZ];\n\tunsigned int deletion:1;\n\tunsigned long long sqnum;\n\tstruct list_head list;\n\tunion ubifs_key key;\n\tunion {\n\t\tstruct fscrypt_name nm;\n\t\tstruct {\n\t\t\tloff_t old_size;\n\t\t\tloff_t new_size;\n\t\t};\n\t};\n};\n\n \nstruct bud_entry {\n\tstruct list_head list;\n\tstruct ubifs_bud *bud;\n\tunsigned long long sqnum;\n\tint free;\n\tint dirty;\n};\n\n \nstatic int set_bud_lprops(struct ubifs_info *c, struct bud_entry *b)\n{\n\tconst struct ubifs_lprops *lp;\n\tint err = 0, dirty;\n\n\tubifs_get_lprops(c);\n\n\tlp = ubifs_lpt_lookup_dirty(c, b->bud->lnum);\n\tif (IS_ERR(lp)) {\n\t\terr = PTR_ERR(lp);\n\t\tgoto out;\n\t}\n\n\tdirty = lp->dirty;\n\tif (b->bud->start == 0 && (lp->free != c->leb_size || lp->dirty != 0)) {\n\t\t \n\t\tdbg_mnt(\"bud LEB %d was GC'd (%d free, %d dirty)\", b->bud->lnum,\n\t\t\tlp->free, lp->dirty);\n\t\tdbg_gc(\"bud LEB %d was GC'd (%d free, %d dirty)\", b->bud->lnum,\n\t\t\tlp->free, lp->dirty);\n\t\tdirty -= c->leb_size - lp->free;\n\t\t \n\t\tif (dirty != 0)\n\t\t\tdbg_mnt(\"LEB %d lp: %d free %d dirty replay: %d free %d dirty\",\n\t\t\t\tb->bud->lnum, lp->free, lp->dirty, b->free,\n\t\t\t\tb->dirty);\n\t}\n\tlp = ubifs_change_lp(c, lp, b->free, dirty + b->dirty,\n\t\t\t     lp->flags | LPROPS_TAKEN, 0);\n\tif (IS_ERR(lp)) {\n\t\terr = PTR_ERR(lp);\n\t\tgoto out;\n\t}\n\n\t \n\terr = ubifs_wbuf_seek_nolock(&c->jheads[b->bud->jhead].wbuf,\n\t\t\t\t     b->bud->lnum, c->leb_size - b->free);\n\nout:\n\tubifs_release_lprops(c);\n\treturn err;\n}\n\n \nstatic int set_buds_lprops(struct ubifs_info *c)\n{\n\tstruct bud_entry *b;\n\tint err;\n\n\tlist_for_each_entry(b, &c->replay_buds, list) {\n\t\terr = set_bud_lprops(c, b);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int trun_remove_range(struct ubifs_info *c, struct replay_entry *r)\n{\n\tunsigned min_blk, max_blk;\n\tunion ubifs_key min_key, max_key;\n\tino_t ino;\n\n\tmin_blk = r->new_size / UBIFS_BLOCK_SIZE;\n\tif (r->new_size & (UBIFS_BLOCK_SIZE - 1))\n\t\tmin_blk += 1;\n\n\tmax_blk = r->old_size / UBIFS_BLOCK_SIZE;\n\tif ((r->old_size & (UBIFS_BLOCK_SIZE - 1)) == 0)\n\t\tmax_blk -= 1;\n\n\tino = key_inum(c, &r->key);\n\n\tdata_key_init(c, &min_key, ino, min_blk);\n\tdata_key_init(c, &max_key, ino, max_blk);\n\n\treturn ubifs_tnc_remove_range(c, &min_key, &max_key);\n}\n\n \nstatic bool inode_still_linked(struct ubifs_info *c, struct replay_entry *rino)\n{\n\tstruct replay_entry *r;\n\n\tubifs_assert(c, rino->deletion);\n\tubifs_assert(c, key_type(c, &rino->key) == UBIFS_INO_KEY);\n\n\t \n\tlist_for_each_entry_reverse(r, &c->replay_list, list) {\n\t\tubifs_assert(c, r->sqnum >= rino->sqnum);\n\t\tif (key_inum(c, &r->key) == key_inum(c, &rino->key) &&\n\t\t    key_type(c, &r->key) == UBIFS_INO_KEY)\n\t\t\treturn r->deletion == 0;\n\n\t}\n\n\tubifs_assert(c, 0);\n\treturn false;\n}\n\n \nstatic int apply_replay_entry(struct ubifs_info *c, struct replay_entry *r)\n{\n\tint err;\n\n\tdbg_mntk(&r->key, \"LEB %d:%d len %d deletion %d sqnum %llu key \",\n\t\t r->lnum, r->offs, r->len, r->deletion, r->sqnum);\n\n\tif (is_hash_key(c, &r->key)) {\n\t\tif (r->deletion)\n\t\t\terr = ubifs_tnc_remove_nm(c, &r->key, &r->nm);\n\t\telse\n\t\t\terr = ubifs_tnc_add_nm(c, &r->key, r->lnum, r->offs,\n\t\t\t\t\t       r->len, r->hash, &r->nm);\n\t} else {\n\t\tif (r->deletion)\n\t\t\tswitch (key_type(c, &r->key)) {\n\t\t\tcase UBIFS_INO_KEY:\n\t\t\t{\n\t\t\t\tino_t inum = key_inum(c, &r->key);\n\n\t\t\t\tif (inode_still_linked(c, r)) {\n\t\t\t\t\terr = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\terr = ubifs_tnc_remove_ino(c, inum);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase UBIFS_TRUN_KEY:\n\t\t\t\terr = trun_remove_range(c, r);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terr = ubifs_tnc_remove(c, &r->key);\n\t\t\t\tbreak;\n\t\t\t}\n\t\telse\n\t\t\terr = ubifs_tnc_add(c, &r->key, r->lnum, r->offs,\n\t\t\t\t\t    r->len, r->hash);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (c->need_recovery)\n\t\t\terr = ubifs_recover_size_accum(c, &r->key, r->deletion,\n\t\t\t\t\t\t       r->new_size);\n\t}\n\n\treturn err;\n}\n\n \nstatic int replay_entries_cmp(void *priv, const struct list_head *a,\n\t\t\t      const struct list_head *b)\n{\n\tstruct ubifs_info *c = priv;\n\tstruct replay_entry *ra, *rb;\n\n\tcond_resched();\n\tif (a == b)\n\t\treturn 0;\n\n\tra = list_entry(a, struct replay_entry, list);\n\trb = list_entry(b, struct replay_entry, list);\n\tubifs_assert(c, ra->sqnum != rb->sqnum);\n\tif (ra->sqnum > rb->sqnum)\n\t\treturn 1;\n\treturn -1;\n}\n\n \nstatic int apply_replay_list(struct ubifs_info *c)\n{\n\tstruct replay_entry *r;\n\tint err;\n\n\tlist_sort(c, &c->replay_list, &replay_entries_cmp);\n\n\tlist_for_each_entry(r, &c->replay_list, list) {\n\t\tcond_resched();\n\n\t\terr = apply_replay_entry(c, r);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void destroy_replay_list(struct ubifs_info *c)\n{\n\tstruct replay_entry *r, *tmp;\n\n\tlist_for_each_entry_safe(r, tmp, &c->replay_list, list) {\n\t\tif (is_hash_key(c, &r->key))\n\t\t\tkfree(fname_name(&r->nm));\n\t\tlist_del(&r->list);\n\t\tkfree(r);\n\t}\n}\n\n \nstatic int insert_node(struct ubifs_info *c, int lnum, int offs, int len,\n\t\t       const u8 *hash, union ubifs_key *key,\n\t\t       unsigned long long sqnum, int deletion, int *used,\n\t\t       loff_t old_size, loff_t new_size)\n{\n\tstruct replay_entry *r;\n\n\tdbg_mntk(key, \"add LEB %d:%d, key \", lnum, offs);\n\n\tif (key_inum(c, key) >= c->highest_inum)\n\t\tc->highest_inum = key_inum(c, key);\n\n\tr = kzalloc(sizeof(struct replay_entry), GFP_KERNEL);\n\tif (!r)\n\t\treturn -ENOMEM;\n\n\tif (!deletion)\n\t\t*used += ALIGN(len, 8);\n\tr->lnum = lnum;\n\tr->offs = offs;\n\tr->len = len;\n\tubifs_copy_hash(c, hash, r->hash);\n\tr->deletion = !!deletion;\n\tr->sqnum = sqnum;\n\tkey_copy(c, key, &r->key);\n\tr->old_size = old_size;\n\tr->new_size = new_size;\n\n\tlist_add_tail(&r->list, &c->replay_list);\n\treturn 0;\n}\n\n \nstatic int insert_dent(struct ubifs_info *c, int lnum, int offs, int len,\n\t\t       const u8 *hash, union ubifs_key *key,\n\t\t       const char *name, int nlen, unsigned long long sqnum,\n\t\t       int deletion, int *used)\n{\n\tstruct replay_entry *r;\n\tchar *nbuf;\n\n\tdbg_mntk(key, \"add LEB %d:%d, key \", lnum, offs);\n\tif (key_inum(c, key) >= c->highest_inum)\n\t\tc->highest_inum = key_inum(c, key);\n\n\tr = kzalloc(sizeof(struct replay_entry), GFP_KERNEL);\n\tif (!r)\n\t\treturn -ENOMEM;\n\n\tnbuf = kmalloc(nlen + 1, GFP_KERNEL);\n\tif (!nbuf) {\n\t\tkfree(r);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (!deletion)\n\t\t*used += ALIGN(len, 8);\n\tr->lnum = lnum;\n\tr->offs = offs;\n\tr->len = len;\n\tubifs_copy_hash(c, hash, r->hash);\n\tr->deletion = !!deletion;\n\tr->sqnum = sqnum;\n\tkey_copy(c, key, &r->key);\n\tfname_len(&r->nm) = nlen;\n\tmemcpy(nbuf, name, nlen);\n\tnbuf[nlen] = '\\0';\n\tfname_name(&r->nm) = nbuf;\n\n\tlist_add_tail(&r->list, &c->replay_list);\n\treturn 0;\n}\n\n \nint ubifs_validate_entry(struct ubifs_info *c,\n\t\t\t const struct ubifs_dent_node *dent)\n{\n\tint key_type = key_type_flash(c, dent->key);\n\tint nlen = le16_to_cpu(dent->nlen);\n\n\tif (le32_to_cpu(dent->ch.len) != nlen + UBIFS_DENT_NODE_SZ + 1 ||\n\t    dent->type >= UBIFS_ITYPES_CNT ||\n\t    nlen > UBIFS_MAX_NLEN || dent->name[nlen] != 0 ||\n\t    (key_type == UBIFS_XENT_KEY && strnlen(dent->name, nlen) != nlen) ||\n\t    le64_to_cpu(dent->inum) > MAX_INUM) {\n\t\tubifs_err(c, \"bad %s node\", key_type == UBIFS_DENT_KEY ?\n\t\t\t  \"directory entry\" : \"extended attribute entry\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (key_type != UBIFS_DENT_KEY && key_type != UBIFS_XENT_KEY) {\n\t\tubifs_err(c, \"bad key type %d\", key_type);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int is_last_bud(struct ubifs_info *c, struct ubifs_bud *bud)\n{\n\tstruct ubifs_jhead *jh = &c->jheads[bud->jhead];\n\tstruct ubifs_bud *next;\n\tuint32_t data;\n\tint err;\n\n\tif (list_is_last(&bud->list, &jh->buds_list))\n\t\treturn 1;\n\n\t \n\tnext = list_entry(bud->list.next, struct ubifs_bud, list);\n\tif (!list_is_last(&next->list, &jh->buds_list))\n\t\treturn 0;\n\n\terr = ubifs_leb_read(c, next->lnum, (char *)&data, next->start, 4, 1);\n\tif (err)\n\t\treturn 0;\n\n\treturn data == 0xFFFFFFFF;\n}\n\n \nstatic int noinline_for_stack\nauthenticate_sleb_hash(struct ubifs_info *c,\n\t\t       struct shash_desc *log_hash, u8 *hash)\n{\n\tSHASH_DESC_ON_STACK(hash_desc, c->hash_tfm);\n\n\thash_desc->tfm = c->hash_tfm;\n\n\tubifs_shash_copy_state(c, log_hash, hash_desc);\n\treturn crypto_shash_final(hash_desc, hash);\n}\n\n \nstatic int authenticate_sleb(struct ubifs_info *c, struct ubifs_scan_leb *sleb,\n\t\t\t     struct shash_desc *log_hash, int is_last)\n{\n\tint n_not_auth = 0;\n\tstruct ubifs_scan_node *snod;\n\tint n_nodes = 0;\n\tint err;\n\tu8 hash[UBIFS_HASH_ARR_SZ];\n\tu8 hmac[UBIFS_HMAC_ARR_SZ];\n\n\tif (!ubifs_authenticated(c))\n\t\treturn sleb->nodes_cnt;\n\n\tlist_for_each_entry(snod, &sleb->nodes, list) {\n\n\t\tn_nodes++;\n\n\t\tif (snod->type == UBIFS_AUTH_NODE) {\n\t\t\tstruct ubifs_auth_node *auth = snod->node;\n\n\t\t\terr = authenticate_sleb_hash(c, log_hash, hash);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\terr = crypto_shash_tfm_digest(c->hmac_tfm, hash,\n\t\t\t\t\t\t      c->hash_len, hmac);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\terr = ubifs_check_hmac(c, auth->hmac, hmac);\n\t\t\tif (err) {\n\t\t\t\terr = -EPERM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tn_not_auth = 0;\n\t\t} else {\n\t\t\terr = crypto_shash_update(log_hash, snod->node,\n\t\t\t\t\t\t  snod->len);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tn_not_auth++;\n\t\t}\n\t}\n\n\t \n\tif (n_not_auth) {\n\t\tif (is_last) {\n\t\t\tdbg_mnt(\"%d unauthenticated nodes found on LEB %d, Ignoring them\",\n\t\t\t\tn_not_auth, sleb->lnum);\n\t\t\terr = 0;\n\t\t} else {\n\t\t\tdbg_mnt(\"%d unauthenticated nodes found on non-last LEB %d\",\n\t\t\t\tn_not_auth, sleb->lnum);\n\t\t\terr = -EPERM;\n\t\t}\n\t} else {\n\t\terr = 0;\n\t}\nout:\n\treturn err ? err : n_nodes - n_not_auth;\n}\n\n \nstatic int replay_bud(struct ubifs_info *c, struct bud_entry *b)\n{\n\tint is_last = is_last_bud(c, b->bud);\n\tint err = 0, used = 0, lnum = b->bud->lnum, offs = b->bud->start;\n\tint n_nodes, n = 0;\n\tstruct ubifs_scan_leb *sleb;\n\tstruct ubifs_scan_node *snod;\n\n\tdbg_mnt(\"replay bud LEB %d, head %d, offs %d, is_last %d\",\n\t\tlnum, b->bud->jhead, offs, is_last);\n\n\tif (c->need_recovery && is_last)\n\t\t \n\t\tsleb = ubifs_recover_leb(c, lnum, offs, c->sbuf, b->bud->jhead);\n\telse\n\t\tsleb = ubifs_scan(c, lnum, offs, c->sbuf, 0);\n\tif (IS_ERR(sleb))\n\t\treturn PTR_ERR(sleb);\n\n\tn_nodes = authenticate_sleb(c, sleb, b->bud->log_hash, is_last);\n\tif (n_nodes < 0) {\n\t\terr = n_nodes;\n\t\tgoto out;\n\t}\n\n\tubifs_shash_copy_state(c, b->bud->log_hash,\n\t\t\t       c->jheads[b->bud->jhead].log_hash);\n\n\t \n\n\tlist_for_each_entry(snod, &sleb->nodes, list) {\n\t\tu8 hash[UBIFS_HASH_ARR_SZ];\n\t\tint deletion = 0;\n\n\t\tcond_resched();\n\n\t\tif (snod->sqnum >= SQNUM_WATERMARK) {\n\t\t\tubifs_err(c, \"file system's life ended\");\n\t\t\tgoto out_dump;\n\t\t}\n\n\t\tubifs_node_calc_hash(c, snod->node, hash);\n\n\t\tif (snod->sqnum > c->max_sqnum)\n\t\t\tc->max_sqnum = snod->sqnum;\n\n\t\tswitch (snod->type) {\n\t\tcase UBIFS_INO_NODE:\n\t\t{\n\t\t\tstruct ubifs_ino_node *ino = snod->node;\n\t\t\tloff_t new_size = le64_to_cpu(ino->size);\n\n\t\t\tif (le32_to_cpu(ino->nlink) == 0)\n\t\t\t\tdeletion = 1;\n\t\t\terr = insert_node(c, lnum, snod->offs, snod->len, hash,\n\t\t\t\t\t  &snod->key, snod->sqnum, deletion,\n\t\t\t\t\t  &used, 0, new_size);\n\t\t\tbreak;\n\t\t}\n\t\tcase UBIFS_DATA_NODE:\n\t\t{\n\t\t\tstruct ubifs_data_node *dn = snod->node;\n\t\t\tloff_t new_size = le32_to_cpu(dn->size) +\n\t\t\t\t\t  key_block(c, &snod->key) *\n\t\t\t\t\t  UBIFS_BLOCK_SIZE;\n\n\t\t\terr = insert_node(c, lnum, snod->offs, snod->len, hash,\n\t\t\t\t\t  &snod->key, snod->sqnum, deletion,\n\t\t\t\t\t  &used, 0, new_size);\n\t\t\tbreak;\n\t\t}\n\t\tcase UBIFS_DENT_NODE:\n\t\tcase UBIFS_XENT_NODE:\n\t\t{\n\t\t\tstruct ubifs_dent_node *dent = snod->node;\n\n\t\t\terr = ubifs_validate_entry(c, dent);\n\t\t\tif (err)\n\t\t\t\tgoto out_dump;\n\n\t\t\terr = insert_dent(c, lnum, snod->offs, snod->len, hash,\n\t\t\t\t\t  &snod->key, dent->name,\n\t\t\t\t\t  le16_to_cpu(dent->nlen), snod->sqnum,\n\t\t\t\t\t  !le64_to_cpu(dent->inum), &used);\n\t\t\tbreak;\n\t\t}\n\t\tcase UBIFS_TRUN_NODE:\n\t\t{\n\t\t\tstruct ubifs_trun_node *trun = snod->node;\n\t\t\tloff_t old_size = le64_to_cpu(trun->old_size);\n\t\t\tloff_t new_size = le64_to_cpu(trun->new_size);\n\t\t\tunion ubifs_key key;\n\n\t\t\t \n\t\t\tif (old_size < 0 || old_size > c->max_inode_sz ||\n\t\t\t    new_size < 0 || new_size > c->max_inode_sz ||\n\t\t\t    old_size <= new_size) {\n\t\t\t\tubifs_err(c, \"bad truncation node\");\n\t\t\t\tgoto out_dump;\n\t\t\t}\n\n\t\t\t \n\t\t\ttrun_key_init(c, &key, le32_to_cpu(trun->inum));\n\t\t\terr = insert_node(c, lnum, snod->offs, snod->len, hash,\n\t\t\t\t\t  &key, snod->sqnum, 1, &used,\n\t\t\t\t\t  old_size, new_size);\n\t\t\tbreak;\n\t\t}\n\t\tcase UBIFS_AUTH_NODE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tubifs_err(c, \"unexpected node type %d in bud LEB %d:%d\",\n\t\t\t\t  snod->type, lnum, snod->offs);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_dump;\n\t\t}\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tn++;\n\t\tif (n == n_nodes)\n\t\t\tbreak;\n\t}\n\n\tubifs_assert(c, ubifs_search_bud(c, lnum));\n\tubifs_assert(c, sleb->endpt - offs >= used);\n\tubifs_assert(c, sleb->endpt % c->min_io_size == 0);\n\n\tb->dirty = sleb->endpt - offs - used;\n\tb->free = c->leb_size - sleb->endpt;\n\tdbg_mnt(\"bud LEB %d replied: dirty %d, free %d\",\n\t\tlnum, b->dirty, b->free);\n\nout:\n\tubifs_scan_destroy(sleb);\n\treturn err;\n\nout_dump:\n\tubifs_err(c, \"bad node is at LEB %d:%d\", lnum, snod->offs);\n\tubifs_dump_node(c, snod->node, c->leb_size - snod->offs);\n\tubifs_scan_destroy(sleb);\n\treturn -EINVAL;\n}\n\n \nstatic int replay_buds(struct ubifs_info *c)\n{\n\tstruct bud_entry *b;\n\tint err;\n\tunsigned long long prev_sqnum = 0;\n\n\tlist_for_each_entry(b, &c->replay_buds, list) {\n\t\terr = replay_bud(c, b);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tubifs_assert(c, b->sqnum > prev_sqnum);\n\t\tprev_sqnum = b->sqnum;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void destroy_bud_list(struct ubifs_info *c)\n{\n\tstruct bud_entry *b;\n\n\twhile (!list_empty(&c->replay_buds)) {\n\t\tb = list_entry(c->replay_buds.next, struct bud_entry, list);\n\t\tlist_del(&b->list);\n\t\tkfree(b);\n\t}\n}\n\n \nstatic int add_replay_bud(struct ubifs_info *c, int lnum, int offs, int jhead,\n\t\t\t  unsigned long long sqnum)\n{\n\tstruct ubifs_bud *bud;\n\tstruct bud_entry *b;\n\tint err;\n\n\tdbg_mnt(\"add replay bud LEB %d:%d, head %d\", lnum, offs, jhead);\n\n\tbud = kmalloc(sizeof(struct ubifs_bud), GFP_KERNEL);\n\tif (!bud)\n\t\treturn -ENOMEM;\n\n\tb = kmalloc(sizeof(struct bud_entry), GFP_KERNEL);\n\tif (!b) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tbud->lnum = lnum;\n\tbud->start = offs;\n\tbud->jhead = jhead;\n\tbud->log_hash = ubifs_hash_get_desc(c);\n\tif (IS_ERR(bud->log_hash)) {\n\t\terr = PTR_ERR(bud->log_hash);\n\t\tgoto out;\n\t}\n\n\tubifs_shash_copy_state(c, c->log_hash, bud->log_hash);\n\n\tubifs_add_bud(c, bud);\n\n\tb->bud = bud;\n\tb->sqnum = sqnum;\n\tlist_add_tail(&b->list, &c->replay_buds);\n\n\treturn 0;\nout:\n\tkfree(bud);\n\tkfree(b);\n\n\treturn err;\n}\n\n \nstatic int validate_ref(struct ubifs_info *c, const struct ubifs_ref_node *ref)\n{\n\tstruct ubifs_bud *bud;\n\tint lnum = le32_to_cpu(ref->lnum);\n\tunsigned int offs = le32_to_cpu(ref->offs);\n\tunsigned int jhead = le32_to_cpu(ref->jhead);\n\n\t \n\tif (jhead >= c->jhead_cnt || lnum >= c->leb_cnt ||\n\t    lnum < c->main_first || offs > c->leb_size ||\n\t    offs & (c->min_io_size - 1))\n\t\treturn -EINVAL;\n\n\t \n\tbud = ubifs_search_bud(c, lnum);\n\tif (bud) {\n\t\tif (bud->jhead == jhead && bud->start <= offs)\n\t\t\treturn 1;\n\t\tubifs_err(c, \"bud at LEB %d:%d was already referred\", lnum, offs);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int replay_log_leb(struct ubifs_info *c, int lnum, int offs, void *sbuf)\n{\n\tint err;\n\tstruct ubifs_scan_leb *sleb;\n\tstruct ubifs_scan_node *snod;\n\tconst struct ubifs_cs_node *node;\n\n\tdbg_mnt(\"replay log LEB %d:%d\", lnum, offs);\n\tsleb = ubifs_scan(c, lnum, offs, sbuf, c->need_recovery);\n\tif (IS_ERR(sleb)) {\n\t\tif (PTR_ERR(sleb) != -EUCLEAN || !c->need_recovery)\n\t\t\treturn PTR_ERR(sleb);\n\t\t \n\t\tsleb = ubifs_recover_log_leb(c, lnum, offs, sbuf);\n\t\tif (IS_ERR(sleb))\n\t\t\treturn PTR_ERR(sleb);\n\t}\n\n\tif (sleb->nodes_cnt == 0) {\n\t\terr = 1;\n\t\tgoto out;\n\t}\n\n\tnode = sleb->buf;\n\tsnod = list_entry(sleb->nodes.next, struct ubifs_scan_node, list);\n\tif (c->cs_sqnum == 0) {\n\t\t \n\t\tif (snod->type != UBIFS_CS_NODE) {\n\t\t\tubifs_err(c, \"first log node at LEB %d:%d is not CS node\",\n\t\t\t\t  lnum, offs);\n\t\t\tgoto out_dump;\n\t\t}\n\t\tif (le64_to_cpu(node->cmt_no) != c->cmt_no) {\n\t\t\tubifs_err(c, \"first CS node at LEB %d:%d has wrong commit number %llu expected %llu\",\n\t\t\t\t  lnum, offs,\n\t\t\t\t  (unsigned long long)le64_to_cpu(node->cmt_no),\n\t\t\t\t  c->cmt_no);\n\t\t\tgoto out_dump;\n\t\t}\n\n\t\tc->cs_sqnum = le64_to_cpu(node->ch.sqnum);\n\t\tdbg_mnt(\"commit start sqnum %llu\", c->cs_sqnum);\n\n\t\terr = ubifs_shash_init(c, c->log_hash);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = ubifs_shash_update(c, c->log_hash, node, UBIFS_CS_NODE_SZ);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\n\tif (snod->sqnum < c->cs_sqnum) {\n\t\t \n\t\terr = 1;\n\t\tgoto out;\n\t}\n\n\t \n\tif (snod->offs != 0) {\n\t\tubifs_err(c, \"first node is not at zero offset\");\n\t\tgoto out_dump;\n\t}\n\n\tlist_for_each_entry(snod, &sleb->nodes, list) {\n\t\tcond_resched();\n\n\t\tif (snod->sqnum >= SQNUM_WATERMARK) {\n\t\t\tubifs_err(c, \"file system's life ended\");\n\t\t\tgoto out_dump;\n\t\t}\n\n\t\tif (snod->sqnum < c->cs_sqnum) {\n\t\t\tubifs_err(c, \"bad sqnum %llu, commit sqnum %llu\",\n\t\t\t\t  snod->sqnum, c->cs_sqnum);\n\t\t\tgoto out_dump;\n\t\t}\n\n\t\tif (snod->sqnum > c->max_sqnum)\n\t\t\tc->max_sqnum = snod->sqnum;\n\n\t\tswitch (snod->type) {\n\t\tcase UBIFS_REF_NODE: {\n\t\t\tconst struct ubifs_ref_node *ref = snod->node;\n\n\t\t\terr = validate_ref(c, ref);\n\t\t\tif (err == 1)\n\t\t\t\tbreak;  \n\t\t\tif (err)\n\t\t\t\tgoto out_dump;\n\n\t\t\terr = ubifs_shash_update(c, c->log_hash, ref,\n\t\t\t\t\t\t UBIFS_REF_NODE_SZ);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\terr = add_replay_bud(c, le32_to_cpu(ref->lnum),\n\t\t\t\t\t     le32_to_cpu(ref->offs),\n\t\t\t\t\t     le32_to_cpu(ref->jhead),\n\t\t\t\t\t     snod->sqnum);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\tbreak;\n\t\t}\n\t\tcase UBIFS_CS_NODE:\n\t\t\t \n\t\t\tif (snod->offs != 0) {\n\t\t\t\tubifs_err(c, \"unexpected node in log\");\n\t\t\t\tgoto out_dump;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tubifs_err(c, \"unexpected node in log\");\n\t\t\tgoto out_dump;\n\t\t}\n\t}\n\n\tif (sleb->endpt || c->lhead_offs >= c->leb_size) {\n\t\tc->lhead_lnum = lnum;\n\t\tc->lhead_offs = sleb->endpt;\n\t}\n\n\terr = !sleb->endpt;\nout:\n\tubifs_scan_destroy(sleb);\n\treturn err;\n\nout_dump:\n\tubifs_err(c, \"log error detected while replaying the log at LEB %d:%d\",\n\t\t  lnum, offs + snod->offs);\n\tubifs_dump_node(c, snod->node, c->leb_size - snod->offs);\n\tubifs_scan_destroy(sleb);\n\treturn -EINVAL;\n}\n\n \nstatic int take_ihead(struct ubifs_info *c)\n{\n\tconst struct ubifs_lprops *lp;\n\tint err, free;\n\n\tubifs_get_lprops(c);\n\n\tlp = ubifs_lpt_lookup_dirty(c, c->ihead_lnum);\n\tif (IS_ERR(lp)) {\n\t\terr = PTR_ERR(lp);\n\t\tgoto out;\n\t}\n\n\tfree = lp->free;\n\n\tlp = ubifs_change_lp(c, lp, LPROPS_NC, LPROPS_NC,\n\t\t\t     lp->flags | LPROPS_TAKEN, 0);\n\tif (IS_ERR(lp)) {\n\t\terr = PTR_ERR(lp);\n\t\tgoto out;\n\t}\n\n\terr = free;\nout:\n\tubifs_release_lprops(c);\n\treturn err;\n}\n\n \nint ubifs_replay_journal(struct ubifs_info *c)\n{\n\tint err, lnum, free;\n\n\tBUILD_BUG_ON(UBIFS_TRUN_KEY > 5);\n\n\t \n\tfree = take_ihead(c);\n\tif (free < 0)\n\t\treturn free;  \n\n\tif (c->ihead_offs != c->leb_size - free) {\n\t\tubifs_err(c, \"bad index head LEB %d:%d\", c->ihead_lnum,\n\t\t\t  c->ihead_offs);\n\t\treturn -EINVAL;\n\t}\n\n\tdbg_mnt(\"start replaying the journal\");\n\tc->replaying = 1;\n\tlnum = c->ltail_lnum = c->lhead_lnum;\n\n\tdo {\n\t\terr = replay_log_leb(c, lnum, 0, c->sbuf);\n\t\tif (err == 1) {\n\t\t\tif (lnum != c->lhead_lnum)\n\t\t\t\t \n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tubifs_err(c, \"no UBIFS nodes found at the log head LEB %d:%d, possibly corrupted\",\n\t\t\t\t  lnum, 0);\n\t\t\terr = -EINVAL;\n\t\t}\n\t\tif (err)\n\t\t\tgoto out;\n\t\tlnum = ubifs_next_log_lnum(c, lnum);\n\t} while (lnum != c->ltail_lnum);\n\n\terr = replay_buds(c);\n\tif (err)\n\t\tgoto out;\n\n\terr = apply_replay_list(c);\n\tif (err)\n\t\tgoto out;\n\n\terr = set_buds_lprops(c);\n\tif (err)\n\t\tgoto out;\n\n\t \n\tc->bi.uncommitted_idx = atomic_long_read(&c->dirty_zn_cnt);\n\tc->bi.uncommitted_idx *= c->max_idx_node_sz;\n\n\tubifs_assert(c, c->bud_bytes <= c->max_bud_bytes || c->need_recovery);\n\tdbg_mnt(\"finished, log head LEB %d:%d, max_sqnum %llu, highest_inum %lu\",\n\t\tc->lhead_lnum, c->lhead_offs, c->max_sqnum,\n\t\t(unsigned long)c->highest_inum);\nout:\n\tdestroy_replay_list(c);\n\tdestroy_bud_list(c);\n\tc->replaying = 0;\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}