{
  "module_name": "tnc_misc.c",
  "hash_id": "e44286789ee22041bdc01fae771a9aaa19d4091400bc79bb2d8d8a4ecf76ea16",
  "original_prompt": "Ingested from linux-6.6.14/fs/ubifs/tnc_misc.c",
  "human_readable_source": "\n \n\n \n\n#include \"ubifs.h\"\n\n \nstruct ubifs_znode *ubifs_tnc_levelorder_next(const struct ubifs_info *c,\n\t\t\t\t\t      struct ubifs_znode *zr,\n\t\t\t\t\t      struct ubifs_znode *znode)\n{\n\tint level, iip, level_search = 0;\n\tstruct ubifs_znode *zn;\n\n\tubifs_assert(c, zr);\n\n\tif (unlikely(!znode))\n\t\treturn zr;\n\n\tif (unlikely(znode == zr)) {\n\t\tif (znode->level == 0)\n\t\t\treturn NULL;\n\t\treturn ubifs_tnc_find_child(zr, 0);\n\t}\n\n\tlevel = znode->level;\n\n\tiip = znode->iip;\n\twhile (1) {\n\t\tubifs_assert(c, znode->level <= zr->level);\n\n\t\t \n\t\twhile (znode->parent != zr && iip >= znode->parent->child_cnt) {\n\t\t\tznode = znode->parent;\n\t\t\tiip = znode->iip;\n\t\t}\n\n\t\tif (unlikely(znode->parent == zr &&\n\t\t\t     iip >= znode->parent->child_cnt)) {\n\t\t\t \n\t\t\tlevel -= 1;\n\t\t\tif (level_search || level < 0)\n\t\t\t\t \n\t\t\t\treturn NULL;\n\n\t\t\tlevel_search = 1;\n\t\t\tiip = -1;\n\t\t\tznode = ubifs_tnc_find_child(zr, 0);\n\t\t\tubifs_assert(c, znode);\n\t\t}\n\n\t\t \n\t\tzn = ubifs_tnc_find_child(znode->parent, iip + 1);\n\t\tif (!zn) {\n\t\t\t \n\t\t\tiip = znode->parent->child_cnt;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\twhile (zn->level != level) {\n\t\t\tznode = zn;\n\t\t\tzn = ubifs_tnc_find_child(zn, 0);\n\t\t\tif (!zn) {\n\t\t\t\t \n\t\t\t\tiip = znode->iip;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (zn) {\n\t\t\tubifs_assert(c, zn->level >= 0);\n\t\t\treturn zn;\n\t\t}\n\t}\n}\n\n \nint ubifs_search_zbranch(const struct ubifs_info *c,\n\t\t\t const struct ubifs_znode *znode,\n\t\t\t const union ubifs_key *key, int *n)\n{\n\tint beg = 0, end = znode->child_cnt, mid;\n\tint cmp;\n\tconst struct ubifs_zbranch *zbr = &znode->zbranch[0];\n\n\tubifs_assert(c, end > beg);\n\n\twhile (end > beg) {\n\t\tmid = (beg + end) >> 1;\n\t\tcmp = keys_cmp(c, key, &zbr[mid].key);\n\t\tif (cmp > 0)\n\t\t\tbeg = mid + 1;\n\t\telse if (cmp < 0)\n\t\t\tend = mid;\n\t\telse {\n\t\t\t*n = mid;\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t*n = end - 1;\n\n\t \n\tubifs_assert(c, *n >= -1 && *n < znode->child_cnt);\n\tif (*n == -1)\n\t\tubifs_assert(c, keys_cmp(c, key, &zbr[0].key) < 0);\n\telse\n\t\tubifs_assert(c, keys_cmp(c, key, &zbr[*n].key) > 0);\n\tif (*n + 1 < znode->child_cnt)\n\t\tubifs_assert(c, keys_cmp(c, key, &zbr[*n + 1].key) < 0);\n\n\treturn 0;\n}\n\n \nstruct ubifs_znode *ubifs_tnc_postorder_first(struct ubifs_znode *znode)\n{\n\tif (unlikely(!znode))\n\t\treturn NULL;\n\n\twhile (znode->level > 0) {\n\t\tstruct ubifs_znode *child;\n\n\t\tchild = ubifs_tnc_find_child(znode, 0);\n\t\tif (!child)\n\t\t\treturn znode;\n\t\tznode = child;\n\t}\n\n\treturn znode;\n}\n\n \nstruct ubifs_znode *ubifs_tnc_postorder_next(const struct ubifs_info *c,\n\t\t\t\t\t     struct ubifs_znode *znode)\n{\n\tstruct ubifs_znode *zn;\n\n\tubifs_assert(c, znode);\n\tif (unlikely(!znode->parent))\n\t\treturn NULL;\n\n\t \n\tzn = ubifs_tnc_find_child(znode->parent, znode->iip + 1);\n\tif (!zn)\n\t\t \n\t\treturn znode->parent;\n\n\t \n\treturn ubifs_tnc_postorder_first(zn);\n}\n\n \nlong ubifs_destroy_tnc_subtree(const struct ubifs_info *c,\n\t\t\t       struct ubifs_znode *znode)\n{\n\tstruct ubifs_znode *zn = ubifs_tnc_postorder_first(znode);\n\tlong clean_freed = 0;\n\tint n;\n\n\tubifs_assert(c, zn);\n\twhile (1) {\n\t\tfor (n = 0; n < zn->child_cnt; n++) {\n\t\t\tif (!zn->zbranch[n].znode)\n\t\t\t\tcontinue;\n\n\t\t\tif (zn->level > 0 &&\n\t\t\t    !ubifs_zn_dirty(zn->zbranch[n].znode))\n\t\t\t\tclean_freed += 1;\n\n\t\t\tcond_resched();\n\t\t\tkfree(zn->zbranch[n].znode);\n\t\t}\n\n\t\tif (zn == znode) {\n\t\t\tif (!ubifs_zn_dirty(zn))\n\t\t\t\tclean_freed += 1;\n\t\t\tkfree(zn);\n\t\t\treturn clean_freed;\n\t\t}\n\n\t\tzn = ubifs_tnc_postorder_next(c, zn);\n\t}\n}\n\n \nstatic int read_znode(struct ubifs_info *c, struct ubifs_zbranch *zzbr,\n\t\t      struct ubifs_znode *znode)\n{\n\tint lnum = zzbr->lnum;\n\tint offs = zzbr->offs;\n\tint len = zzbr->len;\n\tint i, err, type, cmp;\n\tstruct ubifs_idx_node *idx;\n\n\tidx = kmalloc(c->max_idx_node_sz, GFP_NOFS);\n\tif (!idx)\n\t\treturn -ENOMEM;\n\n\terr = ubifs_read_node(c, idx, UBIFS_IDX_NODE, len, lnum, offs);\n\tif (err < 0) {\n\t\tkfree(idx);\n\t\treturn err;\n\t}\n\n\terr = ubifs_node_check_hash(c, idx, zzbr->hash);\n\tif (err) {\n\t\tubifs_bad_hash(c, idx, zzbr->hash, lnum, offs);\n\t\tkfree(idx);\n\t\treturn err;\n\t}\n\n\tznode->child_cnt = le16_to_cpu(idx->child_cnt);\n\tznode->level = le16_to_cpu(idx->level);\n\n\tdbg_tnc(\"LEB %d:%d, level %d, %d branch\",\n\t\tlnum, offs, znode->level, znode->child_cnt);\n\n\tif (znode->child_cnt > c->fanout || znode->level > UBIFS_MAX_LEVELS) {\n\t\tubifs_err(c, \"current fanout %d, branch count %d\",\n\t\t\t  c->fanout, znode->child_cnt);\n\t\tubifs_err(c, \"max levels %d, znode level %d\",\n\t\t\t  UBIFS_MAX_LEVELS, znode->level);\n\t\terr = 1;\n\t\tgoto out_dump;\n\t}\n\n\tfor (i = 0; i < znode->child_cnt; i++) {\n\t\tstruct ubifs_branch *br = ubifs_idx_branch(c, idx, i);\n\t\tstruct ubifs_zbranch *zbr = &znode->zbranch[i];\n\n\t\tkey_read(c, &br->key, &zbr->key);\n\t\tzbr->lnum = le32_to_cpu(br->lnum);\n\t\tzbr->offs = le32_to_cpu(br->offs);\n\t\tzbr->len  = le32_to_cpu(br->len);\n\t\tubifs_copy_hash(c, ubifs_branch_hash(c, br), zbr->hash);\n\t\tzbr->znode = NULL;\n\n\t\t \n\n\t\tif (zbr->lnum < c->main_first ||\n\t\t    zbr->lnum >= c->leb_cnt || zbr->offs < 0 ||\n\t\t    zbr->offs + zbr->len > c->leb_size || zbr->offs & 7) {\n\t\t\tubifs_err(c, \"bad branch %d\", i);\n\t\t\terr = 2;\n\t\t\tgoto out_dump;\n\t\t}\n\n\t\tswitch (key_type(c, &zbr->key)) {\n\t\tcase UBIFS_INO_KEY:\n\t\tcase UBIFS_DATA_KEY:\n\t\tcase UBIFS_DENT_KEY:\n\t\tcase UBIFS_XENT_KEY:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tubifs_err(c, \"bad key type at slot %d: %d\",\n\t\t\t\t  i, key_type(c, &zbr->key));\n\t\t\terr = 3;\n\t\t\tgoto out_dump;\n\t\t}\n\n\t\tif (znode->level)\n\t\t\tcontinue;\n\n\t\ttype = key_type(c, &zbr->key);\n\t\tif (c->ranges[type].max_len == 0) {\n\t\t\tif (zbr->len != c->ranges[type].len) {\n\t\t\t\tubifs_err(c, \"bad target node (type %d) length (%d)\",\n\t\t\t\t\t  type, zbr->len);\n\t\t\t\tubifs_err(c, \"have to be %d\", c->ranges[type].len);\n\t\t\t\terr = 4;\n\t\t\t\tgoto out_dump;\n\t\t\t}\n\t\t} else if (zbr->len < c->ranges[type].min_len ||\n\t\t\t   zbr->len > c->ranges[type].max_len) {\n\t\t\tubifs_err(c, \"bad target node (type %d) length (%d)\",\n\t\t\t\t  type, zbr->len);\n\t\t\tubifs_err(c, \"have to be in range of %d-%d\",\n\t\t\t\t  c->ranges[type].min_len,\n\t\t\t\t  c->ranges[type].max_len);\n\t\t\terr = 5;\n\t\t\tgoto out_dump;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < znode->child_cnt - 1; i++) {\n\t\tconst union ubifs_key *key1, *key2;\n\n\t\tkey1 = &znode->zbranch[i].key;\n\t\tkey2 = &znode->zbranch[i + 1].key;\n\n\t\tcmp = keys_cmp(c, key1, key2);\n\t\tif (cmp > 0) {\n\t\t\tubifs_err(c, \"bad key order (keys %d and %d)\", i, i + 1);\n\t\t\terr = 6;\n\t\t\tgoto out_dump;\n\t\t} else if (cmp == 0 && !is_hash_key(c, key1)) {\n\t\t\t \n\t\t\tubifs_err(c, \"keys %d and %d are not hashed but equivalent\",\n\t\t\t\t  i, i + 1);\n\t\t\terr = 7;\n\t\t\tgoto out_dump;\n\t\t}\n\t}\n\n\tkfree(idx);\n\treturn 0;\n\nout_dump:\n\tubifs_err(c, \"bad indexing node at LEB %d:%d, error %d\", lnum, offs, err);\n\tubifs_dump_node(c, idx, c->max_idx_node_sz);\n\tkfree(idx);\n\treturn -EINVAL;\n}\n\n \nstruct ubifs_znode *ubifs_load_znode(struct ubifs_info *c,\n\t\t\t\t     struct ubifs_zbranch *zbr,\n\t\t\t\t     struct ubifs_znode *parent, int iip)\n{\n\tint err;\n\tstruct ubifs_znode *znode;\n\n\tubifs_assert(c, !zbr->znode);\n\t \n\tznode = kzalloc(c->max_znode_sz, GFP_NOFS);\n\tif (!znode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_znode(c, zbr, znode);\n\tif (err)\n\t\tgoto out;\n\n\tatomic_long_inc(&c->clean_zn_cnt);\n\n\t \n\tatomic_long_inc(&ubifs_clean_zn_cnt);\n\n\tzbr->znode = znode;\n\tznode->parent = parent;\n\tznode->time = ktime_get_seconds();\n\tznode->iip = iip;\n\n\treturn znode;\n\nout:\n\tkfree(znode);\n\treturn ERR_PTR(err);\n}\n\n \nint ubifs_tnc_read_node(struct ubifs_info *c, struct ubifs_zbranch *zbr,\n\t\t\tvoid *node)\n{\n\tunion ubifs_key key1, *key = &zbr->key;\n\tint err, type = key_type(c, key);\n\tstruct ubifs_wbuf *wbuf;\n\n\t \n\twbuf = ubifs_get_wbuf(c, zbr->lnum);\n\tif (wbuf)\n\t\terr = ubifs_read_node_wbuf(wbuf, node, type, zbr->len,\n\t\t\t\t\t   zbr->lnum, zbr->offs);\n\telse\n\t\terr = ubifs_read_node(c, node, type, zbr->len, zbr->lnum,\n\t\t\t\t      zbr->offs);\n\n\tif (err) {\n\t\tdbg_tnck(key, \"key \");\n\t\treturn err;\n\t}\n\n\t \n\tkey_read(c, node + UBIFS_KEY_OFFSET, &key1);\n\tif (!keys_eq(c, key, &key1)) {\n\t\tubifs_err(c, \"bad key in node at LEB %d:%d\",\n\t\t\t  zbr->lnum, zbr->offs);\n\t\tdbg_tnck(key, \"looked for key \");\n\t\tdbg_tnck(&key1, \"but found node's key \");\n\t\tubifs_dump_node(c, node, zbr->len);\n\t\treturn -EINVAL;\n\t}\n\n\terr = ubifs_node_check_hash(c, node, zbr->hash);\n\tif (err) {\n\t\tubifs_bad_hash(c, node, zbr->hash, zbr->lnum, zbr->offs);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}