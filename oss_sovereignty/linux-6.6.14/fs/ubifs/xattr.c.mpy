{
  "module_name": "xattr.c",
  "hash_id": "df971a04421cfab4f566d4663ef0213270937bbb510a6db55388d6c6451e8a85",
  "original_prompt": "Ingested from linux-6.6.14/fs/ubifs/xattr.c",
  "human_readable_source": "\n \n\n \n\n#include \"ubifs.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/xattr.h>\n\n \nenum {\n\tUSER_XATTR,\n\tTRUSTED_XATTR,\n\tSECURITY_XATTR,\n};\n\nstatic const struct inode_operations empty_iops;\nstatic const struct file_operations empty_fops;\n\n \nstatic int create_xattr(struct ubifs_info *c, struct inode *host,\n\t\t\tconst struct fscrypt_name *nm, const void *value, int size)\n{\n\tint err, names_len;\n\tstruct inode *inode;\n\tstruct ubifs_inode *ui, *host_ui = ubifs_inode(host);\n\tstruct ubifs_budget_req req = { .new_ino = 1, .new_dent = 1,\n\t\t\t\t.new_ino_d = ALIGN(size, 8), .dirtied_ino = 1,\n\t\t\t\t.dirtied_ino_d = ALIGN(host_ui->data_len, 8) };\n\n\tif (host_ui->xattr_cnt >= ubifs_xattr_max_cnt(c)) {\n\t\tubifs_err(c, \"inode %lu already has too many xattrs (%d), cannot create more\",\n\t\t\t  host->i_ino, host_ui->xattr_cnt);\n\t\treturn -ENOSPC;\n\t}\n\t \n\tnames_len = host_ui->xattr_names + host_ui->xattr_cnt + fname_len(nm) + 1;\n\tif (names_len > XATTR_LIST_MAX) {\n\t\tubifs_err(c, \"cannot add one more xattr name to inode %lu, total names length would become %d, max. is %d\",\n\t\t\t  host->i_ino, names_len, XATTR_LIST_MAX);\n\t\treturn -ENOSPC;\n\t}\n\n\terr = ubifs_budget_space(c, &req);\n\tif (err)\n\t\treturn err;\n\n\tinode = ubifs_new_inode(c, host, S_IFREG | S_IRWXUGO, true);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tgoto out_budg;\n\t}\n\n\t \n\tinode->i_mapping->a_ops = &empty_aops;\n\tinode->i_op = &empty_iops;\n\tinode->i_fop = &empty_fops;\n\n\tinode->i_flags |= S_SYNC | S_NOATIME | S_NOCMTIME;\n\tui = ubifs_inode(inode);\n\tui->xattr = 1;\n\tui->flags |= UBIFS_XATTR_FL;\n\tui->data = kmemdup(value, size, GFP_NOFS);\n\tif (!ui->data) {\n\t\terr = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\tinode->i_size = ui->ui_size = size;\n\tui->data_len = size;\n\n\tmutex_lock(&host_ui->ui_mutex);\n\tinode_set_ctime_current(host);\n\thost_ui->xattr_cnt += 1;\n\thost_ui->xattr_size += CALC_DENT_SIZE(fname_len(nm));\n\thost_ui->xattr_size += CALC_XATTR_BYTES(size);\n\thost_ui->xattr_names += fname_len(nm);\n\n\t \n\tif (strcmp(fname_name(nm), UBIFS_XATTR_NAME_ENCRYPTION_CONTEXT) == 0)\n\t\thost_ui->flags |= UBIFS_CRYPT_FL;\n\n\terr = ubifs_jnl_update(c, host, nm, inode, 0, 1);\n\tif (err)\n\t\tgoto out_cancel;\n\tubifs_set_inode_flags(host);\n\tmutex_unlock(&host_ui->ui_mutex);\n\n\tubifs_release_budget(c, &req);\n\tinsert_inode_hash(inode);\n\tiput(inode);\n\treturn 0;\n\nout_cancel:\n\thost_ui->xattr_cnt -= 1;\n\thost_ui->xattr_size -= CALC_DENT_SIZE(fname_len(nm));\n\thost_ui->xattr_size -= CALC_XATTR_BYTES(size);\n\thost_ui->xattr_names -= fname_len(nm);\n\thost_ui->flags &= ~UBIFS_CRYPT_FL;\n\tmutex_unlock(&host_ui->ui_mutex);\nout_free:\n\tmake_bad_inode(inode);\n\tiput(inode);\nout_budg:\n\tubifs_release_budget(c, &req);\n\treturn err;\n}\n\n \nstatic int change_xattr(struct ubifs_info *c, struct inode *host,\n\t\t\tstruct inode *inode, const void *value, int size)\n{\n\tint err;\n\tstruct ubifs_inode *host_ui = ubifs_inode(host);\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\tvoid *buf = NULL;\n\tint old_size;\n\tstruct ubifs_budget_req req = { .dirtied_ino = 2,\n\t\t.dirtied_ino_d = ALIGN(size, 8) + ALIGN(host_ui->data_len, 8) };\n\n\tubifs_assert(c, ui->data_len == inode->i_size);\n\terr = ubifs_budget_space(c, &req);\n\tif (err)\n\t\treturn err;\n\n\tbuf = kmemdup(value, size, GFP_NOFS);\n\tif (!buf) {\n\t\terr = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\tkfree(ui->data);\n\tui->data = buf;\n\tinode->i_size = ui->ui_size = size;\n\told_size = ui->data_len;\n\tui->data_len = size;\n\n\tmutex_lock(&host_ui->ui_mutex);\n\tinode_set_ctime_current(host);\n\thost_ui->xattr_size -= CALC_XATTR_BYTES(old_size);\n\thost_ui->xattr_size += CALC_XATTR_BYTES(size);\n\n\t \n\terr = ubifs_jnl_change_xattr(c, inode, host);\n\tif (err)\n\t\tgoto out_cancel;\n\tmutex_unlock(&host_ui->ui_mutex);\n\n\tubifs_release_budget(c, &req);\n\treturn 0;\n\nout_cancel:\n\thost_ui->xattr_size -= CALC_XATTR_BYTES(size);\n\thost_ui->xattr_size += CALC_XATTR_BYTES(old_size);\n\tmutex_unlock(&host_ui->ui_mutex);\n\tmake_bad_inode(inode);\nout_free:\n\tubifs_release_budget(c, &req);\n\treturn err;\n}\n\nstatic struct inode *iget_xattr(struct ubifs_info *c, ino_t inum)\n{\n\tstruct inode *inode;\n\n\tinode = ubifs_iget(c->vfs_sb, inum);\n\tif (IS_ERR(inode)) {\n\t\tubifs_err(c, \"dead extended attribute entry, error %d\",\n\t\t\t  (int)PTR_ERR(inode));\n\t\treturn inode;\n\t}\n\tif (ubifs_inode(inode)->xattr)\n\t\treturn inode;\n\tubifs_err(c, \"corrupt extended attribute entry\");\n\tiput(inode);\n\treturn ERR_PTR(-EINVAL);\n}\n\nint ubifs_xattr_set(struct inode *host, const char *name, const void *value,\n\t\t    size_t size, int flags, bool check_lock)\n{\n\tstruct inode *inode;\n\tstruct ubifs_info *c = host->i_sb->s_fs_info;\n\tstruct fscrypt_name nm = { .disk_name = FSTR_INIT((char *)name, strlen(name))};\n\tstruct ubifs_dent_node *xent;\n\tunion ubifs_key key;\n\tint err;\n\n\tif (check_lock)\n\t\tubifs_assert(c, inode_is_locked(host));\n\n\tif (size > UBIFS_MAX_INO_DATA)\n\t\treturn -ERANGE;\n\n\tif (fname_len(&nm) > UBIFS_MAX_NLEN)\n\t\treturn -ENAMETOOLONG;\n\n\txent = kmalloc(UBIFS_MAX_XENT_NODE_SZ, GFP_NOFS);\n\tif (!xent)\n\t\treturn -ENOMEM;\n\n\tdown_write(&ubifs_inode(host)->xattr_sem);\n\t \n\txent_key_init(c, &key, host->i_ino, &nm);\n\terr = ubifs_tnc_lookup_nm(c, &key, xent, &nm);\n\tif (err) {\n\t\tif (err != -ENOENT)\n\t\t\tgoto out_free;\n\n\t\tif (flags & XATTR_REPLACE)\n\t\t\t \n\t\t\terr = -ENODATA;\n\t\telse\n\t\t\terr = create_xattr(c, host, &nm, value, size);\n\t\tgoto out_free;\n\t}\n\n\tif (flags & XATTR_CREATE) {\n\t\t \n\t\terr = -EEXIST;\n\t\tgoto out_free;\n\t}\n\n\tinode = iget_xattr(c, le64_to_cpu(xent->inum));\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tgoto out_free;\n\t}\n\n\terr = change_xattr(c, host, inode, value, size);\n\tiput(inode);\n\nout_free:\n\tup_write(&ubifs_inode(host)->xattr_sem);\n\tkfree(xent);\n\treturn err;\n}\n\nssize_t ubifs_xattr_get(struct inode *host, const char *name, void *buf,\n\t\t\tsize_t size)\n{\n\tstruct inode *inode;\n\tstruct ubifs_info *c = host->i_sb->s_fs_info;\n\tstruct fscrypt_name nm = { .disk_name = FSTR_INIT((char *)name, strlen(name))};\n\tstruct ubifs_inode *ui;\n\tstruct ubifs_dent_node *xent;\n\tunion ubifs_key key;\n\tint err;\n\n\tif (fname_len(&nm) > UBIFS_MAX_NLEN)\n\t\treturn -ENAMETOOLONG;\n\n\txent = kmalloc(UBIFS_MAX_XENT_NODE_SZ, GFP_NOFS);\n\tif (!xent)\n\t\treturn -ENOMEM;\n\n\tdown_read(&ubifs_inode(host)->xattr_sem);\n\txent_key_init(c, &key, host->i_ino, &nm);\n\terr = ubifs_tnc_lookup_nm(c, &key, xent, &nm);\n\tif (err) {\n\t\tif (err == -ENOENT)\n\t\t\terr = -ENODATA;\n\t\tgoto out_cleanup;\n\t}\n\n\tinode = iget_xattr(c, le64_to_cpu(xent->inum));\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tgoto out_cleanup;\n\t}\n\n\tui = ubifs_inode(inode);\n\tubifs_assert(c, inode->i_size == ui->data_len);\n\tubifs_assert(c, ubifs_inode(host)->xattr_size > ui->data_len);\n\n\tif (buf) {\n\t\t \n\t\tif (ui->data_len > size) {\n\t\t\terr = -ERANGE;\n\t\t\tgoto out_iput;\n\t\t}\n\n\t\tmemcpy(buf, ui->data, ui->data_len);\n\t}\n\terr = ui->data_len;\n\nout_iput:\n\tiput(inode);\nout_cleanup:\n\tup_read(&ubifs_inode(host)->xattr_sem);\n\tkfree(xent);\n\treturn err;\n}\n\nstatic bool xattr_visible(const char *name)\n{\n\t \n\tif (strcmp(name, UBIFS_XATTR_NAME_ENCRYPTION_CONTEXT) == 0)\n\t\treturn false;\n\n\t \n\tif (strncmp(name, XATTR_TRUSTED_PREFIX,\n\t\t    XATTR_TRUSTED_PREFIX_LEN) == 0 && !capable(CAP_SYS_ADMIN))\n\t\treturn false;\n\n\treturn true;\n}\n\nssize_t ubifs_listxattr(struct dentry *dentry, char *buffer, size_t size)\n{\n\tunion ubifs_key key;\n\tstruct inode *host = d_inode(dentry);\n\tstruct ubifs_info *c = host->i_sb->s_fs_info;\n\tstruct ubifs_inode *host_ui = ubifs_inode(host);\n\tstruct ubifs_dent_node *xent, *pxent = NULL;\n\tint err, len, written = 0;\n\tstruct fscrypt_name nm = {0};\n\n\tdbg_gen(\"ino %lu ('%pd'), buffer size %zd\", host->i_ino,\n\t\tdentry, size);\n\n\tdown_read(&host_ui->xattr_sem);\n\tlen = host_ui->xattr_names + host_ui->xattr_cnt;\n\tif (!buffer) {\n\t\t \n\t\terr = len;\n\t\tgoto out_err;\n\t}\n\n\tif (len > size) {\n\t\terr = -ERANGE;\n\t\tgoto out_err;\n\t}\n\n\tlowest_xent_key(c, &key, host->i_ino);\n\twhile (1) {\n\t\txent = ubifs_tnc_next_ent(c, &key, &nm);\n\t\tif (IS_ERR(xent)) {\n\t\t\terr = PTR_ERR(xent);\n\t\t\tbreak;\n\t\t}\n\n\t\tfname_name(&nm) = xent->name;\n\t\tfname_len(&nm) = le16_to_cpu(xent->nlen);\n\n\t\tif (xattr_visible(xent->name)) {\n\t\t\tmemcpy(buffer + written, fname_name(&nm), fname_len(&nm) + 1);\n\t\t\twritten += fname_len(&nm) + 1;\n\t\t}\n\n\t\tkfree(pxent);\n\t\tpxent = xent;\n\t\tkey_read(c, &xent->key, &key);\n\t}\n\tkfree(pxent);\n\tup_read(&host_ui->xattr_sem);\n\n\tif (err != -ENOENT) {\n\t\tubifs_err(c, \"cannot find next direntry, error %d\", err);\n\t\treturn err;\n\t}\n\n\tubifs_assert(c, written <= size);\n\treturn written;\n\nout_err:\n\tup_read(&host_ui->xattr_sem);\n\treturn err;\n}\n\nstatic int remove_xattr(struct ubifs_info *c, struct inode *host,\n\t\t\tstruct inode *inode, const struct fscrypt_name *nm)\n{\n\tint err;\n\tstruct ubifs_inode *host_ui = ubifs_inode(host);\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\tstruct ubifs_budget_req req = { .dirtied_ino = 2, .mod_dent = 1,\n\t\t\t\t.dirtied_ino_d = ALIGN(host_ui->data_len, 8) };\n\n\tubifs_assert(c, ui->data_len == inode->i_size);\n\n\terr = ubifs_budget_space(c, &req);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&host_ui->ui_mutex);\n\tinode_set_ctime_current(host);\n\thost_ui->xattr_cnt -= 1;\n\thost_ui->xattr_size -= CALC_DENT_SIZE(fname_len(nm));\n\thost_ui->xattr_size -= CALC_XATTR_BYTES(ui->data_len);\n\thost_ui->xattr_names -= fname_len(nm);\n\n\terr = ubifs_jnl_delete_xattr(c, host, inode, nm);\n\tif (err)\n\t\tgoto out_cancel;\n\tmutex_unlock(&host_ui->ui_mutex);\n\n\tubifs_release_budget(c, &req);\n\treturn 0;\n\nout_cancel:\n\thost_ui->xattr_cnt += 1;\n\thost_ui->xattr_size += CALC_DENT_SIZE(fname_len(nm));\n\thost_ui->xattr_size += CALC_XATTR_BYTES(ui->data_len);\n\thost_ui->xattr_names += fname_len(nm);\n\tmutex_unlock(&host_ui->ui_mutex);\n\tubifs_release_budget(c, &req);\n\tmake_bad_inode(inode);\n\treturn err;\n}\n\nint ubifs_purge_xattrs(struct inode *host)\n{\n\tunion ubifs_key key;\n\tstruct ubifs_info *c = host->i_sb->s_fs_info;\n\tstruct ubifs_dent_node *xent, *pxent = NULL;\n\tstruct inode *xino;\n\tstruct fscrypt_name nm = {0};\n\tint err;\n\n\tif (ubifs_inode(host)->xattr_cnt <= ubifs_xattr_max_cnt(c))\n\t\treturn 0;\n\n\tubifs_warn(c, \"inode %lu has too many xattrs, doing a non-atomic deletion\",\n\t\t   host->i_ino);\n\n\tdown_write(&ubifs_inode(host)->xattr_sem);\n\tlowest_xent_key(c, &key, host->i_ino);\n\twhile (1) {\n\t\txent = ubifs_tnc_next_ent(c, &key, &nm);\n\t\tif (IS_ERR(xent)) {\n\t\t\terr = PTR_ERR(xent);\n\t\t\tbreak;\n\t\t}\n\n\t\tfname_name(&nm) = xent->name;\n\t\tfname_len(&nm) = le16_to_cpu(xent->nlen);\n\n\t\txino = ubifs_iget(c->vfs_sb, le64_to_cpu(xent->inum));\n\t\tif (IS_ERR(xino)) {\n\t\t\terr = PTR_ERR(xino);\n\t\t\tubifs_err(c, \"dead directory entry '%s', error %d\",\n\t\t\t\t  xent->name, err);\n\t\t\tubifs_ro_mode(c, err);\n\t\t\tkfree(pxent);\n\t\t\tkfree(xent);\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tubifs_assert(c, ubifs_inode(xino)->xattr);\n\n\t\tclear_nlink(xino);\n\t\terr = remove_xattr(c, host, xino, &nm);\n\t\tif (err) {\n\t\t\tkfree(pxent);\n\t\t\tkfree(xent);\n\t\t\tiput(xino);\n\t\t\tubifs_err(c, \"cannot remove xattr, error %d\", err);\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tiput(xino);\n\n\t\tkfree(pxent);\n\t\tpxent = xent;\n\t\tkey_read(c, &xent->key, &key);\n\t}\n\tkfree(pxent);\n\tup_write(&ubifs_inode(host)->xattr_sem);\n\n\tif (err != -ENOENT) {\n\t\tubifs_err(c, \"cannot find next direntry, error %d\", err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n\nout_err:\n\tup_write(&ubifs_inode(host)->xattr_sem);\n\treturn err;\n}\n\n \nvoid ubifs_evict_xattr_inode(struct ubifs_info *c, ino_t xattr_inum)\n{\n\tstruct inode *inode;\n\n\tinode = ilookup(c->vfs_sb, xattr_inum);\n\tif (inode) {\n\t\tclear_nlink(inode);\n\t\tiput(inode);\n\t}\n}\n\nstatic int ubifs_xattr_remove(struct inode *host, const char *name)\n{\n\tstruct inode *inode;\n\tstruct ubifs_info *c = host->i_sb->s_fs_info;\n\tstruct fscrypt_name nm = { .disk_name = FSTR_INIT((char *)name, strlen(name))};\n\tstruct ubifs_dent_node *xent;\n\tunion ubifs_key key;\n\tint err;\n\n\tubifs_assert(c, inode_is_locked(host));\n\n\tif (fname_len(&nm) > UBIFS_MAX_NLEN)\n\t\treturn -ENAMETOOLONG;\n\n\txent = kmalloc(UBIFS_MAX_XENT_NODE_SZ, GFP_NOFS);\n\tif (!xent)\n\t\treturn -ENOMEM;\n\n\tdown_write(&ubifs_inode(host)->xattr_sem);\n\txent_key_init(c, &key, host->i_ino, &nm);\n\terr = ubifs_tnc_lookup_nm(c, &key, xent, &nm);\n\tif (err) {\n\t\tif (err == -ENOENT)\n\t\t\terr = -ENODATA;\n\t\tgoto out_free;\n\t}\n\n\tinode = iget_xattr(c, le64_to_cpu(xent->inum));\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tgoto out_free;\n\t}\n\n\tubifs_assert(c, inode->i_nlink == 1);\n\tclear_nlink(inode);\n\terr = remove_xattr(c, host, inode, &nm);\n\tif (err)\n\t\tset_nlink(inode, 1);\n\n\t \n\tiput(inode);\n\nout_free:\n\tup_write(&ubifs_inode(host)->xattr_sem);\n\tkfree(xent);\n\treturn err;\n}\n\n#ifdef CONFIG_UBIFS_FS_SECURITY\nstatic int init_xattrs(struct inode *inode, const struct xattr *xattr_array,\n\t\t      void *fs_info)\n{\n\tconst struct xattr *xattr;\n\tchar *name;\n\tint err = 0;\n\n\tfor (xattr = xattr_array; xattr->name != NULL; xattr++) {\n\t\tname = kmalloc(XATTR_SECURITY_PREFIX_LEN +\n\t\t\t       strlen(xattr->name) + 1, GFP_NOFS);\n\t\tif (!name) {\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\tstrcpy(name, XATTR_SECURITY_PREFIX);\n\t\tstrcpy(name + XATTR_SECURITY_PREFIX_LEN, xattr->name);\n\t\t \n\t\terr = ubifs_xattr_set(inode, name, xattr->value,\n\t\t\t\t      xattr->value_len, 0, false);\n\t\tkfree(name);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nint ubifs_init_security(struct inode *dentry, struct inode *inode,\n\t\t\tconst struct qstr *qstr)\n{\n\tint err;\n\n\terr = security_inode_init_security(inode, dentry, qstr,\n\t\t\t\t\t   &init_xattrs, NULL);\n\tif (err) {\n\t\tstruct ubifs_info *c = dentry->i_sb->s_fs_info;\n\t\tubifs_err(c, \"cannot initialize security for inode %lu, error %d\",\n\t\t\t  inode->i_ino, err);\n\t}\n\treturn err;\n}\n#endif\n\nstatic int xattr_get(const struct xattr_handler *handler,\n\t\t\t   struct dentry *dentry, struct inode *inode,\n\t\t\t   const char *name, void *buffer, size_t size)\n{\n\tdbg_gen(\"xattr '%s', ino %lu ('%pd'), buf size %zd\", name,\n\t\tinode->i_ino, dentry, size);\n\n\tname = xattr_full_name(handler, name);\n\treturn ubifs_xattr_get(inode, name, buffer, size);\n}\n\nstatic int xattr_set(const struct xattr_handler *handler,\n\t\t\t   struct mnt_idmap *idmap,\n\t\t\t   struct dentry *dentry, struct inode *inode,\n\t\t\t   const char *name, const void *value,\n\t\t\t   size_t size, int flags)\n{\n\tdbg_gen(\"xattr '%s', host ino %lu ('%pd'), size %zd\",\n\t\tname, inode->i_ino, dentry, size);\n\n\tname = xattr_full_name(handler, name);\n\n\tif (value)\n\t\treturn ubifs_xattr_set(inode, name, value, size, flags, true);\n\telse\n\t\treturn ubifs_xattr_remove(inode, name);\n}\n\nstatic const struct xattr_handler ubifs_user_xattr_handler = {\n\t.prefix = XATTR_USER_PREFIX,\n\t.get = xattr_get,\n\t.set = xattr_set,\n};\n\nstatic const struct xattr_handler ubifs_trusted_xattr_handler = {\n\t.prefix = XATTR_TRUSTED_PREFIX,\n\t.get = xattr_get,\n\t.set = xattr_set,\n};\n\n#ifdef CONFIG_UBIFS_FS_SECURITY\nstatic const struct xattr_handler ubifs_security_xattr_handler = {\n\t.prefix = XATTR_SECURITY_PREFIX,\n\t.get = xattr_get,\n\t.set = xattr_set,\n};\n#endif\n\nconst struct xattr_handler *ubifs_xattr_handlers[] = {\n\t&ubifs_user_xattr_handler,\n\t&ubifs_trusted_xattr_handler,\n#ifdef CONFIG_UBIFS_FS_SECURITY\n\t&ubifs_security_xattr_handler,\n#endif\n\tNULL\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}