{
  "module_name": "sb.c",
  "hash_id": "32385ccc697ec994ec33a2727ee27d2ef42e61f9bd768b0fea8e6a97e48f55cc",
  "original_prompt": "Ingested from linux-6.6.14/fs/ubifs/sb.c",
  "human_readable_source": "\n \n\n \n\n#include \"ubifs.h\"\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/uuid.h>\n\n \n#define DEFAULT_JNL_PERCENT 5\n\n \n#define DEFAULT_MAX_JNL (32*1024*1024)\n\n \n#define DEFAULT_FANOUT 8\n\n \n#define DEFAULT_JHEADS_CNT 1\n\n \n#define DEFAULT_IDX_LEB  0\n#define DEFAULT_DATA_LEB 1\n#define DEFAULT_GC_LEB   2\n\n \n#define DEFAULT_LSAVE_CNT 256\n\n \n#define DEFAULT_RP_PERCENT 5\n\n \n#define DEFAULT_MAX_RP_SIZE (5*1024*1024)\n\n \n#define DEFAULT_TIME_GRAN 1000000000\n\nstatic int get_default_compressor(struct ubifs_info *c)\n{\n\tif (ubifs_compr_present(c, UBIFS_COMPR_ZSTD))\n\t\treturn UBIFS_COMPR_ZSTD;\n\n\tif (ubifs_compr_present(c, UBIFS_COMPR_LZO))\n\t\treturn UBIFS_COMPR_LZO;\n\n\tif (ubifs_compr_present(c, UBIFS_COMPR_ZLIB))\n\t\treturn UBIFS_COMPR_ZLIB;\n\n\treturn UBIFS_COMPR_NONE;\n}\n\n \nstatic int create_default_filesystem(struct ubifs_info *c)\n{\n\tstruct ubifs_sb_node *sup;\n\tstruct ubifs_mst_node *mst;\n\tstruct ubifs_idx_node *idx;\n\tstruct ubifs_branch *br;\n\tstruct ubifs_ino_node *ino;\n\tstruct ubifs_cs_node *cs;\n\tunion ubifs_key key;\n\tint err, tmp, jnl_lebs, log_lebs, max_buds, main_lebs, main_first;\n\tint lpt_lebs, lpt_first, orph_lebs, big_lpt, ino_waste, sup_flags = 0;\n\tint min_leb_cnt = UBIFS_MIN_LEB_CNT;\n\tint idx_node_size;\n\tlong long tmp64, main_bytes;\n\t__le64 tmp_le64;\n\tstruct timespec64 ts;\n\tu8 hash[UBIFS_HASH_ARR_SZ];\n\tu8 hash_lpt[UBIFS_HASH_ARR_SZ];\n\n\t \n\tc->key_len = UBIFS_SK_LEN;\n\n\t \n\tif (c->leb_cnt < 0x7FFFFFFF / DEFAULT_JNL_PERCENT)\n\t\t \n\t\tjnl_lebs = c->leb_cnt * DEFAULT_JNL_PERCENT / 100;\n\telse\n\t\tjnl_lebs = (c->leb_cnt / 100) * DEFAULT_JNL_PERCENT;\n\n\tif (jnl_lebs < UBIFS_MIN_JNL_LEBS)\n\t\tjnl_lebs = UBIFS_MIN_JNL_LEBS;\n\tif (jnl_lebs * c->leb_size > DEFAULT_MAX_JNL)\n\t\tjnl_lebs = DEFAULT_MAX_JNL / c->leb_size;\n\n\t \n\ttmp = 2 * (c->ref_node_alsz * jnl_lebs) + c->leb_size - 1;\n\tlog_lebs = tmp / c->leb_size;\n\t \n\tlog_lebs += 1;\n\tif (c->leb_cnt - min_leb_cnt > 8) {\n\t\t \n\t\tlog_lebs += 1;\n\t\tmin_leb_cnt += 1;\n\t}\n\n\tmax_buds = jnl_lebs - log_lebs;\n\tif (max_buds < UBIFS_MIN_BUD_LEBS)\n\t\tmax_buds = UBIFS_MIN_BUD_LEBS;\n\n\t \n\torph_lebs = UBIFS_MIN_ORPH_LEBS;\n\tif (c->leb_cnt - min_leb_cnt > 1)\n\t\t \n\t\torph_lebs += 1;\n\n\tmain_lebs = c->leb_cnt - UBIFS_SB_LEBS - UBIFS_MST_LEBS - log_lebs;\n\tmain_lebs -= orph_lebs;\n\n\tlpt_first = UBIFS_LOG_LNUM + log_lebs;\n\tc->lsave_cnt = DEFAULT_LSAVE_CNT;\n\tc->max_leb_cnt = c->leb_cnt;\n\terr = ubifs_create_dflt_lpt(c, &main_lebs, lpt_first, &lpt_lebs,\n\t\t\t\t    &big_lpt, hash_lpt);\n\tif (err)\n\t\treturn err;\n\n\tdbg_gen(\"LEB Properties Tree created (LEBs %d-%d)\", lpt_first,\n\t\tlpt_first + lpt_lebs - 1);\n\n\tmain_first = c->leb_cnt - main_lebs;\n\n\tsup = kzalloc(ALIGN(UBIFS_SB_NODE_SZ, c->min_io_size), GFP_KERNEL);\n\tmst = kzalloc(c->mst_node_alsz, GFP_KERNEL);\n\tidx_node_size = ubifs_idx_node_sz(c, 1);\n\tidx = kzalloc(ALIGN(idx_node_size, c->min_io_size), GFP_KERNEL);\n\tino = kzalloc(ALIGN(UBIFS_INO_NODE_SZ, c->min_io_size), GFP_KERNEL);\n\tcs = kzalloc(ALIGN(UBIFS_CS_NODE_SZ, c->min_io_size), GFP_KERNEL);\n\n\tif (!sup || !mst || !idx || !ino || !cs) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\n\ttmp64 = (long long)max_buds * c->leb_size;\n\tif (big_lpt)\n\t\tsup_flags |= UBIFS_FLG_BIGLPT;\n\tif (ubifs_default_version > 4)\n\t\tsup_flags |= UBIFS_FLG_DOUBLE_HASH;\n\n\tif (ubifs_authenticated(c)) {\n\t\tsup_flags |= UBIFS_FLG_AUTHENTICATION;\n\t\tsup->hash_algo = cpu_to_le16(c->auth_hash_algo);\n\t\terr = ubifs_hmac_wkm(c, sup->hmac_wkm);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\tsup->hash_algo = cpu_to_le16(0xffff);\n\t}\n\n\tsup->ch.node_type  = UBIFS_SB_NODE;\n\tsup->key_hash      = UBIFS_KEY_HASH_R5;\n\tsup->flags         = cpu_to_le32(sup_flags);\n\tsup->min_io_size   = cpu_to_le32(c->min_io_size);\n\tsup->leb_size      = cpu_to_le32(c->leb_size);\n\tsup->leb_cnt       = cpu_to_le32(c->leb_cnt);\n\tsup->max_leb_cnt   = cpu_to_le32(c->max_leb_cnt);\n\tsup->max_bud_bytes = cpu_to_le64(tmp64);\n\tsup->log_lebs      = cpu_to_le32(log_lebs);\n\tsup->lpt_lebs      = cpu_to_le32(lpt_lebs);\n\tsup->orph_lebs     = cpu_to_le32(orph_lebs);\n\tsup->jhead_cnt     = cpu_to_le32(DEFAULT_JHEADS_CNT);\n\tsup->fanout        = cpu_to_le32(DEFAULT_FANOUT);\n\tsup->lsave_cnt     = cpu_to_le32(c->lsave_cnt);\n\tsup->fmt_version   = cpu_to_le32(ubifs_default_version);\n\tsup->time_gran     = cpu_to_le32(DEFAULT_TIME_GRAN);\n\tif (c->mount_opts.override_compr)\n\t\tsup->default_compr = cpu_to_le16(c->mount_opts.compr_type);\n\telse\n\t\tsup->default_compr = cpu_to_le16(get_default_compressor(c));\n\n\tgenerate_random_uuid(sup->uuid);\n\n\tmain_bytes = (long long)main_lebs * c->leb_size;\n\ttmp64 = div_u64(main_bytes * DEFAULT_RP_PERCENT, 100);\n\tif (tmp64 > DEFAULT_MAX_RP_SIZE)\n\t\ttmp64 = DEFAULT_MAX_RP_SIZE;\n\tsup->rp_size = cpu_to_le64(tmp64);\n\tsup->ro_compat_version = cpu_to_le32(UBIFS_RO_COMPAT_VERSION);\n\n\tdbg_gen(\"default superblock created at LEB 0:0\");\n\n\t \n\n\tmst->ch.node_type = UBIFS_MST_NODE;\n\tmst->log_lnum     = cpu_to_le32(UBIFS_LOG_LNUM);\n\tmst->highest_inum = cpu_to_le64(UBIFS_FIRST_INO);\n\tmst->cmt_no       = 0;\n\tmst->root_lnum    = cpu_to_le32(main_first + DEFAULT_IDX_LEB);\n\tmst->root_offs    = 0;\n\ttmp = ubifs_idx_node_sz(c, 1);\n\tmst->root_len     = cpu_to_le32(tmp);\n\tmst->gc_lnum      = cpu_to_le32(main_first + DEFAULT_GC_LEB);\n\tmst->ihead_lnum   = cpu_to_le32(main_first + DEFAULT_IDX_LEB);\n\tmst->ihead_offs   = cpu_to_le32(ALIGN(tmp, c->min_io_size));\n\tmst->index_size   = cpu_to_le64(ALIGN(tmp, 8));\n\tmst->lpt_lnum     = cpu_to_le32(c->lpt_lnum);\n\tmst->lpt_offs     = cpu_to_le32(c->lpt_offs);\n\tmst->nhead_lnum   = cpu_to_le32(c->nhead_lnum);\n\tmst->nhead_offs   = cpu_to_le32(c->nhead_offs);\n\tmst->ltab_lnum    = cpu_to_le32(c->ltab_lnum);\n\tmst->ltab_offs    = cpu_to_le32(c->ltab_offs);\n\tmst->lsave_lnum   = cpu_to_le32(c->lsave_lnum);\n\tmst->lsave_offs   = cpu_to_le32(c->lsave_offs);\n\tmst->lscan_lnum   = cpu_to_le32(main_first);\n\tmst->empty_lebs   = cpu_to_le32(main_lebs - 2);\n\tmst->idx_lebs     = cpu_to_le32(1);\n\tmst->leb_cnt      = cpu_to_le32(c->leb_cnt);\n\tubifs_copy_hash(c, hash_lpt, mst->hash_lpt);\n\n\t \n\ttmp64 = main_bytes;\n\ttmp64 -= ALIGN(ubifs_idx_node_sz(c, 1), c->min_io_size);\n\ttmp64 -= ALIGN(UBIFS_INO_NODE_SZ, c->min_io_size);\n\tmst->total_free = cpu_to_le64(tmp64);\n\n\ttmp64 = ALIGN(ubifs_idx_node_sz(c, 1), c->min_io_size);\n\tino_waste = ALIGN(UBIFS_INO_NODE_SZ, c->min_io_size) -\n\t\t\t  UBIFS_INO_NODE_SZ;\n\ttmp64 += ino_waste;\n\ttmp64 -= ALIGN(ubifs_idx_node_sz(c, 1), 8);\n\tmst->total_dirty = cpu_to_le64(tmp64);\n\n\t \n\ttmp64 = ((long long)(c->main_lebs - 1) * c->dark_wm);\n\tmst->total_dark = cpu_to_le64(tmp64);\n\n\tmst->total_used = cpu_to_le64(UBIFS_INO_NODE_SZ);\n\n\tdbg_gen(\"default master node created at LEB %d:0\", UBIFS_MST_LNUM);\n\n\t \n\n\tc->key_fmt = UBIFS_SIMPLE_KEY_FMT;\n\tc->key_hash = key_r5_hash;\n\n\tidx->ch.node_type = UBIFS_IDX_NODE;\n\tidx->child_cnt = cpu_to_le16(1);\n\tino_key_init(c, &key, UBIFS_ROOT_INO);\n\tbr = ubifs_idx_branch(c, idx, 0);\n\tkey_write_idx(c, &key, &br->key);\n\tbr->lnum = cpu_to_le32(main_first + DEFAULT_DATA_LEB);\n\tbr->len  = cpu_to_le32(UBIFS_INO_NODE_SZ);\n\n\tdbg_gen(\"default root indexing node created LEB %d:0\",\n\t\tmain_first + DEFAULT_IDX_LEB);\n\n\t \n\n\tino_key_init_flash(c, &ino->key, UBIFS_ROOT_INO);\n\tino->ch.node_type = UBIFS_INO_NODE;\n\tino->creat_sqnum = cpu_to_le64(++c->max_sqnum);\n\tino->nlink = cpu_to_le32(2);\n\n\tktime_get_coarse_real_ts64(&ts);\n\ttmp_le64 = cpu_to_le64(ts.tv_sec);\n\tino->atime_sec   = tmp_le64;\n\tino->ctime_sec   = tmp_le64;\n\tino->mtime_sec   = tmp_le64;\n\tino->atime_nsec  = 0;\n\tino->ctime_nsec  = 0;\n\tino->mtime_nsec  = 0;\n\tino->mode = cpu_to_le32(S_IFDIR | S_IRUGO | S_IWUSR | S_IXUGO);\n\tino->size = cpu_to_le64(UBIFS_INO_NODE_SZ);\n\n\t \n\tino->flags = cpu_to_le32(UBIFS_COMPR_FL);\n\n\tdbg_gen(\"root inode created at LEB %d:0\",\n\t\tmain_first + DEFAULT_DATA_LEB);\n\n\t \n\n\tcs->ch.node_type = UBIFS_CS_NODE;\n\n\terr = ubifs_write_node_hmac(c, sup, UBIFS_SB_NODE_SZ, 0, 0,\n\t\t\t\t    offsetof(struct ubifs_sb_node, hmac));\n\tif (err)\n\t\tgoto out;\n\n\terr = ubifs_write_node(c, ino, UBIFS_INO_NODE_SZ,\n\t\t\t       main_first + DEFAULT_DATA_LEB, 0);\n\tif (err)\n\t\tgoto out;\n\n\tubifs_node_calc_hash(c, ino, hash);\n\tubifs_copy_hash(c, hash, ubifs_branch_hash(c, br));\n\n\terr = ubifs_write_node(c, idx, idx_node_size, main_first + DEFAULT_IDX_LEB, 0);\n\tif (err)\n\t\tgoto out;\n\n\tubifs_node_calc_hash(c, idx, hash);\n\tubifs_copy_hash(c, hash, mst->hash_root_idx);\n\n\terr = ubifs_write_node_hmac(c, mst, UBIFS_MST_NODE_SZ, UBIFS_MST_LNUM, 0,\n\t\toffsetof(struct ubifs_mst_node, hmac));\n\tif (err)\n\t\tgoto out;\n\n\terr = ubifs_write_node_hmac(c, mst, UBIFS_MST_NODE_SZ, UBIFS_MST_LNUM + 1,\n\t\t\t       0, offsetof(struct ubifs_mst_node, hmac));\n\tif (err)\n\t\tgoto out;\n\n\terr = ubifs_write_node(c, cs, UBIFS_CS_NODE_SZ, UBIFS_LOG_LNUM, 0);\n\tif (err)\n\t\tgoto out;\n\n\tubifs_msg(c, \"default file-system created\");\n\n\terr = 0;\nout:\n\tkfree(sup);\n\tkfree(mst);\n\tkfree(idx);\n\tkfree(ino);\n\tkfree(cs);\n\n\treturn err;\n}\n\n \nstatic int validate_sb(struct ubifs_info *c, struct ubifs_sb_node *sup)\n{\n\tlong long max_bytes;\n\tint err = 1, min_leb_cnt;\n\n\tif (!c->key_hash) {\n\t\terr = 2;\n\t\tgoto failed;\n\t}\n\n\tif (sup->key_fmt != UBIFS_SIMPLE_KEY_FMT) {\n\t\terr = 3;\n\t\tgoto failed;\n\t}\n\n\tif (le32_to_cpu(sup->min_io_size) != c->min_io_size) {\n\t\tubifs_err(c, \"min. I/O unit mismatch: %d in superblock, %d real\",\n\t\t\t  le32_to_cpu(sup->min_io_size), c->min_io_size);\n\t\tgoto failed;\n\t}\n\n\tif (le32_to_cpu(sup->leb_size) != c->leb_size) {\n\t\tubifs_err(c, \"LEB size mismatch: %d in superblock, %d real\",\n\t\t\t  le32_to_cpu(sup->leb_size), c->leb_size);\n\t\tgoto failed;\n\t}\n\n\tif (c->log_lebs < UBIFS_MIN_LOG_LEBS ||\n\t    c->lpt_lebs < UBIFS_MIN_LPT_LEBS ||\n\t    c->orph_lebs < UBIFS_MIN_ORPH_LEBS ||\n\t    c->main_lebs < UBIFS_MIN_MAIN_LEBS) {\n\t\terr = 4;\n\t\tgoto failed;\n\t}\n\n\t \n\tmin_leb_cnt = UBIFS_SB_LEBS + UBIFS_MST_LEBS + c->log_lebs;\n\tmin_leb_cnt += c->lpt_lebs + c->orph_lebs + c->jhead_cnt + 6;\n\n\tif (c->leb_cnt < min_leb_cnt || c->leb_cnt > c->vi.size) {\n\t\tubifs_err(c, \"bad LEB count: %d in superblock, %d on UBI volume, %d minimum required\",\n\t\t\t  c->leb_cnt, c->vi.size, min_leb_cnt);\n\t\tgoto failed;\n\t}\n\n\tif (c->max_leb_cnt < c->leb_cnt) {\n\t\tubifs_err(c, \"max. LEB count %d less than LEB count %d\",\n\t\t\t  c->max_leb_cnt, c->leb_cnt);\n\t\tgoto failed;\n\t}\n\n\tif (c->main_lebs < UBIFS_MIN_MAIN_LEBS) {\n\t\tubifs_err(c, \"too few main LEBs count %d, must be at least %d\",\n\t\t\t  c->main_lebs, UBIFS_MIN_MAIN_LEBS);\n\t\tgoto failed;\n\t}\n\n\tmax_bytes = (long long)c->leb_size * UBIFS_MIN_BUD_LEBS;\n\tif (c->max_bud_bytes < max_bytes) {\n\t\tubifs_err(c, \"too small journal (%lld bytes), must be at least %lld bytes\",\n\t\t\t  c->max_bud_bytes, max_bytes);\n\t\tgoto failed;\n\t}\n\n\tmax_bytes = (long long)c->leb_size * c->main_lebs;\n\tif (c->max_bud_bytes > max_bytes) {\n\t\tubifs_err(c, \"too large journal size (%lld bytes), only %lld bytes available in the main area\",\n\t\t\t  c->max_bud_bytes, max_bytes);\n\t\tgoto failed;\n\t}\n\n\tif (c->jhead_cnt < NONDATA_JHEADS_CNT + 1 ||\n\t    c->jhead_cnt > NONDATA_JHEADS_CNT + UBIFS_MAX_JHEADS) {\n\t\terr = 9;\n\t\tgoto failed;\n\t}\n\n\tif (c->fanout < UBIFS_MIN_FANOUT ||\n\t    ubifs_idx_node_sz(c, c->fanout) > c->leb_size) {\n\t\terr = 10;\n\t\tgoto failed;\n\t}\n\n\tif (c->lsave_cnt < 0 || (c->lsave_cnt > DEFAULT_LSAVE_CNT &&\n\t    c->lsave_cnt > c->max_leb_cnt - UBIFS_SB_LEBS - UBIFS_MST_LEBS -\n\t    c->log_lebs - c->lpt_lebs - c->orph_lebs)) {\n\t\terr = 11;\n\t\tgoto failed;\n\t}\n\n\tif (UBIFS_SB_LEBS + UBIFS_MST_LEBS + c->log_lebs + c->lpt_lebs +\n\t    c->orph_lebs + c->main_lebs != c->leb_cnt) {\n\t\terr = 12;\n\t\tgoto failed;\n\t}\n\n\tif (c->default_compr >= UBIFS_COMPR_TYPES_CNT) {\n\t\terr = 13;\n\t\tgoto failed;\n\t}\n\n\tif (c->rp_size < 0 || max_bytes < c->rp_size) {\n\t\terr = 14;\n\t\tgoto failed;\n\t}\n\n\tif (le32_to_cpu(sup->time_gran) > 1000000000 ||\n\t    le32_to_cpu(sup->time_gran) < 1) {\n\t\terr = 15;\n\t\tgoto failed;\n\t}\n\n\tif (!c->double_hash && c->fmt_version >= 5) {\n\t\terr = 16;\n\t\tgoto failed;\n\t}\n\n\tif (c->encrypted && c->fmt_version < 5) {\n\t\terr = 17;\n\t\tgoto failed;\n\t}\n\n\treturn 0;\n\nfailed:\n\tubifs_err(c, \"bad superblock, error %d\", err);\n\tubifs_dump_node(c, sup, ALIGN(UBIFS_SB_NODE_SZ, c->min_io_size));\n\treturn -EINVAL;\n}\n\n \nstatic struct ubifs_sb_node *ubifs_read_sb_node(struct ubifs_info *c)\n{\n\tstruct ubifs_sb_node *sup;\n\tint err;\n\n\tsup = kmalloc(ALIGN(UBIFS_SB_NODE_SZ, c->min_io_size), GFP_NOFS);\n\tif (!sup)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = ubifs_read_node(c, sup, UBIFS_SB_NODE, UBIFS_SB_NODE_SZ,\n\t\t\t      UBIFS_SB_LNUM, 0);\n\tif (err) {\n\t\tkfree(sup);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn sup;\n}\n\nstatic int authenticate_sb_node(struct ubifs_info *c,\n\t\t\t\tconst struct ubifs_sb_node *sup)\n{\n\tunsigned int sup_flags = le32_to_cpu(sup->flags);\n\tu8 hmac_wkm[UBIFS_HMAC_ARR_SZ];\n\tint authenticated = !!(sup_flags & UBIFS_FLG_AUTHENTICATION);\n\tint hash_algo;\n\tint err;\n\n\tif (c->authenticated && !authenticated) {\n\t\tubifs_err(c, \"authenticated FS forced, but found FS without authentication\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!c->authenticated && authenticated) {\n\t\tubifs_err(c, \"authenticated FS found, but no key given\");\n\t\treturn -EINVAL;\n\t}\n\n\tubifs_msg(c, \"Mounting in %sauthenticated mode\",\n\t\t  c->authenticated ? \"\" : \"un\");\n\n\tif (!c->authenticated)\n\t\treturn 0;\n\n\tif (!IS_ENABLED(CONFIG_UBIFS_FS_AUTHENTICATION))\n\t\treturn -EOPNOTSUPP;\n\n\thash_algo = le16_to_cpu(sup->hash_algo);\n\tif (hash_algo >= HASH_ALGO__LAST) {\n\t\tubifs_err(c, \"superblock uses unknown hash algo %d\",\n\t\t\t  hash_algo);\n\t\treturn -EINVAL;\n\t}\n\n\tif (strcmp(hash_algo_name[hash_algo], c->auth_hash_name)) {\n\t\tubifs_err(c, \"This filesystem uses %s for hashing,\"\n\t\t\t     \" but %s is specified\", hash_algo_name[hash_algo],\n\t\t\t     c->auth_hash_name);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (ubifs_hmac_zero(c, sup->hmac)) {\n\t\terr = ubifs_sb_verify_signature(c, sup);\n\t} else {\n\t\terr = ubifs_hmac_wkm(c, hmac_wkm);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (ubifs_check_hmac(c, hmac_wkm, sup->hmac_wkm)) {\n\t\t\tubifs_err(c, \"provided key does not fit\");\n\t\t\treturn -ENOKEY;\n\t\t}\n\t\terr = ubifs_node_verify_hmac(c, sup, sizeof(*sup),\n\t\t\t\t\t     offsetof(struct ubifs_sb_node,\n\t\t\t\t\t\t      hmac));\n\t}\n\n\tif (err)\n\t\tubifs_err(c, \"Failed to authenticate superblock: %d\", err);\n\n\treturn err;\n}\n\n \nint ubifs_write_sb_node(struct ubifs_info *c, struct ubifs_sb_node *sup)\n{\n\tint len = ALIGN(UBIFS_SB_NODE_SZ, c->min_io_size);\n\tint err;\n\n\terr = ubifs_prepare_node_hmac(c, sup, UBIFS_SB_NODE_SZ,\n\t\t\t\t      offsetof(struct ubifs_sb_node, hmac), 1);\n\tif (err)\n\t\treturn err;\n\n\treturn ubifs_leb_change(c, UBIFS_SB_LNUM, sup, len);\n}\n\n \nint ubifs_read_superblock(struct ubifs_info *c)\n{\n\tint err, sup_flags;\n\tstruct ubifs_sb_node *sup;\n\n\tif (c->empty) {\n\t\terr = create_default_filesystem(c);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tsup = ubifs_read_sb_node(c);\n\tif (IS_ERR(sup))\n\t\treturn PTR_ERR(sup);\n\n\tc->sup_node = sup;\n\n\tc->fmt_version = le32_to_cpu(sup->fmt_version);\n\tc->ro_compat_version = le32_to_cpu(sup->ro_compat_version);\n\n\t \n\tif (c->fmt_version > UBIFS_FORMAT_VERSION) {\n\t\tubifs_assert(c, !c->ro_media || c->ro_mount);\n\t\tif (!c->ro_mount ||\n\t\t    c->ro_compat_version > UBIFS_RO_COMPAT_VERSION) {\n\t\t\tubifs_err(c, \"on-flash format version is w%d/r%d, but software only supports up to version w%d/r%d\",\n\t\t\t\t  c->fmt_version, c->ro_compat_version,\n\t\t\t\t  UBIFS_FORMAT_VERSION,\n\t\t\t\t  UBIFS_RO_COMPAT_VERSION);\n\t\t\tif (c->ro_compat_version <= UBIFS_RO_COMPAT_VERSION) {\n\t\t\t\tubifs_msg(c, \"only R/O mounting is possible\");\n\t\t\t\terr = -EROFS;\n\t\t\t} else\n\t\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tc->rw_incompat = 1;\n\t}\n\n\tif (c->fmt_version < 3) {\n\t\tubifs_err(c, \"on-flash format version %d is not supported\",\n\t\t\t  c->fmt_version);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tswitch (sup->key_hash) {\n\tcase UBIFS_KEY_HASH_R5:\n\t\tc->key_hash = key_r5_hash;\n\t\tc->key_hash_type = UBIFS_KEY_HASH_R5;\n\t\tbreak;\n\n\tcase UBIFS_KEY_HASH_TEST:\n\t\tc->key_hash = key_test_hash;\n\t\tc->key_hash_type = UBIFS_KEY_HASH_TEST;\n\t\tbreak;\n\t}\n\n\tc->key_fmt = sup->key_fmt;\n\n\tswitch (c->key_fmt) {\n\tcase UBIFS_SIMPLE_KEY_FMT:\n\t\tc->key_len = UBIFS_SK_LEN;\n\t\tbreak;\n\tdefault:\n\t\tubifs_err(c, \"unsupported key format\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tc->leb_cnt       = le32_to_cpu(sup->leb_cnt);\n\tc->max_leb_cnt   = le32_to_cpu(sup->max_leb_cnt);\n\tc->max_bud_bytes = le64_to_cpu(sup->max_bud_bytes);\n\tc->log_lebs      = le32_to_cpu(sup->log_lebs);\n\tc->lpt_lebs      = le32_to_cpu(sup->lpt_lebs);\n\tc->orph_lebs     = le32_to_cpu(sup->orph_lebs);\n\tc->jhead_cnt     = le32_to_cpu(sup->jhead_cnt) + NONDATA_JHEADS_CNT;\n\tc->fanout        = le32_to_cpu(sup->fanout);\n\tc->lsave_cnt     = le32_to_cpu(sup->lsave_cnt);\n\tc->rp_size       = le64_to_cpu(sup->rp_size);\n\tc->rp_uid        = make_kuid(&init_user_ns, le32_to_cpu(sup->rp_uid));\n\tc->rp_gid        = make_kgid(&init_user_ns, le32_to_cpu(sup->rp_gid));\n\tsup_flags        = le32_to_cpu(sup->flags);\n\tif (!c->mount_opts.override_compr)\n\t\tc->default_compr = le16_to_cpu(sup->default_compr);\n\n\tc->vfs_sb->s_time_gran = le32_to_cpu(sup->time_gran);\n\tmemcpy(&c->uuid, &sup->uuid, 16);\n\tc->big_lpt = !!(sup_flags & UBIFS_FLG_BIGLPT);\n\tc->space_fixup = !!(sup_flags & UBIFS_FLG_SPACE_FIXUP);\n\tc->double_hash = !!(sup_flags & UBIFS_FLG_DOUBLE_HASH);\n\tc->encrypted = !!(sup_flags & UBIFS_FLG_ENCRYPTION);\n\n\terr = authenticate_sb_node(c, sup);\n\tif (err)\n\t\tgoto out;\n\n\tif ((sup_flags & ~UBIFS_FLG_MASK) != 0) {\n\t\tubifs_err(c, \"Unknown feature flags found: %#x\",\n\t\t\t  sup_flags & ~UBIFS_FLG_MASK);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!IS_ENABLED(CONFIG_FS_ENCRYPTION) && c->encrypted) {\n\t\tubifs_err(c, \"file system contains encrypted files but UBIFS\"\n\t\t\t     \" was built without crypto support.\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (c->leb_cnt < c->vi.size && c->leb_cnt < c->max_leb_cnt) {\n\t\tint old_leb_cnt = c->leb_cnt;\n\n\t\tc->leb_cnt = min_t(int, c->max_leb_cnt, c->vi.size);\n\t\tsup->leb_cnt = cpu_to_le32(c->leb_cnt);\n\n\t\tc->superblock_need_write = 1;\n\n\t\tdbg_mnt(\"Auto resizing from %d LEBs to %d LEBs\",\n\t\t\told_leb_cnt, c->leb_cnt);\n\t}\n\n\tc->log_bytes = (long long)c->log_lebs * c->leb_size;\n\tc->log_last = UBIFS_LOG_LNUM + c->log_lebs - 1;\n\tc->lpt_first = UBIFS_LOG_LNUM + c->log_lebs;\n\tc->lpt_last = c->lpt_first + c->lpt_lebs - 1;\n\tc->orph_first = c->lpt_last + 1;\n\tc->orph_last = c->orph_first + c->orph_lebs - 1;\n\tc->main_lebs = c->leb_cnt - UBIFS_SB_LEBS - UBIFS_MST_LEBS;\n\tc->main_lebs -= c->log_lebs + c->lpt_lebs + c->orph_lebs;\n\tc->main_first = c->leb_cnt - c->main_lebs;\n\n\terr = validate_sb(c, sup);\nout:\n\treturn err;\n}\n\n \nstatic int fixup_leb(struct ubifs_info *c, int lnum, int len)\n{\n\tint err;\n\n\tubifs_assert(c, len >= 0);\n\tubifs_assert(c, len % c->min_io_size == 0);\n\tubifs_assert(c, len < c->leb_size);\n\n\tif (len == 0) {\n\t\tdbg_mnt(\"unmap empty LEB %d\", lnum);\n\t\treturn ubifs_leb_unmap(c, lnum);\n\t}\n\n\tdbg_mnt(\"fixup LEB %d, data len %d\", lnum, len);\n\terr = ubifs_leb_read(c, lnum, c->sbuf, 0, len, 1);\n\tif (err)\n\t\treturn err;\n\n\treturn ubifs_leb_change(c, lnum, c->sbuf, len);\n}\n\n \nstatic int fixup_free_space(struct ubifs_info *c)\n{\n\tint lnum, err = 0;\n\tstruct ubifs_lprops *lprops;\n\n\tubifs_get_lprops(c);\n\n\t \n\tfor (lnum = UBIFS_MST_LNUM; lnum < UBIFS_LOG_LNUM; lnum++) {\n\t\terr = fixup_leb(c, lnum, c->mst_offs + c->mst_node_alsz);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\t \n\tlnum = ubifs_next_log_lnum(c, c->lhead_lnum);\n\twhile (lnum != c->ltail_lnum) {\n\t\terr = fixup_leb(c, lnum, 0);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tlnum = ubifs_next_log_lnum(c, lnum);\n\t}\n\n\t \n\terr = fixup_leb(c, c->lhead_lnum,\n\t\t\tALIGN(UBIFS_CS_NODE_SZ, c->min_io_size));\n\tif (err)\n\t\tgoto out;\n\n\t \n\tfor (lnum = c->lpt_first; lnum <= c->lpt_last; lnum++) {\n\t\tint free = c->ltab[lnum - c->lpt_first].free;\n\n\t\tif (free > 0) {\n\t\t\terr = fixup_leb(c, lnum, c->leb_size - free);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tfor (lnum = c->orph_first; lnum <= c->orph_last; lnum++) {\n\t\terr = fixup_leb(c, lnum, 0);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\t \n\tfor (lnum = c->main_first; lnum < c->leb_cnt; lnum++) {\n\t\tlprops = ubifs_lpt_lookup(c, lnum);\n\t\tif (IS_ERR(lprops)) {\n\t\t\terr = PTR_ERR(lprops);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (lprops->free > 0) {\n\t\t\terr = fixup_leb(c, lnum, c->leb_size - lprops->free);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tubifs_release_lprops(c);\n\treturn err;\n}\n\n \nint ubifs_fixup_free_space(struct ubifs_info *c)\n{\n\tint err;\n\tstruct ubifs_sb_node *sup = c->sup_node;\n\n\tubifs_assert(c, c->space_fixup);\n\tubifs_assert(c, !c->ro_mount);\n\n\tubifs_msg(c, \"start fixing up free space\");\n\n\terr = fixup_free_space(c);\n\tif (err)\n\t\treturn err;\n\n\t \n\tc->space_fixup = 0;\n\tsup->flags &= cpu_to_le32(~UBIFS_FLG_SPACE_FIXUP);\n\n\tc->superblock_need_write = 1;\n\n\tubifs_msg(c, \"free space fixup complete\");\n\treturn err;\n}\n\nint ubifs_enable_encryption(struct ubifs_info *c)\n{\n\tint err;\n\tstruct ubifs_sb_node *sup = c->sup_node;\n\n\tif (!IS_ENABLED(CONFIG_FS_ENCRYPTION))\n\t\treturn -EOPNOTSUPP;\n\n\tif (c->encrypted)\n\t\treturn 0;\n\n\tif (c->ro_mount || c->ro_media)\n\t\treturn -EROFS;\n\n\tif (c->fmt_version < 5) {\n\t\tubifs_err(c, \"on-flash format version 5 is needed for encryption\");\n\t\treturn -EINVAL;\n\t}\n\n\tsup->flags |= cpu_to_le32(UBIFS_FLG_ENCRYPTION);\n\n\terr = ubifs_write_sb_node(c, sup);\n\tif (!err)\n\t\tc->encrypted = 1;\n\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}