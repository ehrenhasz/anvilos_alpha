{
  "module_name": "tnc_commit.c",
  "hash_id": "7047bfcc5eecaef421b77b9b2ccff03bab8ec9393b39fb09e2aa0cc80726491a",
  "original_prompt": "Ingested from linux-6.6.14/fs/ubifs/tnc_commit.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/random.h>\n#include \"ubifs.h\"\n\n \nstatic int make_idx_node(struct ubifs_info *c, struct ubifs_idx_node *idx,\n\t\t\t struct ubifs_znode *znode, int lnum, int offs, int len)\n{\n\tstruct ubifs_znode *zp;\n\tu8 hash[UBIFS_HASH_ARR_SZ];\n\tint i, err;\n\n\t \n\tidx->ch.node_type = UBIFS_IDX_NODE;\n\tidx->child_cnt = cpu_to_le16(znode->child_cnt);\n\tidx->level = cpu_to_le16(znode->level);\n\tfor (i = 0; i < znode->child_cnt; i++) {\n\t\tstruct ubifs_branch *br = ubifs_idx_branch(c, idx, i);\n\t\tstruct ubifs_zbranch *zbr = &znode->zbranch[i];\n\n\t\tkey_write_idx(c, &zbr->key, &br->key);\n\t\tbr->lnum = cpu_to_le32(zbr->lnum);\n\t\tbr->offs = cpu_to_le32(zbr->offs);\n\t\tbr->len = cpu_to_le32(zbr->len);\n\t\tubifs_copy_hash(c, zbr->hash, ubifs_branch_hash(c, br));\n\t\tif (!zbr->lnum || !zbr->len) {\n\t\t\tubifs_err(c, \"bad ref in znode\");\n\t\t\tubifs_dump_znode(c, znode);\n\t\t\tif (zbr->znode)\n\t\t\t\tubifs_dump_znode(c, zbr->znode);\n\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tubifs_prepare_node(c, idx, len, 0);\n\tubifs_node_calc_hash(c, idx, hash);\n\n\tznode->lnum = lnum;\n\tznode->offs = offs;\n\tznode->len = len;\n\n\terr = insert_old_idx_znode(c, znode);\n\n\t \n\tzp = znode->parent;\n\tif (zp) {\n\t\tstruct ubifs_zbranch *zbr;\n\n\t\tzbr = &zp->zbranch[znode->iip];\n\t\tzbr->lnum = lnum;\n\t\tzbr->offs = offs;\n\t\tzbr->len = len;\n\t\tubifs_copy_hash(c, hash, zbr->hash);\n\t} else {\n\t\tc->zroot.lnum = lnum;\n\t\tc->zroot.offs = offs;\n\t\tc->zroot.len = len;\n\t\tubifs_copy_hash(c, hash, c->zroot.hash);\n\t}\n\tc->calc_idx_sz += ALIGN(len, 8);\n\n\tatomic_long_dec(&c->dirty_zn_cnt);\n\n\tubifs_assert(c, ubifs_zn_dirty(znode));\n\tubifs_assert(c, ubifs_zn_cow(znode));\n\n\t \n\t__clear_bit(DIRTY_ZNODE, &znode->flags);\n\t__clear_bit(COW_ZNODE, &znode->flags);\n\n\treturn err;\n}\n\n \nstatic int fill_gap(struct ubifs_info *c, int lnum, int gap_start, int gap_end,\n\t\t    int *dirt)\n{\n\tint len, gap_remains, gap_pos, written, pad_len;\n\n\tubifs_assert(c, (gap_start & 7) == 0);\n\tubifs_assert(c, (gap_end & 7) == 0);\n\tubifs_assert(c, gap_end >= gap_start);\n\n\tgap_remains = gap_end - gap_start;\n\tif (!gap_remains)\n\t\treturn 0;\n\tgap_pos = gap_start;\n\twritten = 0;\n\twhile (c->enext) {\n\t\tlen = ubifs_idx_node_sz(c, c->enext->child_cnt);\n\t\tif (len < gap_remains) {\n\t\t\tstruct ubifs_znode *znode = c->enext;\n\t\t\tconst int alen = ALIGN(len, 8);\n\t\t\tint err;\n\n\t\t\tubifs_assert(c, alen <= gap_remains);\n\t\t\terr = make_idx_node(c, c->ileb_buf + gap_pos, znode,\n\t\t\t\t\t    lnum, gap_pos, len);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tgap_remains -= alen;\n\t\t\tgap_pos += alen;\n\t\t\tc->enext = znode->cnext;\n\t\t\tif (c->enext == c->cnext)\n\t\t\t\tc->enext = NULL;\n\t\t\twritten += 1;\n\t\t} else\n\t\t\tbreak;\n\t}\n\tif (gap_end == c->leb_size) {\n\t\tc->ileb_len = ALIGN(gap_pos, c->min_io_size);\n\t\t \n\t\tpad_len = c->ileb_len - gap_pos;\n\t} else\n\t\t \n\t\tpad_len = gap_remains;\n\tdbg_gc(\"LEB %d:%d to %d len %d nodes written %d wasted bytes %d\",\n\t       lnum, gap_start, gap_end, gap_end - gap_start, written, pad_len);\n\tubifs_pad(c, c->ileb_buf + gap_pos, pad_len);\n\t*dirt += pad_len;\n\treturn written;\n}\n\n \nstatic int find_old_idx(struct ubifs_info *c, int lnum, int offs)\n{\n\tstruct ubifs_old_idx *o;\n\tstruct rb_node *p;\n\n\tp = c->old_idx.rb_node;\n\twhile (p) {\n\t\to = rb_entry(p, struct ubifs_old_idx, rb);\n\t\tif (lnum < o->lnum)\n\t\t\tp = p->rb_left;\n\t\telse if (lnum > o->lnum)\n\t\t\tp = p->rb_right;\n\t\telse if (offs < o->offs)\n\t\t\tp = p->rb_left;\n\t\telse if (offs > o->offs)\n\t\t\tp = p->rb_right;\n\t\telse\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \nstatic int is_idx_node_in_use(struct ubifs_info *c, union ubifs_key *key,\n\t\t\t      int level, int lnum, int offs)\n{\n\tint ret;\n\n\tret = is_idx_node_in_tnc(c, key, level, lnum, offs);\n\tif (ret < 0)\n\t\treturn ret;  \n\tif (ret == 0)\n\t\tif (find_old_idx(c, lnum, offs))\n\t\t\treturn 1;\n\treturn ret;\n}\n\n \nstatic int layout_leb_in_gaps(struct ubifs_info *c, int p)\n{\n\tstruct ubifs_scan_leb *sleb;\n\tstruct ubifs_scan_node *snod;\n\tint lnum, dirt = 0, gap_start, gap_end, err, written, tot_written;\n\n\ttot_written = 0;\n\t \n\tlnum = ubifs_find_dirty_idx_leb(c);\n\tif (lnum < 0)\n\t\t \n\t\treturn lnum;  \n\tc->gap_lebs[p] = lnum;\n\tdbg_gc(\"LEB %d\", lnum);\n\t \n\tsleb = ubifs_scan(c, lnum, 0, c->ileb_buf, 0);\n\tc->ileb_len = 0;\n\tif (IS_ERR(sleb))\n\t\treturn PTR_ERR(sleb);\n\tgap_start = 0;\n\tlist_for_each_entry(snod, &sleb->nodes, list) {\n\t\tstruct ubifs_idx_node *idx;\n\t\tint in_use, level;\n\n\t\tubifs_assert(c, snod->type == UBIFS_IDX_NODE);\n\t\tidx = snod->node;\n\t\tkey_read(c, ubifs_idx_key(c, idx), &snod->key);\n\t\tlevel = le16_to_cpu(idx->level);\n\t\t \n\t\tin_use = is_idx_node_in_use(c, &snod->key, level, lnum,\n\t\t\t\t\t    snod->offs);\n\t\tif (in_use < 0) {\n\t\t\tubifs_scan_destroy(sleb);\n\t\t\treturn in_use;  \n\t\t}\n\t\tif (in_use) {\n\t\t\tif (in_use == 1)\n\t\t\t\tdirt += ALIGN(snod->len, 8);\n\t\t\t \n\t\t\tgap_end = snod->offs;\n\t\t\t \n\t\t\twritten = fill_gap(c, lnum, gap_start, gap_end, &dirt);\n\t\t\tif (written < 0) {\n\t\t\t\tubifs_scan_destroy(sleb);\n\t\t\t\treturn written;  \n\t\t\t}\n\t\t\ttot_written += written;\n\t\t\tgap_start = ALIGN(snod->offs + snod->len, 8);\n\t\t}\n\t}\n\tubifs_scan_destroy(sleb);\n\tc->ileb_len = c->leb_size;\n\tgap_end = c->leb_size;\n\t \n\twritten = fill_gap(c, lnum, gap_start, gap_end, &dirt);\n\tif (written < 0)\n\t\treturn written;  \n\ttot_written += written;\n\tif (tot_written == 0) {\n\t\tstruct ubifs_lprops lp;\n\n\t\tdbg_gc(\"LEB %d wrote %d index nodes\", lnum, tot_written);\n\t\terr = ubifs_read_one_lp(c, lnum, &lp);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (lp.free == c->leb_size) {\n\t\t\t \n\t\t\terr = ubifs_change_one_lp(c, lnum,\n\t\t\t\t\t\t  c->leb_size - c->ileb_len,\n\t\t\t\t\t\t  dirt, 0, 0, 0);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\treturn 0;\n\t}\n\terr = ubifs_change_one_lp(c, lnum, c->leb_size - c->ileb_len, dirt,\n\t\t\t\t  0, 0, 0);\n\tif (err)\n\t\treturn err;\n\terr = ubifs_leb_change(c, lnum, c->ileb_buf, c->ileb_len);\n\tif (err)\n\t\treturn err;\n\tdbg_gc(\"LEB %d wrote %d index nodes\", lnum, tot_written);\n\treturn tot_written;\n}\n\n \nstatic int get_leb_cnt(struct ubifs_info *c, int cnt)\n{\n\tint d;\n\n\t \n\tcnt -= (c->leb_size - c->ihead_offs) / c->max_idx_node_sz;\n\tif (cnt < 0)\n\t\tcnt = 0;\n\td = c->leb_size / c->max_idx_node_sz;\n\treturn DIV_ROUND_UP(cnt, d);\n}\n\n \nstatic int layout_in_gaps(struct ubifs_info *c, int cnt)\n{\n\tint err, leb_needed_cnt, written, p = 0, old_idx_lebs, *gap_lebs;\n\n\tdbg_gc(\"%d znodes to write\", cnt);\n\n\tc->gap_lebs = kmalloc_array(c->lst.idx_lebs + 1, sizeof(int),\n\t\t\t\t    GFP_NOFS);\n\tif (!c->gap_lebs)\n\t\treturn -ENOMEM;\n\n\told_idx_lebs = c->lst.idx_lebs;\n\tdo {\n\t\tubifs_assert(c, p < c->lst.idx_lebs);\n\t\twritten = layout_leb_in_gaps(c, p);\n\t\tif (written < 0) {\n\t\t\terr = written;\n\t\t\tif (err != -ENOSPC) {\n\t\t\t\tkfree(c->gap_lebs);\n\t\t\t\tc->gap_lebs = NULL;\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tif (!dbg_is_chk_index(c)) {\n\t\t\t\t \n\t\t\t\tubifs_warn(c, \"out of space\");\n\t\t\t\tubifs_dump_budg(c, &c->bi);\n\t\t\t\tubifs_dump_lprops(c);\n\t\t\t}\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t\tp++;\n\t\tcnt -= written;\n\t\tleb_needed_cnt = get_leb_cnt(c, cnt);\n\t\tdbg_gc(\"%d znodes remaining, need %d LEBs, have %d\", cnt,\n\t\t       leb_needed_cnt, c->ileb_cnt);\n\t\t \n\t\tif (leb_needed_cnt > c->ileb_cnt && p >= old_idx_lebs &&\n\t\t    old_idx_lebs < c->lst.idx_lebs) {\n\t\t\told_idx_lebs = c->lst.idx_lebs;\n\t\t\tgap_lebs = krealloc(c->gap_lebs, sizeof(int) *\n\t\t\t\t\t       (old_idx_lebs + 1), GFP_NOFS);\n\t\t\tif (!gap_lebs) {\n\t\t\t\tkfree(c->gap_lebs);\n\t\t\t\tc->gap_lebs = NULL;\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tc->gap_lebs = gap_lebs;\n\t\t}\n\t} while (leb_needed_cnt > c->ileb_cnt);\n\n\tc->gap_lebs[p] = -1;\n\treturn 0;\n}\n\n \nstatic int layout_in_empty_space(struct ubifs_info *c)\n{\n\tstruct ubifs_znode *znode, *cnext, *zp;\n\tint lnum, offs, len, next_len, buf_len, buf_offs, used, avail;\n\tint wlen, blen, err;\n\n\tcnext = c->enext;\n\tif (!cnext)\n\t\treturn 0;\n\n\tlnum = c->ihead_lnum;\n\tbuf_offs = c->ihead_offs;\n\n\tbuf_len = ubifs_idx_node_sz(c, c->fanout);\n\tbuf_len = ALIGN(buf_len, c->min_io_size);\n\tused = 0;\n\tavail = buf_len;\n\n\t \n\tnext_len = ubifs_idx_node_sz(c, cnext->child_cnt);\n\tif (buf_offs + next_len > c->leb_size)\n\t\tlnum = -1;\n\n\twhile (1) {\n\t\tznode = cnext;\n\n\t\tlen = ubifs_idx_node_sz(c, znode->child_cnt);\n\n\t\t \n\t\tif (lnum == -1) {\n\t\t\tif (c->ileb_nxt >= c->ileb_cnt) {\n\t\t\t\tubifs_err(c, \"out of space\");\n\t\t\t\treturn -ENOSPC;\n\t\t\t}\n\t\t\tlnum = c->ilebs[c->ileb_nxt++];\n\t\t\tbuf_offs = 0;\n\t\t\tused = 0;\n\t\t\tavail = buf_len;\n\t\t}\n\n\t\toffs = buf_offs + used;\n\n\t\tznode->lnum = lnum;\n\t\tznode->offs = offs;\n\t\tznode->len = len;\n\n\t\t \n\t\tzp = znode->parent;\n\t\tif (zp) {\n\t\t\tstruct ubifs_zbranch *zbr;\n\t\t\tint i;\n\n\t\t\ti = znode->iip;\n\t\t\tzbr = &zp->zbranch[i];\n\t\t\tzbr->lnum = lnum;\n\t\t\tzbr->offs = offs;\n\t\t\tzbr->len = len;\n\t\t} else {\n\t\t\tc->zroot.lnum = lnum;\n\t\t\tc->zroot.offs = offs;\n\t\t\tc->zroot.len = len;\n\t\t}\n\t\tc->calc_idx_sz += ALIGN(len, 8);\n\n\t\t \n\t\tatomic_long_dec(&c->dirty_zn_cnt);\n\n\t\t \n\t\tcnext = znode->cnext;\n\t\tif (cnext == c->cnext)\n\t\t\tnext_len = 0;\n\t\telse\n\t\t\tnext_len = ubifs_idx_node_sz(c, cnext->child_cnt);\n\n\t\t \n\t\twlen = used + len;\n\t\tused += ALIGN(len, 8);\n\t\tavail -= ALIGN(len, 8);\n\n\t\tif (next_len != 0 &&\n\t\t    buf_offs + used + next_len <= c->leb_size &&\n\t\t    avail > 0)\n\t\t\tcontinue;\n\n\t\tif (avail <= 0 && next_len &&\n\t\t    buf_offs + used + next_len <= c->leb_size)\n\t\t\tblen = buf_len;\n\t\telse\n\t\t\tblen = ALIGN(wlen, c->min_io_size);\n\n\t\t \n\t\tbuf_offs += blen;\n\t\tif (next_len) {\n\t\t\tif (buf_offs + next_len > c->leb_size) {\n\t\t\t\terr = ubifs_update_one_lp(c, lnum,\n\t\t\t\t\tc->leb_size - buf_offs, blen - used,\n\t\t\t\t\t0, 0);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t\tlnum = -1;\n\t\t\t}\n\t\t\tused -= blen;\n\t\t\tif (used < 0)\n\t\t\t\tused = 0;\n\t\t\tavail = buf_len - used;\n\t\t\tcontinue;\n\t\t}\n\t\terr = ubifs_update_one_lp(c, lnum, c->leb_size - buf_offs,\n\t\t\t\t\t  blen - used, 0, 0);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\t}\n\n\tc->dbg->new_ihead_lnum = lnum;\n\tc->dbg->new_ihead_offs = buf_offs;\n\n\treturn 0;\n}\n\n \nstatic int layout_commit(struct ubifs_info *c, int no_space, int cnt)\n{\n\tint err;\n\n\tif (no_space) {\n\t\terr = layout_in_gaps(c, cnt);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\terr = layout_in_empty_space(c);\n\treturn err;\n}\n\n \nstatic struct ubifs_znode *find_first_dirty(struct ubifs_znode *znode)\n{\n\tint i, cont;\n\n\tif (!znode)\n\t\treturn NULL;\n\n\twhile (1) {\n\t\tif (znode->level == 0) {\n\t\t\tif (ubifs_zn_dirty(znode))\n\t\t\t\treturn znode;\n\t\t\treturn NULL;\n\t\t}\n\t\tcont = 0;\n\t\tfor (i = 0; i < znode->child_cnt; i++) {\n\t\t\tstruct ubifs_zbranch *zbr = &znode->zbranch[i];\n\n\t\t\tif (zbr->znode && ubifs_zn_dirty(zbr->znode)) {\n\t\t\t\tznode = zbr->znode;\n\t\t\t\tcont = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!cont) {\n\t\t\tif (ubifs_zn_dirty(znode))\n\t\t\t\treturn znode;\n\t\t\treturn NULL;\n\t\t}\n\t}\n}\n\n \nstatic struct ubifs_znode *find_next_dirty(struct ubifs_znode *znode)\n{\n\tint n = znode->iip + 1;\n\n\tznode = znode->parent;\n\tif (!znode)\n\t\treturn NULL;\n\tfor (; n < znode->child_cnt; n++) {\n\t\tstruct ubifs_zbranch *zbr = &znode->zbranch[n];\n\n\t\tif (zbr->znode && ubifs_zn_dirty(zbr->znode))\n\t\t\treturn find_first_dirty(zbr->znode);\n\t}\n\treturn znode;\n}\n\n \nstatic int get_znodes_to_commit(struct ubifs_info *c)\n{\n\tstruct ubifs_znode *znode, *cnext;\n\tint cnt = 0;\n\n\tc->cnext = find_first_dirty(c->zroot.znode);\n\tznode = c->enext = c->cnext;\n\tif (!znode) {\n\t\tdbg_cmt(\"no znodes to commit\");\n\t\treturn 0;\n\t}\n\tcnt += 1;\n\twhile (1) {\n\t\tubifs_assert(c, !ubifs_zn_cow(znode));\n\t\t__set_bit(COW_ZNODE, &znode->flags);\n\t\tznode->alt = 0;\n\t\tcnext = find_next_dirty(znode);\n\t\tif (!cnext) {\n\t\t\tznode->cnext = c->cnext;\n\t\t\tbreak;\n\t\t}\n\t\tznode->cparent = znode->parent;\n\t\tznode->ciip = znode->iip;\n\t\tznode->cnext = cnext;\n\t\tznode = cnext;\n\t\tcnt += 1;\n\t}\n\tdbg_cmt(\"committing %d znodes\", cnt);\n\tubifs_assert(c, cnt == atomic_long_read(&c->dirty_zn_cnt));\n\treturn cnt;\n}\n\n \nstatic int alloc_idx_lebs(struct ubifs_info *c, int cnt)\n{\n\tint i, leb_cnt, lnum;\n\n\tc->ileb_cnt = 0;\n\tc->ileb_nxt = 0;\n\tleb_cnt = get_leb_cnt(c, cnt);\n\tdbg_cmt(\"need about %d empty LEBS for TNC commit\", leb_cnt);\n\tif (!leb_cnt)\n\t\treturn 0;\n\tc->ilebs = kmalloc_array(leb_cnt, sizeof(int), GFP_NOFS);\n\tif (!c->ilebs)\n\t\treturn -ENOMEM;\n\tfor (i = 0; i < leb_cnt; i++) {\n\t\tlnum = ubifs_find_free_leb_for_idx(c);\n\t\tif (lnum < 0)\n\t\t\treturn lnum;\n\t\tc->ilebs[c->ileb_cnt++] = lnum;\n\t\tdbg_cmt(\"LEB %d\", lnum);\n\t}\n\tif (dbg_is_chk_index(c) && !get_random_u32_below(8))\n\t\treturn -ENOSPC;\n\treturn 0;\n}\n\n \nstatic int free_unused_idx_lebs(struct ubifs_info *c)\n{\n\tint i, err = 0, lnum, er;\n\n\tfor (i = c->ileb_nxt; i < c->ileb_cnt; i++) {\n\t\tlnum = c->ilebs[i];\n\t\tdbg_cmt(\"LEB %d\", lnum);\n\t\ter = ubifs_change_one_lp(c, lnum, LPROPS_NC, LPROPS_NC, 0,\n\t\t\t\t\t LPROPS_INDEX | LPROPS_TAKEN, 0);\n\t\tif (!err)\n\t\t\terr = er;\n\t}\n\treturn err;\n}\n\n \nstatic int free_idx_lebs(struct ubifs_info *c)\n{\n\tint err;\n\n\terr = free_unused_idx_lebs(c);\n\tkfree(c->ilebs);\n\tc->ilebs = NULL;\n\treturn err;\n}\n\n \nint ubifs_tnc_start_commit(struct ubifs_info *c, struct ubifs_zbranch *zroot)\n{\n\tint err = 0, cnt;\n\n\tmutex_lock(&c->tnc_mutex);\n\terr = dbg_check_tnc(c, 1);\n\tif (err)\n\t\tgoto out;\n\tcnt = get_znodes_to_commit(c);\n\tif (cnt != 0) {\n\t\tint no_space = 0;\n\n\t\terr = alloc_idx_lebs(c, cnt);\n\t\tif (err == -ENOSPC)\n\t\t\tno_space = 1;\n\t\telse if (err)\n\t\t\tgoto out_free;\n\t\terr = layout_commit(c, no_space, cnt);\n\t\tif (err)\n\t\t\tgoto out_free;\n\t\tubifs_assert(c, atomic_long_read(&c->dirty_zn_cnt) == 0);\n\t\terr = free_unused_idx_lebs(c);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\tdestroy_old_idx(c);\n\tmemcpy(zroot, &c->zroot, sizeof(struct ubifs_zbranch));\n\n\terr = ubifs_save_dirty_idx_lnums(c);\n\tif (err)\n\t\tgoto out;\n\n\tspin_lock(&c->space_lock);\n\t \n\tubifs_assert(c, c->bi.min_idx_lebs == ubifs_calc_min_idx_lebs(c));\n\tc->bi.old_idx_sz = c->calc_idx_sz;\n\tc->bi.uncommitted_idx = 0;\n\tc->bi.min_idx_lebs = ubifs_calc_min_idx_lebs(c);\n\tspin_unlock(&c->space_lock);\n\tmutex_unlock(&c->tnc_mutex);\n\n\tdbg_cmt(\"number of index LEBs %d\", c->lst.idx_lebs);\n\tdbg_cmt(\"size of index %llu\", c->calc_idx_sz);\n\treturn err;\n\nout_free:\n\tfree_idx_lebs(c);\nout:\n\tmutex_unlock(&c->tnc_mutex);\n\treturn err;\n}\n\n \nstatic int write_index(struct ubifs_info *c)\n{\n\tstruct ubifs_idx_node *idx;\n\tstruct ubifs_znode *znode, *cnext;\n\tint i, lnum, offs, len, next_len, buf_len, buf_offs, used;\n\tint avail, wlen, err, lnum_pos = 0, blen, nxt_offs;\n\n\tcnext = c->enext;\n\tif (!cnext)\n\t\treturn 0;\n\n\t \n\tlnum = c->ihead_lnum;\n\tbuf_offs = c->ihead_offs;\n\n\t \n\tbuf_len = ALIGN(c->max_idx_node_sz, c->min_io_size);\n\tused = 0;\n\tavail = buf_len;\n\n\t \n\tnext_len = ubifs_idx_node_sz(c, cnext->child_cnt);\n\tif (buf_offs + next_len > c->leb_size) {\n\t\terr = ubifs_update_one_lp(c, lnum, LPROPS_NC, 0, 0,\n\t\t\t\t\t  LPROPS_TAKEN);\n\t\tif (err)\n\t\t\treturn err;\n\t\tlnum = -1;\n\t}\n\n\twhile (1) {\n\t\tu8 hash[UBIFS_HASH_ARR_SZ];\n\n\t\tcond_resched();\n\n\t\tznode = cnext;\n\t\tidx = c->cbuf + used;\n\n\t\t \n\t\tidx->ch.node_type = UBIFS_IDX_NODE;\n\t\tidx->child_cnt = cpu_to_le16(znode->child_cnt);\n\t\tidx->level = cpu_to_le16(znode->level);\n\t\tfor (i = 0; i < znode->child_cnt; i++) {\n\t\t\tstruct ubifs_branch *br = ubifs_idx_branch(c, idx, i);\n\t\t\tstruct ubifs_zbranch *zbr = &znode->zbranch[i];\n\n\t\t\tkey_write_idx(c, &zbr->key, &br->key);\n\t\t\tbr->lnum = cpu_to_le32(zbr->lnum);\n\t\t\tbr->offs = cpu_to_le32(zbr->offs);\n\t\t\tbr->len = cpu_to_le32(zbr->len);\n\t\t\tubifs_copy_hash(c, zbr->hash, ubifs_branch_hash(c, br));\n\t\t\tif (!zbr->lnum || !zbr->len) {\n\t\t\t\tubifs_err(c, \"bad ref in znode\");\n\t\t\t\tubifs_dump_znode(c, znode);\n\t\t\t\tif (zbr->znode)\n\t\t\t\t\tubifs_dump_znode(c, zbr->znode);\n\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\tlen = ubifs_idx_node_sz(c, znode->child_cnt);\n\t\tubifs_prepare_node(c, idx, len, 0);\n\t\tubifs_node_calc_hash(c, idx, hash);\n\n\t\tmutex_lock(&c->tnc_mutex);\n\n\t\tif (znode->cparent)\n\t\t\tubifs_copy_hash(c, hash,\n\t\t\t\t\tznode->cparent->zbranch[znode->ciip].hash);\n\n\t\tif (znode->parent) {\n\t\t\tif (!ubifs_zn_obsolete(znode))\n\t\t\t\tubifs_copy_hash(c, hash,\n\t\t\t\t\tznode->parent->zbranch[znode->iip].hash);\n\t\t} else {\n\t\t\tubifs_copy_hash(c, hash, c->zroot.hash);\n\t\t}\n\n\t\tmutex_unlock(&c->tnc_mutex);\n\n\t\t \n\t\tif (lnum == -1) {\n\t\t\tlnum = c->ilebs[lnum_pos++];\n\t\t\tbuf_offs = 0;\n\t\t\tused = 0;\n\t\t\tavail = buf_len;\n\t\t}\n\t\toffs = buf_offs + used;\n\n\t\tif (lnum != znode->lnum || offs != znode->offs ||\n\t\t    len != znode->len) {\n\t\t\tubifs_err(c, \"inconsistent znode posn\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tcnext = znode->cnext;\n\n\t\tubifs_assert(c, ubifs_zn_dirty(znode));\n\t\tubifs_assert(c, ubifs_zn_cow(znode));\n\n\t\t \n\t\tclear_bit(DIRTY_ZNODE, &znode->flags);\n\t\tsmp_mb__before_atomic();\n\t\tclear_bit(COW_ZNODE, &znode->flags);\n\t\tsmp_mb__after_atomic();\n\n\t\t \n\n\t\t \n\n\t\t \n\t\twlen = used + len;\n\t\tused += ALIGN(len, 8);\n\t\tavail -= ALIGN(len, 8);\n\n\t\t \n\t\tif (cnext == c->cnext)\n\t\t\tnext_len = 0;\n\t\telse\n\t\t\tnext_len = ubifs_idx_node_sz(c, cnext->child_cnt);\n\n\t\tnxt_offs = buf_offs + used + next_len;\n\t\tif (next_len && nxt_offs <= c->leb_size) {\n\t\t\tif (avail > 0)\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\tblen = buf_len;\n\t\t} else {\n\t\t\twlen = ALIGN(wlen, 8);\n\t\t\tblen = ALIGN(wlen, c->min_io_size);\n\t\t\tubifs_pad(c, c->cbuf + wlen, blen - wlen);\n\t\t}\n\n\t\t \n\t\terr = ubifs_leb_write(c, lnum, c->cbuf, buf_offs, blen);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbuf_offs += blen;\n\t\tif (next_len) {\n\t\t\tif (nxt_offs > c->leb_size) {\n\t\t\t\terr = ubifs_update_one_lp(c, lnum, LPROPS_NC, 0,\n\t\t\t\t\t\t\t  0, LPROPS_TAKEN);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t\tlnum = -1;\n\t\t\t}\n\t\t\tused -= blen;\n\t\t\tif (used < 0)\n\t\t\t\tused = 0;\n\t\t\tavail = buf_len - used;\n\t\t\tmemmove(c->cbuf, c->cbuf + blen, used);\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (lnum != c->dbg->new_ihead_lnum ||\n\t    buf_offs != c->dbg->new_ihead_offs) {\n\t\tubifs_err(c, \"inconsistent ihead\");\n\t\treturn -EINVAL;\n\t}\n\n\tc->ihead_lnum = lnum;\n\tc->ihead_offs = buf_offs;\n\n\treturn 0;\n}\n\n \nstatic void free_obsolete_znodes(struct ubifs_info *c)\n{\n\tstruct ubifs_znode *znode, *cnext;\n\n\tcnext = c->cnext;\n\tdo {\n\t\tznode = cnext;\n\t\tcnext = znode->cnext;\n\t\tif (ubifs_zn_obsolete(znode))\n\t\t\tkfree(znode);\n\t\telse {\n\t\t\tznode->cnext = NULL;\n\t\t\tatomic_long_inc(&c->clean_zn_cnt);\n\t\t\tatomic_long_inc(&ubifs_clean_zn_cnt);\n\t\t}\n\t} while (cnext != c->cnext);\n}\n\n \nstatic int return_gap_lebs(struct ubifs_info *c)\n{\n\tint *p, err;\n\n\tif (!c->gap_lebs)\n\t\treturn 0;\n\n\tdbg_cmt(\"\");\n\tfor (p = c->gap_lebs; *p != -1; p++) {\n\t\terr = ubifs_change_one_lp(c, *p, LPROPS_NC, LPROPS_NC, 0,\n\t\t\t\t\t  LPROPS_TAKEN, 0);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tkfree(c->gap_lebs);\n\tc->gap_lebs = NULL;\n\treturn 0;\n}\n\n \nint ubifs_tnc_end_commit(struct ubifs_info *c)\n{\n\tint err;\n\n\tif (!c->cnext)\n\t\treturn 0;\n\n\terr = return_gap_lebs(c);\n\tif (err)\n\t\treturn err;\n\n\terr = write_index(c);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&c->tnc_mutex);\n\n\tdbg_cmt(\"TNC height is %d\", c->zroot.znode->level + 1);\n\n\tfree_obsolete_znodes(c);\n\n\tc->cnext = NULL;\n\tkfree(c->ilebs);\n\tc->ilebs = NULL;\n\n\tmutex_unlock(&c->tnc_mutex);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}