{
  "module_name": "commit.c",
  "hash_id": "e9a768f020bb592f0a1ef0ba4860386a6522b979460e02d5fdb21e17c01dbd61",
  "original_prompt": "Ingested from linux-6.6.14/fs/ubifs/commit.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/slab.h>\n#include \"ubifs.h\"\n\n \nstatic int nothing_to_commit(struct ubifs_info *c)\n{\n\t \n\tif (c->mounting || c->remounting_rw)\n\t\treturn 0;\n\n\t \n\tif (c->zroot.znode && ubifs_zn_dirty(c->zroot.znode))\n\t\treturn 0;\n\n\t \n\tif (c->nroot && test_bit(DIRTY_CNODE, &c->nroot->flags))\n\t\treturn 0;\n\n\tubifs_assert(c, atomic_long_read(&c->dirty_zn_cnt) == 0);\n\tubifs_assert(c, c->dirty_pn_cnt == 0);\n\tubifs_assert(c, c->dirty_nn_cnt == 0);\n\n\treturn 1;\n}\n\n \nstatic int do_commit(struct ubifs_info *c)\n{\n\tint err, new_ltail_lnum, old_ltail_lnum, i;\n\tstruct ubifs_zbranch zroot;\n\tstruct ubifs_lp_stats lst;\n\n\tdbg_cmt(\"start\");\n\tubifs_assert(c, !c->ro_media && !c->ro_mount);\n\n\tif (c->ro_error) {\n\t\terr = -EROFS;\n\t\tgoto out_up;\n\t}\n\n\tif (nothing_to_commit(c)) {\n\t\tup_write(&c->commit_sem);\n\t\terr = 0;\n\t\tgoto out_cancel;\n\t}\n\n\t \n\tfor (i = 0; i < c->jhead_cnt; i++) {\n\t\terr = ubifs_wbuf_sync(&c->jheads[i].wbuf);\n\t\tif (err)\n\t\t\tgoto out_up;\n\t}\n\n\tc->cmt_no += 1;\n\terr = ubifs_gc_start_commit(c);\n\tif (err)\n\t\tgoto out_up;\n\terr = dbg_check_lprops(c);\n\tif (err)\n\t\tgoto out_up;\n\terr = ubifs_log_start_commit(c, &new_ltail_lnum);\n\tif (err)\n\t\tgoto out_up;\n\terr = ubifs_tnc_start_commit(c, &zroot);\n\tif (err)\n\t\tgoto out_up;\n\terr = ubifs_lpt_start_commit(c);\n\tif (err)\n\t\tgoto out_up;\n\terr = ubifs_orphan_start_commit(c);\n\tif (err)\n\t\tgoto out_up;\n\n\tubifs_get_lp_stats(c, &lst);\n\n\tup_write(&c->commit_sem);\n\n\terr = ubifs_tnc_end_commit(c);\n\tif (err)\n\t\tgoto out;\n\terr = ubifs_lpt_end_commit(c);\n\tif (err)\n\t\tgoto out;\n\terr = ubifs_orphan_end_commit(c);\n\tif (err)\n\t\tgoto out;\n\terr = dbg_check_old_index(c, &zroot);\n\tif (err)\n\t\tgoto out;\n\n\tc->mst_node->cmt_no      = cpu_to_le64(c->cmt_no);\n\tc->mst_node->log_lnum    = cpu_to_le32(new_ltail_lnum);\n\tc->mst_node->root_lnum   = cpu_to_le32(zroot.lnum);\n\tc->mst_node->root_offs   = cpu_to_le32(zroot.offs);\n\tc->mst_node->root_len    = cpu_to_le32(zroot.len);\n\tc->mst_node->ihead_lnum  = cpu_to_le32(c->ihead_lnum);\n\tc->mst_node->ihead_offs  = cpu_to_le32(c->ihead_offs);\n\tc->mst_node->index_size  = cpu_to_le64(c->bi.old_idx_sz);\n\tc->mst_node->lpt_lnum    = cpu_to_le32(c->lpt_lnum);\n\tc->mst_node->lpt_offs    = cpu_to_le32(c->lpt_offs);\n\tc->mst_node->nhead_lnum  = cpu_to_le32(c->nhead_lnum);\n\tc->mst_node->nhead_offs  = cpu_to_le32(c->nhead_offs);\n\tc->mst_node->ltab_lnum   = cpu_to_le32(c->ltab_lnum);\n\tc->mst_node->ltab_offs   = cpu_to_le32(c->ltab_offs);\n\tc->mst_node->lsave_lnum  = cpu_to_le32(c->lsave_lnum);\n\tc->mst_node->lsave_offs  = cpu_to_le32(c->lsave_offs);\n\tc->mst_node->lscan_lnum  = cpu_to_le32(c->lscan_lnum);\n\tc->mst_node->empty_lebs  = cpu_to_le32(lst.empty_lebs);\n\tc->mst_node->idx_lebs    = cpu_to_le32(lst.idx_lebs);\n\tc->mst_node->total_free  = cpu_to_le64(lst.total_free);\n\tc->mst_node->total_dirty = cpu_to_le64(lst.total_dirty);\n\tc->mst_node->total_used  = cpu_to_le64(lst.total_used);\n\tc->mst_node->total_dead  = cpu_to_le64(lst.total_dead);\n\tc->mst_node->total_dark  = cpu_to_le64(lst.total_dark);\n\tif (c->no_orphs)\n\t\tc->mst_node->flags |= cpu_to_le32(UBIFS_MST_NO_ORPHS);\n\telse\n\t\tc->mst_node->flags &= ~cpu_to_le32(UBIFS_MST_NO_ORPHS);\n\n\told_ltail_lnum = c->ltail_lnum;\n\terr = ubifs_log_end_commit(c, new_ltail_lnum);\n\tif (err)\n\t\tgoto out;\n\n\terr = ubifs_log_post_commit(c, old_ltail_lnum);\n\tif (err)\n\t\tgoto out;\n\terr = ubifs_gc_end_commit(c);\n\tif (err)\n\t\tgoto out;\n\terr = ubifs_lpt_post_commit(c);\n\tif (err)\n\t\tgoto out;\n\nout_cancel:\n\tspin_lock(&c->cs_lock);\n\tc->cmt_state = COMMIT_RESTING;\n\twake_up(&c->cmt_wq);\n\tdbg_cmt(\"commit end\");\n\tspin_unlock(&c->cs_lock);\n\treturn 0;\n\nout_up:\n\tup_write(&c->commit_sem);\nout:\n\tubifs_err(c, \"commit failed, error %d\", err);\n\tspin_lock(&c->cs_lock);\n\tc->cmt_state = COMMIT_BROKEN;\n\twake_up(&c->cmt_wq);\n\tspin_unlock(&c->cs_lock);\n\tubifs_ro_mode(c, err);\n\treturn err;\n}\n\n \nstatic int run_bg_commit(struct ubifs_info *c)\n{\n\tspin_lock(&c->cs_lock);\n\t \n\tif (c->cmt_state != COMMIT_BACKGROUND &&\n\t    c->cmt_state != COMMIT_REQUIRED)\n\t\tgoto out;\n\tspin_unlock(&c->cs_lock);\n\n\tdown_write(&c->commit_sem);\n\tspin_lock(&c->cs_lock);\n\tif (c->cmt_state == COMMIT_REQUIRED)\n\t\tc->cmt_state = COMMIT_RUNNING_REQUIRED;\n\telse if (c->cmt_state == COMMIT_BACKGROUND)\n\t\tc->cmt_state = COMMIT_RUNNING_BACKGROUND;\n\telse\n\t\tgoto out_cmt_unlock;\n\tspin_unlock(&c->cs_lock);\n\n\treturn do_commit(c);\n\nout_cmt_unlock:\n\tup_write(&c->commit_sem);\nout:\n\tspin_unlock(&c->cs_lock);\n\treturn 0;\n}\n\n \nint ubifs_bg_thread(void *info)\n{\n\tint err;\n\tstruct ubifs_info *c = info;\n\n\tubifs_msg(c, \"background thread \\\"%s\\\" started, PID %d\",\n\t\t  c->bgt_name, current->pid);\n\tset_freezable();\n\n\twhile (1) {\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\n\t\tif (try_to_freeze())\n\t\t\tcontinue;\n\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t \n\t\tif (!c->need_bgt) {\n\t\t\t \n\t\t\tif (kthread_should_stop())\n\t\t\t\tbreak;\n\t\t\tschedule();\n\t\t\tcontinue;\n\t\t} else\n\t\t\t__set_current_state(TASK_RUNNING);\n\n\t\tc->need_bgt = 0;\n\t\terr = ubifs_bg_wbufs_sync(c);\n\t\tif (err)\n\t\t\tubifs_ro_mode(c, err);\n\n\t\trun_bg_commit(c);\n\t\tcond_resched();\n\t}\n\n\tubifs_msg(c, \"background thread \\\"%s\\\" stops\", c->bgt_name);\n\treturn 0;\n}\n\n \nvoid ubifs_commit_required(struct ubifs_info *c)\n{\n\tspin_lock(&c->cs_lock);\n\tswitch (c->cmt_state) {\n\tcase COMMIT_RESTING:\n\tcase COMMIT_BACKGROUND:\n\t\tdbg_cmt(\"old: %s, new: %s\", dbg_cstate(c->cmt_state),\n\t\t\tdbg_cstate(COMMIT_REQUIRED));\n\t\tc->cmt_state = COMMIT_REQUIRED;\n\t\tbreak;\n\tcase COMMIT_RUNNING_BACKGROUND:\n\t\tdbg_cmt(\"old: %s, new: %s\", dbg_cstate(c->cmt_state),\n\t\t\tdbg_cstate(COMMIT_RUNNING_REQUIRED));\n\t\tc->cmt_state = COMMIT_RUNNING_REQUIRED;\n\t\tbreak;\n\tcase COMMIT_REQUIRED:\n\tcase COMMIT_RUNNING_REQUIRED:\n\tcase COMMIT_BROKEN:\n\t\tbreak;\n\t}\n\tspin_unlock(&c->cs_lock);\n}\n\n \nvoid ubifs_request_bg_commit(struct ubifs_info *c)\n{\n\tspin_lock(&c->cs_lock);\n\tif (c->cmt_state == COMMIT_RESTING) {\n\t\tdbg_cmt(\"old: %s, new: %s\", dbg_cstate(c->cmt_state),\n\t\t\tdbg_cstate(COMMIT_BACKGROUND));\n\t\tc->cmt_state = COMMIT_BACKGROUND;\n\t\tspin_unlock(&c->cs_lock);\n\t\tubifs_wake_up_bgt(c);\n\t} else\n\t\tspin_unlock(&c->cs_lock);\n}\n\n \nstatic int wait_for_commit(struct ubifs_info *c)\n{\n\tdbg_cmt(\"pid %d goes sleep\", current->pid);\n\n\t \n\twait_event(c->cmt_wq, c->cmt_state != COMMIT_RUNNING_BACKGROUND &&\n\t\t\t      c->cmt_state != COMMIT_RUNNING_REQUIRED);\n\tdbg_cmt(\"commit finished, pid %d woke up\", current->pid);\n\treturn 0;\n}\n\n \nint ubifs_run_commit(struct ubifs_info *c)\n{\n\tint err = 0;\n\n\tspin_lock(&c->cs_lock);\n\tif (c->cmt_state == COMMIT_BROKEN) {\n\t\terr = -EROFS;\n\t\tgoto out;\n\t}\n\n\tif (c->cmt_state == COMMIT_RUNNING_BACKGROUND)\n\t\t \n\t\tc->cmt_state = COMMIT_RUNNING_REQUIRED;\n\n\tif (c->cmt_state == COMMIT_RUNNING_REQUIRED) {\n\t\tspin_unlock(&c->cs_lock);\n\t\treturn wait_for_commit(c);\n\t}\n\tspin_unlock(&c->cs_lock);\n\n\t \n\n\tdown_write(&c->commit_sem);\n\tspin_lock(&c->cs_lock);\n\t \n\tif (c->cmt_state == COMMIT_BROKEN) {\n\t\terr = -EROFS;\n\t\tgoto out_cmt_unlock;\n\t}\n\n\tif (c->cmt_state == COMMIT_RUNNING_BACKGROUND)\n\t\tc->cmt_state = COMMIT_RUNNING_REQUIRED;\n\n\tif (c->cmt_state == COMMIT_RUNNING_REQUIRED) {\n\t\tup_write(&c->commit_sem);\n\t\tspin_unlock(&c->cs_lock);\n\t\treturn wait_for_commit(c);\n\t}\n\tc->cmt_state = COMMIT_RUNNING_REQUIRED;\n\tspin_unlock(&c->cs_lock);\n\n\terr = do_commit(c);\n\treturn err;\n\nout_cmt_unlock:\n\tup_write(&c->commit_sem);\nout:\n\tspin_unlock(&c->cs_lock);\n\treturn err;\n}\n\n \nint ubifs_gc_should_commit(struct ubifs_info *c)\n{\n\tint ret = 0;\n\n\tspin_lock(&c->cs_lock);\n\tif (c->cmt_state == COMMIT_BACKGROUND) {\n\t\tdbg_cmt(\"commit required now\");\n\t\tc->cmt_state = COMMIT_REQUIRED;\n\t} else\n\t\tdbg_cmt(\"commit not requested\");\n\tif (c->cmt_state == COMMIT_REQUIRED)\n\t\tret = 1;\n\tspin_unlock(&c->cs_lock);\n\treturn ret;\n}\n\n \n\n \nstruct idx_node {\n\tstruct list_head list;\n\tint iip;\n\tunion ubifs_key upper_key;\n\tstruct ubifs_idx_node idx __aligned(8);\n};\n\n \nint dbg_old_index_check_init(struct ubifs_info *c, struct ubifs_zbranch *zroot)\n{\n\tstruct ubifs_idx_node *idx;\n\tint lnum, offs, len, err = 0;\n\tstruct ubifs_debug_info *d = c->dbg;\n\n\td->old_zroot = *zroot;\n\tlnum = d->old_zroot.lnum;\n\toffs = d->old_zroot.offs;\n\tlen = d->old_zroot.len;\n\n\tidx = kmalloc(c->max_idx_node_sz, GFP_NOFS);\n\tif (!idx)\n\t\treturn -ENOMEM;\n\n\terr = ubifs_read_node(c, idx, UBIFS_IDX_NODE, len, lnum, offs);\n\tif (err)\n\t\tgoto out;\n\n\td->old_zroot_level = le16_to_cpu(idx->level);\n\td->old_zroot_sqnum = le64_to_cpu(idx->ch.sqnum);\nout:\n\tkfree(idx);\n\treturn err;\n}\n\n \nint dbg_check_old_index(struct ubifs_info *c, struct ubifs_zbranch *zroot)\n{\n\tint lnum, offs, len, err = 0, last_level, child_cnt;\n\tint first = 1, iip;\n\tstruct ubifs_debug_info *d = c->dbg;\n\tunion ubifs_key lower_key, upper_key, l_key, u_key;\n\tunsigned long long last_sqnum;\n\tstruct ubifs_idx_node *idx;\n\tstruct list_head list;\n\tstruct idx_node *i;\n\tsize_t sz;\n\n\tif (!dbg_is_chk_index(c))\n\t\treturn 0;\n\n\tINIT_LIST_HEAD(&list);\n\n\tsz = sizeof(struct idx_node) + ubifs_idx_node_sz(c, c->fanout) -\n\t     UBIFS_IDX_NODE_SZ;\n\n\t \n\tlnum = d->old_zroot.lnum;\n\toffs = d->old_zroot.offs;\n\tlen = d->old_zroot.len;\n\tiip = 0;\n\n\t \n\twhile (1) {\n\t\tstruct ubifs_branch *br;\n\n\t\t \n\t\ti = kmalloc(sz, GFP_NOFS);\n\t\tif (!i) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_free;\n\t\t}\n\t\ti->iip = iip;\n\t\t \n\t\tlist_add_tail(&i->list, &list);\n\t\t \n\t\tidx = &i->idx;\n\t\terr = ubifs_read_node(c, idx, UBIFS_IDX_NODE, len, lnum, offs);\n\t\tif (err)\n\t\t\tgoto out_free;\n\t\t \n\t\tchild_cnt = le16_to_cpu(idx->child_cnt);\n\t\tif (child_cnt < 1 || child_cnt > c->fanout) {\n\t\t\terr = 1;\n\t\t\tgoto out_dump;\n\t\t}\n\t\tif (first) {\n\t\t\tfirst = 0;\n\t\t\t \n\t\t\tif (le16_to_cpu(idx->level) != d->old_zroot_level) {\n\t\t\t\terr = 2;\n\t\t\t\tgoto out_dump;\n\t\t\t}\n\t\t\tif (le64_to_cpu(idx->ch.sqnum) != d->old_zroot_sqnum) {\n\t\t\t\terr = 3;\n\t\t\t\tgoto out_dump;\n\t\t\t}\n\t\t\t \n\t\t\tlast_level = le16_to_cpu(idx->level) + 1;\n\t\t\tlast_sqnum = le64_to_cpu(idx->ch.sqnum) + 1;\n\t\t\tkey_read(c, ubifs_idx_key(c, idx), &lower_key);\n\t\t\thighest_ino_key(c, &upper_key, INUM_WATERMARK);\n\t\t}\n\t\tkey_copy(c, &upper_key, &i->upper_key);\n\t\tif (le16_to_cpu(idx->level) != last_level - 1) {\n\t\t\terr = 3;\n\t\t\tgoto out_dump;\n\t\t}\n\t\t \n\t\tif (le64_to_cpu(idx->ch.sqnum) >= last_sqnum) {\n\t\t\terr = 4;\n\t\t\tgoto out_dump;\n\t\t}\n\t\t \n\t\tkey_read(c, ubifs_idx_key(c, idx), &l_key);\n\t\tbr = ubifs_idx_branch(c, idx, child_cnt - 1);\n\t\tkey_read(c, &br->key, &u_key);\n\t\tif (keys_cmp(c, &lower_key, &l_key) > 0) {\n\t\t\terr = 5;\n\t\t\tgoto out_dump;\n\t\t}\n\t\tif (keys_cmp(c, &upper_key, &u_key) < 0) {\n\t\t\terr = 6;\n\t\t\tgoto out_dump;\n\t\t}\n\t\tif (keys_cmp(c, &upper_key, &u_key) == 0)\n\t\t\tif (!is_hash_key(c, &u_key)) {\n\t\t\t\terr = 7;\n\t\t\t\tgoto out_dump;\n\t\t\t}\n\t\t \n\t\tif (le16_to_cpu(idx->level) == 0) {\n\t\t\t \n\t\t\twhile (1) {\n\t\t\t\t \n\t\t\t\tlist_del(&i->list);\n\t\t\t\tkfree(i);\n\t\t\t\t \n\t\t\t\tif (list_empty(&list))\n\t\t\t\t\tgoto out;\n\t\t\t\t \n\t\t\t\ti = list_entry(list.prev, struct idx_node,\n\t\t\t\t\t       list);\n\t\t\t\tidx = &i->idx;\n\t\t\t\t \n\t\t\t\tif (iip + 1 < le16_to_cpu(idx->child_cnt)) {\n\t\t\t\t\tiip = iip + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t} else\n\t\t\t\t\t \n\t\t\t\t\tiip = i->iip;\n\t\t\t}\n\t\t} else\n\t\t\t \n\t\t\tiip = 0;\n\t\t \n\t\tlast_level = le16_to_cpu(idx->level);\n\t\tlast_sqnum = le64_to_cpu(idx->ch.sqnum);\n\t\tbr = ubifs_idx_branch(c, idx, iip);\n\t\tlnum = le32_to_cpu(br->lnum);\n\t\toffs = le32_to_cpu(br->offs);\n\t\tlen = le32_to_cpu(br->len);\n\t\tkey_read(c, &br->key, &lower_key);\n\t\tif (iip + 1 < le16_to_cpu(idx->child_cnt)) {\n\t\t\tbr = ubifs_idx_branch(c, idx, iip + 1);\n\t\t\tkey_read(c, &br->key, &upper_key);\n\t\t} else\n\t\t\tkey_copy(c, &i->upper_key, &upper_key);\n\t}\nout:\n\terr = dbg_old_index_check_init(c, zroot);\n\tif (err)\n\t\tgoto out_free;\n\n\treturn 0;\n\nout_dump:\n\tubifs_err(c, \"dumping index node (iip=%d)\", i->iip);\n\tubifs_dump_node(c, idx, ubifs_idx_node_sz(c, c->fanout));\n\tlist_del(&i->list);\n\tkfree(i);\n\tif (!list_empty(&list)) {\n\t\ti = list_entry(list.prev, struct idx_node, list);\n\t\tubifs_err(c, \"dumping parent index node\");\n\t\tubifs_dump_node(c, &i->idx, ubifs_idx_node_sz(c, c->fanout));\n\t}\nout_free:\n\twhile (!list_empty(&list)) {\n\t\ti = list_entry(list.next, struct idx_node, list);\n\t\tlist_del(&i->list);\n\t\tkfree(i);\n\t}\n\tubifs_err(c, \"failed, error %d\", err);\n\tif (err > 0)\n\t\terr = -EINVAL;\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}