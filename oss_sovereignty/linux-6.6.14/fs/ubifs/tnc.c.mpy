{
  "module_name": "tnc.c",
  "hash_id": "da64a161339400e95d177413d0943cc1067b43a9879fe3c056c74b5c20337376",
  "original_prompt": "Ingested from linux-6.6.14/fs/ubifs/tnc.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include \"ubifs.h\"\n\nstatic int try_read_node(const struct ubifs_info *c, void *buf, int type,\n\t\t\t struct ubifs_zbranch *zbr);\nstatic int fallible_read_node(struct ubifs_info *c, const union ubifs_key *key,\n\t\t\t      struct ubifs_zbranch *zbr, void *node);\n\n \nenum {\n\tNAME_LESS    = 0,\n\tNAME_MATCHES = 1,\n\tNAME_GREATER = 2,\n\tNOT_ON_MEDIA = 3,\n};\n\nstatic void do_insert_old_idx(struct ubifs_info *c,\n\t\t\t      struct ubifs_old_idx *old_idx)\n{\n\tstruct ubifs_old_idx *o;\n\tstruct rb_node **p, *parent = NULL;\n\n\tp = &c->old_idx.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\to = rb_entry(parent, struct ubifs_old_idx, rb);\n\t\tif (old_idx->lnum < o->lnum)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (old_idx->lnum > o->lnum)\n\t\t\tp = &(*p)->rb_right;\n\t\telse if (old_idx->offs < o->offs)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (old_idx->offs > o->offs)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\tubifs_err(c, \"old idx added twice!\");\n\t\t\tkfree(old_idx);\n\t\t}\n\t}\n\trb_link_node(&old_idx->rb, parent, p);\n\trb_insert_color(&old_idx->rb, &c->old_idx);\n}\n\n \nstatic int insert_old_idx(struct ubifs_info *c, int lnum, int offs)\n{\n\tstruct ubifs_old_idx *old_idx;\n\n\told_idx = kmalloc(sizeof(struct ubifs_old_idx), GFP_NOFS);\n\tif (unlikely(!old_idx))\n\t\treturn -ENOMEM;\n\told_idx->lnum = lnum;\n\told_idx->offs = offs;\n\tdo_insert_old_idx(c, old_idx);\n\n\treturn 0;\n}\n\n \nint insert_old_idx_znode(struct ubifs_info *c, struct ubifs_znode *znode)\n{\n\tif (znode->parent) {\n\t\tstruct ubifs_zbranch *zbr;\n\n\t\tzbr = &znode->parent->zbranch[znode->iip];\n\t\tif (zbr->len)\n\t\t\treturn insert_old_idx(c, zbr->lnum, zbr->offs);\n\t} else\n\t\tif (c->zroot.len)\n\t\t\treturn insert_old_idx(c, c->zroot.lnum,\n\t\t\t\t\t      c->zroot.offs);\n\treturn 0;\n}\n\n \nstatic int ins_clr_old_idx_znode(struct ubifs_info *c,\n\t\t\t\t struct ubifs_znode *znode)\n{\n\tint err;\n\n\tif (znode->parent) {\n\t\tstruct ubifs_zbranch *zbr;\n\n\t\tzbr = &znode->parent->zbranch[znode->iip];\n\t\tif (zbr->len) {\n\t\t\terr = insert_old_idx(c, zbr->lnum, zbr->offs);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tzbr->lnum = 0;\n\t\t\tzbr->offs = 0;\n\t\t\tzbr->len = 0;\n\t\t}\n\t} else\n\t\tif (c->zroot.len) {\n\t\t\terr = insert_old_idx(c, c->zroot.lnum, c->zroot.offs);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tc->zroot.lnum = 0;\n\t\t\tc->zroot.offs = 0;\n\t\t\tc->zroot.len = 0;\n\t\t}\n\treturn 0;\n}\n\n \nvoid destroy_old_idx(struct ubifs_info *c)\n{\n\tstruct ubifs_old_idx *old_idx, *n;\n\n\trbtree_postorder_for_each_entry_safe(old_idx, n, &c->old_idx, rb)\n\t\tkfree(old_idx);\n\n\tc->old_idx = RB_ROOT;\n}\n\n \nstatic struct ubifs_znode *copy_znode(struct ubifs_info *c,\n\t\t\t\t      struct ubifs_znode *znode)\n{\n\tstruct ubifs_znode *zn;\n\n\tzn = kmemdup(znode, c->max_znode_sz, GFP_NOFS);\n\tif (unlikely(!zn))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tzn->cnext = NULL;\n\t__set_bit(DIRTY_ZNODE, &zn->flags);\n\t__clear_bit(COW_ZNODE, &zn->flags);\n\n\treturn zn;\n}\n\n \nstatic int add_idx_dirt(struct ubifs_info *c, int lnum, int dirt)\n{\n\tc->calc_idx_sz -= ALIGN(dirt, 8);\n\treturn ubifs_add_dirt(c, lnum, dirt);\n}\n\n \nstatic void replace_znode(struct ubifs_info *c, struct ubifs_znode *new_zn,\n\t\t\t  struct ubifs_znode *old_zn, struct ubifs_zbranch *zbr)\n{\n\tubifs_assert(c, !ubifs_zn_obsolete(old_zn));\n\t__set_bit(OBSOLETE_ZNODE, &old_zn->flags);\n\n\tif (old_zn->level != 0) {\n\t\tint i;\n\t\tconst int n = new_zn->child_cnt;\n\n\t\t \n\t\tfor (i = 0; i < n; i++) {\n\t\t\tstruct ubifs_zbranch *child = &new_zn->zbranch[i];\n\n\t\t\tif (child->znode)\n\t\t\t\tchild->znode->parent = new_zn;\n\t\t}\n\t}\n\n\tzbr->znode = new_zn;\n\tzbr->lnum = 0;\n\tzbr->offs = 0;\n\tzbr->len = 0;\n\n\tatomic_long_inc(&c->dirty_zn_cnt);\n}\n\n \nstatic struct ubifs_znode *dirty_cow_znode(struct ubifs_info *c,\n\t\t\t\t\t   struct ubifs_zbranch *zbr)\n{\n\tstruct ubifs_znode *znode = zbr->znode;\n\tstruct ubifs_znode *zn;\n\tint err;\n\n\tif (!ubifs_zn_cow(znode)) {\n\t\t \n\t\tif (!test_and_set_bit(DIRTY_ZNODE, &znode->flags)) {\n\t\t\tatomic_long_inc(&c->dirty_zn_cnt);\n\t\t\tatomic_long_dec(&c->clean_zn_cnt);\n\t\t\tatomic_long_dec(&ubifs_clean_zn_cnt);\n\t\t\terr = add_idx_dirt(c, zbr->lnum, zbr->len);\n\t\t\tif (unlikely(err))\n\t\t\t\treturn ERR_PTR(err);\n\t\t}\n\t\treturn znode;\n\t}\n\n\tzn = copy_znode(c, znode);\n\tif (IS_ERR(zn))\n\t\treturn zn;\n\n\tif (zbr->len) {\n\t\tstruct ubifs_old_idx *old_idx;\n\n\t\told_idx = kmalloc(sizeof(struct ubifs_old_idx), GFP_NOFS);\n\t\tif (unlikely(!old_idx)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\told_idx->lnum = zbr->lnum;\n\t\told_idx->offs = zbr->offs;\n\n\t\terr = add_idx_dirt(c, zbr->lnum, zbr->len);\n\t\tif (err) {\n\t\t\tkfree(old_idx);\n\t\t\tgoto out;\n\t\t}\n\n\t\tdo_insert_old_idx(c, old_idx);\n\t}\n\n\treplace_znode(c, zn, znode, zbr);\n\n\treturn zn;\n\nout:\n\tkfree(zn);\n\treturn ERR_PTR(err);\n}\n\n \nstatic int lnc_add(struct ubifs_info *c, struct ubifs_zbranch *zbr,\n\t\t   const void *node)\n{\n\tint err;\n\tvoid *lnc_node;\n\tconst struct ubifs_dent_node *dent = node;\n\n\tubifs_assert(c, !zbr->leaf);\n\tubifs_assert(c, zbr->len != 0);\n\tubifs_assert(c, is_hash_key(c, &zbr->key));\n\n\terr = ubifs_validate_entry(c, dent);\n\tif (err) {\n\t\tdump_stack();\n\t\tubifs_dump_node(c, dent, zbr->len);\n\t\treturn err;\n\t}\n\n\tlnc_node = kmemdup(node, zbr->len, GFP_NOFS);\n\tif (!lnc_node)\n\t\t \n\t\treturn 0;\n\n\tzbr->leaf = lnc_node;\n\treturn 0;\n}\n\n  \nstatic int lnc_add_directly(struct ubifs_info *c, struct ubifs_zbranch *zbr,\n\t\t\t    void *node)\n{\n\tint err;\n\n\tubifs_assert(c, !zbr->leaf);\n\tubifs_assert(c, zbr->len != 0);\n\n\terr = ubifs_validate_entry(c, node);\n\tif (err) {\n\t\tdump_stack();\n\t\tubifs_dump_node(c, node, zbr->len);\n\t\treturn err;\n\t}\n\n\tzbr->leaf = node;\n\treturn 0;\n}\n\n \nstatic void lnc_free(struct ubifs_zbranch *zbr)\n{\n\tif (!zbr->leaf)\n\t\treturn;\n\tkfree(zbr->leaf);\n\tzbr->leaf = NULL;\n}\n\n \nstatic int tnc_read_hashed_node(struct ubifs_info *c, struct ubifs_zbranch *zbr,\n\t\t\t\tvoid *node)\n{\n\tint err;\n\n\tubifs_assert(c, is_hash_key(c, &zbr->key));\n\n\tif (zbr->leaf) {\n\t\t \n\t\tubifs_assert(c, zbr->len != 0);\n\t\tmemcpy(node, zbr->leaf, zbr->len);\n\t\treturn 0;\n\t}\n\n\tif (c->replaying) {\n\t\terr = fallible_read_node(c, &zbr->key, zbr, node);\n\t\t \n\t\tif (err == 0)\n\t\t\terr = -ENOENT;\n\t\telse if (err == 1)\n\t\t\terr = 0;\n\t} else {\n\t\terr = ubifs_tnc_read_node(c, zbr, node);\n\t}\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = lnc_add(c, zbr, node);\n\treturn err;\n}\n\n \nstatic int try_read_node(const struct ubifs_info *c, void *buf, int type,\n\t\t\t struct ubifs_zbranch *zbr)\n{\n\tint len = zbr->len;\n\tint lnum = zbr->lnum;\n\tint offs = zbr->offs;\n\tint err, node_len;\n\tstruct ubifs_ch *ch = buf;\n\tuint32_t crc, node_crc;\n\n\tdbg_io(\"LEB %d:%d, %s, length %d\", lnum, offs, dbg_ntype(type), len);\n\n\terr = ubifs_leb_read(c, lnum, buf, offs, len, 1);\n\tif (err) {\n\t\tubifs_err(c, \"cannot read node type %d from LEB %d:%d, error %d\",\n\t\t\t  type, lnum, offs, err);\n\t\treturn err;\n\t}\n\n\tif (le32_to_cpu(ch->magic) != UBIFS_NODE_MAGIC)\n\t\treturn 0;\n\n\tif (ch->node_type != type)\n\t\treturn 0;\n\n\tnode_len = le32_to_cpu(ch->len);\n\tif (node_len != len)\n\t\treturn 0;\n\n\tif (type != UBIFS_DATA_NODE || !c->no_chk_data_crc || c->mounting ||\n\t    c->remounting_rw) {\n\t\tcrc = crc32(UBIFS_CRC32_INIT, buf + 8, node_len - 8);\n\t\tnode_crc = le32_to_cpu(ch->crc);\n\t\tif (crc != node_crc)\n\t\t\treturn 0;\n\t}\n\n\terr = ubifs_node_check_hash(c, buf, zbr->hash);\n\tif (err) {\n\t\tubifs_bad_hash(c, buf, zbr->hash, lnum, offs);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n \nstatic int fallible_read_node(struct ubifs_info *c, const union ubifs_key *key,\n\t\t\t      struct ubifs_zbranch *zbr, void *node)\n{\n\tint ret;\n\n\tdbg_tnck(key, \"LEB %d:%d, key \", zbr->lnum, zbr->offs);\n\n\tret = try_read_node(c, node, key_type(c, key), zbr);\n\tif (ret == 1) {\n\t\tunion ubifs_key node_key;\n\t\tstruct ubifs_dent_node *dent = node;\n\n\t\t \n\t\tkey_read(c, &dent->key, &node_key);\n\t\tif (keys_cmp(c, key, &node_key) != 0)\n\t\t\tret = 0;\n\t}\n\tif (ret == 0 && c->replaying)\n\t\tdbg_mntk(key, \"dangling branch LEB %d:%d len %d, key \",\n\t\t\tzbr->lnum, zbr->offs, zbr->len);\n\treturn ret;\n}\n\n \nstatic int matches_name(struct ubifs_info *c, struct ubifs_zbranch *zbr,\n\t\t\tconst struct fscrypt_name *nm)\n{\n\tstruct ubifs_dent_node *dent;\n\tint nlen, err;\n\n\t \n\tif (!zbr->leaf) {\n\t\tdent = kmalloc(zbr->len, GFP_NOFS);\n\t\tif (!dent)\n\t\t\treturn -ENOMEM;\n\n\t\terr = ubifs_tnc_read_node(c, zbr, dent);\n\t\tif (err)\n\t\t\tgoto out_free;\n\n\t\t \n\t\terr = lnc_add_directly(c, zbr, dent);\n\t\tif (err)\n\t\t\tgoto out_free;\n\t} else\n\t\tdent = zbr->leaf;\n\n\tnlen = le16_to_cpu(dent->nlen);\n\terr = memcmp(dent->name, fname_name(nm), min_t(int, nlen, fname_len(nm)));\n\tif (err == 0) {\n\t\tif (nlen == fname_len(nm))\n\t\t\treturn NAME_MATCHES;\n\t\telse if (nlen < fname_len(nm))\n\t\t\treturn NAME_LESS;\n\t\telse\n\t\t\treturn NAME_GREATER;\n\t} else if (err < 0)\n\t\treturn NAME_LESS;\n\telse\n\t\treturn NAME_GREATER;\n\nout_free:\n\tkfree(dent);\n\treturn err;\n}\n\n \nstatic struct ubifs_znode *get_znode(struct ubifs_info *c,\n\t\t\t\t     struct ubifs_znode *znode, int n)\n{\n\tstruct ubifs_zbranch *zbr;\n\n\tzbr = &znode->zbranch[n];\n\tif (zbr->znode)\n\t\tznode = zbr->znode;\n\telse\n\t\tznode = ubifs_load_znode(c, zbr, znode, n);\n\treturn znode;\n}\n\n \nstatic int tnc_next(struct ubifs_info *c, struct ubifs_znode **zn, int *n)\n{\n\tstruct ubifs_znode *znode = *zn;\n\tint nn = *n;\n\n\tnn += 1;\n\tif (nn < znode->child_cnt) {\n\t\t*n = nn;\n\t\treturn 0;\n\t}\n\twhile (1) {\n\t\tstruct ubifs_znode *zp;\n\n\t\tzp = znode->parent;\n\t\tif (!zp)\n\t\t\treturn -ENOENT;\n\t\tnn = znode->iip + 1;\n\t\tznode = zp;\n\t\tif (nn < znode->child_cnt) {\n\t\t\tznode = get_znode(c, znode, nn);\n\t\t\tif (IS_ERR(znode))\n\t\t\t\treturn PTR_ERR(znode);\n\t\t\twhile (znode->level != 0) {\n\t\t\t\tznode = get_znode(c, znode, 0);\n\t\t\t\tif (IS_ERR(znode))\n\t\t\t\t\treturn PTR_ERR(znode);\n\t\t\t}\n\t\t\tnn = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\t*zn = znode;\n\t*n = nn;\n\treturn 0;\n}\n\n \nstatic int tnc_prev(struct ubifs_info *c, struct ubifs_znode **zn, int *n)\n{\n\tstruct ubifs_znode *znode = *zn;\n\tint nn = *n;\n\n\tif (nn > 0) {\n\t\t*n = nn - 1;\n\t\treturn 0;\n\t}\n\twhile (1) {\n\t\tstruct ubifs_znode *zp;\n\n\t\tzp = znode->parent;\n\t\tif (!zp)\n\t\t\treturn -ENOENT;\n\t\tnn = znode->iip - 1;\n\t\tznode = zp;\n\t\tif (nn >= 0) {\n\t\t\tznode = get_znode(c, znode, nn);\n\t\t\tif (IS_ERR(znode))\n\t\t\t\treturn PTR_ERR(znode);\n\t\t\twhile (znode->level != 0) {\n\t\t\t\tnn = znode->child_cnt - 1;\n\t\t\t\tznode = get_znode(c, znode, nn);\n\t\t\t\tif (IS_ERR(znode))\n\t\t\t\t\treturn PTR_ERR(znode);\n\t\t\t}\n\t\t\tnn = znode->child_cnt - 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\t*zn = znode;\n\t*n = nn;\n\treturn 0;\n}\n\n \nstatic int resolve_collision(struct ubifs_info *c, const union ubifs_key *key,\n\t\t\t     struct ubifs_znode **zn, int *n,\n\t\t\t     const struct fscrypt_name *nm)\n{\n\tint err;\n\n\terr = matches_name(c, &(*zn)->zbranch[*n], nm);\n\tif (unlikely(err < 0))\n\t\treturn err;\n\tif (err == NAME_MATCHES)\n\t\treturn 1;\n\n\tif (err == NAME_GREATER) {\n\t\t \n\t\twhile (1) {\n\t\t\terr = tnc_prev(c, zn, n);\n\t\t\tif (err == -ENOENT) {\n\t\t\t\tubifs_assert(c, *n == 0);\n\t\t\t\t*n = -1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tif (keys_cmp(c, &(*zn)->zbranch[*n].key, key)) {\n\t\t\t\t \n\t\t\t\tif (*n == (*zn)->child_cnt - 1) {\n\t\t\t\t\terr = tnc_next(c, zn, n);\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\t \n\t\t\t\t\t\tubifs_assert(c, 0);\n\t\t\t\t\t\tif (err == -ENOENT)\n\t\t\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\t\treturn err;\n\t\t\t\t\t}\n\t\t\t\t\tubifs_assert(c, *n == 0);\n\t\t\t\t\t*n = -1;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\terr = matches_name(c, &(*zn)->zbranch[*n], nm);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tif (err == NAME_LESS)\n\t\t\t\treturn 0;\n\t\t\tif (err == NAME_MATCHES)\n\t\t\t\treturn 1;\n\t\t\tubifs_assert(c, err == NAME_GREATER);\n\t\t}\n\t} else {\n\t\tint nn = *n;\n\t\tstruct ubifs_znode *znode = *zn;\n\n\t\t \n\t\twhile (1) {\n\t\t\terr = tnc_next(c, &znode, &nn);\n\t\t\tif (err == -ENOENT)\n\t\t\t\treturn 0;\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tif (keys_cmp(c, &znode->zbranch[nn].key, key))\n\t\t\t\treturn 0;\n\t\t\terr = matches_name(c, &znode->zbranch[nn], nm);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tif (err == NAME_GREATER)\n\t\t\t\treturn 0;\n\t\t\t*zn = znode;\n\t\t\t*n = nn;\n\t\t\tif (err == NAME_MATCHES)\n\t\t\t\treturn 1;\n\t\t\tubifs_assert(c, err == NAME_LESS);\n\t\t}\n\t}\n}\n\n \nstatic int fallible_matches_name(struct ubifs_info *c,\n\t\t\t\t struct ubifs_zbranch *zbr,\n\t\t\t\t const struct fscrypt_name *nm)\n{\n\tstruct ubifs_dent_node *dent;\n\tint nlen, err;\n\n\t \n\tif (!zbr->leaf) {\n\t\tdent = kmalloc(zbr->len, GFP_NOFS);\n\t\tif (!dent)\n\t\t\treturn -ENOMEM;\n\n\t\terr = fallible_read_node(c, &zbr->key, zbr, dent);\n\t\tif (err < 0)\n\t\t\tgoto out_free;\n\t\tif (err == 0) {\n\t\t\t \n\t\t\terr = NOT_ON_MEDIA;\n\t\t\tgoto out_free;\n\t\t}\n\t\tubifs_assert(c, err == 1);\n\n\t\terr = lnc_add_directly(c, zbr, dent);\n\t\tif (err)\n\t\t\tgoto out_free;\n\t} else\n\t\tdent = zbr->leaf;\n\n\tnlen = le16_to_cpu(dent->nlen);\n\terr = memcmp(dent->name, fname_name(nm), min_t(int, nlen, fname_len(nm)));\n\tif (err == 0) {\n\t\tif (nlen == fname_len(nm))\n\t\t\treturn NAME_MATCHES;\n\t\telse if (nlen < fname_len(nm))\n\t\t\treturn NAME_LESS;\n\t\telse\n\t\t\treturn NAME_GREATER;\n\t} else if (err < 0)\n\t\treturn NAME_LESS;\n\telse\n\t\treturn NAME_GREATER;\n\nout_free:\n\tkfree(dent);\n\treturn err;\n}\n\n \nstatic int fallible_resolve_collision(struct ubifs_info *c,\n\t\t\t\t      const union ubifs_key *key,\n\t\t\t\t      struct ubifs_znode **zn, int *n,\n\t\t\t\t      const struct fscrypt_name *nm,\n\t\t\t\t      int adding)\n{\n\tstruct ubifs_znode *o_znode = NULL, *znode = *zn;\n\tint o_n, err, cmp, unsure = 0, nn = *n;\n\n\tcmp = fallible_matches_name(c, &znode->zbranch[nn], nm);\n\tif (unlikely(cmp < 0))\n\t\treturn cmp;\n\tif (cmp == NAME_MATCHES)\n\t\treturn 1;\n\tif (cmp == NOT_ON_MEDIA) {\n\t\to_znode = znode;\n\t\to_n = nn;\n\t\t \n\t\tunsure = 1;\n\t} else if (!adding)\n\t\tunsure = 1;  \n\n\tif (cmp == NAME_GREATER || unsure) {\n\t\t \n\t\twhile (1) {\n\t\t\terr = tnc_prev(c, zn, n);\n\t\t\tif (err == -ENOENT) {\n\t\t\t\tubifs_assert(c, *n == 0);\n\t\t\t\t*n = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tif (keys_cmp(c, &(*zn)->zbranch[*n].key, key)) {\n\t\t\t\t \n\t\t\t\tif (*n == (*zn)->child_cnt - 1) {\n\t\t\t\t\terr = tnc_next(c, zn, n);\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\t \n\t\t\t\t\t\tubifs_assert(c, 0);\n\t\t\t\t\t\tif (err == -ENOENT)\n\t\t\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\t\treturn err;\n\t\t\t\t\t}\n\t\t\t\t\tubifs_assert(c, *n == 0);\n\t\t\t\t\t*n = -1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\terr = fallible_matches_name(c, &(*zn)->zbranch[*n], nm);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tif (err == NAME_MATCHES)\n\t\t\t\treturn 1;\n\t\t\tif (err == NOT_ON_MEDIA) {\n\t\t\t\to_znode = *zn;\n\t\t\t\to_n = *n;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!adding)\n\t\t\t\tcontinue;\n\t\t\tif (err == NAME_LESS)\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tunsure = 0;\n\t\t}\n\t}\n\n\tif (cmp == NAME_LESS || unsure) {\n\t\t \n\t\t*zn = znode;\n\t\t*n = nn;\n\t\twhile (1) {\n\t\t\terr = tnc_next(c, &znode, &nn);\n\t\t\tif (err == -ENOENT)\n\t\t\t\tbreak;\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tif (keys_cmp(c, &znode->zbranch[nn].key, key))\n\t\t\t\tbreak;\n\t\t\terr = fallible_matches_name(c, &znode->zbranch[nn], nm);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tif (err == NAME_GREATER)\n\t\t\t\tbreak;\n\t\t\t*zn = znode;\n\t\t\t*n = nn;\n\t\t\tif (err == NAME_MATCHES)\n\t\t\t\treturn 1;\n\t\t\tif (err == NOT_ON_MEDIA) {\n\t\t\t\to_znode = znode;\n\t\t\t\to_n = nn;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (adding || !o_znode)\n\t\treturn 0;\n\n\tdbg_mntk(key, \"dangling match LEB %d:%d len %d key \",\n\t\to_znode->zbranch[o_n].lnum, o_znode->zbranch[o_n].offs,\n\t\to_znode->zbranch[o_n].len);\n\t*zn = o_znode;\n\t*n = o_n;\n\treturn 1;\n}\n\n \nstatic int matches_position(struct ubifs_zbranch *zbr, int lnum, int offs)\n{\n\tif (zbr->lnum == lnum && zbr->offs == offs)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\n \nstatic int resolve_collision_directly(struct ubifs_info *c,\n\t\t\t\t      const union ubifs_key *key,\n\t\t\t\t      struct ubifs_znode **zn, int *n,\n\t\t\t\t      int lnum, int offs)\n{\n\tstruct ubifs_znode *znode;\n\tint nn, err;\n\n\tznode = *zn;\n\tnn = *n;\n\tif (matches_position(&znode->zbranch[nn], lnum, offs))\n\t\treturn 1;\n\n\t \n\twhile (1) {\n\t\terr = tnc_prev(c, &znode, &nn);\n\t\tif (err == -ENOENT)\n\t\t\tbreak;\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (keys_cmp(c, &znode->zbranch[nn].key, key))\n\t\t\tbreak;\n\t\tif (matches_position(&znode->zbranch[nn], lnum, offs)) {\n\t\t\t*zn = znode;\n\t\t\t*n = nn;\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t \n\tznode = *zn;\n\tnn = *n;\n\twhile (1) {\n\t\terr = tnc_next(c, &znode, &nn);\n\t\tif (err == -ENOENT)\n\t\t\treturn 0;\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (keys_cmp(c, &znode->zbranch[nn].key, key))\n\t\t\treturn 0;\n\t\t*zn = znode;\n\t\t*n = nn;\n\t\tif (matches_position(&znode->zbranch[nn], lnum, offs))\n\t\t\treturn 1;\n\t}\n}\n\n \nstatic struct ubifs_znode *dirty_cow_bottom_up(struct ubifs_info *c,\n\t\t\t\t\t       struct ubifs_znode *znode)\n{\n\tstruct ubifs_znode *zp;\n\tint *path = c->bottom_up_buf, p = 0;\n\n\tubifs_assert(c, c->zroot.znode);\n\tubifs_assert(c, znode);\n\tif (c->zroot.znode->level > BOTTOM_UP_HEIGHT) {\n\t\tkfree(c->bottom_up_buf);\n\t\tc->bottom_up_buf = kmalloc_array(c->zroot.znode->level,\n\t\t\t\t\t\t sizeof(int),\n\t\t\t\t\t\t GFP_NOFS);\n\t\tif (!c->bottom_up_buf)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tpath = c->bottom_up_buf;\n\t}\n\tif (c->zroot.znode->level) {\n\t\t \n\t\twhile (1) {\n\t\t\tint n;\n\n\t\t\tzp = znode->parent;\n\t\t\tif (!zp)\n\t\t\t\tbreak;\n\t\t\tn = znode->iip;\n\t\t\tubifs_assert(c, p < c->zroot.znode->level);\n\t\t\tpath[p++] = n;\n\t\t\tif (!zp->cnext && ubifs_zn_dirty(znode))\n\t\t\t\tbreak;\n\t\t\tznode = zp;\n\t\t}\n\t}\n\n\t \n\twhile (1) {\n\t\tstruct ubifs_zbranch *zbr;\n\n\t\tzp = znode->parent;\n\t\tif (zp) {\n\t\t\tubifs_assert(c, path[p - 1] >= 0);\n\t\t\tubifs_assert(c, path[p - 1] < zp->child_cnt);\n\t\t\tzbr = &zp->zbranch[path[--p]];\n\t\t\tznode = dirty_cow_znode(c, zbr);\n\t\t} else {\n\t\t\tubifs_assert(c, znode == c->zroot.znode);\n\t\t\tznode = dirty_cow_znode(c, &c->zroot);\n\t\t}\n\t\tif (IS_ERR(znode) || !p)\n\t\t\tbreak;\n\t\tubifs_assert(c, path[p - 1] >= 0);\n\t\tubifs_assert(c, path[p - 1] < znode->child_cnt);\n\t\tznode = znode->zbranch[path[p - 1]].znode;\n\t}\n\n\treturn znode;\n}\n\n \nint ubifs_lookup_level0(struct ubifs_info *c, const union ubifs_key *key,\n\t\t\tstruct ubifs_znode **zn, int *n)\n{\n\tint err, exact;\n\tstruct ubifs_znode *znode;\n\ttime64_t time = ktime_get_seconds();\n\n\tdbg_tnck(key, \"search key \");\n\tubifs_assert(c, key_type(c, key) < UBIFS_INVALID_KEY);\n\n\tznode = c->zroot.znode;\n\tif (unlikely(!znode)) {\n\t\tznode = ubifs_load_znode(c, &c->zroot, NULL, 0);\n\t\tif (IS_ERR(znode))\n\t\t\treturn PTR_ERR(znode);\n\t}\n\n\tznode->time = time;\n\n\twhile (1) {\n\t\tstruct ubifs_zbranch *zbr;\n\n\t\texact = ubifs_search_zbranch(c, znode, key, n);\n\n\t\tif (znode->level == 0)\n\t\t\tbreak;\n\n\t\tif (*n < 0)\n\t\t\t*n = 0;\n\t\tzbr = &znode->zbranch[*n];\n\n\t\tif (zbr->znode) {\n\t\t\tznode->time = time;\n\t\t\tznode = zbr->znode;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tznode = ubifs_load_znode(c, zbr, znode, *n);\n\t\tif (IS_ERR(znode))\n\t\t\treturn PTR_ERR(znode);\n\t}\n\n\t*zn = znode;\n\tif (exact || !is_hash_key(c, key) || *n != -1) {\n\t\tdbg_tnc(\"found %d, lvl %d, n %d\", exact, znode->level, *n);\n\t\treturn exact;\n\t}\n\n\t \n\terr = tnc_prev(c, &znode, n);\n\tif (err == -ENOENT) {\n\t\tdbg_tnc(\"found 0, lvl %d, n -1\", znode->level);\n\t\t*n = -1;\n\t\treturn 0;\n\t}\n\tif (unlikely(err < 0))\n\t\treturn err;\n\tif (keys_cmp(c, key, &znode->zbranch[*n].key)) {\n\t\tdbg_tnc(\"found 0, lvl %d, n -1\", znode->level);\n\t\t*n = -1;\n\t\treturn 0;\n\t}\n\n\tdbg_tnc(\"found 1, lvl %d, n %d\", znode->level, *n);\n\t*zn = znode;\n\treturn 1;\n}\n\n \nstatic int lookup_level0_dirty(struct ubifs_info *c, const union ubifs_key *key,\n\t\t\t       struct ubifs_znode **zn, int *n)\n{\n\tint err, exact;\n\tstruct ubifs_znode *znode;\n\ttime64_t time = ktime_get_seconds();\n\n\tdbg_tnck(key, \"search and dirty key \");\n\n\tznode = c->zroot.znode;\n\tif (unlikely(!znode)) {\n\t\tznode = ubifs_load_znode(c, &c->zroot, NULL, 0);\n\t\tif (IS_ERR(znode))\n\t\t\treturn PTR_ERR(znode);\n\t}\n\n\tznode = dirty_cow_znode(c, &c->zroot);\n\tif (IS_ERR(znode))\n\t\treturn PTR_ERR(znode);\n\n\tznode->time = time;\n\n\twhile (1) {\n\t\tstruct ubifs_zbranch *zbr;\n\n\t\texact = ubifs_search_zbranch(c, znode, key, n);\n\n\t\tif (znode->level == 0)\n\t\t\tbreak;\n\n\t\tif (*n < 0)\n\t\t\t*n = 0;\n\t\tzbr = &znode->zbranch[*n];\n\n\t\tif (zbr->znode) {\n\t\t\tznode->time = time;\n\t\t\tznode = dirty_cow_znode(c, zbr);\n\t\t\tif (IS_ERR(znode))\n\t\t\t\treturn PTR_ERR(znode);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tznode = ubifs_load_znode(c, zbr, znode, *n);\n\t\tif (IS_ERR(znode))\n\t\t\treturn PTR_ERR(znode);\n\t\tznode = dirty_cow_znode(c, zbr);\n\t\tif (IS_ERR(znode))\n\t\t\treturn PTR_ERR(znode);\n\t}\n\n\t*zn = znode;\n\tif (exact || !is_hash_key(c, key) || *n != -1) {\n\t\tdbg_tnc(\"found %d, lvl %d, n %d\", exact, znode->level, *n);\n\t\treturn exact;\n\t}\n\n\t \n\terr = tnc_prev(c, &znode, n);\n\tif (err == -ENOENT) {\n\t\t*n = -1;\n\t\tdbg_tnc(\"found 0, lvl %d, n -1\", znode->level);\n\t\treturn 0;\n\t}\n\tif (unlikely(err < 0))\n\t\treturn err;\n\tif (keys_cmp(c, key, &znode->zbranch[*n].key)) {\n\t\t*n = -1;\n\t\tdbg_tnc(\"found 0, lvl %d, n -1\", znode->level);\n\t\treturn 0;\n\t}\n\n\tif (znode->cnext || !ubifs_zn_dirty(znode)) {\n\t\tznode = dirty_cow_bottom_up(c, znode);\n\t\tif (IS_ERR(znode))\n\t\t\treturn PTR_ERR(znode);\n\t}\n\n\tdbg_tnc(\"found 1, lvl %d, n %d\", znode->level, *n);\n\t*zn = znode;\n\treturn 1;\n}\n\n \nstatic int maybe_leb_gced(struct ubifs_info *c, int lnum, int gc_seq1)\n{\n\tint gc_seq2, gced_lnum;\n\n\tgced_lnum = c->gced_lnum;\n\tsmp_rmb();\n\tgc_seq2 = c->gc_seq;\n\t \n\tif (gc_seq1 == gc_seq2)\n\t\treturn 0;\n\t \n\tif (gc_seq1 + 1 != gc_seq2)\n\t\treturn 1;\n\t \n\tsmp_rmb();\n\tif (gced_lnum != c->gced_lnum)\n\t\treturn 1;\n\t \n\tif (gced_lnum == lnum)\n\t\treturn 1;\n\treturn 0;\n}\n\n \nint ubifs_tnc_locate(struct ubifs_info *c, const union ubifs_key *key,\n\t\t     void *node, int *lnum, int *offs)\n{\n\tint found, n, err, safely = 0, gc_seq1;\n\tstruct ubifs_znode *znode;\n\tstruct ubifs_zbranch zbr, *zt;\n\nagain:\n\tmutex_lock(&c->tnc_mutex);\n\tfound = ubifs_lookup_level0(c, key, &znode, &n);\n\tif (!found) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t} else if (found < 0) {\n\t\terr = found;\n\t\tgoto out;\n\t}\n\tzt = &znode->zbranch[n];\n\tif (lnum) {\n\t\t*lnum = zt->lnum;\n\t\t*offs = zt->offs;\n\t}\n\tif (is_hash_key(c, key)) {\n\t\t \n\t\terr = tnc_read_hashed_node(c, zt, node);\n\t\tgoto out;\n\t}\n\tif (safely) {\n\t\terr = ubifs_tnc_read_node(c, zt, node);\n\t\tgoto out;\n\t}\n\t \n\tzbr = znode->zbranch[n];\n\tgc_seq1 = c->gc_seq;\n\tmutex_unlock(&c->tnc_mutex);\n\n\tif (ubifs_get_wbuf(c, zbr.lnum)) {\n\t\t \n\t\terr = ubifs_tnc_read_node(c, &zbr, node);\n\t\treturn err;\n\t}\n\n\terr = fallible_read_node(c, key, &zbr, node);\n\tif (err <= 0 || maybe_leb_gced(c, zbr.lnum, gc_seq1)) {\n\t\t \n\t\tsafely = 1;\n\t\tgoto again;\n\t}\n\treturn 0;\n\nout:\n\tmutex_unlock(&c->tnc_mutex);\n\treturn err;\n}\n\n \nint ubifs_tnc_get_bu_keys(struct ubifs_info *c, struct bu_info *bu)\n{\n\tint n, err = 0, lnum = -1, offs;\n\tint len;\n\tunsigned int block = key_block(c, &bu->key);\n\tstruct ubifs_znode *znode;\n\n\tbu->cnt = 0;\n\tbu->blk_cnt = 0;\n\tbu->eof = 0;\n\n\tmutex_lock(&c->tnc_mutex);\n\t \n\terr = ubifs_lookup_level0(c, &bu->key, &znode, &n);\n\tif (err < 0)\n\t\tgoto out;\n\tif (err) {\n\t\t \n\t\tlen = znode->zbranch[n].len;\n\t\t \n\t\tif (len > bu->buf_len) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\tbu->zbranch[bu->cnt++] = znode->zbranch[n];\n\t\tbu->blk_cnt += 1;\n\t\tlnum = znode->zbranch[n].lnum;\n\t\toffs = ALIGN(znode->zbranch[n].offs + len, 8);\n\t}\n\twhile (1) {\n\t\tstruct ubifs_zbranch *zbr;\n\t\tunion ubifs_key *key;\n\t\tunsigned int next_block;\n\n\t\t \n\t\terr = tnc_next(c, &znode, &n);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tzbr = &znode->zbranch[n];\n\t\tkey = &zbr->key;\n\t\t \n\t\tif (key_inum(c, key) != key_inum(c, &bu->key) ||\n\t\t    key_type(c, key) != UBIFS_DATA_KEY) {\n\t\t\terr = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (lnum < 0) {\n\t\t\t \n\t\t\tlnum = zbr->lnum;\n\t\t\toffs = ALIGN(zbr->offs + zbr->len, 8);\n\t\t\tlen = zbr->len;\n\t\t\tif (len > bu->buf_len) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif (zbr->lnum != lnum || zbr->offs != offs)\n\t\t\t\tgoto out;\n\t\t\toffs += ALIGN(zbr->len, 8);\n\t\t\tlen = ALIGN(len, 8) + zbr->len;\n\t\t\t \n\t\t\tif (len > bu->buf_len)\n\t\t\t\tgoto out;\n\t\t}\n\t\t \n\t\tnext_block = key_block(c, key);\n\t\tbu->blk_cnt += (next_block - block - 1);\n\t\tif (bu->blk_cnt >= UBIFS_MAX_BULK_READ)\n\t\t\tgoto out;\n\t\tblock = next_block;\n\t\t \n\t\tbu->zbranch[bu->cnt++] = *zbr;\n\t\tbu->blk_cnt += 1;\n\t\t \n\t\tif (bu->cnt >= UBIFS_MAX_BULK_READ)\n\t\t\tgoto out;\n\t\tif (bu->blk_cnt >= UBIFS_MAX_BULK_READ)\n\t\t\tgoto out;\n\t}\nout:\n\tif (err == -ENOENT) {\n\t\tbu->eof = 1;\n\t\terr = 0;\n\t}\n\tbu->gc_seq = c->gc_seq;\n\tmutex_unlock(&c->tnc_mutex);\n\tif (err)\n\t\treturn err;\n\t \n\tif (bu->blk_cnt > UBIFS_MAX_BULK_READ)\n\t\tbu->blk_cnt = UBIFS_MAX_BULK_READ;\n\t \n\tif (UBIFS_BLOCKS_PER_PAGE == 1 ||\n\t    !(bu->blk_cnt & (UBIFS_BLOCKS_PER_PAGE - 1)))\n\t\treturn 0;\n\tif (bu->eof) {\n\t\t \n\t\tbu->blk_cnt += UBIFS_BLOCKS_PER_PAGE - 1;\n\t\treturn 0;\n\t}\n\t \n\tblock = key_block(c, &bu->key) + bu->blk_cnt;\n\tblock &= ~(UBIFS_BLOCKS_PER_PAGE - 1);\n\twhile (bu->cnt) {\n\t\tif (key_block(c, &bu->zbranch[bu->cnt - 1].key) < block)\n\t\t\tbreak;\n\t\tbu->cnt -= 1;\n\t}\n\treturn 0;\n}\n\n \nstatic int read_wbuf(struct ubifs_wbuf *wbuf, void *buf, int len, int lnum,\n\t\t     int offs)\n{\n\tconst struct ubifs_info *c = wbuf->c;\n\tint rlen, overlap;\n\n\tdbg_io(\"LEB %d:%d, length %d\", lnum, offs, len);\n\tubifs_assert(c, wbuf && lnum >= 0 && lnum < c->leb_cnt && offs >= 0);\n\tubifs_assert(c, !(offs & 7) && offs < c->leb_size);\n\tubifs_assert(c, offs + len <= c->leb_size);\n\n\tspin_lock(&wbuf->lock);\n\toverlap = (lnum == wbuf->lnum && offs + len > wbuf->offs);\n\tif (!overlap) {\n\t\t \n\t\tspin_unlock(&wbuf->lock);\n\t\treturn ubifs_leb_read(c, lnum, buf, offs, len, 0);\n\t}\n\n\t \n\trlen = wbuf->offs - offs;\n\tif (rlen < 0)\n\t\trlen = 0;\n\n\t \n\tmemcpy(buf + rlen, wbuf->buf + offs + rlen - wbuf->offs, len - rlen);\n\tspin_unlock(&wbuf->lock);\n\n\tif (rlen > 0)\n\t\t \n\t\treturn ubifs_leb_read(c, lnum, buf, offs, rlen, 0);\n\n\treturn 0;\n}\n\n \nstatic int validate_data_node(struct ubifs_info *c, void *buf,\n\t\t\t      struct ubifs_zbranch *zbr)\n{\n\tunion ubifs_key key1;\n\tstruct ubifs_ch *ch = buf;\n\tint err, len;\n\n\tif (ch->node_type != UBIFS_DATA_NODE) {\n\t\tubifs_err(c, \"bad node type (%d but expected %d)\",\n\t\t\t  ch->node_type, UBIFS_DATA_NODE);\n\t\tgoto out_err;\n\t}\n\n\terr = ubifs_check_node(c, buf, zbr->len, zbr->lnum, zbr->offs, 0, 0);\n\tif (err) {\n\t\tubifs_err(c, \"expected node type %d\", UBIFS_DATA_NODE);\n\t\tgoto out;\n\t}\n\n\terr = ubifs_node_check_hash(c, buf, zbr->hash);\n\tif (err) {\n\t\tubifs_bad_hash(c, buf, zbr->hash, zbr->lnum, zbr->offs);\n\t\treturn err;\n\t}\n\n\tlen = le32_to_cpu(ch->len);\n\tif (len != zbr->len) {\n\t\tubifs_err(c, \"bad node length %d, expected %d\", len, zbr->len);\n\t\tgoto out_err;\n\t}\n\n\t \n\tkey_read(c, buf + UBIFS_KEY_OFFSET, &key1);\n\tif (!keys_eq(c, &zbr->key, &key1)) {\n\t\tubifs_err(c, \"bad key in node at LEB %d:%d\",\n\t\t\t  zbr->lnum, zbr->offs);\n\t\tdbg_tnck(&zbr->key, \"looked for key \");\n\t\tdbg_tnck(&key1, \"found node's key \");\n\t\tgoto out_err;\n\t}\n\n\treturn 0;\n\nout_err:\n\terr = -EINVAL;\nout:\n\tubifs_err(c, \"bad node at LEB %d:%d\", zbr->lnum, zbr->offs);\n\tubifs_dump_node(c, buf, zbr->len);\n\tdump_stack();\n\treturn err;\n}\n\n \nint ubifs_tnc_bulk_read(struct ubifs_info *c, struct bu_info *bu)\n{\n\tint lnum = bu->zbranch[0].lnum, offs = bu->zbranch[0].offs, len, err, i;\n\tstruct ubifs_wbuf *wbuf;\n\tvoid *buf;\n\n\tlen = bu->zbranch[bu->cnt - 1].offs;\n\tlen += bu->zbranch[bu->cnt - 1].len - offs;\n\tif (len > bu->buf_len) {\n\t\tubifs_err(c, \"buffer too small %d vs %d\", bu->buf_len, len);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\twbuf = ubifs_get_wbuf(c, lnum);\n\tif (wbuf)\n\t\terr = read_wbuf(wbuf, bu->buf, len, lnum, offs);\n\telse\n\t\terr = ubifs_leb_read(c, lnum, bu->buf, offs, len, 0);\n\n\t \n\tif (maybe_leb_gced(c, lnum, bu->gc_seq))\n\t\treturn -EAGAIN;\n\n\tif (err && err != -EBADMSG) {\n\t\tubifs_err(c, \"failed to read from LEB %d:%d, error %d\",\n\t\t\t  lnum, offs, err);\n\t\tdump_stack();\n\t\tdbg_tnck(&bu->key, \"key \");\n\t\treturn err;\n\t}\n\n\t \n\tbuf = bu->buf;\n\tfor (i = 0; i < bu->cnt; i++) {\n\t\terr = validate_data_node(c, buf, &bu->zbranch[i]);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbuf = buf + ALIGN(bu->zbranch[i].len, 8);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int do_lookup_nm(struct ubifs_info *c, const union ubifs_key *key,\n\t\t\tvoid *node, const struct fscrypt_name *nm)\n{\n\tint found, n, err;\n\tstruct ubifs_znode *znode;\n\n\tdbg_tnck(key, \"key \");\n\tmutex_lock(&c->tnc_mutex);\n\tfound = ubifs_lookup_level0(c, key, &znode, &n);\n\tif (!found) {\n\t\terr = -ENOENT;\n\t\tgoto out_unlock;\n\t} else if (found < 0) {\n\t\terr = found;\n\t\tgoto out_unlock;\n\t}\n\n\tubifs_assert(c, n >= 0);\n\n\terr = resolve_collision(c, key, &znode, &n, nm);\n\tdbg_tnc(\"rc returned %d, znode %p, n %d\", err, znode, n);\n\tif (unlikely(err < 0))\n\t\tgoto out_unlock;\n\tif (err == 0) {\n\t\terr = -ENOENT;\n\t\tgoto out_unlock;\n\t}\n\n\terr = tnc_read_hashed_node(c, &znode->zbranch[n], node);\n\nout_unlock:\n\tmutex_unlock(&c->tnc_mutex);\n\treturn err;\n}\n\n \nint ubifs_tnc_lookup_nm(struct ubifs_info *c, const union ubifs_key *key,\n\t\t\tvoid *node, const struct fscrypt_name *nm)\n{\n\tint err, len;\n\tconst struct ubifs_dent_node *dent = node;\n\n\t \n\terr = ubifs_tnc_lookup(c, key, node);\n\tif (err)\n\t\treturn err;\n\n\tlen = le16_to_cpu(dent->nlen);\n\tif (fname_len(nm) == len && !memcmp(dent->name, fname_name(nm), len))\n\t\treturn 0;\n\n\t \n\n\treturn do_lookup_nm(c, key, node, nm);\n}\n\nstatic int search_dh_cookie(struct ubifs_info *c, const union ubifs_key *key,\n\t\t\t    struct ubifs_dent_node *dent, uint32_t cookie,\n\t\t\t    struct ubifs_znode **zn, int *n, int exact)\n{\n\tint err;\n\tstruct ubifs_znode *znode = *zn;\n\tstruct ubifs_zbranch *zbr;\n\tunion ubifs_key *dkey;\n\n\tif (!exact) {\n\t\terr = tnc_next(c, &znode, n);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tfor (;;) {\n\t\tzbr = &znode->zbranch[*n];\n\t\tdkey = &zbr->key;\n\n\t\tif (key_inum(c, dkey) != key_inum(c, key) ||\n\t\t    key_type(c, dkey) != key_type(c, key)) {\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\terr = tnc_read_hashed_node(c, zbr, dent);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (key_hash(c, key) == key_hash(c, dkey) &&\n\t\t    le32_to_cpu(dent->cookie) == cookie) {\n\t\t\t*zn = znode;\n\t\t\treturn 0;\n\t\t}\n\n\t\terr = tnc_next(c, &znode, n);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n}\n\nstatic int do_lookup_dh(struct ubifs_info *c, const union ubifs_key *key,\n\t\t\tstruct ubifs_dent_node *dent, uint32_t cookie)\n{\n\tint n, err;\n\tstruct ubifs_znode *znode;\n\tunion ubifs_key start_key;\n\n\tubifs_assert(c, is_hash_key(c, key));\n\n\tlowest_dent_key(c, &start_key, key_inum(c, key));\n\n\tmutex_lock(&c->tnc_mutex);\n\terr = ubifs_lookup_level0(c, &start_key, &znode, &n);\n\tif (unlikely(err < 0))\n\t\tgoto out_unlock;\n\n\terr = search_dh_cookie(c, key, dent, cookie, &znode, &n, err);\n\nout_unlock:\n\tmutex_unlock(&c->tnc_mutex);\n\treturn err;\n}\n\n \nint ubifs_tnc_lookup_dh(struct ubifs_info *c, const union ubifs_key *key,\n\t\t\tvoid *node, uint32_t cookie)\n{\n\tint err;\n\tconst struct ubifs_dent_node *dent = node;\n\n\tif (!c->double_hash)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\terr = ubifs_tnc_lookup(c, key, node);\n\tif (err)\n\t\treturn err;\n\n\tif (le32_to_cpu(dent->cookie) == cookie)\n\t\treturn 0;\n\n\t \n\treturn do_lookup_dh(c, key, node, cookie);\n}\n\n \nstatic void correct_parent_keys(const struct ubifs_info *c,\n\t\t\t\tstruct ubifs_znode *znode)\n{\n\tunion ubifs_key *key, *key1;\n\n\tubifs_assert(c, znode->parent);\n\tubifs_assert(c, znode->iip == 0);\n\n\tkey = &znode->zbranch[0].key;\n\tkey1 = &znode->parent->zbranch[0].key;\n\n\twhile (keys_cmp(c, key, key1) < 0) {\n\t\tkey_copy(c, key, key1);\n\t\tznode = znode->parent;\n\t\tznode->alt = 1;\n\t\tif (!znode->parent || znode->iip)\n\t\t\tbreak;\n\t\tkey1 = &znode->parent->zbranch[0].key;\n\t}\n}\n\n \nstatic void insert_zbranch(struct ubifs_info *c, struct ubifs_znode *znode,\n\t\t\t   const struct ubifs_zbranch *zbr, int n)\n{\n\tint i;\n\n\tubifs_assert(c, ubifs_zn_dirty(znode));\n\n\tif (znode->level) {\n\t\tfor (i = znode->child_cnt; i > n; i--) {\n\t\t\tznode->zbranch[i] = znode->zbranch[i - 1];\n\t\t\tif (znode->zbranch[i].znode)\n\t\t\t\tznode->zbranch[i].znode->iip = i;\n\t\t}\n\t\tif (zbr->znode)\n\t\t\tzbr->znode->iip = n;\n\t} else\n\t\tfor (i = znode->child_cnt; i > n; i--)\n\t\t\tznode->zbranch[i] = znode->zbranch[i - 1];\n\n\tznode->zbranch[n] = *zbr;\n\tznode->child_cnt += 1;\n\n\t \n\tif (n == 0)\n\t\tznode->alt = 1;\n}\n\n \nstatic int tnc_insert(struct ubifs_info *c, struct ubifs_znode *znode,\n\t\t      struct ubifs_zbranch *zbr, int n)\n{\n\tstruct ubifs_znode *zn, *zi, *zp;\n\tint i, keep, move, appending = 0;\n\tunion ubifs_key *key = &zbr->key, *key1;\n\n\tubifs_assert(c, n >= 0 && n <= c->fanout);\n\n\t \nagain:\n\tzp = znode->parent;\n\tif (znode->child_cnt < c->fanout) {\n\t\tubifs_assert(c, n != c->fanout);\n\t\tdbg_tnck(key, \"inserted at %d level %d, key \", n, znode->level);\n\n\t\tinsert_zbranch(c, znode, zbr, n);\n\n\t\t \n\t\tif (n == 0 && zp && znode->iip == 0)\n\t\t\tcorrect_parent_keys(c, znode);\n\n\t\treturn 0;\n\t}\n\n\t \n\tdbg_tnck(key, \"splitting level %d, key \", znode->level);\n\n\tif (znode->alt)\n\t\t \n\t\tins_clr_old_idx_znode(c, znode);\n\n\tzn = kzalloc(c->max_znode_sz, GFP_NOFS);\n\tif (!zn)\n\t\treturn -ENOMEM;\n\tzn->parent = zp;\n\tzn->level = znode->level;\n\n\t \n\tif (znode->level == 0 && key_type(c, key) == UBIFS_DATA_KEY) {\n\t\t \n\t\tif (n == c->fanout) {\n\t\t\tkey1 = &znode->zbranch[n - 1].key;\n\t\t\tif (key_inum(c, key1) == key_inum(c, key) &&\n\t\t\t    key_type(c, key1) == UBIFS_DATA_KEY)\n\t\t\t\tappending = 1;\n\t\t} else\n\t\t\tgoto check_split;\n\t} else if (appending && n != c->fanout) {\n\t\t \n\t\tappending = 0;\ncheck_split:\n\t\tif (n >= (c->fanout + 1) / 2) {\n\t\t\tkey1 = &znode->zbranch[0].key;\n\t\t\tif (key_inum(c, key1) == key_inum(c, key) &&\n\t\t\t    key_type(c, key1) == UBIFS_DATA_KEY) {\n\t\t\t\tkey1 = &znode->zbranch[n].key;\n\t\t\t\tif (key_inum(c, key1) != key_inum(c, key) ||\n\t\t\t\t    key_type(c, key1) != UBIFS_DATA_KEY) {\n\t\t\t\t\tkeep = n;\n\t\t\t\t\tmove = c->fanout - keep;\n\t\t\t\t\tzi = znode;\n\t\t\t\t\tgoto do_split;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (appending) {\n\t\tkeep = c->fanout;\n\t\tmove = 0;\n\t} else {\n\t\tkeep = (c->fanout + 1) / 2;\n\t\tmove = c->fanout - keep;\n\t}\n\n\t \n\n\tif (n < keep) {\n\t\t \n\t\tzi = znode;\n\t\tmove += 1;\n\t\tkeep -= 1;\n\t} else {\n\t\t \n\t\tzi = zn;\n\t\tn -= keep;\n\t\t \n\t\tif (zn->level != 0)\n\t\t\tzbr->znode->parent = zn;\n\t}\n\ndo_split:\n\n\t__set_bit(DIRTY_ZNODE, &zn->flags);\n\tatomic_long_inc(&c->dirty_zn_cnt);\n\n\tzn->child_cnt = move;\n\tznode->child_cnt = keep;\n\n\tdbg_tnc(\"moving %d, keeping %d\", move, keep);\n\n\t \n\tfor (i = 0; i < move; i++) {\n\t\tzn->zbranch[i] = znode->zbranch[keep + i];\n\t\t \n\t\tif (zn->level != 0)\n\t\t\tif (zn->zbranch[i].znode) {\n\t\t\t\tzn->zbranch[i].znode->parent = zn;\n\t\t\t\tzn->zbranch[i].znode->iip = i;\n\t\t\t}\n\t}\n\n\t \n\tdbg_tnck(key, \"inserting at %d level %d, key \", n, zn->level);\n\n\tinsert_zbranch(c, zi, zbr, n);\n\n\t \n\tif (zp) {\n\t\tif (n == 0 && zi == znode && znode->iip == 0)\n\t\t\tcorrect_parent_keys(c, znode);\n\n\t\t \n\t\tn = znode->iip + 1;\n\n\t\t \n\t\tzbr->key = zn->zbranch[0].key;\n\t\tzbr->znode = zn;\n\t\tzbr->lnum = 0;\n\t\tzbr->offs = 0;\n\t\tzbr->len = 0;\n\t\tznode = zp;\n\n\t\tgoto again;\n\t}\n\n\t \n\tdbg_tnc(\"creating new zroot at level %d\", znode->level + 1);\n\n\tzi = kzalloc(c->max_znode_sz, GFP_NOFS);\n\tif (!zi)\n\t\treturn -ENOMEM;\n\n\tzi->child_cnt = 2;\n\tzi->level = znode->level + 1;\n\n\t__set_bit(DIRTY_ZNODE, &zi->flags);\n\tatomic_long_inc(&c->dirty_zn_cnt);\n\n\tzi->zbranch[0].key = znode->zbranch[0].key;\n\tzi->zbranch[0].znode = znode;\n\tzi->zbranch[0].lnum = c->zroot.lnum;\n\tzi->zbranch[0].offs = c->zroot.offs;\n\tzi->zbranch[0].len = c->zroot.len;\n\tzi->zbranch[1].key = zn->zbranch[0].key;\n\tzi->zbranch[1].znode = zn;\n\n\tc->zroot.lnum = 0;\n\tc->zroot.offs = 0;\n\tc->zroot.len = 0;\n\tc->zroot.znode = zi;\n\n\tzn->parent = zi;\n\tzn->iip = 1;\n\tznode->parent = zi;\n\tznode->iip = 0;\n\n\treturn 0;\n}\n\n \nint ubifs_tnc_add(struct ubifs_info *c, const union ubifs_key *key, int lnum,\n\t\t  int offs, int len, const u8 *hash)\n{\n\tint found, n, err = 0;\n\tstruct ubifs_znode *znode;\n\n\tmutex_lock(&c->tnc_mutex);\n\tdbg_tnck(key, \"%d:%d, len %d, key \", lnum, offs, len);\n\tfound = lookup_level0_dirty(c, key, &znode, &n);\n\tif (!found) {\n\t\tstruct ubifs_zbranch zbr;\n\n\t\tzbr.znode = NULL;\n\t\tzbr.lnum = lnum;\n\t\tzbr.offs = offs;\n\t\tzbr.len = len;\n\t\tubifs_copy_hash(c, hash, zbr.hash);\n\t\tkey_copy(c, key, &zbr.key);\n\t\terr = tnc_insert(c, znode, &zbr, n + 1);\n\t} else if (found == 1) {\n\t\tstruct ubifs_zbranch *zbr = &znode->zbranch[n];\n\n\t\tlnc_free(zbr);\n\t\terr = ubifs_add_dirt(c, zbr->lnum, zbr->len);\n\t\tzbr->lnum = lnum;\n\t\tzbr->offs = offs;\n\t\tzbr->len = len;\n\t\tubifs_copy_hash(c, hash, zbr->hash);\n\t} else\n\t\terr = found;\n\tif (!err)\n\t\terr = dbg_check_tnc(c, 0);\n\tmutex_unlock(&c->tnc_mutex);\n\n\treturn err;\n}\n\n \nint ubifs_tnc_replace(struct ubifs_info *c, const union ubifs_key *key,\n\t\t      int old_lnum, int old_offs, int lnum, int offs, int len)\n{\n\tint found, n, err = 0;\n\tstruct ubifs_znode *znode;\n\n\tmutex_lock(&c->tnc_mutex);\n\tdbg_tnck(key, \"old LEB %d:%d, new LEB %d:%d, len %d, key \", old_lnum,\n\t\t old_offs, lnum, offs, len);\n\tfound = lookup_level0_dirty(c, key, &znode, &n);\n\tif (found < 0) {\n\t\terr = found;\n\t\tgoto out_unlock;\n\t}\n\n\tif (found == 1) {\n\t\tstruct ubifs_zbranch *zbr = &znode->zbranch[n];\n\n\t\tfound = 0;\n\t\tif (zbr->lnum == old_lnum && zbr->offs == old_offs) {\n\t\t\tlnc_free(zbr);\n\t\t\terr = ubifs_add_dirt(c, zbr->lnum, zbr->len);\n\t\t\tif (err)\n\t\t\t\tgoto out_unlock;\n\t\t\tzbr->lnum = lnum;\n\t\t\tzbr->offs = offs;\n\t\t\tzbr->len = len;\n\t\t\tfound = 1;\n\t\t} else if (is_hash_key(c, key)) {\n\t\t\tfound = resolve_collision_directly(c, key, &znode, &n,\n\t\t\t\t\t\t\t   old_lnum, old_offs);\n\t\t\tdbg_tnc(\"rc returned %d, znode %p, n %d, LEB %d:%d\",\n\t\t\t\tfound, znode, n, old_lnum, old_offs);\n\t\t\tif (found < 0) {\n\t\t\t\terr = found;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\n\t\t\tif (found) {\n\t\t\t\t \n\t\t\t\tif (znode->cnext || !ubifs_zn_dirty(znode)) {\n\t\t\t\t\tznode = dirty_cow_bottom_up(c, znode);\n\t\t\t\t\tif (IS_ERR(znode)) {\n\t\t\t\t\t\terr = PTR_ERR(znode);\n\t\t\t\t\t\tgoto out_unlock;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tzbr = &znode->zbranch[n];\n\t\t\t\tlnc_free(zbr);\n\t\t\t\terr = ubifs_add_dirt(c, zbr->lnum,\n\t\t\t\t\t\t     zbr->len);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out_unlock;\n\t\t\t\tzbr->lnum = lnum;\n\t\t\t\tzbr->offs = offs;\n\t\t\t\tzbr->len = len;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!found)\n\t\terr = ubifs_add_dirt(c, lnum, len);\n\n\tif (!err)\n\t\terr = dbg_check_tnc(c, 0);\n\nout_unlock:\n\tmutex_unlock(&c->tnc_mutex);\n\treturn err;\n}\n\n \nint ubifs_tnc_add_nm(struct ubifs_info *c, const union ubifs_key *key,\n\t\t     int lnum, int offs, int len, const u8 *hash,\n\t\t     const struct fscrypt_name *nm)\n{\n\tint found, n, err = 0;\n\tstruct ubifs_znode *znode;\n\n\tmutex_lock(&c->tnc_mutex);\n\tdbg_tnck(key, \"LEB %d:%d, key \", lnum, offs);\n\tfound = lookup_level0_dirty(c, key, &znode, &n);\n\tif (found < 0) {\n\t\terr = found;\n\t\tgoto out_unlock;\n\t}\n\n\tif (found == 1) {\n\t\tif (c->replaying)\n\t\t\tfound = fallible_resolve_collision(c, key, &znode, &n,\n\t\t\t\t\t\t\t   nm, 1);\n\t\telse\n\t\t\tfound = resolve_collision(c, key, &znode, &n, nm);\n\t\tdbg_tnc(\"rc returned %d, znode %p, n %d\", found, znode, n);\n\t\tif (found < 0) {\n\t\t\terr = found;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t \n\t\tif (znode->cnext || !ubifs_zn_dirty(znode)) {\n\t\t\tznode = dirty_cow_bottom_up(c, znode);\n\t\t\tif (IS_ERR(znode)) {\n\t\t\t\terr = PTR_ERR(znode);\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t}\n\n\t\tif (found == 1) {\n\t\t\tstruct ubifs_zbranch *zbr = &znode->zbranch[n];\n\n\t\t\tlnc_free(zbr);\n\t\t\terr = ubifs_add_dirt(c, zbr->lnum, zbr->len);\n\t\t\tzbr->lnum = lnum;\n\t\t\tzbr->offs = offs;\n\t\t\tzbr->len = len;\n\t\t\tubifs_copy_hash(c, hash, zbr->hash);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tstruct ubifs_zbranch zbr;\n\n\t\tzbr.znode = NULL;\n\t\tzbr.lnum = lnum;\n\t\tzbr.offs = offs;\n\t\tzbr.len = len;\n\t\tubifs_copy_hash(c, hash, zbr.hash);\n\t\tkey_copy(c, key, &zbr.key);\n\t\terr = tnc_insert(c, znode, &zbr, n + 1);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\t\tif (c->replaying) {\n\t\t\t \n\t\t\tstruct fscrypt_name noname = { .disk_name = { .name = \"\", .len = 1 } };\n\n\t\t\terr = dbg_check_tnc(c, 0);\n\t\t\tmutex_unlock(&c->tnc_mutex);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\treturn ubifs_tnc_remove_nm(c, key, &noname);\n\t\t}\n\t}\n\nout_unlock:\n\tif (!err)\n\t\terr = dbg_check_tnc(c, 0);\n\tmutex_unlock(&c->tnc_mutex);\n\treturn err;\n}\n\n \nstatic int tnc_delete(struct ubifs_info *c, struct ubifs_znode *znode, int n)\n{\n\tstruct ubifs_zbranch *zbr;\n\tstruct ubifs_znode *zp;\n\tint i, err;\n\n\t \n\tubifs_assert(c, znode->level == 0);\n\tubifs_assert(c, n >= 0 && n < c->fanout);\n\tdbg_tnck(&znode->zbranch[n].key, \"deleting key \");\n\n\tzbr = &znode->zbranch[n];\n\tlnc_free(zbr);\n\n\terr = ubifs_add_dirt(c, zbr->lnum, zbr->len);\n\tif (err) {\n\t\tubifs_dump_znode(c, znode);\n\t\treturn err;\n\t}\n\n\t \n\tfor (i = n; i < znode->child_cnt - 1; i++)\n\t\tznode->zbranch[i] = znode->zbranch[i + 1];\n\tznode->child_cnt -= 1;\n\n\tif (znode->child_cnt > 0)\n\t\treturn 0;\n\n\t \n\n\tdo {\n\t\tubifs_assert(c, !ubifs_zn_obsolete(znode));\n\t\tubifs_assert(c, ubifs_zn_dirty(znode));\n\n\t\tzp = znode->parent;\n\t\tn = znode->iip;\n\n\t\tatomic_long_dec(&c->dirty_zn_cnt);\n\n\t\terr = insert_old_idx_znode(c, znode);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (znode->cnext) {\n\t\t\t__set_bit(OBSOLETE_ZNODE, &znode->flags);\n\t\t\tatomic_long_inc(&c->clean_zn_cnt);\n\t\t\tatomic_long_inc(&ubifs_clean_zn_cnt);\n\t\t} else\n\t\t\tkfree(znode);\n\t\tznode = zp;\n\t} while (znode->child_cnt == 1);  \n\n\t \n\tznode->child_cnt -= 1;\n\tubifs_assert(c, znode->level != 0);\n\tfor (i = n; i < znode->child_cnt; i++) {\n\t\tznode->zbranch[i] = znode->zbranch[i + 1];\n\t\tif (znode->zbranch[i].znode)\n\t\t\tznode->zbranch[i].znode->iip = i;\n\t}\n\n\t \n\tif (!znode->parent) {\n\t\twhile (znode->child_cnt == 1 && znode->level != 0) {\n\t\t\tzp = znode;\n\t\t\tzbr = &znode->zbranch[0];\n\t\t\tznode = get_znode(c, znode, 0);\n\t\t\tif (IS_ERR(znode))\n\t\t\t\treturn PTR_ERR(znode);\n\t\t\tznode = dirty_cow_znode(c, zbr);\n\t\t\tif (IS_ERR(znode))\n\t\t\t\treturn PTR_ERR(znode);\n\t\t\tznode->parent = NULL;\n\t\t\tznode->iip = 0;\n\t\t\tif (c->zroot.len) {\n\t\t\t\terr = insert_old_idx(c, c->zroot.lnum,\n\t\t\t\t\t\t     c->zroot.offs);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t\tc->zroot.lnum = zbr->lnum;\n\t\t\tc->zroot.offs = zbr->offs;\n\t\t\tc->zroot.len = zbr->len;\n\t\t\tc->zroot.znode = znode;\n\t\t\tubifs_assert(c, !ubifs_zn_obsolete(zp));\n\t\t\tubifs_assert(c, ubifs_zn_dirty(zp));\n\t\t\tatomic_long_dec(&c->dirty_zn_cnt);\n\n\t\t\tif (zp->cnext) {\n\t\t\t\t__set_bit(OBSOLETE_ZNODE, &zp->flags);\n\t\t\t\tatomic_long_inc(&c->clean_zn_cnt);\n\t\t\t\tatomic_long_inc(&ubifs_clean_zn_cnt);\n\t\t\t} else\n\t\t\t\tkfree(zp);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nint ubifs_tnc_remove(struct ubifs_info *c, const union ubifs_key *key)\n{\n\tint found, n, err = 0;\n\tstruct ubifs_znode *znode;\n\n\tmutex_lock(&c->tnc_mutex);\n\tdbg_tnck(key, \"key \");\n\tfound = lookup_level0_dirty(c, key, &znode, &n);\n\tif (found < 0) {\n\t\terr = found;\n\t\tgoto out_unlock;\n\t}\n\tif (found == 1)\n\t\terr = tnc_delete(c, znode, n);\n\tif (!err)\n\t\terr = dbg_check_tnc(c, 0);\n\nout_unlock:\n\tmutex_unlock(&c->tnc_mutex);\n\treturn err;\n}\n\n \nint ubifs_tnc_remove_nm(struct ubifs_info *c, const union ubifs_key *key,\n\t\t\tconst struct fscrypt_name *nm)\n{\n\tint n, err;\n\tstruct ubifs_znode *znode;\n\n\tmutex_lock(&c->tnc_mutex);\n\tdbg_tnck(key, \"key \");\n\terr = lookup_level0_dirty(c, key, &znode, &n);\n\tif (err < 0)\n\t\tgoto out_unlock;\n\n\tif (err) {\n\t\tif (c->replaying)\n\t\t\terr = fallible_resolve_collision(c, key, &znode, &n,\n\t\t\t\t\t\t\t nm, 0);\n\t\telse\n\t\t\terr = resolve_collision(c, key, &znode, &n, nm);\n\t\tdbg_tnc(\"rc returned %d, znode %p, n %d\", err, znode, n);\n\t\tif (err < 0)\n\t\t\tgoto out_unlock;\n\t\tif (err) {\n\t\t\t \n\t\t\tif (znode->cnext || !ubifs_zn_dirty(znode)) {\n\t\t\t\tznode = dirty_cow_bottom_up(c, znode);\n\t\t\t\tif (IS_ERR(znode)) {\n\t\t\t\t\terr = PTR_ERR(znode);\n\t\t\t\t\tgoto out_unlock;\n\t\t\t\t}\n\t\t\t}\n\t\t\terr = tnc_delete(c, znode, n);\n\t\t}\n\t}\n\nout_unlock:\n\tif (!err)\n\t\terr = dbg_check_tnc(c, 0);\n\tmutex_unlock(&c->tnc_mutex);\n\treturn err;\n}\n\n \nint ubifs_tnc_remove_dh(struct ubifs_info *c, const union ubifs_key *key,\n\t\t\tuint32_t cookie)\n{\n\tint n, err;\n\tstruct ubifs_znode *znode;\n\tstruct ubifs_dent_node *dent;\n\tstruct ubifs_zbranch *zbr;\n\n\tif (!c->double_hash)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&c->tnc_mutex);\n\terr = lookup_level0_dirty(c, key, &znode, &n);\n\tif (err <= 0)\n\t\tgoto out_unlock;\n\n\tzbr = &znode->zbranch[n];\n\tdent = kmalloc(UBIFS_MAX_DENT_NODE_SZ, GFP_NOFS);\n\tif (!dent) {\n\t\terr = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\terr = tnc_read_hashed_node(c, zbr, dent);\n\tif (err)\n\t\tgoto out_free;\n\n\t \n\tif (le32_to_cpu(dent->cookie) != cookie) {\n\t\tunion ubifs_key start_key;\n\n\t\tlowest_dent_key(c, &start_key, key_inum(c, key));\n\n\t\terr = ubifs_lookup_level0(c, &start_key, &znode, &n);\n\t\tif (unlikely(err < 0))\n\t\t\tgoto out_free;\n\n\t\terr = search_dh_cookie(c, key, dent, cookie, &znode, &n, err);\n\t\tif (err)\n\t\t\tgoto out_free;\n\t}\n\n\tif (znode->cnext || !ubifs_zn_dirty(znode)) {\n\t\tznode = dirty_cow_bottom_up(c, znode);\n\t\tif (IS_ERR(znode)) {\n\t\t\terr = PTR_ERR(znode);\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\terr = tnc_delete(c, znode, n);\n\nout_free:\n\tkfree(dent);\nout_unlock:\n\tif (!err)\n\t\terr = dbg_check_tnc(c, 0);\n\tmutex_unlock(&c->tnc_mutex);\n\treturn err;\n}\n\n \nstatic int key_in_range(struct ubifs_info *c, union ubifs_key *key,\n\t\t\tunion ubifs_key *from_key, union ubifs_key *to_key)\n{\n\tif (keys_cmp(c, key, from_key) < 0)\n\t\treturn 0;\n\tif (keys_cmp(c, key, to_key) > 0)\n\t\treturn 0;\n\treturn 1;\n}\n\n \nint ubifs_tnc_remove_range(struct ubifs_info *c, union ubifs_key *from_key,\n\t\t\t   union ubifs_key *to_key)\n{\n\tint i, n, k, err = 0;\n\tstruct ubifs_znode *znode;\n\tunion ubifs_key *key;\n\n\tmutex_lock(&c->tnc_mutex);\n\twhile (1) {\n\t\t \n\t\terr = ubifs_lookup_level0(c, from_key, &znode, &n);\n\t\tif (err < 0)\n\t\t\tgoto out_unlock;\n\n\t\tif (err)\n\t\t\tkey = from_key;\n\t\telse {\n\t\t\terr = tnc_next(c, &znode, &n);\n\t\t\tif (err == -ENOENT) {\n\t\t\t\terr = 0;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tif (err < 0)\n\t\t\t\tgoto out_unlock;\n\t\t\tkey = &znode->zbranch[n].key;\n\t\t\tif (!key_in_range(c, key, from_key, to_key)) {\n\t\t\t\terr = 0;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (znode->cnext || !ubifs_zn_dirty(znode)) {\n\t\t\tznode = dirty_cow_bottom_up(c, znode);\n\t\t\tif (IS_ERR(znode)) {\n\t\t\t\terr = PTR_ERR(znode);\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tfor (i = n + 1, k = 0; i < znode->child_cnt; i++, k++) {\n\t\t\tkey = &znode->zbranch[i].key;\n\t\t\tif (!key_in_range(c, key, from_key, to_key))\n\t\t\t\tbreak;\n\t\t\tlnc_free(&znode->zbranch[i]);\n\t\t\terr = ubifs_add_dirt(c, znode->zbranch[i].lnum,\n\t\t\t\t\t     znode->zbranch[i].len);\n\t\t\tif (err) {\n\t\t\t\tubifs_dump_znode(c, znode);\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tdbg_tnck(key, \"removing key \");\n\t\t}\n\t\tif (k) {\n\t\t\tfor (i = n + 1 + k; i < znode->child_cnt; i++)\n\t\t\t\tznode->zbranch[i - k] = znode->zbranch[i];\n\t\t\tznode->child_cnt -= k;\n\t\t}\n\n\t\t \n\t\terr = tnc_delete(c, znode, n);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\t}\n\nout_unlock:\n\tif (!err)\n\t\terr = dbg_check_tnc(c, 0);\n\tmutex_unlock(&c->tnc_mutex);\n\treturn err;\n}\n\n \nint ubifs_tnc_remove_ino(struct ubifs_info *c, ino_t inum)\n{\n\tunion ubifs_key key1, key2;\n\tstruct ubifs_dent_node *xent, *pxent = NULL;\n\tstruct fscrypt_name nm = {0};\n\n\tdbg_tnc(\"ino %lu\", (unsigned long)inum);\n\n\t \n\tlowest_xent_key(c, &key1, inum);\n\twhile (1) {\n\t\tino_t xattr_inum;\n\t\tint err;\n\n\t\txent = ubifs_tnc_next_ent(c, &key1, &nm);\n\t\tif (IS_ERR(xent)) {\n\t\t\terr = PTR_ERR(xent);\n\t\t\tif (err == -ENOENT)\n\t\t\t\tbreak;\n\t\t\tkfree(pxent);\n\t\t\treturn err;\n\t\t}\n\n\t\txattr_inum = le64_to_cpu(xent->inum);\n\t\tdbg_tnc(\"xent '%s', ino %lu\", xent->name,\n\t\t\t(unsigned long)xattr_inum);\n\n\t\tubifs_evict_xattr_inode(c, xattr_inum);\n\n\t\tfname_name(&nm) = xent->name;\n\t\tfname_len(&nm) = le16_to_cpu(xent->nlen);\n\t\terr = ubifs_tnc_remove_nm(c, &key1, &nm);\n\t\tif (err) {\n\t\t\tkfree(pxent);\n\t\t\tkfree(xent);\n\t\t\treturn err;\n\t\t}\n\n\t\tlowest_ino_key(c, &key1, xattr_inum);\n\t\thighest_ino_key(c, &key2, xattr_inum);\n\t\terr = ubifs_tnc_remove_range(c, &key1, &key2);\n\t\tif (err) {\n\t\t\tkfree(pxent);\n\t\t\tkfree(xent);\n\t\t\treturn err;\n\t\t}\n\n\t\tkfree(pxent);\n\t\tpxent = xent;\n\t\tkey_read(c, &xent->key, &key1);\n\t}\n\n\tkfree(pxent);\n\tlowest_ino_key(c, &key1, inum);\n\thighest_ino_key(c, &key2, inum);\n\n\treturn ubifs_tnc_remove_range(c, &key1, &key2);\n}\n\n \nstruct ubifs_dent_node *ubifs_tnc_next_ent(struct ubifs_info *c,\n\t\t\t\t\t   union ubifs_key *key,\n\t\t\t\t\t   const struct fscrypt_name *nm)\n{\n\tint n, err, type = key_type(c, key);\n\tstruct ubifs_znode *znode;\n\tstruct ubifs_dent_node *dent;\n\tstruct ubifs_zbranch *zbr;\n\tunion ubifs_key *dkey;\n\n\tdbg_tnck(key, \"key \");\n\tubifs_assert(c, is_hash_key(c, key));\n\n\tmutex_lock(&c->tnc_mutex);\n\terr = ubifs_lookup_level0(c, key, &znode, &n);\n\tif (unlikely(err < 0))\n\t\tgoto out_unlock;\n\n\tif (fname_len(nm) > 0) {\n\t\tif (err) {\n\t\t\t \n\t\t\tif (c->replaying)\n\t\t\t\terr = fallible_resolve_collision(c, key, &znode, &n,\n\t\t\t\t\t\t\t nm, 0);\n\t\t\telse\n\t\t\t\terr = resolve_collision(c, key, &znode, &n, nm);\n\t\t\tdbg_tnc(\"rc returned %d, znode %p, n %d\",\n\t\t\t\terr, znode, n);\n\t\t\tif (unlikely(err < 0))\n\t\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t \n\t\terr = tnc_next(c, &znode, &n);\n\t\tif (unlikely(err))\n\t\t\tgoto out_unlock;\n\t} else {\n\t\t \n\t\tif (!err) {\n\t\t\t \n\t\t\terr = tnc_next(c, &znode, &n);\n\t\t\tif (err)\n\t\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tzbr = &znode->zbranch[n];\n\tdent = kmalloc(zbr->len, GFP_NOFS);\n\tif (unlikely(!dent)) {\n\t\terr = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tdkey = &zbr->key;\n\tif (key_inum(c, dkey) != key_inum(c, key) ||\n\t    key_type(c, dkey) != type) {\n\t\terr = -ENOENT;\n\t\tgoto out_free;\n\t}\n\n\terr = tnc_read_hashed_node(c, zbr, dent);\n\tif (unlikely(err))\n\t\tgoto out_free;\n\n\tmutex_unlock(&c->tnc_mutex);\n\treturn dent;\n\nout_free:\n\tkfree(dent);\nout_unlock:\n\tmutex_unlock(&c->tnc_mutex);\n\treturn ERR_PTR(err);\n}\n\n \nstatic void tnc_destroy_cnext(struct ubifs_info *c)\n{\n\tstruct ubifs_znode *cnext;\n\n\tif (!c->cnext)\n\t\treturn;\n\tubifs_assert(c, c->cmt_state == COMMIT_BROKEN);\n\tcnext = c->cnext;\n\tdo {\n\t\tstruct ubifs_znode *znode = cnext;\n\n\t\tcnext = cnext->cnext;\n\t\tif (ubifs_zn_obsolete(znode))\n\t\t\tkfree(znode);\n\t\telse if (!ubifs_zn_cow(znode)) {\n\t\t\t \n\t\t\tatomic_long_inc(&c->clean_zn_cnt);\n\t\t\tatomic_long_inc(&ubifs_clean_zn_cnt);\n\t\t}\n\t} while (cnext && cnext != c->cnext);\n}\n\n \nvoid ubifs_tnc_close(struct ubifs_info *c)\n{\n\ttnc_destroy_cnext(c);\n\tif (c->zroot.znode) {\n\t\tlong n, freed;\n\n\t\tn = atomic_long_read(&c->clean_zn_cnt);\n\t\tfreed = ubifs_destroy_tnc_subtree(c, c->zroot.znode);\n\t\tubifs_assert(c, freed == n);\n\t\tatomic_long_sub(n, &ubifs_clean_zn_cnt);\n\t}\n\tkfree(c->gap_lebs);\n\tkfree(c->ilebs);\n\tdestroy_old_idx(c);\n}\n\n \nstatic struct ubifs_znode *left_znode(struct ubifs_info *c,\n\t\t\t\t      struct ubifs_znode *znode)\n{\n\tint level = znode->level;\n\n\twhile (1) {\n\t\tint n = znode->iip - 1;\n\n\t\t \n\t\tznode = znode->parent;\n\t\tif (!znode)\n\t\t\treturn NULL;\n\t\tif (n >= 0) {\n\t\t\t \n\t\t\tznode = get_znode(c, znode, n);\n\t\t\tif (IS_ERR(znode))\n\t\t\t\treturn znode;\n\t\t\twhile (znode->level != level) {\n\t\t\t\tn = znode->child_cnt - 1;\n\t\t\t\tznode = get_znode(c, znode, n);\n\t\t\t\tif (IS_ERR(znode))\n\t\t\t\t\treturn znode;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn znode;\n}\n\n \nstatic struct ubifs_znode *right_znode(struct ubifs_info *c,\n\t\t\t\t       struct ubifs_znode *znode)\n{\n\tint level = znode->level;\n\n\twhile (1) {\n\t\tint n = znode->iip + 1;\n\n\t\t \n\t\tznode = znode->parent;\n\t\tif (!znode)\n\t\t\treturn NULL;\n\t\tif (n < znode->child_cnt) {\n\t\t\t \n\t\t\tznode = get_znode(c, znode, n);\n\t\t\tif (IS_ERR(znode))\n\t\t\t\treturn znode;\n\t\t\twhile (znode->level != level) {\n\t\t\t\tznode = get_znode(c, znode, 0);\n\t\t\t\tif (IS_ERR(znode))\n\t\t\t\t\treturn znode;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn znode;\n}\n\n \nstatic struct ubifs_znode *lookup_znode(struct ubifs_info *c,\n\t\t\t\t\tunion ubifs_key *key, int level,\n\t\t\t\t\tint lnum, int offs)\n{\n\tstruct ubifs_znode *znode, *zn;\n\tint n, nn;\n\n\tubifs_assert(c, key_type(c, key) < UBIFS_INVALID_KEY);\n\n\t \n\tif (level < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t \n\tznode = c->zroot.znode;\n\tif (!znode) {\n\t\tznode = ubifs_load_znode(c, &c->zroot, NULL, 0);\n\t\tif (IS_ERR(znode))\n\t\t\treturn znode;\n\t}\n\t \n\tif (c->zroot.lnum == lnum && c->zroot.offs == offs)\n\t\treturn znode;\n\t \n\tif (level >= znode->level)\n\t\treturn NULL;\n\twhile (1) {\n\t\tubifs_search_zbranch(c, znode, key, &n);\n\t\tif (n < 0) {\n\t\t\t \n\t\t\tznode = left_znode(c, znode);\n\t\t\tif (!znode)\n\t\t\t\treturn NULL;\n\t\t\tif (IS_ERR(znode))\n\t\t\t\treturn znode;\n\t\t\tubifs_search_zbranch(c, znode, key, &n);\n\t\t\tubifs_assert(c, n >= 0);\n\t\t}\n\t\tif (znode->level == level + 1)\n\t\t\tbreak;\n\t\tznode = get_znode(c, znode, n);\n\t\tif (IS_ERR(znode))\n\t\t\treturn znode;\n\t}\n\t \n\tif (znode->zbranch[n].lnum == lnum && znode->zbranch[n].offs == offs)\n\t\treturn get_znode(c, znode, n);\n\t \n\tif (!is_hash_key(c, key))\n\t\treturn NULL;\n\t \n\tzn = znode;\n\tnn = n;\n\t \n\twhile (1) {\n\t\t \n\t\tif (n)\n\t\t\tn -= 1;\n\t\telse {\n\t\t\tznode = left_znode(c, znode);\n\t\t\tif (!znode)\n\t\t\t\tbreak;\n\t\t\tif (IS_ERR(znode))\n\t\t\t\treturn znode;\n\t\t\tn = znode->child_cnt - 1;\n\t\t}\n\t\t \n\t\tif (znode->zbranch[n].lnum == lnum &&\n\t\t    znode->zbranch[n].offs == offs)\n\t\t\treturn get_znode(c, znode, n);\n\t\t \n\t\tif (keys_cmp(c, &znode->zbranch[n].key, key) < 0)\n\t\t\tbreak;\n\t}\n\t \n\tznode = zn;\n\tn = nn;\n\t \n\twhile (1) {\n\t\t \n\t\tif (++n >= znode->child_cnt) {\n\t\t\tznode = right_znode(c, znode);\n\t\t\tif (!znode)\n\t\t\t\tbreak;\n\t\t\tif (IS_ERR(znode))\n\t\t\t\treturn znode;\n\t\t\tn = 0;\n\t\t}\n\t\t \n\t\tif (znode->zbranch[n].lnum == lnum &&\n\t\t    znode->zbranch[n].offs == offs)\n\t\t\treturn get_znode(c, znode, n);\n\t\t \n\t\tif (keys_cmp(c, &znode->zbranch[n].key, key) > 0)\n\t\t\tbreak;\n\t}\n\treturn NULL;\n}\n\n \nint is_idx_node_in_tnc(struct ubifs_info *c, union ubifs_key *key, int level,\n\t\t       int lnum, int offs)\n{\n\tstruct ubifs_znode *znode;\n\n\tznode = lookup_znode(c, key, level, lnum, offs);\n\tif (!znode)\n\t\treturn 0;\n\tif (IS_ERR(znode))\n\t\treturn PTR_ERR(znode);\n\n\treturn ubifs_zn_dirty(znode) ? 1 : 2;\n}\n\n \nstatic int is_leaf_node_in_tnc(struct ubifs_info *c, union ubifs_key *key,\n\t\t\t       int lnum, int offs)\n{\n\tstruct ubifs_zbranch *zbr;\n\tstruct ubifs_znode *znode, *zn;\n\tint n, found, err, nn;\n\tconst int unique = !is_hash_key(c, key);\n\n\tfound = ubifs_lookup_level0(c, key, &znode, &n);\n\tif (found < 0)\n\t\treturn found;  \n\tif (!found)\n\t\treturn 0;\n\tzbr = &znode->zbranch[n];\n\tif (lnum == zbr->lnum && offs == zbr->offs)\n\t\treturn 1;  \n\tif (unique)\n\t\treturn 0;\n\t \n\tzn = znode;\n\tnn = n;\n\t \n\twhile (1) {\n\t\terr = tnc_prev(c, &znode, &n);\n\t\tif (err == -ENOENT)\n\t\t\tbreak;\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (keys_cmp(c, key, &znode->zbranch[n].key))\n\t\t\tbreak;\n\t\tzbr = &znode->zbranch[n];\n\t\tif (lnum == zbr->lnum && offs == zbr->offs)\n\t\t\treturn 1;  \n\t}\n\t \n\tznode = zn;\n\tn = nn;\n\twhile (1) {\n\t\terr = tnc_next(c, &znode, &n);\n\t\tif (err) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\treturn 0;\n\t\t\treturn err;\n\t\t}\n\t\tif (keys_cmp(c, key, &znode->zbranch[n].key))\n\t\t\tbreak;\n\t\tzbr = &znode->zbranch[n];\n\t\tif (lnum == zbr->lnum && offs == zbr->offs)\n\t\t\treturn 1;  \n\t}\n\treturn 0;\n}\n\n \nint ubifs_tnc_has_node(struct ubifs_info *c, union ubifs_key *key, int level,\n\t\t       int lnum, int offs, int is_idx)\n{\n\tint err;\n\n\tmutex_lock(&c->tnc_mutex);\n\tif (is_idx) {\n\t\terr = is_idx_node_in_tnc(c, key, level, lnum, offs);\n\t\tif (err < 0)\n\t\t\tgoto out_unlock;\n\t\tif (err == 1)\n\t\t\t \n\t\t\terr = 0;\n\t\telse if (err == 2)\n\t\t\t \n\t\t\terr = 1;\n\t\telse\n\t\t\tBUG_ON(err != 0);\n\t} else\n\t\terr = is_leaf_node_in_tnc(c, key, lnum, offs);\n\nout_unlock:\n\tmutex_unlock(&c->tnc_mutex);\n\treturn err;\n}\n\n \nint ubifs_dirty_idx_node(struct ubifs_info *c, union ubifs_key *key, int level,\n\t\t\t int lnum, int offs)\n{\n\tstruct ubifs_znode *znode;\n\tint err = 0;\n\n\tmutex_lock(&c->tnc_mutex);\n\tznode = lookup_znode(c, key, level, lnum, offs);\n\tif (!znode)\n\t\tgoto out_unlock;\n\tif (IS_ERR(znode)) {\n\t\terr = PTR_ERR(znode);\n\t\tgoto out_unlock;\n\t}\n\tznode = dirty_cow_bottom_up(c, znode);\n\tif (IS_ERR(znode)) {\n\t\terr = PTR_ERR(znode);\n\t\tgoto out_unlock;\n\t}\n\nout_unlock:\n\tmutex_unlock(&c->tnc_mutex);\n\treturn err;\n}\n\n \nint dbg_check_inode_size(struct ubifs_info *c, const struct inode *inode,\n\t\t\t loff_t size)\n{\n\tint err, n;\n\tunion ubifs_key from_key, to_key, *key;\n\tstruct ubifs_znode *znode;\n\tunsigned int block;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 0;\n\tif (!dbg_is_chk_gen(c))\n\t\treturn 0;\n\n\tblock = (size + UBIFS_BLOCK_SIZE - 1) >> UBIFS_BLOCK_SHIFT;\n\tdata_key_init(c, &from_key, inode->i_ino, block);\n\thighest_data_key(c, &to_key, inode->i_ino);\n\n\tmutex_lock(&c->tnc_mutex);\n\terr = ubifs_lookup_level0(c, &from_key, &znode, &n);\n\tif (err < 0)\n\t\tgoto out_unlock;\n\n\tif (err) {\n\t\tkey = &from_key;\n\t\tgoto out_dump;\n\t}\n\n\terr = tnc_next(c, &znode, &n);\n\tif (err == -ENOENT) {\n\t\terr = 0;\n\t\tgoto out_unlock;\n\t}\n\tif (err < 0)\n\t\tgoto out_unlock;\n\n\tubifs_assert(c, err == 0);\n\tkey = &znode->zbranch[n].key;\n\tif (!key_in_range(c, key, &from_key, &to_key))\n\t\tgoto out_unlock;\n\nout_dump:\n\tblock = key_block(c, key);\n\tubifs_err(c, \"inode %lu has size %lld, but there are data at offset %lld\",\n\t\t  (unsigned long)inode->i_ino, size,\n\t\t  ((loff_t)block) << UBIFS_BLOCK_SHIFT);\n\tmutex_unlock(&c->tnc_mutex);\n\tubifs_dump_inode(c, inode);\n\tdump_stack();\n\treturn -EINVAL;\n\nout_unlock:\n\tmutex_unlock(&c->tnc_mutex);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}