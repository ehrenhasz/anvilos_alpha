{
  "module_name": "gc.c",
  "hash_id": "d576bbce2c3311fa1abd4d0f225ffc80f21ec468efb945e1c527d8f904eed0c3",
  "original_prompt": "Ingested from linux-6.6.14/fs/ubifs/gc.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/list_sort.h>\n#include \"ubifs.h\"\n\n \n#define SOFT_LEBS_LIMIT 4\n#define HARD_LEBS_LIMIT 32\n\n \nstatic int switch_gc_head(struct ubifs_info *c)\n{\n\tint err, gc_lnum = c->gc_lnum;\n\tstruct ubifs_wbuf *wbuf = &c->jheads[GCHD].wbuf;\n\n\tubifs_assert(c, gc_lnum != -1);\n\tdbg_gc(\"switch GC head from LEB %d:%d to LEB %d (waste %d bytes)\",\n\t       wbuf->lnum, wbuf->offs + wbuf->used, gc_lnum,\n\t       c->leb_size - wbuf->offs - wbuf->used);\n\n\terr = ubifs_wbuf_sync_nolock(wbuf);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = ubifs_leb_unmap(c, gc_lnum);\n\tif (err)\n\t\treturn err;\n\n\terr = ubifs_add_bud_to_log(c, GCHD, gc_lnum, 0);\n\tif (err)\n\t\treturn err;\n\n\tc->gc_lnum = -1;\n\terr = ubifs_wbuf_seek_nolock(wbuf, gc_lnum, 0);\n\treturn err;\n}\n\n \nstatic int data_nodes_cmp(void *priv, const struct list_head *a,\n\t\t\t  const struct list_head *b)\n{\n\tino_t inuma, inumb;\n\tstruct ubifs_info *c = priv;\n\tstruct ubifs_scan_node *sa, *sb;\n\n\tcond_resched();\n\tif (a == b)\n\t\treturn 0;\n\n\tsa = list_entry(a, struct ubifs_scan_node, list);\n\tsb = list_entry(b, struct ubifs_scan_node, list);\n\n\tubifs_assert(c, key_type(c, &sa->key) == UBIFS_DATA_KEY);\n\tubifs_assert(c, key_type(c, &sb->key) == UBIFS_DATA_KEY);\n\tubifs_assert(c, sa->type == UBIFS_DATA_NODE);\n\tubifs_assert(c, sb->type == UBIFS_DATA_NODE);\n\n\tinuma = key_inum(c, &sa->key);\n\tinumb = key_inum(c, &sb->key);\n\n\tif (inuma == inumb) {\n\t\tunsigned int blka = key_block(c, &sa->key);\n\t\tunsigned int blkb = key_block(c, &sb->key);\n\n\t\tif (blka <= blkb)\n\t\t\treturn -1;\n\t} else if (inuma <= inumb)\n\t\treturn -1;\n\n\treturn 1;\n}\n\n \nstatic int nondata_nodes_cmp(void *priv, const struct list_head *a,\n\t\t\t     const struct list_head *b)\n{\n\tino_t inuma, inumb;\n\tstruct ubifs_info *c = priv;\n\tstruct ubifs_scan_node *sa, *sb;\n\n\tcond_resched();\n\tif (a == b)\n\t\treturn 0;\n\n\tsa = list_entry(a, struct ubifs_scan_node, list);\n\tsb = list_entry(b, struct ubifs_scan_node, list);\n\n\tubifs_assert(c, key_type(c, &sa->key) != UBIFS_DATA_KEY &&\n\t\t     key_type(c, &sb->key) != UBIFS_DATA_KEY);\n\tubifs_assert(c, sa->type != UBIFS_DATA_NODE &&\n\t\t     sb->type != UBIFS_DATA_NODE);\n\n\t \n\tif (sa->type == UBIFS_INO_NODE) {\n\t\tif (sb->type == UBIFS_INO_NODE)\n\t\t\treturn sb->len - sa->len;\n\t\treturn -1;\n\t}\n\tif (sb->type == UBIFS_INO_NODE)\n\t\treturn 1;\n\n\tubifs_assert(c, key_type(c, &sa->key) == UBIFS_DENT_KEY ||\n\t\t     key_type(c, &sa->key) == UBIFS_XENT_KEY);\n\tubifs_assert(c, key_type(c, &sb->key) == UBIFS_DENT_KEY ||\n\t\t     key_type(c, &sb->key) == UBIFS_XENT_KEY);\n\tubifs_assert(c, sa->type == UBIFS_DENT_NODE ||\n\t\t     sa->type == UBIFS_XENT_NODE);\n\tubifs_assert(c, sb->type == UBIFS_DENT_NODE ||\n\t\t     sb->type == UBIFS_XENT_NODE);\n\n\tinuma = key_inum(c, &sa->key);\n\tinumb = key_inum(c, &sb->key);\n\n\tif (inuma == inumb) {\n\t\tuint32_t hasha = key_hash(c, &sa->key);\n\t\tuint32_t hashb = key_hash(c, &sb->key);\n\n\t\tif (hasha <= hashb)\n\t\t\treturn -1;\n\t} else if (inuma <= inumb)\n\t\treturn -1;\n\n\treturn 1;\n}\n\n \nstatic int sort_nodes(struct ubifs_info *c, struct ubifs_scan_leb *sleb,\n\t\t      struct list_head *nondata, int *min)\n{\n\tint err;\n\tstruct ubifs_scan_node *snod, *tmp;\n\n\t*min = INT_MAX;\n\n\t \n\tlist_for_each_entry_safe(snod, tmp, &sleb->nodes, list) {\n\t\tubifs_assert(c, snod->type == UBIFS_INO_NODE  ||\n\t\t\t     snod->type == UBIFS_DATA_NODE ||\n\t\t\t     snod->type == UBIFS_DENT_NODE ||\n\t\t\t     snod->type == UBIFS_XENT_NODE ||\n\t\t\t     snod->type == UBIFS_TRUN_NODE ||\n\t\t\t     snod->type == UBIFS_AUTH_NODE);\n\n\t\tif (snod->type != UBIFS_INO_NODE  &&\n\t\t    snod->type != UBIFS_DATA_NODE &&\n\t\t    snod->type != UBIFS_DENT_NODE &&\n\t\t    snod->type != UBIFS_XENT_NODE) {\n\t\t\t \n\t\t\tlist_del(&snod->list);\n\t\t\tkfree(snod);\n\t\t\tcontinue;\n\t\t}\n\n\t\tubifs_assert(c, key_type(c, &snod->key) == UBIFS_DATA_KEY ||\n\t\t\t     key_type(c, &snod->key) == UBIFS_INO_KEY  ||\n\t\t\t     key_type(c, &snod->key) == UBIFS_DENT_KEY ||\n\t\t\t     key_type(c, &snod->key) == UBIFS_XENT_KEY);\n\n\t\terr = ubifs_tnc_has_node(c, &snod->key, 0, sleb->lnum,\n\t\t\t\t\t snod->offs, 0);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (!err) {\n\t\t\t \n\t\t\tlist_del(&snod->list);\n\t\t\tkfree(snod);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (snod->len < *min)\n\t\t\t*min = snod->len;\n\n\t\tif (key_type(c, &snod->key) != UBIFS_DATA_KEY)\n\t\t\tlist_move_tail(&snod->list, nondata);\n\t}\n\n\t \n\tlist_sort(c, &sleb->nodes, &data_nodes_cmp);\n\tlist_sort(c, nondata, &nondata_nodes_cmp);\n\n\terr = dbg_check_data_nodes_order(c, &sleb->nodes);\n\tif (err)\n\t\treturn err;\n\terr = dbg_check_nondata_nodes_order(c, nondata);\n\tif (err)\n\t\treturn err;\n\treturn 0;\n}\n\n \nstatic int move_node(struct ubifs_info *c, struct ubifs_scan_leb *sleb,\n\t\t     struct ubifs_scan_node *snod, struct ubifs_wbuf *wbuf)\n{\n\tint err, new_lnum = wbuf->lnum, new_offs = wbuf->offs + wbuf->used;\n\n\tcond_resched();\n\terr = ubifs_wbuf_write_nolock(wbuf, snod->node, snod->len);\n\tif (err)\n\t\treturn err;\n\n\terr = ubifs_tnc_replace(c, &snod->key, sleb->lnum,\n\t\t\t\tsnod->offs, new_lnum, new_offs,\n\t\t\t\tsnod->len);\n\tlist_del(&snod->list);\n\tkfree(snod);\n\treturn err;\n}\n\n \nstatic int move_nodes(struct ubifs_info *c, struct ubifs_scan_leb *sleb)\n{\n\tint err, min;\n\tLIST_HEAD(nondata);\n\tstruct ubifs_wbuf *wbuf = &c->jheads[GCHD].wbuf;\n\n\tif (wbuf->lnum == -1) {\n\t\t \n\t\terr = switch_gc_head(c);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = sort_nodes(c, sleb, &nondata, &min);\n\tif (err)\n\t\tgoto out;\n\n\t \n\twhile (1) {\n\t\tint avail, moved = 0;\n\t\tstruct ubifs_scan_node *snod, *tmp;\n\n\t\t \n\t\tlist_for_each_entry_safe(snod, tmp, &sleb->nodes, list) {\n\t\t\tavail = c->leb_size - wbuf->offs - wbuf->used -\n\t\t\t\t\tubifs_auth_node_sz(c);\n\t\t\tif  (snod->len > avail)\n\t\t\t\t \n\t\t\t\tbreak;\n\n\t\t\terr = ubifs_shash_update(c, c->jheads[GCHD].log_hash,\n\t\t\t\t\t\t snod->node, snod->len);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\terr = move_node(c, sleb, snod, wbuf);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tmoved = 1;\n\t\t}\n\n\t\t \n\t\tlist_for_each_entry_safe(snod, tmp, &nondata, list) {\n\t\t\tavail = c->leb_size - wbuf->offs - wbuf->used -\n\t\t\t\t\tubifs_auth_node_sz(c);\n\t\t\tif (avail < min)\n\t\t\t\tbreak;\n\n\t\t\tif  (snod->len > avail) {\n\t\t\t\t \n\t\t\t\tif (key_type(c, &snod->key) == UBIFS_DENT_KEY ||\n\t\t\t\t    snod->len == UBIFS_INO_NODE_SZ)\n\t\t\t\t\tbreak;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\terr = ubifs_shash_update(c, c->jheads[GCHD].log_hash,\n\t\t\t\t\t\t snod->node, snod->len);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\terr = move_node(c, sleb, snod, wbuf);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tmoved = 1;\n\t\t}\n\n\t\tif (ubifs_authenticated(c) && moved) {\n\t\t\tstruct ubifs_auth_node *auth;\n\n\t\t\tauth = kmalloc(ubifs_auth_node_sz(c), GFP_NOFS);\n\t\t\tif (!auth) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\terr = ubifs_prepare_auth_node(c, auth,\n\t\t\t\t\t\tc->jheads[GCHD].log_hash);\n\t\t\tif (err) {\n\t\t\t\tkfree(auth);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\terr = ubifs_wbuf_write_nolock(wbuf, auth,\n\t\t\t\t\t\t      ubifs_auth_node_sz(c));\n\t\t\tif (err) {\n\t\t\t\tkfree(auth);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tubifs_add_dirt(c, wbuf->lnum, ubifs_auth_node_sz(c));\n\t\t}\n\n\t\tif (list_empty(&sleb->nodes) && list_empty(&nondata))\n\t\t\tbreak;\n\n\t\t \n\t\terr = switch_gc_head(c);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\treturn 0;\n\nout:\n\tlist_splice_tail(&nondata, &sleb->nodes);\n\treturn err;\n}\n\n \nstatic int gc_sync_wbufs(struct ubifs_info *c)\n{\n\tint err, i;\n\n\tfor (i = 0; i < c->jhead_cnt; i++) {\n\t\tif (i == GCHD)\n\t\t\tcontinue;\n\t\terr = ubifs_wbuf_sync(&c->jheads[i].wbuf);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\n \nint ubifs_garbage_collect_leb(struct ubifs_info *c, struct ubifs_lprops *lp)\n{\n\tstruct ubifs_scan_leb *sleb;\n\tstruct ubifs_scan_node *snod;\n\tstruct ubifs_wbuf *wbuf = &c->jheads[GCHD].wbuf;\n\tint err = 0, lnum = lp->lnum;\n\n\tubifs_assert(c, c->gc_lnum != -1 || wbuf->offs + wbuf->used == 0 ||\n\t\t     c->need_recovery);\n\tubifs_assert(c, c->gc_lnum != lnum);\n\tubifs_assert(c, wbuf->lnum != lnum);\n\n\tif (lp->free + lp->dirty == c->leb_size) {\n\t\t \n\t\tdbg_gc(\"LEB %d is free, return it\", lp->lnum);\n\t\tubifs_assert(c, !(lp->flags & LPROPS_INDEX));\n\n\t\tif (lp->free != c->leb_size) {\n\t\t\t \n\t\t\terr = gc_sync_wbufs(c);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\terr = ubifs_change_one_lp(c, lp->lnum, c->leb_size,\n\t\t\t\t\t\t  0, 0, 0, 0);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\terr = ubifs_leb_unmap(c, lp->lnum);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (c->gc_lnum == -1) {\n\t\t\tc->gc_lnum = lnum;\n\t\t\treturn LEB_RETAINED;\n\t\t}\n\n\t\treturn LEB_FREED;\n\t}\n\n\t \n\tsleb = ubifs_scan(c, lnum, 0, c->sbuf, 0);\n\tif (IS_ERR(sleb))\n\t\treturn PTR_ERR(sleb);\n\n\tubifs_assert(c, !list_empty(&sleb->nodes));\n\tsnod = list_entry(sleb->nodes.next, struct ubifs_scan_node, list);\n\n\tif (snod->type == UBIFS_IDX_NODE) {\n\t\tstruct ubifs_gced_idx_leb *idx_gc;\n\n\t\tdbg_gc(\"indexing LEB %d (free %d, dirty %d)\",\n\t\t       lnum, lp->free, lp->dirty);\n\t\tlist_for_each_entry(snod, &sleb->nodes, list) {\n\t\t\tstruct ubifs_idx_node *idx = snod->node;\n\t\t\tint level = le16_to_cpu(idx->level);\n\n\t\t\tubifs_assert(c, snod->type == UBIFS_IDX_NODE);\n\t\t\tkey_read(c, ubifs_idx_key(c, idx), &snod->key);\n\t\t\terr = ubifs_dirty_idx_node(c, &snod->key, level, lnum,\n\t\t\t\t\t\t   snod->offs);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tidx_gc = kmalloc(sizeof(struct ubifs_gced_idx_leb), GFP_NOFS);\n\t\tif (!idx_gc) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tidx_gc->lnum = lnum;\n\t\tidx_gc->unmap = 0;\n\t\tlist_add(&idx_gc->list, &c->idx_gc);\n\n\t\t \n\t\terr = ubifs_change_one_lp(c, lnum, c->leb_size, 0, 0,\n\t\t\t\t\t  LPROPS_INDEX, 1);\n\t\tif (err)\n\t\t\tgoto out;\n\t\terr = LEB_FREED_IDX;\n\t} else {\n\t\tdbg_gc(\"data LEB %d (free %d, dirty %d)\",\n\t\t       lnum, lp->free, lp->dirty);\n\n\t\terr = move_nodes(c, sleb);\n\t\tif (err)\n\t\t\tgoto out_inc_seq;\n\n\t\terr = gc_sync_wbufs(c);\n\t\tif (err)\n\t\t\tgoto out_inc_seq;\n\n\t\terr = ubifs_change_one_lp(c, lnum, c->leb_size, 0, 0, 0, 0);\n\t\tif (err)\n\t\t\tgoto out_inc_seq;\n\n\t\t \n\t\tc->gced_lnum = lnum;\n\t\tsmp_wmb();\n\t\tc->gc_seq += 1;\n\t\tsmp_wmb();\n\n\t\tif (c->gc_lnum == -1) {\n\t\t\tc->gc_lnum = lnum;\n\t\t\terr = LEB_RETAINED;\n\t\t} else {\n\t\t\terr = ubifs_wbuf_sync_nolock(wbuf);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\terr = ubifs_leb_unmap(c, lnum);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\terr = LEB_FREED;\n\t\t}\n\t}\n\nout:\n\tubifs_scan_destroy(sleb);\n\treturn err;\n\nout_inc_seq:\n\t \n\tc->gced_lnum = lnum;\n\tsmp_wmb();\n\tc->gc_seq += 1;\n\tsmp_wmb();\n\tgoto out;\n}\n\n \nint ubifs_garbage_collect(struct ubifs_info *c, int anyway)\n{\n\tint i, err, ret, min_space = c->dead_wm;\n\tstruct ubifs_lprops lp;\n\tstruct ubifs_wbuf *wbuf = &c->jheads[GCHD].wbuf;\n\n\tubifs_assert_cmt_locked(c);\n\tubifs_assert(c, !c->ro_media && !c->ro_mount);\n\n\tif (ubifs_gc_should_commit(c))\n\t\treturn -EAGAIN;\n\n\tmutex_lock_nested(&wbuf->io_mutex, wbuf->jhead);\n\n\tif (c->ro_error) {\n\t\tret = -EROFS;\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tubifs_assert(c, !wbuf->used);\n\n\tfor (i = 0; ; i++) {\n\t\tint space_before, space_after;\n\n\t\t \n\t\tlp.lnum = -1;\n\n\t\tcond_resched();\n\n\t\t \n\t\tif (ubifs_gc_should_commit(c)) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (i > SOFT_LEBS_LIMIT && !list_empty(&c->idx_gc)) {\n\t\t\t \n\t\t\tdbg_gc(\"soft limit, some index LEBs GC'ed, -EAGAIN\");\n\t\t\tubifs_commit_required(c);\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (i > HARD_LEBS_LIMIT) {\n\t\t\t \n\t\t\tdbg_gc(\"hard limit, -ENOSPC\");\n\t\t\tret = -ENOSPC;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tret = ubifs_find_dirty_leb(c, &lp, min_space, anyway ? 0 : 1);\n\t\tif (ret) {\n\t\t\tif (ret == -ENOSPC)\n\t\t\t\tdbg_gc(\"no more dirty LEBs\");\n\t\t\tbreak;\n\t\t}\n\n\t\tdbg_gc(\"found LEB %d: free %d, dirty %d, sum %d (min. space %d)\",\n\t\t       lp.lnum, lp.free, lp.dirty, lp.free + lp.dirty,\n\t\t       min_space);\n\n\t\tspace_before = c->leb_size - wbuf->offs - wbuf->used;\n\t\tif (wbuf->lnum == -1)\n\t\t\tspace_before = 0;\n\n\t\tret = ubifs_garbage_collect_leb(c, &lp);\n\t\tif (ret < 0) {\n\t\t\tif (ret == -EAGAIN) {\n\t\t\t\t \n\t\t\t\terr = ubifs_return_leb(c, lp.lnum);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\t \n\t\t\t\t\tubifs_ro_mode(c, ret);\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tlp.lnum = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (ret == LEB_FREED) {\n\t\t\t \n\t\t\tdbg_gc(\"LEB %d freed, return\", lp.lnum);\n\t\t\tret = lp.lnum;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ret == LEB_FREED_IDX) {\n\t\t\t \n\t\t\tdbg_gc(\"indexing LEB %d freed, continue\", lp.lnum);\n\t\t\tcontinue;\n\t\t}\n\n\t\tubifs_assert(c, ret == LEB_RETAINED);\n\t\tspace_after = c->leb_size - wbuf->offs - wbuf->used;\n\t\tdbg_gc(\"LEB %d retained, freed %d bytes\", lp.lnum,\n\t\t       space_after - space_before);\n\n\t\tif (space_after > space_before) {\n\t\t\t \n\t\t\tmin_space >>= 1;\n\t\t\tif (min_space < c->dead_wm)\n\t\t\t\tmin_space = c->dead_wm;\n\t\t\tcontinue;\n\t\t}\n\n\t\tdbg_gc(\"did not make progress\");\n\n\t\t \n\t\tif (i < SOFT_LEBS_LIMIT) {\n\t\t\tdbg_gc(\"try again\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tmin_space <<= 1;\n\t\tif (min_space > c->dark_wm)\n\t\t\tmin_space = c->dark_wm;\n\t\tdbg_gc(\"set min. space to %d\", min_space);\n\t}\n\n\tif (ret == -ENOSPC && !list_empty(&c->idx_gc)) {\n\t\tdbg_gc(\"no space, some index LEBs GC'ed, -EAGAIN\");\n\t\tubifs_commit_required(c);\n\t\tret = -EAGAIN;\n\t}\n\n\terr = ubifs_wbuf_sync_nolock(wbuf);\n\tif (!err)\n\t\terr = ubifs_leb_unmap(c, c->gc_lnum);\n\tif (err) {\n\t\tret = err;\n\t\tgoto out;\n\t}\nout_unlock:\n\tmutex_unlock(&wbuf->io_mutex);\n\treturn ret;\n\nout:\n\tubifs_assert(c, ret < 0);\n\tubifs_assert(c, ret != -ENOSPC && ret != -EAGAIN);\n\tubifs_wbuf_sync_nolock(wbuf);\n\tubifs_ro_mode(c, ret);\n\tmutex_unlock(&wbuf->io_mutex);\n\tif (lp.lnum != -1)\n\t\tubifs_return_leb(c, lp.lnum);\n\treturn ret;\n}\n\n \nint ubifs_gc_start_commit(struct ubifs_info *c)\n{\n\tstruct ubifs_gced_idx_leb *idx_gc;\n\tconst struct ubifs_lprops *lp;\n\tint err = 0, flags;\n\n\tubifs_get_lprops(c);\n\n\t \n\twhile (1) {\n\t\tlp = ubifs_fast_find_freeable(c);\n\t\tif (!lp)\n\t\t\tbreak;\n\t\tubifs_assert(c, !(lp->flags & LPROPS_TAKEN));\n\t\tubifs_assert(c, !(lp->flags & LPROPS_INDEX));\n\t\terr = ubifs_leb_unmap(c, lp->lnum);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tlp = ubifs_change_lp(c, lp, c->leb_size, 0, lp->flags, 0);\n\t\tif (IS_ERR(lp)) {\n\t\t\terr = PTR_ERR(lp);\n\t\t\tgoto out;\n\t\t}\n\t\tubifs_assert(c, !(lp->flags & LPROPS_TAKEN));\n\t\tubifs_assert(c, !(lp->flags & LPROPS_INDEX));\n\t}\n\n\t \n\tlist_for_each_entry(idx_gc, &c->idx_gc, list)\n\t\tidx_gc->unmap = 1;\n\n\t \n\twhile (1) {\n\t\tlp = ubifs_fast_find_frdi_idx(c);\n\t\tif (IS_ERR(lp)) {\n\t\t\terr = PTR_ERR(lp);\n\t\t\tgoto out;\n\t\t}\n\t\tif (!lp)\n\t\t\tbreak;\n\t\tidx_gc = kmalloc(sizeof(struct ubifs_gced_idx_leb), GFP_NOFS);\n\t\tif (!idx_gc) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tubifs_assert(c, !(lp->flags & LPROPS_TAKEN));\n\t\tubifs_assert(c, lp->flags & LPROPS_INDEX);\n\t\t \n\t\tflags = (lp->flags | LPROPS_TAKEN) ^ LPROPS_INDEX;\n\t\tlp = ubifs_change_lp(c, lp, c->leb_size, 0, flags, 1);\n\t\tif (IS_ERR(lp)) {\n\t\t\terr = PTR_ERR(lp);\n\t\t\tkfree(idx_gc);\n\t\t\tgoto out;\n\t\t}\n\t\tubifs_assert(c, lp->flags & LPROPS_TAKEN);\n\t\tubifs_assert(c, !(lp->flags & LPROPS_INDEX));\n\t\tidx_gc->lnum = lp->lnum;\n\t\tidx_gc->unmap = 1;\n\t\tlist_add(&idx_gc->list, &c->idx_gc);\n\t}\nout:\n\tubifs_release_lprops(c);\n\treturn err;\n}\n\n \nint ubifs_gc_end_commit(struct ubifs_info *c)\n{\n\tstruct ubifs_gced_idx_leb *idx_gc, *tmp;\n\tstruct ubifs_wbuf *wbuf;\n\tint err = 0;\n\n\twbuf = &c->jheads[GCHD].wbuf;\n\tmutex_lock_nested(&wbuf->io_mutex, wbuf->jhead);\n\tlist_for_each_entry_safe(idx_gc, tmp, &c->idx_gc, list)\n\t\tif (idx_gc->unmap) {\n\t\t\tdbg_gc(\"LEB %d\", idx_gc->lnum);\n\t\t\terr = ubifs_leb_unmap(c, idx_gc->lnum);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\terr = ubifs_change_one_lp(c, idx_gc->lnum, LPROPS_NC,\n\t\t\t\t\t  LPROPS_NC, 0, LPROPS_TAKEN, -1);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tlist_del(&idx_gc->list);\n\t\t\tkfree(idx_gc);\n\t\t}\nout:\n\tmutex_unlock(&wbuf->io_mutex);\n\treturn err;\n}\n\n \nvoid ubifs_destroy_idx_gc(struct ubifs_info *c)\n{\n\twhile (!list_empty(&c->idx_gc)) {\n\t\tstruct ubifs_gced_idx_leb *idx_gc;\n\n\t\tidx_gc = list_entry(c->idx_gc.next, struct ubifs_gced_idx_leb,\n\t\t\t\t    list);\n\t\tc->idx_gc_cnt -= 1;\n\t\tlist_del(&idx_gc->list);\n\t\tkfree(idx_gc);\n\t}\n}\n\n \nint ubifs_get_idx_gc_leb(struct ubifs_info *c)\n{\n\tstruct ubifs_gced_idx_leb *idx_gc;\n\tint lnum;\n\n\tif (list_empty(&c->idx_gc))\n\t\treturn -ENOSPC;\n\tidx_gc = list_entry(c->idx_gc.next, struct ubifs_gced_idx_leb, list);\n\tlnum = idx_gc->lnum;\n\t \n\tlist_del(&idx_gc->list);\n\tkfree(idx_gc);\n\treturn lnum;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}