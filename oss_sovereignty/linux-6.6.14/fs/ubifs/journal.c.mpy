{
  "module_name": "journal.c",
  "hash_id": "1aa104b59461317c46a7be81bfa8992994a0a5580fe84796ffab6f1795d31283",
  "original_prompt": "Ingested from linux-6.6.14/fs/ubifs/journal.c",
  "human_readable_source": "\n \n\n \n\n#include \"ubifs.h\"\n\n \nstatic inline void zero_ino_node_unused(struct ubifs_ino_node *ino)\n{\n\tmemset(ino->padding1, 0, 4);\n\tmemset(ino->padding2, 0, 26);\n}\n\n \nstatic inline void zero_dent_node_unused(struct ubifs_dent_node *dent)\n{\n\tdent->padding1 = 0;\n}\n\n \nstatic inline void zero_trun_node_unused(struct ubifs_trun_node *trun)\n{\n\tmemset(trun->padding, 0, 12);\n}\n\nstatic void ubifs_add_auth_dirt(struct ubifs_info *c, int lnum)\n{\n\tif (ubifs_authenticated(c))\n\t\tubifs_add_dirt(c, lnum, ubifs_auth_node_sz(c));\n}\n\n \nstatic int reserve_space(struct ubifs_info *c, int jhead, int len)\n{\n\tint err = 0, err1, retries = 0, avail, lnum, offs, squeeze;\n\tstruct ubifs_wbuf *wbuf = &c->jheads[jhead].wbuf;\n\n\t \n\tubifs_assert(c, !c->ro_media && !c->ro_mount);\n\tsqueeze = (jhead == BASEHD);\nagain:\n\tmutex_lock_nested(&wbuf->io_mutex, wbuf->jhead);\n\n\tif (c->ro_error) {\n\t\terr = -EROFS;\n\t\tgoto out_unlock;\n\t}\n\n\tavail = c->leb_size - wbuf->offs - wbuf->used;\n\tif (wbuf->lnum != -1 && avail >= len)\n\t\treturn 0;\n\n\t \n\tlnum = ubifs_find_free_space(c, len, &offs, squeeze);\n\tif (lnum >= 0)\n\t\tgoto out;\n\n\terr = lnum;\n\tif (err != -ENOSPC)\n\t\tgoto out_unlock;\n\n\t \n\tdbg_jnl(\"no free space in jhead %s, run GC\", dbg_jhead(jhead));\n\tmutex_unlock(&wbuf->io_mutex);\n\n\tlnum = ubifs_garbage_collect(c, 0);\n\tif (lnum < 0) {\n\t\terr = lnum;\n\t\tif (err != -ENOSPC)\n\t\t\treturn err;\n\n\t\t \n\t\tdbg_jnl(\"GC couldn't make a free LEB for jhead %s\",\n\t\t\tdbg_jhead(jhead));\n\t\tif (retries++ < 2) {\n\t\t\tdbg_jnl(\"retry (%d)\", retries);\n\t\t\tgoto again;\n\t\t}\n\n\t\tdbg_jnl(\"return -ENOSPC\");\n\t\treturn err;\n\t}\n\n\tmutex_lock_nested(&wbuf->io_mutex, wbuf->jhead);\n\tdbg_jnl(\"got LEB %d for jhead %s\", lnum, dbg_jhead(jhead));\n\tavail = c->leb_size - wbuf->offs - wbuf->used;\n\n\tif (wbuf->lnum != -1 && avail >= len) {\n\t\t \n\t\tdbg_jnl(\"return LEB %d back, already have LEB %d:%d\",\n\t\t\tlnum, wbuf->lnum, wbuf->offs + wbuf->used);\n\t\terr = ubifs_return_leb(c, lnum);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\t\treturn 0;\n\t}\n\n\toffs = 0;\n\nout:\n\t \n\terr = ubifs_wbuf_sync_nolock(wbuf);\n\tif (err)\n\t\tgoto out_return;\n\terr = ubifs_add_bud_to_log(c, jhead, lnum, offs);\n\tif (err)\n\t\tgoto out_return;\n\terr = ubifs_wbuf_seek_nolock(wbuf, lnum, offs);\n\tif (err)\n\t\tgoto out_unlock;\n\n\treturn 0;\n\nout_unlock:\n\tmutex_unlock(&wbuf->io_mutex);\n\treturn err;\n\nout_return:\n\t \n\tubifs_assert(c, err < 0);\n\terr1 = ubifs_return_leb(c, lnum);\n\tif (err1 && err == -EAGAIN)\n\t\t \n\t\terr = err1;\n\tmutex_unlock(&wbuf->io_mutex);\n\treturn err;\n}\n\nstatic int ubifs_hash_nodes(struct ubifs_info *c, void *node,\n\t\t\t     int len, struct shash_desc *hash)\n{\n\tint auth_node_size = ubifs_auth_node_sz(c);\n\tint err;\n\n\twhile (1) {\n\t\tconst struct ubifs_ch *ch = node;\n\t\tint nodelen = le32_to_cpu(ch->len);\n\n\t\tubifs_assert(c, len >= auth_node_size);\n\n\t\tif (len == auth_node_size)\n\t\t\tbreak;\n\n\t\tubifs_assert(c, len > nodelen);\n\t\tubifs_assert(c, ch->magic == cpu_to_le32(UBIFS_NODE_MAGIC));\n\n\t\terr = ubifs_shash_update(c, hash, (void *)node, nodelen);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tnode += ALIGN(nodelen, 8);\n\t\tlen -= ALIGN(nodelen, 8);\n\t}\n\n\treturn ubifs_prepare_auth_node(c, node, hash);\n}\n\n \nstatic int write_head(struct ubifs_info *c, int jhead, void *buf, int len,\n\t\t      int *lnum, int *offs, int sync)\n{\n\tint err;\n\tstruct ubifs_wbuf *wbuf = &c->jheads[jhead].wbuf;\n\n\tubifs_assert(c, jhead != GCHD);\n\n\t*lnum = c->jheads[jhead].wbuf.lnum;\n\t*offs = c->jheads[jhead].wbuf.offs + c->jheads[jhead].wbuf.used;\n\tdbg_jnl(\"jhead %s, LEB %d:%d, len %d\",\n\t\tdbg_jhead(jhead), *lnum, *offs, len);\n\n\tif (ubifs_authenticated(c)) {\n\t\terr = ubifs_hash_nodes(c, buf, len, c->jheads[jhead].log_hash);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = ubifs_wbuf_write_nolock(wbuf, buf, len);\n\tif (err)\n\t\treturn err;\n\tif (sync)\n\t\terr = ubifs_wbuf_sync_nolock(wbuf);\n\treturn err;\n}\n\n \nstatic int make_reservation(struct ubifs_info *c, int jhead, int len)\n{\n\tint err, cmt_retries = 0, nospc_retries = 0;\n\nagain:\n\tdown_read(&c->commit_sem);\n\terr = reserve_space(c, jhead, len);\n\tif (!err)\n\t\t \n\t\treturn 0;\n\tup_read(&c->commit_sem);\n\n\tif (err == -ENOSPC) {\n\t\t \n\t\tif (nospc_retries++ < 2) {\n\t\t\tdbg_jnl(\"no space, retry\");\n\t\t\terr = -EAGAIN;\n\t\t}\n\n\t\t \n\t}\n\n\tif (err != -EAGAIN)\n\t\tgoto out;\n\n\t \n\tif (cmt_retries > 128) {\n\t\t \n\t\tubifs_err(c, \"stuck in space allocation\");\n\t\terr = -ENOSPC;\n\t\tgoto out;\n\t} else if (cmt_retries > 32)\n\t\tubifs_warn(c, \"too many space allocation re-tries (%d)\",\n\t\t\t   cmt_retries);\n\n\tdbg_jnl(\"-EAGAIN, commit and retry (retried %d times)\",\n\t\tcmt_retries);\n\tcmt_retries += 1;\n\n\terr = ubifs_run_commit(c);\n\tif (err)\n\t\treturn err;\n\tgoto again;\n\nout:\n\tubifs_err(c, \"cannot reserve %d bytes in jhead %d, error %d\",\n\t\t  len, jhead, err);\n\tif (err == -ENOSPC) {\n\t\t \n\t\tdown_write(&c->commit_sem);\n\t\tdump_stack();\n\t\tubifs_dump_budg(c, &c->bi);\n\t\tubifs_dump_lprops(c);\n\t\tcmt_retries = dbg_check_lprops(c);\n\t\tup_write(&c->commit_sem);\n\t}\n\treturn err;\n}\n\n \nstatic inline void release_head(struct ubifs_info *c, int jhead)\n{\n\tmutex_unlock(&c->jheads[jhead].wbuf.io_mutex);\n}\n\n \nstatic void finish_reservation(struct ubifs_info *c)\n{\n\tup_read(&c->commit_sem);\n}\n\n \nstatic int get_dent_type(int mode)\n{\n\tswitch (mode & S_IFMT) {\n\tcase S_IFREG:\n\t\treturn UBIFS_ITYPE_REG;\n\tcase S_IFDIR:\n\t\treturn UBIFS_ITYPE_DIR;\n\tcase S_IFLNK:\n\t\treturn UBIFS_ITYPE_LNK;\n\tcase S_IFBLK:\n\t\treturn UBIFS_ITYPE_BLK;\n\tcase S_IFCHR:\n\t\treturn UBIFS_ITYPE_CHR;\n\tcase S_IFIFO:\n\t\treturn UBIFS_ITYPE_FIFO;\n\tcase S_IFSOCK:\n\t\treturn UBIFS_ITYPE_SOCK;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn 0;\n}\n\n \nstatic void pack_inode(struct ubifs_info *c, struct ubifs_ino_node *ino,\n\t\t       const struct inode *inode, int last)\n{\n\tint data_len = 0, last_reference = !inode->i_nlink;\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\n\tino->ch.node_type = UBIFS_INO_NODE;\n\tino_key_init_flash(c, &ino->key, inode->i_ino);\n\tino->creat_sqnum = cpu_to_le64(ui->creat_sqnum);\n\tino->atime_sec  = cpu_to_le64(inode->i_atime.tv_sec);\n\tino->atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);\n\tino->ctime_sec  = cpu_to_le64(inode_get_ctime(inode).tv_sec);\n\tino->ctime_nsec = cpu_to_le32(inode_get_ctime(inode).tv_nsec);\n\tino->mtime_sec  = cpu_to_le64(inode->i_mtime.tv_sec);\n\tino->mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\tino->uid   = cpu_to_le32(i_uid_read(inode));\n\tino->gid   = cpu_to_le32(i_gid_read(inode));\n\tino->mode  = cpu_to_le32(inode->i_mode);\n\tino->flags = cpu_to_le32(ui->flags);\n\tino->size  = cpu_to_le64(ui->ui_size);\n\tino->nlink = cpu_to_le32(inode->i_nlink);\n\tino->compr_type  = cpu_to_le16(ui->compr_type);\n\tino->data_len    = cpu_to_le32(ui->data_len);\n\tino->xattr_cnt   = cpu_to_le32(ui->xattr_cnt);\n\tino->xattr_size  = cpu_to_le32(ui->xattr_size);\n\tino->xattr_names = cpu_to_le32(ui->xattr_names);\n\tzero_ino_node_unused(ino);\n\n\t \n\tif (!last_reference) {\n\t\tmemcpy(ino->data, ui->data, ui->data_len);\n\t\tdata_len = ui->data_len;\n\t}\n\n\tubifs_prep_grp_node(c, ino, UBIFS_INO_NODE_SZ + data_len, last);\n}\n\n \nstatic void mark_inode_clean(struct ubifs_info *c, struct ubifs_inode *ui)\n{\n\tif (ui->dirty)\n\t\tubifs_release_dirty_inode_budget(c, ui);\n\tui->dirty = 0;\n}\n\nstatic void set_dent_cookie(struct ubifs_info *c, struct ubifs_dent_node *dent)\n{\n\tif (c->double_hash)\n\t\tdent->cookie = (__force __le32) get_random_u32();\n\telse\n\t\tdent->cookie = 0;\n}\n\n \nint ubifs_jnl_update(struct ubifs_info *c, const struct inode *dir,\n\t\t     const struct fscrypt_name *nm, const struct inode *inode,\n\t\t     int deletion, int xent)\n{\n\tint err, dlen, ilen, len, lnum, ino_offs, dent_offs, orphan_added = 0;\n\tint aligned_dlen, aligned_ilen, sync = IS_DIRSYNC(dir);\n\tint last_reference = !!(deletion && inode->i_nlink == 0);\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\tstruct ubifs_inode *host_ui = ubifs_inode(dir);\n\tstruct ubifs_dent_node *dent;\n\tstruct ubifs_ino_node *ino;\n\tunion ubifs_key dent_key, ino_key;\n\tu8 hash_dent[UBIFS_HASH_ARR_SZ];\n\tu8 hash_ino[UBIFS_HASH_ARR_SZ];\n\tu8 hash_ino_host[UBIFS_HASH_ARR_SZ];\n\n\tubifs_assert(c, mutex_is_locked(&host_ui->ui_mutex));\n\n\tdlen = UBIFS_DENT_NODE_SZ + fname_len(nm) + 1;\n\tilen = UBIFS_INO_NODE_SZ;\n\n\t \n\tif (!last_reference) {\n\t\tilen += ui->data_len;\n\t\tsync |= IS_SYNC(inode);\n\t}\n\n\taligned_dlen = ALIGN(dlen, 8);\n\taligned_ilen = ALIGN(ilen, 8);\n\n\tlen = aligned_dlen + aligned_ilen + UBIFS_INO_NODE_SZ;\n\t \n\tif (ubifs_authenticated(c))\n\t\tlen += ALIGN(host_ui->data_len, 8) + ubifs_auth_node_sz(c);\n\telse\n\t\tlen += host_ui->data_len;\n\n\tdent = kzalloc(len, GFP_NOFS);\n\tif (!dent)\n\t\treturn -ENOMEM;\n\n\t \n\terr = make_reservation(c, BASEHD, len);\n\tif (err)\n\t\tgoto out_free;\n\n\tif (!xent) {\n\t\tdent->ch.node_type = UBIFS_DENT_NODE;\n\t\tif (fname_name(nm) == NULL)\n\t\t\tdent_key_init_hash(c, &dent_key, dir->i_ino, nm->hash);\n\t\telse\n\t\t\tdent_key_init(c, &dent_key, dir->i_ino, nm);\n\t} else {\n\t\tdent->ch.node_type = UBIFS_XENT_NODE;\n\t\txent_key_init(c, &dent_key, dir->i_ino, nm);\n\t}\n\n\tkey_write(c, &dent_key, dent->key);\n\tdent->inum = deletion ? 0 : cpu_to_le64(inode->i_ino);\n\tdent->type = get_dent_type(inode->i_mode);\n\tdent->nlen = cpu_to_le16(fname_len(nm));\n\tmemcpy(dent->name, fname_name(nm), fname_len(nm));\n\tdent->name[fname_len(nm)] = '\\0';\n\tset_dent_cookie(c, dent);\n\n\tzero_dent_node_unused(dent);\n\tubifs_prep_grp_node(c, dent, dlen, 0);\n\terr = ubifs_node_calc_hash(c, dent, hash_dent);\n\tif (err)\n\t\tgoto out_release;\n\n\tino = (void *)dent + aligned_dlen;\n\tpack_inode(c, ino, inode, 0);\n\terr = ubifs_node_calc_hash(c, ino, hash_ino);\n\tif (err)\n\t\tgoto out_release;\n\n\tino = (void *)ino + aligned_ilen;\n\tpack_inode(c, ino, dir, 1);\n\terr = ubifs_node_calc_hash(c, ino, hash_ino_host);\n\tif (err)\n\t\tgoto out_release;\n\n\tif (last_reference) {\n\t\terr = ubifs_add_orphan(c, inode->i_ino);\n\t\tif (err) {\n\t\t\trelease_head(c, BASEHD);\n\t\t\tgoto out_finish;\n\t\t}\n\t\tui->del_cmtno = c->cmt_no;\n\t\torphan_added = 1;\n\t}\n\n\terr = write_head(c, BASEHD, dent, len, &lnum, &dent_offs, sync);\n\tif (err)\n\t\tgoto out_release;\n\tif (!sync) {\n\t\tstruct ubifs_wbuf *wbuf = &c->jheads[BASEHD].wbuf;\n\n\t\tubifs_wbuf_add_ino_nolock(wbuf, inode->i_ino);\n\t\tubifs_wbuf_add_ino_nolock(wbuf, dir->i_ino);\n\t}\n\trelease_head(c, BASEHD);\n\tkfree(dent);\n\tubifs_add_auth_dirt(c, lnum);\n\n\tif (deletion) {\n\t\tif (fname_name(nm) == NULL)\n\t\t\terr = ubifs_tnc_remove_dh(c, &dent_key, nm->minor_hash);\n\t\telse\n\t\t\terr = ubifs_tnc_remove_nm(c, &dent_key, nm);\n\t\tif (err)\n\t\t\tgoto out_ro;\n\t\terr = ubifs_add_dirt(c, lnum, dlen);\n\t} else\n\t\terr = ubifs_tnc_add_nm(c, &dent_key, lnum, dent_offs, dlen,\n\t\t\t\t       hash_dent, nm);\n\tif (err)\n\t\tgoto out_ro;\n\n\t \n\tino_key_init(c, &ino_key, inode->i_ino);\n\tino_offs = dent_offs + aligned_dlen;\n\terr = ubifs_tnc_add(c, &ino_key, lnum, ino_offs, ilen, hash_ino);\n\tif (err)\n\t\tgoto out_ro;\n\n\tino_key_init(c, &ino_key, dir->i_ino);\n\tino_offs += aligned_ilen;\n\terr = ubifs_tnc_add(c, &ino_key, lnum, ino_offs,\n\t\t\t    UBIFS_INO_NODE_SZ + host_ui->data_len, hash_ino_host);\n\tif (err)\n\t\tgoto out_ro;\n\n\tfinish_reservation(c);\n\tspin_lock(&ui->ui_lock);\n\tui->synced_i_size = ui->ui_size;\n\tspin_unlock(&ui->ui_lock);\n\tif (xent) {\n\t\tspin_lock(&host_ui->ui_lock);\n\t\thost_ui->synced_i_size = host_ui->ui_size;\n\t\tspin_unlock(&host_ui->ui_lock);\n\t}\n\tmark_inode_clean(c, ui);\n\tmark_inode_clean(c, host_ui);\n\treturn 0;\n\nout_finish:\n\tfinish_reservation(c);\nout_free:\n\tkfree(dent);\n\treturn err;\n\nout_release:\n\trelease_head(c, BASEHD);\n\tkfree(dent);\nout_ro:\n\tubifs_ro_mode(c, err);\n\tif (orphan_added)\n\t\tubifs_delete_orphan(c, inode->i_ino);\n\tfinish_reservation(c);\n\treturn err;\n}\n\n \nint ubifs_jnl_write_data(struct ubifs_info *c, const struct inode *inode,\n\t\t\t const union ubifs_key *key, const void *buf, int len)\n{\n\tstruct ubifs_data_node *data;\n\tint err, lnum, offs, compr_type, out_len, compr_len, auth_len;\n\tint dlen = COMPRESSED_DATA_NODE_BUF_SZ, allocated = 1;\n\tint write_len;\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\tbool encrypted = IS_ENCRYPTED(inode);\n\tu8 hash[UBIFS_HASH_ARR_SZ];\n\n\tdbg_jnlk(key, \"ino %lu, blk %u, len %d, key \",\n\t\t(unsigned long)key_inum(c, key), key_block(c, key), len);\n\tubifs_assert(c, len <= UBIFS_BLOCK_SIZE);\n\n\tif (encrypted)\n\t\tdlen += UBIFS_CIPHER_BLOCK_SIZE;\n\n\tauth_len = ubifs_auth_node_sz(c);\n\n\tdata = kmalloc(dlen + auth_len, GFP_NOFS | __GFP_NOWARN);\n\tif (!data) {\n\t\t \n\t\tallocated = 0;\n\t\tmutex_lock(&c->write_reserve_mutex);\n\t\tdata = c->write_reserve_buf;\n\t}\n\n\tdata->ch.node_type = UBIFS_DATA_NODE;\n\tkey_write(c, key, &data->key);\n\tdata->size = cpu_to_le32(len);\n\n\tif (!(ui->flags & UBIFS_COMPR_FL))\n\t\t \n\t\tcompr_type = UBIFS_COMPR_NONE;\n\telse\n\t\tcompr_type = ui->compr_type;\n\n\tout_len = compr_len = dlen - UBIFS_DATA_NODE_SZ;\n\tubifs_compress(c, buf, len, &data->data, &compr_len, &compr_type);\n\tubifs_assert(c, compr_len <= UBIFS_BLOCK_SIZE);\n\n\tif (encrypted) {\n\t\terr = ubifs_encrypt(inode, data, compr_len, &out_len, key_block(c, key));\n\t\tif (err)\n\t\t\tgoto out_free;\n\n\t} else {\n\t\tdata->compr_size = 0;\n\t\tout_len = compr_len;\n\t}\n\n\tdlen = UBIFS_DATA_NODE_SZ + out_len;\n\tif (ubifs_authenticated(c))\n\t\twrite_len = ALIGN(dlen, 8) + auth_len;\n\telse\n\t\twrite_len = dlen;\n\n\tdata->compr_type = cpu_to_le16(compr_type);\n\n\t \n\terr = make_reservation(c, DATAHD, write_len);\n\tif (err)\n\t\tgoto out_free;\n\n\tubifs_prepare_node(c, data, dlen, 0);\n\terr = write_head(c, DATAHD, data, write_len, &lnum, &offs, 0);\n\tif (err)\n\t\tgoto out_release;\n\n\terr = ubifs_node_calc_hash(c, data, hash);\n\tif (err)\n\t\tgoto out_release;\n\n\tubifs_wbuf_add_ino_nolock(&c->jheads[DATAHD].wbuf, key_inum(c, key));\n\trelease_head(c, DATAHD);\n\n\tubifs_add_auth_dirt(c, lnum);\n\n\terr = ubifs_tnc_add(c, key, lnum, offs, dlen, hash);\n\tif (err)\n\t\tgoto out_ro;\n\n\tfinish_reservation(c);\n\tif (!allocated)\n\t\tmutex_unlock(&c->write_reserve_mutex);\n\telse\n\t\tkfree(data);\n\treturn 0;\n\nout_release:\n\trelease_head(c, DATAHD);\nout_ro:\n\tubifs_ro_mode(c, err);\n\tfinish_reservation(c);\nout_free:\n\tif (!allocated)\n\t\tmutex_unlock(&c->write_reserve_mutex);\n\telse\n\t\tkfree(data);\n\treturn err;\n}\n\n \nint ubifs_jnl_write_inode(struct ubifs_info *c, const struct inode *inode)\n{\n\tint err, lnum, offs;\n\tstruct ubifs_ino_node *ino, *ino_start;\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\tint sync = 0, write_len = 0, ilen = UBIFS_INO_NODE_SZ;\n\tint last_reference = !inode->i_nlink;\n\tint kill_xattrs = ui->xattr_cnt && last_reference;\n\tu8 hash[UBIFS_HASH_ARR_SZ];\n\n\tdbg_jnl(\"ino %lu, nlink %u\", inode->i_ino, inode->i_nlink);\n\n\t \n\tif (!last_reference) {\n\t\tilen += ui->data_len;\n\t\tsync = IS_SYNC(inode);\n\t} else if (kill_xattrs) {\n\t\twrite_len += UBIFS_INO_NODE_SZ * ui->xattr_cnt;\n\t}\n\n\tif (ubifs_authenticated(c))\n\t\twrite_len += ALIGN(ilen, 8) + ubifs_auth_node_sz(c);\n\telse\n\t\twrite_len += ilen;\n\n\tino_start = ino = kmalloc(write_len, GFP_NOFS);\n\tif (!ino)\n\t\treturn -ENOMEM;\n\n\t \n\terr = make_reservation(c, BASEHD, write_len);\n\tif (err)\n\t\tgoto out_free;\n\n\tif (kill_xattrs) {\n\t\tunion ubifs_key key;\n\t\tstruct fscrypt_name nm = {0};\n\t\tstruct inode *xino;\n\t\tstruct ubifs_dent_node *xent, *pxent = NULL;\n\n\t\tif (ui->xattr_cnt > ubifs_xattr_max_cnt(c)) {\n\t\t\terr = -EPERM;\n\t\t\tubifs_err(c, \"Cannot delete inode, it has too much xattrs!\");\n\t\t\tgoto out_release;\n\t\t}\n\n\t\tlowest_xent_key(c, &key, inode->i_ino);\n\t\twhile (1) {\n\t\t\txent = ubifs_tnc_next_ent(c, &key, &nm);\n\t\t\tif (IS_ERR(xent)) {\n\t\t\t\terr = PTR_ERR(xent);\n\t\t\t\tif (err == -ENOENT)\n\t\t\t\t\tbreak;\n\n\t\t\t\tkfree(pxent);\n\t\t\t\tgoto out_release;\n\t\t\t}\n\n\t\t\tfname_name(&nm) = xent->name;\n\t\t\tfname_len(&nm) = le16_to_cpu(xent->nlen);\n\n\t\t\txino = ubifs_iget(c->vfs_sb, le64_to_cpu(xent->inum));\n\t\t\tif (IS_ERR(xino)) {\n\t\t\t\terr = PTR_ERR(xino);\n\t\t\t\tubifs_err(c, \"dead directory entry '%s', error %d\",\n\t\t\t\t\t  xent->name, err);\n\t\t\t\tubifs_ro_mode(c, err);\n\t\t\t\tkfree(pxent);\n\t\t\t\tkfree(xent);\n\t\t\t\tgoto out_release;\n\t\t\t}\n\t\t\tubifs_assert(c, ubifs_inode(xino)->xattr);\n\n\t\t\tclear_nlink(xino);\n\t\t\tpack_inode(c, ino, xino, 0);\n\t\t\tino = (void *)ino + UBIFS_INO_NODE_SZ;\n\t\t\tiput(xino);\n\n\t\t\tkfree(pxent);\n\t\t\tpxent = xent;\n\t\t\tkey_read(c, &xent->key, &key);\n\t\t}\n\t\tkfree(pxent);\n\t}\n\n\tpack_inode(c, ino, inode, 1);\n\terr = ubifs_node_calc_hash(c, ino, hash);\n\tif (err)\n\t\tgoto out_release;\n\n\terr = write_head(c, BASEHD, ino_start, write_len, &lnum, &offs, sync);\n\tif (err)\n\t\tgoto out_release;\n\tif (!sync)\n\t\tubifs_wbuf_add_ino_nolock(&c->jheads[BASEHD].wbuf,\n\t\t\t\t\t  inode->i_ino);\n\trelease_head(c, BASEHD);\n\n\tif (last_reference) {\n\t\terr = ubifs_tnc_remove_ino(c, inode->i_ino);\n\t\tif (err)\n\t\t\tgoto out_ro;\n\t\tubifs_delete_orphan(c, inode->i_ino);\n\t\terr = ubifs_add_dirt(c, lnum, write_len);\n\t} else {\n\t\tunion ubifs_key key;\n\n\t\tubifs_add_auth_dirt(c, lnum);\n\n\t\tino_key_init(c, &key, inode->i_ino);\n\t\terr = ubifs_tnc_add(c, &key, lnum, offs, ilen, hash);\n\t}\n\tif (err)\n\t\tgoto out_ro;\n\n\tfinish_reservation(c);\n\tspin_lock(&ui->ui_lock);\n\tui->synced_i_size = ui->ui_size;\n\tspin_unlock(&ui->ui_lock);\n\tkfree(ino_start);\n\treturn 0;\n\nout_release:\n\trelease_head(c, BASEHD);\nout_ro:\n\tubifs_ro_mode(c, err);\n\tfinish_reservation(c);\nout_free:\n\tkfree(ino_start);\n\treturn err;\n}\n\n \nint ubifs_jnl_delete_inode(struct ubifs_info *c, const struct inode *inode)\n{\n\tint err;\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\n\tubifs_assert(c, inode->i_nlink == 0);\n\n\tif (ui->xattr_cnt || ui->del_cmtno != c->cmt_no)\n\t\t \n\t\treturn ubifs_jnl_write_inode(c, inode);\n\n\tdown_read(&c->commit_sem);\n\t \n\tif (ui->del_cmtno != c->cmt_no) {\n\t\tup_read(&c->commit_sem);\n\t\treturn ubifs_jnl_write_inode(c, inode);\n\t}\n\n\terr = ubifs_tnc_remove_ino(c, inode->i_ino);\n\tif (err)\n\t\tubifs_ro_mode(c, err);\n\telse\n\t\tubifs_delete_orphan(c, inode->i_ino);\n\tup_read(&c->commit_sem);\n\treturn err;\n}\n\n \nint ubifs_jnl_xrename(struct ubifs_info *c, const struct inode *fst_dir,\n\t\t      const struct inode *fst_inode,\n\t\t      const struct fscrypt_name *fst_nm,\n\t\t      const struct inode *snd_dir,\n\t\t      const struct inode *snd_inode,\n\t\t      const struct fscrypt_name *snd_nm, int sync)\n{\n\tunion ubifs_key key;\n\tstruct ubifs_dent_node *dent1, *dent2;\n\tint err, dlen1, dlen2, lnum, offs, len, plen = UBIFS_INO_NODE_SZ;\n\tint aligned_dlen1, aligned_dlen2;\n\tint twoparents = (fst_dir != snd_dir);\n\tvoid *p;\n\tu8 hash_dent1[UBIFS_HASH_ARR_SZ];\n\tu8 hash_dent2[UBIFS_HASH_ARR_SZ];\n\tu8 hash_p1[UBIFS_HASH_ARR_SZ];\n\tu8 hash_p2[UBIFS_HASH_ARR_SZ];\n\n\tubifs_assert(c, ubifs_inode(fst_dir)->data_len == 0);\n\tubifs_assert(c, ubifs_inode(snd_dir)->data_len == 0);\n\tubifs_assert(c, mutex_is_locked(&ubifs_inode(fst_dir)->ui_mutex));\n\tubifs_assert(c, mutex_is_locked(&ubifs_inode(snd_dir)->ui_mutex));\n\n\tdlen1 = UBIFS_DENT_NODE_SZ + fname_len(snd_nm) + 1;\n\tdlen2 = UBIFS_DENT_NODE_SZ + fname_len(fst_nm) + 1;\n\taligned_dlen1 = ALIGN(dlen1, 8);\n\taligned_dlen2 = ALIGN(dlen2, 8);\n\n\tlen = aligned_dlen1 + aligned_dlen2 + ALIGN(plen, 8);\n\tif (twoparents)\n\t\tlen += plen;\n\n\tlen += ubifs_auth_node_sz(c);\n\n\tdent1 = kzalloc(len, GFP_NOFS);\n\tif (!dent1)\n\t\treturn -ENOMEM;\n\n\t \n\terr = make_reservation(c, BASEHD, len);\n\tif (err)\n\t\tgoto out_free;\n\n\t \n\tdent1->ch.node_type = UBIFS_DENT_NODE;\n\tdent_key_init_flash(c, &dent1->key, snd_dir->i_ino, snd_nm);\n\tdent1->inum = cpu_to_le64(fst_inode->i_ino);\n\tdent1->type = get_dent_type(fst_inode->i_mode);\n\tdent1->nlen = cpu_to_le16(fname_len(snd_nm));\n\tmemcpy(dent1->name, fname_name(snd_nm), fname_len(snd_nm));\n\tdent1->name[fname_len(snd_nm)] = '\\0';\n\tset_dent_cookie(c, dent1);\n\tzero_dent_node_unused(dent1);\n\tubifs_prep_grp_node(c, dent1, dlen1, 0);\n\terr = ubifs_node_calc_hash(c, dent1, hash_dent1);\n\tif (err)\n\t\tgoto out_release;\n\n\t \n\tdent2 = (void *)dent1 + aligned_dlen1;\n\tdent2->ch.node_type = UBIFS_DENT_NODE;\n\tdent_key_init_flash(c, &dent2->key, fst_dir->i_ino, fst_nm);\n\tdent2->inum = cpu_to_le64(snd_inode->i_ino);\n\tdent2->type = get_dent_type(snd_inode->i_mode);\n\tdent2->nlen = cpu_to_le16(fname_len(fst_nm));\n\tmemcpy(dent2->name, fname_name(fst_nm), fname_len(fst_nm));\n\tdent2->name[fname_len(fst_nm)] = '\\0';\n\tset_dent_cookie(c, dent2);\n\tzero_dent_node_unused(dent2);\n\tubifs_prep_grp_node(c, dent2, dlen2, 0);\n\terr = ubifs_node_calc_hash(c, dent2, hash_dent2);\n\tif (err)\n\t\tgoto out_release;\n\n\tp = (void *)dent2 + aligned_dlen2;\n\tif (!twoparents) {\n\t\tpack_inode(c, p, fst_dir, 1);\n\t\terr = ubifs_node_calc_hash(c, p, hash_p1);\n\t\tif (err)\n\t\t\tgoto out_release;\n\t} else {\n\t\tpack_inode(c, p, fst_dir, 0);\n\t\terr = ubifs_node_calc_hash(c, p, hash_p1);\n\t\tif (err)\n\t\t\tgoto out_release;\n\t\tp += ALIGN(plen, 8);\n\t\tpack_inode(c, p, snd_dir, 1);\n\t\terr = ubifs_node_calc_hash(c, p, hash_p2);\n\t\tif (err)\n\t\t\tgoto out_release;\n\t}\n\n\terr = write_head(c, BASEHD, dent1, len, &lnum, &offs, sync);\n\tif (err)\n\t\tgoto out_release;\n\tif (!sync) {\n\t\tstruct ubifs_wbuf *wbuf = &c->jheads[BASEHD].wbuf;\n\n\t\tubifs_wbuf_add_ino_nolock(wbuf, fst_dir->i_ino);\n\t\tubifs_wbuf_add_ino_nolock(wbuf, snd_dir->i_ino);\n\t}\n\trelease_head(c, BASEHD);\n\n\tubifs_add_auth_dirt(c, lnum);\n\n\tdent_key_init(c, &key, snd_dir->i_ino, snd_nm);\n\terr = ubifs_tnc_add_nm(c, &key, lnum, offs, dlen1, hash_dent1, snd_nm);\n\tif (err)\n\t\tgoto out_ro;\n\n\toffs += aligned_dlen1;\n\tdent_key_init(c, &key, fst_dir->i_ino, fst_nm);\n\terr = ubifs_tnc_add_nm(c, &key, lnum, offs, dlen2, hash_dent2, fst_nm);\n\tif (err)\n\t\tgoto out_ro;\n\n\toffs += aligned_dlen2;\n\n\tino_key_init(c, &key, fst_dir->i_ino);\n\terr = ubifs_tnc_add(c, &key, lnum, offs, plen, hash_p1);\n\tif (err)\n\t\tgoto out_ro;\n\n\tif (twoparents) {\n\t\toffs += ALIGN(plen, 8);\n\t\tino_key_init(c, &key, snd_dir->i_ino);\n\t\terr = ubifs_tnc_add(c, &key, lnum, offs, plen, hash_p2);\n\t\tif (err)\n\t\t\tgoto out_ro;\n\t}\n\n\tfinish_reservation(c);\n\n\tmark_inode_clean(c, ubifs_inode(fst_dir));\n\tif (twoparents)\n\t\tmark_inode_clean(c, ubifs_inode(snd_dir));\n\tkfree(dent1);\n\treturn 0;\n\nout_release:\n\trelease_head(c, BASEHD);\nout_ro:\n\tubifs_ro_mode(c, err);\n\tfinish_reservation(c);\nout_free:\n\tkfree(dent1);\n\treturn err;\n}\n\n \nint ubifs_jnl_rename(struct ubifs_info *c, const struct inode *old_dir,\n\t\t     const struct inode *old_inode,\n\t\t     const struct fscrypt_name *old_nm,\n\t\t     const struct inode *new_dir,\n\t\t     const struct inode *new_inode,\n\t\t     const struct fscrypt_name *new_nm,\n\t\t     const struct inode *whiteout, int sync)\n{\n\tvoid *p;\n\tunion ubifs_key key;\n\tstruct ubifs_dent_node *dent, *dent2;\n\tint err, dlen1, dlen2, ilen, wlen, lnum, offs, len, orphan_added = 0;\n\tint aligned_dlen1, aligned_dlen2, plen = UBIFS_INO_NODE_SZ;\n\tint last_reference = !!(new_inode && new_inode->i_nlink == 0);\n\tint move = (old_dir != new_dir);\n\tstruct ubifs_inode *new_ui, *whiteout_ui;\n\tu8 hash_old_dir[UBIFS_HASH_ARR_SZ];\n\tu8 hash_new_dir[UBIFS_HASH_ARR_SZ];\n\tu8 hash_new_inode[UBIFS_HASH_ARR_SZ];\n\tu8 hash_whiteout_inode[UBIFS_HASH_ARR_SZ];\n\tu8 hash_dent1[UBIFS_HASH_ARR_SZ];\n\tu8 hash_dent2[UBIFS_HASH_ARR_SZ];\n\n\tubifs_assert(c, ubifs_inode(old_dir)->data_len == 0);\n\tubifs_assert(c, ubifs_inode(new_dir)->data_len == 0);\n\tubifs_assert(c, mutex_is_locked(&ubifs_inode(old_dir)->ui_mutex));\n\tubifs_assert(c, mutex_is_locked(&ubifs_inode(new_dir)->ui_mutex));\n\n\tdlen1 = UBIFS_DENT_NODE_SZ + fname_len(new_nm) + 1;\n\tdlen2 = UBIFS_DENT_NODE_SZ + fname_len(old_nm) + 1;\n\tif (new_inode) {\n\t\tnew_ui = ubifs_inode(new_inode);\n\t\tubifs_assert(c, mutex_is_locked(&new_ui->ui_mutex));\n\t\tilen = UBIFS_INO_NODE_SZ;\n\t\tif (!last_reference)\n\t\t\tilen += new_ui->data_len;\n\t} else\n\t\tilen = 0;\n\n\tif (whiteout) {\n\t\twhiteout_ui = ubifs_inode(whiteout);\n\t\tubifs_assert(c, mutex_is_locked(&whiteout_ui->ui_mutex));\n\t\tubifs_assert(c, whiteout->i_nlink == 1);\n\t\tubifs_assert(c, !whiteout_ui->dirty);\n\t\twlen = UBIFS_INO_NODE_SZ;\n\t\twlen += whiteout_ui->data_len;\n\t} else\n\t\twlen = 0;\n\n\taligned_dlen1 = ALIGN(dlen1, 8);\n\taligned_dlen2 = ALIGN(dlen2, 8);\n\tlen = aligned_dlen1 + aligned_dlen2 + ALIGN(ilen, 8) +\n\t      ALIGN(wlen, 8) + ALIGN(plen, 8);\n\tif (move)\n\t\tlen += plen;\n\n\tlen += ubifs_auth_node_sz(c);\n\n\tdent = kzalloc(len, GFP_NOFS);\n\tif (!dent)\n\t\treturn -ENOMEM;\n\n\t \n\terr = make_reservation(c, BASEHD, len);\n\tif (err)\n\t\tgoto out_free;\n\n\t \n\tdent->ch.node_type = UBIFS_DENT_NODE;\n\tdent_key_init_flash(c, &dent->key, new_dir->i_ino, new_nm);\n\tdent->inum = cpu_to_le64(old_inode->i_ino);\n\tdent->type = get_dent_type(old_inode->i_mode);\n\tdent->nlen = cpu_to_le16(fname_len(new_nm));\n\tmemcpy(dent->name, fname_name(new_nm), fname_len(new_nm));\n\tdent->name[fname_len(new_nm)] = '\\0';\n\tset_dent_cookie(c, dent);\n\tzero_dent_node_unused(dent);\n\tubifs_prep_grp_node(c, dent, dlen1, 0);\n\terr = ubifs_node_calc_hash(c, dent, hash_dent1);\n\tif (err)\n\t\tgoto out_release;\n\n\tdent2 = (void *)dent + aligned_dlen1;\n\tdent2->ch.node_type = UBIFS_DENT_NODE;\n\tdent_key_init_flash(c, &dent2->key, old_dir->i_ino, old_nm);\n\n\tif (whiteout) {\n\t\tdent2->inum = cpu_to_le64(whiteout->i_ino);\n\t\tdent2->type = get_dent_type(whiteout->i_mode);\n\t} else {\n\t\t \n\t\tdent2->inum = 0;\n\t\tdent2->type = DT_UNKNOWN;\n\t}\n\tdent2->nlen = cpu_to_le16(fname_len(old_nm));\n\tmemcpy(dent2->name, fname_name(old_nm), fname_len(old_nm));\n\tdent2->name[fname_len(old_nm)] = '\\0';\n\tset_dent_cookie(c, dent2);\n\tzero_dent_node_unused(dent2);\n\tubifs_prep_grp_node(c, dent2, dlen2, 0);\n\terr = ubifs_node_calc_hash(c, dent2, hash_dent2);\n\tif (err)\n\t\tgoto out_release;\n\n\tp = (void *)dent2 + aligned_dlen2;\n\tif (new_inode) {\n\t\tpack_inode(c, p, new_inode, 0);\n\t\terr = ubifs_node_calc_hash(c, p, hash_new_inode);\n\t\tif (err)\n\t\t\tgoto out_release;\n\n\t\tp += ALIGN(ilen, 8);\n\t}\n\n\tif (whiteout) {\n\t\tpack_inode(c, p, whiteout, 0);\n\t\terr = ubifs_node_calc_hash(c, p, hash_whiteout_inode);\n\t\tif (err)\n\t\t\tgoto out_release;\n\n\t\tp += ALIGN(wlen, 8);\n\t}\n\n\tif (!move) {\n\t\tpack_inode(c, p, old_dir, 1);\n\t\terr = ubifs_node_calc_hash(c, p, hash_old_dir);\n\t\tif (err)\n\t\t\tgoto out_release;\n\t} else {\n\t\tpack_inode(c, p, old_dir, 0);\n\t\terr = ubifs_node_calc_hash(c, p, hash_old_dir);\n\t\tif (err)\n\t\t\tgoto out_release;\n\n\t\tp += ALIGN(plen, 8);\n\t\tpack_inode(c, p, new_dir, 1);\n\t\terr = ubifs_node_calc_hash(c, p, hash_new_dir);\n\t\tif (err)\n\t\t\tgoto out_release;\n\t}\n\n\tif (last_reference) {\n\t\terr = ubifs_add_orphan(c, new_inode->i_ino);\n\t\tif (err) {\n\t\t\trelease_head(c, BASEHD);\n\t\t\tgoto out_finish;\n\t\t}\n\t\tnew_ui->del_cmtno = c->cmt_no;\n\t\torphan_added = 1;\n\t}\n\n\terr = write_head(c, BASEHD, dent, len, &lnum, &offs, sync);\n\tif (err)\n\t\tgoto out_release;\n\tif (!sync) {\n\t\tstruct ubifs_wbuf *wbuf = &c->jheads[BASEHD].wbuf;\n\n\t\tubifs_wbuf_add_ino_nolock(wbuf, new_dir->i_ino);\n\t\tubifs_wbuf_add_ino_nolock(wbuf, old_dir->i_ino);\n\t\tif (new_inode)\n\t\t\tubifs_wbuf_add_ino_nolock(&c->jheads[BASEHD].wbuf,\n\t\t\t\t\t\t  new_inode->i_ino);\n\t\tif (whiteout)\n\t\t\tubifs_wbuf_add_ino_nolock(&c->jheads[BASEHD].wbuf,\n\t\t\t\t\t\t  whiteout->i_ino);\n\t}\n\trelease_head(c, BASEHD);\n\n\tubifs_add_auth_dirt(c, lnum);\n\n\tdent_key_init(c, &key, new_dir->i_ino, new_nm);\n\terr = ubifs_tnc_add_nm(c, &key, lnum, offs, dlen1, hash_dent1, new_nm);\n\tif (err)\n\t\tgoto out_ro;\n\n\toffs += aligned_dlen1;\n\tif (whiteout) {\n\t\tdent_key_init(c, &key, old_dir->i_ino, old_nm);\n\t\terr = ubifs_tnc_add_nm(c, &key, lnum, offs, dlen2, hash_dent2, old_nm);\n\t\tif (err)\n\t\t\tgoto out_ro;\n\t} else {\n\t\terr = ubifs_add_dirt(c, lnum, dlen2);\n\t\tif (err)\n\t\t\tgoto out_ro;\n\n\t\tdent_key_init(c, &key, old_dir->i_ino, old_nm);\n\t\terr = ubifs_tnc_remove_nm(c, &key, old_nm);\n\t\tif (err)\n\t\t\tgoto out_ro;\n\t}\n\n\toffs += aligned_dlen2;\n\tif (new_inode) {\n\t\tino_key_init(c, &key, new_inode->i_ino);\n\t\terr = ubifs_tnc_add(c, &key, lnum, offs, ilen, hash_new_inode);\n\t\tif (err)\n\t\t\tgoto out_ro;\n\t\toffs += ALIGN(ilen, 8);\n\t}\n\n\tif (whiteout) {\n\t\tino_key_init(c, &key, whiteout->i_ino);\n\t\terr = ubifs_tnc_add(c, &key, lnum, offs, wlen,\n\t\t\t\t    hash_whiteout_inode);\n\t\tif (err)\n\t\t\tgoto out_ro;\n\t\toffs += ALIGN(wlen, 8);\n\t}\n\n\tino_key_init(c, &key, old_dir->i_ino);\n\terr = ubifs_tnc_add(c, &key, lnum, offs, plen, hash_old_dir);\n\tif (err)\n\t\tgoto out_ro;\n\n\tif (move) {\n\t\toffs += ALIGN(plen, 8);\n\t\tino_key_init(c, &key, new_dir->i_ino);\n\t\terr = ubifs_tnc_add(c, &key, lnum, offs, plen, hash_new_dir);\n\t\tif (err)\n\t\t\tgoto out_ro;\n\t}\n\n\tfinish_reservation(c);\n\tif (new_inode) {\n\t\tmark_inode_clean(c, new_ui);\n\t\tspin_lock(&new_ui->ui_lock);\n\t\tnew_ui->synced_i_size = new_ui->ui_size;\n\t\tspin_unlock(&new_ui->ui_lock);\n\t}\n\t \n\tmark_inode_clean(c, ubifs_inode(old_dir));\n\tif (move)\n\t\tmark_inode_clean(c, ubifs_inode(new_dir));\n\tkfree(dent);\n\treturn 0;\n\nout_release:\n\trelease_head(c, BASEHD);\nout_ro:\n\tubifs_ro_mode(c, err);\n\tif (orphan_added)\n\t\tubifs_delete_orphan(c, new_inode->i_ino);\nout_finish:\n\tfinish_reservation(c);\nout_free:\n\tkfree(dent);\n\treturn err;\n}\n\n \nstatic int truncate_data_node(const struct ubifs_info *c, const struct inode *inode,\n\t\t\t      unsigned int block, struct ubifs_data_node *dn,\n\t\t\t      int *new_len, int dn_size)\n{\n\tvoid *buf;\n\tint err, dlen, compr_type, out_len, data_size;\n\n\tout_len = le32_to_cpu(dn->size);\n\tbuf = kmalloc_array(out_len, WORST_COMPR_FACTOR, GFP_NOFS);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tdlen = le32_to_cpu(dn->ch.len) - UBIFS_DATA_NODE_SZ;\n\tdata_size = dn_size - UBIFS_DATA_NODE_SZ;\n\tcompr_type = le16_to_cpu(dn->compr_type);\n\n\tif (IS_ENCRYPTED(inode)) {\n\t\terr = ubifs_decrypt(inode, dn, &dlen, block);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (compr_type == UBIFS_COMPR_NONE) {\n\t\tout_len = *new_len;\n\t} else {\n\t\terr = ubifs_decompress(c, &dn->data, dlen, buf, &out_len, compr_type);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tubifs_compress(c, buf, *new_len, &dn->data, &out_len, &compr_type);\n\t}\n\n\tif (IS_ENCRYPTED(inode)) {\n\t\terr = ubifs_encrypt(inode, dn, out_len, &data_size, block);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tout_len = data_size;\n\t} else {\n\t\tdn->compr_size = 0;\n\t}\n\n\tubifs_assert(c, out_len <= UBIFS_BLOCK_SIZE);\n\tdn->compr_type = cpu_to_le16(compr_type);\n\tdn->size = cpu_to_le32(*new_len);\n\t*new_len = UBIFS_DATA_NODE_SZ + out_len;\n\terr = 0;\nout:\n\tkfree(buf);\n\treturn err;\n}\n\n \nint ubifs_jnl_truncate(struct ubifs_info *c, const struct inode *inode,\n\t\t       loff_t old_size, loff_t new_size)\n{\n\tunion ubifs_key key, to_key;\n\tstruct ubifs_ino_node *ino;\n\tstruct ubifs_trun_node *trun;\n\tstruct ubifs_data_node *dn;\n\tint err, dlen, len, lnum, offs, bit, sz, sync = IS_SYNC(inode);\n\tint dn_size;\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\tino_t inum = inode->i_ino;\n\tunsigned int blk;\n\tu8 hash_ino[UBIFS_HASH_ARR_SZ];\n\tu8 hash_dn[UBIFS_HASH_ARR_SZ];\n\n\tdbg_jnl(\"ino %lu, size %lld -> %lld\",\n\t\t(unsigned long)inum, old_size, new_size);\n\tubifs_assert(c, !ui->data_len);\n\tubifs_assert(c, S_ISREG(inode->i_mode));\n\tubifs_assert(c, mutex_is_locked(&ui->ui_mutex));\n\n\tdn_size = COMPRESSED_DATA_NODE_BUF_SZ;\n\n\tif (IS_ENCRYPTED(inode))\n\t\tdn_size += UBIFS_CIPHER_BLOCK_SIZE;\n\n\tsz =  UBIFS_TRUN_NODE_SZ + UBIFS_INO_NODE_SZ +\n\t\tdn_size + ubifs_auth_node_sz(c);\n\n\tino = kmalloc(sz, GFP_NOFS);\n\tif (!ino)\n\t\treturn -ENOMEM;\n\n\ttrun = (void *)ino + UBIFS_INO_NODE_SZ;\n\ttrun->ch.node_type = UBIFS_TRUN_NODE;\n\ttrun->inum = cpu_to_le32(inum);\n\ttrun->old_size = cpu_to_le64(old_size);\n\ttrun->new_size = cpu_to_le64(new_size);\n\tzero_trun_node_unused(trun);\n\n\tdlen = new_size & (UBIFS_BLOCK_SIZE - 1);\n\tif (dlen) {\n\t\t \n\t\tdn = (void *)trun + UBIFS_TRUN_NODE_SZ;\n\t\tblk = new_size >> UBIFS_BLOCK_SHIFT;\n\t\tdata_key_init(c, &key, inum, blk);\n\t\tdbg_jnlk(&key, \"last block key \");\n\t\terr = ubifs_tnc_lookup(c, &key, dn);\n\t\tif (err == -ENOENT)\n\t\t\tdlen = 0;  \n\t\telse if (err)\n\t\t\tgoto out_free;\n\t\telse {\n\t\t\tint dn_len = le32_to_cpu(dn->size);\n\n\t\t\tif (dn_len <= 0 || dn_len > UBIFS_BLOCK_SIZE) {\n\t\t\t\tubifs_err(c, \"bad data node (block %u, inode %lu)\",\n\t\t\t\t\t  blk, inode->i_ino);\n\t\t\t\tubifs_dump_node(c, dn, dn_size);\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\tif (dn_len <= dlen)\n\t\t\t\tdlen = 0;  \n\t\t\telse {\n\t\t\t\terr = truncate_data_node(c, inode, blk, dn,\n\t\t\t\t\t\t&dlen, dn_size);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tlen = UBIFS_TRUN_NODE_SZ + UBIFS_INO_NODE_SZ;\n\n\tif (ubifs_authenticated(c))\n\t\tlen += ALIGN(dlen, 8) + ubifs_auth_node_sz(c);\n\telse\n\t\tlen += dlen;\n\n\terr = make_reservation(c, BASEHD, len);\n\tif (err)\n\t\tgoto out_free;\n\n\tpack_inode(c, ino, inode, 0);\n\terr = ubifs_node_calc_hash(c, ino, hash_ino);\n\tif (err)\n\t\tgoto out_release;\n\n\tubifs_prep_grp_node(c, trun, UBIFS_TRUN_NODE_SZ, dlen ? 0 : 1);\n\tif (dlen) {\n\t\tubifs_prep_grp_node(c, dn, dlen, 1);\n\t\terr = ubifs_node_calc_hash(c, dn, hash_dn);\n\t\tif (err)\n\t\t\tgoto out_release;\n\t}\n\n\terr = write_head(c, BASEHD, ino, len, &lnum, &offs, sync);\n\tif (err)\n\t\tgoto out_release;\n\tif (!sync)\n\t\tubifs_wbuf_add_ino_nolock(&c->jheads[BASEHD].wbuf, inum);\n\trelease_head(c, BASEHD);\n\n\tubifs_add_auth_dirt(c, lnum);\n\n\tif (dlen) {\n\t\tsz = offs + UBIFS_INO_NODE_SZ + UBIFS_TRUN_NODE_SZ;\n\t\terr = ubifs_tnc_add(c, &key, lnum, sz, dlen, hash_dn);\n\t\tif (err)\n\t\t\tgoto out_ro;\n\t}\n\n\tino_key_init(c, &key, inum);\n\terr = ubifs_tnc_add(c, &key, lnum, offs, UBIFS_INO_NODE_SZ, hash_ino);\n\tif (err)\n\t\tgoto out_ro;\n\n\terr = ubifs_add_dirt(c, lnum, UBIFS_TRUN_NODE_SZ);\n\tif (err)\n\t\tgoto out_ro;\n\n\tbit = new_size & (UBIFS_BLOCK_SIZE - 1);\n\tblk = (new_size >> UBIFS_BLOCK_SHIFT) + (bit ? 1 : 0);\n\tdata_key_init(c, &key, inum, blk);\n\n\tbit = old_size & (UBIFS_BLOCK_SIZE - 1);\n\tblk = (old_size >> UBIFS_BLOCK_SHIFT) - (bit ? 0 : 1);\n\tdata_key_init(c, &to_key, inum, blk);\n\n\terr = ubifs_tnc_remove_range(c, &key, &to_key);\n\tif (err)\n\t\tgoto out_ro;\n\n\tfinish_reservation(c);\n\tspin_lock(&ui->ui_lock);\n\tui->synced_i_size = ui->ui_size;\n\tspin_unlock(&ui->ui_lock);\n\tmark_inode_clean(c, ui);\n\tkfree(ino);\n\treturn 0;\n\nout_release:\n\trelease_head(c, BASEHD);\nout_ro:\n\tubifs_ro_mode(c, err);\n\tfinish_reservation(c);\nout_free:\n\tkfree(ino);\n\treturn err;\n}\n\n\n \nint ubifs_jnl_delete_xattr(struct ubifs_info *c, const struct inode *host,\n\t\t\t   const struct inode *inode,\n\t\t\t   const struct fscrypt_name *nm)\n{\n\tint err, xlen, hlen, len, lnum, xent_offs, aligned_xlen, write_len;\n\tstruct ubifs_dent_node *xent;\n\tstruct ubifs_ino_node *ino;\n\tunion ubifs_key xent_key, key1, key2;\n\tint sync = IS_DIRSYNC(host);\n\tstruct ubifs_inode *host_ui = ubifs_inode(host);\n\tu8 hash[UBIFS_HASH_ARR_SZ];\n\n\tubifs_assert(c, inode->i_nlink == 0);\n\tubifs_assert(c, mutex_is_locked(&host_ui->ui_mutex));\n\n\t \n\txlen = UBIFS_DENT_NODE_SZ + fname_len(nm) + 1;\n\taligned_xlen = ALIGN(xlen, 8);\n\thlen = host_ui->data_len + UBIFS_INO_NODE_SZ;\n\tlen = aligned_xlen + UBIFS_INO_NODE_SZ + ALIGN(hlen, 8);\n\n\twrite_len = len + ubifs_auth_node_sz(c);\n\n\txent = kzalloc(write_len, GFP_NOFS);\n\tif (!xent)\n\t\treturn -ENOMEM;\n\n\t \n\terr = make_reservation(c, BASEHD, write_len);\n\tif (err) {\n\t\tkfree(xent);\n\t\treturn err;\n\t}\n\n\txent->ch.node_type = UBIFS_XENT_NODE;\n\txent_key_init(c, &xent_key, host->i_ino, nm);\n\tkey_write(c, &xent_key, xent->key);\n\txent->inum = 0;\n\txent->type = get_dent_type(inode->i_mode);\n\txent->nlen = cpu_to_le16(fname_len(nm));\n\tmemcpy(xent->name, fname_name(nm), fname_len(nm));\n\txent->name[fname_len(nm)] = '\\0';\n\tzero_dent_node_unused(xent);\n\tubifs_prep_grp_node(c, xent, xlen, 0);\n\n\tino = (void *)xent + aligned_xlen;\n\tpack_inode(c, ino, inode, 0);\n\tino = (void *)ino + UBIFS_INO_NODE_SZ;\n\tpack_inode(c, ino, host, 1);\n\terr = ubifs_node_calc_hash(c, ino, hash);\n\tif (err)\n\t\tgoto out_release;\n\n\terr = write_head(c, BASEHD, xent, write_len, &lnum, &xent_offs, sync);\n\tif (!sync && !err)\n\t\tubifs_wbuf_add_ino_nolock(&c->jheads[BASEHD].wbuf, host->i_ino);\n\trelease_head(c, BASEHD);\n\n\tubifs_add_auth_dirt(c, lnum);\n\tkfree(xent);\n\tif (err)\n\t\tgoto out_ro;\n\n\t \n\terr = ubifs_tnc_remove_nm(c, &xent_key, nm);\n\tif (err)\n\t\tgoto out_ro;\n\terr = ubifs_add_dirt(c, lnum, xlen);\n\tif (err)\n\t\tgoto out_ro;\n\n\t \n\tlowest_ino_key(c, &key1, inode->i_ino);\n\thighest_ino_key(c, &key2, inode->i_ino);\n\terr = ubifs_tnc_remove_range(c, &key1, &key2);\n\tif (err)\n\t\tgoto out_ro;\n\terr = ubifs_add_dirt(c, lnum, UBIFS_INO_NODE_SZ);\n\tif (err)\n\t\tgoto out_ro;\n\n\t \n\tino_key_init(c, &key1, host->i_ino);\n\terr = ubifs_tnc_add(c, &key1, lnum, xent_offs + len - hlen, hlen, hash);\n\tif (err)\n\t\tgoto out_ro;\n\n\tfinish_reservation(c);\n\tspin_lock(&host_ui->ui_lock);\n\thost_ui->synced_i_size = host_ui->ui_size;\n\tspin_unlock(&host_ui->ui_lock);\n\tmark_inode_clean(c, host_ui);\n\treturn 0;\n\nout_release:\n\tkfree(xent);\n\trelease_head(c, BASEHD);\nout_ro:\n\tubifs_ro_mode(c, err);\n\tfinish_reservation(c);\n\treturn err;\n}\n\n \nint ubifs_jnl_change_xattr(struct ubifs_info *c, const struct inode *inode,\n\t\t\t   const struct inode *host)\n{\n\tint err, len1, len2, aligned_len, aligned_len1, lnum, offs;\n\tstruct ubifs_inode *host_ui = ubifs_inode(host);\n\tstruct ubifs_ino_node *ino;\n\tunion ubifs_key key;\n\tint sync = IS_DIRSYNC(host);\n\tu8 hash_host[UBIFS_HASH_ARR_SZ];\n\tu8 hash[UBIFS_HASH_ARR_SZ];\n\n\tdbg_jnl(\"ino %lu, ino %lu\", host->i_ino, inode->i_ino);\n\tubifs_assert(c, inode->i_nlink > 0);\n\tubifs_assert(c, mutex_is_locked(&host_ui->ui_mutex));\n\n\tlen1 = UBIFS_INO_NODE_SZ + host_ui->data_len;\n\tlen2 = UBIFS_INO_NODE_SZ + ubifs_inode(inode)->data_len;\n\taligned_len1 = ALIGN(len1, 8);\n\taligned_len = aligned_len1 + ALIGN(len2, 8);\n\n\taligned_len += ubifs_auth_node_sz(c);\n\n\tino = kzalloc(aligned_len, GFP_NOFS);\n\tif (!ino)\n\t\treturn -ENOMEM;\n\n\t \n\terr = make_reservation(c, BASEHD, aligned_len);\n\tif (err)\n\t\tgoto out_free;\n\n\tpack_inode(c, ino, host, 0);\n\terr = ubifs_node_calc_hash(c, ino, hash_host);\n\tif (err)\n\t\tgoto out_release;\n\tpack_inode(c, (void *)ino + aligned_len1, inode, 1);\n\terr = ubifs_node_calc_hash(c, (void *)ino + aligned_len1, hash);\n\tif (err)\n\t\tgoto out_release;\n\n\terr = write_head(c, BASEHD, ino, aligned_len, &lnum, &offs, 0);\n\tif (!sync && !err) {\n\t\tstruct ubifs_wbuf *wbuf = &c->jheads[BASEHD].wbuf;\n\n\t\tubifs_wbuf_add_ino_nolock(wbuf, host->i_ino);\n\t\tubifs_wbuf_add_ino_nolock(wbuf, inode->i_ino);\n\t}\n\trelease_head(c, BASEHD);\n\tif (err)\n\t\tgoto out_ro;\n\n\tubifs_add_auth_dirt(c, lnum);\n\n\tino_key_init(c, &key, host->i_ino);\n\terr = ubifs_tnc_add(c, &key, lnum, offs, len1, hash_host);\n\tif (err)\n\t\tgoto out_ro;\n\n\tino_key_init(c, &key, inode->i_ino);\n\terr = ubifs_tnc_add(c, &key, lnum, offs + aligned_len1, len2, hash);\n\tif (err)\n\t\tgoto out_ro;\n\n\tfinish_reservation(c);\n\tspin_lock(&host_ui->ui_lock);\n\thost_ui->synced_i_size = host_ui->ui_size;\n\tspin_unlock(&host_ui->ui_lock);\n\tmark_inode_clean(c, host_ui);\n\tkfree(ino);\n\treturn 0;\n\nout_release:\n\trelease_head(c, BASEHD);\nout_ro:\n\tubifs_ro_mode(c, err);\n\tfinish_reservation(c);\nout_free:\n\tkfree(ino);\n\treturn err;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}