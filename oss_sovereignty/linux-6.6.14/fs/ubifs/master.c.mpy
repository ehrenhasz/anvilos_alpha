{
  "module_name": "master.c",
  "hash_id": "bba9ad89c70e277bc1b2cc0f1ec51c7666182dd70c4234008093a81e13d13783",
  "original_prompt": "Ingested from linux-6.6.14/fs/ubifs/master.c",
  "human_readable_source": "\n \n\n \n\n#include \"ubifs.h\"\n\n \nint ubifs_compare_master_node(struct ubifs_info *c, void *m1, void *m2)\n{\n\tint ret;\n\tint behind;\n\tint hmac_offs = offsetof(struct ubifs_mst_node, hmac);\n\n\t \n\tret = memcmp(m1 + UBIFS_CH_SZ, m2 + UBIFS_CH_SZ,\n\t\t     hmac_offs - UBIFS_CH_SZ);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tbehind = hmac_offs + UBIFS_MAX_HMAC_LEN;\n\n\tif (UBIFS_MST_NODE_SZ > behind)\n\t\treturn memcmp(m1 + behind, m2 + behind, UBIFS_MST_NODE_SZ - behind);\n\n\treturn 0;\n}\n\n \nstatic int mst_node_check_hash(const struct ubifs_info *c,\n\t\t\t       const struct ubifs_mst_node *mst,\n\t\t\t       const u8 *expected)\n{\n\tu8 calc[UBIFS_MAX_HASH_LEN];\n\tconst void *node = mst;\n\n\tcrypto_shash_tfm_digest(c->hash_tfm, node + sizeof(struct ubifs_ch),\n\t\t\t\tUBIFS_MST_NODE_SZ - sizeof(struct ubifs_ch),\n\t\t\t\tcalc);\n\n\tif (ubifs_check_hash(c, expected, calc))\n\t\treturn -EPERM;\n\n\treturn 0;\n}\n\n \nstatic int scan_for_master(struct ubifs_info *c)\n{\n\tstruct ubifs_scan_leb *sleb;\n\tstruct ubifs_scan_node *snod;\n\tint lnum, offs = 0, nodes_cnt, err;\n\n\tlnum = UBIFS_MST_LNUM;\n\n\tsleb = ubifs_scan(c, lnum, 0, c->sbuf, 1);\n\tif (IS_ERR(sleb))\n\t\treturn PTR_ERR(sleb);\n\tnodes_cnt = sleb->nodes_cnt;\n\tif (nodes_cnt > 0) {\n\t\tsnod = list_entry(sleb->nodes.prev, struct ubifs_scan_node,\n\t\t\t\t  list);\n\t\tif (snod->type != UBIFS_MST_NODE)\n\t\t\tgoto out_dump;\n\t\tmemcpy(c->mst_node, snod->node, snod->len);\n\t\toffs = snod->offs;\n\t}\n\tubifs_scan_destroy(sleb);\n\n\tlnum += 1;\n\n\tsleb = ubifs_scan(c, lnum, 0, c->sbuf, 1);\n\tif (IS_ERR(sleb))\n\t\treturn PTR_ERR(sleb);\n\tif (sleb->nodes_cnt != nodes_cnt)\n\t\tgoto out;\n\tif (!sleb->nodes_cnt)\n\t\tgoto out;\n\tsnod = list_entry(sleb->nodes.prev, struct ubifs_scan_node, list);\n\tif (snod->type != UBIFS_MST_NODE)\n\t\tgoto out_dump;\n\tif (snod->offs != offs)\n\t\tgoto out;\n\tif (ubifs_compare_master_node(c, c->mst_node, snod->node))\n\t\tgoto out;\n\n\tc->mst_offs = offs;\n\tubifs_scan_destroy(sleb);\n\n\tif (!ubifs_authenticated(c))\n\t\treturn 0;\n\n\tif (ubifs_hmac_zero(c, c->mst_node->hmac)) {\n\t\terr = mst_node_check_hash(c, c->mst_node,\n\t\t\t\t\t  c->sup_node->hash_mst);\n\t\tif (err)\n\t\t\tubifs_err(c, \"Failed to verify master node hash\");\n\t} else {\n\t\terr = ubifs_node_verify_hmac(c, c->mst_node,\n\t\t\t\t\tsizeof(struct ubifs_mst_node),\n\t\t\t\t\toffsetof(struct ubifs_mst_node, hmac));\n\t\tif (err)\n\t\t\tubifs_err(c, \"Failed to verify master node HMAC\");\n\t}\n\n\tif (err)\n\t\treturn -EPERM;\n\n\treturn 0;\n\nout:\n\tubifs_scan_destroy(sleb);\n\treturn -EUCLEAN;\n\nout_dump:\n\tubifs_err(c, \"unexpected node type %d master LEB %d:%d\",\n\t\t  snod->type, lnum, snod->offs);\n\tubifs_scan_destroy(sleb);\n\treturn -EINVAL;\n}\n\n \nstatic int validate_master(const struct ubifs_info *c)\n{\n\tlong long main_sz;\n\tint err;\n\n\tif (c->max_sqnum >= SQNUM_WATERMARK) {\n\t\terr = 1;\n\t\tgoto out;\n\t}\n\n\tif (c->cmt_no >= c->max_sqnum) {\n\t\terr = 2;\n\t\tgoto out;\n\t}\n\n\tif (c->highest_inum >= INUM_WATERMARK) {\n\t\terr = 3;\n\t\tgoto out;\n\t}\n\n\tif (c->lhead_lnum < UBIFS_LOG_LNUM ||\n\t    c->lhead_lnum >= UBIFS_LOG_LNUM + c->log_lebs ||\n\t    c->lhead_offs < 0 || c->lhead_offs >= c->leb_size ||\n\t    c->lhead_offs & (c->min_io_size - 1)) {\n\t\terr = 4;\n\t\tgoto out;\n\t}\n\n\tif (c->zroot.lnum >= c->leb_cnt || c->zroot.lnum < c->main_first ||\n\t    c->zroot.offs >= c->leb_size || c->zroot.offs & 7) {\n\t\terr = 5;\n\t\tgoto out;\n\t}\n\n\tif (c->zroot.len < c->ranges[UBIFS_IDX_NODE].min_len ||\n\t    c->zroot.len > c->ranges[UBIFS_IDX_NODE].max_len) {\n\t\terr = 6;\n\t\tgoto out;\n\t}\n\n\tif (c->gc_lnum >= c->leb_cnt || c->gc_lnum < c->main_first) {\n\t\terr = 7;\n\t\tgoto out;\n\t}\n\n\tif (c->ihead_lnum >= c->leb_cnt || c->ihead_lnum < c->main_first ||\n\t    c->ihead_offs % c->min_io_size || c->ihead_offs < 0 ||\n\t    c->ihead_offs > c->leb_size || c->ihead_offs & 7) {\n\t\terr = 8;\n\t\tgoto out;\n\t}\n\n\tmain_sz = (long long)c->main_lebs * c->leb_size;\n\tif (c->bi.old_idx_sz & 7 || c->bi.old_idx_sz >= main_sz) {\n\t\terr = 9;\n\t\tgoto out;\n\t}\n\n\tif (c->lpt_lnum < c->lpt_first || c->lpt_lnum > c->lpt_last ||\n\t    c->lpt_offs < 0 || c->lpt_offs + c->nnode_sz > c->leb_size) {\n\t\terr = 10;\n\t\tgoto out;\n\t}\n\n\tif (c->nhead_lnum < c->lpt_first || c->nhead_lnum > c->lpt_last ||\n\t    c->nhead_offs < 0 || c->nhead_offs % c->min_io_size ||\n\t    c->nhead_offs > c->leb_size) {\n\t\terr = 11;\n\t\tgoto out;\n\t}\n\n\tif (c->ltab_lnum < c->lpt_first || c->ltab_lnum > c->lpt_last ||\n\t    c->ltab_offs < 0 ||\n\t    c->ltab_offs + c->ltab_sz > c->leb_size) {\n\t\terr = 12;\n\t\tgoto out;\n\t}\n\n\tif (c->big_lpt && (c->lsave_lnum < c->lpt_first ||\n\t    c->lsave_lnum > c->lpt_last || c->lsave_offs < 0 ||\n\t    c->lsave_offs + c->lsave_sz > c->leb_size)) {\n\t\terr = 13;\n\t\tgoto out;\n\t}\n\n\tif (c->lscan_lnum < c->main_first || c->lscan_lnum >= c->leb_cnt) {\n\t\terr = 14;\n\t\tgoto out;\n\t}\n\n\tif (c->lst.empty_lebs < 0 || c->lst.empty_lebs > c->main_lebs - 2) {\n\t\terr = 15;\n\t\tgoto out;\n\t}\n\n\tif (c->lst.idx_lebs < 0 || c->lst.idx_lebs > c->main_lebs - 1) {\n\t\terr = 16;\n\t\tgoto out;\n\t}\n\n\tif (c->lst.total_free < 0 || c->lst.total_free > main_sz ||\n\t    c->lst.total_free & 7) {\n\t\terr = 17;\n\t\tgoto out;\n\t}\n\n\tif (c->lst.total_dirty < 0 || (c->lst.total_dirty & 7)) {\n\t\terr = 18;\n\t\tgoto out;\n\t}\n\n\tif (c->lst.total_used < 0 || (c->lst.total_used & 7)) {\n\t\terr = 19;\n\t\tgoto out;\n\t}\n\n\tif (c->lst.total_free + c->lst.total_dirty +\n\t    c->lst.total_used > main_sz) {\n\t\terr = 20;\n\t\tgoto out;\n\t}\n\n\tif (c->lst.total_dead + c->lst.total_dark +\n\t    c->lst.total_used + c->bi.old_idx_sz > main_sz) {\n\t\terr = 21;\n\t\tgoto out;\n\t}\n\n\tif (c->lst.total_dead < 0 ||\n\t    c->lst.total_dead > c->lst.total_free + c->lst.total_dirty ||\n\t    c->lst.total_dead & 7) {\n\t\terr = 22;\n\t\tgoto out;\n\t}\n\n\tif (c->lst.total_dark < 0 ||\n\t    c->lst.total_dark > c->lst.total_free + c->lst.total_dirty ||\n\t    c->lst.total_dark & 7) {\n\t\terr = 23;\n\t\tgoto out;\n\t}\n\n\treturn 0;\n\nout:\n\tubifs_err(c, \"bad master node at offset %d error %d\", c->mst_offs, err);\n\tubifs_dump_node(c, c->mst_node, c->mst_node_alsz);\n\treturn -EINVAL;\n}\n\n \nint ubifs_read_master(struct ubifs_info *c)\n{\n\tint err, old_leb_cnt;\n\n\tc->mst_node = kzalloc(c->mst_node_alsz, GFP_KERNEL);\n\tif (!c->mst_node)\n\t\treturn -ENOMEM;\n\n\terr = scan_for_master(c);\n\tif (err) {\n\t\tif (err == -EUCLEAN)\n\t\t\terr = ubifs_recover_master_node(c);\n\t\tif (err)\n\t\t\t \n\t\t\treturn err;\n\t}\n\n\t \n\tc->mst_node->flags &= cpu_to_le32(~UBIFS_MST_RCVRY);\n\n\tc->max_sqnum       = le64_to_cpu(c->mst_node->ch.sqnum);\n\tc->highest_inum    = le64_to_cpu(c->mst_node->highest_inum);\n\tc->cmt_no          = le64_to_cpu(c->mst_node->cmt_no);\n\tc->zroot.lnum      = le32_to_cpu(c->mst_node->root_lnum);\n\tc->zroot.offs      = le32_to_cpu(c->mst_node->root_offs);\n\tc->zroot.len       = le32_to_cpu(c->mst_node->root_len);\n\tc->lhead_lnum      = le32_to_cpu(c->mst_node->log_lnum);\n\tc->gc_lnum         = le32_to_cpu(c->mst_node->gc_lnum);\n\tc->ihead_lnum      = le32_to_cpu(c->mst_node->ihead_lnum);\n\tc->ihead_offs      = le32_to_cpu(c->mst_node->ihead_offs);\n\tc->bi.old_idx_sz   = le64_to_cpu(c->mst_node->index_size);\n\tc->lpt_lnum        = le32_to_cpu(c->mst_node->lpt_lnum);\n\tc->lpt_offs        = le32_to_cpu(c->mst_node->lpt_offs);\n\tc->nhead_lnum      = le32_to_cpu(c->mst_node->nhead_lnum);\n\tc->nhead_offs      = le32_to_cpu(c->mst_node->nhead_offs);\n\tc->ltab_lnum       = le32_to_cpu(c->mst_node->ltab_lnum);\n\tc->ltab_offs       = le32_to_cpu(c->mst_node->ltab_offs);\n\tc->lsave_lnum      = le32_to_cpu(c->mst_node->lsave_lnum);\n\tc->lsave_offs      = le32_to_cpu(c->mst_node->lsave_offs);\n\tc->lscan_lnum      = le32_to_cpu(c->mst_node->lscan_lnum);\n\tc->lst.empty_lebs  = le32_to_cpu(c->mst_node->empty_lebs);\n\tc->lst.idx_lebs    = le32_to_cpu(c->mst_node->idx_lebs);\n\told_leb_cnt        = le32_to_cpu(c->mst_node->leb_cnt);\n\tc->lst.total_free  = le64_to_cpu(c->mst_node->total_free);\n\tc->lst.total_dirty = le64_to_cpu(c->mst_node->total_dirty);\n\tc->lst.total_used  = le64_to_cpu(c->mst_node->total_used);\n\tc->lst.total_dead  = le64_to_cpu(c->mst_node->total_dead);\n\tc->lst.total_dark  = le64_to_cpu(c->mst_node->total_dark);\n\n\tubifs_copy_hash(c, c->mst_node->hash_root_idx, c->zroot.hash);\n\n\tc->calc_idx_sz = c->bi.old_idx_sz;\n\n\tif (c->mst_node->flags & cpu_to_le32(UBIFS_MST_NO_ORPHS))\n\t\tc->no_orphs = 1;\n\n\tif (old_leb_cnt != c->leb_cnt) {\n\t\t \n\t\tint growth = c->leb_cnt - old_leb_cnt;\n\n\t\tif (c->leb_cnt < old_leb_cnt ||\n\t\t    c->leb_cnt < UBIFS_MIN_LEB_CNT) {\n\t\t\tubifs_err(c, \"bad leb_cnt on master node\");\n\t\t\tubifs_dump_node(c, c->mst_node, c->mst_node_alsz);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tdbg_mnt(\"Auto resizing (master) from %d LEBs to %d LEBs\",\n\t\t\told_leb_cnt, c->leb_cnt);\n\t\tc->lst.empty_lebs += growth;\n\t\tc->lst.total_free += growth * (long long)c->leb_size;\n\t\tc->lst.total_dark += growth * (long long)c->dark_wm;\n\n\t\t \n\t\tc->mst_node->leb_cnt = cpu_to_le32(c->leb_cnt);\n\t\tc->mst_node->empty_lebs = cpu_to_le32(c->lst.empty_lebs);\n\t\tc->mst_node->total_free = cpu_to_le64(c->lst.total_free);\n\t\tc->mst_node->total_dark = cpu_to_le64(c->lst.total_dark);\n\t}\n\n\terr = validate_master(c);\n\tif (err)\n\t\treturn err;\n\n\terr = dbg_old_index_check_init(c, &c->zroot);\n\n\treturn err;\n}\n\n \nint ubifs_write_master(struct ubifs_info *c)\n{\n\tint err, lnum, offs, len;\n\n\tubifs_assert(c, !c->ro_media && !c->ro_mount);\n\tif (c->ro_error)\n\t\treturn -EROFS;\n\n\tlnum = UBIFS_MST_LNUM;\n\toffs = c->mst_offs + c->mst_node_alsz;\n\tlen = UBIFS_MST_NODE_SZ;\n\n\tif (offs + UBIFS_MST_NODE_SZ > c->leb_size) {\n\t\terr = ubifs_leb_unmap(c, lnum);\n\t\tif (err)\n\t\t\treturn err;\n\t\toffs = 0;\n\t}\n\n\tc->mst_offs = offs;\n\tc->mst_node->highest_inum = cpu_to_le64(c->highest_inum);\n\n\tubifs_copy_hash(c, c->zroot.hash, c->mst_node->hash_root_idx);\n\terr = ubifs_write_node_hmac(c, c->mst_node, len, lnum, offs,\n\t\t\t\t    offsetof(struct ubifs_mst_node, hmac));\n\tif (err)\n\t\treturn err;\n\n\tlnum += 1;\n\n\tif (offs == 0) {\n\t\terr = ubifs_leb_unmap(c, lnum);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\terr = ubifs_write_node_hmac(c, c->mst_node, len, lnum, offs,\n\t\t\t\t    offsetof(struct ubifs_mst_node, hmac));\n\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}