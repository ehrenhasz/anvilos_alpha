{
  "module_name": "file.c",
  "hash_id": "8e2a6487691dc2acf92dd2ceba2e9f36f45dd7e812f4b82382ced031ea3af396",
  "original_prompt": "Ingested from linux-6.6.14/fs/ubifs/file.c",
  "human_readable_source": "\n \n\n \n\n#include \"ubifs.h\"\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/migrate.h>\n\nstatic int read_block(struct inode *inode, void *addr, unsigned int block,\n\t\t      struct ubifs_data_node *dn)\n{\n\tstruct ubifs_info *c = inode->i_sb->s_fs_info;\n\tint err, len, out_len;\n\tunion ubifs_key key;\n\tunsigned int dlen;\n\n\tdata_key_init(c, &key, inode->i_ino, block);\n\terr = ubifs_tnc_lookup(c, &key, dn);\n\tif (err) {\n\t\tif (err == -ENOENT)\n\t\t\t \n\t\t\tmemset(addr, 0, UBIFS_BLOCK_SIZE);\n\t\treturn err;\n\t}\n\n\tubifs_assert(c, le64_to_cpu(dn->ch.sqnum) >\n\t\t     ubifs_inode(inode)->creat_sqnum);\n\tlen = le32_to_cpu(dn->size);\n\tif (len <= 0 || len > UBIFS_BLOCK_SIZE)\n\t\tgoto dump;\n\n\tdlen = le32_to_cpu(dn->ch.len) - UBIFS_DATA_NODE_SZ;\n\n\tif (IS_ENCRYPTED(inode)) {\n\t\terr = ubifs_decrypt(inode, dn, &dlen, block);\n\t\tif (err)\n\t\t\tgoto dump;\n\t}\n\n\tout_len = UBIFS_BLOCK_SIZE;\n\terr = ubifs_decompress(c, &dn->data, dlen, addr, &out_len,\n\t\t\t       le16_to_cpu(dn->compr_type));\n\tif (err || len != out_len)\n\t\tgoto dump;\n\n\t \n\tif (len < UBIFS_BLOCK_SIZE)\n\t\tmemset(addr + len, 0, UBIFS_BLOCK_SIZE - len);\n\n\treturn 0;\n\ndump:\n\tubifs_err(c, \"bad data node (block %u, inode %lu)\",\n\t\t  block, inode->i_ino);\n\tubifs_dump_node(c, dn, UBIFS_MAX_DATA_NODE_SZ);\n\treturn -EINVAL;\n}\n\nstatic int do_readpage(struct page *page)\n{\n\tvoid *addr;\n\tint err = 0, i;\n\tunsigned int block, beyond;\n\tstruct ubifs_data_node *dn;\n\tstruct inode *inode = page->mapping->host;\n\tstruct ubifs_info *c = inode->i_sb->s_fs_info;\n\tloff_t i_size = i_size_read(inode);\n\n\tdbg_gen(\"ino %lu, pg %lu, i_size %lld, flags %#lx\",\n\t\tinode->i_ino, page->index, i_size, page->flags);\n\tubifs_assert(c, !PageChecked(page));\n\tubifs_assert(c, !PagePrivate(page));\n\n\taddr = kmap(page);\n\n\tblock = page->index << UBIFS_BLOCKS_PER_PAGE_SHIFT;\n\tbeyond = (i_size + UBIFS_BLOCK_SIZE - 1) >> UBIFS_BLOCK_SHIFT;\n\tif (block >= beyond) {\n\t\t \n\t\tSetPageChecked(page);\n\t\tmemset(addr, 0, PAGE_SIZE);\n\t\tgoto out;\n\t}\n\n\tdn = kmalloc(UBIFS_MAX_DATA_NODE_SZ, GFP_NOFS);\n\tif (!dn) {\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\ti = 0;\n\twhile (1) {\n\t\tint ret;\n\n\t\tif (block >= beyond) {\n\t\t\t \n\t\t\terr = -ENOENT;\n\t\t\tmemset(addr, 0, UBIFS_BLOCK_SIZE);\n\t\t} else {\n\t\t\tret = read_block(inode, addr, block, dn);\n\t\t\tif (ret) {\n\t\t\t\terr = ret;\n\t\t\t\tif (err != -ENOENT)\n\t\t\t\t\tbreak;\n\t\t\t} else if (block + 1 == beyond) {\n\t\t\t\tint dlen = le32_to_cpu(dn->size);\n\t\t\t\tint ilen = i_size & (UBIFS_BLOCK_SIZE - 1);\n\n\t\t\t\tif (ilen && ilen < dlen)\n\t\t\t\t\tmemset(addr + ilen, 0, dlen - ilen);\n\t\t\t}\n\t\t}\n\t\tif (++i >= UBIFS_BLOCKS_PER_PAGE)\n\t\t\tbreak;\n\t\tblock += 1;\n\t\taddr += UBIFS_BLOCK_SIZE;\n\t}\n\tif (err) {\n\t\tstruct ubifs_info *c = inode->i_sb->s_fs_info;\n\t\tif (err == -ENOENT) {\n\t\t\t \n\t\t\tSetPageChecked(page);\n\t\t\tdbg_gen(\"hole\");\n\t\t\tgoto out_free;\n\t\t}\n\t\tubifs_err(c, \"cannot read page %lu of inode %lu, error %d\",\n\t\t\t  page->index, inode->i_ino, err);\n\t\tgoto error;\n\t}\n\nout_free:\n\tkfree(dn);\nout:\n\tSetPageUptodate(page);\n\tClearPageError(page);\n\tflush_dcache_page(page);\n\tkunmap(page);\n\treturn 0;\n\nerror:\n\tkfree(dn);\n\tClearPageUptodate(page);\n\tSetPageError(page);\n\tflush_dcache_page(page);\n\tkunmap(page);\n\treturn err;\n}\n\n \nstatic void release_new_page_budget(struct ubifs_info *c)\n{\n\tstruct ubifs_budget_req req = { .recalculate = 1, .new_page = 1 };\n\n\tubifs_release_budget(c, &req);\n}\n\n \nstatic void release_existing_page_budget(struct ubifs_info *c)\n{\n\tstruct ubifs_budget_req req = { .dd_growth = c->bi.page_budget};\n\n\tubifs_release_budget(c, &req);\n}\n\nstatic int write_begin_slow(struct address_space *mapping,\n\t\t\t    loff_t pos, unsigned len, struct page **pagep)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct ubifs_info *c = inode->i_sb->s_fs_info;\n\tpgoff_t index = pos >> PAGE_SHIFT;\n\tstruct ubifs_budget_req req = { .new_page = 1 };\n\tint err, appending = !!(pos + len > inode->i_size);\n\tstruct page *page;\n\n\tdbg_gen(\"ino %lu, pos %llu, len %u, i_size %lld\",\n\t\tinode->i_ino, pos, len, inode->i_size);\n\n\t \n\tif (appending)\n\t\t \n\t\treq.dirtied_ino = 1;\n\n\terr = ubifs_budget_space(c, &req);\n\tif (unlikely(err))\n\t\treturn err;\n\n\tpage = grab_cache_page_write_begin(mapping, index);\n\tif (unlikely(!page)) {\n\t\tubifs_release_budget(c, &req);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (!PageUptodate(page)) {\n\t\tif (!(pos & ~PAGE_MASK) && len == PAGE_SIZE)\n\t\t\tSetPageChecked(page);\n\t\telse {\n\t\t\terr = do_readpage(page);\n\t\t\tif (err) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tput_page(page);\n\t\t\t\tubifs_release_budget(c, &req);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\n\t\tSetPageUptodate(page);\n\t\tClearPageError(page);\n\t}\n\n\tif (PagePrivate(page))\n\t\t \n\t\trelease_new_page_budget(c);\n\telse if (!PageChecked(page))\n\t\t \n\t\tubifs_convert_page_budget(c);\n\n\tif (appending) {\n\t\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\n\t\t \n\t\tmutex_lock(&ui->ui_mutex);\n\t\tif (ui->dirty)\n\t\t\t \n\t\t\tubifs_release_dirty_inode_budget(c, ui);\n\t}\n\n\t*pagep = page;\n\treturn 0;\n}\n\n \nstatic int allocate_budget(struct ubifs_info *c, struct page *page,\n\t\t\t   struct ubifs_inode *ui, int appending)\n{\n\tstruct ubifs_budget_req req = { .fast = 1 };\n\n\tif (PagePrivate(page)) {\n\t\tif (!appending)\n\t\t\t \n\t\t\treturn 0;\n\n\t\tmutex_lock(&ui->ui_mutex);\n\t\tif (ui->dirty)\n\t\t\t \n\t\t\treturn 0;\n\n\t\t \n\t\treq.dirtied_ino = 1;\n\t} else {\n\t\tif (PageChecked(page))\n\t\t\t \n\t\t\treq.new_page = 1;\n\t\telse\n\t\t\t \n\t\t\treq.dirtied_page = 1;\n\n\t\tif (appending) {\n\t\t\tmutex_lock(&ui->ui_mutex);\n\t\t\tif (!ui->dirty)\n\t\t\t\t \n\t\t\t\treq.dirtied_ino = 1;\n\t\t}\n\t}\n\n\treturn ubifs_budget_space(c, &req);\n}\n\n \nstatic int ubifs_write_begin(struct file *file, struct address_space *mapping,\n\t\t\t     loff_t pos, unsigned len,\n\t\t\t     struct page **pagep, void **fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct ubifs_info *c = inode->i_sb->s_fs_info;\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\tpgoff_t index = pos >> PAGE_SHIFT;\n\tint err, appending = !!(pos + len > inode->i_size);\n\tint skipped_read = 0;\n\tstruct page *page;\n\n\tubifs_assert(c, ubifs_inode(inode)->ui_size == inode->i_size);\n\tubifs_assert(c, !c->ro_media && !c->ro_mount);\n\n\tif (unlikely(c->ro_error))\n\t\treturn -EROFS;\n\n\t \n\tpage = grab_cache_page_write_begin(mapping, index);\n\tif (unlikely(!page))\n\t\treturn -ENOMEM;\n\n\tif (!PageUptodate(page)) {\n\t\t \n\t\tif (!(pos & ~PAGE_MASK) && len == PAGE_SIZE) {\n\t\t\t \n\t\t\tSetPageChecked(page);\n\t\t\tskipped_read = 1;\n\t\t} else {\n\t\t\terr = do_readpage(page);\n\t\t\tif (err) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tput_page(page);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\n\t\tSetPageUptodate(page);\n\t\tClearPageError(page);\n\t}\n\n\terr = allocate_budget(c, page, ui, appending);\n\tif (unlikely(err)) {\n\t\tubifs_assert(c, err == -ENOSPC);\n\t\t \n\t\tif (skipped_read) {\n\t\t\tClearPageChecked(page);\n\t\t\tClearPageUptodate(page);\n\t\t}\n\t\t \n\t\tif (appending) {\n\t\t\tubifs_assert(c, mutex_is_locked(&ui->ui_mutex));\n\t\t\tmutex_unlock(&ui->ui_mutex);\n\t\t}\n\t\tunlock_page(page);\n\t\tput_page(page);\n\n\t\treturn write_begin_slow(mapping, pos, len, pagep);\n\t}\n\n\t \n\t*pagep = page;\n\treturn 0;\n\n}\n\n \nstatic void cancel_budget(struct ubifs_info *c, struct page *page,\n\t\t\t  struct ubifs_inode *ui, int appending)\n{\n\tif (appending) {\n\t\tif (!ui->dirty)\n\t\t\tubifs_release_dirty_inode_budget(c, ui);\n\t\tmutex_unlock(&ui->ui_mutex);\n\t}\n\tif (!PagePrivate(page)) {\n\t\tif (PageChecked(page))\n\t\t\trelease_new_page_budget(c);\n\t\telse\n\t\t\trelease_existing_page_budget(c);\n\t}\n}\n\nstatic int ubifs_write_end(struct file *file, struct address_space *mapping,\n\t\t\t   loff_t pos, unsigned len, unsigned copied,\n\t\t\t   struct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\tstruct ubifs_info *c = inode->i_sb->s_fs_info;\n\tloff_t end_pos = pos + len;\n\tint appending = !!(end_pos > inode->i_size);\n\n\tdbg_gen(\"ino %lu, pos %llu, pg %lu, len %u, copied %d, i_size %lld\",\n\t\tinode->i_ino, pos, page->index, len, copied, inode->i_size);\n\n\tif (unlikely(copied < len && len == PAGE_SIZE)) {\n\t\t \n\t\tdbg_gen(\"copied %d instead of %d, read page and repeat\",\n\t\t\tcopied, len);\n\t\tcancel_budget(c, page, ui, appending);\n\t\tClearPageChecked(page);\n\n\t\t \n\t\tcopied = do_readpage(page);\n\t\tgoto out;\n\t}\n\n\tif (!PagePrivate(page)) {\n\t\tattach_page_private(page, (void *)1);\n\t\tatomic_long_inc(&c->dirty_pg_cnt);\n\t\t__set_page_dirty_nobuffers(page);\n\t}\n\n\tif (appending) {\n\t\ti_size_write(inode, end_pos);\n\t\tui->ui_size = end_pos;\n\t\t \n\t\t__mark_inode_dirty(inode, I_DIRTY_DATASYNC);\n\t\tubifs_assert(c, mutex_is_locked(&ui->ui_mutex));\n\t\tmutex_unlock(&ui->ui_mutex);\n\t}\n\nout:\n\tunlock_page(page);\n\tput_page(page);\n\treturn copied;\n}\n\n \nstatic int populate_page(struct ubifs_info *c, struct page *page,\n\t\t\t struct bu_info *bu, int *n)\n{\n\tint i = 0, nn = *n, offs = bu->zbranch[0].offs, hole = 0, read = 0;\n\tstruct inode *inode = page->mapping->host;\n\tloff_t i_size = i_size_read(inode);\n\tunsigned int page_block;\n\tvoid *addr, *zaddr;\n\tpgoff_t end_index;\n\n\tdbg_gen(\"ino %lu, pg %lu, i_size %lld, flags %#lx\",\n\t\tinode->i_ino, page->index, i_size, page->flags);\n\n\taddr = zaddr = kmap(page);\n\n\tend_index = (i_size - 1) >> PAGE_SHIFT;\n\tif (!i_size || page->index > end_index) {\n\t\thole = 1;\n\t\tmemset(addr, 0, PAGE_SIZE);\n\t\tgoto out_hole;\n\t}\n\n\tpage_block = page->index << UBIFS_BLOCKS_PER_PAGE_SHIFT;\n\twhile (1) {\n\t\tint err, len, out_len, dlen;\n\n\t\tif (nn >= bu->cnt) {\n\t\t\thole = 1;\n\t\t\tmemset(addr, 0, UBIFS_BLOCK_SIZE);\n\t\t} else if (key_block(c, &bu->zbranch[nn].key) == page_block) {\n\t\t\tstruct ubifs_data_node *dn;\n\n\t\t\tdn = bu->buf + (bu->zbranch[nn].offs - offs);\n\n\t\t\tubifs_assert(c, le64_to_cpu(dn->ch.sqnum) >\n\t\t\t\t     ubifs_inode(inode)->creat_sqnum);\n\n\t\t\tlen = le32_to_cpu(dn->size);\n\t\t\tif (len <= 0 || len > UBIFS_BLOCK_SIZE)\n\t\t\t\tgoto out_err;\n\n\t\t\tdlen = le32_to_cpu(dn->ch.len) - UBIFS_DATA_NODE_SZ;\n\t\t\tout_len = UBIFS_BLOCK_SIZE;\n\n\t\t\tif (IS_ENCRYPTED(inode)) {\n\t\t\t\terr = ubifs_decrypt(inode, dn, &dlen, page_block);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out_err;\n\t\t\t}\n\n\t\t\terr = ubifs_decompress(c, &dn->data, dlen, addr, &out_len,\n\t\t\t\t\t       le16_to_cpu(dn->compr_type));\n\t\t\tif (err || len != out_len)\n\t\t\t\tgoto out_err;\n\n\t\t\tif (len < UBIFS_BLOCK_SIZE)\n\t\t\t\tmemset(addr + len, 0, UBIFS_BLOCK_SIZE - len);\n\n\t\t\tnn += 1;\n\t\t\tread = (i << UBIFS_BLOCK_SHIFT) + len;\n\t\t} else if (key_block(c, &bu->zbranch[nn].key) < page_block) {\n\t\t\tnn += 1;\n\t\t\tcontinue;\n\t\t} else {\n\t\t\thole = 1;\n\t\t\tmemset(addr, 0, UBIFS_BLOCK_SIZE);\n\t\t}\n\t\tif (++i >= UBIFS_BLOCKS_PER_PAGE)\n\t\t\tbreak;\n\t\taddr += UBIFS_BLOCK_SIZE;\n\t\tpage_block += 1;\n\t}\n\n\tif (end_index == page->index) {\n\t\tint len = i_size & (PAGE_SIZE - 1);\n\n\t\tif (len && len < read)\n\t\t\tmemset(zaddr + len, 0, read - len);\n\t}\n\nout_hole:\n\tif (hole) {\n\t\tSetPageChecked(page);\n\t\tdbg_gen(\"hole\");\n\t}\n\n\tSetPageUptodate(page);\n\tClearPageError(page);\n\tflush_dcache_page(page);\n\tkunmap(page);\n\t*n = nn;\n\treturn 0;\n\nout_err:\n\tClearPageUptodate(page);\n\tSetPageError(page);\n\tflush_dcache_page(page);\n\tkunmap(page);\n\tubifs_err(c, \"bad data node (block %u, inode %lu)\",\n\t\t  page_block, inode->i_ino);\n\treturn -EINVAL;\n}\n\n \nstatic int ubifs_do_bulk_read(struct ubifs_info *c, struct bu_info *bu,\n\t\t\t      struct page *page1)\n{\n\tpgoff_t offset = page1->index, end_index;\n\tstruct address_space *mapping = page1->mapping;\n\tstruct inode *inode = mapping->host;\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\tint err, page_idx, page_cnt, ret = 0, n = 0;\n\tint allocate = bu->buf ? 0 : 1;\n\tloff_t isize;\n\tgfp_t ra_gfp_mask = readahead_gfp_mask(mapping) & ~__GFP_FS;\n\n\terr = ubifs_tnc_get_bu_keys(c, bu);\n\tif (err)\n\t\tgoto out_warn;\n\n\tif (bu->eof) {\n\t\t \n\t\tui->read_in_a_row = 1;\n\t\tui->bulk_read = 0;\n\t}\n\n\tpage_cnt = bu->blk_cnt >> UBIFS_BLOCKS_PER_PAGE_SHIFT;\n\tif (!page_cnt) {\n\t\t \n\t\tgoto out_bu_off;\n\t}\n\n\tif (bu->cnt) {\n\t\tif (allocate) {\n\t\t\t \n\t\t\tbu->buf_len = bu->zbranch[bu->cnt - 1].offs +\n\t\t\t\t      bu->zbranch[bu->cnt - 1].len -\n\t\t\t\t      bu->zbranch[0].offs;\n\t\t\tubifs_assert(c, bu->buf_len > 0);\n\t\t\tubifs_assert(c, bu->buf_len <= c->leb_size);\n\t\t\tbu->buf = kmalloc(bu->buf_len, GFP_NOFS | __GFP_NOWARN);\n\t\t\tif (!bu->buf)\n\t\t\t\tgoto out_bu_off;\n\t\t}\n\n\t\terr = ubifs_tnc_bulk_read(c, bu);\n\t\tif (err)\n\t\t\tgoto out_warn;\n\t}\n\n\terr = populate_page(c, page1, bu, &n);\n\tif (err)\n\t\tgoto out_warn;\n\n\tunlock_page(page1);\n\tret = 1;\n\n\tisize = i_size_read(inode);\n\tif (isize == 0)\n\t\tgoto out_free;\n\tend_index = ((isize - 1) >> PAGE_SHIFT);\n\n\tfor (page_idx = 1; page_idx < page_cnt; page_idx++) {\n\t\tpgoff_t page_offset = offset + page_idx;\n\t\tstruct page *page;\n\n\t\tif (page_offset > end_index)\n\t\t\tbreak;\n\t\tpage = pagecache_get_page(mapping, page_offset,\n\t\t\t\t FGP_LOCK|FGP_ACCESSED|FGP_CREAT|FGP_NOWAIT,\n\t\t\t\t ra_gfp_mask);\n\t\tif (!page)\n\t\t\tbreak;\n\t\tif (!PageUptodate(page))\n\t\t\terr = populate_page(c, page, bu, &n);\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tui->last_page_read = offset + page_idx - 1;\n\nout_free:\n\tif (allocate)\n\t\tkfree(bu->buf);\n\treturn ret;\n\nout_warn:\n\tubifs_warn(c, \"ignoring error %d and skipping bulk-read\", err);\n\tgoto out_free;\n\nout_bu_off:\n\tui->read_in_a_row = ui->bulk_read = 0;\n\tgoto out_free;\n}\n\n \nstatic int ubifs_bulk_read(struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct ubifs_info *c = inode->i_sb->s_fs_info;\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\tpgoff_t index = page->index, last_page_read = ui->last_page_read;\n\tstruct bu_info *bu;\n\tint err = 0, allocated = 0;\n\n\tui->last_page_read = index;\n\tif (!c->bulk_read)\n\t\treturn 0;\n\n\t \n\tif (!mutex_trylock(&ui->ui_mutex))\n\t\treturn 0;\n\n\tif (index != last_page_read + 1) {\n\t\t \n\t\tui->read_in_a_row = 1;\n\t\tif (ui->bulk_read)\n\t\t\tui->bulk_read = 0;\n\t\tgoto out_unlock;\n\t}\n\n\tif (!ui->bulk_read) {\n\t\tui->read_in_a_row += 1;\n\t\tif (ui->read_in_a_row < 3)\n\t\t\tgoto out_unlock;\n\t\t \n\t\tui->bulk_read = 1;\n\t}\n\n\t \n\tif (mutex_trylock(&c->bu_mutex))\n\t\tbu = &c->bu;\n\telse {\n\t\tbu = kmalloc(sizeof(struct bu_info), GFP_NOFS | __GFP_NOWARN);\n\t\tif (!bu)\n\t\t\tgoto out_unlock;\n\n\t\tbu->buf = NULL;\n\t\tallocated = 1;\n\t}\n\n\tbu->buf_len = c->max_bu_buf_len;\n\tdata_key_init(c, &bu->key, inode->i_ino,\n\t\t      page->index << UBIFS_BLOCKS_PER_PAGE_SHIFT);\n\terr = ubifs_do_bulk_read(c, bu, page);\n\n\tif (!allocated)\n\t\tmutex_unlock(&c->bu_mutex);\n\telse\n\t\tkfree(bu);\n\nout_unlock:\n\tmutex_unlock(&ui->ui_mutex);\n\treturn err;\n}\n\nstatic int ubifs_read_folio(struct file *file, struct folio *folio)\n{\n\tstruct page *page = &folio->page;\n\n\tif (ubifs_bulk_read(page))\n\t\treturn 0;\n\tdo_readpage(page);\n\tfolio_unlock(folio);\n\treturn 0;\n}\n\nstatic int do_writepage(struct page *page, int len)\n{\n\tint err = 0, i, blen;\n\tunsigned int block;\n\tvoid *addr;\n\tunion ubifs_key key;\n\tstruct inode *inode = page->mapping->host;\n\tstruct ubifs_info *c = inode->i_sb->s_fs_info;\n\n#ifdef UBIFS_DEBUG\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\tspin_lock(&ui->ui_lock);\n\tubifs_assert(c, page->index <= ui->synced_i_size >> PAGE_SHIFT);\n\tspin_unlock(&ui->ui_lock);\n#endif\n\n\t \n\tset_page_writeback(page);\n\n\taddr = kmap(page);\n\tblock = page->index << UBIFS_BLOCKS_PER_PAGE_SHIFT;\n\ti = 0;\n\twhile (len) {\n\t\tblen = min_t(int, len, UBIFS_BLOCK_SIZE);\n\t\tdata_key_init(c, &key, inode->i_ino, block);\n\t\terr = ubifs_jnl_write_data(c, inode, &key, addr, blen);\n\t\tif (err)\n\t\t\tbreak;\n\t\tif (++i >= UBIFS_BLOCKS_PER_PAGE)\n\t\t\tbreak;\n\t\tblock += 1;\n\t\taddr += blen;\n\t\tlen -= blen;\n\t}\n\tif (err) {\n\t\tSetPageError(page);\n\t\tubifs_err(c, \"cannot write page %lu of inode %lu, error %d\",\n\t\t\t  page->index, inode->i_ino, err);\n\t\tubifs_ro_mode(c, err);\n\t}\n\n\tubifs_assert(c, PagePrivate(page));\n\tif (PageChecked(page))\n\t\trelease_new_page_budget(c);\n\telse\n\t\trelease_existing_page_budget(c);\n\n\tatomic_long_dec(&c->dirty_pg_cnt);\n\tdetach_page_private(page);\n\tClearPageChecked(page);\n\n\tkunmap(page);\n\tunlock_page(page);\n\tend_page_writeback(page);\n\treturn err;\n}\n\n \nstatic int ubifs_writepage(struct page *page, struct writeback_control *wbc)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct ubifs_info *c = inode->i_sb->s_fs_info;\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\tloff_t i_size =  i_size_read(inode), synced_i_size;\n\tpgoff_t end_index = i_size >> PAGE_SHIFT;\n\tint err, len = i_size & (PAGE_SIZE - 1);\n\tvoid *kaddr;\n\n\tdbg_gen(\"ino %lu, pg %lu, pg flags %#lx\",\n\t\tinode->i_ino, page->index, page->flags);\n\tubifs_assert(c, PagePrivate(page));\n\n\t \n\tif (page->index > end_index || (page->index == end_index && !len)) {\n\t\terr = 0;\n\t\tgoto out_unlock;\n\t}\n\n\tspin_lock(&ui->ui_lock);\n\tsynced_i_size = ui->synced_i_size;\n\tspin_unlock(&ui->ui_lock);\n\n\t \n\tif (page->index < end_index) {\n\t\tif (page->index >= synced_i_size >> PAGE_SHIFT) {\n\t\t\terr = inode->i_sb->s_op->write_inode(inode, NULL);\n\t\t\tif (err)\n\t\t\t\tgoto out_redirty;\n\t\t\t \n\t\t}\n\t\treturn do_writepage(page, PAGE_SIZE);\n\t}\n\n\t \n\tkaddr = kmap_atomic(page);\n\tmemset(kaddr + len, 0, PAGE_SIZE - len);\n\tflush_dcache_page(page);\n\tkunmap_atomic(kaddr);\n\n\tif (i_size > synced_i_size) {\n\t\terr = inode->i_sb->s_op->write_inode(inode, NULL);\n\t\tif (err)\n\t\t\tgoto out_redirty;\n\t}\n\n\treturn do_writepage(page, len);\nout_redirty:\n\t \n\tredirty_page_for_writepage(wbc, page);\nout_unlock:\n\tunlock_page(page);\n\treturn err;\n}\n\n \nstatic void do_attr_changes(struct inode *inode, const struct iattr *attr)\n{\n\tif (attr->ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (attr->ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (attr->ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = attr->ia_atime;\n\tif (attr->ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = attr->ia_mtime;\n\tif (attr->ia_valid & ATTR_CTIME)\n\t\tinode_set_ctime_to_ts(inode, attr->ia_ctime);\n\tif (attr->ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) && !capable(CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}\n\n \nstatic int do_truncation(struct ubifs_info *c, struct inode *inode,\n\t\t\t const struct iattr *attr)\n{\n\tint err;\n\tstruct ubifs_budget_req req;\n\tloff_t old_size = inode->i_size, new_size = attr->ia_size;\n\tint offset = new_size & (UBIFS_BLOCK_SIZE - 1), budgeted = 1;\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\n\tdbg_gen(\"ino %lu, size %lld -> %lld\", inode->i_ino, old_size, new_size);\n\tmemset(&req, 0, sizeof(struct ubifs_budget_req));\n\n\t \n\tif (new_size & (UBIFS_BLOCK_SIZE - 1))\n\t\treq.dirtied_page = 1;\n\n\treq.dirtied_ino = 1;\n\t \n\treq.dirtied_ino_d = UBIFS_TRUN_NODE_SZ;\n\terr = ubifs_budget_space(c, &req);\n\tif (err) {\n\t\t \n\t\tif (new_size || err != -ENOSPC)\n\t\t\treturn err;\n\t\tbudgeted = 0;\n\t}\n\n\ttruncate_setsize(inode, new_size);\n\n\tif (offset) {\n\t\tpgoff_t index = new_size >> PAGE_SHIFT;\n\t\tstruct page *page;\n\n\t\tpage = find_lock_page(inode->i_mapping, index);\n\t\tif (page) {\n\t\t\tif (PageDirty(page)) {\n\t\t\t\t \n\t\t\t\tubifs_assert(c, PagePrivate(page));\n\n\t\t\t\tclear_page_dirty_for_io(page);\n\t\t\t\tif (UBIFS_BLOCKS_PER_PAGE_SHIFT)\n\t\t\t\t\toffset = new_size &\n\t\t\t\t\t\t (PAGE_SIZE - 1);\n\t\t\t\terr = do_writepage(page, offset);\n\t\t\t\tput_page(page);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out_budg;\n\t\t\t\t \n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tunlock_page(page);\n\t\t\t\tput_page(page);\n\t\t\t}\n\t\t}\n\t}\n\n\tmutex_lock(&ui->ui_mutex);\n\tui->ui_size = inode->i_size;\n\t \n\tinode->i_mtime = inode_set_ctime_current(inode);\n\t \n\tdo_attr_changes(inode, attr);\n\terr = ubifs_jnl_truncate(c, inode, old_size, new_size);\n\tmutex_unlock(&ui->ui_mutex);\n\nout_budg:\n\tif (budgeted)\n\t\tubifs_release_budget(c, &req);\n\telse {\n\t\tc->bi.nospace = c->bi.nospace_rp = 0;\n\t\tsmp_wmb();\n\t}\n\treturn err;\n}\n\n \nstatic int do_setattr(struct ubifs_info *c, struct inode *inode,\n\t\t      const struct iattr *attr)\n{\n\tint err, release;\n\tloff_t new_size = attr->ia_size;\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\tstruct ubifs_budget_req req = { .dirtied_ino = 1,\n\t\t\t\t.dirtied_ino_d = ALIGN(ui->data_len, 8) };\n\n\terr = ubifs_budget_space(c, &req);\n\tif (err)\n\t\treturn err;\n\n\tif (attr->ia_valid & ATTR_SIZE) {\n\t\tdbg_gen(\"size %lld -> %lld\", inode->i_size, new_size);\n\t\ttruncate_setsize(inode, new_size);\n\t}\n\n\tmutex_lock(&ui->ui_mutex);\n\tif (attr->ia_valid & ATTR_SIZE) {\n\t\t \n\t\tinode->i_mtime = inode_set_ctime_current(inode);\n\t\t \n\t\tui->ui_size = inode->i_size;\n\t}\n\n\tdo_attr_changes(inode, attr);\n\n\trelease = ui->dirty;\n\tif (attr->ia_valid & ATTR_SIZE)\n\t\t \n\t\t __mark_inode_dirty(inode, I_DIRTY_DATASYNC);\n\telse\n\t\tmark_inode_dirty_sync(inode);\n\tmutex_unlock(&ui->ui_mutex);\n\n\tif (release)\n\t\tubifs_release_budget(c, &req);\n\tif (IS_SYNC(inode))\n\t\terr = inode->i_sb->s_op->write_inode(inode, NULL);\n\treturn err;\n}\n\nint ubifs_setattr(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\t  struct iattr *attr)\n{\n\tint err;\n\tstruct inode *inode = d_inode(dentry);\n\tstruct ubifs_info *c = inode->i_sb->s_fs_info;\n\n\tdbg_gen(\"ino %lu, mode %#x, ia_valid %#x\",\n\t\tinode->i_ino, inode->i_mode, attr->ia_valid);\n\terr = setattr_prepare(&nop_mnt_idmap, dentry, attr);\n\tif (err)\n\t\treturn err;\n\n\terr = dbg_check_synced_i_size(c, inode);\n\tif (err)\n\t\treturn err;\n\n\terr = fscrypt_prepare_setattr(dentry, attr);\n\tif (err)\n\t\treturn err;\n\n\tif ((attr->ia_valid & ATTR_SIZE) && attr->ia_size < inode->i_size)\n\t\t \n\t\terr = do_truncation(c, inode, attr);\n\telse\n\t\terr = do_setattr(c, inode, attr);\n\n\treturn err;\n}\n\nstatic void ubifs_invalidate_folio(struct folio *folio, size_t offset,\n\t\t\t\t size_t length)\n{\n\tstruct inode *inode = folio->mapping->host;\n\tstruct ubifs_info *c = inode->i_sb->s_fs_info;\n\n\tubifs_assert(c, folio_test_private(folio));\n\tif (offset || length < folio_size(folio))\n\t\t \n\t\treturn;\n\n\tif (folio_test_checked(folio))\n\t\trelease_new_page_budget(c);\n\telse\n\t\trelease_existing_page_budget(c);\n\n\tatomic_long_dec(&c->dirty_pg_cnt);\n\tfolio_detach_private(folio);\n\tfolio_clear_checked(folio);\n}\n\nint ubifs_fsync(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct ubifs_info *c = inode->i_sb->s_fs_info;\n\tint err;\n\n\tdbg_gen(\"syncing inode %lu\", inode->i_ino);\n\n\tif (c->ro_mount)\n\t\t \n\t\treturn 0;\n\n\terr = file_write_and_wait_range(file, start, end);\n\tif (err)\n\t\treturn err;\n\tinode_lock(inode);\n\n\t \n\tif (!datasync || (inode->i_state & I_DIRTY_DATASYNC)) {\n\t\terr = inode->i_sb->s_op->write_inode(inode, NULL);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\t \n\terr = ubifs_sync_wbufs_by_inode(c, inode);\nout:\n\tinode_unlock(inode);\n\treturn err;\n}\n\n \nstatic inline int mctime_update_needed(const struct inode *inode,\n\t\t\t\t       const struct timespec64 *now)\n{\n\tstruct timespec64 ctime = inode_get_ctime(inode);\n\n\tif (!timespec64_equal(&inode->i_mtime, now) ||\n\t    !timespec64_equal(&ctime, now))\n\t\treturn 1;\n\treturn 0;\n}\n\n \nint ubifs_update_time(struct inode *inode, int flags)\n{\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\tstruct ubifs_info *c = inode->i_sb->s_fs_info;\n\tstruct ubifs_budget_req req = { .dirtied_ino = 1,\n\t\t\t.dirtied_ino_d = ALIGN(ui->data_len, 8) };\n\tint err, release;\n\n\tif (!IS_ENABLED(CONFIG_UBIFS_ATIME_SUPPORT)) {\n\t\tgeneric_update_time(inode, flags);\n\t\treturn 0;\n\t}\n\n\terr = ubifs_budget_space(c, &req);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&ui->ui_mutex);\n\tinode_update_timestamps(inode, flags);\n\trelease = ui->dirty;\n\t__mark_inode_dirty(inode, I_DIRTY_SYNC);\n\tmutex_unlock(&ui->ui_mutex);\n\tif (release)\n\t\tubifs_release_budget(c, &req);\n\treturn 0;\n}\n\n \nstatic int update_mctime(struct inode *inode)\n{\n\tstruct timespec64 now = current_time(inode);\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\tstruct ubifs_info *c = inode->i_sb->s_fs_info;\n\n\tif (mctime_update_needed(inode, &now)) {\n\t\tint err, release;\n\t\tstruct ubifs_budget_req req = { .dirtied_ino = 1,\n\t\t\t\t.dirtied_ino_d = ALIGN(ui->data_len, 8) };\n\n\t\terr = ubifs_budget_space(c, &req);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tmutex_lock(&ui->ui_mutex);\n\t\tinode->i_mtime = inode_set_ctime_current(inode);\n\t\trelease = ui->dirty;\n\t\tmark_inode_dirty_sync(inode);\n\t\tmutex_unlock(&ui->ui_mutex);\n\t\tif (release)\n\t\t\tubifs_release_budget(c, &req);\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t ubifs_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tint err = update_mctime(file_inode(iocb->ki_filp));\n\tif (err)\n\t\treturn err;\n\n\treturn generic_file_write_iter(iocb, from);\n}\n\nstatic bool ubifs_dirty_folio(struct address_space *mapping,\n\t\tstruct folio *folio)\n{\n\tbool ret;\n\tstruct ubifs_info *c = mapping->host->i_sb->s_fs_info;\n\n\tret = filemap_dirty_folio(mapping, folio);\n\t \n\tubifs_assert(c, ret == false);\n\treturn ret;\n}\n\nstatic bool ubifs_release_folio(struct folio *folio, gfp_t unused_gfp_flags)\n{\n\tstruct inode *inode = folio->mapping->host;\n\tstruct ubifs_info *c = inode->i_sb->s_fs_info;\n\n\tif (folio_test_writeback(folio))\n\t\treturn false;\n\n\t \n\tubifs_assert(c, folio_test_private(folio));\n\tif (folio_test_checked(folio))\n\t\trelease_new_page_budget(c);\n\telse\n\t\trelease_existing_page_budget(c);\n\n\tatomic_long_dec(&c->dirty_pg_cnt);\n\tfolio_detach_private(folio);\n\tfolio_clear_checked(folio);\n\treturn true;\n}\n\n \nstatic vm_fault_t ubifs_vm_page_mkwrite(struct vm_fault *vmf)\n{\n\tstruct page *page = vmf->page;\n\tstruct inode *inode = file_inode(vmf->vma->vm_file);\n\tstruct ubifs_info *c = inode->i_sb->s_fs_info;\n\tstruct timespec64 now = current_time(inode);\n\tstruct ubifs_budget_req req = { .new_page = 1 };\n\tint err, update_time;\n\n\tdbg_gen(\"ino %lu, pg %lu, i_size %lld\",\tinode->i_ino, page->index,\n\t\ti_size_read(inode));\n\tubifs_assert(c, !c->ro_media && !c->ro_mount);\n\n\tif (unlikely(c->ro_error))\n\t\treturn VM_FAULT_SIGBUS;  \n\n\t \n\tupdate_time = mctime_update_needed(inode, &now);\n\tif (update_time)\n\t\t \n\t\treq.dirtied_ino = 1;\n\n\terr = ubifs_budget_space(c, &req);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOSPC)\n\t\t\tubifs_warn(c, \"out of space for mmapped file (inode number %lu)\",\n\t\t\t\t   inode->i_ino);\n\t\treturn VM_FAULT_SIGBUS;\n\t}\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != inode->i_mapping ||\n\t\t     page_offset(page) > i_size_read(inode))) {\n\t\t \n\t\tgoto sigbus;\n\t}\n\n\tif (PagePrivate(page))\n\t\trelease_new_page_budget(c);\n\telse {\n\t\tif (!PageChecked(page))\n\t\t\tubifs_convert_page_budget(c);\n\t\tattach_page_private(page, (void *)1);\n\t\tatomic_long_inc(&c->dirty_pg_cnt);\n\t\t__set_page_dirty_nobuffers(page);\n\t}\n\n\tif (update_time) {\n\t\tint release;\n\t\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\n\t\tmutex_lock(&ui->ui_mutex);\n\t\tinode->i_mtime = inode_set_ctime_current(inode);\n\t\trelease = ui->dirty;\n\t\tmark_inode_dirty_sync(inode);\n\t\tmutex_unlock(&ui->ui_mutex);\n\t\tif (release)\n\t\t\tubifs_release_dirty_inode_budget(c, ui);\n\t}\n\n\twait_for_stable_page(page);\n\treturn VM_FAULT_LOCKED;\n\nsigbus:\n\tunlock_page(page);\n\tubifs_release_budget(c, &req);\n\treturn VM_FAULT_SIGBUS;\n}\n\nstatic const struct vm_operations_struct ubifs_file_vm_ops = {\n\t.fault        = filemap_fault,\n\t.map_pages = filemap_map_pages,\n\t.page_mkwrite = ubifs_vm_page_mkwrite,\n};\n\nstatic int ubifs_file_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tint err;\n\n\terr = generic_file_mmap(file, vma);\n\tif (err)\n\t\treturn err;\n\tvma->vm_ops = &ubifs_file_vm_ops;\n\n\tif (IS_ENABLED(CONFIG_UBIFS_ATIME_SUPPORT))\n\t\tfile_accessed(file);\n\n\treturn 0;\n}\n\nstatic const char *ubifs_get_link(struct dentry *dentry,\n\t\t\t\t\t    struct inode *inode,\n\t\t\t\t\t    struct delayed_call *done)\n{\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\n\tif (!IS_ENCRYPTED(inode))\n\t\treturn ui->data;\n\n\tif (!dentry)\n\t\treturn ERR_PTR(-ECHILD);\n\n\treturn fscrypt_get_symlink(inode, ui->data, ui->data_len, done);\n}\n\nstatic int ubifs_symlink_getattr(struct mnt_idmap *idmap,\n\t\t\t\t const struct path *path, struct kstat *stat,\n\t\t\t\t u32 request_mask, unsigned int query_flags)\n{\n\tubifs_getattr(idmap, path, stat, request_mask, query_flags);\n\n\tif (IS_ENCRYPTED(d_inode(path->dentry)))\n\t\treturn fscrypt_symlink_getattr(path, stat);\n\treturn 0;\n}\n\nconst struct address_space_operations ubifs_file_address_operations = {\n\t.read_folio     = ubifs_read_folio,\n\t.writepage      = ubifs_writepage,\n\t.write_begin    = ubifs_write_begin,\n\t.write_end      = ubifs_write_end,\n\t.invalidate_folio = ubifs_invalidate_folio,\n\t.dirty_folio\t= ubifs_dirty_folio,\n\t.migrate_folio\t= filemap_migrate_folio,\n\t.release_folio\t= ubifs_release_folio,\n};\n\nconst struct inode_operations ubifs_file_inode_operations = {\n\t.setattr     = ubifs_setattr,\n\t.getattr     = ubifs_getattr,\n\t.listxattr   = ubifs_listxattr,\n\t.update_time = ubifs_update_time,\n\t.fileattr_get = ubifs_fileattr_get,\n\t.fileattr_set = ubifs_fileattr_set,\n};\n\nconst struct inode_operations ubifs_symlink_inode_operations = {\n\t.get_link    = ubifs_get_link,\n\t.setattr     = ubifs_setattr,\n\t.getattr     = ubifs_symlink_getattr,\n\t.listxattr   = ubifs_listxattr,\n\t.update_time = ubifs_update_time,\n};\n\nconst struct file_operations ubifs_file_operations = {\n\t.llseek         = generic_file_llseek,\n\t.read_iter      = generic_file_read_iter,\n\t.write_iter     = ubifs_write_iter,\n\t.mmap           = ubifs_file_mmap,\n\t.fsync          = ubifs_fsync,\n\t.unlocked_ioctl = ubifs_ioctl,\n\t.splice_read\t= filemap_splice_read,\n\t.splice_write\t= iter_file_splice_write,\n\t.open\t\t= fscrypt_file_open,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl   = ubifs_compat_ioctl,\n#endif\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}