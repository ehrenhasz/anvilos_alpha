{
  "module_name": "budget.c",
  "hash_id": "a500611ffe3d8d484792312e5c5d3c3a8963cc93cdcbe512840cf740ada1e52f",
  "original_prompt": "Ingested from linux-6.6.14/fs/ubifs/budget.c",
  "human_readable_source": "\n \n\n \n\n#include \"ubifs.h\"\n#include <linux/writeback.h>\n#include <linux/math64.h>\n\n \n#define MAX_MKSPC_RETRIES 3\n\n \n#define NR_TO_WRITE 16\n\n \nstatic void shrink_liability(struct ubifs_info *c, int nr_to_write)\n{\n\tdown_read(&c->vfs_sb->s_umount);\n\twriteback_inodes_sb_nr(c->vfs_sb, nr_to_write, WB_REASON_FS_FREE_SPACE);\n\tup_read(&c->vfs_sb->s_umount);\n}\n\n \nstatic int run_gc(struct ubifs_info *c)\n{\n\tint lnum;\n\n\t \n\tdown_read(&c->commit_sem);\n\tlnum = ubifs_garbage_collect(c, 1);\n\tup_read(&c->commit_sem);\n\tif (lnum < 0)\n\t\treturn lnum;\n\n\t \n\tdbg_budg(\"GC freed LEB %d\", lnum);\n\treturn ubifs_return_leb(c, lnum);\n}\n\n \nstatic long long get_liability(struct ubifs_info *c)\n{\n\tlong long liab;\n\n\tspin_lock(&c->space_lock);\n\tliab = c->bi.idx_growth + c->bi.data_growth + c->bi.dd_growth;\n\tspin_unlock(&c->space_lock);\n\treturn liab;\n}\n\n \nstatic int make_free_space(struct ubifs_info *c)\n{\n\tint err, retries = 0;\n\tlong long liab1, liab2;\n\n\tdo {\n\t\tliab1 = get_liability(c);\n\t\t \n\t\tdbg_budg(\"liability %lld, run write-back\", liab1);\n\t\tshrink_liability(c, NR_TO_WRITE);\n\n\t\tliab2 = get_liability(c);\n\t\tif (liab2 < liab1)\n\t\t\treturn -EAGAIN;\n\n\t\tdbg_budg(\"new liability %lld (not shrunk)\", liab2);\n\n\t\t \n\t\tdbg_budg(\"Run GC\");\n\t\terr = run_gc(c);\n\t\tif (!err)\n\t\t\treturn -EAGAIN;\n\n\t\tif (err != -EAGAIN && err != -ENOSPC)\n\t\t\t \n\t\t\treturn err;\n\n\t\tdbg_budg(\"Run commit (retries %d)\", retries);\n\t\terr = ubifs_run_commit(c);\n\t\tif (err)\n\t\t\treturn err;\n\t} while (retries++ < MAX_MKSPC_RETRIES);\n\n\treturn -ENOSPC;\n}\n\n \nint ubifs_calc_min_idx_lebs(struct ubifs_info *c)\n{\n\tint idx_lebs;\n\tlong long idx_size;\n\n\tidx_size = c->bi.old_idx_sz + c->bi.idx_growth + c->bi.uncommitted_idx;\n\t \n\tidx_size += idx_size << 1;\n\t \n\tidx_lebs = div_u64(idx_size + c->idx_leb_size - 1, c->idx_leb_size);\n\t \n\tidx_lebs += 1;\n\tif (idx_lebs < MIN_INDEX_LEBS)\n\t\tidx_lebs = MIN_INDEX_LEBS;\n\treturn idx_lebs;\n}\n\n \nlong long ubifs_calc_available(const struct ubifs_info *c, int min_idx_lebs)\n{\n\tint subtract_lebs;\n\tlong long available;\n\n\tavailable = c->main_bytes - c->lst.total_used;\n\n\t \n\tsubtract_lebs = min_idx_lebs;\n\n\t \n\tsubtract_lebs += 1;\n\n\t \n\tsubtract_lebs += c->jhead_cnt;\n\n\t \n\tsubtract_lebs += 1;\n\n\tavailable -= (long long)subtract_lebs * c->leb_size;\n\n\t \n\tavailable -= c->lst.total_dead;\n\n\t \n\tavailable -= c->lst.total_dark;\n\n\t \n\tif (c->lst.idx_lebs > min_idx_lebs) {\n\t\tsubtract_lebs = c->lst.idx_lebs - min_idx_lebs;\n\t\tavailable -= subtract_lebs * c->dark_wm;\n\t}\n\n\t \n\treturn available > 0 ? available : 0;\n}\n\n \nstatic int can_use_rp(struct ubifs_info *c)\n{\n\tif (uid_eq(current_fsuid(), c->rp_uid) || capable(CAP_SYS_RESOURCE) ||\n\t    (!gid_eq(c->rp_gid, GLOBAL_ROOT_GID) && in_group_p(c->rp_gid)))\n\t\treturn 1;\n\treturn 0;\n}\n\n \nstatic int do_budget_space(struct ubifs_info *c)\n{\n\tlong long outstanding, available;\n\tint lebs, rsvd_idx_lebs, min_idx_lebs;\n\n\t \n\tmin_idx_lebs = ubifs_calc_min_idx_lebs(c);\n\n\t \n\tif (min_idx_lebs > c->lst.idx_lebs)\n\t\trsvd_idx_lebs = min_idx_lebs - c->lst.idx_lebs;\n\telse\n\t\trsvd_idx_lebs = 0;\n\n\t \n\tlebs = c->lst.empty_lebs + c->freeable_cnt + c->idx_gc_cnt -\n\t       c->lst.taken_empty_lebs;\n\tif (unlikely(rsvd_idx_lebs > lebs)) {\n\t\tdbg_budg(\"out of indexing space: min_idx_lebs %d (old %d), rsvd_idx_lebs %d\",\n\t\t\t min_idx_lebs, c->bi.min_idx_lebs, rsvd_idx_lebs);\n\t\treturn -ENOSPC;\n\t}\n\n\tavailable = ubifs_calc_available(c, min_idx_lebs);\n\toutstanding = c->bi.data_growth + c->bi.dd_growth;\n\n\tif (unlikely(available < outstanding)) {\n\t\tdbg_budg(\"out of data space: available %lld, outstanding %lld\",\n\t\t\t available, outstanding);\n\t\treturn -ENOSPC;\n\t}\n\n\tif (available - outstanding <= c->rp_size && !can_use_rp(c))\n\t\treturn -ENOSPC;\n\n\tc->bi.min_idx_lebs = min_idx_lebs;\n\treturn 0;\n}\n\n \nstatic int calc_idx_growth(const struct ubifs_info *c,\n\t\t\t   const struct ubifs_budget_req *req)\n{\n\tint znodes;\n\n\tznodes = req->new_ino + (req->new_page << UBIFS_BLOCKS_PER_PAGE_SHIFT) +\n\t\t req->new_dent;\n\treturn znodes * c->max_idx_node_sz;\n}\n\n \nstatic int calc_data_growth(const struct ubifs_info *c,\n\t\t\t    const struct ubifs_budget_req *req)\n{\n\tint data_growth;\n\n\tdata_growth = req->new_ino  ? c->bi.inode_budget : 0;\n\tif (req->new_page)\n\t\tdata_growth += c->bi.page_budget;\n\tif (req->new_dent)\n\t\tdata_growth += c->bi.dent_budget;\n\tdata_growth += req->new_ino_d;\n\treturn data_growth;\n}\n\n \nstatic int calc_dd_growth(const struct ubifs_info *c,\n\t\t\t  const struct ubifs_budget_req *req)\n{\n\tint dd_growth;\n\n\tdd_growth = req->dirtied_page ? c->bi.page_budget : 0;\n\n\tif (req->dirtied_ino)\n\t\tdd_growth += c->bi.inode_budget * req->dirtied_ino;\n\tif (req->mod_dent)\n\t\tdd_growth += c->bi.dent_budget;\n\tdd_growth += req->dirtied_ino_d;\n\treturn dd_growth;\n}\n\n \nint ubifs_budget_space(struct ubifs_info *c, struct ubifs_budget_req *req)\n{\n\tint err, idx_growth, data_growth, dd_growth, retried = 0;\n\n\tubifs_assert(c, req->new_page <= 1);\n\tubifs_assert(c, req->dirtied_page <= 1);\n\tubifs_assert(c, req->new_dent <= 1);\n\tubifs_assert(c, req->mod_dent <= 1);\n\tubifs_assert(c, req->new_ino <= 1);\n\tubifs_assert(c, req->new_ino_d <= UBIFS_MAX_INO_DATA);\n\tubifs_assert(c, req->dirtied_ino <= 4);\n\tubifs_assert(c, req->dirtied_ino_d <= UBIFS_MAX_INO_DATA * 4);\n\tubifs_assert(c, !(req->new_ino_d & 7));\n\tubifs_assert(c, !(req->dirtied_ino_d & 7));\n\n\tdata_growth = calc_data_growth(c, req);\n\tdd_growth = calc_dd_growth(c, req);\n\tif (!data_growth && !dd_growth)\n\t\treturn 0;\n\tidx_growth = calc_idx_growth(c, req);\n\nagain:\n\tspin_lock(&c->space_lock);\n\tubifs_assert(c, c->bi.idx_growth >= 0);\n\tubifs_assert(c, c->bi.data_growth >= 0);\n\tubifs_assert(c, c->bi.dd_growth >= 0);\n\n\tif (unlikely(c->bi.nospace) && (c->bi.nospace_rp || !can_use_rp(c))) {\n\t\tdbg_budg(\"no space\");\n\t\tspin_unlock(&c->space_lock);\n\t\treturn -ENOSPC;\n\t}\n\n\tc->bi.idx_growth += idx_growth;\n\tc->bi.data_growth += data_growth;\n\tc->bi.dd_growth += dd_growth;\n\n\terr = do_budget_space(c);\n\tif (likely(!err)) {\n\t\treq->idx_growth = idx_growth;\n\t\treq->data_growth = data_growth;\n\t\treq->dd_growth = dd_growth;\n\t\tspin_unlock(&c->space_lock);\n\t\treturn 0;\n\t}\n\n\t \n\tc->bi.idx_growth -= idx_growth;\n\tc->bi.data_growth -= data_growth;\n\tc->bi.dd_growth -= dd_growth;\n\tspin_unlock(&c->space_lock);\n\n\tif (req->fast) {\n\t\tdbg_budg(\"no space for fast budgeting\");\n\t\treturn err;\n\t}\n\n\terr = make_free_space(c);\n\tcond_resched();\n\tif (err == -EAGAIN) {\n\t\tdbg_budg(\"try again\");\n\t\tgoto again;\n\t} else if (err == -ENOSPC) {\n\t\tif (!retried) {\n\t\t\tretried = 1;\n\t\t\tdbg_budg(\"-ENOSPC, but anyway try once again\");\n\t\t\tgoto again;\n\t\t}\n\t\tdbg_budg(\"FS is full, -ENOSPC\");\n\t\tc->bi.nospace = 1;\n\t\tif (can_use_rp(c) || c->rp_size == 0)\n\t\t\tc->bi.nospace_rp = 1;\n\t\tsmp_wmb();\n\t} else\n\t\tubifs_err(c, \"cannot budget space, error %d\", err);\n\treturn err;\n}\n\n \nvoid ubifs_release_budget(struct ubifs_info *c, struct ubifs_budget_req *req)\n{\n\tubifs_assert(c, req->new_page <= 1);\n\tubifs_assert(c, req->dirtied_page <= 1);\n\tubifs_assert(c, req->new_dent <= 1);\n\tubifs_assert(c, req->mod_dent <= 1);\n\tubifs_assert(c, req->new_ino <= 1);\n\tubifs_assert(c, req->new_ino_d <= UBIFS_MAX_INO_DATA);\n\tubifs_assert(c, req->dirtied_ino <= 4);\n\tubifs_assert(c, req->dirtied_ino_d <= UBIFS_MAX_INO_DATA * 4);\n\tubifs_assert(c, !(req->new_ino_d & 7));\n\tubifs_assert(c, !(req->dirtied_ino_d & 7));\n\tif (!req->recalculate) {\n\t\tubifs_assert(c, req->idx_growth >= 0);\n\t\tubifs_assert(c, req->data_growth >= 0);\n\t\tubifs_assert(c, req->dd_growth >= 0);\n\t}\n\n\tif (req->recalculate) {\n\t\treq->data_growth = calc_data_growth(c, req);\n\t\treq->dd_growth = calc_dd_growth(c, req);\n\t\treq->idx_growth = calc_idx_growth(c, req);\n\t}\n\n\tif (!req->data_growth && !req->dd_growth)\n\t\treturn;\n\n\tc->bi.nospace = c->bi.nospace_rp = 0;\n\tsmp_wmb();\n\n\tspin_lock(&c->space_lock);\n\tc->bi.idx_growth -= req->idx_growth;\n\tc->bi.uncommitted_idx += req->idx_growth;\n\tc->bi.data_growth -= req->data_growth;\n\tc->bi.dd_growth -= req->dd_growth;\n\tc->bi.min_idx_lebs = ubifs_calc_min_idx_lebs(c);\n\n\tubifs_assert(c, c->bi.idx_growth >= 0);\n\tubifs_assert(c, c->bi.data_growth >= 0);\n\tubifs_assert(c, c->bi.dd_growth >= 0);\n\tubifs_assert(c, c->bi.min_idx_lebs < c->main_lebs);\n\tubifs_assert(c, !(c->bi.idx_growth & 7));\n\tubifs_assert(c, !(c->bi.data_growth & 7));\n\tubifs_assert(c, !(c->bi.dd_growth & 7));\n\tspin_unlock(&c->space_lock);\n}\n\n \nvoid ubifs_convert_page_budget(struct ubifs_info *c)\n{\n\tspin_lock(&c->space_lock);\n\t \n\tc->bi.idx_growth -= c->max_idx_node_sz << UBIFS_BLOCKS_PER_PAGE_SHIFT;\n\t \n\tc->bi.data_growth -= c->bi.page_budget;\n\t \n\tc->bi.dd_growth += c->bi.page_budget;\n\t \n\tc->bi.min_idx_lebs = ubifs_calc_min_idx_lebs(c);\n\tspin_unlock(&c->space_lock);\n}\n\n \nvoid ubifs_release_dirty_inode_budget(struct ubifs_info *c,\n\t\t\t\t      struct ubifs_inode *ui)\n{\n\tstruct ubifs_budget_req req;\n\n\tmemset(&req, 0, sizeof(struct ubifs_budget_req));\n\t \n\treq.dd_growth = c->bi.inode_budget + ALIGN(ui->data_len, 8);\n\tubifs_release_budget(c, &req);\n}\n\n \nlong long ubifs_reported_space(const struct ubifs_info *c, long long free)\n{\n\tint divisor, factor, f;\n\n\t \n\tf = c->fanout > 3 ? c->fanout >> 1 : 2;\n\tfactor = UBIFS_BLOCK_SIZE;\n\tdivisor = UBIFS_MAX_DATA_NODE_SZ;\n\tdivisor += (c->max_idx_node_sz * 3) / (f - 1);\n\tfree *= factor;\n\treturn div_u64(free, divisor);\n}\n\n \nlong long ubifs_get_free_space_nolock(struct ubifs_info *c)\n{\n\tint rsvd_idx_lebs, lebs;\n\tlong long available, outstanding, free;\n\n\tubifs_assert(c, c->bi.min_idx_lebs == ubifs_calc_min_idx_lebs(c));\n\toutstanding = c->bi.data_growth + c->bi.dd_growth;\n\tavailable = ubifs_calc_available(c, c->bi.min_idx_lebs);\n\n\t \n\tif (c->bi.min_idx_lebs > c->lst.idx_lebs)\n\t\trsvd_idx_lebs = c->bi.min_idx_lebs - c->lst.idx_lebs;\n\telse\n\t\trsvd_idx_lebs = 0;\n\tlebs = c->lst.empty_lebs + c->freeable_cnt + c->idx_gc_cnt -\n\t       c->lst.taken_empty_lebs;\n\tlebs -= rsvd_idx_lebs;\n\tavailable += lebs * (c->dark_wm - c->leb_overhead);\n\n\tif (available > outstanding)\n\t\tfree = ubifs_reported_space(c, available - outstanding);\n\telse\n\t\tfree = 0;\n\treturn free;\n}\n\n \nlong long ubifs_get_free_space(struct ubifs_info *c)\n{\n\tlong long free;\n\n\tspin_lock(&c->space_lock);\n\tfree = ubifs_get_free_space_nolock(c);\n\tspin_unlock(&c->space_lock);\n\n\treturn free;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}