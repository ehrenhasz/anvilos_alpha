{
  "module_name": "recovery.c",
  "hash_id": "43af17500081910eb132bcd8f88e8c56c32549e97d6fb8c3674d2a69f3047044",
  "original_prompt": "Ingested from linux-6.6.14/fs/ubifs/recovery.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include \"ubifs.h\"\n\n \nstatic int is_empty(void *buf, int len)\n{\n\tuint8_t *p = buf;\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\tif (*p++ != 0xff)\n\t\t\treturn 0;\n\treturn 1;\n}\n\n \nstatic int first_non_ff(void *buf, int len)\n{\n\tuint8_t *p = buf;\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\tif (*p++ != 0xff)\n\t\t\treturn i;\n\treturn -1;\n}\n\n \nstatic int get_master_node(const struct ubifs_info *c, int lnum, void **pbuf,\n\t\t\t   struct ubifs_mst_node **mst, void **cor)\n{\n\tconst int sz = c->mst_node_alsz;\n\tint err, offs, len;\n\tvoid *sbuf, *buf;\n\n\tsbuf = vmalloc(c->leb_size);\n\tif (!sbuf)\n\t\treturn -ENOMEM;\n\n\terr = ubifs_leb_read(c, lnum, sbuf, 0, c->leb_size, 0);\n\tif (err && err != -EBADMSG)\n\t\tgoto out_free;\n\n\t \n\toffs = 0;\n\tbuf = sbuf;\n\tlen = c->leb_size;\n\twhile (offs + UBIFS_MST_NODE_SZ <= c->leb_size) {\n\t\tstruct ubifs_ch *ch = buf;\n\n\t\tif (le32_to_cpu(ch->magic) != UBIFS_NODE_MAGIC)\n\t\t\tbreak;\n\t\toffs += sz;\n\t\tbuf  += sz;\n\t\tlen  -= sz;\n\t}\n\t \n\tif (offs) {\n\t\tint ret;\n\n\t\toffs -= sz;\n\t\tbuf  -= sz;\n\t\tlen  += sz;\n\t\tret = ubifs_scan_a_node(c, buf, len, lnum, offs, 1);\n\t\tif (ret != SCANNED_A_NODE && offs) {\n\t\t\t \n\t\t\toffs -= sz;\n\t\t\tbuf  -= sz;\n\t\t\tlen  += sz;\n\t\t\tret = ubifs_scan_a_node(c, buf, len, lnum, offs, 1);\n\t\t\tif (ret != SCANNED_A_NODE)\n\t\t\t\t \n\t\t\t\tgoto out_err;\n\t\t}\n\t\tif (ret == SCANNED_A_NODE) {\n\t\t\tstruct ubifs_ch *ch = buf;\n\n\t\t\tif (ch->node_type != UBIFS_MST_NODE)\n\t\t\t\tgoto out_err;\n\t\t\tdbg_rcvry(\"found a master node at %d:%d\", lnum, offs);\n\t\t\t*mst = buf;\n\t\t\toffs += sz;\n\t\t\tbuf  += sz;\n\t\t\tlen  -= sz;\n\t\t}\n\t}\n\t \n\tif (offs < c->leb_size) {\n\t\tif (!is_empty(buf, min_t(int, len, sz))) {\n\t\t\t*cor = buf;\n\t\t\tdbg_rcvry(\"found corruption at %d:%d\", lnum, offs);\n\t\t}\n\t\toffs += sz;\n\t\tbuf  += sz;\n\t\tlen  -= sz;\n\t}\n\t \n\tif (offs < c->leb_size)\n\t\tif (!is_empty(buf, len))\n\t\t\tgoto out_err;\n\t*pbuf = sbuf;\n\treturn 0;\n\nout_err:\n\terr = -EINVAL;\nout_free:\n\tvfree(sbuf);\n\t*mst = NULL;\n\t*cor = NULL;\n\treturn err;\n}\n\n \nstatic int write_rcvrd_mst_node(struct ubifs_info *c,\n\t\t\t\tstruct ubifs_mst_node *mst)\n{\n\tint err = 0, lnum = UBIFS_MST_LNUM, sz = c->mst_node_alsz;\n\t__le32 save_flags;\n\n\tdbg_rcvry(\"recovery\");\n\n\tsave_flags = mst->flags;\n\tmst->flags |= cpu_to_le32(UBIFS_MST_RCVRY);\n\n\terr = ubifs_prepare_node_hmac(c, mst, UBIFS_MST_NODE_SZ,\n\t\t\t\t      offsetof(struct ubifs_mst_node, hmac), 1);\n\tif (err)\n\t\tgoto out;\n\terr = ubifs_leb_change(c, lnum, mst, sz);\n\tif (err)\n\t\tgoto out;\n\terr = ubifs_leb_change(c, lnum + 1, mst, sz);\n\tif (err)\n\t\tgoto out;\nout:\n\tmst->flags = save_flags;\n\treturn err;\n}\n\n \nint ubifs_recover_master_node(struct ubifs_info *c)\n{\n\tvoid *buf1 = NULL, *buf2 = NULL, *cor1 = NULL, *cor2 = NULL;\n\tstruct ubifs_mst_node *mst1 = NULL, *mst2 = NULL, *mst;\n\tconst int sz = c->mst_node_alsz;\n\tint err, offs1, offs2;\n\n\tdbg_rcvry(\"recovery\");\n\n\terr = get_master_node(c, UBIFS_MST_LNUM, &buf1, &mst1, &cor1);\n\tif (err)\n\t\tgoto out_free;\n\n\terr = get_master_node(c, UBIFS_MST_LNUM + 1, &buf2, &mst2, &cor2);\n\tif (err)\n\t\tgoto out_free;\n\n\tif (mst1) {\n\t\toffs1 = (void *)mst1 - buf1;\n\t\tif ((le32_to_cpu(mst1->flags) & UBIFS_MST_RCVRY) &&\n\t\t    (offs1 == 0 && !cor1)) {\n\t\t\t \n\t\t\tdbg_rcvry(\"recovery recovery\");\n\t\t\tmst = mst1;\n\t\t} else if (mst2) {\n\t\t\toffs2 = (void *)mst2 - buf2;\n\t\t\tif (offs1 == offs2) {\n\t\t\t\t \n\t\t\t\tif (ubifs_compare_master_node(c, mst1, mst2))\n\t\t\t\t\tgoto out_err;\n\t\t\t\tmst = mst1;\n\t\t\t} else if (offs2 + sz == offs1) {\n\t\t\t\t \n\t\t\t\tif (cor1)\n\t\t\t\t\tgoto out_err;\n\t\t\t\tmst = mst1;\n\t\t\t} else if (offs1 == 0 &&\n\t\t\t\t   c->leb_size - offs2 - sz < sz) {\n\t\t\t\t \n\t\t\t\tif (cor1)\n\t\t\t\t\tgoto out_err;\n\t\t\t\tmst = mst1;\n\t\t\t} else\n\t\t\t\tgoto out_err;\n\t\t} else {\n\t\t\t \n\t\t\tif (offs1 != 0 || cor1)\n\t\t\t\tgoto out_err;\n\t\t\tmst = mst1;\n\t\t}\n\t} else {\n\t\tif (!mst2)\n\t\t\tgoto out_err;\n\t\t \n\t\toffs2 = (void *)mst2 - buf2;\n\t\tif (offs2 + sz + sz <= c->leb_size)\n\t\t\tgoto out_err;\n\t\tmst = mst2;\n\t}\n\n\tubifs_msg(c, \"recovered master node from LEB %d\",\n\t\t  (mst == mst1 ? UBIFS_MST_LNUM : UBIFS_MST_LNUM + 1));\n\n\tmemcpy(c->mst_node, mst, UBIFS_MST_NODE_SZ);\n\n\tif (c->ro_mount) {\n\t\t \n\t\tc->rcvrd_mst_node = kmalloc(sz, GFP_KERNEL);\n\t\tif (!c->rcvrd_mst_node) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_free;\n\t\t}\n\t\tmemcpy(c->rcvrd_mst_node, c->mst_node, UBIFS_MST_NODE_SZ);\n\n\t\t \n\t\tc->mst_node->flags |= cpu_to_le32(UBIFS_MST_DIRTY);\n\t} else {\n\t\t \n\t\tc->max_sqnum = le64_to_cpu(mst->ch.sqnum) - 1;\n\t\terr = write_rcvrd_mst_node(c, c->mst_node);\n\t\tif (err)\n\t\t\tgoto out_free;\n\t}\n\n\tvfree(buf2);\n\tvfree(buf1);\n\n\treturn 0;\n\nout_err:\n\terr = -EINVAL;\nout_free:\n\tubifs_err(c, \"failed to recover master node\");\n\tif (mst1) {\n\t\tubifs_err(c, \"dumping first master node\");\n\t\tubifs_dump_node(c, mst1, c->leb_size - ((void *)mst1 - buf1));\n\t}\n\tif (mst2) {\n\t\tubifs_err(c, \"dumping second master node\");\n\t\tubifs_dump_node(c, mst2, c->leb_size - ((void *)mst2 - buf2));\n\t}\n\tvfree(buf2);\n\tvfree(buf1);\n\treturn err;\n}\n\n \nint ubifs_write_rcvrd_mst_node(struct ubifs_info *c)\n{\n\tint err;\n\n\tif (!c->rcvrd_mst_node)\n\t\treturn 0;\n\tc->rcvrd_mst_node->flags |= cpu_to_le32(UBIFS_MST_DIRTY);\n\tc->mst_node->flags |= cpu_to_le32(UBIFS_MST_DIRTY);\n\terr = write_rcvrd_mst_node(c, c->rcvrd_mst_node);\n\tif (err)\n\t\treturn err;\n\tkfree(c->rcvrd_mst_node);\n\tc->rcvrd_mst_node = NULL;\n\treturn 0;\n}\n\n \nstatic int is_last_write(const struct ubifs_info *c, void *buf, int offs)\n{\n\tint empty_offs, check_len;\n\tuint8_t *p;\n\n\t \n\tempty_offs = ALIGN(offs + 1, c->max_write_size);\n\tcheck_len = c->leb_size - empty_offs;\n\tp = buf + empty_offs - offs;\n\treturn is_empty(p, check_len);\n}\n\n \nstatic void clean_buf(const struct ubifs_info *c, void **buf, int lnum,\n\t\t      int *offs, int *len)\n{\n\tint empty_offs, pad_len;\n\n\tdbg_rcvry(\"cleaning corruption at %d:%d\", lnum, *offs);\n\n\tubifs_assert(c, !(*offs & 7));\n\tempty_offs = ALIGN(*offs, c->min_io_size);\n\tpad_len = empty_offs - *offs;\n\tubifs_pad(c, *buf, pad_len);\n\t*offs += pad_len;\n\t*buf += pad_len;\n\t*len -= pad_len;\n\tmemset(*buf, 0xff, c->leb_size - empty_offs);\n}\n\n \nstatic int no_more_nodes(const struct ubifs_info *c, void *buf, int len,\n\t\t\tint lnum, int offs)\n{\n\tstruct ubifs_ch *ch = buf;\n\tint skip, dlen = le32_to_cpu(ch->len);\n\n\t \n\tskip = ALIGN(offs + UBIFS_CH_SZ, c->max_write_size) - offs;\n\tif (is_empty(buf + skip, len - skip))\n\t\treturn 1;\n\t \n\tif (ubifs_check_node(c, buf, len, lnum, offs, 1, 0) != -EUCLEAN) {\n\t\tdbg_rcvry(\"unexpected bad common header at %d:%d\", lnum, offs);\n\t\treturn 0;\n\t}\n\t \n\tskip = ALIGN(offs + dlen, c->max_write_size) - offs;\n\t \n\tif (is_empty(buf + skip, len - skip))\n\t\treturn 1;\n\tdbg_rcvry(\"unexpected data at %d:%d\", lnum, offs + skip);\n\treturn 0;\n}\n\n \nstatic int fix_unclean_leb(struct ubifs_info *c, struct ubifs_scan_leb *sleb,\n\t\t\t   int start)\n{\n\tint lnum = sleb->lnum, endpt = start;\n\n\t \n\tif (!list_empty(&sleb->nodes)) {\n\t\tstruct ubifs_scan_node *snod;\n\n\t\tsnod = list_entry(sleb->nodes.prev,\n\t\t\t\t  struct ubifs_scan_node, list);\n\t\tendpt = snod->offs + snod->len;\n\t}\n\n\tif (c->ro_mount && !c->remounting_rw) {\n\t\t \n\t\tstruct ubifs_unclean_leb *ucleb;\n\n\t\tdbg_rcvry(\"need to fix LEB %d start %d endpt %d\",\n\t\t\t  lnum, start, sleb->endpt);\n\t\tucleb = kzalloc(sizeof(struct ubifs_unclean_leb), GFP_NOFS);\n\t\tif (!ucleb)\n\t\t\treturn -ENOMEM;\n\t\tucleb->lnum = lnum;\n\t\tucleb->endpt = endpt;\n\t\tlist_add_tail(&ucleb->list, &c->unclean_leb_list);\n\t} else {\n\t\t \n\t\tint err;\n\n\t\tdbg_rcvry(\"fixing LEB %d start %d endpt %d\",\n\t\t\t  lnum, start, sleb->endpt);\n\t\tif (endpt == 0) {\n\t\t\terr = ubifs_leb_unmap(c, lnum);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\tint len = ALIGN(endpt, c->min_io_size);\n\n\t\t\tif (start) {\n\t\t\t\terr = ubifs_leb_read(c, lnum, sleb->buf, 0,\n\t\t\t\t\t\t     start, 1);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t\t \n\t\t\tif (len > endpt) {\n\t\t\t\tint pad_len = len - ALIGN(endpt, 8);\n\n\t\t\t\tif (pad_len > 0) {\n\t\t\t\t\tvoid *buf = sleb->buf + len - pad_len;\n\n\t\t\t\t\tubifs_pad(c, buf, pad_len);\n\t\t\t\t}\n\t\t\t}\n\t\t\terr = ubifs_leb_change(c, lnum, sleb->buf, len);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic void drop_last_group(struct ubifs_scan_leb *sleb, int *offs)\n{\n\twhile (!list_empty(&sleb->nodes)) {\n\t\tstruct ubifs_scan_node *snod;\n\t\tstruct ubifs_ch *ch;\n\n\t\tsnod = list_entry(sleb->nodes.prev, struct ubifs_scan_node,\n\t\t\t\t  list);\n\t\tch = snod->node;\n\t\tif (ch->group_type != UBIFS_IN_NODE_GROUP)\n\t\t\tbreak;\n\n\t\tdbg_rcvry(\"dropping grouped node at %d:%d\",\n\t\t\t  sleb->lnum, snod->offs);\n\t\t*offs = snod->offs;\n\t\tlist_del(&snod->list);\n\t\tkfree(snod);\n\t\tsleb->nodes_cnt -= 1;\n\t}\n}\n\n \nstatic void drop_last_node(struct ubifs_scan_leb *sleb, int *offs)\n{\n\tstruct ubifs_scan_node *snod;\n\n\tif (!list_empty(&sleb->nodes)) {\n\t\tsnod = list_entry(sleb->nodes.prev, struct ubifs_scan_node,\n\t\t\t\t  list);\n\n\t\tdbg_rcvry(\"dropping last node at %d:%d\",\n\t\t\t  sleb->lnum, snod->offs);\n\t\t*offs = snod->offs;\n\t\tlist_del(&snod->list);\n\t\tkfree(snod);\n\t\tsleb->nodes_cnt -= 1;\n\t}\n}\n\n \nstruct ubifs_scan_leb *ubifs_recover_leb(struct ubifs_info *c, int lnum,\n\t\t\t\t\t int offs, void *sbuf, int jhead)\n{\n\tint ret = 0, err, len = c->leb_size - offs, start = offs, min_io_unit;\n\tint grouped = jhead == -1 ? 0 : c->jheads[jhead].grouped;\n\tstruct ubifs_scan_leb *sleb;\n\tvoid *buf = sbuf + offs;\n\n\tdbg_rcvry(\"%d:%d, jhead %d, grouped %d\", lnum, offs, jhead, grouped);\n\n\tsleb = ubifs_start_scan(c, lnum, offs, sbuf);\n\tif (IS_ERR(sleb))\n\t\treturn sleb;\n\n\tubifs_assert(c, len >= 8);\n\twhile (len >= 8) {\n\t\tdbg_scan(\"look at LEB %d:%d (%d bytes left)\",\n\t\t\t lnum, offs, len);\n\n\t\tcond_resched();\n\n\t\t \n\t\tret = ubifs_scan_a_node(c, buf, len, lnum, offs, 1);\n\t\tif (ret == SCANNED_A_NODE) {\n\t\t\t \n\t\t\tstruct ubifs_ch *ch = buf;\n\t\t\tint node_len;\n\n\t\t\terr = ubifs_add_snod(c, sleb, buf, offs);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\t\t\tnode_len = ALIGN(le32_to_cpu(ch->len), 8);\n\t\t\toffs += node_len;\n\t\t\tbuf += node_len;\n\t\t\tlen -= node_len;\n\t\t} else if (ret > 0) {\n\t\t\t \n\t\t\toffs += ret;\n\t\t\tbuf += ret;\n\t\t\tlen -= ret;\n\t\t} else if (ret == SCANNED_EMPTY_SPACE ||\n\t\t\t   ret == SCANNED_GARBAGE     ||\n\t\t\t   ret == SCANNED_A_BAD_PAD_NODE ||\n\t\t\t   ret == SCANNED_A_CORRUPT_NODE) {\n\t\t\tdbg_rcvry(\"found corruption (%d) at %d:%d\",\n\t\t\t\t  ret, lnum, offs);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tubifs_err(c, \"unexpected return value %d\", ret);\n\t\t\terr = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (ret == SCANNED_GARBAGE || ret == SCANNED_A_BAD_PAD_NODE) {\n\t\tif (!is_last_write(c, buf, offs))\n\t\t\tgoto corrupted_rescan;\n\t} else if (ret == SCANNED_A_CORRUPT_NODE) {\n\t\tif (!no_more_nodes(c, buf, len, lnum, offs))\n\t\t\tgoto corrupted_rescan;\n\t} else if (!is_empty(buf, len)) {\n\t\tif (!is_last_write(c, buf, offs)) {\n\t\t\tint corruption = first_non_ff(buf, len);\n\n\t\t\t \n\t\t\tubifs_err(c, \"corrupt empty space LEB %d:%d, corruption starts at %d\",\n\t\t\t\t  lnum, offs, corruption);\n\t\t\t \n\t\t\toffs += corruption;\n\t\t\tbuf += corruption;\n\t\t\tgoto corrupted;\n\t\t}\n\t}\n\n\tmin_io_unit = round_down(offs, c->min_io_size);\n\tif (grouped)\n\t\t \n\t\tdrop_last_group(sleb, &offs);\n\n\tif (jhead == GCHD) {\n\t\t \n\t\twhile (offs > min_io_unit)\n\t\t\tdrop_last_node(sleb, &offs);\n\t}\n\n\tbuf = sbuf + offs;\n\tlen = c->leb_size - offs;\n\n\tclean_buf(c, &buf, lnum, &offs, &len);\n\tubifs_end_scan(c, sleb, lnum, offs);\n\n\terr = fix_unclean_leb(c, sleb, start);\n\tif (err)\n\t\tgoto error;\n\n\treturn sleb;\n\ncorrupted_rescan:\n\t \n\tubifs_err(c, \"corruption %d\", ret);\n\tubifs_scan_a_node(c, buf, len, lnum, offs, 0);\ncorrupted:\n\tubifs_scanned_corruption(c, lnum, offs, buf);\n\terr = -EUCLEAN;\nerror:\n\tubifs_err(c, \"LEB %d scanning failed\", lnum);\n\tubifs_scan_destroy(sleb);\n\treturn ERR_PTR(err);\n}\n\n \nstatic int get_cs_sqnum(struct ubifs_info *c, int lnum, int offs,\n\t\t\tunsigned long long *cs_sqnum)\n{\n\tstruct ubifs_cs_node *cs_node = NULL;\n\tint err, ret;\n\n\tdbg_rcvry(\"at %d:%d\", lnum, offs);\n\tcs_node = kmalloc(UBIFS_CS_NODE_SZ, GFP_KERNEL);\n\tif (!cs_node)\n\t\treturn -ENOMEM;\n\tif (c->leb_size - offs < UBIFS_CS_NODE_SZ)\n\t\tgoto out_err;\n\terr = ubifs_leb_read(c, lnum, (void *)cs_node, offs,\n\t\t\t     UBIFS_CS_NODE_SZ, 0);\n\tif (err && err != -EBADMSG)\n\t\tgoto out_free;\n\tret = ubifs_scan_a_node(c, cs_node, UBIFS_CS_NODE_SZ, lnum, offs, 0);\n\tif (ret != SCANNED_A_NODE) {\n\t\tubifs_err(c, \"Not a valid node\");\n\t\tgoto out_err;\n\t}\n\tif (cs_node->ch.node_type != UBIFS_CS_NODE) {\n\t\tubifs_err(c, \"Not a CS node, type is %d\", cs_node->ch.node_type);\n\t\tgoto out_err;\n\t}\n\tif (le64_to_cpu(cs_node->cmt_no) != c->cmt_no) {\n\t\tubifs_err(c, \"CS node cmt_no %llu != current cmt_no %llu\",\n\t\t\t  (unsigned long long)le64_to_cpu(cs_node->cmt_no),\n\t\t\t  c->cmt_no);\n\t\tgoto out_err;\n\t}\n\t*cs_sqnum = le64_to_cpu(cs_node->ch.sqnum);\n\tdbg_rcvry(\"commit start sqnum %llu\", *cs_sqnum);\n\tkfree(cs_node);\n\treturn 0;\n\nout_err:\n\terr = -EINVAL;\nout_free:\n\tubifs_err(c, \"failed to get CS sqnum\");\n\tkfree(cs_node);\n\treturn err;\n}\n\n \nstruct ubifs_scan_leb *ubifs_recover_log_leb(struct ubifs_info *c, int lnum,\n\t\t\t\t\t     int offs, void *sbuf)\n{\n\tstruct ubifs_scan_leb *sleb;\n\tint next_lnum;\n\n\tdbg_rcvry(\"LEB %d\", lnum);\n\tnext_lnum = lnum + 1;\n\tif (next_lnum >= UBIFS_LOG_LNUM + c->log_lebs)\n\t\tnext_lnum = UBIFS_LOG_LNUM;\n\tif (next_lnum != c->ltail_lnum) {\n\t\t \n\t\tsleb = ubifs_scan(c, next_lnum, 0, sbuf, 0);\n\t\tif (IS_ERR(sleb))\n\t\t\treturn sleb;\n\t\tif (sleb->nodes_cnt) {\n\t\t\tstruct ubifs_scan_node *snod;\n\t\t\tunsigned long long cs_sqnum = c->cs_sqnum;\n\n\t\t\tsnod = list_entry(sleb->nodes.next,\n\t\t\t\t\t  struct ubifs_scan_node, list);\n\t\t\tif (cs_sqnum == 0) {\n\t\t\t\tint err;\n\n\t\t\t\terr = get_cs_sqnum(c, lnum, offs, &cs_sqnum);\n\t\t\t\tif (err) {\n\t\t\t\t\tubifs_scan_destroy(sleb);\n\t\t\t\t\treturn ERR_PTR(err);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (snod->sqnum > cs_sqnum) {\n\t\t\t\tubifs_err(c, \"unrecoverable log corruption in LEB %d\",\n\t\t\t\t\t  lnum);\n\t\t\t\tubifs_scan_destroy(sleb);\n\t\t\t\treturn ERR_PTR(-EUCLEAN);\n\t\t\t}\n\t\t}\n\t\tubifs_scan_destroy(sleb);\n\t}\n\treturn ubifs_recover_leb(c, lnum, offs, sbuf, -1);\n}\n\n \nstatic int recover_head(struct ubifs_info *c, int lnum, int offs, void *sbuf)\n{\n\tint len = c->max_write_size, err;\n\n\tif (offs + len > c->leb_size)\n\t\tlen = c->leb_size - offs;\n\n\tif (!len)\n\t\treturn 0;\n\n\t \n\terr = ubifs_leb_read(c, lnum, sbuf, offs, len, 1);\n\tif (err || !is_empty(sbuf, len)) {\n\t\tdbg_rcvry(\"cleaning head at %d:%d\", lnum, offs);\n\t\tif (offs == 0)\n\t\t\treturn ubifs_leb_unmap(c, lnum);\n\t\terr = ubifs_leb_read(c, lnum, sbuf, 0, offs, 1);\n\t\tif (err)\n\t\t\treturn err;\n\t\treturn ubifs_leb_change(c, lnum, sbuf, offs);\n\t}\n\n\treturn 0;\n}\n\n \nint ubifs_recover_inl_heads(struct ubifs_info *c, void *sbuf)\n{\n\tint err;\n\n\tubifs_assert(c, !c->ro_mount || c->remounting_rw);\n\n\tdbg_rcvry(\"checking index head at %d:%d\", c->ihead_lnum, c->ihead_offs);\n\terr = recover_head(c, c->ihead_lnum, c->ihead_offs, sbuf);\n\tif (err)\n\t\treturn err;\n\n\tdbg_rcvry(\"checking LPT head at %d:%d\", c->nhead_lnum, c->nhead_offs);\n\n\treturn recover_head(c, c->nhead_lnum, c->nhead_offs, sbuf);\n}\n\n \nstatic int clean_an_unclean_leb(struct ubifs_info *c,\n\t\t\t\tstruct ubifs_unclean_leb *ucleb, void *sbuf)\n{\n\tint err, lnum = ucleb->lnum, offs = 0, len = ucleb->endpt, quiet = 1;\n\tvoid *buf = sbuf;\n\n\tdbg_rcvry(\"LEB %d len %d\", lnum, len);\n\n\tif (len == 0) {\n\t\t \n\t\treturn ubifs_leb_unmap(c, lnum);\n\t}\n\n\terr = ubifs_leb_read(c, lnum, buf, offs, len, 0);\n\tif (err && err != -EBADMSG)\n\t\treturn err;\n\n\twhile (len >= 8) {\n\t\tint ret;\n\n\t\tcond_resched();\n\n\t\t \n\t\tret = ubifs_scan_a_node(c, buf, len, lnum, offs, quiet);\n\n\t\tif (ret == SCANNED_A_NODE) {\n\t\t\t \n\t\t\tstruct ubifs_ch *ch = buf;\n\t\t\tint node_len;\n\n\t\t\tnode_len = ALIGN(le32_to_cpu(ch->len), 8);\n\t\t\toffs += node_len;\n\t\t\tbuf += node_len;\n\t\t\tlen -= node_len;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ret > 0) {\n\t\t\t \n\t\t\toffs += ret;\n\t\t\tbuf += ret;\n\t\t\tlen -= ret;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ret == SCANNED_EMPTY_SPACE) {\n\t\t\tubifs_err(c, \"unexpected empty space at %d:%d\",\n\t\t\t\t  lnum, offs);\n\t\t\treturn -EUCLEAN;\n\t\t}\n\n\t\tif (quiet) {\n\t\t\t \n\t\t\tquiet = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tubifs_scanned_corruption(c, lnum, offs, buf);\n\t\treturn -EUCLEAN;\n\t}\n\n\t \n\tlen = ALIGN(ucleb->endpt, c->min_io_size);\n\tif (len > ucleb->endpt) {\n\t\tint pad_len = len - ALIGN(ucleb->endpt, 8);\n\n\t\tif (pad_len > 0) {\n\t\t\tbuf = c->sbuf + len - pad_len;\n\t\t\tubifs_pad(c, buf, pad_len);\n\t\t}\n\t}\n\n\t \n\terr = ubifs_leb_change(c, lnum, sbuf, len);\n\tif (err)\n\t\treturn err;\n\n\tdbg_rcvry(\"cleaned LEB %d\", lnum);\n\n\treturn 0;\n}\n\n \nint ubifs_clean_lebs(struct ubifs_info *c, void *sbuf)\n{\n\tdbg_rcvry(\"recovery\");\n\twhile (!list_empty(&c->unclean_leb_list)) {\n\t\tstruct ubifs_unclean_leb *ucleb;\n\t\tint err;\n\n\t\tucleb = list_entry(c->unclean_leb_list.next,\n\t\t\t\t   struct ubifs_unclean_leb, list);\n\t\terr = clean_an_unclean_leb(c, ucleb, sbuf);\n\t\tif (err)\n\t\t\treturn err;\n\t\tlist_del(&ucleb->list);\n\t\tkfree(ucleb);\n\t}\n\treturn 0;\n}\n\n \nstatic int grab_empty_leb(struct ubifs_info *c)\n{\n\tint lnum, err;\n\n\t \n\tlnum = ubifs_find_free_leb_for_idx(c);\n\tif (lnum < 0) {\n\t\tubifs_err(c, \"could not find an empty LEB\");\n\t\tubifs_dump_lprops(c);\n\t\tubifs_dump_budg(c, &c->bi);\n\t\treturn lnum;\n\t}\n\n\t \n\terr = ubifs_change_one_lp(c, lnum, LPROPS_NC, LPROPS_NC, 0,\n\t\t\t\t  LPROPS_INDEX, 0);\n\tif (err)\n\t\treturn err;\n\n\tc->gc_lnum = lnum;\n\tdbg_rcvry(\"found empty LEB %d, run commit\", lnum);\n\n\treturn ubifs_run_commit(c);\n}\n\n \nint ubifs_rcvry_gc_commit(struct ubifs_info *c)\n{\n\tstruct ubifs_wbuf *wbuf = &c->jheads[GCHD].wbuf;\n\tstruct ubifs_lprops lp;\n\tint err;\n\n\tdbg_rcvry(\"GC head LEB %d, offs %d\", wbuf->lnum, wbuf->offs);\n\n\tc->gc_lnum = -1;\n\tif (wbuf->lnum == -1 || wbuf->offs == c->leb_size)\n\t\treturn grab_empty_leb(c);\n\n\terr = ubifs_find_dirty_leb(c, &lp, wbuf->offs, 2);\n\tif (err) {\n\t\tif (err != -ENOSPC)\n\t\t\treturn err;\n\n\t\tdbg_rcvry(\"could not find a dirty LEB\");\n\t\treturn grab_empty_leb(c);\n\t}\n\n\tubifs_assert(c, !(lp.flags & LPROPS_INDEX));\n\tubifs_assert(c, lp.free + lp.dirty >= wbuf->offs);\n\n\t \n\tdbg_rcvry(\"committing\");\n\terr = ubifs_run_commit(c);\n\tif (err)\n\t\treturn err;\n\n\tdbg_rcvry(\"GC'ing LEB %d\", lp.lnum);\n\tmutex_lock_nested(&wbuf->io_mutex, wbuf->jhead);\n\terr = ubifs_garbage_collect_leb(c, &lp);\n\tif (err >= 0) {\n\t\tint err2 = ubifs_wbuf_sync_nolock(wbuf);\n\n\t\tif (err2)\n\t\t\terr = err2;\n\t}\n\tmutex_unlock(&wbuf->io_mutex);\n\tif (err < 0) {\n\t\tubifs_err(c, \"GC failed, error %d\", err);\n\t\tif (err == -EAGAIN)\n\t\t\terr = -EINVAL;\n\t\treturn err;\n\t}\n\n\tubifs_assert(c, err == LEB_RETAINED);\n\tif (err != LEB_RETAINED)\n\t\treturn -EINVAL;\n\n\terr = ubifs_leb_unmap(c, c->gc_lnum);\n\tif (err)\n\t\treturn err;\n\n\tdbg_rcvry(\"allocated LEB %d for GC\", lp.lnum);\n\treturn 0;\n}\n\n \nstruct size_entry {\n\tstruct rb_node rb;\n\tino_t inum;\n\tloff_t i_size;\n\tloff_t d_size;\n\tint exists;\n\tstruct inode *inode;\n};\n\n \nstatic int add_ino(struct ubifs_info *c, ino_t inum, loff_t i_size,\n\t\t   loff_t d_size, int exists)\n{\n\tstruct rb_node **p = &c->size_tree.rb_node, *parent = NULL;\n\tstruct size_entry *e;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\te = rb_entry(parent, struct size_entry, rb);\n\t\tif (inum < e->inum)\n\t\t\tp = &(*p)->rb_left;\n\t\telse\n\t\t\tp = &(*p)->rb_right;\n\t}\n\n\te = kzalloc(sizeof(struct size_entry), GFP_KERNEL);\n\tif (!e)\n\t\treturn -ENOMEM;\n\n\te->inum = inum;\n\te->i_size = i_size;\n\te->d_size = d_size;\n\te->exists = exists;\n\n\trb_link_node(&e->rb, parent, p);\n\trb_insert_color(&e->rb, &c->size_tree);\n\n\treturn 0;\n}\n\n \nstatic struct size_entry *find_ino(struct ubifs_info *c, ino_t inum)\n{\n\tstruct rb_node *p = c->size_tree.rb_node;\n\tstruct size_entry *e;\n\n\twhile (p) {\n\t\te = rb_entry(p, struct size_entry, rb);\n\t\tif (inum < e->inum)\n\t\t\tp = p->rb_left;\n\t\telse if (inum > e->inum)\n\t\t\tp = p->rb_right;\n\t\telse\n\t\t\treturn e;\n\t}\n\treturn NULL;\n}\n\n \nstatic void remove_ino(struct ubifs_info *c, ino_t inum)\n{\n\tstruct size_entry *e = find_ino(c, inum);\n\n\tif (!e)\n\t\treturn;\n\trb_erase(&e->rb, &c->size_tree);\n\tkfree(e);\n}\n\n \nvoid ubifs_destroy_size_tree(struct ubifs_info *c)\n{\n\tstruct size_entry *e, *n;\n\n\trbtree_postorder_for_each_entry_safe(e, n, &c->size_tree, rb) {\n\t\tiput(e->inode);\n\t\tkfree(e);\n\t}\n\n\tc->size_tree = RB_ROOT;\n}\n\n \nint ubifs_recover_size_accum(struct ubifs_info *c, union ubifs_key *key,\n\t\t\t     int deletion, loff_t new_size)\n{\n\tino_t inum = key_inum(c, key);\n\tstruct size_entry *e;\n\tint err;\n\n\tswitch (key_type(c, key)) {\n\tcase UBIFS_INO_KEY:\n\t\tif (deletion)\n\t\t\tremove_ino(c, inum);\n\t\telse {\n\t\t\te = find_ino(c, inum);\n\t\t\tif (e) {\n\t\t\t\te->i_size = new_size;\n\t\t\t\te->exists = 1;\n\t\t\t} else {\n\t\t\t\terr = add_ino(c, inum, new_size, 0, 1);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase UBIFS_DATA_KEY:\n\t\te = find_ino(c, inum);\n\t\tif (e) {\n\t\t\tif (new_size > e->d_size)\n\t\t\t\te->d_size = new_size;\n\t\t} else {\n\t\t\terr = add_ino(c, inum, 0, new_size, 0);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tbreak;\n\tcase UBIFS_TRUN_KEY:\n\t\te = find_ino(c, inum);\n\t\tif (e)\n\t\t\te->d_size = new_size;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n \nstatic int fix_size_in_place(struct ubifs_info *c, struct size_entry *e)\n{\n\tstruct ubifs_ino_node *ino = c->sbuf;\n\tunsigned char *p;\n\tunion ubifs_key key;\n\tint err, lnum, offs, len;\n\tloff_t i_size;\n\tuint32_t crc;\n\n\t \n\tino_key_init(c, &key, e->inum);\n\terr = ubifs_tnc_locate(c, &key, ino, &lnum, &offs);\n\tif (err)\n\t\tgoto out;\n\t \n\ti_size = le64_to_cpu(ino->size);\n\tif (i_size >= e->d_size)\n\t\treturn 0;\n\t \n\terr = ubifs_leb_read(c, lnum, c->sbuf, 0, c->leb_size, 1);\n\tif (err)\n\t\tgoto out;\n\t \n\tino = c->sbuf + offs;\n\tino->size = cpu_to_le64(e->d_size);\n\tlen = le32_to_cpu(ino->ch.len);\n\tcrc = crc32(UBIFS_CRC32_INIT, (void *)ino + 8, len - 8);\n\tino->ch.crc = cpu_to_le32(crc);\n\t \n\tp = c->sbuf;\n\tlen = c->leb_size - 1;\n\twhile (p[len] == 0xff)\n\t\tlen -= 1;\n\tlen = ALIGN(len + 1, c->min_io_size);\n\t \n\terr = ubifs_leb_change(c, lnum, c->sbuf, len);\n\tif (err)\n\t\tgoto out;\n\tdbg_rcvry(\"inode %lu at %d:%d size %lld -> %lld\",\n\t\t  (unsigned long)e->inum, lnum, offs, i_size, e->d_size);\n\treturn 0;\n\nout:\n\tubifs_warn(c, \"inode %lu failed to fix size %lld -> %lld error %d\",\n\t\t   (unsigned long)e->inum, e->i_size, e->d_size, err);\n\treturn err;\n}\n\n \nstatic int inode_fix_size(struct ubifs_info *c, struct size_entry *e)\n{\n\tstruct inode *inode;\n\tstruct ubifs_inode *ui;\n\tint err;\n\n\tif (c->ro_mount)\n\t\tubifs_assert(c, !e->inode);\n\n\tif (e->inode) {\n\t\t \n\t\tinode = e->inode;\n\t} else {\n\t\tinode = ubifs_iget(c->vfs_sb, e->inum);\n\t\tif (IS_ERR(inode))\n\t\t\treturn PTR_ERR(inode);\n\n\t\tif (inode->i_size >= e->d_size) {\n\t\t\t \n\t\t\tiput(inode);\n\t\t\treturn 0;\n\t\t}\n\n\t\tdbg_rcvry(\"ino %lu size %lld -> %lld\",\n\t\t\t  (unsigned long)e->inum,\n\t\t\t  inode->i_size, e->d_size);\n\n\t\tui = ubifs_inode(inode);\n\n\t\tinode->i_size = e->d_size;\n\t\tui->ui_size = e->d_size;\n\t\tui->synced_i_size = e->d_size;\n\n\t\te->inode = inode;\n\t}\n\n\t \n\tif (c->ro_mount)\n\t\treturn 0;\n\n\terr = ubifs_jnl_write_inode(c, inode);\n\n\tiput(inode);\n\n\tif (err)\n\t\treturn err;\n\n\trb_erase(&e->rb, &c->size_tree);\n\tkfree(e);\n\n\treturn 0;\n}\n\n \nint ubifs_recover_size(struct ubifs_info *c, bool in_place)\n{\n\tstruct rb_node *this = rb_first(&c->size_tree);\n\n\twhile (this) {\n\t\tstruct size_entry *e;\n\t\tint err;\n\n\t\te = rb_entry(this, struct size_entry, rb);\n\n\t\tthis = rb_next(this);\n\n\t\tif (!e->exists) {\n\t\t\tunion ubifs_key key;\n\n\t\t\tino_key_init(c, &key, e->inum);\n\t\t\terr = ubifs_tnc_lookup(c, &key, c->sbuf);\n\t\t\tif (err && err != -ENOENT)\n\t\t\t\treturn err;\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t \n\t\t\t\tdbg_rcvry(\"removing ino %lu\",\n\t\t\t\t\t  (unsigned long)e->inum);\n\t\t\t\terr = ubifs_tnc_remove_ino(c, e->inum);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t} else {\n\t\t\t\tstruct ubifs_ino_node *ino = c->sbuf;\n\n\t\t\t\te->exists = 1;\n\t\t\t\te->i_size = le64_to_cpu(ino->size);\n\t\t\t}\n\t\t}\n\n\t\tif (e->exists && e->i_size < e->d_size) {\n\t\t\tubifs_assert(c, !(c->ro_mount && in_place));\n\n\t\t\t \n\n\t\t\tif (in_place) {\n\t\t\t\terr = fix_size_in_place(c, e);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t\tiput(e->inode);\n\t\t\t} else {\n\t\t\t\terr = inode_fix_size(c, e);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\trb_erase(&e->rb, &c->size_tree);\n\t\tkfree(e);\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}