{
  "module_name": "shrinker.c",
  "hash_id": "807ca714c797c9ea304a0904fd6bcb50d83eed413ac9ddbbda6b6706d9dc3596",
  "original_prompt": "Ingested from linux-6.6.14/fs/ubifs/shrinker.c",
  "human_readable_source": "\n \n\n \n\n#include \"ubifs.h\"\n\n \nLIST_HEAD(ubifs_infos);\n\n \nstatic unsigned int shrinker_run_no;\n\n \nDEFINE_SPINLOCK(ubifs_infos_lock);\n\n \natomic_long_t ubifs_clean_zn_cnt;\n\n \nstatic int shrink_tnc(struct ubifs_info *c, int nr, int age, int *contention)\n{\n\tint total_freed = 0;\n\tstruct ubifs_znode *znode, *zprev;\n\ttime64_t time = ktime_get_seconds();\n\n\tubifs_assert(c, mutex_is_locked(&c->umount_mutex));\n\tubifs_assert(c, mutex_is_locked(&c->tnc_mutex));\n\n\tif (!c->zroot.znode || atomic_long_read(&c->clean_zn_cnt) == 0)\n\t\treturn 0;\n\n\t \n\tzprev = NULL;\n\tznode = ubifs_tnc_levelorder_next(c, c->zroot.znode, NULL);\n\twhile (znode && total_freed < nr &&\n\t       atomic_long_read(&c->clean_zn_cnt) > 0) {\n\t\tint freed;\n\n\t\t \n\n\t\tif (znode->cnext) {\n\t\t\t \n\t\t\t*contention = 1;\n\t\t} else if (!ubifs_zn_dirty(znode) &&\n\t\t\t   abs(time - znode->time) >= age) {\n\t\t\tif (znode->parent)\n\t\t\t\tznode->parent->zbranch[znode->iip].znode = NULL;\n\t\t\telse\n\t\t\t\tc->zroot.znode = NULL;\n\n\t\t\tfreed = ubifs_destroy_tnc_subtree(c, znode);\n\t\t\tatomic_long_sub(freed, &ubifs_clean_zn_cnt);\n\t\t\tatomic_long_sub(freed, &c->clean_zn_cnt);\n\t\t\ttotal_freed += freed;\n\t\t\tznode = zprev;\n\t\t}\n\n\t\tif (unlikely(!c->zroot.znode))\n\t\t\tbreak;\n\n\t\tzprev = znode;\n\t\tznode = ubifs_tnc_levelorder_next(c, c->zroot.znode, znode);\n\t\tcond_resched();\n\t}\n\n\treturn total_freed;\n}\n\n \nstatic int shrink_tnc_trees(int nr, int age, int *contention)\n{\n\tstruct ubifs_info *c;\n\tstruct list_head *p;\n\tunsigned int run_no;\n\tint freed = 0;\n\n\tspin_lock(&ubifs_infos_lock);\n\tdo {\n\t\trun_no = ++shrinker_run_no;\n\t} while (run_no == 0);\n\t \n\tp = ubifs_infos.next;\n\twhile (p != &ubifs_infos) {\n\t\tc = list_entry(p, struct ubifs_info, infos_list);\n\t\t \n\t\tif (c->shrinker_run_no == run_no)\n\t\t\tbreak;\n\t\tif (!mutex_trylock(&c->umount_mutex)) {\n\t\t\t \n\t\t\t*contention = 1;\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (!mutex_trylock(&c->tnc_mutex)) {\n\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t*contention = 1;\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&ubifs_infos_lock);\n\t\t \n\t\tc->shrinker_run_no = run_no;\n\t\tfreed += shrink_tnc(c, nr, age, contention);\n\t\tmutex_unlock(&c->tnc_mutex);\n\t\tspin_lock(&ubifs_infos_lock);\n\t\t \n\t\tp = p->next;\n\t\t \n\t\tlist_move_tail(&c->infos_list, &ubifs_infos);\n\t\tmutex_unlock(&c->umount_mutex);\n\t\tif (freed >= nr)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&ubifs_infos_lock);\n\treturn freed;\n}\n\n \nstatic int kick_a_thread(void)\n{\n\tint i;\n\tstruct ubifs_info *c;\n\n\t \n\tspin_lock(&ubifs_infos_lock);\n\tfor (i = 0; i < 2; i++) {\n\t\tlist_for_each_entry(c, &ubifs_infos, infos_list) {\n\t\t\tlong dirty_zn_cnt;\n\n\t\t\tif (!mutex_trylock(&c->umount_mutex)) {\n\t\t\t\t \n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tdirty_zn_cnt = atomic_long_read(&c->dirty_zn_cnt);\n\n\t\t\tif (!dirty_zn_cnt || c->cmt_state == COMMIT_BROKEN ||\n\t\t\t    c->ro_mount || c->ro_error) {\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (c->cmt_state != COMMIT_RESTING) {\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (i == 1) {\n\t\t\t\tlist_move_tail(&c->infos_list, &ubifs_infos);\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\n\t\t\t\tubifs_request_bg_commit(c);\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t}\n\t}\n\tspin_unlock(&ubifs_infos_lock);\n\n\treturn 0;\n}\n\nunsigned long ubifs_shrink_count(struct shrinker *shrink,\n\t\t\t\t struct shrink_control *sc)\n{\n\tlong clean_zn_cnt = atomic_long_read(&ubifs_clean_zn_cnt);\n\n\t \n\treturn clean_zn_cnt >= 0 ? clean_zn_cnt : 1;\n}\n\nunsigned long ubifs_shrink_scan(struct shrinker *shrink,\n\t\t\t\tstruct shrink_control *sc)\n{\n\tunsigned long nr = sc->nr_to_scan;\n\tint contention = 0;\n\tunsigned long freed;\n\tlong clean_zn_cnt = atomic_long_read(&ubifs_clean_zn_cnt);\n\n\tif (!clean_zn_cnt) {\n\t\t \n\t\tdbg_tnc(\"no clean znodes, kick a thread\");\n\t\treturn kick_a_thread();\n\t}\n\n\tfreed = shrink_tnc_trees(nr, OLD_ZNODE_AGE, &contention);\n\tif (freed >= nr)\n\t\tgoto out;\n\n\tdbg_tnc(\"not enough old znodes, try to free young ones\");\n\tfreed += shrink_tnc_trees(nr - freed, YOUNG_ZNODE_AGE, &contention);\n\tif (freed >= nr)\n\t\tgoto out;\n\n\tdbg_tnc(\"not enough young znodes, free all\");\n\tfreed += shrink_tnc_trees(nr - freed, 0, &contention);\n\n\tif (!freed && contention) {\n\t\tdbg_tnc(\"freed nothing, but contention\");\n\t\treturn SHRINK_STOP;\n\t}\n\nout:\n\tdbg_tnc(\"%lu znodes were freed, requested %lu\", freed, nr);\n\treturn freed;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}