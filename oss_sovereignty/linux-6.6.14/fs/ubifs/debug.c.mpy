{
  "module_name": "debug.c",
  "hash_id": "08df45627789f96680bc57da59907462122259cbbace0c2b07162211897a5ffb",
  "original_prompt": "Ingested from linux-6.6.14/fs/ubifs/debug.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/math64.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/ctype.h>\n#include \"ubifs.h\"\n\nstatic DEFINE_SPINLOCK(dbg_lock);\n\nstatic const char *get_key_fmt(int fmt)\n{\n\tswitch (fmt) {\n\tcase UBIFS_SIMPLE_KEY_FMT:\n\t\treturn \"simple\";\n\tdefault:\n\t\treturn \"unknown/invalid format\";\n\t}\n}\n\nstatic const char *get_key_hash(int hash)\n{\n\tswitch (hash) {\n\tcase UBIFS_KEY_HASH_R5:\n\t\treturn \"R5\";\n\tcase UBIFS_KEY_HASH_TEST:\n\t\treturn \"test\";\n\tdefault:\n\t\treturn \"unknown/invalid name hash\";\n\t}\n}\n\nstatic const char *get_key_type(int type)\n{\n\tswitch (type) {\n\tcase UBIFS_INO_KEY:\n\t\treturn \"inode\";\n\tcase UBIFS_DENT_KEY:\n\t\treturn \"direntry\";\n\tcase UBIFS_XENT_KEY:\n\t\treturn \"xentry\";\n\tcase UBIFS_DATA_KEY:\n\t\treturn \"data\";\n\tcase UBIFS_TRUN_KEY:\n\t\treturn \"truncate\";\n\tdefault:\n\t\treturn \"unknown/invalid key\";\n\t}\n}\n\nstatic const char *get_dent_type(int type)\n{\n\tswitch (type) {\n\tcase UBIFS_ITYPE_REG:\n\t\treturn \"file\";\n\tcase UBIFS_ITYPE_DIR:\n\t\treturn \"dir\";\n\tcase UBIFS_ITYPE_LNK:\n\t\treturn \"symlink\";\n\tcase UBIFS_ITYPE_BLK:\n\t\treturn \"blkdev\";\n\tcase UBIFS_ITYPE_CHR:\n\t\treturn \"char dev\";\n\tcase UBIFS_ITYPE_FIFO:\n\t\treturn \"fifo\";\n\tcase UBIFS_ITYPE_SOCK:\n\t\treturn \"socket\";\n\tdefault:\n\t\treturn \"unknown/invalid type\";\n\t}\n}\n\nconst char *dbg_snprintf_key(const struct ubifs_info *c,\n\t\t\t     const union ubifs_key *key, char *buffer, int len)\n{\n\tchar *p = buffer;\n\tint type = key_type(c, key);\n\n\tif (c->key_fmt == UBIFS_SIMPLE_KEY_FMT) {\n\t\tswitch (type) {\n\t\tcase UBIFS_INO_KEY:\n\t\t\tlen -= snprintf(p, len, \"(%lu, %s)\",\n\t\t\t\t\t(unsigned long)key_inum(c, key),\n\t\t\t\t\tget_key_type(type));\n\t\t\tbreak;\n\t\tcase UBIFS_DENT_KEY:\n\t\tcase UBIFS_XENT_KEY:\n\t\t\tlen -= snprintf(p, len, \"(%lu, %s, %#08x)\",\n\t\t\t\t\t(unsigned long)key_inum(c, key),\n\t\t\t\t\tget_key_type(type), key_hash(c, key));\n\t\t\tbreak;\n\t\tcase UBIFS_DATA_KEY:\n\t\t\tlen -= snprintf(p, len, \"(%lu, %s, %u)\",\n\t\t\t\t\t(unsigned long)key_inum(c, key),\n\t\t\t\t\tget_key_type(type), key_block(c, key));\n\t\t\tbreak;\n\t\tcase UBIFS_TRUN_KEY:\n\t\t\tlen -= snprintf(p, len, \"(%lu, %s)\",\n\t\t\t\t\t(unsigned long)key_inum(c, key),\n\t\t\t\t\tget_key_type(type));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlen -= snprintf(p, len, \"(bad key type: %#08x, %#08x)\",\n\t\t\t\t\tkey->u32[0], key->u32[1]);\n\t\t}\n\t} else\n\t\tlen -= snprintf(p, len, \"bad key format %d\", c->key_fmt);\n\tubifs_assert(c, len > 0);\n\treturn p;\n}\n\nconst char *dbg_ntype(int type)\n{\n\tswitch (type) {\n\tcase UBIFS_PAD_NODE:\n\t\treturn \"padding node\";\n\tcase UBIFS_SB_NODE:\n\t\treturn \"superblock node\";\n\tcase UBIFS_MST_NODE:\n\t\treturn \"master node\";\n\tcase UBIFS_REF_NODE:\n\t\treturn \"reference node\";\n\tcase UBIFS_INO_NODE:\n\t\treturn \"inode node\";\n\tcase UBIFS_DENT_NODE:\n\t\treturn \"direntry node\";\n\tcase UBIFS_XENT_NODE:\n\t\treturn \"xentry node\";\n\tcase UBIFS_DATA_NODE:\n\t\treturn \"data node\";\n\tcase UBIFS_TRUN_NODE:\n\t\treturn \"truncate node\";\n\tcase UBIFS_IDX_NODE:\n\t\treturn \"indexing node\";\n\tcase UBIFS_CS_NODE:\n\t\treturn \"commit start node\";\n\tcase UBIFS_ORPH_NODE:\n\t\treturn \"orphan node\";\n\tcase UBIFS_AUTH_NODE:\n\t\treturn \"auth node\";\n\tdefault:\n\t\treturn \"unknown node\";\n\t}\n}\n\nstatic const char *dbg_gtype(int type)\n{\n\tswitch (type) {\n\tcase UBIFS_NO_NODE_GROUP:\n\t\treturn \"no node group\";\n\tcase UBIFS_IN_NODE_GROUP:\n\t\treturn \"in node group\";\n\tcase UBIFS_LAST_OF_NODE_GROUP:\n\t\treturn \"last of node group\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\nconst char *dbg_cstate(int cmt_state)\n{\n\tswitch (cmt_state) {\n\tcase COMMIT_RESTING:\n\t\treturn \"commit resting\";\n\tcase COMMIT_BACKGROUND:\n\t\treturn \"background commit requested\";\n\tcase COMMIT_REQUIRED:\n\t\treturn \"commit required\";\n\tcase COMMIT_RUNNING_BACKGROUND:\n\t\treturn \"BACKGROUND commit running\";\n\tcase COMMIT_RUNNING_REQUIRED:\n\t\treturn \"commit running and required\";\n\tcase COMMIT_BROKEN:\n\t\treturn \"broken commit\";\n\tdefault:\n\t\treturn \"unknown commit state\";\n\t}\n}\n\nconst char *dbg_jhead(int jhead)\n{\n\tswitch (jhead) {\n\tcase GCHD:\n\t\treturn \"0 (GC)\";\n\tcase BASEHD:\n\t\treturn \"1 (base)\";\n\tcase DATAHD:\n\t\treturn \"2 (data)\";\n\tdefault:\n\t\treturn \"unknown journal head\";\n\t}\n}\n\nstatic void dump_ch(const struct ubifs_ch *ch)\n{\n\tpr_err(\"\\tmagic          %#x\\n\", le32_to_cpu(ch->magic));\n\tpr_err(\"\\tcrc            %#x\\n\", le32_to_cpu(ch->crc));\n\tpr_err(\"\\tnode_type      %d (%s)\\n\", ch->node_type,\n\t       dbg_ntype(ch->node_type));\n\tpr_err(\"\\tgroup_type     %d (%s)\\n\", ch->group_type,\n\t       dbg_gtype(ch->group_type));\n\tpr_err(\"\\tsqnum          %llu\\n\",\n\t       (unsigned long long)le64_to_cpu(ch->sqnum));\n\tpr_err(\"\\tlen            %u\\n\", le32_to_cpu(ch->len));\n}\n\nvoid ubifs_dump_inode(struct ubifs_info *c, const struct inode *inode)\n{\n\tconst struct ubifs_inode *ui = ubifs_inode(inode);\n\tstruct fscrypt_name nm = {0};\n\tunion ubifs_key key;\n\tstruct ubifs_dent_node *dent, *pdent = NULL;\n\tint count = 2;\n\n\tpr_err(\"Dump in-memory inode:\");\n\tpr_err(\"\\tinode          %lu\\n\", inode->i_ino);\n\tpr_err(\"\\tsize           %llu\\n\",\n\t       (unsigned long long)i_size_read(inode));\n\tpr_err(\"\\tnlink          %u\\n\", inode->i_nlink);\n\tpr_err(\"\\tuid            %u\\n\", (unsigned int)i_uid_read(inode));\n\tpr_err(\"\\tgid            %u\\n\", (unsigned int)i_gid_read(inode));\n\tpr_err(\"\\tatime          %u.%u\\n\",\n\t       (unsigned int)inode->i_atime.tv_sec,\n\t       (unsigned int)inode->i_atime.tv_nsec);\n\tpr_err(\"\\tmtime          %u.%u\\n\",\n\t       (unsigned int)inode->i_mtime.tv_sec,\n\t       (unsigned int)inode->i_mtime.tv_nsec);\n\tpr_err(\"\\tctime          %u.%u\\n\",\n\t       (unsigned int) inode_get_ctime(inode).tv_sec,\n\t       (unsigned int) inode_get_ctime(inode).tv_nsec);\n\tpr_err(\"\\tcreat_sqnum    %llu\\n\", ui->creat_sqnum);\n\tpr_err(\"\\txattr_size     %u\\n\", ui->xattr_size);\n\tpr_err(\"\\txattr_cnt      %u\\n\", ui->xattr_cnt);\n\tpr_err(\"\\txattr_names    %u\\n\", ui->xattr_names);\n\tpr_err(\"\\tdirty          %u\\n\", ui->dirty);\n\tpr_err(\"\\txattr          %u\\n\", ui->xattr);\n\tpr_err(\"\\tbulk_read      %u\\n\", ui->bulk_read);\n\tpr_err(\"\\tsynced_i_size  %llu\\n\",\n\t       (unsigned long long)ui->synced_i_size);\n\tpr_err(\"\\tui_size        %llu\\n\",\n\t       (unsigned long long)ui->ui_size);\n\tpr_err(\"\\tflags          %d\\n\", ui->flags);\n\tpr_err(\"\\tcompr_type     %d\\n\", ui->compr_type);\n\tpr_err(\"\\tlast_page_read %lu\\n\", ui->last_page_read);\n\tpr_err(\"\\tread_in_a_row  %lu\\n\", ui->read_in_a_row);\n\tpr_err(\"\\tdata_len       %d\\n\", ui->data_len);\n\n\tif (!S_ISDIR(inode->i_mode))\n\t\treturn;\n\n\tpr_err(\"List of directory entries:\\n\");\n\tubifs_assert(c, !mutex_is_locked(&c->tnc_mutex));\n\n\tlowest_dent_key(c, &key, inode->i_ino);\n\twhile (1) {\n\t\tdent = ubifs_tnc_next_ent(c, &key, &nm);\n\t\tif (IS_ERR(dent)) {\n\t\t\tif (PTR_ERR(dent) != -ENOENT)\n\t\t\t\tpr_err(\"error %ld\\n\", PTR_ERR(dent));\n\t\t\tbreak;\n\t\t}\n\n\t\tpr_err(\"\\t%d: inode %llu, type %s, len %d\\n\",\n\t\t       count++, (unsigned long long) le64_to_cpu(dent->inum),\n\t\t       get_dent_type(dent->type),\n\t\t       le16_to_cpu(dent->nlen));\n\n\t\tfname_name(&nm) = dent->name;\n\t\tfname_len(&nm) = le16_to_cpu(dent->nlen);\n\t\tkfree(pdent);\n\t\tpdent = dent;\n\t\tkey_read(c, &dent->key, &key);\n\t}\n\tkfree(pdent);\n}\n\nvoid ubifs_dump_node(const struct ubifs_info *c, const void *node, int node_len)\n{\n\tint i, n, type, safe_len, max_node_len, min_node_len;\n\tunion ubifs_key key;\n\tconst struct ubifs_ch *ch = node;\n\tchar key_buf[DBG_KEY_BUF_LEN];\n\n\t \n\tif (le32_to_cpu(ch->magic) != UBIFS_NODE_MAGIC) {\n\t\tpr_err(\"Not a node, first %zu bytes:\", UBIFS_CH_SZ);\n\t\tprint_hex_dump(KERN_ERR, \"\", DUMP_PREFIX_OFFSET, 32, 1,\n\t\t\t       (void *)node, UBIFS_CH_SZ, 1);\n\t\treturn;\n\t}\n\n\t \n\ttype = ch->node_type;\n\tif (type < 0 || type >= UBIFS_NODE_TYPES_CNT) {\n\t\tpr_err(\"node type %d was not recognized\\n\", type);\n\t\treturn;\n\t}\n\n\tspin_lock(&dbg_lock);\n\tdump_ch(node);\n\n\tif (c->ranges[type].max_len == 0) {\n\t\tmax_node_len = min_node_len = c->ranges[type].len;\n\t} else {\n\t\tmax_node_len = c->ranges[type].max_len;\n\t\tmin_node_len = c->ranges[type].min_len;\n\t}\n\tsafe_len = le32_to_cpu(ch->len);\n\tsafe_len = safe_len > 0 ? safe_len : 0;\n\tsafe_len = min3(safe_len, max_node_len, node_len);\n\tif (safe_len < min_node_len) {\n\t\tpr_err(\"node len(%d) is too short for %s, left %d bytes:\\n\",\n\t\t       safe_len, dbg_ntype(type),\n\t\t       safe_len > UBIFS_CH_SZ ?\n\t\t       safe_len - (int)UBIFS_CH_SZ : 0);\n\t\tif (safe_len > UBIFS_CH_SZ)\n\t\t\tprint_hex_dump(KERN_ERR, \"\", DUMP_PREFIX_OFFSET, 32, 1,\n\t\t\t\t       (void *)node + UBIFS_CH_SZ,\n\t\t\t\t       safe_len - UBIFS_CH_SZ, 0);\n\t\tgoto out_unlock;\n\t}\n\tif (safe_len != le32_to_cpu(ch->len))\n\t\tpr_err(\"\\ttruncated node length      %d\\n\", safe_len);\n\n\tswitch (type) {\n\tcase UBIFS_PAD_NODE:\n\t{\n\t\tconst struct ubifs_pad_node *pad = node;\n\n\t\tpr_err(\"\\tpad_len        %u\\n\", le32_to_cpu(pad->pad_len));\n\t\tbreak;\n\t}\n\tcase UBIFS_SB_NODE:\n\t{\n\t\tconst struct ubifs_sb_node *sup = node;\n\t\tunsigned int sup_flags = le32_to_cpu(sup->flags);\n\n\t\tpr_err(\"\\tkey_hash       %d (%s)\\n\",\n\t\t       (int)sup->key_hash, get_key_hash(sup->key_hash));\n\t\tpr_err(\"\\tkey_fmt        %d (%s)\\n\",\n\t\t       (int)sup->key_fmt, get_key_fmt(sup->key_fmt));\n\t\tpr_err(\"\\tflags          %#x\\n\", sup_flags);\n\t\tpr_err(\"\\tbig_lpt        %u\\n\",\n\t\t       !!(sup_flags & UBIFS_FLG_BIGLPT));\n\t\tpr_err(\"\\tspace_fixup    %u\\n\",\n\t\t       !!(sup_flags & UBIFS_FLG_SPACE_FIXUP));\n\t\tpr_err(\"\\tmin_io_size    %u\\n\", le32_to_cpu(sup->min_io_size));\n\t\tpr_err(\"\\tleb_size       %u\\n\", le32_to_cpu(sup->leb_size));\n\t\tpr_err(\"\\tleb_cnt        %u\\n\", le32_to_cpu(sup->leb_cnt));\n\t\tpr_err(\"\\tmax_leb_cnt    %u\\n\", le32_to_cpu(sup->max_leb_cnt));\n\t\tpr_err(\"\\tmax_bud_bytes  %llu\\n\",\n\t\t       (unsigned long long)le64_to_cpu(sup->max_bud_bytes));\n\t\tpr_err(\"\\tlog_lebs       %u\\n\", le32_to_cpu(sup->log_lebs));\n\t\tpr_err(\"\\tlpt_lebs       %u\\n\", le32_to_cpu(sup->lpt_lebs));\n\t\tpr_err(\"\\torph_lebs      %u\\n\", le32_to_cpu(sup->orph_lebs));\n\t\tpr_err(\"\\tjhead_cnt      %u\\n\", le32_to_cpu(sup->jhead_cnt));\n\t\tpr_err(\"\\tfanout         %u\\n\", le32_to_cpu(sup->fanout));\n\t\tpr_err(\"\\tlsave_cnt      %u\\n\", le32_to_cpu(sup->lsave_cnt));\n\t\tpr_err(\"\\tdefault_compr  %u\\n\",\n\t\t       (int)le16_to_cpu(sup->default_compr));\n\t\tpr_err(\"\\trp_size        %llu\\n\",\n\t\t       (unsigned long long)le64_to_cpu(sup->rp_size));\n\t\tpr_err(\"\\trp_uid         %u\\n\", le32_to_cpu(sup->rp_uid));\n\t\tpr_err(\"\\trp_gid         %u\\n\", le32_to_cpu(sup->rp_gid));\n\t\tpr_err(\"\\tfmt_version    %u\\n\", le32_to_cpu(sup->fmt_version));\n\t\tpr_err(\"\\ttime_gran      %u\\n\", le32_to_cpu(sup->time_gran));\n\t\tpr_err(\"\\tUUID           %pUB\\n\", sup->uuid);\n\t\tbreak;\n\t}\n\tcase UBIFS_MST_NODE:\n\t{\n\t\tconst struct ubifs_mst_node *mst = node;\n\n\t\tpr_err(\"\\thighest_inum   %llu\\n\",\n\t\t       (unsigned long long)le64_to_cpu(mst->highest_inum));\n\t\tpr_err(\"\\tcommit number  %llu\\n\",\n\t\t       (unsigned long long)le64_to_cpu(mst->cmt_no));\n\t\tpr_err(\"\\tflags          %#x\\n\", le32_to_cpu(mst->flags));\n\t\tpr_err(\"\\tlog_lnum       %u\\n\", le32_to_cpu(mst->log_lnum));\n\t\tpr_err(\"\\troot_lnum      %u\\n\", le32_to_cpu(mst->root_lnum));\n\t\tpr_err(\"\\troot_offs      %u\\n\", le32_to_cpu(mst->root_offs));\n\t\tpr_err(\"\\troot_len       %u\\n\", le32_to_cpu(mst->root_len));\n\t\tpr_err(\"\\tgc_lnum        %u\\n\", le32_to_cpu(mst->gc_lnum));\n\t\tpr_err(\"\\tihead_lnum     %u\\n\", le32_to_cpu(mst->ihead_lnum));\n\t\tpr_err(\"\\tihead_offs     %u\\n\", le32_to_cpu(mst->ihead_offs));\n\t\tpr_err(\"\\tindex_size     %llu\\n\",\n\t\t       (unsigned long long)le64_to_cpu(mst->index_size));\n\t\tpr_err(\"\\tlpt_lnum       %u\\n\", le32_to_cpu(mst->lpt_lnum));\n\t\tpr_err(\"\\tlpt_offs       %u\\n\", le32_to_cpu(mst->lpt_offs));\n\t\tpr_err(\"\\tnhead_lnum     %u\\n\", le32_to_cpu(mst->nhead_lnum));\n\t\tpr_err(\"\\tnhead_offs     %u\\n\", le32_to_cpu(mst->nhead_offs));\n\t\tpr_err(\"\\tltab_lnum      %u\\n\", le32_to_cpu(mst->ltab_lnum));\n\t\tpr_err(\"\\tltab_offs      %u\\n\", le32_to_cpu(mst->ltab_offs));\n\t\tpr_err(\"\\tlsave_lnum     %u\\n\", le32_to_cpu(mst->lsave_lnum));\n\t\tpr_err(\"\\tlsave_offs     %u\\n\", le32_to_cpu(mst->lsave_offs));\n\t\tpr_err(\"\\tlscan_lnum     %u\\n\", le32_to_cpu(mst->lscan_lnum));\n\t\tpr_err(\"\\tleb_cnt        %u\\n\", le32_to_cpu(mst->leb_cnt));\n\t\tpr_err(\"\\tempty_lebs     %u\\n\", le32_to_cpu(mst->empty_lebs));\n\t\tpr_err(\"\\tidx_lebs       %u\\n\", le32_to_cpu(mst->idx_lebs));\n\t\tpr_err(\"\\ttotal_free     %llu\\n\",\n\t\t       (unsigned long long)le64_to_cpu(mst->total_free));\n\t\tpr_err(\"\\ttotal_dirty    %llu\\n\",\n\t\t       (unsigned long long)le64_to_cpu(mst->total_dirty));\n\t\tpr_err(\"\\ttotal_used     %llu\\n\",\n\t\t       (unsigned long long)le64_to_cpu(mst->total_used));\n\t\tpr_err(\"\\ttotal_dead     %llu\\n\",\n\t\t       (unsigned long long)le64_to_cpu(mst->total_dead));\n\t\tpr_err(\"\\ttotal_dark     %llu\\n\",\n\t\t       (unsigned long long)le64_to_cpu(mst->total_dark));\n\t\tbreak;\n\t}\n\tcase UBIFS_REF_NODE:\n\t{\n\t\tconst struct ubifs_ref_node *ref = node;\n\n\t\tpr_err(\"\\tlnum           %u\\n\", le32_to_cpu(ref->lnum));\n\t\tpr_err(\"\\toffs           %u\\n\", le32_to_cpu(ref->offs));\n\t\tpr_err(\"\\tjhead          %u\\n\", le32_to_cpu(ref->jhead));\n\t\tbreak;\n\t}\n\tcase UBIFS_INO_NODE:\n\t{\n\t\tconst struct ubifs_ino_node *ino = node;\n\n\t\tkey_read(c, &ino->key, &key);\n\t\tpr_err(\"\\tkey            %s\\n\",\n\t\t       dbg_snprintf_key(c, &key, key_buf, DBG_KEY_BUF_LEN));\n\t\tpr_err(\"\\tcreat_sqnum    %llu\\n\",\n\t\t       (unsigned long long)le64_to_cpu(ino->creat_sqnum));\n\t\tpr_err(\"\\tsize           %llu\\n\",\n\t\t       (unsigned long long)le64_to_cpu(ino->size));\n\t\tpr_err(\"\\tnlink          %u\\n\", le32_to_cpu(ino->nlink));\n\t\tpr_err(\"\\tatime          %lld.%u\\n\",\n\t\t       (long long)le64_to_cpu(ino->atime_sec),\n\t\t       le32_to_cpu(ino->atime_nsec));\n\t\tpr_err(\"\\tmtime          %lld.%u\\n\",\n\t\t       (long long)le64_to_cpu(ino->mtime_sec),\n\t\t       le32_to_cpu(ino->mtime_nsec));\n\t\tpr_err(\"\\tctime          %lld.%u\\n\",\n\t\t       (long long)le64_to_cpu(ino->ctime_sec),\n\t\t       le32_to_cpu(ino->ctime_nsec));\n\t\tpr_err(\"\\tuid            %u\\n\", le32_to_cpu(ino->uid));\n\t\tpr_err(\"\\tgid            %u\\n\", le32_to_cpu(ino->gid));\n\t\tpr_err(\"\\tmode           %u\\n\", le32_to_cpu(ino->mode));\n\t\tpr_err(\"\\tflags          %#x\\n\", le32_to_cpu(ino->flags));\n\t\tpr_err(\"\\txattr_cnt      %u\\n\", le32_to_cpu(ino->xattr_cnt));\n\t\tpr_err(\"\\txattr_size     %u\\n\", le32_to_cpu(ino->xattr_size));\n\t\tpr_err(\"\\txattr_names    %u\\n\", le32_to_cpu(ino->xattr_names));\n\t\tpr_err(\"\\tcompr_type     %#x\\n\",\n\t\t       (int)le16_to_cpu(ino->compr_type));\n\t\tpr_err(\"\\tdata len       %u\\n\", le32_to_cpu(ino->data_len));\n\t\tbreak;\n\t}\n\tcase UBIFS_DENT_NODE:\n\tcase UBIFS_XENT_NODE:\n\t{\n\t\tconst struct ubifs_dent_node *dent = node;\n\t\tint nlen = le16_to_cpu(dent->nlen);\n\n\t\tkey_read(c, &dent->key, &key);\n\t\tpr_err(\"\\tkey            %s\\n\",\n\t\t       dbg_snprintf_key(c, &key, key_buf, DBG_KEY_BUF_LEN));\n\t\tpr_err(\"\\tinum           %llu\\n\",\n\t\t       (unsigned long long)le64_to_cpu(dent->inum));\n\t\tpr_err(\"\\ttype           %d\\n\", (int)dent->type);\n\t\tpr_err(\"\\tnlen           %d\\n\", nlen);\n\t\tpr_err(\"\\tname           \");\n\n\t\tif (nlen > UBIFS_MAX_NLEN ||\n\t\t    nlen > safe_len - UBIFS_DENT_NODE_SZ)\n\t\t\tpr_err(\"(bad name length, not printing, bad or corrupted node)\");\n\t\telse {\n\t\t\tfor (i = 0; i < nlen && dent->name[i]; i++)\n\t\t\t\tpr_cont(\"%c\", isprint(dent->name[i]) ?\n\t\t\t\t\tdent->name[i] : '?');\n\t\t}\n\t\tpr_cont(\"\\n\");\n\n\t\tbreak;\n\t}\n\tcase UBIFS_DATA_NODE:\n\t{\n\t\tconst struct ubifs_data_node *dn = node;\n\n\t\tkey_read(c, &dn->key, &key);\n\t\tpr_err(\"\\tkey            %s\\n\",\n\t\t       dbg_snprintf_key(c, &key, key_buf, DBG_KEY_BUF_LEN));\n\t\tpr_err(\"\\tsize           %u\\n\", le32_to_cpu(dn->size));\n\t\tpr_err(\"\\tcompr_typ      %d\\n\",\n\t\t       (int)le16_to_cpu(dn->compr_type));\n\t\tpr_err(\"\\tdata size      %u\\n\",\n\t\t       le32_to_cpu(ch->len) - (unsigned int)UBIFS_DATA_NODE_SZ);\n\t\tpr_err(\"\\tdata (length = %d):\\n\",\n\t\t       safe_len - (int)UBIFS_DATA_NODE_SZ);\n\t\tprint_hex_dump(KERN_ERR, \"\\t\", DUMP_PREFIX_OFFSET, 32, 1,\n\t\t\t       (void *)&dn->data,\n\t\t\t       safe_len - (int)UBIFS_DATA_NODE_SZ, 0);\n\t\tbreak;\n\t}\n\tcase UBIFS_TRUN_NODE:\n\t{\n\t\tconst struct ubifs_trun_node *trun = node;\n\n\t\tpr_err(\"\\tinum           %u\\n\", le32_to_cpu(trun->inum));\n\t\tpr_err(\"\\told_size       %llu\\n\",\n\t\t       (unsigned long long)le64_to_cpu(trun->old_size));\n\t\tpr_err(\"\\tnew_size       %llu\\n\",\n\t\t       (unsigned long long)le64_to_cpu(trun->new_size));\n\t\tbreak;\n\t}\n\tcase UBIFS_IDX_NODE:\n\t{\n\t\tconst struct ubifs_idx_node *idx = node;\n\t\tint max_child_cnt = (safe_len - UBIFS_IDX_NODE_SZ) /\n\t\t\t\t    (ubifs_idx_node_sz(c, 1) -\n\t\t\t\t    UBIFS_IDX_NODE_SZ);\n\n\t\tn = min_t(int, le16_to_cpu(idx->child_cnt), max_child_cnt);\n\t\tpr_err(\"\\tchild_cnt      %d\\n\", (int)le16_to_cpu(idx->child_cnt));\n\t\tpr_err(\"\\tlevel          %d\\n\", (int)le16_to_cpu(idx->level));\n\t\tpr_err(\"\\tBranches:\\n\");\n\n\t\tfor (i = 0; i < n && i < c->fanout; i++) {\n\t\t\tconst struct ubifs_branch *br;\n\n\t\t\tbr = ubifs_idx_branch(c, idx, i);\n\t\t\tkey_read(c, &br->key, &key);\n\t\t\tpr_err(\"\\t%d: LEB %d:%d len %d key %s\\n\",\n\t\t\t       i, le32_to_cpu(br->lnum), le32_to_cpu(br->offs),\n\t\t\t       le32_to_cpu(br->len),\n\t\t\t       dbg_snprintf_key(c, &key, key_buf,\n\t\t\t\t\t\tDBG_KEY_BUF_LEN));\n\t\t}\n\t\tbreak;\n\t}\n\tcase UBIFS_CS_NODE:\n\t\tbreak;\n\tcase UBIFS_ORPH_NODE:\n\t{\n\t\tconst struct ubifs_orph_node *orph = node;\n\n\t\tpr_err(\"\\tcommit number  %llu\\n\",\n\t\t       (unsigned long long)\n\t\t\t\tle64_to_cpu(orph->cmt_no) & LLONG_MAX);\n\t\tpr_err(\"\\tlast node flag %llu\\n\",\n\t\t       (unsigned long long)(le64_to_cpu(orph->cmt_no)) >> 63);\n\t\tn = (safe_len - UBIFS_ORPH_NODE_SZ) >> 3;\n\t\tpr_err(\"\\t%d orphan inode numbers:\\n\", n);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tpr_err(\"\\t  ino %llu\\n\",\n\t\t\t       (unsigned long long)le64_to_cpu(orph->inos[i]));\n\t\tbreak;\n\t}\n\tcase UBIFS_AUTH_NODE:\n\t{\n\t\tbreak;\n\t}\n\tdefault:\n\t\tpr_err(\"node type %d was not recognized\\n\", type);\n\t}\n\nout_unlock:\n\tspin_unlock(&dbg_lock);\n}\n\nvoid ubifs_dump_budget_req(const struct ubifs_budget_req *req)\n{\n\tspin_lock(&dbg_lock);\n\tpr_err(\"Budgeting request: new_ino %d, dirtied_ino %d\\n\",\n\t       req->new_ino, req->dirtied_ino);\n\tpr_err(\"\\tnew_ino_d   %d, dirtied_ino_d %d\\n\",\n\t       req->new_ino_d, req->dirtied_ino_d);\n\tpr_err(\"\\tnew_page    %d, dirtied_page %d\\n\",\n\t       req->new_page, req->dirtied_page);\n\tpr_err(\"\\tnew_dent    %d, mod_dent     %d\\n\",\n\t       req->new_dent, req->mod_dent);\n\tpr_err(\"\\tidx_growth  %d\\n\", req->idx_growth);\n\tpr_err(\"\\tdata_growth %d dd_growth     %d\\n\",\n\t       req->data_growth, req->dd_growth);\n\tspin_unlock(&dbg_lock);\n}\n\nvoid ubifs_dump_lstats(const struct ubifs_lp_stats *lst)\n{\n\tspin_lock(&dbg_lock);\n\tpr_err(\"(pid %d) Lprops statistics: empty_lebs %d, idx_lebs  %d\\n\",\n\t       current->pid, lst->empty_lebs, lst->idx_lebs);\n\tpr_err(\"\\ttaken_empty_lebs %d, total_free %lld, total_dirty %lld\\n\",\n\t       lst->taken_empty_lebs, lst->total_free, lst->total_dirty);\n\tpr_err(\"\\ttotal_used %lld, total_dark %lld, total_dead %lld\\n\",\n\t       lst->total_used, lst->total_dark, lst->total_dead);\n\tspin_unlock(&dbg_lock);\n}\n\nvoid ubifs_dump_budg(struct ubifs_info *c, const struct ubifs_budg_info *bi)\n{\n\tint i;\n\tstruct rb_node *rb;\n\tstruct ubifs_bud *bud;\n\tstruct ubifs_gced_idx_leb *idx_gc;\n\tlong long available, outstanding, free;\n\n\tspin_lock(&c->space_lock);\n\tspin_lock(&dbg_lock);\n\tpr_err(\"(pid %d) Budgeting info: data budget sum %lld, total budget sum %lld\\n\",\n\t       current->pid, bi->data_growth + bi->dd_growth,\n\t       bi->data_growth + bi->dd_growth + bi->idx_growth);\n\tpr_err(\"\\tbudg_data_growth %lld, budg_dd_growth %lld, budg_idx_growth %lld\\n\",\n\t       bi->data_growth, bi->dd_growth, bi->idx_growth);\n\tpr_err(\"\\tmin_idx_lebs %d, old_idx_sz %llu, uncommitted_idx %lld\\n\",\n\t       bi->min_idx_lebs, bi->old_idx_sz, bi->uncommitted_idx);\n\tpr_err(\"\\tpage_budget %d, inode_budget %d, dent_budget %d\\n\",\n\t       bi->page_budget, bi->inode_budget, bi->dent_budget);\n\tpr_err(\"\\tnospace %u, nospace_rp %u\\n\", bi->nospace, bi->nospace_rp);\n\tpr_err(\"\\tdark_wm %d, dead_wm %d, max_idx_node_sz %d\\n\",\n\t       c->dark_wm, c->dead_wm, c->max_idx_node_sz);\n\n\tif (bi != &c->bi)\n\t\t \n\t\tgoto out_unlock;\n\n\tpr_err(\"\\tfreeable_cnt %d, calc_idx_sz %lld, idx_gc_cnt %d\\n\",\n\t       c->freeable_cnt, c->calc_idx_sz, c->idx_gc_cnt);\n\tpr_err(\"\\tdirty_pg_cnt %ld, dirty_zn_cnt %ld, clean_zn_cnt %ld\\n\",\n\t       atomic_long_read(&c->dirty_pg_cnt),\n\t       atomic_long_read(&c->dirty_zn_cnt),\n\t       atomic_long_read(&c->clean_zn_cnt));\n\tpr_err(\"\\tgc_lnum %d, ihead_lnum %d\\n\", c->gc_lnum, c->ihead_lnum);\n\n\t \n\tif (c->jheads)\n\t\tfor (i = 0; i < c->jhead_cnt; i++)\n\t\t\tpr_err(\"\\tjhead %s\\t LEB %d\\n\",\n\t\t\t       dbg_jhead(c->jheads[i].wbuf.jhead),\n\t\t\t       c->jheads[i].wbuf.lnum);\n\tfor (rb = rb_first(&c->buds); rb; rb = rb_next(rb)) {\n\t\tbud = rb_entry(rb, struct ubifs_bud, rb);\n\t\tpr_err(\"\\tbud LEB %d\\n\", bud->lnum);\n\t}\n\tlist_for_each_entry(bud, &c->old_buds, list)\n\t\tpr_err(\"\\told bud LEB %d\\n\", bud->lnum);\n\tlist_for_each_entry(idx_gc, &c->idx_gc, list)\n\t\tpr_err(\"\\tGC'ed idx LEB %d unmap %d\\n\",\n\t\t       idx_gc->lnum, idx_gc->unmap);\n\tpr_err(\"\\tcommit state %d\\n\", c->cmt_state);\n\n\t \n\tavailable = ubifs_calc_available(c, c->bi.min_idx_lebs);\n\toutstanding = c->bi.data_growth + c->bi.dd_growth;\n\tfree = ubifs_get_free_space_nolock(c);\n\tpr_err(\"Budgeting predictions:\\n\");\n\tpr_err(\"\\tavailable: %lld, outstanding %lld, free %lld\\n\",\n\t       available, outstanding, free);\nout_unlock:\n\tspin_unlock(&dbg_lock);\n\tspin_unlock(&c->space_lock);\n}\n\nvoid ubifs_dump_lprop(const struct ubifs_info *c, const struct ubifs_lprops *lp)\n{\n\tint i, spc, dark = 0, dead = 0;\n\tstruct rb_node *rb;\n\tstruct ubifs_bud *bud;\n\n\tspc = lp->free + lp->dirty;\n\tif (spc < c->dead_wm)\n\t\tdead = spc;\n\telse\n\t\tdark = ubifs_calc_dark(c, spc);\n\n\tif (lp->flags & LPROPS_INDEX)\n\t\tpr_err(\"LEB %-7d free %-8d dirty %-8d used %-8d free + dirty %-8d flags %#x (\",\n\t\t       lp->lnum, lp->free, lp->dirty, c->leb_size - spc, spc,\n\t\t       lp->flags);\n\telse\n\t\tpr_err(\"LEB %-7d free %-8d dirty %-8d used %-8d free + dirty %-8d dark %-4d dead %-4d nodes fit %-3d flags %#-4x (\",\n\t\t       lp->lnum, lp->free, lp->dirty, c->leb_size - spc, spc,\n\t\t       dark, dead, (int)(spc / UBIFS_MAX_NODE_SZ), lp->flags);\n\n\tif (lp->flags & LPROPS_TAKEN) {\n\t\tif (lp->flags & LPROPS_INDEX)\n\t\t\tpr_cont(\"index, taken\");\n\t\telse\n\t\t\tpr_cont(\"taken\");\n\t} else {\n\t\tconst char *s;\n\n\t\tif (lp->flags & LPROPS_INDEX) {\n\t\t\tswitch (lp->flags & LPROPS_CAT_MASK) {\n\t\t\tcase LPROPS_DIRTY_IDX:\n\t\t\t\ts = \"dirty index\";\n\t\t\t\tbreak;\n\t\t\tcase LPROPS_FRDI_IDX:\n\t\t\t\ts = \"freeable index\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\ts = \"index\";\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (lp->flags & LPROPS_CAT_MASK) {\n\t\t\tcase LPROPS_UNCAT:\n\t\t\t\ts = \"not categorized\";\n\t\t\t\tbreak;\n\t\t\tcase LPROPS_DIRTY:\n\t\t\t\ts = \"dirty\";\n\t\t\t\tbreak;\n\t\t\tcase LPROPS_FREE:\n\t\t\t\ts = \"free\";\n\t\t\t\tbreak;\n\t\t\tcase LPROPS_EMPTY:\n\t\t\t\ts = \"empty\";\n\t\t\t\tbreak;\n\t\t\tcase LPROPS_FREEABLE:\n\t\t\t\ts = \"freeable\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\ts = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tpr_cont(\"%s\", s);\n\t}\n\n\tfor (rb = rb_first((struct rb_root *)&c->buds); rb; rb = rb_next(rb)) {\n\t\tbud = rb_entry(rb, struct ubifs_bud, rb);\n\t\tif (bud->lnum == lp->lnum) {\n\t\t\tint head = 0;\n\t\t\tfor (i = 0; i < c->jhead_cnt; i++) {\n\t\t\t\t \n\t\t\t\tif (c->jheads &&\n\t\t\t\t    lp->lnum == c->jheads[i].wbuf.lnum) {\n\t\t\t\t\tpr_cont(\", jhead %s\", dbg_jhead(i));\n\t\t\t\t\thead = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!head)\n\t\t\t\tpr_cont(\", bud of jhead %s\",\n\t\t\t\t       dbg_jhead(bud->jhead));\n\t\t}\n\t}\n\tif (lp->lnum == c->gc_lnum)\n\t\tpr_cont(\", GC LEB\");\n\tpr_cont(\")\\n\");\n}\n\nvoid ubifs_dump_lprops(struct ubifs_info *c)\n{\n\tint lnum, err;\n\tstruct ubifs_lprops lp;\n\tstruct ubifs_lp_stats lst;\n\n\tpr_err(\"(pid %d) start dumping LEB properties\\n\", current->pid);\n\tubifs_get_lp_stats(c, &lst);\n\tubifs_dump_lstats(&lst);\n\n\tfor (lnum = c->main_first; lnum < c->leb_cnt; lnum++) {\n\t\terr = ubifs_read_one_lp(c, lnum, &lp);\n\t\tif (err) {\n\t\t\tubifs_err(c, \"cannot read lprops for LEB %d\", lnum);\n\t\t\tcontinue;\n\t\t}\n\n\t\tubifs_dump_lprop(c, &lp);\n\t}\n\tpr_err(\"(pid %d) finish dumping LEB properties\\n\", current->pid);\n}\n\nvoid ubifs_dump_lpt_info(struct ubifs_info *c)\n{\n\tint i;\n\n\tspin_lock(&dbg_lock);\n\tpr_err(\"(pid %d) dumping LPT information\\n\", current->pid);\n\tpr_err(\"\\tlpt_sz:        %lld\\n\", c->lpt_sz);\n\tpr_err(\"\\tpnode_sz:      %d\\n\", c->pnode_sz);\n\tpr_err(\"\\tnnode_sz:      %d\\n\", c->nnode_sz);\n\tpr_err(\"\\tltab_sz:       %d\\n\", c->ltab_sz);\n\tpr_err(\"\\tlsave_sz:      %d\\n\", c->lsave_sz);\n\tpr_err(\"\\tbig_lpt:       %u\\n\", c->big_lpt);\n\tpr_err(\"\\tlpt_hght:      %d\\n\", c->lpt_hght);\n\tpr_err(\"\\tpnode_cnt:     %d\\n\", c->pnode_cnt);\n\tpr_err(\"\\tnnode_cnt:     %d\\n\", c->nnode_cnt);\n\tpr_err(\"\\tdirty_pn_cnt:  %d\\n\", c->dirty_pn_cnt);\n\tpr_err(\"\\tdirty_nn_cnt:  %d\\n\", c->dirty_nn_cnt);\n\tpr_err(\"\\tlsave_cnt:     %d\\n\", c->lsave_cnt);\n\tpr_err(\"\\tspace_bits:    %d\\n\", c->space_bits);\n\tpr_err(\"\\tlpt_lnum_bits: %d\\n\", c->lpt_lnum_bits);\n\tpr_err(\"\\tlpt_offs_bits: %d\\n\", c->lpt_offs_bits);\n\tpr_err(\"\\tlpt_spc_bits:  %d\\n\", c->lpt_spc_bits);\n\tpr_err(\"\\tpcnt_bits:     %d\\n\", c->pcnt_bits);\n\tpr_err(\"\\tlnum_bits:     %d\\n\", c->lnum_bits);\n\tpr_err(\"\\tLPT root is at %d:%d\\n\", c->lpt_lnum, c->lpt_offs);\n\tpr_err(\"\\tLPT head is at %d:%d\\n\",\n\t       c->nhead_lnum, c->nhead_offs);\n\tpr_err(\"\\tLPT ltab is at %d:%d\\n\", c->ltab_lnum, c->ltab_offs);\n\tif (c->big_lpt)\n\t\tpr_err(\"\\tLPT lsave is at %d:%d\\n\",\n\t\t       c->lsave_lnum, c->lsave_offs);\n\tfor (i = 0; i < c->lpt_lebs; i++)\n\t\tpr_err(\"\\tLPT LEB %d free %d dirty %d tgc %d cmt %d\\n\",\n\t\t       i + c->lpt_first, c->ltab[i].free, c->ltab[i].dirty,\n\t\t       c->ltab[i].tgc, c->ltab[i].cmt);\n\tspin_unlock(&dbg_lock);\n}\n\nvoid ubifs_dump_leb(const struct ubifs_info *c, int lnum)\n{\n\tstruct ubifs_scan_leb *sleb;\n\tstruct ubifs_scan_node *snod;\n\tvoid *buf;\n\n\tpr_err(\"(pid %d) start dumping LEB %d\\n\", current->pid, lnum);\n\n\tbuf = __vmalloc(c->leb_size, GFP_NOFS);\n\tif (!buf) {\n\t\tubifs_err(c, \"cannot allocate memory for dumping LEB %d\", lnum);\n\t\treturn;\n\t}\n\n\tsleb = ubifs_scan(c, lnum, 0, buf, 0);\n\tif (IS_ERR(sleb)) {\n\t\tubifs_err(c, \"scan error %d\", (int)PTR_ERR(sleb));\n\t\tgoto out;\n\t}\n\n\tpr_err(\"LEB %d has %d nodes ending at %d\\n\", lnum,\n\t       sleb->nodes_cnt, sleb->endpt);\n\n\tlist_for_each_entry(snod, &sleb->nodes, list) {\n\t\tcond_resched();\n\t\tpr_err(\"Dumping node at LEB %d:%d len %d\\n\", lnum,\n\t\t       snod->offs, snod->len);\n\t\tubifs_dump_node(c, snod->node, c->leb_size - snod->offs);\n\t}\n\n\tpr_err(\"(pid %d) finish dumping LEB %d\\n\", current->pid, lnum);\n\tubifs_scan_destroy(sleb);\n\nout:\n\tvfree(buf);\n\treturn;\n}\n\nvoid ubifs_dump_znode(const struct ubifs_info *c,\n\t\t      const struct ubifs_znode *znode)\n{\n\tint n;\n\tconst struct ubifs_zbranch *zbr;\n\tchar key_buf[DBG_KEY_BUF_LEN];\n\n\tspin_lock(&dbg_lock);\n\tif (znode->parent)\n\t\tzbr = &znode->parent->zbranch[znode->iip];\n\telse\n\t\tzbr = &c->zroot;\n\n\tpr_err(\"znode %p, LEB %d:%d len %d parent %p iip %d level %d child_cnt %d flags %lx\\n\",\n\t       znode, zbr->lnum, zbr->offs, zbr->len, znode->parent, znode->iip,\n\t       znode->level, znode->child_cnt, znode->flags);\n\n\tif (znode->child_cnt <= 0 || znode->child_cnt > c->fanout) {\n\t\tspin_unlock(&dbg_lock);\n\t\treturn;\n\t}\n\n\tpr_err(\"zbranches:\\n\");\n\tfor (n = 0; n < znode->child_cnt; n++) {\n\t\tzbr = &znode->zbranch[n];\n\t\tif (znode->level > 0)\n\t\t\tpr_err(\"\\t%d: znode %p LEB %d:%d len %d key %s\\n\",\n\t\t\t       n, zbr->znode, zbr->lnum, zbr->offs, zbr->len,\n\t\t\t       dbg_snprintf_key(c, &zbr->key, key_buf,\n\t\t\t\t\t\tDBG_KEY_BUF_LEN));\n\t\telse\n\t\t\tpr_err(\"\\t%d: LNC %p LEB %d:%d len %d key %s\\n\",\n\t\t\t       n, zbr->znode, zbr->lnum, zbr->offs, zbr->len,\n\t\t\t       dbg_snprintf_key(c, &zbr->key, key_buf,\n\t\t\t\t\t\tDBG_KEY_BUF_LEN));\n\t}\n\tspin_unlock(&dbg_lock);\n}\n\nvoid ubifs_dump_heap(struct ubifs_info *c, struct ubifs_lpt_heap *heap, int cat)\n{\n\tint i;\n\n\tpr_err(\"(pid %d) start dumping heap cat %d (%d elements)\\n\",\n\t       current->pid, cat, heap->cnt);\n\tfor (i = 0; i < heap->cnt; i++) {\n\t\tstruct ubifs_lprops *lprops = heap->arr[i];\n\n\t\tpr_err(\"\\t%d. LEB %d hpos %d free %d dirty %d flags %d\\n\",\n\t\t       i, lprops->lnum, lprops->hpos, lprops->free,\n\t\t       lprops->dirty, lprops->flags);\n\t}\n\tpr_err(\"(pid %d) finish dumping heap\\n\", current->pid);\n}\n\nvoid ubifs_dump_pnode(struct ubifs_info *c, struct ubifs_pnode *pnode,\n\t\t      struct ubifs_nnode *parent, int iip)\n{\n\tint i;\n\n\tpr_err(\"(pid %d) dumping pnode:\\n\", current->pid);\n\tpr_err(\"\\taddress %zx parent %zx cnext %zx\\n\",\n\t       (size_t)pnode, (size_t)parent, (size_t)pnode->cnext);\n\tpr_err(\"\\tflags %lu iip %d level %d num %d\\n\",\n\t       pnode->flags, iip, pnode->level, pnode->num);\n\tfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\n\t\tstruct ubifs_lprops *lp = &pnode->lprops[i];\n\n\t\tpr_err(\"\\t%d: free %d dirty %d flags %d lnum %d\\n\",\n\t\t       i, lp->free, lp->dirty, lp->flags, lp->lnum);\n\t}\n}\n\nvoid ubifs_dump_tnc(struct ubifs_info *c)\n{\n\tstruct ubifs_znode *znode;\n\tint level;\n\n\tpr_err(\"\\n\");\n\tpr_err(\"(pid %d) start dumping TNC tree\\n\", current->pid);\n\tznode = ubifs_tnc_levelorder_next(c, c->zroot.znode, NULL);\n\tlevel = znode->level;\n\tpr_err(\"== Level %d ==\\n\", level);\n\twhile (znode) {\n\t\tif (level != znode->level) {\n\t\t\tlevel = znode->level;\n\t\t\tpr_err(\"== Level %d ==\\n\", level);\n\t\t}\n\t\tubifs_dump_znode(c, znode);\n\t\tznode = ubifs_tnc_levelorder_next(c, c->zroot.znode, znode);\n\t}\n\tpr_err(\"(pid %d) finish dumping TNC tree\\n\", current->pid);\n}\n\nstatic int dump_znode(struct ubifs_info *c, struct ubifs_znode *znode,\n\t\t      void *priv)\n{\n\tubifs_dump_znode(c, znode);\n\treturn 0;\n}\n\n \nvoid ubifs_dump_index(struct ubifs_info *c)\n{\n\tdbg_walk_index(c, NULL, dump_znode, NULL);\n}\n\n \nvoid dbg_save_space_info(struct ubifs_info *c)\n{\n\tstruct ubifs_debug_info *d = c->dbg;\n\tint freeable_cnt;\n\n\tspin_lock(&c->space_lock);\n\tmemcpy(&d->saved_lst, &c->lst, sizeof(struct ubifs_lp_stats));\n\tmemcpy(&d->saved_bi, &c->bi, sizeof(struct ubifs_budg_info));\n\td->saved_idx_gc_cnt = c->idx_gc_cnt;\n\n\t \n\tfreeable_cnt = c->freeable_cnt;\n\tc->freeable_cnt = 0;\n\td->saved_free = ubifs_get_free_space_nolock(c);\n\tc->freeable_cnt = freeable_cnt;\n\tspin_unlock(&c->space_lock);\n}\n\n \nint dbg_check_space_info(struct ubifs_info *c)\n{\n\tstruct ubifs_debug_info *d = c->dbg;\n\tstruct ubifs_lp_stats lst;\n\tlong long free;\n\tint freeable_cnt;\n\n\tspin_lock(&c->space_lock);\n\tfreeable_cnt = c->freeable_cnt;\n\tc->freeable_cnt = 0;\n\tfree = ubifs_get_free_space_nolock(c);\n\tc->freeable_cnt = freeable_cnt;\n\tspin_unlock(&c->space_lock);\n\n\tif (free != d->saved_free) {\n\t\tubifs_err(c, \"free space changed from %lld to %lld\",\n\t\t\t  d->saved_free, free);\n\t\tgoto out;\n\t}\n\n\treturn 0;\n\nout:\n\tubifs_msg(c, \"saved lprops statistics dump\");\n\tubifs_dump_lstats(&d->saved_lst);\n\tubifs_msg(c, \"saved budgeting info dump\");\n\tubifs_dump_budg(c, &d->saved_bi);\n\tubifs_msg(c, \"saved idx_gc_cnt %d\", d->saved_idx_gc_cnt);\n\tubifs_msg(c, \"current lprops statistics dump\");\n\tubifs_get_lp_stats(c, &lst);\n\tubifs_dump_lstats(&lst);\n\tubifs_msg(c, \"current budgeting info dump\");\n\tubifs_dump_budg(c, &c->bi);\n\tdump_stack();\n\treturn -EINVAL;\n}\n\n \nint dbg_check_synced_i_size(const struct ubifs_info *c, struct inode *inode)\n{\n\tint err = 0;\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\n\tif (!dbg_is_chk_gen(c))\n\t\treturn 0;\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 0;\n\n\tmutex_lock(&ui->ui_mutex);\n\tspin_lock(&ui->ui_lock);\n\tif (ui->ui_size != ui->synced_i_size && !ui->dirty) {\n\t\tubifs_err(c, \"ui_size is %lld, synced_i_size is %lld, but inode is clean\",\n\t\t\t  ui->ui_size, ui->synced_i_size);\n\t\tubifs_err(c, \"i_ino %lu, i_mode %#x, i_size %lld\", inode->i_ino,\n\t\t\t  inode->i_mode, i_size_read(inode));\n\t\tdump_stack();\n\t\terr = -EINVAL;\n\t}\n\tspin_unlock(&ui->ui_lock);\n\tmutex_unlock(&ui->ui_mutex);\n\treturn err;\n}\n\n \nint dbg_check_dir(struct ubifs_info *c, const struct inode *dir)\n{\n\tunsigned int nlink = 2;\n\tunion ubifs_key key;\n\tstruct ubifs_dent_node *dent, *pdent = NULL;\n\tstruct fscrypt_name nm = {0};\n\tloff_t size = UBIFS_INO_NODE_SZ;\n\n\tif (!dbg_is_chk_gen(c))\n\t\treturn 0;\n\n\tif (!S_ISDIR(dir->i_mode))\n\t\treturn 0;\n\n\tlowest_dent_key(c, &key, dir->i_ino);\n\twhile (1) {\n\t\tint err;\n\n\t\tdent = ubifs_tnc_next_ent(c, &key, &nm);\n\t\tif (IS_ERR(dent)) {\n\t\t\terr = PTR_ERR(dent);\n\t\t\tif (err == -ENOENT)\n\t\t\t\tbreak;\n\t\t\tkfree(pdent);\n\t\t\treturn err;\n\t\t}\n\n\t\tfname_name(&nm) = dent->name;\n\t\tfname_len(&nm) = le16_to_cpu(dent->nlen);\n\t\tsize += CALC_DENT_SIZE(fname_len(&nm));\n\t\tif (dent->type == UBIFS_ITYPE_DIR)\n\t\t\tnlink += 1;\n\t\tkfree(pdent);\n\t\tpdent = dent;\n\t\tkey_read(c, &dent->key, &key);\n\t}\n\tkfree(pdent);\n\n\tif (i_size_read(dir) != size) {\n\t\tubifs_err(c, \"directory inode %lu has size %llu, but calculated size is %llu\",\n\t\t\t  dir->i_ino, (unsigned long long)i_size_read(dir),\n\t\t\t  (unsigned long long)size);\n\t\tubifs_dump_inode(c, dir);\n\t\tdump_stack();\n\t\treturn -EINVAL;\n\t}\n\tif (dir->i_nlink != nlink) {\n\t\tubifs_err(c, \"directory inode %lu has nlink %u, but calculated nlink is %u\",\n\t\t\t  dir->i_ino, dir->i_nlink, nlink);\n\t\tubifs_dump_inode(c, dir);\n\t\tdump_stack();\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int dbg_check_key_order(struct ubifs_info *c, struct ubifs_zbranch *zbr1,\n\t\t\t       struct ubifs_zbranch *zbr2)\n{\n\tint err, nlen1, nlen2, cmp;\n\tstruct ubifs_dent_node *dent1, *dent2;\n\tunion ubifs_key key;\n\tchar key_buf[DBG_KEY_BUF_LEN];\n\n\tubifs_assert(c, !keys_cmp(c, &zbr1->key, &zbr2->key));\n\tdent1 = kmalloc(UBIFS_MAX_DENT_NODE_SZ, GFP_NOFS);\n\tif (!dent1)\n\t\treturn -ENOMEM;\n\tdent2 = kmalloc(UBIFS_MAX_DENT_NODE_SZ, GFP_NOFS);\n\tif (!dent2) {\n\t\terr = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\terr = ubifs_tnc_read_node(c, zbr1, dent1);\n\tif (err)\n\t\tgoto out_free;\n\terr = ubifs_validate_entry(c, dent1);\n\tif (err)\n\t\tgoto out_free;\n\n\terr = ubifs_tnc_read_node(c, zbr2, dent2);\n\tif (err)\n\t\tgoto out_free;\n\terr = ubifs_validate_entry(c, dent2);\n\tif (err)\n\t\tgoto out_free;\n\n\t \n\terr = 1;\n\tkey_read(c, &dent1->key, &key);\n\tif (keys_cmp(c, &zbr1->key, &key)) {\n\t\tubifs_err(c, \"1st entry at %d:%d has key %s\", zbr1->lnum,\n\t\t\t  zbr1->offs, dbg_snprintf_key(c, &key, key_buf,\n\t\t\t\t\t\t       DBG_KEY_BUF_LEN));\n\t\tubifs_err(c, \"but it should have key %s according to tnc\",\n\t\t\t  dbg_snprintf_key(c, &zbr1->key, key_buf,\n\t\t\t\t\t   DBG_KEY_BUF_LEN));\n\t\tubifs_dump_node(c, dent1, UBIFS_MAX_DENT_NODE_SZ);\n\t\tgoto out_free;\n\t}\n\n\tkey_read(c, &dent2->key, &key);\n\tif (keys_cmp(c, &zbr2->key, &key)) {\n\t\tubifs_err(c, \"2nd entry at %d:%d has key %s\", zbr1->lnum,\n\t\t\t  zbr1->offs, dbg_snprintf_key(c, &key, key_buf,\n\t\t\t\t\t\t       DBG_KEY_BUF_LEN));\n\t\tubifs_err(c, \"but it should have key %s according to tnc\",\n\t\t\t  dbg_snprintf_key(c, &zbr2->key, key_buf,\n\t\t\t\t\t   DBG_KEY_BUF_LEN));\n\t\tubifs_dump_node(c, dent2, UBIFS_MAX_DENT_NODE_SZ);\n\t\tgoto out_free;\n\t}\n\n\tnlen1 = le16_to_cpu(dent1->nlen);\n\tnlen2 = le16_to_cpu(dent2->nlen);\n\n\tcmp = memcmp(dent1->name, dent2->name, min_t(int, nlen1, nlen2));\n\tif (cmp < 0 || (cmp == 0 && nlen1 < nlen2)) {\n\t\terr = 0;\n\t\tgoto out_free;\n\t}\n\tif (cmp == 0 && nlen1 == nlen2)\n\t\tubifs_err(c, \"2 xent/dent nodes with the same name\");\n\telse\n\t\tubifs_err(c, \"bad order of colliding key %s\",\n\t\t\t  dbg_snprintf_key(c, &key, key_buf, DBG_KEY_BUF_LEN));\n\n\tubifs_msg(c, \"first node at %d:%d\\n\", zbr1->lnum, zbr1->offs);\n\tubifs_dump_node(c, dent1, UBIFS_MAX_DENT_NODE_SZ);\n\tubifs_msg(c, \"second node at %d:%d\\n\", zbr2->lnum, zbr2->offs);\n\tubifs_dump_node(c, dent2, UBIFS_MAX_DENT_NODE_SZ);\n\nout_free:\n\tkfree(dent2);\n\tkfree(dent1);\n\treturn err;\n}\n\n \nstatic int dbg_check_znode(struct ubifs_info *c, struct ubifs_zbranch *zbr)\n{\n\tstruct ubifs_znode *znode = zbr->znode;\n\tstruct ubifs_znode *zp = znode->parent;\n\tint n, err, cmp;\n\n\tif (znode->child_cnt <= 0 || znode->child_cnt > c->fanout) {\n\t\terr = 1;\n\t\tgoto out;\n\t}\n\tif (znode->level < 0) {\n\t\terr = 2;\n\t\tgoto out;\n\t}\n\tif (znode->iip < 0 || znode->iip >= c->fanout) {\n\t\terr = 3;\n\t\tgoto out;\n\t}\n\n\tif (zbr->len == 0)\n\t\t \n\t\tif (!ubifs_zn_dirty(znode)) {\n\t\t\terr = 4;\n\t\t\tgoto out;\n\t\t}\n\n\tif (ubifs_zn_dirty(znode)) {\n\t\t \n\t\tsmp_mb();\n\t\tif (zp && !ubifs_zn_dirty(zp)) {\n\t\t\t \n\t\t\tsmp_mb();\n\t\t\tif (ubifs_zn_dirty(znode)) {\n\t\t\t\terr = 5;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (zp) {\n\t\tconst union ubifs_key *min, *max;\n\n\t\tif (znode->level != zp->level - 1) {\n\t\t\terr = 6;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\terr = ubifs_search_zbranch(c, zp, &zbr->key, &n);\n\t\tif (!err) {\n\t\t\t \n\t\t\terr = 7;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (znode->iip >= zp->child_cnt) {\n\t\t\terr = 8;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (znode->iip != n) {\n\t\t\t \n\t\t\tif (keys_cmp(c, &zp->zbranch[n].key,\n\t\t\t\t     &zp->zbranch[znode->iip].key)) {\n\t\t\t\terr = 9;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tn = znode->iip;\n\t\t}\n\n\t\t \n\t\tmin = &zbr->key;\n\t\tcmp = keys_cmp(c, min, &znode->zbranch[0].key);\n\t\tif (cmp == 1) {\n\t\t\terr = 10;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (n + 1 < zp->child_cnt) {\n\t\t\tmax = &zp->zbranch[n + 1].key;\n\n\t\t\t \n\t\t\tcmp = keys_cmp(c, max,\n\t\t\t\t&znode->zbranch[znode->child_cnt - 1].key);\n\t\t\tif (cmp == -1) {\n\t\t\t\terr = 11;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\tif (zbr != &c->zroot) {\n\t\t\terr = 12;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tfor (n = 1; n < znode->child_cnt; n++) {\n\t\tcmp = keys_cmp(c, &znode->zbranch[n - 1].key,\n\t\t\t       &znode->zbranch[n].key);\n\t\tif (cmp > 0) {\n\t\t\terr = 13;\n\t\t\tgoto out;\n\t\t}\n\t\tif (cmp == 0) {\n\t\t\t \n\t\t\tif (!is_hash_key(c, &znode->zbranch[n].key)) {\n\t\t\t\terr = 14;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (znode->level != 0 || c->replaying)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\terr = dbg_check_key_order(c, &znode->zbranch[n - 1],\n\t\t\t\t\t\t  &znode->zbranch[n]);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tif (err) {\n\t\t\t\terr = 15;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (n = 0; n < znode->child_cnt; n++) {\n\t\tif (!znode->zbranch[n].znode &&\n\t\t    (znode->zbranch[n].lnum == 0 ||\n\t\t     znode->zbranch[n].len == 0)) {\n\t\t\terr = 16;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (znode->zbranch[n].lnum != 0 &&\n\t\t    znode->zbranch[n].len == 0) {\n\t\t\terr = 17;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (znode->zbranch[n].lnum == 0 &&\n\t\t    znode->zbranch[n].len != 0) {\n\t\t\terr = 18;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (znode->zbranch[n].lnum == 0 &&\n\t\t    znode->zbranch[n].offs != 0) {\n\t\t\terr = 19;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (znode->level != 0 && znode->zbranch[n].znode)\n\t\t\tif (znode->zbranch[n].znode->parent != znode) {\n\t\t\t\terr = 20;\n\t\t\t\tgoto out;\n\t\t\t}\n\t}\n\n\treturn 0;\n\nout:\n\tubifs_err(c, \"failed, error %d\", err);\n\tubifs_msg(c, \"dump of the znode\");\n\tubifs_dump_znode(c, znode);\n\tif (zp) {\n\t\tubifs_msg(c, \"dump of the parent znode\");\n\t\tubifs_dump_znode(c, zp);\n\t}\n\tdump_stack();\n\treturn -EINVAL;\n}\n\n \nint dbg_check_tnc(struct ubifs_info *c, int extra)\n{\n\tstruct ubifs_znode *znode;\n\tlong clean_cnt = 0, dirty_cnt = 0;\n\tint err, last;\n\n\tif (!dbg_is_chk_index(c))\n\t\treturn 0;\n\n\tubifs_assert(c, mutex_is_locked(&c->tnc_mutex));\n\tif (!c->zroot.znode)\n\t\treturn 0;\n\n\tznode = ubifs_tnc_postorder_first(c->zroot.znode);\n\twhile (1) {\n\t\tstruct ubifs_znode *prev;\n\t\tstruct ubifs_zbranch *zbr;\n\n\t\tif (!znode->parent)\n\t\t\tzbr = &c->zroot;\n\t\telse\n\t\t\tzbr = &znode->parent->zbranch[znode->iip];\n\n\t\terr = dbg_check_znode(c, zbr);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (extra) {\n\t\t\tif (ubifs_zn_dirty(znode))\n\t\t\t\tdirty_cnt += 1;\n\t\t\telse\n\t\t\t\tclean_cnt += 1;\n\t\t}\n\n\t\tprev = znode;\n\t\tznode = ubifs_tnc_postorder_next(c, znode);\n\t\tif (!znode)\n\t\t\tbreak;\n\n\t\t \n\t\tlast = prev->child_cnt - 1;\n\t\tif (prev->level == 0 && znode->level == 0 && !c->replaying &&\n\t\t    !keys_cmp(c, &prev->zbranch[last].key,\n\t\t\t      &znode->zbranch[0].key)) {\n\t\t\terr = dbg_check_key_order(c, &prev->zbranch[last],\n\t\t\t\t\t\t  &znode->zbranch[0]);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tif (err) {\n\t\t\t\tubifs_msg(c, \"first znode\");\n\t\t\t\tubifs_dump_znode(c, prev);\n\t\t\t\tubifs_msg(c, \"second znode\");\n\t\t\t\tubifs_dump_znode(c, znode);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (extra) {\n\t\tif (clean_cnt != atomic_long_read(&c->clean_zn_cnt)) {\n\t\t\tubifs_err(c, \"incorrect clean_zn_cnt %ld, calculated %ld\",\n\t\t\t\t  atomic_long_read(&c->clean_zn_cnt),\n\t\t\t\t  clean_cnt);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (dirty_cnt != atomic_long_read(&c->dirty_zn_cnt)) {\n\t\t\tubifs_err(c, \"incorrect dirty_zn_cnt %ld, calculated %ld\",\n\t\t\t\t  atomic_long_read(&c->dirty_zn_cnt),\n\t\t\t\t  dirty_cnt);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nint dbg_walk_index(struct ubifs_info *c, dbg_leaf_callback leaf_cb,\n\t\t   dbg_znode_callback znode_cb, void *priv)\n{\n\tint err;\n\tstruct ubifs_zbranch *zbr;\n\tstruct ubifs_znode *znode, *child;\n\n\tmutex_lock(&c->tnc_mutex);\n\t \n\tif (!c->zroot.znode) {\n\t\tc->zroot.znode = ubifs_load_znode(c, &c->zroot, NULL, 0);\n\t\tif (IS_ERR(c->zroot.znode)) {\n\t\t\terr = PTR_ERR(c->zroot.znode);\n\t\t\tc->zroot.znode = NULL;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t \n\tznode = c->zroot.znode;\n\twhile (znode->level > 0) {\n\t\tzbr = &znode->zbranch[0];\n\t\tchild = zbr->znode;\n\t\tif (!child) {\n\t\t\tchild = ubifs_load_znode(c, zbr, znode, 0);\n\t\t\tif (IS_ERR(child)) {\n\t\t\t\terr = PTR_ERR(child);\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t}\n\n\t\tznode = child;\n\t}\n\n\t \n\twhile (1) {\n\t\tint idx;\n\n\t\tcond_resched();\n\n\t\tif (znode_cb) {\n\t\t\terr = znode_cb(c, znode, priv);\n\t\t\tif (err) {\n\t\t\t\tubifs_err(c, \"znode checking function returned error %d\",\n\t\t\t\t\t  err);\n\t\t\t\tubifs_dump_znode(c, znode);\n\t\t\t\tgoto out_dump;\n\t\t\t}\n\t\t}\n\t\tif (leaf_cb && znode->level == 0) {\n\t\t\tfor (idx = 0; idx < znode->child_cnt; idx++) {\n\t\t\t\tzbr = &znode->zbranch[idx];\n\t\t\t\terr = leaf_cb(c, zbr, priv);\n\t\t\t\tif (err) {\n\t\t\t\t\tubifs_err(c, \"leaf checking function returned error %d, for leaf at LEB %d:%d\",\n\t\t\t\t\t\t  err, zbr->lnum, zbr->offs);\n\t\t\t\t\tgoto out_dump;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!znode->parent)\n\t\t\tbreak;\n\n\t\tidx = znode->iip + 1;\n\t\tznode = znode->parent;\n\t\tif (idx < znode->child_cnt) {\n\t\t\t \n\t\t\tzbr = &znode->zbranch[idx];\n\t\t\tchild = zbr->znode;\n\t\t\tif (!child) {\n\t\t\t\tchild = ubifs_load_znode(c, zbr, znode, idx);\n\t\t\t\tif (IS_ERR(child)) {\n\t\t\t\t\terr = PTR_ERR(child);\n\t\t\t\t\tgoto out_unlock;\n\t\t\t\t}\n\t\t\t\tzbr->znode = child;\n\t\t\t}\n\t\t\tznode = child;\n\t\t} else\n\t\t\t \n\t\t\tcontinue;\n\n\t\t \n\t\twhile (znode->level > 0) {\n\t\t\tzbr = &znode->zbranch[0];\n\t\t\tchild = zbr->znode;\n\t\t\tif (!child) {\n\t\t\t\tchild = ubifs_load_znode(c, zbr, znode, 0);\n\t\t\t\tif (IS_ERR(child)) {\n\t\t\t\t\terr = PTR_ERR(child);\n\t\t\t\t\tgoto out_unlock;\n\t\t\t\t}\n\t\t\t\tzbr->znode = child;\n\t\t\t}\n\t\t\tznode = child;\n\t\t}\n\t}\n\n\tmutex_unlock(&c->tnc_mutex);\n\treturn 0;\n\nout_dump:\n\tif (znode->parent)\n\t\tzbr = &znode->parent->zbranch[znode->iip];\n\telse\n\t\tzbr = &c->zroot;\n\tubifs_msg(c, \"dump of znode at LEB %d:%d\", zbr->lnum, zbr->offs);\n\tubifs_dump_znode(c, znode);\nout_unlock:\n\tmutex_unlock(&c->tnc_mutex);\n\treturn err;\n}\n\n \nstatic int add_size(struct ubifs_info *c, struct ubifs_znode *znode, void *priv)\n{\n\tlong long *idx_size = priv;\n\tint add;\n\n\tadd = ubifs_idx_node_sz(c, znode->child_cnt);\n\tadd = ALIGN(add, 8);\n\t*idx_size += add;\n\treturn 0;\n}\n\n \nint dbg_check_idx_size(struct ubifs_info *c, long long idx_size)\n{\n\tint err;\n\tlong long calc = 0;\n\n\tif (!dbg_is_chk_index(c))\n\t\treturn 0;\n\n\terr = dbg_walk_index(c, NULL, add_size, &calc);\n\tif (err) {\n\t\tubifs_err(c, \"error %d while walking the index\", err);\n\t\treturn err;\n\t}\n\n\tif (calc != idx_size) {\n\t\tubifs_err(c, \"index size check failed: calculated size is %lld, should be %lld\",\n\t\t\t  calc, idx_size);\n\t\tdump_stack();\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstruct fsck_inode {\n\tstruct rb_node rb;\n\tino_t inum;\n\tumode_t mode;\n\tunsigned int nlink;\n\tunsigned int xattr_cnt;\n\tint references;\n\tint calc_cnt;\n\tlong long size;\n\tunsigned int xattr_sz;\n\tlong long calc_sz;\n\tlong long calc_xcnt;\n\tlong long calc_xsz;\n\tunsigned int xattr_nms;\n\tlong long calc_xnms;\n};\n\n \nstruct fsck_data {\n\tstruct rb_root inodes;\n};\n\n \nstatic struct fsck_inode *add_inode(struct ubifs_info *c,\n\t\t\t\t    struct fsck_data *fsckd,\n\t\t\t\t    struct ubifs_ino_node *ino)\n{\n\tstruct rb_node **p, *parent = NULL;\n\tstruct fsck_inode *fscki;\n\tino_t inum = key_inum_flash(c, &ino->key);\n\tstruct inode *inode;\n\tstruct ubifs_inode *ui;\n\n\tp = &fsckd->inodes.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\tfscki = rb_entry(parent, struct fsck_inode, rb);\n\t\tif (inum < fscki->inum)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (inum > fscki->inum)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn fscki;\n\t}\n\n\tif (inum > c->highest_inum) {\n\t\tubifs_err(c, \"too high inode number, max. is %lu\",\n\t\t\t  (unsigned long)c->highest_inum);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tfscki = kzalloc(sizeof(struct fsck_inode), GFP_NOFS);\n\tif (!fscki)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinode = ilookup(c->vfs_sb, inum);\n\n\tfscki->inum = inum;\n\t \n\tif (!inode) {\n\t\tfscki->nlink = le32_to_cpu(ino->nlink);\n\t\tfscki->size = le64_to_cpu(ino->size);\n\t\tfscki->xattr_cnt = le32_to_cpu(ino->xattr_cnt);\n\t\tfscki->xattr_sz = le32_to_cpu(ino->xattr_size);\n\t\tfscki->xattr_nms = le32_to_cpu(ino->xattr_names);\n\t\tfscki->mode = le32_to_cpu(ino->mode);\n\t} else {\n\t\tui = ubifs_inode(inode);\n\t\tfscki->nlink = inode->i_nlink;\n\t\tfscki->size = inode->i_size;\n\t\tfscki->xattr_cnt = ui->xattr_cnt;\n\t\tfscki->xattr_sz = ui->xattr_size;\n\t\tfscki->xattr_nms = ui->xattr_names;\n\t\tfscki->mode = inode->i_mode;\n\t\tiput(inode);\n\t}\n\n\tif (S_ISDIR(fscki->mode)) {\n\t\tfscki->calc_sz = UBIFS_INO_NODE_SZ;\n\t\tfscki->calc_cnt = 2;\n\t}\n\n\trb_link_node(&fscki->rb, parent, p);\n\trb_insert_color(&fscki->rb, &fsckd->inodes);\n\n\treturn fscki;\n}\n\n \nstatic struct fsck_inode *search_inode(struct fsck_data *fsckd, ino_t inum)\n{\n\tstruct rb_node *p;\n\tstruct fsck_inode *fscki;\n\n\tp = fsckd->inodes.rb_node;\n\twhile (p) {\n\t\tfscki = rb_entry(p, struct fsck_inode, rb);\n\t\tif (inum < fscki->inum)\n\t\t\tp = p->rb_left;\n\t\telse if (inum > fscki->inum)\n\t\t\tp = p->rb_right;\n\t\telse\n\t\t\treturn fscki;\n\t}\n\treturn NULL;\n}\n\n \nstatic struct fsck_inode *read_add_inode(struct ubifs_info *c,\n\t\t\t\t\t struct fsck_data *fsckd, ino_t inum)\n{\n\tint n, err;\n\tunion ubifs_key key;\n\tstruct ubifs_znode *znode;\n\tstruct ubifs_zbranch *zbr;\n\tstruct ubifs_ino_node *ino;\n\tstruct fsck_inode *fscki;\n\n\tfscki = search_inode(fsckd, inum);\n\tif (fscki)\n\t\treturn fscki;\n\n\tino_key_init(c, &key, inum);\n\terr = ubifs_lookup_level0(c, &key, &znode, &n);\n\tif (!err) {\n\t\tubifs_err(c, \"inode %lu not found in index\", (unsigned long)inum);\n\t\treturn ERR_PTR(-ENOENT);\n\t} else if (err < 0) {\n\t\tubifs_err(c, \"error %d while looking up inode %lu\",\n\t\t\t  err, (unsigned long)inum);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tzbr = &znode->zbranch[n];\n\tif (zbr->len < UBIFS_INO_NODE_SZ) {\n\t\tubifs_err(c, \"bad node %lu node length %d\",\n\t\t\t  (unsigned long)inum, zbr->len);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tino = kmalloc(zbr->len, GFP_NOFS);\n\tif (!ino)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = ubifs_tnc_read_node(c, zbr, ino);\n\tif (err) {\n\t\tubifs_err(c, \"cannot read inode node at LEB %d:%d, error %d\",\n\t\t\t  zbr->lnum, zbr->offs, err);\n\t\tkfree(ino);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tfscki = add_inode(c, fsckd, ino);\n\tkfree(ino);\n\tif (IS_ERR(fscki)) {\n\t\tubifs_err(c, \"error %ld while adding inode %lu node\",\n\t\t\t  PTR_ERR(fscki), (unsigned long)inum);\n\t\treturn fscki;\n\t}\n\n\treturn fscki;\n}\n\n \nstatic int check_leaf(struct ubifs_info *c, struct ubifs_zbranch *zbr,\n\t\t      void *priv)\n{\n\tino_t inum;\n\tvoid *node;\n\tstruct ubifs_ch *ch;\n\tint err, type = key_type(c, &zbr->key);\n\tstruct fsck_inode *fscki;\n\n\tif (zbr->len < UBIFS_CH_SZ) {\n\t\tubifs_err(c, \"bad leaf length %d (LEB %d:%d)\",\n\t\t\t  zbr->len, zbr->lnum, zbr->offs);\n\t\treturn -EINVAL;\n\t}\n\n\tnode = kmalloc(zbr->len, GFP_NOFS);\n\tif (!node)\n\t\treturn -ENOMEM;\n\n\terr = ubifs_tnc_read_node(c, zbr, node);\n\tif (err) {\n\t\tubifs_err(c, \"cannot read leaf node at LEB %d:%d, error %d\",\n\t\t\t  zbr->lnum, zbr->offs, err);\n\t\tgoto out_free;\n\t}\n\n\t \n\tif (type == UBIFS_INO_KEY) {\n\t\tfscki = add_inode(c, priv, node);\n\t\tif (IS_ERR(fscki)) {\n\t\t\terr = PTR_ERR(fscki);\n\t\t\tubifs_err(c, \"error %d while adding inode node\", err);\n\t\t\tgoto out_dump;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tif (type != UBIFS_DENT_KEY && type != UBIFS_XENT_KEY &&\n\t    type != UBIFS_DATA_KEY) {\n\t\tubifs_err(c, \"unexpected node type %d at LEB %d:%d\",\n\t\t\t  type, zbr->lnum, zbr->offs);\n\t\terr = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\tch = node;\n\tif (le64_to_cpu(ch->sqnum) > c->max_sqnum) {\n\t\tubifs_err(c, \"too high sequence number, max. is %llu\",\n\t\t\t  c->max_sqnum);\n\t\terr = -EINVAL;\n\t\tgoto out_dump;\n\t}\n\n\tif (type == UBIFS_DATA_KEY) {\n\t\tlong long blk_offs;\n\t\tstruct ubifs_data_node *dn = node;\n\n\t\tubifs_assert(c, zbr->len >= UBIFS_DATA_NODE_SZ);\n\n\t\t \n\t\tinum = key_inum_flash(c, &dn->key);\n\t\tfscki = read_add_inode(c, priv, inum);\n\t\tif (IS_ERR(fscki)) {\n\t\t\terr = PTR_ERR(fscki);\n\t\t\tubifs_err(c, \"error %d while processing data node and trying to find inode node %lu\",\n\t\t\t\t  err, (unsigned long)inum);\n\t\t\tgoto out_dump;\n\t\t}\n\n\t\t \n\t\tblk_offs = key_block_flash(c, &dn->key);\n\t\tblk_offs <<= UBIFS_BLOCK_SHIFT;\n\t\tblk_offs += le32_to_cpu(dn->size);\n\t\tif (blk_offs > fscki->size) {\n\t\t\tubifs_err(c, \"data node at LEB %d:%d is not within inode size %lld\",\n\t\t\t\t  zbr->lnum, zbr->offs, fscki->size);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_dump;\n\t\t}\n\t} else {\n\t\tint nlen;\n\t\tstruct ubifs_dent_node *dent = node;\n\t\tstruct fsck_inode *fscki1;\n\n\t\tubifs_assert(c, zbr->len >= UBIFS_DENT_NODE_SZ);\n\n\t\terr = ubifs_validate_entry(c, dent);\n\t\tif (err)\n\t\t\tgoto out_dump;\n\n\t\t \n\t\tinum = le64_to_cpu(dent->inum);\n\t\tfscki = read_add_inode(c, priv, inum);\n\t\tif (IS_ERR(fscki)) {\n\t\t\terr = PTR_ERR(fscki);\n\t\t\tubifs_err(c, \"error %d while processing entry node and trying to find inode node %lu\",\n\t\t\t\t  err, (unsigned long)inum);\n\t\t\tgoto out_dump;\n\t\t}\n\n\t\t \n\t\tfscki->references += 1;\n\n\t\tinum = key_inum_flash(c, &dent->key);\n\t\tfscki1 = read_add_inode(c, priv, inum);\n\t\tif (IS_ERR(fscki1)) {\n\t\t\terr = PTR_ERR(fscki1);\n\t\t\tubifs_err(c, \"error %d while processing entry node and trying to find parent inode node %lu\",\n\t\t\t\t  err, (unsigned long)inum);\n\t\t\tgoto out_dump;\n\t\t}\n\n\t\tnlen = le16_to_cpu(dent->nlen);\n\t\tif (type == UBIFS_XENT_KEY) {\n\t\t\tfscki1->calc_xcnt += 1;\n\t\t\tfscki1->calc_xsz += CALC_DENT_SIZE(nlen);\n\t\t\tfscki1->calc_xsz += CALC_XATTR_BYTES(fscki->size);\n\t\t\tfscki1->calc_xnms += nlen;\n\t\t} else {\n\t\t\tfscki1->calc_sz += CALC_DENT_SIZE(nlen);\n\t\t\tif (dent->type == UBIFS_ITYPE_DIR)\n\t\t\t\tfscki1->calc_cnt += 1;\n\t\t}\n\t}\n\nout:\n\tkfree(node);\n\treturn 0;\n\nout_dump:\n\tubifs_msg(c, \"dump of node at LEB %d:%d\", zbr->lnum, zbr->offs);\n\tubifs_dump_node(c, node, zbr->len);\nout_free:\n\tkfree(node);\n\treturn err;\n}\n\n \nstatic void free_inodes(struct fsck_data *fsckd)\n{\n\tstruct fsck_inode *fscki, *n;\n\n\trbtree_postorder_for_each_entry_safe(fscki, n, &fsckd->inodes, rb)\n\t\tkfree(fscki);\n}\n\n \nstatic int check_inodes(struct ubifs_info *c, struct fsck_data *fsckd)\n{\n\tint n, err;\n\tunion ubifs_key key;\n\tstruct ubifs_znode *znode;\n\tstruct ubifs_zbranch *zbr;\n\tstruct ubifs_ino_node *ino;\n\tstruct fsck_inode *fscki;\n\tstruct rb_node *this = rb_first(&fsckd->inodes);\n\n\twhile (this) {\n\t\tfscki = rb_entry(this, struct fsck_inode, rb);\n\t\tthis = rb_next(this);\n\n\t\tif (S_ISDIR(fscki->mode)) {\n\t\t\t \n\t\t\tif (fscki->inum != UBIFS_ROOT_INO &&\n\t\t\t    fscki->references != 1) {\n\t\t\t\tubifs_err(c, \"directory inode %lu has %d direntries which refer it, but should be 1\",\n\t\t\t\t\t  (unsigned long)fscki->inum,\n\t\t\t\t\t  fscki->references);\n\t\t\t\tgoto out_dump;\n\t\t\t}\n\t\t\tif (fscki->inum == UBIFS_ROOT_INO &&\n\t\t\t    fscki->references != 0) {\n\t\t\t\tubifs_err(c, \"root inode %lu has non-zero (%d) direntries which refer it\",\n\t\t\t\t\t  (unsigned long)fscki->inum,\n\t\t\t\t\t  fscki->references);\n\t\t\t\tgoto out_dump;\n\t\t\t}\n\t\t\tif (fscki->calc_sz != fscki->size) {\n\t\t\t\tubifs_err(c, \"directory inode %lu size is %lld, but calculated size is %lld\",\n\t\t\t\t\t  (unsigned long)fscki->inum,\n\t\t\t\t\t  fscki->size, fscki->calc_sz);\n\t\t\t\tgoto out_dump;\n\t\t\t}\n\t\t\tif (fscki->calc_cnt != fscki->nlink) {\n\t\t\t\tubifs_err(c, \"directory inode %lu nlink is %d, but calculated nlink is %d\",\n\t\t\t\t\t  (unsigned long)fscki->inum,\n\t\t\t\t\t  fscki->nlink, fscki->calc_cnt);\n\t\t\t\tgoto out_dump;\n\t\t\t}\n\t\t} else {\n\t\t\tif (fscki->references != fscki->nlink) {\n\t\t\t\tubifs_err(c, \"inode %lu nlink is %d, but calculated nlink is %d\",\n\t\t\t\t\t  (unsigned long)fscki->inum,\n\t\t\t\t\t  fscki->nlink, fscki->references);\n\t\t\t\tgoto out_dump;\n\t\t\t}\n\t\t}\n\t\tif (fscki->xattr_sz != fscki->calc_xsz) {\n\t\t\tubifs_err(c, \"inode %lu has xattr size %u, but calculated size is %lld\",\n\t\t\t\t  (unsigned long)fscki->inum, fscki->xattr_sz,\n\t\t\t\t  fscki->calc_xsz);\n\t\t\tgoto out_dump;\n\t\t}\n\t\tif (fscki->xattr_cnt != fscki->calc_xcnt) {\n\t\t\tubifs_err(c, \"inode %lu has %u xattrs, but calculated count is %lld\",\n\t\t\t\t  (unsigned long)fscki->inum,\n\t\t\t\t  fscki->xattr_cnt, fscki->calc_xcnt);\n\t\t\tgoto out_dump;\n\t\t}\n\t\tif (fscki->xattr_nms != fscki->calc_xnms) {\n\t\t\tubifs_err(c, \"inode %lu has xattr names' size %u, but calculated names' size is %lld\",\n\t\t\t\t  (unsigned long)fscki->inum, fscki->xattr_nms,\n\t\t\t\t  fscki->calc_xnms);\n\t\t\tgoto out_dump;\n\t\t}\n\t}\n\n\treturn 0;\n\nout_dump:\n\t \n\tino_key_init(c, &key, fscki->inum);\n\terr = ubifs_lookup_level0(c, &key, &znode, &n);\n\tif (!err) {\n\t\tubifs_err(c, \"inode %lu not found in index\",\n\t\t\t  (unsigned long)fscki->inum);\n\t\treturn -ENOENT;\n\t} else if (err < 0) {\n\t\tubifs_err(c, \"error %d while looking up inode %lu\",\n\t\t\t  err, (unsigned long)fscki->inum);\n\t\treturn err;\n\t}\n\n\tzbr = &znode->zbranch[n];\n\tino = kmalloc(zbr->len, GFP_NOFS);\n\tif (!ino)\n\t\treturn -ENOMEM;\n\n\terr = ubifs_tnc_read_node(c, zbr, ino);\n\tif (err) {\n\t\tubifs_err(c, \"cannot read inode node at LEB %d:%d, error %d\",\n\t\t\t  zbr->lnum, zbr->offs, err);\n\t\tkfree(ino);\n\t\treturn err;\n\t}\n\n\tubifs_msg(c, \"dump of the inode %lu sitting in LEB %d:%d\",\n\t\t  (unsigned long)fscki->inum, zbr->lnum, zbr->offs);\n\tubifs_dump_node(c, ino, zbr->len);\n\tkfree(ino);\n\treturn -EINVAL;\n}\n\n \nint dbg_check_filesystem(struct ubifs_info *c)\n{\n\tint err;\n\tstruct fsck_data fsckd;\n\n\tif (!dbg_is_chk_fs(c))\n\t\treturn 0;\n\n\tfsckd.inodes = RB_ROOT;\n\terr = dbg_walk_index(c, check_leaf, NULL, &fsckd);\n\tif (err)\n\t\tgoto out_free;\n\n\terr = check_inodes(c, &fsckd);\n\tif (err)\n\t\tgoto out_free;\n\n\tfree_inodes(&fsckd);\n\treturn 0;\n\nout_free:\n\tubifs_err(c, \"file-system check failed with error %d\", err);\n\tdump_stack();\n\tfree_inodes(&fsckd);\n\treturn err;\n}\n\n \nint dbg_check_data_nodes_order(struct ubifs_info *c, struct list_head *head)\n{\n\tstruct list_head *cur;\n\tstruct ubifs_scan_node *sa, *sb;\n\n\tif (!dbg_is_chk_gen(c))\n\t\treturn 0;\n\n\tfor (cur = head->next; cur->next != head; cur = cur->next) {\n\t\tino_t inuma, inumb;\n\t\tuint32_t blka, blkb;\n\n\t\tcond_resched();\n\t\tsa = container_of(cur, struct ubifs_scan_node, list);\n\t\tsb = container_of(cur->next, struct ubifs_scan_node, list);\n\n\t\tif (sa->type != UBIFS_DATA_NODE) {\n\t\t\tubifs_err(c, \"bad node type %d\", sa->type);\n\t\t\tubifs_dump_node(c, sa->node, c->leb_size - sa->offs);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (sb->type != UBIFS_DATA_NODE) {\n\t\t\tubifs_err(c, \"bad node type %d\", sb->type);\n\t\t\tubifs_dump_node(c, sb->node, c->leb_size - sb->offs);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tinuma = key_inum(c, &sa->key);\n\t\tinumb = key_inum(c, &sb->key);\n\n\t\tif (inuma < inumb)\n\t\t\tcontinue;\n\t\tif (inuma > inumb) {\n\t\t\tubifs_err(c, \"larger inum %lu goes before inum %lu\",\n\t\t\t\t  (unsigned long)inuma, (unsigned long)inumb);\n\t\t\tgoto error_dump;\n\t\t}\n\n\t\tblka = key_block(c, &sa->key);\n\t\tblkb = key_block(c, &sb->key);\n\n\t\tif (blka > blkb) {\n\t\t\tubifs_err(c, \"larger block %u goes before %u\", blka, blkb);\n\t\t\tgoto error_dump;\n\t\t}\n\t\tif (blka == blkb) {\n\t\t\tubifs_err(c, \"two data nodes for the same block\");\n\t\t\tgoto error_dump;\n\t\t}\n\t}\n\n\treturn 0;\n\nerror_dump:\n\tubifs_dump_node(c, sa->node, c->leb_size - sa->offs);\n\tubifs_dump_node(c, sb->node, c->leb_size - sb->offs);\n\treturn -EINVAL;\n}\n\n \nint dbg_check_nondata_nodes_order(struct ubifs_info *c, struct list_head *head)\n{\n\tstruct list_head *cur;\n\tstruct ubifs_scan_node *sa, *sb;\n\n\tif (!dbg_is_chk_gen(c))\n\t\treturn 0;\n\n\tfor (cur = head->next; cur->next != head; cur = cur->next) {\n\t\tino_t inuma, inumb;\n\t\tuint32_t hasha, hashb;\n\n\t\tcond_resched();\n\t\tsa = container_of(cur, struct ubifs_scan_node, list);\n\t\tsb = container_of(cur->next, struct ubifs_scan_node, list);\n\n\t\tif (sa->type != UBIFS_INO_NODE && sa->type != UBIFS_DENT_NODE &&\n\t\t    sa->type != UBIFS_XENT_NODE) {\n\t\t\tubifs_err(c, \"bad node type %d\", sa->type);\n\t\t\tubifs_dump_node(c, sa->node, c->leb_size - sa->offs);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (sb->type != UBIFS_INO_NODE && sb->type != UBIFS_DENT_NODE &&\n\t\t    sb->type != UBIFS_XENT_NODE) {\n\t\t\tubifs_err(c, \"bad node type %d\", sb->type);\n\t\t\tubifs_dump_node(c, sb->node, c->leb_size - sb->offs);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (sa->type != UBIFS_INO_NODE && sb->type == UBIFS_INO_NODE) {\n\t\t\tubifs_err(c, \"non-inode node goes before inode node\");\n\t\t\tgoto error_dump;\n\t\t}\n\n\t\tif (sa->type == UBIFS_INO_NODE && sb->type != UBIFS_INO_NODE)\n\t\t\tcontinue;\n\n\t\tif (sa->type == UBIFS_INO_NODE && sb->type == UBIFS_INO_NODE) {\n\t\t\t \n\t\t\tif (sa->len < sb->len) {\n\t\t\t\tubifs_err(c, \"smaller inode node goes first\");\n\t\t\t\tgoto error_dump;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tinuma = key_inum(c, &sa->key);\n\t\tinumb = key_inum(c, &sb->key);\n\n\t\tif (inuma < inumb)\n\t\t\tcontinue;\n\t\tif (inuma > inumb) {\n\t\t\tubifs_err(c, \"larger inum %lu goes before inum %lu\",\n\t\t\t\t  (unsigned long)inuma, (unsigned long)inumb);\n\t\t\tgoto error_dump;\n\t\t}\n\n\t\thasha = key_block(c, &sa->key);\n\t\thashb = key_block(c, &sb->key);\n\n\t\tif (hasha > hashb) {\n\t\t\tubifs_err(c, \"larger hash %u goes before %u\",\n\t\t\t\t  hasha, hashb);\n\t\t\tgoto error_dump;\n\t\t}\n\t}\n\n\treturn 0;\n\nerror_dump:\n\tubifs_msg(c, \"dumping first node\");\n\tubifs_dump_node(c, sa->node, c->leb_size - sa->offs);\n\tubifs_msg(c, \"dumping second node\");\n\tubifs_dump_node(c, sb->node, c->leb_size - sb->offs);\n\treturn -EINVAL;\n}\n\nstatic inline int chance(unsigned int n, unsigned int out_of)\n{\n\treturn !!(get_random_u32_below(out_of) + 1 <= n);\n\n}\n\nstatic int power_cut_emulated(struct ubifs_info *c, int lnum, int write)\n{\n\tstruct ubifs_debug_info *d = c->dbg;\n\n\tubifs_assert(c, dbg_is_tst_rcvry(c));\n\n\tif (!d->pc_cnt) {\n\t\t \n\t\tif (chance(1, 2)) {\n\t\t\tunsigned long delay;\n\n\t\t\tif (chance(1, 2)) {\n\t\t\t\td->pc_delay = 1;\n\t\t\t\t \n\t\t\t\tdelay = get_random_u32_below(60000);\n\t\t\t\td->pc_timeout = jiffies;\n\t\t\t\td->pc_timeout += msecs_to_jiffies(delay);\n\t\t\t\tubifs_warn(c, \"failing after %lums\", delay);\n\t\t\t} else {\n\t\t\t\td->pc_delay = 2;\n\t\t\t\tdelay = get_random_u32_below(10000);\n\t\t\t\t \n\t\t\t\td->pc_cnt_max = delay;\n\t\t\t\tubifs_warn(c, \"failing after %lu calls\", delay);\n\t\t\t}\n\t\t}\n\n\t\td->pc_cnt += 1;\n\t}\n\n\t \n\tif (d->pc_delay == 1 && time_before(jiffies, d->pc_timeout))\n\t\t\treturn 0;\n\tif (d->pc_delay == 2 && d->pc_cnt++ < d->pc_cnt_max)\n\t\t\treturn 0;\n\n\tif (lnum == UBIFS_SB_LNUM) {\n\t\tif (write && chance(1, 2))\n\t\t\treturn 0;\n\t\tif (chance(19, 20))\n\t\t\treturn 0;\n\t\tubifs_warn(c, \"failing in super block LEB %d\", lnum);\n\t} else if (lnum == UBIFS_MST_LNUM || lnum == UBIFS_MST_LNUM + 1) {\n\t\tif (chance(19, 20))\n\t\t\treturn 0;\n\t\tubifs_warn(c, \"failing in master LEB %d\", lnum);\n\t} else if (lnum >= UBIFS_LOG_LNUM && lnum <= c->log_last) {\n\t\tif (write && chance(99, 100))\n\t\t\treturn 0;\n\t\tif (chance(399, 400))\n\t\t\treturn 0;\n\t\tubifs_warn(c, \"failing in log LEB %d\", lnum);\n\t} else if (lnum >= c->lpt_first && lnum <= c->lpt_last) {\n\t\tif (write && chance(7, 8))\n\t\t\treturn 0;\n\t\tif (chance(19, 20))\n\t\t\treturn 0;\n\t\tubifs_warn(c, \"failing in LPT LEB %d\", lnum);\n\t} else if (lnum >= c->orph_first && lnum <= c->orph_last) {\n\t\tif (write && chance(1, 2))\n\t\t\treturn 0;\n\t\tif (chance(9, 10))\n\t\t\treturn 0;\n\t\tubifs_warn(c, \"failing in orphan LEB %d\", lnum);\n\t} else if (lnum == c->ihead_lnum) {\n\t\tif (chance(99, 100))\n\t\t\treturn 0;\n\t\tubifs_warn(c, \"failing in index head LEB %d\", lnum);\n\t} else if (c->jheads && lnum == c->jheads[GCHD].wbuf.lnum) {\n\t\tif (chance(9, 10))\n\t\t\treturn 0;\n\t\tubifs_warn(c, \"failing in GC head LEB %d\", lnum);\n\t} else if (write && !RB_EMPTY_ROOT(&c->buds) &&\n\t\t   !ubifs_search_bud(c, lnum)) {\n\t\tif (chance(19, 20))\n\t\t\treturn 0;\n\t\tubifs_warn(c, \"failing in non-bud LEB %d\", lnum);\n\t} else if (c->cmt_state == COMMIT_RUNNING_BACKGROUND ||\n\t\t   c->cmt_state == COMMIT_RUNNING_REQUIRED) {\n\t\tif (chance(999, 1000))\n\t\t\treturn 0;\n\t\tubifs_warn(c, \"failing in bud LEB %d commit running\", lnum);\n\t} else {\n\t\tif (chance(9999, 10000))\n\t\t\treturn 0;\n\t\tubifs_warn(c, \"failing in bud LEB %d commit not running\", lnum);\n\t}\n\n\td->pc_happened = 1;\n\tubifs_warn(c, \"========== Power cut emulated ==========\");\n\tdump_stack();\n\treturn 1;\n}\n\nstatic int corrupt_data(const struct ubifs_info *c, const void *buf,\n\t\t\tunsigned int len)\n{\n\tunsigned int from, to, ffs = chance(1, 2);\n\tunsigned char *p = (void *)buf;\n\n\tfrom = get_random_u32_below(len);\n\t \n\tto = min(len, ALIGN(from + 1, c->max_write_size));\n\n\tubifs_warn(c, \"filled bytes %u-%u with %s\", from, to - 1,\n\t\t   ffs ? \"0xFFs\" : \"random data\");\n\n\tif (ffs)\n\t\tmemset(p + from, 0xFF, to - from);\n\telse\n\t\tget_random_bytes(p + from, to - from);\n\n\treturn to;\n}\n\nint dbg_leb_write(struct ubifs_info *c, int lnum, const void *buf,\n\t\t  int offs, int len)\n{\n\tint err, failing;\n\n\tif (dbg_is_power_cut(c))\n\t\treturn -EROFS;\n\n\tfailing = power_cut_emulated(c, lnum, 1);\n\tif (failing) {\n\t\tlen = corrupt_data(c, buf, len);\n\t\tubifs_warn(c, \"actually write %d bytes to LEB %d:%d (the buffer was corrupted)\",\n\t\t\t   len, lnum, offs);\n\t}\n\terr = ubi_leb_write(c->ubi, lnum, buf, offs, len);\n\tif (err)\n\t\treturn err;\n\tif (failing)\n\t\treturn -EROFS;\n\treturn 0;\n}\n\nint dbg_leb_change(struct ubifs_info *c, int lnum, const void *buf,\n\t\t   int len)\n{\n\tint err;\n\n\tif (dbg_is_power_cut(c))\n\t\treturn -EROFS;\n\tif (power_cut_emulated(c, lnum, 1))\n\t\treturn -EROFS;\n\terr = ubi_leb_change(c->ubi, lnum, buf, len);\n\tif (err)\n\t\treturn err;\n\tif (power_cut_emulated(c, lnum, 1))\n\t\treturn -EROFS;\n\treturn 0;\n}\n\nint dbg_leb_unmap(struct ubifs_info *c, int lnum)\n{\n\tint err;\n\n\tif (dbg_is_power_cut(c))\n\t\treturn -EROFS;\n\tif (power_cut_emulated(c, lnum, 0))\n\t\treturn -EROFS;\n\terr = ubi_leb_unmap(c->ubi, lnum);\n\tif (err)\n\t\treturn err;\n\tif (power_cut_emulated(c, lnum, 0))\n\t\treturn -EROFS;\n\treturn 0;\n}\n\nint dbg_leb_map(struct ubifs_info *c, int lnum)\n{\n\tint err;\n\n\tif (dbg_is_power_cut(c))\n\t\treturn -EROFS;\n\tif (power_cut_emulated(c, lnum, 0))\n\t\treturn -EROFS;\n\terr = ubi_leb_map(c->ubi, lnum);\n\tif (err)\n\t\treturn err;\n\tif (power_cut_emulated(c, lnum, 0))\n\t\treturn -EROFS;\n\treturn 0;\n}\n\n \nstatic struct dentry *dfs_rootdir;\n\nstatic int dfs_file_open(struct inode *inode, struct file *file)\n{\n\tfile->private_data = inode->i_private;\n\treturn nonseekable_open(inode, file);\n}\n\n \nstatic int provide_user_output(int val, char __user *u, size_t count,\n\t\t\t       loff_t *ppos)\n{\n\tchar buf[3];\n\n\tif (val)\n\t\tbuf[0] = '1';\n\telse\n\t\tbuf[0] = '0';\n\tbuf[1] = '\\n';\n\tbuf[2] = 0x00;\n\n\treturn simple_read_from_buffer(u, count, ppos, buf, 2);\n}\n\nstatic ssize_t dfs_file_read(struct file *file, char __user *u, size_t count,\n\t\t\t     loff_t *ppos)\n{\n\tstruct dentry *dent = file->f_path.dentry;\n\tstruct ubifs_info *c = file->private_data;\n\tstruct ubifs_debug_info *d = c->dbg;\n\tint val;\n\n\tif (dent == d->dfs_chk_gen)\n\t\tval = d->chk_gen;\n\telse if (dent == d->dfs_chk_index)\n\t\tval = d->chk_index;\n\telse if (dent == d->dfs_chk_orph)\n\t\tval = d->chk_orph;\n\telse if (dent == d->dfs_chk_lprops)\n\t\tval = d->chk_lprops;\n\telse if (dent == d->dfs_chk_fs)\n\t\tval = d->chk_fs;\n\telse if (dent == d->dfs_tst_rcvry)\n\t\tval = d->tst_rcvry;\n\telse if (dent == d->dfs_ro_error)\n\t\tval = c->ro_error;\n\telse\n\t\treturn -EINVAL;\n\n\treturn provide_user_output(val, u, count, ppos);\n}\n\n \nstatic int interpret_user_input(const char __user *u, size_t count)\n{\n\tsize_t buf_size;\n\tchar buf[8];\n\n\tbuf_size = min_t(size_t, count, (sizeof(buf) - 1));\n\tif (copy_from_user(buf, u, buf_size))\n\t\treturn -EFAULT;\n\n\tif (buf[0] == '1')\n\t\treturn 1;\n\telse if (buf[0] == '0')\n\t\treturn 0;\n\n\treturn -EINVAL;\n}\n\nstatic ssize_t dfs_file_write(struct file *file, const char __user *u,\n\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct ubifs_info *c = file->private_data;\n\tstruct ubifs_debug_info *d = c->dbg;\n\tstruct dentry *dent = file->f_path.dentry;\n\tint val;\n\n\tif (file->f_path.dentry == d->dfs_dump_lprops) {\n\t\tubifs_dump_lprops(c);\n\t\treturn count;\n\t}\n\tif (file->f_path.dentry == d->dfs_dump_budg) {\n\t\tubifs_dump_budg(c, &c->bi);\n\t\treturn count;\n\t}\n\tif (file->f_path.dentry == d->dfs_dump_tnc) {\n\t\tmutex_lock(&c->tnc_mutex);\n\t\tubifs_dump_tnc(c);\n\t\tmutex_unlock(&c->tnc_mutex);\n\t\treturn count;\n\t}\n\n\tval = interpret_user_input(u, count);\n\tif (val < 0)\n\t\treturn val;\n\n\tif (dent == d->dfs_chk_gen)\n\t\td->chk_gen = val;\n\telse if (dent == d->dfs_chk_index)\n\t\td->chk_index = val;\n\telse if (dent == d->dfs_chk_orph)\n\t\td->chk_orph = val;\n\telse if (dent == d->dfs_chk_lprops)\n\t\td->chk_lprops = val;\n\telse if (dent == d->dfs_chk_fs)\n\t\td->chk_fs = val;\n\telse if (dent == d->dfs_tst_rcvry)\n\t\td->tst_rcvry = val;\n\telse if (dent == d->dfs_ro_error)\n\t\tc->ro_error = !!val;\n\telse\n\t\treturn -EINVAL;\n\n\treturn count;\n}\n\nstatic const struct file_operations dfs_fops = {\n\t.open = dfs_file_open,\n\t.read = dfs_file_read,\n\t.write = dfs_file_write,\n\t.owner = THIS_MODULE,\n\t.llseek = no_llseek,\n};\n\n \nvoid dbg_debugfs_init_fs(struct ubifs_info *c)\n{\n\tint n;\n\tconst char *fname;\n\tstruct ubifs_debug_info *d = c->dbg;\n\n\tn = snprintf(d->dfs_dir_name, UBIFS_DFS_DIR_LEN + 1, UBIFS_DFS_DIR_NAME,\n\t\t     c->vi.ubi_num, c->vi.vol_id);\n\tif (n > UBIFS_DFS_DIR_LEN) {\n\t\t \n\t\treturn;\n\t}\n\n\tfname = d->dfs_dir_name;\n\td->dfs_dir = debugfs_create_dir(fname, dfs_rootdir);\n\n\tfname = \"dump_lprops\";\n\td->dfs_dump_lprops = debugfs_create_file(fname, S_IWUSR, d->dfs_dir, c,\n\t\t\t\t\t\t &dfs_fops);\n\n\tfname = \"dump_budg\";\n\td->dfs_dump_budg = debugfs_create_file(fname, S_IWUSR, d->dfs_dir, c,\n\t\t\t\t\t       &dfs_fops);\n\n\tfname = \"dump_tnc\";\n\td->dfs_dump_tnc = debugfs_create_file(fname, S_IWUSR, d->dfs_dir, c,\n\t\t\t\t\t      &dfs_fops);\n\n\tfname = \"chk_general\";\n\td->dfs_chk_gen = debugfs_create_file(fname, S_IRUSR | S_IWUSR,\n\t\t\t\t\t     d->dfs_dir, c, &dfs_fops);\n\n\tfname = \"chk_index\";\n\td->dfs_chk_index = debugfs_create_file(fname, S_IRUSR | S_IWUSR,\n\t\t\t\t\t       d->dfs_dir, c, &dfs_fops);\n\n\tfname = \"chk_orphans\";\n\td->dfs_chk_orph = debugfs_create_file(fname, S_IRUSR | S_IWUSR,\n\t\t\t\t\t      d->dfs_dir, c, &dfs_fops);\n\n\tfname = \"chk_lprops\";\n\td->dfs_chk_lprops = debugfs_create_file(fname, S_IRUSR | S_IWUSR,\n\t\t\t\t\t\td->dfs_dir, c, &dfs_fops);\n\n\tfname = \"chk_fs\";\n\td->dfs_chk_fs = debugfs_create_file(fname, S_IRUSR | S_IWUSR,\n\t\t\t\t\t    d->dfs_dir, c, &dfs_fops);\n\n\tfname = \"tst_recovery\";\n\td->dfs_tst_rcvry = debugfs_create_file(fname, S_IRUSR | S_IWUSR,\n\t\t\t\t\t       d->dfs_dir, c, &dfs_fops);\n\n\tfname = \"ro_error\";\n\td->dfs_ro_error = debugfs_create_file(fname, S_IRUSR | S_IWUSR,\n\t\t\t\t\t      d->dfs_dir, c, &dfs_fops);\n}\n\n \nvoid dbg_debugfs_exit_fs(struct ubifs_info *c)\n{\n\tdebugfs_remove_recursive(c->dbg->dfs_dir);\n}\n\nstruct ubifs_global_debug_info ubifs_dbg;\n\nstatic struct dentry *dfs_chk_gen;\nstatic struct dentry *dfs_chk_index;\nstatic struct dentry *dfs_chk_orph;\nstatic struct dentry *dfs_chk_lprops;\nstatic struct dentry *dfs_chk_fs;\nstatic struct dentry *dfs_tst_rcvry;\n\nstatic ssize_t dfs_global_file_read(struct file *file, char __user *u,\n\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct dentry *dent = file->f_path.dentry;\n\tint val;\n\n\tif (dent == dfs_chk_gen)\n\t\tval = ubifs_dbg.chk_gen;\n\telse if (dent == dfs_chk_index)\n\t\tval = ubifs_dbg.chk_index;\n\telse if (dent == dfs_chk_orph)\n\t\tval = ubifs_dbg.chk_orph;\n\telse if (dent == dfs_chk_lprops)\n\t\tval = ubifs_dbg.chk_lprops;\n\telse if (dent == dfs_chk_fs)\n\t\tval = ubifs_dbg.chk_fs;\n\telse if (dent == dfs_tst_rcvry)\n\t\tval = ubifs_dbg.tst_rcvry;\n\telse\n\t\treturn -EINVAL;\n\n\treturn provide_user_output(val, u, count, ppos);\n}\n\nstatic ssize_t dfs_global_file_write(struct file *file, const char __user *u,\n\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct dentry *dent = file->f_path.dentry;\n\tint val;\n\n\tval = interpret_user_input(u, count);\n\tif (val < 0)\n\t\treturn val;\n\n\tif (dent == dfs_chk_gen)\n\t\tubifs_dbg.chk_gen = val;\n\telse if (dent == dfs_chk_index)\n\t\tubifs_dbg.chk_index = val;\n\telse if (dent == dfs_chk_orph)\n\t\tubifs_dbg.chk_orph = val;\n\telse if (dent == dfs_chk_lprops)\n\t\tubifs_dbg.chk_lprops = val;\n\telse if (dent == dfs_chk_fs)\n\t\tubifs_dbg.chk_fs = val;\n\telse if (dent == dfs_tst_rcvry)\n\t\tubifs_dbg.tst_rcvry = val;\n\telse\n\t\treturn -EINVAL;\n\n\treturn count;\n}\n\nstatic const struct file_operations dfs_global_fops = {\n\t.read = dfs_global_file_read,\n\t.write = dfs_global_file_write,\n\t.owner = THIS_MODULE,\n\t.llseek = no_llseek,\n};\n\n \nvoid dbg_debugfs_init(void)\n{\n\tconst char *fname;\n\n\tfname = \"ubifs\";\n\tdfs_rootdir = debugfs_create_dir(fname, NULL);\n\n\tfname = \"chk_general\";\n\tdfs_chk_gen = debugfs_create_file(fname, S_IRUSR | S_IWUSR, dfs_rootdir,\n\t\t\t\t\t  NULL, &dfs_global_fops);\n\n\tfname = \"chk_index\";\n\tdfs_chk_index = debugfs_create_file(fname, S_IRUSR | S_IWUSR,\n\t\t\t\t\t    dfs_rootdir, NULL, &dfs_global_fops);\n\n\tfname = \"chk_orphans\";\n\tdfs_chk_orph = debugfs_create_file(fname, S_IRUSR | S_IWUSR,\n\t\t\t\t\t   dfs_rootdir, NULL, &dfs_global_fops);\n\n\tfname = \"chk_lprops\";\n\tdfs_chk_lprops = debugfs_create_file(fname, S_IRUSR | S_IWUSR,\n\t\t\t\t\t     dfs_rootdir, NULL, &dfs_global_fops);\n\n\tfname = \"chk_fs\";\n\tdfs_chk_fs = debugfs_create_file(fname, S_IRUSR | S_IWUSR, dfs_rootdir,\n\t\t\t\t\t NULL, &dfs_global_fops);\n\n\tfname = \"tst_recovery\";\n\tdfs_tst_rcvry = debugfs_create_file(fname, S_IRUSR | S_IWUSR,\n\t\t\t\t\t    dfs_rootdir, NULL, &dfs_global_fops);\n}\n\n \nvoid dbg_debugfs_exit(void)\n{\n\tdebugfs_remove_recursive(dfs_rootdir);\n}\n\nvoid ubifs_assert_failed(struct ubifs_info *c, const char *expr,\n\t\t\t const char *file, int line)\n{\n\tubifs_err(c, \"UBIFS assert failed: %s, in %s:%u\", expr, file, line);\n\n\tswitch (c->assert_action) {\n\t\tcase ASSACT_PANIC:\n\t\tBUG();\n\t\tbreak;\n\n\t\tcase ASSACT_RO:\n\t\tubifs_ro_mode(c, -EINVAL);\n\t\tbreak;\n\n\t\tcase ASSACT_REPORT:\n\t\tdefault:\n\t\tdump_stack();\n\t\tbreak;\n\n\t}\n}\n\n \nint ubifs_debugging_init(struct ubifs_info *c)\n{\n\tc->dbg = kzalloc(sizeof(struct ubifs_debug_info), GFP_KERNEL);\n\tif (!c->dbg)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\n \nvoid ubifs_debugging_exit(struct ubifs_info *c)\n{\n\tkfree(c->dbg);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}