{
  "module_name": "misc.h",
  "hash_id": "f5fe2e3e8149e99360e58bcde7828f8ea50f6e53ae8c6c7b811598309437325d",
  "original_prompt": "Ingested from linux-6.6.14/fs/ubifs/misc.h",
  "human_readable_source": " \n \n\n \n\n#ifndef __UBIFS_MISC_H__\n#define __UBIFS_MISC_H__\n\n \nstatic inline int ubifs_zn_dirty(const struct ubifs_znode *znode)\n{\n\treturn !!test_bit(DIRTY_ZNODE, &znode->flags);\n}\n\n \nstatic inline int ubifs_zn_obsolete(const struct ubifs_znode *znode)\n{\n\treturn !!test_bit(OBSOLETE_ZNODE, &znode->flags);\n}\n\n \nstatic inline int ubifs_zn_cow(const struct ubifs_znode *znode)\n{\n\treturn !!test_bit(COW_ZNODE, &znode->flags);\n}\n\n \nstatic inline void ubifs_wake_up_bgt(struct ubifs_info *c)\n{\n\tif (c->bgt && !c->need_bgt) {\n\t\tc->need_bgt = 1;\n\t\twake_up_process(c->bgt);\n\t}\n}\n\n \nstatic inline struct ubifs_znode *\nubifs_tnc_find_child(struct ubifs_znode *znode, int start)\n{\n\twhile (start < znode->child_cnt) {\n\t\tif (znode->zbranch[start].znode)\n\t\t\treturn znode->zbranch[start].znode;\n\t\tstart += 1;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic inline struct ubifs_inode *ubifs_inode(const struct inode *inode)\n{\n\treturn container_of(inode, struct ubifs_inode, vfs_inode);\n}\n\n \nstatic inline int ubifs_compr_present(struct ubifs_info *c, int compr_type)\n{\n\tubifs_assert(c, compr_type >= 0 && compr_type < UBIFS_COMPR_TYPES_CNT);\n\treturn !!ubifs_compressors[compr_type]->capi_name;\n}\n\n \nstatic inline const char *ubifs_compr_name(struct ubifs_info *c, int compr_type)\n{\n\tubifs_assert(c, compr_type >= 0 && compr_type < UBIFS_COMPR_TYPES_CNT);\n\treturn ubifs_compressors[compr_type]->name;\n}\n\n \nstatic inline int ubifs_wbuf_sync(struct ubifs_wbuf *wbuf)\n{\n\tint err;\n\n\tmutex_lock_nested(&wbuf->io_mutex, wbuf->jhead);\n\terr = ubifs_wbuf_sync_nolock(wbuf);\n\tmutex_unlock(&wbuf->io_mutex);\n\treturn err;\n}\n\n \nstatic inline int ubifs_encode_dev(union ubifs_dev_desc *dev, dev_t rdev)\n{\n\tdev->new = cpu_to_le32(new_encode_dev(rdev));\n\treturn sizeof(dev->new);\n}\n\n \nstatic inline int ubifs_add_dirt(struct ubifs_info *c, int lnum, int dirty)\n{\n\treturn ubifs_update_one_lp(c, lnum, LPROPS_NC, dirty, 0, 0);\n}\n\n \nstatic inline int ubifs_return_leb(struct ubifs_info *c, int lnum)\n{\n\treturn ubifs_change_one_lp(c, lnum, LPROPS_NC, LPROPS_NC, 0,\n\t\t\t\t   LPROPS_TAKEN, 0);\n}\n\n \nstatic inline int ubifs_idx_node_sz(const struct ubifs_info *c, int child_cnt)\n{\n\treturn UBIFS_IDX_NODE_SZ + (UBIFS_BRANCH_SZ + c->key_len + c->hash_len)\n\t\t\t\t   * child_cnt;\n}\n\n \nstatic inline\nstruct ubifs_branch *ubifs_idx_branch(const struct ubifs_info *c,\n\t\t\t\t      const struct ubifs_idx_node *idx,\n\t\t\t\t      int bnum)\n{\n\treturn (struct ubifs_branch *)((void *)idx->branches +\n\t\t\t(UBIFS_BRANCH_SZ + c->key_len + c->hash_len) * bnum);\n}\n\n \nstatic inline void *ubifs_idx_key(const struct ubifs_info *c,\n\t\t\t\t  const struct ubifs_idx_node *idx)\n{\n\treturn (void *)((struct ubifs_branch *)idx->branches)->key;\n}\n\n \nstatic inline int ubifs_tnc_lookup(struct ubifs_info *c,\n\t\t\t\t   const union ubifs_key *key, void *node)\n{\n\treturn ubifs_tnc_locate(c, key, node, NULL, NULL);\n}\n\n \nstatic inline void ubifs_get_lprops(struct ubifs_info *c)\n{\n\tmutex_lock(&c->lp_mutex);\n}\n\n \nstatic inline void ubifs_release_lprops(struct ubifs_info *c)\n{\n\tubifs_assert(c, mutex_is_locked(&c->lp_mutex));\n\tubifs_assert(c, c->lst.empty_lebs >= 0 &&\n\t\t     c->lst.empty_lebs <= c->main_lebs);\n\tmutex_unlock(&c->lp_mutex);\n}\n\n \nstatic inline int ubifs_next_log_lnum(const struct ubifs_info *c, int lnum)\n{\n\tlnum += 1;\n\tif (lnum > c->log_last)\n\t\tlnum = UBIFS_LOG_LNUM;\n\n\treturn lnum;\n}\n\nstatic inline int ubifs_xattr_max_cnt(struct ubifs_info *c)\n{\n\tint max_xattrs = (c->leb_size / 2) / UBIFS_INO_NODE_SZ;\n\n\tubifs_assert(c, max_xattrs < c->max_orphans);\n\treturn max_xattrs;\n}\n\nconst char *ubifs_assert_action_name(struct ubifs_info *c);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}