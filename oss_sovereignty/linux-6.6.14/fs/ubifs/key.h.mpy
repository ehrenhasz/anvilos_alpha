{
  "module_name": "key.h",
  "hash_id": "545d1a2ca6b9f33e43d9cc1c7cb741fba053c3f86764ba6f337b04badc608872",
  "original_prompt": "Ingested from linux-6.6.14/fs/ubifs/key.h",
  "human_readable_source": " \n \n\n \n\n \n\n#ifndef __UBIFS_KEY_H__\n#define __UBIFS_KEY_H__\n\n \nstatic inline uint32_t key_mask_hash(uint32_t hash)\n{\n\thash &= UBIFS_S_KEY_HASH_MASK;\n\tif (unlikely(hash <= 2))\n\t\thash += 3;\n\treturn hash;\n}\n\n \nstatic inline uint32_t key_r5_hash(const char *s, int len)\n{\n\tuint32_t a = 0;\n\tconst signed char *str = (const signed char *)s;\n\n\twhile (len--) {\n\t\ta += *str << 4;\n\t\ta += *str >> 4;\n\t\ta *= 11;\n\t\tstr++;\n\t}\n\n\treturn key_mask_hash(a);\n}\n\n \nstatic inline uint32_t key_test_hash(const char *str, int len)\n{\n\tuint32_t a = 0;\n\n\tlen = min_t(uint32_t, len, 4);\n\tmemcpy(&a, str, len);\n\treturn key_mask_hash(a);\n}\n\n \nstatic inline void ino_key_init(const struct ubifs_info *c,\n\t\t\t\tunion ubifs_key *key, ino_t inum)\n{\n\tkey->u32[0] = inum;\n\tkey->u32[1] = UBIFS_INO_KEY << UBIFS_S_KEY_BLOCK_BITS;\n}\n\n \nstatic inline void ino_key_init_flash(const struct ubifs_info *c, void *k,\n\t\t\t\t      ino_t inum)\n{\n\tunion ubifs_key *key = k;\n\n\tkey->j32[0] = cpu_to_le32(inum);\n\tkey->j32[1] = cpu_to_le32(UBIFS_INO_KEY << UBIFS_S_KEY_BLOCK_BITS);\n\tmemset(k + 8, 0, UBIFS_MAX_KEY_LEN - 8);\n}\n\n \nstatic inline void lowest_ino_key(const struct ubifs_info *c,\n\t\t\t\tunion ubifs_key *key, ino_t inum)\n{\n\tkey->u32[0] = inum;\n\tkey->u32[1] = 0;\n}\n\n \nstatic inline void highest_ino_key(const struct ubifs_info *c,\n\t\t\t\tunion ubifs_key *key, ino_t inum)\n{\n\tkey->u32[0] = inum;\n\tkey->u32[1] = 0xffffffff;\n}\n\n \nstatic inline void dent_key_init(const struct ubifs_info *c,\n\t\t\t\t union ubifs_key *key, ino_t inum,\n\t\t\t\t const struct fscrypt_name *nm)\n{\n\tuint32_t hash = c->key_hash(fname_name(nm), fname_len(nm));\n\n\tubifs_assert(c, !(hash & ~UBIFS_S_KEY_HASH_MASK));\n\tkey->u32[0] = inum;\n\tkey->u32[1] = hash | (UBIFS_DENT_KEY << UBIFS_S_KEY_HASH_BITS);\n}\n\n \nstatic inline void dent_key_init_hash(const struct ubifs_info *c,\n\t\t\t\t      union ubifs_key *key, ino_t inum,\n\t\t\t\t      uint32_t hash)\n{\n\tubifs_assert(c, !(hash & ~UBIFS_S_KEY_HASH_MASK));\n\tkey->u32[0] = inum;\n\tkey->u32[1] = hash | (UBIFS_DENT_KEY << UBIFS_S_KEY_HASH_BITS);\n}\n\n \nstatic inline void dent_key_init_flash(const struct ubifs_info *c, void *k,\n\t\t\t\t       ino_t inum,\n\t\t\t\t       const struct fscrypt_name *nm)\n{\n\tunion ubifs_key *key = k;\n\tuint32_t hash = c->key_hash(fname_name(nm), fname_len(nm));\n\n\tubifs_assert(c, !(hash & ~UBIFS_S_KEY_HASH_MASK));\n\tkey->j32[0] = cpu_to_le32(inum);\n\tkey->j32[1] = cpu_to_le32(hash |\n\t\t\t\t  (UBIFS_DENT_KEY << UBIFS_S_KEY_HASH_BITS));\n\tmemset(k + 8, 0, UBIFS_MAX_KEY_LEN - 8);\n}\n\n \nstatic inline void lowest_dent_key(const struct ubifs_info *c,\n\t\t\t\t   union ubifs_key *key, ino_t inum)\n{\n\tkey->u32[0] = inum;\n\tkey->u32[1] = UBIFS_DENT_KEY << UBIFS_S_KEY_HASH_BITS;\n}\n\n \nstatic inline void xent_key_init(const struct ubifs_info *c,\n\t\t\t\t union ubifs_key *key, ino_t inum,\n\t\t\t\t const struct fscrypt_name *nm)\n{\n\tuint32_t hash = c->key_hash(fname_name(nm), fname_len(nm));\n\n\tubifs_assert(c, !(hash & ~UBIFS_S_KEY_HASH_MASK));\n\tkey->u32[0] = inum;\n\tkey->u32[1] = hash | (UBIFS_XENT_KEY << UBIFS_S_KEY_HASH_BITS);\n}\n\n \nstatic inline void xent_key_init_flash(const struct ubifs_info *c, void *k,\n\t\t\t\t       ino_t inum, const struct fscrypt_name *nm)\n{\n\tunion ubifs_key *key = k;\n\tuint32_t hash = c->key_hash(fname_name(nm), fname_len(nm));\n\n\tubifs_assert(c, !(hash & ~UBIFS_S_KEY_HASH_MASK));\n\tkey->j32[0] = cpu_to_le32(inum);\n\tkey->j32[1] = cpu_to_le32(hash |\n\t\t\t\t  (UBIFS_XENT_KEY << UBIFS_S_KEY_HASH_BITS));\n\tmemset(k + 8, 0, UBIFS_MAX_KEY_LEN - 8);\n}\n\n \nstatic inline void lowest_xent_key(const struct ubifs_info *c,\n\t\t\t\t   union ubifs_key *key, ino_t inum)\n{\n\tkey->u32[0] = inum;\n\tkey->u32[1] = UBIFS_XENT_KEY << UBIFS_S_KEY_HASH_BITS;\n}\n\n \nstatic inline void data_key_init(const struct ubifs_info *c,\n\t\t\t\t union ubifs_key *key, ino_t inum,\n\t\t\t\t unsigned int block)\n{\n\tubifs_assert(c, !(block & ~UBIFS_S_KEY_BLOCK_MASK));\n\tkey->u32[0] = inum;\n\tkey->u32[1] = block | (UBIFS_DATA_KEY << UBIFS_S_KEY_BLOCK_BITS);\n}\n\n \nstatic inline void highest_data_key(const struct ubifs_info *c,\n\t\t\t\t   union ubifs_key *key, ino_t inum)\n{\n\tdata_key_init(c, key, inum, UBIFS_S_KEY_BLOCK_MASK);\n}\n\n \nstatic inline void trun_key_init(const struct ubifs_info *c,\n\t\t\t\t union ubifs_key *key, ino_t inum)\n{\n\tkey->u32[0] = inum;\n\tkey->u32[1] = UBIFS_TRUN_KEY << UBIFS_S_KEY_BLOCK_BITS;\n}\n\n \nstatic inline void invalid_key_init(const struct ubifs_info *c,\n\t\t\t\t    union ubifs_key *key)\n{\n\tkey->u32[0] = 0xDEADBEAF;\n\tkey->u32[1] = UBIFS_INVALID_KEY;\n}\n\n \nstatic inline int key_type(const struct ubifs_info *c,\n\t\t\t   const union ubifs_key *key)\n{\n\treturn key->u32[1] >> UBIFS_S_KEY_BLOCK_BITS;\n}\n\n \nstatic inline int key_type_flash(const struct ubifs_info *c, const void *k)\n{\n\tconst union ubifs_key *key = k;\n\n\treturn le32_to_cpu(key->j32[1]) >> UBIFS_S_KEY_BLOCK_BITS;\n}\n\n \nstatic inline ino_t key_inum(const struct ubifs_info *c, const void *k)\n{\n\tconst union ubifs_key *key = k;\n\n\treturn key->u32[0];\n}\n\n \nstatic inline ino_t key_inum_flash(const struct ubifs_info *c, const void *k)\n{\n\tconst union ubifs_key *key = k;\n\n\treturn le32_to_cpu(key->j32[0]);\n}\n\n \nstatic inline uint32_t key_hash(const struct ubifs_info *c,\n\t\t\t\tconst union ubifs_key *key)\n{\n\treturn key->u32[1] & UBIFS_S_KEY_HASH_MASK;\n}\n\n \nstatic inline uint32_t key_hash_flash(const struct ubifs_info *c, const void *k)\n{\n\tconst union ubifs_key *key = k;\n\n\treturn le32_to_cpu(key->j32[1]) & UBIFS_S_KEY_HASH_MASK;\n}\n\n \nstatic inline unsigned int key_block(const struct ubifs_info *c,\n\t\t\t\t     const union ubifs_key *key)\n{\n\treturn key->u32[1] & UBIFS_S_KEY_BLOCK_MASK;\n}\n\n \nstatic inline unsigned int key_block_flash(const struct ubifs_info *c,\n\t\t\t\t\t   const void *k)\n{\n\tconst union ubifs_key *key = k;\n\n\treturn le32_to_cpu(key->j32[1]) & UBIFS_S_KEY_BLOCK_MASK;\n}\n\n \nstatic inline void key_read(const struct ubifs_info *c, const void *from,\n\t\t\t    union ubifs_key *to)\n{\n\tconst union ubifs_key *f = from;\n\n\tto->u32[0] = le32_to_cpu(f->j32[0]);\n\tto->u32[1] = le32_to_cpu(f->j32[1]);\n}\n\n \nstatic inline void key_write(const struct ubifs_info *c,\n\t\t\t     const union ubifs_key *from, void *to)\n{\n\tunion ubifs_key *t = to;\n\n\tt->j32[0] = cpu_to_le32(from->u32[0]);\n\tt->j32[1] = cpu_to_le32(from->u32[1]);\n\tmemset(to + 8, 0, UBIFS_MAX_KEY_LEN - 8);\n}\n\n \nstatic inline void key_write_idx(const struct ubifs_info *c,\n\t\t\t\t const union ubifs_key *from, void *to)\n{\n\tunion ubifs_key *t = to;\n\n\tt->j32[0] = cpu_to_le32(from->u32[0]);\n\tt->j32[1] = cpu_to_le32(from->u32[1]);\n}\n\n \nstatic inline void key_copy(const struct ubifs_info *c,\n\t\t\t    const union ubifs_key *from, union ubifs_key *to)\n{\n\tto->u64[0] = from->u64[0];\n}\n\n \nstatic inline int keys_cmp(const struct ubifs_info *c,\n\t\t\t   const union ubifs_key *key1,\n\t\t\t   const union ubifs_key *key2)\n{\n\tif (key1->u32[0] < key2->u32[0])\n\t\treturn -1;\n\tif (key1->u32[0] > key2->u32[0])\n\t\treturn 1;\n\tif (key1->u32[1] < key2->u32[1])\n\t\treturn -1;\n\tif (key1->u32[1] > key2->u32[1])\n\t\treturn 1;\n\n\treturn 0;\n}\n\n \nstatic inline int keys_eq(const struct ubifs_info *c,\n\t\t\t  const union ubifs_key *key1,\n\t\t\t  const union ubifs_key *key2)\n{\n\tif (key1->u32[0] != key2->u32[0])\n\t\treturn 0;\n\tif (key1->u32[1] != key2->u32[1])\n\t\treturn 0;\n\treturn 1;\n}\n\n \nstatic inline int is_hash_key(const struct ubifs_info *c,\n\t\t\t      const union ubifs_key *key)\n{\n\tint type = key_type(c, key);\n\n\treturn type == UBIFS_DENT_KEY || type == UBIFS_XENT_KEY;\n}\n\n \nstatic inline unsigned long long key_max_inode_size(const struct ubifs_info *c)\n{\n\tswitch (c->key_fmt) {\n\tcase UBIFS_SIMPLE_KEY_FMT:\n\t\treturn (1ULL << UBIFS_S_KEY_BLOCK_BITS) * UBIFS_BLOCK_SIZE;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}