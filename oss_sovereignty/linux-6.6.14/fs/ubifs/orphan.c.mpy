{
  "module_name": "orphan.c",
  "hash_id": "05ee0aa56d22ae29f0a61911510927fa063a63538117068092163cf474257ef0",
  "original_prompt": "Ingested from linux-6.6.14/fs/ubifs/orphan.c",
  "human_readable_source": "\n \n\n#include \"ubifs.h\"\n\n \n\nstatic int dbg_check_orphans(struct ubifs_info *c);\n\nstatic struct ubifs_orphan *orphan_add(struct ubifs_info *c, ino_t inum,\n\t\t\t\t       struct ubifs_orphan *parent_orphan)\n{\n\tstruct ubifs_orphan *orphan, *o;\n\tstruct rb_node **p, *parent = NULL;\n\n\torphan = kzalloc(sizeof(struct ubifs_orphan), GFP_NOFS);\n\tif (!orphan)\n\t\treturn ERR_PTR(-ENOMEM);\n\torphan->inum = inum;\n\torphan->new = 1;\n\tINIT_LIST_HEAD(&orphan->child_list);\n\n\tspin_lock(&c->orphan_lock);\n\tif (c->tot_orphans >= c->max_orphans) {\n\t\tspin_unlock(&c->orphan_lock);\n\t\tkfree(orphan);\n\t\treturn ERR_PTR(-ENFILE);\n\t}\n\tp = &c->orph_tree.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\to = rb_entry(parent, struct ubifs_orphan, rb);\n\t\tif (inum < o->inum)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (inum > o->inum)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\tubifs_err(c, \"orphaned twice\");\n\t\t\tspin_unlock(&c->orphan_lock);\n\t\t\tkfree(orphan);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t}\n\tc->tot_orphans += 1;\n\tc->new_orphans += 1;\n\trb_link_node(&orphan->rb, parent, p);\n\trb_insert_color(&orphan->rb, &c->orph_tree);\n\tlist_add_tail(&orphan->list, &c->orph_list);\n\tlist_add_tail(&orphan->new_list, &c->orph_new);\n\n\tif (parent_orphan) {\n\t\tlist_add_tail(&orphan->child_list,\n\t\t\t      &parent_orphan->child_list);\n\t}\n\n\tspin_unlock(&c->orphan_lock);\n\tdbg_gen(\"ino %lu\", (unsigned long)inum);\n\treturn orphan;\n}\n\nstatic struct ubifs_orphan *lookup_orphan(struct ubifs_info *c, ino_t inum)\n{\n\tstruct ubifs_orphan *o;\n\tstruct rb_node *p;\n\n\tp = c->orph_tree.rb_node;\n\twhile (p) {\n\t\to = rb_entry(p, struct ubifs_orphan, rb);\n\t\tif (inum < o->inum)\n\t\t\tp = p->rb_left;\n\t\telse if (inum > o->inum)\n\t\t\tp = p->rb_right;\n\t\telse {\n\t\t\treturn o;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic void __orphan_drop(struct ubifs_info *c, struct ubifs_orphan *o)\n{\n\trb_erase(&o->rb, &c->orph_tree);\n\tlist_del(&o->list);\n\tc->tot_orphans -= 1;\n\n\tif (o->new) {\n\t\tlist_del(&o->new_list);\n\t\tc->new_orphans -= 1;\n\t}\n\n\tkfree(o);\n}\n\nstatic void orphan_delete(struct ubifs_info *c, struct ubifs_orphan *orph)\n{\n\tif (orph->del) {\n\t\tdbg_gen(\"deleted twice ino %lu\", (unsigned long)orph->inum);\n\t\treturn;\n\t}\n\n\tif (orph->cmt) {\n\t\torph->del = 1;\n\t\torph->dnext = c->orph_dnext;\n\t\tc->orph_dnext = orph;\n\t\tdbg_gen(\"delete later ino %lu\", (unsigned long)orph->inum);\n\t\treturn;\n\t}\n\n\t__orphan_drop(c, orph);\n}\n\n \nint ubifs_add_orphan(struct ubifs_info *c, ino_t inum)\n{\n\tint err = 0;\n\tino_t xattr_inum;\n\tunion ubifs_key key;\n\tstruct ubifs_dent_node *xent, *pxent = NULL;\n\tstruct fscrypt_name nm = {0};\n\tstruct ubifs_orphan *xattr_orphan;\n\tstruct ubifs_orphan *orphan;\n\n\torphan = orphan_add(c, inum, NULL);\n\tif (IS_ERR(orphan))\n\t\treturn PTR_ERR(orphan);\n\n\tlowest_xent_key(c, &key, inum);\n\twhile (1) {\n\t\txent = ubifs_tnc_next_ent(c, &key, &nm);\n\t\tif (IS_ERR(xent)) {\n\t\t\terr = PTR_ERR(xent);\n\t\t\tif (err == -ENOENT)\n\t\t\t\tbreak;\n\t\t\tkfree(pxent);\n\t\t\treturn err;\n\t\t}\n\n\t\tfname_name(&nm) = xent->name;\n\t\tfname_len(&nm) = le16_to_cpu(xent->nlen);\n\t\txattr_inum = le64_to_cpu(xent->inum);\n\n\t\txattr_orphan = orphan_add(c, xattr_inum, orphan);\n\t\tif (IS_ERR(xattr_orphan)) {\n\t\t\tkfree(pxent);\n\t\t\tkfree(xent);\n\t\t\treturn PTR_ERR(xattr_orphan);\n\t\t}\n\n\t\tkfree(pxent);\n\t\tpxent = xent;\n\t\tkey_read(c, &xent->key, &key);\n\t}\n\tkfree(pxent);\n\n\treturn 0;\n}\n\n \nvoid ubifs_delete_orphan(struct ubifs_info *c, ino_t inum)\n{\n\tstruct ubifs_orphan *orph, *child_orph, *tmp_o;\n\n\tspin_lock(&c->orphan_lock);\n\n\torph = lookup_orphan(c, inum);\n\tif (!orph) {\n\t\tspin_unlock(&c->orphan_lock);\n\t\tubifs_err(c, \"missing orphan ino %lu\", (unsigned long)inum);\n\t\tdump_stack();\n\n\t\treturn;\n\t}\n\n\tlist_for_each_entry_safe(child_orph, tmp_o, &orph->child_list, child_list) {\n\t\tlist_del(&child_orph->child_list);\n\t\torphan_delete(c, child_orph);\n\t}\n\t\n\torphan_delete(c, orph);\n\n\tspin_unlock(&c->orphan_lock);\n}\n\n \nint ubifs_orphan_start_commit(struct ubifs_info *c)\n{\n\tstruct ubifs_orphan *orphan, **last;\n\n\tspin_lock(&c->orphan_lock);\n\tlast = &c->orph_cnext;\n\tlist_for_each_entry(orphan, &c->orph_new, new_list) {\n\t\tubifs_assert(c, orphan->new);\n\t\tubifs_assert(c, !orphan->cmt);\n\t\torphan->new = 0;\n\t\torphan->cmt = 1;\n\t\t*last = orphan;\n\t\tlast = &orphan->cnext;\n\t}\n\t*last = NULL;\n\tc->cmt_orphans = c->new_orphans;\n\tc->new_orphans = 0;\n\tdbg_cmt(\"%d orphans to commit\", c->cmt_orphans);\n\tINIT_LIST_HEAD(&c->orph_new);\n\tif (c->tot_orphans == 0)\n\t\tc->no_orphs = 1;\n\telse\n\t\tc->no_orphs = 0;\n\tspin_unlock(&c->orphan_lock);\n\treturn 0;\n}\n\n \nstatic int avail_orphs(struct ubifs_info *c)\n{\n\tint avail_lebs, avail, gap;\n\n\tavail_lebs = c->orph_lebs - (c->ohead_lnum - c->orph_first) - 1;\n\tavail = avail_lebs *\n\t       ((c->leb_size - UBIFS_ORPH_NODE_SZ) / sizeof(__le64));\n\tgap = c->leb_size - c->ohead_offs;\n\tif (gap >= UBIFS_ORPH_NODE_SZ + sizeof(__le64))\n\t\tavail += (gap - UBIFS_ORPH_NODE_SZ) / sizeof(__le64);\n\treturn avail;\n}\n\n \nstatic int tot_avail_orphs(struct ubifs_info *c)\n{\n\tint avail_lebs, avail;\n\n\tavail_lebs = c->orph_lebs;\n\tavail = avail_lebs *\n\t       ((c->leb_size - UBIFS_ORPH_NODE_SZ) / sizeof(__le64));\n\treturn avail / 2;\n}\n\n \nstatic int do_write_orph_node(struct ubifs_info *c, int len, int atomic)\n{\n\tint err = 0;\n\n\tif (atomic) {\n\t\tubifs_assert(c, c->ohead_offs == 0);\n\t\tubifs_prepare_node(c, c->orph_buf, len, 1);\n\t\tlen = ALIGN(len, c->min_io_size);\n\t\terr = ubifs_leb_change(c, c->ohead_lnum, c->orph_buf, len);\n\t} else {\n\t\tif (c->ohead_offs == 0) {\n\t\t\t \n\t\t\terr = ubifs_leb_unmap(c, c->ohead_lnum);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\terr = ubifs_write_node(c, c->orph_buf, len, c->ohead_lnum,\n\t\t\t\t       c->ohead_offs);\n\t}\n\treturn err;\n}\n\n \nstatic int write_orph_node(struct ubifs_info *c, int atomic)\n{\n\tstruct ubifs_orphan *orphan, *cnext;\n\tstruct ubifs_orph_node *orph;\n\tint gap, err, len, cnt, i;\n\n\tubifs_assert(c, c->cmt_orphans > 0);\n\tgap = c->leb_size - c->ohead_offs;\n\tif (gap < UBIFS_ORPH_NODE_SZ + sizeof(__le64)) {\n\t\tc->ohead_lnum += 1;\n\t\tc->ohead_offs = 0;\n\t\tgap = c->leb_size;\n\t\tif (c->ohead_lnum > c->orph_last) {\n\t\t\t \n\t\t\tubifs_err(c, \"out of space in orphan area\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tcnt = (gap - UBIFS_ORPH_NODE_SZ) / sizeof(__le64);\n\tif (cnt > c->cmt_orphans)\n\t\tcnt = c->cmt_orphans;\n\tlen = UBIFS_ORPH_NODE_SZ + cnt * sizeof(__le64);\n\tubifs_assert(c, c->orph_buf);\n\torph = c->orph_buf;\n\torph->ch.node_type = UBIFS_ORPH_NODE;\n\tspin_lock(&c->orphan_lock);\n\tcnext = c->orph_cnext;\n\tfor (i = 0; i < cnt; i++) {\n\t\torphan = cnext;\n\t\tubifs_assert(c, orphan->cmt);\n\t\torph->inos[i] = cpu_to_le64(orphan->inum);\n\t\torphan->cmt = 0;\n\t\tcnext = orphan->cnext;\n\t\torphan->cnext = NULL;\n\t}\n\tc->orph_cnext = cnext;\n\tc->cmt_orphans -= cnt;\n\tspin_unlock(&c->orphan_lock);\n\tif (c->cmt_orphans)\n\t\torph->cmt_no = cpu_to_le64(c->cmt_no);\n\telse\n\t\t \n\t\torph->cmt_no = cpu_to_le64((c->cmt_no) | (1ULL << 63));\n\tubifs_assert(c, c->ohead_offs + len <= c->leb_size);\n\tubifs_assert(c, c->ohead_lnum >= c->orph_first);\n\tubifs_assert(c, c->ohead_lnum <= c->orph_last);\n\terr = do_write_orph_node(c, len, atomic);\n\tc->ohead_offs += ALIGN(len, c->min_io_size);\n\tc->ohead_offs = ALIGN(c->ohead_offs, 8);\n\treturn err;\n}\n\n \nstatic int write_orph_nodes(struct ubifs_info *c, int atomic)\n{\n\tint err;\n\n\twhile (c->cmt_orphans > 0) {\n\t\terr = write_orph_node(c, atomic);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (atomic) {\n\t\tint lnum;\n\n\t\t \n\t\tfor (lnum = c->ohead_lnum + 1; lnum <= c->orph_last; lnum++) {\n\t\t\terr = ubifs_leb_unmap(c, lnum);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int consolidate(struct ubifs_info *c)\n{\n\tint tot_avail = tot_avail_orphs(c), err = 0;\n\n\tspin_lock(&c->orphan_lock);\n\tdbg_cmt(\"there is space for %d orphans and there are %d\",\n\t\ttot_avail, c->tot_orphans);\n\tif (c->tot_orphans - c->new_orphans <= tot_avail) {\n\t\tstruct ubifs_orphan *orphan, **last;\n\t\tint cnt = 0;\n\n\t\t \n\t\tlast = &c->orph_cnext;\n\t\tlist_for_each_entry(orphan, &c->orph_list, list) {\n\t\t\tif (orphan->new)\n\t\t\t\tcontinue;\n\t\t\torphan->cmt = 1;\n\t\t\t*last = orphan;\n\t\t\tlast = &orphan->cnext;\n\t\t\tcnt += 1;\n\t\t}\n\t\t*last = NULL;\n\t\tubifs_assert(c, cnt == c->tot_orphans - c->new_orphans);\n\t\tc->cmt_orphans = cnt;\n\t\tc->ohead_lnum = c->orph_first;\n\t\tc->ohead_offs = 0;\n\t} else {\n\t\t \n\t\tubifs_err(c, \"out of space in orphan area\");\n\t\terr = -EINVAL;\n\t}\n\tspin_unlock(&c->orphan_lock);\n\treturn err;\n}\n\n \nstatic int commit_orphans(struct ubifs_info *c)\n{\n\tint avail, atomic = 0, err;\n\n\tubifs_assert(c, c->cmt_orphans > 0);\n\tavail = avail_orphs(c);\n\tif (avail < c->cmt_orphans) {\n\t\t \n\t\terr = consolidate(c);\n\t\tif (err)\n\t\t\treturn err;\n\t\tatomic = 1;\n\t}\n\terr = write_orph_nodes(c, atomic);\n\treturn err;\n}\n\n \nstatic void erase_deleted(struct ubifs_info *c)\n{\n\tstruct ubifs_orphan *orphan, *dnext;\n\n\tspin_lock(&c->orphan_lock);\n\tdnext = c->orph_dnext;\n\twhile (dnext) {\n\t\torphan = dnext;\n\t\tdnext = orphan->dnext;\n\t\tubifs_assert(c, !orphan->new);\n\t\tubifs_assert(c, orphan->del);\n\t\trb_erase(&orphan->rb, &c->orph_tree);\n\t\tlist_del(&orphan->list);\n\t\tc->tot_orphans -= 1;\n\t\tdbg_gen(\"deleting orphan ino %lu\", (unsigned long)orphan->inum);\n\t\tkfree(orphan);\n\t}\n\tc->orph_dnext = NULL;\n\tspin_unlock(&c->orphan_lock);\n}\n\n \nint ubifs_orphan_end_commit(struct ubifs_info *c)\n{\n\tint err;\n\n\tif (c->cmt_orphans != 0) {\n\t\terr = commit_orphans(c);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\terase_deleted(c);\n\terr = dbg_check_orphans(c);\n\treturn err;\n}\n\n \nint ubifs_clear_orphans(struct ubifs_info *c)\n{\n\tint lnum, err;\n\n\tfor (lnum = c->orph_first; lnum <= c->orph_last; lnum++) {\n\t\terr = ubifs_leb_unmap(c, lnum);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tc->ohead_lnum = c->orph_first;\n\tc->ohead_offs = 0;\n\treturn 0;\n}\n\n \nstatic int insert_dead_orphan(struct ubifs_info *c, ino_t inum)\n{\n\tstruct ubifs_orphan *orphan, *o;\n\tstruct rb_node **p, *parent = NULL;\n\n\torphan = kzalloc(sizeof(struct ubifs_orphan), GFP_KERNEL);\n\tif (!orphan)\n\t\treturn -ENOMEM;\n\torphan->inum = inum;\n\n\tp = &c->orph_tree.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\to = rb_entry(parent, struct ubifs_orphan, rb);\n\t\tif (inum < o->inum)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (inum > o->inum)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\t \n\t\t\tkfree(orphan);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tc->tot_orphans += 1;\n\trb_link_node(&orphan->rb, parent, p);\n\trb_insert_color(&orphan->rb, &c->orph_tree);\n\tlist_add_tail(&orphan->list, &c->orph_list);\n\torphan->del = 1;\n\torphan->dnext = c->orph_dnext;\n\tc->orph_dnext = orphan;\n\tdbg_mnt(\"ino %lu, new %d, tot %d\", (unsigned long)inum,\n\t\tc->new_orphans, c->tot_orphans);\n\treturn 0;\n}\n\n \nstatic int do_kill_orphans(struct ubifs_info *c, struct ubifs_scan_leb *sleb,\n\t\t\t   unsigned long long *last_cmt_no, int *outofdate,\n\t\t\t   int *last_flagged)\n{\n\tstruct ubifs_scan_node *snod;\n\tstruct ubifs_orph_node *orph;\n\tstruct ubifs_ino_node *ino = NULL;\n\tunsigned long long cmt_no;\n\tino_t inum;\n\tint i, n, err, first = 1;\n\n\tino = kmalloc(UBIFS_MAX_INO_NODE_SZ, GFP_NOFS);\n\tif (!ino)\n\t\treturn -ENOMEM;\n\n\tlist_for_each_entry(snod, &sleb->nodes, list) {\n\t\tif (snod->type != UBIFS_ORPH_NODE) {\n\t\t\tubifs_err(c, \"invalid node type %d in orphan area at %d:%d\",\n\t\t\t\t  snod->type, sleb->lnum, snod->offs);\n\t\t\tubifs_dump_node(c, snod->node,\n\t\t\t\t\tc->leb_size - snod->offs);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\torph = snod->node;\n\n\t\t \n\t\tcmt_no = le64_to_cpu(orph->cmt_no) & LLONG_MAX;\n\t\t \n\t\tif (cmt_no > c->cmt_no)\n\t\t\tc->cmt_no = cmt_no;\n\t\tif (cmt_no < *last_cmt_no && *last_flagged) {\n\t\t\t \n\t\t\tif (!first) {\n\t\t\t\tubifs_err(c, \"out of order commit number %llu in orphan node at %d:%d\",\n\t\t\t\t\t  cmt_no, sleb->lnum, snod->offs);\n\t\t\t\tubifs_dump_node(c, snod->node,\n\t\t\t\t\t\tc->leb_size - snod->offs);\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\tdbg_rcvry(\"out of date LEB %d\", sleb->lnum);\n\t\t\t*outofdate = 1;\n\t\t\terr = 0;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tif (first)\n\t\t\tfirst = 0;\n\n\t\tn = (le32_to_cpu(orph->ch.len) - UBIFS_ORPH_NODE_SZ) >> 3;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tunion ubifs_key key1, key2;\n\n\t\t\tinum = le64_to_cpu(orph->inos[i]);\n\n\t\t\tino_key_init(c, &key1, inum);\n\t\t\terr = ubifs_tnc_lookup(c, &key1, ino);\n\t\t\tif (err && err != -ENOENT)\n\t\t\t\tgoto out_free;\n\n\t\t\t \n\t\t\tif (err == 0 && ino->nlink == 0) {\n\t\t\t\tdbg_rcvry(\"deleting orphaned inode %lu\",\n\t\t\t\t\t  (unsigned long)inum);\n\n\t\t\t\tlowest_ino_key(c, &key1, inum);\n\t\t\t\thighest_ino_key(c, &key2, inum);\n\n\t\t\t\terr = ubifs_tnc_remove_range(c, &key1, &key2);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out_ro;\n\t\t\t}\n\n\t\t\terr = insert_dead_orphan(c, inum);\n\t\t\tif (err)\n\t\t\t\tgoto out_free;\n\t\t}\n\n\t\t*last_cmt_no = cmt_no;\n\t\tif (le64_to_cpu(orph->cmt_no) & (1ULL << 63)) {\n\t\t\tdbg_rcvry(\"last orph node for commit %llu at %d:%d\",\n\t\t\t\t  cmt_no, sleb->lnum, snod->offs);\n\t\t\t*last_flagged = 1;\n\t\t} else\n\t\t\t*last_flagged = 0;\n\t}\n\n\terr = 0;\nout_free:\n\tkfree(ino);\n\treturn err;\n\nout_ro:\n\tubifs_ro_mode(c, err);\n\tkfree(ino);\n\treturn err;\n}\n\n \nstatic int kill_orphans(struct ubifs_info *c)\n{\n\tunsigned long long last_cmt_no = 0;\n\tint lnum, err = 0, outofdate = 0, last_flagged = 0;\n\n\tc->ohead_lnum = c->orph_first;\n\tc->ohead_offs = 0;\n\t \n\tif (c->no_orphs) {\n\t\tdbg_rcvry(\"no orphans\");\n\t\treturn 0;\n\t}\n\t \n\tfor (lnum = c->orph_first; lnum <= c->orph_last; lnum++) {\n\t\tstruct ubifs_scan_leb *sleb;\n\n\t\tdbg_rcvry(\"LEB %d\", lnum);\n\t\tsleb = ubifs_scan(c, lnum, 0, c->sbuf, 1);\n\t\tif (IS_ERR(sleb)) {\n\t\t\tif (PTR_ERR(sleb) == -EUCLEAN)\n\t\t\t\tsleb = ubifs_recover_leb(c, lnum, 0,\n\t\t\t\t\t\t\t c->sbuf, -1);\n\t\t\tif (IS_ERR(sleb)) {\n\t\t\t\terr = PTR_ERR(sleb);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\terr = do_kill_orphans(c, sleb, &last_cmt_no, &outofdate,\n\t\t\t\t      &last_flagged);\n\t\tif (err || outofdate) {\n\t\t\tubifs_scan_destroy(sleb);\n\t\t\tbreak;\n\t\t}\n\t\tif (sleb->endpt) {\n\t\t\tc->ohead_lnum = lnum;\n\t\t\tc->ohead_offs = sleb->endpt;\n\t\t}\n\t\tubifs_scan_destroy(sleb);\n\t}\n\treturn err;\n}\n\n \nint ubifs_mount_orphans(struct ubifs_info *c, int unclean, int read_only)\n{\n\tint err = 0;\n\n\tc->max_orphans = tot_avail_orphs(c);\n\n\tif (!read_only) {\n\t\tc->orph_buf = vmalloc(c->leb_size);\n\t\tif (!c->orph_buf)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (unclean)\n\t\terr = kill_orphans(c);\n\telse if (!read_only)\n\t\terr = ubifs_clear_orphans(c);\n\n\treturn err;\n}\n\n \n\nstruct check_orphan {\n\tstruct rb_node rb;\n\tino_t inum;\n};\n\nstruct check_info {\n\tunsigned long last_ino;\n\tunsigned long tot_inos;\n\tunsigned long missing;\n\tunsigned long long leaf_cnt;\n\tstruct ubifs_ino_node *node;\n\tstruct rb_root root;\n};\n\nstatic bool dbg_find_orphan(struct ubifs_info *c, ino_t inum)\n{\n\tbool found = false;\n\n\tspin_lock(&c->orphan_lock);\n\tfound = !!lookup_orphan(c, inum);\n\tspin_unlock(&c->orphan_lock);\n\n\treturn found;\n}\n\nstatic int dbg_ins_check_orphan(struct rb_root *root, ino_t inum)\n{\n\tstruct check_orphan *orphan, *o;\n\tstruct rb_node **p, *parent = NULL;\n\n\torphan = kzalloc(sizeof(struct check_orphan), GFP_NOFS);\n\tif (!orphan)\n\t\treturn -ENOMEM;\n\torphan->inum = inum;\n\n\tp = &root->rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\to = rb_entry(parent, struct check_orphan, rb);\n\t\tif (inum < o->inum)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (inum > o->inum)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\tkfree(orphan);\n\t\t\treturn 0;\n\t\t}\n\t}\n\trb_link_node(&orphan->rb, parent, p);\n\trb_insert_color(&orphan->rb, root);\n\treturn 0;\n}\n\nstatic int dbg_find_check_orphan(struct rb_root *root, ino_t inum)\n{\n\tstruct check_orphan *o;\n\tstruct rb_node *p;\n\n\tp = root->rb_node;\n\twhile (p) {\n\t\to = rb_entry(p, struct check_orphan, rb);\n\t\tif (inum < o->inum)\n\t\t\tp = p->rb_left;\n\t\telse if (inum > o->inum)\n\t\t\tp = p->rb_right;\n\t\telse\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic void dbg_free_check_tree(struct rb_root *root)\n{\n\tstruct check_orphan *o, *n;\n\n\trbtree_postorder_for_each_entry_safe(o, n, root, rb)\n\t\tkfree(o);\n}\n\nstatic int dbg_orphan_check(struct ubifs_info *c, struct ubifs_zbranch *zbr,\n\t\t\t    void *priv)\n{\n\tstruct check_info *ci = priv;\n\tino_t inum;\n\tint err;\n\n\tinum = key_inum(c, &zbr->key);\n\tif (inum != ci->last_ino) {\n\t\t \n\t\tif (key_type(c, &zbr->key) != UBIFS_INO_KEY)\n\t\t\tubifs_err(c, \"found orphan node ino %lu, type %d\",\n\t\t\t\t  (unsigned long)inum, key_type(c, &zbr->key));\n\t\tci->last_ino = inum;\n\t\tci->tot_inos += 1;\n\t\terr = ubifs_tnc_read_node(c, zbr, ci->node);\n\t\tif (err) {\n\t\t\tubifs_err(c, \"node read failed, error %d\", err);\n\t\t\treturn err;\n\t\t}\n\t\tif (ci->node->nlink == 0)\n\t\t\t \n\t\t\tif (!dbg_find_check_orphan(&ci->root, inum) &&\n\t\t\t    !dbg_find_orphan(c, inum)) {\n\t\t\t\tubifs_err(c, \"missing orphan, ino %lu\",\n\t\t\t\t\t  (unsigned long)inum);\n\t\t\t\tci->missing += 1;\n\t\t\t}\n\t}\n\tci->leaf_cnt += 1;\n\treturn 0;\n}\n\nstatic int dbg_read_orphans(struct check_info *ci, struct ubifs_scan_leb *sleb)\n{\n\tstruct ubifs_scan_node *snod;\n\tstruct ubifs_orph_node *orph;\n\tino_t inum;\n\tint i, n, err;\n\n\tlist_for_each_entry(snod, &sleb->nodes, list) {\n\t\tcond_resched();\n\t\tif (snod->type != UBIFS_ORPH_NODE)\n\t\t\tcontinue;\n\t\torph = snod->node;\n\t\tn = (le32_to_cpu(orph->ch.len) - UBIFS_ORPH_NODE_SZ) >> 3;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tinum = le64_to_cpu(orph->inos[i]);\n\t\t\terr = dbg_ins_check_orphan(&ci->root, inum);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int dbg_scan_orphans(struct ubifs_info *c, struct check_info *ci)\n{\n\tint lnum, err = 0;\n\tvoid *buf;\n\n\t \n\tif (c->no_orphs)\n\t\treturn 0;\n\n\tbuf = __vmalloc(c->leb_size, GFP_NOFS);\n\tif (!buf) {\n\t\tubifs_err(c, \"cannot allocate memory to check orphans\");\n\t\treturn 0;\n\t}\n\n\tfor (lnum = c->orph_first; lnum <= c->orph_last; lnum++) {\n\t\tstruct ubifs_scan_leb *sleb;\n\n\t\tsleb = ubifs_scan(c, lnum, 0, buf, 0);\n\t\tif (IS_ERR(sleb)) {\n\t\t\terr = PTR_ERR(sleb);\n\t\t\tbreak;\n\t\t}\n\n\t\terr = dbg_read_orphans(ci, sleb);\n\t\tubifs_scan_destroy(sleb);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tvfree(buf);\n\treturn err;\n}\n\nstatic int dbg_check_orphans(struct ubifs_info *c)\n{\n\tstruct check_info ci;\n\tint err;\n\n\tif (!dbg_is_chk_orph(c))\n\t\treturn 0;\n\n\tci.last_ino = 0;\n\tci.tot_inos = 0;\n\tci.missing  = 0;\n\tci.leaf_cnt = 0;\n\tci.root = RB_ROOT;\n\tci.node = kmalloc(UBIFS_MAX_INO_NODE_SZ, GFP_NOFS);\n\tif (!ci.node) {\n\t\tubifs_err(c, \"out of memory\");\n\t\treturn -ENOMEM;\n\t}\n\n\terr = dbg_scan_orphans(c, &ci);\n\tif (err)\n\t\tgoto out;\n\n\terr = dbg_walk_index(c, &dbg_orphan_check, NULL, &ci);\n\tif (err) {\n\t\tubifs_err(c, \"cannot scan TNC, error %d\", err);\n\t\tgoto out;\n\t}\n\n\tif (ci.missing) {\n\t\tubifs_err(c, \"%lu missing orphan(s)\", ci.missing);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tdbg_cmt(\"last inode number is %lu\", ci.last_ino);\n\tdbg_cmt(\"total number of inodes is %lu\", ci.tot_inos);\n\tdbg_cmt(\"total number of leaf nodes is %llu\", ci.leaf_cnt);\n\nout:\n\tdbg_free_check_tree(&ci.root);\n\tkfree(ci.node);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}