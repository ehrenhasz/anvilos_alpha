{
  "module_name": "ioctl.c",
  "hash_id": "d7cf85f0b930ad0b739465dcddae941973b887bd2c400bff641887b31ff40c1f",
  "original_prompt": "Ingested from linux-6.6.14/fs/ubifs/ioctl.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/compat.h>\n#include <linux/mount.h>\n#include <linux/fileattr.h>\n#include \"ubifs.h\"\n\n \n#define UBIFS_SETTABLE_IOCTL_FLAGS \\\n\t(FS_COMPR_FL | FS_SYNC_FL | FS_APPEND_FL | \\\n\t FS_IMMUTABLE_FL | FS_DIRSYNC_FL)\n\n \n#define UBIFS_GETTABLE_IOCTL_FLAGS \\\n\t(UBIFS_SETTABLE_IOCTL_FLAGS | FS_ENCRYPT_FL)\n\n \nvoid ubifs_set_inode_flags(struct inode *inode)\n{\n\tunsigned int flags = ubifs_inode(inode)->flags;\n\n\tinode->i_flags &= ~(S_SYNC | S_APPEND | S_IMMUTABLE | S_DIRSYNC |\n\t\t\t    S_ENCRYPTED);\n\tif (flags & UBIFS_SYNC_FL)\n\t\tinode->i_flags |= S_SYNC;\n\tif (flags & UBIFS_APPEND_FL)\n\t\tinode->i_flags |= S_APPEND;\n\tif (flags & UBIFS_IMMUTABLE_FL)\n\t\tinode->i_flags |= S_IMMUTABLE;\n\tif (flags & UBIFS_DIRSYNC_FL)\n\t\tinode->i_flags |= S_DIRSYNC;\n\tif (flags & UBIFS_CRYPT_FL)\n\t\tinode->i_flags |= S_ENCRYPTED;\n}\n\n \nstatic int ioctl2ubifs(int ioctl_flags)\n{\n\tint ubifs_flags = 0;\n\n\tif (ioctl_flags & FS_COMPR_FL)\n\t\tubifs_flags |= UBIFS_COMPR_FL;\n\tif (ioctl_flags & FS_SYNC_FL)\n\t\tubifs_flags |= UBIFS_SYNC_FL;\n\tif (ioctl_flags & FS_APPEND_FL)\n\t\tubifs_flags |= UBIFS_APPEND_FL;\n\tif (ioctl_flags & FS_IMMUTABLE_FL)\n\t\tubifs_flags |= UBIFS_IMMUTABLE_FL;\n\tif (ioctl_flags & FS_DIRSYNC_FL)\n\t\tubifs_flags |= UBIFS_DIRSYNC_FL;\n\n\treturn ubifs_flags;\n}\n\n \nstatic int ubifs2ioctl(int ubifs_flags)\n{\n\tint ioctl_flags = 0;\n\n\tif (ubifs_flags & UBIFS_COMPR_FL)\n\t\tioctl_flags |= FS_COMPR_FL;\n\tif (ubifs_flags & UBIFS_SYNC_FL)\n\t\tioctl_flags |= FS_SYNC_FL;\n\tif (ubifs_flags & UBIFS_APPEND_FL)\n\t\tioctl_flags |= FS_APPEND_FL;\n\tif (ubifs_flags & UBIFS_IMMUTABLE_FL)\n\t\tioctl_flags |= FS_IMMUTABLE_FL;\n\tif (ubifs_flags & UBIFS_DIRSYNC_FL)\n\t\tioctl_flags |= FS_DIRSYNC_FL;\n\tif (ubifs_flags & UBIFS_CRYPT_FL)\n\t\tioctl_flags |= FS_ENCRYPT_FL;\n\n\treturn ioctl_flags;\n}\n\nstatic int setflags(struct inode *inode, int flags)\n{\n\tint err, release;\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\tstruct ubifs_info *c = inode->i_sb->s_fs_info;\n\tstruct ubifs_budget_req req = { .dirtied_ino = 1,\n\t\t\t.dirtied_ino_d = ALIGN(ui->data_len, 8) };\n\n\terr = ubifs_budget_space(c, &req);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&ui->ui_mutex);\n\tui->flags &= ~ioctl2ubifs(UBIFS_SETTABLE_IOCTL_FLAGS);\n\tui->flags |= ioctl2ubifs(flags);\n\tubifs_set_inode_flags(inode);\n\tinode_set_ctime_current(inode);\n\trelease = ui->dirty;\n\tmark_inode_dirty_sync(inode);\n\tmutex_unlock(&ui->ui_mutex);\n\n\tif (release)\n\t\tubifs_release_budget(c, &req);\n\tif (IS_SYNC(inode))\n\t\terr = write_inode_now(inode, 1);\n\treturn err;\n}\n\nint ubifs_fileattr_get(struct dentry *dentry, struct fileattr *fa)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tint flags = ubifs2ioctl(ubifs_inode(inode)->flags);\n\n\tif (d_is_special(dentry))\n\t\treturn -ENOTTY;\n\n\tdbg_gen(\"get flags: %#x, i_flags %#x\", flags, inode->i_flags);\n\tfileattr_fill_flags(fa, flags);\n\n\treturn 0;\n}\n\nint ubifs_fileattr_set(struct mnt_idmap *idmap,\n\t\t       struct dentry *dentry, struct fileattr *fa)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tint flags = fa->flags;\n\n\tif (d_is_special(dentry))\n\t\treturn -ENOTTY;\n\n\tif (fileattr_has_fsx(fa))\n\t\treturn -EOPNOTSUPP;\n\n\tif (flags & ~UBIFS_GETTABLE_IOCTL_FLAGS)\n\t\treturn -EOPNOTSUPP;\n\n\tflags &= UBIFS_SETTABLE_IOCTL_FLAGS;\n\n\tif (!S_ISDIR(inode->i_mode))\n\t\tflags &= ~FS_DIRSYNC_FL;\n\n\tdbg_gen(\"set flags: %#x, i_flags %#x\", flags, inode->i_flags);\n\treturn setflags(inode, flags);\n}\n\nlong ubifs_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tint err;\n\tstruct inode *inode = file_inode(file);\n\n\tswitch (cmd) {\n\tcase FS_IOC_SET_ENCRYPTION_POLICY: {\n\t\tstruct ubifs_info *c = inode->i_sb->s_fs_info;\n\n\t\terr = ubifs_enable_encryption(c);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\treturn fscrypt_ioctl_set_policy(file, (const void __user *)arg);\n\t}\n\tcase FS_IOC_GET_ENCRYPTION_POLICY:\n\t\treturn fscrypt_ioctl_get_policy(file, (void __user *)arg);\n\n\tcase FS_IOC_GET_ENCRYPTION_POLICY_EX:\n\t\treturn fscrypt_ioctl_get_policy_ex(file, (void __user *)arg);\n\n\tcase FS_IOC_ADD_ENCRYPTION_KEY:\n\t\treturn fscrypt_ioctl_add_key(file, (void __user *)arg);\n\n\tcase FS_IOC_REMOVE_ENCRYPTION_KEY:\n\t\treturn fscrypt_ioctl_remove_key(file, (void __user *)arg);\n\n\tcase FS_IOC_REMOVE_ENCRYPTION_KEY_ALL_USERS:\n\t\treturn fscrypt_ioctl_remove_key_all_users(file,\n\t\t\t\t\t\t\t  (void __user *)arg);\n\tcase FS_IOC_GET_ENCRYPTION_KEY_STATUS:\n\t\treturn fscrypt_ioctl_get_key_status(file, (void __user *)arg);\n\n\tcase FS_IOC_GET_ENCRYPTION_NONCE:\n\t\treturn fscrypt_ioctl_get_nonce(file, (void __user *)arg);\n\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}\n\n#ifdef CONFIG_COMPAT\nlong ubifs_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase FS_IOC32_GETFLAGS:\n\t\tcmd = FS_IOC_GETFLAGS;\n\t\tbreak;\n\tcase FS_IOC32_SETFLAGS:\n\t\tcmd = FS_IOC_SETFLAGS;\n\t\tbreak;\n\tcase FS_IOC_SET_ENCRYPTION_POLICY:\n\tcase FS_IOC_GET_ENCRYPTION_POLICY:\n\tcase FS_IOC_GET_ENCRYPTION_POLICY_EX:\n\tcase FS_IOC_ADD_ENCRYPTION_KEY:\n\tcase FS_IOC_REMOVE_ENCRYPTION_KEY:\n\tcase FS_IOC_REMOVE_ENCRYPTION_KEY_ALL_USERS:\n\tcase FS_IOC_GET_ENCRYPTION_KEY_STATUS:\n\tcase FS_IOC_GET_ENCRYPTION_NONCE:\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\treturn ubifs_ioctl(file, cmd, (unsigned long)compat_ptr(arg));\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}