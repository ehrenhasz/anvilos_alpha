{
  "module_name": "nfs4proc.c",
  "hash_id": "a53ae33fc8304c0fa85877d40ed502da5daa5136d8adc22803c395244074321b",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfsd/nfs4proc.c",
  "human_readable_source": " \n#include <linux/fs_struct.h>\n#include <linux/file.h>\n#include <linux/falloc.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/namei.h>\n\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_ssc.h>\n\n#include \"idmap.h\"\n#include \"cache.h\"\n#include \"xdr4.h\"\n#include \"vfs.h\"\n#include \"current_stateid.h\"\n#include \"netns.h\"\n#include \"acl.h\"\n#include \"pnfs.h\"\n#include \"trace.h\"\n\nstatic bool inter_copy_offload_enable;\nmodule_param(inter_copy_offload_enable, bool, 0644);\nMODULE_PARM_DESC(inter_copy_offload_enable,\n\t\t \"Enable inter server to server copy offload. Default: false\");\n\n#ifdef CONFIG_NFSD_V4_2_INTER_SSC\nstatic int nfsd4_ssc_umount_timeout = 900000;\t\t \nmodule_param(nfsd4_ssc_umount_timeout, int, 0644);\nMODULE_PARM_DESC(nfsd4_ssc_umount_timeout,\n\t\t\"idle msecs before unmount export from source server\");\n#endif\n\n#define NFSDDBG_FACILITY\t\tNFSDDBG_PROC\n\nstatic u32 nfsd_attrmask[] = {\n\tNFSD_WRITEABLE_ATTRS_WORD0,\n\tNFSD_WRITEABLE_ATTRS_WORD1,\n\tNFSD_WRITEABLE_ATTRS_WORD2\n};\n\nstatic u32 nfsd41_ex_attrmask[] = {\n\tNFSD_SUPPATTR_EXCLCREAT_WORD0,\n\tNFSD_SUPPATTR_EXCLCREAT_WORD1,\n\tNFSD_SUPPATTR_EXCLCREAT_WORD2\n};\n\nstatic __be32\ncheck_attr_support(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\t   u32 *bmval, u32 *writable)\n{\n\tstruct dentry *dentry = cstate->current_fh.fh_dentry;\n\tstruct svc_export *exp = cstate->current_fh.fh_export;\n\n\tif (!nfsd_attrs_supported(cstate->minorversion, bmval))\n\t\treturn nfserr_attrnotsupp;\n\tif ((bmval[0] & FATTR4_WORD0_ACL) && !IS_POSIXACL(d_inode(dentry)))\n\t\treturn nfserr_attrnotsupp;\n\tif ((bmval[2] & FATTR4_WORD2_SECURITY_LABEL) &&\n\t\t\t!(exp->ex_flags & NFSEXP_SECURITY_LABEL))\n\t\treturn nfserr_attrnotsupp;\n\tif (writable && !bmval_is_subset(bmval, writable))\n\t\treturn nfserr_inval;\n\tif (writable && (bmval[2] & FATTR4_WORD2_MODE_UMASK) &&\n\t\t\t(bmval[1] & FATTR4_WORD1_MODE))\n\t\treturn nfserr_inval;\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_check_open_attributes(struct svc_rqst *rqstp,\n\tstruct nfsd4_compound_state *cstate, struct nfsd4_open *open)\n{\n\t__be32 status = nfs_ok;\n\n\tif (open->op_create == NFS4_OPEN_CREATE) {\n\t\tif (open->op_createmode == NFS4_CREATE_UNCHECKED\n\t\t    || open->op_createmode == NFS4_CREATE_GUARDED)\n\t\t\tstatus = check_attr_support(rqstp, cstate,\n\t\t\t\t\topen->op_bmval, nfsd_attrmask);\n\t\telse if (open->op_createmode == NFS4_CREATE_EXCLUSIVE4_1)\n\t\t\tstatus = check_attr_support(rqstp, cstate,\n\t\t\t\t\topen->op_bmval, nfsd41_ex_attrmask);\n\t}\n\n\treturn status;\n}\n\nstatic int\nis_create_with_attrs(struct nfsd4_open *open)\n{\n\treturn open->op_create == NFS4_OPEN_CREATE\n\t\t&& (open->op_createmode == NFS4_CREATE_UNCHECKED\n\t\t    || open->op_createmode == NFS4_CREATE_GUARDED\n\t\t    || open->op_createmode == NFS4_CREATE_EXCLUSIVE4_1);\n}\n\nstatic inline void\nfh_dup2(struct svc_fh *dst, struct svc_fh *src)\n{\n\tfh_put(dst);\n\tdget(src->fh_dentry);\n\tif (src->fh_export)\n\t\texp_get(src->fh_export);\n\t*dst = *src;\n}\n\nstatic __be32\ndo_open_permission(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nfsd4_open *open, int accmode)\n{\n\n\tif (open->op_truncate &&\n\t\t!(open->op_share_access & NFS4_SHARE_ACCESS_WRITE))\n\t\treturn nfserr_inval;\n\n\taccmode |= NFSD_MAY_READ_IF_EXEC;\n\n\tif (open->op_share_access & NFS4_SHARE_ACCESS_READ)\n\t\taccmode |= NFSD_MAY_READ;\n\tif (open->op_share_access & NFS4_SHARE_ACCESS_WRITE)\n\t\taccmode |= (NFSD_MAY_WRITE | NFSD_MAY_TRUNC);\n\tif (open->op_share_deny & NFS4_SHARE_DENY_READ)\n\t\taccmode |= NFSD_MAY_WRITE;\n\n\treturn fh_verify(rqstp, current_fh, S_IFREG, accmode);\n}\n\nstatic __be32 nfsd_check_obj_isreg(struct svc_fh *fh)\n{\n\tumode_t mode = d_inode(fh->fh_dentry)->i_mode;\n\n\tif (S_ISREG(mode))\n\t\treturn nfs_ok;\n\tif (S_ISDIR(mode))\n\t\treturn nfserr_isdir;\n\t \n\treturn nfserr_symlink;\n}\n\nstatic void nfsd4_set_open_owner_reply_cache(struct nfsd4_compound_state *cstate, struct nfsd4_open *open, struct svc_fh *resfh)\n{\n\tif (nfsd4_has_session(cstate))\n\t\treturn;\n\tfh_copy_shallow(&open->op_openowner->oo_owner.so_replay.rp_openfh,\n\t\t\t&resfh->fh_handle);\n}\n\nstatic inline bool nfsd4_create_is_exclusive(int createmode)\n{\n\treturn createmode == NFS4_CREATE_EXCLUSIVE ||\n\t\tcreatemode == NFS4_CREATE_EXCLUSIVE4_1;\n}\n\nstatic __be32\nnfsd4_vfs_create(struct svc_fh *fhp, struct dentry *child,\n\t\t struct nfsd4_open *open)\n{\n\tstruct file *filp;\n\tstruct path path;\n\tint oflags;\n\n\toflags = O_CREAT | O_LARGEFILE;\n\tswitch (open->op_share_access & NFS4_SHARE_ACCESS_BOTH) {\n\tcase NFS4_SHARE_ACCESS_WRITE:\n\t\toflags |= O_WRONLY;\n\t\tbreak;\n\tcase NFS4_SHARE_ACCESS_BOTH:\n\t\toflags |= O_RDWR;\n\t\tbreak;\n\tdefault:\n\t\toflags |= O_RDONLY;\n\t}\n\n\tpath.mnt = fhp->fh_export->ex_path.mnt;\n\tpath.dentry = child;\n\tfilp = dentry_create(&path, oflags, open->op_iattr.ia_mode,\n\t\t\t     current_cred());\n\tif (IS_ERR(filp))\n\t\treturn nfserrno(PTR_ERR(filp));\n\n\topen->op_filp = filp;\n\treturn nfs_ok;\n}\n\n \nstatic __be32\nnfsd4_create_file(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\t  struct svc_fh *resfhp, struct nfsd4_open *open)\n{\n\tstruct iattr *iap = &open->op_iattr;\n\tstruct nfsd_attrs attrs = {\n\t\t.na_iattr\t= iap,\n\t\t.na_seclabel\t= &open->op_label,\n\t};\n\tstruct dentry *parent, *child;\n\t__u32 v_mtime, v_atime;\n\tstruct inode *inode;\n\t__be32 status;\n\tint host_err;\n\n\tif (isdotent(open->op_fname, open->op_fnamelen))\n\t\treturn nfserr_exist;\n\tif (!(iap->ia_valid & ATTR_MODE))\n\t\tiap->ia_mode = 0;\n\n\tstatus = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_EXEC);\n\tif (status != nfs_ok)\n\t\treturn status;\n\tparent = fhp->fh_dentry;\n\tinode = d_inode(parent);\n\n\thost_err = fh_want_write(fhp);\n\tif (host_err)\n\t\treturn nfserrno(host_err);\n\n\tif (is_create_with_attrs(open))\n\t\tnfsd4_acl_to_attr(NF4REG, open->op_acl, &attrs);\n\n\tinode_lock_nested(inode, I_MUTEX_PARENT);\n\n\tchild = lookup_one_len(open->op_fname, parent, open->op_fnamelen);\n\tif (IS_ERR(child)) {\n\t\tstatus = nfserrno(PTR_ERR(child));\n\t\tgoto out;\n\t}\n\n\tif (d_really_is_negative(child)) {\n\t\tstatus = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_CREATE);\n\t\tif (status != nfs_ok)\n\t\t\tgoto out;\n\t}\n\n\tstatus = fh_compose(resfhp, fhp->fh_export, child, fhp);\n\tif (status != nfs_ok)\n\t\tgoto out;\n\n\tv_mtime = 0;\n\tv_atime = 0;\n\tif (nfsd4_create_is_exclusive(open->op_createmode)) {\n\t\tu32 *verifier = (u32 *)open->op_verf.data;\n\n\t\t \n\t\tv_mtime = verifier[0] & 0x7fffffff;\n\t\tv_atime = verifier[1] & 0x7fffffff;\n\t}\n\n\tif (d_really_is_positive(child)) {\n\t\t \n\t\tstatus = fh_fill_both_attrs(fhp);\n\t\tif (status != nfs_ok)\n\t\t\tgoto out;\n\n\t\tswitch (open->op_createmode) {\n\t\tcase NFS4_CREATE_UNCHECKED:\n\t\t\tif (!d_is_reg(child))\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\topen->op_truncate = (iap->ia_valid & ATTR_SIZE) &&\n\t\t\t\t\t\t!iap->ia_size;\n\t\t\tbreak;\n\t\tcase NFS4_CREATE_GUARDED:\n\t\t\tstatus = nfserr_exist;\n\t\t\tbreak;\n\t\tcase NFS4_CREATE_EXCLUSIVE:\n\t\t\tif (d_inode(child)->i_mtime.tv_sec == v_mtime &&\n\t\t\t    d_inode(child)->i_atime.tv_sec == v_atime &&\n\t\t\t    d_inode(child)->i_size == 0) {\n\t\t\t\topen->op_created = true;\n\t\t\t\tbreak;\t\t \n\t\t\t}\n\t\t\tstatus = nfserr_exist;\n\t\t\tbreak;\n\t\tcase NFS4_CREATE_EXCLUSIVE4_1:\n\t\t\tif (d_inode(child)->i_mtime.tv_sec == v_mtime &&\n\t\t\t    d_inode(child)->i_atime.tv_sec == v_atime &&\n\t\t\t    d_inode(child)->i_size == 0) {\n\t\t\t\topen->op_created = true;\n\t\t\t\tgoto set_attr;\t \n\t\t\t}\n\t\t\tstatus = nfserr_exist;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tif (!IS_POSIXACL(inode))\n\t\tiap->ia_mode &= ~current_umask();\n\n\tstatus = fh_fill_pre_attrs(fhp);\n\tif (status != nfs_ok)\n\t\tgoto out;\n\tstatus = nfsd4_vfs_create(fhp, child, open);\n\tif (status != nfs_ok)\n\t\tgoto out;\n\topen->op_created = true;\n\tfh_fill_post_attrs(fhp);\n\n\t \n\tif ((iap->ia_valid & ATTR_SIZE) && (iap->ia_size == 0))\n\t\tiap->ia_valid &= ~ATTR_SIZE;\n\tif (nfsd4_create_is_exclusive(open->op_createmode)) {\n\t\tiap->ia_valid = ATTR_MTIME | ATTR_ATIME |\n\t\t\t\tATTR_MTIME_SET|ATTR_ATIME_SET;\n\t\tiap->ia_mtime.tv_sec = v_mtime;\n\t\tiap->ia_atime.tv_sec = v_atime;\n\t\tiap->ia_mtime.tv_nsec = 0;\n\t\tiap->ia_atime.tv_nsec = 0;\n\t}\n\nset_attr:\n\tstatus = nfsd_create_setattr(rqstp, fhp, resfhp, &attrs);\n\n\tif (attrs.na_labelerr)\n\t\topen->op_bmval[2] &= ~FATTR4_WORD2_SECURITY_LABEL;\n\tif (attrs.na_aclerr)\n\t\topen->op_bmval[0] &= ~FATTR4_WORD0_ACL;\nout:\n\tinode_unlock(inode);\n\tnfsd_attrs_free(&attrs);\n\tif (child && !IS_ERR(child))\n\t\tdput(child);\n\tfh_drop_write(fhp);\n\treturn status;\n}\n\n \nstatic void\nset_change_info(struct nfsd4_change_info *cinfo, struct svc_fh *fhp)\n{\n\tcinfo->atomic = (u32)(fhp->fh_pre_saved && fhp->fh_post_saved && !fhp->fh_no_atomic_attr);\n\tcinfo->before_change = fhp->fh_pre_change;\n\tcinfo->after_change = fhp->fh_post_change;\n\n\t \n\tif (WARN_ON_ONCE(!fhp->fh_pre_saved))\n\t\tcinfo->before_change = 0;\n\tif (!fhp->fh_post_saved)\n\t\tcinfo->after_change = cinfo->before_change + 1;\n}\n\nstatic __be32\ndo_open_lookup(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate, struct nfsd4_open *open, struct svc_fh **resfh)\n{\n\tstruct svc_fh *current_fh = &cstate->current_fh;\n\tint accmode;\n\t__be32 status;\n\n\t*resfh = kmalloc(sizeof(struct svc_fh), GFP_KERNEL);\n\tif (!*resfh)\n\t\treturn nfserr_jukebox;\n\tfh_init(*resfh, NFS4_FHSIZE);\n\topen->op_truncate = false;\n\n\tif (open->op_create) {\n\t\t \n\n\t\tcurrent->fs->umask = open->op_umask;\n\t\tstatus = nfsd4_create_file(rqstp, current_fh, *resfh, open);\n\t\tcurrent->fs->umask = 0;\n\n\t\t \n\t\tif (nfsd4_create_is_exclusive(open->op_createmode) && status == 0)\n\t\t\topen->op_bmval[1] |= (FATTR4_WORD1_TIME_ACCESS |\n\t\t\t\t\t\tFATTR4_WORD1_TIME_MODIFY);\n\t} else {\n\t\tstatus = nfsd_lookup(rqstp, current_fh,\n\t\t\t\t     open->op_fname, open->op_fnamelen, *resfh);\n\t\tif (status == nfs_ok)\n\t\t\t \n\t\t\tstatus = fh_fill_both_attrs(current_fh);\n\t}\n\tif (status)\n\t\tgoto out;\n\tstatus = nfsd_check_obj_isreg(*resfh);\n\tif (status)\n\t\tgoto out;\n\n\tnfsd4_set_open_owner_reply_cache(cstate, open, *resfh);\n\taccmode = NFSD_MAY_NOP;\n\tif (open->op_created ||\n\t\t\topen->op_claim_type == NFS4_OPEN_CLAIM_DELEGATE_CUR)\n\t\taccmode |= NFSD_MAY_OWNER_OVERRIDE;\n\tstatus = do_open_permission(rqstp, *resfh, open, accmode);\n\tset_change_info(&open->op_cinfo, current_fh);\nout:\n\treturn status;\n}\n\nstatic __be32\ndo_open_fhandle(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate, struct nfsd4_open *open)\n{\n\tstruct svc_fh *current_fh = &cstate->current_fh;\n\tint accmode = 0;\n\n\t \n\n\tmemset(&open->op_cinfo, 0, sizeof(struct nfsd4_change_info));\n\n\tnfsd4_set_open_owner_reply_cache(cstate, open, current_fh);\n\n\topen->op_truncate = (open->op_iattr.ia_valid & ATTR_SIZE) &&\n\t\t(open->op_iattr.ia_size == 0);\n\t \n\tif (open->op_claim_type == NFS4_OPEN_CLAIM_DELEG_CUR_FH)\n\t\taccmode = NFSD_MAY_OWNER_OVERRIDE;\n\n\treturn do_open_permission(rqstp, current_fh, open, accmode);\n}\n\nstatic void\ncopy_clientid(clientid_t *clid, struct nfsd4_session *session)\n{\n\tstruct nfsd4_sessionid *sid =\n\t\t\t(struct nfsd4_sessionid *)session->se_sessionid.data;\n\n\tclid->cl_boot = sid->clientid.cl_boot;\n\tclid->cl_id = sid->clientid.cl_id;\n}\n\nstatic __be32\nnfsd4_open(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t   union nfsd4_op_u *u)\n{\n\tstruct nfsd4_open *open = &u->open;\n\t__be32 status;\n\tstruct svc_fh *resfh = NULL;\n\tstruct net *net = SVC_NET(rqstp);\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tbool reclaim = false;\n\n\tdprintk(\"NFSD: nfsd4_open filename %.*s op_openowner %p\\n\",\n\t\t(int)open->op_fnamelen, open->op_fname,\n\t\topen->op_openowner);\n\n\topen->op_filp = NULL;\n\topen->op_rqstp = rqstp;\n\n\t \n\tif (open->op_create && open->op_claim_type != NFS4_OPEN_CLAIM_NULL)\n\t\treturn nfserr_inval;\n\n\topen->op_created = false;\n\t \n\tif (nfsd4_has_session(cstate) &&\n\t    !test_bit(NFSD4_CLIENT_RECLAIM_COMPLETE, &cstate->clp->cl_flags) &&\n\t    open->op_claim_type != NFS4_OPEN_CLAIM_PREVIOUS)\n\t\treturn nfserr_grace;\n\n\tif (nfsd4_has_session(cstate))\n\t\tcopy_clientid(&open->op_clientid, cstate->session);\n\n\t \n\tstatus = nfsd4_process_open1(cstate, open, nn);\n\tif (status == nfserr_replay_me) {\n\t\tstruct nfs4_replay *rp = &open->op_openowner->oo_owner.so_replay;\n\t\tfh_put(&cstate->current_fh);\n\t\tfh_copy_shallow(&cstate->current_fh.fh_handle,\n\t\t\t\t&rp->rp_openfh);\n\t\tstatus = fh_verify(rqstp, &cstate->current_fh, 0, NFSD_MAY_NOP);\n\t\tif (status)\n\t\t\tdprintk(\"nfsd4_open: replay failed\"\n\t\t\t\t\" restoring previous filehandle\\n\");\n\t\telse\n\t\t\tstatus = nfserr_replay_me;\n\t}\n\tif (status)\n\t\tgoto out;\n\tif (open->op_xdr_error) {\n\t\tstatus = open->op_xdr_error;\n\t\tgoto out;\n\t}\n\n\tstatus = nfsd4_check_open_attributes(rqstp, cstate, open);\n\tif (status)\n\t\tgoto out;\n\n\t \n\tstatus = nfserr_grace;\n\tif (opens_in_grace(net) && open->op_claim_type != NFS4_OPEN_CLAIM_PREVIOUS)\n\t\tgoto out;\n\tstatus = nfserr_no_grace;\n\tif (!opens_in_grace(net) && open->op_claim_type == NFS4_OPEN_CLAIM_PREVIOUS)\n\t\tgoto out;\n\n\tswitch (open->op_claim_type) {\n\tcase NFS4_OPEN_CLAIM_DELEGATE_CUR:\n\tcase NFS4_OPEN_CLAIM_NULL:\n\t\tstatus = do_open_lookup(rqstp, cstate, open, &resfh);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase NFS4_OPEN_CLAIM_PREVIOUS:\n\t\tstatus = nfs4_check_open_reclaim(cstate->clp);\n\t\tif (status)\n\t\t\tgoto out;\n\t\topen->op_openowner->oo_flags |= NFS4_OO_CONFIRMED;\n\t\treclaim = true;\n\t\tfallthrough;\n\tcase NFS4_OPEN_CLAIM_FH:\n\tcase NFS4_OPEN_CLAIM_DELEG_CUR_FH:\n\t\tstatus = do_open_fhandle(rqstp, cstate, open);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tresfh = &cstate->current_fh;\n\t\tbreak;\n\tcase NFS4_OPEN_CLAIM_DELEG_PREV_FH:\n\tcase NFS4_OPEN_CLAIM_DELEGATE_PREV:\n\t\tstatus = nfserr_notsupp;\n\t\tgoto out;\n\tdefault:\n\t\tstatus = nfserr_inval;\n\t\tgoto out;\n\t}\n\n\tstatus = nfsd4_process_open2(rqstp, resfh, open);\n\tif (status && open->op_created)\n\t\tpr_warn(\"nfsd4_process_open2 failed to open newly-created file: status=%u\\n\",\n\t\t\tbe32_to_cpu(status));\n\tif (reclaim && !status)\n\t\tnn->somebody_reclaimed = true;\nout:\n\tif (open->op_filp) {\n\t\tfput(open->op_filp);\n\t\topen->op_filp = NULL;\n\t}\n\tif (resfh && resfh != &cstate->current_fh) {\n\t\tfh_dup2(&cstate->current_fh, resfh);\n\t\tfh_put(resfh);\n\t\tkfree(resfh);\n\t}\n\tnfsd4_cleanup_open_state(cstate, open);\n\tnfsd4_bump_seqid(cstate, status);\n\treturn status;\n}\n\n \nstatic __be32 nfsd4_open_omfg(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate, struct nfsd4_op *op)\n{\n\tstruct nfsd4_open *open = &op->u.open;\n\n\tif (!seqid_mutating_err(ntohl(op->status)))\n\t\treturn op->status;\n\tif (nfsd4_has_session(cstate))\n\t\treturn op->status;\n\topen->op_xdr_error = op->status;\n\treturn nfsd4_open(rqstp, cstate, &op->u);\n}\n\n \nstatic __be32\nnfsd4_getfh(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t    union nfsd4_op_u *u)\n{\n\tu->getfh = &cstate->current_fh;\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_putfh(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t    union nfsd4_op_u *u)\n{\n\tstruct nfsd4_putfh *putfh = &u->putfh;\n\t__be32 ret;\n\n\tfh_put(&cstate->current_fh);\n\tcstate->current_fh.fh_handle.fh_size = putfh->pf_fhlen;\n\tmemcpy(&cstate->current_fh.fh_handle.fh_raw, putfh->pf_fhval,\n\t       putfh->pf_fhlen);\n\tret = fh_verify(rqstp, &cstate->current_fh, 0, NFSD_MAY_BYPASS_GSS);\n#ifdef CONFIG_NFSD_V4_2_INTER_SSC\n\tif (ret == nfserr_stale && putfh->no_verify) {\n\t\tSET_FH_FLAG(&cstate->current_fh, NFSD4_FH_FOREIGN);\n\t\tret = 0;\n\t}\n#endif\n\treturn ret;\n}\n\nstatic __be32\nnfsd4_putrootfh(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\tunion nfsd4_op_u *u)\n{\n\tfh_put(&cstate->current_fh);\n\n\treturn exp_pseudoroot(rqstp, &cstate->current_fh);\n}\n\nstatic __be32\nnfsd4_restorefh(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\tunion nfsd4_op_u *u)\n{\n\tif (!cstate->save_fh.fh_dentry)\n\t\treturn nfserr_restorefh;\n\n\tfh_dup2(&cstate->current_fh, &cstate->save_fh);\n\tif (HAS_CSTATE_FLAG(cstate, SAVED_STATE_ID_FLAG)) {\n\t\tmemcpy(&cstate->current_stateid, &cstate->save_stateid, sizeof(stateid_t));\n\t\tSET_CSTATE_FLAG(cstate, CURRENT_STATE_ID_FLAG);\n\t}\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_savefh(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t     union nfsd4_op_u *u)\n{\n\tfh_dup2(&cstate->save_fh, &cstate->current_fh);\n\tif (HAS_CSTATE_FLAG(cstate, CURRENT_STATE_ID_FLAG)) {\n\t\tmemcpy(&cstate->save_stateid, &cstate->current_stateid, sizeof(stateid_t));\n\t\tSET_CSTATE_FLAG(cstate, SAVED_STATE_ID_FLAG);\n\t}\n\treturn nfs_ok;\n}\n\n \nstatic __be32\nnfsd4_access(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t     union nfsd4_op_u *u)\n{\n\tstruct nfsd4_access *access = &u->access;\n\tu32 access_full;\n\n\taccess_full = NFS3_ACCESS_FULL;\n\tif (cstate->minorversion >= 2)\n\t\taccess_full |= NFS4_ACCESS_XALIST | NFS4_ACCESS_XAREAD |\n\t\t\t       NFS4_ACCESS_XAWRITE;\n\n\tif (access->ac_req_access & ~access_full)\n\t\treturn nfserr_inval;\n\n\taccess->ac_resp_access = access->ac_req_access;\n\treturn nfsd_access(rqstp, &cstate->current_fh, &access->ac_resp_access,\n\t\t\t   &access->ac_supported);\n}\n\nstatic void gen_boot_verifier(nfs4_verifier *verifier, struct net *net)\n{\n\t__be32 *verf = (__be32 *)verifier->data;\n\n\tBUILD_BUG_ON(2*sizeof(*verf) != sizeof(verifier->data));\n\n\tnfsd_copy_write_verifier(verf, net_generic(net, nfsd_net_id));\n}\n\nstatic __be32\nnfsd4_commit(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t     union nfsd4_op_u *u)\n{\n\tstruct nfsd4_commit *commit = &u->commit;\n\tstruct nfsd_file *nf;\n\t__be32 status;\n\n\tstatus = nfsd_file_acquire(rqstp, &cstate->current_fh, NFSD_MAY_WRITE |\n\t\t\t\t   NFSD_MAY_NOT_BREAK_LEASE, &nf);\n\tif (status != nfs_ok)\n\t\treturn status;\n\n\tstatus = nfsd_commit(rqstp, &cstate->current_fh, nf, commit->co_offset,\n\t\t\t     commit->co_count,\n\t\t\t     (__be32 *)commit->co_verf.data);\n\tnfsd_file_put(nf);\n\treturn status;\n}\n\nstatic __be32\nnfsd4_create(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t     union nfsd4_op_u *u)\n{\n\tstruct nfsd4_create *create = &u->create;\n\tstruct nfsd_attrs attrs = {\n\t\t.na_iattr\t= &create->cr_iattr,\n\t\t.na_seclabel\t= &create->cr_label,\n\t};\n\tstruct svc_fh resfh;\n\t__be32 status;\n\tdev_t rdev;\n\n\tfh_init(&resfh, NFS4_FHSIZE);\n\n\tstatus = fh_verify(rqstp, &cstate->current_fh, S_IFDIR, NFSD_MAY_NOP);\n\tif (status)\n\t\treturn status;\n\n\tstatus = check_attr_support(rqstp, cstate, create->cr_bmval,\n\t\t\t\t    nfsd_attrmask);\n\tif (status)\n\t\treturn status;\n\n\tstatus = nfsd4_acl_to_attr(create->cr_type, create->cr_acl, &attrs);\n\tcurrent->fs->umask = create->cr_umask;\n\tswitch (create->cr_type) {\n\tcase NF4LNK:\n\t\tstatus = nfsd_symlink(rqstp, &cstate->current_fh,\n\t\t\t\t      create->cr_name, create->cr_namelen,\n\t\t\t\t      create->cr_data, &attrs, &resfh);\n\t\tbreak;\n\n\tcase NF4BLK:\n\t\tstatus = nfserr_inval;\n\t\trdev = MKDEV(create->cr_specdata1, create->cr_specdata2);\n\t\tif (MAJOR(rdev) != create->cr_specdata1 ||\n\t\t    MINOR(rdev) != create->cr_specdata2)\n\t\t\tgoto out_umask;\n\t\tstatus = nfsd_create(rqstp, &cstate->current_fh,\n\t\t\t\t     create->cr_name, create->cr_namelen,\n\t\t\t\t     &attrs, S_IFBLK, rdev, &resfh);\n\t\tbreak;\n\n\tcase NF4CHR:\n\t\tstatus = nfserr_inval;\n\t\trdev = MKDEV(create->cr_specdata1, create->cr_specdata2);\n\t\tif (MAJOR(rdev) != create->cr_specdata1 ||\n\t\t    MINOR(rdev) != create->cr_specdata2)\n\t\t\tgoto out_umask;\n\t\tstatus = nfsd_create(rqstp, &cstate->current_fh,\n\t\t\t\t     create->cr_name, create->cr_namelen,\n\t\t\t\t     &attrs, S_IFCHR, rdev, &resfh);\n\t\tbreak;\n\n\tcase NF4SOCK:\n\t\tstatus = nfsd_create(rqstp, &cstate->current_fh,\n\t\t\t\t     create->cr_name, create->cr_namelen,\n\t\t\t\t     &attrs, S_IFSOCK, 0, &resfh);\n\t\tbreak;\n\n\tcase NF4FIFO:\n\t\tstatus = nfsd_create(rqstp, &cstate->current_fh,\n\t\t\t\t     create->cr_name, create->cr_namelen,\n\t\t\t\t     &attrs, S_IFIFO, 0, &resfh);\n\t\tbreak;\n\n\tcase NF4DIR:\n\t\tcreate->cr_iattr.ia_valid &= ~ATTR_SIZE;\n\t\tstatus = nfsd_create(rqstp, &cstate->current_fh,\n\t\t\t\t     create->cr_name, create->cr_namelen,\n\t\t\t\t     &attrs, S_IFDIR, 0, &resfh);\n\t\tbreak;\n\n\tdefault:\n\t\tstatus = nfserr_badtype;\n\t}\n\n\tif (status)\n\t\tgoto out;\n\n\tif (attrs.na_labelerr)\n\t\tcreate->cr_bmval[2] &= ~FATTR4_WORD2_SECURITY_LABEL;\n\tif (attrs.na_aclerr)\n\t\tcreate->cr_bmval[0] &= ~FATTR4_WORD0_ACL;\n\tset_change_info(&create->cr_cinfo, &cstate->current_fh);\n\tfh_dup2(&cstate->current_fh, &resfh);\nout:\n\tfh_put(&resfh);\nout_umask:\n\tcurrent->fs->umask = 0;\n\tnfsd_attrs_free(&attrs);\n\treturn status;\n}\n\nstatic __be32\nnfsd4_getattr(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t      union nfsd4_op_u *u)\n{\n\tstruct nfsd4_getattr *getattr = &u->getattr;\n\t__be32 status;\n\n\tstatus = fh_verify(rqstp, &cstate->current_fh, 0, NFSD_MAY_NOP);\n\tif (status)\n\t\treturn status;\n\n\tif (getattr->ga_bmval[1] & NFSD_WRITEONLY_ATTRS_WORD1)\n\t\treturn nfserr_inval;\n\n\tgetattr->ga_bmval[0] &= nfsd_suppattrs[cstate->minorversion][0];\n\tgetattr->ga_bmval[1] &= nfsd_suppattrs[cstate->minorversion][1];\n\tgetattr->ga_bmval[2] &= nfsd_suppattrs[cstate->minorversion][2];\n\n\tgetattr->ga_fhp = &cstate->current_fh;\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_link(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t   union nfsd4_op_u *u)\n{\n\tstruct nfsd4_link *link = &u->link;\n\t__be32 status;\n\n\tstatus = nfsd_link(rqstp, &cstate->current_fh,\n\t\t\t   link->li_name, link->li_namelen, &cstate->save_fh);\n\tif (!status)\n\t\tset_change_info(&link->li_cinfo, &cstate->current_fh);\n\treturn status;\n}\n\nstatic __be32 nfsd4_do_lookupp(struct svc_rqst *rqstp, struct svc_fh *fh)\n{\n\tstruct svc_fh tmp_fh;\n\t__be32 ret;\n\n\tfh_init(&tmp_fh, NFS4_FHSIZE);\n\tret = exp_pseudoroot(rqstp, &tmp_fh);\n\tif (ret)\n\t\treturn ret;\n\tif (tmp_fh.fh_dentry == fh->fh_dentry) {\n\t\tfh_put(&tmp_fh);\n\t\treturn nfserr_noent;\n\t}\n\tfh_put(&tmp_fh);\n\treturn nfsd_lookup(rqstp, fh, \"..\", 2, fh);\n}\n\nstatic __be32\nnfsd4_lookupp(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t      union nfsd4_op_u *u)\n{\n\treturn nfsd4_do_lookupp(rqstp, &cstate->current_fh);\n}\n\nstatic __be32\nnfsd4_lookup(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t     union nfsd4_op_u *u)\n{\n\treturn nfsd_lookup(rqstp, &cstate->current_fh,\n\t\t\t   u->lookup.lo_name, u->lookup.lo_len,\n\t\t\t   &cstate->current_fh);\n}\n\nstatic __be32\nnfsd4_read(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t   union nfsd4_op_u *u)\n{\n\tstruct nfsd4_read *read = &u->read;\n\t__be32 status;\n\n\tread->rd_nf = NULL;\n\n\ttrace_nfsd_read_start(rqstp, &cstate->current_fh,\n\t\t\t      read->rd_offset, read->rd_length);\n\n\tread->rd_length = min_t(u32, read->rd_length, svc_max_payload(rqstp));\n\tif (read->rd_offset > (u64)OFFSET_MAX)\n\t\tread->rd_offset = (u64)OFFSET_MAX;\n\tif (read->rd_offset + read->rd_length > (u64)OFFSET_MAX)\n\t\tread->rd_length = (u64)OFFSET_MAX - read->rd_offset;\n\n\t \n\tif (!nfsd4_last_compound_op(rqstp))\n\t\tclear_bit(RQ_SPLICE_OK, &rqstp->rq_flags);\n\n\t \n\tstatus = nfs4_preprocess_stateid_op(rqstp, cstate, &cstate->current_fh,\n\t\t\t\t\t&read->rd_stateid, RD_STATE,\n\t\t\t\t\t&read->rd_nf, NULL);\n\n\tread->rd_rqstp = rqstp;\n\tread->rd_fhp = &cstate->current_fh;\n\treturn status;\n}\n\n\nstatic void\nnfsd4_read_release(union nfsd4_op_u *u)\n{\n\tif (u->read.rd_nf)\n\t\tnfsd_file_put(u->read.rd_nf);\n\ttrace_nfsd_read_done(u->read.rd_rqstp, u->read.rd_fhp,\n\t\t\t     u->read.rd_offset, u->read.rd_length);\n}\n\nstatic __be32\nnfsd4_readdir(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t      union nfsd4_op_u *u)\n{\n\tstruct nfsd4_readdir *readdir = &u->readdir;\n\tu64 cookie = readdir->rd_cookie;\n\tstatic const nfs4_verifier zeroverf;\n\n\t \n\n\tif (readdir->rd_bmval[1] & NFSD_WRITEONLY_ATTRS_WORD1)\n\t\treturn nfserr_inval;\n\n\treaddir->rd_bmval[0] &= nfsd_suppattrs[cstate->minorversion][0];\n\treaddir->rd_bmval[1] &= nfsd_suppattrs[cstate->minorversion][1];\n\treaddir->rd_bmval[2] &= nfsd_suppattrs[cstate->minorversion][2];\n\n\tif ((cookie == 1) || (cookie == 2) ||\n\t    (cookie == 0 && memcmp(readdir->rd_verf.data, zeroverf.data, NFS4_VERIFIER_SIZE)))\n\t\treturn nfserr_bad_cookie;\n\n\treaddir->rd_rqstp = rqstp;\n\treaddir->rd_fhp = &cstate->current_fh;\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_readlink(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t       union nfsd4_op_u *u)\n{\n\tu->readlink.rl_rqstp = rqstp;\n\tu->readlink.rl_fhp = &cstate->current_fh;\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_remove(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t     union nfsd4_op_u *u)\n{\n\tstruct nfsd4_remove *remove = &u->remove;\n\t__be32 status;\n\n\tif (opens_in_grace(SVC_NET(rqstp)))\n\t\treturn nfserr_grace;\n\tstatus = nfsd_unlink(rqstp, &cstate->current_fh, 0,\n\t\t\t     remove->rm_name, remove->rm_namelen);\n\tif (!status)\n\t\tset_change_info(&remove->rm_cinfo, &cstate->current_fh);\n\treturn status;\n}\n\nstatic __be32\nnfsd4_rename(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t     union nfsd4_op_u *u)\n{\n\tstruct nfsd4_rename *rename = &u->rename;\n\t__be32 status;\n\n\tif (opens_in_grace(SVC_NET(rqstp)))\n\t\treturn nfserr_grace;\n\tstatus = nfsd_rename(rqstp, &cstate->save_fh, rename->rn_sname,\n\t\t\t     rename->rn_snamelen, &cstate->current_fh,\n\t\t\t     rename->rn_tname, rename->rn_tnamelen);\n\tif (status)\n\t\treturn status;\n\tset_change_info(&rename->rn_sinfo, &cstate->save_fh);\n\tset_change_info(&rename->rn_tinfo, &cstate->current_fh);\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_secinfo(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t      union nfsd4_op_u *u)\n{\n\tstruct nfsd4_secinfo *secinfo = &u->secinfo;\n\tstruct svc_export *exp;\n\tstruct dentry *dentry;\n\t__be32 err;\n\n\terr = fh_verify(rqstp, &cstate->current_fh, S_IFDIR, NFSD_MAY_EXEC);\n\tif (err)\n\t\treturn err;\n\terr = nfsd_lookup_dentry(rqstp, &cstate->current_fh,\n\t\t\t\t    secinfo->si_name, secinfo->si_namelen,\n\t\t\t\t    &exp, &dentry);\n\tif (err)\n\t\treturn err;\n\tif (d_really_is_negative(dentry)) {\n\t\texp_put(exp);\n\t\terr = nfserr_noent;\n\t} else\n\t\tsecinfo->si_exp = exp;\n\tdput(dentry);\n\tif (cstate->minorversion)\n\t\t \n\t\tfh_put(&cstate->current_fh);\n\treturn err;\n}\n\nstatic __be32\nnfsd4_secinfo_no_name(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\tunion nfsd4_op_u *u)\n{\n\t__be32 err;\n\n\tswitch (u->secinfo_no_name.sin_style) {\n\tcase NFS4_SECINFO_STYLE4_CURRENT_FH:\n\t\tbreak;\n\tcase NFS4_SECINFO_STYLE4_PARENT:\n\t\terr = nfsd4_do_lookupp(rqstp, &cstate->current_fh);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tdefault:\n\t\treturn nfserr_inval;\n\t}\n\n\tu->secinfo_no_name.sin_exp = exp_get(cstate->current_fh.fh_export);\n\tfh_put(&cstate->current_fh);\n\treturn nfs_ok;\n}\n\nstatic void\nnfsd4_secinfo_release(union nfsd4_op_u *u)\n{\n\tif (u->secinfo.si_exp)\n\t\texp_put(u->secinfo.si_exp);\n}\n\nstatic void\nnfsd4_secinfo_no_name_release(union nfsd4_op_u *u)\n{\n\tif (u->secinfo_no_name.sin_exp)\n\t\texp_put(u->secinfo_no_name.sin_exp);\n}\n\nstatic __be32\nnfsd4_setattr(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t      union nfsd4_op_u *u)\n{\n\tstruct nfsd4_setattr *setattr = &u->setattr;\n\tstruct nfsd_attrs attrs = {\n\t\t.na_iattr\t= &setattr->sa_iattr,\n\t\t.na_seclabel\t= &setattr->sa_label,\n\t};\n\tstruct inode *inode;\n\t__be32 status = nfs_ok;\n\tint err;\n\n\tif (setattr->sa_iattr.ia_valid & ATTR_SIZE) {\n\t\tstatus = nfs4_preprocess_stateid_op(rqstp, cstate,\n\t\t\t\t&cstate->current_fh, &setattr->sa_stateid,\n\t\t\t\tWR_STATE, NULL, NULL);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\terr = fh_want_write(&cstate->current_fh);\n\tif (err)\n\t\treturn nfserrno(err);\n\tstatus = nfs_ok;\n\n\tstatus = check_attr_support(rqstp, cstate, setattr->sa_bmval,\n\t\t\t\t    nfsd_attrmask);\n\tif (status)\n\t\tgoto out;\n\n\tinode = cstate->current_fh.fh_dentry->d_inode;\n\tstatus = nfsd4_acl_to_attr(S_ISDIR(inode->i_mode) ? NF4DIR : NF4REG,\n\t\t\t\t   setattr->sa_acl, &attrs);\n\n\tif (status)\n\t\tgoto out;\n\tstatus = nfsd_setattr(rqstp, &cstate->current_fh, &attrs,\n\t\t\t\t0, (time64_t)0);\n\tif (!status)\n\t\tstatus = nfserrno(attrs.na_labelerr);\n\tif (!status)\n\t\tstatus = nfserrno(attrs.na_aclerr);\nout:\n\tnfsd_attrs_free(&attrs);\n\tfh_drop_write(&cstate->current_fh);\n\treturn status;\n}\n\nstatic __be32\nnfsd4_write(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t    union nfsd4_op_u *u)\n{\n\tstruct nfsd4_write *write = &u->write;\n\tstateid_t *stateid = &write->wr_stateid;\n\tstruct nfsd_file *nf = NULL;\n\t__be32 status = nfs_ok;\n\tunsigned long cnt;\n\tint nvecs;\n\n\tif (write->wr_offset > (u64)OFFSET_MAX ||\n\t    write->wr_offset + write->wr_buflen > (u64)OFFSET_MAX)\n\t\treturn nfserr_fbig;\n\n\tcnt = write->wr_buflen;\n\ttrace_nfsd_write_start(rqstp, &cstate->current_fh,\n\t\t\t       write->wr_offset, cnt);\n\tstatus = nfs4_preprocess_stateid_op(rqstp, cstate, &cstate->current_fh,\n\t\t\t\t\t\tstateid, WR_STATE, &nf, NULL);\n\tif (status)\n\t\treturn status;\n\n\twrite->wr_how_written = write->wr_stable_how;\n\n\tnvecs = svc_fill_write_vector(rqstp, &write->wr_payload);\n\tWARN_ON_ONCE(nvecs > ARRAY_SIZE(rqstp->rq_vec));\n\n\tstatus = nfsd_vfs_write(rqstp, &cstate->current_fh, nf,\n\t\t\t\twrite->wr_offset, rqstp->rq_vec, nvecs, &cnt,\n\t\t\t\twrite->wr_how_written,\n\t\t\t\t(__be32 *)write->wr_verifier.data);\n\tnfsd_file_put(nf);\n\n\twrite->wr_bytes_written = cnt;\n\ttrace_nfsd_write_done(rqstp, &cstate->current_fh,\n\t\t\t      write->wr_offset, cnt);\n\treturn status;\n}\n\nstatic __be32\nnfsd4_verify_copy(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\t  stateid_t *src_stateid, struct nfsd_file **src,\n\t\t  stateid_t *dst_stateid, struct nfsd_file **dst)\n{\n\t__be32 status;\n\n\tif (!cstate->save_fh.fh_dentry)\n\t\treturn nfserr_nofilehandle;\n\n\tstatus = nfs4_preprocess_stateid_op(rqstp, cstate, &cstate->save_fh,\n\t\t\t\t\t    src_stateid, RD_STATE, src, NULL);\n\tif (status)\n\t\tgoto out;\n\n\tstatus = nfs4_preprocess_stateid_op(rqstp, cstate, &cstate->current_fh,\n\t\t\t\t\t    dst_stateid, WR_STATE, dst, NULL);\n\tif (status)\n\t\tgoto out_put_src;\n\n\t \n\tif (!S_ISREG(file_inode((*src)->nf_file)->i_mode) ||\n\t    !S_ISREG(file_inode((*dst)->nf_file)->i_mode)) {\n\t\tstatus = nfserr_wrong_type;\n\t\tgoto out_put_dst;\n\t}\n\nout:\n\treturn status;\nout_put_dst:\n\tnfsd_file_put(*dst);\n\t*dst = NULL;\nout_put_src:\n\tnfsd_file_put(*src);\n\t*src = NULL;\n\tgoto out;\n}\n\nstatic __be32\nnfsd4_clone(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\tunion nfsd4_op_u *u)\n{\n\tstruct nfsd4_clone *clone = &u->clone;\n\tstruct nfsd_file *src, *dst;\n\t__be32 status;\n\n\tstatus = nfsd4_verify_copy(rqstp, cstate, &clone->cl_src_stateid, &src,\n\t\t\t\t   &clone->cl_dst_stateid, &dst);\n\tif (status)\n\t\tgoto out;\n\n\tstatus = nfsd4_clone_file_range(rqstp, src, clone->cl_src_pos,\n\t\t\tdst, clone->cl_dst_pos, clone->cl_count,\n\t\t\tEX_ISSYNC(cstate->current_fh.fh_export));\n\n\tnfsd_file_put(dst);\n\tnfsd_file_put(src);\nout:\n\treturn status;\n}\n\nstatic void nfs4_put_copy(struct nfsd4_copy *copy)\n{\n\tif (!refcount_dec_and_test(&copy->refcount))\n\t\treturn;\n\tkfree(copy->cp_src);\n\tkfree(copy);\n}\n\nstatic void nfsd4_stop_copy(struct nfsd4_copy *copy)\n{\n\tif (!test_and_set_bit(NFSD4_COPY_F_STOPPED, &copy->cp_flags))\n\t\tkthread_stop(copy->copy_task);\n\tnfs4_put_copy(copy);\n}\n\nstatic struct nfsd4_copy *nfsd4_get_copy(struct nfs4_client *clp)\n{\n\tstruct nfsd4_copy *copy = NULL;\n\n\tspin_lock(&clp->async_lock);\n\tif (!list_empty(&clp->async_copies)) {\n\t\tcopy = list_first_entry(&clp->async_copies, struct nfsd4_copy,\n\t\t\t\t\tcopies);\n\t\trefcount_inc(&copy->refcount);\n\t}\n\tspin_unlock(&clp->async_lock);\n\treturn copy;\n}\n\nvoid nfsd4_shutdown_copy(struct nfs4_client *clp)\n{\n\tstruct nfsd4_copy *copy;\n\n\twhile ((copy = nfsd4_get_copy(clp)) != NULL)\n\t\tnfsd4_stop_copy(copy);\n}\n#ifdef CONFIG_NFSD_V4_2_INTER_SSC\n\nextern struct file *nfs42_ssc_open(struct vfsmount *ss_mnt,\n\t\t\t\t   struct nfs_fh *src_fh,\n\t\t\t\t   nfs4_stateid *stateid);\nextern void nfs42_ssc_close(struct file *filep);\n\nextern void nfs_sb_deactive(struct super_block *sb);\n\n#define NFSD42_INTERSSC_MOUNTOPS \"vers=4.2,addr=%s,sec=sys\"\n\n \nstatic __be32 nfsd4_ssc_setup_dul(struct nfsd_net *nn, char *ipaddr,\n\t\t\t\t  struct nfsd4_ssc_umount_item **nsui)\n{\n\tstruct nfsd4_ssc_umount_item *ni = NULL;\n\tstruct nfsd4_ssc_umount_item *work = NULL;\n\tstruct nfsd4_ssc_umount_item *tmp;\n\tDEFINE_WAIT(wait);\n\t__be32 status = 0;\n\n\t*nsui = NULL;\n\twork = kzalloc(sizeof(*work), GFP_KERNEL);\ntry_again:\n\tspin_lock(&nn->nfsd_ssc_lock);\n\tlist_for_each_entry_safe(ni, tmp, &nn->nfsd_ssc_mount_list, nsui_list) {\n\t\tif (strncmp(ni->nsui_ipaddr, ipaddr, sizeof(ni->nsui_ipaddr)))\n\t\t\tcontinue;\n\t\t \n\t\tif (ni->nsui_busy) {\n\t\t\t \n\t\t\tprepare_to_wait(&nn->nfsd_ssc_waitq, &wait, TASK_IDLE);\n\t\t\tspin_unlock(&nn->nfsd_ssc_lock);\n\n\t\t\t \n\t\t\tif (kthread_should_stop() ||\n\t\t\t\t\t(schedule_timeout(20*HZ) == 0)) {\n\t\t\t\tfinish_wait(&nn->nfsd_ssc_waitq, &wait);\n\t\t\t\tkfree(work);\n\t\t\t\treturn nfserr_eagain;\n\t\t\t}\n\t\t\tfinish_wait(&nn->nfsd_ssc_waitq, &wait);\n\t\t\tgoto try_again;\n\t\t}\n\t\t*nsui = ni;\n\t\trefcount_inc(&ni->nsui_refcnt);\n\t\tspin_unlock(&nn->nfsd_ssc_lock);\n\t\tkfree(work);\n\n\t\t \n\t\treturn 0;\n\t}\n\tif (work) {\n\t\tstrscpy(work->nsui_ipaddr, ipaddr, sizeof(work->nsui_ipaddr) - 1);\n\t\trefcount_set(&work->nsui_refcnt, 2);\n\t\twork->nsui_busy = true;\n\t\tlist_add_tail(&work->nsui_list, &nn->nfsd_ssc_mount_list);\n\t\t*nsui = work;\n\t} else\n\t\tstatus = nfserr_resource;\n\tspin_unlock(&nn->nfsd_ssc_lock);\n\treturn status;\n}\n\nstatic void nfsd4_ssc_update_dul(struct nfsd_net *nn,\n\t\t\t\t struct nfsd4_ssc_umount_item *nsui,\n\t\t\t\t struct vfsmount *ss_mnt)\n{\n\tspin_lock(&nn->nfsd_ssc_lock);\n\tnsui->nsui_vfsmount = ss_mnt;\n\tnsui->nsui_busy = false;\n\twake_up_all(&nn->nfsd_ssc_waitq);\n\tspin_unlock(&nn->nfsd_ssc_lock);\n}\n\nstatic void nfsd4_ssc_cancel_dul(struct nfsd_net *nn,\n\t\t\t\t struct nfsd4_ssc_umount_item *nsui)\n{\n\tspin_lock(&nn->nfsd_ssc_lock);\n\tlist_del(&nsui->nsui_list);\n\twake_up_all(&nn->nfsd_ssc_waitq);\n\tspin_unlock(&nn->nfsd_ssc_lock);\n\tkfree(nsui);\n}\n\n \nstatic __be32\nnfsd4_interssc_connect(struct nl4_server *nss, struct svc_rqst *rqstp,\n\t\t       struct nfsd4_ssc_umount_item **nsui)\n{\n\tstruct file_system_type *type;\n\tstruct vfsmount *ss_mnt;\n\tstruct nfs42_netaddr *naddr;\n\tstruct sockaddr_storage tmp_addr;\n\tsize_t tmp_addrlen, match_netid_len = 3;\n\tchar *startsep = \"\", *endsep = \"\", *match_netid = \"tcp\";\n\tchar *ipaddr, *dev_name, *raw_data;\n\tint len, raw_len;\n\t__be32 status = nfserr_inval;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tnaddr = &nss->u.nl4_addr;\n\ttmp_addrlen = rpc_uaddr2sockaddr(SVC_NET(rqstp), naddr->addr,\n\t\t\t\t\t naddr->addr_len,\n\t\t\t\t\t (struct sockaddr *)&tmp_addr,\n\t\t\t\t\t sizeof(tmp_addr));\n\t*nsui = NULL;\n\tif (tmp_addrlen == 0)\n\t\tgoto out_err;\n\n\tif (tmp_addr.ss_family == AF_INET6) {\n\t\tstartsep = \"[\";\n\t\tendsep = \"]\";\n\t\tmatch_netid = \"tcp6\";\n\t\tmatch_netid_len = 4;\n\t}\n\n\tif (naddr->netid_len != match_netid_len ||\n\t\tstrncmp(naddr->netid, match_netid, naddr->netid_len))\n\t\tgoto out_err;\n\n\t \n\tlen = RPC_MAX_ADDRBUFLEN + 1;\n\tipaddr = kzalloc(len, GFP_KERNEL);\n\tif (!ipaddr)\n\t\tgoto out_err;\n\n\trpc_ntop((struct sockaddr *)&tmp_addr, ipaddr, len);\n\n\t \n\n\traw_len = strlen(NFSD42_INTERSSC_MOUNTOPS) + strlen(ipaddr);\n\traw_data = kzalloc(raw_len, GFP_KERNEL);\n\tif (!raw_data)\n\t\tgoto out_free_ipaddr;\n\n\tsnprintf(raw_data, raw_len, NFSD42_INTERSSC_MOUNTOPS, ipaddr);\n\n\tstatus = nfserr_nodev;\n\ttype = get_fs_type(\"nfs\");\n\tif (!type)\n\t\tgoto out_free_rawdata;\n\n\t \n\tdev_name = kzalloc(len + 5, GFP_KERNEL);\n\tif (!dev_name)\n\t\tgoto out_free_rawdata;\n\tsnprintf(dev_name, len + 5, \"%s%s%s:/\", startsep, ipaddr, endsep);\n\n\tstatus = nfsd4_ssc_setup_dul(nn, ipaddr, nsui);\n\tif (status)\n\t\tgoto out_free_devname;\n\tif ((*nsui)->nsui_vfsmount)\n\t\tgoto out_done;\n\n\t \n\tss_mnt = vfs_kern_mount(type, SB_KERNMOUNT, dev_name, raw_data);\n\tmodule_put(type->owner);\n\tif (IS_ERR(ss_mnt)) {\n\t\tstatus = nfserr_nodev;\n\t\tnfsd4_ssc_cancel_dul(nn, *nsui);\n\t\tgoto out_free_devname;\n\t}\n\tnfsd4_ssc_update_dul(nn, *nsui, ss_mnt);\nout_done:\n\tstatus = 0;\n\nout_free_devname:\n\tkfree(dev_name);\nout_free_rawdata:\n\tkfree(raw_data);\nout_free_ipaddr:\n\tkfree(ipaddr);\nout_err:\n\treturn status;\n}\n\n \nstatic __be32\nnfsd4_setup_inter_ssc(struct svc_rqst *rqstp,\n\t\t      struct nfsd4_compound_state *cstate,\n\t\t      struct nfsd4_copy *copy)\n{\n\tstruct svc_fh *s_fh = NULL;\n\tstateid_t *s_stid = &copy->cp_src_stateid;\n\t__be32 status = nfserr_inval;\n\n\t \n\tstatus = nfs4_preprocess_stateid_op(rqstp, cstate, &cstate->current_fh,\n\t\t\t\t\t    &copy->cp_dst_stateid,\n\t\t\t\t\t    WR_STATE, &copy->nf_dst, NULL);\n\tif (status)\n\t\tgoto out;\n\n\tstatus = nfsd4_interssc_connect(copy->cp_src, rqstp, &copy->ss_nsui);\n\tif (status)\n\t\tgoto out;\n\n\ts_fh = &cstate->save_fh;\n\n\tcopy->c_fh.size = s_fh->fh_handle.fh_size;\n\tmemcpy(copy->c_fh.data, &s_fh->fh_handle.fh_raw, copy->c_fh.size);\n\tcopy->stateid.seqid = cpu_to_be32(s_stid->si_generation);\n\tmemcpy(copy->stateid.other, (void *)&s_stid->si_opaque,\n\t       sizeof(stateid_opaque_t));\n\n\tstatus = 0;\nout:\n\treturn status;\n}\n\nstatic void\nnfsd4_cleanup_inter_ssc(struct nfsd4_ssc_umount_item *nsui, struct file *filp,\n\t\t\tstruct nfsd_file *dst)\n{\n\tstruct nfsd_net *nn = net_generic(dst->nf_net, nfsd_net_id);\n\tlong timeout = msecs_to_jiffies(nfsd4_ssc_umount_timeout);\n\n\tnfs42_ssc_close(filp);\n\tfput(filp);\n\n\tspin_lock(&nn->nfsd_ssc_lock);\n\tlist_del(&nsui->nsui_list);\n\t \n\trefcount_dec(&nsui->nsui_refcnt);\n\tnsui->nsui_expire = jiffies + timeout;\n\tlist_add_tail(&nsui->nsui_list, &nn->nfsd_ssc_mount_list);\n\tspin_unlock(&nn->nfsd_ssc_lock);\n}\n\n#else  \n\nstatic __be32\nnfsd4_setup_inter_ssc(struct svc_rqst *rqstp,\n\t\t      struct nfsd4_compound_state *cstate,\n\t\t      struct nfsd4_copy *copy)\n{\n\treturn nfserr_inval;\n}\n\nstatic void\nnfsd4_cleanup_inter_ssc(struct nfsd4_ssc_umount_item *nsui, struct file *filp,\n\t\t\tstruct nfsd_file *dst)\n{\n}\n\nstatic struct file *nfs42_ssc_open(struct vfsmount *ss_mnt,\n\t\t\t\t   struct nfs_fh *src_fh,\n\t\t\t\t   nfs4_stateid *stateid)\n{\n\treturn NULL;\n}\n#endif  \n\nstatic __be32\nnfsd4_setup_intra_ssc(struct svc_rqst *rqstp,\n\t\t      struct nfsd4_compound_state *cstate,\n\t\t      struct nfsd4_copy *copy)\n{\n\treturn nfsd4_verify_copy(rqstp, cstate, &copy->cp_src_stateid,\n\t\t\t\t &copy->nf_src, &copy->cp_dst_stateid,\n\t\t\t\t &copy->nf_dst);\n}\n\nstatic void nfsd4_cb_offload_release(struct nfsd4_callback *cb)\n{\n\tstruct nfsd4_cb_offload *cbo =\n\t\tcontainer_of(cb, struct nfsd4_cb_offload, co_cb);\n\n\tkfree(cbo);\n}\n\nstatic int nfsd4_cb_offload_done(struct nfsd4_callback *cb,\n\t\t\t\t struct rpc_task *task)\n{\n\tstruct nfsd4_cb_offload *cbo =\n\t\tcontainer_of(cb, struct nfsd4_cb_offload, co_cb);\n\n\ttrace_nfsd_cb_offload_done(&cbo->co_res.cb_stateid, task);\n\treturn 1;\n}\n\nstatic const struct nfsd4_callback_ops nfsd4_cb_offload_ops = {\n\t.release = nfsd4_cb_offload_release,\n\t.done = nfsd4_cb_offload_done\n};\n\nstatic void nfsd4_init_copy_res(struct nfsd4_copy *copy, bool sync)\n{\n\tcopy->cp_res.wr_stable_how =\n\t\ttest_bit(NFSD4_COPY_F_COMMITTED, &copy->cp_flags) ?\n\t\t\tNFS_FILE_SYNC : NFS_UNSTABLE;\n\tnfsd4_copy_set_sync(copy, sync);\n\tgen_boot_verifier(&copy->cp_res.wr_verifier, copy->cp_clp->net);\n}\n\nstatic ssize_t _nfsd_copy_file_range(struct nfsd4_copy *copy,\n\t\t\t\t     struct file *dst,\n\t\t\t\t     struct file *src)\n{\n\terrseq_t since;\n\tssize_t bytes_copied = 0;\n\tu64 bytes_total = copy->cp_count;\n\tu64 src_pos = copy->cp_src_pos;\n\tu64 dst_pos = copy->cp_dst_pos;\n\tint status;\n\tloff_t end;\n\n\t \n\tif (bytes_total == 0)\n\t\tbytes_total = ULLONG_MAX;\n\tdo {\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\t\tbytes_copied = nfsd_copy_file_range(src, src_pos, dst, dst_pos,\n\t\t\t\t\t\t    bytes_total);\n\t\tif (bytes_copied <= 0)\n\t\t\tbreak;\n\t\tbytes_total -= bytes_copied;\n\t\tcopy->cp_res.wr_bytes_written += bytes_copied;\n\t\tsrc_pos += bytes_copied;\n\t\tdst_pos += bytes_copied;\n\t} while (bytes_total > 0 && nfsd4_copy_is_async(copy));\n\t \n\tif (nfsd4_copy_is_async(copy) && copy->cp_res.wr_bytes_written > 0) {\n\t\tsince = READ_ONCE(dst->f_wb_err);\n\t\tend = copy->cp_dst_pos + copy->cp_res.wr_bytes_written - 1;\n\t\tstatus = vfs_fsync_range(dst, copy->cp_dst_pos, end, 0);\n\t\tif (!status)\n\t\t\tstatus = filemap_check_wb_err(dst->f_mapping, since);\n\t\tif (!status)\n\t\t\tset_bit(NFSD4_COPY_F_COMMITTED, &copy->cp_flags);\n\t}\n\treturn bytes_copied;\n}\n\nstatic __be32 nfsd4_do_copy(struct nfsd4_copy *copy,\n\t\t\t    struct file *src, struct file *dst,\n\t\t\t    bool sync)\n{\n\t__be32 status;\n\tssize_t bytes;\n\n\tbytes = _nfsd_copy_file_range(copy, dst, src);\n\n\t \n\tif (bytes < 0 && !copy->cp_res.wr_bytes_written)\n\t\tstatus = nfserrno(bytes);\n\telse {\n\t\tnfsd4_init_copy_res(copy, sync);\n\t\tstatus = nfs_ok;\n\t}\n\treturn status;\n}\n\nstatic void dup_copy_fields(struct nfsd4_copy *src, struct nfsd4_copy *dst)\n{\n\tdst->cp_src_pos = src->cp_src_pos;\n\tdst->cp_dst_pos = src->cp_dst_pos;\n\tdst->cp_count = src->cp_count;\n\tdst->cp_flags = src->cp_flags;\n\tmemcpy(&dst->cp_res, &src->cp_res, sizeof(src->cp_res));\n\tmemcpy(&dst->fh, &src->fh, sizeof(src->fh));\n\tdst->cp_clp = src->cp_clp;\n\tdst->nf_dst = nfsd_file_get(src->nf_dst);\n\t \n\tif (!nfsd4_ssc_is_inter(src))\n\t\tdst->nf_src = nfsd_file_get(src->nf_src);\n\n\tmemcpy(&dst->cp_stateid, &src->cp_stateid, sizeof(src->cp_stateid));\n\tmemcpy(dst->cp_src, src->cp_src, sizeof(struct nl4_server));\n\tmemcpy(&dst->stateid, &src->stateid, sizeof(src->stateid));\n\tmemcpy(&dst->c_fh, &src->c_fh, sizeof(src->c_fh));\n\tdst->ss_nsui = src->ss_nsui;\n}\n\nstatic void release_copy_files(struct nfsd4_copy *copy)\n{\n\tif (copy->nf_src)\n\t\tnfsd_file_put(copy->nf_src);\n\tif (copy->nf_dst)\n\t\tnfsd_file_put(copy->nf_dst);\n}\n\nstatic void cleanup_async_copy(struct nfsd4_copy *copy)\n{\n\tnfs4_free_copy_state(copy);\n\trelease_copy_files(copy);\n\tif (copy->cp_clp) {\n\t\tspin_lock(&copy->cp_clp->async_lock);\n\t\tif (!list_empty(&copy->copies))\n\t\t\tlist_del_init(&copy->copies);\n\t\tspin_unlock(&copy->cp_clp->async_lock);\n\t}\n\tnfs4_put_copy(copy);\n}\n\nstatic void nfsd4_send_cb_offload(struct nfsd4_copy *copy, __be32 nfserr)\n{\n\tstruct nfsd4_cb_offload *cbo;\n\n\tcbo = kzalloc(sizeof(*cbo), GFP_KERNEL);\n\tif (!cbo)\n\t\treturn;\n\n\tmemcpy(&cbo->co_res, &copy->cp_res, sizeof(copy->cp_res));\n\tmemcpy(&cbo->co_fh, &copy->fh, sizeof(copy->fh));\n\tcbo->co_nfserr = nfserr;\n\n\tnfsd4_init_cb(&cbo->co_cb, copy->cp_clp, &nfsd4_cb_offload_ops,\n\t\t      NFSPROC4_CLNT_CB_OFFLOAD);\n\ttrace_nfsd_cb_offload(copy->cp_clp, &cbo->co_res.cb_stateid,\n\t\t\t      &cbo->co_fh, copy->cp_count, nfserr);\n\tnfsd4_run_cb(&cbo->co_cb);\n}\n\n \nstatic int nfsd4_do_async_copy(void *data)\n{\n\tstruct nfsd4_copy *copy = (struct nfsd4_copy *)data;\n\t__be32 nfserr;\n\n\tif (nfsd4_ssc_is_inter(copy)) {\n\t\tstruct file *filp;\n\n\t\tfilp = nfs42_ssc_open(copy->ss_nsui->nsui_vfsmount,\n\t\t\t\t      &copy->c_fh, &copy->stateid);\n\t\tif (IS_ERR(filp)) {\n\t\t\tswitch (PTR_ERR(filp)) {\n\t\t\tcase -EBADF:\n\t\t\t\tnfserr = nfserr_wrong_type;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tnfserr = nfserr_offload_denied;\n\t\t\t}\n\t\t\t \n\t\t\tgoto do_callback;\n\t\t}\n\t\tnfserr = nfsd4_do_copy(copy, filp, copy->nf_dst->nf_file,\n\t\t\t\t       false);\n\t\tnfsd4_cleanup_inter_ssc(copy->ss_nsui, filp, copy->nf_dst);\n\t} else {\n\t\tnfserr = nfsd4_do_copy(copy, copy->nf_src->nf_file,\n\t\t\t\t       copy->nf_dst->nf_file, false);\n\t}\n\ndo_callback:\n\tnfsd4_send_cb_offload(copy, nfserr);\n\tcleanup_async_copy(copy);\n\treturn 0;\n}\n\nstatic __be32\nnfsd4_copy(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\tunion nfsd4_op_u *u)\n{\n\tstruct nfsd4_copy *copy = &u->copy;\n\t__be32 status;\n\tstruct nfsd4_copy *async_copy = NULL;\n\n\tif (nfsd4_ssc_is_inter(copy)) {\n\t\tif (!inter_copy_offload_enable || nfsd4_copy_is_sync(copy)) {\n\t\t\tstatus = nfserr_notsupp;\n\t\t\tgoto out;\n\t\t}\n\t\tstatus = nfsd4_setup_inter_ssc(rqstp, cstate, copy);\n\t\tif (status)\n\t\t\treturn nfserr_offload_denied;\n\t} else {\n\t\tstatus = nfsd4_setup_intra_ssc(rqstp, cstate, copy);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\n\tcopy->cp_clp = cstate->clp;\n\tmemcpy(&copy->fh, &cstate->current_fh.fh_handle,\n\t\tsizeof(struct knfsd_fh));\n\tif (nfsd4_copy_is_async(copy)) {\n\t\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\t\tstatus = nfserrno(-ENOMEM);\n\t\tasync_copy = kzalloc(sizeof(struct nfsd4_copy), GFP_KERNEL);\n\t\tif (!async_copy)\n\t\t\tgoto out_err;\n\t\tINIT_LIST_HEAD(&async_copy->copies);\n\t\trefcount_set(&async_copy->refcount, 1);\n\t\tasync_copy->cp_src = kmalloc(sizeof(*async_copy->cp_src), GFP_KERNEL);\n\t\tif (!async_copy->cp_src)\n\t\t\tgoto out_err;\n\t\tif (!nfs4_init_copy_state(nn, copy))\n\t\t\tgoto out_err;\n\t\tmemcpy(&copy->cp_res.cb_stateid, &copy->cp_stateid.cs_stid,\n\t\t\tsizeof(copy->cp_res.cb_stateid));\n\t\tdup_copy_fields(copy, async_copy);\n\t\tasync_copy->copy_task = kthread_create(nfsd4_do_async_copy,\n\t\t\t\tasync_copy, \"%s\", \"copy thread\");\n\t\tif (IS_ERR(async_copy->copy_task))\n\t\t\tgoto out_err;\n\t\tspin_lock(&async_copy->cp_clp->async_lock);\n\t\tlist_add(&async_copy->copies,\n\t\t\t\t&async_copy->cp_clp->async_copies);\n\t\tspin_unlock(&async_copy->cp_clp->async_lock);\n\t\twake_up_process(async_copy->copy_task);\n\t\tstatus = nfs_ok;\n\t} else {\n\t\tstatus = nfsd4_do_copy(copy, copy->nf_src->nf_file,\n\t\t\t\t       copy->nf_dst->nf_file, true);\n\t}\nout:\n\trelease_copy_files(copy);\n\treturn status;\nout_err:\n\tif (nfsd4_ssc_is_inter(copy)) {\n\t\t \n\t\trefcount_dec(&copy->ss_nsui->nsui_refcnt);\n\t}\n\tif (async_copy)\n\t\tcleanup_async_copy(async_copy);\n\tstatus = nfserrno(-ENOMEM);\n\tgoto out;\n}\n\nstatic struct nfsd4_copy *\nfind_async_copy_locked(struct nfs4_client *clp, stateid_t *stateid)\n{\n\tstruct nfsd4_copy *copy;\n\n\tlockdep_assert_held(&clp->async_lock);\n\n\tlist_for_each_entry(copy, &clp->async_copies, copies) {\n\t\tif (memcmp(&copy->cp_stateid.cs_stid, stateid, NFS4_STATEID_SIZE))\n\t\t\tcontinue;\n\t\treturn copy;\n\t}\n\treturn NULL;\n}\n\nstatic struct nfsd4_copy *\nfind_async_copy(struct nfs4_client *clp, stateid_t *stateid)\n{\n\tstruct nfsd4_copy *copy;\n\n\tspin_lock(&clp->async_lock);\n\tcopy = find_async_copy_locked(clp, stateid);\n\tif (copy)\n\t\trefcount_inc(&copy->refcount);\n\tspin_unlock(&clp->async_lock);\n\treturn copy;\n}\n\nstatic __be32\nnfsd4_offload_cancel(struct svc_rqst *rqstp,\n\t\t     struct nfsd4_compound_state *cstate,\n\t\t     union nfsd4_op_u *u)\n{\n\tstruct nfsd4_offload_status *os = &u->offload_status;\n\tstruct nfsd4_copy *copy;\n\tstruct nfs4_client *clp = cstate->clp;\n\n\tcopy = find_async_copy(clp, &os->stateid);\n\tif (!copy) {\n\t\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\t\treturn manage_cpntf_state(nn, &os->stateid, clp, NULL);\n\t} else\n\t\tnfsd4_stop_copy(copy);\n\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_copy_notify(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\t  union nfsd4_op_u *u)\n{\n\tstruct nfsd4_copy_notify *cn = &u->copy_notify;\n\t__be32 status;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\tstruct nfs4_stid *stid;\n\tstruct nfs4_cpntf_state *cps;\n\tstruct nfs4_client *clp = cstate->clp;\n\n\tstatus = nfs4_preprocess_stateid_op(rqstp, cstate, &cstate->current_fh,\n\t\t\t\t\t&cn->cpn_src_stateid, RD_STATE, NULL,\n\t\t\t\t\t&stid);\n\tif (status)\n\t\treturn status;\n\n\tcn->cpn_sec = nn->nfsd4_lease;\n\tcn->cpn_nsec = 0;\n\n\tstatus = nfserrno(-ENOMEM);\n\tcps = nfs4_alloc_init_cpntf_state(nn, stid);\n\tif (!cps)\n\t\tgoto out;\n\tmemcpy(&cn->cpn_cnr_stateid, &cps->cp_stateid.cs_stid, sizeof(stateid_t));\n\tmemcpy(&cps->cp_p_stateid, &stid->sc_stateid, sizeof(stateid_t));\n\tmemcpy(&cps->cp_p_clid, &clp->cl_clientid, sizeof(clientid_t));\n\n\t \n\tcn->cpn_src->nl4_type = NL4_NETADDR;\n\tstatus = nfsd4_set_netaddr((struct sockaddr *)&rqstp->rq_daddr,\n\t\t\t\t &cn->cpn_src->u.nl4_addr);\n\tWARN_ON_ONCE(status);\n\tif (status) {\n\t\tnfs4_put_cpntf_state(nn, cps);\n\t\tgoto out;\n\t}\nout:\n\tnfs4_put_stid(stid);\n\treturn status;\n}\n\nstatic __be32\nnfsd4_fallocate(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\tstruct nfsd4_fallocate *fallocate, int flags)\n{\n\t__be32 status;\n\tstruct nfsd_file *nf;\n\n\tstatus = nfs4_preprocess_stateid_op(rqstp, cstate, &cstate->current_fh,\n\t\t\t\t\t    &fallocate->falloc_stateid,\n\t\t\t\t\t    WR_STATE, &nf, NULL);\n\tif (status != nfs_ok)\n\t\treturn status;\n\n\tstatus = nfsd4_vfs_fallocate(rqstp, &cstate->current_fh, nf->nf_file,\n\t\t\t\t     fallocate->falloc_offset,\n\t\t\t\t     fallocate->falloc_length,\n\t\t\t\t     flags);\n\tnfsd_file_put(nf);\n\treturn status;\n}\n\nstatic __be32\nnfsd4_offload_status(struct svc_rqst *rqstp,\n\t\t     struct nfsd4_compound_state *cstate,\n\t\t     union nfsd4_op_u *u)\n{\n\tstruct nfsd4_offload_status *os = &u->offload_status;\n\t__be32 status = nfs_ok;\n\tstruct nfsd4_copy *copy;\n\tstruct nfs4_client *clp = cstate->clp;\n\n\tspin_lock(&clp->async_lock);\n\tcopy = find_async_copy_locked(clp, &os->stateid);\n\tif (copy)\n\t\tos->count = copy->cp_res.wr_bytes_written;\n\telse\n\t\tstatus = nfserr_bad_stateid;\n\tspin_unlock(&clp->async_lock);\n\n\treturn status;\n}\n\nstatic __be32\nnfsd4_allocate(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t       union nfsd4_op_u *u)\n{\n\treturn nfsd4_fallocate(rqstp, cstate, &u->allocate, 0);\n}\n\nstatic __be32\nnfsd4_deallocate(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\t union nfsd4_op_u *u)\n{\n\treturn nfsd4_fallocate(rqstp, cstate, &u->deallocate,\n\t\t\t       FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE);\n}\n\nstatic __be32\nnfsd4_seek(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t   union nfsd4_op_u *u)\n{\n\tstruct nfsd4_seek *seek = &u->seek;\n\tint whence;\n\t__be32 status;\n\tstruct nfsd_file *nf;\n\n\tstatus = nfs4_preprocess_stateid_op(rqstp, cstate, &cstate->current_fh,\n\t\t\t\t\t    &seek->seek_stateid,\n\t\t\t\t\t    RD_STATE, &nf, NULL);\n\tif (status)\n\t\treturn status;\n\n\tswitch (seek->seek_whence) {\n\tcase NFS4_CONTENT_DATA:\n\t\twhence = SEEK_DATA;\n\t\tbreak;\n\tcase NFS4_CONTENT_HOLE:\n\t\twhence = SEEK_HOLE;\n\t\tbreak;\n\tdefault:\n\t\tstatus = nfserr_union_notsupp;\n\t\tgoto out;\n\t}\n\n\t \n\tseek->seek_pos = vfs_llseek(nf->nf_file, seek->seek_offset, whence);\n\tif (seek->seek_pos < 0)\n\t\tstatus = nfserrno(seek->seek_pos);\n\telse if (seek->seek_pos >= i_size_read(file_inode(nf->nf_file)))\n\t\tseek->seek_eof = true;\n\nout:\n\tnfsd_file_put(nf);\n\treturn status;\n}\n\n \nstatic __be32\n_nfsd4_verify(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t     struct nfsd4_verify *verify)\n{\n\t__be32 *buf, *p;\n\tint count;\n\t__be32 status;\n\n\tstatus = fh_verify(rqstp, &cstate->current_fh, 0, NFSD_MAY_NOP);\n\tif (status)\n\t\treturn status;\n\n\tstatus = check_attr_support(rqstp, cstate, verify->ve_bmval, NULL);\n\tif (status)\n\t\treturn status;\n\n\tif ((verify->ve_bmval[0] & FATTR4_WORD0_RDATTR_ERROR)\n\t    || (verify->ve_bmval[1] & NFSD_WRITEONLY_ATTRS_WORD1))\n\t\treturn nfserr_inval;\n\tif (verify->ve_attrlen & 3)\n\t\treturn nfserr_inval;\n\n\t \n\tcount = 4 + (verify->ve_attrlen >> 2);\n\tbuf = kmalloc(count << 2, GFP_KERNEL);\n\tif (!buf)\n\t\treturn nfserr_jukebox;\n\n\tp = buf;\n\tstatus = nfsd4_encode_fattr_to_buf(&p, count, &cstate->current_fh,\n\t\t\t\t    cstate->current_fh.fh_export,\n\t\t\t\t    cstate->current_fh.fh_dentry,\n\t\t\t\t    verify->ve_bmval,\n\t\t\t\t    rqstp, 0);\n\t \n\tif (status == nfserr_resource)\n\t\tstatus = nfserr_not_same;\n\tif (status)\n\t\tgoto out_kfree;\n\n\t \n\tp = buf + 1 + ntohl(buf[0]);\n\tstatus = nfserr_not_same;\n\tif (ntohl(*p++) != verify->ve_attrlen)\n\t\tgoto out_kfree;\n\tif (!memcmp(p, verify->ve_attrval, verify->ve_attrlen))\n\t\tstatus = nfserr_same;\n\nout_kfree:\n\tkfree(buf);\n\treturn status;\n}\n\nstatic __be32\nnfsd4_nverify(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t      union nfsd4_op_u *u)\n{\n\t__be32 status;\n\n\tstatus = _nfsd4_verify(rqstp, cstate, &u->verify);\n\treturn status == nfserr_not_same ? nfs_ok : status;\n}\n\nstatic __be32\nnfsd4_verify(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t     union nfsd4_op_u *u)\n{\n\t__be32 status;\n\n\tstatus = _nfsd4_verify(rqstp, cstate, &u->nverify);\n\treturn status == nfserr_same ? nfs_ok : status;\n}\n\n#ifdef CONFIG_NFSD_PNFS\nstatic const struct nfsd4_layout_ops *\nnfsd4_layout_verify(struct svc_export *exp, unsigned int layout_type)\n{\n\tif (!exp->ex_layout_types) {\n\t\tdprintk(\"%s: export does not support pNFS\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tif (layout_type >= LAYOUT_TYPE_MAX ||\n\t    !(exp->ex_layout_types & (1 << layout_type))) {\n\t\tdprintk(\"%s: layout type %d not supported\\n\",\n\t\t\t__func__, layout_type);\n\t\treturn NULL;\n\t}\n\n\treturn nfsd4_layout_ops[layout_type];\n}\n\nstatic __be32\nnfsd4_getdeviceinfo(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate, union nfsd4_op_u *u)\n{\n\tstruct nfsd4_getdeviceinfo *gdp = &u->getdeviceinfo;\n\tconst struct nfsd4_layout_ops *ops;\n\tstruct nfsd4_deviceid_map *map;\n\tstruct svc_export *exp;\n\t__be32 nfserr;\n\n\tdprintk(\"%s: layout_type %u dev_id [0x%llx:0x%x] maxcnt %u\\n\",\n\t       __func__,\n\t       gdp->gd_layout_type,\n\t       gdp->gd_devid.fsid_idx, gdp->gd_devid.generation,\n\t       gdp->gd_maxcount);\n\n\tmap = nfsd4_find_devid_map(gdp->gd_devid.fsid_idx);\n\tif (!map) {\n\t\tdprintk(\"%s: couldn't find device ID to export mapping!\\n\",\n\t\t\t__func__);\n\t\treturn nfserr_noent;\n\t}\n\n\texp = rqst_exp_find(rqstp, map->fsid_type, map->fsid);\n\tif (IS_ERR(exp)) {\n\t\tdprintk(\"%s: could not find device id\\n\", __func__);\n\t\treturn nfserr_noent;\n\t}\n\n\tnfserr = nfserr_layoutunavailable;\n\tops = nfsd4_layout_verify(exp, gdp->gd_layout_type);\n\tif (!ops)\n\t\tgoto out;\n\n\tnfserr = nfs_ok;\n\tif (gdp->gd_maxcount != 0) {\n\t\tnfserr = ops->proc_getdeviceinfo(exp->ex_path.mnt->mnt_sb,\n\t\t\t\trqstp, cstate->clp, gdp);\n\t}\n\n\tgdp->gd_notify_types &= ops->notify_types;\nout:\n\texp_put(exp);\n\treturn nfserr;\n}\n\nstatic void\nnfsd4_getdeviceinfo_release(union nfsd4_op_u *u)\n{\n\tkfree(u->getdeviceinfo.gd_device);\n}\n\nstatic __be32\nnfsd4_layoutget(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate, union nfsd4_op_u *u)\n{\n\tstruct nfsd4_layoutget *lgp = &u->layoutget;\n\tstruct svc_fh *current_fh = &cstate->current_fh;\n\tconst struct nfsd4_layout_ops *ops;\n\tstruct nfs4_layout_stateid *ls;\n\t__be32 nfserr;\n\tint accmode = NFSD_MAY_READ_IF_EXEC;\n\n\tswitch (lgp->lg_seg.iomode) {\n\tcase IOMODE_READ:\n\t\taccmode |= NFSD_MAY_READ;\n\t\tbreak;\n\tcase IOMODE_RW:\n\t\taccmode |= NFSD_MAY_READ | NFSD_MAY_WRITE;\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"%s: invalid iomode %d\\n\",\n\t\t\t__func__, lgp->lg_seg.iomode);\n\t\tnfserr = nfserr_badiomode;\n\t\tgoto out;\n\t}\n\n\tnfserr = fh_verify(rqstp, current_fh, 0, accmode);\n\tif (nfserr)\n\t\tgoto out;\n\n\tnfserr = nfserr_layoutunavailable;\n\tops = nfsd4_layout_verify(current_fh->fh_export, lgp->lg_layout_type);\n\tif (!ops)\n\t\tgoto out;\n\n\t \n\tnfserr = nfserr_inval;\n\tif (lgp->lg_seg.length < lgp->lg_minlength ||\n\t    (lgp->lg_minlength != NFS4_MAX_UINT64 &&\n\t     lgp->lg_minlength > NFS4_MAX_UINT64 - lgp->lg_seg.offset) ||\n\t    (lgp->lg_seg.length != NFS4_MAX_UINT64 &&\n\t     lgp->lg_seg.length > NFS4_MAX_UINT64 - lgp->lg_seg.offset))\n\t\tgoto out;\n\tif (lgp->lg_seg.length == 0)\n\t\tgoto out;\n\n\tnfserr = nfsd4_preprocess_layout_stateid(rqstp, cstate, &lgp->lg_sid,\n\t\t\t\t\t\ttrue, lgp->lg_layout_type, &ls);\n\tif (nfserr) {\n\t\ttrace_nfsd_layout_get_lookup_fail(&lgp->lg_sid);\n\t\tgoto out;\n\t}\n\n\tnfserr = nfserr_recallconflict;\n\tif (atomic_read(&ls->ls_stid.sc_file->fi_lo_recalls))\n\t\tgoto out_put_stid;\n\n\tnfserr = ops->proc_layoutget(d_inode(current_fh->fh_dentry),\n\t\t\t\t     current_fh, lgp);\n\tif (nfserr)\n\t\tgoto out_put_stid;\n\n\tnfserr = nfsd4_insert_layout(lgp, ls);\n\nout_put_stid:\n\tmutex_unlock(&ls->ls_mutex);\n\tnfs4_put_stid(&ls->ls_stid);\nout:\n\treturn nfserr;\n}\n\nstatic void\nnfsd4_layoutget_release(union nfsd4_op_u *u)\n{\n\tkfree(u->layoutget.lg_content);\n}\n\nstatic __be32\nnfsd4_layoutcommit(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate, union nfsd4_op_u *u)\n{\n\tstruct nfsd4_layoutcommit *lcp = &u->layoutcommit;\n\tconst struct nfsd4_layout_seg *seg = &lcp->lc_seg;\n\tstruct svc_fh *current_fh = &cstate->current_fh;\n\tconst struct nfsd4_layout_ops *ops;\n\tloff_t new_size = lcp->lc_last_wr + 1;\n\tstruct inode *inode;\n\tstruct nfs4_layout_stateid *ls;\n\t__be32 nfserr;\n\n\tnfserr = fh_verify(rqstp, current_fh, 0, NFSD_MAY_WRITE);\n\tif (nfserr)\n\t\tgoto out;\n\n\tnfserr = nfserr_layoutunavailable;\n\tops = nfsd4_layout_verify(current_fh->fh_export, lcp->lc_layout_type);\n\tif (!ops)\n\t\tgoto out;\n\tinode = d_inode(current_fh->fh_dentry);\n\n\tnfserr = nfserr_inval;\n\tif (new_size <= seg->offset) {\n\t\tdprintk(\"pnfsd: last write before layout segment\\n\");\n\t\tgoto out;\n\t}\n\tif (new_size > seg->offset + seg->length) {\n\t\tdprintk(\"pnfsd: last write beyond layout segment\\n\");\n\t\tgoto out;\n\t}\n\tif (!lcp->lc_newoffset && new_size > i_size_read(inode)) {\n\t\tdprintk(\"pnfsd: layoutcommit beyond EOF\\n\");\n\t\tgoto out;\n\t}\n\n\tnfserr = nfsd4_preprocess_layout_stateid(rqstp, cstate, &lcp->lc_sid,\n\t\t\t\t\t\tfalse, lcp->lc_layout_type,\n\t\t\t\t\t\t&ls);\n\tif (nfserr) {\n\t\ttrace_nfsd_layout_commit_lookup_fail(&lcp->lc_sid);\n\t\t \n\t\tif (nfserr == nfserr_bad_stateid)\n\t\t\tnfserr = nfserr_badlayout;\n\t\tgoto out;\n\t}\n\n\t \n\tmutex_unlock(&ls->ls_mutex);\n\n\tif (new_size > i_size_read(inode)) {\n\t\tlcp->lc_size_chg = 1;\n\t\tlcp->lc_newsize = new_size;\n\t} else {\n\t\tlcp->lc_size_chg = 0;\n\t}\n\n\tnfserr = ops->proc_layoutcommit(inode, lcp);\n\tnfs4_put_stid(&ls->ls_stid);\nout:\n\treturn nfserr;\n}\n\nstatic __be32\nnfsd4_layoutreturn(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate, union nfsd4_op_u *u)\n{\n\tstruct nfsd4_layoutreturn *lrp = &u->layoutreturn;\n\tstruct svc_fh *current_fh = &cstate->current_fh;\n\t__be32 nfserr;\n\n\tnfserr = fh_verify(rqstp, current_fh, 0, NFSD_MAY_NOP);\n\tif (nfserr)\n\t\tgoto out;\n\n\tnfserr = nfserr_layoutunavailable;\n\tif (!nfsd4_layout_verify(current_fh->fh_export, lrp->lr_layout_type))\n\t\tgoto out;\n\n\tswitch (lrp->lr_seg.iomode) {\n\tcase IOMODE_READ:\n\tcase IOMODE_RW:\n\tcase IOMODE_ANY:\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"%s: invalid iomode %d\\n\", __func__,\n\t\t\tlrp->lr_seg.iomode);\n\t\tnfserr = nfserr_inval;\n\t\tgoto out;\n\t}\n\n\tswitch (lrp->lr_return_type) {\n\tcase RETURN_FILE:\n\t\tnfserr = nfsd4_return_file_layouts(rqstp, cstate, lrp);\n\t\tbreak;\n\tcase RETURN_FSID:\n\tcase RETURN_ALL:\n\t\tnfserr = nfsd4_return_client_layouts(rqstp, cstate, lrp);\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"%s: invalid return_type %d\\n\", __func__,\n\t\t\tlrp->lr_return_type);\n\t\tnfserr = nfserr_inval;\n\t\tbreak;\n\t}\nout:\n\treturn nfserr;\n}\n#endif  \n\nstatic __be32\nnfsd4_getxattr(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t       union nfsd4_op_u *u)\n{\n\tstruct nfsd4_getxattr *getxattr = &u->getxattr;\n\n\treturn nfsd_getxattr(rqstp, &cstate->current_fh,\n\t\t\t     getxattr->getxa_name, &getxattr->getxa_buf,\n\t\t\t     &getxattr->getxa_len);\n}\n\nstatic __be32\nnfsd4_setxattr(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t   union nfsd4_op_u *u)\n{\n\tstruct nfsd4_setxattr *setxattr = &u->setxattr;\n\t__be32 ret;\n\n\tif (opens_in_grace(SVC_NET(rqstp)))\n\t\treturn nfserr_grace;\n\n\tret = nfsd_setxattr(rqstp, &cstate->current_fh, setxattr->setxa_name,\n\t\t\t    setxattr->setxa_buf, setxattr->setxa_len,\n\t\t\t    setxattr->setxa_flags);\n\n\tif (!ret)\n\t\tset_change_info(&setxattr->setxa_cinfo, &cstate->current_fh);\n\n\treturn ret;\n}\n\nstatic __be32\nnfsd4_listxattrs(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t   union nfsd4_op_u *u)\n{\n\t \n\treturn nfsd_listxattr(rqstp, &cstate->current_fh,\n\t\t\t     &u->listxattrs.lsxa_buf, &u->listxattrs.lsxa_len);\n}\n\nstatic __be32\nnfsd4_removexattr(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t   union nfsd4_op_u *u)\n{\n\tstruct nfsd4_removexattr *removexattr = &u->removexattr;\n\t__be32 ret;\n\n\tif (opens_in_grace(SVC_NET(rqstp)))\n\t\treturn nfserr_grace;\n\n\tret = nfsd_removexattr(rqstp, &cstate->current_fh,\n\t    removexattr->rmxa_name);\n\n\tif (!ret)\n\t\tset_change_info(&removexattr->rmxa_cinfo, &cstate->current_fh);\n\n\treturn ret;\n}\n\n \nstatic __be32\nnfsd4_proc_null(struct svc_rqst *rqstp)\n{\n\treturn rpc_success;\n}\n\nstatic inline void nfsd4_increment_op_stats(u32 opnum)\n{\n\tif (opnum >= FIRST_NFS4_OP && opnum <= LAST_NFS4_OP)\n\t\tpercpu_counter_inc(&nfsdstats.counter[NFSD_STATS_NFS4_OP(opnum)]);\n}\n\nstatic const struct nfsd4_operation nfsd4_ops[];\n\nstatic const char *nfsd4_op_name(unsigned opnum);\n\n \nstatic __be32 nfs41_check_op_ordering(struct nfsd4_compoundargs *args)\n{\n\tstruct nfsd4_op *first_op = &args->ops[0];\n\n\t \n\tif (args->minorversion == 0)\n\t\treturn nfs_ok;\n\t \n\tif (args->opcnt == 0)\n\t\treturn nfs_ok;\n\tif (first_op->status == nfserr_op_illegal)\n\t\treturn nfs_ok;\n\tif (!(nfsd4_ops[first_op->opnum].op_flags & ALLOWED_AS_FIRST_OP))\n\t\treturn nfserr_op_not_in_session;\n\tif (first_op->opnum == OP_SEQUENCE)\n\t\treturn nfs_ok;\n\t \n\tif (args->opcnt != 1)\n\t\treturn nfserr_not_only_op;\n\treturn nfs_ok;\n}\n\nconst struct nfsd4_operation *OPDESC(struct nfsd4_op *op)\n{\n\treturn &nfsd4_ops[op->opnum];\n}\n\nbool nfsd4_cache_this_op(struct nfsd4_op *op)\n{\n\tif (op->opnum == OP_ILLEGAL)\n\t\treturn false;\n\treturn OPDESC(op)->op_flags & OP_CACHEME;\n}\n\nstatic bool need_wrongsec_check(struct svc_rqst *rqstp)\n{\n\tstruct nfsd4_compoundres *resp = rqstp->rq_resp;\n\tstruct nfsd4_compoundargs *argp = rqstp->rq_argp;\n\tstruct nfsd4_op *this = &argp->ops[resp->opcnt - 1];\n\tstruct nfsd4_op *next = &argp->ops[resp->opcnt];\n\tconst struct nfsd4_operation *thisd = OPDESC(this);\n\tconst struct nfsd4_operation *nextd;\n\n\t \n\tif (!(thisd->op_flags & OP_IS_PUTFH_LIKE))\n\t\treturn false;\n\t \n\tif (argp->opcnt == resp->opcnt)\n\t\treturn false;\n\tif (next->opnum == OP_ILLEGAL)\n\t\treturn false;\n\tnextd = OPDESC(next);\n\t \n\treturn !(nextd->op_flags & OP_HANDLES_WRONGSEC);\n}\n\n#ifdef CONFIG_NFSD_V4_2_INTER_SSC\nstatic void\ncheck_if_stalefh_allowed(struct nfsd4_compoundargs *args)\n{\n\tstruct nfsd4_op\t*op, *current_op = NULL, *saved_op = NULL;\n\tstruct nfsd4_copy *copy;\n\tstruct nfsd4_putfh *putfh;\n\tint i;\n\n\t \n\tfor (i = 0; i < args->opcnt; i++) {\n\t\top = &args->ops[i];\n\t\tif (op->opnum == OP_PUTFH)\n\t\t\tcurrent_op = op;\n\t\telse if (op->opnum == OP_SAVEFH)\n\t\t\tsaved_op = current_op;\n\t\telse if (op->opnum == OP_RESTOREFH)\n\t\t\tcurrent_op = saved_op;\n\t\telse if (op->opnum == OP_COPY) {\n\t\t\tcopy = (struct nfsd4_copy *)&op->u;\n\t\t\tif (!saved_op) {\n\t\t\t\top->status = nfserr_nofilehandle;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tputfh = (struct nfsd4_putfh *)&saved_op->u;\n\t\t\tif (nfsd4_ssc_is_inter(copy))\n\t\t\t\tputfh->no_verify = true;\n\t\t}\n\t}\n}\n#else\nstatic void\ncheck_if_stalefh_allowed(struct nfsd4_compoundargs *args)\n{\n}\n#endif\n\n \nstatic __be32\nnfsd4_proc_compound(struct svc_rqst *rqstp)\n{\n\tstruct nfsd4_compoundargs *args = rqstp->rq_argp;\n\tstruct nfsd4_compoundres *resp = rqstp->rq_resp;\n\tstruct nfsd4_op\t*op;\n\tstruct nfsd4_compound_state *cstate = &resp->cstate;\n\tstruct svc_fh *current_fh = &cstate->current_fh;\n\tstruct svc_fh *save_fh = &cstate->save_fh;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\t__be32\t\tstatus;\n\n\tresp->xdr = &rqstp->rq_res_stream;\n\tresp->statusp = resp->xdr->p;\n\n\t \n\txdr_reserve_space(resp->xdr, XDR_UNIT);\n\n\t \n\txdr_reserve_space(resp->xdr, XDR_UNIT * 2 + args->taglen);\n\tresp->taglen = args->taglen;\n\tresp->tag = args->tag;\n\tresp->rqstp = rqstp;\n\tcstate->minorversion = args->minorversion;\n\tfh_init(current_fh, NFS4_FHSIZE);\n\tfh_init(save_fh, NFS4_FHSIZE);\n\t \n\tclear_bit(RQ_USEDEFERRAL, &rqstp->rq_flags);\n\n\t \n\tstatus = nfserr_minor_vers_mismatch;\n\tif (nfsd_minorversion(nn, args->minorversion, NFSD_TEST) <= 0)\n\t\tgoto out;\n\n\tstatus = nfs41_check_op_ordering(args);\n\tif (status) {\n\t\top = &args->ops[0];\n\t\top->status = status;\n\t\tresp->opcnt = 1;\n\t\tgoto encode_op;\n\t}\n\tcheck_if_stalefh_allowed(args);\n\n\trqstp->rq_lease_breaker = (void **)&cstate->clp;\n\n\ttrace_nfsd_compound(rqstp, args->tag, args->taglen, args->client_opcnt);\n\twhile (!status && resp->opcnt < args->opcnt) {\n\t\top = &args->ops[resp->opcnt++];\n\n\t\tif (unlikely(resp->opcnt == NFSD_MAX_OPS_PER_COMPOUND)) {\n\t\t\t \n\t\t\tif (cstate->minorversion == 0 &&\n\t\t\t    args->client_opcnt > resp->opcnt) {\n\t\t\t\top->status = nfserr_resource;\n\t\t\t\tgoto encode_op;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (op->status) {\n\t\t\tif (op->opnum == OP_OPEN)\n\t\t\t\top->status = nfsd4_open_omfg(rqstp, cstate, op);\n\t\t\tgoto encode_op;\n\t\t}\n\t\tif (!current_fh->fh_dentry &&\n\t\t\t\t!HAS_FH_FLAG(current_fh, NFSD4_FH_FOREIGN)) {\n\t\t\tif (!(op->opdesc->op_flags & ALLOWED_WITHOUT_FH)) {\n\t\t\t\top->status = nfserr_nofilehandle;\n\t\t\t\tgoto encode_op;\n\t\t\t}\n\t\t} else if (current_fh->fh_export &&\n\t\t\t   current_fh->fh_export->ex_fslocs.migrated &&\n\t\t\t  !(op->opdesc->op_flags & ALLOWED_ON_ABSENT_FS)) {\n\t\t\top->status = nfserr_moved;\n\t\t\tgoto encode_op;\n\t\t}\n\n\t\tfh_clear_pre_post_attrs(current_fh);\n\n\t\t \n\t\tif (op->opdesc->op_flags & OP_MODIFIES_SOMETHING) {\n\t\t\t \n\t\t\tu32 plen = op->opdesc->op_rsize_bop(rqstp, op);\n\t\t\t \n\t\t\tif (resp->opcnt < args->opcnt)\n\t\t\t\tplen += COMPOUND_ERR_SLACK_SPACE;\n\t\t\top->status = nfsd4_check_resp_size(resp, plen);\n\t\t}\n\n\t\tif (op->status)\n\t\t\tgoto encode_op;\n\n\t\tif (op->opdesc->op_get_currentstateid)\n\t\t\top->opdesc->op_get_currentstateid(cstate, &op->u);\n\t\top->status = op->opdesc->op_func(rqstp, cstate, &op->u);\n\n\t\t \n\t\tif (cstate->status == nfserr_replay_cache) {\n\t\t\tdprintk(\"%s NFS4.1 replay from cache\\n\", __func__);\n\t\t\tstatus = op->status;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!op->status) {\n\t\t\tif (op->opdesc->op_set_currentstateid)\n\t\t\t\top->opdesc->op_set_currentstateid(cstate, &op->u);\n\n\t\t\tif (op->opdesc->op_flags & OP_CLEAR_STATEID)\n\t\t\t\tclear_current_stateid(cstate);\n\n\t\t\tif (current_fh->fh_export &&\n\t\t\t\t\tneed_wrongsec_check(rqstp))\n\t\t\t\top->status = check_nfsd_access(current_fh->fh_export, rqstp);\n\t\t}\nencode_op:\n\t\tif (op->status == nfserr_replay_me) {\n\t\t\top->replay = &cstate->replay_owner->so_replay;\n\t\t\tnfsd4_encode_replay(resp->xdr, op);\n\t\t\tstatus = op->status = op->replay->rp_status;\n\t\t} else {\n\t\t\tnfsd4_encode_operation(resp, op);\n\t\t\tstatus = op->status;\n\t\t}\n\n\t\ttrace_nfsd_compound_status(args->client_opcnt, resp->opcnt,\n\t\t\t\t\t   status, nfsd4_op_name(op->opnum));\n\n\t\tnfsd4_cstate_clear_replay(cstate);\n\t\tnfsd4_increment_op_stats(op->opnum);\n\t}\n\n\tfh_put(current_fh);\n\tfh_put(save_fh);\n\tBUG_ON(cstate->replay_owner);\nout:\n\tcstate->status = status;\n\t \n\tset_bit(RQ_USEDEFERRAL, &rqstp->rq_flags);\n\treturn rpc_success;\n}\n\n#define op_encode_hdr_size\t\t(2)\n#define op_encode_stateid_maxsz\t\t(XDR_QUADLEN(NFS4_STATEID_SIZE))\n#define op_encode_verifier_maxsz\t(XDR_QUADLEN(NFS4_VERIFIER_SIZE))\n#define op_encode_change_info_maxsz\t(5)\n#define nfs4_fattr_bitmap_maxsz\t\t(4)\n\n \n#define op_encode_lockowner_maxsz\t(0)\n#define op_encode_lock_denied_maxsz\t(8 + op_encode_lockowner_maxsz)\n\n#define nfs4_owner_maxsz\t\t(1 + XDR_QUADLEN(IDMAP_NAMESZ))\n\n#define op_encode_ace_maxsz\t\t(3 + nfs4_owner_maxsz)\n#define op_encode_delegation_maxsz\t(1 + op_encode_stateid_maxsz + 1 + \\\n\t\t\t\t\t op_encode_ace_maxsz)\n\n#define op_encode_channel_attrs_maxsz\t(6 + 1 + 1)\n\n \nstatic u32 nfsd4_max_payload(const struct svc_rqst *rqstp)\n{\n\tu32 buflen;\n\n\tbuflen = (rqstp->rq_page_end - rqstp->rq_next_page) * PAGE_SIZE;\n\tbuflen -= rqstp->rq_auth_slack;\n\tbuflen -= rqstp->rq_res.head[0].iov_len;\n\treturn min_t(u32, buflen, svc_max_payload(rqstp));\n}\n\nstatic u32 nfsd4_only_status_rsize(const struct svc_rqst *rqstp,\n\t\t\t\t   const struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size) * sizeof(__be32);\n}\n\nstatic u32 nfsd4_status_stateid_rsize(const struct svc_rqst *rqstp,\n\t\t\t\t      const struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + op_encode_stateid_maxsz)* sizeof(__be32);\n}\n\nstatic u32 nfsd4_access_rsize(const struct svc_rqst *rqstp,\n\t\t\t      const struct nfsd4_op *op)\n{\n\t \n\treturn (op_encode_hdr_size + 2)* sizeof(__be32);\n}\n\nstatic u32 nfsd4_commit_rsize(const struct svc_rqst *rqstp,\n\t\t\t      const struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + op_encode_verifier_maxsz) * sizeof(__be32);\n}\n\nstatic u32 nfsd4_create_rsize(const struct svc_rqst *rqstp,\n\t\t\t      const struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + op_encode_change_info_maxsz\n\t\t+ nfs4_fattr_bitmap_maxsz) * sizeof(__be32);\n}\n\n \nstatic u32 nfsd4_getattr_rsize(const struct svc_rqst *rqstp,\n\t\t\t       const struct nfsd4_op *op)\n{\n\tconst u32 *bmap = op->u.getattr.ga_bmval;\n\tu32 bmap0 = bmap[0], bmap1 = bmap[1], bmap2 = bmap[2];\n\tu32 ret = 0;\n\n\tif (bmap0 & FATTR4_WORD0_ACL)\n\t\treturn nfsd4_max_payload(rqstp);\n\tif (bmap0 & FATTR4_WORD0_FS_LOCATIONS)\n\t\treturn nfsd4_max_payload(rqstp);\n\n\tif (bmap1 & FATTR4_WORD1_OWNER) {\n\t\tret += IDMAP_NAMESZ + 4;\n\t\tbmap1 &= ~FATTR4_WORD1_OWNER;\n\t}\n\tif (bmap1 & FATTR4_WORD1_OWNER_GROUP) {\n\t\tret += IDMAP_NAMESZ + 4;\n\t\tbmap1 &= ~FATTR4_WORD1_OWNER_GROUP;\n\t}\n\tif (bmap0 & FATTR4_WORD0_FILEHANDLE) {\n\t\tret += NFS4_FHSIZE + 4;\n\t\tbmap0 &= ~FATTR4_WORD0_FILEHANDLE;\n\t}\n\tif (bmap2 & FATTR4_WORD2_SECURITY_LABEL) {\n\t\tret += NFS4_MAXLABELLEN + 12;\n\t\tbmap2 &= ~FATTR4_WORD2_SECURITY_LABEL;\n\t}\n\t \n\tret += 16 * (hweight32(bmap0) + hweight32(bmap1) + hweight32(bmap2));\n\t \n\tret += 20;\n\treturn ret;\n}\n\nstatic u32 nfsd4_getfh_rsize(const struct svc_rqst *rqstp,\n\t\t\t     const struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + 1) * sizeof(__be32) + NFS4_FHSIZE;\n}\n\nstatic u32 nfsd4_link_rsize(const struct svc_rqst *rqstp,\n\t\t\t    const struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + op_encode_change_info_maxsz)\n\t\t* sizeof(__be32);\n}\n\nstatic u32 nfsd4_lock_rsize(const struct svc_rqst *rqstp,\n\t\t\t    const struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + op_encode_lock_denied_maxsz)\n\t\t* sizeof(__be32);\n}\n\nstatic u32 nfsd4_open_rsize(const struct svc_rqst *rqstp,\n\t\t\t    const struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + op_encode_stateid_maxsz\n\t\t+ op_encode_change_info_maxsz + 1\n\t\t+ nfs4_fattr_bitmap_maxsz\n\t\t+ op_encode_delegation_maxsz) * sizeof(__be32);\n}\n\nstatic u32 nfsd4_read_rsize(const struct svc_rqst *rqstp,\n\t\t\t    const struct nfsd4_op *op)\n{\n\tu32 rlen = min(op->u.read.rd_length, nfsd4_max_payload(rqstp));\n\n\treturn (op_encode_hdr_size + 2 + XDR_QUADLEN(rlen)) * sizeof(__be32);\n}\n\nstatic u32 nfsd4_read_plus_rsize(const struct svc_rqst *rqstp,\n\t\t\t\t const struct nfsd4_op *op)\n{\n\tu32 rlen = min(op->u.read.rd_length, nfsd4_max_payload(rqstp));\n\t \n\tu32 seg_len = 2 * (1 + 2 + 1);\n\n\treturn (op_encode_hdr_size + 2 + seg_len + XDR_QUADLEN(rlen)) * sizeof(__be32);\n}\n\nstatic u32 nfsd4_readdir_rsize(const struct svc_rqst *rqstp,\n\t\t\t       const struct nfsd4_op *op)\n{\n\tu32 rlen = min(op->u.readdir.rd_maxcount, nfsd4_max_payload(rqstp));\n\n\treturn (op_encode_hdr_size + op_encode_verifier_maxsz +\n\t\tXDR_QUADLEN(rlen)) * sizeof(__be32);\n}\n\nstatic u32 nfsd4_readlink_rsize(const struct svc_rqst *rqstp,\n\t\t\t\tconst struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + 1) * sizeof(__be32) + PAGE_SIZE;\n}\n\nstatic u32 nfsd4_remove_rsize(const struct svc_rqst *rqstp,\n\t\t\t      const struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + op_encode_change_info_maxsz)\n\t\t* sizeof(__be32);\n}\n\nstatic u32 nfsd4_rename_rsize(const struct svc_rqst *rqstp,\n\t\t\t      const struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + op_encode_change_info_maxsz\n\t\t+ op_encode_change_info_maxsz) * sizeof(__be32);\n}\n\nstatic u32 nfsd4_sequence_rsize(const struct svc_rqst *rqstp,\n\t\t\t\tconst struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size\n\t\t+ XDR_QUADLEN(NFS4_MAX_SESSIONID_LEN) + 5) * sizeof(__be32);\n}\n\nstatic u32 nfsd4_test_stateid_rsize(const struct svc_rqst *rqstp,\n\t\t\t\t    const struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + 1 + op->u.test_stateid.ts_num_ids)\n\t\t* sizeof(__be32);\n}\n\nstatic u32 nfsd4_setattr_rsize(const struct svc_rqst *rqstp,\n\t\t\t       const struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + nfs4_fattr_bitmap_maxsz) * sizeof(__be32);\n}\n\nstatic u32 nfsd4_secinfo_rsize(const struct svc_rqst *rqstp,\n\t\t\t       const struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + RPC_AUTH_MAXFLAVOR *\n\t\t(4 + XDR_QUADLEN(GSS_OID_MAX_LEN))) * sizeof(__be32);\n}\n\nstatic u32 nfsd4_setclientid_rsize(const struct svc_rqst *rqstp,\n\t\t\t\t   const struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + 2 + XDR_QUADLEN(NFS4_VERIFIER_SIZE)) *\n\t\t\t\t\t\t\t\tsizeof(__be32);\n}\n\nstatic u32 nfsd4_write_rsize(const struct svc_rqst *rqstp,\n\t\t\t     const struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + 2 + op_encode_verifier_maxsz) * sizeof(__be32);\n}\n\nstatic u32 nfsd4_exchange_id_rsize(const struct svc_rqst *rqstp,\n\t\t\t\t   const struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + 2 + 1 +  \\\n\t\t1 + 1 +  \\\n\t\t4 +  \\\n\t\t2 +  \\\n\t\t \\\n\t\tXDR_QUADLEN(NFS4_OPAQUE_LIMIT) + 1 +\\\n\t\t \\\n\t\tXDR_QUADLEN(NFS4_OPAQUE_LIMIT) + 1 +\\\n\t\t1 +  \\\n\t\t0  ) * sizeof(__be32);\n}\n\nstatic u32 nfsd4_bind_conn_to_session_rsize(const struct svc_rqst *rqstp,\n\t\t\t\t\t    const struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + \\\n\t\tXDR_QUADLEN(NFS4_MAX_SESSIONID_LEN) +  \\\n\t\t2  ) * sizeof(__be32);\n}\n\nstatic u32 nfsd4_create_session_rsize(const struct svc_rqst *rqstp,\n\t\t\t\t      const struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + \\\n\t\tXDR_QUADLEN(NFS4_MAX_SESSIONID_LEN) +  \\\n\t\t2 +  \\\n\t\top_encode_channel_attrs_maxsz + \\\n\t\top_encode_channel_attrs_maxsz) * sizeof(__be32);\n}\n\nstatic u32 nfsd4_copy_rsize(const struct svc_rqst *rqstp,\n\t\t\t    const struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size +\n\t\t1   +\n\t\top_encode_stateid_maxsz   +\n\t\t2   +\n\t\t1   +\n\t\top_encode_verifier_maxsz +\n\t\t1   +\n\t\t1  ) * sizeof(__be32);\n}\n\nstatic u32 nfsd4_offload_status_rsize(const struct svc_rqst *rqstp,\n\t\t\t\t      const struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size +\n\t\t2   +\n\t\t1  ) * sizeof(__be32);\n}\n\nstatic u32 nfsd4_copy_notify_rsize(const struct svc_rqst *rqstp,\n\t\t\t\t   const struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size +\n\t\t3   +\n\t\t1   +\n\t\t1   +\n\t\top_encode_stateid_maxsz   +\n\t\t1   +\n\t\t1   +\n\t\t1   +\n\t\tXDR_QUADLEN(NFS4_OPAQUE_LIMIT)  )\n\t\t* sizeof(__be32);\n}\n\n#ifdef CONFIG_NFSD_PNFS\nstatic u32 nfsd4_getdeviceinfo_rsize(const struct svc_rqst *rqstp,\n\t\t\t\t     const struct nfsd4_op *op)\n{\n\tu32 rlen = min(op->u.getdeviceinfo.gd_maxcount, nfsd4_max_payload(rqstp));\n\n\treturn (op_encode_hdr_size +\n\t\t1   +\n\t\tXDR_QUADLEN(rlen) +\n\t\t2  ) * sizeof(__be32);\n}\n\n \n#define MAX_LAYOUT_SIZE\t\t128\nstatic u32 nfsd4_layoutget_rsize(const struct svc_rqst *rqstp,\n\t\t\t\t const struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size +\n\t\t1   +\n\t\top_encode_stateid_maxsz +\n\t\t1   +\n\t\tMAX_LAYOUT_SIZE) * sizeof(__be32);\n}\n\nstatic u32 nfsd4_layoutcommit_rsize(const struct svc_rqst *rqstp,\n\t\t\t\t    const struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size +\n\t\t1   +\n\t\t2  ) * sizeof(__be32);\n}\n\nstatic u32 nfsd4_layoutreturn_rsize(const struct svc_rqst *rqstp,\n\t\t\t\t    const struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size +\n\t\t1   +\n\t\top_encode_stateid_maxsz) * sizeof(__be32);\n}\n#endif  \n\n\nstatic u32 nfsd4_seek_rsize(const struct svc_rqst *rqstp,\n\t\t\t    const struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + 3) * sizeof(__be32);\n}\n\nstatic u32 nfsd4_getxattr_rsize(const struct svc_rqst *rqstp,\n\t\t\t\tconst struct nfsd4_op *op)\n{\n\tu32 rlen = min_t(u32, XATTR_SIZE_MAX, nfsd4_max_payload(rqstp));\n\n\treturn (op_encode_hdr_size + 1 + XDR_QUADLEN(rlen)) * sizeof(__be32);\n}\n\nstatic u32 nfsd4_setxattr_rsize(const struct svc_rqst *rqstp,\n\t\t\t\tconst struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + op_encode_change_info_maxsz)\n\t\t* sizeof(__be32);\n}\nstatic u32 nfsd4_listxattrs_rsize(const struct svc_rqst *rqstp,\n\t\t\t\t  const struct nfsd4_op *op)\n{\n\tu32 rlen = min(op->u.listxattrs.lsxa_maxcount, nfsd4_max_payload(rqstp));\n\n\treturn (op_encode_hdr_size + 4 + XDR_QUADLEN(rlen)) * sizeof(__be32);\n}\n\nstatic u32 nfsd4_removexattr_rsize(const struct svc_rqst *rqstp,\n\t\t\t\t   const struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + op_encode_change_info_maxsz)\n\t\t* sizeof(__be32);\n}\n\n\nstatic const struct nfsd4_operation nfsd4_ops[] = {\n\t[OP_ACCESS] = {\n\t\t.op_func = nfsd4_access,\n\t\t.op_name = \"OP_ACCESS\",\n\t\t.op_rsize_bop = nfsd4_access_rsize,\n\t},\n\t[OP_CLOSE] = {\n\t\t.op_func = nfsd4_close,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_CLOSE\",\n\t\t.op_rsize_bop = nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = nfsd4_get_closestateid,\n\t\t.op_set_currentstateid = nfsd4_set_closestateid,\n\t},\n\t[OP_COMMIT] = {\n\t\t.op_func = nfsd4_commit,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_COMMIT\",\n\t\t.op_rsize_bop = nfsd4_commit_rsize,\n\t},\n\t[OP_CREATE] = {\n\t\t.op_func = nfsd4_create,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_CREATE\",\n\t\t.op_rsize_bop = nfsd4_create_rsize,\n\t},\n\t[OP_DELEGRETURN] = {\n\t\t.op_func = nfsd4_delegreturn,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DELEGRETURN\",\n\t\t.op_rsize_bop = nfsd4_only_status_rsize,\n\t\t.op_get_currentstateid = nfsd4_get_delegreturnstateid,\n\t},\n\t[OP_GETATTR] = {\n\t\t.op_func = nfsd4_getattr,\n\t\t.op_flags = ALLOWED_ON_ABSENT_FS,\n\t\t.op_rsize_bop = nfsd4_getattr_rsize,\n\t\t.op_name = \"OP_GETATTR\",\n\t},\n\t[OP_GETFH] = {\n\t\t.op_func = nfsd4_getfh,\n\t\t.op_name = \"OP_GETFH\",\n\t\t.op_rsize_bop = nfsd4_getfh_rsize,\n\t},\n\t[OP_LINK] = {\n\t\t.op_func = nfsd4_link,\n\t\t.op_flags = ALLOWED_ON_ABSENT_FS | OP_MODIFIES_SOMETHING\n\t\t\t\t| OP_CACHEME,\n\t\t.op_name = \"OP_LINK\",\n\t\t.op_rsize_bop = nfsd4_link_rsize,\n\t},\n\t[OP_LOCK] = {\n\t\t.op_func = nfsd4_lock,\n\t\t.op_flags = OP_MODIFIES_SOMETHING |\n\t\t\t\tOP_NONTRIVIAL_ERROR_ENCODE,\n\t\t.op_name = \"OP_LOCK\",\n\t\t.op_rsize_bop = nfsd4_lock_rsize,\n\t\t.op_set_currentstateid = nfsd4_set_lockstateid,\n\t},\n\t[OP_LOCKT] = {\n\t\t.op_func = nfsd4_lockt,\n\t\t.op_flags = OP_NONTRIVIAL_ERROR_ENCODE,\n\t\t.op_name = \"OP_LOCKT\",\n\t\t.op_rsize_bop = nfsd4_lock_rsize,\n\t},\n\t[OP_LOCKU] = {\n\t\t.op_func = nfsd4_locku,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LOCKU\",\n\t\t.op_rsize_bop = nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = nfsd4_get_lockustateid,\n\t},\n\t[OP_LOOKUP] = {\n\t\t.op_func = nfsd4_lookup,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_LOOKUP\",\n\t\t.op_rsize_bop = nfsd4_only_status_rsize,\n\t},\n\t[OP_LOOKUPP] = {\n\t\t.op_func = nfsd4_lookupp,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_LOOKUPP\",\n\t\t.op_rsize_bop = nfsd4_only_status_rsize,\n\t},\n\t[OP_NVERIFY] = {\n\t\t.op_func = nfsd4_nverify,\n\t\t.op_name = \"OP_NVERIFY\",\n\t\t.op_rsize_bop = nfsd4_only_status_rsize,\n\t},\n\t[OP_OPEN] = {\n\t\t.op_func = nfsd4_open,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN\",\n\t\t.op_rsize_bop = nfsd4_open_rsize,\n\t\t.op_set_currentstateid = nfsd4_set_openstateid,\n\t},\n\t[OP_OPEN_CONFIRM] = {\n\t\t.op_func = nfsd4_open_confirm,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN_CONFIRM\",\n\t\t.op_rsize_bop = nfsd4_status_stateid_rsize,\n\t},\n\t[OP_OPEN_DOWNGRADE] = {\n\t\t.op_func = nfsd4_open_downgrade,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN_DOWNGRADE\",\n\t\t.op_rsize_bop = nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = nfsd4_get_opendowngradestateid,\n\t\t.op_set_currentstateid = nfsd4_set_opendowngradestateid,\n\t},\n\t[OP_PUTFH] = {\n\t\t.op_func = nfsd4_putfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTFH\",\n\t\t.op_rsize_bop = nfsd4_only_status_rsize,\n\t},\n\t[OP_PUTPUBFH] = {\n\t\t.op_func = nfsd4_putrootfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTPUBFH\",\n\t\t.op_rsize_bop = nfsd4_only_status_rsize,\n\t},\n\t[OP_PUTROOTFH] = {\n\t\t.op_func = nfsd4_putrootfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTROOTFH\",\n\t\t.op_rsize_bop = nfsd4_only_status_rsize,\n\t},\n\t[OP_READ] = {\n\t\t.op_func = nfsd4_read,\n\t\t.op_release = nfsd4_read_release,\n\t\t.op_name = \"OP_READ\",\n\t\t.op_rsize_bop = nfsd4_read_rsize,\n\t\t.op_get_currentstateid = nfsd4_get_readstateid,\n\t},\n\t[OP_READDIR] = {\n\t\t.op_func = nfsd4_readdir,\n\t\t.op_name = \"OP_READDIR\",\n\t\t.op_rsize_bop = nfsd4_readdir_rsize,\n\t},\n\t[OP_READLINK] = {\n\t\t.op_func = nfsd4_readlink,\n\t\t.op_name = \"OP_READLINK\",\n\t\t.op_rsize_bop = nfsd4_readlink_rsize,\n\t},\n\t[OP_REMOVE] = {\n\t\t.op_func = nfsd4_remove,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_REMOVE\",\n\t\t.op_rsize_bop = nfsd4_remove_rsize,\n\t},\n\t[OP_RENAME] = {\n\t\t.op_func = nfsd4_rename,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_RENAME\",\n\t\t.op_rsize_bop = nfsd4_rename_rsize,\n\t},\n\t[OP_RENEW] = {\n\t\t.op_func = nfsd4_renew,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RENEW\",\n\t\t.op_rsize_bop = nfsd4_only_status_rsize,\n\n\t},\n\t[OP_RESTOREFH] = {\n\t\t.op_func = nfsd4_restorefh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RESTOREFH\",\n\t\t.op_rsize_bop = nfsd4_only_status_rsize,\n\t},\n\t[OP_SAVEFH] = {\n\t\t.op_func = nfsd4_savefh,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_SAVEFH\",\n\t\t.op_rsize_bop = nfsd4_only_status_rsize,\n\t},\n\t[OP_SECINFO] = {\n\t\t.op_func = nfsd4_secinfo,\n\t\t.op_release = nfsd4_secinfo_release,\n\t\t.op_flags = OP_HANDLES_WRONGSEC,\n\t\t.op_name = \"OP_SECINFO\",\n\t\t.op_rsize_bop = nfsd4_secinfo_rsize,\n\t},\n\t[OP_SETATTR] = {\n\t\t.op_func = nfsd4_setattr,\n\t\t.op_name = \"OP_SETATTR\",\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME\n\t\t\t\t| OP_NONTRIVIAL_ERROR_ENCODE,\n\t\t.op_rsize_bop = nfsd4_setattr_rsize,\n\t\t.op_get_currentstateid = nfsd4_get_setattrstateid,\n\t},\n\t[OP_SETCLIENTID] = {\n\t\t.op_func = nfsd4_setclientid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING | OP_CACHEME\n\t\t\t\t| OP_NONTRIVIAL_ERROR_ENCODE,\n\t\t.op_name = \"OP_SETCLIENTID\",\n\t\t.op_rsize_bop = nfsd4_setclientid_rsize,\n\t},\n\t[OP_SETCLIENTID_CONFIRM] = {\n\t\t.op_func = nfsd4_setclientid_confirm,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_SETCLIENTID_CONFIRM\",\n\t\t.op_rsize_bop = nfsd4_only_status_rsize,\n\t},\n\t[OP_VERIFY] = {\n\t\t.op_func = nfsd4_verify,\n\t\t.op_name = \"OP_VERIFY\",\n\t\t.op_rsize_bop = nfsd4_only_status_rsize,\n\t},\n\t[OP_WRITE] = {\n\t\t.op_func = nfsd4_write,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_WRITE\",\n\t\t.op_rsize_bop = nfsd4_write_rsize,\n\t\t.op_get_currentstateid = nfsd4_get_writestateid,\n\t},\n\t[OP_RELEASE_LOCKOWNER] = {\n\t\t.op_func = nfsd4_release_lockowner,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RELEASE_LOCKOWNER\",\n\t\t.op_rsize_bop = nfsd4_only_status_rsize,\n\t},\n\n\t \n\t[OP_EXCHANGE_ID] = {\n\t\t.op_func = nfsd4_exchange_id,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_EXCHANGE_ID\",\n\t\t.op_rsize_bop = nfsd4_exchange_id_rsize,\n\t},\n\t[OP_BACKCHANNEL_CTL] = {\n\t\t.op_func = nfsd4_backchannel_ctl,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_BACKCHANNEL_CTL\",\n\t\t.op_rsize_bop = nfsd4_only_status_rsize,\n\t},\n\t[OP_BIND_CONN_TO_SESSION] = {\n\t\t.op_func = nfsd4_bind_conn_to_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_BIND_CONN_TO_SESSION\",\n\t\t.op_rsize_bop = nfsd4_bind_conn_to_session_rsize,\n\t},\n\t[OP_CREATE_SESSION] = {\n\t\t.op_func = nfsd4_create_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_CREATE_SESSION\",\n\t\t.op_rsize_bop = nfsd4_create_session_rsize,\n\t},\n\t[OP_DESTROY_SESSION] = {\n\t\t.op_func = nfsd4_destroy_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DESTROY_SESSION\",\n\t\t.op_rsize_bop = nfsd4_only_status_rsize,\n\t},\n\t[OP_SEQUENCE] = {\n\t\t.op_func = nfsd4_sequence,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP,\n\t\t.op_name = \"OP_SEQUENCE\",\n\t\t.op_rsize_bop = nfsd4_sequence_rsize,\n\t},\n\t[OP_DESTROY_CLIENTID] = {\n\t\t.op_func = nfsd4_destroy_clientid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DESTROY_CLIENTID\",\n\t\t.op_rsize_bop = nfsd4_only_status_rsize,\n\t},\n\t[OP_RECLAIM_COMPLETE] = {\n\t\t.op_func = nfsd4_reclaim_complete,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RECLAIM_COMPLETE\",\n\t\t.op_rsize_bop = nfsd4_only_status_rsize,\n\t},\n\t[OP_SECINFO_NO_NAME] = {\n\t\t.op_func = nfsd4_secinfo_no_name,\n\t\t.op_release = nfsd4_secinfo_no_name_release,\n\t\t.op_flags = OP_HANDLES_WRONGSEC,\n\t\t.op_name = \"OP_SECINFO_NO_NAME\",\n\t\t.op_rsize_bop = nfsd4_secinfo_rsize,\n\t},\n\t[OP_TEST_STATEID] = {\n\t\t.op_func = nfsd4_test_stateid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH,\n\t\t.op_name = \"OP_TEST_STATEID\",\n\t\t.op_rsize_bop = nfsd4_test_stateid_rsize,\n\t},\n\t[OP_FREE_STATEID] = {\n\t\t.op_func = nfsd4_free_stateid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_FREE_STATEID\",\n\t\t.op_get_currentstateid = nfsd4_get_freestateid,\n\t\t.op_rsize_bop = nfsd4_only_status_rsize,\n\t},\n#ifdef CONFIG_NFSD_PNFS\n\t[OP_GETDEVICEINFO] = {\n\t\t.op_func = nfsd4_getdeviceinfo,\n\t\t.op_release = nfsd4_getdeviceinfo_release,\n\t\t.op_flags = ALLOWED_WITHOUT_FH,\n\t\t.op_name = \"OP_GETDEVICEINFO\",\n\t\t.op_rsize_bop = nfsd4_getdeviceinfo_rsize,\n\t},\n\t[OP_LAYOUTGET] = {\n\t\t.op_func = nfsd4_layoutget,\n\t\t.op_release = nfsd4_layoutget_release,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTGET\",\n\t\t.op_rsize_bop = nfsd4_layoutget_rsize,\n\t},\n\t[OP_LAYOUTCOMMIT] = {\n\t\t.op_func = nfsd4_layoutcommit,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTCOMMIT\",\n\t\t.op_rsize_bop = nfsd4_layoutcommit_rsize,\n\t},\n\t[OP_LAYOUTRETURN] = {\n\t\t.op_func = nfsd4_layoutreturn,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTRETURN\",\n\t\t.op_rsize_bop = nfsd4_layoutreturn_rsize,\n\t},\n#endif  \n\n\t \n\t[OP_ALLOCATE] = {\n\t\t.op_func = nfsd4_allocate,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_ALLOCATE\",\n\t\t.op_rsize_bop = nfsd4_only_status_rsize,\n\t},\n\t[OP_DEALLOCATE] = {\n\t\t.op_func = nfsd4_deallocate,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DEALLOCATE\",\n\t\t.op_rsize_bop = nfsd4_only_status_rsize,\n\t},\n\t[OP_CLONE] = {\n\t\t.op_func = nfsd4_clone,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_CLONE\",\n\t\t.op_rsize_bop = nfsd4_only_status_rsize,\n\t},\n\t[OP_COPY] = {\n\t\t.op_func = nfsd4_copy,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_COPY\",\n\t\t.op_rsize_bop = nfsd4_copy_rsize,\n\t},\n\t[OP_READ_PLUS] = {\n\t\t.op_func = nfsd4_read,\n\t\t.op_release = nfsd4_read_release,\n\t\t.op_name = \"OP_READ_PLUS\",\n\t\t.op_rsize_bop = nfsd4_read_plus_rsize,\n\t\t.op_get_currentstateid = nfsd4_get_readstateid,\n\t},\n\t[OP_SEEK] = {\n\t\t.op_func = nfsd4_seek,\n\t\t.op_name = \"OP_SEEK\",\n\t\t.op_rsize_bop = nfsd4_seek_rsize,\n\t},\n\t[OP_OFFLOAD_STATUS] = {\n\t\t.op_func = nfsd4_offload_status,\n\t\t.op_name = \"OP_OFFLOAD_STATUS\",\n\t\t.op_rsize_bop = nfsd4_offload_status_rsize,\n\t},\n\t[OP_OFFLOAD_CANCEL] = {\n\t\t.op_func = nfsd4_offload_cancel,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OFFLOAD_CANCEL\",\n\t\t.op_rsize_bop = nfsd4_only_status_rsize,\n\t},\n\t[OP_COPY_NOTIFY] = {\n\t\t.op_func = nfsd4_copy_notify,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_COPY_NOTIFY\",\n\t\t.op_rsize_bop = nfsd4_copy_notify_rsize,\n\t},\n\t[OP_GETXATTR] = {\n\t\t.op_func = nfsd4_getxattr,\n\t\t.op_name = \"OP_GETXATTR\",\n\t\t.op_rsize_bop = nfsd4_getxattr_rsize,\n\t},\n\t[OP_SETXATTR] = {\n\t\t.op_func = nfsd4_setxattr,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_SETXATTR\",\n\t\t.op_rsize_bop = nfsd4_setxattr_rsize,\n\t},\n\t[OP_LISTXATTRS] = {\n\t\t.op_func = nfsd4_listxattrs,\n\t\t.op_name = \"OP_LISTXATTRS\",\n\t\t.op_rsize_bop = nfsd4_listxattrs_rsize,\n\t},\n\t[OP_REMOVEXATTR] = {\n\t\t.op_func = nfsd4_removexattr,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_REMOVEXATTR\",\n\t\t.op_rsize_bop = nfsd4_removexattr_rsize,\n\t},\n};\n\n \n\nbool nfsd4_spo_must_allow(struct svc_rqst *rqstp)\n{\n\tstruct nfsd4_compoundres *resp = rqstp->rq_resp;\n\tstruct nfsd4_compoundargs *argp = rqstp->rq_argp;\n\tstruct nfsd4_op *this;\n\tstruct nfsd4_compound_state *cstate = &resp->cstate;\n\tstruct nfs4_op_map *allow = &cstate->clp->cl_spo_must_allow;\n\tu32 opiter;\n\n\tif (!cstate->minorversion)\n\t\treturn false;\n\n\tif (cstate->spo_must_allowed)\n\t\treturn true;\n\n\topiter = resp->opcnt;\n\twhile (opiter < argp->opcnt) {\n\t\tthis = &argp->ops[opiter++];\n\t\tif (test_bit(this->opnum, allow->u.longs) &&\n\t\t\tcstate->clp->cl_mach_cred &&\n\t\t\tnfsd4_mach_creds_match(cstate->clp, rqstp)) {\n\t\t\tcstate->spo_must_allowed = true;\n\t\t\treturn true;\n\t\t}\n\t}\n\tcstate->spo_must_allowed = false;\n\treturn false;\n}\n\nint nfsd4_max_reply(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\tif (op->opnum == OP_ILLEGAL || op->status == nfserr_notsupp)\n\t\treturn op_encode_hdr_size * sizeof(__be32);\n\n\tBUG_ON(OPDESC(op)->op_rsize_bop == NULL);\n\treturn OPDESC(op)->op_rsize_bop(rqstp, op);\n}\n\nvoid warn_on_nonidempotent_op(struct nfsd4_op *op)\n{\n\tif (OPDESC(op)->op_flags & OP_MODIFIES_SOMETHING) {\n\t\tpr_err(\"unable to encode reply to nonidempotent op %u (%s)\\n\",\n\t\t\top->opnum, nfsd4_op_name(op->opnum));\n\t\tWARN_ON_ONCE(1);\n\t}\n}\n\nstatic const char *nfsd4_op_name(unsigned opnum)\n{\n\tif (opnum < ARRAY_SIZE(nfsd4_ops))\n\t\treturn nfsd4_ops[opnum].op_name;\n\treturn \"unknown_operation\";\n}\n\nstatic const struct svc_procedure nfsd_procedures4[2] = {\n\t[NFSPROC4_NULL] = {\n\t\t.pc_func = nfsd4_proc_null,\n\t\t.pc_decode = nfssvc_decode_voidarg,\n\t\t.pc_encode = nfssvc_encode_voidres,\n\t\t.pc_argsize = sizeof(struct nfsd_voidargs),\n\t\t.pc_argzero = sizeof(struct nfsd_voidargs),\n\t\t.pc_ressize = sizeof(struct nfsd_voidres),\n\t\t.pc_cachetype = RC_NOCACHE,\n\t\t.pc_xdrressize = 1,\n\t\t.pc_name = \"NULL\",\n\t},\n\t[NFSPROC4_COMPOUND] = {\n\t\t.pc_func = nfsd4_proc_compound,\n\t\t.pc_decode = nfs4svc_decode_compoundargs,\n\t\t.pc_encode = nfs4svc_encode_compoundres,\n\t\t.pc_argsize = sizeof(struct nfsd4_compoundargs),\n\t\t.pc_argzero = offsetof(struct nfsd4_compoundargs, iops),\n\t\t.pc_ressize = sizeof(struct nfsd4_compoundres),\n\t\t.pc_release = nfsd4_release_compoundargs,\n\t\t.pc_cachetype = RC_NOCACHE,\n\t\t.pc_xdrressize = NFSD_BUFSIZE/4,\n\t\t.pc_name = \"COMPOUND\",\n\t},\n};\n\nstatic DEFINE_PER_CPU_ALIGNED(unsigned long,\n\t\t\t      nfsd_count4[ARRAY_SIZE(nfsd_procedures4)]);\nconst struct svc_version nfsd_version4 = {\n\t.vs_vers\t\t= 4,\n\t.vs_nproc\t\t= ARRAY_SIZE(nfsd_procedures4),\n\t.vs_proc\t\t= nfsd_procedures4,\n\t.vs_count\t\t= nfsd_count4,\n\t.vs_dispatch\t\t= nfsd_dispatch,\n\t.vs_xdrsize\t\t= NFS4_SVC_XDRSIZE,\n\t.vs_rpcb_optnl\t\t= true,\n\t.vs_need_cong_ctrl\t= true,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}