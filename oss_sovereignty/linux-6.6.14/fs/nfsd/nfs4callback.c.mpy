{
  "module_name": "nfs4callback.c",
  "hash_id": "78d084701b73032989d12ee1207b13660c04a54505d81fec8a18d99527c86978",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfsd/nfs4callback.c",
  "human_readable_source": " \n\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/slab.h>\n#include \"nfsd.h\"\n#include \"state.h\"\n#include \"netns.h\"\n#include \"trace.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n\n#define NFSDDBG_FACILITY                NFSDDBG_PROC\n\nstatic void nfsd4_mark_cb_fault(struct nfs4_client *, int reason);\n\n#define NFSPROC4_CB_NULL 0\n#define NFSPROC4_CB_COMPOUND 1\n\n \n\nstruct nfs4_cb_compound_hdr {\n\t \n\tu32\t\tident;\t \n\tu32\t\tnops;\n\t__be32\t\t*nops_p;\n\tu32\t\tminorversion;\n\t \n\tint\t\tstatus;\n};\n\nstatic __be32 *xdr_encode_empty_array(__be32 *p)\n{\n\t*p++ = xdr_zero;\n\treturn p;\n}\n\n \n\nstatic void encode_uint32(struct xdr_stream *xdr, u32 n)\n{\n\tWARN_ON_ONCE(xdr_stream_encode_u32(xdr, n) < 0);\n}\n\nstatic void encode_bitmap4(struct xdr_stream *xdr, const __u32 *bitmap,\n\t\t\t   size_t len)\n{\n\tWARN_ON_ONCE(xdr_stream_encode_uint32_array(xdr, bitmap, len) < 0);\n}\n\n \nenum nfs_cb_opnum4 {\n\tOP_CB_GETATTR\t\t\t= 3,\n\tOP_CB_RECALL\t\t\t= 4,\n\tOP_CB_LAYOUTRECALL\t\t= 5,\n\tOP_CB_NOTIFY\t\t\t= 6,\n\tOP_CB_PUSH_DELEG\t\t= 7,\n\tOP_CB_RECALL_ANY\t\t= 8,\n\tOP_CB_RECALLABLE_OBJ_AVAIL\t= 9,\n\tOP_CB_RECALL_SLOT\t\t= 10,\n\tOP_CB_SEQUENCE\t\t\t= 11,\n\tOP_CB_WANTS_CANCELLED\t\t= 12,\n\tOP_CB_NOTIFY_LOCK\t\t= 13,\n\tOP_CB_NOTIFY_DEVICEID\t\t= 14,\n\tOP_CB_OFFLOAD\t\t\t= 15,\n\tOP_CB_ILLEGAL\t\t\t= 10044\n};\n\nstatic void encode_nfs_cb_opnum4(struct xdr_stream *xdr, enum nfs_cb_opnum4 op)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4);\n\t*p = cpu_to_be32(op);\n}\n\n \nstatic void encode_nfs_fh4(struct xdr_stream *xdr, const struct knfsd_fh *fh)\n{\n\tu32 length = fh->fh_size;\n\t__be32 *p;\n\n\tBUG_ON(length > NFS4_FHSIZE);\n\tp = xdr_reserve_space(xdr, 4 + length);\n\txdr_encode_opaque(p, &fh->fh_raw, length);\n}\n\n \nstatic void encode_stateid4(struct xdr_stream *xdr, const stateid_t *sid)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, NFS4_STATEID_SIZE);\n\t*p++ = cpu_to_be32(sid->si_generation);\n\txdr_encode_opaque_fixed(p, &sid->si_opaque, NFS4_STATEID_OTHER_SIZE);\n}\n\n \nstatic void encode_sessionid4(struct xdr_stream *xdr,\n\t\t\t      const struct nfsd4_session *session)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, NFS4_MAX_SESSIONID_LEN);\n\txdr_encode_opaque_fixed(p, session->se_sessionid.data,\n\t\t\t\t\tNFS4_MAX_SESSIONID_LEN);\n}\n\n \nstatic const struct {\n\tint stat;\n\tint errno;\n} nfs_cb_errtbl[] = {\n\t{ NFS4_OK,\t\t0\t\t},\n\t{ NFS4ERR_PERM,\t\t-EPERM\t\t},\n\t{ NFS4ERR_NOENT,\t-ENOENT\t\t},\n\t{ NFS4ERR_IO,\t\t-EIO\t\t},\n\t{ NFS4ERR_NXIO,\t\t-ENXIO\t\t},\n\t{ NFS4ERR_ACCESS,\t-EACCES\t\t},\n\t{ NFS4ERR_EXIST,\t-EEXIST\t\t},\n\t{ NFS4ERR_XDEV,\t\t-EXDEV\t\t},\n\t{ NFS4ERR_NOTDIR,\t-ENOTDIR\t},\n\t{ NFS4ERR_ISDIR,\t-EISDIR\t\t},\n\t{ NFS4ERR_INVAL,\t-EINVAL\t\t},\n\t{ NFS4ERR_FBIG,\t\t-EFBIG\t\t},\n\t{ NFS4ERR_NOSPC,\t-ENOSPC\t\t},\n\t{ NFS4ERR_ROFS,\t\t-EROFS\t\t},\n\t{ NFS4ERR_MLINK,\t-EMLINK\t\t},\n\t{ NFS4ERR_NAMETOOLONG,\t-ENAMETOOLONG\t},\n\t{ NFS4ERR_NOTEMPTY,\t-ENOTEMPTY\t},\n\t{ NFS4ERR_DQUOT,\t-EDQUOT\t\t},\n\t{ NFS4ERR_STALE,\t-ESTALE\t\t},\n\t{ NFS4ERR_BADHANDLE,\t-EBADHANDLE\t},\n\t{ NFS4ERR_BAD_COOKIE,\t-EBADCOOKIE\t},\n\t{ NFS4ERR_NOTSUPP,\t-ENOTSUPP\t},\n\t{ NFS4ERR_TOOSMALL,\t-ETOOSMALL\t},\n\t{ NFS4ERR_SERVERFAULT,\t-ESERVERFAULT\t},\n\t{ NFS4ERR_BADTYPE,\t-EBADTYPE\t},\n\t{ NFS4ERR_LOCKED,\t-EAGAIN\t\t},\n\t{ NFS4ERR_RESOURCE,\t-EREMOTEIO\t},\n\t{ NFS4ERR_SYMLINK,\t-ELOOP\t\t},\n\t{ NFS4ERR_OP_ILLEGAL,\t-EOPNOTSUPP\t},\n\t{ NFS4ERR_DEADLOCK,\t-EDEADLK\t},\n\t{ -1,\t\t\t-EIO\t\t}\n};\n\n \nstatic int nfs_cb_stat_to_errno(int status)\n{\n\tint i;\n\n\tfor (i = 0; nfs_cb_errtbl[i].stat != -1; i++) {\n\t\tif (nfs_cb_errtbl[i].stat == status)\n\t\t\treturn nfs_cb_errtbl[i].errno;\n\t}\n\n\tdprintk(\"NFSD: Unrecognized NFS CB status value: %u\\n\", status);\n\treturn -status;\n}\n\nstatic int decode_cb_op_status(struct xdr_stream *xdr,\n\t\t\t       enum nfs_cb_opnum4 expected, int *status)\n{\n\t__be32 *p;\n\tu32 op;\n\n\tp = xdr_inline_decode(xdr, 4 + 4);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\top = be32_to_cpup(p++);\n\tif (unlikely(op != expected))\n\t\tgoto out_unexpected;\n\t*status = nfs_cb_stat_to_errno(be32_to_cpup(p));\n\treturn 0;\nout_overflow:\n\treturn -EIO;\nout_unexpected:\n\tdprintk(\"NFSD: Callback server returned operation %d but \"\n\t\t\"we issued a request for %d\\n\", op, expected);\n\treturn -EIO;\n}\n\n \nstatic void encode_cb_compound4args(struct xdr_stream *xdr,\n\t\t\t\t    struct nfs4_cb_compound_hdr *hdr)\n{\n\t__be32 * p;\n\n\tp = xdr_reserve_space(xdr, 4 + 4 + 4 + 4);\n\tp = xdr_encode_empty_array(p);\t\t \n\t*p++ = cpu_to_be32(hdr->minorversion);\n\t*p++ = cpu_to_be32(hdr->ident);\n\n\thdr->nops_p = p;\n\t*p = cpu_to_be32(hdr->nops);\t\t \n}\n\n \nstatic void encode_cb_nops(struct nfs4_cb_compound_hdr *hdr)\n{\n\tBUG_ON(hdr->nops > NFS4_MAX_BACK_CHANNEL_OPS);\n\t*hdr->nops_p = cpu_to_be32(hdr->nops);\n}\n\n \nstatic int decode_cb_compound4res(struct xdr_stream *xdr,\n\t\t\t\t  struct nfs4_cb_compound_hdr *hdr)\n{\n\tu32 length;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4 + 4);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\thdr->status = be32_to_cpup(p++);\n\t \n\tlength = be32_to_cpup(p++);\n\tp = xdr_inline_decode(xdr, length + 4);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\tp += XDR_QUADLEN(length);\n\thdr->nops = be32_to_cpup(p);\n\treturn 0;\nout_overflow:\n\treturn -EIO;\n}\n\n \nstatic void encode_cb_recall4args(struct xdr_stream *xdr,\n\t\t\t\t  const struct nfs4_delegation *dp,\n\t\t\t\t  struct nfs4_cb_compound_hdr *hdr)\n{\n\t__be32 *p;\n\n\tencode_nfs_cb_opnum4(xdr, OP_CB_RECALL);\n\tencode_stateid4(xdr, &dp->dl_stid.sc_stateid);\n\n\tp = xdr_reserve_space(xdr, 4);\n\t*p++ = xdr_zero;\t\t\t \n\n\tencode_nfs_fh4(xdr, &dp->dl_stid.sc_file->fi_fhandle);\n\n\thdr->nops++;\n}\n\n \nstatic void\nencode_cb_recallany4args(struct xdr_stream *xdr,\n\tstruct nfs4_cb_compound_hdr *hdr, struct nfsd4_cb_recall_any *ra)\n{\n\tencode_nfs_cb_opnum4(xdr, OP_CB_RECALL_ANY);\n\tencode_uint32(xdr, ra->ra_keep);\n\tencode_bitmap4(xdr, ra->ra_bmval, ARRAY_SIZE(ra->ra_bmval));\n\thdr->nops++;\n}\n\n \nstatic void encode_cb_sequence4args(struct xdr_stream *xdr,\n\t\t\t\t    const struct nfsd4_callback *cb,\n\t\t\t\t    struct nfs4_cb_compound_hdr *hdr)\n{\n\tstruct nfsd4_session *session = cb->cb_clp->cl_cb_session;\n\t__be32 *p;\n\n\tif (hdr->minorversion == 0)\n\t\treturn;\n\n\tencode_nfs_cb_opnum4(xdr, OP_CB_SEQUENCE);\n\tencode_sessionid4(xdr, session);\n\n\tp = xdr_reserve_space(xdr, 4 + 4 + 4 + 4 + 4);\n\t*p++ = cpu_to_be32(session->se_cb_seq_nr);\t \n\t*p++ = xdr_zero;\t\t\t \n\t*p++ = xdr_zero;\t\t\t \n\t*p++ = xdr_zero;\t\t\t \n\txdr_encode_empty_array(p);\t\t \n\n\thdr->nops++;\n}\n\n \nstatic int decode_cb_sequence4resok(struct xdr_stream *xdr,\n\t\t\t\t    struct nfsd4_callback *cb)\n{\n\tstruct nfsd4_session *session = cb->cb_clp->cl_cb_session;\n\tint status = -ESERVERFAULT;\n\t__be32 *p;\n\tu32 dummy;\n\n\t \n\tp = xdr_inline_decode(xdr, NFS4_MAX_SESSIONID_LEN + 4 + 4 + 4 + 4);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\n\tif (memcmp(p, session->se_sessionid.data, NFS4_MAX_SESSIONID_LEN)) {\n\t\tdprintk(\"NFS: %s Invalid session id\\n\", __func__);\n\t\tgoto out;\n\t}\n\tp += XDR_QUADLEN(NFS4_MAX_SESSIONID_LEN);\n\n\tdummy = be32_to_cpup(p++);\n\tif (dummy != session->se_cb_seq_nr) {\n\t\tdprintk(\"NFS: %s Invalid sequence number\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tdummy = be32_to_cpup(p++);\n\tif (dummy != 0) {\n\t\tdprintk(\"NFS: %s Invalid slotid\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\t \n\tstatus = 0;\nout:\n\tcb->cb_seq_status = status;\n\treturn status;\nout_overflow:\n\tstatus = -EIO;\n\tgoto out;\n}\n\nstatic int decode_cb_sequence4res(struct xdr_stream *xdr,\n\t\t\t\t  struct nfsd4_callback *cb)\n{\n\tint status;\n\n\tif (cb->cb_clp->cl_minorversion == 0)\n\t\treturn 0;\n\n\tstatus = decode_cb_op_status(xdr, OP_CB_SEQUENCE, &cb->cb_seq_status);\n\tif (unlikely(status || cb->cb_seq_status))\n\t\treturn status;\n\n\treturn decode_cb_sequence4resok(xdr, cb);\n}\n\n \n\n \nstatic void nfs4_xdr_enc_cb_null(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\t const void *__unused)\n{\n\txdr_reserve_space(xdr, 0);\n}\n\n \nstatic void nfs4_xdr_enc_cb_recall(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\t   const void *data)\n{\n\tconst struct nfsd4_callback *cb = data;\n\tconst struct nfs4_delegation *dp = cb_to_delegation(cb);\n\tstruct nfs4_cb_compound_hdr hdr = {\n\t\t.ident = cb->cb_clp->cl_cb_ident,\n\t\t.minorversion = cb->cb_clp->cl_minorversion,\n\t};\n\n\tencode_cb_compound4args(xdr, &hdr);\n\tencode_cb_sequence4args(xdr, cb, &hdr);\n\tencode_cb_recall4args(xdr, dp, &hdr);\n\tencode_cb_nops(&hdr);\n}\n\n \nstatic void\nnfs4_xdr_enc_cb_recall_any(struct rpc_rqst *req,\n\t\tstruct xdr_stream *xdr, const void *data)\n{\n\tconst struct nfsd4_callback *cb = data;\n\tstruct nfsd4_cb_recall_any *ra;\n\tstruct nfs4_cb_compound_hdr hdr = {\n\t\t.ident = cb->cb_clp->cl_cb_ident,\n\t\t.minorversion = cb->cb_clp->cl_minorversion,\n\t};\n\n\tra = container_of(cb, struct nfsd4_cb_recall_any, ra_cb);\n\tencode_cb_compound4args(xdr, &hdr);\n\tencode_cb_sequence4args(xdr, cb, &hdr);\n\tencode_cb_recallany4args(xdr, &hdr, ra);\n\tencode_cb_nops(&hdr);\n}\n\n \n\nstatic int nfs4_xdr_dec_cb_null(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\tvoid *__unused)\n{\n\treturn 0;\n}\n\n \nstatic int nfs4_xdr_dec_cb_recall(struct rpc_rqst *rqstp,\n\t\t\t\t  struct xdr_stream *xdr,\n\t\t\t\t  void *data)\n{\n\tstruct nfsd4_callback *cb = data;\n\tstruct nfs4_cb_compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_cb_compound4res(xdr, &hdr);\n\tif (unlikely(status))\n\t\treturn status;\n\n\tstatus = decode_cb_sequence4res(xdr, cb);\n\tif (unlikely(status || cb->cb_seq_status))\n\t\treturn status;\n\n\treturn decode_cb_op_status(xdr, OP_CB_RECALL, &cb->cb_status);\n}\n\n \nstatic int\nnfs4_xdr_dec_cb_recall_any(struct rpc_rqst *rqstp,\n\t\t\t\t  struct xdr_stream *xdr,\n\t\t\t\t  void *data)\n{\n\tstruct nfsd4_callback *cb = data;\n\tstruct nfs4_cb_compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_cb_compound4res(xdr, &hdr);\n\tif (unlikely(status))\n\t\treturn status;\n\tstatus = decode_cb_sequence4res(xdr, cb);\n\tif (unlikely(status || cb->cb_seq_status))\n\t\treturn status;\n\tstatus =  decode_cb_op_status(xdr, OP_CB_RECALL_ANY, &cb->cb_status);\n\treturn status;\n}\n\n#ifdef CONFIG_NFSD_PNFS\n \nstatic void encode_cb_layout4args(struct xdr_stream *xdr,\n\t\t\t\t  const struct nfs4_layout_stateid *ls,\n\t\t\t\t  struct nfs4_cb_compound_hdr *hdr)\n{\n\t__be32 *p;\n\n\tBUG_ON(hdr->minorversion == 0);\n\n\tp = xdr_reserve_space(xdr, 5 * 4);\n\t*p++ = cpu_to_be32(OP_CB_LAYOUTRECALL);\n\t*p++ = cpu_to_be32(ls->ls_layout_type);\n\t*p++ = cpu_to_be32(IOMODE_ANY);\n\t*p++ = cpu_to_be32(1);\n\t*p = cpu_to_be32(RETURN_FILE);\n\n\tencode_nfs_fh4(xdr, &ls->ls_stid.sc_file->fi_fhandle);\n\n\tp = xdr_reserve_space(xdr, 2 * 8);\n\tp = xdr_encode_hyper(p, 0);\n\txdr_encode_hyper(p, NFS4_MAX_UINT64);\n\n\tencode_stateid4(xdr, &ls->ls_recall_sid);\n\n\thdr->nops++;\n}\n\nstatic void nfs4_xdr_enc_cb_layout(struct rpc_rqst *req,\n\t\t\t\t   struct xdr_stream *xdr,\n\t\t\t\t   const void *data)\n{\n\tconst struct nfsd4_callback *cb = data;\n\tconst struct nfs4_layout_stateid *ls =\n\t\tcontainer_of(cb, struct nfs4_layout_stateid, ls_recall);\n\tstruct nfs4_cb_compound_hdr hdr = {\n\t\t.ident = 0,\n\t\t.minorversion = cb->cb_clp->cl_minorversion,\n\t};\n\n\tencode_cb_compound4args(xdr, &hdr);\n\tencode_cb_sequence4args(xdr, cb, &hdr);\n\tencode_cb_layout4args(xdr, ls, &hdr);\n\tencode_cb_nops(&hdr);\n}\n\nstatic int nfs4_xdr_dec_cb_layout(struct rpc_rqst *rqstp,\n\t\t\t\t  struct xdr_stream *xdr,\n\t\t\t\t  void *data)\n{\n\tstruct nfsd4_callback *cb = data;\n\tstruct nfs4_cb_compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_cb_compound4res(xdr, &hdr);\n\tif (unlikely(status))\n\t\treturn status;\n\n\tstatus = decode_cb_sequence4res(xdr, cb);\n\tif (unlikely(status || cb->cb_seq_status))\n\t\treturn status;\n\n\treturn decode_cb_op_status(xdr, OP_CB_LAYOUTRECALL, &cb->cb_status);\n}\n#endif  \n\nstatic void encode_stateowner(struct xdr_stream *xdr, struct nfs4_stateowner *so)\n{\n\t__be32\t*p;\n\n\tp = xdr_reserve_space(xdr, 8 + 4 + so->so_owner.len);\n\tp = xdr_encode_opaque_fixed(p, &so->so_client->cl_clientid, 8);\n\txdr_encode_opaque(p, so->so_owner.data, so->so_owner.len);\n}\n\nstatic void nfs4_xdr_enc_cb_notify_lock(struct rpc_rqst *req,\n\t\t\t\t\tstruct xdr_stream *xdr,\n\t\t\t\t\tconst void *data)\n{\n\tconst struct nfsd4_callback *cb = data;\n\tconst struct nfsd4_blocked_lock *nbl =\n\t\tcontainer_of(cb, struct nfsd4_blocked_lock, nbl_cb);\n\tstruct nfs4_lockowner *lo = (struct nfs4_lockowner *)nbl->nbl_lock.fl_owner;\n\tstruct nfs4_cb_compound_hdr hdr = {\n\t\t.ident = 0,\n\t\t.minorversion = cb->cb_clp->cl_minorversion,\n\t};\n\n\t__be32 *p;\n\n\tBUG_ON(hdr.minorversion == 0);\n\n\tencode_cb_compound4args(xdr, &hdr);\n\tencode_cb_sequence4args(xdr, cb, &hdr);\n\n\tp = xdr_reserve_space(xdr, 4);\n\t*p = cpu_to_be32(OP_CB_NOTIFY_LOCK);\n\tencode_nfs_fh4(xdr, &nbl->nbl_fh);\n\tencode_stateowner(xdr, &lo->lo_owner);\n\thdr.nops++;\n\n\tencode_cb_nops(&hdr);\n}\n\nstatic int nfs4_xdr_dec_cb_notify_lock(struct rpc_rqst *rqstp,\n\t\t\t\t\tstruct xdr_stream *xdr,\n\t\t\t\t\tvoid *data)\n{\n\tstruct nfsd4_callback *cb = data;\n\tstruct nfs4_cb_compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_cb_compound4res(xdr, &hdr);\n\tif (unlikely(status))\n\t\treturn status;\n\n\tstatus = decode_cb_sequence4res(xdr, cb);\n\tif (unlikely(status || cb->cb_seq_status))\n\t\treturn status;\n\n\treturn decode_cb_op_status(xdr, OP_CB_NOTIFY_LOCK, &cb->cb_status);\n}\n\n \nstatic void encode_offload_info4(struct xdr_stream *xdr,\n\t\t\t\t const struct nfsd4_cb_offload *cbo)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4);\n\t*p = cbo->co_nfserr;\n\tswitch (cbo->co_nfserr) {\n\tcase nfs_ok:\n\t\tp = xdr_reserve_space(xdr, 4 + 8 + 4 + NFS4_VERIFIER_SIZE);\n\t\tp = xdr_encode_empty_array(p);\n\t\tp = xdr_encode_hyper(p, cbo->co_res.wr_bytes_written);\n\t\t*p++ = cpu_to_be32(cbo->co_res.wr_stable_how);\n\t\tp = xdr_encode_opaque_fixed(p, cbo->co_res.wr_verifier.data,\n\t\t\t\t\t    NFS4_VERIFIER_SIZE);\n\t\tbreak;\n\tdefault:\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\t \n\t\tp = xdr_encode_hyper(p, 0);\n\t}\n}\n\nstatic void encode_cb_offload4args(struct xdr_stream *xdr,\n\t\t\t\t   const struct nfsd4_cb_offload *cbo,\n\t\t\t\t   struct nfs4_cb_compound_hdr *hdr)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4);\n\t*p = cpu_to_be32(OP_CB_OFFLOAD);\n\tencode_nfs_fh4(xdr, &cbo->co_fh);\n\tencode_stateid4(xdr, &cbo->co_res.cb_stateid);\n\tencode_offload_info4(xdr, cbo);\n\n\thdr->nops++;\n}\n\nstatic void nfs4_xdr_enc_cb_offload(struct rpc_rqst *req,\n\t\t\t\t    struct xdr_stream *xdr,\n\t\t\t\t    const void *data)\n{\n\tconst struct nfsd4_callback *cb = data;\n\tconst struct nfsd4_cb_offload *cbo =\n\t\tcontainer_of(cb, struct nfsd4_cb_offload, co_cb);\n\tstruct nfs4_cb_compound_hdr hdr = {\n\t\t.ident = 0,\n\t\t.minorversion = cb->cb_clp->cl_minorversion,\n\t};\n\n\tencode_cb_compound4args(xdr, &hdr);\n\tencode_cb_sequence4args(xdr, cb, &hdr);\n\tencode_cb_offload4args(xdr, cbo, &hdr);\n\tencode_cb_nops(&hdr);\n}\n\nstatic int nfs4_xdr_dec_cb_offload(struct rpc_rqst *rqstp,\n\t\t\t\t   struct xdr_stream *xdr,\n\t\t\t\t   void *data)\n{\n\tstruct nfsd4_callback *cb = data;\n\tstruct nfs4_cb_compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_cb_compound4res(xdr, &hdr);\n\tif (unlikely(status))\n\t\treturn status;\n\n\tstatus = decode_cb_sequence4res(xdr, cb);\n\tif (unlikely(status || cb->cb_seq_status))\n\t\treturn status;\n\n\treturn decode_cb_op_status(xdr, OP_CB_OFFLOAD, &cb->cb_status);\n}\n \n#define PROC(proc, call, argtype, restype)\t\t\t\t\\\n[NFSPROC4_CLNT_##proc] = {\t\t\t\t\t\t\\\n\t.p_proc    = NFSPROC4_CB_##call,\t\t\t\t\\\n\t.p_encode  = nfs4_xdr_enc_##argtype,\t\t\\\n\t.p_decode  = nfs4_xdr_dec_##restype,\t\t\t\t\\\n\t.p_arglen  = NFS4_enc_##argtype##_sz,\t\t\t\t\\\n\t.p_replen  = NFS4_dec_##restype##_sz,\t\t\t\t\\\n\t.p_statidx = NFSPROC4_CB_##call,\t\t\t\t\\\n\t.p_name    = #proc,\t\t\t\t\t\t\\\n}\n\nstatic const struct rpc_procinfo nfs4_cb_procedures[] = {\n\tPROC(CB_NULL,\tNULL,\t\tcb_null,\tcb_null),\n\tPROC(CB_RECALL,\tCOMPOUND,\tcb_recall,\tcb_recall),\n#ifdef CONFIG_NFSD_PNFS\n\tPROC(CB_LAYOUT,\tCOMPOUND,\tcb_layout,\tcb_layout),\n#endif\n\tPROC(CB_NOTIFY_LOCK,\tCOMPOUND,\tcb_notify_lock,\tcb_notify_lock),\n\tPROC(CB_OFFLOAD,\tCOMPOUND,\tcb_offload,\tcb_offload),\n\tPROC(CB_RECALL_ANY,\tCOMPOUND,\tcb_recall_any,\tcb_recall_any),\n};\n\nstatic unsigned int nfs4_cb_counts[ARRAY_SIZE(nfs4_cb_procedures)];\nstatic const struct rpc_version nfs_cb_version4 = {\n \n\t.number\t\t\t= 1,\n\t.nrprocs\t\t= ARRAY_SIZE(nfs4_cb_procedures),\n\t.procs\t\t\t= nfs4_cb_procedures,\n\t.counts\t\t\t= nfs4_cb_counts,\n};\n\nstatic const struct rpc_version *nfs_cb_version[2] = {\n\t[1] = &nfs_cb_version4,\n};\n\nstatic const struct rpc_program cb_program;\n\nstatic struct rpc_stat cb_stats = {\n\t.program\t\t= &cb_program\n};\n\n#define NFS4_CALLBACK 0x40000000\nstatic const struct rpc_program cb_program = {\n\t.name\t\t\t= \"nfs4_cb\",\n\t.number\t\t\t= NFS4_CALLBACK,\n\t.nrvers\t\t\t= ARRAY_SIZE(nfs_cb_version),\n\t.version\t\t= nfs_cb_version,\n\t.stats\t\t\t= &cb_stats,\n\t.pipe_dir_name\t\t= \"nfsd4_cb\",\n};\n\nstatic int max_cb_time(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\t \n\tif (WARN_ON_ONCE(nn->nfsd4_lease > 3600))\n\t\treturn 360 * HZ;\n\n\treturn max(((u32)nn->nfsd4_lease)/10, 1u) * HZ;\n}\n\nstatic struct workqueue_struct *callback_wq;\n\nstatic bool nfsd4_queue_cb(struct nfsd4_callback *cb)\n{\n\treturn queue_work(callback_wq, &cb->cb_work);\n}\n\nstatic void nfsd41_cb_inflight_begin(struct nfs4_client *clp)\n{\n\tatomic_inc(&clp->cl_cb_inflight);\n}\n\nstatic void nfsd41_cb_inflight_end(struct nfs4_client *clp)\n{\n\n\tif (atomic_dec_and_test(&clp->cl_cb_inflight))\n\t\twake_up_var(&clp->cl_cb_inflight);\n}\n\nstatic void nfsd41_cb_inflight_wait_complete(struct nfs4_client *clp)\n{\n\twait_var_event(&clp->cl_cb_inflight,\n\t\t\t!atomic_read(&clp->cl_cb_inflight));\n}\n\nstatic const struct cred *get_backchannel_cred(struct nfs4_client *clp, struct rpc_clnt *client, struct nfsd4_session *ses)\n{\n\tif (clp->cl_minorversion == 0) {\n\t\tclient->cl_principal = clp->cl_cred.cr_targ_princ ?\n\t\t\tclp->cl_cred.cr_targ_princ : \"nfs\";\n\n\t\treturn get_cred(rpc_machine_cred());\n\t} else {\n\t\tstruct cred *kcred;\n\n\t\tkcred = prepare_kernel_cred(&init_task);\n\t\tif (!kcred)\n\t\t\treturn NULL;\n\n\t\tkcred->fsuid = ses->se_cb_sec.uid;\n\t\tkcred->fsgid = ses->se_cb_sec.gid;\n\t\treturn kcred;\n\t}\n}\n\nstatic int setup_callback_client(struct nfs4_client *clp, struct nfs4_cb_conn *conn, struct nfsd4_session *ses)\n{\n\tint maxtime = max_cb_time(clp->net);\n\tstruct rpc_timeout\ttimeparms = {\n\t\t.to_initval\t= maxtime,\n\t\t.to_retries\t= 0,\n\t\t.to_maxval\t= maxtime,\n\t};\n\tstruct rpc_create_args args = {\n\t\t.net\t\t= clp->net,\n\t\t.address\t= (struct sockaddr *) &conn->cb_addr,\n\t\t.addrsize\t= conn->cb_addrlen,\n\t\t.saddress\t= (struct sockaddr *) &conn->cb_saddr,\n\t\t.timeout\t= &timeparms,\n\t\t.program\t= &cb_program,\n\t\t.version\t= 1,\n\t\t.flags\t\t= (RPC_CLNT_CREATE_NOPING | RPC_CLNT_CREATE_QUIET),\n\t\t.cred\t\t= current_cred(),\n\t};\n\tstruct rpc_clnt *client;\n\tconst struct cred *cred;\n\n\tif (clp->cl_minorversion == 0) {\n\t\tif (!clp->cl_cred.cr_principal &&\n\t\t    (clp->cl_cred.cr_flavor >= RPC_AUTH_GSS_KRB5)) {\n\t\t\ttrace_nfsd_cb_setup_err(clp, -EINVAL);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\targs.client_name = clp->cl_cred.cr_principal;\n\t\targs.prognumber\t= conn->cb_prog;\n\t\targs.protocol = XPRT_TRANSPORT_TCP;\n\t\targs.authflavor = clp->cl_cred.cr_flavor;\n\t\tclp->cl_cb_ident = conn->cb_ident;\n\t} else {\n\t\tif (!conn->cb_xprt)\n\t\t\treturn -EINVAL;\n\t\tclp->cl_cb_session = ses;\n\t\targs.bc_xprt = conn->cb_xprt;\n\t\targs.prognumber = clp->cl_cb_session->se_cb_prog;\n\t\targs.protocol = conn->cb_xprt->xpt_class->xcl_ident |\n\t\t\t\tXPRT_TRANSPORT_BC;\n\t\targs.authflavor = ses->se_cb_sec.flavor;\n\t}\n\t \n\tclient = rpc_create(&args);\n\tif (IS_ERR(client)) {\n\t\ttrace_nfsd_cb_setup_err(clp, PTR_ERR(client));\n\t\treturn PTR_ERR(client);\n\t}\n\tcred = get_backchannel_cred(clp, client, ses);\n\tif (!cred) {\n\t\ttrace_nfsd_cb_setup_err(clp, -ENOMEM);\n\t\trpc_shutdown_client(client);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (clp->cl_minorversion != 0)\n\t\tclp->cl_cb_conn.cb_xprt = conn->cb_xprt;\n\tclp->cl_cb_client = client;\n\tclp->cl_cb_cred = cred;\n\trcu_read_lock();\n\ttrace_nfsd_cb_setup(clp, rpc_peeraddr2str(client, RPC_DISPLAY_NETID),\n\t\t\t    args.authflavor);\n\trcu_read_unlock();\n\treturn 0;\n}\n\nstatic void nfsd4_mark_cb_state(struct nfs4_client *clp, int newstate)\n{\n\tif (clp->cl_cb_state != newstate) {\n\t\tclp->cl_cb_state = newstate;\n\t\ttrace_nfsd_cb_state(clp);\n\t}\n}\n\nstatic void nfsd4_mark_cb_down(struct nfs4_client *clp, int reason)\n{\n\tif (test_bit(NFSD4_CLIENT_CB_UPDATE, &clp->cl_flags))\n\t\treturn;\n\tnfsd4_mark_cb_state(clp, NFSD4_CB_DOWN);\n}\n\nstatic void nfsd4_mark_cb_fault(struct nfs4_client *clp, int reason)\n{\n\tif (test_bit(NFSD4_CLIENT_CB_UPDATE, &clp->cl_flags))\n\t\treturn;\n\tnfsd4_mark_cb_state(clp, NFSD4_CB_FAULT);\n}\n\nstatic void nfsd4_cb_probe_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_client *clp = container_of(calldata, struct nfs4_client, cl_cb_null);\n\n\tif (task->tk_status)\n\t\tnfsd4_mark_cb_down(clp, task->tk_status);\n\telse\n\t\tnfsd4_mark_cb_state(clp, NFSD4_CB_UP);\n}\n\nstatic void nfsd4_cb_probe_release(void *calldata)\n{\n\tstruct nfs4_client *clp = container_of(calldata, struct nfs4_client, cl_cb_null);\n\n\tnfsd41_cb_inflight_end(clp);\n\n}\n\nstatic const struct rpc_call_ops nfsd4_cb_probe_ops = {\n\t \n\t.rpc_call_done = nfsd4_cb_probe_done,\n\t.rpc_release = nfsd4_cb_probe_release,\n};\n\n \nvoid nfsd4_probe_callback(struct nfs4_client *clp)\n{\n\ttrace_nfsd_cb_probe(clp);\n\tnfsd4_mark_cb_state(clp, NFSD4_CB_UNKNOWN);\n\tset_bit(NFSD4_CLIENT_CB_UPDATE, &clp->cl_flags);\n\tnfsd4_run_cb(&clp->cl_cb_null);\n}\n\nvoid nfsd4_probe_callback_sync(struct nfs4_client *clp)\n{\n\tnfsd4_probe_callback(clp);\n\tflush_workqueue(callback_wq);\n}\n\nvoid nfsd4_change_callback(struct nfs4_client *clp, struct nfs4_cb_conn *conn)\n{\n\tnfsd4_mark_cb_state(clp, NFSD4_CB_UNKNOWN);\n\tspin_lock(&clp->cl_lock);\n\tmemcpy(&clp->cl_cb_conn, conn, sizeof(struct nfs4_cb_conn));\n\tspin_unlock(&clp->cl_lock);\n}\n\n \nstatic bool nfsd41_cb_get_slot(struct nfsd4_callback *cb, struct rpc_task *task)\n{\n\tstruct nfs4_client *clp = cb->cb_clp;\n\n\tif (!cb->cb_holds_slot &&\n\t    test_and_set_bit(0, &clp->cl_cb_slot_busy) != 0) {\n\t\trpc_sleep_on(&clp->cl_cb_waitq, task, NULL);\n\t\t \n\t\tif (test_and_set_bit(0, &clp->cl_cb_slot_busy) != 0) {\n\t\t\tdprintk(\"%s slot is busy\\n\", __func__);\n\t\t\treturn false;\n\t\t}\n\t\trpc_wake_up_queued_task(&clp->cl_cb_waitq, task);\n\t}\n\tcb->cb_holds_slot = true;\n\treturn true;\n}\n\nstatic void nfsd41_cb_release_slot(struct nfsd4_callback *cb)\n{\n\tstruct nfs4_client *clp = cb->cb_clp;\n\n\tif (cb->cb_holds_slot) {\n\t\tcb->cb_holds_slot = false;\n\t\tclear_bit(0, &clp->cl_cb_slot_busy);\n\t\trpc_wake_up_next(&clp->cl_cb_waitq);\n\t}\n}\n\nstatic void nfsd41_destroy_cb(struct nfsd4_callback *cb)\n{\n\tstruct nfs4_client *clp = cb->cb_clp;\n\n\tnfsd41_cb_release_slot(cb);\n\tif (cb->cb_ops && cb->cb_ops->release)\n\t\tcb->cb_ops->release(cb);\n\tnfsd41_cb_inflight_end(clp);\n}\n\n \nstatic void nfsd4_cb_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfsd4_callback *cb = calldata;\n\tstruct nfs4_client *clp = cb->cb_clp;\n\tu32 minorversion = clp->cl_minorversion;\n\n\t \n\tcb->cb_seq_status = 1;\n\tcb->cb_status = 0;\n\tif (minorversion && !nfsd41_cb_get_slot(cb, task))\n\t\treturn;\n\trpc_call_start(task);\n}\n\nstatic bool nfsd4_cb_sequence_done(struct rpc_task *task, struct nfsd4_callback *cb)\n{\n\tstruct nfs4_client *clp = cb->cb_clp;\n\tstruct nfsd4_session *session = clp->cl_cb_session;\n\tbool ret = true;\n\n\tif (!clp->cl_minorversion) {\n\t\t \n\t\tif (RPC_SIGNALLED(task))\n\t\t\tgoto need_restart;\n\n\t\treturn true;\n\t}\n\n\tif (!cb->cb_holds_slot)\n\t\tgoto need_restart;\n\n\tswitch (cb->cb_seq_status) {\n\tcase 0:\n\t\t \n\t\t++session->se_cb_seq_nr;\n\t\tbreak;\n\tcase -ESERVERFAULT:\n\t\t++session->se_cb_seq_nr;\n\t\tfallthrough;\n\tcase 1:\n\tcase -NFS4ERR_BADSESSION:\n\t\tnfsd4_mark_cb_fault(cb->cb_clp, cb->cb_seq_status);\n\t\tret = false;\n\t\tbreak;\n\tcase -NFS4ERR_DELAY:\n\t\tif (!rpc_restart_call(task))\n\t\t\tgoto out;\n\n\t\trpc_delay(task, 2 * HZ);\n\t\treturn false;\n\tcase -NFS4ERR_BADSLOT:\n\t\tgoto retry_nowait;\n\tcase -NFS4ERR_SEQ_MISORDERED:\n\t\tif (session->se_cb_seq_nr != 1) {\n\t\t\tsession->se_cb_seq_nr = 1;\n\t\t\tgoto retry_nowait;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tnfsd4_mark_cb_fault(cb->cb_clp, cb->cb_seq_status);\n\t\tdprintk(\"%s: unprocessed error %d\\n\", __func__,\n\t\t\tcb->cb_seq_status);\n\t}\n\n\tnfsd41_cb_release_slot(cb);\n\tdprintk(\"%s: freed slot, new seqid=%d\\n\", __func__,\n\t\tclp->cl_cb_session->se_cb_seq_nr);\n\n\tif (RPC_SIGNALLED(task))\n\t\tgoto need_restart;\nout:\n\treturn ret;\nretry_nowait:\n\tif (rpc_restart_call_prepare(task))\n\t\tret = false;\n\tgoto out;\nneed_restart:\n\tif (!test_bit(NFSD4_CLIENT_CB_KILL, &clp->cl_flags)) {\n\t\ttask->tk_status = 0;\n\t\tcb->cb_need_restart = true;\n\t}\n\treturn false;\n}\n\nstatic void nfsd4_cb_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfsd4_callback *cb = calldata;\n\tstruct nfs4_client *clp = cb->cb_clp;\n\n\tif (!nfsd4_cb_sequence_done(task, cb))\n\t\treturn;\n\n\tif (cb->cb_status) {\n\t\tWARN_ON_ONCE(task->tk_status);\n\t\ttask->tk_status = cb->cb_status;\n\t}\n\n\tswitch (cb->cb_ops->done(cb, task)) {\n\tcase 0:\n\t\ttask->tk_status = 0;\n\t\trpc_restart_call_prepare(task);\n\t\treturn;\n\tcase 1:\n\t\tswitch (task->tk_status) {\n\t\tcase -EIO:\n\t\tcase -ETIMEDOUT:\n\t\tcase -EACCES:\n\t\t\tnfsd4_mark_cb_down(clp, task->tk_status);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}\n\nstatic void nfsd4_cb_release(void *calldata)\n{\n\tstruct nfsd4_callback *cb = calldata;\n\n\tif (cb->cb_need_restart)\n\t\tnfsd4_queue_cb(cb);\n\telse\n\t\tnfsd41_destroy_cb(cb);\n\n}\n\nstatic const struct rpc_call_ops nfsd4_cb_ops = {\n\t.rpc_call_prepare = nfsd4_cb_prepare,\n\t.rpc_call_done = nfsd4_cb_done,\n\t.rpc_release = nfsd4_cb_release,\n};\n\nint nfsd4_create_callback_queue(void)\n{\n\tcallback_wq = alloc_ordered_workqueue(\"nfsd4_callbacks\", 0);\n\tif (!callback_wq)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nvoid nfsd4_destroy_callback_queue(void)\n{\n\tdestroy_workqueue(callback_wq);\n}\n\n \nvoid nfsd4_shutdown_callback(struct nfs4_client *clp)\n{\n\tif (clp->cl_cb_state != NFSD4_CB_UNKNOWN)\n\t\ttrace_nfsd_cb_shutdown(clp);\n\n\tset_bit(NFSD4_CLIENT_CB_KILL, &clp->cl_flags);\n\t \n\tnfsd4_run_cb(&clp->cl_cb_null);\n\tflush_workqueue(callback_wq);\n\tnfsd41_cb_inflight_wait_complete(clp);\n}\n\n \nstatic struct nfsd4_conn * __nfsd4_find_backchannel(struct nfs4_client *clp)\n{\n\tstruct nfsd4_session *s;\n\tstruct nfsd4_conn *c;\n\n\tlist_for_each_entry(s, &clp->cl_sessions, se_perclnt) {\n\t\tlist_for_each_entry(c, &s->se_conns, cn_persession) {\n\t\t\tif (c->cn_flags & NFS4_CDFC4_BACK)\n\t\t\t\treturn c;\n\t\t}\n\t}\n\treturn NULL;\n}\n\n \nstatic void nfsd4_process_cb_update(struct nfsd4_callback *cb)\n{\n\tstruct nfs4_cb_conn conn;\n\tstruct nfs4_client *clp = cb->cb_clp;\n\tstruct nfsd4_session *ses = NULL;\n\tstruct nfsd4_conn *c;\n\tint err;\n\n\t \n\tif (clp->cl_cb_client) {\n\t\trpc_shutdown_client(clp->cl_cb_client);\n\t\tclp->cl_cb_client = NULL;\n\t\tput_cred(clp->cl_cb_cred);\n\t\tclp->cl_cb_cred = NULL;\n\t}\n\tif (clp->cl_cb_conn.cb_xprt) {\n\t\tsvc_xprt_put(clp->cl_cb_conn.cb_xprt);\n\t\tclp->cl_cb_conn.cb_xprt = NULL;\n\t}\n\tif (test_bit(NFSD4_CLIENT_CB_KILL, &clp->cl_flags))\n\t\treturn;\n\tspin_lock(&clp->cl_lock);\n\t \n\tBUG_ON(!(clp->cl_flags & NFSD4_CLIENT_CB_FLAG_MASK));\n\tclear_bit(NFSD4_CLIENT_CB_UPDATE, &clp->cl_flags);\n\tmemcpy(&conn, &cb->cb_clp->cl_cb_conn, sizeof(struct nfs4_cb_conn));\n\tc = __nfsd4_find_backchannel(clp);\n\tif (c) {\n\t\tsvc_xprt_get(c->cn_xprt);\n\t\tconn.cb_xprt = c->cn_xprt;\n\t\tses = c->cn_session;\n\t}\n\tspin_unlock(&clp->cl_lock);\n\n\terr = setup_callback_client(clp, &conn, ses);\n\tif (err) {\n\t\tnfsd4_mark_cb_down(clp, err);\n\t\tif (c)\n\t\t\tsvc_xprt_put(c->cn_xprt);\n\t\treturn;\n\t}\n}\n\nstatic void\nnfsd4_run_cb_work(struct work_struct *work)\n{\n\tstruct nfsd4_callback *cb =\n\t\tcontainer_of(work, struct nfsd4_callback, cb_work);\n\tstruct nfs4_client *clp = cb->cb_clp;\n\tstruct rpc_clnt *clnt;\n\tint flags;\n\n\tif (cb->cb_need_restart) {\n\t\tcb->cb_need_restart = false;\n\t} else {\n\t\tif (cb->cb_ops && cb->cb_ops->prepare)\n\t\t\tcb->cb_ops->prepare(cb);\n\t}\n\n\tif (clp->cl_flags & NFSD4_CLIENT_CB_FLAG_MASK)\n\t\tnfsd4_process_cb_update(cb);\n\n\tclnt = clp->cl_cb_client;\n\tif (!clnt) {\n\t\t \n\t\tnfsd41_destroy_cb(cb);\n\t\treturn;\n\t}\n\n\t \n\tif (!cb->cb_ops && clp->cl_minorversion) {\n\t\tnfsd4_mark_cb_state(clp, NFSD4_CB_UP);\n\t\tnfsd41_destroy_cb(cb);\n\t\treturn;\n\t}\n\n\tcb->cb_msg.rpc_cred = clp->cl_cb_cred;\n\tflags = clp->cl_minorversion ? RPC_TASK_NOCONNECT : RPC_TASK_SOFTCONN;\n\trpc_call_async(clnt, &cb->cb_msg, RPC_TASK_SOFT | flags,\n\t\t\tcb->cb_ops ? &nfsd4_cb_ops : &nfsd4_cb_probe_ops, cb);\n}\n\nvoid nfsd4_init_cb(struct nfsd4_callback *cb, struct nfs4_client *clp,\n\t\tconst struct nfsd4_callback_ops *ops, enum nfsd4_cb_op op)\n{\n\tcb->cb_clp = clp;\n\tcb->cb_msg.rpc_proc = &nfs4_cb_procedures[op];\n\tcb->cb_msg.rpc_argp = cb;\n\tcb->cb_msg.rpc_resp = cb;\n\tcb->cb_ops = ops;\n\tINIT_WORK(&cb->cb_work, nfsd4_run_cb_work);\n\tcb->cb_seq_status = 1;\n\tcb->cb_status = 0;\n\tcb->cb_need_restart = false;\n\tcb->cb_holds_slot = false;\n}\n\n \nbool nfsd4_run_cb(struct nfsd4_callback *cb)\n{\n\tstruct nfs4_client *clp = cb->cb_clp;\n\tbool queued;\n\n\tnfsd41_cb_inflight_begin(clp);\n\tqueued = nfsd4_queue_cb(cb);\n\tif (!queued)\n\t\tnfsd41_cb_inflight_end(clp);\n\treturn queued;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}