{
  "module_name": "nfs4xdr.c",
  "hash_id": "ad16d61040b96312cf076f3a49900b7e220b240eb2c5e7fe5100e5aae06dc20d",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfsd/nfs4xdr.c",
  "human_readable_source": " \n\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/statfs.h>\n#include <linux/utsname.h>\n#include <linux/pagemap.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/xattr.h>\n#include <linux/vmalloc.h>\n\n#include <uapi/linux/xattr.h>\n\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"xdr4.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"filecache.h\"\n\n#include \"trace.h\"\n\n#ifdef CONFIG_NFSD_V4_SECURITY_LABEL\n#include <linux/security.h>\n#endif\n\n\n#define NFSDDBG_FACILITY\t\tNFSDDBG_XDR\n\nconst u32 nfsd_suppattrs[3][3] = {\n\t{NFSD4_SUPPORTED_ATTRS_WORD0,\n\t NFSD4_SUPPORTED_ATTRS_WORD1,\n\t NFSD4_SUPPORTED_ATTRS_WORD2},\n\n\t{NFSD4_1_SUPPORTED_ATTRS_WORD0,\n\t NFSD4_1_SUPPORTED_ATTRS_WORD1,\n\t NFSD4_1_SUPPORTED_ATTRS_WORD2},\n\n\t{NFSD4_1_SUPPORTED_ATTRS_WORD0,\n\t NFSD4_1_SUPPORTED_ATTRS_WORD1,\n\t NFSD4_2_SUPPORTED_ATTRS_WORD2},\n};\n\n \n#define NFS4_REFERRAL_FSID_MAJOR\t0x8000000ULL\n#define NFS4_REFERRAL_FSID_MINOR\t0x8000000ULL\n\nstatic __be32\ncheck_filename(char *str, int len)\n{\n\tint i;\n\n\tif (len == 0)\n\t\treturn nfserr_inval;\n\tif (len > NFS4_MAXNAMLEN)\n\t\treturn nfserr_nametoolong;\n\tif (isdotent(str, len))\n\t\treturn nfserr_badname;\n\tfor (i = 0; i < len; i++)\n\t\tif (str[i] == '/')\n\t\t\treturn nfserr_badname;\n\treturn 0;\n}\n\nstatic int zero_clientid(clientid_t *clid)\n{\n\treturn (clid->cl_boot == 0) && (clid->cl_id == 0);\n}\n\n \nstatic void *\nsvcxdr_tmpalloc(struct nfsd4_compoundargs *argp, u32 len)\n{\n\tstruct svcxdr_tmpbuf *tb;\n\n\ttb = kmalloc(sizeof(*tb) + len, GFP_KERNEL);\n\tif (!tb)\n\t\treturn NULL;\n\ttb->next = argp->to_free;\n\targp->to_free = tb;\n\treturn tb->buf;\n}\n\n \nstatic char *\nsvcxdr_dupstr(struct nfsd4_compoundargs *argp, void *buf, u32 len)\n{\n\tchar *p = svcxdr_tmpalloc(argp, len + 1);\n\n\tif (!p)\n\t\treturn NULL;\n\tmemcpy(p, buf, len);\n\tp[len] = '\\0';\n\treturn p;\n}\n\nstatic void *\nsvcxdr_savemem(struct nfsd4_compoundargs *argp, __be32 *p, u32 len)\n{\n\t__be32 *tmp;\n\n\t \n\tif (p != argp->xdr->scratch.iov_base)\n\t\treturn p;\n\n\ttmp = svcxdr_tmpalloc(argp, len);\n\tif (!tmp)\n\t\treturn NULL;\n\tmemcpy(tmp, p, len);\n\treturn tmp;\n}\n\n \n\n \nstatic __be32\nnfsd4_decode_ignored_string(struct nfsd4_compoundargs *argp, u32 maxlen)\n{\n\tu32 len;\n\n\tif (xdr_stream_decode_u32(argp->xdr, &len) < 0)\n\t\treturn nfserr_bad_xdr;\n\tif (maxlen && len > maxlen)\n\t\treturn nfserr_bad_xdr;\n\tif (!xdr_inline_decode(argp->xdr, len))\n\t\treturn nfserr_bad_xdr;\n\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_decode_opaque(struct nfsd4_compoundargs *argp, struct xdr_netobj *o)\n{\n\t__be32 *p;\n\tu32 len;\n\n\tif (xdr_stream_decode_u32(argp->xdr, &len) < 0)\n\t\treturn nfserr_bad_xdr;\n\tif (len == 0 || len > NFS4_OPAQUE_LIMIT)\n\t\treturn nfserr_bad_xdr;\n\tp = xdr_inline_decode(argp->xdr, len);\n\tif (!p)\n\t\treturn nfserr_bad_xdr;\n\to->data = svcxdr_savemem(argp, p, len);\n\tif (!o->data)\n\t\treturn nfserr_jukebox;\n\to->len = len;\n\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_decode_component4(struct nfsd4_compoundargs *argp, char **namp, u32 *lenp)\n{\n\t__be32 *p, status;\n\n\tif (xdr_stream_decode_u32(argp->xdr, lenp) < 0)\n\t\treturn nfserr_bad_xdr;\n\tp = xdr_inline_decode(argp->xdr, *lenp);\n\tif (!p)\n\t\treturn nfserr_bad_xdr;\n\tstatus = check_filename((char *)p, *lenp);\n\tif (status)\n\t\treturn status;\n\t*namp = svcxdr_savemem(argp, p, *lenp);\n\tif (!*namp)\n\t\treturn nfserr_jukebox;\n\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_decode_nfstime4(struct nfsd4_compoundargs *argp, struct timespec64 *tv)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(argp->xdr, XDR_UNIT * 3);\n\tif (!p)\n\t\treturn nfserr_bad_xdr;\n\tp = xdr_decode_hyper(p, &tv->tv_sec);\n\ttv->tv_nsec = be32_to_cpup(p++);\n\tif (tv->tv_nsec >= (u32)1000000000)\n\t\treturn nfserr_inval;\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_decode_verifier4(struct nfsd4_compoundargs *argp, nfs4_verifier *verf)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(argp->xdr, NFS4_VERIFIER_SIZE);\n\tif (!p)\n\t\treturn nfserr_bad_xdr;\n\tmemcpy(verf->data, p, sizeof(verf->data));\n\treturn nfs_ok;\n}\n\n \nstatic __be32\nnfsd4_decode_bitmap4(struct nfsd4_compoundargs *argp, u32 *bmval, u32 bmlen)\n{\n\tssize_t status;\n\n\tstatus = xdr_stream_decode_uint32_array(argp->xdr, bmval, bmlen);\n\treturn status == -EBADMSG ? nfserr_bad_xdr : nfs_ok;\n}\n\nstatic __be32\nnfsd4_decode_nfsace4(struct nfsd4_compoundargs *argp, struct nfs4_ace *ace)\n{\n\t__be32 *p, status;\n\tu32 length;\n\n\tif (xdr_stream_decode_u32(argp->xdr, &ace->type) < 0)\n\t\treturn nfserr_bad_xdr;\n\tif (xdr_stream_decode_u32(argp->xdr, &ace->flag) < 0)\n\t\treturn nfserr_bad_xdr;\n\tif (xdr_stream_decode_u32(argp->xdr, &ace->access_mask) < 0)\n\t\treturn nfserr_bad_xdr;\n\n\tif (xdr_stream_decode_u32(argp->xdr, &length) < 0)\n\t\treturn nfserr_bad_xdr;\n\tp = xdr_inline_decode(argp->xdr, length);\n\tif (!p)\n\t\treturn nfserr_bad_xdr;\n\tace->whotype = nfs4_acl_get_whotype((char *)p, length);\n\tif (ace->whotype != NFS4_ACL_WHO_NAMED)\n\t\tstatus = nfs_ok;\n\telse if (ace->flag & NFS4_ACE_IDENTIFIER_GROUP)\n\t\tstatus = nfsd_map_name_to_gid(argp->rqstp,\n\t\t\t\t(char *)p, length, &ace->who_gid);\n\telse\n\t\tstatus = nfsd_map_name_to_uid(argp->rqstp,\n\t\t\t\t(char *)p, length, &ace->who_uid);\n\n\treturn status;\n}\n\n \nstatic noinline __be32\nnfsd4_decode_acl(struct nfsd4_compoundargs *argp, struct nfs4_acl **acl)\n{\n\tstruct nfs4_ace *ace;\n\t__be32 status;\n\tu32 count;\n\n\tif (xdr_stream_decode_u32(argp->xdr, &count) < 0)\n\t\treturn nfserr_bad_xdr;\n\n\tif (count > xdr_stream_remaining(argp->xdr) / 20)\n\t\t \n\t\treturn nfserr_fbig;\n\n\t*acl = svcxdr_tmpalloc(argp, nfs4_acl_bytes(count));\n\tif (*acl == NULL)\n\t\treturn nfserr_jukebox;\n\n\t(*acl)->naces = count;\n\tfor (ace = (*acl)->aces; ace < (*acl)->aces + count; ace++) {\n\t\tstatus = nfsd4_decode_nfsace4(argp, ace);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\n\treturn nfs_ok;\n}\n\nstatic noinline __be32\nnfsd4_decode_security_label(struct nfsd4_compoundargs *argp,\n\t\t\t    struct xdr_netobj *label)\n{\n\tu32 lfs, pi, length;\n\t__be32 *p;\n\n\tif (xdr_stream_decode_u32(argp->xdr, &lfs) < 0)\n\t\treturn nfserr_bad_xdr;\n\tif (xdr_stream_decode_u32(argp->xdr, &pi) < 0)\n\t\treturn nfserr_bad_xdr;\n\n\tif (xdr_stream_decode_u32(argp->xdr, &length) < 0)\n\t\treturn nfserr_bad_xdr;\n\tif (length > NFS4_MAXLABELLEN)\n\t\treturn nfserr_badlabel;\n\tp = xdr_inline_decode(argp->xdr, length);\n\tif (!p)\n\t\treturn nfserr_bad_xdr;\n\tlabel->len = length;\n\tlabel->data = svcxdr_dupstr(argp, p, length);\n\tif (!label->data)\n\t\treturn nfserr_jukebox;\n\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_decode_fattr4(struct nfsd4_compoundargs *argp, u32 *bmval, u32 bmlen,\n\t\t    struct iattr *iattr, struct nfs4_acl **acl,\n\t\t    struct xdr_netobj *label, int *umask)\n{\n\tunsigned int starting_pos;\n\tu32 attrlist4_count;\n\t__be32 *p, status;\n\n\tiattr->ia_valid = 0;\n\tstatus = nfsd4_decode_bitmap4(argp, bmval, bmlen);\n\tif (status)\n\t\treturn nfserr_bad_xdr;\n\n\tif (bmval[0] & ~NFSD_WRITEABLE_ATTRS_WORD0\n\t    || bmval[1] & ~NFSD_WRITEABLE_ATTRS_WORD1\n\t    || bmval[2] & ~NFSD_WRITEABLE_ATTRS_WORD2) {\n\t\tif (nfsd_attrs_supported(argp->minorversion, bmval))\n\t\t\treturn nfserr_inval;\n\t\treturn nfserr_attrnotsupp;\n\t}\n\n\tif (xdr_stream_decode_u32(argp->xdr, &attrlist4_count) < 0)\n\t\treturn nfserr_bad_xdr;\n\tstarting_pos = xdr_stream_pos(argp->xdr);\n\n\tif (bmval[0] & FATTR4_WORD0_SIZE) {\n\t\tu64 size;\n\n\t\tif (xdr_stream_decode_u64(argp->xdr, &size) < 0)\n\t\t\treturn nfserr_bad_xdr;\n\t\tiattr->ia_size = size;\n\t\tiattr->ia_valid |= ATTR_SIZE;\n\t}\n\tif (bmval[0] & FATTR4_WORD0_ACL) {\n\t\tstatus = nfsd4_decode_acl(argp, acl);\n\t\tif (status)\n\t\t\treturn status;\n\t} else\n\t\t*acl = NULL;\n\tif (bmval[1] & FATTR4_WORD1_MODE) {\n\t\tu32 mode;\n\n\t\tif (xdr_stream_decode_u32(argp->xdr, &mode) < 0)\n\t\t\treturn nfserr_bad_xdr;\n\t\tiattr->ia_mode = mode;\n\t\tiattr->ia_mode &= (S_IFMT | S_IALLUGO);\n\t\tiattr->ia_valid |= ATTR_MODE;\n\t}\n\tif (bmval[1] & FATTR4_WORD1_OWNER) {\n\t\tu32 length;\n\n\t\tif (xdr_stream_decode_u32(argp->xdr, &length) < 0)\n\t\t\treturn nfserr_bad_xdr;\n\t\tp = xdr_inline_decode(argp->xdr, length);\n\t\tif (!p)\n\t\t\treturn nfserr_bad_xdr;\n\t\tstatus = nfsd_map_name_to_uid(argp->rqstp, (char *)p, length,\n\t\t\t\t\t      &iattr->ia_uid);\n\t\tif (status)\n\t\t\treturn status;\n\t\tiattr->ia_valid |= ATTR_UID;\n\t}\n\tif (bmval[1] & FATTR4_WORD1_OWNER_GROUP) {\n\t\tu32 length;\n\n\t\tif (xdr_stream_decode_u32(argp->xdr, &length) < 0)\n\t\t\treturn nfserr_bad_xdr;\n\t\tp = xdr_inline_decode(argp->xdr, length);\n\t\tif (!p)\n\t\t\treturn nfserr_bad_xdr;\n\t\tstatus = nfsd_map_name_to_gid(argp->rqstp, (char *)p, length,\n\t\t\t\t\t      &iattr->ia_gid);\n\t\tif (status)\n\t\t\treturn status;\n\t\tiattr->ia_valid |= ATTR_GID;\n\t}\n\tif (bmval[1] & FATTR4_WORD1_TIME_ACCESS_SET) {\n\t\tu32 set_it;\n\n\t\tif (xdr_stream_decode_u32(argp->xdr, &set_it) < 0)\n\t\t\treturn nfserr_bad_xdr;\n\t\tswitch (set_it) {\n\t\tcase NFS4_SET_TO_CLIENT_TIME:\n\t\t\tstatus = nfsd4_decode_nfstime4(argp, &iattr->ia_atime);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tiattr->ia_valid |= (ATTR_ATIME | ATTR_ATIME_SET);\n\t\t\tbreak;\n\t\tcase NFS4_SET_TO_SERVER_TIME:\n\t\t\tiattr->ia_valid |= ATTR_ATIME;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn nfserr_bad_xdr;\n\t\t}\n\t}\n\tif (bmval[1] & FATTR4_WORD1_TIME_CREATE) {\n\t\tstruct timespec64 ts;\n\n\t\t \n\t\tbmval[1] &= ~FATTR4_WORD1_TIME_CREATE;\n\t\tstatus = nfsd4_decode_nfstime4(argp, &ts);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\tif (bmval[1] & FATTR4_WORD1_TIME_MODIFY_SET) {\n\t\tu32 set_it;\n\n\t\tif (xdr_stream_decode_u32(argp->xdr, &set_it) < 0)\n\t\t\treturn nfserr_bad_xdr;\n\t\tswitch (set_it) {\n\t\tcase NFS4_SET_TO_CLIENT_TIME:\n\t\t\tstatus = nfsd4_decode_nfstime4(argp, &iattr->ia_mtime);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tiattr->ia_valid |= (ATTR_MTIME | ATTR_MTIME_SET);\n\t\t\tbreak;\n\t\tcase NFS4_SET_TO_SERVER_TIME:\n\t\t\tiattr->ia_valid |= ATTR_MTIME;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn nfserr_bad_xdr;\n\t\t}\n\t}\n\tlabel->len = 0;\n\tif (IS_ENABLED(CONFIG_NFSD_V4_SECURITY_LABEL) &&\n\t    bmval[2] & FATTR4_WORD2_SECURITY_LABEL) {\n\t\tstatus = nfsd4_decode_security_label(argp, label);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\tif (bmval[2] & FATTR4_WORD2_MODE_UMASK) {\n\t\tu32 mode, mask;\n\n\t\tif (!umask)\n\t\t\treturn nfserr_bad_xdr;\n\t\tif (xdr_stream_decode_u32(argp->xdr, &mode) < 0)\n\t\t\treturn nfserr_bad_xdr;\n\t\tiattr->ia_mode = mode & (S_IFMT | S_IALLUGO);\n\t\tif (xdr_stream_decode_u32(argp->xdr, &mask) < 0)\n\t\t\treturn nfserr_bad_xdr;\n\t\t*umask = mask & S_IRWXUGO;\n\t\tiattr->ia_valid |= ATTR_MODE;\n\t}\n\n\t \n\tif (attrlist4_count != xdr_stream_pos(argp->xdr) - starting_pos)\n\t\treturn nfserr_bad_xdr;\n\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_decode_stateid4(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(argp->xdr, NFS4_STATEID_SIZE);\n\tif (!p)\n\t\treturn nfserr_bad_xdr;\n\tsid->si_generation = be32_to_cpup(p++);\n\tmemcpy(&sid->si_opaque, p, sizeof(sid->si_opaque));\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_decode_clientid4(struct nfsd4_compoundargs *argp, clientid_t *clientid)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(argp->xdr, sizeof(__be64));\n\tif (!p)\n\t\treturn nfserr_bad_xdr;\n\tmemcpy(clientid, p, sizeof(*clientid));\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_decode_state_owner4(struct nfsd4_compoundargs *argp,\n\t\t\t  clientid_t *clientid, struct xdr_netobj *owner)\n{\n\t__be32 status;\n\n\tstatus = nfsd4_decode_clientid4(argp, clientid);\n\tif (status)\n\t\treturn status;\n\treturn nfsd4_decode_opaque(argp, owner);\n}\n\n#ifdef CONFIG_NFSD_PNFS\nstatic __be32\nnfsd4_decode_deviceid4(struct nfsd4_compoundargs *argp,\n\t\t       struct nfsd4_deviceid *devid)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(argp->xdr, NFS4_DEVICEID4_SIZE);\n\tif (!p)\n\t\treturn nfserr_bad_xdr;\n\tmemcpy(devid, p, sizeof(*devid));\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_decode_layoutupdate4(struct nfsd4_compoundargs *argp,\n\t\t\t   struct nfsd4_layoutcommit *lcp)\n{\n\tif (xdr_stream_decode_u32(argp->xdr, &lcp->lc_layout_type) < 0)\n\t\treturn nfserr_bad_xdr;\n\tif (lcp->lc_layout_type < LAYOUT_NFSV4_1_FILES)\n\t\treturn nfserr_bad_xdr;\n\tif (lcp->lc_layout_type >= LAYOUT_TYPE_MAX)\n\t\treturn nfserr_bad_xdr;\n\n\tif (xdr_stream_decode_u32(argp->xdr, &lcp->lc_up_len) < 0)\n\t\treturn nfserr_bad_xdr;\n\tif (lcp->lc_up_len > 0) {\n\t\tlcp->lc_up_layout = xdr_inline_decode(argp->xdr, lcp->lc_up_len);\n\t\tif (!lcp->lc_up_layout)\n\t\t\treturn nfserr_bad_xdr;\n\t}\n\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_decode_layoutreturn4(struct nfsd4_compoundargs *argp,\n\t\t\t   struct nfsd4_layoutreturn *lrp)\n{\n\t__be32 status;\n\n\tif (xdr_stream_decode_u32(argp->xdr, &lrp->lr_return_type) < 0)\n\t\treturn nfserr_bad_xdr;\n\tswitch (lrp->lr_return_type) {\n\tcase RETURN_FILE:\n\t\tif (xdr_stream_decode_u64(argp->xdr, &lrp->lr_seg.offset) < 0)\n\t\t\treturn nfserr_bad_xdr;\n\t\tif (xdr_stream_decode_u64(argp->xdr, &lrp->lr_seg.length) < 0)\n\t\t\treturn nfserr_bad_xdr;\n\t\tstatus = nfsd4_decode_stateid4(argp, &lrp->lr_sid);\n\t\tif (status)\n\t\t\treturn status;\n\t\tif (xdr_stream_decode_u32(argp->xdr, &lrp->lrf_body_len) < 0)\n\t\t\treturn nfserr_bad_xdr;\n\t\tif (lrp->lrf_body_len > 0) {\n\t\t\tlrp->lrf_body = xdr_inline_decode(argp->xdr, lrp->lrf_body_len);\n\t\t\tif (!lrp->lrf_body)\n\t\t\t\treturn nfserr_bad_xdr;\n\t\t}\n\t\tbreak;\n\tcase RETURN_FSID:\n\tcase RETURN_ALL:\n\t\tlrp->lr_seg.offset = 0;\n\t\tlrp->lr_seg.length = NFS4_MAX_UINT64;\n\t\tbreak;\n\tdefault:\n\t\treturn nfserr_bad_xdr;\n\t}\n\n\treturn nfs_ok;\n}\n\n#endif  \n\nstatic __be32\nnfsd4_decode_sessionid4(struct nfsd4_compoundargs *argp,\n\t\t\tstruct nfs4_sessionid *sessionid)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(argp->xdr, NFS4_MAX_SESSIONID_LEN);\n\tif (!p)\n\t\treturn nfserr_bad_xdr;\n\tmemcpy(sessionid->data, p, sizeof(sessionid->data));\n\treturn nfs_ok;\n}\n\n \nstatic __be32\nnfsd4_decode_authsys_parms(struct nfsd4_compoundargs *argp,\n\t\t\t   struct nfsd4_cb_sec *cbs)\n{\n\tu32 stamp, gidcount, uid, gid;\n\t__be32 *p, status;\n\n\tif (xdr_stream_decode_u32(argp->xdr, &stamp) < 0)\n\t\treturn nfserr_bad_xdr;\n\t \n\tstatus = nfsd4_decode_ignored_string(argp, 255);\n\tif (status)\n\t\treturn status;\n\tif (xdr_stream_decode_u32(argp->xdr, &uid) < 0)\n\t\treturn nfserr_bad_xdr;\n\tif (xdr_stream_decode_u32(argp->xdr, &gid) < 0)\n\t\treturn nfserr_bad_xdr;\n\tif (xdr_stream_decode_u32(argp->xdr, &gidcount) < 0)\n\t\treturn nfserr_bad_xdr;\n\tif (gidcount > 16)\n\t\treturn nfserr_bad_xdr;\n\tp = xdr_inline_decode(argp->xdr, gidcount << 2);\n\tif (!p)\n\t\treturn nfserr_bad_xdr;\n\tif (cbs->flavor == (u32)(-1)) {\n\t\tstruct user_namespace *userns = nfsd_user_namespace(argp->rqstp);\n\n\t\tkuid_t kuid = make_kuid(userns, uid);\n\t\tkgid_t kgid = make_kgid(userns, gid);\n\t\tif (uid_valid(kuid) && gid_valid(kgid)) {\n\t\t\tcbs->uid = kuid;\n\t\t\tcbs->gid = kgid;\n\t\t\tcbs->flavor = RPC_AUTH_UNIX;\n\t\t} else {\n\t\t\tdprintk(\"RPC_AUTH_UNIX with invalid uid or gid, ignoring!\\n\");\n\t\t}\n\t}\n\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_decode_gss_cb_handles4(struct nfsd4_compoundargs *argp,\n\t\t\t     struct nfsd4_cb_sec *cbs)\n{\n\t__be32 status;\n\tu32 service;\n\n\tdprintk(\"RPC_AUTH_GSS callback secflavor not supported!\\n\");\n\n\tif (xdr_stream_decode_u32(argp->xdr, &service) < 0)\n\t\treturn nfserr_bad_xdr;\n\tif (service < RPC_GSS_SVC_NONE || service > RPC_GSS_SVC_PRIVACY)\n\t\treturn nfserr_bad_xdr;\n\t \n\tstatus = nfsd4_decode_ignored_string(argp, 0);\n\tif (status)\n\t\treturn status;\n\t \n\tstatus = nfsd4_decode_ignored_string(argp, 0);\n\tif (status)\n\t\treturn status;\n\n\treturn nfs_ok;\n}\n\n \nstatic __be32\nnfsd4_decode_cb_sec(struct nfsd4_compoundargs *argp, struct nfsd4_cb_sec *cbs)\n{\n\tu32 i, secflavor, nr_secflavs;\n\t__be32 status;\n\n\t \n\tif (xdr_stream_decode_u32(argp->xdr, &nr_secflavs) < 0)\n\t\treturn nfserr_bad_xdr;\n\tif (nr_secflavs)\n\t\tcbs->flavor = (u32)(-1);\n\telse\n\t\t \n\t\tcbs->flavor = 0;\n\n\tfor (i = 0; i < nr_secflavs; ++i) {\n\t\tif (xdr_stream_decode_u32(argp->xdr, &secflavor) < 0)\n\t\t\treturn nfserr_bad_xdr;\n\t\tswitch (secflavor) {\n\t\tcase RPC_AUTH_NULL:\n\t\t\t \n\t\t\tif (cbs->flavor == (u32)(-1))\n\t\t\t\tcbs->flavor = RPC_AUTH_NULL;\n\t\t\tbreak;\n\t\tcase RPC_AUTH_UNIX:\n\t\t\tstatus = nfsd4_decode_authsys_parms(argp, cbs);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tbreak;\n\t\tcase RPC_AUTH_GSS:\n\t\t\tstatus = nfsd4_decode_gss_cb_handles4(argp, cbs);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn nfserr_inval;\n\t\t}\n\t}\n\n\treturn nfs_ok;\n}\n\n\n \n\nstatic __be32\nnfsd4_decode_access(struct nfsd4_compoundargs *argp,\n\t\t    union nfsd4_op_u *u)\n{\n\tstruct nfsd4_access *access = &u->access;\n\tif (xdr_stream_decode_u32(argp->xdr, &access->ac_req_access) < 0)\n\t\treturn nfserr_bad_xdr;\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_decode_close(struct nfsd4_compoundargs *argp, union nfsd4_op_u *u)\n{\n\tstruct nfsd4_close *close = &u->close;\n\tif (xdr_stream_decode_u32(argp->xdr, &close->cl_seqid) < 0)\n\t\treturn nfserr_bad_xdr;\n\treturn nfsd4_decode_stateid4(argp, &close->cl_stateid);\n}\n\n\nstatic __be32\nnfsd4_decode_commit(struct nfsd4_compoundargs *argp, union nfsd4_op_u *u)\n{\n\tstruct nfsd4_commit *commit = &u->commit;\n\tif (xdr_stream_decode_u64(argp->xdr, &commit->co_offset) < 0)\n\t\treturn nfserr_bad_xdr;\n\tif (xdr_stream_decode_u32(argp->xdr, &commit->co_count) < 0)\n\t\treturn nfserr_bad_xdr;\n\tmemset(&commit->co_verf, 0, sizeof(commit->co_verf));\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_decode_create(struct nfsd4_compoundargs *argp, union nfsd4_op_u *u)\n{\n\tstruct nfsd4_create *create = &u->create;\n\t__be32 *p, status;\n\n\tmemset(create, 0, sizeof(*create));\n\tif (xdr_stream_decode_u32(argp->xdr, &create->cr_type) < 0)\n\t\treturn nfserr_bad_xdr;\n\tswitch (create->cr_type) {\n\tcase NF4LNK:\n\t\tif (xdr_stream_decode_u32(argp->xdr, &create->cr_datalen) < 0)\n\t\t\treturn nfserr_bad_xdr;\n\t\tp = xdr_inline_decode(argp->xdr, create->cr_datalen);\n\t\tif (!p)\n\t\t\treturn nfserr_bad_xdr;\n\t\tcreate->cr_data = svcxdr_dupstr(argp, p, create->cr_datalen);\n\t\tif (!create->cr_data)\n\t\t\treturn nfserr_jukebox;\n\t\tbreak;\n\tcase NF4BLK:\n\tcase NF4CHR:\n\t\tif (xdr_stream_decode_u32(argp->xdr, &create->cr_specdata1) < 0)\n\t\t\treturn nfserr_bad_xdr;\n\t\tif (xdr_stream_decode_u32(argp->xdr, &create->cr_specdata2) < 0)\n\t\t\treturn nfserr_bad_xdr;\n\t\tbreak;\n\tcase NF4SOCK:\n\tcase NF4FIFO:\n\tcase NF4DIR:\n\tdefault:\n\t\tbreak;\n\t}\n\tstatus = nfsd4_decode_component4(argp, &create->cr_name,\n\t\t\t\t\t &create->cr_namelen);\n\tif (status)\n\t\treturn status;\n\tstatus = nfsd4_decode_fattr4(argp, create->cr_bmval,\n\t\t\t\t    ARRAY_SIZE(create->cr_bmval),\n\t\t\t\t    &create->cr_iattr, &create->cr_acl,\n\t\t\t\t    &create->cr_label, &create->cr_umask);\n\tif (status)\n\t\treturn status;\n\n\treturn nfs_ok;\n}\n\nstatic inline __be32\nnfsd4_decode_delegreturn(struct nfsd4_compoundargs *argp, union nfsd4_op_u *u)\n{\n\tstruct nfsd4_delegreturn *dr = &u->delegreturn;\n\treturn nfsd4_decode_stateid4(argp, &dr->dr_stateid);\n}\n\nstatic inline __be32\nnfsd4_decode_getattr(struct nfsd4_compoundargs *argp, union nfsd4_op_u *u)\n{\n\tstruct nfsd4_getattr *getattr = &u->getattr;\n\tmemset(getattr, 0, sizeof(*getattr));\n\treturn nfsd4_decode_bitmap4(argp, getattr->ga_bmval,\n\t\t\t\t    ARRAY_SIZE(getattr->ga_bmval));\n}\n\nstatic __be32\nnfsd4_decode_link(struct nfsd4_compoundargs *argp, union nfsd4_op_u *u)\n{\n\tstruct nfsd4_link *link = &u->link;\n\tmemset(link, 0, sizeof(*link));\n\treturn nfsd4_decode_component4(argp, &link->li_name, &link->li_namelen);\n}\n\nstatic __be32\nnfsd4_decode_open_to_lock_owner4(struct nfsd4_compoundargs *argp,\n\t\t\t\t struct nfsd4_lock *lock)\n{\n\t__be32 status;\n\n\tif (xdr_stream_decode_u32(argp->xdr, &lock->lk_new_open_seqid) < 0)\n\t\treturn nfserr_bad_xdr;\n\tstatus = nfsd4_decode_stateid4(argp, &lock->lk_new_open_stateid);\n\tif (status)\n\t\treturn status;\n\tif (xdr_stream_decode_u32(argp->xdr, &lock->lk_new_lock_seqid) < 0)\n\t\treturn nfserr_bad_xdr;\n\treturn nfsd4_decode_state_owner4(argp, &lock->lk_new_clientid,\n\t\t\t\t\t &lock->lk_new_owner);\n}\n\nstatic __be32\nnfsd4_decode_exist_lock_owner4(struct nfsd4_compoundargs *argp,\n\t\t\t       struct nfsd4_lock *lock)\n{\n\t__be32 status;\n\n\tstatus = nfsd4_decode_stateid4(argp, &lock->lk_old_lock_stateid);\n\tif (status)\n\t\treturn status;\n\tif (xdr_stream_decode_u32(argp->xdr, &lock->lk_old_lock_seqid) < 0)\n\t\treturn nfserr_bad_xdr;\n\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_decode_locker4(struct nfsd4_compoundargs *argp, struct nfsd4_lock *lock)\n{\n\tif (xdr_stream_decode_bool(argp->xdr, &lock->lk_is_new) < 0)\n\t\treturn nfserr_bad_xdr;\n\tif (lock->lk_is_new)\n\t\treturn nfsd4_decode_open_to_lock_owner4(argp, lock);\n\treturn nfsd4_decode_exist_lock_owner4(argp, lock);\n}\n\nstatic __be32\nnfsd4_decode_lock(struct nfsd4_compoundargs *argp, union nfsd4_op_u *u)\n{\n\tstruct nfsd4_lock *lock = &u->lock;\n\tmemset(lock, 0, sizeof(*lock));\n\tif (xdr_stream_decode_u32(argp->xdr, &lock->lk_type) < 0)\n\t\treturn nfserr_bad_xdr;\n\tif ((lock->lk_type < NFS4_READ_LT) || (lock->lk_type > NFS4_WRITEW_LT))\n\t\treturn nfserr_bad_xdr;\n\tif (xdr_stream_decode_bool(argp->xdr, &lock->lk_reclaim) < 0)\n\t\treturn nfserr_bad_xdr;\n\tif (xdr_stream_decode_u64(argp->xdr, &lock->lk_offset) < 0)\n\t\treturn nfserr_bad_xdr;\n\tif (xdr_stream_decode_u64(argp->xdr, &lock->lk_length) < 0)\n\t\treturn nfserr_bad_xdr;\n\treturn nfsd4_decode_locker4(argp, lock);\n}\n\nstatic __be32\nnfsd4_decode_lockt(struct nfsd4_compoundargs *argp, union nfsd4_op_u *u)\n{\n\tstruct nfsd4_lockt *lockt = &u->lockt;\n\tmemset(lockt, 0, sizeof(*lockt));\n\tif (xdr_stream_decode_u32(argp->xdr, &lockt->lt_type) < 0)\n\t\treturn nfserr_bad_xdr;\n\tif ((lockt->lt_type < NFS4_READ_LT) || (lockt->lt_type > NFS4_WRITEW_LT))\n\t\treturn nfserr_bad_xdr;\n\tif (xdr_stream_decode_u64(argp->xdr, &lockt->lt_offset) < 0)\n\t\treturn nfserr_bad_xdr;\n\tif (xdr_stream_decode_u64(argp->xdr, &lockt->lt_length) < 0)\n\t\treturn nfserr_bad_xdr;\n\treturn nfsd4_decode_state_owner4(argp, &lockt->lt_clientid,\n\t\t\t\t\t &lockt->lt_owner);\n}\n\nstatic __be32\nnfsd4_decode_locku(struct nfsd4_compoundargs *argp, union nfsd4_op_u *u)\n{\n\tstruct nfsd4_locku *locku = &u->locku;\n\t__be32 status;\n\n\tif (xdr_stream_decode_u32(argp->xdr, &locku->lu_type) < 0)\n\t\treturn nfserr_bad_xdr;\n\tif ((locku->lu_type < NFS4_READ_LT) || (locku->lu_type > NFS4_WRITEW_LT))\n\t\treturn nfserr_bad_xdr;\n\tif (xdr_stream_decode_u32(argp->xdr, &locku->lu_seqid) < 0)\n\t\treturn nfserr_bad_xdr;\n\tstatus = nfsd4_decode_stateid4(argp, &locku->lu_stateid);\n\tif (status)\n\t\treturn status;\n\tif (xdr_stream_decode_u64(argp->xdr, &locku->lu_offset) < 0)\n\t\treturn nfserr_bad_xdr;\n\tif (xdr_stream_decode_u64(argp->xdr, &locku->lu_length) < 0)\n\t\treturn nfserr_bad_xdr;\n\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_decode_lookup(struct nfsd4_compoundargs *argp, union nfsd4_op_u *u)\n{\n\tstruct nfsd4_lookup *lookup = &u->lookup;\n\treturn nfsd4_decode_component4(argp, &lookup->lo_name, &lookup->lo_len);\n}\n\nstatic __be32\nnfsd4_decode_createhow4(struct nfsd4_compoundargs *argp, struct nfsd4_open *open)\n{\n\t__be32 status;\n\n\tif (xdr_stream_decode_u32(argp->xdr, &open->op_createmode) < 0)\n\t\treturn nfserr_bad_xdr;\n\tswitch (open->op_createmode) {\n\tcase NFS4_CREATE_UNCHECKED:\n\tcase NFS4_CREATE_GUARDED:\n\t\tstatus = nfsd4_decode_fattr4(argp, open->op_bmval,\n\t\t\t\t\t     ARRAY_SIZE(open->op_bmval),\n\t\t\t\t\t     &open->op_iattr, &open->op_acl,\n\t\t\t\t\t     &open->op_label, &open->op_umask);\n\t\tif (status)\n\t\t\treturn status;\n\t\tbreak;\n\tcase NFS4_CREATE_EXCLUSIVE:\n\t\tstatus = nfsd4_decode_verifier4(argp, &open->op_verf);\n\t\tif (status)\n\t\t\treturn status;\n\t\tbreak;\n\tcase NFS4_CREATE_EXCLUSIVE4_1:\n\t\tif (argp->minorversion < 1)\n\t\t\treturn nfserr_bad_xdr;\n\t\tstatus = nfsd4_decode_verifier4(argp, &open->op_verf);\n\t\tif (status)\n\t\t\treturn status;\n\t\tstatus = nfsd4_decode_fattr4(argp, open->op_bmval,\n\t\t\t\t\t     ARRAY_SIZE(open->op_bmval),\n\t\t\t\t\t     &open->op_iattr, &open->op_acl,\n\t\t\t\t\t     &open->op_label, &open->op_umask);\n\t\tif (status)\n\t\t\treturn status;\n\t\tbreak;\n\tdefault:\n\t\treturn nfserr_bad_xdr;\n\t}\n\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_decode_openflag4(struct nfsd4_compoundargs *argp, struct nfsd4_open *open)\n{\n\t__be32 status;\n\n\tif (xdr_stream_decode_u32(argp->xdr, &open->op_create) < 0)\n\t\treturn nfserr_bad_xdr;\n\tswitch (open->op_create) {\n\tcase NFS4_OPEN_NOCREATE:\n\t\tbreak;\n\tcase NFS4_OPEN_CREATE:\n\t\tstatus = nfsd4_decode_createhow4(argp, open);\n\t\tif (status)\n\t\t\treturn status;\n\t\tbreak;\n\tdefault:\n\t\treturn nfserr_bad_xdr;\n\t}\n\n\treturn nfs_ok;\n}\n\nstatic __be32 nfsd4_decode_share_access(struct nfsd4_compoundargs *argp, u32 *share_access, u32 *deleg_want, u32 *deleg_when)\n{\n\tu32 w;\n\n\tif (xdr_stream_decode_u32(argp->xdr, &w) < 0)\n\t\treturn nfserr_bad_xdr;\n\t*share_access = w & NFS4_SHARE_ACCESS_MASK;\n\t*deleg_want = w & NFS4_SHARE_WANT_MASK;\n\tif (deleg_when)\n\t\t*deleg_when = w & NFS4_SHARE_WHEN_MASK;\n\n\tswitch (w & NFS4_SHARE_ACCESS_MASK) {\n\tcase NFS4_SHARE_ACCESS_READ:\n\tcase NFS4_SHARE_ACCESS_WRITE:\n\tcase NFS4_SHARE_ACCESS_BOTH:\n\t\tbreak;\n\tdefault:\n\t\treturn nfserr_bad_xdr;\n\t}\n\tw &= ~NFS4_SHARE_ACCESS_MASK;\n\tif (!w)\n\t\treturn nfs_ok;\n\tif (!argp->minorversion)\n\t\treturn nfserr_bad_xdr;\n\tswitch (w & NFS4_SHARE_WANT_MASK) {\n\tcase NFS4_SHARE_WANT_NO_PREFERENCE:\n\tcase NFS4_SHARE_WANT_READ_DELEG:\n\tcase NFS4_SHARE_WANT_WRITE_DELEG:\n\tcase NFS4_SHARE_WANT_ANY_DELEG:\n\tcase NFS4_SHARE_WANT_NO_DELEG:\n\tcase NFS4_SHARE_WANT_CANCEL:\n\t\tbreak;\n\tdefault:\n\t\treturn nfserr_bad_xdr;\n\t}\n\tw &= ~NFS4_SHARE_WANT_MASK;\n\tif (!w)\n\t\treturn nfs_ok;\n\n\tif (!deleg_when)\t \n\t\treturn nfserr_inval;\n\tswitch (w) {\n\tcase NFS4_SHARE_SIGNAL_DELEG_WHEN_RESRC_AVAIL:\n\tcase NFS4_SHARE_PUSH_DELEG_WHEN_UNCONTENDED:\n\tcase (NFS4_SHARE_SIGNAL_DELEG_WHEN_RESRC_AVAIL |\n\t      NFS4_SHARE_PUSH_DELEG_WHEN_UNCONTENDED):\n\t\treturn nfs_ok;\n\t}\n\treturn nfserr_bad_xdr;\n}\n\nstatic __be32 nfsd4_decode_share_deny(struct nfsd4_compoundargs *argp, u32 *x)\n{\n\tif (xdr_stream_decode_u32(argp->xdr, x) < 0)\n\t\treturn nfserr_bad_xdr;\n\t \n\tif (*x & ~NFS4_SHARE_DENY_BOTH)\n\t\treturn nfserr_bad_xdr;\n\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_decode_open_claim4(struct nfsd4_compoundargs *argp,\n\t\t\t struct nfsd4_open *open)\n{\n\t__be32 status;\n\n\tif (xdr_stream_decode_u32(argp->xdr, &open->op_claim_type) < 0)\n\t\treturn nfserr_bad_xdr;\n\tswitch (open->op_claim_type) {\n\tcase NFS4_OPEN_CLAIM_NULL:\n\tcase NFS4_OPEN_CLAIM_DELEGATE_PREV:\n\t\tstatus = nfsd4_decode_component4(argp, &open->op_fname,\n\t\t\t\t\t\t &open->op_fnamelen);\n\t\tif (status)\n\t\t\treturn status;\n\t\tbreak;\n\tcase NFS4_OPEN_CLAIM_PREVIOUS:\n\t\tif (xdr_stream_decode_u32(argp->xdr, &open->op_delegate_type) < 0)\n\t\t\treturn nfserr_bad_xdr;\n\t\tbreak;\n\tcase NFS4_OPEN_CLAIM_DELEGATE_CUR:\n\t\tstatus = nfsd4_decode_stateid4(argp, &open->op_delegate_stateid);\n\t\tif (status)\n\t\t\treturn status;\n\t\tstatus = nfsd4_decode_component4(argp, &open->op_fname,\n\t\t\t\t\t\t &open->op_fnamelen);\n\t\tif (status)\n\t\t\treturn status;\n\t\tbreak;\n\tcase NFS4_OPEN_CLAIM_FH:\n\tcase NFS4_OPEN_CLAIM_DELEG_PREV_FH:\n\t\tif (argp->minorversion < 1)\n\t\t\treturn nfserr_bad_xdr;\n\t\t \n\t\tbreak;\n\tcase NFS4_OPEN_CLAIM_DELEG_CUR_FH:\n\t\tif (argp->minorversion < 1)\n\t\t\treturn nfserr_bad_xdr;\n\t\tstatus = nfsd4_decode_stateid4(argp, &open->op_delegate_stateid);\n\t\tif (status)\n\t\t\treturn status;\n\t\tbreak;\n\tdefault:\n\t\treturn nfserr_bad_xdr;\n\t}\n\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_decode_open(struct nfsd4_compoundargs *argp, union nfsd4_op_u *u)\n{\n\tstruct nfsd4_open *open = &u->open;\n\t__be32 status;\n\tu32 dummy;\n\n\tmemset(open, 0, sizeof(*open));\n\n\tif (xdr_stream_decode_u32(argp->xdr, &open->op_seqid) < 0)\n\t\treturn nfserr_bad_xdr;\n\t \n\tstatus = nfsd4_decode_share_access(argp, &open->op_share_access,\n\t\t\t\t\t   &open->op_deleg_want, &dummy);\n\tif (status)\n\t\treturn status;\n\tstatus = nfsd4_decode_share_deny(argp, &open->op_share_deny);\n\tif (status)\n\t\treturn status;\n\tstatus = nfsd4_decode_state_owner4(argp, &open->op_clientid,\n\t\t\t\t\t   &open->op_owner);\n\tif (status)\n\t\treturn status;\n\tstatus = nfsd4_decode_openflag4(argp, open);\n\tif (status)\n\t\treturn status;\n\treturn nfsd4_decode_open_claim4(argp, open);\n}\n\nstatic __be32\nnfsd4_decode_open_confirm(struct nfsd4_compoundargs *argp,\n\t\t\t  union nfsd4_op_u *u)\n{\n\tstruct nfsd4_open_confirm *open_conf = &u->open_confirm;\n\t__be32 status;\n\n\tif (argp->minorversion >= 1)\n\t\treturn nfserr_notsupp;\n\n\tstatus = nfsd4_decode_stateid4(argp, &open_conf->oc_req_stateid);\n\tif (status)\n\t\treturn status;\n\tif (xdr_stream_decode_u32(argp->xdr, &open_conf->oc_seqid) < 0)\n\t\treturn nfserr_bad_xdr;\n\n\tmemset(&open_conf->oc_resp_stateid, 0,\n\t       sizeof(open_conf->oc_resp_stateid));\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_decode_open_downgrade(struct nfsd4_compoundargs *argp,\n\t\t\t    union nfsd4_op_u *u)\n{\n\tstruct nfsd4_open_downgrade *open_down = &u->open_downgrade;\n\t__be32 status;\n\n\tmemset(open_down, 0, sizeof(*open_down));\n\tstatus = nfsd4_decode_stateid4(argp, &open_down->od_stateid);\n\tif (status)\n\t\treturn status;\n\tif (xdr_stream_decode_u32(argp->xdr, &open_down->od_seqid) < 0)\n\t\treturn nfserr_bad_xdr;\n\t \n\tstatus = nfsd4_decode_share_access(argp, &open_down->od_share_access,\n\t\t\t\t\t   &open_down->od_deleg_want, NULL);\n\tif (status)\n\t\treturn status;\n\treturn nfsd4_decode_share_deny(argp, &open_down->od_share_deny);\n}\n\nstatic __be32\nnfsd4_decode_putfh(struct nfsd4_compoundargs *argp, union nfsd4_op_u *u)\n{\n\tstruct nfsd4_putfh *putfh = &u->putfh;\n\t__be32 *p;\n\n\tif (xdr_stream_decode_u32(argp->xdr, &putfh->pf_fhlen) < 0)\n\t\treturn nfserr_bad_xdr;\n\tif (putfh->pf_fhlen > NFS4_FHSIZE)\n\t\treturn nfserr_bad_xdr;\n\tp = xdr_inline_decode(argp->xdr, putfh->pf_fhlen);\n\tif (!p)\n\t\treturn nfserr_bad_xdr;\n\tputfh->pf_fhval = svcxdr_savemem(argp, p, putfh->pf_fhlen);\n\tif (!putfh->pf_fhval)\n\t\treturn nfserr_jukebox;\n\n\tputfh->no_verify = false;\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_decode_putpubfh(struct nfsd4_compoundargs *argp, union nfsd4_op_u *p)\n{\n\tif (argp->minorversion == 0)\n\t\treturn nfs_ok;\n\treturn nfserr_notsupp;\n}\n\nstatic __be32\nnfsd4_decode_read(struct nfsd4_compoundargs *argp, union nfsd4_op_u *u)\n{\n\tstruct nfsd4_read *read = &u->read;\n\t__be32 status;\n\n\tmemset(read, 0, sizeof(*read));\n\tstatus = nfsd4_decode_stateid4(argp, &read->rd_stateid);\n\tif (status)\n\t\treturn status;\n\tif (xdr_stream_decode_u64(argp->xdr, &read->rd_offset) < 0)\n\t\treturn nfserr_bad_xdr;\n\tif (xdr_stream_decode_u32(argp->xdr, &read->rd_length) < 0)\n\t\treturn nfserr_bad_xdr;\n\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_decode_readdir(struct nfsd4_compoundargs *argp, union nfsd4_op_u *u)\n{\n\tstruct nfsd4_readdir *readdir = &u->readdir;\n\t__be32 status;\n\n\tmemset(readdir, 0, sizeof(*readdir));\n\tif (xdr_stream_decode_u64(argp->xdr, &readdir->rd_cookie) < 0)\n\t\treturn nfserr_bad_xdr;\n\tstatus = nfsd4_decode_verifier4(argp, &readdir->rd_verf);\n\tif (status)\n\t\treturn status;\n\tif (xdr_stream_decode_u32(argp->xdr, &readdir->rd_dircount) < 0)\n\t\treturn nfserr_bad_xdr;\n\tif (xdr_stream_decode_u32(argp->xdr, &readdir->rd_maxcount) < 0)\n\t\treturn nfserr_bad_xdr;\n\tif (xdr_stream_decode_uint32_array(argp->xdr, readdir->rd_bmval,\n\t\t\t\t\t   ARRAY_SIZE(readdir->rd_bmval)) < 0)\n\t\treturn nfserr_bad_xdr;\n\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_decode_remove(struct nfsd4_compoundargs *argp, union nfsd4_op_u *u)\n{\n\tstruct nfsd4_remove *remove = &u->remove;\n\tmemset(&remove->rm_cinfo, 0, sizeof(remove->rm_cinfo));\n\treturn nfsd4_decode_component4(argp, &remove->rm_name, &remove->rm_namelen);\n}\n\nstatic __be32\nnfsd4_decode_rename(struct nfsd4_compoundargs *argp, union nfsd4_op_u *u)\n{\n\tstruct nfsd4_rename *rename = &u->rename;\n\t__be32 status;\n\n\tmemset(rename, 0, sizeof(*rename));\n\tstatus = nfsd4_decode_component4(argp, &rename->rn_sname, &rename->rn_snamelen);\n\tif (status)\n\t\treturn status;\n\treturn nfsd4_decode_component4(argp, &rename->rn_tname, &rename->rn_tnamelen);\n}\n\nstatic __be32\nnfsd4_decode_renew(struct nfsd4_compoundargs *argp, union nfsd4_op_u *u)\n{\n\tclientid_t *clientid = &u->renew;\n\treturn nfsd4_decode_clientid4(argp, clientid);\n}\n\nstatic __be32\nnfsd4_decode_secinfo(struct nfsd4_compoundargs *argp,\n\t\t     union nfsd4_op_u *u)\n{\n\tstruct nfsd4_secinfo *secinfo = &u->secinfo;\n\tsecinfo->si_exp = NULL;\n\treturn nfsd4_decode_component4(argp, &secinfo->si_name, &secinfo->si_namelen);\n}\n\nstatic __be32\nnfsd4_decode_setattr(struct nfsd4_compoundargs *argp, union nfsd4_op_u *u)\n{\n\tstruct nfsd4_setattr *setattr = &u->setattr;\n\t__be32 status;\n\n\tmemset(setattr, 0, sizeof(*setattr));\n\tstatus = nfsd4_decode_stateid4(argp, &setattr->sa_stateid);\n\tif (status)\n\t\treturn status;\n\treturn nfsd4_decode_fattr4(argp, setattr->sa_bmval,\n\t\t\t\t   ARRAY_SIZE(setattr->sa_bmval),\n\t\t\t\t   &setattr->sa_iattr, &setattr->sa_acl,\n\t\t\t\t   &setattr->sa_label, NULL);\n}\n\nstatic __be32\nnfsd4_decode_setclientid(struct nfsd4_compoundargs *argp, union nfsd4_op_u *u)\n{\n\tstruct nfsd4_setclientid *setclientid = &u->setclientid;\n\t__be32 *p, status;\n\n\tmemset(setclientid, 0, sizeof(*setclientid));\n\n\tif (argp->minorversion >= 1)\n\t\treturn nfserr_notsupp;\n\n\tstatus = nfsd4_decode_verifier4(argp, &setclientid->se_verf);\n\tif (status)\n\t\treturn status;\n\tstatus = nfsd4_decode_opaque(argp, &setclientid->se_name);\n\tif (status)\n\t\treturn status;\n\tif (xdr_stream_decode_u32(argp->xdr, &setclientid->se_callback_prog) < 0)\n\t\treturn nfserr_bad_xdr;\n\tif (xdr_stream_decode_u32(argp->xdr, &setclientid->se_callback_netid_len) < 0)\n\t\treturn nfserr_bad_xdr;\n\tp = xdr_inline_decode(argp->xdr, setclientid->se_callback_netid_len);\n\tif (!p)\n\t\treturn nfserr_bad_xdr;\n\tsetclientid->se_callback_netid_val = svcxdr_savemem(argp, p,\n\t\t\t\t\t\tsetclientid->se_callback_netid_len);\n\tif (!setclientid->se_callback_netid_val)\n\t\treturn nfserr_jukebox;\n\n\tif (xdr_stream_decode_u32(argp->xdr, &setclientid->se_callback_addr_len) < 0)\n\t\treturn nfserr_bad_xdr;\n\tp = xdr_inline_decode(argp->xdr, setclientid->se_callback_addr_len);\n\tif (!p)\n\t\treturn nfserr_bad_xdr;\n\tsetclientid->se_callback_addr_val = svcxdr_savemem(argp, p,\n\t\t\t\t\t\tsetclientid->se_callback_addr_len);\n\tif (!setclientid->se_callback_addr_val)\n\t\treturn nfserr_jukebox;\n\tif (xdr_stream_decode_u32(argp->xdr, &setclientid->se_callback_ident) < 0)\n\t\treturn nfserr_bad_xdr;\n\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_decode_setclientid_confirm(struct nfsd4_compoundargs *argp,\n\t\t\t\t union nfsd4_op_u *u)\n{\n\tstruct nfsd4_setclientid_confirm *scd_c = &u->setclientid_confirm;\n\t__be32 status;\n\n\tif (argp->minorversion >= 1)\n\t\treturn nfserr_notsupp;\n\n\tstatus = nfsd4_decode_clientid4(argp, &scd_c->sc_clientid);\n\tif (status)\n\t\treturn status;\n\treturn nfsd4_decode_verifier4(argp, &scd_c->sc_confirm);\n}\n\n \nstatic __be32\nnfsd4_decode_verify(struct nfsd4_compoundargs *argp, union nfsd4_op_u *u)\n{\n\tstruct nfsd4_verify *verify = &u->verify;\n\t__be32 *p, status;\n\n\tmemset(verify, 0, sizeof(*verify));\n\n\tstatus = nfsd4_decode_bitmap4(argp, verify->ve_bmval,\n\t\t\t\t      ARRAY_SIZE(verify->ve_bmval));\n\tif (status)\n\t\treturn status;\n\n\t \n\n\tif (xdr_stream_decode_u32(argp->xdr, &verify->ve_attrlen) < 0)\n\t\treturn nfserr_bad_xdr;\n\tp = xdr_inline_decode(argp->xdr, verify->ve_attrlen);\n\tif (!p)\n\t\treturn nfserr_bad_xdr;\n\tverify->ve_attrval = svcxdr_savemem(argp, p, verify->ve_attrlen);\n\tif (!verify->ve_attrval)\n\t\treturn nfserr_jukebox;\n\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_decode_write(struct nfsd4_compoundargs *argp, union nfsd4_op_u *u)\n{\n\tstruct nfsd4_write *write = &u->write;\n\t__be32 status;\n\n\tstatus = nfsd4_decode_stateid4(argp, &write->wr_stateid);\n\tif (status)\n\t\treturn status;\n\tif (xdr_stream_decode_u64(argp->xdr, &write->wr_offset) < 0)\n\t\treturn nfserr_bad_xdr;\n\tif (xdr_stream_decode_u32(argp->xdr, &write->wr_stable_how) < 0)\n\t\treturn nfserr_bad_xdr;\n\tif (write->wr_stable_how > NFS_FILE_SYNC)\n\t\treturn nfserr_bad_xdr;\n\tif (xdr_stream_decode_u32(argp->xdr, &write->wr_buflen) < 0)\n\t\treturn nfserr_bad_xdr;\n\tif (!xdr_stream_subsegment(argp->xdr, &write->wr_payload, write->wr_buflen))\n\t\treturn nfserr_bad_xdr;\n\n\twrite->wr_bytes_written = 0;\n\twrite->wr_how_written = 0;\n\tmemset(&write->wr_verifier, 0, sizeof(write->wr_verifier));\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_decode_release_lockowner(struct nfsd4_compoundargs *argp,\n\t\t\t       union nfsd4_op_u *u)\n{\n\tstruct nfsd4_release_lockowner *rlockowner = &u->release_lockowner;\n\t__be32 status;\n\n\tif (argp->minorversion >= 1)\n\t\treturn nfserr_notsupp;\n\n\tstatus = nfsd4_decode_state_owner4(argp, &rlockowner->rl_clientid,\n\t\t\t\t\t   &rlockowner->rl_owner);\n\tif (status)\n\t\treturn status;\n\n\tif (argp->minorversion && !zero_clientid(&rlockowner->rl_clientid))\n\t\treturn nfserr_inval;\n\n\treturn nfs_ok;\n}\n\nstatic __be32 nfsd4_decode_backchannel_ctl(struct nfsd4_compoundargs *argp,\n\t\t\t\t\t   union nfsd4_op_u *u)\n{\n\tstruct nfsd4_backchannel_ctl *bc = &u->backchannel_ctl;\n\tmemset(bc, 0, sizeof(*bc));\n\tif (xdr_stream_decode_u32(argp->xdr, &bc->bc_cb_program) < 0)\n\t\treturn nfserr_bad_xdr;\n\treturn nfsd4_decode_cb_sec(argp, &bc->bc_cb_sec);\n}\n\nstatic __be32 nfsd4_decode_bind_conn_to_session(struct nfsd4_compoundargs *argp,\n\t\t\t\t\t\tunion nfsd4_op_u *u)\n{\n\tstruct nfsd4_bind_conn_to_session *bcts = &u->bind_conn_to_session;\n\tu32 use_conn_in_rdma_mode;\n\t__be32 status;\n\n\tmemset(bcts, 0, sizeof(*bcts));\n\tstatus = nfsd4_decode_sessionid4(argp, &bcts->sessionid);\n\tif (status)\n\t\treturn status;\n\tif (xdr_stream_decode_u32(argp->xdr, &bcts->dir) < 0)\n\t\treturn nfserr_bad_xdr;\n\tif (xdr_stream_decode_u32(argp->xdr, &use_conn_in_rdma_mode) < 0)\n\t\treturn nfserr_bad_xdr;\n\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_decode_state_protect_ops(struct nfsd4_compoundargs *argp,\n\t\t\t       struct nfsd4_exchange_id *exid)\n{\n\t__be32 status;\n\n\tstatus = nfsd4_decode_bitmap4(argp, exid->spo_must_enforce,\n\t\t\t\t      ARRAY_SIZE(exid->spo_must_enforce));\n\tif (status)\n\t\treturn nfserr_bad_xdr;\n\tstatus = nfsd4_decode_bitmap4(argp, exid->spo_must_allow,\n\t\t\t\t      ARRAY_SIZE(exid->spo_must_allow));\n\tif (status)\n\t\treturn nfserr_bad_xdr;\n\n\treturn nfs_ok;\n}\n\n \nstatic noinline __be32\nnfsd4_decode_ssv_sp_parms(struct nfsd4_compoundargs *argp,\n\t\t\t  struct nfsd4_exchange_id *exid)\n{\n\tu32 count, window, num_gss_handles;\n\t__be32 status;\n\n\t \n\tstatus = nfsd4_decode_state_protect_ops(argp, exid);\n\tif (status)\n\t\treturn status;\n\n\t \n\tif (xdr_stream_decode_u32(argp->xdr, &count) < 0)\n\t\treturn nfserr_bad_xdr;\n\twhile (count--) {\n\t\tstatus = nfsd4_decode_ignored_string(argp, 0);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\n\t \n\tif (xdr_stream_decode_u32(argp->xdr, &count) < 0)\n\t\treturn nfserr_bad_xdr;\n\twhile (count--) {\n\t\tstatus = nfsd4_decode_ignored_string(argp, 0);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\n\tif (xdr_stream_decode_u32(argp->xdr, &window) < 0)\n\t\treturn nfserr_bad_xdr;\n\tif (xdr_stream_decode_u32(argp->xdr, &num_gss_handles) < 0)\n\t\treturn nfserr_bad_xdr;\n\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_decode_state_protect4_a(struct nfsd4_compoundargs *argp,\n\t\t\t      struct nfsd4_exchange_id *exid)\n{\n\t__be32 status;\n\n\tif (xdr_stream_decode_u32(argp->xdr, &exid->spa_how) < 0)\n\t\treturn nfserr_bad_xdr;\n\tswitch (exid->spa_how) {\n\tcase SP4_NONE:\n\t\tbreak;\n\tcase SP4_MACH_CRED:\n\t\tstatus = nfsd4_decode_state_protect_ops(argp, exid);\n\t\tif (status)\n\t\t\treturn status;\n\t\tbreak;\n\tcase SP4_SSV:\n\t\tstatus = nfsd4_decode_ssv_sp_parms(argp, exid);\n\t\tif (status)\n\t\t\treturn status;\n\t\tbreak;\n\tdefault:\n\t\treturn nfserr_bad_xdr;\n\t}\n\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_decode_nfs_impl_id4(struct nfsd4_compoundargs *argp,\n\t\t\t  struct nfsd4_exchange_id *exid)\n{\n\t__be32 status;\n\tu32 count;\n\n\tif (xdr_stream_decode_u32(argp->xdr, &count) < 0)\n\t\treturn nfserr_bad_xdr;\n\tswitch (count) {\n\tcase 0:\n\t\tbreak;\n\tcase 1:\n\t\t \n\t\tstatus = nfsd4_decode_opaque(argp, &exid->nii_domain);\n\t\tif (status)\n\t\t\treturn status;\n\t\t \n\t\tstatus = nfsd4_decode_opaque(argp, &exid->nii_name);\n\t\tif (status)\n\t\t\treturn status;\n\t\tstatus = nfsd4_decode_nfstime4(argp, &exid->nii_time);\n\t\tif (status)\n\t\t\treturn status;\n\t\tbreak;\n\tdefault:\n\t\treturn nfserr_bad_xdr;\n\t}\n\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_decode_exchange_id(struct nfsd4_compoundargs *argp,\n\t\t\t union nfsd4_op_u *u)\n{\n\tstruct nfsd4_exchange_id *exid = &u->exchange_id;\n\t__be32 status;\n\n\tmemset(exid, 0, sizeof(*exid));\n\tstatus = nfsd4_decode_verifier4(argp, &exid->verifier);\n\tif (status)\n\t\treturn status;\n\tstatus = nfsd4_decode_opaque(argp, &exid->clname);\n\tif (status)\n\t\treturn status;\n\tif (xdr_stream_decode_u32(argp->xdr, &exid->flags) < 0)\n\t\treturn nfserr_bad_xdr;\n\tstatus = nfsd4_decode_state_protect4_a(argp, exid);\n\tif (status)\n\t\treturn status;\n\treturn nfsd4_decode_nfs_impl_id4(argp, exid);\n}\n\nstatic __be32\nnfsd4_decode_channel_attrs4(struct nfsd4_compoundargs *argp,\n\t\t\t    struct nfsd4_channel_attrs *ca)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(argp->xdr, XDR_UNIT * 7);\n\tif (!p)\n\t\treturn nfserr_bad_xdr;\n\n\t \n\tp++;\n\tca->maxreq_sz = be32_to_cpup(p++);\n\tca->maxresp_sz = be32_to_cpup(p++);\n\tca->maxresp_cached = be32_to_cpup(p++);\n\tca->maxops = be32_to_cpup(p++);\n\tca->maxreqs = be32_to_cpup(p++);\n\tca->nr_rdma_attrs = be32_to_cpup(p);\n\tswitch (ca->nr_rdma_attrs) {\n\tcase 0:\n\t\tbreak;\n\tcase 1:\n\t\tif (xdr_stream_decode_u32(argp->xdr, &ca->rdma_attrs) < 0)\n\t\t\treturn nfserr_bad_xdr;\n\t\tbreak;\n\tdefault:\n\t\treturn nfserr_bad_xdr;\n\t}\n\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_decode_create_session(struct nfsd4_compoundargs *argp,\n\t\t\t    union nfsd4_op_u *u)\n{\n\tstruct nfsd4_create_session *sess = &u->create_session;\n\t__be32 status;\n\n\tmemset(sess, 0, sizeof(*sess));\n\tstatus = nfsd4_decode_clientid4(argp, &sess->clientid);\n\tif (status)\n\t\treturn status;\n\tif (xdr_stream_decode_u32(argp->xdr, &sess->seqid) < 0)\n\t\treturn nfserr_bad_xdr;\n\tif (xdr_stream_decode_u32(argp->xdr, &sess->flags) < 0)\n\t\treturn nfserr_bad_xdr;\n\tstatus = nfsd4_decode_channel_attrs4(argp, &sess->fore_channel);\n\tif (status)\n\t\treturn status;\n\tstatus = nfsd4_decode_channel_attrs4(argp, &sess->back_channel);\n\tif (status)\n\t\treturn status;\n\tif (xdr_stream_decode_u32(argp->xdr, &sess->callback_prog) < 0)\n\t\treturn nfserr_bad_xdr;\n\treturn nfsd4_decode_cb_sec(argp, &sess->cb_sec);\n}\n\nstatic __be32\nnfsd4_decode_destroy_session(struct nfsd4_compoundargs *argp,\n\t\t\t     union nfsd4_op_u *u)\n{\n\tstruct nfsd4_destroy_session *destroy_session = &u->destroy_session;\n\treturn nfsd4_decode_sessionid4(argp, &destroy_session->sessionid);\n}\n\nstatic __be32\nnfsd4_decode_free_stateid(struct nfsd4_compoundargs *argp,\n\t\t\t  union nfsd4_op_u *u)\n{\n\tstruct nfsd4_free_stateid *free_stateid = &u->free_stateid;\n\treturn nfsd4_decode_stateid4(argp, &free_stateid->fr_stateid);\n}\n\n#ifdef CONFIG_NFSD_PNFS\nstatic __be32\nnfsd4_decode_getdeviceinfo(struct nfsd4_compoundargs *argp,\n\t\tunion nfsd4_op_u *u)\n{\n\tstruct nfsd4_getdeviceinfo *gdev = &u->getdeviceinfo;\n\t__be32 status;\n\n\tmemset(gdev, 0, sizeof(*gdev));\n\tstatus = nfsd4_decode_deviceid4(argp, &gdev->gd_devid);\n\tif (status)\n\t\treturn status;\n\tif (xdr_stream_decode_u32(argp->xdr, &gdev->gd_layout_type) < 0)\n\t\treturn nfserr_bad_xdr;\n\tif (xdr_stream_decode_u32(argp->xdr, &gdev->gd_maxcount) < 0)\n\t\treturn nfserr_bad_xdr;\n\tif (xdr_stream_decode_uint32_array(argp->xdr,\n\t\t\t\t\t   &gdev->gd_notify_types, 1) < 0)\n\t\treturn nfserr_bad_xdr;\n\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_decode_layoutcommit(struct nfsd4_compoundargs *argp,\n\t\t\t  union nfsd4_op_u *u)\n{\n\tstruct nfsd4_layoutcommit *lcp = &u->layoutcommit;\n\t__be32 *p, status;\n\n\tmemset(lcp, 0, sizeof(*lcp));\n\tif (xdr_stream_decode_u64(argp->xdr, &lcp->lc_seg.offset) < 0)\n\t\treturn nfserr_bad_xdr;\n\tif (xdr_stream_decode_u64(argp->xdr, &lcp->lc_seg.length) < 0)\n\t\treturn nfserr_bad_xdr;\n\tif (xdr_stream_decode_bool(argp->xdr, &lcp->lc_reclaim) < 0)\n\t\treturn nfserr_bad_xdr;\n\tstatus = nfsd4_decode_stateid4(argp, &lcp->lc_sid);\n\tif (status)\n\t\treturn status;\n\tif (xdr_stream_decode_u32(argp->xdr, &lcp->lc_newoffset) < 0)\n\t\treturn nfserr_bad_xdr;\n\tif (lcp->lc_newoffset) {\n\t\tif (xdr_stream_decode_u64(argp->xdr, &lcp->lc_last_wr) < 0)\n\t\t\treturn nfserr_bad_xdr;\n\t} else\n\t\tlcp->lc_last_wr = 0;\n\tp = xdr_inline_decode(argp->xdr, XDR_UNIT);\n\tif (!p)\n\t\treturn nfserr_bad_xdr;\n\tif (xdr_item_is_present(p)) {\n\t\tstatus = nfsd4_decode_nfstime4(argp, &lcp->lc_mtime);\n\t\tif (status)\n\t\t\treturn status;\n\t} else {\n\t\tlcp->lc_mtime.tv_nsec = UTIME_NOW;\n\t}\n\treturn nfsd4_decode_layoutupdate4(argp, lcp);\n}\n\nstatic __be32\nnfsd4_decode_layoutget(struct nfsd4_compoundargs *argp,\n\t\tunion nfsd4_op_u *u)\n{\n\tstruct nfsd4_layoutget *lgp = &u->layoutget;\n\t__be32 status;\n\n\tmemset(lgp, 0, sizeof(*lgp));\n\tif (xdr_stream_decode_u32(argp->xdr, &lgp->lg_signal) < 0)\n\t\treturn nfserr_bad_xdr;\n\tif (xdr_stream_decode_u32(argp->xdr, &lgp->lg_layout_type) < 0)\n\t\treturn nfserr_bad_xdr;\n\tif (xdr_stream_decode_u32(argp->xdr, &lgp->lg_seg.iomode) < 0)\n\t\treturn nfserr_bad_xdr;\n\tif (xdr_stream_decode_u64(argp->xdr, &lgp->lg_seg.offset) < 0)\n\t\treturn nfserr_bad_xdr;\n\tif (xdr_stream_decode_u64(argp->xdr, &lgp->lg_seg.length) < 0)\n\t\treturn nfserr_bad_xdr;\n\tif (xdr_stream_decode_u64(argp->xdr, &lgp->lg_minlength) < 0)\n\t\treturn nfserr_bad_xdr;\n\tstatus = nfsd4_decode_stateid4(argp, &lgp->lg_sid);\n\tif (status)\n\t\treturn status;\n\tif (xdr_stream_decode_u32(argp->xdr, &lgp->lg_maxcount) < 0)\n\t\treturn nfserr_bad_xdr;\n\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_decode_layoutreturn(struct nfsd4_compoundargs *argp,\n\t\tunion nfsd4_op_u *u)\n{\n\tstruct nfsd4_layoutreturn *lrp = &u->layoutreturn;\n\tmemset(lrp, 0, sizeof(*lrp));\n\tif (xdr_stream_decode_bool(argp->xdr, &lrp->lr_reclaim) < 0)\n\t\treturn nfserr_bad_xdr;\n\tif (xdr_stream_decode_u32(argp->xdr, &lrp->lr_layout_type) < 0)\n\t\treturn nfserr_bad_xdr;\n\tif (xdr_stream_decode_u32(argp->xdr, &lrp->lr_seg.iomode) < 0)\n\t\treturn nfserr_bad_xdr;\n\treturn nfsd4_decode_layoutreturn4(argp, lrp);\n}\n#endif  \n\nstatic __be32 nfsd4_decode_secinfo_no_name(struct nfsd4_compoundargs *argp,\n\t\t\t\t\t   union nfsd4_op_u *u)\n{\n\tstruct nfsd4_secinfo_no_name *sin = &u->secinfo_no_name;\n\tif (xdr_stream_decode_u32(argp->xdr, &sin->sin_style) < 0)\n\t\treturn nfserr_bad_xdr;\n\n\tsin->sin_exp = NULL;\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_decode_sequence(struct nfsd4_compoundargs *argp,\n\t\t      union nfsd4_op_u *u)\n{\n\tstruct nfsd4_sequence *seq = &u->sequence;\n\t__be32 *p, status;\n\n\tstatus = nfsd4_decode_sessionid4(argp, &seq->sessionid);\n\tif (status)\n\t\treturn status;\n\tp = xdr_inline_decode(argp->xdr, XDR_UNIT * 4);\n\tif (!p)\n\t\treturn nfserr_bad_xdr;\n\tseq->seqid = be32_to_cpup(p++);\n\tseq->slotid = be32_to_cpup(p++);\n\tseq->maxslots = be32_to_cpup(p++);\n\tseq->cachethis = be32_to_cpup(p);\n\n\tseq->status_flags = 0;\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_decode_test_stateid(struct nfsd4_compoundargs *argp,\n\t\t\t  union nfsd4_op_u *u)\n{\n\tstruct nfsd4_test_stateid *test_stateid = &u->test_stateid;\n\tstruct nfsd4_test_stateid_id *stateid;\n\t__be32 status;\n\tu32 i;\n\n\tmemset(test_stateid, 0, sizeof(*test_stateid));\n\tif (xdr_stream_decode_u32(argp->xdr, &test_stateid->ts_num_ids) < 0)\n\t\treturn nfserr_bad_xdr;\n\n\tINIT_LIST_HEAD(&test_stateid->ts_stateid_list);\n\tfor (i = 0; i < test_stateid->ts_num_ids; i++) {\n\t\tstateid = svcxdr_tmpalloc(argp, sizeof(*stateid));\n\t\tif (!stateid)\n\t\t\treturn nfserr_jukebox;\n\t\tINIT_LIST_HEAD(&stateid->ts_id_list);\n\t\tlist_add_tail(&stateid->ts_id_list, &test_stateid->ts_stateid_list);\n\t\tstatus = nfsd4_decode_stateid4(argp, &stateid->ts_id_stateid);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\n\treturn nfs_ok;\n}\n\nstatic __be32 nfsd4_decode_destroy_clientid(struct nfsd4_compoundargs *argp,\n\t\t\t\t\t    union nfsd4_op_u *u)\n{\n\tstruct nfsd4_destroy_clientid *dc = &u->destroy_clientid;\n\treturn nfsd4_decode_clientid4(argp, &dc->clientid);\n}\n\nstatic __be32 nfsd4_decode_reclaim_complete(struct nfsd4_compoundargs *argp,\n\t\t\t\t\t    union nfsd4_op_u *u)\n{\n\tstruct nfsd4_reclaim_complete *rc = &u->reclaim_complete;\n\tif (xdr_stream_decode_bool(argp->xdr, &rc->rca_one_fs) < 0)\n\t\treturn nfserr_bad_xdr;\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_decode_fallocate(struct nfsd4_compoundargs *argp,\n\t\t       union nfsd4_op_u *u)\n{\n\tstruct nfsd4_fallocate *fallocate = &u->allocate;\n\t__be32 status;\n\n\tstatus = nfsd4_decode_stateid4(argp, &fallocate->falloc_stateid);\n\tif (status)\n\t\treturn status;\n\tif (xdr_stream_decode_u64(argp->xdr, &fallocate->falloc_offset) < 0)\n\t\treturn nfserr_bad_xdr;\n\tif (xdr_stream_decode_u64(argp->xdr, &fallocate->falloc_length) < 0)\n\t\treturn nfserr_bad_xdr;\n\n\treturn nfs_ok;\n}\n\nstatic __be32 nfsd4_decode_nl4_server(struct nfsd4_compoundargs *argp,\n\t\t\t\t      struct nl4_server *ns)\n{\n\tstruct nfs42_netaddr *naddr;\n\t__be32 *p;\n\n\tif (xdr_stream_decode_u32(argp->xdr, &ns->nl4_type) < 0)\n\t\treturn nfserr_bad_xdr;\n\n\t \n\tswitch (ns->nl4_type) {\n\tcase NL4_NETADDR:\n\t\tnaddr = &ns->u.nl4_addr;\n\n\t\tif (xdr_stream_decode_u32(argp->xdr, &naddr->netid_len) < 0)\n\t\t\treturn nfserr_bad_xdr;\n\t\tif (naddr->netid_len > RPCBIND_MAXNETIDLEN)\n\t\t\treturn nfserr_bad_xdr;\n\n\t\tp = xdr_inline_decode(argp->xdr, naddr->netid_len);\n\t\tif (!p)\n\t\t\treturn nfserr_bad_xdr;\n\t\tmemcpy(naddr->netid, p, naddr->netid_len);\n\n\t\tif (xdr_stream_decode_u32(argp->xdr, &naddr->addr_len) < 0)\n\t\t\treturn nfserr_bad_xdr;\n\t\tif (naddr->addr_len > RPCBIND_MAXUADDRLEN)\n\t\t\treturn nfserr_bad_xdr;\n\n\t\tp = xdr_inline_decode(argp->xdr, naddr->addr_len);\n\t\tif (!p)\n\t\t\treturn nfserr_bad_xdr;\n\t\tmemcpy(naddr->addr, p, naddr->addr_len);\n\t\tbreak;\n\tdefault:\n\t\treturn nfserr_bad_xdr;\n\t}\n\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_decode_copy(struct nfsd4_compoundargs *argp, union nfsd4_op_u *u)\n{\n\tstruct nfsd4_copy *copy = &u->copy;\n\tu32 consecutive, i, count, sync;\n\tstruct nl4_server *ns_dummy;\n\t__be32 status;\n\n\tmemset(copy, 0, sizeof(*copy));\n\tstatus = nfsd4_decode_stateid4(argp, &copy->cp_src_stateid);\n\tif (status)\n\t\treturn status;\n\tstatus = nfsd4_decode_stateid4(argp, &copy->cp_dst_stateid);\n\tif (status)\n\t\treturn status;\n\tif (xdr_stream_decode_u64(argp->xdr, &copy->cp_src_pos) < 0)\n\t\treturn nfserr_bad_xdr;\n\tif (xdr_stream_decode_u64(argp->xdr, &copy->cp_dst_pos) < 0)\n\t\treturn nfserr_bad_xdr;\n\tif (xdr_stream_decode_u64(argp->xdr, &copy->cp_count) < 0)\n\t\treturn nfserr_bad_xdr;\n\t \n\tif (xdr_stream_decode_u32(argp->xdr, &consecutive) < 0)\n\t\treturn nfserr_bad_xdr;\n\tif (xdr_stream_decode_bool(argp->xdr, &sync) < 0)\n\t\treturn nfserr_bad_xdr;\n\tnfsd4_copy_set_sync(copy, sync);\n\n\tif (xdr_stream_decode_u32(argp->xdr, &count) < 0)\n\t\treturn nfserr_bad_xdr;\n\tcopy->cp_src = svcxdr_tmpalloc(argp, sizeof(*copy->cp_src));\n\tif (copy->cp_src == NULL)\n\t\treturn nfserr_jukebox;\n\tif (count == 0) {  \n\t\t__set_bit(NFSD4_COPY_F_INTRA, &copy->cp_flags);\n\t\treturn nfs_ok;\n\t}\n\n\t \n\tstatus = nfsd4_decode_nl4_server(argp, copy->cp_src);\n\tif (status)\n\t\treturn status;\n\n\tns_dummy = kmalloc(sizeof(struct nl4_server), GFP_KERNEL);\n\tif (ns_dummy == NULL)\n\t\treturn nfserr_jukebox;\n\tfor (i = 0; i < count - 1; i++) {\n\t\tstatus = nfsd4_decode_nl4_server(argp, ns_dummy);\n\t\tif (status) {\n\t\t\tkfree(ns_dummy);\n\t\t\treturn status;\n\t\t}\n\t}\n\tkfree(ns_dummy);\n\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_decode_copy_notify(struct nfsd4_compoundargs *argp,\n\t\t\t union nfsd4_op_u *u)\n{\n\tstruct nfsd4_copy_notify *cn = &u->copy_notify;\n\t__be32 status;\n\n\tmemset(cn, 0, sizeof(*cn));\n\tcn->cpn_src = svcxdr_tmpalloc(argp, sizeof(*cn->cpn_src));\n\tif (cn->cpn_src == NULL)\n\t\treturn nfserr_jukebox;\n\tcn->cpn_dst = svcxdr_tmpalloc(argp, sizeof(*cn->cpn_dst));\n\tif (cn->cpn_dst == NULL)\n\t\treturn nfserr_jukebox;\n\n\tstatus = nfsd4_decode_stateid4(argp, &cn->cpn_src_stateid);\n\tif (status)\n\t\treturn status;\n\treturn nfsd4_decode_nl4_server(argp, cn->cpn_dst);\n}\n\nstatic __be32\nnfsd4_decode_offload_status(struct nfsd4_compoundargs *argp,\n\t\t\t    union nfsd4_op_u *u)\n{\n\tstruct nfsd4_offload_status *os = &u->offload_status;\n\tos->count = 0;\n\tos->status = 0;\n\treturn nfsd4_decode_stateid4(argp, &os->stateid);\n}\n\nstatic __be32\nnfsd4_decode_seek(struct nfsd4_compoundargs *argp, union nfsd4_op_u *u)\n{\n\tstruct nfsd4_seek *seek = &u->seek;\n\t__be32 status;\n\n\tstatus = nfsd4_decode_stateid4(argp, &seek->seek_stateid);\n\tif (status)\n\t\treturn status;\n\tif (xdr_stream_decode_u64(argp->xdr, &seek->seek_offset) < 0)\n\t\treturn nfserr_bad_xdr;\n\tif (xdr_stream_decode_u32(argp->xdr, &seek->seek_whence) < 0)\n\t\treturn nfserr_bad_xdr;\n\n\tseek->seek_eof = 0;\n\tseek->seek_pos = 0;\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_decode_clone(struct nfsd4_compoundargs *argp, union nfsd4_op_u *u)\n{\n\tstruct nfsd4_clone *clone = &u->clone;\n\t__be32 status;\n\n\tstatus = nfsd4_decode_stateid4(argp, &clone->cl_src_stateid);\n\tif (status)\n\t\treturn status;\n\tstatus = nfsd4_decode_stateid4(argp, &clone->cl_dst_stateid);\n\tif (status)\n\t\treturn status;\n\tif (xdr_stream_decode_u64(argp->xdr, &clone->cl_src_pos) < 0)\n\t\treturn nfserr_bad_xdr;\n\tif (xdr_stream_decode_u64(argp->xdr, &clone->cl_dst_pos) < 0)\n\t\treturn nfserr_bad_xdr;\n\tif (xdr_stream_decode_u64(argp->xdr, &clone->cl_count) < 0)\n\t\treturn nfserr_bad_xdr;\n\n\treturn nfs_ok;\n}\n\n \n\n \nstatic __be32\nnfsd4_vbuf_from_vector(struct nfsd4_compoundargs *argp, struct xdr_buf *xdr,\n\t\t       char **bufp, u32 buflen)\n{\n\tstruct page **pages = xdr->pages;\n\tstruct kvec *head = xdr->head;\n\tchar *tmp, *dp;\n\tu32 len;\n\n\tif (buflen <= head->iov_len) {\n\t\t \n\t\t*bufp = head->iov_base;\n\t\treturn 0;\n\t}\n\n\ttmp = svcxdr_tmpalloc(argp, buflen);\n\tif (tmp == NULL)\n\t\treturn nfserr_jukebox;\n\n\tdp = tmp;\n\tmemcpy(dp, head->iov_base, head->iov_len);\n\tbuflen -= head->iov_len;\n\tdp += head->iov_len;\n\n\twhile (buflen > 0) {\n\t\tlen = min_t(u32, buflen, PAGE_SIZE);\n\t\tmemcpy(dp, page_address(*pages), len);\n\n\t\tbuflen -= len;\n\t\tdp += len;\n\t\tpages++;\n\t}\n\n\t*bufp = tmp;\n\treturn 0;\n}\n\n \nstatic __be32\nnfsd4_decode_xattr_name(struct nfsd4_compoundargs *argp, char **namep)\n{\n\tchar *name, *sp, *dp;\n\tu32 namelen, cnt;\n\t__be32 *p;\n\n\tif (xdr_stream_decode_u32(argp->xdr, &namelen) < 0)\n\t\treturn nfserr_bad_xdr;\n\tif (namelen > (XATTR_NAME_MAX - XATTR_USER_PREFIX_LEN))\n\t\treturn nfserr_nametoolong;\n\tif (namelen == 0)\n\t\treturn nfserr_bad_xdr;\n\tp = xdr_inline_decode(argp->xdr, namelen);\n\tif (!p)\n\t\treturn nfserr_bad_xdr;\n\tname = svcxdr_tmpalloc(argp, namelen + XATTR_USER_PREFIX_LEN + 1);\n\tif (!name)\n\t\treturn nfserr_jukebox;\n\tmemcpy(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN);\n\n\t \n\tsp = (char *)p;\n\tdp = name + XATTR_USER_PREFIX_LEN;\n\tcnt = namelen;\n\n\twhile (cnt-- > 0) {\n\t\tif (*sp == '\\0')\n\t\t\treturn nfserr_bad_xdr;\n\t\t*dp++ = *sp++;\n\t}\n\t*dp = '\\0';\n\n\t*namep = name;\n\n\treturn nfs_ok;\n}\n\n \nstatic __be32\nnfsd4_decode_getxattr(struct nfsd4_compoundargs *argp,\n\t\t      union nfsd4_op_u *u)\n{\n\tstruct nfsd4_getxattr *getxattr = &u->getxattr;\n\t__be32 status;\n\tu32 maxcount;\n\n\tmemset(getxattr, 0, sizeof(*getxattr));\n\tstatus = nfsd4_decode_xattr_name(argp, &getxattr->getxa_name);\n\tif (status)\n\t\treturn status;\n\n\tmaxcount = svc_max_payload(argp->rqstp);\n\tmaxcount = min_t(u32, XATTR_SIZE_MAX, maxcount);\n\n\tgetxattr->getxa_len = maxcount;\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_decode_setxattr(struct nfsd4_compoundargs *argp,\n\t\t      union nfsd4_op_u *u)\n{\n\tstruct nfsd4_setxattr *setxattr = &u->setxattr;\n\tu32 flags, maxcount, size;\n\t__be32 status;\n\n\tmemset(setxattr, 0, sizeof(*setxattr));\n\n\tif (xdr_stream_decode_u32(argp->xdr, &flags) < 0)\n\t\treturn nfserr_bad_xdr;\n\n\tif (flags > SETXATTR4_REPLACE)\n\t\treturn nfserr_inval;\n\tsetxattr->setxa_flags = flags;\n\n\tstatus = nfsd4_decode_xattr_name(argp, &setxattr->setxa_name);\n\tif (status)\n\t\treturn status;\n\n\tmaxcount = svc_max_payload(argp->rqstp);\n\tmaxcount = min_t(u32, XATTR_SIZE_MAX, maxcount);\n\n\tif (xdr_stream_decode_u32(argp->xdr, &size) < 0)\n\t\treturn nfserr_bad_xdr;\n\tif (size > maxcount)\n\t\treturn nfserr_xattr2big;\n\n\tsetxattr->setxa_len = size;\n\tif (size > 0) {\n\t\tstruct xdr_buf payload;\n\n\t\tif (!xdr_stream_subsegment(argp->xdr, &payload, size))\n\t\t\treturn nfserr_bad_xdr;\n\t\tstatus = nfsd4_vbuf_from_vector(argp, &payload,\n\t\t\t\t\t\t&setxattr->setxa_buf, size);\n\t}\n\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_decode_listxattrs(struct nfsd4_compoundargs *argp,\n\t\t\tunion nfsd4_op_u *u)\n{\n\tstruct nfsd4_listxattrs *listxattrs = &u->listxattrs;\n\tu32 maxcount;\n\n\tmemset(listxattrs, 0, sizeof(*listxattrs));\n\n\tif (xdr_stream_decode_u64(argp->xdr, &listxattrs->lsxa_cookie) < 0)\n\t\treturn nfserr_bad_xdr;\n\n\t \n\tif (listxattrs->lsxa_cookie >=\n\t    (XATTR_LIST_MAX / (XATTR_USER_PREFIX_LEN + 2)))\n\t\treturn nfserr_badcookie;\n\n\tif (xdr_stream_decode_u32(argp->xdr, &maxcount) < 0)\n\t\treturn nfserr_bad_xdr;\n\tif (maxcount < 8)\n\t\t \n\t\treturn nfserr_inval;\n\n\tmaxcount = min(maxcount, svc_max_payload(argp->rqstp));\n\tlistxattrs->lsxa_maxcount = maxcount;\n\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_decode_removexattr(struct nfsd4_compoundargs *argp,\n\t\t\t union nfsd4_op_u *u)\n{\n\tstruct nfsd4_removexattr *removexattr = &u->removexattr;\n\tmemset(removexattr, 0, sizeof(*removexattr));\n\treturn nfsd4_decode_xattr_name(argp, &removexattr->rmxa_name);\n}\n\nstatic __be32\nnfsd4_decode_noop(struct nfsd4_compoundargs *argp, union nfsd4_op_u *p)\n{\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_decode_notsupp(struct nfsd4_compoundargs *argp, union nfsd4_op_u *p)\n{\n\treturn nfserr_notsupp;\n}\n\ntypedef __be32(*nfsd4_dec)(struct nfsd4_compoundargs *argp, union nfsd4_op_u *u);\n\nstatic const nfsd4_dec nfsd4_dec_ops[] = {\n\t[OP_ACCESS]\t\t= nfsd4_decode_access,\n\t[OP_CLOSE]\t\t= nfsd4_decode_close,\n\t[OP_COMMIT]\t\t= nfsd4_decode_commit,\n\t[OP_CREATE]\t\t= nfsd4_decode_create,\n\t[OP_DELEGPURGE]\t\t= nfsd4_decode_notsupp,\n\t[OP_DELEGRETURN]\t= nfsd4_decode_delegreturn,\n\t[OP_GETATTR]\t\t= nfsd4_decode_getattr,\n\t[OP_GETFH]\t\t= nfsd4_decode_noop,\n\t[OP_LINK]\t\t= nfsd4_decode_link,\n\t[OP_LOCK]\t\t= nfsd4_decode_lock,\n\t[OP_LOCKT]\t\t= nfsd4_decode_lockt,\n\t[OP_LOCKU]\t\t= nfsd4_decode_locku,\n\t[OP_LOOKUP]\t\t= nfsd4_decode_lookup,\n\t[OP_LOOKUPP]\t\t= nfsd4_decode_noop,\n\t[OP_NVERIFY]\t\t= nfsd4_decode_verify,\n\t[OP_OPEN]\t\t= nfsd4_decode_open,\n\t[OP_OPENATTR]\t\t= nfsd4_decode_notsupp,\n\t[OP_OPEN_CONFIRM]\t= nfsd4_decode_open_confirm,\n\t[OP_OPEN_DOWNGRADE]\t= nfsd4_decode_open_downgrade,\n\t[OP_PUTFH]\t\t= nfsd4_decode_putfh,\n\t[OP_PUTPUBFH]\t\t= nfsd4_decode_putpubfh,\n\t[OP_PUTROOTFH]\t\t= nfsd4_decode_noop,\n\t[OP_READ]\t\t= nfsd4_decode_read,\n\t[OP_READDIR]\t\t= nfsd4_decode_readdir,\n\t[OP_READLINK]\t\t= nfsd4_decode_noop,\n\t[OP_REMOVE]\t\t= nfsd4_decode_remove,\n\t[OP_RENAME]\t\t= nfsd4_decode_rename,\n\t[OP_RENEW]\t\t= nfsd4_decode_renew,\n\t[OP_RESTOREFH]\t\t= nfsd4_decode_noop,\n\t[OP_SAVEFH]\t\t= nfsd4_decode_noop,\n\t[OP_SECINFO]\t\t= nfsd4_decode_secinfo,\n\t[OP_SETATTR]\t\t= nfsd4_decode_setattr,\n\t[OP_SETCLIENTID]\t= nfsd4_decode_setclientid,\n\t[OP_SETCLIENTID_CONFIRM] = nfsd4_decode_setclientid_confirm,\n\t[OP_VERIFY]\t\t= nfsd4_decode_verify,\n\t[OP_WRITE]\t\t= nfsd4_decode_write,\n\t[OP_RELEASE_LOCKOWNER]\t= nfsd4_decode_release_lockowner,\n\n\t \n\t[OP_BACKCHANNEL_CTL]\t= nfsd4_decode_backchannel_ctl,\n\t[OP_BIND_CONN_TO_SESSION] = nfsd4_decode_bind_conn_to_session,\n\t[OP_EXCHANGE_ID]\t= nfsd4_decode_exchange_id,\n\t[OP_CREATE_SESSION]\t= nfsd4_decode_create_session,\n\t[OP_DESTROY_SESSION]\t= nfsd4_decode_destroy_session,\n\t[OP_FREE_STATEID]\t= nfsd4_decode_free_stateid,\n\t[OP_GET_DIR_DELEGATION]\t= nfsd4_decode_notsupp,\n#ifdef CONFIG_NFSD_PNFS\n\t[OP_GETDEVICEINFO]\t= nfsd4_decode_getdeviceinfo,\n\t[OP_GETDEVICELIST]\t= nfsd4_decode_notsupp,\n\t[OP_LAYOUTCOMMIT]\t= nfsd4_decode_layoutcommit,\n\t[OP_LAYOUTGET]\t\t= nfsd4_decode_layoutget,\n\t[OP_LAYOUTRETURN]\t= nfsd4_decode_layoutreturn,\n#else\n\t[OP_GETDEVICEINFO]\t= nfsd4_decode_notsupp,\n\t[OP_GETDEVICELIST]\t= nfsd4_decode_notsupp,\n\t[OP_LAYOUTCOMMIT]\t= nfsd4_decode_notsupp,\n\t[OP_LAYOUTGET]\t\t= nfsd4_decode_notsupp,\n\t[OP_LAYOUTRETURN]\t= nfsd4_decode_notsupp,\n#endif\n\t[OP_SECINFO_NO_NAME]\t= nfsd4_decode_secinfo_no_name,\n\t[OP_SEQUENCE]\t\t= nfsd4_decode_sequence,\n\t[OP_SET_SSV]\t\t= nfsd4_decode_notsupp,\n\t[OP_TEST_STATEID]\t= nfsd4_decode_test_stateid,\n\t[OP_WANT_DELEGATION]\t= nfsd4_decode_notsupp,\n\t[OP_DESTROY_CLIENTID]\t= nfsd4_decode_destroy_clientid,\n\t[OP_RECLAIM_COMPLETE]\t= nfsd4_decode_reclaim_complete,\n\n\t \n\t[OP_ALLOCATE]\t\t= nfsd4_decode_fallocate,\n\t[OP_COPY]\t\t= nfsd4_decode_copy,\n\t[OP_COPY_NOTIFY]\t= nfsd4_decode_copy_notify,\n\t[OP_DEALLOCATE]\t\t= nfsd4_decode_fallocate,\n\t[OP_IO_ADVISE]\t\t= nfsd4_decode_notsupp,\n\t[OP_LAYOUTERROR]\t= nfsd4_decode_notsupp,\n\t[OP_LAYOUTSTATS]\t= nfsd4_decode_notsupp,\n\t[OP_OFFLOAD_CANCEL]\t= nfsd4_decode_offload_status,\n\t[OP_OFFLOAD_STATUS]\t= nfsd4_decode_offload_status,\n\t[OP_READ_PLUS]\t\t= nfsd4_decode_read,\n\t[OP_SEEK]\t\t= nfsd4_decode_seek,\n\t[OP_WRITE_SAME]\t\t= nfsd4_decode_notsupp,\n\t[OP_CLONE]\t\t= nfsd4_decode_clone,\n\t \n\t[OP_GETXATTR]\t\t= nfsd4_decode_getxattr,\n\t[OP_SETXATTR]\t\t= nfsd4_decode_setxattr,\n\t[OP_LISTXATTRS]\t\t= nfsd4_decode_listxattrs,\n\t[OP_REMOVEXATTR]\t= nfsd4_decode_removexattr,\n};\n\nstatic inline bool\nnfsd4_opnum_in_range(struct nfsd4_compoundargs *argp, struct nfsd4_op *op)\n{\n\tif (op->opnum < FIRST_NFS4_OP)\n\t\treturn false;\n\telse if (argp->minorversion == 0 && op->opnum > LAST_NFS40_OP)\n\t\treturn false;\n\telse if (argp->minorversion == 1 && op->opnum > LAST_NFS41_OP)\n\t\treturn false;\n\telse if (argp->minorversion == 2 && op->opnum > LAST_NFS42_OP)\n\t\treturn false;\n\treturn true;\n}\n\nstatic bool\nnfsd4_decode_compound(struct nfsd4_compoundargs *argp)\n{\n\tstruct nfsd4_op *op;\n\tbool cachethis = false;\n\tint auth_slack= argp->rqstp->rq_auth_slack;\n\tint max_reply = auth_slack + 8;  \n\tint readcount = 0;\n\tint readbytes = 0;\n\t__be32 *p;\n\tint i;\n\n\tif (xdr_stream_decode_u32(argp->xdr, &argp->taglen) < 0)\n\t\treturn false;\n\tmax_reply += XDR_UNIT;\n\targp->tag = NULL;\n\tif (unlikely(argp->taglen)) {\n\t\tif (argp->taglen > NFSD4_MAX_TAGLEN)\n\t\t\treturn false;\n\t\tp = xdr_inline_decode(argp->xdr, argp->taglen);\n\t\tif (!p)\n\t\t\treturn false;\n\t\targp->tag = svcxdr_savemem(argp, p, argp->taglen);\n\t\tif (!argp->tag)\n\t\t\treturn false;\n\t\tmax_reply += xdr_align_size(argp->taglen);\n\t}\n\n\tif (xdr_stream_decode_u32(argp->xdr, &argp->minorversion) < 0)\n\t\treturn false;\n\tif (xdr_stream_decode_u32(argp->xdr, &argp->client_opcnt) < 0)\n\t\treturn false;\n\targp->opcnt = min_t(u32, argp->client_opcnt,\n\t\t\t    NFSD_MAX_OPS_PER_COMPOUND);\n\n\tif (argp->opcnt > ARRAY_SIZE(argp->iops)) {\n\t\targp->ops = vcalloc(argp->opcnt, sizeof(*argp->ops));\n\t\tif (!argp->ops) {\n\t\t\targp->ops = argp->iops;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (argp->minorversion > NFSD_SUPPORTED_MINOR_VERSION)\n\t\targp->opcnt = 0;\n\n\tfor (i = 0; i < argp->opcnt; i++) {\n\t\top = &argp->ops[i];\n\t\top->replay = NULL;\n\t\top->opdesc = NULL;\n\n\t\tif (xdr_stream_decode_u32(argp->xdr, &op->opnum) < 0)\n\t\t\treturn false;\n\t\tif (nfsd4_opnum_in_range(argp, op)) {\n\t\t\top->opdesc = OPDESC(op);\n\t\t\top->status = nfsd4_dec_ops[op->opnum](argp, &op->u);\n\t\t\tif (op->status != nfs_ok)\n\t\t\t\ttrace_nfsd_compound_decode_err(argp->rqstp,\n\t\t\t\t\t\t\t       argp->opcnt, i,\n\t\t\t\t\t\t\t       op->opnum,\n\t\t\t\t\t\t\t       op->status);\n\t\t} else {\n\t\t\top->opnum = OP_ILLEGAL;\n\t\t\top->status = nfserr_op_illegal;\n\t\t}\n\n\t\t \n\t\tcachethis |= nfsd4_cache_this_op(op);\n\n\t\tif (op->opnum == OP_READ || op->opnum == OP_READ_PLUS) {\n\t\t\treadcount++;\n\t\t\treadbytes += nfsd4_max_reply(argp->rqstp, op);\n\t\t} else\n\t\t\tmax_reply += nfsd4_max_reply(argp->rqstp, op);\n\t\t \n\t\tif (op->opnum == OP_LOCK || op->opnum == OP_LOCKT)\n\t\t\tmax_reply += NFS4_OPAQUE_LIMIT;\n\n\t\tif (op->status) {\n\t\t\targp->opcnt = i+1;\n\t\t\tbreak;\n\t\t}\n\t}\n\t \n\tif (argp->minorversion)\n\t\tcachethis = false;\n\tsvc_reserve(argp->rqstp, max_reply + readbytes);\n\targp->rqstp->rq_cachetype = cachethis ? RC_REPLBUFF : RC_NOCACHE;\n\n\tif (readcount > 1 || max_reply > PAGE_SIZE - auth_slack)\n\t\tclear_bit(RQ_SPLICE_OK, &argp->rqstp->rq_flags);\n\n\treturn true;\n}\n\nstatic __be32 *encode_change(__be32 *p, struct kstat *stat, struct inode *inode,\n\t\t\t     struct svc_export *exp)\n{\n\tif (exp->ex_flags & NFSEXP_V4ROOT) {\n\t\t*p++ = cpu_to_be32(convert_to_wallclock(exp->cd->flush_time));\n\t\t*p++ = 0;\n\t} else\n\t\tp = xdr_encode_hyper(p, nfsd4_change_attribute(stat, inode));\n\treturn p;\n}\n\nstatic __be32 nfsd4_encode_nfstime4(struct xdr_stream *xdr,\n\t\t\t\t    struct timespec64 *tv)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, XDR_UNIT * 3);\n\tif (!p)\n\t\treturn nfserr_resource;\n\n\tp = xdr_encode_hyper(p, (s64)tv->tv_sec);\n\t*p = cpu_to_be32(tv->tv_nsec);\n\treturn nfs_ok;\n}\n\n \nstatic __be32 *encode_time_delta(__be32 *p, struct inode *inode)\n{\n\tstruct timespec64 ts;\n\tu32 ns;\n\n\tns = max_t(u32, NSEC_PER_SEC/HZ, inode->i_sb->s_time_gran);\n\tts = ns_to_timespec64(ns);\n\n\tp = xdr_encode_hyper(p, ts.tv_sec);\n\t*p++ = cpu_to_be32(ts.tv_nsec);\n\n\treturn p;\n}\n\nstatic __be32\nnfsd4_encode_change_info4(struct xdr_stream *xdr, struct nfsd4_change_info *c)\n{\n\tif (xdr_stream_encode_bool(xdr, c->atomic) < 0)\n\t\treturn nfserr_resource;\n\tif (xdr_stream_encode_u64(xdr, c->before_change) < 0)\n\t\treturn nfserr_resource;\n\tif (xdr_stream_encode_u64(xdr, c->after_change) < 0)\n\t\treturn nfserr_resource;\n\treturn nfs_ok;\n}\n\n \nstatic __be32 nfsd4_encode_components_esc(struct xdr_stream *xdr, char sep,\n\t\t\t\t\t  char *components, char esc_enter,\n\t\t\t\t\t  char esc_exit)\n{\n\t__be32 *p;\n\t__be32 pathlen;\n\tint pathlen_offset;\n\tint strlen, count=0;\n\tchar *str, *end, *next;\n\n\tdprintk(\"nfsd4_encode_components(%s)\\n\", components);\n\n\tpathlen_offset = xdr->buf->len;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\treturn nfserr_resource;\n\tp++;  \n\n\tend = str = components;\n\twhile (*end) {\n\t\tbool found_esc = false;\n\n\t\t \n\t\tif (*str == esc_enter) {\n\t\t\tfor (; *end && (*end != esc_exit); end++)\n\t\t\t\t ;\n\t\t\tnext = end + 1;\n\t\t\tif (*end && (!*next || *next == sep)) {\n\t\t\t\tstr++;\n\t\t\t\tfound_esc = true;\n\t\t\t}\n\t\t}\n\n\t\tif (!found_esc)\n\t\t\tfor (; *end && (*end != sep); end++)\n\t\t\t\t ;\n\n\t\tstrlen = end - str;\n\t\tif (strlen) {\n\t\t\tp = xdr_reserve_space(xdr, strlen + 4);\n\t\t\tif (!p)\n\t\t\t\treturn nfserr_resource;\n\t\t\tp = xdr_encode_opaque(p, str, strlen);\n\t\t\tcount++;\n\t\t}\n\t\telse\n\t\t\tend++;\n\t\tif (found_esc)\n\t\t\tend = next;\n\n\t\tstr = end;\n\t}\n\tpathlen = htonl(count);\n\twrite_bytes_to_xdr_buf(xdr->buf, pathlen_offset, &pathlen, 4);\n\treturn 0;\n}\n\n \nstatic __be32 nfsd4_encode_components(struct xdr_stream *xdr, char sep,\n\t\t\t\t      char *components)\n{\n\treturn nfsd4_encode_components_esc(xdr, sep, components, 0, 0);\n}\n\n \nstatic __be32 nfsd4_encode_fs_location4(struct xdr_stream *xdr,\n\t\t\t\t\tstruct nfsd4_fs_location *location)\n{\n\t__be32 status;\n\n\tstatus = nfsd4_encode_components_esc(xdr, ':', location->hosts,\n\t\t\t\t\t\t'[', ']');\n\tif (status)\n\t\treturn status;\n\tstatus = nfsd4_encode_components(xdr, '/', location->path);\n\tif (status)\n\t\treturn status;\n\treturn 0;\n}\n\n \nstatic __be32 nfsd4_encode_path(struct xdr_stream *xdr,\n\t\t\t\tconst struct path *root,\n\t\t\t\tconst struct path *path)\n{\n\tstruct path cur = *path;\n\t__be32 *p;\n\tstruct dentry **components = NULL;\n\tunsigned int ncomponents = 0;\n\t__be32 err = nfserr_jukebox;\n\n\tdprintk(\"nfsd4_encode_components(\");\n\n\tpath_get(&cur);\n\t \n\tfor (;;) {\n\t\tif (path_equal(&cur, root))\n\t\t\tbreak;\n\t\tif (cur.dentry == cur.mnt->mnt_root) {\n\t\t\tif (follow_up(&cur))\n\t\t\t\tcontinue;\n\t\t\tgoto out_free;\n\t\t}\n\t\tif ((ncomponents & 15) == 0) {\n\t\t\tstruct dentry **new;\n\t\t\tnew = krealloc(components,\n\t\t\t\t\tsizeof(*new) * (ncomponents + 16),\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!new)\n\t\t\t\tgoto out_free;\n\t\t\tcomponents = new;\n\t\t}\n\t\tcomponents[ncomponents++] = cur.dentry;\n\t\tcur.dentry = dget_parent(cur.dentry);\n\t}\n\terr = nfserr_resource;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\tgoto out_free;\n\t*p++ = cpu_to_be32(ncomponents);\n\n\twhile (ncomponents) {\n\t\tstruct dentry *dentry = components[ncomponents - 1];\n\t\tunsigned int len;\n\n\t\tspin_lock(&dentry->d_lock);\n\t\tlen = dentry->d_name.len;\n\t\tp = xdr_reserve_space(xdr, len + 4);\n\t\tif (!p) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tgoto out_free;\n\t\t}\n\t\tp = xdr_encode_opaque(p, dentry->d_name.name, len);\n\t\tdprintk(\"/%pd\", dentry);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tdput(dentry);\n\t\tncomponents--;\n\t}\n\n\terr = 0;\nout_free:\n\tdprintk(\")\\n\");\n\twhile (ncomponents)\n\t\tdput(components[--ncomponents]);\n\tkfree(components);\n\tpath_put(&cur);\n\treturn err;\n}\n\nstatic __be32 nfsd4_encode_fsloc_fsroot(struct xdr_stream *xdr,\n\t\t\tstruct svc_rqst *rqstp, const struct path *path)\n{\n\tstruct svc_export *exp_ps;\n\t__be32 res;\n\n\texp_ps = rqst_find_fsidzero_export(rqstp);\n\tif (IS_ERR(exp_ps))\n\t\treturn nfserrno(PTR_ERR(exp_ps));\n\tres = nfsd4_encode_path(xdr, &exp_ps->ex_path, path);\n\texp_put(exp_ps);\n\treturn res;\n}\n\n \nstatic __be32 nfsd4_encode_fs_locations(struct xdr_stream *xdr,\n\t\t\tstruct svc_rqst *rqstp, struct svc_export *exp)\n{\n\t__be32 status;\n\tint i;\n\t__be32 *p;\n\tstruct nfsd4_fs_locations *fslocs = &exp->ex_fslocs;\n\n\tstatus = nfsd4_encode_fsloc_fsroot(xdr, rqstp, &exp->ex_path);\n\tif (status)\n\t\treturn status;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(fslocs->locations_count);\n\tfor (i=0; i<fslocs->locations_count; i++) {\n\t\tstatus = nfsd4_encode_fs_location4(xdr, &fslocs->locations[i]);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\treturn 0;\n}\n\nstatic u32 nfs4_file_type(umode_t mode)\n{\n\tswitch (mode & S_IFMT) {\n\tcase S_IFIFO:\treturn NF4FIFO;\n\tcase S_IFCHR:\treturn NF4CHR;\n\tcase S_IFDIR:\treturn NF4DIR;\n\tcase S_IFBLK:\treturn NF4BLK;\n\tcase S_IFLNK:\treturn NF4LNK;\n\tcase S_IFREG:\treturn NF4REG;\n\tcase S_IFSOCK:\treturn NF4SOCK;\n\tdefault:\treturn NF4BAD;\n\t}\n}\n\nstatic inline __be32\nnfsd4_encode_aclname(struct xdr_stream *xdr, struct svc_rqst *rqstp,\n\t\t     struct nfs4_ace *ace)\n{\n\tif (ace->whotype != NFS4_ACL_WHO_NAMED)\n\t\treturn nfs4_acl_write_who(xdr, ace->whotype);\n\telse if (ace->flag & NFS4_ACE_IDENTIFIER_GROUP)\n\t\treturn nfsd4_encode_group(xdr, rqstp, ace->who_gid);\n\telse\n\t\treturn nfsd4_encode_user(xdr, rqstp, ace->who_uid);\n}\n\nstatic inline __be32\nnfsd4_encode_layout_types(struct xdr_stream *xdr, u32 layout_types)\n{\n\t__be32\t\t*p;\n\tunsigned long\ti = hweight_long(layout_types);\n\n\tp = xdr_reserve_space(xdr, 4 + 4 * i);\n\tif (!p)\n\t\treturn nfserr_resource;\n\n\t*p++ = cpu_to_be32(i);\n\n\tfor (i = LAYOUT_NFSV4_1_FILES; i < LAYOUT_TYPE_MAX; ++i)\n\t\tif (layout_types & (1 << i))\n\t\t\t*p++ = cpu_to_be32(i);\n\n\treturn 0;\n}\n\n#define WORD0_ABSENT_FS_ATTRS (FATTR4_WORD0_FS_LOCATIONS | FATTR4_WORD0_FSID | \\\n\t\t\t      FATTR4_WORD0_RDATTR_ERROR)\n#define WORD1_ABSENT_FS_ATTRS FATTR4_WORD1_MOUNTED_ON_FILEID\n#define WORD2_ABSENT_FS_ATTRS 0\n\n#ifdef CONFIG_NFSD_V4_SECURITY_LABEL\nstatic inline __be32\nnfsd4_encode_security_label(struct xdr_stream *xdr, struct svc_rqst *rqstp,\n\t\t\t    void *context, int len)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, len + 4 + 4 + 4);\n\tif (!p)\n\t\treturn nfserr_resource;\n\n\t \n\t*p++ = cpu_to_be32(0);  \n\t*p++ = cpu_to_be32(0);  \n\tp = xdr_encode_opaque(p, context, len);\n\treturn 0;\n}\n#else\nstatic inline __be32\nnfsd4_encode_security_label(struct xdr_stream *xdr, struct svc_rqst *rqstp,\n\t\t\t    void *context, int len)\n{ return 0; }\n#endif\n\nstatic __be32 fattr_handle_absent_fs(u32 *bmval0, u32 *bmval1, u32 *bmval2, u32 *rdattr_err)\n{\n\t \n\tif (*bmval0 & ~WORD0_ABSENT_FS_ATTRS ||\n\t    *bmval1 & ~WORD1_ABSENT_FS_ATTRS) {\n\t\tif (*bmval0 & FATTR4_WORD0_RDATTR_ERROR ||\n\t            *bmval0 & FATTR4_WORD0_FS_LOCATIONS)\n\t\t\t*rdattr_err = NFSERR_MOVED;\n\t\telse\n\t\t\treturn nfserr_moved;\n\t}\n\t*bmval0 &= WORD0_ABSENT_FS_ATTRS;\n\t*bmval1 &= WORD1_ABSENT_FS_ATTRS;\n\t*bmval2 &= WORD2_ABSENT_FS_ATTRS;\n\treturn 0;\n}\n\n\nstatic int nfsd4_get_mounted_on_ino(struct svc_export *exp, u64 *pino)\n{\n\tstruct path path = exp->ex_path;\n\tstruct kstat stat;\n\tint err;\n\n\tpath_get(&path);\n\twhile (follow_up(&path)) {\n\t\tif (path.dentry != path.mnt->mnt_root)\n\t\t\tbreak;\n\t}\n\terr = vfs_getattr(&path, &stat, STATX_INO, AT_STATX_SYNC_AS_STAT);\n\tpath_put(&path);\n\tif (!err)\n\t\t*pino = stat.ino;\n\treturn err;\n}\n\nstatic __be32\nnfsd4_encode_bitmap(struct xdr_stream *xdr, u32 bmval0, u32 bmval1, u32 bmval2)\n{\n\t__be32 *p;\n\n\tif (bmval2) {\n\t\tp = xdr_reserve_space(xdr, 16);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(3);\n\t\t*p++ = cpu_to_be32(bmval0);\n\t\t*p++ = cpu_to_be32(bmval1);\n\t\t*p++ = cpu_to_be32(bmval2);\n\t} else if (bmval1) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(2);\n\t\t*p++ = cpu_to_be32(bmval0);\n\t\t*p++ = cpu_to_be32(bmval1);\n\t} else {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t\t*p++ = cpu_to_be32(bmval0);\n\t}\n\n\treturn 0;\nout_resource:\n\treturn nfserr_resource;\n}\n\n \nstatic __be32\nnfsd4_encode_fattr(struct xdr_stream *xdr, struct svc_fh *fhp,\n\t\tstruct svc_export *exp,\n\t\tstruct dentry *dentry, u32 *bmval,\n\t\tstruct svc_rqst *rqstp, int ignore_crossmnt)\n{\n\tu32 bmval0 = bmval[0];\n\tu32 bmval1 = bmval[1];\n\tu32 bmval2 = bmval[2];\n\tstruct kstat stat;\n\tstruct svc_fh *tempfh = NULL;\n\tstruct kstatfs statfs;\n\t__be32 *p, *attrlen_p;\n\tint starting_len = xdr->buf->len;\n\tint attrlen_offset;\n\tu32 dummy;\n\tu64 dummy64;\n\tu32 rdattr_err = 0;\n\t__be32 status;\n\tint err;\n\tstruct nfs4_acl *acl = NULL;\n#ifdef CONFIG_NFSD_V4_SECURITY_LABEL\n\tvoid *context = NULL;\n\tint contextlen;\n#endif\n\tbool contextsupport = false;\n\tstruct nfsd4_compoundres *resp = rqstp->rq_resp;\n\tu32 minorversion = resp->cstate.minorversion;\n\tstruct path path = {\n\t\t.mnt\t= exp->ex_path.mnt,\n\t\t.dentry\t= dentry,\n\t};\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tBUG_ON(bmval1 & NFSD_WRITEONLY_ATTRS_WORD1);\n\tBUG_ON(!nfsd_attrs_supported(minorversion, bmval));\n\n\tif (exp->ex_fslocs.migrated) {\n\t\tstatus = fattr_handle_absent_fs(&bmval0, &bmval1, &bmval2, &rdattr_err);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval0 & (FATTR4_WORD0_CHANGE | FATTR4_WORD0_SIZE)) {\n\t\tstatus = nfsd4_deleg_getattr_conflict(rqstp, d_inode(dentry));\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\terr = vfs_getattr(&path, &stat,\n\t\t\t  STATX_BASIC_STATS | STATX_BTIME | STATX_CHANGE_COOKIE,\n\t\t\t  AT_STATX_SYNC_AS_STAT);\n\tif (err)\n\t\tgoto out_nfserr;\n\tif (!(stat.result_mask & STATX_BTIME))\n\t\t \n\t\tbmval1 &= ~FATTR4_WORD1_TIME_CREATE;\n\tif ((bmval0 & (FATTR4_WORD0_FILES_AVAIL | FATTR4_WORD0_FILES_FREE |\n\t\t\tFATTR4_WORD0_FILES_TOTAL | FATTR4_WORD0_MAXNAME)) ||\n\t    (bmval1 & (FATTR4_WORD1_SPACE_AVAIL | FATTR4_WORD1_SPACE_FREE |\n\t\t       FATTR4_WORD1_SPACE_TOTAL))) {\n\t\terr = vfs_statfs(&path, &statfs);\n\t\tif (err)\n\t\t\tgoto out_nfserr;\n\t}\n\tif ((bmval0 & (FATTR4_WORD0_FILEHANDLE | FATTR4_WORD0_FSID)) && !fhp) {\n\t\ttempfh = kmalloc(sizeof(struct svc_fh), GFP_KERNEL);\n\t\tstatus = nfserr_jukebox;\n\t\tif (!tempfh)\n\t\t\tgoto out;\n\t\tfh_init(tempfh, NFS4_FHSIZE);\n\t\tstatus = fh_compose(tempfh, exp, dentry, NULL);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tfhp = tempfh;\n\t}\n\tif (bmval0 & FATTR4_WORD0_ACL) {\n\t\terr = nfsd4_get_nfs4_acl(rqstp, dentry, &acl);\n\t\tif (err == -EOPNOTSUPP)\n\t\t\tbmval0 &= ~FATTR4_WORD0_ACL;\n\t\telse if (err == -EINVAL) {\n\t\t\tstatus = nfserr_attrnotsupp;\n\t\t\tgoto out;\n\t\t} else if (err != 0)\n\t\t\tgoto out_nfserr;\n\t}\n\n#ifdef CONFIG_NFSD_V4_SECURITY_LABEL\n\tif ((bmval2 & FATTR4_WORD2_SECURITY_LABEL) ||\n\t     bmval0 & FATTR4_WORD0_SUPPORTED_ATTRS) {\n\t\tif (exp->ex_flags & NFSEXP_SECURITY_LABEL)\n\t\t\terr = security_inode_getsecctx(d_inode(dentry),\n\t\t\t\t\t\t&context, &contextlen);\n\t\telse\n\t\t\terr = -EOPNOTSUPP;\n\t\tcontextsupport = (err == 0);\n\t\tif (bmval2 & FATTR4_WORD2_SECURITY_LABEL) {\n\t\t\tif (err == -EOPNOTSUPP)\n\t\t\t\tbmval2 &= ~FATTR4_WORD2_SECURITY_LABEL;\n\t\t\telse if (err)\n\t\t\t\tgoto out_nfserr;\n\t\t}\n\t}\n#endif  \n\n\tstatus = nfsd4_encode_bitmap(xdr, bmval0, bmval1, bmval2);\n\tif (status)\n\t\tgoto out;\n\n\tattrlen_offset = xdr->buf->len;\n\tattrlen_p = xdr_reserve_space(xdr, XDR_UNIT);\n\tif (!attrlen_p)\n\t\tgoto out_resource;\n\n\tif (bmval0 & FATTR4_WORD0_SUPPORTED_ATTRS) {\n\t\tu32 supp[3];\n\n\t\tmemcpy(supp, nfsd_suppattrs[minorversion], sizeof(supp));\n\n\t\tif (!IS_POSIXACL(dentry->d_inode))\n\t\t\tsupp[0] &= ~FATTR4_WORD0_ACL;\n\t\tif (!contextsupport)\n\t\t\tsupp[2] &= ~FATTR4_WORD2_SECURITY_LABEL;\n\t\tif (!supp[2]) {\n\t\t\tp = xdr_reserve_space(xdr, 12);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(2);\n\t\t\t*p++ = cpu_to_be32(supp[0]);\n\t\t\t*p++ = cpu_to_be32(supp[1]);\n\t\t} else {\n\t\t\tp = xdr_reserve_space(xdr, 16);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(3);\n\t\t\t*p++ = cpu_to_be32(supp[0]);\n\t\t\t*p++ = cpu_to_be32(supp[1]);\n\t\t\t*p++ = cpu_to_be32(supp[2]);\n\t\t}\n\t}\n\tif (bmval0 & FATTR4_WORD0_TYPE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy = nfs4_file_type(stat.mode);\n\t\tif (dummy == NF4BAD) {\n\t\t\tstatus = nfserr_serverfault;\n\t\t\tgoto out;\n\t\t}\n\t\t*p++ = cpu_to_be32(dummy);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FH_EXPIRE_TYPE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tif (exp->ex_flags & NFSEXP_NOSUBTREECHECK)\n\t\t\t*p++ = cpu_to_be32(NFS4_FH_PERSISTENT);\n\t\telse\n\t\t\t*p++ = cpu_to_be32(NFS4_FH_PERSISTENT|\n\t\t\t\t\t\tNFS4_FH_VOL_RENAME);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CHANGE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = encode_change(p, &stat, d_inode(dentry), exp);\n\t}\n\tif (bmval0 & FATTR4_WORD0_SIZE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, stat.size);\n\t}\n\tif (bmval0 & FATTR4_WORD0_LINK_SUPPORT) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_SYMLINK_SUPPORT) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_NAMED_ATTR) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FSID) {\n\t\tp = xdr_reserve_space(xdr, 16);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tif (exp->ex_fslocs.migrated) {\n\t\t\tp = xdr_encode_hyper(p, NFS4_REFERRAL_FSID_MAJOR);\n\t\t\tp = xdr_encode_hyper(p, NFS4_REFERRAL_FSID_MINOR);\n\t\t} else switch(fsid_source(fhp)) {\n\t\tcase FSIDSOURCE_FSID:\n\t\t\tp = xdr_encode_hyper(p, (u64)exp->ex_fsid);\n\t\t\tp = xdr_encode_hyper(p, (u64)0);\n\t\t\tbreak;\n\t\tcase FSIDSOURCE_DEV:\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t\t*p++ = cpu_to_be32(MAJOR(stat.dev));\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t\t*p++ = cpu_to_be32(MINOR(stat.dev));\n\t\t\tbreak;\n\t\tcase FSIDSOURCE_UUID:\n\t\t\tp = xdr_encode_opaque_fixed(p, exp->ex_uuid,\n\t\t\t\t\t\t\t\tEX_UUID_LEN);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (bmval0 & FATTR4_WORD0_UNIQUE_HANDLES) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_LEASE_TIME) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(nn->nfsd4_lease);\n\t}\n\tif (bmval0 & FATTR4_WORD0_RDATTR_ERROR) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(rdattr_err);\n\t}\n\tif (bmval0 & FATTR4_WORD0_ACL) {\n\t\tstruct nfs4_ace *ace;\n\n\t\tif (acl == NULL) {\n\t\t\tp = xdr_reserve_space(xdr, 4);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t\tgoto out_acl;\n\t\t}\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(acl->naces);\n\n\t\tfor (ace = acl->aces; ace < acl->aces + acl->naces; ace++) {\n\t\t\tp = xdr_reserve_space(xdr, 4*3);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(ace->type);\n\t\t\t*p++ = cpu_to_be32(ace->flag);\n\t\t\t*p++ = cpu_to_be32(ace->access_mask &\n\t\t\t\t\t\t\tNFS4_ACE_MASK_ALL);\n\t\t\tstatus = nfsd4_encode_aclname(xdr, rqstp, ace);\n\t\t\tif (status)\n\t\t\t\tgoto out;\n\t\t}\n\t}\nout_acl:\n\tif (bmval0 & FATTR4_WORD0_ACLSUPPORT) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(IS_POSIXACL(dentry->d_inode) ?\n\t\t\tACL4_SUPPORT_ALLOW_ACL|ACL4_SUPPORT_DENY_ACL : 0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CANSETTIME) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CASE_INSENSITIVE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CASE_PRESERVING) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CHOWN_RESTRICTED) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILEHANDLE) {\n\t\tp = xdr_reserve_space(xdr, fhp->fh_handle.fh_size + 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_opaque(p, &fhp->fh_handle.fh_raw,\n\t\t\t\t\tfhp->fh_handle.fh_size);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILEID) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, stat.ino);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILES_AVAIL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) statfs.f_ffree);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILES_FREE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) statfs.f_ffree);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILES_TOTAL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) statfs.f_files);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FS_LOCATIONS) {\n\t\tstatus = nfsd4_encode_fs_locations(xdr, rqstp, exp);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval0 & FATTR4_WORD0_HOMOGENEOUS) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXFILESIZE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, exp->ex_path.mnt->mnt_sb->s_maxbytes);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXLINK) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(255);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXNAME) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(statfs.f_namelen);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXREAD) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) svc_max_payload(rqstp));\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXWRITE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) svc_max_payload(rqstp));\n\t}\n\tif (bmval1 & FATTR4_WORD1_MODE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(stat.mode & S_IALLUGO);\n\t}\n\tif (bmval1 & FATTR4_WORD1_NO_TRUNC) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval1 & FATTR4_WORD1_NUMLINKS) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(stat.nlink);\n\t}\n\tif (bmval1 & FATTR4_WORD1_OWNER) {\n\t\tstatus = nfsd4_encode_user(xdr, rqstp, stat.uid);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval1 & FATTR4_WORD1_OWNER_GROUP) {\n\t\tstatus = nfsd4_encode_group(xdr, rqstp, stat.gid);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval1 & FATTR4_WORD1_RAWDEV) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32((u32) MAJOR(stat.rdev));\n\t\t*p++ = cpu_to_be32((u32) MINOR(stat.rdev));\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_AVAIL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)statfs.f_bavail * (u64)statfs.f_bsize;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_FREE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)statfs.f_bfree * (u64)statfs.f_bsize;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_TOTAL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)statfs.f_blocks * (u64)statfs.f_bsize;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_USED) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)stat.blocks << 9;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_ACCESS) {\n\t\tstatus = nfsd4_encode_nfstime4(xdr, &stat.atime);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_CREATE) {\n\t\tstatus = nfsd4_encode_nfstime4(xdr, &stat.btime);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_DELTA) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = encode_time_delta(p, d_inode(dentry));\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_METADATA) {\n\t\tstatus = nfsd4_encode_nfstime4(xdr, &stat.ctime);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_MODIFY) {\n\t\tstatus = nfsd4_encode_nfstime4(xdr, &stat.mtime);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval1 & FATTR4_WORD1_MOUNTED_ON_FILEID) {\n\t\tu64 ino = stat.ino;\n\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n                \tgoto out_resource;\n\t\t \n\t\tif (ignore_crossmnt == 0 &&\n\t\t    dentry == exp->ex_path.mnt->mnt_root) {\n\t\t\terr = nfsd4_get_mounted_on_ino(exp, &ino);\n\t\t\tif (err)\n\t\t\t\tgoto out_nfserr;\n\t\t}\n\t\tp = xdr_encode_hyper(p, ino);\n\t}\n#ifdef CONFIG_NFSD_PNFS\n\tif (bmval1 & FATTR4_WORD1_FS_LAYOUT_TYPES) {\n\t\tstatus = nfsd4_encode_layout_types(xdr, exp->ex_layout_types);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\tif (bmval2 & FATTR4_WORD2_LAYOUT_TYPES) {\n\t\tstatus = nfsd4_encode_layout_types(xdr, exp->ex_layout_types);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\tif (bmval2 & FATTR4_WORD2_LAYOUT_BLKSIZE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(stat.blksize);\n\t}\n#endif  \n\tif (bmval2 & FATTR4_WORD2_SUPPATTR_EXCLCREAT) {\n\t\tu32 supp[3];\n\n\t\tmemcpy(supp, nfsd_suppattrs[minorversion], sizeof(supp));\n\t\tsupp[0] &= NFSD_SUPPATTR_EXCLCREAT_WORD0;\n\t\tsupp[1] &= NFSD_SUPPATTR_EXCLCREAT_WORD1;\n\t\tsupp[2] &= NFSD_SUPPATTR_EXCLCREAT_WORD2;\n\n\t\tstatus = nfsd4_encode_bitmap(xdr, supp[0], supp[1], supp[2]);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n#ifdef CONFIG_NFSD_V4_SECURITY_LABEL\n\tif (bmval2 & FATTR4_WORD2_SECURITY_LABEL) {\n\t\tstatus = nfsd4_encode_security_label(xdr, rqstp, context,\n\t\t\t\t\t\t\t\tcontextlen);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n#endif\n\n\tif (bmval2 & FATTR4_WORD2_XATTR_SUPPORT) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\terr = xattr_supports_user_prefix(d_inode(dentry));\n\t\t*p++ = cpu_to_be32(err == 0);\n\t}\n\n\t*attrlen_p = cpu_to_be32(xdr->buf->len - attrlen_offset - XDR_UNIT);\n\tstatus = nfs_ok;\n\nout:\n#ifdef CONFIG_NFSD_V4_SECURITY_LABEL\n\tif (context)\n\t\tsecurity_release_secctx(context, contextlen);\n#endif  \n\tkfree(acl);\n\tif (tempfh) {\n\t\tfh_put(tempfh);\n\t\tkfree(tempfh);\n\t}\n\tif (status)\n\t\txdr_truncate_encode(xdr, starting_len);\n\treturn status;\nout_nfserr:\n\tstatus = nfserrno(err);\n\tgoto out;\nout_resource:\n\tstatus = nfserr_resource;\n\tgoto out;\n}\n\nstatic void svcxdr_init_encode_from_buffer(struct xdr_stream *xdr,\n\t\t\t\tstruct xdr_buf *buf, __be32 *p, int bytes)\n{\n\txdr->scratch.iov_len = 0;\n\tmemset(buf, 0, sizeof(struct xdr_buf));\n\tbuf->head[0].iov_base = p;\n\tbuf->head[0].iov_len = 0;\n\tbuf->len = 0;\n\txdr->buf = buf;\n\txdr->iov = buf->head;\n\txdr->p = p;\n\txdr->end = (void *)p + bytes;\n\tbuf->buflen = bytes;\n}\n\n__be32 nfsd4_encode_fattr_to_buf(__be32 **p, int words,\n\t\t\tstruct svc_fh *fhp, struct svc_export *exp,\n\t\t\tstruct dentry *dentry, u32 *bmval,\n\t\t\tstruct svc_rqst *rqstp, int ignore_crossmnt)\n{\n\tstruct xdr_buf dummy;\n\tstruct xdr_stream xdr;\n\t__be32 ret;\n\n\tsvcxdr_init_encode_from_buffer(&xdr, &dummy, *p, words << 2);\n\tret = nfsd4_encode_fattr(&xdr, fhp, exp, dentry, bmval, rqstp,\n\t\t\t\t\t\t\tignore_crossmnt);\n\t*p = xdr.p;\n\treturn ret;\n}\n\nstatic inline int attributes_need_mount(u32 *bmval)\n{\n\tif (bmval[0] & ~(FATTR4_WORD0_RDATTR_ERROR | FATTR4_WORD0_LEASE_TIME))\n\t\treturn 1;\n\tif (bmval[1] & ~FATTR4_WORD1_MOUNTED_ON_FILEID)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic __be32\nnfsd4_encode_dirent_fattr(struct xdr_stream *xdr, struct nfsd4_readdir *cd,\n\t\t\tconst char *name, int namlen)\n{\n\tstruct svc_export *exp = cd->rd_fhp->fh_export;\n\tstruct dentry *dentry;\n\t__be32 nfserr;\n\tint ignore_crossmnt = 0;\n\n\tdentry = lookup_positive_unlocked(name, cd->rd_fhp->fh_dentry, namlen);\n\tif (IS_ERR(dentry))\n\t\treturn nfserrno(PTR_ERR(dentry));\n\n\texp_get(exp);\n\t \n\tif (nfsd_mountpoint(dentry, exp)) {\n\t\tint err;\n\n\t\tif (!(exp->ex_flags & NFSEXP_V4ROOT)\n\t\t\t\t&& !attributes_need_mount(cd->rd_bmval)) {\n\t\t\tignore_crossmnt = 1;\n\t\t\tgoto out_encode;\n\t\t}\n\t\t \n\t\terr = nfsd_cross_mnt(cd->rd_rqstp, &dentry, &exp);\n\t\tif (err) {\n\t\t\tnfserr = nfserrno(err);\n\t\t\tgoto out_put;\n\t\t}\n\t\tnfserr = check_nfsd_access(exp, cd->rd_rqstp);\n\t\tif (nfserr)\n\t\t\tgoto out_put;\n\n\t}\nout_encode:\n\tnfserr = nfsd4_encode_fattr(xdr, NULL, exp, dentry, cd->rd_bmval,\n\t\t\t\t\tcd->rd_rqstp, ignore_crossmnt);\nout_put:\n\tdput(dentry);\n\texp_put(exp);\n\treturn nfserr;\n}\n\nstatic __be32 *\nnfsd4_encode_rdattr_error(struct xdr_stream *xdr, __be32 nfserr)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 20);\n\tif (!p)\n\t\treturn NULL;\n\t*p++ = htonl(2);\n\t*p++ = htonl(FATTR4_WORD0_RDATTR_ERROR);  \n\t*p++ = htonl(0);\t\t\t  \n\n\t*p++ = htonl(4);      \n\t*p++ = nfserr;        \n\treturn p;\n}\n\nstatic int\nnfsd4_encode_dirent(void *ccdv, const char *name, int namlen,\n\t\t    loff_t offset, u64 ino, unsigned int d_type)\n{\n\tstruct readdir_cd *ccd = ccdv;\n\tstruct nfsd4_readdir *cd = container_of(ccd, struct nfsd4_readdir, common);\n\tstruct xdr_stream *xdr = cd->xdr;\n\tint start_offset = xdr->buf->len;\n\tint cookie_offset;\n\tu32 name_and_cookie;\n\tint entry_bytes;\n\t__be32 nfserr = nfserr_toosmall;\n\t__be64 wire_offset;\n\t__be32 *p;\n\n\t \n\tif (name && isdotent(name, namlen)) {\n\t\tcd->common.err = nfs_ok;\n\t\treturn 0;\n\t}\n\n\tif (cd->cookie_offset) {\n\t\twire_offset = cpu_to_be64(offset);\n\t\twrite_bytes_to_xdr_buf(xdr->buf, cd->cookie_offset,\n\t\t\t\t\t\t\t&wire_offset, 8);\n\t}\n\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\tgoto fail;\n\t*p++ = xdr_one;                              \n\tcookie_offset = xdr->buf->len;\n\tp = xdr_reserve_space(xdr, 3*4 + namlen);\n\tif (!p)\n\t\tgoto fail;\n\tp = xdr_encode_hyper(p, OFFSET_MAX);         \n\tp = xdr_encode_array(p, name, namlen);       \n\n\tnfserr = nfsd4_encode_dirent_fattr(xdr, cd, name, namlen);\n\tswitch (nfserr) {\n\tcase nfs_ok:\n\t\tbreak;\n\tcase nfserr_resource:\n\t\tnfserr = nfserr_toosmall;\n\t\tgoto fail;\n\tcase nfserr_noent:\n\t\txdr_truncate_encode(xdr, start_offset);\n\t\tgoto skip_entry;\n\tcase nfserr_jukebox:\n\t\t \n\t\tif (cd->rd_fhp->fh_export->ex_flags & NFSEXP_V4ROOT)\n\t\t\tgoto fail;\n\t\tfallthrough;\n\tdefault:\n\t\t \n\t\tif (!(cd->rd_bmval[0] & FATTR4_WORD0_RDATTR_ERROR))\n\t\t\tgoto fail;\n\t\tp = nfsd4_encode_rdattr_error(xdr, nfserr);\n\t\tif (p == NULL) {\n\t\t\tnfserr = nfserr_toosmall;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tnfserr = nfserr_toosmall;\n\tentry_bytes = xdr->buf->len - start_offset;\n\tif (entry_bytes > cd->rd_maxcount)\n\t\tgoto fail;\n\tcd->rd_maxcount -= entry_bytes;\n\t \n\tif (cd->rd_dircount) {\n\t\tname_and_cookie = 4 + 4 * XDR_QUADLEN(namlen) + 8;\n\t\tif (name_and_cookie > cd->rd_dircount && cd->cookie_offset)\n\t\t\tgoto fail;\n\t\tcd->rd_dircount -= min(cd->rd_dircount, name_and_cookie);\n\t\tif (!cd->rd_dircount)\n\t\t\tcd->rd_maxcount = 0;\n\t}\n\n\tcd->cookie_offset = cookie_offset;\nskip_entry:\n\tcd->common.err = nfs_ok;\n\treturn 0;\nfail:\n\txdr_truncate_encode(xdr, start_offset);\n\tcd->common.err = nfserr;\n\treturn -EINVAL;\n}\n\nstatic __be32\nnfsd4_encode_verifier4(struct xdr_stream *xdr, const nfs4_verifier *verf)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, NFS4_VERIFIER_SIZE);\n\tif (!p)\n\t\treturn nfserr_resource;\n\tmemcpy(p, verf->data, sizeof(verf->data));\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_encode_clientid4(struct xdr_stream *xdr, const clientid_t *clientid)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, sizeof(__be64));\n\tif (!p)\n\t\treturn nfserr_resource;\n\tmemcpy(p, clientid, sizeof(*clientid));\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_encode_stateid(struct xdr_stream *xdr, stateid_t *sid)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, sizeof(stateid_t));\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(sid->si_generation);\n\tp = xdr_encode_opaque_fixed(p, &sid->si_opaque,\n\t\t\t\t\tsizeof(stateid_opaque_t));\n\treturn 0;\n}\n\nstatic __be32\nnfsd4_encode_access(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t    union nfsd4_op_u *u)\n{\n\tstruct nfsd4_access *access = &u->access;\n\tstruct xdr_stream *xdr = resp->xdr;\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 8);\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(access->ac_supported);\n\t*p++ = cpu_to_be32(access->ac_resp_access);\n\treturn 0;\n}\n\nstatic __be32 nfsd4_encode_bind_conn_to_session(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t\t\t\t\tunion nfsd4_op_u *u)\n{\n\tstruct nfsd4_bind_conn_to_session *bcts = &u->bind_conn_to_session;\n\tstruct xdr_stream *xdr = resp->xdr;\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, NFS4_MAX_SESSIONID_LEN + 8);\n\tif (!p)\n\t\treturn nfserr_resource;\n\tp = xdr_encode_opaque_fixed(p, bcts->sessionid.data,\n\t\t\t\t\tNFS4_MAX_SESSIONID_LEN);\n\t*p++ = cpu_to_be32(bcts->dir);\n\t \n\t*p++ = cpu_to_be32(0);\n\treturn 0;\n}\n\nstatic __be32\nnfsd4_encode_close(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t   union nfsd4_op_u *u)\n{\n\tstruct nfsd4_close *close = &u->close;\n\tstruct xdr_stream *xdr = resp->xdr;\n\n\treturn nfsd4_encode_stateid(xdr, &close->cl_stateid);\n}\n\n\nstatic __be32\nnfsd4_encode_commit(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t    union nfsd4_op_u *u)\n{\n\tstruct nfsd4_commit *commit = &u->commit;\n\n\treturn nfsd4_encode_verifier4(resp->xdr, &commit->co_verf);\n}\n\nstatic __be32\nnfsd4_encode_create(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t    union nfsd4_op_u *u)\n{\n\tstruct nfsd4_create *create = &u->create;\n\tstruct xdr_stream *xdr = resp->xdr;\n\n\tnfserr = nfsd4_encode_change_info4(xdr, &create->cr_cinfo);\n\tif (nfserr)\n\t\treturn nfserr;\n\treturn nfsd4_encode_bitmap(xdr, create->cr_bmval[0],\n\t\t\tcreate->cr_bmval[1], create->cr_bmval[2]);\n}\n\nstatic __be32\nnfsd4_encode_getattr(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t     union nfsd4_op_u *u)\n{\n\tstruct nfsd4_getattr *getattr = &u->getattr;\n\tstruct svc_fh *fhp = getattr->ga_fhp;\n\tstruct xdr_stream *xdr = resp->xdr;\n\n\treturn nfsd4_encode_fattr(xdr, fhp, fhp->fh_export, fhp->fh_dentry,\n\t\t\t\t    getattr->ga_bmval, resp->rqstp, 0);\n}\n\nstatic __be32\nnfsd4_encode_getfh(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t   union nfsd4_op_u *u)\n{\n\tstruct svc_fh **fhpp = &u->getfh;\n\tstruct xdr_stream *xdr = resp->xdr;\n\tstruct svc_fh *fhp = *fhpp;\n\tunsigned int len;\n\t__be32 *p;\n\n\tlen = fhp->fh_handle.fh_size;\n\tp = xdr_reserve_space(xdr, len + 4);\n\tif (!p)\n\t\treturn nfserr_resource;\n\tp = xdr_encode_opaque(p, &fhp->fh_handle.fh_raw, len);\n\treturn 0;\n}\n\n \nstatic __be32\nnfsd4_encode_lock_denied(struct xdr_stream *xdr, struct nfsd4_lock_denied *ld)\n{\n\tstruct xdr_netobj *conf = &ld->ld_owner;\n\t__be32 *p;\n\nagain:\n\tp = xdr_reserve_space(xdr, 32 + XDR_LEN(conf->len));\n\tif (!p) {\n\t\t \n\t\tif (conf->len) {\n\t\t\tkfree(conf->data);\n\t\t\tconf->len = 0;\n\t\t\tconf->data = NULL;\n\t\t\tgoto again;\n\t\t}\n\t\treturn nfserr_resource;\n\t}\n\tp = xdr_encode_hyper(p, ld->ld_start);\n\tp = xdr_encode_hyper(p, ld->ld_length);\n\t*p++ = cpu_to_be32(ld->ld_type);\n\tif (conf->len) {\n\t\tp = xdr_encode_opaque_fixed(p, &ld->ld_clientid, 8);\n\t\tp = xdr_encode_opaque(p, conf->data, conf->len);\n\t\tkfree(conf->data);\n\t}  else {   \n\t\tp = xdr_encode_hyper(p, (u64)0);  \n\t\t*p++ = cpu_to_be32(0);  \n\t}\n\treturn nfserr_denied;\n}\n\nstatic __be32\nnfsd4_encode_lock(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t  union nfsd4_op_u *u)\n{\n\tstruct nfsd4_lock *lock = &u->lock;\n\tstruct xdr_stream *xdr = resp->xdr;\n\n\tif (!nfserr)\n\t\tnfserr = nfsd4_encode_stateid(xdr, &lock->lk_resp_stateid);\n\telse if (nfserr == nfserr_denied)\n\t\tnfserr = nfsd4_encode_lock_denied(xdr, &lock->lk_denied);\n\n\treturn nfserr;\n}\n\nstatic __be32\nnfsd4_encode_lockt(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t   union nfsd4_op_u *u)\n{\n\tstruct nfsd4_lockt *lockt = &u->lockt;\n\tstruct xdr_stream *xdr = resp->xdr;\n\n\tif (nfserr == nfserr_denied)\n\t\tnfsd4_encode_lock_denied(xdr, &lockt->lt_denied);\n\treturn nfserr;\n}\n\nstatic __be32\nnfsd4_encode_locku(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t   union nfsd4_op_u *u)\n{\n\tstruct nfsd4_locku *locku = &u->locku;\n\tstruct xdr_stream *xdr = resp->xdr;\n\n\treturn nfsd4_encode_stateid(xdr, &locku->lu_stateid);\n}\n\n\nstatic __be32\nnfsd4_encode_link(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t  union nfsd4_op_u *u)\n{\n\tstruct nfsd4_link *link = &u->link;\n\tstruct xdr_stream *xdr = resp->xdr;\n\n\treturn nfsd4_encode_change_info4(xdr, &link->li_cinfo);\n}\n\n\nstatic __be32\nnfsd4_encode_open(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t  union nfsd4_op_u *u)\n{\n\tstruct nfsd4_open *open = &u->open;\n\tstruct xdr_stream *xdr = resp->xdr;\n\t__be32 *p;\n\n\tnfserr = nfsd4_encode_stateid(xdr, &open->op_stateid);\n\tif (nfserr)\n\t\treturn nfserr;\n\tnfserr = nfsd4_encode_change_info4(xdr, &open->op_cinfo);\n\tif (nfserr)\n\t\treturn nfserr;\n\tif (xdr_stream_encode_u32(xdr, open->op_rflags) < 0)\n\t\treturn nfserr_resource;\n\n\tnfserr = nfsd4_encode_bitmap(xdr, open->op_bmval[0], open->op_bmval[1],\n\t\t\t\t\topen->op_bmval[2]);\n\tif (nfserr)\n\t\treturn nfserr;\n\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\treturn nfserr_resource;\n\n\t*p++ = cpu_to_be32(open->op_delegate_type);\n\tswitch (open->op_delegate_type) {\n\tcase NFS4_OPEN_DELEGATE_NONE:\n\t\tbreak;\n\tcase NFS4_OPEN_DELEGATE_READ:\n\t\tnfserr = nfsd4_encode_stateid(xdr, &open->op_delegate_stateid);\n\t\tif (nfserr)\n\t\t\treturn nfserr;\n\t\tp = xdr_reserve_space(xdr, 20);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\t*p++ = cpu_to_be32(open->op_recall);\n\n\t\t \n\t\t*p++ = cpu_to_be32(NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE);\n\t\t*p++ = cpu_to_be32(0);\n\t\t*p++ = cpu_to_be32(0);\n\t\t*p++ = cpu_to_be32(0);    \n\t\tbreak;\n\tcase NFS4_OPEN_DELEGATE_WRITE:\n\t\tnfserr = nfsd4_encode_stateid(xdr, &open->op_delegate_stateid);\n\t\tif (nfserr)\n\t\t\treturn nfserr;\n\n\t\tp = xdr_reserve_space(xdr, XDR_UNIT * 8);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\t*p++ = cpu_to_be32(open->op_recall);\n\n\t\t \n\t\t*p++ = cpu_to_be32(NFS4_LIMIT_SIZE);\n\t\t*p++ = xdr_zero;\n\t\t*p++ = xdr_zero;\n\n\t\t \n\t\t*p++ = cpu_to_be32(NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE);\n\t\t*p++ = cpu_to_be32(0);\n\t\t*p++ = cpu_to_be32(0);\n\t\t*p++ = cpu_to_be32(0);    \n\t\tbreak;\n\tcase NFS4_OPEN_DELEGATE_NONE_EXT:  \n\t\tswitch (open->op_why_no_deleg) {\n\t\tcase WND4_CONTENTION:\n\t\tcase WND4_RESOURCE:\n\t\t\tp = xdr_reserve_space(xdr, 8);\n\t\t\tif (!p)\n\t\t\t\treturn nfserr_resource;\n\t\t\t*p++ = cpu_to_be32(open->op_why_no_deleg);\n\t\t\t \n\t\t\t*p++ = cpu_to_be32(0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tp = xdr_reserve_space(xdr, 4);\n\t\t\tif (!p)\n\t\t\t\treturn nfserr_resource;\n\t\t\t*p++ = cpu_to_be32(open->op_why_no_deleg);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\t \n\treturn 0;\n}\n\nstatic __be32\nnfsd4_encode_open_confirm(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t\t  union nfsd4_op_u *u)\n{\n\tstruct nfsd4_open_confirm *oc = &u->open_confirm;\n\tstruct xdr_stream *xdr = resp->xdr;\n\n\treturn nfsd4_encode_stateid(xdr, &oc->oc_resp_stateid);\n}\n\nstatic __be32\nnfsd4_encode_open_downgrade(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t\t    union nfsd4_op_u *u)\n{\n\tstruct nfsd4_open_downgrade *od = &u->open_downgrade;\n\tstruct xdr_stream *xdr = resp->xdr;\n\n\treturn nfsd4_encode_stateid(xdr, &od->od_stateid);\n}\n\n \nstatic __be32 nfsd4_encode_splice_read(\n\t\t\t\tstruct nfsd4_compoundres *resp,\n\t\t\t\tstruct nfsd4_read *read,\n\t\t\t\tstruct file *file, unsigned long maxcount)\n{\n\tstruct xdr_stream *xdr = resp->xdr;\n\tstruct xdr_buf *buf = xdr->buf;\n\tint status, space_left;\n\t__be32 nfserr;\n\n\t \n\tif (xdr->iov != xdr->buf->head || xdr->end - xdr->p < 1)\n\t\treturn nfserr_resource;\n\n\tnfserr = nfsd_splice_read(read->rd_rqstp, read->rd_fhp,\n\t\t\t\t  file, read->rd_offset, &maxcount,\n\t\t\t\t  &read->rd_eof);\n\tread->rd_length = maxcount;\n\tif (nfserr)\n\t\tgoto out_err;\n\tsvcxdr_encode_opaque_pages(read->rd_rqstp, xdr, buf->pages,\n\t\t\t\t   buf->page_base, maxcount);\n\tstatus = svc_encode_result_payload(read->rd_rqstp,\n\t\t\t\t\t   buf->head[0].iov_len, maxcount);\n\tif (status) {\n\t\tnfserr = nfserrno(status);\n\t\tgoto out_err;\n\t}\n\n\t \n\tspace_left = min_t(int, (void *)xdr->end - (void *)xdr->p,\n\t\t\t\tbuf->buflen - buf->len);\n\tbuf->buflen = buf->len + space_left;\n\txdr->end = (__be32 *)((void *)xdr->end + space_left);\n\n\treturn nfs_ok;\n\nout_err:\n\t \n\tbuf->page_len = 0;\n\treturn nfserr;\n}\n\nstatic __be32 nfsd4_encode_readv(struct nfsd4_compoundres *resp,\n\t\t\t\t struct nfsd4_read *read,\n\t\t\t\t struct file *file, unsigned long maxcount)\n{\n\tstruct xdr_stream *xdr = resp->xdr;\n\tunsigned int base = xdr->buf->page_len & ~PAGE_MASK;\n\tunsigned int starting_len = xdr->buf->len;\n\t__be32 zero = xdr_zero;\n\t__be32 nfserr;\n\n\tif (xdr_reserve_space_vec(xdr, maxcount) < 0)\n\t\treturn nfserr_resource;\n\n\tnfserr = nfsd_iter_read(resp->rqstp, read->rd_fhp, file,\n\t\t\t\tread->rd_offset, &maxcount, base,\n\t\t\t\t&read->rd_eof);\n\tread->rd_length = maxcount;\n\tif (nfserr)\n\t\treturn nfserr;\n\tif (svc_encode_result_payload(resp->rqstp, starting_len, maxcount))\n\t\treturn nfserr_io;\n\txdr_truncate_encode(xdr, starting_len + xdr_align_size(maxcount));\n\n\twrite_bytes_to_xdr_buf(xdr->buf, starting_len + maxcount, &zero,\n\t\t\t       xdr_pad_size(maxcount));\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_encode_read(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t  union nfsd4_op_u *u)\n{\n\tstruct nfsd4_read *read = &u->read;\n\tbool splice_ok = test_bit(RQ_SPLICE_OK, &resp->rqstp->rq_flags);\n\tunsigned long maxcount;\n\tstruct xdr_stream *xdr = resp->xdr;\n\tstruct file *file;\n\tint starting_len = xdr->buf->len;\n\t__be32 *p;\n\n\tif (nfserr)\n\t\treturn nfserr;\n\tfile = read->rd_nf->nf_file;\n\n\tp = xdr_reserve_space(xdr, 8);  \n\tif (!p) {\n\t\tWARN_ON_ONCE(splice_ok);\n\t\treturn nfserr_resource;\n\t}\n\tif (resp->xdr->buf->page_len && splice_ok) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn nfserr_serverfault;\n\t}\n\txdr_commit_encode(xdr);\n\n\tmaxcount = min_t(unsigned long, read->rd_length,\n\t\t\t (xdr->buf->buflen - xdr->buf->len));\n\n\tif (file->f_op->splice_read && splice_ok)\n\t\tnfserr = nfsd4_encode_splice_read(resp, read, file, maxcount);\n\telse\n\t\tnfserr = nfsd4_encode_readv(resp, read, file, maxcount);\n\tif (nfserr) {\n\t\txdr_truncate_encode(xdr, starting_len);\n\t\treturn nfserr;\n\t}\n\n\tp = xdr_encode_bool(p, read->rd_eof);\n\t*p = cpu_to_be32(read->rd_length);\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_encode_readlink(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t      union nfsd4_op_u *u)\n{\n\tstruct nfsd4_readlink *readlink = &u->readlink;\n\t__be32 *p, *maxcount_p, zero = xdr_zero;\n\tstruct xdr_stream *xdr = resp->xdr;\n\tint length_offset = xdr->buf->len;\n\tint maxcount, status;\n\n\tmaxcount_p = xdr_reserve_space(xdr, XDR_UNIT);\n\tif (!maxcount_p)\n\t\treturn nfserr_resource;\n\tmaxcount = PAGE_SIZE;\n\n\tp = xdr_reserve_space(xdr, maxcount);\n\tif (!p)\n\t\treturn nfserr_resource;\n\t \n\tnfserr = nfsd_readlink(readlink->rl_rqstp, readlink->rl_fhp,\n\t\t\t\t\t\t(char *)p, &maxcount);\n\tif (nfserr == nfserr_isdir)\n\t\tnfserr = nfserr_inval;\n\tif (nfserr)\n\t\tgoto out_err;\n\tstatus = svc_encode_result_payload(readlink->rl_rqstp, length_offset,\n\t\t\t\t\t   maxcount);\n\tif (status) {\n\t\tnfserr = nfserrno(status);\n\t\tgoto out_err;\n\t}\n\t*maxcount_p = cpu_to_be32(maxcount);\n\txdr_truncate_encode(xdr, length_offset + 4 + xdr_align_size(maxcount));\n\twrite_bytes_to_xdr_buf(xdr->buf, length_offset + 4 + maxcount, &zero,\n\t\t\t       xdr_pad_size(maxcount));\n\treturn nfs_ok;\n\nout_err:\n\txdr_truncate_encode(xdr, length_offset);\n\treturn nfserr;\n}\n\nstatic __be32\nnfsd4_encode_readdir(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t     union nfsd4_op_u *u)\n{\n\tstruct nfsd4_readdir *readdir = &u->readdir;\n\tint maxcount;\n\tint bytes_left;\n\tloff_t offset;\n\t__be64 wire_offset;\n\tstruct xdr_stream *xdr = resp->xdr;\n\tint starting_len = xdr->buf->len;\n\t__be32 *p;\n\n\tnfserr = nfsd4_encode_verifier4(xdr, &readdir->rd_verf);\n\tif (nfserr != nfs_ok)\n\t\treturn nfserr;\n\n\t \n\tbytes_left = xdr->buf->buflen - xdr->buf->len\n\t\t\t- COMPOUND_ERR_SLACK_SPACE - 8;\n\tif (bytes_left < 0) {\n\t\tnfserr = nfserr_resource;\n\t\tgoto err_no_verf;\n\t}\n\tmaxcount = svc_max_payload(resp->rqstp);\n\tmaxcount = min_t(u32, readdir->rd_maxcount, maxcount);\n\t \n\tif (maxcount < 16) {\n\t\tnfserr = nfserr_toosmall;\n\t\tgoto err_no_verf;\n\t}\n\tmaxcount = min_t(int, maxcount-16, bytes_left);\n\n\t \n\tif (!readdir->rd_dircount)\n\t\treaddir->rd_dircount = svc_max_payload(resp->rqstp);\n\n\treaddir->xdr = xdr;\n\treaddir->rd_maxcount = maxcount;\n\treaddir->common.err = 0;\n\treaddir->cookie_offset = 0;\n\n\toffset = readdir->rd_cookie;\n\tnfserr = nfsd_readdir(readdir->rd_rqstp, readdir->rd_fhp,\n\t\t\t      &offset,\n\t\t\t      &readdir->common, nfsd4_encode_dirent);\n\tif (nfserr == nfs_ok &&\n\t    readdir->common.err == nfserr_toosmall &&\n\t    xdr->buf->len == starting_len + 8) {\n\t\t \n\t\tif (maxcount - 16 < bytes_left)\n\t\t\t \n\t\t\tnfserr = nfserr_toosmall;\n\t\telse\n\t\t\t \n\t\t\tnfserr = nfserr_resource;\n\t}\n\tif (nfserr)\n\t\tgoto err_no_verf;\n\n\tif (readdir->cookie_offset) {\n\t\twire_offset = cpu_to_be64(offset);\n\t\twrite_bytes_to_xdr_buf(xdr->buf, readdir->cookie_offset,\n\t\t\t\t\t\t\t&wire_offset, 8);\n\t}\n\n\tp = xdr_reserve_space(xdr, 8);\n\tif (!p) {\n\t\tWARN_ON_ONCE(1);\n\t\tgoto err_no_verf;\n\t}\n\t*p++ = 0;\t \n\t*p++ = htonl(readdir->common.err == nfserr_eof);\n\n\treturn 0;\nerr_no_verf:\n\txdr_truncate_encode(xdr, starting_len);\n\treturn nfserr;\n}\n\nstatic __be32\nnfsd4_encode_remove(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t    union nfsd4_op_u *u)\n{\n\tstruct nfsd4_remove *remove = &u->remove;\n\tstruct xdr_stream *xdr = resp->xdr;\n\n\treturn nfsd4_encode_change_info4(xdr, &remove->rm_cinfo);\n}\n\nstatic __be32\nnfsd4_encode_rename(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t    union nfsd4_op_u *u)\n{\n\tstruct nfsd4_rename *rename = &u->rename;\n\tstruct xdr_stream *xdr = resp->xdr;\n\n\tnfserr = nfsd4_encode_change_info4(xdr, &rename->rn_sinfo);\n\tif (nfserr)\n\t\treturn nfserr;\n\treturn nfsd4_encode_change_info4(xdr, &rename->rn_tinfo);\n}\n\nstatic __be32\nnfsd4_do_encode_secinfo(struct xdr_stream *xdr, struct svc_export *exp)\n{\n\tu32 i, nflavs, supported;\n\tstruct exp_flavor_info *flavs;\n\tstruct exp_flavor_info def_flavs[2];\n\t__be32 *p, *flavorsp;\n\tstatic bool report = true;\n\n\tif (exp->ex_nflavors) {\n\t\tflavs = exp->ex_flavors;\n\t\tnflavs = exp->ex_nflavors;\n\t} else {  \n\t\tflavs = def_flavs;\n\t\tif (exp->ex_client->flavour->flavour == RPC_AUTH_UNIX) {\n\t\t\tnflavs = 2;\n\t\t\tflavs[0].pseudoflavor = RPC_AUTH_UNIX;\n\t\t\tflavs[1].pseudoflavor = RPC_AUTH_NULL;\n\t\t} else if (exp->ex_client->flavour->flavour == RPC_AUTH_GSS) {\n\t\t\tnflavs = 1;\n\t\t\tflavs[0].pseudoflavor\n\t\t\t\t\t= svcauth_gss_flavor(exp->ex_client);\n\t\t} else {\n\t\t\tnflavs = 1;\n\t\t\tflavs[0].pseudoflavor\n\t\t\t\t\t= exp->ex_client->flavour->flavour;\n\t\t}\n\t}\n\n\tsupported = 0;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\treturn nfserr_resource;\n\tflavorsp = p++;\t\t \n\n\tfor (i = 0; i < nflavs; i++) {\n\t\trpc_authflavor_t pf = flavs[i].pseudoflavor;\n\t\tstruct rpcsec_gss_info info;\n\n\t\tif (rpcauth_get_gssinfo(pf, &info) == 0) {\n\t\t\tsupported++;\n\t\t\tp = xdr_reserve_space(xdr, 4 + 4 +\n\t\t\t\t\t      XDR_LEN(info.oid.len) + 4 + 4);\n\t\t\tif (!p)\n\t\t\t\treturn nfserr_resource;\n\t\t\t*p++ = cpu_to_be32(RPC_AUTH_GSS);\n\t\t\tp = xdr_encode_opaque(p,  info.oid.data, info.oid.len);\n\t\t\t*p++ = cpu_to_be32(info.qop);\n\t\t\t*p++ = cpu_to_be32(info.service);\n\t\t} else if (pf < RPC_AUTH_MAXFLAVOR) {\n\t\t\tsupported++;\n\t\t\tp = xdr_reserve_space(xdr, 4);\n\t\t\tif (!p)\n\t\t\t\treturn nfserr_resource;\n\t\t\t*p++ = cpu_to_be32(pf);\n\t\t} else {\n\t\t\tif (report)\n\t\t\t\tpr_warn(\"NFS: SECINFO: security flavor %u \"\n\t\t\t\t\t\"is not supported\\n\", pf);\n\t\t}\n\t}\n\n\tif (nflavs != supported)\n\t\treport = false;\n\t*flavorsp = htonl(supported);\n\treturn 0;\n}\n\nstatic __be32\nnfsd4_encode_secinfo(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t     union nfsd4_op_u *u)\n{\n\tstruct nfsd4_secinfo *secinfo = &u->secinfo;\n\tstruct xdr_stream *xdr = resp->xdr;\n\n\treturn nfsd4_do_encode_secinfo(xdr, secinfo->si_exp);\n}\n\nstatic __be32\nnfsd4_encode_secinfo_no_name(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t     union nfsd4_op_u *u)\n{\n\tstruct nfsd4_secinfo_no_name *secinfo = &u->secinfo_no_name;\n\tstruct xdr_stream *xdr = resp->xdr;\n\n\treturn nfsd4_do_encode_secinfo(xdr, secinfo->sin_exp);\n}\n\n \nstatic __be32\nnfsd4_encode_setattr(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t     union nfsd4_op_u *u)\n{\n\tstruct nfsd4_setattr *setattr = &u->setattr;\n\tstruct xdr_stream *xdr = resp->xdr;\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 16);\n\tif (!p)\n\t\treturn nfserr_resource;\n\tif (nfserr) {\n\t\t*p++ = cpu_to_be32(3);\n\t\t*p++ = cpu_to_be32(0);\n\t\t*p++ = cpu_to_be32(0);\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\telse {\n\t\t*p++ = cpu_to_be32(3);\n\t\t*p++ = cpu_to_be32(setattr->sa_bmval[0]);\n\t\t*p++ = cpu_to_be32(setattr->sa_bmval[1]);\n\t\t*p++ = cpu_to_be32(setattr->sa_bmval[2]);\n\t}\n\treturn nfserr;\n}\n\nstatic __be32\nnfsd4_encode_setclientid(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t\t union nfsd4_op_u *u)\n{\n\tstruct nfsd4_setclientid *scd = &u->setclientid;\n\tstruct xdr_stream *xdr = resp->xdr;\n\n\tif (!nfserr) {\n\t\tnfserr = nfsd4_encode_clientid4(xdr, &scd->se_clientid);\n\t\tif (nfserr != nfs_ok)\n\t\t\tgoto out;\n\t\tnfserr = nfsd4_encode_verifier4(xdr, &scd->se_confirm);\n\t} else if (nfserr == nfserr_clid_inuse) {\n\t\t \n\t\tif (xdr_stream_encode_u32(xdr, 0) < 0) {\n\t\t\tnfserr = nfserr_resource;\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\tif (xdr_stream_encode_u32(xdr, 0) < 0) {\n\t\t\tnfserr = nfserr_resource;\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\treturn nfserr;\n}\n\nstatic __be32\nnfsd4_encode_write(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t   union nfsd4_op_u *u)\n{\n\tstruct nfsd4_write *write = &u->write;\n\n\tif (xdr_stream_encode_u32(resp->xdr, write->wr_bytes_written) < 0)\n\t\treturn nfserr_resource;\n\tif (xdr_stream_encode_u32(resp->xdr, write->wr_how_written) < 0)\n\t\treturn nfserr_resource;\n\treturn nfsd4_encode_verifier4(resp->xdr, &write->wr_verifier);\n}\n\nstatic __be32\nnfsd4_encode_exchange_id(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t\t union nfsd4_op_u *u)\n{\n\tstruct nfsd4_exchange_id *exid = &u->exchange_id;\n\tstruct xdr_stream *xdr = resp->xdr;\n\t__be32 *p;\n\tchar *major_id;\n\tchar *server_scope;\n\tint major_id_sz;\n\tint server_scope_sz;\n\tuint64_t minor_id = 0;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(resp->rqstp), nfsd_net_id);\n\n\tmajor_id = nn->nfsd_name;\n\tmajor_id_sz = strlen(nn->nfsd_name);\n\tserver_scope = nn->nfsd_name;\n\tserver_scope_sz = strlen(nn->nfsd_name);\n\n\tif (nfsd4_encode_clientid4(xdr, &exid->clientid) != nfs_ok)\n\t\treturn nfserr_resource;\n\tif (xdr_stream_encode_u32(xdr, exid->seqid) < 0)\n\t\treturn nfserr_resource;\n\tif (xdr_stream_encode_u32(xdr, exid->flags) < 0)\n\t\treturn nfserr_resource;\n\n\tif (xdr_stream_encode_u32(xdr, exid->spa_how) < 0)\n\t\treturn nfserr_resource;\n\tswitch (exid->spa_how) {\n\tcase SP4_NONE:\n\t\tbreak;\n\tcase SP4_MACH_CRED:\n\t\t \n\t\tnfserr = nfsd4_encode_bitmap(xdr,\n\t\t\t\t\texid->spo_must_enforce[0],\n\t\t\t\t\texid->spo_must_enforce[1],\n\t\t\t\t\texid->spo_must_enforce[2]);\n\t\tif (nfserr)\n\t\t\treturn nfserr;\n\t\t \n\t\tnfserr = nfsd4_encode_bitmap(xdr,\n\t\t\t\t\texid->spo_must_allow[0],\n\t\t\t\t\texid->spo_must_allow[1],\n\t\t\t\t\texid->spo_must_allow[2]);\n\t\tif (nfserr)\n\t\t\treturn nfserr;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t}\n\n\tp = xdr_reserve_space(xdr,\n\t\t8   +\n\t\t4   +\n\t\t(XDR_QUADLEN(major_id_sz) * 4) +\n\t\t4   +\n\t\t(XDR_QUADLEN(server_scope_sz) * 4) +\n\t\t4  );\n\tif (!p)\n\t\treturn nfserr_resource;\n\n\t \n\tp = xdr_encode_hyper(p, minor_id);       \n\t \n\tp = xdr_encode_opaque(p, major_id, major_id_sz);\n\n\t \n\tp = xdr_encode_opaque(p, server_scope, server_scope_sz);\n\n\t \n\t*p++ = cpu_to_be32(0);\t \n\treturn 0;\n}\n\nstatic __be32\nnfsd4_encode_create_session(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t\t    union nfsd4_op_u *u)\n{\n\tstruct nfsd4_create_session *sess = &u->create_session;\n\tstruct xdr_stream *xdr = resp->xdr;\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 24);\n\tif (!p)\n\t\treturn nfserr_resource;\n\tp = xdr_encode_opaque_fixed(p, sess->sessionid.data,\n\t\t\t\t\tNFS4_MAX_SESSIONID_LEN);\n\t*p++ = cpu_to_be32(sess->seqid);\n\t*p++ = cpu_to_be32(sess->flags);\n\n\tp = xdr_reserve_space(xdr, 28);\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(0);  \n\t*p++ = cpu_to_be32(sess->fore_channel.maxreq_sz);\n\t*p++ = cpu_to_be32(sess->fore_channel.maxresp_sz);\n\t*p++ = cpu_to_be32(sess->fore_channel.maxresp_cached);\n\t*p++ = cpu_to_be32(sess->fore_channel.maxops);\n\t*p++ = cpu_to_be32(sess->fore_channel.maxreqs);\n\t*p++ = cpu_to_be32(sess->fore_channel.nr_rdma_attrs);\n\n\tif (sess->fore_channel.nr_rdma_attrs) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\t*p++ = cpu_to_be32(sess->fore_channel.rdma_attrs);\n\t}\n\n\tp = xdr_reserve_space(xdr, 28);\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(0);  \n\t*p++ = cpu_to_be32(sess->back_channel.maxreq_sz);\n\t*p++ = cpu_to_be32(sess->back_channel.maxresp_sz);\n\t*p++ = cpu_to_be32(sess->back_channel.maxresp_cached);\n\t*p++ = cpu_to_be32(sess->back_channel.maxops);\n\t*p++ = cpu_to_be32(sess->back_channel.maxreqs);\n\t*p++ = cpu_to_be32(sess->back_channel.nr_rdma_attrs);\n\n\tif (sess->back_channel.nr_rdma_attrs) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\t*p++ = cpu_to_be32(sess->back_channel.rdma_attrs);\n\t}\n\treturn 0;\n}\n\nstatic __be32\nnfsd4_encode_sequence(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t      union nfsd4_op_u *u)\n{\n\tstruct nfsd4_sequence *seq = &u->sequence;\n\tstruct xdr_stream *xdr = resp->xdr;\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, NFS4_MAX_SESSIONID_LEN + 20);\n\tif (!p)\n\t\treturn nfserr_resource;\n\tp = xdr_encode_opaque_fixed(p, seq->sessionid.data,\n\t\t\t\t\tNFS4_MAX_SESSIONID_LEN);\n\t*p++ = cpu_to_be32(seq->seqid);\n\t*p++ = cpu_to_be32(seq->slotid);\n\t \n\t*p++ = cpu_to_be32(seq->maxslots - 1);  \n\t*p++ = cpu_to_be32(seq->maxslots - 1);  \n\t*p++ = cpu_to_be32(seq->status_flags);\n\n\tresp->cstate.data_offset = xdr->buf->len;  \n\treturn 0;\n}\n\nstatic __be32\nnfsd4_encode_test_stateid(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t\t  union nfsd4_op_u *u)\n{\n\tstruct nfsd4_test_stateid *test_stateid = &u->test_stateid;\n\tstruct xdr_stream *xdr = resp->xdr;\n\tstruct nfsd4_test_stateid_id *stateid, *next;\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4 + (4 * test_stateid->ts_num_ids));\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = htonl(test_stateid->ts_num_ids);\n\n\tlist_for_each_entry_safe(stateid, next, &test_stateid->ts_stateid_list, ts_id_list) {\n\t\t*p++ = stateid->ts_id_status;\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_NFSD_PNFS\nstatic __be32\nnfsd4_encode_getdeviceinfo(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\tunion nfsd4_op_u *u)\n{\n\tstruct nfsd4_getdeviceinfo *gdev = &u->getdeviceinfo;\n\tstruct xdr_stream *xdr = resp->xdr;\n\tconst struct nfsd4_layout_ops *ops;\n\tu32 starting_len = xdr->buf->len, needed_len;\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\treturn nfserr_resource;\n\n\t*p++ = cpu_to_be32(gdev->gd_layout_type);\n\n\tops = nfsd4_layout_ops[gdev->gd_layout_type];\n\tnfserr = ops->encode_getdeviceinfo(xdr, gdev);\n\tif (nfserr) {\n\t\t \n\t\tif (xdr->buf->len + 4 > gdev->gd_maxcount)\n\t\t\tgoto toosmall;\n\t\treturn nfserr;\n\t}\n\n\tif (gdev->gd_notify_types) {\n\t\tp = xdr_reserve_space(xdr, 4 + 4);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\t*p++ = cpu_to_be32(1);\t\t\t \n\t\t*p++ = cpu_to_be32(gdev->gd_notify_types);\n\t} else {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\t*p++ = 0;\n\t}\n\n\treturn 0;\ntoosmall:\n\tdprintk(\"%s: maxcount too small\\n\", __func__);\n\tneeded_len = xdr->buf->len + 4  ;\n\txdr_truncate_encode(xdr, starting_len);\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(needed_len);\n\treturn nfserr_toosmall;\n}\n\nstatic __be32\nnfsd4_encode_layoutget(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\tunion nfsd4_op_u *u)\n{\n\tstruct nfsd4_layoutget *lgp = &u->layoutget;\n\tstruct xdr_stream *xdr = resp->xdr;\n\tconst struct nfsd4_layout_ops *ops;\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 36 + sizeof(stateid_opaque_t));\n\tif (!p)\n\t\treturn nfserr_resource;\n\n\t*p++ = cpu_to_be32(1);\t \n\t*p++ = cpu_to_be32(lgp->lg_sid.si_generation);\n\tp = xdr_encode_opaque_fixed(p, &lgp->lg_sid.si_opaque,\n\t\t\t\t    sizeof(stateid_opaque_t));\n\n\t*p++ = cpu_to_be32(1);\t \n\tp = xdr_encode_hyper(p, lgp->lg_seg.offset);\n\tp = xdr_encode_hyper(p, lgp->lg_seg.length);\n\t*p++ = cpu_to_be32(lgp->lg_seg.iomode);\n\t*p++ = cpu_to_be32(lgp->lg_layout_type);\n\n\tops = nfsd4_layout_ops[lgp->lg_layout_type];\n\treturn ops->encode_layoutget(xdr, lgp);\n}\n\nstatic __be32\nnfsd4_encode_layoutcommit(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t\t  union nfsd4_op_u *u)\n{\n\tstruct nfsd4_layoutcommit *lcp = &u->layoutcommit;\n\tstruct xdr_stream *xdr = resp->xdr;\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(lcp->lc_size_chg);\n\tif (lcp->lc_size_chg) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\tp = xdr_encode_hyper(p, lcp->lc_newsize);\n\t}\n\n\treturn 0;\n}\n\nstatic __be32\nnfsd4_encode_layoutreturn(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\tunion nfsd4_op_u *u)\n{\n\tstruct nfsd4_layoutreturn *lrp = &u->layoutreturn;\n\tstruct xdr_stream *xdr = resp->xdr;\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(lrp->lrs_present);\n\tif (lrp->lrs_present)\n\t\treturn nfsd4_encode_stateid(xdr, &lrp->lr_sid);\n\treturn 0;\n}\n#endif  \n\nstatic __be32\nnfsd42_encode_write_res(struct nfsd4_compoundres *resp,\n\t\tstruct nfsd42_write_res *write, bool sync)\n{\n\t__be32 *p;\n\tp = xdr_reserve_space(resp->xdr, 4);\n\tif (!p)\n\t\treturn nfserr_resource;\n\n\tif (sync)\n\t\t*p++ = cpu_to_be32(0);\n\telse {\n\t\t__be32 nfserr;\n\t\t*p++ = cpu_to_be32(1);\n\t\tnfserr = nfsd4_encode_stateid(resp->xdr, &write->cb_stateid);\n\t\tif (nfserr)\n\t\t\treturn nfserr;\n\t}\n\tp = xdr_reserve_space(resp->xdr, 8 + 4 + NFS4_VERIFIER_SIZE);\n\tif (!p)\n\t\treturn nfserr_resource;\n\n\tp = xdr_encode_hyper(p, write->wr_bytes_written);\n\t*p++ = cpu_to_be32(write->wr_stable_how);\n\tp = xdr_encode_opaque_fixed(p, write->wr_verifier.data,\n\t\t\t\t    NFS4_VERIFIER_SIZE);\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd42_encode_nl4_server(struct nfsd4_compoundres *resp, struct nl4_server *ns)\n{\n\tstruct xdr_stream *xdr = resp->xdr;\n\tstruct nfs42_netaddr *addr;\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4);\n\t*p++ = cpu_to_be32(ns->nl4_type);\n\n\tswitch (ns->nl4_type) {\n\tcase NL4_NETADDR:\n\t\taddr = &ns->u.nl4_addr;\n\n\t\t \n\t\tp = xdr_reserve_space(xdr,\n\t\t\t4   +\n\t\t\t(XDR_QUADLEN(addr->netid_len) * 4) +\n\t\t\t4   +\n\t\t\t(XDR_QUADLEN(addr->addr_len) * 4));\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\n\t\t*p++ = cpu_to_be32(addr->netid_len);\n\t\tp = xdr_encode_opaque_fixed(p, addr->netid,\n\t\t\t\t\t    addr->netid_len);\n\t\t*p++ = cpu_to_be32(addr->addr_len);\n\t\tp = xdr_encode_opaque_fixed(p, addr->addr,\n\t\t\t\t\taddr->addr_len);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(ns->nl4_type != NL4_NETADDR);\n\t\treturn nfserr_inval;\n\t}\n\n\treturn 0;\n}\n\nstatic __be32\nnfsd4_encode_copy(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t  union nfsd4_op_u *u)\n{\n\tstruct nfsd4_copy *copy = &u->copy;\n\t__be32 *p;\n\n\tnfserr = nfsd42_encode_write_res(resp, &copy->cp_res,\n\t\t\t\t\t nfsd4_copy_is_sync(copy));\n\tif (nfserr)\n\t\treturn nfserr;\n\n\tp = xdr_reserve_space(resp->xdr, 4 + 4);\n\t*p++ = xdr_one;  \n\t*p = nfsd4_copy_is_sync(copy) ? xdr_one : xdr_zero;\n\treturn 0;\n}\n\nstatic __be32\nnfsd4_encode_offload_status(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t\t    union nfsd4_op_u *u)\n{\n\tstruct nfsd4_offload_status *os = &u->offload_status;\n\tstruct xdr_stream *xdr = resp->xdr;\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 8 + 4);\n\tif (!p)\n\t\treturn nfserr_resource;\n\tp = xdr_encode_hyper(p, os->count);\n\t*p++ = cpu_to_be32(0);\n\treturn nfserr;\n}\n\nstatic __be32\nnfsd4_encode_read_plus_data(struct nfsd4_compoundres *resp,\n\t\t\t    struct nfsd4_read *read)\n{\n\tbool splice_ok = test_bit(RQ_SPLICE_OK, &resp->rqstp->rq_flags);\n\tstruct file *file = read->rd_nf->nf_file;\n\tstruct xdr_stream *xdr = resp->xdr;\n\tunsigned long maxcount;\n\t__be32 nfserr, *p;\n\n\t \n\tp = xdr_reserve_space(xdr, 4 + 8 + 4);\n\tif (!p)\n\t\treturn nfserr_io;\n\tif (resp->xdr->buf->page_len && splice_ok) {\n\t\tWARN_ON_ONCE(splice_ok);\n\t\treturn nfserr_serverfault;\n\t}\n\n\tmaxcount = min_t(unsigned long, read->rd_length,\n\t\t\t (xdr->buf->buflen - xdr->buf->len));\n\n\tif (file->f_op->splice_read && splice_ok)\n\t\tnfserr = nfsd4_encode_splice_read(resp, read, file, maxcount);\n\telse\n\t\tnfserr = nfsd4_encode_readv(resp, read, file, maxcount);\n\tif (nfserr)\n\t\treturn nfserr;\n\n\t*p++ = cpu_to_be32(NFS4_CONTENT_DATA);\n\tp = xdr_encode_hyper(p, read->rd_offset);\n\t*p = cpu_to_be32(read->rd_length);\n\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_encode_read_plus(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t       union nfsd4_op_u *u)\n{\n\tstruct nfsd4_read *read = &u->read;\n\tstruct file *file = read->rd_nf->nf_file;\n\tstruct xdr_stream *xdr = resp->xdr;\n\tint starting_len = xdr->buf->len;\n\tu32 segments = 0;\n\t__be32 *p;\n\n\tif (nfserr)\n\t\treturn nfserr;\n\n\t \n\tp = xdr_reserve_space(xdr, 4 + 4);\n\tif (!p)\n\t\treturn nfserr_io;\n\txdr_commit_encode(xdr);\n\n\tread->rd_eof = read->rd_offset >= i_size_read(file_inode(file));\n\tif (read->rd_eof)\n\t\tgoto out;\n\n\tnfserr = nfsd4_encode_read_plus_data(resp, read);\n\tif (nfserr) {\n\t\txdr_truncate_encode(xdr, starting_len);\n\t\treturn nfserr;\n\t}\n\n\tsegments++;\n\nout:\n\tp = xdr_encode_bool(p, read->rd_eof);\n\t*p = cpu_to_be32(segments);\n\treturn nfserr;\n}\n\nstatic __be32\nnfsd4_encode_copy_notify(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t\t union nfsd4_op_u *u)\n{\n\tstruct nfsd4_copy_notify *cn = &u->copy_notify;\n\tstruct xdr_stream *xdr = resp->xdr;\n\t__be32 *p;\n\n\tif (nfserr)\n\t\treturn nfserr;\n\n\t \n\tp = xdr_reserve_space(xdr, 12);\n\tif (!p)\n\t\treturn nfserr_resource;\n\n\t \n\tp = xdr_encode_hyper(p, cn->cpn_sec);\n\t*p++ = cpu_to_be32(cn->cpn_nsec);\n\n\t \n\tnfserr = nfsd4_encode_stateid(xdr, &cn->cpn_cnr_stateid);\n\tif (nfserr)\n\t\treturn nfserr;\n\n\t \n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\treturn nfserr_resource;\n\n\t*p++ = cpu_to_be32(1);\n\n\tnfserr = nfsd42_encode_nl4_server(resp, cn->cpn_src);\n\treturn nfserr;\n}\n\nstatic __be32\nnfsd4_encode_seek(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t  union nfsd4_op_u *u)\n{\n\tstruct nfsd4_seek *seek = &u->seek;\n\t__be32 *p;\n\n\tp = xdr_reserve_space(resp->xdr, 4 + 8);\n\t*p++ = cpu_to_be32(seek->seek_eof);\n\tp = xdr_encode_hyper(p, seek->seek_pos);\n\n\treturn 0;\n}\n\nstatic __be32\nnfsd4_encode_noop(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t  union nfsd4_op_u *p)\n{\n\treturn nfserr;\n}\n\n \nstatic __be32\nnfsd4_vbuf_to_stream(struct xdr_stream *xdr, char *buf, u32 buflen)\n{\n\tu32 cplen;\n\t__be32 *p;\n\n\tcplen = min_t(unsigned long, buflen,\n\t\t      ((void *)xdr->end - (void *)xdr->p));\n\tp = xdr_reserve_space(xdr, cplen);\n\tif (!p)\n\t\treturn nfserr_resource;\n\n\tmemcpy(p, buf, cplen);\n\tbuf += cplen;\n\tbuflen -= cplen;\n\n\twhile (buflen) {\n\t\tcplen = min_t(u32, buflen, PAGE_SIZE);\n\t\tp = xdr_reserve_space(xdr, cplen);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\n\t\tmemcpy(p, buf, cplen);\n\n\t\tif (cplen < PAGE_SIZE) {\n\t\t\t \n\t\t\txdr_encode_opaque_fixed(p, NULL, cplen);\n\t\t\tbreak;\n\t\t}\n\n\t\tbuflen -= PAGE_SIZE;\n\t\tbuf += PAGE_SIZE;\n\t}\n\n\treturn 0;\n}\n\nstatic __be32\nnfsd4_encode_getxattr(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t      union nfsd4_op_u *u)\n{\n\tstruct nfsd4_getxattr *getxattr = &u->getxattr;\n\tstruct xdr_stream *xdr = resp->xdr;\n\t__be32 *p, err;\n\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\treturn nfserr_resource;\n\n\t*p = cpu_to_be32(getxattr->getxa_len);\n\n\tif (getxattr->getxa_len == 0)\n\t\treturn 0;\n\n\terr = nfsd4_vbuf_to_stream(xdr, getxattr->getxa_buf,\n\t\t\t\t    getxattr->getxa_len);\n\n\tkvfree(getxattr->getxa_buf);\n\n\treturn err;\n}\n\nstatic __be32\nnfsd4_encode_setxattr(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t      union nfsd4_op_u *u)\n{\n\tstruct nfsd4_setxattr *setxattr = &u->setxattr;\n\tstruct xdr_stream *xdr = resp->xdr;\n\n\treturn nfsd4_encode_change_info4(xdr, &setxattr->setxa_cinfo);\n}\n\n \nstatic __be32\nnfsd4_listxattr_validate_cookie(struct nfsd4_listxattrs *listxattrs,\n\t\t\t\tu32 *offsetp)\n{\n\tu64 cookie = listxattrs->lsxa_cookie;\n\n\t \n\tif (cookie > (listxattrs->lsxa_len) / (XATTR_USER_PREFIX_LEN + 2))\n\t\treturn nfserr_badcookie;\n\n\tif (cookie > (listxattrs->lsxa_maxcount /\n\t\t      (XDR_QUADLEN(XATTR_USER_PREFIX_LEN + 2) + 4)))\n\t\treturn nfserr_badcookie;\n\n\t*offsetp = (u32)cookie;\n\treturn 0;\n}\n\nstatic __be32\nnfsd4_encode_listxattrs(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t\tunion nfsd4_op_u *u)\n{\n\tstruct nfsd4_listxattrs *listxattrs = &u->listxattrs;\n\tstruct xdr_stream *xdr = resp->xdr;\n\tu32 cookie_offset, count_offset, eof;\n\tu32 left, xdrleft, slen, count;\n\tu32 xdrlen, offset;\n\tu64 cookie;\n\tchar *sp;\n\t__be32 status, tmp;\n\t__be32 *p;\n\tu32 nuser;\n\n\teof = 1;\n\n\tstatus = nfsd4_listxattr_validate_cookie(listxattrs, &offset);\n\tif (status)\n\t\tgoto out;\n\n\t \n\tcookie_offset = xdr->buf->len;\n\tcount_offset = cookie_offset + 8;\n\tp = xdr_reserve_space(xdr, 12);\n\tif (!p) {\n\t\tstatus = nfserr_resource;\n\t\tgoto out;\n\t}\n\n\tcount = 0;\n\tleft = listxattrs->lsxa_len;\n\tsp = listxattrs->lsxa_buf;\n\tnuser = 0;\n\n\txdrleft = listxattrs->lsxa_maxcount;\n\n\twhile (left > 0 && xdrleft > 0) {\n\t\tslen = strlen(sp);\n\n\t\t \n\t\tif (strncmp(sp, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN))\n\t\t\tgoto contloop;\n\n\t\tslen -= XATTR_USER_PREFIX_LEN;\n\t\txdrlen = 4 + ((slen + 3) & ~3);\n\t\tif (xdrlen > xdrleft) {\n\t\t\tif (count == 0) {\n\t\t\t\t \n\t\t\t\tstatus = nfserr_toosmall;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\teof = 0;\n\t\t\tgoto wreof;\n\t\t}\n\n\t\tleft -= XATTR_USER_PREFIX_LEN;\n\t\tsp += XATTR_USER_PREFIX_LEN;\n\t\tif (nuser++ < offset)\n\t\t\tgoto contloop;\n\n\n\t\tp = xdr_reserve_space(xdr, xdrlen);\n\t\tif (!p) {\n\t\t\tstatus = nfserr_resource;\n\t\t\tgoto out;\n\t\t}\n\n\t\txdr_encode_opaque(p, sp, slen);\n\n\t\txdrleft -= xdrlen;\n\t\tcount++;\ncontloop:\n\t\tsp += slen + 1;\n\t\tleft -= slen + 1;\n\t}\n\n\t \n\tif (nuser > 0 && count == 0) {\n\t\tstatus = nfserr_badcookie;\n\t\tgoto out;\n\t}\n\nwreof:\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p) {\n\t\tstatus = nfserr_resource;\n\t\tgoto out;\n\t}\n\t*p = cpu_to_be32(eof);\n\n\tcookie = offset + count;\n\n\twrite_bytes_to_xdr_buf(xdr->buf, cookie_offset, &cookie, 8);\n\ttmp = cpu_to_be32(count);\n\twrite_bytes_to_xdr_buf(xdr->buf, count_offset, &tmp, 4);\nout:\n\tif (listxattrs->lsxa_len)\n\t\tkvfree(listxattrs->lsxa_buf);\n\treturn status;\n}\n\nstatic __be32\nnfsd4_encode_removexattr(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t\t union nfsd4_op_u *u)\n{\n\tstruct nfsd4_removexattr *removexattr = &u->removexattr;\n\tstruct xdr_stream *xdr = resp->xdr;\n\n\treturn nfsd4_encode_change_info4(xdr, &removexattr->rmxa_cinfo);\n}\n\ntypedef __be32(*nfsd4_enc)(struct nfsd4_compoundres *, __be32, union nfsd4_op_u *u);\n\n \nstatic const nfsd4_enc nfsd4_enc_ops[] = {\n\t[OP_ACCESS]\t\t= nfsd4_encode_access,\n\t[OP_CLOSE]\t\t= nfsd4_encode_close,\n\t[OP_COMMIT]\t\t= nfsd4_encode_commit,\n\t[OP_CREATE]\t\t= nfsd4_encode_create,\n\t[OP_DELEGPURGE]\t\t= nfsd4_encode_noop,\n\t[OP_DELEGRETURN]\t= nfsd4_encode_noop,\n\t[OP_GETATTR]\t\t= nfsd4_encode_getattr,\n\t[OP_GETFH]\t\t= nfsd4_encode_getfh,\n\t[OP_LINK]\t\t= nfsd4_encode_link,\n\t[OP_LOCK]\t\t= nfsd4_encode_lock,\n\t[OP_LOCKT]\t\t= nfsd4_encode_lockt,\n\t[OP_LOCKU]\t\t= nfsd4_encode_locku,\n\t[OP_LOOKUP]\t\t= nfsd4_encode_noop,\n\t[OP_LOOKUPP]\t\t= nfsd4_encode_noop,\n\t[OP_NVERIFY]\t\t= nfsd4_encode_noop,\n\t[OP_OPEN]\t\t= nfsd4_encode_open,\n\t[OP_OPENATTR]\t\t= nfsd4_encode_noop,\n\t[OP_OPEN_CONFIRM]\t= nfsd4_encode_open_confirm,\n\t[OP_OPEN_DOWNGRADE]\t= nfsd4_encode_open_downgrade,\n\t[OP_PUTFH]\t\t= nfsd4_encode_noop,\n\t[OP_PUTPUBFH]\t\t= nfsd4_encode_noop,\n\t[OP_PUTROOTFH]\t\t= nfsd4_encode_noop,\n\t[OP_READ]\t\t= nfsd4_encode_read,\n\t[OP_READDIR]\t\t= nfsd4_encode_readdir,\n\t[OP_READLINK]\t\t= nfsd4_encode_readlink,\n\t[OP_REMOVE]\t\t= nfsd4_encode_remove,\n\t[OP_RENAME]\t\t= nfsd4_encode_rename,\n\t[OP_RENEW]\t\t= nfsd4_encode_noop,\n\t[OP_RESTOREFH]\t\t= nfsd4_encode_noop,\n\t[OP_SAVEFH]\t\t= nfsd4_encode_noop,\n\t[OP_SECINFO]\t\t= nfsd4_encode_secinfo,\n\t[OP_SETATTR]\t\t= nfsd4_encode_setattr,\n\t[OP_SETCLIENTID]\t= nfsd4_encode_setclientid,\n\t[OP_SETCLIENTID_CONFIRM] = nfsd4_encode_noop,\n\t[OP_VERIFY]\t\t= nfsd4_encode_noop,\n\t[OP_WRITE]\t\t= nfsd4_encode_write,\n\t[OP_RELEASE_LOCKOWNER]\t= nfsd4_encode_noop,\n\n\t \n\t[OP_BACKCHANNEL_CTL]\t= nfsd4_encode_noop,\n\t[OP_BIND_CONN_TO_SESSION] = nfsd4_encode_bind_conn_to_session,\n\t[OP_EXCHANGE_ID]\t= nfsd4_encode_exchange_id,\n\t[OP_CREATE_SESSION]\t= nfsd4_encode_create_session,\n\t[OP_DESTROY_SESSION]\t= nfsd4_encode_noop,\n\t[OP_FREE_STATEID]\t= nfsd4_encode_noop,\n\t[OP_GET_DIR_DELEGATION]\t= nfsd4_encode_noop,\n#ifdef CONFIG_NFSD_PNFS\n\t[OP_GETDEVICEINFO]\t= nfsd4_encode_getdeviceinfo,\n\t[OP_GETDEVICELIST]\t= nfsd4_encode_noop,\n\t[OP_LAYOUTCOMMIT]\t= nfsd4_encode_layoutcommit,\n\t[OP_LAYOUTGET]\t\t= nfsd4_encode_layoutget,\n\t[OP_LAYOUTRETURN]\t= nfsd4_encode_layoutreturn,\n#else\n\t[OP_GETDEVICEINFO]\t= nfsd4_encode_noop,\n\t[OP_GETDEVICELIST]\t= nfsd4_encode_noop,\n\t[OP_LAYOUTCOMMIT]\t= nfsd4_encode_noop,\n\t[OP_LAYOUTGET]\t\t= nfsd4_encode_noop,\n\t[OP_LAYOUTRETURN]\t= nfsd4_encode_noop,\n#endif\n\t[OP_SECINFO_NO_NAME]\t= nfsd4_encode_secinfo_no_name,\n\t[OP_SEQUENCE]\t\t= nfsd4_encode_sequence,\n\t[OP_SET_SSV]\t\t= nfsd4_encode_noop,\n\t[OP_TEST_STATEID]\t= nfsd4_encode_test_stateid,\n\t[OP_WANT_DELEGATION]\t= nfsd4_encode_noop,\n\t[OP_DESTROY_CLIENTID]\t= nfsd4_encode_noop,\n\t[OP_RECLAIM_COMPLETE]\t= nfsd4_encode_noop,\n\n\t \n\t[OP_ALLOCATE]\t\t= nfsd4_encode_noop,\n\t[OP_COPY]\t\t= nfsd4_encode_copy,\n\t[OP_COPY_NOTIFY]\t= nfsd4_encode_copy_notify,\n\t[OP_DEALLOCATE]\t\t= nfsd4_encode_noop,\n\t[OP_IO_ADVISE]\t\t= nfsd4_encode_noop,\n\t[OP_LAYOUTERROR]\t= nfsd4_encode_noop,\n\t[OP_LAYOUTSTATS]\t= nfsd4_encode_noop,\n\t[OP_OFFLOAD_CANCEL]\t= nfsd4_encode_noop,\n\t[OP_OFFLOAD_STATUS]\t= nfsd4_encode_offload_status,\n\t[OP_READ_PLUS]\t\t= nfsd4_encode_read_plus,\n\t[OP_SEEK]\t\t= nfsd4_encode_seek,\n\t[OP_WRITE_SAME]\t\t= nfsd4_encode_noop,\n\t[OP_CLONE]\t\t= nfsd4_encode_noop,\n\n\t \n\t[OP_GETXATTR]\t\t= nfsd4_encode_getxattr,\n\t[OP_SETXATTR]\t\t= nfsd4_encode_setxattr,\n\t[OP_LISTXATTRS]\t\t= nfsd4_encode_listxattrs,\n\t[OP_REMOVEXATTR]\t= nfsd4_encode_removexattr,\n};\n\n \n__be32 nfsd4_check_resp_size(struct nfsd4_compoundres *resp, u32 respsize)\n{\n\tstruct xdr_buf *buf = &resp->rqstp->rq_res;\n\tstruct nfsd4_slot *slot = resp->cstate.slot;\n\n\tif (buf->len + respsize <= buf->buflen)\n\t\treturn nfs_ok;\n\tif (!nfsd4_has_session(&resp->cstate))\n\t\treturn nfserr_resource;\n\tif (slot->sl_flags & NFSD4_SLOT_CACHETHIS) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn nfserr_rep_too_big_to_cache;\n\t}\n\treturn nfserr_rep_too_big;\n}\n\nvoid\nnfsd4_encode_operation(struct nfsd4_compoundres *resp, struct nfsd4_op *op)\n{\n\tstruct xdr_stream *xdr = resp->xdr;\n\tstruct nfs4_stateowner *so = resp->cstate.replay_owner;\n\tstruct svc_rqst *rqstp = resp->rqstp;\n\tconst struct nfsd4_operation *opdesc = op->opdesc;\n\tint post_err_offset;\n\tnfsd4_enc encoder;\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 8);\n\tif (!p)\n\t\tgoto release;\n\t*p++ = cpu_to_be32(op->opnum);\n\tpost_err_offset = xdr->buf->len;\n\n\tif (op->opnum == OP_ILLEGAL)\n\t\tgoto status;\n\tif (op->status && opdesc &&\n\t\t\t!(opdesc->op_flags & OP_NONTRIVIAL_ERROR_ENCODE))\n\t\tgoto status;\n\tBUG_ON(op->opnum >= ARRAY_SIZE(nfsd4_enc_ops) ||\n\t       !nfsd4_enc_ops[op->opnum]);\n\tencoder = nfsd4_enc_ops[op->opnum];\n\top->status = encoder(resp, op->status, &op->u);\n\tif (op->status)\n\t\ttrace_nfsd_compound_encode_err(rqstp, op->opnum, op->status);\n\txdr_commit_encode(xdr);\n\n\t \n\tif (!op->status) {\n\t\tint space_needed = 0;\n\t\tif (!nfsd4_last_compound_op(rqstp))\n\t\t\tspace_needed = COMPOUND_ERR_SLACK_SPACE;\n\t\top->status = nfsd4_check_resp_size(resp, space_needed);\n\t}\n\tif (op->status == nfserr_resource && nfsd4_has_session(&resp->cstate)) {\n\t\tstruct nfsd4_slot *slot = resp->cstate.slot;\n\n\t\tif (slot->sl_flags & NFSD4_SLOT_CACHETHIS)\n\t\t\top->status = nfserr_rep_too_big_to_cache;\n\t\telse\n\t\t\top->status = nfserr_rep_too_big;\n\t}\n\tif (op->status == nfserr_resource ||\n\t    op->status == nfserr_rep_too_big ||\n\t    op->status == nfserr_rep_too_big_to_cache) {\n\t\t \n\t\twarn_on_nonidempotent_op(op);\n\t\txdr_truncate_encode(xdr, post_err_offset);\n\t}\n\tif (so) {\n\t\tint len = xdr->buf->len - post_err_offset;\n\n\t\tso->so_replay.rp_status = op->status;\n\t\tso->so_replay.rp_buflen = len;\n\t\tread_bytes_from_xdr_buf(xdr->buf, post_err_offset,\n\t\t\t\t\t\tso->so_replay.rp_buf, len);\n\t}\nstatus:\n\t*p = op->status;\nrelease:\n\tif (opdesc && opdesc->op_release)\n\t\topdesc->op_release(&op->u);\n\n\t \n\trqstp->rq_next_page = xdr->page_ptr + 1;\n}\n\n \nvoid\nnfsd4_encode_replay(struct xdr_stream *xdr, struct nfsd4_op *op)\n{\n\t__be32 *p;\n\tstruct nfs4_replay *rp = op->replay;\n\n\tp = xdr_reserve_space(xdr, 8 + rp->rp_buflen);\n\tif (!p) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn;\n\t}\n\t*p++ = cpu_to_be32(op->opnum);\n\t*p++ = rp->rp_status;   \n\n\tp = xdr_encode_opaque_fixed(p, rp->rp_buf, rp->rp_buflen);\n}\n\nvoid nfsd4_release_compoundargs(struct svc_rqst *rqstp)\n{\n\tstruct nfsd4_compoundargs *args = rqstp->rq_argp;\n\n\tif (args->ops != args->iops) {\n\t\tvfree(args->ops);\n\t\targs->ops = args->iops;\n\t}\n\twhile (args->to_free) {\n\t\tstruct svcxdr_tmpbuf *tb = args->to_free;\n\t\targs->to_free = tb->next;\n\t\tkfree(tb);\n\t}\n}\n\nbool\nnfs4svc_decode_compoundargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nfsd4_compoundargs *args = rqstp->rq_argp;\n\n\t \n\targs->to_free = NULL;\n\n\targs->xdr = xdr;\n\targs->ops = args->iops;\n\targs->rqstp = rqstp;\n\n\treturn nfsd4_decode_compound(args);\n}\n\nbool\nnfs4svc_encode_compoundres(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nfsd4_compoundres *resp = rqstp->rq_resp;\n\t__be32 *p;\n\n\t \n\tp = resp->statusp;\n\n\t*p++ = resp->cstate.status;\n\t*p++ = htonl(resp->taglen);\n\tmemcpy(p, resp->tag, resp->taglen);\n\tp += XDR_QUADLEN(resp->taglen);\n\t*p++ = htonl(resp->opcnt);\n\n\tnfsd4_sequence_done(resp);\n\treturn true;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}