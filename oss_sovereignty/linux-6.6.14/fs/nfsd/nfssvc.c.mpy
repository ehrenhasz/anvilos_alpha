{
  "module_name": "nfssvc.c",
  "hash_id": "cf1465018fdf4c8058a3c8c18e72ef0a03cf6cae60b5b3486aa7975f66dc6150",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfsd/nfssvc.c",
  "human_readable_source": "\n \n\n#include <linux/sched/signal.h>\n#include <linux/freezer.h>\n#include <linux/module.h>\n#include <linux/fs_struct.h>\n#include <linux/swap.h>\n#include <linux/siphash.h>\n\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfsacl.h>\n#include <linux/seq_file.h>\n#include <linux/inetdevice.h>\n#include <net/addrconf.h>\n#include <net/ipv6.h>\n#include <net/net_namespace.h>\n#include \"nfsd.h\"\n#include \"cache.h\"\n#include \"vfs.h\"\n#include \"netns.h\"\n#include \"filecache.h\"\n\n#include \"trace.h\"\n\n#define NFSDDBG_FACILITY\tNFSDDBG_SVC\n\nextern struct svc_program\tnfsd_program;\nstatic int\t\t\tnfsd(void *vrqstp);\n#if defined(CONFIG_NFSD_V2_ACL) || defined(CONFIG_NFSD_V3_ACL)\nstatic int\t\t\tnfsd_acl_rpcbind_set(struct net *,\n\t\t\t\t\t\t     const struct svc_program *,\n\t\t\t\t\t\t     u32, int,\n\t\t\t\t\t\t     unsigned short,\n\t\t\t\t\t\t     unsigned short);\nstatic __be32\t\t\tnfsd_acl_init_request(struct svc_rqst *,\n\t\t\t\t\t\tconst struct svc_program *,\n\t\t\t\t\t\tstruct svc_process_info *);\n#endif\nstatic int\t\t\tnfsd_rpcbind_set(struct net *,\n\t\t\t\t\t\t const struct svc_program *,\n\t\t\t\t\t\t u32, int,\n\t\t\t\t\t\t unsigned short,\n\t\t\t\t\t\t unsigned short);\nstatic __be32\t\t\tnfsd_init_request(struct svc_rqst *,\n\t\t\t\t\t\tconst struct svc_program *,\n\t\t\t\t\t\tstruct svc_process_info *);\n\n \nDEFINE_MUTEX(nfsd_mutex);\n\n \nDEFINE_SPINLOCK(nfsd_drc_lock);\nunsigned long\tnfsd_drc_max_mem;\nunsigned long\tnfsd_drc_mem_used;\n\n#if defined(CONFIG_NFSD_V2_ACL) || defined(CONFIG_NFSD_V3_ACL)\nstatic struct svc_stat\tnfsd_acl_svcstats;\nstatic const struct svc_version *nfsd_acl_version[] = {\n# if defined(CONFIG_NFSD_V2_ACL)\n\t[2] = &nfsd_acl_version2,\n# endif\n# if defined(CONFIG_NFSD_V3_ACL)\n\t[3] = &nfsd_acl_version3,\n# endif\n};\n\n#define NFSD_ACL_MINVERS            2\n#define NFSD_ACL_NRVERS\t\tARRAY_SIZE(nfsd_acl_version)\n\nstatic struct svc_program\tnfsd_acl_program = {\n\t.pg_prog\t\t= NFS_ACL_PROGRAM,\n\t.pg_nvers\t\t= NFSD_ACL_NRVERS,\n\t.pg_vers\t\t= nfsd_acl_version,\n\t.pg_name\t\t= \"nfsacl\",\n\t.pg_class\t\t= \"nfsd\",\n\t.pg_stats\t\t= &nfsd_acl_svcstats,\n\t.pg_authenticate\t= &svc_set_client,\n\t.pg_init_request\t= nfsd_acl_init_request,\n\t.pg_rpcbind_set\t\t= nfsd_acl_rpcbind_set,\n};\n\nstatic struct svc_stat\tnfsd_acl_svcstats = {\n\t.program\t= &nfsd_acl_program,\n};\n#endif  \n\nstatic const struct svc_version *nfsd_version[] = {\n#if defined(CONFIG_NFSD_V2)\n\t[2] = &nfsd_version2,\n#endif\n\t[3] = &nfsd_version3,\n#if defined(CONFIG_NFSD_V4)\n\t[4] = &nfsd_version4,\n#endif\n};\n\n#define NFSD_MINVERS    \t2\n#define NFSD_NRVERS\t\tARRAY_SIZE(nfsd_version)\n\nstruct svc_program\t\tnfsd_program = {\n#if defined(CONFIG_NFSD_V2_ACL) || defined(CONFIG_NFSD_V3_ACL)\n\t.pg_next\t\t= &nfsd_acl_program,\n#endif\n\t.pg_prog\t\t= NFS_PROGRAM,\t\t \n\t.pg_nvers\t\t= NFSD_NRVERS,\t\t \n\t.pg_vers\t\t= nfsd_version,\t\t \n\t.pg_name\t\t= \"nfsd\",\t\t \n\t.pg_class\t\t= \"nfsd\",\t\t \n\t.pg_stats\t\t= &nfsd_svcstats,\t \n\t.pg_authenticate\t= &svc_set_client,\t \n\t.pg_init_request\t= nfsd_init_request,\n\t.pg_rpcbind_set\t\t= nfsd_rpcbind_set,\n};\n\nstatic bool\nnfsd_support_version(int vers)\n{\n\tif (vers >= NFSD_MINVERS && vers < NFSD_NRVERS)\n\t\treturn nfsd_version[vers] != NULL;\n\treturn false;\n}\n\nstatic bool *\nnfsd_alloc_versions(void)\n{\n\tbool *vers = kmalloc_array(NFSD_NRVERS, sizeof(bool), GFP_KERNEL);\n\tunsigned i;\n\n\tif (vers) {\n\t\t \n\t\tfor (i = 0; i < NFSD_NRVERS; i++)\n\t\t\tvers[i] = nfsd_support_version(i);\n\t}\n\treturn vers;\n}\n\nstatic bool *\nnfsd_alloc_minorversions(void)\n{\n\tbool *vers = kmalloc_array(NFSD_SUPPORTED_MINOR_VERSION + 1,\n\t\t\tsizeof(bool), GFP_KERNEL);\n\tunsigned i;\n\n\tif (vers) {\n\t\t \n\t\tfor (i = 0; i <= NFSD_SUPPORTED_MINOR_VERSION; i++)\n\t\t\tvers[i] = nfsd_support_version(4);\n\t}\n\treturn vers;\n}\n\nvoid\nnfsd_netns_free_versions(struct nfsd_net *nn)\n{\n\tkfree(nn->nfsd_versions);\n\tkfree(nn->nfsd4_minorversions);\n\tnn->nfsd_versions = NULL;\n\tnn->nfsd4_minorversions = NULL;\n}\n\nstatic void\nnfsd_netns_init_versions(struct nfsd_net *nn)\n{\n\tif (!nn->nfsd_versions) {\n\t\tnn->nfsd_versions = nfsd_alloc_versions();\n\t\tnn->nfsd4_minorversions = nfsd_alloc_minorversions();\n\t\tif (!nn->nfsd_versions || !nn->nfsd4_minorversions)\n\t\t\tnfsd_netns_free_versions(nn);\n\t}\n}\n\nint nfsd_vers(struct nfsd_net *nn, int vers, enum vers_op change)\n{\n\tif (vers < NFSD_MINVERS || vers >= NFSD_NRVERS)\n\t\treturn 0;\n\tswitch(change) {\n\tcase NFSD_SET:\n\t\tif (nn->nfsd_versions)\n\t\t\tnn->nfsd_versions[vers] = nfsd_support_version(vers);\n\t\tbreak;\n\tcase NFSD_CLEAR:\n\t\tnfsd_netns_init_versions(nn);\n\t\tif (nn->nfsd_versions)\n\t\t\tnn->nfsd_versions[vers] = false;\n\t\tbreak;\n\tcase NFSD_TEST:\n\t\tif (nn->nfsd_versions)\n\t\t\treturn nn->nfsd_versions[vers];\n\t\tfallthrough;\n\tcase NFSD_AVAIL:\n\t\treturn nfsd_support_version(vers);\n\t}\n\treturn 0;\n}\n\nstatic void\nnfsd_adjust_nfsd_versions4(struct nfsd_net *nn)\n{\n\tunsigned i;\n\n\tfor (i = 0; i <= NFSD_SUPPORTED_MINOR_VERSION; i++) {\n\t\tif (nn->nfsd4_minorversions[i])\n\t\t\treturn;\n\t}\n\tnfsd_vers(nn, 4, NFSD_CLEAR);\n}\n\nint nfsd_minorversion(struct nfsd_net *nn, u32 minorversion, enum vers_op change)\n{\n\tif (minorversion > NFSD_SUPPORTED_MINOR_VERSION &&\n\t    change != NFSD_AVAIL)\n\t\treturn -1;\n\n\tswitch(change) {\n\tcase NFSD_SET:\n\t\tif (nn->nfsd4_minorversions) {\n\t\t\tnfsd_vers(nn, 4, NFSD_SET);\n\t\t\tnn->nfsd4_minorversions[minorversion] =\n\t\t\t\tnfsd_vers(nn, 4, NFSD_TEST);\n\t\t}\n\t\tbreak;\n\tcase NFSD_CLEAR:\n\t\tnfsd_netns_init_versions(nn);\n\t\tif (nn->nfsd4_minorversions) {\n\t\t\tnn->nfsd4_minorversions[minorversion] = false;\n\t\t\tnfsd_adjust_nfsd_versions4(nn);\n\t\t}\n\t\tbreak;\n\tcase NFSD_TEST:\n\t\tif (nn->nfsd4_minorversions)\n\t\t\treturn nn->nfsd4_minorversions[minorversion];\n\t\treturn nfsd_vers(nn, 4, NFSD_TEST);\n\tcase NFSD_AVAIL:\n\t\treturn minorversion <= NFSD_SUPPORTED_MINOR_VERSION &&\n\t\t\tnfsd_vers(nn, 4, NFSD_AVAIL);\n\t}\n\treturn 0;\n}\n\n \n#define\tNFSD_MAXSERVS\t\t8192\n\nint nfsd_nrthreads(struct net *net)\n{\n\tint rv = 0;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tmutex_lock(&nfsd_mutex);\n\tif (nn->nfsd_serv)\n\t\trv = nn->nfsd_serv->sv_nrthreads;\n\tmutex_unlock(&nfsd_mutex);\n\treturn rv;\n}\n\nstatic int nfsd_init_socks(struct net *net, const struct cred *cred)\n{\n\tint error;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (!list_empty(&nn->nfsd_serv->sv_permsocks))\n\t\treturn 0;\n\n\terror = svc_xprt_create(nn->nfsd_serv, \"udp\", net, PF_INET, NFS_PORT,\n\t\t\t\tSVC_SOCK_DEFAULTS, cred);\n\tif (error < 0)\n\t\treturn error;\n\n\terror = svc_xprt_create(nn->nfsd_serv, \"tcp\", net, PF_INET, NFS_PORT,\n\t\t\t\tSVC_SOCK_DEFAULTS, cred);\n\tif (error < 0)\n\t\treturn error;\n\n\treturn 0;\n}\n\nstatic int nfsd_users = 0;\n\nstatic int nfsd_startup_generic(void)\n{\n\tint ret;\n\n\tif (nfsd_users++)\n\t\treturn 0;\n\n\tret = nfsd_file_cache_init();\n\tif (ret)\n\t\tgoto dec_users;\n\n\tret = nfs4_state_start();\n\tif (ret)\n\t\tgoto out_file_cache;\n\treturn 0;\n\nout_file_cache:\n\tnfsd_file_cache_shutdown();\ndec_users:\n\tnfsd_users--;\n\treturn ret;\n}\n\nstatic void nfsd_shutdown_generic(void)\n{\n\tif (--nfsd_users)\n\t\treturn;\n\n\tnfs4_state_shutdown();\n\tnfsd_file_cache_shutdown();\n}\n\nstatic bool nfsd_needs_lockd(struct nfsd_net *nn)\n{\n\treturn nfsd_vers(nn, 2, NFSD_TEST) || nfsd_vers(nn, 3, NFSD_TEST);\n}\n\n \nvoid nfsd_copy_write_verifier(__be32 verf[2], struct nfsd_net *nn)\n{\n\tint seq = 0;\n\n\tdo {\n\t\tread_seqbegin_or_lock(&nn->writeverf_lock, &seq);\n\t\tmemcpy(verf, nn->writeverf, sizeof(nn->writeverf));\n\t} while (need_seqretry(&nn->writeverf_lock, seq));\n\tdone_seqretry(&nn->writeverf_lock, seq);\n}\n\nstatic void nfsd_reset_write_verifier_locked(struct nfsd_net *nn)\n{\n\tstruct timespec64 now;\n\tu64 verf;\n\n\t \n\tktime_get_raw_ts64(&now);\n\tverf = siphash_2u64(now.tv_sec, now.tv_nsec, &nn->siphash_key);\n\tmemcpy(nn->writeverf, &verf, sizeof(nn->writeverf));\n}\n\n \nvoid nfsd_reset_write_verifier(struct nfsd_net *nn)\n{\n\twrite_seqlock(&nn->writeverf_lock);\n\tnfsd_reset_write_verifier_locked(nn);\n\twrite_sequnlock(&nn->writeverf_lock);\n}\n\n \nstatic int nfsd_startup_net(struct net *net, const struct cred *cred)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint ret;\n\n\tif (nn->nfsd_net_up)\n\t\treturn 0;\n\n\tret = nfsd_startup_generic();\n\tif (ret)\n\t\treturn ret;\n\tret = nfsd_init_socks(net, cred);\n\tif (ret)\n\t\tgoto out_socks;\n\n\tif (nfsd_needs_lockd(nn) && !nn->lockd_up) {\n\t\tret = lockd_up(net, cred);\n\t\tif (ret)\n\t\t\tgoto out_socks;\n\t\tnn->lockd_up = true;\n\t}\n\n\tret = nfsd_file_cache_start_net(net);\n\tif (ret)\n\t\tgoto out_lockd;\n\n\tret = nfsd_reply_cache_init(nn);\n\tif (ret)\n\t\tgoto out_filecache;\n\n\tret = nfs4_state_start_net(net);\n\tif (ret)\n\t\tgoto out_reply_cache;\n\n#ifdef CONFIG_NFSD_V4_2_INTER_SSC\n\tnfsd4_ssc_init_umount_work(nn);\n#endif\n\tnn->nfsd_net_up = true;\n\treturn 0;\n\nout_reply_cache:\n\tnfsd_reply_cache_shutdown(nn);\nout_filecache:\n\tnfsd_file_cache_shutdown_net(net);\nout_lockd:\n\tif (nn->lockd_up) {\n\t\tlockd_down(net);\n\t\tnn->lockd_up = false;\n\t}\nout_socks:\n\tnfsd_shutdown_generic();\n\treturn ret;\n}\n\nstatic void nfsd_shutdown_net(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tnfs4_state_shutdown_net(net);\n\tnfsd_reply_cache_shutdown(nn);\n\tnfsd_file_cache_shutdown_net(net);\n\tif (nn->lockd_up) {\n\t\tlockd_down(net);\n\t\tnn->lockd_up = false;\n\t}\n\tnn->nfsd_net_up = false;\n\tnfsd_shutdown_generic();\n}\n\nstatic DEFINE_SPINLOCK(nfsd_notifier_lock);\nstatic int nfsd_inetaddr_event(struct notifier_block *this, unsigned long event,\n\tvoid *ptr)\n{\n\tstruct in_ifaddr *ifa = (struct in_ifaddr *)ptr;\n\tstruct net_device *dev = ifa->ifa_dev->dev;\n\tstruct net *net = dev_net(dev);\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tstruct sockaddr_in sin;\n\n\tif (event != NETDEV_DOWN || !nn->nfsd_serv)\n\t\tgoto out;\n\n\tspin_lock(&nfsd_notifier_lock);\n\tif (nn->nfsd_serv) {\n\t\tdprintk(\"nfsd_inetaddr_event: removed %pI4\\n\", &ifa->ifa_local);\n\t\tsin.sin_family = AF_INET;\n\t\tsin.sin_addr.s_addr = ifa->ifa_local;\n\t\tsvc_age_temp_xprts_now(nn->nfsd_serv, (struct sockaddr *)&sin);\n\t}\n\tspin_unlock(&nfsd_notifier_lock);\n\nout:\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block nfsd_inetaddr_notifier = {\n\t.notifier_call = nfsd_inetaddr_event,\n};\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic int nfsd_inet6addr_event(struct notifier_block *this,\n\tunsigned long event, void *ptr)\n{\n\tstruct inet6_ifaddr *ifa = (struct inet6_ifaddr *)ptr;\n\tstruct net_device *dev = ifa->idev->dev;\n\tstruct net *net = dev_net(dev);\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tstruct sockaddr_in6 sin6;\n\n\tif (event != NETDEV_DOWN || !nn->nfsd_serv)\n\t\tgoto out;\n\n\tspin_lock(&nfsd_notifier_lock);\n\tif (nn->nfsd_serv) {\n\t\tdprintk(\"nfsd_inet6addr_event: removed %pI6\\n\", &ifa->addr);\n\t\tsin6.sin6_family = AF_INET6;\n\t\tsin6.sin6_addr = ifa->addr;\n\t\tif (ipv6_addr_type(&sin6.sin6_addr) & IPV6_ADDR_LINKLOCAL)\n\t\t\tsin6.sin6_scope_id = ifa->idev->dev->ifindex;\n\t\tsvc_age_temp_xprts_now(nn->nfsd_serv, (struct sockaddr *)&sin6);\n\t}\n\tspin_unlock(&nfsd_notifier_lock);\n\nout:\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block nfsd_inet6addr_notifier = {\n\t.notifier_call = nfsd_inet6addr_event,\n};\n#endif\n\n \nstatic atomic_t nfsd_notifier_refcount = ATOMIC_INIT(0);\n\nvoid nfsd_last_thread(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tstruct svc_serv *serv = nn->nfsd_serv;\n\n\tspin_lock(&nfsd_notifier_lock);\n\tnn->nfsd_serv = NULL;\n\tspin_unlock(&nfsd_notifier_lock);\n\n\t \n\tif (atomic_dec_return(&nfsd_notifier_refcount) == 0) {\n\t\tunregister_inetaddr_notifier(&nfsd_inetaddr_notifier);\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tunregister_inet6addr_notifier(&nfsd_inet6addr_notifier);\n#endif\n\t}\n\n\tsvc_xprt_destroy_all(serv, net);\n\n\t \n\tsvc_rpcb_cleanup(serv, net);\n\tif (!nn->nfsd_net_up)\n\t\treturn;\n\n\tnfsd_shutdown_net(net);\n\tpr_info(\"nfsd: last server has exited, flushing export cache\\n\");\n\tnfsd_export_flush(net);\n}\n\nvoid nfsd_reset_versions(struct nfsd_net *nn)\n{\n\tint i;\n\n\tfor (i = 0; i < NFSD_NRVERS; i++)\n\t\tif (nfsd_vers(nn, i, NFSD_TEST))\n\t\t\treturn;\n\n\tfor (i = 0; i < NFSD_NRVERS; i++)\n\t\tif (i != 4)\n\t\t\tnfsd_vers(nn, i, NFSD_SET);\n\t\telse {\n\t\t\tint minor = 0;\n\t\t\twhile (nfsd_minorversion(nn, minor, NFSD_SET) >= 0)\n\t\t\t\tminor++;\n\t\t}\n}\n\n \nstatic void set_max_drc(void)\n{\n\t#define NFSD_DRC_SIZE_SHIFT\t7\n\tnfsd_drc_max_mem = (nr_free_buffer_pages()\n\t\t\t\t\t>> NFSD_DRC_SIZE_SHIFT) * PAGE_SIZE;\n\tnfsd_drc_mem_used = 0;\n\tdprintk(\"%s nfsd_drc_max_mem %lu \\n\", __func__, nfsd_drc_max_mem);\n}\n\nstatic int nfsd_get_default_max_blksize(void)\n{\n\tstruct sysinfo i;\n\tunsigned long long target;\n\tunsigned long ret;\n\n\tsi_meminfo(&i);\n\ttarget = (i.totalram - i.totalhigh) << PAGE_SHIFT;\n\t \n\ttarget >>= 12;\n\n\tret = NFSSVC_MAXBLKSIZE;\n\twhile (ret > target && ret >= 8*1024*2)\n\t\tret /= 2;\n\treturn ret;\n}\n\nvoid nfsd_shutdown_threads(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tstruct svc_serv *serv;\n\n\tmutex_lock(&nfsd_mutex);\n\tserv = nn->nfsd_serv;\n\tif (serv == NULL) {\n\t\tmutex_unlock(&nfsd_mutex);\n\t\treturn;\n\t}\n\n\tsvc_get(serv);\n\t \n\tsvc_set_num_threads(serv, NULL, 0);\n\tnfsd_last_thread(net);\n\tsvc_put(serv);\n\tmutex_unlock(&nfsd_mutex);\n}\n\nbool i_am_nfsd(void)\n{\n\treturn kthread_func(current) == nfsd;\n}\n\nint nfsd_create_serv(struct net *net)\n{\n\tint error;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tstruct svc_serv *serv;\n\n\tWARN_ON(!mutex_is_locked(&nfsd_mutex));\n\tif (nn->nfsd_serv) {\n\t\tsvc_get(nn->nfsd_serv);\n\t\treturn 0;\n\t}\n\tif (nfsd_max_blksize == 0)\n\t\tnfsd_max_blksize = nfsd_get_default_max_blksize();\n\tnfsd_reset_versions(nn);\n\tserv = svc_create_pooled(&nfsd_program, nfsd_max_blksize, nfsd);\n\tif (serv == NULL)\n\t\treturn -ENOMEM;\n\n\tserv->sv_maxconn = nn->max_connections;\n\terror = svc_bind(serv, net);\n\tif (error < 0) {\n\t\tsvc_put(serv);\n\t\treturn error;\n\t}\n\tspin_lock(&nfsd_notifier_lock);\n\tnn->nfsd_serv = serv;\n\tspin_unlock(&nfsd_notifier_lock);\n\n\tset_max_drc();\n\t \n\tif (atomic_inc_return(&nfsd_notifier_refcount) == 1) {\n\t\tregister_inetaddr_notifier(&nfsd_inetaddr_notifier);\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tregister_inet6addr_notifier(&nfsd_inet6addr_notifier);\n#endif\n\t}\n\tnfsd_reset_write_verifier(nn);\n\treturn 0;\n}\n\nint nfsd_nrpools(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (nn->nfsd_serv == NULL)\n\t\treturn 0;\n\telse\n\t\treturn nn->nfsd_serv->sv_nrpools;\n}\n\nint nfsd_get_nrthreads(int n, int *nthreads, struct net *net)\n{\n\tint i = 0;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (nn->nfsd_serv != NULL) {\n\t\tfor (i = 0; i < nn->nfsd_serv->sv_nrpools && i < n; i++)\n\t\t\tnthreads[i] = nn->nfsd_serv->sv_pools[i].sp_nrthreads;\n\t}\n\n\treturn 0;\n}\n\nint nfsd_set_nrthreads(int n, int *nthreads, struct net *net)\n{\n\tint i = 0;\n\tint tot = 0;\n\tint err = 0;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tWARN_ON(!mutex_is_locked(&nfsd_mutex));\n\n\tif (nn->nfsd_serv == NULL || n <= 0)\n\t\treturn 0;\n\n\tif (n > nn->nfsd_serv->sv_nrpools)\n\t\tn = nn->nfsd_serv->sv_nrpools;\n\n\t \n\ttot = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tnthreads[i] = min(nthreads[i], NFSD_MAXSERVS);\n\t\ttot += nthreads[i];\n\t}\n\tif (tot > NFSD_MAXSERVS) {\n\t\t \n\t\tfor (i = 0; i < n && tot > 0; i++) {\n\t\t\tint new = nthreads[i] * NFSD_MAXSERVS / tot;\n\t\t\ttot -= (nthreads[i] - new);\n\t\t\tnthreads[i] = new;\n\t\t}\n\t\tfor (i = 0; i < n && tot > 0; i++) {\n\t\t\tnthreads[i]--;\n\t\t\ttot--;\n\t\t}\n\t}\n\n\t \n\tif (nthreads[0] == 0)\n\t\tnthreads[0] = 1;\n\n\t \n\tsvc_get(nn->nfsd_serv);\n\tfor (i = 0; i < n; i++) {\n\t\terr = svc_set_num_threads(nn->nfsd_serv,\n\t\t\t\t\t  &nn->nfsd_serv->sv_pools[i],\n\t\t\t\t\t  nthreads[i]);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\tsvc_put(nn->nfsd_serv);\n\treturn err;\n}\n\n \nint\nnfsd_svc(int nrservs, struct net *net, const struct cred *cred)\n{\n\tint\terror;\n\tbool\tnfsd_up_before;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tstruct svc_serv *serv;\n\n\tmutex_lock(&nfsd_mutex);\n\tdprintk(\"nfsd: creating service\\n\");\n\n\tnrservs = max(nrservs, 0);\n\tnrservs = min(nrservs, NFSD_MAXSERVS);\n\terror = 0;\n\n\tif (nrservs == 0 && nn->nfsd_serv == NULL)\n\t\tgoto out;\n\n\tstrscpy(nn->nfsd_name, utsname()->nodename,\n\t\tsizeof(nn->nfsd_name));\n\n\terror = nfsd_create_serv(net);\n\tif (error)\n\t\tgoto out;\n\n\tnfsd_up_before = nn->nfsd_net_up;\n\tserv = nn->nfsd_serv;\n\n\terror = nfsd_startup_net(net, cred);\n\tif (error)\n\t\tgoto out_put;\n\terror = svc_set_num_threads(serv, NULL, nrservs);\n\tif (error)\n\t\tgoto out_shutdown;\n\terror = serv->sv_nrthreads;\n\tif (error == 0)\n\t\tnfsd_last_thread(net);\nout_shutdown:\n\tif (error < 0 && !nfsd_up_before)\n\t\tnfsd_shutdown_net(net);\nout_put:\n\t \n\tif (xchg(&nn->keep_active, 0))\n\t\tsvc_put(serv);\n\tsvc_put(serv);\nout:\n\tmutex_unlock(&nfsd_mutex);\n\treturn error;\n}\n\n#if defined(CONFIG_NFSD_V2_ACL) || defined(CONFIG_NFSD_V3_ACL)\nstatic bool\nnfsd_support_acl_version(int vers)\n{\n\tif (vers >= NFSD_ACL_MINVERS && vers < NFSD_ACL_NRVERS)\n\t\treturn nfsd_acl_version[vers] != NULL;\n\treturn false;\n}\n\nstatic int\nnfsd_acl_rpcbind_set(struct net *net, const struct svc_program *progp,\n\t\t     u32 version, int family, unsigned short proto,\n\t\t     unsigned short port)\n{\n\tif (!nfsd_support_acl_version(version) ||\n\t    !nfsd_vers(net_generic(net, nfsd_net_id), version, NFSD_TEST))\n\t\treturn 0;\n\treturn svc_generic_rpcbind_set(net, progp, version, family,\n\t\t\tproto, port);\n}\n\nstatic __be32\nnfsd_acl_init_request(struct svc_rqst *rqstp,\n\t\t      const struct svc_program *progp,\n\t\t      struct svc_process_info *ret)\n{\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\tint i;\n\n\tif (likely(nfsd_support_acl_version(rqstp->rq_vers) &&\n\t    nfsd_vers(nn, rqstp->rq_vers, NFSD_TEST)))\n\t\treturn svc_generic_init_request(rqstp, progp, ret);\n\n\tret->mismatch.lovers = NFSD_ACL_NRVERS;\n\tfor (i = NFSD_ACL_MINVERS; i < NFSD_ACL_NRVERS; i++) {\n\t\tif (nfsd_support_acl_version(rqstp->rq_vers) &&\n\t\t    nfsd_vers(nn, i, NFSD_TEST)) {\n\t\t\tret->mismatch.lovers = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ret->mismatch.lovers == NFSD_ACL_NRVERS)\n\t\treturn rpc_prog_unavail;\n\tret->mismatch.hivers = NFSD_ACL_MINVERS;\n\tfor (i = NFSD_ACL_NRVERS - 1; i >= NFSD_ACL_MINVERS; i--) {\n\t\tif (nfsd_support_acl_version(rqstp->rq_vers) &&\n\t\t    nfsd_vers(nn, i, NFSD_TEST)) {\n\t\t\tret->mismatch.hivers = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn rpc_prog_mismatch;\n}\n#endif\n\nstatic int\nnfsd_rpcbind_set(struct net *net, const struct svc_program *progp,\n\t\t u32 version, int family, unsigned short proto,\n\t\t unsigned short port)\n{\n\tif (!nfsd_vers(net_generic(net, nfsd_net_id), version, NFSD_TEST))\n\t\treturn 0;\n\treturn svc_generic_rpcbind_set(net, progp, version, family,\n\t\t\tproto, port);\n}\n\nstatic __be32\nnfsd_init_request(struct svc_rqst *rqstp,\n\t\t  const struct svc_program *progp,\n\t\t  struct svc_process_info *ret)\n{\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\tint i;\n\n\tif (likely(nfsd_vers(nn, rqstp->rq_vers, NFSD_TEST)))\n\t\treturn svc_generic_init_request(rqstp, progp, ret);\n\n\tret->mismatch.lovers = NFSD_NRVERS;\n\tfor (i = NFSD_MINVERS; i < NFSD_NRVERS; i++) {\n\t\tif (nfsd_vers(nn, i, NFSD_TEST)) {\n\t\t\tret->mismatch.lovers = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ret->mismatch.lovers == NFSD_NRVERS)\n\t\treturn rpc_prog_unavail;\n\tret->mismatch.hivers = NFSD_MINVERS;\n\tfor (i = NFSD_NRVERS - 1; i >= NFSD_MINVERS; i--) {\n\t\tif (nfsd_vers(nn, i, NFSD_TEST)) {\n\t\t\tret->mismatch.hivers = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn rpc_prog_mismatch;\n}\n\n \nstatic int\nnfsd(void *vrqstp)\n{\n\tstruct svc_rqst *rqstp = (struct svc_rqst *) vrqstp;\n\tstruct svc_xprt *perm_sock = list_entry(rqstp->rq_server->sv_permsocks.next, typeof(struct svc_xprt), xpt_list);\n\tstruct net *net = perm_sock->xpt_net;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\t \n\tif (unshare_fs_struct() < 0) {\n\t\tprintk(\"Unable to start nfsd thread: out of memory\\n\");\n\t\tgoto out;\n\t}\n\n\tcurrent->fs->umask = 0;\n\n\tatomic_inc(&nfsdstats.th_cnt);\n\n\tset_freezable();\n\n\t \n\twhile (!kthread_should_stop()) {\n\t\t \n\t\trqstp->rq_server->sv_maxconn = nn->max_connections;\n\n\t\tsvc_recv(rqstp);\n\t}\n\n\tatomic_dec(&nfsdstats.th_cnt);\n\nout:\n\t \n\tsvc_exit_thread(rqstp);\n\treturn 0;\n}\n\n \nint nfsd_dispatch(struct svc_rqst *rqstp)\n{\n\tconst struct svc_procedure *proc = rqstp->rq_procinfo;\n\t__be32 *statp = rqstp->rq_accept_statp;\n\tstruct nfsd_cacherep *rp;\n\tunsigned int start, len;\n\t__be32 *nfs_reply;\n\n\t \n\trqstp->rq_cachetype = proc->pc_cachetype;\n\n\t \n\tstart = xdr_stream_pos(&rqstp->rq_arg_stream);\n\tlen = xdr_stream_remaining(&rqstp->rq_arg_stream);\n\tif (!proc->pc_decode(rqstp, &rqstp->rq_arg_stream))\n\t\tgoto out_decode_err;\n\n\trp = NULL;\n\tswitch (nfsd_cache_lookup(rqstp, start, len, &rp)) {\n\tcase RC_DOIT:\n\t\tbreak;\n\tcase RC_REPLY:\n\t\tgoto out_cached_reply;\n\tcase RC_DROPIT:\n\t\tgoto out_dropit;\n\t}\n\n\tnfs_reply = xdr_inline_decode(&rqstp->rq_res_stream, 0);\n\t*statp = proc->pc_func(rqstp);\n\tif (test_bit(RQ_DROPME, &rqstp->rq_flags))\n\t\tgoto out_update_drop;\n\n\tif (!proc->pc_encode(rqstp, &rqstp->rq_res_stream))\n\t\tgoto out_encode_err;\n\n\tnfsd_cache_update(rqstp, rp, rqstp->rq_cachetype, nfs_reply);\nout_cached_reply:\n\treturn 1;\n\nout_decode_err:\n\ttrace_nfsd_garbage_args_err(rqstp);\n\t*statp = rpc_garbage_args;\n\treturn 1;\n\nout_update_drop:\n\tnfsd_cache_update(rqstp, rp, RC_NOCACHE, NULL);\nout_dropit:\n\treturn 0;\n\nout_encode_err:\n\ttrace_nfsd_cant_encode_err(rqstp);\n\tnfsd_cache_update(rqstp, rp, RC_NOCACHE, NULL);\n\t*statp = rpc_system_err;\n\treturn 1;\n}\n\n \nbool nfssvc_decode_voidarg(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\treturn true;\n}\n\n \nbool nfssvc_encode_voidres(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\treturn true;\n}\n\nint nfsd_pool_stats_open(struct inode *inode, struct file *file)\n{\n\tint ret;\n\tstruct nfsd_net *nn = net_generic(inode->i_sb->s_fs_info, nfsd_net_id);\n\n\tmutex_lock(&nfsd_mutex);\n\tif (nn->nfsd_serv == NULL) {\n\t\tmutex_unlock(&nfsd_mutex);\n\t\treturn -ENODEV;\n\t}\n\tsvc_get(nn->nfsd_serv);\n\tret = svc_pool_stats_open(nn->nfsd_serv, file);\n\tmutex_unlock(&nfsd_mutex);\n\treturn ret;\n}\n\nint nfsd_pool_stats_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\tstruct svc_serv *serv = seq->private;\n\tint ret = seq_release(inode, file);\n\n\tmutex_lock(&nfsd_mutex);\n\tsvc_put(serv);\n\tmutex_unlock(&nfsd_mutex);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}