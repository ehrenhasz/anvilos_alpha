{
  "module_name": "trace.h",
  "hash_id": "75d80d69383f1ea008fa211b12644b67b612ca927011c619018d821580b3c89f",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfsd/trace.h",
  "human_readable_source": " \n \n#undef TRACE_SYSTEM\n#define TRACE_SYSTEM nfsd\n\n#if !defined(_NFSD_TRACE_H) || defined(TRACE_HEADER_MULTI_READ)\n#define _NFSD_TRACE_H\n\n#include <linux/tracepoint.h>\n#include <linux/sunrpc/xprt.h>\n#include <trace/misc/nfs.h>\n\n#include \"export.h\"\n#include \"nfsfh.h\"\n#include \"xdr4.h\"\n\n#define NFSD_TRACE_PROC_RES_FIELDS \\\n\t\t__field(unsigned int, netns_ino) \\\n\t\t__field(u32, xid) \\\n\t\t__field(unsigned long, status) \\\n\t\t__array(unsigned char, server, sizeof(struct sockaddr_in6)) \\\n\t\t__array(unsigned char, client, sizeof(struct sockaddr_in6))\n\n#define NFSD_TRACE_PROC_RES_ASSIGNMENTS(error) \\\n\t\tdo { \\\n\t\t\t__entry->netns_ino = SVC_NET(rqstp)->ns.inum; \\\n\t\t\t__entry->xid = be32_to_cpu(rqstp->rq_xid); \\\n\t\t\t__entry->status = be32_to_cpu(error); \\\n\t\t\tmemcpy(__entry->server, &rqstp->rq_xprt->xpt_local, \\\n\t\t\t       rqstp->rq_xprt->xpt_locallen); \\\n\t\t\tmemcpy(__entry->client, &rqstp->rq_xprt->xpt_remote, \\\n\t\t\t       rqstp->rq_xprt->xpt_remotelen); \\\n\t\t} while (0);\n\nDECLARE_EVENT_CLASS(nfsd_xdr_err_class,\n\tTP_PROTO(\n\t\tconst struct svc_rqst *rqstp\n\t),\n\tTP_ARGS(rqstp),\n\tTP_STRUCT__entry(\n\t\t__field(unsigned int, netns_ino)\n\t\t__field(u32, xid)\n\t\t__field(u32, vers)\n\t\t__field(u32, proc)\n\t\t__sockaddr(server, rqstp->rq_xprt->xpt_locallen)\n\t\t__sockaddr(client, rqstp->rq_xprt->xpt_remotelen)\n\t),\n\tTP_fast_assign(\n\t\tconst struct svc_xprt *xprt = rqstp->rq_xprt;\n\n\t\t__entry->netns_ino = xprt->xpt_net->ns.inum;\n\t\t__entry->xid = be32_to_cpu(rqstp->rq_xid);\n\t\t__entry->vers = rqstp->rq_vers;\n\t\t__entry->proc = rqstp->rq_proc;\n\t\t__assign_sockaddr(server, &xprt->xpt_local, xprt->xpt_locallen);\n\t\t__assign_sockaddr(client, &xprt->xpt_remote, xprt->xpt_remotelen);\n\t),\n\tTP_printk(\"xid=0x%08x vers=%u proc=%u\",\n\t\t__entry->xid, __entry->vers, __entry->proc\n\t)\n);\n\n#define DEFINE_NFSD_XDR_ERR_EVENT(name) \\\nDEFINE_EVENT(nfsd_xdr_err_class, nfsd_##name##_err, \\\n\tTP_PROTO(const struct svc_rqst *rqstp), \\\n\tTP_ARGS(rqstp))\n\nDEFINE_NFSD_XDR_ERR_EVENT(garbage_args);\nDEFINE_NFSD_XDR_ERR_EVENT(cant_encode);\n\n#define show_nfsd_may_flags(x)\t\t\t\t\t\t\\\n\t__print_flags(x, \"|\",\t\t\t\t\t\t\\\n\t\t{ NFSD_MAY_EXEC,\t\t\"EXEC\" },\t\t\\\n\t\t{ NFSD_MAY_WRITE,\t\t\"WRITE\" },\t\t\\\n\t\t{ NFSD_MAY_READ,\t\t\"READ\" },\t\t\\\n\t\t{ NFSD_MAY_SATTR,\t\t\"SATTR\" },\t\t\\\n\t\t{ NFSD_MAY_TRUNC,\t\t\"TRUNC\" },\t\t\\\n\t\t{ NFSD_MAY_LOCK,\t\t\"LOCK\" },\t\t\\\n\t\t{ NFSD_MAY_OWNER_OVERRIDE,\t\"OWNER_OVERRIDE\" },\t\\\n\t\t{ NFSD_MAY_LOCAL_ACCESS,\t\"LOCAL_ACCESS\" },\t\\\n\t\t{ NFSD_MAY_BYPASS_GSS_ON_ROOT,\t\"BYPASS_GSS_ON_ROOT\" },\t\\\n\t\t{ NFSD_MAY_NOT_BREAK_LEASE,\t\"NOT_BREAK_LEASE\" },\t\\\n\t\t{ NFSD_MAY_BYPASS_GSS,\t\t\"BYPASS_GSS\" },\t\t\\\n\t\t{ NFSD_MAY_READ_IF_EXEC,\t\"READ_IF_EXEC\" },\t\\\n\t\t{ NFSD_MAY_64BIT_COOKIE,\t\"64BIT_COOKIE\" })\n\nTRACE_EVENT(nfsd_compound,\n\tTP_PROTO(\n\t\tconst struct svc_rqst *rqst,\n\t\tconst char *tag,\n\t\tu32 taglen,\n\t\tu32 opcnt\n\t),\n\tTP_ARGS(rqst, tag, taglen, opcnt),\n\tTP_STRUCT__entry(\n\t\t__field(u32, xid)\n\t\t__field(u32, opcnt)\n\t\t__string_len(tag, tag, taglen)\n\t),\n\tTP_fast_assign(\n\t\t__entry->xid = be32_to_cpu(rqst->rq_xid);\n\t\t__entry->opcnt = opcnt;\n\t\t__assign_str_len(tag, tag, taglen);\n\t),\n\tTP_printk(\"xid=0x%08x opcnt=%u tag=%s\",\n\t\t__entry->xid, __entry->opcnt, __get_str(tag)\n\t)\n)\n\nTRACE_EVENT(nfsd_compound_status,\n\tTP_PROTO(u32 args_opcnt,\n\t\t u32 resp_opcnt,\n\t\t __be32 status,\n\t\t const char *name),\n\tTP_ARGS(args_opcnt, resp_opcnt, status, name),\n\tTP_STRUCT__entry(\n\t\t__field(u32, args_opcnt)\n\t\t__field(u32, resp_opcnt)\n\t\t__field(int, status)\n\t\t__string(name, name)\n\t),\n\tTP_fast_assign(\n\t\t__entry->args_opcnt = args_opcnt;\n\t\t__entry->resp_opcnt = resp_opcnt;\n\t\t__entry->status = be32_to_cpu(status);\n\t\t__assign_str(name, name);\n\t),\n\tTP_printk(\"op=%u/%u %s status=%d\",\n\t\t__entry->resp_opcnt, __entry->args_opcnt,\n\t\t__get_str(name), __entry->status)\n)\n\nTRACE_EVENT(nfsd_compound_decode_err,\n\tTP_PROTO(\n\t\tconst struct svc_rqst *rqstp,\n\t\tu32 args_opcnt,\n\t\tu32 resp_opcnt,\n\t\tu32 opnum,\n\t\t__be32 status\n\t),\n\tTP_ARGS(rqstp, args_opcnt, resp_opcnt, opnum, status),\n\tTP_STRUCT__entry(\n\t\tNFSD_TRACE_PROC_RES_FIELDS\n\n\t\t__field(u32, args_opcnt)\n\t\t__field(u32, resp_opcnt)\n\t\t__field(u32, opnum)\n\t),\n\tTP_fast_assign(\n\t\tNFSD_TRACE_PROC_RES_ASSIGNMENTS(status)\n\n\t\t__entry->args_opcnt = args_opcnt;\n\t\t__entry->resp_opcnt = resp_opcnt;\n\t\t__entry->opnum = opnum;\n\t),\n\tTP_printk(\"op=%u/%u opnum=%u status=%lu\",\n\t\t__entry->resp_opcnt, __entry->args_opcnt,\n\t\t__entry->opnum, __entry->status)\n);\n\nTRACE_EVENT(nfsd_compound_encode_err,\n\tTP_PROTO(\n\t\tconst struct svc_rqst *rqstp,\n\t\tu32 opnum,\n\t\t__be32 status\n\t),\n\tTP_ARGS(rqstp, opnum, status),\n\tTP_STRUCT__entry(\n\t\tNFSD_TRACE_PROC_RES_FIELDS\n\n\t\t__field(u32, opnum)\n\t),\n\tTP_fast_assign(\n\t\tNFSD_TRACE_PROC_RES_ASSIGNMENTS(status)\n\n\t\t__entry->opnum = opnum;\n\t),\n\tTP_printk(\"opnum=%u status=%lu\",\n\t\t__entry->opnum, __entry->status)\n);\n\n#define show_fs_file_type(x) \\\n\t__print_symbolic(x, \\\n\t\t{ S_IFLNK,\t\t\"LNK\" }, \\\n\t\t{ S_IFREG,\t\t\"REG\" }, \\\n\t\t{ S_IFDIR,\t\t\"DIR\" }, \\\n\t\t{ S_IFCHR,\t\t\"CHR\" }, \\\n\t\t{ S_IFBLK,\t\t\"BLK\" }, \\\n\t\t{ S_IFIFO,\t\t\"FIFO\" }, \\\n\t\t{ S_IFSOCK,\t\t\"SOCK\" })\n\nTRACE_EVENT(nfsd_fh_verify,\n\tTP_PROTO(\n\t\tconst struct svc_rqst *rqstp,\n\t\tconst struct svc_fh *fhp,\n\t\tumode_t type,\n\t\tint access\n\t),\n\tTP_ARGS(rqstp, fhp, type, access),\n\tTP_STRUCT__entry(\n\t\t__field(unsigned int, netns_ino)\n\t\t__sockaddr(server, rqstp->rq_xprt->xpt_remotelen)\n\t\t__sockaddr(client, rqstp->rq_xprt->xpt_remotelen)\n\t\t__field(u32, xid)\n\t\t__field(u32, fh_hash)\n\t\t__field(const void *, inode)\n\t\t__field(unsigned long, type)\n\t\t__field(unsigned long, access)\n\t),\n\tTP_fast_assign(\n\t\t__entry->netns_ino = SVC_NET(rqstp)->ns.inum;\n\t\t__assign_sockaddr(server, &rqstp->rq_xprt->xpt_local,\n\t\t       rqstp->rq_xprt->xpt_locallen);\n\t\t__assign_sockaddr(client, &rqstp->rq_xprt->xpt_remote,\n\t\t\t\t  rqstp->rq_xprt->xpt_remotelen);\n\t\t__entry->xid = be32_to_cpu(rqstp->rq_xid);\n\t\t__entry->fh_hash = knfsd_fh_hash(&fhp->fh_handle);\n\t\t__entry->inode = d_inode(fhp->fh_dentry);\n\t\t__entry->type = type;\n\t\t__entry->access = access;\n\t),\n\tTP_printk(\"xid=0x%08x fh_hash=0x%08x type=%s access=%s\",\n\t\t__entry->xid, __entry->fh_hash,\n\t\tshow_fs_file_type(__entry->type),\n\t\tshow_nfsd_may_flags(__entry->access)\n\t)\n);\n\nTRACE_EVENT_CONDITION(nfsd_fh_verify_err,\n\tTP_PROTO(\n\t\tconst struct svc_rqst *rqstp,\n\t\tconst struct svc_fh *fhp,\n\t\tumode_t type,\n\t\tint access,\n\t\t__be32 error\n\t),\n\tTP_ARGS(rqstp, fhp, type, access, error),\n\tTP_CONDITION(error),\n\tTP_STRUCT__entry(\n\t\t__field(unsigned int, netns_ino)\n\t\t__sockaddr(server, rqstp->rq_xprt->xpt_remotelen)\n\t\t__sockaddr(client, rqstp->rq_xprt->xpt_remotelen)\n\t\t__field(u32, xid)\n\t\t__field(u32, fh_hash)\n\t\t__field(const void *, inode)\n\t\t__field(unsigned long, type)\n\t\t__field(unsigned long, access)\n\t\t__field(int, error)\n\t),\n\tTP_fast_assign(\n\t\t__entry->netns_ino = SVC_NET(rqstp)->ns.inum;\n\t\t__assign_sockaddr(server, &rqstp->rq_xprt->xpt_local,\n\t\t       rqstp->rq_xprt->xpt_locallen);\n\t\t__assign_sockaddr(client, &rqstp->rq_xprt->xpt_remote,\n\t\t\t\t  rqstp->rq_xprt->xpt_remotelen);\n\t\t__entry->xid = be32_to_cpu(rqstp->rq_xid);\n\t\t__entry->fh_hash = knfsd_fh_hash(&fhp->fh_handle);\n\t\tif (fhp->fh_dentry)\n\t\t\t__entry->inode = d_inode(fhp->fh_dentry);\n\t\telse\n\t\t\t__entry->inode = NULL;\n\t\t__entry->type = type;\n\t\t__entry->access = access;\n\t\t__entry->error = be32_to_cpu(error);\n\t),\n\tTP_printk(\"xid=0x%08x fh_hash=0x%08x type=%s access=%s error=%d\",\n\t\t__entry->xid, __entry->fh_hash,\n\t\tshow_fs_file_type(__entry->type),\n\t\tshow_nfsd_may_flags(__entry->access),\n\t\t__entry->error\n\t)\n);\n\nDECLARE_EVENT_CLASS(nfsd_fh_err_class,\n\tTP_PROTO(struct svc_rqst *rqstp,\n\t\t struct svc_fh\t*fhp,\n\t\t int\t\tstatus),\n\tTP_ARGS(rqstp, fhp, status),\n\tTP_STRUCT__entry(\n\t\t__field(u32, xid)\n\t\t__field(u32, fh_hash)\n\t\t__field(int, status)\n\t),\n\tTP_fast_assign(\n\t\t__entry->xid = be32_to_cpu(rqstp->rq_xid);\n\t\t__entry->fh_hash = knfsd_fh_hash(&fhp->fh_handle);\n\t\t__entry->status = status;\n\t),\n\tTP_printk(\"xid=0x%08x fh_hash=0x%08x status=%d\",\n\t\t  __entry->xid, __entry->fh_hash,\n\t\t  __entry->status)\n)\n\n#define DEFINE_NFSD_FH_ERR_EVENT(name)\t\t\\\nDEFINE_EVENT(nfsd_fh_err_class, nfsd_##name,\t\\\n\tTP_PROTO(struct svc_rqst *rqstp,\t\\\n\t\t struct svc_fh\t*fhp,\t\t\\\n\t\t int\t\tstatus),\t\\\n\tTP_ARGS(rqstp, fhp, status))\n\nDEFINE_NFSD_FH_ERR_EVENT(set_fh_dentry_badexport);\nDEFINE_NFSD_FH_ERR_EVENT(set_fh_dentry_badhandle);\n\nTRACE_EVENT(nfsd_exp_find_key,\n\tTP_PROTO(const struct svc_expkey *key,\n\t\t int status),\n\tTP_ARGS(key, status),\n\tTP_STRUCT__entry(\n\t\t__field(int, fsidtype)\n\t\t__array(u32, fsid, 6)\n\t\t__string(auth_domain, key->ek_client->name)\n\t\t__field(int, status)\n\t),\n\tTP_fast_assign(\n\t\t__entry->fsidtype = key->ek_fsidtype;\n\t\tmemcpy(__entry->fsid, key->ek_fsid, 4*6);\n\t\t__assign_str(auth_domain, key->ek_client->name);\n\t\t__entry->status = status;\n\t),\n\tTP_printk(\"fsid=%x::%s domain=%s status=%d\",\n\t\t__entry->fsidtype,\n\t\t__print_array(__entry->fsid, 6, 4),\n\t\t__get_str(auth_domain),\n\t\t__entry->status\n\t)\n);\n\nTRACE_EVENT(nfsd_expkey_update,\n\tTP_PROTO(const struct svc_expkey *key, const char *exp_path),\n\tTP_ARGS(key, exp_path),\n\tTP_STRUCT__entry(\n\t\t__field(int, fsidtype)\n\t\t__array(u32, fsid, 6)\n\t\t__string(auth_domain, key->ek_client->name)\n\t\t__string(path, exp_path)\n\t\t__field(bool, cache)\n\t),\n\tTP_fast_assign(\n\t\t__entry->fsidtype = key->ek_fsidtype;\n\t\tmemcpy(__entry->fsid, key->ek_fsid, 4*6);\n\t\t__assign_str(auth_domain, key->ek_client->name);\n\t\t__assign_str(path, exp_path);\n\t\t__entry->cache = !test_bit(CACHE_NEGATIVE, &key->h.flags);\n\t),\n\tTP_printk(\"fsid=%x::%s domain=%s path=%s cache=%s\",\n\t\t__entry->fsidtype,\n\t\t__print_array(__entry->fsid, 6, 4),\n\t\t__get_str(auth_domain),\n\t\t__get_str(path),\n\t\t__entry->cache ? \"pos\" : \"neg\"\n\t)\n);\n\nTRACE_EVENT(nfsd_exp_get_by_name,\n\tTP_PROTO(const struct svc_export *key,\n\t\t int status),\n\tTP_ARGS(key, status),\n\tTP_STRUCT__entry(\n\t\t__string(path, key->ex_path.dentry->d_name.name)\n\t\t__string(auth_domain, key->ex_client->name)\n\t\t__field(int, status)\n\t),\n\tTP_fast_assign(\n\t\t__assign_str(path, key->ex_path.dentry->d_name.name);\n\t\t__assign_str(auth_domain, key->ex_client->name);\n\t\t__entry->status = status;\n\t),\n\tTP_printk(\"path=%s domain=%s status=%d\",\n\t\t__get_str(path),\n\t\t__get_str(auth_domain),\n\t\t__entry->status\n\t)\n);\n\nTRACE_EVENT(nfsd_export_update,\n\tTP_PROTO(const struct svc_export *key),\n\tTP_ARGS(key),\n\tTP_STRUCT__entry(\n\t\t__string(path, key->ex_path.dentry->d_name.name)\n\t\t__string(auth_domain, key->ex_client->name)\n\t\t__field(bool, cache)\n\t),\n\tTP_fast_assign(\n\t\t__assign_str(path, key->ex_path.dentry->d_name.name);\n\t\t__assign_str(auth_domain, key->ex_client->name);\n\t\t__entry->cache = !test_bit(CACHE_NEGATIVE, &key->h.flags);\n\t),\n\tTP_printk(\"path=%s domain=%s cache=%s\",\n\t\t__get_str(path),\n\t\t__get_str(auth_domain),\n\t\t__entry->cache ? \"pos\" : \"neg\"\n\t)\n);\n\nDECLARE_EVENT_CLASS(nfsd_io_class,\n\tTP_PROTO(struct svc_rqst *rqstp,\n\t\t struct svc_fh\t*fhp,\n\t\t u64\t\toffset,\n\t\t u32\t\tlen),\n\tTP_ARGS(rqstp, fhp, offset, len),\n\tTP_STRUCT__entry(\n\t\t__field(u32, xid)\n\t\t__field(u32, fh_hash)\n\t\t__field(u64, offset)\n\t\t__field(u32, len)\n\t),\n\tTP_fast_assign(\n\t\t__entry->xid = be32_to_cpu(rqstp->rq_xid);\n\t\t__entry->fh_hash = knfsd_fh_hash(&fhp->fh_handle);\n\t\t__entry->offset = offset;\n\t\t__entry->len = len;\n\t),\n\tTP_printk(\"xid=0x%08x fh_hash=0x%08x offset=%llu len=%u\",\n\t\t  __entry->xid, __entry->fh_hash,\n\t\t  __entry->offset, __entry->len)\n)\n\n#define DEFINE_NFSD_IO_EVENT(name)\t\t\\\nDEFINE_EVENT(nfsd_io_class, nfsd_##name,\t\\\n\tTP_PROTO(struct svc_rqst *rqstp,\t\\\n\t\t struct svc_fh\t*fhp,\t\t\\\n\t\t u64\t\toffset,\t\t\\\n\t\t u32\t\tlen),\t\t\\\n\tTP_ARGS(rqstp, fhp, offset, len))\n\nDEFINE_NFSD_IO_EVENT(read_start);\nDEFINE_NFSD_IO_EVENT(read_splice);\nDEFINE_NFSD_IO_EVENT(read_vector);\nDEFINE_NFSD_IO_EVENT(read_io_done);\nDEFINE_NFSD_IO_EVENT(read_done);\nDEFINE_NFSD_IO_EVENT(write_start);\nDEFINE_NFSD_IO_EVENT(write_opened);\nDEFINE_NFSD_IO_EVENT(write_io_done);\nDEFINE_NFSD_IO_EVENT(write_done);\n\nDECLARE_EVENT_CLASS(nfsd_err_class,\n\tTP_PROTO(struct svc_rqst *rqstp,\n\t\t struct svc_fh\t*fhp,\n\t\t loff_t\t\toffset,\n\t\t int\t\tstatus),\n\tTP_ARGS(rqstp, fhp, offset, status),\n\tTP_STRUCT__entry(\n\t\t__field(u32, xid)\n\t\t__field(u32, fh_hash)\n\t\t__field(loff_t, offset)\n\t\t__field(int, status)\n\t),\n\tTP_fast_assign(\n\t\t__entry->xid = be32_to_cpu(rqstp->rq_xid);\n\t\t__entry->fh_hash = knfsd_fh_hash(&fhp->fh_handle);\n\t\t__entry->offset = offset;\n\t\t__entry->status = status;\n\t),\n\tTP_printk(\"xid=0x%08x fh_hash=0x%08x offset=%lld status=%d\",\n\t\t  __entry->xid, __entry->fh_hash,\n\t\t  __entry->offset, __entry->status)\n)\n\n#define DEFINE_NFSD_ERR_EVENT(name)\t\t\\\nDEFINE_EVENT(nfsd_err_class, nfsd_##name,\t\\\n\tTP_PROTO(struct svc_rqst *rqstp,\t\\\n\t\t struct svc_fh\t*fhp,\t\t\\\n\t\t loff_t\t\toffset,\t\t\\\n\t\t int\t\tlen),\t\t\\\n\tTP_ARGS(rqstp, fhp, offset, len))\n\nDEFINE_NFSD_ERR_EVENT(read_err);\nDEFINE_NFSD_ERR_EVENT(write_err);\n\nTRACE_EVENT(nfsd_dirent,\n\tTP_PROTO(struct svc_fh *fhp,\n\t\t u64 ino,\n\t\t const char *name,\n\t\t int namlen),\n\tTP_ARGS(fhp, ino, name, namlen),\n\tTP_STRUCT__entry(\n\t\t__field(u32, fh_hash)\n\t\t__field(u64, ino)\n\t\t__string_len(name, name, namlen)\n\t),\n\tTP_fast_assign(\n\t\t__entry->fh_hash = fhp ? knfsd_fh_hash(&fhp->fh_handle) : 0;\n\t\t__entry->ino = ino;\n\t\t__assign_str_len(name, name, namlen)\n\t),\n\tTP_printk(\"fh_hash=0x%08x ino=%llu name=%s\",\n\t\t__entry->fh_hash, __entry->ino, __get_str(name)\n\t)\n)\n\nDECLARE_EVENT_CLASS(nfsd_copy_err_class,\n\tTP_PROTO(struct svc_rqst *rqstp,\n\t\t struct svc_fh\t*src_fhp,\n\t\t loff_t\t\tsrc_offset,\n\t\t struct svc_fh\t*dst_fhp,\n\t\t loff_t\t\tdst_offset,\n\t\t u64\t\tcount,\n\t\t int\t\tstatus),\n\tTP_ARGS(rqstp, src_fhp, src_offset, dst_fhp, dst_offset, count, status),\n\tTP_STRUCT__entry(\n\t\t__field(u32, xid)\n\t\t__field(u32, src_fh_hash)\n\t\t__field(loff_t, src_offset)\n\t\t__field(u32, dst_fh_hash)\n\t\t__field(loff_t, dst_offset)\n\t\t__field(u64, count)\n\t\t__field(int, status)\n\t),\n\tTP_fast_assign(\n\t\t__entry->xid = be32_to_cpu(rqstp->rq_xid);\n\t\t__entry->src_fh_hash = knfsd_fh_hash(&src_fhp->fh_handle);\n\t\t__entry->src_offset = src_offset;\n\t\t__entry->dst_fh_hash = knfsd_fh_hash(&dst_fhp->fh_handle);\n\t\t__entry->dst_offset = dst_offset;\n\t\t__entry->count = count;\n\t\t__entry->status = status;\n\t),\n\tTP_printk(\"xid=0x%08x src_fh_hash=0x%08x src_offset=%lld \"\n\t\t\t\"dst_fh_hash=0x%08x dst_offset=%lld \"\n\t\t\t\"count=%llu status=%d\",\n\t\t  __entry->xid, __entry->src_fh_hash, __entry->src_offset,\n\t\t  __entry->dst_fh_hash, __entry->dst_offset,\n\t\t  (unsigned long long)__entry->count,\n\t\t  __entry->status)\n)\n\n#define DEFINE_NFSD_COPY_ERR_EVENT(name)\t\t\\\nDEFINE_EVENT(nfsd_copy_err_class, nfsd_##name,\t\t\\\n\tTP_PROTO(struct svc_rqst\t*rqstp,\t\t\\\n\t\t struct svc_fh\t\t*src_fhp,\t\\\n\t\t loff_t\t\t\tsrc_offset,\t\\\n\t\t struct svc_fh\t\t*dst_fhp,\t\\\n\t\t loff_t\t\t\tdst_offset,\t\\\n\t\t u64\t\t\tcount,\t\t\\\n\t\t int\t\t\tstatus),\t\\\n\tTP_ARGS(rqstp, src_fhp, src_offset, dst_fhp, dst_offset, \\\n\t\tcount, status))\n\nDEFINE_NFSD_COPY_ERR_EVENT(clone_file_range_err);\n\n#include \"state.h\"\n#include \"filecache.h\"\n#include \"vfs.h\"\n\nTRACE_EVENT(nfsd_delegret_wakeup,\n\tTP_PROTO(\n\t\tconst struct svc_rqst *rqstp,\n\t\tconst struct inode *inode,\n\t\tlong timeo\n\t),\n\tTP_ARGS(rqstp, inode, timeo),\n\tTP_STRUCT__entry(\n\t\t__field(u32, xid)\n\t\t__field(const void *, inode)\n\t\t__field(long, timeo)\n\t),\n\tTP_fast_assign(\n\t\t__entry->xid = be32_to_cpu(rqstp->rq_xid);\n\t\t__entry->inode = inode;\n\t\t__entry->timeo = timeo;\n\t),\n\tTP_printk(\"xid=0x%08x inode=%p%s\",\n\t\t  __entry->xid, __entry->inode,\n\t\t  __entry->timeo == 0 ? \" (timed out)\" : \"\"\n\t)\n);\n\nDECLARE_EVENT_CLASS(nfsd_stateid_class,\n\tTP_PROTO(stateid_t *stp),\n\tTP_ARGS(stp),\n\tTP_STRUCT__entry(\n\t\t__field(u32, cl_boot)\n\t\t__field(u32, cl_id)\n\t\t__field(u32, si_id)\n\t\t__field(u32, si_generation)\n\t),\n\tTP_fast_assign(\n\t\t__entry->cl_boot = stp->si_opaque.so_clid.cl_boot;\n\t\t__entry->cl_id = stp->si_opaque.so_clid.cl_id;\n\t\t__entry->si_id = stp->si_opaque.so_id;\n\t\t__entry->si_generation = stp->si_generation;\n\t),\n\tTP_printk(\"client %08x:%08x stateid %08x:%08x\",\n\t\t__entry->cl_boot,\n\t\t__entry->cl_id,\n\t\t__entry->si_id,\n\t\t__entry->si_generation)\n)\n\n#define DEFINE_STATEID_EVENT(name) \\\nDEFINE_EVENT(nfsd_stateid_class, nfsd_##name, \\\n\tTP_PROTO(stateid_t *stp), \\\n\tTP_ARGS(stp))\n\nDEFINE_STATEID_EVENT(layoutstate_alloc);\nDEFINE_STATEID_EVENT(layoutstate_unhash);\nDEFINE_STATEID_EVENT(layoutstate_free);\nDEFINE_STATEID_EVENT(layout_get_lookup_fail);\nDEFINE_STATEID_EVENT(layout_commit_lookup_fail);\nDEFINE_STATEID_EVENT(layout_return_lookup_fail);\nDEFINE_STATEID_EVENT(layout_recall);\nDEFINE_STATEID_EVENT(layout_recall_done);\nDEFINE_STATEID_EVENT(layout_recall_fail);\nDEFINE_STATEID_EVENT(layout_recall_release);\n\nDEFINE_STATEID_EVENT(open);\nDEFINE_STATEID_EVENT(deleg_read);\nDEFINE_STATEID_EVENT(deleg_write);\nDEFINE_STATEID_EVENT(deleg_return);\nDEFINE_STATEID_EVENT(deleg_recall);\n\nDECLARE_EVENT_CLASS(nfsd_stateseqid_class,\n\tTP_PROTO(u32 seqid, const stateid_t *stp),\n\tTP_ARGS(seqid, stp),\n\tTP_STRUCT__entry(\n\t\t__field(u32, seqid)\n\t\t__field(u32, cl_boot)\n\t\t__field(u32, cl_id)\n\t\t__field(u32, si_id)\n\t\t__field(u32, si_generation)\n\t),\n\tTP_fast_assign(\n\t\t__entry->seqid = seqid;\n\t\t__entry->cl_boot = stp->si_opaque.so_clid.cl_boot;\n\t\t__entry->cl_id = stp->si_opaque.so_clid.cl_id;\n\t\t__entry->si_id = stp->si_opaque.so_id;\n\t\t__entry->si_generation = stp->si_generation;\n\t),\n\tTP_printk(\"seqid=%u client %08x:%08x stateid %08x:%08x\",\n\t\t__entry->seqid, __entry->cl_boot, __entry->cl_id,\n\t\t__entry->si_id, __entry->si_generation)\n)\n\n#define DEFINE_STATESEQID_EVENT(name) \\\nDEFINE_EVENT(nfsd_stateseqid_class, nfsd_##name, \\\n\tTP_PROTO(u32 seqid, const stateid_t *stp), \\\n\tTP_ARGS(seqid, stp))\n\nDEFINE_STATESEQID_EVENT(preprocess);\nDEFINE_STATESEQID_EVENT(open_confirm);\n\nTRACE_DEFINE_ENUM(NFS4_OPEN_STID);\nTRACE_DEFINE_ENUM(NFS4_LOCK_STID);\nTRACE_DEFINE_ENUM(NFS4_DELEG_STID);\nTRACE_DEFINE_ENUM(NFS4_CLOSED_STID);\nTRACE_DEFINE_ENUM(NFS4_REVOKED_DELEG_STID);\nTRACE_DEFINE_ENUM(NFS4_CLOSED_DELEG_STID);\nTRACE_DEFINE_ENUM(NFS4_LAYOUT_STID);\n\n#define show_stid_type(x)\t\t\t\t\t\t\\\n\t__print_flags(x, \"|\",\t\t\t\t\t\t\\\n\t\t{ NFS4_OPEN_STID,\t\t\"OPEN\" },\t\t\\\n\t\t{ NFS4_LOCK_STID,\t\t\"LOCK\" },\t\t\\\n\t\t{ NFS4_DELEG_STID,\t\t\"DELEG\" },\t\t\\\n\t\t{ NFS4_CLOSED_STID,\t\t\"CLOSED\" },\t\t\\\n\t\t{ NFS4_REVOKED_DELEG_STID,\t\"REVOKED\" },\t\t\\\n\t\t{ NFS4_CLOSED_DELEG_STID,\t\"CLOSED_DELEG\" },\t\\\n\t\t{ NFS4_LAYOUT_STID,\t\t\"LAYOUT\" })\n\nDECLARE_EVENT_CLASS(nfsd_stid_class,\n\tTP_PROTO(\n\t\tconst struct nfs4_stid *stid\n\t),\n\tTP_ARGS(stid),\n\tTP_STRUCT__entry(\n\t\t__field(unsigned long, sc_type)\n\t\t__field(int, sc_count)\n\t\t__field(u32, cl_boot)\n\t\t__field(u32, cl_id)\n\t\t__field(u32, si_id)\n\t\t__field(u32, si_generation)\n\t),\n\tTP_fast_assign(\n\t\tconst stateid_t *stp = &stid->sc_stateid;\n\n\t\t__entry->sc_type = stid->sc_type;\n\t\t__entry->sc_count = refcount_read(&stid->sc_count);\n\t\t__entry->cl_boot = stp->si_opaque.so_clid.cl_boot;\n\t\t__entry->cl_id = stp->si_opaque.so_clid.cl_id;\n\t\t__entry->si_id = stp->si_opaque.so_id;\n\t\t__entry->si_generation = stp->si_generation;\n\t),\n\tTP_printk(\"client %08x:%08x stateid %08x:%08x ref=%d type=%s\",\n\t\t__entry->cl_boot, __entry->cl_id,\n\t\t__entry->si_id, __entry->si_generation,\n\t\t__entry->sc_count, show_stid_type(__entry->sc_type)\n\t)\n);\n\n#define DEFINE_STID_EVENT(name)\t\t\t\t\t\\\nDEFINE_EVENT(nfsd_stid_class, nfsd_stid_##name,\t\t\t\\\n\tTP_PROTO(const struct nfs4_stid *stid),\t\t\t\\\n\tTP_ARGS(stid))\n\nDEFINE_STID_EVENT(revoke);\n\nDECLARE_EVENT_CLASS(nfsd_clientid_class,\n\tTP_PROTO(const clientid_t *clid),\n\tTP_ARGS(clid),\n\tTP_STRUCT__entry(\n\t\t__field(u32, cl_boot)\n\t\t__field(u32, cl_id)\n\t),\n\tTP_fast_assign(\n\t\t__entry->cl_boot = clid->cl_boot;\n\t\t__entry->cl_id = clid->cl_id;\n\t),\n\tTP_printk(\"client %08x:%08x\", __entry->cl_boot, __entry->cl_id)\n)\n\n#define DEFINE_CLIENTID_EVENT(name) \\\nDEFINE_EVENT(nfsd_clientid_class, nfsd_clid_##name, \\\n\tTP_PROTO(const clientid_t *clid), \\\n\tTP_ARGS(clid))\n\nDEFINE_CLIENTID_EVENT(expire_unconf);\nDEFINE_CLIENTID_EVENT(reclaim_complete);\nDEFINE_CLIENTID_EVENT(confirmed);\nDEFINE_CLIENTID_EVENT(destroyed);\nDEFINE_CLIENTID_EVENT(admin_expired);\nDEFINE_CLIENTID_EVENT(replaced);\nDEFINE_CLIENTID_EVENT(purged);\nDEFINE_CLIENTID_EVENT(renew);\nDEFINE_CLIENTID_EVENT(stale);\n\nDECLARE_EVENT_CLASS(nfsd_net_class,\n\tTP_PROTO(const struct nfsd_net *nn),\n\tTP_ARGS(nn),\n\tTP_STRUCT__entry(\n\t\t__field(unsigned long long, boot_time)\n\t),\n\tTP_fast_assign(\n\t\t__entry->boot_time = nn->boot_time;\n\t),\n\tTP_printk(\"boot_time=%16llx\", __entry->boot_time)\n)\n\n#define DEFINE_NET_EVENT(name) \\\nDEFINE_EVENT(nfsd_net_class, nfsd_##name, \\\n\tTP_PROTO(const struct nfsd_net *nn), \\\n\tTP_ARGS(nn))\n\nDEFINE_NET_EVENT(grace_start);\nDEFINE_NET_EVENT(grace_complete);\n\nTRACE_EVENT(nfsd_writeverf_reset,\n\tTP_PROTO(\n\t\tconst struct nfsd_net *nn,\n\t\tconst struct svc_rqst *rqstp,\n\t\tint error\n\t),\n\tTP_ARGS(nn, rqstp, error),\n\tTP_STRUCT__entry(\n\t\t__field(unsigned long long, boot_time)\n\t\t__field(u32, xid)\n\t\t__field(int, error)\n\t\t__array(unsigned char, verifier, NFS4_VERIFIER_SIZE)\n\t),\n\tTP_fast_assign(\n\t\t__entry->boot_time = nn->boot_time;\n\t\t__entry->xid = be32_to_cpu(rqstp->rq_xid);\n\t\t__entry->error = error;\n\n\t\t \n\t\tmemcpy(__entry->verifier, nn->writeverf,\n\t\t       NFS4_VERIFIER_SIZE);\n\t),\n\tTP_printk(\"boot_time=%16llx xid=0x%08x error=%d new verifier=0x%s\",\n\t\t__entry->boot_time, __entry->xid, __entry->error,\n\t\t__print_hex_str(__entry->verifier, NFS4_VERIFIER_SIZE)\n\t)\n);\n\nTRACE_EVENT(nfsd_clid_cred_mismatch,\n\tTP_PROTO(\n\t\tconst struct nfs4_client *clp,\n\t\tconst struct svc_rqst *rqstp\n\t),\n\tTP_ARGS(clp, rqstp),\n\tTP_STRUCT__entry(\n\t\t__field(u32, cl_boot)\n\t\t__field(u32, cl_id)\n\t\t__field(unsigned long, cl_flavor)\n\t\t__field(unsigned long, new_flavor)\n\t\t__sockaddr(addr, rqstp->rq_xprt->xpt_remotelen)\n\t),\n\tTP_fast_assign(\n\t\t__entry->cl_boot = clp->cl_clientid.cl_boot;\n\t\t__entry->cl_id = clp->cl_clientid.cl_id;\n\t\t__entry->cl_flavor = clp->cl_cred.cr_flavor;\n\t\t__entry->new_flavor = rqstp->rq_cred.cr_flavor;\n\t\t__assign_sockaddr(addr, &rqstp->rq_xprt->xpt_remote,\n\t\t\t\t  rqstp->rq_xprt->xpt_remotelen);\n\t),\n\tTP_printk(\"client %08x:%08x flavor=%s, conflict=%s from addr=%pISpc\",\n\t\t__entry->cl_boot, __entry->cl_id,\n\t\tshow_nfsd_authflavor(__entry->cl_flavor),\n\t\tshow_nfsd_authflavor(__entry->new_flavor),\n\t\t__get_sockaddr(addr)\n\t)\n)\n\nTRACE_EVENT(nfsd_clid_verf_mismatch,\n\tTP_PROTO(\n\t\tconst struct nfs4_client *clp,\n\t\tconst struct svc_rqst *rqstp,\n\t\tconst nfs4_verifier *verf\n\t),\n\tTP_ARGS(clp, rqstp, verf),\n\tTP_STRUCT__entry(\n\t\t__field(u32, cl_boot)\n\t\t__field(u32, cl_id)\n\t\t__array(unsigned char, cl_verifier, NFS4_VERIFIER_SIZE)\n\t\t__array(unsigned char, new_verifier, NFS4_VERIFIER_SIZE)\n\t\t__sockaddr(addr, rqstp->rq_xprt->xpt_remotelen)\n\t),\n\tTP_fast_assign(\n\t\t__entry->cl_boot = clp->cl_clientid.cl_boot;\n\t\t__entry->cl_id = clp->cl_clientid.cl_id;\n\t\tmemcpy(__entry->cl_verifier, (void *)&clp->cl_verifier,\n\t\t       NFS4_VERIFIER_SIZE);\n\t\tmemcpy(__entry->new_verifier, (void *)verf,\n\t\t       NFS4_VERIFIER_SIZE);\n\t\t__assign_sockaddr(addr, &rqstp->rq_xprt->xpt_remote,\n\t\t\t\t  rqstp->rq_xprt->xpt_remotelen);\n\t),\n\tTP_printk(\"client %08x:%08x verf=0x%s, updated=0x%s from addr=%pISpc\",\n\t\t__entry->cl_boot, __entry->cl_id,\n\t\t__print_hex_str(__entry->cl_verifier, NFS4_VERIFIER_SIZE),\n\t\t__print_hex_str(__entry->new_verifier, NFS4_VERIFIER_SIZE),\n\t\t__get_sockaddr(addr)\n\t)\n);\n\nDECLARE_EVENT_CLASS(nfsd_clid_class,\n\tTP_PROTO(const struct nfs4_client *clp),\n\tTP_ARGS(clp),\n\tTP_STRUCT__entry(\n\t\t__field(u32, cl_boot)\n\t\t__field(u32, cl_id)\n\t\t__array(unsigned char, addr, sizeof(struct sockaddr_in6))\n\t\t__field(unsigned long, flavor)\n\t\t__array(unsigned char, verifier, NFS4_VERIFIER_SIZE)\n\t\t__string_len(name, name, clp->cl_name.len)\n\t),\n\tTP_fast_assign(\n\t\t__entry->cl_boot = clp->cl_clientid.cl_boot;\n\t\t__entry->cl_id = clp->cl_clientid.cl_id;\n\t\tmemcpy(__entry->addr, &clp->cl_addr,\n\t\t\tsizeof(struct sockaddr_in6));\n\t\t__entry->flavor = clp->cl_cred.cr_flavor;\n\t\tmemcpy(__entry->verifier, (void *)&clp->cl_verifier,\n\t\t       NFS4_VERIFIER_SIZE);\n\t\t__assign_str_len(name, clp->cl_name.data, clp->cl_name.len);\n\t),\n\tTP_printk(\"addr=%pISpc name='%s' verifier=0x%s flavor=%s client=%08x:%08x\",\n\t\t__entry->addr, __get_str(name),\n\t\t__print_hex_str(__entry->verifier, NFS4_VERIFIER_SIZE),\n\t\tshow_nfsd_authflavor(__entry->flavor),\n\t\t__entry->cl_boot, __entry->cl_id)\n);\n\n#define DEFINE_CLID_EVENT(name) \\\nDEFINE_EVENT(nfsd_clid_class, nfsd_clid_##name, \\\n\tTP_PROTO(const struct nfs4_client *clp), \\\n\tTP_ARGS(clp))\n\nDEFINE_CLID_EVENT(fresh);\nDEFINE_CLID_EVENT(confirmed_r);\n\n \n#define show_nf_flags(val)\t\t\t\t\t\t\\\n\t__print_flags(val, \"|\",\t\t\t\t\t\t\\\n\t\t{ 1 << NFSD_FILE_HASHED,\t\"HASHED\" },\t\t\\\n\t\t{ 1 << NFSD_FILE_PENDING,\t\"PENDING\" },\t\t\\\n\t\t{ 1 << NFSD_FILE_REFERENCED,\t\"REFERENCED\" },\t\t\\\n\t\t{ 1 << NFSD_FILE_GC,\t\t\"GC\" })\n\nDECLARE_EVENT_CLASS(nfsd_file_class,\n\tTP_PROTO(struct nfsd_file *nf),\n\tTP_ARGS(nf),\n\tTP_STRUCT__entry(\n\t\t__field(void *, nf_inode)\n\t\t__field(int, nf_ref)\n\t\t__field(unsigned long, nf_flags)\n\t\t__field(unsigned char, nf_may)\n\t\t__field(struct file *, nf_file)\n\t),\n\tTP_fast_assign(\n\t\t__entry->nf_inode = nf->nf_inode;\n\t\t__entry->nf_ref = refcount_read(&nf->nf_ref);\n\t\t__entry->nf_flags = nf->nf_flags;\n\t\t__entry->nf_may = nf->nf_may;\n\t\t__entry->nf_file = nf->nf_file;\n\t),\n\tTP_printk(\"inode=%p ref=%d flags=%s may=%s nf_file=%p\",\n\t\t__entry->nf_inode,\n\t\t__entry->nf_ref,\n\t\tshow_nf_flags(__entry->nf_flags),\n\t\tshow_nfsd_may_flags(__entry->nf_may),\n\t\t__entry->nf_file)\n)\n\n#define DEFINE_NFSD_FILE_EVENT(name) \\\nDEFINE_EVENT(nfsd_file_class, name, \\\n\tTP_PROTO(struct nfsd_file *nf), \\\n\tTP_ARGS(nf))\n\nDEFINE_NFSD_FILE_EVENT(nfsd_file_free);\nDEFINE_NFSD_FILE_EVENT(nfsd_file_unhash);\nDEFINE_NFSD_FILE_EVENT(nfsd_file_put);\nDEFINE_NFSD_FILE_EVENT(nfsd_file_closing);\nDEFINE_NFSD_FILE_EVENT(nfsd_file_unhash_and_queue);\n\nTRACE_EVENT(nfsd_file_alloc,\n\tTP_PROTO(\n\t\tconst struct nfsd_file *nf\n\t),\n\tTP_ARGS(nf),\n\tTP_STRUCT__entry(\n\t\t__field(const void *, nf_inode)\n\t\t__field(unsigned long, nf_flags)\n\t\t__field(unsigned long, nf_may)\n\t\t__field(unsigned int, nf_ref)\n\t),\n\tTP_fast_assign(\n\t\t__entry->nf_inode = nf->nf_inode;\n\t\t__entry->nf_flags = nf->nf_flags;\n\t\t__entry->nf_ref = refcount_read(&nf->nf_ref);\n\t\t__entry->nf_may = nf->nf_may;\n\t),\n\tTP_printk(\"inode=%p ref=%u flags=%s may=%s\",\n\t\t__entry->nf_inode, __entry->nf_ref,\n\t\tshow_nf_flags(__entry->nf_flags),\n\t\tshow_nfsd_may_flags(__entry->nf_may)\n\t)\n);\n\nTRACE_EVENT(nfsd_file_acquire,\n\tTP_PROTO(\n\t\tconst struct svc_rqst *rqstp,\n\t\tconst struct inode *inode,\n\t\tunsigned int may_flags,\n\t\tconst struct nfsd_file *nf,\n\t\t__be32 status\n\t),\n\n\tTP_ARGS(rqstp, inode, may_flags, nf, status),\n\n\tTP_STRUCT__entry(\n\t\t__field(u32, xid)\n\t\t__field(const void *, inode)\n\t\t__field(unsigned long, may_flags)\n\t\t__field(unsigned int, nf_ref)\n\t\t__field(unsigned long, nf_flags)\n\t\t__field(unsigned long, nf_may)\n\t\t__field(const void *, nf_file)\n\t\t__field(u32, status)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->xid = be32_to_cpu(rqstp->rq_xid);\n\t\t__entry->inode = inode;\n\t\t__entry->may_flags = may_flags;\n\t\t__entry->nf_ref = nf ? refcount_read(&nf->nf_ref) : 0;\n\t\t__entry->nf_flags = nf ? nf->nf_flags : 0;\n\t\t__entry->nf_may = nf ? nf->nf_may : 0;\n\t\t__entry->nf_file = nf ? nf->nf_file : NULL;\n\t\t__entry->status = be32_to_cpu(status);\n\t),\n\n\tTP_printk(\"xid=0x%x inode=%p may_flags=%s ref=%u nf_flags=%s nf_may=%s nf_file=%p status=%u\",\n\t\t\t__entry->xid, __entry->inode,\n\t\t\tshow_nfsd_may_flags(__entry->may_flags),\n\t\t\t__entry->nf_ref, show_nf_flags(__entry->nf_flags),\n\t\t\tshow_nfsd_may_flags(__entry->nf_may),\n\t\t\t__entry->nf_file, __entry->status\n\t)\n);\n\nTRACE_EVENT(nfsd_file_insert_err,\n\tTP_PROTO(\n\t\tconst struct svc_rqst *rqstp,\n\t\tconst struct inode *inode,\n\t\tunsigned int may_flags,\n\t\tlong error\n\t),\n\tTP_ARGS(rqstp, inode, may_flags, error),\n\tTP_STRUCT__entry(\n\t\t__field(u32, xid)\n\t\t__field(const void *, inode)\n\t\t__field(unsigned long, may_flags)\n\t\t__field(long, error)\n\t),\n\tTP_fast_assign(\n\t\t__entry->xid = be32_to_cpu(rqstp->rq_xid);\n\t\t__entry->inode = inode;\n\t\t__entry->may_flags = may_flags;\n\t\t__entry->error = error;\n\t),\n\tTP_printk(\"xid=0x%x inode=%p may_flags=%s error=%ld\",\n\t\t__entry->xid, __entry->inode,\n\t\tshow_nfsd_may_flags(__entry->may_flags),\n\t\t__entry->error\n\t)\n);\n\nTRACE_EVENT(nfsd_file_cons_err,\n\tTP_PROTO(\n\t\tconst struct svc_rqst *rqstp,\n\t\tconst struct inode *inode,\n\t\tunsigned int may_flags,\n\t\tconst struct nfsd_file *nf\n\t),\n\tTP_ARGS(rqstp, inode, may_flags, nf),\n\tTP_STRUCT__entry(\n\t\t__field(u32, xid)\n\t\t__field(const void *, inode)\n\t\t__field(unsigned long, may_flags)\n\t\t__field(unsigned int, nf_ref)\n\t\t__field(unsigned long, nf_flags)\n\t\t__field(unsigned long, nf_may)\n\t\t__field(const void *, nf_file)\n\t),\n\tTP_fast_assign(\n\t\t__entry->xid = be32_to_cpu(rqstp->rq_xid);\n\t\t__entry->inode = inode;\n\t\t__entry->may_flags = may_flags;\n\t\t__entry->nf_ref = refcount_read(&nf->nf_ref);\n\t\t__entry->nf_flags = nf->nf_flags;\n\t\t__entry->nf_may = nf->nf_may;\n\t\t__entry->nf_file = nf->nf_file;\n\t),\n\tTP_printk(\"xid=0x%x inode=%p may_flags=%s ref=%u nf_flags=%s nf_may=%s nf_file=%p\",\n\t\t__entry->xid, __entry->inode,\n\t\tshow_nfsd_may_flags(__entry->may_flags), __entry->nf_ref,\n\t\tshow_nf_flags(__entry->nf_flags),\n\t\tshow_nfsd_may_flags(__entry->nf_may), __entry->nf_file\n\t)\n);\n\nDECLARE_EVENT_CLASS(nfsd_file_open_class,\n\tTP_PROTO(const struct nfsd_file *nf, __be32 status),\n\tTP_ARGS(nf, status),\n\tTP_STRUCT__entry(\n\t\t__field(void *, nf_inode)\t \n\t\t__field(int, nf_ref)\n\t\t__field(unsigned long, nf_flags)\n\t\t__field(unsigned long, nf_may)\n\t\t__field(void *, nf_file)\t \n\t),\n\tTP_fast_assign(\n\t\t__entry->nf_inode = nf->nf_inode;\n\t\t__entry->nf_ref = refcount_read(&nf->nf_ref);\n\t\t__entry->nf_flags = nf->nf_flags;\n\t\t__entry->nf_may = nf->nf_may;\n\t\t__entry->nf_file = nf->nf_file;\n\t),\n\tTP_printk(\"inode=%p ref=%d flags=%s may=%s file=%p\",\n\t\t__entry->nf_inode,\n\t\t__entry->nf_ref,\n\t\tshow_nf_flags(__entry->nf_flags),\n\t\tshow_nfsd_may_flags(__entry->nf_may),\n\t\t__entry->nf_file)\n)\n\n#define DEFINE_NFSD_FILE_OPEN_EVENT(name)\t\t\t\t\t\\\nDEFINE_EVENT(nfsd_file_open_class, name,\t\t\t\t\t\\\n\tTP_PROTO(\t\t\t\t\t\t\t\\\n\t\tconst struct nfsd_file *nf,\t\t\t\t\\\n\t\t__be32 status\t\t\t\t\t\t\\\n\t),\t\t\t\t\t\t\t\t\\\n\tTP_ARGS(nf, status))\n\nDEFINE_NFSD_FILE_OPEN_EVENT(nfsd_file_open);\nDEFINE_NFSD_FILE_OPEN_EVENT(nfsd_file_opened);\n\nTRACE_EVENT(nfsd_file_is_cached,\n\tTP_PROTO(\n\t\tconst struct inode *inode,\n\t\tint found\n\t),\n\tTP_ARGS(inode, found),\n\tTP_STRUCT__entry(\n\t\t__field(const struct inode *, inode)\n\t\t__field(int, found)\n\t),\n\tTP_fast_assign(\n\t\t__entry->inode = inode;\n\t\t__entry->found = found;\n\t),\n\tTP_printk(\"inode=%p is %scached\",\n\t\t__entry->inode,\n\t\t__entry->found ? \"\" : \"not \"\n\t)\n);\n\nTRACE_EVENT(nfsd_file_fsnotify_handle_event,\n\tTP_PROTO(struct inode *inode, u32 mask),\n\tTP_ARGS(inode, mask),\n\tTP_STRUCT__entry(\n\t\t__field(struct inode *, inode)\n\t\t__field(unsigned int, nlink)\n\t\t__field(umode_t, mode)\n\t\t__field(u32, mask)\n\t),\n\tTP_fast_assign(\n\t\t__entry->inode = inode;\n\t\t__entry->nlink = inode->i_nlink;\n\t\t__entry->mode = inode->i_mode;\n\t\t__entry->mask = mask;\n\t),\n\tTP_printk(\"inode=%p nlink=%u mode=0%ho mask=0x%x\", __entry->inode,\n\t\t\t__entry->nlink, __entry->mode, __entry->mask)\n);\n\nDECLARE_EVENT_CLASS(nfsd_file_gc_class,\n\tTP_PROTO(\n\t\tconst struct nfsd_file *nf\n\t),\n\tTP_ARGS(nf),\n\tTP_STRUCT__entry(\n\t\t__field(void *, nf_inode)\n\t\t__field(void *, nf_file)\n\t\t__field(int, nf_ref)\n\t\t__field(unsigned long, nf_flags)\n\t),\n\tTP_fast_assign(\n\t\t__entry->nf_inode = nf->nf_inode;\n\t\t__entry->nf_file = nf->nf_file;\n\t\t__entry->nf_ref = refcount_read(&nf->nf_ref);\n\t\t__entry->nf_flags = nf->nf_flags;\n\t),\n\tTP_printk(\"inode=%p ref=%d nf_flags=%s nf_file=%p\",\n\t\t__entry->nf_inode, __entry->nf_ref,\n\t\tshow_nf_flags(__entry->nf_flags),\n\t\t__entry->nf_file\n\t)\n);\n\n#define DEFINE_NFSD_FILE_GC_EVENT(name)\t\t\t\t\t\\\nDEFINE_EVENT(nfsd_file_gc_class, name,\t\t\t\t\t\\\n\tTP_PROTO(\t\t\t\t\t\t\t\\\n\t\tconst struct nfsd_file *nf\t\t\t\t\\\n\t),\t\t\t\t\t\t\t\t\\\n\tTP_ARGS(nf))\n\nDEFINE_NFSD_FILE_GC_EVENT(nfsd_file_lru_add);\nDEFINE_NFSD_FILE_GC_EVENT(nfsd_file_lru_add_disposed);\nDEFINE_NFSD_FILE_GC_EVENT(nfsd_file_lru_del);\nDEFINE_NFSD_FILE_GC_EVENT(nfsd_file_lru_del_disposed);\nDEFINE_NFSD_FILE_GC_EVENT(nfsd_file_gc_in_use);\nDEFINE_NFSD_FILE_GC_EVENT(nfsd_file_gc_writeback);\nDEFINE_NFSD_FILE_GC_EVENT(nfsd_file_gc_referenced);\nDEFINE_NFSD_FILE_GC_EVENT(nfsd_file_gc_disposed);\n\nDECLARE_EVENT_CLASS(nfsd_file_lruwalk_class,\n\tTP_PROTO(\n\t\tunsigned long removed,\n\t\tunsigned long remaining\n\t),\n\tTP_ARGS(removed, remaining),\n\tTP_STRUCT__entry(\n\t\t__field(unsigned long, removed)\n\t\t__field(unsigned long, remaining)\n\t),\n\tTP_fast_assign(\n\t\t__entry->removed = removed;\n\t\t__entry->remaining = remaining;\n\t),\n\tTP_printk(\"%lu entries removed, %lu remaining\",\n\t\t__entry->removed, __entry->remaining)\n);\n\n#define DEFINE_NFSD_FILE_LRUWALK_EVENT(name)\t\t\t\t\\\nDEFINE_EVENT(nfsd_file_lruwalk_class, name,\t\t\t\t\\\n\tTP_PROTO(\t\t\t\t\t\t\t\\\n\t\tunsigned long removed,\t\t\t\t\t\\\n\t\tunsigned long remaining\t\t\t\t\t\\\n\t),\t\t\t\t\t\t\t\t\\\n\tTP_ARGS(removed, remaining))\n\nDEFINE_NFSD_FILE_LRUWALK_EVENT(nfsd_file_gc_removed);\nDEFINE_NFSD_FILE_LRUWALK_EVENT(nfsd_file_shrinker_removed);\n\nTRACE_EVENT(nfsd_file_close,\n\tTP_PROTO(\n\t\tconst struct inode *inode\n\t),\n\tTP_ARGS(inode),\n\tTP_STRUCT__entry(\n\t\t__field(const void *, inode)\n\t),\n\tTP_fast_assign(\n\t\t__entry->inode = inode;\n\t),\n\tTP_printk(\"inode=%p\",\n\t\t__entry->inode\n\t)\n);\n\n#include \"cache.h\"\n\nTRACE_DEFINE_ENUM(RC_DROPIT);\nTRACE_DEFINE_ENUM(RC_REPLY);\nTRACE_DEFINE_ENUM(RC_DOIT);\n\n#define show_drc_retval(x)\t\t\t\t\t\t\\\n\t__print_symbolic(x,\t\t\t\t\t\t\\\n\t\t{ RC_DROPIT, \"DROPIT\" },\t\t\t\t\\\n\t\t{ RC_REPLY, \"REPLY\" },\t\t\t\t\t\\\n\t\t{ RC_DOIT, \"DOIT\" })\n\nTRACE_EVENT(nfsd_drc_found,\n\tTP_PROTO(\n\t\tconst struct nfsd_net *nn,\n\t\tconst struct svc_rqst *rqstp,\n\t\tint result\n\t),\n\tTP_ARGS(nn, rqstp, result),\n\tTP_STRUCT__entry(\n\t\t__field(unsigned long long, boot_time)\n\t\t__field(unsigned long, result)\n\t\t__field(u32, xid)\n\t),\n\tTP_fast_assign(\n\t\t__entry->boot_time = nn->boot_time;\n\t\t__entry->result = result;\n\t\t__entry->xid = be32_to_cpu(rqstp->rq_xid);\n\t),\n\tTP_printk(\"boot_time=%16llx xid=0x%08x result=%s\",\n\t\t__entry->boot_time, __entry->xid,\n\t\tshow_drc_retval(__entry->result))\n\n);\n\nTRACE_EVENT(nfsd_drc_mismatch,\n\tTP_PROTO(\n\t\tconst struct nfsd_net *nn,\n\t\tconst struct nfsd_cacherep *key,\n\t\tconst struct nfsd_cacherep *rp\n\t),\n\tTP_ARGS(nn, key, rp),\n\tTP_STRUCT__entry(\n\t\t__field(unsigned long long, boot_time)\n\t\t__field(u32, xid)\n\t\t__field(u32, cached)\n\t\t__field(u32, ingress)\n\t),\n\tTP_fast_assign(\n\t\t__entry->boot_time = nn->boot_time;\n\t\t__entry->xid = be32_to_cpu(key->c_key.k_xid);\n\t\t__entry->cached = (__force u32)key->c_key.k_csum;\n\t\t__entry->ingress = (__force u32)rp->c_key.k_csum;\n\t),\n\tTP_printk(\"boot_time=%16llx xid=0x%08x cached-csum=0x%08x ingress-csum=0x%08x\",\n\t\t__entry->boot_time, __entry->xid, __entry->cached,\n\t\t__entry->ingress)\n);\n\nTRACE_EVENT_CONDITION(nfsd_drc_gc,\n\tTP_PROTO(\n\t\tconst struct nfsd_net *nn,\n\t\tunsigned long freed\n\t),\n\tTP_ARGS(nn, freed),\n\tTP_CONDITION(freed > 0),\n\tTP_STRUCT__entry(\n\t\t__field(unsigned long long, boot_time)\n\t\t__field(unsigned long, freed)\n\t\t__field(int, total)\n\t),\n\tTP_fast_assign(\n\t\t__entry->boot_time = nn->boot_time;\n\t\t__entry->freed = freed;\n\t\t__entry->total = atomic_read(&nn->num_drc_entries);\n\t),\n\tTP_printk(\"boot_time=%16llx total=%d freed=%lu\",\n\t\t__entry->boot_time, __entry->total, __entry->freed\n\t)\n);\n\nTRACE_EVENT(nfsd_cb_args,\n\tTP_PROTO(\n\t\tconst struct nfs4_client *clp,\n\t\tconst struct nfs4_cb_conn *conn\n\t),\n\tTP_ARGS(clp, conn),\n\tTP_STRUCT__entry(\n\t\t__field(u32, cl_boot)\n\t\t__field(u32, cl_id)\n\t\t__field(u32, prog)\n\t\t__field(u32, ident)\n\t\t__sockaddr(addr, conn->cb_addrlen)\n\t),\n\tTP_fast_assign(\n\t\t__entry->cl_boot = clp->cl_clientid.cl_boot;\n\t\t__entry->cl_id = clp->cl_clientid.cl_id;\n\t\t__entry->prog = conn->cb_prog;\n\t\t__entry->ident = conn->cb_ident;\n\t\t__assign_sockaddr(addr, &conn->cb_addr, conn->cb_addrlen);\n\t),\n\tTP_printk(\"addr=%pISpc client %08x:%08x prog=%u ident=%u\",\n\t\t__get_sockaddr(addr), __entry->cl_boot, __entry->cl_id,\n\t\t__entry->prog, __entry->ident)\n);\n\nTRACE_EVENT(nfsd_cb_nodelegs,\n\tTP_PROTO(const struct nfs4_client *clp),\n\tTP_ARGS(clp),\n\tTP_STRUCT__entry(\n\t\t__field(u32, cl_boot)\n\t\t__field(u32, cl_id)\n\t),\n\tTP_fast_assign(\n\t\t__entry->cl_boot = clp->cl_clientid.cl_boot;\n\t\t__entry->cl_id = clp->cl_clientid.cl_id;\n\t),\n\tTP_printk(\"client %08x:%08x\", __entry->cl_boot, __entry->cl_id)\n)\n\n#define show_cb_state(val)\t\t\t\t\t\t\\\n\t__print_symbolic(val,\t\t\t\t\t\t\\\n\t\t{ NFSD4_CB_UP,\t\t\"UP\" },\t\t\t\t\\\n\t\t{ NFSD4_CB_UNKNOWN,\t\"UNKNOWN\" },\t\t\t\\\n\t\t{ NFSD4_CB_DOWN,\t\"DOWN\" },\t\t\t\\\n\t\t{ NFSD4_CB_FAULT,\t\"FAULT\"})\n\nDECLARE_EVENT_CLASS(nfsd_cb_class,\n\tTP_PROTO(const struct nfs4_client *clp),\n\tTP_ARGS(clp),\n\tTP_STRUCT__entry(\n\t\t__field(unsigned long, state)\n\t\t__field(u32, cl_boot)\n\t\t__field(u32, cl_id)\n\t\t__sockaddr(addr, clp->cl_cb_conn.cb_addrlen)\n\t),\n\tTP_fast_assign(\n\t\t__entry->state = clp->cl_cb_state;\n\t\t__entry->cl_boot = clp->cl_clientid.cl_boot;\n\t\t__entry->cl_id = clp->cl_clientid.cl_id;\n\t\t__assign_sockaddr(addr, &clp->cl_cb_conn.cb_addr,\n\t\t\t\t  clp->cl_cb_conn.cb_addrlen)\n\t),\n\tTP_printk(\"addr=%pISpc client %08x:%08x state=%s\",\n\t\t__get_sockaddr(addr), __entry->cl_boot, __entry->cl_id,\n\t\tshow_cb_state(__entry->state))\n);\n\n#define DEFINE_NFSD_CB_EVENT(name)\t\t\t\\\nDEFINE_EVENT(nfsd_cb_class, nfsd_cb_##name,\t\t\\\n\tTP_PROTO(const struct nfs4_client *clp),\t\\\n\tTP_ARGS(clp))\n\nDEFINE_NFSD_CB_EVENT(state);\nDEFINE_NFSD_CB_EVENT(probe);\nDEFINE_NFSD_CB_EVENT(lost);\nDEFINE_NFSD_CB_EVENT(shutdown);\n\nTRACE_DEFINE_ENUM(RPC_AUTH_NULL);\nTRACE_DEFINE_ENUM(RPC_AUTH_UNIX);\nTRACE_DEFINE_ENUM(RPC_AUTH_GSS);\nTRACE_DEFINE_ENUM(RPC_AUTH_GSS_KRB5);\nTRACE_DEFINE_ENUM(RPC_AUTH_GSS_KRB5I);\nTRACE_DEFINE_ENUM(RPC_AUTH_GSS_KRB5P);\n\n#define show_nfsd_authflavor(val)\t\t\t\t\t\\\n\t__print_symbolic(val,\t\t\t\t\t\t\\\n\t\t{ RPC_AUTH_NULL,\t\t\"none\" },\t\t\\\n\t\t{ RPC_AUTH_UNIX,\t\t\"sys\" },\t\t\\\n\t\t{ RPC_AUTH_GSS,\t\t\t\"gss\" },\t\t\\\n\t\t{ RPC_AUTH_GSS_KRB5,\t\t\"krb5\" },\t\t\\\n\t\t{ RPC_AUTH_GSS_KRB5I,\t\t\"krb5i\" },\t\t\\\n\t\t{ RPC_AUTH_GSS_KRB5P,\t\t\"krb5p\" })\n\nTRACE_EVENT(nfsd_cb_setup,\n\tTP_PROTO(const struct nfs4_client *clp,\n\t\t const char *netid,\n\t\t rpc_authflavor_t authflavor\n\t),\n\tTP_ARGS(clp, netid, authflavor),\n\tTP_STRUCT__entry(\n\t\t__field(u32, cl_boot)\n\t\t__field(u32, cl_id)\n\t\t__field(unsigned long, authflavor)\n\t\t__sockaddr(addr, clp->cl_cb_conn.cb_addrlen)\n\t\t__string(netid, netid)\n\t),\n\tTP_fast_assign(\n\t\t__entry->cl_boot = clp->cl_clientid.cl_boot;\n\t\t__entry->cl_id = clp->cl_clientid.cl_id;\n\t\t__assign_str(netid, netid);\n\t\t__entry->authflavor = authflavor;\n\t\t__assign_sockaddr(addr, &clp->cl_cb_conn.cb_addr,\n\t\t\t\t  clp->cl_cb_conn.cb_addrlen)\n\t),\n\tTP_printk(\"addr=%pISpc client %08x:%08x proto=%s flavor=%s\",\n\t\t__get_sockaddr(addr), __entry->cl_boot, __entry->cl_id,\n\t\t__get_str(netid), show_nfsd_authflavor(__entry->authflavor))\n);\n\nTRACE_EVENT(nfsd_cb_setup_err,\n\tTP_PROTO(\n\t\tconst struct nfs4_client *clp,\n\t\tlong error\n\t),\n\tTP_ARGS(clp, error),\n\tTP_STRUCT__entry(\n\t\t__field(long, error)\n\t\t__field(u32, cl_boot)\n\t\t__field(u32, cl_id)\n\t\t__sockaddr(addr, clp->cl_cb_conn.cb_addrlen)\n\t),\n\tTP_fast_assign(\n\t\t__entry->error = error;\n\t\t__entry->cl_boot = clp->cl_clientid.cl_boot;\n\t\t__entry->cl_id = clp->cl_clientid.cl_id;\n\t\t__assign_sockaddr(addr, &clp->cl_cb_conn.cb_addr,\n\t\t\t\t  clp->cl_cb_conn.cb_addrlen)\n\t),\n\tTP_printk(\"addr=%pISpc client %08x:%08x error=%ld\",\n\t\t__get_sockaddr(addr), __entry->cl_boot, __entry->cl_id,\n\t\t__entry->error)\n);\n\nTRACE_EVENT_CONDITION(nfsd_cb_recall,\n\tTP_PROTO(\n\t\tconst struct nfs4_stid *stid\n\t),\n\tTP_ARGS(stid),\n\tTP_CONDITION(stid->sc_client),\n\tTP_STRUCT__entry(\n\t\t__field(u32, cl_boot)\n\t\t__field(u32, cl_id)\n\t\t__field(u32, si_id)\n\t\t__field(u32, si_generation)\n\t\t__sockaddr(addr, stid->sc_client->cl_cb_conn.cb_addrlen)\n\t),\n\tTP_fast_assign(\n\t\tconst stateid_t *stp = &stid->sc_stateid;\n\t\tconst struct nfs4_client *clp = stid->sc_client;\n\n\t\t__entry->cl_boot = stp->si_opaque.so_clid.cl_boot;\n\t\t__entry->cl_id = stp->si_opaque.so_clid.cl_id;\n\t\t__entry->si_id = stp->si_opaque.so_id;\n\t\t__entry->si_generation = stp->si_generation;\n\t\t__assign_sockaddr(addr, &clp->cl_cb_conn.cb_addr,\n\t\t\t\t  clp->cl_cb_conn.cb_addrlen)\n\t),\n\tTP_printk(\"addr=%pISpc client %08x:%08x stateid %08x:%08x\",\n\t\t__get_sockaddr(addr), __entry->cl_boot, __entry->cl_id,\n\t\t__entry->si_id, __entry->si_generation)\n);\n\nTRACE_EVENT(nfsd_cb_notify_lock,\n\tTP_PROTO(\n\t\tconst struct nfs4_lockowner *lo,\n\t\tconst struct nfsd4_blocked_lock *nbl\n\t),\n\tTP_ARGS(lo, nbl),\n\tTP_STRUCT__entry(\n\t\t__field(u32, cl_boot)\n\t\t__field(u32, cl_id)\n\t\t__field(u32, fh_hash)\n\t\t__sockaddr(addr, lo->lo_owner.so_client->cl_cb_conn.cb_addrlen)\n\t),\n\tTP_fast_assign(\n\t\tconst struct nfs4_client *clp = lo->lo_owner.so_client;\n\n\t\t__entry->cl_boot = clp->cl_clientid.cl_boot;\n\t\t__entry->cl_id = clp->cl_clientid.cl_id;\n\t\t__entry->fh_hash = knfsd_fh_hash(&nbl->nbl_fh);\n\t\t__assign_sockaddr(addr, &clp->cl_cb_conn.cb_addr,\n\t\t\t\t  clp->cl_cb_conn.cb_addrlen)\n\t),\n\tTP_printk(\"addr=%pISpc client %08x:%08x fh_hash=0x%08x\",\n\t\t__get_sockaddr(addr), __entry->cl_boot, __entry->cl_id,\n\t\t__entry->fh_hash)\n);\n\nTRACE_EVENT(nfsd_cb_offload,\n\tTP_PROTO(\n\t\tconst struct nfs4_client *clp,\n\t\tconst stateid_t *stp,\n\t\tconst struct knfsd_fh *fh,\n\t\tu64 count,\n\t\t__be32 status\n\t),\n\tTP_ARGS(clp, stp, fh, count, status),\n\tTP_STRUCT__entry(\n\t\t__field(u32, cl_boot)\n\t\t__field(u32, cl_id)\n\t\t__field(u32, si_id)\n\t\t__field(u32, si_generation)\n\t\t__field(u32, fh_hash)\n\t\t__field(int, status)\n\t\t__field(u64, count)\n\t\t__sockaddr(addr, clp->cl_cb_conn.cb_addrlen)\n\t),\n\tTP_fast_assign(\n\t\t__entry->cl_boot = stp->si_opaque.so_clid.cl_boot;\n\t\t__entry->cl_id = stp->si_opaque.so_clid.cl_id;\n\t\t__entry->si_id = stp->si_opaque.so_id;\n\t\t__entry->si_generation = stp->si_generation;\n\t\t__entry->fh_hash = knfsd_fh_hash(fh);\n\t\t__entry->status = be32_to_cpu(status);\n\t\t__entry->count = count;\n\t\t__assign_sockaddr(addr, &clp->cl_cb_conn.cb_addr,\n\t\t\t\t  clp->cl_cb_conn.cb_addrlen)\n\t),\n\tTP_printk(\"addr=%pISpc client %08x:%08x stateid %08x:%08x fh_hash=0x%08x count=%llu status=%d\",\n\t\t__get_sockaddr(addr), __entry->cl_boot, __entry->cl_id,\n\t\t__entry->si_id, __entry->si_generation,\n\t\t__entry->fh_hash, __entry->count, __entry->status)\n);\n\nTRACE_EVENT(nfsd_cb_recall_any,\n\tTP_PROTO(\n\t\tconst struct nfsd4_cb_recall_any *ra\n\t),\n\tTP_ARGS(ra),\n\tTP_STRUCT__entry(\n\t\t__field(u32, cl_boot)\n\t\t__field(u32, cl_id)\n\t\t__field(u32, keep)\n\t\t__field(unsigned long, bmval0)\n\t\t__sockaddr(addr, ra->ra_cb.cb_clp->cl_cb_conn.cb_addrlen)\n\t),\n\tTP_fast_assign(\n\t\t__entry->cl_boot = ra->ra_cb.cb_clp->cl_clientid.cl_boot;\n\t\t__entry->cl_id = ra->ra_cb.cb_clp->cl_clientid.cl_id;\n\t\t__entry->keep = ra->ra_keep;\n\t\t__entry->bmval0 = ra->ra_bmval[0];\n\t\t__assign_sockaddr(addr, &ra->ra_cb.cb_clp->cl_addr,\n\t\t\t\t  ra->ra_cb.cb_clp->cl_cb_conn.cb_addrlen);\n\t),\n\tTP_printk(\"addr=%pISpc client %08x:%08x keep=%u bmval0=%s\",\n\t\t__get_sockaddr(addr), __entry->cl_boot, __entry->cl_id,\n\t\t__entry->keep, show_rca_mask(__entry->bmval0)\n\t)\n);\n\nDECLARE_EVENT_CLASS(nfsd_cb_done_class,\n\tTP_PROTO(\n\t\tconst stateid_t *stp,\n\t\tconst struct rpc_task *task\n\t),\n\tTP_ARGS(stp, task),\n\tTP_STRUCT__entry(\n\t\t__field(u32, cl_boot)\n\t\t__field(u32, cl_id)\n\t\t__field(u32, si_id)\n\t\t__field(u32, si_generation)\n\t\t__field(int, status)\n\t),\n\tTP_fast_assign(\n\t\t__entry->cl_boot = stp->si_opaque.so_clid.cl_boot;\n\t\t__entry->cl_id = stp->si_opaque.so_clid.cl_id;\n\t\t__entry->si_id = stp->si_opaque.so_id;\n\t\t__entry->si_generation = stp->si_generation;\n\t\t__entry->status = task->tk_status;\n\t),\n\tTP_printk(\"client %08x:%08x stateid %08x:%08x status=%d\",\n\t\t__entry->cl_boot, __entry->cl_id, __entry->si_id,\n\t\t__entry->si_generation, __entry->status\n\t)\n);\n\n#define DEFINE_NFSD_CB_DONE_EVENT(name)\t\t\t\\\nDEFINE_EVENT(nfsd_cb_done_class, name,\t\t\t\\\n\tTP_PROTO(\t\t\t\t\t\\\n\t\tconst stateid_t *stp,\t\t\t\\\n\t\tconst struct rpc_task *task\t\t\\\n\t),\t\t\t\t\t\t\\\n\tTP_ARGS(stp, task))\n\nDEFINE_NFSD_CB_DONE_EVENT(nfsd_cb_recall_done);\nDEFINE_NFSD_CB_DONE_EVENT(nfsd_cb_notify_lock_done);\nDEFINE_NFSD_CB_DONE_EVENT(nfsd_cb_layout_done);\nDEFINE_NFSD_CB_DONE_EVENT(nfsd_cb_offload_done);\n\nTRACE_EVENT(nfsd_cb_recall_any_done,\n\tTP_PROTO(\n\t\tconst struct nfsd4_callback *cb,\n\t\tconst struct rpc_task *task\n\t),\n\tTP_ARGS(cb, task),\n\tTP_STRUCT__entry(\n\t\t__field(u32, cl_boot)\n\t\t__field(u32, cl_id)\n\t\t__field(int, status)\n\t),\n\tTP_fast_assign(\n\t\t__entry->status = task->tk_status;\n\t\t__entry->cl_boot = cb->cb_clp->cl_clientid.cl_boot;\n\t\t__entry->cl_id = cb->cb_clp->cl_clientid.cl_id;\n\t),\n\tTP_printk(\"client %08x:%08x status=%d\",\n\t\t__entry->cl_boot, __entry->cl_id, __entry->status\n\t)\n);\n\nTRACE_EVENT(nfsd_ctl_unlock_ip,\n\tTP_PROTO(\n\t\tconst struct net *net,\n\t\tconst char *address\n\t),\n\tTP_ARGS(net, address),\n\tTP_STRUCT__entry(\n\t\t__field(unsigned int, netns_ino)\n\t\t__string(address, address)\n\t),\n\tTP_fast_assign(\n\t\t__entry->netns_ino = net->ns.inum;\n\t\t__assign_str(address, address);\n\t),\n\tTP_printk(\"address=%s\",\n\t\t__get_str(address)\n\t)\n);\n\nTRACE_EVENT(nfsd_ctl_unlock_fs,\n\tTP_PROTO(\n\t\tconst struct net *net,\n\t\tconst char *path\n\t),\n\tTP_ARGS(net, path),\n\tTP_STRUCT__entry(\n\t\t__field(unsigned int, netns_ino)\n\t\t__string(path, path)\n\t),\n\tTP_fast_assign(\n\t\t__entry->netns_ino = net->ns.inum;\n\t\t__assign_str(path, path);\n\t),\n\tTP_printk(\"path=%s\",\n\t\t__get_str(path)\n\t)\n);\n\nTRACE_EVENT(nfsd_ctl_filehandle,\n\tTP_PROTO(\n\t\tconst struct net *net,\n\t\tconst char *domain,\n\t\tconst char *path,\n\t\tint maxsize\n\t),\n\tTP_ARGS(net, domain, path, maxsize),\n\tTP_STRUCT__entry(\n\t\t__field(unsigned int, netns_ino)\n\t\t__field(int, maxsize)\n\t\t__string(domain, domain)\n\t\t__string(path, path)\n\t),\n\tTP_fast_assign(\n\t\t__entry->netns_ino = net->ns.inum;\n\t\t__entry->maxsize = maxsize;\n\t\t__assign_str(domain, domain);\n\t\t__assign_str(path, path);\n\t),\n\tTP_printk(\"domain=%s path=%s maxsize=%d\",\n\t\t__get_str(domain), __get_str(path), __entry->maxsize\n\t)\n);\n\nTRACE_EVENT(nfsd_ctl_threads,\n\tTP_PROTO(\n\t\tconst struct net *net,\n\t\tint newthreads\n\t),\n\tTP_ARGS(net, newthreads),\n\tTP_STRUCT__entry(\n\t\t__field(unsigned int, netns_ino)\n\t\t__field(int, newthreads)\n\t),\n\tTP_fast_assign(\n\t\t__entry->netns_ino = net->ns.inum;\n\t\t__entry->newthreads = newthreads;\n\t),\n\tTP_printk(\"newthreads=%d\",\n\t\t__entry->newthreads\n\t)\n);\n\nTRACE_EVENT(nfsd_ctl_pool_threads,\n\tTP_PROTO(\n\t\tconst struct net *net,\n\t\tint pool,\n\t\tint nrthreads\n\t),\n\tTP_ARGS(net, pool, nrthreads),\n\tTP_STRUCT__entry(\n\t\t__field(unsigned int, netns_ino)\n\t\t__field(int, pool)\n\t\t__field(int, nrthreads)\n\t),\n\tTP_fast_assign(\n\t\t__entry->netns_ino = net->ns.inum;\n\t\t__entry->pool = pool;\n\t\t__entry->nrthreads = nrthreads;\n\t),\n\tTP_printk(\"pool=%d nrthreads=%d\",\n\t\t__entry->pool, __entry->nrthreads\n\t)\n);\n\nTRACE_EVENT(nfsd_ctl_version,\n\tTP_PROTO(\n\t\tconst struct net *net,\n\t\tconst char *mesg\n\t),\n\tTP_ARGS(net, mesg),\n\tTP_STRUCT__entry(\n\t\t__field(unsigned int, netns_ino)\n\t\t__string(mesg, mesg)\n\t),\n\tTP_fast_assign(\n\t\t__entry->netns_ino = net->ns.inum;\n\t\t__assign_str(mesg, mesg);\n\t),\n\tTP_printk(\"%s\",\n\t\t__get_str(mesg)\n\t)\n);\n\nTRACE_EVENT(nfsd_ctl_ports_addfd,\n\tTP_PROTO(\n\t\tconst struct net *net,\n\t\tint fd\n\t),\n\tTP_ARGS(net, fd),\n\tTP_STRUCT__entry(\n\t\t__field(unsigned int, netns_ino)\n\t\t__field(int, fd)\n\t),\n\tTP_fast_assign(\n\t\t__entry->netns_ino = net->ns.inum;\n\t\t__entry->fd = fd;\n\t),\n\tTP_printk(\"fd=%d\",\n\t\t__entry->fd\n\t)\n);\n\nTRACE_EVENT(nfsd_ctl_ports_addxprt,\n\tTP_PROTO(\n\t\tconst struct net *net,\n\t\tconst char *transport,\n\t\tint port\n\t),\n\tTP_ARGS(net, transport, port),\n\tTP_STRUCT__entry(\n\t\t__field(unsigned int, netns_ino)\n\t\t__field(int, port)\n\t\t__string(transport, transport)\n\t),\n\tTP_fast_assign(\n\t\t__entry->netns_ino = net->ns.inum;\n\t\t__entry->port = port;\n\t\t__assign_str(transport, transport);\n\t),\n\tTP_printk(\"transport=%s port=%d\",\n\t\t__get_str(transport), __entry->port\n\t)\n);\n\nTRACE_EVENT(nfsd_ctl_maxblksize,\n\tTP_PROTO(\n\t\tconst struct net *net,\n\t\tint bsize\n\t),\n\tTP_ARGS(net, bsize),\n\tTP_STRUCT__entry(\n\t\t__field(unsigned int, netns_ino)\n\t\t__field(int, bsize)\n\t),\n\tTP_fast_assign(\n\t\t__entry->netns_ino = net->ns.inum;\n\t\t__entry->bsize = bsize;\n\t),\n\tTP_printk(\"bsize=%d\",\n\t\t__entry->bsize\n\t)\n);\n\nTRACE_EVENT(nfsd_ctl_maxconn,\n\tTP_PROTO(\n\t\tconst struct net *net,\n\t\tint maxconn\n\t),\n\tTP_ARGS(net, maxconn),\n\tTP_STRUCT__entry(\n\t\t__field(unsigned int, netns_ino)\n\t\t__field(int, maxconn)\n\t),\n\tTP_fast_assign(\n\t\t__entry->netns_ino = net->ns.inum;\n\t\t__entry->maxconn = maxconn;\n\t),\n\tTP_printk(\"maxconn=%d\",\n\t\t__entry->maxconn\n\t)\n);\n\nTRACE_EVENT(nfsd_ctl_time,\n\tTP_PROTO(\n\t\tconst struct net *net,\n\t\tconst char *name,\n\t\tsize_t namelen,\n\t\tint time\n\t),\n\tTP_ARGS(net, name, namelen, time),\n\tTP_STRUCT__entry(\n\t\t__field(unsigned int, netns_ino)\n\t\t__field(int, time)\n\t\t__string_len(name, name, namelen)\n\t),\n\tTP_fast_assign(\n\t\t__entry->netns_ino = net->ns.inum;\n\t\t__entry->time = time;\n\t\t__assign_str_len(name, name, namelen);\n\t),\n\tTP_printk(\"file=%s time=%d\\n\",\n\t\t__get_str(name), __entry->time\n\t)\n);\n\nTRACE_EVENT(nfsd_ctl_recoverydir,\n\tTP_PROTO(\n\t\tconst struct net *net,\n\t\tconst char *recdir\n\t),\n\tTP_ARGS(net, recdir),\n\tTP_STRUCT__entry(\n\t\t__field(unsigned int, netns_ino)\n\t\t__string(recdir, recdir)\n\t),\n\tTP_fast_assign(\n\t\t__entry->netns_ino = net->ns.inum;\n\t\t__assign_str(recdir, recdir);\n\t),\n\tTP_printk(\"recdir=%s\",\n\t\t__get_str(recdir)\n\t)\n);\n\nTRACE_EVENT(nfsd_end_grace,\n\tTP_PROTO(\n\t\tconst struct net *net\n\t),\n\tTP_ARGS(net),\n\tTP_STRUCT__entry(\n\t\t__field(unsigned int, netns_ino)\n\t),\n\tTP_fast_assign(\n\t\t__entry->netns_ino = net->ns.inum;\n\t),\n\tTP_printk(\"nn=%d\", __entry->netns_ino\n\t)\n);\n\n#endif  \n\n#undef TRACE_INCLUDE_PATH\n#define TRACE_INCLUDE_PATH .\n#define TRACE_INCLUDE_FILE trace\n#include <trace/define_trace.h>\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}