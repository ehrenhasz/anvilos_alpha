{
  "module_name": "nfsxdr.c",
  "hash_id": "5fe8193d222eb8faedf36f49a3e28943f8ba64544a7447df14d514d947fe4544",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfsd/nfsxdr.c",
  "human_readable_source": "\n \n\n#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"auth.h\"\n\n \nstatic const u32 nfs_ftypes[] = {\n\tNFNON,  NFCHR,  NFCHR, NFBAD,\n\tNFDIR,  NFBAD,  NFBLK, NFBAD,\n\tNFREG,  NFBAD,  NFLNK, NFBAD,\n\tNFSOCK, NFBAD,  NFLNK, NFBAD,\n};\n\n\n \n\n \nbool\nsvcxdr_encode_stat(struct xdr_stream *xdr, __be32 status)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, sizeof(status));\n\tif (!p)\n\t\treturn false;\n\t*p = status;\n\n\treturn true;\n}\n\n \nbool\nsvcxdr_decode_fhandle(struct xdr_stream *xdr, struct svc_fh *fhp)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, NFS_FHSIZE);\n\tif (!p)\n\t\treturn false;\n\tfh_init(fhp, NFS_FHSIZE);\n\tmemcpy(&fhp->fh_handle.fh_raw, p, NFS_FHSIZE);\n\tfhp->fh_handle.fh_size = NFS_FHSIZE;\n\n\treturn true;\n}\n\nstatic bool\nsvcxdr_encode_fhandle(struct xdr_stream *xdr, const struct svc_fh *fhp)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, NFS_FHSIZE);\n\tif (!p)\n\t\treturn false;\n\tmemcpy(p, &fhp->fh_handle.fh_raw, NFS_FHSIZE);\n\n\treturn true;\n}\n\nstatic __be32 *\nencode_timeval(__be32 *p, const struct timespec64 *time)\n{\n\t*p++ = cpu_to_be32((u32)time->tv_sec);\n\tif (time->tv_nsec)\n\t\t*p++ = cpu_to_be32(time->tv_nsec / NSEC_PER_USEC);\n\telse\n\t\t*p++ = xdr_zero;\n\treturn p;\n}\n\nstatic bool\nsvcxdr_decode_filename(struct xdr_stream *xdr, char **name, unsigned int *len)\n{\n\tu32 size, i;\n\t__be32 *p;\n\tchar *c;\n\n\tif (xdr_stream_decode_u32(xdr, &size) < 0)\n\t\treturn false;\n\tif (size == 0 || size > NFS_MAXNAMLEN)\n\t\treturn false;\n\tp = xdr_inline_decode(xdr, size);\n\tif (!p)\n\t\treturn false;\n\n\t*len = size;\n\t*name = (char *)p;\n\tfor (i = 0, c = *name; i < size; i++, c++)\n\t\tif (*c == '\\0' || *c == '/')\n\t\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool\nsvcxdr_decode_diropargs(struct xdr_stream *xdr, struct svc_fh *fhp,\n\t\t\tchar **name, unsigned int *len)\n{\n\treturn svcxdr_decode_fhandle(xdr, fhp) &&\n\t\tsvcxdr_decode_filename(xdr, name, len);\n}\n\nstatic bool\nsvcxdr_decode_sattr(struct svc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t    struct iattr *iap)\n{\n\tu32 tmp1, tmp2;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, XDR_UNIT * 8);\n\tif (!p)\n\t\treturn false;\n\n\tiap->ia_valid = 0;\n\n\t \n\ttmp1 = be32_to_cpup(p++);\n\tif (tmp1 != (u32)-1 && tmp1 != 0xffff) {\n\t\tiap->ia_valid |= ATTR_MODE;\n\t\tiap->ia_mode = tmp1;\n\t}\n\n\ttmp1 = be32_to_cpup(p++);\n\tif (tmp1 != (u32)-1) {\n\t\tiap->ia_uid = make_kuid(nfsd_user_namespace(rqstp), tmp1);\n\t\tif (uid_valid(iap->ia_uid))\n\t\t\tiap->ia_valid |= ATTR_UID;\n\t}\n\n\ttmp1 = be32_to_cpup(p++);\n\tif (tmp1 != (u32)-1) {\n\t\tiap->ia_gid = make_kgid(nfsd_user_namespace(rqstp), tmp1);\n\t\tif (gid_valid(iap->ia_gid))\n\t\t\tiap->ia_valid |= ATTR_GID;\n\t}\n\n\ttmp1 = be32_to_cpup(p++);\n\tif (tmp1 != (u32)-1) {\n\t\tiap->ia_valid |= ATTR_SIZE;\n\t\tiap->ia_size = tmp1;\n\t}\n\n\ttmp1 = be32_to_cpup(p++);\n\ttmp2 = be32_to_cpup(p++);\n\tif (tmp1 != (u32)-1 && tmp2 != (u32)-1) {\n\t\tiap->ia_valid |= ATTR_ATIME | ATTR_ATIME_SET;\n\t\tiap->ia_atime.tv_sec = tmp1;\n\t\tiap->ia_atime.tv_nsec = tmp2 * NSEC_PER_USEC;\n\t}\n\n\ttmp1 = be32_to_cpup(p++);\n\ttmp2 = be32_to_cpup(p++);\n\tif (tmp1 != (u32)-1 && tmp2 != (u32)-1) {\n\t\tiap->ia_valid |= ATTR_MTIME | ATTR_MTIME_SET;\n\t\tiap->ia_mtime.tv_sec = tmp1;\n\t\tiap->ia_mtime.tv_nsec = tmp2 * NSEC_PER_USEC;\n\t\t \n\t\tif (tmp2 == 1000000)\n\t\t\tiap->ia_valid &= ~(ATTR_ATIME_SET|ATTR_MTIME_SET);\n\t}\n\n\treturn true;\n}\n\n \nbool\nsvcxdr_encode_fattr(struct svc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t    const struct svc_fh *fhp, const struct kstat *stat)\n{\n\tstruct user_namespace *userns = nfsd_user_namespace(rqstp);\n\tstruct dentry *dentry = fhp->fh_dentry;\n\tint type = stat->mode & S_IFMT;\n\tstruct timespec64 time;\n\t__be32 *p;\n\tu32 fsid;\n\n\tp = xdr_reserve_space(xdr, XDR_UNIT * 17);\n\tif (!p)\n\t\treturn false;\n\n\t*p++ = cpu_to_be32(nfs_ftypes[type >> 12]);\n\t*p++ = cpu_to_be32((u32)stat->mode);\n\t*p++ = cpu_to_be32((u32)stat->nlink);\n\t*p++ = cpu_to_be32((u32)from_kuid_munged(userns, stat->uid));\n\t*p++ = cpu_to_be32((u32)from_kgid_munged(userns, stat->gid));\n\n\tif (S_ISLNK(type) && stat->size > NFS_MAXPATHLEN)\n\t\t*p++ = cpu_to_be32(NFS_MAXPATHLEN);\n\telse\n\t\t*p++ = cpu_to_be32((u32) stat->size);\n\t*p++ = cpu_to_be32((u32) stat->blksize);\n\tif (S_ISCHR(type) || S_ISBLK(type))\n\t\t*p++ = cpu_to_be32(new_encode_dev(stat->rdev));\n\telse\n\t\t*p++ = cpu_to_be32(0xffffffff);\n\t*p++ = cpu_to_be32((u32)stat->blocks);\n\n\tswitch (fsid_source(fhp)) {\n\tcase FSIDSOURCE_FSID:\n\t\tfsid = (u32)fhp->fh_export->ex_fsid;\n\t\tbreak;\n\tcase FSIDSOURCE_UUID:\n\t\tfsid = ((u32 *)fhp->fh_export->ex_uuid)[0];\n\t\tfsid ^= ((u32 *)fhp->fh_export->ex_uuid)[1];\n\t\tfsid ^= ((u32 *)fhp->fh_export->ex_uuid)[2];\n\t\tfsid ^= ((u32 *)fhp->fh_export->ex_uuid)[3];\n\t\tbreak;\n\tdefault:\n\t\tfsid = new_encode_dev(stat->dev);\n\t\tbreak;\n\t}\n\t*p++ = cpu_to_be32(fsid);\n\n\t*p++ = cpu_to_be32((u32)stat->ino);\n\tp = encode_timeval(p, &stat->atime);\n\ttime = stat->mtime;\n\tlease_get_mtime(d_inode(dentry), &time);\n\tp = encode_timeval(p, &time);\n\tencode_timeval(p, &stat->ctime);\n\n\treturn true;\n}\n\n \n\nbool\nnfssvc_decode_fhandleargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nfsd_fhandle *args = rqstp->rq_argp;\n\n\treturn svcxdr_decode_fhandle(xdr, &args->fh);\n}\n\nbool\nnfssvc_decode_sattrargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nfsd_sattrargs *args = rqstp->rq_argp;\n\n\treturn svcxdr_decode_fhandle(xdr, &args->fh) &&\n\t\tsvcxdr_decode_sattr(rqstp, xdr, &args->attrs);\n}\n\nbool\nnfssvc_decode_diropargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nfsd_diropargs *args = rqstp->rq_argp;\n\n\treturn svcxdr_decode_diropargs(xdr, &args->fh, &args->name, &args->len);\n}\n\nbool\nnfssvc_decode_readargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nfsd_readargs *args = rqstp->rq_argp;\n\tu32 totalcount;\n\n\tif (!svcxdr_decode_fhandle(xdr, &args->fh))\n\t\treturn false;\n\tif (xdr_stream_decode_u32(xdr, &args->offset) < 0)\n\t\treturn false;\n\tif (xdr_stream_decode_u32(xdr, &args->count) < 0)\n\t\treturn false;\n\t \n\tif (xdr_stream_decode_u32(xdr, &totalcount) < 0)\n\t\treturn false;\n\n\treturn true;\n}\n\nbool\nnfssvc_decode_writeargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nfsd_writeargs *args = rqstp->rq_argp;\n\tu32 beginoffset, totalcount;\n\n\tif (!svcxdr_decode_fhandle(xdr, &args->fh))\n\t\treturn false;\n\t \n\tif (xdr_stream_decode_u32(xdr, &beginoffset) < 0)\n\t\treturn false;\n\tif (xdr_stream_decode_u32(xdr, &args->offset) < 0)\n\t\treturn false;\n\t \n\tif (xdr_stream_decode_u32(xdr, &totalcount) < 0)\n\t\treturn false;\n\n\t \n\tif (xdr_stream_decode_u32(xdr, &args->len) < 0)\n\t\treturn false;\n\tif (args->len > NFSSVC_MAXBLKSIZE_V2)\n\t\treturn false;\n\n\treturn xdr_stream_subsegment(xdr, &args->payload, args->len);\n}\n\nbool\nnfssvc_decode_createargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nfsd_createargs *args = rqstp->rq_argp;\n\n\treturn svcxdr_decode_diropargs(xdr, &args->fh,\n\t\t\t\t       &args->name, &args->len) &&\n\t\tsvcxdr_decode_sattr(rqstp, xdr, &args->attrs);\n}\n\nbool\nnfssvc_decode_renameargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nfsd_renameargs *args = rqstp->rq_argp;\n\n\treturn svcxdr_decode_diropargs(xdr, &args->ffh,\n\t\t\t\t       &args->fname, &args->flen) &&\n\t\tsvcxdr_decode_diropargs(xdr, &args->tfh,\n\t\t\t\t\t&args->tname, &args->tlen);\n}\n\nbool\nnfssvc_decode_linkargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nfsd_linkargs *args = rqstp->rq_argp;\n\n\treturn svcxdr_decode_fhandle(xdr, &args->ffh) &&\n\t\tsvcxdr_decode_diropargs(xdr, &args->tfh,\n\t\t\t\t\t&args->tname, &args->tlen);\n}\n\nbool\nnfssvc_decode_symlinkargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nfsd_symlinkargs *args = rqstp->rq_argp;\n\tstruct kvec *head = rqstp->rq_arg.head;\n\n\tif (!svcxdr_decode_diropargs(xdr, &args->ffh, &args->fname, &args->flen))\n\t\treturn false;\n\tif (xdr_stream_decode_u32(xdr, &args->tlen) < 0)\n\t\treturn false;\n\tif (args->tlen == 0)\n\t\treturn false;\n\n\targs->first.iov_len = head->iov_len - xdr_stream_pos(xdr);\n\targs->first.iov_base = xdr_inline_decode(xdr, args->tlen);\n\tif (!args->first.iov_base)\n\t\treturn false;\n\treturn svcxdr_decode_sattr(rqstp, xdr, &args->attrs);\n}\n\nbool\nnfssvc_decode_readdirargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nfsd_readdirargs *args = rqstp->rq_argp;\n\n\tif (!svcxdr_decode_fhandle(xdr, &args->fh))\n\t\treturn false;\n\tif (xdr_stream_decode_u32(xdr, &args->cookie) < 0)\n\t\treturn false;\n\tif (xdr_stream_decode_u32(xdr, &args->count) < 0)\n\t\treturn false;\n\n\treturn true;\n}\n\n \n\nbool\nnfssvc_encode_statres(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nfsd_stat *resp = rqstp->rq_resp;\n\n\treturn svcxdr_encode_stat(xdr, resp->status);\n}\n\nbool\nnfssvc_encode_attrstatres(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nfsd_attrstat *resp = rqstp->rq_resp;\n\n\tif (!svcxdr_encode_stat(xdr, resp->status))\n\t\treturn false;\n\tswitch (resp->status) {\n\tcase nfs_ok:\n\t\tif (!svcxdr_encode_fattr(rqstp, xdr, &resp->fh, &resp->stat))\n\t\t\treturn false;\n\t\tbreak;\n\t}\n\n\treturn true;\n}\n\nbool\nnfssvc_encode_diropres(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nfsd_diropres *resp = rqstp->rq_resp;\n\n\tif (!svcxdr_encode_stat(xdr, resp->status))\n\t\treturn false;\n\tswitch (resp->status) {\n\tcase nfs_ok:\n\t\tif (!svcxdr_encode_fhandle(xdr, &resp->fh))\n\t\t\treturn false;\n\t\tif (!svcxdr_encode_fattr(rqstp, xdr, &resp->fh, &resp->stat))\n\t\t\treturn false;\n\t\tbreak;\n\t}\n\n\treturn true;\n}\n\nbool\nnfssvc_encode_readlinkres(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nfsd_readlinkres *resp = rqstp->rq_resp;\n\tstruct kvec *head = rqstp->rq_res.head;\n\n\tif (!svcxdr_encode_stat(xdr, resp->status))\n\t\treturn false;\n\tswitch (resp->status) {\n\tcase nfs_ok:\n\t\tif (xdr_stream_encode_u32(xdr, resp->len) < 0)\n\t\t\treturn false;\n\t\tsvcxdr_encode_opaque_pages(rqstp, xdr, &resp->page, 0,\n\t\t\t\t\t   resp->len);\n\t\tif (svc_encode_result_payload(rqstp, head->iov_len, resp->len) < 0)\n\t\t\treturn false;\n\t\tbreak;\n\t}\n\n\treturn true;\n}\n\nbool\nnfssvc_encode_readres(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nfsd_readres *resp = rqstp->rq_resp;\n\tstruct kvec *head = rqstp->rq_res.head;\n\n\tif (!svcxdr_encode_stat(xdr, resp->status))\n\t\treturn false;\n\tswitch (resp->status) {\n\tcase nfs_ok:\n\t\tif (!svcxdr_encode_fattr(rqstp, xdr, &resp->fh, &resp->stat))\n\t\t\treturn false;\n\t\tif (xdr_stream_encode_u32(xdr, resp->count) < 0)\n\t\t\treturn false;\n\t\tsvcxdr_encode_opaque_pages(rqstp, xdr, resp->pages,\n\t\t\t\t\t   rqstp->rq_res.page_base,\n\t\t\t\t\t   resp->count);\n\t\tif (svc_encode_result_payload(rqstp, head->iov_len, resp->count) < 0)\n\t\t\treturn false;\n\t\tbreak;\n\t}\n\n\treturn true;\n}\n\nbool\nnfssvc_encode_readdirres(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nfsd_readdirres *resp = rqstp->rq_resp;\n\tstruct xdr_buf *dirlist = &resp->dirlist;\n\n\tif (!svcxdr_encode_stat(xdr, resp->status))\n\t\treturn false;\n\tswitch (resp->status) {\n\tcase nfs_ok:\n\t\tsvcxdr_encode_opaque_pages(rqstp, xdr, dirlist->pages, 0,\n\t\t\t\t\t   dirlist->len);\n\t\t \n\t\tif (xdr_stream_encode_item_absent(xdr) < 0)\n\t\t\treturn false;\n\t\tif (xdr_stream_encode_bool(xdr, resp->common.err == nfserr_eof) < 0)\n\t\t\treturn false;\n\t\tbreak;\n\t}\n\n\treturn true;\n}\n\nbool\nnfssvc_encode_statfsres(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nfsd_statfsres *resp = rqstp->rq_resp;\n\tstruct kstatfs\t*stat = &resp->stats;\n\t__be32 *p;\n\n\tif (!svcxdr_encode_stat(xdr, resp->status))\n\t\treturn false;\n\tswitch (resp->status) {\n\tcase nfs_ok:\n\t\tp = xdr_reserve_space(xdr, XDR_UNIT * 5);\n\t\tif (!p)\n\t\t\treturn false;\n\t\t*p++ = cpu_to_be32(NFSSVC_MAXBLKSIZE_V2);\n\t\t*p++ = cpu_to_be32(stat->f_bsize);\n\t\t*p++ = cpu_to_be32(stat->f_blocks);\n\t\t*p++ = cpu_to_be32(stat->f_bfree);\n\t\t*p = cpu_to_be32(stat->f_bavail);\n\t\tbreak;\n\t}\n\n\treturn true;\n}\n\n \nvoid nfssvc_encode_nfscookie(struct nfsd_readdirres *resp, u32 offset)\n{\n\t__be32 cookie = cpu_to_be32(offset);\n\n\tif (!resp->cookie_offset)\n\t\treturn;\n\n\twrite_bytes_to_xdr_buf(&resp->dirlist, resp->cookie_offset, &cookie,\n\t\t\t       sizeof(cookie));\n\tresp->cookie_offset = 0;\n}\n\nstatic bool\nsvcxdr_encode_entry_common(struct nfsd_readdirres *resp, const char *name,\n\t\t\t   int namlen, loff_t offset, u64 ino)\n{\n\tstruct xdr_buf *dirlist = &resp->dirlist;\n\tstruct xdr_stream *xdr = &resp->xdr;\n\n\tif (xdr_stream_encode_item_present(xdr) < 0)\n\t\treturn false;\n\t \n\tif (xdr_stream_encode_u32(xdr, (u32)ino) < 0)\n\t\treturn false;\n\t \n\tif (xdr_stream_encode_opaque(xdr, name, min(namlen, NFS2_MAXNAMLEN)) < 0)\n\t\treturn false;\n\t \n\tresp->cookie_offset = dirlist->len;\n\tif (xdr_stream_encode_u32(xdr, ~0U) < 0)\n\t\treturn false;\n\n\treturn true;\n}\n\n \nint nfssvc_encode_entry(void *data, const char *name, int namlen,\n\t\t\tloff_t offset, u64 ino, unsigned int d_type)\n{\n\tstruct readdir_cd *ccd = data;\n\tstruct nfsd_readdirres *resp = container_of(ccd,\n\t\t\t\t\t\t    struct nfsd_readdirres,\n\t\t\t\t\t\t    common);\n\tunsigned int starting_length = resp->dirlist.len;\n\n\t \n\tnfssvc_encode_nfscookie(resp, offset);\n\n\tif (!svcxdr_encode_entry_common(resp, name, namlen, offset, ino))\n\t\tgoto out_toosmall;\n\n\txdr_commit_encode(&resp->xdr);\n\tresp->common.err = nfs_ok;\n\treturn 0;\n\nout_toosmall:\n\tresp->cookie_offset = 0;\n\tresp->common.err = nfserr_toosmall;\n\tresp->dirlist.len = starting_length;\n\treturn -EINVAL;\n}\n\n \nvoid nfssvc_release_attrstat(struct svc_rqst *rqstp)\n{\n\tstruct nfsd_attrstat *resp = rqstp->rq_resp;\n\n\tfh_put(&resp->fh);\n}\n\nvoid nfssvc_release_diropres(struct svc_rqst *rqstp)\n{\n\tstruct nfsd_diropres *resp = rqstp->rq_resp;\n\n\tfh_put(&resp->fh);\n}\n\nvoid nfssvc_release_readres(struct svc_rqst *rqstp)\n{\n\tstruct nfsd_readres *resp = rqstp->rq_resp;\n\n\tfh_put(&resp->fh);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}