{
  "module_name": "nfsfh.h",
  "hash_id": "22f5ee5d3c87dd71526e541b75b757e53addabc146444ec8d6148f659e662c63",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfsd/nfsfh.h",
  "human_readable_source": " \n \n#ifndef _LINUX_NFSD_NFSFH_H\n#define _LINUX_NFSD_NFSFH_H\n\n#include <linux/crc32.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/iversion.h>\n#include <linux/exportfs.h>\n#include <linux/nfs4.h>\n\n \n\nstruct knfsd_fh {\n\tunsigned int\tfh_size;\t \n\tunion {\n\t\tchar\t\t\tfh_raw[NFS4_FHSIZE];\n\t\tstruct {\n\t\t\tu8\t\tfh_version;\t \n\t\t\tu8\t\tfh_auth_type;\t \n\t\t\tu8\t\tfh_fsid_type;\n\t\t\tu8\t\tfh_fileid_type;\n\t\t\tu32\t\tfh_fsid[];  \n\t\t};\n\t};\n};\n\nstatic inline __u32 ino_t_to_u32(ino_t ino)\n{\n\treturn (__u32) ino;\n}\n\nstatic inline ino_t u32_to_ino_t(__u32 uino)\n{\n\treturn (ino_t) uino;\n}\n\n \ntypedef struct svc_fh {\n\tstruct knfsd_fh\t\tfh_handle;\t \n\tint\t\t\tfh_maxsize;\t \n\tstruct dentry *\t\tfh_dentry;\t \n\tstruct svc_export *\tfh_export;\t \n\n\tbool\t\t\tfh_want_write;\t \n\tbool\t\t\tfh_no_wcc;\t \n\tbool\t\t\tfh_no_atomic_attr;\n\t\t\t\t\t\t \n\tint\t\t\tfh_flags;\t \n\tbool\t\t\tfh_post_saved;\t \n\tbool\t\t\tfh_pre_saved;\t \n\n\t \n\t__u64\t\t\tfh_pre_size;\t \n\tstruct timespec64\tfh_pre_mtime;\t \n\tstruct timespec64\tfh_pre_ctime;\t \n\t \n\tu64\t\t\tfh_pre_change;\n\n\t \n\tstruct kstat\t\tfh_post_attr;\t \n\tu64\t\t\tfh_post_change;  \n} svc_fh;\n#define NFSD4_FH_FOREIGN (1<<0)\n#define SET_FH_FLAG(c, f) ((c)->fh_flags |= (f))\n#define HAS_FH_FLAG(c, f) ((c)->fh_flags & (f))\n\nenum nfsd_fsid {\n\tFSID_DEV = 0,\n\tFSID_NUM,\n\tFSID_MAJOR_MINOR,\n\tFSID_ENCODE_DEV,\n\tFSID_UUID4_INUM,\n\tFSID_UUID8,\n\tFSID_UUID16,\n\tFSID_UUID16_INUM,\n};\n\nenum fsid_source {\n\tFSIDSOURCE_DEV,\n\tFSIDSOURCE_FSID,\n\tFSIDSOURCE_UUID,\n};\nextern enum fsid_source fsid_source(const struct svc_fh *fhp);\n\n\n \nstatic inline void mk_fsid(int vers, u32 *fsidv, dev_t dev, ino_t ino,\n\t\t\t   u32 fsid, unsigned char *uuid)\n{\n\tu32 *up;\n\tswitch(vers) {\n\tcase FSID_DEV:\n\t\tfsidv[0] = (__force __u32)htonl((MAJOR(dev)<<16) |\n\t\t\t\t MINOR(dev));\n\t\tfsidv[1] = ino_t_to_u32(ino);\n\t\tbreak;\n\tcase FSID_NUM:\n\t\tfsidv[0] = fsid;\n\t\tbreak;\n\tcase FSID_MAJOR_MINOR:\n\t\tfsidv[0] = (__force __u32)htonl(MAJOR(dev));\n\t\tfsidv[1] = (__force __u32)htonl(MINOR(dev));\n\t\tfsidv[2] = ino_t_to_u32(ino);\n\t\tbreak;\n\n\tcase FSID_ENCODE_DEV:\n\t\tfsidv[0] = new_encode_dev(dev);\n\t\tfsidv[1] = ino_t_to_u32(ino);\n\t\tbreak;\n\n\tcase FSID_UUID4_INUM:\n\t\t \n\t\tup = (u32*)uuid;\n\t\tfsidv[0] = ino_t_to_u32(ino);\n\t\tfsidv[1] = up[0] ^ up[1] ^ up[2] ^ up[3];\n\t\tbreak;\n\n\tcase FSID_UUID8:\n\t\t \n\t\tup = (u32*)uuid;\n\t\tfsidv[0] = up[0] ^ up[2];\n\t\tfsidv[1] = up[1] ^ up[3];\n\t\tbreak;\n\n\tcase FSID_UUID16:\n\t\t \n\t\tmemcpy(fsidv, uuid, 16);\n\t\tbreak;\n\n\tcase FSID_UUID16_INUM:\n\t\t \n\t\t*(u64*)fsidv = (u64)ino;\n\t\tmemcpy(fsidv+2, uuid, 16);\n\t\tbreak;\n\tdefault: BUG();\n\t}\n}\n\nstatic inline int key_len(int type)\n{\n\tswitch(type) {\n\tcase FSID_DEV:\t\treturn 8;\n\tcase FSID_NUM: \t\treturn 4;\n\tcase FSID_MAJOR_MINOR:\treturn 12;\n\tcase FSID_ENCODE_DEV:\treturn 8;\n\tcase FSID_UUID4_INUM:\treturn 8;\n\tcase FSID_UUID8:\treturn 8;\n\tcase FSID_UUID16:\treturn 16;\n\tcase FSID_UUID16_INUM:\treturn 24;\n\tdefault: return 0;\n\t}\n}\n\n \nextern char * SVCFH_fmt(struct svc_fh *fhp);\n\n \n__be32\tfh_verify(struct svc_rqst *, struct svc_fh *, umode_t, int);\n__be32\tfh_compose(struct svc_fh *, struct svc_export *, struct dentry *, struct svc_fh *);\n__be32\tfh_update(struct svc_fh *);\nvoid\tfh_put(struct svc_fh *);\n\nstatic __inline__ struct svc_fh *\nfh_copy(struct svc_fh *dst, const struct svc_fh *src)\n{\n\tWARN_ON(src->fh_dentry);\n\n\t*dst = *src;\n\treturn dst;\n}\n\nstatic inline void\nfh_copy_shallow(struct knfsd_fh *dst, const struct knfsd_fh *src)\n{\n\tdst->fh_size = src->fh_size;\n\tmemcpy(&dst->fh_raw, &src->fh_raw, src->fh_size);\n}\n\nstatic __inline__ struct svc_fh *\nfh_init(struct svc_fh *fhp, int maxsize)\n{\n\tmemset(fhp, 0, sizeof(*fhp));\n\tfhp->fh_maxsize = maxsize;\n\treturn fhp;\n}\n\nstatic inline bool fh_match(const struct knfsd_fh *fh1,\n\t\t\t    const struct knfsd_fh *fh2)\n{\n\tif (fh1->fh_size != fh2->fh_size)\n\t\treturn false;\n\tif (memcmp(fh1->fh_raw, fh2->fh_raw, fh1->fh_size) != 0)\n\t\treturn false;\n\treturn true;\n}\n\nstatic inline bool fh_fsid_match(const struct knfsd_fh *fh1,\n\t\t\t\t const struct knfsd_fh *fh2)\n{\n\tif (fh1->fh_fsid_type != fh2->fh_fsid_type)\n\t\treturn false;\n\tif (memcmp(fh1->fh_fsid, fh2->fh_fsid, key_len(fh1->fh_fsid_type)) != 0)\n\t\treturn false;\n\treturn true;\n}\n\n#ifdef CONFIG_CRC32\n \nstatic inline u32 knfsd_fh_hash(const struct knfsd_fh *fh)\n{\n\treturn ~crc32_le(0xFFFFFFFF, fh->fh_raw, fh->fh_size);\n}\n#else\nstatic inline u32 knfsd_fh_hash(const struct knfsd_fh *fh)\n{\n\treturn 0;\n}\n#endif\n\n \nstatic inline void fh_clear_pre_post_attrs(struct svc_fh *fhp)\n{\n\tfhp->fh_post_saved = false;\n\tfhp->fh_pre_saved = false;\n}\n\nu64 nfsd4_change_attribute(struct kstat *stat, struct inode *inode);\n__be32 __must_check fh_fill_pre_attrs(struct svc_fh *fhp);\n__be32 fh_fill_post_attrs(struct svc_fh *fhp);\n__be32 __must_check fh_fill_both_attrs(struct svc_fh *fhp);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}