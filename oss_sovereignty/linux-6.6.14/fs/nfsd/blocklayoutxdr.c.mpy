{
  "module_name": "blocklayoutxdr.c",
  "hash_id": "b2794ac6e631f84786cd8a70607a008b3d7ae5fa083fbc3eb9eef51a5389c577",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfsd/blocklayoutxdr.c",
  "human_readable_source": "\n \n#include <linux/sunrpc/svc.h>\n#include <linux/exportfs.h>\n#include <linux/iomap.h>\n#include <linux/nfs4.h>\n\n#include \"nfsd.h\"\n#include \"blocklayoutxdr.h\"\n#include \"vfs.h\"\n\n#define NFSDDBG_FACILITY\tNFSDDBG_PNFS\n\n\n__be32\nnfsd4_block_encode_layoutget(struct xdr_stream *xdr,\n\t\tstruct nfsd4_layoutget *lgp)\n{\n\tstruct pnfs_block_extent *b = lgp->lg_content;\n\tint len = sizeof(__be32) + 5 * sizeof(__be64) + sizeof(__be32);\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, sizeof(__be32) + len);\n\tif (!p)\n\t\treturn nfserr_toosmall;\n\n\t*p++ = cpu_to_be32(len);\n\t*p++ = cpu_to_be32(1);\t\t \n\n\tp = xdr_encode_opaque_fixed(p, &b->vol_id,\n\t\t\tsizeof(struct nfsd4_deviceid));\n\tp = xdr_encode_hyper(p, b->foff);\n\tp = xdr_encode_hyper(p, b->len);\n\tp = xdr_encode_hyper(p, b->soff);\n\t*p++ = cpu_to_be32(b->es);\n\treturn 0;\n}\n\nstatic int\nnfsd4_block_encode_volume(struct xdr_stream *xdr, struct pnfs_block_volume *b)\n{\n\t__be32 *p;\n\tint len;\n\n\tswitch (b->type) {\n\tcase PNFS_BLOCK_VOLUME_SIMPLE:\n\t\tlen = 4 + 4 + 8 + 4 + (XDR_QUADLEN(b->simple.sig_len) << 2);\n\t\tp = xdr_reserve_space(xdr, len);\n\t\tif (!p)\n\t\t\treturn -ETOOSMALL;\n\n\t\t*p++ = cpu_to_be32(b->type);\n\t\t*p++ = cpu_to_be32(1);\t \n\t\tp = xdr_encode_hyper(p, b->simple.offset);\n\t\tp = xdr_encode_opaque(p, b->simple.sig, b->simple.sig_len);\n\t\tbreak;\n\tcase PNFS_BLOCK_VOLUME_SCSI:\n\t\tlen = 4 + 4 + 4 + 4 + (XDR_QUADLEN(b->scsi.designator_len) << 2) + 8;\n\t\tp = xdr_reserve_space(xdr, len);\n\t\tif (!p)\n\t\t\treturn -ETOOSMALL;\n\n\t\t*p++ = cpu_to_be32(b->type);\n\t\t*p++ = cpu_to_be32(b->scsi.code_set);\n\t\t*p++ = cpu_to_be32(b->scsi.designator_type);\n\t\tp = xdr_encode_opaque(p, b->scsi.designator, b->scsi.designator_len);\n\t\tp = xdr_encode_hyper(p, b->scsi.pr_key);\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn len;\n}\n\n__be32\nnfsd4_block_encode_getdeviceinfo(struct xdr_stream *xdr,\n\t\tstruct nfsd4_getdeviceinfo *gdp)\n{\n\tstruct pnfs_block_deviceaddr *dev = gdp->gd_device;\n\tint len = sizeof(__be32), ret, i;\n\t__be32 *p;\n\n\t \n\tif (!gdp->gd_maxcount) {\n\t\tif (xdr_stream_encode_u32(xdr, 0) != XDR_UNIT)\n\t\t\treturn nfserr_resource;\n\t\treturn nfs_ok;\n\t}\n\n\tp = xdr_reserve_space(xdr, len + sizeof(__be32));\n\tif (!p)\n\t\treturn nfserr_resource;\n\n\tfor (i = 0; i < dev->nr_volumes; i++) {\n\t\tret = nfsd4_block_encode_volume(xdr, &dev->volumes[i]);\n\t\tif (ret < 0)\n\t\t\treturn nfserrno(ret);\n\t\tlen += ret;\n\t}\n\n\t \n\t*p++ = cpu_to_be32(len);\n\t*p++ = cpu_to_be32(dev->nr_volumes);\n\treturn 0;\n}\n\nint\nnfsd4_block_decode_layoutupdate(__be32 *p, u32 len, struct iomap **iomapp,\n\t\tu32 block_size)\n{\n\tstruct iomap *iomaps;\n\tu32 nr_iomaps, i;\n\n\tif (len < sizeof(u32)) {\n\t\tdprintk(\"%s: extent array too small: %u\\n\", __func__, len);\n\t\treturn -EINVAL;\n\t}\n\tlen -= sizeof(u32);\n\tif (len % PNFS_BLOCK_EXTENT_SIZE) {\n\t\tdprintk(\"%s: extent array invalid: %u\\n\", __func__, len);\n\t\treturn -EINVAL;\n\t}\n\n\tnr_iomaps = be32_to_cpup(p++);\n\tif (nr_iomaps != len / PNFS_BLOCK_EXTENT_SIZE) {\n\t\tdprintk(\"%s: extent array size mismatch: %u/%u\\n\",\n\t\t\t__func__, len, nr_iomaps);\n\t\treturn -EINVAL;\n\t}\n\n\tiomaps = kcalloc(nr_iomaps, sizeof(*iomaps), GFP_KERNEL);\n\tif (!iomaps) {\n\t\tdprintk(\"%s: failed to allocate extent array\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < nr_iomaps; i++) {\n\t\tstruct pnfs_block_extent bex;\n\n\t\tmemcpy(&bex.vol_id, p, sizeof(struct nfsd4_deviceid));\n\t\tp += XDR_QUADLEN(sizeof(struct nfsd4_deviceid));\n\n\t\tp = xdr_decode_hyper(p, &bex.foff);\n\t\tif (bex.foff & (block_size - 1)) {\n\t\t\tdprintk(\"%s: unaligned offset 0x%llx\\n\",\n\t\t\t\t__func__, bex.foff);\n\t\t\tgoto fail;\n\t\t}\n\t\tp = xdr_decode_hyper(p, &bex.len);\n\t\tif (bex.len & (block_size - 1)) {\n\t\t\tdprintk(\"%s: unaligned length 0x%llx\\n\",\n\t\t\t\t__func__, bex.foff);\n\t\t\tgoto fail;\n\t\t}\n\t\tp = xdr_decode_hyper(p, &bex.soff);\n\t\tif (bex.soff & (block_size - 1)) {\n\t\t\tdprintk(\"%s: unaligned disk offset 0x%llx\\n\",\n\t\t\t\t__func__, bex.soff);\n\t\t\tgoto fail;\n\t\t}\n\t\tbex.es = be32_to_cpup(p++);\n\t\tif (bex.es != PNFS_BLOCK_READWRITE_DATA) {\n\t\t\tdprintk(\"%s: incorrect extent state %d\\n\",\n\t\t\t\t__func__, bex.es);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tiomaps[i].offset = bex.foff;\n\t\tiomaps[i].length = bex.len;\n\t}\n\n\t*iomapp = iomaps;\n\treturn nr_iomaps;\nfail:\n\tkfree(iomaps);\n\treturn -EINVAL;\n}\n\nint\nnfsd4_scsi_decode_layoutupdate(__be32 *p, u32 len, struct iomap **iomapp,\n\t\tu32 block_size)\n{\n\tstruct iomap *iomaps;\n\tu32 nr_iomaps, expected, i;\n\n\tif (len < sizeof(u32)) {\n\t\tdprintk(\"%s: extent array too small: %u\\n\", __func__, len);\n\t\treturn -EINVAL;\n\t}\n\n\tnr_iomaps = be32_to_cpup(p++);\n\texpected = sizeof(__be32) + nr_iomaps * PNFS_SCSI_RANGE_SIZE;\n\tif (len != expected) {\n\t\tdprintk(\"%s: extent array size mismatch: %u/%u\\n\",\n\t\t\t__func__, len, expected);\n\t\treturn -EINVAL;\n\t}\n\n\tiomaps = kcalloc(nr_iomaps, sizeof(*iomaps), GFP_KERNEL);\n\tif (!iomaps) {\n\t\tdprintk(\"%s: failed to allocate extent array\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < nr_iomaps; i++) {\n\t\tu64 val;\n\n\t\tp = xdr_decode_hyper(p, &val);\n\t\tif (val & (block_size - 1)) {\n\t\t\tdprintk(\"%s: unaligned offset 0x%llx\\n\", __func__, val);\n\t\t\tgoto fail;\n\t\t}\n\t\tiomaps[i].offset = val;\n\n\t\tp = xdr_decode_hyper(p, &val);\n\t\tif (val & (block_size - 1)) {\n\t\t\tdprintk(\"%s: unaligned length 0x%llx\\n\", __func__, val);\n\t\t\tgoto fail;\n\t\t}\n\t\tiomaps[i].length = val;\n\t}\n\n\t*iomapp = iomaps;\n\treturn nr_iomaps;\nfail:\n\tkfree(iomaps);\n\treturn -EINVAL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}