{
  "module_name": "nfs4layouts.c",
  "hash_id": "6afbf5bce3ac57aca8b15773f299e9c96dbb2f197b53fcb90825d8ccd6585f7c",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfsd/nfs4layouts.c",
  "human_readable_source": "\n \n#include <linux/blkdev.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/jhash.h>\n#include <linux/sched.h>\n#include <linux/sunrpc/addr.h>\n\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"trace.h\"\n\n#define NFSDDBG_FACILITY                NFSDDBG_PNFS\n\nstruct nfs4_layout {\n\tstruct list_head\t\tlo_perstate;\n\tstruct nfs4_layout_stateid\t*lo_state;\n\tstruct nfsd4_layout_seg\t\tlo_seg;\n};\n\nstatic struct kmem_cache *nfs4_layout_cache;\nstatic struct kmem_cache *nfs4_layout_stateid_cache;\n\nstatic const struct nfsd4_callback_ops nfsd4_cb_layout_ops;\nstatic const struct lock_manager_operations nfsd4_layouts_lm_ops;\n\nconst struct nfsd4_layout_ops *nfsd4_layout_ops[LAYOUT_TYPE_MAX] =  {\n#ifdef CONFIG_NFSD_FLEXFILELAYOUT\n\t[LAYOUT_FLEX_FILES]\t= &ff_layout_ops,\n#endif\n#ifdef CONFIG_NFSD_BLOCKLAYOUT\n\t[LAYOUT_BLOCK_VOLUME]\t= &bl_layout_ops,\n#endif\n#ifdef CONFIG_NFSD_SCSILAYOUT\n\t[LAYOUT_SCSI]\t\t= &scsi_layout_ops,\n#endif\n};\n\n \n#define DEVID_HASH_BITS\t8\n#define DEVID_HASH_SIZE\t(1 << DEVID_HASH_BITS)\n#define DEVID_HASH_MASK\t(DEVID_HASH_SIZE - 1)\nstatic u64 nfsd_devid_seq = 1;\nstatic struct list_head nfsd_devid_hash[DEVID_HASH_SIZE];\nstatic DEFINE_SPINLOCK(nfsd_devid_lock);\n\nstatic inline u32 devid_hashfn(u64 idx)\n{\n\treturn jhash_2words(idx, idx >> 32, 0) & DEVID_HASH_MASK;\n}\n\nstatic void\nnfsd4_alloc_devid_map(const struct svc_fh *fhp)\n{\n\tconst struct knfsd_fh *fh = &fhp->fh_handle;\n\tsize_t fsid_len = key_len(fh->fh_fsid_type);\n\tstruct nfsd4_deviceid_map *map, *old;\n\tint i;\n\n\tmap = kzalloc(sizeof(*map) + fsid_len, GFP_KERNEL);\n\tif (!map)\n\t\treturn;\n\n\tmap->fsid_type = fh->fh_fsid_type;\n\tmemcpy(&map->fsid, fh->fh_fsid, fsid_len);\n\n\tspin_lock(&nfsd_devid_lock);\n\tif (fhp->fh_export->ex_devid_map)\n\t\tgoto out_unlock;\n\n\tfor (i = 0; i < DEVID_HASH_SIZE; i++) {\n\t\tlist_for_each_entry(old, &nfsd_devid_hash[i], hash) {\n\t\t\tif (old->fsid_type != fh->fh_fsid_type)\n\t\t\t\tcontinue;\n\t\t\tif (memcmp(old->fsid, fh->fh_fsid,\n\t\t\t\t\tkey_len(old->fsid_type)))\n\t\t\t\tcontinue;\n\n\t\t\tfhp->fh_export->ex_devid_map = old;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tmap->idx = nfsd_devid_seq++;\n\tlist_add_tail_rcu(&map->hash, &nfsd_devid_hash[devid_hashfn(map->idx)]);\n\tfhp->fh_export->ex_devid_map = map;\n\tmap = NULL;\n\nout_unlock:\n\tspin_unlock(&nfsd_devid_lock);\n\tkfree(map);\n}\n\nstruct nfsd4_deviceid_map *\nnfsd4_find_devid_map(int idx)\n{\n\tstruct nfsd4_deviceid_map *map, *ret = NULL;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(map, &nfsd_devid_hash[devid_hashfn(idx)], hash)\n\t\tif (map->idx == idx)\n\t\t\tret = map;\n\trcu_read_unlock();\n\n\treturn ret;\n}\n\nint\nnfsd4_set_deviceid(struct nfsd4_deviceid *id, const struct svc_fh *fhp,\n\t\tu32 device_generation)\n{\n\tif (!fhp->fh_export->ex_devid_map) {\n\t\tnfsd4_alloc_devid_map(fhp);\n\t\tif (!fhp->fh_export->ex_devid_map)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tid->fsid_idx = fhp->fh_export->ex_devid_map->idx;\n\tid->generation = device_generation;\n\tid->pad = 0;\n\treturn 0;\n}\n\nvoid nfsd4_setup_layout_type(struct svc_export *exp)\n{\n#if defined(CONFIG_NFSD_BLOCKLAYOUT) || defined(CONFIG_NFSD_SCSILAYOUT)\n\tstruct super_block *sb = exp->ex_path.mnt->mnt_sb;\n#endif\n\n\tif (!(exp->ex_flags & NFSEXP_PNFS))\n\t\treturn;\n\n#ifdef CONFIG_NFSD_FLEXFILELAYOUT\n\texp->ex_layout_types |= 1 << LAYOUT_FLEX_FILES;\n#endif\n#ifdef CONFIG_NFSD_BLOCKLAYOUT\n\tif (sb->s_export_op->get_uuid &&\n\t    sb->s_export_op->map_blocks &&\n\t    sb->s_export_op->commit_blocks)\n\t\texp->ex_layout_types |= 1 << LAYOUT_BLOCK_VOLUME;\n#endif\n#ifdef CONFIG_NFSD_SCSILAYOUT\n\tif (sb->s_export_op->map_blocks &&\n\t    sb->s_export_op->commit_blocks &&\n\t    sb->s_bdev &&\n\t    sb->s_bdev->bd_disk->fops->pr_ops &&\n\t    sb->s_bdev->bd_disk->fops->get_unique_id)\n\t\texp->ex_layout_types |= 1 << LAYOUT_SCSI;\n#endif\n}\n\nstatic void\nnfsd4_free_layout_stateid(struct nfs4_stid *stid)\n{\n\tstruct nfs4_layout_stateid *ls = layoutstateid(stid);\n\tstruct nfs4_client *clp = ls->ls_stid.sc_client;\n\tstruct nfs4_file *fp = ls->ls_stid.sc_file;\n\n\ttrace_nfsd_layoutstate_free(&ls->ls_stid.sc_stateid);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_del_init(&ls->ls_perclnt);\n\tspin_unlock(&clp->cl_lock);\n\n\tspin_lock(&fp->fi_lock);\n\tlist_del_init(&ls->ls_perfile);\n\tspin_unlock(&fp->fi_lock);\n\n\tif (!nfsd4_layout_ops[ls->ls_layout_type]->disable_recalls)\n\t\tvfs_setlease(ls->ls_file->nf_file, F_UNLCK, NULL, (void **)&ls);\n\tnfsd_file_put(ls->ls_file);\n\n\tif (ls->ls_recalled)\n\t\tatomic_dec(&ls->ls_stid.sc_file->fi_lo_recalls);\n\n\tkmem_cache_free(nfs4_layout_stateid_cache, ls);\n}\n\nstatic int\nnfsd4_layout_setlease(struct nfs4_layout_stateid *ls)\n{\n\tstruct file_lock *fl;\n\tint status;\n\n\tif (nfsd4_layout_ops[ls->ls_layout_type]->disable_recalls)\n\t\treturn 0;\n\n\tfl = locks_alloc_lock();\n\tif (!fl)\n\t\treturn -ENOMEM;\n\tlocks_init_lock(fl);\n\tfl->fl_lmops = &nfsd4_layouts_lm_ops;\n\tfl->fl_flags = FL_LAYOUT;\n\tfl->fl_type = F_RDLCK;\n\tfl->fl_end = OFFSET_MAX;\n\tfl->fl_owner = ls;\n\tfl->fl_pid = current->tgid;\n\tfl->fl_file = ls->ls_file->nf_file;\n\n\tstatus = vfs_setlease(fl->fl_file, fl->fl_type, &fl, NULL);\n\tif (status) {\n\t\tlocks_free_lock(fl);\n\t\treturn status;\n\t}\n\tBUG_ON(fl != NULL);\n\treturn 0;\n}\n\nstatic struct nfs4_layout_stateid *\nnfsd4_alloc_layout_stateid(struct nfsd4_compound_state *cstate,\n\t\tstruct nfs4_stid *parent, u32 layout_type)\n{\n\tstruct nfs4_client *clp = cstate->clp;\n\tstruct nfs4_file *fp = parent->sc_file;\n\tstruct nfs4_layout_stateid *ls;\n\tstruct nfs4_stid *stp;\n\n\tstp = nfs4_alloc_stid(cstate->clp, nfs4_layout_stateid_cache,\n\t\t\t\t\tnfsd4_free_layout_stateid);\n\tif (!stp)\n\t\treturn NULL;\n\n\tget_nfs4_file(fp);\n\tstp->sc_file = fp;\n\n\tls = layoutstateid(stp);\n\tINIT_LIST_HEAD(&ls->ls_perclnt);\n\tINIT_LIST_HEAD(&ls->ls_perfile);\n\tspin_lock_init(&ls->ls_lock);\n\tINIT_LIST_HEAD(&ls->ls_layouts);\n\tmutex_init(&ls->ls_mutex);\n\tls->ls_layout_type = layout_type;\n\tnfsd4_init_cb(&ls->ls_recall, clp, &nfsd4_cb_layout_ops,\n\t\t\tNFSPROC4_CLNT_CB_LAYOUT);\n\n\tif (parent->sc_type == NFS4_DELEG_STID)\n\t\tls->ls_file = nfsd_file_get(fp->fi_deleg_file);\n\telse\n\t\tls->ls_file = find_any_file(fp);\n\tBUG_ON(!ls->ls_file);\n\n\tif (nfsd4_layout_setlease(ls)) {\n\t\tnfsd_file_put(ls->ls_file);\n\t\tput_nfs4_file(fp);\n\t\tkmem_cache_free(nfs4_layout_stateid_cache, ls);\n\t\treturn NULL;\n\t}\n\n\tspin_lock(&clp->cl_lock);\n\tstp->sc_type = NFS4_LAYOUT_STID;\n\tlist_add(&ls->ls_perclnt, &clp->cl_lo_states);\n\tspin_unlock(&clp->cl_lock);\n\n\tspin_lock(&fp->fi_lock);\n\tlist_add(&ls->ls_perfile, &fp->fi_lo_states);\n\tspin_unlock(&fp->fi_lock);\n\n\ttrace_nfsd_layoutstate_alloc(&ls->ls_stid.sc_stateid);\n\treturn ls;\n}\n\n__be32\nnfsd4_preprocess_layout_stateid(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate, stateid_t *stateid,\n\t\tbool create, u32 layout_type, struct nfs4_layout_stateid **lsp)\n{\n\tstruct nfs4_layout_stateid *ls;\n\tstruct nfs4_stid *stid;\n\tunsigned char typemask = NFS4_LAYOUT_STID;\n\t__be32 status;\n\n\tif (create)\n\t\ttypemask |= (NFS4_OPEN_STID | NFS4_LOCK_STID | NFS4_DELEG_STID);\n\n\tstatus = nfsd4_lookup_stateid(cstate, stateid, typemask, &stid,\n\t\t\tnet_generic(SVC_NET(rqstp), nfsd_net_id));\n\tif (status)\n\t\tgoto out;\n\n\tif (!fh_match(&cstate->current_fh.fh_handle,\n\t\t      &stid->sc_file->fi_fhandle)) {\n\t\tstatus = nfserr_bad_stateid;\n\t\tgoto out_put_stid;\n\t}\n\n\tif (stid->sc_type != NFS4_LAYOUT_STID) {\n\t\tls = nfsd4_alloc_layout_stateid(cstate, stid, layout_type);\n\t\tnfs4_put_stid(stid);\n\n\t\tstatus = nfserr_jukebox;\n\t\tif (!ls)\n\t\t\tgoto out;\n\t\tmutex_lock(&ls->ls_mutex);\n\t} else {\n\t\tls = container_of(stid, struct nfs4_layout_stateid, ls_stid);\n\n\t\tstatus = nfserr_bad_stateid;\n\t\tmutex_lock(&ls->ls_mutex);\n\t\tif (nfsd4_stateid_generation_after(stateid, &stid->sc_stateid))\n\t\t\tgoto out_unlock_stid;\n\t\tif (layout_type != ls->ls_layout_type)\n\t\t\tgoto out_unlock_stid;\n\t}\n\n\t*lsp = ls;\n\treturn 0;\n\nout_unlock_stid:\n\tmutex_unlock(&ls->ls_mutex);\nout_put_stid:\n\tnfs4_put_stid(stid);\nout:\n\treturn status;\n}\n\nstatic void\nnfsd4_recall_file_layout(struct nfs4_layout_stateid *ls)\n{\n\tspin_lock(&ls->ls_lock);\n\tif (ls->ls_recalled)\n\t\tgoto out_unlock;\n\n\tif (list_empty(&ls->ls_layouts))\n\t\tgoto out_unlock;\n\n\tls->ls_recalled = true;\n\tatomic_inc(&ls->ls_stid.sc_file->fi_lo_recalls);\n\ttrace_nfsd_layout_recall(&ls->ls_stid.sc_stateid);\n\n\trefcount_inc(&ls->ls_stid.sc_count);\n\tnfsd4_run_cb(&ls->ls_recall);\n\nout_unlock:\n\tspin_unlock(&ls->ls_lock);\n}\n\nstatic inline u64\nlayout_end(struct nfsd4_layout_seg *seg)\n{\n\tu64 end = seg->offset + seg->length;\n\treturn end >= seg->offset ? end : NFS4_MAX_UINT64;\n}\n\nstatic void\nlayout_update_len(struct nfsd4_layout_seg *lo, u64 end)\n{\n\tif (end == NFS4_MAX_UINT64)\n\t\tlo->length = NFS4_MAX_UINT64;\n\telse\n\t\tlo->length = end - lo->offset;\n}\n\nstatic bool\nlayouts_overlapping(struct nfs4_layout *lo, struct nfsd4_layout_seg *s)\n{\n\tif (s->iomode != IOMODE_ANY && s->iomode != lo->lo_seg.iomode)\n\t\treturn false;\n\tif (layout_end(&lo->lo_seg) <= s->offset)\n\t\treturn false;\n\tif (layout_end(s) <= lo->lo_seg.offset)\n\t\treturn false;\n\treturn true;\n}\n\nstatic bool\nlayouts_try_merge(struct nfsd4_layout_seg *lo, struct nfsd4_layout_seg *new)\n{\n\tif (lo->iomode != new->iomode)\n\t\treturn false;\n\tif (layout_end(new) < lo->offset)\n\t\treturn false;\n\tif (layout_end(lo) < new->offset)\n\t\treturn false;\n\n\tlo->offset = min(lo->offset, new->offset);\n\tlayout_update_len(lo, max(layout_end(lo), layout_end(new)));\n\treturn true;\n}\n\nstatic __be32\nnfsd4_recall_conflict(struct nfs4_layout_stateid *ls)\n{\n\tstruct nfs4_file *fp = ls->ls_stid.sc_file;\n\tstruct nfs4_layout_stateid *l, *n;\n\t__be32 nfserr = nfs_ok;\n\n\tassert_spin_locked(&fp->fi_lock);\n\n\tlist_for_each_entry_safe(l, n, &fp->fi_lo_states, ls_perfile) {\n\t\tif (l != ls) {\n\t\t\tnfsd4_recall_file_layout(l);\n\t\t\tnfserr = nfserr_recallconflict;\n\t\t}\n\t}\n\n\treturn nfserr;\n}\n\n__be32\nnfsd4_insert_layout(struct nfsd4_layoutget *lgp, struct nfs4_layout_stateid *ls)\n{\n\tstruct nfsd4_layout_seg *seg = &lgp->lg_seg;\n\tstruct nfs4_file *fp = ls->ls_stid.sc_file;\n\tstruct nfs4_layout *lp, *new = NULL;\n\t__be32 nfserr;\n\n\tspin_lock(&fp->fi_lock);\n\tnfserr = nfsd4_recall_conflict(ls);\n\tif (nfserr)\n\t\tgoto out;\n\tspin_lock(&ls->ls_lock);\n\tlist_for_each_entry(lp, &ls->ls_layouts, lo_perstate) {\n\t\tif (layouts_try_merge(&lp->lo_seg, seg))\n\t\t\tgoto done;\n\t}\n\tspin_unlock(&ls->ls_lock);\n\tspin_unlock(&fp->fi_lock);\n\n\tnew = kmem_cache_alloc(nfs4_layout_cache, GFP_KERNEL);\n\tif (!new)\n\t\treturn nfserr_jukebox;\n\tmemcpy(&new->lo_seg, seg, sizeof(new->lo_seg));\n\tnew->lo_state = ls;\n\n\tspin_lock(&fp->fi_lock);\n\tnfserr = nfsd4_recall_conflict(ls);\n\tif (nfserr)\n\t\tgoto out;\n\tspin_lock(&ls->ls_lock);\n\tlist_for_each_entry(lp, &ls->ls_layouts, lo_perstate) {\n\t\tif (layouts_try_merge(&lp->lo_seg, seg))\n\t\t\tgoto done;\n\t}\n\n\trefcount_inc(&ls->ls_stid.sc_count);\n\tlist_add_tail(&new->lo_perstate, &ls->ls_layouts);\n\tnew = NULL;\ndone:\n\tnfs4_inc_and_copy_stateid(&lgp->lg_sid, &ls->ls_stid);\n\tspin_unlock(&ls->ls_lock);\nout:\n\tspin_unlock(&fp->fi_lock);\n\tif (new)\n\t\tkmem_cache_free(nfs4_layout_cache, new);\n\treturn nfserr;\n}\n\nstatic void\nnfsd4_free_layouts(struct list_head *reaplist)\n{\n\twhile (!list_empty(reaplist)) {\n\t\tstruct nfs4_layout *lp = list_first_entry(reaplist,\n\t\t\t\tstruct nfs4_layout, lo_perstate);\n\n\t\tlist_del(&lp->lo_perstate);\n\t\tnfs4_put_stid(&lp->lo_state->ls_stid);\n\t\tkmem_cache_free(nfs4_layout_cache, lp);\n\t}\n}\n\nstatic void\nnfsd4_return_file_layout(struct nfs4_layout *lp, struct nfsd4_layout_seg *seg,\n\t\tstruct list_head *reaplist)\n{\n\tstruct nfsd4_layout_seg *lo = &lp->lo_seg;\n\tu64 end = layout_end(lo);\n\n\tif (seg->offset <= lo->offset) {\n\t\tif (layout_end(seg) >= end) {\n\t\t\tlist_move_tail(&lp->lo_perstate, reaplist);\n\t\t\treturn;\n\t\t}\n\t\tlo->offset = layout_end(seg);\n\t} else {\n\t\t \n\t\tif (layout_end(seg) < end) {\n\t\t\tdprintk(\"%s: split not supported\\n\", __func__);\n\t\t\treturn;\n\t\t}\n\t\tend = seg->offset;\n\t}\n\n\tlayout_update_len(lo, end);\n}\n\n__be32\nnfsd4_return_file_layouts(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd4_layoutreturn *lrp)\n{\n\tstruct nfs4_layout_stateid *ls;\n\tstruct nfs4_layout *lp, *n;\n\tLIST_HEAD(reaplist);\n\t__be32 nfserr;\n\tint found = 0;\n\n\tnfserr = nfsd4_preprocess_layout_stateid(rqstp, cstate, &lrp->lr_sid,\n\t\t\t\t\t\tfalse, lrp->lr_layout_type,\n\t\t\t\t\t\t&ls);\n\tif (nfserr) {\n\t\ttrace_nfsd_layout_return_lookup_fail(&lrp->lr_sid);\n\t\treturn nfserr;\n\t}\n\n\tspin_lock(&ls->ls_lock);\n\tlist_for_each_entry_safe(lp, n, &ls->ls_layouts, lo_perstate) {\n\t\tif (layouts_overlapping(lp, &lrp->lr_seg)) {\n\t\t\tnfsd4_return_file_layout(lp, &lrp->lr_seg, &reaplist);\n\t\t\tfound++;\n\t\t}\n\t}\n\tif (!list_empty(&ls->ls_layouts)) {\n\t\tif (found)\n\t\t\tnfs4_inc_and_copy_stateid(&lrp->lr_sid, &ls->ls_stid);\n\t\tlrp->lrs_present = 1;\n\t} else {\n\t\ttrace_nfsd_layoutstate_unhash(&ls->ls_stid.sc_stateid);\n\t\tnfs4_unhash_stid(&ls->ls_stid);\n\t\tlrp->lrs_present = 0;\n\t}\n\tspin_unlock(&ls->ls_lock);\n\n\tmutex_unlock(&ls->ls_mutex);\n\tnfs4_put_stid(&ls->ls_stid);\n\tnfsd4_free_layouts(&reaplist);\n\treturn nfs_ok;\n}\n\n__be32\nnfsd4_return_client_layouts(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd4_layoutreturn *lrp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tstruct nfs4_client *clp = cstate->clp;\n\tstruct nfs4_layout *lp, *t;\n\tLIST_HEAD(reaplist);\n\n\tlrp->lrs_present = 0;\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt) {\n\t\tif (ls->ls_layout_type != lrp->lr_layout_type)\n\t\t\tcontinue;\n\n\t\tif (lrp->lr_return_type == RETURN_FSID &&\n\t\t    !fh_fsid_match(&ls->ls_stid.sc_file->fi_fhandle,\n\t\t\t\t   &cstate->current_fh.fh_handle))\n\t\t\tcontinue;\n\n\t\tspin_lock(&ls->ls_lock);\n\t\tlist_for_each_entry_safe(lp, t, &ls->ls_layouts, lo_perstate) {\n\t\t\tif (lrp->lr_seg.iomode == IOMODE_ANY ||\n\t\t\t    lrp->lr_seg.iomode == lp->lo_seg.iomode)\n\t\t\t\tlist_move_tail(&lp->lo_perstate, &reaplist);\n\t\t}\n\t\tspin_unlock(&ls->ls_lock);\n\t}\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n\treturn 0;\n}\n\nstatic void\nnfsd4_return_all_layouts(struct nfs4_layout_stateid *ls,\n\t\tstruct list_head *reaplist)\n{\n\tspin_lock(&ls->ls_lock);\n\tlist_splice_init(&ls->ls_layouts, reaplist);\n\tspin_unlock(&ls->ls_lock);\n}\n\nvoid\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}\n\nvoid\nnfsd4_return_all_file_layouts(struct nfs4_client *clp, struct nfs4_file *fp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&fp->fi_lock);\n\tlist_for_each_entry_safe(ls, n, &fp->fi_lo_states, ls_perfile) {\n\t\tif (ls->ls_stid.sc_client == clp)\n\t\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\t}\n\tspin_unlock(&fp->fi_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}\n\nstatic void\nnfsd4_cb_layout_fail(struct nfs4_layout_stateid *ls)\n{\n\tstruct nfs4_client *clp = ls->ls_stid.sc_client;\n\tchar addr_str[INET6_ADDRSTRLEN];\n\tstatic char const nfsd_recall_failed[] = \"/sbin/nfsd-recall-failed\";\n\tstatic char *envp[] = {\n\t\t\"HOME=/\",\n\t\t\"TERM=linux\",\n\t\t\"PATH=/sbin:/usr/sbin:/bin:/usr/bin\",\n\t\tNULL\n\t};\n\tchar *argv[8];\n\tint error;\n\n\trpc_ntop((struct sockaddr *)&clp->cl_addr, addr_str, sizeof(addr_str));\n\n\tprintk(KERN_WARNING\n\t\t\"nfsd: client %s failed to respond to layout recall. \"\n\t\t\"  Fencing..\\n\", addr_str);\n\n\targv[0] = (char *)nfsd_recall_failed;\n\targv[1] = addr_str;\n\targv[2] = ls->ls_file->nf_file->f_path.mnt->mnt_sb->s_id;\n\targv[3] = NULL;\n\n\terror = call_usermodehelper(nfsd_recall_failed, argv, envp,\n\t\t\t\t    UMH_WAIT_PROC);\n\tif (error) {\n\t\tprintk(KERN_ERR \"nfsd: fence failed for client %s: %d!\\n\",\n\t\t\taddr_str, error);\n\t}\n}\n\nstatic void\nnfsd4_cb_layout_prepare(struct nfsd4_callback *cb)\n{\n\tstruct nfs4_layout_stateid *ls =\n\t\tcontainer_of(cb, struct nfs4_layout_stateid, ls_recall);\n\n\tmutex_lock(&ls->ls_mutex);\n\tnfs4_inc_and_copy_stateid(&ls->ls_recall_sid, &ls->ls_stid);\n\tmutex_unlock(&ls->ls_mutex);\n}\n\nstatic int\nnfsd4_cb_layout_done(struct nfsd4_callback *cb, struct rpc_task *task)\n{\n\tstruct nfs4_layout_stateid *ls =\n\t\tcontainer_of(cb, struct nfs4_layout_stateid, ls_recall);\n\tstruct nfsd_net *nn;\n\tktime_t now, cutoff;\n\tconst struct nfsd4_layout_ops *ops;\n\n\ttrace_nfsd_cb_layout_done(&ls->ls_stid.sc_stateid, task);\n\tswitch (task->tk_status) {\n\tcase 0:\n\tcase -NFS4ERR_DELAY:\n\t\t \n\t\tif (list_empty(&ls->ls_layouts))\n\t\t\treturn 1;\n\n\t\t \n\t\tnow = ktime_get();\n\t\tnn = net_generic(ls->ls_stid.sc_client->net, nfsd_net_id);\n\n\t\t \n\t\tcutoff = ktime_add_ns(task->tk_start,\n\t\t\t\t\t (u64)nn->nfsd4_lease * NSEC_PER_SEC * 2);\n\n\t\tif (ktime_before(now, cutoff)) {\n\t\t\trpc_delay(task, HZ/100);  \n\t\t\treturn 0;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\t \n\t\ttrace_nfsd_layout_recall_fail(&ls->ls_stid.sc_stateid);\n\n\t\tops = nfsd4_layout_ops[ls->ls_layout_type];\n\t\tif (ops->fence_client)\n\t\t\tops->fence_client(ls);\n\t\telse\n\t\t\tnfsd4_cb_layout_fail(ls);\n\t\treturn 1;\n\tcase -NFS4ERR_NOMATCHING_LAYOUT:\n\t\ttrace_nfsd_layout_recall_done(&ls->ls_stid.sc_stateid);\n\t\ttask->tk_status = 0;\n\t\treturn 1;\n\t}\n}\n\nstatic void\nnfsd4_cb_layout_release(struct nfsd4_callback *cb)\n{\n\tstruct nfs4_layout_stateid *ls =\n\t\tcontainer_of(cb, struct nfs4_layout_stateid, ls_recall);\n\tLIST_HEAD(reaplist);\n\n\ttrace_nfsd_layout_recall_release(&ls->ls_stid.sc_stateid);\n\n\tnfsd4_return_all_layouts(ls, &reaplist);\n\tnfsd4_free_layouts(&reaplist);\n\tnfs4_put_stid(&ls->ls_stid);\n}\n\nstatic const struct nfsd4_callback_ops nfsd4_cb_layout_ops = {\n\t.prepare\t= nfsd4_cb_layout_prepare,\n\t.done\t\t= nfsd4_cb_layout_done,\n\t.release\t= nfsd4_cb_layout_release,\n};\n\nstatic bool\nnfsd4_layout_lm_break(struct file_lock *fl)\n{\n\t \n\tfl->fl_break_time = 0;\n\tnfsd4_recall_file_layout(fl->fl_owner);\n\treturn false;\n}\n\nstatic int\nnfsd4_layout_lm_change(struct file_lock *onlist, int arg,\n\t\tstruct list_head *dispose)\n{\n\tBUG_ON(!(arg & F_UNLCK));\n\treturn lease_modify(onlist, arg, dispose);\n}\n\nstatic const struct lock_manager_operations nfsd4_layouts_lm_ops = {\n\t.lm_break\t= nfsd4_layout_lm_break,\n\t.lm_change\t= nfsd4_layout_lm_change,\n};\n\nint\nnfsd4_init_pnfs(void)\n{\n\tint i;\n\n\tfor (i = 0; i < DEVID_HASH_SIZE; i++)\n\t\tINIT_LIST_HEAD(&nfsd_devid_hash[i]);\n\n\tnfs4_layout_cache = kmem_cache_create(\"nfs4_layout\",\n\t\t\tsizeof(struct nfs4_layout), 0, 0, NULL);\n\tif (!nfs4_layout_cache)\n\t\treturn -ENOMEM;\n\n\tnfs4_layout_stateid_cache = kmem_cache_create(\"nfs4_layout_stateid\",\n\t\t\tsizeof(struct nfs4_layout_stateid), 0, 0, NULL);\n\tif (!nfs4_layout_stateid_cache) {\n\t\tkmem_cache_destroy(nfs4_layout_cache);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nvoid\nnfsd4_exit_pnfs(void)\n{\n\tint i;\n\n\tkmem_cache_destroy(nfs4_layout_cache);\n\tkmem_cache_destroy(nfs4_layout_stateid_cache);\n\n\tfor (i = 0; i < DEVID_HASH_SIZE; i++) {\n\t\tstruct nfsd4_deviceid_map *map, *n;\n\n\t\tlist_for_each_entry_safe(map, n, &nfsd_devid_hash[i], hash)\n\t\t\tkfree(map);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}