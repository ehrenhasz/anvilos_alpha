{
  "module_name": "nfs2acl.c",
  "hash_id": "7bf31e60bd470cec52fbe854b259f7222236da9d361df84ade34ca20dd16656a",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfsd/nfs2acl.c",
  "human_readable_source": "\n \n\n#include \"nfsd.h\"\n \n#include <linux/nfsacl.h>\n#include <linux/gfp.h>\n#include \"cache.h\"\n#include \"xdr3.h\"\n#include \"vfs.h\"\n\n#define NFSDDBG_FACILITY\t\tNFSDDBG_PROC\n\n \nstatic __be32\nnfsacld_proc_null(struct svc_rqst *rqstp)\n{\n\treturn rpc_success;\n}\n\n \nstatic __be32 nfsacld_proc_getacl(struct svc_rqst *rqstp)\n{\n\tstruct nfsd3_getaclargs *argp = rqstp->rq_argp;\n\tstruct nfsd3_getaclres *resp = rqstp->rq_resp;\n\tstruct posix_acl *acl;\n\tstruct inode *inode;\n\tsvc_fh *fh;\n\n\tdprintk(\"nfsd: GETACL(2acl)   %s\\n\", SVCFH_fmt(&argp->fh));\n\n\tfh = fh_copy(&resp->fh, &argp->fh);\n\tresp->status = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_NOP);\n\tif (resp->status != nfs_ok)\n\t\tgoto out;\n\n\tinode = d_inode(fh->fh_dentry);\n\n\tif (argp->mask & ~NFS_ACL_MASK) {\n\t\tresp->status = nfserr_inval;\n\t\tgoto out;\n\t}\n\tresp->mask = argp->mask;\n\n\tresp->status = fh_getattr(fh, &resp->stat);\n\tif (resp->status != nfs_ok)\n\t\tgoto out;\n\n\tif (resp->mask & (NFS_ACL|NFS_ACLCNT)) {\n\t\tacl = get_inode_acl(inode, ACL_TYPE_ACCESS);\n\t\tif (acl == NULL) {\n\t\t\t \n\t\t\tacl = posix_acl_from_mode(inode->i_mode, GFP_KERNEL);\n\t\t}\n\t\tif (IS_ERR(acl)) {\n\t\t\tresp->status = nfserrno(PTR_ERR(acl));\n\t\t\tgoto fail;\n\t\t}\n\t\tresp->acl_access = acl;\n\t}\n\tif (resp->mask & (NFS_DFACL|NFS_DFACLCNT)) {\n\t\t \n\t\tacl = get_inode_acl(inode, ACL_TYPE_DEFAULT);\n\t\tif (IS_ERR(acl)) {\n\t\t\tresp->status = nfserrno(PTR_ERR(acl));\n\t\t\tgoto fail;\n\t\t}\n\t\tresp->acl_default = acl;\n\t}\n\n\t \nout:\n\treturn rpc_success;\n\nfail:\n\tposix_acl_release(resp->acl_access);\n\tposix_acl_release(resp->acl_default);\n\tgoto out;\n}\n\n \nstatic __be32 nfsacld_proc_setacl(struct svc_rqst *rqstp)\n{\n\tstruct nfsd3_setaclargs *argp = rqstp->rq_argp;\n\tstruct nfsd_attrstat *resp = rqstp->rq_resp;\n\tstruct inode *inode;\n\tsvc_fh *fh;\n\tint error;\n\n\tdprintk(\"nfsd: SETACL(2acl)   %s\\n\", SVCFH_fmt(&argp->fh));\n\n\tfh = fh_copy(&resp->fh, &argp->fh);\n\tresp->status = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_SATTR);\n\tif (resp->status != nfs_ok)\n\t\tgoto out;\n\n\tinode = d_inode(fh->fh_dentry);\n\n\terror = fh_want_write(fh);\n\tif (error)\n\t\tgoto out_errno;\n\n\tinode_lock(inode);\n\n\terror = set_posix_acl(&nop_mnt_idmap, fh->fh_dentry, ACL_TYPE_ACCESS,\n\t\t\t      argp->acl_access);\n\tif (error)\n\t\tgoto out_drop_lock;\n\terror = set_posix_acl(&nop_mnt_idmap, fh->fh_dentry, ACL_TYPE_DEFAULT,\n\t\t\t      argp->acl_default);\n\tif (error)\n\t\tgoto out_drop_lock;\n\n\tinode_unlock(inode);\n\n\tfh_drop_write(fh);\n\n\tresp->status = fh_getattr(fh, &resp->stat);\n\nout:\n\t \n\tposix_acl_release(argp->acl_access);\n\tposix_acl_release(argp->acl_default);\n\treturn rpc_success;\n\nout_drop_lock:\n\tinode_unlock(inode);\n\tfh_drop_write(fh);\nout_errno:\n\tresp->status = nfserrno(error);\n\tgoto out;\n}\n\n \nstatic __be32 nfsacld_proc_getattr(struct svc_rqst *rqstp)\n{\n\tstruct nfsd_fhandle *argp = rqstp->rq_argp;\n\tstruct nfsd_attrstat *resp = rqstp->rq_resp;\n\n\tdprintk(\"nfsd: GETATTR  %s\\n\", SVCFH_fmt(&argp->fh));\n\n\tfh_copy(&resp->fh, &argp->fh);\n\tresp->status = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_NOP);\n\tif (resp->status != nfs_ok)\n\t\tgoto out;\n\tresp->status = fh_getattr(&resp->fh, &resp->stat);\nout:\n\treturn rpc_success;\n}\n\n \nstatic __be32 nfsacld_proc_access(struct svc_rqst *rqstp)\n{\n\tstruct nfsd3_accessargs *argp = rqstp->rq_argp;\n\tstruct nfsd3_accessres *resp = rqstp->rq_resp;\n\n\tdprintk(\"nfsd: ACCESS(2acl)   %s 0x%x\\n\",\n\t\t\tSVCFH_fmt(&argp->fh),\n\t\t\targp->access);\n\n\tfh_copy(&resp->fh, &argp->fh);\n\tresp->access = argp->access;\n\tresp->status = nfsd_access(rqstp, &resp->fh, &resp->access, NULL);\n\tif (resp->status != nfs_ok)\n\t\tgoto out;\n\tresp->status = fh_getattr(&resp->fh, &resp->stat);\nout:\n\treturn rpc_success;\n}\n\n \n\nstatic bool\nnfsaclsvc_decode_getaclargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nfsd3_getaclargs *argp = rqstp->rq_argp;\n\n\tif (!svcxdr_decode_fhandle(xdr, &argp->fh))\n\t\treturn false;\n\tif (xdr_stream_decode_u32(xdr, &argp->mask) < 0)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool\nnfsaclsvc_decode_setaclargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nfsd3_setaclargs *argp = rqstp->rq_argp;\n\n\tif (!svcxdr_decode_fhandle(xdr, &argp->fh))\n\t\treturn false;\n\tif (xdr_stream_decode_u32(xdr, &argp->mask) < 0)\n\t\treturn false;\n\tif (argp->mask & ~NFS_ACL_MASK)\n\t\treturn false;\n\tif (!nfs_stream_decode_acl(xdr, NULL, (argp->mask & NFS_ACL) ?\n\t\t\t\t   &argp->acl_access : NULL))\n\t\treturn false;\n\tif (!nfs_stream_decode_acl(xdr, NULL, (argp->mask & NFS_DFACL) ?\n\t\t\t\t   &argp->acl_default : NULL))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool\nnfsaclsvc_decode_accessargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nfsd3_accessargs *args = rqstp->rq_argp;\n\n\tif (!svcxdr_decode_fhandle(xdr, &args->fh))\n\t\treturn false;\n\tif (xdr_stream_decode_u32(xdr, &args->access) < 0)\n\t\treturn false;\n\n\treturn true;\n}\n\n \n\n \nstatic bool\nnfsaclsvc_encode_getaclres(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nfsd3_getaclres *resp = rqstp->rq_resp;\n\tstruct dentry *dentry = resp->fh.fh_dentry;\n\tstruct inode *inode;\n\n\tif (!svcxdr_encode_stat(xdr, resp->status))\n\t\treturn false;\n\n\tif (dentry == NULL || d_really_is_negative(dentry))\n\t\treturn true;\n\tinode = d_inode(dentry);\n\n\tif (!svcxdr_encode_fattr(rqstp, xdr, &resp->fh, &resp->stat))\n\t\treturn false;\n\tif (xdr_stream_encode_u32(xdr, resp->mask) < 0)\n\t\treturn false;\n\n\tif (!nfs_stream_encode_acl(xdr, inode, resp->acl_access,\n\t\t\t\t   resp->mask & NFS_ACL, 0))\n\t\treturn false;\n\tif (!nfs_stream_encode_acl(xdr, inode, resp->acl_default,\n\t\t\t\t   resp->mask & NFS_DFACL, NFS_ACL_DEFAULT))\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic bool\nnfsaclsvc_encode_accessres(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nfsd3_accessres *resp = rqstp->rq_resp;\n\n\tif (!svcxdr_encode_stat(xdr, resp->status))\n\t\treturn false;\n\tswitch (resp->status) {\n\tcase nfs_ok:\n\t\tif (!svcxdr_encode_fattr(rqstp, xdr, &resp->fh, &resp->stat))\n\t\t\treturn false;\n\t\tif (xdr_stream_encode_u32(xdr, resp->access) < 0)\n\t\t\treturn false;\n\t\tbreak;\n\t}\n\n\treturn true;\n}\n\n \nstatic void nfsaclsvc_release_getacl(struct svc_rqst *rqstp)\n{\n\tstruct nfsd3_getaclres *resp = rqstp->rq_resp;\n\n\tfh_put(&resp->fh);\n\tposix_acl_release(resp->acl_access);\n\tposix_acl_release(resp->acl_default);\n}\n\nstatic void nfsaclsvc_release_access(struct svc_rqst *rqstp)\n{\n\tstruct nfsd3_accessres *resp = rqstp->rq_resp;\n\n\tfh_put(&resp->fh);\n}\n\nstruct nfsd3_voidargs { int dummy; };\n\n#define ST 1\t\t \n#define AT 21\t\t \n#define pAT (1+AT)\t \n#define ACL (1+NFS_ACL_MAX_ENTRIES*3)   \n\nstatic const struct svc_procedure nfsd_acl_procedures2[5] = {\n\t[ACLPROC2_NULL] = {\n\t\t.pc_func = nfsacld_proc_null,\n\t\t.pc_decode = nfssvc_decode_voidarg,\n\t\t.pc_encode = nfssvc_encode_voidres,\n\t\t.pc_argsize = sizeof(struct nfsd_voidargs),\n\t\t.pc_argzero = sizeof(struct nfsd_voidargs),\n\t\t.pc_ressize = sizeof(struct nfsd_voidres),\n\t\t.pc_cachetype = RC_NOCACHE,\n\t\t.pc_xdrressize = ST,\n\t\t.pc_name = \"NULL\",\n\t},\n\t[ACLPROC2_GETACL] = {\n\t\t.pc_func = nfsacld_proc_getacl,\n\t\t.pc_decode = nfsaclsvc_decode_getaclargs,\n\t\t.pc_encode = nfsaclsvc_encode_getaclres,\n\t\t.pc_release = nfsaclsvc_release_getacl,\n\t\t.pc_argsize = sizeof(struct nfsd3_getaclargs),\n\t\t.pc_argzero = sizeof(struct nfsd3_getaclargs),\n\t\t.pc_ressize = sizeof(struct nfsd3_getaclres),\n\t\t.pc_cachetype = RC_NOCACHE,\n\t\t.pc_xdrressize = ST+1+2*(1+ACL),\n\t\t.pc_name = \"GETACL\",\n\t},\n\t[ACLPROC2_SETACL] = {\n\t\t.pc_func = nfsacld_proc_setacl,\n\t\t.pc_decode = nfsaclsvc_decode_setaclargs,\n\t\t.pc_encode = nfssvc_encode_attrstatres,\n\t\t.pc_release = nfssvc_release_attrstat,\n\t\t.pc_argsize = sizeof(struct nfsd3_setaclargs),\n\t\t.pc_argzero = sizeof(struct nfsd3_setaclargs),\n\t\t.pc_ressize = sizeof(struct nfsd_attrstat),\n\t\t.pc_cachetype = RC_NOCACHE,\n\t\t.pc_xdrressize = ST+AT,\n\t\t.pc_name = \"SETACL\",\n\t},\n\t[ACLPROC2_GETATTR] = {\n\t\t.pc_func = nfsacld_proc_getattr,\n\t\t.pc_decode = nfssvc_decode_fhandleargs,\n\t\t.pc_encode = nfssvc_encode_attrstatres,\n\t\t.pc_release = nfssvc_release_attrstat,\n\t\t.pc_argsize = sizeof(struct nfsd_fhandle),\n\t\t.pc_argzero = sizeof(struct nfsd_fhandle),\n\t\t.pc_ressize = sizeof(struct nfsd_attrstat),\n\t\t.pc_cachetype = RC_NOCACHE,\n\t\t.pc_xdrressize = ST+AT,\n\t\t.pc_name = \"GETATTR\",\n\t},\n\t[ACLPROC2_ACCESS] = {\n\t\t.pc_func = nfsacld_proc_access,\n\t\t.pc_decode = nfsaclsvc_decode_accessargs,\n\t\t.pc_encode = nfsaclsvc_encode_accessres,\n\t\t.pc_release = nfsaclsvc_release_access,\n\t\t.pc_argsize = sizeof(struct nfsd3_accessargs),\n\t\t.pc_argzero = sizeof(struct nfsd3_accessargs),\n\t\t.pc_ressize = sizeof(struct nfsd3_accessres),\n\t\t.pc_cachetype = RC_NOCACHE,\n\t\t.pc_xdrressize = ST+AT+1,\n\t\t.pc_name = \"SETATTR\",\n\t},\n};\n\nstatic DEFINE_PER_CPU_ALIGNED(unsigned long,\n\t\t\t      nfsd_acl_count2[ARRAY_SIZE(nfsd_acl_procedures2)]);\nconst struct svc_version nfsd_acl_version2 = {\n\t.vs_vers\t= 2,\n\t.vs_nproc\t= ARRAY_SIZE(nfsd_acl_procedures2),\n\t.vs_proc\t= nfsd_acl_procedures2,\n\t.vs_count\t= nfsd_acl_count2,\n\t.vs_dispatch\t= nfsd_dispatch,\n\t.vs_xdrsize\t= NFS3_SVC_XDRSIZE,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}