{
  "module_name": "flexfilelayoutxdr.c",
  "hash_id": "9f46d4cb7bb92be70b62696f106cee44ad45ebc3e433c628d4e28ef6e8ea5ca5",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfsd/flexfilelayoutxdr.c",
  "human_readable_source": "\n \n#include <linux/sunrpc/svc.h>\n#include <linux/nfs4.h>\n\n#include \"nfsd.h\"\n#include \"flexfilelayoutxdr.h\"\n\n#define NFSDDBG_FACILITY\tNFSDDBG_PNFS\n\nstruct ff_idmap {\n\tchar buf[11];\n\tint len;\n};\n\n__be32\nnfsd4_ff_encode_layoutget(struct xdr_stream *xdr,\n\t\tstruct nfsd4_layoutget *lgp)\n{\n\tstruct pnfs_ff_layout *fl = lgp->lg_content;\n\tint len, mirror_len, ds_len, fh_len;\n\t__be32 *p;\n\n\t \n\tstruct ff_idmap uid;\n\tstruct ff_idmap gid;\n\n\tfh_len = 4 + fl->fh.size;\n\n\tuid.len = sprintf(uid.buf, \"%u\", from_kuid(&init_user_ns, fl->uid));\n\tgid.len = sprintf(gid.buf, \"%u\", from_kgid(&init_user_ns, fl->gid));\n\n\t \n\tds_len = 20 + sizeof(stateid_opaque_t) + 4 + fh_len +\n\t\t 8 + uid.len + 8 + gid.len;\n\n\tmirror_len = 4 + ds_len;\n\n\t \n\tlen = 20 + mirror_len;\n\n\tp = xdr_reserve_space(xdr, sizeof(__be32) + len);\n\tif (!p)\n\t\treturn nfserr_toosmall;\n\n\t*p++ = cpu_to_be32(len);\n\tp = xdr_encode_hyper(p, 0);\t\t \n\n\t*p++ = cpu_to_be32(1);\t\t\t \n\t*p++ = cpu_to_be32(1);\t\t\t \n\n\tp = xdr_encode_opaque_fixed(p, &fl->deviceid,\n\t\t\tsizeof(struct nfsd4_deviceid));\n\n\t*p++ = cpu_to_be32(1);\t\t\t \n\n\t*p++ = cpu_to_be32(fl->stateid.si_generation);\n\tp = xdr_encode_opaque_fixed(p, &fl->stateid.si_opaque,\n\t\t\t\t    sizeof(stateid_opaque_t));\n\n\t*p++ = cpu_to_be32(1);\t\t\t \n\tp = xdr_encode_opaque(p, fl->fh.data, fl->fh.size);\n\n\tp = xdr_encode_opaque(p, uid.buf, uid.len);\n\tp = xdr_encode_opaque(p, gid.buf, gid.len);\n\n\t*p++ = cpu_to_be32(fl->flags);\n\t*p++ = cpu_to_be32(0);\t\t\t \n\n\treturn 0;\n}\n\n__be32\nnfsd4_ff_encode_getdeviceinfo(struct xdr_stream *xdr,\n\t\tstruct nfsd4_getdeviceinfo *gdp)\n{\n\tstruct pnfs_ff_device_addr *da = gdp->gd_device;\n\tint len;\n\tint ver_len;\n\tint addr_len;\n\t__be32 *p;\n\n\t \n\tif (!gdp->gd_maxcount) {\n\t\tif (xdr_stream_encode_u32(xdr, 0) != XDR_UNIT)\n\t\t\treturn nfserr_resource;\n\t\treturn nfs_ok;\n\t}\n\n\t \n\taddr_len = 16 + da->netaddr.netid_len + da->netaddr.addr_len;\n\tver_len = 20;\n\n\tlen = 4 + ver_len + 4 + addr_len;\n\n\tp = xdr_reserve_space(xdr, len + sizeof(__be32));\n\tif (!p)\n\t\treturn nfserr_resource;\n\n\t \n\t*p++ = cpu_to_be32(len);\n\t*p++ = cpu_to_be32(1);\t\t\t \n\tp = xdr_encode_opaque(p, da->netaddr.netid, da->netaddr.netid_len);\n\tp = xdr_encode_opaque(p, da->netaddr.addr, da->netaddr.addr_len);\n\n\t*p++ = cpu_to_be32(1);\t\t\t \n\n\t*p++ = cpu_to_be32(da->version);\n\t*p++ = cpu_to_be32(da->minor_version);\n\t*p++ = cpu_to_be32(da->rsize);\n\t*p++ = cpu_to_be32(da->wsize);\n\t*p++ = cpu_to_be32(da->tightly_coupled);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}