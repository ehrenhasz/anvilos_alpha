{
  "module_name": "nfs3xdr.c",
  "hash_id": "e1c958880481ab166ec2fbe781c649189622f32f8c6465e7817be4dc0f86beab",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfsd/nfs3xdr.c",
  "human_readable_source": "\n \n\n#include <linux/namei.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include \"xdr3.h\"\n#include \"auth.h\"\n#include \"netns.h\"\n#include \"vfs.h\"\n\n \nstatic const struct svc_fh nfs3svc_null_fh = {\n\t.fh_no_wcc\t= true,\n};\n\n \nstatic const struct timespec64 nfs3svc_time_delta = {\n\t.tv_sec\t\t= 1,\n\t.tv_nsec\t= 0,\n};\n\n \nstatic const u32 nfs3_ftypes[] = {\n\tNF3NON,  NF3FIFO, NF3CHR, NF3BAD,\n\tNF3DIR,  NF3BAD,  NF3BLK, NF3BAD,\n\tNF3REG,  NF3BAD,  NF3LNK, NF3BAD,\n\tNF3SOCK, NF3BAD,  NF3LNK, NF3BAD,\n};\n\n\n \n\nstatic __be32 *\nencode_nfstime3(__be32 *p, const struct timespec64 *time)\n{\n\t*p++ = cpu_to_be32((u32)time->tv_sec);\n\t*p++ = cpu_to_be32(time->tv_nsec);\n\n\treturn p;\n}\n\nstatic bool\nsvcxdr_decode_nfstime3(struct xdr_stream *xdr, struct timespec64 *timep)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, XDR_UNIT * 2);\n\tif (!p)\n\t\treturn false;\n\ttimep->tv_sec = be32_to_cpup(p++);\n\ttimep->tv_nsec = be32_to_cpup(p);\n\n\treturn true;\n}\n\n \nbool\nsvcxdr_decode_nfs_fh3(struct xdr_stream *xdr, struct svc_fh *fhp)\n{\n\t__be32 *p;\n\tu32 size;\n\n\tif (xdr_stream_decode_u32(xdr, &size) < 0)\n\t\treturn false;\n\tif (size == 0 || size > NFS3_FHSIZE)\n\t\treturn false;\n\tp = xdr_inline_decode(xdr, size);\n\tif (!p)\n\t\treturn false;\n\tfh_init(fhp, NFS3_FHSIZE);\n\tfhp->fh_handle.fh_size = size;\n\tmemcpy(&fhp->fh_handle.fh_raw, p, size);\n\n\treturn true;\n}\n\n \nbool\nsvcxdr_encode_nfsstat3(struct xdr_stream *xdr, __be32 status)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, sizeof(status));\n\tif (!p)\n\t\treturn false;\n\t*p = status;\n\n\treturn true;\n}\n\nstatic bool\nsvcxdr_encode_nfs_fh3(struct xdr_stream *xdr, const struct svc_fh *fhp)\n{\n\tu32 size = fhp->fh_handle.fh_size;\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, XDR_UNIT + size);\n\tif (!p)\n\t\treturn false;\n\t*p++ = cpu_to_be32(size);\n\tif (size)\n\t\tp[XDR_QUADLEN(size) - 1] = 0;\n\tmemcpy(p, &fhp->fh_handle.fh_raw, size);\n\n\treturn true;\n}\n\nstatic bool\nsvcxdr_encode_post_op_fh3(struct xdr_stream *xdr, const struct svc_fh *fhp)\n{\n\tif (xdr_stream_encode_item_present(xdr) < 0)\n\t\treturn false;\n\tif (!svcxdr_encode_nfs_fh3(xdr, fhp))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool\nsvcxdr_encode_cookieverf3(struct xdr_stream *xdr, const __be32 *verf)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, NFS3_COOKIEVERFSIZE);\n\tif (!p)\n\t\treturn false;\n\tmemcpy(p, verf, NFS3_COOKIEVERFSIZE);\n\n\treturn true;\n}\n\nstatic bool\nsvcxdr_encode_writeverf3(struct xdr_stream *xdr, const __be32 *verf)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, NFS3_WRITEVERFSIZE);\n\tif (!p)\n\t\treturn false;\n\tmemcpy(p, verf, NFS3_WRITEVERFSIZE);\n\n\treturn true;\n}\n\nstatic bool\nsvcxdr_decode_filename3(struct xdr_stream *xdr, char **name, unsigned int *len)\n{\n\tu32 size, i;\n\t__be32 *p;\n\tchar *c;\n\n\tif (xdr_stream_decode_u32(xdr, &size) < 0)\n\t\treturn false;\n\tif (size == 0 || size > NFS3_MAXNAMLEN)\n\t\treturn false;\n\tp = xdr_inline_decode(xdr, size);\n\tif (!p)\n\t\treturn false;\n\n\t*len = size;\n\t*name = (char *)p;\n\tfor (i = 0, c = *name; i < size; i++, c++) {\n\t\tif (*c == '\\0' || *c == '/')\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool\nsvcxdr_decode_diropargs3(struct xdr_stream *xdr, struct svc_fh *fhp,\n\t\t\t char **name, unsigned int *len)\n{\n\treturn svcxdr_decode_nfs_fh3(xdr, fhp) &&\n\t\tsvcxdr_decode_filename3(xdr, name, len);\n}\n\nstatic bool\nsvcxdr_decode_sattr3(struct svc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t     struct iattr *iap)\n{\n\tu32 set_it;\n\n\tiap->ia_valid = 0;\n\n\tif (xdr_stream_decode_bool(xdr, &set_it) < 0)\n\t\treturn false;\n\tif (set_it) {\n\t\tu32 mode;\n\n\t\tif (xdr_stream_decode_u32(xdr, &mode) < 0)\n\t\t\treturn false;\n\t\tiap->ia_valid |= ATTR_MODE;\n\t\tiap->ia_mode = mode;\n\t}\n\tif (xdr_stream_decode_bool(xdr, &set_it) < 0)\n\t\treturn false;\n\tif (set_it) {\n\t\tu32 uid;\n\n\t\tif (xdr_stream_decode_u32(xdr, &uid) < 0)\n\t\t\treturn false;\n\t\tiap->ia_uid = make_kuid(nfsd_user_namespace(rqstp), uid);\n\t\tif (uid_valid(iap->ia_uid))\n\t\t\tiap->ia_valid |= ATTR_UID;\n\t}\n\tif (xdr_stream_decode_bool(xdr, &set_it) < 0)\n\t\treturn false;\n\tif (set_it) {\n\t\tu32 gid;\n\n\t\tif (xdr_stream_decode_u32(xdr, &gid) < 0)\n\t\t\treturn false;\n\t\tiap->ia_gid = make_kgid(nfsd_user_namespace(rqstp), gid);\n\t\tif (gid_valid(iap->ia_gid))\n\t\t\tiap->ia_valid |= ATTR_GID;\n\t}\n\tif (xdr_stream_decode_bool(xdr, &set_it) < 0)\n\t\treturn false;\n\tif (set_it) {\n\t\tu64 newsize;\n\n\t\tif (xdr_stream_decode_u64(xdr, &newsize) < 0)\n\t\t\treturn false;\n\t\tiap->ia_valid |= ATTR_SIZE;\n\t\tiap->ia_size = newsize;\n\t}\n\tif (xdr_stream_decode_u32(xdr, &set_it) < 0)\n\t\treturn false;\n\tswitch (set_it) {\n\tcase DONT_CHANGE:\n\t\tbreak;\n\tcase SET_TO_SERVER_TIME:\n\t\tiap->ia_valid |= ATTR_ATIME;\n\t\tbreak;\n\tcase SET_TO_CLIENT_TIME:\n\t\tif (!svcxdr_decode_nfstime3(xdr, &iap->ia_atime))\n\t\t\treturn false;\n\t\tiap->ia_valid |= ATTR_ATIME | ATTR_ATIME_SET;\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\tif (xdr_stream_decode_u32(xdr, &set_it) < 0)\n\t\treturn false;\n\tswitch (set_it) {\n\tcase DONT_CHANGE:\n\t\tbreak;\n\tcase SET_TO_SERVER_TIME:\n\t\tiap->ia_valid |= ATTR_MTIME;\n\t\tbreak;\n\tcase SET_TO_CLIENT_TIME:\n\t\tif (!svcxdr_decode_nfstime3(xdr, &iap->ia_mtime))\n\t\t\treturn false;\n\t\tiap->ia_valid |= ATTR_MTIME | ATTR_MTIME_SET;\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool\nsvcxdr_decode_sattrguard3(struct xdr_stream *xdr, struct nfsd3_sattrargs *args)\n{\n\t__be32 *p;\n\tu32 check;\n\n\tif (xdr_stream_decode_bool(xdr, &check) < 0)\n\t\treturn false;\n\tif (check) {\n\t\tp = xdr_inline_decode(xdr, XDR_UNIT * 2);\n\t\tif (!p)\n\t\t\treturn false;\n\t\targs->check_guard = 1;\n\t\targs->guardtime = be32_to_cpup(p);\n\t} else\n\t\targs->check_guard = 0;\n\n\treturn true;\n}\n\nstatic bool\nsvcxdr_decode_specdata3(struct xdr_stream *xdr, struct nfsd3_mknodargs *args)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, XDR_UNIT * 2);\n\tif (!p)\n\t\treturn false;\n\targs->major = be32_to_cpup(p++);\n\targs->minor = be32_to_cpup(p);\n\n\treturn true;\n}\n\nstatic bool\nsvcxdr_decode_devicedata3(struct svc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t\t  struct nfsd3_mknodargs *args)\n{\n\treturn svcxdr_decode_sattr3(rqstp, xdr, &args->attrs) &&\n\t\tsvcxdr_decode_specdata3(xdr, args);\n}\n\nstatic bool\nsvcxdr_encode_fattr3(struct svc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t     const struct svc_fh *fhp, const struct kstat *stat)\n{\n\tstruct user_namespace *userns = nfsd_user_namespace(rqstp);\n\t__be32 *p;\n\tu64 fsid;\n\n\tp = xdr_reserve_space(xdr, XDR_UNIT * 21);\n\tif (!p)\n\t\treturn false;\n\n\t*p++ = cpu_to_be32(nfs3_ftypes[(stat->mode & S_IFMT) >> 12]);\n\t*p++ = cpu_to_be32((u32)(stat->mode & S_IALLUGO));\n\t*p++ = cpu_to_be32((u32)stat->nlink);\n\t*p++ = cpu_to_be32((u32)from_kuid_munged(userns, stat->uid));\n\t*p++ = cpu_to_be32((u32)from_kgid_munged(userns, stat->gid));\n\tif (S_ISLNK(stat->mode) && stat->size > NFS3_MAXPATHLEN)\n\t\tp = xdr_encode_hyper(p, (u64)NFS3_MAXPATHLEN);\n\telse\n\t\tp = xdr_encode_hyper(p, (u64)stat->size);\n\n\t \n\tp = xdr_encode_hyper(p, ((u64)stat->blocks) << 9);\n\n\t \n\t*p++ = cpu_to_be32((u32)MAJOR(stat->rdev));\n\t*p++ = cpu_to_be32((u32)MINOR(stat->rdev));\n\n\tswitch(fsid_source(fhp)) {\n\tcase FSIDSOURCE_FSID:\n\t\tfsid = (u64)fhp->fh_export->ex_fsid;\n\t\tbreak;\n\tcase FSIDSOURCE_UUID:\n\t\tfsid = ((u64 *)fhp->fh_export->ex_uuid)[0];\n\t\tfsid ^= ((u64 *)fhp->fh_export->ex_uuid)[1];\n\t\tbreak;\n\tdefault:\n\t\tfsid = (u64)huge_encode_dev(fhp->fh_dentry->d_sb->s_dev);\n\t}\n\tp = xdr_encode_hyper(p, fsid);\n\n\t \n\tp = xdr_encode_hyper(p, stat->ino);\n\n\tp = encode_nfstime3(p, &stat->atime);\n\tp = encode_nfstime3(p, &stat->mtime);\n\tencode_nfstime3(p, &stat->ctime);\n\n\treturn true;\n}\n\nstatic bool\nsvcxdr_encode_wcc_attr(struct xdr_stream *xdr, const struct svc_fh *fhp)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, XDR_UNIT * 6);\n\tif (!p)\n\t\treturn false;\n\tp = xdr_encode_hyper(p, (u64)fhp->fh_pre_size);\n\tp = encode_nfstime3(p, &fhp->fh_pre_mtime);\n\tencode_nfstime3(p, &fhp->fh_pre_ctime);\n\n\treturn true;\n}\n\nstatic bool\nsvcxdr_encode_pre_op_attr(struct xdr_stream *xdr, const struct svc_fh *fhp)\n{\n\tif (!fhp->fh_pre_saved) {\n\t\tif (xdr_stream_encode_item_absent(xdr) < 0)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tif (xdr_stream_encode_item_present(xdr) < 0)\n\t\treturn false;\n\treturn svcxdr_encode_wcc_attr(xdr, fhp);\n}\n\n \nbool\nsvcxdr_encode_post_op_attr(struct svc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t\t   const struct svc_fh *fhp)\n{\n\tstruct dentry *dentry = fhp->fh_dentry;\n\tstruct kstat stat;\n\n\t \n\tif (fhp->fh_no_wcc || !dentry || !d_really_is_positive(dentry))\n\t\tgoto no_post_op_attrs;\n\tif (fh_getattr(fhp, &stat) != nfs_ok)\n\t\tgoto no_post_op_attrs;\n\n\tif (xdr_stream_encode_item_present(xdr) < 0)\n\t\treturn false;\n\tlease_get_mtime(d_inode(dentry), &stat.mtime);\n\tif (!svcxdr_encode_fattr3(rqstp, xdr, fhp, &stat))\n\t\treturn false;\n\n\treturn true;\n\nno_post_op_attrs:\n\treturn xdr_stream_encode_item_absent(xdr) > 0;\n}\n\n \nstatic bool\nsvcxdr_encode_wcc_data(struct svc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t       const struct svc_fh *fhp)\n{\n\tstruct dentry *dentry = fhp->fh_dentry;\n\n\tif (!dentry || !d_really_is_positive(dentry) || !fhp->fh_post_saved)\n\t\tgoto neither;\n\n\t \n\tif (!svcxdr_encode_pre_op_attr(xdr, fhp))\n\t\treturn false;\n\n\t \n\tif (xdr_stream_encode_item_present(xdr) < 0)\n\t\treturn false;\n\tif (!svcxdr_encode_fattr3(rqstp, xdr, fhp, &fhp->fh_post_attr))\n\t\treturn false;\n\n\treturn true;\n\nneither:\n\tif (xdr_stream_encode_item_absent(xdr) < 0)\n\t\treturn false;\n\tif (!svcxdr_encode_post_op_attr(rqstp, xdr, fhp))\n\t\treturn false;\n\n\treturn true;\n}\n\n \n\nbool\nnfs3svc_decode_fhandleargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nfsd_fhandle *args = rqstp->rq_argp;\n\n\treturn svcxdr_decode_nfs_fh3(xdr, &args->fh);\n}\n\nbool\nnfs3svc_decode_sattrargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nfsd3_sattrargs *args = rqstp->rq_argp;\n\n\treturn svcxdr_decode_nfs_fh3(xdr, &args->fh) &&\n\t\tsvcxdr_decode_sattr3(rqstp, xdr, &args->attrs) &&\n\t\tsvcxdr_decode_sattrguard3(xdr, args);\n}\n\nbool\nnfs3svc_decode_diropargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nfsd3_diropargs *args = rqstp->rq_argp;\n\n\treturn svcxdr_decode_diropargs3(xdr, &args->fh, &args->name, &args->len);\n}\n\nbool\nnfs3svc_decode_accessargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nfsd3_accessargs *args = rqstp->rq_argp;\n\n\tif (!svcxdr_decode_nfs_fh3(xdr, &args->fh))\n\t\treturn false;\n\tif (xdr_stream_decode_u32(xdr, &args->access) < 0)\n\t\treturn false;\n\n\treturn true;\n}\n\nbool\nnfs3svc_decode_readargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nfsd3_readargs *args = rqstp->rq_argp;\n\n\tif (!svcxdr_decode_nfs_fh3(xdr, &args->fh))\n\t\treturn false;\n\tif (xdr_stream_decode_u64(xdr, &args->offset) < 0)\n\t\treturn false;\n\tif (xdr_stream_decode_u32(xdr, &args->count) < 0)\n\t\treturn false;\n\n\treturn true;\n}\n\nbool\nnfs3svc_decode_writeargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nfsd3_writeargs *args = rqstp->rq_argp;\n\tu32 max_blocksize = svc_max_payload(rqstp);\n\n\tif (!svcxdr_decode_nfs_fh3(xdr, &args->fh))\n\t\treturn false;\n\tif (xdr_stream_decode_u64(xdr, &args->offset) < 0)\n\t\treturn false;\n\tif (xdr_stream_decode_u32(xdr, &args->count) < 0)\n\t\treturn false;\n\tif (xdr_stream_decode_u32(xdr, &args->stable) < 0)\n\t\treturn false;\n\n\t \n\tif (xdr_stream_decode_u32(xdr, &args->len) < 0)\n\t\treturn false;\n\n\t \n\tif (args->count != args->len)\n\t\treturn false;\n\tif (args->count > max_blocksize) {\n\t\targs->count = max_blocksize;\n\t\targs->len = max_blocksize;\n\t}\n\n\treturn xdr_stream_subsegment(xdr, &args->payload, args->count);\n}\n\nbool\nnfs3svc_decode_createargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nfsd3_createargs *args = rqstp->rq_argp;\n\n\tif (!svcxdr_decode_diropargs3(xdr, &args->fh, &args->name, &args->len))\n\t\treturn false;\n\tif (xdr_stream_decode_u32(xdr, &args->createmode) < 0)\n\t\treturn false;\n\tswitch (args->createmode) {\n\tcase NFS3_CREATE_UNCHECKED:\n\tcase NFS3_CREATE_GUARDED:\n\t\treturn svcxdr_decode_sattr3(rqstp, xdr, &args->attrs);\n\tcase NFS3_CREATE_EXCLUSIVE:\n\t\targs->verf = xdr_inline_decode(xdr, NFS3_CREATEVERFSIZE);\n\t\tif (!args->verf)\n\t\t\treturn false;\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool\nnfs3svc_decode_mkdirargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nfsd3_createargs *args = rqstp->rq_argp;\n\n\treturn svcxdr_decode_diropargs3(xdr, &args->fh,\n\t\t\t\t\t&args->name, &args->len) &&\n\t\tsvcxdr_decode_sattr3(rqstp, xdr, &args->attrs);\n}\n\nbool\nnfs3svc_decode_symlinkargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nfsd3_symlinkargs *args = rqstp->rq_argp;\n\tstruct kvec *head = rqstp->rq_arg.head;\n\n\tif (!svcxdr_decode_diropargs3(xdr, &args->ffh, &args->fname, &args->flen))\n\t\treturn false;\n\tif (!svcxdr_decode_sattr3(rqstp, xdr, &args->attrs))\n\t\treturn false;\n\tif (xdr_stream_decode_u32(xdr, &args->tlen) < 0)\n\t\treturn false;\n\n\t \n\targs->first.iov_len = head->iov_len - xdr_stream_pos(xdr);\n\targs->first.iov_base = xdr_inline_decode(xdr, args->tlen);\n\treturn args->first.iov_base != NULL;\n}\n\nbool\nnfs3svc_decode_mknodargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nfsd3_mknodargs *args = rqstp->rq_argp;\n\n\tif (!svcxdr_decode_diropargs3(xdr, &args->fh, &args->name, &args->len))\n\t\treturn false;\n\tif (xdr_stream_decode_u32(xdr, &args->ftype) < 0)\n\t\treturn false;\n\tswitch (args->ftype) {\n\tcase NF3CHR:\n\tcase NF3BLK:\n\t\treturn svcxdr_decode_devicedata3(rqstp, xdr, args);\n\tcase NF3SOCK:\n\tcase NF3FIFO:\n\t\treturn svcxdr_decode_sattr3(rqstp, xdr, &args->attrs);\n\tcase NF3REG:\n\tcase NF3DIR:\n\tcase NF3LNK:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nbool\nnfs3svc_decode_renameargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nfsd3_renameargs *args = rqstp->rq_argp;\n\n\treturn svcxdr_decode_diropargs3(xdr, &args->ffh,\n\t\t\t\t\t&args->fname, &args->flen) &&\n\t\tsvcxdr_decode_diropargs3(xdr, &args->tfh,\n\t\t\t\t\t &args->tname, &args->tlen);\n}\n\nbool\nnfs3svc_decode_linkargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nfsd3_linkargs *args = rqstp->rq_argp;\n\n\treturn svcxdr_decode_nfs_fh3(xdr, &args->ffh) &&\n\t\tsvcxdr_decode_diropargs3(xdr, &args->tfh,\n\t\t\t\t\t &args->tname, &args->tlen);\n}\n\nbool\nnfs3svc_decode_readdirargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nfsd3_readdirargs *args = rqstp->rq_argp;\n\n\tif (!svcxdr_decode_nfs_fh3(xdr, &args->fh))\n\t\treturn false;\n\tif (xdr_stream_decode_u64(xdr, &args->cookie) < 0)\n\t\treturn false;\n\targs->verf = xdr_inline_decode(xdr, NFS3_COOKIEVERFSIZE);\n\tif (!args->verf)\n\t\treturn false;\n\tif (xdr_stream_decode_u32(xdr, &args->count) < 0)\n\t\treturn false;\n\n\treturn true;\n}\n\nbool\nnfs3svc_decode_readdirplusargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nfsd3_readdirargs *args = rqstp->rq_argp;\n\tu32 dircount;\n\n\tif (!svcxdr_decode_nfs_fh3(xdr, &args->fh))\n\t\treturn false;\n\tif (xdr_stream_decode_u64(xdr, &args->cookie) < 0)\n\t\treturn false;\n\targs->verf = xdr_inline_decode(xdr, NFS3_COOKIEVERFSIZE);\n\tif (!args->verf)\n\t\treturn false;\n\t \n\tif (xdr_stream_decode_u32(xdr, &dircount) < 0)\n\t\treturn false;\n\tif (xdr_stream_decode_u32(xdr, &args->count) < 0)\n\t\treturn false;\n\n\treturn true;\n}\n\nbool\nnfs3svc_decode_commitargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nfsd3_commitargs *args = rqstp->rq_argp;\n\n\tif (!svcxdr_decode_nfs_fh3(xdr, &args->fh))\n\t\treturn false;\n\tif (xdr_stream_decode_u64(xdr, &args->offset) < 0)\n\t\treturn false;\n\tif (xdr_stream_decode_u32(xdr, &args->count) < 0)\n\t\treturn false;\n\n\treturn true;\n}\n\n \n\n \nbool\nnfs3svc_encode_getattrres(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nfsd3_attrstat *resp = rqstp->rq_resp;\n\n\tif (!svcxdr_encode_nfsstat3(xdr, resp->status))\n\t\treturn false;\n\tswitch (resp->status) {\n\tcase nfs_ok:\n\t\tlease_get_mtime(d_inode(resp->fh.fh_dentry), &resp->stat.mtime);\n\t\tif (!svcxdr_encode_fattr3(rqstp, xdr, &resp->fh, &resp->stat))\n\t\t\treturn false;\n\t\tbreak;\n\t}\n\n\treturn true;\n}\n\n \nbool\nnfs3svc_encode_wccstat(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nfsd3_attrstat *resp = rqstp->rq_resp;\n\n\treturn svcxdr_encode_nfsstat3(xdr, resp->status) &&\n\t\tsvcxdr_encode_wcc_data(rqstp, xdr, &resp->fh);\n}\n\n \nbool\nnfs3svc_encode_lookupres(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nfsd3_diropres *resp = rqstp->rq_resp;\n\n\tif (!svcxdr_encode_nfsstat3(xdr, resp->status))\n\t\treturn false;\n\tswitch (resp->status) {\n\tcase nfs_ok:\n\t\tif (!svcxdr_encode_nfs_fh3(xdr, &resp->fh))\n\t\t\treturn false;\n\t\tif (!svcxdr_encode_post_op_attr(rqstp, xdr, &resp->fh))\n\t\t\treturn false;\n\t\tif (!svcxdr_encode_post_op_attr(rqstp, xdr, &resp->dirfh))\n\t\t\treturn false;\n\t\tbreak;\n\tdefault:\n\t\tif (!svcxdr_encode_post_op_attr(rqstp, xdr, &resp->dirfh))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nbool\nnfs3svc_encode_accessres(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nfsd3_accessres *resp = rqstp->rq_resp;\n\n\tif (!svcxdr_encode_nfsstat3(xdr, resp->status))\n\t\treturn false;\n\tswitch (resp->status) {\n\tcase nfs_ok:\n\t\tif (!svcxdr_encode_post_op_attr(rqstp, xdr, &resp->fh))\n\t\t\treturn false;\n\t\tif (xdr_stream_encode_u32(xdr, resp->access) < 0)\n\t\t\treturn false;\n\t\tbreak;\n\tdefault:\n\t\tif (!svcxdr_encode_post_op_attr(rqstp, xdr, &resp->fh))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nbool\nnfs3svc_encode_readlinkres(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nfsd3_readlinkres *resp = rqstp->rq_resp;\n\tstruct kvec *head = rqstp->rq_res.head;\n\n\tif (!svcxdr_encode_nfsstat3(xdr, resp->status))\n\t\treturn false;\n\tswitch (resp->status) {\n\tcase nfs_ok:\n\t\tif (!svcxdr_encode_post_op_attr(rqstp, xdr, &resp->fh))\n\t\t\treturn false;\n\t\tif (xdr_stream_encode_u32(xdr, resp->len) < 0)\n\t\t\treturn false;\n\t\tsvcxdr_encode_opaque_pages(rqstp, xdr, resp->pages, 0,\n\t\t\t\t\t   resp->len);\n\t\tif (svc_encode_result_payload(rqstp, head->iov_len, resp->len) < 0)\n\t\t\treturn false;\n\t\tbreak;\n\tdefault:\n\t\tif (!svcxdr_encode_post_op_attr(rqstp, xdr, &resp->fh))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nbool\nnfs3svc_encode_readres(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nfsd3_readres *resp = rqstp->rq_resp;\n\tstruct kvec *head = rqstp->rq_res.head;\n\n\tif (!svcxdr_encode_nfsstat3(xdr, resp->status))\n\t\treturn false;\n\tswitch (resp->status) {\n\tcase nfs_ok:\n\t\tif (!svcxdr_encode_post_op_attr(rqstp, xdr, &resp->fh))\n\t\t\treturn false;\n\t\tif (xdr_stream_encode_u32(xdr, resp->count) < 0)\n\t\t\treturn false;\n\t\tif (xdr_stream_encode_bool(xdr, resp->eof) < 0)\n\t\t\treturn false;\n\t\tif (xdr_stream_encode_u32(xdr, resp->count) < 0)\n\t\t\treturn false;\n\t\tsvcxdr_encode_opaque_pages(rqstp, xdr, resp->pages,\n\t\t\t\t\t   rqstp->rq_res.page_base,\n\t\t\t\t\t   resp->count);\n\t\tif (svc_encode_result_payload(rqstp, head->iov_len, resp->count) < 0)\n\t\t\treturn false;\n\t\tbreak;\n\tdefault:\n\t\tif (!svcxdr_encode_post_op_attr(rqstp, xdr, &resp->fh))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nbool\nnfs3svc_encode_writeres(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nfsd3_writeres *resp = rqstp->rq_resp;\n\n\tif (!svcxdr_encode_nfsstat3(xdr, resp->status))\n\t\treturn false;\n\tswitch (resp->status) {\n\tcase nfs_ok:\n\t\tif (!svcxdr_encode_wcc_data(rqstp, xdr, &resp->fh))\n\t\t\treturn false;\n\t\tif (xdr_stream_encode_u32(xdr, resp->count) < 0)\n\t\t\treturn false;\n\t\tif (xdr_stream_encode_u32(xdr, resp->committed) < 0)\n\t\t\treturn false;\n\t\tif (!svcxdr_encode_writeverf3(xdr, resp->verf))\n\t\t\treturn false;\n\t\tbreak;\n\tdefault:\n\t\tif (!svcxdr_encode_wcc_data(rqstp, xdr, &resp->fh))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nbool\nnfs3svc_encode_createres(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nfsd3_diropres *resp = rqstp->rq_resp;\n\n\tif (!svcxdr_encode_nfsstat3(xdr, resp->status))\n\t\treturn false;\n\tswitch (resp->status) {\n\tcase nfs_ok:\n\t\tif (!svcxdr_encode_post_op_fh3(xdr, &resp->fh))\n\t\t\treturn false;\n\t\tif (!svcxdr_encode_post_op_attr(rqstp, xdr, &resp->fh))\n\t\t\treturn false;\n\t\tif (!svcxdr_encode_wcc_data(rqstp, xdr, &resp->dirfh))\n\t\t\treturn false;\n\t\tbreak;\n\tdefault:\n\t\tif (!svcxdr_encode_wcc_data(rqstp, xdr, &resp->dirfh))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nbool\nnfs3svc_encode_renameres(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nfsd3_renameres *resp = rqstp->rq_resp;\n\n\treturn svcxdr_encode_nfsstat3(xdr, resp->status) &&\n\t\tsvcxdr_encode_wcc_data(rqstp, xdr, &resp->ffh) &&\n\t\tsvcxdr_encode_wcc_data(rqstp, xdr, &resp->tfh);\n}\n\n \nbool\nnfs3svc_encode_linkres(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nfsd3_linkres *resp = rqstp->rq_resp;\n\n\treturn svcxdr_encode_nfsstat3(xdr, resp->status) &&\n\t\tsvcxdr_encode_post_op_attr(rqstp, xdr, &resp->fh) &&\n\t\tsvcxdr_encode_wcc_data(rqstp, xdr, &resp->tfh);\n}\n\n \nbool\nnfs3svc_encode_readdirres(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nfsd3_readdirres *resp = rqstp->rq_resp;\n\tstruct xdr_buf *dirlist = &resp->dirlist;\n\n\tif (!svcxdr_encode_nfsstat3(xdr, resp->status))\n\t\treturn false;\n\tswitch (resp->status) {\n\tcase nfs_ok:\n\t\tif (!svcxdr_encode_post_op_attr(rqstp, xdr, &resp->fh))\n\t\t\treturn false;\n\t\tif (!svcxdr_encode_cookieverf3(xdr, resp->verf))\n\t\t\treturn false;\n\t\tsvcxdr_encode_opaque_pages(rqstp, xdr, dirlist->pages, 0,\n\t\t\t\t\t   dirlist->len);\n\t\t \n\t\tif (xdr_stream_encode_item_absent(xdr) < 0)\n\t\t\treturn false;\n\t\tif (xdr_stream_encode_bool(xdr, resp->common.err == nfserr_eof) < 0)\n\t\t\treturn false;\n\t\tbreak;\n\tdefault:\n\t\tif (!svcxdr_encode_post_op_attr(rqstp, xdr, &resp->fh))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic __be32\ncompose_entry_fh(struct nfsd3_readdirres *cd, struct svc_fh *fhp,\n\t\t const char *name, int namlen, u64 ino)\n{\n\tstruct svc_export\t*exp;\n\tstruct dentry\t\t*dparent, *dchild;\n\t__be32 rv = nfserr_noent;\n\n\tdparent = cd->fh.fh_dentry;\n\texp  = cd->fh.fh_export;\n\n\tif (isdotent(name, namlen)) {\n\t\tif (namlen == 2) {\n\t\t\tdchild = dget_parent(dparent);\n\t\t\t \n\t\t\tif (dchild == dparent)\n\t\t\t\tgoto out;\n\t\t\tif (dparent == exp->ex_path.dentry)\n\t\t\t\tgoto out;\n\t\t} else\n\t\t\tdchild = dget(dparent);\n\t} else\n\t\tdchild = lookup_positive_unlocked(name, dparent, namlen);\n\tif (IS_ERR(dchild))\n\t\treturn rv;\n\tif (d_mountpoint(dchild))\n\t\tgoto out;\n\tif (dchild->d_inode->i_ino != ino)\n\t\tgoto out;\n\trv = fh_compose(fhp, exp, dchild, &cd->fh);\nout:\n\tdput(dchild);\n\treturn rv;\n}\n\n \nvoid nfs3svc_encode_cookie3(struct nfsd3_readdirres *resp, u64 offset)\n{\n\t__be64 cookie = cpu_to_be64(offset);\n\n\tif (!resp->cookie_offset)\n\t\treturn;\n\twrite_bytes_to_xdr_buf(&resp->dirlist, resp->cookie_offset, &cookie,\n\t\t\t       sizeof(cookie));\n\tresp->cookie_offset = 0;\n}\n\nstatic bool\nsvcxdr_encode_entry3_common(struct nfsd3_readdirres *resp, const char *name,\n\t\t\t    int namlen, loff_t offset, u64 ino)\n{\n\tstruct xdr_buf *dirlist = &resp->dirlist;\n\tstruct xdr_stream *xdr = &resp->xdr;\n\n\tif (xdr_stream_encode_item_present(xdr) < 0)\n\t\treturn false;\n\t \n\tif (xdr_stream_encode_u64(xdr, ino) < 0)\n\t\treturn false;\n\t \n\tif (xdr_stream_encode_opaque(xdr, name, min(namlen, NFS3_MAXNAMLEN)) < 0)\n\t\treturn false;\n\t \n\tresp->cookie_offset = dirlist->len;\n\tif (xdr_stream_encode_u64(xdr, OFFSET_MAX) < 0)\n\t\treturn false;\n\n\treturn true;\n}\n\n \nint nfs3svc_encode_entry3(void *data, const char *name, int namlen,\n\t\t\t  loff_t offset, u64 ino, unsigned int d_type)\n{\n\tstruct readdir_cd *ccd = data;\n\tstruct nfsd3_readdirres *resp = container_of(ccd,\n\t\t\t\t\t\t     struct nfsd3_readdirres,\n\t\t\t\t\t\t     common);\n\tunsigned int starting_length = resp->dirlist.len;\n\n\t \n\tnfs3svc_encode_cookie3(resp, offset);\n\n\tif (!svcxdr_encode_entry3_common(resp, name, namlen, offset, ino))\n\t\tgoto out_toosmall;\n\n\txdr_commit_encode(&resp->xdr);\n\tresp->common.err = nfs_ok;\n\treturn 0;\n\nout_toosmall:\n\tresp->cookie_offset = 0;\n\tresp->common.err = nfserr_toosmall;\n\tresp->dirlist.len = starting_length;\n\treturn -EINVAL;\n}\n\nstatic bool\nsvcxdr_encode_entry3_plus(struct nfsd3_readdirres *resp, const char *name,\n\t\t\t  int namlen, u64 ino)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tstruct svc_fh *fhp = &resp->scratch;\n\tbool result;\n\n\tresult = false;\n\tfh_init(fhp, NFS3_FHSIZE);\n\tif (compose_entry_fh(resp, fhp, name, namlen, ino) != nfs_ok)\n\t\tgoto out_noattrs;\n\n\tif (!svcxdr_encode_post_op_attr(resp->rqstp, xdr, fhp))\n\t\tgoto out;\n\tif (!svcxdr_encode_post_op_fh3(xdr, fhp))\n\t\tgoto out;\n\tresult = true;\n\nout:\n\tfh_put(fhp);\n\treturn result;\n\nout_noattrs:\n\tif (xdr_stream_encode_item_absent(xdr) < 0)\n\t\treturn false;\n\tif (xdr_stream_encode_item_absent(xdr) < 0)\n\t\treturn false;\n\treturn true;\n}\n\n \nint nfs3svc_encode_entryplus3(void *data, const char *name, int namlen,\n\t\t\t      loff_t offset, u64 ino, unsigned int d_type)\n{\n\tstruct readdir_cd *ccd = data;\n\tstruct nfsd3_readdirres *resp = container_of(ccd,\n\t\t\t\t\t\t     struct nfsd3_readdirres,\n\t\t\t\t\t\t     common);\n\tunsigned int starting_length = resp->dirlist.len;\n\n\t \n\tnfs3svc_encode_cookie3(resp, offset);\n\n\tif (!svcxdr_encode_entry3_common(resp, name, namlen, offset, ino))\n\t\tgoto out_toosmall;\n\tif (!svcxdr_encode_entry3_plus(resp, name, namlen, ino))\n\t\tgoto out_toosmall;\n\n\txdr_commit_encode(&resp->xdr);\n\tresp->common.err = nfs_ok;\n\treturn 0;\n\nout_toosmall:\n\tresp->cookie_offset = 0;\n\tresp->common.err = nfserr_toosmall;\n\tresp->dirlist.len = starting_length;\n\treturn -EINVAL;\n}\n\nstatic bool\nsvcxdr_encode_fsstat3resok(struct xdr_stream *xdr,\n\t\t\t   const struct nfsd3_fsstatres *resp)\n{\n\tconst struct kstatfs *s = &resp->stats;\n\tu64 bs = s->f_bsize;\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, XDR_UNIT * 13);\n\tif (!p)\n\t\treturn false;\n\tp = xdr_encode_hyper(p, bs * s->f_blocks);\t \n\tp = xdr_encode_hyper(p, bs * s->f_bfree);\t \n\tp = xdr_encode_hyper(p, bs * s->f_bavail);\t \n\tp = xdr_encode_hyper(p, s->f_files);\t\t \n\tp = xdr_encode_hyper(p, s->f_ffree);\t\t \n\tp = xdr_encode_hyper(p, s->f_ffree);\t\t \n\t*p = cpu_to_be32(resp->invarsec);\t\t \n\n\treturn true;\n}\n\n \nbool\nnfs3svc_encode_fsstatres(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nfsd3_fsstatres *resp = rqstp->rq_resp;\n\n\tif (!svcxdr_encode_nfsstat3(xdr, resp->status))\n\t\treturn false;\n\tswitch (resp->status) {\n\tcase nfs_ok:\n\t\tif (!svcxdr_encode_post_op_attr(rqstp, xdr, &nfs3svc_null_fh))\n\t\t\treturn false;\n\t\tif (!svcxdr_encode_fsstat3resok(xdr, resp))\n\t\t\treturn false;\n\t\tbreak;\n\tdefault:\n\t\tif (!svcxdr_encode_post_op_attr(rqstp, xdr, &nfs3svc_null_fh))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool\nsvcxdr_encode_fsinfo3resok(struct xdr_stream *xdr,\n\t\t\t   const struct nfsd3_fsinfores *resp)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, XDR_UNIT * 12);\n\tif (!p)\n\t\treturn false;\n\t*p++ = cpu_to_be32(resp->f_rtmax);\n\t*p++ = cpu_to_be32(resp->f_rtpref);\n\t*p++ = cpu_to_be32(resp->f_rtmult);\n\t*p++ = cpu_to_be32(resp->f_wtmax);\n\t*p++ = cpu_to_be32(resp->f_wtpref);\n\t*p++ = cpu_to_be32(resp->f_wtmult);\n\t*p++ = cpu_to_be32(resp->f_dtpref);\n\tp = xdr_encode_hyper(p, resp->f_maxfilesize);\n\tp = encode_nfstime3(p, &nfs3svc_time_delta);\n\t*p = cpu_to_be32(resp->f_properties);\n\n\treturn true;\n}\n\n \nbool\nnfs3svc_encode_fsinfores(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nfsd3_fsinfores *resp = rqstp->rq_resp;\n\n\tif (!svcxdr_encode_nfsstat3(xdr, resp->status))\n\t\treturn false;\n\tswitch (resp->status) {\n\tcase nfs_ok:\n\t\tif (!svcxdr_encode_post_op_attr(rqstp, xdr, &nfs3svc_null_fh))\n\t\t\treturn false;\n\t\tif (!svcxdr_encode_fsinfo3resok(xdr, resp))\n\t\t\treturn false;\n\t\tbreak;\n\tdefault:\n\t\tif (!svcxdr_encode_post_op_attr(rqstp, xdr, &nfs3svc_null_fh))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool\nsvcxdr_encode_pathconf3resok(struct xdr_stream *xdr,\n\t\t\t     const struct nfsd3_pathconfres *resp)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, XDR_UNIT * 6);\n\tif (!p)\n\t\treturn false;\n\t*p++ = cpu_to_be32(resp->p_link_max);\n\t*p++ = cpu_to_be32(resp->p_name_max);\n\tp = xdr_encode_bool(p, resp->p_no_trunc);\n\tp = xdr_encode_bool(p, resp->p_chown_restricted);\n\tp = xdr_encode_bool(p, resp->p_case_insensitive);\n\txdr_encode_bool(p, resp->p_case_preserving);\n\n\treturn true;\n}\n\n \nbool\nnfs3svc_encode_pathconfres(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nfsd3_pathconfres *resp = rqstp->rq_resp;\n\n\tif (!svcxdr_encode_nfsstat3(xdr, resp->status))\n\t\treturn false;\n\tswitch (resp->status) {\n\tcase nfs_ok:\n\t\tif (!svcxdr_encode_post_op_attr(rqstp, xdr, &nfs3svc_null_fh))\n\t\t\treturn false;\n\t\tif (!svcxdr_encode_pathconf3resok(xdr, resp))\n\t\t\treturn false;\n\t\tbreak;\n\tdefault:\n\t\tif (!svcxdr_encode_post_op_attr(rqstp, xdr, &nfs3svc_null_fh))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nbool\nnfs3svc_encode_commitres(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nfsd3_commitres *resp = rqstp->rq_resp;\n\n\tif (!svcxdr_encode_nfsstat3(xdr, resp->status))\n\t\treturn false;\n\tswitch (resp->status) {\n\tcase nfs_ok:\n\t\tif (!svcxdr_encode_wcc_data(rqstp, xdr, &resp->fh))\n\t\t\treturn false;\n\t\tif (!svcxdr_encode_writeverf3(xdr, resp->verf))\n\t\t\treturn false;\n\t\tbreak;\n\tdefault:\n\t\tif (!svcxdr_encode_wcc_data(rqstp, xdr, &resp->fh))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nvoid\nnfs3svc_release_fhandle(struct svc_rqst *rqstp)\n{\n\tstruct nfsd3_attrstat *resp = rqstp->rq_resp;\n\n\tfh_put(&resp->fh);\n}\n\nvoid\nnfs3svc_release_fhandle2(struct svc_rqst *rqstp)\n{\n\tstruct nfsd3_fhandle_pair *resp = rqstp->rq_resp;\n\n\tfh_put(&resp->fh1);\n\tfh_put(&resp->fh2);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}