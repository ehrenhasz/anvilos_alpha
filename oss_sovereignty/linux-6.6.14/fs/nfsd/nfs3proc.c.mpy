{
  "module_name": "nfs3proc.c",
  "hash_id": "e5549d80b99208997d0985667ea0ca5aff5b8045346917dc26a66b76ee29d6f5",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfsd/nfs3proc.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/ext2_fs.h>\n#include <linux/magic.h>\n#include <linux/namei.h>\n\n#include \"cache.h\"\n#include \"xdr3.h\"\n#include \"vfs.h\"\n#include \"filecache.h\"\n\n#define NFSDDBG_FACILITY\t\tNFSDDBG_PROC\n\nstatic int\tnfs3_ftypes[] = {\n\t0,\t\t\t \n\tS_IFREG,\t\t \n\tS_IFDIR,\t\t \n\tS_IFBLK,\t\t \n\tS_IFCHR,\t\t \n\tS_IFLNK,\t\t \n\tS_IFSOCK,\t\t \n\tS_IFIFO,\t\t \n};\n\n \nstatic __be32\nnfsd3_proc_null(struct svc_rqst *rqstp)\n{\n\treturn rpc_success;\n}\n\n \nstatic __be32\nnfsd3_proc_getattr(struct svc_rqst *rqstp)\n{\n\tstruct nfsd_fhandle *argp = rqstp->rq_argp;\n\tstruct nfsd3_attrstat *resp = rqstp->rq_resp;\n\n\tdprintk(\"nfsd: GETATTR(3)  %s\\n\",\n\t\tSVCFH_fmt(&argp->fh));\n\n\tfh_copy(&resp->fh, &argp->fh);\n\tresp->status = fh_verify(rqstp, &resp->fh, 0,\n\t\t\t\t NFSD_MAY_NOP | NFSD_MAY_BYPASS_GSS_ON_ROOT);\n\tif (resp->status != nfs_ok)\n\t\tgoto out;\n\n\tresp->status = fh_getattr(&resp->fh, &resp->stat);\nout:\n\treturn rpc_success;\n}\n\n \nstatic __be32\nnfsd3_proc_setattr(struct svc_rqst *rqstp)\n{\n\tstruct nfsd3_sattrargs *argp = rqstp->rq_argp;\n\tstruct nfsd3_attrstat *resp = rqstp->rq_resp;\n\tstruct nfsd_attrs attrs = {\n\t\t.na_iattr\t= &argp->attrs,\n\t};\n\n\tdprintk(\"nfsd: SETATTR(3)  %s\\n\",\n\t\t\t\tSVCFH_fmt(&argp->fh));\n\n\tfh_copy(&resp->fh, &argp->fh);\n\tresp->status = nfsd_setattr(rqstp, &resp->fh, &attrs,\n\t\t\t\t    argp->check_guard, argp->guardtime);\n\treturn rpc_success;\n}\n\n \nstatic __be32\nnfsd3_proc_lookup(struct svc_rqst *rqstp)\n{\n\tstruct nfsd3_diropargs *argp = rqstp->rq_argp;\n\tstruct nfsd3_diropres  *resp = rqstp->rq_resp;\n\n\tdprintk(\"nfsd: LOOKUP(3)   %s %.*s\\n\",\n\t\t\t\tSVCFH_fmt(&argp->fh),\n\t\t\t\targp->len,\n\t\t\t\targp->name);\n\n\tfh_copy(&resp->dirfh, &argp->fh);\n\tfh_init(&resp->fh, NFS3_FHSIZE);\n\n\tresp->status = nfsd_lookup(rqstp, &resp->dirfh,\n\t\t\t\t   argp->name, argp->len,\n\t\t\t\t   &resp->fh);\n\treturn rpc_success;\n}\n\n \nstatic __be32\nnfsd3_proc_access(struct svc_rqst *rqstp)\n{\n\tstruct nfsd3_accessargs *argp = rqstp->rq_argp;\n\tstruct nfsd3_accessres *resp = rqstp->rq_resp;\n\n\tdprintk(\"nfsd: ACCESS(3)   %s 0x%x\\n\",\n\t\t\t\tSVCFH_fmt(&argp->fh),\n\t\t\t\targp->access);\n\n\tfh_copy(&resp->fh, &argp->fh);\n\tresp->access = argp->access;\n\tresp->status = nfsd_access(rqstp, &resp->fh, &resp->access, NULL);\n\treturn rpc_success;\n}\n\n \nstatic __be32\nnfsd3_proc_readlink(struct svc_rqst *rqstp)\n{\n\tstruct nfsd_fhandle *argp = rqstp->rq_argp;\n\tstruct nfsd3_readlinkres *resp = rqstp->rq_resp;\n\n\tdprintk(\"nfsd: READLINK(3) %s\\n\", SVCFH_fmt(&argp->fh));\n\n\t \n\tfh_copy(&resp->fh, &argp->fh);\n\tresp->len = NFS3_MAXPATHLEN;\n\tresp->pages = rqstp->rq_next_page++;\n\tresp->status = nfsd_readlink(rqstp, &resp->fh,\n\t\t\t\t     page_address(*resp->pages), &resp->len);\n\treturn rpc_success;\n}\n\n \nstatic __be32\nnfsd3_proc_read(struct svc_rqst *rqstp)\n{\n\tstruct nfsd3_readargs *argp = rqstp->rq_argp;\n\tstruct nfsd3_readres *resp = rqstp->rq_resp;\n\n\tdprintk(\"nfsd: READ(3) %s %lu bytes at %Lu\\n\",\n\t\t\t\tSVCFH_fmt(&argp->fh),\n\t\t\t\t(unsigned long) argp->count,\n\t\t\t\t(unsigned long long) argp->offset);\n\n\targp->count = min_t(u32, argp->count, svc_max_payload(rqstp));\n\targp->count = min_t(u32, argp->count, rqstp->rq_res.buflen);\n\tif (argp->offset > (u64)OFFSET_MAX)\n\t\targp->offset = (u64)OFFSET_MAX;\n\tif (argp->offset + argp->count > (u64)OFFSET_MAX)\n\t\targp->count = (u64)OFFSET_MAX - argp->offset;\n\n\tresp->pages = rqstp->rq_next_page;\n\n\t \n\tresp->count = argp->count;\n\tsvc_reserve_auth(rqstp, ((1 + NFS3_POST_OP_ATTR_WORDS + 3)<<2) + resp->count +4);\n\n\tfh_copy(&resp->fh, &argp->fh);\n\tresp->status = nfsd_read(rqstp, &resp->fh, argp->offset,\n\t\t\t\t &resp->count, &resp->eof);\n\treturn rpc_success;\n}\n\n \nstatic __be32\nnfsd3_proc_write(struct svc_rqst *rqstp)\n{\n\tstruct nfsd3_writeargs *argp = rqstp->rq_argp;\n\tstruct nfsd3_writeres *resp = rqstp->rq_resp;\n\tunsigned long cnt = argp->len;\n\tunsigned int nvecs;\n\n\tdprintk(\"nfsd: WRITE(3)    %s %d bytes at %Lu%s\\n\",\n\t\t\t\tSVCFH_fmt(&argp->fh),\n\t\t\t\targp->len,\n\t\t\t\t(unsigned long long) argp->offset,\n\t\t\t\targp->stable? \" stable\" : \"\");\n\n\tresp->status = nfserr_fbig;\n\tif (argp->offset > (u64)OFFSET_MAX ||\n\t    argp->offset + argp->len > (u64)OFFSET_MAX)\n\t\treturn rpc_success;\n\n\tfh_copy(&resp->fh, &argp->fh);\n\tresp->committed = argp->stable;\n\tnvecs = svc_fill_write_vector(rqstp, &argp->payload);\n\n\tresp->status = nfsd_write(rqstp, &resp->fh, argp->offset,\n\t\t\t\t  rqstp->rq_vec, nvecs, &cnt,\n\t\t\t\t  resp->committed, resp->verf);\n\tresp->count = cnt;\n\treturn rpc_success;\n}\n\n \nstatic __be32\nnfsd3_create_file(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\t  struct svc_fh *resfhp, struct nfsd3_createargs *argp)\n{\n\tstruct iattr *iap = &argp->attrs;\n\tstruct dentry *parent, *child;\n\tstruct nfsd_attrs attrs = {\n\t\t.na_iattr\t= iap,\n\t};\n\t__u32 v_mtime, v_atime;\n\tstruct inode *inode;\n\t__be32 status;\n\tint host_err;\n\n\tif (isdotent(argp->name, argp->len))\n\t\treturn nfserr_exist;\n\tif (!(iap->ia_valid & ATTR_MODE))\n\t\tiap->ia_mode = 0;\n\n\tstatus = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_EXEC);\n\tif (status != nfs_ok)\n\t\treturn status;\n\n\tparent = fhp->fh_dentry;\n\tinode = d_inode(parent);\n\n\thost_err = fh_want_write(fhp);\n\tif (host_err)\n\t\treturn nfserrno(host_err);\n\n\tinode_lock_nested(inode, I_MUTEX_PARENT);\n\n\tchild = lookup_one_len(argp->name, parent, argp->len);\n\tif (IS_ERR(child)) {\n\t\tstatus = nfserrno(PTR_ERR(child));\n\t\tgoto out;\n\t}\n\n\tif (d_really_is_negative(child)) {\n\t\tstatus = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_CREATE);\n\t\tif (status != nfs_ok)\n\t\t\tgoto out;\n\t}\n\n\tstatus = fh_compose(resfhp, fhp->fh_export, child, fhp);\n\tif (status != nfs_ok)\n\t\tgoto out;\n\n\tv_mtime = 0;\n\tv_atime = 0;\n\tif (argp->createmode == NFS3_CREATE_EXCLUSIVE) {\n\t\tu32 *verifier = (u32 *)argp->verf;\n\n\t\t \n\t\tv_mtime = verifier[0] & 0x7fffffff;\n\t\tv_atime = verifier[1] & 0x7fffffff;\n\t}\n\n\tif (d_really_is_positive(child)) {\n\t\tstatus = nfs_ok;\n\n\t\tswitch (argp->createmode) {\n\t\tcase NFS3_CREATE_UNCHECKED:\n\t\t\tif (!d_is_reg(child))\n\t\t\t\tbreak;\n\t\t\tiap->ia_valid &= ATTR_SIZE;\n\t\t\tgoto set_attr;\n\t\tcase NFS3_CREATE_GUARDED:\n\t\t\tstatus = nfserr_exist;\n\t\t\tbreak;\n\t\tcase NFS3_CREATE_EXCLUSIVE:\n\t\t\tif (d_inode(child)->i_mtime.tv_sec == v_mtime &&\n\t\t\t    d_inode(child)->i_atime.tv_sec == v_atime &&\n\t\t\t    d_inode(child)->i_size == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstatus = nfserr_exist;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tif (!IS_POSIXACL(inode))\n\t\tiap->ia_mode &= ~current_umask();\n\n\tstatus = fh_fill_pre_attrs(fhp);\n\tif (status != nfs_ok)\n\t\tgoto out;\n\thost_err = vfs_create(&nop_mnt_idmap, inode, child, iap->ia_mode, true);\n\tif (host_err < 0) {\n\t\tstatus = nfserrno(host_err);\n\t\tgoto out;\n\t}\n\tfh_fill_post_attrs(fhp);\n\n\t \n\tif ((iap->ia_valid & ATTR_SIZE) && (iap->ia_size == 0))\n\t\tiap->ia_valid &= ~ATTR_SIZE;\n\tif (argp->createmode == NFS3_CREATE_EXCLUSIVE) {\n\t\tiap->ia_valid = ATTR_MTIME | ATTR_ATIME |\n\t\t\t\tATTR_MTIME_SET | ATTR_ATIME_SET;\n\t\tiap->ia_mtime.tv_sec = v_mtime;\n\t\tiap->ia_atime.tv_sec = v_atime;\n\t\tiap->ia_mtime.tv_nsec = 0;\n\t\tiap->ia_atime.tv_nsec = 0;\n\t}\n\nset_attr:\n\tstatus = nfsd_create_setattr(rqstp, fhp, resfhp, &attrs);\n\nout:\n\tinode_unlock(inode);\n\tif (child && !IS_ERR(child))\n\t\tdput(child);\n\tfh_drop_write(fhp);\n\treturn status;\n}\n\nstatic __be32\nnfsd3_proc_create(struct svc_rqst *rqstp)\n{\n\tstruct nfsd3_createargs *argp = rqstp->rq_argp;\n\tstruct nfsd3_diropres *resp = rqstp->rq_resp;\n\tsvc_fh *dirfhp, *newfhp;\n\n\tdprintk(\"nfsd: CREATE(3)   %s %.*s\\n\",\n\t\t\t\tSVCFH_fmt(&argp->fh),\n\t\t\t\targp->len,\n\t\t\t\targp->name);\n\n\tdirfhp = fh_copy(&resp->dirfh, &argp->fh);\n\tnewfhp = fh_init(&resp->fh, NFS3_FHSIZE);\n\n\tresp->status = nfsd3_create_file(rqstp, dirfhp, newfhp, argp);\n\treturn rpc_success;\n}\n\n \nstatic __be32\nnfsd3_proc_mkdir(struct svc_rqst *rqstp)\n{\n\tstruct nfsd3_createargs *argp = rqstp->rq_argp;\n\tstruct nfsd3_diropres *resp = rqstp->rq_resp;\n\tstruct nfsd_attrs attrs = {\n\t\t.na_iattr\t= &argp->attrs,\n\t};\n\n\tdprintk(\"nfsd: MKDIR(3)    %s %.*s\\n\",\n\t\t\t\tSVCFH_fmt(&argp->fh),\n\t\t\t\targp->len,\n\t\t\t\targp->name);\n\n\targp->attrs.ia_valid &= ~ATTR_SIZE;\n\tfh_copy(&resp->dirfh, &argp->fh);\n\tfh_init(&resp->fh, NFS3_FHSIZE);\n\tresp->status = nfsd_create(rqstp, &resp->dirfh, argp->name, argp->len,\n\t\t\t\t   &attrs, S_IFDIR, 0, &resp->fh);\n\treturn rpc_success;\n}\n\nstatic __be32\nnfsd3_proc_symlink(struct svc_rqst *rqstp)\n{\n\tstruct nfsd3_symlinkargs *argp = rqstp->rq_argp;\n\tstruct nfsd3_diropres *resp = rqstp->rq_resp;\n\tstruct nfsd_attrs attrs = {\n\t\t.na_iattr\t= &argp->attrs,\n\t};\n\n\tif (argp->tlen == 0) {\n\t\tresp->status = nfserr_inval;\n\t\tgoto out;\n\t}\n\tif (argp->tlen > NFS3_MAXPATHLEN) {\n\t\tresp->status = nfserr_nametoolong;\n\t\tgoto out;\n\t}\n\n\targp->tname = svc_fill_symlink_pathname(rqstp, &argp->first,\n\t\t\t\t\t\tpage_address(rqstp->rq_arg.pages[0]),\n\t\t\t\t\t\targp->tlen);\n\tif (IS_ERR(argp->tname)) {\n\t\tresp->status = nfserrno(PTR_ERR(argp->tname));\n\t\tgoto out;\n\t}\n\n\tdprintk(\"nfsd: SYMLINK(3)  %s %.*s -> %.*s\\n\",\n\t\t\t\tSVCFH_fmt(&argp->ffh),\n\t\t\t\targp->flen, argp->fname,\n\t\t\t\targp->tlen, argp->tname);\n\n\tfh_copy(&resp->dirfh, &argp->ffh);\n\tfh_init(&resp->fh, NFS3_FHSIZE);\n\tresp->status = nfsd_symlink(rqstp, &resp->dirfh, argp->fname,\n\t\t\t\t    argp->flen, argp->tname, &attrs, &resp->fh);\n\tkfree(argp->tname);\nout:\n\treturn rpc_success;\n}\n\n \nstatic __be32\nnfsd3_proc_mknod(struct svc_rqst *rqstp)\n{\n\tstruct nfsd3_mknodargs *argp = rqstp->rq_argp;\n\tstruct nfsd3_diropres  *resp = rqstp->rq_resp;\n\tstruct nfsd_attrs attrs = {\n\t\t.na_iattr\t= &argp->attrs,\n\t};\n\tint type;\n\tdev_t\trdev = 0;\n\n\tdprintk(\"nfsd: MKNOD(3)    %s %.*s\\n\",\n\t\t\t\tSVCFH_fmt(&argp->fh),\n\t\t\t\targp->len,\n\t\t\t\targp->name);\n\n\tfh_copy(&resp->dirfh, &argp->fh);\n\tfh_init(&resp->fh, NFS3_FHSIZE);\n\n\tif (argp->ftype == NF3CHR || argp->ftype == NF3BLK) {\n\t\trdev = MKDEV(argp->major, argp->minor);\n\t\tif (MAJOR(rdev) != argp->major ||\n\t\t    MINOR(rdev) != argp->minor) {\n\t\t\tresp->status = nfserr_inval;\n\t\t\tgoto out;\n\t\t}\n\t} else if (argp->ftype != NF3SOCK && argp->ftype != NF3FIFO) {\n\t\tresp->status = nfserr_badtype;\n\t\tgoto out;\n\t}\n\n\ttype = nfs3_ftypes[argp->ftype];\n\tresp->status = nfsd_create(rqstp, &resp->dirfh, argp->name, argp->len,\n\t\t\t\t   &attrs, type, rdev, &resp->fh);\nout:\n\treturn rpc_success;\n}\n\n \nstatic __be32\nnfsd3_proc_remove(struct svc_rqst *rqstp)\n{\n\tstruct nfsd3_diropargs *argp = rqstp->rq_argp;\n\tstruct nfsd3_attrstat *resp = rqstp->rq_resp;\n\n\tdprintk(\"nfsd: REMOVE(3)   %s %.*s\\n\",\n\t\t\t\tSVCFH_fmt(&argp->fh),\n\t\t\t\targp->len,\n\t\t\t\targp->name);\n\n\t \n\tfh_copy(&resp->fh, &argp->fh);\n\tresp->status = nfsd_unlink(rqstp, &resp->fh, -S_IFDIR,\n\t\t\t\t   argp->name, argp->len);\n\treturn rpc_success;\n}\n\n \nstatic __be32\nnfsd3_proc_rmdir(struct svc_rqst *rqstp)\n{\n\tstruct nfsd3_diropargs *argp = rqstp->rq_argp;\n\tstruct nfsd3_attrstat *resp = rqstp->rq_resp;\n\n\tdprintk(\"nfsd: RMDIR(3)    %s %.*s\\n\",\n\t\t\t\tSVCFH_fmt(&argp->fh),\n\t\t\t\targp->len,\n\t\t\t\targp->name);\n\n\tfh_copy(&resp->fh, &argp->fh);\n\tresp->status = nfsd_unlink(rqstp, &resp->fh, S_IFDIR,\n\t\t\t\t   argp->name, argp->len);\n\treturn rpc_success;\n}\n\nstatic __be32\nnfsd3_proc_rename(struct svc_rqst *rqstp)\n{\n\tstruct nfsd3_renameargs *argp = rqstp->rq_argp;\n\tstruct nfsd3_renameres *resp = rqstp->rq_resp;\n\n\tdprintk(\"nfsd: RENAME(3)   %s %.*s ->\\n\",\n\t\t\t\tSVCFH_fmt(&argp->ffh),\n\t\t\t\targp->flen,\n\t\t\t\targp->fname);\n\tdprintk(\"nfsd: -> %s %.*s\\n\",\n\t\t\t\tSVCFH_fmt(&argp->tfh),\n\t\t\t\targp->tlen,\n\t\t\t\targp->tname);\n\n\tfh_copy(&resp->ffh, &argp->ffh);\n\tfh_copy(&resp->tfh, &argp->tfh);\n\tresp->status = nfsd_rename(rqstp, &resp->ffh, argp->fname, argp->flen,\n\t\t\t\t   &resp->tfh, argp->tname, argp->tlen);\n\treturn rpc_success;\n}\n\nstatic __be32\nnfsd3_proc_link(struct svc_rqst *rqstp)\n{\n\tstruct nfsd3_linkargs *argp = rqstp->rq_argp;\n\tstruct nfsd3_linkres  *resp = rqstp->rq_resp;\n\n\tdprintk(\"nfsd: LINK(3)     %s ->\\n\",\n\t\t\t\tSVCFH_fmt(&argp->ffh));\n\tdprintk(\"nfsd:   -> %s %.*s\\n\",\n\t\t\t\tSVCFH_fmt(&argp->tfh),\n\t\t\t\targp->tlen,\n\t\t\t\targp->tname);\n\n\tfh_copy(&resp->fh,  &argp->ffh);\n\tfh_copy(&resp->tfh, &argp->tfh);\n\tresp->status = nfsd_link(rqstp, &resp->tfh, argp->tname, argp->tlen,\n\t\t\t\t &resp->fh);\n\treturn rpc_success;\n}\n\nstatic void nfsd3_init_dirlist_pages(struct svc_rqst *rqstp,\n\t\t\t\t     struct nfsd3_readdirres *resp,\n\t\t\t\t     u32 count)\n{\n\tstruct xdr_buf *buf = &resp->dirlist;\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tunsigned int sendbuf = min_t(unsigned int, rqstp->rq_res.buflen,\n\t\t\t\t     svc_max_payload(rqstp));\n\n\tmemset(buf, 0, sizeof(*buf));\n\n\t \n\tbuf->buflen = clamp(count, (u32)(XDR_UNIT * 2), sendbuf);\n\tbuf->buflen -= XDR_UNIT * 2;\n\tbuf->pages = rqstp->rq_next_page;\n\trqstp->rq_next_page += (buf->buflen + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\n\txdr_init_encode_pages(xdr, buf, buf->pages,  NULL);\n}\n\n \nstatic __be32\nnfsd3_proc_readdir(struct svc_rqst *rqstp)\n{\n\tstruct nfsd3_readdirargs *argp = rqstp->rq_argp;\n\tstruct nfsd3_readdirres  *resp = rqstp->rq_resp;\n\tloff_t\t\toffset;\n\n\tdprintk(\"nfsd: READDIR(3)  %s %d bytes at %d\\n\",\n\t\t\t\tSVCFH_fmt(&argp->fh),\n\t\t\t\targp->count, (u32) argp->cookie);\n\n\tnfsd3_init_dirlist_pages(rqstp, resp, argp->count);\n\n\tfh_copy(&resp->fh, &argp->fh);\n\tresp->common.err = nfs_ok;\n\tresp->cookie_offset = 0;\n\tresp->rqstp = rqstp;\n\toffset = argp->cookie;\n\tresp->status = nfsd_readdir(rqstp, &resp->fh, &offset,\n\t\t\t\t    &resp->common, nfs3svc_encode_entry3);\n\tmemcpy(resp->verf, argp->verf, 8);\n\tnfs3svc_encode_cookie3(resp, offset);\n\n\t \n\trqstp->rq_next_page = resp->xdr.page_ptr + 1;\n\n\treturn rpc_success;\n}\n\n \nstatic __be32\nnfsd3_proc_readdirplus(struct svc_rqst *rqstp)\n{\n\tstruct nfsd3_readdirargs *argp = rqstp->rq_argp;\n\tstruct nfsd3_readdirres  *resp = rqstp->rq_resp;\n\tloff_t\toffset;\n\n\tdprintk(\"nfsd: READDIR+(3) %s %d bytes at %d\\n\",\n\t\t\t\tSVCFH_fmt(&argp->fh),\n\t\t\t\targp->count, (u32) argp->cookie);\n\n\tnfsd3_init_dirlist_pages(rqstp, resp, argp->count);\n\n\tfh_copy(&resp->fh, &argp->fh);\n\tresp->common.err = nfs_ok;\n\tresp->cookie_offset = 0;\n\tresp->rqstp = rqstp;\n\toffset = argp->cookie;\n\n\tresp->status = fh_verify(rqstp, &resp->fh, S_IFDIR, NFSD_MAY_NOP);\n\tif (resp->status != nfs_ok)\n\t\tgoto out;\n\n\tif (resp->fh.fh_export->ex_flags & NFSEXP_NOREADDIRPLUS) {\n\t\tresp->status = nfserr_notsupp;\n\t\tgoto out;\n\t}\n\n\tresp->status = nfsd_readdir(rqstp, &resp->fh, &offset,\n\t\t\t\t    &resp->common, nfs3svc_encode_entryplus3);\n\tmemcpy(resp->verf, argp->verf, 8);\n\tnfs3svc_encode_cookie3(resp, offset);\n\n\t \n\trqstp->rq_next_page = resp->xdr.page_ptr + 1;\n\nout:\n\treturn rpc_success;\n}\n\n \nstatic __be32\nnfsd3_proc_fsstat(struct svc_rqst *rqstp)\n{\n\tstruct nfsd_fhandle *argp = rqstp->rq_argp;\n\tstruct nfsd3_fsstatres *resp = rqstp->rq_resp;\n\n\tdprintk(\"nfsd: FSSTAT(3)   %s\\n\",\n\t\t\t\tSVCFH_fmt(&argp->fh));\n\n\tresp->status = nfsd_statfs(rqstp, &argp->fh, &resp->stats, 0);\n\tfh_put(&argp->fh);\n\treturn rpc_success;\n}\n\n \nstatic __be32\nnfsd3_proc_fsinfo(struct svc_rqst *rqstp)\n{\n\tstruct nfsd_fhandle *argp = rqstp->rq_argp;\n\tstruct nfsd3_fsinfores *resp = rqstp->rq_resp;\n\tu32\tmax_blocksize = svc_max_payload(rqstp);\n\n\tdprintk(\"nfsd: FSINFO(3)   %s\\n\",\n\t\t\t\tSVCFH_fmt(&argp->fh));\n\n\tresp->f_rtmax  = max_blocksize;\n\tresp->f_rtpref = max_blocksize;\n\tresp->f_rtmult = PAGE_SIZE;\n\tresp->f_wtmax  = max_blocksize;\n\tresp->f_wtpref = max_blocksize;\n\tresp->f_wtmult = PAGE_SIZE;\n\tresp->f_dtpref = max_blocksize;\n\tresp->f_maxfilesize = ~(u32) 0;\n\tresp->f_properties = NFS3_FSF_DEFAULT;\n\n\tresp->status = fh_verify(rqstp, &argp->fh, 0,\n\t\t\t\t NFSD_MAY_NOP | NFSD_MAY_BYPASS_GSS_ON_ROOT);\n\n\t \n\tif (resp->status == nfs_ok) {\n\t\tstruct super_block *sb = argp->fh.fh_dentry->d_sb;\n\n\t\t \n\t\tif (sb->s_magic == MSDOS_SUPER_MAGIC) {\n\t\t\tresp->f_properties = NFS3_FSF_BILLYBOY;\n\t\t}\n\t\tresp->f_maxfilesize = sb->s_maxbytes;\n\t}\n\n\tfh_put(&argp->fh);\n\treturn rpc_success;\n}\n\n \nstatic __be32\nnfsd3_proc_pathconf(struct svc_rqst *rqstp)\n{\n\tstruct nfsd_fhandle *argp = rqstp->rq_argp;\n\tstruct nfsd3_pathconfres *resp = rqstp->rq_resp;\n\n\tdprintk(\"nfsd: PATHCONF(3) %s\\n\",\n\t\t\t\tSVCFH_fmt(&argp->fh));\n\n\t \n\tresp->p_link_max = 255;\t\t \n\tresp->p_name_max = 255;\t\t \n\tresp->p_no_trunc = 0;\n\tresp->p_chown_restricted = 1;\n\tresp->p_case_insensitive = 0;\n\tresp->p_case_preserving = 1;\n\n\tresp->status = fh_verify(rqstp, &argp->fh, 0, NFSD_MAY_NOP);\n\n\tif (resp->status == nfs_ok) {\n\t\tstruct super_block *sb = argp->fh.fh_dentry->d_sb;\n\n\t\t \n\t\tswitch (sb->s_magic) {\n\t\tcase EXT2_SUPER_MAGIC:\n\t\t\tresp->p_link_max = EXT2_LINK_MAX;\n\t\t\tresp->p_name_max = EXT2_NAME_LEN;\n\t\t\tbreak;\n\t\tcase MSDOS_SUPER_MAGIC:\n\t\t\tresp->p_case_insensitive = 1;\n\t\t\tresp->p_case_preserving  = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfh_put(&argp->fh);\n\treturn rpc_success;\n}\n\n \nstatic __be32\nnfsd3_proc_commit(struct svc_rqst *rqstp)\n{\n\tstruct nfsd3_commitargs *argp = rqstp->rq_argp;\n\tstruct nfsd3_commitres *resp = rqstp->rq_resp;\n\tstruct nfsd_file *nf;\n\n\tdprintk(\"nfsd: COMMIT(3)   %s %u@%Lu\\n\",\n\t\t\t\tSVCFH_fmt(&argp->fh),\n\t\t\t\targp->count,\n\t\t\t\t(unsigned long long) argp->offset);\n\n\tfh_copy(&resp->fh, &argp->fh);\n\tresp->status = nfsd_file_acquire_gc(rqstp, &resp->fh, NFSD_MAY_WRITE |\n\t\t\t\t\t    NFSD_MAY_NOT_BREAK_LEASE, &nf);\n\tif (resp->status)\n\t\tgoto out;\n\tresp->status = nfsd_commit(rqstp, &resp->fh, nf, argp->offset,\n\t\t\t\t   argp->count, resp->verf);\n\tnfsd_file_put(nf);\nout:\n\treturn rpc_success;\n}\n\n\n \n#define nfs3svc_encode_attrstatres\tnfs3svc_encode_attrstat\n#define nfs3svc_encode_wccstatres\tnfs3svc_encode_wccstat\n#define nfsd3_mkdirargs\t\t\tnfsd3_createargs\n#define nfsd3_readdirplusargs\t\tnfsd3_readdirargs\n#define nfsd3_fhandleargs\t\tnfsd_fhandle\n#define nfsd3_attrstatres\t\tnfsd3_attrstat\n#define nfsd3_wccstatres\t\tnfsd3_attrstat\n#define nfsd3_createres\t\t\tnfsd3_diropres\n\n#define ST 1\t\t \n#define FH 17\t\t \n#define AT 21\t\t \n#define pAT (1+AT)\t \n#define WC (7+pAT)\t \n\nstatic const struct svc_procedure nfsd_procedures3[22] = {\n\t[NFS3PROC_NULL] = {\n\t\t.pc_func = nfsd3_proc_null,\n\t\t.pc_decode = nfssvc_decode_voidarg,\n\t\t.pc_encode = nfssvc_encode_voidres,\n\t\t.pc_argsize = sizeof(struct nfsd_voidargs),\n\t\t.pc_argzero = sizeof(struct nfsd_voidargs),\n\t\t.pc_ressize = sizeof(struct nfsd_voidres),\n\t\t.pc_cachetype = RC_NOCACHE,\n\t\t.pc_xdrressize = ST,\n\t\t.pc_name = \"NULL\",\n\t},\n\t[NFS3PROC_GETATTR] = {\n\t\t.pc_func = nfsd3_proc_getattr,\n\t\t.pc_decode = nfs3svc_decode_fhandleargs,\n\t\t.pc_encode = nfs3svc_encode_getattrres,\n\t\t.pc_release = nfs3svc_release_fhandle,\n\t\t.pc_argsize = sizeof(struct nfsd_fhandle),\n\t\t.pc_argzero = sizeof(struct nfsd_fhandle),\n\t\t.pc_ressize = sizeof(struct nfsd3_attrstatres),\n\t\t.pc_cachetype = RC_NOCACHE,\n\t\t.pc_xdrressize = ST+AT,\n\t\t.pc_name = \"GETATTR\",\n\t},\n\t[NFS3PROC_SETATTR] = {\n\t\t.pc_func = nfsd3_proc_setattr,\n\t\t.pc_decode = nfs3svc_decode_sattrargs,\n\t\t.pc_encode = nfs3svc_encode_wccstatres,\n\t\t.pc_release = nfs3svc_release_fhandle,\n\t\t.pc_argsize = sizeof(struct nfsd3_sattrargs),\n\t\t.pc_argzero = sizeof(struct nfsd3_sattrargs),\n\t\t.pc_ressize = sizeof(struct nfsd3_wccstatres),\n\t\t.pc_cachetype = RC_REPLBUFF,\n\t\t.pc_xdrressize = ST+WC,\n\t\t.pc_name = \"SETATTR\",\n\t},\n\t[NFS3PROC_LOOKUP] = {\n\t\t.pc_func = nfsd3_proc_lookup,\n\t\t.pc_decode = nfs3svc_decode_diropargs,\n\t\t.pc_encode = nfs3svc_encode_lookupres,\n\t\t.pc_release = nfs3svc_release_fhandle2,\n\t\t.pc_argsize = sizeof(struct nfsd3_diropargs),\n\t\t.pc_argzero = sizeof(struct nfsd3_diropargs),\n\t\t.pc_ressize = sizeof(struct nfsd3_diropres),\n\t\t.pc_cachetype = RC_NOCACHE,\n\t\t.pc_xdrressize = ST+FH+pAT+pAT,\n\t\t.pc_name = \"LOOKUP\",\n\t},\n\t[NFS3PROC_ACCESS] = {\n\t\t.pc_func = nfsd3_proc_access,\n\t\t.pc_decode = nfs3svc_decode_accessargs,\n\t\t.pc_encode = nfs3svc_encode_accessres,\n\t\t.pc_release = nfs3svc_release_fhandle,\n\t\t.pc_argsize = sizeof(struct nfsd3_accessargs),\n\t\t.pc_argzero = sizeof(struct nfsd3_accessargs),\n\t\t.pc_ressize = sizeof(struct nfsd3_accessres),\n\t\t.pc_cachetype = RC_NOCACHE,\n\t\t.pc_xdrressize = ST+pAT+1,\n\t\t.pc_name = \"ACCESS\",\n\t},\n\t[NFS3PROC_READLINK] = {\n\t\t.pc_func = nfsd3_proc_readlink,\n\t\t.pc_decode = nfs3svc_decode_fhandleargs,\n\t\t.pc_encode = nfs3svc_encode_readlinkres,\n\t\t.pc_release = nfs3svc_release_fhandle,\n\t\t.pc_argsize = sizeof(struct nfsd_fhandle),\n\t\t.pc_argzero = sizeof(struct nfsd_fhandle),\n\t\t.pc_ressize = sizeof(struct nfsd3_readlinkres),\n\t\t.pc_cachetype = RC_NOCACHE,\n\t\t.pc_xdrressize = ST+pAT+1+NFS3_MAXPATHLEN/4,\n\t\t.pc_name = \"READLINK\",\n\t},\n\t[NFS3PROC_READ] = {\n\t\t.pc_func = nfsd3_proc_read,\n\t\t.pc_decode = nfs3svc_decode_readargs,\n\t\t.pc_encode = nfs3svc_encode_readres,\n\t\t.pc_release = nfs3svc_release_fhandle,\n\t\t.pc_argsize = sizeof(struct nfsd3_readargs),\n\t\t.pc_argzero = sizeof(struct nfsd3_readargs),\n\t\t.pc_ressize = sizeof(struct nfsd3_readres),\n\t\t.pc_cachetype = RC_NOCACHE,\n\t\t.pc_xdrressize = ST+pAT+4+NFSSVC_MAXBLKSIZE/4,\n\t\t.pc_name = \"READ\",\n\t},\n\t[NFS3PROC_WRITE] = {\n\t\t.pc_func = nfsd3_proc_write,\n\t\t.pc_decode = nfs3svc_decode_writeargs,\n\t\t.pc_encode = nfs3svc_encode_writeres,\n\t\t.pc_release = nfs3svc_release_fhandle,\n\t\t.pc_argsize = sizeof(struct nfsd3_writeargs),\n\t\t.pc_argzero = sizeof(struct nfsd3_writeargs),\n\t\t.pc_ressize = sizeof(struct nfsd3_writeres),\n\t\t.pc_cachetype = RC_REPLBUFF,\n\t\t.pc_xdrressize = ST+WC+4,\n\t\t.pc_name = \"WRITE\",\n\t},\n\t[NFS3PROC_CREATE] = {\n\t\t.pc_func = nfsd3_proc_create,\n\t\t.pc_decode = nfs3svc_decode_createargs,\n\t\t.pc_encode = nfs3svc_encode_createres,\n\t\t.pc_release = nfs3svc_release_fhandle2,\n\t\t.pc_argsize = sizeof(struct nfsd3_createargs),\n\t\t.pc_argzero = sizeof(struct nfsd3_createargs),\n\t\t.pc_ressize = sizeof(struct nfsd3_createres),\n\t\t.pc_cachetype = RC_REPLBUFF,\n\t\t.pc_xdrressize = ST+(1+FH+pAT)+WC,\n\t\t.pc_name = \"CREATE\",\n\t},\n\t[NFS3PROC_MKDIR] = {\n\t\t.pc_func = nfsd3_proc_mkdir,\n\t\t.pc_decode = nfs3svc_decode_mkdirargs,\n\t\t.pc_encode = nfs3svc_encode_createres,\n\t\t.pc_release = nfs3svc_release_fhandle2,\n\t\t.pc_argsize = sizeof(struct nfsd3_mkdirargs),\n\t\t.pc_argzero = sizeof(struct nfsd3_mkdirargs),\n\t\t.pc_ressize = sizeof(struct nfsd3_createres),\n\t\t.pc_cachetype = RC_REPLBUFF,\n\t\t.pc_xdrressize = ST+(1+FH+pAT)+WC,\n\t\t.pc_name = \"MKDIR\",\n\t},\n\t[NFS3PROC_SYMLINK] = {\n\t\t.pc_func = nfsd3_proc_symlink,\n\t\t.pc_decode = nfs3svc_decode_symlinkargs,\n\t\t.pc_encode = nfs3svc_encode_createres,\n\t\t.pc_release = nfs3svc_release_fhandle2,\n\t\t.pc_argsize = sizeof(struct nfsd3_symlinkargs),\n\t\t.pc_argzero = sizeof(struct nfsd3_symlinkargs),\n\t\t.pc_ressize = sizeof(struct nfsd3_createres),\n\t\t.pc_cachetype = RC_REPLBUFF,\n\t\t.pc_xdrressize = ST+(1+FH+pAT)+WC,\n\t\t.pc_name = \"SYMLINK\",\n\t},\n\t[NFS3PROC_MKNOD] = {\n\t\t.pc_func = nfsd3_proc_mknod,\n\t\t.pc_decode = nfs3svc_decode_mknodargs,\n\t\t.pc_encode = nfs3svc_encode_createres,\n\t\t.pc_release = nfs3svc_release_fhandle2,\n\t\t.pc_argsize = sizeof(struct nfsd3_mknodargs),\n\t\t.pc_argzero = sizeof(struct nfsd3_mknodargs),\n\t\t.pc_ressize = sizeof(struct nfsd3_createres),\n\t\t.pc_cachetype = RC_REPLBUFF,\n\t\t.pc_xdrressize = ST+(1+FH+pAT)+WC,\n\t\t.pc_name = \"MKNOD\",\n\t},\n\t[NFS3PROC_REMOVE] = {\n\t\t.pc_func = nfsd3_proc_remove,\n\t\t.pc_decode = nfs3svc_decode_diropargs,\n\t\t.pc_encode = nfs3svc_encode_wccstatres,\n\t\t.pc_release = nfs3svc_release_fhandle,\n\t\t.pc_argsize = sizeof(struct nfsd3_diropargs),\n\t\t.pc_argzero = sizeof(struct nfsd3_diropargs),\n\t\t.pc_ressize = sizeof(struct nfsd3_wccstatres),\n\t\t.pc_cachetype = RC_REPLBUFF,\n\t\t.pc_xdrressize = ST+WC,\n\t\t.pc_name = \"REMOVE\",\n\t},\n\t[NFS3PROC_RMDIR] = {\n\t\t.pc_func = nfsd3_proc_rmdir,\n\t\t.pc_decode = nfs3svc_decode_diropargs,\n\t\t.pc_encode = nfs3svc_encode_wccstatres,\n\t\t.pc_release = nfs3svc_release_fhandle,\n\t\t.pc_argsize = sizeof(struct nfsd3_diropargs),\n\t\t.pc_argzero = sizeof(struct nfsd3_diropargs),\n\t\t.pc_ressize = sizeof(struct nfsd3_wccstatres),\n\t\t.pc_cachetype = RC_REPLBUFF,\n\t\t.pc_xdrressize = ST+WC,\n\t\t.pc_name = \"RMDIR\",\n\t},\n\t[NFS3PROC_RENAME] = {\n\t\t.pc_func = nfsd3_proc_rename,\n\t\t.pc_decode = nfs3svc_decode_renameargs,\n\t\t.pc_encode = nfs3svc_encode_renameres,\n\t\t.pc_release = nfs3svc_release_fhandle2,\n\t\t.pc_argsize = sizeof(struct nfsd3_renameargs),\n\t\t.pc_argzero = sizeof(struct nfsd3_renameargs),\n\t\t.pc_ressize = sizeof(struct nfsd3_renameres),\n\t\t.pc_cachetype = RC_REPLBUFF,\n\t\t.pc_xdrressize = ST+WC+WC,\n\t\t.pc_name = \"RENAME\",\n\t},\n\t[NFS3PROC_LINK] = {\n\t\t.pc_func = nfsd3_proc_link,\n\t\t.pc_decode = nfs3svc_decode_linkargs,\n\t\t.pc_encode = nfs3svc_encode_linkres,\n\t\t.pc_release = nfs3svc_release_fhandle2,\n\t\t.pc_argsize = sizeof(struct nfsd3_linkargs),\n\t\t.pc_argzero = sizeof(struct nfsd3_linkargs),\n\t\t.pc_ressize = sizeof(struct nfsd3_linkres),\n\t\t.pc_cachetype = RC_REPLBUFF,\n\t\t.pc_xdrressize = ST+pAT+WC,\n\t\t.pc_name = \"LINK\",\n\t},\n\t[NFS3PROC_READDIR] = {\n\t\t.pc_func = nfsd3_proc_readdir,\n\t\t.pc_decode = nfs3svc_decode_readdirargs,\n\t\t.pc_encode = nfs3svc_encode_readdirres,\n\t\t.pc_release = nfs3svc_release_fhandle,\n\t\t.pc_argsize = sizeof(struct nfsd3_readdirargs),\n\t\t.pc_argzero = sizeof(struct nfsd3_readdirargs),\n\t\t.pc_ressize = sizeof(struct nfsd3_readdirres),\n\t\t.pc_cachetype = RC_NOCACHE,\n\t\t.pc_name = \"READDIR\",\n\t},\n\t[NFS3PROC_READDIRPLUS] = {\n\t\t.pc_func = nfsd3_proc_readdirplus,\n\t\t.pc_decode = nfs3svc_decode_readdirplusargs,\n\t\t.pc_encode = nfs3svc_encode_readdirres,\n\t\t.pc_release = nfs3svc_release_fhandle,\n\t\t.pc_argsize = sizeof(struct nfsd3_readdirplusargs),\n\t\t.pc_argzero = sizeof(struct nfsd3_readdirplusargs),\n\t\t.pc_ressize = sizeof(struct nfsd3_readdirres),\n\t\t.pc_cachetype = RC_NOCACHE,\n\t\t.pc_name = \"READDIRPLUS\",\n\t},\n\t[NFS3PROC_FSSTAT] = {\n\t\t.pc_func = nfsd3_proc_fsstat,\n\t\t.pc_decode = nfs3svc_decode_fhandleargs,\n\t\t.pc_encode = nfs3svc_encode_fsstatres,\n\t\t.pc_argsize = sizeof(struct nfsd3_fhandleargs),\n\t\t.pc_argzero = sizeof(struct nfsd3_fhandleargs),\n\t\t.pc_ressize = sizeof(struct nfsd3_fsstatres),\n\t\t.pc_cachetype = RC_NOCACHE,\n\t\t.pc_xdrressize = ST+pAT+2*6+1,\n\t\t.pc_name = \"FSSTAT\",\n\t},\n\t[NFS3PROC_FSINFO] = {\n\t\t.pc_func = nfsd3_proc_fsinfo,\n\t\t.pc_decode = nfs3svc_decode_fhandleargs,\n\t\t.pc_encode = nfs3svc_encode_fsinfores,\n\t\t.pc_argsize = sizeof(struct nfsd3_fhandleargs),\n\t\t.pc_argzero = sizeof(struct nfsd3_fhandleargs),\n\t\t.pc_ressize = sizeof(struct nfsd3_fsinfores),\n\t\t.pc_cachetype = RC_NOCACHE,\n\t\t.pc_xdrressize = ST+pAT+12,\n\t\t.pc_name = \"FSINFO\",\n\t},\n\t[NFS3PROC_PATHCONF] = {\n\t\t.pc_func = nfsd3_proc_pathconf,\n\t\t.pc_decode = nfs3svc_decode_fhandleargs,\n\t\t.pc_encode = nfs3svc_encode_pathconfres,\n\t\t.pc_argsize = sizeof(struct nfsd3_fhandleargs),\n\t\t.pc_argzero = sizeof(struct nfsd3_fhandleargs),\n\t\t.pc_ressize = sizeof(struct nfsd3_pathconfres),\n\t\t.pc_cachetype = RC_NOCACHE,\n\t\t.pc_xdrressize = ST+pAT+6,\n\t\t.pc_name = \"PATHCONF\",\n\t},\n\t[NFS3PROC_COMMIT] = {\n\t\t.pc_func = nfsd3_proc_commit,\n\t\t.pc_decode = nfs3svc_decode_commitargs,\n\t\t.pc_encode = nfs3svc_encode_commitres,\n\t\t.pc_release = nfs3svc_release_fhandle,\n\t\t.pc_argsize = sizeof(struct nfsd3_commitargs),\n\t\t.pc_argzero = sizeof(struct nfsd3_commitargs),\n\t\t.pc_ressize = sizeof(struct nfsd3_commitres),\n\t\t.pc_cachetype = RC_NOCACHE,\n\t\t.pc_xdrressize = ST+WC+2,\n\t\t.pc_name = \"COMMIT\",\n\t},\n};\n\nstatic DEFINE_PER_CPU_ALIGNED(unsigned long,\n\t\t\t      nfsd_count3[ARRAY_SIZE(nfsd_procedures3)]);\nconst struct svc_version nfsd_version3 = {\n\t.vs_vers\t= 3,\n\t.vs_nproc\t= ARRAY_SIZE(nfsd_procedures3),\n\t.vs_proc\t= nfsd_procedures3,\n\t.vs_dispatch\t= nfsd_dispatch,\n\t.vs_count\t= nfsd_count3,\n\t.vs_xdrsize\t= NFS3_SVC_XDRSIZE,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}