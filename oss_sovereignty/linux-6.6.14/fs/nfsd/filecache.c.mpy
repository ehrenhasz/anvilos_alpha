{
  "module_name": "filecache.c",
  "hash_id": "18de3b6c026a274ba9fb6dc3adc2e313d0d10bc551414386c8db97b38f4409bf",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfsd/filecache.c",
  "human_readable_source": "\n \n\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n#include <linux/list_lru.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fsnotify.h>\n#include <linux/seq_file.h>\n#include <linux/rhashtable.h>\n\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"nfsfh.h\"\n#include \"netns.h\"\n#include \"filecache.h\"\n#include \"trace.h\"\n\n#define NFSD_LAUNDRETTE_DELAY\t\t     (2 * HZ)\n\n#define NFSD_FILE_CACHE_UP\t\t     (0)\n\n \n#define NFSD_FILE_MAY_MASK\t(NFSD_MAY_READ|NFSD_MAY_WRITE)\n\nstatic DEFINE_PER_CPU(unsigned long, nfsd_file_cache_hits);\nstatic DEFINE_PER_CPU(unsigned long, nfsd_file_acquisitions);\nstatic DEFINE_PER_CPU(unsigned long, nfsd_file_releases);\nstatic DEFINE_PER_CPU(unsigned long, nfsd_file_total_age);\nstatic DEFINE_PER_CPU(unsigned long, nfsd_file_evictions);\n\nstruct nfsd_fcache_disposal {\n\tstruct work_struct work;\n\tspinlock_t lock;\n\tstruct list_head freeme;\n};\n\nstatic struct workqueue_struct *nfsd_filecache_wq __read_mostly;\n\nstatic struct kmem_cache\t\t*nfsd_file_slab;\nstatic struct kmem_cache\t\t*nfsd_file_mark_slab;\nstatic struct list_lru\t\t\tnfsd_file_lru;\nstatic unsigned long\t\t\tnfsd_file_flags;\nstatic struct fsnotify_group\t\t*nfsd_file_fsnotify_group;\nstatic struct delayed_work\t\tnfsd_filecache_laundrette;\nstatic struct rhltable\t\t\tnfsd_file_rhltable\n\t\t\t\t\t\t____cacheline_aligned_in_smp;\n\nstatic bool\nnfsd_match_cred(const struct cred *c1, const struct cred *c2)\n{\n\tint i;\n\n\tif (!uid_eq(c1->fsuid, c2->fsuid))\n\t\treturn false;\n\tif (!gid_eq(c1->fsgid, c2->fsgid))\n\t\treturn false;\n\tif (c1->group_info == NULL || c2->group_info == NULL)\n\t\treturn c1->group_info == c2->group_info;\n\tif (c1->group_info->ngroups != c2->group_info->ngroups)\n\t\treturn false;\n\tfor (i = 0; i < c1->group_info->ngroups; i++) {\n\t\tif (!gid_eq(c1->group_info->gid[i], c2->group_info->gid[i]))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic const struct rhashtable_params nfsd_file_rhash_params = {\n\t.key_len\t\t= sizeof_field(struct nfsd_file, nf_inode),\n\t.key_offset\t\t= offsetof(struct nfsd_file, nf_inode),\n\t.head_offset\t\t= offsetof(struct nfsd_file, nf_rlist),\n\n\t \n\t.min_size\t\t= 256,\n\t.automatic_shrinking\t= true,\n};\n\nstatic void\nnfsd_file_schedule_laundrette(void)\n{\n\tif (test_bit(NFSD_FILE_CACHE_UP, &nfsd_file_flags))\n\t\tqueue_delayed_work(system_wq, &nfsd_filecache_laundrette,\n\t\t\t\t   NFSD_LAUNDRETTE_DELAY);\n}\n\nstatic void\nnfsd_file_slab_free(struct rcu_head *rcu)\n{\n\tstruct nfsd_file *nf = container_of(rcu, struct nfsd_file, nf_rcu);\n\n\tput_cred(nf->nf_cred);\n\tkmem_cache_free(nfsd_file_slab, nf);\n}\n\nstatic void\nnfsd_file_mark_free(struct fsnotify_mark *mark)\n{\n\tstruct nfsd_file_mark *nfm = container_of(mark, struct nfsd_file_mark,\n\t\t\t\t\t\t  nfm_mark);\n\n\tkmem_cache_free(nfsd_file_mark_slab, nfm);\n}\n\nstatic struct nfsd_file_mark *\nnfsd_file_mark_get(struct nfsd_file_mark *nfm)\n{\n\tif (!refcount_inc_not_zero(&nfm->nfm_ref))\n\t\treturn NULL;\n\treturn nfm;\n}\n\nstatic void\nnfsd_file_mark_put(struct nfsd_file_mark *nfm)\n{\n\tif (refcount_dec_and_test(&nfm->nfm_ref)) {\n\t\tfsnotify_destroy_mark(&nfm->nfm_mark, nfsd_file_fsnotify_group);\n\t\tfsnotify_put_mark(&nfm->nfm_mark);\n\t}\n}\n\nstatic struct nfsd_file_mark *\nnfsd_file_mark_find_or_create(struct nfsd_file *nf, struct inode *inode)\n{\n\tint\t\t\terr;\n\tstruct fsnotify_mark\t*mark;\n\tstruct nfsd_file_mark\t*nfm = NULL, *new;\n\n\tdo {\n\t\tfsnotify_group_lock(nfsd_file_fsnotify_group);\n\t\tmark = fsnotify_find_mark(&inode->i_fsnotify_marks,\n\t\t\t\t\t  nfsd_file_fsnotify_group);\n\t\tif (mark) {\n\t\t\tnfm = nfsd_file_mark_get(container_of(mark,\n\t\t\t\t\t\t struct nfsd_file_mark,\n\t\t\t\t\t\t nfm_mark));\n\t\t\tfsnotify_group_unlock(nfsd_file_fsnotify_group);\n\t\t\tif (nfm) {\n\t\t\t\tfsnotify_put_mark(mark);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tfsnotify_destroy_mark(mark, nfsd_file_fsnotify_group);\n\t\t\tfsnotify_put_mark(mark);\n\t\t} else {\n\t\t\tfsnotify_group_unlock(nfsd_file_fsnotify_group);\n\t\t}\n\n\t\t \n\t\tnew = kmem_cache_alloc(nfsd_file_mark_slab, GFP_KERNEL);\n\t\tif (!new)\n\t\t\treturn NULL;\n\t\tfsnotify_init_mark(&new->nfm_mark, nfsd_file_fsnotify_group);\n\t\tnew->nfm_mark.mask = FS_ATTRIB|FS_DELETE_SELF;\n\t\trefcount_set(&new->nfm_ref, 1);\n\n\t\terr = fsnotify_add_inode_mark(&new->nfm_mark, inode, 0);\n\n\t\t \n\t\tif (likely(!err))\n\t\t\tnfm = new;\n\t\telse\n\t\t\tfsnotify_put_mark(&new->nfm_mark);\n\t} while (unlikely(err == -EEXIST));\n\n\treturn nfm;\n}\n\nstatic struct nfsd_file *\nnfsd_file_alloc(struct net *net, struct inode *inode, unsigned char need,\n\t\tbool want_gc)\n{\n\tstruct nfsd_file *nf;\n\n\tnf = kmem_cache_alloc(nfsd_file_slab, GFP_KERNEL);\n\tif (unlikely(!nf))\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&nf->nf_lru);\n\tnf->nf_birthtime = ktime_get();\n\tnf->nf_file = NULL;\n\tnf->nf_cred = get_current_cred();\n\tnf->nf_net = net;\n\tnf->nf_flags = want_gc ?\n\t\tBIT(NFSD_FILE_HASHED) | BIT(NFSD_FILE_PENDING) | BIT(NFSD_FILE_GC) :\n\t\tBIT(NFSD_FILE_HASHED) | BIT(NFSD_FILE_PENDING);\n\tnf->nf_inode = inode;\n\trefcount_set(&nf->nf_ref, 1);\n\tnf->nf_may = need;\n\tnf->nf_mark = NULL;\n\treturn nf;\n}\n\n \nstatic void\nnfsd_file_check_write_error(struct nfsd_file *nf)\n{\n\tstruct file *file = nf->nf_file;\n\n\tif ((file->f_mode & FMODE_WRITE) &&\n\t    filemap_check_wb_err(file->f_mapping, READ_ONCE(file->f_wb_err)))\n\t\tnfsd_reset_write_verifier(net_generic(nf->nf_net, nfsd_net_id));\n}\n\nstatic void\nnfsd_file_hash_remove(struct nfsd_file *nf)\n{\n\ttrace_nfsd_file_unhash(nf);\n\trhltable_remove(&nfsd_file_rhltable, &nf->nf_rlist,\n\t\t\tnfsd_file_rhash_params);\n}\n\nstatic bool\nnfsd_file_unhash(struct nfsd_file *nf)\n{\n\tif (test_and_clear_bit(NFSD_FILE_HASHED, &nf->nf_flags)) {\n\t\tnfsd_file_hash_remove(nf);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic void\nnfsd_file_free(struct nfsd_file *nf)\n{\n\ts64 age = ktime_to_ms(ktime_sub(ktime_get(), nf->nf_birthtime));\n\n\ttrace_nfsd_file_free(nf);\n\n\tthis_cpu_inc(nfsd_file_releases);\n\tthis_cpu_add(nfsd_file_total_age, age);\n\n\tnfsd_file_unhash(nf);\n\tif (nf->nf_mark)\n\t\tnfsd_file_mark_put(nf->nf_mark);\n\tif (nf->nf_file) {\n\t\tnfsd_file_check_write_error(nf);\n\t\tfilp_close(nf->nf_file, NULL);\n\t}\n\n\t \n\tif (WARN_ON_ONCE(!list_empty(&nf->nf_lru)))\n\t\treturn;\n\n\tcall_rcu(&nf->nf_rcu, nfsd_file_slab_free);\n}\n\nstatic bool\nnfsd_file_check_writeback(struct nfsd_file *nf)\n{\n\tstruct file *file = nf->nf_file;\n\tstruct address_space *mapping;\n\n\t \n\tif (!(file->f_mode & FMODE_WRITE))\n\t\treturn false;\n\n\t \n\tif (!(file_inode(file)->i_sb->s_export_op->flags & EXPORT_OP_FLUSH_ON_CLOSE))\n\t\treturn false;\n\n\tmapping = file->f_mapping;\n\treturn mapping_tagged(mapping, PAGECACHE_TAG_DIRTY) ||\n\t\tmapping_tagged(mapping, PAGECACHE_TAG_WRITEBACK);\n}\n\n\nstatic bool nfsd_file_lru_add(struct nfsd_file *nf)\n{\n\tset_bit(NFSD_FILE_REFERENCED, &nf->nf_flags);\n\tif (list_lru_add(&nfsd_file_lru, &nf->nf_lru)) {\n\t\ttrace_nfsd_file_lru_add(nf);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic bool nfsd_file_lru_remove(struct nfsd_file *nf)\n{\n\tif (list_lru_del(&nfsd_file_lru, &nf->nf_lru)) {\n\t\ttrace_nfsd_file_lru_del(nf);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstruct nfsd_file *\nnfsd_file_get(struct nfsd_file *nf)\n{\n\tif (nf && refcount_inc_not_zero(&nf->nf_ref))\n\t\treturn nf;\n\treturn NULL;\n}\n\n \nvoid\nnfsd_file_put(struct nfsd_file *nf)\n{\n\tmight_sleep();\n\ttrace_nfsd_file_put(nf);\n\n\tif (test_bit(NFSD_FILE_GC, &nf->nf_flags) &&\n\t    test_bit(NFSD_FILE_HASHED, &nf->nf_flags)) {\n\t\t \n\t\tif (refcount_dec_not_one(&nf->nf_ref))\n\t\t\treturn;\n\n\t\t \n\t\tif (nfsd_file_lru_add(nf)) {\n\t\t\t \n\t\t\tif (test_bit(NFSD_FILE_HASHED, &nf->nf_flags)) {\n\t\t\t\tnfsd_file_schedule_laundrette();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!nfsd_file_lru_remove(nf))\n\t\t\t\treturn;\n\t\t}\n\t}\n\tif (refcount_dec_and_test(&nf->nf_ref))\n\t\tnfsd_file_free(nf);\n}\n\nstatic void\nnfsd_file_dispose_list(struct list_head *dispose)\n{\n\tstruct nfsd_file *nf;\n\n\twhile (!list_empty(dispose)) {\n\t\tnf = list_first_entry(dispose, struct nfsd_file, nf_lru);\n\t\tlist_del_init(&nf->nf_lru);\n\t\tnfsd_file_free(nf);\n\t}\n}\n\n \nstatic void\nnfsd_file_dispose_list_delayed(struct list_head *dispose)\n{\n\twhile(!list_empty(dispose)) {\n\t\tstruct nfsd_file *nf = list_first_entry(dispose,\n\t\t\t\t\t\tstruct nfsd_file, nf_lru);\n\t\tstruct nfsd_net *nn = net_generic(nf->nf_net, nfsd_net_id);\n\t\tstruct nfsd_fcache_disposal *l = nn->fcache_disposal;\n\n\t\tspin_lock(&l->lock);\n\t\tlist_move_tail(&nf->nf_lru, &l->freeme);\n\t\tspin_unlock(&l->lock);\n\t\tqueue_work(nfsd_filecache_wq, &l->work);\n\t}\n}\n\n \nstatic enum lru_status\nnfsd_file_lru_cb(struct list_head *item, struct list_lru_one *lru,\n\t\t spinlock_t *lock, void *arg)\n\t__releases(lock)\n\t__acquires(lock)\n{\n\tstruct list_head *head = arg;\n\tstruct nfsd_file *nf = list_entry(item, struct nfsd_file, nf_lru);\n\n\t \n\tWARN_ON_ONCE(!test_bit(NFSD_FILE_GC, &nf->nf_flags));\n\n\t \n\tif (nfsd_file_check_writeback(nf)) {\n\t\ttrace_nfsd_file_gc_writeback(nf);\n\t\treturn LRU_SKIP;\n\t}\n\n\t \n\tif (test_and_clear_bit(NFSD_FILE_REFERENCED, &nf->nf_flags)) {\n\t\ttrace_nfsd_file_gc_referenced(nf);\n\t\treturn LRU_ROTATE;\n\t}\n\n\t \n\tif (!refcount_dec_and_test(&nf->nf_ref)) {\n\t\ttrace_nfsd_file_gc_in_use(nf);\n\t\tlist_lru_isolate(lru, &nf->nf_lru);\n\t\treturn LRU_REMOVED;\n\t}\n\n\t \n\tnfsd_file_unhash(nf);\n\tlist_lru_isolate_move(lru, &nf->nf_lru, head);\n\tthis_cpu_inc(nfsd_file_evictions);\n\ttrace_nfsd_file_gc_disposed(nf);\n\treturn LRU_REMOVED;\n}\n\nstatic void\nnfsd_file_gc(void)\n{\n\tLIST_HEAD(dispose);\n\tunsigned long ret;\n\n\tret = list_lru_walk(&nfsd_file_lru, nfsd_file_lru_cb,\n\t\t\t    &dispose, list_lru_count(&nfsd_file_lru));\n\ttrace_nfsd_file_gc_removed(ret, list_lru_count(&nfsd_file_lru));\n\tnfsd_file_dispose_list_delayed(&dispose);\n}\n\nstatic void\nnfsd_file_gc_worker(struct work_struct *work)\n{\n\tnfsd_file_gc();\n\tif (list_lru_count(&nfsd_file_lru))\n\t\tnfsd_file_schedule_laundrette();\n}\n\nstatic unsigned long\nnfsd_file_lru_count(struct shrinker *s, struct shrink_control *sc)\n{\n\treturn list_lru_count(&nfsd_file_lru);\n}\n\nstatic unsigned long\nnfsd_file_lru_scan(struct shrinker *s, struct shrink_control *sc)\n{\n\tLIST_HEAD(dispose);\n\tunsigned long ret;\n\n\tret = list_lru_shrink_walk(&nfsd_file_lru, sc,\n\t\t\t\t   nfsd_file_lru_cb, &dispose);\n\ttrace_nfsd_file_shrinker_removed(ret, list_lru_count(&nfsd_file_lru));\n\tnfsd_file_dispose_list_delayed(&dispose);\n\treturn ret;\n}\n\nstatic struct shrinker\tnfsd_file_shrinker = {\n\t.scan_objects = nfsd_file_lru_scan,\n\t.count_objects = nfsd_file_lru_count,\n\t.seeks = 1,\n};\n\n \nstatic void\nnfsd_file_cond_queue(struct nfsd_file *nf, struct list_head *dispose)\n\t__must_hold(RCU)\n{\n\tint decrement = 1;\n\n\t \n\tif (!nfsd_file_unhash(nf))\n\t\treturn;\n\n\t \n\tif (!nfsd_file_get(nf))\n\t\treturn;\n\n\t \n\tif (nfsd_file_lru_remove(nf))\n\t\t++decrement;\n\n\t \n\tif (refcount_sub_and_test(decrement, &nf->nf_ref)) {\n\t\tlist_add(&nf->nf_lru, dispose);\n\t\ttrace_nfsd_file_closing(nf);\n\t}\n}\n\n \nstatic void\nnfsd_file_queue_for_close(struct inode *inode, struct list_head *dispose)\n{\n\tstruct rhlist_head *tmp, *list;\n\tstruct nfsd_file *nf;\n\n\trcu_read_lock();\n\tlist = rhltable_lookup(&nfsd_file_rhltable, &inode,\n\t\t\t       nfsd_file_rhash_params);\n\trhl_for_each_entry_rcu(nf, tmp, list, nf_rlist) {\n\t\tif (!test_bit(NFSD_FILE_GC, &nf->nf_flags))\n\t\t\tcontinue;\n\t\tnfsd_file_cond_queue(nf, dispose);\n\t}\n\trcu_read_unlock();\n}\n\n \nstatic void\nnfsd_file_close_inode(struct inode *inode)\n{\n\tLIST_HEAD(dispose);\n\n\tnfsd_file_queue_for_close(inode, &dispose);\n\tnfsd_file_dispose_list_delayed(&dispose);\n}\n\n \nvoid\nnfsd_file_close_inode_sync(struct inode *inode)\n{\n\tstruct nfsd_file *nf;\n\tLIST_HEAD(dispose);\n\n\ttrace_nfsd_file_close(inode);\n\n\tnfsd_file_queue_for_close(inode, &dispose);\n\twhile (!list_empty(&dispose)) {\n\t\tnf = list_first_entry(&dispose, struct nfsd_file, nf_lru);\n\t\tlist_del_init(&nf->nf_lru);\n\t\tnfsd_file_free(nf);\n\t}\n\tflush_delayed_fput();\n}\n\n \nstatic void\nnfsd_file_delayed_close(struct work_struct *work)\n{\n\tLIST_HEAD(head);\n\tstruct nfsd_fcache_disposal *l = container_of(work,\n\t\t\tstruct nfsd_fcache_disposal, work);\n\n\tspin_lock(&l->lock);\n\tlist_splice_init(&l->freeme, &head);\n\tspin_unlock(&l->lock);\n\n\tnfsd_file_dispose_list(&head);\n}\n\nstatic int\nnfsd_file_lease_notifier_call(struct notifier_block *nb, unsigned long arg,\n\t\t\t    void *data)\n{\n\tstruct file_lock *fl = data;\n\n\t \n\tif (fl->fl_flags & FL_LEASE)\n\t\tnfsd_file_close_inode(file_inode(fl->fl_file));\n\treturn 0;\n}\n\nstatic struct notifier_block nfsd_file_lease_notifier = {\n\t.notifier_call = nfsd_file_lease_notifier_call,\n};\n\nstatic int\nnfsd_file_fsnotify_handle_event(struct fsnotify_mark *mark, u32 mask,\n\t\t\t\tstruct inode *inode, struct inode *dir,\n\t\t\t\tconst struct qstr *name, u32 cookie)\n{\n\tif (WARN_ON_ONCE(!inode))\n\t\treturn 0;\n\n\ttrace_nfsd_file_fsnotify_handle_event(inode, mask);\n\n\t \n\tif (!S_ISREG(inode->i_mode)) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn 0;\n\t}\n\n\t \n\tif (mask & FS_ATTRIB) {\n\t\tif (inode->i_nlink)\n\t\t\treturn 0;\n\t}\n\n\tnfsd_file_close_inode(inode);\n\treturn 0;\n}\n\n\nstatic const struct fsnotify_ops nfsd_file_fsnotify_ops = {\n\t.handle_inode_event = nfsd_file_fsnotify_handle_event,\n\t.free_mark = nfsd_file_mark_free,\n};\n\nint\nnfsd_file_cache_init(void)\n{\n\tint ret;\n\n\tlockdep_assert_held(&nfsd_mutex);\n\tif (test_and_set_bit(NFSD_FILE_CACHE_UP, &nfsd_file_flags) == 1)\n\t\treturn 0;\n\n\tret = rhltable_init(&nfsd_file_rhltable, &nfsd_file_rhash_params);\n\tif (ret)\n\t\treturn ret;\n\n\tret = -ENOMEM;\n\tnfsd_filecache_wq = alloc_workqueue(\"nfsd_filecache\", 0, 0);\n\tif (!nfsd_filecache_wq)\n\t\tgoto out;\n\n\tnfsd_file_slab = kmem_cache_create(\"nfsd_file\",\n\t\t\t\tsizeof(struct nfsd_file), 0, 0, NULL);\n\tif (!nfsd_file_slab) {\n\t\tpr_err(\"nfsd: unable to create nfsd_file_slab\\n\");\n\t\tgoto out_err;\n\t}\n\n\tnfsd_file_mark_slab = kmem_cache_create(\"nfsd_file_mark\",\n\t\t\t\t\tsizeof(struct nfsd_file_mark), 0, 0, NULL);\n\tif (!nfsd_file_mark_slab) {\n\t\tpr_err(\"nfsd: unable to create nfsd_file_mark_slab\\n\");\n\t\tgoto out_err;\n\t}\n\n\n\tret = list_lru_init(&nfsd_file_lru);\n\tif (ret) {\n\t\tpr_err(\"nfsd: failed to init nfsd_file_lru: %d\\n\", ret);\n\t\tgoto out_err;\n\t}\n\n\tret = register_shrinker(&nfsd_file_shrinker, \"nfsd-filecache\");\n\tif (ret) {\n\t\tpr_err(\"nfsd: failed to register nfsd_file_shrinker: %d\\n\", ret);\n\t\tgoto out_lru;\n\t}\n\n\tret = lease_register_notifier(&nfsd_file_lease_notifier);\n\tif (ret) {\n\t\tpr_err(\"nfsd: unable to register lease notifier: %d\\n\", ret);\n\t\tgoto out_shrinker;\n\t}\n\n\tnfsd_file_fsnotify_group = fsnotify_alloc_group(&nfsd_file_fsnotify_ops,\n\t\t\t\t\t\t\tFSNOTIFY_GROUP_NOFS);\n\tif (IS_ERR(nfsd_file_fsnotify_group)) {\n\t\tpr_err(\"nfsd: unable to create fsnotify group: %ld\\n\",\n\t\t\tPTR_ERR(nfsd_file_fsnotify_group));\n\t\tret = PTR_ERR(nfsd_file_fsnotify_group);\n\t\tnfsd_file_fsnotify_group = NULL;\n\t\tgoto out_notifier;\n\t}\n\n\tINIT_DELAYED_WORK(&nfsd_filecache_laundrette, nfsd_file_gc_worker);\nout:\n\treturn ret;\nout_notifier:\n\tlease_unregister_notifier(&nfsd_file_lease_notifier);\nout_shrinker:\n\tunregister_shrinker(&nfsd_file_shrinker);\nout_lru:\n\tlist_lru_destroy(&nfsd_file_lru);\nout_err:\n\tkmem_cache_destroy(nfsd_file_slab);\n\tnfsd_file_slab = NULL;\n\tkmem_cache_destroy(nfsd_file_mark_slab);\n\tnfsd_file_mark_slab = NULL;\n\tdestroy_workqueue(nfsd_filecache_wq);\n\tnfsd_filecache_wq = NULL;\n\trhltable_destroy(&nfsd_file_rhltable);\n\tgoto out;\n}\n\n \nstatic void\n__nfsd_file_cache_purge(struct net *net)\n{\n\tstruct rhashtable_iter iter;\n\tstruct nfsd_file *nf;\n\tLIST_HEAD(dispose);\n\n\trhltable_walk_enter(&nfsd_file_rhltable, &iter);\n\tdo {\n\t\trhashtable_walk_start(&iter);\n\n\t\tnf = rhashtable_walk_next(&iter);\n\t\twhile (!IS_ERR_OR_NULL(nf)) {\n\t\t\tif (!net || nf->nf_net == net)\n\t\t\t\tnfsd_file_cond_queue(nf, &dispose);\n\t\t\tnf = rhashtable_walk_next(&iter);\n\t\t}\n\n\t\trhashtable_walk_stop(&iter);\n\t} while (nf == ERR_PTR(-EAGAIN));\n\trhashtable_walk_exit(&iter);\n\n\tnfsd_file_dispose_list(&dispose);\n}\n\nstatic struct nfsd_fcache_disposal *\nnfsd_alloc_fcache_disposal(void)\n{\n\tstruct nfsd_fcache_disposal *l;\n\n\tl = kmalloc(sizeof(*l), GFP_KERNEL);\n\tif (!l)\n\t\treturn NULL;\n\tINIT_WORK(&l->work, nfsd_file_delayed_close);\n\tspin_lock_init(&l->lock);\n\tINIT_LIST_HEAD(&l->freeme);\n\treturn l;\n}\n\nstatic void\nnfsd_free_fcache_disposal(struct nfsd_fcache_disposal *l)\n{\n\tcancel_work_sync(&l->work);\n\tnfsd_file_dispose_list(&l->freeme);\n\tkfree(l);\n}\n\nstatic void\nnfsd_free_fcache_disposal_net(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tstruct nfsd_fcache_disposal *l = nn->fcache_disposal;\n\n\tnfsd_free_fcache_disposal(l);\n}\n\nint\nnfsd_file_cache_start_net(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tnn->fcache_disposal = nfsd_alloc_fcache_disposal();\n\treturn nn->fcache_disposal ? 0 : -ENOMEM;\n}\n\n \nvoid\nnfsd_file_cache_purge(struct net *net)\n{\n\tlockdep_assert_held(&nfsd_mutex);\n\tif (test_bit(NFSD_FILE_CACHE_UP, &nfsd_file_flags) == 1)\n\t\t__nfsd_file_cache_purge(net);\n}\n\nvoid\nnfsd_file_cache_shutdown_net(struct net *net)\n{\n\tnfsd_file_cache_purge(net);\n\tnfsd_free_fcache_disposal_net(net);\n}\n\nvoid\nnfsd_file_cache_shutdown(void)\n{\n\tint i;\n\n\tlockdep_assert_held(&nfsd_mutex);\n\tif (test_and_clear_bit(NFSD_FILE_CACHE_UP, &nfsd_file_flags) == 0)\n\t\treturn;\n\n\tlease_unregister_notifier(&nfsd_file_lease_notifier);\n\tunregister_shrinker(&nfsd_file_shrinker);\n\t \n\tcancel_delayed_work_sync(&nfsd_filecache_laundrette);\n\t__nfsd_file_cache_purge(NULL);\n\tlist_lru_destroy(&nfsd_file_lru);\n\trcu_barrier();\n\tfsnotify_put_group(nfsd_file_fsnotify_group);\n\tnfsd_file_fsnotify_group = NULL;\n\tkmem_cache_destroy(nfsd_file_slab);\n\tnfsd_file_slab = NULL;\n\tfsnotify_wait_marks_destroyed();\n\tkmem_cache_destroy(nfsd_file_mark_slab);\n\tnfsd_file_mark_slab = NULL;\n\tdestroy_workqueue(nfsd_filecache_wq);\n\tnfsd_filecache_wq = NULL;\n\trhltable_destroy(&nfsd_file_rhltable);\n\n\tfor_each_possible_cpu(i) {\n\t\tper_cpu(nfsd_file_cache_hits, i) = 0;\n\t\tper_cpu(nfsd_file_acquisitions, i) = 0;\n\t\tper_cpu(nfsd_file_releases, i) = 0;\n\t\tper_cpu(nfsd_file_total_age, i) = 0;\n\t\tper_cpu(nfsd_file_evictions, i) = 0;\n\t}\n}\n\nstatic struct nfsd_file *\nnfsd_file_lookup_locked(const struct net *net, const struct cred *cred,\n\t\t\tstruct inode *inode, unsigned char need,\n\t\t\tbool want_gc)\n{\n\tstruct rhlist_head *tmp, *list;\n\tstruct nfsd_file *nf;\n\n\tlist = rhltable_lookup(&nfsd_file_rhltable, &inode,\n\t\t\t       nfsd_file_rhash_params);\n\trhl_for_each_entry_rcu(nf, tmp, list, nf_rlist) {\n\t\tif (nf->nf_may != need)\n\t\t\tcontinue;\n\t\tif (nf->nf_net != net)\n\t\t\tcontinue;\n\t\tif (!nfsd_match_cred(nf->nf_cred, cred))\n\t\t\tcontinue;\n\t\tif (test_bit(NFSD_FILE_GC, &nf->nf_flags) != want_gc)\n\t\t\tcontinue;\n\t\tif (test_bit(NFSD_FILE_HASHED, &nf->nf_flags) == 0)\n\t\t\tcontinue;\n\n\t\tif (!nfsd_file_get(nf))\n\t\t\tcontinue;\n\t\treturn nf;\n\t}\n\treturn NULL;\n}\n\n \nbool\nnfsd_file_is_cached(struct inode *inode)\n{\n\tstruct rhlist_head *tmp, *list;\n\tstruct nfsd_file *nf;\n\tbool ret = false;\n\n\trcu_read_lock();\n\tlist = rhltable_lookup(&nfsd_file_rhltable, &inode,\n\t\t\t       nfsd_file_rhash_params);\n\trhl_for_each_entry_rcu(nf, tmp, list, nf_rlist)\n\t\tif (test_bit(NFSD_FILE_GC, &nf->nf_flags)) {\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\trcu_read_unlock();\n\n\ttrace_nfsd_file_is_cached(inode, (int)ret);\n\treturn ret;\n}\n\nstatic __be32\nnfsd_file_do_acquire(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\t     unsigned int may_flags, struct file *file,\n\t\t     struct nfsd_file **pnf, bool want_gc)\n{\n\tunsigned char need = may_flags & NFSD_FILE_MAY_MASK;\n\tstruct net *net = SVC_NET(rqstp);\n\tstruct nfsd_file *new, *nf;\n\tbool stale_retry = true;\n\tbool open_retry = true;\n\tstruct inode *inode;\n\t__be32 status;\n\tint ret;\n\nretry:\n\tstatus = fh_verify(rqstp, fhp, S_IFREG,\n\t\t\t\tmay_flags|NFSD_MAY_OWNER_OVERRIDE);\n\tif (status != nfs_ok)\n\t\treturn status;\n\tinode = d_inode(fhp->fh_dentry);\n\n\trcu_read_lock();\n\tnf = nfsd_file_lookup_locked(net, current_cred(), inode, need, want_gc);\n\trcu_read_unlock();\n\n\tif (nf) {\n\t\t \n\t\tif (nfsd_file_lru_remove(nf))\n\t\t\tWARN_ON_ONCE(refcount_dec_and_test(&nf->nf_ref));\n\t\tgoto wait_for_construction;\n\t}\n\n\tnew = nfsd_file_alloc(net, inode, need, want_gc);\n\tif (!new) {\n\t\tstatus = nfserr_jukebox;\n\t\tgoto out;\n\t}\n\n\trcu_read_lock();\n\tspin_lock(&inode->i_lock);\n\tnf = nfsd_file_lookup_locked(net, current_cred(), inode, need, want_gc);\n\tif (unlikely(nf)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\trcu_read_unlock();\n\t\tnfsd_file_slab_free(&new->nf_rcu);\n\t\tgoto wait_for_construction;\n\t}\n\tnf = new;\n\tret = rhltable_insert(&nfsd_file_rhltable, &nf->nf_rlist,\n\t\t\t      nfsd_file_rhash_params);\n\tspin_unlock(&inode->i_lock);\n\trcu_read_unlock();\n\tif (likely(ret == 0))\n\t\tgoto open_file;\n\n\tif (ret == -EEXIST)\n\t\tgoto retry;\n\ttrace_nfsd_file_insert_err(rqstp, inode, may_flags, ret);\n\tstatus = nfserr_jukebox;\n\tgoto construction_err;\n\nwait_for_construction:\n\twait_on_bit(&nf->nf_flags, NFSD_FILE_PENDING, TASK_UNINTERRUPTIBLE);\n\n\t \n\tif (!test_bit(NFSD_FILE_HASHED, &nf->nf_flags)) {\n\t\ttrace_nfsd_file_cons_err(rqstp, inode, may_flags, nf);\n\t\tif (!open_retry) {\n\t\t\tstatus = nfserr_jukebox;\n\t\t\tgoto construction_err;\n\t\t}\n\t\topen_retry = false;\n\t\tfh_put(fhp);\n\t\tgoto retry;\n\t}\n\tthis_cpu_inc(nfsd_file_cache_hits);\n\n\tstatus = nfserrno(nfsd_open_break_lease(file_inode(nf->nf_file), may_flags));\n\tif (status != nfs_ok) {\n\t\tnfsd_file_put(nf);\n\t\tnf = NULL;\n\t}\n\nout:\n\tif (status == nfs_ok) {\n\t\tthis_cpu_inc(nfsd_file_acquisitions);\n\t\tnfsd_file_check_write_error(nf);\n\t\t*pnf = nf;\n\t}\n\ttrace_nfsd_file_acquire(rqstp, inode, may_flags, nf, status);\n\treturn status;\n\nopen_file:\n\ttrace_nfsd_file_alloc(nf);\n\tnf->nf_mark = nfsd_file_mark_find_or_create(nf, inode);\n\tif (nf->nf_mark) {\n\t\tif (file) {\n\t\t\tget_file(file);\n\t\t\tnf->nf_file = file;\n\t\t\tstatus = nfs_ok;\n\t\t\ttrace_nfsd_file_opened(nf, status);\n\t\t} else {\n\t\t\tret = nfsd_open_verified(rqstp, fhp, may_flags,\n\t\t\t\t\t\t &nf->nf_file);\n\t\t\tif (ret == -EOPENSTALE && stale_retry) {\n\t\t\t\tstale_retry = false;\n\t\t\t\tnfsd_file_unhash(nf);\n\t\t\t\tclear_and_wake_up_bit(NFSD_FILE_PENDING,\n\t\t\t\t\t\t      &nf->nf_flags);\n\t\t\t\tif (refcount_dec_and_test(&nf->nf_ref))\n\t\t\t\t\tnfsd_file_free(nf);\n\t\t\t\tnf = NULL;\n\t\t\t\tfh_put(fhp);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\tstatus = nfserrno(ret);\n\t\t\ttrace_nfsd_file_open(nf, status);\n\t\t}\n\t} else\n\t\tstatus = nfserr_jukebox;\n\t \n\tif (status != nfs_ok || inode->i_nlink == 0)\n\t\tnfsd_file_unhash(nf);\n\tclear_and_wake_up_bit(NFSD_FILE_PENDING, &nf->nf_flags);\n\tif (status == nfs_ok)\n\t\tgoto out;\n\nconstruction_err:\n\tif (refcount_dec_and_test(&nf->nf_ref))\n\t\tnfsd_file_free(nf);\n\tnf = NULL;\n\tgoto out;\n}\n\n \n__be32\nnfsd_file_acquire_gc(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\t     unsigned int may_flags, struct nfsd_file **pnf)\n{\n\treturn nfsd_file_do_acquire(rqstp, fhp, may_flags, NULL, pnf, true);\n}\n\n \n__be32\nnfsd_file_acquire(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\t  unsigned int may_flags, struct nfsd_file **pnf)\n{\n\treturn nfsd_file_do_acquire(rqstp, fhp, may_flags, NULL, pnf, false);\n}\n\n \n__be32\nnfsd_file_acquire_opened(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\t\t unsigned int may_flags, struct file *file,\n\t\t\t struct nfsd_file **pnf)\n{\n\treturn nfsd_file_do_acquire(rqstp, fhp, may_flags, file, pnf, false);\n}\n\n \nint nfsd_file_cache_stats_show(struct seq_file *m, void *v)\n{\n\tunsigned long releases = 0, evictions = 0;\n\tunsigned long hits = 0, acquisitions = 0;\n\tunsigned int i, count = 0, buckets = 0;\n\tunsigned long lru = 0, total_age = 0;\n\n\t \n\tmutex_lock(&nfsd_mutex);\n\tif (test_bit(NFSD_FILE_CACHE_UP, &nfsd_file_flags) == 1) {\n\t\tstruct bucket_table *tbl;\n\t\tstruct rhashtable *ht;\n\n\t\tlru = list_lru_count(&nfsd_file_lru);\n\n\t\trcu_read_lock();\n\t\tht = &nfsd_file_rhltable.ht;\n\t\tcount = atomic_read(&ht->nelems);\n\t\ttbl = rht_dereference_rcu(ht->tbl, ht);\n\t\tbuckets = tbl->size;\n\t\trcu_read_unlock();\n\t}\n\tmutex_unlock(&nfsd_mutex);\n\n\tfor_each_possible_cpu(i) {\n\t\thits += per_cpu(nfsd_file_cache_hits, i);\n\t\tacquisitions += per_cpu(nfsd_file_acquisitions, i);\n\t\treleases += per_cpu(nfsd_file_releases, i);\n\t\ttotal_age += per_cpu(nfsd_file_total_age, i);\n\t\tevictions += per_cpu(nfsd_file_evictions, i);\n\t}\n\n\tseq_printf(m, \"total inodes:  %u\\n\", count);\n\tseq_printf(m, \"hash buckets:  %u\\n\", buckets);\n\tseq_printf(m, \"lru entries:   %lu\\n\", lru);\n\tseq_printf(m, \"cache hits:    %lu\\n\", hits);\n\tseq_printf(m, \"acquisitions:  %lu\\n\", acquisitions);\n\tseq_printf(m, \"releases:      %lu\\n\", releases);\n\tseq_printf(m, \"evictions:     %lu\\n\", evictions);\n\tif (releases)\n\t\tseq_printf(m, \"mean age (ms): %ld\\n\", total_age / releases);\n\telse\n\t\tseq_printf(m, \"mean age (ms): -\\n\");\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}