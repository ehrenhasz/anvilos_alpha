{
  "module_name": "nfs4state.c",
  "hash_id": "8043f340c73f1af836d006b2d9dd8b3fd192d3f65935a1e37c8c80fa9744306a",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfsd/nfs4state.c",
  "human_readable_source": " \n\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/ratelimit.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/jhash.h>\n#include <linux/string_helpers.h>\n#include <linux/fsnotify.h>\n#include <linux/rhashtable.h>\n#include <linux/nfs_ssc.h>\n\n#include \"xdr4.h\"\n#include \"xdr4cb.h\"\n#include \"vfs.h\"\n#include \"current_stateid.h\"\n\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"filecache.h\"\n#include \"trace.h\"\n\n#define NFSDDBG_FACILITY                NFSDDBG_PROC\n\n#define all_ones {{~0,~0},~0}\nstatic const stateid_t one_stateid = {\n\t.si_generation = ~0,\n\t.si_opaque = all_ones,\n};\nstatic const stateid_t zero_stateid = {\n\t \n};\nstatic const stateid_t currentstateid = {\n\t.si_generation = 1,\n};\nstatic const stateid_t close_stateid = {\n\t.si_generation = 0xffffffffU,\n};\n\nstatic u64 current_sessionid = 1;\n\n#define ZERO_STATEID(stateid) (!memcmp((stateid), &zero_stateid, sizeof(stateid_t)))\n#define ONE_STATEID(stateid)  (!memcmp((stateid), &one_stateid, sizeof(stateid_t)))\n#define CURRENT_STATEID(stateid) (!memcmp((stateid), &currentstateid, sizeof(stateid_t)))\n#define CLOSE_STATEID(stateid)  (!memcmp((stateid), &close_stateid, sizeof(stateid_t)))\n\n \nstatic bool check_for_locks(struct nfs4_file *fp, struct nfs4_lockowner *lowner);\nstatic void nfs4_free_ol_stateid(struct nfs4_stid *stid);\nvoid nfsd4_end_grace(struct nfsd_net *nn);\nstatic void _free_cpntf_state_locked(struct nfsd_net *nn, struct nfs4_cpntf_state *cps);\nstatic void nfsd4_file_hash_remove(struct nfs4_file *fi);\n\n \n\n \nstatic DEFINE_SPINLOCK(state_lock);\n\nenum nfsd4_st_mutex_lock_subclass {\n\tOPEN_STATEID_MUTEX = 0,\n\tLOCK_STATEID_MUTEX = 1,\n};\n\n \nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\n \nstatic DECLARE_WAIT_QUEUE_HEAD(expiry_wq);\n\nstatic struct kmem_cache *client_slab;\nstatic struct kmem_cache *openowner_slab;\nstatic struct kmem_cache *lockowner_slab;\nstatic struct kmem_cache *file_slab;\nstatic struct kmem_cache *stateid_slab;\nstatic struct kmem_cache *deleg_slab;\nstatic struct kmem_cache *odstate_slab;\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic const struct nfsd4_callback_ops nfsd4_cb_recall_ops;\nstatic const struct nfsd4_callback_ops nfsd4_cb_notify_lock_ops;\n\nstatic struct workqueue_struct *laundry_wq;\n\nint nfsd4_create_laundry_wq(void)\n{\n\tint rc = 0;\n\n\tlaundry_wq = alloc_workqueue(\"%s\", WQ_UNBOUND, 0, \"nfsd4\");\n\tif (laundry_wq == NULL)\n\t\trc = -ENOMEM;\n\treturn rc;\n}\n\nvoid nfsd4_destroy_laundry_wq(void)\n{\n\tdestroy_workqueue(laundry_wq);\n}\n\nstatic bool is_session_dead(struct nfsd4_session *ses)\n{\n\treturn ses->se_flags & NFS4_SESSION_DEAD;\n}\n\nstatic __be32 mark_session_dead_locked(struct nfsd4_session *ses, int ref_held_by_me)\n{\n\tif (atomic_read(&ses->se_ref) > ref_held_by_me)\n\t\treturn nfserr_jukebox;\n\tses->se_flags |= NFS4_SESSION_DEAD;\n\treturn nfs_ok;\n}\n\nstatic bool is_client_expired(struct nfs4_client *clp)\n{\n\treturn clp->cl_time == 0;\n}\n\nstatic void nfsd4_dec_courtesy_client_count(struct nfsd_net *nn,\n\t\t\t\t\tstruct nfs4_client *clp)\n{\n\tif (clp->cl_state != NFSD4_ACTIVE)\n\t\tatomic_add_unless(&nn->nfsd_courtesy_clients, -1, 0);\n}\n\nstatic __be32 get_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tif (is_client_expired(clp))\n\t\treturn nfserr_expired;\n\tatomic_inc(&clp->cl_rpc_users);\n\tnfsd4_dec_courtesy_client_count(nn, clp);\n\tclp->cl_state = NFSD4_ACTIVE;\n\treturn nfs_ok;\n}\n\n \nstatic inline void\nrenew_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (is_client_expired(clp)) {\n\t\tWARN_ON(1);\n\t\tprintk(\"%s: client (clientid %08x/%08x) already expired\\n\",\n\t\t\t__func__,\n\t\t\tclp->cl_clientid.cl_boot,\n\t\t\tclp->cl_clientid.cl_id);\n\t\treturn;\n\t}\n\n\tlist_move_tail(&clp->cl_lru, &nn->client_lru);\n\tclp->cl_time = ktime_get_boottime_seconds();\n\tnfsd4_dec_courtesy_client_count(nn, clp);\n\tclp->cl_state = NFSD4_ACTIVE;\n}\n\nstatic void put_client_renew_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tif (!atomic_dec_and_test(&clp->cl_rpc_users))\n\t\treturn;\n\tif (!is_client_expired(clp))\n\t\trenew_client_locked(clp);\n\telse\n\t\twake_up_all(&expiry_wq);\n}\n\nstatic void put_client_renew(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (!atomic_dec_and_lock(&clp->cl_rpc_users, &nn->client_lock))\n\t\treturn;\n\tif (!is_client_expired(clp))\n\t\trenew_client_locked(clp);\n\telse\n\t\twake_up_all(&expiry_wq);\n\tspin_unlock(&nn->client_lock);\n}\n\nstatic __be32 nfsd4_get_session_locked(struct nfsd4_session *ses)\n{\n\t__be32 status;\n\n\tif (is_session_dead(ses))\n\t\treturn nfserr_badsession;\n\tstatus = get_client_locked(ses->se_client);\n\tif (status)\n\t\treturn status;\n\tatomic_inc(&ses->se_ref);\n\treturn nfs_ok;\n}\n\nstatic void nfsd4_put_session_locked(struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tif (atomic_dec_and_test(&ses->se_ref) && is_session_dead(ses))\n\t\tfree_session(ses);\n\tput_client_renew_locked(clp);\n}\n\nstatic void nfsd4_put_session(struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tspin_lock(&nn->client_lock);\n\tnfsd4_put_session_locked(ses);\n\tspin_unlock(&nn->client_lock);\n}\n\nstatic struct nfsd4_blocked_lock *\nfind_blocked_lock(struct nfs4_lockowner *lo, struct knfsd_fh *fh,\n\t\t\tstruct nfsd_net *nn)\n{\n\tstruct nfsd4_blocked_lock *cur, *found = NULL;\n\n\tspin_lock(&nn->blocked_locks_lock);\n\tlist_for_each_entry(cur, &lo->lo_blocked, nbl_list) {\n\t\tif (fh_match(fh, &cur->nbl_fh)) {\n\t\t\tlist_del_init(&cur->nbl_list);\n\t\t\tWARN_ON(list_empty(&cur->nbl_lru));\n\t\t\tlist_del_init(&cur->nbl_lru);\n\t\t\tfound = cur;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&nn->blocked_locks_lock);\n\tif (found)\n\t\tlocks_delete_block(&found->nbl_lock);\n\treturn found;\n}\n\nstatic struct nfsd4_blocked_lock *\nfind_or_allocate_block(struct nfs4_lockowner *lo, struct knfsd_fh *fh,\n\t\t\tstruct nfsd_net *nn)\n{\n\tstruct nfsd4_blocked_lock *nbl;\n\n\tnbl = find_blocked_lock(lo, fh, nn);\n\tif (!nbl) {\n\t\tnbl= kmalloc(sizeof(*nbl), GFP_KERNEL);\n\t\tif (nbl) {\n\t\t\tINIT_LIST_HEAD(&nbl->nbl_list);\n\t\t\tINIT_LIST_HEAD(&nbl->nbl_lru);\n\t\t\tfh_copy_shallow(&nbl->nbl_fh, fh);\n\t\t\tlocks_init_lock(&nbl->nbl_lock);\n\t\t\tkref_init(&nbl->nbl_kref);\n\t\t\tnfsd4_init_cb(&nbl->nbl_cb, lo->lo_owner.so_client,\n\t\t\t\t\t&nfsd4_cb_notify_lock_ops,\n\t\t\t\t\tNFSPROC4_CLNT_CB_NOTIFY_LOCK);\n\t\t}\n\t}\n\treturn nbl;\n}\n\nstatic void\nfree_nbl(struct kref *kref)\n{\n\tstruct nfsd4_blocked_lock *nbl;\n\n\tnbl = container_of(kref, struct nfsd4_blocked_lock, nbl_kref);\n\tkfree(nbl);\n}\n\nstatic void\nfree_blocked_lock(struct nfsd4_blocked_lock *nbl)\n{\n\tlocks_delete_block(&nbl->nbl_lock);\n\tlocks_release_private(&nbl->nbl_lock);\n\tkref_put(&nbl->nbl_kref, free_nbl);\n}\n\nstatic void\nremove_blocked_locks(struct nfs4_lockowner *lo)\n{\n\tstruct nfs4_client *clp = lo->lo_owner.so_client;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\tstruct nfsd4_blocked_lock *nbl;\n\tLIST_HEAD(reaplist);\n\n\t \n\tspin_lock(&nn->blocked_locks_lock);\n\twhile (!list_empty(&lo->lo_blocked)) {\n\t\tnbl = list_first_entry(&lo->lo_blocked,\n\t\t\t\t\tstruct nfsd4_blocked_lock,\n\t\t\t\t\tnbl_list);\n\t\tlist_del_init(&nbl->nbl_list);\n\t\tWARN_ON(list_empty(&nbl->nbl_lru));\n\t\tlist_move(&nbl->nbl_lru, &reaplist);\n\t}\n\tspin_unlock(&nn->blocked_locks_lock);\n\n\t \n\twhile (!list_empty(&reaplist)) {\n\t\tnbl = list_first_entry(&reaplist, struct nfsd4_blocked_lock,\n\t\t\t\t\tnbl_lru);\n\t\tlist_del_init(&nbl->nbl_lru);\n\t\tfree_blocked_lock(nbl);\n\t}\n}\n\nstatic void\nnfsd4_cb_notify_lock_prepare(struct nfsd4_callback *cb)\n{\n\tstruct nfsd4_blocked_lock\t*nbl = container_of(cb,\n\t\t\t\t\t\tstruct nfsd4_blocked_lock, nbl_cb);\n\tlocks_delete_block(&nbl->nbl_lock);\n}\n\nstatic int\nnfsd4_cb_notify_lock_done(struct nfsd4_callback *cb, struct rpc_task *task)\n{\n\ttrace_nfsd_cb_notify_lock_done(&zero_stateid, task);\n\n\t \n\tswitch (task->tk_status) {\n\tcase -NFS4ERR_DELAY:\n\t\trpc_delay(task, 1 * HZ);\n\t\treturn 0;\n\tdefault:\n\t\treturn 1;\n\t}\n}\n\nstatic void\nnfsd4_cb_notify_lock_release(struct nfsd4_callback *cb)\n{\n\tstruct nfsd4_blocked_lock\t*nbl = container_of(cb,\n\t\t\t\t\t\tstruct nfsd4_blocked_lock, nbl_cb);\n\n\tfree_blocked_lock(nbl);\n}\n\nstatic const struct nfsd4_callback_ops nfsd4_cb_notify_lock_ops = {\n\t.prepare\t= nfsd4_cb_notify_lock_prepare,\n\t.done\t\t= nfsd4_cb_notify_lock_done,\n\t.release\t= nfsd4_cb_notify_lock_release,\n};\n\n \nstatic unsigned int\nbmap_to_share_mode(unsigned long bmap)\n{\n\tint i;\n\tunsigned int access = 0;\n\n\tfor (i = 1; i < 4; i++) {\n\t\tif (test_bit(i, &bmap))\n\t\t\taccess |= i;\n\t}\n\treturn access;\n}\n\n \nstatic inline void\nset_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\tWARN_ON_ONCE(access > NFS4_SHARE_ACCESS_BOTH);\n\tstp->st_access_bmap |= mask;\n}\n\n \nstatic inline void\nclear_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\tWARN_ON_ONCE(access > NFS4_SHARE_ACCESS_BOTH);\n\tstp->st_access_bmap &= ~mask;\n}\n\n \nstatic inline bool\ntest_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\treturn (bool)(stp->st_access_bmap & mask);\n}\n\n \nstatic inline void\nset_deny(u32 deny, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << deny;\n\n\tWARN_ON_ONCE(deny > NFS4_SHARE_DENY_BOTH);\n\tstp->st_deny_bmap |= mask;\n}\n\n \nstatic inline void\nclear_deny(u32 deny, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << deny;\n\n\tWARN_ON_ONCE(deny > NFS4_SHARE_DENY_BOTH);\n\tstp->st_deny_bmap &= ~mask;\n}\n\n \nstatic inline bool\ntest_deny(u32 deny, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << deny;\n\n\treturn (bool)(stp->st_deny_bmap & mask);\n}\n\nstatic int nfs4_access_to_omode(u32 access)\n{\n\tswitch (access & NFS4_SHARE_ACCESS_BOTH) {\n\tcase NFS4_SHARE_ACCESS_READ:\n\t\treturn O_RDONLY;\n\tcase NFS4_SHARE_ACCESS_WRITE:\n\t\treturn O_WRONLY;\n\tcase NFS4_SHARE_ACCESS_BOTH:\n\t\treturn O_RDWR;\n\t}\n\tWARN_ON_ONCE(1);\n\treturn O_RDONLY;\n}\n\nstatic inline int\naccess_permit_read(struct nfs4_ol_stateid *stp)\n{\n\treturn test_access(NFS4_SHARE_ACCESS_READ, stp) ||\n\t\ttest_access(NFS4_SHARE_ACCESS_BOTH, stp) ||\n\t\ttest_access(NFS4_SHARE_ACCESS_WRITE, stp);\n}\n\nstatic inline int\naccess_permit_write(struct nfs4_ol_stateid *stp)\n{\n\treturn test_access(NFS4_SHARE_ACCESS_WRITE, stp) ||\n\t\ttest_access(NFS4_SHARE_ACCESS_BOTH, stp);\n}\n\nstatic inline struct nfs4_stateowner *\nnfs4_get_stateowner(struct nfs4_stateowner *sop)\n{\n\tatomic_inc(&sop->so_count);\n\treturn sop;\n}\n\nstatic int\nsame_owner_str(struct nfs4_stateowner *sop, struct xdr_netobj *owner)\n{\n\treturn (sop->so_owner.len == owner->len) &&\n\t\t0 == memcmp(sop->so_owner.data, owner->data, owner->len);\n}\n\nstatic struct nfs4_openowner *\nfind_openstateowner_str_locked(unsigned int hashval, struct nfsd4_open *open,\n\t\t\tstruct nfs4_client *clp)\n{\n\tstruct nfs4_stateowner *so;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_for_each_entry(so, &clp->cl_ownerstr_hashtbl[hashval],\n\t\t\t    so_strhash) {\n\t\tif (!so->so_is_open_owner)\n\t\t\tcontinue;\n\t\tif (same_owner_str(so, &open->op_owner))\n\t\t\treturn openowner(nfs4_get_stateowner(so));\n\t}\n\treturn NULL;\n}\n\nstatic struct nfs4_openowner *\nfind_openstateowner_str(unsigned int hashval, struct nfsd4_open *open,\n\t\t\tstruct nfs4_client *clp)\n{\n\tstruct nfs4_openowner *oo;\n\n\tspin_lock(&clp->cl_lock);\n\too = find_openstateowner_str_locked(hashval, open, clp);\n\tspin_unlock(&clp->cl_lock);\n\treturn oo;\n}\n\nstatic inline u32\nopaque_hashval(const void *ptr, int nbytes)\n{\n\tunsigned char *cptr = (unsigned char *) ptr;\n\n\tu32 x = 0;\n\twhile (nbytes--) {\n\t\tx *= 37;\n\t\tx += *cptr++;\n\t}\n\treturn x;\n}\n\nstatic void nfsd4_free_file_rcu(struct rcu_head *rcu)\n{\n\tstruct nfs4_file *fp = container_of(rcu, struct nfs4_file, fi_rcu);\n\n\tkmem_cache_free(file_slab, fp);\n}\n\nvoid\nput_nfs4_file(struct nfs4_file *fi)\n{\n\tif (refcount_dec_and_test(&fi->fi_ref)) {\n\t\tnfsd4_file_hash_remove(fi);\n\t\tWARN_ON_ONCE(!list_empty(&fi->fi_clnt_odstate));\n\t\tWARN_ON_ONCE(!list_empty(&fi->fi_delegations));\n\t\tcall_rcu(&fi->fi_rcu, nfsd4_free_file_rcu);\n\t}\n}\n\nstatic struct nfsd_file *\nfind_writeable_file_locked(struct nfs4_file *f)\n{\n\tstruct nfsd_file *ret;\n\n\tlockdep_assert_held(&f->fi_lock);\n\n\tret = nfsd_file_get(f->fi_fds[O_WRONLY]);\n\tif (!ret)\n\t\tret = nfsd_file_get(f->fi_fds[O_RDWR]);\n\treturn ret;\n}\n\nstatic struct nfsd_file *\nfind_writeable_file(struct nfs4_file *f)\n{\n\tstruct nfsd_file *ret;\n\n\tspin_lock(&f->fi_lock);\n\tret = find_writeable_file_locked(f);\n\tspin_unlock(&f->fi_lock);\n\n\treturn ret;\n}\n\nstatic struct nfsd_file *\nfind_readable_file_locked(struct nfs4_file *f)\n{\n\tstruct nfsd_file *ret;\n\n\tlockdep_assert_held(&f->fi_lock);\n\n\tret = nfsd_file_get(f->fi_fds[O_RDONLY]);\n\tif (!ret)\n\t\tret = nfsd_file_get(f->fi_fds[O_RDWR]);\n\treturn ret;\n}\n\nstatic struct nfsd_file *\nfind_readable_file(struct nfs4_file *f)\n{\n\tstruct nfsd_file *ret;\n\n\tspin_lock(&f->fi_lock);\n\tret = find_readable_file_locked(f);\n\tspin_unlock(&f->fi_lock);\n\n\treturn ret;\n}\n\nstatic struct nfsd_file *\nfind_rw_file(struct nfs4_file *f)\n{\n\tstruct nfsd_file *ret;\n\n\tspin_lock(&f->fi_lock);\n\tret = nfsd_file_get(f->fi_fds[O_RDWR]);\n\tspin_unlock(&f->fi_lock);\n\n\treturn ret;\n}\n\nstruct nfsd_file *\nfind_any_file(struct nfs4_file *f)\n{\n\tstruct nfsd_file *ret;\n\n\tif (!f)\n\t\treturn NULL;\n\tspin_lock(&f->fi_lock);\n\tret = nfsd_file_get(f->fi_fds[O_RDWR]);\n\tif (!ret) {\n\t\tret = nfsd_file_get(f->fi_fds[O_WRONLY]);\n\t\tif (!ret)\n\t\t\tret = nfsd_file_get(f->fi_fds[O_RDONLY]);\n\t}\n\tspin_unlock(&f->fi_lock);\n\treturn ret;\n}\n\nstatic struct nfsd_file *find_any_file_locked(struct nfs4_file *f)\n{\n\tlockdep_assert_held(&f->fi_lock);\n\n\tif (f->fi_fds[O_RDWR])\n\t\treturn f->fi_fds[O_RDWR];\n\tif (f->fi_fds[O_WRONLY])\n\t\treturn f->fi_fds[O_WRONLY];\n\tif (f->fi_fds[O_RDONLY])\n\t\treturn f->fi_fds[O_RDONLY];\n\treturn NULL;\n}\n\nstatic atomic_long_t num_delegations;\nunsigned long max_delegations;\n\n \n\n \n#define OWNER_HASH_BITS              8\n#define OWNER_HASH_SIZE             (1 << OWNER_HASH_BITS)\n#define OWNER_HASH_MASK             (OWNER_HASH_SIZE - 1)\n\nstatic unsigned int ownerstr_hashval(struct xdr_netobj *ownername)\n{\n\tunsigned int ret;\n\n\tret = opaque_hashval(ownername->data, ownername->len);\n\treturn ret & OWNER_HASH_MASK;\n}\n\nstatic struct rhltable nfs4_file_rhltable ____cacheline_aligned_in_smp;\n\nstatic const struct rhashtable_params nfs4_file_rhash_params = {\n\t.key_len\t\t= sizeof_field(struct nfs4_file, fi_inode),\n\t.key_offset\t\t= offsetof(struct nfs4_file, fi_inode),\n\t.head_offset\t\t= offsetof(struct nfs4_file, fi_rlist),\n\n\t \n\t.min_size\t\t= 256,\n\t.automatic_shrinking\t= true,\n};\n\n \nstatic bool\nnfs4_resolve_deny_conflicts_locked(struct nfs4_file *fp, bool new_stp,\n\t\tstruct nfs4_ol_stateid *stp, u32 access, bool share_access)\n{\n\tstruct nfs4_ol_stateid *st;\n\tbool resolvable = true;\n\tunsigned char bmap;\n\tstruct nfsd_net *nn;\n\tstruct nfs4_client *clp;\n\n\tlockdep_assert_held(&fp->fi_lock);\n\tlist_for_each_entry(st, &fp->fi_stateids, st_perfile) {\n\t\t \n\t\tif (st->st_openstp)\n\t\t\tcontinue;\n\t\tif (st == stp && new_stp)\n\t\t\tcontinue;\n\t\t \n\t\tbmap = share_access ? st->st_deny_bmap : st->st_access_bmap;\n\t\tif (!(access & bmap_to_share_mode(bmap)))\n\t\t\tcontinue;\n\t\tclp = st->st_stid.sc_client;\n\t\tif (try_to_expire_client(clp))\n\t\t\tcontinue;\n\t\tresolvable = false;\n\t\tbreak;\n\t}\n\tif (resolvable) {\n\t\tclp = stp->st_stid.sc_client;\n\t\tnn = net_generic(clp->net, nfsd_net_id);\n\t\tmod_delayed_work(laundry_wq, &nn->laundromat_work, 0);\n\t}\n\treturn resolvable;\n}\n\nstatic void\n__nfs4_file_get_access(struct nfs4_file *fp, u32 access)\n{\n\tlockdep_assert_held(&fp->fi_lock);\n\n\tif (access & NFS4_SHARE_ACCESS_WRITE)\n\t\tatomic_inc(&fp->fi_access[O_WRONLY]);\n\tif (access & NFS4_SHARE_ACCESS_READ)\n\t\tatomic_inc(&fp->fi_access[O_RDONLY]);\n}\n\nstatic __be32\nnfs4_file_get_access(struct nfs4_file *fp, u32 access)\n{\n\tlockdep_assert_held(&fp->fi_lock);\n\n\t \n\tif (access & ~NFS4_SHARE_ACCESS_BOTH)\n\t\treturn nfserr_inval;\n\n\t \n\tif ((access & fp->fi_share_deny) != 0)\n\t\treturn nfserr_share_denied;\n\n\t__nfs4_file_get_access(fp, access);\n\treturn nfs_ok;\n}\n\nstatic __be32 nfs4_file_check_deny(struct nfs4_file *fp, u32 deny)\n{\n\t \n\tif (deny) {\n\t\t \n\t\tif (deny & ~NFS4_SHARE_DENY_BOTH)\n\t\t\treturn nfserr_inval;\n\n\t\tif ((deny & NFS4_SHARE_DENY_READ) &&\n\t\t    atomic_read(&fp->fi_access[O_RDONLY]))\n\t\t\treturn nfserr_share_denied;\n\n\t\tif ((deny & NFS4_SHARE_DENY_WRITE) &&\n\t\t    atomic_read(&fp->fi_access[O_WRONLY]))\n\t\t\treturn nfserr_share_denied;\n\t}\n\treturn nfs_ok;\n}\n\nstatic void __nfs4_file_put_access(struct nfs4_file *fp, int oflag)\n{\n\tmight_lock(&fp->fi_lock);\n\n\tif (atomic_dec_and_lock(&fp->fi_access[oflag], &fp->fi_lock)) {\n\t\tstruct nfsd_file *f1 = NULL;\n\t\tstruct nfsd_file *f2 = NULL;\n\n\t\tswap(f1, fp->fi_fds[oflag]);\n\t\tif (atomic_read(&fp->fi_access[1 - oflag]) == 0)\n\t\t\tswap(f2, fp->fi_fds[O_RDWR]);\n\t\tspin_unlock(&fp->fi_lock);\n\t\tif (f1)\n\t\t\tnfsd_file_put(f1);\n\t\tif (f2)\n\t\t\tnfsd_file_put(f2);\n\t}\n}\n\nstatic void nfs4_file_put_access(struct nfs4_file *fp, u32 access)\n{\n\tWARN_ON_ONCE(access & ~NFS4_SHARE_ACCESS_BOTH);\n\n\tif (access & NFS4_SHARE_ACCESS_WRITE)\n\t\t__nfs4_file_put_access(fp, O_WRONLY);\n\tif (access & NFS4_SHARE_ACCESS_READ)\n\t\t__nfs4_file_put_access(fp, O_RDONLY);\n}\n\n \nstatic struct nfs4_clnt_odstate *\nalloc_clnt_odstate(struct nfs4_client *clp)\n{\n\tstruct nfs4_clnt_odstate *co;\n\n\tco = kmem_cache_zalloc(odstate_slab, GFP_KERNEL);\n\tif (co) {\n\t\tco->co_client = clp;\n\t\trefcount_set(&co->co_odcount, 1);\n\t}\n\treturn co;\n}\n\nstatic void\nhash_clnt_odstate_locked(struct nfs4_clnt_odstate *co)\n{\n\tstruct nfs4_file *fp = co->co_file;\n\n\tlockdep_assert_held(&fp->fi_lock);\n\tlist_add(&co->co_perfile, &fp->fi_clnt_odstate);\n}\n\nstatic inline void\nget_clnt_odstate(struct nfs4_clnt_odstate *co)\n{\n\tif (co)\n\t\trefcount_inc(&co->co_odcount);\n}\n\nstatic void\nput_clnt_odstate(struct nfs4_clnt_odstate *co)\n{\n\tstruct nfs4_file *fp;\n\n\tif (!co)\n\t\treturn;\n\n\tfp = co->co_file;\n\tif (refcount_dec_and_lock(&co->co_odcount, &fp->fi_lock)) {\n\t\tlist_del(&co->co_perfile);\n\t\tspin_unlock(&fp->fi_lock);\n\n\t\tnfsd4_return_all_file_layouts(co->co_client, fp);\n\t\tkmem_cache_free(odstate_slab, co);\n\t}\n}\n\nstatic struct nfs4_clnt_odstate *\nfind_or_hash_clnt_odstate(struct nfs4_file *fp, struct nfs4_clnt_odstate *new)\n{\n\tstruct nfs4_clnt_odstate *co;\n\tstruct nfs4_client *cl;\n\n\tif (!new)\n\t\treturn NULL;\n\n\tcl = new->co_client;\n\n\tspin_lock(&fp->fi_lock);\n\tlist_for_each_entry(co, &fp->fi_clnt_odstate, co_perfile) {\n\t\tif (co->co_client == cl) {\n\t\t\tget_clnt_odstate(co);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tco = new;\n\tco->co_file = fp;\n\thash_clnt_odstate_locked(new);\nout:\n\tspin_unlock(&fp->fi_lock);\n\treturn co;\n}\n\nstruct nfs4_stid *nfs4_alloc_stid(struct nfs4_client *cl, struct kmem_cache *slab,\n\t\t\t\t  void (*sc_free)(struct nfs4_stid *))\n{\n\tstruct nfs4_stid *stid;\n\tint new_id;\n\n\tstid = kmem_cache_zalloc(slab, GFP_KERNEL);\n\tif (!stid)\n\t\treturn NULL;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock(&cl->cl_lock);\n\t \n\tnew_id = idr_alloc_cyclic(&cl->cl_stateids, stid, 1, 0, GFP_NOWAIT);\n\tspin_unlock(&cl->cl_lock);\n\tidr_preload_end();\n\tif (new_id < 0)\n\t\tgoto out_free;\n\n\tstid->sc_free = sc_free;\n\tstid->sc_client = cl;\n\tstid->sc_stateid.si_opaque.so_id = new_id;\n\tstid->sc_stateid.si_opaque.so_clid = cl->cl_clientid;\n\t \n\trefcount_set(&stid->sc_count, 1);\n\tspin_lock_init(&stid->sc_lock);\n\tINIT_LIST_HEAD(&stid->sc_cp_list);\n\n\t \n\treturn stid;\nout_free:\n\tkmem_cache_free(slab, stid);\n\treturn NULL;\n}\n\n \nstatic int nfs4_init_cp_state(struct nfsd_net *nn, copy_stateid_t *stid,\n\t\t\t      unsigned char cs_type)\n{\n\tint new_id;\n\n\tstid->cs_stid.si_opaque.so_clid.cl_boot = (u32)nn->boot_time;\n\tstid->cs_stid.si_opaque.so_clid.cl_id = nn->s2s_cp_cl_id;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock(&nn->s2s_cp_lock);\n\tnew_id = idr_alloc_cyclic(&nn->s2s_cp_stateids, stid, 0, 0, GFP_NOWAIT);\n\tstid->cs_stid.si_opaque.so_id = new_id;\n\tstid->cs_stid.si_generation = 1;\n\tspin_unlock(&nn->s2s_cp_lock);\n\tidr_preload_end();\n\tif (new_id < 0)\n\t\treturn 0;\n\tstid->cs_type = cs_type;\n\treturn 1;\n}\n\nint nfs4_init_copy_state(struct nfsd_net *nn, struct nfsd4_copy *copy)\n{\n\treturn nfs4_init_cp_state(nn, &copy->cp_stateid, NFS4_COPY_STID);\n}\n\nstruct nfs4_cpntf_state *nfs4_alloc_init_cpntf_state(struct nfsd_net *nn,\n\t\t\t\t\t\t     struct nfs4_stid *p_stid)\n{\n\tstruct nfs4_cpntf_state *cps;\n\n\tcps = kzalloc(sizeof(struct nfs4_cpntf_state), GFP_KERNEL);\n\tif (!cps)\n\t\treturn NULL;\n\tcps->cpntf_time = ktime_get_boottime_seconds();\n\trefcount_set(&cps->cp_stateid.cs_count, 1);\n\tif (!nfs4_init_cp_state(nn, &cps->cp_stateid, NFS4_COPYNOTIFY_STID))\n\t\tgoto out_free;\n\tspin_lock(&nn->s2s_cp_lock);\n\tlist_add(&cps->cp_list, &p_stid->sc_cp_list);\n\tspin_unlock(&nn->s2s_cp_lock);\n\treturn cps;\nout_free:\n\tkfree(cps);\n\treturn NULL;\n}\n\nvoid nfs4_free_copy_state(struct nfsd4_copy *copy)\n{\n\tstruct nfsd_net *nn;\n\n\tif (copy->cp_stateid.cs_type != NFS4_COPY_STID)\n\t\treturn;\n\tnn = net_generic(copy->cp_clp->net, nfsd_net_id);\n\tspin_lock(&nn->s2s_cp_lock);\n\tidr_remove(&nn->s2s_cp_stateids,\n\t\t   copy->cp_stateid.cs_stid.si_opaque.so_id);\n\tspin_unlock(&nn->s2s_cp_lock);\n}\n\nstatic void nfs4_free_cpntf_statelist(struct net *net, struct nfs4_stid *stid)\n{\n\tstruct nfs4_cpntf_state *cps;\n\tstruct nfsd_net *nn;\n\n\tnn = net_generic(net, nfsd_net_id);\n\tspin_lock(&nn->s2s_cp_lock);\n\twhile (!list_empty(&stid->sc_cp_list)) {\n\t\tcps = list_first_entry(&stid->sc_cp_list,\n\t\t\t\t       struct nfs4_cpntf_state, cp_list);\n\t\t_free_cpntf_state_locked(nn, cps);\n\t}\n\tspin_unlock(&nn->s2s_cp_lock);\n}\n\nstatic struct nfs4_ol_stateid * nfs4_alloc_open_stateid(struct nfs4_client *clp)\n{\n\tstruct nfs4_stid *stid;\n\n\tstid = nfs4_alloc_stid(clp, stateid_slab, nfs4_free_ol_stateid);\n\tif (!stid)\n\t\treturn NULL;\n\n\treturn openlockstateid(stid);\n}\n\nstatic void nfs4_free_deleg(struct nfs4_stid *stid)\n{\n\tstruct nfs4_delegation *dp = delegstateid(stid);\n\n\tWARN_ON_ONCE(!list_empty(&stid->sc_cp_list));\n\tWARN_ON_ONCE(!list_empty(&dp->dl_perfile));\n\tWARN_ON_ONCE(!list_empty(&dp->dl_perclnt));\n\tWARN_ON_ONCE(!list_empty(&dp->dl_recall_lru));\n\tkmem_cache_free(deleg_slab, stid);\n\tatomic_long_dec(&num_delegations);\n}\n\n \nstatic DEFINE_SPINLOCK(blocked_delegations_lock);\nstatic struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime64_t swap_time;\n\tint\tnew;  \n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;\n\nstatic int delegation_blocked(struct knfsd_fh *fh)\n{\n\tu32 hash;\n\tstruct bloom_pair *bd = &blocked_delegations;\n\n\tif (bd->entries == 0)\n\t\treturn 0;\n\tif (ktime_get_seconds() - bd->swap_time > 30) {\n\t\tspin_lock(&blocked_delegations_lock);\n\t\tif (ktime_get_seconds() - bd->swap_time > 30) {\n\t\t\tbd->entries -= bd->old_entries;\n\t\t\tbd->old_entries = bd->entries;\n\t\t\tmemset(bd->set[bd->new], 0,\n\t\t\t       sizeof(bd->set[0]));\n\t\t\tbd->new = 1-bd->new;\n\t\t\tbd->swap_time = ktime_get_seconds();\n\t\t}\n\t\tspin_unlock(&blocked_delegations_lock);\n\t}\n\thash = jhash(&fh->fh_raw, fh->fh_size, 0);\n\tif (test_bit(hash&255, bd->set[0]) &&\n\t    test_bit((hash>>8)&255, bd->set[0]) &&\n\t    test_bit((hash>>16)&255, bd->set[0]))\n\t\treturn 1;\n\n\tif (test_bit(hash&255, bd->set[1]) &&\n\t    test_bit((hash>>8)&255, bd->set[1]) &&\n\t    test_bit((hash>>16)&255, bd->set[1]))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic void block_delegations(struct knfsd_fh *fh)\n{\n\tu32 hash;\n\tstruct bloom_pair *bd = &blocked_delegations;\n\n\thash = jhash(&fh->fh_raw, fh->fh_size, 0);\n\n\tspin_lock(&blocked_delegations_lock);\n\t__set_bit(hash&255, bd->set[bd->new]);\n\t__set_bit((hash>>8)&255, bd->set[bd->new]);\n\t__set_bit((hash>>16)&255, bd->set[bd->new]);\n\tif (bd->entries == 0)\n\t\tbd->swap_time = ktime_get_seconds();\n\tbd->entries += 1;\n\tspin_unlock(&blocked_delegations_lock);\n}\n\nstatic struct nfs4_delegation *\nalloc_init_deleg(struct nfs4_client *clp, struct nfs4_file *fp,\n\t\t struct nfs4_clnt_odstate *odstate, u32 dl_type)\n{\n\tstruct nfs4_delegation *dp;\n\tlong n;\n\n\tdprintk(\"NFSD alloc_init_deleg\\n\");\n\tn = atomic_long_inc_return(&num_delegations);\n\tif (n < 0 || n > max_delegations)\n\t\tgoto out_dec;\n\tif (delegation_blocked(&fp->fi_fhandle))\n\t\tgoto out_dec;\n\tdp = delegstateid(nfs4_alloc_stid(clp, deleg_slab, nfs4_free_deleg));\n\tif (dp == NULL)\n\t\tgoto out_dec;\n\n\t \n\tdp->dl_stid.sc_stateid.si_generation = 1;\n\tINIT_LIST_HEAD(&dp->dl_perfile);\n\tINIT_LIST_HEAD(&dp->dl_perclnt);\n\tINIT_LIST_HEAD(&dp->dl_recall_lru);\n\tdp->dl_clnt_odstate = odstate;\n\tget_clnt_odstate(odstate);\n\tdp->dl_type = dl_type;\n\tdp->dl_retries = 1;\n\tdp->dl_recalled = false;\n\tnfsd4_init_cb(&dp->dl_recall, dp->dl_stid.sc_client,\n\t\t      &nfsd4_cb_recall_ops, NFSPROC4_CLNT_CB_RECALL);\n\tget_nfs4_file(fp);\n\tdp->dl_stid.sc_file = fp;\n\treturn dp;\nout_dec:\n\tatomic_long_dec(&num_delegations);\n\treturn NULL;\n}\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!refcount_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tnfs4_free_cpntf_statelist(clp->net, s);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}\n\nvoid\nnfs4_inc_and_copy_stateid(stateid_t *dst, struct nfs4_stid *stid)\n{\n\tstateid_t *src = &stid->sc_stateid;\n\n\tspin_lock(&stid->sc_lock);\n\tif (unlikely(++src->si_generation == 0))\n\t\tsrc->si_generation = 1;\n\tmemcpy(dst, src, sizeof(*dst));\n\tspin_unlock(&stid->sc_lock);\n}\n\nstatic void put_deleg_file(struct nfs4_file *fp)\n{\n\tstruct nfsd_file *nf = NULL;\n\n\tspin_lock(&fp->fi_lock);\n\tif (--fp->fi_delegees == 0)\n\t\tswap(nf, fp->fi_deleg_file);\n\tspin_unlock(&fp->fi_lock);\n\n\tif (nf)\n\t\tnfsd_file_put(nf);\n}\n\nstatic void nfs4_unlock_deleg_lease(struct nfs4_delegation *dp)\n{\n\tstruct nfs4_file *fp = dp->dl_stid.sc_file;\n\tstruct nfsd_file *nf = fp->fi_deleg_file;\n\n\tWARN_ON_ONCE(!fp->fi_delegees);\n\n\tvfs_setlease(nf->nf_file, F_UNLCK, NULL, (void **)&dp);\n\tput_deleg_file(fp);\n}\n\nstatic void destroy_unhashed_deleg(struct nfs4_delegation *dp)\n{\n\tput_clnt_odstate(dp->dl_clnt_odstate);\n\tnfs4_unlock_deleg_lease(dp);\n\tnfs4_put_stid(&dp->dl_stid);\n}\n\nvoid nfs4_unhash_stid(struct nfs4_stid *s)\n{\n\ts->sc_type = 0;\n}\n\n \n\nstatic bool\nnfs4_delegation_exists(struct nfs4_client *clp, struct nfs4_file *fp)\n{\n\tstruct nfs4_delegation *searchdp = NULL;\n\tstruct nfs4_client *searchclp = NULL;\n\n\tlockdep_assert_held(&state_lock);\n\tlockdep_assert_held(&fp->fi_lock);\n\n\tlist_for_each_entry(searchdp, &fp->fi_delegations, dl_perfile) {\n\t\tsearchclp = searchdp->dl_stid.sc_client;\n\t\tif (clp == searchclp) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n \n\nstatic int\nhash_delegation_locked(struct nfs4_delegation *dp, struct nfs4_file *fp)\n{\n\tstruct nfs4_client *clp = dp->dl_stid.sc_client;\n\n\tlockdep_assert_held(&state_lock);\n\tlockdep_assert_held(&fp->fi_lock);\n\n\tif (nfs4_delegation_exists(clp, fp))\n\t\treturn -EAGAIN;\n\trefcount_inc(&dp->dl_stid.sc_count);\n\tdp->dl_stid.sc_type = NFS4_DELEG_STID;\n\tlist_add(&dp->dl_perfile, &fp->fi_delegations);\n\tlist_add(&dp->dl_perclnt, &clp->cl_delegations);\n\treturn 0;\n}\n\nstatic bool delegation_hashed(struct nfs4_delegation *dp)\n{\n\treturn !(list_empty(&dp->dl_perfile));\n}\n\nstatic bool\nunhash_delegation_locked(struct nfs4_delegation *dp)\n{\n\tstruct nfs4_file *fp = dp->dl_stid.sc_file;\n\n\tlockdep_assert_held(&state_lock);\n\n\tif (!delegation_hashed(dp))\n\t\treturn false;\n\n\tdp->dl_stid.sc_type = NFS4_CLOSED_DELEG_STID;\n\t \n\t++dp->dl_time;\n\tspin_lock(&fp->fi_lock);\n\tlist_del_init(&dp->dl_perclnt);\n\tlist_del_init(&dp->dl_recall_lru);\n\tlist_del_init(&dp->dl_perfile);\n\tspin_unlock(&fp->fi_lock);\n\treturn true;\n}\n\nstatic void destroy_delegation(struct nfs4_delegation *dp)\n{\n\tbool unhashed;\n\n\tspin_lock(&state_lock);\n\tunhashed = unhash_delegation_locked(dp);\n\tspin_unlock(&state_lock);\n\tif (unhashed)\n\t\tdestroy_unhashed_deleg(dp);\n}\n\nstatic void revoke_delegation(struct nfs4_delegation *dp)\n{\n\tstruct nfs4_client *clp = dp->dl_stid.sc_client;\n\n\tWARN_ON(!list_empty(&dp->dl_recall_lru));\n\n\ttrace_nfsd_stid_revoke(&dp->dl_stid);\n\n\tif (clp->cl_minorversion) {\n\t\tspin_lock(&clp->cl_lock);\n\t\tdp->dl_stid.sc_type = NFS4_REVOKED_DELEG_STID;\n\t\trefcount_inc(&dp->dl_stid.sc_count);\n\t\tlist_add(&dp->dl_recall_lru, &clp->cl_revoked);\n\t\tspin_unlock(&clp->cl_lock);\n\t}\n\tdestroy_unhashed_deleg(dp);\n}\n\n \n\nstatic unsigned int clientid_hashval(u32 id)\n{\n\treturn id & CLIENT_HASH_MASK;\n}\n\nstatic unsigned int clientstr_hashval(struct xdr_netobj name)\n{\n\treturn opaque_hashval(name.data, 8) & CLIENT_HASH_MASK;\n}\n\n \nstatic void\nrecalculate_deny_mode(struct nfs4_file *fp)\n{\n\tstruct nfs4_ol_stateid *stp;\n\n\tspin_lock(&fp->fi_lock);\n\tfp->fi_share_deny = 0;\n\tlist_for_each_entry(stp, &fp->fi_stateids, st_perfile)\n\t\tfp->fi_share_deny |= bmap_to_share_mode(stp->st_deny_bmap);\n\tspin_unlock(&fp->fi_lock);\n}\n\nstatic void\nreset_union_bmap_deny(u32 deny, struct nfs4_ol_stateid *stp)\n{\n\tint i;\n\tbool change = false;\n\n\tfor (i = 1; i < 4; i++) {\n\t\tif ((i & deny) != i) {\n\t\t\tchange = true;\n\t\t\tclear_deny(i, stp);\n\t\t}\n\t}\n\n\t \n\tif (change)\n\t\trecalculate_deny_mode(stp->st_stid.sc_file);\n}\n\n \nstatic void\nrelease_all_access(struct nfs4_ol_stateid *stp)\n{\n\tint i;\n\tstruct nfs4_file *fp = stp->st_stid.sc_file;\n\n\tif (fp && stp->st_deny_bmap != 0)\n\t\trecalculate_deny_mode(fp);\n\n\tfor (i = 1; i < 4; i++) {\n\t\tif (test_access(i, stp))\n\t\t\tnfs4_file_put_access(stp->st_stid.sc_file, i);\n\t\tclear_access(i, stp);\n\t}\n}\n\nstatic inline void nfs4_free_stateowner(struct nfs4_stateowner *sop)\n{\n\tkfree(sop->so_owner.data);\n\tsop->so_ops->so_free(sop);\n}\n\nstatic void nfs4_put_stateowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_client *clp = sop->so_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&sop->so_count, &clp->cl_lock))\n\t\treturn;\n\tsop->so_ops->so_unhash(sop);\n\tspin_unlock(&clp->cl_lock);\n\tnfs4_free_stateowner(sop);\n}\n\nstatic bool\nnfs4_ol_stateid_unhashed(const struct nfs4_ol_stateid *stp)\n{\n\treturn list_empty(&stp->st_perfile);\n}\n\nstatic bool unhash_ol_stateid(struct nfs4_ol_stateid *stp)\n{\n\tstruct nfs4_file *fp = stp->st_stid.sc_file;\n\n\tlockdep_assert_held(&stp->st_stateowner->so_client->cl_lock);\n\n\tif (list_empty(&stp->st_perfile))\n\t\treturn false;\n\n\tspin_lock(&fp->fi_lock);\n\tlist_del_init(&stp->st_perfile);\n\tspin_unlock(&fp->fi_lock);\n\tlist_del(&stp->st_perstateowner);\n\treturn true;\n}\n\nstatic void nfs4_free_ol_stateid(struct nfs4_stid *stid)\n{\n\tstruct nfs4_ol_stateid *stp = openlockstateid(stid);\n\n\tput_clnt_odstate(stp->st_clnt_odstate);\n\trelease_all_access(stp);\n\tif (stp->st_stateowner)\n\t\tnfs4_put_stateowner(stp->st_stateowner);\n\tWARN_ON(!list_empty(&stid->sc_cp_list));\n\tkmem_cache_free(stateid_slab, stid);\n}\n\nstatic void nfs4_free_lock_stateid(struct nfs4_stid *stid)\n{\n\tstruct nfs4_ol_stateid *stp = openlockstateid(stid);\n\tstruct nfs4_lockowner *lo = lockowner(stp->st_stateowner);\n\tstruct nfsd_file *nf;\n\n\tnf = find_any_file(stp->st_stid.sc_file);\n\tif (nf) {\n\t\tget_file(nf->nf_file);\n\t\tfilp_close(nf->nf_file, (fl_owner_t)lo);\n\t\tnfsd_file_put(nf);\n\t}\n\tnfs4_free_ol_stateid(stid);\n}\n\n \nstatic void put_ol_stateid_locked(struct nfs4_ol_stateid *stp,\n\t\t\t\t       struct list_head *reaplist)\n{\n\tstruct nfs4_stid *s = &stp->st_stid;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tWARN_ON_ONCE(!list_empty(&stp->st_locks));\n\n\tif (!refcount_dec_and_test(&s->sc_count)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tlist_add(&stp->st_locks, reaplist);\n}\n\nstatic bool unhash_lock_stateid(struct nfs4_ol_stateid *stp)\n{\n\tlockdep_assert_held(&stp->st_stid.sc_client->cl_lock);\n\n\tif (!unhash_ol_stateid(stp))\n\t\treturn false;\n\tlist_del_init(&stp->st_locks);\n\tnfs4_unhash_stid(&stp->st_stid);\n\treturn true;\n}\n\nstatic void release_lock_stateid(struct nfs4_ol_stateid *stp)\n{\n\tstruct nfs4_client *clp = stp->st_stid.sc_client;\n\tbool unhashed;\n\n\tspin_lock(&clp->cl_lock);\n\tunhashed = unhash_lock_stateid(stp);\n\tspin_unlock(&clp->cl_lock);\n\tif (unhashed)\n\t\tnfs4_put_stid(&stp->st_stid);\n}\n\nstatic void unhash_lockowner_locked(struct nfs4_lockowner *lo)\n{\n\tstruct nfs4_client *clp = lo->lo_owner.so_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_del_init(&lo->lo_owner.so_strhash);\n}\n\n \nstatic void\nfree_ol_stateid_reaplist(struct list_head *reaplist)\n{\n\tstruct nfs4_ol_stateid *stp;\n\tstruct nfs4_file *fp;\n\n\tmight_sleep();\n\n\twhile (!list_empty(reaplist)) {\n\t\tstp = list_first_entry(reaplist, struct nfs4_ol_stateid,\n\t\t\t\t       st_locks);\n\t\tlist_del(&stp->st_locks);\n\t\tfp = stp->st_stid.sc_file;\n\t\tstp->st_stid.sc_free(&stp->st_stid);\n\t\tif (fp)\n\t\t\tput_nfs4_file(fp);\n\t}\n}\n\nstatic void release_open_stateid_locks(struct nfs4_ol_stateid *open_stp,\n\t\t\t\t       struct list_head *reaplist)\n{\n\tstruct nfs4_ol_stateid *stp;\n\n\tlockdep_assert_held(&open_stp->st_stid.sc_client->cl_lock);\n\n\twhile (!list_empty(&open_stp->st_locks)) {\n\t\tstp = list_entry(open_stp->st_locks.next,\n\t\t\t\tstruct nfs4_ol_stateid, st_locks);\n\t\tWARN_ON(!unhash_lock_stateid(stp));\n\t\tput_ol_stateid_locked(stp, reaplist);\n\t}\n}\n\nstatic bool unhash_open_stateid(struct nfs4_ol_stateid *stp,\n\t\t\t\tstruct list_head *reaplist)\n{\n\tlockdep_assert_held(&stp->st_stid.sc_client->cl_lock);\n\n\tif (!unhash_ol_stateid(stp))\n\t\treturn false;\n\trelease_open_stateid_locks(stp, reaplist);\n\treturn true;\n}\n\nstatic void release_open_stateid(struct nfs4_ol_stateid *stp)\n{\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&stp->st_stid.sc_client->cl_lock);\n\tif (unhash_open_stateid(stp, &reaplist))\n\t\tput_ol_stateid_locked(stp, &reaplist);\n\tspin_unlock(&stp->st_stid.sc_client->cl_lock);\n\tfree_ol_stateid_reaplist(&reaplist);\n}\n\nstatic void unhash_openowner_locked(struct nfs4_openowner *oo)\n{\n\tstruct nfs4_client *clp = oo->oo_owner.so_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_del_init(&oo->oo_owner.so_strhash);\n\tlist_del_init(&oo->oo_perclient);\n}\n\nstatic void release_last_closed_stateid(struct nfs4_openowner *oo)\n{\n\tstruct nfsd_net *nn = net_generic(oo->oo_owner.so_client->net,\n\t\t\t\t\t  nfsd_net_id);\n\tstruct nfs4_ol_stateid *s;\n\n\tspin_lock(&nn->client_lock);\n\ts = oo->oo_last_closed_stid;\n\tif (s) {\n\t\tlist_del_init(&oo->oo_close_lru);\n\t\too->oo_last_closed_stid = NULL;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tif (s)\n\t\tnfs4_put_stid(&s->st_stid);\n}\n\nstatic void release_openowner(struct nfs4_openowner *oo)\n{\n\tstruct nfs4_ol_stateid *stp;\n\tstruct nfs4_client *clp = oo->oo_owner.so_client;\n\tstruct list_head reaplist;\n\n\tINIT_LIST_HEAD(&reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tunhash_openowner_locked(oo);\n\twhile (!list_empty(&oo->oo_owner.so_stateids)) {\n\t\tstp = list_first_entry(&oo->oo_owner.so_stateids,\n\t\t\t\tstruct nfs4_ol_stateid, st_perstateowner);\n\t\tif (unhash_open_stateid(stp, &reaplist))\n\t\t\tput_ol_stateid_locked(stp, &reaplist);\n\t}\n\tspin_unlock(&clp->cl_lock);\n\tfree_ol_stateid_reaplist(&reaplist);\n\trelease_last_closed_stateid(oo);\n\tnfs4_put_stateowner(&oo->oo_owner);\n}\n\nstatic inline int\nhash_sessionid(struct nfs4_sessionid *sessionid)\n{\n\tstruct nfsd4_sessionid *sid = (struct nfsd4_sessionid *)sessionid;\n\n\treturn sid->sequence % SESSION_HASH_SIZE;\n}\n\n#ifdef CONFIG_SUNRPC_DEBUG\nstatic inline void\ndump_sessionid(const char *fn, struct nfs4_sessionid *sessionid)\n{\n\tu32 *ptr = (u32 *)(&sessionid->data[0]);\n\tdprintk(\"%s: %u:%u:%u:%u\\n\", fn, ptr[0], ptr[1], ptr[2], ptr[3]);\n}\n#else\nstatic inline void\ndump_sessionid(const char *fn, struct nfs4_sessionid *sessionid)\n{\n}\n#endif\n\n \nvoid nfsd4_bump_seqid(struct nfsd4_compound_state *cstate, __be32 nfserr)\n{\n\tstruct nfs4_stateowner *so = cstate->replay_owner;\n\n\tif (nfserr == nfserr_replay_me)\n\t\treturn;\n\n\tif (!seqid_mutating_err(ntohl(nfserr))) {\n\t\tnfsd4_cstate_clear_replay(cstate);\n\t\treturn;\n\t}\n\tif (!so)\n\t\treturn;\n\tif (so->so_is_open_owner)\n\t\trelease_last_closed_stateid(openowner(so));\n\tso->so_seqid++;\n\treturn;\n}\n\nstatic void\ngen_sessionid(struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd4_sessionid *sid;\n\n\tsid = (struct nfsd4_sessionid *)ses->se_sessionid.data;\n\tsid->clientid = clp->cl_clientid;\n\tsid->sequence = current_sessionid++;\n\tsid->reserved = 0;\n}\n\n \n#define NFSD_MIN_HDR_SEQ_SZ  (24 + 12 + 44)\n\nstatic void\nfree_session_slots(struct nfsd4_session *ses)\n{\n\tint i;\n\n\tfor (i = 0; i < ses->se_fchannel.maxreqs; i++) {\n\t\tfree_svc_cred(&ses->se_slots[i]->sl_cred);\n\t\tkfree(ses->se_slots[i]);\n\t}\n}\n\n \nstatic inline u32 slot_bytes(struct nfsd4_channel_attrs *ca)\n{\n\tu32 size;\n\n\tif (ca->maxresp_cached < NFSD_MIN_HDR_SEQ_SZ)\n\t\tsize = 0;\n\telse\n\t\tsize = ca->maxresp_cached - NFSD_MIN_HDR_SEQ_SZ;\n\treturn size + sizeof(struct nfsd4_slot);\n}\n\n \nstatic u32 nfsd4_get_drc_mem(struct nfsd4_channel_attrs *ca, struct nfsd_net *nn)\n{\n\tu32 slotsize = slot_bytes(ca);\n\tu32 num = ca->maxreqs;\n\tunsigned long avail, total_avail;\n\tunsigned int scale_factor;\n\n\tspin_lock(&nfsd_drc_lock);\n\tif (nfsd_drc_max_mem > nfsd_drc_mem_used)\n\t\ttotal_avail = nfsd_drc_max_mem - nfsd_drc_mem_used;\n\telse\n\t\t \n\t\ttotal_avail = 0;\n\tavail = min((unsigned long)NFSD_MAX_MEM_PER_SESSION, total_avail);\n\t \n\tscale_factor = max_t(unsigned int, 8, nn->nfsd_serv->sv_nrthreads);\n\n\tavail = clamp_t(unsigned long, avail, slotsize,\n\t\t\ttotal_avail/scale_factor);\n\tnum = min_t(int, num, avail / slotsize);\n\tnum = max_t(int, num, 1);\n\tnfsd_drc_mem_used += num * slotsize;\n\tspin_unlock(&nfsd_drc_lock);\n\n\treturn num;\n}\n\nstatic void nfsd4_put_drc_mem(struct nfsd4_channel_attrs *ca)\n{\n\tint slotsize = slot_bytes(ca);\n\n\tspin_lock(&nfsd_drc_lock);\n\tnfsd_drc_mem_used -= slotsize * ca->maxreqs;\n\tspin_unlock(&nfsd_drc_lock);\n}\n\nstatic struct nfsd4_session *alloc_session(struct nfsd4_channel_attrs *fattrs,\n\t\t\t\t\t   struct nfsd4_channel_attrs *battrs)\n{\n\tint numslots = fattrs->maxreqs;\n\tint slotsize = slot_bytes(fattrs);\n\tstruct nfsd4_session *new;\n\tint i;\n\n\tBUILD_BUG_ON(struct_size(new, se_slots, NFSD_MAX_SLOTS_PER_SESSION)\n\t\t     > PAGE_SIZE);\n\n\tnew = kzalloc(struct_size(new, se_slots, numslots), GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\t \n\tfor (i = 0; i < numslots; i++) {\n\t\tnew->se_slots[i] = kzalloc(slotsize, GFP_KERNEL);\n\t\tif (!new->se_slots[i])\n\t\t\tgoto out_free;\n\t}\n\n\tmemcpy(&new->se_fchannel, fattrs, sizeof(struct nfsd4_channel_attrs));\n\tmemcpy(&new->se_bchannel, battrs, sizeof(struct nfsd4_channel_attrs));\n\n\treturn new;\nout_free:\n\twhile (i--)\n\t\tkfree(new->se_slots[i]);\n\tkfree(new);\n\treturn NULL;\n}\n\nstatic void free_conn(struct nfsd4_conn *c)\n{\n\tsvc_xprt_put(c->cn_xprt);\n\tkfree(c);\n}\n\nstatic void nfsd4_conn_lost(struct svc_xpt_user *u)\n{\n\tstruct nfsd4_conn *c = container_of(u, struct nfsd4_conn, cn_xpt_user);\n\tstruct nfs4_client *clp = c->cn_session->se_client;\n\n\ttrace_nfsd_cb_lost(clp);\n\n\tspin_lock(&clp->cl_lock);\n\tif (!list_empty(&c->cn_persession)) {\n\t\tlist_del(&c->cn_persession);\n\t\tfree_conn(c);\n\t}\n\tnfsd4_probe_callback(clp);\n\tspin_unlock(&clp->cl_lock);\n}\n\nstatic struct nfsd4_conn *alloc_conn(struct svc_rqst *rqstp, u32 flags)\n{\n\tstruct nfsd4_conn *conn;\n\n\tconn = kmalloc(sizeof(struct nfsd4_conn), GFP_KERNEL);\n\tif (!conn)\n\t\treturn NULL;\n\tsvc_xprt_get(rqstp->rq_xprt);\n\tconn->cn_xprt = rqstp->rq_xprt;\n\tconn->cn_flags = flags;\n\tINIT_LIST_HEAD(&conn->cn_xpt_user.list);\n\treturn conn;\n}\n\nstatic void __nfsd4_hash_conn(struct nfsd4_conn *conn, struct nfsd4_session *ses)\n{\n\tconn->cn_session = ses;\n\tlist_add(&conn->cn_persession, &ses->se_conns);\n}\n\nstatic void nfsd4_hash_conn(struct nfsd4_conn *conn, struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\n\tspin_lock(&clp->cl_lock);\n\t__nfsd4_hash_conn(conn, ses);\n\tspin_unlock(&clp->cl_lock);\n}\n\nstatic int nfsd4_register_conn(struct nfsd4_conn *conn)\n{\n\tconn->cn_xpt_user.callback = nfsd4_conn_lost;\n\treturn register_xpt_user(conn->cn_xprt, &conn->cn_xpt_user);\n}\n\nstatic void nfsd4_init_conn(struct svc_rqst *rqstp, struct nfsd4_conn *conn, struct nfsd4_session *ses)\n{\n\tint ret;\n\n\tnfsd4_hash_conn(conn, ses);\n\tret = nfsd4_register_conn(conn);\n\tif (ret)\n\t\t \n\t\tnfsd4_conn_lost(&conn->cn_xpt_user);\n\t \n\tnfsd4_probe_callback_sync(ses->se_client);\n}\n\nstatic struct nfsd4_conn *alloc_conn_from_crses(struct svc_rqst *rqstp, struct nfsd4_create_session *cses)\n{\n\tu32 dir = NFS4_CDFC4_FORE;\n\n\tif (cses->flags & SESSION4_BACK_CHAN)\n\t\tdir |= NFS4_CDFC4_BACK;\n\treturn alloc_conn(rqstp, dir);\n}\n\n \nstatic void nfsd4_del_conns(struct nfsd4_session *s)\n{\n\tstruct nfs4_client *clp = s->se_client;\n\tstruct nfsd4_conn *c;\n\n\tspin_lock(&clp->cl_lock);\n\twhile (!list_empty(&s->se_conns)) {\n\t\tc = list_first_entry(&s->se_conns, struct nfsd4_conn, cn_persession);\n\t\tlist_del_init(&c->cn_persession);\n\t\tspin_unlock(&clp->cl_lock);\n\n\t\tunregister_xpt_user(c->cn_xprt, &c->cn_xpt_user);\n\t\tfree_conn(c);\n\n\t\tspin_lock(&clp->cl_lock);\n\t}\n\tspin_unlock(&clp->cl_lock);\n}\n\nstatic void __free_session(struct nfsd4_session *ses)\n{\n\tfree_session_slots(ses);\n\tkfree(ses);\n}\n\nstatic void free_session(struct nfsd4_session *ses)\n{\n\tnfsd4_del_conns(ses);\n\tnfsd4_put_drc_mem(&ses->se_fchannel);\n\t__free_session(ses);\n}\n\nstatic void init_session(struct svc_rqst *rqstp, struct nfsd4_session *new, struct nfs4_client *clp, struct nfsd4_create_session *cses)\n{\n\tint idx;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tnew->se_client = clp;\n\tgen_sessionid(new);\n\n\tINIT_LIST_HEAD(&new->se_conns);\n\n\tnew->se_cb_seq_nr = 1;\n\tnew->se_flags = cses->flags;\n\tnew->se_cb_prog = cses->callback_prog;\n\tnew->se_cb_sec = cses->cb_sec;\n\tatomic_set(&new->se_ref, 0);\n\tidx = hash_sessionid(&new->se_sessionid);\n\tlist_add(&new->se_hash, &nn->sessionid_hashtbl[idx]);\n\tspin_lock(&clp->cl_lock);\n\tlist_add(&new->se_perclnt, &clp->cl_sessions);\n\tspin_unlock(&clp->cl_lock);\n\n\t{\n\t\tstruct sockaddr *sa = svc_addr(rqstp);\n\t\t \n\t\trpc_copy_addr((struct sockaddr *)&clp->cl_cb_conn.cb_addr, sa);\n\t\tclp->cl_cb_conn.cb_addrlen = svc_addr_len(sa);\n\t}\n}\n\n \nstatic struct nfsd4_session *\n__find_in_sessionid_hashtbl(struct nfs4_sessionid *sessionid, struct net *net)\n{\n\tstruct nfsd4_session *elem;\n\tint idx;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tdump_sessionid(__func__, sessionid);\n\tidx = hash_sessionid(sessionid);\n\t \n\tlist_for_each_entry(elem, &nn->sessionid_hashtbl[idx], se_hash) {\n\t\tif (!memcmp(elem->se_sessionid.data, sessionid->data,\n\t\t\t    NFS4_MAX_SESSIONID_LEN)) {\n\t\t\treturn elem;\n\t\t}\n\t}\n\n\tdprintk(\"%s: session not found\\n\", __func__);\n\treturn NULL;\n}\n\nstatic struct nfsd4_session *\nfind_in_sessionid_hashtbl(struct nfs4_sessionid *sessionid, struct net *net,\n\t\t__be32 *ret)\n{\n\tstruct nfsd4_session *session;\n\t__be32 status = nfserr_badsession;\n\n\tsession = __find_in_sessionid_hashtbl(sessionid, net);\n\tif (!session)\n\t\tgoto out;\n\tstatus = nfsd4_get_session_locked(session);\n\tif (status)\n\t\tsession = NULL;\nout:\n\t*ret = status;\n\treturn session;\n}\n\n \nstatic void\nunhash_session(struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tlist_del(&ses->se_hash);\n\tspin_lock(&ses->se_client->cl_lock);\n\tlist_del(&ses->se_perclnt);\n\tspin_unlock(&ses->se_client->cl_lock);\n}\n\n \nstatic int\nSTALE_CLIENTID(clientid_t *clid, struct nfsd_net *nn)\n{\n\t \n\tif (clid->cl_boot == (u32)nn->boot_time)\n\t\treturn 0;\n\ttrace_nfsd_clid_stale(clid);\n\treturn 1;\n}\n\n \nstatic struct nfs4_client *alloc_client(struct xdr_netobj name,\n\t\t\t\tstruct nfsd_net *nn)\n{\n\tstruct nfs4_client *clp;\n\tint i;\n\n\tif (atomic_read(&nn->nfs4_client_count) >= nn->nfs4_max_clients) {\n\t\tmod_delayed_work(laundry_wq, &nn->laundromat_work, 0);\n\t\treturn NULL;\n\t}\n\tclp = kmem_cache_zalloc(client_slab, GFP_KERNEL);\n\tif (clp == NULL)\n\t\treturn NULL;\n\txdr_netobj_dup(&clp->cl_name, &name, GFP_KERNEL);\n\tif (clp->cl_name.data == NULL)\n\t\tgoto err_no_name;\n\tclp->cl_ownerstr_hashtbl = kmalloc_array(OWNER_HASH_SIZE,\n\t\t\t\t\t\t sizeof(struct list_head),\n\t\t\t\t\t\t GFP_KERNEL);\n\tif (!clp->cl_ownerstr_hashtbl)\n\t\tgoto err_no_hashtbl;\n\tfor (i = 0; i < OWNER_HASH_SIZE; i++)\n\t\tINIT_LIST_HEAD(&clp->cl_ownerstr_hashtbl[i]);\n\tINIT_LIST_HEAD(&clp->cl_sessions);\n\tidr_init(&clp->cl_stateids);\n\tatomic_set(&clp->cl_rpc_users, 0);\n\tclp->cl_cb_state = NFSD4_CB_UNKNOWN;\n\tclp->cl_state = NFSD4_ACTIVE;\n\tatomic_inc(&nn->nfs4_client_count);\n\tatomic_set(&clp->cl_delegs_in_recall, 0);\n\tINIT_LIST_HEAD(&clp->cl_idhash);\n\tINIT_LIST_HEAD(&clp->cl_openowners);\n\tINIT_LIST_HEAD(&clp->cl_delegations);\n\tINIT_LIST_HEAD(&clp->cl_lru);\n\tINIT_LIST_HEAD(&clp->cl_revoked);\n#ifdef CONFIG_NFSD_PNFS\n\tINIT_LIST_HEAD(&clp->cl_lo_states);\n#endif\n\tINIT_LIST_HEAD(&clp->async_copies);\n\tspin_lock_init(&clp->async_lock);\n\tspin_lock_init(&clp->cl_lock);\n\trpc_init_wait_queue(&clp->cl_cb_waitq, \"Backchannel slot table\");\n\treturn clp;\nerr_no_hashtbl:\n\tkfree(clp->cl_name.data);\nerr_no_name:\n\tkmem_cache_free(client_slab, clp);\n\treturn NULL;\n}\n\nstatic void __free_client(struct kref *k)\n{\n\tstruct nfsdfs_client *c = container_of(k, struct nfsdfs_client, cl_ref);\n\tstruct nfs4_client *clp = container_of(c, struct nfs4_client, cl_nfsdfs);\n\n\tfree_svc_cred(&clp->cl_cred);\n\tkfree(clp->cl_ownerstr_hashtbl);\n\tkfree(clp->cl_name.data);\n\tkfree(clp->cl_nii_domain.data);\n\tkfree(clp->cl_nii_name.data);\n\tidr_destroy(&clp->cl_stateids);\n\tkfree(clp->cl_ra);\n\tkmem_cache_free(client_slab, clp);\n}\n\nstatic void drop_client(struct nfs4_client *clp)\n{\n\tkref_put(&clp->cl_nfsdfs.cl_ref, __free_client);\n}\n\nstatic void\nfree_client(struct nfs4_client *clp)\n{\n\twhile (!list_empty(&clp->cl_sessions)) {\n\t\tstruct nfsd4_session *ses;\n\t\tses = list_entry(clp->cl_sessions.next, struct nfsd4_session,\n\t\t\t\tse_perclnt);\n\t\tlist_del(&ses->se_perclnt);\n\t\tWARN_ON_ONCE(atomic_read(&ses->se_ref));\n\t\tfree_session(ses);\n\t}\n\trpc_destroy_wait_queue(&clp->cl_cb_waitq);\n\tif (clp->cl_nfsd_dentry) {\n\t\tnfsd_client_rmdir(clp->cl_nfsd_dentry);\n\t\tclp->cl_nfsd_dentry = NULL;\n\t\twake_up_all(&expiry_wq);\n\t}\n\tdrop_client(clp);\n}\n\n \nstatic void\nunhash_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\tstruct nfsd4_session *ses;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\t \n\tclp->cl_time = 0;\n\t \n\tif (!list_empty(&clp->cl_idhash)) {\n\t\tlist_del_init(&clp->cl_idhash);\n\t\tif (test_bit(NFSD4_CLIENT_CONFIRMED, &clp->cl_flags))\n\t\t\trb_erase(&clp->cl_namenode, &nn->conf_name_tree);\n\t\telse\n\t\t\trb_erase(&clp->cl_namenode, &nn->unconf_name_tree);\n\t}\n\tlist_del_init(&clp->cl_lru);\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry(ses, &clp->cl_sessions, se_perclnt)\n\t\tlist_del_init(&ses->se_hash);\n\tspin_unlock(&clp->cl_lock);\n}\n\nstatic void\nunhash_client(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tspin_lock(&nn->client_lock);\n\tunhash_client_locked(clp);\n\tspin_unlock(&nn->client_lock);\n}\n\nstatic __be32 mark_client_expired_locked(struct nfs4_client *clp)\n{\n\tif (atomic_read(&clp->cl_rpc_users))\n\t\treturn nfserr_jukebox;\n\tunhash_client_locked(clp);\n\treturn nfs_ok;\n}\n\nstatic void\n__destroy_client(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\tint i;\n\tstruct nfs4_openowner *oo;\n\tstruct nfs4_delegation *dp;\n\tstruct list_head reaplist;\n\n\tINIT_LIST_HEAD(&reaplist);\n\tspin_lock(&state_lock);\n\twhile (!list_empty(&clp->cl_delegations)) {\n\t\tdp = list_entry(clp->cl_delegations.next, struct nfs4_delegation, dl_perclnt);\n\t\tWARN_ON(!unhash_delegation_locked(dp));\n\t\tlist_add(&dp->dl_recall_lru, &reaplist);\n\t}\n\tspin_unlock(&state_lock);\n\twhile (!list_empty(&reaplist)) {\n\t\tdp = list_entry(reaplist.next, struct nfs4_delegation, dl_recall_lru);\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tdestroy_unhashed_deleg(dp);\n\t}\n\twhile (!list_empty(&clp->cl_revoked)) {\n\t\tdp = list_entry(clp->cl_revoked.next, struct nfs4_delegation, dl_recall_lru);\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tnfs4_put_stid(&dp->dl_stid);\n\t}\n\twhile (!list_empty(&clp->cl_openowners)) {\n\t\too = list_entry(clp->cl_openowners.next, struct nfs4_openowner, oo_perclient);\n\t\tnfs4_get_stateowner(&oo->oo_owner);\n\t\trelease_openowner(oo);\n\t}\n\tfor (i = 0; i < OWNER_HASH_SIZE; i++) {\n\t\tstruct nfs4_stateowner *so, *tmp;\n\n\t\tlist_for_each_entry_safe(so, tmp, &clp->cl_ownerstr_hashtbl[i],\n\t\t\t\t\t so_strhash) {\n\t\t\t \n\t\t\tWARN_ON_ONCE(so->so_is_open_owner);\n\t\t\tremove_blocked_locks(lockowner(so));\n\t\t}\n\t}\n\tnfsd4_return_all_client_layouts(clp);\n\tnfsd4_shutdown_copy(clp);\n\tnfsd4_shutdown_callback(clp);\n\tif (clp->cl_cb_conn.cb_xprt)\n\t\tsvc_xprt_put(clp->cl_cb_conn.cb_xprt);\n\tatomic_add_unless(&nn->nfs4_client_count, -1, 0);\n\tnfsd4_dec_courtesy_client_count(nn, clp);\n\tfree_client(clp);\n\twake_up_all(&expiry_wq);\n}\n\nstatic void\ndestroy_client(struct nfs4_client *clp)\n{\n\tunhash_client(clp);\n\t__destroy_client(clp);\n}\n\nstatic void inc_reclaim_complete(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (!nn->track_reclaim_completes)\n\t\treturn;\n\tif (!nfsd4_find_reclaim_client(clp->cl_name, nn))\n\t\treturn;\n\tif (atomic_inc_return(&nn->nr_reclaim_complete) ==\n\t\t\tnn->reclaim_str_hashtbl_size) {\n\t\tprintk(KERN_INFO \"NFSD: all clients done reclaiming, ending NFSv4 grace period (net %x)\\n\",\n\t\t\t\tclp->net->ns.inum);\n\t\tnfsd4_end_grace(nn);\n\t}\n}\n\nstatic void expire_client(struct nfs4_client *clp)\n{\n\tunhash_client(clp);\n\tnfsd4_client_record_remove(clp);\n\t__destroy_client(clp);\n}\n\nstatic void copy_verf(struct nfs4_client *target, nfs4_verifier *source)\n{\n\tmemcpy(target->cl_verifier.data, source->data,\n\t\t\tsizeof(target->cl_verifier.data));\n}\n\nstatic void copy_clid(struct nfs4_client *target, struct nfs4_client *source)\n{\n\ttarget->cl_clientid.cl_boot = source->cl_clientid.cl_boot; \n\ttarget->cl_clientid.cl_id = source->cl_clientid.cl_id; \n}\n\nstatic int copy_cred(struct svc_cred *target, struct svc_cred *source)\n{\n\ttarget->cr_principal = kstrdup(source->cr_principal, GFP_KERNEL);\n\ttarget->cr_raw_principal = kstrdup(source->cr_raw_principal,\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\ttarget->cr_targ_princ = kstrdup(source->cr_targ_princ, GFP_KERNEL);\n\tif ((source->cr_principal && !target->cr_principal) ||\n\t    (source->cr_raw_principal && !target->cr_raw_principal) ||\n\t    (source->cr_targ_princ && !target->cr_targ_princ))\n\t\treturn -ENOMEM;\n\n\ttarget->cr_flavor = source->cr_flavor;\n\ttarget->cr_uid = source->cr_uid;\n\ttarget->cr_gid = source->cr_gid;\n\ttarget->cr_group_info = source->cr_group_info;\n\tget_group_info(target->cr_group_info);\n\ttarget->cr_gss_mech = source->cr_gss_mech;\n\tif (source->cr_gss_mech)\n\t\tgss_mech_get(source->cr_gss_mech);\n\treturn 0;\n}\n\nstatic int\ncompare_blob(const struct xdr_netobj *o1, const struct xdr_netobj *o2)\n{\n\tif (o1->len < o2->len)\n\t\treturn -1;\n\tif (o1->len > o2->len)\n\t\treturn 1;\n\treturn memcmp(o1->data, o2->data, o1->len);\n}\n\nstatic int\nsame_verf(nfs4_verifier *v1, nfs4_verifier *v2)\n{\n\treturn 0 == memcmp(v1->data, v2->data, sizeof(v1->data));\n}\n\nstatic int\nsame_clid(clientid_t *cl1, clientid_t *cl2)\n{\n\treturn (cl1->cl_boot == cl2->cl_boot) && (cl1->cl_id == cl2->cl_id);\n}\n\nstatic bool groups_equal(struct group_info *g1, struct group_info *g2)\n{\n\tint i;\n\n\tif (g1->ngroups != g2->ngroups)\n\t\treturn false;\n\tfor (i=0; i<g1->ngroups; i++)\n\t\tif (!gid_eq(g1->gid[i], g2->gid[i]))\n\t\t\treturn false;\n\treturn true;\n}\n\n \nstatic bool is_gss_cred(struct svc_cred *cr)\n{\n\t \n\treturn (cr->cr_flavor > RPC_AUTH_MAXFLAVOR);\n}\n\n\nstatic bool\nsame_creds(struct svc_cred *cr1, struct svc_cred *cr2)\n{\n\tif ((is_gss_cred(cr1) != is_gss_cred(cr2))\n\t\t|| (!uid_eq(cr1->cr_uid, cr2->cr_uid))\n\t\t|| (!gid_eq(cr1->cr_gid, cr2->cr_gid))\n\t\t|| !groups_equal(cr1->cr_group_info, cr2->cr_group_info))\n\t\treturn false;\n\t \n\tif (cr1->cr_principal == cr2->cr_principal)\n\t\treturn true;\n\tif (!cr1->cr_principal || !cr2->cr_principal)\n\t\treturn false;\n\treturn 0 == strcmp(cr1->cr_principal, cr2->cr_principal);\n}\n\nstatic bool svc_rqst_integrity_protected(struct svc_rqst *rqstp)\n{\n\tstruct svc_cred *cr = &rqstp->rq_cred;\n\tu32 service;\n\n\tif (!cr->cr_gss_mech)\n\t\treturn false;\n\tservice = gss_pseudoflavor_to_service(cr->cr_gss_mech, cr->cr_flavor);\n\treturn service == RPC_GSS_SVC_INTEGRITY ||\n\t       service == RPC_GSS_SVC_PRIVACY;\n}\n\nbool nfsd4_mach_creds_match(struct nfs4_client *cl, struct svc_rqst *rqstp)\n{\n\tstruct svc_cred *cr = &rqstp->rq_cred;\n\n\tif (!cl->cl_mach_cred)\n\t\treturn true;\n\tif (cl->cl_cred.cr_gss_mech != cr->cr_gss_mech)\n\t\treturn false;\n\tif (!svc_rqst_integrity_protected(rqstp))\n\t\treturn false;\n\tif (cl->cl_cred.cr_raw_principal)\n\t\treturn 0 == strcmp(cl->cl_cred.cr_raw_principal,\n\t\t\t\t\t\tcr->cr_raw_principal);\n\tif (!cr->cr_principal)\n\t\treturn false;\n\treturn 0 == strcmp(cl->cl_cred.cr_principal, cr->cr_principal);\n}\n\nstatic void gen_confirm(struct nfs4_client *clp, struct nfsd_net *nn)\n{\n\t__be32 verf[2];\n\n\t \n\tverf[0] = (__force __be32)(u32)ktime_get_real_seconds();\n\tverf[1] = (__force __be32)nn->clverifier_counter++;\n\tmemcpy(clp->cl_confirm.data, verf, sizeof(clp->cl_confirm.data));\n}\n\nstatic void gen_clid(struct nfs4_client *clp, struct nfsd_net *nn)\n{\n\tclp->cl_clientid.cl_boot = (u32)nn->boot_time;\n\tclp->cl_clientid.cl_id = nn->clientid_counter++;\n\tgen_confirm(clp, nn);\n}\n\nstatic struct nfs4_stid *\nfind_stateid_locked(struct nfs4_client *cl, stateid_t *t)\n{\n\tstruct nfs4_stid *ret;\n\n\tret = idr_find(&cl->cl_stateids, t->si_opaque.so_id);\n\tif (!ret || !ret->sc_type)\n\t\treturn NULL;\n\treturn ret;\n}\n\nstatic struct nfs4_stid *\nfind_stateid_by_type(struct nfs4_client *cl, stateid_t *t, char typemask)\n{\n\tstruct nfs4_stid *s;\n\n\tspin_lock(&cl->cl_lock);\n\ts = find_stateid_locked(cl, t);\n\tif (s != NULL) {\n\t\tif (typemask & s->sc_type)\n\t\t\trefcount_inc(&s->sc_count);\n\t\telse\n\t\t\ts = NULL;\n\t}\n\tspin_unlock(&cl->cl_lock);\n\treturn s;\n}\n\nstatic struct nfs4_client *get_nfsdfs_clp(struct inode *inode)\n{\n\tstruct nfsdfs_client *nc;\n\tnc = get_nfsdfs_client(inode);\n\tif (!nc)\n\t\treturn NULL;\n\treturn container_of(nc, struct nfs4_client, cl_nfsdfs);\n}\n\nstatic void seq_quote_mem(struct seq_file *m, char *data, int len)\n{\n\tseq_printf(m, \"\\\"\");\n\tseq_escape_mem(m, data, len, ESCAPE_HEX | ESCAPE_NAP | ESCAPE_APPEND, \"\\\"\\\\\");\n\tseq_printf(m, \"\\\"\");\n}\n\nstatic const char *cb_state2str(int state)\n{\n\tswitch (state) {\n\tcase NFSD4_CB_UP:\n\t\treturn \"UP\";\n\tcase NFSD4_CB_UNKNOWN:\n\t\treturn \"UNKNOWN\";\n\tcase NFSD4_CB_DOWN:\n\t\treturn \"DOWN\";\n\tcase NFSD4_CB_FAULT:\n\t\treturn \"FAULT\";\n\t}\n\treturn \"UNDEFINED\";\n}\n\nstatic int client_info_show(struct seq_file *m, void *v)\n{\n\tstruct inode *inode = file_inode(m->file);\n\tstruct nfs4_client *clp;\n\tu64 clid;\n\n\tclp = get_nfsdfs_clp(inode);\n\tif (!clp)\n\t\treturn -ENXIO;\n\tmemcpy(&clid, &clp->cl_clientid, sizeof(clid));\n\tseq_printf(m, \"clientid: 0x%llx\\n\", clid);\n\tseq_printf(m, \"address: \\\"%pISpc\\\"\\n\", (struct sockaddr *)&clp->cl_addr);\n\n\tif (clp->cl_state == NFSD4_COURTESY)\n\t\tseq_puts(m, \"status: courtesy\\n\");\n\telse if (clp->cl_state == NFSD4_EXPIRABLE)\n\t\tseq_puts(m, \"status: expirable\\n\");\n\telse if (test_bit(NFSD4_CLIENT_CONFIRMED, &clp->cl_flags))\n\t\tseq_puts(m, \"status: confirmed\\n\");\n\telse\n\t\tseq_puts(m, \"status: unconfirmed\\n\");\n\tseq_printf(m, \"seconds from last renew: %lld\\n\",\n\t\tktime_get_boottime_seconds() - clp->cl_time);\n\tseq_printf(m, \"name: \");\n\tseq_quote_mem(m, clp->cl_name.data, clp->cl_name.len);\n\tseq_printf(m, \"\\nminor version: %d\\n\", clp->cl_minorversion);\n\tif (clp->cl_nii_domain.data) {\n\t\tseq_printf(m, \"Implementation domain: \");\n\t\tseq_quote_mem(m, clp->cl_nii_domain.data,\n\t\t\t\t\tclp->cl_nii_domain.len);\n\t\tseq_printf(m, \"\\nImplementation name: \");\n\t\tseq_quote_mem(m, clp->cl_nii_name.data, clp->cl_nii_name.len);\n\t\tseq_printf(m, \"\\nImplementation time: [%lld, %ld]\\n\",\n\t\t\tclp->cl_nii_time.tv_sec, clp->cl_nii_time.tv_nsec);\n\t}\n\tseq_printf(m, \"callback state: %s\\n\", cb_state2str(clp->cl_cb_state));\n\tseq_printf(m, \"callback address: %pISpc\\n\", &clp->cl_cb_conn.cb_addr);\n\tdrop_client(clp);\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(client_info);\n\nstatic void *states_start(struct seq_file *s, loff_t *pos)\n\t__acquires(&clp->cl_lock)\n{\n\tstruct nfs4_client *clp = s->private;\n\tunsigned long id = *pos;\n\tvoid *ret;\n\n\tspin_lock(&clp->cl_lock);\n\tret = idr_get_next_ul(&clp->cl_stateids, &id);\n\t*pos = id;\n\treturn ret;\n}\n\nstatic void *states_next(struct seq_file *s, void *v, loff_t *pos)\n{\n\tstruct nfs4_client *clp = s->private;\n\tunsigned long id = *pos;\n\tvoid *ret;\n\n\tid = *pos;\n\tid++;\n\tret = idr_get_next_ul(&clp->cl_stateids, &id);\n\t*pos = id;\n\treturn ret;\n}\n\nstatic void states_stop(struct seq_file *s, void *v)\n\t__releases(&clp->cl_lock)\n{\n\tstruct nfs4_client *clp = s->private;\n\n\tspin_unlock(&clp->cl_lock);\n}\n\nstatic void nfs4_show_fname(struct seq_file *s, struct nfsd_file *f)\n{\n         seq_printf(s, \"filename: \\\"%pD2\\\"\", f->nf_file);\n}\n\nstatic void nfs4_show_superblock(struct seq_file *s, struct nfsd_file *f)\n{\n\tstruct inode *inode = file_inode(f->nf_file);\n\n\tseq_printf(s, \"superblock: \\\"%02x:%02x:%ld\\\"\",\n\t\t\t\t\tMAJOR(inode->i_sb->s_dev),\n\t\t\t\t\t MINOR(inode->i_sb->s_dev),\n\t\t\t\t\t inode->i_ino);\n}\n\nstatic void nfs4_show_owner(struct seq_file *s, struct nfs4_stateowner *oo)\n{\n\tseq_printf(s, \"owner: \");\n\tseq_quote_mem(s, oo->so_owner.data, oo->so_owner.len);\n}\n\nstatic void nfs4_show_stateid(struct seq_file *s, stateid_t *stid)\n{\n\tseq_printf(s, \"0x%.8x\", stid->si_generation);\n\tseq_printf(s, \"%12phN\", &stid->si_opaque);\n}\n\nstatic int nfs4_show_open(struct seq_file *s, struct nfs4_stid *st)\n{\n\tstruct nfs4_ol_stateid *ols;\n\tstruct nfs4_file *nf;\n\tstruct nfsd_file *file;\n\tstruct nfs4_stateowner *oo;\n\tunsigned int access, deny;\n\n\tif (st->sc_type != NFS4_OPEN_STID && st->sc_type != NFS4_LOCK_STID)\n\t\treturn 0;  \n\tols = openlockstateid(st);\n\too = ols->st_stateowner;\n\tnf = st->sc_file;\n\n\tspin_lock(&nf->fi_lock);\n\tfile = find_any_file_locked(nf);\n\tif (!file)\n\t\tgoto out;\n\n\tseq_printf(s, \"- \");\n\tnfs4_show_stateid(s, &st->sc_stateid);\n\tseq_printf(s, \": { type: open, \");\n\n\taccess = bmap_to_share_mode(ols->st_access_bmap);\n\tdeny   = bmap_to_share_mode(ols->st_deny_bmap);\n\n\tseq_printf(s, \"access: %s%s, \",\n\t\taccess & NFS4_SHARE_ACCESS_READ ? \"r\" : \"-\",\n\t\taccess & NFS4_SHARE_ACCESS_WRITE ? \"w\" : \"-\");\n\tseq_printf(s, \"deny: %s%s, \",\n\t\tdeny & NFS4_SHARE_ACCESS_READ ? \"r\" : \"-\",\n\t\tdeny & NFS4_SHARE_ACCESS_WRITE ? \"w\" : \"-\");\n\n\tnfs4_show_superblock(s, file);\n\tseq_printf(s, \", \");\n\tnfs4_show_fname(s, file);\n\tseq_printf(s, \", \");\n\tnfs4_show_owner(s, oo);\n\tseq_printf(s, \" }\\n\");\nout:\n\tspin_unlock(&nf->fi_lock);\n\treturn 0;\n}\n\nstatic int nfs4_show_lock(struct seq_file *s, struct nfs4_stid *st)\n{\n\tstruct nfs4_ol_stateid *ols;\n\tstruct nfs4_file *nf;\n\tstruct nfsd_file *file;\n\tstruct nfs4_stateowner *oo;\n\n\tols = openlockstateid(st);\n\too = ols->st_stateowner;\n\tnf = st->sc_file;\n\tspin_lock(&nf->fi_lock);\n\tfile = find_any_file_locked(nf);\n\tif (!file)\n\t\tgoto out;\n\n\tseq_printf(s, \"- \");\n\tnfs4_show_stateid(s, &st->sc_stateid);\n\tseq_printf(s, \": { type: lock, \");\n\n\t \n\n\tnfs4_show_superblock(s, file);\n\t \n\tseq_printf(s, \", \");\n\tnfs4_show_fname(s, file);\n\tseq_printf(s, \", \");\n\tnfs4_show_owner(s, oo);\n\tseq_printf(s, \" }\\n\");\nout:\n\tspin_unlock(&nf->fi_lock);\n\treturn 0;\n}\n\nstatic int nfs4_show_deleg(struct seq_file *s, struct nfs4_stid *st)\n{\n\tstruct nfs4_delegation *ds;\n\tstruct nfs4_file *nf;\n\tstruct nfsd_file *file;\n\n\tds = delegstateid(st);\n\tnf = st->sc_file;\n\tspin_lock(&nf->fi_lock);\n\tfile = nf->fi_deleg_file;\n\tif (!file)\n\t\tgoto out;\n\n\tseq_printf(s, \"- \");\n\tnfs4_show_stateid(s, &st->sc_stateid);\n\tseq_printf(s, \": { type: deleg, \");\n\n\t \n\tseq_printf(s, \"access: %s, \",\n\t\tds->dl_type == NFS4_OPEN_DELEGATE_READ ? \"r\" : \"w\");\n\n\t \n\n\tnfs4_show_superblock(s, file);\n\tseq_printf(s, \", \");\n\tnfs4_show_fname(s, file);\n\tseq_printf(s, \" }\\n\");\nout:\n\tspin_unlock(&nf->fi_lock);\n\treturn 0;\n}\n\nstatic int nfs4_show_layout(struct seq_file *s, struct nfs4_stid *st)\n{\n\tstruct nfs4_layout_stateid *ls;\n\tstruct nfsd_file *file;\n\n\tls = container_of(st, struct nfs4_layout_stateid, ls_stid);\n\tfile = ls->ls_file;\n\n\tseq_printf(s, \"- \");\n\tnfs4_show_stateid(s, &st->sc_stateid);\n\tseq_printf(s, \": { type: layout, \");\n\n\t \n\n\tnfs4_show_superblock(s, file);\n\tseq_printf(s, \", \");\n\tnfs4_show_fname(s, file);\n\tseq_printf(s, \" }\\n\");\n\n\treturn 0;\n}\n\nstatic int states_show(struct seq_file *s, void *v)\n{\n\tstruct nfs4_stid *st = v;\n\n\tswitch (st->sc_type) {\n\tcase NFS4_OPEN_STID:\n\t\treturn nfs4_show_open(s, st);\n\tcase NFS4_LOCK_STID:\n\t\treturn nfs4_show_lock(s, st);\n\tcase NFS4_DELEG_STID:\n\t\treturn nfs4_show_deleg(s, st);\n\tcase NFS4_LAYOUT_STID:\n\t\treturn nfs4_show_layout(s, st);\n\tdefault:\n\t\treturn 0;  \n\t}\n\t \n}\n\nstatic struct seq_operations states_seq_ops = {\n\t.start = states_start,\n\t.next = states_next,\n\t.stop = states_stop,\n\t.show = states_show\n};\n\nstatic int client_states_open(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *s;\n\tstruct nfs4_client *clp;\n\tint ret;\n\n\tclp = get_nfsdfs_clp(inode);\n\tif (!clp)\n\t\treturn -ENXIO;\n\n\tret = seq_open(file, &states_seq_ops);\n\tif (ret)\n\t\treturn ret;\n\ts = file->private_data;\n\ts->private = clp;\n\treturn 0;\n}\n\nstatic int client_opens_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *m = file->private_data;\n\tstruct nfs4_client *clp = m->private;\n\n\t \n\tdrop_client(clp);\n\treturn seq_release(inode, file);\n}\n\nstatic const struct file_operations client_states_fops = {\n\t.open\t\t= client_states_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= client_opens_release,\n};\n\n \nstatic void force_expire_client(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\tbool already_expired;\n\n\ttrace_nfsd_clid_admin_expired(&clp->cl_clientid);\n\n\tspin_lock(&nn->client_lock);\n\tclp->cl_time = 0;\n\tspin_unlock(&nn->client_lock);\n\n\twait_event(expiry_wq, atomic_read(&clp->cl_rpc_users) == 0);\n\tspin_lock(&nn->client_lock);\n\talready_expired = list_empty(&clp->cl_lru);\n\tif (!already_expired)\n\t\tunhash_client_locked(clp);\n\tspin_unlock(&nn->client_lock);\n\n\tif (!already_expired)\n\t\texpire_client(clp);\n\telse\n\t\twait_event(expiry_wq, clp->cl_nfsd_dentry == NULL);\n}\n\nstatic ssize_t client_ctl_write(struct file *file, const char __user *buf,\n\t\t\t\t   size_t size, loff_t *pos)\n{\n\tchar *data;\n\tstruct nfs4_client *clp;\n\n\tdata = simple_transaction_get(file, buf, size);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\tif (size != 7 || 0 != memcmp(data, \"expire\\n\", 7))\n\t\treturn -EINVAL;\n\tclp = get_nfsdfs_clp(file_inode(file));\n\tif (!clp)\n\t\treturn -ENXIO;\n\tforce_expire_client(clp);\n\tdrop_client(clp);\n\treturn 7;\n}\n\nstatic const struct file_operations client_ctl_fops = {\n\t.write\t\t= client_ctl_write,\n\t.release\t= simple_transaction_release,\n};\n\nstatic const struct tree_descr client_files[] = {\n\t[0] = {\"info\", &client_info_fops, S_IRUSR},\n\t[1] = {\"states\", &client_states_fops, S_IRUSR},\n\t[2] = {\"ctl\", &client_ctl_fops, S_IWUSR},\n\t[3] = {\"\"},\n};\n\nstatic int\nnfsd4_cb_recall_any_done(struct nfsd4_callback *cb,\n\t\t\t\tstruct rpc_task *task)\n{\n\ttrace_nfsd_cb_recall_any_done(cb, task);\n\tswitch (task->tk_status) {\n\tcase -NFS4ERR_DELAY:\n\t\trpc_delay(task, 2 * HZ);\n\t\treturn 0;\n\tdefault:\n\t\treturn 1;\n\t}\n}\n\nstatic void\nnfsd4_cb_recall_any_release(struct nfsd4_callback *cb)\n{\n\tstruct nfs4_client *clp = cb->cb_clp;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tspin_lock(&nn->client_lock);\n\tclear_bit(NFSD4_CLIENT_CB_RECALL_ANY, &clp->cl_flags);\n\tput_client_renew_locked(clp);\n\tspin_unlock(&nn->client_lock);\n}\n\nstatic const struct nfsd4_callback_ops nfsd4_cb_recall_any_ops = {\n\t.done\t\t= nfsd4_cb_recall_any_done,\n\t.release\t= nfsd4_cb_recall_any_release,\n};\n\nstatic struct nfs4_client *create_client(struct xdr_netobj name,\n\t\tstruct svc_rqst *rqstp, nfs4_verifier *verf)\n{\n\tstruct nfs4_client *clp;\n\tstruct sockaddr *sa = svc_addr(rqstp);\n\tint ret;\n\tstruct net *net = SVC_NET(rqstp);\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tstruct dentry *dentries[ARRAY_SIZE(client_files)];\n\n\tclp = alloc_client(name, nn);\n\tif (clp == NULL)\n\t\treturn NULL;\n\n\tret = copy_cred(&clp->cl_cred, &rqstp->rq_cred);\n\tif (ret) {\n\t\tfree_client(clp);\n\t\treturn NULL;\n\t}\n\tgen_clid(clp, nn);\n\tkref_init(&clp->cl_nfsdfs.cl_ref);\n\tnfsd4_init_cb(&clp->cl_cb_null, clp, NULL, NFSPROC4_CLNT_CB_NULL);\n\tclp->cl_time = ktime_get_boottime_seconds();\n\tclear_bit(0, &clp->cl_cb_slot_busy);\n\tcopy_verf(clp, verf);\n\tmemcpy(&clp->cl_addr, sa, sizeof(struct sockaddr_storage));\n\tclp->cl_cb_session = NULL;\n\tclp->net = net;\n\tclp->cl_nfsd_dentry = nfsd_client_mkdir(\n\t\tnn, &clp->cl_nfsdfs,\n\t\tclp->cl_clientid.cl_id - nn->clientid_base,\n\t\tclient_files, dentries);\n\tclp->cl_nfsd_info_dentry = dentries[0];\n\tif (!clp->cl_nfsd_dentry) {\n\t\tfree_client(clp);\n\t\treturn NULL;\n\t}\n\tclp->cl_ra = kzalloc(sizeof(*clp->cl_ra), GFP_KERNEL);\n\tif (!clp->cl_ra) {\n\t\tfree_client(clp);\n\t\treturn NULL;\n\t}\n\tclp->cl_ra_time = 0;\n\tnfsd4_init_cb(&clp->cl_ra->ra_cb, clp, &nfsd4_cb_recall_any_ops,\n\t\t\tNFSPROC4_CLNT_CB_RECALL_ANY);\n\treturn clp;\n}\n\nstatic void\nadd_clp_to_name_tree(struct nfs4_client *new_clp, struct rb_root *root)\n{\n\tstruct rb_node **new = &(root->rb_node), *parent = NULL;\n\tstruct nfs4_client *clp;\n\n\twhile (*new) {\n\t\tclp = rb_entry(*new, struct nfs4_client, cl_namenode);\n\t\tparent = *new;\n\n\t\tif (compare_blob(&clp->cl_name, &new_clp->cl_name) > 0)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse\n\t\t\tnew = &((*new)->rb_right);\n\t}\n\n\trb_link_node(&new_clp->cl_namenode, parent, new);\n\trb_insert_color(&new_clp->cl_namenode, root);\n}\n\nstatic struct nfs4_client *\nfind_clp_in_name_tree(struct xdr_netobj *name, struct rb_root *root)\n{\n\tint cmp;\n\tstruct rb_node *node = root->rb_node;\n\tstruct nfs4_client *clp;\n\n\twhile (node) {\n\t\tclp = rb_entry(node, struct nfs4_client, cl_namenode);\n\t\tcmp = compare_blob(&clp->cl_name, name);\n\t\tif (cmp > 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (cmp < 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn clp;\n\t}\n\treturn NULL;\n}\n\nstatic void\nadd_to_unconfirmed(struct nfs4_client *clp)\n{\n\tunsigned int idhashval;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tclear_bit(NFSD4_CLIENT_CONFIRMED, &clp->cl_flags);\n\tadd_clp_to_name_tree(clp, &nn->unconf_name_tree);\n\tidhashval = clientid_hashval(clp->cl_clientid.cl_id);\n\tlist_add(&clp->cl_idhash, &nn->unconf_id_hashtbl[idhashval]);\n\trenew_client_locked(clp);\n}\n\nstatic void\nmove_to_confirmed(struct nfs4_client *clp)\n{\n\tunsigned int idhashval = clientid_hashval(clp->cl_clientid.cl_id);\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tlist_move(&clp->cl_idhash, &nn->conf_id_hashtbl[idhashval]);\n\trb_erase(&clp->cl_namenode, &nn->unconf_name_tree);\n\tadd_clp_to_name_tree(clp, &nn->conf_name_tree);\n\tset_bit(NFSD4_CLIENT_CONFIRMED, &clp->cl_flags);\n\ttrace_nfsd_clid_confirmed(&clp->cl_clientid);\n\trenew_client_locked(clp);\n}\n\nstatic struct nfs4_client *\nfind_client_in_id_table(struct list_head *tbl, clientid_t *clid, bool sessions)\n{\n\tstruct nfs4_client *clp;\n\tunsigned int idhashval = clientid_hashval(clid->cl_id);\n\n\tlist_for_each_entry(clp, &tbl[idhashval], cl_idhash) {\n\t\tif (same_clid(&clp->cl_clientid, clid)) {\n\t\t\tif ((bool)clp->cl_minorversion != sessions)\n\t\t\t\treturn NULL;\n\t\t\trenew_client_locked(clp);\n\t\t\treturn clp;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic struct nfs4_client *\nfind_confirmed_client(clientid_t *clid, bool sessions, struct nfsd_net *nn)\n{\n\tstruct list_head *tbl = nn->conf_id_hashtbl;\n\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_client_in_id_table(tbl, clid, sessions);\n}\n\nstatic struct nfs4_client *\nfind_unconfirmed_client(clientid_t *clid, bool sessions, struct nfsd_net *nn)\n{\n\tstruct list_head *tbl = nn->unconf_id_hashtbl;\n\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_client_in_id_table(tbl, clid, sessions);\n}\n\nstatic bool clp_used_exchangeid(struct nfs4_client *clp)\n{\n\treturn clp->cl_exchange_flags != 0;\n} \n\nstatic struct nfs4_client *\nfind_confirmed_client_by_name(struct xdr_netobj *name, struct nfsd_net *nn)\n{\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_clp_in_name_tree(name, &nn->conf_name_tree);\n}\n\nstatic struct nfs4_client *\nfind_unconfirmed_client_by_name(struct xdr_netobj *name, struct nfsd_net *nn)\n{\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_clp_in_name_tree(name, &nn->unconf_name_tree);\n}\n\nstatic void\ngen_callback(struct nfs4_client *clp, struct nfsd4_setclientid *se, struct svc_rqst *rqstp)\n{\n\tstruct nfs4_cb_conn *conn = &clp->cl_cb_conn;\n\tstruct sockaddr\t*sa = svc_addr(rqstp);\n\tu32 scopeid = rpc_get_scope_id(sa);\n\tunsigned short expected_family;\n\n\t \n\tif (se->se_callback_netid_len == 3 &&\n\t    !memcmp(se->se_callback_netid_val, \"tcp\", 3))\n\t\texpected_family = AF_INET;\n\telse if (se->se_callback_netid_len == 4 &&\n\t\t !memcmp(se->se_callback_netid_val, \"tcp6\", 4))\n\t\texpected_family = AF_INET6;\n\telse\n\t\tgoto out_err;\n\n\tconn->cb_addrlen = rpc_uaddr2sockaddr(clp->net, se->se_callback_addr_val,\n\t\t\t\t\t    se->se_callback_addr_len,\n\t\t\t\t\t    (struct sockaddr *)&conn->cb_addr,\n\t\t\t\t\t    sizeof(conn->cb_addr));\n\n\tif (!conn->cb_addrlen || conn->cb_addr.ss_family != expected_family)\n\t\tgoto out_err;\n\n\tif (conn->cb_addr.ss_family == AF_INET6)\n\t\t((struct sockaddr_in6 *)&conn->cb_addr)->sin6_scope_id = scopeid;\n\n\tconn->cb_prog = se->se_callback_prog;\n\tconn->cb_ident = se->se_callback_ident;\n\tmemcpy(&conn->cb_saddr, &rqstp->rq_daddr, rqstp->rq_daddrlen);\n\ttrace_nfsd_cb_args(clp, conn);\n\treturn;\nout_err:\n\tconn->cb_addr.ss_family = AF_UNSPEC;\n\tconn->cb_addrlen = 0;\n\ttrace_nfsd_cb_nodelegs(clp);\n\treturn;\n}\n\n \nstatic void\nnfsd4_store_cache_entry(struct nfsd4_compoundres *resp)\n{\n\tstruct xdr_buf *buf = resp->xdr->buf;\n\tstruct nfsd4_slot *slot = resp->cstate.slot;\n\tunsigned int base;\n\n\tdprintk(\"--> %s slot %p\\n\", __func__, slot);\n\n\tslot->sl_flags |= NFSD4_SLOT_INITIALIZED;\n\tslot->sl_opcnt = resp->opcnt;\n\tslot->sl_status = resp->cstate.status;\n\tfree_svc_cred(&slot->sl_cred);\n\tcopy_cred(&slot->sl_cred, &resp->rqstp->rq_cred);\n\n\tif (!nfsd4_cache_this(resp)) {\n\t\tslot->sl_flags &= ~NFSD4_SLOT_CACHED;\n\t\treturn;\n\t}\n\tslot->sl_flags |= NFSD4_SLOT_CACHED;\n\n\tbase = resp->cstate.data_offset;\n\tslot->sl_datalen = buf->len - base;\n\tif (read_bytes_from_xdr_buf(buf, base, slot->sl_data, slot->sl_datalen))\n\t\tWARN(1, \"%s: sessions DRC could not cache compound\\n\",\n\t\t     __func__);\n\treturn;\n}\n\n \nstatic __be32\nnfsd4_enc_sequence_replay(struct nfsd4_compoundargs *args,\n\t\t\t  struct nfsd4_compoundres *resp)\n{\n\tstruct nfsd4_op *op;\n\tstruct nfsd4_slot *slot = resp->cstate.slot;\n\n\t \n\top = &args->ops[resp->opcnt - 1];\n\tnfsd4_encode_operation(resp, op);\n\n\tif (slot->sl_flags & NFSD4_SLOT_CACHED)\n\t\treturn op->status;\n\tif (args->opcnt == 1) {\n\t\t \n\t\top->status = nfserr_seq_false_retry;\n\t} else {\n\t\top = &args->ops[resp->opcnt++];\n\t\top->status = nfserr_retry_uncached_rep;\n\t\tnfsd4_encode_operation(resp, op);\n\t}\n\treturn op->status;\n}\n\n \nstatic __be32\nnfsd4_replay_cache_entry(struct nfsd4_compoundres *resp,\n\t\t\t struct nfsd4_sequence *seq)\n{\n\tstruct nfsd4_slot *slot = resp->cstate.slot;\n\tstruct xdr_stream *xdr = resp->xdr;\n\t__be32 *p;\n\t__be32 status;\n\n\tdprintk(\"--> %s slot %p\\n\", __func__, slot);\n\n\tstatus = nfsd4_enc_sequence_replay(resp->rqstp->rq_argp, resp);\n\tif (status)\n\t\treturn status;\n\n\tp = xdr_reserve_space(xdr, slot->sl_datalen);\n\tif (!p) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn nfserr_serverfault;\n\t}\n\txdr_encode_opaque_fixed(p, slot->sl_data, slot->sl_datalen);\n\txdr_commit_encode(xdr);\n\n\tresp->opcnt = slot->sl_opcnt;\n\treturn slot->sl_status;\n}\n\n \nstatic void\nnfsd4_set_ex_flags(struct nfs4_client *new, struct nfsd4_exchange_id *clid)\n{\n#ifdef CONFIG_NFSD_PNFS\n\tnew->cl_exchange_flags |= EXCHGID4_FLAG_USE_PNFS_MDS;\n#else\n\tnew->cl_exchange_flags |= EXCHGID4_FLAG_USE_NON_PNFS;\n#endif\n\n\t \n\tnew->cl_exchange_flags |= EXCHGID4_FLAG_SUPP_MOVED_REFER;\n\n\t \n\tclid->flags = new->cl_exchange_flags;\n}\n\nstatic bool client_has_openowners(struct nfs4_client *clp)\n{\n\tstruct nfs4_openowner *oo;\n\n\tlist_for_each_entry(oo, &clp->cl_openowners, oo_perclient) {\n\t\tif (!list_empty(&oo->oo_owner.so_stateids))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic bool client_has_state(struct nfs4_client *clp)\n{\n\treturn client_has_openowners(clp)\n#ifdef CONFIG_NFSD_PNFS\n\t\t|| !list_empty(&clp->cl_lo_states)\n#endif\n\t\t|| !list_empty(&clp->cl_delegations)\n\t\t|| !list_empty(&clp->cl_sessions)\n\t\t|| !list_empty(&clp->async_copies);\n}\n\nstatic __be32 copy_impl_id(struct nfs4_client *clp,\n\t\t\t\tstruct nfsd4_exchange_id *exid)\n{\n\tif (!exid->nii_domain.data)\n\t\treturn 0;\n\txdr_netobj_dup(&clp->cl_nii_domain, &exid->nii_domain, GFP_KERNEL);\n\tif (!clp->cl_nii_domain.data)\n\t\treturn nfserr_jukebox;\n\txdr_netobj_dup(&clp->cl_nii_name, &exid->nii_name, GFP_KERNEL);\n\tif (!clp->cl_nii_name.data)\n\t\treturn nfserr_jukebox;\n\tclp->cl_nii_time = exid->nii_time;\n\treturn 0;\n}\n\n__be32\nnfsd4_exchange_id(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\tunion nfsd4_op_u *u)\n{\n\tstruct nfsd4_exchange_id *exid = &u->exchange_id;\n\tstruct nfs4_client *conf, *new;\n\tstruct nfs4_client *unconf = NULL;\n\t__be32 status;\n\tchar\t\t\taddr_str[INET6_ADDRSTRLEN];\n\tnfs4_verifier\t\tverf = exid->verifier;\n\tstruct sockaddr\t\t*sa = svc_addr(rqstp);\n\tbool\tupdate = exid->flags & EXCHGID4_FLAG_UPD_CONFIRMED_REC_A;\n\tstruct nfsd_net\t\t*nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\trpc_ntop(sa, addr_str, sizeof(addr_str));\n\tdprintk(\"%s rqstp=%p exid=%p clname.len=%u clname.data=%p \"\n\t\t\"ip_addr=%s flags %x, spa_how %u\\n\",\n\t\t__func__, rqstp, exid, exid->clname.len, exid->clname.data,\n\t\taddr_str, exid->flags, exid->spa_how);\n\n\tif (exid->flags & ~EXCHGID4_FLAG_MASK_A)\n\t\treturn nfserr_inval;\n\n\tnew = create_client(exid->clname, rqstp, &verf);\n\tif (new == NULL)\n\t\treturn nfserr_jukebox;\n\tstatus = copy_impl_id(new, exid);\n\tif (status)\n\t\tgoto out_nolock;\n\n\tswitch (exid->spa_how) {\n\tcase SP4_MACH_CRED:\n\t\texid->spo_must_enforce[0] = 0;\n\t\texid->spo_must_enforce[1] = (\n\t\t\t1 << (OP_BIND_CONN_TO_SESSION - 32) |\n\t\t\t1 << (OP_EXCHANGE_ID - 32) |\n\t\t\t1 << (OP_CREATE_SESSION - 32) |\n\t\t\t1 << (OP_DESTROY_SESSION - 32) |\n\t\t\t1 << (OP_DESTROY_CLIENTID - 32));\n\n\t\texid->spo_must_allow[0] &= (1 << (OP_CLOSE) |\n\t\t\t\t\t1 << (OP_OPEN_DOWNGRADE) |\n\t\t\t\t\t1 << (OP_LOCKU) |\n\t\t\t\t\t1 << (OP_DELEGRETURN));\n\n\t\texid->spo_must_allow[1] &= (\n\t\t\t\t\t1 << (OP_TEST_STATEID - 32) |\n\t\t\t\t\t1 << (OP_FREE_STATEID - 32));\n\t\tif (!svc_rqst_integrity_protected(rqstp)) {\n\t\t\tstatus = nfserr_inval;\n\t\t\tgoto out_nolock;\n\t\t}\n\t\t \n\t\tif (!new->cl_cred.cr_principal &&\n\t\t\t\t\t!new->cl_cred.cr_raw_principal) {\n\t\t\tstatus = nfserr_serverfault;\n\t\t\tgoto out_nolock;\n\t\t}\n\t\tnew->cl_mach_cred = true;\n\t\tbreak;\n\tcase SP4_NONE:\n\t\tbreak;\n\tdefault:\t\t\t\t \n\t\tWARN_ON_ONCE(1);\n\t\tfallthrough;\n\tcase SP4_SSV:\n\t\tstatus = nfserr_encr_alg_unsupp;\n\t\tgoto out_nolock;\n\t}\n\n\t \n\tspin_lock(&nn->client_lock);\n\tconf = find_confirmed_client_by_name(&exid->clname, nn);\n\tif (conf) {\n\t\tbool creds_match = same_creds(&conf->cl_cred, &rqstp->rq_cred);\n\t\tbool verfs_match = same_verf(&verf, &conf->cl_verifier);\n\n\t\tif (update) {\n\t\t\tif (!clp_used_exchangeid(conf)) {  \n\t\t\t\tstatus = nfserr_inval;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (!nfsd4_mach_creds_match(conf, rqstp)) {\n\t\t\t\tstatus = nfserr_wrong_cred;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (!creds_match) {  \n\t\t\t\tstatus = nfserr_perm;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (!verfs_match) {  \n\t\t\t\tstatus = nfserr_not_same;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t \n\t\t\texid->flags |= EXCHGID4_FLAG_CONFIRMED_R;\n\t\t\ttrace_nfsd_clid_confirmed_r(conf);\n\t\t\tgoto out_copy;\n\t\t}\n\t\tif (!creds_match) {  \n\t\t\tif (client_has_state(conf)) {\n\t\t\t\tstatus = nfserr_clid_inuse;\n\t\t\t\ttrace_nfsd_clid_cred_mismatch(conf, rqstp);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tgoto out_new;\n\t\t}\n\t\tif (verfs_match) {  \n\t\t\tconf->cl_exchange_flags |= EXCHGID4_FLAG_CONFIRMED_R;\n\t\t\ttrace_nfsd_clid_confirmed_r(conf);\n\t\t\tgoto out_copy;\n\t\t}\n\t\t \n\t\ttrace_nfsd_clid_verf_mismatch(conf, rqstp, &verf);\n\t\tconf = NULL;\n\t\tgoto out_new;\n\t}\n\n\tif (update) {  \n\t\tstatus = nfserr_noent;\n\t\tgoto out;\n\t}\n\n\tunconf = find_unconfirmed_client_by_name(&exid->clname, nn);\n\tif (unconf)  \n\t\tunhash_client_locked(unconf);\n\n\t \n\ttrace_nfsd_clid_fresh(new);\n\nout_new:\n\tif (conf) {\n\t\tstatus = mark_client_expired_locked(conf);\n\t\tif (status)\n\t\t\tgoto out;\n\t\ttrace_nfsd_clid_replaced(&conf->cl_clientid);\n\t}\n\tnew->cl_minorversion = cstate->minorversion;\n\tnew->cl_spo_must_allow.u.words[0] = exid->spo_must_allow[0];\n\tnew->cl_spo_must_allow.u.words[1] = exid->spo_must_allow[1];\n\n\tadd_to_unconfirmed(new);\n\tswap(new, conf);\nout_copy:\n\texid->clientid.cl_boot = conf->cl_clientid.cl_boot;\n\texid->clientid.cl_id = conf->cl_clientid.cl_id;\n\n\texid->seqid = conf->cl_cs_slot.sl_seqid + 1;\n\tnfsd4_set_ex_flags(conf, exid);\n\n\tdprintk(\"nfsd4_exchange_id seqid %d flags %x\\n\",\n\t\tconf->cl_cs_slot.sl_seqid, conf->cl_exchange_flags);\n\tstatus = nfs_ok;\n\nout:\n\tspin_unlock(&nn->client_lock);\nout_nolock:\n\tif (new)\n\t\texpire_client(new);\n\tif (unconf) {\n\t\ttrace_nfsd_clid_expire_unconf(&unconf->cl_clientid);\n\t\texpire_client(unconf);\n\t}\n\treturn status;\n}\n\nstatic __be32\ncheck_slot_seqid(u32 seqid, u32 slot_seqid, int slot_inuse)\n{\n\tdprintk(\"%s enter. seqid %d slot_seqid %d\\n\", __func__, seqid,\n\t\tslot_seqid);\n\n\t \n\tif (slot_inuse) {\n\t\tif (seqid == slot_seqid)\n\t\t\treturn nfserr_jukebox;\n\t\telse\n\t\t\treturn nfserr_seq_misordered;\n\t}\n\t \n\tif (likely(seqid == slot_seqid + 1))\n\t\treturn nfs_ok;\n\tif (seqid == slot_seqid)\n\t\treturn nfserr_replay_cache;\n\treturn nfserr_seq_misordered;\n}\n\n \nstatic void\nnfsd4_cache_create_session(struct nfsd4_create_session *cr_ses,\n\t\t\t   struct nfsd4_clid_slot *slot, __be32 nfserr)\n{\n\tslot->sl_status = nfserr;\n\tmemcpy(&slot->sl_cr_ses, cr_ses, sizeof(*cr_ses));\n}\n\nstatic __be32\nnfsd4_replay_create_session(struct nfsd4_create_session *cr_ses,\n\t\t\t    struct nfsd4_clid_slot *slot)\n{\n\tmemcpy(cr_ses, &slot->sl_cr_ses, sizeof(*cr_ses));\n\treturn slot->sl_status;\n}\n\n#define NFSD_MIN_REQ_HDR_SEQ_SZ\t((\\\n\t\t\t2 * 2 +   \\\n\t\t\t1 +\t  \\\n\t\t\t3 +\t  \\\n\t\t\tXDR_QUADLEN(NFS4_MAX_SESSIONID_LEN) + \\\n\t\t\t\t  \\\n\t\t\t4 ) * sizeof(__be32))\n\n#define NFSD_MIN_RESP_HDR_SEQ_SZ ((\\\n\t\t\t2 +\t \\\n\t\t\t1 +\t  \\\n\t\t\t1 +\t  \\\n\t\t\t3 +\t  \\\n\t\t\tXDR_QUADLEN(NFS4_MAX_SESSIONID_LEN) + \\\n\t\t\t\t  \\\n\t\t\t5 ) * sizeof(__be32))\n\nstatic __be32 check_forechannel_attrs(struct nfsd4_channel_attrs *ca, struct nfsd_net *nn)\n{\n\tu32 maxrpc = nn->nfsd_serv->sv_max_mesg;\n\n\tif (ca->maxreq_sz < NFSD_MIN_REQ_HDR_SEQ_SZ)\n\t\treturn nfserr_toosmall;\n\tif (ca->maxresp_sz < NFSD_MIN_RESP_HDR_SEQ_SZ)\n\t\treturn nfserr_toosmall;\n\tca->headerpadsz = 0;\n\tca->maxreq_sz = min_t(u32, ca->maxreq_sz, maxrpc);\n\tca->maxresp_sz = min_t(u32, ca->maxresp_sz, maxrpc);\n\tca->maxops = min_t(u32, ca->maxops, NFSD_MAX_OPS_PER_COMPOUND);\n\tca->maxresp_cached = min_t(u32, ca->maxresp_cached,\n\t\t\tNFSD_SLOT_CACHE_SIZE + NFSD_MIN_HDR_SEQ_SZ);\n\tca->maxreqs = min_t(u32, ca->maxreqs, NFSD_MAX_SLOTS_PER_SESSION);\n\t \n\tca->maxreqs = nfsd4_get_drc_mem(ca, nn);\n\n\treturn nfs_ok;\n}\n\n \n#define RPC_MAX_HEADER_WITH_AUTH_SYS \\\n\t(RPC_CALLHDRSIZE + 2 * (2 + UNX_CALLSLACK))\n\n#define RPC_MAX_REPHEADER_WITH_AUTH_SYS \\\n\t(RPC_REPHDRSIZE + (2 + NUL_REPLYSLACK))\n\n#define NFSD_CB_MAX_REQ_SZ\t((NFS4_enc_cb_recall_sz + \\\n\t\t\t\t RPC_MAX_HEADER_WITH_AUTH_SYS) * sizeof(__be32))\n#define NFSD_CB_MAX_RESP_SZ\t((NFS4_dec_cb_recall_sz + \\\n\t\t\t\t RPC_MAX_REPHEADER_WITH_AUTH_SYS) * \\\n\t\t\t\t sizeof(__be32))\n\nstatic __be32 check_backchannel_attrs(struct nfsd4_channel_attrs *ca)\n{\n\tca->headerpadsz = 0;\n\n\tif (ca->maxreq_sz < NFSD_CB_MAX_REQ_SZ)\n\t\treturn nfserr_toosmall;\n\tif (ca->maxresp_sz < NFSD_CB_MAX_RESP_SZ)\n\t\treturn nfserr_toosmall;\n\tca->maxresp_cached = 0;\n\tif (ca->maxops < 2)\n\t\treturn nfserr_toosmall;\n\n\treturn nfs_ok;\n}\n\nstatic __be32 nfsd4_check_cb_sec(struct nfsd4_cb_sec *cbs)\n{\n\tswitch (cbs->flavor) {\n\tcase RPC_AUTH_NULL:\n\tcase RPC_AUTH_UNIX:\n\t\treturn nfs_ok;\n\tdefault:\n\t\t \n\t\treturn nfserr_encr_alg_unsupp;\n\t}\n}\n\n__be32\nnfsd4_create_session(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate, union nfsd4_op_u *u)\n{\n\tstruct nfsd4_create_session *cr_ses = &u->create_session;\n\tstruct sockaddr *sa = svc_addr(rqstp);\n\tstruct nfs4_client *conf, *unconf;\n\tstruct nfs4_client *old = NULL;\n\tstruct nfsd4_session *new;\n\tstruct nfsd4_conn *conn;\n\tstruct nfsd4_clid_slot *cs_slot = NULL;\n\t__be32 status = 0;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tif (cr_ses->flags & ~SESSION4_FLAG_MASK_A)\n\t\treturn nfserr_inval;\n\tstatus = nfsd4_check_cb_sec(&cr_ses->cb_sec);\n\tif (status)\n\t\treturn status;\n\tstatus = check_forechannel_attrs(&cr_ses->fore_channel, nn);\n\tif (status)\n\t\treturn status;\n\tstatus = check_backchannel_attrs(&cr_ses->back_channel);\n\tif (status)\n\t\tgoto out_release_drc_mem;\n\tstatus = nfserr_jukebox;\n\tnew = alloc_session(&cr_ses->fore_channel, &cr_ses->back_channel);\n\tif (!new)\n\t\tgoto out_release_drc_mem;\n\tconn = alloc_conn_from_crses(rqstp, cr_ses);\n\tif (!conn)\n\t\tgoto out_free_session;\n\n\tspin_lock(&nn->client_lock);\n\tunconf = find_unconfirmed_client(&cr_ses->clientid, true, nn);\n\tconf = find_confirmed_client(&cr_ses->clientid, true, nn);\n\tWARN_ON_ONCE(conf && unconf);\n\n\tif (conf) {\n\t\tstatus = nfserr_wrong_cred;\n\t\tif (!nfsd4_mach_creds_match(conf, rqstp))\n\t\t\tgoto out_free_conn;\n\t\tcs_slot = &conf->cl_cs_slot;\n\t\tstatus = check_slot_seqid(cr_ses->seqid, cs_slot->sl_seqid, 0);\n\t\tif (status) {\n\t\t\tif (status == nfserr_replay_cache)\n\t\t\t\tstatus = nfsd4_replay_create_session(cr_ses, cs_slot);\n\t\t\tgoto out_free_conn;\n\t\t}\n\t} else if (unconf) {\n\t\tstatus = nfserr_clid_inuse;\n\t\tif (!same_creds(&unconf->cl_cred, &rqstp->rq_cred) ||\n\t\t    !rpc_cmp_addr(sa, (struct sockaddr *) &unconf->cl_addr)) {\n\t\t\ttrace_nfsd_clid_cred_mismatch(unconf, rqstp);\n\t\t\tgoto out_free_conn;\n\t\t}\n\t\tstatus = nfserr_wrong_cred;\n\t\tif (!nfsd4_mach_creds_match(unconf, rqstp))\n\t\t\tgoto out_free_conn;\n\t\tcs_slot = &unconf->cl_cs_slot;\n\t\tstatus = check_slot_seqid(cr_ses->seqid, cs_slot->sl_seqid, 0);\n\t\tif (status) {\n\t\t\t \n\t\t\tstatus = nfserr_seq_misordered;\n\t\t\tgoto out_free_conn;\n\t\t}\n\t\told = find_confirmed_client_by_name(&unconf->cl_name, nn);\n\t\tif (old) {\n\t\t\tstatus = mark_client_expired_locked(old);\n\t\t\tif (status) {\n\t\t\t\told = NULL;\n\t\t\t\tgoto out_free_conn;\n\t\t\t}\n\t\t\ttrace_nfsd_clid_replaced(&old->cl_clientid);\n\t\t}\n\t\tmove_to_confirmed(unconf);\n\t\tconf = unconf;\n\t} else {\n\t\tstatus = nfserr_stale_clientid;\n\t\tgoto out_free_conn;\n\t}\n\tstatus = nfs_ok;\n\t \n\tcr_ses->flags &= ~SESSION4_PERSIST;\n\t \n\tcr_ses->flags &= ~SESSION4_RDMA;\n\n\tinit_session(rqstp, new, conf, cr_ses);\n\tnfsd4_get_session_locked(new);\n\n\tmemcpy(cr_ses->sessionid.data, new->se_sessionid.data,\n\t       NFS4_MAX_SESSIONID_LEN);\n\tcs_slot->sl_seqid++;\n\tcr_ses->seqid = cs_slot->sl_seqid;\n\n\t \n\tnfsd4_cache_create_session(cr_ses, cs_slot, status);\n\tspin_unlock(&nn->client_lock);\n\tif (conf == unconf)\n\t\tfsnotify_dentry(conf->cl_nfsd_info_dentry, FS_MODIFY);\n\t \n\tnfsd4_init_conn(rqstp, conn, new);\n\tnfsd4_put_session(new);\n\tif (old)\n\t\texpire_client(old);\n\treturn status;\nout_free_conn:\n\tspin_unlock(&nn->client_lock);\n\tfree_conn(conn);\n\tif (old)\n\t\texpire_client(old);\nout_free_session:\n\t__free_session(new);\nout_release_drc_mem:\n\tnfsd4_put_drc_mem(&cr_ses->fore_channel);\n\treturn status;\n}\n\nstatic __be32 nfsd4_map_bcts_dir(u32 *dir)\n{\n\tswitch (*dir) {\n\tcase NFS4_CDFC4_FORE:\n\tcase NFS4_CDFC4_BACK:\n\t\treturn nfs_ok;\n\tcase NFS4_CDFC4_FORE_OR_BOTH:\n\tcase NFS4_CDFC4_BACK_OR_BOTH:\n\t\t*dir = NFS4_CDFC4_BOTH;\n\t\treturn nfs_ok;\n\t}\n\treturn nfserr_inval;\n}\n\n__be32 nfsd4_backchannel_ctl(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tunion nfsd4_op_u *u)\n{\n\tstruct nfsd4_backchannel_ctl *bc = &u->backchannel_ctl;\n\tstruct nfsd4_session *session = cstate->session;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\t__be32 status;\n\n\tstatus = nfsd4_check_cb_sec(&bc->bc_cb_sec);\n\tif (status)\n\t\treturn status;\n\tspin_lock(&nn->client_lock);\n\tsession->se_cb_prog = bc->bc_cb_program;\n\tsession->se_cb_sec = bc->bc_cb_sec;\n\tspin_unlock(&nn->client_lock);\n\n\tnfsd4_probe_callback(session->se_client);\n\n\treturn nfs_ok;\n}\n\nstatic struct nfsd4_conn *__nfsd4_find_conn(struct svc_xprt *xpt, struct nfsd4_session *s)\n{\n\tstruct nfsd4_conn *c;\n\n\tlist_for_each_entry(c, &s->se_conns, cn_persession) {\n\t\tif (c->cn_xprt == xpt) {\n\t\t\treturn c;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic __be32 nfsd4_match_existing_connection(struct svc_rqst *rqst,\n\t\tstruct nfsd4_session *session, u32 req, struct nfsd4_conn **conn)\n{\n\tstruct nfs4_client *clp = session->se_client;\n\tstruct svc_xprt *xpt = rqst->rq_xprt;\n\tstruct nfsd4_conn *c;\n\t__be32 status;\n\n\t \n\tspin_lock(&clp->cl_lock);\n\tc = __nfsd4_find_conn(xpt, session);\n\tif (!c)\n\t\tstatus = nfserr_noent;\n\telse if (req == c->cn_flags)\n\t\tstatus = nfs_ok;\n\telse if (req == NFS4_CDFC4_FORE_OR_BOTH &&\n\t\t\t\tc->cn_flags != NFS4_CDFC4_BACK)\n\t\tstatus = nfs_ok;\n\telse if (req == NFS4_CDFC4_BACK_OR_BOTH &&\n\t\t\t\tc->cn_flags != NFS4_CDFC4_FORE)\n\t\tstatus = nfs_ok;\n\telse\n\t\tstatus = nfserr_inval;\n\tspin_unlock(&clp->cl_lock);\n\tif (status == nfs_ok && conn)\n\t\t*conn = c;\n\treturn status;\n}\n\n__be32 nfsd4_bind_conn_to_session(struct svc_rqst *rqstp,\n\t\t     struct nfsd4_compound_state *cstate,\n\t\t     union nfsd4_op_u *u)\n{\n\tstruct nfsd4_bind_conn_to_session *bcts = &u->bind_conn_to_session;\n\t__be32 status;\n\tstruct nfsd4_conn *conn;\n\tstruct nfsd4_session *session;\n\tstruct net *net = SVC_NET(rqstp);\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (!nfsd4_last_compound_op(rqstp))\n\t\treturn nfserr_not_only_op;\n\tspin_lock(&nn->client_lock);\n\tsession = find_in_sessionid_hashtbl(&bcts->sessionid, net, &status);\n\tspin_unlock(&nn->client_lock);\n\tif (!session)\n\t\tgoto out_no_session;\n\tstatus = nfserr_wrong_cred;\n\tif (!nfsd4_mach_creds_match(session->se_client, rqstp))\n\t\tgoto out;\n\tstatus = nfsd4_match_existing_connection(rqstp, session,\n\t\t\tbcts->dir, &conn);\n\tif (status == nfs_ok) {\n\t\tif (bcts->dir == NFS4_CDFC4_FORE_OR_BOTH ||\n\t\t\t\tbcts->dir == NFS4_CDFC4_BACK)\n\t\t\tconn->cn_flags |= NFS4_CDFC4_BACK;\n\t\tnfsd4_probe_callback(session->se_client);\n\t\tgoto out;\n\t}\n\tif (status == nfserr_inval)\n\t\tgoto out;\n\tstatus = nfsd4_map_bcts_dir(&bcts->dir);\n\tif (status)\n\t\tgoto out;\n\tconn = alloc_conn(rqstp, bcts->dir);\n\tstatus = nfserr_jukebox;\n\tif (!conn)\n\t\tgoto out;\n\tnfsd4_init_conn(rqstp, conn, session);\n\tstatus = nfs_ok;\nout:\n\tnfsd4_put_session(session);\nout_no_session:\n\treturn status;\n}\n\nstatic bool nfsd4_compound_in_session(struct nfsd4_compound_state *cstate, struct nfs4_sessionid *sid)\n{\n\tif (!cstate->session)\n\t\treturn false;\n\treturn !memcmp(sid, &cstate->session->se_sessionid, sizeof(*sid));\n}\n\n__be32\nnfsd4_destroy_session(struct svc_rqst *r, struct nfsd4_compound_state *cstate,\n\t\tunion nfsd4_op_u *u)\n{\n\tstruct nfs4_sessionid *sessionid = &u->destroy_session.sessionid;\n\tstruct nfsd4_session *ses;\n\t__be32 status;\n\tint ref_held_by_me = 0;\n\tstruct net *net = SVC_NET(r);\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tstatus = nfserr_not_only_op;\n\tif (nfsd4_compound_in_session(cstate, sessionid)) {\n\t\tif (!nfsd4_last_compound_op(r))\n\t\t\tgoto out;\n\t\tref_held_by_me++;\n\t}\n\tdump_sessionid(__func__, sessionid);\n\tspin_lock(&nn->client_lock);\n\tses = find_in_sessionid_hashtbl(sessionid, net, &status);\n\tif (!ses)\n\t\tgoto out_client_lock;\n\tstatus = nfserr_wrong_cred;\n\tif (!nfsd4_mach_creds_match(ses->se_client, r))\n\t\tgoto out_put_session;\n\tstatus = mark_session_dead_locked(ses, 1 + ref_held_by_me);\n\tif (status)\n\t\tgoto out_put_session;\n\tunhash_session(ses);\n\tspin_unlock(&nn->client_lock);\n\n\tnfsd4_probe_callback_sync(ses->se_client);\n\n\tspin_lock(&nn->client_lock);\n\tstatus = nfs_ok;\nout_put_session:\n\tnfsd4_put_session_locked(ses);\nout_client_lock:\n\tspin_unlock(&nn->client_lock);\nout:\n\treturn status;\n}\n\nstatic __be32 nfsd4_sequence_check_conn(struct nfsd4_conn *new, struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd4_conn *c;\n\t__be32 status = nfs_ok;\n\tint ret;\n\n\tspin_lock(&clp->cl_lock);\n\tc = __nfsd4_find_conn(new->cn_xprt, ses);\n\tif (c)\n\t\tgoto out_free;\n\tstatus = nfserr_conn_not_bound_to_session;\n\tif (clp->cl_mach_cred)\n\t\tgoto out_free;\n\t__nfsd4_hash_conn(new, ses);\n\tspin_unlock(&clp->cl_lock);\n\tret = nfsd4_register_conn(new);\n\tif (ret)\n\t\t \n\t\tnfsd4_conn_lost(&new->cn_xpt_user);\n\treturn nfs_ok;\nout_free:\n\tspin_unlock(&clp->cl_lock);\n\tfree_conn(new);\n\treturn status;\n}\n\nstatic bool nfsd4_session_too_many_ops(struct svc_rqst *rqstp, struct nfsd4_session *session)\n{\n\tstruct nfsd4_compoundargs *args = rqstp->rq_argp;\n\n\treturn args->opcnt > session->se_fchannel.maxops;\n}\n\nstatic bool nfsd4_request_too_big(struct svc_rqst *rqstp,\n\t\t\t\t  struct nfsd4_session *session)\n{\n\tstruct xdr_buf *xb = &rqstp->rq_arg;\n\n\treturn xb->len > session->se_fchannel.maxreq_sz;\n}\n\nstatic bool replay_matches_cache(struct svc_rqst *rqstp,\n\t\t struct nfsd4_sequence *seq, struct nfsd4_slot *slot)\n{\n\tstruct nfsd4_compoundargs *argp = rqstp->rq_argp;\n\n\tif ((bool)(slot->sl_flags & NFSD4_SLOT_CACHETHIS) !=\n\t    (bool)seq->cachethis)\n\t\treturn false;\n\t \n\tif (slot->sl_opcnt < argp->opcnt && !slot->sl_status)\n\t\treturn false;\n\t \n\tif (slot->sl_opcnt > argp->opcnt)\n\t\treturn false;\n\t \n\tif (!same_creds(&rqstp->rq_cred, &slot->sl_cred))\n\t\treturn false;\n\t \n\treturn true;\n}\n\n__be32\nnfsd4_sequence(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\tunion nfsd4_op_u *u)\n{\n\tstruct nfsd4_sequence *seq = &u->sequence;\n\tstruct nfsd4_compoundres *resp = rqstp->rq_resp;\n\tstruct xdr_stream *xdr = resp->xdr;\n\tstruct nfsd4_session *session;\n\tstruct nfs4_client *clp;\n\tstruct nfsd4_slot *slot;\n\tstruct nfsd4_conn *conn;\n\t__be32 status;\n\tint buflen;\n\tstruct net *net = SVC_NET(rqstp);\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (resp->opcnt != 1)\n\t\treturn nfserr_sequence_pos;\n\n\t \n\tconn = alloc_conn(rqstp, NFS4_CDFC4_FORE);\n\tif (!conn)\n\t\treturn nfserr_jukebox;\n\n\tspin_lock(&nn->client_lock);\n\tsession = find_in_sessionid_hashtbl(&seq->sessionid, net, &status);\n\tif (!session)\n\t\tgoto out_no_session;\n\tclp = session->se_client;\n\n\tstatus = nfserr_too_many_ops;\n\tif (nfsd4_session_too_many_ops(rqstp, session))\n\t\tgoto out_put_session;\n\n\tstatus = nfserr_req_too_big;\n\tif (nfsd4_request_too_big(rqstp, session))\n\t\tgoto out_put_session;\n\n\tstatus = nfserr_badslot;\n\tif (seq->slotid >= session->se_fchannel.maxreqs)\n\t\tgoto out_put_session;\n\n\tslot = session->se_slots[seq->slotid];\n\tdprintk(\"%s: slotid %d\\n\", __func__, seq->slotid);\n\n\t \n\tseq->maxslots = session->se_fchannel.maxreqs;\n\n\tstatus = check_slot_seqid(seq->seqid, slot->sl_seqid,\n\t\t\t\t\tslot->sl_flags & NFSD4_SLOT_INUSE);\n\tif (status == nfserr_replay_cache) {\n\t\tstatus = nfserr_seq_misordered;\n\t\tif (!(slot->sl_flags & NFSD4_SLOT_INITIALIZED))\n\t\t\tgoto out_put_session;\n\t\tstatus = nfserr_seq_false_retry;\n\t\tif (!replay_matches_cache(rqstp, seq, slot))\n\t\t\tgoto out_put_session;\n\t\tcstate->slot = slot;\n\t\tcstate->session = session;\n\t\tcstate->clp = clp;\n\t\t \n\t\tstatus = nfsd4_replay_cache_entry(resp, seq);\n\t\tcstate->status = nfserr_replay_cache;\n\t\tgoto out;\n\t}\n\tif (status)\n\t\tgoto out_put_session;\n\n\tstatus = nfsd4_sequence_check_conn(conn, session);\n\tconn = NULL;\n\tif (status)\n\t\tgoto out_put_session;\n\n\tbuflen = (seq->cachethis) ?\n\t\t\tsession->se_fchannel.maxresp_cached :\n\t\t\tsession->se_fchannel.maxresp_sz;\n\tstatus = (seq->cachethis) ? nfserr_rep_too_big_to_cache :\n\t\t\t\t    nfserr_rep_too_big;\n\tif (xdr_restrict_buflen(xdr, buflen - rqstp->rq_auth_slack))\n\t\tgoto out_put_session;\n\tsvc_reserve(rqstp, buflen);\n\n\tstatus = nfs_ok;\n\t \n\tslot->sl_seqid = seq->seqid;\n\tslot->sl_flags |= NFSD4_SLOT_INUSE;\n\tif (seq->cachethis)\n\t\tslot->sl_flags |= NFSD4_SLOT_CACHETHIS;\n\telse\n\t\tslot->sl_flags &= ~NFSD4_SLOT_CACHETHIS;\n\n\tcstate->slot = slot;\n\tcstate->session = session;\n\tcstate->clp = clp;\n\nout:\n\tswitch (clp->cl_cb_state) {\n\tcase NFSD4_CB_DOWN:\n\t\tseq->status_flags = SEQ4_STATUS_CB_PATH_DOWN;\n\t\tbreak;\n\tcase NFSD4_CB_FAULT:\n\t\tseq->status_flags = SEQ4_STATUS_BACKCHANNEL_FAULT;\n\t\tbreak;\n\tdefault:\n\t\tseq->status_flags = 0;\n\t}\n\tif (!list_empty(&clp->cl_revoked))\n\t\tseq->status_flags |= SEQ4_STATUS_RECALLABLE_STATE_REVOKED;\nout_no_session:\n\tif (conn)\n\t\tfree_conn(conn);\n\tspin_unlock(&nn->client_lock);\n\treturn status;\nout_put_session:\n\tnfsd4_put_session_locked(session);\n\tgoto out_no_session;\n}\n\nvoid\nnfsd4_sequence_done(struct nfsd4_compoundres *resp)\n{\n\tstruct nfsd4_compound_state *cs = &resp->cstate;\n\n\tif (nfsd4_has_session(cs)) {\n\t\tif (cs->status != nfserr_replay_cache) {\n\t\t\tnfsd4_store_cache_entry(resp);\n\t\t\tcs->slot->sl_flags &= ~NFSD4_SLOT_INUSE;\n\t\t}\n\t\t \n\t\tnfsd4_put_session(cs->session);\n\t} else if (cs->clp)\n\t\tput_client_renew(cs->clp);\n}\n\n__be32\nnfsd4_destroy_clientid(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tunion nfsd4_op_u *u)\n{\n\tstruct nfsd4_destroy_clientid *dc = &u->destroy_clientid;\n\tstruct nfs4_client *conf, *unconf;\n\tstruct nfs4_client *clp = NULL;\n\t__be32 status = 0;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tspin_lock(&nn->client_lock);\n\tunconf = find_unconfirmed_client(&dc->clientid, true, nn);\n\tconf = find_confirmed_client(&dc->clientid, true, nn);\n\tWARN_ON_ONCE(conf && unconf);\n\n\tif (conf) {\n\t\tif (client_has_state(conf)) {\n\t\t\tstatus = nfserr_clientid_busy;\n\t\t\tgoto out;\n\t\t}\n\t\tstatus = mark_client_expired_locked(conf);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tclp = conf;\n\t} else if (unconf)\n\t\tclp = unconf;\n\telse {\n\t\tstatus = nfserr_stale_clientid;\n\t\tgoto out;\n\t}\n\tif (!nfsd4_mach_creds_match(clp, rqstp)) {\n\t\tclp = NULL;\n\t\tstatus = nfserr_wrong_cred;\n\t\tgoto out;\n\t}\n\ttrace_nfsd_clid_destroyed(&clp->cl_clientid);\n\tunhash_client_locked(clp);\nout:\n\tspin_unlock(&nn->client_lock);\n\tif (clp)\n\t\texpire_client(clp);\n\treturn status;\n}\n\n__be32\nnfsd4_reclaim_complete(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate, union nfsd4_op_u *u)\n{\n\tstruct nfsd4_reclaim_complete *rc = &u->reclaim_complete;\n\tstruct nfs4_client *clp = cstate->clp;\n\t__be32 status = 0;\n\n\tif (rc->rca_one_fs) {\n\t\tif (!cstate->current_fh.fh_dentry)\n\t\t\treturn nfserr_nofilehandle;\n\t\t \n\t\treturn nfs_ok;\n\t}\n\n\tstatus = nfserr_complete_already;\n\tif (test_and_set_bit(NFSD4_CLIENT_RECLAIM_COMPLETE, &clp->cl_flags))\n\t\tgoto out;\n\n\tstatus = nfserr_stale_clientid;\n\tif (is_client_expired(clp))\n\t\t \n\t\tgoto out;\n\n\tstatus = nfs_ok;\n\ttrace_nfsd_clid_reclaim_complete(&clp->cl_clientid);\n\tnfsd4_client_record_create(clp);\n\tinc_reclaim_complete(clp);\nout:\n\treturn status;\n}\n\n__be32\nnfsd4_setclientid(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\t  union nfsd4_op_u *u)\n{\n\tstruct nfsd4_setclientid *setclid = &u->setclientid;\n\tstruct xdr_netobj \tclname = setclid->se_name;\n\tnfs4_verifier\t\tclverifier = setclid->se_verf;\n\tstruct nfs4_client\t*conf, *new;\n\tstruct nfs4_client\t*unconf = NULL;\n\t__be32 \t\t\tstatus;\n\tstruct nfsd_net\t\t*nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tnew = create_client(clname, rqstp, &clverifier);\n\tif (new == NULL)\n\t\treturn nfserr_jukebox;\n\tspin_lock(&nn->client_lock);\n\tconf = find_confirmed_client_by_name(&clname, nn);\n\tif (conf && client_has_state(conf)) {\n\t\tstatus = nfserr_clid_inuse;\n\t\tif (clp_used_exchangeid(conf))\n\t\t\tgoto out;\n\t\tif (!same_creds(&conf->cl_cred, &rqstp->rq_cred)) {\n\t\t\ttrace_nfsd_clid_cred_mismatch(conf, rqstp);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tunconf = find_unconfirmed_client_by_name(&clname, nn);\n\tif (unconf)\n\t\tunhash_client_locked(unconf);\n\tif (conf) {\n\t\tif (same_verf(&conf->cl_verifier, &clverifier)) {\n\t\t\tcopy_clid(new, conf);\n\t\t\tgen_confirm(new, nn);\n\t\t} else\n\t\t\ttrace_nfsd_clid_verf_mismatch(conf, rqstp,\n\t\t\t\t\t\t      &clverifier);\n\t} else\n\t\ttrace_nfsd_clid_fresh(new);\n\tnew->cl_minorversion = 0;\n\tgen_callback(new, setclid, rqstp);\n\tadd_to_unconfirmed(new);\n\tsetclid->se_clientid.cl_boot = new->cl_clientid.cl_boot;\n\tsetclid->se_clientid.cl_id = new->cl_clientid.cl_id;\n\tmemcpy(setclid->se_confirm.data, new->cl_confirm.data, sizeof(setclid->se_confirm.data));\n\tnew = NULL;\n\tstatus = nfs_ok;\nout:\n\tspin_unlock(&nn->client_lock);\n\tif (new)\n\t\tfree_client(new);\n\tif (unconf) {\n\t\ttrace_nfsd_clid_expire_unconf(&unconf->cl_clientid);\n\t\texpire_client(unconf);\n\t}\n\treturn status;\n}\n\n__be32\nnfsd4_setclientid_confirm(struct svc_rqst *rqstp,\n\t\t\tstruct nfsd4_compound_state *cstate,\n\t\t\tunion nfsd4_op_u *u)\n{\n\tstruct nfsd4_setclientid_confirm *setclientid_confirm =\n\t\t\t&u->setclientid_confirm;\n\tstruct nfs4_client *conf, *unconf;\n\tstruct nfs4_client *old = NULL;\n\tnfs4_verifier confirm = setclientid_confirm->sc_confirm; \n\tclientid_t * clid = &setclientid_confirm->sc_clientid;\n\t__be32 status;\n\tstruct nfsd_net\t*nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tif (STALE_CLIENTID(clid, nn))\n\t\treturn nfserr_stale_clientid;\n\n\tspin_lock(&nn->client_lock);\n\tconf = find_confirmed_client(clid, false, nn);\n\tunconf = find_unconfirmed_client(clid, false, nn);\n\t \n\tstatus = nfserr_clid_inuse;\n\tif (unconf && !same_creds(&unconf->cl_cred, &rqstp->rq_cred)) {\n\t\ttrace_nfsd_clid_cred_mismatch(unconf, rqstp);\n\t\tgoto out;\n\t}\n\tif (conf && !same_creds(&conf->cl_cred, &rqstp->rq_cred)) {\n\t\ttrace_nfsd_clid_cred_mismatch(conf, rqstp);\n\t\tgoto out;\n\t}\n\tif (!unconf || !same_verf(&confirm, &unconf->cl_confirm)) {\n\t\tif (conf && same_verf(&confirm, &conf->cl_confirm)) {\n\t\t\tstatus = nfs_ok;\n\t\t} else\n\t\t\tstatus = nfserr_stale_clientid;\n\t\tgoto out;\n\t}\n\tstatus = nfs_ok;\n\tif (conf) {\n\t\told = unconf;\n\t\tunhash_client_locked(old);\n\t\tnfsd4_change_callback(conf, &unconf->cl_cb_conn);\n\t} else {\n\t\told = find_confirmed_client_by_name(&unconf->cl_name, nn);\n\t\tif (old) {\n\t\t\tstatus = nfserr_clid_inuse;\n\t\t\tif (client_has_state(old)\n\t\t\t\t\t&& !same_creds(&unconf->cl_cred,\n\t\t\t\t\t\t\t&old->cl_cred)) {\n\t\t\t\told = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tstatus = mark_client_expired_locked(old);\n\t\t\tif (status) {\n\t\t\t\told = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\ttrace_nfsd_clid_replaced(&old->cl_clientid);\n\t\t}\n\t\tmove_to_confirmed(unconf);\n\t\tconf = unconf;\n\t}\n\tget_client_locked(conf);\n\tspin_unlock(&nn->client_lock);\n\tif (conf == unconf)\n\t\tfsnotify_dentry(conf->cl_nfsd_info_dentry, FS_MODIFY);\n\tnfsd4_probe_callback(conf);\n\tspin_lock(&nn->client_lock);\n\tput_client_renew_locked(conf);\nout:\n\tspin_unlock(&nn->client_lock);\n\tif (old)\n\t\texpire_client(old);\n\treturn status;\n}\n\nstatic struct nfs4_file *nfsd4_alloc_file(void)\n{\n\treturn kmem_cache_alloc(file_slab, GFP_KERNEL);\n}\n\n \n\nstatic void nfsd4_file_init(const struct svc_fh *fh, struct nfs4_file *fp)\n{\n\trefcount_set(&fp->fi_ref, 1);\n\tspin_lock_init(&fp->fi_lock);\n\tINIT_LIST_HEAD(&fp->fi_stateids);\n\tINIT_LIST_HEAD(&fp->fi_delegations);\n\tINIT_LIST_HEAD(&fp->fi_clnt_odstate);\n\tfh_copy_shallow(&fp->fi_fhandle, &fh->fh_handle);\n\tfp->fi_deleg_file = NULL;\n\tfp->fi_had_conflict = false;\n\tfp->fi_share_deny = 0;\n\tmemset(fp->fi_fds, 0, sizeof(fp->fi_fds));\n\tmemset(fp->fi_access, 0, sizeof(fp->fi_access));\n\tfp->fi_aliased = false;\n\tfp->fi_inode = d_inode(fh->fh_dentry);\n#ifdef CONFIG_NFSD_PNFS\n\tINIT_LIST_HEAD(&fp->fi_lo_states);\n\tatomic_set(&fp->fi_lo_recalls, 0);\n#endif\n}\n\nvoid\nnfsd4_free_slabs(void)\n{\n\tkmem_cache_destroy(client_slab);\n\tkmem_cache_destroy(openowner_slab);\n\tkmem_cache_destroy(lockowner_slab);\n\tkmem_cache_destroy(file_slab);\n\tkmem_cache_destroy(stateid_slab);\n\tkmem_cache_destroy(deleg_slab);\n\tkmem_cache_destroy(odstate_slab);\n}\n\nint\nnfsd4_init_slabs(void)\n{\n\tclient_slab = kmem_cache_create(\"nfsd4_clients\",\n\t\t\tsizeof(struct nfs4_client), 0, 0, NULL);\n\tif (client_slab == NULL)\n\t\tgoto out;\n\topenowner_slab = kmem_cache_create(\"nfsd4_openowners\",\n\t\t\tsizeof(struct nfs4_openowner), 0, 0, NULL);\n\tif (openowner_slab == NULL)\n\t\tgoto out_free_client_slab;\n\tlockowner_slab = kmem_cache_create(\"nfsd4_lockowners\",\n\t\t\tsizeof(struct nfs4_lockowner), 0, 0, NULL);\n\tif (lockowner_slab == NULL)\n\t\tgoto out_free_openowner_slab;\n\tfile_slab = kmem_cache_create(\"nfsd4_files\",\n\t\t\tsizeof(struct nfs4_file), 0, 0, NULL);\n\tif (file_slab == NULL)\n\t\tgoto out_free_lockowner_slab;\n\tstateid_slab = kmem_cache_create(\"nfsd4_stateids\",\n\t\t\tsizeof(struct nfs4_ol_stateid), 0, 0, NULL);\n\tif (stateid_slab == NULL)\n\t\tgoto out_free_file_slab;\n\tdeleg_slab = kmem_cache_create(\"nfsd4_delegations\",\n\t\t\tsizeof(struct nfs4_delegation), 0, 0, NULL);\n\tif (deleg_slab == NULL)\n\t\tgoto out_free_stateid_slab;\n\todstate_slab = kmem_cache_create(\"nfsd4_odstate\",\n\t\t\tsizeof(struct nfs4_clnt_odstate), 0, 0, NULL);\n\tif (odstate_slab == NULL)\n\t\tgoto out_free_deleg_slab;\n\treturn 0;\n\nout_free_deleg_slab:\n\tkmem_cache_destroy(deleg_slab);\nout_free_stateid_slab:\n\tkmem_cache_destroy(stateid_slab);\nout_free_file_slab:\n\tkmem_cache_destroy(file_slab);\nout_free_lockowner_slab:\n\tkmem_cache_destroy(lockowner_slab);\nout_free_openowner_slab:\n\tkmem_cache_destroy(openowner_slab);\nout_free_client_slab:\n\tkmem_cache_destroy(client_slab);\nout:\n\treturn -ENOMEM;\n}\n\nstatic unsigned long\nnfsd4_state_shrinker_count(struct shrinker *shrink, struct shrink_control *sc)\n{\n\tint count;\n\tstruct nfsd_net *nn = container_of(shrink,\n\t\t\tstruct nfsd_net, nfsd_client_shrinker);\n\n\tcount = atomic_read(&nn->nfsd_courtesy_clients);\n\tif (!count)\n\t\tcount = atomic_long_read(&num_delegations);\n\tif (count)\n\t\tqueue_work(laundry_wq, &nn->nfsd_shrinker_work);\n\treturn (unsigned long)count;\n}\n\nstatic unsigned long\nnfsd4_state_shrinker_scan(struct shrinker *shrink, struct shrink_control *sc)\n{\n\treturn SHRINK_STOP;\n}\n\nvoid\nnfsd4_init_leases_net(struct nfsd_net *nn)\n{\n\tstruct sysinfo si;\n\tu64 max_clients;\n\n\tnn->nfsd4_lease = 90;\t \n\tnn->nfsd4_grace = 90;\n\tnn->somebody_reclaimed = false;\n\tnn->track_reclaim_completes = false;\n\tnn->clverifier_counter = get_random_u32();\n\tnn->clientid_base = get_random_u32();\n\tnn->clientid_counter = nn->clientid_base + 1;\n\tnn->s2s_cp_cl_id = nn->clientid_counter++;\n\n\tatomic_set(&nn->nfs4_client_count, 0);\n\tsi_meminfo(&si);\n\tmax_clients = (u64)si.totalram * si.mem_unit / (1024 * 1024 * 1024);\n\tmax_clients *= NFS4_CLIENTS_PER_GB;\n\tnn->nfs4_max_clients = max_t(int, max_clients, NFS4_CLIENTS_PER_GB);\n\n\tatomic_set(&nn->nfsd_courtesy_clients, 0);\n}\n\nstatic void init_nfs4_replay(struct nfs4_replay *rp)\n{\n\trp->rp_status = nfserr_serverfault;\n\trp->rp_buflen = 0;\n\trp->rp_buf = rp->rp_ibuf;\n\tmutex_init(&rp->rp_mutex);\n}\n\nstatic void nfsd4_cstate_assign_replay(struct nfsd4_compound_state *cstate,\n\t\tstruct nfs4_stateowner *so)\n{\n\tif (!nfsd4_has_session(cstate)) {\n\t\tmutex_lock(&so->so_replay.rp_mutex);\n\t\tcstate->replay_owner = nfs4_get_stateowner(so);\n\t}\n}\n\nvoid nfsd4_cstate_clear_replay(struct nfsd4_compound_state *cstate)\n{\n\tstruct nfs4_stateowner *so = cstate->replay_owner;\n\n\tif (so != NULL) {\n\t\tcstate->replay_owner = NULL;\n\t\tmutex_unlock(&so->so_replay.rp_mutex);\n\t\tnfs4_put_stateowner(so);\n\t}\n}\n\nstatic inline void *alloc_stateowner(struct kmem_cache *slab, struct xdr_netobj *owner, struct nfs4_client *clp)\n{\n\tstruct nfs4_stateowner *sop;\n\n\tsop = kmem_cache_alloc(slab, GFP_KERNEL);\n\tif (!sop)\n\t\treturn NULL;\n\n\txdr_netobj_dup(&sop->so_owner, owner, GFP_KERNEL);\n\tif (!sop->so_owner.data) {\n\t\tkmem_cache_free(slab, sop);\n\t\treturn NULL;\n\t}\n\n\tINIT_LIST_HEAD(&sop->so_stateids);\n\tsop->so_client = clp;\n\tinit_nfs4_replay(&sop->so_replay);\n\tatomic_set(&sop->so_count, 1);\n\treturn sop;\n}\n\nstatic void hash_openowner(struct nfs4_openowner *oo, struct nfs4_client *clp, unsigned int strhashval)\n{\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_add(&oo->oo_owner.so_strhash,\n\t\t &clp->cl_ownerstr_hashtbl[strhashval]);\n\tlist_add(&oo->oo_perclient, &clp->cl_openowners);\n}\n\nstatic void nfs4_unhash_openowner(struct nfs4_stateowner *so)\n{\n\tunhash_openowner_locked(openowner(so));\n}\n\nstatic void nfs4_free_openowner(struct nfs4_stateowner *so)\n{\n\tstruct nfs4_openowner *oo = openowner(so);\n\n\tkmem_cache_free(openowner_slab, oo);\n}\n\nstatic const struct nfs4_stateowner_operations openowner_ops = {\n\t.so_unhash =\tnfs4_unhash_openowner,\n\t.so_free =\tnfs4_free_openowner,\n};\n\nstatic struct nfs4_ol_stateid *\nnfsd4_find_existing_open(struct nfs4_file *fp, struct nfsd4_open *open)\n{\n\tstruct nfs4_ol_stateid *local, *ret = NULL;\n\tstruct nfs4_openowner *oo = open->op_openowner;\n\n\tlockdep_assert_held(&fp->fi_lock);\n\n\tlist_for_each_entry(local, &fp->fi_stateids, st_perfile) {\n\t\t \n\t\tif (local->st_stateowner->so_is_open_owner == 0)\n\t\t\tcontinue;\n\t\tif (local->st_stateowner != &oo->oo_owner)\n\t\t\tcontinue;\n\t\tif (local->st_stid.sc_type == NFS4_OPEN_STID) {\n\t\t\tret = local;\n\t\t\trefcount_inc(&ret->st_stid.sc_count);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic __be32\nnfsd4_verify_open_stid(struct nfs4_stid *s)\n{\n\t__be32 ret = nfs_ok;\n\n\tswitch (s->sc_type) {\n\tdefault:\n\t\tbreak;\n\tcase 0:\n\tcase NFS4_CLOSED_STID:\n\tcase NFS4_CLOSED_DELEG_STID:\n\t\tret = nfserr_bad_stateid;\n\t\tbreak;\n\tcase NFS4_REVOKED_DELEG_STID:\n\t\tret = nfserr_deleg_revoked;\n\t}\n\treturn ret;\n}\n\n \nstatic __be32\nnfsd4_lock_ol_stateid(struct nfs4_ol_stateid *stp)\n{\n\t__be32 ret;\n\n\tmutex_lock_nested(&stp->st_mutex, LOCK_STATEID_MUTEX);\n\tret = nfsd4_verify_open_stid(&stp->st_stid);\n\tif (ret != nfs_ok)\n\t\tmutex_unlock(&stp->st_mutex);\n\treturn ret;\n}\n\nstatic struct nfs4_ol_stateid *\nnfsd4_find_and_lock_existing_open(struct nfs4_file *fp, struct nfsd4_open *open)\n{\n\tstruct nfs4_ol_stateid *stp;\n\tfor (;;) {\n\t\tspin_lock(&fp->fi_lock);\n\t\tstp = nfsd4_find_existing_open(fp, open);\n\t\tspin_unlock(&fp->fi_lock);\n\t\tif (!stp || nfsd4_lock_ol_stateid(stp) == nfs_ok)\n\t\t\tbreak;\n\t\tnfs4_put_stid(&stp->st_stid);\n\t}\n\treturn stp;\n}\n\nstatic struct nfs4_openowner *\nalloc_init_open_stateowner(unsigned int strhashval, struct nfsd4_open *open,\n\t\t\t   struct nfsd4_compound_state *cstate)\n{\n\tstruct nfs4_client *clp = cstate->clp;\n\tstruct nfs4_openowner *oo, *ret;\n\n\too = alloc_stateowner(openowner_slab, &open->op_owner, clp);\n\tif (!oo)\n\t\treturn NULL;\n\too->oo_owner.so_ops = &openowner_ops;\n\too->oo_owner.so_is_open_owner = 1;\n\too->oo_owner.so_seqid = open->op_seqid;\n\too->oo_flags = 0;\n\tif (nfsd4_has_session(cstate))\n\t\too->oo_flags |= NFS4_OO_CONFIRMED;\n\too->oo_time = 0;\n\too->oo_last_closed_stid = NULL;\n\tINIT_LIST_HEAD(&oo->oo_close_lru);\n\tspin_lock(&clp->cl_lock);\n\tret = find_openstateowner_str_locked(strhashval, open, clp);\n\tif (ret == NULL) {\n\t\thash_openowner(oo, clp, strhashval);\n\t\tret = oo;\n\t} else\n\t\tnfs4_free_stateowner(&oo->oo_owner);\n\n\tspin_unlock(&clp->cl_lock);\n\treturn ret;\n}\n\nstatic struct nfs4_ol_stateid *\ninit_open_stateid(struct nfs4_file *fp, struct nfsd4_open *open)\n{\n\n\tstruct nfs4_openowner *oo = open->op_openowner;\n\tstruct nfs4_ol_stateid *retstp = NULL;\n\tstruct nfs4_ol_stateid *stp;\n\n\tstp = open->op_stp;\n\t \n\tmutex_init(&stp->st_mutex);\n\tmutex_lock_nested(&stp->st_mutex, OPEN_STATEID_MUTEX);\n\nretry:\n\tspin_lock(&oo->oo_owner.so_client->cl_lock);\n\tspin_lock(&fp->fi_lock);\n\n\tretstp = nfsd4_find_existing_open(fp, open);\n\tif (retstp)\n\t\tgoto out_unlock;\n\n\topen->op_stp = NULL;\n\trefcount_inc(&stp->st_stid.sc_count);\n\tstp->st_stid.sc_type = NFS4_OPEN_STID;\n\tINIT_LIST_HEAD(&stp->st_locks);\n\tstp->st_stateowner = nfs4_get_stateowner(&oo->oo_owner);\n\tget_nfs4_file(fp);\n\tstp->st_stid.sc_file = fp;\n\tstp->st_access_bmap = 0;\n\tstp->st_deny_bmap = 0;\n\tstp->st_openstp = NULL;\n\tlist_add(&stp->st_perstateowner, &oo->oo_owner.so_stateids);\n\tlist_add(&stp->st_perfile, &fp->fi_stateids);\n\nout_unlock:\n\tspin_unlock(&fp->fi_lock);\n\tspin_unlock(&oo->oo_owner.so_client->cl_lock);\n\tif (retstp) {\n\t\t \n\t\tif (nfsd4_lock_ol_stateid(retstp) != nfs_ok) {\n\t\t\tnfs4_put_stid(&retstp->st_stid);\n\t\t\tgoto retry;\n\t\t}\n\t\t \n\t\tmutex_unlock(&stp->st_mutex);\n\t\tstp = retstp;\n\t}\n\treturn stp;\n}\n\n \nstatic void\nmove_to_close_lru(struct nfs4_ol_stateid *s, struct net *net)\n{\n\tstruct nfs4_ol_stateid *last;\n\tstruct nfs4_openowner *oo = openowner(s->st_stateowner);\n\tstruct nfsd_net *nn = net_generic(s->st_stid.sc_client->net,\n\t\t\t\t\t\tnfsd_net_id);\n\n\tdprintk(\"NFSD: move_to_close_lru nfs4_openowner %p\\n\", oo);\n\n\t \n\twait_event(close_wq, refcount_read(&s->st_stid.sc_count) == 2);\n\n\trelease_all_access(s);\n\tif (s->st_stid.sc_file) {\n\t\tput_nfs4_file(s->st_stid.sc_file);\n\t\ts->st_stid.sc_file = NULL;\n\t}\n\n\tspin_lock(&nn->client_lock);\n\tlast = oo->oo_last_closed_stid;\n\too->oo_last_closed_stid = s;\n\tlist_move_tail(&oo->oo_close_lru, &nn->close_lru);\n\too->oo_time = ktime_get_boottime_seconds();\n\tspin_unlock(&nn->client_lock);\n\tif (last)\n\t\tnfs4_put_stid(&last->st_stid);\n}\n\nstatic noinline_for_stack struct nfs4_file *\nnfsd4_file_hash_lookup(const struct svc_fh *fhp)\n{\n\tstruct inode *inode = d_inode(fhp->fh_dentry);\n\tstruct rhlist_head *tmp, *list;\n\tstruct nfs4_file *fi;\n\n\trcu_read_lock();\n\tlist = rhltable_lookup(&nfs4_file_rhltable, &inode,\n\t\t\t       nfs4_file_rhash_params);\n\trhl_for_each_entry_rcu(fi, tmp, list, fi_rlist) {\n\t\tif (fh_match(&fi->fi_fhandle, &fhp->fh_handle)) {\n\t\t\tif (refcount_inc_not_zero(&fi->fi_ref)) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn fi;\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn NULL;\n}\n\n \nstatic noinline_for_stack struct nfs4_file *\nnfsd4_file_hash_insert(struct nfs4_file *new, const struct svc_fh *fhp)\n{\n\tstruct inode *inode = d_inode(fhp->fh_dentry);\n\tstruct rhlist_head *tmp, *list;\n\tstruct nfs4_file *ret = NULL;\n\tbool alias_found = false;\n\tstruct nfs4_file *fi;\n\tint err;\n\n\trcu_read_lock();\n\tspin_lock(&inode->i_lock);\n\n\tlist = rhltable_lookup(&nfs4_file_rhltable, &inode,\n\t\t\t       nfs4_file_rhash_params);\n\trhl_for_each_entry_rcu(fi, tmp, list, fi_rlist) {\n\t\tif (fh_match(&fi->fi_fhandle, &fhp->fh_handle)) {\n\t\t\tif (refcount_inc_not_zero(&fi->fi_ref))\n\t\t\t\tret = fi;\n\t\t} else\n\t\t\tfi->fi_aliased = alias_found = true;\n\t}\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tnfsd4_file_init(fhp, new);\n\terr = rhltable_insert(&nfs4_file_rhltable, &new->fi_rlist,\n\t\t\t      nfs4_file_rhash_params);\n\tif (err)\n\t\tgoto out_unlock;\n\n\tnew->fi_aliased = alias_found;\n\tret = new;\n\nout_unlock:\n\tspin_unlock(&inode->i_lock);\n\trcu_read_unlock();\n\treturn ret;\n}\n\nstatic noinline_for_stack void nfsd4_file_hash_remove(struct nfs4_file *fi)\n{\n\trhltable_remove(&nfs4_file_rhltable, &fi->fi_rlist,\n\t\t\tnfs4_file_rhash_params);\n}\n\n \nstatic __be32\nnfs4_share_conflict(struct svc_fh *current_fh, unsigned int deny_type)\n{\n\tstruct nfs4_file *fp;\n\t__be32 ret = nfs_ok;\n\n\tfp = nfsd4_file_hash_lookup(current_fh);\n\tif (!fp)\n\t\treturn ret;\n\n\t \n\tspin_lock(&fp->fi_lock);\n\tif (fp->fi_share_deny & deny_type)\n\t\tret = nfserr_locked;\n\tspin_unlock(&fp->fi_lock);\n\tput_nfs4_file(fp);\n\treturn ret;\n}\n\nstatic bool nfsd4_deleg_present(const struct inode *inode)\n{\n\tstruct file_lock_context *ctx = locks_inode_context(inode);\n\n\treturn ctx && !list_empty_careful(&ctx->flc_lease);\n}\n\n \nbool nfsd_wait_for_delegreturn(struct svc_rqst *rqstp, struct inode *inode)\n{\n\tlong __maybe_unused timeo;\n\n\ttimeo = wait_var_event_timeout(inode, !nfsd4_deleg_present(inode),\n\t\t\t\t       NFSD_DELEGRETURN_TIMEOUT);\n\ttrace_nfsd_delegret_wakeup(rqstp, inode, timeo);\n\treturn timeo > 0;\n}\n\nstatic void nfsd4_cb_recall_prepare(struct nfsd4_callback *cb)\n{\n\tstruct nfs4_delegation *dp = cb_to_delegation(cb);\n\tstruct nfsd_net *nn = net_generic(dp->dl_stid.sc_client->net,\n\t\t\t\t\t  nfsd_net_id);\n\n\tblock_delegations(&dp->dl_stid.sc_file->fi_fhandle);\n\n\t \n\tspin_lock(&state_lock);\n\tif (delegation_hashed(dp) && dp->dl_time == 0) {\n\t\tdp->dl_time = ktime_get_boottime_seconds();\n\t\tlist_add_tail(&dp->dl_recall_lru, &nn->del_recall_lru);\n\t}\n\tspin_unlock(&state_lock);\n}\n\nstatic int nfsd4_cb_recall_done(struct nfsd4_callback *cb,\n\t\tstruct rpc_task *task)\n{\n\tstruct nfs4_delegation *dp = cb_to_delegation(cb);\n\n\ttrace_nfsd_cb_recall_done(&dp->dl_stid.sc_stateid, task);\n\n\tif (dp->dl_stid.sc_type == NFS4_CLOSED_DELEG_STID ||\n\t    dp->dl_stid.sc_type == NFS4_REVOKED_DELEG_STID)\n\t        return 1;\n\n\tswitch (task->tk_status) {\n\tcase 0:\n\t\treturn 1;\n\tcase -NFS4ERR_DELAY:\n\t\trpc_delay(task, 2 * HZ);\n\t\treturn 0;\n\tcase -EBADHANDLE:\n\tcase -NFS4ERR_BAD_STATEID:\n\t\t \n\t\tif (dp->dl_retries--) {\n\t\t\trpc_delay(task, 2 * HZ);\n\t\t\treturn 0;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\treturn 1;\n\t}\n}\n\nstatic void nfsd4_cb_recall_release(struct nfsd4_callback *cb)\n{\n\tstruct nfs4_delegation *dp = cb_to_delegation(cb);\n\n\tnfs4_put_stid(&dp->dl_stid);\n}\n\nstatic const struct nfsd4_callback_ops nfsd4_cb_recall_ops = {\n\t.prepare\t= nfsd4_cb_recall_prepare,\n\t.done\t\t= nfsd4_cb_recall_done,\n\t.release\t= nfsd4_cb_recall_release,\n};\n\nstatic void nfsd_break_one_deleg(struct nfs4_delegation *dp)\n{\n\t \n\trefcount_inc(&dp->dl_stid.sc_count);\n\tWARN_ON_ONCE(!nfsd4_run_cb(&dp->dl_recall));\n}\n\n \nstatic bool\nnfsd_break_deleg_cb(struct file_lock *fl)\n{\n\tstruct nfs4_delegation *dp = (struct nfs4_delegation *)fl->fl_owner;\n\tstruct nfs4_file *fp = dp->dl_stid.sc_file;\n\tstruct nfs4_client *clp = dp->dl_stid.sc_client;\n\tstruct nfsd_net *nn;\n\n\ttrace_nfsd_cb_recall(&dp->dl_stid);\n\n\tdp->dl_recalled = true;\n\tatomic_inc(&clp->cl_delegs_in_recall);\n\tif (try_to_expire_client(clp)) {\n\t\tnn = net_generic(clp->net, nfsd_net_id);\n\t\tmod_delayed_work(laundry_wq, &nn->laundromat_work, 0);\n\t}\n\n\t \n\tfl->fl_break_time = 0;\n\n\tspin_lock(&fp->fi_lock);\n\tfp->fi_had_conflict = true;\n\tnfsd_break_one_deleg(dp);\n\tspin_unlock(&fp->fi_lock);\n\treturn false;\n}\n\n \nstatic bool nfsd_breaker_owns_lease(struct file_lock *fl)\n{\n\tstruct nfs4_delegation *dl = fl->fl_owner;\n\tstruct svc_rqst *rqst;\n\tstruct nfs4_client *clp;\n\n\tif (!i_am_nfsd())\n\t\treturn false;\n\trqst = kthread_data(current);\n\t \n\tif (rqst->rq_prog != NFS_PROGRAM || rqst->rq_vers < 4)\n\t\treturn false;\n\tclp = *(rqst->rq_lease_breaker);\n\treturn dl->dl_stid.sc_client == clp;\n}\n\nstatic int\nnfsd_change_deleg_cb(struct file_lock *onlist, int arg,\n\t\t     struct list_head *dispose)\n{\n\tstruct nfs4_delegation *dp = (struct nfs4_delegation *)onlist->fl_owner;\n\tstruct nfs4_client *clp = dp->dl_stid.sc_client;\n\n\tif (arg & F_UNLCK) {\n\t\tif (dp->dl_recalled)\n\t\t\tatomic_dec(&clp->cl_delegs_in_recall);\n\t\treturn lease_modify(onlist, arg, dispose);\n\t} else\n\t\treturn -EAGAIN;\n}\n\nstatic const struct lock_manager_operations nfsd_lease_mng_ops = {\n\t.lm_breaker_owns_lease = nfsd_breaker_owns_lease,\n\t.lm_break = nfsd_break_deleg_cb,\n\t.lm_change = nfsd_change_deleg_cb,\n};\n\nstatic __be32 nfsd4_check_seqid(struct nfsd4_compound_state *cstate, struct nfs4_stateowner *so, u32 seqid)\n{\n\tif (nfsd4_has_session(cstate))\n\t\treturn nfs_ok;\n\tif (seqid == so->so_seqid - 1)\n\t\treturn nfserr_replay_me;\n\tif (seqid == so->so_seqid)\n\t\treturn nfs_ok;\n\treturn nfserr_bad_seqid;\n}\n\nstatic struct nfs4_client *lookup_clientid(clientid_t *clid, bool sessions,\n\t\t\t\t\t\tstruct nfsd_net *nn)\n{\n\tstruct nfs4_client *found;\n\n\tspin_lock(&nn->client_lock);\n\tfound = find_confirmed_client(clid, sessions, nn);\n\tif (found)\n\t\tatomic_inc(&found->cl_rpc_users);\n\tspin_unlock(&nn->client_lock);\n\treturn found;\n}\n\nstatic __be32 set_client(clientid_t *clid,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd_net *nn)\n{\n\tif (cstate->clp) {\n\t\tif (!same_clid(&cstate->clp->cl_clientid, clid))\n\t\t\treturn nfserr_stale_clientid;\n\t\treturn nfs_ok;\n\t}\n\tif (STALE_CLIENTID(clid, nn))\n\t\treturn nfserr_stale_clientid;\n\t \n\tcstate->clp = lookup_clientid(clid, false, nn);\n\tif (!cstate->clp)\n\t\treturn nfserr_expired;\n\treturn nfs_ok;\n}\n\n__be32\nnfsd4_process_open1(struct nfsd4_compound_state *cstate,\n\t\t    struct nfsd4_open *open, struct nfsd_net *nn)\n{\n\tclientid_t *clientid = &open->op_clientid;\n\tstruct nfs4_client *clp = NULL;\n\tunsigned int strhashval;\n\tstruct nfs4_openowner *oo = NULL;\n\t__be32 status;\n\n\t \n\topen->op_file = nfsd4_alloc_file();\n\tif (open->op_file == NULL)\n\t\treturn nfserr_jukebox;\n\n\tstatus = set_client(clientid, cstate, nn);\n\tif (status)\n\t\treturn status;\n\tclp = cstate->clp;\n\n\tstrhashval = ownerstr_hashval(&open->op_owner);\n\too = find_openstateowner_str(strhashval, open, clp);\n\topen->op_openowner = oo;\n\tif (!oo) {\n\t\tgoto new_owner;\n\t}\n\tif (!(oo->oo_flags & NFS4_OO_CONFIRMED)) {\n\t\t \n\t\trelease_openowner(oo);\n\t\topen->op_openowner = NULL;\n\t\tgoto new_owner;\n\t}\n\tstatus = nfsd4_check_seqid(cstate, &oo->oo_owner, open->op_seqid);\n\tif (status)\n\t\treturn status;\n\tgoto alloc_stateid;\nnew_owner:\n\too = alloc_init_open_stateowner(strhashval, open, cstate);\n\tif (oo == NULL)\n\t\treturn nfserr_jukebox;\n\topen->op_openowner = oo;\nalloc_stateid:\n\topen->op_stp = nfs4_alloc_open_stateid(clp);\n\tif (!open->op_stp)\n\t\treturn nfserr_jukebox;\n\n\tif (nfsd4_has_session(cstate) &&\n\t    (cstate->current_fh.fh_export->ex_flags & NFSEXP_PNFS)) {\n\t\topen->op_odstate = alloc_clnt_odstate(clp);\n\t\tif (!open->op_odstate)\n\t\t\treturn nfserr_jukebox;\n\t}\n\n\treturn nfs_ok;\n}\n\nstatic inline __be32\nnfs4_check_delegmode(struct nfs4_delegation *dp, int flags)\n{\n\tif ((flags & WR_STATE) && (dp->dl_type == NFS4_OPEN_DELEGATE_READ))\n\t\treturn nfserr_openmode;\n\telse\n\t\treturn nfs_ok;\n}\n\nstatic int share_access_to_flags(u32 share_access)\n{\n\treturn share_access == NFS4_SHARE_ACCESS_READ ? RD_STATE : WR_STATE;\n}\n\nstatic struct nfs4_delegation *find_deleg_stateid(struct nfs4_client *cl, stateid_t *s)\n{\n\tstruct nfs4_stid *ret;\n\n\tret = find_stateid_by_type(cl, s,\n\t\t\t\tNFS4_DELEG_STID|NFS4_REVOKED_DELEG_STID);\n\tif (!ret)\n\t\treturn NULL;\n\treturn delegstateid(ret);\n}\n\nstatic bool nfsd4_is_deleg_cur(struct nfsd4_open *open)\n{\n\treturn open->op_claim_type == NFS4_OPEN_CLAIM_DELEGATE_CUR ||\n\t       open->op_claim_type == NFS4_OPEN_CLAIM_DELEG_CUR_FH;\n}\n\nstatic __be32\nnfs4_check_deleg(struct nfs4_client *cl, struct nfsd4_open *open,\n\t\tstruct nfs4_delegation **dp)\n{\n\tint flags;\n\t__be32 status = nfserr_bad_stateid;\n\tstruct nfs4_delegation *deleg;\n\n\tdeleg = find_deleg_stateid(cl, &open->op_delegate_stateid);\n\tif (deleg == NULL)\n\t\tgoto out;\n\tif (deleg->dl_stid.sc_type == NFS4_REVOKED_DELEG_STID) {\n\t\tnfs4_put_stid(&deleg->dl_stid);\n\t\tif (cl->cl_minorversion)\n\t\t\tstatus = nfserr_deleg_revoked;\n\t\tgoto out;\n\t}\n\tflags = share_access_to_flags(open->op_share_access);\n\tstatus = nfs4_check_delegmode(deleg, flags);\n\tif (status) {\n\t\tnfs4_put_stid(&deleg->dl_stid);\n\t\tgoto out;\n\t}\n\t*dp = deleg;\nout:\n\tif (!nfsd4_is_deleg_cur(open))\n\t\treturn nfs_ok;\n\tif (status)\n\t\treturn status;\n\topen->op_openowner->oo_flags |= NFS4_OO_CONFIRMED;\n\treturn nfs_ok;\n}\n\nstatic inline int nfs4_access_to_access(u32 nfs4_access)\n{\n\tint flags = 0;\n\n\tif (nfs4_access & NFS4_SHARE_ACCESS_READ)\n\t\tflags |= NFSD_MAY_READ;\n\tif (nfs4_access & NFS4_SHARE_ACCESS_WRITE)\n\t\tflags |= NFSD_MAY_WRITE;\n\treturn flags;\n}\n\nstatic inline __be32\nnfsd4_truncate(struct svc_rqst *rqstp, struct svc_fh *fh,\n\t\tstruct nfsd4_open *open)\n{\n\tstruct iattr iattr = {\n\t\t.ia_valid = ATTR_SIZE,\n\t\t.ia_size = 0,\n\t};\n\tstruct nfsd_attrs attrs = {\n\t\t.na_iattr\t= &iattr,\n\t};\n\tif (!open->op_truncate)\n\t\treturn 0;\n\tif (!(open->op_share_access & NFS4_SHARE_ACCESS_WRITE))\n\t\treturn nfserr_inval;\n\treturn nfsd_setattr(rqstp, fh, &attrs, 0, (time64_t)0);\n}\n\nstatic __be32 nfs4_get_vfs_file(struct svc_rqst *rqstp, struct nfs4_file *fp,\n\t\tstruct svc_fh *cur_fh, struct nfs4_ol_stateid *stp,\n\t\tstruct nfsd4_open *open, bool new_stp)\n{\n\tstruct nfsd_file *nf = NULL;\n\t__be32 status;\n\tint oflag = nfs4_access_to_omode(open->op_share_access);\n\tint access = nfs4_access_to_access(open->op_share_access);\n\tunsigned char old_access_bmap, old_deny_bmap;\n\n\tspin_lock(&fp->fi_lock);\n\n\t \n\tstatus = nfs4_file_check_deny(fp, open->op_share_deny);\n\tif (status != nfs_ok) {\n\t\tif (status != nfserr_share_denied) {\n\t\t\tspin_unlock(&fp->fi_lock);\n\t\t\tgoto out;\n\t\t}\n\t\tif (nfs4_resolve_deny_conflicts_locked(fp, new_stp,\n\t\t\t\tstp, open->op_share_deny, false))\n\t\t\tstatus = nfserr_jukebox;\n\t\tspin_unlock(&fp->fi_lock);\n\t\tgoto out;\n\t}\n\n\t \n\tstatus = nfs4_file_get_access(fp, open->op_share_access);\n\tif (status != nfs_ok) {\n\t\tif (status != nfserr_share_denied) {\n\t\t\tspin_unlock(&fp->fi_lock);\n\t\t\tgoto out;\n\t\t}\n\t\tif (nfs4_resolve_deny_conflicts_locked(fp, new_stp,\n\t\t\t\tstp, open->op_share_access, true))\n\t\t\tstatus = nfserr_jukebox;\n\t\tspin_unlock(&fp->fi_lock);\n\t\tgoto out;\n\t}\n\n\t \n\told_access_bmap = stp->st_access_bmap;\n\tset_access(open->op_share_access, stp);\n\n\t \n\told_deny_bmap = stp->st_deny_bmap;\n\tset_deny(open->op_share_deny, stp);\n\tfp->fi_share_deny |= (open->op_share_deny & NFS4_SHARE_DENY_BOTH);\n\n\tif (!fp->fi_fds[oflag]) {\n\t\tspin_unlock(&fp->fi_lock);\n\n\t\tstatus = nfsd_file_acquire_opened(rqstp, cur_fh, access,\n\t\t\t\t\t\t  open->op_filp, &nf);\n\t\tif (status != nfs_ok)\n\t\t\tgoto out_put_access;\n\n\t\tspin_lock(&fp->fi_lock);\n\t\tif (!fp->fi_fds[oflag]) {\n\t\t\tfp->fi_fds[oflag] = nf;\n\t\t\tnf = NULL;\n\t\t}\n\t}\n\tspin_unlock(&fp->fi_lock);\n\tif (nf)\n\t\tnfsd_file_put(nf);\n\n\tstatus = nfserrno(nfsd_open_break_lease(cur_fh->fh_dentry->d_inode,\n\t\t\t\t\t\t\t\taccess));\n\tif (status)\n\t\tgoto out_put_access;\n\n\tstatus = nfsd4_truncate(rqstp, cur_fh, open);\n\tif (status)\n\t\tgoto out_put_access;\nout:\n\treturn status;\nout_put_access:\n\tstp->st_access_bmap = old_access_bmap;\n\tnfs4_file_put_access(fp, open->op_share_access);\n\treset_union_bmap_deny(bmap_to_share_mode(old_deny_bmap), stp);\n\tgoto out;\n}\n\nstatic __be32\nnfs4_upgrade_open(struct svc_rqst *rqstp, struct nfs4_file *fp,\n\t\tstruct svc_fh *cur_fh, struct nfs4_ol_stateid *stp,\n\t\tstruct nfsd4_open *open)\n{\n\t__be32 status;\n\tunsigned char old_deny_bmap = stp->st_deny_bmap;\n\n\tif (!test_access(open->op_share_access, stp))\n\t\treturn nfs4_get_vfs_file(rqstp, fp, cur_fh, stp, open, false);\n\n\t \n\tspin_lock(&fp->fi_lock);\n\tstatus = nfs4_file_check_deny(fp, open->op_share_deny);\n\tswitch (status) {\n\tcase nfs_ok:\n\t\tset_deny(open->op_share_deny, stp);\n\t\tfp->fi_share_deny |=\n\t\t\t(open->op_share_deny & NFS4_SHARE_DENY_BOTH);\n\t\tbreak;\n\tcase nfserr_share_denied:\n\t\tif (nfs4_resolve_deny_conflicts_locked(fp, false,\n\t\t\t\tstp, open->op_share_deny, false))\n\t\t\tstatus = nfserr_jukebox;\n\t\tbreak;\n\t}\n\tspin_unlock(&fp->fi_lock);\n\n\tif (status != nfs_ok)\n\t\treturn status;\n\n\tstatus = nfsd4_truncate(rqstp, cur_fh, open);\n\tif (status != nfs_ok)\n\t\treset_union_bmap_deny(old_deny_bmap, stp);\n\treturn status;\n}\n\n \nstatic bool nfsd4_cb_channel_good(struct nfs4_client *clp)\n{\n\tif (clp->cl_cb_state == NFSD4_CB_UP)\n\t\treturn true;\n\t \n\treturn clp->cl_minorversion && clp->cl_cb_state == NFSD4_CB_UNKNOWN;\n}\n\nstatic struct file_lock *nfs4_alloc_init_lease(struct nfs4_delegation *dp,\n\t\t\t\t\t\tint flag)\n{\n\tstruct file_lock *fl;\n\n\tfl = locks_alloc_lock();\n\tif (!fl)\n\t\treturn NULL;\n\tfl->fl_lmops = &nfsd_lease_mng_ops;\n\tfl->fl_flags = FL_DELEG;\n\tfl->fl_type = flag == NFS4_OPEN_DELEGATE_READ? F_RDLCK: F_WRLCK;\n\tfl->fl_end = OFFSET_MAX;\n\tfl->fl_owner = (fl_owner_t)dp;\n\tfl->fl_pid = current->tgid;\n\tfl->fl_file = dp->dl_stid.sc_file->fi_deleg_file->nf_file;\n\treturn fl;\n}\n\nstatic int nfsd4_check_conflicting_opens(struct nfs4_client *clp,\n\t\t\t\t\t struct nfs4_file *fp)\n{\n\tstruct nfs4_ol_stateid *st;\n\tstruct file *f = fp->fi_deleg_file->nf_file;\n\tstruct inode *ino = file_inode(f);\n\tint writes;\n\n\twrites = atomic_read(&ino->i_writecount);\n\tif (!writes)\n\t\treturn 0;\n\t \n\tif (fp->fi_aliased)\n\t\treturn -EAGAIN;\n\t \n\tsmp_mb__after_atomic();\n\n\tif (fp->fi_fds[O_WRONLY])\n\t\twrites--;\n\tif (fp->fi_fds[O_RDWR])\n\t\twrites--;\n\tif (writes > 0)\n\t\treturn -EAGAIN;  \n\t \n\tspin_lock(&fp->fi_lock);\n\tlist_for_each_entry(st, &fp->fi_stateids, st_perfile) {\n\t\tif (st->st_openstp == NULL   &&\n\t\t    access_permit_write(st) &&\n\t\t    st->st_stid.sc_client != clp) {\n\t\t\tspin_unlock(&fp->fi_lock);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t}\n\tspin_unlock(&fp->fi_lock);\n\t \n\treturn 0;\n}\n\n \nstatic int\nnfsd4_verify_deleg_dentry(struct nfsd4_open *open, struct nfs4_file *fp,\n\t\t\t  struct svc_fh *parent)\n{\n\tstruct svc_export *exp;\n\tstruct dentry *child;\n\t__be32 err;\n\n\terr = nfsd_lookup_dentry(open->op_rqstp, parent,\n\t\t\t\t open->op_fname, open->op_fnamelen,\n\t\t\t\t &exp, &child);\n\n\tif (err)\n\t\treturn -EAGAIN;\n\n\texp_put(exp);\n\tdput(child);\n\tif (child != file_dentry(fp->fi_deleg_file->nf_file))\n\t\treturn -EAGAIN;\n\n\treturn 0;\n}\n\n \nstatic int\nnfsd4_verify_setuid_write(struct nfsd4_open *open, struct nfsd_file *nf)\n{\n\tstruct inode *inode = file_inode(nf->nf_file);\n\n\tif ((open->op_share_access & NFS4_SHARE_ACCESS_WRITE) &&\n\t    (inode->i_mode & (S_ISUID|S_ISGID)))\n\t\treturn -EAGAIN;\n\treturn 0;\n}\n\nstatic struct nfs4_delegation *\nnfs4_set_delegation(struct nfsd4_open *open, struct nfs4_ol_stateid *stp,\n\t\t    struct svc_fh *parent)\n{\n\tint status = 0;\n\tstruct nfs4_client *clp = stp->st_stid.sc_client;\n\tstruct nfs4_file *fp = stp->st_stid.sc_file;\n\tstruct nfs4_clnt_odstate *odstate = stp->st_clnt_odstate;\n\tstruct nfs4_delegation *dp;\n\tstruct nfsd_file *nf = NULL;\n\tstruct file_lock *fl;\n\tu32 dl_type;\n\n\t \n\tif (fp->fi_had_conflict)\n\t\treturn ERR_PTR(-EAGAIN);\n\n\t \n\tif ((open->op_share_access & NFS4_SHARE_ACCESS_BOTH) == NFS4_SHARE_ACCESS_BOTH) {\n\t\tnf = find_rw_file(fp);\n\t\tdl_type = NFS4_OPEN_DELEGATE_WRITE;\n\t}\n\n\t \n\tif (!nf && (open->op_share_access & NFS4_SHARE_ACCESS_READ)) {\n\t\tnf = find_readable_file(fp);\n\t\tdl_type = NFS4_OPEN_DELEGATE_READ;\n\t}\n\n\tif (!nf)\n\t\treturn ERR_PTR(-EAGAIN);\n\n\tspin_lock(&state_lock);\n\tspin_lock(&fp->fi_lock);\n\tif (nfs4_delegation_exists(clp, fp))\n\t\tstatus = -EAGAIN;\n\telse if (nfsd4_verify_setuid_write(open, nf))\n\t\tstatus = -EAGAIN;\n\telse if (!fp->fi_deleg_file) {\n\t\tfp->fi_deleg_file = nf;\n\t\t \n\t\tfp->fi_delegees = 1;\n\t\tnf = NULL;\n\t} else\n\t\tfp->fi_delegees++;\n\tspin_unlock(&fp->fi_lock);\n\tspin_unlock(&state_lock);\n\tif (nf)\n\t\tnfsd_file_put(nf);\n\tif (status)\n\t\treturn ERR_PTR(status);\n\n\tstatus = -ENOMEM;\n\tdp = alloc_init_deleg(clp, fp, odstate, dl_type);\n\tif (!dp)\n\t\tgoto out_delegees;\n\n\tfl = nfs4_alloc_init_lease(dp, dl_type);\n\tif (!fl)\n\t\tgoto out_clnt_odstate;\n\n\tstatus = vfs_setlease(fp->fi_deleg_file->nf_file, fl->fl_type, &fl, NULL);\n\tif (fl)\n\t\tlocks_free_lock(fl);\n\tif (status)\n\t\tgoto out_clnt_odstate;\n\n\tif (parent) {\n\t\tstatus = nfsd4_verify_deleg_dentry(open, fp, parent);\n\t\tif (status)\n\t\t\tgoto out_unlock;\n\t}\n\n\tstatus = nfsd4_check_conflicting_opens(clp, fp);\n\tif (status)\n\t\tgoto out_unlock;\n\n\t \n\tstatus = nfsd4_verify_setuid_write(open, fp->fi_deleg_file);\n\tif (status)\n\t\tgoto out_unlock;\n\n\tspin_lock(&state_lock);\n\tspin_lock(&fp->fi_lock);\n\tif (fp->fi_had_conflict)\n\t\tstatus = -EAGAIN;\n\telse\n\t\tstatus = hash_delegation_locked(dp, fp);\n\tspin_unlock(&fp->fi_lock);\n\tspin_unlock(&state_lock);\n\n\tif (status)\n\t\tgoto out_unlock;\n\n\treturn dp;\nout_unlock:\n\tvfs_setlease(fp->fi_deleg_file->nf_file, F_UNLCK, NULL, (void **)&dp);\nout_clnt_odstate:\n\tput_clnt_odstate(dp->dl_clnt_odstate);\n\tnfs4_put_stid(&dp->dl_stid);\nout_delegees:\n\tput_deleg_file(fp);\n\treturn ERR_PTR(status);\n}\n\nstatic void nfsd4_open_deleg_none_ext(struct nfsd4_open *open, int status)\n{\n\topen->op_delegate_type = NFS4_OPEN_DELEGATE_NONE_EXT;\n\tif (status == -EAGAIN)\n\t\topen->op_why_no_deleg = WND4_CONTENTION;\n\telse {\n\t\topen->op_why_no_deleg = WND4_RESOURCE;\n\t\tswitch (open->op_deleg_want) {\n\t\tcase NFS4_SHARE_WANT_READ_DELEG:\n\t\tcase NFS4_SHARE_WANT_WRITE_DELEG:\n\t\tcase NFS4_SHARE_WANT_ANY_DELEG:\n\t\t\tbreak;\n\t\tcase NFS4_SHARE_WANT_CANCEL:\n\t\t\topen->op_why_no_deleg = WND4_CANCELLED;\n\t\t\tbreak;\n\t\tcase NFS4_SHARE_WANT_NO_DELEG:\n\t\t\tWARN_ON_ONCE(1);\n\t\t}\n\t}\n}\n\n \nstatic void\nnfs4_open_delegation(struct nfsd4_open *open, struct nfs4_ol_stateid *stp,\n\t\t     struct svc_fh *currentfh)\n{\n\tstruct nfs4_delegation *dp;\n\tstruct nfs4_openowner *oo = openowner(stp->st_stateowner);\n\tstruct nfs4_client *clp = stp->st_stid.sc_client;\n\tstruct svc_fh *parent = NULL;\n\tint cb_up;\n\tint status = 0;\n\n\tcb_up = nfsd4_cb_channel_good(oo->oo_owner.so_client);\n\topen->op_recall = 0;\n\tswitch (open->op_claim_type) {\n\t\tcase NFS4_OPEN_CLAIM_PREVIOUS:\n\t\t\tif (!cb_up)\n\t\t\t\topen->op_recall = 1;\n\t\t\tbreak;\n\t\tcase NFS4_OPEN_CLAIM_NULL:\n\t\t\tparent = currentfh;\n\t\t\tfallthrough;\n\t\tcase NFS4_OPEN_CLAIM_FH:\n\t\t\t \n\t\t\tif (locks_in_grace(clp->net))\n\t\t\t\tgoto out_no_deleg;\n\t\t\tif (!cb_up || !(oo->oo_flags & NFS4_OO_CONFIRMED))\n\t\t\t\tgoto out_no_deleg;\n\t\t\tif (open->op_share_access & NFS4_SHARE_ACCESS_WRITE &&\n\t\t\t\t\t!clp->cl_minorversion)\n\t\t\t\tgoto out_no_deleg;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto out_no_deleg;\n\t}\n\tdp = nfs4_set_delegation(open, stp, parent);\n\tif (IS_ERR(dp))\n\t\tgoto out_no_deleg;\n\n\tmemcpy(&open->op_delegate_stateid, &dp->dl_stid.sc_stateid, sizeof(dp->dl_stid.sc_stateid));\n\n\tif (open->op_share_access & NFS4_SHARE_ACCESS_WRITE) {\n\t\topen->op_delegate_type = NFS4_OPEN_DELEGATE_WRITE;\n\t\ttrace_nfsd_deleg_write(&dp->dl_stid.sc_stateid);\n\t} else {\n\t\topen->op_delegate_type = NFS4_OPEN_DELEGATE_READ;\n\t\ttrace_nfsd_deleg_read(&dp->dl_stid.sc_stateid);\n\t}\n\tnfs4_put_stid(&dp->dl_stid);\n\treturn;\nout_no_deleg:\n\topen->op_delegate_type = NFS4_OPEN_DELEGATE_NONE;\n\tif (open->op_claim_type == NFS4_OPEN_CLAIM_PREVIOUS &&\n\t    open->op_delegate_type != NFS4_OPEN_DELEGATE_NONE) {\n\t\tdprintk(\"NFSD: WARNING: refusing delegation reclaim\\n\");\n\t\topen->op_recall = 1;\n\t}\n\n\t \n\tif (open->op_deleg_want)\n\t\tnfsd4_open_deleg_none_ext(open, status);\n\treturn;\n}\n\nstatic void nfsd4_deleg_xgrade_none_ext(struct nfsd4_open *open,\n\t\t\t\t\tstruct nfs4_delegation *dp)\n{\n\tif (open->op_deleg_want == NFS4_SHARE_WANT_READ_DELEG &&\n\t    dp->dl_type == NFS4_OPEN_DELEGATE_WRITE) {\n\t\topen->op_delegate_type = NFS4_OPEN_DELEGATE_NONE_EXT;\n\t\topen->op_why_no_deleg = WND4_NOT_SUPP_DOWNGRADE;\n\t} else if (open->op_deleg_want == NFS4_SHARE_WANT_WRITE_DELEG &&\n\t\t   dp->dl_type == NFS4_OPEN_DELEGATE_WRITE) {\n\t\topen->op_delegate_type = NFS4_OPEN_DELEGATE_NONE_EXT;\n\t\topen->op_why_no_deleg = WND4_NOT_SUPP_UPGRADE;\n\t}\n\t \n}\n\n \n__be32\nnfsd4_process_open2(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nfsd4_open *open)\n{\n\tstruct nfsd4_compoundres *resp = rqstp->rq_resp;\n\tstruct nfs4_client *cl = open->op_openowner->oo_owner.so_client;\n\tstruct nfs4_file *fp = NULL;\n\tstruct nfs4_ol_stateid *stp = NULL;\n\tstruct nfs4_delegation *dp = NULL;\n\t__be32 status;\n\tbool new_stp = false;\n\n\t \n\tfp = nfsd4_file_hash_insert(open->op_file, current_fh);\n\tif (unlikely(!fp))\n\t\treturn nfserr_jukebox;\n\tif (fp != open->op_file) {\n\t\tstatus = nfs4_check_deleg(cl, open, &dp);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tstp = nfsd4_find_and_lock_existing_open(fp, open);\n\t} else {\n\t\topen->op_file = NULL;\n\t\tstatus = nfserr_bad_stateid;\n\t\tif (nfsd4_is_deleg_cur(open))\n\t\t\tgoto out;\n\t}\n\n\tif (!stp) {\n\t\tstp = init_open_stateid(fp, open);\n\t\tif (!open->op_stp)\n\t\t\tnew_stp = true;\n\t}\n\n\t \n\tif (!new_stp) {\n\t\t \n\t\tstatus = nfs4_upgrade_open(rqstp, fp, current_fh, stp, open);\n\t\tif (status) {\n\t\t\tmutex_unlock(&stp->st_mutex);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tstatus = nfs4_get_vfs_file(rqstp, fp, current_fh, stp, open, true);\n\t\tif (status) {\n\t\t\tstp->st_stid.sc_type = NFS4_CLOSED_STID;\n\t\t\trelease_open_stateid(stp);\n\t\t\tmutex_unlock(&stp->st_mutex);\n\t\t\tgoto out;\n\t\t}\n\n\t\tstp->st_clnt_odstate = find_or_hash_clnt_odstate(fp,\n\t\t\t\t\t\t\topen->op_odstate);\n\t\tif (stp->st_clnt_odstate == open->op_odstate)\n\t\t\topen->op_odstate = NULL;\n\t}\n\n\tnfs4_inc_and_copy_stateid(&open->op_stateid, &stp->st_stid);\n\tmutex_unlock(&stp->st_mutex);\n\n\tif (nfsd4_has_session(&resp->cstate)) {\n\t\tif (open->op_deleg_want & NFS4_SHARE_WANT_NO_DELEG) {\n\t\t\topen->op_delegate_type = NFS4_OPEN_DELEGATE_NONE_EXT;\n\t\t\topen->op_why_no_deleg = WND4_NOT_WANTED;\n\t\t\tgoto nodeleg;\n\t\t}\n\t}\n\n\t \n\tnfs4_open_delegation(open, stp, &resp->cstate.current_fh);\nnodeleg:\n\tstatus = nfs_ok;\n\ttrace_nfsd_open(&stp->st_stid.sc_stateid);\nout:\n\t \n\tif (open->op_delegate_type == NFS4_OPEN_DELEGATE_NONE && dp &&\n\t    open->op_deleg_want)\n\t\tnfsd4_deleg_xgrade_none_ext(open, dp);\n\n\tif (fp)\n\t\tput_nfs4_file(fp);\n\tif (status == 0 && open->op_claim_type == NFS4_OPEN_CLAIM_PREVIOUS)\n\t\topen->op_openowner->oo_flags |= NFS4_OO_CONFIRMED;\n\t \n\topen->op_rflags = NFS4_OPEN_RESULT_LOCKTYPE_POSIX;\n\tif (nfsd4_has_session(&resp->cstate))\n\t\topen->op_rflags |= NFS4_OPEN_RESULT_MAY_NOTIFY_LOCK;\n\telse if (!(open->op_openowner->oo_flags & NFS4_OO_CONFIRMED))\n\t\topen->op_rflags |= NFS4_OPEN_RESULT_CONFIRM;\n\n\tif (dp)\n\t\tnfs4_put_stid(&dp->dl_stid);\n\tif (stp)\n\t\tnfs4_put_stid(&stp->st_stid);\n\n\treturn status;\n}\n\nvoid nfsd4_cleanup_open_state(struct nfsd4_compound_state *cstate,\n\t\t\t      struct nfsd4_open *open)\n{\n\tif (open->op_openowner) {\n\t\tstruct nfs4_stateowner *so = &open->op_openowner->oo_owner;\n\n\t\tnfsd4_cstate_assign_replay(cstate, so);\n\t\tnfs4_put_stateowner(so);\n\t}\n\tif (open->op_file)\n\t\tkmem_cache_free(file_slab, open->op_file);\n\tif (open->op_stp)\n\t\tnfs4_put_stid(&open->op_stp->st_stid);\n\tif (open->op_odstate)\n\t\tkmem_cache_free(odstate_slab, open->op_odstate);\n}\n\n__be32\nnfsd4_renew(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t    union nfsd4_op_u *u)\n{\n\tclientid_t *clid = &u->renew;\n\tstruct nfs4_client *clp;\n\t__be32 status;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\ttrace_nfsd_clid_renew(clid);\n\tstatus = set_client(clid, cstate, nn);\n\tif (status)\n\t\treturn status;\n\tclp = cstate->clp;\n\tif (!list_empty(&clp->cl_delegations)\n\t\t\t&& clp->cl_cb_state != NFSD4_CB_UP)\n\t\treturn nfserr_cb_path_down;\n\treturn nfs_ok;\n}\n\nvoid\nnfsd4_end_grace(struct nfsd_net *nn)\n{\n\t \n\tif (nn->grace_ended)\n\t\treturn;\n\n\ttrace_nfsd_grace_complete(nn);\n\tnn->grace_ended = true;\n\t \n\tnfsd4_record_grace_done(nn);\n\t \n\tlocks_end_grace(&nn->nfsd4_manager);\n\t \n}\n\n \nstatic bool clients_still_reclaiming(struct nfsd_net *nn)\n{\n\ttime64_t double_grace_period_end = nn->boot_time +\n\t\t\t\t\t   2 * nn->nfsd4_lease;\n\n\tif (nn->track_reclaim_completes &&\n\t\t\tatomic_read(&nn->nr_reclaim_complete) ==\n\t\t\tnn->reclaim_str_hashtbl_size)\n\t\treturn false;\n\tif (!nn->somebody_reclaimed)\n\t\treturn false;\n\tnn->somebody_reclaimed = false;\n\t \n\tif (ktime_get_boottime_seconds() > double_grace_period_end)\n\t\treturn false;\n\treturn true;\n}\n\nstruct laundry_time {\n\ttime64_t cutoff;\n\ttime64_t new_timeo;\n};\n\nstatic bool state_expired(struct laundry_time *lt, time64_t last_refresh)\n{\n\ttime64_t time_remaining;\n\n\tif (last_refresh < lt->cutoff)\n\t\treturn true;\n\ttime_remaining = last_refresh - lt->cutoff;\n\tlt->new_timeo = min(lt->new_timeo, time_remaining);\n\treturn false;\n}\n\n#ifdef CONFIG_NFSD_V4_2_INTER_SSC\nvoid nfsd4_ssc_init_umount_work(struct nfsd_net *nn)\n{\n\tspin_lock_init(&nn->nfsd_ssc_lock);\n\tINIT_LIST_HEAD(&nn->nfsd_ssc_mount_list);\n\tinit_waitqueue_head(&nn->nfsd_ssc_waitq);\n}\nEXPORT_SYMBOL_GPL(nfsd4_ssc_init_umount_work);\n\n \nstatic void nfsd4_ssc_shutdown_umount(struct nfsd_net *nn)\n{\n\tstruct nfsd4_ssc_umount_item *ni = NULL;\n\tstruct nfsd4_ssc_umount_item *tmp;\n\n\tspin_lock(&nn->nfsd_ssc_lock);\n\tlist_for_each_entry_safe(ni, tmp, &nn->nfsd_ssc_mount_list, nsui_list) {\n\t\tlist_del(&ni->nsui_list);\n\t\tspin_unlock(&nn->nfsd_ssc_lock);\n\t\tmntput(ni->nsui_vfsmount);\n\t\tkfree(ni);\n\t\tspin_lock(&nn->nfsd_ssc_lock);\n\t}\n\tspin_unlock(&nn->nfsd_ssc_lock);\n}\n\nstatic void nfsd4_ssc_expire_umount(struct nfsd_net *nn)\n{\n\tbool do_wakeup = false;\n\tstruct nfsd4_ssc_umount_item *ni = NULL;\n\tstruct nfsd4_ssc_umount_item *tmp;\n\n\tspin_lock(&nn->nfsd_ssc_lock);\n\tlist_for_each_entry_safe(ni, tmp, &nn->nfsd_ssc_mount_list, nsui_list) {\n\t\tif (time_after(jiffies, ni->nsui_expire)) {\n\t\t\tif (refcount_read(&ni->nsui_refcnt) > 1)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tni->nsui_busy = true;\n\t\t\tspin_unlock(&nn->nfsd_ssc_lock);\n\t\t\tmntput(ni->nsui_vfsmount);\n\t\t\tspin_lock(&nn->nfsd_ssc_lock);\n\n\t\t\t \n\t\t\tlist_del(&ni->nsui_list);\n\t\t\tkfree(ni);\n\n\t\t\t \n\t\t\tdo_wakeup = true;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\tif (do_wakeup)\n\t\twake_up_all(&nn->nfsd_ssc_waitq);\n\tspin_unlock(&nn->nfsd_ssc_lock);\n}\n#endif\n\n \nstatic bool\nnfs4_lockowner_has_blockers(struct nfs4_lockowner *lo)\n{\n\tstruct file_lock_context *ctx;\n\tstruct nfs4_ol_stateid *stp;\n\tstruct nfs4_file *nf;\n\n\tlist_for_each_entry(stp, &lo->lo_owner.so_stateids, st_perstateowner) {\n\t\tnf = stp->st_stid.sc_file;\n\t\tctx = locks_inode_context(nf->fi_inode);\n\t\tif (!ctx)\n\t\t\tcontinue;\n\t\tif (locks_owner_has_blockers(ctx, lo))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic bool\nnfs4_anylock_blockers(struct nfs4_client *clp)\n{\n\tint i;\n\tstruct nfs4_stateowner *so;\n\tstruct nfs4_lockowner *lo;\n\n\tif (atomic_read(&clp->cl_delegs_in_recall))\n\t\treturn true;\n\tspin_lock(&clp->cl_lock);\n\tfor (i = 0; i < OWNER_HASH_SIZE; i++) {\n\t\tlist_for_each_entry(so, &clp->cl_ownerstr_hashtbl[i],\n\t\t\t\tso_strhash) {\n\t\t\tif (so->so_is_open_owner)\n\t\t\t\tcontinue;\n\t\t\tlo = lockowner(so);\n\t\t\tif (nfs4_lockowner_has_blockers(lo)) {\n\t\t\t\tspin_unlock(&clp->cl_lock);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock(&clp->cl_lock);\n\treturn false;\n}\n\nstatic void\nnfs4_get_client_reaplist(struct nfsd_net *nn, struct list_head *reaplist,\n\t\t\t\tstruct laundry_time *lt)\n{\n\tunsigned int maxreap, reapcnt = 0;\n\tstruct list_head *pos, *next;\n\tstruct nfs4_client *clp;\n\n\tmaxreap = (atomic_read(&nn->nfs4_client_count) >= nn->nfs4_max_clients) ?\n\t\t\tNFSD_CLIENT_MAX_TRIM_PER_RUN : 0;\n\tINIT_LIST_HEAD(reaplist);\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_safe(pos, next, &nn->client_lru) {\n\t\tclp = list_entry(pos, struct nfs4_client, cl_lru);\n\t\tif (clp->cl_state == NFSD4_EXPIRABLE)\n\t\t\tgoto exp_client;\n\t\tif (!state_expired(lt, clp->cl_time))\n\t\t\tbreak;\n\t\tif (!atomic_read(&clp->cl_rpc_users)) {\n\t\t\tif (clp->cl_state == NFSD4_ACTIVE)\n\t\t\t\tatomic_inc(&nn->nfsd_courtesy_clients);\n\t\t\tclp->cl_state = NFSD4_COURTESY;\n\t\t}\n\t\tif (!client_has_state(clp))\n\t\t\tgoto exp_client;\n\t\tif (!nfs4_anylock_blockers(clp))\n\t\t\tif (reapcnt >= maxreap)\n\t\t\t\tcontinue;\nexp_client:\n\t\tif (!mark_client_expired_locked(clp)) {\n\t\t\tlist_add(&clp->cl_lru, reaplist);\n\t\t\treapcnt++;\n\t\t}\n\t}\n\tspin_unlock(&nn->client_lock);\n}\n\nstatic void\nnfs4_get_courtesy_client_reaplist(struct nfsd_net *nn,\n\t\t\t\tstruct list_head *reaplist)\n{\n\tunsigned int maxreap = 0, reapcnt = 0;\n\tstruct list_head *pos, *next;\n\tstruct nfs4_client *clp;\n\n\tmaxreap = NFSD_CLIENT_MAX_TRIM_PER_RUN;\n\tINIT_LIST_HEAD(reaplist);\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_safe(pos, next, &nn->client_lru) {\n\t\tclp = list_entry(pos, struct nfs4_client, cl_lru);\n\t\tif (clp->cl_state == NFSD4_ACTIVE)\n\t\t\tbreak;\n\t\tif (reapcnt >= maxreap)\n\t\t\tbreak;\n\t\tif (!mark_client_expired_locked(clp)) {\n\t\t\tlist_add(&clp->cl_lru, reaplist);\n\t\t\treapcnt++;\n\t\t}\n\t}\n\tspin_unlock(&nn->client_lock);\n}\n\nstatic void\nnfs4_process_client_reaplist(struct list_head *reaplist)\n{\n\tstruct list_head *pos, *next;\n\tstruct nfs4_client *clp;\n\n\tlist_for_each_safe(pos, next, reaplist) {\n\t\tclp = list_entry(pos, struct nfs4_client, cl_lru);\n\t\ttrace_nfsd_clid_purged(&clp->cl_clientid);\n\t\tlist_del_init(&clp->cl_lru);\n\t\texpire_client(clp);\n\t}\n}\n\nstatic time64_t\nnfs4_laundromat(struct nfsd_net *nn)\n{\n\tstruct nfs4_openowner *oo;\n\tstruct nfs4_delegation *dp;\n\tstruct nfs4_ol_stateid *stp;\n\tstruct nfsd4_blocked_lock *nbl;\n\tstruct list_head *pos, *next, reaplist;\n\tstruct laundry_time lt = {\n\t\t.cutoff = ktime_get_boottime_seconds() - nn->nfsd4_lease,\n\t\t.new_timeo = nn->nfsd4_lease\n\t};\n\tstruct nfs4_cpntf_state *cps;\n\tcopy_stateid_t *cps_t;\n\tint i;\n\n\tif (clients_still_reclaiming(nn)) {\n\t\tlt.new_timeo = 0;\n\t\tgoto out;\n\t}\n\tnfsd4_end_grace(nn);\n\n\tspin_lock(&nn->s2s_cp_lock);\n\tidr_for_each_entry(&nn->s2s_cp_stateids, cps_t, i) {\n\t\tcps = container_of(cps_t, struct nfs4_cpntf_state, cp_stateid);\n\t\tif (cps->cp_stateid.cs_type == NFS4_COPYNOTIFY_STID &&\n\t\t\t\tstate_expired(&lt, cps->cpntf_time))\n\t\t\t_free_cpntf_state_locked(nn, cps);\n\t}\n\tspin_unlock(&nn->s2s_cp_lock);\n\tnfs4_get_client_reaplist(nn, &reaplist, &lt);\n\tnfs4_process_client_reaplist(&reaplist);\n\n\tspin_lock(&state_lock);\n\tlist_for_each_safe(pos, next, &nn->del_recall_lru) {\n\t\tdp = list_entry (pos, struct nfs4_delegation, dl_recall_lru);\n\t\tif (!state_expired(&lt, dp->dl_time))\n\t\t\tbreak;\n\t\tWARN_ON(!unhash_delegation_locked(dp));\n\t\tlist_add(&dp->dl_recall_lru, &reaplist);\n\t}\n\tspin_unlock(&state_lock);\n\twhile (!list_empty(&reaplist)) {\n\t\tdp = list_first_entry(&reaplist, struct nfs4_delegation,\n\t\t\t\t\tdl_recall_lru);\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\trevoke_delegation(dp);\n\t}\n\n\tspin_lock(&nn->client_lock);\n\twhile (!list_empty(&nn->close_lru)) {\n\t\too = list_first_entry(&nn->close_lru, struct nfs4_openowner,\n\t\t\t\t\too_close_lru);\n\t\tif (!state_expired(&lt, oo->oo_time))\n\t\t\tbreak;\n\t\tlist_del_init(&oo->oo_close_lru);\n\t\tstp = oo->oo_last_closed_stid;\n\t\too->oo_last_closed_stid = NULL;\n\t\tspin_unlock(&nn->client_lock);\n\t\tnfs4_put_stid(&stp->st_stid);\n\t\tspin_lock(&nn->client_lock);\n\t}\n\tspin_unlock(&nn->client_lock);\n\n\t \n\tBUG_ON(!list_empty(&reaplist));\n\tspin_lock(&nn->blocked_locks_lock);\n\twhile (!list_empty(&nn->blocked_locks_lru)) {\n\t\tnbl = list_first_entry(&nn->blocked_locks_lru,\n\t\t\t\t\tstruct nfsd4_blocked_lock, nbl_lru);\n\t\tif (!state_expired(&lt, nbl->nbl_time))\n\t\t\tbreak;\n\t\tlist_move(&nbl->nbl_lru, &reaplist);\n\t\tlist_del_init(&nbl->nbl_list);\n\t}\n\tspin_unlock(&nn->blocked_locks_lock);\n\n\twhile (!list_empty(&reaplist)) {\n\t\tnbl = list_first_entry(&reaplist,\n\t\t\t\t\tstruct nfsd4_blocked_lock, nbl_lru);\n\t\tlist_del_init(&nbl->nbl_lru);\n\t\tfree_blocked_lock(nbl);\n\t}\n#ifdef CONFIG_NFSD_V4_2_INTER_SSC\n\t \n\tnfsd4_ssc_expire_umount(nn);\n#endif\nout:\n\treturn max_t(time64_t, lt.new_timeo, NFSD_LAUNDROMAT_MINTIMEOUT);\n}\n\nstatic void laundromat_main(struct work_struct *);\n\nstatic void\nlaundromat_main(struct work_struct *laundry)\n{\n\ttime64_t t;\n\tstruct delayed_work *dwork = to_delayed_work(laundry);\n\tstruct nfsd_net *nn = container_of(dwork, struct nfsd_net,\n\t\t\t\t\t   laundromat_work);\n\n\tt = nfs4_laundromat(nn);\n\tqueue_delayed_work(laundry_wq, &nn->laundromat_work, t*HZ);\n}\n\nstatic void\ncourtesy_client_reaper(struct nfsd_net *nn)\n{\n\tstruct list_head reaplist;\n\n\tnfs4_get_courtesy_client_reaplist(nn, &reaplist);\n\tnfs4_process_client_reaplist(&reaplist);\n}\n\nstatic void\ndeleg_reaper(struct nfsd_net *nn)\n{\n\tstruct list_head *pos, *next;\n\tstruct nfs4_client *clp;\n\tstruct list_head cblist;\n\n\tINIT_LIST_HEAD(&cblist);\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_safe(pos, next, &nn->client_lru) {\n\t\tclp = list_entry(pos, struct nfs4_client, cl_lru);\n\t\tif (clp->cl_state != NFSD4_ACTIVE ||\n\t\t\tlist_empty(&clp->cl_delegations) ||\n\t\t\tatomic_read(&clp->cl_delegs_in_recall) ||\n\t\t\ttest_bit(NFSD4_CLIENT_CB_RECALL_ANY, &clp->cl_flags) ||\n\t\t\t(ktime_get_boottime_seconds() -\n\t\t\t\tclp->cl_ra_time < 5)) {\n\t\t\tcontinue;\n\t\t}\n\t\tlist_add(&clp->cl_ra_cblist, &cblist);\n\n\t\t \n\t\tatomic_inc(&clp->cl_rpc_users);\n\t\tset_bit(NFSD4_CLIENT_CB_RECALL_ANY, &clp->cl_flags);\n\t\tclp->cl_ra_time = ktime_get_boottime_seconds();\n\t}\n\tspin_unlock(&nn->client_lock);\n\n\twhile (!list_empty(&cblist)) {\n\t\tclp = list_first_entry(&cblist, struct nfs4_client,\n\t\t\t\t\tcl_ra_cblist);\n\t\tlist_del_init(&clp->cl_ra_cblist);\n\t\tclp->cl_ra->ra_keep = 0;\n\t\tclp->cl_ra->ra_bmval[0] = BIT(RCA4_TYPE_MASK_RDATA_DLG);\n\t\ttrace_nfsd_cb_recall_any(clp->cl_ra);\n\t\tnfsd4_run_cb(&clp->cl_ra->ra_cb);\n\t}\n}\n\nstatic void\nnfsd4_state_shrinker_worker(struct work_struct *work)\n{\n\tstruct nfsd_net *nn = container_of(work, struct nfsd_net,\n\t\t\t\tnfsd_shrinker_work);\n\n\tcourtesy_client_reaper(nn);\n\tdeleg_reaper(nn);\n}\n\nstatic inline __be32 nfs4_check_fh(struct svc_fh *fhp, struct nfs4_stid *stp)\n{\n\tif (!fh_match(&fhp->fh_handle, &stp->sc_file->fi_fhandle))\n\t\treturn nfserr_bad_stateid;\n\treturn nfs_ok;\n}\n\nstatic\n__be32 nfs4_check_openmode(struct nfs4_ol_stateid *stp, int flags)\n{\n        __be32 status = nfserr_openmode;\n\n\t \n\tif (stp->st_openstp)\n\t\tstp = stp->st_openstp;\n\tif ((flags & WR_STATE) && !access_permit_write(stp))\n                goto out;\n\tif ((flags & RD_STATE) && !access_permit_read(stp))\n                goto out;\n\tstatus = nfs_ok;\nout:\n\treturn status;\n}\n\nstatic inline __be32\ncheck_special_stateids(struct net *net, svc_fh *current_fh, stateid_t *stateid, int flags)\n{\n\tif (ONE_STATEID(stateid) && (flags & RD_STATE))\n\t\treturn nfs_ok;\n\telse if (opens_in_grace(net)) {\n\t\t \n\t\treturn nfserr_grace;\n\t} else if (flags & WR_STATE)\n\t\treturn nfs4_share_conflict(current_fh,\n\t\t\t\tNFS4_SHARE_DENY_WRITE);\n\telse  \n\t\treturn nfs4_share_conflict(current_fh,\n\t\t\t\tNFS4_SHARE_DENY_READ);\n}\n\nstatic __be32 check_stateid_generation(stateid_t *in, stateid_t *ref, bool has_session)\n{\n\t \n\tif (has_session && in->si_generation == 0)\n\t\treturn nfs_ok;\n\n\tif (in->si_generation == ref->si_generation)\n\t\treturn nfs_ok;\n\n\t \n\tif (nfsd4_stateid_generation_after(in, ref))\n\t\treturn nfserr_bad_stateid;\n\t \n\treturn nfserr_old_stateid;\n}\n\nstatic __be32 nfsd4_stid_check_stateid_generation(stateid_t *in, struct nfs4_stid *s, bool has_session)\n{\n\t__be32 ret;\n\n\tspin_lock(&s->sc_lock);\n\tret = nfsd4_verify_open_stid(s);\n\tif (ret == nfs_ok)\n\t\tret = check_stateid_generation(in, &s->sc_stateid, has_session);\n\tspin_unlock(&s->sc_lock);\n\treturn ret;\n}\n\nstatic __be32 nfsd4_check_openowner_confirmed(struct nfs4_ol_stateid *ols)\n{\n\tif (ols->st_stateowner->so_is_open_owner &&\n\t    !(openowner(ols->st_stateowner)->oo_flags & NFS4_OO_CONFIRMED))\n\t\treturn nfserr_bad_stateid;\n\treturn nfs_ok;\n}\n\nstatic __be32 nfsd4_validate_stateid(struct nfs4_client *cl, stateid_t *stateid)\n{\n\tstruct nfs4_stid *s;\n\t__be32 status = nfserr_bad_stateid;\n\n\tif (ZERO_STATEID(stateid) || ONE_STATEID(stateid) ||\n\t\tCLOSE_STATEID(stateid))\n\t\treturn status;\n\tspin_lock(&cl->cl_lock);\n\ts = find_stateid_locked(cl, stateid);\n\tif (!s)\n\t\tgoto out_unlock;\n\tstatus = nfsd4_stid_check_stateid_generation(stateid, s, 1);\n\tif (status)\n\t\tgoto out_unlock;\n\tswitch (s->sc_type) {\n\tcase NFS4_DELEG_STID:\n\t\tstatus = nfs_ok;\n\t\tbreak;\n\tcase NFS4_REVOKED_DELEG_STID:\n\t\tstatus = nfserr_deleg_revoked;\n\t\tbreak;\n\tcase NFS4_OPEN_STID:\n\tcase NFS4_LOCK_STID:\n\t\tstatus = nfsd4_check_openowner_confirmed(openlockstateid(s));\n\t\tbreak;\n\tdefault:\n\t\tprintk(\"unknown stateid type %x\\n\", s->sc_type);\n\t\tfallthrough;\n\tcase NFS4_CLOSED_STID:\n\tcase NFS4_CLOSED_DELEG_STID:\n\t\tstatus = nfserr_bad_stateid;\n\t}\nout_unlock:\n\tspin_unlock(&cl->cl_lock);\n\treturn status;\n}\n\n__be32\nnfsd4_lookup_stateid(struct nfsd4_compound_state *cstate,\n\t\t     stateid_t *stateid, unsigned char typemask,\n\t\t     struct nfs4_stid **s, struct nfsd_net *nn)\n{\n\t__be32 status;\n\tstruct nfs4_stid *stid;\n\tbool return_revoked = false;\n\n\t \n\tif (typemask & NFS4_REVOKED_DELEG_STID)\n\t\treturn_revoked = true;\n\telse if (typemask & NFS4_DELEG_STID)\n\t\ttypemask |= NFS4_REVOKED_DELEG_STID;\n\n\tif (ZERO_STATEID(stateid) || ONE_STATEID(stateid) ||\n\t\tCLOSE_STATEID(stateid))\n\t\treturn nfserr_bad_stateid;\n\tstatus = set_client(&stateid->si_opaque.so_clid, cstate, nn);\n\tif (status == nfserr_stale_clientid) {\n\t\tif (cstate->session)\n\t\t\treturn nfserr_bad_stateid;\n\t\treturn nfserr_stale_stateid;\n\t}\n\tif (status)\n\t\treturn status;\n\tstid = find_stateid_by_type(cstate->clp, stateid, typemask);\n\tif (!stid)\n\t\treturn nfserr_bad_stateid;\n\tif ((stid->sc_type == NFS4_REVOKED_DELEG_STID) && !return_revoked) {\n\t\tnfs4_put_stid(stid);\n\t\tif (cstate->minorversion)\n\t\t\treturn nfserr_deleg_revoked;\n\t\treturn nfserr_bad_stateid;\n\t}\n\t*s = stid;\n\treturn nfs_ok;\n}\n\nstatic struct nfsd_file *\nnfs4_find_file(struct nfs4_stid *s, int flags)\n{\n\tstruct nfsd_file *ret = NULL;\n\n\tif (!s)\n\t\treturn NULL;\n\n\tswitch (s->sc_type) {\n\tcase NFS4_DELEG_STID:\n\t\tspin_lock(&s->sc_file->fi_lock);\n\t\tret = nfsd_file_get(s->sc_file->fi_deleg_file);\n\t\tspin_unlock(&s->sc_file->fi_lock);\n\t\tbreak;\n\tcase NFS4_OPEN_STID:\n\tcase NFS4_LOCK_STID:\n\t\tif (flags & RD_STATE)\n\t\t\tret = find_readable_file(s->sc_file);\n\t\telse\n\t\t\tret = find_writeable_file(s->sc_file);\n\t}\n\n\treturn ret;\n}\n\nstatic __be32\nnfs4_check_olstateid(struct nfs4_ol_stateid *ols, int flags)\n{\n\t__be32 status;\n\n\tstatus = nfsd4_check_openowner_confirmed(ols);\n\tif (status)\n\t\treturn status;\n\treturn nfs4_check_openmode(ols, flags);\n}\n\nstatic __be32\nnfs4_check_file(struct svc_rqst *rqstp, struct svc_fh *fhp, struct nfs4_stid *s,\n\t\tstruct nfsd_file **nfp, int flags)\n{\n\tint acc = (flags & RD_STATE) ? NFSD_MAY_READ : NFSD_MAY_WRITE;\n\tstruct nfsd_file *nf;\n\t__be32 status;\n\n\tnf = nfs4_find_file(s, flags);\n\tif (nf) {\n\t\tstatus = nfsd_permission(rqstp, fhp->fh_export, fhp->fh_dentry,\n\t\t\t\tacc | NFSD_MAY_OWNER_OVERRIDE);\n\t\tif (status) {\n\t\t\tnfsd_file_put(nf);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tstatus = nfsd_file_acquire(rqstp, fhp, acc, &nf);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\t*nfp = nf;\nout:\n\treturn status;\n}\nstatic void\n_free_cpntf_state_locked(struct nfsd_net *nn, struct nfs4_cpntf_state *cps)\n{\n\tWARN_ON_ONCE(cps->cp_stateid.cs_type != NFS4_COPYNOTIFY_STID);\n\tif (!refcount_dec_and_test(&cps->cp_stateid.cs_count))\n\t\treturn;\n\tlist_del(&cps->cp_list);\n\tidr_remove(&nn->s2s_cp_stateids,\n\t\t   cps->cp_stateid.cs_stid.si_opaque.so_id);\n\tkfree(cps);\n}\n \n__be32 manage_cpntf_state(struct nfsd_net *nn, stateid_t *st,\n\t\t\t  struct nfs4_client *clp,\n\t\t\t  struct nfs4_cpntf_state **cps)\n{\n\tcopy_stateid_t *cps_t;\n\tstruct nfs4_cpntf_state *state = NULL;\n\n\tif (st->si_opaque.so_clid.cl_id != nn->s2s_cp_cl_id)\n\t\treturn nfserr_bad_stateid;\n\tspin_lock(&nn->s2s_cp_lock);\n\tcps_t = idr_find(&nn->s2s_cp_stateids, st->si_opaque.so_id);\n\tif (cps_t) {\n\t\tstate = container_of(cps_t, struct nfs4_cpntf_state,\n\t\t\t\t     cp_stateid);\n\t\tif (state->cp_stateid.cs_type != NFS4_COPYNOTIFY_STID) {\n\t\t\tstate = NULL;\n\t\t\tgoto unlock;\n\t\t}\n\t\tif (!clp)\n\t\t\trefcount_inc(&state->cp_stateid.cs_count);\n\t\telse\n\t\t\t_free_cpntf_state_locked(nn, state);\n\t}\nunlock:\n\tspin_unlock(&nn->s2s_cp_lock);\n\tif (!state)\n\t\treturn nfserr_bad_stateid;\n\tif (!clp && state)\n\t\t*cps = state;\n\treturn 0;\n}\n\nstatic __be32 find_cpntf_state(struct nfsd_net *nn, stateid_t *st,\n\t\t\t       struct nfs4_stid **stid)\n{\n\t__be32 status;\n\tstruct nfs4_cpntf_state *cps = NULL;\n\tstruct nfs4_client *found;\n\n\tstatus = manage_cpntf_state(nn, st, NULL, &cps);\n\tif (status)\n\t\treturn status;\n\n\tcps->cpntf_time = ktime_get_boottime_seconds();\n\n\tstatus = nfserr_expired;\n\tfound = lookup_clientid(&cps->cp_p_clid, true, nn);\n\tif (!found)\n\t\tgoto out;\n\n\t*stid = find_stateid_by_type(found, &cps->cp_p_stateid,\n\t\t\tNFS4_DELEG_STID|NFS4_OPEN_STID|NFS4_LOCK_STID);\n\tif (*stid)\n\t\tstatus = nfs_ok;\n\telse\n\t\tstatus = nfserr_bad_stateid;\n\n\tput_client_renew(found);\nout:\n\tnfs4_put_cpntf_state(nn, cps);\n\treturn status;\n}\n\nvoid nfs4_put_cpntf_state(struct nfsd_net *nn, struct nfs4_cpntf_state *cps)\n{\n\tspin_lock(&nn->s2s_cp_lock);\n\t_free_cpntf_state_locked(nn, cps);\n\tspin_unlock(&nn->s2s_cp_lock);\n}\n\n \n__be32\nnfs4_preprocess_stateid_op(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate, struct svc_fh *fhp,\n\t\tstateid_t *stateid, int flags, struct nfsd_file **nfp,\n\t\tstruct nfs4_stid **cstid)\n{\n\tstruct net *net = SVC_NET(rqstp);\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tstruct nfs4_stid *s = NULL;\n\t__be32 status;\n\n\tif (nfp)\n\t\t*nfp = NULL;\n\n\tif (ZERO_STATEID(stateid) || ONE_STATEID(stateid)) {\n\t\tif (cstid)\n\t\t\tstatus = nfserr_bad_stateid;\n\t\telse\n\t\t\tstatus = check_special_stateids(net, fhp, stateid,\n\t\t\t\t\t\t\t\t\tflags);\n\t\tgoto done;\n\t}\n\n\tstatus = nfsd4_lookup_stateid(cstate, stateid,\n\t\t\t\tNFS4_DELEG_STID|NFS4_OPEN_STID|NFS4_LOCK_STID,\n\t\t\t\t&s, nn);\n\tif (status == nfserr_bad_stateid)\n\t\tstatus = find_cpntf_state(nn, stateid, &s);\n\tif (status)\n\t\treturn status;\n\tstatus = nfsd4_stid_check_stateid_generation(stateid, s,\n\t\t\tnfsd4_has_session(cstate));\n\tif (status)\n\t\tgoto out;\n\n\tswitch (s->sc_type) {\n\tcase NFS4_DELEG_STID:\n\t\tstatus = nfs4_check_delegmode(delegstateid(s), flags);\n\t\tbreak;\n\tcase NFS4_OPEN_STID:\n\tcase NFS4_LOCK_STID:\n\t\tstatus = nfs4_check_olstateid(openlockstateid(s), flags);\n\t\tbreak;\n\tdefault:\n\t\tstatus = nfserr_bad_stateid;\n\t\tbreak;\n\t}\n\tif (status)\n\t\tgoto out;\n\tstatus = nfs4_check_fh(fhp, s);\n\ndone:\n\tif (status == nfs_ok && nfp)\n\t\tstatus = nfs4_check_file(rqstp, fhp, s, nfp, flags);\nout:\n\tif (s) {\n\t\tif (!status && cstid)\n\t\t\t*cstid = s;\n\t\telse\n\t\t\tnfs4_put_stid(s);\n\t}\n\treturn status;\n}\n\n \n__be32\nnfsd4_test_stateid(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\t   union nfsd4_op_u *u)\n{\n\tstruct nfsd4_test_stateid *test_stateid = &u->test_stateid;\n\tstruct nfsd4_test_stateid_id *stateid;\n\tstruct nfs4_client *cl = cstate->clp;\n\n\tlist_for_each_entry(stateid, &test_stateid->ts_stateid_list, ts_id_list)\n\t\tstateid->ts_id_status =\n\t\t\tnfsd4_validate_stateid(cl, &stateid->ts_id_stateid);\n\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_free_lock_stateid(stateid_t *stateid, struct nfs4_stid *s)\n{\n\tstruct nfs4_ol_stateid *stp = openlockstateid(s);\n\t__be32 ret;\n\n\tret = nfsd4_lock_ol_stateid(stp);\n\tif (ret)\n\t\tgoto out_put_stid;\n\n\tret = check_stateid_generation(stateid, &s->sc_stateid, 1);\n\tif (ret)\n\t\tgoto out;\n\n\tret = nfserr_locks_held;\n\tif (check_for_locks(stp->st_stid.sc_file,\n\t\t\t    lockowner(stp->st_stateowner)))\n\t\tgoto out;\n\n\trelease_lock_stateid(stp);\n\tret = nfs_ok;\n\nout:\n\tmutex_unlock(&stp->st_mutex);\nout_put_stid:\n\tnfs4_put_stid(s);\n\treturn ret;\n}\n\n__be32\nnfsd4_free_stateid(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\t   union nfsd4_op_u *u)\n{\n\tstruct nfsd4_free_stateid *free_stateid = &u->free_stateid;\n\tstateid_t *stateid = &free_stateid->fr_stateid;\n\tstruct nfs4_stid *s;\n\tstruct nfs4_delegation *dp;\n\tstruct nfs4_client *cl = cstate->clp;\n\t__be32 ret = nfserr_bad_stateid;\n\n\tspin_lock(&cl->cl_lock);\n\ts = find_stateid_locked(cl, stateid);\n\tif (!s)\n\t\tgoto out_unlock;\n\tspin_lock(&s->sc_lock);\n\tswitch (s->sc_type) {\n\tcase NFS4_DELEG_STID:\n\t\tret = nfserr_locks_held;\n\t\tbreak;\n\tcase NFS4_OPEN_STID:\n\t\tret = check_stateid_generation(stateid, &s->sc_stateid, 1);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tret = nfserr_locks_held;\n\t\tbreak;\n\tcase NFS4_LOCK_STID:\n\t\tspin_unlock(&s->sc_lock);\n\t\trefcount_inc(&s->sc_count);\n\t\tspin_unlock(&cl->cl_lock);\n\t\tret = nfsd4_free_lock_stateid(stateid, s);\n\t\tgoto out;\n\tcase NFS4_REVOKED_DELEG_STID:\n\t\tspin_unlock(&s->sc_lock);\n\t\tdp = delegstateid(s);\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tspin_unlock(&cl->cl_lock);\n\t\tnfs4_put_stid(s);\n\t\tret = nfs_ok;\n\t\tgoto out;\n\t \n\t}\n\tspin_unlock(&s->sc_lock);\nout_unlock:\n\tspin_unlock(&cl->cl_lock);\nout:\n\treturn ret;\n}\n\nstatic inline int\nsetlkflg (int type)\n{\n\treturn (type == NFS4_READW_LT || type == NFS4_READ_LT) ?\n\t\tRD_STATE : WR_STATE;\n}\n\nstatic __be32 nfs4_seqid_op_checks(struct nfsd4_compound_state *cstate, stateid_t *stateid, u32 seqid, struct nfs4_ol_stateid *stp)\n{\n\tstruct svc_fh *current_fh = &cstate->current_fh;\n\tstruct nfs4_stateowner *sop = stp->st_stateowner;\n\t__be32 status;\n\n\tstatus = nfsd4_check_seqid(cstate, sop, seqid);\n\tif (status)\n\t\treturn status;\n\tstatus = nfsd4_lock_ol_stateid(stp);\n\tif (status != nfs_ok)\n\t\treturn status;\n\tstatus = check_stateid_generation(stateid, &stp->st_stid.sc_stateid, nfsd4_has_session(cstate));\n\tif (status == nfs_ok)\n\t\tstatus = nfs4_check_fh(current_fh, &stp->st_stid);\n\tif (status != nfs_ok)\n\t\tmutex_unlock(&stp->st_mutex);\n\treturn status;\n}\n\n \nstatic __be32\nnfs4_preprocess_seqid_op(struct nfsd4_compound_state *cstate, u32 seqid,\n\t\t\t stateid_t *stateid, char typemask,\n\t\t\t struct nfs4_ol_stateid **stpp,\n\t\t\t struct nfsd_net *nn)\n{\n\t__be32 status;\n\tstruct nfs4_stid *s;\n\tstruct nfs4_ol_stateid *stp = NULL;\n\n\ttrace_nfsd_preprocess(seqid, stateid);\n\n\t*stpp = NULL;\n\tstatus = nfsd4_lookup_stateid(cstate, stateid, typemask, &s, nn);\n\tif (status)\n\t\treturn status;\n\tstp = openlockstateid(s);\n\tnfsd4_cstate_assign_replay(cstate, stp->st_stateowner);\n\n\tstatus = nfs4_seqid_op_checks(cstate, stateid, seqid, stp);\n\tif (!status)\n\t\t*stpp = stp;\n\telse\n\t\tnfs4_put_stid(&stp->st_stid);\n\treturn status;\n}\n\nstatic __be32 nfs4_preprocess_confirmed_seqid_op(struct nfsd4_compound_state *cstate, u32 seqid,\n\t\t\t\t\t\t stateid_t *stateid, struct nfs4_ol_stateid **stpp, struct nfsd_net *nn)\n{\n\t__be32 status;\n\tstruct nfs4_openowner *oo;\n\tstruct nfs4_ol_stateid *stp;\n\n\tstatus = nfs4_preprocess_seqid_op(cstate, seqid, stateid,\n\t\t\t\t\t\tNFS4_OPEN_STID, &stp, nn);\n\tif (status)\n\t\treturn status;\n\too = openowner(stp->st_stateowner);\n\tif (!(oo->oo_flags & NFS4_OO_CONFIRMED)) {\n\t\tmutex_unlock(&stp->st_mutex);\n\t\tnfs4_put_stid(&stp->st_stid);\n\t\treturn nfserr_bad_stateid;\n\t}\n\t*stpp = stp;\n\treturn nfs_ok;\n}\n\n__be32\nnfsd4_open_confirm(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\t   union nfsd4_op_u *u)\n{\n\tstruct nfsd4_open_confirm *oc = &u->open_confirm;\n\t__be32 status;\n\tstruct nfs4_openowner *oo;\n\tstruct nfs4_ol_stateid *stp;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tdprintk(\"NFSD: nfsd4_open_confirm on file %pd\\n\",\n\t\t\tcstate->current_fh.fh_dentry);\n\n\tstatus = fh_verify(rqstp, &cstate->current_fh, S_IFREG, 0);\n\tif (status)\n\t\treturn status;\n\n\tstatus = nfs4_preprocess_seqid_op(cstate,\n\t\t\t\t\toc->oc_seqid, &oc->oc_req_stateid,\n\t\t\t\t\tNFS4_OPEN_STID, &stp, nn);\n\tif (status)\n\t\tgoto out;\n\too = openowner(stp->st_stateowner);\n\tstatus = nfserr_bad_stateid;\n\tif (oo->oo_flags & NFS4_OO_CONFIRMED) {\n\t\tmutex_unlock(&stp->st_mutex);\n\t\tgoto put_stateid;\n\t}\n\too->oo_flags |= NFS4_OO_CONFIRMED;\n\tnfs4_inc_and_copy_stateid(&oc->oc_resp_stateid, &stp->st_stid);\n\tmutex_unlock(&stp->st_mutex);\n\ttrace_nfsd_open_confirm(oc->oc_seqid, &stp->st_stid.sc_stateid);\n\tnfsd4_client_record_create(oo->oo_owner.so_client);\n\tstatus = nfs_ok;\nput_stateid:\n\tnfs4_put_stid(&stp->st_stid);\nout:\n\tnfsd4_bump_seqid(cstate, status);\n\treturn status;\n}\n\nstatic inline void nfs4_stateid_downgrade_bit(struct nfs4_ol_stateid *stp, u32 access)\n{\n\tif (!test_access(access, stp))\n\t\treturn;\n\tnfs4_file_put_access(stp->st_stid.sc_file, access);\n\tclear_access(access, stp);\n}\n\nstatic inline void nfs4_stateid_downgrade(struct nfs4_ol_stateid *stp, u32 to_access)\n{\n\tswitch (to_access) {\n\tcase NFS4_SHARE_ACCESS_READ:\n\t\tnfs4_stateid_downgrade_bit(stp, NFS4_SHARE_ACCESS_WRITE);\n\t\tnfs4_stateid_downgrade_bit(stp, NFS4_SHARE_ACCESS_BOTH);\n\t\tbreak;\n\tcase NFS4_SHARE_ACCESS_WRITE:\n\t\tnfs4_stateid_downgrade_bit(stp, NFS4_SHARE_ACCESS_READ);\n\t\tnfs4_stateid_downgrade_bit(stp, NFS4_SHARE_ACCESS_BOTH);\n\t\tbreak;\n\tcase NFS4_SHARE_ACCESS_BOTH:\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t}\n}\n\n__be32\nnfsd4_open_downgrade(struct svc_rqst *rqstp,\n\t\t     struct nfsd4_compound_state *cstate, union nfsd4_op_u *u)\n{\n\tstruct nfsd4_open_downgrade *od = &u->open_downgrade;\n\t__be32 status;\n\tstruct nfs4_ol_stateid *stp;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tdprintk(\"NFSD: nfsd4_open_downgrade on file %pd\\n\", \n\t\t\tcstate->current_fh.fh_dentry);\n\n\t \n\tif (od->od_deleg_want)\n\t\tdprintk(\"NFSD: %s: od_deleg_want=0x%x ignored\\n\", __func__,\n\t\t\tod->od_deleg_want);\n\n\tstatus = nfs4_preprocess_confirmed_seqid_op(cstate, od->od_seqid,\n\t\t\t\t\t&od->od_stateid, &stp, nn);\n\tif (status)\n\t\tgoto out; \n\tstatus = nfserr_inval;\n\tif (!test_access(od->od_share_access, stp)) {\n\t\tdprintk(\"NFSD: access not a subset of current bitmap: 0x%hhx, input access=%08x\\n\",\n\t\t\tstp->st_access_bmap, od->od_share_access);\n\t\tgoto put_stateid;\n\t}\n\tif (!test_deny(od->od_share_deny, stp)) {\n\t\tdprintk(\"NFSD: deny not a subset of current bitmap: 0x%hhx, input deny=%08x\\n\",\n\t\t\tstp->st_deny_bmap, od->od_share_deny);\n\t\tgoto put_stateid;\n\t}\n\tnfs4_stateid_downgrade(stp, od->od_share_access);\n\treset_union_bmap_deny(od->od_share_deny, stp);\n\tnfs4_inc_and_copy_stateid(&od->od_stateid, &stp->st_stid);\n\tstatus = nfs_ok;\nput_stateid:\n\tmutex_unlock(&stp->st_mutex);\n\tnfs4_put_stid(&stp->st_stid);\nout:\n\tnfsd4_bump_seqid(cstate, status);\n\treturn status;\n}\n\nstatic void nfsd4_close_open_stateid(struct nfs4_ol_stateid *s)\n{\n\tstruct nfs4_client *clp = s->st_stid.sc_client;\n\tbool unhashed;\n\tLIST_HEAD(reaplist);\n\tstruct nfs4_ol_stateid *stp;\n\n\tspin_lock(&clp->cl_lock);\n\tunhashed = unhash_open_stateid(s, &reaplist);\n\n\tif (clp->cl_minorversion) {\n\t\tif (unhashed)\n\t\t\tput_ol_stateid_locked(s, &reaplist);\n\t\tspin_unlock(&clp->cl_lock);\n\t\tlist_for_each_entry(stp, &reaplist, st_locks)\n\t\t\tnfs4_free_cpntf_statelist(clp->net, &stp->st_stid);\n\t\tfree_ol_stateid_reaplist(&reaplist);\n\t} else {\n\t\tspin_unlock(&clp->cl_lock);\n\t\tfree_ol_stateid_reaplist(&reaplist);\n\t\tif (unhashed)\n\t\t\tmove_to_close_lru(s, clp->net);\n\t}\n}\n\n \n__be32\nnfsd4_close(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\tunion nfsd4_op_u *u)\n{\n\tstruct nfsd4_close *close = &u->close;\n\t__be32 status;\n\tstruct nfs4_ol_stateid *stp;\n\tstruct net *net = SVC_NET(rqstp);\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tdprintk(\"NFSD: nfsd4_close on file %pd\\n\", \n\t\t\tcstate->current_fh.fh_dentry);\n\n\tstatus = nfs4_preprocess_seqid_op(cstate, close->cl_seqid,\n\t\t\t\t\t&close->cl_stateid,\n\t\t\t\t\tNFS4_OPEN_STID|NFS4_CLOSED_STID,\n\t\t\t\t\t&stp, nn);\n\tnfsd4_bump_seqid(cstate, status);\n\tif (status)\n\t\tgoto out; \n\n\tstp->st_stid.sc_type = NFS4_CLOSED_STID;\n\n\t \n\tnfs4_inc_and_copy_stateid(&close->cl_stateid, &stp->st_stid);\n\n\tnfsd4_close_open_stateid(stp);\n\tmutex_unlock(&stp->st_mutex);\n\n\t \n\tmemcpy(&close->cl_stateid, &close_stateid, sizeof(close->cl_stateid));\n\n\t \n\tnfs4_put_stid(&stp->st_stid);\nout:\n\treturn status;\n}\n\n__be32\nnfsd4_delegreturn(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\t  union nfsd4_op_u *u)\n{\n\tstruct nfsd4_delegreturn *dr = &u->delegreturn;\n\tstruct nfs4_delegation *dp;\n\tstateid_t *stateid = &dr->dr_stateid;\n\tstruct nfs4_stid *s;\n\t__be32 status;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tif ((status = fh_verify(rqstp, &cstate->current_fh, S_IFREG, 0)))\n\t\treturn status;\n\n\tstatus = nfsd4_lookup_stateid(cstate, stateid, NFS4_DELEG_STID, &s, nn);\n\tif (status)\n\t\tgoto out;\n\tdp = delegstateid(s);\n\tstatus = nfsd4_stid_check_stateid_generation(stateid, &dp->dl_stid, nfsd4_has_session(cstate));\n\tif (status)\n\t\tgoto put_stateid;\n\n\ttrace_nfsd_deleg_return(stateid);\n\twake_up_var(d_inode(cstate->current_fh.fh_dentry));\n\tdestroy_delegation(dp);\nput_stateid:\n\tnfs4_put_stid(&dp->dl_stid);\nout:\n\treturn status;\n}\n\n \nstatic inline u64\nlast_byte_offset(u64 start, u64 len)\n{\n\tu64 end;\n\n\tWARN_ON_ONCE(!len);\n\tend = start + len;\n\treturn end > start ? end - 1: NFS4_MAX_UINT64;\n}\n\n \nstatic inline void\nnfs4_transform_lock_offset(struct file_lock *lock)\n{\n\tif (lock->fl_start < 0)\n\t\tlock->fl_start = OFFSET_MAX;\n\tif (lock->fl_end < 0)\n\t\tlock->fl_end = OFFSET_MAX;\n}\n\nstatic fl_owner_t\nnfsd4_lm_get_owner(fl_owner_t owner)\n{\n\tstruct nfs4_lockowner *lo = (struct nfs4_lockowner *)owner;\n\n\tnfs4_get_stateowner(&lo->lo_owner);\n\treturn owner;\n}\n\nstatic void\nnfsd4_lm_put_owner(fl_owner_t owner)\n{\n\tstruct nfs4_lockowner *lo = (struct nfs4_lockowner *)owner;\n\n\tif (lo)\n\t\tnfs4_put_stateowner(&lo->lo_owner);\n}\n\n \nstatic bool\nnfsd4_lm_lock_expirable(struct file_lock *cfl)\n{\n\tstruct nfs4_lockowner *lo = (struct nfs4_lockowner *)cfl->fl_owner;\n\tstruct nfs4_client *clp = lo->lo_owner.so_client;\n\tstruct nfsd_net *nn;\n\n\tif (try_to_expire_client(clp)) {\n\t\tnn = net_generic(clp->net, nfsd_net_id);\n\t\tmod_delayed_work(laundry_wq, &nn->laundromat_work, 0);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nstatic void\nnfsd4_lm_expire_lock(void)\n{\n\tflush_workqueue(laundry_wq);\n}\n\nstatic void\nnfsd4_lm_notify(struct file_lock *fl)\n{\n\tstruct nfs4_lockowner\t\t*lo = (struct nfs4_lockowner *)fl->fl_owner;\n\tstruct net\t\t\t*net = lo->lo_owner.so_client->net;\n\tstruct nfsd_net\t\t\t*nn = net_generic(net, nfsd_net_id);\n\tstruct nfsd4_blocked_lock\t*nbl = container_of(fl,\n\t\t\t\t\t\tstruct nfsd4_blocked_lock, nbl_lock);\n\tbool queue = false;\n\n\t \n\tspin_lock(&nn->blocked_locks_lock);\n\tif (!list_empty(&nbl->nbl_list)) {\n\t\tlist_del_init(&nbl->nbl_list);\n\t\tlist_del_init(&nbl->nbl_lru);\n\t\tqueue = true;\n\t}\n\tspin_unlock(&nn->blocked_locks_lock);\n\n\tif (queue) {\n\t\ttrace_nfsd_cb_notify_lock(lo, nbl);\n\t\tnfsd4_run_cb(&nbl->nbl_cb);\n\t}\n}\n\nstatic const struct lock_manager_operations nfsd_posix_mng_ops  = {\n\t.lm_mod_owner = THIS_MODULE,\n\t.lm_notify = nfsd4_lm_notify,\n\t.lm_get_owner = nfsd4_lm_get_owner,\n\t.lm_put_owner = nfsd4_lm_put_owner,\n\t.lm_lock_expirable = nfsd4_lm_lock_expirable,\n\t.lm_expire_lock = nfsd4_lm_expire_lock,\n};\n\nstatic inline void\nnfs4_set_lock_denied(struct file_lock *fl, struct nfsd4_lock_denied *deny)\n{\n\tstruct nfs4_lockowner *lo;\n\n\tif (fl->fl_lmops == &nfsd_posix_mng_ops) {\n\t\tlo = (struct nfs4_lockowner *) fl->fl_owner;\n\t\txdr_netobj_dup(&deny->ld_owner, &lo->lo_owner.so_owner,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!deny->ld_owner.data)\n\t\t\t \n\t\t\tgoto nevermind;\n\t\tdeny->ld_clientid = lo->lo_owner.so_client->cl_clientid;\n\t} else {\nnevermind:\n\t\tdeny->ld_owner.len = 0;\n\t\tdeny->ld_owner.data = NULL;\n\t\tdeny->ld_clientid.cl_boot = 0;\n\t\tdeny->ld_clientid.cl_id = 0;\n\t}\n\tdeny->ld_start = fl->fl_start;\n\tdeny->ld_length = NFS4_MAX_UINT64;\n\tif (fl->fl_end != NFS4_MAX_UINT64)\n\t\tdeny->ld_length = fl->fl_end - fl->fl_start + 1;        \n\tdeny->ld_type = NFS4_READ_LT;\n\tif (fl->fl_type != F_RDLCK)\n\t\tdeny->ld_type = NFS4_WRITE_LT;\n}\n\nstatic struct nfs4_lockowner *\nfind_lockowner_str_locked(struct nfs4_client *clp, struct xdr_netobj *owner)\n{\n\tunsigned int strhashval = ownerstr_hashval(owner);\n\tstruct nfs4_stateowner *so;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_for_each_entry(so, &clp->cl_ownerstr_hashtbl[strhashval],\n\t\t\t    so_strhash) {\n\t\tif (so->so_is_open_owner)\n\t\t\tcontinue;\n\t\tif (same_owner_str(so, owner))\n\t\t\treturn lockowner(nfs4_get_stateowner(so));\n\t}\n\treturn NULL;\n}\n\nstatic struct nfs4_lockowner *\nfind_lockowner_str(struct nfs4_client *clp, struct xdr_netobj *owner)\n{\n\tstruct nfs4_lockowner *lo;\n\n\tspin_lock(&clp->cl_lock);\n\tlo = find_lockowner_str_locked(clp, owner);\n\tspin_unlock(&clp->cl_lock);\n\treturn lo;\n}\n\nstatic void nfs4_unhash_lockowner(struct nfs4_stateowner *sop)\n{\n\tunhash_lockowner_locked(lockowner(sop));\n}\n\nstatic void nfs4_free_lockowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_lockowner *lo = lockowner(sop);\n\n\tkmem_cache_free(lockowner_slab, lo);\n}\n\nstatic const struct nfs4_stateowner_operations lockowner_ops = {\n\t.so_unhash =\tnfs4_unhash_lockowner,\n\t.so_free =\tnfs4_free_lockowner,\n};\n\n \nstatic struct nfs4_lockowner *\nalloc_init_lock_stateowner(unsigned int strhashval, struct nfs4_client *clp,\n\t\t\t   struct nfs4_ol_stateid *open_stp,\n\t\t\t   struct nfsd4_lock *lock)\n{\n\tstruct nfs4_lockowner *lo, *ret;\n\n\tlo = alloc_stateowner(lockowner_slab, &lock->lk_new_owner, clp);\n\tif (!lo)\n\t\treturn NULL;\n\tINIT_LIST_HEAD(&lo->lo_blocked);\n\tINIT_LIST_HEAD(&lo->lo_owner.so_stateids);\n\tlo->lo_owner.so_is_open_owner = 0;\n\tlo->lo_owner.so_seqid = lock->lk_new_lock_seqid;\n\tlo->lo_owner.so_ops = &lockowner_ops;\n\tspin_lock(&clp->cl_lock);\n\tret = find_lockowner_str_locked(clp, &lock->lk_new_owner);\n\tif (ret == NULL) {\n\t\tlist_add(&lo->lo_owner.so_strhash,\n\t\t\t &clp->cl_ownerstr_hashtbl[strhashval]);\n\t\tret = lo;\n\t} else\n\t\tnfs4_free_stateowner(&lo->lo_owner);\n\n\tspin_unlock(&clp->cl_lock);\n\treturn ret;\n}\n\nstatic struct nfs4_ol_stateid *\nfind_lock_stateid(const struct nfs4_lockowner *lo,\n\t\t  const struct nfs4_ol_stateid *ost)\n{\n\tstruct nfs4_ol_stateid *lst;\n\n\tlockdep_assert_held(&ost->st_stid.sc_client->cl_lock);\n\n\t \n\tif (!nfs4_ol_stateid_unhashed(ost))\n\t\tlist_for_each_entry(lst, &ost->st_locks, st_locks) {\n\t\t\tif (lst->st_stateowner == &lo->lo_owner) {\n\t\t\t\trefcount_inc(&lst->st_stid.sc_count);\n\t\t\t\treturn lst;\n\t\t\t}\n\t\t}\n\treturn NULL;\n}\n\nstatic struct nfs4_ol_stateid *\ninit_lock_stateid(struct nfs4_ol_stateid *stp, struct nfs4_lockowner *lo,\n\t\t  struct nfs4_file *fp, struct inode *inode,\n\t\t  struct nfs4_ol_stateid *open_stp)\n{\n\tstruct nfs4_client *clp = lo->lo_owner.so_client;\n\tstruct nfs4_ol_stateid *retstp;\n\n\tmutex_init(&stp->st_mutex);\n\tmutex_lock_nested(&stp->st_mutex, OPEN_STATEID_MUTEX);\nretry:\n\tspin_lock(&clp->cl_lock);\n\tif (nfs4_ol_stateid_unhashed(open_stp))\n\t\tgoto out_close;\n\tretstp = find_lock_stateid(lo, open_stp);\n\tif (retstp)\n\t\tgoto out_found;\n\trefcount_inc(&stp->st_stid.sc_count);\n\tstp->st_stid.sc_type = NFS4_LOCK_STID;\n\tstp->st_stateowner = nfs4_get_stateowner(&lo->lo_owner);\n\tget_nfs4_file(fp);\n\tstp->st_stid.sc_file = fp;\n\tstp->st_access_bmap = 0;\n\tstp->st_deny_bmap = open_stp->st_deny_bmap;\n\tstp->st_openstp = open_stp;\n\tspin_lock(&fp->fi_lock);\n\tlist_add(&stp->st_locks, &open_stp->st_locks);\n\tlist_add(&stp->st_perstateowner, &lo->lo_owner.so_stateids);\n\tlist_add(&stp->st_perfile, &fp->fi_stateids);\n\tspin_unlock(&fp->fi_lock);\n\tspin_unlock(&clp->cl_lock);\n\treturn stp;\nout_found:\n\tspin_unlock(&clp->cl_lock);\n\tif (nfsd4_lock_ol_stateid(retstp) != nfs_ok) {\n\t\tnfs4_put_stid(&retstp->st_stid);\n\t\tgoto retry;\n\t}\n\t \n\tmutex_unlock(&stp->st_mutex);\n\treturn retstp;\nout_close:\n\tspin_unlock(&clp->cl_lock);\n\tmutex_unlock(&stp->st_mutex);\n\treturn NULL;\n}\n\nstatic struct nfs4_ol_stateid *\nfind_or_create_lock_stateid(struct nfs4_lockowner *lo, struct nfs4_file *fi,\n\t\t\t    struct inode *inode, struct nfs4_ol_stateid *ost,\n\t\t\t    bool *new)\n{\n\tstruct nfs4_stid *ns = NULL;\n\tstruct nfs4_ol_stateid *lst;\n\tstruct nfs4_openowner *oo = openowner(ost->st_stateowner);\n\tstruct nfs4_client *clp = oo->oo_owner.so_client;\n\n\t*new = false;\n\tspin_lock(&clp->cl_lock);\n\tlst = find_lock_stateid(lo, ost);\n\tspin_unlock(&clp->cl_lock);\n\tif (lst != NULL) {\n\t\tif (nfsd4_lock_ol_stateid(lst) == nfs_ok)\n\t\t\tgoto out;\n\t\tnfs4_put_stid(&lst->st_stid);\n\t}\n\tns = nfs4_alloc_stid(clp, stateid_slab, nfs4_free_lock_stateid);\n\tif (ns == NULL)\n\t\treturn NULL;\n\n\tlst = init_lock_stateid(openlockstateid(ns), lo, fi, inode, ost);\n\tif (lst == openlockstateid(ns))\n\t\t*new = true;\n\telse\n\t\tnfs4_put_stid(ns);\nout:\n\treturn lst;\n}\n\nstatic int\ncheck_lock_length(u64 offset, u64 length)\n{\n\treturn ((length == 0) || ((length != NFS4_MAX_UINT64) &&\n\t\t(length > ~offset)));\n}\n\nstatic void get_lock_access(struct nfs4_ol_stateid *lock_stp, u32 access)\n{\n\tstruct nfs4_file *fp = lock_stp->st_stid.sc_file;\n\n\tlockdep_assert_held(&fp->fi_lock);\n\n\tif (test_access(access, lock_stp))\n\t\treturn;\n\t__nfs4_file_get_access(fp, access);\n\tset_access(access, lock_stp);\n}\n\nstatic __be32\nlookup_or_create_lock_state(struct nfsd4_compound_state *cstate,\n\t\t\t    struct nfs4_ol_stateid *ost,\n\t\t\t    struct nfsd4_lock *lock,\n\t\t\t    struct nfs4_ol_stateid **plst, bool *new)\n{\n\t__be32 status;\n\tstruct nfs4_file *fi = ost->st_stid.sc_file;\n\tstruct nfs4_openowner *oo = openowner(ost->st_stateowner);\n\tstruct nfs4_client *cl = oo->oo_owner.so_client;\n\tstruct inode *inode = d_inode(cstate->current_fh.fh_dentry);\n\tstruct nfs4_lockowner *lo;\n\tstruct nfs4_ol_stateid *lst;\n\tunsigned int strhashval;\n\n\tlo = find_lockowner_str(cl, &lock->lk_new_owner);\n\tif (!lo) {\n\t\tstrhashval = ownerstr_hashval(&lock->lk_new_owner);\n\t\tlo = alloc_init_lock_stateowner(strhashval, cl, ost, lock);\n\t\tif (lo == NULL)\n\t\t\treturn nfserr_jukebox;\n\t} else {\n\t\t \n\t\tstatus = nfserr_bad_seqid;\n\t\tif (!cstate->minorversion &&\n\t\t    lock->lk_new_lock_seqid != lo->lo_owner.so_seqid)\n\t\t\tgoto out;\n\t}\n\n\tlst = find_or_create_lock_stateid(lo, fi, inode, ost, new);\n\tif (lst == NULL) {\n\t\tstatus = nfserr_jukebox;\n\t\tgoto out;\n\t}\n\n\tstatus = nfs_ok;\n\t*plst = lst;\nout:\n\tnfs4_put_stateowner(&lo->lo_owner);\n\treturn status;\n}\n\n \n__be32\nnfsd4_lock(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t   union nfsd4_op_u *u)\n{\n\tstruct nfsd4_lock *lock = &u->lock;\n\tstruct nfs4_openowner *open_sop = NULL;\n\tstruct nfs4_lockowner *lock_sop = NULL;\n\tstruct nfs4_ol_stateid *lock_stp = NULL;\n\tstruct nfs4_ol_stateid *open_stp = NULL;\n\tstruct nfs4_file *fp;\n\tstruct nfsd_file *nf = NULL;\n\tstruct nfsd4_blocked_lock *nbl = NULL;\n\tstruct file_lock *file_lock = NULL;\n\tstruct file_lock *conflock = NULL;\n\t__be32 status = 0;\n\tint lkflg;\n\tint err;\n\tbool new = false;\n\tunsigned char fl_type;\n\tunsigned int fl_flags = FL_POSIX;\n\tstruct net *net = SVC_NET(rqstp);\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tdprintk(\"NFSD: nfsd4_lock: start=%Ld length=%Ld\\n\",\n\t\t(long long) lock->lk_offset,\n\t\t(long long) lock->lk_length);\n\n\tif (check_lock_length(lock->lk_offset, lock->lk_length))\n\t\t return nfserr_inval;\n\n\tif ((status = fh_verify(rqstp, &cstate->current_fh,\n\t\t\t\tS_IFREG, NFSD_MAY_LOCK))) {\n\t\tdprintk(\"NFSD: nfsd4_lock: permission denied!\\n\");\n\t\treturn status;\n\t}\n\n\tif (lock->lk_is_new) {\n\t\tif (nfsd4_has_session(cstate))\n\t\t\t \n\t\t\tmemcpy(&lock->lk_new_clientid,\n\t\t\t\t&cstate->clp->cl_clientid,\n\t\t\t\tsizeof(clientid_t));\n\n\t\t \n\t\tstatus = nfs4_preprocess_confirmed_seqid_op(cstate,\n\t\t\t\t        lock->lk_new_open_seqid,\n\t\t                        &lock->lk_new_open_stateid,\n\t\t\t\t\t&open_stp, nn);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tmutex_unlock(&open_stp->st_mutex);\n\t\topen_sop = openowner(open_stp->st_stateowner);\n\t\tstatus = nfserr_bad_stateid;\n\t\tif (!same_clid(&open_sop->oo_owner.so_client->cl_clientid,\n\t\t\t\t\t\t&lock->lk_new_clientid))\n\t\t\tgoto out;\n\t\tstatus = lookup_or_create_lock_state(cstate, open_stp, lock,\n\t\t\t\t\t\t\t&lock_stp, &new);\n\t} else {\n\t\tstatus = nfs4_preprocess_seqid_op(cstate,\n\t\t\t\t       lock->lk_old_lock_seqid,\n\t\t\t\t       &lock->lk_old_lock_stateid,\n\t\t\t\t       NFS4_LOCK_STID, &lock_stp, nn);\n\t}\n\tif (status)\n\t\tgoto out;\n\tlock_sop = lockowner(lock_stp->st_stateowner);\n\n\tlkflg = setlkflg(lock->lk_type);\n\tstatus = nfs4_check_openmode(lock_stp, lkflg);\n\tif (status)\n\t\tgoto out;\n\n\tstatus = nfserr_grace;\n\tif (locks_in_grace(net) && !lock->lk_reclaim)\n\t\tgoto out;\n\tstatus = nfserr_no_grace;\n\tif (!locks_in_grace(net) && lock->lk_reclaim)\n\t\tgoto out;\n\n\tif (lock->lk_reclaim)\n\t\tfl_flags |= FL_RECLAIM;\n\n\tfp = lock_stp->st_stid.sc_file;\n\tswitch (lock->lk_type) {\n\t\tcase NFS4_READW_LT:\n\t\t\tif (nfsd4_has_session(cstate))\n\t\t\t\tfl_flags |= FL_SLEEP;\n\t\t\tfallthrough;\n\t\tcase NFS4_READ_LT:\n\t\t\tspin_lock(&fp->fi_lock);\n\t\t\tnf = find_readable_file_locked(fp);\n\t\t\tif (nf)\n\t\t\t\tget_lock_access(lock_stp, NFS4_SHARE_ACCESS_READ);\n\t\t\tspin_unlock(&fp->fi_lock);\n\t\t\tfl_type = F_RDLCK;\n\t\t\tbreak;\n\t\tcase NFS4_WRITEW_LT:\n\t\t\tif (nfsd4_has_session(cstate))\n\t\t\t\tfl_flags |= FL_SLEEP;\n\t\t\tfallthrough;\n\t\tcase NFS4_WRITE_LT:\n\t\t\tspin_lock(&fp->fi_lock);\n\t\t\tnf = find_writeable_file_locked(fp);\n\t\t\tif (nf)\n\t\t\t\tget_lock_access(lock_stp, NFS4_SHARE_ACCESS_WRITE);\n\t\t\tspin_unlock(&fp->fi_lock);\n\t\t\tfl_type = F_WRLCK;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstatus = nfserr_inval;\n\t\tgoto out;\n\t}\n\n\tif (!nf) {\n\t\tstatus = nfserr_openmode;\n\t\tgoto out;\n\t}\n\n\t \n\tif (nf->nf_file->f_op->lock)\n\t\tfl_flags &= ~FL_SLEEP;\n\n\tnbl = find_or_allocate_block(lock_sop, &fp->fi_fhandle, nn);\n\tif (!nbl) {\n\t\tdprintk(\"NFSD: %s: unable to allocate block!\\n\", __func__);\n\t\tstatus = nfserr_jukebox;\n\t\tgoto out;\n\t}\n\n\tfile_lock = &nbl->nbl_lock;\n\tfile_lock->fl_type = fl_type;\n\tfile_lock->fl_owner = (fl_owner_t)lockowner(nfs4_get_stateowner(&lock_sop->lo_owner));\n\tfile_lock->fl_pid = current->tgid;\n\tfile_lock->fl_file = nf->nf_file;\n\tfile_lock->fl_flags = fl_flags;\n\tfile_lock->fl_lmops = &nfsd_posix_mng_ops;\n\tfile_lock->fl_start = lock->lk_offset;\n\tfile_lock->fl_end = last_byte_offset(lock->lk_offset, lock->lk_length);\n\tnfs4_transform_lock_offset(file_lock);\n\n\tconflock = locks_alloc_lock();\n\tif (!conflock) {\n\t\tdprintk(\"NFSD: %s: unable to allocate lock!\\n\", __func__);\n\t\tstatus = nfserr_jukebox;\n\t\tgoto out;\n\t}\n\n\tif (fl_flags & FL_SLEEP) {\n\t\tnbl->nbl_time = ktime_get_boottime_seconds();\n\t\tspin_lock(&nn->blocked_locks_lock);\n\t\tlist_add_tail(&nbl->nbl_list, &lock_sop->lo_blocked);\n\t\tlist_add_tail(&nbl->nbl_lru, &nn->blocked_locks_lru);\n\t\tkref_get(&nbl->nbl_kref);\n\t\tspin_unlock(&nn->blocked_locks_lock);\n\t}\n\n\terr = vfs_lock_file(nf->nf_file, F_SETLK, file_lock, conflock);\n\tswitch (err) {\n\tcase 0:  \n\t\tnfs4_inc_and_copy_stateid(&lock->lk_resp_stateid, &lock_stp->st_stid);\n\t\tstatus = 0;\n\t\tif (lock->lk_reclaim)\n\t\t\tnn->somebody_reclaimed = true;\n\t\tbreak;\n\tcase FILE_LOCK_DEFERRED:\n\t\tkref_put(&nbl->nbl_kref, free_nbl);\n\t\tnbl = NULL;\n\t\tfallthrough;\n\tcase -EAGAIN:\t\t \n\t\tstatus = nfserr_denied;\n\t\tdprintk(\"NFSD: nfsd4_lock: conflicting lock found!\\n\");\n\t\tnfs4_set_lock_denied(conflock, &lock->lk_denied);\n\t\tbreak;\n\tcase -EDEADLK:\n\t\tstatus = nfserr_deadlock;\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"NFSD: nfsd4_lock: vfs_lock_file() failed! status %d\\n\",err);\n\t\tstatus = nfserrno(err);\n\t\tbreak;\n\t}\nout:\n\tif (nbl) {\n\t\t \n\t\tif (fl_flags & FL_SLEEP) {\n\t\t\tspin_lock(&nn->blocked_locks_lock);\n\t\t\tif (!list_empty(&nbl->nbl_list) &&\n\t\t\t    !list_empty(&nbl->nbl_lru)) {\n\t\t\t\tlist_del_init(&nbl->nbl_list);\n\t\t\t\tlist_del_init(&nbl->nbl_lru);\n\t\t\t\tkref_put(&nbl->nbl_kref, free_nbl);\n\t\t\t}\n\t\t\t \n\t\t\tspin_unlock(&nn->blocked_locks_lock);\n\t\t}\n\t\tfree_blocked_lock(nbl);\n\t}\n\tif (nf)\n\t\tnfsd_file_put(nf);\n\tif (lock_stp) {\n\t\t \n\t\tif (cstate->replay_owner &&\n\t\t    cstate->replay_owner != &lock_sop->lo_owner &&\n\t\t    seqid_mutating_err(ntohl(status)))\n\t\t\tlock_sop->lo_owner.so_seqid++;\n\n\t\t \n\t\tif (status && new)\n\t\t\trelease_lock_stateid(lock_stp);\n\n\t\tmutex_unlock(&lock_stp->st_mutex);\n\n\t\tnfs4_put_stid(&lock_stp->st_stid);\n\t}\n\tif (open_stp)\n\t\tnfs4_put_stid(&open_stp->st_stid);\n\tnfsd4_bump_seqid(cstate, status);\n\tif (conflock)\n\t\tlocks_free_lock(conflock);\n\treturn status;\n}\n\n \nstatic __be32 nfsd_test_lock(struct svc_rqst *rqstp, struct svc_fh *fhp, struct file_lock *lock)\n{\n\tstruct nfsd_file *nf;\n\tstruct inode *inode;\n\t__be32 err;\n\n\terr = nfsd_file_acquire(rqstp, fhp, NFSD_MAY_READ, &nf);\n\tif (err)\n\t\treturn err;\n\tinode = fhp->fh_dentry->d_inode;\n\tinode_lock(inode);  \n\terr = nfserrno(nfsd_open_break_lease(inode, NFSD_MAY_READ));\n\tif (err)\n\t\tgoto out;\n\tlock->fl_file = nf->nf_file;\n\terr = nfserrno(vfs_test_lock(nf->nf_file, lock));\n\tlock->fl_file = NULL;\nout:\n\tinode_unlock(inode);\n\tnfsd_file_put(nf);\n\treturn err;\n}\n\n \n__be32\nnfsd4_lockt(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t    union nfsd4_op_u *u)\n{\n\tstruct nfsd4_lockt *lockt = &u->lockt;\n\tstruct file_lock *file_lock = NULL;\n\tstruct nfs4_lockowner *lo = NULL;\n\t__be32 status;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tif (locks_in_grace(SVC_NET(rqstp)))\n\t\treturn nfserr_grace;\n\n\tif (check_lock_length(lockt->lt_offset, lockt->lt_length))\n\t\t return nfserr_inval;\n\n\tif (!nfsd4_has_session(cstate)) {\n\t\tstatus = set_client(&lockt->lt_clientid, cstate, nn);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\tif ((status = fh_verify(rqstp, &cstate->current_fh, S_IFREG, 0)))\n\t\tgoto out;\n\n\tfile_lock = locks_alloc_lock();\n\tif (!file_lock) {\n\t\tdprintk(\"NFSD: %s: unable to allocate lock!\\n\", __func__);\n\t\tstatus = nfserr_jukebox;\n\t\tgoto out;\n\t}\n\n\tswitch (lockt->lt_type) {\n\t\tcase NFS4_READ_LT:\n\t\tcase NFS4_READW_LT:\n\t\t\tfile_lock->fl_type = F_RDLCK;\n\t\t\tbreak;\n\t\tcase NFS4_WRITE_LT:\n\t\tcase NFS4_WRITEW_LT:\n\t\t\tfile_lock->fl_type = F_WRLCK;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdprintk(\"NFSD: nfs4_lockt: bad lock type!\\n\");\n\t\t\tstatus = nfserr_inval;\n\t\t\tgoto out;\n\t}\n\n\tlo = find_lockowner_str(cstate->clp, &lockt->lt_owner);\n\tif (lo)\n\t\tfile_lock->fl_owner = (fl_owner_t)lo;\n\tfile_lock->fl_pid = current->tgid;\n\tfile_lock->fl_flags = FL_POSIX;\n\n\tfile_lock->fl_start = lockt->lt_offset;\n\tfile_lock->fl_end = last_byte_offset(lockt->lt_offset, lockt->lt_length);\n\n\tnfs4_transform_lock_offset(file_lock);\n\n\tstatus = nfsd_test_lock(rqstp, &cstate->current_fh, file_lock);\n\tif (status)\n\t\tgoto out;\n\n\tif (file_lock->fl_type != F_UNLCK) {\n\t\tstatus = nfserr_denied;\n\t\tnfs4_set_lock_denied(file_lock, &lockt->lt_denied);\n\t}\nout:\n\tif (lo)\n\t\tnfs4_put_stateowner(&lo->lo_owner);\n\tif (file_lock)\n\t\tlocks_free_lock(file_lock);\n\treturn status;\n}\n\n__be32\nnfsd4_locku(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t    union nfsd4_op_u *u)\n{\n\tstruct nfsd4_locku *locku = &u->locku;\n\tstruct nfs4_ol_stateid *stp;\n\tstruct nfsd_file *nf = NULL;\n\tstruct file_lock *file_lock = NULL;\n\t__be32 status;\n\tint err;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tdprintk(\"NFSD: nfsd4_locku: start=%Ld length=%Ld\\n\",\n\t\t(long long) locku->lu_offset,\n\t\t(long long) locku->lu_length);\n\n\tif (check_lock_length(locku->lu_offset, locku->lu_length))\n\t\t return nfserr_inval;\n\n\tstatus = nfs4_preprocess_seqid_op(cstate, locku->lu_seqid,\n\t\t\t\t\t&locku->lu_stateid, NFS4_LOCK_STID,\n\t\t\t\t\t&stp, nn);\n\tif (status)\n\t\tgoto out;\n\tnf = find_any_file(stp->st_stid.sc_file);\n\tif (!nf) {\n\t\tstatus = nfserr_lock_range;\n\t\tgoto put_stateid;\n\t}\n\tfile_lock = locks_alloc_lock();\n\tif (!file_lock) {\n\t\tdprintk(\"NFSD: %s: unable to allocate lock!\\n\", __func__);\n\t\tstatus = nfserr_jukebox;\n\t\tgoto put_file;\n\t}\n\n\tfile_lock->fl_type = F_UNLCK;\n\tfile_lock->fl_owner = (fl_owner_t)lockowner(nfs4_get_stateowner(stp->st_stateowner));\n\tfile_lock->fl_pid = current->tgid;\n\tfile_lock->fl_file = nf->nf_file;\n\tfile_lock->fl_flags = FL_POSIX;\n\tfile_lock->fl_lmops = &nfsd_posix_mng_ops;\n\tfile_lock->fl_start = locku->lu_offset;\n\n\tfile_lock->fl_end = last_byte_offset(locku->lu_offset,\n\t\t\t\t\t\tlocku->lu_length);\n\tnfs4_transform_lock_offset(file_lock);\n\n\terr = vfs_lock_file(nf->nf_file, F_SETLK, file_lock, NULL);\n\tif (err) {\n\t\tdprintk(\"NFSD: nfs4_locku: vfs_lock_file failed!\\n\");\n\t\tgoto out_nfserr;\n\t}\n\tnfs4_inc_and_copy_stateid(&locku->lu_stateid, &stp->st_stid);\nput_file:\n\tnfsd_file_put(nf);\nput_stateid:\n\tmutex_unlock(&stp->st_mutex);\n\tnfs4_put_stid(&stp->st_stid);\nout:\n\tnfsd4_bump_seqid(cstate, status);\n\tif (file_lock)\n\t\tlocks_free_lock(file_lock);\n\treturn status;\n\nout_nfserr:\n\tstatus = nfserrno(err);\n\tgoto put_file;\n}\n\n \nstatic bool\ncheck_for_locks(struct nfs4_file *fp, struct nfs4_lockowner *lowner)\n{\n\tstruct file_lock *fl;\n\tint status = false;\n\tstruct nfsd_file *nf = find_any_file(fp);\n\tstruct inode *inode;\n\tstruct file_lock_context *flctx;\n\n\tif (!nf) {\n\t\t \n\t\tWARN_ON_ONCE(1);\n\t\treturn status;\n\t}\n\n\tinode = file_inode(nf->nf_file);\n\tflctx = locks_inode_context(inode);\n\n\tif (flctx && !list_empty_careful(&flctx->flc_posix)) {\n\t\tspin_lock(&flctx->flc_lock);\n\t\tlist_for_each_entry(fl, &flctx->flc_posix, fl_list) {\n\t\t\tif (fl->fl_owner == (fl_owner_t)lowner) {\n\t\t\t\tstatus = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&flctx->flc_lock);\n\t}\n\tnfsd_file_put(nf);\n\treturn status;\n}\n\n \n__be32\nnfsd4_release_lockowner(struct svc_rqst *rqstp,\n\t\t\tstruct nfsd4_compound_state *cstate,\n\t\t\tunion nfsd4_op_u *u)\n{\n\tstruct nfsd4_release_lockowner *rlockowner = &u->release_lockowner;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\tclientid_t *clid = &rlockowner->rl_clientid;\n\tstruct nfs4_ol_stateid *stp;\n\tstruct nfs4_lockowner *lo;\n\tstruct nfs4_client *clp;\n\tLIST_HEAD(reaplist);\n\t__be32 status;\n\n\tdprintk(\"nfsd4_release_lockowner clientid: (%08x/%08x):\\n\",\n\t\tclid->cl_boot, clid->cl_id);\n\n\tstatus = set_client(clid, cstate, nn);\n\tif (status)\n\t\treturn status;\n\tclp = cstate->clp;\n\n\tspin_lock(&clp->cl_lock);\n\tlo = find_lockowner_str_locked(clp, &rlockowner->rl_owner);\n\tif (!lo) {\n\t\tspin_unlock(&clp->cl_lock);\n\t\treturn nfs_ok;\n\t}\n\tif (atomic_read(&lo->lo_owner.so_count) != 2) {\n\t\tspin_unlock(&clp->cl_lock);\n\t\tnfs4_put_stateowner(&lo->lo_owner);\n\t\treturn nfserr_locks_held;\n\t}\n\tunhash_lockowner_locked(lo);\n\twhile (!list_empty(&lo->lo_owner.so_stateids)) {\n\t\tstp = list_first_entry(&lo->lo_owner.so_stateids,\n\t\t\t\t       struct nfs4_ol_stateid,\n\t\t\t\t       st_perstateowner);\n\t\tWARN_ON(!unhash_lock_stateid(stp));\n\t\tput_ol_stateid_locked(stp, &reaplist);\n\t}\n\tspin_unlock(&clp->cl_lock);\n\n\tfree_ol_stateid_reaplist(&reaplist);\n\tremove_blocked_locks(lo);\n\tnfs4_put_stateowner(&lo->lo_owner);\n\treturn nfs_ok;\n}\n\nstatic inline struct nfs4_client_reclaim *\nalloc_reclaim(void)\n{\n\treturn kmalloc(sizeof(struct nfs4_client_reclaim), GFP_KERNEL);\n}\n\nbool\nnfs4_has_reclaimed_state(struct xdr_netobj name, struct nfsd_net *nn)\n{\n\tstruct nfs4_client_reclaim *crp;\n\n\tcrp = nfsd4_find_reclaim_client(name, nn);\n\treturn (crp && crp->cr_clp);\n}\n\n \nstruct nfs4_client_reclaim *\nnfs4_client_to_reclaim(struct xdr_netobj name, struct xdr_netobj princhash,\n\t\tstruct nfsd_net *nn)\n{\n\tunsigned int strhashval;\n\tstruct nfs4_client_reclaim *crp;\n\n\tcrp = alloc_reclaim();\n\tif (crp) {\n\t\tstrhashval = clientstr_hashval(name);\n\t\tINIT_LIST_HEAD(&crp->cr_strhash);\n\t\tlist_add(&crp->cr_strhash, &nn->reclaim_str_hashtbl[strhashval]);\n\t\tcrp->cr_name.data = name.data;\n\t\tcrp->cr_name.len = name.len;\n\t\tcrp->cr_princhash.data = princhash.data;\n\t\tcrp->cr_princhash.len = princhash.len;\n\t\tcrp->cr_clp = NULL;\n\t\tnn->reclaim_str_hashtbl_size++;\n\t}\n\treturn crp;\n}\n\nvoid\nnfs4_remove_reclaim_record(struct nfs4_client_reclaim *crp, struct nfsd_net *nn)\n{\n\tlist_del(&crp->cr_strhash);\n\tkfree(crp->cr_name.data);\n\tkfree(crp->cr_princhash.data);\n\tkfree(crp);\n\tnn->reclaim_str_hashtbl_size--;\n}\n\nvoid\nnfs4_release_reclaim(struct nfsd_net *nn)\n{\n\tstruct nfs4_client_reclaim *crp = NULL;\n\tint i;\n\n\tfor (i = 0; i < CLIENT_HASH_SIZE; i++) {\n\t\twhile (!list_empty(&nn->reclaim_str_hashtbl[i])) {\n\t\t\tcrp = list_entry(nn->reclaim_str_hashtbl[i].next,\n\t\t\t                struct nfs4_client_reclaim, cr_strhash);\n\t\t\tnfs4_remove_reclaim_record(crp, nn);\n\t\t}\n\t}\n\tWARN_ON_ONCE(nn->reclaim_str_hashtbl_size);\n}\n\n \nstruct nfs4_client_reclaim *\nnfsd4_find_reclaim_client(struct xdr_netobj name, struct nfsd_net *nn)\n{\n\tunsigned int strhashval;\n\tstruct nfs4_client_reclaim *crp = NULL;\n\n\tstrhashval = clientstr_hashval(name);\n\tlist_for_each_entry(crp, &nn->reclaim_str_hashtbl[strhashval], cr_strhash) {\n\t\tif (compare_blob(&crp->cr_name, &name) == 0) {\n\t\t\treturn crp;\n\t\t}\n\t}\n\treturn NULL;\n}\n\n__be32\nnfs4_check_open_reclaim(struct nfs4_client *clp)\n{\n\tif (test_bit(NFSD4_CLIENT_RECLAIM_COMPLETE, &clp->cl_flags))\n\t\treturn nfserr_no_grace;\n\n\tif (nfsd4_client_record_check(clp))\n\t\treturn nfserr_reclaim_bad;\n\n\treturn nfs_ok;\n}\n\n \nstatic void\nset_max_delegations(void)\n{\n\t \n\tmax_delegations = nr_free_buffer_pages() >> (20 - 2 - PAGE_SHIFT);\n}\n\nstatic int nfs4_state_create_net(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint i;\n\n\tnn->conf_id_hashtbl = kmalloc_array(CLIENT_HASH_SIZE,\n\t\t\t\t\t    sizeof(struct list_head),\n\t\t\t\t\t    GFP_KERNEL);\n\tif (!nn->conf_id_hashtbl)\n\t\tgoto err;\n\tnn->unconf_id_hashtbl = kmalloc_array(CLIENT_HASH_SIZE,\n\t\t\t\t\t      sizeof(struct list_head),\n\t\t\t\t\t      GFP_KERNEL);\n\tif (!nn->unconf_id_hashtbl)\n\t\tgoto err_unconf_id;\n\tnn->sessionid_hashtbl = kmalloc_array(SESSION_HASH_SIZE,\n\t\t\t\t\t      sizeof(struct list_head),\n\t\t\t\t\t      GFP_KERNEL);\n\tif (!nn->sessionid_hashtbl)\n\t\tgoto err_sessionid;\n\n\tfor (i = 0; i < CLIENT_HASH_SIZE; i++) {\n\t\tINIT_LIST_HEAD(&nn->conf_id_hashtbl[i]);\n\t\tINIT_LIST_HEAD(&nn->unconf_id_hashtbl[i]);\n\t}\n\tfor (i = 0; i < SESSION_HASH_SIZE; i++)\n\t\tINIT_LIST_HEAD(&nn->sessionid_hashtbl[i]);\n\tnn->conf_name_tree = RB_ROOT;\n\tnn->unconf_name_tree = RB_ROOT;\n\tnn->boot_time = ktime_get_real_seconds();\n\tnn->grace_ended = false;\n\tnn->nfsd4_manager.block_opens = true;\n\tINIT_LIST_HEAD(&nn->nfsd4_manager.list);\n\tINIT_LIST_HEAD(&nn->client_lru);\n\tINIT_LIST_HEAD(&nn->close_lru);\n\tINIT_LIST_HEAD(&nn->del_recall_lru);\n\tspin_lock_init(&nn->client_lock);\n\tspin_lock_init(&nn->s2s_cp_lock);\n\tidr_init(&nn->s2s_cp_stateids);\n\n\tspin_lock_init(&nn->blocked_locks_lock);\n\tINIT_LIST_HEAD(&nn->blocked_locks_lru);\n\n\tINIT_DELAYED_WORK(&nn->laundromat_work, laundromat_main);\n\tINIT_WORK(&nn->nfsd_shrinker_work, nfsd4_state_shrinker_worker);\n\tget_net(net);\n\n\tnn->nfsd_client_shrinker.scan_objects = nfsd4_state_shrinker_scan;\n\tnn->nfsd_client_shrinker.count_objects = nfsd4_state_shrinker_count;\n\tnn->nfsd_client_shrinker.seeks = DEFAULT_SEEKS;\n\n\tif (register_shrinker(&nn->nfsd_client_shrinker, \"nfsd-client\"))\n\t\tgoto err_shrinker;\n\treturn 0;\n\nerr_shrinker:\n\tput_net(net);\n\tkfree(nn->sessionid_hashtbl);\nerr_sessionid:\n\tkfree(nn->unconf_id_hashtbl);\nerr_unconf_id:\n\tkfree(nn->conf_id_hashtbl);\nerr:\n\treturn -ENOMEM;\n}\n\nstatic void\nnfs4_state_destroy_net(struct net *net)\n{\n\tint i;\n\tstruct nfs4_client *clp = NULL;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tfor (i = 0; i < CLIENT_HASH_SIZE; i++) {\n\t\twhile (!list_empty(&nn->conf_id_hashtbl[i])) {\n\t\t\tclp = list_entry(nn->conf_id_hashtbl[i].next, struct nfs4_client, cl_idhash);\n\t\t\tdestroy_client(clp);\n\t\t}\n\t}\n\n\tWARN_ON(!list_empty(&nn->blocked_locks_lru));\n\n\tfor (i = 0; i < CLIENT_HASH_SIZE; i++) {\n\t\twhile (!list_empty(&nn->unconf_id_hashtbl[i])) {\n\t\t\tclp = list_entry(nn->unconf_id_hashtbl[i].next, struct nfs4_client, cl_idhash);\n\t\t\tdestroy_client(clp);\n\t\t}\n\t}\n\n\tkfree(nn->sessionid_hashtbl);\n\tkfree(nn->unconf_id_hashtbl);\n\tkfree(nn->conf_id_hashtbl);\n\tput_net(net);\n}\n\nint\nnfs4_state_start_net(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint ret;\n\n\tret = nfs4_state_create_net(net);\n\tif (ret)\n\t\treturn ret;\n\tlocks_start_grace(net, &nn->nfsd4_manager);\n\tnfsd4_client_tracking_init(net);\n\tif (nn->track_reclaim_completes && nn->reclaim_str_hashtbl_size == 0)\n\t\tgoto skip_grace;\n\tprintk(KERN_INFO \"NFSD: starting %lld-second grace period (net %x)\\n\",\n\t       nn->nfsd4_grace, net->ns.inum);\n\ttrace_nfsd_grace_start(nn);\n\tqueue_delayed_work(laundry_wq, &nn->laundromat_work, nn->nfsd4_grace * HZ);\n\treturn 0;\n\nskip_grace:\n\tprintk(KERN_INFO \"NFSD: no clients to reclaim, skipping NFSv4 grace period (net %x)\\n\",\n\t\t\tnet->ns.inum);\n\tqueue_delayed_work(laundry_wq, &nn->laundromat_work, nn->nfsd4_lease * HZ);\n\tnfsd4_end_grace(nn);\n\treturn 0;\n}\n\n \n\nint\nnfs4_state_start(void)\n{\n\tint ret;\n\n\tret = rhltable_init(&nfs4_file_rhltable, &nfs4_file_rhash_params);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nfsd4_create_callback_queue();\n\tif (ret) {\n\t\trhltable_destroy(&nfs4_file_rhltable);\n\t\treturn ret;\n\t}\n\n\tset_max_delegations();\n\treturn 0;\n}\n\nvoid\nnfs4_state_shutdown_net(struct net *net)\n{\n\tstruct nfs4_delegation *dp = NULL;\n\tstruct list_head *pos, *next, reaplist;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tunregister_shrinker(&nn->nfsd_client_shrinker);\n\tcancel_work(&nn->nfsd_shrinker_work);\n\tcancel_delayed_work_sync(&nn->laundromat_work);\n\tlocks_end_grace(&nn->nfsd4_manager);\n\n\tINIT_LIST_HEAD(&reaplist);\n\tspin_lock(&state_lock);\n\tlist_for_each_safe(pos, next, &nn->del_recall_lru) {\n\t\tdp = list_entry (pos, struct nfs4_delegation, dl_recall_lru);\n\t\tWARN_ON(!unhash_delegation_locked(dp));\n\t\tlist_add(&dp->dl_recall_lru, &reaplist);\n\t}\n\tspin_unlock(&state_lock);\n\tlist_for_each_safe(pos, next, &reaplist) {\n\t\tdp = list_entry (pos, struct nfs4_delegation, dl_recall_lru);\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tdestroy_unhashed_deleg(dp);\n\t}\n\n\tnfsd4_client_tracking_exit(net);\n\tnfs4_state_destroy_net(net);\n#ifdef CONFIG_NFSD_V4_2_INTER_SSC\n\tnfsd4_ssc_shutdown_umount(nn);\n#endif\n}\n\nvoid\nnfs4_state_shutdown(void)\n{\n\tnfsd4_destroy_callback_queue();\n\trhltable_destroy(&nfs4_file_rhltable);\n}\n\nstatic void\nget_stateid(struct nfsd4_compound_state *cstate, stateid_t *stateid)\n{\n\tif (HAS_CSTATE_FLAG(cstate, CURRENT_STATE_ID_FLAG) &&\n\t    CURRENT_STATEID(stateid))\n\t\tmemcpy(stateid, &cstate->current_stateid, sizeof(stateid_t));\n}\n\nstatic void\nput_stateid(struct nfsd4_compound_state *cstate, stateid_t *stateid)\n{\n\tif (cstate->minorversion) {\n\t\tmemcpy(&cstate->current_stateid, stateid, sizeof(stateid_t));\n\t\tSET_CSTATE_FLAG(cstate, CURRENT_STATE_ID_FLAG);\n\t}\n}\n\nvoid\nclear_current_stateid(struct nfsd4_compound_state *cstate)\n{\n\tCLEAR_CSTATE_FLAG(cstate, CURRENT_STATE_ID_FLAG);\n}\n\n \nvoid\nnfsd4_set_opendowngradestateid(struct nfsd4_compound_state *cstate,\n\t\tunion nfsd4_op_u *u)\n{\n\tput_stateid(cstate, &u->open_downgrade.od_stateid);\n}\n\nvoid\nnfsd4_set_openstateid(struct nfsd4_compound_state *cstate,\n\t\tunion nfsd4_op_u *u)\n{\n\tput_stateid(cstate, &u->open.op_stateid);\n}\n\nvoid\nnfsd4_set_closestateid(struct nfsd4_compound_state *cstate,\n\t\tunion nfsd4_op_u *u)\n{\n\tput_stateid(cstate, &u->close.cl_stateid);\n}\n\nvoid\nnfsd4_set_lockstateid(struct nfsd4_compound_state *cstate,\n\t\tunion nfsd4_op_u *u)\n{\n\tput_stateid(cstate, &u->lock.lk_resp_stateid);\n}\n\n \n\nvoid\nnfsd4_get_opendowngradestateid(struct nfsd4_compound_state *cstate,\n\t\tunion nfsd4_op_u *u)\n{\n\tget_stateid(cstate, &u->open_downgrade.od_stateid);\n}\n\nvoid\nnfsd4_get_delegreturnstateid(struct nfsd4_compound_state *cstate,\n\t\tunion nfsd4_op_u *u)\n{\n\tget_stateid(cstate, &u->delegreturn.dr_stateid);\n}\n\nvoid\nnfsd4_get_freestateid(struct nfsd4_compound_state *cstate,\n\t\tunion nfsd4_op_u *u)\n{\n\tget_stateid(cstate, &u->free_stateid.fr_stateid);\n}\n\nvoid\nnfsd4_get_setattrstateid(struct nfsd4_compound_state *cstate,\n\t\tunion nfsd4_op_u *u)\n{\n\tget_stateid(cstate, &u->setattr.sa_stateid);\n}\n\nvoid\nnfsd4_get_closestateid(struct nfsd4_compound_state *cstate,\n\t\tunion nfsd4_op_u *u)\n{\n\tget_stateid(cstate, &u->close.cl_stateid);\n}\n\nvoid\nnfsd4_get_lockustateid(struct nfsd4_compound_state *cstate,\n\t\tunion nfsd4_op_u *u)\n{\n\tget_stateid(cstate, &u->locku.lu_stateid);\n}\n\nvoid\nnfsd4_get_readstateid(struct nfsd4_compound_state *cstate,\n\t\tunion nfsd4_op_u *u)\n{\n\tget_stateid(cstate, &u->read.rd_stateid);\n}\n\nvoid\nnfsd4_get_writestateid(struct nfsd4_compound_state *cstate,\n\t\tunion nfsd4_op_u *u)\n{\n\tget_stateid(cstate, &u->write.wr_stateid);\n}\n\n \n__be32\nnfsd4_deleg_getattr_conflict(struct svc_rqst *rqstp, struct inode *inode)\n{\n\t__be32 status;\n\tstruct file_lock_context *ctx;\n\tstruct file_lock *fl;\n\tstruct nfs4_delegation *dp;\n\n\tctx = locks_inode_context(inode);\n\tif (!ctx)\n\t\treturn 0;\n\tspin_lock(&ctx->flc_lock);\n\tlist_for_each_entry(fl, &ctx->flc_lease, fl_list) {\n\t\tif (fl->fl_flags == FL_LAYOUT)\n\t\t\tcontinue;\n\t\tif (fl->fl_lmops != &nfsd_lease_mng_ops) {\n\t\t\t \n\t\t\tif (fl->fl_type == F_RDLCK)\n\t\t\t\tbreak;\n\t\t\tgoto break_lease;\n\t\t}\n\t\tif (fl->fl_type == F_WRLCK) {\n\t\t\tdp = fl->fl_owner;\n\t\t\tif (dp->dl_recall.cb_clp == *(rqstp->rq_lease_breaker)) {\n\t\t\t\tspin_unlock(&ctx->flc_lock);\n\t\t\t\treturn 0;\n\t\t\t}\nbreak_lease:\n\t\t\tspin_unlock(&ctx->flc_lock);\n\t\t\tnfsd_stats_wdeleg_getattr_inc();\n\t\t\tstatus = nfserrno(nfsd_open_break_lease(inode, NFSD_MAY_READ));\n\t\t\tif (status != nfserr_jukebox ||\n\t\t\t\t\t!nfsd_wait_for_delegreturn(rqstp, inode))\n\t\t\t\treturn status;\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\t}\n\tspin_unlock(&ctx->flc_lock);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}