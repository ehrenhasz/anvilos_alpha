{
  "module_name": "flexfilelayout.c",
  "hash_id": "e58877000a7e09be5484e34800316cfc7357a02bdf2d9c3e5116f541a1a44aff",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfsd/flexfilelayout.c",
  "human_readable_source": "\n \n#include <linux/slab.h>\n\n#include <linux/nfsd/debug.h>\n\n#include <linux/sunrpc/addr.h>\n\n#include \"flexfilelayoutxdr.h\"\n#include \"pnfs.h\"\n#include \"vfs.h\"\n\n#define NFSDDBG_FACILITY\tNFSDDBG_PNFS\n\nstatic __be32\nnfsd4_ff_proc_layoutget(struct inode *inode, const struct svc_fh *fhp,\n\t\tstruct nfsd4_layoutget *args)\n{\n\tstruct nfsd4_layout_seg *seg = &args->lg_seg;\n\tu32 device_generation = 0;\n\tint error;\n\tuid_t u;\n\n\tstruct pnfs_ff_layout *fl;\n\n\t \n\terror = -ENOMEM;\n\tfl = kzalloc(sizeof(*fl), GFP_KERNEL);\n\tif (!fl)\n\t\tgoto out_error;\n\targs->lg_content = fl;\n\n\t \n\tfl->flags = FF_FLAGS_NO_LAYOUTCOMMIT | FF_FLAGS_NO_IO_THRU_MDS |\n\t\t    FF_FLAGS_NO_READ_IO;\n\n\t \n\tif (seg->iomode == IOMODE_READ) {\n\t\tu = from_kuid(&init_user_ns, inode->i_uid) + 1;\n\t\tfl->uid = make_kuid(&init_user_ns, u);\n\t} else\n\t\tfl->uid = inode->i_uid;\n\tfl->gid = inode->i_gid;\n\n\terror = nfsd4_set_deviceid(&fl->deviceid, fhp, device_generation);\n\tif (error)\n\t\tgoto out_error;\n\n\tfl->fh.size = fhp->fh_handle.fh_size;\n\tmemcpy(fl->fh.data, &fhp->fh_handle.fh_raw, fl->fh.size);\n\n\t \n\tseg->offset = 0;\n\tseg->length = NFS4_MAX_UINT64;\n\n\tdprintk(\"GET: 0x%llx:0x%llx %d\\n\", seg->offset, seg->length,\n\t\tseg->iomode);\n\treturn 0;\n\nout_error:\n\tseg->length = 0;\n\treturn nfserrno(error);\n}\n\nstatic __be32\nnfsd4_ff_proc_getdeviceinfo(struct super_block *sb, struct svc_rqst *rqstp,\n\t\tstruct nfs4_client *clp, struct nfsd4_getdeviceinfo *gdp)\n{\n\tstruct pnfs_ff_device_addr *da;\n\n\tu16 port;\n\tchar addr[INET6_ADDRSTRLEN];\n\n\tda = kzalloc(sizeof(struct pnfs_ff_device_addr), GFP_KERNEL);\n\tif (!da)\n\t\treturn nfserrno(-ENOMEM);\n\n\tgdp->gd_device = da;\n\n\tda->version = 3;\n\tda->minor_version = 0;\n\n\tda->rsize = svc_max_payload(rqstp);\n\tda->wsize = da->rsize;\n\n\trpc_ntop((struct sockaddr *)&rqstp->rq_daddr,\n\t\t addr, INET6_ADDRSTRLEN);\n\tif (rqstp->rq_daddr.ss_family == AF_INET) {\n\t\tstruct sockaddr_in *sin;\n\n\t\tsin = (struct sockaddr_in *)&rqstp->rq_daddr;\n\t\tport = ntohs(sin->sin_port);\n\t\tsnprintf(da->netaddr.netid, FF_NETID_LEN + 1, \"tcp\");\n\t\tda->netaddr.netid_len = 3;\n\t} else {\n\t\tstruct sockaddr_in6 *sin6;\n\n\t\tsin6 = (struct sockaddr_in6 *)&rqstp->rq_daddr;\n\t\tport = ntohs(sin6->sin6_port);\n\t\tsnprintf(da->netaddr.netid, FF_NETID_LEN + 1, \"tcp6\");\n\t\tda->netaddr.netid_len = 4;\n\t}\n\n\tda->netaddr.addr_len =\n\t\tsnprintf(da->netaddr.addr, FF_ADDR_LEN + 1,\n\t\t\t \"%s.%d.%d\", addr, port >> 8, port & 0xff);\n\n\tda->tightly_coupled = false;\n\n\treturn 0;\n}\n\nconst struct nfsd4_layout_ops ff_layout_ops = {\n\t.notify_types\t\t=\n\t\t\tNOTIFY_DEVICEID4_DELETE | NOTIFY_DEVICEID4_CHANGE,\n\t.disable_recalls\t= true,\n\t.proc_getdeviceinfo\t= nfsd4_ff_proc_getdeviceinfo,\n\t.encode_getdeviceinfo\t= nfsd4_ff_encode_getdeviceinfo,\n\t.proc_layoutget\t\t= nfsd4_ff_proc_layoutget,\n\t.encode_layoutget\t= nfsd4_ff_encode_layoutget,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}