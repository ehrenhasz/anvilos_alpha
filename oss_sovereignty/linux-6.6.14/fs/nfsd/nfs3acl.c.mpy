{
  "module_name": "nfs3acl.c",
  "hash_id": "da8ae99fd43f5b4e756f6433d46fa7fad3b4aaecc53d393334617718a7c02ad2",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfsd/nfs3acl.c",
  "human_readable_source": "\n \n\n#include \"nfsd.h\"\n \n#include <linux/nfsacl.h>\n#include <linux/gfp.h>\n#include \"cache.h\"\n#include \"xdr3.h\"\n#include \"vfs.h\"\n\n \nstatic __be32\nnfsd3_proc_null(struct svc_rqst *rqstp)\n{\n\treturn rpc_success;\n}\n\n \nstatic __be32 nfsd3_proc_getacl(struct svc_rqst *rqstp)\n{\n\tstruct nfsd3_getaclargs *argp = rqstp->rq_argp;\n\tstruct nfsd3_getaclres *resp = rqstp->rq_resp;\n\tstruct posix_acl *acl;\n\tstruct inode *inode;\n\tsvc_fh *fh;\n\n\tfh = fh_copy(&resp->fh, &argp->fh);\n\tresp->status = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_NOP);\n\tif (resp->status != nfs_ok)\n\t\tgoto out;\n\n\tinode = d_inode(fh->fh_dentry);\n\n\tif (argp->mask & ~NFS_ACL_MASK) {\n\t\tresp->status = nfserr_inval;\n\t\tgoto out;\n\t}\n\tresp->mask = argp->mask;\n\n\tif (resp->mask & (NFS_ACL|NFS_ACLCNT)) {\n\t\tacl = get_inode_acl(inode, ACL_TYPE_ACCESS);\n\t\tif (acl == NULL) {\n\t\t\t \n\t\t\tacl = posix_acl_from_mode(inode->i_mode, GFP_KERNEL);\n\t\t}\n\t\tif (IS_ERR(acl)) {\n\t\t\tresp->status = nfserrno(PTR_ERR(acl));\n\t\t\tgoto fail;\n\t\t}\n\t\tresp->acl_access = acl;\n\t}\n\tif (resp->mask & (NFS_DFACL|NFS_DFACLCNT)) {\n\t\t \n\t\tacl = get_inode_acl(inode, ACL_TYPE_DEFAULT);\n\t\tif (IS_ERR(acl)) {\n\t\t\tresp->status = nfserrno(PTR_ERR(acl));\n\t\t\tgoto fail;\n\t\t}\n\t\tresp->acl_default = acl;\n\t}\n\n\t \nout:\n\treturn rpc_success;\n\nfail:\n\tposix_acl_release(resp->acl_access);\n\tposix_acl_release(resp->acl_default);\n\tgoto out;\n}\n\n \nstatic __be32 nfsd3_proc_setacl(struct svc_rqst *rqstp)\n{\n\tstruct nfsd3_setaclargs *argp = rqstp->rq_argp;\n\tstruct nfsd3_attrstat *resp = rqstp->rq_resp;\n\tstruct inode *inode;\n\tsvc_fh *fh;\n\tint error;\n\n\tfh = fh_copy(&resp->fh, &argp->fh);\n\tresp->status = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_SATTR);\n\tif (resp->status != nfs_ok)\n\t\tgoto out;\n\n\tinode = d_inode(fh->fh_dentry);\n\n\terror = fh_want_write(fh);\n\tif (error)\n\t\tgoto out_errno;\n\n\tinode_lock(inode);\n\n\terror = set_posix_acl(&nop_mnt_idmap, fh->fh_dentry, ACL_TYPE_ACCESS,\n\t\t\t      argp->acl_access);\n\tif (error)\n\t\tgoto out_drop_lock;\n\terror = set_posix_acl(&nop_mnt_idmap, fh->fh_dentry, ACL_TYPE_DEFAULT,\n\t\t\t      argp->acl_default);\n\nout_drop_lock:\n\tinode_unlock(inode);\n\tfh_drop_write(fh);\nout_errno:\n\tresp->status = nfserrno(error);\nout:\n\t \n\tposix_acl_release(argp->acl_access);\n\tposix_acl_release(argp->acl_default);\n\treturn rpc_success;\n}\n\n \n\nstatic bool\nnfs3svc_decode_getaclargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nfsd3_getaclargs *args = rqstp->rq_argp;\n\n\tif (!svcxdr_decode_nfs_fh3(xdr, &args->fh))\n\t\treturn false;\n\tif (xdr_stream_decode_u32(xdr, &args->mask) < 0)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool\nnfs3svc_decode_setaclargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nfsd3_setaclargs *argp = rqstp->rq_argp;\n\n\tif (!svcxdr_decode_nfs_fh3(xdr, &argp->fh))\n\t\treturn false;\n\tif (xdr_stream_decode_u32(xdr, &argp->mask) < 0)\n\t\treturn false;\n\tif (argp->mask & ~NFS_ACL_MASK)\n\t\treturn false;\n\tif (!nfs_stream_decode_acl(xdr, NULL, (argp->mask & NFS_ACL) ?\n\t\t\t\t   &argp->acl_access : NULL))\n\t\treturn false;\n\tif (!nfs_stream_decode_acl(xdr, NULL, (argp->mask & NFS_DFACL) ?\n\t\t\t\t   &argp->acl_default : NULL))\n\t\treturn false;\n\n\treturn true;\n}\n\n \n\n \nstatic bool\nnfs3svc_encode_getaclres(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nfsd3_getaclres *resp = rqstp->rq_resp;\n\tstruct dentry *dentry = resp->fh.fh_dentry;\n\tstruct inode *inode;\n\n\tif (!svcxdr_encode_nfsstat3(xdr, resp->status))\n\t\treturn false;\n\tswitch (resp->status) {\n\tcase nfs_ok:\n\t\tinode = d_inode(dentry);\n\t\tif (!svcxdr_encode_post_op_attr(rqstp, xdr, &resp->fh))\n\t\t\treturn false;\n\t\tif (xdr_stream_encode_u32(xdr, resp->mask) < 0)\n\t\t\treturn false;\n\n\t\tif (!nfs_stream_encode_acl(xdr, inode, resp->acl_access,\n\t\t\t\t\t   resp->mask & NFS_ACL, 0))\n\t\t\treturn false;\n\t\tif (!nfs_stream_encode_acl(xdr, inode, resp->acl_default,\n\t\t\t\t\t   resp->mask & NFS_DFACL,\n\t\t\t\t\t   NFS_ACL_DEFAULT))\n\t\t\treturn false;\n\t\tbreak;\n\tdefault:\n\t\tif (!svcxdr_encode_post_op_attr(rqstp, xdr, &resp->fh))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nstatic bool\nnfs3svc_encode_setaclres(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nfsd3_attrstat *resp = rqstp->rq_resp;\n\n\treturn svcxdr_encode_nfsstat3(xdr, resp->status) &&\n\t\tsvcxdr_encode_post_op_attr(rqstp, xdr, &resp->fh);\n}\n\n \nstatic void nfs3svc_release_getacl(struct svc_rqst *rqstp)\n{\n\tstruct nfsd3_getaclres *resp = rqstp->rq_resp;\n\n\tfh_put(&resp->fh);\n\tposix_acl_release(resp->acl_access);\n\tposix_acl_release(resp->acl_default);\n}\n\nstruct nfsd3_voidargs { int dummy; };\n\n#define ST 1\t\t \n#define AT 21\t\t \n#define pAT (1+AT)\t \n#define ACL (1+NFS_ACL_MAX_ENTRIES*3)   \n\nstatic const struct svc_procedure nfsd_acl_procedures3[3] = {\n\t[ACLPROC3_NULL] = {\n\t\t.pc_func = nfsd3_proc_null,\n\t\t.pc_decode = nfssvc_decode_voidarg,\n\t\t.pc_encode = nfssvc_encode_voidres,\n\t\t.pc_argsize = sizeof(struct nfsd_voidargs),\n\t\t.pc_argzero = sizeof(struct nfsd_voidargs),\n\t\t.pc_ressize = sizeof(struct nfsd_voidres),\n\t\t.pc_cachetype = RC_NOCACHE,\n\t\t.pc_xdrressize = ST,\n\t\t.pc_name = \"NULL\",\n\t},\n\t[ACLPROC3_GETACL] = {\n\t\t.pc_func = nfsd3_proc_getacl,\n\t\t.pc_decode = nfs3svc_decode_getaclargs,\n\t\t.pc_encode = nfs3svc_encode_getaclres,\n\t\t.pc_release = nfs3svc_release_getacl,\n\t\t.pc_argsize = sizeof(struct nfsd3_getaclargs),\n\t\t.pc_argzero = sizeof(struct nfsd3_getaclargs),\n\t\t.pc_ressize = sizeof(struct nfsd3_getaclres),\n\t\t.pc_cachetype = RC_NOCACHE,\n\t\t.pc_xdrressize = ST+1+2*(1+ACL),\n\t\t.pc_name = \"GETACL\",\n\t},\n\t[ACLPROC3_SETACL] = {\n\t\t.pc_func = nfsd3_proc_setacl,\n\t\t.pc_decode = nfs3svc_decode_setaclargs,\n\t\t.pc_encode = nfs3svc_encode_setaclres,\n\t\t.pc_release = nfs3svc_release_fhandle,\n\t\t.pc_argsize = sizeof(struct nfsd3_setaclargs),\n\t\t.pc_argzero = sizeof(struct nfsd3_setaclargs),\n\t\t.pc_ressize = sizeof(struct nfsd3_attrstat),\n\t\t.pc_cachetype = RC_NOCACHE,\n\t\t.pc_xdrressize = ST+pAT,\n\t\t.pc_name = \"SETACL\",\n\t},\n};\n\nstatic DEFINE_PER_CPU_ALIGNED(unsigned long,\n\t\t\t      nfsd_acl_count3[ARRAY_SIZE(nfsd_acl_procedures3)]);\nconst struct svc_version nfsd_acl_version3 = {\n\t.vs_vers\t= 3,\n\t.vs_nproc\t= ARRAY_SIZE(nfsd_acl_procedures3),\n\t.vs_proc\t= nfsd_acl_procedures3,\n\t.vs_count\t= nfsd_acl_count3,\n\t.vs_dispatch\t= nfsd_dispatch,\n\t.vs_xdrsize\t= NFS3_SVC_XDRSIZE,\n};\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}