{
  "module_name": "blocklayout.c",
  "hash_id": "61b0ffb941225094cb871c3131f4381284cc68c760cd47877199bb637a190bbe",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfsd/blocklayout.c",
  "human_readable_source": "\n \n#include <linux/exportfs.h>\n#include <linux/iomap.h>\n#include <linux/slab.h>\n#include <linux/pr.h>\n\n#include <linux/nfsd/debug.h>\n\n#include \"blocklayoutxdr.h\"\n#include \"pnfs.h\"\n#include \"filecache.h\"\n#include \"vfs.h\"\n\n#define NFSDDBG_FACILITY\tNFSDDBG_PNFS\n\n\nstatic __be32\nnfsd4_block_proc_layoutget(struct inode *inode, const struct svc_fh *fhp,\n\t\tstruct nfsd4_layoutget *args)\n{\n\tstruct nfsd4_layout_seg *seg = &args->lg_seg;\n\tstruct super_block *sb = inode->i_sb;\n\tu32 block_size = i_blocksize(inode);\n\tstruct pnfs_block_extent *bex;\n\tstruct iomap iomap;\n\tu32 device_generation = 0;\n\tint error;\n\n\tif (seg->offset & (block_size - 1)) {\n\t\tdprintk(\"pnfsd: I/O misaligned\\n\");\n\t\tgoto out_layoutunavailable;\n\t}\n\n\t \n\terror = -ENOMEM;\n\tbex = kzalloc(sizeof(*bex), GFP_KERNEL);\n\tif (!bex)\n\t\tgoto out_error;\n\targs->lg_content = bex;\n\n\terror = sb->s_export_op->map_blocks(inode, seg->offset, seg->length,\n\t\t\t\t\t    &iomap, seg->iomode != IOMODE_READ,\n\t\t\t\t\t    &device_generation);\n\tif (error) {\n\t\tif (error == -ENXIO)\n\t\t\tgoto out_layoutunavailable;\n\t\tgoto out_error;\n\t}\n\n\tif (iomap.length < args->lg_minlength) {\n\t\tdprintk(\"pnfsd: extent smaller than minlength\\n\");\n\t\tgoto out_layoutunavailable;\n\t}\n\n\tswitch (iomap.type) {\n\tcase IOMAP_MAPPED:\n\t\tif (seg->iomode == IOMODE_READ)\n\t\t\tbex->es = PNFS_BLOCK_READ_DATA;\n\t\telse\n\t\t\tbex->es = PNFS_BLOCK_READWRITE_DATA;\n\t\tbex->soff = iomap.addr;\n\t\tbreak;\n\tcase IOMAP_UNWRITTEN:\n\t\tif (seg->iomode & IOMODE_RW) {\n\t\t\t \n\t\t\tif (args->lg_minlength == 0) {\n\t\t\t\tdprintk(\"pnfsd: no soup for you!\\n\");\n\t\t\t\tgoto out_layoutunavailable;\n\t\t\t}\n\n\t\t\tbex->es = PNFS_BLOCK_INVALID_DATA;\n\t\t\tbex->soff = iomap.addr;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase IOMAP_HOLE:\n\t\tif (seg->iomode == IOMODE_READ) {\n\t\t\tbex->es = PNFS_BLOCK_NONE_DATA;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase IOMAP_DELALLOC:\n\tdefault:\n\t\tWARN(1, \"pnfsd: filesystem returned %d extent\\n\", iomap.type);\n\t\tgoto out_layoutunavailable;\n\t}\n\n\terror = nfsd4_set_deviceid(&bex->vol_id, fhp, device_generation);\n\tif (error)\n\t\tgoto out_error;\n\tbex->foff = iomap.offset;\n\tbex->len = iomap.length;\n\n\tseg->offset = iomap.offset;\n\tseg->length = iomap.length;\n\n\tdprintk(\"GET: 0x%llx:0x%llx %d\\n\", bex->foff, bex->len, bex->es);\n\treturn 0;\n\nout_error:\n\tseg->length = 0;\n\treturn nfserrno(error);\nout_layoutunavailable:\n\tseg->length = 0;\n\treturn nfserr_layoutunavailable;\n}\n\nstatic __be32\nnfsd4_block_commit_blocks(struct inode *inode, struct nfsd4_layoutcommit *lcp,\n\t\tstruct iomap *iomaps, int nr_iomaps)\n{\n\tloff_t new_size = lcp->lc_last_wr + 1;\n\tstruct iattr iattr = { .ia_valid = 0 };\n\tint error;\n\n\tif (lcp->lc_mtime.tv_nsec == UTIME_NOW ||\n\t    timespec64_compare(&lcp->lc_mtime, &inode->i_mtime) < 0)\n\t\tlcp->lc_mtime = current_time(inode);\n\tiattr.ia_valid |= ATTR_ATIME | ATTR_CTIME | ATTR_MTIME;\n\tiattr.ia_atime = iattr.ia_ctime = iattr.ia_mtime = lcp->lc_mtime;\n\n\tif (new_size > i_size_read(inode)) {\n\t\tiattr.ia_valid |= ATTR_SIZE;\n\t\tiattr.ia_size = new_size;\n\t}\n\n\terror = inode->i_sb->s_export_op->commit_blocks(inode, iomaps,\n\t\t\tnr_iomaps, &iattr);\n\tkfree(iomaps);\n\treturn nfserrno(error);\n}\n\n#ifdef CONFIG_NFSD_BLOCKLAYOUT\nstatic int\nnfsd4_block_get_device_info_simple(struct super_block *sb,\n\t\tstruct nfsd4_getdeviceinfo *gdp)\n{\n\tstruct pnfs_block_deviceaddr *dev;\n\tstruct pnfs_block_volume *b;\n\n\tdev = kzalloc(sizeof(struct pnfs_block_deviceaddr) +\n\t\t      sizeof(struct pnfs_block_volume), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tgdp->gd_device = dev;\n\n\tdev->nr_volumes = 1;\n\tb = &dev->volumes[0];\n\n\tb->type = PNFS_BLOCK_VOLUME_SIMPLE;\n\tb->simple.sig_len = PNFS_BLOCK_UUID_LEN;\n\treturn sb->s_export_op->get_uuid(sb, b->simple.sig, &b->simple.sig_len,\n\t\t\t&b->simple.offset);\n}\n\nstatic __be32\nnfsd4_block_proc_getdeviceinfo(struct super_block *sb,\n\t\tstruct svc_rqst *rqstp,\n\t\tstruct nfs4_client *clp,\n\t\tstruct nfsd4_getdeviceinfo *gdp)\n{\n\tif (bdev_is_partition(sb->s_bdev))\n\t\treturn nfserr_inval;\n\treturn nfserrno(nfsd4_block_get_device_info_simple(sb, gdp));\n}\n\nstatic __be32\nnfsd4_block_proc_layoutcommit(struct inode *inode,\n\t\tstruct nfsd4_layoutcommit *lcp)\n{\n\tstruct iomap *iomaps;\n\tint nr_iomaps;\n\n\tnr_iomaps = nfsd4_block_decode_layoutupdate(lcp->lc_up_layout,\n\t\t\tlcp->lc_up_len, &iomaps, i_blocksize(inode));\n\tif (nr_iomaps < 0)\n\t\treturn nfserrno(nr_iomaps);\n\n\treturn nfsd4_block_commit_blocks(inode, lcp, iomaps, nr_iomaps);\n}\n\nconst struct nfsd4_layout_ops bl_layout_ops = {\n\t \n\t.notify_types\t\t=\n\t\t\tNOTIFY_DEVICEID4_DELETE | NOTIFY_DEVICEID4_CHANGE,\n\t.proc_getdeviceinfo\t= nfsd4_block_proc_getdeviceinfo,\n\t.encode_getdeviceinfo\t= nfsd4_block_encode_getdeviceinfo,\n\t.proc_layoutget\t\t= nfsd4_block_proc_layoutget,\n\t.encode_layoutget\t= nfsd4_block_encode_layoutget,\n\t.proc_layoutcommit\t= nfsd4_block_proc_layoutcommit,\n};\n#endif  \n\n#ifdef CONFIG_NFSD_SCSILAYOUT\n#define NFSD_MDS_PR_KEY\t\t0x0100000000000000ULL\n\n \nstatic u64 nfsd4_scsi_pr_key(struct nfs4_client *clp)\n{\n\treturn ((u64)clp->cl_clientid.cl_boot << 32) | clp->cl_clientid.cl_id;\n}\n\nstatic const u8 designator_types[] = {\n\tPS_DESIGNATOR_EUI64,\n\tPS_DESIGNATOR_NAA,\n};\n\nstatic int\nnfsd4_block_get_unique_id(struct gendisk *disk, struct pnfs_block_volume *b)\n{\n\tint ret, i;\n\n\tfor (i = 0; i < ARRAY_SIZE(designator_types); i++) {\n\t\tu8 type = designator_types[i];\n\n\t\tret = disk->fops->get_unique_id(disk, b->scsi.designator, type);\n\t\tif (ret > 0) {\n\t\t\tb->scsi.code_set = PS_CODE_SET_BINARY;\n\t\t\tb->scsi.designator_type = type;\n\t\t\tb->scsi.designator_len = ret;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int\nnfsd4_block_get_device_info_scsi(struct super_block *sb,\n\t\tstruct nfs4_client *clp,\n\t\tstruct nfsd4_getdeviceinfo *gdp)\n{\n\tstruct pnfs_block_deviceaddr *dev;\n\tstruct pnfs_block_volume *b;\n\tconst struct pr_ops *ops;\n\tint ret;\n\n\tdev = kzalloc(sizeof(struct pnfs_block_deviceaddr) +\n\t\t      sizeof(struct pnfs_block_volume), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tgdp->gd_device = dev;\n\n\tdev->nr_volumes = 1;\n\tb = &dev->volumes[0];\n\n\tb->type = PNFS_BLOCK_VOLUME_SCSI;\n\tb->scsi.pr_key = nfsd4_scsi_pr_key(clp);\n\n\tret = nfsd4_block_get_unique_id(sb->s_bdev->bd_disk, b);\n\tif (ret < 0)\n\t\tgoto out_free_dev;\n\n\tret = -EINVAL;\n\tops = sb->s_bdev->bd_disk->fops->pr_ops;\n\tif (!ops) {\n\t\tpr_err(\"pNFS: device %s does not support PRs.\\n\",\n\t\t\tsb->s_id);\n\t\tgoto out_free_dev;\n\t}\n\n\tret = ops->pr_register(sb->s_bdev, 0, NFSD_MDS_PR_KEY, true);\n\tif (ret) {\n\t\tpr_err(\"pNFS: failed to register key for device %s.\\n\",\n\t\t\tsb->s_id);\n\t\tgoto out_free_dev;\n\t}\n\n\tret = ops->pr_reserve(sb->s_bdev, NFSD_MDS_PR_KEY,\n\t\t\tPR_EXCLUSIVE_ACCESS_REG_ONLY, 0);\n\tif (ret) {\n\t\tpr_err(\"pNFS: failed to reserve device %s.\\n\",\n\t\t\tsb->s_id);\n\t\tgoto out_free_dev;\n\t}\n\n\treturn 0;\n\nout_free_dev:\n\tkfree(dev);\n\tgdp->gd_device = NULL;\n\treturn ret;\n}\n\nstatic __be32\nnfsd4_scsi_proc_getdeviceinfo(struct super_block *sb,\n\t\tstruct svc_rqst *rqstp,\n\t\tstruct nfs4_client *clp,\n\t\tstruct nfsd4_getdeviceinfo *gdp)\n{\n\tif (bdev_is_partition(sb->s_bdev))\n\t\treturn nfserr_inval;\n\treturn nfserrno(nfsd4_block_get_device_info_scsi(sb, clp, gdp));\n}\nstatic __be32\nnfsd4_scsi_proc_layoutcommit(struct inode *inode,\n\t\tstruct nfsd4_layoutcommit *lcp)\n{\n\tstruct iomap *iomaps;\n\tint nr_iomaps;\n\n\tnr_iomaps = nfsd4_scsi_decode_layoutupdate(lcp->lc_up_layout,\n\t\t\tlcp->lc_up_len, &iomaps, i_blocksize(inode));\n\tif (nr_iomaps < 0)\n\t\treturn nfserrno(nr_iomaps);\n\n\treturn nfsd4_block_commit_blocks(inode, lcp, iomaps, nr_iomaps);\n}\n\nstatic void\nnfsd4_scsi_fence_client(struct nfs4_layout_stateid *ls)\n{\n\tstruct nfs4_client *clp = ls->ls_stid.sc_client;\n\tstruct block_device *bdev = ls->ls_file->nf_file->f_path.mnt->mnt_sb->s_bdev;\n\n\tbdev->bd_disk->fops->pr_ops->pr_preempt(bdev, NFSD_MDS_PR_KEY,\n\t\t\tnfsd4_scsi_pr_key(clp), 0, true);\n}\n\nconst struct nfsd4_layout_ops scsi_layout_ops = {\n\t \n\t.notify_types\t\t=\n\t\t\tNOTIFY_DEVICEID4_DELETE | NOTIFY_DEVICEID4_CHANGE,\n\t.proc_getdeviceinfo\t= nfsd4_scsi_proc_getdeviceinfo,\n\t.encode_getdeviceinfo\t= nfsd4_block_encode_getdeviceinfo,\n\t.proc_layoutget\t\t= nfsd4_block_proc_layoutget,\n\t.encode_layoutget\t= nfsd4_block_encode_layoutget,\n\t.proc_layoutcommit\t= nfsd4_scsi_proc_layoutcommit,\n\t.fence_client\t\t= nfsd4_scsi_fence_client,\n};\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}