{
  "module_name": "state.h",
  "hash_id": "00931a0a851c647d1b60ad821cc92f7e77d3d75d502e6e0d26cfb93a4efbc31f",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfsd/state.h",
  "human_readable_source": " \n\n#ifndef _NFSD4_STATE_H\n#define _NFSD4_STATE_H\n\n#include <linux/idr.h>\n#include <linux/refcount.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n\ntypedef struct {\n\tu32             cl_boot;\n\tu32             cl_id;\n} clientid_t;\n\ntypedef struct {\n\tclientid_t\tso_clid;\n\tu32\t\tso_id;\n} stateid_opaque_t;\n\ntypedef struct {\n\tu32                     si_generation;\n\tstateid_opaque_t        si_opaque;\n} stateid_t;\n\ntypedef struct {\n\tstateid_t\t\tcs_stid;\n#define NFS4_COPY_STID 1\n#define NFS4_COPYNOTIFY_STID 2\n\tunsigned char\t\tcs_type;\n\trefcount_t\t\tcs_count;\n} copy_stateid_t;\n\nstruct nfsd4_callback {\n\tstruct nfs4_client *cb_clp;\n\tstruct rpc_message cb_msg;\n\tconst struct nfsd4_callback_ops *cb_ops;\n\tstruct work_struct cb_work;\n\tint cb_seq_status;\n\tint cb_status;\n\tbool cb_need_restart;\n\tbool cb_holds_slot;\n};\n\nstruct nfsd4_callback_ops {\n\tvoid (*prepare)(struct nfsd4_callback *);\n\tint (*done)(struct nfsd4_callback *, struct rpc_task *);\n\tvoid (*release)(struct nfsd4_callback *);\n};\n\n \nstruct nfs4_stid {\n\trefcount_t\t\tsc_count;\n#define NFS4_OPEN_STID 1\n#define NFS4_LOCK_STID 2\n#define NFS4_DELEG_STID 4\n \n#define NFS4_CLOSED_STID 8\n \n#define NFS4_REVOKED_DELEG_STID 16\n#define NFS4_CLOSED_DELEG_STID 32\n#define NFS4_LAYOUT_STID 64\n\tstruct list_head\tsc_cp_list;\n\tunsigned char\t\tsc_type;\n\tstateid_t\t\tsc_stateid;\n\tspinlock_t\t\tsc_lock;\n\tstruct nfs4_client\t*sc_client;\n\tstruct nfs4_file\t*sc_file;\n\tvoid\t\t\t(*sc_free)(struct nfs4_stid *);\n};\n\n \nstruct nfs4_cpntf_state {\n\tcopy_stateid_t\t\tcp_stateid;\n\tstruct list_head\tcp_list;\t \n\tstateid_t\t\tcp_p_stateid;\t \n\tclientid_t\t\tcp_p_clid;\t \n\ttime64_t\t\tcpntf_time;\t \n};\n\n \nstruct nfs4_delegation {\n\tstruct nfs4_stid\tdl_stid;  \n\tstruct list_head\tdl_perfile;\n\tstruct list_head\tdl_perclnt;\n\tstruct list_head\tdl_recall_lru;   \n\tstruct nfs4_clnt_odstate *dl_clnt_odstate;\n\tu32\t\t\tdl_type;\n\ttime64_t\t\tdl_time;\n \n\tint\t\t\tdl_retries;\n\tstruct nfsd4_callback\tdl_recall;\n\tbool\t\t\tdl_recalled;\n};\n\n#define cb_to_delegation(cb) \\\n\tcontainer_of(cb, struct nfs4_delegation, dl_recall)\n\n \nstruct nfs4_cb_conn {\n\t \n\tstruct sockaddr_storage\tcb_addr;\n\tstruct sockaddr_storage\tcb_saddr;\n\tsize_t\t\t\tcb_addrlen;\n\tu32                     cb_prog;  \n\tu32                     cb_ident;\t \n\tstruct svc_xprt\t\t*cb_xprt;\t \n};\n\nstatic inline struct nfs4_delegation *delegstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_delegation, dl_stid);\n}\n\n \n#define NFSD_MAX_SLOTS_PER_SESSION     160\n \n#define NFSD_MAX_OPS_PER_COMPOUND\t50\n \n#define NFSD_SLOT_CACHE_SIZE\t\t2048\n \n#define NFSD_CACHE_SIZE_SLOTS_PER_SESSION\t32\n#define NFSD_MAX_MEM_PER_SESSION  \\\n\t\t(NFSD_CACHE_SIZE_SLOTS_PER_SESSION * NFSD_SLOT_CACHE_SIZE)\n\nstruct nfsd4_slot {\n\tu32\tsl_seqid;\n\t__be32\tsl_status;\n\tstruct svc_cred sl_cred;\n\tu32\tsl_datalen;\n\tu16\tsl_opcnt;\n#define NFSD4_SLOT_INUSE\t(1 << 0)\n#define NFSD4_SLOT_CACHETHIS\t(1 << 1)\n#define NFSD4_SLOT_INITIALIZED\t(1 << 2)\n#define NFSD4_SLOT_CACHED\t(1 << 3)\n\tu8\tsl_flags;\n\tchar\tsl_data[];\n};\n\nstruct nfsd4_channel_attrs {\n\tu32\t\theaderpadsz;\n\tu32\t\tmaxreq_sz;\n\tu32\t\tmaxresp_sz;\n\tu32\t\tmaxresp_cached;\n\tu32\t\tmaxops;\n\tu32\t\tmaxreqs;\n\tu32\t\tnr_rdma_attrs;\n\tu32\t\trdma_attrs;\n};\n\nstruct nfsd4_cb_sec {\n\tu32\tflavor;  \n\tkuid_t\tuid;\n\tkgid_t\tgid;\n};\n\nstruct nfsd4_create_session {\n\tclientid_t\t\t\tclientid;\n\tstruct nfs4_sessionid\t\tsessionid;\n\tu32\t\t\t\tseqid;\n\tu32\t\t\t\tflags;\n\tstruct nfsd4_channel_attrs\tfore_channel;\n\tstruct nfsd4_channel_attrs\tback_channel;\n\tu32\t\t\t\tcallback_prog;\n\tstruct nfsd4_cb_sec\t\tcb_sec;\n};\n\nstruct nfsd4_backchannel_ctl {\n\tu32\tbc_cb_program;\n\tstruct nfsd4_cb_sec\t\tbc_cb_sec;\n};\n\nstruct nfsd4_bind_conn_to_session {\n\tstruct nfs4_sessionid\t\tsessionid;\n\tu32\t\t\t\tdir;\n};\n\n \nstruct nfsd4_clid_slot {\n\tu32\t\t\t\tsl_seqid;\n\t__be32\t\t\t\tsl_status;\n\tstruct nfsd4_create_session\tsl_cr_ses;\n};\n\nstruct nfsd4_conn {\n\tstruct list_head cn_persession;\n\tstruct svc_xprt *cn_xprt;\n\tstruct svc_xpt_user cn_xpt_user;\n\tstruct nfsd4_session *cn_session;\n \n\tunsigned char cn_flags;\n};\n\n \nstruct nfsd4_session {\n\tatomic_t\t\tse_ref;\n\tstruct list_head\tse_hash;\t \n\tstruct list_head\tse_perclnt;\n \n#define NFS4_SESSION_DEAD\t0x010\n\tu32\t\t\tse_flags;\n\tstruct nfs4_client\t*se_client;\n\tstruct nfs4_sessionid\tse_sessionid;\n\tstruct nfsd4_channel_attrs se_fchannel;\n\tstruct nfsd4_channel_attrs se_bchannel;\n\tstruct nfsd4_cb_sec\tse_cb_sec;\n\tstruct list_head\tse_conns;\n\tu32\t\t\tse_cb_prog;\n\tu32\t\t\tse_cb_seq_nr;\n\tstruct nfsd4_slot\t*se_slots[];\t \n};\n\n \nstruct nfsd4_sessionid {\n\tclientid_t\tclientid;\n\tu32\t\tsequence;\n\tu32\t\treserved;\n};\n\n#define HEXDIR_LEN     33  \n\n \nenum {\n\tNFSD4_ACTIVE = 0,\n\tNFSD4_COURTESY,\n\tNFSD4_EXPIRABLE,\n};\n\n \nstruct nfs4_client {\n\tstruct list_head\tcl_idhash; \t \n\tstruct rb_node\t\tcl_namenode;\t \n\tstruct list_head\t*cl_ownerstr_hashtbl;\n\tstruct list_head\tcl_openowners;\n\tstruct idr\t\tcl_stateids;\t \n\tstruct list_head\tcl_delegations;\n\tstruct list_head\tcl_revoked;\t \n\tstruct list_head        cl_lru;          \n#ifdef CONFIG_NFSD_PNFS\n\tstruct list_head\tcl_lo_states;\t \n#endif\n\tstruct xdr_netobj\tcl_name; \t \n\tnfs4_verifier\t\tcl_verifier; \t \n\ttime64_t\t\tcl_time;\t \n\tstruct sockaddr_storage\tcl_addr; \t \n\tbool\t\t\tcl_mach_cred;\t \n\tstruct svc_cred\t\tcl_cred; \t \n\tclientid_t\t\tcl_clientid;\t \n\tnfs4_verifier\t\tcl_confirm;\t \n\tu32\t\t\tcl_minorversion;\n\t \n\tstruct xdr_netobj\tcl_nii_domain;\n\tstruct xdr_netobj\tcl_nii_name;\n\tstruct timespec64\tcl_nii_time;\n\n\t \n\tstruct nfs4_cb_conn\tcl_cb_conn;\n#define NFSD4_CLIENT_CB_UPDATE\t\t(0)\n#define NFSD4_CLIENT_CB_KILL\t\t(1)\n#define NFSD4_CLIENT_STABLE\t\t(2)\t \n#define NFSD4_CLIENT_RECLAIM_COMPLETE\t(3)\t \n#define NFSD4_CLIENT_CONFIRMED\t\t(4)\t \n#define NFSD4_CLIENT_UPCALL_LOCK\t(5)\t \n#define NFSD4_CLIENT_CB_FLAG_MASK\t(1 << NFSD4_CLIENT_CB_UPDATE | \\\n\t\t\t\t\t 1 << NFSD4_CLIENT_CB_KILL)\n#define NFSD4_CLIENT_CB_RECALL_ANY\t(6)\n\tunsigned long\t\tcl_flags;\n\tconst struct cred\t*cl_cb_cred;\n\tstruct rpc_clnt\t\t*cl_cb_client;\n\tu32\t\t\tcl_cb_ident;\n#define NFSD4_CB_UP\t\t0\n#define NFSD4_CB_UNKNOWN\t1\n#define NFSD4_CB_DOWN\t\t2\n#define NFSD4_CB_FAULT\t\t3\n\tint\t\t\tcl_cb_state;\n\tstruct nfsd4_callback\tcl_cb_null;\n\tstruct nfsd4_session\t*cl_cb_session;\n\n\t \n\tspinlock_t\t\tcl_lock;\n\n\t \n\tstruct list_head\tcl_sessions;\n\tstruct nfsd4_clid_slot\tcl_cs_slot;\t \n\tu32\t\t\tcl_exchange_flags;\n\t \n\tatomic_t\t\tcl_rpc_users;\n\tstruct nfsdfs_client\tcl_nfsdfs;\n\tstruct nfs4_op_map      cl_spo_must_allow;\n\n\t \n\tstruct dentry\t\t*cl_nfsd_dentry;\n\t \n\tstruct dentry\t\t*cl_nfsd_info_dentry;\n\n\t \n\t \n\tunsigned long\t\tcl_cb_slot_busy;\n\tstruct rpc_wait_queue\tcl_cb_waitq;\t \n\t\t\t\t\t\t \n\tstruct net\t\t*net;\n\tstruct list_head\tasync_copies;\t \n\tspinlock_t\t\tasync_lock;\t \n\tatomic_t\t\tcl_cb_inflight;\t \n\n\tunsigned int\t\tcl_state;\n\tatomic_t\t\tcl_delegs_in_recall;\n\n\tstruct nfsd4_cb_recall_any\t*cl_ra;\n\ttime64_t\t\tcl_ra_time;\n\tstruct list_head\tcl_ra_cblist;\n};\n\n \nstruct nfs4_client_reclaim {\n\tstruct list_head\tcr_strhash;\t \n\tstruct nfs4_client\t*cr_clp;\t \n\tstruct xdr_netobj\tcr_name;\t \n\tstruct xdr_netobj\tcr_princhash;\n};\n\n \n\n#define NFSD4_REPLAY_ISIZE       112 \n\n \nstruct nfs4_replay {\n\t__be32\t\t\trp_status;\n\tunsigned int\t\trp_buflen;\n\tchar\t\t\t*rp_buf;\n\tstruct knfsd_fh\t\trp_openfh;\n\tstruct mutex\t\trp_mutex;\n\tchar\t\t\trp_ibuf[NFSD4_REPLAY_ISIZE];\n};\n\nstruct nfs4_stateowner;\n\nstruct nfs4_stateowner_operations {\n\tvoid (*so_unhash)(struct nfs4_stateowner *);\n\tvoid (*so_free)(struct nfs4_stateowner *);\n};\n\n \nstruct nfs4_stateowner {\n\tstruct list_head\t\t\tso_strhash;\n\tstruct list_head\t\t\tso_stateids;\n\tstruct nfs4_client\t\t\t*so_client;\n\tconst struct nfs4_stateowner_operations\t*so_ops;\n\t \n\tatomic_t\t\t\t\tso_count;\n\tu32\t\t\t\t\tso_seqid;\n\tstruct xdr_netobj\t\t\tso_owner;  \n\tstruct nfs4_replay\t\t\tso_replay;\n\tbool\t\t\t\t\tso_is_open_owner;\n};\n\n \nstruct nfs4_openowner {\n\tstruct nfs4_stateowner\too_owner;  \n\tstruct list_head        oo_perclient;\n\t \n\tstruct list_head\too_close_lru;\n\tstruct nfs4_ol_stateid *oo_last_closed_stid;\n\ttime64_t\t\too_time;  \n#define NFS4_OO_CONFIRMED   1\n\tunsigned char\t\too_flags;\n};\n\n \nstruct nfs4_lockowner {\n\tstruct nfs4_stateowner\tlo_owner;\t \n\tstruct list_head\tlo_blocked;\t \n};\n\nstatic inline struct nfs4_openowner * openowner(struct nfs4_stateowner *so)\n{\n\treturn container_of(so, struct nfs4_openowner, oo_owner);\n}\n\nstatic inline struct nfs4_lockowner * lockowner(struct nfs4_stateowner *so)\n{\n\treturn container_of(so, struct nfs4_lockowner, lo_owner);\n}\n\n \nstruct nfs4_clnt_odstate {\n\tstruct nfs4_client\t*co_client;\n\tstruct nfs4_file\t*co_file;\n\tstruct list_head\tco_perfile;\n\trefcount_t\t\tco_odcount;\n};\n\n \nstruct nfs4_file {\n\trefcount_t\t\tfi_ref;\n\tstruct inode *\t\tfi_inode;\n\tbool\t\t\tfi_aliased;\n\tspinlock_t\t\tfi_lock;\n\tstruct rhlist_head\tfi_rlist;\n\tstruct list_head        fi_stateids;\n\tunion {\n\t\tstruct list_head\tfi_delegations;\n\t\tstruct rcu_head\t\tfi_rcu;\n\t};\n\tstruct list_head\tfi_clnt_odstate;\n\t \n\tstruct nfsd_file\t*fi_fds[3];\n\t \n\tatomic_t\t\tfi_access[2];\n\tu32\t\t\tfi_share_deny;\n\tstruct nfsd_file\t*fi_deleg_file;\n\tint\t\t\tfi_delegees;\n\tstruct knfsd_fh\t\tfi_fhandle;\n\tbool\t\t\tfi_had_conflict;\n#ifdef CONFIG_NFSD_PNFS\n\tstruct list_head\tfi_lo_states;\n\tatomic_t\t\tfi_lo_recalls;\n#endif\n};\n\n \nstruct nfs4_ol_stateid {\n\tstruct nfs4_stid\t\tst_stid;\n\tstruct list_head\t\tst_perfile;\n\tstruct list_head\t\tst_perstateowner;\n\tstruct list_head\t\tst_locks;\n\tstruct nfs4_stateowner\t\t*st_stateowner;\n\tstruct nfs4_clnt_odstate\t*st_clnt_odstate;\n \n\tunsigned char\t\t\tst_access_bmap;\n\tunsigned char\t\t\tst_deny_bmap;\n\tstruct nfs4_ol_stateid\t\t*st_openstp;\n\tstruct mutex\t\t\tst_mutex;\n};\n\nstatic inline struct nfs4_ol_stateid *openlockstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_ol_stateid, st_stid);\n}\n\nstruct nfs4_layout_stateid {\n\tstruct nfs4_stid\t\tls_stid;\n\tstruct list_head\t\tls_perclnt;\n\tstruct list_head\t\tls_perfile;\n\tspinlock_t\t\t\tls_lock;\n\tstruct list_head\t\tls_layouts;\n\tu32\t\t\t\tls_layout_type;\n\tstruct nfsd_file\t\t*ls_file;\n\tstruct nfsd4_callback\t\tls_recall;\n\tstateid_t\t\t\tls_recall_sid;\n\tbool\t\t\t\tls_recalled;\n\tstruct mutex\t\t\tls_mutex;\n};\n\nstatic inline struct nfs4_layout_stateid *layoutstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_layout_stateid, ls_stid);\n}\n\n \n#define RD_STATE\t        0x00000010\n#define WR_STATE\t        0x00000020\n\nenum nfsd4_cb_op {\n\tNFSPROC4_CLNT_CB_NULL = 0,\n\tNFSPROC4_CLNT_CB_RECALL,\n\tNFSPROC4_CLNT_CB_LAYOUT,\n\tNFSPROC4_CLNT_CB_OFFLOAD,\n\tNFSPROC4_CLNT_CB_SEQUENCE,\n\tNFSPROC4_CLNT_CB_NOTIFY_LOCK,\n\tNFSPROC4_CLNT_CB_RECALL_ANY,\n};\n\n \nstatic inline bool nfsd4_stateid_generation_after(stateid_t *a, stateid_t *b)\n{\n\treturn (s32)(a->si_generation - b->si_generation) > 0;\n}\n\n \nstruct nfsd4_blocked_lock {\n\tstruct list_head\tnbl_list;\n\tstruct list_head\tnbl_lru;\n\ttime64_t\t\tnbl_time;\n\tstruct file_lock\tnbl_lock;\n\tstruct knfsd_fh\t\tnbl_fh;\n\tstruct nfsd4_callback\tnbl_cb;\n\tstruct kref\t\tnbl_kref;\n};\n\nstruct nfsd4_compound_state;\nstruct nfsd_net;\nstruct nfsd4_copy;\n\nextern __be32 nfs4_preprocess_stateid_op(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate, struct svc_fh *fhp,\n\t\tstateid_t *stateid, int flags, struct nfsd_file **filp,\n\t\tstruct nfs4_stid **cstid);\n__be32 nfsd4_lookup_stateid(struct nfsd4_compound_state *cstate,\n\t\t     stateid_t *stateid, unsigned char typemask,\n\t\t     struct nfs4_stid **s, struct nfsd_net *nn);\nstruct nfs4_stid *nfs4_alloc_stid(struct nfs4_client *cl, struct kmem_cache *slab,\n\t\t\t\t  void (*sc_free)(struct nfs4_stid *));\nint nfs4_init_copy_state(struct nfsd_net *nn, struct nfsd4_copy *copy);\nvoid nfs4_free_copy_state(struct nfsd4_copy *copy);\nstruct nfs4_cpntf_state *nfs4_alloc_init_cpntf_state(struct nfsd_net *nn,\n\t\t\tstruct nfs4_stid *p_stid);\nvoid nfs4_unhash_stid(struct nfs4_stid *s);\nvoid nfs4_put_stid(struct nfs4_stid *s);\nvoid nfs4_inc_and_copy_stateid(stateid_t *dst, struct nfs4_stid *stid);\nvoid nfs4_remove_reclaim_record(struct nfs4_client_reclaim *, struct nfsd_net *);\nextern void nfs4_release_reclaim(struct nfsd_net *);\nextern struct nfs4_client_reclaim *nfsd4_find_reclaim_client(struct xdr_netobj name,\n\t\t\t\t\t\t\tstruct nfsd_net *nn);\nextern __be32 nfs4_check_open_reclaim(struct nfs4_client *);\nextern void nfsd4_probe_callback(struct nfs4_client *clp);\nextern void nfsd4_probe_callback_sync(struct nfs4_client *clp);\nextern void nfsd4_change_callback(struct nfs4_client *clp, struct nfs4_cb_conn *);\nextern void nfsd4_init_cb(struct nfsd4_callback *cb, struct nfs4_client *clp,\n\t\tconst struct nfsd4_callback_ops *ops, enum nfsd4_cb_op op);\nextern bool nfsd4_run_cb(struct nfsd4_callback *cb);\nextern int nfsd4_create_callback_queue(void);\nextern void nfsd4_destroy_callback_queue(void);\nextern void nfsd4_shutdown_callback(struct nfs4_client *);\nextern void nfsd4_shutdown_copy(struct nfs4_client *clp);\nextern struct nfs4_client_reclaim *nfs4_client_to_reclaim(struct xdr_netobj name,\n\t\t\t\tstruct xdr_netobj princhash, struct nfsd_net *nn);\nextern bool nfs4_has_reclaimed_state(struct xdr_netobj name, struct nfsd_net *nn);\n\nvoid put_nfs4_file(struct nfs4_file *fi);\nextern void nfs4_put_cpntf_state(struct nfsd_net *nn,\n\t\t\t\t struct nfs4_cpntf_state *cps);\nextern __be32 manage_cpntf_state(struct nfsd_net *nn, stateid_t *st,\n\t\t\t\t struct nfs4_client *clp,\n\t\t\t\t struct nfs4_cpntf_state **cps);\nstatic inline void get_nfs4_file(struct nfs4_file *fi)\n{\n\trefcount_inc(&fi->fi_ref);\n}\nstruct nfsd_file *find_any_file(struct nfs4_file *f);\n\n \nvoid nfsd4_end_grace(struct nfsd_net *nn);\n\n \nextern int nfsd4_client_tracking_init(struct net *net);\nextern void nfsd4_client_tracking_exit(struct net *net);\nextern void nfsd4_client_record_create(struct nfs4_client *clp);\nextern void nfsd4_client_record_remove(struct nfs4_client *clp);\nextern int nfsd4_client_record_check(struct nfs4_client *clp);\nextern void nfsd4_record_grace_done(struct nfsd_net *nn);\n\nstatic inline bool try_to_expire_client(struct nfs4_client *clp)\n{\n\tcmpxchg(&clp->cl_state, NFSD4_COURTESY, NFSD4_EXPIRABLE);\n\treturn clp->cl_state == NFSD4_EXPIRABLE;\n}\n\nextern __be32 nfsd4_deleg_getattr_conflict(struct svc_rqst *rqstp,\n\t\t\t\tstruct inode *inode);\n#endif    \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}