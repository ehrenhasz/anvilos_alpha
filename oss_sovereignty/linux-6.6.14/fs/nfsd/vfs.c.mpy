{
  "module_name": "vfs.c",
  "hash_id": "2b44bb962ff9da7c46da839aeb4362f53d8df900c353cd0822cb2136251de205",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfsd/vfs.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/splice.h>\n#include <linux/falloc.h>\n#include <linux/fcntl.h>\n#include <linux/namei.h>\n#include <linux/delay.h>\n#include <linux/fsnotify.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/jhash.h>\n#include <linux/ima.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/exportfs.h>\n#include <linux/writeback.h>\n#include <linux/security.h>\n\n#include \"xdr3.h\"\n\n#ifdef CONFIG_NFSD_V4\n#include \"../internal.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include \"xdr4.h\"\n#endif  \n\n#include \"nfsd.h\"\n#include \"vfs.h\"\n#include \"filecache.h\"\n#include \"trace.h\"\n\n#define NFSDDBG_FACILITY\t\tNFSDDBG_FILEOP\n\n \n__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_stale, -EBADF },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n\t\t{ nfserr_dquot, -EDQUOT },\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t\t{ nfserr_io, -EREMOTEIO },\n\t\t{ nfserr_stale, -EOPENSTALE },\n\t\t{ nfserr_io, -EUCLEAN },\n\t\t{ nfserr_perm, -ENOKEY },\n\t\t{ nfserr_no_grace, -ENOGRACE},\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN_ONCE(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}\n\n \nint\nnfsd_cross_mnt(struct svc_rqst *rqstp, struct dentry **dpp, \n\t\t        struct svc_export **expp)\n{\n\tstruct svc_export *exp = *expp, *exp2 = NULL;\n\tstruct dentry *dentry = *dpp;\n\tstruct path path = {.mnt = mntget(exp->ex_path.mnt),\n\t\t\t    .dentry = dget(dentry)};\n\tunsigned int follow_flags = 0;\n\tint err = 0;\n\n\tif (exp->ex_flags & NFSEXP_CROSSMOUNT)\n\t\tfollow_flags = LOOKUP_AUTOMOUNT;\n\n\terr = follow_down(&path, follow_flags);\n\tif (err < 0)\n\t\tgoto out;\n\tif (path.mnt == exp->ex_path.mnt && path.dentry == dentry &&\n\t    nfsd_mountpoint(dentry, exp) == 2) {\n\t\t \n\t\tpath_put(&path);\n\t\tgoto out;\n\t}\n\n\texp2 = rqst_exp_get_by_name(rqstp, &path);\n\tif (IS_ERR(exp2)) {\n\t\terr = PTR_ERR(exp2);\n\t\t \n\t\tif (err == -ENOENT && !(exp->ex_flags & NFSEXP_V4ROOT))\n\t\t\terr = 0;\n\t\tpath_put(&path);\n\t\tgoto out;\n\t}\n\tif (nfsd_v4client(rqstp) ||\n\t\t(exp->ex_flags & NFSEXP_CROSSMOUNT) || EX_NOHIDE(exp2)) {\n\t\t \n\t\t \n\t\t*dpp = path.dentry;\n\t\tpath.dentry = dentry;\n\t\t*expp = exp2;\n\t\texp2 = exp;\n\t}\n\tpath_put(&path);\n\texp_put(exp2);\nout:\n\treturn err;\n}\n\nstatic void follow_to_parent(struct path *path)\n{\n\tstruct dentry *dp;\n\n\twhile (path->dentry == path->mnt->mnt_root && follow_up(path))\n\t\t;\n\tdp = dget_parent(path->dentry);\n\tdput(path->dentry);\n\tpath->dentry = dp;\n}\n\nstatic int nfsd_lookup_parent(struct svc_rqst *rqstp, struct dentry *dparent, struct svc_export **exp, struct dentry **dentryp)\n{\n\tstruct svc_export *exp2;\n\tstruct path path = {.mnt = mntget((*exp)->ex_path.mnt),\n\t\t\t    .dentry = dget(dparent)};\n\n\tfollow_to_parent(&path);\n\n\texp2 = rqst_exp_parent(rqstp, &path);\n\tif (PTR_ERR(exp2) == -ENOENT) {\n\t\t*dentryp = dget(dparent);\n\t} else if (IS_ERR(exp2)) {\n\t\tpath_put(&path);\n\t\treturn PTR_ERR(exp2);\n\t} else {\n\t\t*dentryp = dget(path.dentry);\n\t\texp_put(*exp);\n\t\t*exp = exp2;\n\t}\n\tpath_put(&path);\n\treturn 0;\n}\n\n \nint nfsd_mountpoint(struct dentry *dentry, struct svc_export *exp)\n{\n\tif (!d_inode(dentry))\n\t\treturn 0;\n\tif (exp->ex_flags & NFSEXP_V4ROOT)\n\t\treturn 1;\n\tif (nfsd4_is_junction(dentry))\n\t\treturn 1;\n\tif (d_managed(dentry))\n\t\t \n\t\treturn 2;\n\treturn 0;\n}\n\n__be32\nnfsd_lookup_dentry(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\t   const char *name, unsigned int len,\n\t\t   struct svc_export **exp_ret, struct dentry **dentry_ret)\n{\n\tstruct svc_export\t*exp;\n\tstruct dentry\t\t*dparent;\n\tstruct dentry\t\t*dentry;\n\tint\t\t\thost_err;\n\n\tdprintk(\"nfsd: nfsd_lookup(fh %s, %.*s)\\n\", SVCFH_fmt(fhp), len,name);\n\n\tdparent = fhp->fh_dentry;\n\texp = exp_get(fhp->fh_export);\n\n\t \n\tif (isdotent(name, len)) {\n\t\tif (len==1)\n\t\t\tdentry = dget(dparent);\n\t\telse if (dparent != exp->ex_path.dentry)\n\t\t\tdentry = dget_parent(dparent);\n\t\telse if (!EX_NOHIDE(exp) && !nfsd_v4client(rqstp))\n\t\t\tdentry = dget(dparent);  \n\t\telse {\n\t\t\t \n\t\t\thost_err = nfsd_lookup_parent(rqstp, dparent, &exp, &dentry);\n\t\t\tif (host_err)\n\t\t\t\tgoto out_nfserr;\n\t\t}\n\t} else {\n\t\tdentry = lookup_one_len_unlocked(name, dparent, len);\n\t\thost_err = PTR_ERR(dentry);\n\t\tif (IS_ERR(dentry))\n\t\t\tgoto out_nfserr;\n\t\tif (nfsd_mountpoint(dentry, exp)) {\n\t\t\thost_err = nfsd_cross_mnt(rqstp, &dentry, &exp);\n\t\t\tif (host_err) {\n\t\t\t\tdput(dentry);\n\t\t\t\tgoto out_nfserr;\n\t\t\t}\n\t\t}\n\t}\n\t*dentry_ret = dentry;\n\t*exp_ret = exp;\n\treturn 0;\n\nout_nfserr:\n\texp_put(exp);\n\treturn nfserrno(host_err);\n}\n\n \n__be32\nnfsd_lookup(struct svc_rqst *rqstp, struct svc_fh *fhp, const char *name,\n\t    unsigned int len, struct svc_fh *resfh)\n{\n\tstruct svc_export\t*exp;\n\tstruct dentry\t\t*dentry;\n\t__be32 err;\n\n\terr = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_EXEC);\n\tif (err)\n\t\treturn err;\n\terr = nfsd_lookup_dentry(rqstp, fhp, name, len, &exp, &dentry);\n\tif (err)\n\t\treturn err;\n\terr = check_nfsd_access(exp, rqstp);\n\tif (err)\n\t\tgoto out;\n\t \n\terr = fh_compose(resfh, exp, dentry, fhp);\n\tif (!err && d_really_is_negative(dentry))\n\t\terr = nfserr_noent;\nout:\n\tdput(dentry);\n\texp_put(exp);\n\treturn err;\n}\n\n \nstatic int\ncommit_inode_metadata(struct inode *inode)\n{\n\tconst struct export_operations *export_ops = inode->i_sb->s_export_op;\n\n\tif (export_ops->commit_metadata)\n\t\treturn export_ops->commit_metadata(inode);\n\treturn sync_inode_metadata(inode, 1);\n}\n\nstatic int\ncommit_metadata(struct svc_fh *fhp)\n{\n\tstruct inode *inode = d_inode(fhp->fh_dentry);\n\n\tif (!EX_ISSYNC(fhp->fh_export))\n\t\treturn 0;\n\treturn commit_inode_metadata(inode);\n}\n\n \nstatic void\nnfsd_sanitize_attrs(struct inode *inode, struct iattr *iap)\n{\n\t \n\tif (S_ISLNK(inode->i_mode))\n\t\tiap->ia_valid &= ~ATTR_MODE;\n\n\t \n\tif (iap->ia_valid & ATTR_MODE) {\n\t\tiap->ia_mode &= S_IALLUGO;\n\t\tiap->ia_mode |= (inode->i_mode & ~S_IALLUGO);\n\t}\n\n\t \n\tif (!S_ISDIR(inode->i_mode) &&\n\t    ((iap->ia_valid & ATTR_UID) || (iap->ia_valid & ATTR_GID))) {\n\t\tiap->ia_valid |= ATTR_KILL_PRIV;\n\t\tif (iap->ia_valid & ATTR_MODE) {\n\t\t\t \n\t\t\tiap->ia_mode &= ~S_ISUID;\n\t\t\tif (iap->ia_mode & S_IXGRP)\n\t\t\t\tiap->ia_mode &= ~S_ISGID;\n\t\t} else {\n\t\t\t \n\t\t\tiap->ia_valid |= ATTR_KILL_SUID;\n\t\t\tiap->ia_valid |=\n\t\t\t\tsetattr_should_drop_sgid(&nop_mnt_idmap, inode);\n\t\t}\n\t}\n}\n\nstatic __be32\nnfsd_get_write_access(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\tstruct iattr *iap)\n{\n\tstruct inode *inode = d_inode(fhp->fh_dentry);\n\n\tif (iap->ia_size < inode->i_size) {\n\t\t__be32 err;\n\n\t\terr = nfsd_permission(rqstp, fhp->fh_export, fhp->fh_dentry,\n\t\t\t\tNFSD_MAY_TRUNC | NFSD_MAY_OWNER_OVERRIDE);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn nfserrno(get_write_access(inode));\n}\n\nstatic int __nfsd_setattr(struct dentry *dentry, struct iattr *iap)\n{\n\tint host_err;\n\n\tif (iap->ia_valid & ATTR_SIZE) {\n\t\t \n\t\tstruct iattr size_attr = {\n\t\t\t.ia_valid\t= ATTR_SIZE | ATTR_CTIME | ATTR_MTIME,\n\t\t\t.ia_size\t= iap->ia_size,\n\t\t};\n\n\t\tif (iap->ia_size < 0)\n\t\t\treturn -EFBIG;\n\n\t\thost_err = notify_change(&nop_mnt_idmap, dentry, &size_attr, NULL);\n\t\tif (host_err)\n\t\t\treturn host_err;\n\t\tiap->ia_valid &= ~ATTR_SIZE;\n\n\t\t \n\t\tif ((iap->ia_valid & ~ATTR_MTIME) == 0)\n\t\t\treturn 0;\n\t}\n\n\tif (!iap->ia_valid)\n\t\treturn 0;\n\n\tiap->ia_valid |= ATTR_CTIME;\n\treturn notify_change(&nop_mnt_idmap, dentry, iap, NULL);\n}\n\n \n__be32\nnfsd_setattr(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t     struct nfsd_attrs *attr,\n\t     int check_guard, time64_t guardtime)\n{\n\tstruct dentry\t*dentry;\n\tstruct inode\t*inode;\n\tstruct iattr\t*iap = attr->na_iattr;\n\tint\t\taccmode = NFSD_MAY_SATTR;\n\tumode_t\t\tftype = 0;\n\t__be32\t\terr;\n\tint\t\thost_err;\n\tbool\t\tget_write_count;\n\tbool\t\tsize_change = (iap->ia_valid & ATTR_SIZE);\n\tint\t\tretries;\n\n\tif (iap->ia_valid & ATTR_SIZE) {\n\t\taccmode |= NFSD_MAY_WRITE|NFSD_MAY_OWNER_OVERRIDE;\n\t\tftype = S_IFREG;\n\t}\n\n\t \n\tif (iap->ia_valid & (ATTR_ATIME | ATTR_MTIME)) {\n\t\taccmode |= NFSD_MAY_OWNER_OVERRIDE;\n\t\tif (!(iap->ia_valid & (ATTR_ATIME_SET | ATTR_MTIME_SET)))\n\t\t\taccmode |= NFSD_MAY_WRITE;\n\t}\n\n\t \n\tget_write_count = !fhp->fh_dentry;\n\n\t \n\terr = fh_verify(rqstp, fhp, ftype, accmode);\n\tif (err)\n\t\treturn err;\n\tif (get_write_count) {\n\t\thost_err = fh_want_write(fhp);\n\t\tif (host_err)\n\t\t\tgoto out;\n\t}\n\n\tdentry = fhp->fh_dentry;\n\tinode = d_inode(dentry);\n\n\tnfsd_sanitize_attrs(inode, iap);\n\n\tif (check_guard && guardtime != inode_get_ctime(inode).tv_sec)\n\t\treturn nfserr_notsync;\n\n\t \n\tif (size_change) {\n\t\terr = nfsd_get_write_access(rqstp, fhp, iap);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tinode_lock(inode);\n\tfor (retries = 1;;) {\n\t\tstruct iattr attrs;\n\n\t\t \n\t\tattrs = *iap;\n\t\thost_err = __nfsd_setattr(dentry, &attrs);\n\t\tif (host_err != -EAGAIN || !retries--)\n\t\t\tbreak;\n\t\tif (!nfsd_wait_for_delegreturn(rqstp, inode))\n\t\t\tbreak;\n\t}\n\tif (attr->na_seclabel && attr->na_seclabel->len)\n\t\tattr->na_labelerr = security_inode_setsecctx(dentry,\n\t\t\tattr->na_seclabel->data, attr->na_seclabel->len);\n\tif (IS_ENABLED(CONFIG_FS_POSIX_ACL) && attr->na_pacl)\n\t\tattr->na_aclerr = set_posix_acl(&nop_mnt_idmap,\n\t\t\t\t\t\tdentry, ACL_TYPE_ACCESS,\n\t\t\t\t\t\tattr->na_pacl);\n\tif (IS_ENABLED(CONFIG_FS_POSIX_ACL) &&\n\t    !attr->na_aclerr && attr->na_dpacl && S_ISDIR(inode->i_mode))\n\t\tattr->na_aclerr = set_posix_acl(&nop_mnt_idmap,\n\t\t\t\t\t\tdentry, ACL_TYPE_DEFAULT,\n\t\t\t\t\t\tattr->na_dpacl);\n\tinode_unlock(inode);\n\tif (size_change)\n\t\tput_write_access(inode);\nout:\n\tif (!host_err)\n\t\thost_err = commit_metadata(fhp);\n\treturn nfserrno(host_err);\n}\n\n#if defined(CONFIG_NFSD_V4)\n \n#define NFSD_JUNCTION_XATTR_NAME\tXATTR_TRUSTED_PREFIX \"junction.nfs\"\n\n \nint nfsd4_is_junction(struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(dentry);\n\n\tif (inode == NULL)\n\t\treturn 0;\n\tif (inode->i_mode & S_IXUGO)\n\t\treturn 0;\n\tif (!(inode->i_mode & S_ISVTX))\n\t\treturn 0;\n\tif (vfs_getxattr(&nop_mnt_idmap, dentry, NFSD_JUNCTION_XATTR_NAME,\n\t\t\t NULL, 0) <= 0)\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic struct nfsd4_compound_state *nfsd4_get_cstate(struct svc_rqst *rqstp)\n{\n\treturn &((struct nfsd4_compoundres *)rqstp->rq_resp)->cstate;\n}\n\n__be32 nfsd4_clone_file_range(struct svc_rqst *rqstp,\n\t\tstruct nfsd_file *nf_src, u64 src_pos,\n\t\tstruct nfsd_file *nf_dst, u64 dst_pos,\n\t\tu64 count, bool sync)\n{\n\tstruct file *src = nf_src->nf_file;\n\tstruct file *dst = nf_dst->nf_file;\n\terrseq_t since;\n\tloff_t cloned;\n\t__be32 ret = 0;\n\n\tsince = READ_ONCE(dst->f_wb_err);\n\tcloned = vfs_clone_file_range(src, src_pos, dst, dst_pos, count, 0);\n\tif (cloned < 0) {\n\t\tret = nfserrno(cloned);\n\t\tgoto out_err;\n\t}\n\tif (count && cloned != count) {\n\t\tret = nfserrno(-EINVAL);\n\t\tgoto out_err;\n\t}\n\tif (sync) {\n\t\tloff_t dst_end = count ? dst_pos + count - 1 : LLONG_MAX;\n\t\tint status = vfs_fsync_range(dst, dst_pos, dst_end, 0);\n\n\t\tif (!status)\n\t\t\tstatus = filemap_check_wb_err(dst->f_mapping, since);\n\t\tif (!status)\n\t\t\tstatus = commit_inode_metadata(file_inode(src));\n\t\tif (status < 0) {\n\t\t\tstruct nfsd_net *nn = net_generic(nf_dst->nf_net,\n\t\t\t\t\t\t\t  nfsd_net_id);\n\n\t\t\ttrace_nfsd_clone_file_range_err(rqstp,\n\t\t\t\t\t&nfsd4_get_cstate(rqstp)->save_fh,\n\t\t\t\t\tsrc_pos,\n\t\t\t\t\t&nfsd4_get_cstate(rqstp)->current_fh,\n\t\t\t\t\tdst_pos,\n\t\t\t\t\tcount, status);\n\t\t\tnfsd_reset_write_verifier(nn);\n\t\t\ttrace_nfsd_writeverf_reset(nn, rqstp, status);\n\t\t\tret = nfserrno(status);\n\t\t}\n\t}\nout_err:\n\treturn ret;\n}\n\nssize_t nfsd_copy_file_range(struct file *src, u64 src_pos, struct file *dst,\n\t\t\t     u64 dst_pos, u64 count)\n{\n\tssize_t ret;\n\n\t \n\tcount = min_t(u64, count, 1 << 22);\n\tret = vfs_copy_file_range(src, src_pos, dst, dst_pos, count, 0);\n\n\tif (ret == -EOPNOTSUPP || ret == -EXDEV)\n\t\tret = vfs_copy_file_range(src, src_pos, dst, dst_pos, count,\n\t\t\t\t\t  COPY_FILE_SPLICE);\n\treturn ret;\n}\n\n__be32 nfsd4_vfs_fallocate(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\t\t   struct file *file, loff_t offset, loff_t len,\n\t\t\t   int flags)\n{\n\tint error;\n\n\tif (!S_ISREG(file_inode(file)->i_mode))\n\t\treturn nfserr_inval;\n\n\terror = vfs_fallocate(file, flags, offset, len);\n\tif (!error)\n\t\terror = commit_metadata(fhp);\n\n\treturn nfserrno(error);\n}\n#endif  \n\n \nstruct accessmap {\n\tu32\t\taccess;\n\tint\t\thow;\n};\nstatic struct accessmap\tnfs3_regaccess[] = {\n    {\tNFS3_ACCESS_READ,\tNFSD_MAY_READ\t\t\t},\n    {\tNFS3_ACCESS_EXECUTE,\tNFSD_MAY_EXEC\t\t\t},\n    {\tNFS3_ACCESS_MODIFY,\tNFSD_MAY_WRITE|NFSD_MAY_TRUNC\t},\n    {\tNFS3_ACCESS_EXTEND,\tNFSD_MAY_WRITE\t\t\t},\n\n#ifdef CONFIG_NFSD_V4\n    {\tNFS4_ACCESS_XAREAD,\tNFSD_MAY_READ\t\t\t},\n    {\tNFS4_ACCESS_XAWRITE,\tNFSD_MAY_WRITE\t\t\t},\n    {\tNFS4_ACCESS_XALIST,\tNFSD_MAY_READ\t\t\t},\n#endif\n\n    {\t0,\t\t\t0\t\t\t\t}\n};\n\nstatic struct accessmap\tnfs3_diraccess[] = {\n    {\tNFS3_ACCESS_READ,\tNFSD_MAY_READ\t\t\t},\n    {\tNFS3_ACCESS_LOOKUP,\tNFSD_MAY_EXEC\t\t\t},\n    {\tNFS3_ACCESS_MODIFY,\tNFSD_MAY_EXEC|NFSD_MAY_WRITE|NFSD_MAY_TRUNC},\n    {\tNFS3_ACCESS_EXTEND,\tNFSD_MAY_EXEC|NFSD_MAY_WRITE\t},\n    {\tNFS3_ACCESS_DELETE,\tNFSD_MAY_REMOVE\t\t\t},\n\n#ifdef CONFIG_NFSD_V4\n    {\tNFS4_ACCESS_XAREAD,\tNFSD_MAY_READ\t\t\t},\n    {\tNFS4_ACCESS_XAWRITE,\tNFSD_MAY_WRITE\t\t\t},\n    {\tNFS4_ACCESS_XALIST,\tNFSD_MAY_READ\t\t\t},\n#endif\n\n    {\t0,\t\t\t0\t\t\t\t}\n};\n\nstatic struct accessmap\tnfs3_anyaccess[] = {\n\t \n    {\tNFS3_ACCESS_READ,\tNFSD_MAY_READ\t\t\t},\n    {\tNFS3_ACCESS_EXECUTE,\tNFSD_MAY_EXEC\t\t\t},\n    {\tNFS3_ACCESS_MODIFY,\tNFSD_MAY_WRITE|NFSD_MAY_LOCAL_ACCESS\t},\n    {\tNFS3_ACCESS_EXTEND,\tNFSD_MAY_WRITE|NFSD_MAY_LOCAL_ACCESS\t},\n\n    {\t0,\t\t\t0\t\t\t\t}\n};\n\n__be32\nnfsd_access(struct svc_rqst *rqstp, struct svc_fh *fhp, u32 *access, u32 *supported)\n{\n\tstruct accessmap\t*map;\n\tstruct svc_export\t*export;\n\tstruct dentry\t\t*dentry;\n\tu32\t\t\tquery, result = 0, sresult = 0;\n\t__be32\t\t\terror;\n\n\terror = fh_verify(rqstp, fhp, 0, NFSD_MAY_NOP);\n\tif (error)\n\t\tgoto out;\n\n\texport = fhp->fh_export;\n\tdentry = fhp->fh_dentry;\n\n\tif (d_is_reg(dentry))\n\t\tmap = nfs3_regaccess;\n\telse if (d_is_dir(dentry))\n\t\tmap = nfs3_diraccess;\n\telse\n\t\tmap = nfs3_anyaccess;\n\n\n\tquery = *access;\n\tfor  (; map->access; map++) {\n\t\tif (map->access & query) {\n\t\t\t__be32 err2;\n\n\t\t\tsresult |= map->access;\n\n\t\t\terr2 = nfsd_permission(rqstp, export, dentry, map->how);\n\t\t\tswitch (err2) {\n\t\t\tcase nfs_ok:\n\t\t\t\tresult |= map->access;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t \n\t\t\tcase nfserr_rofs:\n\t\t\tcase nfserr_acces:\n\t\t\tcase nfserr_perm:\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terror = err2;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\t*access = result;\n\tif (supported)\n\t\t*supported = sresult;\n\n out:\n\treturn error;\n}\n\nint nfsd_open_break_lease(struct inode *inode, int access)\n{\n\tunsigned int mode;\n\n\tif (access & NFSD_MAY_NOT_BREAK_LEASE)\n\t\treturn 0;\n\tmode = (access & NFSD_MAY_WRITE) ? O_WRONLY : O_RDONLY;\n\treturn break_lease(inode, mode | O_NONBLOCK);\n}\n\n \nstatic int\n__nfsd_open(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type,\n\t\t\tint may_flags, struct file **filp)\n{\n\tstruct path\tpath;\n\tstruct inode\t*inode;\n\tstruct file\t*file;\n\tint\t\tflags = O_RDONLY|O_LARGEFILE;\n\tint\t\thost_err = -EPERM;\n\n\tpath.mnt = fhp->fh_export->ex_path.mnt;\n\tpath.dentry = fhp->fh_dentry;\n\tinode = d_inode(path.dentry);\n\n\tif (IS_APPEND(inode) && (may_flags & NFSD_MAY_WRITE))\n\t\tgoto out;\n\n\tif (!inode->i_fop)\n\t\tgoto out;\n\n\thost_err = nfsd_open_break_lease(inode, may_flags);\n\tif (host_err)  \n\t\tgoto out;\n\n\tif (may_flags & NFSD_MAY_WRITE) {\n\t\tif (may_flags & NFSD_MAY_READ)\n\t\t\tflags = O_RDWR|O_LARGEFILE;\n\t\telse\n\t\t\tflags = O_WRONLY|O_LARGEFILE;\n\t}\n\n\tfile = dentry_open(&path, flags, current_cred());\n\tif (IS_ERR(file)) {\n\t\thost_err = PTR_ERR(file);\n\t\tgoto out;\n\t}\n\n\thost_err = ima_file_check(file, may_flags);\n\tif (host_err) {\n\t\tfput(file);\n\t\tgoto out;\n\t}\n\n\tif (may_flags & NFSD_MAY_64BIT_COOKIE)\n\t\tfile->f_mode |= FMODE_64BITHASH;\n\telse\n\t\tfile->f_mode |= FMODE_32BITHASH;\n\n\t*filp = file;\nout:\n\treturn host_err;\n}\n\n__be32\nnfsd_open(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type,\n\t\tint may_flags, struct file **filp)\n{\n\t__be32 err;\n\tint host_err;\n\tbool retried = false;\n\n\t \n\tif (type == S_IFREG)\n\t\tmay_flags |= NFSD_MAY_OWNER_OVERRIDE;\nretry:\n\terr = fh_verify(rqstp, fhp, type, may_flags);\n\tif (!err) {\n\t\thost_err = __nfsd_open(rqstp, fhp, type, may_flags, filp);\n\t\tif (host_err == -EOPENSTALE && !retried) {\n\t\t\tretried = true;\n\t\t\tfh_put(fhp);\n\t\t\tgoto retry;\n\t\t}\n\t\terr = nfserrno(host_err);\n\t}\n\treturn err;\n}\n\n \nint\nnfsd_open_verified(struct svc_rqst *rqstp, struct svc_fh *fhp, int may_flags,\n\t\t   struct file **filp)\n{\n\treturn __nfsd_open(rqstp, fhp, S_IFREG, may_flags, filp);\n}\n\n \nstatic int\nnfsd_splice_actor(struct pipe_inode_info *pipe, struct pipe_buffer *buf,\n\t\t  struct splice_desc *sd)\n{\n\tstruct svc_rqst *rqstp = sd->u.data;\n\tstruct page *page = buf->page;\t\n\tunsigned offset = buf->offset;\n\tstruct page *last_page;\n\n\tlast_page = page + (offset + sd->len - 1) / PAGE_SIZE;\n\tfor (page += offset / PAGE_SIZE; page <= last_page; page++) {\n\t\t \n\t\tif (page == *(rqstp->rq_next_page - 1) &&\n\t\t    offset_in_page(rqstp->rq_res.page_base +\n\t\t\t\t   rqstp->rq_res.page_len))\n\t\t\tcontinue;\n\t\tif (unlikely(!svc_rqst_replace_page(rqstp, page)))\n\t\t\treturn -EIO;\n\t}\n\tif (rqstp->rq_res.page_len == 0)\t\n\t\trqstp->rq_res.page_base = offset % PAGE_SIZE;\n\trqstp->rq_res.page_len += sd->len;\n\treturn sd->len;\n}\n\nstatic int nfsd_direct_splice_actor(struct pipe_inode_info *pipe,\n\t\t\t\t    struct splice_desc *sd)\n{\n\treturn __splice_from_pipe(pipe, sd, nfsd_splice_actor);\n}\n\nstatic u32 nfsd_eof_on_read(struct file *file, loff_t offset, ssize_t len,\n\t\tsize_t expected)\n{\n\tif (expected != 0 && len == 0)\n\t\treturn 1;\n\tif (offset+len >= i_size_read(file_inode(file)))\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic __be32 nfsd_finish_read(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\t\t       struct file *file, loff_t offset,\n\t\t\t       unsigned long *count, u32 *eof, ssize_t host_err)\n{\n\tif (host_err >= 0) {\n\t\tnfsd_stats_io_read_add(fhp->fh_export, host_err);\n\t\t*eof = nfsd_eof_on_read(file, offset, host_err, *count);\n\t\t*count = host_err;\n\t\tfsnotify_access(file);\n\t\ttrace_nfsd_read_io_done(rqstp, fhp, offset, *count);\n\t\treturn 0;\n\t} else {\n\t\ttrace_nfsd_read_err(rqstp, fhp, offset, host_err);\n\t\treturn nfserrno(host_err);\n\t}\n}\n\n \n__be32 nfsd_splice_read(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\t\tstruct file *file, loff_t offset, unsigned long *count,\n\t\t\tu32 *eof)\n{\n\tstruct splice_desc sd = {\n\t\t.len\t\t= 0,\n\t\t.total_len\t= *count,\n\t\t.pos\t\t= offset,\n\t\t.u.data\t\t= rqstp,\n\t};\n\tssize_t host_err;\n\n\ttrace_nfsd_read_splice(rqstp, fhp, offset, *count);\n\thost_err = splice_direct_to_actor(file, &sd, nfsd_direct_splice_actor);\n\treturn nfsd_finish_read(rqstp, fhp, file, offset, count, eof, host_err);\n}\n\n \n__be32 nfsd_iter_read(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\t      struct file *file, loff_t offset, unsigned long *count,\n\t\t      unsigned int base, u32 *eof)\n{\n\tunsigned long v, total;\n\tstruct iov_iter iter;\n\tloff_t ppos = offset;\n\tstruct page *page;\n\tssize_t host_err;\n\n\tv = 0;\n\ttotal = *count;\n\twhile (total) {\n\t\tpage = *(rqstp->rq_next_page++);\n\t\trqstp->rq_vec[v].iov_base = page_address(page) + base;\n\t\trqstp->rq_vec[v].iov_len = min_t(size_t, total, PAGE_SIZE - base);\n\t\ttotal -= rqstp->rq_vec[v].iov_len;\n\t\t++v;\n\t\tbase = 0;\n\t}\n\tWARN_ON_ONCE(v > ARRAY_SIZE(rqstp->rq_vec));\n\n\ttrace_nfsd_read_vector(rqstp, fhp, offset, *count);\n\tiov_iter_kvec(&iter, ITER_DEST, rqstp->rq_vec, v, *count);\n\thost_err = vfs_iter_read(file, &iter, &ppos, 0);\n\treturn nfsd_finish_read(rqstp, fhp, file, offset, count, eof, host_err);\n}\n\n \nstatic int wait_for_concurrent_writes(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstatic ino_t last_ino;\n\tstatic dev_t last_dev;\n\tint err = 0;\n\n\tif (atomic_read(&inode->i_writecount) > 1\n\t    || (last_ino == inode->i_ino && last_dev == inode->i_sb->s_dev)) {\n\t\tdprintk(\"nfsd: write defer %d\\n\", task_pid_nr(current));\n\t\tmsleep(10);\n\t\tdprintk(\"nfsd: write resume %d\\n\", task_pid_nr(current));\n\t}\n\n\tif (inode->i_state & I_DIRTY) {\n\t\tdprintk(\"nfsd: write sync %d\\n\", task_pid_nr(current));\n\t\terr = vfs_fsync(file, 0);\n\t}\n\tlast_ino = inode->i_ino;\n\tlast_dev = inode->i_sb->s_dev;\n\treturn err;\n}\n\n__be32\nnfsd_vfs_write(struct svc_rqst *rqstp, struct svc_fh *fhp, struct nfsd_file *nf,\n\t\t\t\tloff_t offset, struct kvec *vec, int vlen,\n\t\t\t\tunsigned long *cnt, int stable,\n\t\t\t\t__be32 *verf)\n{\n\tstruct nfsd_net\t\t*nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\tstruct file\t\t*file = nf->nf_file;\n\tstruct super_block\t*sb = file_inode(file)->i_sb;\n\tstruct svc_export\t*exp;\n\tstruct iov_iter\t\titer;\n\terrseq_t\t\tsince;\n\t__be32\t\t\tnfserr;\n\tint\t\t\thost_err;\n\tint\t\t\tuse_wgather;\n\tloff_t\t\t\tpos = offset;\n\tunsigned long\t\texp_op_flags = 0;\n\tunsigned int\t\tpflags = current->flags;\n\trwf_t\t\t\tflags = 0;\n\tbool\t\t\trestore_flags = false;\n\n\ttrace_nfsd_write_opened(rqstp, fhp, offset, *cnt);\n\n\tif (sb->s_export_op)\n\t\texp_op_flags = sb->s_export_op->flags;\n\n\tif (test_bit(RQ_LOCAL, &rqstp->rq_flags) &&\n\t    !(exp_op_flags & EXPORT_OP_REMOTE_FS)) {\n\t\t \n\t\tcurrent->flags |= PF_LOCAL_THROTTLE;\n\t\trestore_flags = true;\n\t}\n\n\texp = fhp->fh_export;\n\tuse_wgather = (rqstp->rq_vers == 2) && EX_WGATHER(exp);\n\n\tif (!EX_ISSYNC(exp))\n\t\tstable = NFS_UNSTABLE;\n\n\tif (stable && !use_wgather)\n\t\tflags |= RWF_SYNC;\n\n\tiov_iter_kvec(&iter, ITER_SOURCE, vec, vlen, *cnt);\n\tsince = READ_ONCE(file->f_wb_err);\n\tif (verf)\n\t\tnfsd_copy_write_verifier(verf, nn);\n\tfile_start_write(file);\n\thost_err = vfs_iter_write(file, &iter, &pos, flags);\n\tfile_end_write(file);\n\tif (host_err < 0) {\n\t\tnfsd_reset_write_verifier(nn);\n\t\ttrace_nfsd_writeverf_reset(nn, rqstp, host_err);\n\t\tgoto out_nfserr;\n\t}\n\t*cnt = host_err;\n\tnfsd_stats_io_write_add(exp, *cnt);\n\tfsnotify_modify(file);\n\thost_err = filemap_check_wb_err(file->f_mapping, since);\n\tif (host_err < 0)\n\t\tgoto out_nfserr;\n\n\tif (stable && use_wgather) {\n\t\thost_err = wait_for_concurrent_writes(file);\n\t\tif (host_err < 0) {\n\t\t\tnfsd_reset_write_verifier(nn);\n\t\t\ttrace_nfsd_writeverf_reset(nn, rqstp, host_err);\n\t\t}\n\t}\n\nout_nfserr:\n\tif (host_err >= 0) {\n\t\ttrace_nfsd_write_io_done(rqstp, fhp, offset, *cnt);\n\t\tnfserr = nfs_ok;\n\t} else {\n\t\ttrace_nfsd_write_err(rqstp, fhp, offset, host_err);\n\t\tnfserr = nfserrno(host_err);\n\t}\n\tif (restore_flags)\n\t\tcurrent_restore_flags(pflags, PF_LOCAL_THROTTLE);\n\treturn nfserr;\n}\n\n \n__be32 nfsd_read(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\t loff_t offset, unsigned long *count, u32 *eof)\n{\n\tstruct nfsd_file\t*nf;\n\tstruct file *file;\n\t__be32 err;\n\n\ttrace_nfsd_read_start(rqstp, fhp, offset, *count);\n\terr = nfsd_file_acquire_gc(rqstp, fhp, NFSD_MAY_READ, &nf);\n\tif (err)\n\t\treturn err;\n\n\tfile = nf->nf_file;\n\tif (file->f_op->splice_read && test_bit(RQ_SPLICE_OK, &rqstp->rq_flags))\n\t\terr = nfsd_splice_read(rqstp, fhp, file, offset, count, eof);\n\telse\n\t\terr = nfsd_iter_read(rqstp, fhp, file, offset, count, 0, eof);\n\n\tnfsd_file_put(nf);\n\ttrace_nfsd_read_done(rqstp, fhp, offset, *count);\n\treturn err;\n}\n\n \n__be32\nnfsd_write(struct svc_rqst *rqstp, struct svc_fh *fhp, loff_t offset,\n\t   struct kvec *vec, int vlen, unsigned long *cnt, int stable,\n\t   __be32 *verf)\n{\n\tstruct nfsd_file *nf;\n\t__be32 err;\n\n\ttrace_nfsd_write_start(rqstp, fhp, offset, *cnt);\n\n\terr = nfsd_file_acquire_gc(rqstp, fhp, NFSD_MAY_WRITE, &nf);\n\tif (err)\n\t\tgoto out;\n\n\terr = nfsd_vfs_write(rqstp, fhp, nf, offset, vec,\n\t\t\tvlen, cnt, stable, verf);\n\tnfsd_file_put(nf);\nout:\n\ttrace_nfsd_write_done(rqstp, fhp, offset, *cnt);\n\treturn err;\n}\n\n \n__be32\nnfsd_commit(struct svc_rqst *rqstp, struct svc_fh *fhp, struct nfsd_file *nf,\n\t    u64 offset, u32 count, __be32 *verf)\n{\n\t__be32\t\t\terr = nfs_ok;\n\tu64\t\t\tmaxbytes;\n\tloff_t\t\t\tstart, end;\n\tstruct nfsd_net\t\t*nn;\n\n\t \n\tstart = 0;\n\tend = LLONG_MAX;\n\tmaxbytes = (u64)fhp->fh_dentry->d_sb->s_maxbytes;\n\tif (offset < maxbytes) {\n\t\tstart = offset;\n\t\tif (count && (offset + count - 1 < maxbytes))\n\t\t\tend = offset + count - 1;\n\t}\n\n\tnn = net_generic(nf->nf_net, nfsd_net_id);\n\tif (EX_ISSYNC(fhp->fh_export)) {\n\t\terrseq_t since = READ_ONCE(nf->nf_file->f_wb_err);\n\t\tint err2;\n\n\t\terr2 = vfs_fsync_range(nf->nf_file, start, end, 0);\n\t\tswitch (err2) {\n\t\tcase 0:\n\t\t\tnfsd_copy_write_verifier(verf, nn);\n\t\t\terr2 = filemap_check_wb_err(nf->nf_file->f_mapping,\n\t\t\t\t\t\t    since);\n\t\t\terr = nfserrno(err2);\n\t\t\tbreak;\n\t\tcase -EINVAL:\n\t\t\terr = nfserr_notsupp;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnfsd_reset_write_verifier(nn);\n\t\t\ttrace_nfsd_writeverf_reset(nn, rqstp, err2);\n\t\t\terr = nfserrno(err2);\n\t\t}\n\t} else\n\t\tnfsd_copy_write_verifier(verf, nn);\n\n\treturn err;\n}\n\n \n__be32\nnfsd_create_setattr(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\t    struct svc_fh *resfhp, struct nfsd_attrs *attrs)\n{\n\tstruct iattr *iap = attrs->na_iattr;\n\t__be32 status;\n\n\t \n\tiap->ia_valid &= ~ATTR_MODE;\n\n\t \n\tif (!uid_eq(current_fsuid(), GLOBAL_ROOT_UID))\n\t\tiap->ia_valid &= ~(ATTR_UID|ATTR_GID);\n\n\t \n\tif (iap->ia_valid)\n\t\tstatus = nfsd_setattr(rqstp, resfhp, attrs, 0, (time64_t)0);\n\telse\n\t\tstatus = nfserrno(commit_metadata(resfhp));\n\n\t \n\tif (!status)\n\t\tstatus = nfserrno(commit_metadata(fhp));\n\n\t \n\tif (!status)\n\t\tstatus = fh_update(resfhp);\n\n\treturn status;\n}\n\n \nstatic void\nnfsd_check_ignore_resizing(struct iattr *iap)\n{\n\tif ((iap->ia_valid & ATTR_SIZE) && (iap->ia_size == 0))\n\t\tiap->ia_valid &= ~ATTR_SIZE;\n}\n\n \n__be32\nnfsd_create_locked(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\t   struct nfsd_attrs *attrs,\n\t\t   int type, dev_t rdev, struct svc_fh *resfhp)\n{\n\tstruct dentry\t*dentry, *dchild;\n\tstruct inode\t*dirp;\n\tstruct iattr\t*iap = attrs->na_iattr;\n\t__be32\t\terr;\n\tint\t\thost_err;\n\n\tdentry = fhp->fh_dentry;\n\tdirp = d_inode(dentry);\n\n\tdchild = dget(resfhp->fh_dentry);\n\terr = nfsd_permission(rqstp, fhp->fh_export, dentry, NFSD_MAY_CREATE);\n\tif (err)\n\t\tgoto out;\n\n\tif (!(iap->ia_valid & ATTR_MODE))\n\t\tiap->ia_mode = 0;\n\tiap->ia_mode = (iap->ia_mode & S_IALLUGO) | type;\n\n\tif (!IS_POSIXACL(dirp))\n\t\tiap->ia_mode &= ~current_umask();\n\n\terr = 0;\n\tswitch (type) {\n\tcase S_IFREG:\n\t\thost_err = vfs_create(&nop_mnt_idmap, dirp, dchild,\n\t\t\t\t      iap->ia_mode, true);\n\t\tif (!host_err)\n\t\t\tnfsd_check_ignore_resizing(iap);\n\t\tbreak;\n\tcase S_IFDIR:\n\t\thost_err = vfs_mkdir(&nop_mnt_idmap, dirp, dchild, iap->ia_mode);\n\t\tif (!host_err && unlikely(d_unhashed(dchild))) {\n\t\t\tstruct dentry *d;\n\t\t\td = lookup_one_len(dchild->d_name.name,\n\t\t\t\t\t   dchild->d_parent,\n\t\t\t\t\t   dchild->d_name.len);\n\t\t\tif (IS_ERR(d)) {\n\t\t\t\thost_err = PTR_ERR(d);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (unlikely(d_is_negative(d))) {\n\t\t\t\tdput(d);\n\t\t\t\terr = nfserr_serverfault;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tdput(resfhp->fh_dentry);\n\t\t\tresfhp->fh_dentry = dget(d);\n\t\t\terr = fh_update(resfhp);\n\t\t\tdput(dchild);\n\t\t\tdchild = d;\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFIFO:\n\tcase S_IFSOCK:\n\t\thost_err = vfs_mknod(&nop_mnt_idmap, dirp, dchild,\n\t\t\t\t     iap->ia_mode, rdev);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"nfsd: bad file type %o in nfsd_create\\n\",\n\t\t       type);\n\t\thost_err = -EINVAL;\n\t}\n\tif (host_err < 0)\n\t\tgoto out_nfserr;\n\n\terr = nfsd_create_setattr(rqstp, fhp, resfhp, attrs);\n\nout:\n\tdput(dchild);\n\treturn err;\n\nout_nfserr:\n\terr = nfserrno(host_err);\n\tgoto out;\n}\n\n \n__be32\nnfsd_create(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t    char *fname, int flen, struct nfsd_attrs *attrs,\n\t    int type, dev_t rdev, struct svc_fh *resfhp)\n{\n\tstruct dentry\t*dentry, *dchild = NULL;\n\t__be32\t\terr;\n\tint\t\thost_err;\n\n\tif (isdotent(fname, flen))\n\t\treturn nfserr_exist;\n\n\terr = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_NOP);\n\tif (err)\n\t\treturn err;\n\n\tdentry = fhp->fh_dentry;\n\n\thost_err = fh_want_write(fhp);\n\tif (host_err)\n\t\treturn nfserrno(host_err);\n\n\tinode_lock_nested(dentry->d_inode, I_MUTEX_PARENT);\n\tdchild = lookup_one_len(fname, dentry, flen);\n\thost_err = PTR_ERR(dchild);\n\tif (IS_ERR(dchild)) {\n\t\terr = nfserrno(host_err);\n\t\tgoto out_unlock;\n\t}\n\terr = fh_compose(resfhp, fhp->fh_export, dchild, fhp);\n\t \n\tdput(dchild);\n\tif (err)\n\t\tgoto out_unlock;\n\terr = fh_fill_pre_attrs(fhp);\n\tif (err != nfs_ok)\n\t\tgoto out_unlock;\n\terr = nfsd_create_locked(rqstp, fhp, attrs, type, rdev, resfhp);\n\tfh_fill_post_attrs(fhp);\nout_unlock:\n\tinode_unlock(dentry->d_inode);\n\treturn err;\n}\n\n \n__be32\nnfsd_readlink(struct svc_rqst *rqstp, struct svc_fh *fhp, char *buf, int *lenp)\n{\n\t__be32\t\terr;\n\tconst char *link;\n\tstruct path path;\n\tDEFINE_DELAYED_CALL(done);\n\tint len;\n\n\terr = fh_verify(rqstp, fhp, S_IFLNK, NFSD_MAY_NOP);\n\tif (unlikely(err))\n\t\treturn err;\n\n\tpath.mnt = fhp->fh_export->ex_path.mnt;\n\tpath.dentry = fhp->fh_dentry;\n\n\tif (unlikely(!d_is_symlink(path.dentry)))\n\t\treturn nfserr_inval;\n\n\ttouch_atime(&path);\n\n\tlink = vfs_get_link(path.dentry, &done);\n\tif (IS_ERR(link))\n\t\treturn nfserrno(PTR_ERR(link));\n\n\tlen = strlen(link);\n\tif (len < *lenp)\n\t\t*lenp = len;\n\tmemcpy(buf, link, *lenp);\n\tdo_delayed_call(&done);\n\treturn 0;\n}\n\n \n__be32\nnfsd_symlink(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t     char *fname, int flen,\n\t     char *path, struct nfsd_attrs *attrs,\n\t     struct svc_fh *resfhp)\n{\n\tstruct dentry\t*dentry, *dnew;\n\t__be32\t\terr, cerr;\n\tint\t\thost_err;\n\n\terr = nfserr_noent;\n\tif (!flen || path[0] == '\\0')\n\t\tgoto out;\n\terr = nfserr_exist;\n\tif (isdotent(fname, flen))\n\t\tgoto out;\n\n\terr = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_CREATE);\n\tif (err)\n\t\tgoto out;\n\n\thost_err = fh_want_write(fhp);\n\tif (host_err) {\n\t\terr = nfserrno(host_err);\n\t\tgoto out;\n\t}\n\n\tdentry = fhp->fh_dentry;\n\tinode_lock_nested(dentry->d_inode, I_MUTEX_PARENT);\n\tdnew = lookup_one_len(fname, dentry, flen);\n\tif (IS_ERR(dnew)) {\n\t\terr = nfserrno(PTR_ERR(dnew));\n\t\tinode_unlock(dentry->d_inode);\n\t\tgoto out_drop_write;\n\t}\n\terr = fh_fill_pre_attrs(fhp);\n\tif (err != nfs_ok)\n\t\tgoto out_unlock;\n\thost_err = vfs_symlink(&nop_mnt_idmap, d_inode(dentry), dnew, path);\n\terr = nfserrno(host_err);\n\tcerr = fh_compose(resfhp, fhp->fh_export, dnew, fhp);\n\tif (!err)\n\t\tnfsd_create_setattr(rqstp, fhp, resfhp, attrs);\n\tfh_fill_post_attrs(fhp);\nout_unlock:\n\tinode_unlock(dentry->d_inode);\n\tif (!err)\n\t\terr = nfserrno(commit_metadata(fhp));\n\tdput(dnew);\n\tif (err==0) err = cerr;\nout_drop_write:\n\tfh_drop_write(fhp);\nout:\n\treturn err;\n}\n\n \n__be32\nnfsd_link(struct svc_rqst *rqstp, struct svc_fh *ffhp,\n\t\t\t\tchar *name, int len, struct svc_fh *tfhp)\n{\n\tstruct dentry\t*ddir, *dnew, *dold;\n\tstruct inode\t*dirp;\n\t__be32\t\terr;\n\tint\t\thost_err;\n\n\terr = fh_verify(rqstp, ffhp, S_IFDIR, NFSD_MAY_CREATE);\n\tif (err)\n\t\tgoto out;\n\terr = fh_verify(rqstp, tfhp, 0, NFSD_MAY_NOP);\n\tif (err)\n\t\tgoto out;\n\terr = nfserr_isdir;\n\tif (d_is_dir(tfhp->fh_dentry))\n\t\tgoto out;\n\terr = nfserr_perm;\n\tif (!len)\n\t\tgoto out;\n\terr = nfserr_exist;\n\tif (isdotent(name, len))\n\t\tgoto out;\n\n\thost_err = fh_want_write(tfhp);\n\tif (host_err) {\n\t\terr = nfserrno(host_err);\n\t\tgoto out;\n\t}\n\n\tddir = ffhp->fh_dentry;\n\tdirp = d_inode(ddir);\n\tinode_lock_nested(dirp, I_MUTEX_PARENT);\n\n\tdnew = lookup_one_len(name, ddir, len);\n\tif (IS_ERR(dnew)) {\n\t\terr = nfserrno(PTR_ERR(dnew));\n\t\tgoto out_unlock;\n\t}\n\n\tdold = tfhp->fh_dentry;\n\n\terr = nfserr_noent;\n\tif (d_really_is_negative(dold))\n\t\tgoto out_dput;\n\terr = fh_fill_pre_attrs(ffhp);\n\tif (err != nfs_ok)\n\t\tgoto out_dput;\n\thost_err = vfs_link(dold, &nop_mnt_idmap, dirp, dnew, NULL);\n\tfh_fill_post_attrs(ffhp);\n\tinode_unlock(dirp);\n\tif (!host_err) {\n\t\terr = nfserrno(commit_metadata(ffhp));\n\t\tif (!err)\n\t\t\terr = nfserrno(commit_metadata(tfhp));\n\t} else {\n\t\tif (host_err == -EXDEV && rqstp->rq_vers == 2)\n\t\t\terr = nfserr_acces;\n\t\telse\n\t\t\terr = nfserrno(host_err);\n\t}\n\tdput(dnew);\nout_drop_write:\n\tfh_drop_write(tfhp);\nout:\n\treturn err;\n\nout_dput:\n\tdput(dnew);\nout_unlock:\n\tinode_unlock(dirp);\n\tgoto out_drop_write;\n}\n\nstatic void\nnfsd_close_cached_files(struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(dentry);\n\n\tif (inode && S_ISREG(inode->i_mode))\n\t\tnfsd_file_close_inode_sync(inode);\n}\n\nstatic bool\nnfsd_has_cached_files(struct dentry *dentry)\n{\n\tbool\t\tret = false;\n\tstruct inode *inode = d_inode(dentry);\n\n\tif (inode && S_ISREG(inode->i_mode))\n\t\tret = nfsd_file_is_cached(inode);\n\treturn ret;\n}\n\n \n__be32\nnfsd_rename(struct svc_rqst *rqstp, struct svc_fh *ffhp, char *fname, int flen,\n\t\t\t    struct svc_fh *tfhp, char *tname, int tlen)\n{\n\tstruct dentry\t*fdentry, *tdentry, *odentry, *ndentry, *trap;\n\tstruct inode\t*fdir, *tdir;\n\t__be32\t\terr;\n\tint\t\thost_err;\n\tbool\t\tclose_cached = false;\n\n\terr = fh_verify(rqstp, ffhp, S_IFDIR, NFSD_MAY_REMOVE);\n\tif (err)\n\t\tgoto out;\n\terr = fh_verify(rqstp, tfhp, S_IFDIR, NFSD_MAY_CREATE);\n\tif (err)\n\t\tgoto out;\n\n\tfdentry = ffhp->fh_dentry;\n\tfdir = d_inode(fdentry);\n\n\ttdentry = tfhp->fh_dentry;\n\ttdir = d_inode(tdentry);\n\n\terr = nfserr_perm;\n\tif (!flen || isdotent(fname, flen) || !tlen || isdotent(tname, tlen))\n\t\tgoto out;\n\n\terr = (rqstp->rq_vers == 2) ? nfserr_acces : nfserr_xdev;\n\tif (ffhp->fh_export->ex_path.mnt != tfhp->fh_export->ex_path.mnt)\n\t\tgoto out;\n\tif (ffhp->fh_export->ex_path.dentry != tfhp->fh_export->ex_path.dentry)\n\t\tgoto out;\n\nretry:\n\thost_err = fh_want_write(ffhp);\n\tif (host_err) {\n\t\terr = nfserrno(host_err);\n\t\tgoto out;\n\t}\n\n\ttrap = lock_rename(tdentry, fdentry);\n\terr = fh_fill_pre_attrs(ffhp);\n\tif (err != nfs_ok)\n\t\tgoto out_unlock;\n\terr = fh_fill_pre_attrs(tfhp);\n\tif (err != nfs_ok)\n\t\tgoto out_unlock;\n\n\todentry = lookup_one_len(fname, fdentry, flen);\n\thost_err = PTR_ERR(odentry);\n\tif (IS_ERR(odentry))\n\t\tgoto out_nfserr;\n\n\thost_err = -ENOENT;\n\tif (d_really_is_negative(odentry))\n\t\tgoto out_dput_old;\n\thost_err = -EINVAL;\n\tif (odentry == trap)\n\t\tgoto out_dput_old;\n\n\tndentry = lookup_one_len(tname, tdentry, tlen);\n\thost_err = PTR_ERR(ndentry);\n\tif (IS_ERR(ndentry))\n\t\tgoto out_dput_old;\n\thost_err = -ENOTEMPTY;\n\tif (ndentry == trap)\n\t\tgoto out_dput_new;\n\n\tif ((ndentry->d_sb->s_export_op->flags & EXPORT_OP_CLOSE_BEFORE_UNLINK) &&\n\t    nfsd_has_cached_files(ndentry)) {\n\t\tclose_cached = true;\n\t\tgoto out_dput_old;\n\t} else {\n\t\tstruct renamedata rd = {\n\t\t\t.old_mnt_idmap\t= &nop_mnt_idmap,\n\t\t\t.old_dir\t= fdir,\n\t\t\t.old_dentry\t= odentry,\n\t\t\t.new_mnt_idmap\t= &nop_mnt_idmap,\n\t\t\t.new_dir\t= tdir,\n\t\t\t.new_dentry\t= ndentry,\n\t\t};\n\t\tint retries;\n\n\t\tfor (retries = 1;;) {\n\t\t\thost_err = vfs_rename(&rd);\n\t\t\tif (host_err != -EAGAIN || !retries--)\n\t\t\t\tbreak;\n\t\t\tif (!nfsd_wait_for_delegreturn(rqstp, d_inode(odentry)))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!host_err) {\n\t\t\thost_err = commit_metadata(tfhp);\n\t\t\tif (!host_err)\n\t\t\t\thost_err = commit_metadata(ffhp);\n\t\t}\n\t}\n out_dput_new:\n\tdput(ndentry);\n out_dput_old:\n\tdput(odentry);\n out_nfserr:\n\terr = nfserrno(host_err);\n\n\tif (!close_cached) {\n\t\tfh_fill_post_attrs(ffhp);\n\t\tfh_fill_post_attrs(tfhp);\n\t}\nout_unlock:\n\tunlock_rename(tdentry, fdentry);\n\tfh_drop_write(ffhp);\n\n\t \n\tif (close_cached) {\n\t\tclose_cached = false;\n\t\tnfsd_close_cached_files(ndentry);\n\t\tdput(ndentry);\n\t\tgoto retry;\n\t}\nout:\n\treturn err;\n}\n\n \n__be32\nnfsd_unlink(struct svc_rqst *rqstp, struct svc_fh *fhp, int type,\n\t\t\t\tchar *fname, int flen)\n{\n\tstruct dentry\t*dentry, *rdentry;\n\tstruct inode\t*dirp;\n\tstruct inode\t*rinode;\n\t__be32\t\terr;\n\tint\t\thost_err;\n\n\terr = nfserr_acces;\n\tif (!flen || isdotent(fname, flen))\n\t\tgoto out;\n\terr = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_REMOVE);\n\tif (err)\n\t\tgoto out;\n\n\thost_err = fh_want_write(fhp);\n\tif (host_err)\n\t\tgoto out_nfserr;\n\n\tdentry = fhp->fh_dentry;\n\tdirp = d_inode(dentry);\n\tinode_lock_nested(dirp, I_MUTEX_PARENT);\n\n\trdentry = lookup_one_len(fname, dentry, flen);\n\thost_err = PTR_ERR(rdentry);\n\tif (IS_ERR(rdentry))\n\t\tgoto out_unlock;\n\n\tif (d_really_is_negative(rdentry)) {\n\t\tdput(rdentry);\n\t\thost_err = -ENOENT;\n\t\tgoto out_unlock;\n\t}\n\trinode = d_inode(rdentry);\n\terr = fh_fill_pre_attrs(fhp);\n\tif (err != nfs_ok)\n\t\tgoto out_unlock;\n\n\tihold(rinode);\n\tif (!type)\n\t\ttype = d_inode(rdentry)->i_mode & S_IFMT;\n\n\tif (type != S_IFDIR) {\n\t\tint retries;\n\n\t\tif (rdentry->d_sb->s_export_op->flags & EXPORT_OP_CLOSE_BEFORE_UNLINK)\n\t\t\tnfsd_close_cached_files(rdentry);\n\n\t\tfor (retries = 1;;) {\n\t\t\thost_err = vfs_unlink(&nop_mnt_idmap, dirp, rdentry, NULL);\n\t\t\tif (host_err != -EAGAIN || !retries--)\n\t\t\t\tbreak;\n\t\t\tif (!nfsd_wait_for_delegreturn(rqstp, rinode))\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\thost_err = vfs_rmdir(&nop_mnt_idmap, dirp, rdentry);\n\t}\n\tfh_fill_post_attrs(fhp);\n\n\tinode_unlock(dirp);\n\tif (!host_err)\n\t\thost_err = commit_metadata(fhp);\n\tdput(rdentry);\n\tiput(rinode);     \n\nout_drop_write:\n\tfh_drop_write(fhp);\nout_nfserr:\n\tif (host_err == -EBUSY) {\n\t\t \n\t\tif (nfsd_v4client(rqstp))\n\t\t\terr = nfserr_file_open;\n\t\telse\n\t\t\terr = nfserr_acces;\n\t} else {\n\t\terr = nfserrno(host_err);\n\t}\nout:\n\treturn err;\nout_unlock:\n\tinode_unlock(dirp);\n\tgoto out_drop_write;\n}\n\n \nstruct buffered_dirent {\n\tu64\t\tino;\n\tloff_t\t\toffset;\n\tint\t\tnamlen;\n\tunsigned int\td_type;\n\tchar\t\tname[];\n};\n\nstruct readdir_data {\n\tstruct dir_context ctx;\n\tchar\t\t*dirent;\n\tsize_t\t\tused;\n\tint\t\tfull;\n};\n\nstatic bool nfsd_buffered_filldir(struct dir_context *ctx, const char *name,\n\t\t\t\t int namlen, loff_t offset, u64 ino,\n\t\t\t\t unsigned int d_type)\n{\n\tstruct readdir_data *buf =\n\t\tcontainer_of(ctx, struct readdir_data, ctx);\n\tstruct buffered_dirent *de = (void *)(buf->dirent + buf->used);\n\tunsigned int reclen;\n\n\treclen = ALIGN(sizeof(struct buffered_dirent) + namlen, sizeof(u64));\n\tif (buf->used + reclen > PAGE_SIZE) {\n\t\tbuf->full = 1;\n\t\treturn false;\n\t}\n\n\tde->namlen = namlen;\n\tde->offset = offset;\n\tde->ino = ino;\n\tde->d_type = d_type;\n\tmemcpy(de->name, name, namlen);\n\tbuf->used += reclen;\n\n\treturn true;\n}\n\nstatic __be32 nfsd_buffered_readdir(struct file *file, struct svc_fh *fhp,\n\t\t\t\t    nfsd_filldir_t func, struct readdir_cd *cdp,\n\t\t\t\t    loff_t *offsetp)\n{\n\tstruct buffered_dirent *de;\n\tint host_err;\n\tint size;\n\tloff_t offset;\n\tstruct readdir_data buf = {\n\t\t.ctx.actor = nfsd_buffered_filldir,\n\t\t.dirent = (void *)__get_free_page(GFP_KERNEL)\n\t};\n\n\tif (!buf.dirent)\n\t\treturn nfserrno(-ENOMEM);\n\n\toffset = *offsetp;\n\n\twhile (1) {\n\t\tunsigned int reclen;\n\n\t\tcdp->err = nfserr_eof;  \n\t\tbuf.used = 0;\n\t\tbuf.full = 0;\n\n\t\thost_err = iterate_dir(file, &buf.ctx);\n\t\tif (buf.full)\n\t\t\thost_err = 0;\n\n\t\tif (host_err < 0)\n\t\t\tbreak;\n\n\t\tsize = buf.used;\n\n\t\tif (!size)\n\t\t\tbreak;\n\n\t\tde = (struct buffered_dirent *)buf.dirent;\n\t\twhile (size > 0) {\n\t\t\toffset = de->offset;\n\n\t\t\tif (func(cdp, de->name, de->namlen, de->offset,\n\t\t\t\t de->ino, de->d_type))\n\t\t\t\tbreak;\n\n\t\t\tif (cdp->err != nfs_ok)\n\t\t\t\tbreak;\n\n\t\t\ttrace_nfsd_dirent(fhp, de->ino, de->name, de->namlen);\n\n\t\t\treclen = ALIGN(sizeof(*de) + de->namlen,\n\t\t\t\t       sizeof(u64));\n\t\t\tsize -= reclen;\n\t\t\tde = (struct buffered_dirent *)((char *)de + reclen);\n\t\t}\n\t\tif (size > 0)  \n\t\t\tbreak;\n\n\t\toffset = vfs_llseek(file, 0, SEEK_CUR);\n\t}\n\n\tfree_page((unsigned long)(buf.dirent));\n\n\tif (host_err)\n\t\treturn nfserrno(host_err);\n\n\t*offsetp = offset;\n\treturn cdp->err;\n}\n\n \n__be32\nnfsd_readdir(struct svc_rqst *rqstp, struct svc_fh *fhp, loff_t *offsetp, \n\t     struct readdir_cd *cdp, nfsd_filldir_t func)\n{\n\t__be32\t\terr;\n\tstruct file\t*file;\n\tloff_t\t\toffset = *offsetp;\n\tint             may_flags = NFSD_MAY_READ;\n\n\t \n\tif (rqstp->rq_vers > 2)\n\t\tmay_flags |= NFSD_MAY_64BIT_COOKIE;\n\n\terr = nfsd_open(rqstp, fhp, S_IFDIR, may_flags, &file);\n\tif (err)\n\t\tgoto out;\n\n\toffset = vfs_llseek(file, offset, SEEK_SET);\n\tif (offset < 0) {\n\t\terr = nfserrno((int)offset);\n\t\tgoto out_close;\n\t}\n\n\terr = nfsd_buffered_readdir(file, fhp, func, cdp, offsetp);\n\n\tif (err == nfserr_eof || err == nfserr_toosmall)\n\t\terr = nfs_ok;  \nout_close:\n\tfput(file);\nout:\n\treturn err;\n}\n\n \n__be32\nnfsd_statfs(struct svc_rqst *rqstp, struct svc_fh *fhp, struct kstatfs *stat, int access)\n{\n\t__be32 err;\n\n\terr = fh_verify(rqstp, fhp, 0, NFSD_MAY_NOP | access);\n\tif (!err) {\n\t\tstruct path path = {\n\t\t\t.mnt\t= fhp->fh_export->ex_path.mnt,\n\t\t\t.dentry\t= fhp->fh_dentry,\n\t\t};\n\t\tif (vfs_statfs(&path, stat))\n\t\t\terr = nfserr_io;\n\t}\n\treturn err;\n}\n\nstatic int exp_rdonly(struct svc_rqst *rqstp, struct svc_export *exp)\n{\n\treturn nfsexp_flags(rqstp, exp) & NFSEXP_READONLY;\n}\n\n#ifdef CONFIG_NFSD_V4\n \nstatic __be32\nnfsd_xattr_errno(int err)\n{\n\tswitch (err) {\n\tcase -ENODATA:\n\t\treturn nfserr_noxattr;\n\tcase -E2BIG:\n\t\treturn nfserr_xattr2big;\n\tcase -ERANGE:\n\t\treturn nfserr_toosmall;\n\t}\n\treturn nfserrno(err);\n}\n\n \n__be32\nnfsd_getxattr(struct svc_rqst *rqstp, struct svc_fh *fhp, char *name,\n\t      void **bufp, int *lenp)\n{\n\tssize_t len;\n\t__be32 err;\n\tchar *buf;\n\tstruct inode *inode;\n\tstruct dentry *dentry;\n\n\terr = fh_verify(rqstp, fhp, 0, NFSD_MAY_READ);\n\tif (err)\n\t\treturn err;\n\n\terr = nfs_ok;\n\tdentry = fhp->fh_dentry;\n\tinode = d_inode(dentry);\n\n\tinode_lock_shared(inode);\n\n\tlen = vfs_getxattr(&nop_mnt_idmap, dentry, name, NULL, 0);\n\n\t \n\tif (len == 0) {\n\t\t*bufp = NULL;\n\t\t*lenp = 0;\n\t\tgoto out;\n\t}\n\n\tif (len < 0) {\n\t\terr = nfsd_xattr_errno(len);\n\t\tgoto out;\n\t}\n\n\tif (len > *lenp) {\n\t\terr = nfserr_toosmall;\n\t\tgoto out;\n\t}\n\n\tbuf = kvmalloc(len, GFP_KERNEL);\n\tif (buf == NULL) {\n\t\terr = nfserr_jukebox;\n\t\tgoto out;\n\t}\n\n\tlen = vfs_getxattr(&nop_mnt_idmap, dentry, name, buf, len);\n\tif (len <= 0) {\n\t\tkvfree(buf);\n\t\tbuf = NULL;\n\t\terr = nfsd_xattr_errno(len);\n\t}\n\n\t*lenp = len;\n\t*bufp = buf;\n\nout:\n\tinode_unlock_shared(inode);\n\n\treturn err;\n}\n\n \n__be32\nnfsd_listxattr(struct svc_rqst *rqstp, struct svc_fh *fhp, char **bufp,\n\t       int *lenp)\n{\n\tssize_t len;\n\t__be32 err;\n\tchar *buf;\n\tstruct inode *inode;\n\tstruct dentry *dentry;\n\n\terr = fh_verify(rqstp, fhp, 0, NFSD_MAY_READ);\n\tif (err)\n\t\treturn err;\n\n\tdentry = fhp->fh_dentry;\n\tinode = d_inode(dentry);\n\t*lenp = 0;\n\n\tinode_lock_shared(inode);\n\n\tlen = vfs_listxattr(dentry, NULL, 0);\n\tif (len <= 0) {\n\t\terr = nfsd_xattr_errno(len);\n\t\tgoto out;\n\t}\n\n\tif (len > XATTR_LIST_MAX) {\n\t\terr = nfserr_xattr2big;\n\t\tgoto out;\n\t}\n\n\tbuf = kvmalloc(len, GFP_KERNEL);\n\tif (buf == NULL) {\n\t\terr = nfserr_jukebox;\n\t\tgoto out;\n\t}\n\n\tlen = vfs_listxattr(dentry, buf, len);\n\tif (len <= 0) {\n\t\tkvfree(buf);\n\t\terr = nfsd_xattr_errno(len);\n\t\tgoto out;\n\t}\n\n\t*lenp = len;\n\t*bufp = buf;\n\n\terr = nfs_ok;\nout:\n\tinode_unlock_shared(inode);\n\n\treturn err;\n}\n\n \n__be32\nnfsd_removexattr(struct svc_rqst *rqstp, struct svc_fh *fhp, char *name)\n{\n\t__be32 err;\n\tint ret;\n\n\terr = fh_verify(rqstp, fhp, 0, NFSD_MAY_WRITE);\n\tif (err)\n\t\treturn err;\n\n\tret = fh_want_write(fhp);\n\tif (ret)\n\t\treturn nfserrno(ret);\n\n\tinode_lock(fhp->fh_dentry->d_inode);\n\terr = fh_fill_pre_attrs(fhp);\n\tif (err != nfs_ok)\n\t\tgoto out_unlock;\n\tret = __vfs_removexattr_locked(&nop_mnt_idmap, fhp->fh_dentry,\n\t\t\t\t       name, NULL);\n\terr = nfsd_xattr_errno(ret);\n\tfh_fill_post_attrs(fhp);\nout_unlock:\n\tinode_unlock(fhp->fh_dentry->d_inode);\n\tfh_drop_write(fhp);\n\n\treturn err;\n}\n\n__be32\nnfsd_setxattr(struct svc_rqst *rqstp, struct svc_fh *fhp, char *name,\n\t      void *buf, u32 len, u32 flags)\n{\n\t__be32 err;\n\tint ret;\n\n\terr = fh_verify(rqstp, fhp, 0, NFSD_MAY_WRITE);\n\tif (err)\n\t\treturn err;\n\n\tret = fh_want_write(fhp);\n\tif (ret)\n\t\treturn nfserrno(ret);\n\tinode_lock(fhp->fh_dentry->d_inode);\n\terr = fh_fill_pre_attrs(fhp);\n\tif (err != nfs_ok)\n\t\tgoto out_unlock;\n\tret = __vfs_setxattr_locked(&nop_mnt_idmap, fhp->fh_dentry,\n\t\t\t\t    name, buf, len, flags, NULL);\n\tfh_fill_post_attrs(fhp);\n\terr = nfsd_xattr_errno(ret);\nout_unlock:\n\tinode_unlock(fhp->fh_dentry->d_inode);\n\tfh_drop_write(fhp);\n\treturn err;\n}\n#endif\n\n \n__be32\nnfsd_permission(struct svc_rqst *rqstp, struct svc_export *exp,\n\t\t\t\t\tstruct dentry *dentry, int acc)\n{\n\tstruct inode\t*inode = d_inode(dentry);\n\tint\t\terr;\n\n\tif ((acc & NFSD_MAY_MASK) == NFSD_MAY_NOP)\n\t\treturn 0;\n#if 0\n\tdprintk(\"nfsd: permission 0x%x%s%s%s%s%s%s%s mode 0%o%s%s%s\\n\",\n\t\tacc,\n\t\t(acc & NFSD_MAY_READ)?\t\" read\"  : \"\",\n\t\t(acc & NFSD_MAY_WRITE)?\t\" write\" : \"\",\n\t\t(acc & NFSD_MAY_EXEC)?\t\" exec\"  : \"\",\n\t\t(acc & NFSD_MAY_SATTR)?\t\" sattr\" : \"\",\n\t\t(acc & NFSD_MAY_TRUNC)?\t\" trunc\" : \"\",\n\t\t(acc & NFSD_MAY_LOCK)?\t\" lock\"  : \"\",\n\t\t(acc & NFSD_MAY_OWNER_OVERRIDE)? \" owneroverride\" : \"\",\n\t\tinode->i_mode,\n\t\tIS_IMMUTABLE(inode)?\t\" immut\" : \"\",\n\t\tIS_APPEND(inode)?\t\" append\" : \"\",\n\t\t__mnt_is_readonly(exp->ex_path.mnt)?\t\" ro\" : \"\");\n\tdprintk(\"      owner %d/%d user %d/%d\\n\",\n\t\tinode->i_uid, inode->i_gid, current_fsuid(), current_fsgid());\n#endif\n\n\t \n\tif (!(acc & NFSD_MAY_LOCAL_ACCESS))\n\t\tif (acc & (NFSD_MAY_WRITE | NFSD_MAY_SATTR | NFSD_MAY_TRUNC)) {\n\t\t\tif (exp_rdonly(rqstp, exp) ||\n\t\t\t    __mnt_is_readonly(exp->ex_path.mnt))\n\t\t\t\treturn nfserr_rofs;\n\t\t\tif (  IS_IMMUTABLE(inode))\n\t\t\t\treturn nfserr_perm;\n\t\t}\n\tif ((acc & NFSD_MAY_TRUNC) && IS_APPEND(inode))\n\t\treturn nfserr_perm;\n\n\tif (acc & NFSD_MAY_LOCK) {\n\t\t \n\t\tif (exp->ex_flags & NFSEXP_NOAUTHNLM)\n\t\t\treturn 0;\n\t\telse\n\t\t\tacc = NFSD_MAY_READ | NFSD_MAY_OWNER_OVERRIDE;\n\t}\n\t \n\tif ((acc & NFSD_MAY_OWNER_OVERRIDE) &&\n\t    uid_eq(inode->i_uid, current_fsuid()))\n\t\treturn 0;\n\n\t \n\terr = inode_permission(&nop_mnt_idmap, inode,\n\t\t\t       acc & (MAY_READ | MAY_WRITE | MAY_EXEC));\n\n\t \n\tif (err == -EACCES && S_ISREG(inode->i_mode) &&\n\t     (acc == (NFSD_MAY_READ | NFSD_MAY_OWNER_OVERRIDE) ||\n\t      acc == (NFSD_MAY_READ | NFSD_MAY_READ_IF_EXEC)))\n\t\terr = inode_permission(&nop_mnt_idmap, inode, MAY_EXEC);\n\n\treturn err? nfserrno(err) : 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}