{
  "module_name": "nfsd.h",
  "hash_id": "773b336ad97125f1e60adb3917f68f686db756e36e5450e77533b6060be6a960",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfsd/nfsd.h",
  "human_readable_source": " \n \n\n#ifndef LINUX_NFSD_NFSD_H\n#define LINUX_NFSD_NFSD_H\n\n#include <linux/types.h>\n#include <linux/mount.h>\n\n#include <linux/nfs.h>\n#include <linux/nfs2.h>\n#include <linux/nfs3.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/msg_prot.h>\n#include <linux/sunrpc/addr.h>\n\n#include <uapi/linux/nfsd/debug.h>\n\n#include \"netns.h\"\n#include \"export.h\"\n#include \"stats.h\"\n\n#undef ifdebug\n#ifdef CONFIG_SUNRPC_DEBUG\n# define ifdebug(flag)\t\tif (nfsd_debug & NFSDDBG_##flag)\n#else\n# define ifdebug(flag)\t\tif (0)\n#endif\n\n \n#define NFSD_SUPPORTED_MINOR_VERSION\t2\n \n#define NFSSVC_MAXBLKSIZE       RPCSVC_MAXPAYLOAD\n \n#define NFSSVC_MAXBLKSIZE_V2    (8*1024)\n\n\n \n#define NFSD_BUFSIZE            ((RPC_MAX_HEADER_WITH_AUTH+26)*XDR_UNIT + NFSSVC_MAXBLKSIZE)\n\nstruct readdir_cd {\n\t__be32\t\t\terr;\t \n};\n\n\nextern struct svc_program\tnfsd_program;\nextern const struct svc_version\tnfsd_version2, nfsd_version3, nfsd_version4;\nextern struct mutex\t\tnfsd_mutex;\nextern spinlock_t\t\tnfsd_drc_lock;\nextern unsigned long\t\tnfsd_drc_max_mem;\nextern unsigned long\t\tnfsd_drc_mem_used;\n\nextern const struct seq_operations nfs_exports_op;\n\n \nstruct nfsd_voidargs { };\nstruct nfsd_voidres { };\nbool\t\tnfssvc_decode_voidarg(struct svc_rqst *rqstp,\n\t\t\t\t      struct xdr_stream *xdr);\nbool\t\tnfssvc_encode_voidres(struct svc_rqst *rqstp,\n\t\t\t\t      struct xdr_stream *xdr);\n\n \nint\t\tnfsd_svc(int nrservs, struct net *net, const struct cred *cred);\nint\t\tnfsd_dispatch(struct svc_rqst *rqstp);\n\nint\t\tnfsd_nrthreads(struct net *);\nint\t\tnfsd_nrpools(struct net *);\nint\t\tnfsd_get_nrthreads(int n, int *, struct net *);\nint\t\tnfsd_set_nrthreads(int n, int *, struct net *);\nint\t\tnfsd_pool_stats_open(struct inode *, struct file *);\nint\t\tnfsd_pool_stats_release(struct inode *, struct file *);\nvoid\t\tnfsd_shutdown_threads(struct net *net);\n\nbool\t\ti_am_nfsd(void);\n\nstruct nfsdfs_client {\n\tstruct kref cl_ref;\n\tvoid (*cl_release)(struct kref *kref);\n};\n\nstruct nfsdfs_client *get_nfsdfs_client(struct inode *);\nstruct dentry *nfsd_client_mkdir(struct nfsd_net *nn,\n\t\t\t\t struct nfsdfs_client *ncl, u32 id,\n\t\t\t\t const struct tree_descr *,\n\t\t\t\t struct dentry **fdentries);\nvoid nfsd_client_rmdir(struct dentry *dentry);\n\n\n#if defined(CONFIG_NFSD_V2_ACL) || defined(CONFIG_NFSD_V3_ACL)\n#ifdef CONFIG_NFSD_V2_ACL\nextern const struct svc_version nfsd_acl_version2;\n#else\n#define nfsd_acl_version2 NULL\n#endif\n#ifdef CONFIG_NFSD_V3_ACL\nextern const struct svc_version nfsd_acl_version3;\n#else\n#define nfsd_acl_version3 NULL\n#endif\n#endif\n\nstruct nfsd_net;\n\nenum vers_op {NFSD_SET, NFSD_CLEAR, NFSD_TEST, NFSD_AVAIL };\nint nfsd_vers(struct nfsd_net *nn, int vers, enum vers_op change);\nint nfsd_minorversion(struct nfsd_net *nn, u32 minorversion, enum vers_op change);\nvoid nfsd_reset_versions(struct nfsd_net *nn);\nint nfsd_create_serv(struct net *net);\nvoid nfsd_last_thread(struct net *net);\n\nextern int nfsd_max_blksize;\n\nstatic inline int nfsd_v4client(struct svc_rqst *rq)\n{\n\treturn rq->rq_prog == NFS_PROGRAM && rq->rq_vers == 4;\n}\nstatic inline struct user_namespace *\nnfsd_user_namespace(const struct svc_rqst *rqstp)\n{\n\tconst struct cred *cred = rqstp->rq_xprt->xpt_cred;\n\treturn cred ? cred->user_ns : &init_user_ns;\n}\n\n \n#ifdef CONFIG_NFSD_V4\nextern unsigned long max_delegations;\nint nfsd4_init_slabs(void);\nvoid nfsd4_free_slabs(void);\nint nfs4_state_start(void);\nint nfs4_state_start_net(struct net *net);\nvoid nfs4_state_shutdown(void);\nvoid nfs4_state_shutdown_net(struct net *net);\nint nfs4_reset_recoverydir(char *recdir);\nchar * nfs4_recoverydir(void);\nbool nfsd4_spo_must_allow(struct svc_rqst *rqstp);\nint nfsd4_create_laundry_wq(void);\nvoid nfsd4_destroy_laundry_wq(void);\nbool nfsd_wait_for_delegreturn(struct svc_rqst *rqstp, struct inode *inode);\n#else\nstatic inline int nfsd4_init_slabs(void) { return 0; }\nstatic inline void nfsd4_free_slabs(void) { }\nstatic inline int nfs4_state_start(void) { return 0; }\nstatic inline int nfs4_state_start_net(struct net *net) { return 0; }\nstatic inline void nfs4_state_shutdown(void) { }\nstatic inline void nfs4_state_shutdown_net(struct net *net) { }\nstatic inline int nfs4_reset_recoverydir(char *recdir) { return 0; }\nstatic inline char * nfs4_recoverydir(void) {return NULL; }\nstatic inline bool nfsd4_spo_must_allow(struct svc_rqst *rqstp)\n{\n\treturn false;\n}\nstatic inline int nfsd4_create_laundry_wq(void) { return 0; };\nstatic inline void nfsd4_destroy_laundry_wq(void) {};\nstatic inline bool nfsd_wait_for_delegreturn(struct svc_rqst *rqstp,\n\t\t\t\t\t      struct inode *inode)\n{\n\treturn false;\n}\n#endif\n\n \nvoid\t\tnfsd_lockd_init(void);\nvoid\t\tnfsd_lockd_shutdown(void);\n\n\n \n#define\tnfs_ok\t\t\tcpu_to_be32(NFS_OK)\n#define\tnfserr_perm\t\tcpu_to_be32(NFSERR_PERM)\n#define\tnfserr_noent\t\tcpu_to_be32(NFSERR_NOENT)\n#define\tnfserr_io\t\tcpu_to_be32(NFSERR_IO)\n#define\tnfserr_nxio\t\tcpu_to_be32(NFSERR_NXIO)\n#define\tnfserr_eagain\t\tcpu_to_be32(NFSERR_EAGAIN)\n#define\tnfserr_acces\t\tcpu_to_be32(NFSERR_ACCES)\n#define\tnfserr_exist\t\tcpu_to_be32(NFSERR_EXIST)\n#define\tnfserr_xdev\t\tcpu_to_be32(NFSERR_XDEV)\n#define\tnfserr_nodev\t\tcpu_to_be32(NFSERR_NODEV)\n#define\tnfserr_notdir\t\tcpu_to_be32(NFSERR_NOTDIR)\n#define\tnfserr_isdir\t\tcpu_to_be32(NFSERR_ISDIR)\n#define\tnfserr_inval\t\tcpu_to_be32(NFSERR_INVAL)\n#define\tnfserr_fbig\t\tcpu_to_be32(NFSERR_FBIG)\n#define\tnfserr_nospc\t\tcpu_to_be32(NFSERR_NOSPC)\n#define\tnfserr_rofs\t\tcpu_to_be32(NFSERR_ROFS)\n#define\tnfserr_mlink\t\tcpu_to_be32(NFSERR_MLINK)\n#define\tnfserr_opnotsupp\tcpu_to_be32(NFSERR_OPNOTSUPP)\n#define\tnfserr_nametoolong\tcpu_to_be32(NFSERR_NAMETOOLONG)\n#define\tnfserr_notempty\t\tcpu_to_be32(NFSERR_NOTEMPTY)\n#define\tnfserr_dquot\t\tcpu_to_be32(NFSERR_DQUOT)\n#define\tnfserr_stale\t\tcpu_to_be32(NFSERR_STALE)\n#define\tnfserr_remote\t\tcpu_to_be32(NFSERR_REMOTE)\n#define\tnfserr_wflush\t\tcpu_to_be32(NFSERR_WFLUSH)\n#define\tnfserr_badhandle\tcpu_to_be32(NFSERR_BADHANDLE)\n#define\tnfserr_notsync\t\tcpu_to_be32(NFSERR_NOT_SYNC)\n#define\tnfserr_badcookie\tcpu_to_be32(NFSERR_BAD_COOKIE)\n#define\tnfserr_notsupp\t\tcpu_to_be32(NFSERR_NOTSUPP)\n#define\tnfserr_toosmall\t\tcpu_to_be32(NFSERR_TOOSMALL)\n#define\tnfserr_serverfault\tcpu_to_be32(NFSERR_SERVERFAULT)\n#define\tnfserr_badtype\t\tcpu_to_be32(NFSERR_BADTYPE)\n#define\tnfserr_jukebox\t\tcpu_to_be32(NFSERR_JUKEBOX)\n#define\tnfserr_denied\t\tcpu_to_be32(NFSERR_DENIED)\n#define\tnfserr_deadlock\t\tcpu_to_be32(NFSERR_DEADLOCK)\n#define nfserr_expired          cpu_to_be32(NFSERR_EXPIRED)\n#define\tnfserr_bad_cookie\tcpu_to_be32(NFSERR_BAD_COOKIE)\n#define\tnfserr_same\t\tcpu_to_be32(NFSERR_SAME)\n#define\tnfserr_clid_inuse\tcpu_to_be32(NFSERR_CLID_INUSE)\n#define\tnfserr_stale_clientid\tcpu_to_be32(NFSERR_STALE_CLIENTID)\n#define\tnfserr_resource\t\tcpu_to_be32(NFSERR_RESOURCE)\n#define\tnfserr_moved\t\tcpu_to_be32(NFSERR_MOVED)\n#define\tnfserr_nofilehandle\tcpu_to_be32(NFSERR_NOFILEHANDLE)\n#define\tnfserr_minor_vers_mismatch\tcpu_to_be32(NFSERR_MINOR_VERS_MISMATCH)\n#define nfserr_share_denied\tcpu_to_be32(NFSERR_SHARE_DENIED)\n#define nfserr_stale_stateid\tcpu_to_be32(NFSERR_STALE_STATEID)\n#define nfserr_old_stateid\tcpu_to_be32(NFSERR_OLD_STATEID)\n#define nfserr_bad_stateid\tcpu_to_be32(NFSERR_BAD_STATEID)\n#define nfserr_bad_seqid\tcpu_to_be32(NFSERR_BAD_SEQID)\n#define\tnfserr_symlink\t\tcpu_to_be32(NFSERR_SYMLINK)\n#define\tnfserr_not_same\t\tcpu_to_be32(NFSERR_NOT_SAME)\n#define nfserr_lock_range\tcpu_to_be32(NFSERR_LOCK_RANGE)\n#define\tnfserr_restorefh\tcpu_to_be32(NFSERR_RESTOREFH)\n#define\tnfserr_attrnotsupp\tcpu_to_be32(NFSERR_ATTRNOTSUPP)\n#define\tnfserr_bad_xdr\t\tcpu_to_be32(NFSERR_BAD_XDR)\n#define\tnfserr_openmode\t\tcpu_to_be32(NFSERR_OPENMODE)\n#define\tnfserr_badowner\t\tcpu_to_be32(NFSERR_BADOWNER)\n#define\tnfserr_locks_held\tcpu_to_be32(NFSERR_LOCKS_HELD)\n#define\tnfserr_op_illegal\tcpu_to_be32(NFSERR_OP_ILLEGAL)\n#define\tnfserr_grace\t\tcpu_to_be32(NFSERR_GRACE)\n#define\tnfserr_no_grace\t\tcpu_to_be32(NFSERR_NO_GRACE)\n#define\tnfserr_reclaim_bad\tcpu_to_be32(NFSERR_RECLAIM_BAD)\n#define\tnfserr_badname\t\tcpu_to_be32(NFSERR_BADNAME)\n#define\tnfserr_cb_path_down\tcpu_to_be32(NFSERR_CB_PATH_DOWN)\n#define\tnfserr_locked\t\tcpu_to_be32(NFSERR_LOCKED)\n#define\tnfserr_wrongsec\t\tcpu_to_be32(NFSERR_WRONGSEC)\n#define nfserr_badiomode\t\tcpu_to_be32(NFS4ERR_BADIOMODE)\n#define nfserr_badlayout\t\tcpu_to_be32(NFS4ERR_BADLAYOUT)\n#define nfserr_bad_session_digest\tcpu_to_be32(NFS4ERR_BAD_SESSION_DIGEST)\n#define nfserr_badsession\t\tcpu_to_be32(NFS4ERR_BADSESSION)\n#define nfserr_badslot\t\t\tcpu_to_be32(NFS4ERR_BADSLOT)\n#define nfserr_complete_already\t\tcpu_to_be32(NFS4ERR_COMPLETE_ALREADY)\n#define nfserr_conn_not_bound_to_session cpu_to_be32(NFS4ERR_CONN_NOT_BOUND_TO_SESSION)\n#define nfserr_deleg_already_wanted\tcpu_to_be32(NFS4ERR_DELEG_ALREADY_WANTED)\n#define nfserr_back_chan_busy\t\tcpu_to_be32(NFS4ERR_BACK_CHAN_BUSY)\n#define nfserr_layouttrylater\t\tcpu_to_be32(NFS4ERR_LAYOUTTRYLATER)\n#define nfserr_layoutunavailable\tcpu_to_be32(NFS4ERR_LAYOUTUNAVAILABLE)\n#define nfserr_nomatching_layout\tcpu_to_be32(NFS4ERR_NOMATCHING_LAYOUT)\n#define nfserr_recallconflict\t\tcpu_to_be32(NFS4ERR_RECALLCONFLICT)\n#define nfserr_unknown_layouttype\tcpu_to_be32(NFS4ERR_UNKNOWN_LAYOUTTYPE)\n#define nfserr_seq_misordered\t\tcpu_to_be32(NFS4ERR_SEQ_MISORDERED)\n#define nfserr_sequence_pos\t\tcpu_to_be32(NFS4ERR_SEQUENCE_POS)\n#define nfserr_req_too_big\t\tcpu_to_be32(NFS4ERR_REQ_TOO_BIG)\n#define nfserr_rep_too_big\t\tcpu_to_be32(NFS4ERR_REP_TOO_BIG)\n#define nfserr_rep_too_big_to_cache\tcpu_to_be32(NFS4ERR_REP_TOO_BIG_TO_CACHE)\n#define nfserr_retry_uncached_rep\tcpu_to_be32(NFS4ERR_RETRY_UNCACHED_REP)\n#define nfserr_unsafe_compound\t\tcpu_to_be32(NFS4ERR_UNSAFE_COMPOUND)\n#define nfserr_too_many_ops\t\tcpu_to_be32(NFS4ERR_TOO_MANY_OPS)\n#define nfserr_op_not_in_session\tcpu_to_be32(NFS4ERR_OP_NOT_IN_SESSION)\n#define nfserr_hash_alg_unsupp\t\tcpu_to_be32(NFS4ERR_HASH_ALG_UNSUPP)\n#define nfserr_clientid_busy\t\tcpu_to_be32(NFS4ERR_CLIENTID_BUSY)\n#define nfserr_pnfs_io_hole\t\tcpu_to_be32(NFS4ERR_PNFS_IO_HOLE)\n#define nfserr_seq_false_retry\t\tcpu_to_be32(NFS4ERR_SEQ_FALSE_RETRY)\n#define nfserr_bad_high_slot\t\tcpu_to_be32(NFS4ERR_BAD_HIGH_SLOT)\n#define nfserr_deadsession\t\tcpu_to_be32(NFS4ERR_DEADSESSION)\n#define nfserr_encr_alg_unsupp\t\tcpu_to_be32(NFS4ERR_ENCR_ALG_UNSUPP)\n#define nfserr_pnfs_no_layout\t\tcpu_to_be32(NFS4ERR_PNFS_NO_LAYOUT)\n#define nfserr_not_only_op\t\tcpu_to_be32(NFS4ERR_NOT_ONLY_OP)\n#define nfserr_wrong_cred\t\tcpu_to_be32(NFS4ERR_WRONG_CRED)\n#define nfserr_wrong_type\t\tcpu_to_be32(NFS4ERR_WRONG_TYPE)\n#define nfserr_dirdeleg_unavail\t\tcpu_to_be32(NFS4ERR_DIRDELEG_UNAVAIL)\n#define nfserr_reject_deleg\t\tcpu_to_be32(NFS4ERR_REJECT_DELEG)\n#define nfserr_returnconflict\t\tcpu_to_be32(NFS4ERR_RETURNCONFLICT)\n#define nfserr_deleg_revoked\t\tcpu_to_be32(NFS4ERR_DELEG_REVOKED)\n#define nfserr_partner_notsupp\t\tcpu_to_be32(NFS4ERR_PARTNER_NOTSUPP)\n#define nfserr_partner_no_auth\t\tcpu_to_be32(NFS4ERR_PARTNER_NO_AUTH)\n#define nfserr_union_notsupp\t\tcpu_to_be32(NFS4ERR_UNION_NOTSUPP)\n#define nfserr_offload_denied\t\tcpu_to_be32(NFS4ERR_OFFLOAD_DENIED)\n#define nfserr_wrong_lfs\t\tcpu_to_be32(NFS4ERR_WRONG_LFS)\n#define nfserr_badlabel\t\t\tcpu_to_be32(NFS4ERR_BADLABEL)\n#define nfserr_file_open\t\tcpu_to_be32(NFS4ERR_FILE_OPEN)\n#define nfserr_xattr2big\t\tcpu_to_be32(NFS4ERR_XATTR2BIG)\n#define nfserr_noxattr\t\t\tcpu_to_be32(NFS4ERR_NOXATTR)\n\n \n \n#define\tnfserr_dropit\t\tcpu_to_be32(30000)\n \n#define\tnfserr_eof\t\tcpu_to_be32(30001)\n \n#define\tnfserr_replay_me\tcpu_to_be32(11001)\n \n#define\tnfserr_replay_cache\tcpu_to_be32(11002)\n\n \n#define isdotent(n, l)\t(l < 3 && n[0] == '.' && (l == 1 || n[1] == '.'))\n\n#ifdef CONFIG_NFSD_V4\n\n \n#define\tCOMPOUND_SLACK_SPACE\t\t140     \n#define COMPOUND_ERR_SLACK_SPACE\t16      \n\n#define NFSD_LAUNDROMAT_MINTIMEOUT      1    \n#define\tNFSD_COURTESY_CLIENT_TIMEOUT\t(24 * 60 * 60)\t \n#define\tNFSD_CLIENT_MAX_TRIM_PER_RUN\t128\n#define\tNFS4_CLIENTS_PER_GB\t\t1024\n#define NFSD_DELEGRETURN_TIMEOUT\t(HZ / 34)\t \n\n \n#define NFSD4_SUPPORTED_ATTRS_WORD0                                                         \\\n(FATTR4_WORD0_SUPPORTED_ATTRS   | FATTR4_WORD0_TYPE         | FATTR4_WORD0_FH_EXPIRE_TYPE   \\\n | FATTR4_WORD0_CHANGE          | FATTR4_WORD0_SIZE         | FATTR4_WORD0_LINK_SUPPORT     \\\n | FATTR4_WORD0_SYMLINK_SUPPORT | FATTR4_WORD0_NAMED_ATTR   | FATTR4_WORD0_FSID             \\\n | FATTR4_WORD0_UNIQUE_HANDLES  | FATTR4_WORD0_LEASE_TIME   | FATTR4_WORD0_RDATTR_ERROR     \\\n | FATTR4_WORD0_ACLSUPPORT      | FATTR4_WORD0_CANSETTIME   | FATTR4_WORD0_CASE_INSENSITIVE \\\n | FATTR4_WORD0_CASE_PRESERVING | FATTR4_WORD0_CHOWN_RESTRICTED                             \\\n | FATTR4_WORD0_FILEHANDLE      | FATTR4_WORD0_FILEID       | FATTR4_WORD0_FILES_AVAIL      \\\n | FATTR4_WORD0_FILES_FREE      | FATTR4_WORD0_FILES_TOTAL  | FATTR4_WORD0_FS_LOCATIONS | FATTR4_WORD0_HOMOGENEOUS      \\\n | FATTR4_WORD0_MAXFILESIZE     | FATTR4_WORD0_MAXLINK      | FATTR4_WORD0_MAXNAME          \\\n | FATTR4_WORD0_MAXREAD         | FATTR4_WORD0_MAXWRITE     | FATTR4_WORD0_ACL)\n\n#define NFSD4_SUPPORTED_ATTRS_WORD1                                                         \\\n(FATTR4_WORD1_MODE              | FATTR4_WORD1_NO_TRUNC     | FATTR4_WORD1_NUMLINKS         \\\n | FATTR4_WORD1_OWNER\t        | FATTR4_WORD1_OWNER_GROUP  | FATTR4_WORD1_RAWDEV           \\\n | FATTR4_WORD1_SPACE_AVAIL     | FATTR4_WORD1_SPACE_FREE   | FATTR4_WORD1_SPACE_TOTAL      \\\n | FATTR4_WORD1_SPACE_USED      | FATTR4_WORD1_TIME_ACCESS  | FATTR4_WORD1_TIME_ACCESS_SET  \\\n | FATTR4_WORD1_TIME_DELTA      | FATTR4_WORD1_TIME_METADATA   | FATTR4_WORD1_TIME_CREATE      \\\n | FATTR4_WORD1_TIME_MODIFY     | FATTR4_WORD1_TIME_MODIFY_SET | FATTR4_WORD1_MOUNTED_ON_FILEID)\n\n#define NFSD4_SUPPORTED_ATTRS_WORD2 0\n\n \n#ifdef CONFIG_NFSD_PNFS\n#define PNFSD_SUPPORTED_ATTRS_WORD1\tFATTR4_WORD1_FS_LAYOUT_TYPES\n#define PNFSD_SUPPORTED_ATTRS_WORD2 \\\n(FATTR4_WORD2_LAYOUT_BLKSIZE\t| FATTR4_WORD2_LAYOUT_TYPES)\n#else\n#define PNFSD_SUPPORTED_ATTRS_WORD1\t0\n#define PNFSD_SUPPORTED_ATTRS_WORD2\t0\n#endif  \n\n#define NFSD4_1_SUPPORTED_ATTRS_WORD0 \\\n\tNFSD4_SUPPORTED_ATTRS_WORD0\n\n#define NFSD4_1_SUPPORTED_ATTRS_WORD1 \\\n\t(NFSD4_SUPPORTED_ATTRS_WORD1\t| PNFSD_SUPPORTED_ATTRS_WORD1)\n\n#define NFSD4_1_SUPPORTED_ATTRS_WORD2 \\\n\t(NFSD4_SUPPORTED_ATTRS_WORD2\t| PNFSD_SUPPORTED_ATTRS_WORD2 | \\\n\t FATTR4_WORD2_SUPPATTR_EXCLCREAT)\n\n \n#ifdef CONFIG_NFSD_V4_SECURITY_LABEL\n#define NFSD4_2_SECURITY_ATTRS\t\tFATTR4_WORD2_SECURITY_LABEL\n#else\n#define NFSD4_2_SECURITY_ATTRS\t\t0\n#endif\n\n#define NFSD4_2_SUPPORTED_ATTRS_WORD2 \\\n\t(NFSD4_1_SUPPORTED_ATTRS_WORD2 | \\\n\tFATTR4_WORD2_MODE_UMASK | \\\n\tNFSD4_2_SECURITY_ATTRS | \\\n\tFATTR4_WORD2_XATTR_SUPPORT)\n\nextern const u32 nfsd_suppattrs[3][3];\n\nstatic inline __be32 nfsd4_set_netaddr(struct sockaddr *addr,\n\t\t\t\t    struct nfs42_netaddr *netaddr)\n{\n\tstruct sockaddr_in *sin = (struct sockaddr_in *)addr;\n\tstruct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)addr;\n\tunsigned int port;\n\tsize_t ret_addr, ret_port;\n\n\tswitch (addr->sa_family) {\n\tcase AF_INET:\n\t\tport = ntohs(sin->sin_port);\n\t\tsprintf(netaddr->netid, \"tcp\");\n\t\tnetaddr->netid_len = 3;\n\t\tbreak;\n\tcase AF_INET6:\n\t\tport = ntohs(sin6->sin6_port);\n\t\tsprintf(netaddr->netid, \"tcp6\");\n\t\tnetaddr->netid_len = 4;\n\t\tbreak;\n\tdefault:\n\t\treturn nfserr_inval;\n\t}\n\tret_addr = rpc_ntop(addr, netaddr->addr, sizeof(netaddr->addr));\n\tret_port = snprintf(netaddr->addr + ret_addr,\n\t\t\t    RPCBIND_MAXUADDRLEN + 1 - ret_addr,\n\t\t\t    \".%u.%u\", port >> 8, port & 0xff);\n\tWARN_ON(ret_port >= RPCBIND_MAXUADDRLEN + 1 - ret_addr);\n\tnetaddr->addr_len = ret_addr + ret_port;\n\treturn 0;\n}\n\nstatic inline bool bmval_is_subset(const u32 *bm1, const u32 *bm2)\n{\n\treturn !((bm1[0] & ~bm2[0]) ||\n\t         (bm1[1] & ~bm2[1]) ||\n\t\t (bm1[2] & ~bm2[2]));\n}\n\nstatic inline bool nfsd_attrs_supported(u32 minorversion, const u32 *bmval)\n{\n\treturn bmval_is_subset(bmval, nfsd_suppattrs[minorversion]);\n}\n\n \n#define NFSD_WRITEONLY_ATTRS_WORD1 \\\n\t(FATTR4_WORD1_TIME_ACCESS_SET   | FATTR4_WORD1_TIME_MODIFY_SET)\n\n \n#define NFSD_WRITEABLE_ATTRS_WORD0 \\\n\t(FATTR4_WORD0_SIZE | FATTR4_WORD0_ACL)\n#define NFSD_WRITEABLE_ATTRS_WORD1 \\\n\t(FATTR4_WORD1_MODE | FATTR4_WORD1_OWNER | FATTR4_WORD1_OWNER_GROUP \\\n\t| FATTR4_WORD1_TIME_ACCESS_SET | FATTR4_WORD1_TIME_CREATE \\\n\t| FATTR4_WORD1_TIME_MODIFY_SET)\n#ifdef CONFIG_NFSD_V4_SECURITY_LABEL\n#define MAYBE_FATTR4_WORD2_SECURITY_LABEL \\\n\tFATTR4_WORD2_SECURITY_LABEL\n#else\n#define MAYBE_FATTR4_WORD2_SECURITY_LABEL 0\n#endif\n#define NFSD_WRITEABLE_ATTRS_WORD2 \\\n\t(FATTR4_WORD2_MODE_UMASK \\\n\t| MAYBE_FATTR4_WORD2_SECURITY_LABEL)\n\n#define NFSD_SUPPATTR_EXCLCREAT_WORD0 \\\n\tNFSD_WRITEABLE_ATTRS_WORD0\n \n#define NFSD_SUPPATTR_EXCLCREAT_WORD1 \\\n\t(NFSD_WRITEABLE_ATTRS_WORD1 & \\\n\t ~(FATTR4_WORD1_TIME_ACCESS_SET | FATTR4_WORD1_TIME_MODIFY_SET))\n#define NFSD_SUPPATTR_EXCLCREAT_WORD2 \\\n\tNFSD_WRITEABLE_ATTRS_WORD2\n\nextern int nfsd4_is_junction(struct dentry *dentry);\nextern int register_cld_notifier(void);\nextern void unregister_cld_notifier(void);\n#ifdef CONFIG_NFSD_V4_2_INTER_SSC\nextern void nfsd4_ssc_init_umount_work(struct nfsd_net *nn);\n#endif\n\nextern void nfsd4_init_leases_net(struct nfsd_net *nn);\n\n#else  \nstatic inline int nfsd4_is_junction(struct dentry *dentry)\n{\n\treturn 0;\n}\n\nstatic inline void nfsd4_init_leases_net(struct nfsd_net *nn) { };\n\n#define register_cld_notifier() 0\n#define unregister_cld_notifier() do { } while(0)\n\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}