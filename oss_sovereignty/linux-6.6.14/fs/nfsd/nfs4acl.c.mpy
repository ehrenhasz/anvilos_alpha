{
  "module_name": "nfs4acl.c",
  "hash_id": "190eee3282525103804e9e8b78da7d0dd2b0fdafdf8b52ac01ec233b62e9034f",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfsd/nfs4acl.c",
  "human_readable_source": " \n\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/posix_acl.h>\n\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include \"acl.h\"\n#include \"vfs.h\"\n\n#define NFS4_ACL_TYPE_DEFAULT\t0x01\n#define NFS4_ACL_DIR\t\t0x02\n#define NFS4_ACL_OWNER\t\t0x04\n\n \n#define NFS4_READ_MODE (NFS4_ACE_READ_DATA)\n#define NFS4_WRITE_MODE (NFS4_ACE_WRITE_DATA | NFS4_ACE_APPEND_DATA)\n#define NFS4_EXECUTE_MODE NFS4_ACE_EXECUTE\n#define NFS4_ANYONE_MODE (NFS4_ACE_READ_ATTRIBUTES | NFS4_ACE_READ_ACL | NFS4_ACE_SYNCHRONIZE)\n#define NFS4_OWNER_MODE (NFS4_ACE_WRITE_ATTRIBUTES | NFS4_ACE_WRITE_ACL)\n\n \n#define NFS4_INHERITANCE_FLAGS (NFS4_ACE_FILE_INHERIT_ACE \\\n\t\t| NFS4_ACE_DIRECTORY_INHERIT_ACE)\n\n#define NFS4_SUPPORTED_FLAGS (NFS4_INHERITANCE_FLAGS \\\n\t\t| NFS4_ACE_INHERIT_ONLY_ACE \\\n\t\t| NFS4_ACE_IDENTIFIER_GROUP)\n\nstatic u32\nmask_from_posix(unsigned short perm, unsigned int flags)\n{\n\tint mask = NFS4_ANYONE_MODE;\n\n\tif (flags & NFS4_ACL_OWNER)\n\t\tmask |= NFS4_OWNER_MODE;\n\tif (perm & ACL_READ)\n\t\tmask |= NFS4_READ_MODE;\n\tif (perm & ACL_WRITE)\n\t\tmask |= NFS4_WRITE_MODE;\n\tif ((perm & ACL_WRITE) && (flags & NFS4_ACL_DIR))\n\t\tmask |= NFS4_ACE_DELETE_CHILD;\n\tif (perm & ACL_EXECUTE)\n\t\tmask |= NFS4_EXECUTE_MODE;\n\treturn mask;\n}\n\nstatic u32\ndeny_mask_from_posix(unsigned short perm, u32 flags)\n{\n\tu32 mask = 0;\n\n\tif (perm & ACL_READ)\n\t\tmask |= NFS4_READ_MODE;\n\tif (perm & ACL_WRITE)\n\t\tmask |= NFS4_WRITE_MODE;\n\tif ((perm & ACL_WRITE) && (flags & NFS4_ACL_DIR))\n\t\tmask |= NFS4_ACE_DELETE_CHILD;\n\tif (perm & ACL_EXECUTE)\n\t\tmask |= NFS4_EXECUTE_MODE;\n\treturn mask;\n}\n\n \n\n \n\nstatic void\nlow_mode_from_nfs4(u32 perm, unsigned short *mode, unsigned int flags)\n{\n\tu32 write_mode = NFS4_WRITE_MODE;\n\n\tif (flags & NFS4_ACL_DIR)\n\t\twrite_mode |= NFS4_ACE_DELETE_CHILD;\n\t*mode = 0;\n\tif ((perm & NFS4_READ_MODE) == NFS4_READ_MODE)\n\t\t*mode |= ACL_READ;\n\tif ((perm & write_mode) == write_mode)\n\t\t*mode |= ACL_WRITE;\n\tif ((perm & NFS4_EXECUTE_MODE) == NFS4_EXECUTE_MODE)\n\t\t*mode |= ACL_EXECUTE;\n}\n\nstatic short ace2type(struct nfs4_ace *);\nstatic void _posix_to_nfsv4_one(struct posix_acl *, struct nfs4_acl *,\n\t\t\t\tunsigned int);\n\nint\nnfsd4_get_nfs4_acl(struct svc_rqst *rqstp, struct dentry *dentry,\n\t\tstruct nfs4_acl **acl)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tint error = 0;\n\tstruct posix_acl *pacl = NULL, *dpacl = NULL;\n\tunsigned int flags = 0;\n\tint size = 0;\n\n\tpacl = get_inode_acl(inode, ACL_TYPE_ACCESS);\n\tif (!pacl)\n\t\tpacl = posix_acl_from_mode(inode->i_mode, GFP_KERNEL);\n\n\tif (IS_ERR(pacl))\n\t\treturn PTR_ERR(pacl);\n\n\t \n\tsize += 2 * pacl->a_count;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tflags = NFS4_ACL_DIR;\n\t\tdpacl = get_inode_acl(inode, ACL_TYPE_DEFAULT);\n\t\tif (IS_ERR(dpacl)) {\n\t\t\terror = PTR_ERR(dpacl);\n\t\t\tgoto rel_pacl;\n\t\t}\n\n\t\tif (dpacl)\n\t\t\tsize += 2 * dpacl->a_count;\n\t}\n\n\t*acl = kmalloc(nfs4_acl_bytes(size), GFP_KERNEL);\n\tif (*acl == NULL) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\t(*acl)->naces = 0;\n\n\t_posix_to_nfsv4_one(pacl, *acl, flags & ~NFS4_ACL_TYPE_DEFAULT);\n\n\tif (dpacl)\n\t\t_posix_to_nfsv4_one(dpacl, *acl, flags | NFS4_ACL_TYPE_DEFAULT);\n\nout:\n\tposix_acl_release(dpacl);\nrel_pacl:\n\tposix_acl_release(pacl);\n\treturn error;\n}\n\nstruct posix_acl_summary {\n\tunsigned short owner;\n\tunsigned short users;\n\tunsigned short group;\n\tunsigned short groups;\n\tunsigned short other;\n\tunsigned short mask;\n};\n\nstatic void\nsummarize_posix_acl(struct posix_acl *acl, struct posix_acl_summary *pas)\n{\n\tstruct posix_acl_entry *pa, *pe;\n\n\t \n\tmemset(pas, 0, sizeof(*pas));\n\tpas->mask = 07;\n\n\tpe = acl->a_entries + acl->a_count;\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tswitch (pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tpas->owner = pa->e_perm;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tpas->group = pa->e_perm;\n\t\t\t\tbreak;\n\t\t\tcase ACL_USER:\n\t\t\t\tpas->users |= pa->e_perm;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP:\n\t\t\t\tpas->groups |= pa->e_perm;\n\t\t\t\tbreak;\n\t\t\tcase ACL_OTHER:\n\t\t\t\tpas->other = pa->e_perm;\n\t\t\t\tbreak;\n\t\t\tcase ACL_MASK:\n\t\t\t\tpas->mask = pa->e_perm;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t \n\tpas->users &= pas->mask;\n\tpas->group &= pas->mask;\n\tpas->groups &= pas->mask;\n}\n\n \nstatic void\n_posix_to_nfsv4_one(struct posix_acl *pacl, struct nfs4_acl *acl,\n\t\t\t\t\t\tunsigned int flags)\n{\n\tstruct posix_acl_entry *pa, *group_owner_entry;\n\tstruct nfs4_ace *ace;\n\tstruct posix_acl_summary pas;\n\tunsigned short deny;\n\tint eflag = ((flags & NFS4_ACL_TYPE_DEFAULT) ?\n\t\tNFS4_INHERITANCE_FLAGS | NFS4_ACE_INHERIT_ONLY_ACE : 0);\n\n\tBUG_ON(pacl->a_count < 3);\n\tsummarize_posix_acl(pacl, &pas);\n\n\tpa = pacl->a_entries;\n\tace = acl->aces + acl->naces;\n\n\t \n\tdeny = ~pas.owner;\n\t \n\tdeny &= pas.users | pas.group | pas.groups | pas.other;\n\tif (deny) {\n\t\tace->type = NFS4_ACE_ACCESS_DENIED_ACE_TYPE;\n\t\tace->flag = eflag;\n\t\tace->access_mask = deny_mask_from_posix(deny, flags);\n\t\tace->whotype = NFS4_ACL_WHO_OWNER;\n\t\tace++;\n\t\tacl->naces++;\n\t}\n\n\tace->type = NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE;\n\tace->flag = eflag;\n\tace->access_mask = mask_from_posix(pa->e_perm, flags | NFS4_ACL_OWNER);\n\tace->whotype = NFS4_ACL_WHO_OWNER;\n\tace++;\n\tacl->naces++;\n\tpa++;\n\n\twhile (pa->e_tag == ACL_USER) {\n\t\tdeny = ~(pa->e_perm & pas.mask);\n\t\tdeny &= pas.groups | pas.group | pas.other;\n\t\tif (deny) {\n\t\t\tace->type = NFS4_ACE_ACCESS_DENIED_ACE_TYPE;\n\t\t\tace->flag = eflag;\n\t\t\tace->access_mask = deny_mask_from_posix(deny, flags);\n\t\t\tace->whotype = NFS4_ACL_WHO_NAMED;\n\t\t\tace->who_uid = pa->e_uid;\n\t\t\tace++;\n\t\t\tacl->naces++;\n\t\t}\n\t\tace->type = NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE;\n\t\tace->flag = eflag;\n\t\tace->access_mask = mask_from_posix(pa->e_perm & pas.mask,\n\t\t\t\t\t\t   flags);\n\t\tace->whotype = NFS4_ACL_WHO_NAMED;\n\t\tace->who_uid = pa->e_uid;\n\t\tace++;\n\t\tacl->naces++;\n\t\tpa++;\n\t}\n\n\t \n\n\t \n\n\tgroup_owner_entry = pa;\n\n\tace->type = NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE;\n\tace->flag = eflag;\n\tace->access_mask = mask_from_posix(pas.group, flags);\n\tace->whotype = NFS4_ACL_WHO_GROUP;\n\tace++;\n\tacl->naces++;\n\tpa++;\n\n\twhile (pa->e_tag == ACL_GROUP) {\n\t\tace->type = NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE;\n\t\tace->flag = eflag | NFS4_ACE_IDENTIFIER_GROUP;\n\t\tace->access_mask = mask_from_posix(pa->e_perm & pas.mask,\n\t\t\t\t\t\t   flags);\n\t\tace->whotype = NFS4_ACL_WHO_NAMED;\n\t\tace->who_gid = pa->e_gid;\n\t\tace++;\n\t\tacl->naces++;\n\t\tpa++;\n\t}\n\n\t \n\n\tpa = group_owner_entry;\n\n\tdeny = ~pas.group & pas.other;\n\tif (deny) {\n\t\tace->type = NFS4_ACE_ACCESS_DENIED_ACE_TYPE;\n\t\tace->flag = eflag;\n\t\tace->access_mask = deny_mask_from_posix(deny, flags);\n\t\tace->whotype = NFS4_ACL_WHO_GROUP;\n\t\tace++;\n\t\tacl->naces++;\n\t}\n\tpa++;\n\n\twhile (pa->e_tag == ACL_GROUP) {\n\t\tdeny = ~(pa->e_perm & pas.mask);\n\t\tdeny &= pas.other;\n\t\tif (deny) {\n\t\t\tace->type = NFS4_ACE_ACCESS_DENIED_ACE_TYPE;\n\t\t\tace->flag = eflag | NFS4_ACE_IDENTIFIER_GROUP;\n\t\t\tace->access_mask = deny_mask_from_posix(deny, flags);\n\t\t\tace->whotype = NFS4_ACL_WHO_NAMED;\n\t\t\tace->who_gid = pa->e_gid;\n\t\t\tace++;\n\t\t\tacl->naces++;\n\t\t}\n\t\tpa++;\n\t}\n\n\tif (pa->e_tag == ACL_MASK)\n\t\tpa++;\n\tace->type = NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE;\n\tace->flag = eflag;\n\tace->access_mask = mask_from_posix(pa->e_perm, flags);\n\tace->whotype = NFS4_ACL_WHO_EVERYONE;\n\tacl->naces++;\n}\n\nstatic bool\npace_gt(struct posix_acl_entry *pace1, struct posix_acl_entry *pace2)\n{\n\tif (pace1->e_tag != pace2->e_tag)\n\t\treturn pace1->e_tag > pace2->e_tag;\n\tif (pace1->e_tag == ACL_USER)\n\t\treturn uid_gt(pace1->e_uid, pace2->e_uid);\n\tif (pace1->e_tag == ACL_GROUP)\n\t\treturn gid_gt(pace1->e_gid, pace2->e_gid);\n\treturn false;\n}\n\nstatic void\nsort_pacl_range(struct posix_acl *pacl, int start, int end) {\n\tint sorted = 0, i;\n\n\t \n\twhile (!sorted) {\n\t\tsorted = 1;\n\t\tfor (i = start; i < end; i++) {\n\t\t\tif (pace_gt(&pacl->a_entries[i],\n\t\t\t\t    &pacl->a_entries[i+1])) {\n\t\t\t\tsorted = 0;\n\t\t\t\tswap(pacl->a_entries[i],\n\t\t\t\t     pacl->a_entries[i + 1]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void\nsort_pacl(struct posix_acl *pacl)\n{\n\t \n\tint i, j;\n\n\t \n\tif (!pacl || pacl->a_count <= 4)\n\t\treturn;\n\n\ti = 1;\n\twhile (pacl->a_entries[i].e_tag == ACL_USER)\n\t\ti++;\n\tsort_pacl_range(pacl, 1, i-1);\n\n\tBUG_ON(pacl->a_entries[i].e_tag != ACL_GROUP_OBJ);\n\tj = ++i;\n\twhile (pacl->a_entries[j].e_tag == ACL_GROUP)\n\t\tj++;\n\tsort_pacl_range(pacl, i, j-1);\n\treturn;\n}\n\n \nstruct posix_ace_state {\n\tu32 allow;\n\tu32 deny;\n};\n\nstruct posix_user_ace_state {\n\tunion {\n\t\tkuid_t uid;\n\t\tkgid_t gid;\n\t};\n\tstruct posix_ace_state perms;\n};\n\nstruct posix_ace_state_array {\n\tint n;\n\tstruct posix_user_ace_state aces[];\n};\n\n \n\nstruct posix_acl_state {\n\tunsigned char valid;\n\tstruct posix_ace_state owner;\n\tstruct posix_ace_state group;\n\tstruct posix_ace_state other;\n\tstruct posix_ace_state everyone;\n\tstruct posix_ace_state mask;  \n\tstruct posix_ace_state_array *users;\n\tstruct posix_ace_state_array *groups;\n};\n\nstatic int\ninit_state(struct posix_acl_state *state, int cnt)\n{\n\tint alloc;\n\n\tmemset(state, 0, sizeof(struct posix_acl_state));\n\t \n\talloc = sizeof(struct posix_ace_state_array)\n\t\t+ cnt*sizeof(struct posix_user_ace_state);\n\tstate->users = kzalloc(alloc, GFP_KERNEL);\n\tif (!state->users)\n\t\treturn -ENOMEM;\n\tstate->groups = kzalloc(alloc, GFP_KERNEL);\n\tif (!state->groups) {\n\t\tkfree(state->users);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nstatic void\nfree_state(struct posix_acl_state *state) {\n\tkfree(state->users);\n\tkfree(state->groups);\n}\n\nstatic inline void add_to_mask(struct posix_acl_state *state, struct posix_ace_state *astate)\n{\n\tstate->mask.allow |= astate->allow;\n}\n\nstatic struct posix_acl *\nposix_state_to_acl(struct posix_acl_state *state, unsigned int flags)\n{\n\tstruct posix_acl_entry *pace;\n\tstruct posix_acl *pacl;\n\tint nace;\n\tint i;\n\n\t \n\tif (!state->valid && (flags & NFS4_ACL_TYPE_DEFAULT))\n\t\treturn NULL;\n\n\t \n\tif (!state->users->n && !state->groups->n)\n\t\tnace = 3;\n\telse  \n\t\tnace = 4 + state->users->n + state->groups->n;\n\tpacl = posix_acl_alloc(nace, GFP_KERNEL);\n\tif (!pacl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpace = pacl->a_entries;\n\tpace->e_tag = ACL_USER_OBJ;\n\tlow_mode_from_nfs4(state->owner.allow, &pace->e_perm, flags);\n\n\tfor (i=0; i < state->users->n; i++) {\n\t\tpace++;\n\t\tpace->e_tag = ACL_USER;\n\t\tlow_mode_from_nfs4(state->users->aces[i].perms.allow,\n\t\t\t\t\t&pace->e_perm, flags);\n\t\tpace->e_uid = state->users->aces[i].uid;\n\t\tadd_to_mask(state, &state->users->aces[i].perms);\n\t}\n\n\tpace++;\n\tpace->e_tag = ACL_GROUP_OBJ;\n\tlow_mode_from_nfs4(state->group.allow, &pace->e_perm, flags);\n\tadd_to_mask(state, &state->group);\n\n\tfor (i=0; i < state->groups->n; i++) {\n\t\tpace++;\n\t\tpace->e_tag = ACL_GROUP;\n\t\tlow_mode_from_nfs4(state->groups->aces[i].perms.allow,\n\t\t\t\t\t&pace->e_perm, flags);\n\t\tpace->e_gid = state->groups->aces[i].gid;\n\t\tadd_to_mask(state, &state->groups->aces[i].perms);\n\t}\n\n\tif (state->users->n || state->groups->n) {\n\t\tpace++;\n\t\tpace->e_tag = ACL_MASK;\n\t\tlow_mode_from_nfs4(state->mask.allow, &pace->e_perm, flags);\n\t}\n\n\tpace++;\n\tpace->e_tag = ACL_OTHER;\n\tlow_mode_from_nfs4(state->other.allow, &pace->e_perm, flags);\n\n\treturn pacl;\n}\n\nstatic inline void allow_bits(struct posix_ace_state *astate, u32 mask)\n{\n\t \n\tastate->allow |= mask & ~astate->deny;\n}\n\nstatic inline void deny_bits(struct posix_ace_state *astate, u32 mask)\n{\n\t \n\tastate->deny |= mask & ~astate->allow;\n}\n\nstatic int find_uid(struct posix_acl_state *state, kuid_t uid)\n{\n\tstruct posix_ace_state_array *a = state->users;\n\tint i;\n\n\tfor (i = 0; i < a->n; i++)\n\t\tif (uid_eq(a->aces[i].uid, uid))\n\t\t\treturn i;\n\t \n\ta->n++;\n\ta->aces[i].uid = uid;\n\ta->aces[i].perms.allow = state->everyone.allow;\n\ta->aces[i].perms.deny  = state->everyone.deny;\n\n\treturn i;\n}\n\nstatic int find_gid(struct posix_acl_state *state, kgid_t gid)\n{\n\tstruct posix_ace_state_array *a = state->groups;\n\tint i;\n\n\tfor (i = 0; i < a->n; i++)\n\t\tif (gid_eq(a->aces[i].gid, gid))\n\t\t\treturn i;\n\t \n\ta->n++;\n\ta->aces[i].gid = gid;\n\ta->aces[i].perms.allow = state->everyone.allow;\n\ta->aces[i].perms.deny  = state->everyone.deny;\n\n\treturn i;\n}\n\nstatic void deny_bits_array(struct posix_ace_state_array *a, u32 mask)\n{\n\tint i;\n\n\tfor (i=0; i < a->n; i++)\n\t\tdeny_bits(&a->aces[i].perms, mask);\n}\n\nstatic void allow_bits_array(struct posix_ace_state_array *a, u32 mask)\n{\n\tint i;\n\n\tfor (i=0; i < a->n; i++)\n\t\tallow_bits(&a->aces[i].perms, mask);\n}\n\nstatic void process_one_v4_ace(struct posix_acl_state *state,\n\t\t\t\tstruct nfs4_ace *ace)\n{\n\tu32 mask = ace->access_mask;\n\tshort type = ace2type(ace);\n\tint i;\n\n\tstate->valid |= type;\n\n\tswitch (type) {\n\tcase ACL_USER_OBJ:\n\t\tif (ace->type == NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE) {\n\t\t\tallow_bits(&state->owner, mask);\n\t\t} else {\n\t\t\tdeny_bits(&state->owner, mask);\n\t\t}\n\t\tbreak;\n\tcase ACL_USER:\n\t\ti = find_uid(state, ace->who_uid);\n\t\tif (ace->type == NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE) {\n\t\t\tallow_bits(&state->users->aces[i].perms, mask);\n\t\t} else {\n\t\t\tdeny_bits(&state->users->aces[i].perms, mask);\n\t\t\tmask = state->users->aces[i].perms.deny;\n\t\t\tdeny_bits(&state->owner, mask);\n\t\t}\n\t\tbreak;\n\tcase ACL_GROUP_OBJ:\n\t\tif (ace->type == NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE) {\n\t\t\tallow_bits(&state->group, mask);\n\t\t} else {\n\t\t\tdeny_bits(&state->group, mask);\n\t\t\tmask = state->group.deny;\n\t\t\tdeny_bits(&state->owner, mask);\n\t\t\tdeny_bits(&state->everyone, mask);\n\t\t\tdeny_bits_array(state->users, mask);\n\t\t\tdeny_bits_array(state->groups, mask);\n\t\t}\n\t\tbreak;\n\tcase ACL_GROUP:\n\t\ti = find_gid(state, ace->who_gid);\n\t\tif (ace->type == NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE) {\n\t\t\tallow_bits(&state->groups->aces[i].perms, mask);\n\t\t} else {\n\t\t\tdeny_bits(&state->groups->aces[i].perms, mask);\n\t\t\tmask = state->groups->aces[i].perms.deny;\n\t\t\tdeny_bits(&state->owner, mask);\n\t\t\tdeny_bits(&state->group, mask);\n\t\t\tdeny_bits(&state->everyone, mask);\n\t\t\tdeny_bits_array(state->users, mask);\n\t\t\tdeny_bits_array(state->groups, mask);\n\t\t}\n\t\tbreak;\n\tcase ACL_OTHER:\n\t\tif (ace->type == NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE) {\n\t\t\tallow_bits(&state->owner, mask);\n\t\t\tallow_bits(&state->group, mask);\n\t\t\tallow_bits(&state->other, mask);\n\t\t\tallow_bits(&state->everyone, mask);\n\t\t\tallow_bits_array(state->users, mask);\n\t\t\tallow_bits_array(state->groups, mask);\n\t\t} else {\n\t\t\tdeny_bits(&state->owner, mask);\n\t\t\tdeny_bits(&state->group, mask);\n\t\t\tdeny_bits(&state->other, mask);\n\t\t\tdeny_bits(&state->everyone, mask);\n\t\t\tdeny_bits_array(state->users, mask);\n\t\t\tdeny_bits_array(state->groups, mask);\n\t\t}\n\t}\n}\n\nstatic int nfs4_acl_nfsv4_to_posix(struct nfs4_acl *acl,\n\t\tstruct posix_acl **pacl, struct posix_acl **dpacl,\n\t\tunsigned int flags)\n{\n\tstruct posix_acl_state effective_acl_state, default_acl_state;\n\tstruct nfs4_ace *ace;\n\tint ret;\n\n\tret = init_state(&effective_acl_state, acl->naces);\n\tif (ret)\n\t\treturn ret;\n\tret = init_state(&default_acl_state, acl->naces);\n\tif (ret)\n\t\tgoto out_estate;\n\tret = -EINVAL;\n\tfor (ace = acl->aces; ace < acl->aces + acl->naces; ace++) {\n\t\tif (ace->type != NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE &&\n\t\t    ace->type != NFS4_ACE_ACCESS_DENIED_ACE_TYPE)\n\t\t\tgoto out_dstate;\n\t\tif (ace->flag & ~NFS4_SUPPORTED_FLAGS)\n\t\t\tgoto out_dstate;\n\t\tif ((ace->flag & NFS4_INHERITANCE_FLAGS) == 0) {\n\t\t\tprocess_one_v4_ace(&effective_acl_state, ace);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!(flags & NFS4_ACL_DIR))\n\t\t\tgoto out_dstate;\n\t\t \n\t\tprocess_one_v4_ace(&default_acl_state, ace);\n\n\t\tif (!(ace->flag & NFS4_ACE_INHERIT_ONLY_ACE))\n\t\t\tprocess_one_v4_ace(&effective_acl_state, ace);\n\t}\n\n\t \n\tif (default_acl_state.valid) {\n\t\tif (!(default_acl_state.valid & ACL_USER_OBJ))\n\t\t\tdefault_acl_state.owner = effective_acl_state.owner;\n\t\tif (!(default_acl_state.valid & ACL_GROUP_OBJ))\n\t\t\tdefault_acl_state.group = effective_acl_state.group;\n\t\tif (!(default_acl_state.valid & ACL_OTHER))\n\t\t\tdefault_acl_state.other = effective_acl_state.other;\n\t}\n\n\t*pacl = posix_state_to_acl(&effective_acl_state, flags);\n\tif (IS_ERR(*pacl)) {\n\t\tret = PTR_ERR(*pacl);\n\t\t*pacl = NULL;\n\t\tgoto out_dstate;\n\t}\n\t*dpacl = posix_state_to_acl(&default_acl_state,\n\t\t\t\t\t\tflags | NFS4_ACL_TYPE_DEFAULT);\n\tif (IS_ERR(*dpacl)) {\n\t\tret = PTR_ERR(*dpacl);\n\t\t*dpacl = NULL;\n\t\tposix_acl_release(*pacl);\n\t\t*pacl = NULL;\n\t\tgoto out_dstate;\n\t}\n\tsort_pacl(*pacl);\n\tsort_pacl(*dpacl);\n\tret = 0;\nout_dstate:\n\tfree_state(&default_acl_state);\nout_estate:\n\tfree_state(&effective_acl_state);\n\treturn ret;\n}\n\n__be32 nfsd4_acl_to_attr(enum nfs_ftype4 type, struct nfs4_acl *acl,\n\t\t\t struct nfsd_attrs *attr)\n{\n\tint host_error;\n\tunsigned int flags = 0;\n\n\tif (!acl)\n\t\treturn nfs_ok;\n\n\tif (type == NF4DIR)\n\t\tflags = NFS4_ACL_DIR;\n\n\thost_error = nfs4_acl_nfsv4_to_posix(acl, &attr->na_pacl,\n\t\t\t\t\t     &attr->na_dpacl, flags);\n\tif (host_error == -EINVAL)\n\t\treturn nfserr_attrnotsupp;\n\telse\n\t\treturn nfserrno(host_error);\n}\n\nstatic short\nace2type(struct nfs4_ace *ace)\n{\n\tswitch (ace->whotype) {\n\t\tcase NFS4_ACL_WHO_NAMED:\n\t\t\treturn (ace->flag & NFS4_ACE_IDENTIFIER_GROUP ?\n\t\t\t\t\tACL_GROUP : ACL_USER);\n\t\tcase NFS4_ACL_WHO_OWNER:\n\t\t\treturn ACL_USER_OBJ;\n\t\tcase NFS4_ACL_WHO_GROUP:\n\t\t\treturn ACL_GROUP_OBJ;\n\t\tcase NFS4_ACL_WHO_EVERYONE:\n\t\t\treturn ACL_OTHER;\n\t}\n\tBUG();\n\treturn -1;\n}\n\n \nint nfs4_acl_bytes(int entries)\n{\n\treturn sizeof(struct nfs4_acl) + entries * sizeof(struct nfs4_ace);\n}\n\nstatic struct {\n\tchar *string;\n\tint   stringlen;\n\tint type;\n} s2t_map[] = {\n\t{\n\t\t.string    = \"OWNER@\",\n\t\t.stringlen = sizeof(\"OWNER@\") - 1,\n\t\t.type      = NFS4_ACL_WHO_OWNER,\n\t},\n\t{\n\t\t.string    = \"GROUP@\",\n\t\t.stringlen = sizeof(\"GROUP@\") - 1,\n\t\t.type      = NFS4_ACL_WHO_GROUP,\n\t},\n\t{\n\t\t.string    = \"EVERYONE@\",\n\t\t.stringlen = sizeof(\"EVERYONE@\") - 1,\n\t\t.type      = NFS4_ACL_WHO_EVERYONE,\n\t},\n};\n\nint\nnfs4_acl_get_whotype(char *p, u32 len)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(s2t_map); i++) {\n\t\tif (s2t_map[i].stringlen == len &&\n\t\t\t\t0 == memcmp(s2t_map[i].string, p, len))\n\t\t\treturn s2t_map[i].type;\n\t}\n\treturn NFS4_ACL_WHO_NAMED;\n}\n\n__be32 nfs4_acl_write_who(struct xdr_stream *xdr, int who)\n{\n\t__be32 *p;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(s2t_map); i++) {\n\t\tif (s2t_map[i].type != who)\n\t\t\tcontinue;\n\t\tp = xdr_reserve_space(xdr, s2t_map[i].stringlen + 4);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\tp = xdr_encode_opaque(p, s2t_map[i].string,\n\t\t\t\t\ts2t_map[i].stringlen);\n\t\treturn 0;\n\t}\n\tWARN_ON_ONCE(1);\n\treturn nfserr_serverfault;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}