{
  "module_name": "nfsproc.c",
  "hash_id": "97f76dedfe33fd02394bd40b4bcc2ddb00d1f711f1df8cba7c85850d49b5d586",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfsd/nfsproc.c",
  "human_readable_source": "\n \n\n#include <linux/namei.h>\n\n#include \"cache.h\"\n#include \"xdr.h\"\n#include \"vfs.h\"\n\n#define NFSDDBG_FACILITY\t\tNFSDDBG_PROC\n\nstatic __be32\nnfsd_proc_null(struct svc_rqst *rqstp)\n{\n\treturn rpc_success;\n}\n\n \nstatic __be32\nnfsd_proc_getattr(struct svc_rqst *rqstp)\n{\n\tstruct nfsd_fhandle *argp = rqstp->rq_argp;\n\tstruct nfsd_attrstat *resp = rqstp->rq_resp;\n\n\tdprintk(\"nfsd: GETATTR  %s\\n\", SVCFH_fmt(&argp->fh));\n\n\tfh_copy(&resp->fh, &argp->fh);\n\tresp->status = fh_verify(rqstp, &resp->fh, 0,\n\t\t\t\t NFSD_MAY_NOP | NFSD_MAY_BYPASS_GSS_ON_ROOT);\n\tif (resp->status != nfs_ok)\n\t\tgoto out;\n\tresp->status = fh_getattr(&resp->fh, &resp->stat);\nout:\n\treturn rpc_success;\n}\n\n \nstatic __be32\nnfsd_proc_setattr(struct svc_rqst *rqstp)\n{\n\tstruct nfsd_sattrargs *argp = rqstp->rq_argp;\n\tstruct nfsd_attrstat *resp = rqstp->rq_resp;\n\tstruct iattr *iap = &argp->attrs;\n\tstruct nfsd_attrs attrs = {\n\t\t.na_iattr\t= iap,\n\t};\n\tstruct svc_fh *fhp;\n\n\tdprintk(\"nfsd: SETATTR  %s, valid=%x, size=%ld\\n\",\n\t\tSVCFH_fmt(&argp->fh),\n\t\targp->attrs.ia_valid, (long) argp->attrs.ia_size);\n\n\tfhp = fh_copy(&resp->fh, &argp->fh);\n\n\t \n#define BOTH_TIME_SET (ATTR_ATIME_SET | ATTR_MTIME_SET)\n#define\tMAX_TOUCH_TIME_ERROR (30*60)\n\tif ((iap->ia_valid & BOTH_TIME_SET) == BOTH_TIME_SET &&\n\t    iap->ia_mtime.tv_sec == iap->ia_atime.tv_sec) {\n\t\t \n\t\ttime64_t delta = iap->ia_atime.tv_sec - ktime_get_real_seconds();\n\n\t\tresp->status = fh_verify(rqstp, fhp, 0, NFSD_MAY_NOP);\n\t\tif (resp->status != nfs_ok)\n\t\t\tgoto out;\n\n\t\tif (delta < 0)\n\t\t\tdelta = -delta;\n\t\tif (delta < MAX_TOUCH_TIME_ERROR &&\n\t\t    setattr_prepare(&nop_mnt_idmap, fhp->fh_dentry, iap) != 0) {\n\t\t\t \n\t\t\tiap->ia_valid &= ~BOTH_TIME_SET;\n\t\t}\n\t}\n\n\tresp->status = nfsd_setattr(rqstp, fhp, &attrs, 0, (time64_t)0);\n\tif (resp->status != nfs_ok)\n\t\tgoto out;\n\n\tresp->status = fh_getattr(&resp->fh, &resp->stat);\nout:\n\treturn rpc_success;\n}\n\n \nstatic __be32\nnfsd_proc_root(struct svc_rqst *rqstp)\n{\n\treturn rpc_success;\n}\n\n \nstatic __be32\nnfsd_proc_lookup(struct svc_rqst *rqstp)\n{\n\tstruct nfsd_diropargs *argp = rqstp->rq_argp;\n\tstruct nfsd_diropres *resp = rqstp->rq_resp;\n\n\tdprintk(\"nfsd: LOOKUP   %s %.*s\\n\",\n\t\tSVCFH_fmt(&argp->fh), argp->len, argp->name);\n\n\tfh_init(&resp->fh, NFS_FHSIZE);\n\tresp->status = nfsd_lookup(rqstp, &argp->fh, argp->name, argp->len,\n\t\t\t\t   &resp->fh);\n\tfh_put(&argp->fh);\n\tif (resp->status != nfs_ok)\n\t\tgoto out;\n\n\tresp->status = fh_getattr(&resp->fh, &resp->stat);\nout:\n\treturn rpc_success;\n}\n\n \nstatic __be32\nnfsd_proc_readlink(struct svc_rqst *rqstp)\n{\n\tstruct nfsd_fhandle *argp = rqstp->rq_argp;\n\tstruct nfsd_readlinkres *resp = rqstp->rq_resp;\n\n\tdprintk(\"nfsd: READLINK %s\\n\", SVCFH_fmt(&argp->fh));\n\n\t \n\tresp->len = NFS_MAXPATHLEN;\n\tresp->page = *(rqstp->rq_next_page++);\n\tresp->status = nfsd_readlink(rqstp, &argp->fh,\n\t\t\t\t     page_address(resp->page), &resp->len);\n\n\tfh_put(&argp->fh);\n\treturn rpc_success;\n}\n\n \nstatic __be32\nnfsd_proc_read(struct svc_rqst *rqstp)\n{\n\tstruct nfsd_readargs *argp = rqstp->rq_argp;\n\tstruct nfsd_readres *resp = rqstp->rq_resp;\n\tu32 eof;\n\n\tdprintk(\"nfsd: READ    %s %d bytes at %d\\n\",\n\t\tSVCFH_fmt(&argp->fh),\n\t\targp->count, argp->offset);\n\n\targp->count = min_t(u32, argp->count, NFSSVC_MAXBLKSIZE_V2);\n\targp->count = min_t(u32, argp->count, rqstp->rq_res.buflen);\n\n\tresp->pages = rqstp->rq_next_page;\n\n\t \n\tsvc_reserve_auth(rqstp, (19<<2) + argp->count + 4);\n\n\tresp->count = argp->count;\n\tfh_copy(&resp->fh, &argp->fh);\n\tresp->status = nfsd_read(rqstp, &resp->fh, argp->offset,\n\t\t\t\t &resp->count, &eof);\n\tif (resp->status == nfs_ok)\n\t\tresp->status = fh_getattr(&resp->fh, &resp->stat);\n\telse if (resp->status == nfserr_jukebox)\n\t\tset_bit(RQ_DROPME, &rqstp->rq_flags);\n\treturn rpc_success;\n}\n\n \nstatic __be32\nnfsd_proc_writecache(struct svc_rqst *rqstp)\n{\n\treturn rpc_success;\n}\n\n \nstatic __be32\nnfsd_proc_write(struct svc_rqst *rqstp)\n{\n\tstruct nfsd_writeargs *argp = rqstp->rq_argp;\n\tstruct nfsd_attrstat *resp = rqstp->rq_resp;\n\tunsigned long cnt = argp->len;\n\tunsigned int nvecs;\n\n\tdprintk(\"nfsd: WRITE    %s %u bytes at %d\\n\",\n\t\tSVCFH_fmt(&argp->fh),\n\t\targp->len, argp->offset);\n\n\tnvecs = svc_fill_write_vector(rqstp, &argp->payload);\n\n\tresp->status = nfsd_write(rqstp, fh_copy(&resp->fh, &argp->fh),\n\t\t\t\t  argp->offset, rqstp->rq_vec, nvecs,\n\t\t\t\t  &cnt, NFS_DATA_SYNC, NULL);\n\tif (resp->status == nfs_ok)\n\t\tresp->status = fh_getattr(&resp->fh, &resp->stat);\n\telse if (resp->status == nfserr_jukebox)\n\t\tset_bit(RQ_DROPME, &rqstp->rq_flags);\n\treturn rpc_success;\n}\n\n \nstatic __be32\nnfsd_proc_create(struct svc_rqst *rqstp)\n{\n\tstruct nfsd_createargs *argp = rqstp->rq_argp;\n\tstruct nfsd_diropres *resp = rqstp->rq_resp;\n\tsvc_fh\t\t*dirfhp = &argp->fh;\n\tsvc_fh\t\t*newfhp = &resp->fh;\n\tstruct iattr\t*attr = &argp->attrs;\n\tstruct nfsd_attrs attrs = {\n\t\t.na_iattr\t= attr,\n\t};\n\tstruct inode\t*inode;\n\tstruct dentry\t*dchild;\n\tint\t\ttype, mode;\n\tint\t\thosterr;\n\tdev_t\t\trdev = 0, wanted = new_decode_dev(attr->ia_size);\n\n\tdprintk(\"nfsd: CREATE   %s %.*s\\n\",\n\t\tSVCFH_fmt(dirfhp), argp->len, argp->name);\n\n\t \n\tresp->status = fh_verify(rqstp, dirfhp, S_IFDIR, NFSD_MAY_EXEC);\n\tif (resp->status != nfs_ok)\n\t\tgoto done;  \n\n\t \n\n\tresp->status = nfserr_exist;\n\tif (isdotent(argp->name, argp->len))\n\t\tgoto done;\n\thosterr = fh_want_write(dirfhp);\n\tif (hosterr) {\n\t\tresp->status = nfserrno(hosterr);\n\t\tgoto done;\n\t}\n\n\tinode_lock_nested(dirfhp->fh_dentry->d_inode, I_MUTEX_PARENT);\n\tdchild = lookup_one_len(argp->name, dirfhp->fh_dentry, argp->len);\n\tif (IS_ERR(dchild)) {\n\t\tresp->status = nfserrno(PTR_ERR(dchild));\n\t\tgoto out_unlock;\n\t}\n\tfh_init(newfhp, NFS_FHSIZE);\n\tresp->status = fh_compose(newfhp, dirfhp->fh_export, dchild, dirfhp);\n\tif (!resp->status && d_really_is_negative(dchild))\n\t\tresp->status = nfserr_noent;\n\tdput(dchild);\n\tif (resp->status) {\n\t\tif (resp->status != nfserr_noent)\n\t\t\tgoto out_unlock;\n\t\t \n\t\tresp->status = nfserr_acces;\n\t\tif (!newfhp->fh_dentry) {\n\t\t\tprintk(KERN_WARNING \n\t\t\t\t\"nfsd_proc_create: file handle not verified\\n\");\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tinode = d_inode(newfhp->fh_dentry);\n\n\t \n\tif (attr->ia_valid & ATTR_MODE) {\n\t\ttype = attr->ia_mode & S_IFMT;\n\t\tmode = attr->ia_mode & ~S_IFMT;\n\t\tif (!type) {\n\t\t\t \n\t\t\tif (inode) {\n\t\t\t\ttype = inode->i_mode & S_IFMT;\n\t\t\t\tswitch(type) {\n\t\t\t\tcase S_IFCHR:\n\t\t\t\tcase S_IFBLK:\n\t\t\t\t\t \n\t\t\t\t\trdev = inode->i_rdev;\n\t\t\t\t\tattr->ia_valid |= ATTR_SIZE;\n\n\t\t\t\t\tfallthrough;\n\t\t\t\tcase S_IFIFO:\n\t\t\t\t\t \n\t\t\t\t\tresp->status = nfsd_permission(rqstp,\n\t\t\t\t\t\t\t\t newfhp->fh_export,\n\t\t\t\t\t\t\t\t newfhp->fh_dentry,\n\t\t\t\t\t\t\t\t NFSD_MAY_WRITE|NFSD_MAY_LOCAL_ACCESS);\n\t\t\t\t\tif (resp->status && resp->status != nfserr_rofs)\n\t\t\t\t\t\tgoto out_unlock;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\ttype = S_IFREG;\n\t\t}\n\t} else if (inode) {\n\t\ttype = inode->i_mode & S_IFMT;\n\t\tmode = inode->i_mode & ~S_IFMT;\n\t} else {\n\t\ttype = S_IFREG;\n\t\tmode = 0;\t \n\t}\n\n\tattr->ia_valid |= ATTR_MODE;\n\tattr->ia_mode = mode;\n\n\t \n\tif (type != S_IFREG) {\n\t\tif (type != S_IFBLK && type != S_IFCHR) {\n\t\t\trdev = 0;\n\t\t} else if (type == S_IFCHR && !(attr->ia_valid & ATTR_SIZE)) {\n\t\t\t \n\t\t\ttype = S_IFIFO;\n\t\t} else {\n\t\t\t \n\t\t\tif (!rdev)\n\t\t\t\trdev = wanted;\n\t\t}\n\n\t\t \n\t\tattr->ia_valid &= ~ATTR_SIZE;\n\n\t\t \n\t\tresp->status = nfserr_exist;\n\t\tif (inode && inode_wrong_type(inode, type))\n\t\t\tgoto out_unlock;\n\t}\n\n\tresp->status = nfs_ok;\n\tif (!inode) {\n\t\t \n\t\tresp->status = nfsd_create_locked(rqstp, dirfhp, &attrs, type,\n\t\t\t\t\t\t  rdev, newfhp);\n\t} else if (type == S_IFREG) {\n\t\tdprintk(\"nfsd:   existing %s, valid=%x, size=%ld\\n\",\n\t\t\targp->name, attr->ia_valid, (long) attr->ia_size);\n\t\t \n\t\tattr->ia_valid &= ATTR_SIZE;\n\t\tif (attr->ia_valid)\n\t\t\tresp->status = nfsd_setattr(rqstp, newfhp, &attrs, 0,\n\t\t\t\t\t\t    (time64_t)0);\n\t}\n\nout_unlock:\n\tinode_unlock(dirfhp->fh_dentry->d_inode);\n\tfh_drop_write(dirfhp);\ndone:\n\tfh_put(dirfhp);\n\tif (resp->status != nfs_ok)\n\t\tgoto out;\n\tresp->status = fh_getattr(&resp->fh, &resp->stat);\nout:\n\treturn rpc_success;\n}\n\nstatic __be32\nnfsd_proc_remove(struct svc_rqst *rqstp)\n{\n\tstruct nfsd_diropargs *argp = rqstp->rq_argp;\n\tstruct nfsd_stat *resp = rqstp->rq_resp;\n\n\tdprintk(\"nfsd: REMOVE   %s %.*s\\n\", SVCFH_fmt(&argp->fh),\n\t\targp->len, argp->name);\n\n\t \n\tresp->status = nfsd_unlink(rqstp, &argp->fh, -S_IFDIR,\n\t\t\t\t   argp->name, argp->len);\n\tfh_put(&argp->fh);\n\treturn rpc_success;\n}\n\nstatic __be32\nnfsd_proc_rename(struct svc_rqst *rqstp)\n{\n\tstruct nfsd_renameargs *argp = rqstp->rq_argp;\n\tstruct nfsd_stat *resp = rqstp->rq_resp;\n\n\tdprintk(\"nfsd: RENAME   %s %.*s -> \\n\",\n\t\tSVCFH_fmt(&argp->ffh), argp->flen, argp->fname);\n\tdprintk(\"nfsd:        ->  %s %.*s\\n\",\n\t\tSVCFH_fmt(&argp->tfh), argp->tlen, argp->tname);\n\n\tresp->status = nfsd_rename(rqstp, &argp->ffh, argp->fname, argp->flen,\n\t\t\t\t   &argp->tfh, argp->tname, argp->tlen);\n\tfh_put(&argp->ffh);\n\tfh_put(&argp->tfh);\n\treturn rpc_success;\n}\n\nstatic __be32\nnfsd_proc_link(struct svc_rqst *rqstp)\n{\n\tstruct nfsd_linkargs *argp = rqstp->rq_argp;\n\tstruct nfsd_stat *resp = rqstp->rq_resp;\n\n\tdprintk(\"nfsd: LINK     %s ->\\n\",\n\t\tSVCFH_fmt(&argp->ffh));\n\tdprintk(\"nfsd:    %s %.*s\\n\",\n\t\tSVCFH_fmt(&argp->tfh),\n\t\targp->tlen,\n\t\targp->tname);\n\n\tresp->status = nfsd_link(rqstp, &argp->tfh, argp->tname, argp->tlen,\n\t\t\t\t &argp->ffh);\n\tfh_put(&argp->ffh);\n\tfh_put(&argp->tfh);\n\treturn rpc_success;\n}\n\nstatic __be32\nnfsd_proc_symlink(struct svc_rqst *rqstp)\n{\n\tstruct nfsd_symlinkargs *argp = rqstp->rq_argp;\n\tstruct nfsd_stat *resp = rqstp->rq_resp;\n\tstruct nfsd_attrs attrs = {\n\t\t.na_iattr\t= &argp->attrs,\n\t};\n\tstruct svc_fh\tnewfh;\n\n\tif (argp->tlen > NFS_MAXPATHLEN) {\n\t\tresp->status = nfserr_nametoolong;\n\t\tgoto out;\n\t}\n\n\targp->tname = svc_fill_symlink_pathname(rqstp, &argp->first,\n\t\t\t\t\t\tpage_address(rqstp->rq_arg.pages[0]),\n\t\t\t\t\t\targp->tlen);\n\tif (IS_ERR(argp->tname)) {\n\t\tresp->status = nfserrno(PTR_ERR(argp->tname));\n\t\tgoto out;\n\t}\n\n\tdprintk(\"nfsd: SYMLINK  %s %.*s -> %.*s\\n\",\n\t\tSVCFH_fmt(&argp->ffh), argp->flen, argp->fname,\n\t\targp->tlen, argp->tname);\n\n\tfh_init(&newfh, NFS_FHSIZE);\n\tresp->status = nfsd_symlink(rqstp, &argp->ffh, argp->fname, argp->flen,\n\t\t\t\t    argp->tname, &attrs, &newfh);\n\n\tkfree(argp->tname);\n\tfh_put(&argp->ffh);\n\tfh_put(&newfh);\nout:\n\treturn rpc_success;\n}\n\n \nstatic __be32\nnfsd_proc_mkdir(struct svc_rqst *rqstp)\n{\n\tstruct nfsd_createargs *argp = rqstp->rq_argp;\n\tstruct nfsd_diropres *resp = rqstp->rq_resp;\n\tstruct nfsd_attrs attrs = {\n\t\t.na_iattr\t= &argp->attrs,\n\t};\n\n\tdprintk(\"nfsd: MKDIR    %s %.*s\\n\", SVCFH_fmt(&argp->fh), argp->len, argp->name);\n\n\tif (resp->fh.fh_dentry) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"nfsd_proc_mkdir: response already verified??\\n\");\n\t}\n\n\targp->attrs.ia_valid &= ~ATTR_SIZE;\n\tfh_init(&resp->fh, NFS_FHSIZE);\n\tresp->status = nfsd_create(rqstp, &argp->fh, argp->name, argp->len,\n\t\t\t\t   &attrs, S_IFDIR, 0, &resp->fh);\n\tfh_put(&argp->fh);\n\tif (resp->status != nfs_ok)\n\t\tgoto out;\n\n\tresp->status = fh_getattr(&resp->fh, &resp->stat);\nout:\n\treturn rpc_success;\n}\n\n \nstatic __be32\nnfsd_proc_rmdir(struct svc_rqst *rqstp)\n{\n\tstruct nfsd_diropargs *argp = rqstp->rq_argp;\n\tstruct nfsd_stat *resp = rqstp->rq_resp;\n\n\tdprintk(\"nfsd: RMDIR    %s %.*s\\n\", SVCFH_fmt(&argp->fh), argp->len, argp->name);\n\n\tresp->status = nfsd_unlink(rqstp, &argp->fh, S_IFDIR,\n\t\t\t\t   argp->name, argp->len);\n\tfh_put(&argp->fh);\n\treturn rpc_success;\n}\n\nstatic void nfsd_init_dirlist_pages(struct svc_rqst *rqstp,\n\t\t\t\t    struct nfsd_readdirres *resp,\n\t\t\t\t    u32 count)\n{\n\tstruct xdr_buf *buf = &resp->dirlist;\n\tstruct xdr_stream *xdr = &resp->xdr;\n\n\tmemset(buf, 0, sizeof(*buf));\n\n\t \n\tbuf->buflen = clamp(count, (u32)(XDR_UNIT * 2), (u32)PAGE_SIZE);\n\tbuf->buflen -= XDR_UNIT * 2;\n\tbuf->pages = rqstp->rq_next_page;\n\trqstp->rq_next_page++;\n\n\txdr_init_encode_pages(xdr, buf, buf->pages,  NULL);\n}\n\n \nstatic __be32\nnfsd_proc_readdir(struct svc_rqst *rqstp)\n{\n\tstruct nfsd_readdirargs *argp = rqstp->rq_argp;\n\tstruct nfsd_readdirres *resp = rqstp->rq_resp;\n\tloff_t\t\toffset;\n\n\tdprintk(\"nfsd: READDIR  %s %d bytes at %d\\n\",\n\t\tSVCFH_fmt(&argp->fh),\t\t\n\t\targp->count, argp->cookie);\n\n\tnfsd_init_dirlist_pages(rqstp, resp, argp->count);\n\n\tresp->common.err = nfs_ok;\n\tresp->cookie_offset = 0;\n\toffset = argp->cookie;\n\tresp->status = nfsd_readdir(rqstp, &argp->fh, &offset,\n\t\t\t\t    &resp->common, nfssvc_encode_entry);\n\tnfssvc_encode_nfscookie(resp, offset);\n\n\tfh_put(&argp->fh);\n\treturn rpc_success;\n}\n\n \nstatic __be32\nnfsd_proc_statfs(struct svc_rqst *rqstp)\n{\n\tstruct nfsd_fhandle *argp = rqstp->rq_argp;\n\tstruct nfsd_statfsres *resp = rqstp->rq_resp;\n\n\tdprintk(\"nfsd: STATFS   %s\\n\", SVCFH_fmt(&argp->fh));\n\n\tresp->status = nfsd_statfs(rqstp, &argp->fh, &resp->stats,\n\t\t\t\t   NFSD_MAY_BYPASS_GSS_ON_ROOT);\n\tfh_put(&argp->fh);\n\treturn rpc_success;\n}\n\n \n\n#define ST 1\t\t \n#define FH 8\t\t \n#define\tAT 18\t\t \n\nstatic const struct svc_procedure nfsd_procedures2[18] = {\n\t[NFSPROC_NULL] = {\n\t\t.pc_func = nfsd_proc_null,\n\t\t.pc_decode = nfssvc_decode_voidarg,\n\t\t.pc_encode = nfssvc_encode_voidres,\n\t\t.pc_argsize = sizeof(struct nfsd_voidargs),\n\t\t.pc_argzero = sizeof(struct nfsd_voidargs),\n\t\t.pc_ressize = sizeof(struct nfsd_voidres),\n\t\t.pc_cachetype = RC_NOCACHE,\n\t\t.pc_xdrressize = 0,\n\t\t.pc_name = \"NULL\",\n\t},\n\t[NFSPROC_GETATTR] = {\n\t\t.pc_func = nfsd_proc_getattr,\n\t\t.pc_decode = nfssvc_decode_fhandleargs,\n\t\t.pc_encode = nfssvc_encode_attrstatres,\n\t\t.pc_release = nfssvc_release_attrstat,\n\t\t.pc_argsize = sizeof(struct nfsd_fhandle),\n\t\t.pc_argzero = sizeof(struct nfsd_fhandle),\n\t\t.pc_ressize = sizeof(struct nfsd_attrstat),\n\t\t.pc_cachetype = RC_NOCACHE,\n\t\t.pc_xdrressize = ST+AT,\n\t\t.pc_name = \"GETATTR\",\n\t},\n\t[NFSPROC_SETATTR] = {\n\t\t.pc_func = nfsd_proc_setattr,\n\t\t.pc_decode = nfssvc_decode_sattrargs,\n\t\t.pc_encode = nfssvc_encode_attrstatres,\n\t\t.pc_release = nfssvc_release_attrstat,\n\t\t.pc_argsize = sizeof(struct nfsd_sattrargs),\n\t\t.pc_argzero = sizeof(struct nfsd_sattrargs),\n\t\t.pc_ressize = sizeof(struct nfsd_attrstat),\n\t\t.pc_cachetype = RC_REPLBUFF,\n\t\t.pc_xdrressize = ST+AT,\n\t\t.pc_name = \"SETATTR\",\n\t},\n\t[NFSPROC_ROOT] = {\n\t\t.pc_func = nfsd_proc_root,\n\t\t.pc_decode = nfssvc_decode_voidarg,\n\t\t.pc_encode = nfssvc_encode_voidres,\n\t\t.pc_argsize = sizeof(struct nfsd_voidargs),\n\t\t.pc_argzero = sizeof(struct nfsd_voidargs),\n\t\t.pc_ressize = sizeof(struct nfsd_voidres),\n\t\t.pc_cachetype = RC_NOCACHE,\n\t\t.pc_xdrressize = 0,\n\t\t.pc_name = \"ROOT\",\n\t},\n\t[NFSPROC_LOOKUP] = {\n\t\t.pc_func = nfsd_proc_lookup,\n\t\t.pc_decode = nfssvc_decode_diropargs,\n\t\t.pc_encode = nfssvc_encode_diropres,\n\t\t.pc_release = nfssvc_release_diropres,\n\t\t.pc_argsize = sizeof(struct nfsd_diropargs),\n\t\t.pc_argzero = sizeof(struct nfsd_diropargs),\n\t\t.pc_ressize = sizeof(struct nfsd_diropres),\n\t\t.pc_cachetype = RC_NOCACHE,\n\t\t.pc_xdrressize = ST+FH+AT,\n\t\t.pc_name = \"LOOKUP\",\n\t},\n\t[NFSPROC_READLINK] = {\n\t\t.pc_func = nfsd_proc_readlink,\n\t\t.pc_decode = nfssvc_decode_fhandleargs,\n\t\t.pc_encode = nfssvc_encode_readlinkres,\n\t\t.pc_argsize = sizeof(struct nfsd_fhandle),\n\t\t.pc_argzero = sizeof(struct nfsd_fhandle),\n\t\t.pc_ressize = sizeof(struct nfsd_readlinkres),\n\t\t.pc_cachetype = RC_NOCACHE,\n\t\t.pc_xdrressize = ST+1+NFS_MAXPATHLEN/4,\n\t\t.pc_name = \"READLINK\",\n\t},\n\t[NFSPROC_READ] = {\n\t\t.pc_func = nfsd_proc_read,\n\t\t.pc_decode = nfssvc_decode_readargs,\n\t\t.pc_encode = nfssvc_encode_readres,\n\t\t.pc_release = nfssvc_release_readres,\n\t\t.pc_argsize = sizeof(struct nfsd_readargs),\n\t\t.pc_argzero = sizeof(struct nfsd_readargs),\n\t\t.pc_ressize = sizeof(struct nfsd_readres),\n\t\t.pc_cachetype = RC_NOCACHE,\n\t\t.pc_xdrressize = ST+AT+1+NFSSVC_MAXBLKSIZE_V2/4,\n\t\t.pc_name = \"READ\",\n\t},\n\t[NFSPROC_WRITECACHE] = {\n\t\t.pc_func = nfsd_proc_writecache,\n\t\t.pc_decode = nfssvc_decode_voidarg,\n\t\t.pc_encode = nfssvc_encode_voidres,\n\t\t.pc_argsize = sizeof(struct nfsd_voidargs),\n\t\t.pc_argzero = sizeof(struct nfsd_voidargs),\n\t\t.pc_ressize = sizeof(struct nfsd_voidres),\n\t\t.pc_cachetype = RC_NOCACHE,\n\t\t.pc_xdrressize = 0,\n\t\t.pc_name = \"WRITECACHE\",\n\t},\n\t[NFSPROC_WRITE] = {\n\t\t.pc_func = nfsd_proc_write,\n\t\t.pc_decode = nfssvc_decode_writeargs,\n\t\t.pc_encode = nfssvc_encode_attrstatres,\n\t\t.pc_release = nfssvc_release_attrstat,\n\t\t.pc_argsize = sizeof(struct nfsd_writeargs),\n\t\t.pc_argzero = sizeof(struct nfsd_writeargs),\n\t\t.pc_ressize = sizeof(struct nfsd_attrstat),\n\t\t.pc_cachetype = RC_REPLBUFF,\n\t\t.pc_xdrressize = ST+AT,\n\t\t.pc_name = \"WRITE\",\n\t},\n\t[NFSPROC_CREATE] = {\n\t\t.pc_func = nfsd_proc_create,\n\t\t.pc_decode = nfssvc_decode_createargs,\n\t\t.pc_encode = nfssvc_encode_diropres,\n\t\t.pc_release = nfssvc_release_diropres,\n\t\t.pc_argsize = sizeof(struct nfsd_createargs),\n\t\t.pc_argzero = sizeof(struct nfsd_createargs),\n\t\t.pc_ressize = sizeof(struct nfsd_diropres),\n\t\t.pc_cachetype = RC_REPLBUFF,\n\t\t.pc_xdrressize = ST+FH+AT,\n\t\t.pc_name = \"CREATE\",\n\t},\n\t[NFSPROC_REMOVE] = {\n\t\t.pc_func = nfsd_proc_remove,\n\t\t.pc_decode = nfssvc_decode_diropargs,\n\t\t.pc_encode = nfssvc_encode_statres,\n\t\t.pc_argsize = sizeof(struct nfsd_diropargs),\n\t\t.pc_argzero = sizeof(struct nfsd_diropargs),\n\t\t.pc_ressize = sizeof(struct nfsd_stat),\n\t\t.pc_cachetype = RC_REPLSTAT,\n\t\t.pc_xdrressize = ST,\n\t\t.pc_name = \"REMOVE\",\n\t},\n\t[NFSPROC_RENAME] = {\n\t\t.pc_func = nfsd_proc_rename,\n\t\t.pc_decode = nfssvc_decode_renameargs,\n\t\t.pc_encode = nfssvc_encode_statres,\n\t\t.pc_argsize = sizeof(struct nfsd_renameargs),\n\t\t.pc_argzero = sizeof(struct nfsd_renameargs),\n\t\t.pc_ressize = sizeof(struct nfsd_stat),\n\t\t.pc_cachetype = RC_REPLSTAT,\n\t\t.pc_xdrressize = ST,\n\t\t.pc_name = \"RENAME\",\n\t},\n\t[NFSPROC_LINK] = {\n\t\t.pc_func = nfsd_proc_link,\n\t\t.pc_decode = nfssvc_decode_linkargs,\n\t\t.pc_encode = nfssvc_encode_statres,\n\t\t.pc_argsize = sizeof(struct nfsd_linkargs),\n\t\t.pc_argzero = sizeof(struct nfsd_linkargs),\n\t\t.pc_ressize = sizeof(struct nfsd_stat),\n\t\t.pc_cachetype = RC_REPLSTAT,\n\t\t.pc_xdrressize = ST,\n\t\t.pc_name = \"LINK\",\n\t},\n\t[NFSPROC_SYMLINK] = {\n\t\t.pc_func = nfsd_proc_symlink,\n\t\t.pc_decode = nfssvc_decode_symlinkargs,\n\t\t.pc_encode = nfssvc_encode_statres,\n\t\t.pc_argsize = sizeof(struct nfsd_symlinkargs),\n\t\t.pc_argzero = sizeof(struct nfsd_symlinkargs),\n\t\t.pc_ressize = sizeof(struct nfsd_stat),\n\t\t.pc_cachetype = RC_REPLSTAT,\n\t\t.pc_xdrressize = ST,\n\t\t.pc_name = \"SYMLINK\",\n\t},\n\t[NFSPROC_MKDIR] = {\n\t\t.pc_func = nfsd_proc_mkdir,\n\t\t.pc_decode = nfssvc_decode_createargs,\n\t\t.pc_encode = nfssvc_encode_diropres,\n\t\t.pc_release = nfssvc_release_diropres,\n\t\t.pc_argsize = sizeof(struct nfsd_createargs),\n\t\t.pc_argzero = sizeof(struct nfsd_createargs),\n\t\t.pc_ressize = sizeof(struct nfsd_diropres),\n\t\t.pc_cachetype = RC_REPLBUFF,\n\t\t.pc_xdrressize = ST+FH+AT,\n\t\t.pc_name = \"MKDIR\",\n\t},\n\t[NFSPROC_RMDIR] = {\n\t\t.pc_func = nfsd_proc_rmdir,\n\t\t.pc_decode = nfssvc_decode_diropargs,\n\t\t.pc_encode = nfssvc_encode_statres,\n\t\t.pc_argsize = sizeof(struct nfsd_diropargs),\n\t\t.pc_argzero = sizeof(struct nfsd_diropargs),\n\t\t.pc_ressize = sizeof(struct nfsd_stat),\n\t\t.pc_cachetype = RC_REPLSTAT,\n\t\t.pc_xdrressize = ST,\n\t\t.pc_name = \"RMDIR\",\n\t},\n\t[NFSPROC_READDIR] = {\n\t\t.pc_func = nfsd_proc_readdir,\n\t\t.pc_decode = nfssvc_decode_readdirargs,\n\t\t.pc_encode = nfssvc_encode_readdirres,\n\t\t.pc_argsize = sizeof(struct nfsd_readdirargs),\n\t\t.pc_argzero = sizeof(struct nfsd_readdirargs),\n\t\t.pc_ressize = sizeof(struct nfsd_readdirres),\n\t\t.pc_cachetype = RC_NOCACHE,\n\t\t.pc_name = \"READDIR\",\n\t},\n\t[NFSPROC_STATFS] = {\n\t\t.pc_func = nfsd_proc_statfs,\n\t\t.pc_decode = nfssvc_decode_fhandleargs,\n\t\t.pc_encode = nfssvc_encode_statfsres,\n\t\t.pc_argsize = sizeof(struct nfsd_fhandle),\n\t\t.pc_argzero = sizeof(struct nfsd_fhandle),\n\t\t.pc_ressize = sizeof(struct nfsd_statfsres),\n\t\t.pc_cachetype = RC_NOCACHE,\n\t\t.pc_xdrressize = ST+5,\n\t\t.pc_name = \"STATFS\",\n\t},\n};\n\nstatic DEFINE_PER_CPU_ALIGNED(unsigned long,\n\t\t\t      nfsd_count2[ARRAY_SIZE(nfsd_procedures2)]);\nconst struct svc_version nfsd_version2 = {\n\t.vs_vers\t= 2,\n\t.vs_nproc\t= ARRAY_SIZE(nfsd_procedures2),\n\t.vs_proc\t= nfsd_procedures2,\n\t.vs_count\t= nfsd_count2,\n\t.vs_dispatch\t= nfsd_dispatch,\n\t.vs_xdrsize\t= NFS2_SVC_XDRSIZE,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}