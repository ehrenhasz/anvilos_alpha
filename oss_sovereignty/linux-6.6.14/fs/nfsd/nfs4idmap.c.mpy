{
  "module_name": "nfs4idmap.c",
  "hash_id": "f84ff6625c1642df7c60c49adb236b93b7abf9a574df458bcd797d00f4c3c8d4",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfsd/nfs4idmap.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <net/net_namespace.h>\n#include \"idmap.h\"\n#include \"nfsd.h\"\n#include \"netns.h\"\n#include \"vfs.h\"\n\n \nstatic bool nfs4_disable_idmapping = true;\nmodule_param(nfs4_disable_idmapping, bool, 0644);\nMODULE_PARM_DESC(nfs4_disable_idmapping,\n\t\t\"Turn off server's NFSv4 idmapping when using 'sec=sys'\");\n\n \n\n \n\nstruct ent {\n\tstruct cache_head h;\n\tint               type;\t\t        \n\tu32               id;\n\tchar              name[IDMAP_NAMESZ];\n\tchar              authname[IDMAP_NAMESZ];\n\tstruct rcu_head\t  rcu_head;\n};\n\n \n\n#define ENT_HASHBITS          8\n#define ENT_HASHMAX           (1 << ENT_HASHBITS)\n\nstatic void\nent_init(struct cache_head *cnew, struct cache_head *citm)\n{\n\tstruct ent *new = container_of(cnew, struct ent, h);\n\tstruct ent *itm = container_of(citm, struct ent, h);\n\n\tnew->id = itm->id;\n\tnew->type = itm->type;\n\n\tstrscpy(new->name, itm->name, sizeof(new->name));\n\tstrscpy(new->authname, itm->authname, sizeof(new->authname));\n}\n\nstatic void\nent_put(struct kref *ref)\n{\n\tstruct ent *map = container_of(ref, struct ent, h.ref);\n\tkfree_rcu(map, rcu_head);\n}\n\nstatic struct cache_head *\nent_alloc(void)\n{\n\tstruct ent *e = kmalloc(sizeof(*e), GFP_KERNEL);\n\tif (e)\n\t\treturn &e->h;\n\telse\n\t\treturn NULL;\n}\n\n \n\nstatic uint32_t\nidtoname_hash(struct ent *ent)\n{\n\tuint32_t hash;\n\n\thash = hash_str(ent->authname, ENT_HASHBITS);\n\thash = hash_long(hash ^ ent->id, ENT_HASHBITS);\n\n\t \n\tif (ent->type == IDMAP_TYPE_GROUP)\n\t\thash ^= 1;\n\n\treturn hash;\n}\n\nstatic int\nidtoname_upcall(struct cache_detail *cd, struct cache_head *h)\n{\n\treturn sunrpc_cache_pipe_upcall_timeout(cd, h);\n}\n\nstatic void\nidtoname_request(struct cache_detail *cd, struct cache_head *ch, char **bpp,\n    int *blen)\n{\n \tstruct ent *ent = container_of(ch, struct ent, h);\n\tchar idstr[11];\n\n\tqword_add(bpp, blen, ent->authname);\n\tsnprintf(idstr, sizeof(idstr), \"%u\", ent->id);\n\tqword_add(bpp, blen, ent->type == IDMAP_TYPE_GROUP ? \"group\" : \"user\");\n\tqword_add(bpp, blen, idstr);\n\n\t(*bpp)[-1] = '\\n';\n}\n\nstatic int\nidtoname_match(struct cache_head *ca, struct cache_head *cb)\n{\n\tstruct ent *a = container_of(ca, struct ent, h);\n\tstruct ent *b = container_of(cb, struct ent, h);\n\n\treturn (a->id == b->id && a->type == b->type &&\n\t    strcmp(a->authname, b->authname) == 0);\n}\n\nstatic int\nidtoname_show(struct seq_file *m, struct cache_detail *cd, struct cache_head *h)\n{\n\tstruct ent *ent;\n\n\tif (h == NULL) {\n\t\tseq_puts(m, \"#domain type id [name]\\n\");\n\t\treturn 0;\n\t}\n\tent = container_of(h, struct ent, h);\n\tseq_printf(m, \"%s %s %u\", ent->authname,\n\t\t\tent->type == IDMAP_TYPE_GROUP ? \"group\" : \"user\",\n\t\t\tent->id);\n\tif (test_bit(CACHE_VALID, &h->flags))\n\t\tseq_printf(m, \" %s\", ent->name);\n\tseq_putc(m, '\\n');\n\treturn 0;\n}\n\nstatic void\nwarn_no_idmapd(struct cache_detail *detail, int has_died)\n{\n\tprintk(\"nfsd: nfsv4 idmapping failing: has idmapd %s?\\n\",\n\t\t\thas_died ? \"died\" : \"not been started\");\n}\n\n\nstatic int         idtoname_parse(struct cache_detail *, char *, int);\nstatic struct ent *idtoname_lookup(struct cache_detail *, struct ent *);\nstatic struct ent *idtoname_update(struct cache_detail *, struct ent *,\n\t\t\t\t   struct ent *);\n\nstatic const struct cache_detail idtoname_cache_template = {\n\t.owner\t\t= THIS_MODULE,\n\t.hash_size\t= ENT_HASHMAX,\n\t.name\t\t= \"nfs4.idtoname\",\n\t.cache_put\t= ent_put,\n\t.cache_upcall\t= idtoname_upcall,\n\t.cache_request\t= idtoname_request,\n\t.cache_parse\t= idtoname_parse,\n\t.cache_show\t= idtoname_show,\n\t.warn_no_listener = warn_no_idmapd,\n\t.match\t\t= idtoname_match,\n\t.init\t\t= ent_init,\n\t.update\t\t= ent_init,\n\t.alloc\t\t= ent_alloc,\n};\n\nstatic int\nidtoname_parse(struct cache_detail *cd, char *buf, int buflen)\n{\n\tstruct ent ent, *res;\n\tchar *buf1, *bp;\n\tint len;\n\tint error = -EINVAL;\n\n\tif (buf[buflen - 1] != '\\n')\n\t\treturn (-EINVAL);\n\tbuf[buflen - 1]= '\\0';\n\n\tbuf1 = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (buf1 == NULL)\n\t\treturn (-ENOMEM);\n\n\tmemset(&ent, 0, sizeof(ent));\n\n\t \n\tlen = qword_get(&buf, buf1, PAGE_SIZE);\n\tif (len <= 0 || len >= IDMAP_NAMESZ)\n\t\tgoto out;\n\tmemcpy(ent.authname, buf1, sizeof(ent.authname));\n\n\t \n\tif (qword_get(&buf, buf1, PAGE_SIZE) <= 0)\n\t\tgoto out;\n\tent.type = strcmp(buf1, \"user\") == 0 ?\n\t\tIDMAP_TYPE_USER : IDMAP_TYPE_GROUP;\n\n\t \n\tif (qword_get(&buf, buf1, PAGE_SIZE) <= 0)\n\t\tgoto out;\n\tent.id = simple_strtoul(buf1, &bp, 10);\n\tif (bp == buf1)\n\t\tgoto out;\n\n\t \n\terror = get_expiry(&buf, &ent.h.expiry_time);\n\tif (error)\n\t\tgoto out;\n\n\terror = -ENOMEM;\n\tres = idtoname_lookup(cd, &ent);\n\tif (!res)\n\t\tgoto out;\n\n\t \n\terror = -EINVAL;\n\tlen = qword_get(&buf, buf1, PAGE_SIZE);\n\tif (len < 0 || len >= IDMAP_NAMESZ)\n\t\tgoto out;\n\tif (len == 0)\n\t\tset_bit(CACHE_NEGATIVE, &ent.h.flags);\n\telse\n\t\tmemcpy(ent.name, buf1, sizeof(ent.name));\n\terror = -ENOMEM;\n\tres = idtoname_update(cd, &ent, res);\n\tif (res == NULL)\n\t\tgoto out;\n\n\tcache_put(&res->h, cd);\n\terror = 0;\nout:\n\tkfree(buf1);\n\treturn error;\n}\n\nstatic struct ent *\nidtoname_lookup(struct cache_detail *cd, struct ent *item)\n{\n\tstruct cache_head *ch = sunrpc_cache_lookup_rcu(cd, &item->h,\n\t\t\t\t\t\t\tidtoname_hash(item));\n\tif (ch)\n\t\treturn container_of(ch, struct ent, h);\n\telse\n\t\treturn NULL;\n}\n\nstatic struct ent *\nidtoname_update(struct cache_detail *cd, struct ent *new, struct ent *old)\n{\n\tstruct cache_head *ch = sunrpc_cache_update(cd, &new->h, &old->h,\n\t\t\t\t\t\t    idtoname_hash(new));\n\tif (ch)\n\t\treturn container_of(ch, struct ent, h);\n\telse\n\t\treturn NULL;\n}\n\n\n \n\nstatic inline int\nnametoid_hash(struct ent *ent)\n{\n\treturn hash_str(ent->name, ENT_HASHBITS);\n}\n\nstatic int\nnametoid_upcall(struct cache_detail *cd, struct cache_head *h)\n{\n\treturn sunrpc_cache_pipe_upcall_timeout(cd, h);\n}\n\nstatic void\nnametoid_request(struct cache_detail *cd, struct cache_head *ch, char **bpp,\n    int *blen)\n{\n \tstruct ent *ent = container_of(ch, struct ent, h);\n\n\tqword_add(bpp, blen, ent->authname);\n\tqword_add(bpp, blen, ent->type == IDMAP_TYPE_GROUP ? \"group\" : \"user\");\n\tqword_add(bpp, blen, ent->name);\n\n\t(*bpp)[-1] = '\\n';\n}\n\nstatic int\nnametoid_match(struct cache_head *ca, struct cache_head *cb)\n{\n\tstruct ent *a = container_of(ca, struct ent, h);\n\tstruct ent *b = container_of(cb, struct ent, h);\n\n\treturn (a->type == b->type && strcmp(a->name, b->name) == 0 &&\n\t    strcmp(a->authname, b->authname) == 0);\n}\n\nstatic int\nnametoid_show(struct seq_file *m, struct cache_detail *cd, struct cache_head *h)\n{\n\tstruct ent *ent;\n\n\tif (h == NULL) {\n\t\tseq_puts(m, \"#domain type name [id]\\n\");\n\t\treturn 0;\n\t}\n\tent = container_of(h, struct ent, h);\n\tseq_printf(m, \"%s %s %s\", ent->authname,\n\t\t\tent->type == IDMAP_TYPE_GROUP ? \"group\" : \"user\",\n\t\t\tent->name);\n\tif (test_bit(CACHE_VALID, &h->flags))\n\t\tseq_printf(m, \" %u\", ent->id);\n\tseq_putc(m, '\\n');\n\treturn 0;\n}\n\nstatic struct ent *nametoid_lookup(struct cache_detail *, struct ent *);\nstatic struct ent *nametoid_update(struct cache_detail *, struct ent *,\n\t\t\t\t   struct ent *);\nstatic int         nametoid_parse(struct cache_detail *, char *, int);\n\nstatic const struct cache_detail nametoid_cache_template = {\n\t.owner\t\t= THIS_MODULE,\n\t.hash_size\t= ENT_HASHMAX,\n\t.name\t\t= \"nfs4.nametoid\",\n\t.cache_put\t= ent_put,\n\t.cache_upcall\t= nametoid_upcall,\n\t.cache_request\t= nametoid_request,\n\t.cache_parse\t= nametoid_parse,\n\t.cache_show\t= nametoid_show,\n\t.warn_no_listener = warn_no_idmapd,\n\t.match\t\t= nametoid_match,\n\t.init\t\t= ent_init,\n\t.update\t\t= ent_init,\n\t.alloc\t\t= ent_alloc,\n};\n\nstatic int\nnametoid_parse(struct cache_detail *cd, char *buf, int buflen)\n{\n\tstruct ent ent, *res;\n\tchar *buf1;\n\tint len, error = -EINVAL;\n\n\tif (buf[buflen - 1] != '\\n')\n\t\treturn (-EINVAL);\n\tbuf[buflen - 1]= '\\0';\n\n\tbuf1 = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (buf1 == NULL)\n\t\treturn (-ENOMEM);\n\n\tmemset(&ent, 0, sizeof(ent));\n\n\t \n\tlen = qword_get(&buf, buf1, PAGE_SIZE);\n\tif (len <= 0 || len >= IDMAP_NAMESZ)\n\t\tgoto out;\n\tmemcpy(ent.authname, buf1, sizeof(ent.authname));\n\n\t \n\tif (qword_get(&buf, buf1, PAGE_SIZE) <= 0)\n\t\tgoto out;\n\tent.type = strcmp(buf1, \"user\") == 0 ?\n\t\tIDMAP_TYPE_USER : IDMAP_TYPE_GROUP;\n\n\t \n\tlen = qword_get(&buf, buf1, PAGE_SIZE);\n\tif (len <= 0 || len >= IDMAP_NAMESZ)\n\t\tgoto out;\n\tmemcpy(ent.name, buf1, sizeof(ent.name));\n\n\t \n\terror = get_expiry(&buf, &ent.h.expiry_time);\n\tif (error)\n\t\tgoto out;\n\n\t \n\terror = get_int(&buf, &ent.id);\n\tif (error == -EINVAL)\n\t\tgoto out;\n\tif (error == -ENOENT)\n\t\tset_bit(CACHE_NEGATIVE, &ent.h.flags);\n\n\terror = -ENOMEM;\n\tres = nametoid_lookup(cd, &ent);\n\tif (res == NULL)\n\t\tgoto out;\n\tres = nametoid_update(cd, &ent, res);\n\tif (res == NULL)\n\t\tgoto out;\n\n\tcache_put(&res->h, cd);\n\terror = 0;\nout:\n\tkfree(buf1);\n\treturn (error);\n}\n\n\nstatic struct ent *\nnametoid_lookup(struct cache_detail *cd, struct ent *item)\n{\n\tstruct cache_head *ch = sunrpc_cache_lookup_rcu(cd, &item->h,\n\t\t\t\t\t\t\tnametoid_hash(item));\n\tif (ch)\n\t\treturn container_of(ch, struct ent, h);\n\telse\n\t\treturn NULL;\n}\n\nstatic struct ent *\nnametoid_update(struct cache_detail *cd, struct ent *new, struct ent *old)\n{\n\tstruct cache_head *ch = sunrpc_cache_update(cd, &new->h, &old->h,\n\t\t\t\t\t\t    nametoid_hash(new));\n\tif (ch)\n\t\treturn container_of(ch, struct ent, h);\n\telse\n\t\treturn NULL;\n}\n\n \n\nint\nnfsd_idmap_init(struct net *net)\n{\n\tint rv;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tnn->idtoname_cache = cache_create_net(&idtoname_cache_template, net);\n\tif (IS_ERR(nn->idtoname_cache))\n\t\treturn PTR_ERR(nn->idtoname_cache);\n\trv = cache_register_net(nn->idtoname_cache, net);\n\tif (rv)\n\t\tgoto destroy_idtoname_cache;\n\tnn->nametoid_cache = cache_create_net(&nametoid_cache_template, net);\n\tif (IS_ERR(nn->nametoid_cache)) {\n\t\trv = PTR_ERR(nn->nametoid_cache);\n\t\tgoto unregister_idtoname_cache;\n\t}\n\trv = cache_register_net(nn->nametoid_cache, net);\n\tif (rv)\n\t\tgoto destroy_nametoid_cache;\n\treturn 0;\n\ndestroy_nametoid_cache:\n\tcache_destroy_net(nn->nametoid_cache, net);\nunregister_idtoname_cache:\n\tcache_unregister_net(nn->idtoname_cache, net);\ndestroy_idtoname_cache:\n\tcache_destroy_net(nn->idtoname_cache, net);\n\treturn rv;\n}\n\nvoid\nnfsd_idmap_shutdown(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tcache_unregister_net(nn->idtoname_cache, net);\n\tcache_unregister_net(nn->nametoid_cache, net);\n\tcache_destroy_net(nn->idtoname_cache, net);\n\tcache_destroy_net(nn->nametoid_cache, net);\n}\n\nstatic int\nidmap_lookup(struct svc_rqst *rqstp,\n\t\tstruct ent *(*lookup_fn)(struct cache_detail *, struct ent *),\n\t\tstruct ent *key, struct cache_detail *detail, struct ent **item)\n{\n\tint ret;\n\n\t*item = lookup_fn(detail, key);\n\tif (!*item)\n\t\treturn -ENOMEM;\n retry:\n\tret = cache_check(detail, &(*item)->h, &rqstp->rq_chandle);\n\n\tif (ret == -ETIMEDOUT) {\n\t\tstruct ent *prev_item = *item;\n\t\t*item = lookup_fn(detail, key);\n\t\tif (*item != prev_item)\n\t\t\tgoto retry;\n\t\tcache_put(&(*item)->h, detail);\n\t}\n\treturn ret;\n}\n\nstatic char *\nrqst_authname(struct svc_rqst *rqstp)\n{\n\tstruct auth_domain *clp;\n\n\tclp = rqstp->rq_gssclient ? rqstp->rq_gssclient : rqstp->rq_client;\n\treturn clp->name;\n}\n\nstatic __be32\nidmap_name_to_id(struct svc_rqst *rqstp, int type, const char *name, u32 namelen,\n\t\tu32 *id)\n{\n\tstruct ent *item, key = {\n\t\t.type = type,\n\t};\n\tint ret;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tif (namelen + 1 > sizeof(key.name))\n\t\treturn nfserr_badowner;\n\tmemcpy(key.name, name, namelen);\n\tkey.name[namelen] = '\\0';\n\tstrscpy(key.authname, rqst_authname(rqstp), sizeof(key.authname));\n\tret = idmap_lookup(rqstp, nametoid_lookup, &key, nn->nametoid_cache, &item);\n\tif (ret == -ENOENT)\n\t\treturn nfserr_badowner;\n\tif (ret)\n\t\treturn nfserrno(ret);\n\t*id = item->id;\n\tcache_put(&item->h, nn->nametoid_cache);\n\treturn 0;\n}\n\nstatic __be32 encode_ascii_id(struct xdr_stream *xdr, u32 id)\n{\n\tchar buf[11];\n\tint len;\n\t__be32 *p;\n\n\tlen = sprintf(buf, \"%u\", id);\n\tp = xdr_reserve_space(xdr, len + 4);\n\tif (!p)\n\t\treturn nfserr_resource;\n\tp = xdr_encode_opaque(p, buf, len);\n\treturn 0;\n}\n\nstatic __be32 idmap_id_to_name(struct xdr_stream *xdr,\n\t\t\t       struct svc_rqst *rqstp, int type, u32 id)\n{\n\tstruct ent *item, key = {\n\t\t.id = id,\n\t\t.type = type,\n\t};\n\t__be32 *p;\n\tint ret;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tstrscpy(key.authname, rqst_authname(rqstp), sizeof(key.authname));\n\tret = idmap_lookup(rqstp, idtoname_lookup, &key, nn->idtoname_cache, &item);\n\tif (ret == -ENOENT)\n\t\treturn encode_ascii_id(xdr, id);\n\tif (ret)\n\t\treturn nfserrno(ret);\n\tret = strlen(item->name);\n\tWARN_ON_ONCE(ret > IDMAP_NAMESZ);\n\tp = xdr_reserve_space(xdr, ret + 4);\n\tif (!p)\n\t\treturn nfserr_resource;\n\tp = xdr_encode_opaque(p, item->name, ret);\n\tcache_put(&item->h, nn->idtoname_cache);\n\treturn 0;\n}\n\nstatic bool\nnumeric_name_to_id(struct svc_rqst *rqstp, int type, const char *name, u32 namelen, u32 *id)\n{\n\tint ret;\n\tchar buf[11];\n\n\tif (namelen + 1 > sizeof(buf))\n\t\t \n\t\treturn false;\n\t \n\tmemcpy(buf, name, namelen);\n\tbuf[namelen] = '\\0';\n\tret = kstrtouint(buf, 10, id);\n\treturn ret == 0;\n}\n\nstatic __be32\ndo_name_to_id(struct svc_rqst *rqstp, int type, const char *name, u32 namelen, u32 *id)\n{\n\tif (nfs4_disable_idmapping && rqstp->rq_cred.cr_flavor < RPC_AUTH_GSS)\n\t\tif (numeric_name_to_id(rqstp, type, name, namelen, id))\n\t\t\treturn 0;\n\t\t \n\treturn idmap_name_to_id(rqstp, type, name, namelen, id);\n}\n\nstatic __be32 encode_name_from_id(struct xdr_stream *xdr,\n\t\t\t\t  struct svc_rqst *rqstp, int type, u32 id)\n{\n\tif (nfs4_disable_idmapping && rqstp->rq_cred.cr_flavor < RPC_AUTH_GSS)\n\t\treturn encode_ascii_id(xdr, id);\n\treturn idmap_id_to_name(xdr, rqstp, type, id);\n}\n\n__be32\nnfsd_map_name_to_uid(struct svc_rqst *rqstp, const char *name, size_t namelen,\n\t\tkuid_t *uid)\n{\n\t__be32 status;\n\tu32 id = -1;\n\n\tif (name == NULL || namelen == 0)\n\t\treturn nfserr_inval;\n\n\tstatus = do_name_to_id(rqstp, IDMAP_TYPE_USER, name, namelen, &id);\n\t*uid = make_kuid(nfsd_user_namespace(rqstp), id);\n\tif (!uid_valid(*uid))\n\t\tstatus = nfserr_badowner;\n\treturn status;\n}\n\n__be32\nnfsd_map_name_to_gid(struct svc_rqst *rqstp, const char *name, size_t namelen,\n\t\tkgid_t *gid)\n{\n\t__be32 status;\n\tu32 id = -1;\n\n\tif (name == NULL || namelen == 0)\n\t\treturn nfserr_inval;\n\n\tstatus = do_name_to_id(rqstp, IDMAP_TYPE_GROUP, name, namelen, &id);\n\t*gid = make_kgid(nfsd_user_namespace(rqstp), id);\n\tif (!gid_valid(*gid))\n\t\tstatus = nfserr_badowner;\n\treturn status;\n}\n\n__be32 nfsd4_encode_user(struct xdr_stream *xdr, struct svc_rqst *rqstp,\n\t\t\t kuid_t uid)\n{\n\tu32 id = from_kuid_munged(nfsd_user_namespace(rqstp), uid);\n\treturn encode_name_from_id(xdr, rqstp, IDMAP_TYPE_USER, id);\n}\n\n__be32 nfsd4_encode_group(struct xdr_stream *xdr, struct svc_rqst *rqstp,\n\t\t\t  kgid_t gid)\n{\n\tu32 id = from_kgid_munged(nfsd_user_namespace(rqstp), gid);\n\treturn encode_name_from_id(xdr, rqstp, IDMAP_TYPE_GROUP, id);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}