{
  "module_name": "nfs4recover.c",
  "hash_id": "23511c870fa0c1fa8734306a357ffb20910484eaf236d8ab0d2ba99e26a98a90",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfsd/nfs4recover.c",
  "human_readable_source": " \n\n#include <crypto/hash.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <net/net_namespace.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/nfsd/cld.h>\n\n#include \"nfsd.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"netns.h\"\n\n#define NFSDDBG_FACILITY                NFSDDBG_PROC\n\n \nstruct nfsd4_client_tracking_ops {\n\tint (*init)(struct net *);\n\tvoid (*exit)(struct net *);\n\tvoid (*create)(struct nfs4_client *);\n\tvoid (*remove)(struct nfs4_client *);\n\tint (*check)(struct nfs4_client *);\n\tvoid (*grace_done)(struct nfsd_net *);\n\tuint8_t version;\n\tsize_t msglen;\n};\n\nstatic const struct nfsd4_client_tracking_ops nfsd4_cld_tracking_ops;\nstatic const struct nfsd4_client_tracking_ops nfsd4_cld_tracking_ops_v2;\n\n \nstatic char user_recovery_dirname[PATH_MAX] = \"/var/lib/nfs/v4recovery\";\n\nstatic int\nnfs4_save_creds(const struct cred **original_creds)\n{\n\tstruct cred *new;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tnew->fsuid = GLOBAL_ROOT_UID;\n\tnew->fsgid = GLOBAL_ROOT_GID;\n\t*original_creds = override_creds(new);\n\tput_cred(new);\n\treturn 0;\n}\n\nstatic void\nnfs4_reset_creds(const struct cred *original)\n{\n\trevert_creds(original);\n}\n\nstatic void\nmd5_to_hex(char *out, char *md5)\n{\n\tint i;\n\n\tfor (i=0; i<16; i++) {\n\t\tunsigned char c = md5[i];\n\n\t\t*out++ = '0' + ((c&0xf0)>>4) + (c>=0xa0)*('a'-'9'-1);\n\t\t*out++ = '0' + (c&0x0f) + ((c&0x0f)>=0x0a)*('a'-'9'-1);\n\t}\n\t*out = '\\0';\n}\n\nstatic int\nnfs4_make_rec_clidname(char *dname, const struct xdr_netobj *clname)\n{\n\tstruct xdr_netobj cksum;\n\tstruct crypto_shash *tfm;\n\tint status;\n\n\tdprintk(\"NFSD: nfs4_make_rec_clidname for %.*s\\n\",\n\t\t\tclname->len, clname->data);\n\ttfm = crypto_alloc_shash(\"md5\", 0, 0);\n\tif (IS_ERR(tfm)) {\n\t\tstatus = PTR_ERR(tfm);\n\t\tgoto out_no_tfm;\n\t}\n\n\tcksum.len = crypto_shash_digestsize(tfm);\n\tcksum.data = kmalloc(cksum.len, GFP_KERNEL);\n\tif (cksum.data == NULL) {\n\t\tstatus = -ENOMEM;\n \t\tgoto out;\n\t}\n\n\tstatus = crypto_shash_tfm_digest(tfm, clname->data, clname->len,\n\t\t\t\t\t cksum.data);\n\tif (status)\n\t\tgoto out;\n\n\tmd5_to_hex(dname, cksum.data);\n\n\tstatus = 0;\nout:\n\tkfree(cksum.data);\n\tcrypto_free_shash(tfm);\nout_no_tfm:\n\treturn status;\n}\n\n \nstatic void\nlegacy_recdir_name_error(struct nfs4_client *clp, int error)\n{\n\tprintk(KERN_ERR \"NFSD: unable to generate recoverydir \"\n\t\t\t\"name (%d).\\n\", error);\n\n\t \n\tif (error == -ENOENT) {\n\t\tprintk(KERN_ERR \"NFSD: disabling legacy clientid tracking. \"\n\t\t\t\"Reboot recovery will not function correctly!\\n\");\n\t\tnfsd4_client_tracking_exit(clp->net);\n\t}\n}\n\nstatic void\n__nfsd4_create_reclaim_record_grace(struct nfs4_client *clp,\n\t\tconst char *dname, int len, struct nfsd_net *nn)\n{\n\tstruct xdr_netobj name;\n\tstruct xdr_netobj princhash = { .len = 0, .data = NULL };\n\tstruct nfs4_client_reclaim *crp;\n\n\tname.data = kmemdup(dname, len, GFP_KERNEL);\n\tif (!name.data) {\n\t\tdprintk(\"%s: failed to allocate memory for name.data!\\n\",\n\t\t\t__func__);\n\t\treturn;\n\t}\n\tname.len = len;\n\tcrp = nfs4_client_to_reclaim(name, princhash, nn);\n\tif (!crp) {\n\t\tkfree(name.data);\n\t\treturn;\n\t}\n\tcrp->cr_clp = clp;\n}\n\nstatic void\nnfsd4_create_clid_dir(struct nfs4_client *clp)\n{\n\tconst struct cred *original_cred;\n\tchar dname[HEXDIR_LEN];\n\tstruct dentry *dir, *dentry;\n\tint status;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (test_and_set_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\n\t\treturn;\n\tif (!nn->rec_file)\n\t\treturn;\n\n\tstatus = nfs4_make_rec_clidname(dname, &clp->cl_name);\n\tif (status)\n\t\treturn legacy_recdir_name_error(clp, status);\n\n\tstatus = nfs4_save_creds(&original_cred);\n\tif (status < 0)\n\t\treturn;\n\n\tstatus = mnt_want_write_file(nn->rec_file);\n\tif (status)\n\t\tgoto out_creds;\n\n\tdir = nn->rec_file->f_path.dentry;\n\t \n\tinode_lock(d_inode(dir));\n\n\tdentry = lookup_one_len(dname, dir, HEXDIR_LEN-1);\n\tif (IS_ERR(dentry)) {\n\t\tstatus = PTR_ERR(dentry);\n\t\tgoto out_unlock;\n\t}\n\tif (d_really_is_positive(dentry))\n\t\t \n\t\tgoto out_put;\n\tstatus = vfs_mkdir(&nop_mnt_idmap, d_inode(dir), dentry, S_IRWXU);\nout_put:\n\tdput(dentry);\nout_unlock:\n\tinode_unlock(d_inode(dir));\n\tif (status == 0) {\n\t\tif (nn->in_grace)\n\t\t\t__nfsd4_create_reclaim_record_grace(clp, dname,\n\t\t\t\t\tHEXDIR_LEN, nn);\n\t\tvfs_fsync(nn->rec_file, 0);\n\t} else {\n\t\tprintk(KERN_ERR \"NFSD: failed to write recovery record\"\n\t\t\t\t\" (err %d); please check that %s exists\"\n\t\t\t\t\" and is writeable\", status,\n\t\t\t\tuser_recovery_dirname);\n\t}\n\tmnt_drop_write_file(nn->rec_file);\nout_creds:\n\tnfs4_reset_creds(original_cred);\n}\n\ntypedef int (recdir_func)(struct dentry *, struct dentry *, struct nfsd_net *);\n\nstruct name_list {\n\tchar name[HEXDIR_LEN];\n\tstruct list_head list;\n};\n\nstruct nfs4_dir_ctx {\n\tstruct dir_context ctx;\n\tstruct list_head names;\n};\n\nstatic bool\nnfsd4_build_namelist(struct dir_context *__ctx, const char *name, int namlen,\n\t\tloff_t offset, u64 ino, unsigned int d_type)\n{\n\tstruct nfs4_dir_ctx *ctx =\n\t\tcontainer_of(__ctx, struct nfs4_dir_ctx, ctx);\n\tstruct name_list *entry;\n\n\tif (namlen != HEXDIR_LEN - 1)\n\t\treturn true;\n\tentry = kmalloc(sizeof(struct name_list), GFP_KERNEL);\n\tif (entry == NULL)\n\t\treturn false;\n\tmemcpy(entry->name, name, HEXDIR_LEN - 1);\n\tentry->name[HEXDIR_LEN - 1] = '\\0';\n\tlist_add(&entry->list, &ctx->names);\n\treturn true;\n}\n\nstatic int\nnfsd4_list_rec_dir(recdir_func *f, struct nfsd_net *nn)\n{\n\tconst struct cred *original_cred;\n\tstruct dentry *dir = nn->rec_file->f_path.dentry;\n\tstruct nfs4_dir_ctx ctx = {\n\t\t.ctx.actor = nfsd4_build_namelist,\n\t\t.names = LIST_HEAD_INIT(ctx.names)\n\t};\n\tstruct name_list *entry, *tmp;\n\tint status;\n\n\tstatus = nfs4_save_creds(&original_cred);\n\tif (status < 0)\n\t\treturn status;\n\n\tstatus = vfs_llseek(nn->rec_file, 0, SEEK_SET);\n\tif (status < 0) {\n\t\tnfs4_reset_creds(original_cred);\n\t\treturn status;\n\t}\n\n\tstatus = iterate_dir(nn->rec_file, &ctx.ctx);\n\tinode_lock_nested(d_inode(dir), I_MUTEX_PARENT);\n\n\tlist_for_each_entry_safe(entry, tmp, &ctx.names, list) {\n\t\tif (!status) {\n\t\t\tstruct dentry *dentry;\n\t\t\tdentry = lookup_one_len(entry->name, dir, HEXDIR_LEN-1);\n\t\t\tif (IS_ERR(dentry)) {\n\t\t\t\tstatus = PTR_ERR(dentry);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstatus = f(dir, dentry, nn);\n\t\t\tdput(dentry);\n\t\t}\n\t\tlist_del(&entry->list);\n\t\tkfree(entry);\n\t}\n\tinode_unlock(d_inode(dir));\n\tnfs4_reset_creds(original_cred);\n\n\tlist_for_each_entry_safe(entry, tmp, &ctx.names, list) {\n\t\tdprintk(\"NFSD: %s. Left entry %s\\n\", __func__, entry->name);\n\t\tlist_del(&entry->list);\n\t\tkfree(entry);\n\t}\n\treturn status;\n}\n\nstatic int\nnfsd4_unlink_clid_dir(char *name, int namlen, struct nfsd_net *nn)\n{\n\tstruct dentry *dir, *dentry;\n\tint status;\n\n\tdprintk(\"NFSD: nfsd4_unlink_clid_dir. name %.*s\\n\", namlen, name);\n\n\tdir = nn->rec_file->f_path.dentry;\n\tinode_lock_nested(d_inode(dir), I_MUTEX_PARENT);\n\tdentry = lookup_one_len(name, dir, namlen);\n\tif (IS_ERR(dentry)) {\n\t\tstatus = PTR_ERR(dentry);\n\t\tgoto out_unlock;\n\t}\n\tstatus = -ENOENT;\n\tif (d_really_is_negative(dentry))\n\t\tgoto out;\n\tstatus = vfs_rmdir(&nop_mnt_idmap, d_inode(dir), dentry);\nout:\n\tdput(dentry);\nout_unlock:\n\tinode_unlock(d_inode(dir));\n\treturn status;\n}\n\nstatic void\n__nfsd4_remove_reclaim_record_grace(const char *dname, int len,\n\t\tstruct nfsd_net *nn)\n{\n\tstruct xdr_netobj name;\n\tstruct nfs4_client_reclaim *crp;\n\n\tname.data = kmemdup(dname, len, GFP_KERNEL);\n\tif (!name.data) {\n\t\tdprintk(\"%s: failed to allocate memory for name.data!\\n\",\n\t\t\t__func__);\n\t\treturn;\n\t}\n\tname.len = len;\n\tcrp = nfsd4_find_reclaim_client(name, nn);\n\tkfree(name.data);\n\tif (crp)\n\t\tnfs4_remove_reclaim_record(crp, nn);\n}\n\nstatic void\nnfsd4_remove_clid_dir(struct nfs4_client *clp)\n{\n\tconst struct cred *original_cred;\n\tchar dname[HEXDIR_LEN];\n\tint status;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (!nn->rec_file || !test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\n\t\treturn;\n\n\tstatus = nfs4_make_rec_clidname(dname, &clp->cl_name);\n\tif (status)\n\t\treturn legacy_recdir_name_error(clp, status);\n\n\tstatus = mnt_want_write_file(nn->rec_file);\n\tif (status)\n\t\tgoto out;\n\tclear_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags);\n\n\tstatus = nfs4_save_creds(&original_cred);\n\tif (status < 0)\n\t\tgoto out_drop_write;\n\n\tstatus = nfsd4_unlink_clid_dir(dname, HEXDIR_LEN-1, nn);\n\tnfs4_reset_creds(original_cred);\n\tif (status == 0) {\n\t\tvfs_fsync(nn->rec_file, 0);\n\t\tif (nn->in_grace)\n\t\t\t__nfsd4_remove_reclaim_record_grace(dname,\n\t\t\t\t\tHEXDIR_LEN, nn);\n\t}\nout_drop_write:\n\tmnt_drop_write_file(nn->rec_file);\nout:\n\tif (status)\n\t\tprintk(\"NFSD: Failed to remove expired client state directory\"\n\t\t\t\t\" %.*s\\n\", HEXDIR_LEN, dname);\n}\n\nstatic int\npurge_old(struct dentry *parent, struct dentry *child, struct nfsd_net *nn)\n{\n\tint status;\n\tstruct xdr_netobj name;\n\n\tif (child->d_name.len != HEXDIR_LEN - 1) {\n\t\tprintk(\"%s: illegal name %pd in recovery directory\\n\",\n\t\t\t\t__func__, child);\n\t\t \n\t\treturn 0;\n\t}\n\tname.data = kmemdup_nul(child->d_name.name, child->d_name.len, GFP_KERNEL);\n\tif (!name.data) {\n\t\tdprintk(\"%s: failed to allocate memory for name.data!\\n\",\n\t\t\t__func__);\n\t\tgoto out;\n\t}\n\tname.len = HEXDIR_LEN;\n\tif (nfs4_has_reclaimed_state(name, nn))\n\t\tgoto out_free;\n\n\tstatus = vfs_rmdir(&nop_mnt_idmap, d_inode(parent), child);\n\tif (status)\n\t\tprintk(\"failed to remove client recovery directory %pd\\n\",\n\t\t\t\tchild);\nout_free:\n\tkfree(name.data);\nout:\n\t \n\treturn 0;\n}\n\nstatic void\nnfsd4_recdir_purge_old(struct nfsd_net *nn)\n{\n\tint status;\n\n\tnn->in_grace = false;\n\tif (!nn->rec_file)\n\t\treturn;\n\tstatus = mnt_want_write_file(nn->rec_file);\n\tif (status)\n\t\tgoto out;\n\tstatus = nfsd4_list_rec_dir(purge_old, nn);\n\tif (status == 0)\n\t\tvfs_fsync(nn->rec_file, 0);\n\tmnt_drop_write_file(nn->rec_file);\nout:\n\tnfs4_release_reclaim(nn);\n\tif (status)\n\t\tprintk(\"nfsd4: failed to purge old clients from recovery\"\n\t\t\t\" directory %pD\\n\", nn->rec_file);\n}\n\nstatic int\nload_recdir(struct dentry *parent, struct dentry *child, struct nfsd_net *nn)\n{\n\tstruct xdr_netobj name;\n\tstruct xdr_netobj princhash = { .len = 0, .data = NULL };\n\n\tif (child->d_name.len != HEXDIR_LEN - 1) {\n\t\tprintk(\"%s: illegal name %pd in recovery directory\\n\",\n\t\t\t\t__func__, child);\n\t\t \n\t\treturn 0;\n\t}\n\tname.data = kmemdup_nul(child->d_name.name, child->d_name.len, GFP_KERNEL);\n\tif (!name.data) {\n\t\tdprintk(\"%s: failed to allocate memory for name.data!\\n\",\n\t\t\t__func__);\n\t\tgoto out;\n\t}\n\tname.len = HEXDIR_LEN;\n\tif (!nfs4_client_to_reclaim(name, princhash, nn))\n\t\tkfree(name.data);\nout:\n\treturn 0;\n}\n\nstatic int\nnfsd4_recdir_load(struct net *net) {\n\tint status;\n\tstruct nfsd_net *nn =  net_generic(net, nfsd_net_id);\n\n\tif (!nn->rec_file)\n\t\treturn 0;\n\n\tstatus = nfsd4_list_rec_dir(load_recdir, nn);\n\tif (status)\n\t\tprintk(\"nfsd4: failed loading clients from recovery\"\n\t\t\t\" directory %pD\\n\", nn->rec_file);\n\treturn status;\n}\n\n \n\nstatic int\nnfsd4_init_recdir(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tconst struct cred *original_cred;\n\tint status;\n\n\tprintk(\"NFSD: Using %s as the NFSv4 state recovery directory\\n\",\n\t\t\tuser_recovery_dirname);\n\n\tBUG_ON(nn->rec_file);\n\n\tstatus = nfs4_save_creds(&original_cred);\n\tif (status < 0) {\n\t\tprintk(\"NFSD: Unable to change credentials to find recovery\"\n\t\t       \" directory: error %d\\n\",\n\t\t       status);\n\t\treturn status;\n\t}\n\n\tnn->rec_file = filp_open(user_recovery_dirname, O_RDONLY | O_DIRECTORY, 0);\n\tif (IS_ERR(nn->rec_file)) {\n\t\tprintk(\"NFSD: unable to find recovery directory %s\\n\",\n\t\t\t\tuser_recovery_dirname);\n\t\tstatus = PTR_ERR(nn->rec_file);\n\t\tnn->rec_file = NULL;\n\t}\n\n\tnfs4_reset_creds(original_cred);\n\tif (!status)\n\t\tnn->in_grace = true;\n\treturn status;\n}\n\nstatic void\nnfsd4_shutdown_recdir(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (!nn->rec_file)\n\t\treturn;\n\tfput(nn->rec_file);\n\tnn->rec_file = NULL;\n}\n\nstatic int\nnfs4_legacy_state_init(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint i;\n\n\tnn->reclaim_str_hashtbl = kmalloc_array(CLIENT_HASH_SIZE,\n\t\t\t\t\t\tsizeof(struct list_head),\n\t\t\t\t\t\tGFP_KERNEL);\n\tif (!nn->reclaim_str_hashtbl)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < CLIENT_HASH_SIZE; i++)\n\t\tINIT_LIST_HEAD(&nn->reclaim_str_hashtbl[i]);\n\tnn->reclaim_str_hashtbl_size = 0;\n\n\treturn 0;\n}\n\nstatic void\nnfs4_legacy_state_shutdown(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tkfree(nn->reclaim_str_hashtbl);\n}\n\nstatic int\nnfsd4_load_reboot_recovery_data(struct net *net)\n{\n\tint status;\n\n\tstatus = nfsd4_init_recdir(net);\n\tif (status)\n\t\treturn status;\n\n\tstatus = nfsd4_recdir_load(net);\n\tif (status)\n\t\tnfsd4_shutdown_recdir(net);\n\n\treturn status;\n}\n\nstatic int\nnfsd4_legacy_tracking_init(struct net *net)\n{\n\tint status;\n\n\t \n\tif (net != &init_net) {\n\t\tpr_warn(\"NFSD: attempt to initialize legacy client tracking in a container ignored.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tstatus = nfs4_legacy_state_init(net);\n\tif (status)\n\t\treturn status;\n\n\tstatus = nfsd4_load_reboot_recovery_data(net);\n\tif (status)\n\t\tgoto err;\n\tpr_info(\"NFSD: Using legacy client tracking operations.\\n\");\n\treturn 0;\n\nerr:\n\tnfs4_legacy_state_shutdown(net);\n\treturn status;\n}\n\nstatic void\nnfsd4_legacy_tracking_exit(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tnfs4_release_reclaim(nn);\n\tnfsd4_shutdown_recdir(net);\n\tnfs4_legacy_state_shutdown(net);\n}\n\n \nint\nnfs4_reset_recoverydir(char *recdir)\n{\n\tint status;\n\tstruct path path;\n\n\tstatus = kern_path(recdir, LOOKUP_FOLLOW, &path);\n\tif (status)\n\t\treturn status;\n\tstatus = -ENOTDIR;\n\tif (d_is_dir(path.dentry)) {\n\t\tstrcpy(user_recovery_dirname, recdir);\n\t\tstatus = 0;\n\t}\n\tpath_put(&path);\n\treturn status;\n}\n\nchar *\nnfs4_recoverydir(void)\n{\n\treturn user_recovery_dirname;\n}\n\nstatic int\nnfsd4_check_legacy_client(struct nfs4_client *clp)\n{\n\tint status;\n\tchar dname[HEXDIR_LEN];\n\tstruct nfs4_client_reclaim *crp;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\tstruct xdr_netobj name;\n\n\t \n\tif (test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\n\t\treturn 0;\n\n\tstatus = nfs4_make_rec_clidname(dname, &clp->cl_name);\n\tif (status) {\n\t\tlegacy_recdir_name_error(clp, status);\n\t\treturn status;\n\t}\n\n\t \n\tname.data = kmemdup(dname, HEXDIR_LEN, GFP_KERNEL);\n\tif (!name.data) {\n\t\tdprintk(\"%s: failed to allocate memory for name.data!\\n\",\n\t\t\t__func__);\n\t\tgoto out_enoent;\n\t}\n\tname.len = HEXDIR_LEN;\n\tcrp = nfsd4_find_reclaim_client(name, nn);\n\tkfree(name.data);\n\tif (crp) {\n\t\tset_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags);\n\t\tcrp->cr_clp = clp;\n\t\treturn 0;\n\t}\n\nout_enoent:\n\treturn -ENOENT;\n}\n\nstatic const struct nfsd4_client_tracking_ops nfsd4_legacy_tracking_ops = {\n\t.init\t\t= nfsd4_legacy_tracking_init,\n\t.exit\t\t= nfsd4_legacy_tracking_exit,\n\t.create\t\t= nfsd4_create_clid_dir,\n\t.remove\t\t= nfsd4_remove_clid_dir,\n\t.check\t\t= nfsd4_check_legacy_client,\n\t.grace_done\t= nfsd4_recdir_purge_old,\n\t.version\t= 1,\n\t.msglen\t\t= 0,\n};\n\n \n#define NFSD_PIPE_DIR\t\t\"nfsd\"\n#define NFSD_CLD_PIPE\t\t\"cld\"\n\n \nstruct cld_net {\n\tstruct rpc_pipe\t\t*cn_pipe;\n\tspinlock_t\t\t cn_lock;\n\tstruct list_head\t cn_list;\n\tunsigned int\t\t cn_xid;\n\tbool\t\t\t cn_has_legacy;\n\tstruct crypto_shash\t*cn_tfm;\n};\n\nstruct cld_upcall {\n\tstruct list_head\t cu_list;\n\tstruct cld_net\t\t*cu_net;\n\tstruct completion\t cu_done;\n\tunion {\n\t\tstruct cld_msg_hdr\t cu_hdr;\n\t\tstruct cld_msg\t\t cu_msg;\n\t\tstruct cld_msg_v2\t cu_msg_v2;\n\t} cu_u;\n};\n\nstatic int\n__cld_pipe_upcall(struct rpc_pipe *pipe, void *cmsg, struct nfsd_net *nn)\n{\n\tint ret;\n\tstruct rpc_pipe_msg msg;\n\tstruct cld_upcall *cup = container_of(cmsg, struct cld_upcall, cu_u);\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.data = cmsg;\n\tmsg.len = nn->client_tracking_ops->msglen;\n\n\tret = rpc_queue_upcall(pipe, &msg);\n\tif (ret < 0) {\n\t\tgoto out;\n\t}\n\n\twait_for_completion(&cup->cu_done);\n\n\tif (msg.errno < 0)\n\t\tret = msg.errno;\nout:\n\treturn ret;\n}\n\nstatic int\ncld_pipe_upcall(struct rpc_pipe *pipe, void *cmsg, struct nfsd_net *nn)\n{\n\tint ret;\n\n\t \n\tdo {\n\t\tret = __cld_pipe_upcall(pipe, cmsg, nn);\n\t} while (ret == -EAGAIN);\n\n\treturn ret;\n}\n\nstatic ssize_t\n__cld_pipe_inprogress_downcall(const struct cld_msg_v2 __user *cmsg,\n\t\tstruct nfsd_net *nn)\n{\n\tuint8_t cmd, princhashlen;\n\tstruct xdr_netobj name, princhash = { .len = 0, .data = NULL };\n\tuint16_t namelen;\n\tstruct cld_net *cn = nn->cld_net;\n\n\tif (get_user(cmd, &cmsg->cm_cmd)) {\n\t\tdprintk(\"%s: error when copying cmd from userspace\", __func__);\n\t\treturn -EFAULT;\n\t}\n\tif (cmd == Cld_GraceStart) {\n\t\tif (nn->client_tracking_ops->version >= 2) {\n\t\t\tconst struct cld_clntinfo __user *ci;\n\n\t\t\tci = &cmsg->cm_u.cm_clntinfo;\n\t\t\tif (get_user(namelen, &ci->cc_name.cn_len))\n\t\t\t\treturn -EFAULT;\n\t\t\tname.data = memdup_user(&ci->cc_name.cn_id, namelen);\n\t\t\tif (IS_ERR(name.data))\n\t\t\t\treturn PTR_ERR(name.data);\n\t\t\tname.len = namelen;\n\t\t\tget_user(princhashlen, &ci->cc_princhash.cp_len);\n\t\t\tif (princhashlen > 0) {\n\t\t\t\tprinchash.data = memdup_user(\n\t\t\t\t\t\t&ci->cc_princhash.cp_data,\n\t\t\t\t\t\tprinchashlen);\n\t\t\t\tif (IS_ERR(princhash.data)) {\n\t\t\t\t\tkfree(name.data);\n\t\t\t\t\treturn PTR_ERR(princhash.data);\n\t\t\t\t}\n\t\t\t\tprinchash.len = princhashlen;\n\t\t\t} else\n\t\t\t\tprinchash.len = 0;\n\t\t} else {\n\t\t\tconst struct cld_name __user *cnm;\n\n\t\t\tcnm = &cmsg->cm_u.cm_name;\n\t\t\tif (get_user(namelen, &cnm->cn_len))\n\t\t\t\treturn -EFAULT;\n\t\t\tname.data = memdup_user(&cnm->cn_id, namelen);\n\t\t\tif (IS_ERR(name.data))\n\t\t\t\treturn PTR_ERR(name.data);\n\t\t\tname.len = namelen;\n\t\t}\n\t\tif (name.len > 5 && memcmp(name.data, \"hash:\", 5) == 0) {\n\t\t\tname.len = name.len - 5;\n\t\t\tmemmove(name.data, name.data + 5, name.len);\n\t\t\tcn->cn_has_legacy = true;\n\t\t}\n\t\tif (!nfs4_client_to_reclaim(name, princhash, nn)) {\n\t\t\tkfree(name.data);\n\t\t\tkfree(princhash.data);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\treturn nn->client_tracking_ops->msglen;\n\t}\n\treturn -EFAULT;\n}\n\nstatic ssize_t\ncld_pipe_downcall(struct file *filp, const char __user *src, size_t mlen)\n{\n\tstruct cld_upcall *tmp, *cup;\n\tstruct cld_msg_hdr __user *hdr = (struct cld_msg_hdr __user *)src;\n\tstruct cld_msg_v2 __user *cmsg = (struct cld_msg_v2 __user *)src;\n\tuint32_t xid;\n\tstruct nfsd_net *nn = net_generic(file_inode(filp)->i_sb->s_fs_info,\n\t\t\t\t\t\tnfsd_net_id);\n\tstruct cld_net *cn = nn->cld_net;\n\tint16_t status;\n\n\tif (mlen != nn->client_tracking_ops->msglen) {\n\t\tdprintk(\"%s: got %zu bytes, expected %zu\\n\", __func__, mlen,\n\t\t\tnn->client_tracking_ops->msglen);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (copy_from_user(&xid, &hdr->cm_xid, sizeof(xid)) != 0) {\n\t\tdprintk(\"%s: error when copying xid from userspace\", __func__);\n\t\treturn -EFAULT;\n\t}\n\n\t \n\tif (get_user(status, &hdr->cm_status)) {\n\t\tdprintk(\"%s: error when copying status from userspace\", __func__);\n\t\treturn -EFAULT;\n\t}\n\n\t \n\tcup = NULL;\n\tspin_lock(&cn->cn_lock);\n\tlist_for_each_entry(tmp, &cn->cn_list, cu_list) {\n\t\tif (get_unaligned(&tmp->cu_u.cu_hdr.cm_xid) == xid) {\n\t\t\tcup = tmp;\n\t\t\tif (status != -EINPROGRESS)\n\t\t\t\tlist_del_init(&cup->cu_list);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&cn->cn_lock);\n\n\t \n\tif (!cup) {\n\t\tdprintk(\"%s: couldn't find upcall -- xid=%u\\n\", __func__, xid);\n\t\treturn -EINVAL;\n\t}\n\n\tif (status == -EINPROGRESS)\n\t\treturn __cld_pipe_inprogress_downcall(cmsg, nn);\n\n\tif (copy_from_user(&cup->cu_u.cu_msg_v2, src, mlen) != 0)\n\t\treturn -EFAULT;\n\n\tcomplete(&cup->cu_done);\n\treturn mlen;\n}\n\nstatic void\ncld_pipe_destroy_msg(struct rpc_pipe_msg *msg)\n{\n\tstruct cld_msg *cmsg = msg->data;\n\tstruct cld_upcall *cup = container_of(cmsg, struct cld_upcall,\n\t\t\t\t\t\t cu_u.cu_msg);\n\n\t \n\tif (msg->errno >= 0)\n\t\treturn;\n\n\tcomplete(&cup->cu_done);\n}\n\nstatic const struct rpc_pipe_ops cld_upcall_ops = {\n\t.upcall\t\t= rpc_pipe_generic_upcall,\n\t.downcall\t= cld_pipe_downcall,\n\t.destroy_msg\t= cld_pipe_destroy_msg,\n};\n\nstatic struct dentry *\nnfsd4_cld_register_sb(struct super_block *sb, struct rpc_pipe *pipe)\n{\n\tstruct dentry *dir, *dentry;\n\n\tdir = rpc_d_lookup_sb(sb, NFSD_PIPE_DIR);\n\tif (dir == NULL)\n\t\treturn ERR_PTR(-ENOENT);\n\tdentry = rpc_mkpipe_dentry(dir, NFSD_CLD_PIPE, NULL, pipe);\n\tdput(dir);\n\treturn dentry;\n}\n\nstatic void\nnfsd4_cld_unregister_sb(struct rpc_pipe *pipe)\n{\n\tif (pipe->dentry)\n\t\trpc_unlink(pipe->dentry);\n}\n\nstatic struct dentry *\nnfsd4_cld_register_net(struct net *net, struct rpc_pipe *pipe)\n{\n\tstruct super_block *sb;\n\tstruct dentry *dentry;\n\n\tsb = rpc_get_sb_net(net);\n\tif (!sb)\n\t\treturn NULL;\n\tdentry = nfsd4_cld_register_sb(sb, pipe);\n\trpc_put_sb_net(net);\n\treturn dentry;\n}\n\nstatic void\nnfsd4_cld_unregister_net(struct net *net, struct rpc_pipe *pipe)\n{\n\tstruct super_block *sb;\n\n\tsb = rpc_get_sb_net(net);\n\tif (sb) {\n\t\tnfsd4_cld_unregister_sb(pipe);\n\t\trpc_put_sb_net(net);\n\t}\n}\n\n \nstatic int\n__nfsd4_init_cld_pipe(struct net *net)\n{\n\tint ret;\n\tstruct dentry *dentry;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tstruct cld_net *cn;\n\n\tif (nn->cld_net)\n\t\treturn 0;\n\n\tcn = kzalloc(sizeof(*cn), GFP_KERNEL);\n\tif (!cn) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tcn->cn_pipe = rpc_mkpipe_data(&cld_upcall_ops, RPC_PIPE_WAIT_FOR_OPEN);\n\tif (IS_ERR(cn->cn_pipe)) {\n\t\tret = PTR_ERR(cn->cn_pipe);\n\t\tgoto err;\n\t}\n\tspin_lock_init(&cn->cn_lock);\n\tINIT_LIST_HEAD(&cn->cn_list);\n\n\tdentry = nfsd4_cld_register_net(net, cn->cn_pipe);\n\tif (IS_ERR(dentry)) {\n\t\tret = PTR_ERR(dentry);\n\t\tgoto err_destroy_data;\n\t}\n\n\tcn->cn_pipe->dentry = dentry;\n\tcn->cn_has_legacy = false;\n\tnn->cld_net = cn;\n\treturn 0;\n\nerr_destroy_data:\n\trpc_destroy_pipe_data(cn->cn_pipe);\nerr:\n\tkfree(cn);\n\tprintk(KERN_ERR \"NFSD: unable to create nfsdcld upcall pipe (%d)\\n\",\n\t\t\tret);\n\treturn ret;\n}\n\nstatic int\nnfsd4_init_cld_pipe(struct net *net)\n{\n\tint status;\n\n\tstatus = __nfsd4_init_cld_pipe(net);\n\tif (!status)\n\t\tpr_info(\"NFSD: Using old nfsdcld client tracking operations.\\n\");\n\treturn status;\n}\n\nstatic void\nnfsd4_remove_cld_pipe(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tstruct cld_net *cn = nn->cld_net;\n\n\tnfsd4_cld_unregister_net(net, cn->cn_pipe);\n\trpc_destroy_pipe_data(cn->cn_pipe);\n\tif (cn->cn_tfm)\n\t\tcrypto_free_shash(cn->cn_tfm);\n\tkfree(nn->cld_net);\n\tnn->cld_net = NULL;\n}\n\nstatic struct cld_upcall *\nalloc_cld_upcall(struct nfsd_net *nn)\n{\n\tstruct cld_upcall *new, *tmp;\n\tstruct cld_net *cn = nn->cld_net;\n\n\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\tif (!new)\n\t\treturn new;\n\n\t \nrestart_search:\n\tspin_lock(&cn->cn_lock);\n\tlist_for_each_entry(tmp, &cn->cn_list, cu_list) {\n\t\tif (tmp->cu_u.cu_msg.cm_xid == cn->cn_xid) {\n\t\t\tcn->cn_xid++;\n\t\t\tspin_unlock(&cn->cn_lock);\n\t\t\tgoto restart_search;\n\t\t}\n\t}\n\tinit_completion(&new->cu_done);\n\tnew->cu_u.cu_msg.cm_vers = nn->client_tracking_ops->version;\n\tput_unaligned(cn->cn_xid++, &new->cu_u.cu_msg.cm_xid);\n\tnew->cu_net = cn;\n\tlist_add(&new->cu_list, &cn->cn_list);\n\tspin_unlock(&cn->cn_lock);\n\n\tdprintk(\"%s: allocated xid %u\\n\", __func__, new->cu_u.cu_msg.cm_xid);\n\n\treturn new;\n}\n\nstatic void\nfree_cld_upcall(struct cld_upcall *victim)\n{\n\tstruct cld_net *cn = victim->cu_net;\n\n\tspin_lock(&cn->cn_lock);\n\tlist_del(&victim->cu_list);\n\tspin_unlock(&cn->cn_lock);\n\tkfree(victim);\n}\n\n \nstatic void\nnfsd4_cld_create(struct nfs4_client *clp)\n{\n\tint ret;\n\tstruct cld_upcall *cup;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\tstruct cld_net *cn = nn->cld_net;\n\n\t \n\tif (test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\n\t\treturn;\n\n\tcup = alloc_cld_upcall(nn);\n\tif (!cup) {\n\t\tret = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\tcup->cu_u.cu_msg.cm_cmd = Cld_Create;\n\tcup->cu_u.cu_msg.cm_u.cm_name.cn_len = clp->cl_name.len;\n\tmemcpy(cup->cu_u.cu_msg.cm_u.cm_name.cn_id, clp->cl_name.data,\n\t\t\tclp->cl_name.len);\n\n\tret = cld_pipe_upcall(cn->cn_pipe, &cup->cu_u.cu_msg, nn);\n\tif (!ret) {\n\t\tret = cup->cu_u.cu_msg.cm_status;\n\t\tset_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags);\n\t}\n\n\tfree_cld_upcall(cup);\nout_err:\n\tif (ret)\n\t\tprintk(KERN_ERR \"NFSD: Unable to create client \"\n\t\t\t\t\"record on stable storage: %d\\n\", ret);\n}\n\n \nstatic void\nnfsd4_cld_create_v2(struct nfs4_client *clp)\n{\n\tint ret;\n\tstruct cld_upcall *cup;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\tstruct cld_net *cn = nn->cld_net;\n\tstruct cld_msg_v2 *cmsg;\n\tstruct crypto_shash *tfm = cn->cn_tfm;\n\tstruct xdr_netobj cksum;\n\tchar *principal = NULL;\n\n\t \n\tif (test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\n\t\treturn;\n\n\tcup = alloc_cld_upcall(nn);\n\tif (!cup) {\n\t\tret = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\tcmsg = &cup->cu_u.cu_msg_v2;\n\tcmsg->cm_cmd = Cld_Create;\n\tcmsg->cm_u.cm_clntinfo.cc_name.cn_len = clp->cl_name.len;\n\tmemcpy(cmsg->cm_u.cm_clntinfo.cc_name.cn_id, clp->cl_name.data,\n\t\t\tclp->cl_name.len);\n\tif (clp->cl_cred.cr_raw_principal)\n\t\tprincipal = clp->cl_cred.cr_raw_principal;\n\telse if (clp->cl_cred.cr_principal)\n\t\tprincipal = clp->cl_cred.cr_principal;\n\tif (principal) {\n\t\tcksum.len = crypto_shash_digestsize(tfm);\n\t\tcksum.data = kmalloc(cksum.len, GFP_KERNEL);\n\t\tif (cksum.data == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = crypto_shash_tfm_digest(tfm, principal, strlen(principal),\n\t\t\t\t\t      cksum.data);\n\t\tif (ret) {\n\t\t\tkfree(cksum.data);\n\t\t\tgoto out;\n\t\t}\n\t\tcmsg->cm_u.cm_clntinfo.cc_princhash.cp_len = cksum.len;\n\t\tmemcpy(cmsg->cm_u.cm_clntinfo.cc_princhash.cp_data,\n\t\t       cksum.data, cksum.len);\n\t\tkfree(cksum.data);\n\t} else\n\t\tcmsg->cm_u.cm_clntinfo.cc_princhash.cp_len = 0;\n\n\tret = cld_pipe_upcall(cn->cn_pipe, cmsg, nn);\n\tif (!ret) {\n\t\tret = cmsg->cm_status;\n\t\tset_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags);\n\t}\n\nout:\n\tfree_cld_upcall(cup);\nout_err:\n\tif (ret)\n\t\tpr_err(\"NFSD: Unable to create client record on stable storage: %d\\n\",\n\t\t\t\tret);\n}\n\n \nstatic void\nnfsd4_cld_remove(struct nfs4_client *clp)\n{\n\tint ret;\n\tstruct cld_upcall *cup;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\tstruct cld_net *cn = nn->cld_net;\n\n\t \n\tif (!test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\n\t\treturn;\n\n\tcup = alloc_cld_upcall(nn);\n\tif (!cup) {\n\t\tret = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\tcup->cu_u.cu_msg.cm_cmd = Cld_Remove;\n\tcup->cu_u.cu_msg.cm_u.cm_name.cn_len = clp->cl_name.len;\n\tmemcpy(cup->cu_u.cu_msg.cm_u.cm_name.cn_id, clp->cl_name.data,\n\t\t\tclp->cl_name.len);\n\n\tret = cld_pipe_upcall(cn->cn_pipe, &cup->cu_u.cu_msg, nn);\n\tif (!ret) {\n\t\tret = cup->cu_u.cu_msg.cm_status;\n\t\tclear_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags);\n\t}\n\n\tfree_cld_upcall(cup);\nout_err:\n\tif (ret)\n\t\tprintk(KERN_ERR \"NFSD: Unable to remove client \"\n\t\t\t\t\"record from stable storage: %d\\n\", ret);\n}\n\n \nstatic int\nnfsd4_cld_check_v0(struct nfs4_client *clp)\n{\n\tint ret;\n\tstruct cld_upcall *cup;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\tstruct cld_net *cn = nn->cld_net;\n\n\t \n\tif (test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\n\t\treturn 0;\n\n\tcup = alloc_cld_upcall(nn);\n\tif (!cup) {\n\t\tprintk(KERN_ERR \"NFSD: Unable to check client record on \"\n\t\t\t\t\"stable storage: %d\\n\", -ENOMEM);\n\t\treturn -ENOMEM;\n\t}\n\n\tcup->cu_u.cu_msg.cm_cmd = Cld_Check;\n\tcup->cu_u.cu_msg.cm_u.cm_name.cn_len = clp->cl_name.len;\n\tmemcpy(cup->cu_u.cu_msg.cm_u.cm_name.cn_id, clp->cl_name.data,\n\t\t\tclp->cl_name.len);\n\n\tret = cld_pipe_upcall(cn->cn_pipe, &cup->cu_u.cu_msg, nn);\n\tif (!ret) {\n\t\tret = cup->cu_u.cu_msg.cm_status;\n\t\tset_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags);\n\t}\n\n\tfree_cld_upcall(cup);\n\treturn ret;\n}\n\n \nstatic int\nnfsd4_cld_check(struct nfs4_client *clp)\n{\n\tstruct nfs4_client_reclaim *crp;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\tstruct cld_net *cn = nn->cld_net;\n\tint status;\n\tchar dname[HEXDIR_LEN];\n\tstruct xdr_netobj name;\n\n\t \n\tif (test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\n\t\treturn 0;\n\n\t \n\tcrp = nfsd4_find_reclaim_client(clp->cl_name, nn);\n\tif (crp)\n\t\tgoto found;\n\n\tif (cn->cn_has_legacy) {\n\t\tstatus = nfs4_make_rec_clidname(dname, &clp->cl_name);\n\t\tif (status)\n\t\t\treturn -ENOENT;\n\n\t\tname.data = kmemdup(dname, HEXDIR_LEN, GFP_KERNEL);\n\t\tif (!name.data) {\n\t\t\tdprintk(\"%s: failed to allocate memory for name.data!\\n\",\n\t\t\t\t__func__);\n\t\t\treturn -ENOENT;\n\t\t}\n\t\tname.len = HEXDIR_LEN;\n\t\tcrp = nfsd4_find_reclaim_client(name, nn);\n\t\tkfree(name.data);\n\t\tif (crp)\n\t\t\tgoto found;\n\n\t}\n\treturn -ENOENT;\nfound:\n\tcrp->cr_clp = clp;\n\treturn 0;\n}\n\nstatic int\nnfsd4_cld_check_v2(struct nfs4_client *clp)\n{\n\tstruct nfs4_client_reclaim *crp;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\tstruct cld_net *cn = nn->cld_net;\n\tint status;\n\tchar dname[HEXDIR_LEN];\n\tstruct xdr_netobj name;\n\tstruct crypto_shash *tfm = cn->cn_tfm;\n\tstruct xdr_netobj cksum;\n\tchar *principal = NULL;\n\n\t \n\tif (test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\n\t\treturn 0;\n\n\t \n\tcrp = nfsd4_find_reclaim_client(clp->cl_name, nn);\n\tif (crp)\n\t\tgoto found;\n\n\tif (cn->cn_has_legacy) {\n\t\tstatus = nfs4_make_rec_clidname(dname, &clp->cl_name);\n\t\tif (status)\n\t\t\treturn -ENOENT;\n\n\t\tname.data = kmemdup(dname, HEXDIR_LEN, GFP_KERNEL);\n\t\tif (!name.data) {\n\t\t\tdprintk(\"%s: failed to allocate memory for name.data\\n\",\n\t\t\t\t\t__func__);\n\t\t\treturn -ENOENT;\n\t\t}\n\t\tname.len = HEXDIR_LEN;\n\t\tcrp = nfsd4_find_reclaim_client(name, nn);\n\t\tkfree(name.data);\n\t\tif (crp)\n\t\t\tgoto found;\n\n\t}\n\treturn -ENOENT;\nfound:\n\tif (crp->cr_princhash.len) {\n\t\tif (clp->cl_cred.cr_raw_principal)\n\t\t\tprincipal = clp->cl_cred.cr_raw_principal;\n\t\telse if (clp->cl_cred.cr_principal)\n\t\t\tprincipal = clp->cl_cred.cr_principal;\n\t\tif (principal == NULL)\n\t\t\treturn -ENOENT;\n\t\tcksum.len = crypto_shash_digestsize(tfm);\n\t\tcksum.data = kmalloc(cksum.len, GFP_KERNEL);\n\t\tif (cksum.data == NULL)\n\t\t\treturn -ENOENT;\n\t\tstatus = crypto_shash_tfm_digest(tfm, principal,\n\t\t\t\t\t\t strlen(principal), cksum.data);\n\t\tif (status) {\n\t\t\tkfree(cksum.data);\n\t\t\treturn -ENOENT;\n\t\t}\n\t\tif (memcmp(crp->cr_princhash.data, cksum.data,\n\t\t\t\tcrp->cr_princhash.len)) {\n\t\t\tkfree(cksum.data);\n\t\t\treturn -ENOENT;\n\t\t}\n\t\tkfree(cksum.data);\n\t}\n\tcrp->cr_clp = clp;\n\treturn 0;\n}\n\nstatic int\nnfsd4_cld_grace_start(struct nfsd_net *nn)\n{\n\tint ret;\n\tstruct cld_upcall *cup;\n\tstruct cld_net *cn = nn->cld_net;\n\n\tcup = alloc_cld_upcall(nn);\n\tif (!cup) {\n\t\tret = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\tcup->cu_u.cu_msg.cm_cmd = Cld_GraceStart;\n\tret = cld_pipe_upcall(cn->cn_pipe, &cup->cu_u.cu_msg, nn);\n\tif (!ret)\n\t\tret = cup->cu_u.cu_msg.cm_status;\n\n\tfree_cld_upcall(cup);\nout_err:\n\tif (ret)\n\t\tdprintk(\"%s: Unable to get clients from userspace: %d\\n\",\n\t\t\t__func__, ret);\n\treturn ret;\n}\n\n \nstatic void\nnfsd4_cld_grace_done_v0(struct nfsd_net *nn)\n{\n\tint ret;\n\tstruct cld_upcall *cup;\n\tstruct cld_net *cn = nn->cld_net;\n\n\tcup = alloc_cld_upcall(nn);\n\tif (!cup) {\n\t\tret = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\tcup->cu_u.cu_msg.cm_cmd = Cld_GraceDone;\n\tcup->cu_u.cu_msg.cm_u.cm_gracetime = nn->boot_time;\n\tret = cld_pipe_upcall(cn->cn_pipe, &cup->cu_u.cu_msg, nn);\n\tif (!ret)\n\t\tret = cup->cu_u.cu_msg.cm_status;\n\n\tfree_cld_upcall(cup);\nout_err:\n\tif (ret)\n\t\tprintk(KERN_ERR \"NFSD: Unable to end grace period: %d\\n\", ret);\n}\n\n \nstatic void\nnfsd4_cld_grace_done(struct nfsd_net *nn)\n{\n\tint ret;\n\tstruct cld_upcall *cup;\n\tstruct cld_net *cn = nn->cld_net;\n\n\tcup = alloc_cld_upcall(nn);\n\tif (!cup) {\n\t\tret = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\tcup->cu_u.cu_msg.cm_cmd = Cld_GraceDone;\n\tret = cld_pipe_upcall(cn->cn_pipe, &cup->cu_u.cu_msg, nn);\n\tif (!ret)\n\t\tret = cup->cu_u.cu_msg.cm_status;\n\n\tfree_cld_upcall(cup);\nout_err:\n\tnfs4_release_reclaim(nn);\n\tif (ret)\n\t\tprintk(KERN_ERR \"NFSD: Unable to end grace period: %d\\n\", ret);\n}\n\nstatic int\nnfs4_cld_state_init(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint i;\n\n\tnn->reclaim_str_hashtbl = kmalloc_array(CLIENT_HASH_SIZE,\n\t\t\t\t\t\tsizeof(struct list_head),\n\t\t\t\t\t\tGFP_KERNEL);\n\tif (!nn->reclaim_str_hashtbl)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < CLIENT_HASH_SIZE; i++)\n\t\tINIT_LIST_HEAD(&nn->reclaim_str_hashtbl[i]);\n\tnn->reclaim_str_hashtbl_size = 0;\n\tnn->track_reclaim_completes = true;\n\tatomic_set(&nn->nr_reclaim_complete, 0);\n\n\treturn 0;\n}\n\nstatic void\nnfs4_cld_state_shutdown(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tnn->track_reclaim_completes = false;\n\tkfree(nn->reclaim_str_hashtbl);\n}\n\nstatic bool\ncld_running(struct nfsd_net *nn)\n{\n\tstruct cld_net *cn = nn->cld_net;\n\tstruct rpc_pipe *pipe = cn->cn_pipe;\n\n\treturn pipe->nreaders || pipe->nwriters;\n}\n\nstatic int\nnfsd4_cld_get_version(struct nfsd_net *nn)\n{\n\tint ret = 0;\n\tstruct cld_upcall *cup;\n\tstruct cld_net *cn = nn->cld_net;\n\tuint8_t version;\n\n\tcup = alloc_cld_upcall(nn);\n\tif (!cup) {\n\t\tret = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\tcup->cu_u.cu_msg.cm_cmd = Cld_GetVersion;\n\tret = cld_pipe_upcall(cn->cn_pipe, &cup->cu_u.cu_msg, nn);\n\tif (!ret) {\n\t\tret = cup->cu_u.cu_msg.cm_status;\n\t\tif (ret)\n\t\t\tgoto out_free;\n\t\tversion = cup->cu_u.cu_msg.cm_u.cm_version;\n\t\tdprintk(\"%s: userspace returned version %u\\n\",\n\t\t\t\t__func__, version);\n\t\tif (version < 1)\n\t\t\tversion = 1;\n\t\telse if (version > CLD_UPCALL_VERSION)\n\t\t\tversion = CLD_UPCALL_VERSION;\n\n\t\tswitch (version) {\n\t\tcase 1:\n\t\t\tnn->client_tracking_ops = &nfsd4_cld_tracking_ops;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tnn->client_tracking_ops = &nfsd4_cld_tracking_ops_v2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\nout_free:\n\tfree_cld_upcall(cup);\nout_err:\n\tif (ret)\n\t\tdprintk(\"%s: Unable to get version from userspace: %d\\n\",\n\t\t\t__func__, ret);\n\treturn ret;\n}\n\nstatic int\nnfsd4_cld_tracking_init(struct net *net)\n{\n\tint status;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tbool running;\n\tint retries = 10;\n\tstruct crypto_shash *tfm;\n\n\tstatus = nfs4_cld_state_init(net);\n\tif (status)\n\t\treturn status;\n\n\tstatus = __nfsd4_init_cld_pipe(net);\n\tif (status)\n\t\tgoto err_shutdown;\n\n\t \n\twhile (!(running = cld_running(nn)) && retries--)\n\t\tmsleep(100);\n\n\tif (!running) {\n\t\tstatus = -ETIMEDOUT;\n\t\tgoto err_remove;\n\t}\n\ttfm = crypto_alloc_shash(\"sha256\", 0, 0);\n\tif (IS_ERR(tfm)) {\n\t\tstatus = PTR_ERR(tfm);\n\t\tgoto err_remove;\n\t}\n\tnn->cld_net->cn_tfm = tfm;\n\n\tstatus = nfsd4_cld_get_version(nn);\n\tif (status == -EOPNOTSUPP)\n\t\tpr_warn(\"NFSD: nfsdcld GetVersion upcall failed. Please upgrade nfsdcld.\\n\");\n\n\tstatus = nfsd4_cld_grace_start(nn);\n\tif (status) {\n\t\tif (status == -EOPNOTSUPP)\n\t\t\tpr_warn(\"NFSD: nfsdcld GraceStart upcall failed. Please upgrade nfsdcld.\\n\");\n\t\tnfs4_release_reclaim(nn);\n\t\tgoto err_remove;\n\t} else\n\t\tpr_info(\"NFSD: Using nfsdcld client tracking operations.\\n\");\n\treturn 0;\n\nerr_remove:\n\tnfsd4_remove_cld_pipe(net);\nerr_shutdown:\n\tnfs4_cld_state_shutdown(net);\n\treturn status;\n}\n\nstatic void\nnfsd4_cld_tracking_exit(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tnfs4_release_reclaim(nn);\n\tnfsd4_remove_cld_pipe(net);\n\tnfs4_cld_state_shutdown(net);\n}\n\n \nstatic const struct nfsd4_client_tracking_ops nfsd4_cld_tracking_ops_v0 = {\n\t.init\t\t= nfsd4_init_cld_pipe,\n\t.exit\t\t= nfsd4_remove_cld_pipe,\n\t.create\t\t= nfsd4_cld_create,\n\t.remove\t\t= nfsd4_cld_remove,\n\t.check\t\t= nfsd4_cld_check_v0,\n\t.grace_done\t= nfsd4_cld_grace_done_v0,\n\t.version\t= 1,\n\t.msglen\t\t= sizeof(struct cld_msg),\n};\n\n \nstatic const struct nfsd4_client_tracking_ops nfsd4_cld_tracking_ops = {\n\t.init\t\t= nfsd4_cld_tracking_init,\n\t.exit\t\t= nfsd4_cld_tracking_exit,\n\t.create\t\t= nfsd4_cld_create,\n\t.remove\t\t= nfsd4_cld_remove,\n\t.check\t\t= nfsd4_cld_check,\n\t.grace_done\t= nfsd4_cld_grace_done,\n\t.version\t= 1,\n\t.msglen\t\t= sizeof(struct cld_msg),\n};\n\n \nstatic const struct nfsd4_client_tracking_ops nfsd4_cld_tracking_ops_v2 = {\n\t.init\t\t= nfsd4_cld_tracking_init,\n\t.exit\t\t= nfsd4_cld_tracking_exit,\n\t.create\t\t= nfsd4_cld_create_v2,\n\t.remove\t\t= nfsd4_cld_remove,\n\t.check\t\t= nfsd4_cld_check_v2,\n\t.grace_done\t= nfsd4_cld_grace_done,\n\t.version\t= 2,\n\t.msglen\t\t= sizeof(struct cld_msg_v2),\n};\n\n \nstatic char cltrack_prog[PATH_MAX] = \"/sbin/nfsdcltrack\";\nmodule_param_string(cltrack_prog, cltrack_prog, sizeof(cltrack_prog),\n\t\t\tS_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(cltrack_prog, \"Path to the nfsdcltrack upcall program\");\n\nstatic bool cltrack_legacy_disable;\nmodule_param(cltrack_legacy_disable, bool, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(cltrack_legacy_disable,\n\t\t\"Disable legacy recoverydir conversion. Default: false\");\n\n#define LEGACY_TOPDIR_ENV_PREFIX \"NFSDCLTRACK_LEGACY_TOPDIR=\"\n#define LEGACY_RECDIR_ENV_PREFIX \"NFSDCLTRACK_LEGACY_RECDIR=\"\n#define HAS_SESSION_ENV_PREFIX \"NFSDCLTRACK_CLIENT_HAS_SESSION=\"\n#define GRACE_START_ENV_PREFIX \"NFSDCLTRACK_GRACE_START=\"\n\nstatic char *\nnfsd4_cltrack_legacy_topdir(void)\n{\n\tint copied;\n\tsize_t len;\n\tchar *result;\n\n\tif (cltrack_legacy_disable)\n\t\treturn NULL;\n\n\tlen = strlen(LEGACY_TOPDIR_ENV_PREFIX) +\n\t\tstrlen(nfs4_recoverydir()) + 1;\n\n\tresult = kmalloc(len, GFP_KERNEL);\n\tif (!result)\n\t\treturn result;\n\n\tcopied = snprintf(result, len, LEGACY_TOPDIR_ENV_PREFIX \"%s\",\n\t\t\t\tnfs4_recoverydir());\n\tif (copied >= len) {\n\t\t \n\t\tkfree(result);\n\t\treturn NULL;\n\t}\n\n\treturn result;\n}\n\nstatic char *\nnfsd4_cltrack_legacy_recdir(const struct xdr_netobj *name)\n{\n\tint copied;\n\tsize_t len;\n\tchar *result;\n\n\tif (cltrack_legacy_disable)\n\t\treturn NULL;\n\n\t \n\tlen = strlen(LEGACY_RECDIR_ENV_PREFIX) +\n\t\tstrlen(nfs4_recoverydir()) + 1 + HEXDIR_LEN;\n\n\tresult = kmalloc(len, GFP_KERNEL);\n\tif (!result)\n\t\treturn result;\n\n\tcopied = snprintf(result, len, LEGACY_RECDIR_ENV_PREFIX \"%s/\",\n\t\t\t\tnfs4_recoverydir());\n\tif (copied > (len - HEXDIR_LEN)) {\n\t\t \n\t\tkfree(result);\n\t\treturn NULL;\n\t}\n\n\tcopied = nfs4_make_rec_clidname(result + copied, name);\n\tif (copied) {\n\t\tkfree(result);\n\t\treturn NULL;\n\t}\n\n\treturn result;\n}\n\nstatic char *\nnfsd4_cltrack_client_has_session(struct nfs4_client *clp)\n{\n\tint copied;\n\tsize_t len;\n\tchar *result;\n\n\t \n\tlen = strlen(HAS_SESSION_ENV_PREFIX) + 1 + 1;\n\n\tresult = kmalloc(len, GFP_KERNEL);\n\tif (!result)\n\t\treturn result;\n\n\tcopied = snprintf(result, len, HAS_SESSION_ENV_PREFIX \"%c\",\n\t\t\t\tclp->cl_minorversion ? 'Y' : 'N');\n\tif (copied >= len) {\n\t\t \n\t\tkfree(result);\n\t\treturn NULL;\n\t}\n\n\treturn result;\n}\n\nstatic char *\nnfsd4_cltrack_grace_start(time64_t grace_start)\n{\n\tint copied;\n\tsize_t len;\n\tchar *result;\n\n\t \n\tlen = strlen(GRACE_START_ENV_PREFIX) + 22 + 1;\n\n\tresult = kmalloc(len, GFP_KERNEL);\n\tif (!result)\n\t\treturn result;\n\n\tcopied = snprintf(result, len, GRACE_START_ENV_PREFIX \"%lld\",\n\t\t\t\tgrace_start);\n\tif (copied >= len) {\n\t\t \n\t\tkfree(result);\n\t\treturn NULL;\n\t}\n\n\treturn result;\n}\n\nstatic int\nnfsd4_umh_cltrack_upcall(char *cmd, char *arg, char *env0, char *env1)\n{\n\tchar *envp[3];\n\tchar *argv[4];\n\tint ret;\n\n\tif (unlikely(!cltrack_prog[0])) {\n\t\tdprintk(\"%s: cltrack_prog is disabled\\n\", __func__);\n\t\treturn -EACCES;\n\t}\n\n\tdprintk(\"%s: cmd: %s\\n\", __func__, cmd);\n\tdprintk(\"%s: arg: %s\\n\", __func__, arg ? arg : \"(null)\");\n\tdprintk(\"%s: env0: %s\\n\", __func__, env0 ? env0 : \"(null)\");\n\tdprintk(\"%s: env1: %s\\n\", __func__, env1 ? env1 : \"(null)\");\n\n\tenvp[0] = env0;\n\tenvp[1] = env1;\n\tenvp[2] = NULL;\n\n\targv[0] = (char *)cltrack_prog;\n\targv[1] = cmd;\n\targv[2] = arg;\n\targv[3] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\t \n\tif (ret == -ENOENT || ret == -EACCES) {\n\t\tdprintk(\"NFSD: %s was not found or isn't executable (%d). \"\n\t\t\t\"Setting cltrack_prog to blank string!\",\n\t\t\tcltrack_prog, ret);\n\t\tcltrack_prog[0] = '\\0';\n\t}\n\tdprintk(\"%s: %s return value: %d\\n\", __func__, cltrack_prog, ret);\n\n\treturn ret;\n}\n\nstatic char *\nbin_to_hex_dup(const unsigned char *src, int srclen)\n{\n\tchar *buf;\n\n\t \n\tbuf = kzalloc((srclen * 2) + 1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn buf;\n\n\tbin2hex(buf, src, srclen);\n\treturn buf;\n}\n\nstatic int\nnfsd4_umh_cltrack_init(struct net *net)\n{\n\tint ret;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tchar *grace_start = nfsd4_cltrack_grace_start(nn->boot_time);\n\n\t \n\tif (net != &init_net) {\n\t\tpr_warn(\"NFSD: attempt to initialize umh client tracking in a container ignored.\\n\");\n\t\tkfree(grace_start);\n\t\treturn -EINVAL;\n\t}\n\n\tret = nfsd4_umh_cltrack_upcall(\"init\", NULL, grace_start, NULL);\n\tkfree(grace_start);\n\tif (!ret)\n\t\tpr_info(\"NFSD: Using UMH upcall client tracking operations.\\n\");\n\treturn ret;\n}\n\nstatic void\nnfsd4_cltrack_upcall_lock(struct nfs4_client *clp)\n{\n\twait_on_bit_lock(&clp->cl_flags, NFSD4_CLIENT_UPCALL_LOCK,\n\t\t\t TASK_UNINTERRUPTIBLE);\n}\n\nstatic void\nnfsd4_cltrack_upcall_unlock(struct nfs4_client *clp)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(NFSD4_CLIENT_UPCALL_LOCK, &clp->cl_flags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&clp->cl_flags, NFSD4_CLIENT_UPCALL_LOCK);\n}\n\nstatic void\nnfsd4_umh_cltrack_create(struct nfs4_client *clp)\n{\n\tchar *hexid, *has_session, *grace_start;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\t \n\tif (clp->cl_minorversion == 0 &&\n\t    test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\n\t\treturn;\n\n\thexid = bin_to_hex_dup(clp->cl_name.data, clp->cl_name.len);\n\tif (!hexid) {\n\t\tdprintk(\"%s: can't allocate memory for upcall!\\n\", __func__);\n\t\treturn;\n\t}\n\n\thas_session = nfsd4_cltrack_client_has_session(clp);\n\tgrace_start = nfsd4_cltrack_grace_start(nn->boot_time);\n\n\tnfsd4_cltrack_upcall_lock(clp);\n\tif (!nfsd4_umh_cltrack_upcall(\"create\", hexid, has_session, grace_start))\n\t\tset_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags);\n\tnfsd4_cltrack_upcall_unlock(clp);\n\n\tkfree(has_session);\n\tkfree(grace_start);\n\tkfree(hexid);\n}\n\nstatic void\nnfsd4_umh_cltrack_remove(struct nfs4_client *clp)\n{\n\tchar *hexid;\n\n\tif (!test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\n\t\treturn;\n\n\thexid = bin_to_hex_dup(clp->cl_name.data, clp->cl_name.len);\n\tif (!hexid) {\n\t\tdprintk(\"%s: can't allocate memory for upcall!\\n\", __func__);\n\t\treturn;\n\t}\n\n\tnfsd4_cltrack_upcall_lock(clp);\n\tif (test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags) &&\n\t    nfsd4_umh_cltrack_upcall(\"remove\", hexid, NULL, NULL) == 0)\n\t\tclear_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags);\n\tnfsd4_cltrack_upcall_unlock(clp);\n\n\tkfree(hexid);\n}\n\nstatic int\nnfsd4_umh_cltrack_check(struct nfs4_client *clp)\n{\n\tint ret;\n\tchar *hexid, *has_session, *legacy;\n\n\tif (test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\n\t\treturn 0;\n\n\thexid = bin_to_hex_dup(clp->cl_name.data, clp->cl_name.len);\n\tif (!hexid) {\n\t\tdprintk(\"%s: can't allocate memory for upcall!\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\thas_session = nfsd4_cltrack_client_has_session(clp);\n\tlegacy = nfsd4_cltrack_legacy_recdir(&clp->cl_name);\n\n\tnfsd4_cltrack_upcall_lock(clp);\n\tif (test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags)) {\n\t\tret = 0;\n\t} else {\n\t\tret = nfsd4_umh_cltrack_upcall(\"check\", hexid, has_session, legacy);\n\t\tif (ret == 0)\n\t\t\tset_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags);\n\t}\n\tnfsd4_cltrack_upcall_unlock(clp);\n\tkfree(has_session);\n\tkfree(legacy);\n\tkfree(hexid);\n\n\treturn ret;\n}\n\nstatic void\nnfsd4_umh_cltrack_grace_done(struct nfsd_net *nn)\n{\n\tchar *legacy;\n\tchar timestr[22];  \n\n\tsprintf(timestr, \"%lld\", nn->boot_time);\n\tlegacy = nfsd4_cltrack_legacy_topdir();\n\tnfsd4_umh_cltrack_upcall(\"gracedone\", timestr, legacy, NULL);\n\tkfree(legacy);\n}\n\nstatic const struct nfsd4_client_tracking_ops nfsd4_umh_tracking_ops = {\n\t.init\t\t= nfsd4_umh_cltrack_init,\n\t.exit\t\t= NULL,\n\t.create\t\t= nfsd4_umh_cltrack_create,\n\t.remove\t\t= nfsd4_umh_cltrack_remove,\n\t.check\t\t= nfsd4_umh_cltrack_check,\n\t.grace_done\t= nfsd4_umh_cltrack_grace_done,\n\t.version\t= 1,\n\t.msglen\t\t= 0,\n};\n\nint\nnfsd4_client_tracking_init(struct net *net)\n{\n\tint status;\n\tstruct path path;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\t \n\tif (nn->client_tracking_ops)\n\t\tgoto do_init;\n\n\t \n\tnn->client_tracking_ops = &nfsd4_cld_tracking_ops;\n\tstatus = nn->client_tracking_ops->init(net);\n\tif (!status)\n\t\treturn status;\n\tif (status != -ETIMEDOUT) {\n\t\tnn->client_tracking_ops = &nfsd4_cld_tracking_ops_v0;\n\t\tstatus = nn->client_tracking_ops->init(net);\n\t\tif (!status)\n\t\t\treturn status;\n\t}\n\n\t \n\tnn->client_tracking_ops = &nfsd4_umh_tracking_ops;\n\tstatus = nn->client_tracking_ops->init(net);\n\tif (!status)\n\t\treturn status;\n\n\t \n\tnn->client_tracking_ops = &nfsd4_legacy_tracking_ops;\n\tstatus = kern_path(nfs4_recoverydir(), LOOKUP_FOLLOW, &path);\n\tif (!status) {\n\t\tstatus = d_is_dir(path.dentry);\n\t\tpath_put(&path);\n\t\tif (!status) {\n\t\t\tstatus = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\ndo_init:\n\tstatus = nn->client_tracking_ops->init(net);\nout:\n\tif (status) {\n\t\tprintk(KERN_WARNING \"NFSD: Unable to initialize client \"\n\t\t\t\t    \"recovery tracking! (%d)\\n\", status);\n\t\tnn->client_tracking_ops = NULL;\n\t}\n\treturn status;\n}\n\nvoid\nnfsd4_client_tracking_exit(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (nn->client_tracking_ops) {\n\t\tif (nn->client_tracking_ops->exit)\n\t\t\tnn->client_tracking_ops->exit(net);\n\t\tnn->client_tracking_ops = NULL;\n\t}\n}\n\nvoid\nnfsd4_client_record_create(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (nn->client_tracking_ops)\n\t\tnn->client_tracking_ops->create(clp);\n}\n\nvoid\nnfsd4_client_record_remove(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (nn->client_tracking_ops)\n\t\tnn->client_tracking_ops->remove(clp);\n}\n\nint\nnfsd4_client_record_check(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (nn->client_tracking_ops)\n\t\treturn nn->client_tracking_ops->check(clp);\n\n\treturn -EOPNOTSUPP;\n}\n\nvoid\nnfsd4_record_grace_done(struct nfsd_net *nn)\n{\n\tif (nn->client_tracking_ops)\n\t\tnn->client_tracking_ops->grace_done(nn);\n}\n\nstatic int\nrpc_pipefs_event(struct notifier_block *nb, unsigned long event, void *ptr)\n{\n\tstruct super_block *sb = ptr;\n\tstruct net *net = sb->s_fs_info;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tstruct cld_net *cn = nn->cld_net;\n\tstruct dentry *dentry;\n\tint ret = 0;\n\n\tif (!try_module_get(THIS_MODULE))\n\t\treturn 0;\n\n\tif (!cn) {\n\t\tmodule_put(THIS_MODULE);\n\t\treturn 0;\n\t}\n\n\tswitch (event) {\n\tcase RPC_PIPEFS_MOUNT:\n\t\tdentry = nfsd4_cld_register_sb(sb, cn->cn_pipe);\n\t\tif (IS_ERR(dentry)) {\n\t\t\tret = PTR_ERR(dentry);\n\t\t\tbreak;\n\t\t}\n\t\tcn->cn_pipe->dentry = dentry;\n\t\tbreak;\n\tcase RPC_PIPEFS_UMOUNT:\n\t\tif (cn->cn_pipe->dentry)\n\t\t\tnfsd4_cld_unregister_sb(cn->cn_pipe);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOTSUPP;\n\t\tbreak;\n\t}\n\tmodule_put(THIS_MODULE);\n\treturn ret;\n}\n\nstatic struct notifier_block nfsd4_cld_block = {\n\t.notifier_call = rpc_pipefs_event,\n};\n\nint\nregister_cld_notifier(void)\n{\n\tWARN_ON(!nfsd_net_id);\n\treturn rpc_pipefs_notifier_register(&nfsd4_cld_block);\n}\n\nvoid\nunregister_cld_notifier(void)\n{\n\trpc_pipefs_notifier_unregister(&nfsd4_cld_block);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}