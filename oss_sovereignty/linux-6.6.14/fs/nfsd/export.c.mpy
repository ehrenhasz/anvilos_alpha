{
  "module_name": "export.c",
  "hash_id": "c4a691ffd06d956c346e38a506601fed9a91c97fbc0b9dd72d18f2809118ff70",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfsd/export.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n#include <linux/sunrpc/svc_xprt.h>\n\n#include \"nfsd.h\"\n#include \"nfsfh.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"filecache.h\"\n#include \"trace.h\"\n\n#define NFSDDBG_FACILITY\tNFSDDBG_EXPORT\n\n \n\n#define\tEXPKEY_HASHBITS\t\t8\n#define\tEXPKEY_HASHMAX\t\t(1 << EXPKEY_HASHBITS)\n#define\tEXPKEY_HASHMASK\t\t(EXPKEY_HASHMAX -1)\n\nstatic void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree_rcu(key, ek_rcu);\n}\n\nstatic int expkey_upcall(struct cache_detail *cd, struct cache_head *h)\n{\n\treturn sunrpc_cache_pipe_upcall(cd, h);\n}\n\nstatic void expkey_request(struct cache_detail *cd,\n\t\t\t   struct cache_head *h,\n\t\t\t   char **bpp, int *blen)\n{\n\t \n\tstruct svc_expkey *ek = container_of(h, struct svc_expkey, h);\n\tchar type[5];\n\n\tqword_add(bpp, blen, ek->ek_client->name);\n\tsnprintf(type, 5, \"%d\", ek->ek_fsidtype);\n\tqword_add(bpp, blen, type);\n\tqword_addhex(bpp, blen, (char*)ek->ek_fsid, key_len(ek->ek_fsidtype));\n\t(*bpp)[-1] = '\\n';\n}\n\nstatic struct svc_expkey *svc_expkey_update(struct cache_detail *cd, struct svc_expkey *new,\n\t\t\t\t\t    struct svc_expkey *old);\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\n\nstatic int expkey_parse(struct cache_detail *cd, char *mesg, int mlen)\n{\n\t \n\tchar *buf;\n\tint len;\n\tstruct auth_domain *dom = NULL;\n\tint err;\n\tint fsidtype;\n\tchar *ep;\n\tstruct svc_expkey key;\n\tstruct svc_expkey *ek = NULL;\n\n\tif (mesg[mlen - 1] != '\\n')\n\t\treturn -EINVAL;\n\tmesg[mlen-1] = 0;\n\n\tbuf = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\terr = -ENOMEM;\n\tif (!buf)\n\t\tgoto out;\n\n\terr = -EINVAL;\n\tif (qword_get(&mesg, buf, PAGE_SIZE) <= 0)\n\t\tgoto out;\n\n\terr = -ENOENT;\n\tdom = auth_domain_find(buf);\n\tif (!dom)\n\t\tgoto out;\n\tdprintk(\"found domain %s\\n\", buf);\n\n\terr = -EINVAL;\n\tif (qword_get(&mesg, buf, PAGE_SIZE) <= 0)\n\t\tgoto out;\n\tfsidtype = simple_strtoul(buf, &ep, 10);\n\tif (*ep)\n\t\tgoto out;\n\tdprintk(\"found fsidtype %d\\n\", fsidtype);\n\tif (key_len(fsidtype)==0)  \n\t\tgoto out;\n\tif ((len=qword_get(&mesg, buf, PAGE_SIZE)) <= 0)\n\t\tgoto out;\n\tdprintk(\"found fsid length %d\\n\", len);\n\tif (len != key_len(fsidtype))\n\t\tgoto out;\n\n\t \n\tkey.h.flags = 0;\n\terr = get_expiry(&mesg, &key.h.expiry_time);\n\tif (err)\n\t\tgoto out;\n\n\tkey.ek_client = dom;\n\tkey.ek_fsidtype = fsidtype;\n\tmemcpy(key.ek_fsid, buf, len);\n\n\tek = svc_expkey_lookup(cd, &key);\n\terr = -ENOMEM;\n\tif (!ek)\n\t\tgoto out;\n\n\t \n\terr = -EINVAL;\n\tlen = qword_get(&mesg, buf, PAGE_SIZE);\n\tif (len < 0)\n\t\tgoto out;\n\tdprintk(\"Path seems to be <%s>\\n\", buf);\n\terr = 0;\n\tif (len == 0) {\n\t\tset_bit(CACHE_NEGATIVE, &key.h.flags);\n\t\tek = svc_expkey_update(cd, &key, ek);\n\t\tif (ek)\n\t\t\ttrace_nfsd_expkey_update(ek, NULL);\n\t\telse\n\t\t\terr = -ENOMEM;\n\t} else {\n\t\terr = kern_path(buf, 0, &key.ek_path);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tdprintk(\"Found the path %s\\n\", buf);\n\n\t\tek = svc_expkey_update(cd, &key, ek);\n\t\tif (ek)\n\t\t\ttrace_nfsd_expkey_update(ek, buf);\n\t\telse\n\t\t\terr = -ENOMEM;\n\t\tpath_put(&key.ek_path);\n\t}\n\tcache_flush();\n out:\n\tif (ek)\n\t\tcache_put(&ek->h, cd);\n\tif (dom)\n\t\tauth_domain_put(dom);\n\tkfree(buf);\n\treturn err;\n}\n\nstatic int expkey_show(struct seq_file *m,\n\t\t       struct cache_detail *cd,\n\t\t       struct cache_head *h)\n{\n\tstruct svc_expkey *ek ;\n\tint i;\n\n\tif (h ==NULL) {\n\t\tseq_puts(m, \"#domain fsidtype fsid [path]\\n\");\n\t\treturn 0;\n\t}\n\tek = container_of(h, struct svc_expkey, h);\n\tseq_printf(m, \"%s %d 0x\", ek->ek_client->name,\n\t\t   ek->ek_fsidtype);\n\tfor (i=0; i < key_len(ek->ek_fsidtype)/4; i++)\n\t\tseq_printf(m, \"%08x\", ek->ek_fsid[i]);\n\tif (test_bit(CACHE_VALID, &h->flags) && \n\t    !test_bit(CACHE_NEGATIVE, &h->flags)) {\n\t\tseq_printf(m, \" \");\n\t\tseq_path(m, &ek->ek_path, \"\\\\ \\t\\n\");\n\t}\n\tseq_printf(m, \"\\n\");\n\treturn 0;\n}\n\nstatic inline int expkey_match (struct cache_head *a, struct cache_head *b)\n{\n\tstruct svc_expkey *orig = container_of(a, struct svc_expkey, h);\n\tstruct svc_expkey *new = container_of(b, struct svc_expkey, h);\n\n\tif (orig->ek_fsidtype != new->ek_fsidtype ||\n\t    orig->ek_client != new->ek_client ||\n\t    memcmp(orig->ek_fsid, new->ek_fsid, key_len(orig->ek_fsidtype)) != 0)\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic inline void expkey_init(struct cache_head *cnew,\n\t\t\t\t   struct cache_head *citem)\n{\n\tstruct svc_expkey *new = container_of(cnew, struct svc_expkey, h);\n\tstruct svc_expkey *item = container_of(citem, struct svc_expkey, h);\n\n\tkref_get(&item->ek_client->ref);\n\tnew->ek_client = item->ek_client;\n\tnew->ek_fsidtype = item->ek_fsidtype;\n\n\tmemcpy(new->ek_fsid, item->ek_fsid, sizeof(new->ek_fsid));\n}\n\nstatic inline void expkey_update(struct cache_head *cnew,\n\t\t\t\t   struct cache_head *citem)\n{\n\tstruct svc_expkey *new = container_of(cnew, struct svc_expkey, h);\n\tstruct svc_expkey *item = container_of(citem, struct svc_expkey, h);\n\n\tnew->ek_path = item->ek_path;\n\tpath_get(&item->ek_path);\n}\n\nstatic struct cache_head *expkey_alloc(void)\n{\n\tstruct svc_expkey *i = kmalloc(sizeof(*i), GFP_KERNEL);\n\tif (i)\n\t\treturn &i->h;\n\telse\n\t\treturn NULL;\n}\n\nstatic void expkey_flush(void)\n{\n\t \n\tmutex_lock(&nfsd_mutex);\n\tnfsd_file_cache_purge(current->nsproxy->net_ns);\n\tmutex_unlock(&nfsd_mutex);\n}\n\nstatic const struct cache_detail svc_expkey_cache_template = {\n\t.owner\t\t= THIS_MODULE,\n\t.hash_size\t= EXPKEY_HASHMAX,\n\t.name\t\t= \"nfsd.fh\",\n\t.cache_put\t= expkey_put,\n\t.cache_upcall\t= expkey_upcall,\n\t.cache_request\t= expkey_request,\n\t.cache_parse\t= expkey_parse,\n\t.cache_show\t= expkey_show,\n\t.match\t\t= expkey_match,\n\t.init\t\t= expkey_init,\n\t.update       \t= expkey_update,\n\t.alloc\t\t= expkey_alloc,\n\t.flush\t\t= expkey_flush,\n};\n\nstatic int\nsvc_expkey_hash(struct svc_expkey *item)\n{\n\tint hash = item->ek_fsidtype;\n\tchar * cp = (char*)item->ek_fsid;\n\tint len = key_len(item->ek_fsidtype);\n\n\thash ^= hash_mem(cp, len, EXPKEY_HASHBITS);\n\thash ^= hash_ptr(item->ek_client, EXPKEY_HASHBITS);\n\thash &= EXPKEY_HASHMASK;\n\treturn hash;\n}\n\nstatic struct svc_expkey *\nsvc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *item)\n{\n\tstruct cache_head *ch;\n\tint hash = svc_expkey_hash(item);\n\n\tch = sunrpc_cache_lookup_rcu(cd, &item->h, hash);\n\tif (ch)\n\t\treturn container_of(ch, struct svc_expkey, h);\n\telse\n\t\treturn NULL;\n}\n\nstatic struct svc_expkey *\nsvc_expkey_update(struct cache_detail *cd, struct svc_expkey *new,\n\t\t  struct svc_expkey *old)\n{\n\tstruct cache_head *ch;\n\tint hash = svc_expkey_hash(new);\n\n\tch = sunrpc_cache_update(cd, &new->h, &old->h, hash);\n\tif (ch)\n\t\treturn container_of(ch, struct svc_expkey, h);\n\telse\n\t\treturn NULL;\n}\n\n\n#define\tEXPORT_HASHBITS\t\t8\n#define\tEXPORT_HASHMAX\t\t(1<< EXPORT_HASHBITS)\n\nstatic void nfsd4_fslocs_free(struct nfsd4_fs_locations *fsloc)\n{\n\tstruct nfsd4_fs_location *locations = fsloc->locations;\n\tint i;\n\n\tif (!locations)\n\t\treturn;\n\n\tfor (i = 0; i < fsloc->locations_count; i++) {\n\t\tkfree(locations[i].path);\n\t\tkfree(locations[i].hosts);\n\t}\n\n\tkfree(locations);\n\tfsloc->locations = NULL;\n}\n\nstatic int export_stats_init(struct export_stats *stats)\n{\n\tstats->start_time = ktime_get_seconds();\n\treturn nfsd_percpu_counters_init(stats->counter, EXP_STATS_COUNTERS_NUM);\n}\n\nstatic void export_stats_reset(struct export_stats *stats)\n{\n\tnfsd_percpu_counters_reset(stats->counter, EXP_STATS_COUNTERS_NUM);\n}\n\nstatic void export_stats_destroy(struct export_stats *stats)\n{\n\tnfsd_percpu_counters_destroy(stats->counter, EXP_STATS_COUNTERS_NUM);\n}\n\nstatic void svc_export_put(struct kref *ref)\n{\n\tstruct svc_export *exp = container_of(ref, struct svc_export, h.ref);\n\tpath_put(&exp->ex_path);\n\tauth_domain_put(exp->ex_client);\n\tnfsd4_fslocs_free(&exp->ex_fslocs);\n\texport_stats_destroy(&exp->ex_stats);\n\tkfree(exp->ex_uuid);\n\tkfree_rcu(exp, ex_rcu);\n}\n\nstatic int svc_export_upcall(struct cache_detail *cd, struct cache_head *h)\n{\n\treturn sunrpc_cache_pipe_upcall(cd, h);\n}\n\nstatic void svc_export_request(struct cache_detail *cd,\n\t\t\t       struct cache_head *h,\n\t\t\t       char **bpp, int *blen)\n{\n\t \n\tstruct svc_export *exp = container_of(h, struct svc_export, h);\n\tchar *pth;\n\n\tqword_add(bpp, blen, exp->ex_client->name);\n\tpth = d_path(&exp->ex_path, *bpp, *blen);\n\tif (IS_ERR(pth)) {\n\t\t \n\t\t(*bpp)[0] = '\\n';\n\t\treturn;\n\t}\n\tqword_add(bpp, blen, pth);\n\t(*bpp)[-1] = '\\n';\n}\n\nstatic struct svc_export *svc_export_update(struct svc_export *new,\n\t\t\t\t\t    struct svc_export *old);\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\n\nstatic int check_export(struct path *path, int *flags, unsigned char *uuid)\n{\n\tstruct inode *inode = d_inode(path->dentry);\n\n\t \n\tif (!S_ISDIR(inode->i_mode) &&\n\t    !S_ISLNK(inode->i_mode) &&\n\t    !S_ISREG(inode->i_mode))\n\t\treturn -ENOTDIR;\n\n\t \n\tif (*flags & NFSEXP_V4ROOT)\n\t\t*flags |= NFSEXP_READONLY;\n\n\t \n\tif (!(inode->i_sb->s_type->fs_flags & FS_REQUIRES_DEV) &&\n\t    !(*flags & NFSEXP_FSID) &&\n\t    uuid == NULL) {\n\t\tdprintk(\"exp_export: export of non-dev fs without fsid\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!inode->i_sb->s_export_op ||\n\t    !inode->i_sb->s_export_op->fh_to_dentry) {\n\t\tdprintk(\"exp_export: export of invalid fs type.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (is_idmapped_mnt(path->mnt)) {\n\t\tdprintk(\"exp_export: export of idmapped mounts not yet supported.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (inode->i_sb->s_export_op->flags & EXPORT_OP_NOSUBTREECHK &&\n\t    !(*flags & NFSEXP_NOSUBTREECHECK)) {\n\t\tdprintk(\"%s: %s does not support subtree checking!\\n\",\n\t\t\t__func__, inode->i_sb->s_type->name);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n#ifdef CONFIG_NFSD_V4\n\nstatic int\nfsloc_parse(char **mesg, char *buf, struct nfsd4_fs_locations *fsloc)\n{\n\tint len;\n\tint migrated, i, err;\n\n\t \n\tif (fsloc->locations)\n\t\treturn -EINVAL;\n\n\t \n\terr = get_uint(mesg, &fsloc->locations_count);\n\tif (err)\n\t\treturn err;\n\tif (fsloc->locations_count > MAX_FS_LOCATIONS)\n\t\treturn -EINVAL;\n\tif (fsloc->locations_count == 0)\n\t\treturn 0;\n\n\tfsloc->locations = kcalloc(fsloc->locations_count,\n\t\t\t\t   sizeof(struct nfsd4_fs_location),\n\t\t\t\t   GFP_KERNEL);\n\tif (!fsloc->locations)\n\t\treturn -ENOMEM;\n\tfor (i=0; i < fsloc->locations_count; i++) {\n\t\t \n\t\terr = -EINVAL;\n\t\tlen = qword_get(mesg, buf, PAGE_SIZE);\n\t\tif (len <= 0)\n\t\t\tgoto out_free_all;\n\t\terr = -ENOMEM;\n\t\tfsloc->locations[i].hosts = kstrdup(buf, GFP_KERNEL);\n\t\tif (!fsloc->locations[i].hosts)\n\t\t\tgoto out_free_all;\n\t\terr = -EINVAL;\n\t\t \n\t\tlen = qword_get(mesg, buf, PAGE_SIZE);\n\t\tif (len <= 0)\n\t\t\tgoto out_free_all;\n\t\terr = -ENOMEM;\n\t\tfsloc->locations[i].path = kstrdup(buf, GFP_KERNEL);\n\t\tif (!fsloc->locations[i].path)\n\t\t\tgoto out_free_all;\n\t}\n\t \n\terr = get_int(mesg, &migrated);\n\tif (err)\n\t\tgoto out_free_all;\n\terr = -EINVAL;\n\tif (migrated < 0 || migrated > 1)\n\t\tgoto out_free_all;\n\tfsloc->migrated = migrated;\n\treturn 0;\nout_free_all:\n\tnfsd4_fslocs_free(fsloc);\n\treturn err;\n}\n\nstatic int secinfo_parse(char **mesg, char *buf, struct svc_export *exp)\n{\n\tstruct exp_flavor_info *f;\n\tu32 listsize;\n\tint err;\n\n\t \n\tif (exp->ex_nflavors)\n\t\treturn -EINVAL;\n\n\terr = get_uint(mesg, &listsize);\n\tif (err)\n\t\treturn err;\n\tif (listsize > MAX_SECINFO_LIST)\n\t\treturn -EINVAL;\n\n\tfor (f = exp->ex_flavors; f < exp->ex_flavors + listsize; f++) {\n\t\terr = get_uint(mesg, &f->pseudoflavor);\n\t\tif (err)\n\t\t\treturn err;\n\t\t \n\t\terr = get_uint(mesg, &f->flags);\n\t\tif (err)\n\t\t\treturn err;\n\t\t \n\t\tif (~NFSEXP_SECINFO_FLAGS & (f->flags ^ exp->ex_flags))\n\t\t\treturn -EINVAL;\n\t}\n\texp->ex_nflavors = listsize;\n\treturn 0;\n}\n\n#else  \nstatic inline int\nfsloc_parse(char **mesg, char *buf, struct nfsd4_fs_locations *fsloc){return 0;}\nstatic inline int\nsecinfo_parse(char **mesg, char *buf, struct svc_export *exp) { return 0; }\n#endif\n\nstatic int xprtsec_parse(char **mesg, char *buf, struct svc_export *exp)\n{\n\tunsigned int i, mode, listsize;\n\tint err;\n\n\terr = get_uint(mesg, &listsize);\n\tif (err)\n\t\treturn err;\n\tif (listsize > NFSEXP_XPRTSEC_NUM)\n\t\treturn -EINVAL;\n\n\texp->ex_xprtsec_modes = 0;\n\tfor (i = 0; i < listsize; i++) {\n\t\terr = get_uint(mesg, &mode);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (mode > NFSEXP_XPRTSEC_MTLS)\n\t\t\treturn -EINVAL;\n\t\texp->ex_xprtsec_modes |= mode;\n\t}\n\treturn 0;\n}\n\nstatic inline int\nnfsd_uuid_parse(char **mesg, char *buf, unsigned char **puuid)\n{\n\tint len;\n\n\t \n\tif (*puuid)\n\t\treturn -EINVAL;\n\n\t \n\tlen = qword_get(mesg, buf, PAGE_SIZE);\n\tif (len != EX_UUID_LEN)\n\t\treturn -EINVAL;\n\n\t*puuid = kmemdup(buf, EX_UUID_LEN, GFP_KERNEL);\n\tif (*puuid == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int svc_export_parse(struct cache_detail *cd, char *mesg, int mlen)\n{\n\t \n\tchar *buf;\n\tint err;\n\tstruct auth_domain *dom = NULL;\n\tstruct svc_export exp = {}, *expp;\n\tint an_int;\n\n\tif (mesg[mlen-1] != '\\n')\n\t\treturn -EINVAL;\n\tmesg[mlen-1] = 0;\n\n\tbuf = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t \n\terr = -EINVAL;\n\tif (qword_get(&mesg, buf, PAGE_SIZE) <= 0)\n\t\tgoto out;\n\n\terr = -ENOENT;\n\tdom = auth_domain_find(buf);\n\tif (!dom)\n\t\tgoto out;\n\n\t \n\terr = -EINVAL;\n\tif (qword_get(&mesg, buf, PAGE_SIZE) <= 0)\n\t\tgoto out1;\n\n\terr = kern_path(buf, 0, &exp.ex_path);\n\tif (err)\n\t\tgoto out1;\n\n\texp.ex_client = dom;\n\texp.cd = cd;\n\texp.ex_devid_map = NULL;\n\texp.ex_xprtsec_modes = NFSEXP_XPRTSEC_ALL;\n\n\t \n\terr = get_expiry(&mesg, &exp.h.expiry_time);\n\tif (err)\n\t\tgoto out3;\n\n\t \n\terr = get_int(&mesg, &an_int);\n\tif (err == -ENOENT) {\n\t\terr = 0;\n\t\tset_bit(CACHE_NEGATIVE, &exp.h.flags);\n\t} else {\n\t\tif (err || an_int < 0)\n\t\t\tgoto out3;\n\t\texp.ex_flags= an_int;\n\n\t\t \n\t\terr = get_int(&mesg, &an_int);\n\t\tif (err)\n\t\t\tgoto out3;\n\t\texp.ex_anon_uid= make_kuid(current_user_ns(), an_int);\n\n\t\t \n\t\terr = get_int(&mesg, &an_int);\n\t\tif (err)\n\t\t\tgoto out3;\n\t\texp.ex_anon_gid= make_kgid(current_user_ns(), an_int);\n\n\t\t \n\t\terr = get_int(&mesg, &an_int);\n\t\tif (err)\n\t\t\tgoto out3;\n\t\texp.ex_fsid = an_int;\n\n\t\twhile (qword_get(&mesg, buf, PAGE_SIZE) > 0) {\n\t\t\tif (strcmp(buf, \"fsloc\") == 0)\n\t\t\t\terr = fsloc_parse(&mesg, buf, &exp.ex_fslocs);\n\t\t\telse if (strcmp(buf, \"uuid\") == 0)\n\t\t\t\terr = nfsd_uuid_parse(&mesg, buf, &exp.ex_uuid);\n\t\t\telse if (strcmp(buf, \"secinfo\") == 0)\n\t\t\t\terr = secinfo_parse(&mesg, buf, &exp);\n\t\t\telse if (strcmp(buf, \"xprtsec\") == 0)\n\t\t\t\terr = xprtsec_parse(&mesg, buf, &exp);\n\t\t\telse\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\tif (err)\n\t\t\t\tgoto out4;\n\t\t}\n\n\t\terr = check_export(&exp.ex_path, &exp.ex_flags, exp.ex_uuid);\n\t\tif (err)\n\t\t\tgoto out4;\n\n\t\t \n\t\tif (exp.h.expiry_time < seconds_since_boot())\n\t\t\tgoto out4;\n\t\t \n\t\terr = -EINVAL;\n\t\tif (!uid_valid(exp.ex_anon_uid))\n\t\t\tgoto out4;\n\t\tif (!gid_valid(exp.ex_anon_gid))\n\t\t\tgoto out4;\n\t\terr = 0;\n\n\t\tnfsd4_setup_layout_type(&exp);\n\t}\n\n\texpp = svc_export_lookup(&exp);\n\tif (!expp) {\n\t\terr = -ENOMEM;\n\t\tgoto out4;\n\t}\n\texpp = svc_export_update(&exp, expp);\n\tif (expp) {\n\t\ttrace_nfsd_export_update(expp);\n\t\tcache_flush();\n\t\texp_put(expp);\n\t} else\n\t\terr = -ENOMEM;\nout4:\n\tnfsd4_fslocs_free(&exp.ex_fslocs);\n\tkfree(exp.ex_uuid);\nout3:\n\tpath_put(&exp.ex_path);\nout1:\n\tauth_domain_put(dom);\nout:\n\tkfree(buf);\n\treturn err;\n}\n\nstatic void exp_flags(struct seq_file *m, int flag, int fsid,\n\t\tkuid_t anonu, kgid_t anong, struct nfsd4_fs_locations *fslocs);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\nstatic int is_export_stats_file(struct seq_file *m)\n{\n\t \n\treturn !strcmp(m->file->f_path.dentry->d_name.name, \"export_stats\");\n}\n\nstatic int svc_export_show(struct seq_file *m,\n\t\t\t   struct cache_detail *cd,\n\t\t\t   struct cache_head *h)\n{\n\tstruct svc_export *exp;\n\tbool export_stats = is_export_stats_file(m);\n\n\tif (h == NULL) {\n\t\tif (export_stats)\n\t\t\tseq_puts(m, \"#path domain start-time\\n#\\tstats\\n\");\n\t\telse\n\t\t\tseq_puts(m, \"#path domain(flags)\\n\");\n\t\treturn 0;\n\t}\n\texp = container_of(h, struct svc_export, h);\n\tseq_path(m, &exp->ex_path, \" \\t\\n\\\\\");\n\tseq_putc(m, '\\t');\n\tseq_escape(m, exp->ex_client->name, \" \\t\\n\\\\\");\n\tif (export_stats) {\n\t\tseq_printf(m, \"\\t%lld\\n\", exp->ex_stats.start_time);\n\t\tseq_printf(m, \"\\tfh_stale: %lld\\n\",\n\t\t\t   percpu_counter_sum_positive(&exp->ex_stats.counter[EXP_STATS_FH_STALE]));\n\t\tseq_printf(m, \"\\tio_read: %lld\\n\",\n\t\t\t   percpu_counter_sum_positive(&exp->ex_stats.counter[EXP_STATS_IO_READ]));\n\t\tseq_printf(m, \"\\tio_write: %lld\\n\",\n\t\t\t   percpu_counter_sum_positive(&exp->ex_stats.counter[EXP_STATS_IO_WRITE]));\n\t\tseq_putc(m, '\\n');\n\t\treturn 0;\n\t}\n\tseq_putc(m, '(');\n\tif (test_bit(CACHE_VALID, &h->flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &h->flags)) {\n\t\texp_flags(m, exp->ex_flags, exp->ex_fsid,\n\t\t\t  exp->ex_anon_uid, exp->ex_anon_gid, &exp->ex_fslocs);\n\t\tif (exp->ex_uuid) {\n\t\t\tint i;\n\t\t\tseq_puts(m, \",uuid=\");\n\t\t\tfor (i = 0; i < EX_UUID_LEN; i++) {\n\t\t\t\tif ((i&3) == 0 && i)\n\t\t\t\t\tseq_putc(m, ':');\n\t\t\t\tseq_printf(m, \"%02x\", exp->ex_uuid[i]);\n\t\t\t}\n\t\t}\n\t\tshow_secinfo(m, exp);\n\t}\n\tseq_puts(m, \")\\n\");\n\treturn 0;\n}\nstatic int svc_export_match(struct cache_head *a, struct cache_head *b)\n{\n\tstruct svc_export *orig = container_of(a, struct svc_export, h);\n\tstruct svc_export *new = container_of(b, struct svc_export, h);\n\treturn orig->ex_client == new->ex_client &&\n\t\tpath_equal(&orig->ex_path, &new->ex_path);\n}\n\nstatic void svc_export_init(struct cache_head *cnew, struct cache_head *citem)\n{\n\tstruct svc_export *new = container_of(cnew, struct svc_export, h);\n\tstruct svc_export *item = container_of(citem, struct svc_export, h);\n\n\tkref_get(&item->ex_client->ref);\n\tnew->ex_client = item->ex_client;\n\tnew->ex_path = item->ex_path;\n\tpath_get(&item->ex_path);\n\tnew->ex_fslocs.locations = NULL;\n\tnew->ex_fslocs.locations_count = 0;\n\tnew->ex_fslocs.migrated = 0;\n\tnew->ex_layout_types = 0;\n\tnew->ex_uuid = NULL;\n\tnew->cd = item->cd;\n\texport_stats_reset(&new->ex_stats);\n}\n\nstatic void export_update(struct cache_head *cnew, struct cache_head *citem)\n{\n\tstruct svc_export *new = container_of(cnew, struct svc_export, h);\n\tstruct svc_export *item = container_of(citem, struct svc_export, h);\n\tint i;\n\n\tnew->ex_flags = item->ex_flags;\n\tnew->ex_anon_uid = item->ex_anon_uid;\n\tnew->ex_anon_gid = item->ex_anon_gid;\n\tnew->ex_fsid = item->ex_fsid;\n\tnew->ex_devid_map = item->ex_devid_map;\n\titem->ex_devid_map = NULL;\n\tnew->ex_uuid = item->ex_uuid;\n\titem->ex_uuid = NULL;\n\tnew->ex_fslocs.locations = item->ex_fslocs.locations;\n\titem->ex_fslocs.locations = NULL;\n\tnew->ex_fslocs.locations_count = item->ex_fslocs.locations_count;\n\titem->ex_fslocs.locations_count = 0;\n\tnew->ex_fslocs.migrated = item->ex_fslocs.migrated;\n\titem->ex_fslocs.migrated = 0;\n\tnew->ex_layout_types = item->ex_layout_types;\n\tnew->ex_nflavors = item->ex_nflavors;\n\tfor (i = 0; i < MAX_SECINFO_LIST; i++) {\n\t\tnew->ex_flavors[i] = item->ex_flavors[i];\n\t}\n\tnew->ex_xprtsec_modes = item->ex_xprtsec_modes;\n}\n\nstatic struct cache_head *svc_export_alloc(void)\n{\n\tstruct svc_export *i = kmalloc(sizeof(*i), GFP_KERNEL);\n\tif (!i)\n\t\treturn NULL;\n\n\tif (export_stats_init(&i->ex_stats)) {\n\t\tkfree(i);\n\t\treturn NULL;\n\t}\n\n\treturn &i->h;\n}\n\nstatic const struct cache_detail svc_export_cache_template = {\n\t.owner\t\t= THIS_MODULE,\n\t.hash_size\t= EXPORT_HASHMAX,\n\t.name\t\t= \"nfsd.export\",\n\t.cache_put\t= svc_export_put,\n\t.cache_upcall\t= svc_export_upcall,\n\t.cache_request\t= svc_export_request,\n\t.cache_parse\t= svc_export_parse,\n\t.cache_show\t= svc_export_show,\n\t.match\t\t= svc_export_match,\n\t.init\t\t= svc_export_init,\n\t.update\t\t= export_update,\n\t.alloc\t\t= svc_export_alloc,\n};\n\nstatic int\nsvc_export_hash(struct svc_export *exp)\n{\n\tint hash;\n\n\thash = hash_ptr(exp->ex_client, EXPORT_HASHBITS);\n\thash ^= hash_ptr(exp->ex_path.dentry, EXPORT_HASHBITS);\n\thash ^= hash_ptr(exp->ex_path.mnt, EXPORT_HASHBITS);\n\treturn hash;\n}\n\nstatic struct svc_export *\nsvc_export_lookup(struct svc_export *exp)\n{\n\tstruct cache_head *ch;\n\tint hash = svc_export_hash(exp);\n\n\tch = sunrpc_cache_lookup_rcu(exp->cd, &exp->h, hash);\n\tif (ch)\n\t\treturn container_of(ch, struct svc_export, h);\n\telse\n\t\treturn NULL;\n}\n\nstatic struct svc_export *\nsvc_export_update(struct svc_export *new, struct svc_export *old)\n{\n\tstruct cache_head *ch;\n\tint hash = svc_export_hash(old);\n\n\tch = sunrpc_cache_update(old->cd, &new->h, &old->h, hash);\n\tif (ch)\n\t\treturn container_of(ch, struct svc_export, h);\n\telse\n\t\treturn NULL;\n}\n\n\nstatic struct svc_expkey *\nexp_find_key(struct cache_detail *cd, struct auth_domain *clp, int fsid_type,\n\t     u32 *fsidv, struct cache_req *reqp)\n{\n\tstruct svc_expkey key, *ek;\n\tint err;\n\t\n\tif (!clp)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tkey.ek_client = clp;\n\tkey.ek_fsidtype = fsid_type;\n\tmemcpy(key.ek_fsid, fsidv, key_len(fsid_type));\n\n\tek = svc_expkey_lookup(cd, &key);\n\tif (ek == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\terr = cache_check(cd, &ek->h, reqp);\n\tif (err) {\n\t\ttrace_nfsd_exp_find_key(&key, err);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn ek;\n}\n\nstatic struct svc_export *\nexp_get_by_name(struct cache_detail *cd, struct auth_domain *clp,\n\t\tconst struct path *path, struct cache_req *reqp)\n{\n\tstruct svc_export *exp, key;\n\tint err;\n\n\tif (!clp)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tkey.ex_client = clp;\n\tkey.ex_path = *path;\n\tkey.cd = cd;\n\n\texp = svc_export_lookup(&key);\n\tif (exp == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\terr = cache_check(cd, &exp->h, reqp);\n\tif (err) {\n\t\ttrace_nfsd_exp_get_by_name(&key, err);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn exp;\n}\n\n \nstatic struct svc_export *\nexp_parent(struct cache_detail *cd, struct auth_domain *clp, struct path *path)\n{\n\tstruct dentry *saved = dget(path->dentry);\n\tstruct svc_export *exp = exp_get_by_name(cd, clp, path, NULL);\n\n\twhile (PTR_ERR(exp) == -ENOENT && !IS_ROOT(path->dentry)) {\n\t\tstruct dentry *parent = dget_parent(path->dentry);\n\t\tdput(path->dentry);\n\t\tpath->dentry = parent;\n\t\texp = exp_get_by_name(cd, clp, path, NULL);\n\t}\n\tdput(path->dentry);\n\tpath->dentry = saved;\n\treturn exp;\n}\n\n\n\n \nint\nexp_rootfh(struct net *net, struct auth_domain *clp, char *name,\n\t   struct knfsd_fh *f, int maxsize)\n{\n\tstruct svc_export\t*exp;\n\tstruct path\t\tpath;\n\tstruct inode\t\t*inode;\n\tstruct svc_fh\t\tfh;\n\tint\t\t\terr;\n\tstruct nfsd_net\t\t*nn = net_generic(net, nfsd_net_id);\n\tstruct cache_detail\t*cd = nn->svc_export_cache;\n\n\terr = -EPERM;\n\t \n\tif (kern_path(name, 0, &path)) {\n\t\tprintk(\"nfsd: exp_rootfh path not found %s\", name);\n\t\treturn err;\n\t}\n\tinode = d_inode(path.dentry);\n\n\tdprintk(\"nfsd: exp_rootfh(%s [%p] %s:%s/%ld)\\n\",\n\t\t name, path.dentry, clp->name,\n\t\t inode->i_sb->s_id, inode->i_ino);\n\texp = exp_parent(cd, clp, &path);\n\tif (IS_ERR(exp)) {\n\t\terr = PTR_ERR(exp);\n\t\tgoto out;\n\t}\n\n\t \n\tfh_init(&fh, maxsize);\n\tif (fh_compose(&fh, exp, path.dentry, NULL))\n\t\terr = -EINVAL;\n\telse\n\t\terr = 0;\n\tmemcpy(f, &fh.fh_handle, sizeof(struct knfsd_fh));\n\tfh_put(&fh);\n\texp_put(exp);\nout:\n\tpath_put(&path);\n\treturn err;\n}\n\nstatic struct svc_export *exp_find(struct cache_detail *cd,\n\t\t\t\t   struct auth_domain *clp, int fsid_type,\n\t\t\t\t   u32 *fsidv, struct cache_req *reqp)\n{\n\tstruct svc_export *exp;\n\tstruct nfsd_net *nn = net_generic(cd->net, nfsd_net_id);\n\tstruct svc_expkey *ek = exp_find_key(nn->svc_expkey_cache, clp, fsid_type, fsidv, reqp);\n\tif (IS_ERR(ek))\n\t\treturn ERR_CAST(ek);\n\n\texp = exp_get_by_name(cd, clp, &ek->ek_path, reqp);\n\tcache_put(&ek->h, nn->svc_expkey_cache);\n\n\tif (IS_ERR(exp))\n\t\treturn ERR_CAST(exp);\n\treturn exp;\n}\n\n__be32 check_nfsd_access(struct svc_export *exp, struct svc_rqst *rqstp)\n{\n\tstruct exp_flavor_info *f, *end = exp->ex_flavors + exp->ex_nflavors;\n\tstruct svc_xprt *xprt = rqstp->rq_xprt;\n\n\tif (exp->ex_xprtsec_modes & NFSEXP_XPRTSEC_NONE) {\n\t\tif (!test_bit(XPT_TLS_SESSION, &xprt->xpt_flags))\n\t\t\tgoto ok;\n\t}\n\tif (exp->ex_xprtsec_modes & NFSEXP_XPRTSEC_TLS) {\n\t\tif (test_bit(XPT_TLS_SESSION, &xprt->xpt_flags) &&\n\t\t    !test_bit(XPT_PEER_AUTH, &xprt->xpt_flags))\n\t\t\tgoto ok;\n\t}\n\tif (exp->ex_xprtsec_modes & NFSEXP_XPRTSEC_MTLS) {\n\t\tif (test_bit(XPT_TLS_SESSION, &xprt->xpt_flags) &&\n\t\t    test_bit(XPT_PEER_AUTH, &xprt->xpt_flags))\n\t\t\tgoto ok;\n\t}\n\tgoto denied;\n\nok:\n\t \n\tif (exp->ex_client == rqstp->rq_gssclient)\n\t\treturn 0;\n\t \n\tfor (f = exp->ex_flavors; f < end; f++) {\n\t\tif (f->pseudoflavor == rqstp->rq_cred.cr_flavor)\n\t\t\treturn 0;\n\t}\n\t \n\tif (exp->ex_nflavors == 0) {\n\t\tif (rqstp->rq_cred.cr_flavor == RPC_AUTH_NULL ||\n\t\t    rqstp->rq_cred.cr_flavor == RPC_AUTH_UNIX)\n\t\t\treturn 0;\n\t}\n\n\t \n\n\tif (nfsd4_spo_must_allow(rqstp))\n\t\treturn 0;\n\ndenied:\n\treturn rqstp->rq_vers < 4 ? nfserr_acces : nfserr_wrongsec;\n}\n\n \nstruct svc_export *\nrqst_exp_get_by_name(struct svc_rqst *rqstp, struct path *path)\n{\n\tstruct svc_export *gssexp, *exp = ERR_PTR(-ENOENT);\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\tstruct cache_detail *cd = nn->svc_export_cache;\n\n\tif (rqstp->rq_client == NULL)\n\t\tgoto gss;\n\n\t \n\texp = exp_get_by_name(cd, rqstp->rq_client, path, &rqstp->rq_chandle);\n\tif (PTR_ERR(exp) == -ENOENT)\n\t\tgoto gss;\n\tif (IS_ERR(exp))\n\t\treturn exp;\n\t \n\tif (exp->ex_nflavors > 0)\n\t\treturn exp;\ngss:\n\t \n\tif (rqstp->rq_gssclient == NULL)\n\t\treturn exp;\n\tgssexp = exp_get_by_name(cd, rqstp->rq_gssclient, path, &rqstp->rq_chandle);\n\tif (PTR_ERR(gssexp) == -ENOENT)\n\t\treturn exp;\n\tif (!IS_ERR(exp))\n\t\texp_put(exp);\n\treturn gssexp;\n}\n\nstruct svc_export *\nrqst_exp_find(struct svc_rqst *rqstp, int fsid_type, u32 *fsidv)\n{\n\tstruct svc_export *gssexp, *exp = ERR_PTR(-ENOENT);\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\tstruct cache_detail *cd = nn->svc_export_cache;\n\n\tif (rqstp->rq_client == NULL)\n\t\tgoto gss;\n\n\t \n\texp = exp_find(cd, rqstp->rq_client, fsid_type,\n\t\t       fsidv, &rqstp->rq_chandle);\n\tif (PTR_ERR(exp) == -ENOENT)\n\t\tgoto gss;\n\tif (IS_ERR(exp))\n\t\treturn exp;\n\t \n\tif (exp->ex_nflavors > 0)\n\t\treturn exp;\ngss:\n\t \n\tif (rqstp->rq_gssclient == NULL)\n\t\treturn exp;\n\tgssexp = exp_find(cd, rqstp->rq_gssclient, fsid_type, fsidv,\n\t\t\t\t\t\t&rqstp->rq_chandle);\n\tif (PTR_ERR(gssexp) == -ENOENT)\n\t\treturn exp;\n\tif (!IS_ERR(exp))\n\t\texp_put(exp);\n\treturn gssexp;\n}\n\nstruct svc_export *\nrqst_exp_parent(struct svc_rqst *rqstp, struct path *path)\n{\n\tstruct dentry *saved = dget(path->dentry);\n\tstruct svc_export *exp = rqst_exp_get_by_name(rqstp, path);\n\n\twhile (PTR_ERR(exp) == -ENOENT && !IS_ROOT(path->dentry)) {\n\t\tstruct dentry *parent = dget_parent(path->dentry);\n\t\tdput(path->dentry);\n\t\tpath->dentry = parent;\n\t\texp = rqst_exp_get_by_name(rqstp, path);\n\t}\n\tdput(path->dentry);\n\tpath->dentry = saved;\n\treturn exp;\n}\n\nstruct svc_export *rqst_find_fsidzero_export(struct svc_rqst *rqstp)\n{\n\tu32 fsidv[2];\n\n\tmk_fsid(FSID_NUM, fsidv, 0, 0, 0, NULL);\n\n\treturn rqst_exp_find(rqstp, FSID_NUM, fsidv);\n}\n\n \n__be32\nexp_pseudoroot(struct svc_rqst *rqstp, struct svc_fh *fhp)\n{\n\tstruct svc_export *exp;\n\t__be32 rv;\n\n\texp = rqst_find_fsidzero_export(rqstp);\n\tif (IS_ERR(exp))\n\t\treturn nfserrno(PTR_ERR(exp));\n\trv = fh_compose(fhp, exp, exp->ex_path.dentry, NULL);\n\texp_put(exp);\n\treturn rv;\n}\n\nstatic struct flags {\n\tint flag;\n\tchar *name[2];\n} expflags[] = {\n\t{ NFSEXP_READONLY, {\"ro\", \"rw\"}},\n\t{ NFSEXP_INSECURE_PORT, {\"insecure\", \"\"}},\n\t{ NFSEXP_ROOTSQUASH, {\"root_squash\", \"no_root_squash\"}},\n\t{ NFSEXP_ALLSQUASH, {\"all_squash\", \"\"}},\n\t{ NFSEXP_ASYNC, {\"async\", \"sync\"}},\n\t{ NFSEXP_GATHERED_WRITES, {\"wdelay\", \"no_wdelay\"}},\n\t{ NFSEXP_NOREADDIRPLUS, {\"nordirplus\", \"\"}},\n\t{ NFSEXP_NOHIDE, {\"nohide\", \"\"}},\n\t{ NFSEXP_CROSSMOUNT, {\"crossmnt\", \"\"}},\n\t{ NFSEXP_NOSUBTREECHECK, {\"no_subtree_check\", \"\"}},\n\t{ NFSEXP_NOAUTHNLM, {\"insecure_locks\", \"\"}},\n\t{ NFSEXP_V4ROOT, {\"v4root\", \"\"}},\n\t{ NFSEXP_PNFS, {\"pnfs\", \"\"}},\n\t{ NFSEXP_SECURITY_LABEL, {\"security_label\", \"\"}},\n\t{ 0, {\"\", \"\"}}\n};\n\nstatic void show_expflags(struct seq_file *m, int flags, int mask)\n{\n\tstruct flags *flg;\n\tint state, first = 0;\n\n\tfor (flg = expflags; flg->flag; flg++) {\n\t\tif (flg->flag & ~mask)\n\t\t\tcontinue;\n\t\tstate = (flg->flag & flags) ? 0 : 1;\n\t\tif (*flg->name[state])\n\t\t\tseq_printf(m, \"%s%s\", first++?\",\":\"\", flg->name[state]);\n\t}\n}\n\nstatic void show_secinfo_flags(struct seq_file *m, int flags)\n{\n\tseq_printf(m, \",\");\n\tshow_expflags(m, flags, NFSEXP_SECINFO_FLAGS);\n}\n\nstatic bool secinfo_flags_equal(int f, int g)\n{\n\tf &= NFSEXP_SECINFO_FLAGS;\n\tg &= NFSEXP_SECINFO_FLAGS;\n\treturn f == g;\n}\n\nstatic int show_secinfo_run(struct seq_file *m, struct exp_flavor_info **fp, struct exp_flavor_info *end)\n{\n\tint flags;\n\n\tflags = (*fp)->flags;\n\tseq_printf(m, \",sec=%d\", (*fp)->pseudoflavor);\n\t(*fp)++;\n\twhile (*fp != end && secinfo_flags_equal(flags, (*fp)->flags)) {\n\t\tseq_printf(m, \":%d\", (*fp)->pseudoflavor);\n\t\t(*fp)++;\n\t}\n\treturn flags;\n}\n\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp)\n{\n\tstruct exp_flavor_info *f;\n\tstruct exp_flavor_info *end = exp->ex_flavors + exp->ex_nflavors;\n\tint flags;\n\n\tif (exp->ex_nflavors == 0)\n\t\treturn;\n\tf = exp->ex_flavors;\n\tflags = show_secinfo_run(m, &f, end);\n\tif (!secinfo_flags_equal(flags, exp->ex_flags))\n\t\tshow_secinfo_flags(m, flags);\n\twhile (f != end) {\n\t\tflags = show_secinfo_run(m, &f, end);\n\t\tshow_secinfo_flags(m, flags);\n\t}\n}\n\nstatic void exp_flags(struct seq_file *m, int flag, int fsid,\n\t\tkuid_t anonu, kgid_t anong, struct nfsd4_fs_locations *fsloc)\n{\n\tstruct user_namespace *userns = m->file->f_cred->user_ns;\n\n\tshow_expflags(m, flag, NFSEXP_ALLFLAGS);\n\tif (flag & NFSEXP_FSID)\n\t\tseq_printf(m, \",fsid=%d\", fsid);\n\tif (!uid_eq(anonu, make_kuid(userns, (uid_t)-2)) &&\n\t    !uid_eq(anonu, make_kuid(userns, 0x10000-2)))\n\t\tseq_printf(m, \",anonuid=%u\", from_kuid_munged(userns, anonu));\n\tif (!gid_eq(anong, make_kgid(userns, (gid_t)-2)) &&\n\t    !gid_eq(anong, make_kgid(userns, 0x10000-2)))\n\t\tseq_printf(m, \",anongid=%u\", from_kgid_munged(userns, anong));\n\tif (fsloc && fsloc->locations_count > 0) {\n\t\tchar *loctype = (fsloc->migrated) ? \"refer\" : \"replicas\";\n\t\tint i;\n\n\t\tseq_printf(m, \",%s=\", loctype);\n\t\tseq_escape(m, fsloc->locations[0].path, \",;@ \\t\\n\\\\\");\n\t\tseq_putc(m, '@');\n\t\tseq_escape(m, fsloc->locations[0].hosts, \",;@ \\t\\n\\\\\");\n\t\tfor (i = 1; i < fsloc->locations_count; i++) {\n\t\t\tseq_putc(m, ';');\n\t\t\tseq_escape(m, fsloc->locations[i].path, \",;@ \\t\\n\\\\\");\n\t\t\tseq_putc(m, '@');\n\t\t\tseq_escape(m, fsloc->locations[i].hosts, \",;@ \\t\\n\\\\\");\n\t\t}\n\t}\n}\n\nstatic int e_show(struct seq_file *m, void *p)\n{\n\tstruct cache_head *cp = p;\n\tstruct svc_export *exp = container_of(cp, struct svc_export, h);\n\tstruct cache_detail *cd = m->private;\n\tbool export_stats = is_export_stats_file(m);\n\n\tif (p == SEQ_START_TOKEN) {\n\t\tseq_puts(m, \"# Version 1.1\\n\");\n\t\tif (export_stats)\n\t\t\tseq_puts(m, \"# Path Client Start-time\\n#\\tStats\\n\");\n\t\telse\n\t\t\tseq_puts(m, \"# Path Client(Flags) # IPs\\n\");\n\t\treturn 0;\n\t}\n\n\texp_get(exp);\n\tif (cache_check(cd, &exp->h, NULL))\n\t\treturn 0;\n\texp_put(exp);\n\treturn svc_export_show(m, cd, cp);\n}\n\nconst struct seq_operations nfs_exports_op = {\n\t.start\t= cache_seq_start_rcu,\n\t.next\t= cache_seq_next_rcu,\n\t.stop\t= cache_seq_stop_rcu,\n\t.show\t= e_show,\n};\n\n \nint\nnfsd_export_init(struct net *net)\n{\n\tint rv;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tdprintk(\"nfsd: initializing export module (net: %x).\\n\", net->ns.inum);\n\n\tnn->svc_export_cache = cache_create_net(&svc_export_cache_template, net);\n\tif (IS_ERR(nn->svc_export_cache))\n\t\treturn PTR_ERR(nn->svc_export_cache);\n\trv = cache_register_net(nn->svc_export_cache, net);\n\tif (rv)\n\t\tgoto destroy_export_cache;\n\n\tnn->svc_expkey_cache = cache_create_net(&svc_expkey_cache_template, net);\n\tif (IS_ERR(nn->svc_expkey_cache)) {\n\t\trv = PTR_ERR(nn->svc_expkey_cache);\n\t\tgoto unregister_export_cache;\n\t}\n\trv = cache_register_net(nn->svc_expkey_cache, net);\n\tif (rv)\n\t\tgoto destroy_expkey_cache;\n\treturn 0;\n\ndestroy_expkey_cache:\n\tcache_destroy_net(nn->svc_expkey_cache, net);\nunregister_export_cache:\n\tcache_unregister_net(nn->svc_export_cache, net);\ndestroy_export_cache:\n\tcache_destroy_net(nn->svc_export_cache, net);\n\treturn rv;\n}\n\n \nvoid\nnfsd_export_flush(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tcache_purge(nn->svc_expkey_cache);\n\tcache_purge(nn->svc_export_cache);\n}\n\n \nvoid\nnfsd_export_shutdown(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tdprintk(\"nfsd: shutting down export module (net: %x).\\n\", net->ns.inum);\n\n\tcache_unregister_net(nn->svc_expkey_cache, net);\n\tcache_unregister_net(nn->svc_export_cache, net);\n\tcache_destroy_net(nn->svc_expkey_cache, net);\n\tcache_destroy_net(nn->svc_export_cache, net);\n\tsvcauth_unix_purge(net);\n\n\tdprintk(\"nfsd: export shutdown complete (net: %x).\\n\", net->ns.inum);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}