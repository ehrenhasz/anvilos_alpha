{
  "module_name": "vfs.h",
  "hash_id": "56303cf5c4aa40302268833fb7dfd8ec6c0ee425f973905e8075bb7e05d42147",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfsd/vfs.h",
  "human_readable_source": " \n \n\n#ifndef LINUX_NFSD_VFS_H\n#define LINUX_NFSD_VFS_H\n\n#include <linux/fs.h>\n#include <linux/posix_acl.h>\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n\n \n#define NFSD_MAY_NOP\t\t\t0\n#define NFSD_MAY_EXEC\t\t\t0x001  \n#define NFSD_MAY_WRITE\t\t\t0x002  \n#define NFSD_MAY_READ\t\t\t0x004  \n#define NFSD_MAY_SATTR\t\t\t0x008\n#define NFSD_MAY_TRUNC\t\t\t0x010\n#define NFSD_MAY_LOCK\t\t\t0x020\n#define NFSD_MAY_MASK\t\t\t0x03f\n\n \n#define NFSD_MAY_OWNER_OVERRIDE\t\t0x040\n#define NFSD_MAY_LOCAL_ACCESS\t\t0x080  \n#define NFSD_MAY_BYPASS_GSS_ON_ROOT\t0x100\n#define NFSD_MAY_NOT_BREAK_LEASE\t0x200\n#define NFSD_MAY_BYPASS_GSS\t\t0x400\n#define NFSD_MAY_READ_IF_EXEC\t\t0x800\n\n#define NFSD_MAY_64BIT_COOKIE\t\t0x1000  \n\n#define NFSD_MAY_CREATE\t\t(NFSD_MAY_EXEC|NFSD_MAY_WRITE)\n#define NFSD_MAY_REMOVE\t\t(NFSD_MAY_EXEC|NFSD_MAY_WRITE|NFSD_MAY_TRUNC)\n\nstruct nfsd_file;\n\n \ntypedef int (*nfsd_filldir_t)(void *, const char *, int, loff_t, u64, unsigned);\n\n \nstruct nfsd_attrs {\n\tstruct iattr\t\t*na_iattr;\t \n\tstruct xdr_netobj\t*na_seclabel;\t \n\tstruct posix_acl\t*na_pacl;\t \n\tstruct posix_acl\t*na_dpacl;\t \n\n\tint\t\t\tna_labelerr;\t \n\tint\t\t\tna_aclerr;\t \n};\n\nstatic inline void nfsd_attrs_free(struct nfsd_attrs *attrs)\n{\n\tposix_acl_release(attrs->na_pacl);\n\tposix_acl_release(attrs->na_dpacl);\n}\n\n__be32\t\tnfserrno (int errno);\nint\t\tnfsd_cross_mnt(struct svc_rqst *rqstp, struct dentry **dpp,\n\t\t                struct svc_export **expp);\n__be32\t\tnfsd_lookup(struct svc_rqst *, struct svc_fh *,\n\t\t\t\tconst char *, unsigned int, struct svc_fh *);\n__be32\t\t nfsd_lookup_dentry(struct svc_rqst *, struct svc_fh *,\n\t\t\t\tconst char *, unsigned int,\n\t\t\t\tstruct svc_export **, struct dentry **);\n__be32\t\tnfsd_setattr(struct svc_rqst *, struct svc_fh *,\n\t\t\t\tstruct nfsd_attrs *, int, time64_t);\nint nfsd_mountpoint(struct dentry *, struct svc_export *);\n#ifdef CONFIG_NFSD_V4\n__be32\t\tnfsd4_vfs_fallocate(struct svc_rqst *, struct svc_fh *,\n\t\t\t\t    struct file *, loff_t, loff_t, int);\n__be32\t\tnfsd4_clone_file_range(struct svc_rqst *rqstp,\n\t\t\t\t       struct nfsd_file *nf_src, u64 src_pos,\n\t\t\t\t       struct nfsd_file *nf_dst, u64 dst_pos,\n\t\t\t\t       u64 count, bool sync);\n#endif  \n__be32\t\tnfsd_create_locked(struct svc_rqst *, struct svc_fh *,\n\t\t\t\tstruct nfsd_attrs *attrs, int type, dev_t rdev,\n\t\t\t\tstruct svc_fh *res);\n__be32\t\tnfsd_create(struct svc_rqst *, struct svc_fh *,\n\t\t\t\tchar *name, int len, struct nfsd_attrs *attrs,\n\t\t\t\tint type, dev_t rdev, struct svc_fh *res);\n__be32\t\tnfsd_access(struct svc_rqst *, struct svc_fh *, u32 *, u32 *);\n__be32\t\tnfsd_create_setattr(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\t\t\tstruct svc_fh *resfhp, struct nfsd_attrs *iap);\n__be32\t\tnfsd_commit(struct svc_rqst *rqst, struct svc_fh *fhp,\n\t\t\t\tstruct nfsd_file *nf, u64 offset, u32 count,\n\t\t\t\t__be32 *verf);\n#ifdef CONFIG_NFSD_V4\n__be32\t\tnfsd_getxattr(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\t\t    char *name, void **bufp, int *lenp);\n__be32\t\tnfsd_listxattr(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\t\t    char **bufp, int *lenp);\n__be32\t\tnfsd_removexattr(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\t\t    char *name);\n__be32\t\tnfsd_setxattr(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\t\t    char *name, void *buf, u32 len, u32 flags);\n#endif\nint \t\tnfsd_open_break_lease(struct inode *, int);\n__be32\t\tnfsd_open(struct svc_rqst *, struct svc_fh *, umode_t,\n\t\t\t\tint, struct file **);\nint\t\tnfsd_open_verified(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\t\t\t   int may_flags, struct file **filp);\n__be32\t\tnfsd_splice_read(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\t\t\tstruct file *file, loff_t offset,\n\t\t\t\tunsigned long *count,\n\t\t\t\tu32 *eof);\n__be32\t\tnfsd_iter_read(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\t\t\tstruct file *file, loff_t offset,\n\t\t\t\tunsigned long *count, unsigned int base,\n\t\t\t\tu32 *eof);\n__be32\t\tnfsd_read(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\t\t\tloff_t offset, unsigned long *count,\n\t\t\t\tu32 *eof);\n__be32 \t\tnfsd_write(struct svc_rqst *, struct svc_fh *, loff_t,\n\t\t\t\tstruct kvec *, int, unsigned long *,\n\t\t\t\tint stable, __be32 *verf);\n__be32\t\tnfsd_vfs_write(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\t\t\tstruct nfsd_file *nf, loff_t offset,\n\t\t\t\tstruct kvec *vec, int vlen, unsigned long *cnt,\n\t\t\t\tint stable, __be32 *verf);\n__be32\t\tnfsd_readlink(struct svc_rqst *, struct svc_fh *,\n\t\t\t\tchar *, int *);\n__be32\t\tnfsd_symlink(struct svc_rqst *, struct svc_fh *,\n\t\t\t     char *name, int len, char *path,\n\t\t\t     struct nfsd_attrs *attrs,\n\t\t\t     struct svc_fh *res);\n__be32\t\tnfsd_link(struct svc_rqst *, struct svc_fh *,\n\t\t\t\tchar *, int, struct svc_fh *);\nssize_t\t\tnfsd_copy_file_range(struct file *, u64,\n\t\t\t\t     struct file *, u64, u64);\n__be32\t\tnfsd_rename(struct svc_rqst *,\n\t\t\t\tstruct svc_fh *, char *, int,\n\t\t\t\tstruct svc_fh *, char *, int);\n__be32\t\tnfsd_unlink(struct svc_rqst *, struct svc_fh *, int type,\n\t\t\t\tchar *name, int len);\n__be32\t\tnfsd_readdir(struct svc_rqst *, struct svc_fh *,\n\t\t\t     loff_t *, struct readdir_cd *, nfsd_filldir_t);\n__be32\t\tnfsd_statfs(struct svc_rqst *, struct svc_fh *,\n\t\t\t\tstruct kstatfs *, int access);\n\n__be32\t\tnfsd_permission(struct svc_rqst *, struct svc_export *,\n\t\t\t\tstruct dentry *, int);\n\nstatic inline int fh_want_write(struct svc_fh *fh)\n{\n\tint ret;\n\n\tif (fh->fh_want_write)\n\t\treturn 0;\n\tret = mnt_want_write(fh->fh_export->ex_path.mnt);\n\tif (!ret)\n\t\tfh->fh_want_write = true;\n\treturn ret;\n}\n\nstatic inline void fh_drop_write(struct svc_fh *fh)\n{\n\tif (fh->fh_want_write) {\n\t\tfh->fh_want_write = false;\n\t\tmnt_drop_write(fh->fh_export->ex_path.mnt);\n\t}\n}\n\nstatic inline __be32 fh_getattr(const struct svc_fh *fh, struct kstat *stat)\n{\n\tu32 request_mask = STATX_BASIC_STATS;\n\tstruct path p = {.mnt = fh->fh_export->ex_path.mnt,\n\t\t\t .dentry = fh->fh_dentry};\n\n\tif (fh->fh_maxsize == NFS4_FHSIZE)\n\t\trequest_mask |= (STATX_BTIME | STATX_CHANGE_COOKIE);\n\n\treturn nfserrno(vfs_getattr(&p, stat, request_mask,\n\t\t\t\t    AT_STATX_SYNC_AS_STAT));\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}