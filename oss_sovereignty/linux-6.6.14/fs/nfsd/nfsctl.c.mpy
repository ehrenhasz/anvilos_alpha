{
  "module_name": "nfsctl.c",
  "hash_id": "383ba496efcabf5debdf0a45b69d0588503eff66bf5a6ab81474a850effb8056",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfsd/nfsctl.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/fs_context.h>\n\n#include <linux/sunrpc/svcsock.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n\n#include \"idmap.h\"\n#include \"nfsd.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"filecache.h\"\n#include \"trace.h\"\n\n \nenum {\n\tNFSD_Root = 1,\n\tNFSD_List,\n\tNFSD_Export_Stats,\n\tNFSD_Export_features,\n\tNFSD_Fh,\n\tNFSD_FO_UnlockIP,\n\tNFSD_FO_UnlockFS,\n\tNFSD_Threads,\n\tNFSD_Pool_Threads,\n\tNFSD_Pool_Stats,\n\tNFSD_Reply_Cache_Stats,\n\tNFSD_Versions,\n\tNFSD_Ports,\n\tNFSD_MaxBlkSize,\n\tNFSD_MaxConnections,\n\tNFSD_Filecache,\n\t \n#ifdef CONFIG_NFSD_V4\n\tNFSD_Leasetime,\n\tNFSD_Gracetime,\n\tNFSD_RecoveryDir,\n\tNFSD_V4EndGrace,\n#endif\n\tNFSD_MaxReserved\n};\n\n \nstatic ssize_t write_filehandle(struct file *file, char *buf, size_t size);\nstatic ssize_t write_unlock_ip(struct file *file, char *buf, size_t size);\nstatic ssize_t write_unlock_fs(struct file *file, char *buf, size_t size);\nstatic ssize_t write_threads(struct file *file, char *buf, size_t size);\nstatic ssize_t write_pool_threads(struct file *file, char *buf, size_t size);\nstatic ssize_t write_versions(struct file *file, char *buf, size_t size);\nstatic ssize_t write_ports(struct file *file, char *buf, size_t size);\nstatic ssize_t write_maxblksize(struct file *file, char *buf, size_t size);\nstatic ssize_t write_maxconn(struct file *file, char *buf, size_t size);\n#ifdef CONFIG_NFSD_V4\nstatic ssize_t write_leasetime(struct file *file, char *buf, size_t size);\nstatic ssize_t write_gracetime(struct file *file, char *buf, size_t size);\nstatic ssize_t write_recoverydir(struct file *file, char *buf, size_t size);\nstatic ssize_t write_v4_end_grace(struct file *file, char *buf, size_t size);\n#endif\n\nstatic ssize_t (*const write_op[])(struct file *, char *, size_t) = {\n\t[NFSD_Fh] = write_filehandle,\n\t[NFSD_FO_UnlockIP] = write_unlock_ip,\n\t[NFSD_FO_UnlockFS] = write_unlock_fs,\n\t[NFSD_Threads] = write_threads,\n\t[NFSD_Pool_Threads] = write_pool_threads,\n\t[NFSD_Versions] = write_versions,\n\t[NFSD_Ports] = write_ports,\n\t[NFSD_MaxBlkSize] = write_maxblksize,\n\t[NFSD_MaxConnections] = write_maxconn,\n#ifdef CONFIG_NFSD_V4\n\t[NFSD_Leasetime] = write_leasetime,\n\t[NFSD_Gracetime] = write_gracetime,\n\t[NFSD_RecoveryDir] = write_recoverydir,\n\t[NFSD_V4EndGrace] = write_v4_end_grace,\n#endif\n};\n\nstatic ssize_t nfsctl_transaction_write(struct file *file, const char __user *buf, size_t size, loff_t *pos)\n{\n\tino_t ino =  file_inode(file)->i_ino;\n\tchar *data;\n\tssize_t rv;\n\n\tif (ino >= ARRAY_SIZE(write_op) || !write_op[ino])\n\t\treturn -EINVAL;\n\n\tdata = simple_transaction_get(file, buf, size);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\trv = write_op[ino](file, data, size);\n\tif (rv < 0)\n\t\treturn rv;\n\n\tsimple_transaction_set(file, rv);\n\treturn size;\n}\n\nstatic ssize_t nfsctl_transaction_read(struct file *file, char __user *buf, size_t size, loff_t *pos)\n{\n\tif (! file->private_data) {\n\t\t \n\t\tssize_t rv = nfsctl_transaction_write(file, buf, 0, pos);\n\t\tif (rv < 0)\n\t\t\treturn rv;\n\t}\n\treturn simple_transaction_read(file, buf, size, pos);\n}\n\nstatic const struct file_operations transaction_ops = {\n\t.write\t\t= nfsctl_transaction_write,\n\t.read\t\t= nfsctl_transaction_read,\n\t.release\t= simple_transaction_release,\n\t.llseek\t\t= default_llseek,\n};\n\nstatic int exports_net_open(struct net *net, struct file *file)\n{\n\tint err;\n\tstruct seq_file *seq;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\terr = seq_open(file, &nfs_exports_op);\n\tif (err)\n\t\treturn err;\n\n\tseq = file->private_data;\n\tseq->private = nn->svc_export_cache;\n\treturn 0;\n}\n\nstatic int exports_nfsd_open(struct inode *inode, struct file *file)\n{\n\treturn exports_net_open(inode->i_sb->s_fs_info, file);\n}\n\nstatic const struct file_operations exports_nfsd_operations = {\n\t.open\t\t= exports_nfsd_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n};\n\nstatic int export_features_show(struct seq_file *m, void *v)\n{\n\tseq_printf(m, \"0x%x 0x%x\\n\", NFSEXP_ALLFLAGS, NFSEXP_SECINFO_FLAGS);\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(export_features);\n\nstatic const struct file_operations pool_stats_operations = {\n\t.open\t\t= nfsd_pool_stats_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= nfsd_pool_stats_release,\n};\n\nDEFINE_SHOW_ATTRIBUTE(nfsd_reply_cache_stats);\n\nDEFINE_SHOW_ATTRIBUTE(nfsd_file_cache_stats);\n\n \n \n\nstatic inline struct net *netns(struct file *file)\n{\n\treturn file_inode(file)->i_sb->s_fs_info;\n}\n\n \nstatic ssize_t write_unlock_ip(struct file *file, char *buf, size_t size)\n{\n\tstruct sockaddr_storage address;\n\tstruct sockaddr *sap = (struct sockaddr *)&address;\n\tsize_t salen = sizeof(address);\n\tchar *fo_path;\n\tstruct net *net = netns(file);\n\n\t \n\tif (size == 0)\n\t\treturn -EINVAL;\n\n\tif (buf[size-1] != '\\n')\n\t\treturn -EINVAL;\n\n\tfo_path = buf;\n\tif (qword_get(&buf, fo_path, size) < 0)\n\t\treturn -EINVAL;\n\n\tif (rpc_pton(net, fo_path, size, sap, salen) == 0)\n\t\treturn -EINVAL;\n\n\ttrace_nfsd_ctl_unlock_ip(net, buf);\n\treturn nlmsvc_unlock_all_by_ip(sap);\n}\n\n \nstatic ssize_t write_unlock_fs(struct file *file, char *buf, size_t size)\n{\n\tstruct path path;\n\tchar *fo_path;\n\tint error;\n\n\t \n\tif (size == 0)\n\t\treturn -EINVAL;\n\n\tif (buf[size-1] != '\\n')\n\t\treturn -EINVAL;\n\n\tfo_path = buf;\n\tif (qword_get(&buf, fo_path, size) < 0)\n\t\treturn -EINVAL;\n\ttrace_nfsd_ctl_unlock_fs(netns(file), fo_path);\n\terror = kern_path(fo_path, 0, &path);\n\tif (error)\n\t\treturn error;\n\n\t \n\terror = nlmsvc_unlock_all_by_sb(path.dentry->d_sb);\n\n\tpath_put(&path);\n\treturn error;\n}\n\n \nstatic ssize_t write_filehandle(struct file *file, char *buf, size_t size)\n{\n\tchar *dname, *path;\n\tint maxsize;\n\tchar *mesg = buf;\n\tint len;\n\tstruct auth_domain *dom;\n\tstruct knfsd_fh fh;\n\n\tif (size == 0)\n\t\treturn -EINVAL;\n\n\tif (buf[size-1] != '\\n')\n\t\treturn -EINVAL;\n\tbuf[size-1] = 0;\n\n\tdname = mesg;\n\tlen = qword_get(&mesg, dname, size);\n\tif (len <= 0)\n\t\treturn -EINVAL;\n\n\tpath = dname+len+1;\n\tlen = qword_get(&mesg, path, size);\n\tif (len <= 0)\n\t\treturn -EINVAL;\n\n\tlen = get_int(&mesg, &maxsize);\n\tif (len)\n\t\treturn len;\n\n\tif (maxsize < NFS_FHSIZE)\n\t\treturn -EINVAL;\n\tmaxsize = min(maxsize, NFS3_FHSIZE);\n\n\tif (qword_get(&mesg, mesg, size) > 0)\n\t\treturn -EINVAL;\n\n\ttrace_nfsd_ctl_filehandle(netns(file), dname, path, maxsize);\n\n\t \n\tdom = unix_domain_find(dname);\n\tif (!dom)\n\t\treturn -ENOMEM;\n\n\tlen = exp_rootfh(netns(file), dom, path, &fh, maxsize);\n\tauth_domain_put(dom);\n\tif (len)\n\t\treturn len;\n\n\tmesg = buf;\n\tlen = SIMPLE_TRANSACTION_LIMIT;\n\tqword_addhex(&mesg, &len, fh.fh_raw, fh.fh_size);\n\tmesg[-1] = '\\n';\n\treturn mesg - buf;\n}\n\n \nstatic ssize_t write_threads(struct file *file, char *buf, size_t size)\n{\n\tchar *mesg = buf;\n\tint rv;\n\tstruct net *net = netns(file);\n\n\tif (size > 0) {\n\t\tint newthreads;\n\t\trv = get_int(&mesg, &newthreads);\n\t\tif (rv)\n\t\t\treturn rv;\n\t\tif (newthreads < 0)\n\t\t\treturn -EINVAL;\n\t\ttrace_nfsd_ctl_threads(net, newthreads);\n\t\trv = nfsd_svc(newthreads, net, file->f_cred);\n\t\tif (rv < 0)\n\t\t\treturn rv;\n\t} else\n\t\trv = nfsd_nrthreads(net);\n\n\treturn scnprintf(buf, SIMPLE_TRANSACTION_LIMIT, \"%d\\n\", rv);\n}\n\n \nstatic ssize_t write_pool_threads(struct file *file, char *buf, size_t size)\n{\n\t \n\tchar *mesg = buf;\n\tint i;\n\tint rv;\n\tint len;\n\tint npools;\n\tint *nthreads;\n\tstruct net *net = netns(file);\n\n\tmutex_lock(&nfsd_mutex);\n\tnpools = nfsd_nrpools(net);\n\tif (npools == 0) {\n\t\t \n\t\tmutex_unlock(&nfsd_mutex);\n\t\tstrcpy(buf, \"0\\n\");\n\t\treturn strlen(buf);\n\t}\n\n\tnthreads = kcalloc(npools, sizeof(int), GFP_KERNEL);\n\trv = -ENOMEM;\n\tif (nthreads == NULL)\n\t\tgoto out_free;\n\n\tif (size > 0) {\n\t\tfor (i = 0; i < npools; i++) {\n\t\t\trv = get_int(&mesg, &nthreads[i]);\n\t\t\tif (rv == -ENOENT)\n\t\t\t\tbreak;\t\t \n\t\t\tif (rv)\n\t\t\t\tgoto out_free;\t \n\t\t\trv = -EINVAL;\n\t\t\tif (nthreads[i] < 0)\n\t\t\t\tgoto out_free;\n\t\t\ttrace_nfsd_ctl_pool_threads(net, i, nthreads[i]);\n\t\t}\n\t\trv = nfsd_set_nrthreads(i, nthreads, net);\n\t\tif (rv)\n\t\t\tgoto out_free;\n\t}\n\n\trv = nfsd_get_nrthreads(npools, nthreads, net);\n\tif (rv)\n\t\tgoto out_free;\n\n\tmesg = buf;\n\tsize = SIMPLE_TRANSACTION_LIMIT;\n\tfor (i = 0; i < npools && size > 0; i++) {\n\t\tsnprintf(mesg, size, \"%d%c\", nthreads[i], (i == npools-1 ? '\\n' : ' '));\n\t\tlen = strlen(mesg);\n\t\tsize -= len;\n\t\tmesg += len;\n\t}\n\trv = mesg - buf;\nout_free:\n\tkfree(nthreads);\n\tmutex_unlock(&nfsd_mutex);\n\treturn rv;\n}\n\nstatic ssize_t\nnfsd_print_version_support(struct nfsd_net *nn, char *buf, int remaining,\n\t\tconst char *sep, unsigned vers, int minor)\n{\n\tconst char *format = minor < 0 ? \"%s%c%u\" : \"%s%c%u.%u\";\n\tbool supported = !!nfsd_vers(nn, vers, NFSD_TEST);\n\n\tif (vers == 4 && minor >= 0 &&\n\t    !nfsd_minorversion(nn, minor, NFSD_TEST))\n\t\tsupported = false;\n\tif (minor == 0 && supported)\n\t\t \n\t\treturn 0;\n\treturn snprintf(buf, remaining, format, sep,\n\t\t\tsupported ? '+' : '-', vers, minor);\n}\n\nstatic ssize_t __write_versions(struct file *file, char *buf, size_t size)\n{\n\tchar *mesg = buf;\n\tchar *vers, *minorp, sign;\n\tint len, num, remaining;\n\tssize_t tlen = 0;\n\tchar *sep;\n\tstruct nfsd_net *nn = net_generic(netns(file), nfsd_net_id);\n\n\tif (size > 0) {\n\t\tif (nn->nfsd_serv)\n\t\t\t \n\t\t\treturn -EBUSY;\n\t\tif (buf[size-1] != '\\n')\n\t\t\treturn -EINVAL;\n\t\tbuf[size-1] = 0;\n\t\ttrace_nfsd_ctl_version(netns(file), buf);\n\n\t\tvers = mesg;\n\t\tlen = qword_get(&mesg, vers, size);\n\t\tif (len <= 0) return -EINVAL;\n\t\tdo {\n\t\t\tenum vers_op cmd;\n\t\t\tunsigned minor;\n\t\t\tsign = *vers;\n\t\t\tif (sign == '+' || sign == '-')\n\t\t\t\tnum = simple_strtol((vers+1), &minorp, 0);\n\t\t\telse\n\t\t\t\tnum = simple_strtol(vers, &minorp, 0);\n\t\t\tif (*minorp == '.') {\n\t\t\t\tif (num != 4)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tif (kstrtouint(minorp+1, 0, &minor) < 0)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tcmd = sign == '-' ? NFSD_CLEAR : NFSD_SET;\n\t\t\tswitch(num) {\n#ifdef CONFIG_NFSD_V2\n\t\t\tcase 2:\n#endif\n\t\t\tcase 3:\n\t\t\t\tnfsd_vers(nn, num, cmd);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tif (*minorp == '.') {\n\t\t\t\t\tif (nfsd_minorversion(nn, minor, cmd) < 0)\n\t\t\t\t\t\treturn -EINVAL;\n\t\t\t\t} else if ((cmd == NFSD_SET) != nfsd_vers(nn, num, NFSD_TEST)) {\n\t\t\t\t\t \n\t\t\t\t\tminor = 0;\n\t\t\t\t\twhile (nfsd_minorversion(nn, minor, cmd) >= 0)\n\t\t\t\t\t\tminor++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t \n\t\t\t\tif (cmd == NFSD_SET)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tvers += len + 1;\n\t\t} while ((len = qword_get(&mesg, vers, size)) > 0);\n\t\t \n\t\tnfsd_reset_versions(nn);\n\t}\n\n\t \n\tsep = \"\";\n\tremaining = SIMPLE_TRANSACTION_LIMIT;\n\tfor (num=2 ; num <= 4 ; num++) {\n\t\tint minor;\n\t\tif (!nfsd_vers(nn, num, NFSD_AVAIL))\n\t\t\tcontinue;\n\n\t\tminor = -1;\n\t\tdo {\n\t\t\tlen = nfsd_print_version_support(nn, buf, remaining,\n\t\t\t\t\tsep, num, minor);\n\t\t\tif (len >= remaining)\n\t\t\t\tgoto out;\n\t\t\tremaining -= len;\n\t\t\tbuf += len;\n\t\t\ttlen += len;\n\t\t\tminor++;\n\t\t\tif (len)\n\t\t\t\tsep = \" \";\n\t\t} while (num == 4 && minor <= NFSD_SUPPORTED_MINOR_VERSION);\n\t}\nout:\n\tlen = snprintf(buf, remaining, \"\\n\");\n\tif (len >= remaining)\n\t\treturn -EINVAL;\n\treturn tlen + len;\n}\n\n \nstatic ssize_t write_versions(struct file *file, char *buf, size_t size)\n{\n\tssize_t rv;\n\n\tmutex_lock(&nfsd_mutex);\n\trv = __write_versions(file, buf, size);\n\tmutex_unlock(&nfsd_mutex);\n\treturn rv;\n}\n\n \nstatic ssize_t __write_ports_names(char *buf, struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (nn->nfsd_serv == NULL)\n\t\treturn 0;\n\treturn svc_xprt_names(nn->nfsd_serv, buf, SIMPLE_TRANSACTION_LIMIT);\n}\n\n \nstatic ssize_t __write_ports_addfd(char *buf, struct net *net, const struct cred *cred)\n{\n\tchar *mesg = buf;\n\tint fd, err;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tstruct svc_serv *serv;\n\n\terr = get_int(&mesg, &fd);\n\tif (err != 0 || fd < 0)\n\t\treturn -EINVAL;\n\ttrace_nfsd_ctl_ports_addfd(net, fd);\n\n\terr = nfsd_create_serv(net);\n\tif (err != 0)\n\t\treturn err;\n\n\tserv = nn->nfsd_serv;\n\terr = svc_addsock(serv, net, fd, buf, SIMPLE_TRANSACTION_LIMIT, cred);\n\n\tif (err < 0 && !serv->sv_nrthreads && !nn->keep_active)\n\t\tnfsd_last_thread(net);\n\telse if (err >= 0 && !serv->sv_nrthreads && !xchg(&nn->keep_active, 1))\n\t\tsvc_get(serv);\n\n\tsvc_put(serv);\n\treturn err;\n}\n\n \nstatic ssize_t __write_ports_addxprt(char *buf, struct net *net, const struct cred *cred)\n{\n\tchar transport[16];\n\tstruct svc_xprt *xprt;\n\tint port, err;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tstruct svc_serv *serv;\n\n\tif (sscanf(buf, \"%15s %5u\", transport, &port) != 2)\n\t\treturn -EINVAL;\n\n\tif (port < 1 || port > USHRT_MAX)\n\t\treturn -EINVAL;\n\ttrace_nfsd_ctl_ports_addxprt(net, transport, port);\n\n\terr = nfsd_create_serv(net);\n\tif (err != 0)\n\t\treturn err;\n\n\tserv = nn->nfsd_serv;\n\terr = svc_xprt_create(serv, transport, net,\n\t\t\t      PF_INET, port, SVC_SOCK_ANONYMOUS, cred);\n\tif (err < 0)\n\t\tgoto out_err;\n\n\terr = svc_xprt_create(serv, transport, net,\n\t\t\t      PF_INET6, port, SVC_SOCK_ANONYMOUS, cred);\n\tif (err < 0 && err != -EAFNOSUPPORT)\n\t\tgoto out_close;\n\n\tif (!serv->sv_nrthreads && !xchg(&nn->keep_active, 1))\n\t\tsvc_get(serv);\n\n\tsvc_put(serv);\n\treturn 0;\nout_close:\n\txprt = svc_find_xprt(serv, transport, net, PF_INET, port);\n\tif (xprt != NULL) {\n\t\tsvc_xprt_close(xprt);\n\t\tsvc_xprt_put(xprt);\n\t}\nout_err:\n\tif (!serv->sv_nrthreads && !nn->keep_active)\n\t\tnfsd_last_thread(net);\n\n\tsvc_put(serv);\n\treturn err;\n}\n\nstatic ssize_t __write_ports(struct file *file, char *buf, size_t size,\n\t\t\t     struct net *net)\n{\n\tif (size == 0)\n\t\treturn __write_ports_names(buf, net);\n\n\tif (isdigit(buf[0]))\n\t\treturn __write_ports_addfd(buf, net, file->f_cred);\n\n\tif (isalpha(buf[0]))\n\t\treturn __write_ports_addxprt(buf, net, file->f_cred);\n\n\treturn -EINVAL;\n}\n\n \nstatic ssize_t write_ports(struct file *file, char *buf, size_t size)\n{\n\tssize_t rv;\n\n\tmutex_lock(&nfsd_mutex);\n\trv = __write_ports(file, buf, size, netns(file));\n\tmutex_unlock(&nfsd_mutex);\n\treturn rv;\n}\n\n\nint nfsd_max_blksize;\n\n \nstatic ssize_t write_maxblksize(struct file *file, char *buf, size_t size)\n{\n\tchar *mesg = buf;\n\tstruct nfsd_net *nn = net_generic(netns(file), nfsd_net_id);\n\n\tif (size > 0) {\n\t\tint bsize;\n\t\tint rv = get_int(&mesg, &bsize);\n\t\tif (rv)\n\t\t\treturn rv;\n\t\ttrace_nfsd_ctl_maxblksize(netns(file), bsize);\n\n\t\t \n\t\tbsize = max_t(int, bsize, 1024);\n\t\tbsize = min_t(int, bsize, NFSSVC_MAXBLKSIZE);\n\t\tbsize &= ~(1024-1);\n\t\tmutex_lock(&nfsd_mutex);\n\t\tif (nn->nfsd_serv) {\n\t\t\tmutex_unlock(&nfsd_mutex);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tnfsd_max_blksize = bsize;\n\t\tmutex_unlock(&nfsd_mutex);\n\t}\n\n\treturn scnprintf(buf, SIMPLE_TRANSACTION_LIMIT, \"%d\\n\",\n\t\t\t\t\t\t\tnfsd_max_blksize);\n}\n\n \nstatic ssize_t write_maxconn(struct file *file, char *buf, size_t size)\n{\n\tchar *mesg = buf;\n\tstruct nfsd_net *nn = net_generic(netns(file), nfsd_net_id);\n\tunsigned int maxconn = nn->max_connections;\n\n\tif (size > 0) {\n\t\tint rv = get_uint(&mesg, &maxconn);\n\n\t\tif (rv)\n\t\t\treturn rv;\n\t\ttrace_nfsd_ctl_maxconn(netns(file), maxconn);\n\t\tnn->max_connections = maxconn;\n\t}\n\n\treturn scnprintf(buf, SIMPLE_TRANSACTION_LIMIT, \"%u\\n\", maxconn);\n}\n\n#ifdef CONFIG_NFSD_V4\nstatic ssize_t __nfsd4_write_time(struct file *file, char *buf, size_t size,\n\t\t\t\t  time64_t *time, struct nfsd_net *nn)\n{\n\tstruct dentry *dentry = file_dentry(file);\n\tchar *mesg = buf;\n\tint rv, i;\n\n\tif (size > 0) {\n\t\tif (nn->nfsd_serv)\n\t\t\treturn -EBUSY;\n\t\trv = get_int(&mesg, &i);\n\t\tif (rv)\n\t\t\treturn rv;\n\t\ttrace_nfsd_ctl_time(netns(file), dentry->d_name.name,\n\t\t\t\t    dentry->d_name.len, i);\n\n\t\t \n\t\tif (i < 10 || i > 3600)\n\t\t\treturn -EINVAL;\n\t\t*time = i;\n\t}\n\n\treturn scnprintf(buf, SIMPLE_TRANSACTION_LIMIT, \"%lld\\n\", *time);\n}\n\nstatic ssize_t nfsd4_write_time(struct file *file, char *buf, size_t size,\n\t\t\t\ttime64_t *time, struct nfsd_net *nn)\n{\n\tssize_t rv;\n\n\tmutex_lock(&nfsd_mutex);\n\trv = __nfsd4_write_time(file, buf, size, time, nn);\n\tmutex_unlock(&nfsd_mutex);\n\treturn rv;\n}\n\n \nstatic ssize_t write_leasetime(struct file *file, char *buf, size_t size)\n{\n\tstruct nfsd_net *nn = net_generic(netns(file), nfsd_net_id);\n\treturn nfsd4_write_time(file, buf, size, &nn->nfsd4_lease, nn);\n}\n\n \nstatic ssize_t write_gracetime(struct file *file, char *buf, size_t size)\n{\n\tstruct nfsd_net *nn = net_generic(netns(file), nfsd_net_id);\n\treturn nfsd4_write_time(file, buf, size, &nn->nfsd4_grace, nn);\n}\n\nstatic ssize_t __write_recoverydir(struct file *file, char *buf, size_t size,\n\t\t\t\t   struct nfsd_net *nn)\n{\n\tchar *mesg = buf;\n\tchar *recdir;\n\tint len, status;\n\n\tif (size > 0) {\n\t\tif (nn->nfsd_serv)\n\t\t\treturn -EBUSY;\n\t\tif (size > PATH_MAX || buf[size-1] != '\\n')\n\t\t\treturn -EINVAL;\n\t\tbuf[size-1] = 0;\n\n\t\trecdir = mesg;\n\t\tlen = qword_get(&mesg, recdir, size);\n\t\tif (len <= 0)\n\t\t\treturn -EINVAL;\n\t\ttrace_nfsd_ctl_recoverydir(netns(file), recdir);\n\n\t\tstatus = nfs4_reset_recoverydir(recdir);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\n\treturn scnprintf(buf, SIMPLE_TRANSACTION_LIMIT, \"%s\\n\",\n\t\t\t\t\t\t\tnfs4_recoverydir());\n}\n\n \nstatic ssize_t write_recoverydir(struct file *file, char *buf, size_t size)\n{\n\tssize_t rv;\n\tstruct nfsd_net *nn = net_generic(netns(file), nfsd_net_id);\n\n\tmutex_lock(&nfsd_mutex);\n\trv = __write_recoverydir(file, buf, size, nn);\n\tmutex_unlock(&nfsd_mutex);\n\treturn rv;\n}\n\n \nstatic ssize_t write_v4_end_grace(struct file *file, char *buf, size_t size)\n{\n\tstruct nfsd_net *nn = net_generic(netns(file), nfsd_net_id);\n\n\tif (size > 0) {\n\t\tswitch(buf[0]) {\n\t\tcase 'Y':\n\t\tcase 'y':\n\t\tcase '1':\n\t\t\tif (!nn->nfsd_serv)\n\t\t\t\treturn -EBUSY;\n\t\t\ttrace_nfsd_end_grace(netns(file));\n\t\t\tnfsd4_end_grace(nn);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn scnprintf(buf, SIMPLE_TRANSACTION_LIMIT, \"%c\\n\",\n\t\t\t nn->grace_ended ? 'Y' : 'N');\n}\n\n#endif\n\n \n \n\n \nstatic struct inode *nfsd_get_inode(struct super_block *sb, umode_t mode)\n{\n\tstruct inode *inode = new_inode(sb);\n\tif (!inode)\n\t\treturn NULL;\n\t \n\tinode->i_ino = iunique(sb, NFSD_MaxReserved);\n\tinode->i_mode = mode;\n\tinode->i_atime = inode->i_mtime = inode_set_ctime_current(inode);\n\tswitch (mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_fop = &simple_dir_operations;\n\t\tinode->i_op = &simple_dir_inode_operations;\n\t\tinc_nlink(inode);\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &simple_symlink_inode_operations;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn inode;\n}\n\nstatic int __nfsd_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode, struct nfsdfs_client *ncl)\n{\n\tstruct inode *inode;\n\n\tinode = nfsd_get_inode(dir->i_sb, mode);\n\tif (!inode)\n\t\treturn -ENOMEM;\n\tif (ncl) {\n\t\tinode->i_private = ncl;\n\t\tkref_get(&ncl->cl_ref);\n\t}\n\td_add(dentry, inode);\n\tinc_nlink(dir);\n\tfsnotify_mkdir(dir, dentry);\n\treturn 0;\n}\n\nstatic struct dentry *nfsd_mkdir(struct dentry *parent, struct nfsdfs_client *ncl, char *name)\n{\n\tstruct inode *dir = parent->d_inode;\n\tstruct dentry *dentry;\n\tint ret = -ENOMEM;\n\n\tinode_lock(dir);\n\tdentry = d_alloc_name(parent, name);\n\tif (!dentry)\n\t\tgoto out_err;\n\tret = __nfsd_mkdir(d_inode(parent), dentry, S_IFDIR | 0600, ncl);\n\tif (ret)\n\t\tgoto out_err;\nout:\n\tinode_unlock(dir);\n\treturn dentry;\nout_err:\n\tdput(dentry);\n\tdentry = ERR_PTR(ret);\n\tgoto out;\n}\n\n#if IS_ENABLED(CONFIG_SUNRPC_GSS)\nstatic int __nfsd_symlink(struct inode *dir, struct dentry *dentry,\n\t\t\t  umode_t mode, const char *content)\n{\n\tstruct inode *inode;\n\n\tinode = nfsd_get_inode(dir->i_sb, mode);\n\tif (!inode)\n\t\treturn -ENOMEM;\n\n\tinode->i_link = (char *)content;\n\tinode->i_size = strlen(content);\n\n\td_add(dentry, inode);\n\tinc_nlink(dir);\n\tfsnotify_create(dir, dentry);\n\treturn 0;\n}\n\n \nstatic void _nfsd_symlink(struct dentry *parent, const char *name,\n\t\t\t  const char *content)\n{\n\tstruct inode *dir = parent->d_inode;\n\tstruct dentry *dentry;\n\tint ret;\n\n\tinode_lock(dir);\n\tdentry = d_alloc_name(parent, name);\n\tif (!dentry)\n\t\tgoto out;\n\tret = __nfsd_symlink(d_inode(parent), dentry, S_IFLNK | 0777, content);\n\tif (ret)\n\t\tdput(dentry);\nout:\n\tinode_unlock(dir);\n}\n#else\nstatic inline void _nfsd_symlink(struct dentry *parent, const char *name,\n\t\t\t\t const char *content)\n{\n}\n\n#endif\n\nstatic void clear_ncl(struct inode *inode)\n{\n\tstruct nfsdfs_client *ncl = inode->i_private;\n\n\tinode->i_private = NULL;\n\tkref_put(&ncl->cl_ref, ncl->cl_release);\n}\n\nstatic struct nfsdfs_client *__get_nfsdfs_client(struct inode *inode)\n{\n\tstruct nfsdfs_client *nc = inode->i_private;\n\n\tif (nc)\n\t\tkref_get(&nc->cl_ref);\n\treturn nc;\n}\n\nstruct nfsdfs_client *get_nfsdfs_client(struct inode *inode)\n{\n\tstruct nfsdfs_client *nc;\n\n\tinode_lock_shared(inode);\n\tnc = __get_nfsdfs_client(inode);\n\tinode_unlock_shared(inode);\n\treturn nc;\n}\n \nstatic void nfsdfs_remove_file(struct inode *dir, struct dentry *dentry)\n{\n\tint ret;\n\n\tclear_ncl(d_inode(dentry));\n\tdget(dentry);\n\tret = simple_unlink(dir, dentry);\n\td_drop(dentry);\n\tfsnotify_unlink(dir, dentry);\n\tdput(dentry);\n\tWARN_ON_ONCE(ret);\n}\n\nstatic void nfsdfs_remove_files(struct dentry *root)\n{\n\tstruct dentry *dentry, *tmp;\n\n\tlist_for_each_entry_safe(dentry, tmp, &root->d_subdirs, d_child) {\n\t\tif (!simple_positive(dentry)) {\n\t\t\tWARN_ON_ONCE(1);  \n\t\t\tcontinue;\n\t\t}\n\t\tnfsdfs_remove_file(d_inode(root), dentry);\n\t}\n}\n\n \nstatic  int nfsdfs_create_files(struct dentry *root,\n\t\t\t\tconst struct tree_descr *files,\n\t\t\t\tstruct dentry **fdentries)\n{\n\tstruct inode *dir = d_inode(root);\n\tstruct inode *inode;\n\tstruct dentry *dentry;\n\tint i;\n\n\tinode_lock(dir);\n\tfor (i = 0; files->name && files->name[0]; i++, files++) {\n\t\tdentry = d_alloc_name(root, files->name);\n\t\tif (!dentry)\n\t\t\tgoto out;\n\t\tinode = nfsd_get_inode(d_inode(root)->i_sb,\n\t\t\t\t\tS_IFREG | files->mode);\n\t\tif (!inode) {\n\t\t\tdput(dentry);\n\t\t\tgoto out;\n\t\t}\n\t\tinode->i_fop = files->ops;\n\t\tinode->i_private = __get_nfsdfs_client(dir);\n\t\td_add(dentry, inode);\n\t\tfsnotify_create(dir, dentry);\n\t\tif (fdentries)\n\t\t\tfdentries[i] = dentry;\n\t}\n\tinode_unlock(dir);\n\treturn 0;\nout:\n\tnfsdfs_remove_files(root);\n\tinode_unlock(dir);\n\treturn -ENOMEM;\n}\n\n \nstruct dentry *nfsd_client_mkdir(struct nfsd_net *nn,\n\t\t\t\t struct nfsdfs_client *ncl, u32 id,\n\t\t\t\t const struct tree_descr *files,\n\t\t\t\t struct dentry **fdentries)\n{\n\tstruct dentry *dentry;\n\tchar name[11];\n\tint ret;\n\n\tsprintf(name, \"%u\", id);\n\n\tdentry = nfsd_mkdir(nn->nfsd_client_dir, ncl, name);\n\tif (IS_ERR(dentry))  \n\t\treturn NULL;\n\tret = nfsdfs_create_files(dentry, files, fdentries);\n\tif (ret) {\n\t\tnfsd_client_rmdir(dentry);\n\t\treturn NULL;\n\t}\n\treturn dentry;\n}\n\n \nvoid nfsd_client_rmdir(struct dentry *dentry)\n{\n\tstruct inode *dir = d_inode(dentry->d_parent);\n\tstruct inode *inode = d_inode(dentry);\n\tint ret;\n\n\tinode_lock(dir);\n\tnfsdfs_remove_files(dentry);\n\tclear_ncl(inode);\n\tdget(dentry);\n\tret = simple_rmdir(dir, dentry);\n\tWARN_ON_ONCE(ret);\n\td_drop(dentry);\n\tfsnotify_rmdir(dir, dentry);\n\tdput(dentry);\n\tinode_unlock(dir);\n}\n\nstatic int nfsd_fill_super(struct super_block *sb, struct fs_context *fc)\n{\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\t\tnfsd_net_id);\n\tstruct dentry *dentry;\n\tint ret;\n\n\tstatic const struct tree_descr nfsd_files[] = {\n\t\t[NFSD_List] = {\"exports\", &exports_nfsd_operations, S_IRUGO},\n\t\t \n\t\t[NFSD_Export_Stats] = {\"export_stats\", &exports_nfsd_operations, S_IRUGO},\n\t\t[NFSD_Export_features] = {\"export_features\",\n\t\t\t\t\t&export_features_fops, S_IRUGO},\n\t\t[NFSD_FO_UnlockIP] = {\"unlock_ip\",\n\t\t\t\t\t&transaction_ops, S_IWUSR|S_IRUSR},\n\t\t[NFSD_FO_UnlockFS] = {\"unlock_filesystem\",\n\t\t\t\t\t&transaction_ops, S_IWUSR|S_IRUSR},\n\t\t[NFSD_Fh] = {\"filehandle\", &transaction_ops, S_IWUSR|S_IRUSR},\n\t\t[NFSD_Threads] = {\"threads\", &transaction_ops, S_IWUSR|S_IRUSR},\n\t\t[NFSD_Pool_Threads] = {\"pool_threads\", &transaction_ops, S_IWUSR|S_IRUSR},\n\t\t[NFSD_Pool_Stats] = {\"pool_stats\", &pool_stats_operations, S_IRUGO},\n\t\t[NFSD_Reply_Cache_Stats] = {\"reply_cache_stats\",\n\t\t\t\t\t&nfsd_reply_cache_stats_fops, S_IRUGO},\n\t\t[NFSD_Versions] = {\"versions\", &transaction_ops, S_IWUSR|S_IRUSR},\n\t\t[NFSD_Ports] = {\"portlist\", &transaction_ops, S_IWUSR|S_IRUGO},\n\t\t[NFSD_MaxBlkSize] = {\"max_block_size\", &transaction_ops, S_IWUSR|S_IRUGO},\n\t\t[NFSD_MaxConnections] = {\"max_connections\", &transaction_ops, S_IWUSR|S_IRUGO},\n\t\t[NFSD_Filecache] = {\"filecache\", &nfsd_file_cache_stats_fops, S_IRUGO},\n#ifdef CONFIG_NFSD_V4\n\t\t[NFSD_Leasetime] = {\"nfsv4leasetime\", &transaction_ops, S_IWUSR|S_IRUSR},\n\t\t[NFSD_Gracetime] = {\"nfsv4gracetime\", &transaction_ops, S_IWUSR|S_IRUSR},\n\t\t[NFSD_RecoveryDir] = {\"nfsv4recoverydir\", &transaction_ops, S_IWUSR|S_IRUSR},\n\t\t[NFSD_V4EndGrace] = {\"v4_end_grace\", &transaction_ops, S_IWUSR|S_IRUGO},\n#endif\n\t\t  {\"\"}\n\t};\n\n\tret = simple_fill_super(sb, 0x6e667364, nfsd_files);\n\tif (ret)\n\t\treturn ret;\n\t_nfsd_symlink(sb->s_root, \"supported_krb5_enctypes\",\n\t\t      \"/proc/net/rpc/gss_krb5_enctypes\");\n\tdentry = nfsd_mkdir(sb->s_root, NULL, \"clients\");\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\tnn->nfsd_client_dir = dentry;\n\treturn 0;\n}\n\nstatic int nfsd_fs_get_tree(struct fs_context *fc)\n{\n\treturn get_tree_keyed(fc, nfsd_fill_super, get_net(fc->net_ns));\n}\n\nstatic void nfsd_fs_free_fc(struct fs_context *fc)\n{\n\tif (fc->s_fs_info)\n\t\tput_net(fc->s_fs_info);\n}\n\nstatic const struct fs_context_operations nfsd_fs_context_ops = {\n\t.free\t\t= nfsd_fs_free_fc,\n\t.get_tree\t= nfsd_fs_get_tree,\n};\n\nstatic int nfsd_init_fs_context(struct fs_context *fc)\n{\n\tput_user_ns(fc->user_ns);\n\tfc->user_ns = get_user_ns(fc->net_ns->user_ns);\n\tfc->ops = &nfsd_fs_context_ops;\n\treturn 0;\n}\n\nstatic void nfsd_umount(struct super_block *sb)\n{\n\tstruct net *net = sb->s_fs_info;\n\n\tnfsd_shutdown_threads(net);\n\n\tkill_litter_super(sb);\n\tput_net(net);\n}\n\nstatic struct file_system_type nfsd_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"nfsd\",\n\t.init_fs_context = nfsd_init_fs_context,\n\t.kill_sb\t= nfsd_umount,\n};\nMODULE_ALIAS_FS(\"nfsd\");\n\n#ifdef CONFIG_PROC_FS\n\nstatic int exports_proc_open(struct inode *inode, struct file *file)\n{\n\treturn exports_net_open(current->nsproxy->net_ns, file);\n}\n\nstatic const struct proc_ops exports_proc_ops = {\n\t.proc_open\t= exports_proc_open,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_release\t= seq_release,\n};\n\nstatic int create_proc_exports_entry(void)\n{\n\tstruct proc_dir_entry *entry;\n\n\tentry = proc_mkdir(\"fs/nfs\", NULL);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\tentry = proc_create(\"exports\", 0, entry, &exports_proc_ops);\n\tif (!entry) {\n\t\tremove_proc_entry(\"fs/nfs\", NULL);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n#else  \nstatic int create_proc_exports_entry(void)\n{\n\treturn 0;\n}\n#endif\n\nunsigned int nfsd_net_id;\n\n \nstatic __net_init int nfsd_net_init(struct net *net)\n{\n\tint retval;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tretval = nfsd_export_init(net);\n\tif (retval)\n\t\tgoto out_export_error;\n\tretval = nfsd_idmap_init(net);\n\tif (retval)\n\t\tgoto out_idmap_error;\n\tretval = nfsd_net_reply_cache_init(nn);\n\tif (retval)\n\t\tgoto out_repcache_error;\n\tnn->nfsd_versions = NULL;\n\tnn->nfsd4_minorversions = NULL;\n\tnfsd4_init_leases_net(nn);\n\tget_random_bytes(&nn->siphash_key, sizeof(nn->siphash_key));\n\tseqlock_init(&nn->writeverf_lock);\n\n\treturn 0;\n\nout_repcache_error:\n\tnfsd_idmap_shutdown(net);\nout_idmap_error:\n\tnfsd_export_shutdown(net);\nout_export_error:\n\treturn retval;\n}\n\n \nstatic __net_exit void nfsd_net_exit(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tnfsd_net_reply_cache_destroy(nn);\n\tnfsd_idmap_shutdown(net);\n\tnfsd_export_shutdown(net);\n\tnfsd_netns_free_versions(nn);\n}\n\nstatic struct pernet_operations nfsd_net_ops = {\n\t.init = nfsd_net_init,\n\t.exit = nfsd_net_exit,\n\t.id   = &nfsd_net_id,\n\t.size = sizeof(struct nfsd_net),\n};\n\nstatic int __init init_nfsd(void)\n{\n\tint retval;\n\n\tretval = nfsd4_init_slabs();\n\tif (retval)\n\t\treturn retval;\n\tretval = nfsd4_init_pnfs();\n\tif (retval)\n\t\tgoto out_free_slabs;\n\tretval = nfsd_stat_init();\t \n\tif (retval)\n\t\tgoto out_free_pnfs;\n\tretval = nfsd_drc_slab_create();\n\tif (retval)\n\t\tgoto out_free_stat;\n\tnfsd_lockd_init();\t \n\tretval = create_proc_exports_entry();\n\tif (retval)\n\t\tgoto out_free_lockd;\n\tretval = register_pernet_subsys(&nfsd_net_ops);\n\tif (retval < 0)\n\t\tgoto out_free_exports;\n\tretval = register_cld_notifier();\n\tif (retval)\n\t\tgoto out_free_subsys;\n\tretval = nfsd4_create_laundry_wq();\n\tif (retval)\n\t\tgoto out_free_cld;\n\tretval = register_filesystem(&nfsd_fs_type);\n\tif (retval)\n\t\tgoto out_free_all;\n\treturn 0;\nout_free_all:\n\tnfsd4_destroy_laundry_wq();\nout_free_cld:\n\tunregister_cld_notifier();\nout_free_subsys:\n\tunregister_pernet_subsys(&nfsd_net_ops);\nout_free_exports:\n\tremove_proc_entry(\"fs/nfs/exports\", NULL);\n\tremove_proc_entry(\"fs/nfs\", NULL);\nout_free_lockd:\n\tnfsd_lockd_shutdown();\n\tnfsd_drc_slab_free();\nout_free_stat:\n\tnfsd_stat_shutdown();\nout_free_pnfs:\n\tnfsd4_exit_pnfs();\nout_free_slabs:\n\tnfsd4_free_slabs();\n\treturn retval;\n}\n\nstatic void __exit exit_nfsd(void)\n{\n\tunregister_filesystem(&nfsd_fs_type);\n\tnfsd4_destroy_laundry_wq();\n\tunregister_cld_notifier();\n\tunregister_pernet_subsys(&nfsd_net_ops);\n\tnfsd_drc_slab_free();\n\tremove_proc_entry(\"fs/nfs/exports\", NULL);\n\tremove_proc_entry(\"fs/nfs\", NULL);\n\tnfsd_stat_shutdown();\n\tnfsd_lockd_shutdown();\n\tnfsd4_free_slabs();\n\tnfsd4_exit_pnfs();\n}\n\nMODULE_AUTHOR(\"Olaf Kirch <okir@monad.swb.de>\");\nMODULE_DESCRIPTION(\"In-kernel NFS server\");\nMODULE_LICENSE(\"GPL\");\nmodule_init(init_nfsd)\nmodule_exit(exit_nfsd)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}