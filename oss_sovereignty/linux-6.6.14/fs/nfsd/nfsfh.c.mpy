{
  "module_name": "nfsfh.c",
  "hash_id": "77c4d0bf0af9c16bf33a451f82eef4442cf22588bee4287b4ff3e1542edb3070",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfsd/nfsfh.c",
  "human_readable_source": "\n \n\n#include <linux/exportfs.h>\n\n#include <linux/sunrpc/svcauth_gss.h>\n#include \"nfsd.h\"\n#include \"vfs.h\"\n#include \"auth.h\"\n#include \"trace.h\"\n\n#define NFSDDBG_FACILITY\t\tNFSDDBG_FH\n\n\n \nstatic int nfsd_acceptable(void *expv, struct dentry *dentry)\n{\n\tstruct svc_export *exp = expv;\n\tint rv;\n\tstruct dentry *tdentry;\n\tstruct dentry *parent;\n\n\tif (exp->ex_flags & NFSEXP_NOSUBTREECHECK)\n\t\treturn 1;\n\n\ttdentry = dget(dentry);\n\twhile (tdentry != exp->ex_path.dentry && !IS_ROOT(tdentry)) {\n\t\t \n\t\tint err;\n\t\tparent = dget_parent(tdentry);\n\t\terr = inode_permission(&nop_mnt_idmap,\n\t\t\t\t       d_inode(parent), MAY_EXEC);\n\t\tif (err < 0) {\n\t\t\tdput(parent);\n\t\t\tbreak;\n\t\t}\n\t\tdput(tdentry);\n\t\ttdentry = parent;\n\t}\n\tif (tdentry != exp->ex_path.dentry)\n\t\tdprintk(\"nfsd_acceptable failed at %p %pd\\n\", tdentry, tdentry);\n\trv = (tdentry == exp->ex_path.dentry);\n\tdput(tdentry);\n\treturn rv;\n}\n\n \nstatic inline __be32\nnfsd_mode_check(struct svc_rqst *rqstp, struct dentry *dentry,\n\t\tumode_t requested)\n{\n\tumode_t mode = d_inode(dentry)->i_mode & S_IFMT;\n\n\tif (requested == 0)  \n\t\treturn nfs_ok;\n\tif (mode == requested) {\n\t\tif (mode == S_IFDIR && !d_can_lookup(dentry)) {\n\t\t\tWARN_ON_ONCE(1);\n\t\t\treturn nfserr_notdir;\n\t\t}\n\t\treturn nfs_ok;\n\t}\n\t \n\tif (rqstp->rq_vers == 4 && mode == S_IFLNK)\n\t\treturn nfserr_symlink;\n\tif (requested == S_IFDIR)\n\t\treturn nfserr_notdir;\n\tif (mode == S_IFDIR)\n\t\treturn nfserr_isdir;\n\treturn nfserr_inval;\n}\n\nstatic bool nfsd_originating_port_ok(struct svc_rqst *rqstp, int flags)\n{\n\tif (flags & NFSEXP_INSECURE_PORT)\n\t\treturn true;\n\t \n\tif (rqstp->rq_cred.cr_flavor >= RPC_AUTH_GSS)\n\t\treturn true;\n\treturn test_bit(RQ_SECURE, &rqstp->rq_flags);\n}\n\nstatic __be32 nfsd_setuser_and_check_port(struct svc_rqst *rqstp,\n\t\t\t\t\t  struct svc_export *exp)\n{\n\tint flags = nfsexp_flags(rqstp, exp);\n\n\t \n\tif (!nfsd_originating_port_ok(rqstp, flags)) {\n\t\tRPC_IFDEBUG(char buf[RPC_MAX_ADDRBUFLEN]);\n\t\tdprintk(\"nfsd: request from insecure port %s!\\n\",\n\t\t        svc_print_addr(rqstp, buf, sizeof(buf)));\n\t\treturn nfserr_perm;\n\t}\n\n\t \n\treturn nfserrno(nfsd_setuser(rqstp, exp));\n}\n\nstatic inline __be32 check_pseudo_root(struct svc_rqst *rqstp,\n\tstruct dentry *dentry, struct svc_export *exp)\n{\n\tif (!(exp->ex_flags & NFSEXP_V4ROOT))\n\t\treturn nfs_ok;\n\t \n\tif (!nfsd_v4client(rqstp))\n\t\treturn nfserr_stale;\n\t \n\tif (unlikely(!d_is_dir(dentry) &&\n\t\t     !d_is_symlink(dentry)))\n\t\treturn nfserr_stale;\n\t \n\tif (unlikely(dentry != exp->ex_path.dentry))\n\t\treturn nfserr_stale;\n\treturn nfs_ok;\n}\n\n \nstatic __be32 nfsd_set_fh_dentry(struct svc_rqst *rqstp, struct svc_fh *fhp)\n{\n\tstruct knfsd_fh\t*fh = &fhp->fh_handle;\n\tstruct fid *fid = NULL;\n\tstruct svc_export *exp;\n\tstruct dentry *dentry;\n\tint fileid_type;\n\tint data_left = fh->fh_size/4;\n\tint len;\n\t__be32 error;\n\n\terror = nfserr_stale;\n\tif (rqstp->rq_vers > 2)\n\t\terror = nfserr_badhandle;\n\tif (rqstp->rq_vers == 4 && fh->fh_size == 0)\n\t\treturn nfserr_nofilehandle;\n\n\tif (fh->fh_version != 1)\n\t\treturn error;\n\n\tif (--data_left < 0)\n\t\treturn error;\n\tif (fh->fh_auth_type != 0)\n\t\treturn error;\n\tlen = key_len(fh->fh_fsid_type) / 4;\n\tif (len == 0)\n\t\treturn error;\n\tif (fh->fh_fsid_type == FSID_MAJOR_MINOR) {\n\t\t \n\t\tlen = key_len(FSID_ENCODE_DEV)/4;\n\t\tfh->fh_fsid_type = FSID_ENCODE_DEV;\n\t\t \n\t\tfh->fh_fsid[0] = new_encode_dev(MKDEV(ntohl((__force __be32)fh->fh_fsid[0]),\n\t\t\t\t\t\t      ntohl((__force __be32)fh->fh_fsid[1])));\n\t\tfh->fh_fsid[1] = fh->fh_fsid[2];\n\t}\n\tdata_left -= len;\n\tif (data_left < 0)\n\t\treturn error;\n\texp = rqst_exp_find(rqstp, fh->fh_fsid_type, fh->fh_fsid);\n\tfid = (struct fid *)(fh->fh_fsid + len);\n\n\terror = nfserr_stale;\n\tif (IS_ERR(exp)) {\n\t\ttrace_nfsd_set_fh_dentry_badexport(rqstp, fhp, PTR_ERR(exp));\n\n\t\tif (PTR_ERR(exp) == -ENOENT)\n\t\t\treturn error;\n\n\t\treturn nfserrno(PTR_ERR(exp));\n\t}\n\n\tif (exp->ex_flags & NFSEXP_NOSUBTREECHECK) {\n\t\t \n\t\tstruct cred *new = prepare_creds();\n\t\tif (!new) {\n\t\t\terror =  nfserrno(-ENOMEM);\n\t\t\tgoto out;\n\t\t}\n\t\tnew->cap_effective =\n\t\t\tcap_raise_nfsd_set(new->cap_effective,\n\t\t\t\t\t   new->cap_permitted);\n\t\tput_cred(override_creds(new));\n\t\tput_cred(new);\n\t} else {\n\t\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\t \n\terror = nfserr_stale;\n\tif (rqstp->rq_vers > 2)\n\t\terror = nfserr_badhandle;\n\n\tfileid_type = fh->fh_fileid_type;\n\n\tif (fileid_type == FILEID_ROOT)\n\t\tdentry = dget(exp->ex_path.dentry);\n\telse {\n\t\tdentry = exportfs_decode_fh_raw(exp->ex_path.mnt, fid,\n\t\t\t\t\t\tdata_left, fileid_type,\n\t\t\t\t\t\tnfsd_acceptable, exp);\n\t\tif (IS_ERR_OR_NULL(dentry)) {\n\t\t\ttrace_nfsd_set_fh_dentry_badhandle(rqstp, fhp,\n\t\t\t\t\tdentry ?  PTR_ERR(dentry) : -ESTALE);\n\t\t\tswitch (PTR_ERR(dentry)) {\n\t\t\tcase -ENOMEM:\n\t\t\tcase -ETIMEDOUT:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdentry = ERR_PTR(-ESTALE);\n\t\t\t}\n\t\t}\n\t}\n\tif (dentry == NULL)\n\t\tgoto out;\n\tif (IS_ERR(dentry)) {\n\t\tif (PTR_ERR(dentry) != -EINVAL)\n\t\t\terror = nfserrno(PTR_ERR(dentry));\n\t\tgoto out;\n\t}\n\n\tif (d_is_dir(dentry) &&\n\t\t\t(dentry->d_flags & DCACHE_DISCONNECTED)) {\n\t\tprintk(\"nfsd: find_fh_dentry returned a DISCONNECTED directory: %pd2\\n\",\n\t\t\t\tdentry);\n\t}\n\n\tfhp->fh_dentry = dentry;\n\tfhp->fh_export = exp;\n\n\tswitch (rqstp->rq_vers) {\n\tcase 4:\n\t\tif (dentry->d_sb->s_export_op->flags & EXPORT_OP_NOATOMIC_ATTR)\n\t\t\tfhp->fh_no_atomic_attr = true;\n\t\tbreak;\n\tcase 3:\n\t\tif (dentry->d_sb->s_export_op->flags & EXPORT_OP_NOWCC)\n\t\t\tfhp->fh_no_wcc = true;\n\t\tbreak;\n\tcase 2:\n\t\tfhp->fh_no_wcc = true;\n\t}\n\n\treturn 0;\nout:\n\texp_put(exp);\n\treturn error;\n}\n\n \n__be32\nfh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type, int access)\n{\n\tstruct svc_export *exp = NULL;\n\tstruct dentry\t*dentry;\n\t__be32\t\terror;\n\n\tif (!fhp->fh_dentry) {\n\t\terror = nfsd_set_fh_dentry(rqstp, fhp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tdentry = fhp->fh_dentry;\n\texp = fhp->fh_export;\n\n\ttrace_nfsd_fh_verify(rqstp, fhp, type, access);\n\n\t \n\terror = check_pseudo_root(rqstp, dentry, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_mode_check(rqstp, dentry, type);\n\tif (error)\n\t\tgoto out;\n\n\t \n\tif (access & NFSD_MAY_LOCK || access & NFSD_MAY_BYPASS_GSS)\n\t\tgoto skip_pseudoflavor_check;\n\t \n\tif (access & NFSD_MAY_BYPASS_GSS_ON_ROOT\n\t\t\t&& exp->ex_path.dentry == dentry)\n\t\tgoto skip_pseudoflavor_check;\n\n\terror = check_nfsd_access(exp, rqstp);\n\tif (error)\n\t\tgoto out;\n\nskip_pseudoflavor_check:\n\t \n\terror = nfsd_permission(rqstp, exp, dentry, access);\nout:\n\ttrace_nfsd_fh_verify_err(rqstp, fhp, type, access, error);\n\tif (error == nfserr_stale)\n\t\tnfsd_stats_fh_stale_inc(exp);\n\treturn error;\n}\n\n\n \nstatic void _fh_update(struct svc_fh *fhp, struct svc_export *exp,\n\t\tstruct dentry *dentry)\n{\n\tif (dentry != exp->ex_path.dentry) {\n\t\tstruct fid *fid = (struct fid *)\n\t\t\t(fhp->fh_handle.fh_fsid + fhp->fh_handle.fh_size/4 - 1);\n\t\tint maxsize = (fhp->fh_maxsize - fhp->fh_handle.fh_size)/4;\n\t\tint fh_flags = (exp->ex_flags & NFSEXP_NOSUBTREECHECK) ? 0 :\n\t\t\t\tEXPORT_FH_CONNECTABLE;\n\t\tint fileid_type =\n\t\t\texportfs_encode_fh(dentry, fid, &maxsize, fh_flags);\n\n\t\tfhp->fh_handle.fh_fileid_type =\n\t\t\tfileid_type > 0 ? fileid_type : FILEID_INVALID;\n\t\tfhp->fh_handle.fh_size += maxsize * 4;\n\t} else {\n\t\tfhp->fh_handle.fh_fileid_type = FILEID_ROOT;\n\t}\n}\n\nstatic bool is_root_export(struct svc_export *exp)\n{\n\treturn exp->ex_path.dentry == exp->ex_path.dentry->d_sb->s_root;\n}\n\nstatic struct super_block *exp_sb(struct svc_export *exp)\n{\n\treturn exp->ex_path.dentry->d_sb;\n}\n\nstatic bool fsid_type_ok_for_exp(u8 fsid_type, struct svc_export *exp)\n{\n\tswitch (fsid_type) {\n\tcase FSID_DEV:\n\t\tif (!old_valid_dev(exp_sb(exp)->s_dev))\n\t\t\treturn false;\n\t\tfallthrough;\n\tcase FSID_MAJOR_MINOR:\n\tcase FSID_ENCODE_DEV:\n\t\treturn exp_sb(exp)->s_type->fs_flags & FS_REQUIRES_DEV;\n\tcase FSID_NUM:\n\t\treturn exp->ex_flags & NFSEXP_FSID;\n\tcase FSID_UUID8:\n\tcase FSID_UUID16:\n\t\tif (!is_root_export(exp))\n\t\t\treturn false;\n\t\tfallthrough;\n\tcase FSID_UUID4_INUM:\n\tcase FSID_UUID16_INUM:\n\t\treturn exp->ex_uuid != NULL;\n\t}\n\treturn true;\n}\n\n\nstatic void set_version_and_fsid_type(struct svc_fh *fhp, struct svc_export *exp, struct svc_fh *ref_fh)\n{\n\tu8 version;\n\tu8 fsid_type;\nretry:\n\tversion = 1;\n\tif (ref_fh && ref_fh->fh_export == exp) {\n\t\tversion = ref_fh->fh_handle.fh_version;\n\t\tfsid_type = ref_fh->fh_handle.fh_fsid_type;\n\n\t\tref_fh = NULL;\n\n\t\tswitch (version) {\n\t\tcase 0xca:\n\t\t\tfsid_type = FSID_DEV;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto retry;\n\t\t}\n\n\t\t \n\t\tif (!fsid_type_ok_for_exp(fsid_type, exp))\n\t\t\tgoto retry;\n\t} else if (exp->ex_flags & NFSEXP_FSID) {\n\t\tfsid_type = FSID_NUM;\n\t} else if (exp->ex_uuid) {\n\t\tif (fhp->fh_maxsize >= 64) {\n\t\t\tif (is_root_export(exp))\n\t\t\t\tfsid_type = FSID_UUID16;\n\t\t\telse\n\t\t\t\tfsid_type = FSID_UUID16_INUM;\n\t\t} else {\n\t\t\tif (is_root_export(exp))\n\t\t\t\tfsid_type = FSID_UUID8;\n\t\t\telse\n\t\t\t\tfsid_type = FSID_UUID4_INUM;\n\t\t}\n\t} else if (!old_valid_dev(exp_sb(exp)->s_dev))\n\t\t \n\t\tfsid_type = FSID_ENCODE_DEV;\n\telse\n\t\tfsid_type = FSID_DEV;\n\tfhp->fh_handle.fh_version = version;\n\tif (version)\n\t\tfhp->fh_handle.fh_fsid_type = fsid_type;\n}\n\n__be32\nfh_compose(struct svc_fh *fhp, struct svc_export *exp, struct dentry *dentry,\n\t   struct svc_fh *ref_fh)\n{\n\t \n\n\tstruct inode * inode = d_inode(dentry);\n\tdev_t ex_dev = exp_sb(exp)->s_dev;\n\n\tdprintk(\"nfsd: fh_compose(exp %02x:%02x/%ld %pd2, ino=%ld)\\n\",\n\t\tMAJOR(ex_dev), MINOR(ex_dev),\n\t\t(long) d_inode(exp->ex_path.dentry)->i_ino,\n\t\tdentry,\n\t\t(inode ? inode->i_ino : 0));\n\n\t \n\tset_version_and_fsid_type(fhp, exp, ref_fh);\n\n\t \n\tfhp->fh_no_wcc = ref_fh ? ref_fh->fh_no_wcc : false;\n\n\tif (ref_fh == fhp)\n\t\tfh_put(ref_fh);\n\n\tif (fhp->fh_dentry) {\n\t\tprintk(KERN_ERR \"fh_compose: fh %pd2 not initialized!\\n\",\n\t\t       dentry);\n\t}\n\tif (fhp->fh_maxsize < NFS_FHSIZE)\n\t\tprintk(KERN_ERR \"fh_compose: called with maxsize %d! %pd2\\n\",\n\t\t       fhp->fh_maxsize,\n\t\t       dentry);\n\n\tfhp->fh_dentry = dget(dentry);  \n\tfhp->fh_export = exp_get(exp);\n\n\tfhp->fh_handle.fh_size =\n\t\tkey_len(fhp->fh_handle.fh_fsid_type) + 4;\n\tfhp->fh_handle.fh_auth_type = 0;\n\n\tmk_fsid(fhp->fh_handle.fh_fsid_type,\n\t\tfhp->fh_handle.fh_fsid,\n\t\tex_dev,\n\t\td_inode(exp->ex_path.dentry)->i_ino,\n\t\texp->ex_fsid, exp->ex_uuid);\n\n\tif (inode)\n\t\t_fh_update(fhp, exp, dentry);\n\tif (fhp->fh_handle.fh_fileid_type == FILEID_INVALID) {\n\t\tfh_put(fhp);\n\t\treturn nfserr_opnotsupp;\n\t}\n\n\treturn 0;\n}\n\n \n__be32\nfh_update(struct svc_fh *fhp)\n{\n\tstruct dentry *dentry;\n\n\tif (!fhp->fh_dentry)\n\t\tgoto out_bad;\n\n\tdentry = fhp->fh_dentry;\n\tif (d_really_is_negative(dentry))\n\t\tgoto out_negative;\n\tif (fhp->fh_handle.fh_fileid_type != FILEID_ROOT)\n\t\treturn 0;\n\n\t_fh_update(fhp, fhp->fh_export, dentry);\n\tif (fhp->fh_handle.fh_fileid_type == FILEID_INVALID)\n\t\treturn nfserr_opnotsupp;\n\treturn 0;\nout_bad:\n\tprintk(KERN_ERR \"fh_update: fh not verified!\\n\");\n\treturn nfserr_serverfault;\nout_negative:\n\tprintk(KERN_ERR \"fh_update: %pd2 still negative!\\n\",\n\t\tdentry);\n\treturn nfserr_serverfault;\n}\n\n \n__be32 __must_check fh_fill_pre_attrs(struct svc_fh *fhp)\n{\n\tbool v4 = (fhp->fh_maxsize == NFS4_FHSIZE);\n\tstruct inode *inode;\n\tstruct kstat stat;\n\t__be32 err;\n\n\tif (fhp->fh_no_wcc || fhp->fh_pre_saved)\n\t\treturn nfs_ok;\n\n\tinode = d_inode(fhp->fh_dentry);\n\terr = fh_getattr(fhp, &stat);\n\tif (err)\n\t\treturn err;\n\n\tif (v4)\n\t\tfhp->fh_pre_change = nfsd4_change_attribute(&stat, inode);\n\n\tfhp->fh_pre_mtime = stat.mtime;\n\tfhp->fh_pre_ctime = stat.ctime;\n\tfhp->fh_pre_size  = stat.size;\n\tfhp->fh_pre_saved = true;\n\treturn nfs_ok;\n}\n\n \n__be32 fh_fill_post_attrs(struct svc_fh *fhp)\n{\n\tbool v4 = (fhp->fh_maxsize == NFS4_FHSIZE);\n\tstruct inode *inode = d_inode(fhp->fh_dentry);\n\t__be32 err;\n\n\tif (fhp->fh_no_wcc)\n\t\treturn nfs_ok;\n\n\tif (fhp->fh_post_saved)\n\t\tprintk(\"nfsd: inode locked twice during operation.\\n\");\n\n\terr = fh_getattr(fhp, &fhp->fh_post_attr);\n\tif (err)\n\t\treturn err;\n\n\tfhp->fh_post_saved = true;\n\tif (v4)\n\t\tfhp->fh_post_change =\n\t\t\tnfsd4_change_attribute(&fhp->fh_post_attr, inode);\n\treturn nfs_ok;\n}\n\n \n__be32 __must_check fh_fill_both_attrs(struct svc_fh *fhp)\n{\n\t__be32 err;\n\n\terr = fh_fill_post_attrs(fhp);\n\tif (err)\n\t\treturn err;\n\n\tfhp->fh_pre_change = fhp->fh_post_change;\n\tfhp->fh_pre_mtime = fhp->fh_post_attr.mtime;\n\tfhp->fh_pre_ctime = fhp->fh_post_attr.ctime;\n\tfhp->fh_pre_size = fhp->fh_post_attr.size;\n\tfhp->fh_pre_saved = true;\n\treturn nfs_ok;\n}\n\n \nvoid\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n\t\tfh_clear_pre_post_attrs(fhp);\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\tfhp->fh_no_wcc = false;\n\treturn;\n}\n\n \nchar * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\tstatic char buf[2+1+1+64*3+1];\n\n\tif (fh->fh_size < 0 || fh->fh_size> 64)\n\t\treturn \"bad-fh\";\n\tsprintf(buf, \"%d: %*ph\", fh->fh_size, fh->fh_size, fh->fh_raw);\n\treturn buf;\n}\n\nenum fsid_source fsid_source(const struct svc_fh *fhp)\n{\n\tif (fhp->fh_handle.fh_version != 1)\n\t\treturn FSIDSOURCE_DEV;\n\tswitch(fhp->fh_handle.fh_fsid_type) {\n\tcase FSID_DEV:\n\tcase FSID_ENCODE_DEV:\n\tcase FSID_MAJOR_MINOR:\n\t\tif (exp_sb(fhp->fh_export)->s_type->fs_flags & FS_REQUIRES_DEV)\n\t\t\treturn FSIDSOURCE_DEV;\n\t\tbreak;\n\tcase FSID_NUM:\n\t\tif (fhp->fh_export->ex_flags & NFSEXP_FSID)\n\t\t\treturn FSIDSOURCE_FSID;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\t \n\tif (fhp->fh_export->ex_flags & NFSEXP_FSID)\n\t\treturn FSIDSOURCE_FSID;\n\tif (fhp->fh_export->ex_uuid)\n\t\treturn FSIDSOURCE_UUID;\n\treturn FSIDSOURCE_DEV;\n}\n\n \nu64 nfsd4_change_attribute(struct kstat *stat, struct inode *inode)\n{\n\tu64 chattr;\n\n\tif (stat->result_mask & STATX_CHANGE_COOKIE) {\n\t\tchattr = stat->change_cookie;\n\t\tif (S_ISREG(inode->i_mode) &&\n\t\t    !(stat->attributes & STATX_ATTR_CHANGE_MONOTONIC)) {\n\t\t\tchattr += (u64)stat->ctime.tv_sec << 30;\n\t\t\tchattr += stat->ctime.tv_nsec;\n\t\t}\n\t} else {\n\t\tchattr = time_to_chattr(&stat->ctime);\n\t}\n\treturn chattr;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}