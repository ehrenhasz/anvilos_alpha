{
  "module_name": "auth.c",
  "hash_id": "28261b4d0f2ecd87005017b839653dcfd299a1a3c20aa8962e3583e7968b07e1",
  "original_prompt": "Ingested from linux-6.6.14/fs/nfsd/auth.c",
  "human_readable_source": "\n \n\n#include <linux/sched.h>\n#include \"nfsd.h\"\n#include \"auth.h\"\n\nint nfsexp_flags(struct svc_rqst *rqstp, struct svc_export *exp)\n{\n\tstruct exp_flavor_info *f;\n\tstruct exp_flavor_info *end = exp->ex_flavors + exp->ex_nflavors;\n\n\tfor (f = exp->ex_flavors; f < end; f++) {\n\t\tif (f->pseudoflavor == rqstp->rq_cred.cr_flavor)\n\t\t\treturn f->flags;\n\t}\n\treturn exp->ex_flags;\n\n}\n\nint nfsd_setuser(struct svc_rqst *rqstp, struct svc_export *exp)\n{\n\tstruct group_info *rqgi;\n\tstruct group_info *gi;\n\tstruct cred *new;\n\tint i;\n\tint flags = nfsexp_flags(rqstp, exp);\n\n\t \n\trevert_creds(get_cred(current_real_cred()));\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tnew->fsuid = rqstp->rq_cred.cr_uid;\n\tnew->fsgid = rqstp->rq_cred.cr_gid;\n\n\trqgi = rqstp->rq_cred.cr_group_info;\n\n\tif (flags & NFSEXP_ALLSQUASH) {\n\t\tnew->fsuid = exp->ex_anon_uid;\n\t\tnew->fsgid = exp->ex_anon_gid;\n\t\tgi = groups_alloc(0);\n\t\tif (!gi)\n\t\t\tgoto oom;\n\t} else if (flags & NFSEXP_ROOTSQUASH) {\n\t\tif (uid_eq(new->fsuid, GLOBAL_ROOT_UID))\n\t\t\tnew->fsuid = exp->ex_anon_uid;\n\t\tif (gid_eq(new->fsgid, GLOBAL_ROOT_GID))\n\t\t\tnew->fsgid = exp->ex_anon_gid;\n\n\t\tgi = groups_alloc(rqgi->ngroups);\n\t\tif (!gi)\n\t\t\tgoto oom;\n\n\t\tfor (i = 0; i < rqgi->ngroups; i++) {\n\t\t\tif (gid_eq(GLOBAL_ROOT_GID, rqgi->gid[i]))\n\t\t\t\tgi->gid[i] = exp->ex_anon_gid;\n\t\t\telse\n\t\t\t\tgi->gid[i] = rqgi->gid[i];\n\t\t}\n\n\t\t \n\t\tgroups_sort(gi);\n\t} else {\n\t\tgi = get_group_info(rqgi);\n\t}\n\n\tif (uid_eq(new->fsuid, INVALID_UID))\n\t\tnew->fsuid = exp->ex_anon_uid;\n\tif (gid_eq(new->fsgid, INVALID_GID))\n\t\tnew->fsgid = exp->ex_anon_gid;\n\n\tset_groups(new, gi);\n\tput_group_info(gi);\n\n\tif (!uid_eq(new->fsuid, GLOBAL_ROOT_UID))\n\t\tnew->cap_effective = cap_drop_nfsd_set(new->cap_effective);\n\telse\n\t\tnew->cap_effective = cap_raise_nfsd_set(new->cap_effective,\n\t\t\t\t\t\t\tnew->cap_permitted);\n\tput_cred(override_creds(new));\n\tput_cred(new);\n\treturn 0;\n\noom:\n\tabort_creds(new);\n\treturn -ENOMEM;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}