{
  "module_name": "coredump.c",
  "hash_id": "e742001370c980f35647157f8746ce6f984dc5d66803802a6dc5c6d0db1a9928",
  "original_prompt": "Ingested from linux-6.6.14/fs/coredump.c",
  "human_readable_source": "\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/swap.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/perf_event.h>\n#include <linux/highmem.h>\n#include <linux/spinlock.h>\n#include <linux/key.h>\n#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/coredump.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/task_stack.h>\n#include <linux/utsname.h>\n#include <linux/pid_namespace.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/tsacct_kern.h>\n#include <linux/cn_proc.h>\n#include <linux/audit.h>\n#include <linux/kmod.h>\n#include <linux/fsnotify.h>\n#include <linux/fs_struct.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/oom.h>\n#include <linux/compat.h>\n#include <linux/fs.h>\n#include <linux/path.h>\n#include <linux/timekeeping.h>\n#include <linux/sysctl.h>\n#include <linux/elf.h>\n\n#include <linux/uaccess.h>\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/exec.h>\n\n#include <trace/events/task.h>\n#include \"internal.h\"\n\n#include <trace/events/sched.h>\n\nstatic bool dump_vma_snapshot(struct coredump_params *cprm);\nstatic void free_vma_snapshot(struct coredump_params *cprm);\n\nstatic int core_uses_pid;\nstatic unsigned int core_pipe_limit;\nstatic char core_pattern[CORENAME_MAX_SIZE] = \"core\";\nstatic int core_name_size = CORENAME_MAX_SIZE;\n\nstruct core_name {\n\tchar *corename;\n\tint used, size;\n};\n\nstatic int expand_corename(struct core_name *cn, int size)\n{\n\tchar *corename;\n\n\tsize = kmalloc_size_roundup(size);\n\tcorename = krealloc(cn->corename, size, GFP_KERNEL);\n\n\tif (!corename)\n\t\treturn -ENOMEM;\n\n\tif (size > core_name_size)  \n\t\tcore_name_size = size;\n\n\tcn->size = size;\n\tcn->corename = corename;\n\treturn 0;\n}\n\nstatic __printf(2, 0) int cn_vprintf(struct core_name *cn, const char *fmt,\n\t\t\t\t     va_list arg)\n{\n\tint free, need;\n\tva_list arg_copy;\n\nagain:\n\tfree = cn->size - cn->used;\n\n\tva_copy(arg_copy, arg);\n\tneed = vsnprintf(cn->corename + cn->used, free, fmt, arg_copy);\n\tva_end(arg_copy);\n\n\tif (need < free) {\n\t\tcn->used += need;\n\t\treturn 0;\n\t}\n\n\tif (!expand_corename(cn, cn->size + need - free + 1))\n\t\tgoto again;\n\n\treturn -ENOMEM;\n}\n\nstatic __printf(2, 3) int cn_printf(struct core_name *cn, const char *fmt, ...)\n{\n\tva_list arg;\n\tint ret;\n\n\tva_start(arg, fmt);\n\tret = cn_vprintf(cn, fmt, arg);\n\tva_end(arg);\n\n\treturn ret;\n}\n\nstatic __printf(2, 3)\nint cn_esc_printf(struct core_name *cn, const char *fmt, ...)\n{\n\tint cur = cn->used;\n\tva_list arg;\n\tint ret;\n\n\tva_start(arg, fmt);\n\tret = cn_vprintf(cn, fmt, arg);\n\tva_end(arg);\n\n\tif (ret == 0) {\n\t\t \n\t\tif ((cn->used - cur == 1 && cn->corename[cur] == '.') ||\n\t\t\t\t(cn->used - cur == 2 && cn->corename[cur] == '.'\n\t\t\t\t&& cn->corename[cur+1] == '.'))\n\t\t\tcn->corename[cur] = '!';\n\n\t\t \n\t\tif (cn->used == cur)\n\t\t\tret = cn_printf(cn, \"!\");\n\t}\n\n\tfor (; cur < cn->used; ++cur) {\n\t\tif (cn->corename[cur] == '/')\n\t\t\tcn->corename[cur] = '!';\n\t}\n\treturn ret;\n}\n\nstatic int cn_print_exe_file(struct core_name *cn, bool name_only)\n{\n\tstruct file *exe_file;\n\tchar *pathbuf, *path, *ptr;\n\tint ret;\n\n\texe_file = get_mm_exe_file(current->mm);\n\tif (!exe_file)\n\t\treturn cn_esc_printf(cn, \"%s (path unknown)\", current->comm);\n\n\tpathbuf = kmalloc(PATH_MAX, GFP_KERNEL);\n\tif (!pathbuf) {\n\t\tret = -ENOMEM;\n\t\tgoto put_exe_file;\n\t}\n\n\tpath = file_path(exe_file, pathbuf, PATH_MAX);\n\tif (IS_ERR(path)) {\n\t\tret = PTR_ERR(path);\n\t\tgoto free_buf;\n\t}\n\n\tif (name_only) {\n\t\tptr = strrchr(path, '/');\n\t\tif (ptr)\n\t\t\tpath = ptr + 1;\n\t}\n\tret = cn_esc_printf(cn, \"%s\", path);\n\nfree_buf:\n\tkfree(pathbuf);\nput_exe_file:\n\tfput(exe_file);\n\treturn ret;\n}\n\n \nstatic int format_corename(struct core_name *cn, struct coredump_params *cprm,\n\t\t\t   size_t **argv, int *argc)\n{\n\tconst struct cred *cred = current_cred();\n\tconst char *pat_ptr = core_pattern;\n\tint ispipe = (*pat_ptr == '|');\n\tbool was_space = false;\n\tint pid_in_pattern = 0;\n\tint err = 0;\n\n\tcn->used = 0;\n\tcn->corename = NULL;\n\tif (expand_corename(cn, core_name_size))\n\t\treturn -ENOMEM;\n\tcn->corename[0] = '\\0';\n\n\tif (ispipe) {\n\t\tint argvs = sizeof(core_pattern) / 2;\n\t\t(*argv) = kmalloc_array(argvs, sizeof(**argv), GFP_KERNEL);\n\t\tif (!(*argv))\n\t\t\treturn -ENOMEM;\n\t\t(*argv)[(*argc)++] = 0;\n\t\t++pat_ptr;\n\t\tif (!(*pat_ptr))\n\t\t\treturn -ENOMEM;\n\t}\n\n\t \n\twhile (*pat_ptr) {\n\t\t \n\t\tif (ispipe) {\n\t\t\tif (isspace(*pat_ptr)) {\n\t\t\t\tif (cn->used != 0)\n\t\t\t\t\twas_space = true;\n\t\t\t\tpat_ptr++;\n\t\t\t\tcontinue;\n\t\t\t} else if (was_space) {\n\t\t\t\twas_space = false;\n\t\t\t\terr = cn_printf(cn, \"%c\", '\\0');\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t\t(*argv)[(*argc)++] = cn->used;\n\t\t\t}\n\t\t}\n\t\tif (*pat_ptr != '%') {\n\t\t\terr = cn_printf(cn, \"%c\", *pat_ptr++);\n\t\t} else {\n\t\t\tswitch (*++pat_ptr) {\n\t\t\t \n\t\t\tcase 0:\n\t\t\t\tgoto out;\n\t\t\t \n\t\t\tcase '%':\n\t\t\t\terr = cn_printf(cn, \"%c\", '%');\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tcase 'p':\n\t\t\t\tpid_in_pattern = 1;\n\t\t\t\terr = cn_printf(cn, \"%d\",\n\t\t\t\t\t      task_tgid_vnr(current));\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tcase 'P':\n\t\t\t\terr = cn_printf(cn, \"%d\",\n\t\t\t\t\t      task_tgid_nr(current));\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\terr = cn_printf(cn, \"%d\",\n\t\t\t\t\t      task_pid_vnr(current));\n\t\t\t\tbreak;\n\t\t\tcase 'I':\n\t\t\t\terr = cn_printf(cn, \"%d\",\n\t\t\t\t\t      task_pid_nr(current));\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tcase 'u':\n\t\t\t\terr = cn_printf(cn, \"%u\",\n\t\t\t\t\t\tfrom_kuid(&init_user_ns,\n\t\t\t\t\t\t\t  cred->uid));\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tcase 'g':\n\t\t\t\terr = cn_printf(cn, \"%u\",\n\t\t\t\t\t\tfrom_kgid(&init_user_ns,\n\t\t\t\t\t\t\t  cred->gid));\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\terr = cn_printf(cn, \"%d\",\n\t\t\t\t\t__get_dumpable(cprm->mm_flags));\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tcase 's':\n\t\t\t\terr = cn_printf(cn, \"%d\",\n\t\t\t\t\t\tcprm->siginfo->si_signo);\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tcase 't': {\n\t\t\t\ttime64_t time;\n\n\t\t\t\ttime = ktime_get_real_seconds();\n\t\t\t\terr = cn_printf(cn, \"%lld\", time);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tcase 'h':\n\t\t\t\tdown_read(&uts_sem);\n\t\t\t\terr = cn_esc_printf(cn, \"%s\",\n\t\t\t\t\t      utsname()->nodename);\n\t\t\t\tup_read(&uts_sem);\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tcase 'e':\n\t\t\t\terr = cn_esc_printf(cn, \"%s\", current->comm);\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tcase 'f':\n\t\t\t\terr = cn_print_exe_file(cn, true);\n\t\t\t\tbreak;\n\t\t\tcase 'E':\n\t\t\t\terr = cn_print_exe_file(cn, false);\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tcase 'c':\n\t\t\t\terr = cn_printf(cn, \"%lu\",\n\t\t\t\t\t      rlimit(RLIMIT_CORE));\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tcase 'C':\n\t\t\t\terr = cn_printf(cn, \"%d\", cprm->cpu);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t++pat_ptr;\n\t\t}\n\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\nout:\n\t \n\tif (!ispipe && !pid_in_pattern && core_uses_pid) {\n\t\terr = cn_printf(cn, \".%d\", task_tgid_vnr(current));\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn ispipe;\n}\n\nstatic int zap_process(struct task_struct *start, int exit_code)\n{\n\tstruct task_struct *t;\n\tint nr = 0;\n\n\t \n\tstart->signal->flags = SIGNAL_GROUP_EXIT;\n\tstart->signal->group_exit_code = exit_code;\n\tstart->signal->group_stop_count = 0;\n\n\tfor_each_thread(start, t) {\n\t\ttask_clear_jobctl_pending(t, JOBCTL_PENDING_MASK);\n\t\tif (t != current && !(t->flags & PF_POSTCOREDUMP)) {\n\t\t\tsigaddset(&t->pending.signal, SIGKILL);\n\t\t\tsignal_wake_up(t, 1);\n\t\t\t \n\t\t\tif ((t->flags & (PF_USER_WORKER | PF_IO_WORKER)) != PF_USER_WORKER)\n\t\t\t\tnr++;\n\t\t}\n\t}\n\n\treturn nr;\n}\n\nstatic int zap_threads(struct task_struct *tsk,\n\t\t\tstruct core_state *core_state, int exit_code)\n{\n\tstruct signal_struct *signal = tsk->signal;\n\tint nr = -EAGAIN;\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\tif (!(signal->flags & SIGNAL_GROUP_EXIT) && !signal->group_exec_task) {\n\t\tsignal->core_state = core_state;\n\t\tnr = zap_process(tsk, exit_code);\n\t\tclear_tsk_thread_flag(tsk, TIF_SIGPENDING);\n\t\ttsk->flags |= PF_DUMPCORE;\n\t\tatomic_set(&core_state->nr_threads, nr);\n\t}\n\tspin_unlock_irq(&tsk->sighand->siglock);\n\treturn nr;\n}\n\nstatic int coredump_wait(int exit_code, struct core_state *core_state)\n{\n\tstruct task_struct *tsk = current;\n\tint core_waiters = -EBUSY;\n\n\tinit_completion(&core_state->startup);\n\tcore_state->dumper.task = tsk;\n\tcore_state->dumper.next = NULL;\n\n\tcore_waiters = zap_threads(tsk, core_state, exit_code);\n\tif (core_waiters > 0) {\n\t\tstruct core_thread *ptr;\n\n\t\twait_for_completion_state(&core_state->startup,\n\t\t\t\t\t  TASK_UNINTERRUPTIBLE|TASK_FREEZABLE);\n\t\t \n\t\tptr = core_state->dumper.next;\n\t\twhile (ptr != NULL) {\n\t\t\twait_task_inactive(ptr->task, TASK_ANY);\n\t\t\tptr = ptr->next;\n\t\t}\n\t}\n\n\treturn core_waiters;\n}\n\nstatic void coredump_finish(bool core_dumped)\n{\n\tstruct core_thread *curr, *next;\n\tstruct task_struct *task;\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tif (core_dumped && !__fatal_signal_pending(current))\n\t\tcurrent->signal->group_exit_code |= 0x80;\n\tnext = current->signal->core_state->dumper.next;\n\tcurrent->signal->core_state = NULL;\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\twhile ((curr = next) != NULL) {\n\t\tnext = curr->next;\n\t\ttask = curr->task;\n\t\t \n\t\tsmp_mb();\n\t\tcurr->task = NULL;\n\t\twake_up_process(task);\n\t}\n}\n\nstatic bool dump_interrupted(void)\n{\n\t \n\treturn fatal_signal_pending(current) || freezing(current);\n}\n\nstatic void wait_for_dump_helpers(struct file *file)\n{\n\tstruct pipe_inode_info *pipe = file->private_data;\n\n\tpipe_lock(pipe);\n\tpipe->readers++;\n\tpipe->writers--;\n\twake_up_interruptible_sync(&pipe->rd_wait);\n\tkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);\n\tpipe_unlock(pipe);\n\n\t \n\twait_event_interruptible(pipe->rd_wait, pipe->readers == 1);\n\n\tpipe_lock(pipe);\n\tpipe->readers--;\n\tpipe->writers++;\n\tpipe_unlock(pipe);\n}\n\n \nstatic int umh_pipe_setup(struct subprocess_info *info, struct cred *new)\n{\n\tstruct file *files[2];\n\tstruct coredump_params *cp = (struct coredump_params *)info->data;\n\tint err = create_pipe_files(files, 0);\n\tif (err)\n\t\treturn err;\n\n\tcp->file = files[1];\n\n\terr = replace_fd(0, files[0], 0);\n\tfput(files[0]);\n\t \n\tcurrent->signal->rlim[RLIMIT_CORE] = (struct rlimit){1, 1};\n\n\treturn err;\n}\n\nvoid do_coredump(const kernel_siginfo_t *siginfo)\n{\n\tstruct core_state core_state;\n\tstruct core_name cn;\n\tstruct mm_struct *mm = current->mm;\n\tstruct linux_binfmt * binfmt;\n\tconst struct cred *old_cred;\n\tstruct cred *cred;\n\tint retval = 0;\n\tint ispipe;\n\tsize_t *argv = NULL;\n\tint argc = 0;\n\t \n\tbool need_suid_safe = false;\n\tbool core_dumped = false;\n\tstatic atomic_t core_dump_count = ATOMIC_INIT(0);\n\tstruct coredump_params cprm = {\n\t\t.siginfo = siginfo,\n\t\t.limit = rlimit(RLIMIT_CORE),\n\t\t \n\t\t.mm_flags = mm->flags,\n\t\t.vma_meta = NULL,\n\t\t.cpu = raw_smp_processor_id(),\n\t};\n\n\taudit_core_dumps(siginfo->si_signo);\n\n\tbinfmt = mm->binfmt;\n\tif (!binfmt || !binfmt->core_dump)\n\t\tgoto fail;\n\tif (!__get_dumpable(cprm.mm_flags))\n\t\tgoto fail;\n\n\tcred = prepare_creds();\n\tif (!cred)\n\t\tgoto fail;\n\t \n\tif (__get_dumpable(cprm.mm_flags) == SUID_DUMP_ROOT) {\n\t\t \n\t\tcred->fsuid = GLOBAL_ROOT_UID;\t \n\t\tneed_suid_safe = true;\n\t}\n\n\tretval = coredump_wait(siginfo->si_signo, &core_state);\n\tif (retval < 0)\n\t\tgoto fail_creds;\n\n\told_cred = override_creds(cred);\n\n\tispipe = format_corename(&cn, &cprm, &argv, &argc);\n\n\tif (ispipe) {\n\t\tint argi;\n\t\tint dump_count;\n\t\tchar **helper_argv;\n\t\tstruct subprocess_info *sub_info;\n\n\t\tif (ispipe < 0) {\n\t\t\tprintk(KERN_WARNING \"format_corename failed\\n\");\n\t\t\tprintk(KERN_WARNING \"Aborting core\\n\");\n\t\t\tgoto fail_unlock;\n\t\t}\n\n\t\tif (cprm.limit == 1) {\n\t\t\t \n\t\t\tprintk(KERN_WARNING\n\t\t\t\t\"Process %d(%s) has RLIMIT_CORE set to 1\\n\",\n\t\t\t\ttask_tgid_vnr(current), current->comm);\n\t\t\tprintk(KERN_WARNING \"Aborting core\\n\");\n\t\t\tgoto fail_unlock;\n\t\t}\n\t\tcprm.limit = RLIM_INFINITY;\n\n\t\tdump_count = atomic_inc_return(&core_dump_count);\n\t\tif (core_pipe_limit && (core_pipe_limit < dump_count)) {\n\t\t\tprintk(KERN_WARNING \"Pid %d(%s) over core_pipe_limit\\n\",\n\t\t\t       task_tgid_vnr(current), current->comm);\n\t\t\tprintk(KERN_WARNING \"Skipping core dump\\n\");\n\t\t\tgoto fail_dropcount;\n\t\t}\n\n\t\thelper_argv = kmalloc_array(argc + 1, sizeof(*helper_argv),\n\t\t\t\t\t    GFP_KERNEL);\n\t\tif (!helper_argv) {\n\t\t\tprintk(KERN_WARNING \"%s failed to allocate memory\\n\",\n\t\t\t       __func__);\n\t\t\tgoto fail_dropcount;\n\t\t}\n\t\tfor (argi = 0; argi < argc; argi++)\n\t\t\thelper_argv[argi] = cn.corename + argv[argi];\n\t\thelper_argv[argi] = NULL;\n\n\t\tretval = -ENOMEM;\n\t\tsub_info = call_usermodehelper_setup(helper_argv[0],\n\t\t\t\t\t\thelper_argv, NULL, GFP_KERNEL,\n\t\t\t\t\t\tumh_pipe_setup, NULL, &cprm);\n\t\tif (sub_info)\n\t\t\tretval = call_usermodehelper_exec(sub_info,\n\t\t\t\t\t\t\t  UMH_WAIT_EXEC);\n\n\t\tkfree(helper_argv);\n\t\tif (retval) {\n\t\t\tprintk(KERN_INFO \"Core dump to |%s pipe failed\\n\",\n\t\t\t       cn.corename);\n\t\t\tgoto close_fail;\n\t\t}\n\t} else {\n\t\tstruct mnt_idmap *idmap;\n\t\tstruct inode *inode;\n\t\tint open_flags = O_CREAT | O_WRONLY | O_NOFOLLOW |\n\t\t\t\t O_LARGEFILE | O_EXCL;\n\n\t\tif (cprm.limit < binfmt->min_coredump)\n\t\t\tgoto fail_unlock;\n\n\t\tif (need_suid_safe && cn.corename[0] != '/') {\n\t\t\tprintk(KERN_WARNING \"Pid %d(%s) can only dump core \"\\\n\t\t\t\t\"to fully qualified path!\\n\",\n\t\t\t\ttask_tgid_vnr(current), current->comm);\n\t\t\tprintk(KERN_WARNING \"Skipping core dump\\n\");\n\t\t\tgoto fail_unlock;\n\t\t}\n\n\t\t \n\t\tif (!need_suid_safe) {\n\t\t\t \n\t\t\tdo_unlinkat(AT_FDCWD, getname_kernel(cn.corename));\n\t\t}\n\n\t\t \n\t\tif (need_suid_safe) {\n\t\t\t \n\t\t\tstruct path root;\n\n\t\t\ttask_lock(&init_task);\n\t\t\tget_fs_root(init_task.fs, &root);\n\t\t\ttask_unlock(&init_task);\n\t\t\tcprm.file = file_open_root(&root, cn.corename,\n\t\t\t\t\t\t   open_flags, 0600);\n\t\t\tpath_put(&root);\n\t\t} else {\n\t\t\tcprm.file = filp_open(cn.corename, open_flags, 0600);\n\t\t}\n\t\tif (IS_ERR(cprm.file))\n\t\t\tgoto fail_unlock;\n\n\t\tinode = file_inode(cprm.file);\n\t\tif (inode->i_nlink > 1)\n\t\t\tgoto close_fail;\n\t\tif (d_unhashed(cprm.file->f_path.dentry))\n\t\t\tgoto close_fail;\n\t\t \n\t\tif (!S_ISREG(inode->i_mode))\n\t\t\tgoto close_fail;\n\t\t \n\t\tidmap = file_mnt_idmap(cprm.file);\n\t\tif (!vfsuid_eq_kuid(i_uid_into_vfsuid(idmap, inode),\n\t\t\t\t    current_fsuid())) {\n\t\t\tpr_info_ratelimited(\"Core dump to %s aborted: cannot preserve file owner\\n\",\n\t\t\t\t\t    cn.corename);\n\t\t\tgoto close_fail;\n\t\t}\n\t\tif ((inode->i_mode & 0677) != 0600) {\n\t\t\tpr_info_ratelimited(\"Core dump to %s aborted: cannot preserve file permissions\\n\",\n\t\t\t\t\t    cn.corename);\n\t\t\tgoto close_fail;\n\t\t}\n\t\tif (!(cprm.file->f_mode & FMODE_CAN_WRITE))\n\t\t\tgoto close_fail;\n\t\tif (do_truncate(idmap, cprm.file->f_path.dentry,\n\t\t\t\t0, 0, cprm.file))\n\t\t\tgoto close_fail;\n\t}\n\n\t \n\t \n\tretval = unshare_files();\n\tif (retval)\n\t\tgoto close_fail;\n\tif (!dump_interrupted()) {\n\t\t \n\t\tif (!cprm.file) {\n\t\t\tpr_info(\"Core dump to |%s disabled\\n\", cn.corename);\n\t\t\tgoto close_fail;\n\t\t}\n\t\tif (!dump_vma_snapshot(&cprm))\n\t\t\tgoto close_fail;\n\n\t\tfile_start_write(cprm.file);\n\t\tcore_dumped = binfmt->core_dump(&cprm);\n\t\t \n\t\tif (cprm.to_skip) {\n\t\t\tcprm.to_skip--;\n\t\t\tdump_emit(&cprm, \"\", 1);\n\t\t}\n\t\tfile_end_write(cprm.file);\n\t\tfree_vma_snapshot(&cprm);\n\t}\n\tif (ispipe && core_pipe_limit)\n\t\twait_for_dump_helpers(cprm.file);\nclose_fail:\n\tif (cprm.file)\n\t\tfilp_close(cprm.file, NULL);\nfail_dropcount:\n\tif (ispipe)\n\t\tatomic_dec(&core_dump_count);\nfail_unlock:\n\tkfree(argv);\n\tkfree(cn.corename);\n\tcoredump_finish(core_dumped);\n\trevert_creds(old_cred);\nfail_creds:\n\tput_cred(cred);\nfail:\n\treturn;\n}\n\n \nstatic int __dump_emit(struct coredump_params *cprm, const void *addr, int nr)\n{\n\tstruct file *file = cprm->file;\n\tloff_t pos = file->f_pos;\n\tssize_t n;\n\tif (cprm->written + nr > cprm->limit)\n\t\treturn 0;\n\n\n\tif (dump_interrupted())\n\t\treturn 0;\n\tn = __kernel_write(file, addr, nr, &pos);\n\tif (n != nr)\n\t\treturn 0;\n\tfile->f_pos = pos;\n\tcprm->written += n;\n\tcprm->pos += n;\n\n\treturn 1;\n}\n\nstatic int __dump_skip(struct coredump_params *cprm, size_t nr)\n{\n\tstatic char zeroes[PAGE_SIZE];\n\tstruct file *file = cprm->file;\n\tif (file->f_mode & FMODE_LSEEK) {\n\t\tif (dump_interrupted() ||\n\t\t    vfs_llseek(file, nr, SEEK_CUR) < 0)\n\t\t\treturn 0;\n\t\tcprm->pos += nr;\n\t\treturn 1;\n\t} else {\n\t\twhile (nr > PAGE_SIZE) {\n\t\t\tif (!__dump_emit(cprm, zeroes, PAGE_SIZE))\n\t\t\t\treturn 0;\n\t\t\tnr -= PAGE_SIZE;\n\t\t}\n\t\treturn __dump_emit(cprm, zeroes, nr);\n\t}\n}\n\nint dump_emit(struct coredump_params *cprm, const void *addr, int nr)\n{\n\tif (cprm->to_skip) {\n\t\tif (!__dump_skip(cprm, cprm->to_skip))\n\t\t\treturn 0;\n\t\tcprm->to_skip = 0;\n\t}\n\treturn __dump_emit(cprm, addr, nr);\n}\nEXPORT_SYMBOL(dump_emit);\n\nvoid dump_skip_to(struct coredump_params *cprm, unsigned long pos)\n{\n\tcprm->to_skip = pos - cprm->pos;\n}\nEXPORT_SYMBOL(dump_skip_to);\n\nvoid dump_skip(struct coredump_params *cprm, size_t nr)\n{\n\tcprm->to_skip += nr;\n}\nEXPORT_SYMBOL(dump_skip);\n\n#ifdef CONFIG_ELF_CORE\nstatic int dump_emit_page(struct coredump_params *cprm, struct page *page)\n{\n\tstruct bio_vec bvec;\n\tstruct iov_iter iter;\n\tstruct file *file = cprm->file;\n\tloff_t pos;\n\tssize_t n;\n\n\tif (cprm->to_skip) {\n\t\tif (!__dump_skip(cprm, cprm->to_skip))\n\t\t\treturn 0;\n\t\tcprm->to_skip = 0;\n\t}\n\tif (cprm->written + PAGE_SIZE > cprm->limit)\n\t\treturn 0;\n\tif (dump_interrupted())\n\t\treturn 0;\n\tpos = file->f_pos;\n\tbvec_set_page(&bvec, page, PAGE_SIZE, 0);\n\tiov_iter_bvec(&iter, ITER_SOURCE, &bvec, 1, PAGE_SIZE);\n\tiov_iter_set_copy_mc(&iter);\n\tn = __kernel_write_iter(cprm->file, &iter, &pos);\n\tif (n != PAGE_SIZE)\n\t\treturn 0;\n\tfile->f_pos = pos;\n\tcprm->written += PAGE_SIZE;\n\tcprm->pos += PAGE_SIZE;\n\n\treturn 1;\n}\n\nint dump_user_range(struct coredump_params *cprm, unsigned long start,\n\t\t    unsigned long len)\n{\n\tunsigned long addr;\n\n\tfor (addr = start; addr < start + len; addr += PAGE_SIZE) {\n\t\tstruct page *page;\n\n\t\t \n\t\tpage = get_dump_page(addr);\n\t\tif (page) {\n\t\t\tint stop = !dump_emit_page(cprm, page);\n\t\t\tput_page(page);\n\t\t\tif (stop)\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tdump_skip(cprm, PAGE_SIZE);\n\t\t}\n\t}\n\treturn 1;\n}\n#endif\n\nint dump_align(struct coredump_params *cprm, int align)\n{\n\tunsigned mod = (cprm->pos + cprm->to_skip) & (align - 1);\n\tif (align & (align - 1))\n\t\treturn 0;\n\tif (mod)\n\t\tcprm->to_skip += align - mod;\n\treturn 1;\n}\nEXPORT_SYMBOL(dump_align);\n\n#ifdef CONFIG_SYSCTL\n\nvoid validate_coredump_safety(void)\n{\n\tif (suid_dumpable == SUID_DUMP_ROOT &&\n\t    core_pattern[0] != '/' && core_pattern[0] != '|') {\n\t\tpr_warn(\n\"Unsafe core_pattern used with fs.suid_dumpable=2.\\n\"\n\"Pipe handler or fully qualified core dump path required.\\n\"\n\"Set kernel.core_pattern before fs.suid_dumpable.\\n\"\n\t\t);\n\t}\n}\n\nstatic int proc_dostring_coredump(struct ctl_table *table, int write,\n\t\t  void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint error = proc_dostring(table, write, buffer, lenp, ppos);\n\n\tif (!error)\n\t\tvalidate_coredump_safety();\n\treturn error;\n}\n\nstatic struct ctl_table coredump_sysctls[] = {\n\t{\n\t\t.procname\t= \"core_uses_pid\",\n\t\t.data\t\t= &core_uses_pid,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"core_pattern\",\n\t\t.data\t\t= core_pattern,\n\t\t.maxlen\t\t= CORENAME_MAX_SIZE,\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dostring_coredump,\n\t},\n\t{\n\t\t.procname\t= \"core_pipe_limit\",\n\t\t.data\t\t= &core_pipe_limit,\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{ }\n};\n\nstatic int __init init_fs_coredump_sysctls(void)\n{\n\tregister_sysctl_init(\"kernel\", coredump_sysctls);\n\treturn 0;\n}\nfs_initcall(init_fs_coredump_sysctls);\n#endif  \n\n \nstatic bool always_dump_vma(struct vm_area_struct *vma)\n{\n\t \n\tif (vma == get_gate_vma(vma->vm_mm))\n\t\treturn true;\n\n\t \n\tif (vma->vm_ops && vma->vm_ops->name && vma->vm_ops->name(vma))\n\t\treturn true;\n\n\t \n\tif (arch_vma_name(vma))\n\t\treturn true;\n\n\treturn false;\n}\n\n#define DUMP_SIZE_MAYBE_ELFHDR_PLACEHOLDER 1\n\n \nstatic unsigned long vma_dump_size(struct vm_area_struct *vma,\n\t\t\t\t   unsigned long mm_flags)\n{\n#define FILTER(type)\t(mm_flags & (1UL << MMF_DUMP_##type))\n\n\t \n\tif (always_dump_vma(vma))\n\t\tgoto whole;\n\n\tif (vma->vm_flags & VM_DONTDUMP)\n\t\treturn 0;\n\n\t \n\tif (vma_is_dax(vma)) {\n\t\tif ((vma->vm_flags & VM_SHARED) && FILTER(DAX_SHARED))\n\t\t\tgoto whole;\n\t\tif (!(vma->vm_flags & VM_SHARED) && FILTER(DAX_PRIVATE))\n\t\t\tgoto whole;\n\t\treturn 0;\n\t}\n\n\t \n\tif (is_vm_hugetlb_page(vma)) {\n\t\tif ((vma->vm_flags & VM_SHARED) && FILTER(HUGETLB_SHARED))\n\t\t\tgoto whole;\n\t\tif (!(vma->vm_flags & VM_SHARED) && FILTER(HUGETLB_PRIVATE))\n\t\t\tgoto whole;\n\t\treturn 0;\n\t}\n\n\t \n\tif (vma->vm_flags & VM_IO)\n\t\treturn 0;\n\n\t \n\tif (vma->vm_flags & VM_SHARED) {\n\t\tif (file_inode(vma->vm_file)->i_nlink == 0 ?\n\t\t    FILTER(ANON_SHARED) : FILTER(MAPPED_SHARED))\n\t\t\tgoto whole;\n\t\treturn 0;\n\t}\n\n\t \n\tif ((!IS_ENABLED(CONFIG_MMU) || vma->anon_vma) && FILTER(ANON_PRIVATE))\n\t\tgoto whole;\n\tif (vma->vm_file == NULL)\n\t\treturn 0;\n\n\tif (FILTER(MAPPED_PRIVATE))\n\t\tgoto whole;\n\n\t \n\tif (FILTER(ELF_HEADERS) &&\n\t    vma->vm_pgoff == 0 && (vma->vm_flags & VM_READ)) {\n\t\tif ((READ_ONCE(file_inode(vma->vm_file)->i_mode) & 0111) != 0)\n\t\t\treturn PAGE_SIZE;\n\n\t\t \n\t\treturn DUMP_SIZE_MAYBE_ELFHDR_PLACEHOLDER;\n\t}\n\n#undef\tFILTER\n\n\treturn 0;\n\nwhole:\n\treturn vma->vm_end - vma->vm_start;\n}\n\n \nstatic struct vm_area_struct *coredump_next_vma(struct vma_iterator *vmi,\n\t\t\t\t       struct vm_area_struct *vma,\n\t\t\t\t       struct vm_area_struct *gate_vma)\n{\n\tif (gate_vma && (vma == gate_vma))\n\t\treturn NULL;\n\n\tvma = vma_next(vmi);\n\tif (vma)\n\t\treturn vma;\n\treturn gate_vma;\n}\n\nstatic void free_vma_snapshot(struct coredump_params *cprm)\n{\n\tif (cprm->vma_meta) {\n\t\tint i;\n\t\tfor (i = 0; i < cprm->vma_count; i++) {\n\t\t\tstruct file *file = cprm->vma_meta[i].file;\n\t\t\tif (file)\n\t\t\t\tfput(file);\n\t\t}\n\t\tkvfree(cprm->vma_meta);\n\t\tcprm->vma_meta = NULL;\n\t}\n}\n\n \nstatic bool dump_vma_snapshot(struct coredump_params *cprm)\n{\n\tstruct vm_area_struct *gate_vma, *vma = NULL;\n\tstruct mm_struct *mm = current->mm;\n\tVMA_ITERATOR(vmi, mm, 0);\n\tint i = 0;\n\n\t \n\tif (mmap_write_lock_killable(mm))\n\t\treturn false;\n\n\tcprm->vma_data_size = 0;\n\tgate_vma = get_gate_vma(mm);\n\tcprm->vma_count = mm->map_count + (gate_vma ? 1 : 0);\n\n\tcprm->vma_meta = kvmalloc_array(cprm->vma_count, sizeof(*cprm->vma_meta), GFP_KERNEL);\n\tif (!cprm->vma_meta) {\n\t\tmmap_write_unlock(mm);\n\t\treturn false;\n\t}\n\n\twhile ((vma = coredump_next_vma(&vmi, vma, gate_vma)) != NULL) {\n\t\tstruct core_vma_metadata *m = cprm->vma_meta + i;\n\n\t\tm->start = vma->vm_start;\n\t\tm->end = vma->vm_end;\n\t\tm->flags = vma->vm_flags;\n\t\tm->dump_size = vma_dump_size(vma, cprm->mm_flags);\n\t\tm->pgoff = vma->vm_pgoff;\n\t\tm->file = vma->vm_file;\n\t\tif (m->file)\n\t\t\tget_file(m->file);\n\t\ti++;\n\t}\n\n\tmmap_write_unlock(mm);\n\n\tfor (i = 0; i < cprm->vma_count; i++) {\n\t\tstruct core_vma_metadata *m = cprm->vma_meta + i;\n\n\t\tif (m->dump_size == DUMP_SIZE_MAYBE_ELFHDR_PLACEHOLDER) {\n\t\t\tchar elfmag[SELFMAG];\n\n\t\t\tif (copy_from_user(elfmag, (void __user *)m->start, SELFMAG) ||\n\t\t\t\t\tmemcmp(elfmag, ELFMAG, SELFMAG) != 0) {\n\t\t\t\tm->dump_size = 0;\n\t\t\t} else {\n\t\t\t\tm->dump_size = PAGE_SIZE;\n\t\t\t}\n\t\t}\n\n\t\tcprm->vma_data_size += m->dump_size;\n\t}\n\n\treturn true;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}