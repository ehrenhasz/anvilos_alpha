{
  "module_name": "balloc.c",
  "hash_id": "403c8aaaf53c9cf5d07c4ff735f3ff1e327ebe045f11db2c6e897793a27d1d4e",
  "original_prompt": "Ingested from linux-6.6.14/fs/ext2/balloc.c",
  "human_readable_source": "\n \n\n#include \"ext2.h\"\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/cred.h>\n#include <linux/buffer_head.h>\n#include <linux/capability.h>\n\n \n\n \n\n\nstruct ext2_group_desc * ext2_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext2_group_desc * desc;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\tWARN(1, \"block_group >= groups_count - \"\n\t\t     \"block_group = %d, groups_count = %lu\",\n\t\t     block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT2_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT2_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\tWARN(1, \"Group descriptor not loaded - \"\n\t\t     \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t      block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext2_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}\n\nstatic int ext2_valid_block_bitmap(struct super_block *sb,\n\t\t\t\t\tstruct ext2_group_desc *desc,\n\t\t\t\t\tunsigned int block_group,\n\t\t\t\t\tstruct buffer_head *bh)\n{\n\text2_grpblk_t offset;\n\text2_grpblk_t next_zero_bit;\n\text2_fsblk_t bitmap_blk;\n\text2_fsblk_t group_first_block;\n\n\tgroup_first_block = ext2_group_first_block_no(sb, block_group);\n\n\t \n\tbitmap_blk = le32_to_cpu(desc->bg_block_bitmap);\n\toffset = bitmap_blk - group_first_block;\n\tif (!ext2_test_bit(offset, bh->b_data))\n\t\t \n\t\tgoto err_out;\n\n\t \n\tbitmap_blk = le32_to_cpu(desc->bg_inode_bitmap);\n\toffset = bitmap_blk - group_first_block;\n\tif (!ext2_test_bit(offset, bh->b_data))\n\t\t \n\t\tgoto err_out;\n\n\t \n\tbitmap_blk = le32_to_cpu(desc->bg_inode_table);\n\toffset = bitmap_blk - group_first_block;\n\tnext_zero_bit = ext2_find_next_zero_bit(bh->b_data,\n\t\t\t\toffset + EXT2_SB(sb)->s_itb_per_group,\n\t\t\t\toffset);\n\tif (next_zero_bit >= offset + EXT2_SB(sb)->s_itb_per_group)\n\t\t \n\t\treturn 1;\n\nerr_out:\n\text2_error(sb, __func__,\n\t\t\t\"Invalid block bitmap - \"\n\t\t\t\"block_group = %d, block = %lu\",\n\t\t\tblock_group, bitmap_blk);\n\treturn 0;\n}\n\n \nstatic struct buffer_head *\nread_block_bitmap(struct super_block *sb, unsigned int block_group)\n{\n\tstruct ext2_group_desc * desc;\n\tstruct buffer_head * bh = NULL;\n\text2_fsblk_t bitmap_blk;\n\tint ret;\n\n\tdesc = ext2_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\treturn NULL;\n\tbitmap_blk = le32_to_cpu(desc->bg_block_bitmap);\n\tbh = sb_getblk(sb, bitmap_blk);\n\tif (unlikely(!bh)) {\n\t\text2_error(sb, __func__,\n\t\t\t    \"Cannot read block bitmap - \"\n\t\t\t    \"block_group = %d, block_bitmap = %u\",\n\t\t\t    block_group, le32_to_cpu(desc->bg_block_bitmap));\n\t\treturn NULL;\n\t}\n\tret = bh_read(bh, 0);\n\tif (ret > 0)\n\t\treturn bh;\n\tif (ret < 0) {\n\t\tbrelse(bh);\n\t\text2_error(sb, __func__,\n\t\t\t    \"Cannot read block bitmap - \"\n\t\t\t    \"block_group = %d, block_bitmap = %u\",\n\t\t\t    block_group, le32_to_cpu(desc->bg_block_bitmap));\n\t\treturn NULL;\n\t}\n\n\text2_valid_block_bitmap(sb, desc, block_group, bh);\n\t \n\treturn bh;\n}\n\nstatic void group_adjust_blocks(struct super_block *sb, int group_no,\n\tstruct ext2_group_desc *desc, struct buffer_head *bh, int count)\n{\n\tif (count) {\n\t\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\t\tunsigned free_blocks;\n\n\t\tspin_lock(sb_bgl_lock(sbi, group_no));\n\t\tfree_blocks = le16_to_cpu(desc->bg_free_blocks_count);\n\t\tdesc->bg_free_blocks_count = cpu_to_le16(free_blocks + count);\n\t\tspin_unlock(sb_bgl_lock(sbi, group_no));\n\t\tmark_buffer_dirty(bh);\n\t}\n}\n\n \n\n \n#if 1\nstatic void __rsv_window_dump(struct rb_root *root, int verbose,\n\t\t\t      const char *fn)\n{\n\tstruct rb_node *n;\n\tstruct ext2_reserve_window_node *rsv, *prev;\n\tint bad;\n\nrestart:\n\tn = rb_first(root);\n\tbad = 0;\n\tprev = NULL;\n\n\tprintk(\"Block Allocation Reservation Windows Map (%s):\\n\", fn);\n\twhile (n) {\n\t\trsv = rb_entry(n, struct ext2_reserve_window_node, rsv_node);\n\t\tif (verbose)\n\t\t\tprintk(\"reservation window 0x%p \"\n\t\t\t\t\"start: %lu, end: %lu\\n\",\n\t\t\t\trsv, rsv->rsv_start, rsv->rsv_end);\n\t\tif (rsv->rsv_start && rsv->rsv_start >= rsv->rsv_end) {\n\t\t\tprintk(\"Bad reservation %p (start >= end)\\n\",\n\t\t\t       rsv);\n\t\t\tbad = 1;\n\t\t}\n\t\tif (prev && prev->rsv_end >= rsv->rsv_start) {\n\t\t\tprintk(\"Bad reservation %p (prev->end >= start)\\n\",\n\t\t\t       rsv);\n\t\t\tbad = 1;\n\t\t}\n\t\tif (bad) {\n\t\t\tif (!verbose) {\n\t\t\t\tprintk(\"Restarting reservation walk in verbose mode\\n\");\n\t\t\t\tverbose = 1;\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t}\n\t\tn = rb_next(n);\n\t\tprev = rsv;\n\t}\n\tprintk(\"Window map complete.\\n\");\n\tBUG_ON(bad);\n}\n#define rsv_window_dump(root, verbose) \\\n\t__rsv_window_dump((root), (verbose), __func__)\n#else\n#define rsv_window_dump(root, verbose) do {} while (0)\n#endif\n\n \nstatic int\ngoal_in_my_reservation(struct ext2_reserve_window *rsv, ext2_grpblk_t grp_goal,\n\t\t\tunsigned int group, struct super_block * sb)\n{\n\text2_fsblk_t group_first_block, group_last_block;\n\n\tgroup_first_block = ext2_group_first_block_no(sb, group);\n\tgroup_last_block = ext2_group_last_block_no(sb, group);\n\n\tif ((rsv->_rsv_start > group_last_block) ||\n\t    (rsv->_rsv_end < group_first_block))\n\t\treturn 0;\n\tif ((grp_goal >= 0) && ((grp_goal + group_first_block < rsv->_rsv_start)\n\t\t|| (grp_goal + group_first_block > rsv->_rsv_end)))\n\t\treturn 0;\n\treturn 1;\n}\n\n \nstatic struct ext2_reserve_window_node *\nsearch_reserve_window(struct rb_root *root, ext2_fsblk_t goal)\n{\n\tstruct rb_node *n = root->rb_node;\n\tstruct ext2_reserve_window_node *rsv;\n\n\tif (!n)\n\t\treturn NULL;\n\n\tdo {\n\t\trsv = rb_entry(n, struct ext2_reserve_window_node, rsv_node);\n\n\t\tif (goal < rsv->rsv_start)\n\t\t\tn = n->rb_left;\n\t\telse if (goal > rsv->rsv_end)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn rsv;\n\t} while (n);\n\t \n\tif (rsv->rsv_start > goal) {\n\t\tn = rb_prev(&rsv->rsv_node);\n\t\trsv = rb_entry(n, struct ext2_reserve_window_node, rsv_node);\n\t}\n\treturn rsv;\n}\n\n \nvoid ext2_rsv_window_add(struct super_block *sb,\n\t\t    struct ext2_reserve_window_node *rsv)\n{\n\tstruct rb_root *root = &EXT2_SB(sb)->s_rsv_window_root;\n\tstruct rb_node *node = &rsv->rsv_node;\n\text2_fsblk_t start = rsv->rsv_start;\n\n\tstruct rb_node ** p = &root->rb_node;\n\tstruct rb_node * parent = NULL;\n\tstruct ext2_reserve_window_node *this;\n\n\twhile (*p)\n\t{\n\t\tparent = *p;\n\t\tthis = rb_entry(parent, struct ext2_reserve_window_node, rsv_node);\n\n\t\tif (start < this->rsv_start)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (start > this->rsv_end)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\trsv_window_dump(root, 1);\n\t\t\tBUG();\n\t\t}\n\t}\n\n\trb_link_node(node, parent, p);\n\trb_insert_color(node, root);\n}\n\n \nstatic void rsv_window_remove(struct super_block *sb,\n\t\t\t      struct ext2_reserve_window_node *rsv)\n{\n\trsv->rsv_start = EXT2_RESERVE_WINDOW_NOT_ALLOCATED;\n\trsv->rsv_end = EXT2_RESERVE_WINDOW_NOT_ALLOCATED;\n\trsv->rsv_alloc_hit = 0;\n\trb_erase(&rsv->rsv_node, &EXT2_SB(sb)->s_rsv_window_root);\n}\n\n \nstatic inline int rsv_is_empty(struct ext2_reserve_window *rsv)\n{\n\t \n\treturn (rsv->_rsv_end == EXT2_RESERVE_WINDOW_NOT_ALLOCATED);\n}\n\n \nvoid ext2_init_block_alloc_info(struct inode *inode)\n{\n\tstruct ext2_inode_info *ei = EXT2_I(inode);\n\tstruct ext2_block_alloc_info *block_i;\n\tstruct super_block *sb = inode->i_sb;\n\n\tblock_i = kmalloc(sizeof(*block_i), GFP_NOFS);\n\tif (block_i) {\n\t\tstruct ext2_reserve_window_node *rsv = &block_i->rsv_window_node;\n\n\t\trsv->rsv_start = EXT2_RESERVE_WINDOW_NOT_ALLOCATED;\n\t\trsv->rsv_end = EXT2_RESERVE_WINDOW_NOT_ALLOCATED;\n\n\t \t \n\t\tif (!test_opt(sb, RESERVATION))\n\t\t\trsv->rsv_goal_size = 0;\n\t\telse\n\t\t\trsv->rsv_goal_size = EXT2_DEFAULT_RESERVE_BLOCKS;\n\t\trsv->rsv_alloc_hit = 0;\n\t\tblock_i->last_alloc_logical_block = 0;\n\t\tblock_i->last_alloc_physical_block = 0;\n\t}\n\tei->i_block_alloc_info = block_i;\n}\n\n \nvoid ext2_discard_reservation(struct inode *inode)\n{\n\tstruct ext2_inode_info *ei = EXT2_I(inode);\n\tstruct ext2_block_alloc_info *block_i = ei->i_block_alloc_info;\n\tstruct ext2_reserve_window_node *rsv;\n\tspinlock_t *rsv_lock = &EXT2_SB(inode->i_sb)->s_rsv_window_lock;\n\n\tif (!block_i)\n\t\treturn;\n\n\trsv = &block_i->rsv_window_node;\n\tif (!rsv_is_empty(&rsv->rsv_window)) {\n\t\tspin_lock(rsv_lock);\n\t\tif (!rsv_is_empty(&rsv->rsv_window))\n\t\t\trsv_window_remove(inode->i_sb, rsv);\n\t\tspin_unlock(rsv_lock);\n\t}\n}\n\n \nvoid ext2_free_blocks(struct inode * inode, ext2_fsblk_t block,\n\t\t      unsigned long count)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head * bh2;\n\tunsigned long block_group;\n\tunsigned long bit;\n\tunsigned long i;\n\tunsigned long overflow;\n\tstruct super_block * sb = inode->i_sb;\n\tstruct ext2_sb_info * sbi = EXT2_SB(sb);\n\tstruct ext2_group_desc * desc;\n\tstruct ext2_super_block * es = sbi->s_es;\n\tunsigned freed = 0, group_freed;\n\n\tif (!ext2_data_block_valid(sbi, block, count)) {\n\t\text2_error (sb, \"ext2_free_blocks\",\n\t\t\t    \"Freeing blocks not in datazone - \"\n\t\t\t    \"block = %lu, count = %lu\", block, count);\n\t\tgoto error_return;\n\t}\n\n\text2_debug (\"freeing block(s) %lu-%lu\\n\", block, block + count - 1);\n\ndo_more:\n\toverflow = 0;\n\tblock_group = (block - le32_to_cpu(es->s_first_data_block)) /\n\t\t      EXT2_BLOCKS_PER_GROUP(sb);\n\tbit = (block - le32_to_cpu(es->s_first_data_block)) %\n\t\t      EXT2_BLOCKS_PER_GROUP(sb);\n\t \n\tif (bit + count > EXT2_BLOCKS_PER_GROUP(sb)) {\n\t\toverflow = bit + count - EXT2_BLOCKS_PER_GROUP(sb);\n\t\tcount -= overflow;\n\t}\n\tbrelse(bitmap_bh);\n\tbitmap_bh = read_block_bitmap(sb, block_group);\n\tif (!bitmap_bh)\n\t\tgoto error_return;\n\n\tdesc = ext2_get_group_desc (sb, block_group, &bh2);\n\tif (!desc)\n\t\tgoto error_return;\n\n\tif (in_range (le32_to_cpu(desc->bg_block_bitmap), block, count) ||\n\t    in_range (le32_to_cpu(desc->bg_inode_bitmap), block, count) ||\n\t    in_range (block, le32_to_cpu(desc->bg_inode_table),\n\t\t      sbi->s_itb_per_group) ||\n\t    in_range (block + count - 1, le32_to_cpu(desc->bg_inode_table),\n\t\t      sbi->s_itb_per_group)) {\n\t\text2_error (sb, \"ext2_free_blocks\",\n\t\t\t    \"Freeing blocks in system zones - \"\n\t\t\t    \"Block = %lu, count = %lu\",\n\t\t\t    block, count);\n\t\tgoto error_return;\n\t}\n\n\tfor (i = 0, group_freed = 0; i < count; i++) {\n\t\tif (!ext2_clear_bit_atomic(sb_bgl_lock(sbi, block_group),\n\t\t\t\t\t\tbit + i, bitmap_bh->b_data)) {\n\t\t\text2_error(sb, __func__,\n\t\t\t\t\"bit already cleared for block %lu\", block + i);\n\t\t} else {\n\t\t\tgroup_freed++;\n\t\t}\n\t}\n\n\tmark_buffer_dirty(bitmap_bh);\n\tif (sb->s_flags & SB_SYNCHRONOUS)\n\t\tsync_dirty_buffer(bitmap_bh);\n\n\tgroup_adjust_blocks(sb, block_group, desc, bh2, group_freed);\n\tfreed += group_freed;\n\n\tif (overflow) {\n\t\tblock += count;\n\t\tcount = overflow;\n\t\tgoto do_more;\n\t}\nerror_return:\n\tbrelse(bitmap_bh);\n\tif (freed) {\n\t\tpercpu_counter_add(&sbi->s_freeblocks_counter, freed);\n\t\tdquot_free_block_nodirty(inode, freed);\n\t\tmark_inode_dirty(inode);\n\t}\n}\n\n \nstatic ext2_grpblk_t\nbitmap_search_next_usable_block(ext2_grpblk_t start, struct buffer_head *bh,\n\t\t\t\t\text2_grpblk_t maxblocks)\n{\n\text2_grpblk_t next;\n\n\tnext = ext2_find_next_zero_bit(bh->b_data, maxblocks, start);\n\tif (next >= maxblocks)\n\t\treturn -1;\n\treturn next;\n}\n\n \nstatic ext2_grpblk_t\nfind_next_usable_block(int start, struct buffer_head *bh, int maxblocks)\n{\n\text2_grpblk_t here, next;\n\tchar *p, *r;\n\n\tif (start > 0) {\n\t\t \n\t\text2_grpblk_t end_goal = (start + 63) & ~63;\n\t\tif (end_goal > maxblocks)\n\t\t\tend_goal = maxblocks;\n\t\there = ext2_find_next_zero_bit(bh->b_data, end_goal, start);\n\t\tif (here < end_goal)\n\t\t\treturn here;\n\t\text2_debug(\"Bit not found near goal\\n\");\n\t}\n\n\there = start;\n\tif (here < 0)\n\t\there = 0;\n\n\tp = ((char *)bh->b_data) + (here >> 3);\n\tr = memscan(p, 0, ((maxblocks + 7) >> 3) - (here >> 3));\n\tnext = (r - ((char *)bh->b_data)) << 3;\n\n\tif (next < maxblocks && next >= here)\n\t\treturn next;\n\n\there = bitmap_search_next_usable_block(here, bh, maxblocks);\n\treturn here;\n}\n\n \nstatic int\next2_try_to_allocate(struct super_block *sb, int group,\n\t\t\tstruct buffer_head *bitmap_bh, ext2_grpblk_t grp_goal,\n\t\t\tunsigned long *count,\n\t\t\tstruct ext2_reserve_window *my_rsv)\n{\n\text2_fsblk_t group_first_block = ext2_group_first_block_no(sb, group);\n\text2_fsblk_t group_last_block = ext2_group_last_block_no(sb, group);\n\text2_grpblk_t start, end;\n\tunsigned long num = 0;\n\n\tstart = 0;\n\tend = group_last_block - group_first_block + 1;\n\t \n\tif (my_rsv) {\n\t\tif (my_rsv->_rsv_start >= group_first_block)\n\t\t\tstart = my_rsv->_rsv_start - group_first_block;\n\t\tif (my_rsv->_rsv_end < group_last_block)\n\t\t\tend = my_rsv->_rsv_end - group_first_block + 1;\n\t\tif (grp_goal < start || grp_goal >= end)\n\t\t\tgrp_goal = -1;\n\t}\n\tBUG_ON(start > EXT2_BLOCKS_PER_GROUP(sb));\n\n\tif (grp_goal < 0) {\n\t\tgrp_goal = find_next_usable_block(start, bitmap_bh, end);\n\t\tif (grp_goal < 0)\n\t\t\tgoto fail_access;\n\t\tif (!my_rsv) {\n\t\t\tint i;\n\n\t\t\tfor (i = 0; i < 7 && grp_goal > start &&\n\t\t\t\t\t!ext2_test_bit(grp_goal - 1,\n\t\t\t\t\t     \t\tbitmap_bh->b_data);\n\t\t\t     \t\ti++, grp_goal--)\n\t\t\t\t;\n\t\t}\n\t}\n\n\tfor (; num < *count && grp_goal < end; grp_goal++) {\n\t\tif (ext2_set_bit_atomic(sb_bgl_lock(EXT2_SB(sb), group),\n\t\t\t\t\tgrp_goal, bitmap_bh->b_data)) {\n\t\t\tif (num == 0)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\t\tnum++;\n\t}\n\n\tif (num == 0)\n\t\tgoto fail_access;\n\n\t*count = num;\n\treturn grp_goal - num;\nfail_access:\n\treturn -1;\n}\n\n \nstatic int find_next_reservable_window(\n\t\t\t\tstruct ext2_reserve_window_node *search_head,\n\t\t\t\tstruct ext2_reserve_window_node *my_rsv,\n\t\t\t\tstruct super_block * sb,\n\t\t\t\text2_fsblk_t start_block,\n\t\t\t\text2_fsblk_t last_block)\n{\n\tstruct rb_node *next;\n\tstruct ext2_reserve_window_node *rsv, *prev;\n\text2_fsblk_t cur;\n\tint size = my_rsv->rsv_goal_size;\n\n\t \n\t \n\tcur = start_block;\n\trsv = search_head;\n\tif (!rsv)\n\t\treturn -1;\n\n\twhile (1) {\n\t\tif (cur <= rsv->rsv_end)\n\t\t\tcur = rsv->rsv_end + 1;\n\n\t\t \n\t\tif (cur > last_block)\n\t\t\treturn -1;\t\t \n\n\t\tprev = rsv;\n\t\tnext = rb_next(&rsv->rsv_node);\n\t\trsv = rb_entry(next,struct ext2_reserve_window_node,rsv_node);\n\n\t\t \n\t\tif (!next)\n\t\t\tbreak;\n\n\t\tif (cur + size <= rsv->rsv_start) {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n\t \n\n\tif ((prev != my_rsv) && (!rsv_is_empty(&my_rsv->rsv_window)))\n\t\trsv_window_remove(sb, my_rsv);\n\n\t \n\tmy_rsv->rsv_start = cur;\n\tmy_rsv->rsv_end = cur + size - 1;\n\tmy_rsv->rsv_alloc_hit = 0;\n\n\tif (prev != my_rsv)\n\t\text2_rsv_window_add(sb, my_rsv);\n\n\treturn 0;\n}\n\n \nstatic int alloc_new_reservation(struct ext2_reserve_window_node *my_rsv,\n\t\text2_grpblk_t grp_goal, struct super_block *sb,\n\t\tunsigned int group, struct buffer_head *bitmap_bh)\n{\n\tstruct ext2_reserve_window_node *search_head;\n\text2_fsblk_t group_first_block, group_end_block, start_block;\n\text2_grpblk_t first_free_block;\n\tstruct rb_root *fs_rsv_root = &EXT2_SB(sb)->s_rsv_window_root;\n\tunsigned long size;\n\tint ret;\n\tspinlock_t *rsv_lock = &EXT2_SB(sb)->s_rsv_window_lock;\n\n\tgroup_first_block = ext2_group_first_block_no(sb, group);\n\tgroup_end_block = ext2_group_last_block_no(sb, group);\n\n\tif (grp_goal < 0)\n\t\tstart_block = group_first_block;\n\telse\n\t\tstart_block = grp_goal + group_first_block;\n\n\tsize = my_rsv->rsv_goal_size;\n\n\tif (!rsv_is_empty(&my_rsv->rsv_window)) {\n\t\t \n\n\t\tif ((my_rsv->rsv_start <= group_end_block) &&\n\t\t\t\t(my_rsv->rsv_end > group_end_block) &&\n\t\t\t\t(start_block >= my_rsv->rsv_start))\n\t\t\treturn -1;\n\n\t\tif ((my_rsv->rsv_alloc_hit >\n\t\t     (my_rsv->rsv_end - my_rsv->rsv_start + 1) / 2)) {\n\t\t\t \n\t\t\tsize = size * 2;\n\t\t\tif (size > EXT2_MAX_RESERVE_BLOCKS)\n\t\t\t\tsize = EXT2_MAX_RESERVE_BLOCKS;\n\t\t\tmy_rsv->rsv_goal_size= size;\n\t\t}\n\t}\n\n\tspin_lock(rsv_lock);\n\t \n\tsearch_head = search_reserve_window(fs_rsv_root, start_block);\n\n\t \nretry:\n\tret = find_next_reservable_window(search_head, my_rsv, sb,\n\t\t\t\t\t\tstart_block, group_end_block);\n\n\tif (ret == -1) {\n\t\tif (!rsv_is_empty(&my_rsv->rsv_window))\n\t\t\trsv_window_remove(sb, my_rsv);\n\t\tspin_unlock(rsv_lock);\n\t\treturn -1;\n\t}\n\n\t \n\tspin_unlock(rsv_lock);\n\tfirst_free_block = bitmap_search_next_usable_block(\n\t\t\tmy_rsv->rsv_start - group_first_block,\n\t\t\tbitmap_bh, group_end_block - group_first_block + 1);\n\n\tif (first_free_block < 0) {\n\t\t \n\t\tspin_lock(rsv_lock);\n\t\tif (!rsv_is_empty(&my_rsv->rsv_window))\n\t\t\trsv_window_remove(sb, my_rsv);\n\t\tspin_unlock(rsv_lock);\n\t\treturn -1;\t\t \n\t}\n\n\tstart_block = first_free_block + group_first_block;\n\t \n\tif (start_block >= my_rsv->rsv_start && start_block <= my_rsv->rsv_end)\n\t\treturn 0;\t\t \n\t \n\tsearch_head = my_rsv;\n\tspin_lock(rsv_lock);\n\tgoto retry;\n}\n\n \nstatic void try_to_extend_reservation(struct ext2_reserve_window_node *my_rsv,\n\t\t\tstruct super_block *sb, int size)\n{\n\tstruct ext2_reserve_window_node *next_rsv;\n\tstruct rb_node *next;\n\tspinlock_t *rsv_lock = &EXT2_SB(sb)->s_rsv_window_lock;\n\n\tif (!spin_trylock(rsv_lock))\n\t\treturn;\n\n\tnext = rb_next(&my_rsv->rsv_node);\n\n\tif (!next)\n\t\tmy_rsv->rsv_end += size;\n\telse {\n\t\tnext_rsv = rb_entry(next, struct ext2_reserve_window_node, rsv_node);\n\n\t\tif ((next_rsv->rsv_start - my_rsv->rsv_end - 1) >= size)\n\t\t\tmy_rsv->rsv_end += size;\n\t\telse\n\t\t\tmy_rsv->rsv_end = next_rsv->rsv_start - 1;\n\t}\n\tspin_unlock(rsv_lock);\n}\n\n \nstatic ext2_grpblk_t\next2_try_to_allocate_with_rsv(struct super_block *sb, unsigned int group,\n\t\t\tstruct buffer_head *bitmap_bh, ext2_grpblk_t grp_goal,\n\t\t\tstruct ext2_reserve_window_node * my_rsv,\n\t\t\tunsigned long *count)\n{\n\text2_fsblk_t group_first_block, group_last_block;\n\text2_grpblk_t ret = 0;\n\tunsigned long num = *count;\n\n\t \n\tif (my_rsv == NULL) {\n\t\treturn ext2_try_to_allocate(sb, group, bitmap_bh,\n\t\t\t\t\t\tgrp_goal, count, NULL);\n\t}\n\t \n\tgroup_first_block = ext2_group_first_block_no(sb, group);\n\tgroup_last_block = ext2_group_last_block_no(sb, group);\n\n\t \n\twhile (1) {\n\t\tif (rsv_is_empty(&my_rsv->rsv_window) || (ret < 0) ||\n\t\t\t!goal_in_my_reservation(&my_rsv->rsv_window,\n\t\t\t\t\t\tgrp_goal, group, sb)) {\n\t\t\tif (my_rsv->rsv_goal_size < *count)\n\t\t\t\tmy_rsv->rsv_goal_size = *count;\n\t\t\tret = alloc_new_reservation(my_rsv, grp_goal, sb,\n\t\t\t\t\t\t\tgroup, bitmap_bh);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\t\t\t \n\n\t\t\tif (!goal_in_my_reservation(&my_rsv->rsv_window,\n\t\t\t\t\t\t\tgrp_goal, group, sb))\n\t\t\t\tgrp_goal = -1;\n\t\t} else if (grp_goal >= 0) {\n\t\t\tint curr = my_rsv->rsv_end -\n\t\t\t\t\t(grp_goal + group_first_block) + 1;\n\n\t\t\tif (curr < *count)\n\t\t\t\ttry_to_extend_reservation(my_rsv, sb,\n\t\t\t\t\t\t\t*count - curr);\n\t\t}\n\n\t\tif ((my_rsv->rsv_start > group_last_block) ||\n\t\t\t\t(my_rsv->rsv_end < group_first_block)) {\n\t\t\text2_error(sb, __func__,\n\t\t\t\t   \"Reservation out of group %u range goal %d fsb[%lu,%lu] rsv[%lu, %lu]\",\n\t\t\t\t   group, grp_goal, group_first_block,\n\t\t\t\t   group_last_block, my_rsv->rsv_start,\n\t\t\t\t   my_rsv->rsv_end);\n\t\t\trsv_window_dump(&EXT2_SB(sb)->s_rsv_window_root, 1);\n\t\t\treturn -1;\n\t\t}\n\t\tret = ext2_try_to_allocate(sb, group, bitmap_bh, grp_goal,\n\t\t\t\t\t   &num, &my_rsv->rsv_window);\n\t\tif (ret >= 0) {\n\t\t\tmy_rsv->rsv_alloc_hit += num;\n\t\t\t*count = num;\n\t\t\tbreak;\t\t\t\t \n\t\t}\n\t\tnum = *count;\n\t}\n\treturn ret;\n}\n\n \nstatic int ext2_has_free_blocks(struct ext2_sb_info *sbi)\n{\n\text2_fsblk_t free_blocks, root_blocks;\n\n\tfree_blocks = percpu_counter_read_positive(&sbi->s_freeblocks_counter);\n\troot_blocks = le32_to_cpu(sbi->s_es->s_r_blocks_count);\n\tif (free_blocks < root_blocks + 1 && !capable(CAP_SYS_RESOURCE) &&\n\t\t!uid_eq(sbi->s_resuid, current_fsuid()) &&\n\t\t(gid_eq(sbi->s_resgid, GLOBAL_ROOT_GID) ||\n\t\t !in_group_p (sbi->s_resgid))) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n \nint ext2_data_block_valid(struct ext2_sb_info *sbi, ext2_fsblk_t start_blk,\n\t\t\t  unsigned int count)\n{\n\tif ((start_blk <= le32_to_cpu(sbi->s_es->s_first_data_block)) ||\n\t    (start_blk + count - 1 < start_blk) ||\n\t    (start_blk + count - 1 >= le32_to_cpu(sbi->s_es->s_blocks_count)))\n\t\treturn 0;\n\n\t \n\tif ((start_blk <= sbi->s_sb_block) &&\n\t    (start_blk + count - 1 >= sbi->s_sb_block))\n\t\treturn 0;\n\n\treturn 1;\n}\n\n \next2_fsblk_t ext2_new_blocks(struct inode *inode, ext2_fsblk_t goal,\n\t\t    unsigned long *count, int *errp, unsigned int flags)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head *gdp_bh;\n\tint group_no;\n\tint goal_group;\n\text2_grpblk_t grp_target_blk;\t \n\text2_grpblk_t grp_alloc_blk;\t \n\text2_fsblk_t ret_block;\t\t \n\tint bgi;\t\t\t \n\tint performed_allocation = 0;\n\text2_grpblk_t free_blocks;\t \n\tstruct super_block *sb;\n\tstruct ext2_group_desc *gdp;\n\tstruct ext2_super_block *es;\n\tstruct ext2_sb_info *sbi;\n\tstruct ext2_reserve_window_node *my_rsv = NULL;\n\tstruct ext2_block_alloc_info *block_i;\n\tunsigned short windowsz = 0;\n\tunsigned long ngroups;\n\tunsigned long num = *count;\n\tint ret;\n\n\t*errp = -ENOSPC;\n\tsb = inode->i_sb;\n\n\t \n\tret = dquot_alloc_block(inode, num);\n\tif (ret) {\n\t\t*errp = ret;\n\t\treturn 0;\n\t}\n\n\tsbi = EXT2_SB(sb);\n\tes = EXT2_SB(sb)->s_es;\n\text2_debug(\"goal=%lu.\\n\", goal);\n\t \n\tblock_i = EXT2_I(inode)->i_block_alloc_info;\n\tif (!(flags & EXT2_ALLOC_NORESERVE) && block_i) {\n\t\twindowsz = block_i->rsv_window_node.rsv_goal_size;\n\t\tif (windowsz > 0)\n\t\t\tmy_rsv = &block_i->rsv_window_node;\n\t}\n\n\tif (!ext2_has_free_blocks(sbi)) {\n\t\t*errp = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t \n\tif (goal < le32_to_cpu(es->s_first_data_block) ||\n\t    goal >= le32_to_cpu(es->s_blocks_count))\n\t\tgoal = le32_to_cpu(es->s_first_data_block);\n\tgroup_no = (goal - le32_to_cpu(es->s_first_data_block)) /\n\t\t\tEXT2_BLOCKS_PER_GROUP(sb);\n\tgoal_group = group_no;\nretry_alloc:\n\tgdp = ext2_get_group_desc(sb, group_no, &gdp_bh);\n\tif (!gdp)\n\t\tgoto io_error;\n\n\tfree_blocks = le16_to_cpu(gdp->bg_free_blocks_count);\n\t \n\tif (my_rsv && (free_blocks < windowsz)\n\t\t&& (free_blocks > 0)\n\t\t&& (rsv_is_empty(&my_rsv->rsv_window)))\n\t\tmy_rsv = NULL;\n\n\tif (free_blocks > 0) {\n\t\tgrp_target_blk = ((goal - le32_to_cpu(es->s_first_data_block)) %\n\t\t\t\tEXT2_BLOCKS_PER_GROUP(sb));\n\t\t \n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_block_bitmap(sb, group_no);\n\t\tif (!bitmap_bh)\n\t\t\tgoto io_error;\n\t\tgrp_alloc_blk = ext2_try_to_allocate_with_rsv(sb, group_no,\n\t\t\t\t\tbitmap_bh, grp_target_blk,\n\t\t\t\t\tmy_rsv, &num);\n\t\tif (grp_alloc_blk >= 0)\n\t\t\tgoto allocated;\n\t}\n\n\tngroups = EXT2_SB(sb)->s_groups_count;\n\tsmp_rmb();\n\n\t \n\tfor (bgi = 0; bgi < ngroups; bgi++) {\n\t\tgroup_no++;\n\t\tif (group_no >= ngroups)\n\t\t\tgroup_no = 0;\n\t\tgdp = ext2_get_group_desc(sb, group_no, &gdp_bh);\n\t\tif (!gdp)\n\t\t\tgoto io_error;\n\n\t\tfree_blocks = le16_to_cpu(gdp->bg_free_blocks_count);\n\t\t \n\t\tif (!free_blocks)\n\t\t\tcontinue;\n\t\t \n\t\tif (my_rsv && (free_blocks <= (windowsz/2)))\n\t\t\tcontinue;\n\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_block_bitmap(sb, group_no);\n\t\tif (!bitmap_bh)\n\t\t\tgoto io_error;\n\t\t \n\t\tgrp_alloc_blk = ext2_try_to_allocate_with_rsv(sb, group_no,\n\t\t\t\t\tbitmap_bh, -1, my_rsv, &num);\n\t\tif (grp_alloc_blk >= 0)\n\t\t\tgoto allocated;\n\t}\n\t \n\tif (my_rsv) {\n\t\tmy_rsv = NULL;\n\t\twindowsz = 0;\n\t\tgroup_no = goal_group;\n\t\tgoto retry_alloc;\n\t}\n\t \n\t*errp = -ENOSPC;\n\tgoto out;\n\nallocated:\n\n\text2_debug(\"using block group %d(%d)\\n\",\n\t\t\tgroup_no, gdp->bg_free_blocks_count);\n\n\tret_block = grp_alloc_blk + ext2_group_first_block_no(sb, group_no);\n\n\tif (in_range(le32_to_cpu(gdp->bg_block_bitmap), ret_block, num) ||\n\t    in_range(le32_to_cpu(gdp->bg_inode_bitmap), ret_block, num) ||\n\t    in_range(ret_block, le32_to_cpu(gdp->bg_inode_table),\n\t\t      EXT2_SB(sb)->s_itb_per_group) ||\n\t    in_range(ret_block + num - 1, le32_to_cpu(gdp->bg_inode_table),\n\t\t      EXT2_SB(sb)->s_itb_per_group)) {\n\t\text2_error(sb, \"ext2_new_blocks\",\n\t\t\t    \"Allocating block in system zone - \"\n\t\t\t    \"blocks from \"E2FSBLK\", length %lu\",\n\t\t\t    ret_block, num);\n\t\t \n\t\tnum = *count;\n\t\tgoto retry_alloc;\n\t}\n\n\tperformed_allocation = 1;\n\n\tif (ret_block + num - 1 >= le32_to_cpu(es->s_blocks_count)) {\n\t\text2_error(sb, \"ext2_new_blocks\",\n\t\t\t    \"block(\"E2FSBLK\") >= blocks count(%d) - \"\n\t\t\t    \"block_group = %d, es == %p \", ret_block,\n\t\t\tle32_to_cpu(es->s_blocks_count), group_no, es);\n\t\tgoto out;\n\t}\n\n\tgroup_adjust_blocks(sb, group_no, gdp, gdp_bh, -num);\n\tpercpu_counter_sub(&sbi->s_freeblocks_counter, num);\n\n\tmark_buffer_dirty(bitmap_bh);\n\tif (sb->s_flags & SB_SYNCHRONOUS)\n\t\tsync_dirty_buffer(bitmap_bh);\n\n\t*errp = 0;\n\tbrelse(bitmap_bh);\n\tif (num < *count) {\n\t\tdquot_free_block_nodirty(inode, *count-num);\n\t\tmark_inode_dirty(inode);\n\t\t*count = num;\n\t}\n\treturn ret_block;\n\nio_error:\n\t*errp = -EIO;\nout:\n\t \n\tif (!performed_allocation) {\n\t\tdquot_free_block_nodirty(inode, *count);\n\t\tmark_inode_dirty(inode);\n\t}\n\tbrelse(bitmap_bh);\n\treturn 0;\n}\n\n#ifdef EXT2FS_DEBUG\n\nunsigned long ext2_count_free(struct buffer_head *map, unsigned int numchars)\n{\n\treturn numchars * BITS_PER_BYTE - memweight(map->b_data, numchars);\n}\n\n#endif   \n\nunsigned long ext2_count_free_blocks (struct super_block * sb)\n{\n\tstruct ext2_group_desc * desc;\n\tunsigned long desc_count = 0;\n\tint i;\n#ifdef EXT2FS_DEBUG\n\tunsigned long bitmap_count, x;\n\tstruct ext2_super_block *es;\n\n\tes = EXT2_SB(sb)->s_es;\n\tdesc_count = 0;\n\tbitmap_count = 0;\n\tdesc = NULL;\n\tfor (i = 0; i < EXT2_SB(sb)->s_groups_count; i++) {\n\t\tstruct buffer_head *bitmap_bh;\n\t\tdesc = ext2_get_group_desc (sb, i, NULL);\n\t\tif (!desc)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(desc->bg_free_blocks_count);\n\t\tbitmap_bh = read_block_bitmap(sb, i);\n\t\tif (!bitmap_bh)\n\t\t\tcontinue;\n\t\t\n\t\tx = ext2_count_free(bitmap_bh, sb->s_blocksize);\n\t\tprintk (\"group %d: stored = %d, counted = %lu\\n\",\n\t\t\ti, le16_to_cpu(desc->bg_free_blocks_count), x);\n\t\tbitmap_count += x;\n\t\tbrelse(bitmap_bh);\n\t}\n\tprintk(\"ext2_count_free_blocks: stored = %lu, computed = %lu, %lu\\n\",\n\t\t(long)le32_to_cpu(es->s_free_blocks_count),\n\t\tdesc_count, bitmap_count);\n\treturn bitmap_count;\n#else\n\tfor (i = 0; i < EXT2_SB(sb)->s_groups_count; i++) {\n\t\tdesc = ext2_get_group_desc(sb, i, NULL);\n\t\tif (!desc)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(desc->bg_free_blocks_count);\n\t}\n\treturn desc_count;\n#endif\n}\n\nstatic inline int test_root(int a, int b)\n{\n\tint num = b;\n\n\twhile (a > num)\n\t\tnum *= b;\n\treturn num == a;\n}\n\nstatic int ext2_group_sparse(int group)\n{\n\tif (group <= 1)\n\t\treturn 1;\n\treturn (test_root(group, 3) || test_root(group, 5) ||\n\t\ttest_root(group, 7));\n}\n\n \nint ext2_bg_has_super(struct super_block *sb, int group)\n{\n\tif (EXT2_HAS_RO_COMPAT_FEATURE(sb,EXT2_FEATURE_RO_COMPAT_SPARSE_SUPER)&&\n\t    !ext2_group_sparse(group))\n\t\treturn 0;\n\treturn 1;\n}\n\n \nunsigned long ext2_bg_num_gdb(struct super_block *sb, int group)\n{\n\treturn ext2_bg_has_super(sb, group) ? EXT2_SB(sb)->s_gdb_count : 0;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}