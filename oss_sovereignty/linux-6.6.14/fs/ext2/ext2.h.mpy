{
  "module_name": "ext2.h",
  "hash_id": "41525da71dd3e540e17f957dccf13c5c62492fc3b822d66fcb6f9b13f81490ce",
  "original_prompt": "Ingested from linux-6.6.14/fs/ext2/ext2.h",
  "human_readable_source": " \n \n#include <linux/fs.h>\n#include <linux/ext2_fs.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/percpu_counter.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n\n \n\n \ntypedef int ext2_grpblk_t;\n\n \ntypedef unsigned long ext2_fsblk_t;\n\n#define E2FSBLK \"%lu\"\n\nstruct ext2_reserve_window {\n\text2_fsblk_t\t\t_rsv_start;\t \n\text2_fsblk_t\t\t_rsv_end;\t \n};\n\nstruct ext2_reserve_window_node {\n\tstruct rb_node\t \trsv_node;\n\t__u32\t\t\trsv_goal_size;\n\t__u32\t\t\trsv_alloc_hit;\n\tstruct ext2_reserve_window\trsv_window;\n};\n\nstruct ext2_block_alloc_info {\n\t \n\tstruct ext2_reserve_window_node\trsv_window_node;\n\t \n\t__u32\t\t\tlast_alloc_logical_block;\n\t \n\text2_fsblk_t\t\tlast_alloc_physical_block;\n};\n\n#define rsv_start rsv_window._rsv_start\n#define rsv_end rsv_window._rsv_end\n\nstruct mb_cache;\n\n \nstruct ext2_sb_info {\n\tunsigned long s_inodes_per_block; \n\tunsigned long s_blocks_per_group; \n\tunsigned long s_inodes_per_group; \n\tunsigned long s_itb_per_group;\t \n\tunsigned long s_gdb_count;\t \n\tunsigned long s_desc_per_block;\t \n\tunsigned long s_groups_count;\t \n\tunsigned long s_overhead_last;   \n\tunsigned long s_blocks_last;     \n\tstruct buffer_head * s_sbh;\t \n\tstruct ext2_super_block * s_es;\t \n\tstruct buffer_head ** s_group_desc;\n\tunsigned long  s_mount_opt;\n\tunsigned long s_sb_block;\n\tkuid_t s_resuid;\n\tkgid_t s_resgid;\n\tunsigned short s_mount_state;\n\tunsigned short s_pad;\n\tint s_addr_per_block_bits;\n\tint s_desc_per_block_bits;\n\tint s_inode_size;\n\tint s_first_ino;\n\tspinlock_t s_next_gen_lock;\n\tu32 s_next_generation;\n\tunsigned long s_dir_count;\n\tu8 *s_debts;\n\tstruct percpu_counter s_freeblocks_counter;\n\tstruct percpu_counter s_freeinodes_counter;\n\tstruct percpu_counter s_dirs_counter;\n\tstruct blockgroup_lock *s_blockgroup_lock;\n\t \n\tspinlock_t s_rsv_window_lock;\n\tstruct rb_root s_rsv_window_root;\n\tstruct ext2_reserve_window_node s_rsv_window_head;\n\t \n\tspinlock_t s_lock;\n\tstruct mb_cache *s_ea_block_cache;\n\tstruct dax_device *s_daxdev;\n\tu64 s_dax_part_off;\n};\n\nstatic inline spinlock_t *\nsb_bgl_lock(struct ext2_sb_info *sbi, unsigned int block_group)\n{\n\treturn bgl_lock_ptr(sbi->s_blockgroup_lock, block_group);\n}\n\n \n#undef EXT2FS_DEBUG\n\n \n#define EXT2_DEFAULT_RESERVE_BLOCKS     8\n \n#define EXT2_MAX_RESERVE_BLOCKS         1027\n#define EXT2_RESERVE_WINDOW_NOT_ALLOCATED 0\n \n#define EXT2FS_DATE\t\t\"95/08/09\"\n#define EXT2FS_VERSION\t\t\"0.5b\"\n\n \n#ifdef EXT2FS_DEBUG\n#\tdefine ext2_debug(f, a...)\t{ \\\n\t\t\t\t\tprintk (\"EXT2-fs DEBUG (%s, %d): %s:\", \\\n\t\t\t\t\t\t__FILE__, __LINE__, __func__); \\\n\t\t\t\t  \tprintk (f, ## a); \\\n\t\t\t\t\t}\n#else\n#\tdefine ext2_debug(f, a...)\t \n#endif\n\n \n#define\tEXT2_BAD_INO\t\t 1\t \n#define EXT2_ROOT_INO\t\t 2\t \n#define EXT2_BOOT_LOADER_INO\t 5\t \n#define EXT2_UNDEL_DIR_INO\t 6\t \n\n \n#define EXT2_GOOD_OLD_FIRST_INO\t11\n\nstatic inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}\n\n \n#define EXT2_MIN_BLOCK_SIZE\t\t1024\n#define\tEXT2_MAX_BLOCK_SIZE\t\t65536\n#define EXT2_MIN_BLOCK_LOG_SIZE\t\t  10\n#define EXT2_MAX_BLOCK_LOG_SIZE\t\t  16\n#define EXT2_BLOCK_SIZE(s)\t\t((s)->s_blocksize)\n#define\tEXT2_ADDR_PER_BLOCK(s)\t\t(EXT2_BLOCK_SIZE(s) / sizeof (__u32))\n#define EXT2_BLOCK_SIZE_BITS(s)\t\t((s)->s_blocksize_bits)\n#define\tEXT2_ADDR_PER_BLOCK_BITS(s)\t(EXT2_SB(s)->s_addr_per_block_bits)\n#define EXT2_INODE_SIZE(s)\t\t(EXT2_SB(s)->s_inode_size)\n#define EXT2_FIRST_INO(s)\t\t(EXT2_SB(s)->s_first_ino)\n\n \nstruct ext2_group_desc\n{\n\t__le32\tbg_block_bitmap;\t\t \n\t__le32\tbg_inode_bitmap;\t\t \n\t__le32\tbg_inode_table;\t\t \n\t__le16\tbg_free_blocks_count;\t \n\t__le16\tbg_free_inodes_count;\t \n\t__le16\tbg_used_dirs_count;\t \n\t__le16\tbg_pad;\n\t__le32\tbg_reserved[3];\n};\n\n \n#define EXT2_BLOCKS_PER_GROUP(s)\t(EXT2_SB(s)->s_blocks_per_group)\n#define EXT2_DESC_PER_BLOCK(s)\t\t(EXT2_SB(s)->s_desc_per_block)\n#define EXT2_INODES_PER_GROUP(s)\t(EXT2_SB(s)->s_inodes_per_group)\n#define EXT2_DESC_PER_BLOCK_BITS(s)\t(EXT2_SB(s)->s_desc_per_block_bits)\n\n \n#define\tEXT2_NDIR_BLOCKS\t\t12\n#define\tEXT2_IND_BLOCK\t\t\tEXT2_NDIR_BLOCKS\n#define\tEXT2_DIND_BLOCK\t\t\t(EXT2_IND_BLOCK + 1)\n#define\tEXT2_TIND_BLOCK\t\t\t(EXT2_DIND_BLOCK + 1)\n#define\tEXT2_N_BLOCKS\t\t\t(EXT2_TIND_BLOCK + 1)\n\n \n#define\tEXT2_SECRM_FL\t\t\tFS_SECRM_FL\t \n#define\tEXT2_UNRM_FL\t\t\tFS_UNRM_FL\t \n#define\tEXT2_COMPR_FL\t\t\tFS_COMPR_FL\t \n#define EXT2_SYNC_FL\t\t\tFS_SYNC_FL\t \n#define EXT2_IMMUTABLE_FL\t\tFS_IMMUTABLE_FL\t \n#define EXT2_APPEND_FL\t\t\tFS_APPEND_FL\t \n#define EXT2_NODUMP_FL\t\t\tFS_NODUMP_FL\t \n#define EXT2_NOATIME_FL\t\t\tFS_NOATIME_FL\t \n \n#define EXT2_DIRTY_FL\t\t\tFS_DIRTY_FL\n#define EXT2_COMPRBLK_FL\t\tFS_COMPRBLK_FL\t \n#define EXT2_NOCOMP_FL\t\t\tFS_NOCOMP_FL\t \n#define EXT2_ECOMPR_FL\t\t\tFS_ECOMPR_FL\t \n \t\n#define EXT2_BTREE_FL\t\t\tFS_BTREE_FL\t \n#define EXT2_INDEX_FL\t\t\tFS_INDEX_FL\t \n#define EXT2_IMAGIC_FL\t\t\tFS_IMAGIC_FL\t \n#define EXT2_JOURNAL_DATA_FL\t\tFS_JOURNAL_DATA_FL  \n#define EXT2_NOTAIL_FL\t\t\tFS_NOTAIL_FL\t \n#define EXT2_DIRSYNC_FL\t\t\tFS_DIRSYNC_FL\t \n#define EXT2_TOPDIR_FL\t\t\tFS_TOPDIR_FL\t \n#define EXT2_RESERVED_FL\t\tFS_RESERVED_FL\t \n\n#define EXT2_FL_USER_VISIBLE\t\tFS_FL_USER_VISIBLE\t \n#define EXT2_FL_USER_MODIFIABLE\t\tFS_FL_USER_MODIFIABLE\t \n\n \n#define EXT2_FL_INHERITED (EXT2_SECRM_FL | EXT2_UNRM_FL | EXT2_COMPR_FL |\\\n\t\t\t   EXT2_SYNC_FL | EXT2_NODUMP_FL |\\\n\t\t\t   EXT2_NOATIME_FL | EXT2_COMPRBLK_FL |\\\n\t\t\t   EXT2_NOCOMP_FL | EXT2_JOURNAL_DATA_FL |\\\n\t\t\t   EXT2_NOTAIL_FL | EXT2_DIRSYNC_FL)\n\n \n#define EXT2_REG_FLMASK (~(EXT2_DIRSYNC_FL | EXT2_TOPDIR_FL))\n\n \n#define EXT2_OTHER_FLMASK (EXT2_NODUMP_FL | EXT2_NOATIME_FL)\n\n \nstatic inline __u32 ext2_mask_flags(umode_t mode, __u32 flags)\n{\n\tif (S_ISDIR(mode))\n\t\treturn flags;\n\telse if (S_ISREG(mode))\n\t\treturn flags & EXT2_REG_FLMASK;\n\telse\n\t\treturn flags & EXT2_OTHER_FLMASK;\n}\n\n \n#define\tEXT2_IOC_GETVERSION\t\tFS_IOC_GETVERSION\n#define\tEXT2_IOC_SETVERSION\t\tFS_IOC_SETVERSION\n#define\tEXT2_IOC_GETRSVSZ\t\t_IOR('f', 5, long)\n#define\tEXT2_IOC_SETRSVSZ\t\t_IOW('f', 6, long)\n\n \n#define EXT2_IOC32_GETVERSION\t\tFS_IOC32_GETVERSION\n#define EXT2_IOC32_SETVERSION\t\tFS_IOC32_SETVERSION\n\n \nstruct ext2_inode {\n\t__le16\ti_mode;\t\t \n\t__le16\ti_uid;\t\t \n\t__le32\ti_size;\t\t \n\t__le32\ti_atime;\t \n\t__le32\ti_ctime;\t \n\t__le32\ti_mtime;\t \n\t__le32\ti_dtime;\t \n\t__le16\ti_gid;\t\t \n\t__le16\ti_links_count;\t \n\t__le32\ti_blocks;\t \n\t__le32\ti_flags;\t \n\tunion {\n\t\tstruct {\n\t\t\t__le32  l_i_reserved1;\n\t\t} linux1;\n\t\tstruct {\n\t\t\t__le32  h_i_translator;\n\t\t} hurd1;\n\t\tstruct {\n\t\t\t__le32  m_i_reserved1;\n\t\t} masix1;\n\t} osd1;\t\t\t\t \n\t__le32\ti_block[EXT2_N_BLOCKS]; \n\t__le32\ti_generation;\t \n\t__le32\ti_file_acl;\t \n\t__le32\ti_dir_acl;\t \n\t__le32\ti_faddr;\t \n\tunion {\n\t\tstruct {\n\t\t\t__u8\tl_i_frag;\t \n\t\t\t__u8\tl_i_fsize;\t \n\t\t\t__u16\ti_pad1;\n\t\t\t__le16\tl_i_uid_high;\t \n\t\t\t__le16\tl_i_gid_high;\t \n\t\t\t__u32\tl_i_reserved2;\n\t\t} linux2;\n\t\tstruct {\n\t\t\t__u8\th_i_frag;\t \n\t\t\t__u8\th_i_fsize;\t \n\t\t\t__le16\th_i_mode_high;\n\t\t\t__le16\th_i_uid_high;\n\t\t\t__le16\th_i_gid_high;\n\t\t\t__le32\th_i_author;\n\t\t} hurd2;\n\t\tstruct {\n\t\t\t__u8\tm_i_frag;\t \n\t\t\t__u8\tm_i_fsize;\t \n\t\t\t__u16\tm_pad1;\n\t\t\t__u32\tm_i_reserved2[2];\n\t\t} masix2;\n\t} osd2;\t\t\t\t \n};\n\n#define i_size_high\ti_dir_acl\n\n#define i_reserved1\tosd1.linux1.l_i_reserved1\n#define i_frag\t\tosd2.linux2.l_i_frag\n#define i_fsize\t\tosd2.linux2.l_i_fsize\n#define i_uid_low\ti_uid\n#define i_gid_low\ti_gid\n#define i_uid_high\tosd2.linux2.l_i_uid_high\n#define i_gid_high\tosd2.linux2.l_i_gid_high\n#define i_reserved2\tosd2.linux2.l_i_reserved2\n\n \n#define\tEXT2_VALID_FS\t\t\t0x0001\t \n#define\tEXT2_ERROR_FS\t\t\t0x0002\t \n#define\tEFSCORRUPTED\t\t\tEUCLEAN\t \n\n \n#define EXT2_MOUNT_OLDALLOC\t\t0x000002   \n#define EXT2_MOUNT_GRPID\t\t0x000004   \n#define EXT2_MOUNT_DEBUG\t\t0x000008   \n#define EXT2_MOUNT_ERRORS_CONT\t\t0x000010   \n#define EXT2_MOUNT_ERRORS_RO\t\t0x000020   \n#define EXT2_MOUNT_ERRORS_PANIC\t\t0x000040   \n#define EXT2_MOUNT_MINIX_DF\t\t0x000080   \n#define EXT2_MOUNT_NOBH\t\t\t0x000100   \n#define EXT2_MOUNT_NO_UID32\t\t0x000200   \n#define EXT2_MOUNT_XATTR_USER\t\t0x004000   \n#define EXT2_MOUNT_POSIX_ACL\t\t0x008000   \n#define EXT2_MOUNT_XIP\t\t\t0x010000   \n#define EXT2_MOUNT_USRQUOTA\t\t0x020000   \n#define EXT2_MOUNT_GRPQUOTA\t\t0x040000   \n#define EXT2_MOUNT_RESERVATION\t\t0x080000   \n#define EXT2_MOUNT_DAX\t\t\t0x100000   \n\n\n#define clear_opt(o, opt)\t\to &= ~EXT2_MOUNT_##opt\n#define set_opt(o, opt)\t\t\to |= EXT2_MOUNT_##opt\n#define test_opt(sb, opt)\t\t(EXT2_SB(sb)->s_mount_opt & \\\n\t\t\t\t\t EXT2_MOUNT_##opt)\n \n#define EXT2_DFL_MAX_MNT_COUNT\t\t20\t \n#define EXT2_DFL_CHECKINTERVAL\t\t0\t \n\n \n#define EXT2_ERRORS_CONTINUE\t\t1\t \n#define EXT2_ERRORS_RO\t\t\t2\t \n#define EXT2_ERRORS_PANIC\t\t3\t \n#define EXT2_ERRORS_DEFAULT\t\tEXT2_ERRORS_CONTINUE\n\n \n#define EXT2_ALLOC_NORESERVE            0x1\t \n\n \nstruct ext2_super_block {\n\t__le32\ts_inodes_count;\t\t \n\t__le32\ts_blocks_count;\t\t \n\t__le32\ts_r_blocks_count;\t \n\t__le32\ts_free_blocks_count;\t \n\t__le32\ts_free_inodes_count;\t \n\t__le32\ts_first_data_block;\t \n\t__le32\ts_log_block_size;\t \n\t__le32\ts_log_frag_size;\t \n\t__le32\ts_blocks_per_group;\t \n\t__le32\ts_frags_per_group;\t \n\t__le32\ts_inodes_per_group;\t \n\t__le32\ts_mtime;\t\t \n\t__le32\ts_wtime;\t\t \n\t__le16\ts_mnt_count;\t\t \n\t__le16\ts_max_mnt_count;\t \n\t__le16\ts_magic;\t\t \n\t__le16\ts_state;\t\t \n\t__le16\ts_errors;\t\t \n\t__le16\ts_minor_rev_level; \t \n\t__le32\ts_lastcheck;\t\t \n\t__le32\ts_checkinterval;\t \n\t__le32\ts_creator_os;\t\t \n\t__le32\ts_rev_level;\t\t \n\t__le16\ts_def_resuid;\t\t \n\t__le16\ts_def_resgid;\t\t \n\t \n\t__le32\ts_first_ino; \t\t \n\t__le16   s_inode_size; \t\t \n\t__le16\ts_block_group_nr; \t \n\t__le32\ts_feature_compat; \t \n\t__le32\ts_feature_incompat; \t \n\t__le32\ts_feature_ro_compat; \t \n\t__u8\ts_uuid[16];\t\t \n\tchar\ts_volume_name[16]; \t \n\tchar\ts_last_mounted[64]; \t \n\t__le32\ts_algorithm_usage_bitmap;  \n\t \n\t__u8\ts_prealloc_blocks;\t \n\t__u8\ts_prealloc_dir_blocks;\t \n\t__u16\ts_padding1;\n\t \n\t__u8\ts_journal_uuid[16];\t \n\t__u32\ts_journal_inum;\t\t \n\t__u32\ts_journal_dev;\t\t \n\t__u32\ts_last_orphan;\t\t \n\t__u32\ts_hash_seed[4];\t\t \n\t__u8\ts_def_hash_version;\t \n\t__u8\ts_reserved_char_pad;\n\t__u16\ts_reserved_word_pad;\n\t__le32\ts_default_mount_opts;\n \t__le32\ts_first_meta_bg; \t \n\t__u32\ts_reserved[190];\t \n};\n\n \n#define EXT2_OS_LINUX\t\t0\n#define EXT2_OS_HURD\t\t1\n#define EXT2_OS_MASIX\t\t2\n#define EXT2_OS_FREEBSD\t\t3\n#define EXT2_OS_LITES\t\t4\n\n \n#define EXT2_GOOD_OLD_REV\t0\t \n#define EXT2_DYNAMIC_REV\t1 \t \n\n#define EXT2_CURRENT_REV\tEXT2_GOOD_OLD_REV\n#define EXT2_MAX_SUPP_REV\tEXT2_DYNAMIC_REV\n\n#define EXT2_GOOD_OLD_INODE_SIZE 128\n\n \n\n#define EXT2_HAS_COMPAT_FEATURE(sb,mask)\t\t\t\\\n\t( EXT2_SB(sb)->s_es->s_feature_compat & cpu_to_le32(mask) )\n#define EXT2_HAS_RO_COMPAT_FEATURE(sb,mask)\t\t\t\\\n\t( EXT2_SB(sb)->s_es->s_feature_ro_compat & cpu_to_le32(mask) )\n#define EXT2_HAS_INCOMPAT_FEATURE(sb,mask)\t\t\t\\\n\t( EXT2_SB(sb)->s_es->s_feature_incompat & cpu_to_le32(mask) )\n#define EXT2_SET_COMPAT_FEATURE(sb,mask)\t\t\t\\\n\tEXT2_SB(sb)->s_es->s_feature_compat |= cpu_to_le32(mask)\n#define EXT2_SET_RO_COMPAT_FEATURE(sb,mask)\t\t\t\\\n\tEXT2_SB(sb)->s_es->s_feature_ro_compat |= cpu_to_le32(mask)\n#define EXT2_SET_INCOMPAT_FEATURE(sb,mask)\t\t\t\\\n\tEXT2_SB(sb)->s_es->s_feature_incompat |= cpu_to_le32(mask)\n#define EXT2_CLEAR_COMPAT_FEATURE(sb,mask)\t\t\t\\\n\tEXT2_SB(sb)->s_es->s_feature_compat &= ~cpu_to_le32(mask)\n#define EXT2_CLEAR_RO_COMPAT_FEATURE(sb,mask)\t\t\t\\\n\tEXT2_SB(sb)->s_es->s_feature_ro_compat &= ~cpu_to_le32(mask)\n#define EXT2_CLEAR_INCOMPAT_FEATURE(sb,mask)\t\t\t\\\n\tEXT2_SB(sb)->s_es->s_feature_incompat &= ~cpu_to_le32(mask)\n\n#define EXT2_FEATURE_COMPAT_DIR_PREALLOC\t0x0001\n#define EXT2_FEATURE_COMPAT_IMAGIC_INODES\t0x0002\n#define EXT3_FEATURE_COMPAT_HAS_JOURNAL\t\t0x0004\n#define EXT2_FEATURE_COMPAT_EXT_ATTR\t\t0x0008\n#define EXT2_FEATURE_COMPAT_RESIZE_INO\t\t0x0010\n#define EXT2_FEATURE_COMPAT_DIR_INDEX\t\t0x0020\n#define EXT2_FEATURE_COMPAT_ANY\t\t\t0xffffffff\n\n#define EXT2_FEATURE_RO_COMPAT_SPARSE_SUPER\t0x0001\n#define EXT2_FEATURE_RO_COMPAT_LARGE_FILE\t0x0002\n#define EXT2_FEATURE_RO_COMPAT_BTREE_DIR\t0x0004\n#define EXT2_FEATURE_RO_COMPAT_ANY\t\t0xffffffff\n\n#define EXT2_FEATURE_INCOMPAT_COMPRESSION\t0x0001\n#define EXT2_FEATURE_INCOMPAT_FILETYPE\t\t0x0002\n#define EXT3_FEATURE_INCOMPAT_RECOVER\t\t0x0004\n#define EXT3_FEATURE_INCOMPAT_JOURNAL_DEV\t0x0008\n#define EXT2_FEATURE_INCOMPAT_META_BG\t\t0x0010\n#define EXT2_FEATURE_INCOMPAT_ANY\t\t0xffffffff\n\n#define EXT2_FEATURE_COMPAT_SUPP\tEXT2_FEATURE_COMPAT_EXT_ATTR\n#define EXT2_FEATURE_INCOMPAT_SUPP\t(EXT2_FEATURE_INCOMPAT_FILETYPE| \\\n\t\t\t\t\t EXT2_FEATURE_INCOMPAT_META_BG)\n#define EXT2_FEATURE_RO_COMPAT_SUPP\t(EXT2_FEATURE_RO_COMPAT_SPARSE_SUPER| \\\n\t\t\t\t\t EXT2_FEATURE_RO_COMPAT_LARGE_FILE| \\\n\t\t\t\t\t EXT2_FEATURE_RO_COMPAT_BTREE_DIR)\n#define EXT2_FEATURE_RO_COMPAT_UNSUPPORTED\t~EXT2_FEATURE_RO_COMPAT_SUPP\n#define EXT2_FEATURE_INCOMPAT_UNSUPPORTED\t~EXT2_FEATURE_INCOMPAT_SUPP\n\n \n#define\tEXT2_DEF_RESUID\t\t0\n#define\tEXT2_DEF_RESGID\t\t0\n\n \n#define EXT2_DEFM_DEBUG\t\t0x0001\n#define EXT2_DEFM_BSDGROUPS\t0x0002\n#define EXT2_DEFM_XATTR_USER\t0x0004\n#define EXT2_DEFM_ACL\t\t0x0008\n#define EXT2_DEFM_UID16\t\t0x0010\n     \n#define EXT3_DEFM_JMODE\t\t0x0060 \n#define EXT3_DEFM_JMODE_DATA\t0x0020\n#define EXT3_DEFM_JMODE_ORDERED\t0x0040\n#define EXT3_DEFM_JMODE_WBACK\t0x0060\n\n \n\nstruct ext2_dir_entry {\n\t__le32\tinode;\t\t\t \n\t__le16\trec_len;\t\t \n\t__le16\tname_len;\t\t \n\tchar\tname[];\t\t\t \n};\n\n \nstruct ext2_dir_entry_2 {\n\t__le32\tinode;\t\t\t \n\t__le16\trec_len;\t\t \n\t__u8\tname_len;\t\t \n\t__u8\tfile_type;\n\tchar\tname[];\t\t\t \n};\n\n \n#define EXT2_DIR_PAD\t\t \t4\n#define EXT2_DIR_ROUND \t\t\t(EXT2_DIR_PAD - 1)\n#define EXT2_DIR_REC_LEN(name_len)\t(((name_len) + 8 + EXT2_DIR_ROUND) & \\\n\t\t\t\t\t ~EXT2_DIR_ROUND)\n#define EXT2_MAX_REC_LEN\t\t((1<<16)-1)\n\nstatic inline void verify_offsets(void)\n{\n#define A(x,y) BUILD_BUG_ON(x != offsetof(struct ext2_super_block, y));\n\tA(EXT2_SB_MAGIC_OFFSET, s_magic);\n\tA(EXT2_SB_BLOCKS_OFFSET, s_blocks_count);\n\tA(EXT2_SB_BSIZE_OFFSET, s_log_block_size);\n#undef A\n}\n\n \nstruct ext2_mount_options {\n\tunsigned long s_mount_opt;\n\tkuid_t s_resuid;\n\tkgid_t s_resgid;\n};\n\n \nstruct ext2_inode_info {\n\t__le32\ti_data[15];\n\t__u32\ti_flags;\n\t__u32\ti_faddr;\n\t__u8\ti_frag_no;\n\t__u8\ti_frag_size;\n\t__u16\ti_state;\n\t__u32\ti_file_acl;\n\t__u32\ti_dir_acl;\n\t__u32\ti_dtime;\n\n\t \n\t__u32\ti_block_group;\n\n\t \n\tstruct ext2_block_alloc_info *i_block_alloc_info;\n\n\t__u32\ti_dir_start_lookup;\n#ifdef CONFIG_EXT2_FS_XATTR\n\t \n\tstruct rw_semaphore xattr_sem;\n#endif\n\trwlock_t i_meta_lock;\n\n\t \n\tstruct mutex truncate_mutex;\n\tstruct inode\tvfs_inode;\n\tstruct list_head i_orphan;\t \n#ifdef CONFIG_QUOTA\n\tstruct dquot *i_dquot[MAXQUOTAS];\n#endif\n};\n\n \n#define EXT2_STATE_NEW\t\t\t0x00000001  \n\n\n \n\n \n\nstatic inline struct ext2_inode_info *EXT2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext2_inode_info, vfs_inode);\n}\n\n \nextern int ext2_bg_has_super(struct super_block *sb, int group);\nextern unsigned long ext2_bg_num_gdb(struct super_block *sb, int group);\nextern ext2_fsblk_t ext2_new_blocks(struct inode *, ext2_fsblk_t,\n\t\t\t\tunsigned long *, int *, unsigned int);\nextern int ext2_data_block_valid(struct ext2_sb_info *sbi, ext2_fsblk_t start_blk,\n\t\t\t\t unsigned int count);\nextern void ext2_free_blocks(struct inode *, ext2_fsblk_t, unsigned long);\nextern unsigned long ext2_count_free_blocks (struct super_block *);\nextern unsigned long ext2_count_dirs (struct super_block *);\nextern struct ext2_group_desc * ext2_get_group_desc(struct super_block * sb,\n\t\t\t\t\t\t    unsigned int block_group,\n\t\t\t\t\t\t    struct buffer_head ** bh);\nextern void ext2_discard_reservation (struct inode *);\nextern int ext2_should_retry_alloc(struct super_block *sb, int *retries);\nextern void ext2_init_block_alloc_info(struct inode *);\nextern void ext2_rsv_window_add(struct super_block *sb, struct ext2_reserve_window_node *rsv);\n\n \nextern int ext2_add_link (struct dentry *, struct inode *);\nextern int ext2_inode_by_name(struct inode *dir,\n\t\t\t      const struct qstr *child, ino_t *ino);\nextern int ext2_make_empty(struct inode *, struct inode *);\nextern struct ext2_dir_entry_2 *ext2_find_entry(struct inode *, const struct qstr *,\n\t\t\t\t\t\tstruct page **);\nextern int ext2_delete_entry(struct ext2_dir_entry_2 *dir, struct page *page);\nextern int ext2_empty_dir (struct inode *);\nextern struct ext2_dir_entry_2 *ext2_dotdot(struct inode *dir, struct page **p);\nint ext2_set_link(struct inode *dir, struct ext2_dir_entry_2 *de,\n\t\tstruct page *page, struct inode *inode, bool update_times);\nstatic inline void ext2_put_page(struct page *page, void *page_addr)\n{\n\tkunmap_local(page_addr);\n\tput_page(page);\n}\n\n \nextern struct inode * ext2_new_inode (struct inode *, umode_t, const struct qstr *);\nextern void ext2_free_inode (struct inode *);\nextern unsigned long ext2_count_free_inodes (struct super_block *);\nextern unsigned long ext2_count_free (struct buffer_head *, unsigned);\n\n \nextern struct inode *ext2_iget (struct super_block *, unsigned long);\nextern int ext2_write_inode (struct inode *, struct writeback_control *);\nextern void ext2_evict_inode(struct inode *);\nvoid ext2_write_failed(struct address_space *mapping, loff_t to);\nextern int ext2_get_block(struct inode *, sector_t, struct buffer_head *, int);\nextern int ext2_setattr (struct mnt_idmap *, struct dentry *, struct iattr *);\nextern int ext2_getattr (struct mnt_idmap *, const struct path *,\n\t\t\t struct kstat *, u32, unsigned int);\nextern void ext2_set_inode_flags(struct inode *inode);\nextern int ext2_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t       u64 start, u64 len);\n\n \nextern int ext2_fileattr_get(struct dentry *dentry, struct fileattr *fa);\nextern int ext2_fileattr_set(struct mnt_idmap *idmap,\n\t\t\t     struct dentry *dentry, struct fileattr *fa);\nextern long ext2_ioctl(struct file *, unsigned int, unsigned long);\nextern long ext2_compat_ioctl(struct file *, unsigned int, unsigned long);\n\n \nstruct dentry *ext2_get_parent(struct dentry *child);\n\n \nextern __printf(3, 4)\nvoid ext2_error(struct super_block *, const char *, const char *, ...);\nextern __printf(3, 4)\nvoid ext2_msg(struct super_block *, const char *, const char *, ...);\nextern void ext2_update_dynamic_rev (struct super_block *sb);\nextern void ext2_sync_super(struct super_block *sb, struct ext2_super_block *es,\n\t\t\t    int wait);\n\n \n\n \nextern const struct file_operations ext2_dir_operations;\n\n \nextern int ext2_fsync(struct file *file, loff_t start, loff_t end,\n\t\t      int datasync);\nextern const struct inode_operations ext2_file_inode_operations;\nextern const struct file_operations ext2_file_operations;\n\n \nextern void ext2_set_file_ops(struct inode *inode);\nextern const struct address_space_operations ext2_aops;\nextern const struct iomap_ops ext2_iomap_ops;\n\n \nextern const struct inode_operations ext2_dir_inode_operations;\nextern const struct inode_operations ext2_special_inode_operations;\n\n \nextern const struct inode_operations ext2_fast_symlink_inode_operations;\nextern const struct inode_operations ext2_symlink_inode_operations;\n\nstatic inline ext2_fsblk_t\next2_group_first_block_no(struct super_block *sb, unsigned long group_no)\n{\n\treturn group_no * (ext2_fsblk_t)EXT2_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT2_SB(sb)->s_es->s_first_data_block);\n}\n\nstatic inline ext2_fsblk_t\next2_group_last_block_no(struct super_block *sb, unsigned long group_no)\n{\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\n\tif (group_no == sbi->s_groups_count - 1)\n\t\treturn le32_to_cpu(sbi->s_es->s_blocks_count) - 1;\n\telse\n\t\treturn ext2_group_first_block_no(sb, group_no) +\n\t\t\tEXT2_BLOCKS_PER_GROUP(sb) - 1;\n}\n\n#define ext2_set_bit\t__test_and_set_bit_le\n#define ext2_clear_bit\t__test_and_clear_bit_le\n#define ext2_test_bit\ttest_bit_le\n#define ext2_find_first_zero_bit\tfind_first_zero_bit_le\n#define ext2_find_next_zero_bit\t\tfind_next_zero_bit_le\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}