{
  "module_name": "xattr.c",
  "hash_id": "88522284edcf41b2430671918aae97da240a24bfc6a4d32537c5a82dfd04a6f0",
  "original_prompt": "Ingested from linux-6.6.14/fs/ext2/xattr.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/mbcache.h>\n#include <linux/quotaops.h>\n#include <linux/rwsem.h>\n#include <linux/security.h>\n#include \"ext2.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n\n#define HDR(bh) ((struct ext2_xattr_header *)((bh)->b_data))\n#define ENTRY(ptr) ((struct ext2_xattr_entry *)(ptr))\n#define FIRST_ENTRY(bh) ENTRY(HDR(bh)+1)\n#define IS_LAST_ENTRY(entry) (*(__u32 *)(entry) == 0)\n\n#ifdef EXT2_XATTR_DEBUG\n# define ea_idebug(inode, f...) do { \\\n\t\tprintk(KERN_DEBUG \"inode %s:%ld: \", \\\n\t\t\tinode->i_sb->s_id, inode->i_ino); \\\n\t\tprintk(f); \\\n\t\tprintk(\"\\n\"); \\\n\t} while (0)\n# define ea_bdebug(bh, f...) do { \\\n\t\tprintk(KERN_DEBUG \"block %pg:%lu: \", \\\n\t\t\tbh->b_bdev, (unsigned long) bh->b_blocknr); \\\n\t\tprintk(f); \\\n\t\tprintk(\"\\n\"); \\\n\t} while (0)\n#else\n# define ea_idebug(inode, f...)\tno_printk(f)\n# define ea_bdebug(bh, f...)\tno_printk(f)\n#endif\n\nstatic int ext2_xattr_set2(struct inode *, struct buffer_head *,\n\t\t\t   struct ext2_xattr_header *);\n\nstatic int ext2_xattr_cache_insert(struct mb_cache *, struct buffer_head *);\nstatic struct buffer_head *ext2_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext2_xattr_header *);\nstatic void ext2_xattr_rehash(struct ext2_xattr_header *,\n\t\t\t      struct ext2_xattr_entry *);\n\nstatic const struct xattr_handler *ext2_xattr_handler_map[] = {\n\t[EXT2_XATTR_INDEX_USER]\t\t     = &ext2_xattr_user_handler,\n#ifdef CONFIG_EXT2_FS_POSIX_ACL\n\t[EXT2_XATTR_INDEX_POSIX_ACL_ACCESS]  = &nop_posix_acl_access,\n\t[EXT2_XATTR_INDEX_POSIX_ACL_DEFAULT] = &nop_posix_acl_default,\n#endif\n\t[EXT2_XATTR_INDEX_TRUSTED]\t     = &ext2_xattr_trusted_handler,\n#ifdef CONFIG_EXT2_FS_SECURITY\n\t[EXT2_XATTR_INDEX_SECURITY]\t     = &ext2_xattr_security_handler,\n#endif\n};\n\nconst struct xattr_handler *ext2_xattr_handlers[] = {\n\t&ext2_xattr_user_handler,\n\t&ext2_xattr_trusted_handler,\n#ifdef CONFIG_EXT2_FS_SECURITY\n\t&ext2_xattr_security_handler,\n#endif\n\tNULL\n};\n\n#define EA_BLOCK_CACHE(inode)\t(EXT2_SB(inode->i_sb)->s_ea_block_cache)\n\nstatic inline const char *ext2_xattr_prefix(int name_index,\n\t\t\t\t\t    struct dentry *dentry)\n{\n\tconst struct xattr_handler *handler = NULL;\n\n\tif (name_index > 0 && name_index < ARRAY_SIZE(ext2_xattr_handler_map))\n\t\thandler = ext2_xattr_handler_map[name_index];\n\n\tif (!xattr_handler_can_list(handler, dentry))\n\t\treturn NULL;\n\n\treturn xattr_prefix(handler);\n}\n\nstatic bool\next2_xattr_header_valid(struct ext2_xattr_header *header)\n{\n\tif (header->h_magic != cpu_to_le32(EXT2_XATTR_MAGIC) ||\n\t    header->h_blocks != cpu_to_le32(1))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool\next2_xattr_entry_valid(struct ext2_xattr_entry *entry,\n\t\t       char *end, size_t end_offs)\n{\n\tstruct ext2_xattr_entry *next;\n\tsize_t size;\n\n\tnext = EXT2_XATTR_NEXT(entry);\n\tif ((char *)next >= end)\n\t\treturn false;\n\n\tif (entry->e_value_block != 0)\n\t\treturn false;\n\n\tsize = le32_to_cpu(entry->e_value_size);\n\tif (size > end_offs ||\n\t    le16_to_cpu(entry->e_value_offs) + size > end_offs)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int\next2_xattr_cmp_entry(int name_index, size_t name_len, const char *name,\n\t\t     struct ext2_xattr_entry *entry)\n{\n\tint cmp;\n\n\tcmp = name_index - entry->e_name_index;\n\tif (!cmp)\n\t\tcmp = name_len - entry->e_name_len;\n\tif (!cmp)\n\t\tcmp = memcmp(name, entry->e_name, name_len);\n\n\treturn cmp;\n}\n\n \nint\next2_xattr_get(struct inode *inode, int name_index, const char *name,\n\t       void *buffer, size_t buffer_size)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct ext2_xattr_entry *entry;\n\tsize_t name_len, size;\n\tchar *end;\n\tint error, not_found;\n\tstruct mb_cache *ea_block_cache = EA_BLOCK_CACHE(inode);\n\n\tea_idebug(inode, \"name=%d.%s, buffer=%p, buffer_size=%ld\",\n\t\t  name_index, name, buffer, (long)buffer_size);\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\tname_len = strlen(name);\n\tif (name_len > 255)\n\t\treturn -ERANGE;\n\n\tdown_read(&EXT2_I(inode)->xattr_sem);\n\terror = -ENODATA;\n\tif (!EXT2_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tea_idebug(inode, \"reading block %d\", EXT2_I(inode)->i_file_acl);\n\tbh = sb_bread(inode->i_sb, EXT2_I(inode)->i_file_acl);\n\terror = -EIO;\n\tif (!bh)\n\t\tgoto cleanup;\n\tea_bdebug(bh, \"b_count=%d, refcount=%d\",\n\t\tatomic_read(&(bh->b_count)), le32_to_cpu(HDR(bh)->h_refcount));\n\tend = bh->b_data + bh->b_size;\n\tif (!ext2_xattr_header_valid(HDR(bh))) {\nbad_block:\n\t\text2_error(inode->i_sb, \"ext2_xattr_get\",\n\t\t\t\"inode %ld: bad block %d\", inode->i_ino,\n\t\t\tEXT2_I(inode)->i_file_acl);\n\t\terror = -EIO;\n\t\tgoto cleanup;\n\t}\n\n\t \n\tentry = FIRST_ENTRY(bh);\n\twhile (!IS_LAST_ENTRY(entry)) {\n\t\tif (!ext2_xattr_entry_valid(entry, end,\n\t\t    inode->i_sb->s_blocksize))\n\t\t\tgoto bad_block;\n\n\t\tnot_found = ext2_xattr_cmp_entry(name_index, name_len, name,\n\t\t\t\t\t\t entry);\n\t\tif (!not_found)\n\t\t\tgoto found;\n\t\tif (not_found < 0)\n\t\t\tbreak;\n\n\t\tentry = EXT2_XATTR_NEXT(entry);\n\t}\n\tif (ext2_xattr_cache_insert(ea_block_cache, bh))\n\t\tea_idebug(inode, \"cache insert failed\");\n\terror = -ENODATA;\n\tgoto cleanup;\nfound:\n\tsize = le32_to_cpu(entry->e_value_size);\n\tif (ext2_xattr_cache_insert(ea_block_cache, bh))\n\t\tea_idebug(inode, \"cache insert failed\");\n\tif (buffer) {\n\t\terror = -ERANGE;\n\t\tif (size > buffer_size)\n\t\t\tgoto cleanup;\n\t\t \n\t\tmemcpy(buffer, bh->b_data + le16_to_cpu(entry->e_value_offs),\n\t\t\tsize);\n\t}\n\terror = size;\n\ncleanup:\n\tbrelse(bh);\n\tup_read(&EXT2_I(inode)->xattr_sem);\n\n\treturn error;\n}\n\n \nstatic int\next2_xattr_list(struct dentry *dentry, char *buffer, size_t buffer_size)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct buffer_head *bh = NULL;\n\tstruct ext2_xattr_entry *entry;\n\tchar *end;\n\tsize_t rest = buffer_size;\n\tint error;\n\tstruct mb_cache *ea_block_cache = EA_BLOCK_CACHE(inode);\n\n\tea_idebug(inode, \"buffer=%p, buffer_size=%ld\",\n\t\t  buffer, (long)buffer_size);\n\n\tdown_read(&EXT2_I(inode)->xattr_sem);\n\terror = 0;\n\tif (!EXT2_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tea_idebug(inode, \"reading block %d\", EXT2_I(inode)->i_file_acl);\n\tbh = sb_bread(inode->i_sb, EXT2_I(inode)->i_file_acl);\n\terror = -EIO;\n\tif (!bh)\n\t\tgoto cleanup;\n\tea_bdebug(bh, \"b_count=%d, refcount=%d\",\n\t\tatomic_read(&(bh->b_count)), le32_to_cpu(HDR(bh)->h_refcount));\n\tend = bh->b_data + bh->b_size;\n\tif (!ext2_xattr_header_valid(HDR(bh))) {\nbad_block:\n\t\text2_error(inode->i_sb, \"ext2_xattr_list\",\n\t\t\t\"inode %ld: bad block %d\", inode->i_ino,\n\t\t\tEXT2_I(inode)->i_file_acl);\n\t\terror = -EIO;\n\t\tgoto cleanup;\n\t}\n\n\t \n\tentry = FIRST_ENTRY(bh);\n\twhile (!IS_LAST_ENTRY(entry)) {\n\t\tif (!ext2_xattr_entry_valid(entry, end,\n\t\t    inode->i_sb->s_blocksize))\n\t\t\tgoto bad_block;\n\t\tentry = EXT2_XATTR_NEXT(entry);\n\t}\n\tif (ext2_xattr_cache_insert(ea_block_cache, bh))\n\t\tea_idebug(inode, \"cache insert failed\");\n\n\t \n\tfor (entry = FIRST_ENTRY(bh); !IS_LAST_ENTRY(entry);\n\t     entry = EXT2_XATTR_NEXT(entry)) {\n\t\tconst char *prefix;\n\n\t\tprefix = ext2_xattr_prefix(entry->e_name_index, dentry);\n\t\tif (prefix) {\n\t\t\tsize_t prefix_len = strlen(prefix);\n\t\t\tsize_t size = prefix_len + entry->e_name_len + 1;\n\n\t\t\tif (buffer) {\n\t\t\t\tif (size > rest) {\n\t\t\t\t\terror = -ERANGE;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\tmemcpy(buffer, prefix, prefix_len);\n\t\t\t\tbuffer += prefix_len;\n\t\t\t\tmemcpy(buffer, entry->e_name, entry->e_name_len);\n\t\t\t\tbuffer += entry->e_name_len;\n\t\t\t\t*buffer++ = 0;\n\t\t\t}\n\t\t\trest -= size;\n\t\t}\n\t}\n\terror = buffer_size - rest;   \n\ncleanup:\n\tbrelse(bh);\n\tup_read(&EXT2_I(inode)->xattr_sem);\n\n\treturn error;\n}\n\n \nssize_t\next2_listxattr(struct dentry *dentry, char *buffer, size_t size)\n{\n\treturn ext2_xattr_list(dentry, buffer, size);\n}\n\n \nstatic void ext2_xattr_update_super_block(struct super_block *sb)\n{\n\tif (EXT2_HAS_COMPAT_FEATURE(sb, EXT2_FEATURE_COMPAT_EXT_ATTR))\n\t\treturn;\n\n\tspin_lock(&EXT2_SB(sb)->s_lock);\n\text2_update_dynamic_rev(sb);\n\tEXT2_SET_COMPAT_FEATURE(sb, EXT2_FEATURE_COMPAT_EXT_ATTR);\n\tspin_unlock(&EXT2_SB(sb)->s_lock);\n\tmark_buffer_dirty(EXT2_SB(sb)->s_sbh);\n}\n\n \nint\next2_xattr_set(struct inode *inode, int name_index, const char *name,\n\t       const void *value, size_t value_len, int flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bh = NULL;\n\tstruct ext2_xattr_header *header = NULL;\n\tstruct ext2_xattr_entry *here = NULL, *last = NULL;\n\tsize_t name_len, free, min_offs = sb->s_blocksize;\n\tint not_found = 1, error;\n\tchar *end;\n\t\n\t \n\t\n\tea_idebug(inode, \"name=%d.%s, value=%p, value_len=%ld\",\n\t\t  name_index, name, value, (long)value_len);\n\n\tif (value == NULL)\n\t\tvalue_len = 0;\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\tname_len = strlen(name);\n\tif (name_len > 255 || value_len > sb->s_blocksize)\n\t\treturn -ERANGE;\n\terror = dquot_initialize(inode);\n\tif (error)\n\t\treturn error;\n\tdown_write(&EXT2_I(inode)->xattr_sem);\n\tif (EXT2_I(inode)->i_file_acl) {\n\t\t \n\t\tbh = sb_bread(sb, EXT2_I(inode)->i_file_acl);\n\t\terror = -EIO;\n\t\tif (!bh)\n\t\t\tgoto cleanup;\n\t\tea_bdebug(bh, \"b_count=%d, refcount=%d\",\n\t\t\tatomic_read(&(bh->b_count)),\n\t\t\tle32_to_cpu(HDR(bh)->h_refcount));\n\t\theader = HDR(bh);\n\t\tend = bh->b_data + bh->b_size;\n\t\tif (!ext2_xattr_header_valid(header)) {\nbad_block:\n\t\t\text2_error(sb, \"ext2_xattr_set\",\n\t\t\t\t\"inode %ld: bad block %d\", inode->i_ino, \n\t\t\t\t   EXT2_I(inode)->i_file_acl);\n\t\t\terror = -EIO;\n\t\t\tgoto cleanup;\n\t\t}\n\t\t \n\t\tlast = FIRST_ENTRY(bh);\n\t\twhile (!IS_LAST_ENTRY(last)) {\n\t\t\tif (!ext2_xattr_entry_valid(last, end, sb->s_blocksize))\n\t\t\t\tgoto bad_block;\n\t\t\tif (last->e_value_size) {\n\t\t\t\tsize_t offs = le16_to_cpu(last->e_value_offs);\n\t\t\t\tif (offs < min_offs)\n\t\t\t\t\tmin_offs = offs;\n\t\t\t}\n\t\t\tif (not_found > 0) {\n\t\t\t\tnot_found = ext2_xattr_cmp_entry(name_index,\n\t\t\t\t\t\t\t\t name_len,\n\t\t\t\t\t\t\t\t name, last);\n\t\t\t\tif (not_found <= 0)\n\t\t\t\t\there = last;\n\t\t\t}\n\t\t\tlast = EXT2_XATTR_NEXT(last);\n\t\t}\n\t\tif (not_found > 0)\n\t\t\there = last;\n\n\t\t \n\t\tfree = min_offs - ((char*)last - (char*)header) - sizeof(__u32);\n\t} else {\n\t\t \n\t\tfree = sb->s_blocksize -\n\t\t\tsizeof(struct ext2_xattr_header) - sizeof(__u32);\n\t}\n\n\tif (not_found) {\n\t\t \n\t\terror = -ENODATA;\n\t\tif (flags & XATTR_REPLACE)\n\t\t\tgoto cleanup;\n\t\terror = 0;\n\t\tif (value == NULL)\n\t\t\tgoto cleanup;\n\t} else {\n\t\t \n\t\terror = -EEXIST;\n\t\tif (flags & XATTR_CREATE)\n\t\t\tgoto cleanup;\n\t\tfree += EXT2_XATTR_SIZE(le32_to_cpu(here->e_value_size));\n\t\tfree += EXT2_XATTR_LEN(name_len);\n\t}\n\terror = -ENOSPC;\n\tif (free < EXT2_XATTR_LEN(name_len) + EXT2_XATTR_SIZE(value_len))\n\t\tgoto cleanup;\n\n\t \n\n\tif (header) {\n\t\tint offset;\n\n\t\tlock_buffer(bh);\n\t\tif (header->h_refcount == cpu_to_le32(1)) {\n\t\t\t__u32 hash = le32_to_cpu(header->h_hash);\n\t\t\tstruct mb_cache_entry *oe;\n\n\t\t\toe = mb_cache_entry_delete_or_get(EA_BLOCK_CACHE(inode),\n\t\t\t\t\thash, bh->b_blocknr);\n\t\t\tif (!oe) {\n\t\t\t\tea_bdebug(bh, \"modifying in-place\");\n\t\t\t\tgoto update_block;\n\t\t\t}\n\t\t\t \n\t\t\tmb_cache_entry_put(EA_BLOCK_CACHE(inode), oe);\n\t\t}\n\t\tunlock_buffer(bh);\n\t\tea_bdebug(bh, \"cloning\");\n\t\theader = kmemdup(HDR(bh), bh->b_size, GFP_KERNEL);\n\t\terror = -ENOMEM;\n\t\tif (header == NULL)\n\t\t\tgoto cleanup;\n\t\theader->h_refcount = cpu_to_le32(1);\n\n\t\toffset = (char *)here - bh->b_data;\n\t\there = ENTRY((char *)header + offset);\n\t\toffset = (char *)last - bh->b_data;\n\t\tlast = ENTRY((char *)header + offset);\n\t} else {\n\t\t \n\t\theader = kzalloc(sb->s_blocksize, GFP_KERNEL);\n\t\terror = -ENOMEM;\n\t\tif (header == NULL)\n\t\t\tgoto cleanup;\n\t\theader->h_magic = cpu_to_le32(EXT2_XATTR_MAGIC);\n\t\theader->h_blocks = header->h_refcount = cpu_to_le32(1);\n\t\tlast = here = ENTRY(header+1);\n\t}\n\nupdate_block:\n\t \n\n\tif (not_found) {\n\t\t \n\t\tsize_t size = EXT2_XATTR_LEN(name_len);\n\t\tsize_t rest = (char *)last - (char *)here;\n\t\tmemmove((char *)here + size, here, rest);\n\t\tmemset(here, 0, size);\n\t\there->e_name_index = name_index;\n\t\there->e_name_len = name_len;\n\t\tmemcpy(here->e_name, name, name_len);\n\t} else {\n\t\tif (here->e_value_size) {\n\t\t\tchar *first_val = (char *)header + min_offs;\n\t\t\tsize_t offs = le16_to_cpu(here->e_value_offs);\n\t\t\tchar *val = (char *)header + offs;\n\t\t\tsize_t size = EXT2_XATTR_SIZE(\n\t\t\t\tle32_to_cpu(here->e_value_size));\n\n\t\t\tif (size == EXT2_XATTR_SIZE(value_len)) {\n\t\t\t\t \n\t\t\t\there->e_value_size = cpu_to_le32(value_len);\n\t\t\t\tmemset(val + size - EXT2_XATTR_PAD, 0,\n\t\t\t\t       EXT2_XATTR_PAD);  \n\t\t\t\tmemcpy(val, value, value_len);\n\t\t\t\tgoto skip_replace;\n\t\t\t}\n\n\t\t\t \n\t\t\tmemmove(first_val + size, first_val, val - first_val);\n\t\t\tmemset(first_val, 0, size);\n\t\t\tmin_offs += size;\n\n\t\t\t \n\t\t\tlast = ENTRY(header+1);\n\t\t\twhile (!IS_LAST_ENTRY(last)) {\n\t\t\t\tsize_t o = le16_to_cpu(last->e_value_offs);\n\t\t\t\tif (o < offs)\n\t\t\t\t\tlast->e_value_offs =\n\t\t\t\t\t\tcpu_to_le16(o + size);\n\t\t\t\tlast = EXT2_XATTR_NEXT(last);\n\t\t\t}\n\n\t\t\there->e_value_offs = 0;\n\t\t}\n\t\tif (value == NULL) {\n\t\t\t \n\t\t\tsize_t size = EXT2_XATTR_LEN(name_len);\n\t\t\tlast = ENTRY((char *)last - size);\n\t\t\tmemmove(here, (char*)here + size,\n\t\t\t\t(char*)last - (char*)here);\n\t\t\tmemset(last, 0, size);\n\t\t}\n\t}\n\n\tif (value != NULL) {\n\t\t \n\t\there->e_value_size = cpu_to_le32(value_len);\n\t\tif (value_len) {\n\t\t\tsize_t size = EXT2_XATTR_SIZE(value_len);\n\t\t\tchar *val = (char *)header + min_offs - size;\n\t\t\there->e_value_offs =\n\t\t\t\tcpu_to_le16((char *)val - (char *)header);\n\t\t\tmemset(val + size - EXT2_XATTR_PAD, 0,\n\t\t\t       EXT2_XATTR_PAD);  \n\t\t\tmemcpy(val, value, value_len);\n\t\t}\n\t}\n\nskip_replace:\n\tif (IS_LAST_ENTRY(ENTRY(header+1))) {\n\t\t \n\t\tif (bh && header == HDR(bh))\n\t\t\tunlock_buffer(bh);   \n\t\terror = ext2_xattr_set2(inode, bh, NULL);\n\t} else {\n\t\text2_xattr_rehash(header, here);\n\t\tif (bh && header == HDR(bh))\n\t\t\tunlock_buffer(bh);   \n\t\terror = ext2_xattr_set2(inode, bh, header);\n\t}\n\ncleanup:\n\tif (!(bh && header == HDR(bh)))\n\t\tkfree(header);\n\tbrelse(bh);\n\tup_write(&EXT2_I(inode)->xattr_sem);\n\n\treturn error;\n}\n\nstatic void ext2_xattr_release_block(struct inode *inode,\n\t\t\t\t     struct buffer_head *bh)\n{\n\tstruct mb_cache *ea_block_cache = EA_BLOCK_CACHE(inode);\n\nretry_ref:\n\tlock_buffer(bh);\n\tif (HDR(bh)->h_refcount == cpu_to_le32(1)) {\n\t\t__u32 hash = le32_to_cpu(HDR(bh)->h_hash);\n\t\tstruct mb_cache_entry *oe;\n\n\t\t \n\t\toe = mb_cache_entry_delete_or_get(ea_block_cache, hash,\n\t\t\t\t\t\t  bh->b_blocknr);\n\t\tif (oe) {\n\t\t\t \n\t\t\tunlock_buffer(bh);\n\t\t\tmb_cache_entry_wait_unused(oe);\n\t\t\tmb_cache_entry_put(ea_block_cache, oe);\n\t\t\tgoto retry_ref;\n\t\t}\n\n\t\t \n\t\tea_bdebug(bh, \"freeing\");\n\t\text2_free_blocks(inode, bh->b_blocknr, 1);\n\t\t \n\t\tget_bh(bh);\n\t\tbforget(bh);\n\t\tunlock_buffer(bh);\n\t} else {\n\t\t \n\t\tle32_add_cpu(&HDR(bh)->h_refcount, -1);\n\t\tdquot_free_block(inode, 1);\n\t\tmark_buffer_dirty(bh);\n\t\tunlock_buffer(bh);\n\t\tea_bdebug(bh, \"refcount now=%d\",\n\t\t\tle32_to_cpu(HDR(bh)->h_refcount));\n\t\tif (IS_SYNC(inode))\n\t\t\tsync_dirty_buffer(bh);\n\t}\n}\n\n \nstatic int\next2_xattr_set2(struct inode *inode, struct buffer_head *old_bh,\n\t\tstruct ext2_xattr_header *header)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *new_bh = NULL;\n\tint error;\n\tstruct mb_cache *ea_block_cache = EA_BLOCK_CACHE(inode);\n\n\tif (header) {\n\t\tnew_bh = ext2_xattr_cache_find(inode, header);\n\t\tif (new_bh) {\n\t\t\t \n\t\t\tif (new_bh == old_bh) {\n\t\t\t\tea_bdebug(new_bh, \"keeping this block\");\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tea_bdebug(new_bh, \"reusing block\");\n\n\t\t\t\terror = dquot_alloc_block(inode, 1);\n\t\t\t\tif (error) {\n\t\t\t\t\tunlock_buffer(new_bh);\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\tle32_add_cpu(&HDR(new_bh)->h_refcount, 1);\n\t\t\t\tea_bdebug(new_bh, \"refcount now=%d\",\n\t\t\t\t\tle32_to_cpu(HDR(new_bh)->h_refcount));\n\t\t\t}\n\t\t\tunlock_buffer(new_bh);\n\t\t} else if (old_bh && header == HDR(old_bh)) {\n\t\t\t \n\t\t\tnew_bh = old_bh;\n\t\t\tget_bh(new_bh);\n\t\t\text2_xattr_cache_insert(ea_block_cache, new_bh);\n\t\t} else {\n\t\t\t \n\t\t\text2_fsblk_t goal = ext2_group_first_block_no(sb,\n\t\t\t\t\t\tEXT2_I(inode)->i_block_group);\n\t\t\tunsigned long count = 1;\n\t\t\text2_fsblk_t block = ext2_new_blocks(inode, goal,\n\t\t\t\t\t\t&count, &error,\n\t\t\t\t\t\tEXT2_ALLOC_NORESERVE);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\t\t\tea_idebug(inode, \"creating block %lu\", block);\n\n\t\t\tnew_bh = sb_getblk(sb, block);\n\t\t\tif (unlikely(!new_bh)) {\n\t\t\t\text2_free_blocks(inode, block, 1);\n\t\t\t\tmark_inode_dirty(inode);\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tlock_buffer(new_bh);\n\t\t\tmemcpy(new_bh->b_data, header, new_bh->b_size);\n\t\t\tset_buffer_uptodate(new_bh);\n\t\t\tunlock_buffer(new_bh);\n\t\t\text2_xattr_cache_insert(ea_block_cache, new_bh);\n\t\t\t\n\t\t\text2_xattr_update_super_block(sb);\n\t\t}\n\t\tmark_buffer_dirty(new_bh);\n\t\tif (IS_SYNC(inode)) {\n\t\t\tsync_dirty_buffer(new_bh);\n\t\t\terror = -EIO;\n\t\t\tif (buffer_req(new_bh) && !buffer_uptodate(new_bh))\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\t \n\tEXT2_I(inode)->i_file_acl = new_bh ? new_bh->b_blocknr : 0;\n\tinode_set_ctime_current(inode);\n\tif (IS_SYNC(inode)) {\n\t\terror = sync_inode_metadata(inode, 1);\n\t\t \n\t\tif (error && error != -ENOSPC) {\n\t\t\tif (new_bh && new_bh != old_bh) {\n\t\t\t\tdquot_free_block_nodirty(inode, 1);\n\t\t\t\tmark_inode_dirty(inode);\n\t\t\t}\n\t\t\tgoto cleanup;\n\t\t}\n\t} else\n\t\tmark_inode_dirty(inode);\n\n\terror = 0;\n\tif (old_bh && old_bh != new_bh) {\n\t\t \n\t\text2_xattr_release_block(inode, old_bh);\n\t}\n\ncleanup:\n\tbrelse(new_bh);\n\n\treturn error;\n}\n\n \nvoid\next2_xattr_delete_inode(struct inode *inode)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct ext2_sb_info *sbi = EXT2_SB(inode->i_sb);\n\n\t \n\tif (WARN_ON_ONCE(!down_write_trylock(&EXT2_I(inode)->xattr_sem)))\n\t\treturn;\n\tif (!EXT2_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\n\tif (!ext2_data_block_valid(sbi, EXT2_I(inode)->i_file_acl, 1)) {\n\t\text2_error(inode->i_sb, \"ext2_xattr_delete_inode\",\n\t\t\t\"inode %ld: xattr block %d is out of data blocks range\",\n\t\t\tinode->i_ino, EXT2_I(inode)->i_file_acl);\n\t\tgoto cleanup;\n\t}\n\n\tbh = sb_bread(inode->i_sb, EXT2_I(inode)->i_file_acl);\n\tif (!bh) {\n\t\text2_error(inode->i_sb, \"ext2_xattr_delete_inode\",\n\t\t\t\"inode %ld: block %d read error\", inode->i_ino,\n\t\t\tEXT2_I(inode)->i_file_acl);\n\t\tgoto cleanup;\n\t}\n\tea_bdebug(bh, \"b_count=%d\", atomic_read(&(bh->b_count)));\n\tif (!ext2_xattr_header_valid(HDR(bh))) {\n\t\text2_error(inode->i_sb, \"ext2_xattr_delete_inode\",\n\t\t\t\"inode %ld: bad block %d\", inode->i_ino,\n\t\t\tEXT2_I(inode)->i_file_acl);\n\t\tgoto cleanup;\n\t}\n\text2_xattr_release_block(inode, bh);\n\tEXT2_I(inode)->i_file_acl = 0;\n\ncleanup:\n\tbrelse(bh);\n\tup_write(&EXT2_I(inode)->xattr_sem);\n}\n\n \nstatic int\next2_xattr_cache_insert(struct mb_cache *cache, struct buffer_head *bh)\n{\n\t__u32 hash = le32_to_cpu(HDR(bh)->h_hash);\n\tint error;\n\n\terror = mb_cache_entry_create(cache, GFP_NOFS, hash, bh->b_blocknr,\n\t\t\t\t      true);\n\tif (error) {\n\t\tif (error == -EBUSY) {\n\t\t\tea_bdebug(bh, \"already in cache\");\n\t\t\terror = 0;\n\t\t}\n\t} else\n\t\tea_bdebug(bh, \"inserting [%x]\", (int)hash);\n\treturn error;\n}\n\n \nstatic int\next2_xattr_cmp(struct ext2_xattr_header *header1,\n\t       struct ext2_xattr_header *header2)\n{\n\tstruct ext2_xattr_entry *entry1, *entry2;\n\n\tentry1 = ENTRY(header1+1);\n\tentry2 = ENTRY(header2+1);\n\twhile (!IS_LAST_ENTRY(entry1)) {\n\t\tif (IS_LAST_ENTRY(entry2))\n\t\t\treturn 1;\n\t\tif (entry1->e_hash != entry2->e_hash ||\n\t\t    entry1->e_name_index != entry2->e_name_index ||\n\t\t    entry1->e_name_len != entry2->e_name_len ||\n\t\t    entry1->e_value_size != entry2->e_value_size ||\n\t\t    memcmp(entry1->e_name, entry2->e_name, entry1->e_name_len))\n\t\t\treturn 1;\n\t\tif (entry1->e_value_block != 0 || entry2->e_value_block != 0)\n\t\t\treturn -EIO;\n\t\tif (memcmp((char *)header1 + le16_to_cpu(entry1->e_value_offs),\n\t\t\t   (char *)header2 + le16_to_cpu(entry2->e_value_offs),\n\t\t\t   le32_to_cpu(entry1->e_value_size)))\n\t\t\treturn 1;\n\n\t\tentry1 = EXT2_XATTR_NEXT(entry1);\n\t\tentry2 = EXT2_XATTR_NEXT(entry2);\n\t}\n\tif (!IS_LAST_ENTRY(entry2))\n\t\treturn 1;\n\treturn 0;\n}\n\n \nstatic struct buffer_head *\next2_xattr_cache_find(struct inode *inode, struct ext2_xattr_header *header)\n{\n\t__u32 hash = le32_to_cpu(header->h_hash);\n\tstruct mb_cache_entry *ce;\n\tstruct mb_cache *ea_block_cache = EA_BLOCK_CACHE(inode);\n\n\tif (!header->h_hash)\n\t\treturn NULL;   \n\tea_idebug(inode, \"looking for cached blocks [%x]\", (int)hash);\n\n\tce = mb_cache_entry_find_first(ea_block_cache, hash);\n\twhile (ce) {\n\t\tstruct buffer_head *bh;\n\n\t\tbh = sb_bread(inode->i_sb, ce->e_value);\n\t\tif (!bh) {\n\t\t\text2_error(inode->i_sb, \"ext2_xattr_cache_find\",\n\t\t\t\t\"inode %ld: block %ld read error\",\n\t\t\t\tinode->i_ino, (unsigned long) ce->e_value);\n\t\t} else {\n\t\t\tlock_buffer(bh);\n\t\t\tif (le32_to_cpu(HDR(bh)->h_refcount) >\n\t\t\t    EXT2_XATTR_REFCOUNT_MAX) {\n\t\t\t\tea_idebug(inode, \"block %ld refcount %d>%d\",\n\t\t\t\t\t  (unsigned long) ce->e_value,\n\t\t\t\t\t  le32_to_cpu(HDR(bh)->h_refcount),\n\t\t\t\t\t  EXT2_XATTR_REFCOUNT_MAX);\n\t\t\t} else if (!ext2_xattr_cmp(header, HDR(bh))) {\n\t\t\t\tea_bdebug(bh, \"b_count=%d\",\n\t\t\t\t\t  atomic_read(&(bh->b_count)));\n\t\t\t\tmb_cache_entry_touch(ea_block_cache, ce);\n\t\t\t\tmb_cache_entry_put(ea_block_cache, ce);\n\t\t\t\treturn bh;\n\t\t\t}\n\t\t\tunlock_buffer(bh);\n\t\t\tbrelse(bh);\n\t\t}\n\t\tce = mb_cache_entry_find_next(ea_block_cache, ce);\n\t}\n\treturn NULL;\n}\n\n#define NAME_HASH_SHIFT 5\n#define VALUE_HASH_SHIFT 16\n\n \nstatic inline void ext2_xattr_hash_entry(struct ext2_xattr_header *header,\n\t\t\t\t\t struct ext2_xattr_entry *entry)\n{\n\t__u32 hash = 0;\n\tchar *name = entry->e_name;\n\tint n;\n\n\tfor (n=0; n < entry->e_name_len; n++) {\n\t\thash = (hash << NAME_HASH_SHIFT) ^\n\t\t       (hash >> (8*sizeof(hash) - NAME_HASH_SHIFT)) ^\n\t\t       *name++;\n\t}\n\n\tif (entry->e_value_block == 0 && entry->e_value_size != 0) {\n\t\t__le32 *value = (__le32 *)((char *)header +\n\t\t\tle16_to_cpu(entry->e_value_offs));\n\t\tfor (n = (le32_to_cpu(entry->e_value_size) +\n\t\t     EXT2_XATTR_ROUND) >> EXT2_XATTR_PAD_BITS; n; n--) {\n\t\t\thash = (hash << VALUE_HASH_SHIFT) ^\n\t\t\t       (hash >> (8*sizeof(hash) - VALUE_HASH_SHIFT)) ^\n\t\t\t       le32_to_cpu(*value++);\n\t\t}\n\t}\n\tentry->e_hash = cpu_to_le32(hash);\n}\n\n#undef NAME_HASH_SHIFT\n#undef VALUE_HASH_SHIFT\n\n#define BLOCK_HASH_SHIFT 16\n\n \nstatic void ext2_xattr_rehash(struct ext2_xattr_header *header,\n\t\t\t      struct ext2_xattr_entry *entry)\n{\n\tstruct ext2_xattr_entry *here;\n\t__u32 hash = 0;\n\t\n\text2_xattr_hash_entry(header, entry);\n\there = ENTRY(header+1);\n\twhile (!IS_LAST_ENTRY(here)) {\n\t\tif (!here->e_hash) {\n\t\t\t \n\t\t\thash = 0;\n\t\t\tbreak;\n\t\t}\n\t\thash = (hash << BLOCK_HASH_SHIFT) ^\n\t\t       (hash >> (8*sizeof(hash) - BLOCK_HASH_SHIFT)) ^\n\t\t       le32_to_cpu(here->e_hash);\n\t\there = EXT2_XATTR_NEXT(here);\n\t}\n\theader->h_hash = cpu_to_le32(hash);\n}\n\n#undef BLOCK_HASH_SHIFT\n\n#define HASH_BUCKET_BITS 10\n\nstruct mb_cache *ext2_xattr_create_cache(void)\n{\n\treturn mb_cache_create(HASH_BUCKET_BITS);\n}\n\nvoid ext2_xattr_destroy_cache(struct mb_cache *cache)\n{\n\tif (cache)\n\t\tmb_cache_destroy(cache);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}