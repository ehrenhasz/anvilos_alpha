{
  "module_name": "acl.c",
  "hash_id": "1b34314893d4ce386f2e7f14625e45ea70071c99e09ec1026550ceb157833e4a",
  "original_prompt": "Ingested from linux-6.6.14/fs/ext2/acl.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include \"ext2.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n\n \nstatic struct posix_acl *\next2_acl_from_disk(const void *value, size_t size)\n{\n\tconst char *end = (char *)value + size;\n\tint n, count;\n\tstruct posix_acl *acl;\n\n\tif (!value)\n\t\treturn NULL;\n\tif (size < sizeof(ext2_acl_header))\n\t\t return ERR_PTR(-EINVAL);\n\tif (((ext2_acl_header *)value)->a_version !=\n\t    cpu_to_le32(EXT2_ACL_VERSION))\n\t\treturn ERR_PTR(-EINVAL);\n\tvalue = (char *)value + sizeof(ext2_acl_header);\n\tcount = ext2_acl_count(size);\n\tif (count < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (count == 0)\n\t\treturn NULL;\n\tacl = posix_acl_alloc(count, GFP_KERNEL);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\tfor (n=0; n < count; n++) {\n\t\text2_acl_entry *entry =\n\t\t\t(ext2_acl_entry *)value;\n\t\tif ((char *)value + sizeof(ext2_acl_entry_short) > end)\n\t\t\tgoto fail;\n\t\tacl->a_entries[n].e_tag  = le16_to_cpu(entry->e_tag);\n\t\tacl->a_entries[n].e_perm = le16_to_cpu(entry->e_perm);\n\t\tswitch(acl->a_entries[n].e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\tcase ACL_MASK:\n\t\t\tcase ACL_OTHER:\n\t\t\t\tvalue = (char *)value +\n\t\t\t\t\tsizeof(ext2_acl_entry_short);\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_USER:\n\t\t\t\tvalue = (char *)value + sizeof(ext2_acl_entry);\n\t\t\t\tif ((char *)value > end)\n\t\t\t\t\tgoto fail;\n\t\t\t\tacl->a_entries[n].e_uid =\n\t\t\t\t\tmake_kuid(&init_user_ns,\n\t\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP:\n\t\t\t\tvalue = (char *)value + sizeof(ext2_acl_entry);\n\t\t\t\tif ((char *)value > end)\n\t\t\t\t\tgoto fail;\n\t\t\t\tacl->a_entries[n].e_gid =\n\t\t\t\t\tmake_kgid(&init_user_ns,\n\t\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\tif (value != end)\n\t\tgoto fail;\n\treturn acl;\n\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}\n\n \nstatic void *\next2_acl_to_disk(const struct posix_acl *acl, size_t *size)\n{\n\text2_acl_header *ext_acl;\n\tchar *e;\n\tsize_t n;\n\n\t*size = ext2_acl_size(acl->a_count);\n\text_acl = kmalloc(sizeof(ext2_acl_header) + acl->a_count *\n\t\t\tsizeof(ext2_acl_entry), GFP_KERNEL);\n\tif (!ext_acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\text_acl->a_version = cpu_to_le32(EXT2_ACL_VERSION);\n\te = (char *)ext_acl + sizeof(ext2_acl_header);\n\tfor (n=0; n < acl->a_count; n++) {\n\t\tconst struct posix_acl_entry *acl_e = &acl->a_entries[n];\n\t\text2_acl_entry *entry = (ext2_acl_entry *)e;\n\t\tentry->e_tag  = cpu_to_le16(acl_e->e_tag);\n\t\tentry->e_perm = cpu_to_le16(acl_e->e_perm);\n\t\tswitch(acl_e->e_tag) {\n\t\t\tcase ACL_USER:\n\t\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\t\tfrom_kuid(&init_user_ns, acl_e->e_uid));\n\t\t\t\te += sizeof(ext2_acl_entry);\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP:\n\t\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\t\tfrom_kgid(&init_user_ns, acl_e->e_gid));\n\t\t\t\te += sizeof(ext2_acl_entry);\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_USER_OBJ:\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\tcase ACL_MASK:\n\t\t\tcase ACL_OTHER:\n\t\t\t\te += sizeof(ext2_acl_entry_short);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn (char *)ext_acl;\n\nfail:\n\tkfree(ext_acl);\n\treturn ERR_PTR(-EINVAL);\n}\n\n \nstruct posix_acl *\next2_get_acl(struct inode *inode, int type, bool rcu)\n{\n\tint name_index;\n\tchar *value = NULL;\n\tstruct posix_acl *acl;\n\tint retval;\n\n\tif (rcu)\n\t\treturn ERR_PTR(-ECHILD);\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = EXT2_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = EXT2_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\tretval = ext2_xattr_get(inode, name_index, \"\", NULL, 0);\n\tif (retval > 0) {\n\t\tvalue = kmalloc(retval, GFP_KERNEL);\n\t\tif (!value)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tretval = ext2_xattr_get(inode, name_index, \"\", value, retval);\n\t}\n\tif (retval > 0)\n\t\tacl = ext2_acl_from_disk(value, retval);\n\telse if (retval == -ENODATA || retval == -ENOSYS)\n\t\tacl = NULL;\n\telse\n\t\tacl = ERR_PTR(retval);\n\tkfree(value);\n\n\treturn acl;\n}\n\nstatic int\n__ext2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint name_index;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint error;\n\n\tswitch(type) {\n\t\tcase ACL_TYPE_ACCESS:\n\t\t\tname_index = EXT2_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\t\tbreak;\n\n\t\tcase ACL_TYPE_DEFAULT:\n\t\t\tname_index = EXT2_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\t\treturn acl ? -EACCES : 0;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n \tif (acl) {\n\t\tvalue = ext2_acl_to_disk(acl, &size);\n\t\tif (IS_ERR(value))\n\t\t\treturn (int)PTR_ERR(value);\n\t}\n\n\terror = ext2_xattr_set(inode, name_index, \"\", value, size, 0);\n\n\tkfree(value);\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\treturn error;\n}\n\n \nint\next2_set_acl(struct mnt_idmap *idmap, struct dentry *dentry,\n\t     struct posix_acl *acl, int type)\n{\n\tint error;\n\tint update_mode = 0;\n\tstruct inode *inode = d_inode(dentry);\n\tumode_t mode = inode->i_mode;\n\n\tif (type == ACL_TYPE_ACCESS && acl) {\n\t\terror = posix_acl_update_mode(&nop_mnt_idmap, inode, &mode,\n\t\t\t\t\t      &acl);\n\t\tif (error)\n\t\t\treturn error;\n\t\tupdate_mode = 1;\n\t}\n\terror = __ext2_set_acl(inode, acl, type);\n\tif (!error && update_mode) {\n\t\tinode->i_mode = mode;\n\t\tinode_set_ctime_current(inode);\n\t\tmark_inode_dirty(inode);\n\t}\n\treturn error;\n}\n\n \nint\next2_init_acl(struct inode *inode, struct inode *dir)\n{\n\tstruct posix_acl *default_acl, *acl;\n\tint error;\n\n\terror = posix_acl_create(dir, &inode->i_mode, &default_acl, &acl);\n\tif (error)\n\t\treturn error;\n\n\tif (default_acl) {\n\t\terror = __ext2_set_acl(inode, default_acl, ACL_TYPE_DEFAULT);\n\t\tposix_acl_release(default_acl);\n\t} else {\n\t\tinode->i_default_acl = NULL;\n\t}\n\tif (acl) {\n\t\tif (!error)\n\t\t\terror = __ext2_set_acl(inode, acl, ACL_TYPE_ACCESS);\n\t\tposix_acl_release(acl);\n\t} else {\n\t\tinode->i_acl = NULL;\n\t}\n\treturn error;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}