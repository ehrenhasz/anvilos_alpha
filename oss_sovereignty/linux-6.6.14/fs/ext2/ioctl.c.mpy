{
  "module_name": "ioctl.c",
  "hash_id": "6cbc97976265253237995f95461cbc42ab91ed3be246b05d5ae47c3ec4aff1d6",
  "original_prompt": "Ingested from linux-6.6.14/fs/ext2/ioctl.c",
  "human_readable_source": "\n \n\n#include \"ext2.h\"\n#include <linux/capability.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/compat.h>\n#include <linux/mount.h>\n#include <asm/current.h>\n#include <linux/uaccess.h>\n#include <linux/fileattr.h>\n\nint ext2_fileattr_get(struct dentry *dentry, struct fileattr *fa)\n{\n\tstruct ext2_inode_info *ei = EXT2_I(d_inode(dentry));\n\n\tfileattr_fill_flags(fa, ei->i_flags & EXT2_FL_USER_VISIBLE);\n\n\treturn 0;\n}\n\nint ext2_fileattr_set(struct mnt_idmap *idmap,\n\t\t      struct dentry *dentry, struct fileattr *fa)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct ext2_inode_info *ei = EXT2_I(inode);\n\n\tif (fileattr_has_fsx(fa))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (IS_NOQUOTA(inode))\n\t\treturn -EPERM;\n\n\tei->i_flags = (ei->i_flags & ~EXT2_FL_USER_MODIFIABLE) |\n\t\t(fa->flags & EXT2_FL_USER_MODIFIABLE);\n\n\text2_set_inode_flags(inode);\n\tinode_set_ctime_current(inode);\n\tmark_inode_dirty(inode);\n\n\treturn 0;\n}\n\n\nlong ext2_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct ext2_inode_info *ei = EXT2_I(inode);\n\tunsigned short rsv_window_size;\n\tint ret;\n\n\text2_debug (\"cmd = %u, arg = %lu\\n\", cmd, arg);\n\n\tswitch (cmd) {\n\tcase EXT2_IOC_GETVERSION:\n\t\treturn put_user(inode->i_generation, (int __user *) arg);\n\tcase EXT2_IOC_SETVERSION: {\n\t\t__u32 generation;\n\n\t\tif (!inode_owner_or_capable(&nop_mnt_idmap, inode))\n\t\t\treturn -EPERM;\n\t\tret = mnt_want_write_file(filp);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (get_user(generation, (int __user *) arg)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto setversion_out;\n\t\t}\n\n\t\tinode_lock(inode);\n\t\tinode_set_ctime_current(inode);\n\t\tinode->i_generation = generation;\n\t\tinode_unlock(inode);\n\n\t\tmark_inode_dirty(inode);\nsetversion_out:\n\t\tmnt_drop_write_file(filp);\n\t\treturn ret;\n\t}\n\tcase EXT2_IOC_GETRSVSZ:\n\t\tif (test_opt(inode->i_sb, RESERVATION)\n\t\t\t&& S_ISREG(inode->i_mode)\n\t\t\t&& ei->i_block_alloc_info) {\n\t\t\trsv_window_size = ei->i_block_alloc_info->rsv_window_node.rsv_goal_size;\n\t\t\treturn put_user(rsv_window_size, (int __user *)arg);\n\t\t}\n\t\treturn -ENOTTY;\n\tcase EXT2_IOC_SETRSVSZ: {\n\n\t\tif (!test_opt(inode->i_sb, RESERVATION) ||!S_ISREG(inode->i_mode))\n\t\t\treturn -ENOTTY;\n\n\t\tif (!inode_owner_or_capable(&nop_mnt_idmap, inode))\n\t\t\treturn -EACCES;\n\n\t\tif (get_user(rsv_window_size, (int __user *)arg))\n\t\t\treturn -EFAULT;\n\n\t\tret = mnt_want_write_file(filp);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (rsv_window_size > EXT2_MAX_RESERVE_BLOCKS)\n\t\t\trsv_window_size = EXT2_MAX_RESERVE_BLOCKS;\n\n\t\t \n\t\t \n\t\tmutex_lock(&ei->truncate_mutex);\n\t\tif (!ei->i_block_alloc_info)\n\t\t\text2_init_block_alloc_info(inode);\n\n\t\tif (ei->i_block_alloc_info){\n\t\t\tstruct ext2_reserve_window_node *rsv = &ei->i_block_alloc_info->rsv_window_node;\n\t\t\trsv->rsv_goal_size = rsv_window_size;\n\t\t} else {\n\t\t\tret = -ENOMEM;\n\t\t}\n\n\t\tmutex_unlock(&ei->truncate_mutex);\n\t\tmnt_drop_write_file(filp);\n\t\treturn ret;\n\t}\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}\n\n#ifdef CONFIG_COMPAT\nlong ext2_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\t \n\tswitch (cmd) {\n\tcase EXT2_IOC32_GETVERSION:\n\t\tcmd = EXT2_IOC_GETVERSION;\n\t\tbreak;\n\tcase EXT2_IOC32_SETVERSION:\n\t\tcmd = EXT2_IOC_SETVERSION;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\treturn ext2_ioctl(file, cmd, (unsigned long) compat_ptr(arg));\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}