{
  "module_name": "dir.c",
  "hash_id": "3e39cab5cd077a06bb536de9686564360e8fc350bffb8ccbb59baf31eecc16ff",
  "original_prompt": "Ingested from linux-6.6.14/fs/ext2/dir.c",
  "human_readable_source": "\n \n\n#include \"ext2.h\"\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/iversion.h>\n\ntypedef struct ext2_dir_entry_2 ext2_dirent;\n\n \nstatic inline unsigned ext2_rec_len_from_disk(__le16 dlen)\n{\n\tunsigned len = le16_to_cpu(dlen);\n\n#if (PAGE_SIZE >= 65536)\n\tif (len == EXT2_MAX_REC_LEN)\n\t\treturn 1 << 16;\n#endif\n\treturn len;\n}\n\nstatic inline __le16 ext2_rec_len_to_disk(unsigned len)\n{\n#if (PAGE_SIZE >= 65536)\n\tif (len == (1 << 16))\n\t\treturn cpu_to_le16(EXT2_MAX_REC_LEN);\n\telse\n\t\tBUG_ON(len > (1 << 16));\n#endif\n\treturn cpu_to_le16(len);\n}\n\n \nstatic inline unsigned ext2_chunk_size(struct inode *inode)\n{\n\treturn inode->i_sb->s_blocksize;\n}\n\n \nstatic unsigned\next2_last_byte(struct inode *inode, unsigned long page_nr)\n{\n\tunsigned last_byte = inode->i_size;\n\n\tlast_byte -= page_nr << PAGE_SHIFT;\n\tif (last_byte > PAGE_SIZE)\n\t\tlast_byte = PAGE_SIZE;\n\treturn last_byte;\n}\n\nstatic void ext2_commit_chunk(struct page *page, loff_t pos, unsigned len)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *dir = mapping->host;\n\n\tinode_inc_iversion(dir);\n\tblock_write_end(NULL, mapping, pos, len, len, page, NULL);\n\n\tif (pos+len > dir->i_size) {\n\t\ti_size_write(dir, pos+len);\n\t\tmark_inode_dirty(dir);\n\t}\n\tunlock_page(page);\n}\n\nstatic bool ext2_check_page(struct page *page, int quiet, char *kaddr)\n{\n\tstruct inode *dir = page->mapping->host;\n\tstruct super_block *sb = dir->i_sb;\n\tunsigned chunk_size = ext2_chunk_size(dir);\n\tu32 max_inumber = le32_to_cpu(EXT2_SB(sb)->s_es->s_inodes_count);\n\tunsigned offs, rec_len;\n\tunsigned limit = PAGE_SIZE;\n\text2_dirent *p;\n\tchar *error;\n\n\tif ((dir->i_size >> PAGE_SHIFT) == page->index) {\n\t\tlimit = dir->i_size & ~PAGE_MASK;\n\t\tif (limit & (chunk_size - 1))\n\t\t\tgoto Ebadsize;\n\t\tif (!limit)\n\t\t\tgoto out;\n\t}\n\tfor (offs = 0; offs <= limit - EXT2_DIR_REC_LEN(1); offs += rec_len) {\n\t\tp = (ext2_dirent *)(kaddr + offs);\n\t\trec_len = ext2_rec_len_from_disk(p->rec_len);\n\n\t\tif (unlikely(rec_len < EXT2_DIR_REC_LEN(1)))\n\t\t\tgoto Eshort;\n\t\tif (unlikely(rec_len & 3))\n\t\t\tgoto Ealign;\n\t\tif (unlikely(rec_len < EXT2_DIR_REC_LEN(p->name_len)))\n\t\t\tgoto Enamelen;\n\t\tif (unlikely(((offs + rec_len - 1) ^ offs) & ~(chunk_size-1)))\n\t\t\tgoto Espan;\n\t\tif (unlikely(le32_to_cpu(p->inode) > max_inumber))\n\t\t\tgoto Einumber;\n\t}\n\tif (offs != limit)\n\t\tgoto Eend;\nout:\n\tSetPageChecked(page);\n\treturn true;\n\n\t \n\nEbadsize:\n\tif (!quiet)\n\t\text2_error(sb, __func__,\n\t\t\t\"size of directory #%lu is not a multiple \"\n\t\t\t\"of chunk size\", dir->i_ino);\n\tgoto fail;\nEshort:\n\terror = \"rec_len is smaller than minimal\";\n\tgoto bad_entry;\nEalign:\n\terror = \"unaligned directory entry\";\n\tgoto bad_entry;\nEnamelen:\n\terror = \"rec_len is too small for name_len\";\n\tgoto bad_entry;\nEspan:\n\terror = \"directory entry across blocks\";\n\tgoto bad_entry;\nEinumber:\n\terror = \"inode out of bounds\";\nbad_entry:\n\tif (!quiet)\n\t\text2_error(sb, __func__, \"bad entry in directory #%lu: : %s - \"\n\t\t\t\"offset=%lu, inode=%lu, rec_len=%d, name_len=%d\",\n\t\t\tdir->i_ino, error, (page->index<<PAGE_SHIFT)+offs,\n\t\t\t(unsigned long) le32_to_cpu(p->inode),\n\t\t\trec_len, p->name_len);\n\tgoto fail;\nEend:\n\tif (!quiet) {\n\t\tp = (ext2_dirent *)(kaddr + offs);\n\t\text2_error(sb, \"ext2_check_page\",\n\t\t\t\"entry in directory #%lu spans the page boundary\"\n\t\t\t\"offset=%lu, inode=%lu\",\n\t\t\tdir->i_ino, (page->index<<PAGE_SHIFT)+offs,\n\t\t\t(unsigned long) le32_to_cpu(p->inode));\n\t}\nfail:\n\tSetPageError(page);\n\treturn false;\n}\n\n \nstatic void *ext2_get_page(struct inode *dir, unsigned long n,\n\t\t\t\t   int quiet, struct page **page)\n{\n\tstruct address_space *mapping = dir->i_mapping;\n\tstruct folio *folio = read_mapping_folio(mapping, n, NULL);\n\tvoid *page_addr;\n\n\tif (IS_ERR(folio))\n\t\treturn ERR_CAST(folio);\n\tpage_addr = kmap_local_folio(folio, n & (folio_nr_pages(folio) - 1));\n\tif (unlikely(!folio_test_checked(folio))) {\n\t\tif (!ext2_check_page(&folio->page, quiet, page_addr))\n\t\t\tgoto fail;\n\t}\n\t*page = &folio->page;\n\treturn page_addr;\n\nfail:\n\text2_put_page(&folio->page, page_addr);\n\treturn ERR_PTR(-EIO);\n}\n\n \nstatic inline int ext2_match (int len, const char * const name,\n\t\t\t\t\tstruct ext2_dir_entry_2 * de)\n{\n\tif (len != de->name_len)\n\t\treturn 0;\n\tif (!de->inode)\n\t\treturn 0;\n\treturn !memcmp(name, de->name, len);\n}\n\n \nstatic inline ext2_dirent *ext2_next_entry(ext2_dirent *p)\n{\n\treturn (ext2_dirent *)((char *)p +\n\t\t\text2_rec_len_from_disk(p->rec_len));\n}\n\nstatic inline unsigned \next2_validate_entry(char *base, unsigned offset, unsigned mask)\n{\n\text2_dirent *de = (ext2_dirent*)(base + offset);\n\text2_dirent *p = (ext2_dirent*)(base + (offset&mask));\n\twhile ((char*)p < (char*)de) {\n\t\tif (p->rec_len == 0)\n\t\t\tbreak;\n\t\tp = ext2_next_entry(p);\n\t}\n\treturn offset_in_page(p);\n}\n\nstatic inline void ext2_set_de_type(ext2_dirent *de, struct inode *inode)\n{\n\tif (EXT2_HAS_INCOMPAT_FEATURE(inode->i_sb, EXT2_FEATURE_INCOMPAT_FILETYPE))\n\t\tde->file_type = fs_umode_to_ftype(inode->i_mode);\n\telse\n\t\tde->file_type = 0;\n}\n\nstatic int\next2_readdir(struct file *file, struct dir_context *ctx)\n{\n\tloff_t pos = ctx->pos;\n\tstruct inode *inode = file_inode(file);\n\tstruct super_block *sb = inode->i_sb;\n\tunsigned int offset = pos & ~PAGE_MASK;\n\tunsigned long n = pos >> PAGE_SHIFT;\n\tunsigned long npages = dir_pages(inode);\n\tunsigned chunk_mask = ~(ext2_chunk_size(inode)-1);\n\tbool need_revalidate = !inode_eq_iversion(inode, file->f_version);\n\tbool has_filetype;\n\n\tif (pos > inode->i_size - EXT2_DIR_REC_LEN(1))\n\t\treturn 0;\n\n\thas_filetype =\n\t\tEXT2_HAS_INCOMPAT_FEATURE(sb, EXT2_FEATURE_INCOMPAT_FILETYPE);\n\n\tfor ( ; n < npages; n++, offset = 0) {\n\t\text2_dirent *de;\n\t\tstruct page *page;\n\t\tchar *kaddr = ext2_get_page(inode, n, 0, &page);\n\t\tchar *limit;\n\n\t\tif (IS_ERR(kaddr)) {\n\t\t\text2_error(sb, __func__,\n\t\t\t\t   \"bad page in #%lu\",\n\t\t\t\t   inode->i_ino);\n\t\t\tctx->pos += PAGE_SIZE - offset;\n\t\t\treturn PTR_ERR(kaddr);\n\t\t}\n\t\tif (unlikely(need_revalidate)) {\n\t\t\tif (offset) {\n\t\t\t\toffset = ext2_validate_entry(kaddr, offset, chunk_mask);\n\t\t\t\tctx->pos = (n<<PAGE_SHIFT) + offset;\n\t\t\t}\n\t\t\tfile->f_version = inode_query_iversion(inode);\n\t\t\tneed_revalidate = false;\n\t\t}\n\t\tde = (ext2_dirent *)(kaddr+offset);\n\t\tlimit = kaddr + ext2_last_byte(inode, n) - EXT2_DIR_REC_LEN(1);\n\t\tfor ( ;(char*)de <= limit; de = ext2_next_entry(de)) {\n\t\t\tif (de->rec_len == 0) {\n\t\t\t\text2_error(sb, __func__,\n\t\t\t\t\t\"zero-length directory entry\");\n\t\t\t\text2_put_page(page, de);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tif (de->inode) {\n\t\t\t\tunsigned char d_type = DT_UNKNOWN;\n\n\t\t\t\tif (has_filetype)\n\t\t\t\t\td_type = fs_ftype_to_dtype(de->file_type);\n\n\t\t\t\tif (!dir_emit(ctx, de->name, de->name_len,\n\t\t\t\t\t\tle32_to_cpu(de->inode),\n\t\t\t\t\t\td_type)) {\n\t\t\t\t\text2_put_page(page, de);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tctx->pos += ext2_rec_len_from_disk(de->rec_len);\n\t\t}\n\t\text2_put_page(page, kaddr);\n\t}\n\treturn 0;\n}\n\n \nstruct ext2_dir_entry_2 *ext2_find_entry (struct inode *dir,\n\t\t\tconst struct qstr *child, struct page **res_page)\n{\n\tconst char *name = child->name;\n\tint namelen = child->len;\n\tunsigned reclen = EXT2_DIR_REC_LEN(namelen);\n\tunsigned long start, n;\n\tunsigned long npages = dir_pages(dir);\n\tstruct page *page = NULL;\n\tstruct ext2_inode_info *ei = EXT2_I(dir);\n\text2_dirent * de;\n\n\tif (npages == 0)\n\t\tgoto out;\n\n\t \n\t*res_page = NULL;\n\n\tstart = ei->i_dir_start_lookup;\n\tif (start >= npages)\n\t\tstart = 0;\n\tn = start;\n\tdo {\n\t\tchar *kaddr = ext2_get_page(dir, n, 0, &page);\n\t\tif (IS_ERR(kaddr))\n\t\t\treturn ERR_CAST(kaddr);\n\n\t\tde = (ext2_dirent *) kaddr;\n\t\tkaddr += ext2_last_byte(dir, n) - reclen;\n\t\twhile ((char *) de <= kaddr) {\n\t\t\tif (de->rec_len == 0) {\n\t\t\t\text2_error(dir->i_sb, __func__,\n\t\t\t\t\t\"zero-length directory entry\");\n\t\t\t\text2_put_page(page, de);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (ext2_match(namelen, name, de))\n\t\t\t\tgoto found;\n\t\t\tde = ext2_next_entry(de);\n\t\t}\n\t\text2_put_page(page, kaddr);\n\n\t\tif (++n >= npages)\n\t\t\tn = 0;\n\t\t \n\t\tif (unlikely(n > (dir->i_blocks >> (PAGE_SHIFT - 9)))) {\n\t\t\text2_error(dir->i_sb, __func__,\n\t\t\t\t\"dir %lu size %lld exceeds block count %llu\",\n\t\t\t\tdir->i_ino, dir->i_size,\n\t\t\t\t(unsigned long long)dir->i_blocks);\n\t\t\tgoto out;\n\t\t}\n\t} while (n != start);\nout:\n\treturn ERR_PTR(-ENOENT);\n\nfound:\n\t*res_page = page;\n\tei->i_dir_start_lookup = n;\n\treturn de;\n}\n\n \nstruct ext2_dir_entry_2 *ext2_dotdot(struct inode *dir, struct page **p)\n{\n\text2_dirent *de = ext2_get_page(dir, 0, 0, p);\n\n\tif (!IS_ERR(de))\n\t\treturn ext2_next_entry(de);\n\treturn NULL;\n}\n\nint ext2_inode_by_name(struct inode *dir, const struct qstr *child, ino_t *ino)\n{\n\tstruct ext2_dir_entry_2 *de;\n\tstruct page *page;\n\t\n\tde = ext2_find_entry(dir, child, &page);\n\tif (IS_ERR(de))\n\t\treturn PTR_ERR(de);\n\n\t*ino = le32_to_cpu(de->inode);\n\text2_put_page(page, de);\n\treturn 0;\n}\n\nstatic int ext2_prepare_chunk(struct page *page, loff_t pos, unsigned len)\n{\n\treturn __block_write_begin(page, pos, len, ext2_get_block);\n}\n\n\nstatic int ext2_handle_dirsync(struct inode *dir)\n{\n\tint err;\n\n\terr = filemap_write_and_wait(dir->i_mapping);\n\tif (!err)\n\t\terr = sync_inode_metadata(dir, 1);\n\treturn err;\n}\n\nint ext2_set_link(struct inode *dir, struct ext2_dir_entry_2 *de,\n\t\tstruct page *page, struct inode *inode, bool update_times)\n{\n\tloff_t pos = page_offset(page) + offset_in_page(de);\n\tunsigned len = ext2_rec_len_from_disk(de->rec_len);\n\tint err;\n\n\tlock_page(page);\n\terr = ext2_prepare_chunk(page, pos, len);\n\tif (err) {\n\t\tunlock_page(page);\n\t\treturn err;\n\t}\n\tde->inode = cpu_to_le32(inode->i_ino);\n\text2_set_de_type(de, inode);\n\text2_commit_chunk(page, pos, len);\n\tif (update_times)\n\t\tdir->i_mtime = inode_set_ctime_current(dir);\n\tEXT2_I(dir)->i_flags &= ~EXT2_BTREE_FL;\n\tmark_inode_dirty(dir);\n\treturn ext2_handle_dirsync(dir);\n}\n\n \nint ext2_add_link (struct dentry *dentry, struct inode *inode)\n{\n\tstruct inode *dir = d_inode(dentry->d_parent);\n\tconst char *name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tunsigned chunk_size = ext2_chunk_size(dir);\n\tunsigned reclen = EXT2_DIR_REC_LEN(namelen);\n\tunsigned short rec_len, name_len;\n\tstruct page *page = NULL;\n\text2_dirent * de;\n\tunsigned long npages = dir_pages(dir);\n\tunsigned long n;\n\tloff_t pos;\n\tint err;\n\n\t \n\tfor (n = 0; n <= npages; n++) {\n\t\tchar *kaddr = ext2_get_page(dir, n, 0, &page);\n\t\tchar *dir_end;\n\n\t\tif (IS_ERR(kaddr))\n\t\t\treturn PTR_ERR(kaddr);\n\t\tlock_page(page);\n\t\tdir_end = kaddr + ext2_last_byte(dir, n);\n\t\tde = (ext2_dirent *)kaddr;\n\t\tkaddr += PAGE_SIZE - reclen;\n\t\twhile ((char *)de <= kaddr) {\n\t\t\tif ((char *)de == dir_end) {\n\t\t\t\t \n\t\t\t\tname_len = 0;\n\t\t\t\trec_len = chunk_size;\n\t\t\t\tde->rec_len = ext2_rec_len_to_disk(chunk_size);\n\t\t\t\tde->inode = 0;\n\t\t\t\tgoto got_it;\n\t\t\t}\n\t\t\tif (de->rec_len == 0) {\n\t\t\t\text2_error(dir->i_sb, __func__,\n\t\t\t\t\t\"zero-length directory entry\");\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\terr = -EEXIST;\n\t\t\tif (ext2_match (namelen, name, de))\n\t\t\t\tgoto out_unlock;\n\t\t\tname_len = EXT2_DIR_REC_LEN(de->name_len);\n\t\t\trec_len = ext2_rec_len_from_disk(de->rec_len);\n\t\t\tif (!de->inode && rec_len >= reclen)\n\t\t\t\tgoto got_it;\n\t\t\tif (rec_len >= name_len + reclen)\n\t\t\t\tgoto got_it;\n\t\t\tde = (ext2_dirent *) ((char *) de + rec_len);\n\t\t}\n\t\tunlock_page(page);\n\t\text2_put_page(page, kaddr);\n\t}\n\tBUG();\n\treturn -EINVAL;\n\ngot_it:\n\tpos = page_offset(page) + offset_in_page(de);\n\terr = ext2_prepare_chunk(page, pos, rec_len);\n\tif (err)\n\t\tgoto out_unlock;\n\tif (de->inode) {\n\t\text2_dirent *de1 = (ext2_dirent *) ((char *) de + name_len);\n\t\tde1->rec_len = ext2_rec_len_to_disk(rec_len - name_len);\n\t\tde->rec_len = ext2_rec_len_to_disk(name_len);\n\t\tde = de1;\n\t}\n\tde->name_len = namelen;\n\tmemcpy(de->name, name, namelen);\n\tde->inode = cpu_to_le32(inode->i_ino);\n\text2_set_de_type (de, inode);\n\text2_commit_chunk(page, pos, rec_len);\n\tdir->i_mtime = inode_set_ctime_current(dir);\n\tEXT2_I(dir)->i_flags &= ~EXT2_BTREE_FL;\n\tmark_inode_dirty(dir);\n\terr = ext2_handle_dirsync(dir);\n\t \nout_put:\n\text2_put_page(page, de);\n\treturn err;\nout_unlock:\n\tunlock_page(page);\n\tgoto out_put;\n}\n\n \nint ext2_delete_entry(struct ext2_dir_entry_2 *dir, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tchar *kaddr = (char *)((unsigned long)dir & PAGE_MASK);\n\tunsigned from = offset_in_page(dir) & ~(ext2_chunk_size(inode)-1);\n\tunsigned to = offset_in_page(dir) +\n\t\t\t\text2_rec_len_from_disk(dir->rec_len);\n\tloff_t pos;\n\text2_dirent *pde = NULL;\n\text2_dirent *de = (ext2_dirent *)(kaddr + from);\n\tint err;\n\n\twhile ((char*)de < (char*)dir) {\n\t\tif (de->rec_len == 0) {\n\t\t\text2_error(inode->i_sb, __func__,\n\t\t\t\t\"zero-length directory entry\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tpde = de;\n\t\tde = ext2_next_entry(de);\n\t}\n\tif (pde)\n\t\tfrom = offset_in_page(pde);\n\tpos = page_offset(page) + from;\n\tlock_page(page);\n\terr = ext2_prepare_chunk(page, pos, to - from);\n\tif (err) {\n\t\tunlock_page(page);\n\t\treturn err;\n\t}\n\tif (pde)\n\t\tpde->rec_len = ext2_rec_len_to_disk(to - from);\n\tdir->inode = 0;\n\text2_commit_chunk(page, pos, to - from);\n\tinode->i_mtime = inode_set_ctime_current(inode);\n\tEXT2_I(inode)->i_flags &= ~EXT2_BTREE_FL;\n\tmark_inode_dirty(inode);\n\treturn ext2_handle_dirsync(inode);\n}\n\n \nint ext2_make_empty(struct inode *inode, struct inode *parent)\n{\n\tstruct page *page = grab_cache_page(inode->i_mapping, 0);\n\tunsigned chunk_size = ext2_chunk_size(inode);\n\tstruct ext2_dir_entry_2 * de;\n\tint err;\n\tvoid *kaddr;\n\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\terr = ext2_prepare_chunk(page, 0, chunk_size);\n\tif (err) {\n\t\tunlock_page(page);\n\t\tgoto fail;\n\t}\n\tkaddr = kmap_local_page(page);\n\tmemset(kaddr, 0, chunk_size);\n\tde = (struct ext2_dir_entry_2 *)kaddr;\n\tde->name_len = 1;\n\tde->rec_len = ext2_rec_len_to_disk(EXT2_DIR_REC_LEN(1));\n\tmemcpy (de->name, \".\\0\\0\", 4);\n\tde->inode = cpu_to_le32(inode->i_ino);\n\text2_set_de_type (de, inode);\n\n\tde = (struct ext2_dir_entry_2 *)(kaddr + EXT2_DIR_REC_LEN(1));\n\tde->name_len = 2;\n\tde->rec_len = ext2_rec_len_to_disk(chunk_size - EXT2_DIR_REC_LEN(1));\n\tde->inode = cpu_to_le32(parent->i_ino);\n\tmemcpy (de->name, \"..\\0\", 4);\n\text2_set_de_type (de, inode);\n\tkunmap_local(kaddr);\n\text2_commit_chunk(page, 0, chunk_size);\n\terr = ext2_handle_dirsync(inode);\nfail:\n\tput_page(page);\n\treturn err;\n}\n\n \nint ext2_empty_dir (struct inode * inode)\n{\n\tstruct page *page;\n\tchar *kaddr;\n\tunsigned long i, npages = dir_pages(inode);\n\n\tfor (i = 0; i < npages; i++) {\n\t\text2_dirent *de;\n\n\t\tkaddr = ext2_get_page(inode, i, 0, &page);\n\t\tif (IS_ERR(kaddr))\n\t\t\treturn 0;\n\n\t\tde = (ext2_dirent *)kaddr;\n\t\tkaddr += ext2_last_byte(inode, i) - EXT2_DIR_REC_LEN(1);\n\n\t\twhile ((char *)de <= kaddr) {\n\t\t\tif (de->rec_len == 0) {\n\t\t\t\text2_error(inode->i_sb, __func__,\n\t\t\t\t\t\"zero-length directory entry\");\n\t\t\t\tprintk(\"kaddr=%p, de=%p\\n\", kaddr, de);\n\t\t\t\tgoto not_empty;\n\t\t\t}\n\t\t\tif (de->inode != 0) {\n\t\t\t\t \n\t\t\t\tif (de->name[0] != '.')\n\t\t\t\t\tgoto not_empty;\n\t\t\t\tif (de->name_len > 2)\n\t\t\t\t\tgoto not_empty;\n\t\t\t\tif (de->name_len < 2) {\n\t\t\t\t\tif (de->inode !=\n\t\t\t\t\t    cpu_to_le32(inode->i_ino))\n\t\t\t\t\t\tgoto not_empty;\n\t\t\t\t} else if (de->name[1] != '.')\n\t\t\t\t\tgoto not_empty;\n\t\t\t}\n\t\t\tde = ext2_next_entry(de);\n\t\t}\n\t\text2_put_page(page, kaddr);\n\t}\n\treturn 1;\n\nnot_empty:\n\text2_put_page(page, kaddr);\n\treturn 0;\n}\n\nconst struct file_operations ext2_dir_operations = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= generic_read_dir,\n\t.iterate_shared\t= ext2_readdir,\n\t.unlocked_ioctl = ext2_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t= ext2_compat_ioctl,\n#endif\n\t.fsync\t\t= ext2_fsync,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}