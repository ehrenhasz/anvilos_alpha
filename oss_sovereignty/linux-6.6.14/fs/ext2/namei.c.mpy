{
  "module_name": "namei.c",
  "hash_id": "0ec154f0aac225c3e465bc4b014b22bbf8ae8235d4eec3529e752cde1e78bb97",
  "original_prompt": "Ingested from linux-6.6.14/fs/ext2/namei.c",
  "human_readable_source": "\n \n\n#include <linux/pagemap.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n\nstatic inline int ext2_add_nondir(struct dentry *dentry, struct inode *inode)\n{\n\tint err = ext2_add_link(dentry, inode);\n\tif (!err) {\n\t\td_instantiate_new(dentry, inode);\n\t\treturn 0;\n\t}\n\tinode_dec_link_count(inode);\n\tdiscard_new_inode(inode);\n\treturn err;\n}\n\n \n\nstatic struct dentry *ext2_lookup(struct inode * dir, struct dentry *dentry, unsigned int flags)\n{\n\tstruct inode * inode;\n\tino_t ino;\n\tint res;\n\t\n\tif (dentry->d_name.len > EXT2_NAME_LEN)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tres = ext2_inode_by_name(dir, &dentry->d_name, &ino);\n\tif (res) {\n\t\tif (res != -ENOENT)\n\t\t\treturn ERR_PTR(res);\n\t\tinode = NULL;\n\t} else {\n\t\tinode = ext2_iget(dir->i_sb, ino);\n\t\tif (inode == ERR_PTR(-ESTALE)) {\n\t\t\text2_error(dir->i_sb, __func__,\n\t\t\t\t\t\"deleted inode referenced: %lu\",\n\t\t\t\t\t(unsigned long) ino);\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\n\t}\n\treturn d_splice_alias(inode, dentry);\n}\n\nstruct dentry *ext2_get_parent(struct dentry *child)\n{\n\tino_t ino;\n\tint res;\n\n\tres = ext2_inode_by_name(d_inode(child), &dotdot_name, &ino);\n\tif (res)\n\t\treturn ERR_PTR(res);\n\n\treturn d_obtain_alias(ext2_iget(child->d_sb, ino));\n} \n\n \nstatic int ext2_create (struct mnt_idmap * idmap,\n\t\t\tstruct inode * dir, struct dentry * dentry,\n\t\t\tumode_t mode, bool excl)\n{\n\tstruct inode *inode;\n\tint err;\n\n\terr = dquot_initialize(dir);\n\tif (err)\n\t\treturn err;\n\n\tinode = ext2_new_inode(dir, mode, &dentry->d_name);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\text2_set_file_ops(inode);\n\tmark_inode_dirty(inode);\n\treturn ext2_add_nondir(dentry, inode);\n}\n\nstatic int ext2_tmpfile(struct mnt_idmap *idmap, struct inode *dir,\n\t\t\tstruct file *file, umode_t mode)\n{\n\tstruct inode *inode = ext2_new_inode(dir, mode, NULL);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\text2_set_file_ops(inode);\n\tmark_inode_dirty(inode);\n\td_tmpfile(file, inode);\n\tunlock_new_inode(inode);\n\treturn finish_open_simple(file, 0);\n}\n\nstatic int ext2_mknod (struct mnt_idmap * idmap, struct inode * dir,\n\tstruct dentry *dentry, umode_t mode, dev_t rdev)\n{\n\tstruct inode * inode;\n\tint err;\n\n\terr = dquot_initialize(dir);\n\tif (err)\n\t\treturn err;\n\n\tinode = ext2_new_inode (dir, mode, &dentry->d_name);\n\terr = PTR_ERR(inode);\n\tif (!IS_ERR(inode)) {\n\t\tinit_special_inode(inode, inode->i_mode, rdev);\n\t\tinode->i_op = &ext2_special_inode_operations;\n\t\tmark_inode_dirty(inode);\n\t\terr = ext2_add_nondir(dentry, inode);\n\t}\n\treturn err;\n}\n\nstatic int ext2_symlink (struct mnt_idmap * idmap, struct inode * dir,\n\tstruct dentry * dentry, const char * symname)\n{\n\tstruct super_block * sb = dir->i_sb;\n\tint err = -ENAMETOOLONG;\n\tunsigned l = strlen(symname)+1;\n\tstruct inode * inode;\n\n\tif (l > sb->s_blocksize)\n\t\tgoto out;\n\n\terr = dquot_initialize(dir);\n\tif (err)\n\t\tgoto out;\n\n\tinode = ext2_new_inode (dir, S_IFLNK | S_IRWXUGO, &dentry->d_name);\n\terr = PTR_ERR(inode);\n\tif (IS_ERR(inode))\n\t\tgoto out;\n\n\tif (l > sizeof (EXT2_I(inode)->i_data)) {\n\t\t \n\t\tinode->i_op = &ext2_symlink_inode_operations;\n\t\tinode_nohighmem(inode);\n\t\tinode->i_mapping->a_ops = &ext2_aops;\n\t\terr = page_symlink(inode, symname, l);\n\t\tif (err)\n\t\t\tgoto out_fail;\n\t} else {\n\t\t \n\t\tinode->i_op = &ext2_fast_symlink_inode_operations;\n\t\tinode->i_link = (char*)EXT2_I(inode)->i_data;\n\t\tmemcpy(inode->i_link, symname, l);\n\t\tinode->i_size = l-1;\n\t}\n\tmark_inode_dirty(inode);\n\n\terr = ext2_add_nondir(dentry, inode);\nout:\n\treturn err;\n\nout_fail:\n\tinode_dec_link_count(inode);\n\tdiscard_new_inode(inode);\n\tgoto out;\n}\n\nstatic int ext2_link (struct dentry * old_dentry, struct inode * dir,\n\tstruct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(old_dentry);\n\tint err;\n\n\terr = dquot_initialize(dir);\n\tif (err)\n\t\treturn err;\n\n\tinode_set_ctime_current(inode);\n\tinode_inc_link_count(inode);\n\tihold(inode);\n\n\terr = ext2_add_link(dentry, inode);\n\tif (!err) {\n\t\td_instantiate(dentry, inode);\n\t\treturn 0;\n\t}\n\tinode_dec_link_count(inode);\n\tiput(inode);\n\treturn err;\n}\n\nstatic int ext2_mkdir(struct mnt_idmap * idmap,\n\tstruct inode * dir, struct dentry * dentry, umode_t mode)\n{\n\tstruct inode * inode;\n\tint err;\n\n\terr = dquot_initialize(dir);\n\tif (err)\n\t\treturn err;\n\n\tinode_inc_link_count(dir);\n\n\tinode = ext2_new_inode(dir, S_IFDIR | mode, &dentry->d_name);\n\terr = PTR_ERR(inode);\n\tif (IS_ERR(inode))\n\t\tgoto out_dir;\n\n\tinode->i_op = &ext2_dir_inode_operations;\n\tinode->i_fop = &ext2_dir_operations;\n\tinode->i_mapping->a_ops = &ext2_aops;\n\n\tinode_inc_link_count(inode);\n\n\terr = ext2_make_empty(inode, dir);\n\tif (err)\n\t\tgoto out_fail;\n\n\terr = ext2_add_link(dentry, inode);\n\tif (err)\n\t\tgoto out_fail;\n\n\td_instantiate_new(dentry, inode);\nout:\n\treturn err;\n\nout_fail:\n\tinode_dec_link_count(inode);\n\tinode_dec_link_count(inode);\n\tdiscard_new_inode(inode);\nout_dir:\n\tinode_dec_link_count(dir);\n\tgoto out;\n}\n\nstatic int ext2_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct ext2_dir_entry_2 *de;\n\tstruct page *page;\n\tint err;\n\n\terr = dquot_initialize(dir);\n\tif (err)\n\t\tgoto out;\n\n\tde = ext2_find_entry(dir, &dentry->d_name, &page);\n\tif (IS_ERR(de)) {\n\t\terr = PTR_ERR(de);\n\t\tgoto out;\n\t}\n\n\terr = ext2_delete_entry(de, page);\n\text2_put_page(page, de);\n\tif (err)\n\t\tgoto out;\n\n\tinode_set_ctime_to_ts(inode, inode_get_ctime(dir));\n\tinode_dec_link_count(inode);\n\terr = 0;\nout:\n\treturn err;\n}\n\nstatic int ext2_rmdir (struct inode * dir, struct dentry *dentry)\n{\n\tstruct inode * inode = d_inode(dentry);\n\tint err = -ENOTEMPTY;\n\n\tif (ext2_empty_dir(inode)) {\n\t\terr = ext2_unlink(dir, dentry);\n\t\tif (!err) {\n\t\t\tinode->i_size = 0;\n\t\t\tinode_dec_link_count(inode);\n\t\t\tinode_dec_link_count(dir);\n\t\t}\n\t}\n\treturn err;\n}\n\nstatic int ext2_rename (struct mnt_idmap * idmap,\n\t\t\tstruct inode * old_dir, struct dentry * old_dentry,\n\t\t\tstruct inode * new_dir, struct dentry * new_dentry,\n\t\t\tunsigned int flags)\n{\n\tstruct inode * old_inode = d_inode(old_dentry);\n\tstruct inode * new_inode = d_inode(new_dentry);\n\tstruct page * dir_page = NULL;\n\tstruct ext2_dir_entry_2 * dir_de = NULL;\n\tstruct page * old_page;\n\tstruct ext2_dir_entry_2 * old_de;\n\tint err;\n\n\tif (flags & ~RENAME_NOREPLACE)\n\t\treturn -EINVAL;\n\n\terr = dquot_initialize(old_dir);\n\tif (err)\n\t\treturn err;\n\n\terr = dquot_initialize(new_dir);\n\tif (err)\n\t\treturn err;\n\n\told_de = ext2_find_entry(old_dir, &old_dentry->d_name, &old_page);\n\tif (IS_ERR(old_de))\n\t\treturn PTR_ERR(old_de);\n\n\tif (S_ISDIR(old_inode->i_mode)) {\n\t\terr = -EIO;\n\t\tdir_de = ext2_dotdot(old_inode, &dir_page);\n\t\tif (!dir_de)\n\t\t\tgoto out_old;\n\t}\n\n\tif (new_inode) {\n\t\tstruct page *new_page;\n\t\tstruct ext2_dir_entry_2 *new_de;\n\n\t\terr = -ENOTEMPTY;\n\t\tif (dir_de && !ext2_empty_dir (new_inode))\n\t\t\tgoto out_dir;\n\n\t\tnew_de = ext2_find_entry(new_dir, &new_dentry->d_name,\n\t\t\t\t\t &new_page);\n\t\tif (IS_ERR(new_de)) {\n\t\t\terr = PTR_ERR(new_de);\n\t\t\tgoto out_dir;\n\t\t}\n\t\terr = ext2_set_link(new_dir, new_de, new_page, old_inode, true);\n\t\text2_put_page(new_page, new_de);\n\t\tif (err)\n\t\t\tgoto out_dir;\n\t\tinode_set_ctime_current(new_inode);\n\t\tif (dir_de)\n\t\t\tdrop_nlink(new_inode);\n\t\tinode_dec_link_count(new_inode);\n\t} else {\n\t\terr = ext2_add_link(new_dentry, old_inode);\n\t\tif (err)\n\t\t\tgoto out_dir;\n\t\tif (dir_de)\n\t\t\tinode_inc_link_count(new_dir);\n\t}\n\n\t \n\tinode_set_ctime_current(old_inode);\n\tmark_inode_dirty(old_inode);\n\n\terr = ext2_delete_entry(old_de, old_page);\n\tif (!err && dir_de) {\n\t\tif (old_dir != new_dir)\n\t\t\terr = ext2_set_link(old_inode, dir_de, dir_page,\n\t\t\t\t\t    new_dir, false);\n\n\t\tinode_dec_link_count(old_dir);\n\t}\nout_dir:\n\tif (dir_de)\n\t\text2_put_page(dir_page, dir_de);\nout_old:\n\text2_put_page(old_page, old_de);\n\treturn err;\n}\n\nconst struct inode_operations ext2_dir_inode_operations = {\n\t.create\t\t= ext2_create,\n\t.lookup\t\t= ext2_lookup,\n\t.link\t\t= ext2_link,\n\t.unlink\t\t= ext2_unlink,\n\t.symlink\t= ext2_symlink,\n\t.mkdir\t\t= ext2_mkdir,\n\t.rmdir\t\t= ext2_rmdir,\n\t.mknod\t\t= ext2_mknod,\n\t.rename\t\t= ext2_rename,\n\t.listxattr\t= ext2_listxattr,\n\t.getattr\t= ext2_getattr,\n\t.setattr\t= ext2_setattr,\n\t.get_inode_acl\t= ext2_get_acl,\n\t.set_acl\t= ext2_set_acl,\n\t.tmpfile\t= ext2_tmpfile,\n\t.fileattr_get\t= ext2_fileattr_get,\n\t.fileattr_set\t= ext2_fileattr_set,\n};\n\nconst struct inode_operations ext2_special_inode_operations = {\n\t.listxattr\t= ext2_listxattr,\n\t.getattr\t= ext2_getattr,\n\t.setattr\t= ext2_setattr,\n\t.get_inode_acl\t= ext2_get_acl,\n\t.set_acl\t= ext2_set_acl,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}