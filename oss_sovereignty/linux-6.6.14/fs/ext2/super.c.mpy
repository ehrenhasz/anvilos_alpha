{
  "module_name": "super.c",
  "hash_id": "36a4256910830741361beb90159053f34983998911b4c59f6a695625b2208a86",
  "original_prompt": "Ingested from linux-6.6.14/fs/ext2/super.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/parser.h>\n#include <linux/random.h>\n#include <linux/buffer_head.h>\n#include <linux/exportfs.h>\n#include <linux/vfs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/quotaops.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/iversion.h>\n#include \"ext2.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n\nstatic void ext2_write_super(struct super_block *sb);\nstatic int ext2_remount (struct super_block * sb, int * flags, char * data);\nstatic int ext2_statfs (struct dentry * dentry, struct kstatfs * buf);\nstatic int ext2_sync_fs(struct super_block *sb, int wait);\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nvoid ext2_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = sbi->s_es;\n\n\tif (!sb_rdonly(sb)) {\n\t\tspin_lock(&sbi->s_lock);\n\t\tsbi->s_mount_state |= EXT2_ERROR_FS;\n\t\tes->s_state |= cpu_to_le16(EXT2_ERROR_FS);\n\t\tspin_unlock(&sbi->s_lock);\n\t\text2_sync_super(sb, es, 1);\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT2-fs (%s): error: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT2-fs: panic from previous error\\n\");\n\tif (!sb_rdonly(sb) && test_opt(sb, ERRORS_RO)) {\n\t\text2_msg(sb, KERN_CRIT,\n\t\t\t     \"error: remounting filesystem read-only\");\n\t\tsb->s_flags |= SB_RDONLY;\n\t}\n}\n\nvoid ext2_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT2-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}\n\n \nvoid ext2_update_dynamic_rev(struct super_block *sb)\n{\n\tstruct ext2_super_block *es = EXT2_SB(sb)->s_es;\n\n\tif (le32_to_cpu(es->s_rev_level) > EXT2_GOOD_OLD_REV)\n\t\treturn;\n\n\text2_msg(sb, KERN_WARNING,\n\t\t     \"warning: updating to rev %d because of \"\n\t\t     \"new feature flag, running e2fsck is recommended\",\n\t\t     EXT2_DYNAMIC_REV);\n\n\tes->s_first_ino = cpu_to_le32(EXT2_GOOD_OLD_FIRST_INO);\n\tes->s_inode_size = cpu_to_le16(EXT2_GOOD_OLD_INODE_SIZE);\n\tes->s_rev_level = cpu_to_le32(EXT2_DYNAMIC_REV);\n\t \n\t \n\n\t \n}\n\n#ifdef CONFIG_QUOTA\nstatic int ext2_quota_off(struct super_block *sb, int type);\n\nstatic void ext2_quota_off_umount(struct super_block *sb)\n{\n\tint type;\n\n\tfor (type = 0; type < MAXQUOTAS; type++)\n\t\text2_quota_off(sb, type);\n}\n#else\nstatic inline void ext2_quota_off_umount(struct super_block *sb)\n{\n}\n#endif\n\nstatic void ext2_put_super (struct super_block * sb)\n{\n\tint db_count;\n\tint i;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\n\text2_quota_off_umount(sb);\n\n\text2_xattr_destroy_cache(sbi->s_ea_block_cache);\n\tsbi->s_ea_block_cache = NULL;\n\n\tif (!sb_rdonly(sb)) {\n\t\tstruct ext2_super_block *es = sbi->s_es;\n\n\t\tspin_lock(&sbi->s_lock);\n\t\tes->s_state = cpu_to_le16(sbi->s_mount_state);\n\t\tspin_unlock(&sbi->s_lock);\n\t\text2_sync_super(sb, es, 1);\n\t}\n\tdb_count = sbi->s_gdb_count;\n\tfor (i = 0; i < db_count; i++)\n\t\tbrelse(sbi->s_group_desc[i]);\n\tkvfree(sbi->s_group_desc);\n\tkfree(sbi->s_debts);\n\tpercpu_counter_destroy(&sbi->s_freeblocks_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tbrelse (sbi->s_sbh);\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\n\tfs_put_dax(sbi->s_daxdev, NULL);\n\tkfree(sbi);\n}\n\nstatic struct kmem_cache * ext2_inode_cachep;\n\nstatic struct inode *ext2_alloc_inode(struct super_block *sb)\n{\n\tstruct ext2_inode_info *ei;\n\tei = alloc_inode_sb(sb, ext2_inode_cachep, GFP_KERNEL);\n\tif (!ei)\n\t\treturn NULL;\n\tei->i_block_alloc_info = NULL;\n\tinode_set_iversion(&ei->vfs_inode, 1);\n#ifdef CONFIG_QUOTA\n\tmemset(&ei->i_dquot, 0, sizeof(ei->i_dquot));\n#endif\n\n\treturn &ei->vfs_inode;\n}\n\nstatic void ext2_free_in_core_inode(struct inode *inode)\n{\n\tkmem_cache_free(ext2_inode_cachep, EXT2_I(inode));\n}\n\nstatic void init_once(void *foo)\n{\n\tstruct ext2_inode_info *ei = (struct ext2_inode_info *) foo;\n\n\trwlock_init(&ei->i_meta_lock);\n#ifdef CONFIG_EXT2_FS_XATTR\n\tinit_rwsem(&ei->xattr_sem);\n#endif\n\tmutex_init(&ei->truncate_mutex);\n\tinode_init_once(&ei->vfs_inode);\n}\n\nstatic int __init init_inodecache(void)\n{\n\text2_inode_cachep = kmem_cache_create_usercopy(\"ext2_inode_cache\",\n\t\t\t\tsizeof(struct ext2_inode_info), 0,\n\t\t\t\t(SLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD|\n\t\t\t\t\tSLAB_ACCOUNT),\n\t\t\t\toffsetof(struct ext2_inode_info, i_data),\n\t\t\t\tsizeof_field(struct ext2_inode_info, i_data),\n\t\t\t\tinit_once);\n\tif (ext2_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic void destroy_inodecache(void)\n{\n\t \n\trcu_barrier();\n\tkmem_cache_destroy(ext2_inode_cachep);\n}\n\nstatic int ext2_show_options(struct seq_file *seq, struct dentry *root)\n{\n\tstruct super_block *sb = root->d_sb;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = sbi->s_es;\n\tunsigned long def_mount_opts;\n\n\tspin_lock(&sbi->s_lock);\n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\n\tif (sbi->s_sb_block != 1)\n\t\tseq_printf(seq, \",sb=%lu\", sbi->s_sb_block);\n\tif (test_opt(sb, MINIX_DF))\n\t\tseq_puts(seq, \",minixdf\");\n\tif (test_opt(sb, GRPID))\n\t\tseq_puts(seq, \",grpid\");\n\tif (!test_opt(sb, GRPID) && (def_mount_opts & EXT2_DEFM_BSDGROUPS))\n\t\tseq_puts(seq, \",nogrpid\");\n\tif (!uid_eq(sbi->s_resuid, make_kuid(&init_user_ns, EXT2_DEF_RESUID)) ||\n\t    le16_to_cpu(es->s_def_resuid) != EXT2_DEF_RESUID) {\n\t\tseq_printf(seq, \",resuid=%u\",\n\t\t\t\tfrom_kuid_munged(&init_user_ns, sbi->s_resuid));\n\t}\n\tif (!gid_eq(sbi->s_resgid, make_kgid(&init_user_ns, EXT2_DEF_RESGID)) ||\n\t    le16_to_cpu(es->s_def_resgid) != EXT2_DEF_RESGID) {\n\t\tseq_printf(seq, \",resgid=%u\",\n\t\t\t\tfrom_kgid_munged(&init_user_ns, sbi->s_resgid));\n\t}\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\tint def_errors = le16_to_cpu(es->s_errors);\n\n\t\tif (def_errors == EXT2_ERRORS_PANIC ||\n\t\t    def_errors == EXT2_ERRORS_CONTINUE) {\n\t\t\tseq_puts(seq, \",errors=remount-ro\");\n\t\t}\n\t}\n\tif (test_opt(sb, ERRORS_CONT))\n\t\tseq_puts(seq, \",errors=continue\");\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tseq_puts(seq, \",errors=panic\");\n\tif (test_opt(sb, NO_UID32))\n\t\tseq_puts(seq, \",nouid32\");\n\tif (test_opt(sb, DEBUG))\n\t\tseq_puts(seq, \",debug\");\n\tif (test_opt(sb, OLDALLOC))\n\t\tseq_puts(seq, \",oldalloc\");\n\n#ifdef CONFIG_EXT2_FS_XATTR\n\tif (test_opt(sb, XATTR_USER))\n\t\tseq_puts(seq, \",user_xattr\");\n\tif (!test_opt(sb, XATTR_USER) &&\n\t    (def_mount_opts & EXT2_DEFM_XATTR_USER)) {\n\t\tseq_puts(seq, \",nouser_xattr\");\n\t}\n#endif\n\n#ifdef CONFIG_EXT2_FS_POSIX_ACL\n\tif (test_opt(sb, POSIX_ACL))\n\t\tseq_puts(seq, \",acl\");\n\tif (!test_opt(sb, POSIX_ACL) && (def_mount_opts & EXT2_DEFM_ACL))\n\t\tseq_puts(seq, \",noacl\");\n#endif\n\n\tif (test_opt(sb, USRQUOTA))\n\t\tseq_puts(seq, \",usrquota\");\n\n\tif (test_opt(sb, GRPQUOTA))\n\t\tseq_puts(seq, \",grpquota\");\n\n\tif (test_opt(sb, XIP))\n\t\tseq_puts(seq, \",xip\");\n\n\tif (test_opt(sb, DAX))\n\t\tseq_puts(seq, \",dax\");\n\n\tif (!test_opt(sb, RESERVATION))\n\t\tseq_puts(seq, \",noreservation\");\n\n\tspin_unlock(&sbi->s_lock);\n\treturn 0;\n}\n\n#ifdef CONFIG_QUOTA\nstatic ssize_t ext2_quota_read(struct super_block *sb, int type, char *data, size_t len, loff_t off);\nstatic ssize_t ext2_quota_write(struct super_block *sb, int type, const char *data, size_t len, loff_t off);\nstatic int ext2_quota_on(struct super_block *sb, int type, int format_id,\n\t\t\t const struct path *path);\nstatic struct dquot **ext2_get_dquots(struct inode *inode)\n{\n\treturn EXT2_I(inode)->i_dquot;\n}\n\nstatic const struct quotactl_ops ext2_quotactl_ops = {\n\t.quota_on\t= ext2_quota_on,\n\t.quota_off\t= ext2_quota_off,\n\t.quota_sync\t= dquot_quota_sync,\n\t.get_state\t= dquot_get_state,\n\t.set_info\t= dquot_set_dqinfo,\n\t.get_dqblk\t= dquot_get_dqblk,\n\t.set_dqblk\t= dquot_set_dqblk,\n\t.get_nextdqblk\t= dquot_get_next_dqblk,\n};\n#endif\n\nstatic const struct super_operations ext2_sops = {\n\t.alloc_inode\t= ext2_alloc_inode,\n\t.free_inode\t= ext2_free_in_core_inode,\n\t.write_inode\t= ext2_write_inode,\n\t.evict_inode\t= ext2_evict_inode,\n\t.put_super\t= ext2_put_super,\n\t.sync_fs\t= ext2_sync_fs,\n\t.freeze_fs\t= ext2_freeze,\n\t.unfreeze_fs\t= ext2_unfreeze,\n\t.statfs\t\t= ext2_statfs,\n\t.remount_fs\t= ext2_remount,\n\t.show_options\t= ext2_show_options,\n#ifdef CONFIG_QUOTA\n\t.quota_read\t= ext2_quota_read,\n\t.quota_write\t= ext2_quota_write,\n\t.get_dquots\t= ext2_get_dquots,\n#endif\n};\n\nstatic struct inode *ext2_nfs_get_inode(struct super_block *sb,\n\t\tu64 ino, u32 generation)\n{\n\tstruct inode *inode;\n\n\tif (ino < EXT2_FIRST_INO(sb) && ino != EXT2_ROOT_INO)\n\t\treturn ERR_PTR(-ESTALE);\n\tif (ino > le32_to_cpu(EXT2_SB(sb)->s_es->s_inodes_count))\n\t\treturn ERR_PTR(-ESTALE);\n\n\t \n\tinode = ext2_iget(sb, ino);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\tif (generation && inode->i_generation != generation) {\n\t\t \n\t\tiput(inode);\n\t\treturn ERR_PTR(-ESTALE);\n\t}\n\treturn inode;\n}\n\nstatic struct dentry *ext2_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type)\n{\n\treturn generic_fh_to_dentry(sb, fid, fh_len, fh_type,\n\t\t\t\t    ext2_nfs_get_inode);\n}\n\nstatic struct dentry *ext2_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type)\n{\n\treturn generic_fh_to_parent(sb, fid, fh_len, fh_type,\n\t\t\t\t    ext2_nfs_get_inode);\n}\n\nstatic const struct export_operations ext2_export_ops = {\n\t.fh_to_dentry = ext2_fh_to_dentry,\n\t.fh_to_parent = ext2_fh_to_parent,\n\t.get_parent = ext2_get_parent,\n};\n\nstatic unsigned long get_sb_block(void **data)\n{\n\tunsigned long \tsb_block;\n\tchar \t\t*options = (char *) *data;\n\n\tif (!options || strncmp(options, \"sb=\", 3) != 0)\n\t\treturn 1;\t \n\toptions += 3;\n\tsb_block = simple_strtoul(options, &options, 0);\n\tif (*options && *options != ',') {\n\t\tprintk(\"EXT2-fs: Invalid sb specification: %s\\n\",\n\t\t       (char *) *data);\n\t\treturn 1;\n\t}\n\tif (*options == ',')\n\t\toptions++;\n\t*data = (void *) options;\n\treturn sb_block;\n}\n\nenum {\n\tOpt_bsd_df, Opt_minix_df, Opt_grpid, Opt_nogrpid,\n\tOpt_resgid, Opt_resuid, Opt_sb, Opt_err_cont, Opt_err_panic,\n\tOpt_err_ro, Opt_nouid32, Opt_debug,\n\tOpt_oldalloc, Opt_orlov, Opt_nobh, Opt_user_xattr, Opt_nouser_xattr,\n\tOpt_acl, Opt_noacl, Opt_xip, Opt_dax, Opt_ignore, Opt_err, Opt_quota,\n\tOpt_usrquota, Opt_grpquota, Opt_reservation, Opt_noreservation\n};\n\nstatic const match_table_t tokens = {\n\t{Opt_bsd_df, \"bsddf\"},\n\t{Opt_minix_df, \"minixdf\"},\n\t{Opt_grpid, \"grpid\"},\n\t{Opt_grpid, \"bsdgroups\"},\n\t{Opt_nogrpid, \"nogrpid\"},\n\t{Opt_nogrpid, \"sysvgroups\"},\n\t{Opt_resgid, \"resgid=%u\"},\n\t{Opt_resuid, \"resuid=%u\"},\n\t{Opt_sb, \"sb=%u\"},\n\t{Opt_err_cont, \"errors=continue\"},\n\t{Opt_err_panic, \"errors=panic\"},\n\t{Opt_err_ro, \"errors=remount-ro\"},\n\t{Opt_nouid32, \"nouid32\"},\n\t{Opt_debug, \"debug\"},\n\t{Opt_oldalloc, \"oldalloc\"},\n\t{Opt_orlov, \"orlov\"},\n\t{Opt_nobh, \"nobh\"},\n\t{Opt_user_xattr, \"user_xattr\"},\n\t{Opt_nouser_xattr, \"nouser_xattr\"},\n\t{Opt_acl, \"acl\"},\n\t{Opt_noacl, \"noacl\"},\n\t{Opt_xip, \"xip\"},\n\t{Opt_dax, \"dax\"},\n\t{Opt_grpquota, \"grpquota\"},\n\t{Opt_ignore, \"noquota\"},\n\t{Opt_quota, \"quota\"},\n\t{Opt_usrquota, \"usrquota\"},\n\t{Opt_reservation, \"reservation\"},\n\t{Opt_noreservation, \"noreservation\"},\n\t{Opt_err, NULL}\n};\n\nstatic int parse_options(char *options, struct super_block *sb,\n\t\t\t struct ext2_mount_options *opts)\n{\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\tkuid_t uid;\n\tkgid_t gid;\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep (&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_bsd_df:\n\t\t\tclear_opt (opts->s_mount_opt, MINIX_DF);\n\t\t\tbreak;\n\t\tcase Opt_minix_df:\n\t\t\tset_opt (opts->s_mount_opt, MINIX_DF);\n\t\t\tbreak;\n\t\tcase Opt_grpid:\n\t\t\tset_opt (opts->s_mount_opt, GRPID);\n\t\t\tbreak;\n\t\tcase Opt_nogrpid:\n\t\t\tclear_opt (opts->s_mount_opt, GRPID);\n\t\t\tbreak;\n\t\tcase Opt_resuid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tuid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(uid)) {\n\t\t\t\text2_msg(sb, KERN_ERR, \"Invalid uid value %d\", option);\n\t\t\t\treturn 0;\n\n\t\t\t}\n\t\t\topts->s_resuid = uid;\n\t\t\tbreak;\n\t\tcase Opt_resgid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tgid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(gid)) {\n\t\t\t\text2_msg(sb, KERN_ERR, \"Invalid gid value %d\", option);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\topts->s_resgid = gid;\n\t\t\tbreak;\n\t\tcase Opt_sb:\n\t\t\t \n\t\t\t \n\t\t\tbreak;\n\t\tcase Opt_err_panic:\n\t\t\tclear_opt (opts->s_mount_opt, ERRORS_CONT);\n\t\t\tclear_opt (opts->s_mount_opt, ERRORS_RO);\n\t\t\tset_opt (opts->s_mount_opt, ERRORS_PANIC);\n\t\t\tbreak;\n\t\tcase Opt_err_ro:\n\t\t\tclear_opt (opts->s_mount_opt, ERRORS_CONT);\n\t\t\tclear_opt (opts->s_mount_opt, ERRORS_PANIC);\n\t\t\tset_opt (opts->s_mount_opt, ERRORS_RO);\n\t\t\tbreak;\n\t\tcase Opt_err_cont:\n\t\t\tclear_opt (opts->s_mount_opt, ERRORS_RO);\n\t\t\tclear_opt (opts->s_mount_opt, ERRORS_PANIC);\n\t\t\tset_opt (opts->s_mount_opt, ERRORS_CONT);\n\t\t\tbreak;\n\t\tcase Opt_nouid32:\n\t\t\tset_opt (opts->s_mount_opt, NO_UID32);\n\t\t\tbreak;\n\t\tcase Opt_debug:\n\t\t\tset_opt (opts->s_mount_opt, DEBUG);\n\t\t\tbreak;\n\t\tcase Opt_oldalloc:\n\t\t\tset_opt (opts->s_mount_opt, OLDALLOC);\n\t\t\tbreak;\n\t\tcase Opt_orlov:\n\t\t\tclear_opt (opts->s_mount_opt, OLDALLOC);\n\t\t\tbreak;\n\t\tcase Opt_nobh:\n\t\t\text2_msg(sb, KERN_INFO,\n\t\t\t\t\"nobh option not supported\");\n\t\t\tbreak;\n#ifdef CONFIG_EXT2_FS_XATTR\n\t\tcase Opt_user_xattr:\n\t\t\tset_opt (opts->s_mount_opt, XATTR_USER);\n\t\t\tbreak;\n\t\tcase Opt_nouser_xattr:\n\t\t\tclear_opt (opts->s_mount_opt, XATTR_USER);\n\t\t\tbreak;\n#else\n\t\tcase Opt_user_xattr:\n\t\tcase Opt_nouser_xattr:\n\t\t\text2_msg(sb, KERN_INFO, \"(no)user_xattr options\"\n\t\t\t\t\"not supported\");\n\t\t\tbreak;\n#endif\n#ifdef CONFIG_EXT2_FS_POSIX_ACL\n\t\tcase Opt_acl:\n\t\t\tset_opt(opts->s_mount_opt, POSIX_ACL);\n\t\t\tbreak;\n\t\tcase Opt_noacl:\n\t\t\tclear_opt(opts->s_mount_opt, POSIX_ACL);\n\t\t\tbreak;\n#else\n\t\tcase Opt_acl:\n\t\tcase Opt_noacl:\n\t\t\text2_msg(sb, KERN_INFO,\n\t\t\t\t\"(no)acl options not supported\");\n\t\t\tbreak;\n#endif\n\t\tcase Opt_xip:\n\t\t\text2_msg(sb, KERN_INFO, \"use dax instead of xip\");\n\t\t\tset_opt(opts->s_mount_opt, XIP);\n\t\t\tfallthrough;\n\t\tcase Opt_dax:\n#ifdef CONFIG_FS_DAX\n\t\t\text2_msg(sb, KERN_WARNING,\n\t\t\"DAX enabled. Warning: EXPERIMENTAL, use at your own risk\");\n\t\t\tset_opt(opts->s_mount_opt, DAX);\n#else\n\t\t\text2_msg(sb, KERN_INFO, \"dax option not supported\");\n#endif\n\t\t\tbreak;\n\n#if defined(CONFIG_QUOTA)\n\t\tcase Opt_quota:\n\t\tcase Opt_usrquota:\n\t\t\tset_opt(opts->s_mount_opt, USRQUOTA);\n\t\t\tbreak;\n\n\t\tcase Opt_grpquota:\n\t\t\tset_opt(opts->s_mount_opt, GRPQUOTA);\n\t\t\tbreak;\n#else\n\t\tcase Opt_quota:\n\t\tcase Opt_usrquota:\n\t\tcase Opt_grpquota:\n\t\t\text2_msg(sb, KERN_INFO,\n\t\t\t\t\"quota operations not supported\");\n\t\t\tbreak;\n#endif\n\n\t\tcase Opt_reservation:\n\t\t\tset_opt(opts->s_mount_opt, RESERVATION);\n\t\t\text2_msg(sb, KERN_INFO, \"reservations ON\");\n\t\t\tbreak;\n\t\tcase Opt_noreservation:\n\t\t\tclear_opt(opts->s_mount_opt, RESERVATION);\n\t\t\text2_msg(sb, KERN_INFO, \"reservations OFF\");\n\t\t\tbreak;\n\t\tcase Opt_ignore:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic int ext2_setup_super (struct super_block * sb,\n\t\t\t      struct ext2_super_block * es,\n\t\t\t      int read_only)\n{\n\tint res = 0;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\n\tif (le32_to_cpu(es->s_rev_level) > EXT2_MAX_SUPP_REV) {\n\t\text2_msg(sb, KERN_ERR,\n\t\t\t\"error: revision level too high, \"\n\t\t\t\"forcing read-only mode\");\n\t\tres = SB_RDONLY;\n\t}\n\tif (read_only)\n\t\treturn res;\n\tif (!(sbi->s_mount_state & EXT2_VALID_FS))\n\t\text2_msg(sb, KERN_WARNING,\n\t\t\t\"warning: mounting unchecked fs, \"\n\t\t\t\"running e2fsck is recommended\");\n\telse if ((sbi->s_mount_state & EXT2_ERROR_FS))\n\t\text2_msg(sb, KERN_WARNING,\n\t\t\t\"warning: mounting fs with errors, \"\n\t\t\t\"running e2fsck is recommended\");\n\telse if ((__s16) le16_to_cpu(es->s_max_mnt_count) >= 0 &&\n\t\t le16_to_cpu(es->s_mnt_count) >=\n\t\t (unsigned short) (__s16) le16_to_cpu(es->s_max_mnt_count))\n\t\text2_msg(sb, KERN_WARNING,\n\t\t\t\"warning: maximal mount count reached, \"\n\t\t\t\"running e2fsck is recommended\");\n\telse if (le32_to_cpu(es->s_checkinterval) &&\n\t\t(le32_to_cpu(es->s_lastcheck) +\n\t\t\tle32_to_cpu(es->s_checkinterval) <=\n\t\t\tktime_get_real_seconds()))\n\t\text2_msg(sb, KERN_WARNING,\n\t\t\t\"warning: checktime reached, \"\n\t\t\t\"running e2fsck is recommended\");\n\tif (!le16_to_cpu(es->s_max_mnt_count))\n\t\tes->s_max_mnt_count = cpu_to_le16(EXT2_DFL_MAX_MNT_COUNT);\n\tle16_add_cpu(&es->s_mnt_count, 1);\n\tif (test_opt (sb, DEBUG))\n\t\text2_msg(sb, KERN_INFO, \"%s, %s, bs=%lu, gc=%lu, \"\n\t\t\t\"bpg=%lu, ipg=%lu, mo=%04lx]\",\n\t\t\tEXT2FS_VERSION, EXT2FS_DATE, sb->s_blocksize,\n\t\t\tsbi->s_groups_count,\n\t\t\tEXT2_BLOCKS_PER_GROUP(sb),\n\t\t\tEXT2_INODES_PER_GROUP(sb),\n\t\t\tsbi->s_mount_opt);\n\treturn res;\n}\n\nstatic int ext2_check_descriptors(struct super_block *sb)\n{\n\tint i;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\n\text2_debug (\"Checking group descriptors\");\n\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\tstruct ext2_group_desc *gdp = ext2_get_group_desc(sb, i, NULL);\n\t\text2_fsblk_t first_block = ext2_group_first_block_no(sb, i);\n\t\text2_fsblk_t last_block = ext2_group_last_block_no(sb, i);\n\n\t\tif (le32_to_cpu(gdp->bg_block_bitmap) < first_block ||\n\t\t    le32_to_cpu(gdp->bg_block_bitmap) > last_block)\n\t\t{\n\t\t\text2_error (sb, \"ext2_check_descriptors\",\n\t\t\t\t    \"Block bitmap for group %d\"\n\t\t\t\t    \" not in group (block %lu)!\",\n\t\t\t\t    i, (unsigned long) le32_to_cpu(gdp->bg_block_bitmap));\n\t\t\treturn 0;\n\t\t}\n\t\tif (le32_to_cpu(gdp->bg_inode_bitmap) < first_block ||\n\t\t    le32_to_cpu(gdp->bg_inode_bitmap) > last_block)\n\t\t{\n\t\t\text2_error (sb, \"ext2_check_descriptors\",\n\t\t\t\t    \"Inode bitmap for group %d\"\n\t\t\t\t    \" not in group (block %lu)!\",\n\t\t\t\t    i, (unsigned long) le32_to_cpu(gdp->bg_inode_bitmap));\n\t\t\treturn 0;\n\t\t}\n\t\tif (le32_to_cpu(gdp->bg_inode_table) < first_block ||\n\t\t    le32_to_cpu(gdp->bg_inode_table) + sbi->s_itb_per_group - 1 >\n\t\t    last_block)\n\t\t{\n\t\t\text2_error (sb, \"ext2_check_descriptors\",\n\t\t\t\t    \"Inode table for group %d\"\n\t\t\t\t    \" not in group (block %lu)!\",\n\t\t\t\t    i, (unsigned long) le32_to_cpu(gdp->bg_inode_table));\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\n \nstatic loff_t ext2_max_size(int bits)\n{\n\tloff_t res = EXT2_NDIR_BLOCKS;\n\tint meta_blocks;\n\tunsigned int upper_limit;\n\tunsigned int ppb = 1 << (bits-2);\n\n\t \n\tupper_limit = (1LL << 32) - 1;\n\n\t \n\tupper_limit >>= (bits - 9);\n\n\t \n\tres += 1LL << (bits-2);\n\tres += 1LL << (2*(bits-2));\n\tres += 1LL << (3*(bits-2));\n\t \n\tmeta_blocks = 1;\n\tmeta_blocks += 1 + ppb;\n\tmeta_blocks += 1 + ppb + ppb * ppb;\n\t \n\tif (res + meta_blocks <= upper_limit)\n\t\tgoto check_lfs;\n\n\tres = upper_limit;\n\t \n\tupper_limit -= EXT2_NDIR_BLOCKS;\n\t \n\tmeta_blocks = 1;\n\tupper_limit -= ppb;\n\t \n\tif (upper_limit < ppb * ppb) {\n\t\tmeta_blocks += 1 + DIV_ROUND_UP(upper_limit, ppb);\n\t\tres -= meta_blocks;\n\t\tgoto check_lfs;\n\t}\n\tmeta_blocks += 1 + ppb;\n\tupper_limit -= ppb * ppb;\n\t \n\tmeta_blocks += 1 + DIV_ROUND_UP(upper_limit, ppb) +\n\t\tDIV_ROUND_UP(upper_limit, ppb*ppb);\n\tres -= meta_blocks;\ncheck_lfs:\n\tres <<= bits;\n\tif (res > MAX_LFS_FILESIZE)\n\t\tres = MAX_LFS_FILESIZE;\n\n\treturn res;\n}\n\nstatic unsigned long descriptor_loc(struct super_block *sb,\n\t\t\t\t    unsigned long logic_sb_block,\n\t\t\t\t    int nr)\n{\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tunsigned long bg, first_meta_bg;\n\t\n\tfirst_meta_bg = le32_to_cpu(sbi->s_es->s_first_meta_bg);\n\n\tif (!EXT2_HAS_INCOMPAT_FEATURE(sb, EXT2_FEATURE_INCOMPAT_META_BG) ||\n\t    nr < first_meta_bg)\n\t\treturn (logic_sb_block + nr + 1);\n\tbg = sbi->s_desc_per_block * nr;\n\n\treturn ext2_group_first_block_no(sb, bg) + ext2_bg_has_super(sb, bg);\n}\n\nstatic int ext2_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct buffer_head * bh;\n\tstruct ext2_sb_info * sbi;\n\tstruct ext2_super_block * es;\n\tstruct inode *root;\n\tunsigned long block;\n\tunsigned long sb_block = get_sb_block(&data);\n\tunsigned long logic_sb_block;\n\tunsigned long offset = 0;\n\tunsigned long def_mount_opts;\n\tlong ret = -ENOMEM;\n\tint blocksize = BLOCK_SIZE;\n\tint db_count;\n\tint i, j;\n\t__le32 features;\n\tint err;\n\tstruct ext2_mount_options opts;\n\n\tsbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\n\tsbi->s_blockgroup_lock =\n\t\tkzalloc(sizeof(struct blockgroup_lock), GFP_KERNEL);\n\tif (!sbi->s_blockgroup_lock) {\n\t\tkfree(sbi);\n\t\treturn -ENOMEM;\n\t}\n\tsb->s_fs_info = sbi;\n\tsbi->s_sb_block = sb_block;\n\tsbi->s_daxdev = fs_dax_get_by_bdev(sb->s_bdev, &sbi->s_dax_part_off,\n\t\t\t\t\t   NULL, NULL);\n\n\tspin_lock_init(&sbi->s_lock);\n\tret = -EINVAL;\n\n\t \n\tblocksize = sb_min_blocksize(sb, BLOCK_SIZE);\n\tif (!blocksize) {\n\t\text2_msg(sb, KERN_ERR, \"error: unable to set blocksize\");\n\t\tgoto failed_sbi;\n\t}\n\n\t \n\tif (blocksize != BLOCK_SIZE) {\n\t\tlogic_sb_block = (sb_block*BLOCK_SIZE) / blocksize;\n\t\toffset = (sb_block*BLOCK_SIZE) % blocksize;\n\t} else {\n\t\tlogic_sb_block = sb_block;\n\t}\n\n\tif (!(bh = sb_bread(sb, logic_sb_block))) {\n\t\text2_msg(sb, KERN_ERR, \"error: unable to read superblock\");\n\t\tgoto failed_sbi;\n\t}\n\t \n\tes = (struct ext2_super_block *) (((char *)bh->b_data) + offset);\n\tsbi->s_es = es;\n\tsb->s_magic = le16_to_cpu(es->s_magic);\n\n\tif (sb->s_magic != EXT2_SUPER_MAGIC)\n\t\tgoto cantfind_ext2;\n\n\topts.s_mount_opt = 0;\n\t \n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\tif (def_mount_opts & EXT2_DEFM_DEBUG)\n\t\tset_opt(opts.s_mount_opt, DEBUG);\n\tif (def_mount_opts & EXT2_DEFM_BSDGROUPS)\n\t\tset_opt(opts.s_mount_opt, GRPID);\n\tif (def_mount_opts & EXT2_DEFM_UID16)\n\t\tset_opt(opts.s_mount_opt, NO_UID32);\n#ifdef CONFIG_EXT2_FS_XATTR\n\tif (def_mount_opts & EXT2_DEFM_XATTR_USER)\n\t\tset_opt(opts.s_mount_opt, XATTR_USER);\n#endif\n#ifdef CONFIG_EXT2_FS_POSIX_ACL\n\tif (def_mount_opts & EXT2_DEFM_ACL)\n\t\tset_opt(opts.s_mount_opt, POSIX_ACL);\n#endif\n\t\n\tif (le16_to_cpu(sbi->s_es->s_errors) == EXT2_ERRORS_PANIC)\n\t\tset_opt(opts.s_mount_opt, ERRORS_PANIC);\n\telse if (le16_to_cpu(sbi->s_es->s_errors) == EXT2_ERRORS_CONTINUE)\n\t\tset_opt(opts.s_mount_opt, ERRORS_CONT);\n\telse\n\t\tset_opt(opts.s_mount_opt, ERRORS_RO);\n\n\topts.s_resuid = make_kuid(&init_user_ns, le16_to_cpu(es->s_def_resuid));\n\topts.s_resgid = make_kgid(&init_user_ns, le16_to_cpu(es->s_def_resgid));\n\t\n\tset_opt(opts.s_mount_opt, RESERVATION);\n\n\tif (!parse_options((char *) data, sb, &opts))\n\t\tgoto failed_mount;\n\n\tsbi->s_mount_opt = opts.s_mount_opt;\n\tsbi->s_resuid = opts.s_resuid;\n\tsbi->s_resgid = opts.s_resgid;\n\n\tsb->s_flags = (sb->s_flags & ~SB_POSIXACL) |\n\t\t(test_opt(sb, POSIX_ACL) ? SB_POSIXACL : 0);\n\tsb->s_iflags |= SB_I_CGROUPWB;\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT2_GOOD_OLD_REV &&\n\t    (EXT2_HAS_COMPAT_FEATURE(sb, ~0U) ||\n\t     EXT2_HAS_RO_COMPAT_FEATURE(sb, ~0U) ||\n\t     EXT2_HAS_INCOMPAT_FEATURE(sb, ~0U)))\n\t\text2_msg(sb, KERN_WARNING,\n\t\t\t\"warning: feature flags set on rev 0 fs, \"\n\t\t\t\"running e2fsck is recommended\");\n\t \n\tfeatures = EXT2_HAS_INCOMPAT_FEATURE(sb, ~EXT2_FEATURE_INCOMPAT_SUPP);\n\tif (features) {\n\t\text2_msg(sb, KERN_ERR,\t\"error: couldn't mount because of \"\n\t\t       \"unsupported optional features (%x)\",\n\t\t\tle32_to_cpu(features));\n\t\tgoto failed_mount;\n\t}\n\tif (!sb_rdonly(sb) && (features = EXT2_HAS_RO_COMPAT_FEATURE(sb, ~EXT2_FEATURE_RO_COMPAT_SUPP))){\n\t\text2_msg(sb, KERN_ERR, \"error: couldn't mount RDWR because of \"\n\t\t       \"unsupported optional features (%x)\",\n\t\t       le32_to_cpu(features));\n\t\tgoto failed_mount;\n\t}\n\n\tif (le32_to_cpu(es->s_log_block_size) >\n\t    (EXT2_MAX_BLOCK_LOG_SIZE - BLOCK_SIZE_BITS)) {\n\t\text2_msg(sb, KERN_ERR,\n\t\t\t \"Invalid log block size: %u\",\n\t\t\t le32_to_cpu(es->s_log_block_size));\n\t\tgoto failed_mount;\n\t}\n\tblocksize = BLOCK_SIZE << le32_to_cpu(sbi->s_es->s_log_block_size);\n\n\tif (test_opt(sb, DAX)) {\n\t\tif (!sbi->s_daxdev) {\n\t\t\text2_msg(sb, KERN_ERR,\n\t\t\t\t\"DAX unsupported by block device. Turning off DAX.\");\n\t\t\tclear_opt(sbi->s_mount_opt, DAX);\n\t\t} else if (blocksize != PAGE_SIZE) {\n\t\t\text2_msg(sb, KERN_ERR, \"unsupported blocksize for DAX\\n\");\n\t\t\tclear_opt(sbi->s_mount_opt, DAX);\n\t\t}\n\t}\n\n\t \n\tif (sb->s_blocksize != blocksize) {\n\t\tbrelse(bh);\n\n\t\tif (!sb_set_blocksize(sb, blocksize)) {\n\t\t\text2_msg(sb, KERN_ERR,\n\t\t\t\t\"error: bad blocksize %d\", blocksize);\n\t\t\tgoto failed_sbi;\n\t\t}\n\n\t\tlogic_sb_block = (sb_block*BLOCK_SIZE) / blocksize;\n\t\toffset = (sb_block*BLOCK_SIZE) % blocksize;\n\t\tbh = sb_bread(sb, logic_sb_block);\n\t\tif(!bh) {\n\t\t\text2_msg(sb, KERN_ERR, \"error: couldn't read\"\n\t\t\t\t\"superblock on 2nd try\");\n\t\t\tgoto failed_sbi;\n\t\t}\n\t\tes = (struct ext2_super_block *) (((char *)bh->b_data) + offset);\n\t\tsbi->s_es = es;\n\t\tif (es->s_magic != cpu_to_le16(EXT2_SUPER_MAGIC)) {\n\t\t\text2_msg(sb, KERN_ERR, \"error: magic mismatch\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tsb->s_maxbytes = ext2_max_size(sb->s_blocksize_bits);\n\tsb->s_max_links = EXT2_LINK_MAX;\n\tsb->s_time_min = S32_MIN;\n\tsb->s_time_max = S32_MAX;\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT2_GOOD_OLD_REV) {\n\t\tsbi->s_inode_size = EXT2_GOOD_OLD_INODE_SIZE;\n\t\tsbi->s_first_ino = EXT2_GOOD_OLD_FIRST_INO;\n\t} else {\n\t\tsbi->s_inode_size = le16_to_cpu(es->s_inode_size);\n\t\tsbi->s_first_ino = le32_to_cpu(es->s_first_ino);\n\t\tif ((sbi->s_inode_size < EXT2_GOOD_OLD_INODE_SIZE) ||\n\t\t    !is_power_of_2(sbi->s_inode_size) ||\n\t\t    (sbi->s_inode_size > blocksize)) {\n\t\t\text2_msg(sb, KERN_ERR,\n\t\t\t\t\"error: unsupported inode size: %d\",\n\t\t\t\tsbi->s_inode_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tsbi->s_blocks_per_group = le32_to_cpu(es->s_blocks_per_group);\n\tsbi->s_inodes_per_group = le32_to_cpu(es->s_inodes_per_group);\n\n\tsbi->s_inodes_per_block = sb->s_blocksize / EXT2_INODE_SIZE(sb);\n\tif (sbi->s_inodes_per_block == 0 || sbi->s_inodes_per_group == 0)\n\t\tgoto cantfind_ext2;\n\tsbi->s_itb_per_group = sbi->s_inodes_per_group /\n\t\t\t\t\tsbi->s_inodes_per_block;\n\tsbi->s_desc_per_block = sb->s_blocksize /\n\t\t\t\t\tsizeof (struct ext2_group_desc);\n\tsbi->s_sbh = bh;\n\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\tsbi->s_addr_per_block_bits =\n\t\tilog2 (EXT2_ADDR_PER_BLOCK(sb));\n\tsbi->s_desc_per_block_bits =\n\t\tilog2 (EXT2_DESC_PER_BLOCK(sb));\n\n\tif (sb->s_magic != EXT2_SUPER_MAGIC)\n\t\tgoto cantfind_ext2;\n\n\tif (sb->s_blocksize != bh->b_size) {\n\t\tif (!silent)\n\t\t\text2_msg(sb, KERN_ERR, \"error: unsupported blocksize\");\n\t\tgoto failed_mount;\n\t}\n\n\tif (es->s_log_frag_size != es->s_log_block_size) {\n\t\text2_msg(sb, KERN_ERR,\n\t\t\t\"error: fragsize log %u != blocksize log %u\",\n\t\t\tle32_to_cpu(es->s_log_frag_size), sb->s_blocksize_bits);\n\t\tgoto failed_mount;\n\t}\n\n\tif (sbi->s_blocks_per_group > sb->s_blocksize * 8) {\n\t\text2_msg(sb, KERN_ERR,\n\t\t\t\"error: #blocks per group too big: %lu\",\n\t\t\tsbi->s_blocks_per_group);\n\t\tgoto failed_mount;\n\t}\n\t \n\tif (sbi->s_blocks_per_group <= sbi->s_itb_per_group + 3) {\n\t\text2_msg(sb, KERN_ERR,\n\t\t\t\"error: #blocks per group smaller than metadata size: %lu <= %lu\",\n\t\t\tsbi->s_blocks_per_group, sbi->s_inodes_per_group + 3);\n\t\tgoto failed_mount;\n\t}\n\tif (sbi->s_inodes_per_group < sbi->s_inodes_per_block ||\n\t    sbi->s_inodes_per_group > sb->s_blocksize * 8) {\n\t\text2_msg(sb, KERN_ERR,\n\t\t\t\"error: invalid #inodes per group: %lu\",\n\t\t\tsbi->s_inodes_per_group);\n\t\tgoto failed_mount;\n\t}\n\tif (sb_bdev_nr_blocks(sb) < le32_to_cpu(es->s_blocks_count)) {\n\t\text2_msg(sb, KERN_ERR,\n\t\t\t \"bad geometry: block count %u exceeds size of device (%u blocks)\",\n\t\t\t le32_to_cpu(es->s_blocks_count),\n\t\t\t (unsigned)sb_bdev_nr_blocks(sb));\n\t\tgoto failed_mount;\n\t}\n\n\tsbi->s_groups_count = ((le32_to_cpu(es->s_blocks_count) -\n\t\t\t\tle32_to_cpu(es->s_first_data_block) - 1)\n\t\t\t\t\t/ EXT2_BLOCKS_PER_GROUP(sb)) + 1;\n\tif ((u64)sbi->s_groups_count * sbi->s_inodes_per_group !=\n\t    le32_to_cpu(es->s_inodes_count)) {\n\t\text2_msg(sb, KERN_ERR, \"error: invalid #inodes: %u vs computed %llu\",\n\t\t\t le32_to_cpu(es->s_inodes_count),\n\t\t\t (u64)sbi->s_groups_count * sbi->s_inodes_per_group);\n\t\tgoto failed_mount;\n\t}\n\tdb_count = (sbi->s_groups_count + EXT2_DESC_PER_BLOCK(sb) - 1) /\n\t\t   EXT2_DESC_PER_BLOCK(sb);\n\tsbi->s_group_desc = kvmalloc_array(db_count,\n\t\t\t\t\t   sizeof(struct buffer_head *),\n\t\t\t\t\t   GFP_KERNEL);\n\tif (sbi->s_group_desc == NULL) {\n\t\tret = -ENOMEM;\n\t\text2_msg(sb, KERN_ERR, \"error: not enough memory\");\n\t\tgoto failed_mount;\n\t}\n\tbgl_lock_init(sbi->s_blockgroup_lock);\n\tsbi->s_debts = kcalloc(sbi->s_groups_count, sizeof(*sbi->s_debts), GFP_KERNEL);\n\tif (!sbi->s_debts) {\n\t\tret = -ENOMEM;\n\t\text2_msg(sb, KERN_ERR, \"error: not enough memory\");\n\t\tgoto failed_mount_group_desc;\n\t}\n\tfor (i = 0; i < db_count; i++) {\n\t\tblock = descriptor_loc(sb, logic_sb_block, i);\n\t\tsbi->s_group_desc[i] = sb_bread(sb, block);\n\t\tif (!sbi->s_group_desc[i]) {\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tbrelse (sbi->s_group_desc[j]);\n\t\t\text2_msg(sb, KERN_ERR,\n\t\t\t\t\"error: unable to read group descriptors\");\n\t\t\tgoto failed_mount_group_desc;\n\t\t}\n\t}\n\tif (!ext2_check_descriptors (sb)) {\n\t\text2_msg(sb, KERN_ERR, \"group descriptors corrupted\");\n\t\tgoto failed_mount2;\n\t}\n\tsbi->s_gdb_count = db_count;\n\tget_random_bytes(&sbi->s_next_generation, sizeof(u32));\n\tspin_lock_init(&sbi->s_next_gen_lock);\n\n\t \n\tspin_lock_init(&sbi->s_rsv_window_lock);\n\tsbi->s_rsv_window_root = RB_ROOT;\n\t \n\tsbi->s_rsv_window_head.rsv_start = EXT2_RESERVE_WINDOW_NOT_ALLOCATED;\n\tsbi->s_rsv_window_head.rsv_end = EXT2_RESERVE_WINDOW_NOT_ALLOCATED;\n\tsbi->s_rsv_window_head.rsv_alloc_hit = 0;\n\tsbi->s_rsv_window_head.rsv_goal_size = 0;\n\text2_rsv_window_add(sb, &sbi->s_rsv_window_head);\n\n\terr = percpu_counter_init(&sbi->s_freeblocks_counter,\n\t\t\t\text2_count_free_blocks(sb), GFP_KERNEL);\n\tif (!err) {\n\t\terr = percpu_counter_init(&sbi->s_freeinodes_counter,\n\t\t\t\text2_count_free_inodes(sb), GFP_KERNEL);\n\t}\n\tif (!err) {\n\t\terr = percpu_counter_init(&sbi->s_dirs_counter,\n\t\t\t\text2_count_dirs(sb), GFP_KERNEL);\n\t}\n\tif (err) {\n\t\tret = err;\n\t\text2_msg(sb, KERN_ERR, \"error: insufficient memory\");\n\t\tgoto failed_mount3;\n\t}\n\n#ifdef CONFIG_EXT2_FS_XATTR\n\tsbi->s_ea_block_cache = ext2_xattr_create_cache();\n\tif (!sbi->s_ea_block_cache) {\n\t\tret = -ENOMEM;\n\t\text2_msg(sb, KERN_ERR, \"Failed to create ea_block_cache\");\n\t\tgoto failed_mount3;\n\t}\n#endif\n\t \n\tsb->s_op = &ext2_sops;\n\tsb->s_export_op = &ext2_export_ops;\n\tsb->s_xattr = ext2_xattr_handlers;\n\n#ifdef CONFIG_QUOTA\n\tsb->dq_op = &dquot_operations;\n\tsb->s_qcop = &ext2_quotactl_ops;\n\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP;\n#endif\n\n\troot = ext2_iget(sb, EXT2_ROOT_INO);\n\tif (IS_ERR(root)) {\n\t\tret = PTR_ERR(root);\n\t\tgoto failed_mount3;\n\t}\n\tif (!S_ISDIR(root->i_mode) || !root->i_blocks || !root->i_size) {\n\t\tiput(root);\n\t\text2_msg(sb, KERN_ERR, \"error: corrupt root inode, run e2fsck\");\n\t\tgoto failed_mount3;\n\t}\n\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\text2_msg(sb, KERN_ERR, \"error: get root inode failed\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount3;\n\t}\n\tif (EXT2_HAS_COMPAT_FEATURE(sb, EXT3_FEATURE_COMPAT_HAS_JOURNAL))\n\t\text2_msg(sb, KERN_WARNING,\n\t\t\t\"warning: mounting ext3 filesystem as ext2\");\n\tif (ext2_setup_super (sb, es, sb_rdonly(sb)))\n\t\tsb->s_flags |= SB_RDONLY;\n\text2_write_super(sb);\n\treturn 0;\n\ncantfind_ext2:\n\tif (!silent)\n\t\text2_msg(sb, KERN_ERR,\n\t\t\t\"error: can't find an ext2 filesystem on dev %s.\",\n\t\t\tsb->s_id);\n\tgoto failed_mount;\nfailed_mount3:\n\text2_xattr_destroy_cache(sbi->s_ea_block_cache);\n\tpercpu_counter_destroy(&sbi->s_freeblocks_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\nfailed_mount2:\n\tfor (i = 0; i < db_count; i++)\n\t\tbrelse(sbi->s_group_desc[i]);\nfailed_mount_group_desc:\n\tkvfree(sbi->s_group_desc);\n\tkfree(sbi->s_debts);\nfailed_mount:\n\tbrelse(bh);\nfailed_sbi:\n\tfs_put_dax(sbi->s_daxdev, NULL);\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\n\tkfree(sbi);\n\treturn ret;\n}\n\nstatic void ext2_clear_super_error(struct super_block *sb)\n{\n\tstruct buffer_head *sbh = EXT2_SB(sb)->s_sbh;\n\n\tif (buffer_write_io_error(sbh)) {\n\t\t \n\t\text2_msg(sb, KERN_ERR,\n\t\t       \"previous I/O error to superblock detected\");\n\t\tclear_buffer_write_io_error(sbh);\n\t\tset_buffer_uptodate(sbh);\n\t}\n}\n\nvoid ext2_sync_super(struct super_block *sb, struct ext2_super_block *es,\n\t\t     int wait)\n{\n\text2_clear_super_error(sb);\n\tspin_lock(&EXT2_SB(sb)->s_lock);\n\tes->s_free_blocks_count = cpu_to_le32(ext2_count_free_blocks(sb));\n\tes->s_free_inodes_count = cpu_to_le32(ext2_count_free_inodes(sb));\n\tes->s_wtime = cpu_to_le32(ktime_get_real_seconds());\n\t \n\tspin_unlock(&EXT2_SB(sb)->s_lock);\n\tmark_buffer_dirty(EXT2_SB(sb)->s_sbh);\n\tif (wait)\n\t\tsync_dirty_buffer(EXT2_SB(sb)->s_sbh);\n}\n\n \nstatic int ext2_sync_fs(struct super_block *sb, int wait)\n{\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = EXT2_SB(sb)->s_es;\n\n\t \n\tdquot_writeback_dquots(sb, -1);\n\n\tspin_lock(&sbi->s_lock);\n\tif (es->s_state & cpu_to_le16(EXT2_VALID_FS)) {\n\t\text2_debug(\"setting valid to 0\\n\");\n\t\tes->s_state &= cpu_to_le16(~EXT2_VALID_FS);\n\t}\n\tspin_unlock(&sbi->s_lock);\n\text2_sync_super(sb, es, wait);\n\treturn 0;\n}\n\nstatic int ext2_freeze(struct super_block *sb)\n{\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\n\t \n\tif (atomic_long_read(&sb->s_remove_count)) {\n\t\text2_sync_fs(sb, 1);\n\t\treturn 0;\n\t}\n\t \n\tspin_lock(&sbi->s_lock);\n\tsbi->s_es->s_state = cpu_to_le16(sbi->s_mount_state);\n\tspin_unlock(&sbi->s_lock);\n\text2_sync_super(sb, sbi->s_es, 1);\n\n\treturn 0;\n}\n\nstatic int ext2_unfreeze(struct super_block *sb)\n{\n\t \n\text2_write_super(sb);\n\n\treturn 0;\n}\n\nstatic void ext2_write_super(struct super_block *sb)\n{\n\tif (!sb_rdonly(sb))\n\t\text2_sync_fs(sb, 1);\n}\n\nstatic int ext2_remount (struct super_block * sb, int * flags, char * data)\n{\n\tstruct ext2_sb_info * sbi = EXT2_SB(sb);\n\tstruct ext2_super_block * es;\n\tstruct ext2_mount_options new_opts;\n\tint err;\n\n\tsync_filesystem(sb);\n\n\tspin_lock(&sbi->s_lock);\n\tnew_opts.s_mount_opt = sbi->s_mount_opt;\n\tnew_opts.s_resuid = sbi->s_resuid;\n\tnew_opts.s_resgid = sbi->s_resgid;\n\tspin_unlock(&sbi->s_lock);\n\n\tif (!parse_options(data, sb, &new_opts))\n\t\treturn -EINVAL;\n\n\tspin_lock(&sbi->s_lock);\n\tes = sbi->s_es;\n\tif ((sbi->s_mount_opt ^ new_opts.s_mount_opt) & EXT2_MOUNT_DAX) {\n\t\text2_msg(sb, KERN_WARNING, \"warning: refusing change of \"\n\t\t\t \"dax flag with busy inodes while remounting\");\n\t\tnew_opts.s_mount_opt ^= EXT2_MOUNT_DAX;\n\t}\n\tif ((bool)(*flags & SB_RDONLY) == sb_rdonly(sb))\n\t\tgoto out_set;\n\tif (*flags & SB_RDONLY) {\n\t\tif (le16_to_cpu(es->s_state) & EXT2_VALID_FS ||\n\t\t    !(sbi->s_mount_state & EXT2_VALID_FS))\n\t\t\tgoto out_set;\n\n\t\t \n\t\tes->s_state = cpu_to_le16(sbi->s_mount_state);\n\t\tes->s_mtime = cpu_to_le32(ktime_get_real_seconds());\n\t\tspin_unlock(&sbi->s_lock);\n\n\t\terr = dquot_suspend(sb, -1);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\text2_sync_super(sb, es, 1);\n\t} else {\n\t\t__le32 ret = EXT2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t       ~EXT2_FEATURE_RO_COMPAT_SUPP);\n\t\tif (ret) {\n\t\t\tspin_unlock(&sbi->s_lock);\n\t\t\text2_msg(sb, KERN_WARNING,\n\t\t\t\t\"warning: couldn't remount RDWR because of \"\n\t\t\t\t\"unsupported optional features (%x).\",\n\t\t\t\tle32_to_cpu(ret));\n\t\t\treturn -EROFS;\n\t\t}\n\t\t \n\t\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\t\tif (!ext2_setup_super (sb, es, 0))\n\t\t\tsb->s_flags &= ~SB_RDONLY;\n\t\tspin_unlock(&sbi->s_lock);\n\n\t\text2_write_super(sb);\n\n\t\tdquot_resume(sb, -1);\n\t}\n\n\tspin_lock(&sbi->s_lock);\nout_set:\n\tsbi->s_mount_opt = new_opts.s_mount_opt;\n\tsbi->s_resuid = new_opts.s_resuid;\n\tsbi->s_resgid = new_opts.s_resgid;\n\tsb->s_flags = (sb->s_flags & ~SB_POSIXACL) |\n\t\t(test_opt(sb, POSIX_ACL) ? SB_POSIXACL : 0);\n\tspin_unlock(&sbi->s_lock);\n\n\treturn 0;\n}\n\nstatic int ext2_statfs (struct dentry * dentry, struct kstatfs * buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = sbi->s_es;\n\n\tspin_lock(&sbi->s_lock);\n\n\tif (test_opt (sb, MINIX_DF))\n\t\tsbi->s_overhead_last = 0;\n\telse if (sbi->s_blocks_last != le32_to_cpu(es->s_blocks_count)) {\n\t\tunsigned long i, overhead = 0;\n\t\tsmp_rmb();\n\n\t\t \n\n\t\t \n\t\toverhead = le32_to_cpu(es->s_first_data_block);\n\n\t\t \n\t\tfor (i = 0; i < sbi->s_groups_count; i++)\n\t\t\toverhead += ext2_bg_has_super(sb, i) +\n\t\t\t\text2_bg_num_gdb(sb, i);\n\n\t\t \n\t\toverhead += (sbi->s_groups_count *\n\t\t\t     (2 + sbi->s_itb_per_group));\n\t\tsbi->s_overhead_last = overhead;\n\t\tsmp_wmb();\n\t\tsbi->s_blocks_last = le32_to_cpu(es->s_blocks_count);\n\t}\n\n\tbuf->f_type = EXT2_SUPER_MAGIC;\n\tbuf->f_bsize = sb->s_blocksize;\n\tbuf->f_blocks = le32_to_cpu(es->s_blocks_count) - sbi->s_overhead_last;\n\tbuf->f_bfree = ext2_count_free_blocks(sb);\n\tes->s_free_blocks_count = cpu_to_le32(buf->f_bfree);\n\tbuf->f_bavail = buf->f_bfree - le32_to_cpu(es->s_r_blocks_count);\n\tif (buf->f_bfree < le32_to_cpu(es->s_r_blocks_count))\n\t\tbuf->f_bavail = 0;\n\tbuf->f_files = le32_to_cpu(es->s_inodes_count);\n\tbuf->f_ffree = ext2_count_free_inodes(sb);\n\tes->s_free_inodes_count = cpu_to_le32(buf->f_ffree);\n\tbuf->f_namelen = EXT2_NAME_LEN;\n\tbuf->f_fsid = uuid_to_fsid(es->s_uuid);\n\tspin_unlock(&sbi->s_lock);\n\treturn 0;\n}\n\nstatic struct dentry *ext2_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, ext2_fill_super);\n}\n\n#ifdef CONFIG_QUOTA\n\n \nstatic ssize_t ext2_quota_read(struct super_block *sb, int type, char *data,\n\t\t\t       size_t len, loff_t off)\n{\n\tstruct inode *inode = sb_dqopt(sb)->files[type];\n\tsector_t blk = off >> EXT2_BLOCK_SIZE_BITS(sb);\n\tint err = 0;\n\tint offset = off & (sb->s_blocksize - 1);\n\tint tocopy;\n\tsize_t toread;\n\tstruct buffer_head tmp_bh;\n\tstruct buffer_head *bh;\n\tloff_t i_size = i_size_read(inode);\n\n\tif (off > i_size)\n\t\treturn 0;\n\tif (off+len > i_size)\n\t\tlen = i_size-off;\n\ttoread = len;\n\twhile (toread > 0) {\n\t\ttocopy = min_t(size_t, sb->s_blocksize - offset, toread);\n\n\t\ttmp_bh.b_state = 0;\n\t\ttmp_bh.b_size = sb->s_blocksize;\n\t\terr = ext2_get_block(inode, blk, &tmp_bh, 0);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (!buffer_mapped(&tmp_bh))\t \n\t\t\tmemset(data, 0, tocopy);\n\t\telse {\n\t\t\tbh = sb_bread(sb, tmp_bh.b_blocknr);\n\t\t\tif (!bh)\n\t\t\t\treturn -EIO;\n\t\t\tmemcpy(data, bh->b_data+offset, tocopy);\n\t\t\tbrelse(bh);\n\t\t}\n\t\toffset = 0;\n\t\ttoread -= tocopy;\n\t\tdata += tocopy;\n\t\tblk++;\n\t}\n\treturn len;\n}\n\n \nstatic ssize_t ext2_quota_write(struct super_block *sb, int type,\n\t\t\t\tconst char *data, size_t len, loff_t off)\n{\n\tstruct inode *inode = sb_dqopt(sb)->files[type];\n\tsector_t blk = off >> EXT2_BLOCK_SIZE_BITS(sb);\n\tint err = 0;\n\tint offset = off & (sb->s_blocksize - 1);\n\tint tocopy;\n\tsize_t towrite = len;\n\tstruct buffer_head tmp_bh;\n\tstruct buffer_head *bh;\n\n\twhile (towrite > 0) {\n\t\ttocopy = min_t(size_t, sb->s_blocksize - offset, towrite);\n\n\t\ttmp_bh.b_state = 0;\n\t\ttmp_bh.b_size = sb->s_blocksize;\n\t\terr = ext2_get_block(inode, blk, &tmp_bh, 1);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\tif (offset || tocopy != EXT2_BLOCK_SIZE(sb))\n\t\t\tbh = sb_bread(sb, tmp_bh.b_blocknr);\n\t\telse\n\t\t\tbh = sb_getblk(sb, tmp_bh.b_blocknr);\n\t\tif (unlikely(!bh)) {\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tlock_buffer(bh);\n\t\tmemcpy(bh->b_data+offset, data, tocopy);\n\t\tflush_dcache_page(bh->b_page);\n\t\tset_buffer_uptodate(bh);\n\t\tmark_buffer_dirty(bh);\n\t\tunlock_buffer(bh);\n\t\tbrelse(bh);\n\t\toffset = 0;\n\t\ttowrite -= tocopy;\n\t\tdata += tocopy;\n\t\tblk++;\n\t}\nout:\n\tif (len == towrite)\n\t\treturn err;\n\tif (inode->i_size < off+len-towrite)\n\t\ti_size_write(inode, off+len-towrite);\n\tinode_inc_iversion(inode);\n\tinode->i_mtime = inode_set_ctime_current(inode);\n\tmark_inode_dirty(inode);\n\treturn len - towrite;\n}\n\nstatic int ext2_quota_on(struct super_block *sb, int type, int format_id,\n\t\t\t const struct path *path)\n{\n\tint err;\n\tstruct inode *inode;\n\n\terr = dquot_quota_on(sb, type, format_id, path);\n\tif (err)\n\t\treturn err;\n\n\tinode = d_inode(path->dentry);\n\tinode_lock(inode);\n\tEXT2_I(inode)->i_flags |= EXT2_NOATIME_FL | EXT2_IMMUTABLE_FL;\n\tinode_set_flags(inode, S_NOATIME | S_IMMUTABLE,\n\t\t\tS_NOATIME | S_IMMUTABLE);\n\tinode_unlock(inode);\n\tmark_inode_dirty(inode);\n\n\treturn 0;\n}\n\nstatic int ext2_quota_off(struct super_block *sb, int type)\n{\n\tstruct inode *inode = sb_dqopt(sb)->files[type];\n\tint err;\n\n\tif (!inode || !igrab(inode))\n\t\tgoto out;\n\n\terr = dquot_quota_off(sb, type);\n\tif (err)\n\t\tgoto out_put;\n\n\tinode_lock(inode);\n\tEXT2_I(inode)->i_flags &= ~(EXT2_NOATIME_FL | EXT2_IMMUTABLE_FL);\n\tinode_set_flags(inode, 0, S_NOATIME | S_IMMUTABLE);\n\tinode_unlock(inode);\n\tmark_inode_dirty(inode);\nout_put:\n\tiput(inode);\n\treturn err;\nout:\n\treturn dquot_quota_off(sb, type);\n}\n\n#endif\n\nstatic struct file_system_type ext2_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"ext2\",\n\t.mount\t\t= ext2_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\nMODULE_ALIAS_FS(\"ext2\");\n\nstatic int __init init_ext2_fs(void)\n{\n\tint err;\n\n\terr = init_inodecache();\n\tif (err)\n\t\treturn err;\n\terr = register_filesystem(&ext2_fs_type);\n\tif (err)\n\t\tgoto out;\n\treturn 0;\nout:\n\tdestroy_inodecache();\n\treturn err;\n}\n\nstatic void __exit exit_ext2_fs(void)\n{\n\tunregister_filesystem(&ext2_fs_type);\n\tdestroy_inodecache();\n}\n\nMODULE_AUTHOR(\"Remy Card and others\");\nMODULE_DESCRIPTION(\"Second Extended Filesystem\");\nMODULE_LICENSE(\"GPL\");\nmodule_init(init_ext2_fs)\nmodule_exit(exit_ext2_fs)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}