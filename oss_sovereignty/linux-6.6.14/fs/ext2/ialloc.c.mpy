{
  "module_name": "ialloc.c",
  "hash_id": "fe468c41ff87927f24d3ea641a5e45c2480343aba5897291fc340df011374eab",
  "original_prompt": "Ingested from linux-6.6.14/fs/ext2/ialloc.c",
  "human_readable_source": "\n \n\n#include <linux/quotaops.h>\n#include <linux/sched.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include \"ext2.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n\n \n\n \n\n\n \nstatic struct buffer_head *\nread_inode_bitmap(struct super_block * sb, unsigned long block_group)\n{\n\tstruct ext2_group_desc *desc;\n\tstruct buffer_head *bh = NULL;\n\n\tdesc = ext2_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\tgoto error_out;\n\n\tbh = sb_bread(sb, le32_to_cpu(desc->bg_inode_bitmap));\n\tif (!bh)\n\t\text2_error(sb, \"read_inode_bitmap\",\n\t\t\t    \"Cannot read inode bitmap - \"\n\t\t\t    \"block_group = %lu, inode_bitmap = %u\",\n\t\t\t    block_group, le32_to_cpu(desc->bg_inode_bitmap));\nerror_out:\n\treturn bh;\n}\n\nstatic void ext2_release_inode(struct super_block *sb, int group, int dir)\n{\n\tstruct ext2_group_desc * desc;\n\tstruct buffer_head *bh;\n\n\tdesc = ext2_get_group_desc(sb, group, &bh);\n\tif (!desc) {\n\t\text2_error(sb, \"ext2_release_inode\",\n\t\t\t\"can't get descriptor for group %d\", group);\n\t\treturn;\n\t}\n\n\tspin_lock(sb_bgl_lock(EXT2_SB(sb), group));\n\tle16_add_cpu(&desc->bg_free_inodes_count, 1);\n\tif (dir)\n\t\tle16_add_cpu(&desc->bg_used_dirs_count, -1);\n\tspin_unlock(sb_bgl_lock(EXT2_SB(sb), group));\n\tpercpu_counter_inc(&EXT2_SB(sb)->s_freeinodes_counter);\n\tif (dir)\n\t\tpercpu_counter_dec(&EXT2_SB(sb)->s_dirs_counter);\n\tmark_buffer_dirty(bh);\n}\n\n \nvoid ext2_free_inode (struct inode * inode)\n{\n\tstruct super_block * sb = inode->i_sb;\n\tint is_directory;\n\tunsigned long ino;\n\tstruct buffer_head *bitmap_bh;\n\tunsigned long block_group;\n\tunsigned long bit;\n\tstruct ext2_super_block * es;\n\n\tino = inode->i_ino;\n\text2_debug (\"freeing inode %lu\\n\", ino);\n\n\t \n\t \n\tdquot_free_inode(inode);\n\tdquot_drop(inode);\n\n\tes = EXT2_SB(sb)->s_es;\n\tis_directory = S_ISDIR(inode->i_mode);\n\n\tif (ino < EXT2_FIRST_INO(sb) ||\n\t    ino > le32_to_cpu(es->s_inodes_count)) {\n\t\text2_error (sb, \"ext2_free_inode\",\n\t\t\t    \"reserved or nonexistent inode %lu\", ino);\n\t\treturn;\n\t}\n\tblock_group = (ino - 1) / EXT2_INODES_PER_GROUP(sb);\n\tbit = (ino - 1) % EXT2_INODES_PER_GROUP(sb);\n\tbitmap_bh = read_inode_bitmap(sb, block_group);\n\tif (!bitmap_bh)\n\t\treturn;\n\n\t \n\tif (!ext2_clear_bit_atomic(sb_bgl_lock(EXT2_SB(sb), block_group),\n\t\t\t\tbit, (void *) bitmap_bh->b_data))\n\t\text2_error (sb, \"ext2_free_inode\",\n\t\t\t      \"bit already cleared for inode %lu\", ino);\n\telse\n\t\text2_release_inode(sb, block_group, is_directory);\n\tmark_buffer_dirty(bitmap_bh);\n\tif (sb->s_flags & SB_SYNCHRONOUS)\n\t\tsync_dirty_buffer(bitmap_bh);\n\n\tbrelse(bitmap_bh);\n}\n\n \nstatic void ext2_preread_inode(struct inode *inode)\n{\n\tunsigned long block_group;\n\tunsigned long offset;\n\tunsigned long block;\n\tstruct ext2_group_desc * gdp;\n\n\tblock_group = (inode->i_ino - 1) / EXT2_INODES_PER_GROUP(inode->i_sb);\n\tgdp = ext2_get_group_desc(inode->i_sb, block_group, NULL);\n\tif (gdp == NULL)\n\t\treturn;\n\n\t \n\toffset = ((inode->i_ino - 1) % EXT2_INODES_PER_GROUP(inode->i_sb)) *\n\t\t\t\tEXT2_INODE_SIZE(inode->i_sb);\n\tblock = le32_to_cpu(gdp->bg_inode_table) +\n\t\t\t\t(offset >> EXT2_BLOCK_SIZE_BITS(inode->i_sb));\n\tsb_breadahead(inode->i_sb, block);\n}\n\n \nstatic int find_group_dir(struct super_block *sb, struct inode *parent)\n{\n\tint ngroups = EXT2_SB(sb)->s_groups_count;\n\tint avefreei = ext2_count_free_inodes(sb) / ngroups;\n\tstruct ext2_group_desc *desc, *best_desc = NULL;\n\tint group, best_group = -1;\n\n\tfor (group = 0; group < ngroups; group++) {\n\t\tdesc = ext2_get_group_desc (sb, group, NULL);\n\t\tif (!desc || !desc->bg_free_inodes_count)\n\t\t\tcontinue;\n\t\tif (le16_to_cpu(desc->bg_free_inodes_count) < avefreei)\n\t\t\tcontinue;\n\t\tif (!best_desc || \n\t\t    (le16_to_cpu(desc->bg_free_blocks_count) >\n\t\t     le16_to_cpu(best_desc->bg_free_blocks_count))) {\n\t\t\tbest_group = group;\n\t\t\tbest_desc = desc;\n\t\t}\n\t}\n\n\treturn best_group;\n}\n\n  \n\n#define INODE_COST 64\n#define BLOCK_COST 256\n\nstatic int find_group_orlov(struct super_block *sb, struct inode *parent)\n{\n\tint parent_group = EXT2_I(parent)->i_block_group;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = sbi->s_es;\n\tint ngroups = sbi->s_groups_count;\n\tint inodes_per_group = EXT2_INODES_PER_GROUP(sb);\n\tint freei;\n\tint avefreei;\n\tint free_blocks;\n\tint avefreeb;\n\tint blocks_per_dir;\n\tint ndirs;\n\tint max_debt, max_dirs, min_blocks, min_inodes;\n\tint group = -1, i;\n\tstruct ext2_group_desc *desc;\n\n\tfreei = percpu_counter_read_positive(&sbi->s_freeinodes_counter);\n\tavefreei = freei / ngroups;\n\tfree_blocks = percpu_counter_read_positive(&sbi->s_freeblocks_counter);\n\tavefreeb = free_blocks / ngroups;\n\tndirs = percpu_counter_read_positive(&sbi->s_dirs_counter);\n\n\tif ((parent == d_inode(sb->s_root)) ||\n\t    (EXT2_I(parent)->i_flags & EXT2_TOPDIR_FL)) {\n\t\tint best_ndir = inodes_per_group;\n\t\tint best_group = -1;\n\n\t\tparent_group = get_random_u32_below(ngroups);\n\t\tfor (i = 0; i < ngroups; i++) {\n\t\t\tgroup = (parent_group + i) % ngroups;\n\t\t\tdesc = ext2_get_group_desc (sb, group, NULL);\n\t\t\tif (!desc || !desc->bg_free_inodes_count)\n\t\t\t\tcontinue;\n\t\t\tif (le16_to_cpu(desc->bg_used_dirs_count) >= best_ndir)\n\t\t\t\tcontinue;\n\t\t\tif (le16_to_cpu(desc->bg_free_inodes_count) < avefreei)\n\t\t\t\tcontinue;\n\t\t\tif (le16_to_cpu(desc->bg_free_blocks_count) < avefreeb)\n\t\t\t\tcontinue;\n\t\t\tbest_group = group;\n\t\t\tbest_ndir = le16_to_cpu(desc->bg_used_dirs_count);\n\t\t}\n\t\tif (best_group >= 0) {\n\t\t\tgroup = best_group;\n\t\t\tgoto found;\n\t\t}\n\t\tgoto fallback;\n\t}\n\n\tif (ndirs == 0)\n\t\tndirs = 1;\t \n\n\tblocks_per_dir = (le32_to_cpu(es->s_blocks_count)-free_blocks) / ndirs;\n\n\tmax_dirs = ndirs / ngroups + inodes_per_group / 16;\n\tmin_inodes = avefreei - inodes_per_group / 4;\n\tmin_blocks = avefreeb - EXT2_BLOCKS_PER_GROUP(sb) / 4;\n\n\tmax_debt = EXT2_BLOCKS_PER_GROUP(sb) / max(blocks_per_dir, BLOCK_COST);\n\tif (max_debt * INODE_COST > inodes_per_group)\n\t\tmax_debt = inodes_per_group / INODE_COST;\n\tif (max_debt > 255)\n\t\tmax_debt = 255;\n\tif (max_debt == 0)\n\t\tmax_debt = 1;\n\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgroup = (parent_group + i) % ngroups;\n\t\tdesc = ext2_get_group_desc (sb, group, NULL);\n\t\tif (!desc || !desc->bg_free_inodes_count)\n\t\t\tcontinue;\n\t\tif (sbi->s_debts[group] >= max_debt)\n\t\t\tcontinue;\n\t\tif (le16_to_cpu(desc->bg_used_dirs_count) >= max_dirs)\n\t\t\tcontinue;\n\t\tif (le16_to_cpu(desc->bg_free_inodes_count) < min_inodes)\n\t\t\tcontinue;\n\t\tif (le16_to_cpu(desc->bg_free_blocks_count) < min_blocks)\n\t\t\tcontinue;\n\t\tgoto found;\n\t}\n\nfallback:\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgroup = (parent_group + i) % ngroups;\n\t\tdesc = ext2_get_group_desc (sb, group, NULL);\n\t\tif (!desc || !desc->bg_free_inodes_count)\n\t\t\tcontinue;\n\t\tif (le16_to_cpu(desc->bg_free_inodes_count) >= avefreei)\n\t\t\tgoto found;\n\t}\n\n\tif (avefreei) {\n\t\t \n\t\tavefreei = 0;\n\t\tgoto fallback;\n\t}\n\n\treturn -1;\n\nfound:\n\treturn group;\n}\n\nstatic int find_group_other(struct super_block *sb, struct inode *parent)\n{\n\tint parent_group = EXT2_I(parent)->i_block_group;\n\tint ngroups = EXT2_SB(sb)->s_groups_count;\n\tstruct ext2_group_desc *desc;\n\tint group, i;\n\n\t \n\tgroup = parent_group;\n\tdesc = ext2_get_group_desc (sb, group, NULL);\n\tif (desc && le16_to_cpu(desc->bg_free_inodes_count) &&\n\t\t\tle16_to_cpu(desc->bg_free_blocks_count))\n\t\tgoto found;\n\n\t \n\tgroup = (group + parent->i_ino) % ngroups;\n\n\t \n\tfor (i = 1; i < ngroups; i <<= 1) {\n\t\tgroup += i;\n\t\tif (group >= ngroups)\n\t\t\tgroup -= ngroups;\n\t\tdesc = ext2_get_group_desc (sb, group, NULL);\n\t\tif (desc && le16_to_cpu(desc->bg_free_inodes_count) &&\n\t\t\t\tle16_to_cpu(desc->bg_free_blocks_count))\n\t\t\tgoto found;\n\t}\n\n\t \n\tgroup = parent_group;\n\tfor (i = 0; i < ngroups; i++) {\n\t\tif (++group >= ngroups)\n\t\t\tgroup = 0;\n\t\tdesc = ext2_get_group_desc (sb, group, NULL);\n\t\tif (desc && le16_to_cpu(desc->bg_free_inodes_count))\n\t\t\tgoto found;\n\t}\n\n\treturn -1;\n\nfound:\n\treturn group;\n}\n\nstruct inode *ext2_new_inode(struct inode *dir, umode_t mode,\n\t\t\t     const struct qstr *qstr)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head *bh2;\n\tint group, i;\n\tino_t ino = 0;\n\tstruct inode * inode;\n\tstruct ext2_group_desc *gdp;\n\tstruct ext2_super_block *es;\n\tstruct ext2_inode_info *ei;\n\tstruct ext2_sb_info *sbi;\n\tint err;\n\n\tsb = dir->i_sb;\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tei = EXT2_I(inode);\n\tsbi = EXT2_SB(sb);\n\tes = sbi->s_es;\n\tif (S_ISDIR(mode)) {\n\t\tif (test_opt(sb, OLDALLOC))\n\t\t\tgroup = find_group_dir(sb, dir);\n\t\telse\n\t\t\tgroup = find_group_orlov(sb, dir);\n\t} else \n\t\tgroup = find_group_other(sb, dir);\n\n\tif (group == -1) {\n\t\terr = -ENOSPC;\n\t\tgoto fail;\n\t}\n\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\tgdp = ext2_get_group_desc(sb, group, &bh2);\n\t\tif (!gdp) {\n\t\t\tif (++group == sbi->s_groups_count)\n\t\t\t\tgroup = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_inode_bitmap(sb, group);\n\t\tif (!bitmap_bh) {\n\t\t\terr = -EIO;\n\t\t\tgoto fail;\n\t\t}\n\t\tino = 0;\n\nrepeat_in_this_group:\n\t\tino = ext2_find_next_zero_bit((unsigned long *)bitmap_bh->b_data,\n\t\t\t\t\t      EXT2_INODES_PER_GROUP(sb), ino);\n\t\tif (ino >= EXT2_INODES_PER_GROUP(sb)) {\n\t\t\t \n\t\t\tif (++group == sbi->s_groups_count)\n\t\t\t\tgroup = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ext2_set_bit_atomic(sb_bgl_lock(sbi, group),\n\t\t\t\t\t\tino, bitmap_bh->b_data)) {\n\t\t\t \n\t\t\tif (++ino >= EXT2_INODES_PER_GROUP(sb)) {\n\t\t\t\t \n\t\t\t\tif (++group == sbi->s_groups_count)\n\t\t\t\t\tgroup = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t \n\t\t\tgoto repeat_in_this_group;\n\t\t}\n\t\tgoto got;\n\t}\n\n\t \n\tbrelse(bitmap_bh);\n\terr = -ENOSPC;\n\tgoto fail;\ngot:\n\tmark_buffer_dirty(bitmap_bh);\n\tif (sb->s_flags & SB_SYNCHRONOUS)\n\t\tsync_dirty_buffer(bitmap_bh);\n\tbrelse(bitmap_bh);\n\n\tino += group * EXT2_INODES_PER_GROUP(sb) + 1;\n\tif (ino < EXT2_FIRST_INO(sb) || ino > le32_to_cpu(es->s_inodes_count)) {\n\t\text2_error (sb, \"ext2_new_inode\",\n\t\t\t    \"reserved inode or inode > inodes count - \"\n\t\t\t    \"block_group = %d,inode=%lu\", group,\n\t\t\t    (unsigned long) ino);\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\n\tpercpu_counter_dec(&sbi->s_freeinodes_counter);\n\tif (S_ISDIR(mode))\n\t\tpercpu_counter_inc(&sbi->s_dirs_counter);\n\n\tspin_lock(sb_bgl_lock(sbi, group));\n\tle16_add_cpu(&gdp->bg_free_inodes_count, -1);\n\tif (S_ISDIR(mode)) {\n\t\tif (sbi->s_debts[group] < 255)\n\t\t\tsbi->s_debts[group]++;\n\t\tle16_add_cpu(&gdp->bg_used_dirs_count, 1);\n\t} else {\n\t\tif (sbi->s_debts[group])\n\t\t\tsbi->s_debts[group]--;\n\t}\n\tspin_unlock(sb_bgl_lock(sbi, group));\n\n\tmark_buffer_dirty(bh2);\n\tif (test_opt(sb, GRPID)) {\n\t\tinode->i_mode = mode;\n\t\tinode->i_uid = current_fsuid();\n\t\tinode->i_gid = dir->i_gid;\n\t} else\n\t\tinode_init_owner(&nop_mnt_idmap, inode, dir, mode);\n\n\tinode->i_ino = ino;\n\tinode->i_blocks = 0;\n\tinode->i_mtime = inode->i_atime = inode_set_ctime_current(inode);\n\tmemset(ei->i_data, 0, sizeof(ei->i_data));\n\tei->i_flags =\n\t\text2_mask_flags(mode, EXT2_I(dir)->i_flags & EXT2_FL_INHERITED);\n\tei->i_faddr = 0;\n\tei->i_frag_no = 0;\n\tei->i_frag_size = 0;\n\tei->i_file_acl = 0;\n\tei->i_dir_acl = 0;\n\tei->i_dtime = 0;\n\tei->i_block_alloc_info = NULL;\n\tei->i_block_group = group;\n\tei->i_dir_start_lookup = 0;\n\tei->i_state = EXT2_STATE_NEW;\n\text2_set_inode_flags(inode);\n\tspin_lock(&sbi->s_next_gen_lock);\n\tinode->i_generation = sbi->s_next_generation++;\n\tspin_unlock(&sbi->s_next_gen_lock);\n\tif (insert_inode_locked(inode) < 0) {\n\t\text2_error(sb, \"ext2_new_inode\",\n\t\t\t   \"inode number already in use - inode=%lu\",\n\t\t\t   (unsigned long) ino);\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\n\terr = dquot_initialize(inode);\n\tif (err)\n\t\tgoto fail_drop;\n\n\terr = dquot_alloc_inode(inode);\n\tif (err)\n\t\tgoto fail_drop;\n\n\terr = ext2_init_acl(inode, dir);\n\tif (err)\n\t\tgoto fail_free_drop;\n\n\terr = ext2_init_security(inode, dir, qstr);\n\tif (err)\n\t\tgoto fail_free_drop;\n\n\tmark_inode_dirty(inode);\n\text2_debug(\"allocating inode %lu\\n\", inode->i_ino);\n\text2_preread_inode(inode);\n\treturn inode;\n\nfail_free_drop:\n\tdquot_free_inode(inode);\n\nfail_drop:\n\tdquot_drop(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tclear_nlink(inode);\n\tdiscard_new_inode(inode);\n\treturn ERR_PTR(err);\n\nfail:\n\tmake_bad_inode(inode);\n\tiput(inode);\n\treturn ERR_PTR(err);\n}\n\nunsigned long ext2_count_free_inodes (struct super_block * sb)\n{\n\tstruct ext2_group_desc *desc;\n\tunsigned long desc_count = 0;\n\tint i;\t\n\n#ifdef EXT2FS_DEBUG\n\tstruct ext2_super_block *es;\n\tunsigned long bitmap_count = 0;\n\tstruct buffer_head *bitmap_bh = NULL;\n\n\tes = EXT2_SB(sb)->s_es;\n\tfor (i = 0; i < EXT2_SB(sb)->s_groups_count; i++) {\n\t\tunsigned x;\n\n\t\tdesc = ext2_get_group_desc (sb, i, NULL);\n\t\tif (!desc)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(desc->bg_free_inodes_count);\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_inode_bitmap(sb, i);\n\t\tif (!bitmap_bh)\n\t\t\tcontinue;\n\n\t\tx = ext2_count_free(bitmap_bh, EXT2_INODES_PER_GROUP(sb) / 8);\n\t\tprintk(\"group %d: stored = %d, counted = %u\\n\",\n\t\t\ti, le16_to_cpu(desc->bg_free_inodes_count), x);\n\t\tbitmap_count += x;\n\t}\n\tbrelse(bitmap_bh);\n\tprintk(\"ext2_count_free_inodes: stored = %lu, computed = %lu, %lu\\n\",\n\t\t(unsigned long)\n\t\tpercpu_counter_read(&EXT2_SB(sb)->s_freeinodes_counter),\n\t\tdesc_count, bitmap_count);\n\treturn desc_count;\n#else\n\tfor (i = 0; i < EXT2_SB(sb)->s_groups_count; i++) {\n\t\tdesc = ext2_get_group_desc (sb, i, NULL);\n\t\tif (!desc)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(desc->bg_free_inodes_count);\n\t}\n\treturn desc_count;\n#endif\n}\n\n \nunsigned long ext2_count_dirs (struct super_block * sb)\n{\n\tunsigned long count = 0;\n\tint i;\n\n\tfor (i = 0; i < EXT2_SB(sb)->s_groups_count; i++) {\n\t\tstruct ext2_group_desc *gdp = ext2_get_group_desc (sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tcount += le16_to_cpu(gdp->bg_used_dirs_count);\n\t}\n\treturn count;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}