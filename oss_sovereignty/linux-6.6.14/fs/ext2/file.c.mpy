{
  "module_name": "file.c",
  "hash_id": "baaa17100f1b1edff49fbea2ab318d76c105d847ebaec6198dd186690b43e39b",
  "original_prompt": "Ingested from linux-6.6.14/fs/ext2/file.c",
  "human_readable_source": "\n \n\n#include <linux/time.h>\n#include <linux/pagemap.h>\n#include <linux/dax.h>\n#include <linux/quotaops.h>\n#include <linux/iomap.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include \"ext2.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"trace.h\"\n\n#ifdef CONFIG_FS_DAX\nstatic ssize_t ext2_dax_read_iter(struct kiocb *iocb, struct iov_iter *to)\n{\n\tstruct inode *inode = iocb->ki_filp->f_mapping->host;\n\tssize_t ret;\n\n\tif (!iov_iter_count(to))\n\t\treturn 0;  \n\n\tinode_lock_shared(inode);\n\tret = dax_iomap_rw(iocb, to, &ext2_iomap_ops);\n\tinode_unlock_shared(inode);\n\n\tfile_accessed(iocb->ki_filp);\n\treturn ret;\n}\n\nstatic ssize_t ext2_dax_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file->f_mapping->host;\n\tssize_t ret;\n\n\tinode_lock(inode);\n\tret = generic_write_checks(iocb, from);\n\tif (ret <= 0)\n\t\tgoto out_unlock;\n\tret = file_remove_privs(file);\n\tif (ret)\n\t\tgoto out_unlock;\n\tret = file_update_time(file);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = dax_iomap_rw(iocb, from, &ext2_iomap_ops);\n\tif (ret > 0 && iocb->ki_pos > i_size_read(inode)) {\n\t\ti_size_write(inode, iocb->ki_pos);\n\t\tmark_inode_dirty(inode);\n\t}\n\nout_unlock:\n\tinode_unlock(inode);\n\tif (ret > 0)\n\t\tret = generic_write_sync(iocb, ret);\n\treturn ret;\n}\n\n \nstatic vm_fault_t ext2_dax_fault(struct vm_fault *vmf)\n{\n\tstruct inode *inode = file_inode(vmf->vma->vm_file);\n\tvm_fault_t ret;\n\tbool write = (vmf->flags & FAULT_FLAG_WRITE) &&\n\t\t(vmf->vma->vm_flags & VM_SHARED);\n\n\tif (write) {\n\t\tsb_start_pagefault(inode->i_sb);\n\t\tfile_update_time(vmf->vma->vm_file);\n\t}\n\tfilemap_invalidate_lock_shared(inode->i_mapping);\n\n\tret = dax_iomap_fault(vmf, 0, NULL, NULL, &ext2_iomap_ops);\n\n\tfilemap_invalidate_unlock_shared(inode->i_mapping);\n\tif (write)\n\t\tsb_end_pagefault(inode->i_sb);\n\treturn ret;\n}\n\nstatic const struct vm_operations_struct ext2_dax_vm_ops = {\n\t.fault\t\t= ext2_dax_fault,\n\t \n\t.page_mkwrite\t= ext2_dax_fault,\n\t.pfn_mkwrite\t= ext2_dax_fault,\n};\n\nstatic int ext2_file_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tif (!IS_DAX(file_inode(file)))\n\t\treturn generic_file_mmap(file, vma);\n\n\tfile_accessed(file);\n\tvma->vm_ops = &ext2_dax_vm_ops;\n\treturn 0;\n}\n#else\n#define ext2_file_mmap\tgeneric_file_mmap\n#endif\n\n \nstatic int ext2_release_file (struct inode * inode, struct file * filp)\n{\n\tif (filp->f_mode & FMODE_WRITE) {\n\t\tmutex_lock(&EXT2_I(inode)->truncate_mutex);\n\t\text2_discard_reservation(inode);\n\t\tmutex_unlock(&EXT2_I(inode)->truncate_mutex);\n\t}\n\treturn 0;\n}\n\nint ext2_fsync(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tint ret;\n\tstruct super_block *sb = file->f_mapping->host->i_sb;\n\n\tret = generic_buffers_fsync(file, start, end, datasync);\n\tif (ret == -EIO)\n\t\t \n\t\text2_error(sb, __func__,\n\t\t\t   \"detected IO error when writing metadata buffers\");\n\treturn ret;\n}\n\nstatic ssize_t ext2_dio_read_iter(struct kiocb *iocb, struct iov_iter *to)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file->f_mapping->host;\n\tssize_t ret;\n\n\ttrace_ext2_dio_read_begin(iocb, to, 0);\n\tinode_lock_shared(inode);\n\tret = iomap_dio_rw(iocb, to, &ext2_iomap_ops, NULL, 0, NULL, 0);\n\tinode_unlock_shared(inode);\n\ttrace_ext2_dio_read_end(iocb, to, ret);\n\n\treturn ret;\n}\n\nstatic int ext2_dio_write_end_io(struct kiocb *iocb, ssize_t size,\n\t\t\t\t int error, unsigned int flags)\n{\n\tloff_t pos = iocb->ki_pos;\n\tstruct inode *inode = file_inode(iocb->ki_filp);\n\n\tif (error)\n\t\tgoto out;\n\n\t \n\tpos += size;\n\tif (pos > i_size_read(inode)) {\n\t\ti_size_write(inode, pos);\n\t\tmark_inode_dirty(inode);\n\t}\nout:\n\ttrace_ext2_dio_write_endio(iocb, size, error);\n\treturn error;\n}\n\nstatic const struct iomap_dio_ops ext2_dio_write_ops = {\n\t.end_io = ext2_dio_write_end_io,\n};\n\nstatic ssize_t ext2_dio_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file->f_mapping->host;\n\tssize_t ret;\n\tunsigned int flags = 0;\n\tunsigned long blocksize = inode->i_sb->s_blocksize;\n\tloff_t offset = iocb->ki_pos;\n\tloff_t count = iov_iter_count(from);\n\tssize_t status = 0;\n\n\ttrace_ext2_dio_write_begin(iocb, from, 0);\n\tinode_lock(inode);\n\tret = generic_write_checks(iocb, from);\n\tif (ret <= 0)\n\t\tgoto out_unlock;\n\n\tret = kiocb_modified(iocb);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t \n\tif (iocb->ki_pos + iov_iter_count(from) > i_size_read(inode) ||\n\t   (!IS_ALIGNED(iocb->ki_pos | iov_iter_alignment(from), blocksize)))\n\t\tflags |= IOMAP_DIO_FORCE_WAIT;\n\n\tret = iomap_dio_rw(iocb, from, &ext2_iomap_ops, &ext2_dio_write_ops,\n\t\t\t   flags, NULL, 0);\n\n\t \n\tif (ret == -ENOTBLK)\n\t\tret = 0;\n\n\tif (ret < 0 && ret != -EIOCBQUEUED)\n\t\text2_write_failed(inode->i_mapping, offset + count);\n\n\t \n\tif (ret >= 0 && iov_iter_count(from)) {\n\t\tloff_t pos, endbyte;\n\t\tint ret2;\n\n\t\tiocb->ki_flags &= ~IOCB_DIRECT;\n\t\tpos = iocb->ki_pos;\n\t\tstatus = generic_perform_write(iocb, from);\n\t\tif (unlikely(status < 0)) {\n\t\t\tret = status;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tret += status;\n\t\tendbyte = pos + status - 1;\n\t\tret2 = filemap_write_and_wait_range(inode->i_mapping, pos,\n\t\t\t\t\t\t    endbyte);\n\t\tif (!ret2)\n\t\t\tinvalidate_mapping_pages(inode->i_mapping,\n\t\t\t\t\t\t pos >> PAGE_SHIFT,\n\t\t\t\t\t\t endbyte >> PAGE_SHIFT);\n\t\tif (ret > 0)\n\t\t\tgeneric_write_sync(iocb, ret);\n\t}\n\nout_unlock:\n\tinode_unlock(inode);\n\tif (status)\n\t\ttrace_ext2_dio_write_buff_end(iocb, from, status);\n\ttrace_ext2_dio_write_end(iocb, from, ret);\n\treturn ret;\n}\n\nstatic ssize_t ext2_file_read_iter(struct kiocb *iocb, struct iov_iter *to)\n{\n#ifdef CONFIG_FS_DAX\n\tif (IS_DAX(iocb->ki_filp->f_mapping->host))\n\t\treturn ext2_dax_read_iter(iocb, to);\n#endif\n\tif (iocb->ki_flags & IOCB_DIRECT)\n\t\treturn ext2_dio_read_iter(iocb, to);\n\n\treturn generic_file_read_iter(iocb, to);\n}\n\nstatic ssize_t ext2_file_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n#ifdef CONFIG_FS_DAX\n\tif (IS_DAX(iocb->ki_filp->f_mapping->host))\n\t\treturn ext2_dax_write_iter(iocb, from);\n#endif\n\tif (iocb->ki_flags & IOCB_DIRECT)\n\t\treturn ext2_dio_write_iter(iocb, from);\n\n\treturn generic_file_write_iter(iocb, from);\n}\n\nconst struct file_operations ext2_file_operations = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read_iter\t= ext2_file_read_iter,\n\t.write_iter\t= ext2_file_write_iter,\n\t.unlocked_ioctl = ext2_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t= ext2_compat_ioctl,\n#endif\n\t.mmap\t\t= ext2_file_mmap,\n\t.open\t\t= dquot_file_open,\n\t.release\t= ext2_release_file,\n\t.fsync\t\t= ext2_fsync,\n\t.get_unmapped_area = thp_get_unmapped_area,\n\t.splice_read\t= filemap_splice_read,\n\t.splice_write\t= iter_file_splice_write,\n};\n\nconst struct inode_operations ext2_file_inode_operations = {\n\t.listxattr\t= ext2_listxattr,\n\t.getattr\t= ext2_getattr,\n\t.setattr\t= ext2_setattr,\n\t.get_inode_acl\t= ext2_get_acl,\n\t.set_acl\t= ext2_set_acl,\n\t.fiemap\t\t= ext2_fiemap,\n\t.fileattr_get\t= ext2_fileattr_get,\n\t.fileattr_set\t= ext2_fileattr_set,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}