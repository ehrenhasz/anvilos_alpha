{
  "module_name": "internal.h",
  "hash_id": "7a4b70343e942ff8b1f64bb24d599ab9d67af620355fe2bb9bbd57d8504a47e6",
  "original_prompt": "Ingested from linux-6.6.14/fs/netfs/internal.h",
  "human_readable_source": " \n \n\n#include <linux/netfs.h>\n#include <linux/fscache.h>\n#include <trace/events/netfs.h>\n\n#ifdef pr_fmt\n#undef pr_fmt\n#endif\n\n#define pr_fmt(fmt) \"netfs: \" fmt\n\n \nvoid netfs_rreq_unlock_folios(struct netfs_io_request *rreq);\n\n \nint netfs_begin_read(struct netfs_io_request *rreq, bool sync);\n\n \nextern unsigned int netfs_debug;\n\n \nstruct netfs_io_request *netfs_alloc_request(struct address_space *mapping,\n\t\t\t\t\t     struct file *file,\n\t\t\t\t\t     loff_t start, size_t len,\n\t\t\t\t\t     enum netfs_io_origin origin);\nvoid netfs_get_request(struct netfs_io_request *rreq, enum netfs_rreq_ref_trace what);\nvoid netfs_clear_subrequests(struct netfs_io_request *rreq, bool was_async);\nvoid netfs_put_request(struct netfs_io_request *rreq, bool was_async,\n\t\t       enum netfs_rreq_ref_trace what);\nstruct netfs_io_subrequest *netfs_alloc_subrequest(struct netfs_io_request *rreq);\n\nstatic inline void netfs_see_request(struct netfs_io_request *rreq,\n\t\t\t\t     enum netfs_rreq_ref_trace what)\n{\n\ttrace_netfs_rreq_ref(rreq->debug_id, refcount_read(&rreq->ref), what);\n}\n\n \n#ifdef CONFIG_NETFS_STATS\nextern atomic_t netfs_n_rh_readahead;\nextern atomic_t netfs_n_rh_readpage;\nextern atomic_t netfs_n_rh_rreq;\nextern atomic_t netfs_n_rh_sreq;\nextern atomic_t netfs_n_rh_download;\nextern atomic_t netfs_n_rh_download_done;\nextern atomic_t netfs_n_rh_download_failed;\nextern atomic_t netfs_n_rh_download_instead;\nextern atomic_t netfs_n_rh_read;\nextern atomic_t netfs_n_rh_read_done;\nextern atomic_t netfs_n_rh_read_failed;\nextern atomic_t netfs_n_rh_zero;\nextern atomic_t netfs_n_rh_short_read;\nextern atomic_t netfs_n_rh_write;\nextern atomic_t netfs_n_rh_write_begin;\nextern atomic_t netfs_n_rh_write_done;\nextern atomic_t netfs_n_rh_write_failed;\nextern atomic_t netfs_n_rh_write_zskip;\n\n\nstatic inline void netfs_stat(atomic_t *stat)\n{\n\tatomic_inc(stat);\n}\n\nstatic inline void netfs_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}\n\n#else\n#define netfs_stat(x) do {} while(0)\n#define netfs_stat_d(x) do {} while(0)\n#endif\n\n \nstatic inline bool netfs_is_cache_enabled(struct netfs_inode *ctx)\n{\n#if IS_ENABLED(CONFIG_FSCACHE)\n\tstruct fscache_cookie *cookie = ctx->cache;\n\n\treturn fscache_cookie_valid(cookie) && cookie->cache_priv &&\n\t\tfscache_cookie_enabled(cookie);\n#else\n\treturn false;\n#endif\n}\n\n \n \n#define dbgprintk(FMT, ...) \\\n\tprintk(\"[%-6.6s] \"FMT\"\\n\", current->comm, ##__VA_ARGS__)\n\n#define kenter(FMT, ...) dbgprintk(\"==> %s(\"FMT\")\", __func__, ##__VA_ARGS__)\n#define kleave(FMT, ...) dbgprintk(\"<== %s()\"FMT\"\", __func__, ##__VA_ARGS__)\n#define kdebug(FMT, ...) dbgprintk(FMT, ##__VA_ARGS__)\n\n#ifdef __KDEBUG\n#define _enter(FMT, ...) kenter(FMT, ##__VA_ARGS__)\n#define _leave(FMT, ...) kleave(FMT, ##__VA_ARGS__)\n#define _debug(FMT, ...) kdebug(FMT, ##__VA_ARGS__)\n\n#elif defined(CONFIG_NETFS_DEBUG)\n#define _enter(FMT, ...)\t\t\t\\\ndo {\t\t\t\t\t\t\\\n\tif (netfs_debug)\t\t\t\\\n\t\tkenter(FMT, ##__VA_ARGS__);\t\\\n} while (0)\n\n#define _leave(FMT, ...)\t\t\t\\\ndo {\t\t\t\t\t\t\\\n\tif (netfs_debug)\t\t\t\\\n\t\tkleave(FMT, ##__VA_ARGS__);\t\\\n} while (0)\n\n#define _debug(FMT, ...)\t\t\t\\\ndo {\t\t\t\t\t\t\\\n\tif (netfs_debug)\t\t\t\\\n\t\tkdebug(FMT, ##__VA_ARGS__);\t\\\n} while (0)\n\n#else\n#define _enter(FMT, ...) no_printk(\"==> %s(\"FMT\")\", __func__, ##__VA_ARGS__)\n#define _leave(FMT, ...) no_printk(\"<== %s()\"FMT\"\", __func__, ##__VA_ARGS__)\n#define _debug(FMT, ...) no_printk(FMT, ##__VA_ARGS__)\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}