{
  "module_name": "namei.c",
  "hash_id": "7fcaaa6a3cb5677b98fac2f23a6552ae853fdaffda2d3d65f7ffe769d7833a3b",
  "original_prompt": "Ingested from linux-6.6.14/fs/namei.c",
  "human_readable_source": "\n \n\n \n\n \n \n\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/filelock.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/sched/mm.h>\n#include <linux/fsnotify.h>\n#include <linux/personality.h>\n#include <linux/security.h>\n#include <linux/ima.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/device_cgroup.h>\n#include <linux/fs_struct.h>\n#include <linux/posix_acl.h>\n#include <linux/hash.h>\n#include <linux/bitops.h>\n#include <linux/init_task.h>\n#include <linux/uaccess.h>\n\n#include \"internal.h\"\n#include \"mount.h\"\n\n \n\n \n\n \n\n \n \n\n \n\n#define EMBEDDED_NAME_MAX\t(PATH_MAX - offsetof(struct filename, iname))\n\nstruct filename *\ngetname_flags(const char __user *filename, int flags, int *empty)\n{\n\tstruct filename *result;\n\tchar *kname;\n\tint len;\n\n\tresult = audit_reusename(filename);\n\tif (result)\n\t\treturn result;\n\n\tresult = __getname();\n\tif (unlikely(!result))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tkname = (char *)result->iname;\n\tresult->name = kname;\n\n\tlen = strncpy_from_user(kname, filename, EMBEDDED_NAME_MAX);\n\tif (unlikely(len < 0)) {\n\t\t__putname(result);\n\t\treturn ERR_PTR(len);\n\t}\n\n\t \n\tif (unlikely(len == EMBEDDED_NAME_MAX)) {\n\t\tconst size_t size = offsetof(struct filename, iname[1]);\n\t\tkname = (char *)result;\n\n\t\t \n\t\tresult = kzalloc(size, GFP_KERNEL);\n\t\tif (unlikely(!result)) {\n\t\t\t__putname(kname);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t\tresult->name = kname;\n\t\tlen = strncpy_from_user(kname, filename, PATH_MAX);\n\t\tif (unlikely(len < 0)) {\n\t\t\t__putname(kname);\n\t\t\tkfree(result);\n\t\t\treturn ERR_PTR(len);\n\t\t}\n\t\tif (unlikely(len == PATH_MAX)) {\n\t\t\t__putname(kname);\n\t\t\tkfree(result);\n\t\t\treturn ERR_PTR(-ENAMETOOLONG);\n\t\t}\n\t}\n\n\tatomic_set(&result->refcnt, 1);\n\t \n\tif (unlikely(!len)) {\n\t\tif (empty)\n\t\t\t*empty = 1;\n\t\tif (!(flags & LOOKUP_EMPTY)) {\n\t\t\tputname(result);\n\t\t\treturn ERR_PTR(-ENOENT);\n\t\t}\n\t}\n\n\tresult->uptr = filename;\n\tresult->aname = NULL;\n\taudit_getname(result);\n\treturn result;\n}\n\nstruct filename *\ngetname_uflags(const char __user *filename, int uflags)\n{\n\tint flags = (uflags & AT_EMPTY_PATH) ? LOOKUP_EMPTY : 0;\n\n\treturn getname_flags(filename, flags, NULL);\n}\n\nstruct filename *\ngetname(const char __user * filename)\n{\n\treturn getname_flags(filename, 0, NULL);\n}\n\nstruct filename *\ngetname_kernel(const char * filename)\n{\n\tstruct filename *result;\n\tint len = strlen(filename) + 1;\n\n\tresult = __getname();\n\tif (unlikely(!result))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (len <= EMBEDDED_NAME_MAX) {\n\t\tresult->name = (char *)result->iname;\n\t} else if (len <= PATH_MAX) {\n\t\tconst size_t size = offsetof(struct filename, iname[1]);\n\t\tstruct filename *tmp;\n\n\t\ttmp = kmalloc(size, GFP_KERNEL);\n\t\tif (unlikely(!tmp)) {\n\t\t\t__putname(result);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t\ttmp->name = (char *)result;\n\t\tresult = tmp;\n\t} else {\n\t\t__putname(result);\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\t}\n\tmemcpy((char *)result->name, filename, len);\n\tresult->uptr = NULL;\n\tresult->aname = NULL;\n\tatomic_set(&result->refcnt, 1);\n\taudit_getname(result);\n\n\treturn result;\n}\nEXPORT_SYMBOL(getname_kernel);\n\nvoid putname(struct filename *name)\n{\n\tif (IS_ERR(name))\n\t\treturn;\n\n\tif (WARN_ON_ONCE(!atomic_read(&name->refcnt)))\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&name->refcnt))\n\t\treturn;\n\n\tif (name->name != name->iname) {\n\t\t__putname(name->name);\n\t\tkfree(name);\n\t} else\n\t\t__putname(name);\n}\nEXPORT_SYMBOL(putname);\n\n \nstatic int check_acl(struct mnt_idmap *idmap,\n\t\t     struct inode *inode, int mask)\n{\n#ifdef CONFIG_FS_POSIX_ACL\n\tstruct posix_acl *acl;\n\n\tif (mask & MAY_NOT_BLOCK) {\n\t\tacl = get_cached_acl_rcu(inode, ACL_TYPE_ACCESS);\n\t        if (!acl)\n\t                return -EAGAIN;\n\t\t \n\t\tif (is_uncached_acl(acl))\n\t\t\treturn -ECHILD;\n\t        return posix_acl_permission(idmap, inode, acl, mask);\n\t}\n\n\tacl = get_inode_acl(inode, ACL_TYPE_ACCESS);\n\tif (IS_ERR(acl))\n\t\treturn PTR_ERR(acl);\n\tif (acl) {\n\t        int error = posix_acl_permission(idmap, inode, acl, mask);\n\t        posix_acl_release(acl);\n\t        return error;\n\t}\n#endif\n\n\treturn -EAGAIN;\n}\n\n \nstatic int acl_permission_check(struct mnt_idmap *idmap,\n\t\t\t\tstruct inode *inode, int mask)\n{\n\tunsigned int mode = inode->i_mode;\n\tvfsuid_t vfsuid;\n\n\t \n\tvfsuid = i_uid_into_vfsuid(idmap, inode);\n\tif (likely(vfsuid_eq_kuid(vfsuid, current_fsuid()))) {\n\t\tmask &= 7;\n\t\tmode >>= 6;\n\t\treturn (mask & ~mode) ? -EACCES : 0;\n\t}\n\n\t \n\tif (IS_POSIXACL(inode) && (mode & S_IRWXG)) {\n\t\tint error = check_acl(idmap, inode, mask);\n\t\tif (error != -EAGAIN)\n\t\t\treturn error;\n\t}\n\n\t \n\tmask &= 7;\n\n\t \n\tif (mask & (mode ^ (mode >> 3))) {\n\t\tvfsgid_t vfsgid = i_gid_into_vfsgid(idmap, inode);\n\t\tif (vfsgid_in_group_p(vfsgid))\n\t\t\tmode >>= 3;\n\t}\n\n\t \n\treturn (mask & ~mode) ? -EACCES : 0;\n}\n\n \nint generic_permission(struct mnt_idmap *idmap, struct inode *inode,\n\t\t       int mask)\n{\n\tint ret;\n\n\t \n\tret = acl_permission_check(idmap, inode, mask);\n\tif (ret != -EACCES)\n\t\treturn ret;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\t \n\t\tif (!(mask & MAY_WRITE))\n\t\t\tif (capable_wrt_inode_uidgid(idmap, inode,\n\t\t\t\t\t\t     CAP_DAC_READ_SEARCH))\n\t\t\t\treturn 0;\n\t\tif (capable_wrt_inode_uidgid(idmap, inode,\n\t\t\t\t\t     CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\t\treturn -EACCES;\n\t}\n\n\t \n\tmask &= MAY_READ | MAY_WRITE | MAY_EXEC;\n\tif (mask == MAY_READ)\n\t\tif (capable_wrt_inode_uidgid(idmap, inode,\n\t\t\t\t\t     CAP_DAC_READ_SEARCH))\n\t\t\treturn 0;\n\t \n\tif (!(mask & MAY_EXEC) || (inode->i_mode & S_IXUGO))\n\t\tif (capable_wrt_inode_uidgid(idmap, inode,\n\t\t\t\t\t     CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\n\treturn -EACCES;\n}\nEXPORT_SYMBOL(generic_permission);\n\n \nstatic inline int do_inode_permission(struct mnt_idmap *idmap,\n\t\t\t\t      struct inode *inode, int mask)\n{\n\tif (unlikely(!(inode->i_opflags & IOP_FASTPERM))) {\n\t\tif (likely(inode->i_op->permission))\n\t\t\treturn inode->i_op->permission(idmap, inode, mask);\n\n\t\t \n\t\tspin_lock(&inode->i_lock);\n\t\tinode->i_opflags |= IOP_FASTPERM;\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\treturn generic_permission(idmap, inode, mask);\n}\n\n \nstatic int sb_permission(struct super_block *sb, struct inode *inode, int mask)\n{\n\tif (unlikely(mask & MAY_WRITE)) {\n\t\tumode_t mode = inode->i_mode;\n\n\t\t \n\t\tif (sb_rdonly(sb) && (S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode)))\n\t\t\treturn -EROFS;\n\t}\n\treturn 0;\n}\n\n \nint inode_permission(struct mnt_idmap *idmap,\n\t\t     struct inode *inode, int mask)\n{\n\tint retval;\n\n\tretval = sb_permission(inode->i_sb, inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\tif (unlikely(mask & MAY_WRITE)) {\n\t\t \n\t\tif (IS_IMMUTABLE(inode))\n\t\t\treturn -EPERM;\n\n\t\t \n\t\tif (HAS_UNMAPPED_ID(idmap, inode))\n\t\t\treturn -EACCES;\n\t}\n\n\tretval = do_inode_permission(idmap, inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = devcgroup_inode_permission(inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\treturn security_inode_permission(inode, mask);\n}\nEXPORT_SYMBOL(inode_permission);\n\n \nvoid path_get(const struct path *path)\n{\n\tmntget(path->mnt);\n\tdget(path->dentry);\n}\nEXPORT_SYMBOL(path_get);\n\n \nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}\nEXPORT_SYMBOL(path_put);\n\n#define EMBEDDED_LEVELS 2\nstruct nameidata {\n\tstruct path\tpath;\n\tstruct qstr\tlast;\n\tstruct path\troot;\n\tstruct inode\t*inode;  \n\tunsigned int\tflags, state;\n\tunsigned\tseq, next_seq, m_seq, r_seq;\n\tint\t\tlast_type;\n\tunsigned\tdepth;\n\tint\t\ttotal_link_count;\n\tstruct saved {\n\t\tstruct path link;\n\t\tstruct delayed_call done;\n\t\tconst char *name;\n\t\tunsigned seq;\n\t} *stack, internal[EMBEDDED_LEVELS];\n\tstruct filename\t*name;\n\tstruct nameidata *saved;\n\tunsigned\troot_seq;\n\tint\t\tdfd;\n\tvfsuid_t\tdir_vfsuid;\n\tumode_t\t\tdir_mode;\n} __randomize_layout;\n\n#define ND_ROOT_PRESET 1\n#define ND_ROOT_GRABBED 2\n#define ND_JUMPED 4\n\nstatic void __set_nameidata(struct nameidata *p, int dfd, struct filename *name)\n{\n\tstruct nameidata *old = current->nameidata;\n\tp->stack = p->internal;\n\tp->depth = 0;\n\tp->dfd = dfd;\n\tp->name = name;\n\tp->path.mnt = NULL;\n\tp->path.dentry = NULL;\n\tp->total_link_count = old ? old->total_link_count : 0;\n\tp->saved = old;\n\tcurrent->nameidata = p;\n}\n\nstatic inline void set_nameidata(struct nameidata *p, int dfd, struct filename *name,\n\t\t\t  const struct path *root)\n{\n\t__set_nameidata(p, dfd, name);\n\tp->state = 0;\n\tif (unlikely(root)) {\n\t\tp->state = ND_ROOT_PRESET;\n\t\tp->root = *root;\n\t}\n}\n\nstatic void restore_nameidata(void)\n{\n\tstruct nameidata *now = current->nameidata, *old = now->saved;\n\n\tcurrent->nameidata = old;\n\tif (old)\n\t\told->total_link_count = now->total_link_count;\n\tif (now->stack != now->internal)\n\t\tkfree(now->stack);\n}\n\nstatic bool nd_alloc_stack(struct nameidata *nd)\n{\n\tstruct saved *p;\n\n\tp= kmalloc_array(MAXSYMLINKS, sizeof(struct saved),\n\t\t\t nd->flags & LOOKUP_RCU ? GFP_ATOMIC : GFP_KERNEL);\n\tif (unlikely(!p))\n\t\treturn false;\n\tmemcpy(p, nd->internal, sizeof(nd->internal));\n\tnd->stack = p;\n\treturn true;\n}\n\n \nstatic bool path_connected(struct vfsmount *mnt, struct dentry *dentry)\n{\n\tstruct super_block *sb = mnt->mnt_sb;\n\n\t \n\tif (mnt->mnt_root == sb->s_root)\n\t\treturn true;\n\n\treturn is_subdir(dentry, mnt->mnt_root);\n}\n\nstatic void drop_links(struct nameidata *nd)\n{\n\tint i = nd->depth;\n\twhile (i--) {\n\t\tstruct saved *last = nd->stack + i;\n\t\tdo_delayed_call(&last->done);\n\t\tclear_delayed_call(&last->done);\n\t}\n}\n\nstatic void leave_rcu(struct nameidata *nd)\n{\n\tnd->flags &= ~LOOKUP_RCU;\n\tnd->seq = nd->next_seq = 0;\n\trcu_read_unlock();\n}\n\nstatic void terminate_walk(struct nameidata *nd)\n{\n\tdrop_links(nd);\n\tif (!(nd->flags & LOOKUP_RCU)) {\n\t\tint i;\n\t\tpath_put(&nd->path);\n\t\tfor (i = 0; i < nd->depth; i++)\n\t\t\tpath_put(&nd->stack[i].link);\n\t\tif (nd->state & ND_ROOT_GRABBED) {\n\t\t\tpath_put(&nd->root);\n\t\t\tnd->state &= ~ND_ROOT_GRABBED;\n\t\t}\n\t} else {\n\t\tleave_rcu(nd);\n\t}\n\tnd->depth = 0;\n\tnd->path.mnt = NULL;\n\tnd->path.dentry = NULL;\n}\n\n \nstatic bool __legitimize_path(struct path *path, unsigned seq, unsigned mseq)\n{\n\tint res = __legitimize_mnt(path->mnt, mseq);\n\tif (unlikely(res)) {\n\t\tif (res > 0)\n\t\t\tpath->mnt = NULL;\n\t\tpath->dentry = NULL;\n\t\treturn false;\n\t}\n\tif (unlikely(!lockref_get_not_dead(&path->dentry->d_lockref))) {\n\t\tpath->dentry = NULL;\n\t\treturn false;\n\t}\n\treturn !read_seqcount_retry(&path->dentry->d_seq, seq);\n}\n\nstatic inline bool legitimize_path(struct nameidata *nd,\n\t\t\t    struct path *path, unsigned seq)\n{\n\treturn __legitimize_path(path, seq, nd->m_seq);\n}\n\nstatic bool legitimize_links(struct nameidata *nd)\n{\n\tint i;\n\tif (unlikely(nd->flags & LOOKUP_CACHED)) {\n\t\tdrop_links(nd);\n\t\tnd->depth = 0;\n\t\treturn false;\n\t}\n\tfor (i = 0; i < nd->depth; i++) {\n\t\tstruct saved *last = nd->stack + i;\n\t\tif (unlikely(!legitimize_path(nd, &last->link, last->seq))) {\n\t\t\tdrop_links(nd);\n\t\t\tnd->depth = i + 1;\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic bool legitimize_root(struct nameidata *nd)\n{\n\t \n\tif (!nd->root.mnt || (nd->state & ND_ROOT_PRESET))\n\t\treturn true;\n\tnd->state |= ND_ROOT_GRABBED;\n\treturn legitimize_path(nd, &nd->root, nd->root_seq);\n}\n\n \n\n \nstatic bool try_to_unlazy(struct nameidata *nd)\n{\n\tstruct dentry *parent = nd->path.dentry;\n\n\tBUG_ON(!(nd->flags & LOOKUP_RCU));\n\n\tif (unlikely(!legitimize_links(nd)))\n\t\tgoto out1;\n\tif (unlikely(!legitimize_path(nd, &nd->path, nd->seq)))\n\t\tgoto out;\n\tif (unlikely(!legitimize_root(nd)))\n\t\tgoto out;\n\tleave_rcu(nd);\n\tBUG_ON(nd->inode != parent->d_inode);\n\treturn true;\n\nout1:\n\tnd->path.mnt = NULL;\n\tnd->path.dentry = NULL;\nout:\n\tleave_rcu(nd);\n\treturn false;\n}\n\n \nstatic bool try_to_unlazy_next(struct nameidata *nd, struct dentry *dentry)\n{\n\tint res;\n\tBUG_ON(!(nd->flags & LOOKUP_RCU));\n\n\tif (unlikely(!legitimize_links(nd)))\n\t\tgoto out2;\n\tres = __legitimize_mnt(nd->path.mnt, nd->m_seq);\n\tif (unlikely(res)) {\n\t\tif (res > 0)\n\t\t\tgoto out2;\n\t\tgoto out1;\n\t}\n\tif (unlikely(!lockref_get_not_dead(&nd->path.dentry->d_lockref)))\n\t\tgoto out1;\n\n\t \n\tif (unlikely(!lockref_get_not_dead(&dentry->d_lockref)))\n\t\tgoto out;\n\tif (read_seqcount_retry(&dentry->d_seq, nd->next_seq))\n\t\tgoto out_dput;\n\t \n\tif (unlikely(!legitimize_root(nd)))\n\t\tgoto out_dput;\n\tleave_rcu(nd);\n\treturn true;\n\nout2:\n\tnd->path.mnt = NULL;\nout1:\n\tnd->path.dentry = NULL;\nout:\n\tleave_rcu(nd);\n\treturn false;\nout_dput:\n\tleave_rcu(nd);\n\tdput(dentry);\n\treturn false;\n}\n\nstatic inline int d_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tif (unlikely(dentry->d_flags & DCACHE_OP_REVALIDATE))\n\t\treturn dentry->d_op->d_revalidate(dentry, flags);\n\telse\n\t\treturn 1;\n}\n\n \nstatic int complete_walk(struct nameidata *nd)\n{\n\tstruct dentry *dentry = nd->path.dentry;\n\tint status;\n\n\tif (nd->flags & LOOKUP_RCU) {\n\t\t \n\t\tif (!(nd->state & ND_ROOT_PRESET))\n\t\t\tif (!(nd->flags & LOOKUP_IS_SCOPED))\n\t\t\t\tnd->root.mnt = NULL;\n\t\tnd->flags &= ~LOOKUP_CACHED;\n\t\tif (!try_to_unlazy(nd))\n\t\t\treturn -ECHILD;\n\t}\n\n\tif (unlikely(nd->flags & LOOKUP_IS_SCOPED)) {\n\t\t \n\t\tif (!path_is_under(&nd->path, &nd->root))\n\t\t\treturn -EXDEV;\n\t}\n\n\tif (likely(!(nd->state & ND_JUMPED)))\n\t\treturn 0;\n\n\tif (likely(!(dentry->d_flags & DCACHE_OP_WEAK_REVALIDATE)))\n\t\treturn 0;\n\n\tstatus = dentry->d_op->d_weak_revalidate(dentry, nd->flags);\n\tif (status > 0)\n\t\treturn 0;\n\n\tif (!status)\n\t\tstatus = -ESTALE;\n\n\treturn status;\n}\n\nstatic int set_root(struct nameidata *nd)\n{\n\tstruct fs_struct *fs = current->fs;\n\n\t \n\tif (WARN_ON(nd->flags & LOOKUP_IS_SCOPED))\n\t\treturn -ENOTRECOVERABLE;\n\n\tif (nd->flags & LOOKUP_RCU) {\n\t\tunsigned seq;\n\n\t\tdo {\n\t\t\tseq = read_seqcount_begin(&fs->seq);\n\t\t\tnd->root = fs->root;\n\t\t\tnd->root_seq = __read_seqcount_begin(&nd->root.dentry->d_seq);\n\t\t} while (read_seqcount_retry(&fs->seq, seq));\n\t} else {\n\t\tget_fs_root(fs, &nd->root);\n\t\tnd->state |= ND_ROOT_GRABBED;\n\t}\n\treturn 0;\n}\n\nstatic int nd_jump_root(struct nameidata *nd)\n{\n\tif (unlikely(nd->flags & LOOKUP_BENEATH))\n\t\treturn -EXDEV;\n\tif (unlikely(nd->flags & LOOKUP_NO_XDEV)) {\n\t\t \n\t\tif (nd->path.mnt != NULL && nd->path.mnt != nd->root.mnt)\n\t\t\treturn -EXDEV;\n\t}\n\tif (!nd->root.mnt) {\n\t\tint error = set_root(nd);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tif (nd->flags & LOOKUP_RCU) {\n\t\tstruct dentry *d;\n\t\tnd->path = nd->root;\n\t\td = nd->path.dentry;\n\t\tnd->inode = d->d_inode;\n\t\tnd->seq = nd->root_seq;\n\t\tif (read_seqcount_retry(&d->d_seq, nd->seq))\n\t\t\treturn -ECHILD;\n\t} else {\n\t\tpath_put(&nd->path);\n\t\tnd->path = nd->root;\n\t\tpath_get(&nd->path);\n\t\tnd->inode = nd->path.dentry->d_inode;\n\t}\n\tnd->state |= ND_JUMPED;\n\treturn 0;\n}\n\n \nint nd_jump_link(const struct path *path)\n{\n\tint error = -ELOOP;\n\tstruct nameidata *nd = current->nameidata;\n\n\tif (unlikely(nd->flags & LOOKUP_NO_MAGICLINKS))\n\t\tgoto err;\n\n\terror = -EXDEV;\n\tif (unlikely(nd->flags & LOOKUP_NO_XDEV)) {\n\t\tif (nd->path.mnt != path->mnt)\n\t\t\tgoto err;\n\t}\n\t \n\tif (unlikely(nd->flags & LOOKUP_IS_SCOPED))\n\t\tgoto err;\n\n\tpath_put(&nd->path);\n\tnd->path = *path;\n\tnd->inode = nd->path.dentry->d_inode;\n\tnd->state |= ND_JUMPED;\n\treturn 0;\n\nerr:\n\tpath_put(path);\n\treturn error;\n}\n\nstatic inline void put_link(struct nameidata *nd)\n{\n\tstruct saved *last = nd->stack + --nd->depth;\n\tdo_delayed_call(&last->done);\n\tif (!(nd->flags & LOOKUP_RCU))\n\t\tpath_put(&last->link);\n}\n\nstatic int sysctl_protected_symlinks __read_mostly;\nstatic int sysctl_protected_hardlinks __read_mostly;\nstatic int sysctl_protected_fifos __read_mostly;\nstatic int sysctl_protected_regular __read_mostly;\n\n#ifdef CONFIG_SYSCTL\nstatic struct ctl_table namei_sysctls[] = {\n\t{\n\t\t.procname\t= \"protected_symlinks\",\n\t\t.data\t\t= &sysctl_protected_symlinks,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_ONE,\n\t},\n\t{\n\t\t.procname\t= \"protected_hardlinks\",\n\t\t.data\t\t= &sysctl_protected_hardlinks,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_ONE,\n\t},\n\t{\n\t\t.procname\t= \"protected_fifos\",\n\t\t.data\t\t= &sysctl_protected_fifos,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_TWO,\n\t},\n\t{\n\t\t.procname\t= \"protected_regular\",\n\t\t.data\t\t= &sysctl_protected_regular,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_TWO,\n\t},\n\t{ }\n};\n\nstatic int __init init_fs_namei_sysctls(void)\n{\n\tregister_sysctl_init(\"fs\", namei_sysctls);\n\treturn 0;\n}\nfs_initcall(init_fs_namei_sysctls);\n\n#endif  \n\n \nstatic inline int may_follow_link(struct nameidata *nd, const struct inode *inode)\n{\n\tstruct mnt_idmap *idmap;\n\tvfsuid_t vfsuid;\n\n\tif (!sysctl_protected_symlinks)\n\t\treturn 0;\n\n\tidmap = mnt_idmap(nd->path.mnt);\n\tvfsuid = i_uid_into_vfsuid(idmap, inode);\n\t \n\tif (vfsuid_eq_kuid(vfsuid, current_fsuid()))\n\t\treturn 0;\n\n\t \n\tif ((nd->dir_mode & (S_ISVTX|S_IWOTH)) != (S_ISVTX|S_IWOTH))\n\t\treturn 0;\n\n\t \n\tif (vfsuid_valid(nd->dir_vfsuid) && vfsuid_eq(nd->dir_vfsuid, vfsuid))\n\t\treturn 0;\n\n\tif (nd->flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\taudit_inode(nd->name, nd->stack[0].link.dentry, 0);\n\taudit_log_path_denied(AUDIT_ANOM_LINK, \"follow_link\");\n\treturn -EACCES;\n}\n\n \nstatic bool safe_hardlink_source(struct mnt_idmap *idmap,\n\t\t\t\t struct inode *inode)\n{\n\tumode_t mode = inode->i_mode;\n\n\t \n\tif (!S_ISREG(mode))\n\t\treturn false;\n\n\t \n\tif (mode & S_ISUID)\n\t\treturn false;\n\n\t \n\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP))\n\t\treturn false;\n\n\t \n\tif (inode_permission(idmap, inode, MAY_READ | MAY_WRITE))\n\t\treturn false;\n\n\treturn true;\n}\n\n \nint may_linkat(struct mnt_idmap *idmap, const struct path *link)\n{\n\tstruct inode *inode = link->dentry->d_inode;\n\n\t \n\tif (!vfsuid_valid(i_uid_into_vfsuid(idmap, inode)) ||\n\t    !vfsgid_valid(i_gid_into_vfsgid(idmap, inode)))\n\t\treturn -EOVERFLOW;\n\n\tif (!sysctl_protected_hardlinks)\n\t\treturn 0;\n\n\t \n\tif (safe_hardlink_source(idmap, inode) ||\n\t    inode_owner_or_capable(idmap, inode))\n\t\treturn 0;\n\n\taudit_log_path_denied(AUDIT_ANOM_LINK, \"linkat\");\n\treturn -EPERM;\n}\n\n \nstatic int may_create_in_sticky(struct mnt_idmap *idmap,\n\t\t\t\tstruct nameidata *nd, struct inode *const inode)\n{\n\tumode_t dir_mode = nd->dir_mode;\n\tvfsuid_t dir_vfsuid = nd->dir_vfsuid;\n\n\tif ((!sysctl_protected_fifos && S_ISFIFO(inode->i_mode)) ||\n\t    (!sysctl_protected_regular && S_ISREG(inode->i_mode)) ||\n\t    likely(!(dir_mode & S_ISVTX)) ||\n\t    vfsuid_eq(i_uid_into_vfsuid(idmap, inode), dir_vfsuid) ||\n\t    vfsuid_eq_kuid(i_uid_into_vfsuid(idmap, inode), current_fsuid()))\n\t\treturn 0;\n\n\tif (likely(dir_mode & 0002) ||\n\t    (dir_mode & 0020 &&\n\t     ((sysctl_protected_fifos >= 2 && S_ISFIFO(inode->i_mode)) ||\n\t      (sysctl_protected_regular >= 2 && S_ISREG(inode->i_mode))))) {\n\t\tconst char *operation = S_ISFIFO(inode->i_mode) ?\n\t\t\t\t\t\"sticky_create_fifo\" :\n\t\t\t\t\t\"sticky_create_regular\";\n\t\taudit_log_path_denied(AUDIT_ANOM_CREAT, operation);\n\t\treturn -EACCES;\n\t}\n\treturn 0;\n}\n\n \nint follow_up(struct path *path)\n{\n\tstruct mount *mnt = real_mount(path->mnt);\n\tstruct mount *parent;\n\tstruct dentry *mountpoint;\n\n\tread_seqlock_excl(&mount_lock);\n\tparent = mnt->mnt_parent;\n\tif (parent == mnt) {\n\t\tread_sequnlock_excl(&mount_lock);\n\t\treturn 0;\n\t}\n\tmntget(&parent->mnt);\n\tmountpoint = dget(mnt->mnt_mountpoint);\n\tread_sequnlock_excl(&mount_lock);\n\tdput(path->dentry);\n\tpath->dentry = mountpoint;\n\tmntput(path->mnt);\n\tpath->mnt = &parent->mnt;\n\treturn 1;\n}\nEXPORT_SYMBOL(follow_up);\n\nstatic bool choose_mountpoint_rcu(struct mount *m, const struct path *root,\n\t\t\t\t  struct path *path, unsigned *seqp)\n{\n\twhile (mnt_has_parent(m)) {\n\t\tstruct dentry *mountpoint = m->mnt_mountpoint;\n\n\t\tm = m->mnt_parent;\n\t\tif (unlikely(root->dentry == mountpoint &&\n\t\t\t     root->mnt == &m->mnt))\n\t\t\tbreak;\n\t\tif (mountpoint != m->mnt.mnt_root) {\n\t\t\tpath->mnt = &m->mnt;\n\t\t\tpath->dentry = mountpoint;\n\t\t\t*seqp = read_seqcount_begin(&mountpoint->d_seq);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic bool choose_mountpoint(struct mount *m, const struct path *root,\n\t\t\t      struct path *path)\n{\n\tbool found;\n\n\trcu_read_lock();\n\twhile (1) {\n\t\tunsigned seq, mseq = read_seqbegin(&mount_lock);\n\n\t\tfound = choose_mountpoint_rcu(m, root, path, &seq);\n\t\tif (unlikely(!found)) {\n\t\t\tif (!read_seqretry(&mount_lock, mseq))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (likely(__legitimize_path(path, seq, mseq)))\n\t\t\t\tbreak;\n\t\t\trcu_read_unlock();\n\t\t\tpath_put(path);\n\t\t\trcu_read_lock();\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn found;\n}\n\n \nstatic int follow_automount(struct path *path, int *count, unsigned lookup_flags)\n{\n\tstruct dentry *dentry = path->dentry;\n\n\t \n\tif (!(lookup_flags & (LOOKUP_PARENT | LOOKUP_DIRECTORY |\n\t\t\t   LOOKUP_OPEN | LOOKUP_CREATE | LOOKUP_AUTOMOUNT)) &&\n\t    dentry->d_inode)\n\t\treturn -EISDIR;\n\n\tif (count && (*count)++ >= MAXSYMLINKS)\n\t\treturn -ELOOP;\n\n\treturn finish_automount(dentry->d_op->d_automount(path), path);\n}\n\n \nstatic int __traverse_mounts(struct path *path, unsigned flags, bool *jumped,\n\t\t\t     int *count, unsigned lookup_flags)\n{\n\tstruct vfsmount *mnt = path->mnt;\n\tbool need_mntput = false;\n\tint ret = 0;\n\n\twhile (flags & DCACHE_MANAGED_DENTRY) {\n\t\t \n\t\tif (flags & DCACHE_MANAGE_TRANSIT) {\n\t\t\tret = path->dentry->d_op->d_manage(path, false);\n\t\t\tflags = smp_load_acquire(&path->dentry->d_flags);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (flags & DCACHE_MOUNTED) {\t \n\t\t\tstruct vfsmount *mounted = lookup_mnt(path);\n\t\t\tif (mounted) {\t\t \n\t\t\t\tdput(path->dentry);\n\t\t\t\tif (need_mntput)\n\t\t\t\t\tmntput(path->mnt);\n\t\t\t\tpath->mnt = mounted;\n\t\t\t\tpath->dentry = dget(mounted->mnt_root);\n\t\t\t\t \n\t\t\t\tflags = path->dentry->d_flags;\n\t\t\t\tneed_mntput = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (!(flags & DCACHE_NEED_AUTOMOUNT))\n\t\t\tbreak;\n\n\t\t \n\t\tret = follow_automount(path, count, lookup_flags);\n\t\tflags = smp_load_acquire(&path->dentry->d_flags);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\n\tif (ret == -EISDIR)\n\t\tret = 0;\n\t \n\tif (need_mntput && path->mnt == mnt)\n\t\tmntput(path->mnt);\n\tif (!ret && unlikely(d_flags_negative(flags)))\n\t\tret = -ENOENT;\n\t*jumped = need_mntput;\n\treturn ret;\n}\n\nstatic inline int traverse_mounts(struct path *path, bool *jumped,\n\t\t\t\t  int *count, unsigned lookup_flags)\n{\n\tunsigned flags = smp_load_acquire(&path->dentry->d_flags);\n\n\t \n\tif (likely(!(flags & DCACHE_MANAGED_DENTRY))) {\n\t\t*jumped = false;\n\t\tif (unlikely(d_flags_negative(flags)))\n\t\t\treturn -ENOENT;\n\t\treturn 0;\n\t}\n\treturn __traverse_mounts(path, flags, jumped, count, lookup_flags);\n}\n\nint follow_down_one(struct path *path)\n{\n\tstruct vfsmount *mounted;\n\n\tmounted = lookup_mnt(path);\n\tif (mounted) {\n\t\tdput(path->dentry);\n\t\tmntput(path->mnt);\n\t\tpath->mnt = mounted;\n\t\tpath->dentry = dget(mounted->mnt_root);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(follow_down_one);\n\n \nint follow_down(struct path *path, unsigned int flags)\n{\n\tstruct vfsmount *mnt = path->mnt;\n\tbool jumped;\n\tint ret = traverse_mounts(path, &jumped, NULL, flags);\n\n\tif (path->mnt != mnt)\n\t\tmntput(mnt);\n\treturn ret;\n}\nEXPORT_SYMBOL(follow_down);\n\n \nstatic bool __follow_mount_rcu(struct nameidata *nd, struct path *path)\n{\n\tstruct dentry *dentry = path->dentry;\n\tunsigned int flags = dentry->d_flags;\n\n\tif (likely(!(flags & DCACHE_MANAGED_DENTRY)))\n\t\treturn true;\n\n\tif (unlikely(nd->flags & LOOKUP_NO_XDEV))\n\t\treturn false;\n\n\tfor (;;) {\n\t\t \n\t\tif (unlikely(flags & DCACHE_MANAGE_TRANSIT)) {\n\t\t\tint res = dentry->d_op->d_manage(path, true);\n\t\t\tif (res)\n\t\t\t\treturn res == -EISDIR;\n\t\t\tflags = dentry->d_flags;\n\t\t}\n\n\t\tif (flags & DCACHE_MOUNTED) {\n\t\t\tstruct mount *mounted = __lookup_mnt(path->mnt, dentry);\n\t\t\tif (mounted) {\n\t\t\t\tpath->mnt = &mounted->mnt;\n\t\t\t\tdentry = path->dentry = mounted->mnt.mnt_root;\n\t\t\t\tnd->state |= ND_JUMPED;\n\t\t\t\tnd->next_seq = read_seqcount_begin(&dentry->d_seq);\n\t\t\t\tflags = dentry->d_flags;\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tif (read_seqretry(&mount_lock, nd->m_seq))\n\t\t\t\t\treturn false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (read_seqretry(&mount_lock, nd->m_seq))\n\t\t\t\treturn false;\n\t\t}\n\t\treturn !(flags & DCACHE_NEED_AUTOMOUNT);\n\t}\n}\n\nstatic inline int handle_mounts(struct nameidata *nd, struct dentry *dentry,\n\t\t\t  struct path *path)\n{\n\tbool jumped;\n\tint ret;\n\n\tpath->mnt = nd->path.mnt;\n\tpath->dentry = dentry;\n\tif (nd->flags & LOOKUP_RCU) {\n\t\tunsigned int seq = nd->next_seq;\n\t\tif (likely(__follow_mount_rcu(nd, path)))\n\t\t\treturn 0;\n\t\t \n\t\tpath->mnt = nd->path.mnt;\n\t\tpath->dentry = dentry;\n\t\tnd->next_seq = seq;\n\t\tif (!try_to_unlazy_next(nd, dentry))\n\t\t\treturn -ECHILD;\n\t}\n\tret = traverse_mounts(path, &jumped, &nd->total_link_count, nd->flags);\n\tif (jumped) {\n\t\tif (unlikely(nd->flags & LOOKUP_NO_XDEV))\n\t\t\tret = -EXDEV;\n\t\telse\n\t\t\tnd->state |= ND_JUMPED;\n\t}\n\tif (unlikely(ret)) {\n\t\tdput(path->dentry);\n\t\tif (path->mnt != nd->path.mnt)\n\t\t\tmntput(path->mnt);\n\t}\n\treturn ret;\n}\n\n \nstatic struct dentry *lookup_dcache(const struct qstr *name,\n\t\t\t\t    struct dentry *dir,\n\t\t\t\t    unsigned int flags)\n{\n\tstruct dentry *dentry = d_lookup(dir, name);\n\tif (dentry) {\n\t\tint error = d_revalidate(dentry, flags);\n\t\tif (unlikely(error <= 0)) {\n\t\t\tif (!error)\n\t\t\t\td_invalidate(dentry);\n\t\t\tdput(dentry);\n\t\t\treturn ERR_PTR(error);\n\t\t}\n\t}\n\treturn dentry;\n}\n\n \nstruct dentry *lookup_one_qstr_excl(const struct qstr *name,\n\t\t\t\t    struct dentry *base,\n\t\t\t\t    unsigned int flags)\n{\n\tstruct dentry *dentry = lookup_dcache(name, base, flags);\n\tstruct dentry *old;\n\tstruct inode *dir = base->d_inode;\n\n\tif (dentry)\n\t\treturn dentry;\n\n\t \n\tif (unlikely(IS_DEADDIR(dir)))\n\t\treturn ERR_PTR(-ENOENT);\n\n\tdentry = d_alloc(base, name);\n\tif (unlikely(!dentry))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\told = dir->i_op->lookup(dir, dentry, flags);\n\tif (unlikely(old)) {\n\t\tdput(dentry);\n\t\tdentry = old;\n\t}\n\treturn dentry;\n}\nEXPORT_SYMBOL(lookup_one_qstr_excl);\n\nstatic struct dentry *lookup_fast(struct nameidata *nd)\n{\n\tstruct dentry *dentry, *parent = nd->path.dentry;\n\tint status = 1;\n\n\t \n\tif (nd->flags & LOOKUP_RCU) {\n\t\tdentry = __d_lookup_rcu(parent, &nd->last, &nd->next_seq);\n\t\tif (unlikely(!dentry)) {\n\t\t\tif (!try_to_unlazy(nd))\n\t\t\t\treturn ERR_PTR(-ECHILD);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t \n\t\tif (read_seqcount_retry(&parent->d_seq, nd->seq))\n\t\t\treturn ERR_PTR(-ECHILD);\n\n\t\tstatus = d_revalidate(dentry, nd->flags);\n\t\tif (likely(status > 0))\n\t\t\treturn dentry;\n\t\tif (!try_to_unlazy_next(nd, dentry))\n\t\t\treturn ERR_PTR(-ECHILD);\n\t\tif (status == -ECHILD)\n\t\t\t \n\t\t\tstatus = d_revalidate(dentry, nd->flags);\n\t} else {\n\t\tdentry = __d_lookup(parent, &nd->last);\n\t\tif (unlikely(!dentry))\n\t\t\treturn NULL;\n\t\tstatus = d_revalidate(dentry, nd->flags);\n\t}\n\tif (unlikely(status <= 0)) {\n\t\tif (!status)\n\t\t\td_invalidate(dentry);\n\t\tdput(dentry);\n\t\treturn ERR_PTR(status);\n\t}\n\treturn dentry;\n}\n\n \nstatic struct dentry *__lookup_slow(const struct qstr *name,\n\t\t\t\t    struct dentry *dir,\n\t\t\t\t    unsigned int flags)\n{\n\tstruct dentry *dentry, *old;\n\tstruct inode *inode = dir->d_inode;\n\tDECLARE_WAIT_QUEUE_HEAD_ONSTACK(wq);\n\n\t \n\tif (unlikely(IS_DEADDIR(inode)))\n\t\treturn ERR_PTR(-ENOENT);\nagain:\n\tdentry = d_alloc_parallel(dir, name, &wq);\n\tif (IS_ERR(dentry))\n\t\treturn dentry;\n\tif (unlikely(!d_in_lookup(dentry))) {\n\t\tint error = d_revalidate(dentry, flags);\n\t\tif (unlikely(error <= 0)) {\n\t\t\tif (!error) {\n\t\t\t\td_invalidate(dentry);\n\t\t\t\tdput(dentry);\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\tdput(dentry);\n\t\t\tdentry = ERR_PTR(error);\n\t\t}\n\t} else {\n\t\told = inode->i_op->lookup(inode, dentry, flags);\n\t\td_lookup_done(dentry);\n\t\tif (unlikely(old)) {\n\t\t\tdput(dentry);\n\t\t\tdentry = old;\n\t\t}\n\t}\n\treturn dentry;\n}\n\nstatic struct dentry *lookup_slow(const struct qstr *name,\n\t\t\t\t  struct dentry *dir,\n\t\t\t\t  unsigned int flags)\n{\n\tstruct inode *inode = dir->d_inode;\n\tstruct dentry *res;\n\tinode_lock_shared(inode);\n\tres = __lookup_slow(name, dir, flags);\n\tinode_unlock_shared(inode);\n\treturn res;\n}\n\nstatic inline int may_lookup(struct mnt_idmap *idmap,\n\t\t\t     struct nameidata *nd)\n{\n\tif (nd->flags & LOOKUP_RCU) {\n\t\tint err = inode_permission(idmap, nd->inode, MAY_EXEC|MAY_NOT_BLOCK);\n\t\tif (err != -ECHILD || !try_to_unlazy(nd))\n\t\t\treturn err;\n\t}\n\treturn inode_permission(idmap, nd->inode, MAY_EXEC);\n}\n\nstatic int reserve_stack(struct nameidata *nd, struct path *link)\n{\n\tif (unlikely(nd->total_link_count++ >= MAXSYMLINKS))\n\t\treturn -ELOOP;\n\n\tif (likely(nd->depth != EMBEDDED_LEVELS))\n\t\treturn 0;\n\tif (likely(nd->stack != nd->internal))\n\t\treturn 0;\n\tif (likely(nd_alloc_stack(nd)))\n\t\treturn 0;\n\n\tif (nd->flags & LOOKUP_RCU) {\n\t\t \n\t\t \n\t\tbool grabbed_link = legitimize_path(nd, link, nd->next_seq);\n\n\t\tif (!try_to_unlazy(nd) || !grabbed_link)\n\t\t\treturn -ECHILD;\n\n\t\tif (nd_alloc_stack(nd))\n\t\t\treturn 0;\n\t}\n\treturn -ENOMEM;\n}\n\nenum {WALK_TRAILING = 1, WALK_MORE = 2, WALK_NOFOLLOW = 4};\n\nstatic const char *pick_link(struct nameidata *nd, struct path *link,\n\t\t     struct inode *inode, int flags)\n{\n\tstruct saved *last;\n\tconst char *res;\n\tint error = reserve_stack(nd, link);\n\n\tif (unlikely(error)) {\n\t\tif (!(nd->flags & LOOKUP_RCU))\n\t\t\tpath_put(link);\n\t\treturn ERR_PTR(error);\n\t}\n\tlast = nd->stack + nd->depth++;\n\tlast->link = *link;\n\tclear_delayed_call(&last->done);\n\tlast->seq = nd->next_seq;\n\n\tif (flags & WALK_TRAILING) {\n\t\terror = may_follow_link(nd, inode);\n\t\tif (unlikely(error))\n\t\t\treturn ERR_PTR(error);\n\t}\n\n\tif (unlikely(nd->flags & LOOKUP_NO_SYMLINKS) ||\n\t\t\tunlikely(link->mnt->mnt_flags & MNT_NOSYMFOLLOW))\n\t\treturn ERR_PTR(-ELOOP);\n\n\tif (!(nd->flags & LOOKUP_RCU)) {\n\t\ttouch_atime(&last->link);\n\t\tcond_resched();\n\t} else if (atime_needs_update(&last->link, inode)) {\n\t\tif (!try_to_unlazy(nd))\n\t\t\treturn ERR_PTR(-ECHILD);\n\t\ttouch_atime(&last->link);\n\t}\n\n\terror = security_inode_follow_link(link->dentry, inode,\n\t\t\t\t\t   nd->flags & LOOKUP_RCU);\n\tif (unlikely(error))\n\t\treturn ERR_PTR(error);\n\n\tres = READ_ONCE(inode->i_link);\n\tif (!res) {\n\t\tconst char * (*get)(struct dentry *, struct inode *,\n\t\t\t\tstruct delayed_call *);\n\t\tget = inode->i_op->get_link;\n\t\tif (nd->flags & LOOKUP_RCU) {\n\t\t\tres = get(NULL, inode, &last->done);\n\t\t\tif (res == ERR_PTR(-ECHILD) && try_to_unlazy(nd))\n\t\t\t\tres = get(link->dentry, inode, &last->done);\n\t\t} else {\n\t\t\tres = get(link->dentry, inode, &last->done);\n\t\t}\n\t\tif (!res)\n\t\t\tgoto all_done;\n\t\tif (IS_ERR(res))\n\t\t\treturn res;\n\t}\n\tif (*res == '/') {\n\t\terror = nd_jump_root(nd);\n\t\tif (unlikely(error))\n\t\t\treturn ERR_PTR(error);\n\t\twhile (unlikely(*++res == '/'))\n\t\t\t;\n\t}\n\tif (*res)\n\t\treturn res;\nall_done:  \n\tput_link(nd);\n\treturn NULL;\n}\n\n \nstatic const char *step_into(struct nameidata *nd, int flags,\n\t\t     struct dentry *dentry)\n{\n\tstruct path path;\n\tstruct inode *inode;\n\tint err = handle_mounts(nd, dentry, &path);\n\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\tinode = path.dentry->d_inode;\n\tif (likely(!d_is_symlink(path.dentry)) ||\n\t   ((flags & WALK_TRAILING) && !(nd->flags & LOOKUP_FOLLOW)) ||\n\t   (flags & WALK_NOFOLLOW)) {\n\t\t \n\t\tif (nd->flags & LOOKUP_RCU) {\n\t\t\tif (read_seqcount_retry(&path.dentry->d_seq, nd->next_seq))\n\t\t\t\treturn ERR_PTR(-ECHILD);\n\t\t\tif (unlikely(!inode))\n\t\t\t\treturn ERR_PTR(-ENOENT);\n\t\t} else {\n\t\t\tdput(nd->path.dentry);\n\t\t\tif (nd->path.mnt != path.mnt)\n\t\t\t\tmntput(nd->path.mnt);\n\t\t}\n\t\tnd->path = path;\n\t\tnd->inode = inode;\n\t\tnd->seq = nd->next_seq;\n\t\treturn NULL;\n\t}\n\tif (nd->flags & LOOKUP_RCU) {\n\t\t \n\t\tif (read_seqcount_retry(&path.dentry->d_seq, nd->next_seq))\n\t\t\treturn ERR_PTR(-ECHILD);\n\t} else {\n\t\tif (path.mnt == nd->path.mnt)\n\t\t\tmntget(path.mnt);\n\t}\n\treturn pick_link(nd, &path, inode, flags);\n}\n\nstatic struct dentry *follow_dotdot_rcu(struct nameidata *nd)\n{\n\tstruct dentry *parent, *old;\n\n\tif (path_equal(&nd->path, &nd->root))\n\t\tgoto in_root;\n\tif (unlikely(nd->path.dentry == nd->path.mnt->mnt_root)) {\n\t\tstruct path path;\n\t\tunsigned seq;\n\t\tif (!choose_mountpoint_rcu(real_mount(nd->path.mnt),\n\t\t\t\t\t   &nd->root, &path, &seq))\n\t\t\tgoto in_root;\n\t\tif (unlikely(nd->flags & LOOKUP_NO_XDEV))\n\t\t\treturn ERR_PTR(-ECHILD);\n\t\tnd->path = path;\n\t\tnd->inode = path.dentry->d_inode;\n\t\tnd->seq = seq;\n\t\t \n\t\tif (read_seqretry(&mount_lock, nd->m_seq))\n\t\t\treturn ERR_PTR(-ECHILD);\n\t\t \n\t}\n\told = nd->path.dentry;\n\tparent = old->d_parent;\n\tnd->next_seq = read_seqcount_begin(&parent->d_seq);\n\t \n\tif (read_seqcount_retry(&old->d_seq, nd->seq))\n\t\treturn ERR_PTR(-ECHILD);\n\tif (unlikely(!path_connected(nd->path.mnt, parent)))\n\t\treturn ERR_PTR(-ECHILD);\n\treturn parent;\nin_root:\n\tif (read_seqretry(&mount_lock, nd->m_seq))\n\t\treturn ERR_PTR(-ECHILD);\n\tif (unlikely(nd->flags & LOOKUP_BENEATH))\n\t\treturn ERR_PTR(-ECHILD);\n\tnd->next_seq = nd->seq;\n\treturn nd->path.dentry;\n}\n\nstatic struct dentry *follow_dotdot(struct nameidata *nd)\n{\n\tstruct dentry *parent;\n\n\tif (path_equal(&nd->path, &nd->root))\n\t\tgoto in_root;\n\tif (unlikely(nd->path.dentry == nd->path.mnt->mnt_root)) {\n\t\tstruct path path;\n\n\t\tif (!choose_mountpoint(real_mount(nd->path.mnt),\n\t\t\t\t       &nd->root, &path))\n\t\t\tgoto in_root;\n\t\tpath_put(&nd->path);\n\t\tnd->path = path;\n\t\tnd->inode = path.dentry->d_inode;\n\t\tif (unlikely(nd->flags & LOOKUP_NO_XDEV))\n\t\t\treturn ERR_PTR(-EXDEV);\n\t}\n\t \n\tparent = dget_parent(nd->path.dentry);\n\tif (unlikely(!path_connected(nd->path.mnt, parent))) {\n\t\tdput(parent);\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\treturn parent;\n\nin_root:\n\tif (unlikely(nd->flags & LOOKUP_BENEATH))\n\t\treturn ERR_PTR(-EXDEV);\n\treturn dget(nd->path.dentry);\n}\n\nstatic const char *handle_dots(struct nameidata *nd, int type)\n{\n\tif (type == LAST_DOTDOT) {\n\t\tconst char *error = NULL;\n\t\tstruct dentry *parent;\n\n\t\tif (!nd->root.mnt) {\n\t\t\terror = ERR_PTR(set_root(nd));\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\tif (nd->flags & LOOKUP_RCU)\n\t\t\tparent = follow_dotdot_rcu(nd);\n\t\telse\n\t\t\tparent = follow_dotdot(nd);\n\t\tif (IS_ERR(parent))\n\t\t\treturn ERR_CAST(parent);\n\t\terror = step_into(nd, WALK_NOFOLLOW, parent);\n\t\tif (unlikely(error))\n\t\t\treturn error;\n\n\t\tif (unlikely(nd->flags & LOOKUP_IS_SCOPED)) {\n\t\t\t \n\t\t\tsmp_rmb();\n\t\t\tif (__read_seqcount_retry(&mount_lock.seqcount, nd->m_seq))\n\t\t\t\treturn ERR_PTR(-EAGAIN);\n\t\t\tif (__read_seqcount_retry(&rename_lock.seqcount, nd->r_seq))\n\t\t\t\treturn ERR_PTR(-EAGAIN);\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic const char *walk_component(struct nameidata *nd, int flags)\n{\n\tstruct dentry *dentry;\n\t \n\tif (unlikely(nd->last_type != LAST_NORM)) {\n\t\tif (!(flags & WALK_MORE) && nd->depth)\n\t\t\tput_link(nd);\n\t\treturn handle_dots(nd, nd->last_type);\n\t}\n\tdentry = lookup_fast(nd);\n\tif (IS_ERR(dentry))\n\t\treturn ERR_CAST(dentry);\n\tif (unlikely(!dentry)) {\n\t\tdentry = lookup_slow(&nd->last, nd->path.dentry, nd->flags);\n\t\tif (IS_ERR(dentry))\n\t\t\treturn ERR_CAST(dentry);\n\t}\n\tif (!(flags & WALK_MORE) && nd->depth)\n\t\tput_link(nd);\n\treturn step_into(nd, flags, dentry);\n}\n\n \n#ifdef CONFIG_DCACHE_WORD_ACCESS\n\n#include <asm/word-at-a-time.h>\n\n#ifdef HASH_MIX\n\n \n\n#elif defined(CONFIG_64BIT)\n \n#define HASH_MIX(x, y, a)\t\\\n\t(\tx ^= (a),\t\\\n\ty ^= x,\tx = rol64(x,12),\\\n\tx += y,\ty = rol64(y,45),\\\n\ty *= 9\t\t\t)\n\n \nstatic inline unsigned int fold_hash(unsigned long x, unsigned long y)\n{\n\ty ^= x * GOLDEN_RATIO_64;\n\ty *= GOLDEN_RATIO_64;\n\treturn y >> 32;\n}\n\n#else\t \n\n \n#define HASH_MIX(x, y, a)\t\\\n\t(\tx ^= (a),\t\\\n\ty ^= x,\tx = rol32(x, 7),\\\n\tx += y,\ty = rol32(y,20),\\\n\ty *= 9\t\t\t)\n\nstatic inline unsigned int fold_hash(unsigned long x, unsigned long y)\n{\n\t \n\treturn __hash_32(y ^ __hash_32(x));\n}\n\n#endif\n\n \nunsigned int full_name_hash(const void *salt, const char *name, unsigned int len)\n{\n\tunsigned long a, x = 0, y = (unsigned long)salt;\n\n\tfor (;;) {\n\t\tif (!len)\n\t\t\tgoto done;\n\t\ta = load_unaligned_zeropad(name);\n\t\tif (len < sizeof(unsigned long))\n\t\t\tbreak;\n\t\tHASH_MIX(x, y, a);\n\t\tname += sizeof(unsigned long);\n\t\tlen -= sizeof(unsigned long);\n\t}\n\tx ^= a & bytemask_from_count(len);\ndone:\n\treturn fold_hash(x, y);\n}\nEXPORT_SYMBOL(full_name_hash);\n\n \nu64 hashlen_string(const void *salt, const char *name)\n{\n\tunsigned long a = 0, x = 0, y = (unsigned long)salt;\n\tunsigned long adata, mask, len;\n\tconst struct word_at_a_time constants = WORD_AT_A_TIME_CONSTANTS;\n\n\tlen = 0;\n\tgoto inside;\n\n\tdo {\n\t\tHASH_MIX(x, y, a);\n\t\tlen += sizeof(unsigned long);\ninside:\n\t\ta = load_unaligned_zeropad(name+len);\n\t} while (!has_zero(a, &adata, &constants));\n\n\tadata = prep_zero_mask(a, adata, &constants);\n\tmask = create_zero_mask(adata);\n\tx ^= a & zero_bytemask(mask);\n\n\treturn hashlen_create(fold_hash(x, y), len + find_zero(mask));\n}\nEXPORT_SYMBOL(hashlen_string);\n\n \nstatic inline u64 hash_name(const void *salt, const char *name)\n{\n\tunsigned long a = 0, b, x = 0, y = (unsigned long)salt;\n\tunsigned long adata, bdata, mask, len;\n\tconst struct word_at_a_time constants = WORD_AT_A_TIME_CONSTANTS;\n\n\tlen = 0;\n\tgoto inside;\n\n\tdo {\n\t\tHASH_MIX(x, y, a);\n\t\tlen += sizeof(unsigned long);\ninside:\n\t\ta = load_unaligned_zeropad(name+len);\n\t\tb = a ^ REPEAT_BYTE('/');\n\t} while (!(has_zero(a, &adata, &constants) | has_zero(b, &bdata, &constants)));\n\n\tadata = prep_zero_mask(a, adata, &constants);\n\tbdata = prep_zero_mask(b, bdata, &constants);\n\tmask = create_zero_mask(adata | bdata);\n\tx ^= a & zero_bytemask(mask);\n\n\treturn hashlen_create(fold_hash(x, y), len + find_zero(mask));\n}\n\n#else\t \n\n \nunsigned int full_name_hash(const void *salt, const char *name, unsigned int len)\n{\n\tunsigned long hash = init_name_hash(salt);\n\twhile (len--)\n\t\thash = partial_name_hash((unsigned char)*name++, hash);\n\treturn end_name_hash(hash);\n}\nEXPORT_SYMBOL(full_name_hash);\n\n \nu64 hashlen_string(const void *salt, const char *name)\n{\n\tunsigned long hash = init_name_hash(salt);\n\tunsigned long len = 0, c;\n\n\tc = (unsigned char)*name;\n\twhile (c) {\n\t\tlen++;\n\t\thash = partial_name_hash(c, hash);\n\t\tc = (unsigned char)name[len];\n\t}\n\treturn hashlen_create(end_name_hash(hash), len);\n}\nEXPORT_SYMBOL(hashlen_string);\n\n \nstatic inline u64 hash_name(const void *salt, const char *name)\n{\n\tunsigned long hash = init_name_hash(salt);\n\tunsigned long len = 0, c;\n\n\tc = (unsigned char)*name;\n\tdo {\n\t\tlen++;\n\t\thash = partial_name_hash(c, hash);\n\t\tc = (unsigned char)name[len];\n\t} while (c && c != '/');\n\treturn hashlen_create(end_name_hash(hash), len);\n}\n\n#endif\n\n \nstatic int link_path_walk(const char *name, struct nameidata *nd)\n{\n\tint depth = 0;  \n\tint err;\n\n\tnd->last_type = LAST_ROOT;\n\tnd->flags |= LOOKUP_PARENT;\n\tif (IS_ERR(name))\n\t\treturn PTR_ERR(name);\n\twhile (*name=='/')\n\t\tname++;\n\tif (!*name) {\n\t\tnd->dir_mode = 0;  \n\t\treturn 0;\n\t}\n\n\t \n\tfor(;;) {\n\t\tstruct mnt_idmap *idmap;\n\t\tconst char *link;\n\t\tu64 hash_len;\n\t\tint type;\n\n\t\tidmap = mnt_idmap(nd->path.mnt);\n\t\terr = may_lookup(idmap, nd);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\thash_len = hash_name(nd->path.dentry, name);\n\n\t\ttype = LAST_NORM;\n\t\tif (name[0] == '.') switch (hashlen_len(hash_len)) {\n\t\t\tcase 2:\n\t\t\t\tif (name[1] == '.') {\n\t\t\t\t\ttype = LAST_DOTDOT;\n\t\t\t\t\tnd->state |= ND_JUMPED;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\ttype = LAST_DOT;\n\t\t}\n\t\tif (likely(type == LAST_NORM)) {\n\t\t\tstruct dentry *parent = nd->path.dentry;\n\t\t\tnd->state &= ~ND_JUMPED;\n\t\t\tif (unlikely(parent->d_flags & DCACHE_OP_HASH)) {\n\t\t\t\tstruct qstr this = { { .hash_len = hash_len }, .name = name };\n\t\t\t\terr = parent->d_op->d_hash(parent, &this);\n\t\t\t\tif (err < 0)\n\t\t\t\t\treturn err;\n\t\t\t\thash_len = this.hash_len;\n\t\t\t\tname = this.name;\n\t\t\t}\n\t\t}\n\n\t\tnd->last.hash_len = hash_len;\n\t\tnd->last.name = name;\n\t\tnd->last_type = type;\n\n\t\tname += hashlen_len(hash_len);\n\t\tif (!*name)\n\t\t\tgoto OK;\n\t\t \n\t\tdo {\n\t\t\tname++;\n\t\t} while (unlikely(*name == '/'));\n\t\tif (unlikely(!*name)) {\nOK:\n\t\t\t \n\t\t\tif (!depth) {\n\t\t\t\tnd->dir_vfsuid = i_uid_into_vfsuid(idmap, nd->inode);\n\t\t\t\tnd->dir_mode = nd->inode->i_mode;\n\t\t\t\tnd->flags &= ~LOOKUP_PARENT;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t \n\t\t\tname = nd->stack[--depth].name;\n\t\t\tlink = walk_component(nd, 0);\n\t\t} else {\n\t\t\t \n\t\t\tlink = walk_component(nd, WALK_MORE);\n\t\t}\n\t\tif (unlikely(link)) {\n\t\t\tif (IS_ERR(link))\n\t\t\t\treturn PTR_ERR(link);\n\t\t\t \n\t\t\tnd->stack[depth++].name = name;\n\t\t\tname = link;\n\t\t\tcontinue;\n\t\t}\n\t\tif (unlikely(!d_can_lookup(nd->path.dentry))) {\n\t\t\tif (nd->flags & LOOKUP_RCU) {\n\t\t\t\tif (!try_to_unlazy(nd))\n\t\t\t\t\treturn -ECHILD;\n\t\t\t}\n\t\t\treturn -ENOTDIR;\n\t\t}\n\t}\n}\n\n \nstatic const char *path_init(struct nameidata *nd, unsigned flags)\n{\n\tint error;\n\tconst char *s = nd->name->name;\n\n\t \n\tif ((flags & (LOOKUP_RCU | LOOKUP_CACHED)) == LOOKUP_CACHED)\n\t\treturn ERR_PTR(-EAGAIN);\n\n\tif (!*s)\n\t\tflags &= ~LOOKUP_RCU;\n\tif (flags & LOOKUP_RCU)\n\t\trcu_read_lock();\n\telse\n\t\tnd->seq = nd->next_seq = 0;\n\n\tnd->flags = flags;\n\tnd->state |= ND_JUMPED;\n\n\tnd->m_seq = __read_seqcount_begin(&mount_lock.seqcount);\n\tnd->r_seq = __read_seqcount_begin(&rename_lock.seqcount);\n\tsmp_rmb();\n\n\tif (nd->state & ND_ROOT_PRESET) {\n\t\tstruct dentry *root = nd->root.dentry;\n\t\tstruct inode *inode = root->d_inode;\n\t\tif (*s && unlikely(!d_can_lookup(root)))\n\t\t\treturn ERR_PTR(-ENOTDIR);\n\t\tnd->path = nd->root;\n\t\tnd->inode = inode;\n\t\tif (flags & LOOKUP_RCU) {\n\t\t\tnd->seq = read_seqcount_begin(&nd->path.dentry->d_seq);\n\t\t\tnd->root_seq = nd->seq;\n\t\t} else {\n\t\t\tpath_get(&nd->path);\n\t\t}\n\t\treturn s;\n\t}\n\n\tnd->root.mnt = NULL;\n\n\t \n\tif (*s == '/' && !(flags & LOOKUP_IN_ROOT)) {\n\t\terror = nd_jump_root(nd);\n\t\tif (unlikely(error))\n\t\t\treturn ERR_PTR(error);\n\t\treturn s;\n\t}\n\n\t \n\tif (nd->dfd == AT_FDCWD) {\n\t\tif (flags & LOOKUP_RCU) {\n\t\t\tstruct fs_struct *fs = current->fs;\n\t\t\tunsigned seq;\n\n\t\t\tdo {\n\t\t\t\tseq = read_seqcount_begin(&fs->seq);\n\t\t\t\tnd->path = fs->pwd;\n\t\t\t\tnd->inode = nd->path.dentry->d_inode;\n\t\t\t\tnd->seq = __read_seqcount_begin(&nd->path.dentry->d_seq);\n\t\t\t} while (read_seqcount_retry(&fs->seq, seq));\n\t\t} else {\n\t\t\tget_fs_pwd(current->fs, &nd->path);\n\t\t\tnd->inode = nd->path.dentry->d_inode;\n\t\t}\n\t} else {\n\t\t \n\t\tstruct fd f = fdget_raw(nd->dfd);\n\t\tstruct dentry *dentry;\n\n\t\tif (!f.file)\n\t\t\treturn ERR_PTR(-EBADF);\n\n\t\tdentry = f.file->f_path.dentry;\n\n\t\tif (*s && unlikely(!d_can_lookup(dentry))) {\n\t\t\tfdput(f);\n\t\t\treturn ERR_PTR(-ENOTDIR);\n\t\t}\n\n\t\tnd->path = f.file->f_path;\n\t\tif (flags & LOOKUP_RCU) {\n\t\t\tnd->inode = nd->path.dentry->d_inode;\n\t\t\tnd->seq = read_seqcount_begin(&nd->path.dentry->d_seq);\n\t\t} else {\n\t\t\tpath_get(&nd->path);\n\t\t\tnd->inode = nd->path.dentry->d_inode;\n\t\t}\n\t\tfdput(f);\n\t}\n\n\t \n\tif (flags & LOOKUP_IS_SCOPED) {\n\t\tnd->root = nd->path;\n\t\tif (flags & LOOKUP_RCU) {\n\t\t\tnd->root_seq = nd->seq;\n\t\t} else {\n\t\t\tpath_get(&nd->root);\n\t\t\tnd->state |= ND_ROOT_GRABBED;\n\t\t}\n\t}\n\treturn s;\n}\n\nstatic inline const char *lookup_last(struct nameidata *nd)\n{\n\tif (nd->last_type == LAST_NORM && nd->last.name[nd->last.len])\n\t\tnd->flags |= LOOKUP_FOLLOW | LOOKUP_DIRECTORY;\n\n\treturn walk_component(nd, WALK_TRAILING);\n}\n\nstatic int handle_lookup_down(struct nameidata *nd)\n{\n\tif (!(nd->flags & LOOKUP_RCU))\n\t\tdget(nd->path.dentry);\n\tnd->next_seq = nd->seq;\n\treturn PTR_ERR(step_into(nd, WALK_NOFOLLOW, nd->path.dentry));\n}\n\n \nstatic int path_lookupat(struct nameidata *nd, unsigned flags, struct path *path)\n{\n\tconst char *s = path_init(nd, flags);\n\tint err;\n\n\tif (unlikely(flags & LOOKUP_DOWN) && !IS_ERR(s)) {\n\t\terr = handle_lookup_down(nd);\n\t\tif (unlikely(err < 0))\n\t\t\ts = ERR_PTR(err);\n\t}\n\n\twhile (!(err = link_path_walk(s, nd)) &&\n\t       (s = lookup_last(nd)) != NULL)\n\t\t;\n\tif (!err && unlikely(nd->flags & LOOKUP_MOUNTPOINT)) {\n\t\terr = handle_lookup_down(nd);\n\t\tnd->state &= ~ND_JUMPED; \n\t}\n\tif (!err)\n\t\terr = complete_walk(nd);\n\n\tif (!err && nd->flags & LOOKUP_DIRECTORY)\n\t\tif (!d_can_lookup(nd->path.dentry))\n\t\t\terr = -ENOTDIR;\n\tif (!err) {\n\t\t*path = nd->path;\n\t\tnd->path.mnt = NULL;\n\t\tnd->path.dentry = NULL;\n\t}\n\tterminate_walk(nd);\n\treturn err;\n}\n\nint filename_lookup(int dfd, struct filename *name, unsigned flags,\n\t\t    struct path *path, struct path *root)\n{\n\tint retval;\n\tstruct nameidata nd;\n\tif (IS_ERR(name))\n\t\treturn PTR_ERR(name);\n\tset_nameidata(&nd, dfd, name, root);\n\tretval = path_lookupat(&nd, flags | LOOKUP_RCU, path);\n\tif (unlikely(retval == -ECHILD))\n\t\tretval = path_lookupat(&nd, flags, path);\n\tif (unlikely(retval == -ESTALE))\n\t\tretval = path_lookupat(&nd, flags | LOOKUP_REVAL, path);\n\n\tif (likely(!retval))\n\t\taudit_inode(name, path->dentry,\n\t\t\t    flags & LOOKUP_MOUNTPOINT ? AUDIT_INODE_NOEVAL : 0);\n\trestore_nameidata();\n\treturn retval;\n}\n\n \nstatic int path_parentat(struct nameidata *nd, unsigned flags,\n\t\t\t\tstruct path *parent)\n{\n\tconst char *s = path_init(nd, flags);\n\tint err = link_path_walk(s, nd);\n\tif (!err)\n\t\terr = complete_walk(nd);\n\tif (!err) {\n\t\t*parent = nd->path;\n\t\tnd->path.mnt = NULL;\n\t\tnd->path.dentry = NULL;\n\t}\n\tterminate_walk(nd);\n\treturn err;\n}\n\n \nstatic int __filename_parentat(int dfd, struct filename *name,\n\t\t\t       unsigned int flags, struct path *parent,\n\t\t\t       struct qstr *last, int *type,\n\t\t\t       const struct path *root)\n{\n\tint retval;\n\tstruct nameidata nd;\n\n\tif (IS_ERR(name))\n\t\treturn PTR_ERR(name);\n\tset_nameidata(&nd, dfd, name, root);\n\tretval = path_parentat(&nd, flags | LOOKUP_RCU, parent);\n\tif (unlikely(retval == -ECHILD))\n\t\tretval = path_parentat(&nd, flags, parent);\n\tif (unlikely(retval == -ESTALE))\n\t\tretval = path_parentat(&nd, flags | LOOKUP_REVAL, parent);\n\tif (likely(!retval)) {\n\t\t*last = nd.last;\n\t\t*type = nd.last_type;\n\t\taudit_inode(name, parent->dentry, AUDIT_INODE_PARENT);\n\t}\n\trestore_nameidata();\n\treturn retval;\n}\n\nstatic int filename_parentat(int dfd, struct filename *name,\n\t\t\t     unsigned int flags, struct path *parent,\n\t\t\t     struct qstr *last, int *type)\n{\n\treturn __filename_parentat(dfd, name, flags, parent, last, type, NULL);\n}\n\n \nstatic struct dentry *__kern_path_locked(struct filename *name, struct path *path)\n{\n\tstruct dentry *d;\n\tstruct qstr last;\n\tint type, error;\n\n\terror = filename_parentat(AT_FDCWD, name, 0, path, &last, &type);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\tif (unlikely(type != LAST_NORM)) {\n\t\tpath_put(path);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tinode_lock_nested(path->dentry->d_inode, I_MUTEX_PARENT);\n\td = lookup_one_qstr_excl(&last, path->dentry, 0);\n\tif (IS_ERR(d)) {\n\t\tinode_unlock(path->dentry->d_inode);\n\t\tpath_put(path);\n\t}\n\treturn d;\n}\n\nstruct dentry *kern_path_locked(const char *name, struct path *path)\n{\n\tstruct filename *filename = getname_kernel(name);\n\tstruct dentry *res = __kern_path_locked(filename, path);\n\n\tputname(filename);\n\treturn res;\n}\n\nint kern_path(const char *name, unsigned int flags, struct path *path)\n{\n\tstruct filename *filename = getname_kernel(name);\n\tint ret = filename_lookup(AT_FDCWD, filename, flags, path, NULL);\n\n\tputname(filename);\n\treturn ret;\n\n}\nEXPORT_SYMBOL(kern_path);\n\n \nint vfs_path_parent_lookup(struct filename *filename, unsigned int flags,\n\t\t\t   struct path *parent, struct qstr *last, int *type,\n\t\t\t   const struct path *root)\n{\n\treturn  __filename_parentat(AT_FDCWD, filename, flags, parent, last,\n\t\t\t\t    type, root);\n}\nEXPORT_SYMBOL(vfs_path_parent_lookup);\n\n \nint vfs_path_lookup(struct dentry *dentry, struct vfsmount *mnt,\n\t\t    const char *name, unsigned int flags,\n\t\t    struct path *path)\n{\n\tstruct filename *filename;\n\tstruct path root = {.mnt = mnt, .dentry = dentry};\n\tint ret;\n\n\tfilename = getname_kernel(name);\n\t \n\tret = filename_lookup(AT_FDCWD, filename, flags, path, &root);\n\tputname(filename);\n\treturn ret;\n}\nEXPORT_SYMBOL(vfs_path_lookup);\n\nstatic int lookup_one_common(struct mnt_idmap *idmap,\n\t\t\t     const char *name, struct dentry *base, int len,\n\t\t\t     struct qstr *this)\n{\n\tthis->name = name;\n\tthis->len = len;\n\tthis->hash = full_name_hash(base, name, len);\n\tif (!len)\n\t\treturn -EACCES;\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn -EACCES;\n\t}\n\n\twhile (len--) {\n\t\tunsigned int c = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn -EACCES;\n\t}\n\t \n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, this);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn inode_permission(idmap, base->d_inode, MAY_EXEC);\n}\n\n \nstruct dentry *try_lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tint err;\n\n\tWARN_ON_ONCE(!inode_is_locked(base->d_inode));\n\n\terr = lookup_one_common(&nop_mnt_idmap, name, base, len, &this);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn lookup_dcache(&this, base, 0);\n}\nEXPORT_SYMBOL(try_lookup_one_len);\n\n \nstruct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct dentry *dentry;\n\tstruct qstr this;\n\tint err;\n\n\tWARN_ON_ONCE(!inode_is_locked(base->d_inode));\n\n\terr = lookup_one_common(&nop_mnt_idmap, name, base, len, &this);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tdentry = lookup_dcache(&this, base, 0);\n\treturn dentry ? dentry : __lookup_slow(&this, base, 0);\n}\nEXPORT_SYMBOL(lookup_one_len);\n\n \nstruct dentry *lookup_one(struct mnt_idmap *idmap, const char *name,\n\t\t\t  struct dentry *base, int len)\n{\n\tstruct dentry *dentry;\n\tstruct qstr this;\n\tint err;\n\n\tWARN_ON_ONCE(!inode_is_locked(base->d_inode));\n\n\terr = lookup_one_common(idmap, name, base, len, &this);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tdentry = lookup_dcache(&this, base, 0);\n\treturn dentry ? dentry : __lookup_slow(&this, base, 0);\n}\nEXPORT_SYMBOL(lookup_one);\n\n \nstruct dentry *lookup_one_unlocked(struct mnt_idmap *idmap,\n\t\t\t\t   const char *name, struct dentry *base,\n\t\t\t\t   int len)\n{\n\tstruct qstr this;\n\tint err;\n\tstruct dentry *ret;\n\n\terr = lookup_one_common(idmap, name, base, len, &this);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tret = lookup_dcache(&this, base, 0);\n\tif (!ret)\n\t\tret = lookup_slow(&this, base, 0);\n\treturn ret;\n}\nEXPORT_SYMBOL(lookup_one_unlocked);\n\n \nstruct dentry *lookup_one_positive_unlocked(struct mnt_idmap *idmap,\n\t\t\t\t\t    const char *name,\n\t\t\t\t\t    struct dentry *base, int len)\n{\n\tstruct dentry *ret = lookup_one_unlocked(idmap, name, base, len);\n\n\tif (!IS_ERR(ret) && d_flags_negative(smp_load_acquire(&ret->d_flags))) {\n\t\tdput(ret);\n\t\tret = ERR_PTR(-ENOENT);\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL(lookup_one_positive_unlocked);\n\n \nstruct dentry *lookup_one_len_unlocked(const char *name,\n\t\t\t\t       struct dentry *base, int len)\n{\n\treturn lookup_one_unlocked(&nop_mnt_idmap, name, base, len);\n}\nEXPORT_SYMBOL(lookup_one_len_unlocked);\n\n \nstruct dentry *lookup_positive_unlocked(const char *name,\n\t\t\t\t       struct dentry *base, int len)\n{\n\treturn lookup_one_positive_unlocked(&nop_mnt_idmap, name, base, len);\n}\nEXPORT_SYMBOL(lookup_positive_unlocked);\n\n#ifdef CONFIG_UNIX98_PTYS\nint path_pts(struct path *path)\n{\n\t \n\tstruct dentry *parent = dget_parent(path->dentry);\n\tstruct dentry *child;\n\tstruct qstr this = QSTR_INIT(\"pts\", 3);\n\n\tif (unlikely(!path_connected(path->mnt, parent))) {\n\t\tdput(parent);\n\t\treturn -ENOENT;\n\t}\n\tdput(path->dentry);\n\tpath->dentry = parent;\n\tchild = d_hash_and_lookup(parent, &this);\n\tif (IS_ERR_OR_NULL(child))\n\t\treturn -ENOENT;\n\n\tpath->dentry = child;\n\tdput(parent);\n\tfollow_down(path, 0);\n\treturn 0;\n}\n#endif\n\nint user_path_at_empty(int dfd, const char __user *name, unsigned flags,\n\t\t struct path *path, int *empty)\n{\n\tstruct filename *filename = getname_flags(name, flags, empty);\n\tint ret = filename_lookup(dfd, filename, flags, path, NULL);\n\n\tputname(filename);\n\treturn ret;\n}\nEXPORT_SYMBOL(user_path_at_empty);\n\nint __check_sticky(struct mnt_idmap *idmap, struct inode *dir,\n\t\t   struct inode *inode)\n{\n\tkuid_t fsuid = current_fsuid();\n\n\tif (vfsuid_eq_kuid(i_uid_into_vfsuid(idmap, inode), fsuid))\n\t\treturn 0;\n\tif (vfsuid_eq_kuid(i_uid_into_vfsuid(idmap, dir), fsuid))\n\t\treturn 0;\n\treturn !capable_wrt_inode_uidgid(idmap, inode, CAP_FOWNER);\n}\nEXPORT_SYMBOL(__check_sticky);\n\n \nstatic int may_delete(struct mnt_idmap *idmap, struct inode *dir,\n\t\t      struct dentry *victim, bool isdir)\n{\n\tstruct inode *inode = d_backing_inode(victim);\n\tint error;\n\n\tif (d_is_negative(victim))\n\t\treturn -ENOENT;\n\tBUG_ON(!inode);\n\n\tBUG_ON(victim->d_parent->d_inode != dir);\n\n\t \n\tif (!vfsuid_valid(i_uid_into_vfsuid(idmap, inode)) ||\n\t    !vfsgid_valid(i_gid_into_vfsgid(idmap, inode)))\n\t\treturn -EOVERFLOW;\n\n\taudit_inode_child(dir, victim, AUDIT_TYPE_CHILD_DELETE);\n\n\terror = inode_permission(idmap, dir, MAY_WRITE | MAY_EXEC);\n\tif (error)\n\t\treturn error;\n\tif (IS_APPEND(dir))\n\t\treturn -EPERM;\n\n\tif (check_sticky(idmap, dir, inode) || IS_APPEND(inode) ||\n\t    IS_IMMUTABLE(inode) || IS_SWAPFILE(inode) ||\n\t    HAS_UNMAPPED_ID(idmap, inode))\n\t\treturn -EPERM;\n\tif (isdir) {\n\t\tif (!d_is_dir(victim))\n\t\t\treturn -ENOTDIR;\n\t\tif (IS_ROOT(victim))\n\t\t\treturn -EBUSY;\n\t} else if (d_is_dir(victim))\n\t\treturn -EISDIR;\n\tif (IS_DEADDIR(dir))\n\t\treturn -ENOENT;\n\tif (victim->d_flags & DCACHE_NFSFS_RENAMED)\n\t\treturn -EBUSY;\n\treturn 0;\n}\n\n \nstatic inline int may_create(struct mnt_idmap *idmap,\n\t\t\t     struct inode *dir, struct dentry *child)\n{\n\taudit_inode_child(dir, child, AUDIT_TYPE_CHILD_CREATE);\n\tif (child->d_inode)\n\t\treturn -EEXIST;\n\tif (IS_DEADDIR(dir))\n\t\treturn -ENOENT;\n\tif (!fsuidgid_has_mapping(dir->i_sb, idmap))\n\t\treturn -EOVERFLOW;\n\n\treturn inode_permission(idmap, dir, MAY_WRITE | MAY_EXEC);\n}\n\nstatic struct dentry *lock_two_directories(struct dentry *p1, struct dentry *p2)\n{\n\tstruct dentry *p;\n\n\tp = d_ancestor(p2, p1);\n\tif (p) {\n\t\tinode_lock_nested(p2->d_inode, I_MUTEX_PARENT);\n\t\tinode_lock_nested(p1->d_inode, I_MUTEX_CHILD);\n\t\treturn p;\n\t}\n\n\tp = d_ancestor(p1, p2);\n\tif (p) {\n\t\tinode_lock_nested(p1->d_inode, I_MUTEX_PARENT);\n\t\tinode_lock_nested(p2->d_inode, I_MUTEX_CHILD);\n\t\treturn p;\n\t}\n\n\tlock_two_inodes(p1->d_inode, p2->d_inode,\n\t\t\tI_MUTEX_PARENT, I_MUTEX_PARENT2);\n\treturn NULL;\n}\n\n \nstruct dentry *lock_rename(struct dentry *p1, struct dentry *p2)\n{\n\tif (p1 == p2) {\n\t\tinode_lock_nested(p1->d_inode, I_MUTEX_PARENT);\n\t\treturn NULL;\n\t}\n\n\tmutex_lock(&p1->d_sb->s_vfs_rename_mutex);\n\treturn lock_two_directories(p1, p2);\n}\nEXPORT_SYMBOL(lock_rename);\n\n \nstruct dentry *lock_rename_child(struct dentry *c1, struct dentry *p2)\n{\n\tif (READ_ONCE(c1->d_parent) == p2) {\n\t\t \n\t\tinode_lock_nested(p2->d_inode, I_MUTEX_PARENT);\n\t\t \n\t\tif (likely(c1->d_parent == p2))\n\t\t\treturn NULL;\n\n\t\t \n\t\tinode_unlock(p2->d_inode);\n\t}\n\n\tmutex_lock(&c1->d_sb->s_vfs_rename_mutex);\n\t \n\tif (likely(c1->d_parent != p2))\n\t\treturn lock_two_directories(c1->d_parent, p2);\n\n\t \n\tinode_lock_nested(p2->d_inode, I_MUTEX_PARENT);\n\tmutex_unlock(&c1->d_sb->s_vfs_rename_mutex);\n\treturn NULL;\n}\nEXPORT_SYMBOL(lock_rename_child);\n\nvoid unlock_rename(struct dentry *p1, struct dentry *p2)\n{\n\tinode_unlock(p1->d_inode);\n\tif (p1 != p2) {\n\t\tinode_unlock(p2->d_inode);\n\t\tmutex_unlock(&p1->d_sb->s_vfs_rename_mutex);\n\t}\n}\nEXPORT_SYMBOL(unlock_rename);\n\n \nstatic inline umode_t mode_strip_umask(const struct inode *dir, umode_t mode)\n{\n\tif (!IS_POSIXACL(dir))\n\t\tmode &= ~current_umask();\n\treturn mode;\n}\n\n \nstatic inline umode_t vfs_prepare_mode(struct mnt_idmap *idmap,\n\t\t\t\t       const struct inode *dir, umode_t mode,\n\t\t\t\t       umode_t mask_perms, umode_t type)\n{\n\tmode = mode_strip_sgid(idmap, dir, mode);\n\tmode = mode_strip_umask(dir, mode);\n\n\t \n\tmode &= (mask_perms & ~S_IFMT);\n\tmode |= (type & S_IFMT);\n\n\treturn mode;\n}\n\n \nint vfs_create(struct mnt_idmap *idmap, struct inode *dir,\n\t       struct dentry *dentry, umode_t mode, bool want_excl)\n{\n\tint error;\n\n\terror = may_create(idmap, dir, dentry);\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->create)\n\t\treturn -EACCES;\t \n\n\tmode = vfs_prepare_mode(idmap, dir, mode, S_IALLUGO, S_IFREG);\n\terror = security_inode_create(dir, dentry, mode);\n\tif (error)\n\t\treturn error;\n\terror = dir->i_op->create(idmap, dir, dentry, mode, want_excl);\n\tif (!error)\n\t\tfsnotify_create(dir, dentry);\n\treturn error;\n}\nEXPORT_SYMBOL(vfs_create);\n\nint vfs_mkobj(struct dentry *dentry, umode_t mode,\n\t\tint (*f)(struct dentry *, umode_t, void *),\n\t\tvoid *arg)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tint error = may_create(&nop_mnt_idmap, dir, dentry);\n\tif (error)\n\t\treturn error;\n\n\tmode &= S_IALLUGO;\n\tmode |= S_IFREG;\n\terror = security_inode_create(dir, dentry, mode);\n\tif (error)\n\t\treturn error;\n\terror = f(dentry, mode, arg);\n\tif (!error)\n\t\tfsnotify_create(dir, dentry);\n\treturn error;\n}\nEXPORT_SYMBOL(vfs_mkobj);\n\nbool may_open_dev(const struct path *path)\n{\n\treturn !(path->mnt->mnt_flags & MNT_NODEV) &&\n\t\t!(path->mnt->mnt_sb->s_iflags & SB_I_NODEV);\n}\n\nstatic int may_open(struct mnt_idmap *idmap, const struct path *path,\n\t\t    int acc_mode, int flag)\n{\n\tstruct dentry *dentry = path->dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\tif (!inode)\n\t\treturn -ENOENT;\n\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFLNK:\n\t\treturn -ELOOP;\n\tcase S_IFDIR:\n\t\tif (acc_mode & MAY_WRITE)\n\t\t\treturn -EISDIR;\n\t\tif (acc_mode & MAY_EXEC)\n\t\t\treturn -EACCES;\n\t\tbreak;\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\t\tif (!may_open_dev(path))\n\t\t\treturn -EACCES;\n\t\tfallthrough;\n\tcase S_IFIFO:\n\tcase S_IFSOCK:\n\t\tif (acc_mode & MAY_EXEC)\n\t\t\treturn -EACCES;\n\t\tflag &= ~O_TRUNC;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tif ((acc_mode & MAY_EXEC) && path_noexec(path))\n\t\t\treturn -EACCES;\n\t\tbreak;\n\t}\n\n\terror = inode_permission(idmap, inode, MAY_OPEN | acc_mode);\n\tif (error)\n\t\treturn error;\n\n\t \n\tif (IS_APPEND(inode)) {\n\t\tif  ((flag & O_ACCMODE) != O_RDONLY && !(flag & O_APPEND))\n\t\t\treturn -EPERM;\n\t\tif (flag & O_TRUNC)\n\t\t\treturn -EPERM;\n\t}\n\n\t \n\tif (flag & O_NOATIME && !inode_owner_or_capable(idmap, inode))\n\t\treturn -EPERM;\n\n\treturn 0;\n}\n\nstatic int handle_truncate(struct mnt_idmap *idmap, struct file *filp)\n{\n\tconst struct path *path = &filp->f_path;\n\tstruct inode *inode = path->dentry->d_inode;\n\tint error = get_write_access(inode);\n\tif (error)\n\t\treturn error;\n\n\terror = security_file_truncate(filp);\n\tif (!error) {\n\t\terror = do_truncate(idmap, path->dentry, 0,\n\t\t\t\t    ATTR_MTIME|ATTR_CTIME|ATTR_OPEN,\n\t\t\t\t    filp);\n\t}\n\tput_write_access(inode);\n\treturn error;\n}\n\nstatic inline int open_to_namei_flags(int flag)\n{\n\tif ((flag & O_ACCMODE) == 3)\n\t\tflag--;\n\treturn flag;\n}\n\nstatic int may_o_create(struct mnt_idmap *idmap,\n\t\t\tconst struct path *dir, struct dentry *dentry,\n\t\t\tumode_t mode)\n{\n\tint error = security_path_mknod(dir, dentry, mode, 0);\n\tif (error)\n\t\treturn error;\n\n\tif (!fsuidgid_has_mapping(dir->dentry->d_sb, idmap))\n\t\treturn -EOVERFLOW;\n\n\terror = inode_permission(idmap, dir->dentry->d_inode,\n\t\t\t\t MAY_WRITE | MAY_EXEC);\n\tif (error)\n\t\treturn error;\n\n\treturn security_inode_create(dir->dentry->d_inode, dentry, mode);\n}\n\n \nstatic struct dentry *atomic_open(struct nameidata *nd, struct dentry *dentry,\n\t\t\t\t  struct file *file,\n\t\t\t\t  int open_flag, umode_t mode)\n{\n\tstruct dentry *const DENTRY_NOT_SET = (void *) -1UL;\n\tstruct inode *dir =  nd->path.dentry->d_inode;\n\tint error;\n\n\tif (nd->flags & LOOKUP_DIRECTORY)\n\t\topen_flag |= O_DIRECTORY;\n\n\tfile->f_path.dentry = DENTRY_NOT_SET;\n\tfile->f_path.mnt = nd->path.mnt;\n\terror = dir->i_op->atomic_open(dir, dentry, file,\n\t\t\t\t       open_to_namei_flags(open_flag), mode);\n\td_lookup_done(dentry);\n\tif (!error) {\n\t\tif (file->f_mode & FMODE_OPENED) {\n\t\t\tif (unlikely(dentry != file->f_path.dentry)) {\n\t\t\t\tdput(dentry);\n\t\t\t\tdentry = dget(file->f_path.dentry);\n\t\t\t}\n\t\t} else if (WARN_ON(file->f_path.dentry == DENTRY_NOT_SET)) {\n\t\t\terror = -EIO;\n\t\t} else {\n\t\t\tif (file->f_path.dentry) {\n\t\t\t\tdput(dentry);\n\t\t\t\tdentry = file->f_path.dentry;\n\t\t\t}\n\t\t\tif (unlikely(d_is_negative(dentry)))\n\t\t\t\terror = -ENOENT;\n\t\t}\n\t}\n\tif (error) {\n\t\tdput(dentry);\n\t\tdentry = ERR_PTR(error);\n\t}\n\treturn dentry;\n}\n\n \nstatic struct dentry *lookup_open(struct nameidata *nd, struct file *file,\n\t\t\t\t  const struct open_flags *op,\n\t\t\t\t  bool got_write)\n{\n\tstruct mnt_idmap *idmap;\n\tstruct dentry *dir = nd->path.dentry;\n\tstruct inode *dir_inode = dir->d_inode;\n\tint open_flag = op->open_flag;\n\tstruct dentry *dentry;\n\tint error, create_error = 0;\n\tumode_t mode = op->mode;\n\tDECLARE_WAIT_QUEUE_HEAD_ONSTACK(wq);\n\n\tif (unlikely(IS_DEADDIR(dir_inode)))\n\t\treturn ERR_PTR(-ENOENT);\n\n\tfile->f_mode &= ~FMODE_CREATED;\n\tdentry = d_lookup(dir, &nd->last);\n\tfor (;;) {\n\t\tif (!dentry) {\n\t\t\tdentry = d_alloc_parallel(dir, &nd->last, &wq);\n\t\t\tif (IS_ERR(dentry))\n\t\t\t\treturn dentry;\n\t\t}\n\t\tif (d_in_lookup(dentry))\n\t\t\tbreak;\n\n\t\terror = d_revalidate(dentry, nd->flags);\n\t\tif (likely(error > 0))\n\t\t\tbreak;\n\t\tif (error)\n\t\t\tgoto out_dput;\n\t\td_invalidate(dentry);\n\t\tdput(dentry);\n\t\tdentry = NULL;\n\t}\n\tif (dentry->d_inode) {\n\t\t \n\t\treturn dentry;\n\t}\n\n\t \n\tif (unlikely(!got_write))\n\t\topen_flag &= ~O_TRUNC;\n\tidmap = mnt_idmap(nd->path.mnt);\n\tif (open_flag & O_CREAT) {\n\t\tif (open_flag & O_EXCL)\n\t\t\topen_flag &= ~O_TRUNC;\n\t\tmode = vfs_prepare_mode(idmap, dir->d_inode, mode, mode, mode);\n\t\tif (likely(got_write))\n\t\t\tcreate_error = may_o_create(idmap, &nd->path,\n\t\t\t\t\t\t    dentry, mode);\n\t\telse\n\t\t\tcreate_error = -EROFS;\n\t}\n\tif (create_error)\n\t\topen_flag &= ~O_CREAT;\n\tif (dir_inode->i_op->atomic_open) {\n\t\tdentry = atomic_open(nd, dentry, file, open_flag, mode);\n\t\tif (unlikely(create_error) && dentry == ERR_PTR(-ENOENT))\n\t\t\tdentry = ERR_PTR(create_error);\n\t\treturn dentry;\n\t}\n\n\tif (d_in_lookup(dentry)) {\n\t\tstruct dentry *res = dir_inode->i_op->lookup(dir_inode, dentry,\n\t\t\t\t\t\t\t     nd->flags);\n\t\td_lookup_done(dentry);\n\t\tif (unlikely(res)) {\n\t\t\tif (IS_ERR(res)) {\n\t\t\t\terror = PTR_ERR(res);\n\t\t\t\tgoto out_dput;\n\t\t\t}\n\t\t\tdput(dentry);\n\t\t\tdentry = res;\n\t\t}\n\t}\n\n\t \n\tif (!dentry->d_inode && (open_flag & O_CREAT)) {\n\t\tfile->f_mode |= FMODE_CREATED;\n\t\taudit_inode_child(dir_inode, dentry, AUDIT_TYPE_CHILD_CREATE);\n\t\tif (!dir_inode->i_op->create) {\n\t\t\terror = -EACCES;\n\t\t\tgoto out_dput;\n\t\t}\n\n\t\terror = dir_inode->i_op->create(idmap, dir_inode, dentry,\n\t\t\t\t\t\tmode, open_flag & O_EXCL);\n\t\tif (error)\n\t\t\tgoto out_dput;\n\t}\n\tif (unlikely(create_error) && !dentry->d_inode) {\n\t\terror = create_error;\n\t\tgoto out_dput;\n\t}\n\treturn dentry;\n\nout_dput:\n\tdput(dentry);\n\treturn ERR_PTR(error);\n}\n\nstatic const char *open_last_lookups(struct nameidata *nd,\n\t\t   struct file *file, const struct open_flags *op)\n{\n\tstruct dentry *dir = nd->path.dentry;\n\tint open_flag = op->open_flag;\n\tbool got_write = false;\n\tstruct dentry *dentry;\n\tconst char *res;\n\n\tnd->flags |= op->intent;\n\n\tif (nd->last_type != LAST_NORM) {\n\t\tif (nd->depth)\n\t\t\tput_link(nd);\n\t\treturn handle_dots(nd, nd->last_type);\n\t}\n\n\tif (!(open_flag & O_CREAT)) {\n\t\tif (nd->last.name[nd->last.len])\n\t\t\tnd->flags |= LOOKUP_FOLLOW | LOOKUP_DIRECTORY;\n\t\t \n\t\tdentry = lookup_fast(nd);\n\t\tif (IS_ERR(dentry))\n\t\t\treturn ERR_CAST(dentry);\n\t\tif (likely(dentry))\n\t\t\tgoto finish_lookup;\n\n\t\tBUG_ON(nd->flags & LOOKUP_RCU);\n\t} else {\n\t\t \n\t\tif (nd->flags & LOOKUP_RCU) {\n\t\t\tif (!try_to_unlazy(nd))\n\t\t\t\treturn ERR_PTR(-ECHILD);\n\t\t}\n\t\taudit_inode(nd->name, dir, AUDIT_INODE_PARENT);\n\t\t \n\t\tif (unlikely(nd->last.name[nd->last.len]))\n\t\t\treturn ERR_PTR(-EISDIR);\n\t}\n\n\tif (open_flag & (O_CREAT | O_TRUNC | O_WRONLY | O_RDWR)) {\n\t\tgot_write = !mnt_want_write(nd->path.mnt);\n\t\t \n\t}\n\tif (open_flag & O_CREAT)\n\t\tinode_lock(dir->d_inode);\n\telse\n\t\tinode_lock_shared(dir->d_inode);\n\tdentry = lookup_open(nd, file, op, got_write);\n\tif (!IS_ERR(dentry) && (file->f_mode & FMODE_CREATED))\n\t\tfsnotify_create(dir->d_inode, dentry);\n\tif (open_flag & O_CREAT)\n\t\tinode_unlock(dir->d_inode);\n\telse\n\t\tinode_unlock_shared(dir->d_inode);\n\n\tif (got_write)\n\t\tmnt_drop_write(nd->path.mnt);\n\n\tif (IS_ERR(dentry))\n\t\treturn ERR_CAST(dentry);\n\n\tif (file->f_mode & (FMODE_OPENED | FMODE_CREATED)) {\n\t\tdput(nd->path.dentry);\n\t\tnd->path.dentry = dentry;\n\t\treturn NULL;\n\t}\n\nfinish_lookup:\n\tif (nd->depth)\n\t\tput_link(nd);\n\tres = step_into(nd, WALK_TRAILING, dentry);\n\tif (unlikely(res))\n\t\tnd->flags &= ~(LOOKUP_OPEN|LOOKUP_CREATE|LOOKUP_EXCL);\n\treturn res;\n}\n\n \nstatic int do_open(struct nameidata *nd,\n\t\t   struct file *file, const struct open_flags *op)\n{\n\tstruct mnt_idmap *idmap;\n\tint open_flag = op->open_flag;\n\tbool do_truncate;\n\tint acc_mode;\n\tint error;\n\n\tif (!(file->f_mode & (FMODE_OPENED | FMODE_CREATED))) {\n\t\terror = complete_walk(nd);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tif (!(file->f_mode & FMODE_CREATED))\n\t\taudit_inode(nd->name, nd->path.dentry, 0);\n\tidmap = mnt_idmap(nd->path.mnt);\n\tif (open_flag & O_CREAT) {\n\t\tif ((open_flag & O_EXCL) && !(file->f_mode & FMODE_CREATED))\n\t\t\treturn -EEXIST;\n\t\tif (d_is_dir(nd->path.dentry))\n\t\t\treturn -EISDIR;\n\t\terror = may_create_in_sticky(idmap, nd,\n\t\t\t\t\t     d_backing_inode(nd->path.dentry));\n\t\tif (unlikely(error))\n\t\t\treturn error;\n\t}\n\tif ((nd->flags & LOOKUP_DIRECTORY) && !d_can_lookup(nd->path.dentry))\n\t\treturn -ENOTDIR;\n\n\tdo_truncate = false;\n\tacc_mode = op->acc_mode;\n\tif (file->f_mode & FMODE_CREATED) {\n\t\t \n\t\topen_flag &= ~O_TRUNC;\n\t\tacc_mode = 0;\n\t} else if (d_is_reg(nd->path.dentry) && open_flag & O_TRUNC) {\n\t\terror = mnt_want_write(nd->path.mnt);\n\t\tif (error)\n\t\t\treturn error;\n\t\tdo_truncate = true;\n\t}\n\terror = may_open(idmap, &nd->path, acc_mode, open_flag);\n\tif (!error && !(file->f_mode & FMODE_OPENED))\n\t\terror = vfs_open(&nd->path, file);\n\tif (!error)\n\t\terror = ima_file_check(file, op->acc_mode);\n\tif (!error && do_truncate)\n\t\terror = handle_truncate(idmap, file);\n\tif (unlikely(error > 0)) {\n\t\tWARN_ON(1);\n\t\terror = -EINVAL;\n\t}\n\tif (do_truncate)\n\t\tmnt_drop_write(nd->path.mnt);\n\treturn error;\n}\n\n \nstatic int vfs_tmpfile(struct mnt_idmap *idmap,\n\t\t       const struct path *parentpath,\n\t\t       struct file *file, umode_t mode)\n{\n\tstruct dentry *child;\n\tstruct inode *dir = d_inode(parentpath->dentry);\n\tstruct inode *inode;\n\tint error;\n\tint open_flag = file->f_flags;\n\n\t \n\terror = inode_permission(idmap, dir, MAY_WRITE | MAY_EXEC);\n\tif (error)\n\t\treturn error;\n\tif (!dir->i_op->tmpfile)\n\t\treturn -EOPNOTSUPP;\n\tchild = d_alloc(parentpath->dentry, &slash_name);\n\tif (unlikely(!child))\n\t\treturn -ENOMEM;\n\tfile->f_path.mnt = parentpath->mnt;\n\tfile->f_path.dentry = child;\n\tmode = vfs_prepare_mode(idmap, dir, mode, mode, mode);\n\terror = dir->i_op->tmpfile(idmap, dir, file, mode);\n\tdput(child);\n\tif (error)\n\t\treturn error;\n\t \n\terror = may_open(idmap, &file->f_path, 0, file->f_flags);\n\tif (error)\n\t\treturn error;\n\tinode = file_inode(file);\n\tif (!(open_flag & O_EXCL)) {\n\t\tspin_lock(&inode->i_lock);\n\t\tinode->i_state |= I_LINKABLE;\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\tima_post_create_tmpfile(idmap, inode);\n\treturn 0;\n}\n\n \nstruct file *kernel_tmpfile_open(struct mnt_idmap *idmap,\n\t\t\t\t const struct path *parentpath,\n\t\t\t\t umode_t mode, int open_flag,\n\t\t\t\t const struct cred *cred)\n{\n\tstruct file *file;\n\tint error;\n\n\tfile = alloc_empty_file_noaccount(open_flag, cred);\n\tif (IS_ERR(file))\n\t\treturn file;\n\n\terror = vfs_tmpfile(idmap, parentpath, file, mode);\n\tif (error) {\n\t\tfput(file);\n\t\tfile = ERR_PTR(error);\n\t}\n\treturn file;\n}\nEXPORT_SYMBOL(kernel_tmpfile_open);\n\nstatic int do_tmpfile(struct nameidata *nd, unsigned flags,\n\t\tconst struct open_flags *op,\n\t\tstruct file *file)\n{\n\tstruct path path;\n\tint error = path_lookupat(nd, flags | LOOKUP_DIRECTORY, &path);\n\n\tif (unlikely(error))\n\t\treturn error;\n\terror = mnt_want_write(path.mnt);\n\tif (unlikely(error))\n\t\tgoto out;\n\terror = vfs_tmpfile(mnt_idmap(path.mnt), &path, file, op->mode);\n\tif (error)\n\t\tgoto out2;\n\taudit_inode(nd->name, file->f_path.dentry, 0);\nout2:\n\tmnt_drop_write(path.mnt);\nout:\n\tpath_put(&path);\n\treturn error;\n}\n\nstatic int do_o_path(struct nameidata *nd, unsigned flags, struct file *file)\n{\n\tstruct path path;\n\tint error = path_lookupat(nd, flags, &path);\n\tif (!error) {\n\t\taudit_inode(nd->name, path.dentry, 0);\n\t\terror = vfs_open(&path, file);\n\t\tpath_put(&path);\n\t}\n\treturn error;\n}\n\nstatic struct file *path_openat(struct nameidata *nd,\n\t\t\tconst struct open_flags *op, unsigned flags)\n{\n\tstruct file *file;\n\tint error;\n\n\tfile = alloc_empty_file(op->open_flag, current_cred());\n\tif (IS_ERR(file))\n\t\treturn file;\n\n\tif (unlikely(file->f_flags & __O_TMPFILE)) {\n\t\terror = do_tmpfile(nd, flags, op, file);\n\t} else if (unlikely(file->f_flags & O_PATH)) {\n\t\terror = do_o_path(nd, flags, file);\n\t} else {\n\t\tconst char *s = path_init(nd, flags);\n\t\twhile (!(error = link_path_walk(s, nd)) &&\n\t\t       (s = open_last_lookups(nd, file, op)) != NULL)\n\t\t\t;\n\t\tif (!error)\n\t\t\terror = do_open(nd, file, op);\n\t\tterminate_walk(nd);\n\t}\n\tif (likely(!error)) {\n\t\tif (likely(file->f_mode & FMODE_OPENED))\n\t\t\treturn file;\n\t\tWARN_ON(1);\n\t\terror = -EINVAL;\n\t}\n\tfput(file);\n\tif (error == -EOPENSTALE) {\n\t\tif (flags & LOOKUP_RCU)\n\t\t\terror = -ECHILD;\n\t\telse\n\t\t\terror = -ESTALE;\n\t}\n\treturn ERR_PTR(error);\n}\n\nstruct file *do_filp_open(int dfd, struct filename *pathname,\n\t\tconst struct open_flags *op)\n{\n\tstruct nameidata nd;\n\tint flags = op->lookup_flags;\n\tstruct file *filp;\n\n\tset_nameidata(&nd, dfd, pathname, NULL);\n\tfilp = path_openat(&nd, op, flags | LOOKUP_RCU);\n\tif (unlikely(filp == ERR_PTR(-ECHILD)))\n\t\tfilp = path_openat(&nd, op, flags);\n\tif (unlikely(filp == ERR_PTR(-ESTALE)))\n\t\tfilp = path_openat(&nd, op, flags | LOOKUP_REVAL);\n\trestore_nameidata();\n\treturn filp;\n}\n\nstruct file *do_file_open_root(const struct path *root,\n\t\tconst char *name, const struct open_flags *op)\n{\n\tstruct nameidata nd;\n\tstruct file *file;\n\tstruct filename *filename;\n\tint flags = op->lookup_flags;\n\n\tif (d_is_symlink(root->dentry) && op->intent & LOOKUP_OPEN)\n\t\treturn ERR_PTR(-ELOOP);\n\n\tfilename = getname_kernel(name);\n\tif (IS_ERR(filename))\n\t\treturn ERR_CAST(filename);\n\n\tset_nameidata(&nd, -1, filename, root);\n\tfile = path_openat(&nd, op, flags | LOOKUP_RCU);\n\tif (unlikely(file == ERR_PTR(-ECHILD)))\n\t\tfile = path_openat(&nd, op, flags);\n\tif (unlikely(file == ERR_PTR(-ESTALE)))\n\t\tfile = path_openat(&nd, op, flags | LOOKUP_REVAL);\n\trestore_nameidata();\n\tputname(filename);\n\treturn file;\n}\n\nstatic struct dentry *filename_create(int dfd, struct filename *name,\n\t\t\t\t      struct path *path, unsigned int lookup_flags)\n{\n\tstruct dentry *dentry = ERR_PTR(-EEXIST);\n\tstruct qstr last;\n\tbool want_dir = lookup_flags & LOOKUP_DIRECTORY;\n\tunsigned int reval_flag = lookup_flags & LOOKUP_REVAL;\n\tunsigned int create_flags = LOOKUP_CREATE | LOOKUP_EXCL;\n\tint type;\n\tint err2;\n\tint error;\n\n\terror = filename_parentat(dfd, name, reval_flag, path, &last, &type);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\t \n\tif (unlikely(type != LAST_NORM))\n\t\tgoto out;\n\n\t \n\terr2 = mnt_want_write(path->mnt);\n\t \n\tif (last.name[last.len] && !want_dir)\n\t\tcreate_flags = 0;\n\tinode_lock_nested(path->dentry->d_inode, I_MUTEX_PARENT);\n\tdentry = lookup_one_qstr_excl(&last, path->dentry,\n\t\t\t\t      reval_flag | create_flags);\n\tif (IS_ERR(dentry))\n\t\tgoto unlock;\n\n\terror = -EEXIST;\n\tif (d_is_positive(dentry))\n\t\tgoto fail;\n\n\t \n\tif (unlikely(!create_flags)) {\n\t\terror = -ENOENT;\n\t\tgoto fail;\n\t}\n\tif (unlikely(err2)) {\n\t\terror = err2;\n\t\tgoto fail;\n\t}\n\treturn dentry;\nfail:\n\tdput(dentry);\n\tdentry = ERR_PTR(error);\nunlock:\n\tinode_unlock(path->dentry->d_inode);\n\tif (!err2)\n\t\tmnt_drop_write(path->mnt);\nout:\n\tpath_put(path);\n\treturn dentry;\n}\n\nstruct dentry *kern_path_create(int dfd, const char *pathname,\n\t\t\t\tstruct path *path, unsigned int lookup_flags)\n{\n\tstruct filename *filename = getname_kernel(pathname);\n\tstruct dentry *res = filename_create(dfd, filename, path, lookup_flags);\n\n\tputname(filename);\n\treturn res;\n}\nEXPORT_SYMBOL(kern_path_create);\n\nvoid done_path_create(struct path *path, struct dentry *dentry)\n{\n\tdput(dentry);\n\tinode_unlock(path->dentry->d_inode);\n\tmnt_drop_write(path->mnt);\n\tpath_put(path);\n}\nEXPORT_SYMBOL(done_path_create);\n\ninline struct dentry *user_path_create(int dfd, const char __user *pathname,\n\t\t\t\tstruct path *path, unsigned int lookup_flags)\n{\n\tstruct filename *filename = getname(pathname);\n\tstruct dentry *res = filename_create(dfd, filename, path, lookup_flags);\n\n\tputname(filename);\n\treturn res;\n}\nEXPORT_SYMBOL(user_path_create);\n\n \nint vfs_mknod(struct mnt_idmap *idmap, struct inode *dir,\n\t      struct dentry *dentry, umode_t mode, dev_t dev)\n{\n\tbool is_whiteout = S_ISCHR(mode) && dev == WHITEOUT_DEV;\n\tint error = may_create(idmap, dir, dentry);\n\n\tif (error)\n\t\treturn error;\n\n\tif ((S_ISCHR(mode) || S_ISBLK(mode)) && !is_whiteout &&\n\t    !capable(CAP_MKNOD))\n\t\treturn -EPERM;\n\n\tif (!dir->i_op->mknod)\n\t\treturn -EPERM;\n\n\tmode = vfs_prepare_mode(idmap, dir, mode, mode, mode);\n\terror = devcgroup_inode_mknod(mode, dev);\n\tif (error)\n\t\treturn error;\n\n\terror = security_inode_mknod(dir, dentry, mode, dev);\n\tif (error)\n\t\treturn error;\n\n\terror = dir->i_op->mknod(idmap, dir, dentry, mode, dev);\n\tif (!error)\n\t\tfsnotify_create(dir, dentry);\n\treturn error;\n}\nEXPORT_SYMBOL(vfs_mknod);\n\nstatic int may_mknod(umode_t mode)\n{\n\tswitch (mode & S_IFMT) {\n\tcase S_IFREG:\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFIFO:\n\tcase S_IFSOCK:\n\tcase 0:  \n\t\treturn 0;\n\tcase S_IFDIR:\n\t\treturn -EPERM;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int do_mknodat(int dfd, struct filename *name, umode_t mode,\n\t\tunsigned int dev)\n{\n\tstruct mnt_idmap *idmap;\n\tstruct dentry *dentry;\n\tstruct path path;\n\tint error;\n\tunsigned int lookup_flags = 0;\n\n\terror = may_mknod(mode);\n\tif (error)\n\t\tgoto out1;\nretry:\n\tdentry = filename_create(dfd, name, &path, lookup_flags);\n\terror = PTR_ERR(dentry);\n\tif (IS_ERR(dentry))\n\t\tgoto out1;\n\n\terror = security_path_mknod(&path, dentry,\n\t\t\tmode_strip_umask(path.dentry->d_inode, mode), dev);\n\tif (error)\n\t\tgoto out2;\n\n\tidmap = mnt_idmap(path.mnt);\n\tswitch (mode & S_IFMT) {\n\t\tcase 0: case S_IFREG:\n\t\t\terror = vfs_create(idmap, path.dentry->d_inode,\n\t\t\t\t\t   dentry, mode, true);\n\t\t\tif (!error)\n\t\t\t\tima_post_path_mknod(idmap, dentry);\n\t\t\tbreak;\n\t\tcase S_IFCHR: case S_IFBLK:\n\t\t\terror = vfs_mknod(idmap, path.dentry->d_inode,\n\t\t\t\t\t  dentry, mode, new_decode_dev(dev));\n\t\t\tbreak;\n\t\tcase S_IFIFO: case S_IFSOCK:\n\t\t\terror = vfs_mknod(idmap, path.dentry->d_inode,\n\t\t\t\t\t  dentry, mode, 0);\n\t\t\tbreak;\n\t}\nout2:\n\tdone_path_create(&path, dentry);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\nout1:\n\tputname(name);\n\treturn error;\n}\n\nSYSCALL_DEFINE4(mknodat, int, dfd, const char __user *, filename, umode_t, mode,\n\t\tunsigned int, dev)\n{\n\treturn do_mknodat(dfd, getname(filename), mode, dev);\n}\n\nSYSCALL_DEFINE3(mknod, const char __user *, filename, umode_t, mode, unsigned, dev)\n{\n\treturn do_mknodat(AT_FDCWD, getname(filename), mode, dev);\n}\n\n \nint vfs_mkdir(struct mnt_idmap *idmap, struct inode *dir,\n\t      struct dentry *dentry, umode_t mode)\n{\n\tint error;\n\tunsigned max_links = dir->i_sb->s_max_links;\n\n\terror = may_create(idmap, dir, dentry);\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->mkdir)\n\t\treturn -EPERM;\n\n\tmode = vfs_prepare_mode(idmap, dir, mode, S_IRWXUGO | S_ISVTX, 0);\n\terror = security_inode_mkdir(dir, dentry, mode);\n\tif (error)\n\t\treturn error;\n\n\tif (max_links && dir->i_nlink >= max_links)\n\t\treturn -EMLINK;\n\n\terror = dir->i_op->mkdir(idmap, dir, dentry, mode);\n\tif (!error)\n\t\tfsnotify_mkdir(dir, dentry);\n\treturn error;\n}\nEXPORT_SYMBOL(vfs_mkdir);\n\nint do_mkdirat(int dfd, struct filename *name, umode_t mode)\n{\n\tstruct dentry *dentry;\n\tstruct path path;\n\tint error;\n\tunsigned int lookup_flags = LOOKUP_DIRECTORY;\n\nretry:\n\tdentry = filename_create(dfd, name, &path, lookup_flags);\n\terror = PTR_ERR(dentry);\n\tif (IS_ERR(dentry))\n\t\tgoto out_putname;\n\n\terror = security_path_mkdir(&path, dentry,\n\t\t\tmode_strip_umask(path.dentry->d_inode, mode));\n\tif (!error) {\n\t\terror = vfs_mkdir(mnt_idmap(path.mnt), path.dentry->d_inode,\n\t\t\t\t  dentry, mode);\n\t}\n\tdone_path_create(&path, dentry);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\nout_putname:\n\tputname(name);\n\treturn error;\n}\n\nSYSCALL_DEFINE3(mkdirat, int, dfd, const char __user *, pathname, umode_t, mode)\n{\n\treturn do_mkdirat(dfd, getname(pathname), mode);\n}\n\nSYSCALL_DEFINE2(mkdir, const char __user *, pathname, umode_t, mode)\n{\n\treturn do_mkdirat(AT_FDCWD, getname(pathname), mode);\n}\n\n \nint vfs_rmdir(struct mnt_idmap *idmap, struct inode *dir,\n\t\t     struct dentry *dentry)\n{\n\tint error = may_delete(idmap, dir, dentry, 1);\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->rmdir)\n\t\treturn -EPERM;\n\n\tdget(dentry);\n\tinode_lock(dentry->d_inode);\n\n\terror = -EBUSY;\n\tif (is_local_mountpoint(dentry) ||\n\t    (dentry->d_inode->i_flags & S_KERNEL_FILE))\n\t\tgoto out;\n\n\terror = security_inode_rmdir(dir, dentry);\n\tif (error)\n\t\tgoto out;\n\n\terror = dir->i_op->rmdir(dir, dentry);\n\tif (error)\n\t\tgoto out;\n\n\tshrink_dcache_parent(dentry);\n\tdentry->d_inode->i_flags |= S_DEAD;\n\tdont_mount(dentry);\n\tdetach_mounts(dentry);\n\nout:\n\tinode_unlock(dentry->d_inode);\n\tdput(dentry);\n\tif (!error)\n\t\td_delete_notify(dir, dentry);\n\treturn error;\n}\nEXPORT_SYMBOL(vfs_rmdir);\n\nint do_rmdir(int dfd, struct filename *name)\n{\n\tint error;\n\tstruct dentry *dentry;\n\tstruct path path;\n\tstruct qstr last;\n\tint type;\n\tunsigned int lookup_flags = 0;\nretry:\n\terror = filename_parentat(dfd, name, lookup_flags, &path, &last, &type);\n\tif (error)\n\t\tgoto exit1;\n\n\tswitch (type) {\n\tcase LAST_DOTDOT:\n\t\terror = -ENOTEMPTY;\n\t\tgoto exit2;\n\tcase LAST_DOT:\n\t\terror = -EINVAL;\n\t\tgoto exit2;\n\tcase LAST_ROOT:\n\t\terror = -EBUSY;\n\t\tgoto exit2;\n\t}\n\n\terror = mnt_want_write(path.mnt);\n\tif (error)\n\t\tgoto exit2;\n\n\tinode_lock_nested(path.dentry->d_inode, I_MUTEX_PARENT);\n\tdentry = lookup_one_qstr_excl(&last, path.dentry, lookup_flags);\n\terror = PTR_ERR(dentry);\n\tif (IS_ERR(dentry))\n\t\tgoto exit3;\n\tif (!dentry->d_inode) {\n\t\terror = -ENOENT;\n\t\tgoto exit4;\n\t}\n\terror = security_path_rmdir(&path, dentry);\n\tif (error)\n\t\tgoto exit4;\n\terror = vfs_rmdir(mnt_idmap(path.mnt), path.dentry->d_inode, dentry);\nexit4:\n\tdput(dentry);\nexit3:\n\tinode_unlock(path.dentry->d_inode);\n\tmnt_drop_write(path.mnt);\nexit2:\n\tpath_put(&path);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\nexit1:\n\tputname(name);\n\treturn error;\n}\n\nSYSCALL_DEFINE1(rmdir, const char __user *, pathname)\n{\n\treturn do_rmdir(AT_FDCWD, getname(pathname));\n}\n\n \nint vfs_unlink(struct mnt_idmap *idmap, struct inode *dir,\n\t       struct dentry *dentry, struct inode **delegated_inode)\n{\n\tstruct inode *target = dentry->d_inode;\n\tint error = may_delete(idmap, dir, dentry, 0);\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->unlink)\n\t\treturn -EPERM;\n\n\tinode_lock(target);\n\tif (IS_SWAPFILE(target))\n\t\terror = -EPERM;\n\telse if (is_local_mountpoint(dentry))\n\t\terror = -EBUSY;\n\telse {\n\t\terror = security_inode_unlink(dir, dentry);\n\t\tif (!error) {\n\t\t\terror = try_break_deleg(target, delegated_inode);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t\terror = dir->i_op->unlink(dir, dentry);\n\t\t\tif (!error) {\n\t\t\t\tdont_mount(dentry);\n\t\t\t\tdetach_mounts(dentry);\n\t\t\t}\n\t\t}\n\t}\nout:\n\tinode_unlock(target);\n\n\t \n\tif (!error && dentry->d_flags & DCACHE_NFSFS_RENAMED) {\n\t\tfsnotify_unlink(dir, dentry);\n\t} else if (!error) {\n\t\tfsnotify_link_count(target);\n\t\td_delete_notify(dir, dentry);\n\t}\n\n\treturn error;\n}\nEXPORT_SYMBOL(vfs_unlink);\n\n \nint do_unlinkat(int dfd, struct filename *name)\n{\n\tint error;\n\tstruct dentry *dentry;\n\tstruct path path;\n\tstruct qstr last;\n\tint type;\n\tstruct inode *inode = NULL;\n\tstruct inode *delegated_inode = NULL;\n\tunsigned int lookup_flags = 0;\nretry:\n\terror = filename_parentat(dfd, name, lookup_flags, &path, &last, &type);\n\tif (error)\n\t\tgoto exit1;\n\n\terror = -EISDIR;\n\tif (type != LAST_NORM)\n\t\tgoto exit2;\n\n\terror = mnt_want_write(path.mnt);\n\tif (error)\n\t\tgoto exit2;\nretry_deleg:\n\tinode_lock_nested(path.dentry->d_inode, I_MUTEX_PARENT);\n\tdentry = lookup_one_qstr_excl(&last, path.dentry, lookup_flags);\n\terror = PTR_ERR(dentry);\n\tif (!IS_ERR(dentry)) {\n\n\t\t \n\t\tif (last.name[last.len])\n\t\t\tgoto slashes;\n\t\tinode = dentry->d_inode;\n\t\tif (d_is_negative(dentry))\n\t\t\tgoto slashes;\n\t\tihold(inode);\n\t\terror = security_path_unlink(&path, dentry);\n\t\tif (error)\n\t\t\tgoto exit3;\n\t\terror = vfs_unlink(mnt_idmap(path.mnt), path.dentry->d_inode,\n\t\t\t\t   dentry, &delegated_inode);\nexit3:\n\t\tdput(dentry);\n\t}\n\tinode_unlock(path.dentry->d_inode);\n\tif (inode)\n\t\tiput(inode);\t \n\tinode = NULL;\n\tif (delegated_inode) {\n\t\terror = break_deleg_wait(&delegated_inode);\n\t\tif (!error)\n\t\t\tgoto retry_deleg;\n\t}\n\tmnt_drop_write(path.mnt);\nexit2:\n\tpath_put(&path);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tinode = NULL;\n\t\tgoto retry;\n\t}\nexit1:\n\tputname(name);\n\treturn error;\n\nslashes:\n\tif (d_is_negative(dentry))\n\t\terror = -ENOENT;\n\telse if (d_is_dir(dentry))\n\t\terror = -EISDIR;\n\telse\n\t\terror = -ENOTDIR;\n\tgoto exit3;\n}\n\nSYSCALL_DEFINE3(unlinkat, int, dfd, const char __user *, pathname, int, flag)\n{\n\tif ((flag & ~AT_REMOVEDIR) != 0)\n\t\treturn -EINVAL;\n\n\tif (flag & AT_REMOVEDIR)\n\t\treturn do_rmdir(dfd, getname(pathname));\n\treturn do_unlinkat(dfd, getname(pathname));\n}\n\nSYSCALL_DEFINE1(unlink, const char __user *, pathname)\n{\n\treturn do_unlinkat(AT_FDCWD, getname(pathname));\n}\n\n \nint vfs_symlink(struct mnt_idmap *idmap, struct inode *dir,\n\t\tstruct dentry *dentry, const char *oldname)\n{\n\tint error;\n\n\terror = may_create(idmap, dir, dentry);\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->symlink)\n\t\treturn -EPERM;\n\n\terror = security_inode_symlink(dir, dentry, oldname);\n\tif (error)\n\t\treturn error;\n\n\terror = dir->i_op->symlink(idmap, dir, dentry, oldname);\n\tif (!error)\n\t\tfsnotify_create(dir, dentry);\n\treturn error;\n}\nEXPORT_SYMBOL(vfs_symlink);\n\nint do_symlinkat(struct filename *from, int newdfd, struct filename *to)\n{\n\tint error;\n\tstruct dentry *dentry;\n\tstruct path path;\n\tunsigned int lookup_flags = 0;\n\n\tif (IS_ERR(from)) {\n\t\terror = PTR_ERR(from);\n\t\tgoto out_putnames;\n\t}\nretry:\n\tdentry = filename_create(newdfd, to, &path, lookup_flags);\n\terror = PTR_ERR(dentry);\n\tif (IS_ERR(dentry))\n\t\tgoto out_putnames;\n\n\terror = security_path_symlink(&path, dentry, from->name);\n\tif (!error)\n\t\terror = vfs_symlink(mnt_idmap(path.mnt), path.dentry->d_inode,\n\t\t\t\t    dentry, from->name);\n\tdone_path_create(&path, dentry);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\nout_putnames:\n\tputname(to);\n\tputname(from);\n\treturn error;\n}\n\nSYSCALL_DEFINE3(symlinkat, const char __user *, oldname,\n\t\tint, newdfd, const char __user *, newname)\n{\n\treturn do_symlinkat(getname(oldname), newdfd, getname(newname));\n}\n\nSYSCALL_DEFINE2(symlink, const char __user *, oldname, const char __user *, newname)\n{\n\treturn do_symlinkat(getname(oldname), AT_FDCWD, getname(newname));\n}\n\n \nint vfs_link(struct dentry *old_dentry, struct mnt_idmap *idmap,\n\t     struct inode *dir, struct dentry *new_dentry,\n\t     struct inode **delegated_inode)\n{\n\tstruct inode *inode = old_dentry->d_inode;\n\tunsigned max_links = dir->i_sb->s_max_links;\n\tint error;\n\n\tif (!inode)\n\t\treturn -ENOENT;\n\n\terror = may_create(idmap, dir, new_dentry);\n\tif (error)\n\t\treturn error;\n\n\tif (dir->i_sb != inode->i_sb)\n\t\treturn -EXDEV;\n\n\t \n\tif (IS_APPEND(inode) || IS_IMMUTABLE(inode))\n\t\treturn -EPERM;\n\t \n\tif (HAS_UNMAPPED_ID(idmap, inode))\n\t\treturn -EPERM;\n\tif (!dir->i_op->link)\n\t\treturn -EPERM;\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn -EPERM;\n\n\terror = security_inode_link(old_dentry, dir, new_dentry);\n\tif (error)\n\t\treturn error;\n\n\tinode_lock(inode);\n\t \n\tif (inode->i_nlink == 0 && !(inode->i_state & I_LINKABLE))\n\t\terror =  -ENOENT;\n\telse if (max_links && inode->i_nlink >= max_links)\n\t\terror = -EMLINK;\n\telse {\n\t\terror = try_break_deleg(inode, delegated_inode);\n\t\tif (!error)\n\t\t\terror = dir->i_op->link(old_dentry, dir, new_dentry);\n\t}\n\n\tif (!error && (inode->i_state & I_LINKABLE)) {\n\t\tspin_lock(&inode->i_lock);\n\t\tinode->i_state &= ~I_LINKABLE;\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\tinode_unlock(inode);\n\tif (!error)\n\t\tfsnotify_link(dir, inode, new_dentry);\n\treturn error;\n}\nEXPORT_SYMBOL(vfs_link);\n\n \nint do_linkat(int olddfd, struct filename *old, int newdfd,\n\t      struct filename *new, int flags)\n{\n\tstruct mnt_idmap *idmap;\n\tstruct dentry *new_dentry;\n\tstruct path old_path, new_path;\n\tstruct inode *delegated_inode = NULL;\n\tint how = 0;\n\tint error;\n\n\tif ((flags & ~(AT_SYMLINK_FOLLOW | AT_EMPTY_PATH)) != 0) {\n\t\terror = -EINVAL;\n\t\tgoto out_putnames;\n\t}\n\t \n\tif (flags & AT_EMPTY_PATH && !capable(CAP_DAC_READ_SEARCH)) {\n\t\terror = -ENOENT;\n\t\tgoto out_putnames;\n\t}\n\n\tif (flags & AT_SYMLINK_FOLLOW)\n\t\thow |= LOOKUP_FOLLOW;\nretry:\n\terror = filename_lookup(olddfd, old, how, &old_path, NULL);\n\tif (error)\n\t\tgoto out_putnames;\n\n\tnew_dentry = filename_create(newdfd, new, &new_path,\n\t\t\t\t\t(how & LOOKUP_REVAL));\n\terror = PTR_ERR(new_dentry);\n\tif (IS_ERR(new_dentry))\n\t\tgoto out_putpath;\n\n\terror = -EXDEV;\n\tif (old_path.mnt != new_path.mnt)\n\t\tgoto out_dput;\n\tidmap = mnt_idmap(new_path.mnt);\n\terror = may_linkat(idmap, &old_path);\n\tif (unlikely(error))\n\t\tgoto out_dput;\n\terror = security_path_link(old_path.dentry, &new_path, new_dentry);\n\tif (error)\n\t\tgoto out_dput;\n\terror = vfs_link(old_path.dentry, idmap, new_path.dentry->d_inode,\n\t\t\t new_dentry, &delegated_inode);\nout_dput:\n\tdone_path_create(&new_path, new_dentry);\n\tif (delegated_inode) {\n\t\terror = break_deleg_wait(&delegated_inode);\n\t\tif (!error) {\n\t\t\tpath_put(&old_path);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\tif (retry_estale(error, how)) {\n\t\tpath_put(&old_path);\n\t\thow |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\nout_putpath:\n\tpath_put(&old_path);\nout_putnames:\n\tputname(old);\n\tputname(new);\n\n\treturn error;\n}\n\nSYSCALL_DEFINE5(linkat, int, olddfd, const char __user *, oldname,\n\t\tint, newdfd, const char __user *, newname, int, flags)\n{\n\treturn do_linkat(olddfd, getname_uflags(oldname, flags),\n\t\tnewdfd, getname(newname), flags);\n}\n\nSYSCALL_DEFINE2(link, const char __user *, oldname, const char __user *, newname)\n{\n\treturn do_linkat(AT_FDCWD, getname(oldname), AT_FDCWD, getname(newname), 0);\n}\n\n \nint vfs_rename(struct renamedata *rd)\n{\n\tint error;\n\tstruct inode *old_dir = rd->old_dir, *new_dir = rd->new_dir;\n\tstruct dentry *old_dentry = rd->old_dentry;\n\tstruct dentry *new_dentry = rd->new_dentry;\n\tstruct inode **delegated_inode = rd->delegated_inode;\n\tunsigned int flags = rd->flags;\n\tbool is_dir = d_is_dir(old_dentry);\n\tstruct inode *source = old_dentry->d_inode;\n\tstruct inode *target = new_dentry->d_inode;\n\tbool new_is_dir = false;\n\tunsigned max_links = new_dir->i_sb->s_max_links;\n\tstruct name_snapshot old_name;\n\n\tif (source == target)\n\t\treturn 0;\n\n\terror = may_delete(rd->old_mnt_idmap, old_dir, old_dentry, is_dir);\n\tif (error)\n\t\treturn error;\n\n\tif (!target) {\n\t\terror = may_create(rd->new_mnt_idmap, new_dir, new_dentry);\n\t} else {\n\t\tnew_is_dir = d_is_dir(new_dentry);\n\n\t\tif (!(flags & RENAME_EXCHANGE))\n\t\t\terror = may_delete(rd->new_mnt_idmap, new_dir,\n\t\t\t\t\t   new_dentry, is_dir);\n\t\telse\n\t\t\terror = may_delete(rd->new_mnt_idmap, new_dir,\n\t\t\t\t\t   new_dentry, new_is_dir);\n\t}\n\tif (error)\n\t\treturn error;\n\n\tif (!old_dir->i_op->rename)\n\t\treturn -EPERM;\n\n\t \n\tif (new_dir != old_dir) {\n\t\tif (is_dir) {\n\t\t\terror = inode_permission(rd->old_mnt_idmap, source,\n\t\t\t\t\t\t MAY_WRITE);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\tif ((flags & RENAME_EXCHANGE) && new_is_dir) {\n\t\t\terror = inode_permission(rd->new_mnt_idmap, target,\n\t\t\t\t\t\t MAY_WRITE);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\terror = security_inode_rename(old_dir, old_dentry, new_dir, new_dentry,\n\t\t\t\t      flags);\n\tif (error)\n\t\treturn error;\n\n\ttake_dentry_name_snapshot(&old_name, old_dentry);\n\tdget(new_dentry);\n\t \n\tlock_two_inodes(source, target, I_MUTEX_NORMAL, I_MUTEX_NONDIR2);\n\n\terror = -EPERM;\n\tif (IS_SWAPFILE(source) || (target && IS_SWAPFILE(target)))\n\t\tgoto out;\n\n\terror = -EBUSY;\n\tif (is_local_mountpoint(old_dentry) || is_local_mountpoint(new_dentry))\n\t\tgoto out;\n\n\tif (max_links && new_dir != old_dir) {\n\t\terror = -EMLINK;\n\t\tif (is_dir && !new_is_dir && new_dir->i_nlink >= max_links)\n\t\t\tgoto out;\n\t\tif ((flags & RENAME_EXCHANGE) && !is_dir && new_is_dir &&\n\t\t    old_dir->i_nlink >= max_links)\n\t\t\tgoto out;\n\t}\n\tif (!is_dir) {\n\t\terror = try_break_deleg(source, delegated_inode);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tif (target && !new_is_dir) {\n\t\terror = try_break_deleg(target, delegated_inode);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\terror = old_dir->i_op->rename(rd->new_mnt_idmap, old_dir, old_dentry,\n\t\t\t\t      new_dir, new_dentry, flags);\n\tif (error)\n\t\tgoto out;\n\n\tif (!(flags & RENAME_EXCHANGE) && target) {\n\t\tif (is_dir) {\n\t\t\tshrink_dcache_parent(new_dentry);\n\t\t\ttarget->i_flags |= S_DEAD;\n\t\t}\n\t\tdont_mount(new_dentry);\n\t\tdetach_mounts(new_dentry);\n\t}\n\tif (!(old_dir->i_sb->s_type->fs_flags & FS_RENAME_DOES_D_MOVE)) {\n\t\tif (!(flags & RENAME_EXCHANGE))\n\t\t\td_move(old_dentry, new_dentry);\n\t\telse\n\t\t\td_exchange(old_dentry, new_dentry);\n\t}\nout:\n\tinode_unlock(source);\n\tif (target)\n\t\tinode_unlock(target);\n\tdput(new_dentry);\n\tif (!error) {\n\t\tfsnotify_move(old_dir, new_dir, &old_name.name, is_dir,\n\t\t\t      !(flags & RENAME_EXCHANGE) ? target : NULL, old_dentry);\n\t\tif (flags & RENAME_EXCHANGE) {\n\t\t\tfsnotify_move(new_dir, old_dir, &old_dentry->d_name,\n\t\t\t\t      new_is_dir, NULL, new_dentry);\n\t\t}\n\t}\n\trelease_dentry_name_snapshot(&old_name);\n\n\treturn error;\n}\nEXPORT_SYMBOL(vfs_rename);\n\nint do_renameat2(int olddfd, struct filename *from, int newdfd,\n\t\t struct filename *to, unsigned int flags)\n{\n\tstruct renamedata rd;\n\tstruct dentry *old_dentry, *new_dentry;\n\tstruct dentry *trap;\n\tstruct path old_path, new_path;\n\tstruct qstr old_last, new_last;\n\tint old_type, new_type;\n\tstruct inode *delegated_inode = NULL;\n\tunsigned int lookup_flags = 0, target_flags = LOOKUP_RENAME_TARGET;\n\tbool should_retry = false;\n\tint error = -EINVAL;\n\n\tif (flags & ~(RENAME_NOREPLACE | RENAME_EXCHANGE | RENAME_WHITEOUT))\n\t\tgoto put_names;\n\n\tif ((flags & (RENAME_NOREPLACE | RENAME_WHITEOUT)) &&\n\t    (flags & RENAME_EXCHANGE))\n\t\tgoto put_names;\n\n\tif (flags & RENAME_EXCHANGE)\n\t\ttarget_flags = 0;\n\nretry:\n\terror = filename_parentat(olddfd, from, lookup_flags, &old_path,\n\t\t\t\t  &old_last, &old_type);\n\tif (error)\n\t\tgoto put_names;\n\n\terror = filename_parentat(newdfd, to, lookup_flags, &new_path, &new_last,\n\t\t\t\t  &new_type);\n\tif (error)\n\t\tgoto exit1;\n\n\terror = -EXDEV;\n\tif (old_path.mnt != new_path.mnt)\n\t\tgoto exit2;\n\n\terror = -EBUSY;\n\tif (old_type != LAST_NORM)\n\t\tgoto exit2;\n\n\tif (flags & RENAME_NOREPLACE)\n\t\terror = -EEXIST;\n\tif (new_type != LAST_NORM)\n\t\tgoto exit2;\n\n\terror = mnt_want_write(old_path.mnt);\n\tif (error)\n\t\tgoto exit2;\n\nretry_deleg:\n\ttrap = lock_rename(new_path.dentry, old_path.dentry);\n\n\told_dentry = lookup_one_qstr_excl(&old_last, old_path.dentry,\n\t\t\t\t\t  lookup_flags);\n\terror = PTR_ERR(old_dentry);\n\tif (IS_ERR(old_dentry))\n\t\tgoto exit3;\n\t \n\terror = -ENOENT;\n\tif (d_is_negative(old_dentry))\n\t\tgoto exit4;\n\tnew_dentry = lookup_one_qstr_excl(&new_last, new_path.dentry,\n\t\t\t\t\t  lookup_flags | target_flags);\n\terror = PTR_ERR(new_dentry);\n\tif (IS_ERR(new_dentry))\n\t\tgoto exit4;\n\terror = -EEXIST;\n\tif ((flags & RENAME_NOREPLACE) && d_is_positive(new_dentry))\n\t\tgoto exit5;\n\tif (flags & RENAME_EXCHANGE) {\n\t\terror = -ENOENT;\n\t\tif (d_is_negative(new_dentry))\n\t\t\tgoto exit5;\n\n\t\tif (!d_is_dir(new_dentry)) {\n\t\t\terror = -ENOTDIR;\n\t\t\tif (new_last.name[new_last.len])\n\t\t\t\tgoto exit5;\n\t\t}\n\t}\n\t \n\tif (!d_is_dir(old_dentry)) {\n\t\terror = -ENOTDIR;\n\t\tif (old_last.name[old_last.len])\n\t\t\tgoto exit5;\n\t\tif (!(flags & RENAME_EXCHANGE) && new_last.name[new_last.len])\n\t\t\tgoto exit5;\n\t}\n\t \n\terror = -EINVAL;\n\tif (old_dentry == trap)\n\t\tgoto exit5;\n\t \n\tif (!(flags & RENAME_EXCHANGE))\n\t\terror = -ENOTEMPTY;\n\tif (new_dentry == trap)\n\t\tgoto exit5;\n\n\terror = security_path_rename(&old_path, old_dentry,\n\t\t\t\t     &new_path, new_dentry, flags);\n\tif (error)\n\t\tgoto exit5;\n\n\trd.old_dir\t   = old_path.dentry->d_inode;\n\trd.old_dentry\t   = old_dentry;\n\trd.old_mnt_idmap   = mnt_idmap(old_path.mnt);\n\trd.new_dir\t   = new_path.dentry->d_inode;\n\trd.new_dentry\t   = new_dentry;\n\trd.new_mnt_idmap   = mnt_idmap(new_path.mnt);\n\trd.delegated_inode = &delegated_inode;\n\trd.flags\t   = flags;\n\terror = vfs_rename(&rd);\nexit5:\n\tdput(new_dentry);\nexit4:\n\tdput(old_dentry);\nexit3:\n\tunlock_rename(new_path.dentry, old_path.dentry);\n\tif (delegated_inode) {\n\t\terror = break_deleg_wait(&delegated_inode);\n\t\tif (!error)\n\t\t\tgoto retry_deleg;\n\t}\n\tmnt_drop_write(old_path.mnt);\nexit2:\n\tif (retry_estale(error, lookup_flags))\n\t\tshould_retry = true;\n\tpath_put(&new_path);\nexit1:\n\tpath_put(&old_path);\n\tif (should_retry) {\n\t\tshould_retry = false;\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\nput_names:\n\tputname(from);\n\tputname(to);\n\treturn error;\n}\n\nSYSCALL_DEFINE5(renameat2, int, olddfd, const char __user *, oldname,\n\t\tint, newdfd, const char __user *, newname, unsigned int, flags)\n{\n\treturn do_renameat2(olddfd, getname(oldname), newdfd, getname(newname),\n\t\t\t\tflags);\n}\n\nSYSCALL_DEFINE4(renameat, int, olddfd, const char __user *, oldname,\n\t\tint, newdfd, const char __user *, newname)\n{\n\treturn do_renameat2(olddfd, getname(oldname), newdfd, getname(newname),\n\t\t\t\t0);\n}\n\nSYSCALL_DEFINE2(rename, const char __user *, oldname, const char __user *, newname)\n{\n\treturn do_renameat2(AT_FDCWD, getname(oldname), AT_FDCWD,\n\t\t\t\tgetname(newname), 0);\n}\n\nint readlink_copy(char __user *buffer, int buflen, const char *link)\n{\n\tint len = PTR_ERR(link);\n\tif (IS_ERR(link))\n\t\tgoto out;\n\n\tlen = strlen(link);\n\tif (len > (unsigned) buflen)\n\t\tlen = buflen;\n\tif (copy_to_user(buffer, link, len))\n\t\tlen = -EFAULT;\nout:\n\treturn len;\n}\n\n \nint vfs_readlink(struct dentry *dentry, char __user *buffer, int buflen)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tDEFINE_DELAYED_CALL(done);\n\tconst char *link;\n\tint res;\n\n\tif (unlikely(!(inode->i_opflags & IOP_DEFAULT_READLINK))) {\n\t\tif (unlikely(inode->i_op->readlink))\n\t\t\treturn inode->i_op->readlink(dentry, buffer, buflen);\n\n\t\tif (!d_is_symlink(dentry))\n\t\t\treturn -EINVAL;\n\n\t\tspin_lock(&inode->i_lock);\n\t\tinode->i_opflags |= IOP_DEFAULT_READLINK;\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\n\tlink = READ_ONCE(inode->i_link);\n\tif (!link) {\n\t\tlink = inode->i_op->get_link(dentry, inode, &done);\n\t\tif (IS_ERR(link))\n\t\t\treturn PTR_ERR(link);\n\t}\n\tres = readlink_copy(buffer, buflen, link);\n\tdo_delayed_call(&done);\n\treturn res;\n}\nEXPORT_SYMBOL(vfs_readlink);\n\n \nconst char *vfs_get_link(struct dentry *dentry, struct delayed_call *done)\n{\n\tconst char *res = ERR_PTR(-EINVAL);\n\tstruct inode *inode = d_inode(dentry);\n\n\tif (d_is_symlink(dentry)) {\n\t\tres = ERR_PTR(security_inode_readlink(dentry));\n\t\tif (!res)\n\t\t\tres = inode->i_op->get_link(dentry, inode, done);\n\t}\n\treturn res;\n}\nEXPORT_SYMBOL(vfs_get_link);\n\n \nconst char *page_get_link(struct dentry *dentry, struct inode *inode,\n\t\t\t  struct delayed_call *callback)\n{\n\tchar *kaddr;\n\tstruct page *page;\n\tstruct address_space *mapping = inode->i_mapping;\n\n\tif (!dentry) {\n\t\tpage = find_get_page(mapping, 0);\n\t\tif (!page)\n\t\t\treturn ERR_PTR(-ECHILD);\n\t\tif (!PageUptodate(page)) {\n\t\t\tput_page(page);\n\t\t\treturn ERR_PTR(-ECHILD);\n\t\t}\n\t} else {\n\t\tpage = read_mapping_page(mapping, 0, NULL);\n\t\tif (IS_ERR(page))\n\t\t\treturn (char*)page;\n\t}\n\tset_delayed_call(callback, page_put_link, page);\n\tBUG_ON(mapping_gfp_mask(mapping) & __GFP_HIGHMEM);\n\tkaddr = page_address(page);\n\tnd_terminate_link(kaddr, inode->i_size, PAGE_SIZE - 1);\n\treturn kaddr;\n}\n\nEXPORT_SYMBOL(page_get_link);\n\nvoid page_put_link(void *arg)\n{\n\tput_page(arg);\n}\nEXPORT_SYMBOL(page_put_link);\n\nint page_readlink(struct dentry *dentry, char __user *buffer, int buflen)\n{\n\tDEFINE_DELAYED_CALL(done);\n\tint res = readlink_copy(buffer, buflen,\n\t\t\t\tpage_get_link(dentry, d_inode(dentry),\n\t\t\t\t\t      &done));\n\tdo_delayed_call(&done);\n\treturn res;\n}\nEXPORT_SYMBOL(page_readlink);\n\nint page_symlink(struct inode *inode, const char *symname, int len)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tconst struct address_space_operations *aops = mapping->a_ops;\n\tbool nofs = !mapping_gfp_constraint(mapping, __GFP_FS);\n\tstruct page *page;\n\tvoid *fsdata = NULL;\n\tint err;\n\tunsigned int flags;\n\nretry:\n\tif (nofs)\n\t\tflags = memalloc_nofs_save();\n\terr = aops->write_begin(NULL, mapping, 0, len-1, &page, &fsdata);\n\tif (nofs)\n\t\tmemalloc_nofs_restore(flags);\n\tif (err)\n\t\tgoto fail;\n\n\tmemcpy(page_address(page), symname, len-1);\n\n\terr = aops->write_end(NULL, mapping, 0, len-1, len-1,\n\t\t\t\t\t\t\tpage, fsdata);\n\tif (err < 0)\n\t\tgoto fail;\n\tif (err < len-1)\n\t\tgoto retry;\n\n\tmark_inode_dirty(inode);\n\treturn 0;\nfail:\n\treturn err;\n}\nEXPORT_SYMBOL(page_symlink);\n\nconst struct inode_operations page_symlink_inode_operations = {\n\t.get_link\t= page_get_link,\n};\nEXPORT_SYMBOL(page_symlink_inode_operations);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}