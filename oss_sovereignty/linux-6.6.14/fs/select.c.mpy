{
  "module_name": "select.c",
  "hash_id": "3df6bb7a8123bd70005402e01e3494f7f3cb921be570e4663e72ae30fd8c31f5",
  "original_prompt": "Ingested from linux-6.6.14/fs/select.c",
  "human_readable_source": "\n \n\n#include <linux/compat.h>\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/personality.h>  \n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/hrtimer.h>\n#include <linux/freezer.h>\n#include <net/busy_poll.h>\n#include <linux/vmalloc.h>\n\n#include <linux/uaccess.h>\n\n\n \n\n#define MAX_SLACK\t(100 * NSEC_PER_MSEC)\n\nstatic long __estimate_accuracy(struct timespec64 *tv)\n{\n\tlong slack;\n\tint divfactor = 1000;\n\n\tif (tv->tv_sec < 0)\n\t\treturn 0;\n\n\tif (task_nice(current) > 0)\n\t\tdivfactor = divfactor / 5;\n\n\tif (tv->tv_sec > MAX_SLACK / (NSEC_PER_SEC/divfactor))\n\t\treturn MAX_SLACK;\n\n\tslack = tv->tv_nsec / divfactor;\n\tslack += tv->tv_sec * (NSEC_PER_SEC/divfactor);\n\n\tif (slack > MAX_SLACK)\n\t\treturn MAX_SLACK;\n\n\treturn slack;\n}\n\nu64 select_estimate_accuracy(struct timespec64 *tv)\n{\n\tu64 ret;\n\tstruct timespec64 now;\n\n\t \n\n\tif (rt_task(current))\n\t\treturn 0;\n\n\tktime_get_ts64(&now);\n\tnow = timespec64_sub(*tv, now);\n\tret = __estimate_accuracy(&now);\n\tif (ret < current->timer_slack_ns)\n\t\treturn current->timer_slack_ns;\n\treturn ret;\n}\n\n\n\nstruct poll_table_page {\n\tstruct poll_table_page * next;\n\tstruct poll_table_entry * entry;\n\tstruct poll_table_entry entries[];\n};\n\n#define POLL_TABLE_FULL(table) \\\n\t((unsigned long)((table)->entry+1) > PAGE_SIZE + (unsigned long)(table))\n\n \nstatic void __pollwait(struct file *filp, wait_queue_head_t *wait_address,\n\t\t       poll_table *p);\n\nvoid poll_initwait(struct poll_wqueues *pwq)\n{\n\tinit_poll_funcptr(&pwq->pt, __pollwait);\n\tpwq->polling_task = current;\n\tpwq->triggered = 0;\n\tpwq->error = 0;\n\tpwq->table = NULL;\n\tpwq->inline_index = 0;\n}\nEXPORT_SYMBOL(poll_initwait);\n\nstatic void free_poll_entry(struct poll_table_entry *entry)\n{\n\tremove_wait_queue(entry->wait_address, &entry->wait);\n\tfput(entry->filp);\n}\n\nvoid poll_freewait(struct poll_wqueues *pwq)\n{\n\tstruct poll_table_page * p = pwq->table;\n\tint i;\n\tfor (i = 0; i < pwq->inline_index; i++)\n\t\tfree_poll_entry(pwq->inline_entries + i);\n\twhile (p) {\n\t\tstruct poll_table_entry * entry;\n\t\tstruct poll_table_page *old;\n\n\t\tentry = p->entry;\n\t\tdo {\n\t\t\tentry--;\n\t\t\tfree_poll_entry(entry);\n\t\t} while (entry > p->entries);\n\t\told = p;\n\t\tp = p->next;\n\t\tfree_page((unsigned long) old);\n\t}\n}\nEXPORT_SYMBOL(poll_freewait);\n\nstatic struct poll_table_entry *poll_get_entry(struct poll_wqueues *p)\n{\n\tstruct poll_table_page *table = p->table;\n\n\tif (p->inline_index < N_INLINE_POLL_ENTRIES)\n\t\treturn p->inline_entries + p->inline_index++;\n\n\tif (!table || POLL_TABLE_FULL(table)) {\n\t\tstruct poll_table_page *new_table;\n\n\t\tnew_table = (struct poll_table_page *) __get_free_page(GFP_KERNEL);\n\t\tif (!new_table) {\n\t\t\tp->error = -ENOMEM;\n\t\t\treturn NULL;\n\t\t}\n\t\tnew_table->entry = new_table->entries;\n\t\tnew_table->next = table;\n\t\tp->table = new_table;\n\t\ttable = new_table;\n\t}\n\n\treturn table->entry++;\n}\n\nstatic int __pollwake(wait_queue_entry_t *wait, unsigned mode, int sync, void *key)\n{\n\tstruct poll_wqueues *pwq = wait->private;\n\tDECLARE_WAITQUEUE(dummy_wait, pwq->polling_task);\n\n\t \n\tsmp_wmb();\n\tpwq->triggered = 1;\n\n\t \n\treturn default_wake_function(&dummy_wait, mode, sync, key);\n}\n\nstatic int pollwake(wait_queue_entry_t *wait, unsigned mode, int sync, void *key)\n{\n\tstruct poll_table_entry *entry;\n\n\tentry = container_of(wait, struct poll_table_entry, wait);\n\tif (key && !(key_to_poll(key) & entry->key))\n\t\treturn 0;\n\treturn __pollwake(wait, mode, sync, key);\n}\n\n \nstatic void __pollwait(struct file *filp, wait_queue_head_t *wait_address,\n\t\t\t\tpoll_table *p)\n{\n\tstruct poll_wqueues *pwq = container_of(p, struct poll_wqueues, pt);\n\tstruct poll_table_entry *entry = poll_get_entry(pwq);\n\tif (!entry)\n\t\treturn;\n\tentry->filp = get_file(filp);\n\tentry->wait_address = wait_address;\n\tentry->key = p->_key;\n\tinit_waitqueue_func_entry(&entry->wait, pollwake);\n\tentry->wait.private = pwq;\n\tadd_wait_queue(wait_address, &entry->wait);\n}\n\nstatic int poll_schedule_timeout(struct poll_wqueues *pwq, int state,\n\t\t\t  ktime_t *expires, unsigned long slack)\n{\n\tint rc = -EINTR;\n\n\tset_current_state(state);\n\tif (!pwq->triggered)\n\t\trc = schedule_hrtimeout_range(expires, slack, HRTIMER_MODE_ABS);\n\t__set_current_state(TASK_RUNNING);\n\n\t \n\tsmp_store_mb(pwq->triggered, 0);\n\n\treturn rc;\n}\n\n \nint poll_select_set_timeout(struct timespec64 *to, time64_t sec, long nsec)\n{\n\tstruct timespec64 ts = {.tv_sec = sec, .tv_nsec = nsec};\n\n\tif (!timespec64_valid(&ts))\n\t\treturn -EINVAL;\n\n\t \n\tif (!sec && !nsec) {\n\t\tto->tv_sec = to->tv_nsec = 0;\n\t} else {\n\t\tktime_get_ts64(to);\n\t\t*to = timespec64_add_safe(*to, ts);\n\t}\n\treturn 0;\n}\n\nenum poll_time_type {\n\tPT_TIMEVAL = 0,\n\tPT_OLD_TIMEVAL = 1,\n\tPT_TIMESPEC = 2,\n\tPT_OLD_TIMESPEC = 3,\n};\n\nstatic int poll_select_finish(struct timespec64 *end_time,\n\t\t\t      void __user *p,\n\t\t\t      enum poll_time_type pt_type, int ret)\n{\n\tstruct timespec64 rts;\n\n\trestore_saved_sigmask_unless(ret == -ERESTARTNOHAND);\n\n\tif (!p)\n\t\treturn ret;\n\n\tif (current->personality & STICKY_TIMEOUTS)\n\t\tgoto sticky;\n\n\t \n\tif (!end_time->tv_sec && !end_time->tv_nsec)\n\t\treturn ret;\n\n\tktime_get_ts64(&rts);\n\trts = timespec64_sub(*end_time, rts);\n\tif (rts.tv_sec < 0)\n\t\trts.tv_sec = rts.tv_nsec = 0;\n\n\n\tswitch (pt_type) {\n\tcase PT_TIMEVAL:\n\t\t{\n\t\t\tstruct __kernel_old_timeval rtv;\n\n\t\t\tif (sizeof(rtv) > sizeof(rtv.tv_sec) + sizeof(rtv.tv_usec))\n\t\t\t\tmemset(&rtv, 0, sizeof(rtv));\n\t\t\trtv.tv_sec = rts.tv_sec;\n\t\t\trtv.tv_usec = rts.tv_nsec / NSEC_PER_USEC;\n\t\t\tif (!copy_to_user(p, &rtv, sizeof(rtv)))\n\t\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tcase PT_OLD_TIMEVAL:\n\t\t{\n\t\t\tstruct old_timeval32 rtv;\n\n\t\t\trtv.tv_sec = rts.tv_sec;\n\t\t\trtv.tv_usec = rts.tv_nsec / NSEC_PER_USEC;\n\t\t\tif (!copy_to_user(p, &rtv, sizeof(rtv)))\n\t\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tcase PT_TIMESPEC:\n\t\tif (!put_timespec64(&rts, p))\n\t\t\treturn ret;\n\t\tbreak;\n\tcase PT_OLD_TIMESPEC:\n\t\tif (!put_old_timespec32(&rts, p))\n\t\t\treturn ret;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\t \n\nsticky:\n\tif (ret == -ERESTARTNOHAND)\n\t\tret = -EINTR;\n\treturn ret;\n}\n\n \n\ntypedef struct {\n\tunsigned long *in, *out, *ex;\n\tunsigned long *res_in, *res_out, *res_ex;\n} fd_set_bits;\n\n \n#define FDS_BITPERLONG\t(8*sizeof(long))\n#define FDS_LONGS(nr)\t(((nr)+FDS_BITPERLONG-1)/FDS_BITPERLONG)\n#define FDS_BYTES(nr)\t(FDS_LONGS(nr)*sizeof(long))\n\n \nstatic inline\nint get_fd_set(unsigned long nr, void __user *ufdset, unsigned long *fdset)\n{\n\tnr = FDS_BYTES(nr);\n\tif (ufdset)\n\t\treturn copy_from_user(fdset, ufdset, nr) ? -EFAULT : 0;\n\n\tmemset(fdset, 0, nr);\n\treturn 0;\n}\n\nstatic inline unsigned long __must_check\nset_fd_set(unsigned long nr, void __user *ufdset, unsigned long *fdset)\n{\n\tif (ufdset)\n\t\treturn __copy_to_user(ufdset, fdset, FDS_BYTES(nr));\n\treturn 0;\n}\n\nstatic inline\nvoid zero_fd_set(unsigned long nr, unsigned long *fdset)\n{\n\tmemset(fdset, 0, FDS_BYTES(nr));\n}\n\n#define FDS_IN(fds, n)\t\t(fds->in + n)\n#define FDS_OUT(fds, n)\t\t(fds->out + n)\n#define FDS_EX(fds, n)\t\t(fds->ex + n)\n\n#define BITS(fds, n)\t(*FDS_IN(fds, n)|*FDS_OUT(fds, n)|*FDS_EX(fds, n))\n\nstatic int max_select_fd(unsigned long n, fd_set_bits *fds)\n{\n\tunsigned long *open_fds;\n\tunsigned long set;\n\tint max;\n\tstruct fdtable *fdt;\n\n\t \n\tset = ~(~0UL << (n & (BITS_PER_LONG-1)));\n\tn /= BITS_PER_LONG;\n\tfdt = files_fdtable(current->files);\n\topen_fds = fdt->open_fds + n;\n\tmax = 0;\n\tif (set) {\n\t\tset &= BITS(fds, n);\n\t\tif (set) {\n\t\t\tif (!(set & ~*open_fds))\n\t\t\t\tgoto get_max;\n\t\t\treturn -EBADF;\n\t\t}\n\t}\n\twhile (n) {\n\t\topen_fds--;\n\t\tn--;\n\t\tset = BITS(fds, n);\n\t\tif (!set)\n\t\t\tcontinue;\n\t\tif (set & ~*open_fds)\n\t\t\treturn -EBADF;\n\t\tif (max)\n\t\t\tcontinue;\nget_max:\n\t\tdo {\n\t\t\tmax++;\n\t\t\tset >>= 1;\n\t\t} while (set);\n\t\tmax += n * BITS_PER_LONG;\n\t}\n\n\treturn max;\n}\n\n#define POLLIN_SET (EPOLLRDNORM | EPOLLRDBAND | EPOLLIN | EPOLLHUP | EPOLLERR |\\\n\t\t\tEPOLLNVAL)\n#define POLLOUT_SET (EPOLLWRBAND | EPOLLWRNORM | EPOLLOUT | EPOLLERR |\\\n\t\t\t EPOLLNVAL)\n#define POLLEX_SET (EPOLLPRI | EPOLLNVAL)\n\nstatic inline void wait_key_set(poll_table *wait, unsigned long in,\n\t\t\t\tunsigned long out, unsigned long bit,\n\t\t\t\t__poll_t ll_flag)\n{\n\twait->_key = POLLEX_SET | ll_flag;\n\tif (in & bit)\n\t\twait->_key |= POLLIN_SET;\n\tif (out & bit)\n\t\twait->_key |= POLLOUT_SET;\n}\n\nstatic int do_select(int n, fd_set_bits *fds, struct timespec64 *end_time)\n{\n\tktime_t expire, *to = NULL;\n\tstruct poll_wqueues table;\n\tpoll_table *wait;\n\tint retval, i, timed_out = 0;\n\tu64 slack = 0;\n\t__poll_t busy_flag = net_busy_loop_on() ? POLL_BUSY_LOOP : 0;\n\tunsigned long busy_start = 0;\n\n\trcu_read_lock();\n\tretval = max_select_fd(n, fds);\n\trcu_read_unlock();\n\n\tif (retval < 0)\n\t\treturn retval;\n\tn = retval;\n\n\tpoll_initwait(&table);\n\twait = &table.pt;\n\tif (end_time && !end_time->tv_sec && !end_time->tv_nsec) {\n\t\twait->_qproc = NULL;\n\t\ttimed_out = 1;\n\t}\n\n\tif (end_time && !timed_out)\n\t\tslack = select_estimate_accuracy(end_time);\n\n\tretval = 0;\n\tfor (;;) {\n\t\tunsigned long *rinp, *routp, *rexp, *inp, *outp, *exp;\n\t\tbool can_busy_loop = false;\n\n\t\tinp = fds->in; outp = fds->out; exp = fds->ex;\n\t\trinp = fds->res_in; routp = fds->res_out; rexp = fds->res_ex;\n\n\t\tfor (i = 0; i < n; ++rinp, ++routp, ++rexp) {\n\t\t\tunsigned long in, out, ex, all_bits, bit = 1, j;\n\t\t\tunsigned long res_in = 0, res_out = 0, res_ex = 0;\n\t\t\t__poll_t mask;\n\n\t\t\tin = *inp++; out = *outp++; ex = *exp++;\n\t\t\tall_bits = in | out | ex;\n\t\t\tif (all_bits == 0) {\n\t\t\t\ti += BITS_PER_LONG;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (j = 0; j < BITS_PER_LONG; ++j, ++i, bit <<= 1) {\n\t\t\t\tstruct fd f;\n\t\t\t\tif (i >= n)\n\t\t\t\t\tbreak;\n\t\t\t\tif (!(bit & all_bits))\n\t\t\t\t\tcontinue;\n\t\t\t\tmask = EPOLLNVAL;\n\t\t\t\tf = fdget(i);\n\t\t\t\tif (f.file) {\n\t\t\t\t\twait_key_set(wait, in, out, bit,\n\t\t\t\t\t\t     busy_flag);\n\t\t\t\t\tmask = vfs_poll(f.file, wait);\n\n\t\t\t\t\tfdput(f);\n\t\t\t\t}\n\t\t\t\tif ((mask & POLLIN_SET) && (in & bit)) {\n\t\t\t\t\tres_in |= bit;\n\t\t\t\t\tretval++;\n\t\t\t\t\twait->_qproc = NULL;\n\t\t\t\t}\n\t\t\t\tif ((mask & POLLOUT_SET) && (out & bit)) {\n\t\t\t\t\tres_out |= bit;\n\t\t\t\t\tretval++;\n\t\t\t\t\twait->_qproc = NULL;\n\t\t\t\t}\n\t\t\t\tif ((mask & POLLEX_SET) && (ex & bit)) {\n\t\t\t\t\tres_ex |= bit;\n\t\t\t\t\tretval++;\n\t\t\t\t\twait->_qproc = NULL;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tif (retval) {\n\t\t\t\t\tcan_busy_loop = false;\n\t\t\t\t\tbusy_flag = 0;\n\n\t\t\t\t \n\t\t\t\t} else if (busy_flag & mask)\n\t\t\t\t\tcan_busy_loop = true;\n\n\t\t\t}\n\t\t\tif (res_in)\n\t\t\t\t*rinp = res_in;\n\t\t\tif (res_out)\n\t\t\t\t*routp = res_out;\n\t\t\tif (res_ex)\n\t\t\t\t*rexp = res_ex;\n\t\t\tcond_resched();\n\t\t}\n\t\twait->_qproc = NULL;\n\t\tif (retval || timed_out || signal_pending(current))\n\t\t\tbreak;\n\t\tif (table.error) {\n\t\t\tretval = table.error;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (can_busy_loop && !need_resched()) {\n\t\t\tif (!busy_start) {\n\t\t\t\tbusy_start = busy_loop_current_time();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!busy_loop_timeout(busy_start))\n\t\t\t\tcontinue;\n\t\t}\n\t\tbusy_flag = 0;\n\n\t\t \n\t\tif (end_time && !to) {\n\t\t\texpire = timespec64_to_ktime(*end_time);\n\t\t\tto = &expire;\n\t\t}\n\n\t\tif (!poll_schedule_timeout(&table, TASK_INTERRUPTIBLE,\n\t\t\t\t\t   to, slack))\n\t\t\ttimed_out = 1;\n\t}\n\n\tpoll_freewait(&table);\n\n\treturn retval;\n}\n\n \nint core_sys_select(int n, fd_set __user *inp, fd_set __user *outp,\n\t\t\t   fd_set __user *exp, struct timespec64 *end_time)\n{\n\tfd_set_bits fds;\n\tvoid *bits;\n\tint ret, max_fds;\n\tsize_t size, alloc_size;\n\tstruct fdtable *fdt;\n\t \n\tlong stack_fds[SELECT_STACK_ALLOC/sizeof(long)];\n\n\tret = -EINVAL;\n\tif (n < 0)\n\t\tgoto out_nofds;\n\n\t \n\trcu_read_lock();\n\tfdt = files_fdtable(current->files);\n\tmax_fds = fdt->max_fds;\n\trcu_read_unlock();\n\tif (n > max_fds)\n\t\tn = max_fds;\n\n\t \n\tsize = FDS_BYTES(n);\n\tbits = stack_fds;\n\tif (size > sizeof(stack_fds) / 6) {\n\t\t \n\t\tret = -ENOMEM;\n\t\tif (size > (SIZE_MAX / 6))\n\t\t\tgoto out_nofds;\n\n\t\talloc_size = 6 * size;\n\t\tbits = kvmalloc(alloc_size, GFP_KERNEL);\n\t\tif (!bits)\n\t\t\tgoto out_nofds;\n\t}\n\tfds.in      = bits;\n\tfds.out     = bits +   size;\n\tfds.ex      = bits + 2*size;\n\tfds.res_in  = bits + 3*size;\n\tfds.res_out = bits + 4*size;\n\tfds.res_ex  = bits + 5*size;\n\n\tif ((ret = get_fd_set(n, inp, fds.in)) ||\n\t    (ret = get_fd_set(n, outp, fds.out)) ||\n\t    (ret = get_fd_set(n, exp, fds.ex)))\n\t\tgoto out;\n\tzero_fd_set(n, fds.res_in);\n\tzero_fd_set(n, fds.res_out);\n\tzero_fd_set(n, fds.res_ex);\n\n\tret = do_select(n, &fds, end_time);\n\n\tif (ret < 0)\n\t\tgoto out;\n\tif (!ret) {\n\t\tret = -ERESTARTNOHAND;\n\t\tif (signal_pending(current))\n\t\t\tgoto out;\n\t\tret = 0;\n\t}\n\n\tif (set_fd_set(n, inp, fds.res_in) ||\n\t    set_fd_set(n, outp, fds.res_out) ||\n\t    set_fd_set(n, exp, fds.res_ex))\n\t\tret = -EFAULT;\n\nout:\n\tif (bits != stack_fds)\n\t\tkvfree(bits);\nout_nofds:\n\treturn ret;\n}\n\nstatic int kern_select(int n, fd_set __user *inp, fd_set __user *outp,\n\t\t       fd_set __user *exp, struct __kernel_old_timeval __user *tvp)\n{\n\tstruct timespec64 end_time, *to = NULL;\n\tstruct __kernel_old_timeval tv;\n\tint ret;\n\n\tif (tvp) {\n\t\tif (copy_from_user(&tv, tvp, sizeof(tv)))\n\t\t\treturn -EFAULT;\n\n\t\tto = &end_time;\n\t\tif (poll_select_set_timeout(to,\n\t\t\t\ttv.tv_sec + (tv.tv_usec / USEC_PER_SEC),\n\t\t\t\t(tv.tv_usec % USEC_PER_SEC) * NSEC_PER_USEC))\n\t\t\treturn -EINVAL;\n\t}\n\n\tret = core_sys_select(n, inp, outp, exp, to);\n\treturn poll_select_finish(&end_time, tvp, PT_TIMEVAL, ret);\n}\n\nSYSCALL_DEFINE5(select, int, n, fd_set __user *, inp, fd_set __user *, outp,\n\t\tfd_set __user *, exp, struct __kernel_old_timeval __user *, tvp)\n{\n\treturn kern_select(n, inp, outp, exp, tvp);\n}\n\nstatic long do_pselect(int n, fd_set __user *inp, fd_set __user *outp,\n\t\t       fd_set __user *exp, void __user *tsp,\n\t\t       const sigset_t __user *sigmask, size_t sigsetsize,\n\t\t       enum poll_time_type type)\n{\n\tstruct timespec64 ts, end_time, *to = NULL;\n\tint ret;\n\n\tif (tsp) {\n\t\tswitch (type) {\n\t\tcase PT_TIMESPEC:\n\t\t\tif (get_timespec64(&ts, tsp))\n\t\t\t\treturn -EFAULT;\n\t\t\tbreak;\n\t\tcase PT_OLD_TIMESPEC:\n\t\t\tif (get_old_timespec32(&ts, tsp))\n\t\t\t\treturn -EFAULT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\n\t\tto = &end_time;\n\t\tif (poll_select_set_timeout(to, ts.tv_sec, ts.tv_nsec))\n\t\t\treturn -EINVAL;\n\t}\n\n\tret = set_user_sigmask(sigmask, sigsetsize);\n\tif (ret)\n\t\treturn ret;\n\n\tret = core_sys_select(n, inp, outp, exp, to);\n\treturn poll_select_finish(&end_time, tsp, type, ret);\n}\n\n \nstruct sigset_argpack {\n\tsigset_t __user *p;\n\tsize_t size;\n};\n\nstatic inline int get_sigset_argpack(struct sigset_argpack *to,\n\t\t\t\t     struct sigset_argpack __user *from)\n{\n\t \n\tif (from) {\n\t\tif (!user_read_access_begin(from, sizeof(*from)))\n\t\t\treturn -EFAULT;\n\t\tunsafe_get_user(to->p, &from->p, Efault);\n\t\tunsafe_get_user(to->size, &from->size, Efault);\n\t\tuser_read_access_end();\n\t}\n\treturn 0;\nEfault:\n\tuser_access_end();\n\treturn -EFAULT;\n}\n\nSYSCALL_DEFINE6(pselect6, int, n, fd_set __user *, inp, fd_set __user *, outp,\n\t\tfd_set __user *, exp, struct __kernel_timespec __user *, tsp,\n\t\tvoid __user *, sig)\n{\n\tstruct sigset_argpack x = {NULL, 0};\n\n\tif (get_sigset_argpack(&x, sig))\n\t\treturn -EFAULT;\n\n\treturn do_pselect(n, inp, outp, exp, tsp, x.p, x.size, PT_TIMESPEC);\n}\n\n#if defined(CONFIG_COMPAT_32BIT_TIME) && !defined(CONFIG_64BIT)\n\nSYSCALL_DEFINE6(pselect6_time32, int, n, fd_set __user *, inp, fd_set __user *, outp,\n\t\tfd_set __user *, exp, struct old_timespec32 __user *, tsp,\n\t\tvoid __user *, sig)\n{\n\tstruct sigset_argpack x = {NULL, 0};\n\n\tif (get_sigset_argpack(&x, sig))\n\t\treturn -EFAULT;\n\n\treturn do_pselect(n, inp, outp, exp, tsp, x.p, x.size, PT_OLD_TIMESPEC);\n}\n\n#endif\n\n#ifdef __ARCH_WANT_SYS_OLD_SELECT\nstruct sel_arg_struct {\n\tunsigned long n;\n\tfd_set __user *inp, *outp, *exp;\n\tstruct __kernel_old_timeval __user *tvp;\n};\n\nSYSCALL_DEFINE1(old_select, struct sel_arg_struct __user *, arg)\n{\n\tstruct sel_arg_struct a;\n\n\tif (copy_from_user(&a, arg, sizeof(a)))\n\t\treturn -EFAULT;\n\treturn kern_select(a.n, a.inp, a.outp, a.exp, a.tvp);\n}\n#endif\n\nstruct poll_list {\n\tstruct poll_list *next;\n\tint len;\n\tstruct pollfd entries[];\n};\n\n#define POLLFD_PER_PAGE  ((PAGE_SIZE-sizeof(struct poll_list)) / sizeof(struct pollfd))\n\n \nstatic inline __poll_t do_pollfd(struct pollfd *pollfd, poll_table *pwait,\n\t\t\t\t     bool *can_busy_poll,\n\t\t\t\t     __poll_t busy_flag)\n{\n\tint fd = pollfd->fd;\n\t__poll_t mask = 0, filter;\n\tstruct fd f;\n\n\tif (fd < 0)\n\t\tgoto out;\n\tmask = EPOLLNVAL;\n\tf = fdget(fd);\n\tif (!f.file)\n\t\tgoto out;\n\n\t \n\tfilter = demangle_poll(pollfd->events) | EPOLLERR | EPOLLHUP;\n\tpwait->_key = filter | busy_flag;\n\tmask = vfs_poll(f.file, pwait);\n\tif (mask & busy_flag)\n\t\t*can_busy_poll = true;\n\tmask &= filter;\t\t \n\tfdput(f);\n\nout:\n\t \n\tpollfd->revents = mangle_poll(mask);\n\treturn mask;\n}\n\nstatic int do_poll(struct poll_list *list, struct poll_wqueues *wait,\n\t\t   struct timespec64 *end_time)\n{\n\tpoll_table* pt = &wait->pt;\n\tktime_t expire, *to = NULL;\n\tint timed_out = 0, count = 0;\n\tu64 slack = 0;\n\t__poll_t busy_flag = net_busy_loop_on() ? POLL_BUSY_LOOP : 0;\n\tunsigned long busy_start = 0;\n\n\t \n\tif (end_time && !end_time->tv_sec && !end_time->tv_nsec) {\n\t\tpt->_qproc = NULL;\n\t\ttimed_out = 1;\n\t}\n\n\tif (end_time && !timed_out)\n\t\tslack = select_estimate_accuracy(end_time);\n\n\tfor (;;) {\n\t\tstruct poll_list *walk;\n\t\tbool can_busy_loop = false;\n\n\t\tfor (walk = list; walk != NULL; walk = walk->next) {\n\t\t\tstruct pollfd * pfd, * pfd_end;\n\n\t\t\tpfd = walk->entries;\n\t\t\tpfd_end = pfd + walk->len;\n\t\t\tfor (; pfd != pfd_end; pfd++) {\n\t\t\t\t \n\t\t\t\tif (do_pollfd(pfd, pt, &can_busy_loop,\n\t\t\t\t\t      busy_flag)) {\n\t\t\t\t\tcount++;\n\t\t\t\t\tpt->_qproc = NULL;\n\t\t\t\t\t \n\t\t\t\t\tbusy_flag = 0;\n\t\t\t\t\tcan_busy_loop = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t \n\t\tpt->_qproc = NULL;\n\t\tif (!count) {\n\t\t\tcount = wait->error;\n\t\t\tif (signal_pending(current))\n\t\t\t\tcount = -ERESTARTNOHAND;\n\t\t}\n\t\tif (count || timed_out)\n\t\t\tbreak;\n\n\t\t \n\t\tif (can_busy_loop && !need_resched()) {\n\t\t\tif (!busy_start) {\n\t\t\t\tbusy_start = busy_loop_current_time();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!busy_loop_timeout(busy_start))\n\t\t\t\tcontinue;\n\t\t}\n\t\tbusy_flag = 0;\n\n\t\t \n\t\tif (end_time && !to) {\n\t\t\texpire = timespec64_to_ktime(*end_time);\n\t\t\tto = &expire;\n\t\t}\n\n\t\tif (!poll_schedule_timeout(wait, TASK_INTERRUPTIBLE, to, slack))\n\t\t\ttimed_out = 1;\n\t}\n\treturn count;\n}\n\n#define N_STACK_PPS ((sizeof(stack_pps) - sizeof(struct poll_list))  / \\\n\t\t\tsizeof(struct pollfd))\n\nstatic int do_sys_poll(struct pollfd __user *ufds, unsigned int nfds,\n\t\tstruct timespec64 *end_time)\n{\n\tstruct poll_wqueues table;\n\tint err = -EFAULT, fdcount, len;\n\t \n\tlong stack_pps[POLL_STACK_ALLOC/sizeof(long)];\n\tstruct poll_list *const head = (struct poll_list *)stack_pps;\n \tstruct poll_list *walk = head;\n \tunsigned long todo = nfds;\n\n\tif (nfds > rlimit(RLIMIT_NOFILE))\n\t\treturn -EINVAL;\n\n\tlen = min_t(unsigned int, nfds, N_STACK_PPS);\n\tfor (;;) {\n\t\twalk->next = NULL;\n\t\twalk->len = len;\n\t\tif (!len)\n\t\t\tbreak;\n\n\t\tif (copy_from_user(walk->entries, ufds + nfds-todo,\n\t\t\t\t\tsizeof(struct pollfd) * walk->len))\n\t\t\tgoto out_fds;\n\n\t\ttodo -= walk->len;\n\t\tif (!todo)\n\t\t\tbreak;\n\n\t\tlen = min(todo, POLLFD_PER_PAGE);\n\t\twalk = walk->next = kmalloc(struct_size(walk, entries, len),\n\t\t\t\t\t    GFP_KERNEL);\n\t\tif (!walk) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_fds;\n\t\t}\n\t}\n\n\tpoll_initwait(&table);\n\tfdcount = do_poll(head, &table, end_time);\n\tpoll_freewait(&table);\n\n\tif (!user_write_access_begin(ufds, nfds * sizeof(*ufds)))\n\t\tgoto out_fds;\n\n\tfor (walk = head; walk; walk = walk->next) {\n\t\tstruct pollfd *fds = walk->entries;\n\t\tint j;\n\n\t\tfor (j = walk->len; j; fds++, ufds++, j--)\n\t\t\tunsafe_put_user(fds->revents, &ufds->revents, Efault);\n  \t}\n\tuser_write_access_end();\n\n\terr = fdcount;\nout_fds:\n\twalk = head->next;\n\twhile (walk) {\n\t\tstruct poll_list *pos = walk;\n\t\twalk = walk->next;\n\t\tkfree(pos);\n\t}\n\n\treturn err;\n\nEfault:\n\tuser_write_access_end();\n\terr = -EFAULT;\n\tgoto out_fds;\n}\n\nstatic long do_restart_poll(struct restart_block *restart_block)\n{\n\tstruct pollfd __user *ufds = restart_block->poll.ufds;\n\tint nfds = restart_block->poll.nfds;\n\tstruct timespec64 *to = NULL, end_time;\n\tint ret;\n\n\tif (restart_block->poll.has_timeout) {\n\t\tend_time.tv_sec = restart_block->poll.tv_sec;\n\t\tend_time.tv_nsec = restart_block->poll.tv_nsec;\n\t\tto = &end_time;\n\t}\n\n\tret = do_sys_poll(ufds, nfds, to);\n\n\tif (ret == -ERESTARTNOHAND)\n\t\tret = set_restart_fn(restart_block, do_restart_poll);\n\n\treturn ret;\n}\n\nSYSCALL_DEFINE3(poll, struct pollfd __user *, ufds, unsigned int, nfds,\n\t\tint, timeout_msecs)\n{\n\tstruct timespec64 end_time, *to = NULL;\n\tint ret;\n\n\tif (timeout_msecs >= 0) {\n\t\tto = &end_time;\n\t\tpoll_select_set_timeout(to, timeout_msecs / MSEC_PER_SEC,\n\t\t\tNSEC_PER_MSEC * (timeout_msecs % MSEC_PER_SEC));\n\t}\n\n\tret = do_sys_poll(ufds, nfds, to);\n\n\tif (ret == -ERESTARTNOHAND) {\n\t\tstruct restart_block *restart_block;\n\n\t\trestart_block = &current->restart_block;\n\t\trestart_block->poll.ufds = ufds;\n\t\trestart_block->poll.nfds = nfds;\n\n\t\tif (timeout_msecs >= 0) {\n\t\t\trestart_block->poll.tv_sec = end_time.tv_sec;\n\t\t\trestart_block->poll.tv_nsec = end_time.tv_nsec;\n\t\t\trestart_block->poll.has_timeout = 1;\n\t\t} else\n\t\t\trestart_block->poll.has_timeout = 0;\n\n\t\tret = set_restart_fn(restart_block, do_restart_poll);\n\t}\n\treturn ret;\n}\n\nSYSCALL_DEFINE5(ppoll, struct pollfd __user *, ufds, unsigned int, nfds,\n\t\tstruct __kernel_timespec __user *, tsp, const sigset_t __user *, sigmask,\n\t\tsize_t, sigsetsize)\n{\n\tstruct timespec64 ts, end_time, *to = NULL;\n\tint ret;\n\n\tif (tsp) {\n\t\tif (get_timespec64(&ts, tsp))\n\t\t\treturn -EFAULT;\n\n\t\tto = &end_time;\n\t\tif (poll_select_set_timeout(to, ts.tv_sec, ts.tv_nsec))\n\t\t\treturn -EINVAL;\n\t}\n\n\tret = set_user_sigmask(sigmask, sigsetsize);\n\tif (ret)\n\t\treturn ret;\n\n\tret = do_sys_poll(ufds, nfds, to);\n\treturn poll_select_finish(&end_time, tsp, PT_TIMESPEC, ret);\n}\n\n#if defined(CONFIG_COMPAT_32BIT_TIME) && !defined(CONFIG_64BIT)\n\nSYSCALL_DEFINE5(ppoll_time32, struct pollfd __user *, ufds, unsigned int, nfds,\n\t\tstruct old_timespec32 __user *, tsp, const sigset_t __user *, sigmask,\n\t\tsize_t, sigsetsize)\n{\n\tstruct timespec64 ts, end_time, *to = NULL;\n\tint ret;\n\n\tif (tsp) {\n\t\tif (get_old_timespec32(&ts, tsp))\n\t\t\treturn -EFAULT;\n\n\t\tto = &end_time;\n\t\tif (poll_select_set_timeout(to, ts.tv_sec, ts.tv_nsec))\n\t\t\treturn -EINVAL;\n\t}\n\n\tret = set_user_sigmask(sigmask, sigsetsize);\n\tif (ret)\n\t\treturn ret;\n\n\tret = do_sys_poll(ufds, nfds, to);\n\treturn poll_select_finish(&end_time, tsp, PT_OLD_TIMESPEC, ret);\n}\n#endif\n\n#ifdef CONFIG_COMPAT\n#define __COMPAT_NFDBITS       (8 * sizeof(compat_ulong_t))\n\n \nstatic\nint compat_get_fd_set(unsigned long nr, compat_ulong_t __user *ufdset,\n\t\t\tunsigned long *fdset)\n{\n\tif (ufdset) {\n\t\treturn compat_get_bitmap(fdset, ufdset, nr);\n\t} else {\n\t\tzero_fd_set(nr, fdset);\n\t\treturn 0;\n\t}\n}\n\nstatic\nint compat_set_fd_set(unsigned long nr, compat_ulong_t __user *ufdset,\n\t\t      unsigned long *fdset)\n{\n\tif (!ufdset)\n\t\treturn 0;\n\treturn compat_put_bitmap(ufdset, fdset, nr);\n}\n\n\n \n\n \nstatic int compat_core_sys_select(int n, compat_ulong_t __user *inp,\n\tcompat_ulong_t __user *outp, compat_ulong_t __user *exp,\n\tstruct timespec64 *end_time)\n{\n\tfd_set_bits fds;\n\tvoid *bits;\n\tint size, max_fds, ret = -EINVAL;\n\tstruct fdtable *fdt;\n\tlong stack_fds[SELECT_STACK_ALLOC/sizeof(long)];\n\n\tif (n < 0)\n\t\tgoto out_nofds;\n\n\t \n\trcu_read_lock();\n\tfdt = files_fdtable(current->files);\n\tmax_fds = fdt->max_fds;\n\trcu_read_unlock();\n\tif (n > max_fds)\n\t\tn = max_fds;\n\n\t \n\tsize = FDS_BYTES(n);\n\tbits = stack_fds;\n\tif (size > sizeof(stack_fds) / 6) {\n\t\tbits = kmalloc_array(6, size, GFP_KERNEL);\n\t\tret = -ENOMEM;\n\t\tif (!bits)\n\t\t\tgoto out_nofds;\n\t}\n\tfds.in      = (unsigned long *)  bits;\n\tfds.out     = (unsigned long *) (bits +   size);\n\tfds.ex      = (unsigned long *) (bits + 2*size);\n\tfds.res_in  = (unsigned long *) (bits + 3*size);\n\tfds.res_out = (unsigned long *) (bits + 4*size);\n\tfds.res_ex  = (unsigned long *) (bits + 5*size);\n\n\tif ((ret = compat_get_fd_set(n, inp, fds.in)) ||\n\t    (ret = compat_get_fd_set(n, outp, fds.out)) ||\n\t    (ret = compat_get_fd_set(n, exp, fds.ex)))\n\t\tgoto out;\n\tzero_fd_set(n, fds.res_in);\n\tzero_fd_set(n, fds.res_out);\n\tzero_fd_set(n, fds.res_ex);\n\n\tret = do_select(n, &fds, end_time);\n\n\tif (ret < 0)\n\t\tgoto out;\n\tif (!ret) {\n\t\tret = -ERESTARTNOHAND;\n\t\tif (signal_pending(current))\n\t\t\tgoto out;\n\t\tret = 0;\n\t}\n\n\tif (compat_set_fd_set(n, inp, fds.res_in) ||\n\t    compat_set_fd_set(n, outp, fds.res_out) ||\n\t    compat_set_fd_set(n, exp, fds.res_ex))\n\t\tret = -EFAULT;\nout:\n\tif (bits != stack_fds)\n\t\tkfree(bits);\nout_nofds:\n\treturn ret;\n}\n\nstatic int do_compat_select(int n, compat_ulong_t __user *inp,\n\tcompat_ulong_t __user *outp, compat_ulong_t __user *exp,\n\tstruct old_timeval32 __user *tvp)\n{\n\tstruct timespec64 end_time, *to = NULL;\n\tstruct old_timeval32 tv;\n\tint ret;\n\n\tif (tvp) {\n\t\tif (copy_from_user(&tv, tvp, sizeof(tv)))\n\t\t\treturn -EFAULT;\n\n\t\tto = &end_time;\n\t\tif (poll_select_set_timeout(to,\n\t\t\t\ttv.tv_sec + (tv.tv_usec / USEC_PER_SEC),\n\t\t\t\t(tv.tv_usec % USEC_PER_SEC) * NSEC_PER_USEC))\n\t\t\treturn -EINVAL;\n\t}\n\n\tret = compat_core_sys_select(n, inp, outp, exp, to);\n\treturn poll_select_finish(&end_time, tvp, PT_OLD_TIMEVAL, ret);\n}\n\nCOMPAT_SYSCALL_DEFINE5(select, int, n, compat_ulong_t __user *, inp,\n\tcompat_ulong_t __user *, outp, compat_ulong_t __user *, exp,\n\tstruct old_timeval32 __user *, tvp)\n{\n\treturn do_compat_select(n, inp, outp, exp, tvp);\n}\n\nstruct compat_sel_arg_struct {\n\tcompat_ulong_t n;\n\tcompat_uptr_t inp;\n\tcompat_uptr_t outp;\n\tcompat_uptr_t exp;\n\tcompat_uptr_t tvp;\n};\n\nCOMPAT_SYSCALL_DEFINE1(old_select, struct compat_sel_arg_struct __user *, arg)\n{\n\tstruct compat_sel_arg_struct a;\n\n\tif (copy_from_user(&a, arg, sizeof(a)))\n\t\treturn -EFAULT;\n\treturn do_compat_select(a.n, compat_ptr(a.inp), compat_ptr(a.outp),\n\t\t\t\tcompat_ptr(a.exp), compat_ptr(a.tvp));\n}\n\nstatic long do_compat_pselect(int n, compat_ulong_t __user *inp,\n\tcompat_ulong_t __user *outp, compat_ulong_t __user *exp,\n\tvoid __user *tsp, compat_sigset_t __user *sigmask,\n\tcompat_size_t sigsetsize, enum poll_time_type type)\n{\n\tstruct timespec64 ts, end_time, *to = NULL;\n\tint ret;\n\n\tif (tsp) {\n\t\tswitch (type) {\n\t\tcase PT_OLD_TIMESPEC:\n\t\t\tif (get_old_timespec32(&ts, tsp))\n\t\t\t\treturn -EFAULT;\n\t\t\tbreak;\n\t\tcase PT_TIMESPEC:\n\t\t\tif (get_timespec64(&ts, tsp))\n\t\t\t\treturn -EFAULT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\n\t\tto = &end_time;\n\t\tif (poll_select_set_timeout(to, ts.tv_sec, ts.tv_nsec))\n\t\t\treturn -EINVAL;\n\t}\n\n\tret = set_compat_user_sigmask(sigmask, sigsetsize);\n\tif (ret)\n\t\treturn ret;\n\n\tret = compat_core_sys_select(n, inp, outp, exp, to);\n\treturn poll_select_finish(&end_time, tsp, type, ret);\n}\n\nstruct compat_sigset_argpack {\n\tcompat_uptr_t p;\n\tcompat_size_t size;\n};\nstatic inline int get_compat_sigset_argpack(struct compat_sigset_argpack *to,\n\t\t\t\t\t    struct compat_sigset_argpack __user *from)\n{\n\tif (from) {\n\t\tif (!user_read_access_begin(from, sizeof(*from)))\n\t\t\treturn -EFAULT;\n\t\tunsafe_get_user(to->p, &from->p, Efault);\n\t\tunsafe_get_user(to->size, &from->size, Efault);\n\t\tuser_read_access_end();\n\t}\n\treturn 0;\nEfault:\n\tuser_access_end();\n\treturn -EFAULT;\n}\n\nCOMPAT_SYSCALL_DEFINE6(pselect6_time64, int, n, compat_ulong_t __user *, inp,\n\tcompat_ulong_t __user *, outp, compat_ulong_t __user *, exp,\n\tstruct __kernel_timespec __user *, tsp, void __user *, sig)\n{\n\tstruct compat_sigset_argpack x = {0, 0};\n\n\tif (get_compat_sigset_argpack(&x, sig))\n\t\treturn -EFAULT;\n\n\treturn do_compat_pselect(n, inp, outp, exp, tsp, compat_ptr(x.p),\n\t\t\t\t x.size, PT_TIMESPEC);\n}\n\n#if defined(CONFIG_COMPAT_32BIT_TIME)\n\nCOMPAT_SYSCALL_DEFINE6(pselect6_time32, int, n, compat_ulong_t __user *, inp,\n\tcompat_ulong_t __user *, outp, compat_ulong_t __user *, exp,\n\tstruct old_timespec32 __user *, tsp, void __user *, sig)\n{\n\tstruct compat_sigset_argpack x = {0, 0};\n\n\tif (get_compat_sigset_argpack(&x, sig))\n\t\treturn -EFAULT;\n\n\treturn do_compat_pselect(n, inp, outp, exp, tsp, compat_ptr(x.p),\n\t\t\t\t x.size, PT_OLD_TIMESPEC);\n}\n\n#endif\n\n#if defined(CONFIG_COMPAT_32BIT_TIME)\nCOMPAT_SYSCALL_DEFINE5(ppoll_time32, struct pollfd __user *, ufds,\n\tunsigned int,  nfds, struct old_timespec32 __user *, tsp,\n\tconst compat_sigset_t __user *, sigmask, compat_size_t, sigsetsize)\n{\n\tstruct timespec64 ts, end_time, *to = NULL;\n\tint ret;\n\n\tif (tsp) {\n\t\tif (get_old_timespec32(&ts, tsp))\n\t\t\treturn -EFAULT;\n\n\t\tto = &end_time;\n\t\tif (poll_select_set_timeout(to, ts.tv_sec, ts.tv_nsec))\n\t\t\treturn -EINVAL;\n\t}\n\n\tret = set_compat_user_sigmask(sigmask, sigsetsize);\n\tif (ret)\n\t\treturn ret;\n\n\tret = do_sys_poll(ufds, nfds, to);\n\treturn poll_select_finish(&end_time, tsp, PT_OLD_TIMESPEC, ret);\n}\n#endif\n\n \nCOMPAT_SYSCALL_DEFINE5(ppoll_time64, struct pollfd __user *, ufds,\n\tunsigned int,  nfds, struct __kernel_timespec __user *, tsp,\n\tconst compat_sigset_t __user *, sigmask, compat_size_t, sigsetsize)\n{\n\tstruct timespec64 ts, end_time, *to = NULL;\n\tint ret;\n\n\tif (tsp) {\n\t\tif (get_timespec64(&ts, tsp))\n\t\t\treturn -EFAULT;\n\n\t\tto = &end_time;\n\t\tif (poll_select_set_timeout(to, ts.tv_sec, ts.tv_nsec))\n\t\t\treturn -EINVAL;\n\t}\n\n\tret = set_compat_user_sigmask(sigmask, sigsetsize);\n\tif (ret)\n\t\treturn ret;\n\n\tret = do_sys_poll(ufds, nfds, to);\n\treturn poll_select_finish(&end_time, tsp, PT_TIMESPEC, ret);\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}