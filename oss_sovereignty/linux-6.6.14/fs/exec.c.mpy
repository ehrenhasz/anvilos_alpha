{
  "module_name": "exec.c",
  "hash_id": "111b188ad558b54ef06132b871b36ed09522959721b03240e817aa26e6cc2566",
  "original_prompt": "Ingested from linux-6.6.14/fs/exec.c",
  "human_readable_source": "\n \n\n \n \n\n#include <linux/kernel_read_file.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/swap.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/task.h>\n#include <linux/pagemap.h>\n#include <linux/perf_event.h>\n#include <linux/highmem.h>\n#include <linux/spinlock.h>\n#include <linux/key.h>\n#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/utsname.h>\n#include <linux/pid_namespace.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/tsacct_kern.h>\n#include <linux/cn_proc.h>\n#include <linux/audit.h>\n#include <linux/kmod.h>\n#include <linux/fsnotify.h>\n#include <linux/fs_struct.h>\n#include <linux/oom.h>\n#include <linux/compat.h>\n#include <linux/vmalloc.h>\n#include <linux/io_uring.h>\n#include <linux/syscall_user_dispatch.h>\n#include <linux/coredump.h>\n#include <linux/time_namespace.h>\n#include <linux/user_events.h>\n\n#include <linux/uaccess.h>\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n\n#include <trace/events/task.h>\n#include \"internal.h\"\n\n#include <trace/events/sched.h>\n\nstatic int bprm_creds_from_file(struct linux_binprm *bprm);\n\nint suid_dumpable = 0;\n\nstatic LIST_HEAD(formats);\nstatic DEFINE_RWLOCK(binfmt_lock);\n\nvoid __register_binfmt(struct linux_binfmt * fmt, int insert)\n{\n\twrite_lock(&binfmt_lock);\n\tinsert ? list_add(&fmt->lh, &formats) :\n\t\t list_add_tail(&fmt->lh, &formats);\n\twrite_unlock(&binfmt_lock);\n}\n\nEXPORT_SYMBOL(__register_binfmt);\n\nvoid unregister_binfmt(struct linux_binfmt * fmt)\n{\n\twrite_lock(&binfmt_lock);\n\tlist_del(&fmt->lh);\n\twrite_unlock(&binfmt_lock);\n}\n\nEXPORT_SYMBOL(unregister_binfmt);\n\nstatic inline void put_binfmt(struct linux_binfmt * fmt)\n{\n\tmodule_put(fmt->module);\n}\n\nbool path_noexec(const struct path *path)\n{\n\treturn (path->mnt->mnt_flags & MNT_NOEXEC) ||\n\t       (path->mnt->mnt_sb->s_iflags & SB_I_NOEXEC);\n}\n\n#ifdef CONFIG_USELIB\n \nSYSCALL_DEFINE1(uselib, const char __user *, library)\n{\n\tstruct linux_binfmt *fmt;\n\tstruct file *file;\n\tstruct filename *tmp = getname(library);\n\tint error = PTR_ERR(tmp);\n\tstatic const struct open_flags uselib_flags = {\n\t\t.open_flag = O_LARGEFILE | O_RDONLY | __FMODE_EXEC,\n\t\t.acc_mode = MAY_READ | MAY_EXEC,\n\t\t.intent = LOOKUP_OPEN,\n\t\t.lookup_flags = LOOKUP_FOLLOW,\n\t};\n\n\tif (IS_ERR(tmp))\n\t\tgoto out;\n\n\tfile = do_filp_open(AT_FDCWD, tmp, &uselib_flags);\n\tputname(tmp);\n\terror = PTR_ERR(file);\n\tif (IS_ERR(file))\n\t\tgoto out;\n\n\t \n\terror = -EACCES;\n\tif (WARN_ON_ONCE(!S_ISREG(file_inode(file)->i_mode) ||\n\t\t\t path_noexec(&file->f_path)))\n\t\tgoto exit;\n\n\terror = -ENOEXEC;\n\n\tread_lock(&binfmt_lock);\n\tlist_for_each_entry(fmt, &formats, lh) {\n\t\tif (!fmt->load_shlib)\n\t\t\tcontinue;\n\t\tif (!try_module_get(fmt->module))\n\t\t\tcontinue;\n\t\tread_unlock(&binfmt_lock);\n\t\terror = fmt->load_shlib(file);\n\t\tread_lock(&binfmt_lock);\n\t\tput_binfmt(fmt);\n\t\tif (error != -ENOEXEC)\n\t\t\tbreak;\n\t}\n\tread_unlock(&binfmt_lock);\nexit:\n\tfput(file);\nout:\n\treturn error;\n}\n#endif  \n\n#ifdef CONFIG_MMU\n \nstatic void acct_arg_size(struct linux_binprm *bprm, unsigned long pages)\n{\n\tstruct mm_struct *mm = current->mm;\n\tlong diff = (long)(pages - bprm->vma_pages);\n\n\tif (!mm || !diff)\n\t\treturn;\n\n\tbprm->vma_pages = pages;\n\tadd_mm_counter(mm, MM_ANONPAGES, diff);\n}\n\nstatic struct page *get_arg_page(struct linux_binprm *bprm, unsigned long pos,\n\t\tint write)\n{\n\tstruct page *page;\n\tstruct vm_area_struct *vma = bprm->vma;\n\tstruct mm_struct *mm = bprm->mm;\n\tint ret;\n\n\t \n\tif (write && pos < vma->vm_start) {\n\t\tmmap_write_lock(mm);\n\t\tret = expand_downwards(vma, pos);\n\t\tif (unlikely(ret < 0)) {\n\t\t\tmmap_write_unlock(mm);\n\t\t\treturn NULL;\n\t\t}\n\t\tmmap_write_downgrade(mm);\n\t} else\n\t\tmmap_read_lock(mm);\n\n\t \n\tret = get_user_pages_remote(mm, pos, 1,\n\t\t\twrite ? FOLL_WRITE : 0,\n\t\t\t&page, NULL);\n\tmmap_read_unlock(mm);\n\tif (ret <= 0)\n\t\treturn NULL;\n\n\tif (write)\n\t\tacct_arg_size(bprm, vma_pages(vma));\n\n\treturn page;\n}\n\nstatic void put_arg_page(struct page *page)\n{\n\tput_page(page);\n}\n\nstatic void free_arg_pages(struct linux_binprm *bprm)\n{\n}\n\nstatic void flush_arg_page(struct linux_binprm *bprm, unsigned long pos,\n\t\tstruct page *page)\n{\n\tflush_cache_page(bprm->vma, pos, page_to_pfn(page));\n}\n\nstatic int __bprm_mm_init(struct linux_binprm *bprm)\n{\n\tint err;\n\tstruct vm_area_struct *vma = NULL;\n\tstruct mm_struct *mm = bprm->mm;\n\n\tbprm->vma = vma = vm_area_alloc(mm);\n\tif (!vma)\n\t\treturn -ENOMEM;\n\tvma_set_anonymous(vma);\n\n\tif (mmap_write_lock_killable(mm)) {\n\t\terr = -EINTR;\n\t\tgoto err_free;\n\t}\n\n\t \n\tBUILD_BUG_ON(VM_STACK_FLAGS & VM_STACK_INCOMPLETE_SETUP);\n\tvma->vm_end = STACK_TOP_MAX;\n\tvma->vm_start = vma->vm_end - PAGE_SIZE;\n\tvm_flags_init(vma, VM_SOFTDIRTY | VM_STACK_FLAGS | VM_STACK_INCOMPLETE_SETUP);\n\tvma->vm_page_prot = vm_get_page_prot(vma->vm_flags);\n\n\terr = insert_vm_struct(mm, vma);\n\tif (err)\n\t\tgoto err;\n\n\tmm->stack_vm = mm->total_vm = 1;\n\tmmap_write_unlock(mm);\n\tbprm->p = vma->vm_end - sizeof(void *);\n\treturn 0;\nerr:\n\tmmap_write_unlock(mm);\nerr_free:\n\tbprm->vma = NULL;\n\tvm_area_free(vma);\n\treturn err;\n}\n\nstatic bool valid_arg_len(struct linux_binprm *bprm, long len)\n{\n\treturn len <= MAX_ARG_STRLEN;\n}\n\n#else\n\nstatic inline void acct_arg_size(struct linux_binprm *bprm, unsigned long pages)\n{\n}\n\nstatic struct page *get_arg_page(struct linux_binprm *bprm, unsigned long pos,\n\t\tint write)\n{\n\tstruct page *page;\n\n\tpage = bprm->page[pos / PAGE_SIZE];\n\tif (!page && write) {\n\t\tpage = alloc_page(GFP_HIGHUSER|__GFP_ZERO);\n\t\tif (!page)\n\t\t\treturn NULL;\n\t\tbprm->page[pos / PAGE_SIZE] = page;\n\t}\n\n\treturn page;\n}\n\nstatic void put_arg_page(struct page *page)\n{\n}\n\nstatic void free_arg_page(struct linux_binprm *bprm, int i)\n{\n\tif (bprm->page[i]) {\n\t\t__free_page(bprm->page[i]);\n\t\tbprm->page[i] = NULL;\n\t}\n}\n\nstatic void free_arg_pages(struct linux_binprm *bprm)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_ARG_PAGES; i++)\n\t\tfree_arg_page(bprm, i);\n}\n\nstatic void flush_arg_page(struct linux_binprm *bprm, unsigned long pos,\n\t\tstruct page *page)\n{\n}\n\nstatic int __bprm_mm_init(struct linux_binprm *bprm)\n{\n\tbprm->p = PAGE_SIZE * MAX_ARG_PAGES - sizeof(void *);\n\treturn 0;\n}\n\nstatic bool valid_arg_len(struct linux_binprm *bprm, long len)\n{\n\treturn len <= bprm->p;\n}\n\n#endif  \n\n \nstatic int bprm_mm_init(struct linux_binprm *bprm)\n{\n\tint err;\n\tstruct mm_struct *mm = NULL;\n\n\tbprm->mm = mm = mm_alloc();\n\terr = -ENOMEM;\n\tif (!mm)\n\t\tgoto err;\n\n\t \n\ttask_lock(current->group_leader);\n\tbprm->rlim_stack = current->signal->rlim[RLIMIT_STACK];\n\ttask_unlock(current->group_leader);\n\n\terr = __bprm_mm_init(bprm);\n\tif (err)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tif (mm) {\n\t\tbprm->mm = NULL;\n\t\tmmdrop(mm);\n\t}\n\n\treturn err;\n}\n\nstruct user_arg_ptr {\n#ifdef CONFIG_COMPAT\n\tbool is_compat;\n#endif\n\tunion {\n\t\tconst char __user *const __user *native;\n#ifdef CONFIG_COMPAT\n\t\tconst compat_uptr_t __user *compat;\n#endif\n\t} ptr;\n};\n\nstatic const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}\n\n \nstatic int count(struct user_arg_ptr argv, int max)\n{\n\tint i = 0;\n\n\tif (argv.ptr.native != NULL) {\n\t\tfor (;;) {\n\t\t\tconst char __user *p = get_user_arg_ptr(argv, i);\n\n\t\t\tif (!p)\n\t\t\t\tbreak;\n\n\t\t\tif (IS_ERR(p))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tif (i >= max)\n\t\t\t\treturn -E2BIG;\n\t\t\t++i;\n\n\t\t\tif (fatal_signal_pending(current))\n\t\t\t\treturn -ERESTARTNOHAND;\n\t\t\tcond_resched();\n\t\t}\n\t}\n\treturn i;\n}\n\nstatic int count_strings_kernel(const char *const *argv)\n{\n\tint i;\n\n\tif (!argv)\n\t\treturn 0;\n\n\tfor (i = 0; argv[i]; ++i) {\n\t\tif (i >= MAX_ARG_STRINGS)\n\t\t\treturn -E2BIG;\n\t\tif (fatal_signal_pending(current))\n\t\t\treturn -ERESTARTNOHAND;\n\t\tcond_resched();\n\t}\n\treturn i;\n}\n\nstatic int bprm_stack_limits(struct linux_binprm *bprm)\n{\n\tunsigned long limit, ptr_size;\n\n\t \n\tlimit = _STK_LIM / 4 * 3;\n\tlimit = min(limit, bprm->rlim_stack.rlim_cur / 4);\n\t \n\tlimit = max_t(unsigned long, limit, ARG_MAX);\n\t \n\tptr_size = (max(bprm->argc, 1) + bprm->envc) * sizeof(void *);\n\tif (limit <= ptr_size)\n\t\treturn -E2BIG;\n\tlimit -= ptr_size;\n\n\tbprm->argmin = bprm->p - limit;\n\treturn 0;\n}\n\n \nstatic int copy_strings(int argc, struct user_arg_ptr argv,\n\t\t\tstruct linux_binprm *bprm)\n{\n\tstruct page *kmapped_page = NULL;\n\tchar *kaddr = NULL;\n\tunsigned long kpos = 0;\n\tint ret;\n\n\twhile (argc-- > 0) {\n\t\tconst char __user *str;\n\t\tint len;\n\t\tunsigned long pos;\n\n\t\tret = -EFAULT;\n\t\tstr = get_user_arg_ptr(argv, argc);\n\t\tif (IS_ERR(str))\n\t\t\tgoto out;\n\n\t\tlen = strnlen_user(str, MAX_ARG_STRLEN);\n\t\tif (!len)\n\t\t\tgoto out;\n\n\t\tret = -E2BIG;\n\t\tif (!valid_arg_len(bprm, len))\n\t\t\tgoto out;\n\n\t\t \n\t\tpos = bprm->p;\n\t\tstr += len;\n\t\tbprm->p -= len;\n#ifdef CONFIG_MMU\n\t\tif (bprm->p < bprm->argmin)\n\t\t\tgoto out;\n#endif\n\n\t\twhile (len > 0) {\n\t\t\tint offset, bytes_to_copy;\n\n\t\t\tif (fatal_signal_pending(current)) {\n\t\t\t\tret = -ERESTARTNOHAND;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcond_resched();\n\n\t\t\toffset = pos % PAGE_SIZE;\n\t\t\tif (offset == 0)\n\t\t\t\toffset = PAGE_SIZE;\n\n\t\t\tbytes_to_copy = offset;\n\t\t\tif (bytes_to_copy > len)\n\t\t\t\tbytes_to_copy = len;\n\n\t\t\toffset -= bytes_to_copy;\n\t\t\tpos -= bytes_to_copy;\n\t\t\tstr -= bytes_to_copy;\n\t\t\tlen -= bytes_to_copy;\n\n\t\t\tif (!kmapped_page || kpos != (pos & PAGE_MASK)) {\n\t\t\t\tstruct page *page;\n\n\t\t\t\tpage = get_arg_page(bprm, pos, 1);\n\t\t\t\tif (!page) {\n\t\t\t\t\tret = -E2BIG;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tif (kmapped_page) {\n\t\t\t\t\tflush_dcache_page(kmapped_page);\n\t\t\t\t\tkunmap_local(kaddr);\n\t\t\t\t\tput_arg_page(kmapped_page);\n\t\t\t\t}\n\t\t\t\tkmapped_page = page;\n\t\t\t\tkaddr = kmap_local_page(kmapped_page);\n\t\t\t\tkpos = pos & PAGE_MASK;\n\t\t\t\tflush_arg_page(bprm, kpos, kmapped_page);\n\t\t\t}\n\t\t\tif (copy_from_user(kaddr+offset, str, bytes_to_copy)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\tret = 0;\nout:\n\tif (kmapped_page) {\n\t\tflush_dcache_page(kmapped_page);\n\t\tkunmap_local(kaddr);\n\t\tput_arg_page(kmapped_page);\n\t}\n\treturn ret;\n}\n\n \nint copy_string_kernel(const char *arg, struct linux_binprm *bprm)\n{\n\tint len = strnlen(arg, MAX_ARG_STRLEN) + 1  ;\n\tunsigned long pos = bprm->p;\n\n\tif (len == 0)\n\t\treturn -EFAULT;\n\tif (!valid_arg_len(bprm, len))\n\t\treturn -E2BIG;\n\n\t \n\targ += len;\n\tbprm->p -= len;\n\tif (IS_ENABLED(CONFIG_MMU) && bprm->p < bprm->argmin)\n\t\treturn -E2BIG;\n\n\twhile (len > 0) {\n\t\tunsigned int bytes_to_copy = min_t(unsigned int, len,\n\t\t\t\tmin_not_zero(offset_in_page(pos), PAGE_SIZE));\n\t\tstruct page *page;\n\n\t\tpos -= bytes_to_copy;\n\t\targ -= bytes_to_copy;\n\t\tlen -= bytes_to_copy;\n\n\t\tpage = get_arg_page(bprm, pos, 1);\n\t\tif (!page)\n\t\t\treturn -E2BIG;\n\t\tflush_arg_page(bprm, pos & PAGE_MASK, page);\n\t\tmemcpy_to_page(page, offset_in_page(pos), arg, bytes_to_copy);\n\t\tput_arg_page(page);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(copy_string_kernel);\n\nstatic int copy_strings_kernel(int argc, const char *const *argv,\n\t\t\t       struct linux_binprm *bprm)\n{\n\twhile (argc-- > 0) {\n\t\tint ret = copy_string_kernel(argv[argc], bprm);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (fatal_signal_pending(current))\n\t\t\treturn -ERESTARTNOHAND;\n\t\tcond_resched();\n\t}\n\treturn 0;\n}\n\n#ifdef CONFIG_MMU\n\n \nstatic int shift_arg_pages(struct vm_area_struct *vma, unsigned long shift)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long old_start = vma->vm_start;\n\tunsigned long old_end = vma->vm_end;\n\tunsigned long length = old_end - old_start;\n\tunsigned long new_start = old_start - shift;\n\tunsigned long new_end = old_end - shift;\n\tVMA_ITERATOR(vmi, mm, new_start);\n\tstruct vm_area_struct *next;\n\tstruct mmu_gather tlb;\n\n\tBUG_ON(new_start > new_end);\n\n\t \n\tif (vma != vma_next(&vmi))\n\t\treturn -EFAULT;\n\n\tvma_iter_prev_range(&vmi);\n\t \n\tif (vma_expand(&vmi, vma, new_start, old_end, vma->vm_pgoff, NULL))\n\t\treturn -ENOMEM;\n\n\t \n\tif (length != move_page_tables(vma, old_start,\n\t\t\t\t       vma, new_start, length, false))\n\t\treturn -ENOMEM;\n\n\tlru_add_drain();\n\ttlb_gather_mmu(&tlb, mm);\n\tnext = vma_next(&vmi);\n\tif (new_end > old_start) {\n\t\t \n\t\tfree_pgd_range(&tlb, new_end, old_end, new_end,\n\t\t\tnext ? next->vm_start : USER_PGTABLES_CEILING);\n\t} else {\n\t\t \n\t\tfree_pgd_range(&tlb, old_start, old_end, new_end,\n\t\t\tnext ? next->vm_start : USER_PGTABLES_CEILING);\n\t}\n\ttlb_finish_mmu(&tlb);\n\n\tvma_prev(&vmi);\n\t \n\treturn vma_shrink(&vmi, vma, new_start, new_end, vma->vm_pgoff);\n}\n\n \nint setup_arg_pages(struct linux_binprm *bprm,\n\t\t    unsigned long stack_top,\n\t\t    int executable_stack)\n{\n\tunsigned long ret;\n\tunsigned long stack_shift;\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma = bprm->vma;\n\tstruct vm_area_struct *prev = NULL;\n\tunsigned long vm_flags;\n\tunsigned long stack_base;\n\tunsigned long stack_size;\n\tunsigned long stack_expand;\n\tunsigned long rlim_stack;\n\tstruct mmu_gather tlb;\n\tstruct vma_iterator vmi;\n\n#ifdef CONFIG_STACK_GROWSUP\n\t \n\tstack_base = bprm->rlim_stack.rlim_max;\n\n\tstack_base = calc_max_stack_size(stack_base);\n\n\t \n\tstack_base += (STACK_RND_MASK << PAGE_SHIFT);\n\n\t \n\tif (vma->vm_end - vma->vm_start > stack_base)\n\t\treturn -ENOMEM;\n\n\tstack_base = PAGE_ALIGN(stack_top - stack_base);\n\n\tstack_shift = vma->vm_start - stack_base;\n\tmm->arg_start = bprm->p - stack_shift;\n\tbprm->p = vma->vm_end - stack_shift;\n#else\n\tstack_top = arch_align_stack(stack_top);\n\tstack_top = PAGE_ALIGN(stack_top);\n\n\tif (unlikely(stack_top < mmap_min_addr) ||\n\t    unlikely(vma->vm_end - vma->vm_start >= stack_top - mmap_min_addr))\n\t\treturn -ENOMEM;\n\n\tstack_shift = vma->vm_end - stack_top;\n\n\tbprm->p -= stack_shift;\n\tmm->arg_start = bprm->p;\n#endif\n\n\tif (bprm->loader)\n\t\tbprm->loader -= stack_shift;\n\tbprm->exec -= stack_shift;\n\n\tif (mmap_write_lock_killable(mm))\n\t\treturn -EINTR;\n\n\tvm_flags = VM_STACK_FLAGS;\n\n\t \n\tif (unlikely(executable_stack == EXSTACK_ENABLE_X))\n\t\tvm_flags |= VM_EXEC;\n\telse if (executable_stack == EXSTACK_DISABLE_X)\n\t\tvm_flags &= ~VM_EXEC;\n\tvm_flags |= mm->def_flags;\n\tvm_flags |= VM_STACK_INCOMPLETE_SETUP;\n\n\tvma_iter_init(&vmi, mm, vma->vm_start);\n\n\ttlb_gather_mmu(&tlb, mm);\n\tret = mprotect_fixup(&vmi, &tlb, vma, &prev, vma->vm_start, vma->vm_end,\n\t\t\tvm_flags);\n\ttlb_finish_mmu(&tlb);\n\n\tif (ret)\n\t\tgoto out_unlock;\n\tBUG_ON(prev != vma);\n\n\tif (unlikely(vm_flags & VM_EXEC)) {\n\t\tpr_warn_once(\"process '%pD4' started with executable stack\\n\",\n\t\t\t     bprm->file);\n\t}\n\n\t \n\tif (stack_shift) {\n\t\tret = shift_arg_pages(vma, stack_shift);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t}\n\n\t \n\tvm_flags_clear(vma, VM_STACK_INCOMPLETE_SETUP);\n\n\tstack_expand = 131072UL;  \n\tstack_size = vma->vm_end - vma->vm_start;\n\t \n\trlim_stack = bprm->rlim_stack.rlim_cur & PAGE_MASK;\n\n\tstack_expand = min(rlim_stack, stack_size + stack_expand);\n\n#ifdef CONFIG_STACK_GROWSUP\n\tstack_base = vma->vm_start + stack_expand;\n#else\n\tstack_base = vma->vm_end - stack_expand;\n#endif\n\tcurrent->mm->start_stack = bprm->p;\n\tret = expand_stack_locked(vma, stack_base);\n\tif (ret)\n\t\tret = -EFAULT;\n\nout_unlock:\n\tmmap_write_unlock(mm);\n\treturn ret;\n}\nEXPORT_SYMBOL(setup_arg_pages);\n\n#else\n\n \nint transfer_args_to_stack(struct linux_binprm *bprm,\n\t\t\t   unsigned long *sp_location)\n{\n\tunsigned long index, stop, sp;\n\tint ret = 0;\n\n\tstop = bprm->p >> PAGE_SHIFT;\n\tsp = *sp_location;\n\n\tfor (index = MAX_ARG_PAGES - 1; index >= stop; index--) {\n\t\tunsigned int offset = index == stop ? bprm->p & ~PAGE_MASK : 0;\n\t\tchar *src = kmap_local_page(bprm->page[index]) + offset;\n\t\tsp -= PAGE_SIZE - offset;\n\t\tif (copy_to_user((void *) sp, src, PAGE_SIZE - offset) != 0)\n\t\t\tret = -EFAULT;\n\t\tkunmap_local(src);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\t*sp_location = sp;\n\nout:\n\treturn ret;\n}\nEXPORT_SYMBOL(transfer_args_to_stack);\n\n#endif  \n\nstatic struct file *do_open_execat(int fd, struct filename *name, int flags)\n{\n\tstruct file *file;\n\tint err;\n\tstruct open_flags open_exec_flags = {\n\t\t.open_flag = O_LARGEFILE | O_RDONLY | __FMODE_EXEC,\n\t\t.acc_mode = MAY_EXEC,\n\t\t.intent = LOOKUP_OPEN,\n\t\t.lookup_flags = LOOKUP_FOLLOW,\n\t};\n\n\tif ((flags & ~(AT_SYMLINK_NOFOLLOW | AT_EMPTY_PATH)) != 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (flags & AT_SYMLINK_NOFOLLOW)\n\t\topen_exec_flags.lookup_flags &= ~LOOKUP_FOLLOW;\n\tif (flags & AT_EMPTY_PATH)\n\t\topen_exec_flags.lookup_flags |= LOOKUP_EMPTY;\n\n\tfile = do_filp_open(fd, name, &open_exec_flags);\n\tif (IS_ERR(file))\n\t\tgoto out;\n\n\t \n\terr = -EACCES;\n\tif (WARN_ON_ONCE(!S_ISREG(file_inode(file)->i_mode) ||\n\t\t\t path_noexec(&file->f_path)))\n\t\tgoto exit;\n\n\terr = deny_write_access(file);\n\tif (err)\n\t\tgoto exit;\n\nout:\n\treturn file;\n\nexit:\n\tfput(file);\n\treturn ERR_PTR(err);\n}\n\nstruct file *open_exec(const char *name)\n{\n\tstruct filename *filename = getname_kernel(name);\n\tstruct file *f = ERR_CAST(filename);\n\n\tif (!IS_ERR(filename)) {\n\t\tf = do_open_execat(AT_FDCWD, filename, 0);\n\t\tputname(filename);\n\t}\n\treturn f;\n}\nEXPORT_SYMBOL(open_exec);\n\n#if defined(CONFIG_BINFMT_FLAT) || defined(CONFIG_BINFMT_ELF_FDPIC)\nssize_t read_code(struct file *file, unsigned long addr, loff_t pos, size_t len)\n{\n\tssize_t res = vfs_read(file, (void __user *)addr, len, &pos);\n\tif (res > 0)\n\t\tflush_icache_user_range(addr, addr + len);\n\treturn res;\n}\nEXPORT_SYMBOL(read_code);\n#endif\n\n \nstatic int exec_mmap(struct mm_struct *mm)\n{\n\tstruct task_struct *tsk;\n\tstruct mm_struct *old_mm, *active_mm;\n\tint ret;\n\n\t \n\ttsk = current;\n\told_mm = current->mm;\n\texec_mm_release(tsk, old_mm);\n\tif (old_mm)\n\t\tsync_mm_rss(old_mm);\n\n\tret = down_write_killable(&tsk->signal->exec_update_lock);\n\tif (ret)\n\t\treturn ret;\n\n\tif (old_mm) {\n\t\t \n\t\tret = mmap_read_lock_killable(old_mm);\n\t\tif (ret) {\n\t\t\tup_write(&tsk->signal->exec_update_lock);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\ttask_lock(tsk);\n\tmembarrier_exec_mmap(mm);\n\n\tlocal_irq_disable();\n\tactive_mm = tsk->active_mm;\n\ttsk->active_mm = mm;\n\ttsk->mm = mm;\n\tmm_init_cid(mm);\n\t \n\tif (!IS_ENABLED(CONFIG_ARCH_WANT_IRQS_OFF_ACTIVATE_MM))\n\t\tlocal_irq_enable();\n\tactivate_mm(active_mm, mm);\n\tif (IS_ENABLED(CONFIG_ARCH_WANT_IRQS_OFF_ACTIVATE_MM))\n\t\tlocal_irq_enable();\n\tlru_gen_add_mm(mm);\n\ttask_unlock(tsk);\n\tlru_gen_use_mm(mm);\n\tif (old_mm) {\n\t\tmmap_read_unlock(old_mm);\n\t\tBUG_ON(active_mm != old_mm);\n\t\tsetmax_mm_hiwater_rss(&tsk->signal->maxrss, old_mm);\n\t\tmm_update_next_owner(old_mm);\n\t\tmmput(old_mm);\n\t\treturn 0;\n\t}\n\tmmdrop_lazy_tlb(active_mm);\n\treturn 0;\n}\n\nstatic int de_thread(struct task_struct *tsk)\n{\n\tstruct signal_struct *sig = tsk->signal;\n\tstruct sighand_struct *oldsighand = tsk->sighand;\n\tspinlock_t *lock = &oldsighand->siglock;\n\n\tif (thread_group_empty(tsk))\n\t\tgoto no_thread_group;\n\n\t \n\tspin_lock_irq(lock);\n\tif ((sig->flags & SIGNAL_GROUP_EXIT) || sig->group_exec_task) {\n\t\t \n\t\tspin_unlock_irq(lock);\n\t\treturn -EAGAIN;\n\t}\n\n\tsig->group_exec_task = tsk;\n\tsig->notify_count = zap_other_threads(tsk);\n\tif (!thread_group_leader(tsk))\n\t\tsig->notify_count--;\n\n\twhile (sig->notify_count) {\n\t\t__set_current_state(TASK_KILLABLE);\n\t\tspin_unlock_irq(lock);\n\t\tschedule();\n\t\tif (__fatal_signal_pending(tsk))\n\t\t\tgoto killed;\n\t\tspin_lock_irq(lock);\n\t}\n\tspin_unlock_irq(lock);\n\n\t \n\tif (!thread_group_leader(tsk)) {\n\t\tstruct task_struct *leader = tsk->group_leader;\n\n\t\tfor (;;) {\n\t\t\tcgroup_threadgroup_change_begin(tsk);\n\t\t\twrite_lock_irq(&tasklist_lock);\n\t\t\t \n\t\t\tsig->notify_count = -1;\n\t\t\tif (likely(leader->exit_state))\n\t\t\t\tbreak;\n\t\t\t__set_current_state(TASK_KILLABLE);\n\t\t\twrite_unlock_irq(&tasklist_lock);\n\t\t\tcgroup_threadgroup_change_end(tsk);\n\t\t\tschedule();\n\t\t\tif (__fatal_signal_pending(tsk))\n\t\t\t\tgoto killed;\n\t\t}\n\n\t\t \n\t\ttsk->start_time = leader->start_time;\n\t\ttsk->start_boottime = leader->start_boottime;\n\n\t\tBUG_ON(!same_thread_group(leader, tsk));\n\t\t \n\n\t\t \n\t\texchange_tids(tsk, leader);\n\t\ttransfer_pid(leader, tsk, PIDTYPE_TGID);\n\t\ttransfer_pid(leader, tsk, PIDTYPE_PGID);\n\t\ttransfer_pid(leader, tsk, PIDTYPE_SID);\n\n\t\tlist_replace_rcu(&leader->tasks, &tsk->tasks);\n\t\tlist_replace_init(&leader->sibling, &tsk->sibling);\n\n\t\ttsk->group_leader = tsk;\n\t\tleader->group_leader = tsk;\n\n\t\ttsk->exit_signal = SIGCHLD;\n\t\tleader->exit_signal = -1;\n\n\t\tBUG_ON(leader->exit_state != EXIT_ZOMBIE);\n\t\tleader->exit_state = EXIT_DEAD;\n\n\t\t \n\t\tif (unlikely(leader->ptrace))\n\t\t\t__wake_up_parent(leader, leader->parent);\n\t\twrite_unlock_irq(&tasklist_lock);\n\t\tcgroup_threadgroup_change_end(tsk);\n\n\t\trelease_task(leader);\n\t}\n\n\tsig->group_exec_task = NULL;\n\tsig->notify_count = 0;\n\nno_thread_group:\n\t \n\ttsk->exit_signal = SIGCHLD;\n\n\tBUG_ON(!thread_group_leader(tsk));\n\treturn 0;\n\nkilled:\n\t \n\tread_lock(&tasklist_lock);\n\tsig->group_exec_task = NULL;\n\tsig->notify_count = 0;\n\tread_unlock(&tasklist_lock);\n\treturn -EAGAIN;\n}\n\n\n \nstatic int unshare_sighand(struct task_struct *me)\n{\n\tstruct sighand_struct *oldsighand = me->sighand;\n\n\tif (refcount_read(&oldsighand->count) != 1) {\n\t\tstruct sighand_struct *newsighand;\n\t\t \n\t\tnewsighand = kmem_cache_alloc(sighand_cachep, GFP_KERNEL);\n\t\tif (!newsighand)\n\t\t\treturn -ENOMEM;\n\n\t\trefcount_set(&newsighand->count, 1);\n\n\t\twrite_lock_irq(&tasklist_lock);\n\t\tspin_lock(&oldsighand->siglock);\n\t\tmemcpy(newsighand->action, oldsighand->action,\n\t\t       sizeof(newsighand->action));\n\t\trcu_assign_pointer(me->sighand, newsighand);\n\t\tspin_unlock(&oldsighand->siglock);\n\t\twrite_unlock_irq(&tasklist_lock);\n\n\t\t__cleanup_sighand(oldsighand);\n\t}\n\treturn 0;\n}\n\nchar *__get_task_comm(char *buf, size_t buf_size, struct task_struct *tsk)\n{\n\ttask_lock(tsk);\n\t \n\tstrscpy_pad(buf, tsk->comm, buf_size);\n\ttask_unlock(tsk);\n\treturn buf;\n}\nEXPORT_SYMBOL_GPL(__get_task_comm);\n\n \n\nvoid __set_task_comm(struct task_struct *tsk, const char *buf, bool exec)\n{\n\ttask_lock(tsk);\n\ttrace_task_rename(tsk, buf);\n\tstrscpy_pad(tsk->comm, buf, sizeof(tsk->comm));\n\ttask_unlock(tsk);\n\tperf_event_comm(tsk, exec);\n}\n\n \nint begin_new_exec(struct linux_binprm * bprm)\n{\n\tstruct task_struct *me = current;\n\tint retval;\n\n\t \n\tretval = bprm_creds_from_file(bprm);\n\tif (retval)\n\t\treturn retval;\n\n\t \n\tbprm->point_of_no_return = true;\n\n\t \n\tretval = de_thread(me);\n\tif (retval)\n\t\tgoto out;\n\n\t \n\tio_uring_task_cancel();\n\n\t \n\tretval = unshare_files();\n\tif (retval)\n\t\tgoto out;\n\n\t \n\tretval = set_mm_exe_file(bprm->mm, bprm->file);\n\tif (retval)\n\t\tgoto out;\n\n\t \n\twould_dump(bprm, bprm->file);\n\tif (bprm->have_execfd)\n\t\twould_dump(bprm, bprm->executable);\n\n\t \n\tacct_arg_size(bprm, 0);\n\tretval = exec_mmap(bprm->mm);\n\tif (retval)\n\t\tgoto out;\n\n\tbprm->mm = NULL;\n\n\tretval = exec_task_namespaces();\n\tif (retval)\n\t\tgoto out_unlock;\n\n#ifdef CONFIG_POSIX_TIMERS\n\tspin_lock_irq(&me->sighand->siglock);\n\tposix_cpu_timers_exit(me);\n\tspin_unlock_irq(&me->sighand->siglock);\n\texit_itimers(me);\n\tflush_itimer_signals();\n#endif\n\n\t \n\tretval = unshare_sighand(me);\n\tif (retval)\n\t\tgoto out_unlock;\n\n\tme->flags &= ~(PF_RANDOMIZE | PF_FORKNOEXEC |\n\t\t\t\t\tPF_NOFREEZE | PF_NO_SETAFFINITY);\n\tflush_thread();\n\tme->personality &= ~bprm->per_clear;\n\n\tclear_syscall_work_syscall_user_dispatch(me);\n\n\t \n\tdo_close_on_exec(me->files);\n\n\tif (bprm->secureexec) {\n\t\t \n\t\tme->pdeath_signal = 0;\n\n\t\t \n\t\tif (bprm->rlim_stack.rlim_cur > _STK_LIM)\n\t\t\tbprm->rlim_stack.rlim_cur = _STK_LIM;\n\t}\n\n\tme->sas_ss_sp = me->sas_ss_size = 0;\n\n\t \n\tif (bprm->interp_flags & BINPRM_FLAGS_ENFORCE_NONDUMP ||\n\t    !(uid_eq(current_euid(), current_uid()) &&\n\t      gid_eq(current_egid(), current_gid())))\n\t\tset_dumpable(current->mm, suid_dumpable);\n\telse\n\t\tset_dumpable(current->mm, SUID_DUMP_USER);\n\n\tperf_event_exec();\n\t__set_task_comm(me, kbasename(bprm->filename), true);\n\n\t \n\tWRITE_ONCE(me->self_exec_id, me->self_exec_id + 1);\n\tflush_signal_handlers(me, 0);\n\n\tretval = set_cred_ucounts(bprm->cred);\n\tif (retval < 0)\n\t\tgoto out_unlock;\n\n\t \n\tsecurity_bprm_committing_creds(bprm);\n\n\tcommit_creds(bprm->cred);\n\tbprm->cred = NULL;\n\n\t \n\tif (get_dumpable(me->mm) != SUID_DUMP_USER)\n\t\tperf_event_exit_task(me);\n\t \n\tsecurity_bprm_committed_creds(bprm);\n\n\t \n\tif (bprm->have_execfd) {\n\t\tretval = get_unused_fd_flags(0);\n\t\tif (retval < 0)\n\t\t\tgoto out_unlock;\n\t\tfd_install(retval, bprm->executable);\n\t\tbprm->executable = NULL;\n\t\tbprm->execfd = retval;\n\t}\n\treturn 0;\n\nout_unlock:\n\tup_write(&me->signal->exec_update_lock);\nout:\n\treturn retval;\n}\nEXPORT_SYMBOL(begin_new_exec);\n\nvoid would_dump(struct linux_binprm *bprm, struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct mnt_idmap *idmap = file_mnt_idmap(file);\n\tif (inode_permission(idmap, inode, MAY_READ) < 0) {\n\t\tstruct user_namespace *old, *user_ns;\n\t\tbprm->interp_flags |= BINPRM_FLAGS_ENFORCE_NONDUMP;\n\n\t\t \n\t\tuser_ns = old = bprm->mm->user_ns;\n\t\twhile ((user_ns != &init_user_ns) &&\n\t\t       !privileged_wrt_inode_uidgid(user_ns, idmap, inode))\n\t\t\tuser_ns = user_ns->parent;\n\n\t\tif (old != user_ns) {\n\t\t\tbprm->mm->user_ns = get_user_ns(user_ns);\n\t\t\tput_user_ns(old);\n\t\t}\n\t}\n}\nEXPORT_SYMBOL(would_dump);\n\nvoid setup_new_exec(struct linux_binprm * bprm)\n{\n\t \n\tstruct task_struct *me = current;\n\n\tarch_pick_mmap_layout(me->mm, &bprm->rlim_stack);\n\n\tarch_setup_new_exec();\n\n\t \n\tme->mm->task_size = TASK_SIZE;\n\tup_write(&me->signal->exec_update_lock);\n\tmutex_unlock(&me->signal->cred_guard_mutex);\n}\nEXPORT_SYMBOL(setup_new_exec);\n\n \nvoid finalize_exec(struct linux_binprm *bprm)\n{\n\t \n\ttask_lock(current->group_leader);\n\tcurrent->signal->rlim[RLIMIT_STACK] = bprm->rlim_stack;\n\ttask_unlock(current->group_leader);\n}\nEXPORT_SYMBOL(finalize_exec);\n\n \nstatic int prepare_bprm_creds(struct linux_binprm *bprm)\n{\n\tif (mutex_lock_interruptible(&current->signal->cred_guard_mutex))\n\t\treturn -ERESTARTNOINTR;\n\n\tbprm->cred = prepare_exec_creds();\n\tif (likely(bprm->cred))\n\t\treturn 0;\n\n\tmutex_unlock(&current->signal->cred_guard_mutex);\n\treturn -ENOMEM;\n}\n\nstatic void free_bprm(struct linux_binprm *bprm)\n{\n\tif (bprm->mm) {\n\t\tacct_arg_size(bprm, 0);\n\t\tmmput(bprm->mm);\n\t}\n\tfree_arg_pages(bprm);\n\tif (bprm->cred) {\n\t\tmutex_unlock(&current->signal->cred_guard_mutex);\n\t\tabort_creds(bprm->cred);\n\t}\n\tif (bprm->file) {\n\t\tallow_write_access(bprm->file);\n\t\tfput(bprm->file);\n\t}\n\tif (bprm->executable)\n\t\tfput(bprm->executable);\n\t \n\tif (bprm->interp != bprm->filename)\n\t\tkfree(bprm->interp);\n\tkfree(bprm->fdpath);\n\tkfree(bprm);\n}\n\nstatic struct linux_binprm *alloc_bprm(int fd, struct filename *filename)\n{\n\tstruct linux_binprm *bprm = kzalloc(sizeof(*bprm), GFP_KERNEL);\n\tint retval = -ENOMEM;\n\tif (!bprm)\n\t\tgoto out;\n\n\tif (fd == AT_FDCWD || filename->name[0] == '/') {\n\t\tbprm->filename = filename->name;\n\t} else {\n\t\tif (filename->name[0] == '\\0')\n\t\t\tbprm->fdpath = kasprintf(GFP_KERNEL, \"/dev/fd/%d\", fd);\n\t\telse\n\t\t\tbprm->fdpath = kasprintf(GFP_KERNEL, \"/dev/fd/%d/%s\",\n\t\t\t\t\t\t  fd, filename->name);\n\t\tif (!bprm->fdpath)\n\t\t\tgoto out_free;\n\n\t\tbprm->filename = bprm->fdpath;\n\t}\n\tbprm->interp = bprm->filename;\n\n\tretval = bprm_mm_init(bprm);\n\tif (retval)\n\t\tgoto out_free;\n\treturn bprm;\n\nout_free:\n\tfree_bprm(bprm);\nout:\n\treturn ERR_PTR(retval);\n}\n\nint bprm_change_interp(const char *interp, struct linux_binprm *bprm)\n{\n\t \n\tif (bprm->interp != bprm->filename)\n\t\tkfree(bprm->interp);\n\tbprm->interp = kstrdup(interp, GFP_KERNEL);\n\tif (!bprm->interp)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\nEXPORT_SYMBOL(bprm_change_interp);\n\n \nstatic void check_unsafe_exec(struct linux_binprm *bprm)\n{\n\tstruct task_struct *p = current, *t;\n\tunsigned n_fs;\n\n\tif (p->ptrace)\n\t\tbprm->unsafe |= LSM_UNSAFE_PTRACE;\n\n\t \n\tif (task_no_new_privs(current))\n\t\tbprm->unsafe |= LSM_UNSAFE_NO_NEW_PRIVS;\n\n\t \n\tt = p;\n\tn_fs = 1;\n\tspin_lock(&p->fs->lock);\n\trcu_read_lock();\n\twhile_each_thread(p, t) {\n\t\tif (t->fs == p->fs)\n\t\t\tn_fs++;\n\t}\n\trcu_read_unlock();\n\n\tif (p->fs->users > n_fs)\n\t\tbprm->unsafe |= LSM_UNSAFE_SHARE;\n\telse\n\t\tp->fs->in_exec = 1;\n\tspin_unlock(&p->fs->lock);\n}\n\nstatic void bprm_fill_uid(struct linux_binprm *bprm, struct file *file)\n{\n\t \n\tstruct mnt_idmap *idmap;\n\tstruct inode *inode = file_inode(file);\n\tunsigned int mode;\n\tvfsuid_t vfsuid;\n\tvfsgid_t vfsgid;\n\n\tif (!mnt_may_suid(file->f_path.mnt))\n\t\treturn;\n\n\tif (task_no_new_privs(current))\n\t\treturn;\n\n\tmode = READ_ONCE(inode->i_mode);\n\tif (!(mode & (S_ISUID|S_ISGID)))\n\t\treturn;\n\n\tidmap = file_mnt_idmap(file);\n\n\t \n\tinode_lock(inode);\n\n\t \n\tmode = inode->i_mode;\n\tvfsuid = i_uid_into_vfsuid(idmap, inode);\n\tvfsgid = i_gid_into_vfsgid(idmap, inode);\n\tinode_unlock(inode);\n\n\t \n\tif (!vfsuid_has_mapping(bprm->cred->user_ns, vfsuid) ||\n\t    !vfsgid_has_mapping(bprm->cred->user_ns, vfsgid))\n\t\treturn;\n\n\tif (mode & S_ISUID) {\n\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\t\tbprm->cred->euid = vfsuid_into_kuid(vfsuid);\n\t}\n\n\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\t\tbprm->cred->egid = vfsgid_into_kgid(vfsgid);\n\t}\n}\n\n \nstatic int bprm_creds_from_file(struct linux_binprm *bprm)\n{\n\t \n\tstruct file *file = bprm->execfd_creds ? bprm->executable : bprm->file;\n\n\tbprm_fill_uid(bprm, file);\n\treturn security_bprm_creds_from_file(bprm, file);\n}\n\n \nstatic int prepare_binprm(struct linux_binprm *bprm)\n{\n\tloff_t pos = 0;\n\n\tmemset(bprm->buf, 0, BINPRM_BUF_SIZE);\n\treturn kernel_read(bprm->file, bprm->buf, BINPRM_BUF_SIZE, &pos);\n}\n\n \nint remove_arg_zero(struct linux_binprm *bprm)\n{\n\tint ret = 0;\n\tunsigned long offset;\n\tchar *kaddr;\n\tstruct page *page;\n\n\tif (!bprm->argc)\n\t\treturn 0;\n\n\tdo {\n\t\toffset = bprm->p & ~PAGE_MASK;\n\t\tpage = get_arg_page(bprm, bprm->p, 0);\n\t\tif (!page) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tkaddr = kmap_local_page(page);\n\n\t\tfor (; offset < PAGE_SIZE && kaddr[offset];\n\t\t\t\toffset++, bprm->p++)\n\t\t\t;\n\n\t\tkunmap_local(kaddr);\n\t\tput_arg_page(page);\n\t} while (offset == PAGE_SIZE);\n\n\tbprm->p++;\n\tbprm->argc--;\n\tret = 0;\n\nout:\n\treturn ret;\n}\nEXPORT_SYMBOL(remove_arg_zero);\n\n#define printable(c) (((c)=='\\t') || ((c)=='\\n') || (0x20<=(c) && (c)<=0x7e))\n \nstatic int search_binary_handler(struct linux_binprm *bprm)\n{\n\tbool need_retry = IS_ENABLED(CONFIG_MODULES);\n\tstruct linux_binfmt *fmt;\n\tint retval;\n\n\tretval = prepare_binprm(bprm);\n\tif (retval < 0)\n\t\treturn retval;\n\n\tretval = security_bprm_check(bprm);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = -ENOENT;\n retry:\n\tread_lock(&binfmt_lock);\n\tlist_for_each_entry(fmt, &formats, lh) {\n\t\tif (!try_module_get(fmt->module))\n\t\t\tcontinue;\n\t\tread_unlock(&binfmt_lock);\n\n\t\tretval = fmt->load_binary(bprm);\n\n\t\tread_lock(&binfmt_lock);\n\t\tput_binfmt(fmt);\n\t\tif (bprm->point_of_no_return || (retval != -ENOEXEC)) {\n\t\t\tread_unlock(&binfmt_lock);\n\t\t\treturn retval;\n\t\t}\n\t}\n\tread_unlock(&binfmt_lock);\n\n\tif (need_retry) {\n\t\tif (printable(bprm->buf[0]) && printable(bprm->buf[1]) &&\n\t\t    printable(bprm->buf[2]) && printable(bprm->buf[3]))\n\t\t\treturn retval;\n\t\tif (request_module(\"binfmt-%04x\", *(ushort *)(bprm->buf + 2)) < 0)\n\t\t\treturn retval;\n\t\tneed_retry = false;\n\t\tgoto retry;\n\t}\n\n\treturn retval;\n}\n\n \nstatic int exec_binprm(struct linux_binprm *bprm)\n{\n\tpid_t old_pid, old_vpid;\n\tint ret, depth;\n\n\t \n\told_pid = current->pid;\n\trcu_read_lock();\n\told_vpid = task_pid_nr_ns(current, task_active_pid_ns(current->parent));\n\trcu_read_unlock();\n\n\t \n\tfor (depth = 0;; depth++) {\n\t\tstruct file *exec;\n\t\tif (depth > 5)\n\t\t\treturn -ELOOP;\n\n\t\tret = search_binary_handler(bprm);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (!bprm->interpreter)\n\t\t\tbreak;\n\n\t\texec = bprm->file;\n\t\tbprm->file = bprm->interpreter;\n\t\tbprm->interpreter = NULL;\n\n\t\tallow_write_access(exec);\n\t\tif (unlikely(bprm->have_execfd)) {\n\t\t\tif (bprm->executable) {\n\t\t\t\tfput(exec);\n\t\t\t\treturn -ENOEXEC;\n\t\t\t}\n\t\t\tbprm->executable = exec;\n\t\t} else\n\t\t\tfput(exec);\n\t}\n\n\taudit_bprm(bprm);\n\ttrace_sched_process_exec(current, old_pid, bprm);\n\tptrace_event(PTRACE_EVENT_EXEC, old_vpid);\n\tproc_exec_connector(current);\n\treturn 0;\n}\n\n \nstatic int bprm_execve(struct linux_binprm *bprm,\n\t\t       int fd, struct filename *filename, int flags)\n{\n\tstruct file *file;\n\tint retval;\n\n\tretval = prepare_bprm_creds(bprm);\n\tif (retval)\n\t\treturn retval;\n\n\t \n\tcheck_unsafe_exec(bprm);\n\tcurrent->in_execve = 1;\n\tsched_mm_cid_before_execve(current);\n\n\tfile = do_open_execat(fd, filename, flags);\n\tretval = PTR_ERR(file);\n\tif (IS_ERR(file))\n\t\tgoto out_unmark;\n\n\tsched_exec();\n\n\tbprm->file = file;\n\t \n\tif (bprm->fdpath && get_close_on_exec(fd))\n\t\tbprm->interp_flags |= BINPRM_FLAGS_PATH_INACCESSIBLE;\n\n\t \n\tretval = security_bprm_creds_for_exec(bprm);\n\tif (retval)\n\t\tgoto out;\n\n\tretval = exec_binprm(bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tsched_mm_cid_after_execve(current);\n\t \n\tcurrent->fs->in_exec = 0;\n\tcurrent->in_execve = 0;\n\trseq_execve(current);\n\tuser_events_execve(current);\n\tacct_update_integrals(current);\n\ttask_numa_free(current, false);\n\treturn retval;\n\nout:\n\t \n\tif (bprm->point_of_no_return && !fatal_signal_pending(current))\n\t\tforce_fatal_sig(SIGSEGV);\n\nout_unmark:\n\tsched_mm_cid_after_execve(current);\n\tcurrent->fs->in_exec = 0;\n\tcurrent->in_execve = 0;\n\n\treturn retval;\n}\n\nstatic int do_execveat_common(int fd, struct filename *filename,\n\t\t\t      struct user_arg_ptr argv,\n\t\t\t      struct user_arg_ptr envp,\n\t\t\t      int flags)\n{\n\tstruct linux_binprm *bprm;\n\tint retval;\n\n\tif (IS_ERR(filename))\n\t\treturn PTR_ERR(filename);\n\n\t \n\tif ((current->flags & PF_NPROC_EXCEEDED) &&\n\t    is_rlimit_overlimit(current_ucounts(), UCOUNT_RLIMIT_NPROC, rlimit(RLIMIT_NPROC))) {\n\t\tretval = -EAGAIN;\n\t\tgoto out_ret;\n\t}\n\n\t \n\tcurrent->flags &= ~PF_NPROC_EXCEEDED;\n\n\tbprm = alloc_bprm(fd, filename);\n\tif (IS_ERR(bprm)) {\n\t\tretval = PTR_ERR(bprm);\n\t\tgoto out_ret;\n\t}\n\n\tretval = count(argv, MAX_ARG_STRINGS);\n\tif (retval == 0)\n\t\tpr_warn_once(\"process '%s' launched '%s' with NULL argv: empty string added\\n\",\n\t\t\t     current->comm, bprm->filename);\n\tif (retval < 0)\n\t\tgoto out_free;\n\tbprm->argc = retval;\n\n\tretval = count(envp, MAX_ARG_STRINGS);\n\tif (retval < 0)\n\t\tgoto out_free;\n\tbprm->envc = retval;\n\n\tretval = bprm_stack_limits(bprm);\n\tif (retval < 0)\n\t\tgoto out_free;\n\n\tretval = copy_string_kernel(bprm->filename, bprm);\n\tif (retval < 0)\n\t\tgoto out_free;\n\tbprm->exec = bprm->p;\n\n\tretval = copy_strings(bprm->envc, envp, bprm);\n\tif (retval < 0)\n\t\tgoto out_free;\n\n\tretval = copy_strings(bprm->argc, argv, bprm);\n\tif (retval < 0)\n\t\tgoto out_free;\n\n\t \n\tif (bprm->argc == 0) {\n\t\tretval = copy_string_kernel(\"\", bprm);\n\t\tif (retval < 0)\n\t\t\tgoto out_free;\n\t\tbprm->argc = 1;\n\t}\n\n\tretval = bprm_execve(bprm, fd, filename, flags);\nout_free:\n\tfree_bprm(bprm);\n\nout_ret:\n\tputname(filename);\n\treturn retval;\n}\n\nint kernel_execve(const char *kernel_filename,\n\t\t  const char *const *argv, const char *const *envp)\n{\n\tstruct filename *filename;\n\tstruct linux_binprm *bprm;\n\tint fd = AT_FDCWD;\n\tint retval;\n\n\t \n\tif (WARN_ON_ONCE(current->flags & PF_KTHREAD))\n\t\treturn -EINVAL;\n\n\tfilename = getname_kernel(kernel_filename);\n\tif (IS_ERR(filename))\n\t\treturn PTR_ERR(filename);\n\n\tbprm = alloc_bprm(fd, filename);\n\tif (IS_ERR(bprm)) {\n\t\tretval = PTR_ERR(bprm);\n\t\tgoto out_ret;\n\t}\n\n\tretval = count_strings_kernel(argv);\n\tif (WARN_ON_ONCE(retval == 0))\n\t\tretval = -EINVAL;\n\tif (retval < 0)\n\t\tgoto out_free;\n\tbprm->argc = retval;\n\n\tretval = count_strings_kernel(envp);\n\tif (retval < 0)\n\t\tgoto out_free;\n\tbprm->envc = retval;\n\n\tretval = bprm_stack_limits(bprm);\n\tif (retval < 0)\n\t\tgoto out_free;\n\n\tretval = copy_string_kernel(bprm->filename, bprm);\n\tif (retval < 0)\n\t\tgoto out_free;\n\tbprm->exec = bprm->p;\n\n\tretval = copy_strings_kernel(bprm->envc, envp, bprm);\n\tif (retval < 0)\n\t\tgoto out_free;\n\n\tretval = copy_strings_kernel(bprm->argc, argv, bprm);\n\tif (retval < 0)\n\t\tgoto out_free;\n\n\tretval = bprm_execve(bprm, fd, filename, 0);\nout_free:\n\tfree_bprm(bprm);\nout_ret:\n\tputname(filename);\n\treturn retval;\n}\n\nstatic int do_execve(struct filename *filename,\n\tconst char __user *const __user *__argv,\n\tconst char __user *const __user *__envp)\n{\n\tstruct user_arg_ptr argv = { .ptr.native = __argv };\n\tstruct user_arg_ptr envp = { .ptr.native = __envp };\n\treturn do_execveat_common(AT_FDCWD, filename, argv, envp, 0);\n}\n\nstatic int do_execveat(int fd, struct filename *filename,\n\t\tconst char __user *const __user *__argv,\n\t\tconst char __user *const __user *__envp,\n\t\tint flags)\n{\n\tstruct user_arg_ptr argv = { .ptr.native = __argv };\n\tstruct user_arg_ptr envp = { .ptr.native = __envp };\n\n\treturn do_execveat_common(fd, filename, argv, envp, flags);\n}\n\n#ifdef CONFIG_COMPAT\nstatic int compat_do_execve(struct filename *filename,\n\tconst compat_uptr_t __user *__argv,\n\tconst compat_uptr_t __user *__envp)\n{\n\tstruct user_arg_ptr argv = {\n\t\t.is_compat = true,\n\t\t.ptr.compat = __argv,\n\t};\n\tstruct user_arg_ptr envp = {\n\t\t.is_compat = true,\n\t\t.ptr.compat = __envp,\n\t};\n\treturn do_execveat_common(AT_FDCWD, filename, argv, envp, 0);\n}\n\nstatic int compat_do_execveat(int fd, struct filename *filename,\n\t\t\t      const compat_uptr_t __user *__argv,\n\t\t\t      const compat_uptr_t __user *__envp,\n\t\t\t      int flags)\n{\n\tstruct user_arg_ptr argv = {\n\t\t.is_compat = true,\n\t\t.ptr.compat = __argv,\n\t};\n\tstruct user_arg_ptr envp = {\n\t\t.is_compat = true,\n\t\t.ptr.compat = __envp,\n\t};\n\treturn do_execveat_common(fd, filename, argv, envp, flags);\n}\n#endif\n\nvoid set_binfmt(struct linux_binfmt *new)\n{\n\tstruct mm_struct *mm = current->mm;\n\n\tif (mm->binfmt)\n\t\tmodule_put(mm->binfmt->module);\n\n\tmm->binfmt = new;\n\tif (new)\n\t\t__module_get(new->module);\n}\nEXPORT_SYMBOL(set_binfmt);\n\n \nvoid set_dumpable(struct mm_struct *mm, int value)\n{\n\tif (WARN_ON((unsigned)value > SUID_DUMP_ROOT))\n\t\treturn;\n\n\tset_mask_bits(&mm->flags, MMF_DUMPABLE_MASK, value);\n}\n\nSYSCALL_DEFINE3(execve,\n\t\tconst char __user *, filename,\n\t\tconst char __user *const __user *, argv,\n\t\tconst char __user *const __user *, envp)\n{\n\treturn do_execve(getname(filename), argv, envp);\n}\n\nSYSCALL_DEFINE5(execveat,\n\t\tint, fd, const char __user *, filename,\n\t\tconst char __user *const __user *, argv,\n\t\tconst char __user *const __user *, envp,\n\t\tint, flags)\n{\n\treturn do_execveat(fd,\n\t\t\t   getname_uflags(filename, flags),\n\t\t\t   argv, envp, flags);\n}\n\n#ifdef CONFIG_COMPAT\nCOMPAT_SYSCALL_DEFINE3(execve, const char __user *, filename,\n\tconst compat_uptr_t __user *, argv,\n\tconst compat_uptr_t __user *, envp)\n{\n\treturn compat_do_execve(getname(filename), argv, envp);\n}\n\nCOMPAT_SYSCALL_DEFINE5(execveat, int, fd,\n\t\t       const char __user *, filename,\n\t\t       const compat_uptr_t __user *, argv,\n\t\t       const compat_uptr_t __user *, envp,\n\t\t       int,  flags)\n{\n\treturn compat_do_execveat(fd,\n\t\t\t\t  getname_uflags(filename, flags),\n\t\t\t\t  argv, envp, flags);\n}\n#endif\n\n#ifdef CONFIG_SYSCTL\n\nstatic int proc_dointvec_minmax_coredump(struct ctl_table *table, int write,\n\t\tvoid *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint error = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\n\tif (!error)\n\t\tvalidate_coredump_safety();\n\treturn error;\n}\n\nstatic struct ctl_table fs_exec_sysctls[] = {\n\t{\n\t\t.procname\t= \"suid_dumpable\",\n\t\t.data\t\t= &suid_dumpable,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax_coredump,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_TWO,\n\t},\n\t{ }\n};\n\nstatic int __init init_fs_exec_sysctls(void)\n{\n\tregister_sysctl_init(\"fs\", fs_exec_sysctls);\n\treturn 0;\n}\n\nfs_initcall(init_fs_exec_sysctls);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}