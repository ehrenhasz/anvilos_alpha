{
  "module_name": "file.c",
  "hash_id": "3d75e858d3fb4f296afe5550fd9bb23f0c3cc322094085215344ac3d7da808f2",
  "original_prompt": "Ingested from linux-6.6.14/fs/file.c",
  "human_readable_source": "\n \n\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/bitops.h>\n#include <linux/spinlock.h>\n#include <linux/rcupdate.h>\n#include <linux/close_range.h>\n#include <net/sock.h>\n\n#include \"internal.h\"\n\nunsigned int sysctl_nr_open __read_mostly = 1024*1024;\nunsigned int sysctl_nr_open_min = BITS_PER_LONG;\n \n#define __const_min(x, y) ((x) < (y) ? (x) : (y))\nunsigned int sysctl_nr_open_max =\n\t__const_min(INT_MAX, ~(size_t)0/sizeof(void *)) & -BITS_PER_LONG;\n\nstatic void __free_fdtable(struct fdtable *fdt)\n{\n\tkvfree(fdt->fd);\n\tkvfree(fdt->open_fds);\n\tkfree(fdt);\n}\n\nstatic void free_fdtable_rcu(struct rcu_head *rcu)\n{\n\t__free_fdtable(container_of(rcu, struct fdtable, rcu));\n}\n\n#define BITBIT_NR(nr)\tBITS_TO_LONGS(BITS_TO_LONGS(nr))\n#define BITBIT_SIZE(nr)\t(BITBIT_NR(nr) * sizeof(long))\n\n \nstatic void copy_fd_bitmaps(struct fdtable *nfdt, struct fdtable *ofdt,\n\t\t\t    unsigned int count)\n{\n\tunsigned int cpy, set;\n\n\tcpy = count / BITS_PER_BYTE;\n\tset = (nfdt->max_fds - count) / BITS_PER_BYTE;\n\tmemcpy(nfdt->open_fds, ofdt->open_fds, cpy);\n\tmemset((char *)nfdt->open_fds + cpy, 0, set);\n\tmemcpy(nfdt->close_on_exec, ofdt->close_on_exec, cpy);\n\tmemset((char *)nfdt->close_on_exec + cpy, 0, set);\n\n\tcpy = BITBIT_SIZE(count);\n\tset = BITBIT_SIZE(nfdt->max_fds) - cpy;\n\tmemcpy(nfdt->full_fds_bits, ofdt->full_fds_bits, cpy);\n\tmemset((char *)nfdt->full_fds_bits + cpy, 0, set);\n}\n\n \nstatic void copy_fdtable(struct fdtable *nfdt, struct fdtable *ofdt)\n{\n\tsize_t cpy, set;\n\n\tBUG_ON(nfdt->max_fds < ofdt->max_fds);\n\n\tcpy = ofdt->max_fds * sizeof(struct file *);\n\tset = (nfdt->max_fds - ofdt->max_fds) * sizeof(struct file *);\n\tmemcpy(nfdt->fd, ofdt->fd, cpy);\n\tmemset((char *)nfdt->fd + cpy, 0, set);\n\n\tcopy_fd_bitmaps(nfdt, ofdt, ofdt->max_fds);\n}\n\n \nstatic struct fdtable * alloc_fdtable(unsigned int nr)\n{\n\tstruct fdtable *fdt;\n\tvoid *data;\n\n\t \n\tnr /= (1024 / sizeof(struct file *));\n\tnr = roundup_pow_of_two(nr + 1);\n\tnr *= (1024 / sizeof(struct file *));\n\tnr = ALIGN(nr, BITS_PER_LONG);\n\t \n\tif (unlikely(nr > sysctl_nr_open))\n\t\tnr = ((sysctl_nr_open - 1) | (BITS_PER_LONG - 1)) + 1;\n\n\tfdt = kmalloc(sizeof(struct fdtable), GFP_KERNEL_ACCOUNT);\n\tif (!fdt)\n\t\tgoto out;\n\tfdt->max_fds = nr;\n\tdata = kvmalloc_array(nr, sizeof(struct file *), GFP_KERNEL_ACCOUNT);\n\tif (!data)\n\t\tgoto out_fdt;\n\tfdt->fd = data;\n\n\tdata = kvmalloc(max_t(size_t,\n\t\t\t\t 2 * nr / BITS_PER_BYTE + BITBIT_SIZE(nr), L1_CACHE_BYTES),\n\t\t\t\t GFP_KERNEL_ACCOUNT);\n\tif (!data)\n\t\tgoto out_arr;\n\tfdt->open_fds = data;\n\tdata += nr / BITS_PER_BYTE;\n\tfdt->close_on_exec = data;\n\tdata += nr / BITS_PER_BYTE;\n\tfdt->full_fds_bits = data;\n\n\treturn fdt;\n\nout_arr:\n\tkvfree(fdt->fd);\nout_fdt:\n\tkfree(fdt);\nout:\n\treturn NULL;\n}\n\n \nstatic int expand_fdtable(struct files_struct *files, unsigned int nr)\n\t__releases(files->file_lock)\n\t__acquires(files->file_lock)\n{\n\tstruct fdtable *new_fdt, *cur_fdt;\n\n\tspin_unlock(&files->file_lock);\n\tnew_fdt = alloc_fdtable(nr);\n\n\t \n\tif (atomic_read(&files->count) > 1)\n\t\tsynchronize_rcu();\n\n\tspin_lock(&files->file_lock);\n\tif (!new_fdt)\n\t\treturn -ENOMEM;\n\t \n\tif (unlikely(new_fdt->max_fds <= nr)) {\n\t\t__free_fdtable(new_fdt);\n\t\treturn -EMFILE;\n\t}\n\tcur_fdt = files_fdtable(files);\n\tBUG_ON(nr < cur_fdt->max_fds);\n\tcopy_fdtable(new_fdt, cur_fdt);\n\trcu_assign_pointer(files->fdt, new_fdt);\n\tif (cur_fdt != &files->fdtab)\n\t\tcall_rcu(&cur_fdt->rcu, free_fdtable_rcu);\n\t \n\tsmp_wmb();\n\treturn 1;\n}\n\n \nstatic int expand_files(struct files_struct *files, unsigned int nr)\n\t__releases(files->file_lock)\n\t__acquires(files->file_lock)\n{\n\tstruct fdtable *fdt;\n\tint expanded = 0;\n\nrepeat:\n\tfdt = files_fdtable(files);\n\n\t \n\tif (nr < fdt->max_fds)\n\t\treturn expanded;\n\n\t \n\tif (nr >= sysctl_nr_open)\n\t\treturn -EMFILE;\n\n\tif (unlikely(files->resize_in_progress)) {\n\t\tspin_unlock(&files->file_lock);\n\t\texpanded = 1;\n\t\twait_event(files->resize_wait, !files->resize_in_progress);\n\t\tspin_lock(&files->file_lock);\n\t\tgoto repeat;\n\t}\n\n\t \n\tfiles->resize_in_progress = true;\n\texpanded = expand_fdtable(files, nr);\n\tfiles->resize_in_progress = false;\n\n\twake_up_all(&files->resize_wait);\n\treturn expanded;\n}\n\nstatic inline void __set_close_on_exec(unsigned int fd, struct fdtable *fdt)\n{\n\t__set_bit(fd, fdt->close_on_exec);\n}\n\nstatic inline void __clear_close_on_exec(unsigned int fd, struct fdtable *fdt)\n{\n\tif (test_bit(fd, fdt->close_on_exec))\n\t\t__clear_bit(fd, fdt->close_on_exec);\n}\n\nstatic inline void __set_open_fd(unsigned int fd, struct fdtable *fdt)\n{\n\t__set_bit(fd, fdt->open_fds);\n\tfd /= BITS_PER_LONG;\n\tif (!~fdt->open_fds[fd])\n\t\t__set_bit(fd, fdt->full_fds_bits);\n}\n\nstatic inline void __clear_open_fd(unsigned int fd, struct fdtable *fdt)\n{\n\t__clear_bit(fd, fdt->open_fds);\n\t__clear_bit(fd / BITS_PER_LONG, fdt->full_fds_bits);\n}\n\nstatic unsigned int count_open_files(struct fdtable *fdt)\n{\n\tunsigned int size = fdt->max_fds;\n\tunsigned int i;\n\n\t \n\tfor (i = size / BITS_PER_LONG; i > 0; ) {\n\t\tif (fdt->open_fds[--i])\n\t\t\tbreak;\n\t}\n\ti = (i + 1) * BITS_PER_LONG;\n\treturn i;\n}\n\n \nstatic unsigned int sane_fdtable_size(struct fdtable *fdt, unsigned int max_fds)\n{\n\tunsigned int count;\n\n\tcount = count_open_files(fdt);\n\tif (max_fds < NR_OPEN_DEFAULT)\n\t\tmax_fds = NR_OPEN_DEFAULT;\n\treturn ALIGN(min(count, max_fds), BITS_PER_LONG);\n}\n\n \nstruct files_struct *dup_fd(struct files_struct *oldf, unsigned int max_fds, int *errorp)\n{\n\tstruct files_struct *newf;\n\tstruct file **old_fds, **new_fds;\n\tunsigned int open_files, i;\n\tstruct fdtable *old_fdt, *new_fdt;\n\n\t*errorp = -ENOMEM;\n\tnewf = kmem_cache_alloc(files_cachep, GFP_KERNEL);\n\tif (!newf)\n\t\tgoto out;\n\n\tatomic_set(&newf->count, 1);\n\n\tspin_lock_init(&newf->file_lock);\n\tnewf->resize_in_progress = false;\n\tinit_waitqueue_head(&newf->resize_wait);\n\tnewf->next_fd = 0;\n\tnew_fdt = &newf->fdtab;\n\tnew_fdt->max_fds = NR_OPEN_DEFAULT;\n\tnew_fdt->close_on_exec = newf->close_on_exec_init;\n\tnew_fdt->open_fds = newf->open_fds_init;\n\tnew_fdt->full_fds_bits = newf->full_fds_bits_init;\n\tnew_fdt->fd = &newf->fd_array[0];\n\n\tspin_lock(&oldf->file_lock);\n\told_fdt = files_fdtable(oldf);\n\topen_files = sane_fdtable_size(old_fdt, max_fds);\n\n\t \n\twhile (unlikely(open_files > new_fdt->max_fds)) {\n\t\tspin_unlock(&oldf->file_lock);\n\n\t\tif (new_fdt != &newf->fdtab)\n\t\t\t__free_fdtable(new_fdt);\n\n\t\tnew_fdt = alloc_fdtable(open_files - 1);\n\t\tif (!new_fdt) {\n\t\t\t*errorp = -ENOMEM;\n\t\t\tgoto out_release;\n\t\t}\n\n\t\t \n\t\tif (unlikely(new_fdt->max_fds < open_files)) {\n\t\t\t__free_fdtable(new_fdt);\n\t\t\t*errorp = -EMFILE;\n\t\t\tgoto out_release;\n\t\t}\n\n\t\t \n\t\tspin_lock(&oldf->file_lock);\n\t\told_fdt = files_fdtable(oldf);\n\t\topen_files = sane_fdtable_size(old_fdt, max_fds);\n\t}\n\n\tcopy_fd_bitmaps(new_fdt, old_fdt, open_files);\n\n\told_fds = old_fdt->fd;\n\tnew_fds = new_fdt->fd;\n\n\tfor (i = open_files; i != 0; i--) {\n\t\tstruct file *f = *old_fds++;\n\t\tif (f) {\n\t\t\tget_file(f);\n\t\t} else {\n\t\t\t \n\t\t\t__clear_open_fd(open_files - i, new_fdt);\n\t\t}\n\t\trcu_assign_pointer(*new_fds++, f);\n\t}\n\tspin_unlock(&oldf->file_lock);\n\n\t \n\tmemset(new_fds, 0, (new_fdt->max_fds - open_files) * sizeof(struct file *));\n\n\trcu_assign_pointer(newf->fdt, new_fdt);\n\n\treturn newf;\n\nout_release:\n\tkmem_cache_free(files_cachep, newf);\nout:\n\treturn NULL;\n}\n\nstatic struct fdtable *close_files(struct files_struct * files)\n{\n\t \n\tstruct fdtable *fdt = rcu_dereference_raw(files->fdt);\n\tunsigned int i, j = 0;\n\n\tfor (;;) {\n\t\tunsigned long set;\n\t\ti = j * BITS_PER_LONG;\n\t\tif (i >= fdt->max_fds)\n\t\t\tbreak;\n\t\tset = fdt->open_fds[j++];\n\t\twhile (set) {\n\t\t\tif (set & 1) {\n\t\t\t\tstruct file * file = xchg(&fdt->fd[i], NULL);\n\t\t\t\tif (file) {\n\t\t\t\t\tfilp_close(file, files);\n\t\t\t\t\tcond_resched();\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++;\n\t\t\tset >>= 1;\n\t\t}\n\t}\n\n\treturn fdt;\n}\n\nvoid put_files_struct(struct files_struct *files)\n{\n\tif (atomic_dec_and_test(&files->count)) {\n\t\tstruct fdtable *fdt = close_files(files);\n\n\t\t \n\t\tif (fdt != &files->fdtab)\n\t\t\t__free_fdtable(fdt);\n\t\tkmem_cache_free(files_cachep, files);\n\t}\n}\n\nvoid exit_files(struct task_struct *tsk)\n{\n\tstruct files_struct * files = tsk->files;\n\n\tif (files) {\n\t\ttask_lock(tsk);\n\t\ttsk->files = NULL;\n\t\ttask_unlock(tsk);\n\t\tput_files_struct(files);\n\t}\n}\n\nstruct files_struct init_files = {\n\t.count\t\t= ATOMIC_INIT(1),\n\t.fdt\t\t= &init_files.fdtab,\n\t.fdtab\t\t= {\n\t\t.max_fds\t= NR_OPEN_DEFAULT,\n\t\t.fd\t\t= &init_files.fd_array[0],\n\t\t.close_on_exec\t= init_files.close_on_exec_init,\n\t\t.open_fds\t= init_files.open_fds_init,\n\t\t.full_fds_bits\t= init_files.full_fds_bits_init,\n\t},\n\t.file_lock\t= __SPIN_LOCK_UNLOCKED(init_files.file_lock),\n\t.resize_wait\t= __WAIT_QUEUE_HEAD_INITIALIZER(init_files.resize_wait),\n};\n\nstatic unsigned int find_next_fd(struct fdtable *fdt, unsigned int start)\n{\n\tunsigned int maxfd = fdt->max_fds;\n\tunsigned int maxbit = maxfd / BITS_PER_LONG;\n\tunsigned int bitbit = start / BITS_PER_LONG;\n\n\tbitbit = find_next_zero_bit(fdt->full_fds_bits, maxbit, bitbit) * BITS_PER_LONG;\n\tif (bitbit > maxfd)\n\t\treturn maxfd;\n\tif (bitbit > start)\n\t\tstart = bitbit;\n\treturn find_next_zero_bit(fdt->open_fds, maxfd, start);\n}\n\n \nstatic int alloc_fd(unsigned start, unsigned end, unsigned flags)\n{\n\tstruct files_struct *files = current->files;\n\tunsigned int fd;\n\tint error;\n\tstruct fdtable *fdt;\n\n\tspin_lock(&files->file_lock);\nrepeat:\n\tfdt = files_fdtable(files);\n\tfd = start;\n\tif (fd < files->next_fd)\n\t\tfd = files->next_fd;\n\n\tif (fd < fdt->max_fds)\n\t\tfd = find_next_fd(fdt, fd);\n\n\t \n\terror = -EMFILE;\n\tif (fd >= end)\n\t\tgoto out;\n\n\terror = expand_files(files, fd);\n\tif (error < 0)\n\t\tgoto out;\n\n\t \n\tif (error)\n\t\tgoto repeat;\n\n\tif (start <= files->next_fd)\n\t\tfiles->next_fd = fd + 1;\n\n\t__set_open_fd(fd, fdt);\n\tif (flags & O_CLOEXEC)\n\t\t__set_close_on_exec(fd, fdt);\n\telse\n\t\t__clear_close_on_exec(fd, fdt);\n\terror = fd;\n#if 1\n\t \n\tif (rcu_access_pointer(fdt->fd[fd]) != NULL) {\n\t\tprintk(KERN_WARNING \"alloc_fd: slot %d not NULL!\\n\", fd);\n\t\trcu_assign_pointer(fdt->fd[fd], NULL);\n\t}\n#endif\n\nout:\n\tspin_unlock(&files->file_lock);\n\treturn error;\n}\n\nint __get_unused_fd_flags(unsigned flags, unsigned long nofile)\n{\n\treturn alloc_fd(0, nofile, flags);\n}\n\nint get_unused_fd_flags(unsigned flags)\n{\n\treturn __get_unused_fd_flags(flags, rlimit(RLIMIT_NOFILE));\n}\nEXPORT_SYMBOL(get_unused_fd_flags);\n\nstatic void __put_unused_fd(struct files_struct *files, unsigned int fd)\n{\n\tstruct fdtable *fdt = files_fdtable(files);\n\t__clear_open_fd(fd, fdt);\n\tif (fd < files->next_fd)\n\t\tfiles->next_fd = fd;\n}\n\nvoid put_unused_fd(unsigned int fd)\n{\n\tstruct files_struct *files = current->files;\n\tspin_lock(&files->file_lock);\n\t__put_unused_fd(files, fd);\n\tspin_unlock(&files->file_lock);\n}\n\nEXPORT_SYMBOL(put_unused_fd);\n\n \n\nvoid fd_install(unsigned int fd, struct file *file)\n{\n\tstruct files_struct *files = current->files;\n\tstruct fdtable *fdt;\n\n\trcu_read_lock_sched();\n\n\tif (unlikely(files->resize_in_progress)) {\n\t\trcu_read_unlock_sched();\n\t\tspin_lock(&files->file_lock);\n\t\tfdt = files_fdtable(files);\n\t\tBUG_ON(fdt->fd[fd] != NULL);\n\t\trcu_assign_pointer(fdt->fd[fd], file);\n\t\tspin_unlock(&files->file_lock);\n\t\treturn;\n\t}\n\t \n\tsmp_rmb();\n\tfdt = rcu_dereference_sched(files->fdt);\n\tBUG_ON(fdt->fd[fd] != NULL);\n\trcu_assign_pointer(fdt->fd[fd], file);\n\trcu_read_unlock_sched();\n}\n\nEXPORT_SYMBOL(fd_install);\n\n \nstatic struct file *pick_file(struct files_struct *files, unsigned fd)\n{\n\tstruct fdtable *fdt = files_fdtable(files);\n\tstruct file *file;\n\n\tif (fd >= fdt->max_fds)\n\t\treturn NULL;\n\n\tfd = array_index_nospec(fd, fdt->max_fds);\n\tfile = fdt->fd[fd];\n\tif (file) {\n\t\trcu_assign_pointer(fdt->fd[fd], NULL);\n\t\t__put_unused_fd(files, fd);\n\t}\n\treturn file;\n}\n\nint close_fd(unsigned fd)\n{\n\tstruct files_struct *files = current->files;\n\tstruct file *file;\n\n\tspin_lock(&files->file_lock);\n\tfile = pick_file(files, fd);\n\tspin_unlock(&files->file_lock);\n\tif (!file)\n\t\treturn -EBADF;\n\n\treturn filp_close(file, files);\n}\nEXPORT_SYMBOL(close_fd);  \n\n \nstatic inline unsigned last_fd(struct fdtable *fdt)\n{\n\treturn fdt->max_fds - 1;\n}\n\nstatic inline void __range_cloexec(struct files_struct *cur_fds,\n\t\t\t\t   unsigned int fd, unsigned int max_fd)\n{\n\tstruct fdtable *fdt;\n\n\t \n\tspin_lock(&cur_fds->file_lock);\n\tfdt = files_fdtable(cur_fds);\n\tmax_fd = min(last_fd(fdt), max_fd);\n\tif (fd <= max_fd)\n\t\tbitmap_set(fdt->close_on_exec, fd, max_fd - fd + 1);\n\tspin_unlock(&cur_fds->file_lock);\n}\n\nstatic inline void __range_close(struct files_struct *files, unsigned int fd,\n\t\t\t\t unsigned int max_fd)\n{\n\tstruct file *file;\n\tunsigned n;\n\n\tspin_lock(&files->file_lock);\n\tn = last_fd(files_fdtable(files));\n\tmax_fd = min(max_fd, n);\n\n\tfor (; fd <= max_fd; fd++) {\n\t\tfile = pick_file(files, fd);\n\t\tif (file) {\n\t\t\tspin_unlock(&files->file_lock);\n\t\t\tfilp_close(file, files);\n\t\t\tcond_resched();\n\t\t\tspin_lock(&files->file_lock);\n\t\t} else if (need_resched()) {\n\t\t\tspin_unlock(&files->file_lock);\n\t\t\tcond_resched();\n\t\t\tspin_lock(&files->file_lock);\n\t\t}\n\t}\n\tspin_unlock(&files->file_lock);\n}\n\n \nint __close_range(unsigned fd, unsigned max_fd, unsigned int flags)\n{\n\tstruct task_struct *me = current;\n\tstruct files_struct *cur_fds = me->files, *fds = NULL;\n\n\tif (flags & ~(CLOSE_RANGE_UNSHARE | CLOSE_RANGE_CLOEXEC))\n\t\treturn -EINVAL;\n\n\tif (fd > max_fd)\n\t\treturn -EINVAL;\n\n\tif (flags & CLOSE_RANGE_UNSHARE) {\n\t\tint ret;\n\t\tunsigned int max_unshare_fds = NR_OPEN_MAX;\n\n\t\t \n\t\tif (!(flags & CLOSE_RANGE_CLOEXEC)) {\n\t\t\t \n\t\t\trcu_read_lock();\n\t\t\tif (max_fd >= last_fd(files_fdtable(cur_fds)))\n\t\t\t\tmax_unshare_fds = fd;\n\t\t\trcu_read_unlock();\n\t\t}\n\n\t\tret = unshare_fd(CLONE_FILES, max_unshare_fds, &fds);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tif (fds)\n\t\t\tswap(cur_fds, fds);\n\t}\n\n\tif (flags & CLOSE_RANGE_CLOEXEC)\n\t\t__range_cloexec(cur_fds, fd, max_fd);\n\telse\n\t\t__range_close(cur_fds, fd, max_fd);\n\n\tif (fds) {\n\t\t \n\t\ttask_lock(me);\n\t\tme->files = cur_fds;\n\t\ttask_unlock(me);\n\t\tput_files_struct(fds);\n\t}\n\n\treturn 0;\n}\n\n \nstruct file *__close_fd_get_file(unsigned int fd)\n{\n\treturn pick_file(current->files, fd);\n}\n\n \nstruct file *close_fd_get_file(unsigned int fd)\n{\n\tstruct files_struct *files = current->files;\n\tstruct file *file;\n\n\tspin_lock(&files->file_lock);\n\tfile = pick_file(files, fd);\n\tspin_unlock(&files->file_lock);\n\n\treturn file;\n}\n\nvoid do_close_on_exec(struct files_struct *files)\n{\n\tunsigned i;\n\tstruct fdtable *fdt;\n\n\t \n\tspin_lock(&files->file_lock);\n\tfor (i = 0; ; i++) {\n\t\tunsigned long set;\n\t\tunsigned fd = i * BITS_PER_LONG;\n\t\tfdt = files_fdtable(files);\n\t\tif (fd >= fdt->max_fds)\n\t\t\tbreak;\n\t\tset = fdt->close_on_exec[i];\n\t\tif (!set)\n\t\t\tcontinue;\n\t\tfdt->close_on_exec[i] = 0;\n\t\tfor ( ; set ; fd++, set >>= 1) {\n\t\t\tstruct file *file;\n\t\t\tif (!(set & 1))\n\t\t\t\tcontinue;\n\t\t\tfile = fdt->fd[fd];\n\t\t\tif (!file)\n\t\t\t\tcontinue;\n\t\t\trcu_assign_pointer(fdt->fd[fd], NULL);\n\t\t\t__put_unused_fd(files, fd);\n\t\t\tspin_unlock(&files->file_lock);\n\t\t\tfilp_close(file, files);\n\t\t\tcond_resched();\n\t\t\tspin_lock(&files->file_lock);\n\t\t}\n\n\t}\n\tspin_unlock(&files->file_lock);\n}\n\nstatic inline struct file *__fget_files_rcu(struct files_struct *files,\n\tunsigned int fd, fmode_t mask)\n{\n\tfor (;;) {\n\t\tstruct file *file;\n\t\tstruct fdtable *fdt = rcu_dereference_raw(files->fdt);\n\t\tstruct file __rcu **fdentry;\n\n\t\tif (unlikely(fd >= fdt->max_fds))\n\t\t\treturn NULL;\n\n\t\tfdentry = fdt->fd + array_index_nospec(fd, fdt->max_fds);\n\t\tfile = rcu_dereference_raw(*fdentry);\n\t\tif (unlikely(!file))\n\t\t\treturn NULL;\n\n\t\tif (unlikely(file->f_mode & mask))\n\t\t\treturn NULL;\n\n\t\t \n\t\tif (unlikely(!get_file_rcu(file)))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (unlikely(rcu_dereference_raw(files->fdt) != fdt) ||\n\t\t    unlikely(rcu_dereference_raw(*fdentry) != file)) {\n\t\t\tfput(file);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\treturn file;\n\t}\n}\n\nstatic struct file *__fget_files(struct files_struct *files, unsigned int fd,\n\t\t\t\t fmode_t mask)\n{\n\tstruct file *file;\n\n\trcu_read_lock();\n\tfile = __fget_files_rcu(files, fd, mask);\n\trcu_read_unlock();\n\n\treturn file;\n}\n\nstatic inline struct file *__fget(unsigned int fd, fmode_t mask)\n{\n\treturn __fget_files(current->files, fd, mask);\n}\n\nstruct file *fget(unsigned int fd)\n{\n\treturn __fget(fd, FMODE_PATH);\n}\nEXPORT_SYMBOL(fget);\n\nstruct file *fget_raw(unsigned int fd)\n{\n\treturn __fget(fd, 0);\n}\nEXPORT_SYMBOL(fget_raw);\n\nstruct file *fget_task(struct task_struct *task, unsigned int fd)\n{\n\tstruct file *file = NULL;\n\n\ttask_lock(task);\n\tif (task->files)\n\t\tfile = __fget_files(task->files, fd, 0);\n\ttask_unlock(task);\n\n\treturn file;\n}\n\nstruct file *task_lookup_fd_rcu(struct task_struct *task, unsigned int fd)\n{\n\t \n\tstruct files_struct *files;\n\tstruct file *file = NULL;\n\n\ttask_lock(task);\n\tfiles = task->files;\n\tif (files)\n\t\tfile = files_lookup_fd_rcu(files, fd);\n\ttask_unlock(task);\n\n\treturn file;\n}\n\nstruct file *task_lookup_next_fd_rcu(struct task_struct *task, unsigned int *ret_fd)\n{\n\t \n\tstruct files_struct *files;\n\tunsigned int fd = *ret_fd;\n\tstruct file *file = NULL;\n\n\ttask_lock(task);\n\tfiles = task->files;\n\tif (files) {\n\t\tfor (; fd < files_fdtable(files)->max_fds; fd++) {\n\t\t\tfile = files_lookup_fd_rcu(files, fd);\n\t\t\tif (file)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\ttask_unlock(task);\n\t*ret_fd = fd;\n\treturn file;\n}\nEXPORT_SYMBOL(task_lookup_next_fd_rcu);\n\n \nstatic unsigned long __fget_light(unsigned int fd, fmode_t mask)\n{\n\tstruct files_struct *files = current->files;\n\tstruct file *file;\n\n\t \n\tif (atomic_read_acquire(&files->count) == 1) {\n\t\tfile = files_lookup_fd_raw(files, fd);\n\t\tif (!file || unlikely(file->f_mode & mask))\n\t\t\treturn 0;\n\t\treturn (unsigned long)file;\n\t} else {\n\t\tfile = __fget(fd, mask);\n\t\tif (!file)\n\t\t\treturn 0;\n\t\treturn FDPUT_FPUT | (unsigned long)file;\n\t}\n}\nunsigned long __fdget(unsigned int fd)\n{\n\treturn __fget_light(fd, FMODE_PATH);\n}\nEXPORT_SYMBOL(__fdget);\n\nunsigned long __fdget_raw(unsigned int fd)\n{\n\treturn __fget_light(fd, 0);\n}\n\n \nstatic inline bool file_needs_f_pos_lock(struct file *file)\n{\n\treturn (file->f_mode & FMODE_ATOMIC_POS) &&\n\t\t(file_count(file) > 1 || file->f_op->iterate_shared);\n}\n\nunsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && file_needs_f_pos_lock(file)) {\n\t\tv |= FDPUT_POS_UNLOCK;\n\t\tmutex_lock(&file->f_pos_lock);\n\t}\n\treturn v;\n}\n\nvoid __f_unlock_pos(struct file *f)\n{\n\tmutex_unlock(&f->f_pos_lock);\n}\n\n \n\nvoid set_close_on_exec(unsigned int fd, int flag)\n{\n\tstruct files_struct *files = current->files;\n\tstruct fdtable *fdt;\n\tspin_lock(&files->file_lock);\n\tfdt = files_fdtable(files);\n\tif (flag)\n\t\t__set_close_on_exec(fd, fdt);\n\telse\n\t\t__clear_close_on_exec(fd, fdt);\n\tspin_unlock(&files->file_lock);\n}\n\nbool get_close_on_exec(unsigned int fd)\n{\n\tstruct files_struct *files = current->files;\n\tstruct fdtable *fdt;\n\tbool res;\n\trcu_read_lock();\n\tfdt = files_fdtable(files);\n\tres = close_on_exec(fd, fdt);\n\trcu_read_unlock();\n\treturn res;\n}\n\nstatic int do_dup2(struct files_struct *files,\n\tstruct file *file, unsigned fd, unsigned flags)\n__releases(&files->file_lock)\n{\n\tstruct file *tofree;\n\tstruct fdtable *fdt;\n\n\t \n\tfdt = files_fdtable(files);\n\ttofree = fdt->fd[fd];\n\tif (!tofree && fd_is_open(fd, fdt))\n\t\tgoto Ebusy;\n\tget_file(file);\n\trcu_assign_pointer(fdt->fd[fd], file);\n\t__set_open_fd(fd, fdt);\n\tif (flags & O_CLOEXEC)\n\t\t__set_close_on_exec(fd, fdt);\n\telse\n\t\t__clear_close_on_exec(fd, fdt);\n\tspin_unlock(&files->file_lock);\n\n\tif (tofree)\n\t\tfilp_close(tofree, files);\n\n\treturn fd;\n\nEbusy:\n\tspin_unlock(&files->file_lock);\n\treturn -EBUSY;\n}\n\nint replace_fd(unsigned fd, struct file *file, unsigned flags)\n{\n\tint err;\n\tstruct files_struct *files = current->files;\n\n\tif (!file)\n\t\treturn close_fd(fd);\n\n\tif (fd >= rlimit(RLIMIT_NOFILE))\n\t\treturn -EBADF;\n\n\tspin_lock(&files->file_lock);\n\terr = expand_files(files, fd);\n\tif (unlikely(err < 0))\n\t\tgoto out_unlock;\n\treturn do_dup2(files, file, fd, flags);\n\nout_unlock:\n\tspin_unlock(&files->file_lock);\n\treturn err;\n}\n\n \nint __receive_fd(struct file *file, int __user *ufd, unsigned int o_flags)\n{\n\tint new_fd;\n\tint error;\n\n\terror = security_file_receive(file);\n\tif (error)\n\t\treturn error;\n\n\tnew_fd = get_unused_fd_flags(o_flags);\n\tif (new_fd < 0)\n\t\treturn new_fd;\n\n\tif (ufd) {\n\t\terror = put_user(new_fd, ufd);\n\t\tif (error) {\n\t\t\tput_unused_fd(new_fd);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\tfd_install(new_fd, get_file(file));\n\t__receive_sock(file);\n\treturn new_fd;\n}\n\nint receive_fd_replace(int new_fd, struct file *file, unsigned int o_flags)\n{\n\tint error;\n\n\terror = security_file_receive(file);\n\tif (error)\n\t\treturn error;\n\terror = replace_fd(new_fd, file, o_flags);\n\tif (error)\n\t\treturn error;\n\t__receive_sock(file);\n\treturn new_fd;\n}\n\nint receive_fd(struct file *file, unsigned int o_flags)\n{\n\treturn __receive_fd(file, NULL, o_flags);\n}\nEXPORT_SYMBOL_GPL(receive_fd);\n\nstatic int ksys_dup3(unsigned int oldfd, unsigned int newfd, int flags)\n{\n\tint err = -EBADF;\n\tstruct file *file;\n\tstruct files_struct *files = current->files;\n\n\tif ((flags & ~O_CLOEXEC) != 0)\n\t\treturn -EINVAL;\n\n\tif (unlikely(oldfd == newfd))\n\t\treturn -EINVAL;\n\n\tif (newfd >= rlimit(RLIMIT_NOFILE))\n\t\treturn -EBADF;\n\n\tspin_lock(&files->file_lock);\n\terr = expand_files(files, newfd);\n\tfile = files_lookup_fd_locked(files, oldfd);\n\tif (unlikely(!file))\n\t\tgoto Ebadf;\n\tif (unlikely(err < 0)) {\n\t\tif (err == -EMFILE)\n\t\t\tgoto Ebadf;\n\t\tgoto out_unlock;\n\t}\n\treturn do_dup2(files, file, newfd, flags);\n\nEbadf:\n\terr = -EBADF;\nout_unlock:\n\tspin_unlock(&files->file_lock);\n\treturn err;\n}\n\nSYSCALL_DEFINE3(dup3, unsigned int, oldfd, unsigned int, newfd, int, flags)\n{\n\treturn ksys_dup3(oldfd, newfd, flags);\n}\n\nSYSCALL_DEFINE2(dup2, unsigned int, oldfd, unsigned int, newfd)\n{\n\tif (unlikely(newfd == oldfd)) {  \n\t\tstruct files_struct *files = current->files;\n\t\tint retval = oldfd;\n\n\t\trcu_read_lock();\n\t\tif (!files_lookup_fd_rcu(files, oldfd))\n\t\t\tretval = -EBADF;\n\t\trcu_read_unlock();\n\t\treturn retval;\n\t}\n\treturn ksys_dup3(oldfd, newfd, 0);\n}\n\nSYSCALL_DEFINE1(dup, unsigned int, fildes)\n{\n\tint ret = -EBADF;\n\tstruct file *file = fget_raw(fildes);\n\n\tif (file) {\n\t\tret = get_unused_fd_flags(0);\n\t\tif (ret >= 0)\n\t\t\tfd_install(ret, file);\n\t\telse\n\t\t\tfput(file);\n\t}\n\treturn ret;\n}\n\nint f_dupfd(unsigned int from, struct file *file, unsigned flags)\n{\n\tunsigned long nofile = rlimit(RLIMIT_NOFILE);\n\tint err;\n\tif (from >= nofile)\n\t\treturn -EINVAL;\n\terr = alloc_fd(from, nofile, flags);\n\tif (err >= 0) {\n\t\tget_file(file);\n\t\tfd_install(err, file);\n\t}\n\treturn err;\n}\n\nint iterate_fd(struct files_struct *files, unsigned n,\n\t\tint (*f)(const void *, struct file *, unsigned),\n\t\tconst void *p)\n{\n\tstruct fdtable *fdt;\n\tint res = 0;\n\tif (!files)\n\t\treturn 0;\n\tspin_lock(&files->file_lock);\n\tfor (fdt = files_fdtable(files); n < fdt->max_fds; n++) {\n\t\tstruct file *file;\n\t\tfile = rcu_dereference_check_fdtable(files, fdt->fd[n]);\n\t\tif (!file)\n\t\t\tcontinue;\n\t\tres = f(p, file, n);\n\t\tif (res)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&files->file_lock);\n\treturn res;\n}\nEXPORT_SYMBOL(iterate_fd);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}