{
  "module_name": "mnt_idmapping.c",
  "hash_id": "b5d96873781025ae6cc48a53718fd570997d2a64b0c927ddcf5e9436509be9f4",
  "original_prompt": "Ingested from linux-6.6.14/fs/mnt_idmapping.c",
  "human_readable_source": "\n \n\n#include <linux/cred.h>\n#include <linux/fs.h>\n#include <linux/mnt_idmapping.h>\n#include <linux/slab.h>\n#include <linux/user_namespace.h>\n\n#include \"internal.h\"\n\nstruct mnt_idmap {\n\tstruct user_namespace *owner;\n\trefcount_t count;\n};\n\n \nstruct mnt_idmap nop_mnt_idmap = {\n\t.owner\t= &init_user_ns,\n\t.count\t= REFCOUNT_INIT(1),\n};\nEXPORT_SYMBOL_GPL(nop_mnt_idmap);\n\n \nbool check_fsmapping(const struct mnt_idmap *idmap,\n\t\t     const struct super_block *sb)\n{\n\treturn idmap->owner != sb->s_user_ns;\n}\n\n \nstatic inline bool initial_idmapping(const struct user_namespace *ns)\n{\n\treturn ns == &init_user_ns;\n}\n\n \nstatic inline bool no_idmapping(const struct user_namespace *mnt_userns,\n\t\t\t\tconst struct user_namespace *fs_userns)\n{\n\treturn initial_idmapping(mnt_userns) || mnt_userns == fs_userns;\n}\n\n \n\nvfsuid_t make_vfsuid(struct mnt_idmap *idmap,\n\t\t\t\t   struct user_namespace *fs_userns,\n\t\t\t\t   kuid_t kuid)\n{\n\tuid_t uid;\n\tstruct user_namespace *mnt_userns = idmap->owner;\n\n\tif (no_idmapping(mnt_userns, fs_userns))\n\t\treturn VFSUIDT_INIT(kuid);\n\tif (initial_idmapping(fs_userns))\n\t\tuid = __kuid_val(kuid);\n\telse\n\t\tuid = from_kuid(fs_userns, kuid);\n\tif (uid == (uid_t)-1)\n\t\treturn INVALID_VFSUID;\n\treturn VFSUIDT_INIT(make_kuid(mnt_userns, uid));\n}\nEXPORT_SYMBOL_GPL(make_vfsuid);\n\n \nvfsgid_t make_vfsgid(struct mnt_idmap *idmap,\n\t\t     struct user_namespace *fs_userns, kgid_t kgid)\n{\n\tgid_t gid;\n\tstruct user_namespace *mnt_userns = idmap->owner;\n\n\tif (no_idmapping(mnt_userns, fs_userns))\n\t\treturn VFSGIDT_INIT(kgid);\n\tif (initial_idmapping(fs_userns))\n\t\tgid = __kgid_val(kgid);\n\telse\n\t\tgid = from_kgid(fs_userns, kgid);\n\tif (gid == (gid_t)-1)\n\t\treturn INVALID_VFSGID;\n\treturn VFSGIDT_INIT(make_kgid(mnt_userns, gid));\n}\nEXPORT_SYMBOL_GPL(make_vfsgid);\n\n \nkuid_t from_vfsuid(struct mnt_idmap *idmap,\n\t\t   struct user_namespace *fs_userns, vfsuid_t vfsuid)\n{\n\tuid_t uid;\n\tstruct user_namespace *mnt_userns = idmap->owner;\n\n\tif (no_idmapping(mnt_userns, fs_userns))\n\t\treturn AS_KUIDT(vfsuid);\n\tuid = from_kuid(mnt_userns, AS_KUIDT(vfsuid));\n\tif (uid == (uid_t)-1)\n\t\treturn INVALID_UID;\n\tif (initial_idmapping(fs_userns))\n\t\treturn KUIDT_INIT(uid);\n\treturn make_kuid(fs_userns, uid);\n}\nEXPORT_SYMBOL_GPL(from_vfsuid);\n\n \nkgid_t from_vfsgid(struct mnt_idmap *idmap,\n\t\t   struct user_namespace *fs_userns, vfsgid_t vfsgid)\n{\n\tgid_t gid;\n\tstruct user_namespace *mnt_userns = idmap->owner;\n\n\tif (no_idmapping(mnt_userns, fs_userns))\n\t\treturn AS_KGIDT(vfsgid);\n\tgid = from_kgid(mnt_userns, AS_KGIDT(vfsgid));\n\tif (gid == (gid_t)-1)\n\t\treturn INVALID_GID;\n\tif (initial_idmapping(fs_userns))\n\t\treturn KGIDT_INIT(gid);\n\treturn make_kgid(fs_userns, gid);\n}\nEXPORT_SYMBOL_GPL(from_vfsgid);\n\n#ifdef CONFIG_MULTIUSER\n \nint vfsgid_in_group_p(vfsgid_t vfsgid)\n{\n\treturn in_group_p(AS_KGIDT(vfsgid));\n}\n#else\nint vfsgid_in_group_p(vfsgid_t vfsgid)\n{\n\treturn 1;\n}\n#endif\nEXPORT_SYMBOL_GPL(vfsgid_in_group_p);\n\nstruct mnt_idmap *alloc_mnt_idmap(struct user_namespace *mnt_userns)\n{\n\tstruct mnt_idmap *idmap;\n\n\tidmap = kzalloc(sizeof(struct mnt_idmap), GFP_KERNEL_ACCOUNT);\n\tif (!idmap)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tidmap->owner = get_user_ns(mnt_userns);\n\trefcount_set(&idmap->count, 1);\n\treturn idmap;\n}\n\n \nstruct mnt_idmap *mnt_idmap_get(struct mnt_idmap *idmap)\n{\n\tif (idmap != &nop_mnt_idmap)\n\t\trefcount_inc(&idmap->count);\n\n\treturn idmap;\n}\n\n \nvoid mnt_idmap_put(struct mnt_idmap *idmap)\n{\n\tif (idmap != &nop_mnt_idmap && refcount_dec_and_test(&idmap->count)) {\n\t\tput_user_ns(idmap->owner);\n\t\tkfree(idmap);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}