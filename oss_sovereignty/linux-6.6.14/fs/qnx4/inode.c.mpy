{
  "module_name": "inode.c",
  "hash_id": "10414f6e3bd50aba4208ea58cc994d130d86276949356704aab2c2332e1c4f2b",
  "original_prompt": "Ingested from linux-6.6.14/fs/qnx4/inode.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/highuid.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/statfs.h>\n#include \"qnx4.h\"\n\n#define QNX4_VERSION  4\n#define QNX4_BMNAME   \".bitmap\"\n\nstatic const struct super_operations qnx4_sops;\n\nstatic struct inode *qnx4_alloc_inode(struct super_block *sb);\nstatic void qnx4_free_inode(struct inode *inode);\nstatic int qnx4_remount(struct super_block *sb, int *flags, char *data);\nstatic int qnx4_statfs(struct dentry *, struct kstatfs *);\n\nstatic const struct super_operations qnx4_sops =\n{\n\t.alloc_inode\t= qnx4_alloc_inode,\n\t.free_inode\t= qnx4_free_inode,\n\t.statfs\t\t= qnx4_statfs,\n\t.remount_fs\t= qnx4_remount,\n};\n\nstatic int qnx4_remount(struct super_block *sb, int *flags, char *data)\n{\n\tstruct qnx4_sb_info *qs;\n\n\tsync_filesystem(sb);\n\tqs = qnx4_sb(sb);\n\tqs->Version = QNX4_VERSION;\n\t*flags |= SB_RDONLY;\n\treturn 0;\n}\n\nstatic int qnx4_get_block( struct inode *inode, sector_t iblock, struct buffer_head *bh, int create )\n{\n\tunsigned long phys;\n\n\tQNX4DEBUG((KERN_INFO \"qnx4: qnx4_get_block inode=[%ld] iblock=[%ld]\\n\",inode->i_ino,iblock));\n\n\tphys = qnx4_block_map( inode, iblock );\n\tif ( phys ) {\n\t\t\n\t\tmap_bh(bh, inode->i_sb, phys);\n\t}\n\treturn 0;\n}\n\nstatic inline u32 try_extent(qnx4_xtnt_t *extent, u32 *offset)\n{\n\tu32 size = le32_to_cpu(extent->xtnt_size);\n\tif (*offset < size)\n\t\treturn le32_to_cpu(extent->xtnt_blk) + *offset - 1;\n\t*offset -= size;\n\treturn 0;\n}\n\nunsigned long qnx4_block_map( struct inode *inode, long iblock )\n{\n\tint ix;\n\tlong i_xblk;\n\tstruct buffer_head *bh = NULL;\n\tstruct qnx4_xblk *xblk = NULL;\n\tstruct qnx4_inode_entry *qnx4_inode = qnx4_raw_inode(inode);\n\tu16 nxtnt = le16_to_cpu(qnx4_inode->di_num_xtnts);\n\tu32 offset = iblock;\n\tu32 block = try_extent(&qnx4_inode->di_first_xtnt, &offset);\n\n\tif (block) {\n\t\t\n\t} else {\n\t\t\n\t\ti_xblk = le32_to_cpu(qnx4_inode->di_xblk);\n\t\tix = 0;\n\t\twhile ( --nxtnt > 0 ) {\n\t\t\tif ( ix == 0 ) {\n\t\t\t\t\n\t\t\t\tbh = sb_bread(inode->i_sb, i_xblk - 1);\n\t\t\t\tif ( !bh ) {\n\t\t\t\t\tQNX4DEBUG((KERN_ERR \"qnx4: I/O error reading xtnt block [%ld])\\n\", i_xblk - 1));\n\t\t\t\t\treturn -EIO;\n\t\t\t\t}\n\t\t\t\txblk = (struct qnx4_xblk*)bh->b_data;\n\t\t\t\tif ( memcmp( xblk->xblk_signature, \"IamXblk\", 7 ) ) {\n\t\t\t\t\tQNX4DEBUG((KERN_ERR \"qnx4: block at %ld is not a valid xtnt\\n\", qnx4_inode->i_xblk));\n\t\t\t\t\treturn -EIO;\n\t\t\t\t}\n\t\t\t}\n\t\t\tblock = try_extent(&xblk->xblk_xtnts[ix], &offset);\n\t\t\tif (block) {\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( ++ix >= xblk->xblk_num_xtnts ) {\n\t\t\t\ti_xblk = le32_to_cpu(xblk->xblk_next_xblk);\n\t\t\t\tix = 0;\n\t\t\t\tbrelse( bh );\n\t\t\t\tbh = NULL;\n\t\t\t}\n\t\t}\n\t\tif ( bh )\n\t\t\tbrelse( bh );\n\t}\n\n\tQNX4DEBUG((KERN_INFO \"qnx4: mapping block %ld of inode %ld = %ld\\n\",iblock,inode->i_ino,block));\n\treturn block;\n}\n\nstatic int qnx4_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tu64 id = huge_encode_dev(sb->s_bdev->bd_dev);\n\n\tbuf->f_type    = sb->s_magic;\n\tbuf->f_bsize   = sb->s_blocksize;\n\tbuf->f_blocks  = le32_to_cpu(qnx4_sb(sb)->BitMap->di_size) * 8;\n\tbuf->f_bfree   = qnx4_count_free_blocks(sb);\n\tbuf->f_bavail  = buf->f_bfree;\n\tbuf->f_namelen = QNX4_NAME_MAX;\n\tbuf->f_fsid    = u64_to_fsid(id);\n\n\treturn 0;\n}\n\n \nstatic const char *qnx4_checkroot(struct super_block *sb,\n\t\t\t\t  struct qnx4_super_block *s)\n{\n\tstruct buffer_head *bh;\n\tstruct qnx4_inode_entry *rootdir;\n\tint rd, rl;\n\tint i, j;\n\n\tif (s->RootDir.di_fname[0] != '/' || s->RootDir.di_fname[1] != '\\0')\n\t\treturn \"no qnx4 filesystem (no root dir).\";\n\tQNX4DEBUG((KERN_NOTICE \"QNX4 filesystem found on dev %s.\\n\", sb->s_id));\n\trd = le32_to_cpu(s->RootDir.di_first_xtnt.xtnt_blk) - 1;\n\trl = le32_to_cpu(s->RootDir.di_first_xtnt.xtnt_size);\n\tfor (j = 0; j < rl; j++) {\n\t\tbh = sb_bread(sb, rd + j);\t \n\t\tif (bh == NULL)\n\t\t\treturn \"unable to read root entry.\";\n\t\trootdir = (struct qnx4_inode_entry *) bh->b_data;\n\t\tfor (i = 0; i < QNX4_INODES_PER_BLOCK; i++, rootdir++) {\n\t\t\tQNX4DEBUG((KERN_INFO \"rootdir entry found : [%s]\\n\", rootdir->di_fname));\n\t\t\tif (strcmp(rootdir->di_fname, QNX4_BMNAME) != 0)\n\t\t\t\tcontinue;\n\t\t\tqnx4_sb(sb)->BitMap = kmemdup(rootdir,\n\t\t\t\t\t\t      sizeof(struct qnx4_inode_entry),\n\t\t\t\t\t\t      GFP_KERNEL);\n\t\t\tbrelse(bh);\n\t\t\tif (!qnx4_sb(sb)->BitMap)\n\t\t\t\treturn \"not enough memory for bitmap inode\";\n\t\t\t \n\t\t\treturn NULL;\n\t\t}\n\t\tbrelse(bh);\n\t}\n\treturn \"bitmap file not found.\";\n}\n\nstatic int qnx4_fill_super(struct super_block *s, void *data, int silent)\n{\n\tstruct buffer_head *bh;\n\tstruct inode *root;\n\tconst char *errmsg;\n\tstruct qnx4_sb_info *qs;\n\n\tqs = kzalloc(sizeof(struct qnx4_sb_info), GFP_KERNEL);\n\tif (!qs)\n\t\treturn -ENOMEM;\n\ts->s_fs_info = qs;\n\n\tsb_set_blocksize(s, QNX4_BLOCK_SIZE);\n\n\ts->s_op = &qnx4_sops;\n\ts->s_magic = QNX4_SUPER_MAGIC;\n\ts->s_flags |= SB_RDONLY;\t \n\ts->s_time_min = 0;\n\ts->s_time_max = U32_MAX;\n\n\t \n\tbh = sb_bread(s, 1);\n\tif (!bh) {\n\t\tprintk(KERN_ERR \"qnx4: unable to read the superblock\\n\");\n\t\treturn -EINVAL;\n\t}\n\n \t \n\terrmsg = qnx4_checkroot(s, (struct qnx4_super_block *) bh->b_data);\n\tbrelse(bh);\n\tif (errmsg != NULL) {\n \t\tif (!silent)\n\t\t\tprintk(KERN_ERR \"qnx4: %s\\n\", errmsg);\n\t\treturn -EINVAL;\n\t}\n\n \t \n\troot = qnx4_iget(s, QNX4_ROOT_INO * QNX4_INODES_PER_BLOCK);\n\tif (IS_ERR(root)) {\n\t\tprintk(KERN_ERR \"qnx4: get inode failed\\n\");\n\t\treturn PTR_ERR(root);\n \t}\n\n \ts->s_root = d_make_root(root);\n \tif (s->s_root == NULL)\n \t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void qnx4_kill_sb(struct super_block *sb)\n{\n\tstruct qnx4_sb_info *qs = qnx4_sb(sb);\n\tkill_block_super(sb);\n\tif (qs) {\n\t\tkfree(qs->BitMap);\n\t\tkfree(qs);\n\t}\n}\n\nstatic int qnx4_read_folio(struct file *file, struct folio *folio)\n{\n\treturn block_read_full_folio(folio, qnx4_get_block);\n}\n\nstatic sector_t qnx4_bmap(struct address_space *mapping, sector_t block)\n{\n\treturn generic_block_bmap(mapping,block,qnx4_get_block);\n}\n\nstatic const struct address_space_operations qnx4_aops = {\n\t.read_folio\t= qnx4_read_folio,\n\t.bmap\t\t= qnx4_bmap\n};\n\nstruct inode *qnx4_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct buffer_head *bh;\n\tstruct qnx4_inode_entry *raw_inode;\n\tint block;\n\tstruct qnx4_inode_entry *qnx4_inode;\n\tstruct inode *inode;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tqnx4_inode = qnx4_raw_inode(inode);\n\tinode->i_mode = 0;\n\n\tQNX4DEBUG((KERN_INFO \"reading inode : [%d]\\n\", ino));\n\tif (!ino) {\n\t\tprintk(KERN_ERR \"qnx4: bad inode number on dev %s: %lu is \"\n\t\t\t\t\"out of range\\n\",\n\t\t       sb->s_id, ino);\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tblock = ino / QNX4_INODES_PER_BLOCK;\n\n\tif (!(bh = sb_bread(sb, block))) {\n\t\tprintk(KERN_ERR \"qnx4: major problem: unable to read inode from dev \"\n\t\t       \"%s\\n\", sb->s_id);\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\traw_inode = ((struct qnx4_inode_entry *) bh->b_data) +\n\t    (ino % QNX4_INODES_PER_BLOCK);\n\n\tinode->i_mode    = le16_to_cpu(raw_inode->di_mode);\n\ti_uid_write(inode, (uid_t)le16_to_cpu(raw_inode->di_uid));\n\ti_gid_write(inode, (gid_t)le16_to_cpu(raw_inode->di_gid));\n\tset_nlink(inode, le16_to_cpu(raw_inode->di_nlink));\n\tinode->i_size    = le32_to_cpu(raw_inode->di_size);\n\tinode->i_mtime.tv_sec   = le32_to_cpu(raw_inode->di_mtime);\n\tinode->i_mtime.tv_nsec = 0;\n\tinode->i_atime.tv_sec   = le32_to_cpu(raw_inode->di_atime);\n\tinode->i_atime.tv_nsec = 0;\n\tinode_set_ctime(inode, le32_to_cpu(raw_inode->di_ctime), 0);\n\tinode->i_blocks  = le32_to_cpu(raw_inode->di_first_xtnt.xtnt_size);\n\n\tmemcpy(qnx4_inode, raw_inode, QNX4_DIR_ENTRY_SIZE);\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_fop = &generic_ro_fops;\n\t\tinode->i_mapping->a_ops = &qnx4_aops;\n\t\tqnx4_i(inode)->mmu_private = inode->i_size;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &qnx4_dir_inode_operations;\n\t\tinode->i_fop = &qnx4_dir_operations;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &page_symlink_inode_operations;\n\t\tinode_nohighmem(inode);\n\t\tinode->i_mapping->a_ops = &qnx4_aops;\n\t\tqnx4_i(inode)->mmu_private = inode->i_size;\n\t} else {\n\t\tprintk(KERN_ERR \"qnx4: bad inode %lu on dev %s\\n\",\n\t\t\tino, sb->s_id);\n\t\tiget_failed(inode);\n\t\tbrelse(bh);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tbrelse(bh);\n\tunlock_new_inode(inode);\n\treturn inode;\n}\n\nstatic struct kmem_cache *qnx4_inode_cachep;\n\nstatic struct inode *qnx4_alloc_inode(struct super_block *sb)\n{\n\tstruct qnx4_inode_info *ei;\n\tei = alloc_inode_sb(sb, qnx4_inode_cachep, GFP_KERNEL);\n\tif (!ei)\n\t\treturn NULL;\n\treturn &ei->vfs_inode;\n}\n\nstatic void qnx4_free_inode(struct inode *inode)\n{\n\tkmem_cache_free(qnx4_inode_cachep, qnx4_i(inode));\n}\n\nstatic void init_once(void *foo)\n{\n\tstruct qnx4_inode_info *ei = (struct qnx4_inode_info *) foo;\n\n\tinode_init_once(&ei->vfs_inode);\n}\n\nstatic int init_inodecache(void)\n{\n\tqnx4_inode_cachep = kmem_cache_create(\"qnx4_inode_cache\",\n\t\t\t\t\t     sizeof(struct qnx4_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD|SLAB_ACCOUNT),\n\t\t\t\t\t     init_once);\n\tif (qnx4_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic void destroy_inodecache(void)\n{\n\t \n\trcu_barrier();\n\tkmem_cache_destroy(qnx4_inode_cachep);\n}\n\nstatic struct dentry *qnx4_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, qnx4_fill_super);\n}\n\nstatic struct file_system_type qnx4_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"qnx4\",\n\t.mount\t\t= qnx4_mount,\n\t.kill_sb\t= qnx4_kill_sb,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\nMODULE_ALIAS_FS(\"qnx4\");\n\nstatic int __init init_qnx4_fs(void)\n{\n\tint err;\n\n\terr = init_inodecache();\n\tif (err)\n\t\treturn err;\n\n\terr = register_filesystem(&qnx4_fs_type);\n\tif (err) {\n\t\tdestroy_inodecache();\n\t\treturn err;\n\t}\n\n\tprintk(KERN_INFO \"QNX4 filesystem 0.2.3 registered.\\n\");\n\treturn 0;\n}\n\nstatic void __exit exit_qnx4_fs(void)\n{\n\tunregister_filesystem(&qnx4_fs_type);\n\tdestroy_inodecache();\n}\n\nmodule_init(init_qnx4_fs)\nmodule_exit(exit_qnx4_fs)\nMODULE_LICENSE(\"GPL\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}