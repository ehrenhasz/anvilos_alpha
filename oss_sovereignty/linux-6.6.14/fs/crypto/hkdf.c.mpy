{
  "module_name": "hkdf.c",
  "hash_id": "b6543968e946566c3198d4156923025b1336de610ec4b180858fe0d8c2931bce",
  "original_prompt": "Ingested from linux-6.6.14/fs/crypto/hkdf.c",
  "human_readable_source": "\n \n\n#include <crypto/hash.h>\n#include <crypto/sha2.h>\n\n#include \"fscrypt_private.h\"\n\n \n#define HKDF_HMAC_ALG\t\t\"hmac(sha512)\"\n#define HKDF_HASHLEN\t\tSHA512_DIGEST_SIZE\n\n \n\n \nstatic int hkdf_extract(struct crypto_shash *hmac_tfm, const u8 *ikm,\n\t\t\tunsigned int ikmlen, u8 prk[HKDF_HASHLEN])\n{\n\tstatic const u8 default_salt[HKDF_HASHLEN];\n\tint err;\n\n\terr = crypto_shash_setkey(hmac_tfm, default_salt, HKDF_HASHLEN);\n\tif (err)\n\t\treturn err;\n\n\treturn crypto_shash_tfm_digest(hmac_tfm, ikm, ikmlen, prk);\n}\n\n \nint fscrypt_init_hkdf(struct fscrypt_hkdf *hkdf, const u8 *master_key,\n\t\t      unsigned int master_key_size)\n{\n\tstruct crypto_shash *hmac_tfm;\n\tu8 prk[HKDF_HASHLEN];\n\tint err;\n\n\thmac_tfm = crypto_alloc_shash(HKDF_HMAC_ALG, 0, 0);\n\tif (IS_ERR(hmac_tfm)) {\n\t\tfscrypt_err(NULL, \"Error allocating \" HKDF_HMAC_ALG \": %ld\",\n\t\t\t    PTR_ERR(hmac_tfm));\n\t\treturn PTR_ERR(hmac_tfm);\n\t}\n\n\tif (WARN_ON_ONCE(crypto_shash_digestsize(hmac_tfm) != sizeof(prk))) {\n\t\terr = -EINVAL;\n\t\tgoto err_free_tfm;\n\t}\n\n\terr = hkdf_extract(hmac_tfm, master_key, master_key_size, prk);\n\tif (err)\n\t\tgoto err_free_tfm;\n\n\terr = crypto_shash_setkey(hmac_tfm, prk, sizeof(prk));\n\tif (err)\n\t\tgoto err_free_tfm;\n\n\thkdf->hmac_tfm = hmac_tfm;\n\tgoto out;\n\nerr_free_tfm:\n\tcrypto_free_shash(hmac_tfm);\nout:\n\tmemzero_explicit(prk, sizeof(prk));\n\treturn err;\n}\n\n \nint fscrypt_hkdf_expand(const struct fscrypt_hkdf *hkdf, u8 context,\n\t\t\tconst u8 *info, unsigned int infolen,\n\t\t\tu8 *okm, unsigned int okmlen)\n{\n\tSHASH_DESC_ON_STACK(desc, hkdf->hmac_tfm);\n\tu8 prefix[9];\n\tunsigned int i;\n\tint err;\n\tconst u8 *prev = NULL;\n\tu8 counter = 1;\n\tu8 tmp[HKDF_HASHLEN];\n\n\tif (WARN_ON_ONCE(okmlen > 255 * HKDF_HASHLEN))\n\t\treturn -EINVAL;\n\n\tdesc->tfm = hkdf->hmac_tfm;\n\n\tmemcpy(prefix, \"fscrypt\\0\", 8);\n\tprefix[8] = context;\n\n\tfor (i = 0; i < okmlen; i += HKDF_HASHLEN) {\n\n\t\terr = crypto_shash_init(desc);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tif (prev) {\n\t\t\terr = crypto_shash_update(desc, prev, HKDF_HASHLEN);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\terr = crypto_shash_update(desc, prefix, sizeof(prefix));\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = crypto_shash_update(desc, info, infolen);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tBUILD_BUG_ON(sizeof(counter) != 1);\n\t\tif (okmlen - i < HKDF_HASHLEN) {\n\t\t\terr = crypto_shash_finup(desc, &counter, 1, tmp);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tmemcpy(&okm[i], tmp, okmlen - i);\n\t\t\tmemzero_explicit(tmp, sizeof(tmp));\n\t\t} else {\n\t\t\terr = crypto_shash_finup(desc, &counter, 1, &okm[i]);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t\tcounter++;\n\t\tprev = &okm[i];\n\t}\n\terr = 0;\nout:\n\tif (unlikely(err))\n\t\tmemzero_explicit(okm, okmlen);  \n\tshash_desc_zero(desc);\n\treturn err;\n}\n\nvoid fscrypt_destroy_hkdf(struct fscrypt_hkdf *hkdf)\n{\n\tcrypto_free_shash(hkdf->hmac_tfm);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}