{
  "module_name": "fname.c",
  "hash_id": "6443477a2c62f388a85c7314bfbf338e77916feec9b4208cb9bb9914cf1e47d1",
  "original_prompt": "Ingested from linux-6.6.14/fs/crypto/fname.c",
  "human_readable_source": "\n \n\n#include <linux/namei.h>\n#include <linux/scatterlist.h>\n#include <crypto/hash.h>\n#include <crypto/sha2.h>\n#include <crypto/skcipher.h>\n#include \"fscrypt_private.h\"\n\n \n#define FSCRYPT_FNAME_MIN_MSG_LEN 16\n\n \nstruct fscrypt_nokey_name {\n\tu32 dirhash[2];\n\tu8 bytes[149];\n\tu8 sha256[SHA256_DIGEST_SIZE];\n};  \n\n \n#define FSCRYPT_NOKEY_NAME_MAX\toffsetofend(struct fscrypt_nokey_name, sha256)\n\n \n#define FSCRYPT_NOKEY_NAME_MAX_ENCODED \\\n\t\tFSCRYPT_BASE64URL_CHARS(FSCRYPT_NOKEY_NAME_MAX)\n\nstatic inline bool fscrypt_is_dot_dotdot(const struct qstr *str)\n{\n\tif (str->len == 1 && str->name[0] == '.')\n\t\treturn true;\n\n\tif (str->len == 2 && str->name[0] == '.' && str->name[1] == '.')\n\t\treturn true;\n\n\treturn false;\n}\n\n \nint fscrypt_fname_encrypt(const struct inode *inode, const struct qstr *iname,\n\t\t\t  u8 *out, unsigned int olen)\n{\n\tstruct skcipher_request *req = NULL;\n\tDECLARE_CRYPTO_WAIT(wait);\n\tconst struct fscrypt_info *ci = inode->i_crypt_info;\n\tstruct crypto_skcipher *tfm = ci->ci_enc_key.tfm;\n\tunion fscrypt_iv iv;\n\tstruct scatterlist sg;\n\tint res;\n\n\t \n\tif (WARN_ON_ONCE(olen < iname->len))\n\t\treturn -ENOBUFS;\n\tmemcpy(out, iname->name, iname->len);\n\tmemset(out + iname->len, 0, olen - iname->len);\n\n\t \n\tfscrypt_generate_iv(&iv, 0, ci);\n\n\t \n\treq = skcipher_request_alloc(tfm, GFP_NOFS);\n\tif (!req)\n\t\treturn -ENOMEM;\n\tskcipher_request_set_callback(req,\n\t\t\tCRYPTO_TFM_REQ_MAY_BACKLOG | CRYPTO_TFM_REQ_MAY_SLEEP,\n\t\t\tcrypto_req_done, &wait);\n\tsg_init_one(&sg, out, olen);\n\tskcipher_request_set_crypt(req, &sg, &sg, olen, &iv);\n\n\t \n\tres = crypto_wait_req(crypto_skcipher_encrypt(req), &wait);\n\tskcipher_request_free(req);\n\tif (res < 0) {\n\t\tfscrypt_err(inode, \"Filename encryption failed: %d\", res);\n\t\treturn res;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(fscrypt_fname_encrypt);\n\n \nstatic int fname_decrypt(const struct inode *inode,\n\t\t\t const struct fscrypt_str *iname,\n\t\t\t struct fscrypt_str *oname)\n{\n\tstruct skcipher_request *req = NULL;\n\tDECLARE_CRYPTO_WAIT(wait);\n\tstruct scatterlist src_sg, dst_sg;\n\tconst struct fscrypt_info *ci = inode->i_crypt_info;\n\tstruct crypto_skcipher *tfm = ci->ci_enc_key.tfm;\n\tunion fscrypt_iv iv;\n\tint res;\n\n\t \n\treq = skcipher_request_alloc(tfm, GFP_NOFS);\n\tif (!req)\n\t\treturn -ENOMEM;\n\tskcipher_request_set_callback(req,\n\t\tCRYPTO_TFM_REQ_MAY_BACKLOG | CRYPTO_TFM_REQ_MAY_SLEEP,\n\t\tcrypto_req_done, &wait);\n\n\t \n\tfscrypt_generate_iv(&iv, 0, ci);\n\n\t \n\tsg_init_one(&src_sg, iname->name, iname->len);\n\tsg_init_one(&dst_sg, oname->name, oname->len);\n\tskcipher_request_set_crypt(req, &src_sg, &dst_sg, iname->len, &iv);\n\tres = crypto_wait_req(crypto_skcipher_decrypt(req), &wait);\n\tskcipher_request_free(req);\n\tif (res < 0) {\n\t\tfscrypt_err(inode, \"Filename decryption failed: %d\", res);\n\t\treturn res;\n\t}\n\n\toname->len = strnlen(oname->name, iname->len);\n\treturn 0;\n}\n\nstatic const char base64url_table[65] =\n\t\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\";\n\n#define FSCRYPT_BASE64URL_CHARS(nbytes)\tDIV_ROUND_UP((nbytes) * 4, 3)\n\n \nstatic int fscrypt_base64url_encode(const u8 *src, int srclen, char *dst)\n{\n\tu32 ac = 0;\n\tint bits = 0;\n\tint i;\n\tchar *cp = dst;\n\n\tfor (i = 0; i < srclen; i++) {\n\t\tac = (ac << 8) | src[i];\n\t\tbits += 8;\n\t\tdo {\n\t\t\tbits -= 6;\n\t\t\t*cp++ = base64url_table[(ac >> bits) & 0x3f];\n\t\t} while (bits >= 6);\n\t}\n\tif (bits)\n\t\t*cp++ = base64url_table[(ac << (6 - bits)) & 0x3f];\n\treturn cp - dst;\n}\n\n \nstatic int fscrypt_base64url_decode(const char *src, int srclen, u8 *dst)\n{\n\tu32 ac = 0;\n\tint bits = 0;\n\tint i;\n\tu8 *bp = dst;\n\n\tfor (i = 0; i < srclen; i++) {\n\t\tconst char *p = strchr(base64url_table, src[i]);\n\n\t\tif (p == NULL || src[i] == 0)\n\t\t\treturn -1;\n\t\tac = (ac << 6) | (p - base64url_table);\n\t\tbits += 6;\n\t\tif (bits >= 8) {\n\t\t\tbits -= 8;\n\t\t\t*bp++ = (u8)(ac >> bits);\n\t\t}\n\t}\n\tif (ac & ((1 << bits) - 1))\n\t\treturn -1;\n\treturn bp - dst;\n}\n\nbool __fscrypt_fname_encrypted_size(const union fscrypt_policy *policy,\n\t\t\t\t    u32 orig_len, u32 max_len,\n\t\t\t\t    u32 *encrypted_len_ret)\n{\n\tint padding = 4 << (fscrypt_policy_flags(policy) &\n\t\t\t    FSCRYPT_POLICY_FLAGS_PAD_MASK);\n\tu32 encrypted_len;\n\n\tif (orig_len > max_len)\n\t\treturn false;\n\tencrypted_len = max_t(u32, orig_len, FSCRYPT_FNAME_MIN_MSG_LEN);\n\tencrypted_len = round_up(encrypted_len, padding);\n\t*encrypted_len_ret = min(encrypted_len, max_len);\n\treturn true;\n}\n\n \nbool fscrypt_fname_encrypted_size(const struct inode *inode, u32 orig_len,\n\t\t\t\t  u32 max_len, u32 *encrypted_len_ret)\n{\n\treturn __fscrypt_fname_encrypted_size(&inode->i_crypt_info->ci_policy,\n\t\t\t\t\t      orig_len, max_len,\n\t\t\t\t\t      encrypted_len_ret);\n}\nEXPORT_SYMBOL_GPL(fscrypt_fname_encrypted_size);\n\n \nint fscrypt_fname_alloc_buffer(u32 max_encrypted_len,\n\t\t\t       struct fscrypt_str *crypto_str)\n{\n\tu32 max_presented_len = max_t(u32, FSCRYPT_NOKEY_NAME_MAX_ENCODED,\n\t\t\t\t      max_encrypted_len);\n\n\tcrypto_str->name = kmalloc(max_presented_len + 1, GFP_NOFS);\n\tif (!crypto_str->name)\n\t\treturn -ENOMEM;\n\tcrypto_str->len = max_presented_len;\n\treturn 0;\n}\nEXPORT_SYMBOL(fscrypt_fname_alloc_buffer);\n\n \nvoid fscrypt_fname_free_buffer(struct fscrypt_str *crypto_str)\n{\n\tif (!crypto_str)\n\t\treturn;\n\tkfree(crypto_str->name);\n\tcrypto_str->name = NULL;\n}\nEXPORT_SYMBOL(fscrypt_fname_free_buffer);\n\n \nint fscrypt_fname_disk_to_usr(const struct inode *inode,\n\t\t\t      u32 hash, u32 minor_hash,\n\t\t\t      const struct fscrypt_str *iname,\n\t\t\t      struct fscrypt_str *oname)\n{\n\tconst struct qstr qname = FSTR_TO_QSTR(iname);\n\tstruct fscrypt_nokey_name nokey_name;\n\tu32 size;  \n\n\tif (fscrypt_is_dot_dotdot(&qname)) {\n\t\toname->name[0] = '.';\n\t\toname->name[iname->len - 1] = '.';\n\t\toname->len = iname->len;\n\t\treturn 0;\n\t}\n\n\tif (iname->len < FSCRYPT_FNAME_MIN_MSG_LEN)\n\t\treturn -EUCLEAN;\n\n\tif (fscrypt_has_encryption_key(inode))\n\t\treturn fname_decrypt(inode, iname, oname);\n\n\t \n\tBUILD_BUG_ON(offsetofend(struct fscrypt_nokey_name, dirhash) !=\n\t\t     offsetof(struct fscrypt_nokey_name, bytes));\n\tBUILD_BUG_ON(offsetofend(struct fscrypt_nokey_name, bytes) !=\n\t\t     offsetof(struct fscrypt_nokey_name, sha256));\n\tBUILD_BUG_ON(FSCRYPT_NOKEY_NAME_MAX_ENCODED > NAME_MAX);\n\n\tnokey_name.dirhash[0] = hash;\n\tnokey_name.dirhash[1] = minor_hash;\n\n\tif (iname->len <= sizeof(nokey_name.bytes)) {\n\t\tmemcpy(nokey_name.bytes, iname->name, iname->len);\n\t\tsize = offsetof(struct fscrypt_nokey_name, bytes[iname->len]);\n\t} else {\n\t\tmemcpy(nokey_name.bytes, iname->name, sizeof(nokey_name.bytes));\n\t\t \n\t\tsha256(&iname->name[sizeof(nokey_name.bytes)],\n\t\t       iname->len - sizeof(nokey_name.bytes),\n\t\t       nokey_name.sha256);\n\t\tsize = FSCRYPT_NOKEY_NAME_MAX;\n\t}\n\toname->len = fscrypt_base64url_encode((const u8 *)&nokey_name, size,\n\t\t\t\t\t      oname->name);\n\treturn 0;\n}\nEXPORT_SYMBOL(fscrypt_fname_disk_to_usr);\n\n \nint fscrypt_setup_filename(struct inode *dir, const struct qstr *iname,\n\t\t\t      int lookup, struct fscrypt_name *fname)\n{\n\tstruct fscrypt_nokey_name *nokey_name;\n\tint ret;\n\n\tmemset(fname, 0, sizeof(struct fscrypt_name));\n\tfname->usr_fname = iname;\n\n\tif (!IS_ENCRYPTED(dir) || fscrypt_is_dot_dotdot(iname)) {\n\t\tfname->disk_name.name = (unsigned char *)iname->name;\n\t\tfname->disk_name.len = iname->len;\n\t\treturn 0;\n\t}\n\tret = fscrypt_get_encryption_info(dir, lookup);\n\tif (ret)\n\t\treturn ret;\n\n\tif (fscrypt_has_encryption_key(dir)) {\n\t\tif (!fscrypt_fname_encrypted_size(dir, iname->len, NAME_MAX,\n\t\t\t\t\t\t  &fname->crypto_buf.len))\n\t\t\treturn -ENAMETOOLONG;\n\t\tfname->crypto_buf.name = kmalloc(fname->crypto_buf.len,\n\t\t\t\t\t\t GFP_NOFS);\n\t\tif (!fname->crypto_buf.name)\n\t\t\treturn -ENOMEM;\n\n\t\tret = fscrypt_fname_encrypt(dir, iname, fname->crypto_buf.name,\n\t\t\t\t\t    fname->crypto_buf.len);\n\t\tif (ret)\n\t\t\tgoto errout;\n\t\tfname->disk_name.name = fname->crypto_buf.name;\n\t\tfname->disk_name.len = fname->crypto_buf.len;\n\t\treturn 0;\n\t}\n\tif (!lookup)\n\t\treturn -ENOKEY;\n\tfname->is_nokey_name = true;\n\n\t \n\n\tif (iname->len > FSCRYPT_NOKEY_NAME_MAX_ENCODED)\n\t\treturn -ENOENT;\n\n\tfname->crypto_buf.name = kmalloc(FSCRYPT_NOKEY_NAME_MAX, GFP_KERNEL);\n\tif (fname->crypto_buf.name == NULL)\n\t\treturn -ENOMEM;\n\n\tret = fscrypt_base64url_decode(iname->name, iname->len,\n\t\t\t\t       fname->crypto_buf.name);\n\tif (ret < (int)offsetof(struct fscrypt_nokey_name, bytes[1]) ||\n\t    (ret > offsetof(struct fscrypt_nokey_name, sha256) &&\n\t     ret != FSCRYPT_NOKEY_NAME_MAX)) {\n\t\tret = -ENOENT;\n\t\tgoto errout;\n\t}\n\tfname->crypto_buf.len = ret;\n\n\tnokey_name = (void *)fname->crypto_buf.name;\n\tfname->hash = nokey_name->dirhash[0];\n\tfname->minor_hash = nokey_name->dirhash[1];\n\tif (ret != FSCRYPT_NOKEY_NAME_MAX) {\n\t\t \n\t\tfname->disk_name.name = nokey_name->bytes;\n\t\tfname->disk_name.len =\n\t\t\tret - offsetof(struct fscrypt_nokey_name, bytes);\n\t}\n\treturn 0;\n\nerrout:\n\tkfree(fname->crypto_buf.name);\n\treturn ret;\n}\nEXPORT_SYMBOL(fscrypt_setup_filename);\n\n \nbool fscrypt_match_name(const struct fscrypt_name *fname,\n\t\t\tconst u8 *de_name, u32 de_name_len)\n{\n\tconst struct fscrypt_nokey_name *nokey_name =\n\t\t(const void *)fname->crypto_buf.name;\n\tu8 digest[SHA256_DIGEST_SIZE];\n\n\tif (likely(fname->disk_name.name)) {\n\t\tif (de_name_len != fname->disk_name.len)\n\t\t\treturn false;\n\t\treturn !memcmp(de_name, fname->disk_name.name, de_name_len);\n\t}\n\tif (de_name_len <= sizeof(nokey_name->bytes))\n\t\treturn false;\n\tif (memcmp(de_name, nokey_name->bytes, sizeof(nokey_name->bytes)))\n\t\treturn false;\n\tsha256(&de_name[sizeof(nokey_name->bytes)],\n\t       de_name_len - sizeof(nokey_name->bytes), digest);\n\treturn !memcmp(digest, nokey_name->sha256, sizeof(digest));\n}\nEXPORT_SYMBOL_GPL(fscrypt_match_name);\n\n \nu64 fscrypt_fname_siphash(const struct inode *dir, const struct qstr *name)\n{\n\tconst struct fscrypt_info *ci = dir->i_crypt_info;\n\n\tWARN_ON_ONCE(!ci->ci_dirhash_key_initialized);\n\n\treturn siphash(name->name, name->len, &ci->ci_dirhash_key);\n}\nEXPORT_SYMBOL_GPL(fscrypt_fname_siphash);\n\n \nint fscrypt_d_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tstruct dentry *dir;\n\tint err;\n\tint valid;\n\n\t \n\tif (!(dentry->d_flags & DCACHE_NOKEY_NAME))\n\t\treturn 1;\n\n\t \n\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\tdir = dget_parent(dentry);\n\t \n\terr = fscrypt_get_encryption_info(d_inode(dir), true);\n\tvalid = !fscrypt_has_encryption_key(d_inode(dir));\n\tdput(dir);\n\n\tif (err < 0)\n\t\treturn err;\n\n\treturn valid;\n}\nEXPORT_SYMBOL_GPL(fscrypt_d_revalidate);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}