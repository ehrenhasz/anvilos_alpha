{
  "module_name": "keysetup.c",
  "hash_id": "4bc9ac7b07d8db799e2c6e090194ce0e81144d470cb99b21ddd591ddf25756bf",
  "original_prompt": "Ingested from linux-6.6.14/fs/crypto/keysetup.c",
  "human_readable_source": "\n \n\n#include <crypto/skcipher.h>\n#include <linux/random.h>\n\n#include \"fscrypt_private.h\"\n\nstruct fscrypt_mode fscrypt_modes[] = {\n\t[FSCRYPT_MODE_AES_256_XTS] = {\n\t\t.friendly_name = \"AES-256-XTS\",\n\t\t.cipher_str = \"xts(aes)\",\n\t\t.keysize = 64,\n\t\t.security_strength = 32,\n\t\t.ivsize = 16,\n\t\t.blk_crypto_mode = BLK_ENCRYPTION_MODE_AES_256_XTS,\n\t},\n\t[FSCRYPT_MODE_AES_256_CTS] = {\n\t\t.friendly_name = \"AES-256-CTS-CBC\",\n\t\t.cipher_str = \"cts(cbc(aes))\",\n\t\t.keysize = 32,\n\t\t.security_strength = 32,\n\t\t.ivsize = 16,\n\t},\n\t[FSCRYPT_MODE_AES_128_CBC] = {\n\t\t.friendly_name = \"AES-128-CBC-ESSIV\",\n\t\t.cipher_str = \"essiv(cbc(aes),sha256)\",\n\t\t.keysize = 16,\n\t\t.security_strength = 16,\n\t\t.ivsize = 16,\n\t\t.blk_crypto_mode = BLK_ENCRYPTION_MODE_AES_128_CBC_ESSIV,\n\t},\n\t[FSCRYPT_MODE_AES_128_CTS] = {\n\t\t.friendly_name = \"AES-128-CTS-CBC\",\n\t\t.cipher_str = \"cts(cbc(aes))\",\n\t\t.keysize = 16,\n\t\t.security_strength = 16,\n\t\t.ivsize = 16,\n\t},\n\t[FSCRYPT_MODE_SM4_XTS] = {\n\t\t.friendly_name = \"SM4-XTS\",\n\t\t.cipher_str = \"xts(sm4)\",\n\t\t.keysize = 32,\n\t\t.security_strength = 16,\n\t\t.ivsize = 16,\n\t\t.blk_crypto_mode = BLK_ENCRYPTION_MODE_SM4_XTS,\n\t},\n\t[FSCRYPT_MODE_SM4_CTS] = {\n\t\t.friendly_name = \"SM4-CTS-CBC\",\n\t\t.cipher_str = \"cts(cbc(sm4))\",\n\t\t.keysize = 16,\n\t\t.security_strength = 16,\n\t\t.ivsize = 16,\n\t},\n\t[FSCRYPT_MODE_ADIANTUM] = {\n\t\t.friendly_name = \"Adiantum\",\n\t\t.cipher_str = \"adiantum(xchacha12,aes)\",\n\t\t.keysize = 32,\n\t\t.security_strength = 32,\n\t\t.ivsize = 32,\n\t\t.blk_crypto_mode = BLK_ENCRYPTION_MODE_ADIANTUM,\n\t},\n\t[FSCRYPT_MODE_AES_256_HCTR2] = {\n\t\t.friendly_name = \"AES-256-HCTR2\",\n\t\t.cipher_str = \"hctr2(aes)\",\n\t\t.keysize = 32,\n\t\t.security_strength = 32,\n\t\t.ivsize = 32,\n\t},\n};\n\nstatic DEFINE_MUTEX(fscrypt_mode_key_setup_mutex);\n\nstatic struct fscrypt_mode *\nselect_encryption_mode(const union fscrypt_policy *policy,\n\t\t       const struct inode *inode)\n{\n\tBUILD_BUG_ON(ARRAY_SIZE(fscrypt_modes) != FSCRYPT_MODE_MAX + 1);\n\n\tif (S_ISREG(inode->i_mode))\n\t\treturn &fscrypt_modes[fscrypt_policy_contents_mode(policy)];\n\n\tif (S_ISDIR(inode->i_mode) || S_ISLNK(inode->i_mode))\n\t\treturn &fscrypt_modes[fscrypt_policy_fnames_mode(policy)];\n\n\tWARN_ONCE(1, \"fscrypt: filesystem tried to load encryption info for inode %lu, which is not encryptable (file type %d)\\n\",\n\t\t  inode->i_ino, (inode->i_mode & S_IFMT));\n\treturn ERR_PTR(-EINVAL);\n}\n\n \nstatic struct crypto_skcipher *\nfscrypt_allocate_skcipher(struct fscrypt_mode *mode, const u8 *raw_key,\n\t\t\t  const struct inode *inode)\n{\n\tstruct crypto_skcipher *tfm;\n\tint err;\n\n\ttfm = crypto_alloc_skcipher(mode->cipher_str, 0, 0);\n\tif (IS_ERR(tfm)) {\n\t\tif (PTR_ERR(tfm) == -ENOENT) {\n\t\t\tfscrypt_warn(inode,\n\t\t\t\t     \"Missing crypto API support for %s (API name: \\\"%s\\\")\",\n\t\t\t\t     mode->friendly_name, mode->cipher_str);\n\t\t\treturn ERR_PTR(-ENOPKG);\n\t\t}\n\t\tfscrypt_err(inode, \"Error allocating '%s' transform: %ld\",\n\t\t\t    mode->cipher_str, PTR_ERR(tfm));\n\t\treturn tfm;\n\t}\n\tif (!xchg(&mode->logged_cryptoapi_impl, 1)) {\n\t\t \n\t\tpr_info(\"fscrypt: %s using implementation \\\"%s\\\"\\n\",\n\t\t\tmode->friendly_name, crypto_skcipher_driver_name(tfm));\n\t}\n\tif (WARN_ON_ONCE(crypto_skcipher_ivsize(tfm) != mode->ivsize)) {\n\t\terr = -EINVAL;\n\t\tgoto err_free_tfm;\n\t}\n\tcrypto_skcipher_set_flags(tfm, CRYPTO_TFM_REQ_FORBID_WEAK_KEYS);\n\terr = crypto_skcipher_setkey(tfm, raw_key, mode->keysize);\n\tif (err)\n\t\tgoto err_free_tfm;\n\n\treturn tfm;\n\nerr_free_tfm:\n\tcrypto_free_skcipher(tfm);\n\treturn ERR_PTR(err);\n}\n\n \nint fscrypt_prepare_key(struct fscrypt_prepared_key *prep_key,\n\t\t\tconst u8 *raw_key, const struct fscrypt_info *ci)\n{\n\tstruct crypto_skcipher *tfm;\n\n\tif (fscrypt_using_inline_encryption(ci))\n\t\treturn fscrypt_prepare_inline_crypt_key(prep_key, raw_key, ci);\n\n\ttfm = fscrypt_allocate_skcipher(ci->ci_mode, raw_key, ci->ci_inode);\n\tif (IS_ERR(tfm))\n\t\treturn PTR_ERR(tfm);\n\t \n\tsmp_store_release(&prep_key->tfm, tfm);\n\treturn 0;\n}\n\n \nvoid fscrypt_destroy_prepared_key(struct super_block *sb,\n\t\t\t\t  struct fscrypt_prepared_key *prep_key)\n{\n\tcrypto_free_skcipher(prep_key->tfm);\n\tfscrypt_destroy_inline_crypt_key(sb, prep_key);\n\tmemzero_explicit(prep_key, sizeof(*prep_key));\n}\n\n \nint fscrypt_set_per_file_enc_key(struct fscrypt_info *ci, const u8 *raw_key)\n{\n\tci->ci_owns_key = true;\n\treturn fscrypt_prepare_key(&ci->ci_enc_key, raw_key, ci);\n}\n\nstatic int setup_per_mode_enc_key(struct fscrypt_info *ci,\n\t\t\t\t  struct fscrypt_master_key *mk,\n\t\t\t\t  struct fscrypt_prepared_key *keys,\n\t\t\t\t  u8 hkdf_context, bool include_fs_uuid)\n{\n\tconst struct inode *inode = ci->ci_inode;\n\tconst struct super_block *sb = inode->i_sb;\n\tstruct fscrypt_mode *mode = ci->ci_mode;\n\tconst u8 mode_num = mode - fscrypt_modes;\n\tstruct fscrypt_prepared_key *prep_key;\n\tu8 mode_key[FSCRYPT_MAX_KEY_SIZE];\n\tu8 hkdf_info[sizeof(mode_num) + sizeof(sb->s_uuid)];\n\tunsigned int hkdf_infolen = 0;\n\tint err;\n\n\tif (WARN_ON_ONCE(mode_num > FSCRYPT_MODE_MAX))\n\t\treturn -EINVAL;\n\n\tprep_key = &keys[mode_num];\n\tif (fscrypt_is_key_prepared(prep_key, ci)) {\n\t\tci->ci_enc_key = *prep_key;\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&fscrypt_mode_key_setup_mutex);\n\n\tif (fscrypt_is_key_prepared(prep_key, ci))\n\t\tgoto done_unlock;\n\n\tBUILD_BUG_ON(sizeof(mode_num) != 1);\n\tBUILD_BUG_ON(sizeof(sb->s_uuid) != 16);\n\tBUILD_BUG_ON(sizeof(hkdf_info) != 17);\n\thkdf_info[hkdf_infolen++] = mode_num;\n\tif (include_fs_uuid) {\n\t\tmemcpy(&hkdf_info[hkdf_infolen], &sb->s_uuid,\n\t\t       sizeof(sb->s_uuid));\n\t\thkdf_infolen += sizeof(sb->s_uuid);\n\t}\n\terr = fscrypt_hkdf_expand(&mk->mk_secret.hkdf,\n\t\t\t\t  hkdf_context, hkdf_info, hkdf_infolen,\n\t\t\t\t  mode_key, mode->keysize);\n\tif (err)\n\t\tgoto out_unlock;\n\terr = fscrypt_prepare_key(prep_key, mode_key, ci);\n\tmemzero_explicit(mode_key, mode->keysize);\n\tif (err)\n\t\tgoto out_unlock;\ndone_unlock:\n\tci->ci_enc_key = *prep_key;\n\terr = 0;\nout_unlock:\n\tmutex_unlock(&fscrypt_mode_key_setup_mutex);\n\treturn err;\n}\n\n \nstatic int fscrypt_derive_siphash_key(const struct fscrypt_master_key *mk,\n\t\t\t\t      u8 context, const u8 *info,\n\t\t\t\t      unsigned int infolen, siphash_key_t *key)\n{\n\tint err;\n\n\terr = fscrypt_hkdf_expand(&mk->mk_secret.hkdf, context, info, infolen,\n\t\t\t\t  (u8 *)key, sizeof(*key));\n\tif (err)\n\t\treturn err;\n\n\tBUILD_BUG_ON(sizeof(*key) != 16);\n\tBUILD_BUG_ON(ARRAY_SIZE(key->key) != 2);\n\tle64_to_cpus(&key->key[0]);\n\tle64_to_cpus(&key->key[1]);\n\treturn 0;\n}\n\nint fscrypt_derive_dirhash_key(struct fscrypt_info *ci,\n\t\t\t       const struct fscrypt_master_key *mk)\n{\n\tint err;\n\n\terr = fscrypt_derive_siphash_key(mk, HKDF_CONTEXT_DIRHASH_KEY,\n\t\t\t\t\t ci->ci_nonce, FSCRYPT_FILE_NONCE_SIZE,\n\t\t\t\t\t &ci->ci_dirhash_key);\n\tif (err)\n\t\treturn err;\n\tci->ci_dirhash_key_initialized = true;\n\treturn 0;\n}\n\nvoid fscrypt_hash_inode_number(struct fscrypt_info *ci,\n\t\t\t       const struct fscrypt_master_key *mk)\n{\n\tWARN_ON_ONCE(ci->ci_inode->i_ino == 0);\n\tWARN_ON_ONCE(!mk->mk_ino_hash_key_initialized);\n\n\tci->ci_hashed_ino = (u32)siphash_1u64(ci->ci_inode->i_ino,\n\t\t\t\t\t      &mk->mk_ino_hash_key);\n}\n\nstatic int fscrypt_setup_iv_ino_lblk_32_key(struct fscrypt_info *ci,\n\t\t\t\t\t    struct fscrypt_master_key *mk)\n{\n\tint err;\n\n\terr = setup_per_mode_enc_key(ci, mk, mk->mk_iv_ino_lblk_32_keys,\n\t\t\t\t     HKDF_CONTEXT_IV_INO_LBLK_32_KEY, true);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (!smp_load_acquire(&mk->mk_ino_hash_key_initialized)) {\n\n\t\tmutex_lock(&fscrypt_mode_key_setup_mutex);\n\n\t\tif (mk->mk_ino_hash_key_initialized)\n\t\t\tgoto unlock;\n\n\t\terr = fscrypt_derive_siphash_key(mk,\n\t\t\t\t\t\t HKDF_CONTEXT_INODE_HASH_KEY,\n\t\t\t\t\t\t NULL, 0, &mk->mk_ino_hash_key);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t\t \n\t\tsmp_store_release(&mk->mk_ino_hash_key_initialized, true);\nunlock:\n\t\tmutex_unlock(&fscrypt_mode_key_setup_mutex);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tif (ci->ci_inode->i_ino)\n\t\tfscrypt_hash_inode_number(ci, mk);\n\treturn 0;\n}\n\nstatic int fscrypt_setup_v2_file_key(struct fscrypt_info *ci,\n\t\t\t\t     struct fscrypt_master_key *mk,\n\t\t\t\t     bool need_dirhash_key)\n{\n\tint err;\n\n\tif (ci->ci_policy.v2.flags & FSCRYPT_POLICY_FLAG_DIRECT_KEY) {\n\t\t \n\t\terr = setup_per_mode_enc_key(ci, mk, mk->mk_direct_keys,\n\t\t\t\t\t     HKDF_CONTEXT_DIRECT_KEY, false);\n\t} else if (ci->ci_policy.v2.flags &\n\t\t   FSCRYPT_POLICY_FLAG_IV_INO_LBLK_64) {\n\t\t \n\t\terr = setup_per_mode_enc_key(ci, mk, mk->mk_iv_ino_lblk_64_keys,\n\t\t\t\t\t     HKDF_CONTEXT_IV_INO_LBLK_64_KEY,\n\t\t\t\t\t     true);\n\t} else if (ci->ci_policy.v2.flags &\n\t\t   FSCRYPT_POLICY_FLAG_IV_INO_LBLK_32) {\n\t\terr = fscrypt_setup_iv_ino_lblk_32_key(ci, mk);\n\t} else {\n\t\tu8 derived_key[FSCRYPT_MAX_KEY_SIZE];\n\n\t\terr = fscrypt_hkdf_expand(&mk->mk_secret.hkdf,\n\t\t\t\t\t  HKDF_CONTEXT_PER_FILE_ENC_KEY,\n\t\t\t\t\t  ci->ci_nonce, FSCRYPT_FILE_NONCE_SIZE,\n\t\t\t\t\t  derived_key, ci->ci_mode->keysize);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = fscrypt_set_per_file_enc_key(ci, derived_key);\n\t\tmemzero_explicit(derived_key, ci->ci_mode->keysize);\n\t}\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (need_dirhash_key) {\n\t\terr = fscrypt_derive_dirhash_key(ci, mk);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstatic bool fscrypt_valid_master_key_size(const struct fscrypt_master_key *mk,\n\t\t\t\t\t  const struct fscrypt_info *ci)\n{\n\tunsigned int min_keysize;\n\n\tif (ci->ci_policy.version == FSCRYPT_POLICY_V1)\n\t\tmin_keysize = ci->ci_mode->keysize;\n\telse\n\t\tmin_keysize = ci->ci_mode->security_strength;\n\n\tif (mk->mk_secret.size < min_keysize) {\n\t\tfscrypt_warn(NULL,\n\t\t\t     \"key with %s %*phN is too short (got %u bytes, need %u+ bytes)\",\n\t\t\t     master_key_spec_type(&mk->mk_spec),\n\t\t\t     master_key_spec_len(&mk->mk_spec),\n\t\t\t     (u8 *)&mk->mk_spec.u,\n\t\t\t     mk->mk_secret.size, min_keysize);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n \nstatic int setup_file_encryption_key(struct fscrypt_info *ci,\n\t\t\t\t     bool need_dirhash_key,\n\t\t\t\t     struct fscrypt_master_key **mk_ret)\n{\n\tstruct super_block *sb = ci->ci_inode->i_sb;\n\tstruct fscrypt_key_specifier mk_spec;\n\tstruct fscrypt_master_key *mk;\n\tint err;\n\n\terr = fscrypt_select_encryption_impl(ci);\n\tif (err)\n\t\treturn err;\n\n\terr = fscrypt_policy_to_key_spec(&ci->ci_policy, &mk_spec);\n\tif (err)\n\t\treturn err;\n\n\tmk = fscrypt_find_master_key(sb, &mk_spec);\n\tif (unlikely(!mk)) {\n\t\tconst union fscrypt_policy *dummy_policy =\n\t\t\tfscrypt_get_dummy_policy(sb);\n\n\t\t \n\t\tif (dummy_policy &&\n\t\t    fscrypt_policies_equal(dummy_policy, &ci->ci_policy)) {\n\t\t\terr = fscrypt_add_test_dummy_key(sb, &mk_spec);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tmk = fscrypt_find_master_key(sb, &mk_spec);\n\t\t}\n\t}\n\tif (unlikely(!mk)) {\n\t\tif (ci->ci_policy.version != FSCRYPT_POLICY_V1)\n\t\t\treturn -ENOKEY;\n\n\t\t \n\t\treturn fscrypt_setup_v1_file_key_via_subscribed_keyrings(ci);\n\t}\n\tdown_read(&mk->mk_sem);\n\n\t \n\tif (!is_master_key_secret_present(&mk->mk_secret)) {\n\t\terr = -ENOKEY;\n\t\tgoto out_release_key;\n\t}\n\n\tif (!fscrypt_valid_master_key_size(mk, ci)) {\n\t\terr = -ENOKEY;\n\t\tgoto out_release_key;\n\t}\n\n\tswitch (ci->ci_policy.version) {\n\tcase FSCRYPT_POLICY_V1:\n\t\terr = fscrypt_setup_v1_file_key(ci, mk->mk_secret.raw);\n\t\tbreak;\n\tcase FSCRYPT_POLICY_V2:\n\t\terr = fscrypt_setup_v2_file_key(ci, mk, need_dirhash_key);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\tif (err)\n\t\tgoto out_release_key;\n\n\t*mk_ret = mk;\n\treturn 0;\n\nout_release_key:\n\tup_read(&mk->mk_sem);\n\tfscrypt_put_master_key(mk);\n\treturn err;\n}\n\nstatic void put_crypt_info(struct fscrypt_info *ci)\n{\n\tstruct fscrypt_master_key *mk;\n\n\tif (!ci)\n\t\treturn;\n\n\tif (ci->ci_direct_key)\n\t\tfscrypt_put_direct_key(ci->ci_direct_key);\n\telse if (ci->ci_owns_key)\n\t\tfscrypt_destroy_prepared_key(ci->ci_inode->i_sb,\n\t\t\t\t\t     &ci->ci_enc_key);\n\n\tmk = ci->ci_master_key;\n\tif (mk) {\n\t\t \n\t\tspin_lock(&mk->mk_decrypted_inodes_lock);\n\t\tlist_del(&ci->ci_master_key_link);\n\t\tspin_unlock(&mk->mk_decrypted_inodes_lock);\n\t\tfscrypt_put_master_key_activeref(ci->ci_inode->i_sb, mk);\n\t}\n\tmemzero_explicit(ci, sizeof(*ci));\n\tkmem_cache_free(fscrypt_info_cachep, ci);\n}\n\nstatic int\nfscrypt_setup_encryption_info(struct inode *inode,\n\t\t\t      const union fscrypt_policy *policy,\n\t\t\t      const u8 nonce[FSCRYPT_FILE_NONCE_SIZE],\n\t\t\t      bool need_dirhash_key)\n{\n\tstruct fscrypt_info *crypt_info;\n\tstruct fscrypt_mode *mode;\n\tstruct fscrypt_master_key *mk = NULL;\n\tint res;\n\n\tres = fscrypt_initialize(inode->i_sb);\n\tif (res)\n\t\treturn res;\n\n\tcrypt_info = kmem_cache_zalloc(fscrypt_info_cachep, GFP_KERNEL);\n\tif (!crypt_info)\n\t\treturn -ENOMEM;\n\n\tcrypt_info->ci_inode = inode;\n\tcrypt_info->ci_policy = *policy;\n\tmemcpy(crypt_info->ci_nonce, nonce, FSCRYPT_FILE_NONCE_SIZE);\n\n\tmode = select_encryption_mode(&crypt_info->ci_policy, inode);\n\tif (IS_ERR(mode)) {\n\t\tres = PTR_ERR(mode);\n\t\tgoto out;\n\t}\n\tWARN_ON_ONCE(mode->ivsize > FSCRYPT_MAX_IV_SIZE);\n\tcrypt_info->ci_mode = mode;\n\n\tres = setup_file_encryption_key(crypt_info, need_dirhash_key, &mk);\n\tif (res)\n\t\tgoto out;\n\n\t \n\tif (cmpxchg_release(&inode->i_crypt_info, NULL, crypt_info) == NULL) {\n\t\t \n\t\tif (mk) {\n\t\t\tcrypt_info->ci_master_key = mk;\n\t\t\trefcount_inc(&mk->mk_active_refs);\n\t\t\tspin_lock(&mk->mk_decrypted_inodes_lock);\n\t\t\tlist_add(&crypt_info->ci_master_key_link,\n\t\t\t\t &mk->mk_decrypted_inodes);\n\t\t\tspin_unlock(&mk->mk_decrypted_inodes_lock);\n\t\t}\n\t\tcrypt_info = NULL;\n\t}\n\tres = 0;\nout:\n\tif (mk) {\n\t\tup_read(&mk->mk_sem);\n\t\tfscrypt_put_master_key(mk);\n\t}\n\tput_crypt_info(crypt_info);\n\treturn res;\n}\n\n \nint fscrypt_get_encryption_info(struct inode *inode, bool allow_unsupported)\n{\n\tint res;\n\tunion fscrypt_context ctx;\n\tunion fscrypt_policy policy;\n\n\tif (fscrypt_has_encryption_key(inode))\n\t\treturn 0;\n\n\tres = inode->i_sb->s_cop->get_context(inode, &ctx, sizeof(ctx));\n\tif (res < 0) {\n\t\tif (res == -ERANGE && allow_unsupported)\n\t\t\treturn 0;\n\t\tfscrypt_warn(inode, \"Error %d getting encryption context\", res);\n\t\treturn res;\n\t}\n\n\tres = fscrypt_policy_from_context(&policy, &ctx, res);\n\tif (res) {\n\t\tif (allow_unsupported)\n\t\t\treturn 0;\n\t\tfscrypt_warn(inode,\n\t\t\t     \"Unrecognized or corrupt encryption context\");\n\t\treturn res;\n\t}\n\n\tif (!fscrypt_supported_policy(&policy, inode)) {\n\t\tif (allow_unsupported)\n\t\t\treturn 0;\n\t\treturn -EINVAL;\n\t}\n\n\tres = fscrypt_setup_encryption_info(inode, &policy,\n\t\t\t\t\t    fscrypt_context_nonce(&ctx),\n\t\t\t\t\t    IS_CASEFOLDED(inode) &&\n\t\t\t\t\t    S_ISDIR(inode->i_mode));\n\n\tif (res == -ENOPKG && allow_unsupported)  \n\t\tres = 0;\n\tif (res == -ENOKEY)\n\t\tres = 0;\n\treturn res;\n}\n\n \nint fscrypt_prepare_new_inode(struct inode *dir, struct inode *inode,\n\t\t\t      bool *encrypt_ret)\n{\n\tconst union fscrypt_policy *policy;\n\tu8 nonce[FSCRYPT_FILE_NONCE_SIZE];\n\n\tpolicy = fscrypt_policy_to_inherit(dir);\n\tif (policy == NULL)\n\t\treturn 0;\n\tif (IS_ERR(policy))\n\t\treturn PTR_ERR(policy);\n\n\tif (WARN_ON_ONCE(inode->i_mode == 0))\n\t\treturn -EINVAL;\n\n\t \n\tif (!S_ISREG(inode->i_mode) &&\n\t    !S_ISDIR(inode->i_mode) &&\n\t    !S_ISLNK(inode->i_mode))\n\t\treturn 0;\n\n\t*encrypt_ret = true;\n\n\tget_random_bytes(nonce, FSCRYPT_FILE_NONCE_SIZE);\n\treturn fscrypt_setup_encryption_info(inode, policy, nonce,\n\t\t\t\t\t     IS_CASEFOLDED(dir) &&\n\t\t\t\t\t     S_ISDIR(inode->i_mode));\n}\nEXPORT_SYMBOL_GPL(fscrypt_prepare_new_inode);\n\n \nvoid fscrypt_put_encryption_info(struct inode *inode)\n{\n\tput_crypt_info(inode->i_crypt_info);\n\tinode->i_crypt_info = NULL;\n}\nEXPORT_SYMBOL(fscrypt_put_encryption_info);\n\n \nvoid fscrypt_free_inode(struct inode *inode)\n{\n\tif (IS_ENCRYPTED(inode) && S_ISLNK(inode->i_mode)) {\n\t\tkfree(inode->i_link);\n\t\tinode->i_link = NULL;\n\t}\n}\nEXPORT_SYMBOL(fscrypt_free_inode);\n\n \nint fscrypt_drop_inode(struct inode *inode)\n{\n\tconst struct fscrypt_info *ci = fscrypt_get_info(inode);\n\n\t \n\tif (!ci || !ci->ci_master_key)\n\t\treturn 0;\n\n\t \n\tif (inode->i_state & I_DIRTY_ALL)\n\t\treturn 0;\n\n\t \n\treturn !is_master_key_secret_present(&ci->ci_master_key->mk_secret);\n}\nEXPORT_SYMBOL_GPL(fscrypt_drop_inode);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}