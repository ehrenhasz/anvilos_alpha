{
  "module_name": "policy.c",
  "hash_id": "a0afc95fa70510bce3b315c29019fddc5aa95436ea450971d712deac70a8311b",
  "original_prompt": "Ingested from linux-6.6.14/fs/crypto/policy.c",
  "human_readable_source": "\n \n\n#include <linux/fs_context.h>\n#include <linux/random.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/mount.h>\n#include \"fscrypt_private.h\"\n\n \nbool fscrypt_policies_equal(const union fscrypt_policy *policy1,\n\t\t\t    const union fscrypt_policy *policy2)\n{\n\tif (policy1->version != policy2->version)\n\t\treturn false;\n\n\treturn !memcmp(policy1, policy2, fscrypt_policy_size(policy1));\n}\n\nint fscrypt_policy_to_key_spec(const union fscrypt_policy *policy,\n\t\t\t       struct fscrypt_key_specifier *key_spec)\n{\n\tswitch (policy->version) {\n\tcase FSCRYPT_POLICY_V1:\n\t\tkey_spec->type = FSCRYPT_KEY_SPEC_TYPE_DESCRIPTOR;\n\t\tmemcpy(key_spec->u.descriptor, policy->v1.master_key_descriptor,\n\t\t       FSCRYPT_KEY_DESCRIPTOR_SIZE);\n\t\treturn 0;\n\tcase FSCRYPT_POLICY_V2:\n\t\tkey_spec->type = FSCRYPT_KEY_SPEC_TYPE_IDENTIFIER;\n\t\tmemcpy(key_spec->u.identifier, policy->v2.master_key_identifier,\n\t\t       FSCRYPT_KEY_IDENTIFIER_SIZE);\n\t\treturn 0;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn -EINVAL;\n\t}\n}\n\nconst union fscrypt_policy *fscrypt_get_dummy_policy(struct super_block *sb)\n{\n\tif (!sb->s_cop->get_dummy_policy)\n\t\treturn NULL;\n\treturn sb->s_cop->get_dummy_policy(sb);\n}\n\n \nstatic bool fscrypt_valid_enc_modes_v1(u32 contents_mode, u32 filenames_mode)\n{\n\tif (contents_mode == FSCRYPT_MODE_AES_256_XTS &&\n\t    filenames_mode == FSCRYPT_MODE_AES_256_CTS)\n\t\treturn true;\n\n\tif (contents_mode == FSCRYPT_MODE_AES_128_CBC &&\n\t    filenames_mode == FSCRYPT_MODE_AES_128_CTS)\n\t\treturn true;\n\n\tif (contents_mode == FSCRYPT_MODE_ADIANTUM &&\n\t    filenames_mode == FSCRYPT_MODE_ADIANTUM)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool fscrypt_valid_enc_modes_v2(u32 contents_mode, u32 filenames_mode)\n{\n\tif (contents_mode == FSCRYPT_MODE_AES_256_XTS &&\n\t    filenames_mode == FSCRYPT_MODE_AES_256_HCTR2)\n\t\treturn true;\n\n\tif (contents_mode == FSCRYPT_MODE_SM4_XTS &&\n\t    filenames_mode == FSCRYPT_MODE_SM4_CTS)\n\t\treturn true;\n\n\treturn fscrypt_valid_enc_modes_v1(contents_mode, filenames_mode);\n}\n\nstatic bool supported_direct_key_modes(const struct inode *inode,\n\t\t\t\t       u32 contents_mode, u32 filenames_mode)\n{\n\tconst struct fscrypt_mode *mode;\n\n\tif (contents_mode != filenames_mode) {\n\t\tfscrypt_warn(inode,\n\t\t\t     \"Direct key flag not allowed with different contents and filenames modes\");\n\t\treturn false;\n\t}\n\tmode = &fscrypt_modes[contents_mode];\n\n\tif (mode->ivsize < offsetofend(union fscrypt_iv, nonce)) {\n\t\tfscrypt_warn(inode, \"Direct key flag not allowed with %s\",\n\t\t\t     mode->friendly_name);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic bool supported_iv_ino_lblk_policy(const struct fscrypt_policy_v2 *policy,\n\t\t\t\t\t const struct inode *inode,\n\t\t\t\t\t const char *type,\n\t\t\t\t\t int max_ino_bits, int max_lblk_bits)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint ino_bits = 64, lblk_bits = 64;\n\n\t \n\tif (policy->contents_encryption_mode != FSCRYPT_MODE_AES_256_XTS) {\n\t\tfscrypt_warn(inode,\n\t\t\t     \"Can't use %s policy with contents mode other than AES-256-XTS\",\n\t\t\t     type);\n\t\treturn false;\n\t}\n\n\t \n\tif (!sb->s_cop->has_stable_inodes ||\n\t    !sb->s_cop->has_stable_inodes(sb)) {\n\t\tfscrypt_warn(inode,\n\t\t\t     \"Can't use %s policy on filesystem '%s' because it doesn't have stable inode numbers\",\n\t\t\t     type, sb->s_id);\n\t\treturn false;\n\t}\n\tif (sb->s_cop->get_ino_and_lblk_bits)\n\t\tsb->s_cop->get_ino_and_lblk_bits(sb, &ino_bits, &lblk_bits);\n\tif (ino_bits > max_ino_bits) {\n\t\tfscrypt_warn(inode,\n\t\t\t     \"Can't use %s policy on filesystem '%s' because its inode numbers are too long\",\n\t\t\t     type, sb->s_id);\n\t\treturn false;\n\t}\n\tif (lblk_bits > max_lblk_bits) {\n\t\tfscrypt_warn(inode,\n\t\t\t     \"Can't use %s policy on filesystem '%s' because its block numbers are too long\",\n\t\t\t     type, sb->s_id);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic bool fscrypt_supported_v1_policy(const struct fscrypt_policy_v1 *policy,\n\t\t\t\t\tconst struct inode *inode)\n{\n\tif (!fscrypt_valid_enc_modes_v1(policy->contents_encryption_mode,\n\t\t\t\t     policy->filenames_encryption_mode)) {\n\t\tfscrypt_warn(inode,\n\t\t\t     \"Unsupported encryption modes (contents %d, filenames %d)\",\n\t\t\t     policy->contents_encryption_mode,\n\t\t\t     policy->filenames_encryption_mode);\n\t\treturn false;\n\t}\n\n\tif (policy->flags & ~(FSCRYPT_POLICY_FLAGS_PAD_MASK |\n\t\t\t      FSCRYPT_POLICY_FLAG_DIRECT_KEY)) {\n\t\tfscrypt_warn(inode, \"Unsupported encryption flags (0x%02x)\",\n\t\t\t     policy->flags);\n\t\treturn false;\n\t}\n\n\tif ((policy->flags & FSCRYPT_POLICY_FLAG_DIRECT_KEY) &&\n\t    !supported_direct_key_modes(inode, policy->contents_encryption_mode,\n\t\t\t\t\tpolicy->filenames_encryption_mode))\n\t\treturn false;\n\n\tif (IS_CASEFOLDED(inode)) {\n\t\t \n\t\tfscrypt_warn(inode,\n\t\t\t     \"v1 policies can't be used on casefolded directories\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool fscrypt_supported_v2_policy(const struct fscrypt_policy_v2 *policy,\n\t\t\t\t\tconst struct inode *inode)\n{\n\tint count = 0;\n\n\tif (!fscrypt_valid_enc_modes_v2(policy->contents_encryption_mode,\n\t\t\t\t     policy->filenames_encryption_mode)) {\n\t\tfscrypt_warn(inode,\n\t\t\t     \"Unsupported encryption modes (contents %d, filenames %d)\",\n\t\t\t     policy->contents_encryption_mode,\n\t\t\t     policy->filenames_encryption_mode);\n\t\treturn false;\n\t}\n\n\tif (policy->flags & ~(FSCRYPT_POLICY_FLAGS_PAD_MASK |\n\t\t\t      FSCRYPT_POLICY_FLAG_DIRECT_KEY |\n\t\t\t      FSCRYPT_POLICY_FLAG_IV_INO_LBLK_64 |\n\t\t\t      FSCRYPT_POLICY_FLAG_IV_INO_LBLK_32)) {\n\t\tfscrypt_warn(inode, \"Unsupported encryption flags (0x%02x)\",\n\t\t\t     policy->flags);\n\t\treturn false;\n\t}\n\n\tcount += !!(policy->flags & FSCRYPT_POLICY_FLAG_DIRECT_KEY);\n\tcount += !!(policy->flags & FSCRYPT_POLICY_FLAG_IV_INO_LBLK_64);\n\tcount += !!(policy->flags & FSCRYPT_POLICY_FLAG_IV_INO_LBLK_32);\n\tif (count > 1) {\n\t\tfscrypt_warn(inode, \"Mutually exclusive encryption flags (0x%02x)\",\n\t\t\t     policy->flags);\n\t\treturn false;\n\t}\n\n\tif ((policy->flags & FSCRYPT_POLICY_FLAG_DIRECT_KEY) &&\n\t    !supported_direct_key_modes(inode, policy->contents_encryption_mode,\n\t\t\t\t\tpolicy->filenames_encryption_mode))\n\t\treturn false;\n\n\tif ((policy->flags & FSCRYPT_POLICY_FLAG_IV_INO_LBLK_64) &&\n\t    !supported_iv_ino_lblk_policy(policy, inode, \"IV_INO_LBLK_64\",\n\t\t\t\t\t  32, 32))\n\t\treturn false;\n\n\t \n\tif ((policy->flags & FSCRYPT_POLICY_FLAG_IV_INO_LBLK_32) &&\n\t    !supported_iv_ino_lblk_policy(policy, inode, \"IV_INO_LBLK_32\",\n\t\t\t\t\t  32, 32))\n\t\treturn false;\n\n\tif (memchr_inv(policy->__reserved, 0, sizeof(policy->__reserved))) {\n\t\tfscrypt_warn(inode, \"Reserved bits set in encryption policy\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nbool fscrypt_supported_policy(const union fscrypt_policy *policy_u,\n\t\t\t      const struct inode *inode)\n{\n\tswitch (policy_u->version) {\n\tcase FSCRYPT_POLICY_V1:\n\t\treturn fscrypt_supported_v1_policy(&policy_u->v1, inode);\n\tcase FSCRYPT_POLICY_V2:\n\t\treturn fscrypt_supported_v2_policy(&policy_u->v2, inode);\n\t}\n\treturn false;\n}\n\n \nstatic int fscrypt_new_context(union fscrypt_context *ctx_u,\n\t\t\t       const union fscrypt_policy *policy_u,\n\t\t\t       const u8 nonce[FSCRYPT_FILE_NONCE_SIZE])\n{\n\tmemset(ctx_u, 0, sizeof(*ctx_u));\n\n\tswitch (policy_u->version) {\n\tcase FSCRYPT_POLICY_V1: {\n\t\tconst struct fscrypt_policy_v1 *policy = &policy_u->v1;\n\t\tstruct fscrypt_context_v1 *ctx = &ctx_u->v1;\n\n\t\tctx->version = FSCRYPT_CONTEXT_V1;\n\t\tctx->contents_encryption_mode =\n\t\t\tpolicy->contents_encryption_mode;\n\t\tctx->filenames_encryption_mode =\n\t\t\tpolicy->filenames_encryption_mode;\n\t\tctx->flags = policy->flags;\n\t\tmemcpy(ctx->master_key_descriptor,\n\t\t       policy->master_key_descriptor,\n\t\t       sizeof(ctx->master_key_descriptor));\n\t\tmemcpy(ctx->nonce, nonce, FSCRYPT_FILE_NONCE_SIZE);\n\t\treturn sizeof(*ctx);\n\t}\n\tcase FSCRYPT_POLICY_V2: {\n\t\tconst struct fscrypt_policy_v2 *policy = &policy_u->v2;\n\t\tstruct fscrypt_context_v2 *ctx = &ctx_u->v2;\n\n\t\tctx->version = FSCRYPT_CONTEXT_V2;\n\t\tctx->contents_encryption_mode =\n\t\t\tpolicy->contents_encryption_mode;\n\t\tctx->filenames_encryption_mode =\n\t\t\tpolicy->filenames_encryption_mode;\n\t\tctx->flags = policy->flags;\n\t\tmemcpy(ctx->master_key_identifier,\n\t\t       policy->master_key_identifier,\n\t\t       sizeof(ctx->master_key_identifier));\n\t\tmemcpy(ctx->nonce, nonce, FSCRYPT_FILE_NONCE_SIZE);\n\t\treturn sizeof(*ctx);\n\t}\n\t}\n\tBUG();\n}\n\n \nint fscrypt_policy_from_context(union fscrypt_policy *policy_u,\n\t\t\t\tconst union fscrypt_context *ctx_u,\n\t\t\t\tint ctx_size)\n{\n\tmemset(policy_u, 0, sizeof(*policy_u));\n\n\tif (!fscrypt_context_is_valid(ctx_u, ctx_size))\n\t\treturn -EINVAL;\n\n\tswitch (ctx_u->version) {\n\tcase FSCRYPT_CONTEXT_V1: {\n\t\tconst struct fscrypt_context_v1 *ctx = &ctx_u->v1;\n\t\tstruct fscrypt_policy_v1 *policy = &policy_u->v1;\n\n\t\tpolicy->version = FSCRYPT_POLICY_V1;\n\t\tpolicy->contents_encryption_mode =\n\t\t\tctx->contents_encryption_mode;\n\t\tpolicy->filenames_encryption_mode =\n\t\t\tctx->filenames_encryption_mode;\n\t\tpolicy->flags = ctx->flags;\n\t\tmemcpy(policy->master_key_descriptor,\n\t\t       ctx->master_key_descriptor,\n\t\t       sizeof(policy->master_key_descriptor));\n\t\treturn 0;\n\t}\n\tcase FSCRYPT_CONTEXT_V2: {\n\t\tconst struct fscrypt_context_v2 *ctx = &ctx_u->v2;\n\t\tstruct fscrypt_policy_v2 *policy = &policy_u->v2;\n\n\t\tpolicy->version = FSCRYPT_POLICY_V2;\n\t\tpolicy->contents_encryption_mode =\n\t\t\tctx->contents_encryption_mode;\n\t\tpolicy->filenames_encryption_mode =\n\t\t\tctx->filenames_encryption_mode;\n\t\tpolicy->flags = ctx->flags;\n\t\tmemcpy(policy->__reserved, ctx->__reserved,\n\t\t       sizeof(policy->__reserved));\n\t\tmemcpy(policy->master_key_identifier,\n\t\t       ctx->master_key_identifier,\n\t\t       sizeof(policy->master_key_identifier));\n\t\treturn 0;\n\t}\n\t}\n\t \n\treturn -EINVAL;\n}\n\n \nstatic int fscrypt_get_policy(struct inode *inode, union fscrypt_policy *policy)\n{\n\tconst struct fscrypt_info *ci;\n\tunion fscrypt_context ctx;\n\tint ret;\n\n\tci = fscrypt_get_info(inode);\n\tif (ci) {\n\t\t \n\t\t*policy = ci->ci_policy;\n\t\treturn 0;\n\t}\n\n\tif (!IS_ENCRYPTED(inode))\n\t\treturn -ENODATA;\n\n\tret = inode->i_sb->s_cop->get_context(inode, &ctx, sizeof(ctx));\n\tif (ret < 0)\n\t\treturn (ret == -ERANGE) ? -EINVAL : ret;\n\n\treturn fscrypt_policy_from_context(policy, &ctx, ret);\n}\n\nstatic int set_encryption_policy(struct inode *inode,\n\t\t\t\t const union fscrypt_policy *policy)\n{\n\tu8 nonce[FSCRYPT_FILE_NONCE_SIZE];\n\tunion fscrypt_context ctx;\n\tint ctxsize;\n\tint err;\n\n\tif (!fscrypt_supported_policy(policy, inode))\n\t\treturn -EINVAL;\n\n\tswitch (policy->version) {\n\tcase FSCRYPT_POLICY_V1:\n\t\t \n\t\tpr_warn_once(\"%s (pid %d) is setting deprecated v1 encryption policy; recommend upgrading to v2.\\n\",\n\t\t\t     current->comm, current->pid);\n\t\tbreak;\n\tcase FSCRYPT_POLICY_V2:\n\t\terr = fscrypt_verify_key_added(inode->i_sb,\n\t\t\t\t\t       policy->v2.master_key_identifier);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (policy->v2.flags & FSCRYPT_POLICY_FLAG_IV_INO_LBLK_32)\n\t\t\tpr_warn_once(\"%s (pid %d) is setting an IV_INO_LBLK_32 encryption policy.  This should only be used if there are certain hardware limitations.\\n\",\n\t\t\t\t     current->comm, current->pid);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn -EINVAL;\n\t}\n\n\tget_random_bytes(nonce, FSCRYPT_FILE_NONCE_SIZE);\n\tctxsize = fscrypt_new_context(&ctx, policy, nonce);\n\n\treturn inode->i_sb->s_cop->set_context(inode, &ctx, ctxsize, NULL);\n}\n\nint fscrypt_ioctl_set_policy(struct file *filp, const void __user *arg)\n{\n\tunion fscrypt_policy policy;\n\tunion fscrypt_policy existing_policy;\n\tstruct inode *inode = file_inode(filp);\n\tu8 version;\n\tint size;\n\tint ret;\n\n\tif (get_user(policy.version, (const u8 __user *)arg))\n\t\treturn -EFAULT;\n\n\tsize = fscrypt_policy_size(&policy);\n\tif (size <= 0)\n\t\treturn -EINVAL;\n\n\t \n\tversion = policy.version;\n\tif (copy_from_user(&policy, arg, size))\n\t\treturn -EFAULT;\n\tpolicy.version = version;\n\n\tif (!inode_owner_or_capable(&nop_mnt_idmap, inode))\n\t\treturn -EACCES;\n\n\tret = mnt_want_write_file(filp);\n\tif (ret)\n\t\treturn ret;\n\n\tinode_lock(inode);\n\n\tret = fscrypt_get_policy(inode, &existing_policy);\n\tif (ret == -ENODATA) {\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\tret = -ENOTDIR;\n\t\telse if (IS_DEADDIR(inode))\n\t\t\tret = -ENOENT;\n\t\telse if (!inode->i_sb->s_cop->empty_dir(inode))\n\t\t\tret = -ENOTEMPTY;\n\t\telse\n\t\t\tret = set_encryption_policy(inode, &policy);\n\t} else if (ret == -EINVAL ||\n\t\t   (ret == 0 && !fscrypt_policies_equal(&policy,\n\t\t\t\t\t\t\t&existing_policy))) {\n\t\t \n\t\tret = -EEXIST;\n\t}\n\n\tinode_unlock(inode);\n\n\tmnt_drop_write_file(filp);\n\treturn ret;\n}\nEXPORT_SYMBOL(fscrypt_ioctl_set_policy);\n\n \nint fscrypt_ioctl_get_policy(struct file *filp, void __user *arg)\n{\n\tunion fscrypt_policy policy;\n\tint err;\n\n\terr = fscrypt_get_policy(file_inode(filp), &policy);\n\tif (err)\n\t\treturn err;\n\n\tif (policy.version != FSCRYPT_POLICY_V1)\n\t\treturn -EINVAL;\n\n\tif (copy_to_user(arg, &policy, sizeof(policy.v1)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\nEXPORT_SYMBOL(fscrypt_ioctl_get_policy);\n\n \nint fscrypt_ioctl_get_policy_ex(struct file *filp, void __user *uarg)\n{\n\tstruct fscrypt_get_policy_ex_arg arg;\n\tunion fscrypt_policy *policy = (union fscrypt_policy *)&arg.policy;\n\tsize_t policy_size;\n\tint err;\n\n\t \n\tBUILD_BUG_ON(offsetof(typeof(arg), policy_size) != 0);\n\tBUILD_BUG_ON(offsetofend(typeof(arg), policy_size) !=\n\t\t     offsetof(typeof(arg), policy));\n\tBUILD_BUG_ON(sizeof(arg.policy) != sizeof(*policy));\n\n\terr = fscrypt_get_policy(file_inode(filp), policy);\n\tif (err)\n\t\treturn err;\n\tpolicy_size = fscrypt_policy_size(policy);\n\n\tif (copy_from_user(&arg, uarg, sizeof(arg.policy_size)))\n\t\treturn -EFAULT;\n\n\tif (policy_size > arg.policy_size)\n\t\treturn -EOVERFLOW;\n\targ.policy_size = policy_size;\n\n\tif (copy_to_user(uarg, &arg, sizeof(arg.policy_size) + policy_size))\n\t\treturn -EFAULT;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(fscrypt_ioctl_get_policy_ex);\n\n \nint fscrypt_ioctl_get_nonce(struct file *filp, void __user *arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tunion fscrypt_context ctx;\n\tint ret;\n\n\tret = inode->i_sb->s_cop->get_context(inode, &ctx, sizeof(ctx));\n\tif (ret < 0)\n\t\treturn ret;\n\tif (!fscrypt_context_is_valid(&ctx, ret))\n\t\treturn -EINVAL;\n\tif (copy_to_user(arg, fscrypt_context_nonce(&ctx),\n\t\t\t FSCRYPT_FILE_NONCE_SIZE))\n\t\treturn -EFAULT;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(fscrypt_ioctl_get_nonce);\n\n \nint fscrypt_has_permitted_context(struct inode *parent, struct inode *child)\n{\n\tunion fscrypt_policy parent_policy, child_policy;\n\tint err, err1, err2;\n\n\t \n\tif (!S_ISREG(child->i_mode) && !S_ISDIR(child->i_mode) &&\n\t    !S_ISLNK(child->i_mode))\n\t\treturn 1;\n\n\t \n\tif (!IS_ENCRYPTED(parent))\n\t\treturn 1;\n\n\t \n\tif (!IS_ENCRYPTED(child))\n\t\treturn 0;\n\n\t \n\n\terr = fscrypt_get_encryption_info(parent, true);\n\tif (err)\n\t\treturn 0;\n\terr = fscrypt_get_encryption_info(child, true);\n\tif (err)\n\t\treturn 0;\n\n\terr1 = fscrypt_get_policy(parent, &parent_policy);\n\terr2 = fscrypt_get_policy(child, &child_policy);\n\n\t \n\tif (err1 == -EINVAL && err2 == -EINVAL)\n\t\treturn 1;\n\n\tif (err1 || err2)\n\t\treturn 0;\n\n\treturn fscrypt_policies_equal(&parent_policy, &child_policy);\n}\nEXPORT_SYMBOL(fscrypt_has_permitted_context);\n\n \nconst union fscrypt_policy *fscrypt_policy_to_inherit(struct inode *dir)\n{\n\tint err;\n\n\tif (IS_ENCRYPTED(dir)) {\n\t\terr = fscrypt_require_key(dir);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\t\treturn &dir->i_crypt_info->ci_policy;\n\t}\n\n\treturn fscrypt_get_dummy_policy(dir->i_sb);\n}\n\n \nint fscrypt_context_for_new_inode(void *ctx, struct inode *inode)\n{\n\tstruct fscrypt_info *ci = inode->i_crypt_info;\n\n\tBUILD_BUG_ON(sizeof(union fscrypt_context) !=\n\t\t\tFSCRYPT_SET_CONTEXT_MAX_SIZE);\n\n\t \n\tif (WARN_ON_ONCE(!ci))\n\t\treturn -ENOKEY;\n\n\treturn fscrypt_new_context(ctx, &ci->ci_policy, ci->ci_nonce);\n}\nEXPORT_SYMBOL_GPL(fscrypt_context_for_new_inode);\n\n \nint fscrypt_set_context(struct inode *inode, void *fs_data)\n{\n\tstruct fscrypt_info *ci = inode->i_crypt_info;\n\tunion fscrypt_context ctx;\n\tint ctxsize;\n\n\tctxsize = fscrypt_context_for_new_inode(&ctx, inode);\n\tif (ctxsize < 0)\n\t\treturn ctxsize;\n\n\t \n\tif (ci->ci_policy.version == FSCRYPT_POLICY_V2 &&\n\t    (ci->ci_policy.v2.flags & FSCRYPT_POLICY_FLAG_IV_INO_LBLK_32))\n\t\tfscrypt_hash_inode_number(ci, ci->ci_master_key);\n\n\treturn inode->i_sb->s_cop->set_context(inode, &ctx, ctxsize, fs_data);\n}\nEXPORT_SYMBOL_GPL(fscrypt_set_context);\n\n \nint fscrypt_parse_test_dummy_encryption(const struct fs_parameter *param,\n\t\t\t\tstruct fscrypt_dummy_policy *dummy_policy)\n{\n\tconst char *arg = \"v2\";\n\tunion fscrypt_policy *policy;\n\tint err;\n\n\tif (param->type == fs_value_is_string && *param->string)\n\t\targ = param->string;\n\n\tpolicy = kzalloc(sizeof(*policy), GFP_KERNEL);\n\tif (!policy)\n\t\treturn -ENOMEM;\n\n\tif (!strcmp(arg, \"v1\")) {\n\t\tpolicy->version = FSCRYPT_POLICY_V1;\n\t\tpolicy->v1.contents_encryption_mode = FSCRYPT_MODE_AES_256_XTS;\n\t\tpolicy->v1.filenames_encryption_mode = FSCRYPT_MODE_AES_256_CTS;\n\t\tmemset(policy->v1.master_key_descriptor, 0x42,\n\t\t       FSCRYPT_KEY_DESCRIPTOR_SIZE);\n\t} else if (!strcmp(arg, \"v2\")) {\n\t\tpolicy->version = FSCRYPT_POLICY_V2;\n\t\tpolicy->v2.contents_encryption_mode = FSCRYPT_MODE_AES_256_XTS;\n\t\tpolicy->v2.filenames_encryption_mode = FSCRYPT_MODE_AES_256_CTS;\n\t\terr = fscrypt_get_test_dummy_key_identifier(\n\t\t\t\tpolicy->v2.master_key_identifier);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (dummy_policy->policy) {\n\t\tif (fscrypt_policies_equal(policy, dummy_policy->policy))\n\t\t\terr = 0;\n\t\telse\n\t\t\terr = -EEXIST;\n\t\tgoto out;\n\t}\n\tdummy_policy->policy = policy;\n\tpolicy = NULL;\n\terr = 0;\nout:\n\tkfree(policy);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(fscrypt_parse_test_dummy_encryption);\n\n \nbool fscrypt_dummy_policies_equal(const struct fscrypt_dummy_policy *p1,\n\t\t\t\t  const struct fscrypt_dummy_policy *p2)\n{\n\tif (!p1->policy && !p2->policy)\n\t\treturn true;\n\tif (!p1->policy || !p2->policy)\n\t\treturn false;\n\treturn fscrypt_policies_equal(p1->policy, p2->policy);\n}\nEXPORT_SYMBOL_GPL(fscrypt_dummy_policies_equal);\n\n \nvoid fscrypt_show_test_dummy_encryption(struct seq_file *seq, char sep,\n\t\t\t\t\tstruct super_block *sb)\n{\n\tconst union fscrypt_policy *policy = fscrypt_get_dummy_policy(sb);\n\tint vers;\n\n\tif (!policy)\n\t\treturn;\n\n\tvers = policy->version;\n\tif (vers == FSCRYPT_POLICY_V1)  \n\t\tvers = 1;\n\n\tseq_printf(seq, \"%ctest_dummy_encryption=v%d\", sep, vers);\n}\nEXPORT_SYMBOL_GPL(fscrypt_show_test_dummy_encryption);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}