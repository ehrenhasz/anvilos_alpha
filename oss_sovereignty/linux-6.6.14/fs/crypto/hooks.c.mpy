{
  "module_name": "hooks.c",
  "hash_id": "d8bbd4c2c8bb3bd195793261201d8ed1ed0489d8256a7b7c4152bda75a46aaf9",
  "original_prompt": "Ingested from linux-6.6.14/fs/crypto/hooks.c",
  "human_readable_source": "\n \n\n#include \"fscrypt_private.h\"\n\n \nint fscrypt_file_open(struct inode *inode, struct file *filp)\n{\n\tint err;\n\tstruct dentry *dir;\n\n\terr = fscrypt_require_key(inode);\n\tif (err)\n\t\treturn err;\n\n\tdir = dget_parent(file_dentry(filp));\n\tif (IS_ENCRYPTED(d_inode(dir)) &&\n\t    !fscrypt_has_permitted_context(d_inode(dir), inode)) {\n\t\tfscrypt_warn(inode,\n\t\t\t     \"Inconsistent encryption context (parent directory: %lu)\",\n\t\t\t     d_inode(dir)->i_ino);\n\t\terr = -EPERM;\n\t}\n\tdput(dir);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(fscrypt_file_open);\n\nint __fscrypt_prepare_link(struct inode *inode, struct inode *dir,\n\t\t\t   struct dentry *dentry)\n{\n\tif (fscrypt_is_nokey_name(dentry))\n\t\treturn -ENOKEY;\n\t \n\n\tif (!fscrypt_has_permitted_context(dir, inode))\n\t\treturn -EXDEV;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(__fscrypt_prepare_link);\n\nint __fscrypt_prepare_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\t     struct inode *new_dir, struct dentry *new_dentry,\n\t\t\t     unsigned int flags)\n{\n\tif (fscrypt_is_nokey_name(old_dentry) ||\n\t    fscrypt_is_nokey_name(new_dentry))\n\t\treturn -ENOKEY;\n\t \n\n\tif (old_dir != new_dir) {\n\t\tif (IS_ENCRYPTED(new_dir) &&\n\t\t    !fscrypt_has_permitted_context(new_dir,\n\t\t\t\t\t\t   d_inode(old_dentry)))\n\t\t\treturn -EXDEV;\n\n\t\tif ((flags & RENAME_EXCHANGE) &&\n\t\t    IS_ENCRYPTED(old_dir) &&\n\t\t    !fscrypt_has_permitted_context(old_dir,\n\t\t\t\t\t\t   d_inode(new_dentry)))\n\t\t\treturn -EXDEV;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(__fscrypt_prepare_rename);\n\nint __fscrypt_prepare_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t     struct fscrypt_name *fname)\n{\n\tint err = fscrypt_setup_filename(dir, &dentry->d_name, 1, fname);\n\n\tif (err && err != -ENOENT)\n\t\treturn err;\n\n\tif (fname->is_nokey_name) {\n\t\tspin_lock(&dentry->d_lock);\n\t\tdentry->d_flags |= DCACHE_NOKEY_NAME;\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(__fscrypt_prepare_lookup);\n\n \nint fscrypt_prepare_lookup_partial(struct inode *dir, struct dentry *dentry)\n{\n\tint err = fscrypt_get_encryption_info(dir, true);\n\n\tif (!err && !fscrypt_has_encryption_key(dir)) {\n\t\tspin_lock(&dentry->d_lock);\n\t\tdentry->d_flags |= DCACHE_NOKEY_NAME;\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(fscrypt_prepare_lookup_partial);\n\nint __fscrypt_prepare_readdir(struct inode *dir)\n{\n\treturn fscrypt_get_encryption_info(dir, true);\n}\nEXPORT_SYMBOL_GPL(__fscrypt_prepare_readdir);\n\nint __fscrypt_prepare_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tif (attr->ia_valid & ATTR_SIZE)\n\t\treturn fscrypt_require_key(d_inode(dentry));\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(__fscrypt_prepare_setattr);\n\n \nint fscrypt_prepare_setflags(struct inode *inode,\n\t\t\t     unsigned int oldflags, unsigned int flags)\n{\n\tstruct fscrypt_info *ci;\n\tstruct fscrypt_master_key *mk;\n\tint err;\n\n\t \n\tif (IS_ENCRYPTED(inode) && (flags & ~oldflags & FS_CASEFOLD_FL)) {\n\t\terr = fscrypt_require_key(inode);\n\t\tif (err)\n\t\t\treturn err;\n\t\tci = inode->i_crypt_info;\n\t\tif (ci->ci_policy.version != FSCRYPT_POLICY_V2)\n\t\t\treturn -EINVAL;\n\t\tmk = ci->ci_master_key;\n\t\tdown_read(&mk->mk_sem);\n\t\tif (is_master_key_secret_present(&mk->mk_secret))\n\t\t\terr = fscrypt_derive_dirhash_key(ci, mk);\n\t\telse\n\t\t\terr = -ENOKEY;\n\t\tup_read(&mk->mk_sem);\n\t\treturn err;\n\t}\n\treturn 0;\n}\n\n \nint fscrypt_prepare_symlink(struct inode *dir, const char *target,\n\t\t\t    unsigned int len, unsigned int max_len,\n\t\t\t    struct fscrypt_str *disk_link)\n{\n\tconst union fscrypt_policy *policy;\n\n\t \n\tpolicy = fscrypt_policy_to_inherit(dir);\n\tif (policy == NULL) {\n\t\t \n\t\tdisk_link->name = (unsigned char *)target;\n\t\tdisk_link->len = len + 1;\n\t\tif (disk_link->len > max_len)\n\t\t\treturn -ENAMETOOLONG;\n\t\treturn 0;\n\t}\n\tif (IS_ERR(policy))\n\t\treturn PTR_ERR(policy);\n\n\t \n\tif (!__fscrypt_fname_encrypted_size(policy, len,\n\t\t\t\t\t    max_len - sizeof(struct fscrypt_symlink_data) - 1,\n\t\t\t\t\t    &disk_link->len))\n\t\treturn -ENAMETOOLONG;\n\tdisk_link->len += sizeof(struct fscrypt_symlink_data) + 1;\n\n\tdisk_link->name = NULL;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(fscrypt_prepare_symlink);\n\nint __fscrypt_encrypt_symlink(struct inode *inode, const char *target,\n\t\t\t      unsigned int len, struct fscrypt_str *disk_link)\n{\n\tint err;\n\tstruct qstr iname = QSTR_INIT(target, len);\n\tstruct fscrypt_symlink_data *sd;\n\tunsigned int ciphertext_len;\n\n\t \n\tif (WARN_ON_ONCE(!fscrypt_has_encryption_key(inode)))\n\t\treturn -ENOKEY;\n\n\tif (disk_link->name) {\n\t\t \n\t\tsd = (struct fscrypt_symlink_data *)disk_link->name;\n\t} else {\n\t\tsd = kmalloc(disk_link->len, GFP_NOFS);\n\t\tif (!sd)\n\t\t\treturn -ENOMEM;\n\t}\n\tciphertext_len = disk_link->len - sizeof(*sd) - 1;\n\tsd->len = cpu_to_le16(ciphertext_len);\n\n\terr = fscrypt_fname_encrypt(inode, &iname, sd->encrypted_path,\n\t\t\t\t    ciphertext_len);\n\tif (err)\n\t\tgoto err_free_sd;\n\n\t \n\tsd->encrypted_path[ciphertext_len] = '\\0';\n\n\t \n\terr = -ENOMEM;\n\tinode->i_link = kmemdup(target, len + 1, GFP_NOFS);\n\tif (!inode->i_link)\n\t\tgoto err_free_sd;\n\n\tif (!disk_link->name)\n\t\tdisk_link->name = (unsigned char *)sd;\n\treturn 0;\n\nerr_free_sd:\n\tif (!disk_link->name)\n\t\tkfree(sd);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(__fscrypt_encrypt_symlink);\n\n \nconst char *fscrypt_get_symlink(struct inode *inode, const void *caddr,\n\t\t\t\tunsigned int max_size,\n\t\t\t\tstruct delayed_call *done)\n{\n\tconst struct fscrypt_symlink_data *sd;\n\tstruct fscrypt_str cstr, pstr;\n\tbool has_key;\n\tint err;\n\n\t \n\tif (WARN_ON_ONCE(!IS_ENCRYPTED(inode)))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t \n\tpstr.name = READ_ONCE(inode->i_link);\n\tif (pstr.name)\n\t\treturn pstr.name;\n\n\t \n\terr = fscrypt_get_encryption_info(inode, false);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\thas_key = fscrypt_has_encryption_key(inode);\n\n\t \n\n\tif (max_size < sizeof(*sd) + 1)\n\t\treturn ERR_PTR(-EUCLEAN);\n\tsd = caddr;\n\tcstr.name = (unsigned char *)sd->encrypted_path;\n\tcstr.len = le16_to_cpu(sd->len);\n\n\tif (cstr.len == 0)\n\t\treturn ERR_PTR(-EUCLEAN);\n\n\tif (cstr.len + sizeof(*sd) > max_size)\n\t\treturn ERR_PTR(-EUCLEAN);\n\n\terr = fscrypt_fname_alloc_buffer(cstr.len, &pstr);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\terr = fscrypt_fname_disk_to_usr(inode, 0, 0, &cstr, &pstr);\n\tif (err)\n\t\tgoto err_kfree;\n\n\terr = -EUCLEAN;\n\tif (pstr.name[0] == '\\0')\n\t\tgoto err_kfree;\n\n\tpstr.name[pstr.len] = '\\0';\n\n\t \n\tif (!has_key ||\n\t    cmpxchg_release(&inode->i_link, NULL, pstr.name) != NULL)\n\t\tset_delayed_call(done, kfree_link, pstr.name);\n\n\treturn pstr.name;\n\nerr_kfree:\n\tkfree(pstr.name);\n\treturn ERR_PTR(err);\n}\nEXPORT_SYMBOL_GPL(fscrypt_get_symlink);\n\n \nint fscrypt_symlink_getattr(const struct path *path, struct kstat *stat)\n{\n\tstruct dentry *dentry = path->dentry;\n\tstruct inode *inode = d_inode(dentry);\n\tconst char *link;\n\tDEFINE_DELAYED_CALL(done);\n\n\t \n\tlink = READ_ONCE(inode->i_link);\n\tif (!link) {\n\t\tlink = inode->i_op->get_link(dentry, inode, &done);\n\t\tif (IS_ERR(link))\n\t\t\treturn PTR_ERR(link);\n\t}\n\tstat->size = strlen(link);\n\tdo_delayed_call(&done);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(fscrypt_symlink_getattr);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}