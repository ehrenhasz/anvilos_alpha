{
  "module_name": "fscrypt_private.h",
  "hash_id": "505fd92e6b2cefc86738c77700821cde2b301eec305c10e23cd3b1c89f78e26d",
  "original_prompt": "Ingested from linux-6.6.14/fs/crypto/fscrypt_private.h",
  "human_readable_source": " \n \n\n#ifndef _FSCRYPT_PRIVATE_H\n#define _FSCRYPT_PRIVATE_H\n\n#include <linux/fscrypt.h>\n#include <linux/siphash.h>\n#include <crypto/hash.h>\n#include <linux/blk-crypto.h>\n\n#define CONST_STRLEN(str)\t(sizeof(str) - 1)\n\n#define FSCRYPT_FILE_NONCE_SIZE\t16\n\n \n#define FSCRYPT_MIN_KEY_SIZE\t16\n\n#define FSCRYPT_CONTEXT_V1\t1\n#define FSCRYPT_CONTEXT_V2\t2\n\n \n#define FSCRYPT_MODE_MAX\tFSCRYPT_MODE_AES_256_HCTR2\n\nstruct fscrypt_context_v1 {\n\tu8 version;  \n\tu8 contents_encryption_mode;\n\tu8 filenames_encryption_mode;\n\tu8 flags;\n\tu8 master_key_descriptor[FSCRYPT_KEY_DESCRIPTOR_SIZE];\n\tu8 nonce[FSCRYPT_FILE_NONCE_SIZE];\n};\n\nstruct fscrypt_context_v2 {\n\tu8 version;  \n\tu8 contents_encryption_mode;\n\tu8 filenames_encryption_mode;\n\tu8 flags;\n\tu8 __reserved[4];\n\tu8 master_key_identifier[FSCRYPT_KEY_IDENTIFIER_SIZE];\n\tu8 nonce[FSCRYPT_FILE_NONCE_SIZE];\n};\n\n \nunion fscrypt_context {\n\tu8 version;\n\tstruct fscrypt_context_v1 v1;\n\tstruct fscrypt_context_v2 v2;\n};\n\n \nstatic inline int fscrypt_context_size(const union fscrypt_context *ctx)\n{\n\tswitch (ctx->version) {\n\tcase FSCRYPT_CONTEXT_V1:\n\t\tBUILD_BUG_ON(sizeof(ctx->v1) != 28);\n\t\treturn sizeof(ctx->v1);\n\tcase FSCRYPT_CONTEXT_V2:\n\t\tBUILD_BUG_ON(sizeof(ctx->v2) != 40);\n\t\treturn sizeof(ctx->v2);\n\t}\n\treturn 0;\n}\n\n \nstatic inline bool fscrypt_context_is_valid(const union fscrypt_context *ctx,\n\t\t\t\t\t    int ctx_size)\n{\n\treturn ctx_size >= 1 && ctx_size == fscrypt_context_size(ctx);\n}\n\n \nstatic inline const u8 *fscrypt_context_nonce(const union fscrypt_context *ctx)\n{\n\tswitch (ctx->version) {\n\tcase FSCRYPT_CONTEXT_V1:\n\t\treturn ctx->v1.nonce;\n\tcase FSCRYPT_CONTEXT_V2:\n\t\treturn ctx->v2.nonce;\n\t}\n\tWARN_ON_ONCE(1);\n\treturn NULL;\n}\n\nunion fscrypt_policy {\n\tu8 version;\n\tstruct fscrypt_policy_v1 v1;\n\tstruct fscrypt_policy_v2 v2;\n};\n\n \nstatic inline int fscrypt_policy_size(const union fscrypt_policy *policy)\n{\n\tswitch (policy->version) {\n\tcase FSCRYPT_POLICY_V1:\n\t\treturn sizeof(policy->v1);\n\tcase FSCRYPT_POLICY_V2:\n\t\treturn sizeof(policy->v2);\n\t}\n\treturn 0;\n}\n\n \nstatic inline u8\nfscrypt_policy_contents_mode(const union fscrypt_policy *policy)\n{\n\tswitch (policy->version) {\n\tcase FSCRYPT_POLICY_V1:\n\t\treturn policy->v1.contents_encryption_mode;\n\tcase FSCRYPT_POLICY_V2:\n\t\treturn policy->v2.contents_encryption_mode;\n\t}\n\tBUG();\n}\n\n \nstatic inline u8\nfscrypt_policy_fnames_mode(const union fscrypt_policy *policy)\n{\n\tswitch (policy->version) {\n\tcase FSCRYPT_POLICY_V1:\n\t\treturn policy->v1.filenames_encryption_mode;\n\tcase FSCRYPT_POLICY_V2:\n\t\treturn policy->v2.filenames_encryption_mode;\n\t}\n\tBUG();\n}\n\n \nstatic inline u8\nfscrypt_policy_flags(const union fscrypt_policy *policy)\n{\n\tswitch (policy->version) {\n\tcase FSCRYPT_POLICY_V1:\n\t\treturn policy->v1.flags;\n\tcase FSCRYPT_POLICY_V2:\n\t\treturn policy->v2.flags;\n\t}\n\tBUG();\n}\n\n \nstruct fscrypt_symlink_data {\n\t__le16 len;\n\tchar encrypted_path[];\n} __packed;\n\n \nstruct fscrypt_prepared_key {\n\tstruct crypto_skcipher *tfm;\n#ifdef CONFIG_FS_ENCRYPTION_INLINE_CRYPT\n\tstruct blk_crypto_key *blk_key;\n#endif\n};\n\n \nstruct fscrypt_info {\n\n\t \n\tstruct fscrypt_prepared_key ci_enc_key;\n\n\t \n\tbool ci_owns_key;\n\n#ifdef CONFIG_FS_ENCRYPTION_INLINE_CRYPT\n\t \n\tbool ci_inlinecrypt;\n#endif\n\n\t \n\tstruct fscrypt_mode *ci_mode;\n\n\t \n\tstruct inode *ci_inode;\n\n\t \n\tstruct fscrypt_master_key *ci_master_key;\n\n\t \n\tstruct list_head ci_master_key_link;\n\n\t \n\tstruct fscrypt_direct_key *ci_direct_key;\n\n\t \n\tsiphash_key_t ci_dirhash_key;\n\tbool ci_dirhash_key_initialized;\n\n\t \n\tunion fscrypt_policy ci_policy;\n\n\t \n\tu8 ci_nonce[FSCRYPT_FILE_NONCE_SIZE];\n\n\t \n\tu32 ci_hashed_ino;\n};\n\ntypedef enum {\n\tFS_DECRYPT = 0,\n\tFS_ENCRYPT,\n} fscrypt_direction_t;\n\n \nextern struct kmem_cache *fscrypt_info_cachep;\nint fscrypt_initialize(struct super_block *sb);\nint fscrypt_crypt_block(const struct inode *inode, fscrypt_direction_t rw,\n\t\t\tu64 lblk_num, struct page *src_page,\n\t\t\tstruct page *dest_page, unsigned int len,\n\t\t\tunsigned int offs, gfp_t gfp_flags);\nstruct page *fscrypt_alloc_bounce_page(gfp_t gfp_flags);\n\nvoid __printf(3, 4) __cold\nfscrypt_msg(const struct inode *inode, const char *level, const char *fmt, ...);\n\n#define fscrypt_warn(inode, fmt, ...)\t\t\\\n\tfscrypt_msg((inode), KERN_WARNING, fmt, ##__VA_ARGS__)\n#define fscrypt_err(inode, fmt, ...)\t\t\\\n\tfscrypt_msg((inode), KERN_ERR, fmt, ##__VA_ARGS__)\n\n#define FSCRYPT_MAX_IV_SIZE\t32\n\nunion fscrypt_iv {\n\tstruct {\n\t\t \n\t\t__le64 lblk_num;\n\n\t\t \n\t\tu8 nonce[FSCRYPT_FILE_NONCE_SIZE];\n\t};\n\tu8 raw[FSCRYPT_MAX_IV_SIZE];\n\t__le64 dun[FSCRYPT_MAX_IV_SIZE / sizeof(__le64)];\n};\n\nvoid fscrypt_generate_iv(union fscrypt_iv *iv, u64 lblk_num,\n\t\t\t const struct fscrypt_info *ci);\n\n \nbool __fscrypt_fname_encrypted_size(const union fscrypt_policy *policy,\n\t\t\t\t    u32 orig_len, u32 max_len,\n\t\t\t\t    u32 *encrypted_len_ret);\n\n \nstruct fscrypt_hkdf {\n\tstruct crypto_shash *hmac_tfm;\n};\n\nint fscrypt_init_hkdf(struct fscrypt_hkdf *hkdf, const u8 *master_key,\n\t\t      unsigned int master_key_size);\n\n \n#define HKDF_CONTEXT_KEY_IDENTIFIER\t1  \n#define HKDF_CONTEXT_PER_FILE_ENC_KEY\t2  \n#define HKDF_CONTEXT_DIRECT_KEY\t\t3  \n#define HKDF_CONTEXT_IV_INO_LBLK_64_KEY\t4  \n#define HKDF_CONTEXT_DIRHASH_KEY\t5  \n#define HKDF_CONTEXT_IV_INO_LBLK_32_KEY\t6  \n#define HKDF_CONTEXT_INODE_HASH_KEY\t7  \n\nint fscrypt_hkdf_expand(const struct fscrypt_hkdf *hkdf, u8 context,\n\t\t\tconst u8 *info, unsigned int infolen,\n\t\t\tu8 *okm, unsigned int okmlen);\n\nvoid fscrypt_destroy_hkdf(struct fscrypt_hkdf *hkdf);\n\n \n#ifdef CONFIG_FS_ENCRYPTION_INLINE_CRYPT\nint fscrypt_select_encryption_impl(struct fscrypt_info *ci);\n\nstatic inline bool\nfscrypt_using_inline_encryption(const struct fscrypt_info *ci)\n{\n\treturn ci->ci_inlinecrypt;\n}\n\nint fscrypt_prepare_inline_crypt_key(struct fscrypt_prepared_key *prep_key,\n\t\t\t\t     const u8 *raw_key,\n\t\t\t\t     const struct fscrypt_info *ci);\n\nvoid fscrypt_destroy_inline_crypt_key(struct super_block *sb,\n\t\t\t\t      struct fscrypt_prepared_key *prep_key);\n\n \nstatic inline bool\nfscrypt_is_key_prepared(struct fscrypt_prepared_key *prep_key,\n\t\t\tconst struct fscrypt_info *ci)\n{\n\t \n\tif (fscrypt_using_inline_encryption(ci))\n\t\treturn smp_load_acquire(&prep_key->blk_key) != NULL;\n\treturn smp_load_acquire(&prep_key->tfm) != NULL;\n}\n\n#else  \n\nstatic inline int fscrypt_select_encryption_impl(struct fscrypt_info *ci)\n{\n\treturn 0;\n}\n\nstatic inline bool\nfscrypt_using_inline_encryption(const struct fscrypt_info *ci)\n{\n\treturn false;\n}\n\nstatic inline int\nfscrypt_prepare_inline_crypt_key(struct fscrypt_prepared_key *prep_key,\n\t\t\t\t const u8 *raw_key,\n\t\t\t\t const struct fscrypt_info *ci)\n{\n\tWARN_ON_ONCE(1);\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline void\nfscrypt_destroy_inline_crypt_key(struct super_block *sb,\n\t\t\t\t struct fscrypt_prepared_key *prep_key)\n{\n}\n\nstatic inline bool\nfscrypt_is_key_prepared(struct fscrypt_prepared_key *prep_key,\n\t\t\tconst struct fscrypt_info *ci)\n{\n\treturn smp_load_acquire(&prep_key->tfm) != NULL;\n}\n#endif  \n\n \n\n \nstruct fscrypt_master_key_secret {\n\n\t \n\tstruct fscrypt_hkdf\thkdf;\n\n\t \n\tu32\t\t\tsize;\n\n\t \n\tu8\t\t\traw[FSCRYPT_MAX_KEY_SIZE];\n\n} __randomize_layout;\n\n \nstruct fscrypt_master_key {\n\n\t \n\tstruct hlist_node\t\t\tmk_node;\n\n\t \n\tstruct rw_semaphore\t\t\tmk_sem;\n\n\t \n\trefcount_t\t\t\t\tmk_active_refs;\n\trefcount_t\t\t\t\tmk_struct_refs;\n\n\tstruct rcu_head\t\t\t\tmk_rcu_head;\n\n\t \n\tstruct fscrypt_master_key_secret\tmk_secret;\n\n\t \n\tstruct fscrypt_key_specifier\t\tmk_spec;\n\n\t \n\tstruct key\t\t*mk_users;\n\n\t \n\tstruct list_head\tmk_decrypted_inodes;\n\tspinlock_t\t\tmk_decrypted_inodes_lock;\n\n\t \n\tstruct fscrypt_prepared_key mk_direct_keys[FSCRYPT_MODE_MAX + 1];\n\tstruct fscrypt_prepared_key mk_iv_ino_lblk_64_keys[FSCRYPT_MODE_MAX + 1];\n\tstruct fscrypt_prepared_key mk_iv_ino_lblk_32_keys[FSCRYPT_MODE_MAX + 1];\n\n\t \n\tsiphash_key_t\t\tmk_ino_hash_key;\n\tbool\t\t\tmk_ino_hash_key_initialized;\n\n} __randomize_layout;\n\nstatic inline bool\nis_master_key_secret_present(const struct fscrypt_master_key_secret *secret)\n{\n\t \n\treturn READ_ONCE(secret->size) != 0;\n}\n\nstatic inline const char *master_key_spec_type(\n\t\t\t\tconst struct fscrypt_key_specifier *spec)\n{\n\tswitch (spec->type) {\n\tcase FSCRYPT_KEY_SPEC_TYPE_DESCRIPTOR:\n\t\treturn \"descriptor\";\n\tcase FSCRYPT_KEY_SPEC_TYPE_IDENTIFIER:\n\t\treturn \"identifier\";\n\t}\n\treturn \"[unknown]\";\n}\n\nstatic inline int master_key_spec_len(const struct fscrypt_key_specifier *spec)\n{\n\tswitch (spec->type) {\n\tcase FSCRYPT_KEY_SPEC_TYPE_DESCRIPTOR:\n\t\treturn FSCRYPT_KEY_DESCRIPTOR_SIZE;\n\tcase FSCRYPT_KEY_SPEC_TYPE_IDENTIFIER:\n\t\treturn FSCRYPT_KEY_IDENTIFIER_SIZE;\n\t}\n\treturn 0;\n}\n\nvoid fscrypt_put_master_key(struct fscrypt_master_key *mk);\n\nvoid fscrypt_put_master_key_activeref(struct super_block *sb,\n\t\t\t\t      struct fscrypt_master_key *mk);\n\nstruct fscrypt_master_key *\nfscrypt_find_master_key(struct super_block *sb,\n\t\t\tconst struct fscrypt_key_specifier *mk_spec);\n\nint fscrypt_get_test_dummy_key_identifier(\n\t\t\t  u8 key_identifier[FSCRYPT_KEY_IDENTIFIER_SIZE]);\n\nint fscrypt_add_test_dummy_key(struct super_block *sb,\n\t\t\t       struct fscrypt_key_specifier *key_spec);\n\nint fscrypt_verify_key_added(struct super_block *sb,\n\t\t\t     const u8 identifier[FSCRYPT_KEY_IDENTIFIER_SIZE]);\n\nint __init fscrypt_init_keyring(void);\n\n \n\nstruct fscrypt_mode {\n\tconst char *friendly_name;\n\tconst char *cipher_str;\n\tint keysize;\t\t \n\tint security_strength;\t \n\tint ivsize;\t\t \n\tint logged_cryptoapi_impl;\n\tint logged_blk_crypto_native;\n\tint logged_blk_crypto_fallback;\n\tenum blk_crypto_mode_num blk_crypto_mode;\n};\n\nextern struct fscrypt_mode fscrypt_modes[];\n\nint fscrypt_prepare_key(struct fscrypt_prepared_key *prep_key,\n\t\t\tconst u8 *raw_key, const struct fscrypt_info *ci);\n\nvoid fscrypt_destroy_prepared_key(struct super_block *sb,\n\t\t\t\t  struct fscrypt_prepared_key *prep_key);\n\nint fscrypt_set_per_file_enc_key(struct fscrypt_info *ci, const u8 *raw_key);\n\nint fscrypt_derive_dirhash_key(struct fscrypt_info *ci,\n\t\t\t       const struct fscrypt_master_key *mk);\n\nvoid fscrypt_hash_inode_number(struct fscrypt_info *ci,\n\t\t\t       const struct fscrypt_master_key *mk);\n\nint fscrypt_get_encryption_info(struct inode *inode, bool allow_unsupported);\n\n \nstatic inline int fscrypt_require_key(struct inode *inode)\n{\n\tif (IS_ENCRYPTED(inode)) {\n\t\tint err = fscrypt_get_encryption_info(inode, false);\n\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (!fscrypt_has_encryption_key(inode))\n\t\t\treturn -ENOKEY;\n\t}\n\treturn 0;\n}\n\n \n\nvoid fscrypt_put_direct_key(struct fscrypt_direct_key *dk);\n\nint fscrypt_setup_v1_file_key(struct fscrypt_info *ci,\n\t\t\t      const u8 *raw_master_key);\n\nint fscrypt_setup_v1_file_key_via_subscribed_keyrings(struct fscrypt_info *ci);\n\n \n\nbool fscrypt_policies_equal(const union fscrypt_policy *policy1,\n\t\t\t    const union fscrypt_policy *policy2);\nint fscrypt_policy_to_key_spec(const union fscrypt_policy *policy,\n\t\t\t       struct fscrypt_key_specifier *key_spec);\nconst union fscrypt_policy *fscrypt_get_dummy_policy(struct super_block *sb);\nbool fscrypt_supported_policy(const union fscrypt_policy *policy_u,\n\t\t\t      const struct inode *inode);\nint fscrypt_policy_from_context(union fscrypt_policy *policy_u,\n\t\t\t\tconst union fscrypt_context *ctx_u,\n\t\t\t\tint ctx_size);\nconst union fscrypt_policy *fscrypt_policy_to_inherit(struct inode *dir);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}