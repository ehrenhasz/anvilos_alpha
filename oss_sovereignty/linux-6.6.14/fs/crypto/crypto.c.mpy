{
  "module_name": "crypto.c",
  "hash_id": "9d9bfdec5f1af985944c63390e37278207dd9cfe5469df5dc321fe350f6d845d",
  "original_prompt": "Ingested from linux-6.6.14/fs/crypto/crypto.c",
  "human_readable_source": "\n \n\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/module.h>\n#include <linux/scatterlist.h>\n#include <linux/ratelimit.h>\n#include <crypto/skcipher.h>\n#include \"fscrypt_private.h\"\n\nstatic unsigned int num_prealloc_crypto_pages = 32;\n\nmodule_param(num_prealloc_crypto_pages, uint, 0444);\nMODULE_PARM_DESC(num_prealloc_crypto_pages,\n\t\t\"Number of crypto pages to preallocate\");\n\nstatic mempool_t *fscrypt_bounce_page_pool = NULL;\n\nstatic struct workqueue_struct *fscrypt_read_workqueue;\nstatic DEFINE_MUTEX(fscrypt_init_mutex);\n\nstruct kmem_cache *fscrypt_info_cachep;\n\nvoid fscrypt_enqueue_decrypt_work(struct work_struct *work)\n{\n\tqueue_work(fscrypt_read_workqueue, work);\n}\nEXPORT_SYMBOL(fscrypt_enqueue_decrypt_work);\n\nstruct page *fscrypt_alloc_bounce_page(gfp_t gfp_flags)\n{\n\treturn mempool_alloc(fscrypt_bounce_page_pool, gfp_flags);\n}\n\n \nvoid fscrypt_free_bounce_page(struct page *bounce_page)\n{\n\tif (!bounce_page)\n\t\treturn;\n\tset_page_private(bounce_page, (unsigned long)NULL);\n\tClearPagePrivate(bounce_page);\n\tmempool_free(bounce_page, fscrypt_bounce_page_pool);\n}\nEXPORT_SYMBOL(fscrypt_free_bounce_page);\n\n \nvoid fscrypt_generate_iv(union fscrypt_iv *iv, u64 lblk_num,\n\t\t\t const struct fscrypt_info *ci)\n{\n\tu8 flags = fscrypt_policy_flags(&ci->ci_policy);\n\n\tmemset(iv, 0, ci->ci_mode->ivsize);\n\n\tif (flags & FSCRYPT_POLICY_FLAG_IV_INO_LBLK_64) {\n\t\tWARN_ON_ONCE(lblk_num > U32_MAX);\n\t\tWARN_ON_ONCE(ci->ci_inode->i_ino > U32_MAX);\n\t\tlblk_num |= (u64)ci->ci_inode->i_ino << 32;\n\t} else if (flags & FSCRYPT_POLICY_FLAG_IV_INO_LBLK_32) {\n\t\tWARN_ON_ONCE(lblk_num > U32_MAX);\n\t\tlblk_num = (u32)(ci->ci_hashed_ino + lblk_num);\n\t} else if (flags & FSCRYPT_POLICY_FLAG_DIRECT_KEY) {\n\t\tmemcpy(iv->nonce, ci->ci_nonce, FSCRYPT_FILE_NONCE_SIZE);\n\t}\n\tiv->lblk_num = cpu_to_le64(lblk_num);\n}\n\n \nint fscrypt_crypt_block(const struct inode *inode, fscrypt_direction_t rw,\n\t\t\tu64 lblk_num, struct page *src_page,\n\t\t\tstruct page *dest_page, unsigned int len,\n\t\t\tunsigned int offs, gfp_t gfp_flags)\n{\n\tunion fscrypt_iv iv;\n\tstruct skcipher_request *req = NULL;\n\tDECLARE_CRYPTO_WAIT(wait);\n\tstruct scatterlist dst, src;\n\tstruct fscrypt_info *ci = inode->i_crypt_info;\n\tstruct crypto_skcipher *tfm = ci->ci_enc_key.tfm;\n\tint res = 0;\n\n\tif (WARN_ON_ONCE(len <= 0))\n\t\treturn -EINVAL;\n\tif (WARN_ON_ONCE(len % FSCRYPT_CONTENTS_ALIGNMENT != 0))\n\t\treturn -EINVAL;\n\n\tfscrypt_generate_iv(&iv, lblk_num, ci);\n\n\treq = skcipher_request_alloc(tfm, gfp_flags);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\tskcipher_request_set_callback(\n\t\treq, CRYPTO_TFM_REQ_MAY_BACKLOG | CRYPTO_TFM_REQ_MAY_SLEEP,\n\t\tcrypto_req_done, &wait);\n\n\tsg_init_table(&dst, 1);\n\tsg_set_page(&dst, dest_page, len, offs);\n\tsg_init_table(&src, 1);\n\tsg_set_page(&src, src_page, len, offs);\n\tskcipher_request_set_crypt(req, &src, &dst, len, &iv);\n\tif (rw == FS_DECRYPT)\n\t\tres = crypto_wait_req(crypto_skcipher_decrypt(req), &wait);\n\telse\n\t\tres = crypto_wait_req(crypto_skcipher_encrypt(req), &wait);\n\tskcipher_request_free(req);\n\tif (res) {\n\t\tfscrypt_err(inode, \"%scryption failed for block %llu: %d\",\n\t\t\t    (rw == FS_DECRYPT ? \"De\" : \"En\"), lblk_num, res);\n\t\treturn res;\n\t}\n\treturn 0;\n}\n\n \nstruct page *fscrypt_encrypt_pagecache_blocks(struct page *page,\n\t\t\t\t\t      unsigned int len,\n\t\t\t\t\t      unsigned int offs,\n\t\t\t\t\t      gfp_t gfp_flags)\n\n{\n\tconst struct inode *inode = page->mapping->host;\n\tconst unsigned int blockbits = inode->i_blkbits;\n\tconst unsigned int blocksize = 1 << blockbits;\n\tstruct page *ciphertext_page;\n\tu64 lblk_num = ((u64)page->index << (PAGE_SHIFT - blockbits)) +\n\t\t       (offs >> blockbits);\n\tunsigned int i;\n\tint err;\n\n\tif (WARN_ON_ONCE(!PageLocked(page)))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (WARN_ON_ONCE(len <= 0 || !IS_ALIGNED(len | offs, blocksize)))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tciphertext_page = fscrypt_alloc_bounce_page(gfp_flags);\n\tif (!ciphertext_page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (i = offs; i < offs + len; i += blocksize, lblk_num++) {\n\t\terr = fscrypt_crypt_block(inode, FS_ENCRYPT, lblk_num,\n\t\t\t\t\t  page, ciphertext_page,\n\t\t\t\t\t  blocksize, i, gfp_flags);\n\t\tif (err) {\n\t\t\tfscrypt_free_bounce_page(ciphertext_page);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\t}\n\tSetPagePrivate(ciphertext_page);\n\tset_page_private(ciphertext_page, (unsigned long)page);\n\treturn ciphertext_page;\n}\nEXPORT_SYMBOL(fscrypt_encrypt_pagecache_blocks);\n\n \nint fscrypt_encrypt_block_inplace(const struct inode *inode, struct page *page,\n\t\t\t\t  unsigned int len, unsigned int offs,\n\t\t\t\t  u64 lblk_num, gfp_t gfp_flags)\n{\n\treturn fscrypt_crypt_block(inode, FS_ENCRYPT, lblk_num, page, page,\n\t\t\t\t   len, offs, gfp_flags);\n}\nEXPORT_SYMBOL(fscrypt_encrypt_block_inplace);\n\n \nint fscrypt_decrypt_pagecache_blocks(struct folio *folio, size_t len,\n\t\t\t\t     size_t offs)\n{\n\tconst struct inode *inode = folio->mapping->host;\n\tconst unsigned int blockbits = inode->i_blkbits;\n\tconst unsigned int blocksize = 1 << blockbits;\n\tu64 lblk_num = ((u64)folio->index << (PAGE_SHIFT - blockbits)) +\n\t\t       (offs >> blockbits);\n\tsize_t i;\n\tint err;\n\n\tif (WARN_ON_ONCE(!folio_test_locked(folio)))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON_ONCE(len <= 0 || !IS_ALIGNED(len | offs, blocksize)))\n\t\treturn -EINVAL;\n\n\tfor (i = offs; i < offs + len; i += blocksize, lblk_num++) {\n\t\tstruct page *page = folio_page(folio, i >> PAGE_SHIFT);\n\n\t\terr = fscrypt_crypt_block(inode, FS_DECRYPT, lblk_num, page,\n\t\t\t\t\t  page, blocksize, i & ~PAGE_MASK,\n\t\t\t\t\t  GFP_NOFS);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(fscrypt_decrypt_pagecache_blocks);\n\n \nint fscrypt_decrypt_block_inplace(const struct inode *inode, struct page *page,\n\t\t\t\t  unsigned int len, unsigned int offs,\n\t\t\t\t  u64 lblk_num)\n{\n\treturn fscrypt_crypt_block(inode, FS_DECRYPT, lblk_num, page, page,\n\t\t\t\t   len, offs, GFP_NOFS);\n}\nEXPORT_SYMBOL(fscrypt_decrypt_block_inplace);\n\n \nint fscrypt_initialize(struct super_block *sb)\n{\n\tint err = 0;\n\tmempool_t *pool;\n\n\t \n\tif (likely(smp_load_acquire(&fscrypt_bounce_page_pool)))\n\t\treturn 0;\n\n\t \n\tif (sb->s_cop->flags & FS_CFLG_OWN_PAGES)\n\t\treturn 0;\n\n\tmutex_lock(&fscrypt_init_mutex);\n\tif (fscrypt_bounce_page_pool)\n\t\tgoto out_unlock;\n\n\terr = -ENOMEM;\n\tpool = mempool_create_page_pool(num_prealloc_crypto_pages, 0);\n\tif (!pool)\n\t\tgoto out_unlock;\n\t \n\tsmp_store_release(&fscrypt_bounce_page_pool, pool);\n\terr = 0;\nout_unlock:\n\tmutex_unlock(&fscrypt_init_mutex);\n\treturn err;\n}\n\nvoid fscrypt_msg(const struct inode *inode, const char *level,\n\t\t const char *fmt, ...)\n{\n\tstatic DEFINE_RATELIMIT_STATE(rs, DEFAULT_RATELIMIT_INTERVAL,\n\t\t\t\t      DEFAULT_RATELIMIT_BURST);\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!__ratelimit(&rs))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (inode && inode->i_ino)\n\t\tprintk(\"%sfscrypt (%s, inode %lu): %pV\\n\",\n\t\t       level, inode->i_sb->s_id, inode->i_ino, &vaf);\n\telse if (inode)\n\t\tprintk(\"%sfscrypt (%s): %pV\\n\", level, inode->i_sb->s_id, &vaf);\n\telse\n\t\tprintk(\"%sfscrypt: %pV\\n\", level, &vaf);\n\tva_end(args);\n}\n\n \nstatic int __init fscrypt_init(void)\n{\n\tint err = -ENOMEM;\n\n\t \n\tfscrypt_read_workqueue = alloc_workqueue(\"fscrypt_read_queue\",\n\t\t\t\t\t\t WQ_UNBOUND | WQ_HIGHPRI,\n\t\t\t\t\t\t num_online_cpus());\n\tif (!fscrypt_read_workqueue)\n\t\tgoto fail;\n\n\tfscrypt_info_cachep = KMEM_CACHE(fscrypt_info, SLAB_RECLAIM_ACCOUNT);\n\tif (!fscrypt_info_cachep)\n\t\tgoto fail_free_queue;\n\n\terr = fscrypt_init_keyring();\n\tif (err)\n\t\tgoto fail_free_info;\n\n\treturn 0;\n\nfail_free_info:\n\tkmem_cache_destroy(fscrypt_info_cachep);\nfail_free_queue:\n\tdestroy_workqueue(fscrypt_read_workqueue);\nfail:\n\treturn err;\n}\nlate_initcall(fscrypt_init)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}