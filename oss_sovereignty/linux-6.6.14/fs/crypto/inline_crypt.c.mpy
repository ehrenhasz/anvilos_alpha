{
  "module_name": "inline_crypt.c",
  "hash_id": "85f22f001e25d327d2cdc7bde86483db20903fbd07fe0b17e914ab397d23075b",
  "original_prompt": "Ingested from linux-6.6.14/fs/crypto/inline_crypt.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/blk-crypto.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/sched/mm.h>\n#include <linux/slab.h>\n#include <linux/uio.h>\n\n#include \"fscrypt_private.h\"\n\nstatic struct block_device **fscrypt_get_devices(struct super_block *sb,\n\t\t\t\t\t\t unsigned int *num_devs)\n{\n\tstruct block_device **devs;\n\n\tif (sb->s_cop->get_devices) {\n\t\tdevs = sb->s_cop->get_devices(sb, num_devs);\n\t\tif (devs)\n\t\t\treturn devs;\n\t}\n\tdevs = kmalloc(sizeof(*devs), GFP_KERNEL);\n\tif (!devs)\n\t\treturn ERR_PTR(-ENOMEM);\n\tdevs[0] = sb->s_bdev;\n\t*num_devs = 1;\n\treturn devs;\n}\n\nstatic unsigned int fscrypt_get_dun_bytes(const struct fscrypt_info *ci)\n{\n\tstruct super_block *sb = ci->ci_inode->i_sb;\n\tunsigned int flags = fscrypt_policy_flags(&ci->ci_policy);\n\tint ino_bits = 64, lblk_bits = 64;\n\n\tif (flags & FSCRYPT_POLICY_FLAG_DIRECT_KEY)\n\t\treturn offsetofend(union fscrypt_iv, nonce);\n\n\tif (flags & FSCRYPT_POLICY_FLAG_IV_INO_LBLK_64)\n\t\treturn sizeof(__le64);\n\n\tif (flags & FSCRYPT_POLICY_FLAG_IV_INO_LBLK_32)\n\t\treturn sizeof(__le32);\n\n\t \n\tif (sb->s_cop->get_ino_and_lblk_bits)\n\t\tsb->s_cop->get_ino_and_lblk_bits(sb, &ino_bits, &lblk_bits);\n\treturn DIV_ROUND_UP(lblk_bits, 8);\n}\n\n \nstatic void fscrypt_log_blk_crypto_impl(struct fscrypt_mode *mode,\n\t\t\t\t\tstruct block_device **devs,\n\t\t\t\t\tunsigned int num_devs,\n\t\t\t\t\tconst struct blk_crypto_config *cfg)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < num_devs; i++) {\n\t\tif (!IS_ENABLED(CONFIG_BLK_INLINE_ENCRYPTION_FALLBACK) ||\n\t\t    blk_crypto_config_supported_natively(devs[i], cfg)) {\n\t\t\tif (!xchg(&mode->logged_blk_crypto_native, 1))\n\t\t\t\tpr_info(\"fscrypt: %s using blk-crypto (native)\\n\",\n\t\t\t\t\tmode->friendly_name);\n\t\t} else if (!xchg(&mode->logged_blk_crypto_fallback, 1)) {\n\t\t\tpr_info(\"fscrypt: %s using blk-crypto-fallback\\n\",\n\t\t\t\tmode->friendly_name);\n\t\t}\n\t}\n}\n\n \nint fscrypt_select_encryption_impl(struct fscrypt_info *ci)\n{\n\tconst struct inode *inode = ci->ci_inode;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct blk_crypto_config crypto_cfg;\n\tstruct block_device **devs;\n\tunsigned int num_devs;\n\tunsigned int i;\n\n\t \n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 0;\n\n\t \n\tif (ci->ci_mode->blk_crypto_mode == BLK_ENCRYPTION_MODE_INVALID)\n\t\treturn 0;\n\n\t \n\tif (!(sb->s_flags & SB_INLINECRYPT))\n\t\treturn 0;\n\n\t \n\tif ((fscrypt_policy_flags(&ci->ci_policy) &\n\t     FSCRYPT_POLICY_FLAG_IV_INO_LBLK_32) &&\n\t    sb->s_blocksize != PAGE_SIZE)\n\t\treturn 0;\n\n\t \n\tcrypto_cfg.crypto_mode = ci->ci_mode->blk_crypto_mode;\n\tcrypto_cfg.data_unit_size = sb->s_blocksize;\n\tcrypto_cfg.dun_bytes = fscrypt_get_dun_bytes(ci);\n\n\tdevs = fscrypt_get_devices(sb, &num_devs);\n\tif (IS_ERR(devs))\n\t\treturn PTR_ERR(devs);\n\n\tfor (i = 0; i < num_devs; i++) {\n\t\tif (!blk_crypto_config_supported(devs[i], &crypto_cfg))\n\t\t\tgoto out_free_devs;\n\t}\n\n\tfscrypt_log_blk_crypto_impl(ci->ci_mode, devs, num_devs, &crypto_cfg);\n\n\tci->ci_inlinecrypt = true;\nout_free_devs:\n\tkfree(devs);\n\n\treturn 0;\n}\n\nint fscrypt_prepare_inline_crypt_key(struct fscrypt_prepared_key *prep_key,\n\t\t\t\t     const u8 *raw_key,\n\t\t\t\t     const struct fscrypt_info *ci)\n{\n\tconst struct inode *inode = ci->ci_inode;\n\tstruct super_block *sb = inode->i_sb;\n\tenum blk_crypto_mode_num crypto_mode = ci->ci_mode->blk_crypto_mode;\n\tstruct blk_crypto_key *blk_key;\n\tstruct block_device **devs;\n\tunsigned int num_devs;\n\tunsigned int i;\n\tint err;\n\n\tblk_key = kmalloc(sizeof(*blk_key), GFP_KERNEL);\n\tif (!blk_key)\n\t\treturn -ENOMEM;\n\n\terr = blk_crypto_init_key(blk_key, raw_key, crypto_mode,\n\t\t\t\t  fscrypt_get_dun_bytes(ci), sb->s_blocksize);\n\tif (err) {\n\t\tfscrypt_err(inode, \"error %d initializing blk-crypto key\", err);\n\t\tgoto fail;\n\t}\n\n\t \n\tdevs = fscrypt_get_devices(sb, &num_devs);\n\tif (IS_ERR(devs)) {\n\t\terr = PTR_ERR(devs);\n\t\tgoto fail;\n\t}\n\tfor (i = 0; i < num_devs; i++) {\n\t\terr = blk_crypto_start_using_key(devs[i], blk_key);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\tkfree(devs);\n\tif (err) {\n\t\tfscrypt_err(inode, \"error %d starting to use blk-crypto\", err);\n\t\tgoto fail;\n\t}\n\n\t \n\tsmp_store_release(&prep_key->blk_key, blk_key);\n\treturn 0;\n\nfail:\n\tkfree_sensitive(blk_key);\n\treturn err;\n}\n\nvoid fscrypt_destroy_inline_crypt_key(struct super_block *sb,\n\t\t\t\t      struct fscrypt_prepared_key *prep_key)\n{\n\tstruct blk_crypto_key *blk_key = prep_key->blk_key;\n\tstruct block_device **devs;\n\tunsigned int num_devs;\n\tunsigned int i;\n\n\tif (!blk_key)\n\t\treturn;\n\n\t \n\tdevs = fscrypt_get_devices(sb, &num_devs);\n\tif (!IS_ERR(devs)) {\n\t\tfor (i = 0; i < num_devs; i++)\n\t\t\tblk_crypto_evict_key(devs[i], blk_key);\n\t\tkfree(devs);\n\t}\n\tkfree_sensitive(blk_key);\n}\n\nbool __fscrypt_inode_uses_inline_crypto(const struct inode *inode)\n{\n\treturn inode->i_crypt_info->ci_inlinecrypt;\n}\nEXPORT_SYMBOL_GPL(__fscrypt_inode_uses_inline_crypto);\n\nstatic void fscrypt_generate_dun(const struct fscrypt_info *ci, u64 lblk_num,\n\t\t\t\t u64 dun[BLK_CRYPTO_DUN_ARRAY_SIZE])\n{\n\tunion fscrypt_iv iv;\n\tint i;\n\n\tfscrypt_generate_iv(&iv, lblk_num, ci);\n\n\tBUILD_BUG_ON(FSCRYPT_MAX_IV_SIZE > BLK_CRYPTO_MAX_IV_SIZE);\n\tmemset(dun, 0, BLK_CRYPTO_MAX_IV_SIZE);\n\tfor (i = 0; i < ci->ci_mode->ivsize/sizeof(dun[0]); i++)\n\t\tdun[i] = le64_to_cpu(iv.dun[i]);\n}\n\n \nvoid fscrypt_set_bio_crypt_ctx(struct bio *bio, const struct inode *inode,\n\t\t\t       u64 first_lblk, gfp_t gfp_mask)\n{\n\tconst struct fscrypt_info *ci;\n\tu64 dun[BLK_CRYPTO_DUN_ARRAY_SIZE];\n\n\tif (!fscrypt_inode_uses_inline_crypto(inode))\n\t\treturn;\n\tci = inode->i_crypt_info;\n\n\tfscrypt_generate_dun(ci, first_lblk, dun);\n\tbio_crypt_set_ctx(bio, ci->ci_enc_key.blk_key, dun, gfp_mask);\n}\nEXPORT_SYMBOL_GPL(fscrypt_set_bio_crypt_ctx);\n\n \nstatic bool bh_get_inode_and_lblk_num(const struct buffer_head *bh,\n\t\t\t\t      const struct inode **inode_ret,\n\t\t\t\t      u64 *lblk_num_ret)\n{\n\tstruct page *page = bh->b_page;\n\tconst struct address_space *mapping;\n\tconst struct inode *inode;\n\n\t \n\tmapping = page_mapping(page);\n\tif (!mapping)\n\t\treturn false;\n\tinode = mapping->host;\n\n\t*inode_ret = inode;\n\t*lblk_num_ret = ((u64)page->index << (PAGE_SHIFT - inode->i_blkbits)) +\n\t\t\t(bh_offset(bh) >> inode->i_blkbits);\n\treturn true;\n}\n\n \nvoid fscrypt_set_bio_crypt_ctx_bh(struct bio *bio,\n\t\t\t\t  const struct buffer_head *first_bh,\n\t\t\t\t  gfp_t gfp_mask)\n{\n\tconst struct inode *inode;\n\tu64 first_lblk;\n\n\tif (bh_get_inode_and_lblk_num(first_bh, &inode, &first_lblk))\n\t\tfscrypt_set_bio_crypt_ctx(bio, inode, first_lblk, gfp_mask);\n}\nEXPORT_SYMBOL_GPL(fscrypt_set_bio_crypt_ctx_bh);\n\n \nbool fscrypt_mergeable_bio(struct bio *bio, const struct inode *inode,\n\t\t\t   u64 next_lblk)\n{\n\tconst struct bio_crypt_ctx *bc = bio->bi_crypt_context;\n\tu64 next_dun[BLK_CRYPTO_DUN_ARRAY_SIZE];\n\n\tif (!!bc != fscrypt_inode_uses_inline_crypto(inode))\n\t\treturn false;\n\tif (!bc)\n\t\treturn true;\n\n\t \n\tif (bc->bc_key != inode->i_crypt_info->ci_enc_key.blk_key)\n\t\treturn false;\n\n\tfscrypt_generate_dun(inode->i_crypt_info, next_lblk, next_dun);\n\treturn bio_crypt_dun_is_contiguous(bc, bio->bi_iter.bi_size, next_dun);\n}\nEXPORT_SYMBOL_GPL(fscrypt_mergeable_bio);\n\n \nbool fscrypt_mergeable_bio_bh(struct bio *bio,\n\t\t\t      const struct buffer_head *next_bh)\n{\n\tconst struct inode *inode;\n\tu64 next_lblk;\n\n\tif (!bh_get_inode_and_lblk_num(next_bh, &inode, &next_lblk))\n\t\treturn !bio->bi_crypt_context;\n\n\treturn fscrypt_mergeable_bio(bio, inode, next_lblk);\n}\nEXPORT_SYMBOL_GPL(fscrypt_mergeable_bio_bh);\n\n \nbool fscrypt_dio_supported(struct inode *inode)\n{\n\tint err;\n\n\t \n\tif (!fscrypt_needs_contents_encryption(inode))\n\t\treturn true;\n\n\t \n\terr = fscrypt_require_key(inode);\n\tif (err) {\n\t\t \n\t\treturn false;\n\t}\n\treturn fscrypt_inode_uses_inline_crypto(inode);\n}\nEXPORT_SYMBOL_GPL(fscrypt_dio_supported);\n\n \nu64 fscrypt_limit_io_blocks(const struct inode *inode, u64 lblk, u64 nr_blocks)\n{\n\tconst struct fscrypt_info *ci;\n\tu32 dun;\n\n\tif (!fscrypt_inode_uses_inline_crypto(inode))\n\t\treturn nr_blocks;\n\n\tif (nr_blocks <= 1)\n\t\treturn nr_blocks;\n\n\tci = inode->i_crypt_info;\n\tif (!(fscrypt_policy_flags(&ci->ci_policy) &\n\t      FSCRYPT_POLICY_FLAG_IV_INO_LBLK_32))\n\t\treturn nr_blocks;\n\n\t \n\n\tdun = ci->ci_hashed_ino + lblk;\n\n\treturn min_t(u64, nr_blocks, (u64)U32_MAX + 1 - dun);\n}\nEXPORT_SYMBOL_GPL(fscrypt_limit_io_blocks);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}