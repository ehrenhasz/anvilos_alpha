{
  "module_name": "keyring.c",
  "hash_id": "1b08c89190f5b5a8fae77310ca2c3afb7b639aa6a9826241cafa977ac7c96eb8",
  "original_prompt": "Ingested from linux-6.6.14/fs/crypto/keyring.c",
  "human_readable_source": "\n \n\n \n\n#include <asm/unaligned.h>\n#include <crypto/skcipher.h>\n#include <linux/key-type.h>\n#include <linux/random.h>\n#include <linux/seq_file.h>\n\n#include \"fscrypt_private.h\"\n\n \nstruct fscrypt_keyring {\n\t \n\tspinlock_t lock;\n\n\t \n\tstruct hlist_head key_hashtable[128];\n};\n\nstatic void wipe_master_key_secret(struct fscrypt_master_key_secret *secret)\n{\n\tfscrypt_destroy_hkdf(&secret->hkdf);\n\tmemzero_explicit(secret, sizeof(*secret));\n}\n\nstatic void move_master_key_secret(struct fscrypt_master_key_secret *dst,\n\t\t\t\t   struct fscrypt_master_key_secret *src)\n{\n\tmemcpy(dst, src, sizeof(*dst));\n\tmemzero_explicit(src, sizeof(*src));\n}\n\nstatic void fscrypt_free_master_key(struct rcu_head *head)\n{\n\tstruct fscrypt_master_key *mk =\n\t\tcontainer_of(head, struct fscrypt_master_key, mk_rcu_head);\n\t \n\tkfree_sensitive(mk);\n}\n\nvoid fscrypt_put_master_key(struct fscrypt_master_key *mk)\n{\n\tif (!refcount_dec_and_test(&mk->mk_struct_refs))\n\t\treturn;\n\t \n\tWARN_ON_ONCE(refcount_read(&mk->mk_active_refs) != 0);\n\tkey_put(mk->mk_users);\n\tmk->mk_users = NULL;\n\tcall_rcu(&mk->mk_rcu_head, fscrypt_free_master_key);\n}\n\nvoid fscrypt_put_master_key_activeref(struct super_block *sb,\n\t\t\t\t      struct fscrypt_master_key *mk)\n{\n\tsize_t i;\n\n\tif (!refcount_dec_and_test(&mk->mk_active_refs))\n\t\treturn;\n\t \n\n\tif (WARN_ON_ONCE(!sb->s_master_keys))\n\t\treturn;\n\tspin_lock(&sb->s_master_keys->lock);\n\thlist_del_rcu(&mk->mk_node);\n\tspin_unlock(&sb->s_master_keys->lock);\n\n\t \n\tWARN_ON_ONCE(is_master_key_secret_present(&mk->mk_secret));\n\tWARN_ON_ONCE(!list_empty(&mk->mk_decrypted_inodes));\n\n\tfor (i = 0; i <= FSCRYPT_MODE_MAX; i++) {\n\t\tfscrypt_destroy_prepared_key(\n\t\t\t\tsb, &mk->mk_direct_keys[i]);\n\t\tfscrypt_destroy_prepared_key(\n\t\t\t\tsb, &mk->mk_iv_ino_lblk_64_keys[i]);\n\t\tfscrypt_destroy_prepared_key(\n\t\t\t\tsb, &mk->mk_iv_ino_lblk_32_keys[i]);\n\t}\n\tmemzero_explicit(&mk->mk_ino_hash_key,\n\t\t\t sizeof(mk->mk_ino_hash_key));\n\tmk->mk_ino_hash_key_initialized = false;\n\n\t \n\tfscrypt_put_master_key(mk);\n}\n\nstatic inline bool valid_key_spec(const struct fscrypt_key_specifier *spec)\n{\n\tif (spec->__reserved)\n\t\treturn false;\n\treturn master_key_spec_len(spec) != 0;\n}\n\nstatic int fscrypt_user_key_instantiate(struct key *key,\n\t\t\t\t\tstruct key_preparsed_payload *prep)\n{\n\t \n\treturn key_payload_reserve(key, FSCRYPT_MAX_KEY_SIZE);\n}\n\nstatic void fscrypt_user_key_describe(const struct key *key, struct seq_file *m)\n{\n\tseq_puts(m, key->description);\n}\n\n \nstatic struct key_type key_type_fscrypt_user = {\n\t.name\t\t\t= \".fscrypt\",\n\t.instantiate\t\t= fscrypt_user_key_instantiate,\n\t.describe\t\t= fscrypt_user_key_describe,\n};\n\n#define FSCRYPT_MK_USERS_DESCRIPTION_SIZE\t\\\n\t(CONST_STRLEN(\"fscrypt-\") + 2 * FSCRYPT_KEY_IDENTIFIER_SIZE + \\\n\t CONST_STRLEN(\"-users\") + 1)\n\n#define FSCRYPT_MK_USER_DESCRIPTION_SIZE\t\\\n\t(2 * FSCRYPT_KEY_IDENTIFIER_SIZE + CONST_STRLEN(\".uid.\") + 10 + 1)\n\nstatic void format_mk_users_keyring_description(\n\t\t\tchar description[FSCRYPT_MK_USERS_DESCRIPTION_SIZE],\n\t\t\tconst u8 mk_identifier[FSCRYPT_KEY_IDENTIFIER_SIZE])\n{\n\tsprintf(description, \"fscrypt-%*phN-users\",\n\t\tFSCRYPT_KEY_IDENTIFIER_SIZE, mk_identifier);\n}\n\nstatic void format_mk_user_description(\n\t\t\tchar description[FSCRYPT_MK_USER_DESCRIPTION_SIZE],\n\t\t\tconst u8 mk_identifier[FSCRYPT_KEY_IDENTIFIER_SIZE])\n{\n\n\tsprintf(description, \"%*phN.uid.%u\", FSCRYPT_KEY_IDENTIFIER_SIZE,\n\t\tmk_identifier, __kuid_val(current_fsuid()));\n}\n\n \nstatic int allocate_filesystem_keyring(struct super_block *sb)\n{\n\tstruct fscrypt_keyring *keyring;\n\n\tif (sb->s_master_keys)\n\t\treturn 0;\n\n\tkeyring = kzalloc(sizeof(*keyring), GFP_KERNEL);\n\tif (!keyring)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&keyring->lock);\n\t \n\tsmp_store_release(&sb->s_master_keys, keyring);\n\treturn 0;\n}\n\n \nvoid fscrypt_destroy_keyring(struct super_block *sb)\n{\n\tstruct fscrypt_keyring *keyring = sb->s_master_keys;\n\tsize_t i;\n\n\tif (!keyring)\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(keyring->key_hashtable); i++) {\n\t\tstruct hlist_head *bucket = &keyring->key_hashtable[i];\n\t\tstruct fscrypt_master_key *mk;\n\t\tstruct hlist_node *tmp;\n\n\t\thlist_for_each_entry_safe(mk, tmp, bucket, mk_node) {\n\t\t\t \n\t\t\tWARN_ON_ONCE(refcount_read(&mk->mk_active_refs) != 1);\n\t\t\tWARN_ON_ONCE(refcount_read(&mk->mk_struct_refs) != 1);\n\t\t\tWARN_ON_ONCE(!is_master_key_secret_present(&mk->mk_secret));\n\t\t\twipe_master_key_secret(&mk->mk_secret);\n\t\t\tfscrypt_put_master_key_activeref(sb, mk);\n\t\t}\n\t}\n\tkfree_sensitive(keyring);\n\tsb->s_master_keys = NULL;\n}\n\nstatic struct hlist_head *\nfscrypt_mk_hash_bucket(struct fscrypt_keyring *keyring,\n\t\t       const struct fscrypt_key_specifier *mk_spec)\n{\n\t \n\tunsigned long i = get_unaligned((unsigned long *)&mk_spec->u);\n\n\treturn &keyring->key_hashtable[i % ARRAY_SIZE(keyring->key_hashtable)];\n}\n\n \nstruct fscrypt_master_key *\nfscrypt_find_master_key(struct super_block *sb,\n\t\t\tconst struct fscrypt_key_specifier *mk_spec)\n{\n\tstruct fscrypt_keyring *keyring;\n\tstruct hlist_head *bucket;\n\tstruct fscrypt_master_key *mk;\n\n\t \n\tkeyring = smp_load_acquire(&sb->s_master_keys);\n\tif (keyring == NULL)\n\t\treturn NULL;  \n\n\tbucket = fscrypt_mk_hash_bucket(keyring, mk_spec);\n\trcu_read_lock();\n\tswitch (mk_spec->type) {\n\tcase FSCRYPT_KEY_SPEC_TYPE_DESCRIPTOR:\n\t\thlist_for_each_entry_rcu(mk, bucket, mk_node) {\n\t\t\tif (mk->mk_spec.type ==\n\t\t\t\tFSCRYPT_KEY_SPEC_TYPE_DESCRIPTOR &&\n\t\t\t    memcmp(mk->mk_spec.u.descriptor,\n\t\t\t\t   mk_spec->u.descriptor,\n\t\t\t\t   FSCRYPT_KEY_DESCRIPTOR_SIZE) == 0 &&\n\t\t\t    refcount_inc_not_zero(&mk->mk_struct_refs))\n\t\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase FSCRYPT_KEY_SPEC_TYPE_IDENTIFIER:\n\t\thlist_for_each_entry_rcu(mk, bucket, mk_node) {\n\t\t\tif (mk->mk_spec.type ==\n\t\t\t\tFSCRYPT_KEY_SPEC_TYPE_IDENTIFIER &&\n\t\t\t    memcmp(mk->mk_spec.u.identifier,\n\t\t\t\t   mk_spec->u.identifier,\n\t\t\t\t   FSCRYPT_KEY_IDENTIFIER_SIZE) == 0 &&\n\t\t\t    refcount_inc_not_zero(&mk->mk_struct_refs))\n\t\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\t}\n\tmk = NULL;\nout:\n\trcu_read_unlock();\n\treturn mk;\n}\n\nstatic int allocate_master_key_users_keyring(struct fscrypt_master_key *mk)\n{\n\tchar description[FSCRYPT_MK_USERS_DESCRIPTION_SIZE];\n\tstruct key *keyring;\n\n\tformat_mk_users_keyring_description(description,\n\t\t\t\t\t    mk->mk_spec.u.identifier);\n\tkeyring = keyring_alloc(description, GLOBAL_ROOT_UID, GLOBAL_ROOT_GID,\n\t\t\t\tcurrent_cred(), KEY_POS_SEARCH |\n\t\t\t\t  KEY_USR_SEARCH | KEY_USR_READ | KEY_USR_VIEW,\n\t\t\t\tKEY_ALLOC_NOT_IN_QUOTA, NULL, NULL);\n\tif (IS_ERR(keyring))\n\t\treturn PTR_ERR(keyring);\n\n\tmk->mk_users = keyring;\n\treturn 0;\n}\n\n \nstatic struct key *find_master_key_user(struct fscrypt_master_key *mk)\n{\n\tchar description[FSCRYPT_MK_USER_DESCRIPTION_SIZE];\n\tkey_ref_t keyref;\n\n\tformat_mk_user_description(description, mk->mk_spec.u.identifier);\n\n\t \n\tkeyref = keyring_search(make_key_ref(mk->mk_users, true  ),\n\t\t\t\t&key_type_fscrypt_user, description, false);\n\tif (IS_ERR(keyref)) {\n\t\tif (PTR_ERR(keyref) == -EAGAIN ||  \n\t\t    PTR_ERR(keyref) == -EKEYREVOKED)  \n\t\t\tkeyref = ERR_PTR(-ENOKEY);\n\t\treturn ERR_CAST(keyref);\n\t}\n\treturn key_ref_to_ptr(keyref);\n}\n\n \nstatic int add_master_key_user(struct fscrypt_master_key *mk)\n{\n\tchar description[FSCRYPT_MK_USER_DESCRIPTION_SIZE];\n\tstruct key *mk_user;\n\tint err;\n\n\tformat_mk_user_description(description, mk->mk_spec.u.identifier);\n\tmk_user = key_alloc(&key_type_fscrypt_user, description,\n\t\t\t    current_fsuid(), current_gid(), current_cred(),\n\t\t\t    KEY_POS_SEARCH | KEY_USR_VIEW, 0, NULL);\n\tif (IS_ERR(mk_user))\n\t\treturn PTR_ERR(mk_user);\n\n\terr = key_instantiate_and_link(mk_user, NULL, 0, mk->mk_users, NULL);\n\tkey_put(mk_user);\n\treturn err;\n}\n\n \nstatic int remove_master_key_user(struct fscrypt_master_key *mk)\n{\n\tstruct key *mk_user;\n\tint err;\n\n\tmk_user = find_master_key_user(mk);\n\tif (IS_ERR(mk_user))\n\t\treturn PTR_ERR(mk_user);\n\terr = key_unlink(mk->mk_users, mk_user);\n\tkey_put(mk_user);\n\treturn err;\n}\n\n \nstatic int add_new_master_key(struct super_block *sb,\n\t\t\t      struct fscrypt_master_key_secret *secret,\n\t\t\t      const struct fscrypt_key_specifier *mk_spec)\n{\n\tstruct fscrypt_keyring *keyring = sb->s_master_keys;\n\tstruct fscrypt_master_key *mk;\n\tint err;\n\n\tmk = kzalloc(sizeof(*mk), GFP_KERNEL);\n\tif (!mk)\n\t\treturn -ENOMEM;\n\n\tinit_rwsem(&mk->mk_sem);\n\trefcount_set(&mk->mk_struct_refs, 1);\n\tmk->mk_spec = *mk_spec;\n\n\tINIT_LIST_HEAD(&mk->mk_decrypted_inodes);\n\tspin_lock_init(&mk->mk_decrypted_inodes_lock);\n\n\tif (mk_spec->type == FSCRYPT_KEY_SPEC_TYPE_IDENTIFIER) {\n\t\terr = allocate_master_key_users_keyring(mk);\n\t\tif (err)\n\t\t\tgoto out_put;\n\t\terr = add_master_key_user(mk);\n\t\tif (err)\n\t\t\tgoto out_put;\n\t}\n\n\tmove_master_key_secret(&mk->mk_secret, secret);\n\trefcount_set(&mk->mk_active_refs, 1);  \n\n\tspin_lock(&keyring->lock);\n\thlist_add_head_rcu(&mk->mk_node,\n\t\t\t   fscrypt_mk_hash_bucket(keyring, mk_spec));\n\tspin_unlock(&keyring->lock);\n\treturn 0;\n\nout_put:\n\tfscrypt_put_master_key(mk);\n\treturn err;\n}\n\n#define KEY_DEAD\t1\n\nstatic int add_existing_master_key(struct fscrypt_master_key *mk,\n\t\t\t\t   struct fscrypt_master_key_secret *secret)\n{\n\tint err;\n\n\t \n\tif (mk->mk_users) {\n\t\tstruct key *mk_user = find_master_key_user(mk);\n\n\t\tif (mk_user != ERR_PTR(-ENOKEY)) {\n\t\t\tif (IS_ERR(mk_user))\n\t\t\t\treturn PTR_ERR(mk_user);\n\t\t\tkey_put(mk_user);\n\t\t\treturn 0;\n\t\t}\n\t\terr = add_master_key_user(mk);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tif (!is_master_key_secret_present(&mk->mk_secret)) {\n\t\tif (!refcount_inc_not_zero(&mk->mk_active_refs))\n\t\t\treturn KEY_DEAD;\n\t\tmove_master_key_secret(&mk->mk_secret, secret);\n\t}\n\n\treturn 0;\n}\n\nstatic int do_add_master_key(struct super_block *sb,\n\t\t\t     struct fscrypt_master_key_secret *secret,\n\t\t\t     const struct fscrypt_key_specifier *mk_spec)\n{\n\tstatic DEFINE_MUTEX(fscrypt_add_key_mutex);\n\tstruct fscrypt_master_key *mk;\n\tint err;\n\n\tmutex_lock(&fscrypt_add_key_mutex);  \n\n\tmk = fscrypt_find_master_key(sb, mk_spec);\n\tif (!mk) {\n\t\t \n\t\terr = allocate_filesystem_keyring(sb);\n\t\tif (!err)\n\t\t\terr = add_new_master_key(sb, secret, mk_spec);\n\t} else {\n\t\t \n\t\tdown_write(&mk->mk_sem);\n\t\terr = add_existing_master_key(mk, secret);\n\t\tup_write(&mk->mk_sem);\n\t\tif (err == KEY_DEAD) {\n\t\t\t \n\t\t\terr = add_new_master_key(sb, secret, mk_spec);\n\t\t}\n\t\tfscrypt_put_master_key(mk);\n\t}\n\tmutex_unlock(&fscrypt_add_key_mutex);\n\treturn err;\n}\n\nstatic int add_master_key(struct super_block *sb,\n\t\t\t  struct fscrypt_master_key_secret *secret,\n\t\t\t  struct fscrypt_key_specifier *key_spec)\n{\n\tint err;\n\n\tif (key_spec->type == FSCRYPT_KEY_SPEC_TYPE_IDENTIFIER) {\n\t\terr = fscrypt_init_hkdf(&secret->hkdf, secret->raw,\n\t\t\t\t\tsecret->size);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t \n\t\tmemzero_explicit(secret->raw, secret->size);\n\n\t\t \n\t\terr = fscrypt_hkdf_expand(&secret->hkdf,\n\t\t\t\t\t  HKDF_CONTEXT_KEY_IDENTIFIER, NULL, 0,\n\t\t\t\t\t  key_spec->u.identifier,\n\t\t\t\t\t  FSCRYPT_KEY_IDENTIFIER_SIZE);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn do_add_master_key(sb, secret, key_spec);\n}\n\nstatic int fscrypt_provisioning_key_preparse(struct key_preparsed_payload *prep)\n{\n\tconst struct fscrypt_provisioning_key_payload *payload = prep->data;\n\n\tif (prep->datalen < sizeof(*payload) + FSCRYPT_MIN_KEY_SIZE ||\n\t    prep->datalen > sizeof(*payload) + FSCRYPT_MAX_KEY_SIZE)\n\t\treturn -EINVAL;\n\n\tif (payload->type != FSCRYPT_KEY_SPEC_TYPE_DESCRIPTOR &&\n\t    payload->type != FSCRYPT_KEY_SPEC_TYPE_IDENTIFIER)\n\t\treturn -EINVAL;\n\n\tif (payload->__reserved)\n\t\treturn -EINVAL;\n\n\tprep->payload.data[0] = kmemdup(payload, prep->datalen, GFP_KERNEL);\n\tif (!prep->payload.data[0])\n\t\treturn -ENOMEM;\n\n\tprep->quotalen = prep->datalen;\n\treturn 0;\n}\n\nstatic void fscrypt_provisioning_key_free_preparse(\n\t\t\t\t\tstruct key_preparsed_payload *prep)\n{\n\tkfree_sensitive(prep->payload.data[0]);\n}\n\nstatic void fscrypt_provisioning_key_describe(const struct key *key,\n\t\t\t\t\t      struct seq_file *m)\n{\n\tseq_puts(m, key->description);\n\tif (key_is_positive(key)) {\n\t\tconst struct fscrypt_provisioning_key_payload *payload =\n\t\t\tkey->payload.data[0];\n\n\t\tseq_printf(m, \": %u [%u]\", key->datalen, payload->type);\n\t}\n}\n\nstatic void fscrypt_provisioning_key_destroy(struct key *key)\n{\n\tkfree_sensitive(key->payload.data[0]);\n}\n\nstatic struct key_type key_type_fscrypt_provisioning = {\n\t.name\t\t\t= \"fscrypt-provisioning\",\n\t.preparse\t\t= fscrypt_provisioning_key_preparse,\n\t.free_preparse\t\t= fscrypt_provisioning_key_free_preparse,\n\t.instantiate\t\t= generic_key_instantiate,\n\t.describe\t\t= fscrypt_provisioning_key_describe,\n\t.destroy\t\t= fscrypt_provisioning_key_destroy,\n};\n\n \nstatic int get_keyring_key(u32 key_id, u32 type,\n\t\t\t   struct fscrypt_master_key_secret *secret)\n{\n\tkey_ref_t ref;\n\tstruct key *key;\n\tconst struct fscrypt_provisioning_key_payload *payload;\n\tint err;\n\n\tref = lookup_user_key(key_id, 0, KEY_NEED_SEARCH);\n\tif (IS_ERR(ref))\n\t\treturn PTR_ERR(ref);\n\tkey = key_ref_to_ptr(ref);\n\n\tif (key->type != &key_type_fscrypt_provisioning)\n\t\tgoto bad_key;\n\tpayload = key->payload.data[0];\n\n\t \n\tif (payload->type != type)\n\t\tgoto bad_key;\n\n\tsecret->size = key->datalen - sizeof(*payload);\n\tmemcpy(secret->raw, payload->raw, secret->size);\n\terr = 0;\n\tgoto out_put;\n\nbad_key:\n\terr = -EKEYREJECTED;\nout_put:\n\tkey_ref_put(ref);\n\treturn err;\n}\n\n \nint fscrypt_ioctl_add_key(struct file *filp, void __user *_uarg)\n{\n\tstruct super_block *sb = file_inode(filp)->i_sb;\n\tstruct fscrypt_add_key_arg __user *uarg = _uarg;\n\tstruct fscrypt_add_key_arg arg;\n\tstruct fscrypt_master_key_secret secret;\n\tint err;\n\n\tif (copy_from_user(&arg, uarg, sizeof(arg)))\n\t\treturn -EFAULT;\n\n\tif (!valid_key_spec(&arg.key_spec))\n\t\treturn -EINVAL;\n\n\tif (memchr_inv(arg.__reserved, 0, sizeof(arg.__reserved)))\n\t\treturn -EINVAL;\n\n\t \n\tif (arg.key_spec.type == FSCRYPT_KEY_SPEC_TYPE_DESCRIPTOR &&\n\t    !capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\n\tmemset(&secret, 0, sizeof(secret));\n\tif (arg.key_id) {\n\t\tif (arg.raw_size != 0)\n\t\t\treturn -EINVAL;\n\t\terr = get_keyring_key(arg.key_id, arg.key_spec.type, &secret);\n\t\tif (err)\n\t\t\tgoto out_wipe_secret;\n\t} else {\n\t\tif (arg.raw_size < FSCRYPT_MIN_KEY_SIZE ||\n\t\t    arg.raw_size > FSCRYPT_MAX_KEY_SIZE)\n\t\t\treturn -EINVAL;\n\t\tsecret.size = arg.raw_size;\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(secret.raw, uarg->raw, secret.size))\n\t\t\tgoto out_wipe_secret;\n\t}\n\n\terr = add_master_key(sb, &secret, &arg.key_spec);\n\tif (err)\n\t\tgoto out_wipe_secret;\n\n\t \n\terr = -EFAULT;\n\tif (arg.key_spec.type == FSCRYPT_KEY_SPEC_TYPE_IDENTIFIER &&\n\t    copy_to_user(uarg->key_spec.u.identifier, arg.key_spec.u.identifier,\n\t\t\t FSCRYPT_KEY_IDENTIFIER_SIZE))\n\t\tgoto out_wipe_secret;\n\terr = 0;\nout_wipe_secret:\n\twipe_master_key_secret(&secret);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(fscrypt_ioctl_add_key);\n\nstatic void\nfscrypt_get_test_dummy_secret(struct fscrypt_master_key_secret *secret)\n{\n\tstatic u8 test_key[FSCRYPT_MAX_KEY_SIZE];\n\n\tget_random_once(test_key, FSCRYPT_MAX_KEY_SIZE);\n\n\tmemset(secret, 0, sizeof(*secret));\n\tsecret->size = FSCRYPT_MAX_KEY_SIZE;\n\tmemcpy(secret->raw, test_key, FSCRYPT_MAX_KEY_SIZE);\n}\n\nint fscrypt_get_test_dummy_key_identifier(\n\t\t\t\tu8 key_identifier[FSCRYPT_KEY_IDENTIFIER_SIZE])\n{\n\tstruct fscrypt_master_key_secret secret;\n\tint err;\n\n\tfscrypt_get_test_dummy_secret(&secret);\n\n\terr = fscrypt_init_hkdf(&secret.hkdf, secret.raw, secret.size);\n\tif (err)\n\t\tgoto out;\n\terr = fscrypt_hkdf_expand(&secret.hkdf, HKDF_CONTEXT_KEY_IDENTIFIER,\n\t\t\t\t  NULL, 0, key_identifier,\n\t\t\t\t  FSCRYPT_KEY_IDENTIFIER_SIZE);\nout:\n\twipe_master_key_secret(&secret);\n\treturn err;\n}\n\n \nint fscrypt_add_test_dummy_key(struct super_block *sb,\n\t\t\t       struct fscrypt_key_specifier *key_spec)\n{\n\tstruct fscrypt_master_key_secret secret;\n\tint err;\n\n\tfscrypt_get_test_dummy_secret(&secret);\n\terr = add_master_key(sb, &secret, key_spec);\n\twipe_master_key_secret(&secret);\n\treturn err;\n}\n\n \nint fscrypt_verify_key_added(struct super_block *sb,\n\t\t\t     const u8 identifier[FSCRYPT_KEY_IDENTIFIER_SIZE])\n{\n\tstruct fscrypt_key_specifier mk_spec;\n\tstruct fscrypt_master_key *mk;\n\tstruct key *mk_user;\n\tint err;\n\n\tmk_spec.type = FSCRYPT_KEY_SPEC_TYPE_IDENTIFIER;\n\tmemcpy(mk_spec.u.identifier, identifier, FSCRYPT_KEY_IDENTIFIER_SIZE);\n\n\tmk = fscrypt_find_master_key(sb, &mk_spec);\n\tif (!mk) {\n\t\terr = -ENOKEY;\n\t\tgoto out;\n\t}\n\tdown_read(&mk->mk_sem);\n\tmk_user = find_master_key_user(mk);\n\tif (IS_ERR(mk_user)) {\n\t\terr = PTR_ERR(mk_user);\n\t} else {\n\t\tkey_put(mk_user);\n\t\terr = 0;\n\t}\n\tup_read(&mk->mk_sem);\n\tfscrypt_put_master_key(mk);\nout:\n\tif (err == -ENOKEY && capable(CAP_FOWNER))\n\t\terr = 0;\n\treturn err;\n}\n\n \nstatic void shrink_dcache_inode(struct inode *inode)\n{\n\tstruct dentry *dentry;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tdentry = d_find_any_alias(inode);\n\t\tif (dentry) {\n\t\t\tshrink_dcache_parent(dentry);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n\td_prune_aliases(inode);\n}\n\nstatic void evict_dentries_for_decrypted_inodes(struct fscrypt_master_key *mk)\n{\n\tstruct fscrypt_info *ci;\n\tstruct inode *inode;\n\tstruct inode *toput_inode = NULL;\n\n\tspin_lock(&mk->mk_decrypted_inodes_lock);\n\n\tlist_for_each_entry(ci, &mk->mk_decrypted_inodes, ci_master_key_link) {\n\t\tinode = ci->ci_inode;\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_FREEING | I_WILL_FREE | I_NEW)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tcontinue;\n\t\t}\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\tspin_unlock(&mk->mk_decrypted_inodes_lock);\n\n\t\tshrink_dcache_inode(inode);\n\t\tiput(toput_inode);\n\t\ttoput_inode = inode;\n\n\t\tspin_lock(&mk->mk_decrypted_inodes_lock);\n\t}\n\n\tspin_unlock(&mk->mk_decrypted_inodes_lock);\n\tiput(toput_inode);\n}\n\nstatic int check_for_busy_inodes(struct super_block *sb,\n\t\t\t\t struct fscrypt_master_key *mk)\n{\n\tstruct list_head *pos;\n\tsize_t busy_count = 0;\n\tunsigned long ino;\n\tchar ino_str[50] = \"\";\n\n\tspin_lock(&mk->mk_decrypted_inodes_lock);\n\n\tlist_for_each(pos, &mk->mk_decrypted_inodes)\n\t\tbusy_count++;\n\n\tif (busy_count == 0) {\n\t\tspin_unlock(&mk->mk_decrypted_inodes_lock);\n\t\treturn 0;\n\t}\n\n\t{\n\t\t \n\t\tstruct inode *inode =\n\t\t\tlist_first_entry(&mk->mk_decrypted_inodes,\n\t\t\t\t\t struct fscrypt_info,\n\t\t\t\t\t ci_master_key_link)->ci_inode;\n\t\tino = inode->i_ino;\n\t}\n\tspin_unlock(&mk->mk_decrypted_inodes_lock);\n\n\t \n\tif (ino)\n\t\tsnprintf(ino_str, sizeof(ino_str), \", including ino %lu\", ino);\n\n\tfscrypt_warn(NULL,\n\t\t     \"%s: %zu inode(s) still busy after removing key with %s %*phN%s\",\n\t\t     sb->s_id, busy_count, master_key_spec_type(&mk->mk_spec),\n\t\t     master_key_spec_len(&mk->mk_spec), (u8 *)&mk->mk_spec.u,\n\t\t     ino_str);\n\treturn -EBUSY;\n}\n\nstatic int try_to_lock_encrypted_files(struct super_block *sb,\n\t\t\t\t       struct fscrypt_master_key *mk)\n{\n\tint err1;\n\tint err2;\n\n\t \n\tdown_read(&sb->s_umount);\n\terr1 = sync_filesystem(sb);\n\tup_read(&sb->s_umount);\n\t \n\n\t \n\tevict_dentries_for_decrypted_inodes(mk);\n\n\t \n\terr2 = check_for_busy_inodes(sb, mk);\n\n\treturn err1 ?: err2;\n}\n\n \nstatic int do_remove_key(struct file *filp, void __user *_uarg, bool all_users)\n{\n\tstruct super_block *sb = file_inode(filp)->i_sb;\n\tstruct fscrypt_remove_key_arg __user *uarg = _uarg;\n\tstruct fscrypt_remove_key_arg arg;\n\tstruct fscrypt_master_key *mk;\n\tu32 status_flags = 0;\n\tint err;\n\tbool inodes_remain;\n\n\tif (copy_from_user(&arg, uarg, sizeof(arg)))\n\t\treturn -EFAULT;\n\n\tif (!valid_key_spec(&arg.key_spec))\n\t\treturn -EINVAL;\n\n\tif (memchr_inv(arg.__reserved, 0, sizeof(arg.__reserved)))\n\t\treturn -EINVAL;\n\n\t \n\tif (arg.key_spec.type == FSCRYPT_KEY_SPEC_TYPE_DESCRIPTOR &&\n\t    !capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\n\t \n\tmk = fscrypt_find_master_key(sb, &arg.key_spec);\n\tif (!mk)\n\t\treturn -ENOKEY;\n\tdown_write(&mk->mk_sem);\n\n\t \n\tif (mk->mk_users && mk->mk_users->keys.nr_leaves_on_tree != 0) {\n\t\tif (all_users)\n\t\t\terr = keyring_clear(mk->mk_users);\n\t\telse\n\t\t\terr = remove_master_key_user(mk);\n\t\tif (err) {\n\t\t\tup_write(&mk->mk_sem);\n\t\t\tgoto out_put_key;\n\t\t}\n\t\tif (mk->mk_users->keys.nr_leaves_on_tree != 0) {\n\t\t\t \n\t\t\tstatus_flags |=\n\t\t\t\tFSCRYPT_KEY_REMOVAL_STATUS_FLAG_OTHER_USERS;\n\t\t\terr = 0;\n\t\t\tup_write(&mk->mk_sem);\n\t\t\tgoto out_put_key;\n\t\t}\n\t}\n\n\t \n\terr = -ENOKEY;\n\tif (is_master_key_secret_present(&mk->mk_secret)) {\n\t\twipe_master_key_secret(&mk->mk_secret);\n\t\tfscrypt_put_master_key_activeref(sb, mk);\n\t\terr = 0;\n\t}\n\tinodes_remain = refcount_read(&mk->mk_active_refs) > 0;\n\tup_write(&mk->mk_sem);\n\n\tif (inodes_remain) {\n\t\t \n\t\terr = try_to_lock_encrypted_files(sb, mk);\n\t\tif (err == -EBUSY) {\n\t\t\tstatus_flags |=\n\t\t\t\tFSCRYPT_KEY_REMOVAL_STATUS_FLAG_FILES_BUSY;\n\t\t\terr = 0;\n\t\t}\n\t}\n\t \nout_put_key:\n\tfscrypt_put_master_key(mk);\n\tif (err == 0)\n\t\terr = put_user(status_flags, &uarg->removal_status_flags);\n\treturn err;\n}\n\nint fscrypt_ioctl_remove_key(struct file *filp, void __user *uarg)\n{\n\treturn do_remove_key(filp, uarg, false);\n}\nEXPORT_SYMBOL_GPL(fscrypt_ioctl_remove_key);\n\nint fscrypt_ioctl_remove_key_all_users(struct file *filp, void __user *uarg)\n{\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\treturn do_remove_key(filp, uarg, true);\n}\nEXPORT_SYMBOL_GPL(fscrypt_ioctl_remove_key_all_users);\n\n \nint fscrypt_ioctl_get_key_status(struct file *filp, void __user *uarg)\n{\n\tstruct super_block *sb = file_inode(filp)->i_sb;\n\tstruct fscrypt_get_key_status_arg arg;\n\tstruct fscrypt_master_key *mk;\n\tint err;\n\n\tif (copy_from_user(&arg, uarg, sizeof(arg)))\n\t\treturn -EFAULT;\n\n\tif (!valid_key_spec(&arg.key_spec))\n\t\treturn -EINVAL;\n\n\tif (memchr_inv(arg.__reserved, 0, sizeof(arg.__reserved)))\n\t\treturn -EINVAL;\n\n\targ.status_flags = 0;\n\targ.user_count = 0;\n\tmemset(arg.__out_reserved, 0, sizeof(arg.__out_reserved));\n\n\tmk = fscrypt_find_master_key(sb, &arg.key_spec);\n\tif (!mk) {\n\t\targ.status = FSCRYPT_KEY_STATUS_ABSENT;\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\tdown_read(&mk->mk_sem);\n\n\tif (!is_master_key_secret_present(&mk->mk_secret)) {\n\t\targ.status = refcount_read(&mk->mk_active_refs) > 0 ?\n\t\t\tFSCRYPT_KEY_STATUS_INCOMPLETELY_REMOVED :\n\t\t\tFSCRYPT_KEY_STATUS_ABSENT  ;\n\t\terr = 0;\n\t\tgoto out_release_key;\n\t}\n\n\targ.status = FSCRYPT_KEY_STATUS_PRESENT;\n\tif (mk->mk_users) {\n\t\tstruct key *mk_user;\n\n\t\targ.user_count = mk->mk_users->keys.nr_leaves_on_tree;\n\t\tmk_user = find_master_key_user(mk);\n\t\tif (!IS_ERR(mk_user)) {\n\t\t\targ.status_flags |=\n\t\t\t\tFSCRYPT_KEY_STATUS_FLAG_ADDED_BY_SELF;\n\t\t\tkey_put(mk_user);\n\t\t} else if (mk_user != ERR_PTR(-ENOKEY)) {\n\t\t\terr = PTR_ERR(mk_user);\n\t\t\tgoto out_release_key;\n\t\t}\n\t}\n\terr = 0;\nout_release_key:\n\tup_read(&mk->mk_sem);\n\tfscrypt_put_master_key(mk);\nout:\n\tif (!err && copy_to_user(uarg, &arg, sizeof(arg)))\n\t\terr = -EFAULT;\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(fscrypt_ioctl_get_key_status);\n\nint __init fscrypt_init_keyring(void)\n{\n\tint err;\n\n\terr = register_key_type(&key_type_fscrypt_user);\n\tif (err)\n\t\treturn err;\n\n\terr = register_key_type(&key_type_fscrypt_provisioning);\n\tif (err)\n\t\tgoto err_unregister_fscrypt_user;\n\n\treturn 0;\n\nerr_unregister_fscrypt_user:\n\tunregister_key_type(&key_type_fscrypt_user);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}