{
  "module_name": "keysetup_v1.c",
  "hash_id": "da40bbb2348cfeb5ef70f244905b1fba7e8b4ff3e3f44d6fdacb036b449549cc",
  "original_prompt": "Ingested from linux-6.6.14/fs/crypto/keysetup_v1.c",
  "human_readable_source": "\n \n\n \n\n#include <crypto/algapi.h>\n#include <crypto/skcipher.h>\n#include <keys/user-type.h>\n#include <linux/hashtable.h>\n#include <linux/scatterlist.h>\n\n#include \"fscrypt_private.h\"\n\n \nstatic DEFINE_HASHTABLE(fscrypt_direct_keys, 6);  \nstatic DEFINE_SPINLOCK(fscrypt_direct_keys_lock);\n\n \nstatic int derive_key_aes(const u8 *master_key,\n\t\t\t  const u8 nonce[FSCRYPT_FILE_NONCE_SIZE],\n\t\t\t  u8 *derived_key, unsigned int derived_keysize)\n{\n\tint res = 0;\n\tstruct skcipher_request *req = NULL;\n\tDECLARE_CRYPTO_WAIT(wait);\n\tstruct scatterlist src_sg, dst_sg;\n\tstruct crypto_skcipher *tfm = crypto_alloc_skcipher(\"ecb(aes)\", 0, 0);\n\n\tif (IS_ERR(tfm)) {\n\t\tres = PTR_ERR(tfm);\n\t\ttfm = NULL;\n\t\tgoto out;\n\t}\n\tcrypto_skcipher_set_flags(tfm, CRYPTO_TFM_REQ_FORBID_WEAK_KEYS);\n\treq = skcipher_request_alloc(tfm, GFP_KERNEL);\n\tif (!req) {\n\t\tres = -ENOMEM;\n\t\tgoto out;\n\t}\n\tskcipher_request_set_callback(req,\n\t\t\tCRYPTO_TFM_REQ_MAY_BACKLOG | CRYPTO_TFM_REQ_MAY_SLEEP,\n\t\t\tcrypto_req_done, &wait);\n\tres = crypto_skcipher_setkey(tfm, nonce, FSCRYPT_FILE_NONCE_SIZE);\n\tif (res < 0)\n\t\tgoto out;\n\n\tsg_init_one(&src_sg, master_key, derived_keysize);\n\tsg_init_one(&dst_sg, derived_key, derived_keysize);\n\tskcipher_request_set_crypt(req, &src_sg, &dst_sg, derived_keysize,\n\t\t\t\t   NULL);\n\tres = crypto_wait_req(crypto_skcipher_encrypt(req), &wait);\nout:\n\tskcipher_request_free(req);\n\tcrypto_free_skcipher(tfm);\n\treturn res;\n}\n\n \nstatic struct key *\nfind_and_lock_process_key(const char *prefix,\n\t\t\t  const u8 descriptor[FSCRYPT_KEY_DESCRIPTOR_SIZE],\n\t\t\t  unsigned int min_keysize,\n\t\t\t  const struct fscrypt_key **payload_ret)\n{\n\tchar *description;\n\tstruct key *key;\n\tconst struct user_key_payload *ukp;\n\tconst struct fscrypt_key *payload;\n\n\tdescription = kasprintf(GFP_KERNEL, \"%s%*phN\", prefix,\n\t\t\t\tFSCRYPT_KEY_DESCRIPTOR_SIZE, descriptor);\n\tif (!description)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tkey = request_key(&key_type_logon, description, NULL);\n\tkfree(description);\n\tif (IS_ERR(key))\n\t\treturn key;\n\n\tdown_read(&key->sem);\n\tukp = user_key_payload_locked(key);\n\n\tif (!ukp)  \n\t\tgoto invalid;\n\n\tpayload = (const struct fscrypt_key *)ukp->data;\n\n\tif (ukp->datalen != sizeof(struct fscrypt_key) ||\n\t    payload->size < 1 || payload->size > FSCRYPT_MAX_KEY_SIZE) {\n\t\tfscrypt_warn(NULL,\n\t\t\t     \"key with description '%s' has invalid payload\",\n\t\t\t     key->description);\n\t\tgoto invalid;\n\t}\n\n\tif (payload->size < min_keysize) {\n\t\tfscrypt_warn(NULL,\n\t\t\t     \"key with description '%s' is too short (got %u bytes, need %u+ bytes)\",\n\t\t\t     key->description, payload->size, min_keysize);\n\t\tgoto invalid;\n\t}\n\n\t*payload_ret = payload;\n\treturn key;\n\ninvalid:\n\tup_read(&key->sem);\n\tkey_put(key);\n\treturn ERR_PTR(-ENOKEY);\n}\n\n \nstruct fscrypt_direct_key {\n\tstruct super_block\t\t*dk_sb;\n\tstruct hlist_node\t\tdk_node;\n\trefcount_t\t\t\tdk_refcount;\n\tconst struct fscrypt_mode\t*dk_mode;\n\tstruct fscrypt_prepared_key\tdk_key;\n\tu8\t\t\t\tdk_descriptor[FSCRYPT_KEY_DESCRIPTOR_SIZE];\n\tu8\t\t\t\tdk_raw[FSCRYPT_MAX_KEY_SIZE];\n};\n\nstatic void free_direct_key(struct fscrypt_direct_key *dk)\n{\n\tif (dk) {\n\t\tfscrypt_destroy_prepared_key(dk->dk_sb, &dk->dk_key);\n\t\tkfree_sensitive(dk);\n\t}\n}\n\nvoid fscrypt_put_direct_key(struct fscrypt_direct_key *dk)\n{\n\tif (!refcount_dec_and_lock(&dk->dk_refcount, &fscrypt_direct_keys_lock))\n\t\treturn;\n\thash_del(&dk->dk_node);\n\tspin_unlock(&fscrypt_direct_keys_lock);\n\n\tfree_direct_key(dk);\n}\n\n \nstatic struct fscrypt_direct_key *\nfind_or_insert_direct_key(struct fscrypt_direct_key *to_insert,\n\t\t\t  const u8 *raw_key, const struct fscrypt_info *ci)\n{\n\tunsigned long hash_key;\n\tstruct fscrypt_direct_key *dk;\n\n\t \n\n\tBUILD_BUG_ON(sizeof(hash_key) > FSCRYPT_KEY_DESCRIPTOR_SIZE);\n\tmemcpy(&hash_key, ci->ci_policy.v1.master_key_descriptor,\n\t       sizeof(hash_key));\n\n\tspin_lock(&fscrypt_direct_keys_lock);\n\thash_for_each_possible(fscrypt_direct_keys, dk, dk_node, hash_key) {\n\t\tif (memcmp(ci->ci_policy.v1.master_key_descriptor,\n\t\t\t   dk->dk_descriptor, FSCRYPT_KEY_DESCRIPTOR_SIZE) != 0)\n\t\t\tcontinue;\n\t\tif (ci->ci_mode != dk->dk_mode)\n\t\t\tcontinue;\n\t\tif (!fscrypt_is_key_prepared(&dk->dk_key, ci))\n\t\t\tcontinue;\n\t\tif (crypto_memneq(raw_key, dk->dk_raw, ci->ci_mode->keysize))\n\t\t\tcontinue;\n\t\t \n\t\trefcount_inc(&dk->dk_refcount);\n\t\tspin_unlock(&fscrypt_direct_keys_lock);\n\t\tfree_direct_key(to_insert);\n\t\treturn dk;\n\t}\n\tif (to_insert)\n\t\thash_add(fscrypt_direct_keys, &to_insert->dk_node, hash_key);\n\tspin_unlock(&fscrypt_direct_keys_lock);\n\treturn to_insert;\n}\n\n \nstatic struct fscrypt_direct_key *\nfscrypt_get_direct_key(const struct fscrypt_info *ci, const u8 *raw_key)\n{\n\tstruct fscrypt_direct_key *dk;\n\tint err;\n\n\t \n\tdk = find_or_insert_direct_key(NULL, raw_key, ci);\n\tif (dk)\n\t\treturn dk;\n\n\t \n\tdk = kzalloc(sizeof(*dk), GFP_KERNEL);\n\tif (!dk)\n\t\treturn ERR_PTR(-ENOMEM);\n\tdk->dk_sb = ci->ci_inode->i_sb;\n\trefcount_set(&dk->dk_refcount, 1);\n\tdk->dk_mode = ci->ci_mode;\n\terr = fscrypt_prepare_key(&dk->dk_key, raw_key, ci);\n\tif (err)\n\t\tgoto err_free_dk;\n\tmemcpy(dk->dk_descriptor, ci->ci_policy.v1.master_key_descriptor,\n\t       FSCRYPT_KEY_DESCRIPTOR_SIZE);\n\tmemcpy(dk->dk_raw, raw_key, ci->ci_mode->keysize);\n\n\treturn find_or_insert_direct_key(dk, raw_key, ci);\n\nerr_free_dk:\n\tfree_direct_key(dk);\n\treturn ERR_PTR(err);\n}\n\n \nstatic int setup_v1_file_key_direct(struct fscrypt_info *ci,\n\t\t\t\t    const u8 *raw_master_key)\n{\n\tstruct fscrypt_direct_key *dk;\n\n\tdk = fscrypt_get_direct_key(ci, raw_master_key);\n\tif (IS_ERR(dk))\n\t\treturn PTR_ERR(dk);\n\tci->ci_direct_key = dk;\n\tci->ci_enc_key = dk->dk_key;\n\treturn 0;\n}\n\n \nstatic int setup_v1_file_key_derived(struct fscrypt_info *ci,\n\t\t\t\t     const u8 *raw_master_key)\n{\n\tu8 *derived_key;\n\tint err;\n\n\t \n\tderived_key = kmalloc(ci->ci_mode->keysize, GFP_KERNEL);\n\tif (!derived_key)\n\t\treturn -ENOMEM;\n\n\terr = derive_key_aes(raw_master_key, ci->ci_nonce,\n\t\t\t     derived_key, ci->ci_mode->keysize);\n\tif (err)\n\t\tgoto out;\n\n\terr = fscrypt_set_per_file_enc_key(ci, derived_key);\nout:\n\tkfree_sensitive(derived_key);\n\treturn err;\n}\n\nint fscrypt_setup_v1_file_key(struct fscrypt_info *ci, const u8 *raw_master_key)\n{\n\tif (ci->ci_policy.v1.flags & FSCRYPT_POLICY_FLAG_DIRECT_KEY)\n\t\treturn setup_v1_file_key_direct(ci, raw_master_key);\n\telse\n\t\treturn setup_v1_file_key_derived(ci, raw_master_key);\n}\n\nint fscrypt_setup_v1_file_key_via_subscribed_keyrings(struct fscrypt_info *ci)\n{\n\tstruct key *key;\n\tconst struct fscrypt_key *payload;\n\tint err;\n\n\tkey = find_and_lock_process_key(FSCRYPT_KEY_DESC_PREFIX,\n\t\t\t\t\tci->ci_policy.v1.master_key_descriptor,\n\t\t\t\t\tci->ci_mode->keysize, &payload);\n\tif (key == ERR_PTR(-ENOKEY) && ci->ci_inode->i_sb->s_cop->key_prefix) {\n\t\tkey = find_and_lock_process_key(ci->ci_inode->i_sb->s_cop->key_prefix,\n\t\t\t\t\t\tci->ci_policy.v1.master_key_descriptor,\n\t\t\t\t\t\tci->ci_mode->keysize, &payload);\n\t}\n\tif (IS_ERR(key))\n\t\treturn PTR_ERR(key);\n\n\terr = fscrypt_setup_v1_file_key(ci, payload->raw);\n\tup_read(&key->sem);\n\tkey_put(key);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}