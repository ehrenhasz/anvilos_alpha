{
  "module_name": "bio.c",
  "hash_id": "89f740e74c96587a38f80d90d72b89c03a7f606aeeb389f6cc4c3be4481fee28",
  "original_prompt": "Ingested from linux-6.6.14/fs/crypto/bio.c",
  "human_readable_source": "\n \n\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/bio.h>\n#include <linux/namei.h>\n#include \"fscrypt_private.h\"\n\n \nbool fscrypt_decrypt_bio(struct bio *bio)\n{\n\tstruct folio_iter fi;\n\n\tbio_for_each_folio_all(fi, bio) {\n\t\tint err = fscrypt_decrypt_pagecache_blocks(fi.folio, fi.length,\n\t\t\t\t\t\t\t   fi.offset);\n\n\t\tif (err) {\n\t\t\tbio->bi_status = errno_to_blk_status(err);\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nEXPORT_SYMBOL(fscrypt_decrypt_bio);\n\nstatic int fscrypt_zeroout_range_inline_crypt(const struct inode *inode,\n\t\t\t\t\t      pgoff_t lblk, sector_t pblk,\n\t\t\t\t\t      unsigned int len)\n{\n\tconst unsigned int blockbits = inode->i_blkbits;\n\tconst unsigned int blocks_per_page = 1 << (PAGE_SHIFT - blockbits);\n\tstruct bio *bio;\n\tint ret, err = 0;\n\tint num_pages = 0;\n\n\t \n\tbio = bio_alloc(inode->i_sb->s_bdev, BIO_MAX_VECS, REQ_OP_WRITE,\n\t\t\tGFP_NOFS);\n\n\twhile (len) {\n\t\tunsigned int blocks_this_page = min(len, blocks_per_page);\n\t\tunsigned int bytes_this_page = blocks_this_page << blockbits;\n\n\t\tif (num_pages == 0) {\n\t\t\tfscrypt_set_bio_crypt_ctx(bio, inode, lblk, GFP_NOFS);\n\t\t\tbio->bi_iter.bi_sector =\n\t\t\t\t\tpblk << (blockbits - SECTOR_SHIFT);\n\t\t}\n\t\tret = bio_add_page(bio, ZERO_PAGE(0), bytes_this_page, 0);\n\t\tif (WARN_ON_ONCE(ret != bytes_this_page)) {\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tnum_pages++;\n\t\tlen -= blocks_this_page;\n\t\tlblk += blocks_this_page;\n\t\tpblk += blocks_this_page;\n\t\tif (num_pages == BIO_MAX_VECS || !len ||\n\t\t    !fscrypt_mergeable_bio(bio, inode, lblk)) {\n\t\t\terr = submit_bio_wait(bio);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tbio_reset(bio, inode->i_sb->s_bdev, REQ_OP_WRITE);\n\t\t\tnum_pages = 0;\n\t\t}\n\t}\nout:\n\tbio_put(bio);\n\treturn err;\n}\n\n \nint fscrypt_zeroout_range(const struct inode *inode, pgoff_t lblk,\n\t\t\t  sector_t pblk, unsigned int len)\n{\n\tconst unsigned int blockbits = inode->i_blkbits;\n\tconst unsigned int blocksize = 1 << blockbits;\n\tconst unsigned int blocks_per_page_bits = PAGE_SHIFT - blockbits;\n\tconst unsigned int blocks_per_page = 1 << blocks_per_page_bits;\n\tstruct page *pages[16];  \n\tunsigned int nr_pages;\n\tunsigned int i;\n\tunsigned int offset;\n\tstruct bio *bio;\n\tint ret, err;\n\n\tif (len == 0)\n\t\treturn 0;\n\n\tif (fscrypt_inode_uses_inline_crypto(inode))\n\t\treturn fscrypt_zeroout_range_inline_crypt(inode, lblk, pblk,\n\t\t\t\t\t\t\t  len);\n\n\tBUILD_BUG_ON(ARRAY_SIZE(pages) > BIO_MAX_VECS);\n\tnr_pages = min_t(unsigned int, ARRAY_SIZE(pages),\n\t\t\t (len + blocks_per_page - 1) >> blocks_per_page_bits);\n\n\t \n\tfor (i = 0; i < nr_pages; i++) {\n\t\tpages[i] = fscrypt_alloc_bounce_page(i == 0 ? GFP_NOFS :\n\t\t\t\t\t\t     GFP_NOWAIT | __GFP_NOWARN);\n\t\tif (!pages[i])\n\t\t\tbreak;\n\t}\n\tnr_pages = i;\n\tif (WARN_ON_ONCE(nr_pages <= 0))\n\t\treturn -EINVAL;\n\n\t \n\tbio = bio_alloc(inode->i_sb->s_bdev, nr_pages, REQ_OP_WRITE, GFP_NOFS);\n\n\tdo {\n\t\tbio->bi_iter.bi_sector = pblk << (blockbits - 9);\n\n\t\ti = 0;\n\t\toffset = 0;\n\t\tdo {\n\t\t\terr = fscrypt_crypt_block(inode, FS_ENCRYPT, lblk,\n\t\t\t\t\t\t  ZERO_PAGE(0), pages[i],\n\t\t\t\t\t\t  blocksize, offset, GFP_NOFS);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tlblk++;\n\t\t\tpblk++;\n\t\t\tlen--;\n\t\t\toffset += blocksize;\n\t\t\tif (offset == PAGE_SIZE || len == 0) {\n\t\t\t\tret = bio_add_page(bio, pages[i++], offset, 0);\n\t\t\t\tif (WARN_ON_ONCE(ret != offset)) {\n\t\t\t\t\terr = -EIO;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\toffset = 0;\n\t\t\t}\n\t\t} while (i != nr_pages && len != 0);\n\n\t\terr = submit_bio_wait(bio);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tbio_reset(bio, inode->i_sb->s_bdev, REQ_OP_WRITE);\n\t} while (len != 0);\n\terr = 0;\nout:\n\tbio_put(bio);\n\tfor (i = 0; i < nr_pages; i++)\n\t\tfscrypt_free_bounce_page(pages[i]);\n\treturn err;\n}\nEXPORT_SYMBOL(fscrypt_zeroout_range);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}