{
  "module_name": "util.c",
  "hash_id": "6d58aa833ab52a292a2e479a238c904b7c654722473e28cdc2e45db8bf47fbed",
  "original_prompt": "Ingested from linux-6.6.14/fs/overlayfs/util.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/xattr.h>\n#include <linux/exportfs.h>\n#include <linux/file.h>\n#include <linux/fileattr.h>\n#include <linux/uuid.h>\n#include <linux/namei.h>\n#include <linux/ratelimit.h>\n#include \"overlayfs.h\"\n\nint ovl_want_write(struct dentry *dentry)\n{\n\tstruct ovl_fs *ofs = OVL_FS(dentry->d_sb);\n\treturn mnt_want_write(ovl_upper_mnt(ofs));\n}\n\nvoid ovl_drop_write(struct dentry *dentry)\n{\n\tstruct ovl_fs *ofs = OVL_FS(dentry->d_sb);\n\tmnt_drop_write(ovl_upper_mnt(ofs));\n}\n\nstruct dentry *ovl_workdir(struct dentry *dentry)\n{\n\tstruct ovl_fs *ofs = OVL_FS(dentry->d_sb);\n\treturn ofs->workdir;\n}\n\nconst struct cred *ovl_override_creds(struct super_block *sb)\n{\n\tstruct ovl_fs *ofs = OVL_FS(sb);\n\n\treturn override_creds(ofs->creator_cred);\n}\n\n \nint ovl_can_decode_fh(struct super_block *sb)\n{\n\tif (!capable(CAP_DAC_READ_SEARCH))\n\t\treturn 0;\n\n\tif (!sb->s_export_op || !sb->s_export_op->fh_to_dentry)\n\t\treturn 0;\n\n\treturn sb->s_export_op->encode_fh ? -1 : FILEID_INO32_GEN;\n}\n\nstruct dentry *ovl_indexdir(struct super_block *sb)\n{\n\tstruct ovl_fs *ofs = OVL_FS(sb);\n\n\treturn ofs->indexdir;\n}\n\n \nbool ovl_index_all(struct super_block *sb)\n{\n\tstruct ovl_fs *ofs = OVL_FS(sb);\n\n\treturn ofs->config.nfs_export && ofs->config.index;\n}\n\n \nbool ovl_verify_lower(struct super_block *sb)\n{\n\tstruct ovl_fs *ofs = OVL_FS(sb);\n\n\treturn ofs->config.nfs_export && ofs->config.index;\n}\n\nstruct ovl_path *ovl_stack_alloc(unsigned int n)\n{\n\treturn kcalloc(n, sizeof(struct ovl_path), GFP_KERNEL);\n}\n\nvoid ovl_stack_cpy(struct ovl_path *dst, struct ovl_path *src, unsigned int n)\n{\n\tunsigned int i;\n\n\tmemcpy(dst, src, sizeof(struct ovl_path) * n);\n\tfor (i = 0; i < n; i++)\n\t\tdget(src[i].dentry);\n}\n\nvoid ovl_stack_put(struct ovl_path *stack, unsigned int n)\n{\n\tunsigned int i;\n\n\tfor (i = 0; stack && i < n; i++)\n\t\tdput(stack[i].dentry);\n}\n\nvoid ovl_stack_free(struct ovl_path *stack, unsigned int n)\n{\n\tovl_stack_put(stack, n);\n\tkfree(stack);\n}\n\nstruct ovl_entry *ovl_alloc_entry(unsigned int numlower)\n{\n\tsize_t size = offsetof(struct ovl_entry, __lowerstack[numlower]);\n\tstruct ovl_entry *oe = kzalloc(size, GFP_KERNEL);\n\n\tif (oe)\n\t\toe->__numlower = numlower;\n\n\treturn oe;\n}\n\nvoid ovl_free_entry(struct ovl_entry *oe)\n{\n\tovl_stack_put(ovl_lowerstack(oe), ovl_numlower(oe));\n\tkfree(oe);\n}\n\n#define OVL_D_REVALIDATE (DCACHE_OP_REVALIDATE | DCACHE_OP_WEAK_REVALIDATE)\n\nbool ovl_dentry_remote(struct dentry *dentry)\n{\n\treturn dentry->d_flags & OVL_D_REVALIDATE;\n}\n\nvoid ovl_dentry_update_reval(struct dentry *dentry, struct dentry *realdentry)\n{\n\tif (!ovl_dentry_remote(realdentry))\n\t\treturn;\n\n\tspin_lock(&dentry->d_lock);\n\tdentry->d_flags |= realdentry->d_flags & OVL_D_REVALIDATE;\n\tspin_unlock(&dentry->d_lock);\n}\n\nvoid ovl_dentry_init_reval(struct dentry *dentry, struct dentry *upperdentry,\n\t\t\t   struct ovl_entry *oe)\n{\n\treturn ovl_dentry_init_flags(dentry, upperdentry, oe, OVL_D_REVALIDATE);\n}\n\nvoid ovl_dentry_init_flags(struct dentry *dentry, struct dentry *upperdentry,\n\t\t\t   struct ovl_entry *oe, unsigned int mask)\n{\n\tstruct ovl_path *lowerstack = ovl_lowerstack(oe);\n\tunsigned int i, flags = 0;\n\n\tif (upperdentry)\n\t\tflags |= upperdentry->d_flags;\n\tfor (i = 0; i < ovl_numlower(oe) && lowerstack[i].dentry; i++)\n\t\tflags |= lowerstack[i].dentry->d_flags;\n\n\tspin_lock(&dentry->d_lock);\n\tdentry->d_flags &= ~mask;\n\tdentry->d_flags |= flags & mask;\n\tspin_unlock(&dentry->d_lock);\n}\n\nbool ovl_dentry_weird(struct dentry *dentry)\n{\n\treturn dentry->d_flags & (DCACHE_NEED_AUTOMOUNT |\n\t\t\t\t  DCACHE_MANAGE_TRANSIT |\n\t\t\t\t  DCACHE_OP_HASH |\n\t\t\t\t  DCACHE_OP_COMPARE);\n}\n\nenum ovl_path_type ovl_path_type(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = OVL_E(dentry);\n\tenum ovl_path_type type = 0;\n\n\tif (ovl_dentry_upper(dentry)) {\n\t\ttype = __OVL_PATH_UPPER;\n\n\t\t \n\t\tif (ovl_numlower(oe)) {\n\t\t\tif (ovl_test_flag(OVL_CONST_INO, d_inode(dentry)))\n\t\t\t\ttype |= __OVL_PATH_ORIGIN;\n\t\t\tif (d_is_dir(dentry) ||\n\t\t\t    !ovl_has_upperdata(d_inode(dentry)))\n\t\t\t\ttype |= __OVL_PATH_MERGE;\n\t\t}\n\t} else {\n\t\tif (ovl_numlower(oe) > 1)\n\t\t\ttype |= __OVL_PATH_MERGE;\n\t}\n\treturn type;\n}\n\nvoid ovl_path_upper(struct dentry *dentry, struct path *path)\n{\n\tstruct ovl_fs *ofs = OVL_FS(dentry->d_sb);\n\n\tpath->mnt = ovl_upper_mnt(ofs);\n\tpath->dentry = ovl_dentry_upper(dentry);\n}\n\nvoid ovl_path_lower(struct dentry *dentry, struct path *path)\n{\n\tstruct ovl_entry *oe = OVL_E(dentry);\n\tstruct ovl_path *lowerpath = ovl_lowerstack(oe);\n\n\tif (ovl_numlower(oe)) {\n\t\tpath->mnt = lowerpath->layer->mnt;\n\t\tpath->dentry = lowerpath->dentry;\n\t} else {\n\t\t*path = (struct path) { };\n\t}\n}\n\nvoid ovl_path_lowerdata(struct dentry *dentry, struct path *path)\n{\n\tstruct ovl_entry *oe = OVL_E(dentry);\n\tstruct ovl_path *lowerdata = ovl_lowerdata(oe);\n\tstruct dentry *lowerdata_dentry = ovl_lowerdata_dentry(oe);\n\n\tif (lowerdata_dentry) {\n\t\tpath->dentry = lowerdata_dentry;\n\t\t \n\t\tsmp_rmb();\n\t\tpath->mnt = READ_ONCE(lowerdata->layer)->mnt;\n\t} else {\n\t\t*path = (struct path) { };\n\t}\n}\n\nenum ovl_path_type ovl_path_real(struct dentry *dentry, struct path *path)\n{\n\tenum ovl_path_type type = ovl_path_type(dentry);\n\n\tif (!OVL_TYPE_UPPER(type))\n\t\tovl_path_lower(dentry, path);\n\telse\n\t\tovl_path_upper(dentry, path);\n\n\treturn type;\n}\n\nenum ovl_path_type ovl_path_realdata(struct dentry *dentry, struct path *path)\n{\n\tenum ovl_path_type type = ovl_path_type(dentry);\n\n\tWARN_ON_ONCE(d_is_dir(dentry));\n\n\tif (!OVL_TYPE_UPPER(type) || OVL_TYPE_MERGE(type))\n\t\tovl_path_lowerdata(dentry, path);\n\telse\n\t\tovl_path_upper(dentry, path);\n\n\treturn type;\n}\n\nstruct dentry *ovl_dentry_upper(struct dentry *dentry)\n{\n\treturn ovl_upperdentry_dereference(OVL_I(d_inode(dentry)));\n}\n\nstruct dentry *ovl_dentry_lower(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = OVL_E(dentry);\n\n\treturn ovl_numlower(oe) ? ovl_lowerstack(oe)->dentry : NULL;\n}\n\nconst struct ovl_layer *ovl_layer_lower(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = OVL_E(dentry);\n\n\treturn ovl_numlower(oe) ? ovl_lowerstack(oe)->layer : NULL;\n}\n\n \nstruct dentry *ovl_dentry_lowerdata(struct dentry *dentry)\n{\n\treturn ovl_lowerdata_dentry(OVL_E(dentry));\n}\n\nint ovl_dentry_set_lowerdata(struct dentry *dentry, struct ovl_path *datapath)\n{\n\tstruct ovl_entry *oe = OVL_E(dentry);\n\tstruct ovl_path *lowerdata = ovl_lowerdata(oe);\n\tstruct dentry *datadentry = datapath->dentry;\n\n\tif (WARN_ON_ONCE(ovl_numlower(oe) <= 1))\n\t\treturn -EIO;\n\n\tWRITE_ONCE(lowerdata->layer, datapath->layer);\n\t \n\tsmp_wmb();\n\tWRITE_ONCE(lowerdata->dentry, dget(datadentry));\n\n\tovl_dentry_update_reval(dentry, datadentry);\n\n\treturn 0;\n}\n\nstruct dentry *ovl_dentry_real(struct dentry *dentry)\n{\n\treturn ovl_dentry_upper(dentry) ?: ovl_dentry_lower(dentry);\n}\n\nstruct dentry *ovl_i_dentry_upper(struct inode *inode)\n{\n\treturn ovl_upperdentry_dereference(OVL_I(inode));\n}\n\nstruct inode *ovl_i_path_real(struct inode *inode, struct path *path)\n{\n\tstruct ovl_path *lowerpath = ovl_lowerpath(OVL_I_E(inode));\n\n\tpath->dentry = ovl_i_dentry_upper(inode);\n\tif (!path->dentry) {\n\t\tpath->dentry = lowerpath->dentry;\n\t\tpath->mnt = lowerpath->layer->mnt;\n\t} else {\n\t\tpath->mnt = ovl_upper_mnt(OVL_FS(inode->i_sb));\n\t}\n\n\treturn path->dentry ? d_inode_rcu(path->dentry) : NULL;\n}\n\nstruct inode *ovl_inode_upper(struct inode *inode)\n{\n\tstruct dentry *upperdentry = ovl_i_dentry_upper(inode);\n\n\treturn upperdentry ? d_inode(upperdentry) : NULL;\n}\n\nstruct inode *ovl_inode_lower(struct inode *inode)\n{\n\tstruct ovl_path *lowerpath = ovl_lowerpath(OVL_I_E(inode));\n\n\treturn lowerpath ? d_inode(lowerpath->dentry) : NULL;\n}\n\nstruct inode *ovl_inode_real(struct inode *inode)\n{\n\treturn ovl_inode_upper(inode) ?: ovl_inode_lower(inode);\n}\n\n \nstruct inode *ovl_inode_lowerdata(struct inode *inode)\n{\n\tstruct dentry *lowerdata = ovl_lowerdata_dentry(OVL_I_E(inode));\n\n\tif (WARN_ON(!S_ISREG(inode->i_mode)))\n\t\treturn NULL;\n\n\treturn lowerdata ? d_inode(lowerdata) : NULL;\n}\n\n \nstruct inode *ovl_inode_realdata(struct inode *inode)\n{\n\tstruct inode *upperinode;\n\n\tupperinode = ovl_inode_upper(inode);\n\tif (upperinode && ovl_has_upperdata(inode))\n\t\treturn upperinode;\n\n\treturn ovl_inode_lowerdata(inode);\n}\n\nconst char *ovl_lowerdata_redirect(struct inode *inode)\n{\n\treturn inode && S_ISREG(inode->i_mode) ?\n\t\tOVL_I(inode)->lowerdata_redirect : NULL;\n}\n\nstruct ovl_dir_cache *ovl_dir_cache(struct inode *inode)\n{\n\treturn inode && S_ISDIR(inode->i_mode) ? OVL_I(inode)->cache : NULL;\n}\n\nvoid ovl_set_dir_cache(struct inode *inode, struct ovl_dir_cache *cache)\n{\n\tOVL_I(inode)->cache = cache;\n}\n\nvoid ovl_dentry_set_flag(unsigned long flag, struct dentry *dentry)\n{\n\tset_bit(flag, OVL_E_FLAGS(dentry));\n}\n\nvoid ovl_dentry_clear_flag(unsigned long flag, struct dentry *dentry)\n{\n\tclear_bit(flag, OVL_E_FLAGS(dentry));\n}\n\nbool ovl_dentry_test_flag(unsigned long flag, struct dentry *dentry)\n{\n\treturn test_bit(flag, OVL_E_FLAGS(dentry));\n}\n\nbool ovl_dentry_is_opaque(struct dentry *dentry)\n{\n\treturn ovl_dentry_test_flag(OVL_E_OPAQUE, dentry);\n}\n\nbool ovl_dentry_is_whiteout(struct dentry *dentry)\n{\n\treturn !dentry->d_inode && ovl_dentry_is_opaque(dentry);\n}\n\nvoid ovl_dentry_set_opaque(struct dentry *dentry)\n{\n\tovl_dentry_set_flag(OVL_E_OPAQUE, dentry);\n}\n\n \nbool ovl_dentry_has_upper_alias(struct dentry *dentry)\n{\n\treturn ovl_dentry_test_flag(OVL_E_UPPER_ALIAS, dentry);\n}\n\nvoid ovl_dentry_set_upper_alias(struct dentry *dentry)\n{\n\tovl_dentry_set_flag(OVL_E_UPPER_ALIAS, dentry);\n}\n\nstatic bool ovl_should_check_upperdata(struct inode *inode)\n{\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn false;\n\n\tif (!ovl_inode_lower(inode))\n\t\treturn false;\n\n\treturn true;\n}\n\nbool ovl_has_upperdata(struct inode *inode)\n{\n\tif (!ovl_should_check_upperdata(inode))\n\t\treturn true;\n\n\tif (!ovl_test_flag(OVL_UPPERDATA, inode))\n\t\treturn false;\n\t \n\tsmp_rmb();\n\treturn true;\n}\n\nvoid ovl_set_upperdata(struct inode *inode)\n{\n\t \n\tsmp_wmb();\n\tovl_set_flag(OVL_UPPERDATA, inode);\n}\n\n \nbool ovl_dentry_needs_data_copy_up_locked(struct dentry *dentry, int flags)\n{\n\tif (!ovl_open_flags_need_copy_up(flags))\n\t\treturn false;\n\n\treturn !ovl_test_flag(OVL_UPPERDATA, d_inode(dentry));\n}\n\nbool ovl_dentry_needs_data_copy_up(struct dentry *dentry, int flags)\n{\n\tif (!ovl_open_flags_need_copy_up(flags))\n\t\treturn false;\n\n\treturn !ovl_has_upperdata(d_inode(dentry));\n}\n\nconst char *ovl_dentry_get_redirect(struct dentry *dentry)\n{\n\treturn OVL_I(d_inode(dentry))->redirect;\n}\n\nvoid ovl_dentry_set_redirect(struct dentry *dentry, const char *redirect)\n{\n\tstruct ovl_inode *oi = OVL_I(d_inode(dentry));\n\n\tkfree(oi->redirect);\n\toi->redirect = redirect;\n}\n\nvoid ovl_inode_update(struct inode *inode, struct dentry *upperdentry)\n{\n\tstruct inode *upperinode = d_inode(upperdentry);\n\n\tWARN_ON(OVL_I(inode)->__upperdentry);\n\n\t \n\tsmp_wmb();\n\tOVL_I(inode)->__upperdentry = upperdentry;\n\tif (inode_unhashed(inode)) {\n\t\tinode->i_private = upperinode;\n\t\t__insert_inode_hash(inode, (unsigned long) upperinode);\n\t}\n}\n\nstatic void ovl_dir_version_inc(struct dentry *dentry, bool impurity)\n{\n\tstruct inode *inode = d_inode(dentry);\n\n\tWARN_ON(!inode_is_locked(inode));\n\tWARN_ON(!d_is_dir(dentry));\n\t \n\tif (!ovl_dir_is_real(inode) || impurity)\n\t\tOVL_I(inode)->version++;\n}\n\nvoid ovl_dir_modified(struct dentry *dentry, bool impurity)\n{\n\t \n\tovl_copyattr(d_inode(dentry));\n\n\tovl_dir_version_inc(dentry, impurity);\n}\n\nu64 ovl_inode_version_get(struct inode *inode)\n{\n\tWARN_ON(!inode_is_locked(inode));\n\treturn OVL_I(inode)->version;\n}\n\nbool ovl_is_whiteout(struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\n\treturn inode && IS_WHITEOUT(inode);\n}\n\nstruct file *ovl_path_open(const struct path *path, int flags)\n{\n\tstruct inode *inode = d_inode(path->dentry);\n\tstruct mnt_idmap *real_idmap = mnt_idmap(path->mnt);\n\tint err, acc_mode;\n\n\tif (flags & ~(O_ACCMODE | O_LARGEFILE))\n\t\tBUG();\n\n\tswitch (flags & O_ACCMODE) {\n\tcase O_RDONLY:\n\t\tacc_mode = MAY_READ;\n\t\tbreak;\n\tcase O_WRONLY:\n\t\tacc_mode = MAY_WRITE;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\terr = inode_permission(real_idmap, inode, acc_mode | MAY_OPEN);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\t \n\tif (inode_owner_or_capable(real_idmap, inode))\n\t\tflags |= O_NOATIME;\n\n\treturn dentry_open(path, flags, current_cred());\n}\n\n \nstatic bool ovl_already_copied_up_locked(struct dentry *dentry, int flags)\n{\n\tbool disconnected = dentry->d_flags & DCACHE_DISCONNECTED;\n\n\tif (ovl_dentry_upper(dentry) &&\n\t    (ovl_dentry_has_upper_alias(dentry) || disconnected) &&\n\t    !ovl_dentry_needs_data_copy_up_locked(dentry, flags))\n\t\treturn true;\n\n\treturn false;\n}\n\nbool ovl_already_copied_up(struct dentry *dentry, int flags)\n{\n\tbool disconnected = dentry->d_flags & DCACHE_DISCONNECTED;\n\n\t \n\tif (ovl_dentry_upper(dentry) &&\n\t    (ovl_dentry_has_upper_alias(dentry) || disconnected) &&\n\t    !ovl_dentry_needs_data_copy_up(dentry, flags))\n\t\treturn true;\n\n\treturn false;\n}\n\nint ovl_copy_up_start(struct dentry *dentry, int flags)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tint err;\n\n\terr = ovl_inode_lock_interruptible(inode);\n\tif (!err && ovl_already_copied_up_locked(dentry, flags)) {\n\t\terr = 1;  \n\t\tovl_inode_unlock(inode);\n\t}\n\n\treturn err;\n}\n\nvoid ovl_copy_up_end(struct dentry *dentry)\n{\n\tovl_inode_unlock(d_inode(dentry));\n}\n\nbool ovl_path_check_origin_xattr(struct ovl_fs *ofs, const struct path *path)\n{\n\tint res;\n\n\tres = ovl_path_getxattr(ofs, path, OVL_XATTR_ORIGIN, NULL, 0);\n\n\t \n\tif (res >= 0)\n\t\treturn true;\n\n\treturn false;\n}\n\n \nbool ovl_init_uuid_xattr(struct super_block *sb, struct ovl_fs *ofs,\n\t\t\t const struct path *upperpath)\n{\n\tbool set = false;\n\tint res;\n\n\t \n\tres = ovl_path_getxattr(ofs, upperpath, OVL_XATTR_UUID, sb->s_uuid.b,\n\t\t\t\tUUID_SIZE);\n\tif (res == UUID_SIZE)\n\t\treturn true;\n\n\tif (res != -ENODATA)\n\t\tgoto fail;\n\n\t \n\tif (ofs->config.uuid == OVL_UUID_AUTO) {\n\t\tres = ovl_path_getxattr(ofs, upperpath, OVL_XATTR_IMPURE, NULL,\n\t\t\t\t\t0);\n\t\tif (res > 0) {\n\t\t\t \n\t\t\tofs->config.uuid = OVL_UUID_NULL;\n\t\t\treturn true;\n\t\t} else if (res == -ENODATA) {\n\t\t\t \n\t\t\tofs->config.uuid = OVL_UUID_ON;\n\t\t} else if (res < 0) {\n\t\t\tgoto fail;\n\t\t}\n\n\t}\n\n\t \n\tuuid_gen(&sb->s_uuid);\n\n\t \n\tset = true;\n\tres = ovl_setxattr(ofs, upperpath->dentry, OVL_XATTR_UUID, sb->s_uuid.b,\n\t\t\t   UUID_SIZE);\n\tif (res == 0)\n\t\treturn true;\n\nfail:\n\tmemset(sb->s_uuid.b, 0, UUID_SIZE);\n\tofs->config.uuid = OVL_UUID_NULL;\n\tpr_warn(\"failed to %s uuid (%pd2, err=%i); falling back to uuid=null.\\n\",\n\t\tset ? \"set\" : \"get\", upperpath->dentry, res);\n\treturn false;\n}\n\nbool ovl_path_check_dir_xattr(struct ovl_fs *ofs, const struct path *path,\n\t\t\t       enum ovl_xattr ox)\n{\n\tint res;\n\tchar val;\n\n\tif (!d_is_dir(path->dentry))\n\t\treturn false;\n\n\tres = ovl_path_getxattr(ofs, path, ox, &val, 1);\n\tif (res == 1 && val == 'y')\n\t\treturn true;\n\n\treturn false;\n}\n\n#define OVL_XATTR_OPAQUE_POSTFIX\t\"opaque\"\n#define OVL_XATTR_REDIRECT_POSTFIX\t\"redirect\"\n#define OVL_XATTR_ORIGIN_POSTFIX\t\"origin\"\n#define OVL_XATTR_IMPURE_POSTFIX\t\"impure\"\n#define OVL_XATTR_NLINK_POSTFIX\t\t\"nlink\"\n#define OVL_XATTR_UPPER_POSTFIX\t\t\"upper\"\n#define OVL_XATTR_UUID_POSTFIX\t\t\"uuid\"\n#define OVL_XATTR_METACOPY_POSTFIX\t\"metacopy\"\n#define OVL_XATTR_PROTATTR_POSTFIX\t\"protattr\"\n\n#define OVL_XATTR_TAB_ENTRY(x) \\\n\t[x] = { [false] = OVL_XATTR_TRUSTED_PREFIX x ## _POSTFIX, \\\n\t\t[true] = OVL_XATTR_USER_PREFIX x ## _POSTFIX }\n\nconst char *const ovl_xattr_table[][2] = {\n\tOVL_XATTR_TAB_ENTRY(OVL_XATTR_OPAQUE),\n\tOVL_XATTR_TAB_ENTRY(OVL_XATTR_REDIRECT),\n\tOVL_XATTR_TAB_ENTRY(OVL_XATTR_ORIGIN),\n\tOVL_XATTR_TAB_ENTRY(OVL_XATTR_IMPURE),\n\tOVL_XATTR_TAB_ENTRY(OVL_XATTR_NLINK),\n\tOVL_XATTR_TAB_ENTRY(OVL_XATTR_UPPER),\n\tOVL_XATTR_TAB_ENTRY(OVL_XATTR_UUID),\n\tOVL_XATTR_TAB_ENTRY(OVL_XATTR_METACOPY),\n\tOVL_XATTR_TAB_ENTRY(OVL_XATTR_PROTATTR),\n};\n\nint ovl_check_setxattr(struct ovl_fs *ofs, struct dentry *upperdentry,\n\t\t       enum ovl_xattr ox, const void *value, size_t size,\n\t\t       int xerr)\n{\n\tint err;\n\n\tif (ofs->noxattr)\n\t\treturn xerr;\n\n\terr = ovl_setxattr(ofs, upperdentry, ox, value, size);\n\n\tif (err == -EOPNOTSUPP) {\n\t\tpr_warn(\"cannot set %s xattr on upper\\n\", ovl_xattr(ofs, ox));\n\t\tofs->noxattr = true;\n\t\treturn xerr;\n\t}\n\n\treturn err;\n}\n\nint ovl_set_impure(struct dentry *dentry, struct dentry *upperdentry)\n{\n\tstruct ovl_fs *ofs = OVL_FS(dentry->d_sb);\n\tint err;\n\n\tif (ovl_test_flag(OVL_IMPURE, d_inode(dentry)))\n\t\treturn 0;\n\n\t \n\terr = ovl_check_setxattr(ofs, upperdentry, OVL_XATTR_IMPURE, \"y\", 1, 0);\n\tif (!err)\n\t\tovl_set_flag(OVL_IMPURE, d_inode(dentry));\n\n\treturn err;\n}\n\n\n#define OVL_PROTATTR_MAX 32  \n\nvoid ovl_check_protattr(struct inode *inode, struct dentry *upper)\n{\n\tstruct ovl_fs *ofs = OVL_FS(inode->i_sb);\n\tu32 iflags = inode->i_flags & OVL_PROT_I_FLAGS_MASK;\n\tchar buf[OVL_PROTATTR_MAX+1];\n\tint res, n;\n\n\tres = ovl_getxattr_upper(ofs, upper, OVL_XATTR_PROTATTR, buf,\n\t\t\t\t OVL_PROTATTR_MAX);\n\tif (res < 0)\n\t\treturn;\n\n\t \n\tfor (n = 0; n < res; n++) {\n\t\tif (buf[n] == 'a')\n\t\t\tiflags |= S_APPEND;\n\t\telse if (buf[n] == 'i')\n\t\t\tiflags |= S_IMMUTABLE;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tif (!res || n < res) {\n\t\tpr_warn_ratelimited(\"incompatible overlay.protattr format (%pd2, len=%d)\\n\",\n\t\t\t\t    upper, res);\n\t} else {\n\t\tinode_set_flags(inode, iflags, OVL_PROT_I_FLAGS_MASK);\n\t}\n}\n\nint ovl_set_protattr(struct inode *inode, struct dentry *upper,\n\t\t      struct fileattr *fa)\n{\n\tstruct ovl_fs *ofs = OVL_FS(inode->i_sb);\n\tchar buf[OVL_PROTATTR_MAX];\n\tint len = 0, err = 0;\n\tu32 iflags = 0;\n\n\tBUILD_BUG_ON(HWEIGHT32(OVL_PROT_FS_FLAGS_MASK) > OVL_PROTATTR_MAX);\n\n\tif (fa->flags & FS_APPEND_FL) {\n\t\tbuf[len++] = 'a';\n\t\tiflags |= S_APPEND;\n\t}\n\tif (fa->flags & FS_IMMUTABLE_FL) {\n\t\tbuf[len++] = 'i';\n\t\tiflags |= S_IMMUTABLE;\n\t}\n\n\t \n\tif (len) {\n\t\terr = ovl_check_setxattr(ofs, upper, OVL_XATTR_PROTATTR,\n\t\t\t\t\t buf, len, -EPERM);\n\t} else if (inode->i_flags & OVL_PROT_I_FLAGS_MASK) {\n\t\terr = ovl_removexattr(ofs, upper, OVL_XATTR_PROTATTR);\n\t\tif (err == -EOPNOTSUPP || err == -ENODATA)\n\t\t\terr = 0;\n\t}\n\tif (err)\n\t\treturn err;\n\n\tinode_set_flags(inode, iflags, OVL_PROT_I_FLAGS_MASK);\n\n\t \n\tfa->flags &= ~OVL_PROT_FS_FLAGS_MASK;\n\tfa->fsx_xflags &= ~OVL_PROT_FSX_FLAGS_MASK;\n\n\treturn 0;\n}\n\n \nbool ovl_inuse_trylock(struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tbool locked = false;\n\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & I_OVL_INUSE)) {\n\t\tinode->i_state |= I_OVL_INUSE;\n\t\tlocked = true;\n\t}\n\tspin_unlock(&inode->i_lock);\n\n\treturn locked;\n}\n\nvoid ovl_inuse_unlock(struct dentry *dentry)\n{\n\tif (dentry) {\n\t\tstruct inode *inode = d_inode(dentry);\n\n\t\tspin_lock(&inode->i_lock);\n\t\tWARN_ON(!(inode->i_state & I_OVL_INUSE));\n\t\tinode->i_state &= ~I_OVL_INUSE;\n\t\tspin_unlock(&inode->i_lock);\n\t}\n}\n\nbool ovl_is_inuse(struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tbool inuse;\n\n\tspin_lock(&inode->i_lock);\n\tinuse = (inode->i_state & I_OVL_INUSE);\n\tspin_unlock(&inode->i_lock);\n\n\treturn inuse;\n}\n\n \nbool ovl_need_index(struct dentry *dentry)\n{\n\tstruct dentry *lower = ovl_dentry_lower(dentry);\n\n\tif (!lower || !ovl_indexdir(dentry->d_sb))\n\t\treturn false;\n\n\t \n\tif (ovl_index_all(dentry->d_sb))\n\t\treturn true;\n\n\t \n\tif (!d_is_dir(lower) && d_inode(lower)->i_nlink > 1)\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic void ovl_cleanup_index(struct dentry *dentry)\n{\n\tstruct ovl_fs *ofs = OVL_FS(dentry->d_sb);\n\tstruct dentry *indexdir = ovl_indexdir(dentry->d_sb);\n\tstruct inode *dir = indexdir->d_inode;\n\tstruct dentry *lowerdentry = ovl_dentry_lower(dentry);\n\tstruct dentry *upperdentry = ovl_dentry_upper(dentry);\n\tstruct dentry *index = NULL;\n\tstruct inode *inode;\n\tstruct qstr name = { };\n\tint err;\n\n\terr = ovl_get_index_name(ofs, lowerdentry, &name);\n\tif (err)\n\t\tgoto fail;\n\n\tinode = d_inode(upperdentry);\n\tif (!S_ISDIR(inode->i_mode) && inode->i_nlink != 1) {\n\t\tpr_warn_ratelimited(\"cleanup linked index (%pd2, ino=%lu, nlink=%u)\\n\",\n\t\t\t\t    upperdentry, inode->i_ino, inode->i_nlink);\n\t\t \n\t\tset_nlink(d_inode(dentry), inode->i_nlink - 1);\n\t\tovl_set_nlink_upper(dentry);\n\t\tgoto out;\n\t}\n\n\tinode_lock_nested(dir, I_MUTEX_PARENT);\n\tindex = ovl_lookup_upper(ofs, name.name, indexdir, name.len);\n\terr = PTR_ERR(index);\n\tif (IS_ERR(index)) {\n\t\tindex = NULL;\n\t} else if (ovl_index_all(dentry->d_sb)) {\n\t\t \n\t\terr = ovl_cleanup_and_whiteout(OVL_FS(dentry->d_sb),\n\t\t\t\t\t       dir, index);\n\t} else {\n\t\t \n\t\terr = ovl_cleanup(ofs, dir, index);\n\t}\n\n\tinode_unlock(dir);\n\tif (err)\n\t\tgoto fail;\n\nout:\n\tkfree(name.name);\n\tdput(index);\n\treturn;\n\nfail:\n\tpr_err(\"cleanup index of '%pd2' failed (%i)\\n\", dentry, err);\n\tgoto out;\n}\n\n \nint ovl_nlink_start(struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tconst struct cred *old_cred;\n\tint err;\n\n\tif (WARN_ON(!inode))\n\t\treturn -ENOENT;\n\n\t \n\tif (ovl_need_index(dentry) && !ovl_dentry_has_upper_alias(dentry)) {\n\t\terr = ovl_copy_up(dentry);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = ovl_inode_lock_interruptible(inode);\n\tif (err)\n\t\treturn err;\n\n\tif (d_is_dir(dentry) || !ovl_test_flag(OVL_INDEX, inode))\n\t\tgoto out;\n\n\told_cred = ovl_override_creds(dentry->d_sb);\n\t \n\terr = ovl_set_nlink_upper(dentry);\n\trevert_creds(old_cred);\n\nout:\n\tif (err)\n\t\tovl_inode_unlock(inode);\n\n\treturn err;\n}\n\nvoid ovl_nlink_end(struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(dentry);\n\n\tif (ovl_test_flag(OVL_INDEX, inode) && inode->i_nlink == 0) {\n\t\tconst struct cred *old_cred;\n\n\t\told_cred = ovl_override_creds(dentry->d_sb);\n\t\tovl_cleanup_index(dentry);\n\t\trevert_creds(old_cred);\n\t}\n\n\tovl_inode_unlock(inode);\n}\n\nint ovl_lock_rename_workdir(struct dentry *workdir, struct dentry *upperdir)\n{\n\t \n\tif (workdir == upperdir)\n\t\tgoto err;\n\n\t \n\tif (lock_rename(workdir, upperdir) != NULL)\n\t\tgoto err_unlock;\n\n\treturn 0;\n\nerr_unlock:\n\tunlock_rename(workdir, upperdir);\nerr:\n\tpr_err(\"failed to lock workdir+upperdir\\n\");\n\treturn -EIO;\n}\n\n \nint ovl_check_metacopy_xattr(struct ovl_fs *ofs, const struct path *path,\n\t\t\t     struct ovl_metacopy *data)\n{\n\tint res;\n\n\t \n\tif (!S_ISREG(d_inode(path->dentry)->i_mode))\n\t\treturn 0;\n\n\tres = ovl_path_getxattr(ofs, path, OVL_XATTR_METACOPY,\n\t\t\t\tdata, data ? OVL_METACOPY_MAX_SIZE : 0);\n\tif (res < 0) {\n\t\tif (res == -ENODATA || res == -EOPNOTSUPP)\n\t\t\treturn 0;\n\t\t \n\t\tif (ofs->config.userxattr && res == -EACCES)\n\t\t\treturn 0;\n\t\tgoto out;\n\t}\n\n\tif (res == 0) {\n\t\t \n\t\tres = OVL_METACOPY_MIN_SIZE;\n\t\tif (data) {\n\t\t\tmemset(data, 0, res);\n\t\t\tdata->len = res;\n\t\t}\n\t} else if (res < OVL_METACOPY_MIN_SIZE) {\n\t\tpr_warn_ratelimited(\"metacopy file '%pd' has too small xattr\\n\",\n\t\t\t\t    path->dentry);\n\t\treturn -EIO;\n\t} else if (data) {\n\t\tif (data->version != 0) {\n\t\t\tpr_warn_ratelimited(\"metacopy file '%pd' has unsupported version\\n\",\n\t\t\t\t\t    path->dentry);\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (res != data->len) {\n\t\t\tpr_warn_ratelimited(\"metacopy file '%pd' has invalid xattr size\\n\",\n\t\t\t\t\t    path->dentry);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\treturn res;\nout:\n\tpr_warn_ratelimited(\"failed to get metacopy (%i)\\n\", res);\n\treturn res;\n}\n\nint ovl_set_metacopy_xattr(struct ovl_fs *ofs, struct dentry *d, struct ovl_metacopy *metacopy)\n{\n\tsize_t len = metacopy->len;\n\n\t \n\tif (metacopy->version == 0 && metacopy->flags == 0 && metacopy->digest_algo == 0)\n\t\tlen = 0;\n\n\treturn ovl_check_setxattr(ofs, d, OVL_XATTR_METACOPY,\n\t\t\t\t  metacopy, len, -EOPNOTSUPP);\n}\n\nbool ovl_is_metacopy_dentry(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = OVL_E(dentry);\n\n\tif (!d_is_reg(dentry))\n\t\treturn false;\n\n\tif (ovl_dentry_upper(dentry)) {\n\t\tif (!ovl_has_upperdata(d_inode(dentry)))\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\treturn (ovl_numlower(oe) > 1);\n}\n\nchar *ovl_get_redirect_xattr(struct ovl_fs *ofs, const struct path *path, int padding)\n{\n\tint res;\n\tchar *s, *next, *buf = NULL;\n\n\tres = ovl_path_getxattr(ofs, path, OVL_XATTR_REDIRECT, NULL, 0);\n\tif (res == -ENODATA || res == -EOPNOTSUPP)\n\t\treturn NULL;\n\tif (res < 0)\n\t\tgoto fail;\n\tif (res == 0)\n\t\tgoto invalid;\n\n\tbuf = kzalloc(res + padding + 1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tres = ovl_path_getxattr(ofs, path, OVL_XATTR_REDIRECT, buf, res);\n\tif (res < 0)\n\t\tgoto fail;\n\tif (res == 0)\n\t\tgoto invalid;\n\n\tif (buf[0] == '/') {\n\t\tfor (s = buf; *s++ == '/'; s = next) {\n\t\t\tnext = strchrnul(s, '/');\n\t\t\tif (s == next)\n\t\t\t\tgoto invalid;\n\t\t}\n\t} else {\n\t\tif (strchr(buf, '/') != NULL)\n\t\t\tgoto invalid;\n\t}\n\n\treturn buf;\ninvalid:\n\tpr_warn_ratelimited(\"invalid redirect (%s)\\n\", buf);\n\tres = -EINVAL;\n\tgoto err_free;\nfail:\n\tpr_warn_ratelimited(\"failed to get redirect (%i)\\n\", res);\nerr_free:\n\tkfree(buf);\n\treturn ERR_PTR(res);\n}\n\n \nint ovl_ensure_verity_loaded(struct path *datapath)\n{\n\tstruct inode *inode = d_inode(datapath->dentry);\n\tstruct file *filp;\n\n\tif (!fsverity_active(inode) && IS_VERITY(inode)) {\n\t\t \n\t\tfilp = kernel_file_open(datapath, O_RDONLY, inode, current_cred());\n\t\tif (IS_ERR(filp))\n\t\t\treturn PTR_ERR(filp);\n\t\tfput(filp);\n\t}\n\n\treturn 0;\n}\n\nint ovl_validate_verity(struct ovl_fs *ofs,\n\t\t\tstruct path *metapath,\n\t\t\tstruct path *datapath)\n{\n\tstruct ovl_metacopy metacopy_data;\n\tu8 actual_digest[FS_VERITY_MAX_DIGEST_SIZE];\n\tint xattr_digest_size, digest_size;\n\tint xattr_size, err;\n\tu8 verity_algo;\n\n\tif (!ofs->config.verity_mode ||\n\t     \n\t    !S_ISREG(d_inode(metapath->dentry)->i_mode))\n\t\treturn 0;\n\n\txattr_size = ovl_check_metacopy_xattr(ofs, metapath, &metacopy_data);\n\tif (xattr_size < 0)\n\t\treturn xattr_size;\n\n\tif (!xattr_size || !metacopy_data.digest_algo) {\n\t\tif (ofs->config.verity_mode == OVL_VERITY_REQUIRE) {\n\t\t\tpr_warn_ratelimited(\"metacopy file '%pd' has no digest specified\\n\",\n\t\t\t\t\t    metapath->dentry);\n\t\t\treturn -EIO;\n\t\t}\n\t\treturn 0;\n\t}\n\n\txattr_digest_size = ovl_metadata_digest_size(&metacopy_data);\n\n\terr = ovl_ensure_verity_loaded(datapath);\n\tif (err < 0) {\n\t\tpr_warn_ratelimited(\"lower file '%pd' failed to load fs-verity info\\n\",\n\t\t\t\t    datapath->dentry);\n\t\treturn -EIO;\n\t}\n\n\tdigest_size = fsverity_get_digest(d_inode(datapath->dentry), actual_digest,\n\t\t\t\t\t  &verity_algo, NULL);\n\tif (digest_size == 0) {\n\t\tpr_warn_ratelimited(\"lower file '%pd' has no fs-verity digest\\n\", datapath->dentry);\n\t\treturn -EIO;\n\t}\n\n\tif (xattr_digest_size != digest_size ||\n\t    metacopy_data.digest_algo != verity_algo ||\n\t    memcmp(metacopy_data.digest, actual_digest, xattr_digest_size) != 0) {\n\t\tpr_warn_ratelimited(\"lower file '%pd' has the wrong fs-verity digest\\n\",\n\t\t\t\t    datapath->dentry);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nint ovl_get_verity_digest(struct ovl_fs *ofs, struct path *src,\n\t\t\t  struct ovl_metacopy *metacopy)\n{\n\tint err, digest_size;\n\n\tif (!ofs->config.verity_mode || !S_ISREG(d_inode(src->dentry)->i_mode))\n\t\treturn 0;\n\n\terr = ovl_ensure_verity_loaded(src);\n\tif (err < 0) {\n\t\tpr_warn_ratelimited(\"lower file '%pd' failed to load fs-verity info\\n\",\n\t\t\t\t    src->dentry);\n\t\treturn -EIO;\n\t}\n\n\tdigest_size = fsverity_get_digest(d_inode(src->dentry),\n\t\t\t\t\t  metacopy->digest, &metacopy->digest_algo, NULL);\n\tif (digest_size == 0 ||\n\t    WARN_ON_ONCE(digest_size > FS_VERITY_MAX_DIGEST_SIZE)) {\n\t\tif (ofs->config.verity_mode == OVL_VERITY_REQUIRE) {\n\t\t\tpr_warn_ratelimited(\"lower file '%pd' has no fs-verity digest\\n\",\n\t\t\t\t\t    src->dentry);\n\t\t\treturn -EIO;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tmetacopy->len += digest_size;\n\treturn 0;\n}\n\n \n\nint ovl_sync_status(struct ovl_fs *ofs)\n{\n\tstruct vfsmount *mnt;\n\n\tif (ovl_should_sync(ofs))\n\t\treturn 1;\n\n\tmnt = ovl_upper_mnt(ofs);\n\tif (!mnt)\n\t\treturn 0;\n\n\treturn errseq_check(&mnt->mnt_sb->s_wb_err, ofs->errseq);\n}\n\n \nvoid ovl_copyattr(struct inode *inode)\n{\n\tstruct path realpath;\n\tstruct inode *realinode;\n\tstruct mnt_idmap *real_idmap;\n\tvfsuid_t vfsuid;\n\tvfsgid_t vfsgid;\n\n\trealinode = ovl_i_path_real(inode, &realpath);\n\treal_idmap = mnt_idmap(realpath.mnt);\n\n\tvfsuid = i_uid_into_vfsuid(real_idmap, realinode);\n\tvfsgid = i_gid_into_vfsgid(real_idmap, realinode);\n\n\tinode->i_uid = vfsuid_into_kuid(vfsuid);\n\tinode->i_gid = vfsgid_into_kgid(vfsgid);\n\tinode->i_mode = realinode->i_mode;\n\tinode->i_atime = realinode->i_atime;\n\tinode->i_mtime = realinode->i_mtime;\n\tinode_set_ctime_to_ts(inode, inode_get_ctime(realinode));\n\ti_size_write(inode, i_size_read(realinode));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}