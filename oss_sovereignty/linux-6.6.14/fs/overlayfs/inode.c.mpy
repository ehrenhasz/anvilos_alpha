{
  "module_name": "inode.c",
  "hash_id": "2873fef5852760a6e0980d0cbfa4c8d8bcb48ff6181957517b60ca494bb1c06a",
  "original_prompt": "Ingested from linux-6.6.14/fs/overlayfs/inode.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/ratelimit.h>\n#include <linux/fiemap.h>\n#include <linux/fileattr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/posix_acl.h>\n#include <linux/posix_acl_xattr.h>\n#include \"overlayfs.h\"\n\n\nint ovl_setattr(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\tstruct iattr *attr)\n{\n\tint err;\n\tstruct ovl_fs *ofs = OVL_FS(dentry->d_sb);\n\tbool full_copy_up = false;\n\tstruct dentry *upperdentry;\n\tconst struct cred *old_cred;\n\n\terr = setattr_prepare(&nop_mnt_idmap, dentry, attr);\n\tif (err)\n\t\treturn err;\n\n\terr = ovl_want_write(dentry);\n\tif (err)\n\t\tgoto out;\n\n\tif (attr->ia_valid & ATTR_SIZE) {\n\t\t \n\t\tfull_copy_up = true;\n\t}\n\n\tif (!full_copy_up)\n\t\terr = ovl_copy_up(dentry);\n\telse\n\t\terr = ovl_copy_up_with_data(dentry);\n\tif (!err) {\n\t\tstruct inode *winode = NULL;\n\n\t\tupperdentry = ovl_dentry_upper(dentry);\n\n\t\tif (attr->ia_valid & ATTR_SIZE) {\n\t\t\twinode = d_inode(upperdentry);\n\t\t\terr = get_write_access(winode);\n\t\t\tif (err)\n\t\t\t\tgoto out_drop_write;\n\t\t}\n\n\t\tif (attr->ia_valid & (ATTR_KILL_SUID|ATTR_KILL_SGID))\n\t\t\tattr->ia_valid &= ~ATTR_MODE;\n\n\t\t \n\t\tattr->ia_valid &= ~ATTR_FILE;\n\n\t\t \n\t\tattr->ia_valid &= ~ATTR_OPEN;\n\n\t\tinode_lock(upperdentry->d_inode);\n\t\told_cred = ovl_override_creds(dentry->d_sb);\n\t\terr = ovl_do_notify_change(ofs, upperdentry, attr);\n\t\trevert_creds(old_cred);\n\t\tif (!err)\n\t\t\tovl_copyattr(dentry->d_inode);\n\t\tinode_unlock(upperdentry->d_inode);\n\n\t\tif (winode)\n\t\t\tput_write_access(winode);\n\t}\nout_drop_write:\n\tovl_drop_write(dentry);\nout:\n\treturn err;\n}\n\nstatic void ovl_map_dev_ino(struct dentry *dentry, struct kstat *stat, int fsid)\n{\n\tstruct ovl_fs *ofs = OVL_FS(dentry->d_sb);\n\tbool samefs = ovl_same_fs(ofs);\n\tunsigned int xinobits = ovl_xino_bits(ofs);\n\tunsigned int xinoshift = 64 - xinobits;\n\n\tif (samefs) {\n\t\t \n\t\tstat->dev = dentry->d_sb->s_dev;\n\t\treturn;\n\t} else if (xinobits) {\n\t\t \n\t\tif (likely(!(stat->ino >> xinoshift))) {\n\t\t\tstat->ino |= ((u64)fsid) << (xinoshift + 1);\n\t\t\tstat->dev = dentry->d_sb->s_dev;\n\t\t\treturn;\n\t\t} else if (ovl_xino_warn(ofs)) {\n\t\t\tpr_warn_ratelimited(\"inode number too big (%pd2, ino=%llu, xinobits=%d)\\n\",\n\t\t\t\t\t    dentry, stat->ino, xinobits);\n\t\t}\n\t}\n\n\t \n\tif (S_ISDIR(dentry->d_inode->i_mode)) {\n\t\t \n\t\tstat->dev = dentry->d_sb->s_dev;\n\t\tstat->ino = dentry->d_inode->i_ino;\n\t} else {\n\t\t \n\t\tstat->dev = ofs->fs[fsid].pseudo_dev;\n\t}\n}\n\nint ovl_getattr(struct mnt_idmap *idmap, const struct path *path,\n\t\tstruct kstat *stat, u32 request_mask, unsigned int flags)\n{\n\tstruct dentry *dentry = path->dentry;\n\tenum ovl_path_type type;\n\tstruct path realpath;\n\tconst struct cred *old_cred;\n\tstruct inode *inode = d_inode(dentry);\n\tbool is_dir = S_ISDIR(inode->i_mode);\n\tint fsid = 0;\n\tint err;\n\tbool metacopy_blocks = false;\n\n\tmetacopy_blocks = ovl_is_metacopy_dentry(dentry);\n\n\ttype = ovl_path_real(dentry, &realpath);\n\told_cred = ovl_override_creds(dentry->d_sb);\n\terr = ovl_do_getattr(&realpath, stat, request_mask, flags);\n\tif (err)\n\t\tgoto out;\n\n\t \n\tgeneric_fill_statx_attr(inode, stat);\n\n\t \n\tif (!is_dir || ovl_same_dev(OVL_FS(dentry->d_sb))) {\n\t\tif (!OVL_TYPE_UPPER(type)) {\n\t\t\tfsid = ovl_layer_lower(dentry)->fsid;\n\t\t} else if (OVL_TYPE_ORIGIN(type)) {\n\t\t\tstruct kstat lowerstat;\n\t\t\tu32 lowermask = STATX_INO | STATX_BLOCKS |\n\t\t\t\t\t(!is_dir ? STATX_NLINK : 0);\n\n\t\t\tovl_path_lower(dentry, &realpath);\n\t\t\terr = ovl_do_getattr(&realpath, &lowerstat, lowermask,\n\t\t\t\t\t     flags);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\t \n\t\t\tif (ovl_test_flag(OVL_INDEX, d_inode(dentry)) ||\n\t\t\t    (!ovl_verify_lower(dentry->d_sb) &&\n\t\t\t     (is_dir || lowerstat.nlink == 1))) {\n\t\t\t\tfsid = ovl_layer_lower(dentry)->fsid;\n\t\t\t\tstat->ino = lowerstat.ino;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (metacopy_blocks &&\n\t\t\t    realpath.dentry == ovl_dentry_lowerdata(dentry)) {\n\t\t\t\tstat->blocks = lowerstat.blocks;\n\t\t\t\tmetacopy_blocks = false;\n\t\t\t}\n\t\t}\n\n\t\tif (metacopy_blocks) {\n\t\t\t \n\t\t\tstruct kstat lowerdatastat;\n\t\t\tu32 lowermask = STATX_BLOCKS;\n\n\t\t\tovl_path_lowerdata(dentry, &realpath);\n\t\t\tif (realpath.dentry) {\n\t\t\t\terr = ovl_do_getattr(&realpath, &lowerdatastat,\n\t\t\t\t\t\t     lowermask, flags);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tlowerdatastat.blocks =\n\t\t\t\t\tround_up(stat->size, stat->blksize) >> 9;\n\t\t\t}\n\t\t\tstat->blocks = lowerdatastat.blocks;\n\t\t}\n\t}\n\n\tovl_map_dev_ino(dentry, stat, fsid);\n\n\t \n\tif (is_dir && OVL_TYPE_MERGE(type))\n\t\tstat->nlink = 1;\n\n\t \n\tif (!is_dir && ovl_test_flag(OVL_INDEX, d_inode(dentry)))\n\t\tstat->nlink = dentry->d_inode->i_nlink;\n\nout:\n\trevert_creds(old_cred);\n\n\treturn err;\n}\n\nint ovl_permission(struct mnt_idmap *idmap,\n\t\t   struct inode *inode, int mask)\n{\n\tstruct inode *upperinode = ovl_inode_upper(inode);\n\tstruct inode *realinode;\n\tstruct path realpath;\n\tconst struct cred *old_cred;\n\tint err;\n\n\t \n\trealinode = ovl_i_path_real(inode, &realpath);\n\tif (!realinode) {\n\t\tWARN_ON(!(mask & MAY_NOT_BLOCK));\n\t\treturn -ECHILD;\n\t}\n\n\t \n\terr = generic_permission(&nop_mnt_idmap, inode, mask);\n\tif (err)\n\t\treturn err;\n\n\told_cred = ovl_override_creds(inode->i_sb);\n\tif (!upperinode &&\n\t    !special_file(realinode->i_mode) && mask & MAY_WRITE) {\n\t\tmask &= ~(MAY_WRITE | MAY_APPEND);\n\t\t \n\t\tmask |= MAY_READ;\n\t}\n\terr = inode_permission(mnt_idmap(realpath.mnt), realinode, mask);\n\trevert_creds(old_cred);\n\n\treturn err;\n}\n\nstatic const char *ovl_get_link(struct dentry *dentry,\n\t\t\t\tstruct inode *inode,\n\t\t\t\tstruct delayed_call *done)\n{\n\tconst struct cred *old_cred;\n\tconst char *p;\n\n\tif (!dentry)\n\t\treturn ERR_PTR(-ECHILD);\n\n\told_cred = ovl_override_creds(dentry->d_sb);\n\tp = vfs_get_link(ovl_dentry_real(dentry), done);\n\trevert_creds(old_cred);\n\treturn p;\n}\n\nbool ovl_is_private_xattr(struct super_block *sb, const char *name)\n{\n\tstruct ovl_fs *ofs = OVL_FS(sb);\n\n\tif (ofs->config.userxattr)\n\t\treturn strncmp(name, OVL_XATTR_USER_PREFIX,\n\t\t\t       sizeof(OVL_XATTR_USER_PREFIX) - 1) == 0;\n\telse\n\t\treturn strncmp(name, OVL_XATTR_TRUSTED_PREFIX,\n\t\t\t       sizeof(OVL_XATTR_TRUSTED_PREFIX) - 1) == 0;\n}\n\nint ovl_xattr_set(struct dentry *dentry, struct inode *inode, const char *name,\n\t\t  const void *value, size_t size, int flags)\n{\n\tint err;\n\tstruct ovl_fs *ofs = OVL_FS(dentry->d_sb);\n\tstruct dentry *upperdentry = ovl_i_dentry_upper(inode);\n\tstruct dentry *realdentry = upperdentry ?: ovl_dentry_lower(dentry);\n\tstruct path realpath;\n\tconst struct cred *old_cred;\n\n\terr = ovl_want_write(dentry);\n\tif (err)\n\t\tgoto out;\n\n\tif (!value && !upperdentry) {\n\t\tovl_path_lower(dentry, &realpath);\n\t\told_cred = ovl_override_creds(dentry->d_sb);\n\t\terr = vfs_getxattr(mnt_idmap(realpath.mnt), realdentry, name, NULL, 0);\n\t\trevert_creds(old_cred);\n\t\tif (err < 0)\n\t\t\tgoto out_drop_write;\n\t}\n\n\tif (!upperdentry) {\n\t\terr = ovl_copy_up(dentry);\n\t\tif (err)\n\t\t\tgoto out_drop_write;\n\n\t\trealdentry = ovl_dentry_upper(dentry);\n\t}\n\n\told_cred = ovl_override_creds(dentry->d_sb);\n\tif (value) {\n\t\terr = ovl_do_setxattr(ofs, realdentry, name, value, size,\n\t\t\t\t      flags);\n\t} else {\n\t\tWARN_ON(flags != XATTR_REPLACE);\n\t\terr = ovl_do_removexattr(ofs, realdentry, name);\n\t}\n\trevert_creds(old_cred);\n\n\t \n\tovl_copyattr(inode);\n\nout_drop_write:\n\tovl_drop_write(dentry);\nout:\n\treturn err;\n}\n\nint ovl_xattr_get(struct dentry *dentry, struct inode *inode, const char *name,\n\t\t  void *value, size_t size)\n{\n\tssize_t res;\n\tconst struct cred *old_cred;\n\tstruct path realpath;\n\n\tovl_i_path_real(inode, &realpath);\n\told_cred = ovl_override_creds(dentry->d_sb);\n\tres = vfs_getxattr(mnt_idmap(realpath.mnt), realpath.dentry, name, value, size);\n\trevert_creds(old_cred);\n\treturn res;\n}\n\nstatic bool ovl_can_list(struct super_block *sb, const char *s)\n{\n\t \n\tif (ovl_is_private_xattr(sb, s))\n\t\treturn false;\n\n\t \n\tif (strncmp(s, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN) != 0)\n\t\treturn true;\n\n\t \n\treturn ns_capable_noaudit(&init_user_ns, CAP_SYS_ADMIN);\n}\n\nssize_t ovl_listxattr(struct dentry *dentry, char *list, size_t size)\n{\n\tstruct dentry *realdentry = ovl_dentry_real(dentry);\n\tssize_t res;\n\tsize_t len;\n\tchar *s;\n\tconst struct cred *old_cred;\n\n\told_cred = ovl_override_creds(dentry->d_sb);\n\tres = vfs_listxattr(realdentry, list, size);\n\trevert_creds(old_cred);\n\tif (res <= 0 || size == 0)\n\t\treturn res;\n\n\t \n\tfor (s = list, len = res; len;) {\n\t\tsize_t slen = strnlen(s, len) + 1;\n\n\t\t \n\t\tif (WARN_ON(slen > len))\n\t\t\treturn -EIO;\n\n\t\tlen -= slen;\n\t\tif (!ovl_can_list(dentry->d_sb, s)) {\n\t\t\tres -= slen;\n\t\t\tmemmove(s, s + slen, len);\n\t\t} else {\n\t\t\ts += slen;\n\t\t}\n\t}\n\n\treturn res;\n}\n\n#ifdef CONFIG_FS_POSIX_ACL\n \nstatic void ovl_idmap_posix_acl(const struct inode *realinode,\n\t\t\t\tstruct mnt_idmap *idmap,\n\t\t\t\tstruct posix_acl *acl)\n{\n\tstruct user_namespace *fs_userns = i_user_ns(realinode);\n\n\tfor (unsigned int i = 0; i < acl->a_count; i++) {\n\t\tvfsuid_t vfsuid;\n\t\tvfsgid_t vfsgid;\n\n\t\tstruct posix_acl_entry *e = &acl->a_entries[i];\n\t\tswitch (e->e_tag) {\n\t\tcase ACL_USER:\n\t\t\tvfsuid = make_vfsuid(idmap, fs_userns, e->e_uid);\n\t\t\te->e_uid = vfsuid_into_kuid(vfsuid);\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tvfsgid = make_vfsgid(idmap, fs_userns, e->e_gid);\n\t\t\te->e_gid = vfsgid_into_kgid(vfsgid);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nstruct posix_acl *ovl_get_acl_path(const struct path *path,\n\t\t\t\t   const char *acl_name, bool noperm)\n{\n\tstruct posix_acl *real_acl, *clone;\n\tstruct mnt_idmap *idmap;\n\tstruct inode *realinode = d_inode(path->dentry);\n\n\tidmap = mnt_idmap(path->mnt);\n\n\tif (noperm)\n\t\treal_acl = get_inode_acl(realinode, posix_acl_type(acl_name));\n\telse\n\t\treal_acl = vfs_get_acl(idmap, path->dentry, acl_name);\n\tif (IS_ERR_OR_NULL(real_acl))\n\t\treturn real_acl;\n\n\tif (!is_idmapped_mnt(path->mnt))\n\t\treturn real_acl;\n\n\t \n\tclone = posix_acl_clone(real_acl, GFP_KERNEL);\n\tposix_acl_release(real_acl);  \n\tif (!clone)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tovl_idmap_posix_acl(realinode, idmap, clone);\n\treturn clone;\n}\n\n \nstruct posix_acl *do_ovl_get_acl(struct mnt_idmap *idmap,\n\t\t\t\t struct inode *inode, int type,\n\t\t\t\t bool rcu, bool noperm)\n{\n\tstruct inode *realinode;\n\tstruct posix_acl *acl;\n\tstruct path realpath;\n\n\t \n\trealinode = ovl_i_path_real(inode, &realpath);\n\tif (!realinode) {\n\t\tWARN_ON(!rcu);\n\t\treturn ERR_PTR(-ECHILD);\n\t}\n\n\tif (!IS_POSIXACL(realinode))\n\t\treturn NULL;\n\n\tif (rcu) {\n\t\t \n\t\tif (is_idmapped_mnt(realpath.mnt))\n\t\t\treturn ERR_PTR(-ECHILD);\n\n\t\tacl = get_cached_acl_rcu(realinode, type);\n\t} else {\n\t\tconst struct cred *old_cred;\n\n\t\told_cred = ovl_override_creds(inode->i_sb);\n\t\tacl = ovl_get_acl_path(&realpath, posix_acl_xattr_name(type), noperm);\n\t\trevert_creds(old_cred);\n\t}\n\n\treturn acl;\n}\n\nstatic int ovl_set_or_remove_acl(struct dentry *dentry, struct inode *inode,\n\t\t\t\t struct posix_acl *acl, int type)\n{\n\tint err;\n\tstruct path realpath;\n\tconst char *acl_name;\n\tconst struct cred *old_cred;\n\tstruct ovl_fs *ofs = OVL_FS(dentry->d_sb);\n\tstruct dentry *upperdentry = ovl_dentry_upper(dentry);\n\tstruct dentry *realdentry = upperdentry ?: ovl_dentry_lower(dentry);\n\n\terr = ovl_want_write(dentry);\n\tif (err)\n\t\treturn err;\n\n\t \n\tacl_name = posix_acl_xattr_name(type);\n\tif (!acl && !upperdentry) {\n\t\tstruct posix_acl *real_acl;\n\n\t\tovl_path_lower(dentry, &realpath);\n\t\told_cred = ovl_override_creds(dentry->d_sb);\n\t\treal_acl = vfs_get_acl(mnt_idmap(realpath.mnt), realdentry,\n\t\t\t\t       acl_name);\n\t\trevert_creds(old_cred);\n\t\tif (IS_ERR(real_acl)) {\n\t\t\terr = PTR_ERR(real_acl);\n\t\t\tgoto out_drop_write;\n\t\t}\n\t\tposix_acl_release(real_acl);\n\t}\n\n\tif (!upperdentry) {\n\t\terr = ovl_copy_up(dentry);\n\t\tif (err)\n\t\t\tgoto out_drop_write;\n\n\t\trealdentry = ovl_dentry_upper(dentry);\n\t}\n\n\told_cred = ovl_override_creds(dentry->d_sb);\n\tif (acl)\n\t\terr = ovl_do_set_acl(ofs, realdentry, acl_name, acl);\n\telse\n\t\terr = ovl_do_remove_acl(ofs, realdentry, acl_name);\n\trevert_creds(old_cred);\n\n\t \n\tovl_copyattr(inode);\n\nout_drop_write:\n\tovl_drop_write(dentry);\n\treturn err;\n}\n\nint ovl_set_acl(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\tstruct posix_acl *acl, int type)\n{\n\tint err;\n\tstruct inode *inode = d_inode(dentry);\n\tstruct dentry *workdir = ovl_workdir(dentry);\n\tstruct inode *realinode = ovl_inode_real(inode);\n\n\tif (!IS_POSIXACL(d_inode(workdir)))\n\t\treturn -EOPNOTSUPP;\n\tif (!realinode->i_op->set_acl)\n\t\treturn -EOPNOTSUPP;\n\tif (type == ACL_TYPE_DEFAULT && !S_ISDIR(inode->i_mode))\n\t\treturn acl ? -EACCES : 0;\n\tif (!inode_owner_or_capable(&nop_mnt_idmap, inode))\n\t\treturn -EPERM;\n\n\t \n\tif (unlikely(inode->i_mode & S_ISGID) && type == ACL_TYPE_ACCESS &&\n\t    !in_group_p(inode->i_gid) &&\n\t    !capable_wrt_inode_uidgid(&nop_mnt_idmap, inode, CAP_FSETID)) {\n\t\tstruct iattr iattr = { .ia_valid = ATTR_KILL_SGID };\n\n\t\terr = ovl_setattr(&nop_mnt_idmap, dentry, &iattr);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn ovl_set_or_remove_acl(dentry, inode, acl, type);\n}\n#endif\n\nint ovl_update_time(struct inode *inode, int flags)\n{\n\tif (flags & S_ATIME) {\n\t\tstruct ovl_fs *ofs = OVL_FS(inode->i_sb);\n\t\tstruct path upperpath = {\n\t\t\t.mnt = ovl_upper_mnt(ofs),\n\t\t\t.dentry = ovl_upperdentry_dereference(OVL_I(inode)),\n\t\t};\n\n\t\tif (upperpath.dentry) {\n\t\t\ttouch_atime(&upperpath);\n\t\t\tinode->i_atime = d_inode(upperpath.dentry)->i_atime;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int ovl_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t      u64 start, u64 len)\n{\n\tint err;\n\tstruct inode *realinode = ovl_inode_realdata(inode);\n\tconst struct cred *old_cred;\n\n\tif (!realinode)\n\t\treturn -EIO;\n\n\tif (!realinode->i_op->fiemap)\n\t\treturn -EOPNOTSUPP;\n\n\told_cred = ovl_override_creds(inode->i_sb);\n\terr = realinode->i_op->fiemap(realinode, fieinfo, start, len);\n\trevert_creds(old_cred);\n\n\treturn err;\n}\n\n \nstatic int ovl_security_fileattr(const struct path *realpath, struct fileattr *fa,\n\t\t\t\t bool set)\n{\n\tstruct file *file;\n\tunsigned int cmd;\n\tint err;\n\n\tfile = dentry_open(realpath, O_RDONLY, current_cred());\n\tif (IS_ERR(file))\n\t\treturn PTR_ERR(file);\n\n\tif (set)\n\t\tcmd = fa->fsx_valid ? FS_IOC_FSSETXATTR : FS_IOC_SETFLAGS;\n\telse\n\t\tcmd = fa->fsx_valid ? FS_IOC_FSGETXATTR : FS_IOC_GETFLAGS;\n\n\terr = security_file_ioctl(file, cmd, 0);\n\tfput(file);\n\n\treturn err;\n}\n\nint ovl_real_fileattr_set(const struct path *realpath, struct fileattr *fa)\n{\n\tint err;\n\n\terr = ovl_security_fileattr(realpath, fa, true);\n\tif (err)\n\t\treturn err;\n\n\treturn vfs_fileattr_set(mnt_idmap(realpath->mnt), realpath->dentry, fa);\n}\n\nint ovl_fileattr_set(struct mnt_idmap *idmap,\n\t\t     struct dentry *dentry, struct fileattr *fa)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct path upperpath;\n\tconst struct cred *old_cred;\n\tunsigned int flags;\n\tint err;\n\n\terr = ovl_want_write(dentry);\n\tif (err)\n\t\tgoto out;\n\n\terr = ovl_copy_up(dentry);\n\tif (!err) {\n\t\tovl_path_real(dentry, &upperpath);\n\n\t\told_cred = ovl_override_creds(inode->i_sb);\n\t\t \n\t\terr = ovl_set_protattr(inode, upperpath.dentry, fa);\n\t\tif (!err)\n\t\t\terr = ovl_real_fileattr_set(&upperpath, fa);\n\t\trevert_creds(old_cred);\n\n\t\t \n\t\tflags = ovl_inode_real(inode)->i_flags & OVL_COPY_I_FLAGS_MASK;\n\n\t\tBUILD_BUG_ON(OVL_PROT_I_FLAGS_MASK & ~OVL_COPY_I_FLAGS_MASK);\n\t\tflags |= inode->i_flags & OVL_PROT_I_FLAGS_MASK;\n\t\tinode_set_flags(inode, flags, OVL_COPY_I_FLAGS_MASK);\n\n\t\t \n\t\tovl_copyattr(inode);\n\t}\n\tovl_drop_write(dentry);\nout:\n\treturn err;\n}\n\n \nstatic void ovl_fileattr_prot_flags(struct inode *inode, struct fileattr *fa)\n{\n\tBUILD_BUG_ON(OVL_PROT_FS_FLAGS_MASK & ~FS_COMMON_FL);\n\tBUILD_BUG_ON(OVL_PROT_FSX_FLAGS_MASK & ~FS_XFLAG_COMMON);\n\n\tif (inode->i_flags & S_APPEND) {\n\t\tfa->flags |= FS_APPEND_FL;\n\t\tfa->fsx_xflags |= FS_XFLAG_APPEND;\n\t}\n\tif (inode->i_flags & S_IMMUTABLE) {\n\t\tfa->flags |= FS_IMMUTABLE_FL;\n\t\tfa->fsx_xflags |= FS_XFLAG_IMMUTABLE;\n\t}\n}\n\nint ovl_real_fileattr_get(const struct path *realpath, struct fileattr *fa)\n{\n\tint err;\n\n\terr = ovl_security_fileattr(realpath, fa, false);\n\tif (err)\n\t\treturn err;\n\n\terr = vfs_fileattr_get(realpath->dentry, fa);\n\tif (err == -ENOIOCTLCMD)\n\t\terr = -ENOTTY;\n\treturn err;\n}\n\nint ovl_fileattr_get(struct dentry *dentry, struct fileattr *fa)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct path realpath;\n\tconst struct cred *old_cred;\n\tint err;\n\n\tovl_path_real(dentry, &realpath);\n\n\told_cred = ovl_override_creds(inode->i_sb);\n\terr = ovl_real_fileattr_get(&realpath, fa);\n\tovl_fileattr_prot_flags(inode, fa);\n\trevert_creds(old_cred);\n\n\treturn err;\n}\n\nstatic const struct inode_operations ovl_file_inode_operations = {\n\t.setattr\t= ovl_setattr,\n\t.permission\t= ovl_permission,\n\t.getattr\t= ovl_getattr,\n\t.listxattr\t= ovl_listxattr,\n\t.get_inode_acl\t= ovl_get_inode_acl,\n\t.get_acl\t= ovl_get_acl,\n\t.set_acl\t= ovl_set_acl,\n\t.update_time\t= ovl_update_time,\n\t.fiemap\t\t= ovl_fiemap,\n\t.fileattr_get\t= ovl_fileattr_get,\n\t.fileattr_set\t= ovl_fileattr_set,\n};\n\nstatic const struct inode_operations ovl_symlink_inode_operations = {\n\t.setattr\t= ovl_setattr,\n\t.get_link\t= ovl_get_link,\n\t.getattr\t= ovl_getattr,\n\t.listxattr\t= ovl_listxattr,\n\t.update_time\t= ovl_update_time,\n};\n\nstatic const struct inode_operations ovl_special_inode_operations = {\n\t.setattr\t= ovl_setattr,\n\t.permission\t= ovl_permission,\n\t.getattr\t= ovl_getattr,\n\t.listxattr\t= ovl_listxattr,\n\t.get_inode_acl\t= ovl_get_inode_acl,\n\t.get_acl\t= ovl_get_acl,\n\t.set_acl\t= ovl_set_acl,\n\t.update_time\t= ovl_update_time,\n};\n\nstatic const struct address_space_operations ovl_aops = {\n\t \n\t.direct_IO\t\t= noop_direct_IO,\n};\n\n \n#define OVL_MAX_NESTING FILESYSTEM_MAX_STACK_DEPTH\n\nstatic inline void ovl_lockdep_annotate_inode_mutex_key(struct inode *inode)\n{\n#ifdef CONFIG_LOCKDEP\n\tstatic struct lock_class_key ovl_i_mutex_key[OVL_MAX_NESTING];\n\tstatic struct lock_class_key ovl_i_mutex_dir_key[OVL_MAX_NESTING];\n\tstatic struct lock_class_key ovl_i_lock_key[OVL_MAX_NESTING];\n\n\tint depth = inode->i_sb->s_stack_depth - 1;\n\n\tif (WARN_ON_ONCE(depth < 0 || depth >= OVL_MAX_NESTING))\n\t\tdepth = 0;\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tlockdep_set_class(&inode->i_rwsem, &ovl_i_mutex_dir_key[depth]);\n\telse\n\t\tlockdep_set_class(&inode->i_rwsem, &ovl_i_mutex_key[depth]);\n\n\tlockdep_set_class(&OVL_I(inode)->lock, &ovl_i_lock_key[depth]);\n#endif\n}\n\nstatic void ovl_next_ino(struct inode *inode)\n{\n\tstruct ovl_fs *ofs = OVL_FS(inode->i_sb);\n\n\tinode->i_ino = atomic_long_inc_return(&ofs->last_ino);\n\tif (unlikely(!inode->i_ino))\n\t\tinode->i_ino = atomic_long_inc_return(&ofs->last_ino);\n}\n\nstatic void ovl_map_ino(struct inode *inode, unsigned long ino, int fsid)\n{\n\tstruct ovl_fs *ofs = OVL_FS(inode->i_sb);\n\tint xinobits = ovl_xino_bits(ofs);\n\tunsigned int xinoshift = 64 - xinobits;\n\n\t \n\tinode->i_ino = ino;\n\tif (ovl_same_fs(ofs)) {\n\t\treturn;\n\t} else if (xinobits && likely(!(ino >> xinoshift))) {\n\t\tinode->i_ino |= (unsigned long)fsid << (xinoshift + 1);\n\t\treturn;\n\t}\n\n\t \n\tif (S_ISDIR(inode->i_mode)) {\n\t\tovl_next_ino(inode);\n\t\tif (xinobits) {\n\t\t\tinode->i_ino &= ~0UL >> xinobits;\n\t\t\tinode->i_ino |= 1UL << xinoshift;\n\t\t}\n\t}\n}\n\nvoid ovl_inode_init(struct inode *inode, struct ovl_inode_params *oip,\n\t\t    unsigned long ino, int fsid)\n{\n\tstruct inode *realinode;\n\tstruct ovl_inode *oi = OVL_I(inode);\n\n\toi->__upperdentry = oip->upperdentry;\n\toi->oe = oip->oe;\n\toi->redirect = oip->redirect;\n\toi->lowerdata_redirect = oip->lowerdata_redirect;\n\n\trealinode = ovl_inode_real(inode);\n\tovl_copyattr(inode);\n\tovl_copyflags(realinode, inode);\n\tovl_map_ino(inode, ino, fsid);\n}\n\nstatic void ovl_fill_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tinode->i_flags |= S_NOCMTIME;\n#ifdef CONFIG_FS_POSIX_ACL\n\tinode->i_acl = inode->i_default_acl = ACL_DONT_CACHE;\n#endif\n\n\tovl_lockdep_annotate_inode_mutex_key(inode);\n\n\tswitch (mode & S_IFMT) {\n\tcase S_IFREG:\n\t\tinode->i_op = &ovl_file_inode_operations;\n\t\tinode->i_fop = &ovl_file_operations;\n\t\tinode->i_mapping->a_ops = &ovl_aops;\n\t\tbreak;\n\n\tcase S_IFDIR:\n\t\tinode->i_op = &ovl_dir_inode_operations;\n\t\tinode->i_fop = &ovl_dir_operations;\n\t\tbreak;\n\n\tcase S_IFLNK:\n\t\tinode->i_op = &ovl_symlink_inode_operations;\n\t\tbreak;\n\n\tdefault:\n\t\tinode->i_op = &ovl_special_inode_operations;\n\t\tinit_special_inode(inode, mode, rdev);\n\t\tbreak;\n\t}\n}\n\n \n#define OVL_NLINK_ADD_UPPER\t(1 << 0)\n\n \n\nstatic int ovl_set_nlink_common(struct dentry *dentry,\n\t\t\t\tstruct dentry *realdentry, const char *format)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct inode *realinode = d_inode(realdentry);\n\tchar buf[13];\n\tint len;\n\n\tlen = snprintf(buf, sizeof(buf), format,\n\t\t       (int) (inode->i_nlink - realinode->i_nlink));\n\n\tif (WARN_ON(len >= sizeof(buf)))\n\t\treturn -EIO;\n\n\treturn ovl_setxattr(OVL_FS(inode->i_sb), ovl_dentry_upper(dentry),\n\t\t\t    OVL_XATTR_NLINK, buf, len);\n}\n\nint ovl_set_nlink_upper(struct dentry *dentry)\n{\n\treturn ovl_set_nlink_common(dentry, ovl_dentry_upper(dentry), \"U%+i\");\n}\n\nint ovl_set_nlink_lower(struct dentry *dentry)\n{\n\treturn ovl_set_nlink_common(dentry, ovl_dentry_lower(dentry), \"L%+i\");\n}\n\nunsigned int ovl_get_nlink(struct ovl_fs *ofs, struct dentry *lowerdentry,\n\t\t\t   struct dentry *upperdentry,\n\t\t\t   unsigned int fallback)\n{\n\tint nlink_diff;\n\tint nlink;\n\tchar buf[13];\n\tint err;\n\n\tif (!lowerdentry || !upperdentry || d_inode(lowerdentry)->i_nlink == 1)\n\t\treturn fallback;\n\n\terr = ovl_getxattr_upper(ofs, upperdentry, OVL_XATTR_NLINK,\n\t\t\t\t &buf, sizeof(buf) - 1);\n\tif (err < 0)\n\t\tgoto fail;\n\n\tbuf[err] = '\\0';\n\tif ((buf[0] != 'L' && buf[0] != 'U') ||\n\t    (buf[1] != '+' && buf[1] != '-'))\n\t\tgoto fail;\n\n\terr = kstrtoint(buf + 1, 10, &nlink_diff);\n\tif (err < 0)\n\t\tgoto fail;\n\n\tnlink = d_inode(buf[0] == 'L' ? lowerdentry : upperdentry)->i_nlink;\n\tnlink += nlink_diff;\n\n\tif (nlink <= 0)\n\t\tgoto fail;\n\n\treturn nlink;\n\nfail:\n\tpr_warn_ratelimited(\"failed to get index nlink (%pd2, err=%i)\\n\",\n\t\t\t    upperdentry, err);\n\treturn fallback;\n}\n\nstruct inode *ovl_new_inode(struct super_block *sb, umode_t mode, dev_t rdev)\n{\n\tstruct inode *inode;\n\n\tinode = new_inode(sb);\n\tif (inode)\n\t\tovl_fill_inode(inode, mode, rdev);\n\n\treturn inode;\n}\n\nstatic int ovl_inode_test(struct inode *inode, void *data)\n{\n\treturn inode->i_private == data;\n}\n\nstatic int ovl_inode_set(struct inode *inode, void *data)\n{\n\tinode->i_private = data;\n\treturn 0;\n}\n\nstatic bool ovl_verify_inode(struct inode *inode, struct dentry *lowerdentry,\n\t\t\t     struct dentry *upperdentry, bool strict)\n{\n\t \n\tif (S_ISDIR(inode->i_mode) && strict) {\n\t\t \n\t\tif (!lowerdentry && ovl_inode_lower(inode))\n\t\t\treturn false;\n\n\t\t \n\t\tif (!upperdentry && ovl_inode_upper(inode))\n\t\t\treturn false;\n\t}\n\n\t \n\tif (lowerdentry && ovl_inode_lower(inode) != d_inode(lowerdentry))\n\t\treturn false;\n\n\t \n\tif (upperdentry && ovl_inode_upper(inode) != d_inode(upperdentry))\n\t\treturn false;\n\n\treturn true;\n}\n\nstruct inode *ovl_lookup_inode(struct super_block *sb, struct dentry *real,\n\t\t\t       bool is_upper)\n{\n\tstruct inode *inode, *key = d_inode(real);\n\n\tinode = ilookup5(sb, (unsigned long) key, ovl_inode_test, key);\n\tif (!inode)\n\t\treturn NULL;\n\n\tif (!ovl_verify_inode(inode, is_upper ? NULL : real,\n\t\t\t      is_upper ? real : NULL, false)) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ESTALE);\n\t}\n\n\treturn inode;\n}\n\nbool ovl_lookup_trap_inode(struct super_block *sb, struct dentry *dir)\n{\n\tstruct inode *key = d_inode(dir);\n\tstruct inode *trap;\n\tbool res;\n\n\ttrap = ilookup5(sb, (unsigned long) key, ovl_inode_test, key);\n\tif (!trap)\n\t\treturn false;\n\n\tres = IS_DEADDIR(trap) && !ovl_inode_upper(trap) &&\n\t\t\t\t  !ovl_inode_lower(trap);\n\n\tiput(trap);\n\treturn res;\n}\n\n \nstruct inode *ovl_get_trap_inode(struct super_block *sb, struct dentry *dir)\n{\n\tstruct inode *key = d_inode(dir);\n\tstruct inode *trap;\n\n\tif (!d_is_dir(dir))\n\t\treturn ERR_PTR(-ENOTDIR);\n\n\ttrap = iget5_locked(sb, (unsigned long) key, ovl_inode_test,\n\t\t\t    ovl_inode_set, key);\n\tif (!trap)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!(trap->i_state & I_NEW)) {\n\t\t \n\t\tiput(trap);\n\t\treturn ERR_PTR(-ELOOP);\n\t}\n\n\ttrap->i_mode = S_IFDIR;\n\ttrap->i_flags = S_DEAD;\n\tunlock_new_inode(trap);\n\n\treturn trap;\n}\n\n \nstatic bool ovl_hash_bylower(struct super_block *sb, struct dentry *upper,\n\t\t\t     struct dentry *lower, bool index)\n{\n\tstruct ovl_fs *ofs = OVL_FS(sb);\n\n\t \n\tif (!lower)\n\t\treturn false;\n\n\t \n\tif (index)\n\t\treturn true;\n\n\t \n\tif (!ovl_upper_mnt(ofs))\n\t\treturn true;\n\n\t \n\tif ((upper || !ovl_indexdir(sb)) &&\n\t    !d_is_dir(lower) && d_inode(lower)->i_nlink > 1)\n\t\treturn false;\n\n\t \n\tif (ofs->config.nfs_export && upper)\n\t\treturn false;\n\n\t \n\treturn true;\n}\n\nstatic struct inode *ovl_iget5(struct super_block *sb, struct inode *newinode,\n\t\t\t       struct inode *key)\n{\n\treturn newinode ? inode_insert5(newinode, (unsigned long) key,\n\t\t\t\t\t ovl_inode_test, ovl_inode_set, key) :\n\t\t\t  iget5_locked(sb, (unsigned long) key,\n\t\t\t\t       ovl_inode_test, ovl_inode_set, key);\n}\n\nstruct inode *ovl_get_inode(struct super_block *sb,\n\t\t\t    struct ovl_inode_params *oip)\n{\n\tstruct ovl_fs *ofs = OVL_FS(sb);\n\tstruct dentry *upperdentry = oip->upperdentry;\n\tstruct ovl_path *lowerpath = ovl_lowerpath(oip->oe);\n\tstruct inode *realinode = upperdentry ? d_inode(upperdentry) : NULL;\n\tstruct inode *inode;\n\tstruct dentry *lowerdentry = lowerpath ? lowerpath->dentry : NULL;\n\tstruct path realpath = {\n\t\t.dentry = upperdentry ?: lowerdentry,\n\t\t.mnt = upperdentry ? ovl_upper_mnt(ofs) : lowerpath->layer->mnt,\n\t};\n\tbool bylower = ovl_hash_bylower(sb, upperdentry, lowerdentry,\n\t\t\t\t\toip->index);\n\tint fsid = bylower ? lowerpath->layer->fsid : 0;\n\tbool is_dir;\n\tunsigned long ino = 0;\n\tint err = oip->newinode ? -EEXIST : -ENOMEM;\n\n\tif (!realinode)\n\t\trealinode = d_inode(lowerdentry);\n\n\t \n\tis_dir = S_ISDIR(realinode->i_mode);\n\tif (upperdentry || bylower) {\n\t\tstruct inode *key = d_inode(bylower ? lowerdentry :\n\t\t\t\t\t\t      upperdentry);\n\t\tunsigned int nlink = is_dir ? 1 : realinode->i_nlink;\n\n\t\tinode = ovl_iget5(sb, oip->newinode, key);\n\t\tif (!inode)\n\t\t\tgoto out_err;\n\t\tif (!(inode->i_state & I_NEW)) {\n\t\t\t \n\t\t\tif (!ovl_verify_inode(inode, lowerdentry, upperdentry,\n\t\t\t\t\t      true)) {\n\t\t\t\tiput(inode);\n\t\t\t\terr = -ESTALE;\n\t\t\t\tgoto out_err;\n\t\t\t}\n\n\t\t\tdput(upperdentry);\n\t\t\tovl_free_entry(oip->oe);\n\t\t\tkfree(oip->redirect);\n\t\t\tkfree(oip->lowerdata_redirect);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif (!is_dir)\n\t\t\tnlink = ovl_get_nlink(ofs, lowerdentry, upperdentry,\n\t\t\t\t\t      nlink);\n\t\tset_nlink(inode, nlink);\n\t\tino = key->i_ino;\n\t} else {\n\t\t \n\t\tinode = new_inode(sb);\n\t\tif (!inode) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_err;\n\t\t}\n\t\tino = realinode->i_ino;\n\t\tfsid = lowerpath->layer->fsid;\n\t}\n\tovl_fill_inode(inode, realinode->i_mode, realinode->i_rdev);\n\tovl_inode_init(inode, oip, ino, fsid);\n\n\tif (upperdentry && ovl_is_impuredir(sb, upperdentry))\n\t\tovl_set_flag(OVL_IMPURE, inode);\n\n\tif (oip->index)\n\t\tovl_set_flag(OVL_INDEX, inode);\n\n\tif (bylower)\n\t\tovl_set_flag(OVL_CONST_INO, inode);\n\n\t \n\tif (is_dir) {\n\t\tif (((upperdentry && lowerdentry) || ovl_numlower(oip->oe) > 1) ||\n\t\t    ovl_path_check_origin_xattr(ofs, &realpath)) {\n\t\t\tovl_set_flag(OVL_WHITEOUTS, inode);\n\t\t}\n\t}\n\n\t \n\tif (upperdentry)\n\t\tovl_check_protattr(inode, upperdentry);\n\n\tif (inode->i_state & I_NEW)\n\t\tunlock_new_inode(inode);\nout:\n\treturn inode;\n\nout_err:\n\tpr_warn_ratelimited(\"failed to get inode (%i)\\n\", err);\n\tinode = ERR_PTR(err);\n\tgoto out;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}