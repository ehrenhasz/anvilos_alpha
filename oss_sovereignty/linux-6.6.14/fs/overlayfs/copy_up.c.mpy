{
  "module_name": "copy_up.c",
  "hash_id": "530215d9a3fec0402096d5a21170913c43300d14c7b9e20d3563f05c396d878a",
  "original_prompt": "Ingested from linux-6.6.14/fs/overlayfs/copy_up.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/fileattr.h>\n#include <linux/splice.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/cred.h>\n#include <linux/namei.h>\n#include <linux/fdtable.h>\n#include <linux/ratelimit.h>\n#include <linux/exportfs.h>\n#include \"overlayfs.h\"\n\n#define OVL_COPY_UP_CHUNK_SIZE (1 << 20)\n\nstatic int ovl_ccup_set(const char *buf, const struct kernel_param *param)\n{\n\tpr_warn(\"\\\"check_copy_up\\\" module option is obsolete\\n\");\n\treturn 0;\n}\n\nstatic int ovl_ccup_get(char *buf, const struct kernel_param *param)\n{\n\treturn sprintf(buf, \"N\\n\");\n}\n\nmodule_param_call(check_copy_up, ovl_ccup_set, ovl_ccup_get, NULL, 0644);\nMODULE_PARM_DESC(check_copy_up, \"Obsolete; does nothing\");\n\nstatic bool ovl_must_copy_xattr(const char *name)\n{\n\treturn !strcmp(name, XATTR_POSIX_ACL_ACCESS) ||\n\t       !strcmp(name, XATTR_POSIX_ACL_DEFAULT) ||\n\t       !strncmp(name, XATTR_SECURITY_PREFIX, XATTR_SECURITY_PREFIX_LEN);\n}\n\nstatic int ovl_copy_acl(struct ovl_fs *ofs, const struct path *path,\n\t\t\tstruct dentry *dentry, const char *acl_name)\n{\n\tint err;\n\tstruct posix_acl *clone, *real_acl = NULL;\n\n\treal_acl = ovl_get_acl_path(path, acl_name, false);\n\tif (!real_acl)\n\t\treturn 0;\n\n\tif (IS_ERR(real_acl)) {\n\t\terr = PTR_ERR(real_acl);\n\t\tif (err == -ENODATA || err == -EOPNOTSUPP)\n\t\t\treturn 0;\n\t\treturn err;\n\t}\n\n\tclone = posix_acl_clone(real_acl, GFP_KERNEL);\n\tposix_acl_release(real_acl);  \n\tif (!clone)\n\t\treturn -ENOMEM;\n\n\terr = ovl_do_set_acl(ofs, dentry, acl_name, clone);\n\n\t \n\tposix_acl_release(clone);\n\treturn err;\n}\n\nint ovl_copy_xattr(struct super_block *sb, const struct path *oldpath, struct dentry *new)\n{\n\tstruct dentry *old = oldpath->dentry;\n\tssize_t list_size, size, value_size = 0;\n\tchar *buf, *name, *value = NULL;\n\tint error = 0;\n\tsize_t slen;\n\n\tif (!old->d_inode->i_op->listxattr || !new->d_inode->i_op->listxattr)\n\t\treturn 0;\n\n\tlist_size = vfs_listxattr(old, NULL, 0);\n\tif (list_size <= 0) {\n\t\tif (list_size == -EOPNOTSUPP)\n\t\t\treturn 0;\n\t\treturn list_size;\n\t}\n\n\tbuf = kvzalloc(list_size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tlist_size = vfs_listxattr(old, buf, list_size);\n\tif (list_size <= 0) {\n\t\terror = list_size;\n\t\tgoto out;\n\t}\n\n\tfor (name = buf; list_size; name += slen) {\n\t\tslen = strnlen(name, list_size) + 1;\n\n\t\t \n\t\tif (WARN_ON(slen > list_size)) {\n\t\t\terror = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tlist_size -= slen;\n\n\t\tif (ovl_is_private_xattr(sb, name))\n\t\t\tcontinue;\n\n\t\terror = security_inode_copy_up_xattr(name);\n\t\tif (error < 0 && error != -EOPNOTSUPP)\n\t\t\tbreak;\n\t\tif (error == 1) {\n\t\t\terror = 0;\n\t\t\tcontinue;  \n\t\t}\n\n\t\tif (is_posix_acl_xattr(name)) {\n\t\t\terror = ovl_copy_acl(OVL_FS(sb), oldpath, new, name);\n\t\t\tif (!error)\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\nretry:\n\t\tsize = ovl_do_getxattr(oldpath, name, value, value_size);\n\t\tif (size == -ERANGE)\n\t\t\tsize = ovl_do_getxattr(oldpath, name, NULL, 0);\n\n\t\tif (size < 0) {\n\t\t\terror = size;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (size > value_size) {\n\t\t\tvoid *new;\n\n\t\t\tnew = kvmalloc(size, GFP_KERNEL);\n\t\t\tif (!new) {\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tkvfree(value);\n\t\t\tvalue = new;\n\t\t\tvalue_size = size;\n\t\t\tgoto retry;\n\t\t}\n\n\t\terror = ovl_do_setxattr(OVL_FS(sb), new, name, value, size, 0);\n\t\tif (error) {\n\t\t\tif (error != -EOPNOTSUPP || ovl_must_copy_xattr(name))\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\terror = 0;\n\t\t}\n\t}\n\tkvfree(value);\nout:\n\tkvfree(buf);\n\treturn error;\n}\n\nstatic int ovl_copy_fileattr(struct inode *inode, const struct path *old,\n\t\t\t     const struct path *new)\n{\n\tstruct fileattr oldfa = { .flags_valid = true };\n\tstruct fileattr newfa = { .flags_valid = true };\n\tint err;\n\n\terr = ovl_real_fileattr_get(old, &oldfa);\n\tif (err) {\n\t\t \n\t\tif (err == -ENOTTY || err == -EINVAL)\n\t\t\treturn 0;\n\t\tpr_warn(\"failed to retrieve lower fileattr (%pd2, err=%i)\\n\",\n\t\t\told->dentry, err);\n\t\treturn err;\n\t}\n\n\t \n\tif (oldfa.flags & OVL_PROT_FS_FLAGS_MASK) {\n\t\terr = ovl_set_protattr(inode, new->dentry, &oldfa);\n\t\tif (err == -EPERM)\n\t\t\tpr_warn_once(\"copying fileattr: no xattr on upper\\n\");\n\t\telse if (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tif (!(oldfa.flags & OVL_COPY_FS_FLAGS_MASK))\n\t\treturn 0;\n\n\terr = ovl_real_fileattr_get(new, &newfa);\n\tif (err) {\n\t\t \n\t\tif (err == -ENOTTY || err == -EINVAL) {\n\t\t\tpr_warn_once(\"copying fileattr: no support on upper\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tpr_warn(\"failed to retrieve upper fileattr (%pd2, err=%i)\\n\",\n\t\t\tnew->dentry, err);\n\t\treturn err;\n\t}\n\n\tBUILD_BUG_ON(OVL_COPY_FS_FLAGS_MASK & ~FS_COMMON_FL);\n\tnewfa.flags &= ~OVL_COPY_FS_FLAGS_MASK;\n\tnewfa.flags |= (oldfa.flags & OVL_COPY_FS_FLAGS_MASK);\n\n\tBUILD_BUG_ON(OVL_COPY_FSX_FLAGS_MASK & ~FS_XFLAG_COMMON);\n\tnewfa.fsx_xflags &= ~OVL_COPY_FSX_FLAGS_MASK;\n\tnewfa.fsx_xflags |= (oldfa.fsx_xflags & OVL_COPY_FSX_FLAGS_MASK);\n\n\treturn ovl_real_fileattr_set(new, &newfa);\n}\n\nstatic int ovl_copy_up_file(struct ovl_fs *ofs, struct dentry *dentry,\n\t\t\t    struct file *new_file, loff_t len)\n{\n\tstruct path datapath;\n\tstruct file *old_file;\n\tloff_t old_pos = 0;\n\tloff_t new_pos = 0;\n\tloff_t cloned;\n\tloff_t data_pos = -1;\n\tloff_t hole_len;\n\tbool skip_hole = false;\n\tint error = 0;\n\n\tovl_path_lowerdata(dentry, &datapath);\n\tif (WARN_ON(datapath.dentry == NULL))\n\t\treturn -EIO;\n\n\told_file = ovl_path_open(&datapath, O_LARGEFILE | O_RDONLY);\n\tif (IS_ERR(old_file))\n\t\treturn PTR_ERR(old_file);\n\n\t \n\tcloned = do_clone_file_range(old_file, 0, new_file, 0, len, 0);\n\tif (cloned == len)\n\t\tgoto out_fput;\n\t \n\n\t \n\tif (old_file->f_mode & FMODE_LSEEK)\n\t\tskip_hole = true;\n\n\twhile (len) {\n\t\tsize_t this_len = OVL_COPY_UP_CHUNK_SIZE;\n\t\tlong bytes;\n\n\t\tif (len < this_len)\n\t\t\tthis_len = len;\n\n\t\tif (signal_pending_state(TASK_KILLABLE, current)) {\n\t\t\terror = -EINTR;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\n\t\tif (skip_hole && data_pos < old_pos) {\n\t\t\tdata_pos = vfs_llseek(old_file, old_pos, SEEK_DATA);\n\t\t\tif (data_pos > old_pos) {\n\t\t\t\thole_len = data_pos - old_pos;\n\t\t\t\tlen -= hole_len;\n\t\t\t\told_pos = new_pos = data_pos;\n\t\t\t\tcontinue;\n\t\t\t} else if (data_pos == -ENXIO) {\n\t\t\t\tbreak;\n\t\t\t} else if (data_pos < 0) {\n\t\t\t\tskip_hole = false;\n\t\t\t}\n\t\t}\n\n\t\tbytes = do_splice_direct(old_file, &old_pos,\n\t\t\t\t\t new_file, &new_pos,\n\t\t\t\t\t this_len, SPLICE_F_MOVE);\n\t\tif (bytes <= 0) {\n\t\t\terror = bytes;\n\t\t\tbreak;\n\t\t}\n\t\tWARN_ON(old_pos != new_pos);\n\n\t\tlen -= bytes;\n\t}\n\tif (!error && ovl_should_sync(ofs))\n\t\terror = vfs_fsync(new_file, 0);\nout_fput:\n\tfput(old_file);\n\treturn error;\n}\n\nstatic int ovl_set_size(struct ovl_fs *ofs,\n\t\t\tstruct dentry *upperdentry, struct kstat *stat)\n{\n\tstruct iattr attr = {\n\t\t.ia_valid = ATTR_SIZE,\n\t\t.ia_size = stat->size,\n\t};\n\n\treturn ovl_do_notify_change(ofs, upperdentry, &attr);\n}\n\nstatic int ovl_set_timestamps(struct ovl_fs *ofs, struct dentry *upperdentry,\n\t\t\t      struct kstat *stat)\n{\n\tstruct iattr attr = {\n\t\t.ia_valid =\n\t\t     ATTR_ATIME | ATTR_MTIME | ATTR_ATIME_SET | ATTR_MTIME_SET | ATTR_CTIME,\n\t\t.ia_atime = stat->atime,\n\t\t.ia_mtime = stat->mtime,\n\t};\n\n\treturn ovl_do_notify_change(ofs, upperdentry, &attr);\n}\n\nint ovl_set_attr(struct ovl_fs *ofs, struct dentry *upperdentry,\n\t\t struct kstat *stat)\n{\n\tint err = 0;\n\n\tif (!S_ISLNK(stat->mode)) {\n\t\tstruct iattr attr = {\n\t\t\t.ia_valid = ATTR_MODE,\n\t\t\t.ia_mode = stat->mode,\n\t\t};\n\t\terr = ovl_do_notify_change(ofs, upperdentry, &attr);\n\t}\n\tif (!err) {\n\t\tstruct iattr attr = {\n\t\t\t.ia_valid = ATTR_UID | ATTR_GID,\n\t\t\t.ia_vfsuid = VFSUIDT_INIT(stat->uid),\n\t\t\t.ia_vfsgid = VFSGIDT_INIT(stat->gid),\n\t\t};\n\t\terr = ovl_do_notify_change(ofs, upperdentry, &attr);\n\t}\n\tif (!err)\n\t\tovl_set_timestamps(ofs, upperdentry, stat);\n\n\treturn err;\n}\n\nstruct ovl_fh *ovl_encode_real_fh(struct ovl_fs *ofs, struct dentry *real,\n\t\t\t\t  bool is_upper)\n{\n\tstruct ovl_fh *fh;\n\tint fh_type, dwords;\n\tint buflen = MAX_HANDLE_SZ;\n\tuuid_t *uuid = &real->d_sb->s_uuid;\n\tint err;\n\n\t \n\tBUILD_BUG_ON(OVL_FH_FID_OFFSET % 4);\n\tBUILD_BUG_ON(MAX_HANDLE_SZ + OVL_FH_FID_OFFSET > 255);\n\n\tfh = kzalloc(buflen + OVL_FH_FID_OFFSET, GFP_KERNEL);\n\tif (!fh)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tdwords = buflen >> 2;\n\tfh_type = exportfs_encode_fh(real, (void *)fh->fb.fid, &dwords, 0);\n\tbuflen = (dwords << 2);\n\n\terr = -EIO;\n\tif (WARN_ON(fh_type < 0) ||\n\t    WARN_ON(buflen > MAX_HANDLE_SZ) ||\n\t    WARN_ON(fh_type == FILEID_INVALID))\n\t\tgoto out_err;\n\n\tfh->fb.version = OVL_FH_VERSION;\n\tfh->fb.magic = OVL_FH_MAGIC;\n\tfh->fb.type = fh_type;\n\tfh->fb.flags = OVL_FH_FLAG_CPU_ENDIAN;\n\t \n\tif (is_upper)\n\t\tfh->fb.flags |= OVL_FH_FLAG_PATH_UPPER;\n\tfh->fb.len = sizeof(fh->fb) + buflen;\n\tif (ovl_origin_uuid(ofs))\n\t\tfh->fb.uuid = *uuid;\n\n\treturn fh;\n\nout_err:\n\tkfree(fh);\n\treturn ERR_PTR(err);\n}\n\nint ovl_set_origin(struct ovl_fs *ofs, struct dentry *lower,\n\t\t   struct dentry *upper)\n{\n\tconst struct ovl_fh *fh = NULL;\n\tint err;\n\n\t \n\tif (ovl_can_decode_fh(lower->d_sb)) {\n\t\tfh = ovl_encode_real_fh(ofs, lower, false);\n\t\tif (IS_ERR(fh))\n\t\t\treturn PTR_ERR(fh);\n\t}\n\n\t \n\terr = ovl_check_setxattr(ofs, upper, OVL_XATTR_ORIGIN, fh->buf,\n\t\t\t\t fh ? fh->fb.len : 0, 0);\n\tkfree(fh);\n\n\t \n\treturn err == -EPERM ? 0 : err;\n}\n\n \nstatic int ovl_set_upper_fh(struct ovl_fs *ofs, struct dentry *upper,\n\t\t\t    struct dentry *index)\n{\n\tconst struct ovl_fh *fh;\n\tint err;\n\n\tfh = ovl_encode_real_fh(ofs, upper, true);\n\tif (IS_ERR(fh))\n\t\treturn PTR_ERR(fh);\n\n\terr = ovl_setxattr(ofs, index, OVL_XATTR_UPPER, fh->buf, fh->fb.len);\n\n\tkfree(fh);\n\treturn err;\n}\n\n \nstatic int ovl_create_index(struct dentry *dentry, struct dentry *origin,\n\t\t\t    struct dentry *upper)\n{\n\tstruct ovl_fs *ofs = OVL_FS(dentry->d_sb);\n\tstruct dentry *indexdir = ovl_indexdir(dentry->d_sb);\n\tstruct inode *dir = d_inode(indexdir);\n\tstruct dentry *index = NULL;\n\tstruct dentry *temp = NULL;\n\tstruct qstr name = { };\n\tint err;\n\n\t \n\tif (WARN_ON(!d_is_dir(dentry)))\n\t\treturn -EIO;\n\n\t \n\tif (WARN_ON(ovl_test_flag(OVL_INDEX, d_inode(dentry))))\n\t\treturn -EIO;\n\n\terr = ovl_get_index_name(ofs, origin, &name);\n\tif (err)\n\t\treturn err;\n\n\ttemp = ovl_create_temp(ofs, indexdir, OVL_CATTR(S_IFDIR | 0));\n\terr = PTR_ERR(temp);\n\tif (IS_ERR(temp))\n\t\tgoto free_name;\n\n\terr = ovl_set_upper_fh(ofs, upper, temp);\n\tif (err)\n\t\tgoto out;\n\n\tindex = ovl_lookup_upper(ofs, name.name, indexdir, name.len);\n\tif (IS_ERR(index)) {\n\t\terr = PTR_ERR(index);\n\t} else {\n\t\terr = ovl_do_rename(ofs, dir, temp, dir, index, 0);\n\t\tdput(index);\n\t}\nout:\n\tif (err)\n\t\tovl_cleanup(ofs, dir, temp);\n\tdput(temp);\nfree_name:\n\tkfree(name.name);\n\treturn err;\n}\n\nstruct ovl_copy_up_ctx {\n\tstruct dentry *parent;\n\tstruct dentry *dentry;\n\tstruct path lowerpath;\n\tstruct kstat stat;\n\tstruct kstat pstat;\n\tconst char *link;\n\tstruct dentry *destdir;\n\tstruct qstr destname;\n\tstruct dentry *workdir;\n\tbool origin;\n\tbool indexed;\n\tbool metacopy;\n\tbool metacopy_digest;\n};\n\nstatic int ovl_link_up(struct ovl_copy_up_ctx *c)\n{\n\tint err;\n\tstruct dentry *upper;\n\tstruct dentry *upperdir = ovl_dentry_upper(c->parent);\n\tstruct ovl_fs *ofs = OVL_FS(c->dentry->d_sb);\n\tstruct inode *udir = d_inode(upperdir);\n\n\t \n\terr = ovl_set_impure(c->parent, upperdir);\n\tif (err)\n\t\treturn err;\n\n\terr = ovl_set_nlink_lower(c->dentry);\n\tif (err)\n\t\treturn err;\n\n\tinode_lock_nested(udir, I_MUTEX_PARENT);\n\tupper = ovl_lookup_upper(ofs, c->dentry->d_name.name, upperdir,\n\t\t\t\t c->dentry->d_name.len);\n\terr = PTR_ERR(upper);\n\tif (!IS_ERR(upper)) {\n\t\terr = ovl_do_link(ofs, ovl_dentry_upper(c->dentry), udir, upper);\n\t\tdput(upper);\n\n\t\tif (!err) {\n\t\t\t \n\t\t\tovl_set_timestamps(ofs, upperdir, &c->pstat);\n\t\t\tovl_dentry_set_upper_alias(c->dentry);\n\t\t\tovl_dentry_update_reval(c->dentry, upper);\n\t\t}\n\t}\n\tinode_unlock(udir);\n\tif (err)\n\t\treturn err;\n\n\terr = ovl_set_nlink_upper(c->dentry);\n\n\treturn err;\n}\n\nstatic int ovl_copy_up_data(struct ovl_copy_up_ctx *c, const struct path *temp)\n{\n\tstruct ovl_fs *ofs = OVL_FS(c->dentry->d_sb);\n\tstruct file *new_file;\n\tint err;\n\n\tif (!S_ISREG(c->stat.mode) || c->metacopy || !c->stat.size)\n\t\treturn 0;\n\n\tnew_file = ovl_path_open(temp, O_LARGEFILE | O_WRONLY);\n\tif (IS_ERR(new_file))\n\t\treturn PTR_ERR(new_file);\n\n\terr = ovl_copy_up_file(ofs, c->dentry, new_file, c->stat.size);\n\tfput(new_file);\n\n\treturn err;\n}\n\nstatic int ovl_copy_up_metadata(struct ovl_copy_up_ctx *c, struct dentry *temp)\n{\n\tstruct ovl_fs *ofs = OVL_FS(c->dentry->d_sb);\n\tstruct inode *inode = d_inode(c->dentry);\n\tstruct path upperpath = { .mnt = ovl_upper_mnt(ofs), .dentry = temp };\n\tint err;\n\n\terr = ovl_copy_xattr(c->dentry->d_sb, &c->lowerpath, temp);\n\tif (err)\n\t\treturn err;\n\n\tif (inode->i_flags & OVL_COPY_I_FLAGS_MASK &&\n\t    (S_ISREG(c->stat.mode) || S_ISDIR(c->stat.mode))) {\n\t\t \n\t\terr = ovl_copy_fileattr(inode, &c->lowerpath, &upperpath);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tif (c->origin) {\n\t\terr = ovl_set_origin(ofs, c->lowerpath.dentry, temp);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (c->metacopy) {\n\t\tstruct path lowerdatapath;\n\t\tstruct ovl_metacopy metacopy_data = OVL_METACOPY_INIT;\n\n\t\tovl_path_lowerdata(c->dentry, &lowerdatapath);\n\t\tif (WARN_ON_ONCE(lowerdatapath.dentry == NULL))\n\t\t\treturn -EIO;\n\t\terr = ovl_get_verity_digest(ofs, &lowerdatapath, &metacopy_data);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (metacopy_data.digest_algo)\n\t\t\tc->metacopy_digest = true;\n\n\t\terr = ovl_set_metacopy_xattr(ofs, temp, &metacopy_data);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tinode_lock(temp->d_inode);\n\tif (S_ISREG(c->stat.mode))\n\t\terr = ovl_set_size(ofs, temp, &c->stat);\n\tif (!err)\n\t\terr = ovl_set_attr(ofs, temp, &c->stat);\n\tinode_unlock(temp->d_inode);\n\n\treturn err;\n}\n\nstruct ovl_cu_creds {\n\tconst struct cred *old;\n\tstruct cred *new;\n};\n\nstatic int ovl_prep_cu_creds(struct dentry *dentry, struct ovl_cu_creds *cc)\n{\n\tint err;\n\n\tcc->old = cc->new = NULL;\n\terr = security_inode_copy_up(dentry, &cc->new);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (cc->new)\n\t\tcc->old = override_creds(cc->new);\n\n\treturn 0;\n}\n\nstatic void ovl_revert_cu_creds(struct ovl_cu_creds *cc)\n{\n\tif (cc->new) {\n\t\trevert_creds(cc->old);\n\t\tput_cred(cc->new);\n\t}\n}\n\n \nstatic int ovl_copy_up_workdir(struct ovl_copy_up_ctx *c)\n{\n\tstruct ovl_fs *ofs = OVL_FS(c->dentry->d_sb);\n\tstruct inode *inode;\n\tstruct inode *udir = d_inode(c->destdir), *wdir = d_inode(c->workdir);\n\tstruct path path = { .mnt = ovl_upper_mnt(ofs) };\n\tstruct dentry *temp, *upper;\n\tstruct ovl_cu_creds cc;\n\tint err;\n\tstruct ovl_cattr cattr = {\n\t\t \n\t\t.mode = c->stat.mode & S_IFMT,\n\t\t.rdev = c->stat.rdev,\n\t\t.link = c->link\n\t};\n\n\t \n\terr = -EIO;\n\tif (lock_rename(c->workdir, c->destdir) != NULL)\n\t\tgoto unlock;\n\n\terr = ovl_prep_cu_creds(c->dentry, &cc);\n\tif (err)\n\t\tgoto unlock;\n\n\ttemp = ovl_create_temp(ofs, c->workdir, &cattr);\n\tovl_revert_cu_creds(&cc);\n\n\terr = PTR_ERR(temp);\n\tif (IS_ERR(temp))\n\t\tgoto unlock;\n\n\t \n\tpath.dentry = temp;\n\terr = ovl_copy_up_data(c, &path);\n\tif (err)\n\t\tgoto cleanup;\n\n\terr = ovl_copy_up_metadata(c, temp);\n\tif (err)\n\t\tgoto cleanup;\n\n\tif (S_ISDIR(c->stat.mode) && c->indexed) {\n\t\terr = ovl_create_index(c->dentry, c->lowerpath.dentry, temp);\n\t\tif (err)\n\t\t\tgoto cleanup;\n\t}\n\n\tupper = ovl_lookup_upper(ofs, c->destname.name, c->destdir,\n\t\t\t\t c->destname.len);\n\terr = PTR_ERR(upper);\n\tif (IS_ERR(upper))\n\t\tgoto cleanup;\n\n\terr = ovl_do_rename(ofs, wdir, temp, udir, upper, 0);\n\tdput(upper);\n\tif (err)\n\t\tgoto cleanup;\n\n\tinode = d_inode(c->dentry);\n\tif (c->metacopy_digest)\n\t\tovl_set_flag(OVL_HAS_DIGEST, inode);\n\telse\n\t\tovl_clear_flag(OVL_HAS_DIGEST, inode);\n\tovl_clear_flag(OVL_VERIFIED_DIGEST, inode);\n\n\tif (!c->metacopy)\n\t\tovl_set_upperdata(inode);\n\tovl_inode_update(inode, temp);\n\tif (S_ISDIR(inode->i_mode))\n\t\tovl_set_flag(OVL_WHITEOUTS, inode);\nunlock:\n\tunlock_rename(c->workdir, c->destdir);\n\n\treturn err;\n\ncleanup:\n\tovl_cleanup(ofs, wdir, temp);\n\tdput(temp);\n\tgoto unlock;\n}\n\n \nstatic int ovl_copy_up_tmpfile(struct ovl_copy_up_ctx *c)\n{\n\tstruct ovl_fs *ofs = OVL_FS(c->dentry->d_sb);\n\tstruct inode *udir = d_inode(c->destdir);\n\tstruct dentry *temp, *upper;\n\tstruct file *tmpfile;\n\tstruct ovl_cu_creds cc;\n\tint err;\n\n\terr = ovl_prep_cu_creds(c->dentry, &cc);\n\tif (err)\n\t\treturn err;\n\n\ttmpfile = ovl_do_tmpfile(ofs, c->workdir, c->stat.mode);\n\tovl_revert_cu_creds(&cc);\n\n\tif (IS_ERR(tmpfile))\n\t\treturn PTR_ERR(tmpfile);\n\n\ttemp = tmpfile->f_path.dentry;\n\tif (!c->metacopy && c->stat.size) {\n\t\terr = ovl_copy_up_file(ofs, c->dentry, tmpfile, c->stat.size);\n\t\tif (err)\n\t\t\tgoto out_fput;\n\t}\n\n\terr = ovl_copy_up_metadata(c, temp);\n\tif (err)\n\t\tgoto out_fput;\n\n\tinode_lock_nested(udir, I_MUTEX_PARENT);\n\n\tupper = ovl_lookup_upper(ofs, c->destname.name, c->destdir,\n\t\t\t\t c->destname.len);\n\terr = PTR_ERR(upper);\n\tif (!IS_ERR(upper)) {\n\t\terr = ovl_do_link(ofs, temp, udir, upper);\n\t\tdput(upper);\n\t}\n\tinode_unlock(udir);\n\n\tif (err)\n\t\tgoto out_fput;\n\n\tif (c->metacopy_digest)\n\t\tovl_set_flag(OVL_HAS_DIGEST, d_inode(c->dentry));\n\telse\n\t\tovl_clear_flag(OVL_HAS_DIGEST, d_inode(c->dentry));\n\tovl_clear_flag(OVL_VERIFIED_DIGEST, d_inode(c->dentry));\n\n\tif (!c->metacopy)\n\t\tovl_set_upperdata(d_inode(c->dentry));\n\tovl_inode_update(d_inode(c->dentry), dget(temp));\n\nout_fput:\n\tfput(tmpfile);\n\treturn err;\n}\n\n \nstatic int ovl_do_copy_up(struct ovl_copy_up_ctx *c)\n{\n\tint err;\n\tstruct ovl_fs *ofs = OVL_FS(c->dentry->d_sb);\n\tbool to_index = false;\n\n\t \n\tif (ovl_need_index(c->dentry)) {\n\t\tc->indexed = true;\n\t\tif (S_ISDIR(c->stat.mode))\n\t\t\tc->workdir = ovl_indexdir(c->dentry->d_sb);\n\t\telse\n\t\t\tto_index = true;\n\t}\n\n\tif (S_ISDIR(c->stat.mode) || c->stat.nlink == 1 || to_index)\n\t\tc->origin = true;\n\n\tif (to_index) {\n\t\tc->destdir = ovl_indexdir(c->dentry->d_sb);\n\t\terr = ovl_get_index_name(ofs, c->lowerpath.dentry, &c->destname);\n\t\tif (err)\n\t\t\treturn err;\n\t} else if (WARN_ON(!c->parent)) {\n\t\t \n\t\treturn -EIO;\n\t} else {\n\t\t \n\t\terr = ovl_set_impure(c->parent, c->destdir);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tif (S_ISREG(c->stat.mode) && ofs->tmpfile)\n\t\terr = ovl_copy_up_tmpfile(c);\n\telse\n\t\terr = ovl_copy_up_workdir(c);\n\tif (err)\n\t\tgoto out;\n\n\tif (c->indexed)\n\t\tovl_set_flag(OVL_INDEX, d_inode(c->dentry));\n\n\tif (to_index) {\n\t\t \n\t\terr = ovl_set_nlink_upper(c->dentry);\n\t} else {\n\t\tstruct inode *udir = d_inode(c->destdir);\n\n\t\t \n\t\tinode_lock(udir);\n\t\tovl_set_timestamps(ofs, c->destdir, &c->pstat);\n\t\tinode_unlock(udir);\n\n\t\tovl_dentry_set_upper_alias(c->dentry);\n\t\tovl_dentry_update_reval(c->dentry, ovl_dentry_upper(c->dentry));\n\t}\n\nout:\n\tif (to_index)\n\t\tkfree(c->destname.name);\n\treturn err;\n}\n\nstatic bool ovl_need_meta_copy_up(struct dentry *dentry, umode_t mode,\n\t\t\t\t  int flags)\n{\n\tstruct ovl_fs *ofs = OVL_FS(dentry->d_sb);\n\n\tif (!ofs->config.metacopy)\n\t\treturn false;\n\n\tif (!S_ISREG(mode))\n\t\treturn false;\n\n\tif (flags && ((OPEN_FMODE(flags) & FMODE_WRITE) || (flags & O_TRUNC)))\n\t\treturn false;\n\n\t \n\tif (ofs->config.verity_mode == OVL_VERITY_REQUIRE) {\n\t\tstruct path lowerdata;\n\n\t\tovl_path_lowerdata(dentry, &lowerdata);\n\n\t\tif (WARN_ON_ONCE(lowerdata.dentry == NULL) ||\n\t\t    ovl_ensure_verity_loaded(&lowerdata) ||\n\t\t    !fsverity_active(d_inode(lowerdata.dentry))) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstatic ssize_t ovl_getxattr_value(const struct path *path, char *name, char **value)\n{\n\tssize_t res;\n\tchar *buf;\n\n\tres = ovl_do_getxattr(path, name, NULL, 0);\n\tif (res == -ENODATA || res == -EOPNOTSUPP)\n\t\tres = 0;\n\n\tif (res > 0) {\n\t\tbuf = kzalloc(res, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\n\t\tres = ovl_do_getxattr(path, name, buf, res);\n\t\tif (res < 0)\n\t\t\tkfree(buf);\n\t\telse\n\t\t\t*value = buf;\n\t}\n\treturn res;\n}\n\n \nstatic int ovl_copy_up_meta_inode_data(struct ovl_copy_up_ctx *c)\n{\n\tstruct ovl_fs *ofs = OVL_FS(c->dentry->d_sb);\n\tstruct path upperpath;\n\tint err;\n\tchar *capability = NULL;\n\tssize_t cap_size;\n\n\tovl_path_upper(c->dentry, &upperpath);\n\tif (WARN_ON(upperpath.dentry == NULL))\n\t\treturn -EIO;\n\n\tif (c->stat.size) {\n\t\terr = cap_size = ovl_getxattr_value(&upperpath, XATTR_NAME_CAPS,\n\t\t\t\t\t\t    &capability);\n\t\tif (cap_size < 0)\n\t\t\tgoto out;\n\t}\n\n\terr = ovl_copy_up_data(c, &upperpath);\n\tif (err)\n\t\tgoto out_free;\n\n\t \n\tif (capability) {\n\t\terr = ovl_do_setxattr(ofs, upperpath.dentry, XATTR_NAME_CAPS,\n\t\t\t\t      capability, cap_size, 0);\n\t\tif (err)\n\t\t\tgoto out_free;\n\t}\n\n\n\terr = ovl_removexattr(ofs, upperpath.dentry, OVL_XATTR_METACOPY);\n\tif (err)\n\t\tgoto out_free;\n\n\tovl_clear_flag(OVL_HAS_DIGEST, d_inode(c->dentry));\n\tovl_clear_flag(OVL_VERIFIED_DIGEST, d_inode(c->dentry));\n\tovl_set_upperdata(d_inode(c->dentry));\nout_free:\n\tkfree(capability);\nout:\n\treturn err;\n}\n\nstatic int ovl_copy_up_one(struct dentry *parent, struct dentry *dentry,\n\t\t\t   int flags)\n{\n\tint err;\n\tDEFINE_DELAYED_CALL(done);\n\tstruct path parentpath;\n\tstruct ovl_copy_up_ctx ctx = {\n\t\t.parent = parent,\n\t\t.dentry = dentry,\n\t\t.workdir = ovl_workdir(dentry),\n\t};\n\n\tif (WARN_ON(!ctx.workdir))\n\t\treturn -EROFS;\n\n\tovl_path_lower(dentry, &ctx.lowerpath);\n\terr = vfs_getattr(&ctx.lowerpath, &ctx.stat,\n\t\t\t  STATX_BASIC_STATS, AT_STATX_SYNC_AS_STAT);\n\tif (err)\n\t\treturn err;\n\n\tif (!kuid_has_mapping(current_user_ns(), ctx.stat.uid) ||\n\t    !kgid_has_mapping(current_user_ns(), ctx.stat.gid))\n\t\treturn -EOVERFLOW;\n\n\tctx.metacopy = ovl_need_meta_copy_up(dentry, ctx.stat.mode, flags);\n\n\tif (parent) {\n\t\tovl_path_upper(parent, &parentpath);\n\t\tctx.destdir = parentpath.dentry;\n\t\tctx.destname = dentry->d_name;\n\n\t\terr = vfs_getattr(&parentpath, &ctx.pstat,\n\t\t\t\t  STATX_ATIME | STATX_MTIME,\n\t\t\t\t  AT_STATX_SYNC_AS_STAT);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tif (flags & O_TRUNC)\n\t\tctx.stat.size = 0;\n\n\tif (S_ISLNK(ctx.stat.mode)) {\n\t\tctx.link = vfs_get_link(ctx.lowerpath.dentry, &done);\n\t\tif (IS_ERR(ctx.link))\n\t\t\treturn PTR_ERR(ctx.link);\n\t}\n\n\terr = ovl_copy_up_start(dentry, flags);\n\t \n\tif (unlikely(err)) {\n\t\tif (err > 0)\n\t\t\terr = 0;\n\t} else {\n\t\tif (!ovl_dentry_upper(dentry))\n\t\t\terr = ovl_do_copy_up(&ctx);\n\t\tif (!err && parent && !ovl_dentry_has_upper_alias(dentry))\n\t\t\terr = ovl_link_up(&ctx);\n\t\tif (!err && ovl_dentry_needs_data_copy_up_locked(dentry, flags))\n\t\t\terr = ovl_copy_up_meta_inode_data(&ctx);\n\t\tovl_copy_up_end(dentry);\n\t}\n\tdo_delayed_call(&done);\n\n\treturn err;\n}\n\nstatic int ovl_copy_up_flags(struct dentry *dentry, int flags)\n{\n\tint err = 0;\n\tconst struct cred *old_cred;\n\tbool disconnected = (dentry->d_flags & DCACHE_DISCONNECTED);\n\n\t \n\tif (WARN_ON(disconnected && d_is_dir(dentry)))\n\t\treturn -EIO;\n\n\t \n\terr = ovl_verify_lowerdata(dentry);\n\tif (err)\n\t\treturn err;\n\n\told_cred = ovl_override_creds(dentry->d_sb);\n\twhile (!err) {\n\t\tstruct dentry *next;\n\t\tstruct dentry *parent = NULL;\n\n\t\tif (ovl_already_copied_up(dentry, flags))\n\t\t\tbreak;\n\n\t\tnext = dget(dentry);\n\t\t \n\t\tfor (; !disconnected;) {\n\t\t\tparent = dget_parent(next);\n\n\t\t\tif (ovl_dentry_upper(parent))\n\t\t\t\tbreak;\n\n\t\t\tdput(next);\n\t\t\tnext = parent;\n\t\t}\n\n\t\terr = ovl_copy_up_one(parent, next, flags);\n\n\t\tdput(parent);\n\t\tdput(next);\n\t}\n\trevert_creds(old_cred);\n\n\treturn err;\n}\n\nstatic bool ovl_open_need_copy_up(struct dentry *dentry, int flags)\n{\n\t \n\tif (ovl_already_copied_up(dentry, flags))\n\t\treturn false;\n\n\tif (special_file(d_inode(dentry)->i_mode))\n\t\treturn false;\n\n\tif (!ovl_open_flags_need_copy_up(flags))\n\t\treturn false;\n\n\treturn true;\n}\n\nint ovl_maybe_copy_up(struct dentry *dentry, int flags)\n{\n\tint err = 0;\n\n\tif (ovl_open_need_copy_up(dentry, flags)) {\n\t\terr = ovl_want_write(dentry);\n\t\tif (!err) {\n\t\t\terr = ovl_copy_up_flags(dentry, flags);\n\t\t\tovl_drop_write(dentry);\n\t\t}\n\t}\n\n\treturn err;\n}\n\nint ovl_copy_up_with_data(struct dentry *dentry)\n{\n\treturn ovl_copy_up_flags(dentry, O_WRONLY);\n}\n\nint ovl_copy_up(struct dentry *dentry)\n{\n\treturn ovl_copy_up_flags(dentry, 0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}