{
  "module_name": "super.c",
  "hash_id": "0f7b91487a35772c08354c0d33def0af57961961b35af75e7dba9c49031000ee",
  "original_prompt": "Ingested from linux-6.6.14/fs/overlayfs/super.c",
  "human_readable_source": "\n \n\n#include <uapi/linux/magic.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/statfs.h>\n#include <linux/seq_file.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/exportfs.h>\n#include <linux/file.h>\n#include <linux/fs_context.h>\n#include <linux/fs_parser.h>\n#include \"overlayfs.h\"\n#include \"params.h\"\n\nMODULE_AUTHOR(\"Miklos Szeredi <miklos@szeredi.hu>\");\nMODULE_DESCRIPTION(\"Overlay filesystem\");\nMODULE_LICENSE(\"GPL\");\n\n\nstruct ovl_dir_cache;\n\nstatic struct dentry *ovl_d_real(struct dentry *dentry,\n\t\t\t\t const struct inode *inode)\n{\n\tstruct dentry *real = NULL, *lower;\n\tint err;\n\n\t \n\tif (inode && d_inode(dentry) == inode)\n\t\treturn dentry;\n\n\tif (!d_is_reg(dentry)) {\n\t\tif (!inode || inode == d_inode(dentry))\n\t\t\treturn dentry;\n\t\tgoto bug;\n\t}\n\n\treal = ovl_dentry_upper(dentry);\n\tif (real && (inode == d_inode(real)))\n\t\treturn real;\n\n\tif (real && !inode && ovl_has_upperdata(d_inode(dentry)))\n\t\treturn real;\n\n\t \n\terr = ovl_verify_lowerdata(dentry);\n\tif (err)\n\t\tgoto bug;\n\tlower = ovl_dentry_lowerdata(dentry);\n\tif (!lower)\n\t\tgoto bug;\n\treal = lower;\n\n\t \n\treal = d_real(real, inode);\n\n\tif (!inode || inode == d_inode(real))\n\t\treturn real;\nbug:\n\tWARN(1, \"%s(%pd4, %s:%lu): real dentry (%p/%lu) not found\\n\",\n\t     __func__, dentry, inode ? inode->i_sb->s_id : \"NULL\",\n\t     inode ? inode->i_ino : 0, real,\n\t     real && d_inode(real) ? d_inode(real)->i_ino : 0);\n\treturn dentry;\n}\n\nstatic int ovl_revalidate_real(struct dentry *d, unsigned int flags, bool weak)\n{\n\tint ret = 1;\n\n\tif (!d)\n\t\treturn 1;\n\n\tif (weak) {\n\t\tif (d->d_flags & DCACHE_OP_WEAK_REVALIDATE)\n\t\t\tret =  d->d_op->d_weak_revalidate(d, flags);\n\t} else if (d->d_flags & DCACHE_OP_REVALIDATE) {\n\t\tret = d->d_op->d_revalidate(d, flags);\n\t\tif (!ret) {\n\t\t\tif (!(flags & LOOKUP_RCU))\n\t\t\t\td_invalidate(d);\n\t\t\tret = -ESTALE;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int ovl_dentry_revalidate_common(struct dentry *dentry,\n\t\t\t\t\tunsigned int flags, bool weak)\n{\n\tstruct ovl_entry *oe;\n\tstruct ovl_path *lowerstack;\n\tstruct inode *inode = d_inode_rcu(dentry);\n\tstruct dentry *upper;\n\tunsigned int i;\n\tint ret = 1;\n\n\t \n\tif (!inode)\n\t\treturn -ECHILD;\n\n\toe = OVL_I_E(inode);\n\tlowerstack = ovl_lowerstack(oe);\n\tupper = ovl_i_dentry_upper(inode);\n\tif (upper)\n\t\tret = ovl_revalidate_real(upper, flags, weak);\n\n\tfor (i = 0; ret > 0 && i < ovl_numlower(oe); i++)\n\t\tret = ovl_revalidate_real(lowerstack[i].dentry, flags, weak);\n\n\treturn ret;\n}\n\nstatic int ovl_dentry_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\treturn ovl_dentry_revalidate_common(dentry, flags, false);\n}\n\nstatic int ovl_dentry_weak_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\treturn ovl_dentry_revalidate_common(dentry, flags, true);\n}\n\nstatic const struct dentry_operations ovl_dentry_operations = {\n\t.d_real = ovl_d_real,\n\t.d_revalidate = ovl_dentry_revalidate,\n\t.d_weak_revalidate = ovl_dentry_weak_revalidate,\n};\n\nstatic struct kmem_cache *ovl_inode_cachep;\n\nstatic struct inode *ovl_alloc_inode(struct super_block *sb)\n{\n\tstruct ovl_inode *oi = alloc_inode_sb(sb, ovl_inode_cachep, GFP_KERNEL);\n\n\tif (!oi)\n\t\treturn NULL;\n\n\toi->cache = NULL;\n\toi->redirect = NULL;\n\toi->version = 0;\n\toi->flags = 0;\n\toi->__upperdentry = NULL;\n\toi->lowerdata_redirect = NULL;\n\toi->oe = NULL;\n\tmutex_init(&oi->lock);\n\n\treturn &oi->vfs_inode;\n}\n\nstatic void ovl_free_inode(struct inode *inode)\n{\n\tstruct ovl_inode *oi = OVL_I(inode);\n\n\tkfree(oi->redirect);\n\tkfree(oi->oe);\n\tmutex_destroy(&oi->lock);\n\tkmem_cache_free(ovl_inode_cachep, oi);\n}\n\nstatic void ovl_destroy_inode(struct inode *inode)\n{\n\tstruct ovl_inode *oi = OVL_I(inode);\n\n\tdput(oi->__upperdentry);\n\tovl_stack_put(ovl_lowerstack(oi->oe), ovl_numlower(oi->oe));\n\tif (S_ISDIR(inode->i_mode))\n\t\tovl_dir_cache_free(inode);\n\telse\n\t\tkfree(oi->lowerdata_redirect);\n}\n\nstatic void ovl_put_super(struct super_block *sb)\n{\n\tstruct ovl_fs *ofs = OVL_FS(sb);\n\n\tif (ofs)\n\t\tovl_free_fs(ofs);\n}\n\n \nstatic int ovl_sync_fs(struct super_block *sb, int wait)\n{\n\tstruct ovl_fs *ofs = OVL_FS(sb);\n\tstruct super_block *upper_sb;\n\tint ret;\n\n\tret = ovl_sync_status(ofs);\n\t \n\tif (ret < 0) {\n\t\terrseq_set(&sb->s_wb_err, -EIO);\n\t\treturn -EIO;\n\t}\n\n\tif (!ret)\n\t\treturn ret;\n\n\t \n\tif (!wait)\n\t\treturn 0;\n\n\tupper_sb = ovl_upper_mnt(ofs)->mnt_sb;\n\n\tdown_read(&upper_sb->s_umount);\n\tret = sync_filesystem(upper_sb);\n\tup_read(&upper_sb->s_umount);\n\n\treturn ret;\n}\n\n \nstatic int ovl_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct ovl_fs *ofs = OVL_FS(sb);\n\tstruct dentry *root_dentry = sb->s_root;\n\tstruct path path;\n\tint err;\n\n\tovl_path_real(root_dentry, &path);\n\n\terr = vfs_statfs(&path, buf);\n\tif (!err) {\n\t\tbuf->f_namelen = ofs->namelen;\n\t\tbuf->f_type = OVERLAYFS_SUPER_MAGIC;\n\t\tif (ovl_has_fsid(ofs))\n\t\t\tbuf->f_fsid = uuid_to_fsid(sb->s_uuid.b);\n\t}\n\n\treturn err;\n}\n\nstatic const struct super_operations ovl_super_operations = {\n\t.alloc_inode\t= ovl_alloc_inode,\n\t.free_inode\t= ovl_free_inode,\n\t.destroy_inode\t= ovl_destroy_inode,\n\t.drop_inode\t= generic_delete_inode,\n\t.put_super\t= ovl_put_super,\n\t.sync_fs\t= ovl_sync_fs,\n\t.statfs\t\t= ovl_statfs,\n\t.show_options\t= ovl_show_options,\n};\n\n#define OVL_WORKDIR_NAME \"work\"\n#define OVL_INDEXDIR_NAME \"index\"\n\nstatic struct dentry *ovl_workdir_create(struct ovl_fs *ofs,\n\t\t\t\t\t const char *name, bool persist)\n{\n\tstruct inode *dir =  ofs->workbasedir->d_inode;\n\tstruct vfsmount *mnt = ovl_upper_mnt(ofs);\n\tstruct dentry *work;\n\tint err;\n\tbool retried = false;\n\n\tinode_lock_nested(dir, I_MUTEX_PARENT);\nretry:\n\twork = ovl_lookup_upper(ofs, name, ofs->workbasedir, strlen(name));\n\n\tif (!IS_ERR(work)) {\n\t\tstruct iattr attr = {\n\t\t\t.ia_valid = ATTR_MODE,\n\t\t\t.ia_mode = S_IFDIR | 0,\n\t\t};\n\n\t\tif (work->d_inode) {\n\t\t\terr = -EEXIST;\n\t\t\tif (retried)\n\t\t\t\tgoto out_dput;\n\n\t\t\tif (persist)\n\t\t\t\tgoto out_unlock;\n\n\t\t\tretried = true;\n\t\t\terr = ovl_workdir_cleanup(ofs, dir, mnt, work, 0);\n\t\t\tdput(work);\n\t\t\tif (err == -EINVAL) {\n\t\t\t\twork = ERR_PTR(err);\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tgoto retry;\n\t\t}\n\n\t\terr = ovl_mkdir_real(ofs, dir, &work, attr.ia_mode);\n\t\tif (err)\n\t\t\tgoto out_dput;\n\n\t\t \n\t\terr = -EINVAL;\n\t\tif (d_really_is_negative(work))\n\t\t\tgoto out_dput;\n\n\t\t \n\t\terr = ovl_do_remove_acl(ofs, work, XATTR_NAME_POSIX_ACL_DEFAULT);\n\t\tif (err && err != -ENODATA && err != -EOPNOTSUPP)\n\t\t\tgoto out_dput;\n\n\t\terr = ovl_do_remove_acl(ofs, work, XATTR_NAME_POSIX_ACL_ACCESS);\n\t\tif (err && err != -ENODATA && err != -EOPNOTSUPP)\n\t\t\tgoto out_dput;\n\n\t\t \n\t\tinode_lock(work->d_inode);\n\t\terr = ovl_do_notify_change(ofs, work, &attr);\n\t\tinode_unlock(work->d_inode);\n\t\tif (err)\n\t\t\tgoto out_dput;\n\t} else {\n\t\terr = PTR_ERR(work);\n\t\tgoto out_err;\n\t}\nout_unlock:\n\tinode_unlock(dir);\n\treturn work;\n\nout_dput:\n\tdput(work);\nout_err:\n\tpr_warn(\"failed to create directory %s/%s (errno: %i); mounting read-only\\n\",\n\t\tofs->config.workdir, name, -err);\n\twork = NULL;\n\tgoto out_unlock;\n}\n\nstatic int ovl_check_namelen(const struct path *path, struct ovl_fs *ofs,\n\t\t\t     const char *name)\n{\n\tstruct kstatfs statfs;\n\tint err = vfs_statfs(path, &statfs);\n\n\tif (err)\n\t\tpr_err(\"statfs failed on '%s'\\n\", name);\n\telse\n\t\tofs->namelen = max(ofs->namelen, statfs.f_namelen);\n\n\treturn err;\n}\n\nstatic int ovl_lower_dir(const char *name, struct path *path,\n\t\t\t struct ovl_fs *ofs, int *stack_depth)\n{\n\tint fh_type;\n\tint err;\n\n\terr = ovl_check_namelen(path, ofs, name);\n\tif (err)\n\t\treturn err;\n\n\t*stack_depth = max(*stack_depth, path->mnt->mnt_sb->s_stack_depth);\n\n\t \n\tfh_type = ovl_can_decode_fh(path->dentry->d_sb);\n\tif ((ofs->config.nfs_export ||\n\t     (ofs->config.index && ofs->config.upperdir)) && !fh_type) {\n\t\tofs->config.index = false;\n\t\tofs->config.nfs_export = false;\n\t\tpr_warn(\"fs on '%s' does not support file handles, falling back to index=off,nfs_export=off.\\n\",\n\t\t\tname);\n\t}\n\tofs->nofh |= !fh_type;\n\t \n\tif (ofs->config.xino == OVL_XINO_AUTO &&\n\t    ofs->config.upperdir && !fh_type) {\n\t\tofs->config.xino = OVL_XINO_OFF;\n\t\tpr_warn(\"fs on '%s' does not support file handles, falling back to xino=off.\\n\",\n\t\t\tname);\n\t}\n\n\t \n\tif (fh_type != FILEID_INO32_GEN)\n\t\tofs->xino_mode = -1;\n\n\treturn 0;\n}\n\n \nstatic bool ovl_workdir_ok(struct dentry *workdir, struct dentry *upperdir)\n{\n\tbool ok = false;\n\n\tif (workdir != upperdir) {\n\t\tok = (lock_rename(workdir, upperdir) == NULL);\n\t\tunlock_rename(workdir, upperdir);\n\t}\n\treturn ok;\n}\n\nstatic int ovl_own_xattr_get(const struct xattr_handler *handler,\n\t\t\t     struct dentry *dentry, struct inode *inode,\n\t\t\t     const char *name, void *buffer, size_t size)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic int ovl_own_xattr_set(const struct xattr_handler *handler,\n\t\t\t     struct mnt_idmap *idmap,\n\t\t\t     struct dentry *dentry, struct inode *inode,\n\t\t\t     const char *name, const void *value,\n\t\t\t     size_t size, int flags)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic int ovl_other_xattr_get(const struct xattr_handler *handler,\n\t\t\t       struct dentry *dentry, struct inode *inode,\n\t\t\t       const char *name, void *buffer, size_t size)\n{\n\treturn ovl_xattr_get(dentry, inode, name, buffer, size);\n}\n\nstatic int ovl_other_xattr_set(const struct xattr_handler *handler,\n\t\t\t       struct mnt_idmap *idmap,\n\t\t\t       struct dentry *dentry, struct inode *inode,\n\t\t\t       const char *name, const void *value,\n\t\t\t       size_t size, int flags)\n{\n\treturn ovl_xattr_set(dentry, inode, name, value, size, flags);\n}\n\nstatic const struct xattr_handler ovl_own_trusted_xattr_handler = {\n\t.prefix\t= OVL_XATTR_TRUSTED_PREFIX,\n\t.get = ovl_own_xattr_get,\n\t.set = ovl_own_xattr_set,\n};\n\nstatic const struct xattr_handler ovl_own_user_xattr_handler = {\n\t.prefix\t= OVL_XATTR_USER_PREFIX,\n\t.get = ovl_own_xattr_get,\n\t.set = ovl_own_xattr_set,\n};\n\nstatic const struct xattr_handler ovl_other_xattr_handler = {\n\t.prefix\t= \"\",  \n\t.get = ovl_other_xattr_get,\n\t.set = ovl_other_xattr_set,\n};\n\nstatic const struct xattr_handler *ovl_trusted_xattr_handlers[] = {\n\t&ovl_own_trusted_xattr_handler,\n\t&ovl_other_xattr_handler,\n\tNULL\n};\n\nstatic const struct xattr_handler *ovl_user_xattr_handlers[] = {\n\t&ovl_own_user_xattr_handler,\n\t&ovl_other_xattr_handler,\n\tNULL\n};\n\nstatic int ovl_setup_trap(struct super_block *sb, struct dentry *dir,\n\t\t\t  struct inode **ptrap, const char *name)\n{\n\tstruct inode *trap;\n\tint err;\n\n\ttrap = ovl_get_trap_inode(sb, dir);\n\terr = PTR_ERR_OR_ZERO(trap);\n\tif (err) {\n\t\tif (err == -ELOOP)\n\t\t\tpr_err(\"conflicting %s path\\n\", name);\n\t\treturn err;\n\t}\n\n\t*ptrap = trap;\n\treturn 0;\n}\n\n \nstatic int ovl_report_in_use(struct ovl_fs *ofs, const char *name)\n{\n\tif (ofs->config.index) {\n\t\tpr_err(\"%s is in-use as upperdir/workdir of another mount, mount with '-o index=off' to override exclusive upperdir protection.\\n\",\n\t\t       name);\n\t\treturn -EBUSY;\n\t} else {\n\t\tpr_warn(\"%s is in-use as upperdir/workdir of another mount, accessing files from both mounts will result in undefined behavior.\\n\",\n\t\t\tname);\n\t\treturn 0;\n\t}\n}\n\nstatic int ovl_get_upper(struct super_block *sb, struct ovl_fs *ofs,\n\t\t\t struct ovl_layer *upper_layer,\n\t\t\t const struct path *upperpath)\n{\n\tstruct vfsmount *upper_mnt;\n\tint err;\n\n\t \n\tif (__mnt_is_readonly(upperpath->mnt)) {\n\t\tpr_err(\"upper fs is r/o, try multi-lower layers mount\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\terr = ovl_check_namelen(upperpath, ofs, ofs->config.upperdir);\n\tif (err)\n\t\tgoto out;\n\n\terr = ovl_setup_trap(sb, upperpath->dentry, &upper_layer->trap,\n\t\t\t     \"upperdir\");\n\tif (err)\n\t\tgoto out;\n\n\tupper_mnt = clone_private_mount(upperpath);\n\terr = PTR_ERR(upper_mnt);\n\tif (IS_ERR(upper_mnt)) {\n\t\tpr_err(\"failed to clone upperpath\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tupper_mnt->mnt_flags &= ~(MNT_NOATIME | MNT_NODIRATIME | MNT_RELATIME);\n\tupper_layer->mnt = upper_mnt;\n\tupper_layer->idx = 0;\n\tupper_layer->fsid = 0;\n\n\t \n\tif (upper_mnt->mnt_sb->s_flags & SB_NOSEC)\n\t\tsb->s_flags |= SB_NOSEC;\n\n\tif (ovl_inuse_trylock(ovl_upper_mnt(ofs)->mnt_root)) {\n\t\tofs->upperdir_locked = true;\n\t} else {\n\t\terr = ovl_report_in_use(ofs, \"upperdir\");\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\terr = 0;\nout:\n\treturn err;\n}\n\n \nstatic int ovl_check_rename_whiteout(struct ovl_fs *ofs)\n{\n\tstruct dentry *workdir = ofs->workdir;\n\tstruct inode *dir = d_inode(workdir);\n\tstruct dentry *temp;\n\tstruct dentry *dest;\n\tstruct dentry *whiteout;\n\tstruct name_snapshot name;\n\tint err;\n\n\tinode_lock_nested(dir, I_MUTEX_PARENT);\n\n\ttemp = ovl_create_temp(ofs, workdir, OVL_CATTR(S_IFREG | 0));\n\terr = PTR_ERR(temp);\n\tif (IS_ERR(temp))\n\t\tgoto out_unlock;\n\n\tdest = ovl_lookup_temp(ofs, workdir);\n\terr = PTR_ERR(dest);\n\tif (IS_ERR(dest)) {\n\t\tdput(temp);\n\t\tgoto out_unlock;\n\t}\n\n\t \n\ttake_dentry_name_snapshot(&name, temp);\n\terr = ovl_do_rename(ofs, dir, temp, dir, dest, RENAME_WHITEOUT);\n\tif (err) {\n\t\tif (err == -EINVAL)\n\t\t\terr = 0;\n\t\tgoto cleanup_temp;\n\t}\n\n\twhiteout = ovl_lookup_upper(ofs, name.name.name, workdir, name.name.len);\n\terr = PTR_ERR(whiteout);\n\tif (IS_ERR(whiteout))\n\t\tgoto cleanup_temp;\n\n\terr = ovl_is_whiteout(whiteout);\n\n\t \n\tif (err)\n\t\tovl_cleanup(ofs, dir, whiteout);\n\tdput(whiteout);\n\ncleanup_temp:\n\tovl_cleanup(ofs, dir, temp);\n\trelease_dentry_name_snapshot(&name);\n\tdput(temp);\n\tdput(dest);\n\nout_unlock:\n\tinode_unlock(dir);\n\n\treturn err;\n}\n\nstatic struct dentry *ovl_lookup_or_create(struct ovl_fs *ofs,\n\t\t\t\t\t   struct dentry *parent,\n\t\t\t\t\t   const char *name, umode_t mode)\n{\n\tsize_t len = strlen(name);\n\tstruct dentry *child;\n\n\tinode_lock_nested(parent->d_inode, I_MUTEX_PARENT);\n\tchild = ovl_lookup_upper(ofs, name, parent, len);\n\tif (!IS_ERR(child) && !child->d_inode)\n\t\tchild = ovl_create_real(ofs, parent->d_inode, child,\n\t\t\t\t\tOVL_CATTR(mode));\n\tinode_unlock(parent->d_inode);\n\tdput(parent);\n\n\treturn child;\n}\n\n \nstatic int ovl_create_volatile_dirty(struct ovl_fs *ofs)\n{\n\tunsigned int ctr;\n\tstruct dentry *d = dget(ofs->workbasedir);\n\tstatic const char *const volatile_path[] = {\n\t\tOVL_WORKDIR_NAME, \"incompat\", \"volatile\", \"dirty\"\n\t};\n\tconst char *const *name = volatile_path;\n\n\tfor (ctr = ARRAY_SIZE(volatile_path); ctr; ctr--, name++) {\n\t\td = ovl_lookup_or_create(ofs, d, *name, ctr > 1 ? S_IFDIR : S_IFREG);\n\t\tif (IS_ERR(d))\n\t\t\treturn PTR_ERR(d);\n\t}\n\tdput(d);\n\treturn 0;\n}\n\nstatic int ovl_make_workdir(struct super_block *sb, struct ovl_fs *ofs,\n\t\t\t    const struct path *workpath)\n{\n\tstruct vfsmount *mnt = ovl_upper_mnt(ofs);\n\tstruct dentry *workdir;\n\tstruct file *tmpfile;\n\tbool rename_whiteout;\n\tbool d_type;\n\tint fh_type;\n\tint err;\n\n\terr = mnt_want_write(mnt);\n\tif (err)\n\t\treturn err;\n\n\tworkdir = ovl_workdir_create(ofs, OVL_WORKDIR_NAME, false);\n\terr = PTR_ERR(workdir);\n\tif (IS_ERR_OR_NULL(workdir))\n\t\tgoto out;\n\n\tofs->workdir = workdir;\n\n\terr = ovl_setup_trap(sb, ofs->workdir, &ofs->workdir_trap, \"workdir\");\n\tif (err)\n\t\tgoto out;\n\n\t \n\terr = ovl_check_d_type_supported(workpath);\n\tif (err < 0)\n\t\tgoto out;\n\n\td_type = err;\n\tif (!d_type)\n\t\tpr_warn(\"upper fs needs to support d_type.\\n\");\n\n\t \n\ttmpfile = ovl_do_tmpfile(ofs, ofs->workdir, S_IFREG | 0);\n\tofs->tmpfile = !IS_ERR(tmpfile);\n\tif (ofs->tmpfile)\n\t\tfput(tmpfile);\n\telse\n\t\tpr_warn(\"upper fs does not support tmpfile.\\n\");\n\n\n\t \n\terr = ovl_check_rename_whiteout(ofs);\n\tif (err < 0)\n\t\tgoto out;\n\n\trename_whiteout = err;\n\tif (!rename_whiteout)\n\t\tpr_warn(\"upper fs does not support RENAME_WHITEOUT.\\n\");\n\n\t \n\terr = ovl_setxattr(ofs, ofs->workdir, OVL_XATTR_OPAQUE, \"0\", 1);\n\tif (err) {\n\t\tpr_warn(\"failed to set xattr on upper\\n\");\n\t\tofs->noxattr = true;\n\t\tif (ovl_redirect_follow(ofs)) {\n\t\t\tofs->config.redirect_mode = OVL_REDIRECT_NOFOLLOW;\n\t\t\tpr_warn(\"...falling back to redirect_dir=nofollow.\\n\");\n\t\t}\n\t\tif (ofs->config.metacopy) {\n\t\t\tofs->config.metacopy = false;\n\t\t\tpr_warn(\"...falling back to metacopy=off.\\n\");\n\t\t}\n\t\tif (ofs->config.index) {\n\t\t\tofs->config.index = false;\n\t\t\tpr_warn(\"...falling back to index=off.\\n\");\n\t\t}\n\t\tif (ovl_has_fsid(ofs)) {\n\t\t\tofs->config.uuid = OVL_UUID_NULL;\n\t\t\tpr_warn(\"...falling back to uuid=null.\\n\");\n\t\t}\n\t\t \n\t\tif (ofs->config.xino == OVL_XINO_AUTO) {\n\t\t\tofs->config.xino = OVL_XINO_OFF;\n\t\t\tpr_warn(\"...falling back to xino=off.\\n\");\n\t\t}\n\t\tif (err == -EPERM && !ofs->config.userxattr)\n\t\t\tpr_info(\"try mounting with 'userxattr' option\\n\");\n\t\terr = 0;\n\t} else {\n\t\tovl_removexattr(ofs, ofs->workdir, OVL_XATTR_OPAQUE);\n\t}\n\n\t \n\tif (ovl_dentry_remote(ofs->workdir) &&\n\t    (!d_type || !rename_whiteout || ofs->noxattr)) {\n\t\tpr_err(\"upper fs missing required features.\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (ofs->config.ovl_volatile) {\n\t\terr = ovl_create_volatile_dirty(ofs);\n\t\tif (err < 0) {\n\t\t\tpr_err(\"Failed to create volatile/dirty file.\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tfh_type = ovl_can_decode_fh(ofs->workdir->d_sb);\n\tif (ofs->config.index && !fh_type) {\n\t\tofs->config.index = false;\n\t\tpr_warn(\"upper fs does not support file handles, falling back to index=off.\\n\");\n\t}\n\tofs->nofh |= !fh_type;\n\n\t \n\tif (fh_type != FILEID_INO32_GEN)\n\t\tofs->xino_mode = -1;\n\n\t \n\tif (ofs->config.nfs_export && !ofs->config.index) {\n\t\tpr_warn(\"NFS export requires \\\"index=on\\\", falling back to nfs_export=off.\\n\");\n\t\tofs->config.nfs_export = false;\n\t}\nout:\n\tmnt_drop_write(mnt);\n\treturn err;\n}\n\nstatic int ovl_get_workdir(struct super_block *sb, struct ovl_fs *ofs,\n\t\t\t   const struct path *upperpath,\n\t\t\t   const struct path *workpath)\n{\n\tint err;\n\n\terr = -EINVAL;\n\tif (upperpath->mnt != workpath->mnt) {\n\t\tpr_err(\"workdir and upperdir must reside under the same mount\\n\");\n\t\treturn err;\n\t}\n\tif (!ovl_workdir_ok(workpath->dentry, upperpath->dentry)) {\n\t\tpr_err(\"workdir and upperdir must be separate subtrees\\n\");\n\t\treturn err;\n\t}\n\n\tofs->workbasedir = dget(workpath->dentry);\n\n\tif (ovl_inuse_trylock(ofs->workbasedir)) {\n\t\tofs->workdir_locked = true;\n\t} else {\n\t\terr = ovl_report_in_use(ofs, \"workdir\");\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = ovl_setup_trap(sb, ofs->workbasedir, &ofs->workbasedir_trap,\n\t\t\t     \"workdir\");\n\tif (err)\n\t\treturn err;\n\n\treturn ovl_make_workdir(sb, ofs, workpath);\n}\n\nstatic int ovl_get_indexdir(struct super_block *sb, struct ovl_fs *ofs,\n\t\t\t    struct ovl_entry *oe, const struct path *upperpath)\n{\n\tstruct vfsmount *mnt = ovl_upper_mnt(ofs);\n\tstruct dentry *indexdir;\n\tint err;\n\n\terr = mnt_want_write(mnt);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = ovl_verify_origin(ofs, upperpath->dentry,\n\t\t\t\tovl_lowerstack(oe)->dentry, true);\n\tif (err) {\n\t\tpr_err(\"failed to verify upper root origin\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tiput(ofs->workdir_trap);\n\tofs->workdir_trap = NULL;\n\tdput(ofs->workdir);\n\tofs->workdir = NULL;\n\tindexdir = ovl_workdir_create(ofs, OVL_INDEXDIR_NAME, true);\n\tif (IS_ERR(indexdir)) {\n\t\terr = PTR_ERR(indexdir);\n\t} else if (indexdir) {\n\t\tofs->indexdir = indexdir;\n\t\tofs->workdir = dget(indexdir);\n\n\t\terr = ovl_setup_trap(sb, ofs->indexdir, &ofs->indexdir_trap,\n\t\t\t\t     \"indexdir\");\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\t \n\t\tif (ovl_check_origin_xattr(ofs, ofs->indexdir)) {\n\t\t\terr = ovl_verify_set_fh(ofs, ofs->indexdir,\n\t\t\t\t\t\tOVL_XATTR_ORIGIN,\n\t\t\t\t\t\tupperpath->dentry, true, false);\n\t\t\tif (err)\n\t\t\t\tpr_err(\"failed to verify index dir 'origin' xattr\\n\");\n\t\t}\n\t\terr = ovl_verify_upper(ofs, ofs->indexdir, upperpath->dentry,\n\t\t\t\t       true);\n\t\tif (err)\n\t\t\tpr_err(\"failed to verify index dir 'upper' xattr\\n\");\n\n\t\t \n\t\tif (!err)\n\t\t\terr = ovl_indexdir_cleanup(ofs);\n\t}\n\tif (err || !ofs->indexdir)\n\t\tpr_warn(\"try deleting index dir or mounting with '-o index=off' to disable inodes index.\\n\");\n\nout:\n\tmnt_drop_write(mnt);\n\treturn err;\n}\n\nstatic bool ovl_lower_uuid_ok(struct ovl_fs *ofs, const uuid_t *uuid)\n{\n\tunsigned int i;\n\n\tif (!ofs->config.nfs_export && !ovl_upper_mnt(ofs))\n\t\treturn true;\n\n\t \n\tif (ovl_allow_offline_changes(ofs) && uuid_is_null(uuid))\n\t\treturn false;\n\n\tfor (i = 0; i < ofs->numfs; i++) {\n\t\t \n\t\tif (ofs->fs[i].is_lower &&\n\t\t    uuid_equal(&ofs->fs[i].sb->s_uuid, uuid)) {\n\t\t\tofs->fs[i].bad_uuid = true;\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n \nstatic int ovl_get_fsid(struct ovl_fs *ofs, const struct path *path)\n{\n\tstruct super_block *sb = path->mnt->mnt_sb;\n\tunsigned int i;\n\tdev_t dev;\n\tint err;\n\tbool bad_uuid = false;\n\tbool warn = false;\n\n\tfor (i = 0; i < ofs->numfs; i++) {\n\t\tif (ofs->fs[i].sb == sb)\n\t\t\treturn i;\n\t}\n\n\tif (!ovl_lower_uuid_ok(ofs, &sb->s_uuid)) {\n\t\tbad_uuid = true;\n\t\tif (ofs->config.xino == OVL_XINO_AUTO) {\n\t\t\tofs->config.xino = OVL_XINO_OFF;\n\t\t\twarn = true;\n\t\t}\n\t\tif (ofs->config.index || ofs->config.nfs_export) {\n\t\t\tofs->config.index = false;\n\t\t\tofs->config.nfs_export = false;\n\t\t\twarn = true;\n\t\t}\n\t\tif (warn) {\n\t\t\tpr_warn(\"%s uuid detected in lower fs '%pd2', falling back to xino=%s,index=off,nfs_export=off.\\n\",\n\t\t\t\tuuid_is_null(&sb->s_uuid) ? \"null\" :\n\t\t\t\t\t\t\t    \"conflicting\",\n\t\t\t\tpath->dentry, ovl_xino_mode(&ofs->config));\n\t\t}\n\t}\n\n\terr = get_anon_bdev(&dev);\n\tif (err) {\n\t\tpr_err(\"failed to get anonymous bdev for lowerpath\\n\");\n\t\treturn err;\n\t}\n\n\tofs->fs[ofs->numfs].sb = sb;\n\tofs->fs[ofs->numfs].pseudo_dev = dev;\n\tofs->fs[ofs->numfs].bad_uuid = bad_uuid;\n\n\treturn ofs->numfs++;\n}\n\n \nstatic int ovl_get_data_fsid(struct ovl_fs *ofs)\n{\n\treturn ofs->numfs;\n}\n\n\nstatic int ovl_get_layers(struct super_block *sb, struct ovl_fs *ofs,\n\t\t\t  struct ovl_fs_context *ctx, struct ovl_layer *layers)\n{\n\tint err;\n\tunsigned int i;\n\tsize_t nr_merged_lower;\n\n\tofs->fs = kcalloc(ctx->nr + 2, sizeof(struct ovl_sb), GFP_KERNEL);\n\tif (ofs->fs == NULL)\n\t\treturn -ENOMEM;\n\n\t \n\tofs->numfs++;\n\n\t \n\terr = get_anon_bdev(&ofs->fs[0].pseudo_dev);\n\tif (err) {\n\t\tpr_err(\"failed to get anonymous bdev for upper fs\\n\");\n\t\treturn err;\n\t}\n\n\tif (ovl_upper_mnt(ofs)) {\n\t\tofs->fs[0].sb = ovl_upper_mnt(ofs)->mnt_sb;\n\t\tofs->fs[0].is_lower = false;\n\t}\n\n\tnr_merged_lower = ctx->nr - ctx->nr_data;\n\tfor (i = 0; i < ctx->nr; i++) {\n\t\tstruct ovl_fs_context_layer *l = &ctx->lower[i];\n\t\tstruct vfsmount *mnt;\n\t\tstruct inode *trap;\n\t\tint fsid;\n\n\t\tif (i < nr_merged_lower)\n\t\t\tfsid = ovl_get_fsid(ofs, &l->path);\n\t\telse\n\t\t\tfsid = ovl_get_data_fsid(ofs);\n\t\tif (fsid < 0)\n\t\t\treturn fsid;\n\n\t\t \n\t\terr = ovl_setup_trap(sb, l->path.dentry, &trap, \"lowerdir\");\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (ovl_is_inuse(l->path.dentry)) {\n\t\t\terr = ovl_report_in_use(ofs, \"lowerdir\");\n\t\t\tif (err) {\n\t\t\t\tiput(trap);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\n\t\tmnt = clone_private_mount(&l->path);\n\t\terr = PTR_ERR(mnt);\n\t\tif (IS_ERR(mnt)) {\n\t\t\tpr_err(\"failed to clone lowerpath\\n\");\n\t\t\tiput(trap);\n\t\t\treturn err;\n\t\t}\n\n\t\t \n\t\tmnt->mnt_flags |= MNT_READONLY | MNT_NOATIME;\n\n\t\tlayers[ofs->numlayer].trap = trap;\n\t\tlayers[ofs->numlayer].mnt = mnt;\n\t\tlayers[ofs->numlayer].idx = ofs->numlayer;\n\t\tlayers[ofs->numlayer].fsid = fsid;\n\t\tlayers[ofs->numlayer].fs = &ofs->fs[fsid];\n\t\t \n\t\tofs->config.lowerdirs[ofs->numlayer] = l->name;\n\t\tl->name = NULL;\n\t\tofs->numlayer++;\n\t\tofs->fs[fsid].is_lower = true;\n\t}\n\n\t \n\tif (ofs->numfs - !ovl_upper_mnt(ofs) == 1) {\n\t\tif (ofs->config.xino == OVL_XINO_ON)\n\t\t\tpr_info(\"\\\"xino=on\\\" is useless with all layers on same fs, ignore.\\n\");\n\t\tofs->xino_mode = 0;\n\t} else if (ofs->config.xino == OVL_XINO_OFF) {\n\t\tofs->xino_mode = -1;\n\t} else if (ofs->xino_mode < 0) {\n\t\t \n\t\tBUILD_BUG_ON(ilog2(OVL_MAX_STACK) > 30);\n\t\tofs->xino_mode = ilog2(ofs->numfs - 1) + 2;\n\t}\n\n\tif (ofs->xino_mode > 0) {\n\t\tpr_info(\"\\\"xino\\\" feature enabled using %d upper inode bits.\\n\",\n\t\t\tofs->xino_mode);\n\t}\n\n\treturn 0;\n}\n\nstatic struct ovl_entry *ovl_get_lowerstack(struct super_block *sb,\n\t\t\t\t\t    struct ovl_fs_context *ctx,\n\t\t\t\t\t    struct ovl_fs *ofs,\n\t\t\t\t\t    struct ovl_layer *layers)\n{\n\tint err;\n\tunsigned int i;\n\tsize_t nr_merged_lower;\n\tstruct ovl_entry *oe;\n\tstruct ovl_path *lowerstack;\n\n\tstruct ovl_fs_context_layer *l;\n\n\tif (!ofs->config.upperdir && ctx->nr == 1) {\n\t\tpr_err(\"at least 2 lowerdir are needed while upperdir nonexistent\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\terr = -EINVAL;\n\tfor (i = 0; i < ctx->nr; i++) {\n\t\tl = &ctx->lower[i];\n\n\t\terr = ovl_lower_dir(l->name, &l->path, ofs, &sb->s_stack_depth);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = -EINVAL;\n\tsb->s_stack_depth++;\n\tif (sb->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {\n\t\tpr_err(\"maximum fs stacking depth exceeded\\n\");\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = ovl_get_layers(sb, ofs, ctx, layers);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\terr = -ENOMEM;\n\t \n\tnr_merged_lower = ctx->nr - ctx->nr_data;\n\toe = ovl_alloc_entry(nr_merged_lower);\n\tif (!oe)\n\t\treturn ERR_PTR(err);\n\n\tlowerstack = ovl_lowerstack(oe);\n\tfor (i = 0; i < nr_merged_lower; i++) {\n\t\tl = &ctx->lower[i];\n\t\tlowerstack[i].dentry = dget(l->path.dentry);\n\t\tlowerstack[i].layer = &ofs->layers[i + 1];\n\t}\n\tofs->numdatalayer = ctx->nr_data;\n\n\treturn oe;\n}\n\n \nstatic int ovl_check_layer(struct super_block *sb, struct ovl_fs *ofs,\n\t\t\t   struct dentry *dentry, const char *name,\n\t\t\t   bool is_lower)\n{\n\tstruct dentry *next = dentry, *parent;\n\tint err = 0;\n\n\tif (!dentry)\n\t\treturn 0;\n\n\tparent = dget_parent(next);\n\n\t \n\twhile (!err && parent != next) {\n\t\tif (is_lower && ovl_lookup_trap_inode(sb, parent)) {\n\t\t\terr = -ELOOP;\n\t\t\tpr_err(\"overlapping %s path\\n\", name);\n\t\t} else if (ovl_is_inuse(parent)) {\n\t\t\terr = ovl_report_in_use(ofs, name);\n\t\t}\n\t\tnext = parent;\n\t\tparent = dget_parent(next);\n\t\tdput(next);\n\t}\n\n\tdput(parent);\n\n\treturn err;\n}\n\n \nstatic int ovl_check_overlapping_layers(struct super_block *sb,\n\t\t\t\t\tstruct ovl_fs *ofs)\n{\n\tint i, err;\n\n\tif (ovl_upper_mnt(ofs)) {\n\t\terr = ovl_check_layer(sb, ofs, ovl_upper_mnt(ofs)->mnt_root,\n\t\t\t\t      \"upperdir\", false);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t \n\t\terr = ovl_check_layer(sb, ofs, ofs->workbasedir, \"workdir\",\n\t\t\t\t      false);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tfor (i = 1; i < ofs->numlayer; i++) {\n\t\terr = ovl_check_layer(sb, ofs,\n\t\t\t\t      ofs->layers[i].mnt->mnt_root,\n\t\t\t\t      \"lowerdir\", true);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic struct dentry *ovl_get_root(struct super_block *sb,\n\t\t\t\t   struct dentry *upperdentry,\n\t\t\t\t   struct ovl_entry *oe)\n{\n\tstruct dentry *root;\n\tstruct ovl_path *lowerpath = ovl_lowerstack(oe);\n\tunsigned long ino = d_inode(lowerpath->dentry)->i_ino;\n\tint fsid = lowerpath->layer->fsid;\n\tstruct ovl_inode_params oip = {\n\t\t.upperdentry = upperdentry,\n\t\t.oe = oe,\n\t};\n\n\troot = d_make_root(ovl_new_inode(sb, S_IFDIR, 0));\n\tif (!root)\n\t\treturn NULL;\n\n\tif (upperdentry) {\n\t\t \n\t\tino = d_inode(upperdentry)->i_ino;\n\t\tfsid = 0;\n\t\tovl_dentry_set_upper_alias(root);\n\t\tif (ovl_is_impuredir(sb, upperdentry))\n\t\t\tovl_set_flag(OVL_IMPURE, d_inode(root));\n\t}\n\n\t \n\tovl_set_flag(OVL_WHITEOUTS, d_inode(root));\n\tovl_dentry_set_flag(OVL_E_CONNECTED, root);\n\tovl_set_upperdata(d_inode(root));\n\tovl_inode_init(d_inode(root), &oip, ino, fsid);\n\tovl_dentry_init_flags(root, upperdentry, oe, DCACHE_OP_WEAK_REVALIDATE);\n\t \n\tdget(upperdentry);\n\n\treturn root;\n}\n\nint ovl_fill_super(struct super_block *sb, struct fs_context *fc)\n{\n\tstruct ovl_fs *ofs = sb->s_fs_info;\n\tstruct ovl_fs_context *ctx = fc->fs_private;\n\tstruct dentry *root_dentry;\n\tstruct ovl_entry *oe;\n\tstruct ovl_layer *layers;\n\tstruct cred *cred;\n\tint err;\n\n\terr = -EIO;\n\tif (WARN_ON(fc->user_ns != current_user_ns()))\n\t\tgoto out_err;\n\n\tsb->s_d_op = &ovl_dentry_operations;\n\n\terr = -ENOMEM;\n\tofs->creator_cred = cred = prepare_creds();\n\tif (!cred)\n\t\tgoto out_err;\n\n\terr = ovl_fs_params_verify(ctx, &ofs->config);\n\tif (err)\n\t\tgoto out_err;\n\n\terr = -EINVAL;\n\tif (ctx->nr == 0) {\n\t\tif (!(fc->sb_flags & SB_SILENT))\n\t\t\tpr_err(\"missing 'lowerdir'\\n\");\n\t\tgoto out_err;\n\t}\n\n\terr = -ENOMEM;\n\tlayers = kcalloc(ctx->nr + 1, sizeof(struct ovl_layer), GFP_KERNEL);\n\tif (!layers)\n\t\tgoto out_err;\n\n\tofs->config.lowerdirs = kcalloc(ctx->nr + 1, sizeof(char *), GFP_KERNEL);\n\tif (!ofs->config.lowerdirs) {\n\t\tkfree(layers);\n\t\tgoto out_err;\n\t}\n\tofs->layers = layers;\n\t \n\tofs->numlayer = 1;\n\n\tsb->s_stack_depth = 0;\n\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\tatomic_long_set(&ofs->last_ino, 1);\n\t \n\tif (ofs->config.xino != OVL_XINO_OFF) {\n\t\tofs->xino_mode = BITS_PER_LONG - 32;\n\t\tif (!ofs->xino_mode) {\n\t\t\tpr_warn(\"xino not supported on 32bit kernel, falling back to xino=off.\\n\");\n\t\t\tofs->config.xino = OVL_XINO_OFF;\n\t\t}\n\t}\n\n\t \n\tsb->s_op = &ovl_super_operations;\n\n\tif (ofs->config.upperdir) {\n\t\tstruct super_block *upper_sb;\n\n\t\terr = -EINVAL;\n\t\tif (!ofs->config.workdir) {\n\t\t\tpr_err(\"missing 'workdir'\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\n\t\terr = ovl_get_upper(sb, ofs, &layers[0], &ctx->upper);\n\t\tif (err)\n\t\t\tgoto out_err;\n\n\t\tupper_sb = ovl_upper_mnt(ofs)->mnt_sb;\n\t\tif (!ovl_should_sync(ofs)) {\n\t\t\tofs->errseq = errseq_sample(&upper_sb->s_wb_err);\n\t\t\tif (errseq_check(&upper_sb->s_wb_err, ofs->errseq)) {\n\t\t\t\terr = -EIO;\n\t\t\t\tpr_err(\"Cannot mount volatile when upperdir has an unseen error. Sync upperdir fs to clear state.\\n\");\n\t\t\t\tgoto out_err;\n\t\t\t}\n\t\t}\n\n\t\terr = ovl_get_workdir(sb, ofs, &ctx->upper, &ctx->work);\n\t\tif (err)\n\t\t\tgoto out_err;\n\n\t\tif (!ofs->workdir)\n\t\t\tsb->s_flags |= SB_RDONLY;\n\n\t\tsb->s_stack_depth = upper_sb->s_stack_depth;\n\t\tsb->s_time_gran = upper_sb->s_time_gran;\n\t}\n\toe = ovl_get_lowerstack(sb, ctx, ofs, layers);\n\terr = PTR_ERR(oe);\n\tif (IS_ERR(oe))\n\t\tgoto out_err;\n\n\t \n\tif (!ovl_upper_mnt(ofs))\n\t\tsb->s_flags |= SB_RDONLY;\n\n\tif (!ovl_origin_uuid(ofs) && ofs->numfs > 1) {\n\t\tpr_warn(\"The uuid=off requires a single fs for lower and upper, falling back to uuid=null.\\n\");\n\t\tofs->config.uuid = OVL_UUID_NULL;\n\t} else if (ovl_has_fsid(ofs) && ovl_upper_mnt(ofs)) {\n\t\t \n\t\tovl_init_uuid_xattr(sb, ofs, &ctx->upper);\n\t}\n\n\tif (!ovl_force_readonly(ofs) && ofs->config.index) {\n\t\terr = ovl_get_indexdir(sb, ofs, oe, &ctx->upper);\n\t\tif (err)\n\t\t\tgoto out_free_oe;\n\n\t\t \n\t\tif (!ofs->indexdir)\n\t\t\tsb->s_flags |= SB_RDONLY;\n\t}\n\n\terr = ovl_check_overlapping_layers(sb, ofs);\n\tif (err)\n\t\tgoto out_free_oe;\n\n\t \n\tif (!ofs->indexdir) {\n\t\tofs->config.index = false;\n\t\tif (ovl_upper_mnt(ofs) && ofs->config.nfs_export) {\n\t\t\tpr_warn(\"NFS export requires an index dir, falling back to nfs_export=off.\\n\");\n\t\t\tofs->config.nfs_export = false;\n\t\t}\n\t}\n\n\tif (ofs->config.metacopy && ofs->config.nfs_export) {\n\t\tpr_warn(\"NFS export is not supported with metadata only copy up, falling back to nfs_export=off.\\n\");\n\t\tofs->config.nfs_export = false;\n\t}\n\n\t \n\tif (ofs->config.nfs_export)\n\t\tsb->s_export_op = &ovl_export_operations;\n\telse if (!ofs->nofh)\n\t\tsb->s_export_op = &ovl_export_fid_operations;\n\n\t \n\tcap_lower(cred->cap_effective, CAP_SYS_RESOURCE);\n\n\tsb->s_magic = OVERLAYFS_SUPER_MAGIC;\n\tsb->s_xattr = ofs->config.userxattr ? ovl_user_xattr_handlers :\n\t\tovl_trusted_xattr_handlers;\n\tsb->s_fs_info = ofs;\n\tsb->s_flags |= SB_POSIXACL;\n\tsb->s_iflags |= SB_I_SKIP_SYNC;\n\n\terr = -ENOMEM;\n\troot_dentry = ovl_get_root(sb, ctx->upper.dentry, oe);\n\tif (!root_dentry)\n\t\tgoto out_free_oe;\n\n\tsb->s_root = root_dentry;\n\n\treturn 0;\n\nout_free_oe:\n\tovl_free_entry(oe);\nout_err:\n\tovl_free_fs(ofs);\n\tsb->s_fs_info = NULL;\n\treturn err;\n}\n\nstruct file_system_type ovl_fs_type = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.name\t\t\t= \"overlay\",\n\t.init_fs_context\t= ovl_init_fs_context,\n\t.parameters\t\t= ovl_parameter_spec,\n\t.fs_flags\t\t= FS_USERNS_MOUNT,\n\t.kill_sb\t\t= kill_anon_super,\n};\nMODULE_ALIAS_FS(\"overlay\");\n\nstatic void ovl_inode_init_once(void *foo)\n{\n\tstruct ovl_inode *oi = foo;\n\n\tinode_init_once(&oi->vfs_inode);\n}\n\nstatic int __init ovl_init(void)\n{\n\tint err;\n\n\tovl_inode_cachep = kmem_cache_create(\"ovl_inode\",\n\t\t\t\t\t     sizeof(struct ovl_inode), 0,\n\t\t\t\t\t     (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t      SLAB_MEM_SPREAD|SLAB_ACCOUNT),\n\t\t\t\t\t     ovl_inode_init_once);\n\tif (ovl_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\n\terr = ovl_aio_request_cache_init();\n\tif (!err) {\n\t\terr = register_filesystem(&ovl_fs_type);\n\t\tif (!err)\n\t\t\treturn 0;\n\n\t\tovl_aio_request_cache_destroy();\n\t}\n\tkmem_cache_destroy(ovl_inode_cachep);\n\n\treturn err;\n}\n\nstatic void __exit ovl_exit(void)\n{\n\tunregister_filesystem(&ovl_fs_type);\n\n\t \n\trcu_barrier();\n\tkmem_cache_destroy(ovl_inode_cachep);\n\tovl_aio_request_cache_destroy();\n}\n\nmodule_init(ovl_init);\nmodule_exit(ovl_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}