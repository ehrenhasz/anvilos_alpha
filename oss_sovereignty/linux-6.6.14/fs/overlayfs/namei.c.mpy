{
  "module_name": "namei.c",
  "hash_id": "f3e56bcfa56d5b34023bdcb4426eabfac32eadd437c19b4fd050683883610ccd",
  "original_prompt": "Ingested from linux-6.6.14/fs/overlayfs/namei.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/cred.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/ratelimit.h>\n#include <linux/mount.h>\n#include <linux/exportfs.h>\n#include \"overlayfs.h\"\n\n#include \"../internal.h\"\t \n\nstruct ovl_lookup_data {\n\tstruct super_block *sb;\n\tstruct vfsmount *mnt;\n\tstruct qstr name;\n\tbool is_dir;\n\tbool opaque;\n\tbool stop;\n\tbool last;\n\tchar *redirect;\n\tint metacopy;\n\t \n\tbool absolute_redirect;\n};\n\nstatic int ovl_check_redirect(const struct path *path, struct ovl_lookup_data *d,\n\t\t\t      size_t prelen, const char *post)\n{\n\tint res;\n\tchar *buf;\n\tstruct ovl_fs *ofs = OVL_FS(d->sb);\n\n\td->absolute_redirect = false;\n\tbuf = ovl_get_redirect_xattr(ofs, path, prelen + strlen(post));\n\tif (IS_ERR_OR_NULL(buf))\n\t\treturn PTR_ERR(buf);\n\n\tif (buf[0] == '/') {\n\t\td->absolute_redirect = true;\n\t\t \n\t\td->stop = false;\n\t} else {\n\t\tres = strlen(buf) + 1;\n\t\tmemmove(buf + prelen, buf, res);\n\t\tmemcpy(buf, d->name.name, prelen);\n\t}\n\n\tstrcat(buf, post);\n\tkfree(d->redirect);\n\td->redirect = buf;\n\td->name.name = d->redirect;\n\td->name.len = strlen(d->redirect);\n\n\treturn 0;\n}\n\nstatic int ovl_acceptable(void *ctx, struct dentry *dentry)\n{\n\t \n\tif (!d_is_dir(dentry))\n\t\treturn 1;\n\n\t \n\tif (d_unhashed(dentry))\n\t\treturn 0;\n\n\t \n\treturn is_subdir(dentry, ((struct vfsmount *)ctx)->mnt_root);\n}\n\n \nint ovl_check_fb_len(struct ovl_fb *fb, int fb_len)\n{\n\tif (fb_len < sizeof(struct ovl_fb) || fb_len < fb->len)\n\t\treturn -EINVAL;\n\n\tif (fb->magic != OVL_FH_MAGIC)\n\t\treturn -EINVAL;\n\n\t \n\tif (fb->version > OVL_FH_VERSION || fb->flags & ~OVL_FH_FLAG_ALL)\n\t\treturn -ENODATA;\n\n\t \n\tif (!(fb->flags & OVL_FH_FLAG_ANY_ENDIAN) &&\n\t    (fb->flags & OVL_FH_FLAG_BIG_ENDIAN) != OVL_FH_FLAG_CPU_ENDIAN)\n\t\treturn -ENODATA;\n\n\treturn 0;\n}\n\nstatic struct ovl_fh *ovl_get_fh(struct ovl_fs *ofs, struct dentry *upperdentry,\n\t\t\t\t enum ovl_xattr ox)\n{\n\tint res, err;\n\tstruct ovl_fh *fh = NULL;\n\n\tres = ovl_getxattr_upper(ofs, upperdentry, ox, NULL, 0);\n\tif (res < 0) {\n\t\tif (res == -ENODATA || res == -EOPNOTSUPP)\n\t\t\treturn NULL;\n\t\tgoto fail;\n\t}\n\t \n\tif (res == 0)\n\t\treturn NULL;\n\n\tfh = kzalloc(res + OVL_FH_WIRE_OFFSET, GFP_KERNEL);\n\tif (!fh)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tres = ovl_getxattr_upper(ofs, upperdentry, ox, fh->buf, res);\n\tif (res < 0)\n\t\tgoto fail;\n\n\terr = ovl_check_fb_len(&fh->fb, res);\n\tif (err < 0) {\n\t\tif (err == -ENODATA)\n\t\t\tgoto out;\n\t\tgoto invalid;\n\t}\n\n\treturn fh;\n\nout:\n\tkfree(fh);\n\treturn NULL;\n\nfail:\n\tpr_warn_ratelimited(\"failed to get origin (%i)\\n\", res);\n\tgoto out;\ninvalid:\n\tpr_warn_ratelimited(\"invalid origin (%*phN)\\n\", res, fh);\n\tgoto out;\n}\n\nstruct dentry *ovl_decode_real_fh(struct ovl_fs *ofs, struct ovl_fh *fh,\n\t\t\t\t  struct vfsmount *mnt, bool connected)\n{\n\tstruct dentry *real;\n\tint bytes;\n\n\tif (!capable(CAP_DAC_READ_SEARCH))\n\t\treturn NULL;\n\n\t \n\tif (ovl_origin_uuid(ofs) ?\n\t    !uuid_equal(&fh->fb.uuid, &mnt->mnt_sb->s_uuid) :\n\t    !uuid_is_null(&fh->fb.uuid))\n\t\treturn NULL;\n\n\tbytes = (fh->fb.len - offsetof(struct ovl_fb, fid));\n\treal = exportfs_decode_fh(mnt, (struct fid *)fh->fb.fid,\n\t\t\t\t  bytes >> 2, (int)fh->fb.type,\n\t\t\t\t  connected ? ovl_acceptable : NULL, mnt);\n\tif (IS_ERR(real)) {\n\t\t \n\t\tif (real == ERR_PTR(-ESTALE) &&\n\t\t    !(fh->fb.flags & OVL_FH_FLAG_PATH_UPPER))\n\t\t\treal = NULL;\n\t\treturn real;\n\t}\n\n\tif (ovl_dentry_weird(real)) {\n\t\tdput(real);\n\t\treturn NULL;\n\t}\n\n\treturn real;\n}\n\nstatic bool ovl_is_opaquedir(struct ovl_fs *ofs, const struct path *path)\n{\n\treturn ovl_path_check_dir_xattr(ofs, path, OVL_XATTR_OPAQUE);\n}\n\nstatic struct dentry *ovl_lookup_positive_unlocked(struct ovl_lookup_data *d,\n\t\t\t\t\t\t   const char *name,\n\t\t\t\t\t\t   struct dentry *base, int len,\n\t\t\t\t\t\t   bool drop_negative)\n{\n\tstruct dentry *ret = lookup_one_unlocked(mnt_idmap(d->mnt), name, base, len);\n\n\tif (!IS_ERR(ret) && d_flags_negative(smp_load_acquire(&ret->d_flags))) {\n\t\tif (drop_negative && ret->d_lockref.count == 1) {\n\t\t\tspin_lock(&ret->d_lock);\n\t\t\t \n\t\t\tif (d_is_negative(ret) && ret->d_lockref.count == 1)\n\t\t\t\t__d_drop(ret);\n\t\t\tspin_unlock(&ret->d_lock);\n\t\t}\n\t\tdput(ret);\n\t\tret = ERR_PTR(-ENOENT);\n\t}\n\treturn ret;\n}\n\nstatic int ovl_lookup_single(struct dentry *base, struct ovl_lookup_data *d,\n\t\t\t     const char *name, unsigned int namelen,\n\t\t\t     size_t prelen, const char *post,\n\t\t\t     struct dentry **ret, bool drop_negative)\n{\n\tstruct dentry *this;\n\tstruct path path;\n\tint err;\n\tbool last_element = !post[0];\n\n\tthis = ovl_lookup_positive_unlocked(d, name, base, namelen, drop_negative);\n\tif (IS_ERR(this)) {\n\t\terr = PTR_ERR(this);\n\t\tthis = NULL;\n\t\tif (err == -ENOENT || err == -ENAMETOOLONG)\n\t\t\tgoto out;\n\t\tgoto out_err;\n\t}\n\n\tif (ovl_dentry_weird(this)) {\n\t\t \n\t\terr = -EREMOTE;\n\t\tgoto out_err;\n\t}\n\tif (ovl_is_whiteout(this)) {\n\t\td->stop = d->opaque = true;\n\t\tgoto put_and_out;\n\t}\n\t \n\tif (last_element && d->metacopy && !d_is_reg(this)) {\n\t\td->stop = true;\n\t\tgoto put_and_out;\n\t}\n\n\tpath.dentry = this;\n\tpath.mnt = d->mnt;\n\tif (!d_can_lookup(this)) {\n\t\tif (d->is_dir || !last_element) {\n\t\t\td->stop = true;\n\t\t\tgoto put_and_out;\n\t\t}\n\t\terr = ovl_check_metacopy_xattr(OVL_FS(d->sb), &path, NULL);\n\t\tif (err < 0)\n\t\t\tgoto out_err;\n\n\t\td->metacopy = err;\n\t\td->stop = !d->metacopy;\n\t\tif (!d->metacopy || d->last)\n\t\t\tgoto out;\n\t} else {\n\t\tif (ovl_lookup_trap_inode(d->sb, this)) {\n\t\t\t \n\t\t\terr = -ELOOP;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tif (last_element)\n\t\t\td->is_dir = true;\n\t\tif (d->last)\n\t\t\tgoto out;\n\n\t\tif (ovl_is_opaquedir(OVL_FS(d->sb), &path)) {\n\t\t\td->stop = true;\n\t\t\tif (last_element)\n\t\t\t\td->opaque = true;\n\t\t\tgoto out;\n\t\t}\n\t}\n\terr = ovl_check_redirect(&path, d, prelen, post);\n\tif (err)\n\t\tgoto out_err;\nout:\n\t*ret = this;\n\treturn 0;\n\nput_and_out:\n\tdput(this);\n\tthis = NULL;\n\tgoto out;\n\nout_err:\n\tdput(this);\n\treturn err;\n}\n\nstatic int ovl_lookup_layer(struct dentry *base, struct ovl_lookup_data *d,\n\t\t\t    struct dentry **ret, bool drop_negative)\n{\n\t \n\tsize_t rem = d->name.len - 1;\n\tstruct dentry *dentry = NULL;\n\tint err;\n\n\tif (d->name.name[0] != '/')\n\t\treturn ovl_lookup_single(base, d, d->name.name, d->name.len,\n\t\t\t\t\t 0, \"\", ret, drop_negative);\n\n\twhile (!IS_ERR_OR_NULL(base) && d_can_lookup(base)) {\n\t\tconst char *s = d->name.name + d->name.len - rem;\n\t\tconst char *next = strchrnul(s, '/');\n\t\tsize_t thislen = next - s;\n\t\tbool end = !next[0];\n\n\t\t \n\t\tif (WARN_ON(s[-1] != '/'))\n\t\t\treturn -EIO;\n\n\t\terr = ovl_lookup_single(base, d, s, thislen,\n\t\t\t\t\td->name.len - rem, next, &base,\n\t\t\t\t\tdrop_negative);\n\t\tdput(dentry);\n\t\tif (err)\n\t\t\treturn err;\n\t\tdentry = base;\n\t\tif (end)\n\t\t\tbreak;\n\n\t\trem -= thislen + 1;\n\n\t\tif (WARN_ON(rem >= d->name.len))\n\t\t\treturn -EIO;\n\t}\n\t*ret = dentry;\n\treturn 0;\n}\n\nstatic int ovl_lookup_data_layer(struct dentry *dentry, const char *redirect,\n\t\t\t\t const struct ovl_layer *layer,\n\t\t\t\t struct path *datapath)\n{\n\tint err;\n\n\terr = vfs_path_lookup(layer->mnt->mnt_root, layer->mnt, redirect,\n\t\t\tLOOKUP_BENEATH | LOOKUP_NO_SYMLINKS | LOOKUP_NO_XDEV,\n\t\t\tdatapath);\n\tpr_debug(\"lookup lowerdata (%pd2, redirect=\\\"%s\\\", layer=%d, err=%i)\\n\",\n\t\t dentry, redirect, layer->idx, err);\n\n\tif (err)\n\t\treturn err;\n\n\terr = -EREMOTE;\n\tif (ovl_dentry_weird(datapath->dentry))\n\t\tgoto out_path_put;\n\n\terr = -ENOENT;\n\t \n\tif (!d_is_reg(datapath->dentry))\n\t\tgoto out_path_put;\n\n\treturn 0;\n\nout_path_put:\n\tpath_put(datapath);\n\n\treturn err;\n}\n\n \nstatic int ovl_lookup_data_layers(struct dentry *dentry, const char *redirect,\n\t\t\t\t  struct ovl_path *lowerdata)\n{\n\tstruct ovl_fs *ofs = OVL_FS(dentry->d_sb);\n\tconst struct ovl_layer *layer;\n\tstruct path datapath;\n\tint err = -ENOENT;\n\tint i;\n\n\tlayer = &ofs->layers[ofs->numlayer - ofs->numdatalayer];\n\tfor (i = 0; i < ofs->numdatalayer; i++, layer++) {\n\t\terr = ovl_lookup_data_layer(dentry, redirect, layer, &datapath);\n\t\tif (!err) {\n\t\t\tmntput(datapath.mnt);\n\t\t\tlowerdata->dentry = datapath.dentry;\n\t\t\tlowerdata->layer = layer;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn err;\n}\n\nint ovl_check_origin_fh(struct ovl_fs *ofs, struct ovl_fh *fh, bool connected,\n\t\t\tstruct dentry *upperdentry, struct ovl_path **stackp)\n{\n\tstruct dentry *origin = NULL;\n\tint i;\n\n\tfor (i = 1; i <= ovl_numlowerlayer(ofs); i++) {\n\t\t \n\t\tif (ofs->layers[i].fsid &&\n\t\t    ofs->layers[i].fs->bad_uuid)\n\t\t\tcontinue;\n\n\t\torigin = ovl_decode_real_fh(ofs, fh, ofs->layers[i].mnt,\n\t\t\t\t\t    connected);\n\t\tif (origin)\n\t\t\tbreak;\n\t}\n\n\tif (!origin)\n\t\treturn -ESTALE;\n\telse if (IS_ERR(origin))\n\t\treturn PTR_ERR(origin);\n\n\tif (upperdentry && !ovl_is_whiteout(upperdentry) &&\n\t    inode_wrong_type(d_inode(upperdentry), d_inode(origin)->i_mode))\n\t\tgoto invalid;\n\n\tif (!*stackp)\n\t\t*stackp = kmalloc(sizeof(struct ovl_path), GFP_KERNEL);\n\tif (!*stackp) {\n\t\tdput(origin);\n\t\treturn -ENOMEM;\n\t}\n\t**stackp = (struct ovl_path){\n\t\t.dentry = origin,\n\t\t.layer = &ofs->layers[i]\n\t};\n\n\treturn 0;\n\ninvalid:\n\tpr_warn_ratelimited(\"invalid origin (%pd2, ftype=%x, origin ftype=%x).\\n\",\n\t\t\t    upperdentry, d_inode(upperdentry)->i_mode & S_IFMT,\n\t\t\t    d_inode(origin)->i_mode & S_IFMT);\n\tdput(origin);\n\treturn -ESTALE;\n}\n\nstatic int ovl_check_origin(struct ovl_fs *ofs, struct dentry *upperdentry,\n\t\t\t    struct ovl_path **stackp)\n{\n\tstruct ovl_fh *fh = ovl_get_fh(ofs, upperdentry, OVL_XATTR_ORIGIN);\n\tint err;\n\n\tif (IS_ERR_OR_NULL(fh))\n\t\treturn PTR_ERR(fh);\n\n\terr = ovl_check_origin_fh(ofs, fh, false, upperdentry, stackp);\n\tkfree(fh);\n\n\tif (err) {\n\t\tif (err == -ESTALE)\n\t\t\treturn 0;\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ovl_verify_fh(struct ovl_fs *ofs, struct dentry *dentry,\n\t\t\t enum ovl_xattr ox, const struct ovl_fh *fh)\n{\n\tstruct ovl_fh *ofh = ovl_get_fh(ofs, dentry, ox);\n\tint err = 0;\n\n\tif (!ofh)\n\t\treturn -ENODATA;\n\n\tif (IS_ERR(ofh))\n\t\treturn PTR_ERR(ofh);\n\n\tif (fh->fb.len != ofh->fb.len || memcmp(&fh->fb, &ofh->fb, fh->fb.len))\n\t\terr = -ESTALE;\n\n\tkfree(ofh);\n\treturn err;\n}\n\n \nint ovl_verify_set_fh(struct ovl_fs *ofs, struct dentry *dentry,\n\t\t      enum ovl_xattr ox, struct dentry *real, bool is_upper,\n\t\t      bool set)\n{\n\tstruct inode *inode;\n\tstruct ovl_fh *fh;\n\tint err;\n\n\tfh = ovl_encode_real_fh(ofs, real, is_upper);\n\terr = PTR_ERR(fh);\n\tif (IS_ERR(fh)) {\n\t\tfh = NULL;\n\t\tgoto fail;\n\t}\n\n\terr = ovl_verify_fh(ofs, dentry, ox, fh);\n\tif (set && err == -ENODATA)\n\t\terr = ovl_setxattr(ofs, dentry, ox, fh->buf, fh->fb.len);\n\tif (err)\n\t\tgoto fail;\n\nout:\n\tkfree(fh);\n\treturn err;\n\nfail:\n\tinode = d_inode(real);\n\tpr_warn_ratelimited(\"failed to verify %s (%pd2, ino=%lu, err=%i)\\n\",\n\t\t\t    is_upper ? \"upper\" : \"origin\", real,\n\t\t\t    inode ? inode->i_ino : 0, err);\n\tgoto out;\n}\n\n \nstruct dentry *ovl_index_upper(struct ovl_fs *ofs, struct dentry *index,\n\t\t\t       bool connected)\n{\n\tstruct ovl_fh *fh;\n\tstruct dentry *upper;\n\n\tif (!d_is_dir(index))\n\t\treturn dget(index);\n\n\tfh = ovl_get_fh(ofs, index, OVL_XATTR_UPPER);\n\tif (IS_ERR_OR_NULL(fh))\n\t\treturn ERR_CAST(fh);\n\n\tupper = ovl_decode_real_fh(ofs, fh, ovl_upper_mnt(ofs), connected);\n\tkfree(fh);\n\n\tif (IS_ERR_OR_NULL(upper))\n\t\treturn upper ?: ERR_PTR(-ESTALE);\n\n\tif (!d_is_dir(upper)) {\n\t\tpr_warn_ratelimited(\"invalid index upper (%pd2, upper=%pd2).\\n\",\n\t\t\t\t    index, upper);\n\t\tdput(upper);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\treturn upper;\n}\n\n \nint ovl_verify_index(struct ovl_fs *ofs, struct dentry *index)\n{\n\tstruct ovl_fh *fh = NULL;\n\tsize_t len;\n\tstruct ovl_path origin = { };\n\tstruct ovl_path *stack = &origin;\n\tstruct dentry *upper = NULL;\n\tint err;\n\n\tif (!d_inode(index))\n\t\treturn 0;\n\n\terr = -EINVAL;\n\tif (index->d_name.len < sizeof(struct ovl_fb)*2)\n\t\tgoto fail;\n\n\terr = -ENOMEM;\n\tlen = index->d_name.len / 2;\n\tfh = kzalloc(len + OVL_FH_WIRE_OFFSET, GFP_KERNEL);\n\tif (!fh)\n\t\tgoto fail;\n\n\terr = -EINVAL;\n\tif (hex2bin(fh->buf, index->d_name.name, len))\n\t\tgoto fail;\n\n\terr = ovl_check_fb_len(&fh->fb, len);\n\tif (err)\n\t\tgoto fail;\n\n\t \n\tif (ovl_is_whiteout(index))\n\t\tgoto out;\n\n\t \n\tif (d_is_dir(index) && !ofs->config.nfs_export)\n\t\tgoto out;\n\n\t \n\tupper = ovl_index_upper(ofs, index, false);\n\tif (IS_ERR_OR_NULL(upper)) {\n\t\terr = PTR_ERR(upper);\n\t\t \n\t\tif (err == -ESTALE)\n\t\t\tgoto orphan;\n\t\telse if (!err)\n\t\t\terr = -ESTALE;\n\t\tgoto fail;\n\t}\n\n\terr = ovl_verify_fh(ofs, upper, OVL_XATTR_ORIGIN, fh);\n\tdput(upper);\n\tif (err)\n\t\tgoto fail;\n\n\t \n\tif (!d_is_dir(index) && d_inode(index)->i_nlink == 1) {\n\t\terr = ovl_check_origin_fh(ofs, fh, false, index, &stack);\n\t\tif (err)\n\t\t\tgoto fail;\n\n\t\tif (ovl_get_nlink(ofs, origin.dentry, index, 0) == 0)\n\t\t\tgoto orphan;\n\t}\n\nout:\n\tdput(origin.dentry);\n\tkfree(fh);\n\treturn err;\n\nfail:\n\tpr_warn_ratelimited(\"failed to verify index (%pd2, ftype=%x, err=%i)\\n\",\n\t\t\t    index, d_inode(index)->i_mode & S_IFMT, err);\n\tgoto out;\n\norphan:\n\tpr_warn_ratelimited(\"orphan index entry (%pd2, ftype=%x, nlink=%u)\\n\",\n\t\t\t    index, d_inode(index)->i_mode & S_IFMT,\n\t\t\t    d_inode(index)->i_nlink);\n\terr = -ENOENT;\n\tgoto out;\n}\n\nstatic int ovl_get_index_name_fh(struct ovl_fh *fh, struct qstr *name)\n{\n\tchar *n, *s;\n\n\tn = kcalloc(fh->fb.len, 2, GFP_KERNEL);\n\tif (!n)\n\t\treturn -ENOMEM;\n\n\ts  = bin2hex(n, fh->buf, fh->fb.len);\n\t*name = (struct qstr) QSTR_INIT(n, s - n);\n\n\treturn 0;\n\n}\n\n \nint ovl_get_index_name(struct ovl_fs *ofs, struct dentry *origin,\n\t\t       struct qstr *name)\n{\n\tstruct ovl_fh *fh;\n\tint err;\n\n\tfh = ovl_encode_real_fh(ofs, origin, false);\n\tif (IS_ERR(fh))\n\t\treturn PTR_ERR(fh);\n\n\terr = ovl_get_index_name_fh(fh, name);\n\n\tkfree(fh);\n\treturn err;\n}\n\n \nstruct dentry *ovl_get_index_fh(struct ovl_fs *ofs, struct ovl_fh *fh)\n{\n\tstruct dentry *index;\n\tstruct qstr name;\n\tint err;\n\n\terr = ovl_get_index_name_fh(fh, &name);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tindex = lookup_positive_unlocked(name.name, ofs->indexdir, name.len);\n\tkfree(name.name);\n\tif (IS_ERR(index)) {\n\t\tif (PTR_ERR(index) == -ENOENT)\n\t\t\tindex = NULL;\n\t\treturn index;\n\t}\n\n\tif (ovl_is_whiteout(index))\n\t\terr = -ESTALE;\n\telse if (ovl_dentry_weird(index))\n\t\terr = -EIO;\n\telse\n\t\treturn index;\n\n\tdput(index);\n\treturn ERR_PTR(err);\n}\n\nstruct dentry *ovl_lookup_index(struct ovl_fs *ofs, struct dentry *upper,\n\t\t\t\tstruct dentry *origin, bool verify)\n{\n\tstruct dentry *index;\n\tstruct inode *inode;\n\tstruct qstr name;\n\tbool is_dir = d_is_dir(origin);\n\tint err;\n\n\terr = ovl_get_index_name(ofs, origin, &name);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tindex = lookup_one_positive_unlocked(ovl_upper_mnt_idmap(ofs), name.name,\n\t\t\t\t\t     ofs->indexdir, name.len);\n\tif (IS_ERR(index)) {\n\t\terr = PTR_ERR(index);\n\t\tif (err == -ENOENT) {\n\t\t\tindex = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tpr_warn_ratelimited(\"failed inode index lookup (ino=%lu, key=%.*s, err=%i);\\n\"\n\t\t\t\t    \"overlayfs: mount with '-o index=off' to disable inodes index.\\n\",\n\t\t\t\t    d_inode(origin)->i_ino, name.len, name.name,\n\t\t\t\t    err);\n\t\tgoto out;\n\t}\n\n\tinode = d_inode(index);\n\tif (ovl_is_whiteout(index) && !verify) {\n\t\t \n\t\tdput(index);\n\t\tindex = ERR_PTR(-ESTALE);\n\t\tgoto out;\n\t} else if (ovl_dentry_weird(index) || ovl_is_whiteout(index) ||\n\t\t   inode_wrong_type(inode, d_inode(origin)->i_mode)) {\n\t\t \n\t\tpr_warn_ratelimited(\"bad index found (index=%pd2, ftype=%x, origin ftype=%x).\\n\",\n\t\t\t\t    index, d_inode(index)->i_mode & S_IFMT,\n\t\t\t\t    d_inode(origin)->i_mode & S_IFMT);\n\t\tgoto fail;\n\t} else if (is_dir && verify) {\n\t\tif (!upper) {\n\t\t\tpr_warn_ratelimited(\"suspected uncovered redirected dir found (origin=%pd2, index=%pd2).\\n\",\n\t\t\t\t\t    origin, index);\n\t\t\tgoto fail;\n\t\t}\n\n\t\t \n\t\terr = ovl_verify_upper(ofs, index, upper, false);\n\t\tif (err) {\n\t\t\tif (err == -ESTALE) {\n\t\t\t\tpr_warn_ratelimited(\"suspected multiply redirected dir found (upper=%pd2, origin=%pd2, index=%pd2).\\n\",\n\t\t\t\t\t\t    upper, origin, index);\n\t\t\t}\n\t\t\tgoto fail;\n\t\t}\n\t} else if (upper && d_inode(upper) != inode) {\n\t\tgoto out_dput;\n\t}\nout:\n\tkfree(name.name);\n\treturn index;\n\nout_dput:\n\tdput(index);\n\tindex = NULL;\n\tgoto out;\n\nfail:\n\tdput(index);\n\tindex = ERR_PTR(-EIO);\n\tgoto out;\n}\n\n \nint ovl_path_next(int idx, struct dentry *dentry, struct path *path)\n{\n\tstruct ovl_entry *oe = OVL_E(dentry);\n\tstruct ovl_path *lowerstack = ovl_lowerstack(oe);\n\n\tBUG_ON(idx < 0);\n\tif (idx == 0) {\n\t\tovl_path_upper(dentry, path);\n\t\tif (path->dentry)\n\t\t\treturn ovl_numlower(oe) ? 1 : -1;\n\t\tidx++;\n\t}\n\tBUG_ON(idx > ovl_numlower(oe));\n\tpath->dentry = lowerstack[idx - 1].dentry;\n\tpath->mnt = lowerstack[idx - 1].layer->mnt;\n\n\treturn (idx < ovl_numlower(oe)) ? idx + 1 : -1;\n}\n\n \nstatic int ovl_fix_origin(struct ovl_fs *ofs, struct dentry *dentry,\n\t\t\t  struct dentry *lower, struct dentry *upper)\n{\n\tint err;\n\n\tif (ovl_check_origin_xattr(ofs, upper))\n\t\treturn 0;\n\n\terr = ovl_want_write(dentry);\n\tif (err)\n\t\treturn err;\n\n\terr = ovl_set_origin(ofs, lower, upper);\n\tif (!err)\n\t\terr = ovl_set_impure(dentry->d_parent, upper->d_parent);\n\n\tovl_drop_write(dentry);\n\treturn err;\n}\n\nstatic int ovl_maybe_validate_verity(struct dentry *dentry)\n{\n\tstruct ovl_fs *ofs = OVL_FS(dentry->d_sb);\n\tstruct inode *inode = d_inode(dentry);\n\tstruct path datapath, metapath;\n\tint err;\n\n\tif (!ofs->config.verity_mode ||\n\t    !ovl_is_metacopy_dentry(dentry) ||\n\t    ovl_test_flag(OVL_VERIFIED_DIGEST, inode))\n\t\treturn 0;\n\n\tif (!ovl_test_flag(OVL_HAS_DIGEST, inode)) {\n\t\tif (ofs->config.verity_mode == OVL_VERITY_REQUIRE) {\n\t\t\tpr_warn_ratelimited(\"metacopy file '%pd' has no digest specified\\n\",\n\t\t\t\t\t    dentry);\n\t\t\treturn -EIO;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tovl_path_lowerdata(dentry, &datapath);\n\tif (!datapath.dentry)\n\t\treturn -EIO;\n\n\tovl_path_real(dentry, &metapath);\n\tif (!metapath.dentry)\n\t\treturn -EIO;\n\n\terr = ovl_inode_lock_interruptible(inode);\n\tif (err)\n\t\treturn err;\n\n\tif (!ovl_test_flag(OVL_VERIFIED_DIGEST, inode)) {\n\t\tconst struct cred *old_cred;\n\n\t\told_cred = ovl_override_creds(dentry->d_sb);\n\n\t\terr = ovl_validate_verity(ofs, &metapath, &datapath);\n\t\tif (err == 0)\n\t\t\tovl_set_flag(OVL_VERIFIED_DIGEST, inode);\n\n\t\trevert_creds(old_cred);\n\t}\n\n\tovl_inode_unlock(inode);\n\n\treturn err;\n}\n\n \nstatic int ovl_maybe_lookup_lowerdata(struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tconst char *redirect = ovl_lowerdata_redirect(inode);\n\tstruct ovl_path datapath = {};\n\tconst struct cred *old_cred;\n\tint err;\n\n\tif (!redirect || ovl_dentry_lowerdata(dentry))\n\t\treturn 0;\n\n\tif (redirect[0] != '/')\n\t\treturn -EIO;\n\n\terr = ovl_inode_lock_interruptible(inode);\n\tif (err)\n\t\treturn err;\n\n\terr = 0;\n\t \n\tif (ovl_dentry_lowerdata(dentry))\n\t\tgoto out;\n\n\told_cred = ovl_override_creds(dentry->d_sb);\n\terr = ovl_lookup_data_layers(dentry, redirect, &datapath);\n\trevert_creds(old_cred);\n\tif (err)\n\t\tgoto out_err;\n\n\terr = ovl_dentry_set_lowerdata(dentry, &datapath);\n\tif (err)\n\t\tgoto out_err;\n\nout:\n\tovl_inode_unlock(inode);\n\tdput(datapath.dentry);\n\n\treturn err;\n\nout_err:\n\tpr_warn_ratelimited(\"lazy lowerdata lookup failed (%pd2, err=%i)\\n\",\n\t\t\t    dentry, err);\n\tgoto out;\n}\n\nint ovl_verify_lowerdata(struct dentry *dentry)\n{\n\tint err;\n\n\terr = ovl_maybe_lookup_lowerdata(dentry);\n\tif (err)\n\t\treturn err;\n\n\treturn ovl_maybe_validate_verity(dentry);\n}\n\nstruct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t  unsigned int flags)\n{\n\tstruct ovl_entry *oe = NULL;\n\tconst struct cred *old_cred;\n\tstruct ovl_fs *ofs = OVL_FS(dentry->d_sb);\n\tstruct ovl_entry *poe = OVL_E(dentry->d_parent);\n\tstruct ovl_entry *roe = OVL_E(dentry->d_sb->s_root);\n\tstruct ovl_path *stack = NULL, *origin_path = NULL;\n\tstruct dentry *upperdir, *upperdentry = NULL;\n\tstruct dentry *origin = NULL;\n\tstruct dentry *index = NULL;\n\tunsigned int ctr = 0;\n\tstruct inode *inode = NULL;\n\tbool upperopaque = false;\n\tchar *upperredirect = NULL;\n\tstruct dentry *this;\n\tunsigned int i;\n\tint err;\n\tbool uppermetacopy = false;\n\tint metacopy_size = 0;\n\tstruct ovl_lookup_data d = {\n\t\t.sb = dentry->d_sb,\n\t\t.name = dentry->d_name,\n\t\t.is_dir = false,\n\t\t.opaque = false,\n\t\t.stop = false,\n\t\t.last = ovl_redirect_follow(ofs) ? false : !ovl_numlower(poe),\n\t\t.redirect = NULL,\n\t\t.metacopy = 0,\n\t};\n\n\tif (dentry->d_name.len > ofs->namelen)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\told_cred = ovl_override_creds(dentry->d_sb);\n\tupperdir = ovl_dentry_upper(dentry->d_parent);\n\tif (upperdir) {\n\t\td.mnt = ovl_upper_mnt(ofs);\n\t\terr = ovl_lookup_layer(upperdir, &d, &upperdentry, true);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tif (upperdentry && upperdentry->d_flags & DCACHE_OP_REAL) {\n\t\t\tdput(upperdentry);\n\t\t\terr = -EREMOTE;\n\t\t\tgoto out;\n\t\t}\n\t\tif (upperdentry && !d.is_dir) {\n\t\t\t \n\t\t\terr = ovl_check_origin(ofs, upperdentry, &origin_path);\n\t\t\tif (err)\n\t\t\t\tgoto out_put_upper;\n\n\t\t\tif (d.metacopy)\n\t\t\t\tuppermetacopy = true;\n\t\t\tmetacopy_size = d.metacopy;\n\t\t}\n\n\t\tif (d.redirect) {\n\t\t\terr = -ENOMEM;\n\t\t\tupperredirect = kstrdup(d.redirect, GFP_KERNEL);\n\t\t\tif (!upperredirect)\n\t\t\t\tgoto out_put_upper;\n\t\t\tif (d.redirect[0] == '/')\n\t\t\t\tpoe = roe;\n\t\t}\n\t\tupperopaque = d.opaque;\n\t}\n\n\tif (!d.stop && ovl_numlower(poe)) {\n\t\terr = -ENOMEM;\n\t\tstack = ovl_stack_alloc(ofs->numlayer - 1);\n\t\tif (!stack)\n\t\t\tgoto out_put_upper;\n\t}\n\n\tfor (i = 0; !d.stop && i < ovl_numlower(poe); i++) {\n\t\tstruct ovl_path lower = ovl_lowerstack(poe)[i];\n\n\t\tif (!ovl_redirect_follow(ofs))\n\t\t\td.last = i == ovl_numlower(poe) - 1;\n\t\telse if (d.is_dir || !ofs->numdatalayer)\n\t\t\td.last = lower.layer->idx == ovl_numlower(roe);\n\n\t\td.mnt = lower.layer->mnt;\n\t\terr = ovl_lookup_layer(lower.dentry, &d, &this, false);\n\t\tif (err)\n\t\t\tgoto out_put;\n\n\t\tif (!this)\n\t\t\tcontinue;\n\n\t\tif ((uppermetacopy || d.metacopy) && !ofs->config.metacopy) {\n\t\t\tdput(this);\n\t\t\terr = -EPERM;\n\t\t\tpr_warn_ratelimited(\"refusing to follow metacopy origin for (%pd2)\\n\", dentry);\n\t\t\tgoto out_put;\n\t\t}\n\n\t\t \n\t\tif (upperdentry && !ctr && !ofs->noxattr && d.is_dir) {\n\t\t\terr = ovl_fix_origin(ofs, dentry, this, upperdentry);\n\t\t\tif (err) {\n\t\t\t\tdput(this);\n\t\t\t\tgoto out_put;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (upperdentry && !ctr &&\n\t\t    ((d.is_dir && ovl_verify_lower(dentry->d_sb)) ||\n\t\t     (!d.is_dir && ofs->config.index && origin_path))) {\n\t\t\terr = ovl_verify_origin(ofs, upperdentry, this, false);\n\t\t\tif (err) {\n\t\t\t\tdput(this);\n\t\t\t\tif (d.is_dir)\n\t\t\t\t\tbreak;\n\t\t\t\tgoto out_put;\n\t\t\t}\n\t\t\torigin = this;\n\t\t}\n\n\t\tif (!upperdentry && !d.is_dir && !ctr && d.metacopy)\n\t\t\tmetacopy_size = d.metacopy;\n\n\t\tif (d.metacopy && ctr) {\n\t\t\t \n\t\t\tdput(this);\n\t\t\tthis = NULL;\n\t\t} else {\n\t\t\tstack[ctr].dentry = this;\n\t\t\tstack[ctr].layer = lower.layer;\n\t\t\tctr++;\n\t\t}\n\n\t\t \n\t\terr = -EPERM;\n\t\tif (d.redirect && !ovl_redirect_follow(ofs)) {\n\t\t\tpr_warn_ratelimited(\"refusing to follow redirect for (%pd2)\\n\",\n\t\t\t\t\t    dentry);\n\t\t\tgoto out_put;\n\t\t}\n\n\t\tif (d.stop)\n\t\t\tbreak;\n\n\t\tif (d.redirect && d.redirect[0] == '/' && poe != roe) {\n\t\t\tpoe = roe;\n\t\t\t \n\t\t\ti = lower.layer->idx - 1;\n\t\t}\n\t}\n\n\t \n\tif (d.metacopy && ctr && ofs->numdatalayer && d.absolute_redirect) {\n\t\td.metacopy = 0;\n\t\tctr++;\n\t}\n\n\t \n\tif (d.metacopy || (uppermetacopy && !ctr)) {\n\t\tpr_warn_ratelimited(\"metacopy with no lower data found - abort lookup (%pd2)\\n\",\n\t\t\t\t    dentry);\n\t\terr = -EIO;\n\t\tgoto out_put;\n\t} else if (!d.is_dir && upperdentry && !ctr && origin_path) {\n\t\tif (WARN_ON(stack != NULL)) {\n\t\t\terr = -EIO;\n\t\t\tgoto out_put;\n\t\t}\n\t\tstack = origin_path;\n\t\tctr = 1;\n\t\torigin = origin_path->dentry;\n\t\torigin_path = NULL;\n\t}\n\n\t \n\tif (!upperdentry && ctr)\n\t\torigin = stack[0].dentry;\n\n\tif (origin && ovl_indexdir(dentry->d_sb) &&\n\t    (!d.is_dir || ovl_index_all(dentry->d_sb))) {\n\t\tindex = ovl_lookup_index(ofs, upperdentry, origin, true);\n\t\tif (IS_ERR(index)) {\n\t\t\terr = PTR_ERR(index);\n\t\t\tindex = NULL;\n\t\t\tgoto out_put;\n\t\t}\n\t}\n\n\tif (ctr) {\n\t\toe = ovl_alloc_entry(ctr);\n\t\terr = -ENOMEM;\n\t\tif (!oe)\n\t\t\tgoto out_put;\n\n\t\tovl_stack_cpy(ovl_lowerstack(oe), stack, ctr);\n\t}\n\n\tif (upperopaque)\n\t\tovl_dentry_set_opaque(dentry);\n\n\tif (upperdentry)\n\t\tovl_dentry_set_upper_alias(dentry);\n\telse if (index) {\n\t\tstruct path upperpath = {\n\t\t\t.dentry = upperdentry = dget(index),\n\t\t\t.mnt = ovl_upper_mnt(ofs),\n\t\t};\n\n\t\t \n\t\tupperredirect = ovl_get_redirect_xattr(ofs, &upperpath, 0);\n\t\tif (IS_ERR(upperredirect)) {\n\t\t\terr = PTR_ERR(upperredirect);\n\t\t\tupperredirect = NULL;\n\t\t\tgoto out_free_oe;\n\t\t}\n\t\terr = ovl_check_metacopy_xattr(ofs, &upperpath, NULL);\n\t\tif (err < 0)\n\t\t\tgoto out_free_oe;\n\t\tuppermetacopy = err;\n\t\tmetacopy_size = err;\n\t}\n\n\tif (upperdentry || ctr) {\n\t\tstruct ovl_inode_params oip = {\n\t\t\t.upperdentry = upperdentry,\n\t\t\t.oe = oe,\n\t\t\t.index = index,\n\t\t\t.redirect = upperredirect,\n\t\t};\n\n\t\t \n\t\tif (ctr > 1 && !d.is_dir && !stack[ctr - 1].dentry) {\n\t\t\toip.lowerdata_redirect = d.redirect;\n\t\t\td.redirect = NULL;\n\t\t}\n\t\tinode = ovl_get_inode(dentry->d_sb, &oip);\n\t\terr = PTR_ERR(inode);\n\t\tif (IS_ERR(inode))\n\t\t\tgoto out_free_oe;\n\t\tif (upperdentry && !uppermetacopy)\n\t\t\tovl_set_flag(OVL_UPPERDATA, inode);\n\n\t\tif (metacopy_size > OVL_METACOPY_MIN_SIZE)\n\t\t\tovl_set_flag(OVL_HAS_DIGEST, inode);\n\t}\n\n\tovl_dentry_init_reval(dentry, upperdentry, OVL_I_E(inode));\n\n\trevert_creds(old_cred);\n\tif (origin_path) {\n\t\tdput(origin_path->dentry);\n\t\tkfree(origin_path);\n\t}\n\tdput(index);\n\tovl_stack_free(stack, ctr);\n\tkfree(d.redirect);\n\treturn d_splice_alias(inode, dentry);\n\nout_free_oe:\n\tovl_free_entry(oe);\nout_put:\n\tdput(index);\n\tovl_stack_free(stack, ctr);\nout_put_upper:\n\tif (origin_path) {\n\t\tdput(origin_path->dentry);\n\t\tkfree(origin_path);\n\t}\n\tdput(upperdentry);\n\tkfree(upperredirect);\nout:\n\tkfree(d.redirect);\n\trevert_creds(old_cred);\n\treturn ERR_PTR(err);\n}\n\nbool ovl_lower_positive(struct dentry *dentry)\n{\n\tstruct ovl_entry *poe = OVL_E(dentry->d_parent);\n\tconst struct qstr *name = &dentry->d_name;\n\tconst struct cred *old_cred;\n\tunsigned int i;\n\tbool positive = false;\n\tbool done = false;\n\n\t \n\tif (!dentry->d_inode)\n\t\treturn ovl_dentry_is_opaque(dentry);\n\n\t \n\tif (!ovl_dentry_upper(dentry))\n\t\treturn true;\n\n\told_cred = ovl_override_creds(dentry->d_sb);\n\t \n\tfor (i = 0; !done && !positive && i < ovl_numlower(poe); i++) {\n\t\tstruct dentry *this;\n\t\tstruct ovl_path *parentpath = &ovl_lowerstack(poe)[i];\n\n\t\tthis = lookup_one_positive_unlocked(\n\t\t\t\tmnt_idmap(parentpath->layer->mnt),\n\t\t\t\tname->name, parentpath->dentry, name->len);\n\t\tif (IS_ERR(this)) {\n\t\t\tswitch (PTR_ERR(this)) {\n\t\t\tcase -ENOENT:\n\t\t\tcase -ENAMETOOLONG:\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t \n\t\t\t\tpositive = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tpositive = !ovl_is_whiteout(this);\n\t\t\tdone = true;\n\t\t\tdput(this);\n\t\t}\n\t}\n\trevert_creds(old_cred);\n\n\treturn positive;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}