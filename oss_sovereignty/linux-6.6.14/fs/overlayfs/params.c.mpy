{
  "module_name": "params.c",
  "hash_id": "9c5ec62df344253c814635fcd29e670a19c66ab731bc47d0d181fafb0a1e5aaf",
  "original_prompt": "Ingested from linux-6.6.14/fs/overlayfs/params.c",
  "human_readable_source": "\n\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/fs_parser.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/seq_file.h>\n#include <linux/xattr.h>\n#include \"overlayfs.h\"\n#include \"params.h\"\n\nstatic bool ovl_redirect_dir_def = IS_ENABLED(CONFIG_OVERLAY_FS_REDIRECT_DIR);\nmodule_param_named(redirect_dir, ovl_redirect_dir_def, bool, 0644);\nMODULE_PARM_DESC(redirect_dir,\n\t\t \"Default to on or off for the redirect_dir feature\");\n\nstatic bool ovl_redirect_always_follow =\n\tIS_ENABLED(CONFIG_OVERLAY_FS_REDIRECT_ALWAYS_FOLLOW);\nmodule_param_named(redirect_always_follow, ovl_redirect_always_follow,\n\t\t   bool, 0644);\nMODULE_PARM_DESC(redirect_always_follow,\n\t\t \"Follow redirects even if redirect_dir feature is turned off\");\n\nstatic bool ovl_xino_auto_def = IS_ENABLED(CONFIG_OVERLAY_FS_XINO_AUTO);\nmodule_param_named(xino_auto, ovl_xino_auto_def, bool, 0644);\nMODULE_PARM_DESC(xino_auto,\n\t\t \"Auto enable xino feature\");\n\nstatic bool ovl_index_def = IS_ENABLED(CONFIG_OVERLAY_FS_INDEX);\nmodule_param_named(index, ovl_index_def, bool, 0644);\nMODULE_PARM_DESC(index,\n\t\t \"Default to on or off for the inodes index feature\");\n\nstatic bool ovl_nfs_export_def = IS_ENABLED(CONFIG_OVERLAY_FS_NFS_EXPORT);\nmodule_param_named(nfs_export, ovl_nfs_export_def, bool, 0644);\nMODULE_PARM_DESC(nfs_export,\n\t\t \"Default to on or off for the NFS export feature\");\n\nstatic bool ovl_metacopy_def = IS_ENABLED(CONFIG_OVERLAY_FS_METACOPY);\nmodule_param_named(metacopy, ovl_metacopy_def, bool, 0644);\nMODULE_PARM_DESC(metacopy,\n\t\t \"Default to on or off for the metadata only copy up feature\");\n\nenum {\n\tOpt_lowerdir,\n\tOpt_upperdir,\n\tOpt_workdir,\n\tOpt_default_permissions,\n\tOpt_redirect_dir,\n\tOpt_index,\n\tOpt_uuid,\n\tOpt_nfs_export,\n\tOpt_userxattr,\n\tOpt_xino,\n\tOpt_metacopy,\n\tOpt_verity,\n\tOpt_volatile,\n};\n\nstatic const struct constant_table ovl_parameter_bool[] = {\n\t{ \"on\",\t\ttrue  },\n\t{ \"off\",\tfalse },\n\t{}\n};\n\nstatic const struct constant_table ovl_parameter_uuid[] = {\n\t{ \"off\",\tOVL_UUID_OFF  },\n\t{ \"null\",\tOVL_UUID_NULL },\n\t{ \"auto\",\tOVL_UUID_AUTO },\n\t{ \"on\",\t\tOVL_UUID_ON   },\n\t{}\n};\n\nstatic const char *ovl_uuid_mode(struct ovl_config *config)\n{\n\treturn ovl_parameter_uuid[config->uuid].name;\n}\n\nstatic int ovl_uuid_def(void)\n{\n\treturn OVL_UUID_AUTO;\n}\n\nstatic const struct constant_table ovl_parameter_xino[] = {\n\t{ \"off\",\tOVL_XINO_OFF  },\n\t{ \"auto\",\tOVL_XINO_AUTO },\n\t{ \"on\",\t\tOVL_XINO_ON   },\n\t{}\n};\n\nconst char *ovl_xino_mode(struct ovl_config *config)\n{\n\treturn ovl_parameter_xino[config->xino].name;\n}\n\nstatic int ovl_xino_def(void)\n{\n\treturn ovl_xino_auto_def ? OVL_XINO_AUTO : OVL_XINO_OFF;\n}\n\nconst struct constant_table ovl_parameter_redirect_dir[] = {\n\t{ \"off\",\tOVL_REDIRECT_OFF      },\n\t{ \"follow\",\tOVL_REDIRECT_FOLLOW   },\n\t{ \"nofollow\",\tOVL_REDIRECT_NOFOLLOW },\n\t{ \"on\",\t\tOVL_REDIRECT_ON       },\n\t{}\n};\n\nstatic const char *ovl_redirect_mode(struct ovl_config *config)\n{\n\treturn ovl_parameter_redirect_dir[config->redirect_mode].name;\n}\n\nstatic int ovl_redirect_mode_def(void)\n{\n\treturn ovl_redirect_dir_def\t  ? OVL_REDIRECT_ON :\n\t       ovl_redirect_always_follow ? OVL_REDIRECT_FOLLOW :\n\t\t\t\t\t    OVL_REDIRECT_NOFOLLOW;\n}\n\nstatic const struct constant_table ovl_parameter_verity[] = {\n\t{ \"off\",\tOVL_VERITY_OFF     },\n\t{ \"on\",\t\tOVL_VERITY_ON      },\n\t{ \"require\",\tOVL_VERITY_REQUIRE },\n\t{}\n};\n\nstatic const char *ovl_verity_mode(struct ovl_config *config)\n{\n\treturn ovl_parameter_verity[config->verity_mode].name;\n}\n\nstatic int ovl_verity_mode_def(void)\n{\n\treturn OVL_VERITY_OFF;\n}\n\n#define fsparam_string_empty(NAME, OPT) \\\n\t__fsparam(fs_param_is_string, NAME, OPT, fs_param_can_be_empty, NULL)\n\nconst struct fs_parameter_spec ovl_parameter_spec[] = {\n\tfsparam_string_empty(\"lowerdir\",    Opt_lowerdir),\n\tfsparam_string(\"upperdir\",          Opt_upperdir),\n\tfsparam_string(\"workdir\",           Opt_workdir),\n\tfsparam_flag(\"default_permissions\", Opt_default_permissions),\n\tfsparam_enum(\"redirect_dir\",        Opt_redirect_dir, ovl_parameter_redirect_dir),\n\tfsparam_enum(\"index\",               Opt_index, ovl_parameter_bool),\n\tfsparam_enum(\"uuid\",                Opt_uuid, ovl_parameter_uuid),\n\tfsparam_enum(\"nfs_export\",          Opt_nfs_export, ovl_parameter_bool),\n\tfsparam_flag(\"userxattr\",           Opt_userxattr),\n\tfsparam_enum(\"xino\",                Opt_xino, ovl_parameter_xino),\n\tfsparam_enum(\"metacopy\",            Opt_metacopy, ovl_parameter_bool),\n\tfsparam_enum(\"verity\",              Opt_verity, ovl_parameter_verity),\n\tfsparam_flag(\"volatile\",            Opt_volatile),\n\t{}\n};\n\nstatic char *ovl_next_opt(char **s)\n{\n\tchar *sbegin = *s;\n\tchar *p;\n\n\tif (sbegin == NULL)\n\t\treturn NULL;\n\n\tfor (p = sbegin; *p; p++) {\n\t\tif (*p == '\\\\') {\n\t\t\tp++;\n\t\t\tif (!*p)\n\t\t\t\tbreak;\n\t\t} else if (*p == ',') {\n\t\t\t*p = '\\0';\n\t\t\t*s = p + 1;\n\t\t\treturn sbegin;\n\t\t}\n\t}\n\t*s = NULL;\n\treturn sbegin;\n}\n\nstatic int ovl_parse_monolithic(struct fs_context *fc, void *data)\n{\n\treturn vfs_parse_monolithic_sep(fc, data, ovl_next_opt);\n}\n\nstatic ssize_t ovl_parse_param_split_lowerdirs(char *str)\n{\n\tssize_t nr_layers = 1, nr_colons = 0;\n\tchar *s, *d;\n\n\tfor (s = d = str;; s++, d++) {\n\t\tif (*s == '\\\\') {\n\t\t\t \n\t\t\t*d++ = *s++;\n\t\t} else if (*s == ':') {\n\t\t\tbool next_colon = (*(s + 1) == ':');\n\n\t\t\tnr_colons++;\n\t\t\tif (nr_colons == 2 && next_colon) {\n\t\t\t\tpr_err(\"only single ':' or double '::' sequences of unescaped colons in lowerdir mount option allowed.\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t \n\t\t\tif (!next_colon)\n\t\t\t\tnr_layers++;\n\n\t\t\t*d = '\\0';\n\t\t\tcontinue;\n\t\t}\n\n\t\t*d = *s;\n\t\tif (!*s) {\n\t\t\t \n\t\t\tif (nr_colons) {\n\t\t\t\tpr_err(\"unescaped trailing colons in lowerdir mount option.\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tnr_colons = 0;\n\t}\n\n\treturn nr_layers;\n}\n\nstatic int ovl_mount_dir_noesc(const char *name, struct path *path)\n{\n\tint err = -EINVAL;\n\n\tif (!*name) {\n\t\tpr_err(\"empty lowerdir\\n\");\n\t\tgoto out;\n\t}\n\terr = kern_path(name, LOOKUP_FOLLOW, path);\n\tif (err) {\n\t\tpr_err(\"failed to resolve '%s': %i\\n\", name, err);\n\t\tgoto out;\n\t}\n\terr = -EINVAL;\n\tif (ovl_dentry_weird(path->dentry)) {\n\t\tpr_err(\"filesystem on '%s' not supported\\n\", name);\n\t\tgoto out_put;\n\t}\n\tif (!d_is_dir(path->dentry)) {\n\t\tpr_err(\"'%s' not a directory\\n\", name);\n\t\tgoto out_put;\n\t}\n\treturn 0;\n\nout_put:\n\tpath_put_init(path);\nout:\n\treturn err;\n}\n\nstatic void ovl_unescape(char *s)\n{\n\tchar *d = s;\n\n\tfor (;; s++, d++) {\n\t\tif (*s == '\\\\')\n\t\t\ts++;\n\t\t*d = *s;\n\t\tif (!*s)\n\t\t\tbreak;\n\t}\n}\n\nstatic int ovl_mount_dir(const char *name, struct path *path, bool upper)\n{\n\tint err = -ENOMEM;\n\tchar *tmp = kstrdup(name, GFP_KERNEL);\n\n\tif (tmp) {\n\t\tovl_unescape(tmp);\n\t\terr = ovl_mount_dir_noesc(tmp, path);\n\n\t\tif (!err && upper && path->dentry->d_flags & DCACHE_OP_REAL) {\n\t\t\tpr_err(\"filesystem on '%s' not supported as upperdir\\n\",\n\t\t\t       tmp);\n\t\t\tpath_put_init(path);\n\t\t\terr = -EINVAL;\n\t\t}\n\t\tkfree(tmp);\n\t}\n\treturn err;\n}\n\nstatic int ovl_parse_param_upperdir(const char *name, struct fs_context *fc,\n\t\t\t\t    bool workdir)\n{\n\tint err;\n\tstruct ovl_fs *ofs = fc->s_fs_info;\n\tstruct ovl_config *config = &ofs->config;\n\tstruct ovl_fs_context *ctx = fc->fs_private;\n\tstruct path path;\n\tchar *dup;\n\n\terr = ovl_mount_dir(name, &path, true);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (__mnt_is_readonly(path.mnt)) {\n\t\tpath_put(&path);\n\t\treturn -EINVAL;\n\t}\n\n\tdup = kstrdup(name, GFP_KERNEL);\n\tif (!dup) {\n\t\tpath_put(&path);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (workdir) {\n\t\tkfree(config->workdir);\n\t\tconfig->workdir = dup;\n\t\tpath_put(&ctx->work);\n\t\tctx->work = path;\n\t} else {\n\t\tkfree(config->upperdir);\n\t\tconfig->upperdir = dup;\n\t\tpath_put(&ctx->upper);\n\t\tctx->upper = path;\n\t}\n\treturn 0;\n}\n\nstatic void ovl_parse_param_drop_lowerdir(struct ovl_fs_context *ctx)\n{\n\tfor (size_t nr = 0; nr < ctx->nr; nr++) {\n\t\tpath_put(&ctx->lower[nr].path);\n\t\tkfree(ctx->lower[nr].name);\n\t\tctx->lower[nr].name = NULL;\n\t}\n\tctx->nr = 0;\n\tctx->nr_data = 0;\n}\n\n \nstatic int ovl_parse_param_lowerdir(const char *name, struct fs_context *fc)\n{\n\tint err;\n\tstruct ovl_fs_context *ctx = fc->fs_private;\n\tstruct ovl_fs_context_layer *l;\n\tchar *dup = NULL, *dup_iter;\n\tssize_t nr_lower = 0, nr = 0, nr_data = 0;\n\tbool append = false, data_layer = false;\n\n\t \n\n\t \n\tif (!*name) {\n\t\tovl_parse_param_drop_lowerdir(ctx);\n\t\treturn 0;\n\t}\n\n\tif (*name == ':') {\n\t\tpr_err(\"cannot append lower layer\");\n\t\treturn -EINVAL;\n\t}\n\n\tdup = kstrdup(name, GFP_KERNEL);\n\tif (!dup)\n\t\treturn -ENOMEM;\n\n\terr = -EINVAL;\n\tnr_lower = ovl_parse_param_split_lowerdirs(dup);\n\tif (nr_lower < 0)\n\t\tgoto out_err;\n\n\tif ((nr_lower > OVL_MAX_STACK) ||\n\t    (append && (size_add(ctx->nr, nr_lower) > OVL_MAX_STACK))) {\n\t\tpr_err(\"too many lower directories, limit is %d\\n\", OVL_MAX_STACK);\n\t\tgoto out_err;\n\t}\n\n\tif (!append)\n\t\tovl_parse_param_drop_lowerdir(ctx);\n\n\t \n\tnr_lower += ctx->nr;\n\tif (nr_lower > ctx->capacity) {\n\t\terr = -ENOMEM;\n\t\tl = krealloc_array(ctx->lower, nr_lower, sizeof(*ctx->lower),\n\t\t\t\t   GFP_KERNEL_ACCOUNT);\n\t\tif (!l)\n\t\t\tgoto out_err;\n\n\t\tctx->lower = l;\n\t\tctx->capacity = nr_lower;\n\t}\n\n\t \n\tdup_iter = dup;\n\tfor (nr = ctx->nr; nr < nr_lower; nr++) {\n\t\tl = &ctx->lower[nr];\n\t\tmemset(l, 0, sizeof(*l));\n\n\t\terr = ovl_mount_dir(dup_iter, &l->path, false);\n\t\tif (err)\n\t\t\tgoto out_put;\n\n\t\terr = -ENOMEM;\n\t\tl->name = kstrdup(dup_iter, GFP_KERNEL_ACCOUNT);\n\t\tif (!l->name)\n\t\t\tgoto out_put;\n\n\t\tif (data_layer)\n\t\t\tnr_data++;\n\n\t\t \n\t\tif ((nr + 1) == nr_lower)\n\t\t\tbreak;\n\n\t\terr = -EINVAL;\n\t\tdup_iter = strchr(dup_iter, '\\0') + 1;\n\t\tif (*dup_iter) {\n\t\t\t \n\t\t\tif ((ctx->nr_data + nr_data) > 0) {\n\t\t\t\tpr_err(\"regular lower layers cannot follow data lower layers\");\n\t\t\t\tgoto out_put;\n\t\t\t}\n\n\t\t\tdata_layer = false;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tdata_layer = true;\n\t\tdup_iter++;\n\t}\n\tctx->nr = nr_lower;\n\tctx->nr_data += nr_data;\n\tkfree(dup);\n\treturn 0;\n\nout_put:\n\t \n\tfor (; nr >= ctx->nr; nr--) {\n\t\tl = &ctx->lower[nr];\n\t\tkfree(l->name);\n\t\tl->name = NULL;\n\t\tpath_put(&l->path);\n\n\t\t \n\t\tif (nr == 0)\n\t\t\tbreak;\n\t}\n\nout_err:\n\tkfree(dup);\n\n\t \n\treturn err;\n}\n\nstatic int ovl_parse_param(struct fs_context *fc, struct fs_parameter *param)\n{\n\tint err = 0;\n\tstruct fs_parse_result result;\n\tstruct ovl_fs *ofs = fc->s_fs_info;\n\tstruct ovl_config *config = &ofs->config;\n\tstruct ovl_fs_context *ctx = fc->fs_private;\n\tint opt;\n\n\tif (fc->purpose == FS_CONTEXT_FOR_RECONFIGURE) {\n\t\t \n\t\tif (fc->oldapi)\n\t\t\treturn 0;\n\n\t\t \n\t\treturn invalfc(fc, \"No changes allowed in reconfigure\");\n\t}\n\n\topt = fs_parse(fc, ovl_parameter_spec, param, &result);\n\tif (opt < 0)\n\t\treturn opt;\n\n\tswitch (opt) {\n\tcase Opt_lowerdir:\n\t\terr = ovl_parse_param_lowerdir(param->string, fc);\n\t\tbreak;\n\tcase Opt_upperdir:\n\t\tfallthrough;\n\tcase Opt_workdir:\n\t\terr = ovl_parse_param_upperdir(param->string, fc,\n\t\t\t\t\t       (Opt_workdir == opt));\n\t\tbreak;\n\tcase Opt_default_permissions:\n\t\tconfig->default_permissions = true;\n\t\tbreak;\n\tcase Opt_redirect_dir:\n\t\tconfig->redirect_mode = result.uint_32;\n\t\tif (config->redirect_mode == OVL_REDIRECT_OFF) {\n\t\t\tconfig->redirect_mode = ovl_redirect_always_follow ?\n\t\t\t\t\t\tOVL_REDIRECT_FOLLOW :\n\t\t\t\t\t\tOVL_REDIRECT_NOFOLLOW;\n\t\t}\n\t\tctx->set.redirect = true;\n\t\tbreak;\n\tcase Opt_index:\n\t\tconfig->index = result.uint_32;\n\t\tctx->set.index = true;\n\t\tbreak;\n\tcase Opt_uuid:\n\t\tconfig->uuid = result.uint_32;\n\t\tbreak;\n\tcase Opt_nfs_export:\n\t\tconfig->nfs_export = result.uint_32;\n\t\tctx->set.nfs_export = true;\n\t\tbreak;\n\tcase Opt_xino:\n\t\tconfig->xino = result.uint_32;\n\t\tbreak;\n\tcase Opt_metacopy:\n\t\tconfig->metacopy = result.uint_32;\n\t\tctx->set.metacopy = true;\n\t\tbreak;\n\tcase Opt_verity:\n\t\tconfig->verity_mode = result.uint_32;\n\t\tbreak;\n\tcase Opt_volatile:\n\t\tconfig->ovl_volatile = true;\n\t\tbreak;\n\tcase Opt_userxattr:\n\t\tconfig->userxattr = true;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"unrecognized mount option \\\"%s\\\" or missing value\\n\",\n\t\t       param->key);\n\t\treturn -EINVAL;\n\t}\n\n\treturn err;\n}\n\nstatic int ovl_get_tree(struct fs_context *fc)\n{\n\treturn get_tree_nodev(fc, ovl_fill_super);\n}\n\nstatic inline void ovl_fs_context_free(struct ovl_fs_context *ctx)\n{\n\tovl_parse_param_drop_lowerdir(ctx);\n\tpath_put(&ctx->upper);\n\tpath_put(&ctx->work);\n\tkfree(ctx->lower);\n\tkfree(ctx);\n}\n\nstatic void ovl_free(struct fs_context *fc)\n{\n\tstruct ovl_fs *ofs = fc->s_fs_info;\n\tstruct ovl_fs_context *ctx = fc->fs_private;\n\n\t \n\tif (ofs)\n\t\tovl_free_fs(ofs);\n\n\tif (ctx)\n\t\tovl_fs_context_free(ctx);\n}\n\nstatic int ovl_reconfigure(struct fs_context *fc)\n{\n\tstruct super_block *sb = fc->root->d_sb;\n\tstruct ovl_fs *ofs = OVL_FS(sb);\n\tstruct super_block *upper_sb;\n\tint ret = 0;\n\n\tif (!(fc->sb_flags & SB_RDONLY) && ovl_force_readonly(ofs))\n\t\treturn -EROFS;\n\n\tif (fc->sb_flags & SB_RDONLY && !sb_rdonly(sb)) {\n\t\tupper_sb = ovl_upper_mnt(ofs)->mnt_sb;\n\t\tif (ovl_should_sync(ofs)) {\n\t\t\tdown_read(&upper_sb->s_umount);\n\t\t\tret = sync_filesystem(upper_sb);\n\t\t\tup_read(&upper_sb->s_umount);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic const struct fs_context_operations ovl_context_ops = {\n\t.parse_monolithic = ovl_parse_monolithic,\n\t.parse_param = ovl_parse_param,\n\t.get_tree    = ovl_get_tree,\n\t.reconfigure = ovl_reconfigure,\n\t.free        = ovl_free,\n};\n\n \nint ovl_init_fs_context(struct fs_context *fc)\n{\n\tstruct ovl_fs_context *ctx;\n\tstruct ovl_fs *ofs;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL_ACCOUNT);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\t \n\tctx->lower = kmalloc_array(3, sizeof(*ctx->lower), GFP_KERNEL_ACCOUNT);\n\tif (!ctx->lower)\n\t\tgoto out_err;\n\tctx->capacity = 3;\n\n\tofs = kzalloc(sizeof(struct ovl_fs), GFP_KERNEL);\n\tif (!ofs)\n\t\tgoto out_err;\n\n\tofs->config.redirect_mode\t= ovl_redirect_mode_def();\n\tofs->config.index\t\t= ovl_index_def;\n\tofs->config.uuid\t\t= ovl_uuid_def();\n\tofs->config.nfs_export\t\t= ovl_nfs_export_def;\n\tofs->config.xino\t\t= ovl_xino_def();\n\tofs->config.metacopy\t\t= ovl_metacopy_def;\n\n\tfc->s_fs_info\t\t= ofs;\n\tfc->fs_private\t\t= ctx;\n\tfc->ops\t\t\t= &ovl_context_ops;\n\treturn 0;\n\nout_err:\n\tovl_fs_context_free(ctx);\n\treturn -ENOMEM;\n\n}\n\nvoid ovl_free_fs(struct ovl_fs *ofs)\n{\n\tstruct vfsmount **mounts;\n\tunsigned i;\n\n\tiput(ofs->workbasedir_trap);\n\tiput(ofs->indexdir_trap);\n\tiput(ofs->workdir_trap);\n\tdput(ofs->whiteout);\n\tdput(ofs->indexdir);\n\tdput(ofs->workdir);\n\tif (ofs->workdir_locked)\n\t\tovl_inuse_unlock(ofs->workbasedir);\n\tdput(ofs->workbasedir);\n\tif (ofs->upperdir_locked)\n\t\tovl_inuse_unlock(ovl_upper_mnt(ofs)->mnt_root);\n\n\t \n\tmounts = (struct vfsmount **) ofs->config.lowerdirs;\n\tfor (i = 0; i < ofs->numlayer; i++) {\n\t\tiput(ofs->layers[i].trap);\n\t\tkfree(ofs->config.lowerdirs[i]);\n\t\tmounts[i] = ofs->layers[i].mnt;\n\t}\n\tkern_unmount_array(mounts, ofs->numlayer);\n\tkfree(ofs->layers);\n\tfor (i = 0; i < ofs->numfs; i++)\n\t\tfree_anon_bdev(ofs->fs[i].pseudo_dev);\n\tkfree(ofs->fs);\n\n\tkfree(ofs->config.lowerdirs);\n\tkfree(ofs->config.upperdir);\n\tkfree(ofs->config.workdir);\n\tif (ofs->creator_cred)\n\t\tput_cred(ofs->creator_cred);\n\tkfree(ofs);\n}\n\nint ovl_fs_params_verify(const struct ovl_fs_context *ctx,\n\t\t\t struct ovl_config *config)\n{\n\tstruct ovl_opt_set set = ctx->set;\n\n\tif (ctx->nr_data > 0 && !config->metacopy) {\n\t\tpr_err(\"lower data-only dirs require metacopy support.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!config->upperdir) {\n\t\tif (config->workdir) {\n\t\t\tpr_info(\"option \\\"workdir=%s\\\" is useless in a non-upper mount, ignore\\n\",\n\t\t\t\tconfig->workdir);\n\t\t\tkfree(config->workdir);\n\t\t\tconfig->workdir = NULL;\n\t\t}\n\t\tif (config->index && set.index) {\n\t\t\tpr_info(\"option \\\"index=on\\\" is useless in a non-upper mount, ignore\\n\");\n\t\t\tset.index = false;\n\t\t}\n\t\tconfig->index = false;\n\t}\n\n\tif (!config->upperdir && config->ovl_volatile) {\n\t\tpr_info(\"option \\\"volatile\\\" is meaningless in a non-upper mount, ignoring it.\\n\");\n\t\tconfig->ovl_volatile = false;\n\t}\n\n\tif (!config->upperdir && config->uuid == OVL_UUID_ON) {\n\t\tpr_info(\"option \\\"uuid=on\\\" requires an upper fs, falling back to uuid=null.\\n\");\n\t\tconfig->uuid = OVL_UUID_NULL;\n\t}\n\n\t \n\tif (config->verity_mode && !config->metacopy) {\n\t\t \n\t\tif (set.metacopy) {\n\t\t\tpr_err(\"conflicting options: metacopy=off,verity=%s\\n\",\n\t\t\t       ovl_verity_mode(config));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\tconfig->metacopy = true;\n\t}\n\n\t \n\tif (!config->upperdir && config->redirect_mode == OVL_REDIRECT_FOLLOW)\n\t\tconfig->redirect_mode = OVL_REDIRECT_ON;\n\n\t \n\tif (config->metacopy && config->redirect_mode != OVL_REDIRECT_ON) {\n\t\tif (set.metacopy && set.redirect) {\n\t\t\tpr_err(\"conflicting options: metacopy=on,redirect_dir=%s\\n\",\n\t\t\t       ovl_redirect_mode(config));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (config->verity_mode && set.redirect) {\n\t\t\tpr_err(\"conflicting options: verity=%s,redirect_dir=%s\\n\",\n\t\t\t       ovl_verity_mode(config), ovl_redirect_mode(config));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (set.redirect) {\n\t\t\t \n\t\t\tpr_info(\"disabling metacopy due to redirect_dir=%s\\n\",\n\t\t\t\tovl_redirect_mode(config));\n\t\t\tconfig->metacopy = false;\n\t\t} else {\n\t\t\t \n\t\t\tconfig->redirect_mode = OVL_REDIRECT_ON;\n\t\t}\n\t}\n\n\t \n\tif (config->nfs_export && !config->index) {\n\t\tif (!config->upperdir &&\n\t\t    config->redirect_mode != OVL_REDIRECT_NOFOLLOW) {\n\t\t\tpr_info(\"NFS export requires \\\"redirect_dir=nofollow\\\" on non-upper mount, falling back to nfs_export=off.\\n\");\n\t\t\tconfig->nfs_export = false;\n\t\t} else if (set.nfs_export && set.index) {\n\t\t\tpr_err(\"conflicting options: nfs_export=on,index=off\\n\");\n\t\t\treturn -EINVAL;\n\t\t} else if (set.index) {\n\t\t\t \n\t\t\tpr_info(\"disabling nfs_export due to index=off\\n\");\n\t\t\tconfig->nfs_export = false;\n\t\t} else {\n\t\t\t \n\t\t\tconfig->index = true;\n\t\t}\n\t}\n\n\t \n\tif (config->nfs_export && config->metacopy) {\n\t\tif (set.nfs_export && set.metacopy) {\n\t\t\tpr_err(\"conflicting options: nfs_export=on,metacopy=on\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (set.metacopy) {\n\t\t\t \n\t\t\tpr_info(\"disabling nfs_export due to metacopy=on\\n\");\n\t\t\tconfig->nfs_export = false;\n\t\t} else if (config->verity_mode) {\n\t\t\t \n\t\t\tpr_info(\"disabling nfs_export due to verity=%s\\n\",\n\t\t\t\tovl_verity_mode(config));\n\t\t\tconfig->nfs_export = false;\n\t\t} else {\n\t\t\t \n\t\t\tpr_info(\"disabling metacopy due to nfs_export=on\\n\");\n\t\t\tconfig->metacopy = false;\n\t\t}\n\t}\n\n\n\t \n\tif (config->userxattr) {\n\t\tif (set.redirect &&\n\t\t    config->redirect_mode != OVL_REDIRECT_NOFOLLOW) {\n\t\t\tpr_err(\"conflicting options: userxattr,redirect_dir=%s\\n\",\n\t\t\t       ovl_redirect_mode(config));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (config->metacopy && set.metacopy) {\n\t\t\tpr_err(\"conflicting options: userxattr,metacopy=on\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (config->verity_mode) {\n\t\t\tpr_err(\"conflicting options: userxattr,verity=%s\\n\",\n\t\t\t       ovl_verity_mode(config));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\tconfig->redirect_mode = OVL_REDIRECT_NOFOLLOW;\n\t\tconfig->metacopy = false;\n\t}\n\n\treturn 0;\n}\n\n \nint ovl_show_options(struct seq_file *m, struct dentry *dentry)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct ovl_fs *ofs = OVL_FS(sb);\n\tsize_t nr, nr_merged_lower = ofs->numlayer - ofs->numdatalayer;\n\n\t \n\tseq_puts(m, \",lowerdir=\");\n\tfor (nr = 1; nr < ofs->numlayer; nr++) {\n\t\tif (nr > 1)\n\t\t\tseq_putc(m, ':');\n\t\tif (nr >= nr_merged_lower)\n\t\t\tseq_putc(m, ':');\n\t\tseq_escape(m, ofs->config.lowerdirs[nr], \":, \\t\\n\\\\\");\n\t}\n\tif (ofs->config.upperdir) {\n\t\tseq_show_option(m, \"upperdir\", ofs->config.upperdir);\n\t\tseq_show_option(m, \"workdir\", ofs->config.workdir);\n\t}\n\tif (ofs->config.default_permissions)\n\t\tseq_puts(m, \",default_permissions\");\n\tif (ofs->config.redirect_mode != ovl_redirect_mode_def())\n\t\tseq_printf(m, \",redirect_dir=%s\",\n\t\t\t   ovl_redirect_mode(&ofs->config));\n\tif (ofs->config.index != ovl_index_def)\n\t\tseq_printf(m, \",index=%s\", ofs->config.index ? \"on\" : \"off\");\n\tif (ofs->config.uuid != ovl_uuid_def())\n\t\tseq_printf(m, \",uuid=%s\", ovl_uuid_mode(&ofs->config));\n\tif (ofs->config.nfs_export != ovl_nfs_export_def)\n\t\tseq_printf(m, \",nfs_export=%s\", ofs->config.nfs_export ?\n\t\t\t\t\t\t\"on\" : \"off\");\n\tif (ofs->config.xino != ovl_xino_def() && !ovl_same_fs(ofs))\n\t\tseq_printf(m, \",xino=%s\", ovl_xino_mode(&ofs->config));\n\tif (ofs->config.metacopy != ovl_metacopy_def)\n\t\tseq_printf(m, \",metacopy=%s\",\n\t\t\t   ofs->config.metacopy ? \"on\" : \"off\");\n\tif (ofs->config.ovl_volatile)\n\t\tseq_puts(m, \",volatile\");\n\tif (ofs->config.userxattr)\n\t\tseq_puts(m, \",userxattr\");\n\tif (ofs->config.verity_mode != ovl_verity_mode_def())\n\t\tseq_printf(m, \",verity=%s\",\n\t\t\t   ovl_verity_mode(&ofs->config));\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}