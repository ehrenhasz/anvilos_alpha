{
  "module_name": "dir.c",
  "hash_id": "9694465b72c502ed82aea60484b86d89776774489e84cbc3a0657cf34470a4e3",
  "original_prompt": "Ingested from linux-6.6.14/fs/overlayfs/dir.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/cred.h>\n#include <linux/module.h>\n#include <linux/posix_acl.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/atomic.h>\n#include <linux/ratelimit.h>\n#include \"overlayfs.h\"\n\nstatic unsigned short ovl_redirect_max = 256;\nmodule_param_named(redirect_max, ovl_redirect_max, ushort, 0644);\nMODULE_PARM_DESC(redirect_max,\n\t\t \"Maximum length of absolute redirect xattr value\");\n\nstatic int ovl_set_redirect(struct dentry *dentry, bool samedir);\n\nint ovl_cleanup(struct ovl_fs *ofs, struct inode *wdir, struct dentry *wdentry)\n{\n\tint err;\n\n\tdget(wdentry);\n\tif (d_is_dir(wdentry))\n\t\terr = ovl_do_rmdir(ofs, wdir, wdentry);\n\telse\n\t\terr = ovl_do_unlink(ofs, wdir, wdentry);\n\tdput(wdentry);\n\n\tif (err) {\n\t\tpr_err(\"cleanup of '%pd2' failed (%i)\\n\",\n\t\t       wdentry, err);\n\t}\n\n\treturn err;\n}\n\nstruct dentry *ovl_lookup_temp(struct ovl_fs *ofs, struct dentry *workdir)\n{\n\tstruct dentry *temp;\n\tchar name[20];\n\tstatic atomic_t temp_id = ATOMIC_INIT(0);\n\n\t \n\tsnprintf(name, sizeof(name), \"#%x\", atomic_inc_return(&temp_id));\n\n\ttemp = ovl_lookup_upper(ofs, name, workdir, strlen(name));\n\tif (!IS_ERR(temp) && temp->d_inode) {\n\t\tpr_err(\"workdir/%s already exists\\n\", name);\n\t\tdput(temp);\n\t\ttemp = ERR_PTR(-EIO);\n\t}\n\n\treturn temp;\n}\n\n \nstatic struct dentry *ovl_whiteout(struct ovl_fs *ofs)\n{\n\tint err;\n\tstruct dentry *whiteout;\n\tstruct dentry *workdir = ofs->workdir;\n\tstruct inode *wdir = workdir->d_inode;\n\n\tif (!ofs->whiteout) {\n\t\twhiteout = ovl_lookup_temp(ofs, workdir);\n\t\tif (IS_ERR(whiteout))\n\t\t\tgoto out;\n\n\t\terr = ovl_do_whiteout(ofs, wdir, whiteout);\n\t\tif (err) {\n\t\t\tdput(whiteout);\n\t\t\twhiteout = ERR_PTR(err);\n\t\t\tgoto out;\n\t\t}\n\t\tofs->whiteout = whiteout;\n\t}\n\n\tif (!ofs->no_shared_whiteout) {\n\t\twhiteout = ovl_lookup_temp(ofs, workdir);\n\t\tif (IS_ERR(whiteout))\n\t\t\tgoto out;\n\n\t\terr = ovl_do_link(ofs, ofs->whiteout, wdir, whiteout);\n\t\tif (!err)\n\t\t\tgoto out;\n\n\t\tif (err != -EMLINK) {\n\t\t\tpr_warn(\"Failed to link whiteout - disabling whiteout inode sharing(nlink=%u, err=%i)\\n\",\n\t\t\t\tofs->whiteout->d_inode->i_nlink, err);\n\t\t\tofs->no_shared_whiteout = true;\n\t\t}\n\t\tdput(whiteout);\n\t}\n\twhiteout = ofs->whiteout;\n\tofs->whiteout = NULL;\nout:\n\treturn whiteout;\n}\n\n \nint ovl_cleanup_and_whiteout(struct ovl_fs *ofs, struct inode *dir,\n\t\t\t     struct dentry *dentry)\n{\n\tstruct inode *wdir = ofs->workdir->d_inode;\n\tstruct dentry *whiteout;\n\tint err;\n\tint flags = 0;\n\n\twhiteout = ovl_whiteout(ofs);\n\terr = PTR_ERR(whiteout);\n\tif (IS_ERR(whiteout))\n\t\treturn err;\n\n\tif (d_is_dir(dentry))\n\t\tflags = RENAME_EXCHANGE;\n\n\terr = ovl_do_rename(ofs, wdir, whiteout, dir, dentry, flags);\n\tif (err)\n\t\tgoto kill_whiteout;\n\tif (flags)\n\t\tovl_cleanup(ofs, wdir, dentry);\n\nout:\n\tdput(whiteout);\n\treturn err;\n\nkill_whiteout:\n\tovl_cleanup(ofs, wdir, whiteout);\n\tgoto out;\n}\n\nint ovl_mkdir_real(struct ovl_fs *ofs, struct inode *dir,\n\t\t   struct dentry **newdentry, umode_t mode)\n{\n\tint err;\n\tstruct dentry *d, *dentry = *newdentry;\n\n\terr = ovl_do_mkdir(ofs, dir, dentry, mode);\n\tif (err)\n\t\treturn err;\n\n\tif (likely(!d_unhashed(dentry)))\n\t\treturn 0;\n\n\t \n\td = ovl_lookup_upper(ofs, dentry->d_name.name, dentry->d_parent,\n\t\t\t     dentry->d_name.len);\n\tif (IS_ERR(d)) {\n\t\tpr_warn(\"failed lookup after mkdir (%pd2, err=%i).\\n\",\n\t\t\tdentry, err);\n\t\treturn PTR_ERR(d);\n\t}\n\tdput(dentry);\n\t*newdentry = d;\n\n\treturn 0;\n}\n\nstruct dentry *ovl_create_real(struct ovl_fs *ofs, struct inode *dir,\n\t\t\t       struct dentry *newdentry, struct ovl_cattr *attr)\n{\n\tint err;\n\n\tif (IS_ERR(newdentry))\n\t\treturn newdentry;\n\n\terr = -ESTALE;\n\tif (newdentry->d_inode)\n\t\tgoto out;\n\n\tif (attr->hardlink) {\n\t\terr = ovl_do_link(ofs, attr->hardlink, dir, newdentry);\n\t} else {\n\t\tswitch (attr->mode & S_IFMT) {\n\t\tcase S_IFREG:\n\t\t\terr = ovl_do_create(ofs, dir, newdentry, attr->mode);\n\t\t\tbreak;\n\n\t\tcase S_IFDIR:\n\t\t\t \n\t\t\terr =  ovl_mkdir_real(ofs, dir, &newdentry, attr->mode);\n\t\t\tbreak;\n\n\t\tcase S_IFCHR:\n\t\tcase S_IFBLK:\n\t\tcase S_IFIFO:\n\t\tcase S_IFSOCK:\n\t\t\terr = ovl_do_mknod(ofs, dir, newdentry, attr->mode,\n\t\t\t\t\t   attr->rdev);\n\t\t\tbreak;\n\n\t\tcase S_IFLNK:\n\t\t\terr = ovl_do_symlink(ofs, dir, newdentry, attr->link);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\terr = -EPERM;\n\t\t}\n\t}\n\tif (!err && WARN_ON(!newdentry->d_inode)) {\n\t\t \n\t\terr = -EIO;\n\t}\nout:\n\tif (err) {\n\t\tdput(newdentry);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn newdentry;\n}\n\nstruct dentry *ovl_create_temp(struct ovl_fs *ofs, struct dentry *workdir,\n\t\t\t       struct ovl_cattr *attr)\n{\n\treturn ovl_create_real(ofs, d_inode(workdir),\n\t\t\t       ovl_lookup_temp(ofs, workdir), attr);\n}\n\nstatic int ovl_set_opaque_xerr(struct dentry *dentry, struct dentry *upper,\n\t\t\t       int xerr)\n{\n\tstruct ovl_fs *ofs = OVL_FS(dentry->d_sb);\n\tint err;\n\n\terr = ovl_check_setxattr(ofs, upper, OVL_XATTR_OPAQUE, \"y\", 1, xerr);\n\tif (!err)\n\t\tovl_dentry_set_opaque(dentry);\n\n\treturn err;\n}\n\nstatic int ovl_set_opaque(struct dentry *dentry, struct dentry *upperdentry)\n{\n\t \n\treturn ovl_set_opaque_xerr(dentry, upperdentry, -EIO);\n}\n\n \nstatic int ovl_instantiate(struct dentry *dentry, struct inode *inode,\n\t\t\t   struct dentry *newdentry, bool hardlink)\n{\n\tstruct ovl_inode_params oip = {\n\t\t.upperdentry = newdentry,\n\t\t.newinode = inode,\n\t};\n\n\tovl_dir_modified(dentry->d_parent, false);\n\tovl_dentry_set_upper_alias(dentry);\n\tovl_dentry_init_reval(dentry, newdentry, NULL);\n\n\tif (!hardlink) {\n\t\t \n\t\tinode = ovl_get_inode(dentry->d_sb, &oip);\n\t\tif (IS_ERR(inode))\n\t\t\treturn PTR_ERR(inode);\n\t\tif (inode == oip.newinode)\n\t\t\tovl_set_flag(OVL_UPPERDATA, inode);\n\t} else {\n\t\tWARN_ON(ovl_inode_real(inode) != d_inode(newdentry));\n\t\tdput(newdentry);\n\t\tinc_nlink(inode);\n\t}\n\n\td_instantiate(dentry, inode);\n\tif (inode != oip.newinode) {\n\t\tpr_warn_ratelimited(\"newly created inode found in cache (%pd2)\\n\",\n\t\t\t\t    dentry);\n\t}\n\n\t \n\tif (hardlink)\n\t\td_drop(dentry);\n\n\treturn 0;\n}\n\nstatic bool ovl_type_merge(struct dentry *dentry)\n{\n\treturn OVL_TYPE_MERGE(ovl_path_type(dentry));\n}\n\nstatic bool ovl_type_origin(struct dentry *dentry)\n{\n\treturn OVL_TYPE_ORIGIN(ovl_path_type(dentry));\n}\n\nstatic int ovl_create_upper(struct dentry *dentry, struct inode *inode,\n\t\t\t    struct ovl_cattr *attr)\n{\n\tstruct ovl_fs *ofs = OVL_FS(dentry->d_sb);\n\tstruct dentry *upperdir = ovl_dentry_upper(dentry->d_parent);\n\tstruct inode *udir = upperdir->d_inode;\n\tstruct dentry *newdentry;\n\tint err;\n\n\tif (!attr->hardlink && !IS_POSIXACL(udir))\n\t\tattr->mode &= ~current_umask();\n\n\tinode_lock_nested(udir, I_MUTEX_PARENT);\n\tnewdentry = ovl_create_real(ofs, udir,\n\t\t\t\t    ovl_lookup_upper(ofs, dentry->d_name.name,\n\t\t\t\t\t\t     upperdir, dentry->d_name.len),\n\t\t\t\t    attr);\n\terr = PTR_ERR(newdentry);\n\tif (IS_ERR(newdentry))\n\t\tgoto out_unlock;\n\n\tif (ovl_type_merge(dentry->d_parent) && d_is_dir(newdentry) &&\n\t    !ovl_allow_offline_changes(ofs)) {\n\t\t \n\t\tovl_set_opaque(dentry, newdentry);\n\t}\n\n\terr = ovl_instantiate(dentry, inode, newdentry, !!attr->hardlink);\n\tif (err)\n\t\tgoto out_cleanup;\nout_unlock:\n\tinode_unlock(udir);\n\treturn err;\n\nout_cleanup:\n\tovl_cleanup(ofs, udir, newdentry);\n\tdput(newdentry);\n\tgoto out_unlock;\n}\n\nstatic struct dentry *ovl_clear_empty(struct dentry *dentry,\n\t\t\t\t      struct list_head *list)\n{\n\tstruct ovl_fs *ofs = OVL_FS(dentry->d_sb);\n\tstruct dentry *workdir = ovl_workdir(dentry);\n\tstruct inode *wdir = workdir->d_inode;\n\tstruct dentry *upperdir = ovl_dentry_upper(dentry->d_parent);\n\tstruct inode *udir = upperdir->d_inode;\n\tstruct path upperpath;\n\tstruct dentry *upper;\n\tstruct dentry *opaquedir;\n\tstruct kstat stat;\n\tint err;\n\n\tif (WARN_ON(!workdir))\n\t\treturn ERR_PTR(-EROFS);\n\n\terr = ovl_lock_rename_workdir(workdir, upperdir);\n\tif (err)\n\t\tgoto out;\n\n\tovl_path_upper(dentry, &upperpath);\n\terr = vfs_getattr(&upperpath, &stat,\n\t\t\t  STATX_BASIC_STATS, AT_STATX_SYNC_AS_STAT);\n\tif (err)\n\t\tgoto out_unlock;\n\n\terr = -ESTALE;\n\tif (!S_ISDIR(stat.mode))\n\t\tgoto out_unlock;\n\tupper = upperpath.dentry;\n\tif (upper->d_parent->d_inode != udir)\n\t\tgoto out_unlock;\n\n\topaquedir = ovl_create_temp(ofs, workdir, OVL_CATTR(stat.mode));\n\terr = PTR_ERR(opaquedir);\n\tif (IS_ERR(opaquedir))\n\t\tgoto out_unlock;\n\n\terr = ovl_copy_xattr(dentry->d_sb, &upperpath, opaquedir);\n\tif (err)\n\t\tgoto out_cleanup;\n\n\terr = ovl_set_opaque(dentry, opaquedir);\n\tif (err)\n\t\tgoto out_cleanup;\n\n\tinode_lock(opaquedir->d_inode);\n\terr = ovl_set_attr(ofs, opaquedir, &stat);\n\tinode_unlock(opaquedir->d_inode);\n\tif (err)\n\t\tgoto out_cleanup;\n\n\terr = ovl_do_rename(ofs, wdir, opaquedir, udir, upper, RENAME_EXCHANGE);\n\tif (err)\n\t\tgoto out_cleanup;\n\n\tovl_cleanup_whiteouts(ofs, upper, list);\n\tovl_cleanup(ofs, wdir, upper);\n\tunlock_rename(workdir, upperdir);\n\n\t \n\td_drop(dentry);\n\n\treturn opaquedir;\n\nout_cleanup:\n\tovl_cleanup(ofs, wdir, opaquedir);\n\tdput(opaquedir);\nout_unlock:\n\tunlock_rename(workdir, upperdir);\nout:\n\treturn ERR_PTR(err);\n}\n\nstatic int ovl_set_upper_acl(struct ovl_fs *ofs, struct dentry *upperdentry,\n\t\t\t     const char *acl_name, struct posix_acl *acl)\n{\n\tif (!IS_ENABLED(CONFIG_FS_POSIX_ACL) || !acl)\n\t\treturn 0;\n\n\treturn ovl_do_set_acl(ofs, upperdentry, acl_name, acl);\n}\n\nstatic int ovl_create_over_whiteout(struct dentry *dentry, struct inode *inode,\n\t\t\t\t    struct ovl_cattr *cattr)\n{\n\tstruct ovl_fs *ofs = OVL_FS(dentry->d_sb);\n\tstruct dentry *workdir = ovl_workdir(dentry);\n\tstruct inode *wdir = workdir->d_inode;\n\tstruct dentry *upperdir = ovl_dentry_upper(dentry->d_parent);\n\tstruct inode *udir = upperdir->d_inode;\n\tstruct dentry *upper;\n\tstruct dentry *newdentry;\n\tint err;\n\tstruct posix_acl *acl, *default_acl;\n\tbool hardlink = !!cattr->hardlink;\n\n\tif (WARN_ON(!workdir))\n\t\treturn -EROFS;\n\n\tif (!hardlink) {\n\t\terr = posix_acl_create(dentry->d_parent->d_inode,\n\t\t\t\t       &cattr->mode, &default_acl, &acl);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = ovl_lock_rename_workdir(workdir, upperdir);\n\tif (err)\n\t\tgoto out;\n\n\tupper = ovl_lookup_upper(ofs, dentry->d_name.name, upperdir,\n\t\t\t\t dentry->d_name.len);\n\terr = PTR_ERR(upper);\n\tif (IS_ERR(upper))\n\t\tgoto out_unlock;\n\n\terr = -ESTALE;\n\tif (d_is_negative(upper) || !IS_WHITEOUT(d_inode(upper)))\n\t\tgoto out_dput;\n\n\tnewdentry = ovl_create_temp(ofs, workdir, cattr);\n\terr = PTR_ERR(newdentry);\n\tif (IS_ERR(newdentry))\n\t\tgoto out_dput;\n\n\t \n\tif (!hardlink &&\n\t    !S_ISLNK(cattr->mode) &&\n\t    newdentry->d_inode->i_mode != cattr->mode) {\n\t\tstruct iattr attr = {\n\t\t\t.ia_valid = ATTR_MODE,\n\t\t\t.ia_mode = cattr->mode,\n\t\t};\n\t\tinode_lock(newdentry->d_inode);\n\t\terr = ovl_do_notify_change(ofs, newdentry, &attr);\n\t\tinode_unlock(newdentry->d_inode);\n\t\tif (err)\n\t\t\tgoto out_cleanup;\n\t}\n\tif (!hardlink) {\n\t\terr = ovl_set_upper_acl(ofs, newdentry,\n\t\t\t\t\tXATTR_NAME_POSIX_ACL_ACCESS, acl);\n\t\tif (err)\n\t\t\tgoto out_cleanup;\n\n\t\terr = ovl_set_upper_acl(ofs, newdentry,\n\t\t\t\t\tXATTR_NAME_POSIX_ACL_DEFAULT, default_acl);\n\t\tif (err)\n\t\t\tgoto out_cleanup;\n\t}\n\n\tif (!hardlink && S_ISDIR(cattr->mode)) {\n\t\terr = ovl_set_opaque(dentry, newdentry);\n\t\tif (err)\n\t\t\tgoto out_cleanup;\n\n\t\terr = ovl_do_rename(ofs, wdir, newdentry, udir, upper,\n\t\t\t\t    RENAME_EXCHANGE);\n\t\tif (err)\n\t\t\tgoto out_cleanup;\n\n\t\tovl_cleanup(ofs, wdir, upper);\n\t} else {\n\t\terr = ovl_do_rename(ofs, wdir, newdentry, udir, upper, 0);\n\t\tif (err)\n\t\t\tgoto out_cleanup;\n\t}\n\terr = ovl_instantiate(dentry, inode, newdentry, hardlink);\n\tif (err) {\n\t\tovl_cleanup(ofs, udir, newdentry);\n\t\tdput(newdentry);\n\t}\nout_dput:\n\tdput(upper);\nout_unlock:\n\tunlock_rename(workdir, upperdir);\nout:\n\tif (!hardlink) {\n\t\tposix_acl_release(acl);\n\t\tposix_acl_release(default_acl);\n\t}\n\treturn err;\n\nout_cleanup:\n\tovl_cleanup(ofs, wdir, newdentry);\n\tdput(newdentry);\n\tgoto out_dput;\n}\n\nstatic int ovl_create_or_link(struct dentry *dentry, struct inode *inode,\n\t\t\t      struct ovl_cattr *attr, bool origin)\n{\n\tint err;\n\tconst struct cred *old_cred;\n\tstruct cred *override_cred;\n\tstruct dentry *parent = dentry->d_parent;\n\n\terr = ovl_copy_up(parent);\n\tif (err)\n\t\treturn err;\n\n\told_cred = ovl_override_creds(dentry->d_sb);\n\n\t \n\tif (origin) {\n\t\terr = ovl_set_impure(parent, ovl_dentry_upper(parent));\n\t\tif (err)\n\t\t\tgoto out_revert_creds;\n\t}\n\n\tif (!attr->hardlink) {\n\t\terr = -ENOMEM;\n\t\toverride_cred = prepare_creds();\n\t\tif (!override_cred)\n\t\t\tgoto out_revert_creds;\n\t\t \n\t\toverride_cred->fsuid = inode->i_uid;\n\t\toverride_cred->fsgid = inode->i_gid;\n\t\terr = security_dentry_create_files_as(dentry,\n\t\t\t\tattr->mode, &dentry->d_name, old_cred,\n\t\t\t\toverride_cred);\n\t\tif (err) {\n\t\t\tput_cred(override_cred);\n\t\t\tgoto out_revert_creds;\n\t\t}\n\t\tput_cred(override_creds(override_cred));\n\t\tput_cred(override_cred);\n\t}\n\n\tif (!ovl_dentry_is_whiteout(dentry))\n\t\terr = ovl_create_upper(dentry, inode, attr);\n\telse\n\t\terr = ovl_create_over_whiteout(dentry, inode, attr);\n\nout_revert_creds:\n\trevert_creds(old_cred);\n\treturn err;\n}\n\nstatic int ovl_create_object(struct dentry *dentry, int mode, dev_t rdev,\n\t\t\t     const char *link)\n{\n\tint err;\n\tstruct inode *inode;\n\tstruct ovl_cattr attr = {\n\t\t.rdev = rdev,\n\t\t.link = link,\n\t};\n\n\terr = ovl_want_write(dentry);\n\tif (err)\n\t\tgoto out;\n\n\t \n\terr = -ENOMEM;\n\tinode = ovl_new_inode(dentry->d_sb, mode, rdev);\n\tif (!inode)\n\t\tgoto out_drop_write;\n\n\tspin_lock(&inode->i_lock);\n\tinode->i_state |= I_CREATING;\n\tspin_unlock(&inode->i_lock);\n\n\tinode_init_owner(&nop_mnt_idmap, inode, dentry->d_parent->d_inode, mode);\n\tattr.mode = inode->i_mode;\n\n\terr = ovl_create_or_link(dentry, inode, &attr, false);\n\t \n\tif (inode != d_inode(dentry))\n\t\tiput(inode);\n\nout_drop_write:\n\tovl_drop_write(dentry);\nout:\n\treturn err;\n}\n\nstatic int ovl_create(struct mnt_idmap *idmap, struct inode *dir,\n\t\t      struct dentry *dentry, umode_t mode, bool excl)\n{\n\treturn ovl_create_object(dentry, (mode & 07777) | S_IFREG, 0, NULL);\n}\n\nstatic int ovl_mkdir(struct mnt_idmap *idmap, struct inode *dir,\n\t\t     struct dentry *dentry, umode_t mode)\n{\n\treturn ovl_create_object(dentry, (mode & 07777) | S_IFDIR, 0, NULL);\n}\n\nstatic int ovl_mknod(struct mnt_idmap *idmap, struct inode *dir,\n\t\t     struct dentry *dentry, umode_t mode, dev_t rdev)\n{\n\t \n\tif (S_ISCHR(mode) && rdev == WHITEOUT_DEV)\n\t\treturn -EPERM;\n\n\treturn ovl_create_object(dentry, mode, rdev, NULL);\n}\n\nstatic int ovl_symlink(struct mnt_idmap *idmap, struct inode *dir,\n\t\t       struct dentry *dentry, const char *link)\n{\n\treturn ovl_create_object(dentry, S_IFLNK, 0, link);\n}\n\nstatic int ovl_set_link_redirect(struct dentry *dentry)\n{\n\tconst struct cred *old_cred;\n\tint err;\n\n\told_cred = ovl_override_creds(dentry->d_sb);\n\terr = ovl_set_redirect(dentry, false);\n\trevert_creds(old_cred);\n\n\treturn err;\n}\n\nstatic int ovl_link(struct dentry *old, struct inode *newdir,\n\t\t    struct dentry *new)\n{\n\tint err;\n\tstruct inode *inode;\n\n\terr = ovl_want_write(old);\n\tif (err)\n\t\tgoto out;\n\n\terr = ovl_copy_up(old);\n\tif (err)\n\t\tgoto out_drop_write;\n\n\terr = ovl_copy_up(new->d_parent);\n\tif (err)\n\t\tgoto out_drop_write;\n\n\tif (ovl_is_metacopy_dentry(old)) {\n\t\terr = ovl_set_link_redirect(old);\n\t\tif (err)\n\t\t\tgoto out_drop_write;\n\t}\n\n\terr = ovl_nlink_start(old);\n\tif (err)\n\t\tgoto out_drop_write;\n\n\tinode = d_inode(old);\n\tihold(inode);\n\n\terr = ovl_create_or_link(new, inode,\n\t\t\t&(struct ovl_cattr) {.hardlink = ovl_dentry_upper(old)},\n\t\t\tovl_type_origin(old));\n\tif (err)\n\t\tiput(inode);\n\n\tovl_nlink_end(old);\nout_drop_write:\n\tovl_drop_write(old);\nout:\n\treturn err;\n}\n\nstatic bool ovl_matches_upper(struct dentry *dentry, struct dentry *upper)\n{\n\treturn d_inode(ovl_dentry_upper(dentry)) == d_inode(upper);\n}\n\nstatic int ovl_remove_and_whiteout(struct dentry *dentry,\n\t\t\t\t   struct list_head *list)\n{\n\tstruct ovl_fs *ofs = OVL_FS(dentry->d_sb);\n\tstruct dentry *workdir = ovl_workdir(dentry);\n\tstruct dentry *upperdir = ovl_dentry_upper(dentry->d_parent);\n\tstruct dentry *upper;\n\tstruct dentry *opaquedir = NULL;\n\tint err;\n\n\tif (WARN_ON(!workdir))\n\t\treturn -EROFS;\n\n\tif (!list_empty(list)) {\n\t\topaquedir = ovl_clear_empty(dentry, list);\n\t\terr = PTR_ERR(opaquedir);\n\t\tif (IS_ERR(opaquedir))\n\t\t\tgoto out;\n\t}\n\n\terr = ovl_lock_rename_workdir(workdir, upperdir);\n\tif (err)\n\t\tgoto out_dput;\n\n\tupper = ovl_lookup_upper(ofs, dentry->d_name.name, upperdir,\n\t\t\t\t dentry->d_name.len);\n\terr = PTR_ERR(upper);\n\tif (IS_ERR(upper))\n\t\tgoto out_unlock;\n\n\terr = -ESTALE;\n\tif ((opaquedir && upper != opaquedir) ||\n\t    (!opaquedir && ovl_dentry_upper(dentry) &&\n\t     !ovl_matches_upper(dentry, upper))) {\n\t\tgoto out_dput_upper;\n\t}\n\n\terr = ovl_cleanup_and_whiteout(ofs, d_inode(upperdir), upper);\n\tif (err)\n\t\tgoto out_d_drop;\n\n\tovl_dir_modified(dentry->d_parent, true);\nout_d_drop:\n\td_drop(dentry);\nout_dput_upper:\n\tdput(upper);\nout_unlock:\n\tunlock_rename(workdir, upperdir);\nout_dput:\n\tdput(opaquedir);\nout:\n\treturn err;\n}\n\nstatic int ovl_remove_upper(struct dentry *dentry, bool is_dir,\n\t\t\t    struct list_head *list)\n{\n\tstruct ovl_fs *ofs = OVL_FS(dentry->d_sb);\n\tstruct dentry *upperdir = ovl_dentry_upper(dentry->d_parent);\n\tstruct inode *dir = upperdir->d_inode;\n\tstruct dentry *upper;\n\tstruct dentry *opaquedir = NULL;\n\tint err;\n\n\tif (!list_empty(list)) {\n\t\topaquedir = ovl_clear_empty(dentry, list);\n\t\terr = PTR_ERR(opaquedir);\n\t\tif (IS_ERR(opaquedir))\n\t\t\tgoto out;\n\t}\n\n\tinode_lock_nested(dir, I_MUTEX_PARENT);\n\tupper = ovl_lookup_upper(ofs, dentry->d_name.name, upperdir,\n\t\t\t\t dentry->d_name.len);\n\terr = PTR_ERR(upper);\n\tif (IS_ERR(upper))\n\t\tgoto out_unlock;\n\n\terr = -ESTALE;\n\tif ((opaquedir && upper != opaquedir) ||\n\t    (!opaquedir && !ovl_matches_upper(dentry, upper)))\n\t\tgoto out_dput_upper;\n\n\tif (is_dir)\n\t\terr = ovl_do_rmdir(ofs, dir, upper);\n\telse\n\t\terr = ovl_do_unlink(ofs, dir, upper);\n\tovl_dir_modified(dentry->d_parent, ovl_type_origin(dentry));\n\n\t \n\tif (!err)\n\t\td_drop(dentry);\nout_dput_upper:\n\tdput(upper);\nout_unlock:\n\tinode_unlock(dir);\n\tdput(opaquedir);\nout:\n\treturn err;\n}\n\nstatic bool ovl_pure_upper(struct dentry *dentry)\n{\n\treturn !ovl_dentry_lower(dentry) &&\n\t       !ovl_test_flag(OVL_WHITEOUTS, d_inode(dentry));\n}\n\nstatic void ovl_drop_nlink(struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct dentry *alias;\n\n\t \n\tspin_lock(&inode->i_lock);\n\thlist_for_each_entry(alias, &inode->i_dentry, d_u.d_alias) {\n\t\tif (alias != dentry && !d_unhashed(alias))\n\t\t\tbreak;\n\t}\n\tspin_unlock(&inode->i_lock);\n\n\t \n\tif (inode->i_nlink > !!alias)\n\t\tdrop_nlink(inode);\n}\n\nstatic int ovl_do_remove(struct dentry *dentry, bool is_dir)\n{\n\tint err;\n\tconst struct cred *old_cred;\n\tbool lower_positive = ovl_lower_positive(dentry);\n\tLIST_HEAD(list);\n\n\t \n\tif (is_dir && (lower_positive || !ovl_pure_upper(dentry))) {\n\t\terr = ovl_check_empty_dir(dentry, &list);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\terr = ovl_want_write(dentry);\n\tif (err)\n\t\tgoto out;\n\n\terr = ovl_copy_up(dentry->d_parent);\n\tif (err)\n\t\tgoto out_drop_write;\n\n\terr = ovl_nlink_start(dentry);\n\tif (err)\n\t\tgoto out_drop_write;\n\n\told_cred = ovl_override_creds(dentry->d_sb);\n\tif (!lower_positive)\n\t\terr = ovl_remove_upper(dentry, is_dir, &list);\n\telse\n\t\terr = ovl_remove_and_whiteout(dentry, &list);\n\trevert_creds(old_cred);\n\tif (!err) {\n\t\tif (is_dir)\n\t\t\tclear_nlink(dentry->d_inode);\n\t\telse\n\t\t\tovl_drop_nlink(dentry);\n\t}\n\tovl_nlink_end(dentry);\n\n\t \n\tif (ovl_dentry_upper(dentry))\n\t\tovl_copyattr(d_inode(dentry));\n\nout_drop_write:\n\tovl_drop_write(dentry);\nout:\n\tovl_cache_free(&list);\n\treturn err;\n}\n\nstatic int ovl_unlink(struct inode *dir, struct dentry *dentry)\n{\n\treturn ovl_do_remove(dentry, false);\n}\n\nstatic int ovl_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\treturn ovl_do_remove(dentry, true);\n}\n\nstatic bool ovl_type_merge_or_lower(struct dentry *dentry)\n{\n\tenum ovl_path_type type = ovl_path_type(dentry);\n\n\treturn OVL_TYPE_MERGE(type) || !OVL_TYPE_UPPER(type);\n}\n\nstatic bool ovl_can_move(struct dentry *dentry)\n{\n\treturn ovl_redirect_dir(OVL_FS(dentry->d_sb)) ||\n\t\t!d_is_dir(dentry) || !ovl_type_merge_or_lower(dentry);\n}\n\nstatic char *ovl_get_redirect(struct dentry *dentry, bool abs_redirect)\n{\n\tchar *buf, *ret;\n\tstruct dentry *d, *tmp;\n\tint buflen = ovl_redirect_max + 1;\n\n\tif (!abs_redirect) {\n\t\tret = kstrndup(dentry->d_name.name, dentry->d_name.len,\n\t\t\t       GFP_KERNEL);\n\t\tgoto out;\n\t}\n\n\tbuf = ret = kmalloc(buflen, GFP_KERNEL);\n\tif (!buf)\n\t\tgoto out;\n\n\tbuflen--;\n\tbuf[buflen] = '\\0';\n\tfor (d = dget(dentry); !IS_ROOT(d);) {\n\t\tconst char *name;\n\t\tint thislen;\n\n\t\tspin_lock(&d->d_lock);\n\t\tname = ovl_dentry_get_redirect(d);\n\t\tif (name) {\n\t\t\tthislen = strlen(name);\n\t\t} else {\n\t\t\tname = d->d_name.name;\n\t\t\tthislen = d->d_name.len;\n\t\t}\n\n\t\t \n\t\tif (thislen + (name[0] != '/') > buflen) {\n\t\t\tret = ERR_PTR(-EXDEV);\n\t\t\tspin_unlock(&d->d_lock);\n\t\t\tgoto out_put;\n\t\t}\n\n\t\tbuflen -= thislen;\n\t\tmemcpy(&buf[buflen], name, thislen);\n\t\tspin_unlock(&d->d_lock);\n\t\ttmp = dget_parent(d);\n\n\t\tdput(d);\n\t\td = tmp;\n\n\t\t \n\t\tif (buf[buflen] == '/')\n\t\t\tbreak;\n\t\tbuflen--;\n\t\tbuf[buflen] = '/';\n\t}\n\tret = kstrdup(&buf[buflen], GFP_KERNEL);\nout_put:\n\tdput(d);\n\tkfree(buf);\nout:\n\treturn ret ? ret : ERR_PTR(-ENOMEM);\n}\n\nstatic bool ovl_need_absolute_redirect(struct dentry *dentry, bool samedir)\n{\n\tstruct dentry *lowerdentry;\n\n\tif (!samedir)\n\t\treturn true;\n\n\tif (d_is_dir(dentry))\n\t\treturn false;\n\n\t \n\tlowerdentry = ovl_dentry_lower(dentry);\n\treturn (d_inode(lowerdentry)->i_nlink > 1);\n}\n\nstatic int ovl_set_redirect(struct dentry *dentry, bool samedir)\n{\n\tint err;\n\tstruct ovl_fs *ofs = OVL_FS(dentry->d_sb);\n\tconst char *redirect = ovl_dentry_get_redirect(dentry);\n\tbool absolute_redirect = ovl_need_absolute_redirect(dentry, samedir);\n\n\tif (redirect && (!absolute_redirect || redirect[0] == '/'))\n\t\treturn 0;\n\n\tredirect = ovl_get_redirect(dentry, absolute_redirect);\n\tif (IS_ERR(redirect))\n\t\treturn PTR_ERR(redirect);\n\n\terr = ovl_check_setxattr(ofs, ovl_dentry_upper(dentry),\n\t\t\t\t OVL_XATTR_REDIRECT,\n\t\t\t\t redirect, strlen(redirect), -EXDEV);\n\tif (!err) {\n\t\tspin_lock(&dentry->d_lock);\n\t\tovl_dentry_set_redirect(dentry, redirect);\n\t\tspin_unlock(&dentry->d_lock);\n\t} else {\n\t\tkfree(redirect);\n\t\tpr_warn_ratelimited(\"failed to set redirect (%i)\\n\",\n\t\t\t\t    err);\n\t\t \n\t\terr = -EXDEV;\n\t}\n\treturn err;\n}\n\nstatic int ovl_rename(struct mnt_idmap *idmap, struct inode *olddir,\n\t\t      struct dentry *old, struct inode *newdir,\n\t\t      struct dentry *new, unsigned int flags)\n{\n\tint err;\n\tstruct dentry *old_upperdir;\n\tstruct dentry *new_upperdir;\n\tstruct dentry *olddentry;\n\tstruct dentry *newdentry;\n\tstruct dentry *trap;\n\tbool old_opaque;\n\tbool new_opaque;\n\tbool cleanup_whiteout = false;\n\tbool update_nlink = false;\n\tbool overwrite = !(flags & RENAME_EXCHANGE);\n\tbool is_dir = d_is_dir(old);\n\tbool new_is_dir = d_is_dir(new);\n\tbool samedir = olddir == newdir;\n\tstruct dentry *opaquedir = NULL;\n\tconst struct cred *old_cred = NULL;\n\tstruct ovl_fs *ofs = OVL_FS(old->d_sb);\n\tLIST_HEAD(list);\n\n\terr = -EINVAL;\n\tif (flags & ~(RENAME_EXCHANGE | RENAME_NOREPLACE))\n\t\tgoto out;\n\n\tflags &= ~RENAME_NOREPLACE;\n\n\t \n\terr = -EXDEV;\n\tif (!ovl_can_move(old))\n\t\tgoto out;\n\tif (!overwrite && !ovl_can_move(new))\n\t\tgoto out;\n\n\tif (overwrite && new_is_dir && !ovl_pure_upper(new)) {\n\t\terr = ovl_check_empty_dir(new, &list);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (overwrite) {\n\t\tif (ovl_lower_positive(old)) {\n\t\t\tif (!ovl_dentry_is_whiteout(new)) {\n\t\t\t\t \n\t\t\t\tflags |= RENAME_WHITEOUT;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tflags |= RENAME_EXCHANGE;\n\t\t\t}\n\t\t} else if (is_dir && ovl_dentry_is_whiteout(new)) {\n\t\t\tflags |= RENAME_EXCHANGE;\n\t\t\tcleanup_whiteout = true;\n\t\t}\n\t}\n\n\terr = ovl_want_write(old);\n\tif (err)\n\t\tgoto out;\n\n\terr = ovl_copy_up(old);\n\tif (err)\n\t\tgoto out_drop_write;\n\n\terr = ovl_copy_up(new->d_parent);\n\tif (err)\n\t\tgoto out_drop_write;\n\tif (!overwrite) {\n\t\terr = ovl_copy_up(new);\n\t\tif (err)\n\t\t\tgoto out_drop_write;\n\t} else if (d_inode(new)) {\n\t\terr = ovl_nlink_start(new);\n\t\tif (err)\n\t\t\tgoto out_drop_write;\n\n\t\tupdate_nlink = true;\n\t}\n\n\told_cred = ovl_override_creds(old->d_sb);\n\n\tif (!list_empty(&list)) {\n\t\topaquedir = ovl_clear_empty(new, &list);\n\t\terr = PTR_ERR(opaquedir);\n\t\tif (IS_ERR(opaquedir)) {\n\t\t\topaquedir = NULL;\n\t\t\tgoto out_revert_creds;\n\t\t}\n\t}\n\n\told_upperdir = ovl_dentry_upper(old->d_parent);\n\tnew_upperdir = ovl_dentry_upper(new->d_parent);\n\n\tif (!samedir) {\n\t\t \n\t\tif (ovl_type_origin(old)) {\n\t\t\terr = ovl_set_impure(new->d_parent, new_upperdir);\n\t\t\tif (err)\n\t\t\t\tgoto out_revert_creds;\n\t\t}\n\t\tif (!overwrite && ovl_type_origin(new)) {\n\t\t\terr = ovl_set_impure(old->d_parent, old_upperdir);\n\t\t\tif (err)\n\t\t\t\tgoto out_revert_creds;\n\t\t}\n\t}\n\n\ttrap = lock_rename(new_upperdir, old_upperdir);\n\n\tolddentry = ovl_lookup_upper(ofs, old->d_name.name, old_upperdir,\n\t\t\t\t     old->d_name.len);\n\terr = PTR_ERR(olddentry);\n\tif (IS_ERR(olddentry))\n\t\tgoto out_unlock;\n\n\terr = -ESTALE;\n\tif (!ovl_matches_upper(old, olddentry))\n\t\tgoto out_dput_old;\n\n\tnewdentry = ovl_lookup_upper(ofs, new->d_name.name, new_upperdir,\n\t\t\t\t     new->d_name.len);\n\terr = PTR_ERR(newdentry);\n\tif (IS_ERR(newdentry))\n\t\tgoto out_dput_old;\n\n\told_opaque = ovl_dentry_is_opaque(old);\n\tnew_opaque = ovl_dentry_is_opaque(new);\n\n\terr = -ESTALE;\n\tif (d_inode(new) && ovl_dentry_upper(new)) {\n\t\tif (opaquedir) {\n\t\t\tif (newdentry != opaquedir)\n\t\t\t\tgoto out_dput;\n\t\t} else {\n\t\t\tif (!ovl_matches_upper(new, newdentry))\n\t\t\t\tgoto out_dput;\n\t\t}\n\t} else {\n\t\tif (!d_is_negative(newdentry)) {\n\t\t\tif (!new_opaque || !ovl_is_whiteout(newdentry))\n\t\t\t\tgoto out_dput;\n\t\t} else {\n\t\t\tif (flags & RENAME_EXCHANGE)\n\t\t\t\tgoto out_dput;\n\t\t}\n\t}\n\n\tif (olddentry == trap)\n\t\tgoto out_dput;\n\tif (newdentry == trap)\n\t\tgoto out_dput;\n\n\tif (olddentry->d_inode == newdentry->d_inode)\n\t\tgoto out_dput;\n\n\terr = 0;\n\tif (ovl_type_merge_or_lower(old))\n\t\terr = ovl_set_redirect(old, samedir);\n\telse if (is_dir && !old_opaque && ovl_type_merge(new->d_parent))\n\t\terr = ovl_set_opaque_xerr(old, olddentry, -EXDEV);\n\tif (err)\n\t\tgoto out_dput;\n\n\tif (!overwrite && ovl_type_merge_or_lower(new))\n\t\terr = ovl_set_redirect(new, samedir);\n\telse if (!overwrite && new_is_dir && !new_opaque &&\n\t\t ovl_type_merge(old->d_parent))\n\t\terr = ovl_set_opaque_xerr(new, newdentry, -EXDEV);\n\tif (err)\n\t\tgoto out_dput;\n\n\terr = ovl_do_rename(ofs, old_upperdir->d_inode, olddentry,\n\t\t\t    new_upperdir->d_inode, newdentry, flags);\n\tif (err)\n\t\tgoto out_dput;\n\n\tif (cleanup_whiteout)\n\t\tovl_cleanup(ofs, old_upperdir->d_inode, newdentry);\n\n\tif (overwrite && d_inode(new)) {\n\t\tif (new_is_dir)\n\t\t\tclear_nlink(d_inode(new));\n\t\telse\n\t\t\tovl_drop_nlink(new);\n\t}\n\n\tovl_dir_modified(old->d_parent, ovl_type_origin(old) ||\n\t\t\t (!overwrite && ovl_type_origin(new)));\n\tovl_dir_modified(new->d_parent, ovl_type_origin(old) ||\n\t\t\t (d_inode(new) && ovl_type_origin(new)));\n\n\t \n\tovl_copyattr(d_inode(old));\n\tif (d_inode(new) && ovl_dentry_upper(new))\n\t\tovl_copyattr(d_inode(new));\n\nout_dput:\n\tdput(newdentry);\nout_dput_old:\n\tdput(olddentry);\nout_unlock:\n\tunlock_rename(new_upperdir, old_upperdir);\nout_revert_creds:\n\trevert_creds(old_cred);\n\tif (update_nlink)\n\t\tovl_nlink_end(new);\nout_drop_write:\n\tovl_drop_write(old);\nout:\n\tdput(opaquedir);\n\tovl_cache_free(&list);\n\treturn err;\n}\n\nconst struct inode_operations ovl_dir_inode_operations = {\n\t.lookup\t\t= ovl_lookup,\n\t.mkdir\t\t= ovl_mkdir,\n\t.symlink\t= ovl_symlink,\n\t.unlink\t\t= ovl_unlink,\n\t.rmdir\t\t= ovl_rmdir,\n\t.rename\t\t= ovl_rename,\n\t.link\t\t= ovl_link,\n\t.setattr\t= ovl_setattr,\n\t.create\t\t= ovl_create,\n\t.mknod\t\t= ovl_mknod,\n\t.permission\t= ovl_permission,\n\t.getattr\t= ovl_getattr,\n\t.listxattr\t= ovl_listxattr,\n\t.get_inode_acl\t= ovl_get_inode_acl,\n\t.get_acl\t= ovl_get_acl,\n\t.set_acl\t= ovl_set_acl,\n\t.update_time\t= ovl_update_time,\n\t.fileattr_get\t= ovl_fileattr_get,\n\t.fileattr_set\t= ovl_fileattr_set,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}