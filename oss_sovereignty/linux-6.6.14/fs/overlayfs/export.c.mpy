{
  "module_name": "export.c",
  "hash_id": "a04b5bd6cf8859a8a5a08ea5d397062ef9fcc3609da669e8856aa422ae6340f8",
  "original_prompt": "Ingested from linux-6.6.14/fs/overlayfs/export.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/cred.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/exportfs.h>\n#include <linux/ratelimit.h>\n#include \"overlayfs.h\"\n\nstatic int ovl_encode_maybe_copy_up(struct dentry *dentry)\n{\n\tint err;\n\n\tif (ovl_dentry_upper(dentry))\n\t\treturn 0;\n\n\terr = ovl_want_write(dentry);\n\tif (!err) {\n\t\terr = ovl_copy_up(dentry);\n\t\tovl_drop_write(dentry);\n\t}\n\n\tif (err) {\n\t\tpr_warn_ratelimited(\"failed to copy up on encode (%pd2, err=%i)\\n\",\n\t\t\t\t    dentry, err);\n\t}\n\n\treturn err;\n}\n\n \n\n \nstatic int ovl_connectable_layer(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = OVL_E(dentry);\n\n\t \n\tif (dentry == dentry->d_sb->s_root)\n\t\treturn ovl_numlower(oe);\n\n\t \n\tif (ovl_dentry_upper(dentry) &&\n\t    !ovl_test_flag(OVL_INDEX, d_inode(dentry)))\n\t\treturn 0;\n\n\t \n\treturn ovl_lowerstack(oe)->layer->idx;\n}\n\n \nstatic int ovl_connect_layer(struct dentry *dentry)\n{\n\tstruct dentry *next, *parent = NULL;\n\tstruct ovl_entry *oe = OVL_E(dentry);\n\tint origin_layer;\n\tint err = 0;\n\n\tif (WARN_ON(dentry == dentry->d_sb->s_root) ||\n\t    WARN_ON(!ovl_dentry_lower(dentry)))\n\t\treturn -EIO;\n\n\torigin_layer = ovl_lowerstack(oe)->layer->idx;\n\tif (ovl_dentry_test_flag(OVL_E_CONNECTED, dentry))\n\t\treturn origin_layer;\n\n\t \n\tnext = dget(dentry);\n\tfor (;;) {\n\t\tparent = dget_parent(next);\n\t\tif (WARN_ON(parent == next)) {\n\t\t\terr = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (ovl_connectable_layer(parent) < origin_layer) {\n\t\t\terr = ovl_encode_maybe_copy_up(next);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (ovl_dentry_test_flag(OVL_E_CONNECTED, parent) ||\n\t\t    ovl_test_flag(OVL_INDEX, d_inode(parent)))\n\t\t\tbreak;\n\n\t\tdput(next);\n\t\tnext = parent;\n\t}\n\n\tdput(parent);\n\tdput(next);\n\n\tif (!err)\n\t\tovl_dentry_set_flag(OVL_E_CONNECTED, dentry);\n\n\treturn err ?: origin_layer;\n}\n\n \nstatic int ovl_check_encode_origin(struct dentry *dentry)\n{\n\tstruct ovl_fs *ofs = OVL_FS(dentry->d_sb);\n\tbool decodable = ofs->config.nfs_export;\n\n\t \n\tif (!ovl_dentry_upper(dentry) && !decodable)\n\t\treturn 1;\n\n\t \n\tif (!ovl_dentry_lower(dentry))\n\t\treturn 0;\n\n\t \n\tif (dentry == dentry->d_sb->s_root)\n\t\treturn 0;\n\n\t \n\tif (ovl_dentry_upper(dentry) && decodable &&\n\t    !ovl_test_flag(OVL_INDEX, d_inode(dentry)))\n\t\treturn 0;\n\n\t \n\tif (d_is_dir(dentry) && ovl_upper_mnt(ofs) && decodable)\n\t\treturn ovl_connect_layer(dentry);\n\n\t \n\treturn 1;\n}\n\nstatic int ovl_dentry_to_fid(struct ovl_fs *ofs, struct dentry *dentry,\n\t\t\t     u32 *fid, int buflen)\n{\n\tstruct ovl_fh *fh = NULL;\n\tint err, enc_lower;\n\tint len;\n\n\t \n\terr = enc_lower = ovl_check_encode_origin(dentry);\n\tif (enc_lower < 0)\n\t\tgoto fail;\n\n\t \n\tfh = ovl_encode_real_fh(ofs, enc_lower ? ovl_dentry_lower(dentry) :\n\t\t\t\tovl_dentry_upper(dentry), !enc_lower);\n\tif (IS_ERR(fh))\n\t\treturn PTR_ERR(fh);\n\n\tlen = OVL_FH_LEN(fh);\n\tif (len <= buflen)\n\t\tmemcpy(fid, fh, len);\n\terr = len;\n\nout:\n\tkfree(fh);\n\treturn err;\n\nfail:\n\tpr_warn_ratelimited(\"failed to encode file handle (%pd2, err=%i)\\n\",\n\t\t\t    dentry, err);\n\tgoto out;\n}\n\nstatic int ovl_encode_fh(struct inode *inode, u32 *fid, int *max_len,\n\t\t\t struct inode *parent)\n{\n\tstruct ovl_fs *ofs = OVL_FS(inode->i_sb);\n\tstruct dentry *dentry;\n\tint bytes, buflen = *max_len << 2;\n\n\t \n\tif (parent)\n\t\treturn FILEID_INVALID;\n\n\tdentry = d_find_any_alias(inode);\n\tif (!dentry)\n\t\treturn FILEID_INVALID;\n\n\tbytes = ovl_dentry_to_fid(ofs, dentry, fid, buflen);\n\tdput(dentry);\n\tif (bytes <= 0)\n\t\treturn FILEID_INVALID;\n\n\t*max_len = bytes >> 2;\n\tif (bytes > buflen)\n\t\treturn FILEID_INVALID;\n\n\treturn OVL_FILEID_V1;\n}\n\n \nstatic struct dentry *ovl_obtain_alias(struct super_block *sb,\n\t\t\t\t       struct dentry *upper_alias,\n\t\t\t\t       struct ovl_path *lowerpath,\n\t\t\t\t       struct dentry *index)\n{\n\tstruct dentry *lower = lowerpath ? lowerpath->dentry : NULL;\n\tstruct dentry *upper = upper_alias ?: index;\n\tstruct dentry *dentry;\n\tstruct inode *inode = NULL;\n\tstruct ovl_entry *oe;\n\tstruct ovl_inode_params oip = {\n\t\t.index = index,\n\t};\n\n\t \n\tif (d_is_dir(upper ?: lower))\n\t\treturn ERR_PTR(-EIO);\n\n\toe = ovl_alloc_entry(!!lower);\n\tif (!oe)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\toip.upperdentry = dget(upper);\n\tif (lower) {\n\t\tovl_lowerstack(oe)->dentry = dget(lower);\n\t\tovl_lowerstack(oe)->layer = lowerpath->layer;\n\t}\n\toip.oe = oe;\n\tinode = ovl_get_inode(sb, &oip);\n\tif (IS_ERR(inode)) {\n\t\tovl_free_entry(oe);\n\t\tdput(upper);\n\t\treturn ERR_CAST(inode);\n\t}\n\n\tif (upper)\n\t\tovl_set_flag(OVL_UPPERDATA, inode);\n\n\tdentry = d_find_any_alias(inode);\n\tif (dentry)\n\t\tgoto out_iput;\n\n\tdentry = d_alloc_anon(inode->i_sb);\n\tif (unlikely(!dentry))\n\t\tgoto nomem;\n\n\tif (upper_alias)\n\t\tovl_dentry_set_upper_alias(dentry);\n\n\tovl_dentry_init_reval(dentry, upper, OVL_I_E(inode));\n\n\treturn d_instantiate_anon(dentry, inode);\n\nnomem:\n\tdput(dentry);\n\tdentry = ERR_PTR(-ENOMEM);\nout_iput:\n\tiput(inode);\n\treturn dentry;\n}\n\n \nstatic struct dentry *ovl_dentry_real_at(struct dentry *dentry, int idx)\n{\n\tstruct ovl_entry *oe = OVL_E(dentry);\n\tstruct ovl_path *lowerstack = ovl_lowerstack(oe);\n\tint i;\n\n\tif (!idx)\n\t\treturn ovl_dentry_upper(dentry);\n\n\tfor (i = 0; i < ovl_numlower(oe); i++) {\n\t\tif (lowerstack[i].layer->idx == idx)\n\t\t\treturn lowerstack[i].dentry;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic struct dentry *ovl_lookup_real_one(struct dentry *connected,\n\t\t\t\t\t  struct dentry *real,\n\t\t\t\t\t  const struct ovl_layer *layer)\n{\n\tstruct inode *dir = d_inode(connected);\n\tstruct dentry *this, *parent = NULL;\n\tstruct name_snapshot name;\n\tint err;\n\n\t \n\tinode_lock_nested(dir, I_MUTEX_PARENT);\n\terr = -ECHILD;\n\tparent = dget_parent(real);\n\tif (ovl_dentry_real_at(connected, layer->idx) != parent)\n\t\tgoto fail;\n\n\t \n\ttake_dentry_name_snapshot(&name, real);\n\t \n\tthis = lookup_one_len(name.name.name, connected, name.name.len);\n\trelease_dentry_name_snapshot(&name);\n\terr = PTR_ERR(this);\n\tif (IS_ERR(this)) {\n\t\tgoto fail;\n\t} else if (!this || !this->d_inode) {\n\t\tdput(this);\n\t\terr = -ENOENT;\n\t\tgoto fail;\n\t} else if (ovl_dentry_real_at(this, layer->idx) != real) {\n\t\tdput(this);\n\t\terr = -ESTALE;\n\t\tgoto fail;\n\t}\n\nout:\n\tdput(parent);\n\tinode_unlock(dir);\n\treturn this;\n\nfail:\n\tpr_warn_ratelimited(\"failed to lookup one by real (%pd2, layer=%d, connected=%pd2, err=%i)\\n\",\n\t\t\t    real, layer->idx, connected, err);\n\tthis = ERR_PTR(err);\n\tgoto out;\n}\n\nstatic struct dentry *ovl_lookup_real(struct super_block *sb,\n\t\t\t\t      struct dentry *real,\n\t\t\t\t      const struct ovl_layer *layer);\n\n \nstatic struct dentry *ovl_lookup_real_inode(struct super_block *sb,\n\t\t\t\t\t    struct dentry *real,\n\t\t\t\t\t    const struct ovl_layer *layer)\n{\n\tstruct ovl_fs *ofs = OVL_FS(sb);\n\tstruct dentry *index = NULL;\n\tstruct dentry *this = NULL;\n\tstruct inode *inode;\n\n\t \n\tinode = ovl_lookup_inode(sb, real, !layer->idx);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\tif (inode) {\n\t\tthis = d_find_any_alias(inode);\n\t\tiput(inode);\n\t}\n\n\t \n\tif (!this && layer->idx && ofs->indexdir && !WARN_ON(!d_is_dir(real))) {\n\t\tindex = ovl_lookup_index(ofs, NULL, real, false);\n\t\tif (IS_ERR(index))\n\t\t\treturn index;\n\t}\n\n\t \n\tif (index) {\n\t\tstruct dentry *upper = ovl_index_upper(ofs, index, true);\n\n\t\tdput(index);\n\t\tif (IS_ERR_OR_NULL(upper))\n\t\t\treturn upper;\n\n\t\t \n\t\tthis = ovl_lookup_real(sb, upper, &ofs->layers[0]);\n\t\tdput(upper);\n\t}\n\n\tif (IS_ERR_OR_NULL(this))\n\t\treturn this;\n\n\tif (ovl_dentry_real_at(this, layer->idx) != real) {\n\t\tdput(this);\n\t\tthis = ERR_PTR(-EIO);\n\t}\n\n\treturn this;\n}\n\n \nstatic struct dentry *ovl_lookup_real_ancestor(struct super_block *sb,\n\t\t\t\t\t       struct dentry *real,\n\t\t\t\t\t       const struct ovl_layer *layer)\n{\n\tstruct dentry *next, *parent = NULL;\n\tstruct dentry *ancestor = ERR_PTR(-EIO);\n\n\tif (real == layer->mnt->mnt_root)\n\t\treturn dget(sb->s_root);\n\n\t \n\tnext = dget(real);\n\tfor (;;) {\n\t\tparent = dget_parent(next);\n\n\t\t \n\t\tancestor = ovl_lookup_real_inode(sb, next, layer);\n\t\tif (ancestor)\n\t\t\tbreak;\n\n\t\tif (parent == layer->mnt->mnt_root) {\n\t\t\tancestor = dget(sb->s_root);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (parent == next) {\n\t\t\tancestor = ERR_PTR(-EXDEV);\n\t\t\tbreak;\n\t\t}\n\n\t\tdput(next);\n\t\tnext = parent;\n\t}\n\n\tdput(parent);\n\tdput(next);\n\n\treturn ancestor;\n}\n\n \nstatic struct dentry *ovl_lookup_real(struct super_block *sb,\n\t\t\t\t      struct dentry *real,\n\t\t\t\t      const struct ovl_layer *layer)\n{\n\tstruct dentry *connected;\n\tint err = 0;\n\n\tconnected = ovl_lookup_real_ancestor(sb, real, layer);\n\tif (IS_ERR(connected))\n\t\treturn connected;\n\n\twhile (!err) {\n\t\tstruct dentry *next, *this;\n\t\tstruct dentry *parent = NULL;\n\t\tstruct dentry *real_connected = ovl_dentry_real_at(connected,\n\t\t\t\t\t\t\t\t   layer->idx);\n\n\t\tif (real_connected == real)\n\t\t\tbreak;\n\n\t\t \n\t\tnext = dget(real);\n\t\tfor (;;) {\n\t\t\tparent = dget_parent(next);\n\n\t\t\tif (parent == real_connected)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tif (parent == layer->mnt->mnt_root) {\n\t\t\t\tdput(connected);\n\t\t\t\tconnected = dget(sb->s_root);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (parent == next) {\n\t\t\t\terr = -EXDEV;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdput(next);\n\t\t\tnext = parent;\n\t\t}\n\n\t\tif (!err) {\n\t\t\tthis = ovl_lookup_real_one(connected, next, layer);\n\t\t\tif (IS_ERR(this))\n\t\t\t\terr = PTR_ERR(this);\n\n\t\t\t \n\t\t\tif (err == -ECHILD) {\n\t\t\t\tthis = ovl_lookup_real_ancestor(sb, real,\n\t\t\t\t\t\t\t\tlayer);\n\t\t\t\terr = PTR_ERR_OR_ZERO(this);\n\t\t\t}\n\t\t\tif (!err) {\n\t\t\t\tdput(connected);\n\t\t\t\tconnected = this;\n\t\t\t}\n\t\t}\n\n\t\tdput(parent);\n\t\tdput(next);\n\t}\n\n\tif (err)\n\t\tgoto fail;\n\n\treturn connected;\n\nfail:\n\tpr_warn_ratelimited(\"failed to lookup by real (%pd2, layer=%d, connected=%pd2, err=%i)\\n\",\n\t\t\t    real, layer->idx, connected, err);\n\tdput(connected);\n\treturn ERR_PTR(err);\n}\n\n \nstatic struct dentry *ovl_get_dentry(struct super_block *sb,\n\t\t\t\t     struct dentry *upper,\n\t\t\t\t     struct ovl_path *lowerpath,\n\t\t\t\t     struct dentry *index)\n{\n\tstruct ovl_fs *ofs = OVL_FS(sb);\n\tconst struct ovl_layer *layer = upper ? &ofs->layers[0] : lowerpath->layer;\n\tstruct dentry *real = upper ?: (index ?: lowerpath->dentry);\n\n\t \n\tif (!d_is_dir(real))\n\t\treturn ovl_obtain_alias(sb, upper, lowerpath, index);\n\n\t \n\tif ((real->d_flags & DCACHE_DISCONNECTED) || d_unhashed(real))\n\t\treturn ERR_PTR(-ENOENT);\n\n\t \n\treturn ovl_lookup_real(sb, real, layer);\n}\n\nstatic struct dentry *ovl_upper_fh_to_d(struct super_block *sb,\n\t\t\t\t\tstruct ovl_fh *fh)\n{\n\tstruct ovl_fs *ofs = OVL_FS(sb);\n\tstruct dentry *dentry;\n\tstruct dentry *upper;\n\n\tif (!ovl_upper_mnt(ofs))\n\t\treturn ERR_PTR(-EACCES);\n\n\tupper = ovl_decode_real_fh(ofs, fh, ovl_upper_mnt(ofs), true);\n\tif (IS_ERR_OR_NULL(upper))\n\t\treturn upper;\n\n\tdentry = ovl_get_dentry(sb, upper, NULL, NULL);\n\tdput(upper);\n\n\treturn dentry;\n}\n\nstatic struct dentry *ovl_lower_fh_to_d(struct super_block *sb,\n\t\t\t\t\tstruct ovl_fh *fh)\n{\n\tstruct ovl_fs *ofs = OVL_FS(sb);\n\tstruct ovl_path origin = { };\n\tstruct ovl_path *stack = &origin;\n\tstruct dentry *dentry = NULL;\n\tstruct dentry *index = NULL;\n\tstruct inode *inode;\n\tint err;\n\n\t \n\terr = ovl_check_origin_fh(ofs, fh, false, NULL, &stack);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tif (!d_is_dir(origin.dentry) ||\n\t    !(origin.dentry->d_flags & DCACHE_DISCONNECTED)) {\n\t\tinode = ovl_lookup_inode(sb, origin.dentry, false);\n\t\terr = PTR_ERR(inode);\n\t\tif (IS_ERR(inode))\n\t\t\tgoto out_err;\n\t\tif (inode) {\n\t\t\tdentry = d_find_any_alias(inode);\n\t\t\tiput(inode);\n\t\t\tif (dentry)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tif (ofs->indexdir) {\n\t\tindex = ovl_get_index_fh(ofs, fh);\n\t\terr = PTR_ERR(index);\n\t\tif (IS_ERR(index)) {\n\t\t\tindex = NULL;\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\t \n\tif (index && d_is_dir(index)) {\n\t\tstruct dentry *upper = ovl_index_upper(ofs, index, true);\n\n\t\terr = PTR_ERR(upper);\n\t\tif (IS_ERR_OR_NULL(upper))\n\t\t\tgoto out_err;\n\n\t\tdentry = ovl_get_dentry(sb, upper, NULL, NULL);\n\t\tdput(upper);\n\t\tgoto out;\n\t}\n\n\t \n\tif (d_is_dir(origin.dentry)) {\n\t\tdput(origin.dentry);\n\t\torigin.dentry = NULL;\n\t\terr = ovl_check_origin_fh(ofs, fh, true, NULL, &stack);\n\t\tif (err)\n\t\t\tgoto out_err;\n\t}\n\tif (index) {\n\t\terr = ovl_verify_origin(ofs, index, origin.dentry, false);\n\t\tif (err)\n\t\t\tgoto out_err;\n\t}\n\n\t \n\tdentry = ovl_get_dentry(sb, NULL, &origin, index);\n\nout:\n\tdput(origin.dentry);\n\tdput(index);\n\treturn dentry;\n\nout_err:\n\tdentry = ERR_PTR(err);\n\tgoto out;\n}\n\nstatic struct ovl_fh *ovl_fid_to_fh(struct fid *fid, int buflen, int fh_type)\n{\n\tstruct ovl_fh *fh;\n\n\t \n\tif (fh_type == OVL_FILEID_V1)\n\t\treturn (struct ovl_fh *)fid;\n\n\tif (fh_type != OVL_FILEID_V0)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (buflen <= OVL_FH_WIRE_OFFSET)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tfh = kzalloc(buflen, GFP_KERNEL);\n\tif (!fh)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tmemcpy(fh->buf, fid, buflen - OVL_FH_WIRE_OFFSET);\n\treturn fh;\n}\n\nstatic struct dentry *ovl_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\t\t\t       int fh_len, int fh_type)\n{\n\tstruct dentry *dentry = NULL;\n\tstruct ovl_fh *fh = NULL;\n\tint len = fh_len << 2;\n\tunsigned int flags = 0;\n\tint err;\n\n\tfh = ovl_fid_to_fh(fid, len, fh_type);\n\terr = PTR_ERR(fh);\n\tif (IS_ERR(fh))\n\t\tgoto out_err;\n\n\terr = ovl_check_fh_len(fh, len);\n\tif (err)\n\t\tgoto out_err;\n\n\tflags = fh->fb.flags;\n\tdentry = (flags & OVL_FH_FLAG_PATH_UPPER) ?\n\t\t ovl_upper_fh_to_d(sb, fh) :\n\t\t ovl_lower_fh_to_d(sb, fh);\n\terr = PTR_ERR(dentry);\n\tif (IS_ERR(dentry) && err != -ESTALE)\n\t\tgoto out_err;\n\nout:\n\t \n\tif (!IS_ERR_OR_NULL(fh) && fh != (void *)fid)\n\t\tkfree(fh);\n\n\treturn dentry;\n\nout_err:\n\tpr_warn_ratelimited(\"failed to decode file handle (len=%d, type=%d, flags=%x, err=%i)\\n\",\n\t\t\t    fh_len, fh_type, flags, err);\n\tdentry = ERR_PTR(err);\n\tgoto out;\n}\n\nstatic struct dentry *ovl_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\t\t\t       int fh_len, int fh_type)\n{\n\tpr_warn_ratelimited(\"connectable file handles not supported; use 'no_subtree_check' exportfs option.\\n\");\n\treturn ERR_PTR(-EACCES);\n}\n\nstatic int ovl_get_name(struct dentry *parent, char *name,\n\t\t\tstruct dentry *child)\n{\n\t \n\tWARN_ON_ONCE(1);\n\treturn -EIO;\n}\n\nstatic struct dentry *ovl_get_parent(struct dentry *dentry)\n{\n\t \n\tWARN_ON_ONCE(1);\n\treturn ERR_PTR(-EIO);\n}\n\nconst struct export_operations ovl_export_operations = {\n\t.encode_fh\t= ovl_encode_fh,\n\t.fh_to_dentry\t= ovl_fh_to_dentry,\n\t.fh_to_parent\t= ovl_fh_to_parent,\n\t.get_name\t= ovl_get_name,\n\t.get_parent\t= ovl_get_parent,\n};\n\n \nconst struct export_operations ovl_export_fid_operations = {\n\t.encode_fh\t= ovl_encode_fh,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}