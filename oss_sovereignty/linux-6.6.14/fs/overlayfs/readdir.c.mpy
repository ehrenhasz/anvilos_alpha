{
  "module_name": "readdir.c",
  "hash_id": "e6c2f38ffccd0d2774f4213d77bfb079e905ded6bd1c9d995d9ac0f8e54bd503",
  "original_prompt": "Ingested from linux-6.6.14/fs/overlayfs/readdir.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/xattr.h>\n#include <linux/rbtree.h>\n#include <linux/security.h>\n#include <linux/cred.h>\n#include <linux/ratelimit.h>\n#include \"overlayfs.h\"\n\nstruct ovl_cache_entry {\n\tunsigned int len;\n\tunsigned int type;\n\tu64 real_ino;\n\tu64 ino;\n\tstruct list_head l_node;\n\tstruct rb_node node;\n\tstruct ovl_cache_entry *next_maybe_whiteout;\n\tbool is_upper;\n\tbool is_whiteout;\n\tchar name[];\n};\n\nstruct ovl_dir_cache {\n\tlong refcount;\n\tu64 version;\n\tstruct list_head entries;\n\tstruct rb_root root;\n};\n\nstruct ovl_readdir_data {\n\tstruct dir_context ctx;\n\tstruct dentry *dentry;\n\tbool is_lowest;\n\tstruct rb_root *root;\n\tstruct list_head *list;\n\tstruct list_head middle;\n\tstruct ovl_cache_entry *first_maybe_whiteout;\n\tint count;\n\tint err;\n\tbool is_upper;\n\tbool d_type_supported;\n};\n\nstruct ovl_dir_file {\n\tbool is_real;\n\tbool is_upper;\n\tstruct ovl_dir_cache *cache;\n\tstruct list_head *cursor;\n\tstruct file *realfile;\n\tstruct file *upperfile;\n};\n\nstatic struct ovl_cache_entry *ovl_cache_entry_from_node(struct rb_node *n)\n{\n\treturn rb_entry(n, struct ovl_cache_entry, node);\n}\n\nstatic bool ovl_cache_entry_find_link(const char *name, int len,\n\t\t\t\t      struct rb_node ***link,\n\t\t\t\t      struct rb_node **parent)\n{\n\tbool found = false;\n\tstruct rb_node **newp = *link;\n\n\twhile (!found && *newp) {\n\t\tint cmp;\n\t\tstruct ovl_cache_entry *tmp;\n\n\t\t*parent = *newp;\n\t\ttmp = ovl_cache_entry_from_node(*newp);\n\t\tcmp = strncmp(name, tmp->name, len);\n\t\tif (cmp > 0)\n\t\t\tnewp = &tmp->node.rb_right;\n\t\telse if (cmp < 0 || len < tmp->len)\n\t\t\tnewp = &tmp->node.rb_left;\n\t\telse\n\t\t\tfound = true;\n\t}\n\t*link = newp;\n\n\treturn found;\n}\n\nstatic struct ovl_cache_entry *ovl_cache_entry_find(struct rb_root *root,\n\t\t\t\t\t\t    const char *name, int len)\n{\n\tstruct rb_node *node = root->rb_node;\n\tint cmp;\n\n\twhile (node) {\n\t\tstruct ovl_cache_entry *p = ovl_cache_entry_from_node(node);\n\n\t\tcmp = strncmp(name, p->name, len);\n\t\tif (cmp > 0)\n\t\t\tnode = p->node.rb_right;\n\t\telse if (cmp < 0 || len < p->len)\n\t\t\tnode = p->node.rb_left;\n\t\telse\n\t\t\treturn p;\n\t}\n\n\treturn NULL;\n}\n\nstatic bool ovl_calc_d_ino(struct ovl_readdir_data *rdd,\n\t\t\t   struct ovl_cache_entry *p)\n{\n\t \n\tif (!rdd->dentry)\n\t\treturn false;\n\n\t \n\tif (ovl_xino_bits(OVL_FS(rdd->dentry->d_sb)))\n\t\treturn true;\n\n\t \n\tif (strcmp(p->name, \"..\") == 0)\n\t\treturn true;\n\n\t \n\tif (!rdd->is_upper)\n\t\treturn false;\n\n\t \n\tif ((p->name[0] == '.' && p->len == 1) ||\n\t    ovl_test_flag(OVL_IMPURE, d_inode(rdd->dentry)))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic struct ovl_cache_entry *ovl_cache_entry_new(struct ovl_readdir_data *rdd,\n\t\t\t\t\t\t   const char *name, int len,\n\t\t\t\t\t\t   u64 ino, unsigned int d_type)\n{\n\tstruct ovl_cache_entry *p;\n\tsize_t size = offsetof(struct ovl_cache_entry, name[len + 1]);\n\n\tp = kmalloc(size, GFP_KERNEL);\n\tif (!p)\n\t\treturn NULL;\n\n\tmemcpy(p->name, name, len);\n\tp->name[len] = '\\0';\n\tp->len = len;\n\tp->type = d_type;\n\tp->real_ino = ino;\n\tp->ino = ino;\n\t \n\tif (ovl_calc_d_ino(rdd, p))\n\t\tp->ino = 0;\n\tp->is_upper = rdd->is_upper;\n\tp->is_whiteout = false;\n\n\tif (d_type == DT_CHR) {\n\t\tp->next_maybe_whiteout = rdd->first_maybe_whiteout;\n\t\trdd->first_maybe_whiteout = p;\n\t}\n\treturn p;\n}\n\nstatic bool ovl_cache_entry_add_rb(struct ovl_readdir_data *rdd,\n\t\t\t\t  const char *name, int len, u64 ino,\n\t\t\t\t  unsigned int d_type)\n{\n\tstruct rb_node **newp = &rdd->root->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct ovl_cache_entry *p;\n\n\tif (ovl_cache_entry_find_link(name, len, &newp, &parent))\n\t\treturn true;\n\n\tp = ovl_cache_entry_new(rdd, name, len, ino, d_type);\n\tif (p == NULL) {\n\t\trdd->err = -ENOMEM;\n\t\treturn false;\n\t}\n\n\tlist_add_tail(&p->l_node, rdd->list);\n\trb_link_node(&p->node, parent, newp);\n\trb_insert_color(&p->node, rdd->root);\n\n\treturn true;\n}\n\nstatic bool ovl_fill_lowest(struct ovl_readdir_data *rdd,\n\t\t\t   const char *name, int namelen,\n\t\t\t   loff_t offset, u64 ino, unsigned int d_type)\n{\n\tstruct ovl_cache_entry *p;\n\n\tp = ovl_cache_entry_find(rdd->root, name, namelen);\n\tif (p) {\n\t\tlist_move_tail(&p->l_node, &rdd->middle);\n\t} else {\n\t\tp = ovl_cache_entry_new(rdd, name, namelen, ino, d_type);\n\t\tif (p == NULL)\n\t\t\trdd->err = -ENOMEM;\n\t\telse\n\t\t\tlist_add_tail(&p->l_node, &rdd->middle);\n\t}\n\n\treturn rdd->err == 0;\n}\n\nvoid ovl_cache_free(struct list_head *list)\n{\n\tstruct ovl_cache_entry *p;\n\tstruct ovl_cache_entry *n;\n\n\tlist_for_each_entry_safe(p, n, list, l_node)\n\t\tkfree(p);\n\n\tINIT_LIST_HEAD(list);\n}\n\nvoid ovl_dir_cache_free(struct inode *inode)\n{\n\tstruct ovl_dir_cache *cache = ovl_dir_cache(inode);\n\n\tif (cache) {\n\t\tovl_cache_free(&cache->entries);\n\t\tkfree(cache);\n\t}\n}\n\nstatic void ovl_cache_put(struct ovl_dir_file *od, struct inode *inode)\n{\n\tstruct ovl_dir_cache *cache = od->cache;\n\n\tWARN_ON(cache->refcount <= 0);\n\tcache->refcount--;\n\tif (!cache->refcount) {\n\t\tif (ovl_dir_cache(inode) == cache)\n\t\t\tovl_set_dir_cache(inode, NULL);\n\n\t\tovl_cache_free(&cache->entries);\n\t\tkfree(cache);\n\t}\n}\n\nstatic bool ovl_fill_merge(struct dir_context *ctx, const char *name,\n\t\t\t  int namelen, loff_t offset, u64 ino,\n\t\t\t  unsigned int d_type)\n{\n\tstruct ovl_readdir_data *rdd =\n\t\tcontainer_of(ctx, struct ovl_readdir_data, ctx);\n\n\trdd->count++;\n\tif (!rdd->is_lowest)\n\t\treturn ovl_cache_entry_add_rb(rdd, name, namelen, ino, d_type);\n\telse\n\t\treturn ovl_fill_lowest(rdd, name, namelen, offset, ino, d_type);\n}\n\nstatic int ovl_check_whiteouts(const struct path *path, struct ovl_readdir_data *rdd)\n{\n\tint err;\n\tstruct ovl_cache_entry *p;\n\tstruct dentry *dentry, *dir = path->dentry;\n\tconst struct cred *old_cred;\n\n\told_cred = ovl_override_creds(rdd->dentry->d_sb);\n\n\terr = down_write_killable(&dir->d_inode->i_rwsem);\n\tif (!err) {\n\t\twhile (rdd->first_maybe_whiteout) {\n\t\t\tp = rdd->first_maybe_whiteout;\n\t\t\trdd->first_maybe_whiteout = p->next_maybe_whiteout;\n\t\t\tdentry = lookup_one(mnt_idmap(path->mnt), p->name, dir, p->len);\n\t\t\tif (!IS_ERR(dentry)) {\n\t\t\t\tp->is_whiteout = ovl_is_whiteout(dentry);\n\t\t\t\tdput(dentry);\n\t\t\t}\n\t\t}\n\t\tinode_unlock(dir->d_inode);\n\t}\n\trevert_creds(old_cred);\n\n\treturn err;\n}\n\nstatic inline int ovl_dir_read(const struct path *realpath,\n\t\t\t       struct ovl_readdir_data *rdd)\n{\n\tstruct file *realfile;\n\tint err;\n\n\trealfile = ovl_path_open(realpath, O_RDONLY | O_LARGEFILE);\n\tif (IS_ERR(realfile))\n\t\treturn PTR_ERR(realfile);\n\n\trdd->first_maybe_whiteout = NULL;\n\trdd->ctx.pos = 0;\n\tdo {\n\t\trdd->count = 0;\n\t\trdd->err = 0;\n\t\terr = iterate_dir(realfile, &rdd->ctx);\n\t\tif (err >= 0)\n\t\t\terr = rdd->err;\n\t} while (!err && rdd->count);\n\n\tif (!err && rdd->first_maybe_whiteout && rdd->dentry)\n\t\terr = ovl_check_whiteouts(realpath, rdd);\n\n\tfput(realfile);\n\n\treturn err;\n}\n\nstatic void ovl_dir_reset(struct file *file)\n{\n\tstruct ovl_dir_file *od = file->private_data;\n\tstruct ovl_dir_cache *cache = od->cache;\n\tstruct inode *inode = file_inode(file);\n\tbool is_real;\n\n\tif (cache && ovl_inode_version_get(inode) != cache->version) {\n\t\tovl_cache_put(od, inode);\n\t\tod->cache = NULL;\n\t\tod->cursor = NULL;\n\t}\n\tis_real = ovl_dir_is_real(inode);\n\tif (od->is_real != is_real) {\n\t\t \n\t\tif (WARN_ON(is_real))\n\t\t\treturn;\n\t\tod->is_real = false;\n\t}\n}\n\nstatic int ovl_dir_read_merged(struct dentry *dentry, struct list_head *list,\n\tstruct rb_root *root)\n{\n\tint err;\n\tstruct path realpath;\n\tstruct ovl_readdir_data rdd = {\n\t\t.ctx.actor = ovl_fill_merge,\n\t\t.dentry = dentry,\n\t\t.list = list,\n\t\t.root = root,\n\t\t.is_lowest = false,\n\t};\n\tint idx, next;\n\n\tfor (idx = 0; idx != -1; idx = next) {\n\t\tnext = ovl_path_next(idx, dentry, &realpath);\n\t\trdd.is_upper = ovl_dentry_upper(dentry) == realpath.dentry;\n\n\t\tif (next != -1) {\n\t\t\terr = ovl_dir_read(&realpath, &rdd);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\t \n\t\t\tlist_add(&rdd.middle, rdd.list);\n\t\t\trdd.is_lowest = true;\n\t\t\terr = ovl_dir_read(&realpath, &rdd);\n\t\t\tlist_del(&rdd.middle);\n\t\t}\n\t}\n\treturn err;\n}\n\nstatic void ovl_seek_cursor(struct ovl_dir_file *od, loff_t pos)\n{\n\tstruct list_head *p;\n\tloff_t off = 0;\n\n\tlist_for_each(p, &od->cache->entries) {\n\t\tif (off >= pos)\n\t\t\tbreak;\n\t\toff++;\n\t}\n\t \n\tod->cursor = p;\n}\n\nstatic struct ovl_dir_cache *ovl_cache_get(struct dentry *dentry)\n{\n\tint res;\n\tstruct ovl_dir_cache *cache;\n\tstruct inode *inode = d_inode(dentry);\n\n\tcache = ovl_dir_cache(inode);\n\tif (cache && ovl_inode_version_get(inode) == cache->version) {\n\t\tWARN_ON(!cache->refcount);\n\t\tcache->refcount++;\n\t\treturn cache;\n\t}\n\tovl_set_dir_cache(d_inode(dentry), NULL);\n\n\tcache = kzalloc(sizeof(struct ovl_dir_cache), GFP_KERNEL);\n\tif (!cache)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcache->refcount = 1;\n\tINIT_LIST_HEAD(&cache->entries);\n\tcache->root = RB_ROOT;\n\n\tres = ovl_dir_read_merged(dentry, &cache->entries, &cache->root);\n\tif (res) {\n\t\tovl_cache_free(&cache->entries);\n\t\tkfree(cache);\n\t\treturn ERR_PTR(res);\n\t}\n\n\tcache->version = ovl_inode_version_get(inode);\n\tovl_set_dir_cache(inode, cache);\n\n\treturn cache;\n}\n\n \nstatic u64 ovl_remap_lower_ino(u64 ino, int xinobits, int fsid,\n\t\t\t       const char *name, int namelen, bool warn)\n{\n\tunsigned int xinoshift = 64 - xinobits;\n\n\tif (unlikely(ino >> xinoshift)) {\n\t\tif (warn) {\n\t\t\tpr_warn_ratelimited(\"d_ino too big (%.*s, ino=%llu, xinobits=%d)\\n\",\n\t\t\t\t\t    namelen, name, ino, xinobits);\n\t\t}\n\t\treturn ino;\n\t}\n\n\t \n\treturn ino | ((u64)fsid) << (xinoshift + 1);\n}\n\n \nstatic int ovl_cache_update_ino(const struct path *path, struct ovl_cache_entry *p)\n\n{\n\tstruct dentry *dir = path->dentry;\n\tstruct ovl_fs *ofs = OVL_FS(dir->d_sb);\n\tstruct dentry *this = NULL;\n\tenum ovl_path_type type;\n\tu64 ino = p->real_ino;\n\tint xinobits = ovl_xino_bits(ofs);\n\tint err = 0;\n\n\tif (!ovl_same_dev(ofs))\n\t\tgoto out;\n\n\tif (p->name[0] == '.') {\n\t\tif (p->len == 1) {\n\t\t\tthis = dget(dir);\n\t\t\tgoto get;\n\t\t}\n\t\tif (p->len == 2 && p->name[1] == '.') {\n\t\t\t \n\t\t\tthis = dget(dir->d_parent);\n\t\t\tgoto get;\n\t\t}\n\t}\n\tthis = lookup_one(mnt_idmap(path->mnt), p->name, dir, p->len);\n\tif (IS_ERR_OR_NULL(this) || !this->d_inode) {\n\t\t \n\t\tp->is_whiteout = true;\n\t\tif (IS_ERR(this)) {\n\t\t\terr = PTR_ERR(this);\n\t\t\tthis = NULL;\n\t\t\tgoto fail;\n\t\t}\n\t\tgoto out;\n\t}\n\nget:\n\ttype = ovl_path_type(this);\n\tif (OVL_TYPE_ORIGIN(type)) {\n\t\tstruct kstat stat;\n\t\tstruct path statpath = *path;\n\n\t\tstatpath.dentry = this;\n\t\terr = vfs_getattr(&statpath, &stat, STATX_INO, 0);\n\t\tif (err)\n\t\t\tgoto fail;\n\n\t\t \n\t\tWARN_ON_ONCE(S_ISDIR(stat.mode) &&\n\t\t\t     dir->d_sb->s_dev != stat.dev);\n\t\tino = stat.ino;\n\t} else if (xinobits && !OVL_TYPE_UPPER(type)) {\n\t\tino = ovl_remap_lower_ino(ino, xinobits,\n\t\t\t\t\t  ovl_layer_lower(this)->fsid,\n\t\t\t\t\t  p->name, p->len,\n\t\t\t\t\t  ovl_xino_warn(ofs));\n\t}\n\nout:\n\tp->ino = ino;\n\tdput(this);\n\treturn err;\n\nfail:\n\tpr_warn_ratelimited(\"failed to look up (%s) for ino (%i)\\n\",\n\t\t\t    p->name, err);\n\tgoto out;\n}\n\nstatic bool ovl_fill_plain(struct dir_context *ctx, const char *name,\n\t\t\t  int namelen, loff_t offset, u64 ino,\n\t\t\t  unsigned int d_type)\n{\n\tstruct ovl_cache_entry *p;\n\tstruct ovl_readdir_data *rdd =\n\t\tcontainer_of(ctx, struct ovl_readdir_data, ctx);\n\n\trdd->count++;\n\tp = ovl_cache_entry_new(rdd, name, namelen, ino, d_type);\n\tif (p == NULL) {\n\t\trdd->err = -ENOMEM;\n\t\treturn false;\n\t}\n\tlist_add_tail(&p->l_node, rdd->list);\n\n\treturn true;\n}\n\nstatic int ovl_dir_read_impure(const struct path *path,  struct list_head *list,\n\t\t\t       struct rb_root *root)\n{\n\tint err;\n\tstruct path realpath;\n\tstruct ovl_cache_entry *p, *n;\n\tstruct ovl_readdir_data rdd = {\n\t\t.ctx.actor = ovl_fill_plain,\n\t\t.list = list,\n\t\t.root = root,\n\t};\n\n\tINIT_LIST_HEAD(list);\n\t*root = RB_ROOT;\n\tovl_path_upper(path->dentry, &realpath);\n\n\terr = ovl_dir_read(&realpath, &rdd);\n\tif (err)\n\t\treturn err;\n\n\tlist_for_each_entry_safe(p, n, list, l_node) {\n\t\tif (strcmp(p->name, \".\") != 0 &&\n\t\t    strcmp(p->name, \"..\") != 0) {\n\t\t\terr = ovl_cache_update_ino(path, p);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (p->ino == p->real_ino) {\n\t\t\tlist_del(&p->l_node);\n\t\t\tkfree(p);\n\t\t} else {\n\t\t\tstruct rb_node **newp = &root->rb_node;\n\t\t\tstruct rb_node *parent = NULL;\n\n\t\t\tif (WARN_ON(ovl_cache_entry_find_link(p->name, p->len,\n\t\t\t\t\t\t\t      &newp, &parent)))\n\t\t\t\treturn -EIO;\n\n\t\t\trb_link_node(&p->node, parent, newp);\n\t\t\trb_insert_color(&p->node, root);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic struct ovl_dir_cache *ovl_cache_get_impure(const struct path *path)\n{\n\tint res;\n\tstruct dentry *dentry = path->dentry;\n\tstruct inode *inode = d_inode(dentry);\n\tstruct ovl_fs *ofs = OVL_FS(dentry->d_sb);\n\tstruct ovl_dir_cache *cache;\n\n\tcache = ovl_dir_cache(inode);\n\tif (cache && ovl_inode_version_get(inode) == cache->version)\n\t\treturn cache;\n\n\t \n\tovl_dir_cache_free(inode);\n\tovl_set_dir_cache(inode, NULL);\n\n\tcache = kzalloc(sizeof(struct ovl_dir_cache), GFP_KERNEL);\n\tif (!cache)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tres = ovl_dir_read_impure(path, &cache->entries, &cache->root);\n\tif (res) {\n\t\tovl_cache_free(&cache->entries);\n\t\tkfree(cache);\n\t\treturn ERR_PTR(res);\n\t}\n\tif (list_empty(&cache->entries)) {\n\t\t \n\t\tif (!ovl_want_write(dentry)) {\n\t\t\tovl_removexattr(ofs, ovl_dentry_upper(dentry),\n\t\t\t\t\tOVL_XATTR_IMPURE);\n\t\t\tovl_drop_write(dentry);\n\t\t}\n\t\tovl_clear_flag(OVL_IMPURE, inode);\n\t\tkfree(cache);\n\t\treturn NULL;\n\t}\n\n\tcache->version = ovl_inode_version_get(inode);\n\tovl_set_dir_cache(inode, cache);\n\n\treturn cache;\n}\n\nstruct ovl_readdir_translate {\n\tstruct dir_context *orig_ctx;\n\tstruct ovl_dir_cache *cache;\n\tstruct dir_context ctx;\n\tu64 parent_ino;\n\tint fsid;\n\tint xinobits;\n\tbool xinowarn;\n};\n\nstatic bool ovl_fill_real(struct dir_context *ctx, const char *name,\n\t\t\t   int namelen, loff_t offset, u64 ino,\n\t\t\t   unsigned int d_type)\n{\n\tstruct ovl_readdir_translate *rdt =\n\t\tcontainer_of(ctx, struct ovl_readdir_translate, ctx);\n\tstruct dir_context *orig_ctx = rdt->orig_ctx;\n\n\tif (rdt->parent_ino && strcmp(name, \"..\") == 0) {\n\t\tino = rdt->parent_ino;\n\t} else if (rdt->cache) {\n\t\tstruct ovl_cache_entry *p;\n\n\t\tp = ovl_cache_entry_find(&rdt->cache->root, name, namelen);\n\t\tif (p)\n\t\t\tino = p->ino;\n\t} else if (rdt->xinobits) {\n\t\tino = ovl_remap_lower_ino(ino, rdt->xinobits, rdt->fsid,\n\t\t\t\t\t  name, namelen, rdt->xinowarn);\n\t}\n\n\treturn orig_ctx->actor(orig_ctx, name, namelen, offset, ino, d_type);\n}\n\nstatic bool ovl_is_impure_dir(struct file *file)\n{\n\tstruct ovl_dir_file *od = file->private_data;\n\tstruct inode *dir = file_inode(file);\n\n\t \n\treturn od->is_upper && ovl_test_flag(OVL_IMPURE, dir);\n\n}\n\nstatic int ovl_iterate_real(struct file *file, struct dir_context *ctx)\n{\n\tint err;\n\tstruct ovl_dir_file *od = file->private_data;\n\tstruct dentry *dir = file->f_path.dentry;\n\tstruct ovl_fs *ofs = OVL_FS(dir->d_sb);\n\tconst struct ovl_layer *lower_layer = ovl_layer_lower(dir);\n\tstruct ovl_readdir_translate rdt = {\n\t\t.ctx.actor = ovl_fill_real,\n\t\t.orig_ctx = ctx,\n\t\t.xinobits = ovl_xino_bits(ofs),\n\t\t.xinowarn = ovl_xino_warn(ofs),\n\t};\n\n\tif (rdt.xinobits && lower_layer)\n\t\trdt.fsid = lower_layer->fsid;\n\n\tif (OVL_TYPE_MERGE(ovl_path_type(dir->d_parent))) {\n\t\tstruct kstat stat;\n\t\tstruct path statpath = file->f_path;\n\n\t\tstatpath.dentry = dir->d_parent;\n\t\terr = vfs_getattr(&statpath, &stat, STATX_INO, 0);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tWARN_ON_ONCE(dir->d_sb->s_dev != stat.dev);\n\t\trdt.parent_ino = stat.ino;\n\t}\n\n\tif (ovl_is_impure_dir(file)) {\n\t\trdt.cache = ovl_cache_get_impure(&file->f_path);\n\t\tif (IS_ERR(rdt.cache))\n\t\t\treturn PTR_ERR(rdt.cache);\n\t}\n\n\terr = iterate_dir(od->realfile, &rdt.ctx);\n\tctx->pos = rdt.ctx.pos;\n\n\treturn err;\n}\n\n\nstatic int ovl_iterate(struct file *file, struct dir_context *ctx)\n{\n\tstruct ovl_dir_file *od = file->private_data;\n\tstruct dentry *dentry = file->f_path.dentry;\n\tstruct ovl_fs *ofs = OVL_FS(dentry->d_sb);\n\tstruct ovl_cache_entry *p;\n\tconst struct cred *old_cred;\n\tint err;\n\n\told_cred = ovl_override_creds(dentry->d_sb);\n\tif (!ctx->pos)\n\t\tovl_dir_reset(file);\n\n\tif (od->is_real) {\n\t\t \n\t\tif (ovl_xino_bits(ofs) ||\n\t\t    (ovl_same_fs(ofs) &&\n\t\t     (ovl_is_impure_dir(file) ||\n\t\t      OVL_TYPE_MERGE(ovl_path_type(dentry->d_parent))))) {\n\t\t\terr = ovl_iterate_real(file, ctx);\n\t\t} else {\n\t\t\terr = iterate_dir(od->realfile, ctx);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tif (!od->cache) {\n\t\tstruct ovl_dir_cache *cache;\n\n\t\tcache = ovl_cache_get(dentry);\n\t\terr = PTR_ERR(cache);\n\t\tif (IS_ERR(cache))\n\t\t\tgoto out;\n\n\t\tod->cache = cache;\n\t\tovl_seek_cursor(od, ctx->pos);\n\t}\n\n\twhile (od->cursor != &od->cache->entries) {\n\t\tp = list_entry(od->cursor, struct ovl_cache_entry, l_node);\n\t\tif (!p->is_whiteout) {\n\t\t\tif (!p->ino) {\n\t\t\t\terr = ovl_cache_update_ino(&file->f_path, p);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (!p->is_whiteout) {\n\t\t\tif (!dir_emit(ctx, p->name, p->len, p->ino, p->type))\n\t\t\t\tbreak;\n\t\t}\n\t\tod->cursor = p->l_node.next;\n\t\tctx->pos++;\n\t}\n\terr = 0;\nout:\n\trevert_creds(old_cred);\n\treturn err;\n}\n\nstatic loff_t ovl_dir_llseek(struct file *file, loff_t offset, int origin)\n{\n\tloff_t res;\n\tstruct ovl_dir_file *od = file->private_data;\n\n\tinode_lock(file_inode(file));\n\tif (!file->f_pos)\n\t\tovl_dir_reset(file);\n\n\tif (od->is_real) {\n\t\tres = vfs_llseek(od->realfile, offset, origin);\n\t\tfile->f_pos = od->realfile->f_pos;\n\t} else {\n\t\tres = -EINVAL;\n\n\t\tswitch (origin) {\n\t\tcase SEEK_CUR:\n\t\t\toffset += file->f_pos;\n\t\t\tbreak;\n\t\tcase SEEK_SET:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tif (offset < 0)\n\t\t\tgoto out_unlock;\n\n\t\tif (offset != file->f_pos) {\n\t\t\tfile->f_pos = offset;\n\t\t\tif (od->cache)\n\t\t\t\tovl_seek_cursor(od, offset);\n\t\t}\n\t\tres = offset;\n\t}\nout_unlock:\n\tinode_unlock(file_inode(file));\n\n\treturn res;\n}\n\nstatic struct file *ovl_dir_open_realfile(const struct file *file,\n\t\t\t\t\t  const struct path *realpath)\n{\n\tstruct file *res;\n\tconst struct cred *old_cred;\n\n\told_cred = ovl_override_creds(file_inode(file)->i_sb);\n\tres = ovl_path_open(realpath, O_RDONLY | (file->f_flags & O_LARGEFILE));\n\trevert_creds(old_cred);\n\n\treturn res;\n}\n\n \nstruct file *ovl_dir_real_file(const struct file *file, bool want_upper)\n{\n\n\tstruct ovl_dir_file *od = file->private_data;\n\tstruct dentry *dentry = file->f_path.dentry;\n\tstruct file *old, *realfile = od->realfile;\n\n\tif (!OVL_TYPE_UPPER(ovl_path_type(dentry)))\n\t\treturn want_upper ? NULL : realfile;\n\n\t \n\tif (!od->is_upper) {\n\t\trealfile = READ_ONCE(od->upperfile);\n\t\tif (!realfile) {\n\t\t\tstruct path upperpath;\n\n\t\t\tovl_path_upper(dentry, &upperpath);\n\t\t\trealfile = ovl_dir_open_realfile(file, &upperpath);\n\t\t\tif (IS_ERR(realfile))\n\t\t\t\treturn realfile;\n\n\t\t\told = cmpxchg_release(&od->upperfile, NULL, realfile);\n\t\t\tif (old) {\n\t\t\t\tfput(realfile);\n\t\t\t\trealfile = old;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn realfile;\n}\n\nstatic int ovl_dir_fsync(struct file *file, loff_t start, loff_t end,\n\t\t\t int datasync)\n{\n\tstruct file *realfile;\n\tint err;\n\n\terr = ovl_sync_status(OVL_FS(file_inode(file)->i_sb));\n\tif (err <= 0)\n\t\treturn err;\n\n\trealfile = ovl_dir_real_file(file, true);\n\terr = PTR_ERR_OR_ZERO(realfile);\n\n\t \n\tif (!realfile || err)\n\t\treturn err;\n\n\treturn vfs_fsync_range(realfile, start, end, datasync);\n}\n\nstatic int ovl_dir_release(struct inode *inode, struct file *file)\n{\n\tstruct ovl_dir_file *od = file->private_data;\n\n\tif (od->cache) {\n\t\tinode_lock(inode);\n\t\tovl_cache_put(od, inode);\n\t\tinode_unlock(inode);\n\t}\n\tfput(od->realfile);\n\tif (od->upperfile)\n\t\tfput(od->upperfile);\n\tkfree(od);\n\n\treturn 0;\n}\n\nstatic int ovl_dir_open(struct inode *inode, struct file *file)\n{\n\tstruct path realpath;\n\tstruct file *realfile;\n\tstruct ovl_dir_file *od;\n\tenum ovl_path_type type;\n\n\tod = kzalloc(sizeof(struct ovl_dir_file), GFP_KERNEL);\n\tif (!od)\n\t\treturn -ENOMEM;\n\n\ttype = ovl_path_real(file->f_path.dentry, &realpath);\n\trealfile = ovl_dir_open_realfile(file, &realpath);\n\tif (IS_ERR(realfile)) {\n\t\tkfree(od);\n\t\treturn PTR_ERR(realfile);\n\t}\n\tod->realfile = realfile;\n\tod->is_real = ovl_dir_is_real(inode);\n\tod->is_upper = OVL_TYPE_UPPER(type);\n\tfile->private_data = od;\n\n\treturn 0;\n}\n\nWRAP_DIR_ITER(ovl_iterate)  \nconst struct file_operations ovl_dir_operations = {\n\t.read\t\t= generic_read_dir,\n\t.open\t\t= ovl_dir_open,\n\t.iterate_shared\t= shared_ovl_iterate,\n\t.llseek\t\t= ovl_dir_llseek,\n\t.fsync\t\t= ovl_dir_fsync,\n\t.release\t= ovl_dir_release,\n};\n\nint ovl_check_empty_dir(struct dentry *dentry, struct list_head *list)\n{\n\tint err;\n\tstruct ovl_cache_entry *p, *n;\n\tstruct rb_root root = RB_ROOT;\n\tconst struct cred *old_cred;\n\n\told_cred = ovl_override_creds(dentry->d_sb);\n\terr = ovl_dir_read_merged(dentry, list, &root);\n\trevert_creds(old_cred);\n\tif (err)\n\t\treturn err;\n\n\terr = 0;\n\n\tlist_for_each_entry_safe(p, n, list, l_node) {\n\t\t \n\t\tif (p->is_whiteout) {\n\t\t\tif (p->is_upper)\n\t\t\t\tcontinue;\n\t\t\tgoto del_entry;\n\t\t}\n\n\t\tif (p->name[0] == '.') {\n\t\t\tif (p->len == 1)\n\t\t\t\tgoto del_entry;\n\t\t\tif (p->len == 2 && p->name[1] == '.')\n\t\t\t\tgoto del_entry;\n\t\t}\n\t\terr = -ENOTEMPTY;\n\t\tbreak;\n\ndel_entry:\n\t\tlist_del(&p->l_node);\n\t\tkfree(p);\n\t}\n\n\treturn err;\n}\n\nvoid ovl_cleanup_whiteouts(struct ovl_fs *ofs, struct dentry *upper,\n\t\t\t   struct list_head *list)\n{\n\tstruct ovl_cache_entry *p;\n\n\tinode_lock_nested(upper->d_inode, I_MUTEX_CHILD);\n\tlist_for_each_entry(p, list, l_node) {\n\t\tstruct dentry *dentry;\n\n\t\tif (WARN_ON(!p->is_whiteout || !p->is_upper))\n\t\t\tcontinue;\n\n\t\tdentry = ovl_lookup_upper(ofs, p->name, upper, p->len);\n\t\tif (IS_ERR(dentry)) {\n\t\t\tpr_err(\"lookup '%s/%.*s' failed (%i)\\n\",\n\t\t\t       upper->d_name.name, p->len, p->name,\n\t\t\t       (int) PTR_ERR(dentry));\n\t\t\tcontinue;\n\t\t}\n\t\tif (dentry->d_inode)\n\t\t\tovl_cleanup(ofs, upper->d_inode, dentry);\n\t\tdput(dentry);\n\t}\n\tinode_unlock(upper->d_inode);\n}\n\nstatic bool ovl_check_d_type(struct dir_context *ctx, const char *name,\n\t\t\t  int namelen, loff_t offset, u64 ino,\n\t\t\t  unsigned int d_type)\n{\n\tstruct ovl_readdir_data *rdd =\n\t\tcontainer_of(ctx, struct ovl_readdir_data, ctx);\n\n\t \n\tif (!strncmp(name, \".\", namelen) || !strncmp(name, \"..\", namelen))\n\t\treturn true;\n\n\tif (d_type != DT_UNKNOWN)\n\t\trdd->d_type_supported = true;\n\n\treturn true;\n}\n\n \nint ovl_check_d_type_supported(const struct path *realpath)\n{\n\tint err;\n\tstruct ovl_readdir_data rdd = {\n\t\t.ctx.actor = ovl_check_d_type,\n\t\t.d_type_supported = false,\n\t};\n\n\terr = ovl_dir_read(realpath, &rdd);\n\tif (err)\n\t\treturn err;\n\n\treturn rdd.d_type_supported;\n}\n\n#define OVL_INCOMPATDIR_NAME \"incompat\"\n\nstatic int ovl_workdir_cleanup_recurse(struct ovl_fs *ofs, const struct path *path,\n\t\t\t\t       int level)\n{\n\tint err;\n\tstruct inode *dir = path->dentry->d_inode;\n\tLIST_HEAD(list);\n\tstruct ovl_cache_entry *p;\n\tstruct ovl_readdir_data rdd = {\n\t\t.ctx.actor = ovl_fill_plain,\n\t\t.list = &list,\n\t};\n\tbool incompat = false;\n\n\t \n\tif (level == 2 &&\n\t    !strcmp(path->dentry->d_name.name, OVL_INCOMPATDIR_NAME))\n\t\tincompat = true;\n\n\terr = ovl_dir_read(path, &rdd);\n\tif (err)\n\t\tgoto out;\n\n\tinode_lock_nested(dir, I_MUTEX_PARENT);\n\tlist_for_each_entry(p, &list, l_node) {\n\t\tstruct dentry *dentry;\n\n\t\tif (p->name[0] == '.') {\n\t\t\tif (p->len == 1)\n\t\t\t\tcontinue;\n\t\t\tif (p->len == 2 && p->name[1] == '.')\n\t\t\t\tcontinue;\n\t\t} else if (incompat) {\n\t\t\tpr_err(\"overlay with incompat feature '%s' cannot be mounted\\n\",\n\t\t\t\tp->name);\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tdentry = ovl_lookup_upper(ofs, p->name, path->dentry, p->len);\n\t\tif (IS_ERR(dentry))\n\t\t\tcontinue;\n\t\tif (dentry->d_inode)\n\t\t\terr = ovl_workdir_cleanup(ofs, dir, path->mnt, dentry, level);\n\t\tdput(dentry);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\tinode_unlock(dir);\nout:\n\tovl_cache_free(&list);\n\treturn err;\n}\n\nint ovl_workdir_cleanup(struct ovl_fs *ofs, struct inode *dir,\n\t\t\tstruct vfsmount *mnt, struct dentry *dentry, int level)\n{\n\tint err;\n\n\tif (!d_is_dir(dentry) || level > 1) {\n\t\treturn ovl_cleanup(ofs, dir, dentry);\n\t}\n\n\terr = ovl_do_rmdir(ofs, dir, dentry);\n\tif (err) {\n\t\tstruct path path = { .mnt = mnt, .dentry = dentry };\n\n\t\tinode_unlock(dir);\n\t\terr = ovl_workdir_cleanup_recurse(ofs, &path, level + 1);\n\t\tinode_lock_nested(dir, I_MUTEX_PARENT);\n\t\tif (!err)\n\t\t\terr = ovl_cleanup(ofs, dir, dentry);\n\t}\n\n\treturn err;\n}\n\nint ovl_indexdir_cleanup(struct ovl_fs *ofs)\n{\n\tint err;\n\tstruct dentry *indexdir = ofs->indexdir;\n\tstruct dentry *index = NULL;\n\tstruct inode *dir = indexdir->d_inode;\n\tstruct path path = { .mnt = ovl_upper_mnt(ofs), .dentry = indexdir };\n\tLIST_HEAD(list);\n\tstruct ovl_cache_entry *p;\n\tstruct ovl_readdir_data rdd = {\n\t\t.ctx.actor = ovl_fill_plain,\n\t\t.list = &list,\n\t};\n\n\terr = ovl_dir_read(&path, &rdd);\n\tif (err)\n\t\tgoto out;\n\n\tinode_lock_nested(dir, I_MUTEX_PARENT);\n\tlist_for_each_entry(p, &list, l_node) {\n\t\tif (p->name[0] == '.') {\n\t\t\tif (p->len == 1)\n\t\t\t\tcontinue;\n\t\t\tif (p->len == 2 && p->name[1] == '.')\n\t\t\t\tcontinue;\n\t\t}\n\t\tindex = ovl_lookup_upper(ofs, p->name, indexdir, p->len);\n\t\tif (IS_ERR(index)) {\n\t\t\terr = PTR_ERR(index);\n\t\t\tindex = NULL;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tif (index->d_name.name[0] == '#') {\n\t\t\terr = ovl_workdir_cleanup(ofs, dir, path.mnt, index, 1);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tgoto next;\n\t\t}\n\t\terr = ovl_verify_index(ofs, index);\n\t\tif (!err) {\n\t\t\tgoto next;\n\t\t} else if (err == -ESTALE) {\n\t\t\t \n\t\t\terr = ovl_cleanup(ofs, dir, index);\n\t\t} else if (err != -ENOENT) {\n\t\t\t \n\t\t\tbreak;\n\t\t} else if (ofs->config.nfs_export) {\n\t\t\t \n\t\t\terr = ovl_cleanup_and_whiteout(ofs, dir, index);\n\t\t} else {\n\t\t\t \n\t\t\terr = ovl_cleanup(ofs, dir, index);\n\t\t}\n\n\t\tif (err)\n\t\t\tbreak;\n\nnext:\n\t\tdput(index);\n\t\tindex = NULL;\n\t}\n\tdput(index);\n\tinode_unlock(dir);\nout:\n\tovl_cache_free(&list);\n\tif (err)\n\t\tpr_err(\"failed index dir cleanup (%i)\\n\", err);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}