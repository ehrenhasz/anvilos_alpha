{
  "module_name": "overlayfs.h",
  "hash_id": "798d253789cf636957636f0cbc73e8fff5545dc106722f4ebd6737639a2dc5c5",
  "original_prompt": "Ingested from linux-6.6.14/fs/overlayfs/overlayfs.h",
  "human_readable_source": " \n \n\n#include <linux/kernel.h>\n#include <linux/uuid.h>\n#include <linux/fs.h>\n#include <linux/fsverity.h>\n#include <linux/namei.h>\n#include <linux/posix_acl.h>\n#include <linux/posix_acl_xattr.h>\n#include \"ovl_entry.h\"\n\n#undef pr_fmt\n#define pr_fmt(fmt) \"overlayfs: \" fmt\n\nenum ovl_path_type {\n\t__OVL_PATH_UPPER\t= (1 << 0),\n\t__OVL_PATH_MERGE\t= (1 << 1),\n\t__OVL_PATH_ORIGIN\t= (1 << 2),\n};\n\n#define OVL_TYPE_UPPER(type)\t((type) & __OVL_PATH_UPPER)\n#define OVL_TYPE_MERGE(type)\t((type) & __OVL_PATH_MERGE)\n#define OVL_TYPE_ORIGIN(type)\t((type) & __OVL_PATH_ORIGIN)\n\n#define OVL_XATTR_NAMESPACE \"overlay.\"\n#define OVL_XATTR_TRUSTED_PREFIX XATTR_TRUSTED_PREFIX OVL_XATTR_NAMESPACE\n#define OVL_XATTR_USER_PREFIX XATTR_USER_PREFIX OVL_XATTR_NAMESPACE\n\nenum ovl_xattr {\n\tOVL_XATTR_OPAQUE,\n\tOVL_XATTR_REDIRECT,\n\tOVL_XATTR_ORIGIN,\n\tOVL_XATTR_IMPURE,\n\tOVL_XATTR_NLINK,\n\tOVL_XATTR_UPPER,\n\tOVL_XATTR_UUID,\n\tOVL_XATTR_METACOPY,\n\tOVL_XATTR_PROTATTR,\n};\n\nenum ovl_inode_flag {\n\t \n\tOVL_IMPURE,\n\t \n\tOVL_WHITEOUTS,\n\tOVL_INDEX,\n\tOVL_UPPERDATA,\n\t \n\tOVL_CONST_INO,\n\tOVL_HAS_DIGEST,\n\tOVL_VERIFIED_DIGEST,\n};\n\nenum ovl_entry_flag {\n\tOVL_E_UPPER_ALIAS,\n\tOVL_E_OPAQUE,\n\tOVL_E_CONNECTED,\n};\n\nenum {\n\tOVL_REDIRECT_OFF,\t \n\tOVL_REDIRECT_FOLLOW,\t \n\tOVL_REDIRECT_NOFOLLOW,\t \n\tOVL_REDIRECT_ON,\n};\n\nenum {\n\tOVL_UUID_OFF,\n\tOVL_UUID_NULL,\n\tOVL_UUID_AUTO,\n\tOVL_UUID_ON,\n};\n\nenum {\n\tOVL_XINO_OFF,\n\tOVL_XINO_AUTO,\n\tOVL_XINO_ON,\n};\n\nenum {\n\tOVL_VERITY_OFF,\n\tOVL_VERITY_ON,\n\tOVL_VERITY_REQUIRE,\n};\n\n \n#define OVL_FH_VERSION\t0\n#define OVL_FH_MAGIC\t0xfb\n\n \n#define OVL_FH_FLAG_BIG_ENDIAN\t(1 << 0)\n#define OVL_FH_FLAG_ANY_ENDIAN\t(1 << 1)\n \n#define OVL_FH_FLAG_PATH_UPPER\t(1 << 2)\n\n#define OVL_FH_FLAG_ALL (OVL_FH_FLAG_BIG_ENDIAN | OVL_FH_FLAG_ANY_ENDIAN | \\\n\t\t\t OVL_FH_FLAG_PATH_UPPER)\n\n#if defined(__LITTLE_ENDIAN)\n#define OVL_FH_FLAG_CPU_ENDIAN 0\n#elif defined(__BIG_ENDIAN)\n#define OVL_FH_FLAG_CPU_ENDIAN OVL_FH_FLAG_BIG_ENDIAN\n#else\n#error Endianness not defined\n#endif\n\n \n#define OVL_FILEID_V0\t0xfb\n \n#define OVL_FILEID_V1\t0xf8\n\n \nstruct ovl_fb {\n\tu8 version;\t \n\tu8 magic;\t \n\tu8 len;\t\t \n\tu8 flags;\t \n\tu8 type;\t \n\tuuid_t uuid;\t \n\tu32 fid[];\t \n} __packed;\n\n \nstruct ovl_fh {\n\tu8 padding[3];\t \n\tunion {\n\t\tstruct ovl_fb fb;\n\t\tDECLARE_FLEX_ARRAY(u8, buf);\n\t};\n} __packed;\n\n#define OVL_FH_WIRE_OFFSET\toffsetof(struct ovl_fh, fb)\n#define OVL_FH_LEN(fh)\t\t(OVL_FH_WIRE_OFFSET + (fh)->fb.len)\n#define OVL_FH_FID_OFFSET\t(OVL_FH_WIRE_OFFSET + \\\n\t\t\t\t offsetof(struct ovl_fb, fid))\n\n \nstruct ovl_metacopy {\n\tu8 version;\t \n\tu8 len;          \n\tu8 flags;\n\tu8 digest_algo;\t \n\tu8 digest[FS_VERITY_MAX_DIGEST_SIZE];   \n} __packed;\n\n#define OVL_METACOPY_MAX_SIZE (sizeof(struct ovl_metacopy))\n#define OVL_METACOPY_MIN_SIZE (OVL_METACOPY_MAX_SIZE - FS_VERITY_MAX_DIGEST_SIZE)\n#define OVL_METACOPY_INIT { 0, OVL_METACOPY_MIN_SIZE }\n\nstatic inline int ovl_metadata_digest_size(const struct ovl_metacopy *metacopy)\n{\n\tif (metacopy->len < OVL_METACOPY_MIN_SIZE)\n\t\treturn 0;\n\treturn (int)metacopy->len - OVL_METACOPY_MIN_SIZE;\n}\n\nextern const char *const ovl_xattr_table[][2];\nstatic inline const char *ovl_xattr(struct ovl_fs *ofs, enum ovl_xattr ox)\n{\n\treturn ovl_xattr_table[ox][ofs->config.userxattr];\n}\n\n \nstatic inline int ovl_do_notify_change(struct ovl_fs *ofs,\n\t\t\t\t       struct dentry *upperdentry,\n\t\t\t\t       struct iattr *attr)\n{\n\treturn notify_change(ovl_upper_mnt_idmap(ofs), upperdentry, attr, NULL);\n}\n\nstatic inline int ovl_do_rmdir(struct ovl_fs *ofs,\n\t\t\t       struct inode *dir, struct dentry *dentry)\n{\n\tint err = vfs_rmdir(ovl_upper_mnt_idmap(ofs), dir, dentry);\n\n\tpr_debug(\"rmdir(%pd2) = %i\\n\", dentry, err);\n\treturn err;\n}\n\nstatic inline int ovl_do_unlink(struct ovl_fs *ofs, struct inode *dir,\n\t\t\t\tstruct dentry *dentry)\n{\n\tint err = vfs_unlink(ovl_upper_mnt_idmap(ofs), dir, dentry, NULL);\n\n\tpr_debug(\"unlink(%pd2) = %i\\n\", dentry, err);\n\treturn err;\n}\n\nstatic inline int ovl_do_link(struct ovl_fs *ofs, struct dentry *old_dentry,\n\t\t\t      struct inode *dir, struct dentry *new_dentry)\n{\n\tint err = vfs_link(old_dentry, ovl_upper_mnt_idmap(ofs), dir,\n\t\t\t   new_dentry, NULL);\n\n\tpr_debug(\"link(%pd2, %pd2) = %i\\n\", old_dentry, new_dentry, err);\n\treturn err;\n}\n\nstatic inline int ovl_do_create(struct ovl_fs *ofs,\n\t\t\t\tstruct inode *dir, struct dentry *dentry,\n\t\t\t\tumode_t mode)\n{\n\tint err = vfs_create(ovl_upper_mnt_idmap(ofs), dir, dentry, mode, true);\n\n\tpr_debug(\"create(%pd2, 0%o) = %i\\n\", dentry, mode, err);\n\treturn err;\n}\n\nstatic inline int ovl_do_mkdir(struct ovl_fs *ofs,\n\t\t\t       struct inode *dir, struct dentry *dentry,\n\t\t\t       umode_t mode)\n{\n\tint err = vfs_mkdir(ovl_upper_mnt_idmap(ofs), dir, dentry, mode);\n\tpr_debug(\"mkdir(%pd2, 0%o) = %i\\n\", dentry, mode, err);\n\treturn err;\n}\n\nstatic inline int ovl_do_mknod(struct ovl_fs *ofs,\n\t\t\t       struct inode *dir, struct dentry *dentry,\n\t\t\t       umode_t mode, dev_t dev)\n{\n\tint err = vfs_mknod(ovl_upper_mnt_idmap(ofs), dir, dentry, mode, dev);\n\n\tpr_debug(\"mknod(%pd2, 0%o, 0%o) = %i\\n\", dentry, mode, dev, err);\n\treturn err;\n}\n\nstatic inline int ovl_do_symlink(struct ovl_fs *ofs,\n\t\t\t\t struct inode *dir, struct dentry *dentry,\n\t\t\t\t const char *oldname)\n{\n\tint err = vfs_symlink(ovl_upper_mnt_idmap(ofs), dir, dentry, oldname);\n\n\tpr_debug(\"symlink(\\\"%s\\\", %pd2) = %i\\n\", oldname, dentry, err);\n\treturn err;\n}\n\nstatic inline ssize_t ovl_do_getxattr(const struct path *path, const char *name,\n\t\t\t\t      void *value, size_t size)\n{\n\tint err, len;\n\n\tWARN_ON(path->dentry->d_sb != path->mnt->mnt_sb);\n\n\terr = vfs_getxattr(mnt_idmap(path->mnt), path->dentry,\n\t\t\t       name, value, size);\n\tlen = (value && err > 0) ? err : 0;\n\n\tpr_debug(\"getxattr(%pd2, \\\"%s\\\", \\\"%*pE\\\", %zu, 0) = %i\\n\",\n\t\t path->dentry, name, min(len, 48), value, size, err);\n\treturn err;\n}\n\nstatic inline ssize_t ovl_getxattr_upper(struct ovl_fs *ofs,\n\t\t\t\t\t struct dentry *upperdentry,\n\t\t\t\t\t enum ovl_xattr ox, void *value,\n\t\t\t\t\t size_t size)\n{\n\tstruct path upperpath = {\n\t\t.dentry = upperdentry,\n\t\t.mnt = ovl_upper_mnt(ofs),\n\t};\n\n\treturn ovl_do_getxattr(&upperpath, ovl_xattr(ofs, ox), value, size);\n}\n\nstatic inline ssize_t ovl_path_getxattr(struct ovl_fs *ofs,\n\t\t\t\t\t const struct path *path,\n\t\t\t\t\t enum ovl_xattr ox, void *value,\n\t\t\t\t\t size_t size)\n{\n\treturn ovl_do_getxattr(path, ovl_xattr(ofs, ox), value, size);\n}\n\nstatic inline int ovl_do_setxattr(struct ovl_fs *ofs, struct dentry *dentry,\n\t\t\t\t  const char *name, const void *value,\n\t\t\t\t  size_t size, int flags)\n{\n\tint err = vfs_setxattr(ovl_upper_mnt_idmap(ofs), dentry, name,\n\t\t\t       value, size, flags);\n\n\tpr_debug(\"setxattr(%pd2, \\\"%s\\\", \\\"%*pE\\\", %zu, %d) = %i\\n\",\n\t\t dentry, name, min((int)size, 48), value, size, flags, err);\n\treturn err;\n}\n\nstatic inline int ovl_setxattr(struct ovl_fs *ofs, struct dentry *dentry,\n\t\t\t       enum ovl_xattr ox, const void *value,\n\t\t\t       size_t size)\n{\n\treturn ovl_do_setxattr(ofs, dentry, ovl_xattr(ofs, ox), value, size, 0);\n}\n\nstatic inline int ovl_do_removexattr(struct ovl_fs *ofs, struct dentry *dentry,\n\t\t\t\t     const char *name)\n{\n\tint err = vfs_removexattr(ovl_upper_mnt_idmap(ofs), dentry, name);\n\tpr_debug(\"removexattr(%pd2, \\\"%s\\\") = %i\\n\", dentry, name, err);\n\treturn err;\n}\n\nstatic inline int ovl_removexattr(struct ovl_fs *ofs, struct dentry *dentry,\n\t\t\t\t  enum ovl_xattr ox)\n{\n\treturn ovl_do_removexattr(ofs, dentry, ovl_xattr(ofs, ox));\n}\n\nstatic inline int ovl_do_set_acl(struct ovl_fs *ofs, struct dentry *dentry,\n\t\t\t\t const char *acl_name, struct posix_acl *acl)\n{\n\treturn vfs_set_acl(ovl_upper_mnt_idmap(ofs), dentry, acl_name, acl);\n}\n\nstatic inline int ovl_do_remove_acl(struct ovl_fs *ofs, struct dentry *dentry,\n\t\t\t\t    const char *acl_name)\n{\n\treturn vfs_remove_acl(ovl_upper_mnt_idmap(ofs), dentry, acl_name);\n}\n\nstatic inline int ovl_do_rename(struct ovl_fs *ofs, struct inode *olddir,\n\t\t\t\tstruct dentry *olddentry, struct inode *newdir,\n\t\t\t\tstruct dentry *newdentry, unsigned int flags)\n{\n\tint err;\n\tstruct renamedata rd = {\n\t\t.old_mnt_idmap\t= ovl_upper_mnt_idmap(ofs),\n\t\t.old_dir \t= olddir,\n\t\t.old_dentry \t= olddentry,\n\t\t.new_mnt_idmap\t= ovl_upper_mnt_idmap(ofs),\n\t\t.new_dir \t= newdir,\n\t\t.new_dentry \t= newdentry,\n\t\t.flags \t\t= flags,\n\t};\n\n\tpr_debug(\"rename(%pd2, %pd2, 0x%x)\\n\", olddentry, newdentry, flags);\n\terr = vfs_rename(&rd);\n\tif (err) {\n\t\tpr_debug(\"...rename(%pd2, %pd2, ...) = %i\\n\",\n\t\t\t olddentry, newdentry, err);\n\t}\n\treturn err;\n}\n\nstatic inline int ovl_do_whiteout(struct ovl_fs *ofs,\n\t\t\t\t  struct inode *dir, struct dentry *dentry)\n{\n\tint err = vfs_whiteout(ovl_upper_mnt_idmap(ofs), dir, dentry);\n\tpr_debug(\"whiteout(%pd2) = %i\\n\", dentry, err);\n\treturn err;\n}\n\nstatic inline struct file *ovl_do_tmpfile(struct ovl_fs *ofs,\n\t\t\t\t\t  struct dentry *dentry, umode_t mode)\n{\n\tstruct path path = { .mnt = ovl_upper_mnt(ofs), .dentry = dentry };\n\tstruct file *file = kernel_tmpfile_open(ovl_upper_mnt_idmap(ofs), &path,\n\t\t\t\t\t\tmode, O_LARGEFILE | O_WRONLY,\n\t\t\t\t\t\tcurrent_cred());\n\tint err = PTR_ERR_OR_ZERO(file);\n\n\tpr_debug(\"tmpfile(%pd2, 0%o) = %i\\n\", dentry, mode, err);\n\treturn file;\n}\n\nstatic inline struct dentry *ovl_lookup_upper(struct ovl_fs *ofs,\n\t\t\t\t\t      const char *name,\n\t\t\t\t\t      struct dentry *base, int len)\n{\n\treturn lookup_one(ovl_upper_mnt_idmap(ofs), name, base, len);\n}\n\nstatic inline bool ovl_open_flags_need_copy_up(int flags)\n{\n\tif (!flags)\n\t\treturn false;\n\n\treturn ((OPEN_FMODE(flags) & FMODE_WRITE) || (flags & O_TRUNC));\n}\n\nstatic inline int ovl_do_getattr(const struct path *path, struct kstat *stat,\n\t\t\t\t u32 request_mask, unsigned int flags)\n{\n\tif (flags & AT_GETATTR_NOSEC)\n\t\treturn vfs_getattr_nosec(path, stat, request_mask, flags);\n\treturn vfs_getattr(path, stat, request_mask, flags);\n}\n\n \nint ovl_want_write(struct dentry *dentry);\nvoid ovl_drop_write(struct dentry *dentry);\nstruct dentry *ovl_workdir(struct dentry *dentry);\nconst struct cred *ovl_override_creds(struct super_block *sb);\nint ovl_can_decode_fh(struct super_block *sb);\nstruct dentry *ovl_indexdir(struct super_block *sb);\nbool ovl_index_all(struct super_block *sb);\nbool ovl_verify_lower(struct super_block *sb);\nstruct ovl_path *ovl_stack_alloc(unsigned int n);\nvoid ovl_stack_cpy(struct ovl_path *dst, struct ovl_path *src, unsigned int n);\nvoid ovl_stack_put(struct ovl_path *stack, unsigned int n);\nvoid ovl_stack_free(struct ovl_path *stack, unsigned int n);\nstruct ovl_entry *ovl_alloc_entry(unsigned int numlower);\nvoid ovl_free_entry(struct ovl_entry *oe);\nbool ovl_dentry_remote(struct dentry *dentry);\nvoid ovl_dentry_update_reval(struct dentry *dentry, struct dentry *realdentry);\nvoid ovl_dentry_init_reval(struct dentry *dentry, struct dentry *upperdentry,\n\t\t\t   struct ovl_entry *oe);\nvoid ovl_dentry_init_flags(struct dentry *dentry, struct dentry *upperdentry,\n\t\t\t   struct ovl_entry *oe, unsigned int mask);\nbool ovl_dentry_weird(struct dentry *dentry);\nenum ovl_path_type ovl_path_type(struct dentry *dentry);\nvoid ovl_path_upper(struct dentry *dentry, struct path *path);\nvoid ovl_path_lower(struct dentry *dentry, struct path *path);\nvoid ovl_path_lowerdata(struct dentry *dentry, struct path *path);\nstruct inode *ovl_i_path_real(struct inode *inode, struct path *path);\nenum ovl_path_type ovl_path_real(struct dentry *dentry, struct path *path);\nenum ovl_path_type ovl_path_realdata(struct dentry *dentry, struct path *path);\nstruct dentry *ovl_dentry_upper(struct dentry *dentry);\nstruct dentry *ovl_dentry_lower(struct dentry *dentry);\nstruct dentry *ovl_dentry_lowerdata(struct dentry *dentry);\nint ovl_dentry_set_lowerdata(struct dentry *dentry, struct ovl_path *datapath);\nconst struct ovl_layer *ovl_i_layer_lower(struct inode *inode);\nconst struct ovl_layer *ovl_layer_lower(struct dentry *dentry);\nstruct dentry *ovl_dentry_real(struct dentry *dentry);\nstruct dentry *ovl_i_dentry_upper(struct inode *inode);\nstruct inode *ovl_inode_upper(struct inode *inode);\nstruct inode *ovl_inode_lower(struct inode *inode);\nstruct inode *ovl_inode_lowerdata(struct inode *inode);\nstruct inode *ovl_inode_real(struct inode *inode);\nstruct inode *ovl_inode_realdata(struct inode *inode);\nconst char *ovl_lowerdata_redirect(struct inode *inode);\nstruct ovl_dir_cache *ovl_dir_cache(struct inode *inode);\nvoid ovl_set_dir_cache(struct inode *inode, struct ovl_dir_cache *cache);\nvoid ovl_dentry_set_flag(unsigned long flag, struct dentry *dentry);\nvoid ovl_dentry_clear_flag(unsigned long flag, struct dentry *dentry);\nbool ovl_dentry_test_flag(unsigned long flag, struct dentry *dentry);\nbool ovl_dentry_is_opaque(struct dentry *dentry);\nbool ovl_dentry_is_whiteout(struct dentry *dentry);\nvoid ovl_dentry_set_opaque(struct dentry *dentry);\nbool ovl_dentry_has_upper_alias(struct dentry *dentry);\nvoid ovl_dentry_set_upper_alias(struct dentry *dentry);\nbool ovl_dentry_needs_data_copy_up(struct dentry *dentry, int flags);\nbool ovl_dentry_needs_data_copy_up_locked(struct dentry *dentry, int flags);\nbool ovl_has_upperdata(struct inode *inode);\nvoid ovl_set_upperdata(struct inode *inode);\nconst char *ovl_dentry_get_redirect(struct dentry *dentry);\nvoid ovl_dentry_set_redirect(struct dentry *dentry, const char *redirect);\nvoid ovl_inode_update(struct inode *inode, struct dentry *upperdentry);\nvoid ovl_dir_modified(struct dentry *dentry, bool impurity);\nu64 ovl_inode_version_get(struct inode *inode);\nbool ovl_is_whiteout(struct dentry *dentry);\nstruct file *ovl_path_open(const struct path *path, int flags);\nint ovl_copy_up_start(struct dentry *dentry, int flags);\nvoid ovl_copy_up_end(struct dentry *dentry);\nbool ovl_already_copied_up(struct dentry *dentry, int flags);\nbool ovl_path_check_dir_xattr(struct ovl_fs *ofs, const struct path *path,\n\t\t\t      enum ovl_xattr ox);\nbool ovl_path_check_origin_xattr(struct ovl_fs *ofs, const struct path *path);\nbool ovl_init_uuid_xattr(struct super_block *sb, struct ovl_fs *ofs,\n\t\t\t const struct path *upperpath);\n\nstatic inline bool ovl_check_origin_xattr(struct ovl_fs *ofs,\n\t\t\t\t\t  struct dentry *upperdentry)\n{\n\tstruct path upperpath = {\n\t\t.dentry = upperdentry,\n\t\t.mnt = ovl_upper_mnt(ofs),\n\t};\n\treturn ovl_path_check_origin_xattr(ofs, &upperpath);\n}\n\nint ovl_check_setxattr(struct ovl_fs *ofs, struct dentry *upperdentry,\n\t\t       enum ovl_xattr ox, const void *value, size_t size,\n\t\t       int xerr);\nint ovl_set_impure(struct dentry *dentry, struct dentry *upperdentry);\nbool ovl_inuse_trylock(struct dentry *dentry);\nvoid ovl_inuse_unlock(struct dentry *dentry);\nbool ovl_is_inuse(struct dentry *dentry);\nbool ovl_need_index(struct dentry *dentry);\nint ovl_nlink_start(struct dentry *dentry);\nvoid ovl_nlink_end(struct dentry *dentry);\nint ovl_lock_rename_workdir(struct dentry *workdir, struct dentry *upperdir);\nint ovl_check_metacopy_xattr(struct ovl_fs *ofs, const struct path *path,\n\t\t\t     struct ovl_metacopy *data);\nint ovl_set_metacopy_xattr(struct ovl_fs *ofs, struct dentry *d,\n\t\t\t   struct ovl_metacopy *metacopy);\nbool ovl_is_metacopy_dentry(struct dentry *dentry);\nchar *ovl_get_redirect_xattr(struct ovl_fs *ofs, const struct path *path, int padding);\nint ovl_ensure_verity_loaded(struct path *path);\nint ovl_get_verity_xattr(struct ovl_fs *ofs, const struct path *path,\n\t\t\t u8 *digest_buf, int *buf_length);\nint ovl_validate_verity(struct ovl_fs *ofs,\n\t\t\tstruct path *metapath,\n\t\t\tstruct path *datapath);\nint ovl_get_verity_digest(struct ovl_fs *ofs, struct path *src,\n\t\t\t  struct ovl_metacopy *metacopy);\nint ovl_sync_status(struct ovl_fs *ofs);\n\nstatic inline void ovl_set_flag(unsigned long flag, struct inode *inode)\n{\n\tset_bit(flag, &OVL_I(inode)->flags);\n}\n\nstatic inline void ovl_clear_flag(unsigned long flag, struct inode *inode)\n{\n\tclear_bit(flag, &OVL_I(inode)->flags);\n}\n\nstatic inline bool ovl_test_flag(unsigned long flag, struct inode *inode)\n{\n\treturn test_bit(flag, &OVL_I(inode)->flags);\n}\n\nstatic inline bool ovl_is_impuredir(struct super_block *sb,\n\t\t\t\t    struct dentry *upperdentry)\n{\n\tstruct ovl_fs *ofs = OVL_FS(sb);\n\tstruct path upperpath = {\n\t\t.dentry = upperdentry,\n\t\t.mnt = ovl_upper_mnt(ofs),\n\t};\n\n\treturn ovl_path_check_dir_xattr(ofs, &upperpath, OVL_XATTR_IMPURE);\n}\n\nstatic inline bool ovl_redirect_follow(struct ovl_fs *ofs)\n{\n\treturn ofs->config.redirect_mode != OVL_REDIRECT_NOFOLLOW;\n}\n\nstatic inline bool ovl_redirect_dir(struct ovl_fs *ofs)\n{\n\treturn ofs->config.redirect_mode == OVL_REDIRECT_ON;\n}\n\nstatic inline bool ovl_origin_uuid(struct ovl_fs *ofs)\n{\n\treturn ofs->config.uuid != OVL_UUID_OFF;\n}\n\nstatic inline bool ovl_has_fsid(struct ovl_fs *ofs)\n{\n\treturn ofs->config.uuid == OVL_UUID_ON ||\n\t       ofs->config.uuid == OVL_UUID_AUTO;\n}\n\n \nstatic inline bool ovl_xino_warn(struct ovl_fs *ofs)\n{\n\treturn ofs->config.xino == OVL_XINO_ON;\n}\n\n \nstatic inline bool ovl_allow_offline_changes(struct ovl_fs *ofs)\n{\n\treturn (!ofs->config.index && !ofs->config.metacopy &&\n\t\t!ovl_redirect_dir(ofs) && !ovl_xino_warn(ofs));\n}\n\n \nstatic inline bool ovl_same_fs(struct ovl_fs *ofs)\n{\n\treturn ofs->xino_mode == 0;\n}\n\n \nstatic inline bool ovl_same_dev(struct ovl_fs *ofs)\n{\n\treturn ofs->xino_mode >= 0;\n}\n\nstatic inline unsigned int ovl_xino_bits(struct ovl_fs *ofs)\n{\n\treturn ovl_same_dev(ofs) ? ofs->xino_mode : 0;\n}\n\nstatic inline void ovl_inode_lock(struct inode *inode)\n{\n\tmutex_lock(&OVL_I(inode)->lock);\n}\n\nstatic inline int ovl_inode_lock_interruptible(struct inode *inode)\n{\n\treturn mutex_lock_interruptible(&OVL_I(inode)->lock);\n}\n\nstatic inline void ovl_inode_unlock(struct inode *inode)\n{\n\tmutex_unlock(&OVL_I(inode)->lock);\n}\n\n\n \nint ovl_check_fb_len(struct ovl_fb *fb, int fb_len);\n\nstatic inline int ovl_check_fh_len(struct ovl_fh *fh, int fh_len)\n{\n\tif (fh_len < sizeof(struct ovl_fh))\n\t\treturn -EINVAL;\n\n\treturn ovl_check_fb_len(&fh->fb, fh_len - OVL_FH_WIRE_OFFSET);\n}\n\nstruct dentry *ovl_decode_real_fh(struct ovl_fs *ofs, struct ovl_fh *fh,\n\t\t\t\t  struct vfsmount *mnt, bool connected);\nint ovl_check_origin_fh(struct ovl_fs *ofs, struct ovl_fh *fh, bool connected,\n\t\t\tstruct dentry *upperdentry, struct ovl_path **stackp);\nint ovl_verify_set_fh(struct ovl_fs *ofs, struct dentry *dentry,\n\t\t      enum ovl_xattr ox, struct dentry *real, bool is_upper,\n\t\t      bool set);\nstruct dentry *ovl_index_upper(struct ovl_fs *ofs, struct dentry *index,\n\t\t\t       bool connected);\nint ovl_verify_index(struct ovl_fs *ofs, struct dentry *index);\nint ovl_get_index_name(struct ovl_fs *ofs, struct dentry *origin,\n\t\t       struct qstr *name);\nstruct dentry *ovl_get_index_fh(struct ovl_fs *ofs, struct ovl_fh *fh);\nstruct dentry *ovl_lookup_index(struct ovl_fs *ofs, struct dentry *upper,\n\t\t\t\tstruct dentry *origin, bool verify);\nint ovl_path_next(int idx, struct dentry *dentry, struct path *path);\nint ovl_verify_lowerdata(struct dentry *dentry);\nstruct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t  unsigned int flags);\nbool ovl_lower_positive(struct dentry *dentry);\n\nstatic inline int ovl_verify_origin(struct ovl_fs *ofs, struct dentry *upper,\n\t\t\t\t    struct dentry *origin, bool set)\n{\n\treturn ovl_verify_set_fh(ofs, upper, OVL_XATTR_ORIGIN, origin,\n\t\t\t\t false, set);\n}\n\nstatic inline int ovl_verify_upper(struct ovl_fs *ofs, struct dentry *index,\n\t\t\t\t   struct dentry *upper, bool set)\n{\n\treturn ovl_verify_set_fh(ofs, index, OVL_XATTR_UPPER, upper, true, set);\n}\n\n \nextern const struct file_operations ovl_dir_operations;\nstruct file *ovl_dir_real_file(const struct file *file, bool want_upper);\nint ovl_check_empty_dir(struct dentry *dentry, struct list_head *list);\nvoid ovl_cleanup_whiteouts(struct ovl_fs *ofs, struct dentry *upper,\n\t\t\t   struct list_head *list);\nvoid ovl_cache_free(struct list_head *list);\nvoid ovl_dir_cache_free(struct inode *inode);\nint ovl_check_d_type_supported(const struct path *realpath);\nint ovl_workdir_cleanup(struct ovl_fs *ofs, struct inode *dir,\n\t\t\tstruct vfsmount *mnt, struct dentry *dentry, int level);\nint ovl_indexdir_cleanup(struct ovl_fs *ofs);\n\n \nstatic inline bool ovl_dir_is_real(struct inode *dir)\n{\n\treturn !ovl_test_flag(OVL_WHITEOUTS, dir);\n}\n\n \nint ovl_set_nlink_upper(struct dentry *dentry);\nint ovl_set_nlink_lower(struct dentry *dentry);\nunsigned int ovl_get_nlink(struct ovl_fs *ofs, struct dentry *lowerdentry,\n\t\t\t   struct dentry *upperdentry,\n\t\t\t   unsigned int fallback);\nint ovl_setattr(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\tstruct iattr *attr);\nint ovl_getattr(struct mnt_idmap *idmap, const struct path *path,\n\t\tstruct kstat *stat, u32 request_mask, unsigned int flags);\nint ovl_permission(struct mnt_idmap *idmap, struct inode *inode,\n\t\t   int mask);\nint ovl_xattr_set(struct dentry *dentry, struct inode *inode, const char *name,\n\t\t  const void *value, size_t size, int flags);\nint ovl_xattr_get(struct dentry *dentry, struct inode *inode, const char *name,\n\t\t  void *value, size_t size);\nssize_t ovl_listxattr(struct dentry *dentry, char *list, size_t size);\n\n#ifdef CONFIG_FS_POSIX_ACL\nstruct posix_acl *do_ovl_get_acl(struct mnt_idmap *idmap,\n\t\t\t\t struct inode *inode, int type,\n\t\t\t\t bool rcu, bool noperm);\nstatic inline struct posix_acl *ovl_get_inode_acl(struct inode *inode, int type,\n\t\t\t\t\t\t  bool rcu)\n{\n\treturn do_ovl_get_acl(&nop_mnt_idmap, inode, type, rcu, true);\n}\nstatic inline struct posix_acl *ovl_get_acl(struct mnt_idmap *idmap,\n\t\t\t\t\t    struct dentry *dentry, int type)\n{\n\treturn do_ovl_get_acl(idmap, d_inode(dentry), type, false, false);\n}\nint ovl_set_acl(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\tstruct posix_acl *acl, int type);\nstruct posix_acl *ovl_get_acl_path(const struct path *path,\n\t\t\t\t   const char *acl_name, bool noperm);\n#else\n#define ovl_get_inode_acl\tNULL\n#define ovl_get_acl\t\tNULL\n#define ovl_set_acl\t\tNULL\nstatic inline struct posix_acl *ovl_get_acl_path(const struct path *path,\n\t\t\t\t\t\t const char *acl_name,\n\t\t\t\t\t\t bool noperm)\n{\n\treturn NULL;\n}\n#endif\n\nint ovl_update_time(struct inode *inode, int flags);\nbool ovl_is_private_xattr(struct super_block *sb, const char *name);\n\nstruct ovl_inode_params {\n\tstruct inode *newinode;\n\tstruct dentry *upperdentry;\n\tstruct ovl_entry *oe;\n\tbool index;\n\tchar *redirect;\n\tchar *lowerdata_redirect;\n};\nvoid ovl_inode_init(struct inode *inode, struct ovl_inode_params *oip,\n\t\t    unsigned long ino, int fsid);\nstruct inode *ovl_new_inode(struct super_block *sb, umode_t mode, dev_t rdev);\nstruct inode *ovl_lookup_inode(struct super_block *sb, struct dentry *real,\n\t\t\t       bool is_upper);\nbool ovl_lookup_trap_inode(struct super_block *sb, struct dentry *dir);\nstruct inode *ovl_get_trap_inode(struct super_block *sb, struct dentry *dir);\nstruct inode *ovl_get_inode(struct super_block *sb,\n\t\t\t    struct ovl_inode_params *oip);\nvoid ovl_copyattr(struct inode *to);\n\n \n#define OVL_COPY_I_FLAGS_MASK\t(S_SYNC | S_NOATIME | S_APPEND | S_IMMUTABLE)\n \n#define OVL_PROT_I_FLAGS_MASK\t(S_APPEND | S_IMMUTABLE)\n\n \n#define OVL_COPY_FS_FLAGS_MASK\t(FS_SYNC_FL | FS_NOATIME_FL)\n#define OVL_COPY_FSX_FLAGS_MASK\t(FS_XFLAG_SYNC | FS_XFLAG_NOATIME)\n#define OVL_PROT_FS_FLAGS_MASK  (FS_APPEND_FL | FS_IMMUTABLE_FL)\n#define OVL_PROT_FSX_FLAGS_MASK (FS_XFLAG_APPEND | FS_XFLAG_IMMUTABLE)\n\nvoid ovl_check_protattr(struct inode *inode, struct dentry *upper);\nint ovl_set_protattr(struct inode *inode, struct dentry *upper,\n\t\t      struct fileattr *fa);\n\nstatic inline void ovl_copyflags(struct inode *from, struct inode *to)\n{\n\tunsigned int mask = OVL_COPY_I_FLAGS_MASK;\n\n\tinode_set_flags(to, from->i_flags & mask, mask);\n}\n\n \nextern const struct inode_operations ovl_dir_inode_operations;\nint ovl_cleanup_and_whiteout(struct ovl_fs *ofs, struct inode *dir,\n\t\t\t     struct dentry *dentry);\nstruct ovl_cattr {\n\tdev_t rdev;\n\tumode_t mode;\n\tconst char *link;\n\tstruct dentry *hardlink;\n};\n\n#define OVL_CATTR(m) (&(struct ovl_cattr) { .mode = (m) })\n\nint ovl_mkdir_real(struct ovl_fs *ofs, struct inode *dir,\n\t\t   struct dentry **newdentry, umode_t mode);\nstruct dentry *ovl_create_real(struct ovl_fs *ofs,\n\t\t\t       struct inode *dir, struct dentry *newdentry,\n\t\t\t       struct ovl_cattr *attr);\nint ovl_cleanup(struct ovl_fs *ofs, struct inode *dir, struct dentry *dentry);\nstruct dentry *ovl_lookup_temp(struct ovl_fs *ofs, struct dentry *workdir);\nstruct dentry *ovl_create_temp(struct ovl_fs *ofs, struct dentry *workdir,\n\t\t\t       struct ovl_cattr *attr);\n\n \nextern const struct file_operations ovl_file_operations;\nint __init ovl_aio_request_cache_init(void);\nvoid ovl_aio_request_cache_destroy(void);\nint ovl_real_fileattr_get(const struct path *realpath, struct fileattr *fa);\nint ovl_real_fileattr_set(const struct path *realpath, struct fileattr *fa);\nint ovl_fileattr_get(struct dentry *dentry, struct fileattr *fa);\nint ovl_fileattr_set(struct mnt_idmap *idmap,\n\t\t     struct dentry *dentry, struct fileattr *fa);\n\n \nint ovl_copy_up(struct dentry *dentry);\nint ovl_copy_up_with_data(struct dentry *dentry);\nint ovl_maybe_copy_up(struct dentry *dentry, int flags);\nint ovl_copy_xattr(struct super_block *sb, const struct path *path, struct dentry *new);\nint ovl_set_attr(struct ovl_fs *ofs, struct dentry *upper, struct kstat *stat);\nstruct ovl_fh *ovl_encode_real_fh(struct ovl_fs *ofs, struct dentry *real,\n\t\t\t\t  bool is_upper);\nint ovl_set_origin(struct ovl_fs *ofs, struct dentry *lower,\n\t\t   struct dentry *upper);\n\n \nextern const struct export_operations ovl_export_operations;\nextern const struct export_operations ovl_export_fid_operations;\n\n \nint ovl_fill_super(struct super_block *sb, struct fs_context *fc);\n\n \nstatic inline bool ovl_force_readonly(struct ovl_fs *ofs)\n{\n\treturn (!ovl_upper_mnt(ofs) || !ofs->workdir);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}