{
  "module_name": "file.c",
  "hash_id": "ffc501827bbc15b9793a5fe44e96ceee9ae61998f7e2244b13b2cd3bb008787b",
  "original_prompt": "Ingested from linux-6.6.14/fs/overlayfs/file.c",
  "human_readable_source": "\n \n\n#include <linux/cred.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/uio.h>\n#include <linux/uaccess.h>\n#include <linux/splice.h>\n#include <linux/security.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include \"overlayfs.h\"\n\nstruct ovl_aio_req {\n\tstruct kiocb iocb;\n\trefcount_t ref;\n\tstruct kiocb *orig_iocb;\n};\n\nstatic struct kmem_cache *ovl_aio_request_cachep;\n\nstatic char ovl_whatisit(struct inode *inode, struct inode *realinode)\n{\n\tif (realinode != ovl_inode_upper(inode))\n\t\treturn 'l';\n\tif (ovl_has_upperdata(inode))\n\t\treturn 'u';\n\telse\n\t\treturn 'm';\n}\n\n \n#define OVL_OPEN_FLAGS (O_NOATIME)\n\nstatic struct file *ovl_open_realfile(const struct file *file,\n\t\t\t\t      const struct path *realpath)\n{\n\tstruct inode *realinode = d_inode(realpath->dentry);\n\tstruct inode *inode = file_inode(file);\n\tstruct mnt_idmap *real_idmap;\n\tstruct file *realfile;\n\tconst struct cred *old_cred;\n\tint flags = file->f_flags | OVL_OPEN_FLAGS;\n\tint acc_mode = ACC_MODE(flags);\n\tint err;\n\n\tif (flags & O_APPEND)\n\t\tacc_mode |= MAY_APPEND;\n\n\told_cred = ovl_override_creds(inode->i_sb);\n\treal_idmap = mnt_idmap(realpath->mnt);\n\terr = inode_permission(real_idmap, realinode, MAY_OPEN | acc_mode);\n\tif (err) {\n\t\trealfile = ERR_PTR(err);\n\t} else {\n\t\tif (!inode_owner_or_capable(real_idmap, realinode))\n\t\t\tflags &= ~O_NOATIME;\n\n\t\trealfile = backing_file_open(&file->f_path, flags, realpath,\n\t\t\t\t\t     current_cred());\n\t}\n\trevert_creds(old_cred);\n\n\tpr_debug(\"open(%p[%pD2/%c], 0%o) -> (%p, 0%o)\\n\",\n\t\t file, file, ovl_whatisit(inode, realinode), file->f_flags,\n\t\t realfile, IS_ERR(realfile) ? 0 : realfile->f_flags);\n\n\treturn realfile;\n}\n\n#define OVL_SETFL_MASK (O_APPEND | O_NONBLOCK | O_NDELAY | O_DIRECT)\n\nstatic int ovl_change_flags(struct file *file, unsigned int flags)\n{\n\tstruct inode *inode = file_inode(file);\n\tint err;\n\n\tflags &= OVL_SETFL_MASK;\n\n\tif (((flags ^ file->f_flags) & O_APPEND) && IS_APPEND(inode))\n\t\treturn -EPERM;\n\n\tif ((flags & O_DIRECT) && !(file->f_mode & FMODE_CAN_ODIRECT))\n\t\treturn -EINVAL;\n\n\tif (file->f_op->check_flags) {\n\t\terr = file->f_op->check_flags(flags);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tspin_lock(&file->f_lock);\n\tfile->f_flags = (file->f_flags & ~OVL_SETFL_MASK) | flags;\n\tfile->f_iocb_flags = iocb_flags(file);\n\tspin_unlock(&file->f_lock);\n\n\treturn 0;\n}\n\nstatic int ovl_real_fdget_meta(const struct file *file, struct fd *real,\n\t\t\t       bool allow_meta)\n{\n\tstruct dentry *dentry = file_dentry(file);\n\tstruct path realpath;\n\tint err;\n\n\treal->flags = 0;\n\treal->file = file->private_data;\n\n\tif (allow_meta) {\n\t\tovl_path_real(dentry, &realpath);\n\t} else {\n\t\t \n\t\terr = ovl_verify_lowerdata(dentry);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tovl_path_realdata(dentry, &realpath);\n\t}\n\tif (!realpath.dentry)\n\t\treturn -EIO;\n\n\t \n\tif (unlikely(file_inode(real->file) != d_inode(realpath.dentry))) {\n\t\treal->flags = FDPUT_FPUT;\n\t\treal->file = ovl_open_realfile(file, &realpath);\n\n\t\treturn PTR_ERR_OR_ZERO(real->file);\n\t}\n\n\t \n\tif (unlikely((file->f_flags ^ real->file->f_flags) & ~OVL_OPEN_FLAGS))\n\t\treturn ovl_change_flags(real->file, file->f_flags);\n\n\treturn 0;\n}\n\nstatic int ovl_real_fdget(const struct file *file, struct fd *real)\n{\n\tif (d_is_dir(file_dentry(file))) {\n\t\treal->flags = 0;\n\t\treal->file = ovl_dir_real_file(file, false);\n\n\t\treturn PTR_ERR_OR_ZERO(real->file);\n\t}\n\n\treturn ovl_real_fdget_meta(file, real, false);\n}\n\nstatic int ovl_open(struct inode *inode, struct file *file)\n{\n\tstruct dentry *dentry = file_dentry(file);\n\tstruct file *realfile;\n\tstruct path realpath;\n\tint err;\n\n\t \n\terr = ovl_verify_lowerdata(dentry);\n\tif (err)\n\t\treturn err;\n\n\terr = ovl_maybe_copy_up(dentry, file->f_flags);\n\tif (err)\n\t\treturn err;\n\n\t \n\tfile->f_flags &= ~(O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC);\n\n\tovl_path_realdata(dentry, &realpath);\n\tif (!realpath.dentry)\n\t\treturn -EIO;\n\n\trealfile = ovl_open_realfile(file, &realpath);\n\tif (IS_ERR(realfile))\n\t\treturn PTR_ERR(realfile);\n\n\tfile->private_data = realfile;\n\n\treturn 0;\n}\n\nstatic int ovl_release(struct inode *inode, struct file *file)\n{\n\tfput(file->private_data);\n\n\treturn 0;\n}\n\nstatic loff_t ovl_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fd real;\n\tconst struct cred *old_cred;\n\tloff_t ret;\n\n\t \n\tif (offset == 0) {\n\t\tif (whence == SEEK_CUR)\n\t\t\treturn file->f_pos;\n\n\t\tif (whence == SEEK_SET)\n\t\t\treturn vfs_setpos(file, 0, 0);\n\t}\n\n\tret = ovl_real_fdget(file, &real);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tovl_inode_lock(inode);\n\treal.file->f_pos = file->f_pos;\n\n\told_cred = ovl_override_creds(inode->i_sb);\n\tret = vfs_llseek(real.file, offset, whence);\n\trevert_creds(old_cred);\n\n\tfile->f_pos = real.file->f_pos;\n\tovl_inode_unlock(inode);\n\n\tfdput(real);\n\n\treturn ret;\n}\n\nstatic void ovl_file_accessed(struct file *file)\n{\n\tstruct inode *inode, *upperinode;\n\tstruct timespec64 ctime, uctime;\n\n\tif (file->f_flags & O_NOATIME)\n\t\treturn;\n\n\tinode = file_inode(file);\n\tupperinode = ovl_inode_upper(inode);\n\n\tif (!upperinode)\n\t\treturn;\n\n\tctime = inode_get_ctime(inode);\n\tuctime = inode_get_ctime(upperinode);\n\tif ((!timespec64_equal(&inode->i_mtime, &upperinode->i_mtime) ||\n\t     !timespec64_equal(&ctime, &uctime))) {\n\t\tinode->i_mtime = upperinode->i_mtime;\n\t\tinode_set_ctime_to_ts(inode, uctime);\n\t}\n\n\ttouch_atime(&file->f_path);\n}\n\nstatic rwf_t ovl_iocb_to_rwf(int ifl)\n{\n\trwf_t flags = 0;\n\n\tif (ifl & IOCB_NOWAIT)\n\t\tflags |= RWF_NOWAIT;\n\tif (ifl & IOCB_HIPRI)\n\t\tflags |= RWF_HIPRI;\n\tif (ifl & IOCB_DSYNC)\n\t\tflags |= RWF_DSYNC;\n\tif (ifl & IOCB_SYNC)\n\t\tflags |= RWF_SYNC;\n\n\treturn flags;\n}\n\nstatic inline void ovl_aio_put(struct ovl_aio_req *aio_req)\n{\n\tif (refcount_dec_and_test(&aio_req->ref)) {\n\t\tfput(aio_req->iocb.ki_filp);\n\t\tkmem_cache_free(ovl_aio_request_cachep, aio_req);\n\t}\n}\n\nstatic void ovl_aio_cleanup_handler(struct ovl_aio_req *aio_req)\n{\n\tstruct kiocb *iocb = &aio_req->iocb;\n\tstruct kiocb *orig_iocb = aio_req->orig_iocb;\n\n\tif (iocb->ki_flags & IOCB_WRITE) {\n\t\tstruct inode *inode = file_inode(orig_iocb->ki_filp);\n\n\t\tkiocb_end_write(iocb);\n\t\tovl_copyattr(inode);\n\t}\n\n\torig_iocb->ki_pos = iocb->ki_pos;\n\tovl_aio_put(aio_req);\n}\n\nstatic void ovl_aio_rw_complete(struct kiocb *iocb, long res)\n{\n\tstruct ovl_aio_req *aio_req = container_of(iocb,\n\t\t\t\t\t\t   struct ovl_aio_req, iocb);\n\tstruct kiocb *orig_iocb = aio_req->orig_iocb;\n\n\tovl_aio_cleanup_handler(aio_req);\n\torig_iocb->ki_complete(orig_iocb, res);\n}\n\nstatic ssize_t ovl_read_iter(struct kiocb *iocb, struct iov_iter *iter)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct fd real;\n\tconst struct cred *old_cred;\n\tssize_t ret;\n\n\tif (!iov_iter_count(iter))\n\t\treturn 0;\n\n\tret = ovl_real_fdget(file, &real);\n\tif (ret)\n\t\treturn ret;\n\n\tret = -EINVAL;\n\tif (iocb->ki_flags & IOCB_DIRECT &&\n\t    !(real.file->f_mode & FMODE_CAN_ODIRECT))\n\t\tgoto out_fdput;\n\n\told_cred = ovl_override_creds(file_inode(file)->i_sb);\n\tif (is_sync_kiocb(iocb)) {\n\t\tret = vfs_iter_read(real.file, iter, &iocb->ki_pos,\n\t\t\t\t    ovl_iocb_to_rwf(iocb->ki_flags));\n\t} else {\n\t\tstruct ovl_aio_req *aio_req;\n\n\t\tret = -ENOMEM;\n\t\taio_req = kmem_cache_zalloc(ovl_aio_request_cachep, GFP_KERNEL);\n\t\tif (!aio_req)\n\t\t\tgoto out;\n\n\t\taio_req->orig_iocb = iocb;\n\t\tkiocb_clone(&aio_req->iocb, iocb, get_file(real.file));\n\t\taio_req->iocb.ki_complete = ovl_aio_rw_complete;\n\t\trefcount_set(&aio_req->ref, 2);\n\t\tret = vfs_iocb_iter_read(real.file, &aio_req->iocb, iter);\n\t\tovl_aio_put(aio_req);\n\t\tif (ret != -EIOCBQUEUED)\n\t\t\tovl_aio_cleanup_handler(aio_req);\n\t}\nout:\n\trevert_creds(old_cred);\n\tovl_file_accessed(file);\nout_fdput:\n\tfdput(real);\n\n\treturn ret;\n}\n\nstatic ssize_t ovl_write_iter(struct kiocb *iocb, struct iov_iter *iter)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file_inode(file);\n\tstruct fd real;\n\tconst struct cred *old_cred;\n\tssize_t ret;\n\tint ifl = iocb->ki_flags;\n\n\tif (!iov_iter_count(iter))\n\t\treturn 0;\n\n\tinode_lock(inode);\n\t \n\tovl_copyattr(inode);\n\tret = file_remove_privs(file);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = ovl_real_fdget(file, &real);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = -EINVAL;\n\tif (iocb->ki_flags & IOCB_DIRECT &&\n\t    !(real.file->f_mode & FMODE_CAN_ODIRECT))\n\t\tgoto out_fdput;\n\n\tif (!ovl_should_sync(OVL_FS(inode->i_sb)))\n\t\tifl &= ~(IOCB_DSYNC | IOCB_SYNC);\n\n\t \n\tifl &= ~IOCB_DIO_CALLER_COMP;\n\n\told_cred = ovl_override_creds(file_inode(file)->i_sb);\n\tif (is_sync_kiocb(iocb)) {\n\t\tfile_start_write(real.file);\n\t\tret = vfs_iter_write(real.file, iter, &iocb->ki_pos,\n\t\t\t\t     ovl_iocb_to_rwf(ifl));\n\t\tfile_end_write(real.file);\n\t\t \n\t\tovl_copyattr(inode);\n\t} else {\n\t\tstruct ovl_aio_req *aio_req;\n\n\t\tret = -ENOMEM;\n\t\taio_req = kmem_cache_zalloc(ovl_aio_request_cachep, GFP_KERNEL);\n\t\tif (!aio_req)\n\t\t\tgoto out;\n\n\t\taio_req->orig_iocb = iocb;\n\t\tkiocb_clone(&aio_req->iocb, iocb, get_file(real.file));\n\t\taio_req->iocb.ki_flags = ifl;\n\t\taio_req->iocb.ki_complete = ovl_aio_rw_complete;\n\t\trefcount_set(&aio_req->ref, 2);\n\t\tkiocb_start_write(&aio_req->iocb);\n\t\tret = vfs_iocb_iter_write(real.file, &aio_req->iocb, iter);\n\t\tovl_aio_put(aio_req);\n\t\tif (ret != -EIOCBQUEUED)\n\t\t\tovl_aio_cleanup_handler(aio_req);\n\t}\nout:\n\trevert_creds(old_cred);\nout_fdput:\n\tfdput(real);\n\nout_unlock:\n\tinode_unlock(inode);\n\n\treturn ret;\n}\n\nstatic ssize_t ovl_splice_read(struct file *in, loff_t *ppos,\n\t\t\t       struct pipe_inode_info *pipe, size_t len,\n\t\t\t       unsigned int flags)\n{\n\tconst struct cred *old_cred;\n\tstruct fd real;\n\tssize_t ret;\n\n\tret = ovl_real_fdget(in, &real);\n\tif (ret)\n\t\treturn ret;\n\n\told_cred = ovl_override_creds(file_inode(in)->i_sb);\n\tret = vfs_splice_read(real.file, ppos, pipe, len, flags);\n\trevert_creds(old_cred);\n\tovl_file_accessed(in);\n\n\tfdput(real);\n\treturn ret;\n}\n\n \nstatic ssize_t ovl_splice_write(struct pipe_inode_info *pipe, struct file *out,\n\t\t\t\tloff_t *ppos, size_t len, unsigned int flags)\n{\n\tstruct fd real;\n\tconst struct cred *old_cred;\n\tstruct inode *inode = file_inode(out);\n\tssize_t ret;\n\n\tinode_lock(inode);\n\t \n\tovl_copyattr(inode);\n\tret = file_remove_privs(out);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = ovl_real_fdget(out, &real);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\told_cred = ovl_override_creds(inode->i_sb);\n\tfile_start_write(real.file);\n\n\tret = iter_file_splice_write(pipe, real.file, ppos, len, flags);\n\n\tfile_end_write(real.file);\n\t \n\tovl_copyattr(inode);\n\trevert_creds(old_cred);\n\tfdput(real);\n\nout_unlock:\n\tinode_unlock(inode);\n\n\treturn ret;\n}\n\nstatic int ovl_fsync(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tstruct fd real;\n\tconst struct cred *old_cred;\n\tint ret;\n\n\tret = ovl_sync_status(OVL_FS(file_inode(file)->i_sb));\n\tif (ret <= 0)\n\t\treturn ret;\n\n\tret = ovl_real_fdget_meta(file, &real, !datasync);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (file_inode(real.file) == ovl_inode_upper(file_inode(file))) {\n\t\told_cred = ovl_override_creds(file_inode(file)->i_sb);\n\t\tret = vfs_fsync_range(real.file, start, end, datasync);\n\t\trevert_creds(old_cred);\n\t}\n\n\tfdput(real);\n\n\treturn ret;\n}\n\nstatic int ovl_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct file *realfile = file->private_data;\n\tconst struct cred *old_cred;\n\tint ret;\n\n\tif (!realfile->f_op->mmap)\n\t\treturn -ENODEV;\n\n\tif (WARN_ON(file != vma->vm_file))\n\t\treturn -EIO;\n\n\tvma_set_file(vma, realfile);\n\n\told_cred = ovl_override_creds(file_inode(file)->i_sb);\n\tret = call_mmap(vma->vm_file, vma);\n\trevert_creds(old_cred);\n\tovl_file_accessed(file);\n\n\treturn ret;\n}\n\nstatic long ovl_fallocate(struct file *file, int mode, loff_t offset, loff_t len)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fd real;\n\tconst struct cred *old_cred;\n\tint ret;\n\n\tinode_lock(inode);\n\t \n\tovl_copyattr(inode);\n\tret = file_remove_privs(file);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = ovl_real_fdget(file, &real);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\told_cred = ovl_override_creds(file_inode(file)->i_sb);\n\tret = vfs_fallocate(real.file, mode, offset, len);\n\trevert_creds(old_cred);\n\n\t \n\tovl_copyattr(inode);\n\n\tfdput(real);\n\nout_unlock:\n\tinode_unlock(inode);\n\n\treturn ret;\n}\n\nstatic int ovl_fadvise(struct file *file, loff_t offset, loff_t len, int advice)\n{\n\tstruct fd real;\n\tconst struct cred *old_cred;\n\tint ret;\n\n\tret = ovl_real_fdget(file, &real);\n\tif (ret)\n\t\treturn ret;\n\n\told_cred = ovl_override_creds(file_inode(file)->i_sb);\n\tret = vfs_fadvise(real.file, offset, len, advice);\n\trevert_creds(old_cred);\n\n\tfdput(real);\n\n\treturn ret;\n}\n\nenum ovl_copyop {\n\tOVL_COPY,\n\tOVL_CLONE,\n\tOVL_DEDUPE,\n};\n\nstatic loff_t ovl_copyfile(struct file *file_in, loff_t pos_in,\n\t\t\t    struct file *file_out, loff_t pos_out,\n\t\t\t    loff_t len, unsigned int flags, enum ovl_copyop op)\n{\n\tstruct inode *inode_out = file_inode(file_out);\n\tstruct fd real_in, real_out;\n\tconst struct cred *old_cred;\n\tloff_t ret;\n\n\tinode_lock(inode_out);\n\tif (op != OVL_DEDUPE) {\n\t\t \n\t\tovl_copyattr(inode_out);\n\t\tret = file_remove_privs(file_out);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t}\n\n\tret = ovl_real_fdget(file_out, &real_out);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = ovl_real_fdget(file_in, &real_in);\n\tif (ret) {\n\t\tfdput(real_out);\n\t\tgoto out_unlock;\n\t}\n\n\told_cred = ovl_override_creds(file_inode(file_out)->i_sb);\n\tswitch (op) {\n\tcase OVL_COPY:\n\t\tret = vfs_copy_file_range(real_in.file, pos_in,\n\t\t\t\t\t  real_out.file, pos_out, len, flags);\n\t\tbreak;\n\n\tcase OVL_CLONE:\n\t\tret = vfs_clone_file_range(real_in.file, pos_in,\n\t\t\t\t\t   real_out.file, pos_out, len, flags);\n\t\tbreak;\n\n\tcase OVL_DEDUPE:\n\t\tret = vfs_dedupe_file_range_one(real_in.file, pos_in,\n\t\t\t\t\t\treal_out.file, pos_out, len,\n\t\t\t\t\t\tflags);\n\t\tbreak;\n\t}\n\trevert_creds(old_cred);\n\n\t \n\tovl_copyattr(inode_out);\n\n\tfdput(real_in);\n\tfdput(real_out);\n\nout_unlock:\n\tinode_unlock(inode_out);\n\n\treturn ret;\n}\n\nstatic ssize_t ovl_copy_file_range(struct file *file_in, loff_t pos_in,\n\t\t\t\t   struct file *file_out, loff_t pos_out,\n\t\t\t\t   size_t len, unsigned int flags)\n{\n\treturn ovl_copyfile(file_in, pos_in, file_out, pos_out, len, flags,\n\t\t\t    OVL_COPY);\n}\n\nstatic loff_t ovl_remap_file_range(struct file *file_in, loff_t pos_in,\n\t\t\t\t   struct file *file_out, loff_t pos_out,\n\t\t\t\t   loff_t len, unsigned int remap_flags)\n{\n\tenum ovl_copyop op;\n\n\tif (remap_flags & ~(REMAP_FILE_DEDUP | REMAP_FILE_ADVISORY))\n\t\treturn -EINVAL;\n\n\tif (remap_flags & REMAP_FILE_DEDUP)\n\t\top = OVL_DEDUPE;\n\telse\n\t\top = OVL_CLONE;\n\n\t \n\tif (op == OVL_DEDUPE &&\n\t    (!ovl_inode_upper(file_inode(file_in)) ||\n\t     !ovl_inode_upper(file_inode(file_out))))\n\t\treturn -EPERM;\n\n\treturn ovl_copyfile(file_in, pos_in, file_out, pos_out, len,\n\t\t\t    remap_flags, op);\n}\n\nstatic int ovl_flush(struct file *file, fl_owner_t id)\n{\n\tstruct fd real;\n\tconst struct cred *old_cred;\n\tint err;\n\n\terr = ovl_real_fdget(file, &real);\n\tif (err)\n\t\treturn err;\n\n\tif (real.file->f_op->flush) {\n\t\told_cred = ovl_override_creds(file_inode(file)->i_sb);\n\t\terr = real.file->f_op->flush(real.file, id);\n\t\trevert_creds(old_cred);\n\t}\n\tfdput(real);\n\n\treturn err;\n}\n\nconst struct file_operations ovl_file_operations = {\n\t.open\t\t= ovl_open,\n\t.release\t= ovl_release,\n\t.llseek\t\t= ovl_llseek,\n\t.read_iter\t= ovl_read_iter,\n\t.write_iter\t= ovl_write_iter,\n\t.fsync\t\t= ovl_fsync,\n\t.mmap\t\t= ovl_mmap,\n\t.fallocate\t= ovl_fallocate,\n\t.fadvise\t= ovl_fadvise,\n\t.flush\t\t= ovl_flush,\n\t.splice_read    = ovl_splice_read,\n\t.splice_write   = ovl_splice_write,\n\n\t.copy_file_range\t= ovl_copy_file_range,\n\t.remap_file_range\t= ovl_remap_file_range,\n};\n\nint __init ovl_aio_request_cache_init(void)\n{\n\tovl_aio_request_cachep = kmem_cache_create(\"ovl_aio_req\",\n\t\t\t\t\t\t   sizeof(struct ovl_aio_req),\n\t\t\t\t\t\t   0, SLAB_HWCACHE_ALIGN, NULL);\n\tif (!ovl_aio_request_cachep)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nvoid ovl_aio_request_cache_destroy(void)\n{\n\tkmem_cache_destroy(ovl_aio_request_cachep);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}