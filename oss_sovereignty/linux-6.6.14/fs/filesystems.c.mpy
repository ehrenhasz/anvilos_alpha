{
  "module_name": "filesystems.c",
  "hash_id": "b9765b5eb39f48f0f755e61e4f3d6395157a5a04e18382899fdfd5251a07fcfd",
  "original_prompt": "Ingested from linux-6.6.14/fs/filesystems.c",
  "human_readable_source": "\n \n\n#include <linux/syscalls.h>\n#include <linux/fs.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/kmod.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/fs_parser.h>\n\n \n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\n \nstruct file_system_type *get_filesystem(struct file_system_type *fs)\n{\n\t__module_get(fs->owner);\n\treturn fs;\n}\n\nvoid put_filesystem(struct file_system_type *fs)\n{\n\tmodule_put(fs->owner);\n}\n\nstatic struct file_system_type **find_filesystem(const char *name, unsigned len)\n{\n\tstruct file_system_type **p;\n\tfor (p = &file_systems; *p; p = &(*p)->next)\n\t\tif (strncmp((*p)->name, name, len) == 0 &&\n\t\t    !(*p)->name[len])\n\t\t\tbreak;\n\treturn p;\n}\n\n \n \nint register_filesystem(struct file_system_type * fs)\n{\n\tint res = 0;\n\tstruct file_system_type ** p;\n\n\tif (fs->parameters &&\n\t    !fs_validate_description(fs->name, fs->parameters))\n\t\treturn -EINVAL;\n\n\tBUG_ON(strchr(fs->name, '.'));\n\tif (fs->next)\n\t\treturn -EBUSY;\n\twrite_lock(&file_systems_lock);\n\tp = find_filesystem(fs->name, strlen(fs->name));\n\tif (*p)\n\t\tres = -EBUSY;\n\telse\n\t\t*p = fs;\n\twrite_unlock(&file_systems_lock);\n\treturn res;\n}\n\nEXPORT_SYMBOL(register_filesystem);\n\n \n \nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}\n\nEXPORT_SYMBOL(unregister_filesystem);\n\n#ifdef CONFIG_SYSFS_SYSCALL\nstatic int fs_index(const char __user * __name)\n{\n\tstruct file_system_type * tmp;\n\tstruct filename *name;\n\tint err, index;\n\n\tname = getname(__name);\n\terr = PTR_ERR(name);\n\tif (IS_ERR(name))\n\t\treturn err;\n\n\terr = -EINVAL;\n\tread_lock(&file_systems_lock);\n\tfor (tmp=file_systems, index=0 ; tmp ; tmp=tmp->next, index++) {\n\t\tif (strcmp(tmp->name, name->name) == 0) {\n\t\t\terr = index;\n\t\t\tbreak;\n\t\t}\n\t}\n\tread_unlock(&file_systems_lock);\n\tputname(name);\n\treturn err;\n}\n\nstatic int fs_name(unsigned int index, char __user * buf)\n{\n\tstruct file_system_type * tmp;\n\tint len, res;\n\n\tread_lock(&file_systems_lock);\n\tfor (tmp = file_systems; tmp; tmp = tmp->next, index--)\n\t\tif (index <= 0 && try_module_get(tmp->owner))\n\t\t\tbreak;\n\tread_unlock(&file_systems_lock);\n\tif (!tmp)\n\t\treturn -EINVAL;\n\n\t \n\tlen = strlen(tmp->name) + 1;\n\tres = copy_to_user(buf, tmp->name, len) ? -EFAULT : 0;\n\tput_filesystem(tmp);\n\treturn res;\n}\n\nstatic int fs_maxindex(void)\n{\n\tstruct file_system_type * tmp;\n\tint index;\n\n\tread_lock(&file_systems_lock);\n\tfor (tmp = file_systems, index = 0 ; tmp ; tmp = tmp->next, index++)\n\t\t;\n\tread_unlock(&file_systems_lock);\n\treturn index;\n}\n\n \nSYSCALL_DEFINE3(sysfs, int, option, unsigned long, arg1, unsigned long, arg2)\n{\n\tint retval = -EINVAL;\n\n\tswitch (option) {\n\t\tcase 1:\n\t\t\tretval = fs_index((const char __user *) arg1);\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\tretval = fs_name(arg1, (char __user *) arg2);\n\t\t\tbreak;\n\n\t\tcase 3:\n\t\t\tretval = fs_maxindex();\n\t\t\tbreak;\n\t}\n\treturn retval;\n}\n#endif\n\nint __init list_bdev_fs_names(char *buf, size_t size)\n{\n\tstruct file_system_type *p;\n\tsize_t len;\n\tint count = 0;\n\n\tread_lock(&file_systems_lock);\n\tfor (p = file_systems; p; p = p->next) {\n\t\tif (!(p->fs_flags & FS_REQUIRES_DEV))\n\t\t\tcontinue;\n\t\tlen = strlen(p->name) + 1;\n\t\tif (len > size) {\n\t\t\tpr_warn(\"%s: truncating file system list\\n\", __func__);\n\t\t\tbreak;\n\t\t}\n\t\tmemcpy(buf, p->name, len);\n\t\tbuf += len;\n\t\tsize -= len;\n\t\tcount++;\n\t}\n\tread_unlock(&file_systems_lock);\n\treturn count;\n}\n\n#ifdef CONFIG_PROC_FS\nstatic int filesystems_proc_show(struct seq_file *m, void *v)\n{\n\tstruct file_system_type * tmp;\n\n\tread_lock(&file_systems_lock);\n\ttmp = file_systems;\n\twhile (tmp) {\n\t\tseq_printf(m, \"%s\\t%s\\n\",\n\t\t\t(tmp->fs_flags & FS_REQUIRES_DEV) ? \"\" : \"nodev\",\n\t\t\ttmp->name);\n\t\ttmp = tmp->next;\n\t}\n\tread_unlock(&file_systems_lock);\n\treturn 0;\n}\n\nstatic int __init proc_filesystems_init(void)\n{\n\tproc_create_single(\"filesystems\", 0, NULL, filesystems_proc_show);\n\treturn 0;\n}\nmodule_init(proc_filesystems_init);\n#endif\n\nstatic struct file_system_type *__get_fs_type(const char *name, int len)\n{\n\tstruct file_system_type *fs;\n\n\tread_lock(&file_systems_lock);\n\tfs = *(find_filesystem(name, len));\n\tif (fs && !try_module_get(fs->owner))\n\t\tfs = NULL;\n\tread_unlock(&file_systems_lock);\n\treturn fs;\n}\n\nstruct file_system_type *get_fs_type(const char *name)\n{\n\tstruct file_system_type *fs;\n\tconst char *dot = strchr(name, '.');\n\tint len = dot ? dot - name : strlen(name);\n\n\tfs = __get_fs_type(name, len);\n\tif (!fs && (request_module(\"fs-%.*s\", len, name) == 0)) {\n\t\tfs = __get_fs_type(name, len);\n\t\tif (!fs)\n\t\t\tpr_warn_once(\"request_module fs-%.*s succeeded, but still no fs?\\n\",\n\t\t\t\t     len, name);\n\t}\n\n\tif (dot && fs && !(fs->fs_flags & FS_HAS_SUBTYPE)) {\n\t\tput_filesystem(fs);\n\t\tfs = NULL;\n\t}\n\treturn fs;\n}\n\nEXPORT_SYMBOL(get_fs_type);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}