{
  "module_name": "read_write.c",
  "hash_id": "6ebb863f7c16943e09f30224c357fb8d1f9529466c5af55a5f8c3418c06d8edd",
  "original_prompt": "Ingested from linux-6.6.14/fs/read_write.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/sched/xacct.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/uio.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/splice.h>\n#include <linux/compat.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include \"internal.h\"\n\n#include <linux/uaccess.h>\n#include <asm/unistd.h>\n\nconst struct file_operations generic_ro_fops = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read_iter\t= generic_file_read_iter,\n\t.mmap\t\t= generic_file_readonly_mmap,\n\t.splice_read\t= filemap_splice_read,\n};\n\nEXPORT_SYMBOL(generic_ro_fops);\n\nstatic inline bool unsigned_offsets(struct file *file)\n{\n\treturn file->f_mode & FMODE_UNSIGNED_OFFSET;\n}\n\n \nloff_t vfs_setpos(struct file *file, loff_t offset, loff_t maxsize)\n{\n\tif (offset < 0 && !unsigned_offsets(file))\n\t\treturn -EINVAL;\n\tif (offset > maxsize)\n\t\treturn -EINVAL;\n\n\tif (offset != file->f_pos) {\n\t\tfile->f_pos = offset;\n\t\tfile->f_version = 0;\n\t}\n\treturn offset;\n}\nEXPORT_SYMBOL(vfs_setpos);\n\n \nloff_t\ngeneric_file_llseek_size(struct file *file, loff_t offset, int whence,\n\t\tloff_t maxsize, loff_t eof)\n{\n\tswitch (whence) {\n\tcase SEEK_END:\n\t\toffset += eof;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\t \n\t\tif (offset == 0)\n\t\t\treturn file->f_pos;\n\t\t \n\t\tspin_lock(&file->f_lock);\n\t\toffset = vfs_setpos(file, file->f_pos + offset, maxsize);\n\t\tspin_unlock(&file->f_lock);\n\t\treturn offset;\n\tcase SEEK_DATA:\n\t\t \n\t\tif ((unsigned long long)offset >= eof)\n\t\t\treturn -ENXIO;\n\t\tbreak;\n\tcase SEEK_HOLE:\n\t\t \n\t\tif ((unsigned long long)offset >= eof)\n\t\t\treturn -ENXIO;\n\t\toffset = eof;\n\t\tbreak;\n\t}\n\n\treturn vfs_setpos(file, offset, maxsize);\n}\nEXPORT_SYMBOL(generic_file_llseek_size);\n\n \nloff_t generic_file_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\n\treturn generic_file_llseek_size(file, offset, whence,\n\t\t\t\t\tinode->i_sb->s_maxbytes,\n\t\t\t\t\ti_size_read(inode));\n}\nEXPORT_SYMBOL(generic_file_llseek);\n\n \nloff_t fixed_size_llseek(struct file *file, loff_t offset, int whence, loff_t size)\n{\n\tswitch (whence) {\n\tcase SEEK_SET: case SEEK_CUR: case SEEK_END:\n\t\treturn generic_file_llseek_size(file, offset, whence,\n\t\t\t\t\t\tsize, size);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\nEXPORT_SYMBOL(fixed_size_llseek);\n\n \nloff_t no_seek_end_llseek(struct file *file, loff_t offset, int whence)\n{\n\tswitch (whence) {\n\tcase SEEK_SET: case SEEK_CUR:\n\t\treturn generic_file_llseek_size(file, offset, whence,\n\t\t\t\t\t\tOFFSET_MAX, 0);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\nEXPORT_SYMBOL(no_seek_end_llseek);\n\n \nloff_t no_seek_end_llseek_size(struct file *file, loff_t offset, int whence, loff_t size)\n{\n\tswitch (whence) {\n\tcase SEEK_SET: case SEEK_CUR:\n\t\treturn generic_file_llseek_size(file, offset, whence,\n\t\t\t\t\t\tsize, 0);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\nEXPORT_SYMBOL(no_seek_end_llseek_size);\n\n \nloff_t noop_llseek(struct file *file, loff_t offset, int whence)\n{\n\treturn file->f_pos;\n}\nEXPORT_SYMBOL(noop_llseek);\n\nloff_t default_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *inode = file_inode(file);\n\tloff_t retval;\n\n\tinode_lock(inode);\n\tswitch (whence) {\n\t\tcase SEEK_END:\n\t\t\toffset += i_size_read(inode);\n\t\t\tbreak;\n\t\tcase SEEK_CUR:\n\t\t\tif (offset == 0) {\n\t\t\t\tretval = file->f_pos;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\toffset += file->f_pos;\n\t\t\tbreak;\n\t\tcase SEEK_DATA:\n\t\t\t \n\t\t\tif (offset >= inode->i_size) {\n\t\t\t\tretval = -ENXIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SEEK_HOLE:\n\t\t\t \n\t\t\tif (offset >= inode->i_size) {\n\t\t\t\tretval = -ENXIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\toffset = inode->i_size;\n\t\t\tbreak;\n\t}\n\tretval = -EINVAL;\n\tif (offset >= 0 || unsigned_offsets(file)) {\n\t\tif (offset != file->f_pos) {\n\t\t\tfile->f_pos = offset;\n\t\t\tfile->f_version = 0;\n\t\t}\n\t\tretval = offset;\n\t}\nout:\n\tinode_unlock(inode);\n\treturn retval;\n}\nEXPORT_SYMBOL(default_llseek);\n\nloff_t vfs_llseek(struct file *file, loff_t offset, int whence)\n{\n\tif (!(file->f_mode & FMODE_LSEEK))\n\t\treturn -ESPIPE;\n\treturn file->f_op->llseek(file, offset, whence);\n}\nEXPORT_SYMBOL(vfs_llseek);\n\nstatic off_t ksys_lseek(unsigned int fd, off_t offset, unsigned int whence)\n{\n\toff_t retval;\n\tstruct fd f = fdget_pos(fd);\n\tif (!f.file)\n\t\treturn -EBADF;\n\n\tretval = -EINVAL;\n\tif (whence <= SEEK_MAX) {\n\t\tloff_t res = vfs_llseek(f.file, offset, whence);\n\t\tretval = res;\n\t\tif (res != (loff_t)retval)\n\t\t\tretval = -EOVERFLOW;\t \n\t}\n\tfdput_pos(f);\n\treturn retval;\n}\n\nSYSCALL_DEFINE3(lseek, unsigned int, fd, off_t, offset, unsigned int, whence)\n{\n\treturn ksys_lseek(fd, offset, whence);\n}\n\n#ifdef CONFIG_COMPAT\nCOMPAT_SYSCALL_DEFINE3(lseek, unsigned int, fd, compat_off_t, offset, unsigned int, whence)\n{\n\treturn ksys_lseek(fd, offset, whence);\n}\n#endif\n\n#if !defined(CONFIG_64BIT) || defined(CONFIG_COMPAT) || \\\n\tdefined(__ARCH_WANT_SYS_LLSEEK)\nSYSCALL_DEFINE5(llseek, unsigned int, fd, unsigned long, offset_high,\n\t\tunsigned long, offset_low, loff_t __user *, result,\n\t\tunsigned int, whence)\n{\n\tint retval;\n\tstruct fd f = fdget_pos(fd);\n\tloff_t offset;\n\n\tif (!f.file)\n\t\treturn -EBADF;\n\n\tretval = -EINVAL;\n\tif (whence > SEEK_MAX)\n\t\tgoto out_putf;\n\n\toffset = vfs_llseek(f.file, ((loff_t) offset_high << 32) | offset_low,\n\t\t\twhence);\n\n\tretval = (int)offset;\n\tif (offset >= 0) {\n\t\tretval = -EFAULT;\n\t\tif (!copy_to_user(result, &offset, sizeof(offset)))\n\t\t\tretval = 0;\n\t}\nout_putf:\n\tfdput_pos(f);\n\treturn retval;\n}\n#endif\n\nint rw_verify_area(int read_write, struct file *file, const loff_t *ppos, size_t count)\n{\n\tif (unlikely((ssize_t) count < 0))\n\t\treturn -EINVAL;\n\n\tif (ppos) {\n\t\tloff_t pos = *ppos;\n\n\t\tif (unlikely(pos < 0)) {\n\t\t\tif (!unsigned_offsets(file))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (count >= -pos)  \n\t\t\t\treturn -EOVERFLOW;\n\t\t} else if (unlikely((loff_t) (pos + count) < 0)) {\n\t\t\tif (!unsigned_offsets(file))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn security_file_permission(file,\n\t\t\t\tread_write == READ ? MAY_READ : MAY_WRITE);\n}\nEXPORT_SYMBOL(rw_verify_area);\n\nstatic ssize_t new_sync_read(struct file *filp, char __user *buf, size_t len, loff_t *ppos)\n{\n\tstruct kiocb kiocb;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tinit_sync_kiocb(&kiocb, filp);\n\tkiocb.ki_pos = (ppos ? *ppos : 0);\n\tiov_iter_ubuf(&iter, ITER_DEST, buf, len);\n\n\tret = call_read_iter(filp, &kiocb, &iter);\n\tBUG_ON(ret == -EIOCBQUEUED);\n\tif (ppos)\n\t\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}\n\nstatic int warn_unsupported(struct file *file, const char *op)\n{\n\tpr_warn_ratelimited(\n\t\t\"kernel %s not supported for file %pD4 (pid: %d comm: %.20s)\\n\",\n\t\top, file, current->pid, current->comm);\n\treturn -EINVAL;\n}\n\nssize_t __kernel_read(struct file *file, void *buf, size_t count, loff_t *pos)\n{\n\tstruct kvec iov = {\n\t\t.iov_base\t= buf,\n\t\t.iov_len\t= min_t(size_t, count, MAX_RW_COUNT),\n\t};\n\tstruct kiocb kiocb;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tif (WARN_ON_ONCE(!(file->f_mode & FMODE_READ)))\n\t\treturn -EINVAL;\n\tif (!(file->f_mode & FMODE_CAN_READ))\n\t\treturn -EINVAL;\n\t \n\tif (unlikely(!file->f_op->read_iter || file->f_op->read))\n\t\treturn warn_unsupported(file, \"read\");\n\n\tinit_sync_kiocb(&kiocb, file);\n\tkiocb.ki_pos = pos ? *pos : 0;\n\tiov_iter_kvec(&iter, ITER_DEST, &iov, 1, iov.iov_len);\n\tret = file->f_op->read_iter(&kiocb, &iter);\n\tif (ret > 0) {\n\t\tif (pos)\n\t\t\t*pos = kiocb.ki_pos;\n\t\tfsnotify_access(file);\n\t\tadd_rchar(current, ret);\n\t}\n\tinc_syscr(current);\n\treturn ret;\n}\n\nssize_t kernel_read(struct file *file, void *buf, size_t count, loff_t *pos)\n{\n\tssize_t ret;\n\n\tret = rw_verify_area(READ, file, pos, count);\n\tif (ret)\n\t\treturn ret;\n\treturn __kernel_read(file, buf, count, pos);\n}\nEXPORT_SYMBOL(kernel_read);\n\nssize_t vfs_read(struct file *file, char __user *buf, size_t count, loff_t *pos)\n{\n\tssize_t ret;\n\n\tif (!(file->f_mode & FMODE_READ))\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_READ))\n\t\treturn -EINVAL;\n\tif (unlikely(!access_ok(buf, count)))\n\t\treturn -EFAULT;\n\n\tret = rw_verify_area(READ, file, pos, count);\n\tif (ret)\n\t\treturn ret;\n\tif (count > MAX_RW_COUNT)\n\t\tcount =  MAX_RW_COUNT;\n\n\tif (file->f_op->read)\n\t\tret = file->f_op->read(file, buf, count, pos);\n\telse if (file->f_op->read_iter)\n\t\tret = new_sync_read(file, buf, count, pos);\n\telse\n\t\tret = -EINVAL;\n\tif (ret > 0) {\n\t\tfsnotify_access(file);\n\t\tadd_rchar(current, ret);\n\t}\n\tinc_syscr(current);\n\treturn ret;\n}\n\nstatic ssize_t new_sync_write(struct file *filp, const char __user *buf, size_t len, loff_t *ppos)\n{\n\tstruct kiocb kiocb;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tinit_sync_kiocb(&kiocb, filp);\n\tkiocb.ki_pos = (ppos ? *ppos : 0);\n\tiov_iter_ubuf(&iter, ITER_SOURCE, (void __user *)buf, len);\n\n\tret = call_write_iter(filp, &kiocb, &iter);\n\tBUG_ON(ret == -EIOCBQUEUED);\n\tif (ret > 0 && ppos)\n\t\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}\n\n \nssize_t __kernel_write_iter(struct file *file, struct iov_iter *from, loff_t *pos)\n{\n\tstruct kiocb kiocb;\n\tssize_t ret;\n\n\tif (WARN_ON_ONCE(!(file->f_mode & FMODE_WRITE)))\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_WRITE))\n\t\treturn -EINVAL;\n\t \n\tif (unlikely(!file->f_op->write_iter || file->f_op->write))\n\t\treturn warn_unsupported(file, \"write\");\n\n\tinit_sync_kiocb(&kiocb, file);\n\tkiocb.ki_pos = pos ? *pos : 0;\n\tret = file->f_op->write_iter(&kiocb, from);\n\tif (ret > 0) {\n\t\tif (pos)\n\t\t\t*pos = kiocb.ki_pos;\n\t\tfsnotify_modify(file);\n\t\tadd_wchar(current, ret);\n\t}\n\tinc_syscw(current);\n\treturn ret;\n}\n\n \nssize_t __kernel_write(struct file *file, const void *buf, size_t count, loff_t *pos)\n{\n\tstruct kvec iov = {\n\t\t.iov_base\t= (void *)buf,\n\t\t.iov_len\t= min_t(size_t, count, MAX_RW_COUNT),\n\t};\n\tstruct iov_iter iter;\n\tiov_iter_kvec(&iter, ITER_SOURCE, &iov, 1, iov.iov_len);\n\treturn __kernel_write_iter(file, &iter, pos);\n}\n \nEXPORT_SYMBOL_GPL(__kernel_write);\n\nssize_t kernel_write(struct file *file, const void *buf, size_t count,\n\t\t\t    loff_t *pos)\n{\n\tssize_t ret;\n\n\tret = rw_verify_area(WRITE, file, pos, count);\n\tif (ret)\n\t\treturn ret;\n\n\tfile_start_write(file);\n\tret =  __kernel_write(file, buf, count, pos);\n\tfile_end_write(file);\n\treturn ret;\n}\nEXPORT_SYMBOL(kernel_write);\n\nssize_t vfs_write(struct file *file, const char __user *buf, size_t count, loff_t *pos)\n{\n\tssize_t ret;\n\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_WRITE))\n\t\treturn -EINVAL;\n\tif (unlikely(!access_ok(buf, count)))\n\t\treturn -EFAULT;\n\n\tret = rw_verify_area(WRITE, file, pos, count);\n\tif (ret)\n\t\treturn ret;\n\tif (count > MAX_RW_COUNT)\n\t\tcount =  MAX_RW_COUNT;\n\tfile_start_write(file);\n\tif (file->f_op->write)\n\t\tret = file->f_op->write(file, buf, count, pos);\n\telse if (file->f_op->write_iter)\n\t\tret = new_sync_write(file, buf, count, pos);\n\telse\n\t\tret = -EINVAL;\n\tif (ret > 0) {\n\t\tfsnotify_modify(file);\n\t\tadd_wchar(current, ret);\n\t}\n\tinc_syscw(current);\n\tfile_end_write(file);\n\treturn ret;\n}\n\n \nstatic inline loff_t *file_ppos(struct file *file)\n{\n\treturn file->f_mode & FMODE_STREAM ? NULL : &file->f_pos;\n}\n\nssize_t ksys_read(unsigned int fd, char __user *buf, size_t count)\n{\n\tstruct fd f = fdget_pos(fd);\n\tssize_t ret = -EBADF;\n\n\tif (f.file) {\n\t\tloff_t pos, *ppos = file_ppos(f.file);\n\t\tif (ppos) {\n\t\t\tpos = *ppos;\n\t\t\tppos = &pos;\n\t\t}\n\t\tret = vfs_read(f.file, buf, count, ppos);\n\t\tif (ret >= 0 && ppos)\n\t\t\tf.file->f_pos = pos;\n\t\tfdput_pos(f);\n\t}\n\treturn ret;\n}\n\nSYSCALL_DEFINE3(read, unsigned int, fd, char __user *, buf, size_t, count)\n{\n\treturn ksys_read(fd, buf, count);\n}\n\nssize_t ksys_write(unsigned int fd, const char __user *buf, size_t count)\n{\n\tstruct fd f = fdget_pos(fd);\n\tssize_t ret = -EBADF;\n\n\tif (f.file) {\n\t\tloff_t pos, *ppos = file_ppos(f.file);\n\t\tif (ppos) {\n\t\t\tpos = *ppos;\n\t\t\tppos = &pos;\n\t\t}\n\t\tret = vfs_write(f.file, buf, count, ppos);\n\t\tif (ret >= 0 && ppos)\n\t\t\tf.file->f_pos = pos;\n\t\tfdput_pos(f);\n\t}\n\n\treturn ret;\n}\n\nSYSCALL_DEFINE3(write, unsigned int, fd, const char __user *, buf,\n\t\tsize_t, count)\n{\n\treturn ksys_write(fd, buf, count);\n}\n\nssize_t ksys_pread64(unsigned int fd, char __user *buf, size_t count,\n\t\t     loff_t pos)\n{\n\tstruct fd f;\n\tssize_t ret = -EBADF;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\n\tf = fdget(fd);\n\tif (f.file) {\n\t\tret = -ESPIPE;\n\t\tif (f.file->f_mode & FMODE_PREAD)\n\t\t\tret = vfs_read(f.file, buf, count, &pos);\n\t\tfdput(f);\n\t}\n\n\treturn ret;\n}\n\nSYSCALL_DEFINE4(pread64, unsigned int, fd, char __user *, buf,\n\t\t\tsize_t, count, loff_t, pos)\n{\n\treturn ksys_pread64(fd, buf, count, pos);\n}\n\n#if defined(CONFIG_COMPAT) && defined(__ARCH_WANT_COMPAT_PREAD64)\nCOMPAT_SYSCALL_DEFINE5(pread64, unsigned int, fd, char __user *, buf,\n\t\t       size_t, count, compat_arg_u64_dual(pos))\n{\n\treturn ksys_pread64(fd, buf, count, compat_arg_u64_glue(pos));\n}\n#endif\n\nssize_t ksys_pwrite64(unsigned int fd, const char __user *buf,\n\t\t      size_t count, loff_t pos)\n{\n\tstruct fd f;\n\tssize_t ret = -EBADF;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\n\tf = fdget(fd);\n\tif (f.file) {\n\t\tret = -ESPIPE;\n\t\tif (f.file->f_mode & FMODE_PWRITE)  \n\t\t\tret = vfs_write(f.file, buf, count, &pos);\n\t\tfdput(f);\n\t}\n\n\treturn ret;\n}\n\nSYSCALL_DEFINE4(pwrite64, unsigned int, fd, const char __user *, buf,\n\t\t\t size_t, count, loff_t, pos)\n{\n\treturn ksys_pwrite64(fd, buf, count, pos);\n}\n\n#if defined(CONFIG_COMPAT) && defined(__ARCH_WANT_COMPAT_PWRITE64)\nCOMPAT_SYSCALL_DEFINE5(pwrite64, unsigned int, fd, const char __user *, buf,\n\t\t       size_t, count, compat_arg_u64_dual(pos))\n{\n\treturn ksys_pwrite64(fd, buf, count, compat_arg_u64_glue(pos));\n}\n#endif\n\nstatic ssize_t do_iter_readv_writev(struct file *filp, struct iov_iter *iter,\n\t\tloff_t *ppos, int type, rwf_t flags)\n{\n\tstruct kiocb kiocb;\n\tssize_t ret;\n\n\tinit_sync_kiocb(&kiocb, filp);\n\tret = kiocb_set_rw_flags(&kiocb, flags);\n\tif (ret)\n\t\treturn ret;\n\tkiocb.ki_pos = (ppos ? *ppos : 0);\n\n\tif (type == READ)\n\t\tret = call_read_iter(filp, &kiocb, iter);\n\telse\n\t\tret = call_write_iter(filp, &kiocb, iter);\n\tBUG_ON(ret == -EIOCBQUEUED);\n\tif (ppos)\n\t\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}\n\n \nstatic ssize_t do_loop_readv_writev(struct file *filp, struct iov_iter *iter,\n\t\tloff_t *ppos, int type, rwf_t flags)\n{\n\tssize_t ret = 0;\n\n\tif (flags & ~RWF_HIPRI)\n\t\treturn -EOPNOTSUPP;\n\n\twhile (iov_iter_count(iter)) {\n\t\tssize_t nr;\n\n\t\tif (type == READ) {\n\t\t\tnr = filp->f_op->read(filp, iter_iov_addr(iter),\n\t\t\t\t\t\titer_iov_len(iter), ppos);\n\t\t} else {\n\t\t\tnr = filp->f_op->write(filp, iter_iov_addr(iter),\n\t\t\t\t\t\titer_iov_len(iter), ppos);\n\t\t}\n\n\t\tif (nr < 0) {\n\t\t\tif (!ret)\n\t\t\t\tret = nr;\n\t\t\tbreak;\n\t\t}\n\t\tret += nr;\n\t\tif (nr != iter_iov_len(iter))\n\t\t\tbreak;\n\t\tiov_iter_advance(iter, nr);\n\t}\n\n\treturn ret;\n}\n\nstatic ssize_t do_iter_read(struct file *file, struct iov_iter *iter,\n\t\tloff_t *pos, rwf_t flags)\n{\n\tsize_t tot_len;\n\tssize_t ret = 0;\n\n\tif (!(file->f_mode & FMODE_READ))\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_READ))\n\t\treturn -EINVAL;\n\n\ttot_len = iov_iter_count(iter);\n\tif (!tot_len)\n\t\tgoto out;\n\tret = rw_verify_area(READ, file, pos, tot_len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (file->f_op->read_iter)\n\t\tret = do_iter_readv_writev(file, iter, pos, READ, flags);\n\telse\n\t\tret = do_loop_readv_writev(file, iter, pos, READ, flags);\nout:\n\tif (ret >= 0)\n\t\tfsnotify_access(file);\n\treturn ret;\n}\n\nssize_t vfs_iocb_iter_read(struct file *file, struct kiocb *iocb,\n\t\t\t   struct iov_iter *iter)\n{\n\tsize_t tot_len;\n\tssize_t ret = 0;\n\n\tif (!file->f_op->read_iter)\n\t\treturn -EINVAL;\n\tif (!(file->f_mode & FMODE_READ))\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_READ))\n\t\treturn -EINVAL;\n\n\ttot_len = iov_iter_count(iter);\n\tif (!tot_len)\n\t\tgoto out;\n\tret = rw_verify_area(READ, file, &iocb->ki_pos, tot_len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = call_read_iter(file, iocb, iter);\nout:\n\tif (ret >= 0)\n\t\tfsnotify_access(file);\n\treturn ret;\n}\nEXPORT_SYMBOL(vfs_iocb_iter_read);\n\nssize_t vfs_iter_read(struct file *file, struct iov_iter *iter, loff_t *ppos,\n\t\trwf_t flags)\n{\n\tif (!file->f_op->read_iter)\n\t\treturn -EINVAL;\n\treturn do_iter_read(file, iter, ppos, flags);\n}\nEXPORT_SYMBOL(vfs_iter_read);\n\nstatic ssize_t do_iter_write(struct file *file, struct iov_iter *iter,\n\t\tloff_t *pos, rwf_t flags)\n{\n\tsize_t tot_len;\n\tssize_t ret = 0;\n\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_WRITE))\n\t\treturn -EINVAL;\n\n\ttot_len = iov_iter_count(iter);\n\tif (!tot_len)\n\t\treturn 0;\n\tret = rw_verify_area(WRITE, file, pos, tot_len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (file->f_op->write_iter)\n\t\tret = do_iter_readv_writev(file, iter, pos, WRITE, flags);\n\telse\n\t\tret = do_loop_readv_writev(file, iter, pos, WRITE, flags);\n\tif (ret > 0)\n\t\tfsnotify_modify(file);\n\treturn ret;\n}\n\nssize_t vfs_iocb_iter_write(struct file *file, struct kiocb *iocb,\n\t\t\t    struct iov_iter *iter)\n{\n\tsize_t tot_len;\n\tssize_t ret = 0;\n\n\tif (!file->f_op->write_iter)\n\t\treturn -EINVAL;\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_WRITE))\n\t\treturn -EINVAL;\n\n\ttot_len = iov_iter_count(iter);\n\tif (!tot_len)\n\t\treturn 0;\n\tret = rw_verify_area(WRITE, file, &iocb->ki_pos, tot_len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = call_write_iter(file, iocb, iter);\n\tif (ret > 0)\n\t\tfsnotify_modify(file);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(vfs_iocb_iter_write);\n\nssize_t vfs_iter_write(struct file *file, struct iov_iter *iter, loff_t *ppos,\n\t\trwf_t flags)\n{\n\tif (!file->f_op->write_iter)\n\t\treturn -EINVAL;\n\treturn do_iter_write(file, iter, ppos, flags);\n}\nEXPORT_SYMBOL(vfs_iter_write);\n\nstatic ssize_t vfs_readv(struct file *file, const struct iovec __user *vec,\n\t\t  unsigned long vlen, loff_t *pos, rwf_t flags)\n{\n\tstruct iovec iovstack[UIO_FASTIOV];\n\tstruct iovec *iov = iovstack;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tret = import_iovec(ITER_DEST, vec, vlen, ARRAY_SIZE(iovstack), &iov, &iter);\n\tif (ret >= 0) {\n\t\tret = do_iter_read(file, &iter, pos, flags);\n\t\tkfree(iov);\n\t}\n\n\treturn ret;\n}\n\nstatic ssize_t vfs_writev(struct file *file, const struct iovec __user *vec,\n\t\t   unsigned long vlen, loff_t *pos, rwf_t flags)\n{\n\tstruct iovec iovstack[UIO_FASTIOV];\n\tstruct iovec *iov = iovstack;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tret = import_iovec(ITER_SOURCE, vec, vlen, ARRAY_SIZE(iovstack), &iov, &iter);\n\tif (ret >= 0) {\n\t\tfile_start_write(file);\n\t\tret = do_iter_write(file, &iter, pos, flags);\n\t\tfile_end_write(file);\n\t\tkfree(iov);\n\t}\n\treturn ret;\n}\n\nstatic ssize_t do_readv(unsigned long fd, const struct iovec __user *vec,\n\t\t\tunsigned long vlen, rwf_t flags)\n{\n\tstruct fd f = fdget_pos(fd);\n\tssize_t ret = -EBADF;\n\n\tif (f.file) {\n\t\tloff_t pos, *ppos = file_ppos(f.file);\n\t\tif (ppos) {\n\t\t\tpos = *ppos;\n\t\t\tppos = &pos;\n\t\t}\n\t\tret = vfs_readv(f.file, vec, vlen, ppos, flags);\n\t\tif (ret >= 0 && ppos)\n\t\t\tf.file->f_pos = pos;\n\t\tfdput_pos(f);\n\t}\n\n\tif (ret > 0)\n\t\tadd_rchar(current, ret);\n\tinc_syscr(current);\n\treturn ret;\n}\n\nstatic ssize_t do_writev(unsigned long fd, const struct iovec __user *vec,\n\t\t\t unsigned long vlen, rwf_t flags)\n{\n\tstruct fd f = fdget_pos(fd);\n\tssize_t ret = -EBADF;\n\n\tif (f.file) {\n\t\tloff_t pos, *ppos = file_ppos(f.file);\n\t\tif (ppos) {\n\t\t\tpos = *ppos;\n\t\t\tppos = &pos;\n\t\t}\n\t\tret = vfs_writev(f.file, vec, vlen, ppos, flags);\n\t\tif (ret >= 0 && ppos)\n\t\t\tf.file->f_pos = pos;\n\t\tfdput_pos(f);\n\t}\n\n\tif (ret > 0)\n\t\tadd_wchar(current, ret);\n\tinc_syscw(current);\n\treturn ret;\n}\n\nstatic inline loff_t pos_from_hilo(unsigned long high, unsigned long low)\n{\n#define HALF_LONG_BITS (BITS_PER_LONG / 2)\n\treturn (((loff_t)high << HALF_LONG_BITS) << HALF_LONG_BITS) | low;\n}\n\nstatic ssize_t do_preadv(unsigned long fd, const struct iovec __user *vec,\n\t\t\t unsigned long vlen, loff_t pos, rwf_t flags)\n{\n\tstruct fd f;\n\tssize_t ret = -EBADF;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\n\tf = fdget(fd);\n\tif (f.file) {\n\t\tret = -ESPIPE;\n\t\tif (f.file->f_mode & FMODE_PREAD)\n\t\t\tret = vfs_readv(f.file, vec, vlen, &pos, flags);\n\t\tfdput(f);\n\t}\n\n\tif (ret > 0)\n\t\tadd_rchar(current, ret);\n\tinc_syscr(current);\n\treturn ret;\n}\n\nstatic ssize_t do_pwritev(unsigned long fd, const struct iovec __user *vec,\n\t\t\t  unsigned long vlen, loff_t pos, rwf_t flags)\n{\n\tstruct fd f;\n\tssize_t ret = -EBADF;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\n\tf = fdget(fd);\n\tif (f.file) {\n\t\tret = -ESPIPE;\n\t\tif (f.file->f_mode & FMODE_PWRITE)\n\t\t\tret = vfs_writev(f.file, vec, vlen, &pos, flags);\n\t\tfdput(f);\n\t}\n\n\tif (ret > 0)\n\t\tadd_wchar(current, ret);\n\tinc_syscw(current);\n\treturn ret;\n}\n\nSYSCALL_DEFINE3(readv, unsigned long, fd, const struct iovec __user *, vec,\n\t\tunsigned long, vlen)\n{\n\treturn do_readv(fd, vec, vlen, 0);\n}\n\nSYSCALL_DEFINE3(writev, unsigned long, fd, const struct iovec __user *, vec,\n\t\tunsigned long, vlen)\n{\n\treturn do_writev(fd, vec, vlen, 0);\n}\n\nSYSCALL_DEFINE5(preadv, unsigned long, fd, const struct iovec __user *, vec,\n\t\tunsigned long, vlen, unsigned long, pos_l, unsigned long, pos_h)\n{\n\tloff_t pos = pos_from_hilo(pos_h, pos_l);\n\n\treturn do_preadv(fd, vec, vlen, pos, 0);\n}\n\nSYSCALL_DEFINE6(preadv2, unsigned long, fd, const struct iovec __user *, vec,\n\t\tunsigned long, vlen, unsigned long, pos_l, unsigned long, pos_h,\n\t\trwf_t, flags)\n{\n\tloff_t pos = pos_from_hilo(pos_h, pos_l);\n\n\tif (pos == -1)\n\t\treturn do_readv(fd, vec, vlen, flags);\n\n\treturn do_preadv(fd, vec, vlen, pos, flags);\n}\n\nSYSCALL_DEFINE5(pwritev, unsigned long, fd, const struct iovec __user *, vec,\n\t\tunsigned long, vlen, unsigned long, pos_l, unsigned long, pos_h)\n{\n\tloff_t pos = pos_from_hilo(pos_h, pos_l);\n\n\treturn do_pwritev(fd, vec, vlen, pos, 0);\n}\n\nSYSCALL_DEFINE6(pwritev2, unsigned long, fd, const struct iovec __user *, vec,\n\t\tunsigned long, vlen, unsigned long, pos_l, unsigned long, pos_h,\n\t\trwf_t, flags)\n{\n\tloff_t pos = pos_from_hilo(pos_h, pos_l);\n\n\tif (pos == -1)\n\t\treturn do_writev(fd, vec, vlen, flags);\n\n\treturn do_pwritev(fd, vec, vlen, pos, flags);\n}\n\n \n#ifdef CONFIG_COMPAT\n#ifdef __ARCH_WANT_COMPAT_SYS_PREADV64\nCOMPAT_SYSCALL_DEFINE4(preadv64, unsigned long, fd,\n\t\tconst struct iovec __user *, vec,\n\t\tunsigned long, vlen, loff_t, pos)\n{\n\treturn do_preadv(fd, vec, vlen, pos, 0);\n}\n#endif\n\nCOMPAT_SYSCALL_DEFINE5(preadv, compat_ulong_t, fd,\n\t\tconst struct iovec __user *, vec,\n\t\tcompat_ulong_t, vlen, u32, pos_low, u32, pos_high)\n{\n\tloff_t pos = ((loff_t)pos_high << 32) | pos_low;\n\n\treturn do_preadv(fd, vec, vlen, pos, 0);\n}\n\n#ifdef __ARCH_WANT_COMPAT_SYS_PREADV64V2\nCOMPAT_SYSCALL_DEFINE5(preadv64v2, unsigned long, fd,\n\t\tconst struct iovec __user *, vec,\n\t\tunsigned long, vlen, loff_t, pos, rwf_t, flags)\n{\n\tif (pos == -1)\n\t\treturn do_readv(fd, vec, vlen, flags);\n\treturn do_preadv(fd, vec, vlen, pos, flags);\n}\n#endif\n\nCOMPAT_SYSCALL_DEFINE6(preadv2, compat_ulong_t, fd,\n\t\tconst struct iovec __user *, vec,\n\t\tcompat_ulong_t, vlen, u32, pos_low, u32, pos_high,\n\t\trwf_t, flags)\n{\n\tloff_t pos = ((loff_t)pos_high << 32) | pos_low;\n\n\tif (pos == -1)\n\t\treturn do_readv(fd, vec, vlen, flags);\n\treturn do_preadv(fd, vec, vlen, pos, flags);\n}\n\n#ifdef __ARCH_WANT_COMPAT_SYS_PWRITEV64\nCOMPAT_SYSCALL_DEFINE4(pwritev64, unsigned long, fd,\n\t\tconst struct iovec __user *, vec,\n\t\tunsigned long, vlen, loff_t, pos)\n{\n\treturn do_pwritev(fd, vec, vlen, pos, 0);\n}\n#endif\n\nCOMPAT_SYSCALL_DEFINE5(pwritev, compat_ulong_t, fd,\n\t\tconst struct iovec __user *,vec,\n\t\tcompat_ulong_t, vlen, u32, pos_low, u32, pos_high)\n{\n\tloff_t pos = ((loff_t)pos_high << 32) | pos_low;\n\n\treturn do_pwritev(fd, vec, vlen, pos, 0);\n}\n\n#ifdef __ARCH_WANT_COMPAT_SYS_PWRITEV64V2\nCOMPAT_SYSCALL_DEFINE5(pwritev64v2, unsigned long, fd,\n\t\tconst struct iovec __user *, vec,\n\t\tunsigned long, vlen, loff_t, pos, rwf_t, flags)\n{\n\tif (pos == -1)\n\t\treturn do_writev(fd, vec, vlen, flags);\n\treturn do_pwritev(fd, vec, vlen, pos, flags);\n}\n#endif\n\nCOMPAT_SYSCALL_DEFINE6(pwritev2, compat_ulong_t, fd,\n\t\tconst struct iovec __user *,vec,\n\t\tcompat_ulong_t, vlen, u32, pos_low, u32, pos_high, rwf_t, flags)\n{\n\tloff_t pos = ((loff_t)pos_high << 32) | pos_low;\n\n\tif (pos == -1)\n\t\treturn do_writev(fd, vec, vlen, flags);\n\treturn do_pwritev(fd, vec, vlen, pos, flags);\n}\n#endif  \n\nstatic ssize_t do_sendfile(int out_fd, int in_fd, loff_t *ppos,\n\t\t  \t   size_t count, loff_t max)\n{\n\tstruct fd in, out;\n\tstruct inode *in_inode, *out_inode;\n\tstruct pipe_inode_info *opipe;\n\tloff_t pos;\n\tloff_t out_pos;\n\tssize_t retval;\n\tint fl;\n\n\t \n\tretval = -EBADF;\n\tin = fdget(in_fd);\n\tif (!in.file)\n\t\tgoto out;\n\tif (!(in.file->f_mode & FMODE_READ))\n\t\tgoto fput_in;\n\tretval = -ESPIPE;\n\tif (!ppos) {\n\t\tpos = in.file->f_pos;\n\t} else {\n\t\tpos = *ppos;\n\t\tif (!(in.file->f_mode & FMODE_PREAD))\n\t\t\tgoto fput_in;\n\t}\n\tretval = rw_verify_area(READ, in.file, &pos, count);\n\tif (retval < 0)\n\t\tgoto fput_in;\n\tif (count > MAX_RW_COUNT)\n\t\tcount =  MAX_RW_COUNT;\n\n\t \n\tretval = -EBADF;\n\tout = fdget(out_fd);\n\tif (!out.file)\n\t\tgoto fput_in;\n\tif (!(out.file->f_mode & FMODE_WRITE))\n\t\tgoto fput_out;\n\tin_inode = file_inode(in.file);\n\tout_inode = file_inode(out.file);\n\tout_pos = out.file->f_pos;\n\n\tif (!max)\n\t\tmax = min(in_inode->i_sb->s_maxbytes, out_inode->i_sb->s_maxbytes);\n\n\tif (unlikely(pos + count > max)) {\n\t\tretval = -EOVERFLOW;\n\t\tif (pos >= max)\n\t\t\tgoto fput_out;\n\t\tcount = max - pos;\n\t}\n\n\tfl = 0;\n#if 0\n\t \n\tif (in.file->f_flags & O_NONBLOCK)\n\t\tfl = SPLICE_F_NONBLOCK;\n#endif\n\topipe = get_pipe_info(out.file, true);\n\tif (!opipe) {\n\t\tretval = rw_verify_area(WRITE, out.file, &out_pos, count);\n\t\tif (retval < 0)\n\t\t\tgoto fput_out;\n\t\tfile_start_write(out.file);\n\t\tretval = do_splice_direct(in.file, &pos, out.file, &out_pos,\n\t\t\t\t\t  count, fl);\n\t\tfile_end_write(out.file);\n\t} else {\n\t\tif (out.file->f_flags & O_NONBLOCK)\n\t\t\tfl |= SPLICE_F_NONBLOCK;\n\n\t\tretval = splice_file_to_pipe(in.file, opipe, &pos, count, fl);\n\t}\n\n\tif (retval > 0) {\n\t\tadd_rchar(current, retval);\n\t\tadd_wchar(current, retval);\n\t\tfsnotify_access(in.file);\n\t\tfsnotify_modify(out.file);\n\t\tout.file->f_pos = out_pos;\n\t\tif (ppos)\n\t\t\t*ppos = pos;\n\t\telse\n\t\t\tin.file->f_pos = pos;\n\t}\n\n\tinc_syscr(current);\n\tinc_syscw(current);\n\tif (pos > max)\n\t\tretval = -EOVERFLOW;\n\nfput_out:\n\tfdput(out);\nfput_in:\n\tfdput(in);\nout:\n\treturn retval;\n}\n\nSYSCALL_DEFINE4(sendfile, int, out_fd, int, in_fd, off_t __user *, offset, size_t, count)\n{\n\tloff_t pos;\n\toff_t off;\n\tssize_t ret;\n\n\tif (offset) {\n\t\tif (unlikely(get_user(off, offset)))\n\t\t\treturn -EFAULT;\n\t\tpos = off;\n\t\tret = do_sendfile(out_fd, in_fd, &pos, count, MAX_NON_LFS);\n\t\tif (unlikely(put_user(pos, offset)))\n\t\t\treturn -EFAULT;\n\t\treturn ret;\n\t}\n\n\treturn do_sendfile(out_fd, in_fd, NULL, count, 0);\n}\n\nSYSCALL_DEFINE4(sendfile64, int, out_fd, int, in_fd, loff_t __user *, offset, size_t, count)\n{\n\tloff_t pos;\n\tssize_t ret;\n\n\tif (offset) {\n\t\tif (unlikely(copy_from_user(&pos, offset, sizeof(loff_t))))\n\t\t\treturn -EFAULT;\n\t\tret = do_sendfile(out_fd, in_fd, &pos, count, 0);\n\t\tif (unlikely(put_user(pos, offset)))\n\t\t\treturn -EFAULT;\n\t\treturn ret;\n\t}\n\n\treturn do_sendfile(out_fd, in_fd, NULL, count, 0);\n}\n\n#ifdef CONFIG_COMPAT\nCOMPAT_SYSCALL_DEFINE4(sendfile, int, out_fd, int, in_fd,\n\t\tcompat_off_t __user *, offset, compat_size_t, count)\n{\n\tloff_t pos;\n\toff_t off;\n\tssize_t ret;\n\n\tif (offset) {\n\t\tif (unlikely(get_user(off, offset)))\n\t\t\treturn -EFAULT;\n\t\tpos = off;\n\t\tret = do_sendfile(out_fd, in_fd, &pos, count, MAX_NON_LFS);\n\t\tif (unlikely(put_user(pos, offset)))\n\t\t\treturn -EFAULT;\n\t\treturn ret;\n\t}\n\n\treturn do_sendfile(out_fd, in_fd, NULL, count, 0);\n}\n\nCOMPAT_SYSCALL_DEFINE4(sendfile64, int, out_fd, int, in_fd,\n\t\tcompat_loff_t __user *, offset, compat_size_t, count)\n{\n\tloff_t pos;\n\tssize_t ret;\n\n\tif (offset) {\n\t\tif (unlikely(copy_from_user(&pos, offset, sizeof(loff_t))))\n\t\t\treturn -EFAULT;\n\t\tret = do_sendfile(out_fd, in_fd, &pos, count, 0);\n\t\tif (unlikely(put_user(pos, offset)))\n\t\t\treturn -EFAULT;\n\t\treturn ret;\n\t}\n\n\treturn do_sendfile(out_fd, in_fd, NULL, count, 0);\n}\n#endif\n\n \n\nssize_t generic_copy_file_range(struct file *file_in, loff_t pos_in,\n\t\t\t\tstruct file *file_out, loff_t pos_out,\n\t\t\t\tsize_t len, unsigned int flags)\n{\n\tlockdep_assert(sb_write_started(file_inode(file_out)->i_sb));\n\n\treturn do_splice_direct(file_in, &pos_in, file_out, &pos_out,\n\t\t\t\tlen > MAX_RW_COUNT ? MAX_RW_COUNT : len, 0);\n}\nEXPORT_SYMBOL(generic_copy_file_range);\n\n \nstatic int generic_copy_file_checks(struct file *file_in, loff_t pos_in,\n\t\t\t\t    struct file *file_out, loff_t pos_out,\n\t\t\t\t    size_t *req_count, unsigned int flags)\n{\n\tstruct inode *inode_in = file_inode(file_in);\n\tstruct inode *inode_out = file_inode(file_out);\n\tuint64_t count = *req_count;\n\tloff_t size_in;\n\tint ret;\n\n\tret = generic_file_rw_checks(file_in, file_out);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (flags & COPY_FILE_SPLICE) {\n\t\t \n\t} else if (file_out->f_op->copy_file_range) {\n\t\tif (file_in->f_op->copy_file_range !=\n\t\t    file_out->f_op->copy_file_range)\n\t\t\treturn -EXDEV;\n\t} else if (file_inode(file_in)->i_sb != file_inode(file_out)->i_sb) {\n\t\treturn -EXDEV;\n\t}\n\n\t \n\tif (IS_IMMUTABLE(inode_out))\n\t\treturn -EPERM;\n\n\tif (IS_SWAPFILE(inode_in) || IS_SWAPFILE(inode_out))\n\t\treturn -ETXTBSY;\n\n\t \n\tif (pos_in + count < pos_in || pos_out + count < pos_out)\n\t\treturn -EOVERFLOW;\n\n\t \n\tsize_in = i_size_read(inode_in);\n\tif (pos_in >= size_in)\n\t\tcount = 0;\n\telse\n\t\tcount = min(count, size_in - (uint64_t)pos_in);\n\n\tret = generic_write_check_limits(file_out, pos_out, &count);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (inode_in == inode_out &&\n\t    pos_out + count > pos_in &&\n\t    pos_out < pos_in + count)\n\t\treturn -EINVAL;\n\n\t*req_count = count;\n\treturn 0;\n}\n\n \nssize_t vfs_copy_file_range(struct file *file_in, loff_t pos_in,\n\t\t\t    struct file *file_out, loff_t pos_out,\n\t\t\t    size_t len, unsigned int flags)\n{\n\tssize_t ret;\n\tbool splice = flags & COPY_FILE_SPLICE;\n\n\tif (flags & ~COPY_FILE_SPLICE)\n\t\treturn -EINVAL;\n\n\tret = generic_copy_file_checks(file_in, pos_in, file_out, pos_out, &len,\n\t\t\t\t       flags);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tret = rw_verify_area(READ, file_in, &pos_in, len);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tret = rw_verify_area(WRITE, file_out, &pos_out, len);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tif (len == 0)\n\t\treturn 0;\n\n\tfile_start_write(file_out);\n\n\t \n\tif (!splice && file_out->f_op->copy_file_range) {\n\t\tret = file_out->f_op->copy_file_range(file_in, pos_in,\n\t\t\t\t\t\t      file_out, pos_out,\n\t\t\t\t\t\t      len, flags);\n\t\tgoto done;\n\t}\n\n\tif (!splice && file_in->f_op->remap_file_range &&\n\t    file_inode(file_in)->i_sb == file_inode(file_out)->i_sb) {\n\t\tret = file_in->f_op->remap_file_range(file_in, pos_in,\n\t\t\t\tfile_out, pos_out,\n\t\t\t\tmin_t(loff_t, MAX_RW_COUNT, len),\n\t\t\t\tREMAP_FILE_CAN_SHORTEN);\n\t\tif (ret > 0)\n\t\t\tgoto done;\n\t}\n\n\t \n\tret = generic_copy_file_range(file_in, pos_in, file_out, pos_out, len,\n\t\t\t\t      flags);\n\ndone:\n\tif (ret > 0) {\n\t\tfsnotify_access(file_in);\n\t\tadd_rchar(current, ret);\n\t\tfsnotify_modify(file_out);\n\t\tadd_wchar(current, ret);\n\t}\n\n\tinc_syscr(current);\n\tinc_syscw(current);\n\n\tfile_end_write(file_out);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(vfs_copy_file_range);\n\nSYSCALL_DEFINE6(copy_file_range, int, fd_in, loff_t __user *, off_in,\n\t\tint, fd_out, loff_t __user *, off_out,\n\t\tsize_t, len, unsigned int, flags)\n{\n\tloff_t pos_in;\n\tloff_t pos_out;\n\tstruct fd f_in;\n\tstruct fd f_out;\n\tssize_t ret = -EBADF;\n\n\tf_in = fdget(fd_in);\n\tif (!f_in.file)\n\t\tgoto out2;\n\n\tf_out = fdget(fd_out);\n\tif (!f_out.file)\n\t\tgoto out1;\n\n\tret = -EFAULT;\n\tif (off_in) {\n\t\tif (copy_from_user(&pos_in, off_in, sizeof(loff_t)))\n\t\t\tgoto out;\n\t} else {\n\t\tpos_in = f_in.file->f_pos;\n\t}\n\n\tif (off_out) {\n\t\tif (copy_from_user(&pos_out, off_out, sizeof(loff_t)))\n\t\t\tgoto out;\n\t} else {\n\t\tpos_out = f_out.file->f_pos;\n\t}\n\n\tret = -EINVAL;\n\tif (flags != 0)\n\t\tgoto out;\n\n\tret = vfs_copy_file_range(f_in.file, pos_in, f_out.file, pos_out, len,\n\t\t\t\t  flags);\n\tif (ret > 0) {\n\t\tpos_in += ret;\n\t\tpos_out += ret;\n\n\t\tif (off_in) {\n\t\t\tif (copy_to_user(off_in, &pos_in, sizeof(loff_t)))\n\t\t\t\tret = -EFAULT;\n\t\t} else {\n\t\t\tf_in.file->f_pos = pos_in;\n\t\t}\n\n\t\tif (off_out) {\n\t\t\tif (copy_to_user(off_out, &pos_out, sizeof(loff_t)))\n\t\t\t\tret = -EFAULT;\n\t\t} else {\n\t\t\tf_out.file->f_pos = pos_out;\n\t\t}\n\t}\n\nout:\n\tfdput(f_out);\nout1:\n\tfdput(f_in);\nout2:\n\treturn ret;\n}\n\n \nint generic_write_check_limits(struct file *file, loff_t pos, loff_t *count)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tloff_t max_size = inode->i_sb->s_maxbytes;\n\tloff_t limit = rlimit(RLIMIT_FSIZE);\n\n\tif (limit != RLIM_INFINITY) {\n\t\tif (pos >= limit) {\n\t\t\tsend_sig(SIGXFSZ, current, 0);\n\t\t\treturn -EFBIG;\n\t\t}\n\t\t*count = min(*count, limit - pos);\n\t}\n\n\tif (!(file->f_flags & O_LARGEFILE))\n\t\tmax_size = MAX_NON_LFS;\n\n\tif (unlikely(pos >= max_size))\n\t\treturn -EFBIG;\n\n\t*count = min(*count, max_size - pos);\n\n\treturn 0;\n}\n\n \nint generic_write_checks_count(struct kiocb *iocb, loff_t *count)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file->f_mapping->host;\n\n\tif (IS_SWAPFILE(inode))\n\t\treturn -ETXTBSY;\n\n\tif (!*count)\n\t\treturn 0;\n\n\tif (iocb->ki_flags & IOCB_APPEND)\n\t\tiocb->ki_pos = i_size_read(inode);\n\n\tif ((iocb->ki_flags & IOCB_NOWAIT) &&\n\t    !((iocb->ki_flags & IOCB_DIRECT) ||\n\t      (file->f_mode & FMODE_BUF_WASYNC)))\n\t\treturn -EINVAL;\n\n\treturn generic_write_check_limits(iocb->ki_filp, iocb->ki_pos, count);\n}\nEXPORT_SYMBOL(generic_write_checks_count);\n\n \nssize_t generic_write_checks(struct kiocb *iocb, struct iov_iter *from)\n{\n\tloff_t count = iov_iter_count(from);\n\tint ret;\n\n\tret = generic_write_checks_count(iocb, &count);\n\tif (ret)\n\t\treturn ret;\n\n\tiov_iter_truncate(from, count);\n\treturn iov_iter_count(from);\n}\nEXPORT_SYMBOL(generic_write_checks);\n\n \nint generic_file_rw_checks(struct file *file_in, struct file *file_out)\n{\n\tstruct inode *inode_in = file_inode(file_in);\n\tstruct inode *inode_out = file_inode(file_out);\n\n\t \n\tif (S_ISDIR(inode_in->i_mode) || S_ISDIR(inode_out->i_mode))\n\t\treturn -EISDIR;\n\tif (!S_ISREG(inode_in->i_mode) || !S_ISREG(inode_out->i_mode))\n\t\treturn -EINVAL;\n\n\tif (!(file_in->f_mode & FMODE_READ) ||\n\t    !(file_out->f_mode & FMODE_WRITE) ||\n\t    (file_out->f_flags & O_APPEND))\n\t\treturn -EBADF;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}