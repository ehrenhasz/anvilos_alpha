{
  "module_name": "super.c",
  "hash_id": "f5bc557a98119c59731a7b04597787e3c2c0678c60fd19ee5873fcd2fd750f22",
  "original_prompt": "Ingested from linux-6.6.14/fs/zonefs/super.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/pagemap.h>\n#include <linux/magic.h>\n#include <linux/iomap.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/parser.h>\n#include <linux/uio.h>\n#include <linux/mman.h>\n#include <linux/sched/mm.h>\n#include <linux/crc32.h>\n#include <linux/task_io_accounting_ops.h>\n\n#include \"zonefs.h\"\n\n#define CREATE_TRACE_POINTS\n#include \"trace.h\"\n\n \nstatic const char *zonefs_zgroup_name(enum zonefs_ztype ztype)\n{\n\tswitch (ztype) {\n\tcase ZONEFS_ZTYPE_CNV:\n\t\treturn \"cnv\";\n\tcase ZONEFS_ZTYPE_SEQ:\n\t\treturn \"seq\";\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn \"???\";\n\t}\n}\n\n \nstatic void zonefs_account_active(struct super_block *sb,\n\t\t\t\t  struct zonefs_zone *z)\n{\n\tstruct zonefs_sb_info *sbi = ZONEFS_SB(sb);\n\n\tif (zonefs_zone_is_cnv(z))\n\t\treturn;\n\n\t \n\tif (z->z_flags & (ZONEFS_ZONE_OFFLINE | ZONEFS_ZONE_READONLY))\n\t\tgoto out;\n\n\t \n\tif ((z->z_flags & ZONEFS_ZONE_OPEN) ||\n\t    (z->z_wpoffset > 0 && z->z_wpoffset < z->z_capacity)) {\n\t\tif (!(z->z_flags & ZONEFS_ZONE_ACTIVE)) {\n\t\t\tz->z_flags |= ZONEFS_ZONE_ACTIVE;\n\t\t\tatomic_inc(&sbi->s_active_seq_files);\n\t\t}\n\t\treturn;\n\t}\n\nout:\n\t \n\tif (z->z_flags & ZONEFS_ZONE_ACTIVE) {\n\t\tz->z_flags &= ~ZONEFS_ZONE_ACTIVE;\n\t\tatomic_dec(&sbi->s_active_seq_files);\n\t}\n}\n\n \nvoid zonefs_inode_account_active(struct inode *inode)\n{\n\tlockdep_assert_held(&ZONEFS_I(inode)->i_truncate_mutex);\n\n\treturn zonefs_account_active(inode->i_sb, zonefs_inode_zone(inode));\n}\n\n \nstatic int zonefs_zone_mgmt(struct super_block *sb,\n\t\t\t    struct zonefs_zone *z, enum req_op op)\n{\n\tint ret;\n\n\t \n\tif (op == REQ_OP_ZONE_CLOSE && !z->z_wpoffset)\n\t\top = REQ_OP_ZONE_RESET;\n\n\ttrace_zonefs_zone_mgmt(sb, z, op);\n\tret = blkdev_zone_mgmt(sb->s_bdev, op, z->z_sector,\n\t\t\t       z->z_size >> SECTOR_SHIFT, GFP_NOFS);\n\tif (ret) {\n\t\tzonefs_err(sb,\n\t\t\t   \"Zone management operation %s at %llu failed %d\\n\",\n\t\t\t   blk_op_str(op), z->z_sector, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint zonefs_inode_zone_mgmt(struct inode *inode, enum req_op op)\n{\n\tlockdep_assert_held(&ZONEFS_I(inode)->i_truncate_mutex);\n\n\treturn zonefs_zone_mgmt(inode->i_sb, zonefs_inode_zone(inode), op);\n}\n\nvoid zonefs_i_size_write(struct inode *inode, loff_t isize)\n{\n\tstruct zonefs_zone *z = zonefs_inode_zone(inode);\n\n\ti_size_write(inode, isize);\n\n\t \n\tif (isize >= z->z_capacity) {\n\t\tstruct zonefs_sb_info *sbi = ZONEFS_SB(inode->i_sb);\n\n\t\tif (z->z_flags & ZONEFS_ZONE_ACTIVE)\n\t\t\tatomic_dec(&sbi->s_active_seq_files);\n\t\tz->z_flags &= ~(ZONEFS_ZONE_OPEN | ZONEFS_ZONE_ACTIVE);\n\t}\n}\n\nvoid zonefs_update_stats(struct inode *inode, loff_t new_isize)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct zonefs_sb_info *sbi = ZONEFS_SB(sb);\n\tloff_t old_isize = i_size_read(inode);\n\tloff_t nr_blocks;\n\n\tif (new_isize == old_isize)\n\t\treturn;\n\n\tspin_lock(&sbi->s_lock);\n\n\t \n\tif (new_isize < old_isize) {\n\t\tnr_blocks = (old_isize - new_isize) >> sb->s_blocksize_bits;\n\t\tif (sbi->s_used_blocks > nr_blocks)\n\t\t\tsbi->s_used_blocks -= nr_blocks;\n\t\telse\n\t\t\tsbi->s_used_blocks = 0;\n\t} else {\n\t\tsbi->s_used_blocks +=\n\t\t\t(new_isize - old_isize) >> sb->s_blocksize_bits;\n\t\tif (sbi->s_used_blocks > sbi->s_blocks)\n\t\t\tsbi->s_used_blocks = sbi->s_blocks;\n\t}\n\n\tspin_unlock(&sbi->s_lock);\n}\n\n \nstatic loff_t zonefs_check_zone_condition(struct super_block *sb,\n\t\t\t\t\t  struct zonefs_zone *z,\n\t\t\t\t\t  struct blk_zone *zone)\n{\n\tswitch (zone->cond) {\n\tcase BLK_ZONE_COND_OFFLINE:\n\t\tzonefs_warn(sb, \"Zone %llu: offline zone\\n\",\n\t\t\t    z->z_sector);\n\t\tz->z_flags |= ZONEFS_ZONE_OFFLINE;\n\t\treturn 0;\n\tcase BLK_ZONE_COND_READONLY:\n\t\t \n\t\tzonefs_warn(sb, \"Zone %llu: read-only zone\\n\",\n\t\t\t    z->z_sector);\n\t\tz->z_flags |= ZONEFS_ZONE_READONLY;\n\t\tif (zonefs_zone_is_cnv(z))\n\t\t\treturn z->z_capacity;\n\t\treturn z->z_wpoffset;\n\tcase BLK_ZONE_COND_FULL:\n\t\t \n\t\treturn z->z_capacity;\n\tdefault:\n\t\tif (zonefs_zone_is_cnv(z))\n\t\t\treturn z->z_capacity;\n\t\treturn (zone->wp - zone->start) << SECTOR_SHIFT;\n\t}\n}\n\n \nstatic void zonefs_inode_update_mode(struct inode *inode)\n{\n\tstruct zonefs_zone *z = zonefs_inode_zone(inode);\n\n\tif (z->z_flags & ZONEFS_ZONE_OFFLINE) {\n\t\t \n\t\tinode->i_flags |= S_IMMUTABLE;\n\t\tinode->i_mode &= ~0777;\n\t} else if (z->z_flags & ZONEFS_ZONE_READONLY) {\n\t\t \n\t\tinode->i_flags |= S_IMMUTABLE;\n\t\tif (z->z_flags & ZONEFS_ZONE_INIT_MODE)\n\t\t\tinode->i_mode &= ~0777;\n\t\telse\n\t\t\tinode->i_mode &= ~0222;\n\t}\n\n\tz->z_flags &= ~ZONEFS_ZONE_INIT_MODE;\n\tz->z_mode = inode->i_mode;\n}\n\nstruct zonefs_ioerr_data {\n\tstruct inode\t*inode;\n\tbool\t\twrite;\n};\n\nstatic int zonefs_io_error_cb(struct blk_zone *zone, unsigned int idx,\n\t\t\t      void *data)\n{\n\tstruct zonefs_ioerr_data *err = data;\n\tstruct inode *inode = err->inode;\n\tstruct zonefs_zone *z = zonefs_inode_zone(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct zonefs_sb_info *sbi = ZONEFS_SB(sb);\n\tloff_t isize, data_size;\n\n\t \n\tdata_size = zonefs_check_zone_condition(sb, z, zone);\n\tisize = i_size_read(inode);\n\tif (!(z->z_flags & (ZONEFS_ZONE_READONLY | ZONEFS_ZONE_OFFLINE)) &&\n\t    !err->write && isize == data_size)\n\t\treturn 0;\n\n\t \n\tif (zonefs_zone_is_seq(z) && isize != data_size)\n\t\tzonefs_warn(sb,\n\t\t\t    \"inode %lu: invalid size %lld (should be %lld)\\n\",\n\t\t\t    inode->i_ino, isize, data_size);\n\n\t \n\tif ((z->z_flags & ZONEFS_ZONE_OFFLINE) ||\n\t    (sbi->s_mount_opts & ZONEFS_MNTOPT_ERRORS_ZOL)) {\n\t\tzonefs_warn(sb, \"inode %lu: read/write access disabled\\n\",\n\t\t\t    inode->i_ino);\n\t\tif (!(z->z_flags & ZONEFS_ZONE_OFFLINE))\n\t\t\tz->z_flags |= ZONEFS_ZONE_OFFLINE;\n\t\tzonefs_inode_update_mode(inode);\n\t\tdata_size = 0;\n\t} else if ((z->z_flags & ZONEFS_ZONE_READONLY) ||\n\t\t   (sbi->s_mount_opts & ZONEFS_MNTOPT_ERRORS_ZRO)) {\n\t\tzonefs_warn(sb, \"inode %lu: write access disabled\\n\",\n\t\t\t    inode->i_ino);\n\t\tif (!(z->z_flags & ZONEFS_ZONE_READONLY))\n\t\t\tz->z_flags |= ZONEFS_ZONE_READONLY;\n\t\tzonefs_inode_update_mode(inode);\n\t\tdata_size = isize;\n\t} else if (sbi->s_mount_opts & ZONEFS_MNTOPT_ERRORS_RO &&\n\t\t   data_size > isize) {\n\t\t \n\t\tdata_size = isize;\n\t}\n\n\t \n\tif ((sbi->s_mount_opts & ZONEFS_MNTOPT_EXPLICIT_OPEN) &&\n\t    (z->z_flags & (ZONEFS_ZONE_READONLY | ZONEFS_ZONE_OFFLINE)))\n\t\tz->z_flags &= ~ZONEFS_ZONE_OPEN;\n\n\t \n\tif ((sbi->s_mount_opts & ZONEFS_MNTOPT_ERRORS_RO) && !sb_rdonly(sb)) {\n\t\tzonefs_warn(sb, \"remounting filesystem read-only\\n\");\n\t\tsb->s_flags |= SB_RDONLY;\n\t}\n\n\t \n\tzonefs_update_stats(inode, data_size);\n\tzonefs_i_size_write(inode, data_size);\n\tz->z_wpoffset = data_size;\n\tzonefs_inode_account_active(inode);\n\n\treturn 0;\n}\n\n \nvoid __zonefs_io_error(struct inode *inode, bool write)\n{\n\tstruct zonefs_zone *z = zonefs_inode_zone(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct zonefs_sb_info *sbi = ZONEFS_SB(sb);\n\tunsigned int noio_flag;\n\tunsigned int nr_zones = 1;\n\tstruct zonefs_ioerr_data err = {\n\t\t.inode = inode,\n\t\t.write = write,\n\t};\n\tint ret;\n\n\t \n\tif (z->z_size > bdev_zone_sectors(sb->s_bdev))\n\t\tnr_zones = z->z_size >>\n\t\t\t(sbi->s_zone_sectors_shift + SECTOR_SHIFT);\n\n\t \n\tnoio_flag = memalloc_noio_save();\n\tret = blkdev_report_zones(sb->s_bdev, z->z_sector, nr_zones,\n\t\t\t\t  zonefs_io_error_cb, &err);\n\tif (ret != nr_zones)\n\t\tzonefs_err(sb, \"Get inode %lu zone information failed %d\\n\",\n\t\t\t   inode->i_ino, ret);\n\tmemalloc_noio_restore(noio_flag);\n}\n\nstatic struct kmem_cache *zonefs_inode_cachep;\n\nstatic struct inode *zonefs_alloc_inode(struct super_block *sb)\n{\n\tstruct zonefs_inode_info *zi;\n\n\tzi = alloc_inode_sb(sb, zonefs_inode_cachep, GFP_KERNEL);\n\tif (!zi)\n\t\treturn NULL;\n\n\tinode_init_once(&zi->i_vnode);\n\tmutex_init(&zi->i_truncate_mutex);\n\tzi->i_wr_refcnt = 0;\n\n\treturn &zi->i_vnode;\n}\n\nstatic void zonefs_free_inode(struct inode *inode)\n{\n\tkmem_cache_free(zonefs_inode_cachep, ZONEFS_I(inode));\n}\n\n \nstatic int zonefs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct zonefs_sb_info *sbi = ZONEFS_SB(sb);\n\tenum zonefs_ztype t;\n\n\tbuf->f_type = ZONEFS_MAGIC;\n\tbuf->f_bsize = sb->s_blocksize;\n\tbuf->f_namelen = ZONEFS_NAME_MAX;\n\n\tspin_lock(&sbi->s_lock);\n\n\tbuf->f_blocks = sbi->s_blocks;\n\tif (WARN_ON(sbi->s_used_blocks > sbi->s_blocks))\n\t\tbuf->f_bfree = 0;\n\telse\n\t\tbuf->f_bfree = buf->f_blocks - sbi->s_used_blocks;\n\tbuf->f_bavail = buf->f_bfree;\n\n\tfor (t = 0; t < ZONEFS_ZTYPE_MAX; t++) {\n\t\tif (sbi->s_zgroup[t].g_nr_zones)\n\t\t\tbuf->f_files += sbi->s_zgroup[t].g_nr_zones + 1;\n\t}\n\tbuf->f_ffree = 0;\n\n\tspin_unlock(&sbi->s_lock);\n\n\tbuf->f_fsid = uuid_to_fsid(sbi->s_uuid.b);\n\n\treturn 0;\n}\n\nenum {\n\tOpt_errors_ro, Opt_errors_zro, Opt_errors_zol, Opt_errors_repair,\n\tOpt_explicit_open, Opt_err,\n};\n\nstatic const match_table_t tokens = {\n\t{ Opt_errors_ro,\t\"errors=remount-ro\"},\n\t{ Opt_errors_zro,\t\"errors=zone-ro\"},\n\t{ Opt_errors_zol,\t\"errors=zone-offline\"},\n\t{ Opt_errors_repair,\t\"errors=repair\"},\n\t{ Opt_explicit_open,\t\"explicit-open\" },\n\t{ Opt_err,\t\tNULL}\n};\n\nstatic int zonefs_parse_options(struct super_block *sb, char *options)\n{\n\tstruct zonefs_sb_info *sbi = ZONEFS_SB(sb);\n\tsubstring_t args[MAX_OPT_ARGS];\n\tchar *p;\n\n\tif (!options)\n\t\treturn 0;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_errors_ro:\n\t\t\tsbi->s_mount_opts &= ~ZONEFS_MNTOPT_ERRORS_MASK;\n\t\t\tsbi->s_mount_opts |= ZONEFS_MNTOPT_ERRORS_RO;\n\t\t\tbreak;\n\t\tcase Opt_errors_zro:\n\t\t\tsbi->s_mount_opts &= ~ZONEFS_MNTOPT_ERRORS_MASK;\n\t\t\tsbi->s_mount_opts |= ZONEFS_MNTOPT_ERRORS_ZRO;\n\t\t\tbreak;\n\t\tcase Opt_errors_zol:\n\t\t\tsbi->s_mount_opts &= ~ZONEFS_MNTOPT_ERRORS_MASK;\n\t\t\tsbi->s_mount_opts |= ZONEFS_MNTOPT_ERRORS_ZOL;\n\t\t\tbreak;\n\t\tcase Opt_errors_repair:\n\t\t\tsbi->s_mount_opts &= ~ZONEFS_MNTOPT_ERRORS_MASK;\n\t\t\tsbi->s_mount_opts |= ZONEFS_MNTOPT_ERRORS_REPAIR;\n\t\t\tbreak;\n\t\tcase Opt_explicit_open:\n\t\t\tsbi->s_mount_opts |= ZONEFS_MNTOPT_EXPLICIT_OPEN;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int zonefs_show_options(struct seq_file *seq, struct dentry *root)\n{\n\tstruct zonefs_sb_info *sbi = ZONEFS_SB(root->d_sb);\n\n\tif (sbi->s_mount_opts & ZONEFS_MNTOPT_ERRORS_RO)\n\t\tseq_puts(seq, \",errors=remount-ro\");\n\tif (sbi->s_mount_opts & ZONEFS_MNTOPT_ERRORS_ZRO)\n\t\tseq_puts(seq, \",errors=zone-ro\");\n\tif (sbi->s_mount_opts & ZONEFS_MNTOPT_ERRORS_ZOL)\n\t\tseq_puts(seq, \",errors=zone-offline\");\n\tif (sbi->s_mount_opts & ZONEFS_MNTOPT_ERRORS_REPAIR)\n\t\tseq_puts(seq, \",errors=repair\");\n\n\treturn 0;\n}\n\nstatic int zonefs_remount(struct super_block *sb, int *flags, char *data)\n{\n\tsync_filesystem(sb);\n\n\treturn zonefs_parse_options(sb, data);\n}\n\nstatic int zonefs_inode_setattr(struct mnt_idmap *idmap,\n\t\t\t\tstruct dentry *dentry, struct iattr *iattr)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tint ret;\n\n\tif (unlikely(IS_IMMUTABLE(inode)))\n\t\treturn -EPERM;\n\n\tret = setattr_prepare(&nop_mnt_idmap, dentry, iattr);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif ((iattr->ia_valid & ATTR_MODE) && S_ISDIR(inode->i_mode) &&\n\t    (iattr->ia_mode & 0222))\n\t\treturn -EPERM;\n\n\tif (((iattr->ia_valid & ATTR_UID) &&\n\t     !uid_eq(iattr->ia_uid, inode->i_uid)) ||\n\t    ((iattr->ia_valid & ATTR_GID) &&\n\t     !gid_eq(iattr->ia_gid, inode->i_gid))) {\n\t\tret = dquot_transfer(&nop_mnt_idmap, inode, iattr);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (iattr->ia_valid & ATTR_SIZE) {\n\t\tret = zonefs_file_truncate(inode, iattr->ia_size);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tsetattr_copy(&nop_mnt_idmap, inode, iattr);\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tstruct zonefs_zone *z = zonefs_inode_zone(inode);\n\n\t\tz->z_mode = inode->i_mode;\n\t\tz->z_uid = inode->i_uid;\n\t\tz->z_gid = inode->i_gid;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct inode_operations zonefs_file_inode_operations = {\n\t.setattr\t= zonefs_inode_setattr,\n};\n\nstatic long zonefs_fname_to_fno(const struct qstr *fname)\n{\n\tconst char *name = fname->name;\n\tunsigned int len = fname->len;\n\tlong fno = 0, shift = 1;\n\tconst char *rname;\n\tchar c = *name;\n\tunsigned int i;\n\n\t \n\tif (!isdigit(c))\n\t\treturn -ENOENT;\n\n\tif (len > 1 && c == '0')\n\t\treturn -ENOENT;\n\n\tif (len == 1)\n\t\treturn c - '0';\n\n\tfor (i = 0, rname = name + len - 1; i < len; i++, rname--) {\n\t\tc = *rname;\n\t\tif (!isdigit(c))\n\t\t\treturn -ENOENT;\n\t\tfno += (c - '0') * shift;\n\t\tshift *= 10;\n\t}\n\n\treturn fno;\n}\n\nstatic struct inode *zonefs_get_file_inode(struct inode *dir,\n\t\t\t\t\t   struct dentry *dentry)\n{\n\tstruct zonefs_zone_group *zgroup = dir->i_private;\n\tstruct super_block *sb = dir->i_sb;\n\tstruct zonefs_sb_info *sbi = ZONEFS_SB(sb);\n\tstruct zonefs_zone *z;\n\tstruct inode *inode;\n\tino_t ino;\n\tlong fno;\n\n\t \n\tfno = zonefs_fname_to_fno(&dentry->d_name);\n\tif (fno < 0)\n\t\treturn ERR_PTR(fno);\n\n\tif (!zgroup->g_nr_zones || fno >= zgroup->g_nr_zones)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tz = &zgroup->g_zones[fno];\n\tino = z->z_sector >> sbi->s_zone_sectors_shift;\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW)) {\n\t\tWARN_ON_ONCE(inode->i_private != z);\n\t\treturn inode;\n\t}\n\n\tinode->i_ino = ino;\n\tinode->i_mode = z->z_mode;\n\tinode->i_mtime = inode->i_atime = inode_set_ctime_to_ts(inode,\n\t\t\t\t\t\t\t\tinode_get_ctime(dir));\n\tinode->i_uid = z->z_uid;\n\tinode->i_gid = z->z_gid;\n\tinode->i_size = z->z_wpoffset;\n\tinode->i_blocks = z->z_capacity >> SECTOR_SHIFT;\n\tinode->i_private = z;\n\n\tinode->i_op = &zonefs_file_inode_operations;\n\tinode->i_fop = &zonefs_file_operations;\n\tinode->i_mapping->a_ops = &zonefs_file_aops;\n\n\t \n\tzonefs_inode_update_mode(inode);\n\n\tunlock_new_inode(inode);\n\n\treturn inode;\n}\n\nstatic struct inode *zonefs_get_zgroup_inode(struct super_block *sb,\n\t\t\t\t\t     enum zonefs_ztype ztype)\n{\n\tstruct inode *root = d_inode(sb->s_root);\n\tstruct zonefs_sb_info *sbi = ZONEFS_SB(sb);\n\tstruct inode *inode;\n\tino_t ino = bdev_nr_zones(sb->s_bdev) + ztype + 1;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tinode->i_ino = ino;\n\tinode_init_owner(&nop_mnt_idmap, inode, root, S_IFDIR | 0555);\n\tinode->i_size = sbi->s_zgroup[ztype].g_nr_zones;\n\tinode->i_mtime = inode->i_atime = inode_set_ctime_to_ts(inode,\n\t\t\t\t\t\t\t\tinode_get_ctime(root));\n\tinode->i_private = &sbi->s_zgroup[ztype];\n\tset_nlink(inode, 2);\n\n\tinode->i_op = &zonefs_dir_inode_operations;\n\tinode->i_fop = &zonefs_dir_operations;\n\n\tunlock_new_inode(inode);\n\n\treturn inode;\n}\n\n\nstatic struct inode *zonefs_get_dir_inode(struct inode *dir,\n\t\t\t\t\t  struct dentry *dentry)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct zonefs_sb_info *sbi = ZONEFS_SB(sb);\n\tconst char *name = dentry->d_name.name;\n\tenum zonefs_ztype ztype;\n\n\t \n\tif (dentry->d_name.len != 3)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tfor (ztype = 0; ztype < ZONEFS_ZTYPE_MAX; ztype++) {\n\t\tif (sbi->s_zgroup[ztype].g_nr_zones &&\n\t\t    memcmp(name, zonefs_zgroup_name(ztype), 3) == 0)\n\t\t\tbreak;\n\t}\n\tif (ztype == ZONEFS_ZTYPE_MAX)\n\t\treturn ERR_PTR(-ENOENT);\n\n\treturn zonefs_get_zgroup_inode(sb, ztype);\n}\n\nstatic struct dentry *zonefs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t    unsigned int flags)\n{\n\tstruct inode *inode;\n\n\tif (dentry->d_name.len > ZONEFS_NAME_MAX)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tif (dir == d_inode(dir->i_sb->s_root))\n\t\tinode = zonefs_get_dir_inode(dir, dentry);\n\telse\n\t\tinode = zonefs_get_file_inode(dir, dentry);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\treturn d_splice_alias(inode, dentry);\n}\n\nstatic int zonefs_readdir_root(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct zonefs_sb_info *sbi = ZONEFS_SB(sb);\n\tenum zonefs_ztype ztype = ZONEFS_ZTYPE_CNV;\n\tino_t base_ino = bdev_nr_zones(sb->s_bdev) + 1;\n\n\tif (ctx->pos >= inode->i_size)\n\t\treturn 0;\n\n\tif (!dir_emit_dots(file, ctx))\n\t\treturn 0;\n\n\tif (ctx->pos == 2) {\n\t\tif (!sbi->s_zgroup[ZONEFS_ZTYPE_CNV].g_nr_zones)\n\t\t\tztype = ZONEFS_ZTYPE_SEQ;\n\n\t\tif (!dir_emit(ctx, zonefs_zgroup_name(ztype), 3,\n\t\t\t      base_ino + ztype, DT_DIR))\n\t\t\treturn 0;\n\t\tctx->pos++;\n\t}\n\n\tif (ctx->pos == 3 && ztype != ZONEFS_ZTYPE_SEQ) {\n\t\tztype = ZONEFS_ZTYPE_SEQ;\n\t\tif (!dir_emit(ctx, zonefs_zgroup_name(ztype), 3,\n\t\t\t      base_ino + ztype, DT_DIR))\n\t\t\treturn 0;\n\t\tctx->pos++;\n\t}\n\n\treturn 0;\n}\n\nstatic int zonefs_readdir_zgroup(struct file *file,\n\t\t\t\t struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct zonefs_zone_group *zgroup = inode->i_private;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct zonefs_sb_info *sbi = ZONEFS_SB(sb);\n\tstruct zonefs_zone *z;\n\tint fname_len;\n\tchar *fname;\n\tino_t ino;\n\tint f;\n\n\t \n\tif (ctx->pos >= inode->i_size + 2)\n\t\treturn 0;\n\n\tif (!dir_emit_dots(file, ctx))\n\t\treturn 0;\n\n\tfname = kmalloc(ZONEFS_NAME_MAX, GFP_KERNEL);\n\tif (!fname)\n\t\treturn -ENOMEM;\n\n\tfor (f = ctx->pos - 2; f < zgroup->g_nr_zones; f++) {\n\t\tz = &zgroup->g_zones[f];\n\t\tino = z->z_sector >> sbi->s_zone_sectors_shift;\n\t\tfname_len = snprintf(fname, ZONEFS_NAME_MAX - 1, \"%u\", f);\n\t\tif (!dir_emit(ctx, fname, fname_len, ino, DT_REG))\n\t\t\tbreak;\n\t\tctx->pos++;\n\t}\n\n\tkfree(fname);\n\n\treturn 0;\n}\n\nstatic int zonefs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\n\tif (inode == d_inode(inode->i_sb->s_root))\n\t\treturn zonefs_readdir_root(file, ctx);\n\n\treturn zonefs_readdir_zgroup(file, ctx);\n}\n\nconst struct inode_operations zonefs_dir_inode_operations = {\n\t.lookup\t\t= zonefs_lookup,\n\t.setattr\t= zonefs_inode_setattr,\n};\n\nconst struct file_operations zonefs_dir_operations = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= generic_read_dir,\n\t.iterate_shared\t= zonefs_readdir,\n};\n\nstruct zonefs_zone_data {\n\tstruct super_block\t*sb;\n\tunsigned int\t\tnr_zones[ZONEFS_ZTYPE_MAX];\n\tsector_t\t\tcnv_zone_start;\n\tstruct blk_zone\t\t*zones;\n};\n\nstatic int zonefs_get_zone_info_cb(struct blk_zone *zone, unsigned int idx,\n\t\t\t\t   void *data)\n{\n\tstruct zonefs_zone_data *zd = data;\n\tstruct super_block *sb = zd->sb;\n\tstruct zonefs_sb_info *sbi = ZONEFS_SB(sb);\n\n\t \n\tif (!idx)\n\t\treturn 0;\n\n\t \n\tswitch (zone->type) {\n\tcase BLK_ZONE_TYPE_CONVENTIONAL:\n\t\tif (sbi->s_features & ZONEFS_F_AGGRCNV) {\n\t\t\t \n\t\t\tif (!(sbi->s_zgroup[ZONEFS_ZTYPE_CNV].g_nr_zones) ||\n\t\t\t    zone->start != zd->cnv_zone_start)\n\t\t\t\tsbi->s_zgroup[ZONEFS_ZTYPE_CNV].g_nr_zones++;\n\t\t\tzd->cnv_zone_start = zone->start + zone->len;\n\t\t} else {\n\t\t\t \n\t\t\tsbi->s_zgroup[ZONEFS_ZTYPE_CNV].g_nr_zones++;\n\t\t}\n\t\tbreak;\n\tcase BLK_ZONE_TYPE_SEQWRITE_REQ:\n\tcase BLK_ZONE_TYPE_SEQWRITE_PREF:\n\t\tsbi->s_zgroup[ZONEFS_ZTYPE_SEQ].g_nr_zones++;\n\t\tbreak;\n\tdefault:\n\t\tzonefs_err(zd->sb, \"Unsupported zone type 0x%x\\n\",\n\t\t\t   zone->type);\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(&zd->zones[idx], zone, sizeof(struct blk_zone));\n\n\treturn 0;\n}\n\nstatic int zonefs_get_zone_info(struct zonefs_zone_data *zd)\n{\n\tstruct block_device *bdev = zd->sb->s_bdev;\n\tint ret;\n\n\tzd->zones = kvcalloc(bdev_nr_zones(bdev), sizeof(struct blk_zone),\n\t\t\t     GFP_KERNEL);\n\tif (!zd->zones)\n\t\treturn -ENOMEM;\n\n\t \n\tret = blkdev_report_zones(bdev, 0, BLK_ALL_ZONES,\n\t\t\t\t  zonefs_get_zone_info_cb, zd);\n\tif (ret < 0) {\n\t\tzonefs_err(zd->sb, \"Zone report failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (ret != bdev_nr_zones(bdev)) {\n\t\tzonefs_err(zd->sb, \"Invalid zone report (%d/%u zones)\\n\",\n\t\t\t   ret, bdev_nr_zones(bdev));\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic inline void zonefs_free_zone_info(struct zonefs_zone_data *zd)\n{\n\tkvfree(zd->zones);\n}\n\n \nstatic int zonefs_init_zgroup(struct super_block *sb,\n\t\t\t      struct zonefs_zone_data *zd,\n\t\t\t      enum zonefs_ztype ztype)\n{\n\tstruct zonefs_sb_info *sbi = ZONEFS_SB(sb);\n\tstruct zonefs_zone_group *zgroup = &sbi->s_zgroup[ztype];\n\tstruct blk_zone *zone, *next, *end;\n\tstruct zonefs_zone *z;\n\tunsigned int n = 0;\n\tint ret;\n\n\t \n\tif (!zgroup->g_nr_zones)\n\t\treturn 0;\n\n\tzgroup->g_zones = kvcalloc(zgroup->g_nr_zones,\n\t\t\t\t   sizeof(struct zonefs_zone), GFP_KERNEL);\n\tif (!zgroup->g_zones)\n\t\treturn -ENOMEM;\n\n\t \n\tend = zd->zones + bdev_nr_zones(sb->s_bdev);\n\tfor (zone = &zd->zones[1]; zone < end; zone = next) {\n\n\t\tnext = zone + 1;\n\t\tif (zonefs_zone_type(zone) != ztype)\n\t\t\tcontinue;\n\n\t\tif (WARN_ON_ONCE(n >= zgroup->g_nr_zones))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (ztype == ZONEFS_ZTYPE_CNV &&\n\t\t    (sbi->s_features & ZONEFS_F_AGGRCNV)) {\n\t\t\tfor (; next < end; next++) {\n\t\t\t\tif (zonefs_zone_type(next) != ztype)\n\t\t\t\t\tbreak;\n\t\t\t\tzone->len += next->len;\n\t\t\t\tzone->capacity += next->capacity;\n\t\t\t\tif (next->cond == BLK_ZONE_COND_READONLY &&\n\t\t\t\t    zone->cond != BLK_ZONE_COND_OFFLINE)\n\t\t\t\t\tzone->cond = BLK_ZONE_COND_READONLY;\n\t\t\t\telse if (next->cond == BLK_ZONE_COND_OFFLINE)\n\t\t\t\t\tzone->cond = BLK_ZONE_COND_OFFLINE;\n\t\t\t}\n\t\t}\n\n\t\tz = &zgroup->g_zones[n];\n\t\tif (ztype == ZONEFS_ZTYPE_CNV)\n\t\t\tz->z_flags |= ZONEFS_ZONE_CNV;\n\t\tz->z_sector = zone->start;\n\t\tz->z_size = zone->len << SECTOR_SHIFT;\n\t\tif (z->z_size > bdev_zone_sectors(sb->s_bdev) << SECTOR_SHIFT &&\n\t\t    !(sbi->s_features & ZONEFS_F_AGGRCNV)) {\n\t\t\tzonefs_err(sb,\n\t\t\t\t\"Invalid zone size %llu (device zone sectors %llu)\\n\",\n\t\t\t\tz->z_size,\n\t\t\t\tbdev_zone_sectors(sb->s_bdev) << SECTOR_SHIFT);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tz->z_capacity = min_t(loff_t, MAX_LFS_FILESIZE,\n\t\t\t\t      zone->capacity << SECTOR_SHIFT);\n\t\tz->z_wpoffset = zonefs_check_zone_condition(sb, z, zone);\n\n\t\tz->z_mode = S_IFREG | sbi->s_perm;\n\t\tz->z_uid = sbi->s_uid;\n\t\tz->z_gid = sbi->s_gid;\n\n\t\t \n\t\tz->z_flags |= ZONEFS_ZONE_INIT_MODE;\n\n\t\tsb->s_maxbytes = max(z->z_capacity, sb->s_maxbytes);\n\t\tsbi->s_blocks += z->z_capacity >> sb->s_blocksize_bits;\n\t\tsbi->s_used_blocks += z->z_wpoffset >> sb->s_blocksize_bits;\n\n\t\t \n\t\tif (ztype == ZONEFS_ZTYPE_SEQ &&\n\t\t    (zone->cond == BLK_ZONE_COND_IMP_OPEN ||\n\t\t     zone->cond == BLK_ZONE_COND_EXP_OPEN)) {\n\t\t\tret = zonefs_zone_mgmt(sb, z, REQ_OP_ZONE_CLOSE);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tzonefs_account_active(sb, z);\n\n\t\tn++;\n\t}\n\n\tif (WARN_ON_ONCE(n != zgroup->g_nr_zones))\n\t\treturn -EINVAL;\n\n\tzonefs_info(sb, \"Zone group \\\"%s\\\" has %u file%s\\n\",\n\t\t    zonefs_zgroup_name(ztype),\n\t\t    zgroup->g_nr_zones,\n\t\t    zgroup->g_nr_zones > 1 ? \"s\" : \"\");\n\n\treturn 0;\n}\n\nstatic void zonefs_free_zgroups(struct super_block *sb)\n{\n\tstruct zonefs_sb_info *sbi = ZONEFS_SB(sb);\n\tenum zonefs_ztype ztype;\n\n\tif (!sbi)\n\t\treturn;\n\n\tfor (ztype = 0; ztype < ZONEFS_ZTYPE_MAX; ztype++) {\n\t\tkvfree(sbi->s_zgroup[ztype].g_zones);\n\t\tsbi->s_zgroup[ztype].g_zones = NULL;\n\t}\n}\n\n \nstatic int zonefs_init_zgroups(struct super_block *sb)\n{\n\tstruct zonefs_zone_data zd;\n\tenum zonefs_ztype ztype;\n\tint ret;\n\n\t \n\tmemset(&zd, 0, sizeof(struct zonefs_zone_data));\n\tzd.sb = sb;\n\tret = zonefs_get_zone_info(&zd);\n\tif (ret)\n\t\tgoto cleanup;\n\n\t \n\tfor (ztype = 0; ztype < ZONEFS_ZTYPE_MAX; ztype++) {\n\t\tret = zonefs_init_zgroup(sb, &zd, ztype);\n\t\tif (ret) {\n\t\t\tzonefs_info(sb,\n\t\t\t\t    \"Zone group \\\"%s\\\" initialization failed\\n\",\n\t\t\t\t    zonefs_zgroup_name(ztype));\n\t\t\tbreak;\n\t\t}\n\t}\n\ncleanup:\n\tzonefs_free_zone_info(&zd);\n\tif (ret)\n\t\tzonefs_free_zgroups(sb);\n\n\treturn ret;\n}\n\n \nstatic int zonefs_read_super(struct super_block *sb)\n{\n\tstruct zonefs_sb_info *sbi = ZONEFS_SB(sb);\n\tstruct zonefs_super *super;\n\tu32 crc, stored_crc;\n\tstruct page *page;\n\tstruct bio_vec bio_vec;\n\tstruct bio bio;\n\tint ret;\n\n\tpage = alloc_page(GFP_KERNEL);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tbio_init(&bio, sb->s_bdev, &bio_vec, 1, REQ_OP_READ);\n\tbio.bi_iter.bi_sector = 0;\n\t__bio_add_page(&bio, page, PAGE_SIZE, 0);\n\n\tret = submit_bio_wait(&bio);\n\tif (ret)\n\t\tgoto free_page;\n\n\tsuper = page_address(page);\n\n\tret = -EINVAL;\n\tif (le32_to_cpu(super->s_magic) != ZONEFS_MAGIC)\n\t\tgoto free_page;\n\n\tstored_crc = le32_to_cpu(super->s_crc);\n\tsuper->s_crc = 0;\n\tcrc = crc32(~0U, (unsigned char *)super, sizeof(struct zonefs_super));\n\tif (crc != stored_crc) {\n\t\tzonefs_err(sb, \"Invalid checksum (Expected 0x%08x, got 0x%08x)\",\n\t\t\t   crc, stored_crc);\n\t\tgoto free_page;\n\t}\n\n\tsbi->s_features = le64_to_cpu(super->s_features);\n\tif (sbi->s_features & ~ZONEFS_F_DEFINED_FEATURES) {\n\t\tzonefs_err(sb, \"Unknown features set 0x%llx\\n\",\n\t\t\t   sbi->s_features);\n\t\tgoto free_page;\n\t}\n\n\tif (sbi->s_features & ZONEFS_F_UID) {\n\t\tsbi->s_uid = make_kuid(current_user_ns(),\n\t\t\t\t       le32_to_cpu(super->s_uid));\n\t\tif (!uid_valid(sbi->s_uid)) {\n\t\t\tzonefs_err(sb, \"Invalid UID feature\\n\");\n\t\t\tgoto free_page;\n\t\t}\n\t}\n\n\tif (sbi->s_features & ZONEFS_F_GID) {\n\t\tsbi->s_gid = make_kgid(current_user_ns(),\n\t\t\t\t       le32_to_cpu(super->s_gid));\n\t\tif (!gid_valid(sbi->s_gid)) {\n\t\t\tzonefs_err(sb, \"Invalid GID feature\\n\");\n\t\t\tgoto free_page;\n\t\t}\n\t}\n\n\tif (sbi->s_features & ZONEFS_F_PERM)\n\t\tsbi->s_perm = le32_to_cpu(super->s_perm);\n\n\tif (memchr_inv(super->s_reserved, 0, sizeof(super->s_reserved))) {\n\t\tzonefs_err(sb, \"Reserved area is being used\\n\");\n\t\tgoto free_page;\n\t}\n\n\timport_uuid(&sbi->s_uuid, super->s_uuid);\n\tret = 0;\n\nfree_page:\n\t__free_page(page);\n\n\treturn ret;\n}\n\nstatic const struct super_operations zonefs_sops = {\n\t.alloc_inode\t= zonefs_alloc_inode,\n\t.free_inode\t= zonefs_free_inode,\n\t.statfs\t\t= zonefs_statfs,\n\t.remount_fs\t= zonefs_remount,\n\t.show_options\t= zonefs_show_options,\n};\n\nstatic int zonefs_get_zgroup_inodes(struct super_block *sb)\n{\n\tstruct zonefs_sb_info *sbi = ZONEFS_SB(sb);\n\tstruct inode *dir_inode;\n\tenum zonefs_ztype ztype;\n\n\tfor (ztype = 0; ztype < ZONEFS_ZTYPE_MAX; ztype++) {\n\t\tif (!sbi->s_zgroup[ztype].g_nr_zones)\n\t\t\tcontinue;\n\n\t\tdir_inode = zonefs_get_zgroup_inode(sb, ztype);\n\t\tif (IS_ERR(dir_inode))\n\t\t\treturn PTR_ERR(dir_inode);\n\n\t\tsbi->s_zgroup[ztype].g_inode = dir_inode;\n\t}\n\n\treturn 0;\n}\n\nstatic void zonefs_release_zgroup_inodes(struct super_block *sb)\n{\n\tstruct zonefs_sb_info *sbi = ZONEFS_SB(sb);\n\tenum zonefs_ztype ztype;\n\n\tif (!sbi)\n\t\treturn;\n\n\tfor (ztype = 0; ztype < ZONEFS_ZTYPE_MAX; ztype++) {\n\t\tif (sbi->s_zgroup[ztype].g_inode) {\n\t\t\tiput(sbi->s_zgroup[ztype].g_inode);\n\t\t\tsbi->s_zgroup[ztype].g_inode = NULL;\n\t\t}\n\t}\n}\n\n \nstatic int zonefs_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct zonefs_sb_info *sbi;\n\tstruct inode *inode;\n\tenum zonefs_ztype ztype;\n\tint ret;\n\n\tif (!bdev_is_zoned(sb->s_bdev)) {\n\t\tzonefs_err(sb, \"Not a zoned block device\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tsbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&sbi->s_lock);\n\tsb->s_fs_info = sbi;\n\tsb->s_magic = ZONEFS_MAGIC;\n\tsb->s_maxbytes = 0;\n\tsb->s_op = &zonefs_sops;\n\tsb->s_time_gran\t= 1;\n\n\t \n\tsb_set_blocksize(sb, bdev_zone_write_granularity(sb->s_bdev));\n\tsbi->s_zone_sectors_shift = ilog2(bdev_zone_sectors(sb->s_bdev));\n\tsbi->s_uid = GLOBAL_ROOT_UID;\n\tsbi->s_gid = GLOBAL_ROOT_GID;\n\tsbi->s_perm = 0640;\n\tsbi->s_mount_opts = ZONEFS_MNTOPT_ERRORS_RO;\n\n\tatomic_set(&sbi->s_wro_seq_files, 0);\n\tsbi->s_max_wro_seq_files = bdev_max_open_zones(sb->s_bdev);\n\tatomic_set(&sbi->s_active_seq_files, 0);\n\tsbi->s_max_active_seq_files = bdev_max_active_zones(sb->s_bdev);\n\n\tret = zonefs_read_super(sb);\n\tif (ret)\n\t\treturn ret;\n\n\tret = zonefs_parse_options(sb, data);\n\tif (ret)\n\t\treturn ret;\n\n\tzonefs_info(sb, \"Mounting %u zones\", bdev_nr_zones(sb->s_bdev));\n\n\tif (!sbi->s_max_wro_seq_files &&\n\t    !sbi->s_max_active_seq_files &&\n\t    sbi->s_mount_opts & ZONEFS_MNTOPT_EXPLICIT_OPEN) {\n\t\tzonefs_info(sb,\n\t\t\t\"No open and active zone limits. Ignoring explicit_open mount option\\n\");\n\t\tsbi->s_mount_opts &= ~ZONEFS_MNTOPT_EXPLICIT_OPEN;\n\t}\n\n\t \n\tret = zonefs_init_zgroups(sb);\n\tif (ret)\n\t\tgoto cleanup;\n\n\t \n\tret = -ENOMEM;\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\tgoto cleanup;\n\n\tinode->i_ino = bdev_nr_zones(sb->s_bdev);\n\tinode->i_mode = S_IFDIR | 0555;\n\tinode->i_mtime = inode->i_atime = inode_set_ctime_current(inode);\n\tinode->i_op = &zonefs_dir_inode_operations;\n\tinode->i_fop = &zonefs_dir_operations;\n\tinode->i_size = 2;\n\tset_nlink(inode, 2);\n\tfor (ztype = 0; ztype < ZONEFS_ZTYPE_MAX; ztype++) {\n\t\tif (sbi->s_zgroup[ztype].g_nr_zones) {\n\t\t\tinc_nlink(inode);\n\t\t\tinode->i_size++;\n\t\t}\n\t}\n\n\tsb->s_root = d_make_root(inode);\n\tif (!sb->s_root)\n\t\tgoto cleanup;\n\n\t \n\tret = zonefs_get_zgroup_inodes(sb);\n\tif (ret)\n\t\tgoto cleanup;\n\n\tret = zonefs_sysfs_register(sb);\n\tif (ret)\n\t\tgoto cleanup;\n\n\treturn 0;\n\ncleanup:\n\tzonefs_release_zgroup_inodes(sb);\n\tzonefs_free_zgroups(sb);\n\n\treturn ret;\n}\n\nstatic struct dentry *zonefs_mount(struct file_system_type *fs_type,\n\t\t\t\t   int flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, zonefs_fill_super);\n}\n\nstatic void zonefs_kill_super(struct super_block *sb)\n{\n\tstruct zonefs_sb_info *sbi = ZONEFS_SB(sb);\n\n\t \n\tzonefs_release_zgroup_inodes(sb);\n\n\tkill_block_super(sb);\n\n\tzonefs_sysfs_unregister(sb);\n\tzonefs_free_zgroups(sb);\n\tkfree(sbi);\n}\n\n \nstatic struct file_system_type zonefs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"zonefs\",\n\t.mount\t\t= zonefs_mount,\n\t.kill_sb\t= zonefs_kill_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\n\nstatic int __init zonefs_init_inodecache(void)\n{\n\tzonefs_inode_cachep = kmem_cache_create(\"zonefs_inode_cache\",\n\t\t\tsizeof(struct zonefs_inode_info), 0,\n\t\t\t(SLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD | SLAB_ACCOUNT),\n\t\t\tNULL);\n\tif (zonefs_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic void zonefs_destroy_inodecache(void)\n{\n\t \n\trcu_barrier();\n\tkmem_cache_destroy(zonefs_inode_cachep);\n}\n\nstatic int __init zonefs_init(void)\n{\n\tint ret;\n\n\tBUILD_BUG_ON(sizeof(struct zonefs_super) != ZONEFS_SUPER_SIZE);\n\n\tret = zonefs_init_inodecache();\n\tif (ret)\n\t\treturn ret;\n\n\tret = zonefs_sysfs_init();\n\tif (ret)\n\t\tgoto destroy_inodecache;\n\n\tret = register_filesystem(&zonefs_type);\n\tif (ret)\n\t\tgoto sysfs_exit;\n\n\treturn 0;\n\nsysfs_exit:\n\tzonefs_sysfs_exit();\ndestroy_inodecache:\n\tzonefs_destroy_inodecache();\n\n\treturn ret;\n}\n\nstatic void __exit zonefs_exit(void)\n{\n\tunregister_filesystem(&zonefs_type);\n\tzonefs_sysfs_exit();\n\tzonefs_destroy_inodecache();\n}\n\nMODULE_AUTHOR(\"Damien Le Moal\");\nMODULE_DESCRIPTION(\"Zone file system for zoned block devices\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_FS(\"zonefs\");\nmodule_init(zonefs_init);\nmodule_exit(zonefs_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}