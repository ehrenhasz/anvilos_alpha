{
  "module_name": "file.c",
  "hash_id": "44e7c7598b2107661b84d73c93faa859282baf8c6fa425a08dd9942ce344dcd9",
  "original_prompt": "Ingested from linux-6.6.14/fs/zonefs/file.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/pagemap.h>\n#include <linux/iomap.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/parser.h>\n#include <linux/uio.h>\n#include <linux/mman.h>\n#include <linux/sched/mm.h>\n#include <linux/task_io_accounting_ops.h>\n\n#include \"zonefs.h\"\n\n#include \"trace.h\"\n\nstatic int zonefs_read_iomap_begin(struct inode *inode, loff_t offset,\n\t\t\t\t   loff_t length, unsigned int flags,\n\t\t\t\t   struct iomap *iomap, struct iomap *srcmap)\n{\n\tstruct zonefs_inode_info *zi = ZONEFS_I(inode);\n\tstruct zonefs_zone *z = zonefs_inode_zone(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tloff_t isize;\n\n\t \n\tmutex_lock(&zi->i_truncate_mutex);\n\tiomap->bdev = inode->i_sb->s_bdev;\n\tiomap->offset = ALIGN_DOWN(offset, sb->s_blocksize);\n\tisize = i_size_read(inode);\n\tif (iomap->offset >= isize) {\n\t\tiomap->type = IOMAP_HOLE;\n\t\tiomap->addr = IOMAP_NULL_ADDR;\n\t\tiomap->length = length;\n\t} else {\n\t\tiomap->type = IOMAP_MAPPED;\n\t\tiomap->addr = (z->z_sector << SECTOR_SHIFT) + iomap->offset;\n\t\tiomap->length = isize - iomap->offset;\n\t}\n\tmutex_unlock(&zi->i_truncate_mutex);\n\n\ttrace_zonefs_iomap_begin(inode, iomap);\n\n\treturn 0;\n}\n\nstatic const struct iomap_ops zonefs_read_iomap_ops = {\n\t.iomap_begin\t= zonefs_read_iomap_begin,\n};\n\nstatic int zonefs_write_iomap_begin(struct inode *inode, loff_t offset,\n\t\t\t\t    loff_t length, unsigned int flags,\n\t\t\t\t    struct iomap *iomap, struct iomap *srcmap)\n{\n\tstruct zonefs_inode_info *zi = ZONEFS_I(inode);\n\tstruct zonefs_zone *z = zonefs_inode_zone(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tloff_t isize;\n\n\t \n\tif (WARN_ON_ONCE(offset + length > z->z_capacity))\n\t\treturn -EIO;\n\n\t \n\tif (WARN_ON_ONCE(zonefs_zone_is_seq(z) && !(flags & IOMAP_DIRECT)))\n\t\treturn -EIO;\n\n\t \n\tmutex_lock(&zi->i_truncate_mutex);\n\tiomap->bdev = inode->i_sb->s_bdev;\n\tiomap->offset = ALIGN_DOWN(offset, sb->s_blocksize);\n\tiomap->addr = (z->z_sector << SECTOR_SHIFT) + iomap->offset;\n\tisize = i_size_read(inode);\n\tif (iomap->offset >= isize) {\n\t\tiomap->type = IOMAP_UNWRITTEN;\n\t\tiomap->length = z->z_capacity - iomap->offset;\n\t} else {\n\t\tiomap->type = IOMAP_MAPPED;\n\t\tiomap->length = isize - iomap->offset;\n\t}\n\tmutex_unlock(&zi->i_truncate_mutex);\n\n\ttrace_zonefs_iomap_begin(inode, iomap);\n\n\treturn 0;\n}\n\nstatic const struct iomap_ops zonefs_write_iomap_ops = {\n\t.iomap_begin\t= zonefs_write_iomap_begin,\n};\n\nstatic int zonefs_read_folio(struct file *unused, struct folio *folio)\n{\n\treturn iomap_read_folio(folio, &zonefs_read_iomap_ops);\n}\n\nstatic void zonefs_readahead(struct readahead_control *rac)\n{\n\tiomap_readahead(rac, &zonefs_read_iomap_ops);\n}\n\n \nstatic int zonefs_write_map_blocks(struct iomap_writepage_ctx *wpc,\n\t\t\t\t   struct inode *inode, loff_t offset)\n{\n\tstruct zonefs_zone *z = zonefs_inode_zone(inode);\n\n\tif (WARN_ON_ONCE(zonefs_zone_is_seq(z)))\n\t\treturn -EIO;\n\tif (WARN_ON_ONCE(offset >= i_size_read(inode)))\n\t\treturn -EIO;\n\n\t \n\tif (offset >= wpc->iomap.offset &&\n\t    offset < wpc->iomap.offset + wpc->iomap.length)\n\t\treturn 0;\n\n\treturn zonefs_write_iomap_begin(inode, offset,\n\t\t\t\t\tz->z_capacity - offset,\n\t\t\t\t\tIOMAP_WRITE, &wpc->iomap, NULL);\n}\n\nstatic const struct iomap_writeback_ops zonefs_writeback_ops = {\n\t.map_blocks\t\t= zonefs_write_map_blocks,\n};\n\nstatic int zonefs_writepages(struct address_space *mapping,\n\t\t\t     struct writeback_control *wbc)\n{\n\tstruct iomap_writepage_ctx wpc = { };\n\n\treturn iomap_writepages(mapping, wbc, &wpc, &zonefs_writeback_ops);\n}\n\nstatic int zonefs_swap_activate(struct swap_info_struct *sis,\n\t\t\t\tstruct file *swap_file, sector_t *span)\n{\n\tstruct inode *inode = file_inode(swap_file);\n\n\tif (zonefs_inode_is_seq(inode)) {\n\t\tzonefs_err(inode->i_sb,\n\t\t\t   \"swap file: not a conventional zone file\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn iomap_swapfile_activate(sis, swap_file, span,\n\t\t\t\t       &zonefs_read_iomap_ops);\n}\n\nconst struct address_space_operations zonefs_file_aops = {\n\t.read_folio\t\t= zonefs_read_folio,\n\t.readahead\t\t= zonefs_readahead,\n\t.writepages\t\t= zonefs_writepages,\n\t.dirty_folio\t\t= iomap_dirty_folio,\n\t.release_folio\t\t= iomap_release_folio,\n\t.invalidate_folio\t= iomap_invalidate_folio,\n\t.migrate_folio\t\t= filemap_migrate_folio,\n\t.is_partially_uptodate\t= iomap_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n\t.swap_activate\t\t= zonefs_swap_activate,\n};\n\nint zonefs_file_truncate(struct inode *inode, loff_t isize)\n{\n\tstruct zonefs_inode_info *zi = ZONEFS_I(inode);\n\tstruct zonefs_zone *z = zonefs_inode_zone(inode);\n\tloff_t old_isize;\n\tenum req_op op;\n\tint ret = 0;\n\n\t \n\tif (!zonefs_zone_is_seq(z))\n\t\treturn -EPERM;\n\n\tif (!isize)\n\t\top = REQ_OP_ZONE_RESET;\n\telse if (isize == z->z_capacity)\n\t\top = REQ_OP_ZONE_FINISH;\n\telse\n\t\treturn -EPERM;\n\n\tinode_dio_wait(inode);\n\n\t \n\tfilemap_invalidate_lock(inode->i_mapping);\n\n\t \n\tmutex_lock(&zi->i_truncate_mutex);\n\n\told_isize = i_size_read(inode);\n\tif (isize == old_isize)\n\t\tgoto unlock;\n\n\tret = zonefs_inode_zone_mgmt(inode, op);\n\tif (ret)\n\t\tgoto unlock;\n\n\t \n\tif (z->z_flags & ZONEFS_ZONE_OPEN) {\n\t\t \n\t\tif (!isize)\n\t\t\tret = zonefs_inode_zone_mgmt(inode, REQ_OP_ZONE_OPEN);\n\t\telse\n\t\t\tz->z_flags &= ~ZONEFS_ZONE_OPEN;\n\t}\n\n\tzonefs_update_stats(inode, isize);\n\ttruncate_setsize(inode, isize);\n\tz->z_wpoffset = isize;\n\tzonefs_inode_account_active(inode);\n\nunlock:\n\tmutex_unlock(&zi->i_truncate_mutex);\n\tfilemap_invalidate_unlock(inode->i_mapping);\n\n\treturn ret;\n}\n\nstatic int zonefs_file_fsync(struct file *file, loff_t start, loff_t end,\n\t\t\t     int datasync)\n{\n\tstruct inode *inode = file_inode(file);\n\tint ret = 0;\n\n\tif (unlikely(IS_IMMUTABLE(inode)))\n\t\treturn -EPERM;\n\n\t \n\tif (zonefs_inode_is_cnv(inode))\n\t\tret = file_write_and_wait_range(file, start, end);\n\tif (!ret)\n\t\tret = blkdev_issue_flush(inode->i_sb->s_bdev);\n\n\tif (ret)\n\t\tzonefs_io_error(inode, true);\n\n\treturn ret;\n}\n\nstatic vm_fault_t zonefs_filemap_page_mkwrite(struct vm_fault *vmf)\n{\n\tstruct inode *inode = file_inode(vmf->vma->vm_file);\n\tvm_fault_t ret;\n\n\tif (unlikely(IS_IMMUTABLE(inode)))\n\t\treturn VM_FAULT_SIGBUS;\n\n\t \n\tif (zonefs_inode_is_seq(inode))\n\t\treturn VM_FAULT_NOPAGE;\n\n\tsb_start_pagefault(inode->i_sb);\n\tfile_update_time(vmf->vma->vm_file);\n\n\t \n\tfilemap_invalidate_lock_shared(inode->i_mapping);\n\tret = iomap_page_mkwrite(vmf, &zonefs_write_iomap_ops);\n\tfilemap_invalidate_unlock_shared(inode->i_mapping);\n\n\tsb_end_pagefault(inode->i_sb);\n\treturn ret;\n}\n\nstatic const struct vm_operations_struct zonefs_file_vm_ops = {\n\t.fault\t\t= filemap_fault,\n\t.map_pages\t= filemap_map_pages,\n\t.page_mkwrite\t= zonefs_filemap_page_mkwrite,\n};\n\nstatic int zonefs_file_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\t \n\tif (zonefs_inode_is_seq(file_inode(file)) &&\n\t    (vma->vm_flags & VM_SHARED) && (vma->vm_flags & VM_MAYWRITE))\n\t\treturn -EINVAL;\n\n\tfile_accessed(file);\n\tvma->vm_ops = &zonefs_file_vm_ops;\n\n\treturn 0;\n}\n\nstatic loff_t zonefs_file_llseek(struct file *file, loff_t offset, int whence)\n{\n\tloff_t isize = i_size_read(file_inode(file));\n\n\t \n\treturn generic_file_llseek_size(file, offset, whence, isize, isize);\n}\n\nstatic int zonefs_file_write_dio_end_io(struct kiocb *iocb, ssize_t size,\n\t\t\t\t\tint error, unsigned int flags)\n{\n\tstruct inode *inode = file_inode(iocb->ki_filp);\n\tstruct zonefs_inode_info *zi = ZONEFS_I(inode);\n\n\tif (error) {\n\t\tzonefs_io_error(inode, true);\n\t\treturn error;\n\t}\n\n\tif (size && zonefs_inode_is_seq(inode)) {\n\t\t \n\t\tmutex_lock(&zi->i_truncate_mutex);\n\t\tif (i_size_read(inode) < iocb->ki_pos + size) {\n\t\t\tzonefs_update_stats(inode, iocb->ki_pos + size);\n\t\t\tzonefs_i_size_write(inode, iocb->ki_pos + size);\n\t\t}\n\t\tmutex_unlock(&zi->i_truncate_mutex);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct iomap_dio_ops zonefs_write_dio_ops = {\n\t.end_io\t\t= zonefs_file_write_dio_end_io,\n};\n\n \nstatic loff_t zonefs_write_check_limits(struct file *file, loff_t pos,\n\t\t\t\t\tloff_t count)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct zonefs_zone *z = zonefs_inode_zone(inode);\n\tloff_t limit = rlimit(RLIMIT_FSIZE);\n\tloff_t max_size = z->z_capacity;\n\n\tif (limit != RLIM_INFINITY) {\n\t\tif (pos >= limit) {\n\t\t\tsend_sig(SIGXFSZ, current, 0);\n\t\t\treturn -EFBIG;\n\t\t}\n\t\tcount = min(count, limit - pos);\n\t}\n\n\tif (!(file->f_flags & O_LARGEFILE))\n\t\tmax_size = min_t(loff_t, MAX_NON_LFS, max_size);\n\n\tif (unlikely(pos >= max_size))\n\t\treturn -EFBIG;\n\n\treturn min(count, max_size - pos);\n}\n\nstatic ssize_t zonefs_write_checks(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file_inode(file);\n\tstruct zonefs_inode_info *zi = ZONEFS_I(inode);\n\tstruct zonefs_zone *z = zonefs_inode_zone(inode);\n\tloff_t count;\n\n\tif (IS_SWAPFILE(inode))\n\t\treturn -ETXTBSY;\n\n\tif (!iov_iter_count(from))\n\t\treturn 0;\n\n\tif ((iocb->ki_flags & IOCB_NOWAIT) && !(iocb->ki_flags & IOCB_DIRECT))\n\t\treturn -EINVAL;\n\n\tif (iocb->ki_flags & IOCB_APPEND) {\n\t\tif (zonefs_zone_is_cnv(z))\n\t\t\treturn -EINVAL;\n\t\tmutex_lock(&zi->i_truncate_mutex);\n\t\tiocb->ki_pos = z->z_wpoffset;\n\t\tmutex_unlock(&zi->i_truncate_mutex);\n\t}\n\n\tcount = zonefs_write_check_limits(file, iocb->ki_pos,\n\t\t\t\t\t  iov_iter_count(from));\n\tif (count < 0)\n\t\treturn count;\n\n\tiov_iter_truncate(from, count);\n\treturn iov_iter_count(from);\n}\n\n \nstatic ssize_t zonefs_file_dio_write(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct inode *inode = file_inode(iocb->ki_filp);\n\tstruct zonefs_inode_info *zi = ZONEFS_I(inode);\n\tstruct zonefs_zone *z = zonefs_inode_zone(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tssize_t ret, count;\n\n\t \n\tif (zonefs_zone_is_seq(z) && !is_sync_kiocb(iocb) &&\n\t    (iocb->ki_flags & IOCB_NOWAIT))\n\t\treturn -EOPNOTSUPP;\n\n\tif (iocb->ki_flags & IOCB_NOWAIT) {\n\t\tif (!inode_trylock(inode))\n\t\t\treturn -EAGAIN;\n\t} else {\n\t\tinode_lock(inode);\n\t}\n\n\tcount = zonefs_write_checks(iocb, from);\n\tif (count <= 0) {\n\t\tret = count;\n\t\tgoto inode_unlock;\n\t}\n\n\tif ((iocb->ki_pos | count) & (sb->s_blocksize - 1)) {\n\t\tret = -EINVAL;\n\t\tgoto inode_unlock;\n\t}\n\n\t \n\tif (zonefs_zone_is_seq(z)) {\n\t\tmutex_lock(&zi->i_truncate_mutex);\n\t\tif (iocb->ki_pos != z->z_wpoffset) {\n\t\t\tmutex_unlock(&zi->i_truncate_mutex);\n\t\t\tret = -EINVAL;\n\t\t\tgoto inode_unlock;\n\t\t}\n\t\tmutex_unlock(&zi->i_truncate_mutex);\n\t}\n\n\t \n\tret = iomap_dio_rw(iocb, from, &zonefs_write_iomap_ops,\n\t\t\t   &zonefs_write_dio_ops, 0, NULL, 0);\n\tif (ret == -ENOTBLK)\n\t\tret = -EBUSY;\n\n\tif (zonefs_zone_is_seq(z) &&\n\t    (ret > 0 || ret == -EIOCBQUEUED)) {\n\t\tif (ret > 0)\n\t\t\tcount = ret;\n\n\t\t \n\t\tmutex_lock(&zi->i_truncate_mutex);\n\t\tz->z_wpoffset += count;\n\t\tzonefs_inode_account_active(inode);\n\t\tmutex_unlock(&zi->i_truncate_mutex);\n\t}\n\ninode_unlock:\n\tinode_unlock(inode);\n\n\treturn ret;\n}\n\nstatic ssize_t zonefs_file_buffered_write(struct kiocb *iocb,\n\t\t\t\t\t  struct iov_iter *from)\n{\n\tstruct inode *inode = file_inode(iocb->ki_filp);\n\tssize_t ret;\n\n\t \n\tif (zonefs_inode_is_seq(inode))\n\t\treturn -EIO;\n\n\tif (iocb->ki_flags & IOCB_NOWAIT) {\n\t\tif (!inode_trylock(inode))\n\t\t\treturn -EAGAIN;\n\t} else {\n\t\tinode_lock(inode);\n\t}\n\n\tret = zonefs_write_checks(iocb, from);\n\tif (ret <= 0)\n\t\tgoto inode_unlock;\n\n\tret = iomap_file_buffered_write(iocb, from, &zonefs_write_iomap_ops);\n\tif (ret == -EIO)\n\t\tzonefs_io_error(inode, true);\n\ninode_unlock:\n\tinode_unlock(inode);\n\tif (ret > 0)\n\t\tret = generic_write_sync(iocb, ret);\n\n\treturn ret;\n}\n\nstatic ssize_t zonefs_file_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct inode *inode = file_inode(iocb->ki_filp);\n\tstruct zonefs_zone *z = zonefs_inode_zone(inode);\n\n\tif (unlikely(IS_IMMUTABLE(inode)))\n\t\treturn -EPERM;\n\n\tif (sb_rdonly(inode->i_sb))\n\t\treturn -EROFS;\n\n\t \n\tif (iocb->ki_pos >= z->z_capacity)\n\t\treturn -EFBIG;\n\n\tif (iocb->ki_flags & IOCB_DIRECT) {\n\t\tssize_t ret = zonefs_file_dio_write(iocb, from);\n\n\t\tif (ret != -ENOTBLK)\n\t\t\treturn ret;\n\t}\n\n\treturn zonefs_file_buffered_write(iocb, from);\n}\n\nstatic int zonefs_file_read_dio_end_io(struct kiocb *iocb, ssize_t size,\n\t\t\t\t       int error, unsigned int flags)\n{\n\tif (error) {\n\t\tzonefs_io_error(file_inode(iocb->ki_filp), false);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct iomap_dio_ops zonefs_read_dio_ops = {\n\t.end_io\t\t\t= zonefs_file_read_dio_end_io,\n};\n\nstatic ssize_t zonefs_file_read_iter(struct kiocb *iocb, struct iov_iter *to)\n{\n\tstruct inode *inode = file_inode(iocb->ki_filp);\n\tstruct zonefs_inode_info *zi = ZONEFS_I(inode);\n\tstruct zonefs_zone *z = zonefs_inode_zone(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tloff_t isize;\n\tssize_t ret;\n\n\t \n\tif (unlikely(IS_IMMUTABLE(inode) && !(inode->i_mode & 0777)))\n\t\treturn -EPERM;\n\n\tif (iocb->ki_pos >= z->z_capacity)\n\t\treturn 0;\n\n\tif (iocb->ki_flags & IOCB_NOWAIT) {\n\t\tif (!inode_trylock_shared(inode))\n\t\t\treturn -EAGAIN;\n\t} else {\n\t\tinode_lock_shared(inode);\n\t}\n\n\t \n\tmutex_lock(&zi->i_truncate_mutex);\n\tisize = i_size_read(inode);\n\tif (iocb->ki_pos >= isize) {\n\t\tmutex_unlock(&zi->i_truncate_mutex);\n\t\tret = 0;\n\t\tgoto inode_unlock;\n\t}\n\tiov_iter_truncate(to, isize - iocb->ki_pos);\n\tmutex_unlock(&zi->i_truncate_mutex);\n\n\tif (iocb->ki_flags & IOCB_DIRECT) {\n\t\tsize_t count = iov_iter_count(to);\n\n\t\tif ((iocb->ki_pos | count) & (sb->s_blocksize - 1)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto inode_unlock;\n\t\t}\n\t\tfile_accessed(iocb->ki_filp);\n\t\tret = iomap_dio_rw(iocb, to, &zonefs_read_iomap_ops,\n\t\t\t\t   &zonefs_read_dio_ops, 0, NULL, 0);\n\t} else {\n\t\tret = generic_file_read_iter(iocb, to);\n\t\tif (ret == -EIO)\n\t\t\tzonefs_io_error(inode, false);\n\t}\n\ninode_unlock:\n\tinode_unlock_shared(inode);\n\n\treturn ret;\n}\n\nstatic ssize_t zonefs_file_splice_read(struct file *in, loff_t *ppos,\n\t\t\t\t       struct pipe_inode_info *pipe,\n\t\t\t\t       size_t len, unsigned int flags)\n{\n\tstruct inode *inode = file_inode(in);\n\tstruct zonefs_inode_info *zi = ZONEFS_I(inode);\n\tstruct zonefs_zone *z = zonefs_inode_zone(inode);\n\tloff_t isize;\n\tssize_t ret = 0;\n\n\t \n\tif (unlikely(IS_IMMUTABLE(inode) && !(inode->i_mode & 0777)))\n\t\treturn -EPERM;\n\n\tif (*ppos >= z->z_capacity)\n\t\treturn 0;\n\n\tinode_lock_shared(inode);\n\n\t \n\tmutex_lock(&zi->i_truncate_mutex);\n\tisize = i_size_read(inode);\n\tif (*ppos >= isize)\n\t\tlen = 0;\n\telse\n\t\tlen = min_t(loff_t, len, isize - *ppos);\n\tmutex_unlock(&zi->i_truncate_mutex);\n\n\tif (len > 0) {\n\t\tret = filemap_splice_read(in, ppos, pipe, len, flags);\n\t\tif (ret == -EIO)\n\t\t\tzonefs_io_error(inode, false);\n\t}\n\n\tinode_unlock_shared(inode);\n\treturn ret;\n}\n\n \nstatic inline bool zonefs_seq_file_need_wro(struct inode *inode,\n\t\t\t\t\t    struct file *file)\n{\n\tif (zonefs_inode_is_cnv(inode))\n\t\treturn false;\n\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int zonefs_seq_file_write_open(struct inode *inode)\n{\n\tstruct zonefs_inode_info *zi = ZONEFS_I(inode);\n\tstruct zonefs_zone *z = zonefs_inode_zone(inode);\n\tint ret = 0;\n\n\tmutex_lock(&zi->i_truncate_mutex);\n\n\tif (!zi->i_wr_refcnt) {\n\t\tstruct zonefs_sb_info *sbi = ZONEFS_SB(inode->i_sb);\n\t\tunsigned int wro = atomic_inc_return(&sbi->s_wro_seq_files);\n\n\t\tif (sbi->s_mount_opts & ZONEFS_MNTOPT_EXPLICIT_OPEN) {\n\n\t\t\tif (sbi->s_max_wro_seq_files\n\t\t\t    && wro > sbi->s_max_wro_seq_files) {\n\t\t\t\tatomic_dec(&sbi->s_wro_seq_files);\n\t\t\t\tret = -EBUSY;\n\t\t\t\tgoto unlock;\n\t\t\t}\n\n\t\t\tif (i_size_read(inode) < z->z_capacity) {\n\t\t\t\tret = zonefs_inode_zone_mgmt(inode,\n\t\t\t\t\t\t\t     REQ_OP_ZONE_OPEN);\n\t\t\t\tif (ret) {\n\t\t\t\t\tatomic_dec(&sbi->s_wro_seq_files);\n\t\t\t\t\tgoto unlock;\n\t\t\t\t}\n\t\t\t\tz->z_flags |= ZONEFS_ZONE_OPEN;\n\t\t\t\tzonefs_inode_account_active(inode);\n\t\t\t}\n\t\t}\n\t}\n\n\tzi->i_wr_refcnt++;\n\nunlock:\n\tmutex_unlock(&zi->i_truncate_mutex);\n\n\treturn ret;\n}\n\nstatic int zonefs_file_open(struct inode *inode, struct file *file)\n{\n\tint ret;\n\n\tfile->f_mode |= FMODE_CAN_ODIRECT;\n\tret = generic_file_open(inode, file);\n\tif (ret)\n\t\treturn ret;\n\n\tif (zonefs_seq_file_need_wro(inode, file))\n\t\treturn zonefs_seq_file_write_open(inode);\n\n\treturn 0;\n}\n\nstatic void zonefs_seq_file_write_close(struct inode *inode)\n{\n\tstruct zonefs_inode_info *zi = ZONEFS_I(inode);\n\tstruct zonefs_zone *z = zonefs_inode_zone(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct zonefs_sb_info *sbi = ZONEFS_SB(sb);\n\tint ret = 0;\n\n\tmutex_lock(&zi->i_truncate_mutex);\n\n\tzi->i_wr_refcnt--;\n\tif (zi->i_wr_refcnt)\n\t\tgoto unlock;\n\n\t \n\tif (z->z_flags & ZONEFS_ZONE_OPEN) {\n\t\tret = zonefs_inode_zone_mgmt(inode, REQ_OP_ZONE_CLOSE);\n\t\tif (ret) {\n\t\t\t__zonefs_io_error(inode, false);\n\t\t\t \n\t\t\tif (z->z_flags & ZONEFS_ZONE_OPEN &&\n\t\t\t    !(sb->s_flags & SB_RDONLY)) {\n\t\t\t\tzonefs_warn(sb,\n\t\t\t\t\t\"closing zone at %llu failed %d\\n\",\n\t\t\t\t\tz->z_sector, ret);\n\t\t\t\tzonefs_warn(sb,\n\t\t\t\t\t\"remounting filesystem read-only\\n\");\n\t\t\t\tsb->s_flags |= SB_RDONLY;\n\t\t\t}\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tz->z_flags &= ~ZONEFS_ZONE_OPEN;\n\t\tzonefs_inode_account_active(inode);\n\t}\n\n\tatomic_dec(&sbi->s_wro_seq_files);\n\nunlock:\n\tmutex_unlock(&zi->i_truncate_mutex);\n}\n\nstatic int zonefs_file_release(struct inode *inode, struct file *file)\n{\n\t \n\tif (zonefs_seq_file_need_wro(inode, file))\n\t\tzonefs_seq_file_write_close(inode);\n\n\treturn 0;\n}\n\nconst struct file_operations zonefs_file_operations = {\n\t.open\t\t= zonefs_file_open,\n\t.release\t= zonefs_file_release,\n\t.fsync\t\t= zonefs_file_fsync,\n\t.mmap\t\t= zonefs_file_mmap,\n\t.llseek\t\t= zonefs_file_llseek,\n\t.read_iter\t= zonefs_file_read_iter,\n\t.write_iter\t= zonefs_file_write_iter,\n\t.splice_read\t= zonefs_file_splice_read,\n\t.splice_write\t= iter_file_splice_write,\n\t.iopoll\t\t= iocb_bio_iopoll,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}