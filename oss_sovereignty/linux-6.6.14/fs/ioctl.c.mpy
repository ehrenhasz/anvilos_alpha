{
  "module_name": "ioctl.c",
  "hash_id": "6c3dd85c061dbdb5aa026b3126cdf53df7cdfc874f52823481fdd728ef211743",
  "original_prompt": "Ingested from linux-6.6.14/fs/ioctl.c",
  "human_readable_source": "\n \n\n#include <linux/syscalls.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/compat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/falloc.h>\n#include <linux/sched/signal.h>\n#include <linux/fiemap.h>\n#include <linux/mount.h>\n#include <linux/fscrypt.h>\n#include <linux/fileattr.h>\n\n#include \"internal.h\"\n\n#include <asm/ioctls.h>\n\n \n#define FIEMAP_MAX_EXTENTS\t(UINT_MAX / sizeof(struct fiemap_extent))\n\n \nlong vfs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tint error = -ENOTTY;\n\n\tif (!filp->f_op->unlocked_ioctl)\n\t\tgoto out;\n\n\terror = filp->f_op->unlocked_ioctl(filp, cmd, arg);\n\tif (error == -ENOIOCTLCMD)\n\t\terror = -ENOTTY;\n out:\n\treturn error;\n}\nEXPORT_SYMBOL(vfs_ioctl);\n\nstatic int ioctl_fibmap(struct file *filp, int __user *p)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct super_block *sb = inode->i_sb;\n\tint error, ur_block;\n\tsector_t block;\n\n\tif (!capable(CAP_SYS_RAWIO))\n\t\treturn -EPERM;\n\n\terror = get_user(ur_block, p);\n\tif (error)\n\t\treturn error;\n\n\tif (ur_block < 0)\n\t\treturn -EINVAL;\n\n\tblock = ur_block;\n\terror = bmap(inode, &block);\n\n\tif (block > INT_MAX) {\n\t\terror = -ERANGE;\n\t\tpr_warn_ratelimited(\"[%s/%d] FS: %s File: %pD4 would truncate fibmap result\\n\",\n\t\t\t\t    current->comm, task_pid_nr(current),\n\t\t\t\t    sb->s_id, filp);\n\t}\n\n\tif (error)\n\t\tur_block = 0;\n\telse\n\t\tur_block = block;\n\n\tif (put_user(ur_block, p))\n\t\terror = -EFAULT;\n\n\treturn error;\n}\n\n \nint fiemap_fill_next_extent(struct fiemap_extent_info *fieinfo, u64 logical,\n\t\t\t    u64 phys, u64 len, u32 flags)\n{\n\tstruct fiemap_extent extent;\n\tstruct fiemap_extent __user *dest = fieinfo->fi_extents_start;\n\n\t \n\tif (fieinfo->fi_extents_max == 0) {\n\t\tfieinfo->fi_extents_mapped++;\n\t\treturn (flags & FIEMAP_EXTENT_LAST) ? 1 : 0;\n\t}\n\n\tif (fieinfo->fi_extents_mapped >= fieinfo->fi_extents_max)\n\t\treturn 1;\n\n#define SET_UNKNOWN_FLAGS\t(FIEMAP_EXTENT_DELALLOC)\n#define SET_NO_UNMOUNTED_IO_FLAGS\t(FIEMAP_EXTENT_DATA_ENCRYPTED)\n#define SET_NOT_ALIGNED_FLAGS\t(FIEMAP_EXTENT_DATA_TAIL|FIEMAP_EXTENT_DATA_INLINE)\n\n\tif (flags & SET_UNKNOWN_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_UNKNOWN;\n\tif (flags & SET_NO_UNMOUNTED_IO_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_ENCODED;\n\tif (flags & SET_NOT_ALIGNED_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_NOT_ALIGNED;\n\n\tmemset(&extent, 0, sizeof(extent));\n\textent.fe_logical = logical;\n\textent.fe_physical = phys;\n\textent.fe_length = len;\n\textent.fe_flags = flags;\n\n\tdest += fieinfo->fi_extents_mapped;\n\tif (copy_to_user(dest, &extent, sizeof(extent)))\n\t\treturn -EFAULT;\n\n\tfieinfo->fi_extents_mapped++;\n\tif (fieinfo->fi_extents_mapped == fieinfo->fi_extents_max)\n\t\treturn 1;\n\treturn (flags & FIEMAP_EXTENT_LAST) ? 1 : 0;\n}\nEXPORT_SYMBOL(fiemap_fill_next_extent);\n\n \nint fiemap_prep(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\tu64 start, u64 *len, u32 supported_flags)\n{\n\tu64 maxbytes = inode->i_sb->s_maxbytes;\n\tu32 incompat_flags;\n\tint ret = 0;\n\n\tif (*len == 0)\n\t\treturn -EINVAL;\n\tif (start >= maxbytes)\n\t\treturn -EFBIG;\n\n\t \n\tif (*len > maxbytes || (maxbytes - *len) < start)\n\t\t*len = maxbytes - start;\n\n\tsupported_flags |= FIEMAP_FLAG_SYNC;\n\tsupported_flags &= FIEMAP_FLAGS_COMPAT;\n\tincompat_flags = fieinfo->fi_flags & ~supported_flags;\n\tif (incompat_flags) {\n\t\tfieinfo->fi_flags = incompat_flags;\n\t\treturn -EBADR;\n\t}\n\n\tif (fieinfo->fi_flags & FIEMAP_FLAG_SYNC)\n\t\tret = filemap_write_and_wait(inode->i_mapping);\n\treturn ret;\n}\nEXPORT_SYMBOL(fiemap_prep);\n\nstatic int ioctl_fiemap(struct file *filp, struct fiemap __user *ufiemap)\n{\n\tstruct fiemap fiemap;\n\tstruct fiemap_extent_info fieinfo = { 0, };\n\tstruct inode *inode = file_inode(filp);\n\tint error;\n\n\tif (!inode->i_op->fiemap)\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&fiemap, ufiemap, sizeof(fiemap)))\n\t\treturn -EFAULT;\n\n\tif (fiemap.fm_extent_count > FIEMAP_MAX_EXTENTS)\n\t\treturn -EINVAL;\n\n\tfieinfo.fi_flags = fiemap.fm_flags;\n\tfieinfo.fi_extents_max = fiemap.fm_extent_count;\n\tfieinfo.fi_extents_start = ufiemap->fm_extents;\n\n\terror = inode->i_op->fiemap(inode, &fieinfo, fiemap.fm_start,\n\t\t\tfiemap.fm_length);\n\n\tfiemap.fm_flags = fieinfo.fi_flags;\n\tfiemap.fm_mapped_extents = fieinfo.fi_extents_mapped;\n\tif (copy_to_user(ufiemap, &fiemap, sizeof(fiemap)))\n\t\terror = -EFAULT;\n\n\treturn error;\n}\n\nstatic long ioctl_file_clone(struct file *dst_file, unsigned long srcfd,\n\t\t\t     u64 off, u64 olen, u64 destoff)\n{\n\tstruct fd src_file = fdget(srcfd);\n\tloff_t cloned;\n\tint ret;\n\n\tif (!src_file.file)\n\t\treturn -EBADF;\n\tcloned = vfs_clone_file_range(src_file.file, off, dst_file, destoff,\n\t\t\t\t      olen, 0);\n\tif (cloned < 0)\n\t\tret = cloned;\n\telse if (olen && cloned != olen)\n\t\tret = -EINVAL;\n\telse\n\t\tret = 0;\n\tfdput(src_file);\n\treturn ret;\n}\n\nstatic long ioctl_file_clone_range(struct file *file,\n\t\t\t\t   struct file_clone_range __user *argp)\n{\n\tstruct file_clone_range args;\n\n\tif (copy_from_user(&args, argp, sizeof(args)))\n\t\treturn -EFAULT;\n\treturn ioctl_file_clone(file, args.src_fd, args.src_offset,\n\t\t\t\targs.src_length, args.dest_offset);\n}\n\n \nstatic int ioctl_preallocate(struct file *filp, int mode, void __user *argp)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct space_resv sr;\n\n\tif (copy_from_user(&sr, argp, sizeof(sr)))\n\t\treturn -EFAULT;\n\n\tswitch (sr.l_whence) {\n\tcase SEEK_SET:\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\tsr.l_start += filp->f_pos;\n\t\tbreak;\n\tcase SEEK_END:\n\t\tsr.l_start += i_size_read(inode);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn vfs_fallocate(filp, mode | FALLOC_FL_KEEP_SIZE, sr.l_start,\n\t\t\tsr.l_len);\n}\n\n \n#if defined CONFIG_COMPAT && defined(CONFIG_X86_64)\n \nstatic int compat_ioctl_preallocate(struct file *file, int mode,\n\t\t\t\t    struct space_resv_32 __user *argp)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct space_resv_32 sr;\n\n\tif (copy_from_user(&sr, argp, sizeof(sr)))\n\t\treturn -EFAULT;\n\n\tswitch (sr.l_whence) {\n\tcase SEEK_SET:\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\tsr.l_start += file->f_pos;\n\t\tbreak;\n\tcase SEEK_END:\n\t\tsr.l_start += i_size_read(inode);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn vfs_fallocate(file, mode | FALLOC_FL_KEEP_SIZE, sr.l_start, sr.l_len);\n}\n#endif\n\nstatic int file_ioctl(struct file *filp, unsigned int cmd, int __user *p)\n{\n\tswitch (cmd) {\n\tcase FIBMAP:\n\t\treturn ioctl_fibmap(filp, p);\n\tcase FS_IOC_RESVSP:\n\tcase FS_IOC_RESVSP64:\n\t\treturn ioctl_preallocate(filp, 0, p);\n\tcase FS_IOC_UNRESVSP:\n\tcase FS_IOC_UNRESVSP64:\n\t\treturn ioctl_preallocate(filp, FALLOC_FL_PUNCH_HOLE, p);\n\tcase FS_IOC_ZERO_RANGE:\n\t\treturn ioctl_preallocate(filp, FALLOC_FL_ZERO_RANGE, p);\n\t}\n\n\treturn -ENOIOCTLCMD;\n}\n\nstatic int ioctl_fionbio(struct file *filp, int __user *argp)\n{\n\tunsigned int flag;\n\tint on, error;\n\n\terror = get_user(on, argp);\n\tif (error)\n\t\treturn error;\n\tflag = O_NONBLOCK;\n#ifdef __sparc__\n\t \n\tif (O_NONBLOCK != O_NDELAY)\n\t\tflag |= O_NDELAY;\n#endif\n\tspin_lock(&filp->f_lock);\n\tif (on)\n\t\tfilp->f_flags |= flag;\n\telse\n\t\tfilp->f_flags &= ~flag;\n\tspin_unlock(&filp->f_lock);\n\treturn error;\n}\n\nstatic int ioctl_fioasync(unsigned int fd, struct file *filp,\n\t\t\t  int __user *argp)\n{\n\tunsigned int flag;\n\tint on, error;\n\n\terror = get_user(on, argp);\n\tif (error)\n\t\treturn error;\n\tflag = on ? FASYNC : 0;\n\n\t \n\tif ((flag ^ filp->f_flags) & FASYNC) {\n\t\tif (filp->f_op->fasync)\n\t\t\t \n\t\t\terror = filp->f_op->fasync(fd, filp, on);\n\t\telse\n\t\t\terror = -ENOTTY;\n\t}\n\treturn error < 0 ? error : 0;\n}\n\nstatic int ioctl_fsfreeze(struct file *filp)\n{\n\tstruct super_block *sb = file_inode(filp)->i_sb;\n\n\tif (!ns_capable(sb->s_user_ns, CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\t \n\tif (sb->s_op->freeze_fs == NULL && sb->s_op->freeze_super == NULL)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (sb->s_op->freeze_super)\n\t\treturn sb->s_op->freeze_super(sb, FREEZE_HOLDER_USERSPACE);\n\treturn freeze_super(sb, FREEZE_HOLDER_USERSPACE);\n}\n\nstatic int ioctl_fsthaw(struct file *filp)\n{\n\tstruct super_block *sb = file_inode(filp)->i_sb;\n\n\tif (!ns_capable(sb->s_user_ns, CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\t \n\tif (sb->s_op->thaw_super)\n\t\treturn sb->s_op->thaw_super(sb, FREEZE_HOLDER_USERSPACE);\n\treturn thaw_super(sb, FREEZE_HOLDER_USERSPACE);\n}\n\nstatic int ioctl_file_dedupe_range(struct file *file,\n\t\t\t\t   struct file_dedupe_range __user *argp)\n{\n\tstruct file_dedupe_range *same = NULL;\n\tint ret;\n\tunsigned long size;\n\tu16 count;\n\n\tif (get_user(count, &argp->dest_count)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tsize = offsetof(struct file_dedupe_range, info[count]);\n\tif (size > PAGE_SIZE) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tsame = memdup_user(argp, size);\n\tif (IS_ERR(same)) {\n\t\tret = PTR_ERR(same);\n\t\tsame = NULL;\n\t\tgoto out;\n\t}\n\n\tsame->dest_count = count;\n\tret = vfs_dedupe_file_range(file, same);\n\tif (ret)\n\t\tgoto out;\n\n\tret = copy_to_user(argp, same, size);\n\tif (ret)\n\t\tret = -EFAULT;\n\nout:\n\tkfree(same);\n\treturn ret;\n}\n\n \nvoid fileattr_fill_xflags(struct fileattr *fa, u32 xflags)\n{\n\tmemset(fa, 0, sizeof(*fa));\n\tfa->fsx_valid = true;\n\tfa->fsx_xflags = xflags;\n\tif (fa->fsx_xflags & FS_XFLAG_IMMUTABLE)\n\t\tfa->flags |= FS_IMMUTABLE_FL;\n\tif (fa->fsx_xflags & FS_XFLAG_APPEND)\n\t\tfa->flags |= FS_APPEND_FL;\n\tif (fa->fsx_xflags & FS_XFLAG_SYNC)\n\t\tfa->flags |= FS_SYNC_FL;\n\tif (fa->fsx_xflags & FS_XFLAG_NOATIME)\n\t\tfa->flags |= FS_NOATIME_FL;\n\tif (fa->fsx_xflags & FS_XFLAG_NODUMP)\n\t\tfa->flags |= FS_NODUMP_FL;\n\tif (fa->fsx_xflags & FS_XFLAG_DAX)\n\t\tfa->flags |= FS_DAX_FL;\n\tif (fa->fsx_xflags & FS_XFLAG_PROJINHERIT)\n\t\tfa->flags |= FS_PROJINHERIT_FL;\n}\nEXPORT_SYMBOL(fileattr_fill_xflags);\n\n \nvoid fileattr_fill_flags(struct fileattr *fa, u32 flags)\n{\n\tmemset(fa, 0, sizeof(*fa));\n\tfa->flags_valid = true;\n\tfa->flags = flags;\n\tif (fa->flags & FS_SYNC_FL)\n\t\tfa->fsx_xflags |= FS_XFLAG_SYNC;\n\tif (fa->flags & FS_IMMUTABLE_FL)\n\t\tfa->fsx_xflags |= FS_XFLAG_IMMUTABLE;\n\tif (fa->flags & FS_APPEND_FL)\n\t\tfa->fsx_xflags |= FS_XFLAG_APPEND;\n\tif (fa->flags & FS_NODUMP_FL)\n\t\tfa->fsx_xflags |= FS_XFLAG_NODUMP;\n\tif (fa->flags & FS_NOATIME_FL)\n\t\tfa->fsx_xflags |= FS_XFLAG_NOATIME;\n\tif (fa->flags & FS_DAX_FL)\n\t\tfa->fsx_xflags |= FS_XFLAG_DAX;\n\tif (fa->flags & FS_PROJINHERIT_FL)\n\t\tfa->fsx_xflags |= FS_XFLAG_PROJINHERIT;\n}\nEXPORT_SYMBOL(fileattr_fill_flags);\n\n \nint vfs_fileattr_get(struct dentry *dentry, struct fileattr *fa)\n{\n\tstruct inode *inode = d_inode(dentry);\n\n\tif (!inode->i_op->fileattr_get)\n\t\treturn -ENOIOCTLCMD;\n\n\treturn inode->i_op->fileattr_get(dentry, fa);\n}\nEXPORT_SYMBOL(vfs_fileattr_get);\n\n \nint copy_fsxattr_to_user(const struct fileattr *fa, struct fsxattr __user *ufa)\n{\n\tstruct fsxattr xfa;\n\n\tmemset(&xfa, 0, sizeof(xfa));\n\txfa.fsx_xflags = fa->fsx_xflags;\n\txfa.fsx_extsize = fa->fsx_extsize;\n\txfa.fsx_nextents = fa->fsx_nextents;\n\txfa.fsx_projid = fa->fsx_projid;\n\txfa.fsx_cowextsize = fa->fsx_cowextsize;\n\n\tif (copy_to_user(ufa, &xfa, sizeof(xfa)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(copy_fsxattr_to_user);\n\nstatic int copy_fsxattr_from_user(struct fileattr *fa,\n\t\t\t\t  struct fsxattr __user *ufa)\n{\n\tstruct fsxattr xfa;\n\n\tif (copy_from_user(&xfa, ufa, sizeof(xfa)))\n\t\treturn -EFAULT;\n\n\tfileattr_fill_xflags(fa, xfa.fsx_xflags);\n\tfa->fsx_extsize = xfa.fsx_extsize;\n\tfa->fsx_nextents = xfa.fsx_nextents;\n\tfa->fsx_projid = xfa.fsx_projid;\n\tfa->fsx_cowextsize = xfa.fsx_cowextsize;\n\n\treturn 0;\n}\n\n \nstatic int fileattr_set_prepare(struct inode *inode,\n\t\t\t      const struct fileattr *old_ma,\n\t\t\t      struct fileattr *fa)\n{\n\tint err;\n\n\t \n\tif ((fa->flags ^ old_ma->flags) & (FS_APPEND_FL | FS_IMMUTABLE_FL) &&\n\t    !capable(CAP_LINUX_IMMUTABLE))\n\t\treturn -EPERM;\n\n\terr = fscrypt_prepare_setflags(inode, old_ma->flags, fa->flags);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (current_user_ns() != &init_user_ns) {\n\t\tif (old_ma->fsx_projid != fa->fsx_projid)\n\t\t\treturn -EINVAL;\n\t\tif ((old_ma->fsx_xflags ^ fa->fsx_xflags) &\n\t\t\t\tFS_XFLAG_PROJINHERIT)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\t \n\t\tif (old_ma->fsx_projid != fa->fsx_projid &&\n\t\t    !projid_valid(make_kprojid(&init_user_ns, fa->fsx_projid)))\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\tif ((fa->fsx_xflags & FS_XFLAG_EXTSIZE) && !S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\n\tif ((fa->fsx_xflags & FS_XFLAG_EXTSZINHERIT) &&\n\t\t\t!S_ISDIR(inode->i_mode))\n\t\treturn -EINVAL;\n\n\tif ((fa->fsx_xflags & FS_XFLAG_COWEXTSIZE) &&\n\t    !S_ISREG(inode->i_mode) && !S_ISDIR(inode->i_mode))\n\t\treturn -EINVAL;\n\n\t \n\tif ((fa->fsx_xflags & FS_XFLAG_DAX) &&\n\t    !(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode)))\n\t\treturn -EINVAL;\n\n\t \n\tif (fa->fsx_extsize == 0)\n\t\tfa->fsx_xflags &= ~(FS_XFLAG_EXTSIZE | FS_XFLAG_EXTSZINHERIT);\n\tif (fa->fsx_cowextsize == 0)\n\t\tfa->fsx_xflags &= ~FS_XFLAG_COWEXTSIZE;\n\n\treturn 0;\n}\n\n \nint vfs_fileattr_set(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\t     struct fileattr *fa)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct fileattr old_ma = {};\n\tint err;\n\n\tif (!inode->i_op->fileattr_set)\n\t\treturn -ENOIOCTLCMD;\n\n\tif (!inode_owner_or_capable(idmap, inode))\n\t\treturn -EPERM;\n\n\tinode_lock(inode);\n\terr = vfs_fileattr_get(dentry, &old_ma);\n\tif (!err) {\n\t\t \n\t\tif (fa->flags_valid) {\n\t\t\tfa->fsx_xflags |= old_ma.fsx_xflags & ~FS_XFLAG_COMMON;\n\t\t\tfa->fsx_extsize = old_ma.fsx_extsize;\n\t\t\tfa->fsx_nextents = old_ma.fsx_nextents;\n\t\t\tfa->fsx_projid = old_ma.fsx_projid;\n\t\t\tfa->fsx_cowextsize = old_ma.fsx_cowextsize;\n\t\t} else {\n\t\t\tfa->flags |= old_ma.flags & ~FS_COMMON_FL;\n\t\t}\n\t\terr = fileattr_set_prepare(inode, &old_ma, fa);\n\t\tif (!err)\n\t\t\terr = inode->i_op->fileattr_set(idmap, dentry, fa);\n\t}\n\tinode_unlock(inode);\n\n\treturn err;\n}\nEXPORT_SYMBOL(vfs_fileattr_set);\n\nstatic int ioctl_getflags(struct file *file, unsigned int __user *argp)\n{\n\tstruct fileattr fa = { .flags_valid = true };  \n\tint err;\n\n\terr = vfs_fileattr_get(file->f_path.dentry, &fa);\n\tif (!err)\n\t\terr = put_user(fa.flags, argp);\n\treturn err;\n}\n\nstatic int ioctl_setflags(struct file *file, unsigned int __user *argp)\n{\n\tstruct mnt_idmap *idmap = file_mnt_idmap(file);\n\tstruct dentry *dentry = file->f_path.dentry;\n\tstruct fileattr fa;\n\tunsigned int flags;\n\tint err;\n\n\terr = get_user(flags, argp);\n\tif (!err) {\n\t\terr = mnt_want_write_file(file);\n\t\tif (!err) {\n\t\t\tfileattr_fill_flags(&fa, flags);\n\t\t\terr = vfs_fileattr_set(idmap, dentry, &fa);\n\t\t\tmnt_drop_write_file(file);\n\t\t}\n\t}\n\treturn err;\n}\n\nstatic int ioctl_fsgetxattr(struct file *file, void __user *argp)\n{\n\tstruct fileattr fa = { .fsx_valid = true };  \n\tint err;\n\n\terr = vfs_fileattr_get(file->f_path.dentry, &fa);\n\tif (!err)\n\t\terr = copy_fsxattr_to_user(&fa, argp);\n\n\treturn err;\n}\n\nstatic int ioctl_fssetxattr(struct file *file, void __user *argp)\n{\n\tstruct mnt_idmap *idmap = file_mnt_idmap(file);\n\tstruct dentry *dentry = file->f_path.dentry;\n\tstruct fileattr fa;\n\tint err;\n\n\terr = copy_fsxattr_from_user(&fa, argp);\n\tif (!err) {\n\t\terr = mnt_want_write_file(file);\n\t\tif (!err) {\n\t\t\terr = vfs_fileattr_set(idmap, dentry, &fa);\n\t\t\tmnt_drop_write_file(file);\n\t\t}\n\t}\n\treturn err;\n}\n\n \nstatic int do_vfs_ioctl(struct file *filp, unsigned int fd,\n\t\t\tunsigned int cmd, unsigned long arg)\n{\n\tvoid __user *argp = (void __user *)arg;\n\tstruct inode *inode = file_inode(filp);\n\n\tswitch (cmd) {\n\tcase FIOCLEX:\n\t\tset_close_on_exec(fd, 1);\n\t\treturn 0;\n\n\tcase FIONCLEX:\n\t\tset_close_on_exec(fd, 0);\n\t\treturn 0;\n\n\tcase FIONBIO:\n\t\treturn ioctl_fionbio(filp, argp);\n\n\tcase FIOASYNC:\n\t\treturn ioctl_fioasync(fd, filp, argp);\n\n\tcase FIOQSIZE:\n\t\tif (S_ISDIR(inode->i_mode) || S_ISREG(inode->i_mode) ||\n\t\t    S_ISLNK(inode->i_mode)) {\n\t\t\tloff_t res = inode_get_bytes(inode);\n\t\t\treturn copy_to_user(argp, &res, sizeof(res)) ?\n\t\t\t\t\t    -EFAULT : 0;\n\t\t}\n\n\t\treturn -ENOTTY;\n\n\tcase FIFREEZE:\n\t\treturn ioctl_fsfreeze(filp);\n\n\tcase FITHAW:\n\t\treturn ioctl_fsthaw(filp);\n\n\tcase FS_IOC_FIEMAP:\n\t\treturn ioctl_fiemap(filp, argp);\n\n\tcase FIGETBSZ:\n\t\t \n\t\tif (!inode->i_sb->s_blocksize)\n\t\t\treturn -EINVAL;\n\n\t\treturn put_user(inode->i_sb->s_blocksize, (int __user *)argp);\n\n\tcase FICLONE:\n\t\treturn ioctl_file_clone(filp, arg, 0, 0, 0);\n\n\tcase FICLONERANGE:\n\t\treturn ioctl_file_clone_range(filp, argp);\n\n\tcase FIDEDUPERANGE:\n\t\treturn ioctl_file_dedupe_range(filp, argp);\n\n\tcase FIONREAD:\n\t\tif (!S_ISREG(inode->i_mode))\n\t\t\treturn vfs_ioctl(filp, cmd, arg);\n\n\t\treturn put_user(i_size_read(inode) - filp->f_pos,\n\t\t\t\t(int __user *)argp);\n\n\tcase FS_IOC_GETFLAGS:\n\t\treturn ioctl_getflags(filp, argp);\n\n\tcase FS_IOC_SETFLAGS:\n\t\treturn ioctl_setflags(filp, argp);\n\n\tcase FS_IOC_FSGETXATTR:\n\t\treturn ioctl_fsgetxattr(filp, argp);\n\n\tcase FS_IOC_FSSETXATTR:\n\t\treturn ioctl_fssetxattr(filp, argp);\n\n\tdefault:\n\t\tif (S_ISREG(inode->i_mode))\n\t\t\treturn file_ioctl(filp, cmd, argp);\n\t\tbreak;\n\t}\n\n\treturn -ENOIOCTLCMD;\n}\n\nSYSCALL_DEFINE3(ioctl, unsigned int, fd, unsigned int, cmd, unsigned long, arg)\n{\n\tstruct fd f = fdget(fd);\n\tint error;\n\n\tif (!f.file)\n\t\treturn -EBADF;\n\n\terror = security_file_ioctl(f.file, cmd, arg);\n\tif (error)\n\t\tgoto out;\n\n\terror = do_vfs_ioctl(f.file, fd, cmd, arg);\n\tif (error == -ENOIOCTLCMD)\n\t\terror = vfs_ioctl(f.file, cmd, arg);\n\nout:\n\tfdput(f);\n\treturn error;\n}\n\n#ifdef CONFIG_COMPAT\n \nlong compat_ptr_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tif (!file->f_op->unlocked_ioctl)\n\t\treturn -ENOIOCTLCMD;\n\n\treturn file->f_op->unlocked_ioctl(file, cmd, (unsigned long)compat_ptr(arg));\n}\nEXPORT_SYMBOL(compat_ptr_ioctl);\n\nCOMPAT_SYSCALL_DEFINE3(ioctl, unsigned int, fd, unsigned int, cmd,\n\t\t       compat_ulong_t, arg)\n{\n\tstruct fd f = fdget(fd);\n\tint error;\n\n\tif (!f.file)\n\t\treturn -EBADF;\n\n\t \n\terror = security_file_ioctl(f.file, cmd, arg);\n\tif (error)\n\t\tgoto out;\n\n\tswitch (cmd) {\n\t \n\tcase FICLONE:\n\t\terror = ioctl_file_clone(f.file, arg, 0, 0, 0);\n\t\tbreak;\n\n#if defined(CONFIG_X86_64)\n\t \n\tcase FS_IOC_RESVSP_32:\n\tcase FS_IOC_RESVSP64_32:\n\t\terror = compat_ioctl_preallocate(f.file, 0, compat_ptr(arg));\n\t\tbreak;\n\tcase FS_IOC_UNRESVSP_32:\n\tcase FS_IOC_UNRESVSP64_32:\n\t\terror = compat_ioctl_preallocate(f.file, FALLOC_FL_PUNCH_HOLE,\n\t\t\t\tcompat_ptr(arg));\n\t\tbreak;\n\tcase FS_IOC_ZERO_RANGE_32:\n\t\terror = compat_ioctl_preallocate(f.file, FALLOC_FL_ZERO_RANGE,\n\t\t\t\tcompat_ptr(arg));\n\t\tbreak;\n#endif\n\n\t \n\tcase FS_IOC32_GETFLAGS:\n\tcase FS_IOC32_SETFLAGS:\n\t\tcmd = (cmd == FS_IOC32_GETFLAGS) ?\n\t\t\tFS_IOC_GETFLAGS : FS_IOC_SETFLAGS;\n\t\tfallthrough;\n\t \n\tdefault:\n\t\terror = do_vfs_ioctl(f.file, fd, cmd,\n\t\t\t\t     (unsigned long)compat_ptr(arg));\n\t\tif (error != -ENOIOCTLCMD)\n\t\t\tbreak;\n\n\t\tif (f.file->f_op->compat_ioctl)\n\t\t\terror = f.file->f_op->compat_ioctl(f.file, cmd, arg);\n\t\tif (error == -ENOIOCTLCMD)\n\t\t\terror = -ENOTTY;\n\t\tbreak;\n\t}\n\n out:\n\tfdput(f);\n\n\treturn error;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}