{
  "module_name": "super.c",
  "hash_id": "43447e19bfc53a99727bfdc6ca6b5114c75f370b71630994a9d8f4718ee6c470",
  "original_prompt": "Ingested from linux-6.6.14/fs/vboxsf/super.c",
  "human_readable_source": "\n \n\n#include <linux/idr.h>\n#include <linux/fs_parser.h>\n#include <linux/magic.h>\n#include <linux/module.h>\n#include <linux/nls.h>\n#include <linux/statfs.h>\n#include <linux/vbox_utils.h>\n#include \"vfsmod.h\"\n\n#define VBOXSF_SUPER_MAGIC 0x786f4256  \n\nstatic const unsigned char VBSF_MOUNT_SIGNATURE[4] = \"\\000\\377\\376\\375\";\n\nstatic int follow_symlinks;\nmodule_param(follow_symlinks, int, 0444);\nMODULE_PARM_DESC(follow_symlinks,\n\t\t \"Let host resolve symlinks rather than showing them\");\n\nstatic DEFINE_IDA(vboxsf_bdi_ida);\nstatic DEFINE_MUTEX(vboxsf_setup_mutex);\nstatic bool vboxsf_setup_done;\nstatic struct super_operations vboxsf_super_ops;  \nstatic struct kmem_cache *vboxsf_inode_cachep;\n\nstatic char * const vboxsf_default_nls = CONFIG_NLS_DEFAULT;\n\nenum  { opt_nls, opt_uid, opt_gid, opt_ttl, opt_dmode, opt_fmode,\n\topt_dmask, opt_fmask };\n\nstatic const struct fs_parameter_spec vboxsf_fs_parameters[] = {\n\tfsparam_string\t(\"nls\",\t\topt_nls),\n\tfsparam_u32\t(\"uid\",\t\topt_uid),\n\tfsparam_u32\t(\"gid\",\t\topt_gid),\n\tfsparam_u32\t(\"ttl\",\t\topt_ttl),\n\tfsparam_u32oct\t(\"dmode\",\topt_dmode),\n\tfsparam_u32oct\t(\"fmode\",\topt_fmode),\n\tfsparam_u32oct\t(\"dmask\",\topt_dmask),\n\tfsparam_u32oct\t(\"fmask\",\topt_fmask),\n\t{}\n};\n\nstatic int vboxsf_parse_param(struct fs_context *fc, struct fs_parameter *param)\n{\n\tstruct vboxsf_fs_context *ctx = fc->fs_private;\n\tstruct fs_parse_result result;\n\tkuid_t uid;\n\tkgid_t gid;\n\tint opt;\n\n\topt = fs_parse(fc, vboxsf_fs_parameters, param, &result);\n\tif (opt < 0)\n\t\treturn opt;\n\n\tswitch (opt) {\n\tcase opt_nls:\n\t\tif (ctx->nls_name || fc->purpose != FS_CONTEXT_FOR_MOUNT) {\n\t\t\tvbg_err(\"vboxsf: Cannot reconfigure nls option\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tctx->nls_name = param->string;\n\t\tparam->string = NULL;\n\t\tbreak;\n\tcase opt_uid:\n\t\tuid = make_kuid(current_user_ns(), result.uint_32);\n\t\tif (!uid_valid(uid))\n\t\t\treturn -EINVAL;\n\t\tctx->o.uid = uid;\n\t\tbreak;\n\tcase opt_gid:\n\t\tgid = make_kgid(current_user_ns(), result.uint_32);\n\t\tif (!gid_valid(gid))\n\t\t\treturn -EINVAL;\n\t\tctx->o.gid = gid;\n\t\tbreak;\n\tcase opt_ttl:\n\t\tctx->o.ttl = msecs_to_jiffies(result.uint_32);\n\t\tbreak;\n\tcase opt_dmode:\n\t\tif (result.uint_32 & ~0777)\n\t\t\treturn -EINVAL;\n\t\tctx->o.dmode = result.uint_32;\n\t\tctx->o.dmode_set = true;\n\t\tbreak;\n\tcase opt_fmode:\n\t\tif (result.uint_32 & ~0777)\n\t\t\treturn -EINVAL;\n\t\tctx->o.fmode = result.uint_32;\n\t\tctx->o.fmode_set = true;\n\t\tbreak;\n\tcase opt_dmask:\n\t\tif (result.uint_32 & ~07777)\n\t\t\treturn -EINVAL;\n\t\tctx->o.dmask = result.uint_32;\n\t\tbreak;\n\tcase opt_fmask:\n\t\tif (result.uint_32 & ~07777)\n\t\t\treturn -EINVAL;\n\t\tctx->o.fmask = result.uint_32;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int vboxsf_fill_super(struct super_block *sb, struct fs_context *fc)\n{\n\tstruct vboxsf_fs_context *ctx = fc->fs_private;\n\tstruct shfl_string *folder_name, root_path;\n\tstruct vboxsf_sbi *sbi;\n\tstruct dentry *droot;\n\tstruct inode *iroot;\n\tchar *nls_name;\n\tsize_t size;\n\tint err;\n\n\tif (!fc->source)\n\t\treturn -EINVAL;\n\n\tsbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\n\tsbi->o = ctx->o;\n\tidr_init(&sbi->ino_idr);\n\tspin_lock_init(&sbi->ino_idr_lock);\n\tsbi->next_generation = 1;\n\tsbi->bdi_id = -1;\n\n\t \n\tnls_name = ctx->nls_name ? ctx->nls_name : vboxsf_default_nls;\n\tif (strcmp(nls_name, \"utf8\") != 0) {\n\t\tif (nls_name == vboxsf_default_nls)\n\t\t\tsbi->nls = load_nls_default();\n\t\telse\n\t\t\tsbi->nls = load_nls(nls_name);\n\n\t\tif (!sbi->nls) {\n\t\t\tvbg_err(\"vboxsf: Count not load '%s' nls\\n\", nls_name);\n\t\t\terr = -EINVAL;\n\t\t\tgoto fail_free;\n\t\t}\n\t}\n\n\tsbi->bdi_id = ida_simple_get(&vboxsf_bdi_ida, 0, 0, GFP_KERNEL);\n\tif (sbi->bdi_id < 0) {\n\t\terr = sbi->bdi_id;\n\t\tgoto fail_free;\n\t}\n\n\terr = super_setup_bdi_name(sb, \"vboxsf-%d\", sbi->bdi_id);\n\tif (err)\n\t\tgoto fail_free;\n\tsb->s_bdi->ra_pages = 0;\n\tsb->s_bdi->io_pages = 0;\n\n\t \n\tsize = strlen(fc->source) + 1;\n\tfolder_name = kmalloc(SHFLSTRING_HEADER_SIZE + size, GFP_KERNEL);\n\tif (!folder_name) {\n\t\terr = -ENOMEM;\n\t\tgoto fail_free;\n\t}\n\tfolder_name->size = size;\n\tfolder_name->length = size - 1;\n\tstrscpy(folder_name->string.utf8, fc->source, size);\n\terr = vboxsf_map_folder(folder_name, &sbi->root);\n\tkfree(folder_name);\n\tif (err) {\n\t\tvbg_err(\"vboxsf: Host rejected mount of '%s' with error %d\\n\",\n\t\t\tfc->source, err);\n\t\tgoto fail_free;\n\t}\n\n\troot_path.length = 1;\n\troot_path.size = 2;\n\troot_path.string.utf8[0] = '/';\n\troot_path.string.utf8[1] = 0;\n\terr = vboxsf_stat(sbi, &root_path, &sbi->root_info);\n\tif (err)\n\t\tgoto fail_unmap;\n\n\tsb->s_magic = VBOXSF_SUPER_MAGIC;\n\tsb->s_blocksize = 1024;\n\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\tsb->s_op = &vboxsf_super_ops;\n\tsb->s_d_op = &vboxsf_dentry_ops;\n\n\tiroot = iget_locked(sb, 0);\n\tif (!iroot) {\n\t\terr = -ENOMEM;\n\t\tgoto fail_unmap;\n\t}\n\tvboxsf_init_inode(sbi, iroot, &sbi->root_info, false);\n\tunlock_new_inode(iroot);\n\n\tdroot = d_make_root(iroot);\n\tif (!droot) {\n\t\terr = -ENOMEM;\n\t\tgoto fail_unmap;\n\t}\n\n\tsb->s_root = droot;\n\tsb->s_fs_info = sbi;\n\treturn 0;\n\nfail_unmap:\n\tvboxsf_unmap_folder(sbi->root);\nfail_free:\n\tif (sbi->bdi_id >= 0)\n\t\tida_simple_remove(&vboxsf_bdi_ida, sbi->bdi_id);\n\tif (sbi->nls)\n\t\tunload_nls(sbi->nls);\n\tidr_destroy(&sbi->ino_idr);\n\tkfree(sbi);\n\treturn err;\n}\n\nstatic void vboxsf_inode_init_once(void *data)\n{\n\tstruct vboxsf_inode *sf_i = data;\n\n\tmutex_init(&sf_i->handle_list_mutex);\n\tinode_init_once(&sf_i->vfs_inode);\n}\n\nstatic struct inode *vboxsf_alloc_inode(struct super_block *sb)\n{\n\tstruct vboxsf_inode *sf_i;\n\n\tsf_i = alloc_inode_sb(sb, vboxsf_inode_cachep, GFP_NOFS);\n\tif (!sf_i)\n\t\treturn NULL;\n\n\tsf_i->force_restat = 0;\n\tINIT_LIST_HEAD(&sf_i->handle_list);\n\n\treturn &sf_i->vfs_inode;\n}\n\nstatic void vboxsf_free_inode(struct inode *inode)\n{\n\tstruct vboxsf_sbi *sbi = VBOXSF_SBI(inode->i_sb);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sbi->ino_idr_lock, flags);\n\tidr_remove(&sbi->ino_idr, inode->i_ino);\n\tspin_unlock_irqrestore(&sbi->ino_idr_lock, flags);\n\tkmem_cache_free(vboxsf_inode_cachep, VBOXSF_I(inode));\n}\n\nstatic void vboxsf_put_super(struct super_block *sb)\n{\n\tstruct vboxsf_sbi *sbi = VBOXSF_SBI(sb);\n\n\tvboxsf_unmap_folder(sbi->root);\n\tif (sbi->bdi_id >= 0)\n\t\tida_simple_remove(&vboxsf_bdi_ida, sbi->bdi_id);\n\tif (sbi->nls)\n\t\tunload_nls(sbi->nls);\n\n\t \n\trcu_barrier();\n\tidr_destroy(&sbi->ino_idr);\n\tkfree(sbi);\n}\n\nstatic int vboxsf_statfs(struct dentry *dentry, struct kstatfs *stat)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct shfl_volinfo shfl_volinfo;\n\tstruct vboxsf_sbi *sbi;\n\tu32 buf_len;\n\tint err;\n\n\tsbi = VBOXSF_SBI(sb);\n\tbuf_len = sizeof(shfl_volinfo);\n\terr = vboxsf_fsinfo(sbi->root, 0, SHFL_INFO_GET | SHFL_INFO_VOLUME,\n\t\t\t    &buf_len, &shfl_volinfo);\n\tif (err)\n\t\treturn err;\n\n\tstat->f_type = VBOXSF_SUPER_MAGIC;\n\tstat->f_bsize = shfl_volinfo.bytes_per_allocation_unit;\n\n\tdo_div(shfl_volinfo.total_allocation_bytes,\n\t       shfl_volinfo.bytes_per_allocation_unit);\n\tstat->f_blocks = shfl_volinfo.total_allocation_bytes;\n\n\tdo_div(shfl_volinfo.available_allocation_bytes,\n\t       shfl_volinfo.bytes_per_allocation_unit);\n\tstat->f_bfree  = shfl_volinfo.available_allocation_bytes;\n\tstat->f_bavail = shfl_volinfo.available_allocation_bytes;\n\n\tstat->f_files = 1000;\n\t \n\tstat->f_ffree = 1000000;\n\tstat->f_fsid.val[0] = 0;\n\tstat->f_fsid.val[1] = 0;\n\tstat->f_namelen = 255;\n\treturn 0;\n}\n\nstatic struct super_operations vboxsf_super_ops = {\n\t.alloc_inode\t= vboxsf_alloc_inode,\n\t.free_inode\t= vboxsf_free_inode,\n\t.put_super\t= vboxsf_put_super,\n\t.statfs\t\t= vboxsf_statfs,\n};\n\nstatic int vboxsf_setup(void)\n{\n\tint err;\n\n\tmutex_lock(&vboxsf_setup_mutex);\n\n\tif (vboxsf_setup_done)\n\t\tgoto success;\n\n\tvboxsf_inode_cachep =\n\t\tkmem_cache_create(\"vboxsf_inode_cache\",\n\t\t\t\t  sizeof(struct vboxsf_inode), 0,\n\t\t\t\t  (SLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD |\n\t\t\t\t   SLAB_ACCOUNT),\n\t\t\t\t  vboxsf_inode_init_once);\n\tif (!vboxsf_inode_cachep) {\n\t\terr = -ENOMEM;\n\t\tgoto fail_nomem;\n\t}\n\n\terr = vboxsf_connect();\n\tif (err) {\n\t\tvbg_err(\"vboxsf: err %d connecting to guest PCI-device\\n\", err);\n\t\tvbg_err(\"vboxsf: make sure you are inside a VirtualBox VM\\n\");\n\t\tvbg_err(\"vboxsf: and check dmesg for vboxguest errors\\n\");\n\t\tgoto fail_free_cache;\n\t}\n\n\terr = vboxsf_set_utf8();\n\tif (err) {\n\t\tvbg_err(\"vboxsf_setutf8 error %d\\n\", err);\n\t\tgoto fail_disconnect;\n\t}\n\n\tif (!follow_symlinks) {\n\t\terr = vboxsf_set_symlinks();\n\t\tif (err)\n\t\t\tvbg_warn(\"vboxsf: Unable to show symlinks: %d\\n\", err);\n\t}\n\n\tvboxsf_setup_done = true;\nsuccess:\n\tmutex_unlock(&vboxsf_setup_mutex);\n\treturn 0;\n\nfail_disconnect:\n\tvboxsf_disconnect();\nfail_free_cache:\n\tkmem_cache_destroy(vboxsf_inode_cachep);\nfail_nomem:\n\tmutex_unlock(&vboxsf_setup_mutex);\n\treturn err;\n}\n\nstatic int vboxsf_parse_monolithic(struct fs_context *fc, void *data)\n{\n\tif (data && !memcmp(data, VBSF_MOUNT_SIGNATURE, 4)) {\n\t\tvbg_err(\"vboxsf: Old binary mount data not supported, remove obsolete mount.vboxsf and/or update your VBoxService.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn generic_parse_monolithic(fc, data);\n}\n\nstatic int vboxsf_get_tree(struct fs_context *fc)\n{\n\tint err;\n\n\terr = vboxsf_setup();\n\tif (err)\n\t\treturn err;\n\n\treturn get_tree_nodev(fc, vboxsf_fill_super);\n}\n\nstatic int vboxsf_reconfigure(struct fs_context *fc)\n{\n\tstruct vboxsf_sbi *sbi = VBOXSF_SBI(fc->root->d_sb);\n\tstruct vboxsf_fs_context *ctx = fc->fs_private;\n\tstruct inode *iroot = fc->root->d_sb->s_root->d_inode;\n\n\t \n\tsbi->o = ctx->o;\n\tvboxsf_init_inode(sbi, iroot, &sbi->root_info, true);\n\n\treturn 0;\n}\n\nstatic void vboxsf_free_fc(struct fs_context *fc)\n{\n\tstruct vboxsf_fs_context *ctx = fc->fs_private;\n\n\tkfree(ctx->nls_name);\n\tkfree(ctx);\n}\n\nstatic const struct fs_context_operations vboxsf_context_ops = {\n\t.free\t\t\t= vboxsf_free_fc,\n\t.parse_param\t\t= vboxsf_parse_param,\n\t.parse_monolithic\t= vboxsf_parse_monolithic,\n\t.get_tree\t\t= vboxsf_get_tree,\n\t.reconfigure\t\t= vboxsf_reconfigure,\n};\n\nstatic int vboxsf_init_fs_context(struct fs_context *fc)\n{\n\tstruct vboxsf_fs_context *ctx;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tcurrent_uid_gid(&ctx->o.uid, &ctx->o.gid);\n\n\tfc->fs_private = ctx;\n\tfc->ops = &vboxsf_context_ops;\n\treturn 0;\n}\n\nstatic struct file_system_type vboxsf_fs_type = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.name\t\t\t= \"vboxsf\",\n\t.init_fs_context\t= vboxsf_init_fs_context,\n\t.kill_sb\t\t= kill_anon_super\n};\n\n \nstatic int __init vboxsf_init(void)\n{\n\treturn register_filesystem(&vboxsf_fs_type);\n}\n\nstatic void __exit vboxsf_fini(void)\n{\n\tunregister_filesystem(&vboxsf_fs_type);\n\n\tmutex_lock(&vboxsf_setup_mutex);\n\tif (vboxsf_setup_done) {\n\t\tvboxsf_disconnect();\n\t\t \n\t\trcu_barrier();\n\t\tkmem_cache_destroy(vboxsf_inode_cachep);\n\t}\n\tmutex_unlock(&vboxsf_setup_mutex);\n}\n\nmodule_init(vboxsf_init);\nmodule_exit(vboxsf_fini);\n\nMODULE_DESCRIPTION(\"Oracle VM VirtualBox Module for Host File System Access\");\nMODULE_AUTHOR(\"Oracle Corporation\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS_FS(\"vboxsf\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}