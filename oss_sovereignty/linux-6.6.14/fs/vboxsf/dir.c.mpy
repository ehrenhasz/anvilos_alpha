{
  "module_name": "dir.c",
  "hash_id": "73a83cf1e2d32efe6facb7795bad38c6bfa7745d65bc8f65bae200cb9d106633",
  "original_prompt": "Ingested from linux-6.6.14/fs/vboxsf/dir.c",
  "human_readable_source": "\n \n\n#include <linux/namei.h>\n#include <linux/vbox_utils.h>\n#include \"vfsmod.h\"\n\nstatic int vboxsf_dir_open(struct inode *inode, struct file *file)\n{\n\tstruct vboxsf_sbi *sbi = VBOXSF_SBI(inode->i_sb);\n\tstruct shfl_createparms params = {};\n\tstruct vboxsf_dir_info *sf_d;\n\tint err;\n\n\tsf_d = vboxsf_dir_info_alloc();\n\tif (!sf_d)\n\t\treturn -ENOMEM;\n\n\tparams.handle = SHFL_HANDLE_NIL;\n\tparams.create_flags = SHFL_CF_DIRECTORY | SHFL_CF_ACT_OPEN_IF_EXISTS |\n\t\t\t      SHFL_CF_ACT_FAIL_IF_NEW | SHFL_CF_ACCESS_READ;\n\n\terr = vboxsf_create_at_dentry(file_dentry(file), &params);\n\tif (err)\n\t\tgoto err_free_dir_info;\n\n\tif (params.result != SHFL_FILE_EXISTS) {\n\t\terr = -ENOENT;\n\t\tgoto err_close;\n\t}\n\n\terr = vboxsf_dir_read_all(sbi, sf_d, params.handle);\n\tif (err)\n\t\tgoto err_close;\n\n\tvboxsf_close(sbi->root, params.handle);\n\tfile->private_data = sf_d;\n\treturn 0;\n\nerr_close:\n\tvboxsf_close(sbi->root, params.handle);\nerr_free_dir_info:\n\tvboxsf_dir_info_free(sf_d);\n\treturn err;\n}\n\nstatic int vboxsf_dir_release(struct inode *inode, struct file *file)\n{\n\tif (file->private_data)\n\t\tvboxsf_dir_info_free(file->private_data);\n\n\treturn 0;\n}\n\nstatic unsigned int vboxsf_get_d_type(u32 mode)\n{\n\tunsigned int d_type;\n\n\tswitch (mode & SHFL_TYPE_MASK) {\n\tcase SHFL_TYPE_FIFO:\n\t\td_type = DT_FIFO;\n\t\tbreak;\n\tcase SHFL_TYPE_DEV_CHAR:\n\t\td_type = DT_CHR;\n\t\tbreak;\n\tcase SHFL_TYPE_DIRECTORY:\n\t\td_type = DT_DIR;\n\t\tbreak;\n\tcase SHFL_TYPE_DEV_BLOCK:\n\t\td_type = DT_BLK;\n\t\tbreak;\n\tcase SHFL_TYPE_FILE:\n\t\td_type = DT_REG;\n\t\tbreak;\n\tcase SHFL_TYPE_SYMLINK:\n\t\td_type = DT_LNK;\n\t\tbreak;\n\tcase SHFL_TYPE_SOCKET:\n\t\td_type = DT_SOCK;\n\t\tbreak;\n\tcase SHFL_TYPE_WHITEOUT:\n\t\td_type = DT_WHT;\n\t\tbreak;\n\tdefault:\n\t\td_type = DT_UNKNOWN;\n\t\tbreak;\n\t}\n\treturn d_type;\n}\n\nstatic bool vboxsf_dir_emit(struct file *dir, struct dir_context *ctx)\n{\n\tstruct vboxsf_sbi *sbi = VBOXSF_SBI(file_inode(dir)->i_sb);\n\tstruct vboxsf_dir_info *sf_d = dir->private_data;\n\tstruct shfl_dirinfo *info;\n\tstruct vboxsf_dir_buf *b;\n\tunsigned int d_type;\n\tloff_t i, cur = 0;\n\tino_t fake_ino;\n\tvoid *end;\n\tint err;\n\n\tlist_for_each_entry(b, &sf_d->info_list, head) {\ntry_next_entry:\n\t\tif (ctx->pos >= cur + b->entries) {\n\t\t\tcur += b->entries;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tfor (i = 0, info = b->buf; i < ctx->pos - cur; i++) {\n\t\t\tend = &info->name.string.utf8[info->name.size];\n\t\t\t \n\t\t\tif (WARN_ON(end > (b->buf + b->used)))\n\t\t\t\treturn false;\n\t\t\tinfo = end;\n\t\t}\n\n\t\tend = &info->name.string.utf8[info->name.size];\n\t\tif (WARN_ON(end > (b->buf + b->used)))\n\t\t\treturn false;\n\n\t\t \n\t\td_type = vboxsf_get_d_type(info->info.attr.mode);\n\n\t\t \n\t\tif ((ino_t)(ctx->pos + 1) != (u64)(ctx->pos + 1)) {\n\t\t\tvbg_err(\"vboxsf: fake ino overflow, truncating dir\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tfake_ino = ctx->pos + 1;\n\n\t\tif (sbi->nls) {\n\t\t\tchar d_name[NAME_MAX];\n\n\t\t\terr = vboxsf_nlscpy(sbi, d_name, NAME_MAX,\n\t\t\t\t\t    info->name.string.utf8,\n\t\t\t\t\t    info->name.length);\n\t\t\tif (err) {\n\t\t\t\t \n\t\t\t\tctx->pos += 1;\n\t\t\t\tgoto try_next_entry;\n\t\t\t}\n\n\t\t\treturn dir_emit(ctx, d_name, strlen(d_name),\n\t\t\t\t\tfake_ino, d_type);\n\t\t}\n\n\t\treturn dir_emit(ctx, info->name.string.utf8, info->name.length,\n\t\t\t\tfake_ino, d_type);\n\t}\n\n\treturn false;\n}\n\nstatic int vboxsf_dir_iterate(struct file *dir, struct dir_context *ctx)\n{\n\tbool emitted;\n\n\tdo {\n\t\temitted = vboxsf_dir_emit(dir, ctx);\n\t\tif (emitted)\n\t\t\tctx->pos += 1;\n\t} while (emitted);\n\n\treturn 0;\n}\n\nWRAP_DIR_ITER(vboxsf_dir_iterate) \nconst struct file_operations vboxsf_dir_fops = {\n\t.open = vboxsf_dir_open,\n\t.iterate_shared = shared_vboxsf_dir_iterate,\n\t.release = vboxsf_dir_release,\n\t.read = generic_read_dir,\n\t.llseek = generic_file_llseek,\n};\n\n \nstatic int vboxsf_dentry_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\tif (d_really_is_positive(dentry))\n\t\treturn vboxsf_inode_revalidate(dentry) == 0;\n\telse\n\t\treturn vboxsf_stat_dentry(dentry, NULL) == -ENOENT;\n}\n\nconst struct dentry_operations vboxsf_dentry_ops = {\n\t.d_revalidate = vboxsf_dentry_revalidate\n};\n\n \n\nstatic struct dentry *vboxsf_dir_lookup(struct inode *parent,\n\t\t\t\t\tstruct dentry *dentry,\n\t\t\t\t\tunsigned int flags)\n{\n\tstruct vboxsf_sbi *sbi = VBOXSF_SBI(parent->i_sb);\n\tstruct shfl_fsobjinfo fsinfo;\n\tstruct inode *inode;\n\tint err;\n\n\tdentry->d_time = jiffies;\n\n\terr = vboxsf_stat_dentry(dentry, &fsinfo);\n\tif (err) {\n\t\tinode = (err == -ENOENT) ? NULL : ERR_PTR(err);\n\t} else {\n\t\tinode = vboxsf_new_inode(parent->i_sb);\n\t\tif (!IS_ERR(inode))\n\t\t\tvboxsf_init_inode(sbi, inode, &fsinfo, false);\n\t}\n\n\treturn d_splice_alias(inode, dentry);\n}\n\nstatic int vboxsf_dir_instantiate(struct inode *parent, struct dentry *dentry,\n\t\t\t\t  struct shfl_fsobjinfo *info)\n{\n\tstruct vboxsf_sbi *sbi = VBOXSF_SBI(parent->i_sb);\n\tstruct vboxsf_inode *sf_i;\n\tstruct inode *inode;\n\n\tinode = vboxsf_new_inode(parent->i_sb);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tsf_i = VBOXSF_I(inode);\n\t \n\tsf_i->force_restat = 1;\n\tvboxsf_init_inode(sbi, inode, info, false);\n\n\td_instantiate(dentry, inode);\n\n\treturn 0;\n}\n\nstatic int vboxsf_dir_create(struct inode *parent, struct dentry *dentry,\n\t\t\t     umode_t mode, bool is_dir, bool excl, u64 *handle_ret)\n{\n\tstruct vboxsf_inode *sf_parent_i = VBOXSF_I(parent);\n\tstruct vboxsf_sbi *sbi = VBOXSF_SBI(parent->i_sb);\n\tstruct shfl_createparms params = {};\n\tint err;\n\n\tparams.handle = SHFL_HANDLE_NIL;\n\tparams.create_flags = SHFL_CF_ACT_CREATE_IF_NEW | SHFL_CF_ACCESS_READWRITE;\n\tif (is_dir)\n\t\tparams.create_flags |= SHFL_CF_DIRECTORY;\n\tif (excl)\n\t\tparams.create_flags |= SHFL_CF_ACT_FAIL_IF_EXISTS;\n\n\tparams.info.attr.mode = (mode & 0777) |\n\t\t\t\t(is_dir ? SHFL_TYPE_DIRECTORY : SHFL_TYPE_FILE);\n\tparams.info.attr.additional = SHFLFSOBJATTRADD_NOTHING;\n\n\terr = vboxsf_create_at_dentry(dentry, &params);\n\tif (err)\n\t\treturn err;\n\n\tif (params.result != SHFL_FILE_CREATED)\n\t\treturn -EPERM;\n\n\terr = vboxsf_dir_instantiate(parent, dentry, &params.info);\n\tif (err)\n\t\tgoto out;\n\n\t \n\tsf_parent_i->force_restat = 1;\n\nout:\n\tif (err == 0 && handle_ret)\n\t\t*handle_ret = params.handle;\n\telse\n\t\tvboxsf_close(sbi->root, params.handle);\n\n\treturn err;\n}\n\nstatic int vboxsf_dir_mkfile(struct mnt_idmap *idmap,\n\t\t\t     struct inode *parent, struct dentry *dentry,\n\t\t\t     umode_t mode, bool excl)\n{\n\treturn vboxsf_dir_create(parent, dentry, mode, false, excl, NULL);\n}\n\nstatic int vboxsf_dir_mkdir(struct mnt_idmap *idmap,\n\t\t\t    struct inode *parent, struct dentry *dentry,\n\t\t\t    umode_t mode)\n{\n\treturn vboxsf_dir_create(parent, dentry, mode, true, true, NULL);\n}\n\nstatic int vboxsf_dir_atomic_open(struct inode *parent, struct dentry *dentry,\n\t\t\t\t  struct file *file, unsigned int flags, umode_t mode)\n{\n\tstruct vboxsf_sbi *sbi = VBOXSF_SBI(parent->i_sb);\n\tstruct vboxsf_handle *sf_handle;\n\tstruct dentry *res = NULL;\n\tu64 handle;\n\tint err;\n\n\tif (d_in_lookup(dentry)) {\n\t\tres = vboxsf_dir_lookup(parent, dentry, 0);\n\t\tif (IS_ERR(res))\n\t\t\treturn PTR_ERR(res);\n\n\t\tif (res)\n\t\t\tdentry = res;\n\t}\n\n\t \n\tif (!(flags & O_CREAT) || d_really_is_positive(dentry))\n\t\treturn finish_no_open(file, res);\n\n\terr = vboxsf_dir_create(parent, dentry, mode, false, flags & O_EXCL, &handle);\n\tif (err)\n\t\tgoto out;\n\n\tsf_handle = vboxsf_create_sf_handle(d_inode(dentry), handle, SHFL_CF_ACCESS_READWRITE);\n\tif (IS_ERR(sf_handle)) {\n\t\tvboxsf_close(sbi->root, handle);\n\t\terr = PTR_ERR(sf_handle);\n\t\tgoto out;\n\t}\n\n\terr = finish_open(file, dentry, generic_file_open);\n\tif (err) {\n\t\t \n\t\tvboxsf_release_sf_handle(d_inode(dentry), sf_handle);\n\t\tgoto out;\n\t}\n\n\tfile->private_data = sf_handle;\n\tfile->f_mode |= FMODE_CREATED;\nout:\n\tdput(res);\n\treturn err;\n}\n\nstatic int vboxsf_dir_unlink(struct inode *parent, struct dentry *dentry)\n{\n\tstruct vboxsf_sbi *sbi = VBOXSF_SBI(parent->i_sb);\n\tstruct vboxsf_inode *sf_parent_i = VBOXSF_I(parent);\n\tstruct inode *inode = d_inode(dentry);\n\tstruct shfl_string *path;\n\tu32 flags;\n\tint err;\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tflags = SHFL_REMOVE_DIR;\n\telse\n\t\tflags = SHFL_REMOVE_FILE;\n\n\tif (S_ISLNK(inode->i_mode))\n\t\tflags |= SHFL_REMOVE_SYMLINK;\n\n\tpath = vboxsf_path_from_dentry(sbi, dentry);\n\tif (IS_ERR(path))\n\t\treturn PTR_ERR(path);\n\n\terr = vboxsf_remove(sbi->root, path, flags);\n\t__putname(path);\n\tif (err)\n\t\treturn err;\n\n\t \n\tsf_parent_i->force_restat = 1;\n\n\treturn 0;\n}\n\nstatic int vboxsf_dir_rename(struct mnt_idmap *idmap,\n\t\t\t     struct inode *old_parent,\n\t\t\t     struct dentry *old_dentry,\n\t\t\t     struct inode *new_parent,\n\t\t\t     struct dentry *new_dentry,\n\t\t\t     unsigned int flags)\n{\n\tstruct vboxsf_sbi *sbi = VBOXSF_SBI(old_parent->i_sb);\n\tstruct vboxsf_inode *sf_old_parent_i = VBOXSF_I(old_parent);\n\tstruct vboxsf_inode *sf_new_parent_i = VBOXSF_I(new_parent);\n\tu32 shfl_flags = SHFL_RENAME_FILE | SHFL_RENAME_REPLACE_IF_EXISTS;\n\tstruct shfl_string *old_path, *new_path;\n\tint err;\n\n\tif (flags)\n\t\treturn -EINVAL;\n\n\told_path = vboxsf_path_from_dentry(sbi, old_dentry);\n\tif (IS_ERR(old_path))\n\t\treturn PTR_ERR(old_path);\n\n\tnew_path = vboxsf_path_from_dentry(sbi, new_dentry);\n\tif (IS_ERR(new_path)) {\n\t\terr = PTR_ERR(new_path);\n\t\tgoto err_put_old_path;\n\t}\n\n\tif (d_inode(old_dentry)->i_mode & S_IFDIR)\n\t\tshfl_flags = 0;\n\n\terr = vboxsf_rename(sbi->root, old_path, new_path, shfl_flags);\n\tif (err == 0) {\n\t\t \n\t\tsf_new_parent_i->force_restat = 1;\n\t\tsf_old_parent_i->force_restat = 1;\n\t}\n\n\t__putname(new_path);\nerr_put_old_path:\n\t__putname(old_path);\n\treturn err;\n}\n\nstatic int vboxsf_dir_symlink(struct mnt_idmap *idmap,\n\t\t\t      struct inode *parent, struct dentry *dentry,\n\t\t\t      const char *symname)\n{\n\tstruct vboxsf_inode *sf_parent_i = VBOXSF_I(parent);\n\tstruct vboxsf_sbi *sbi = VBOXSF_SBI(parent->i_sb);\n\tint symname_size = strlen(symname) + 1;\n\tstruct shfl_string *path, *ssymname;\n\tstruct shfl_fsobjinfo info;\n\tint err;\n\n\tpath = vboxsf_path_from_dentry(sbi, dentry);\n\tif (IS_ERR(path))\n\t\treturn PTR_ERR(path);\n\n\tssymname = kmalloc(SHFLSTRING_HEADER_SIZE + symname_size, GFP_KERNEL);\n\tif (!ssymname) {\n\t\t__putname(path);\n\t\treturn -ENOMEM;\n\t}\n\tssymname->length = symname_size - 1;\n\tssymname->size = symname_size;\n\tmemcpy(ssymname->string.utf8, symname, symname_size);\n\n\terr = vboxsf_symlink(sbi->root, path, ssymname, &info);\n\tkfree(ssymname);\n\t__putname(path);\n\tif (err) {\n\t\t \n\t\treturn (err == -EROFS) ? -EPERM : err;\n\t}\n\n\terr = vboxsf_dir_instantiate(parent, dentry, &info);\n\tif (err)\n\t\treturn err;\n\n\t \n\tsf_parent_i->force_restat = 1;\n\treturn 0;\n}\n\nconst struct inode_operations vboxsf_dir_iops = {\n\t.lookup  = vboxsf_dir_lookup,\n\t.create  = vboxsf_dir_mkfile,\n\t.mkdir   = vboxsf_dir_mkdir,\n\t.atomic_open = vboxsf_dir_atomic_open,\n\t.rmdir   = vboxsf_dir_unlink,\n\t.unlink  = vboxsf_dir_unlink,\n\t.rename  = vboxsf_dir_rename,\n\t.symlink = vboxsf_dir_symlink,\n\t.getattr = vboxsf_getattr,\n\t.setattr = vboxsf_setattr,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}