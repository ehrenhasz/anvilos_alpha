{
  "module_name": "utils.c",
  "hash_id": "706c4b97c2dcaf5111c02b08eac3c83f33a2074afa71f312daf70270fa4ad833",
  "original_prompt": "Ingested from linux-6.6.14/fs/vboxsf/utils.c",
  "human_readable_source": "\n \n\n#include <linux/namei.h>\n#include <linux/nls.h>\n#include <linux/sizes.h>\n#include <linux/pagemap.h>\n#include <linux/vfs.h>\n#include \"vfsmod.h\"\n\nstruct inode *vboxsf_new_inode(struct super_block *sb)\n{\n\tstruct vboxsf_sbi *sbi = VBOXSF_SBI(sb);\n\tstruct inode *inode;\n\tunsigned long flags;\n\tint cursor, ret;\n\tu32 gen;\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock_irqsave(&sbi->ino_idr_lock, flags);\n\tcursor = idr_get_cursor(&sbi->ino_idr);\n\tret = idr_alloc_cyclic(&sbi->ino_idr, inode, 1, 0, GFP_ATOMIC);\n\tif (ret >= 0 && ret < cursor)\n\t\tsbi->next_generation++;\n\tgen = sbi->next_generation;\n\tspin_unlock_irqrestore(&sbi->ino_idr_lock, flags);\n\tidr_preload_end();\n\n\tif (ret < 0) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tinode->i_ino = ret;\n\tinode->i_generation = gen;\n\treturn inode;\n}\n\n \nint vboxsf_init_inode(struct vboxsf_sbi *sbi, struct inode *inode,\n\t\t       const struct shfl_fsobjinfo *info, bool reinit)\n{\n\tconst struct shfl_fsobjattr *attr;\n\ts64 allocated;\n\tumode_t mode;\n\n\tattr = &info->attr;\n\n#define mode_set(r) ((attr->mode & (SHFL_UNIX_##r)) ? (S_##r) : 0)\n\n\tmode = mode_set(IRUSR);\n\tmode |= mode_set(IWUSR);\n\tmode |= mode_set(IXUSR);\n\n\tmode |= mode_set(IRGRP);\n\tmode |= mode_set(IWGRP);\n\tmode |= mode_set(IXGRP);\n\n\tmode |= mode_set(IROTH);\n\tmode |= mode_set(IWOTH);\n\tmode |= mode_set(IXOTH);\n\n#undef mode_set\n\n\t \n\tinode->i_flags |= S_NOATIME | S_NOCMTIME;\n\tinode->i_mapping->a_ops = &vboxsf_reg_aops;\n\n\tif (SHFL_IS_DIRECTORY(attr->mode)) {\n\t\tif (sbi->o.dmode_set)\n\t\t\tmode = sbi->o.dmode;\n\t\tmode &= ~sbi->o.dmask;\n\t\tmode |= S_IFDIR;\n\t\tif (!reinit) {\n\t\t\tinode->i_op = &vboxsf_dir_iops;\n\t\t\tinode->i_fop = &vboxsf_dir_fops;\n\t\t\t \n\t\t\tset_nlink(inode, 1);\n\t\t} else if (!S_ISDIR(inode->i_mode))\n\t\t\treturn -ESTALE;\n\t\tinode->i_mode = mode;\n\t} else if (SHFL_IS_SYMLINK(attr->mode)) {\n\t\tif (sbi->o.fmode_set)\n\t\t\tmode = sbi->o.fmode;\n\t\tmode &= ~sbi->o.fmask;\n\t\tmode |= S_IFLNK;\n\t\tif (!reinit) {\n\t\t\tinode->i_op = &vboxsf_lnk_iops;\n\t\t\tset_nlink(inode, 1);\n\t\t} else if (!S_ISLNK(inode->i_mode))\n\t\t\treturn -ESTALE;\n\t\tinode->i_mode = mode;\n\t} else {\n\t\tif (sbi->o.fmode_set)\n\t\t\tmode = sbi->o.fmode;\n\t\tmode &= ~sbi->o.fmask;\n\t\tmode |= S_IFREG;\n\t\tif (!reinit) {\n\t\t\tinode->i_op = &vboxsf_reg_iops;\n\t\t\tinode->i_fop = &vboxsf_reg_fops;\n\t\t\tset_nlink(inode, 1);\n\t\t} else if (!S_ISREG(inode->i_mode))\n\t\t\treturn -ESTALE;\n\t\tinode->i_mode = mode;\n\t}\n\n\tinode->i_uid = sbi->o.uid;\n\tinode->i_gid = sbi->o.gid;\n\n\tinode->i_size = info->size;\n\tinode->i_blkbits = 12;\n\t \n\tallocated = info->allocated + 511;\n\tdo_div(allocated, 512);\n\tinode->i_blocks = allocated;\n\n\tinode->i_atime = ns_to_timespec64(\n\t\t\t\t info->access_time.ns_relative_to_unix_epoch);\n\tinode_set_ctime_to_ts(inode,\n\t\t\t      ns_to_timespec64(info->change_time.ns_relative_to_unix_epoch));\n\tinode->i_mtime = ns_to_timespec64(\n\t\t\t   info->modification_time.ns_relative_to_unix_epoch);\n\treturn 0;\n}\n\nint vboxsf_create_at_dentry(struct dentry *dentry,\n\t\t\t    struct shfl_createparms *params)\n{\n\tstruct vboxsf_sbi *sbi = VBOXSF_SBI(dentry->d_sb);\n\tstruct shfl_string *path;\n\tint err;\n\n\tpath = vboxsf_path_from_dentry(sbi, dentry);\n\tif (IS_ERR(path))\n\t\treturn PTR_ERR(path);\n\n\terr = vboxsf_create(sbi->root, path, params);\n\t__putname(path);\n\n\treturn err;\n}\n\nint vboxsf_stat(struct vboxsf_sbi *sbi, struct shfl_string *path,\n\t\tstruct shfl_fsobjinfo *info)\n{\n\tstruct shfl_createparms params = {};\n\tint err;\n\n\tparams.handle = SHFL_HANDLE_NIL;\n\tparams.create_flags = SHFL_CF_LOOKUP | SHFL_CF_ACT_FAIL_IF_NEW;\n\n\terr = vboxsf_create(sbi->root, path, &params);\n\tif (err)\n\t\treturn err;\n\n\tif (params.result != SHFL_FILE_EXISTS)\n\t\treturn -ENOENT;\n\n\tif (info)\n\t\t*info = params.info;\n\n\treturn 0;\n}\n\nint vboxsf_stat_dentry(struct dentry *dentry, struct shfl_fsobjinfo *info)\n{\n\tstruct vboxsf_sbi *sbi = VBOXSF_SBI(dentry->d_sb);\n\tstruct shfl_string *path;\n\tint err;\n\n\tpath = vboxsf_path_from_dentry(sbi, dentry);\n\tif (IS_ERR(path))\n\t\treturn PTR_ERR(path);\n\n\terr = vboxsf_stat(sbi, path, info);\n\t__putname(path);\n\treturn err;\n}\n\nint vboxsf_inode_revalidate(struct dentry *dentry)\n{\n\tstruct vboxsf_sbi *sbi;\n\tstruct vboxsf_inode *sf_i;\n\tstruct shfl_fsobjinfo info;\n\tstruct timespec64 prev_mtime;\n\tstruct inode *inode;\n\tint err;\n\n\tif (!dentry || !d_really_is_positive(dentry))\n\t\treturn -EINVAL;\n\n\tinode = d_inode(dentry);\n\tprev_mtime = inode->i_mtime;\n\tsf_i = VBOXSF_I(inode);\n\tsbi = VBOXSF_SBI(dentry->d_sb);\n\tif (!sf_i->force_restat) {\n\t\tif (time_before(jiffies, dentry->d_time + sbi->o.ttl))\n\t\t\treturn 0;\n\t}\n\n\terr = vboxsf_stat_dentry(dentry, &info);\n\tif (err)\n\t\treturn err;\n\n\tdentry->d_time = jiffies;\n\tsf_i->force_restat = 0;\n\terr = vboxsf_init_inode(sbi, inode, &info, true);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (timespec64_compare(&inode->i_mtime, &prev_mtime) > 0)\n\t\tinvalidate_inode_pages2(inode->i_mapping);\n\n\treturn 0;\n}\n\nint vboxsf_getattr(struct mnt_idmap *idmap, const struct path *path,\n\t\t   struct kstat *kstat, u32 request_mask, unsigned int flags)\n{\n\tint err;\n\tstruct dentry *dentry = path->dentry;\n\tstruct inode *inode = d_inode(dentry);\n\tstruct vboxsf_inode *sf_i = VBOXSF_I(inode);\n\n\tswitch (flags & AT_STATX_SYNC_TYPE) {\n\tcase AT_STATX_DONT_SYNC:\n\t\terr = 0;\n\t\tbreak;\n\tcase AT_STATX_FORCE_SYNC:\n\t\tsf_i->force_restat = 1;\n\t\tfallthrough;\n\tdefault:\n\t\terr = vboxsf_inode_revalidate(dentry);\n\t}\n\tif (err)\n\t\treturn err;\n\n\tgeneric_fillattr(&nop_mnt_idmap, request_mask, d_inode(dentry), kstat);\n\treturn 0;\n}\n\nint vboxsf_setattr(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\t   struct iattr *iattr)\n{\n\tstruct vboxsf_inode *sf_i = VBOXSF_I(d_inode(dentry));\n\tstruct vboxsf_sbi *sbi = VBOXSF_SBI(dentry->d_sb);\n\tstruct shfl_createparms params = {};\n\tstruct shfl_fsobjinfo info = {};\n\tu32 buf_len;\n\tint err;\n\n\tparams.handle = SHFL_HANDLE_NIL;\n\tparams.create_flags = SHFL_CF_ACT_OPEN_IF_EXISTS |\n\t\t\t      SHFL_CF_ACT_FAIL_IF_NEW |\n\t\t\t      SHFL_CF_ACCESS_ATTR_WRITE;\n\n\t \n\tif (iattr->ia_valid & ATTR_SIZE)\n\t\tparams.create_flags |= SHFL_CF_ACCESS_WRITE;\n\n\terr = vboxsf_create_at_dentry(dentry, &params);\n\tif (err || params.result != SHFL_FILE_EXISTS)\n\t\treturn err ? err : -ENOENT;\n\n#define mode_set(r) ((iattr->ia_mode & (S_##r)) ? SHFL_UNIX_##r : 0)\n\n\t \n\tif (iattr->ia_valid & (ATTR_MODE | ATTR_ATIME | ATTR_MTIME)) {\n\t\tif (iattr->ia_valid & ATTR_MODE) {\n\t\t\tinfo.attr.mode = mode_set(IRUSR);\n\t\t\tinfo.attr.mode |= mode_set(IWUSR);\n\t\t\tinfo.attr.mode |= mode_set(IXUSR);\n\t\t\tinfo.attr.mode |= mode_set(IRGRP);\n\t\t\tinfo.attr.mode |= mode_set(IWGRP);\n\t\t\tinfo.attr.mode |= mode_set(IXGRP);\n\t\t\tinfo.attr.mode |= mode_set(IROTH);\n\t\t\tinfo.attr.mode |= mode_set(IWOTH);\n\t\t\tinfo.attr.mode |= mode_set(IXOTH);\n\n\t\t\tif (iattr->ia_mode & S_IFDIR)\n\t\t\t\tinfo.attr.mode |= SHFL_TYPE_DIRECTORY;\n\t\t\telse\n\t\t\t\tinfo.attr.mode |= SHFL_TYPE_FILE;\n\t\t}\n\n\t\tif (iattr->ia_valid & ATTR_ATIME)\n\t\t\tinfo.access_time.ns_relative_to_unix_epoch =\n\t\t\t\t\t    timespec64_to_ns(&iattr->ia_atime);\n\n\t\tif (iattr->ia_valid & ATTR_MTIME)\n\t\t\tinfo.modification_time.ns_relative_to_unix_epoch =\n\t\t\t\t\t    timespec64_to_ns(&iattr->ia_mtime);\n\n\t\t \n\n\t\tbuf_len = sizeof(info);\n\t\terr = vboxsf_fsinfo(sbi->root, params.handle,\n\t\t\t\t    SHFL_INFO_SET | SHFL_INFO_FILE, &buf_len,\n\t\t\t\t    &info);\n\t\tif (err) {\n\t\t\tvboxsf_close(sbi->root, params.handle);\n\t\t\treturn err;\n\t\t}\n\n\t\t \n\t\tsf_i->force_restat = 1;\n\t}\n\n#undef mode_set\n\n\tif (iattr->ia_valid & ATTR_SIZE) {\n\t\tmemset(&info, 0, sizeof(info));\n\t\tinfo.size = iattr->ia_size;\n\t\tbuf_len = sizeof(info);\n\t\terr = vboxsf_fsinfo(sbi->root, params.handle,\n\t\t\t\t    SHFL_INFO_SET | SHFL_INFO_SIZE, &buf_len,\n\t\t\t\t    &info);\n\t\tif (err) {\n\t\t\tvboxsf_close(sbi->root, params.handle);\n\t\t\treturn err;\n\t\t}\n\n\t\t \n\t\tsf_i->force_restat = 1;\n\t}\n\n\tvboxsf_close(sbi->root, params.handle);\n\n\t \n\tif (sf_i->force_restat)\n\t\tvboxsf_inode_revalidate(dentry);\n\n\treturn 0;\n}\n\n \nstruct shfl_string *vboxsf_path_from_dentry(struct vboxsf_sbi *sbi,\n\t\t\t\t\t    struct dentry *dentry)\n{\n\tstruct shfl_string *shfl_path;\n\tint path_len, out_len, nb;\n\tchar *buf, *path;\n\twchar_t uni;\n\tu8 *out;\n\n\tbuf = __getname();\n\tif (!buf)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpath = dentry_path_raw(dentry, buf, PATH_MAX);\n\tif (IS_ERR(path)) {\n\t\t__putname(buf);\n\t\treturn ERR_CAST(path);\n\t}\n\tpath_len = strlen(path);\n\n\tif (sbi->nls) {\n\t\tshfl_path = __getname();\n\t\tif (!shfl_path) {\n\t\t\t__putname(buf);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\n\t\tout = shfl_path->string.utf8;\n\t\tout_len = PATH_MAX - SHFLSTRING_HEADER_SIZE - 1;\n\n\t\twhile (path_len) {\n\t\t\tnb = sbi->nls->char2uni(path, path_len, &uni);\n\t\t\tif (nb < 0) {\n\t\t\t\t__putname(shfl_path);\n\t\t\t\t__putname(buf);\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\t}\n\t\t\tpath += nb;\n\t\t\tpath_len -= nb;\n\n\t\t\tnb = utf32_to_utf8(uni, out, out_len);\n\t\t\tif (nb < 0) {\n\t\t\t\t__putname(shfl_path);\n\t\t\t\t__putname(buf);\n\t\t\t\treturn ERR_PTR(-ENAMETOOLONG);\n\t\t\t}\n\t\t\tout += nb;\n\t\t\tout_len -= nb;\n\t\t}\n\t\t*out = 0;\n\t\tshfl_path->length = out - shfl_path->string.utf8;\n\t\tshfl_path->size = shfl_path->length + 1;\n\t\t__putname(buf);\n\t} else {\n\t\tif ((SHFLSTRING_HEADER_SIZE + path_len + 1) > PATH_MAX) {\n\t\t\t__putname(buf);\n\t\t\treturn ERR_PTR(-ENAMETOOLONG);\n\t\t}\n\t\t \n\t\tshfl_path = (struct shfl_string *)buf;\n\t\tmemmove(shfl_path->string.utf8, path, path_len);\n\t\tshfl_path->string.utf8[path_len] = 0;\n\t\tshfl_path->length = path_len;\n\t\tshfl_path->size = path_len + 1;\n\t}\n\n\treturn shfl_path;\n}\n\nint vboxsf_nlscpy(struct vboxsf_sbi *sbi, char *name, size_t name_bound_len,\n\t\t  const unsigned char *utf8_name, size_t utf8_len)\n{\n\tconst char *in;\n\tchar *out;\n\tsize_t out_len;\n\tsize_t out_bound_len;\n\tsize_t in_bound_len;\n\n\tin = utf8_name;\n\tin_bound_len = utf8_len;\n\n\tout = name;\n\tout_len = 0;\n\t \n\tout_bound_len = name_bound_len - 1;\n\n\twhile (in_bound_len) {\n\t\tint nb;\n\t\tunicode_t uni;\n\n\t\tnb = utf8_to_utf32(in, in_bound_len, &uni);\n\t\tif (nb < 0)\n\t\t\treturn -EINVAL;\n\n\t\tin += nb;\n\t\tin_bound_len -= nb;\n\n\t\tnb = sbi->nls->uni2char(uni, out, out_bound_len);\n\t\tif (nb < 0)\n\t\t\treturn nb;\n\n\t\tout += nb;\n\t\tout_bound_len -= nb;\n\t\tout_len += nb;\n\t}\n\n\t*out = 0;\n\n\treturn 0;\n}\n\nstatic struct vboxsf_dir_buf *vboxsf_dir_buf_alloc(struct list_head *list)\n{\n\tstruct vboxsf_dir_buf *b;\n\n\tb = kmalloc(sizeof(*b), GFP_KERNEL);\n\tif (!b)\n\t\treturn NULL;\n\n\tb->buf = kmalloc(DIR_BUFFER_SIZE, GFP_KERNEL);\n\tif (!b->buf) {\n\t\tkfree(b);\n\t\treturn NULL;\n\t}\n\n\tb->entries = 0;\n\tb->used = 0;\n\tb->free = DIR_BUFFER_SIZE;\n\tlist_add(&b->head, list);\n\n\treturn b;\n}\n\nstatic void vboxsf_dir_buf_free(struct vboxsf_dir_buf *b)\n{\n\tlist_del(&b->head);\n\tkfree(b->buf);\n\tkfree(b);\n}\n\nstruct vboxsf_dir_info *vboxsf_dir_info_alloc(void)\n{\n\tstruct vboxsf_dir_info *p;\n\n\tp = kmalloc(sizeof(*p), GFP_KERNEL);\n\tif (!p)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&p->info_list);\n\treturn p;\n}\n\nvoid vboxsf_dir_info_free(struct vboxsf_dir_info *p)\n{\n\tstruct list_head *list, *pos, *tmp;\n\n\tlist = &p->info_list;\n\tlist_for_each_safe(pos, tmp, list) {\n\t\tstruct vboxsf_dir_buf *b;\n\n\t\tb = list_entry(pos, struct vboxsf_dir_buf, head);\n\t\tvboxsf_dir_buf_free(b);\n\t}\n\tkfree(p);\n}\n\nint vboxsf_dir_read_all(struct vboxsf_sbi *sbi, struct vboxsf_dir_info *sf_d,\n\t\t\tu64 handle)\n{\n\tstruct vboxsf_dir_buf *b;\n\tu32 entries, size;\n\tint err = 0;\n\tvoid *buf;\n\n\t \n\twhile (err == 0) {\n\t\tb = vboxsf_dir_buf_alloc(&sf_d->info_list);\n\t\tif (!b) {\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tbuf = b->buf;\n\t\tsize = b->free;\n\n\t\terr = vboxsf_dirinfo(sbi->root, handle, NULL, 0, 0,\n\t\t\t\t     &size, buf, &entries);\n\t\tif (err < 0)\n\t\t\tbreak;\n\n\t\tb->entries += entries;\n\t\tb->free -= size;\n\t\tb->used += size;\n\t}\n\n\tif (b && b->used == 0)\n\t\tvboxsf_dir_buf_free(b);\n\n\t \n\tif (err > 0 || err == -EILSEQ)\n\t\terr = 0;\n\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}