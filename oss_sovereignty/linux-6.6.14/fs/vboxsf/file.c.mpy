{
  "module_name": "file.c",
  "hash_id": "3adbac03dd1f98262cbea4ef8436dd87c2cbdc5cf5018d9620dc019817549e19",
  "original_prompt": "Ingested from linux-6.6.14/fs/vboxsf/file.c",
  "human_readable_source": "\n \n\n#include <linux/mm.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/sizes.h>\n#include \"vfsmod.h\"\n\nstruct vboxsf_handle {\n\tu64 handle;\n\tu32 root;\n\tu32 access_flags;\n\tstruct kref refcount;\n\tstruct list_head head;\n};\n\nstruct vboxsf_handle *vboxsf_create_sf_handle(struct inode *inode,\n\t\t\t\t\t      u64 handle, u32 access_flags)\n{\n\tstruct vboxsf_inode *sf_i = VBOXSF_I(inode);\n\tstruct vboxsf_handle *sf_handle;\n\n\tsf_handle = kmalloc(sizeof(*sf_handle), GFP_KERNEL);\n\tif (!sf_handle)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tsf_i->force_restat = 1;\n\n\t \n\tsf_handle->handle = handle;\n\tsf_handle->root = VBOXSF_SBI(inode->i_sb)->root;\n\tsf_handle->access_flags = access_flags;\n\tkref_init(&sf_handle->refcount);\n\n\tmutex_lock(&sf_i->handle_list_mutex);\n\tlist_add(&sf_handle->head, &sf_i->handle_list);\n\tmutex_unlock(&sf_i->handle_list_mutex);\n\n\treturn sf_handle;\n}\n\nstatic int vboxsf_file_open(struct inode *inode, struct file *file)\n{\n\tstruct vboxsf_sbi *sbi = VBOXSF_SBI(inode->i_sb);\n\tstruct shfl_createparms params = {};\n\tstruct vboxsf_handle *sf_handle;\n\tu32 access_flags = 0;\n\tint err;\n\n\t \n\tparams.handle = SHFL_HANDLE_NIL;\n\tif (file->f_flags & O_CREAT) {\n\t\tparams.create_flags |= SHFL_CF_ACT_CREATE_IF_NEW;\n\t\t \n\t\tif (file->f_flags & O_TRUNC)\n\t\t\tparams.create_flags |= SHFL_CF_ACT_OVERWRITE_IF_EXISTS;\n\t\telse\n\t\t\tparams.create_flags |= SHFL_CF_ACT_OPEN_IF_EXISTS;\n\t} else {\n\t\tparams.create_flags |= SHFL_CF_ACT_FAIL_IF_NEW;\n\t\tif (file->f_flags & O_TRUNC)\n\t\t\tparams.create_flags |= SHFL_CF_ACT_OVERWRITE_IF_EXISTS;\n\t}\n\n\tswitch (file->f_flags & O_ACCMODE) {\n\tcase O_RDONLY:\n\t\taccess_flags |= SHFL_CF_ACCESS_READ;\n\t\tbreak;\n\n\tcase O_WRONLY:\n\t\taccess_flags |= SHFL_CF_ACCESS_WRITE;\n\t\tbreak;\n\n\tcase O_RDWR:\n\t\taccess_flags |= SHFL_CF_ACCESS_READWRITE;\n\t\tbreak;\n\n\tdefault:\n\t\tWARN_ON(1);\n\t}\n\n\tif (file->f_flags & O_APPEND)\n\t\taccess_flags |= SHFL_CF_ACCESS_APPEND;\n\n\tparams.create_flags |= access_flags;\n\tparams.info.attr.mode = inode->i_mode;\n\n\terr = vboxsf_create_at_dentry(file_dentry(file), &params);\n\tif (err == 0 && params.handle == SHFL_HANDLE_NIL)\n\t\terr = (params.result == SHFL_FILE_EXISTS) ? -EEXIST : -ENOENT;\n\tif (err)\n\t\treturn err;\n\n\tsf_handle = vboxsf_create_sf_handle(inode, params.handle, access_flags);\n\tif (IS_ERR(sf_handle)) {\n\t\tvboxsf_close(sbi->root, params.handle);\n\t\treturn PTR_ERR(sf_handle);\n\t}\n\n\tfile->private_data = sf_handle;\n\treturn 0;\n}\n\nstatic void vboxsf_handle_release(struct kref *refcount)\n{\n\tstruct vboxsf_handle *sf_handle =\n\t\tcontainer_of(refcount, struct vboxsf_handle, refcount);\n\n\tvboxsf_close(sf_handle->root, sf_handle->handle);\n\tkfree(sf_handle);\n}\n\nvoid vboxsf_release_sf_handle(struct inode *inode, struct vboxsf_handle *sf_handle)\n{\n\tstruct vboxsf_inode *sf_i = VBOXSF_I(inode);\n\n\tmutex_lock(&sf_i->handle_list_mutex);\n\tlist_del(&sf_handle->head);\n\tmutex_unlock(&sf_i->handle_list_mutex);\n\n\tkref_put(&sf_handle->refcount, vboxsf_handle_release);\n}\n\nstatic int vboxsf_file_release(struct inode *inode, struct file *file)\n{\n\t \n\tfilemap_write_and_wait(inode->i_mapping);\n\n\tvboxsf_release_sf_handle(inode, file->private_data);\n\treturn 0;\n}\n\n \nstatic void vboxsf_vma_close(struct vm_area_struct *vma)\n{\n\tfilemap_write_and_wait(vma->vm_file->f_mapping);\n}\n\nstatic const struct vm_operations_struct vboxsf_file_vm_ops = {\n\t.close\t\t= vboxsf_vma_close,\n\t.fault\t\t= filemap_fault,\n\t.map_pages\t= filemap_map_pages,\n};\n\nstatic int vboxsf_file_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tint err;\n\n\terr = generic_file_mmap(file, vma);\n\tif (!err)\n\t\tvma->vm_ops = &vboxsf_file_vm_ops;\n\n\treturn err;\n}\n\n \nconst struct file_operations vboxsf_reg_fops = {\n\t.llseek = generic_file_llseek,\n\t.read_iter = generic_file_read_iter,\n\t.write_iter = generic_file_write_iter,\n\t.mmap = vboxsf_file_mmap,\n\t.open = vboxsf_file_open,\n\t.release = vboxsf_file_release,\n\t.fsync = noop_fsync,\n\t.splice_read = filemap_splice_read,\n};\n\nconst struct inode_operations vboxsf_reg_iops = {\n\t.getattr = vboxsf_getattr,\n\t.setattr = vboxsf_setattr\n};\n\nstatic int vboxsf_read_folio(struct file *file, struct folio *folio)\n{\n\tstruct page *page = &folio->page;\n\tstruct vboxsf_handle *sf_handle = file->private_data;\n\tloff_t off = page_offset(page);\n\tu32 nread = PAGE_SIZE;\n\tu8 *buf;\n\tint err;\n\n\tbuf = kmap(page);\n\n\terr = vboxsf_read(sf_handle->root, sf_handle->handle, off, &nread, buf);\n\tif (err == 0) {\n\t\tmemset(&buf[nread], 0, PAGE_SIZE - nread);\n\t\tflush_dcache_page(page);\n\t\tSetPageUptodate(page);\n\t} else {\n\t\tSetPageError(page);\n\t}\n\n\tkunmap(page);\n\tunlock_page(page);\n\treturn err;\n}\n\nstatic struct vboxsf_handle *vboxsf_get_write_handle(struct vboxsf_inode *sf_i)\n{\n\tstruct vboxsf_handle *h, *sf_handle = NULL;\n\n\tmutex_lock(&sf_i->handle_list_mutex);\n\tlist_for_each_entry(h, &sf_i->handle_list, head) {\n\t\tif (h->access_flags == SHFL_CF_ACCESS_WRITE ||\n\t\t    h->access_flags == SHFL_CF_ACCESS_READWRITE) {\n\t\t\tkref_get(&h->refcount);\n\t\t\tsf_handle = h;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&sf_i->handle_list_mutex);\n\n\treturn sf_handle;\n}\n\nstatic int vboxsf_writepage(struct page *page, struct writeback_control *wbc)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct vboxsf_inode *sf_i = VBOXSF_I(inode);\n\tstruct vboxsf_handle *sf_handle;\n\tloff_t off = page_offset(page);\n\tloff_t size = i_size_read(inode);\n\tu32 nwrite = PAGE_SIZE;\n\tu8 *buf;\n\tint err;\n\n\tif (off + PAGE_SIZE > size)\n\t\tnwrite = size & ~PAGE_MASK;\n\n\tsf_handle = vboxsf_get_write_handle(sf_i);\n\tif (!sf_handle)\n\t\treturn -EBADF;\n\n\tbuf = kmap(page);\n\terr = vboxsf_write(sf_handle->root, sf_handle->handle,\n\t\t\t   off, &nwrite, buf);\n\tkunmap(page);\n\n\tkref_put(&sf_handle->refcount, vboxsf_handle_release);\n\n\tif (err == 0) {\n\t\tClearPageError(page);\n\t\t \n\t\tsf_i->force_restat = 1;\n\t} else {\n\t\tClearPageUptodate(page);\n\t}\n\n\tunlock_page(page);\n\treturn err;\n}\n\nstatic int vboxsf_write_end(struct file *file, struct address_space *mapping,\n\t\t\t    loff_t pos, unsigned int len, unsigned int copied,\n\t\t\t    struct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct vboxsf_handle *sf_handle = file->private_data;\n\tunsigned int from = pos & ~PAGE_MASK;\n\tu32 nwritten = len;\n\tu8 *buf;\n\tint err;\n\n\t \n\tif (!PageUptodate(page) && copied < len)\n\t\tzero_user(page, from + copied, len - copied);\n\n\tbuf = kmap(page);\n\terr = vboxsf_write(sf_handle->root, sf_handle->handle,\n\t\t\t   pos, &nwritten, buf + from);\n\tkunmap(page);\n\n\tif (err) {\n\t\tnwritten = 0;\n\t\tgoto out;\n\t}\n\n\t \n\tVBOXSF_I(inode)->force_restat = 1;\n\n\tif (!PageUptodate(page) && nwritten == PAGE_SIZE)\n\t\tSetPageUptodate(page);\n\n\tpos += nwritten;\n\tif (pos > inode->i_size)\n\t\ti_size_write(inode, pos);\n\nout:\n\tunlock_page(page);\n\tput_page(page);\n\n\treturn nwritten;\n}\n\n \nconst struct address_space_operations vboxsf_reg_aops = {\n\t.read_folio = vboxsf_read_folio,\n\t.writepage = vboxsf_writepage,\n\t.dirty_folio = filemap_dirty_folio,\n\t.write_begin = simple_write_begin,\n\t.write_end = vboxsf_write_end,\n};\n\nstatic const char *vboxsf_get_link(struct dentry *dentry, struct inode *inode,\n\t\t\t\t   struct delayed_call *done)\n{\n\tstruct vboxsf_sbi *sbi = VBOXSF_SBI(inode->i_sb);\n\tstruct shfl_string *path;\n\tchar *link;\n\tint err;\n\n\tif (!dentry)\n\t\treturn ERR_PTR(-ECHILD);\n\n\tpath = vboxsf_path_from_dentry(sbi, dentry);\n\tif (IS_ERR(path))\n\t\treturn ERR_CAST(path);\n\n\tlink = kzalloc(PATH_MAX, GFP_KERNEL);\n\tif (!link) {\n\t\t__putname(path);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\terr = vboxsf_readlink(sbi->root, path, PATH_MAX, link);\n\t__putname(path);\n\tif (err) {\n\t\tkfree(link);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tset_delayed_call(done, kfree_link, link);\n\treturn link;\n}\n\nconst struct inode_operations vboxsf_lnk_iops = {\n\t.get_link = vboxsf_get_link\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}