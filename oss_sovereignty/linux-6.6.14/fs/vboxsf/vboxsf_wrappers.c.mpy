{
  "module_name": "vboxsf_wrappers.c",
  "hash_id": "f48bfaaf7439d6ffb4444a1f42d7f98591c9a25ab310e8311eaa93f42d14001c",
  "original_prompt": "Ingested from linux-6.6.14/fs/vboxsf/vboxsf_wrappers.c",
  "human_readable_source": "\n \n\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/vbox_err.h>\n#include <linux/vbox_utils.h>\n#include \"vfsmod.h\"\n\n#define SHFL_REQUEST \\\n\t(VMMDEV_REQUESTOR_KERNEL | VMMDEV_REQUESTOR_USR_DRV_OTHER | \\\n\t VMMDEV_REQUESTOR_CON_DONT_KNOW | VMMDEV_REQUESTOR_TRUST_NOT_GIVEN)\n\nstatic u32 vboxsf_client_id;\n\nint vboxsf_connect(void)\n{\n\tstruct vbg_dev *gdev;\n\tstruct vmmdev_hgcm_service_location loc;\n\tint err, vbox_status;\n\n\tloc.type = VMMDEV_HGCM_LOC_LOCALHOST_EXISTING;\n\tstrcpy(loc.u.localhost.service_name, \"VBoxSharedFolders\");\n\n\tgdev = vbg_get_gdev();\n\tif (IS_ERR(gdev))\n\t\treturn -ENODEV;\t \n\n\terr = vbg_hgcm_connect(gdev, SHFL_REQUEST, &loc,\n\t\t\t       &vboxsf_client_id, &vbox_status);\n\tvbg_put_gdev(gdev);\n\n\treturn err ? err : vbg_status_code_to_errno(vbox_status);\n}\n\nvoid vboxsf_disconnect(void)\n{\n\tstruct vbg_dev *gdev;\n\tint vbox_status;\n\n\tgdev = vbg_get_gdev();\n\tif (IS_ERR(gdev))\n\t\treturn;    \n\n\tvbg_hgcm_disconnect(gdev, SHFL_REQUEST, vboxsf_client_id, &vbox_status);\n\tvbg_put_gdev(gdev);\n}\n\nstatic int vboxsf_call(u32 function, void *parms, u32 parm_count, int *status)\n{\n\tstruct vbg_dev *gdev;\n\tint err, vbox_status;\n\n\tgdev = vbg_get_gdev();\n\tif (IS_ERR(gdev))\n\t\treturn -ESHUTDOWN;  \n\n\terr = vbg_hgcm_call(gdev, SHFL_REQUEST, vboxsf_client_id, function,\n\t\t\t    U32_MAX, parms, parm_count, &vbox_status);\n\tvbg_put_gdev(gdev);\n\n\tif (err < 0)\n\t\treturn err;\n\n\tif (status)\n\t\t*status = vbox_status;\n\n\treturn vbg_status_code_to_errno(vbox_status);\n}\n\nint vboxsf_map_folder(struct shfl_string *folder_name, u32 *root)\n{\n\tstruct shfl_map_folder parms;\n\tint err, status;\n\n\tparms.path.type = VMMDEV_HGCM_PARM_TYPE_LINADDR_KERNEL;\n\tparms.path.u.pointer.size = shfl_string_buf_size(folder_name);\n\tparms.path.u.pointer.u.linear_addr = (uintptr_t)folder_name;\n\n\tparms.root.type = VMMDEV_HGCM_PARM_TYPE_32BIT;\n\tparms.root.u.value32 = 0;\n\n\tparms.delimiter.type = VMMDEV_HGCM_PARM_TYPE_32BIT;\n\tparms.delimiter.u.value32 = '/';\n\n\tparms.case_sensitive.type = VMMDEV_HGCM_PARM_TYPE_32BIT;\n\tparms.case_sensitive.u.value32 = 1;\n\n\terr = vboxsf_call(SHFL_FN_MAP_FOLDER, &parms, SHFL_CPARMS_MAP_FOLDER,\n\t\t\t  &status);\n\tif (err == -ENOSYS && status == VERR_NOT_IMPLEMENTED)\n\t\tvbg_err(\"%s: Error host is too old\\n\", __func__);\n\n\t*root = parms.root.u.value32;\n\treturn err;\n}\n\nint vboxsf_unmap_folder(u32 root)\n{\n\tstruct shfl_unmap_folder parms;\n\n\tparms.root.type = VMMDEV_HGCM_PARM_TYPE_32BIT;\n\tparms.root.u.value32 = root;\n\n\treturn vboxsf_call(SHFL_FN_UNMAP_FOLDER, &parms,\n\t\t\t   SHFL_CPARMS_UNMAP_FOLDER, NULL);\n}\n\n \nint vboxsf_create(u32 root, struct shfl_string *parsed_path,\n\t\t  struct shfl_createparms *create_parms)\n{\n\tstruct shfl_create parms;\n\n\tparms.root.type = VMMDEV_HGCM_PARM_TYPE_32BIT;\n\tparms.root.u.value32 = root;\n\n\tparms.path.type = VMMDEV_HGCM_PARM_TYPE_LINADDR_KERNEL;\n\tparms.path.u.pointer.size = shfl_string_buf_size(parsed_path);\n\tparms.path.u.pointer.u.linear_addr = (uintptr_t)parsed_path;\n\n\tparms.parms.type = VMMDEV_HGCM_PARM_TYPE_LINADDR_KERNEL;\n\tparms.parms.u.pointer.size = sizeof(struct shfl_createparms);\n\tparms.parms.u.pointer.u.linear_addr = (uintptr_t)create_parms;\n\n\treturn vboxsf_call(SHFL_FN_CREATE, &parms, SHFL_CPARMS_CREATE, NULL);\n}\n\nint vboxsf_close(u32 root, u64 handle)\n{\n\tstruct shfl_close parms;\n\n\tparms.root.type = VMMDEV_HGCM_PARM_TYPE_32BIT;\n\tparms.root.u.value32 = root;\n\n\tparms.handle.type = VMMDEV_HGCM_PARM_TYPE_64BIT;\n\tparms.handle.u.value64 = handle;\n\n\treturn vboxsf_call(SHFL_FN_CLOSE, &parms, SHFL_CPARMS_CLOSE, NULL);\n}\n\nint vboxsf_remove(u32 root, struct shfl_string *parsed_path, u32 flags)\n{\n\tstruct shfl_remove parms;\n\n\tparms.root.type = VMMDEV_HGCM_PARM_TYPE_32BIT;\n\tparms.root.u.value32 = root;\n\n\tparms.path.type = VMMDEV_HGCM_PARM_TYPE_LINADDR_KERNEL_IN;\n\tparms.path.u.pointer.size = shfl_string_buf_size(parsed_path);\n\tparms.path.u.pointer.u.linear_addr = (uintptr_t)parsed_path;\n\n\tparms.flags.type = VMMDEV_HGCM_PARM_TYPE_32BIT;\n\tparms.flags.u.value32 = flags;\n\n\treturn vboxsf_call(SHFL_FN_REMOVE, &parms, SHFL_CPARMS_REMOVE, NULL);\n}\n\nint vboxsf_rename(u32 root, struct shfl_string *src_path,\n\t\t  struct shfl_string *dest_path, u32 flags)\n{\n\tstruct shfl_rename parms;\n\n\tparms.root.type = VMMDEV_HGCM_PARM_TYPE_32BIT;\n\tparms.root.u.value32 = root;\n\n\tparms.src.type = VMMDEV_HGCM_PARM_TYPE_LINADDR_KERNEL_IN;\n\tparms.src.u.pointer.size = shfl_string_buf_size(src_path);\n\tparms.src.u.pointer.u.linear_addr = (uintptr_t)src_path;\n\n\tparms.dest.type = VMMDEV_HGCM_PARM_TYPE_LINADDR_KERNEL_IN;\n\tparms.dest.u.pointer.size = shfl_string_buf_size(dest_path);\n\tparms.dest.u.pointer.u.linear_addr = (uintptr_t)dest_path;\n\n\tparms.flags.type = VMMDEV_HGCM_PARM_TYPE_32BIT;\n\tparms.flags.u.value32 = flags;\n\n\treturn vboxsf_call(SHFL_FN_RENAME, &parms, SHFL_CPARMS_RENAME, NULL);\n}\n\nint vboxsf_read(u32 root, u64 handle, u64 offset, u32 *buf_len, u8 *buf)\n{\n\tstruct shfl_read parms;\n\tint err;\n\n\tparms.root.type = VMMDEV_HGCM_PARM_TYPE_32BIT;\n\tparms.root.u.value32 = root;\n\n\tparms.handle.type = VMMDEV_HGCM_PARM_TYPE_64BIT;\n\tparms.handle.u.value64 = handle;\n\tparms.offset.type = VMMDEV_HGCM_PARM_TYPE_64BIT;\n\tparms.offset.u.value64 = offset;\n\tparms.cb.type = VMMDEV_HGCM_PARM_TYPE_32BIT;\n\tparms.cb.u.value32 = *buf_len;\n\tparms.buffer.type = VMMDEV_HGCM_PARM_TYPE_LINADDR_KERNEL_OUT;\n\tparms.buffer.u.pointer.size = *buf_len;\n\tparms.buffer.u.pointer.u.linear_addr = (uintptr_t)buf;\n\n\terr = vboxsf_call(SHFL_FN_READ, &parms, SHFL_CPARMS_READ, NULL);\n\n\t*buf_len = parms.cb.u.value32;\n\treturn err;\n}\n\nint vboxsf_write(u32 root, u64 handle, u64 offset, u32 *buf_len, u8 *buf)\n{\n\tstruct shfl_write parms;\n\tint err;\n\n\tparms.root.type = VMMDEV_HGCM_PARM_TYPE_32BIT;\n\tparms.root.u.value32 = root;\n\n\tparms.handle.type = VMMDEV_HGCM_PARM_TYPE_64BIT;\n\tparms.handle.u.value64 = handle;\n\tparms.offset.type = VMMDEV_HGCM_PARM_TYPE_64BIT;\n\tparms.offset.u.value64 = offset;\n\tparms.cb.type = VMMDEV_HGCM_PARM_TYPE_32BIT;\n\tparms.cb.u.value32 = *buf_len;\n\tparms.buffer.type = VMMDEV_HGCM_PARM_TYPE_LINADDR_KERNEL_IN;\n\tparms.buffer.u.pointer.size = *buf_len;\n\tparms.buffer.u.pointer.u.linear_addr = (uintptr_t)buf;\n\n\terr = vboxsf_call(SHFL_FN_WRITE, &parms, SHFL_CPARMS_WRITE, NULL);\n\n\t*buf_len = parms.cb.u.value32;\n\treturn err;\n}\n\n \nint vboxsf_dirinfo(u32 root, u64 handle,\n\t\t   struct shfl_string *parsed_path, u32 flags, u32 index,\n\t\t   u32 *buf_len, struct shfl_dirinfo *buf, u32 *file_count)\n{\n\tstruct shfl_list parms;\n\tint err, status;\n\n\tparms.root.type = VMMDEV_HGCM_PARM_TYPE_32BIT;\n\tparms.root.u.value32 = root;\n\n\tparms.handle.type = VMMDEV_HGCM_PARM_TYPE_64BIT;\n\tparms.handle.u.value64 = handle;\n\tparms.flags.type = VMMDEV_HGCM_PARM_TYPE_32BIT;\n\tparms.flags.u.value32 = flags;\n\tparms.cb.type = VMMDEV_HGCM_PARM_TYPE_32BIT;\n\tparms.cb.u.value32 = *buf_len;\n\tif (parsed_path) {\n\t\tparms.path.type = VMMDEV_HGCM_PARM_TYPE_LINADDR_KERNEL_IN;\n\t\tparms.path.u.pointer.size = shfl_string_buf_size(parsed_path);\n\t\tparms.path.u.pointer.u.linear_addr = (uintptr_t)parsed_path;\n\t} else {\n\t\tparms.path.type = VMMDEV_HGCM_PARM_TYPE_LINADDR_IN;\n\t\tparms.path.u.pointer.size = 0;\n\t\tparms.path.u.pointer.u.linear_addr = 0;\n\t}\n\n\tparms.buffer.type = VMMDEV_HGCM_PARM_TYPE_LINADDR_KERNEL_OUT;\n\tparms.buffer.u.pointer.size = *buf_len;\n\tparms.buffer.u.pointer.u.linear_addr = (uintptr_t)buf;\n\n\tparms.resume_point.type = VMMDEV_HGCM_PARM_TYPE_32BIT;\n\tparms.resume_point.u.value32 = index;\n\tparms.file_count.type = VMMDEV_HGCM_PARM_TYPE_32BIT;\n\tparms.file_count.u.value32 = 0;\t \n\n\terr = vboxsf_call(SHFL_FN_LIST, &parms, SHFL_CPARMS_LIST, &status);\n\tif (err == -ENODATA && status == VERR_NO_MORE_FILES)\n\t\terr = 1;\n\n\t*buf_len = parms.cb.u.value32;\n\t*file_count = parms.file_count.u.value32;\n\treturn err;\n}\n\nint vboxsf_fsinfo(u32 root, u64 handle, u32 flags,\n\t\t  u32 *buf_len, void *buf)\n{\n\tstruct shfl_information parms;\n\tint err;\n\n\tparms.root.type = VMMDEV_HGCM_PARM_TYPE_32BIT;\n\tparms.root.u.value32 = root;\n\n\tparms.handle.type = VMMDEV_HGCM_PARM_TYPE_64BIT;\n\tparms.handle.u.value64 = handle;\n\tparms.flags.type = VMMDEV_HGCM_PARM_TYPE_32BIT;\n\tparms.flags.u.value32 = flags;\n\tparms.cb.type = VMMDEV_HGCM_PARM_TYPE_32BIT;\n\tparms.cb.u.value32 = *buf_len;\n\tparms.info.type = VMMDEV_HGCM_PARM_TYPE_LINADDR_KERNEL;\n\tparms.info.u.pointer.size = *buf_len;\n\tparms.info.u.pointer.u.linear_addr = (uintptr_t)buf;\n\n\terr = vboxsf_call(SHFL_FN_INFORMATION, &parms, SHFL_CPARMS_INFORMATION,\n\t\t\t  NULL);\n\n\t*buf_len = parms.cb.u.value32;\n\treturn err;\n}\n\nint vboxsf_readlink(u32 root, struct shfl_string *parsed_path,\n\t\t    u32 buf_len, u8 *buf)\n{\n\tstruct shfl_readLink parms;\n\n\tparms.root.type = VMMDEV_HGCM_PARM_TYPE_32BIT;\n\tparms.root.u.value32 = root;\n\n\tparms.path.type = VMMDEV_HGCM_PARM_TYPE_LINADDR_KERNEL_IN;\n\tparms.path.u.pointer.size = shfl_string_buf_size(parsed_path);\n\tparms.path.u.pointer.u.linear_addr = (uintptr_t)parsed_path;\n\n\tparms.buffer.type = VMMDEV_HGCM_PARM_TYPE_LINADDR_KERNEL_OUT;\n\tparms.buffer.u.pointer.size = buf_len;\n\tparms.buffer.u.pointer.u.linear_addr = (uintptr_t)buf;\n\n\treturn vboxsf_call(SHFL_FN_READLINK, &parms, SHFL_CPARMS_READLINK,\n\t\t\t   NULL);\n}\n\nint vboxsf_symlink(u32 root, struct shfl_string *new_path,\n\t\t   struct shfl_string *old_path, struct shfl_fsobjinfo *buf)\n{\n\tstruct shfl_symlink parms;\n\n\tparms.root.type = VMMDEV_HGCM_PARM_TYPE_32BIT;\n\tparms.root.u.value32 = root;\n\n\tparms.new_path.type = VMMDEV_HGCM_PARM_TYPE_LINADDR_KERNEL_IN;\n\tparms.new_path.u.pointer.size = shfl_string_buf_size(new_path);\n\tparms.new_path.u.pointer.u.linear_addr = (uintptr_t)new_path;\n\n\tparms.old_path.type = VMMDEV_HGCM_PARM_TYPE_LINADDR_KERNEL_IN;\n\tparms.old_path.u.pointer.size = shfl_string_buf_size(old_path);\n\tparms.old_path.u.pointer.u.linear_addr = (uintptr_t)old_path;\n\n\tparms.info.type = VMMDEV_HGCM_PARM_TYPE_LINADDR_KERNEL_OUT;\n\tparms.info.u.pointer.size = sizeof(struct shfl_fsobjinfo);\n\tparms.info.u.pointer.u.linear_addr = (uintptr_t)buf;\n\n\treturn vboxsf_call(SHFL_FN_SYMLINK, &parms, SHFL_CPARMS_SYMLINK, NULL);\n}\n\nint vboxsf_set_utf8(void)\n{\n\treturn vboxsf_call(SHFL_FN_SET_UTF8, NULL, 0, NULL);\n}\n\nint vboxsf_set_symlinks(void)\n{\n\treturn vboxsf_call(SHFL_FN_SET_SYMLINKS, NULL, 0, NULL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}