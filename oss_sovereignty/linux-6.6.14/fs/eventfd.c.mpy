{
  "module_name": "eventfd.c",
  "hash_id": "6d73488ed68580a2c333269fc27e32ff3c00560f29bad1a074d428ae9598119b",
  "original_prompt": "Ingested from linux-6.6.14/fs/eventfd.c",
  "human_readable_source": "\n \n\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/kref.h>\n#include <linux/eventfd.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/idr.h>\n#include <linux/uio.h>\n\nstatic DEFINE_IDA(eventfd_ida);\n\nstruct eventfd_ctx {\n\tstruct kref kref;\n\twait_queue_head_t wqh;\n\t \n\t__u64 count;\n\tunsigned int flags;\n\tint id;\n};\n\n__u64 eventfd_signal_mask(struct eventfd_ctx *ctx, __u64 n, __poll_t mask)\n{\n\tunsigned long flags;\n\n\t \n\tif (WARN_ON_ONCE(current->in_eventfd))\n\t\treturn 0;\n\n\tspin_lock_irqsave(&ctx->wqh.lock, flags);\n\tcurrent->in_eventfd = 1;\n\tif (ULLONG_MAX - ctx->count < n)\n\t\tn = ULLONG_MAX - ctx->count;\n\tctx->count += n;\n\tif (waitqueue_active(&ctx->wqh))\n\t\twake_up_locked_poll(&ctx->wqh, EPOLLIN | mask);\n\tcurrent->in_eventfd = 0;\n\tspin_unlock_irqrestore(&ctx->wqh.lock, flags);\n\n\treturn n;\n}\n\n \n__u64 eventfd_signal(struct eventfd_ctx *ctx, __u64 n)\n{\n\treturn eventfd_signal_mask(ctx, n, 0);\n}\nEXPORT_SYMBOL_GPL(eventfd_signal);\n\nstatic void eventfd_free_ctx(struct eventfd_ctx *ctx)\n{\n\tif (ctx->id >= 0)\n\t\tida_simple_remove(&eventfd_ida, ctx->id);\n\tkfree(ctx);\n}\n\nstatic void eventfd_free(struct kref *kref)\n{\n\tstruct eventfd_ctx *ctx = container_of(kref, struct eventfd_ctx, kref);\n\n\teventfd_free_ctx(ctx);\n}\n\n \nvoid eventfd_ctx_put(struct eventfd_ctx *ctx)\n{\n\tkref_put(&ctx->kref, eventfd_free);\n}\nEXPORT_SYMBOL_GPL(eventfd_ctx_put);\n\nstatic int eventfd_release(struct inode *inode, struct file *file)\n{\n\tstruct eventfd_ctx *ctx = file->private_data;\n\n\twake_up_poll(&ctx->wqh, EPOLLHUP);\n\teventfd_ctx_put(ctx);\n\treturn 0;\n}\n\nstatic __poll_t eventfd_poll(struct file *file, poll_table *wait)\n{\n\tstruct eventfd_ctx *ctx = file->private_data;\n\t__poll_t events = 0;\n\tu64 count;\n\n\tpoll_wait(file, &ctx->wqh, wait);\n\n\t \n\tcount = READ_ONCE(ctx->count);\n\n\tif (count > 0)\n\t\tevents |= EPOLLIN;\n\tif (count == ULLONG_MAX)\n\t\tevents |= EPOLLERR;\n\tif (ULLONG_MAX - 1 > count)\n\t\tevents |= EPOLLOUT;\n\n\treturn events;\n}\n\nvoid eventfd_ctx_do_read(struct eventfd_ctx *ctx, __u64 *cnt)\n{\n\tlockdep_assert_held(&ctx->wqh.lock);\n\n\t*cnt = ((ctx->flags & EFD_SEMAPHORE) && ctx->count) ? 1 : ctx->count;\n\tctx->count -= *cnt;\n}\nEXPORT_SYMBOL_GPL(eventfd_ctx_do_read);\n\n \nint eventfd_ctx_remove_wait_queue(struct eventfd_ctx *ctx, wait_queue_entry_t *wait,\n\t\t\t\t  __u64 *cnt)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctx->wqh.lock, flags);\n\teventfd_ctx_do_read(ctx, cnt);\n\t__remove_wait_queue(&ctx->wqh, wait);\n\tif (*cnt != 0 && waitqueue_active(&ctx->wqh))\n\t\twake_up_locked_poll(&ctx->wqh, EPOLLOUT);\n\tspin_unlock_irqrestore(&ctx->wqh.lock, flags);\n\n\treturn *cnt != 0 ? 0 : -EAGAIN;\n}\nEXPORT_SYMBOL_GPL(eventfd_ctx_remove_wait_queue);\n\nstatic ssize_t eventfd_read(struct kiocb *iocb, struct iov_iter *to)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct eventfd_ctx *ctx = file->private_data;\n\t__u64 ucnt = 0;\n\n\tif (iov_iter_count(to) < sizeof(ucnt))\n\t\treturn -EINVAL;\n\tspin_lock_irq(&ctx->wqh.lock);\n\tif (!ctx->count) {\n\t\tif ((file->f_flags & O_NONBLOCK) ||\n\t\t    (iocb->ki_flags & IOCB_NOWAIT)) {\n\t\t\tspin_unlock_irq(&ctx->wqh.lock);\n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\tif (wait_event_interruptible_locked_irq(ctx->wqh, ctx->count)) {\n\t\t\tspin_unlock_irq(&ctx->wqh.lock);\n\t\t\treturn -ERESTARTSYS;\n\t\t}\n\t}\n\teventfd_ctx_do_read(ctx, &ucnt);\n\tcurrent->in_eventfd = 1;\n\tif (waitqueue_active(&ctx->wqh))\n\t\twake_up_locked_poll(&ctx->wqh, EPOLLOUT);\n\tcurrent->in_eventfd = 0;\n\tspin_unlock_irq(&ctx->wqh.lock);\n\tif (unlikely(copy_to_iter(&ucnt, sizeof(ucnt), to) != sizeof(ucnt)))\n\t\treturn -EFAULT;\n\n\treturn sizeof(ucnt);\n}\n\nstatic ssize_t eventfd_write(struct file *file, const char __user *buf, size_t count,\n\t\t\t     loff_t *ppos)\n{\n\tstruct eventfd_ctx *ctx = file->private_data;\n\tssize_t res;\n\t__u64 ucnt;\n\n\tif (count < sizeof(ucnt))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&ucnt, buf, sizeof(ucnt)))\n\t\treturn -EFAULT;\n\tif (ucnt == ULLONG_MAX)\n\t\treturn -EINVAL;\n\tspin_lock_irq(&ctx->wqh.lock);\n\tres = -EAGAIN;\n\tif (ULLONG_MAX - ctx->count > ucnt)\n\t\tres = sizeof(ucnt);\n\telse if (!(file->f_flags & O_NONBLOCK)) {\n\t\tres = wait_event_interruptible_locked_irq(ctx->wqh,\n\t\t\t\tULLONG_MAX - ctx->count > ucnt);\n\t\tif (!res)\n\t\t\tres = sizeof(ucnt);\n\t}\n\tif (likely(res > 0)) {\n\t\tctx->count += ucnt;\n\t\tcurrent->in_eventfd = 1;\n\t\tif (waitqueue_active(&ctx->wqh))\n\t\t\twake_up_locked_poll(&ctx->wqh, EPOLLIN);\n\t\tcurrent->in_eventfd = 0;\n\t}\n\tspin_unlock_irq(&ctx->wqh.lock);\n\n\treturn res;\n}\n\n#ifdef CONFIG_PROC_FS\nstatic void eventfd_show_fdinfo(struct seq_file *m, struct file *f)\n{\n\tstruct eventfd_ctx *ctx = f->private_data;\n\n\tspin_lock_irq(&ctx->wqh.lock);\n\tseq_printf(m, \"eventfd-count: %16llx\\n\",\n\t\t   (unsigned long long)ctx->count);\n\tspin_unlock_irq(&ctx->wqh.lock);\n\tseq_printf(m, \"eventfd-id: %d\\n\", ctx->id);\n\tseq_printf(m, \"eventfd-semaphore: %d\\n\",\n\t\t   !!(ctx->flags & EFD_SEMAPHORE));\n}\n#endif\n\nstatic const struct file_operations eventfd_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= eventfd_show_fdinfo,\n#endif\n\t.release\t= eventfd_release,\n\t.poll\t\t= eventfd_poll,\n\t.read_iter\t= eventfd_read,\n\t.write\t\t= eventfd_write,\n\t.llseek\t\t= noop_llseek,\n};\n\n \nstruct file *eventfd_fget(int fd)\n{\n\tstruct file *file;\n\n\tfile = fget(fd);\n\tif (!file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (file->f_op != &eventfd_fops) {\n\t\tfput(file);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn file;\n}\nEXPORT_SYMBOL_GPL(eventfd_fget);\n\n \nstruct eventfd_ctx *eventfd_ctx_fdget(int fd)\n{\n\tstruct eventfd_ctx *ctx;\n\tstruct fd f = fdget(fd);\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tctx = eventfd_ctx_fileget(f.file);\n\tfdput(f);\n\treturn ctx;\n}\nEXPORT_SYMBOL_GPL(eventfd_ctx_fdget);\n\n \nstruct eventfd_ctx *eventfd_ctx_fileget(struct file *file)\n{\n\tstruct eventfd_ctx *ctx;\n\n\tif (file->f_op != &eventfd_fops)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tctx = file->private_data;\n\tkref_get(&ctx->kref);\n\treturn ctx;\n}\nEXPORT_SYMBOL_GPL(eventfd_ctx_fileget);\n\nstatic int do_eventfd(unsigned int count, int flags)\n{\n\tstruct eventfd_ctx *ctx;\n\tstruct file *file;\n\tint fd;\n\n\t \n\tBUILD_BUG_ON(EFD_CLOEXEC != O_CLOEXEC);\n\tBUILD_BUG_ON(EFD_NONBLOCK != O_NONBLOCK);\n\n\tif (flags & ~EFD_FLAGS_SET)\n\t\treturn -EINVAL;\n\n\tctx = kmalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tkref_init(&ctx->kref);\n\tinit_waitqueue_head(&ctx->wqh);\n\tctx->count = count;\n\tctx->flags = flags;\n\tctx->id = ida_simple_get(&eventfd_ida, 0, 0, GFP_KERNEL);\n\n\tflags &= EFD_SHARED_FCNTL_FLAGS;\n\tflags |= O_RDWR;\n\tfd = get_unused_fd_flags(flags);\n\tif (fd < 0)\n\t\tgoto err;\n\n\tfile = anon_inode_getfile(\"[eventfd]\", &eventfd_fops, ctx, flags);\n\tif (IS_ERR(file)) {\n\t\tput_unused_fd(fd);\n\t\tfd = PTR_ERR(file);\n\t\tgoto err;\n\t}\n\n\tfile->f_mode |= FMODE_NOWAIT;\n\tfd_install(fd, file);\n\treturn fd;\nerr:\n\teventfd_free_ctx(ctx);\n\treturn fd;\n}\n\nSYSCALL_DEFINE2(eventfd2, unsigned int, count, int, flags)\n{\n\treturn do_eventfd(count, flags);\n}\n\nSYSCALL_DEFINE1(eventfd, unsigned int, count)\n{\n\treturn do_eventfd(count, 0);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}