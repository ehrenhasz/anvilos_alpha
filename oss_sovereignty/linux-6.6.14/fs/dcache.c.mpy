{
  "module_name": "dcache.c",
  "hash_id": "875d67b3612b1e5ab80d286f0e34818253bfea47bbcb3c4cee2ca58952100e26",
  "original_prompt": "Ingested from linux-6.6.14/fs/dcache.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/fscrypt.h>\n#include <linux/fsnotify.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/cache.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/seqlock.h>\n#include <linux/memblock.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/list_lru.h>\n#include \"internal.h\"\n#include \"mount.h\"\n\n \nint sysctl_vfs_cache_pressure __read_mostly = 100;\nEXPORT_SYMBOL_GPL(sysctl_vfs_cache_pressure);\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);\n\nEXPORT_SYMBOL(rename_lock);\n\nstatic struct kmem_cache *dentry_cache __read_mostly;\n\nconst struct qstr empty_name = QSTR_INIT(\"\", 0);\nEXPORT_SYMBOL(empty_name);\nconst struct qstr slash_name = QSTR_INIT(\"/\", 1);\nEXPORT_SYMBOL(slash_name);\nconst struct qstr dotdot_name = QSTR_INIT(\"..\", 2);\nEXPORT_SYMBOL(dotdot_name);\n\n \n\nstatic unsigned int d_hash_shift __read_mostly;\n\nstatic struct hlist_bl_head *dentry_hashtable __read_mostly;\n\nstatic inline struct hlist_bl_head *d_hash(unsigned int hash)\n{\n\treturn dentry_hashtable + (hash >> d_hash_shift);\n}\n\n#define IN_LOOKUP_SHIFT 10\nstatic struct hlist_bl_head in_lookup_hashtable[1 << IN_LOOKUP_SHIFT];\n\nstatic inline struct hlist_bl_head *in_lookup_hash(const struct dentry *parent,\n\t\t\t\t\tunsigned int hash)\n{\n\thash += (unsigned long) parent / L1_CACHE_BYTES;\n\treturn in_lookup_hashtable + hash_32(hash, IN_LOOKUP_SHIFT);\n}\n\nstruct dentry_stat_t {\n\tlong nr_dentry;\n\tlong nr_unused;\n\tlong age_limit;\t\t \n\tlong want_pages;\t \n\tlong nr_negative;\t \n\tlong dummy;\t\t \n};\n\nstatic DEFINE_PER_CPU(long, nr_dentry);\nstatic DEFINE_PER_CPU(long, nr_dentry_unused);\nstatic DEFINE_PER_CPU(long, nr_dentry_negative);\n\n#if defined(CONFIG_SYSCTL) && defined(CONFIG_PROC_FS)\n \nstatic struct dentry_stat_t dentry_stat = {\n\t.age_limit = 45,\n};\n\n \nstatic long get_nr_dentry(void)\n{\n\tint i;\n\tlong sum = 0;\n\tfor_each_possible_cpu(i)\n\t\tsum += per_cpu(nr_dentry, i);\n\treturn sum < 0 ? 0 : sum;\n}\n\nstatic long get_nr_dentry_unused(void)\n{\n\tint i;\n\tlong sum = 0;\n\tfor_each_possible_cpu(i)\n\t\tsum += per_cpu(nr_dentry_unused, i);\n\treturn sum < 0 ? 0 : sum;\n}\n\nstatic long get_nr_dentry_negative(void)\n{\n\tint i;\n\tlong sum = 0;\n\n\tfor_each_possible_cpu(i)\n\t\tsum += per_cpu(nr_dentry_negative, i);\n\treturn sum < 0 ? 0 : sum;\n}\n\nstatic int proc_nr_dentry(struct ctl_table *table, int write, void *buffer,\n\t\t\t  size_t *lenp, loff_t *ppos)\n{\n\tdentry_stat.nr_dentry = get_nr_dentry();\n\tdentry_stat.nr_unused = get_nr_dentry_unused();\n\tdentry_stat.nr_negative = get_nr_dentry_negative();\n\treturn proc_doulongvec_minmax(table, write, buffer, lenp, ppos);\n}\n\nstatic struct ctl_table fs_dcache_sysctls[] = {\n\t{\n\t\t.procname\t= \"dentry-state\",\n\t\t.data\t\t= &dentry_stat,\n\t\t.maxlen\t\t= 6*sizeof(long),\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= proc_nr_dentry,\n\t},\n\t{ }\n};\n\nstatic int __init init_fs_dcache_sysctls(void)\n{\n\tregister_sysctl_init(\"fs\", fs_dcache_sysctls);\n\treturn 0;\n}\nfs_initcall(init_fs_dcache_sysctls);\n#endif\n\n \n#ifdef CONFIG_DCACHE_WORD_ACCESS\n\n#include <asm/word-at-a-time.h>\n \nstatic inline int dentry_string_cmp(const unsigned char *cs, const unsigned char *ct, unsigned tcount)\n{\n\tunsigned long a,b,mask;\n\n\tfor (;;) {\n\t\ta = read_word_at_a_time(cs);\n\t\tb = load_unaligned_zeropad(ct);\n\t\tif (tcount < sizeof(unsigned long))\n\t\t\tbreak;\n\t\tif (unlikely(a != b))\n\t\t\treturn 1;\n\t\tcs += sizeof(unsigned long);\n\t\tct += sizeof(unsigned long);\n\t\ttcount -= sizeof(unsigned long);\n\t\tif (!tcount)\n\t\t\treturn 0;\n\t}\n\tmask = bytemask_from_count(tcount);\n\treturn unlikely(!!((a ^ b) & mask));\n}\n\n#else\n\nstatic inline int dentry_string_cmp(const unsigned char *cs, const unsigned char *ct, unsigned tcount)\n{\n\tdo {\n\t\tif (*cs != *ct)\n\t\t\treturn 1;\n\t\tcs++;\n\t\tct++;\n\t\ttcount--;\n\t} while (tcount);\n\treturn 0;\n}\n\n#endif\n\nstatic inline int dentry_cmp(const struct dentry *dentry, const unsigned char *ct, unsigned tcount)\n{\n\t \n\tconst unsigned char *cs = READ_ONCE(dentry->d_name.name);\n\n\treturn dentry_string_cmp(cs, ct, tcount);\n}\n\nstruct external_name {\n\tunion {\n\t\tatomic_t count;\n\t\tstruct rcu_head head;\n\t} u;\n\tunsigned char name[];\n};\n\nstatic inline struct external_name *external_name(struct dentry *dentry)\n{\n\treturn container_of(dentry->d_name.name, struct external_name, name[0]);\n}\n\nstatic void __d_free(struct rcu_head *head)\n{\n\tstruct dentry *dentry = container_of(head, struct dentry, d_u.d_rcu);\n\n\tkmem_cache_free(dentry_cache, dentry); \n}\n\nstatic void __d_free_external(struct rcu_head *head)\n{\n\tstruct dentry *dentry = container_of(head, struct dentry, d_u.d_rcu);\n\tkfree(external_name(dentry));\n\tkmem_cache_free(dentry_cache, dentry);\n}\n\nstatic inline int dname_external(const struct dentry *dentry)\n{\n\treturn dentry->d_name.name != dentry->d_iname;\n}\n\nvoid take_dentry_name_snapshot(struct name_snapshot *name, struct dentry *dentry)\n{\n\tspin_lock(&dentry->d_lock);\n\tname->name = dentry->d_name;\n\tif (unlikely(dname_external(dentry))) {\n\t\tatomic_inc(&external_name(dentry)->u.count);\n\t} else {\n\t\tmemcpy(name->inline_name, dentry->d_iname,\n\t\t       dentry->d_name.len + 1);\n\t\tname->name.name = name->inline_name;\n\t}\n\tspin_unlock(&dentry->d_lock);\n}\nEXPORT_SYMBOL(take_dentry_name_snapshot);\n\nvoid release_dentry_name_snapshot(struct name_snapshot *name)\n{\n\tif (unlikely(name->name.name != name->inline_name)) {\n\t\tstruct external_name *p;\n\t\tp = container_of(name->name.name, struct external_name, name[0]);\n\t\tif (unlikely(atomic_dec_and_test(&p->u.count)))\n\t\t\tkfree_rcu(p, u.head);\n\t}\n}\nEXPORT_SYMBOL(release_dentry_name_snapshot);\n\nstatic inline void __d_set_inode_and_type(struct dentry *dentry,\n\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t  unsigned type_flags)\n{\n\tunsigned flags;\n\n\tdentry->d_inode = inode;\n\tflags = READ_ONCE(dentry->d_flags);\n\tflags &= ~(DCACHE_ENTRY_TYPE | DCACHE_FALLTHRU);\n\tflags |= type_flags;\n\tsmp_store_release(&dentry->d_flags, flags);\n}\n\nstatic inline void __d_clear_type_and_inode(struct dentry *dentry)\n{\n\tunsigned flags = READ_ONCE(dentry->d_flags);\n\n\tflags &= ~(DCACHE_ENTRY_TYPE | DCACHE_FALLTHRU);\n\tWRITE_ONCE(dentry->d_flags, flags);\n\tdentry->d_inode = NULL;\n\tif (dentry->d_flags & DCACHE_LRU_LIST)\n\t\tthis_cpu_inc(nr_dentry_negative);\n}\n\nstatic void dentry_free(struct dentry *dentry)\n{\n\tWARN_ON(!hlist_unhashed(&dentry->d_u.d_alias));\n\tif (unlikely(dname_external(dentry))) {\n\t\tstruct external_name *p = external_name(dentry);\n\t\tif (likely(atomic_dec_and_test(&p->u.count))) {\n\t\t\tcall_rcu(&dentry->d_u.d_rcu, __d_free_external);\n\t\t\treturn;\n\t\t}\n\t}\n\t \n\tif (dentry->d_flags & DCACHE_NORCU)\n\t\t__d_free(&dentry->d_u.d_rcu);\n\telse\n\t\tcall_rcu(&dentry->d_u.d_rcu, __d_free);\n}\n\n \nstatic void dentry_unlink_inode(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\n\traw_write_seqcount_begin(&dentry->d_seq);\n\t__d_clear_type_and_inode(dentry);\n\thlist_del_init(&dentry->d_u.d_alias);\n\traw_write_seqcount_end(&dentry->d_seq);\n\tspin_unlock(&dentry->d_lock);\n\tspin_unlock(&inode->i_lock);\n\tif (!inode->i_nlink)\n\t\tfsnotify_inoderemove(inode);\n\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\tdentry->d_op->d_iput(dentry, inode);\n\telse\n\t\tiput(inode);\n}\n\n \n#define D_FLAG_VERIFY(dentry,x) WARN_ON_ONCE(((dentry)->d_flags & (DCACHE_LRU_LIST | DCACHE_SHRINK_LIST)) != (x))\nstatic void d_lru_add(struct dentry *dentry)\n{\n\tD_FLAG_VERIFY(dentry, 0);\n\tdentry->d_flags |= DCACHE_LRU_LIST;\n\tthis_cpu_inc(nr_dentry_unused);\n\tif (d_is_negative(dentry))\n\t\tthis_cpu_inc(nr_dentry_negative);\n\tWARN_ON_ONCE(!list_lru_add(&dentry->d_sb->s_dentry_lru, &dentry->d_lru));\n}\n\nstatic void d_lru_del(struct dentry *dentry)\n{\n\tD_FLAG_VERIFY(dentry, DCACHE_LRU_LIST);\n\tdentry->d_flags &= ~DCACHE_LRU_LIST;\n\tthis_cpu_dec(nr_dentry_unused);\n\tif (d_is_negative(dentry))\n\t\tthis_cpu_dec(nr_dentry_negative);\n\tWARN_ON_ONCE(!list_lru_del(&dentry->d_sb->s_dentry_lru, &dentry->d_lru));\n}\n\nstatic void d_shrink_del(struct dentry *dentry)\n{\n\tD_FLAG_VERIFY(dentry, DCACHE_SHRINK_LIST | DCACHE_LRU_LIST);\n\tlist_del_init(&dentry->d_lru);\n\tdentry->d_flags &= ~(DCACHE_SHRINK_LIST | DCACHE_LRU_LIST);\n\tthis_cpu_dec(nr_dentry_unused);\n}\n\nstatic void d_shrink_add(struct dentry *dentry, struct list_head *list)\n{\n\tD_FLAG_VERIFY(dentry, 0);\n\tlist_add(&dentry->d_lru, list);\n\tdentry->d_flags |= DCACHE_SHRINK_LIST | DCACHE_LRU_LIST;\n\tthis_cpu_inc(nr_dentry_unused);\n}\n\n \nstatic void d_lru_isolate(struct list_lru_one *lru, struct dentry *dentry)\n{\n\tD_FLAG_VERIFY(dentry, DCACHE_LRU_LIST);\n\tdentry->d_flags &= ~DCACHE_LRU_LIST;\n\tthis_cpu_dec(nr_dentry_unused);\n\tif (d_is_negative(dentry))\n\t\tthis_cpu_dec(nr_dentry_negative);\n\tlist_lru_isolate(lru, &dentry->d_lru);\n}\n\nstatic void d_lru_shrink_move(struct list_lru_one *lru, struct dentry *dentry,\n\t\t\t      struct list_head *list)\n{\n\tD_FLAG_VERIFY(dentry, DCACHE_LRU_LIST);\n\tdentry->d_flags |= DCACHE_SHRINK_LIST;\n\tif (d_is_negative(dentry))\n\t\tthis_cpu_dec(nr_dentry_negative);\n\tlist_lru_isolate_move(lru, &dentry->d_lru, list);\n}\n\nstatic void ___d_drop(struct dentry *dentry)\n{\n\tstruct hlist_bl_head *b;\n\t \n\tif (unlikely(IS_ROOT(dentry)))\n\t\tb = &dentry->d_sb->s_roots;\n\telse\n\t\tb = d_hash(dentry->d_name.hash);\n\n\thlist_bl_lock(b);\n\t__hlist_bl_del(&dentry->d_hash);\n\thlist_bl_unlock(b);\n}\n\nvoid __d_drop(struct dentry *dentry)\n{\n\tif (!d_unhashed(dentry)) {\n\t\t___d_drop(dentry);\n\t\tdentry->d_hash.pprev = NULL;\n\t\twrite_seqcount_invalidate(&dentry->d_seq);\n\t}\n}\nEXPORT_SYMBOL(__d_drop);\n\n \nvoid d_drop(struct dentry *dentry)\n{\n\tspin_lock(&dentry->d_lock);\n\t__d_drop(dentry);\n\tspin_unlock(&dentry->d_lock);\n}\nEXPORT_SYMBOL(d_drop);\n\nstatic inline void dentry_unlist(struct dentry *dentry, struct dentry *parent)\n{\n\tstruct dentry *next;\n\t \n\tdentry->d_flags |= DCACHE_DENTRY_KILLED;\n\tif (unlikely(list_empty(&dentry->d_child)))\n\t\treturn;\n\t__list_del_entry(&dentry->d_child);\n\t \n\twhile (dentry->d_child.next != &parent->d_subdirs) {\n\t\tnext = list_entry(dentry->d_child.next, struct dentry, d_child);\n\t\tif (likely(!(next->d_flags & DCACHE_DENTRY_CURSOR)))\n\t\t\tbreak;\n\t\tdentry->d_child.next = next->d_child.next;\n\t}\n}\n\nstatic void __dentry_kill(struct dentry *dentry)\n{\n\tstruct dentry *parent = NULL;\n\tbool can_free = true;\n\tif (!IS_ROOT(dentry))\n\t\tparent = dentry->d_parent;\n\n\t \n\tlockref_mark_dead(&dentry->d_lockref);\n\n\t \n\tif (dentry->d_flags & DCACHE_OP_PRUNE)\n\t\tdentry->d_op->d_prune(dentry);\n\n\tif (dentry->d_flags & DCACHE_LRU_LIST) {\n\t\tif (!(dentry->d_flags & DCACHE_SHRINK_LIST))\n\t\t\td_lru_del(dentry);\n\t}\n\t \n\t__d_drop(dentry);\n\tdentry_unlist(dentry, parent);\n\tif (parent)\n\t\tspin_unlock(&parent->d_lock);\n\tif (dentry->d_inode)\n\t\tdentry_unlink_inode(dentry);\n\telse\n\t\tspin_unlock(&dentry->d_lock);\n\tthis_cpu_dec(nr_dentry);\n\tif (dentry->d_op && dentry->d_op->d_release)\n\t\tdentry->d_op->d_release(dentry);\n\n\tspin_lock(&dentry->d_lock);\n\tif (dentry->d_flags & DCACHE_SHRINK_LIST) {\n\t\tdentry->d_flags |= DCACHE_MAY_FREE;\n\t\tcan_free = false;\n\t}\n\tspin_unlock(&dentry->d_lock);\n\tif (likely(can_free))\n\t\tdentry_free(dentry);\n\tcond_resched();\n}\n\nstatic struct dentry *__lock_parent(struct dentry *dentry)\n{\n\tstruct dentry *parent;\n\trcu_read_lock();\n\tspin_unlock(&dentry->d_lock);\nagain:\n\tparent = READ_ONCE(dentry->d_parent);\n\tspin_lock(&parent->d_lock);\n\t \n\tif (unlikely(parent != dentry->d_parent)) {\n\t\tspin_unlock(&parent->d_lock);\n\t\tgoto again;\n\t}\n\trcu_read_unlock();\n\tif (parent != dentry)\n\t\tspin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);\n\telse\n\t\tparent = NULL;\n\treturn parent;\n}\n\nstatic inline struct dentry *lock_parent(struct dentry *dentry)\n{\n\tstruct dentry *parent = dentry->d_parent;\n\tif (IS_ROOT(dentry))\n\t\treturn NULL;\n\tif (likely(spin_trylock(&parent->d_lock)))\n\t\treturn parent;\n\treturn __lock_parent(dentry);\n}\n\nstatic inline bool retain_dentry(struct dentry *dentry)\n{\n\tWARN_ON(d_in_lookup(dentry));\n\n\t \n\tif (unlikely(d_unhashed(dentry)))\n\t\treturn false;\n\n\tif (unlikely(dentry->d_flags & DCACHE_DISCONNECTED))\n\t\treturn false;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\treturn false;\n\t}\n\n\tif (unlikely(dentry->d_flags & DCACHE_DONTCACHE))\n\t\treturn false;\n\n\t \n\tdentry->d_lockref.count--;\n\tif (unlikely(!(dentry->d_flags & DCACHE_LRU_LIST)))\n\t\td_lru_add(dentry);\n\telse if (unlikely(!(dentry->d_flags & DCACHE_REFERENCED)))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\treturn true;\n}\n\nvoid d_mark_dontcache(struct inode *inode)\n{\n\tstruct dentry *de;\n\n\tspin_lock(&inode->i_lock);\n\thlist_for_each_entry(de, &inode->i_dentry, d_u.d_alias) {\n\t\tspin_lock(&de->d_lock);\n\t\tde->d_flags |= DCACHE_DONTCACHE;\n\t\tspin_unlock(&de->d_lock);\n\t}\n\tinode->i_state |= I_DONTCACHE;\n\tspin_unlock(&inode->i_lock);\n}\nEXPORT_SYMBOL(d_mark_dontcache);\n\n \nstatic struct dentry *dentry_kill(struct dentry *dentry)\n\t__releases(dentry->d_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct dentry *parent = NULL;\n\n\tif (inode && unlikely(!spin_trylock(&inode->i_lock)))\n\t\tgoto slow_positive;\n\n\tif (!IS_ROOT(dentry)) {\n\t\tparent = dentry->d_parent;\n\t\tif (unlikely(!spin_trylock(&parent->d_lock))) {\n\t\t\tparent = __lock_parent(dentry);\n\t\t\tif (likely(inode || !dentry->d_inode))\n\t\t\t\tgoto got_locks;\n\t\t\t \n\t\t\tif (parent)\n\t\t\t\tspin_unlock(&parent->d_lock);\n\t\t\tinode = dentry->d_inode;\n\t\t\tgoto slow_positive;\n\t\t}\n\t}\n\t__dentry_kill(dentry);\n\treturn parent;\n\nslow_positive:\n\tspin_unlock(&dentry->d_lock);\n\tspin_lock(&inode->i_lock);\n\tspin_lock(&dentry->d_lock);\n\tparent = lock_parent(dentry);\ngot_locks:\n\tif (unlikely(dentry->d_lockref.count != 1)) {\n\t\tdentry->d_lockref.count--;\n\t} else if (likely(!retain_dentry(dentry))) {\n\t\t__dentry_kill(dentry);\n\t\treturn parent;\n\t}\n\t \n\tif (inode)\n\t\tspin_unlock(&inode->i_lock);\n\tif (parent)\n\t\tspin_unlock(&parent->d_lock);\n\tspin_unlock(&dentry->d_lock);\n\treturn NULL;\n}\n\n \nstatic inline bool fast_dput(struct dentry *dentry)\n{\n\tint ret;\n\tunsigned int d_flags;\n\n\t \n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE))\n\t\treturn lockref_put_or_lock(&dentry->d_lockref);\n\n\t \n\tret = lockref_put_return(&dentry->d_lockref);\n\n\t \n\tif (unlikely(ret < 0)) {\n\t\tspin_lock(&dentry->d_lock);\n\t\tif (dentry->d_lockref.count > 1) {\n\t\t\tdentry->d_lockref.count--;\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t \n\tif (ret)\n\t\treturn true;\n\n\t \n\tsmp_rmb();\n\td_flags = READ_ONCE(dentry->d_flags);\n\td_flags &= DCACHE_REFERENCED | DCACHE_LRU_LIST |\n\t\t\tDCACHE_DISCONNECTED | DCACHE_DONTCACHE;\n\n\t \n\tif (d_flags == (DCACHE_REFERENCED | DCACHE_LRU_LIST) && !d_unhashed(dentry))\n\t\treturn true;\n\n\t \n\tspin_lock(&dentry->d_lock);\n\n\t \n\tif (dentry->d_lockref.count) {\n\t\tspin_unlock(&dentry->d_lock);\n\t\treturn true;\n\t}\n\n\t \n\tdentry->d_lockref.count = 1;\n\treturn false;\n}\n\n\n \n\n \nvoid dput(struct dentry *dentry)\n{\n\twhile (dentry) {\n\t\tmight_sleep();\n\n\t\trcu_read_lock();\n\t\tif (likely(fast_dput(dentry))) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\trcu_read_unlock();\n\n\t\tif (likely(retain_dentry(dentry))) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\treturn;\n\t\t}\n\n\t\tdentry = dentry_kill(dentry);\n\t}\n}\nEXPORT_SYMBOL(dput);\n\nstatic void __dput_to_list(struct dentry *dentry, struct list_head *list)\n__must_hold(&dentry->d_lock)\n{\n\tif (dentry->d_flags & DCACHE_SHRINK_LIST) {\n\t\t \n\t\t--dentry->d_lockref.count;\n\t} else {\n\t\tif (dentry->d_flags & DCACHE_LRU_LIST)\n\t\t\td_lru_del(dentry);\n\t\tif (!--dentry->d_lockref.count)\n\t\t\td_shrink_add(dentry, list);\n\t}\n}\n\nvoid dput_to_list(struct dentry *dentry, struct list_head *list)\n{\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\trcu_read_unlock();\n\tif (!retain_dentry(dentry))\n\t\t__dput_to_list(dentry, list);\n\tspin_unlock(&dentry->d_lock);\n}\n\n \nstatic inline void __dget_dlock(struct dentry *dentry)\n{\n\tdentry->d_lockref.count++;\n}\n\nstatic inline void __dget(struct dentry *dentry)\n{\n\tlockref_get(&dentry->d_lockref);\n}\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\tunsigned seq;\n\n\t \n\trcu_read_lock();\n\tseq = raw_seqcount_begin(&dentry->d_seq);\n\tret = READ_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (!read_seqcount_retry(&dentry->d_seq, seq))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t \n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}\nEXPORT_SYMBOL(dget_parent);\n\nstatic struct dentry * __d_find_any_alias(struct inode *inode)\n{\n\tstruct dentry *alias;\n\n\tif (hlist_empty(&inode->i_dentry))\n\t\treturn NULL;\n\talias = hlist_entry(inode->i_dentry.first, struct dentry, d_u.d_alias);\n\t__dget(alias);\n\treturn alias;\n}\n\n \nstruct dentry *d_find_any_alias(struct inode *inode)\n{\n\tstruct dentry *de;\n\n\tspin_lock(&inode->i_lock);\n\tde = __d_find_any_alias(inode);\n\tspin_unlock(&inode->i_lock);\n\treturn de;\n}\nEXPORT_SYMBOL(d_find_any_alias);\n\nstatic struct dentry *__d_find_alias(struct inode *inode)\n{\n\tstruct dentry *alias;\n\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn __d_find_any_alias(inode);\n\n\thlist_for_each_entry(alias, &inode->i_dentry, d_u.d_alias) {\n\t\tspin_lock(&alias->d_lock);\n \t\tif (!d_unhashed(alias)) {\n\t\t\t__dget_dlock(alias);\n\t\t\tspin_unlock(&alias->d_lock);\n\t\t\treturn alias;\n\t\t}\n\t\tspin_unlock(&alias->d_lock);\n\t}\n\treturn NULL;\n}\n\n \nstruct dentry *d_find_alias(struct inode *inode)\n{\n\tstruct dentry *de = NULL;\n\n\tif (!hlist_empty(&inode->i_dentry)) {\n\t\tspin_lock(&inode->i_lock);\n\t\tde = __d_find_alias(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\treturn de;\n}\nEXPORT_SYMBOL(d_find_alias);\n\n \nstruct dentry *d_find_alias_rcu(struct inode *inode)\n{\n\tstruct hlist_head *l = &inode->i_dentry;\n\tstruct dentry *de = NULL;\n\n\tspin_lock(&inode->i_lock);\n\t \n\t\n\tif (likely(!(inode->i_state & I_FREEING) && !hlist_empty(l))) {\n\t\tif (S_ISDIR(inode->i_mode)) {\n\t\t\tde = hlist_entry(l->first, struct dentry, d_u.d_alias);\n\t\t} else {\n\t\t\thlist_for_each_entry(de, l, d_u.d_alias)\n\t\t\t\tif (!d_unhashed(de))\n\t\t\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&inode->i_lock);\n\treturn de;\n}\n\n \nvoid d_prune_aliases(struct inode *inode)\n{\n\tstruct dentry *dentry;\nrestart:\n\tspin_lock(&inode->i_lock);\n\thlist_for_each_entry(dentry, &inode->i_dentry, d_u.d_alias) {\n\t\tspin_lock(&dentry->d_lock);\n\t\tif (!dentry->d_lockref.count) {\n\t\t\tstruct dentry *parent = lock_parent(dentry);\n\t\t\tif (likely(!dentry->d_lockref.count)) {\n\t\t\t\t__dentry_kill(dentry);\n\t\t\t\tdput(parent);\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t\tif (parent)\n\t\t\t\tspin_unlock(&parent->d_lock);\n\t\t}\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n\tspin_unlock(&inode->i_lock);\n}\nEXPORT_SYMBOL(d_prune_aliases);\n\n \nstatic bool shrink_lock_dentry(struct dentry *dentry)\n{\n\tstruct inode *inode;\n\tstruct dentry *parent;\n\n\tif (dentry->d_lockref.count)\n\t\treturn false;\n\n\tinode = dentry->d_inode;\n\tif (inode && unlikely(!spin_trylock(&inode->i_lock))) {\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_lock(&inode->i_lock);\n\t\tspin_lock(&dentry->d_lock);\n\t\tif (unlikely(dentry->d_lockref.count))\n\t\t\tgoto out;\n\t\t \n\t\tif (unlikely(inode != dentry->d_inode))\n\t\t\tgoto out;\n\t}\n\n\tparent = dentry->d_parent;\n\tif (IS_ROOT(dentry) || likely(spin_trylock(&parent->d_lock)))\n\t\treturn true;\n\n\tspin_unlock(&dentry->d_lock);\n\tspin_lock(&parent->d_lock);\n\tif (unlikely(parent != dentry->d_parent)) {\n\t\tspin_unlock(&parent->d_lock);\n\t\tspin_lock(&dentry->d_lock);\n\t\tgoto out;\n\t}\n\tspin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);\n\tif (likely(!dentry->d_lockref.count))\n\t\treturn true;\n\tspin_unlock(&parent->d_lock);\nout:\n\tif (inode)\n\t\tspin_unlock(&inode->i_lock);\n\treturn false;\n}\n\nvoid shrink_dentry_list(struct list_head *list)\n{\n\twhile (!list_empty(list)) {\n\t\tstruct dentry *dentry, *parent;\n\n\t\tdentry = list_entry(list->prev, struct dentry, d_lru);\n\t\tspin_lock(&dentry->d_lock);\n\t\trcu_read_lock();\n\t\tif (!shrink_lock_dentry(dentry)) {\n\t\t\tbool can_free = false;\n\t\t\trcu_read_unlock();\n\t\t\td_shrink_del(dentry);\n\t\t\tif (dentry->d_lockref.count < 0)\n\t\t\t\tcan_free = dentry->d_flags & DCACHE_MAY_FREE;\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tif (can_free)\n\t\t\t\tdentry_free(dentry);\n\t\t\tcontinue;\n\t\t}\n\t\trcu_read_unlock();\n\t\td_shrink_del(dentry);\n\t\tparent = dentry->d_parent;\n\t\tif (parent != dentry)\n\t\t\t__dput_to_list(parent, list);\n\t\t__dentry_kill(dentry);\n\t}\n}\n\nstatic enum lru_status dentry_lru_isolate(struct list_head *item,\n\t\tstruct list_lru_one *lru, spinlock_t *lru_lock, void *arg)\n{\n\tstruct list_head *freeable = arg;\n\tstruct dentry\t*dentry = container_of(item, struct dentry, d_lru);\n\n\n\t \n\tif (!spin_trylock(&dentry->d_lock))\n\t\treturn LRU_SKIP;\n\n\t \n\tif (dentry->d_lockref.count) {\n\t\td_lru_isolate(lru, dentry);\n\t\tspin_unlock(&dentry->d_lock);\n\t\treturn LRU_REMOVED;\n\t}\n\n\tif (dentry->d_flags & DCACHE_REFERENCED) {\n\t\tdentry->d_flags &= ~DCACHE_REFERENCED;\n\t\tspin_unlock(&dentry->d_lock);\n\n\t\t \n\t\treturn LRU_ROTATE;\n\t}\n\n\td_lru_shrink_move(lru, dentry, freeable);\n\tspin_unlock(&dentry->d_lock);\n\n\treturn LRU_REMOVED;\n}\n\n \nlong prune_dcache_sb(struct super_block *sb, struct shrink_control *sc)\n{\n\tLIST_HEAD(dispose);\n\tlong freed;\n\n\tfreed = list_lru_shrink_walk(&sb->s_dentry_lru, sc,\n\t\t\t\t     dentry_lru_isolate, &dispose);\n\tshrink_dentry_list(&dispose);\n\treturn freed;\n}\n\nstatic enum lru_status dentry_lru_isolate_shrink(struct list_head *item,\n\t\tstruct list_lru_one *lru, spinlock_t *lru_lock, void *arg)\n{\n\tstruct list_head *freeable = arg;\n\tstruct dentry\t*dentry = container_of(item, struct dentry, d_lru);\n\n\t \n\tif (!spin_trylock(&dentry->d_lock))\n\t\treturn LRU_SKIP;\n\n\td_lru_shrink_move(lru, dentry, freeable);\n\tspin_unlock(&dentry->d_lock);\n\n\treturn LRU_REMOVED;\n}\n\n\n \nvoid shrink_dcache_sb(struct super_block *sb)\n{\n\tdo {\n\t\tLIST_HEAD(dispose);\n\n\t\tlist_lru_walk(&sb->s_dentry_lru,\n\t\t\tdentry_lru_isolate_shrink, &dispose, 1024);\n\t\tshrink_dentry_list(&dispose);\n\t} while (list_lru_count(&sb->s_dentry_lru) > 0);\n}\nEXPORT_SYMBOL(shrink_dcache_sb);\n\n \nenum d_walk_ret {\n\tD_WALK_CONTINUE,\n\tD_WALK_QUIT,\n\tD_WALK_NORETRY,\n\tD_WALK_SKIP,\n};\n\n \nstatic void d_walk(struct dentry *parent, void *data,\n\t\t   enum d_walk_ret (*enter)(void *, struct dentry *))\n{\n\tstruct dentry *this_parent;\n\tstruct list_head *next;\n\tunsigned seq = 0;\n\tenum d_walk_ret ret;\n\tbool retry = true;\n\nagain:\n\tread_seqbegin_or_lock(&rename_lock, &seq);\n\tthis_parent = parent;\n\tspin_lock(&this_parent->d_lock);\n\n\tret = enter(data, this_parent);\n\tswitch (ret) {\n\tcase D_WALK_CONTINUE:\n\t\tbreak;\n\tcase D_WALK_QUIT:\n\tcase D_WALK_SKIP:\n\t\tgoto out_unlock;\n\tcase D_WALK_NORETRY:\n\t\tretry = false;\n\t\tbreak;\n\t}\nrepeat:\n\tnext = this_parent->d_subdirs.next;\nresume:\n\twhile (next != &this_parent->d_subdirs) {\n\t\tstruct list_head *tmp = next;\n\t\tstruct dentry *dentry = list_entry(tmp, struct dentry, d_child);\n\t\tnext = tmp->next;\n\n\t\tif (unlikely(dentry->d_flags & DCACHE_DENTRY_CURSOR))\n\t\t\tcontinue;\n\n\t\tspin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);\n\n\t\tret = enter(data, dentry);\n\t\tswitch (ret) {\n\t\tcase D_WALK_CONTINUE:\n\t\t\tbreak;\n\t\tcase D_WALK_QUIT:\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tgoto out_unlock;\n\t\tcase D_WALK_NORETRY:\n\t\t\tretry = false;\n\t\t\tbreak;\n\t\tcase D_WALK_SKIP:\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!list_empty(&dentry->d_subdirs)) {\n\t\t\tspin_unlock(&this_parent->d_lock);\n\t\t\tspin_release(&dentry->d_lock.dep_map, _RET_IP_);\n\t\t\tthis_parent = dentry;\n\t\t\tspin_acquire(&this_parent->d_lock.dep_map, 0, 1, _RET_IP_);\n\t\t\tgoto repeat;\n\t\t}\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n\t \n\trcu_read_lock();\nascend:\n\tif (this_parent != parent) {\n\t\tstruct dentry *child = this_parent;\n\t\tthis_parent = child->d_parent;\n\n\t\tspin_unlock(&child->d_lock);\n\t\tspin_lock(&this_parent->d_lock);\n\n\t\t \n\t\tif (need_seqretry(&rename_lock, seq))\n\t\t\tgoto rename_retry;\n\t\t \n\t\tdo {\n\t\t\tnext = child->d_child.next;\n\t\t\tif (next == &this_parent->d_subdirs)\n\t\t\t\tgoto ascend;\n\t\t\tchild = list_entry(next, struct dentry, d_child);\n\t\t} while (unlikely(child->d_flags & DCACHE_DENTRY_KILLED));\n\t\trcu_read_unlock();\n\t\tgoto resume;\n\t}\n\tif (need_seqretry(&rename_lock, seq))\n\t\tgoto rename_retry;\n\trcu_read_unlock();\n\nout_unlock:\n\tspin_unlock(&this_parent->d_lock);\n\tdone_seqretry(&rename_lock, seq);\n\treturn;\n\nrename_retry:\n\tspin_unlock(&this_parent->d_lock);\n\trcu_read_unlock();\n\tBUG_ON(seq & 1);\n\tif (!retry)\n\t\treturn;\n\tseq = 1;\n\tgoto again;\n}\n\nstruct check_mount {\n\tstruct vfsmount *mnt;\n\tunsigned int mounted;\n};\n\nstatic enum d_walk_ret path_check_mount(void *data, struct dentry *dentry)\n{\n\tstruct check_mount *info = data;\n\tstruct path path = { .mnt = info->mnt, .dentry = dentry };\n\n\tif (likely(!d_mountpoint(dentry)))\n\t\treturn D_WALK_CONTINUE;\n\tif (__path_is_mountpoint(&path)) {\n\t\tinfo->mounted = 1;\n\t\treturn D_WALK_QUIT;\n\t}\n\treturn D_WALK_CONTINUE;\n}\n\n \nint path_has_submounts(const struct path *parent)\n{\n\tstruct check_mount data = { .mnt = parent->mnt, .mounted = 0 };\n\n\tread_seqlock_excl(&mount_lock);\n\td_walk(parent->dentry, &data, path_check_mount);\n\tread_sequnlock_excl(&mount_lock);\n\n\treturn data.mounted;\n}\nEXPORT_SYMBOL(path_has_submounts);\n\n \nint d_set_mounted(struct dentry *dentry)\n{\n\tstruct dentry *p;\n\tint ret = -ENOENT;\n\twrite_seqlock(&rename_lock);\n\tfor (p = dentry->d_parent; !IS_ROOT(p); p = p->d_parent) {\n\t\t \n\t\tspin_lock(&p->d_lock);\n\t\tif (unlikely(d_unhashed(p))) {\n\t\t\tspin_unlock(&p->d_lock);\n\t\t\tgoto out;\n\t\t}\n\t\tspin_unlock(&p->d_lock);\n\t}\n\tspin_lock(&dentry->d_lock);\n\tif (!d_unlinked(dentry)) {\n\t\tret = -EBUSY;\n\t\tif (!d_mountpoint(dentry)) {\n\t\t\tdentry->d_flags |= DCACHE_MOUNTED;\n\t\t\tret = 0;\n\t\t}\n\t}\n \tspin_unlock(&dentry->d_lock);\nout:\n\twrite_sequnlock(&rename_lock);\n\treturn ret;\n}\n\n \n\nstruct select_data {\n\tstruct dentry *start;\n\tunion {\n\t\tlong found;\n\t\tstruct dentry *victim;\n\t};\n\tstruct list_head dispose;\n};\n\nstatic enum d_walk_ret select_collect(void *_data, struct dentry *dentry)\n{\n\tstruct select_data *data = _data;\n\tenum d_walk_ret ret = D_WALK_CONTINUE;\n\n\tif (data->start == dentry)\n\t\tgoto out;\n\n\tif (dentry->d_flags & DCACHE_SHRINK_LIST) {\n\t\tdata->found++;\n\t} else {\n\t\tif (dentry->d_flags & DCACHE_LRU_LIST)\n\t\t\td_lru_del(dentry);\n\t\tif (!dentry->d_lockref.count) {\n\t\t\td_shrink_add(dentry, &data->dispose);\n\t\t\tdata->found++;\n\t\t}\n\t}\n\t \n\tif (!list_empty(&data->dispose))\n\t\tret = need_resched() ? D_WALK_QUIT : D_WALK_NORETRY;\nout:\n\treturn ret;\n}\n\nstatic enum d_walk_ret select_collect2(void *_data, struct dentry *dentry)\n{\n\tstruct select_data *data = _data;\n\tenum d_walk_ret ret = D_WALK_CONTINUE;\n\n\tif (data->start == dentry)\n\t\tgoto out;\n\n\tif (dentry->d_flags & DCACHE_SHRINK_LIST) {\n\t\tif (!dentry->d_lockref.count) {\n\t\t\trcu_read_lock();\n\t\t\tdata->victim = dentry;\n\t\t\treturn D_WALK_QUIT;\n\t\t}\n\t} else {\n\t\tif (dentry->d_flags & DCACHE_LRU_LIST)\n\t\t\td_lru_del(dentry);\n\t\tif (!dentry->d_lockref.count)\n\t\t\td_shrink_add(dentry, &data->dispose);\n\t}\n\t \n\tif (!list_empty(&data->dispose))\n\t\tret = need_resched() ? D_WALK_QUIT : D_WALK_NORETRY;\nout:\n\treturn ret;\n}\n\n \nvoid shrink_dcache_parent(struct dentry *parent)\n{\n\tfor (;;) {\n\t\tstruct select_data data = {.start = parent};\n\n\t\tINIT_LIST_HEAD(&data.dispose);\n\t\td_walk(parent, &data, select_collect);\n\n\t\tif (!list_empty(&data.dispose)) {\n\t\t\tshrink_dentry_list(&data.dispose);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcond_resched();\n\t\tif (!data.found)\n\t\t\tbreak;\n\t\tdata.victim = NULL;\n\t\td_walk(parent, &data, select_collect2);\n\t\tif (data.victim) {\n\t\t\tstruct dentry *parent;\n\t\t\tspin_lock(&data.victim->d_lock);\n\t\t\tif (!shrink_lock_dentry(data.victim)) {\n\t\t\t\tspin_unlock(&data.victim->d_lock);\n\t\t\t\trcu_read_unlock();\n\t\t\t} else {\n\t\t\t\trcu_read_unlock();\n\t\t\t\tparent = data.victim->d_parent;\n\t\t\t\tif (parent != data.victim)\n\t\t\t\t\t__dput_to_list(parent, &data.dispose);\n\t\t\t\t__dentry_kill(data.victim);\n\t\t\t}\n\t\t}\n\t\tif (!list_empty(&data.dispose))\n\t\t\tshrink_dentry_list(&data.dispose);\n\t}\n}\nEXPORT_SYMBOL(shrink_dcache_parent);\n\nstatic enum d_walk_ret umount_check(void *_data, struct dentry *dentry)\n{\n\t \n\tif (!list_empty(&dentry->d_subdirs))\n\t\treturn D_WALK_CONTINUE;\n\n\t \n\tif (dentry == _data && dentry->d_lockref.count == 1)\n\t\treturn D_WALK_CONTINUE;\n\n\tWARN(1, \"BUG: Dentry %p{i=%lx,n=%pd} \"\n\t\t\t\" still in use (%d) [unmount of %s %s]\\n\",\n\t\t       dentry,\n\t\t       dentry->d_inode ?\n\t\t       dentry->d_inode->i_ino : 0UL,\n\t\t       dentry,\n\t\t       dentry->d_lockref.count,\n\t\t       dentry->d_sb->s_type->name,\n\t\t       dentry->d_sb->s_id);\n\treturn D_WALK_CONTINUE;\n}\n\nstatic void do_one_tree(struct dentry *dentry)\n{\n\tshrink_dcache_parent(dentry);\n\td_walk(dentry, dentry, umount_check);\n\td_drop(dentry);\n\tdput(dentry);\n}\n\n \nvoid shrink_dcache_for_umount(struct super_block *sb)\n{\n\tstruct dentry *dentry;\n\n\tWARN(down_read_trylock(&sb->s_umount), \"s_umount should've been locked\");\n\n\tdentry = sb->s_root;\n\tsb->s_root = NULL;\n\tdo_one_tree(dentry);\n\n\twhile (!hlist_bl_empty(&sb->s_roots)) {\n\t\tdentry = dget(hlist_bl_entry(hlist_bl_first(&sb->s_roots), struct dentry, d_hash));\n\t\tdo_one_tree(dentry);\n\t}\n}\n\nstatic enum d_walk_ret find_submount(void *_data, struct dentry *dentry)\n{\n\tstruct dentry **victim = _data;\n\tif (d_mountpoint(dentry)) {\n\t\t__dget_dlock(dentry);\n\t\t*victim = dentry;\n\t\treturn D_WALK_QUIT;\n\t}\n\treturn D_WALK_CONTINUE;\n}\n\n \nvoid d_invalidate(struct dentry *dentry)\n{\n\tbool had_submounts = false;\n\tspin_lock(&dentry->d_lock);\n\tif (d_unhashed(dentry)) {\n\t\tspin_unlock(&dentry->d_lock);\n\t\treturn;\n\t}\n\t__d_drop(dentry);\n\tspin_unlock(&dentry->d_lock);\n\n\t \n\tif (!dentry->d_inode)\n\t\treturn;\n\n\tshrink_dcache_parent(dentry);\n\tfor (;;) {\n\t\tstruct dentry *victim = NULL;\n\t\td_walk(dentry, &victim, find_submount);\n\t\tif (!victim) {\n\t\t\tif (had_submounts)\n\t\t\t\tshrink_dcache_parent(dentry);\n\t\t\treturn;\n\t\t}\n\t\thad_submounts = true;\n\t\tdetach_mounts(victim);\n\t\tdput(victim);\n\t}\n}\nEXPORT_SYMBOL(d_invalidate);\n\n \n \nstatic struct dentry *__d_alloc(struct super_block *sb, const struct qstr *name)\n{\n\tstruct dentry *dentry;\n\tchar *dname;\n\tint err;\n\n\tdentry = kmem_cache_alloc_lru(dentry_cache, &sb->s_dentry_lru,\n\t\t\t\t      GFP_KERNEL);\n\tif (!dentry)\n\t\treturn NULL;\n\n\t \n\tdentry->d_iname[DNAME_INLINE_LEN-1] = 0;\n\tif (unlikely(!name)) {\n\t\tname = &slash_name;\n\t\tdname = dentry->d_iname;\n\t} else if (name->len > DNAME_INLINE_LEN-1) {\n\t\tsize_t size = offsetof(struct external_name, name[1]);\n\t\tstruct external_name *p = kmalloc(size + name->len,\n\t\t\t\t\t\t  GFP_KERNEL_ACCOUNT |\n\t\t\t\t\t\t  __GFP_RECLAIMABLE);\n\t\tif (!p) {\n\t\t\tkmem_cache_free(dentry_cache, dentry); \n\t\t\treturn NULL;\n\t\t}\n\t\tatomic_set(&p->u.count, 1);\n\t\tdname = p->name;\n\t} else  {\n\t\tdname = dentry->d_iname;\n\t}\t\n\n\tdentry->d_name.len = name->len;\n\tdentry->d_name.hash = name->hash;\n\tmemcpy(dname, name->name, name->len);\n\tdname[name->len] = 0;\n\n\t \n\tsmp_store_release(&dentry->d_name.name, dname);  \n\n\tdentry->d_lockref.count = 1;\n\tdentry->d_flags = 0;\n\tspin_lock_init(&dentry->d_lock);\n\tseqcount_spinlock_init(&dentry->d_seq, &dentry->d_lock);\n\tdentry->d_inode = NULL;\n\tdentry->d_parent = dentry;\n\tdentry->d_sb = sb;\n\tdentry->d_op = NULL;\n\tdentry->d_fsdata = NULL;\n\tINIT_HLIST_BL_NODE(&dentry->d_hash);\n\tINIT_LIST_HEAD(&dentry->d_lru);\n\tINIT_LIST_HEAD(&dentry->d_subdirs);\n\tINIT_HLIST_NODE(&dentry->d_u.d_alias);\n\tINIT_LIST_HEAD(&dentry->d_child);\n\td_set_d_op(dentry, dentry->d_sb->s_d_op);\n\n\tif (dentry->d_op && dentry->d_op->d_init) {\n\t\terr = dentry->d_op->d_init(dentry);\n\t\tif (err) {\n\t\t\tif (dname_external(dentry))\n\t\t\t\tkfree(external_name(dentry));\n\t\t\tkmem_cache_free(dentry_cache, dentry);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tthis_cpu_inc(nr_dentry);\n\n\treturn dentry;\n}\n\n \nstruct dentry *d_alloc(struct dentry * parent, const struct qstr *name)\n{\n\tstruct dentry *dentry = __d_alloc(parent->d_sb, name);\n\tif (!dentry)\n\t\treturn NULL;\n\tspin_lock(&parent->d_lock);\n\t \n\t__dget_dlock(parent);\n\tdentry->d_parent = parent;\n\tlist_add(&dentry->d_child, &parent->d_subdirs);\n\tspin_unlock(&parent->d_lock);\n\n\treturn dentry;\n}\nEXPORT_SYMBOL(d_alloc);\n\nstruct dentry *d_alloc_anon(struct super_block *sb)\n{\n\treturn __d_alloc(sb, NULL);\n}\nEXPORT_SYMBOL(d_alloc_anon);\n\nstruct dentry *d_alloc_cursor(struct dentry * parent)\n{\n\tstruct dentry *dentry = d_alloc_anon(parent->d_sb);\n\tif (dentry) {\n\t\tdentry->d_flags |= DCACHE_DENTRY_CURSOR;\n\t\tdentry->d_parent = dget(parent);\n\t}\n\treturn dentry;\n}\n\n \nstruct dentry *d_alloc_pseudo(struct super_block *sb, const struct qstr *name)\n{\n\tstruct dentry *dentry = __d_alloc(sb, name);\n\tif (likely(dentry))\n\t\tdentry->d_flags |= DCACHE_NORCU;\n\treturn dentry;\n}\n\nstruct dentry *d_alloc_name(struct dentry *parent, const char *name)\n{\n\tstruct qstr q;\n\n\tq.name = name;\n\tq.hash_len = hashlen_string(parent, name);\n\treturn d_alloc(parent, &q);\n}\nEXPORT_SYMBOL(d_alloc_name);\n\nvoid d_set_d_op(struct dentry *dentry, const struct dentry_operations *op)\n{\n\tWARN_ON_ONCE(dentry->d_op);\n\tWARN_ON_ONCE(dentry->d_flags & (DCACHE_OP_HASH\t|\n\t\t\t\tDCACHE_OP_COMPARE\t|\n\t\t\t\tDCACHE_OP_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_WEAK_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_DELETE\t|\n\t\t\t\tDCACHE_OP_REAL));\n\tdentry->d_op = op;\n\tif (!op)\n\t\treturn;\n\tif (op->d_hash)\n\t\tdentry->d_flags |= DCACHE_OP_HASH;\n\tif (op->d_compare)\n\t\tdentry->d_flags |= DCACHE_OP_COMPARE;\n\tif (op->d_revalidate)\n\t\tdentry->d_flags |= DCACHE_OP_REVALIDATE;\n\tif (op->d_weak_revalidate)\n\t\tdentry->d_flags |= DCACHE_OP_WEAK_REVALIDATE;\n\tif (op->d_delete)\n\t\tdentry->d_flags |= DCACHE_OP_DELETE;\n\tif (op->d_prune)\n\t\tdentry->d_flags |= DCACHE_OP_PRUNE;\n\tif (op->d_real)\n\t\tdentry->d_flags |= DCACHE_OP_REAL;\n\n}\nEXPORT_SYMBOL(d_set_d_op);\n\n\n \nvoid d_set_fallthru(struct dentry *dentry)\n{\n\tspin_lock(&dentry->d_lock);\n\tdentry->d_flags |= DCACHE_FALLTHRU;\n\tspin_unlock(&dentry->d_lock);\n}\nEXPORT_SYMBOL(d_set_fallthru);\n\nstatic unsigned d_flags_for_inode(struct inode *inode)\n{\n\tunsigned add_flags = DCACHE_REGULAR_TYPE;\n\n\tif (!inode)\n\t\treturn DCACHE_MISS_TYPE;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tadd_flags = DCACHE_DIRECTORY_TYPE;\n\t\tif (unlikely(!(inode->i_opflags & IOP_LOOKUP))) {\n\t\t\tif (unlikely(!inode->i_op->lookup))\n\t\t\t\tadd_flags = DCACHE_AUTODIR_TYPE;\n\t\t\telse\n\t\t\t\tinode->i_opflags |= IOP_LOOKUP;\n\t\t}\n\t\tgoto type_determined;\n\t}\n\n\tif (unlikely(!(inode->i_opflags & IOP_NOFOLLOW))) {\n\t\tif (unlikely(inode->i_op->get_link)) {\n\t\t\tadd_flags = DCACHE_SYMLINK_TYPE;\n\t\t\tgoto type_determined;\n\t\t}\n\t\tinode->i_opflags |= IOP_NOFOLLOW;\n\t}\n\n\tif (unlikely(!S_ISREG(inode->i_mode)))\n\t\tadd_flags = DCACHE_SPECIAL_TYPE;\n\ntype_determined:\n\tif (unlikely(IS_AUTOMOUNT(inode)))\n\t\tadd_flags |= DCACHE_NEED_AUTOMOUNT;\n\treturn add_flags;\n}\n\nstatic void __d_instantiate(struct dentry *dentry, struct inode *inode)\n{\n\tunsigned add_flags = d_flags_for_inode(inode);\n\tWARN_ON(d_in_lookup(dentry));\n\n\tspin_lock(&dentry->d_lock);\n\t \n\tif (dentry->d_flags & DCACHE_LRU_LIST)\n\t\tthis_cpu_dec(nr_dentry_negative);\n\thlist_add_head(&dentry->d_u.d_alias, &inode->i_dentry);\n\traw_write_seqcount_begin(&dentry->d_seq);\n\t__d_set_inode_and_type(dentry, inode, add_flags);\n\traw_write_seqcount_end(&dentry->d_seq);\n\tfsnotify_update_flags(dentry);\n\tspin_unlock(&dentry->d_lock);\n}\n\n \n \nvoid d_instantiate(struct dentry *entry, struct inode * inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\tif (inode) {\n\t\tsecurity_d_instantiate(entry, inode);\n\t\tspin_lock(&inode->i_lock);\n\t\t__d_instantiate(entry, inode);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n}\nEXPORT_SYMBOL(d_instantiate);\n\n \nvoid d_instantiate_new(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\tBUG_ON(!inode);\n\tlockdep_annotate_inode_mutex_key(inode);\n\tsecurity_d_instantiate(entry, inode);\n\tspin_lock(&inode->i_lock);\n\t__d_instantiate(entry, inode);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW & ~I_CREATING;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}\nEXPORT_SYMBOL(d_instantiate_new);\n\nstruct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tres = d_alloc_anon(root_inode->i_sb);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}\nEXPORT_SYMBOL(d_make_root);\n\nstatic struct dentry *__d_instantiate_anon(struct dentry *dentry,\n\t\t\t\t\t   struct inode *inode,\n\t\t\t\t\t   bool disconnected)\n{\n\tstruct dentry *res;\n\tunsigned add_flags;\n\n\tsecurity_d_instantiate(dentry, inode);\n\tspin_lock(&inode->i_lock);\n\tres = __d_find_any_alias(inode);\n\tif (res) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tdput(dentry);\n\t\tgoto out_iput;\n\t}\n\n\t \n\tadd_flags = d_flags_for_inode(inode);\n\n\tif (disconnected)\n\t\tadd_flags |= DCACHE_DISCONNECTED;\n\n\tspin_lock(&dentry->d_lock);\n\t__d_set_inode_and_type(dentry, inode, add_flags);\n\thlist_add_head(&dentry->d_u.d_alias, &inode->i_dentry);\n\tif (!disconnected) {\n\t\thlist_bl_lock(&dentry->d_sb->s_roots);\n\t\thlist_bl_add_head(&dentry->d_hash, &dentry->d_sb->s_roots);\n\t\thlist_bl_unlock(&dentry->d_sb->s_roots);\n\t}\n\tspin_unlock(&dentry->d_lock);\n\tspin_unlock(&inode->i_lock);\n\n\treturn dentry;\n\n out_iput:\n\tiput(inode);\n\treturn res;\n}\n\nstruct dentry *d_instantiate_anon(struct dentry *dentry, struct inode *inode)\n{\n\treturn __d_instantiate_anon(dentry, inode, true);\n}\nEXPORT_SYMBOL(d_instantiate_anon);\n\nstatic struct dentry *__d_obtain_alias(struct inode *inode, bool disconnected)\n{\n\tstruct dentry *tmp;\n\tstruct dentry *res;\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ESTALE);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tres = d_find_any_alias(inode);\n\tif (res)\n\t\tgoto out_iput;\n\n\ttmp = d_alloc_anon(inode->i_sb);\n\tif (!tmp) {\n\t\tres = ERR_PTR(-ENOMEM);\n\t\tgoto out_iput;\n\t}\n\n\treturn __d_instantiate_anon(tmp, inode, disconnected);\n\nout_iput:\n\tiput(inode);\n\treturn res;\n}\n\n \nstruct dentry *d_obtain_alias(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, true);\n}\nEXPORT_SYMBOL(d_obtain_alias);\n\n \nstruct dentry *d_obtain_root(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, false);\n}\nEXPORT_SYMBOL(d_obtain_root);\n\n \nstruct dentry *d_add_ci(struct dentry *dentry, struct inode *inode,\n\t\t\tstruct qstr *name)\n{\n\tstruct dentry *found, *res;\n\n\t \n\tfound = d_hash_and_lookup(dentry->d_parent, name);\n\tif (found) {\n\t\tiput(inode);\n\t\treturn found;\n\t}\n\tif (d_in_lookup(dentry)) {\n\t\tfound = d_alloc_parallel(dentry->d_parent, name,\n\t\t\t\t\tdentry->d_wait);\n\t\tif (IS_ERR(found) || !d_in_lookup(found)) {\n\t\t\tiput(inode);\n\t\t\treturn found;\n\t\t}\n\t} else {\n\t\tfound = d_alloc(dentry->d_parent, name);\n\t\tif (!found) {\n\t\t\tiput(inode);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t} \n\t}\n\tres = d_splice_alias(inode, found);\n\tif (res) {\n\t\td_lookup_done(found);\n\t\tdput(found);\n\t\treturn res;\n\t}\n\treturn found;\n}\nEXPORT_SYMBOL(d_add_ci);\n\n \nbool d_same_name(const struct dentry *dentry, const struct dentry *parent,\n\t\t const struct qstr *name)\n{\n\tif (likely(!(parent->d_flags & DCACHE_OP_COMPARE))) {\n\t\tif (dentry->d_name.len != name->len)\n\t\t\treturn false;\n\t\treturn dentry_cmp(dentry, name->name, name->len) == 0;\n\t}\n\treturn parent->d_op->d_compare(dentry,\n\t\t\t\t       dentry->d_name.len, dentry->d_name.name,\n\t\t\t\t       name) == 0;\n}\nEXPORT_SYMBOL_GPL(d_same_name);\n\n \nstatic noinline struct dentry *__d_lookup_rcu_op_compare(\n\tconst struct dentry *parent,\n\tconst struct qstr *name,\n\tunsigned *seqp)\n{\n\tu64 hashlen = name->hash_len;\n\tstruct hlist_bl_head *b = d_hash(hashlen_hash(hashlen));\n\tstruct hlist_bl_node *node;\n\tstruct dentry *dentry;\n\n\thlist_bl_for_each_entry_rcu(dentry, node, b, d_hash) {\n\t\tint tlen;\n\t\tconst char *tname;\n\t\tunsigned seq;\n\nseqretry:\n\t\tseq = raw_seqcount_begin(&dentry->d_seq);\n\t\tif (dentry->d_parent != parent)\n\t\t\tcontinue;\n\t\tif (d_unhashed(dentry))\n\t\t\tcontinue;\n\t\tif (dentry->d_name.hash != hashlen_hash(hashlen))\n\t\t\tcontinue;\n\t\ttlen = dentry->d_name.len;\n\t\ttname = dentry->d_name.name;\n\t\t \n\t\tif (read_seqcount_retry(&dentry->d_seq, seq)) {\n\t\t\tcpu_relax();\n\t\t\tgoto seqretry;\n\t\t}\n\t\tif (parent->d_op->d_compare(dentry, tlen, tname, name) != 0)\n\t\t\tcontinue;\n\t\t*seqp = seq;\n\t\treturn dentry;\n\t}\n\treturn NULL;\n}\n\n \nstruct dentry *__d_lookup_rcu(const struct dentry *parent,\n\t\t\t\tconst struct qstr *name,\n\t\t\t\tunsigned *seqp)\n{\n\tu64 hashlen = name->hash_len;\n\tconst unsigned char *str = name->name;\n\tstruct hlist_bl_head *b = d_hash(hashlen_hash(hashlen));\n\tstruct hlist_bl_node *node;\n\tstruct dentry *dentry;\n\n\t \n\n\tif (unlikely(parent->d_flags & DCACHE_OP_COMPARE))\n\t\treturn __d_lookup_rcu_op_compare(parent, name, seqp);\n\n\t \n\thlist_bl_for_each_entry_rcu(dentry, node, b, d_hash) {\n\t\tunsigned seq;\n\n\t\t \n\t\tseq = raw_seqcount_begin(&dentry->d_seq);\n\t\tif (dentry->d_parent != parent)\n\t\t\tcontinue;\n\t\tif (d_unhashed(dentry))\n\t\t\tcontinue;\n\t\tif (dentry->d_name.hash_len != hashlen)\n\t\t\tcontinue;\n\t\tif (dentry_cmp(dentry, str, hashlen_len(hashlen)) != 0)\n\t\t\tcontinue;\n\t\t*seqp = seq;\n\t\treturn dentry;\n\t}\n\treturn NULL;\n}\n\n \nstruct dentry *d_lookup(const struct dentry *parent, const struct qstr *name)\n{\n\tstruct dentry *dentry;\n\tunsigned seq;\n\n\tdo {\n\t\tseq = read_seqbegin(&rename_lock);\n\t\tdentry = __d_lookup(parent, name);\n\t\tif (dentry)\n\t\t\tbreak;\n\t} while (read_seqretry(&rename_lock, seq));\n\treturn dentry;\n}\nEXPORT_SYMBOL(d_lookup);\n\n \nstruct dentry *__d_lookup(const struct dentry *parent, const struct qstr *name)\n{\n\tunsigned int hash = name->hash;\n\tstruct hlist_bl_head *b = d_hash(hash);\n\tstruct hlist_bl_node *node;\n\tstruct dentry *found = NULL;\n\tstruct dentry *dentry;\n\n\t \n\n\t \n\trcu_read_lock();\n\t\n\thlist_bl_for_each_entry_rcu(dentry, node, b, d_hash) {\n\n\t\tif (dentry->d_name.hash != hash)\n\t\t\tcontinue;\n\n\t\tspin_lock(&dentry->d_lock);\n\t\tif (dentry->d_parent != parent)\n\t\t\tgoto next;\n\t\tif (d_unhashed(dentry))\n\t\t\tgoto next;\n\n\t\tif (!d_same_name(dentry, parent, name))\n\t\t\tgoto next;\n\n\t\tdentry->d_lockref.count++;\n\t\tfound = dentry;\n\t\tspin_unlock(&dentry->d_lock);\n\t\tbreak;\nnext:\n\t\tspin_unlock(&dentry->d_lock);\n \t}\n \trcu_read_unlock();\n\n \treturn found;\n}\n\n \nstruct dentry *d_hash_and_lookup(struct dentry *dir, struct qstr *name)\n{\n\t \n\tname->hash = full_name_hash(dir, name->name, name->len);\n\tif (dir->d_flags & DCACHE_OP_HASH) {\n\t\tint err = dir->d_op->d_hash(dir, name);\n\t\tif (unlikely(err < 0))\n\t\t\treturn ERR_PTR(err);\n\t}\n\treturn d_lookup(dir, name);\n}\nEXPORT_SYMBOL(d_hash_and_lookup);\n\n \n \n \n \nvoid d_delete(struct dentry * dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\n\tspin_lock(&inode->i_lock);\n\tspin_lock(&dentry->d_lock);\n\t \n\tif (dentry->d_lockref.count == 1) {\n\t\tdentry->d_flags &= ~DCACHE_CANT_MOUNT;\n\t\tdentry_unlink_inode(dentry);\n\t} else {\n\t\t__d_drop(dentry);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n}\nEXPORT_SYMBOL(d_delete);\n\nstatic void __d_rehash(struct dentry *entry)\n{\n\tstruct hlist_bl_head *b = d_hash(entry->d_name.hash);\n\n\thlist_bl_lock(b);\n\thlist_bl_add_head_rcu(&entry->d_hash, b);\n\thlist_bl_unlock(b);\n}\n\n \n \nvoid d_rehash(struct dentry * entry)\n{\n\tspin_lock(&entry->d_lock);\n\t__d_rehash(entry);\n\tspin_unlock(&entry->d_lock);\n}\nEXPORT_SYMBOL(d_rehash);\n\nstatic inline unsigned start_dir_add(struct inode *dir)\n{\n\tpreempt_disable_nested();\n\tfor (;;) {\n\t\tunsigned n = dir->i_dir_seq;\n\t\tif (!(n & 1) && cmpxchg(&dir->i_dir_seq, n, n + 1) == n)\n\t\t\treturn n;\n\t\tcpu_relax();\n\t}\n}\n\nstatic inline void end_dir_add(struct inode *dir, unsigned int n,\n\t\t\t       wait_queue_head_t *d_wait)\n{\n\tsmp_store_release(&dir->i_dir_seq, n + 2);\n\tpreempt_enable_nested();\n\twake_up_all(d_wait);\n}\n\nstatic void d_wait_lookup(struct dentry *dentry)\n{\n\tif (d_in_lookup(dentry)) {\n\t\tDECLARE_WAITQUEUE(wait, current);\n\t\tadd_wait_queue(dentry->d_wait, &wait);\n\t\tdo {\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tschedule();\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t} while (d_in_lookup(dentry));\n\t}\n}\n\nstruct dentry *d_alloc_parallel(struct dentry *parent,\n\t\t\t\tconst struct qstr *name,\n\t\t\t\twait_queue_head_t *wq)\n{\n\tunsigned int hash = name->hash;\n\tstruct hlist_bl_head *b = in_lookup_hash(parent, hash);\n\tstruct hlist_bl_node *node;\n\tstruct dentry *new = d_alloc(parent, name);\n\tstruct dentry *dentry;\n\tunsigned seq, r_seq, d_seq;\n\n\tif (unlikely(!new))\n\t\treturn ERR_PTR(-ENOMEM);\n\nretry:\n\trcu_read_lock();\n\tseq = smp_load_acquire(&parent->d_inode->i_dir_seq);\n\tr_seq = read_seqbegin(&rename_lock);\n\tdentry = __d_lookup_rcu(parent, name, &d_seq);\n\tif (unlikely(dentry)) {\n\t\tif (!lockref_get_not_dead(&dentry->d_lockref)) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto retry;\n\t\t}\n\t\tif (read_seqcount_retry(&dentry->d_seq, d_seq)) {\n\t\t\trcu_read_unlock();\n\t\t\tdput(dentry);\n\t\t\tgoto retry;\n\t\t}\n\t\trcu_read_unlock();\n\t\tdput(new);\n\t\treturn dentry;\n\t}\n\tif (unlikely(read_seqretry(&rename_lock, r_seq))) {\n\t\trcu_read_unlock();\n\t\tgoto retry;\n\t}\n\n\tif (unlikely(seq & 1)) {\n\t\trcu_read_unlock();\n\t\tgoto retry;\n\t}\n\n\thlist_bl_lock(b);\n\tif (unlikely(READ_ONCE(parent->d_inode->i_dir_seq) != seq)) {\n\t\thlist_bl_unlock(b);\n\t\trcu_read_unlock();\n\t\tgoto retry;\n\t}\n\t \n\thlist_bl_for_each_entry(dentry, node, b, d_u.d_in_lookup_hash) {\n\t\tif (dentry->d_name.hash != hash)\n\t\t\tcontinue;\n\t\tif (dentry->d_parent != parent)\n\t\t\tcontinue;\n\t\tif (!d_same_name(dentry, parent, name))\n\t\t\tcontinue;\n\t\thlist_bl_unlock(b);\n\t\t \n\t\tif (!lockref_get_not_dead(&dentry->d_lockref)) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto retry;\n\t\t}\n\n\t\trcu_read_unlock();\n\t\t \n\t\tspin_lock(&dentry->d_lock);\n\t\td_wait_lookup(dentry);\n\t\t \n\t\tif (unlikely(dentry->d_name.hash != hash))\n\t\t\tgoto mismatch;\n\t\tif (unlikely(dentry->d_parent != parent))\n\t\t\tgoto mismatch;\n\t\tif (unlikely(d_unhashed(dentry)))\n\t\t\tgoto mismatch;\n\t\tif (unlikely(!d_same_name(dentry, parent, name)))\n\t\t\tgoto mismatch;\n\t\t \n\t\tspin_unlock(&dentry->d_lock);\n\t\tdput(new);\n\t\treturn dentry;\n\t}\n\trcu_read_unlock();\n\t \n\tnew->d_flags |= DCACHE_PAR_LOOKUP;\n\tnew->d_wait = wq;\n\thlist_bl_add_head_rcu(&new->d_u.d_in_lookup_hash, b);\n\thlist_bl_unlock(b);\n\treturn new;\nmismatch:\n\tspin_unlock(&dentry->d_lock);\n\tdput(dentry);\n\tgoto retry;\n}\nEXPORT_SYMBOL(d_alloc_parallel);\n\n \nstatic wait_queue_head_t *__d_lookup_unhash(struct dentry *dentry)\n{\n\twait_queue_head_t *d_wait;\n\tstruct hlist_bl_head *b;\n\n\tlockdep_assert_held(&dentry->d_lock);\n\n\tb = in_lookup_hash(dentry->d_parent, dentry->d_name.hash);\n\thlist_bl_lock(b);\n\tdentry->d_flags &= ~DCACHE_PAR_LOOKUP;\n\t__hlist_bl_del(&dentry->d_u.d_in_lookup_hash);\n\td_wait = dentry->d_wait;\n\tdentry->d_wait = NULL;\n\thlist_bl_unlock(b);\n\tINIT_HLIST_NODE(&dentry->d_u.d_alias);\n\tINIT_LIST_HEAD(&dentry->d_lru);\n\treturn d_wait;\n}\n\nvoid __d_lookup_unhash_wake(struct dentry *dentry)\n{\n\tspin_lock(&dentry->d_lock);\n\twake_up_all(__d_lookup_unhash(dentry));\n\tspin_unlock(&dentry->d_lock);\n}\nEXPORT_SYMBOL(__d_lookup_unhash_wake);\n\n \n\nstatic inline void __d_add(struct dentry *dentry, struct inode *inode)\n{\n\twait_queue_head_t *d_wait;\n\tstruct inode *dir = NULL;\n\tunsigned n;\n\tspin_lock(&dentry->d_lock);\n\tif (unlikely(d_in_lookup(dentry))) {\n\t\tdir = dentry->d_parent->d_inode;\n\t\tn = start_dir_add(dir);\n\t\td_wait = __d_lookup_unhash(dentry);\n\t}\n\tif (inode) {\n\t\tunsigned add_flags = d_flags_for_inode(inode);\n\t\thlist_add_head(&dentry->d_u.d_alias, &inode->i_dentry);\n\t\traw_write_seqcount_begin(&dentry->d_seq);\n\t\t__d_set_inode_and_type(dentry, inode, add_flags);\n\t\traw_write_seqcount_end(&dentry->d_seq);\n\t\tfsnotify_update_flags(dentry);\n\t}\n\t__d_rehash(dentry);\n\tif (dir)\n\t\tend_dir_add(dir, n, d_wait);\n\tspin_unlock(&dentry->d_lock);\n\tif (inode)\n\t\tspin_unlock(&inode->i_lock);\n}\n\n \n\nvoid d_add(struct dentry *entry, struct inode *inode)\n{\n\tif (inode) {\n\t\tsecurity_d_instantiate(entry, inode);\n\t\tspin_lock(&inode->i_lock);\n\t}\n\t__d_add(entry, inode);\n}\nEXPORT_SYMBOL(d_add);\n\n \nstruct dentry *d_exact_alias(struct dentry *entry, struct inode *inode)\n{\n\tstruct dentry *alias;\n\tunsigned int hash = entry->d_name.hash;\n\n\tspin_lock(&inode->i_lock);\n\thlist_for_each_entry(alias, &inode->i_dentry, d_u.d_alias) {\n\t\t \n\t\tif (alias->d_name.hash != hash)\n\t\t\tcontinue;\n\t\tif (alias->d_parent != entry->d_parent)\n\t\t\tcontinue;\n\t\tif (!d_same_name(alias, entry->d_parent, &entry->d_name))\n\t\t\tcontinue;\n\t\tspin_lock(&alias->d_lock);\n\t\tif (!d_unhashed(alias)) {\n\t\t\tspin_unlock(&alias->d_lock);\n\t\t\talias = NULL;\n\t\t} else {\n\t\t\t__dget_dlock(alias);\n\t\t\t__d_rehash(alias);\n\t\t\tspin_unlock(&alias->d_lock);\n\t\t}\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn alias;\n\t}\n\tspin_unlock(&inode->i_lock);\n\treturn NULL;\n}\nEXPORT_SYMBOL(d_exact_alias);\n\nstatic void swap_names(struct dentry *dentry, struct dentry *target)\n{\n\tif (unlikely(dname_external(target))) {\n\t\tif (unlikely(dname_external(dentry))) {\n\t\t\t \n\t\t\tswap(target->d_name.name, dentry->d_name.name);\n\t\t} else {\n\t\t\t \n\t\t\tmemcpy(target->d_iname, dentry->d_name.name,\n\t\t\t\t\tdentry->d_name.len + 1);\n\t\t\tdentry->d_name.name = target->d_name.name;\n\t\t\ttarget->d_name.name = target->d_iname;\n\t\t}\n\t} else {\n\t\tif (unlikely(dname_external(dentry))) {\n\t\t\t \n\t\t\tmemcpy(dentry->d_iname, target->d_name.name,\n\t\t\t\t\ttarget->d_name.len + 1);\n\t\t\ttarget->d_name.name = dentry->d_name.name;\n\t\t\tdentry->d_name.name = dentry->d_iname;\n\t\t} else {\n\t\t\t \n\t\t\tunsigned int i;\n\t\t\tBUILD_BUG_ON(!IS_ALIGNED(DNAME_INLINE_LEN, sizeof(long)));\n\t\t\tfor (i = 0; i < DNAME_INLINE_LEN / sizeof(long); i++) {\n\t\t\t\tswap(((long *) &dentry->d_iname)[i],\n\t\t\t\t     ((long *) &target->d_iname)[i]);\n\t\t\t}\n\t\t}\n\t}\n\tswap(dentry->d_name.hash_len, target->d_name.hash_len);\n}\n\nstatic void copy_name(struct dentry *dentry, struct dentry *target)\n{\n\tstruct external_name *old_name = NULL;\n\tif (unlikely(dname_external(dentry)))\n\t\told_name = external_name(dentry);\n\tif (unlikely(dname_external(target))) {\n\t\tatomic_inc(&external_name(target)->u.count);\n\t\tdentry->d_name = target->d_name;\n\t} else {\n\t\tmemcpy(dentry->d_iname, target->d_name.name,\n\t\t\t\ttarget->d_name.len + 1);\n\t\tdentry->d_name.name = dentry->d_iname;\n\t\tdentry->d_name.hash_len = target->d_name.hash_len;\n\t}\n\tif (old_name && likely(atomic_dec_and_test(&old_name->u.count)))\n\t\tkfree_rcu(old_name, u.head);\n}\n\n \nstatic void __d_move(struct dentry *dentry, struct dentry *target,\n\t\t     bool exchange)\n{\n\tstruct dentry *old_parent, *p;\n\twait_queue_head_t *d_wait;\n\tstruct inode *dir = NULL;\n\tunsigned n;\n\n\tWARN_ON(!dentry->d_inode);\n\tif (WARN_ON(dentry == target))\n\t\treturn;\n\n\tBUG_ON(d_ancestor(target, dentry));\n\told_parent = dentry->d_parent;\n\tp = d_ancestor(old_parent, target);\n\tif (IS_ROOT(dentry)) {\n\t\tBUG_ON(p);\n\t\tspin_lock(&target->d_parent->d_lock);\n\t} else if (!p) {\n\t\t \n\t\tspin_lock(&target->d_parent->d_lock);\n\t\tspin_lock_nested(&old_parent->d_lock, DENTRY_D_LOCK_NESTED);\n\t} else {\n\t\tBUG_ON(p == dentry);\n\t\tspin_lock(&old_parent->d_lock);\n\t\tif (p != target)\n\t\t\tspin_lock_nested(&target->d_parent->d_lock,\n\t\t\t\t\tDENTRY_D_LOCK_NESTED);\n\t}\n\tspin_lock_nested(&dentry->d_lock, 2);\n\tspin_lock_nested(&target->d_lock, 3);\n\n\tif (unlikely(d_in_lookup(target))) {\n\t\tdir = target->d_parent->d_inode;\n\t\tn = start_dir_add(dir);\n\t\td_wait = __d_lookup_unhash(target);\n\t}\n\n\twrite_seqcount_begin(&dentry->d_seq);\n\twrite_seqcount_begin_nested(&target->d_seq, DENTRY_D_LOCK_NESTED);\n\n\t \n\tif (!d_unhashed(dentry))\n\t\t___d_drop(dentry);\n\tif (!d_unhashed(target))\n\t\t___d_drop(target);\n\n\t \n\tdentry->d_parent = target->d_parent;\n\tif (!exchange) {\n\t\tcopy_name(dentry, target);\n\t\ttarget->d_hash.pprev = NULL;\n\t\tdentry->d_parent->d_lockref.count++;\n\t\tif (dentry != old_parent)  \n\t\t\tWARN_ON(!--old_parent->d_lockref.count);\n\t} else {\n\t\ttarget->d_parent = old_parent;\n\t\tswap_names(dentry, target);\n\t\tlist_move(&target->d_child, &target->d_parent->d_subdirs);\n\t\t__d_rehash(target);\n\t\tfsnotify_update_flags(target);\n\t}\n\tlist_move(&dentry->d_child, &dentry->d_parent->d_subdirs);\n\t__d_rehash(dentry);\n\tfsnotify_update_flags(dentry);\n\tfscrypt_handle_d_move(dentry);\n\n\twrite_seqcount_end(&target->d_seq);\n\twrite_seqcount_end(&dentry->d_seq);\n\n\tif (dir)\n\t\tend_dir_add(dir, n, d_wait);\n\n\tif (dentry->d_parent != old_parent)\n\t\tspin_unlock(&dentry->d_parent->d_lock);\n\tif (dentry != old_parent)\n\t\tspin_unlock(&old_parent->d_lock);\n\tspin_unlock(&target->d_lock);\n\tspin_unlock(&dentry->d_lock);\n}\n\n \nvoid d_move(struct dentry *dentry, struct dentry *target)\n{\n\twrite_seqlock(&rename_lock);\n\t__d_move(dentry, target, false);\n\twrite_sequnlock(&rename_lock);\n}\nEXPORT_SYMBOL(d_move);\n\n \nvoid d_exchange(struct dentry *dentry1, struct dentry *dentry2)\n{\n\twrite_seqlock(&rename_lock);\n\n\tWARN_ON(!dentry1->d_inode);\n\tWARN_ON(!dentry2->d_inode);\n\tWARN_ON(IS_ROOT(dentry1));\n\tWARN_ON(IS_ROOT(dentry2));\n\n\t__d_move(dentry1, dentry2, true);\n\n\twrite_sequnlock(&rename_lock);\n}\n\n \nstruct dentry *d_ancestor(struct dentry *p1, struct dentry *p2)\n{\n\tstruct dentry *p;\n\n\tfor (p = p2; !IS_ROOT(p); p = p->d_parent) {\n\t\tif (p->d_parent == p1)\n\t\t\treturn p;\n\t}\n\treturn NULL;\n}\n\n \nstatic int __d_unalias(struct inode *inode,\n\t\tstruct dentry *dentry, struct dentry *alias)\n{\n\tstruct mutex *m1 = NULL;\n\tstruct rw_semaphore *m2 = NULL;\n\tint ret = -ESTALE;\n\n\t \n\tif (alias->d_parent == dentry->d_parent)\n\t\tgoto out_unalias;\n\n\t \n\tif (!mutex_trylock(&dentry->d_sb->s_vfs_rename_mutex))\n\t\tgoto out_err;\n\tm1 = &dentry->d_sb->s_vfs_rename_mutex;\n\tif (!inode_trylock_shared(alias->d_parent->d_inode))\n\t\tgoto out_err;\n\tm2 = &alias->d_parent->d_inode->i_rwsem;\nout_unalias:\n\t__d_move(alias, dentry, false);\n\tret = 0;\nout_err:\n\tif (m2)\n\t\tup_read(m2);\n\tif (m1)\n\t\tmutex_unlock(m1);\n\treturn ret;\n}\n\n \nstruct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)\n{\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tBUG_ON(!d_unhashed(dentry));\n\n\tif (!inode)\n\t\tgoto out;\n\n\tsecurity_d_instantiate(dentry, inode);\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct dentry *new = __d_find_any_alias(inode);\n\t\tif (unlikely(new)) {\n\t\t\t \n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\twrite_seqlock(&rename_lock);\n\t\t\tif (unlikely(d_ancestor(new, dentry))) {\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tdput(new);\n\t\t\t\tnew = ERR_PTR(-ELOOP);\n\t\t\t\tpr_warn_ratelimited(\n\t\t\t\t\t\"VFS: Lookup of '%s' in %s %s\"\n\t\t\t\t\t\" would have caused loop\\n\",\n\t\t\t\t\tdentry->d_name.name,\n\t\t\t\t\tinode->i_sb->s_type->name,\n\t\t\t\t\tinode->i_sb->s_id);\n\t\t\t} else if (!IS_ROOT(new)) {\n\t\t\t\tstruct dentry *old_parent = dget(new->d_parent);\n\t\t\t\tint err = __d_unalias(inode, dentry, new);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tif (err) {\n\t\t\t\t\tdput(new);\n\t\t\t\t\tnew = ERR_PTR(err);\n\t\t\t\t}\n\t\t\t\tdput(old_parent);\n\t\t\t} else {\n\t\t\t\t__d_move(new, dentry, false);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\treturn new;\n\t\t}\n\t}\nout:\n\t__d_add(dentry, inode);\n\treturn NULL;\n}\nEXPORT_SYMBOL(d_splice_alias);\n\n \n\n \n  \nbool is_subdir(struct dentry *new_dentry, struct dentry *old_dentry)\n{\n\tbool result;\n\tunsigned seq;\n\n\tif (new_dentry == old_dentry)\n\t\treturn true;\n\n\tdo {\n\t\t \n\t\tseq = read_seqbegin(&rename_lock);\n\t\t \n\t\trcu_read_lock();\n\t\tif (d_ancestor(old_dentry, new_dentry))\n\t\t\tresult = true;\n\t\telse\n\t\t\tresult = false;\n\t\trcu_read_unlock();\n\t} while (read_seqretry(&rename_lock, seq));\n\n\treturn result;\n}\nEXPORT_SYMBOL(is_subdir);\n\nstatic enum d_walk_ret d_genocide_kill(void *data, struct dentry *dentry)\n{\n\tstruct dentry *root = data;\n\tif (dentry != root) {\n\t\tif (d_unhashed(dentry) || !dentry->d_inode)\n\t\t\treturn D_WALK_SKIP;\n\n\t\tif (!(dentry->d_flags & DCACHE_GENOCIDE)) {\n\t\t\tdentry->d_flags |= DCACHE_GENOCIDE;\n\t\t\tdentry->d_lockref.count--;\n\t\t}\n\t}\n\treturn D_WALK_CONTINUE;\n}\n\nvoid d_genocide(struct dentry *parent)\n{\n\td_walk(parent, parent, d_genocide_kill);\n}\n\nvoid d_tmpfile(struct file *file, struct inode *inode)\n{\n\tstruct dentry *dentry = file->f_path.dentry;\n\n\tinode_dec_link_count(inode);\n\tBUG_ON(dentry->d_name.name != dentry->d_iname ||\n\t\t!hlist_unhashed(&dentry->d_u.d_alias) ||\n\t\t!d_unlinked(dentry));\n\tspin_lock(&dentry->d_parent->d_lock);\n\tspin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);\n\tdentry->d_name.len = sprintf(dentry->d_iname, \"#%llu\",\n\t\t\t\t(unsigned long long)inode->i_ino);\n\tspin_unlock(&dentry->d_lock);\n\tspin_unlock(&dentry->d_parent->d_lock);\n\td_instantiate(dentry, inode);\n}\nEXPORT_SYMBOL(d_tmpfile);\n\nstatic __initdata unsigned long dhash_entries;\nstatic int __init set_dhash_entries(char *str)\n{\n\tif (!str)\n\t\treturn 0;\n\tdhash_entries = simple_strtoul(str, &str, 0);\n\treturn 1;\n}\n__setup(\"dhash_entries=\", set_dhash_entries);\n\nstatic void __init dcache_init_early(void)\n{\n\t \n\tif (hashdist)\n\t\treturn;\n\n\tdentry_hashtable =\n\t\talloc_large_system_hash(\"Dentry cache\",\n\t\t\t\t\tsizeof(struct hlist_bl_head),\n\t\t\t\t\tdhash_entries,\n\t\t\t\t\t13,\n\t\t\t\t\tHASH_EARLY | HASH_ZERO,\n\t\t\t\t\t&d_hash_shift,\n\t\t\t\t\tNULL,\n\t\t\t\t\t0,\n\t\t\t\t\t0);\n\td_hash_shift = 32 - d_hash_shift;\n}\n\nstatic void __init dcache_init(void)\n{\n\t \n\tdentry_cache = KMEM_CACHE_USERCOPY(dentry,\n\t\tSLAB_RECLAIM_ACCOUNT|SLAB_PANIC|SLAB_MEM_SPREAD|SLAB_ACCOUNT,\n\t\td_iname);\n\n\t \n\tif (!hashdist)\n\t\treturn;\n\n\tdentry_hashtable =\n\t\talloc_large_system_hash(\"Dentry cache\",\n\t\t\t\t\tsizeof(struct hlist_bl_head),\n\t\t\t\t\tdhash_entries,\n\t\t\t\t\t13,\n\t\t\t\t\tHASH_ZERO,\n\t\t\t\t\t&d_hash_shift,\n\t\t\t\t\tNULL,\n\t\t\t\t\t0,\n\t\t\t\t\t0);\n\td_hash_shift = 32 - d_hash_shift;\n}\n\n \nstruct kmem_cache *names_cachep __read_mostly;\nEXPORT_SYMBOL(names_cachep);\n\nvoid __init vfs_caches_init_early(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(in_lookup_hashtable); i++)\n\t\tINIT_HLIST_BL_HEAD(&in_lookup_hashtable[i]);\n\n\tdcache_init_early();\n\tinode_init_early();\n}\n\nvoid __init vfs_caches_init(void)\n{\n\tnames_cachep = kmem_cache_create_usercopy(\"names_cache\", PATH_MAX, 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC, 0, PATH_MAX, NULL);\n\n\tdcache_init();\n\tinode_init();\n\tfiles_init();\n\tfiles_maxfiles_init();\n\tmnt_init();\n\tbdev_cache_init();\n\tchrdev_init();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}