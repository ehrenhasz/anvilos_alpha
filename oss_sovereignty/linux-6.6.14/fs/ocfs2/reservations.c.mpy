{
  "module_name": "reservations.c",
  "hash_id": "ef7c4268f6b447a7046adf75d0c2a8d4fa291802893080d3e07b86c48cb51e88",
  "original_prompt": "Ingested from linux-6.6.14/fs/ocfs2/reservations.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/highmem.h>\n#include <linux/bitops.h>\n#include <linux/list.h>\n\n#include <cluster/masklog.h>\n\n#include \"ocfs2.h\"\n#include \"ocfs2_trace.h\"\n\n#ifdef CONFIG_OCFS2_DEBUG_FS\n#define OCFS2_CHECK_RESERVATIONS\n#endif\n\nstatic DEFINE_SPINLOCK(resv_lock);\n\nint ocfs2_dir_resv_allowed(struct ocfs2_super *osb)\n{\n\treturn (osb->osb_resv_level && osb->osb_dir_resv_level);\n}\n\nstatic unsigned int ocfs2_resv_window_bits(struct ocfs2_reservation_map *resmap,\n\t\t\t\t\t   struct ocfs2_alloc_reservation *resv)\n{\n\tstruct ocfs2_super *osb = resmap->m_osb;\n\tunsigned int bits;\n\n\tif (!(resv->r_flags & OCFS2_RESV_FLAG_DIR)) {\n\t\t \n\t\tbits = 4 << osb->osb_resv_level;\n\t} else {\n\t\tbits = 4 << osb->osb_dir_resv_level;\n\t}\n\treturn bits;\n}\n\nstatic inline unsigned int ocfs2_resv_end(struct ocfs2_alloc_reservation *resv)\n{\n\tif (resv->r_len)\n\t\treturn resv->r_start + resv->r_len - 1;\n\treturn resv->r_start;\n}\n\nstatic inline int ocfs2_resv_empty(struct ocfs2_alloc_reservation *resv)\n{\n\treturn !!(resv->r_len == 0);\n}\n\nstatic inline int ocfs2_resmap_disabled(struct ocfs2_reservation_map *resmap)\n{\n\tif (resmap->m_osb->osb_resv_level == 0)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic void ocfs2_dump_resv(struct ocfs2_reservation_map *resmap)\n{\n\tstruct ocfs2_super *osb = resmap->m_osb;\n\tstruct rb_node *node;\n\tstruct ocfs2_alloc_reservation *resv;\n\tint i = 0;\n\n\tmlog(ML_NOTICE, \"Dumping resmap for device %s. Bitmap length: %u\\n\",\n\t     osb->dev_str, resmap->m_bitmap_len);\n\n\tnode = rb_first(&resmap->m_reservations);\n\twhile (node) {\n\t\tresv = rb_entry(node, struct ocfs2_alloc_reservation, r_node);\n\n\t\tmlog(ML_NOTICE, \"start: %u\\tend: %u\\tlen: %u\\tlast_start: %u\"\n\t\t     \"\\tlast_len: %u\\n\", resv->r_start,\n\t\t     ocfs2_resv_end(resv), resv->r_len, resv->r_last_start,\n\t\t     resv->r_last_len);\n\n\t\tnode = rb_next(node);\n\t\ti++;\n\t}\n\n\tmlog(ML_NOTICE, \"%d reservations found. LRU follows\\n\", i);\n\n\ti = 0;\n\tlist_for_each_entry(resv, &resmap->m_lru, r_lru) {\n\t\tmlog(ML_NOTICE, \"LRU(%d) start: %u\\tend: %u\\tlen: %u\\t\"\n\t\t     \"last_start: %u\\tlast_len: %u\\n\", i, resv->r_start,\n\t\t     ocfs2_resv_end(resv), resv->r_len, resv->r_last_start,\n\t\t     resv->r_last_len);\n\n\t\ti++;\n\t}\n}\n\n#ifdef OCFS2_CHECK_RESERVATIONS\nstatic int ocfs2_validate_resmap_bits(struct ocfs2_reservation_map *resmap,\n\t\t\t\t      int i,\n\t\t\t\t      struct ocfs2_alloc_reservation *resv)\n{\n\tchar *disk_bitmap = resmap->m_disk_bitmap;\n\tunsigned int start = resv->r_start;\n\tunsigned int end = ocfs2_resv_end(resv);\n\n\twhile (start <= end) {\n\t\tif (ocfs2_test_bit(start, disk_bitmap)) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"reservation %d covers an allocated area \"\n\t\t\t     \"starting at bit %u!\\n\", i, start);\n\t\t\treturn 1;\n\t\t}\n\n\t\tstart++;\n\t}\n\treturn 0;\n}\n\nstatic void ocfs2_check_resmap(struct ocfs2_reservation_map *resmap)\n{\n\tunsigned int off = 0;\n\tint i = 0;\n\tstruct rb_node *node;\n\tstruct ocfs2_alloc_reservation *resv;\n\n\tnode = rb_first(&resmap->m_reservations);\n\twhile (node) {\n\t\tresv = rb_entry(node, struct ocfs2_alloc_reservation, r_node);\n\n\t\tif (i > 0 && resv->r_start <= off) {\n\t\t\tmlog(ML_ERROR, \"reservation %d has bad start off!\\n\",\n\t\t\t     i);\n\t\t\tgoto bad;\n\t\t}\n\n\t\tif (resv->r_len == 0) {\n\t\t\tmlog(ML_ERROR, \"reservation %d has no length!\\n\",\n\t\t\t     i);\n\t\t\tgoto bad;\n\t\t}\n\n\t\tif (resv->r_start > ocfs2_resv_end(resv)) {\n\t\t\tmlog(ML_ERROR, \"reservation %d has invalid range!\\n\",\n\t\t\t     i);\n\t\t\tgoto bad;\n\t\t}\n\n\t\tif (ocfs2_resv_end(resv) >= resmap->m_bitmap_len) {\n\t\t\tmlog(ML_ERROR, \"reservation %d extends past bitmap!\\n\",\n\t\t\t     i);\n\t\t\tgoto bad;\n\t\t}\n\n\t\tif (ocfs2_validate_resmap_bits(resmap, i, resv))\n\t\t\tgoto bad;\n\n\t\toff = ocfs2_resv_end(resv);\n\t\tnode = rb_next(node);\n\n\t\ti++;\n\t}\n\treturn;\n\nbad:\n\tocfs2_dump_resv(resmap);\n\tBUG();\n}\n#else\nstatic inline void ocfs2_check_resmap(struct ocfs2_reservation_map *resmap)\n{\n\n}\n#endif\n\nvoid ocfs2_resv_init_once(struct ocfs2_alloc_reservation *resv)\n{\n\tmemset(resv, 0, sizeof(*resv));\n\tINIT_LIST_HEAD(&resv->r_lru);\n}\n\nvoid ocfs2_resv_set_type(struct ocfs2_alloc_reservation *resv,\n\t\t\t unsigned int flags)\n{\n\tBUG_ON(flags & ~OCFS2_RESV_TYPES);\n\n\tresv->r_flags |= flags;\n}\n\nvoid ocfs2_resmap_init(struct ocfs2_super *osb,\n\t\t      struct ocfs2_reservation_map *resmap)\n{\n\tmemset(resmap, 0, sizeof(*resmap));\n\n\tresmap->m_osb = osb;\n\tresmap->m_reservations = RB_ROOT;\n\t \n\tINIT_LIST_HEAD(&resmap->m_lru);\n}\n\nstatic void ocfs2_resv_mark_lru(struct ocfs2_reservation_map *resmap,\n\t\t\t\tstruct ocfs2_alloc_reservation *resv)\n{\n\tassert_spin_locked(&resv_lock);\n\n\tif (!list_empty(&resv->r_lru))\n\t\tlist_del_init(&resv->r_lru);\n\n\tlist_add_tail(&resv->r_lru, &resmap->m_lru);\n}\n\nstatic void __ocfs2_resv_trunc(struct ocfs2_alloc_reservation *resv)\n{\n\tresv->r_len = 0;\n\tresv->r_start = 0;\n}\n\nstatic void ocfs2_resv_remove(struct ocfs2_reservation_map *resmap,\n\t\t\t      struct ocfs2_alloc_reservation *resv)\n{\n\tif (resv->r_flags & OCFS2_RESV_FLAG_INUSE) {\n\t\tlist_del_init(&resv->r_lru);\n\t\trb_erase(&resv->r_node, &resmap->m_reservations);\n\t\tresv->r_flags &= ~OCFS2_RESV_FLAG_INUSE;\n\t}\n}\n\nstatic void __ocfs2_resv_discard(struct ocfs2_reservation_map *resmap,\n\t\t\t\t struct ocfs2_alloc_reservation *resv)\n{\n\tassert_spin_locked(&resv_lock);\n\n\t__ocfs2_resv_trunc(resv);\n\t \n\tresv->r_last_len = resv->r_last_start = 0;\n\n\tocfs2_resv_remove(resmap, resv);\n}\n\n \nvoid ocfs2_resv_discard(struct ocfs2_reservation_map *resmap,\n\t\t\tstruct ocfs2_alloc_reservation *resv)\n{\n\tif (resv) {\n\t\tspin_lock(&resv_lock);\n\t\t__ocfs2_resv_discard(resmap, resv);\n\t\tspin_unlock(&resv_lock);\n\t}\n}\n\nstatic void ocfs2_resmap_clear_all_resv(struct ocfs2_reservation_map *resmap)\n{\n\tstruct rb_node *node;\n\tstruct ocfs2_alloc_reservation *resv;\n\n\tassert_spin_locked(&resv_lock);\n\n\twhile ((node = rb_last(&resmap->m_reservations)) != NULL) {\n\t\tresv = rb_entry(node, struct ocfs2_alloc_reservation, r_node);\n\n\t\t__ocfs2_resv_discard(resmap, resv);\n\t}\n}\n\nvoid ocfs2_resmap_restart(struct ocfs2_reservation_map *resmap,\n\t\t\t  unsigned int clen, char *disk_bitmap)\n{\n\tif (ocfs2_resmap_disabled(resmap))\n\t\treturn;\n\n\tspin_lock(&resv_lock);\n\n\tocfs2_resmap_clear_all_resv(resmap);\n\tresmap->m_bitmap_len = clen;\n\tresmap->m_disk_bitmap = disk_bitmap;\n\n\tspin_unlock(&resv_lock);\n}\n\nvoid ocfs2_resmap_uninit(struct ocfs2_reservation_map *resmap)\n{\n\t \n}\n\nstatic void ocfs2_resv_insert(struct ocfs2_reservation_map *resmap,\n\t\t\t      struct ocfs2_alloc_reservation *new)\n{\n\tstruct rb_root *root = &resmap->m_reservations;\n\tstruct rb_node *parent = NULL;\n\tstruct rb_node **p = &root->rb_node;\n\tstruct ocfs2_alloc_reservation *tmp;\n\n\tassert_spin_locked(&resv_lock);\n\n\ttrace_ocfs2_resv_insert(new->r_start, new->r_len);\n\n\twhile (*p) {\n\t\tparent = *p;\n\n\t\ttmp = rb_entry(parent, struct ocfs2_alloc_reservation, r_node);\n\n\t\tif (new->r_start < tmp->r_start) {\n\t\t\tp = &(*p)->rb_left;\n\n\t\t\t \n\t\t\tBUG_ON(ocfs2_resv_end(new) >= tmp->r_start);\n\t\t} else if (new->r_start > ocfs2_resv_end(tmp)) {\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\t \n\t\t\tmlog(ML_ERROR, \"Duplicate reservation window!\\n\");\n\t\t\tBUG();\n\t\t}\n\t}\n\n\trb_link_node(&new->r_node, parent, p);\n\trb_insert_color(&new->r_node, root);\n\tnew->r_flags |= OCFS2_RESV_FLAG_INUSE;\n\n\tocfs2_resv_mark_lru(resmap, new);\n\n\tocfs2_check_resmap(resmap);\n}\n\n \nstatic struct ocfs2_alloc_reservation *\nocfs2_find_resv_lhs(struct ocfs2_reservation_map *resmap, unsigned int goal)\n{\n\tstruct ocfs2_alloc_reservation *resv = NULL;\n\tstruct ocfs2_alloc_reservation *prev_resv = NULL;\n\tstruct rb_node *node = resmap->m_reservations.rb_node;\n\n\tassert_spin_locked(&resv_lock);\n\n\tif (!node)\n\t\treturn NULL;\n\n\tnode = rb_first(&resmap->m_reservations);\n\twhile (node) {\n\t\tresv = rb_entry(node, struct ocfs2_alloc_reservation, r_node);\n\n\t\tif (resv->r_start <= goal && ocfs2_resv_end(resv) >= goal)\n\t\t\tbreak;\n\n\t\t \n\t\tif (resv->r_start > goal) {\n\t\t\tresv = prev_resv;\n\t\t\tbreak;\n\t\t}\n\n\t\tprev_resv = resv;\n\t\tnode = rb_next(node);\n\t}\n\n\treturn resv;\n}\n\n \nstatic int ocfs2_resmap_find_free_bits(struct ocfs2_reservation_map *resmap,\n\t\t\t\t       unsigned int wanted,\n\t\t\t\t       unsigned int search_start,\n\t\t\t\t       unsigned int search_len,\n\t\t\t\t       unsigned int *rstart,\n\t\t\t\t       unsigned int *rlen)\n{\n\tvoid *bitmap = resmap->m_disk_bitmap;\n\tunsigned int best_start, best_len = 0;\n\tint offset, start, found;\n\n\ttrace_ocfs2_resmap_find_free_bits_begin(search_start, search_len,\n\t\t\t\t\t\twanted, resmap->m_bitmap_len);\n\n\tfound = best_start = best_len = 0;\n\n\tstart = search_start;\n\twhile ((offset = ocfs2_find_next_zero_bit(bitmap, resmap->m_bitmap_len,\n\t\t\t\t\t\t start)) != -1) {\n\t\t \n\t\tif (offset >= (search_start + search_len))\n\t\t\tbreak;\n\n\t\tif (offset == start) {\n\t\t\t \n\t\t\tfound++;\n\t\t\t \n\t\t\tstart++;\n\t\t} else {\n\t\t\t \n\t\t\tfound = 1;\n\t\t\tstart = offset + 1;\n\t\t}\n\t\tif (found > best_len) {\n\t\t\tbest_len = found;\n\t\t\tbest_start = start - found;\n\t\t}\n\n\t\tif (found >= wanted)\n\t\t\tbreak;\n\t}\n\n\tif (best_len == 0)\n\t\treturn 0;\n\n\tif (best_len >= wanted)\n\t\tbest_len = wanted;\n\n\t*rlen = best_len;\n\t*rstart = best_start;\n\n\ttrace_ocfs2_resmap_find_free_bits_end(best_start, best_len);\n\n\treturn *rlen;\n}\n\nstatic void __ocfs2_resv_find_window(struct ocfs2_reservation_map *resmap,\n\t\t\t\t     struct ocfs2_alloc_reservation *resv,\n\t\t\t\t     unsigned int goal, unsigned int wanted)\n{\n\tstruct rb_root *root = &resmap->m_reservations;\n\tunsigned int gap_start, gap_end, gap_len;\n\tstruct ocfs2_alloc_reservation *prev_resv, *next_resv;\n\tstruct rb_node *prev, *next;\n\tunsigned int cstart, clen;\n\tunsigned int best_start = 0, best_len = 0;\n\n\t \n\ttrace_ocfs2_resv_find_window_begin(resv->r_start, ocfs2_resv_end(resv),\n\t\t\t\t\t   goal, wanted, RB_EMPTY_ROOT(root));\n\n\tassert_spin_locked(&resv_lock);\n\n\tif (RB_EMPTY_ROOT(root)) {\n\t\t \n\t\tclen = ocfs2_resmap_find_free_bits(resmap, wanted, goal,\n\t\t\t\t\t\t   resmap->m_bitmap_len - goal,\n\t\t\t\t\t\t   &cstart, &clen);\n\n\t\t \n\t\tBUG_ON(goal == 0 && clen == 0);\n\n\t\tif (clen == 0)\n\t\t\treturn;\n\n\t\tresv->r_start = cstart;\n\t\tresv->r_len = clen;\n\n\t\tocfs2_resv_insert(resmap, resv);\n\t\treturn;\n\t}\n\n\tprev_resv = ocfs2_find_resv_lhs(resmap, goal);\n\n\tif (prev_resv == NULL) {\n\t\t \n\n\t\tnext = rb_first(root);\n\t\tnext_resv = rb_entry(next, struct ocfs2_alloc_reservation,\n\t\t\t\t     r_node);\n\n\t\t \n\t\tif (next_resv->r_start <= goal) {\n\t\t\tmlog(ML_ERROR, \"goal: %u next_resv: start %u len %u\\n\",\n\t\t\t     goal, next_resv->r_start, next_resv->r_len);\n\t\t\tocfs2_dump_resv(resmap);\n\t\t\tBUG();\n\t\t}\n\n\t\tclen = ocfs2_resmap_find_free_bits(resmap, wanted, goal,\n\t\t\t\t\t\t   next_resv->r_start - goal,\n\t\t\t\t\t\t   &cstart, &clen);\n\t\tif (clen) {\n\t\t\tbest_len = clen;\n\t\t\tbest_start = cstart;\n\t\t\tif (best_len == wanted)\n\t\t\t\tgoto out_insert;\n\t\t}\n\n\t\tprev_resv = next_resv;\n\t\tnext_resv = NULL;\n\t}\n\n\ttrace_ocfs2_resv_find_window_prev(prev_resv->r_start,\n\t\t\t\t\t  ocfs2_resv_end(prev_resv));\n\n\tprev = &prev_resv->r_node;\n\n\t \n\twhile (1) {\n\t\tnext = rb_next(prev);\n\t\tif (next) {\n\t\t\tnext_resv = rb_entry(next,\n\t\t\t\t\t     struct ocfs2_alloc_reservation,\n\t\t\t\t\t     r_node);\n\n\t\t\tgap_start = ocfs2_resv_end(prev_resv) + 1;\n\t\t\tgap_end = next_resv->r_start - 1;\n\t\t\tgap_len = gap_end - gap_start + 1;\n\t\t} else {\n\t\t\t \n\t\t\tgap_start = ocfs2_resv_end(prev_resv) + 1;\n\t\t\tgap_len = resmap->m_bitmap_len - gap_start;\n\t\t\tgap_end = resmap->m_bitmap_len - 1;\n\t\t}\n\n\t\ttrace_ocfs2_resv_find_window_next(next ? next_resv->r_start: -1,\n\t\t\t\t\tnext ? ocfs2_resv_end(next_resv) : -1);\n\t\t \n\t\tif (gap_len <= best_len)\n\t\t\tgoto next_resv;\n\n\t\tclen = ocfs2_resmap_find_free_bits(resmap, wanted, gap_start,\n\t\t\t\t\t\t   gap_len, &cstart, &clen);\n\t\tif (clen == wanted) {\n\t\t\tbest_len = clen;\n\t\t\tbest_start = cstart;\n\t\t\tgoto out_insert;\n\t\t} else if (clen > best_len) {\n\t\t\tbest_len = clen;\n\t\t\tbest_start = cstart;\n\t\t}\n\nnext_resv:\n\t\tif (!next)\n\t\t\tbreak;\n\n\t\tprev = next;\n\t\tprev_resv = rb_entry(prev, struct ocfs2_alloc_reservation,\n\t\t\t\t     r_node);\n\t}\n\nout_insert:\n\tif (best_len) {\n\t\tresv->r_start = best_start;\n\t\tresv->r_len = best_len;\n\t\tocfs2_resv_insert(resmap, resv);\n\t}\n}\n\nstatic void ocfs2_cannibalize_resv(struct ocfs2_reservation_map *resmap,\n\t\t\t\t   struct ocfs2_alloc_reservation *resv,\n\t\t\t\t   unsigned int wanted)\n{\n\tstruct ocfs2_alloc_reservation *lru_resv;\n\tint tmpwindow = !!(resv->r_flags & OCFS2_RESV_FLAG_TMP);\n\tunsigned int min_bits;\n\n\tif (!tmpwindow)\n\t\tmin_bits = ocfs2_resv_window_bits(resmap, resv) >> 1;\n\telse\n\t\tmin_bits = wanted;  \n\n\t \n\tlru_resv = list_first_entry(&resmap->m_lru,\n\t\t\t\t    struct ocfs2_alloc_reservation, r_lru);\n\n\ttrace_ocfs2_cannibalize_resv_begin(lru_resv->r_start,\n\t\t\t\t\t   lru_resv->r_len,\n\t\t\t\t\t   ocfs2_resv_end(lru_resv));\n\n\t \n\tif (lru_resv->r_len <= min_bits) {\n\t\t \n\t\tresv->r_start = lru_resv->r_start;\n\t\tresv->r_len = lru_resv->r_len;\n\n\t\t__ocfs2_resv_discard(resmap, lru_resv);\n\t} else {\n\t\tunsigned int shrink;\n\t\tif (tmpwindow)\n\t\t\tshrink = min_bits;\n\t\telse\n\t\t\tshrink = lru_resv->r_len / 2;\n\n\t\tlru_resv->r_len -= shrink;\n\n\t\tresv->r_start = ocfs2_resv_end(lru_resv) + 1;\n\t\tresv->r_len = shrink;\n\t}\n\n\ttrace_ocfs2_cannibalize_resv_end(resv->r_start, ocfs2_resv_end(resv),\n\t\t\t\t\t resv->r_len, resv->r_last_start,\n\t\t\t\t\t resv->r_last_len);\n\n\tocfs2_resv_insert(resmap, resv);\n}\n\nstatic void ocfs2_resv_find_window(struct ocfs2_reservation_map *resmap,\n\t\t\t\t   struct ocfs2_alloc_reservation *resv,\n\t\t\t\t   unsigned int wanted)\n{\n\tunsigned int goal = 0;\n\n\tBUG_ON(!ocfs2_resv_empty(resv));\n\n\t \n\tif (resv->r_last_len) {\n\t\tgoal = resv->r_last_start + resv->r_last_len;\n\t\tif (goal >= resmap->m_bitmap_len)\n\t\t\tgoal = 0;\n\t}\n\n\t__ocfs2_resv_find_window(resmap, resv, goal, wanted);\n\n\t \n\tif (ocfs2_resv_empty(resv) && goal != 0)\n\t\t__ocfs2_resv_find_window(resmap, resv, 0, wanted);\n\n\tif (ocfs2_resv_empty(resv)) {\n\t\t \n\t\tocfs2_cannibalize_resv(resmap, resv, wanted);\n\t}\n\n\tBUG_ON(ocfs2_resv_empty(resv));\n}\n\nint ocfs2_resmap_resv_bits(struct ocfs2_reservation_map *resmap,\n\t\t\t   struct ocfs2_alloc_reservation *resv,\n\t\t\t   int *cstart, int *clen)\n{\n\tif (resv == NULL || ocfs2_resmap_disabled(resmap))\n\t\treturn -ENOSPC;\n\n\tspin_lock(&resv_lock);\n\n\tif (ocfs2_resv_empty(resv)) {\n\t\t \n\t\tunsigned int wanted = ocfs2_resv_window_bits(resmap, resv);\n\n\t\tif ((resv->r_flags & OCFS2_RESV_FLAG_TMP) || wanted < *clen)\n\t\t\twanted = *clen;\n\n\t\t \n\t\tocfs2_resv_find_window(resmap, resv, wanted);\n\t\ttrace_ocfs2_resmap_resv_bits(resv->r_start, resv->r_len);\n\t}\n\n\tBUG_ON(ocfs2_resv_empty(resv));\n\n\t*cstart = resv->r_start;\n\t*clen = resv->r_len;\n\n\tspin_unlock(&resv_lock);\n\treturn 0;\n}\n\nstatic void\n\tocfs2_adjust_resv_from_alloc(struct ocfs2_reservation_map *resmap,\n\t\t\t\t     struct ocfs2_alloc_reservation *resv,\n\t\t\t\t     unsigned int start, unsigned int end)\n{\n\tunsigned int rhs = 0;\n\tunsigned int old_end = ocfs2_resv_end(resv);\n\n\tBUG_ON(start != resv->r_start || old_end < end);\n\n\t \n\tif (old_end == end) {\n\t\t__ocfs2_resv_discard(resmap, resv);\n\t\treturn;\n\t}\n\n\trhs = old_end - end;\n\n\t \n\tBUG_ON(rhs == 0);\n\n\tresv->r_start = end + 1;\n\tresv->r_len = old_end - resv->r_start + 1;\n}\n\nvoid ocfs2_resmap_claimed_bits(struct ocfs2_reservation_map *resmap,\n\t\t\t       struct ocfs2_alloc_reservation *resv,\n\t\t\t       u32 cstart, u32 clen)\n{\n\tunsigned int cend = cstart + clen - 1;\n\n\tif (resmap == NULL || ocfs2_resmap_disabled(resmap))\n\t\treturn;\n\n\tif (resv == NULL)\n\t\treturn;\n\n\tBUG_ON(cstart != resv->r_start);\n\n\tspin_lock(&resv_lock);\n\n\ttrace_ocfs2_resmap_claimed_bits_begin(cstart, cend, clen, resv->r_start,\n\t\t\t\t\t      ocfs2_resv_end(resv), resv->r_len,\n\t\t\t\t\t      resv->r_last_start,\n\t\t\t\t\t      resv->r_last_len);\n\n\tBUG_ON(cstart < resv->r_start);\n\tBUG_ON(cstart > ocfs2_resv_end(resv));\n\tBUG_ON(cend > ocfs2_resv_end(resv));\n\n\tocfs2_adjust_resv_from_alloc(resmap, resv, cstart, cend);\n\tresv->r_last_start = cstart;\n\tresv->r_last_len = clen;\n\n\t \n\tif (!ocfs2_resv_empty(resv))\n\t\tocfs2_resv_mark_lru(resmap, resv);\n\n\ttrace_ocfs2_resmap_claimed_bits_end(resv->r_start, ocfs2_resv_end(resv),\n\t\t\t\t\t    resv->r_len, resv->r_last_start,\n\t\t\t\t\t    resv->r_last_len);\n\n\tocfs2_check_resmap(resmap);\n\n\tspin_unlock(&resv_lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}