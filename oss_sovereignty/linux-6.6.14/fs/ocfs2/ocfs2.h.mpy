{
  "module_name": "ocfs2.h",
  "hash_id": "eaf2e760e2f904758dec6c7ff27d8f0500077a5f2ce1f1568b8893e30acda98a",
  "original_prompt": "Ingested from linux-6.6.14/fs/ocfs2/ocfs2.h",
  "human_readable_source": " \n \n\n#ifndef OCFS2_H\n#define OCFS2_H\n\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/llist.h>\n#include <linux/rbtree.h>\n#include <linux/workqueue.h>\n#include <linux/kref.h>\n#include <linux/mutex.h>\n#include <linux/lockdep.h>\n#include <linux/jbd2.h>\n\n \n#include \"stackglue.h\"\n\n#include \"ocfs2_fs.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_ioctl.h\"\n\n \n#include \"blockcheck.h\"\n\n#include \"reservations.h\"\n\n#include \"filecheck.h\"\n\n \n\n \n#define OCFS2_CACHE_INFO_MAX_ARRAY 2\n\n \n\nenum ocfs2_caching_info_flags {\n\t \n\tOCFS2_CACHE_FL_INLINE\t= 1<<1,\n};\n\nstruct ocfs2_caching_operations;\nstruct ocfs2_caching_info {\n\t \n\tconst struct ocfs2_caching_operations *ci_ops;\n\n\t \n\t \n\tunsigned long\t\tci_created_trans;\n\t \n\tunsigned long\t\tci_last_trans;\n\n\t \n\tunsigned int\t\tci_flags;\n\tunsigned int\t\tci_num_cached;\n\tunion {\n\tsector_t\tci_array[OCFS2_CACHE_INFO_MAX_ARRAY];\n\t\tstruct rb_root\tci_tree;\n\t} ci_cache;\n};\n \nstruct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci);\n\n \n#define OCFS2_NODE_MAP_MAX_NODES    256\nstruct ocfs2_node_map {\n\tu16 num_nodes;\n\tunsigned long map[BITS_TO_LONGS(OCFS2_NODE_MAP_MAX_NODES)];\n};\n\nenum ocfs2_ast_action {\n\tOCFS2_AST_INVALID = 0,\n\tOCFS2_AST_ATTACH,\n\tOCFS2_AST_CONVERT,\n\tOCFS2_AST_DOWNCONVERT,\n};\n\n \nenum ocfs2_unlock_action {\n\tOCFS2_UNLOCK_INVALID = 0,\n\tOCFS2_UNLOCK_CANCEL_CONVERT,\n\tOCFS2_UNLOCK_DROP_LOCK,\n};\n\n \n#define OCFS2_LOCK_ATTACHED      (0x00000001)  \n#define OCFS2_LOCK_BUSY          (0x00000002)  \n#define OCFS2_LOCK_BLOCKED       (0x00000004)  \n#define OCFS2_LOCK_LOCAL         (0x00000008)  \n#define OCFS2_LOCK_NEEDS_REFRESH (0x00000010)\n#define OCFS2_LOCK_REFRESHING    (0x00000020)\n#define OCFS2_LOCK_INITIALIZED   (0x00000040)  \n#define OCFS2_LOCK_FREEING       (0x00000080)  \n#define OCFS2_LOCK_QUEUED        (0x00000100)  \n#define OCFS2_LOCK_NOCACHE       (0x00000200)  \n#define OCFS2_LOCK_PENDING       (0x00000400)  \n#define OCFS2_LOCK_UPCONVERT_FINISHING (0x00000800)  \n\n#define OCFS2_LOCK_NONBLOCK_FINISHED (0x00001000)  \n\nstruct ocfs2_lock_res_ops;\n\ntypedef void (*ocfs2_lock_callback)(int status, unsigned long data);\n\n#ifdef CONFIG_OCFS2_FS_STATS\nstruct ocfs2_lock_stats {\n\tu64\t\tls_total;\t \n\tu32\t\tls_gets;\t \n\tu32\t\tls_fail;\t \n\n\t \n\tu32\t\tls_max;\t\t \n\tu64\t\tls_last;\t \n};\n#endif\n\nstruct ocfs2_lock_res {\n\tvoid                    *l_priv;\n\tstruct ocfs2_lock_res_ops *l_ops;\n\n\n\tstruct list_head         l_blocked_list;\n\tstruct list_head         l_mask_waiters;\n\tstruct list_head\t l_holders;\n\n\tunsigned long\t\t l_flags;\n\tchar                     l_name[OCFS2_LOCK_ID_MAX_LEN];\n\tunsigned int             l_ro_holders;\n\tunsigned int             l_ex_holders;\n\tsigned char\t\t l_level;\n\tsigned char\t\t l_requested;\n\tsigned char\t\t l_blocking;\n\n\t \n\tunsigned char            l_type;\n\n\t \n\t \n\tunsigned char            l_action;\n\t \n\tunsigned char            l_unlock_action;\n\tunsigned int             l_pending_gen;\n\n\tspinlock_t               l_lock;\n\n\tstruct ocfs2_dlm_lksb    l_lksb;\n\n\twait_queue_head_t        l_event;\n\n\tstruct list_head         l_debug_list;\n\n#ifdef CONFIG_OCFS2_FS_STATS\n\tstruct ocfs2_lock_stats  l_lock_prmode;\t\t \n\tu32                      l_lock_refresh;\t \n\tu64                      l_lock_wait;\t \n\tstruct ocfs2_lock_stats  l_lock_exmode;\t\t \n#endif\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tstruct lockdep_map\t l_lockdep_map;\n#endif\n};\n\nenum ocfs2_orphan_reco_type {\n\tORPHAN_NO_NEED_TRUNCATE = 0,\n\tORPHAN_NEED_TRUNCATE,\n};\n\nenum ocfs2_orphan_scan_state {\n\tORPHAN_SCAN_ACTIVE,\n\tORPHAN_SCAN_INACTIVE\n};\n\nstruct ocfs2_orphan_scan {\n\tstruct mutex \t\tos_lock;\n\tstruct ocfs2_super \t*os_osb;\n\tstruct ocfs2_lock_res \tos_lockres;      \n\tstruct delayed_work \tos_orphan_scan_work;\n\ttime64_t\t\tos_scantime;   \n\tu32\t\t\tos_count;       \n\tu32  \t\t\tos_seqno;        \n\tatomic_t\t\tos_state;               \n};\n\nstruct ocfs2_dlm_debug {\n\tstruct kref d_refcnt;\n\tu32 d_filter_secs;\n\tstruct list_head d_lockres_tracking;\n};\n\nenum ocfs2_vol_state\n{\n\tVOLUME_INIT = 0,\n\tVOLUME_MOUNTED,\n\tVOLUME_MOUNTED_QUOTAS,\n\tVOLUME_DISMOUNTED,\n\tVOLUME_DISABLED\n};\n\nstruct ocfs2_alloc_stats\n{\n\tatomic_t moves;\n\tatomic_t local_data;\n\tatomic_t bitmap_data;\n\tatomic_t bg_allocs;\n\tatomic_t bg_extends;\n};\n\nenum ocfs2_local_alloc_state\n{\n\tOCFS2_LA_UNUSED = 0,\t \n\tOCFS2_LA_ENABLED,\t \n\tOCFS2_LA_THROTTLED,\t \n\tOCFS2_LA_DISABLED\t \n};\n\nenum ocfs2_mount_options\n{\n\tOCFS2_MOUNT_HB_LOCAL = 1 << 0,  \n\tOCFS2_MOUNT_BARRIER = 1 << 1,\t \n\tOCFS2_MOUNT_NOINTR  = 1 << 2,    \n\tOCFS2_MOUNT_ERRORS_PANIC = 1 << 3,  \n\tOCFS2_MOUNT_DATA_WRITEBACK = 1 << 4,  \n\tOCFS2_MOUNT_LOCALFLOCKS = 1 << 5,  \n\tOCFS2_MOUNT_NOUSERXATTR = 1 << 6,  \n\tOCFS2_MOUNT_INODE64 = 1 << 7,\t \n\tOCFS2_MOUNT_POSIX_ACL = 1 << 8,\t \n\tOCFS2_MOUNT_NO_POSIX_ACL = 1 << 9,\t \n\tOCFS2_MOUNT_USRQUOTA = 1 << 10,  \n\tOCFS2_MOUNT_GRPQUOTA = 1 << 11,  \n\tOCFS2_MOUNT_COHERENCY_BUFFERED = 1 << 12,  \n\tOCFS2_MOUNT_HB_NONE = 1 << 13,  \n\tOCFS2_MOUNT_HB_GLOBAL = 1 << 14,  \n\n\tOCFS2_MOUNT_JOURNAL_ASYNC_COMMIT = 1 << 15,   \n\tOCFS2_MOUNT_ERRORS_CONT = 1 << 16,  \n\tOCFS2_MOUNT_ERRORS_ROFS = 1 << 17,  \n};\n\n#define OCFS2_OSB_SOFT_RO\t0x0001\n#define OCFS2_OSB_HARD_RO\t0x0002\n#define OCFS2_OSB_ERROR_FS\t0x0004\n#define OCFS2_DEFAULT_ATIME_QUANTUM\t60\n\nstruct ocfs2_journal;\nstruct ocfs2_slot_info;\nstruct ocfs2_recovery_map;\nstruct ocfs2_replay_map;\nstruct ocfs2_quota_recovery;\nstruct ocfs2_super\n{\n\tstruct task_struct *commit_task;\n\tstruct super_block *sb;\n\tstruct inode *root_inode;\n\tstruct inode *sys_root_inode;\n\tstruct inode *global_system_inodes[NUM_GLOBAL_SYSTEM_INODES];\n\tstruct inode **local_system_inodes;\n\n\tstruct ocfs2_slot_info *slot_info;\n\n\tu32 *slot_recovery_generations;\n\n\tspinlock_t node_map_lock;\n\n\tu64 root_blkno;\n\tu64 system_dir_blkno;\n\tu64 bitmap_blkno;\n\tu32 bitmap_cpg;\n\tchar *uuid_str;\n\tu32 uuid_hash;\n\tu8 *vol_label;\n\tu64 first_cluster_group_blkno;\n\tu32 fs_generation;\n\n\tu32 s_feature_compat;\n\tu32 s_feature_incompat;\n\tu32 s_feature_ro_compat;\n\n\t \n\tspinlock_t osb_lock;\n\tu32 s_next_generation;\n\tunsigned long osb_flags;\n\tu16 s_inode_steal_slot;\n\tu16 s_meta_steal_slot;\n\tatomic_t s_num_inodes_stolen;\n\tatomic_t s_num_meta_stolen;\n\n\tunsigned long s_mount_opt;\n\tunsigned int s_atime_quantum;\n\n\tunsigned int max_slots;\n\tunsigned int node_num;\n\tint slot_num;\n\tint preferred_slot;\n\tint s_sectsize_bits;\n\tint s_clustersize;\n\tint s_clustersize_bits;\n\tunsigned int s_xattr_inline_size;\n\n\tatomic_t vol_state;\n\tstruct mutex recovery_lock;\n\tstruct ocfs2_recovery_map *recovery_map;\n\tstruct ocfs2_replay_map *replay_map;\n\tstruct task_struct *recovery_thread_task;\n\tint disable_recovery;\n\twait_queue_head_t checkpoint_event;\n\tstruct ocfs2_journal *journal;\n\tunsigned long osb_commit_interval;\n\n\tstruct delayed_work\t\tla_enable_wq;\n\n\t \n\tunsigned int local_alloc_bits;\n\tunsigned int local_alloc_default_bits;\n\t \n\tunsigned int osb_clusters_at_boot;\n\n\tenum ocfs2_local_alloc_state local_alloc_state;  \n\n\tstruct buffer_head *local_alloc_bh;\n\n\tu64 la_last_gd;\n\n\tstruct ocfs2_reservation_map\tosb_la_resmap;\n\n\tunsigned int\tosb_resv_level;\n\tunsigned int\tosb_dir_resv_level;\n\n\t \n\tstruct ocfs2_dinode *local_alloc_copy;\n\tstruct ocfs2_quota_recovery *quota_rec;\n\n\tstruct ocfs2_blockcheck_stats osb_ecc_stats;\n\tstruct ocfs2_alloc_stats alloc_stats;\n\tchar dev_str[20];\t\t \n\n\tu8 osb_stackflags;\n\n\tchar osb_cluster_stack[OCFS2_STACK_LABEL_LEN + 1];\n\tchar osb_cluster_name[OCFS2_CLUSTER_NAME_LEN + 1];\n\tstruct ocfs2_cluster_connection *cconn;\n\tstruct ocfs2_lock_res osb_super_lockres;\n\tstruct ocfs2_lock_res osb_rename_lockres;\n\tstruct ocfs2_lock_res osb_nfs_sync_lockres;\n\tstruct rw_semaphore nfs_sync_rwlock;\n\tstruct ocfs2_lock_res osb_trim_fs_lockres;\n\tstruct mutex obs_trim_fs_mutex;\n\tstruct ocfs2_dlm_debug *osb_dlm_debug;\n\n\tstruct dentry *osb_debug_root;\n\n\twait_queue_head_t recovery_event;\n\n\tspinlock_t dc_task_lock;\n\tstruct task_struct *dc_task;\n\twait_queue_head_t dc_event;\n\tunsigned long dc_wake_sequence;\n\tunsigned long dc_work_sequence;\n\n\t \n\tstruct list_head blocked_lock_list;\n\tunsigned long blocked_lock_count;\n\n\t \n\tstruct llist_head dquot_drop_list;\n\tstruct work_struct dquot_drop_work;\n\n\twait_queue_head_t\t\tosb_mount_event;\n\n\t \n\tstruct inode\t\t\t*osb_tl_inode;\n\tstruct buffer_head\t\t*osb_tl_bh;\n\tstruct delayed_work\t\tosb_truncate_log_wq;\n\tatomic_t\t\t\tosb_tl_disable;\n\t \n\tunsigned int truncated_clusters;\n\n\tstruct ocfs2_node_map\t\tosb_recovering_orphan_dirs;\n\tunsigned int\t\t\t*osb_orphan_wipes;\n\twait_queue_head_t\t\tosb_wipe_event;\n\n\tstruct ocfs2_orphan_scan\tosb_orphan_scan;\n\n\t \n\tspinlock_t osb_xattr_lock;\n\n\tunsigned int\t\t\tosb_dx_mask;\n\tu32\t\t\t\tosb_dx_seed[4];\n\n\t \n\tu64\t\t\t\tosb_inode_alloc_group;\n\n\t \n\tstruct rb_root\tosb_rf_lock_tree;\n\tstruct ocfs2_refcount_tree *osb_ref_tree_lru;\n\n\tstruct mutex system_file_mutex;\n\n\t \n\tstruct workqueue_struct *ocfs2_wq;\n\n\t \n\tstruct kset *osb_dev_kset;\n\n\t \n\tstruct ocfs2_filecheck_sysfs_entry osb_fc_ent;\n};\n\n#define OCFS2_SB(sb)\t    ((struct ocfs2_super *)(sb)->s_fs_info)\n\n \ntypedef int (*ocfs2_journal_access_func)(handle_t *handle,\n\t\t\t\t\t struct ocfs2_caching_info *ci,\n\t\t\t\t\t struct buffer_head *bh, int type);\n\nstatic inline int ocfs2_should_order_data(struct inode *inode)\n{\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 0;\n\tif (OCFS2_SB(inode->i_sb)->s_mount_opt & OCFS2_MOUNT_DATA_WRITEBACK)\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic inline int ocfs2_sparse_alloc(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_SPARSE_ALLOC)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic inline int ocfs2_writes_unwritten_extents(struct ocfs2_super *osb)\n{\n\t \n\tif (!ocfs2_sparse_alloc(osb))\n\t\treturn 0;\n\n\tif (osb->s_feature_ro_compat & OCFS2_FEATURE_RO_COMPAT_UNWRITTEN)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic inline int ocfs2_supports_append_dio(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_APPEND_DIO)\n\t\treturn 1;\n\treturn 0;\n}\n\n\nstatic inline int ocfs2_supports_inline_data(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_INLINE_DATA)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic inline int ocfs2_supports_xattr(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_XATTR)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic inline int ocfs2_meta_ecc(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_META_ECC)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic inline int ocfs2_supports_indexed_dirs(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_INDEXED_DIRS)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic inline int ocfs2_supports_discontig_bg(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_DISCONTIG_BG)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic inline unsigned int ocfs2_link_max(struct ocfs2_super *osb)\n{\n\tif (ocfs2_supports_indexed_dirs(osb))\n\t\treturn OCFS2_DX_LINK_MAX;\n\treturn OCFS2_LINK_MAX;\n}\n\nstatic inline unsigned int ocfs2_read_links_count(struct ocfs2_dinode *di)\n{\n\tu32 nlink = le16_to_cpu(di->i_links_count);\n\tu32 hi = le16_to_cpu(di->i_links_count_hi);\n\n\tnlink |= (hi << OCFS2_LINKS_HI_SHIFT);\n\n\treturn nlink;\n}\n\nstatic inline void ocfs2_set_links_count(struct ocfs2_dinode *di, u32 nlink)\n{\n\tu16 lo, hi;\n\n\tlo = nlink;\n\thi = nlink >> OCFS2_LINKS_HI_SHIFT;\n\n\tdi->i_links_count = cpu_to_le16(lo);\n\tdi->i_links_count_hi = cpu_to_le16(hi);\n}\n\nstatic inline void ocfs2_add_links_count(struct ocfs2_dinode *di, int n)\n{\n\tu32 links = ocfs2_read_links_count(di);\n\n\tlinks += n;\n\n\tocfs2_set_links_count(di, links);\n}\n\nstatic inline int ocfs2_refcount_tree(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_REFCOUNT_TREE)\n\t\treturn 1;\n\treturn 0;\n}\n\n \nstatic inline void ocfs2_set_osb_flag(struct ocfs2_super *osb,\n\t\t\t\t      unsigned long flag)\n{\n\tspin_lock(&osb->osb_lock);\n\tosb->osb_flags |= flag;\n\tspin_unlock(&osb->osb_lock);\n}\n\nstatic inline void ocfs2_set_ro_flag(struct ocfs2_super *osb,\n\t\t\t\t     int hard)\n{\n\tspin_lock(&osb->osb_lock);\n\tosb->osb_flags &= ~(OCFS2_OSB_SOFT_RO|OCFS2_OSB_HARD_RO);\n\tif (hard)\n\t\tosb->osb_flags |= OCFS2_OSB_HARD_RO;\n\telse\n\t\tosb->osb_flags |= OCFS2_OSB_SOFT_RO;\n\tspin_unlock(&osb->osb_lock);\n}\n\nstatic inline int ocfs2_is_hard_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_HARD_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}\n\nstatic inline int ocfs2_is_soft_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_SOFT_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}\n\nstatic inline int ocfs2_clusterinfo_valid(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat &\n\t\t(OCFS2_FEATURE_INCOMPAT_USERSPACE_STACK |\n\t\t OCFS2_FEATURE_INCOMPAT_CLUSTERINFO));\n}\n\nstatic inline int ocfs2_userspace_stack(struct ocfs2_super *osb)\n{\n\tif (ocfs2_clusterinfo_valid(osb) &&\n\t    memcmp(osb->osb_cluster_stack, OCFS2_CLASSIC_CLUSTER_STACK,\n\t\t   OCFS2_STACK_LABEL_LEN))\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic inline int ocfs2_o2cb_stack(struct ocfs2_super *osb)\n{\n\tif (ocfs2_clusterinfo_valid(osb) &&\n\t    !memcmp(osb->osb_cluster_stack, OCFS2_CLASSIC_CLUSTER_STACK,\n\t\t   OCFS2_STACK_LABEL_LEN))\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic inline int ocfs2_cluster_o2cb_global_heartbeat(struct ocfs2_super *osb)\n{\n\treturn ocfs2_o2cb_stack(osb) &&\n\t\t(osb->osb_stackflags & OCFS2_CLUSTER_O2CB_GLOBAL_HEARTBEAT);\n}\n\nstatic inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}\n\nstatic inline int ocfs2_uses_extended_slot_map(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat &\n\t\tOCFS2_FEATURE_INCOMPAT_EXTENDED_SLOT_MAP);\n}\n\n\n#define OCFS2_IS_VALID_DINODE(ptr)\t\t\t\t\t\\\n\t(!strcmp((ptr)->i_signature, OCFS2_INODE_SIGNATURE))\n\n#define OCFS2_IS_VALID_EXTENT_BLOCK(ptr)\t\t\t\t\\\n\t(!strcmp((ptr)->h_signature, OCFS2_EXTENT_BLOCK_SIGNATURE))\n\n#define OCFS2_IS_VALID_GROUP_DESC(ptr)\t\t\t\t\t\\\n\t(!strcmp((ptr)->bg_signature, OCFS2_GROUP_DESC_SIGNATURE))\n\n\n#define OCFS2_IS_VALID_XATTR_BLOCK(ptr)\t\t\t\t\t\\\n\t(!strcmp((ptr)->xb_signature, OCFS2_XATTR_BLOCK_SIGNATURE))\n\n#define OCFS2_IS_VALID_DIR_TRAILER(ptr)\t\t\t\t\t\\\n\t(!strcmp((ptr)->db_signature, OCFS2_DIR_TRAILER_SIGNATURE))\n\n#define OCFS2_IS_VALID_DX_ROOT(ptr)\t\t\t\t\t\\\n\t(!strcmp((ptr)->dr_signature, OCFS2_DX_ROOT_SIGNATURE))\n\n#define OCFS2_IS_VALID_DX_LEAF(ptr)\t\t\t\t\t\\\n\t(!strcmp((ptr)->dl_signature, OCFS2_DX_LEAF_SIGNATURE))\n\n#define OCFS2_IS_VALID_REFCOUNT_BLOCK(ptr)\t\t\t\t\\\n\t(!strcmp((ptr)->rf_signature, OCFS2_REFCOUNT_BLOCK_SIGNATURE))\n\nstatic inline unsigned long ino_from_blkno(struct super_block *sb,\n\t\t\t\t\t   u64 blkno)\n{\n\treturn (unsigned long)(blkno & (u64)ULONG_MAX);\n}\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}\n\nstatic inline u32 ocfs2_clusters_for_blocks(struct super_block *sb,\n\t\tu64 blocks)\n{\n\tint b_to_c_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\t\tsb->s_blocksize_bits;\n\n\tblocks += (1 << b_to_c_bits) - 1;\n\treturn (u32)(blocks >> b_to_c_bits);\n}\n\nstatic inline u32 ocfs2_blocks_to_clusters(struct super_block *sb,\n\t\t\t\t\t   u64 blocks)\n{\n\tint b_to_c_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u32)(blocks >> b_to_c_bits);\n}\n\nstatic inline unsigned int ocfs2_clusters_for_bytes(struct super_block *sb,\n\t\t\t\t\t\t    u64 bytes)\n{\n\tint cl_bits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int clusters;\n\n\tbytes += OCFS2_SB(sb)->s_clustersize - 1;\n\t \n\tclusters = (unsigned int)(bytes >> cl_bits);\n\n\treturn clusters;\n}\n\nstatic inline unsigned int ocfs2_bytes_to_clusters(struct super_block *sb,\n\t\tu64 bytes)\n{\n\tint cl_bits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int clusters;\n\n\tclusters = (unsigned int)(bytes >> cl_bits);\n\treturn clusters;\n}\n\nstatic inline u64 ocfs2_blocks_for_bytes(struct super_block *sb,\n\t\t\t\t\t u64 bytes)\n{\n\tbytes += sb->s_blocksize - 1;\n\treturn bytes >> sb->s_blocksize_bits;\n}\n\nstatic inline u64 ocfs2_clusters_to_bytes(struct super_block *sb,\n\t\t\t\t\t  u32 clusters)\n{\n\treturn (u64)clusters << OCFS2_SB(sb)->s_clustersize_bits;\n}\n\nstatic inline u64 ocfs2_block_to_cluster_start(struct super_block *sb,\n\t\t\t\t\t       u64 blocks)\n{\n\tint bits = OCFS2_SB(sb)->s_clustersize_bits - sb->s_blocksize_bits;\n\tunsigned int clusters;\n\n\tclusters = ocfs2_blocks_to_clusters(sb, blocks);\n\treturn (u64)clusters << bits;\n}\n\nstatic inline u64 ocfs2_align_bytes_to_clusters(struct super_block *sb,\n\t\t\t\t\t\tu64 bytes)\n{\n\tint cl_bits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int clusters;\n\n\tclusters = ocfs2_clusters_for_bytes(sb, bytes);\n\treturn (u64)clusters << cl_bits;\n}\n\nstatic inline u64 ocfs2_align_bytes_to_blocks(struct super_block *sb,\n\t\t\t\t\t      u64 bytes)\n{\n\tu64 blocks;\n\n        blocks = ocfs2_blocks_for_bytes(sb, bytes);\n\treturn blocks << sb->s_blocksize_bits;\n}\n\nstatic inline unsigned long ocfs2_align_bytes_to_sectors(u64 bytes)\n{\n\treturn (unsigned long)((bytes + 511) >> 9);\n}\n\nstatic inline unsigned int ocfs2_page_index_to_clusters(struct super_block *sb,\n\t\t\t\t\t\t\tunsigned long pg_index)\n{\n\tu32 clusters = pg_index;\n\tunsigned int cbits = OCFS2_SB(sb)->s_clustersize_bits;\n\n\tif (unlikely(PAGE_SHIFT > cbits))\n\t\tclusters = pg_index << (PAGE_SHIFT - cbits);\n\telse if (PAGE_SHIFT < cbits)\n\t\tclusters = pg_index >> (cbits - PAGE_SHIFT);\n\n\treturn clusters;\n}\n\n \nstatic inline pgoff_t ocfs2_align_clusters_to_page_index(struct super_block *sb,\n\t\t\t\t\t\t\tu32 clusters)\n{\n\tunsigned int cbits = OCFS2_SB(sb)->s_clustersize_bits;\n        pgoff_t index = clusters;\n\n\tif (PAGE_SHIFT > cbits) {\n\t\tindex = (pgoff_t)clusters >> (PAGE_SHIFT - cbits);\n\t} else if (PAGE_SHIFT < cbits) {\n\t\tindex = (pgoff_t)clusters << (cbits - PAGE_SHIFT);\n\t}\n\n\treturn index;\n}\n\nstatic inline unsigned int ocfs2_pages_per_cluster(struct super_block *sb)\n{\n\tunsigned int cbits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int pages_per_cluster = 1;\n\n\tif (PAGE_SHIFT < cbits)\n\t\tpages_per_cluster = 1 << (cbits - PAGE_SHIFT);\n\n\treturn pages_per_cluster;\n}\n\nstatic inline unsigned int ocfs2_megabytes_to_clusters(struct super_block *sb,\n\t\t\t\t\t\t       unsigned int megs)\n{\n\tBUILD_BUG_ON(OCFS2_MAX_CLUSTERSIZE > 1048576);\n\n\treturn megs << (20 - OCFS2_SB(sb)->s_clustersize_bits);\n}\n\nstatic inline unsigned int ocfs2_clusters_to_megabytes(struct super_block *sb,\n\t\t\t\t\t\t       unsigned int clusters)\n{\n\treturn clusters >> (20 - OCFS2_SB(sb)->s_clustersize_bits);\n}\n\nstatic inline void _ocfs2_set_bit(unsigned int bit, unsigned long *bitmap)\n{\n\t__set_bit_le(bit, bitmap);\n}\n#define ocfs2_set_bit(bit, addr) _ocfs2_set_bit((bit), (unsigned long *)(addr))\n\nstatic inline void _ocfs2_clear_bit(unsigned int bit, unsigned long *bitmap)\n{\n\t__clear_bit_le(bit, bitmap);\n}\n#define ocfs2_clear_bit(bit, addr) _ocfs2_clear_bit((bit), (unsigned long *)(addr))\n\n#define ocfs2_test_bit test_bit_le\n#define ocfs2_find_next_zero_bit find_next_zero_bit_le\n#define ocfs2_find_next_bit find_next_bit_le\n\nstatic inline void *correct_addr_and_bit_unaligned(int *bit, void *addr)\n{\n#if BITS_PER_LONG == 64\n\t*bit += ((unsigned long) addr & 7UL) << 3;\n\taddr = (void *) ((unsigned long) addr & ~7UL);\n#elif BITS_PER_LONG == 32\n\t*bit += ((unsigned long) addr & 3UL) << 3;\n\taddr = (void *) ((unsigned long) addr & ~3UL);\n#else\n#error \"how many bits you are?!\"\n#endif\n\treturn addr;\n}\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}\n\nstatic inline int ocfs2_find_next_zero_bit_unaligned(void *bitmap, int max,\n\t\t\t\t\t\t\tint start)\n{\n\tint fix = 0, ret, tmpmax;\n\tbitmap = correct_addr_and_bit_unaligned(&fix, bitmap);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ocfs2_find_next_zero_bit(bitmap, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}\n\n#endif   \n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}