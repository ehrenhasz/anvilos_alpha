{
  "module_name": "blockcheck.c",
  "hash_id": "a00871959170a4d0dfc7a9ce5976b4b8ec6025eb2546598c5da36671128caded",
  "original_prompt": "Ingested from linux-6.6.14/fs/ocfs2/blockcheck.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/crc32.h>\n#include <linux/buffer_head.h>\n#include <linux/bitops.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <asm/byteorder.h>\n\n#include <cluster/masklog.h>\n\n#include \"ocfs2.h\"\n\n#include \"blockcheck.h\"\n\n\n \n\n\n \nstatic unsigned int calc_code_bit(unsigned int i, unsigned int *p_cache)\n{\n\tunsigned int b, p = 0;\n\n\t \n\tb = i + 1;\n\n\t \n\tif (p_cache)\n\t\tp = *p_cache;\n        b += p;\n\n\t \n\tfor (; (1 << p) < (b + 1); p++)\n\t\tb++;\n\n\tif (p_cache)\n\t\t*p_cache = p;\n\n\treturn b;\n}\n\n \nu32 ocfs2_hamming_encode(u32 parity, void *data, unsigned int d, unsigned int nr)\n{\n\tunsigned int i, b, p = 0;\n\n\tBUG_ON(!d);\n\n\t \n\tfor (i = 0; (i = ocfs2_find_next_bit(data, d, i)) < d; i++)\n\t{\n\t\t \n\t\tb = calc_code_bit(nr + i, &p);\n\n\t\t \n\t\tparity ^= b;\n\t}\n\n\t \n\treturn parity;\n}\n\nu32 ocfs2_hamming_encode_block(void *data, unsigned int blocksize)\n{\n\treturn ocfs2_hamming_encode(0, data, blocksize * 8, 0);\n}\n\n \nvoid ocfs2_hamming_fix(void *data, unsigned int d, unsigned int nr,\n\t\t       unsigned int fix)\n{\n\tunsigned int i, b;\n\n\tBUG_ON(!d);\n\n\t \n\tif (hweight32(fix) == 1)\n\t\treturn;\n\n\t \n\tif (fix >= calc_code_bit(nr + d, NULL))\n\t\treturn;\n\n\t \n\tb = calc_code_bit(nr, NULL);\n\t \n\tif (fix < b)\n\t\treturn;\n\n\tfor (i = 0; i < d; i++, b++)\n\t{\n\t\t \n\t\twhile (hweight32(b) == 1)\n\t\t\tb++;\n\n\t\t \n\t\tif (b == fix)\n\t\t{\n\t\t\tif (ocfs2_test_bit(i, data))\n\t\t\t\tocfs2_clear_bit(i, data);\n\t\t\telse\n\t\t\t\tocfs2_set_bit(i, data);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid ocfs2_hamming_fix_block(void *data, unsigned int blocksize,\n\t\t\t     unsigned int fix)\n{\n\tocfs2_hamming_fix(data, blocksize * 8, 0, fix);\n}\n\n\n \n\n#ifdef CONFIG_DEBUG_FS\n\nstatic int blockcheck_u64_get(void *data, u64 *val)\n{\n\t*val = *(u64 *)data;\n\treturn 0;\n}\nDEFINE_DEBUGFS_ATTRIBUTE(blockcheck_fops, blockcheck_u64_get, NULL, \"%llu\\n\");\n\nstatic void ocfs2_blockcheck_debug_remove(struct ocfs2_blockcheck_stats *stats)\n{\n\tif (stats) {\n\t\tdebugfs_remove_recursive(stats->b_debug_dir);\n\t\tstats->b_debug_dir = NULL;\n\t}\n}\n\nstatic void ocfs2_blockcheck_debug_install(struct ocfs2_blockcheck_stats *stats,\n\t\t\t\t\t   struct dentry *parent)\n{\n\tstruct dentry *dir;\n\n\tdir = debugfs_create_dir(\"blockcheck\", parent);\n\tstats->b_debug_dir = dir;\n\n\tdebugfs_create_file(\"blocks_checked\", S_IFREG | S_IRUSR, dir,\n\t\t\t    &stats->b_check_count, &blockcheck_fops);\n\n\tdebugfs_create_file(\"checksums_failed\", S_IFREG | S_IRUSR, dir,\n\t\t\t    &stats->b_failure_count, &blockcheck_fops);\n\n\tdebugfs_create_file(\"ecc_recoveries\", S_IFREG | S_IRUSR, dir,\n\t\t\t    &stats->b_recover_count, &blockcheck_fops);\n\n}\n#else\nstatic inline void ocfs2_blockcheck_debug_install(struct ocfs2_blockcheck_stats *stats,\n\t\t\t\t\t\t  struct dentry *parent)\n{\n}\n\nstatic inline void ocfs2_blockcheck_debug_remove(struct ocfs2_blockcheck_stats *stats)\n{\n}\n#endif   \n\n \nvoid ocfs2_blockcheck_stats_debugfs_install(struct ocfs2_blockcheck_stats *stats,\n\t\t\t\t\t    struct dentry *parent)\n{\n\tocfs2_blockcheck_debug_install(stats, parent);\n}\n\nvoid ocfs2_blockcheck_stats_debugfs_remove(struct ocfs2_blockcheck_stats *stats)\n{\n\tocfs2_blockcheck_debug_remove(stats);\n}\n\nstatic void ocfs2_blockcheck_inc_check(struct ocfs2_blockcheck_stats *stats)\n{\n\tu64 new_count;\n\n\tif (!stats)\n\t\treturn;\n\n\tspin_lock(&stats->b_lock);\n\tstats->b_check_count++;\n\tnew_count = stats->b_check_count;\n\tspin_unlock(&stats->b_lock);\n\n\tif (!new_count)\n\t\tmlog(ML_NOTICE, \"Block check count has wrapped\\n\");\n}\n\nstatic void ocfs2_blockcheck_inc_failure(struct ocfs2_blockcheck_stats *stats)\n{\n\tu64 new_count;\n\n\tif (!stats)\n\t\treturn;\n\n\tspin_lock(&stats->b_lock);\n\tstats->b_failure_count++;\n\tnew_count = stats->b_failure_count;\n\tspin_unlock(&stats->b_lock);\n\n\tif (!new_count)\n\t\tmlog(ML_NOTICE, \"Checksum failure count has wrapped\\n\");\n}\n\nstatic void ocfs2_blockcheck_inc_recover(struct ocfs2_blockcheck_stats *stats)\n{\n\tu64 new_count;\n\n\tif (!stats)\n\t\treturn;\n\n\tspin_lock(&stats->b_lock);\n\tstats->b_recover_count++;\n\tnew_count = stats->b_recover_count;\n\tspin_unlock(&stats->b_lock);\n\n\tif (!new_count)\n\t\tmlog(ML_NOTICE, \"ECC recovery count has wrapped\\n\");\n}\n\n\n\n \n\n \nvoid ocfs2_block_check_compute(void *data, size_t blocksize,\n\t\t\t       struct ocfs2_block_check *bc)\n{\n\tu32 crc;\n\tu32 ecc;\n\n\tmemset(bc, 0, sizeof(struct ocfs2_block_check));\n\n\tcrc = crc32_le(~0, data, blocksize);\n\tecc = ocfs2_hamming_encode_block(data, blocksize);\n\n\t \n\tBUG_ON(ecc > USHRT_MAX);\n\n\tbc->bc_crc32e = cpu_to_le32(crc);\n\tbc->bc_ecc = cpu_to_le16((u16)ecc);\n}\n\n \nint ocfs2_block_check_validate(void *data, size_t blocksize,\n\t\t\t       struct ocfs2_block_check *bc,\n\t\t\t       struct ocfs2_blockcheck_stats *stats)\n{\n\tint rc = 0;\n\tu32 bc_crc32e;\n\tu16 bc_ecc;\n\tu32 crc, ecc;\n\n\tocfs2_blockcheck_inc_check(stats);\n\n\tbc_crc32e = le32_to_cpu(bc->bc_crc32e);\n\tbc_ecc = le16_to_cpu(bc->bc_ecc);\n\n\tmemset(bc, 0, sizeof(struct ocfs2_block_check));\n\n\t \n\tcrc = crc32_le(~0, data, blocksize);\n\tif (crc == bc_crc32e)\n\t\tgoto out;\n\n\tocfs2_blockcheck_inc_failure(stats);\n\tmlog(ML_ERROR,\n\t     \"CRC32 failed: stored: 0x%x, computed 0x%x. Applying ECC.\\n\",\n\t     (unsigned int)bc_crc32e, (unsigned int)crc);\n\n\t \n\tecc = ocfs2_hamming_encode_block(data, blocksize);\n\tocfs2_hamming_fix_block(data, blocksize, ecc ^ bc_ecc);\n\n\t \n\tcrc = crc32_le(~0, data, blocksize);\n\tif (crc == bc_crc32e) {\n\t\tocfs2_blockcheck_inc_recover(stats);\n\t\tgoto out;\n\t}\n\n\tmlog(ML_ERROR, \"Fixed CRC32 failed: stored: 0x%x, computed 0x%x\\n\",\n\t     (unsigned int)bc_crc32e, (unsigned int)crc);\n\n\trc = -EIO;\n\nout:\n\tbc->bc_crc32e = cpu_to_le32(bc_crc32e);\n\tbc->bc_ecc = cpu_to_le16(bc_ecc);\n\n\treturn rc;\n}\n\n \nvoid ocfs2_block_check_compute_bhs(struct buffer_head **bhs, int nr,\n\t\t\t\t   struct ocfs2_block_check *bc)\n{\n\tint i;\n\tu32 crc, ecc;\n\n\tBUG_ON(nr < 0);\n\n\tif (!nr)\n\t\treturn;\n\n\tmemset(bc, 0, sizeof(struct ocfs2_block_check));\n\n\tfor (i = 0, crc = ~0, ecc = 0; i < nr; i++) {\n\t\tcrc = crc32_le(crc, bhs[i]->b_data, bhs[i]->b_size);\n\t\t \n\t\tecc = (u16)ocfs2_hamming_encode(ecc, bhs[i]->b_data,\n\t\t\t\t\t\tbhs[i]->b_size * 8,\n\t\t\t\t\t\tbhs[i]->b_size * 8 * i);\n\t}\n\n\t \n\tBUG_ON(ecc > USHRT_MAX);\n\n\tbc->bc_crc32e = cpu_to_le32(crc);\n\tbc->bc_ecc = cpu_to_le16((u16)ecc);\n}\n\n \nint ocfs2_block_check_validate_bhs(struct buffer_head **bhs, int nr,\n\t\t\t\t   struct ocfs2_block_check *bc,\n\t\t\t\t   struct ocfs2_blockcheck_stats *stats)\n{\n\tint i, rc = 0;\n\tu32 bc_crc32e;\n\tu16 bc_ecc;\n\tu32 crc, ecc, fix;\n\n\tBUG_ON(nr < 0);\n\n\tif (!nr)\n\t\treturn 0;\n\n\tocfs2_blockcheck_inc_check(stats);\n\n\tbc_crc32e = le32_to_cpu(bc->bc_crc32e);\n\tbc_ecc = le16_to_cpu(bc->bc_ecc);\n\n\tmemset(bc, 0, sizeof(struct ocfs2_block_check));\n\n\t \n\tfor (i = 0, crc = ~0; i < nr; i++)\n\t\tcrc = crc32_le(crc, bhs[i]->b_data, bhs[i]->b_size);\n\tif (crc == bc_crc32e)\n\t\tgoto out;\n\n\tocfs2_blockcheck_inc_failure(stats);\n\tmlog(ML_ERROR,\n\t     \"CRC32 failed: stored: %u, computed %u.  Applying ECC.\\n\",\n\t     (unsigned int)bc_crc32e, (unsigned int)crc);\n\n\t \n\tfor (i = 0, ecc = 0; i < nr; i++) {\n\t\t \n\t\tecc = (u16)ocfs2_hamming_encode(ecc, bhs[i]->b_data,\n\t\t\t\t\t\tbhs[i]->b_size * 8,\n\t\t\t\t\t\tbhs[i]->b_size * 8 * i);\n\t}\n\tfix = ecc ^ bc_ecc;\n\tfor (i = 0; i < nr; i++) {\n\t\t \n\t\tocfs2_hamming_fix(bhs[i]->b_data, bhs[i]->b_size * 8,\n\t\t\t\t  bhs[i]->b_size * 8 * i, fix);\n\t}\n\n\t \n\tfor (i = 0, crc = ~0; i < nr; i++)\n\t\tcrc = crc32_le(crc, bhs[i]->b_data, bhs[i]->b_size);\n\tif (crc == bc_crc32e) {\n\t\tocfs2_blockcheck_inc_recover(stats);\n\t\tgoto out;\n\t}\n\n\tmlog(ML_ERROR, \"Fixed CRC32 failed: stored: %u, computed %u\\n\",\n\t     (unsigned int)bc_crc32e, (unsigned int)crc);\n\n\trc = -EIO;\n\nout:\n\tbc->bc_crc32e = cpu_to_le32(bc_crc32e);\n\tbc->bc_ecc = cpu_to_le16(bc_ecc);\n\n\treturn rc;\n}\n\n \nvoid ocfs2_compute_meta_ecc(struct super_block *sb, void *data,\n\t\t\t    struct ocfs2_block_check *bc)\n{\n\tif (ocfs2_meta_ecc(OCFS2_SB(sb)))\n\t\tocfs2_block_check_compute(data, sb->s_blocksize, bc);\n}\n\nint ocfs2_validate_meta_ecc(struct super_block *sb, void *data,\n\t\t\t    struct ocfs2_block_check *bc)\n{\n\tint rc = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (ocfs2_meta_ecc(osb))\n\t\trc = ocfs2_block_check_validate(data, sb->s_blocksize, bc,\n\t\t\t\t\t\t&osb->osb_ecc_stats);\n\n\treturn rc;\n}\n\nvoid ocfs2_compute_meta_ecc_bhs(struct super_block *sb,\n\t\t\t\tstruct buffer_head **bhs, int nr,\n\t\t\t\tstruct ocfs2_block_check *bc)\n{\n\tif (ocfs2_meta_ecc(OCFS2_SB(sb)))\n\t\tocfs2_block_check_compute_bhs(bhs, nr, bc);\n}\n\nint ocfs2_validate_meta_ecc_bhs(struct super_block *sb,\n\t\t\t\tstruct buffer_head **bhs, int nr,\n\t\t\t\tstruct ocfs2_block_check *bc)\n{\n\tint rc = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (ocfs2_meta_ecc(osb))\n\t\trc = ocfs2_block_check_validate_bhs(bhs, nr, bc,\n\t\t\t\t\t\t    &osb->osb_ecc_stats);\n\n\treturn rc;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}