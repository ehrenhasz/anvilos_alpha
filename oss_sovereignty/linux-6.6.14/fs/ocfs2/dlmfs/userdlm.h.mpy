{
  "module_name": "userdlm.h",
  "hash_id": "f3782e220a34dd4d32a30425e1451ea68b30c01cf51427a71a4ef03ca83516d7",
  "original_prompt": "Ingested from linux-6.6.14/fs/ocfs2/dlmfs/userdlm.h",
  "human_readable_source": " \n \n\n\n#ifndef USERDLM_H\n#define USERDLM_H\n\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/workqueue.h>\n\n \n#define USER_LOCK_ATTACHED      (0x00000001)  \n#define USER_LOCK_BUSY          (0x00000002)  \n#define USER_LOCK_BLOCKED       (0x00000004)  \n#define USER_LOCK_IN_TEARDOWN   (0x00000008)  \n#define USER_LOCK_QUEUED        (0x00000010)  \n#define USER_LOCK_IN_CANCEL     (0x00000020)\n\nstruct user_lock_res {\n\tspinlock_t               l_lock;\n\n\tint                      l_flags;\n\n#define USER_DLM_LOCK_ID_MAX_LEN  32\n\tchar                     l_name[USER_DLM_LOCK_ID_MAX_LEN];\n\tint                      l_namelen;\n\tint                      l_level;\n\tunsigned int             l_ro_holders;\n\tunsigned int             l_ex_holders;\n\tstruct ocfs2_dlm_lksb    l_lksb;\n\n\tint                      l_requested;\n\tint                      l_blocking;\n\n\twait_queue_head_t        l_event;\n\n\tstruct work_struct       l_work;\n};\n\nextern struct workqueue_struct *user_dlm_worker;\n\nvoid user_dlm_lock_res_init(struct user_lock_res *lockres,\n\t\t\t    struct dentry *dentry);\nint user_dlm_destroy_lock(struct user_lock_res *lockres);\nint user_dlm_cluster_lock(struct user_lock_res *lockres,\n\t\t\t  int level,\n\t\t\t  int lkm_flags);\nvoid user_dlm_cluster_unlock(struct user_lock_res *lockres,\n\t\t\t     int level);\nvoid user_dlm_write_lvb(struct inode *inode,\n\t\t\tconst char *val,\n\t\t\tunsigned int len);\nbool user_dlm_read_lvb(struct inode *inode, char *val);\nstruct ocfs2_cluster_connection *user_dlm_register(const struct qstr *name);\nvoid user_dlm_unregister(struct ocfs2_cluster_connection *conn);\nvoid user_dlm_set_locking_protocol(void);\n\nstruct dlmfs_inode_private {\n\tstruct ocfs2_cluster_connection\t*ip_conn;\n\n\tstruct user_lock_res ip_lockres;  \n\tstruct inode         *ip_parent;\n\n\tstruct inode         ip_vfs_inode;\n};\n\nstatic inline struct dlmfs_inode_private *\nDLMFS_I(struct inode *inode)\n{\n        return container_of(inode,\n\t\t\t    struct dlmfs_inode_private,\n\t\t\t    ip_vfs_inode);\n}\n\nstruct dlmfs_filp_private {\n\tint                  fp_lock_level;\n};\n\n#define DLMFS_MAGIC\t0x76a9f425\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}