{
  "module_name": "dlmfs.c",
  "hash_id": "8ef862419aecaad5c76aa5caa7464a7728a0d47160d4900736c7e46a2219af6b",
  "original_prompt": "Ingested from linux-6.6.14/fs/ocfs2/dlmfs/dlmfs.c",
  "human_readable_source": "\n \n\n \n \n\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/backing-dev.h>\n#include <linux/poll.h>\n\n#include <linux/uaccess.h>\n\n#include \"../stackglue.h\"\n#include \"userdlm.h\"\n\n#define MLOG_MASK_PREFIX ML_DLMFS\n#include \"../cluster/masklog.h\"\n\n\nstatic const struct super_operations dlmfs_ops;\nstatic const struct file_operations dlmfs_file_operations;\nstatic const struct inode_operations dlmfs_dir_inode_operations;\nstatic const struct inode_operations dlmfs_root_inode_operations;\nstatic const struct inode_operations dlmfs_file_inode_operations;\nstatic struct kmem_cache *dlmfs_inode_cache;\n\nstruct workqueue_struct *user_dlm_worker;\n\n\n\n \n#define DLMFS_CAPABILITIES \"bast stackglue\"\nstatic int param_set_dlmfs_capabilities(const char *val,\n\t\t\t\t\tconst struct kernel_param *kp)\n{\n\tprintk(KERN_ERR \"%s: readonly parameter\\n\", kp->name);\n\treturn -EINVAL;\n}\nstatic int param_get_dlmfs_capabilities(char *buffer,\n\t\t\t\t\tconst struct kernel_param *kp)\n{\n\treturn strlcpy(buffer, DLMFS_CAPABILITIES,\n\t\t       strlen(DLMFS_CAPABILITIES) + 1);\n}\nmodule_param_call(capabilities, param_set_dlmfs_capabilities,\n\t\t  param_get_dlmfs_capabilities, NULL, 0444);\nMODULE_PARM_DESC(capabilities, DLMFS_CAPABILITIES);\n\n\n \nstatic int dlmfs_decode_open_flags(int open_flags,\n\t\t\t\t   int *level,\n\t\t\t\t   int *flags)\n{\n\tif (open_flags & (O_WRONLY|O_RDWR))\n\t\t*level = DLM_LOCK_EX;\n\telse\n\t\t*level = DLM_LOCK_PR;\n\n\t*flags = 0;\n\tif (open_flags & O_NONBLOCK)\n\t\t*flags |= DLM_LKF_NOQUEUE;\n\n\treturn 0;\n}\n\nstatic int dlmfs_file_open(struct inode *inode,\n\t\t\t   struct file *file)\n{\n\tint status, level, flags;\n\tstruct dlmfs_filp_private *fp = NULL;\n\tstruct dlmfs_inode_private *ip;\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tBUG();\n\n\tmlog(0, \"open called on inode %lu, flags 0x%x\\n\", inode->i_ino,\n\t\tfile->f_flags);\n\n\tstatus = dlmfs_decode_open_flags(file->f_flags, &level, &flags);\n\tif (status < 0)\n\t\tgoto bail;\n\n\t \n\tfile->f_flags &= ~O_APPEND;\n\n\tfp = kmalloc(sizeof(*fp), GFP_NOFS);\n\tif (!fp) {\n\t\tstatus = -ENOMEM;\n\t\tgoto bail;\n\t}\n\tfp->fp_lock_level = level;\n\n\tip = DLMFS_I(inode);\n\n\tstatus = user_dlm_cluster_lock(&ip->ip_lockres, level, flags);\n\tif (status < 0) {\n\t\t \n\t\tif (flags & DLM_LKF_NOQUEUE && status == -EAGAIN)\n\t\t\tstatus = -ETXTBSY;\n\t\tkfree(fp);\n\t\tgoto bail;\n\t}\n\n\tfile->private_data = fp;\nbail:\n\treturn status;\n}\n\nstatic int dlmfs_file_release(struct inode *inode,\n\t\t\t      struct file *file)\n{\n\tint level;\n\tstruct dlmfs_inode_private *ip = DLMFS_I(inode);\n\tstruct dlmfs_filp_private *fp = file->private_data;\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tBUG();\n\n\tmlog(0, \"close called on inode %lu\\n\", inode->i_ino);\n\n\tif (fp) {\n\t\tlevel = fp->fp_lock_level;\n\t\tif (level != DLM_LOCK_IV)\n\t\t\tuser_dlm_cluster_unlock(&ip->ip_lockres, level);\n\n\t\tkfree(fp);\n\t\tfile->private_data = NULL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int dlmfs_file_setattr(struct mnt_idmap *idmap,\n\t\t\t      struct dentry *dentry, struct iattr *attr)\n{\n\tint error;\n\tstruct inode *inode = d_inode(dentry);\n\n\tattr->ia_valid &= ~ATTR_SIZE;\n\terror = setattr_prepare(&nop_mnt_idmap, dentry, attr);\n\tif (error)\n\t\treturn error;\n\n\tsetattr_copy(&nop_mnt_idmap, inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}\n\nstatic __poll_t dlmfs_file_poll(struct file *file, poll_table *wait)\n{\n\t__poll_t event = 0;\n\tstruct inode *inode = file_inode(file);\n\tstruct dlmfs_inode_private *ip = DLMFS_I(inode);\n\n\tpoll_wait(file, &ip->ip_lockres.l_event, wait);\n\n\tspin_lock(&ip->ip_lockres.l_lock);\n\tif (ip->ip_lockres.l_flags & USER_LOCK_BLOCKED)\n\t\tevent = EPOLLIN | EPOLLRDNORM;\n\tspin_unlock(&ip->ip_lockres.l_lock);\n\n\treturn event;\n}\n\nstatic ssize_t dlmfs_file_read(struct file *file,\n\t\t\t       char __user *buf,\n\t\t\t       size_t count,\n\t\t\t       loff_t *ppos)\n{\n\tchar lvb[DLM_LVB_LEN];\n\n\tif (!user_dlm_read_lvb(file_inode(file), lvb))\n\t\treturn 0;\n\n\treturn simple_read_from_buffer(buf, count, ppos, lvb, sizeof(lvb));\n}\n\nstatic ssize_t dlmfs_file_write(struct file *filp,\n\t\t\t\tconst char __user *buf,\n\t\t\t\tsize_t count,\n\t\t\t\tloff_t *ppos)\n{\n\tchar lvb_buf[DLM_LVB_LEN];\n\tint bytes_left;\n\tstruct inode *inode = file_inode(filp);\n\n\tmlog(0, \"inode %lu, count = %zu, *ppos = %llu\\n\",\n\t\tinode->i_ino, count, *ppos);\n\n\tif (*ppos >= DLM_LVB_LEN)\n\t\treturn -ENOSPC;\n\n\t \n\tif (count > DLM_LVB_LEN - *ppos)\n\t\tcount = DLM_LVB_LEN - *ppos;\n\n\tif (!count)\n\t\treturn 0;\n\n\tbytes_left = copy_from_user(lvb_buf, buf, count);\n\tcount -= bytes_left;\n\tif (count)\n\t\tuser_dlm_write_lvb(inode, lvb_buf, count);\n\n\t*ppos = *ppos + count;\n\tmlog(0, \"wrote %zu bytes\\n\", count);\n\treturn count;\n}\n\nstatic void dlmfs_init_once(void *foo)\n{\n\tstruct dlmfs_inode_private *ip =\n\t\t(struct dlmfs_inode_private *) foo;\n\n\tip->ip_conn = NULL;\n\tip->ip_parent = NULL;\n\n\tinode_init_once(&ip->ip_vfs_inode);\n}\n\nstatic struct inode *dlmfs_alloc_inode(struct super_block *sb)\n{\n\tstruct dlmfs_inode_private *ip;\n\n\tip = alloc_inode_sb(sb, dlmfs_inode_cache, GFP_NOFS);\n\tif (!ip)\n\t\treturn NULL;\n\n\treturn &ip->ip_vfs_inode;\n}\n\nstatic void dlmfs_free_inode(struct inode *inode)\n{\n\tkmem_cache_free(dlmfs_inode_cache, DLMFS_I(inode));\n}\n\nstatic void dlmfs_evict_inode(struct inode *inode)\n{\n\tint status;\n\tstruct dlmfs_inode_private *ip;\n\tstruct user_lock_res *lockres;\n\tint teardown;\n\n\tclear_inode(inode);\n\n\tmlog(0, \"inode %lu\\n\", inode->i_ino);\n\n\tip = DLMFS_I(inode);\n\tlockres = &ip->ip_lockres;\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tspin_lock(&lockres->l_lock);\n\t\tteardown = !!(lockres->l_flags & USER_LOCK_IN_TEARDOWN);\n\t\tspin_unlock(&lockres->l_lock);\n\t\tif (!teardown) {\n\t\t\tstatus = user_dlm_destroy_lock(lockres);\n\t\t\tif (status < 0)\n\t\t\t\tmlog_errno(status);\n\t\t}\n\t\tiput(ip->ip_parent);\n\t\tgoto clear_fields;\n\t}\n\n\tmlog(0, \"we're a directory, ip->ip_conn = 0x%p\\n\", ip->ip_conn);\n\t \n\tif (ip->ip_conn)\n\t\tuser_dlm_unregister(ip->ip_conn);\nclear_fields:\n\tip->ip_parent = NULL;\n\tip->ip_conn = NULL;\n}\n\nstatic struct inode *dlmfs_get_root_inode(struct super_block *sb)\n{\n\tstruct inode *inode = new_inode(sb);\n\tumode_t mode = S_IFDIR | 0755;\n\n\tif (inode) {\n\t\tinode->i_ino = get_next_ino();\n\t\tinode_init_owner(&nop_mnt_idmap, inode, NULL, mode);\n\t\tinode->i_atime = inode->i_mtime = inode_set_ctime_current(inode);\n\t\tinc_nlink(inode);\n\n\t\tinode->i_fop = &simple_dir_operations;\n\t\tinode->i_op = &dlmfs_root_inode_operations;\n\t}\n\n\treturn inode;\n}\n\nstatic struct inode *dlmfs_get_inode(struct inode *parent,\n\t\t\t\t     struct dentry *dentry,\n\t\t\t\t     umode_t mode)\n{\n\tstruct super_block *sb = parent->i_sb;\n\tstruct inode * inode = new_inode(sb);\n\tstruct dlmfs_inode_private *ip;\n\n\tif (!inode)\n\t\treturn NULL;\n\n\tinode->i_ino = get_next_ino();\n\tinode_init_owner(&nop_mnt_idmap, inode, parent, mode);\n\tinode->i_atime = inode->i_mtime = inode_set_ctime_current(inode);\n\n\tip = DLMFS_I(inode);\n\tip->ip_conn = DLMFS_I(parent)->ip_conn;\n\n\tswitch (mode & S_IFMT) {\n\tdefault:\n\t\t \n\t\tBUG();\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &dlmfs_file_inode_operations;\n\t\tinode->i_fop = &dlmfs_file_operations;\n\n\t\ti_size_write(inode,  DLM_LVB_LEN);\n\n\t\tuser_dlm_lock_res_init(&ip->ip_lockres, dentry);\n\n\t\t \n\t\tip->ip_parent = igrab(parent);\n\t\tBUG_ON(!ip->ip_parent);\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tinode->i_op = &dlmfs_dir_inode_operations;\n\t\tinode->i_fop = &simple_dir_operations;\n\n\t\t \n\t\tinc_nlink(inode);\n\t\tbreak;\n\t}\n\treturn inode;\n}\n\n \n \nstatic int dlmfs_mkdir(struct mnt_idmap * idmap,\n\t\t       struct inode * dir,\n\t\t       struct dentry * dentry,\n\t\t       umode_t mode)\n{\n\tint status;\n\tstruct inode *inode = NULL;\n\tconst struct qstr *domain = &dentry->d_name;\n\tstruct dlmfs_inode_private *ip;\n\tstruct ocfs2_cluster_connection *conn;\n\n\tmlog(0, \"mkdir %.*s\\n\", domain->len, domain->name);\n\n\t \n\tif (domain->len >= GROUP_NAME_MAX) {\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"invalid domain name for directory.\\n\");\n\t\tgoto bail;\n\t}\n\n\tinode = dlmfs_get_inode(dir, dentry, mode | S_IFDIR);\n\tif (!inode) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tip = DLMFS_I(inode);\n\n\tconn = user_dlm_register(domain);\n\tif (IS_ERR(conn)) {\n\t\tstatus = PTR_ERR(conn);\n\t\tmlog(ML_ERROR, \"Error %d could not register domain \\\"%.*s\\\"\\n\",\n\t\t     status, domain->len, domain->name);\n\t\tgoto bail;\n\t}\n\tip->ip_conn = conn;\n\n\tinc_nlink(dir);\n\td_instantiate(dentry, inode);\n\tdget(dentry);\t \n\n\tstatus = 0;\nbail:\n\tif (status < 0)\n\t\tiput(inode);\n\treturn status;\n}\n\nstatic int dlmfs_create(struct mnt_idmap *idmap,\n\t\t\tstruct inode *dir,\n\t\t\tstruct dentry *dentry,\n\t\t\tumode_t mode,\n\t\t\tbool excl)\n{\n\tint status = 0;\n\tstruct inode *inode;\n\tconst struct qstr *name = &dentry->d_name;\n\n\tmlog(0, \"create %.*s\\n\", name->len, name->name);\n\n\t \n\tif (name->len >= USER_DLM_LOCK_ID_MAX_LEN ||\n\t    name->name[0] == '$') {\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"invalid lock name, %.*s\\n\", name->len,\n\t\t     name->name);\n\t\tgoto bail;\n\t}\n\n\tinode = dlmfs_get_inode(dir, dentry, mode | S_IFREG);\n\tif (!inode) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\td_instantiate(dentry, inode);\n\tdget(dentry);\t \nbail:\n\treturn status;\n}\n\nstatic int dlmfs_unlink(struct inode *dir,\n\t\t\tstruct dentry *dentry)\n{\n\tint status;\n\tstruct inode *inode = d_inode(dentry);\n\n\tmlog(0, \"unlink inode %lu\\n\", inode->i_ino);\n\n\t \n\tstatus = user_dlm_destroy_lock(&DLMFS_I(inode)->ip_lockres);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"unlink %pd, error %d from destroy\\n\",\n\t\t     dentry, status);\n\t\tgoto bail;\n\t}\n\tstatus = simple_unlink(dir, dentry);\nbail:\n\treturn status;\n}\n\nstatic int dlmfs_fill_super(struct super_block * sb,\n\t\t\t    void * data,\n\t\t\t    int silent)\n{\n\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\tsb->s_blocksize = PAGE_SIZE;\n\tsb->s_blocksize_bits = PAGE_SHIFT;\n\tsb->s_magic = DLMFS_MAGIC;\n\tsb->s_op = &dlmfs_ops;\n\tsb->s_root = d_make_root(dlmfs_get_root_inode(sb));\n\tif (!sb->s_root)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic const struct file_operations dlmfs_file_operations = {\n\t.open\t\t= dlmfs_file_open,\n\t.release\t= dlmfs_file_release,\n\t.poll\t\t= dlmfs_file_poll,\n\t.read\t\t= dlmfs_file_read,\n\t.write\t\t= dlmfs_file_write,\n\t.llseek\t\t= default_llseek,\n};\n\nstatic const struct inode_operations dlmfs_dir_inode_operations = {\n\t.create\t\t= dlmfs_create,\n\t.lookup\t\t= simple_lookup,\n\t.unlink\t\t= dlmfs_unlink,\n};\n\n \nstatic const struct inode_operations dlmfs_root_inode_operations = {\n\t.lookup\t\t= simple_lookup,\n\t.mkdir\t\t= dlmfs_mkdir,\n\t.rmdir\t\t= simple_rmdir,\n};\n\nstatic const struct super_operations dlmfs_ops = {\n\t.statfs\t\t= simple_statfs,\n\t.alloc_inode\t= dlmfs_alloc_inode,\n\t.free_inode\t= dlmfs_free_inode,\n\t.evict_inode\t= dlmfs_evict_inode,\n\t.drop_inode\t= generic_delete_inode,\n};\n\nstatic const struct inode_operations dlmfs_file_inode_operations = {\n\t.getattr\t= simple_getattr,\n\t.setattr\t= dlmfs_file_setattr,\n};\n\nstatic struct dentry *dlmfs_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_nodev(fs_type, flags, data, dlmfs_fill_super);\n}\n\nstatic struct file_system_type dlmfs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"ocfs2_dlmfs\",\n\t.mount\t\t= dlmfs_mount,\n\t.kill_sb\t= kill_litter_super,\n};\nMODULE_ALIAS_FS(\"ocfs2_dlmfs\");\n\nstatic int __init init_dlmfs_fs(void)\n{\n\tint status;\n\tint cleanup_inode = 0, cleanup_worker = 0;\n\n\tdlmfs_inode_cache = kmem_cache_create(\"dlmfs_inode_cache\",\n\t\t\t\tsizeof(struct dlmfs_inode_private),\n\t\t\t\t0, (SLAB_HWCACHE_ALIGN|SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\tSLAB_MEM_SPREAD|SLAB_ACCOUNT),\n\t\t\t\tdlmfs_init_once);\n\tif (!dlmfs_inode_cache) {\n\t\tstatus = -ENOMEM;\n\t\tgoto bail;\n\t}\n\tcleanup_inode = 1;\n\n\tuser_dlm_worker = alloc_workqueue(\"user_dlm\", WQ_MEM_RECLAIM, 0);\n\tif (!user_dlm_worker) {\n\t\tstatus = -ENOMEM;\n\t\tgoto bail;\n\t}\n\tcleanup_worker = 1;\n\n\tuser_dlm_set_locking_protocol();\n\tstatus = register_filesystem(&dlmfs_fs_type);\nbail:\n\tif (status) {\n\t\tif (cleanup_inode)\n\t\t\tkmem_cache_destroy(dlmfs_inode_cache);\n\t\tif (cleanup_worker)\n\t\t\tdestroy_workqueue(user_dlm_worker);\n\t} else\n\t\tprintk(\"OCFS2 User DLM kernel interface loaded\\n\");\n\treturn status;\n}\n\nstatic void __exit exit_dlmfs_fs(void)\n{\n\tunregister_filesystem(&dlmfs_fs_type);\n\n\tdestroy_workqueue(user_dlm_worker);\n\n\t \n\trcu_barrier();\n\tkmem_cache_destroy(dlmfs_inode_cache);\n\n}\n\nMODULE_AUTHOR(\"Oracle\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"OCFS2 DLM-Filesystem\");\n\nmodule_init(init_dlmfs_fs)\nmodule_exit(exit_dlmfs_fs)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}