{
  "module_name": "userdlm.c",
  "hash_id": "17d981b77e827f3474173d201a7aea0d3030e201bed4da883898c34bf87252d8",
  "original_prompt": "Ingested from linux-6.6.14/fs/ocfs2/dlmfs/userdlm.c",
  "human_readable_source": "\n \n\n#include <linux/signal.h>\n#include <linux/sched/signal.h>\n\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/crc32.h>\n\n#include \"../ocfs2_lockingver.h\"\n#include \"../stackglue.h\"\n#include \"userdlm.h\"\n\n#define MLOG_MASK_PREFIX ML_DLMFS\n#include \"../cluster/masklog.h\"\n\n\nstatic inline struct user_lock_res *user_lksb_to_lock_res(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn container_of(lksb, struct user_lock_res, l_lksb);\n}\n\nstatic inline int user_check_wait_flag(struct user_lock_res *lockres,\n\t\t\t\t       int flag)\n{\n\tint ret;\n\n\tspin_lock(&lockres->l_lock);\n\tret = lockres->l_flags & flag;\n\tspin_unlock(&lockres->l_lock);\n\n\treturn ret;\n}\n\nstatic inline void user_wait_on_busy_lock(struct user_lock_res *lockres)\n\n{\n\twait_event(lockres->l_event,\n\t\t   !user_check_wait_flag(lockres, USER_LOCK_BUSY));\n}\n\nstatic inline void user_wait_on_blocked_lock(struct user_lock_res *lockres)\n\n{\n\twait_event(lockres->l_event,\n\t\t   !user_check_wait_flag(lockres, USER_LOCK_BLOCKED));\n}\n\n \nstatic inline struct ocfs2_cluster_connection *\ncluster_connection_from_user_lockres(struct user_lock_res *lockres)\n{\n\tstruct dlmfs_inode_private *ip;\n\n\tip = container_of(lockres,\n\t\t\t  struct dlmfs_inode_private,\n\t\t\t  ip_lockres);\n\treturn ip->ip_conn;\n}\n\nstatic struct inode *\nuser_dlm_inode_from_user_lockres(struct user_lock_res *lockres)\n{\n\tstruct dlmfs_inode_private *ip;\n\n\tip = container_of(lockres,\n\t\t\t  struct dlmfs_inode_private,\n\t\t\t  ip_lockres);\n\treturn &ip->ip_vfs_inode;\n}\n\nstatic inline void user_recover_from_dlm_error(struct user_lock_res *lockres)\n{\n\tspin_lock(&lockres->l_lock);\n\tlockres->l_flags &= ~USER_LOCK_BUSY;\n\tspin_unlock(&lockres->l_lock);\n}\n\n#define user_log_dlm_error(_func, _stat, _lockres) do {\t\t\t\\\n\tmlog(ML_ERROR, \"Dlm error %d while calling %s on \"\t\t\\\n\t\t\"resource %.*s\\n\", _stat, _func,\t\t\t\\\n\t\t_lockres->l_namelen, _lockres->l_name); \t\t\\\n} while (0)\n\n \nstatic inline int user_highest_compat_lock_level(int level)\n{\n\tint new_level = DLM_LOCK_EX;\n\n\tif (level == DLM_LOCK_EX)\n\t\tnew_level = DLM_LOCK_NL;\n\telse if (level == DLM_LOCK_PR)\n\t\tnew_level = DLM_LOCK_PR;\n\treturn new_level;\n}\n\nstatic void user_ast(struct ocfs2_dlm_lksb *lksb)\n{\n\tstruct user_lock_res *lockres = user_lksb_to_lock_res(lksb);\n\tint status;\n\n\tmlog(ML_BASTS, \"AST fired for lockres %.*s, level %d => %d\\n\",\n\t     lockres->l_namelen, lockres->l_name, lockres->l_level,\n\t     lockres->l_requested);\n\n\tspin_lock(&lockres->l_lock);\n\n\tstatus = ocfs2_dlm_lock_status(&lockres->l_lksb);\n\tif (status) {\n\t\tmlog(ML_ERROR, \"lksb status value of %u on lockres %.*s\\n\",\n\t\t     status, lockres->l_namelen, lockres->l_name);\n\t\tspin_unlock(&lockres->l_lock);\n\t\treturn;\n\t}\n\n\tmlog_bug_on_msg(lockres->l_requested == DLM_LOCK_IV,\n\t\t\t\"Lockres %.*s, requested ivmode. flags 0x%x\\n\",\n\t\t\tlockres->l_namelen, lockres->l_name, lockres->l_flags);\n\n\t \n\tif (lockres->l_requested < lockres->l_level) {\n\t\tif (lockres->l_requested <=\n\t\t    user_highest_compat_lock_level(lockres->l_blocking)) {\n\t\t\tlockres->l_blocking = DLM_LOCK_NL;\n\t\t\tlockres->l_flags &= ~USER_LOCK_BLOCKED;\n\t\t}\n\t}\n\n\tlockres->l_level = lockres->l_requested;\n\tlockres->l_requested = DLM_LOCK_IV;\n\tlockres->l_flags |= USER_LOCK_ATTACHED;\n\tlockres->l_flags &= ~USER_LOCK_BUSY;\n\n\tspin_unlock(&lockres->l_lock);\n\n\twake_up(&lockres->l_event);\n}\n\nstatic inline void user_dlm_grab_inode_ref(struct user_lock_res *lockres)\n{\n\tstruct inode *inode;\n\tinode = user_dlm_inode_from_user_lockres(lockres);\n\tif (!igrab(inode))\n\t\tBUG();\n}\n\nstatic void user_dlm_unblock_lock(struct work_struct *work);\n\nstatic void __user_dlm_queue_lockres(struct user_lock_res *lockres)\n{\n\tif (!(lockres->l_flags & USER_LOCK_QUEUED)) {\n\t\tuser_dlm_grab_inode_ref(lockres);\n\n\t\tINIT_WORK(&lockres->l_work, user_dlm_unblock_lock);\n\n\t\tqueue_work(user_dlm_worker, &lockres->l_work);\n\t\tlockres->l_flags |= USER_LOCK_QUEUED;\n\t}\n}\n\nstatic void __user_dlm_cond_queue_lockres(struct user_lock_res *lockres)\n{\n\tint queue = 0;\n\n\tif (!(lockres->l_flags & USER_LOCK_BLOCKED))\n\t\treturn;\n\n\tswitch (lockres->l_blocking) {\n\tcase DLM_LOCK_EX:\n\t\tif (!lockres->l_ex_holders && !lockres->l_ro_holders)\n\t\t\tqueue = 1;\n\t\tbreak;\n\tcase DLM_LOCK_PR:\n\t\tif (!lockres->l_ex_holders)\n\t\t\tqueue = 1;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tif (queue)\n\t\t__user_dlm_queue_lockres(lockres);\n}\n\nstatic void user_bast(struct ocfs2_dlm_lksb *lksb, int level)\n{\n\tstruct user_lock_res *lockres = user_lksb_to_lock_res(lksb);\n\n\tmlog(ML_BASTS, \"BAST fired for lockres %.*s, blocking %d, level %d\\n\",\n\t     lockres->l_namelen, lockres->l_name, level, lockres->l_level);\n\n\tspin_lock(&lockres->l_lock);\n\tlockres->l_flags |= USER_LOCK_BLOCKED;\n\tif (level > lockres->l_blocking)\n\t\tlockres->l_blocking = level;\n\n\t__user_dlm_queue_lockres(lockres);\n\tspin_unlock(&lockres->l_lock);\n\n\twake_up(&lockres->l_event);\n}\n\nstatic void user_unlock_ast(struct ocfs2_dlm_lksb *lksb, int status)\n{\n\tstruct user_lock_res *lockres = user_lksb_to_lock_res(lksb);\n\n\tmlog(ML_BASTS, \"UNLOCK AST fired for lockres %.*s, flags 0x%x\\n\",\n\t     lockres->l_namelen, lockres->l_name, lockres->l_flags);\n\n\tif (status)\n\t\tmlog(ML_ERROR, \"dlm returns status %d\\n\", status);\n\n\tspin_lock(&lockres->l_lock);\n\t \n\tif (lockres->l_flags & USER_LOCK_IN_TEARDOWN\n\t    && !(lockres->l_flags & USER_LOCK_IN_CANCEL)) {\n\t\tlockres->l_level = DLM_LOCK_IV;\n\t} else if (status == DLM_CANCELGRANT) {\n\t\t \n\t\tBUG_ON(!(lockres->l_flags & USER_LOCK_IN_CANCEL));\n\t\tlockres->l_flags &= ~USER_LOCK_IN_CANCEL;\n\t\tgoto out_noclear;\n\t} else {\n\t\tBUG_ON(!(lockres->l_flags & USER_LOCK_IN_CANCEL));\n\t\t \n\t\tlockres->l_requested = DLM_LOCK_IV;  \n\t\tlockres->l_flags &= ~USER_LOCK_IN_CANCEL;\n\t\t \n\t\tif (lockres->l_flags & USER_LOCK_BLOCKED)\n\t\t\t__user_dlm_queue_lockres(lockres);\n\t}\n\n\tlockres->l_flags &= ~USER_LOCK_BUSY;\nout_noclear:\n\tspin_unlock(&lockres->l_lock);\n\n\twake_up(&lockres->l_event);\n}\n\n \nstatic struct ocfs2_locking_protocol user_dlm_lproto = {\n\t.lp_max_version = {\n\t\t.pv_major = OCFS2_LOCKING_PROTOCOL_MAJOR,\n\t\t.pv_minor = OCFS2_LOCKING_PROTOCOL_MINOR,\n\t},\n\t.lp_lock_ast\t\t= user_ast,\n\t.lp_blocking_ast\t= user_bast,\n\t.lp_unlock_ast\t\t= user_unlock_ast,\n};\n\nstatic inline void user_dlm_drop_inode_ref(struct user_lock_res *lockres)\n{\n\tstruct inode *inode;\n\tinode = user_dlm_inode_from_user_lockres(lockres);\n\tiput(inode);\n}\n\nstatic void user_dlm_unblock_lock(struct work_struct *work)\n{\n\tint new_level, status;\n\tstruct user_lock_res *lockres =\n\t\tcontainer_of(work, struct user_lock_res, l_work);\n\tstruct ocfs2_cluster_connection *conn =\n\t\tcluster_connection_from_user_lockres(lockres);\n\n\tmlog(0, \"lockres %.*s\\n\", lockres->l_namelen, lockres->l_name);\n\n\tspin_lock(&lockres->l_lock);\n\n\tmlog_bug_on_msg(!(lockres->l_flags & USER_LOCK_QUEUED),\n\t\t\t\"Lockres %.*s, flags 0x%x\\n\",\n\t\t\tlockres->l_namelen, lockres->l_name, lockres->l_flags);\n\n\t \n\tlockres->l_flags &= ~USER_LOCK_QUEUED;\n\n\t \n\tif (!(lockres->l_flags & USER_LOCK_BLOCKED)) {\n\t\tmlog(ML_BASTS, \"lockres %.*s USER_LOCK_BLOCKED\\n\",\n\t\t     lockres->l_namelen, lockres->l_name);\n\t\tspin_unlock(&lockres->l_lock);\n\t\tgoto drop_ref;\n\t}\n\n\tif (lockres->l_flags & USER_LOCK_IN_TEARDOWN) {\n\t\tmlog(ML_BASTS, \"lockres %.*s USER_LOCK_IN_TEARDOWN\\n\",\n\t\t     lockres->l_namelen, lockres->l_name);\n\t\tspin_unlock(&lockres->l_lock);\n\t\tgoto drop_ref;\n\t}\n\n\tif (lockres->l_flags & USER_LOCK_BUSY) {\n\t\tif (lockres->l_flags & USER_LOCK_IN_CANCEL) {\n\t\t\tmlog(ML_BASTS, \"lockres %.*s USER_LOCK_IN_CANCEL\\n\",\n\t\t\t     lockres->l_namelen, lockres->l_name);\n\t\t\tspin_unlock(&lockres->l_lock);\n\t\t\tgoto drop_ref;\n\t\t}\n\n\t\tlockres->l_flags |= USER_LOCK_IN_CANCEL;\n\t\tspin_unlock(&lockres->l_lock);\n\n\t\tstatus = ocfs2_dlm_unlock(conn, &lockres->l_lksb,\n\t\t\t\t\t  DLM_LKF_CANCEL);\n\t\tif (status)\n\t\t\tuser_log_dlm_error(\"ocfs2_dlm_unlock\", status, lockres);\n\t\tgoto drop_ref;\n\t}\n\n\t \n\tif ((lockres->l_blocking == DLM_LOCK_EX)\n\t    && (lockres->l_ex_holders || lockres->l_ro_holders)) {\n\t\tspin_unlock(&lockres->l_lock);\n\t\tmlog(ML_BASTS, \"lockres %.*s, EX/PR Holders %u,%u\\n\",\n\t\t     lockres->l_namelen, lockres->l_name,\n\t\t     lockres->l_ex_holders, lockres->l_ro_holders);\n\t\tgoto drop_ref;\n\t}\n\n\tif ((lockres->l_blocking == DLM_LOCK_PR)\n\t    && lockres->l_ex_holders) {\n\t\tspin_unlock(&lockres->l_lock);\n\t\tmlog(ML_BASTS, \"lockres %.*s, EX Holders %u\\n\",\n\t\t     lockres->l_namelen, lockres->l_name,\n\t\t     lockres->l_ex_holders);\n\t\tgoto drop_ref;\n\t}\n\n\t \n\tnew_level = user_highest_compat_lock_level(lockres->l_blocking);\n\tlockres->l_requested = new_level;\n\tlockres->l_flags |= USER_LOCK_BUSY;\n\tmlog(ML_BASTS, \"lockres %.*s, downconvert %d => %d\\n\",\n\t     lockres->l_namelen, lockres->l_name, lockres->l_level, new_level);\n\tspin_unlock(&lockres->l_lock);\n\n\t \n\tstatus = ocfs2_dlm_lock(conn, new_level, &lockres->l_lksb,\n\t\t\t\tDLM_LKF_CONVERT|DLM_LKF_VALBLK,\n\t\t\t\tlockres->l_name,\n\t\t\t\tlockres->l_namelen);\n\tif (status) {\n\t\tuser_log_dlm_error(\"ocfs2_dlm_lock\", status, lockres);\n\t\tuser_recover_from_dlm_error(lockres);\n\t}\n\ndrop_ref:\n\tuser_dlm_drop_inode_ref(lockres);\n}\n\nstatic inline void user_dlm_inc_holders(struct user_lock_res *lockres,\n\t\t\t\t\tint level)\n{\n\tswitch(level) {\n\tcase DLM_LOCK_EX:\n\t\tlockres->l_ex_holders++;\n\t\tbreak;\n\tcase DLM_LOCK_PR:\n\t\tlockres->l_ro_holders++;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}\n\n \nstatic inline int\nuser_may_continue_on_blocked_lock(struct user_lock_res *lockres,\n\t\t\t\t  int wanted)\n{\n\tBUG_ON(!(lockres->l_flags & USER_LOCK_BLOCKED));\n\n\treturn wanted <= user_highest_compat_lock_level(lockres->l_blocking);\n}\n\nint user_dlm_cluster_lock(struct user_lock_res *lockres,\n\t\t\t  int level,\n\t\t\t  int lkm_flags)\n{\n\tint status, local_flags;\n\tstruct ocfs2_cluster_connection *conn =\n\t\tcluster_connection_from_user_lockres(lockres);\n\n\tif (level != DLM_LOCK_EX &&\n\t    level != DLM_LOCK_PR) {\n\t\tmlog(ML_ERROR, \"lockres %.*s: invalid request!\\n\",\n\t\t     lockres->l_namelen, lockres->l_name);\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tmlog(ML_BASTS, \"lockres %.*s, level %d, flags = 0x%x\\n\",\n\t     lockres->l_namelen, lockres->l_name, level, lkm_flags);\n\nagain:\n\tif (signal_pending(current)) {\n\t\tstatus = -ERESTARTSYS;\n\t\tgoto bail;\n\t}\n\n\tspin_lock(&lockres->l_lock);\n\tif (lockres->l_flags & USER_LOCK_IN_TEARDOWN) {\n\t\tspin_unlock(&lockres->l_lock);\n\t\tstatus = -EAGAIN;\n\t\tgoto bail;\n\t}\n\n\t \n\tif ((lockres->l_flags & USER_LOCK_BUSY) &&\n\t    (level > lockres->l_level)) {\n\t\t \n\t\tspin_unlock(&lockres->l_lock);\n\n\t\tuser_wait_on_busy_lock(lockres);\n\t\tgoto again;\n\t}\n\n\tif ((lockres->l_flags & USER_LOCK_BLOCKED) &&\n\t    (!user_may_continue_on_blocked_lock(lockres, level))) {\n\t\t \n\t\tspin_unlock(&lockres->l_lock);\n\n\t\tuser_wait_on_blocked_lock(lockres);\n\t\tgoto again;\n\t}\n\n\tif (level > lockres->l_level) {\n\t\tlocal_flags = lkm_flags | DLM_LKF_VALBLK;\n\t\tif (lockres->l_level != DLM_LOCK_IV)\n\t\t\tlocal_flags |= DLM_LKF_CONVERT;\n\n\t\tlockres->l_requested = level;\n\t\tlockres->l_flags |= USER_LOCK_BUSY;\n\t\tspin_unlock(&lockres->l_lock);\n\n\t\tBUG_ON(level == DLM_LOCK_IV);\n\t\tBUG_ON(level == DLM_LOCK_NL);\n\n\t\t \n\t\tstatus = ocfs2_dlm_lock(conn, level, &lockres->l_lksb,\n\t\t\t\t\tlocal_flags, lockres->l_name,\n\t\t\t\t\tlockres->l_namelen);\n\t\tif (status) {\n\t\t\tif ((lkm_flags & DLM_LKF_NOQUEUE) &&\n\t\t\t    (status != -EAGAIN))\n\t\t\t\tuser_log_dlm_error(\"ocfs2_dlm_lock\",\n\t\t\t\t\t\t   status, lockres);\n\t\t\tuser_recover_from_dlm_error(lockres);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tuser_wait_on_busy_lock(lockres);\n\t\tgoto again;\n\t}\n\n\tuser_dlm_inc_holders(lockres, level);\n\tspin_unlock(&lockres->l_lock);\n\n\tstatus = 0;\nbail:\n\treturn status;\n}\n\nstatic inline void user_dlm_dec_holders(struct user_lock_res *lockres,\n\t\t\t\t\tint level)\n{\n\tswitch(level) {\n\tcase DLM_LOCK_EX:\n\t\tBUG_ON(!lockres->l_ex_holders);\n\t\tlockres->l_ex_holders--;\n\t\tbreak;\n\tcase DLM_LOCK_PR:\n\t\tBUG_ON(!lockres->l_ro_holders);\n\t\tlockres->l_ro_holders--;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}\n\nvoid user_dlm_cluster_unlock(struct user_lock_res *lockres,\n\t\t\t     int level)\n{\n\tif (level != DLM_LOCK_EX &&\n\t    level != DLM_LOCK_PR) {\n\t\tmlog(ML_ERROR, \"lockres %.*s: invalid request!\\n\",\n\t\t     lockres->l_namelen, lockres->l_name);\n\t\treturn;\n\t}\n\n\tspin_lock(&lockres->l_lock);\n\tuser_dlm_dec_holders(lockres, level);\n\t__user_dlm_cond_queue_lockres(lockres);\n\tspin_unlock(&lockres->l_lock);\n}\n\nvoid user_dlm_write_lvb(struct inode *inode,\n\t\t\tconst char *val,\n\t\t\tunsigned int len)\n{\n\tstruct user_lock_res *lockres = &DLMFS_I(inode)->ip_lockres;\n\tchar *lvb;\n\n\tBUG_ON(len > DLM_LVB_LEN);\n\n\tspin_lock(&lockres->l_lock);\n\n\tBUG_ON(lockres->l_level < DLM_LOCK_EX);\n\tlvb = ocfs2_dlm_lvb(&lockres->l_lksb);\n\tmemcpy(lvb, val, len);\n\n\tspin_unlock(&lockres->l_lock);\n}\n\nbool user_dlm_read_lvb(struct inode *inode, char *val)\n{\n\tstruct user_lock_res *lockres = &DLMFS_I(inode)->ip_lockres;\n\tchar *lvb;\n\tbool ret = true;\n\n\tspin_lock(&lockres->l_lock);\n\n\tBUG_ON(lockres->l_level < DLM_LOCK_PR);\n\tif (ocfs2_dlm_lvb_valid(&lockres->l_lksb)) {\n\t\tlvb = ocfs2_dlm_lvb(&lockres->l_lksb);\n\t\tmemcpy(val, lvb, DLM_LVB_LEN);\n\t} else\n\t\tret = false;\n\n\tspin_unlock(&lockres->l_lock);\n\treturn ret;\n}\n\nvoid user_dlm_lock_res_init(struct user_lock_res *lockres,\n\t\t\t    struct dentry *dentry)\n{\n\tmemset(lockres, 0, sizeof(*lockres));\n\n\tspin_lock_init(&lockres->l_lock);\n\tinit_waitqueue_head(&lockres->l_event);\n\tlockres->l_level = DLM_LOCK_IV;\n\tlockres->l_requested = DLM_LOCK_IV;\n\tlockres->l_blocking = DLM_LOCK_IV;\n\n\t \n\tBUG_ON(dentry->d_name.len >= USER_DLM_LOCK_ID_MAX_LEN);\n\n\tmemcpy(lockres->l_name,\n\t       dentry->d_name.name,\n\t       dentry->d_name.len);\n\tlockres->l_namelen = dentry->d_name.len;\n}\n\nint user_dlm_destroy_lock(struct user_lock_res *lockres)\n{\n\tint status = -EBUSY;\n\tstruct ocfs2_cluster_connection *conn =\n\t\tcluster_connection_from_user_lockres(lockres);\n\n\tmlog(ML_BASTS, \"lockres %.*s\\n\", lockres->l_namelen, lockres->l_name);\n\n\tspin_lock(&lockres->l_lock);\n\tif (lockres->l_flags & USER_LOCK_IN_TEARDOWN) {\n\t\tspin_unlock(&lockres->l_lock);\n\t\tgoto bail;\n\t}\n\n\tlockres->l_flags |= USER_LOCK_IN_TEARDOWN;\n\n\twhile (lockres->l_flags & USER_LOCK_BUSY) {\n\t\tspin_unlock(&lockres->l_lock);\n\n\t\tuser_wait_on_busy_lock(lockres);\n\n\t\tspin_lock(&lockres->l_lock);\n\t}\n\n\tif (lockres->l_ro_holders || lockres->l_ex_holders) {\n\t\tlockres->l_flags &= ~USER_LOCK_IN_TEARDOWN;\n\t\tspin_unlock(&lockres->l_lock);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\n\tif (!(lockres->l_flags & USER_LOCK_ATTACHED)) {\n\t\t \n\t\tspin_unlock(&lockres->l_lock);\n\t\tgoto bail;\n\t}\n\n\tlockres->l_flags |= USER_LOCK_BUSY;\n\tspin_unlock(&lockres->l_lock);\n\n\tstatus = ocfs2_dlm_unlock(conn, &lockres->l_lksb, DLM_LKF_VALBLK);\n\tif (status) {\n\t\tspin_lock(&lockres->l_lock);\n\t\tlockres->l_flags &= ~USER_LOCK_IN_TEARDOWN;\n\t\tlockres->l_flags &= ~USER_LOCK_BUSY;\n\t\tspin_unlock(&lockres->l_lock);\n\t\tuser_log_dlm_error(\"ocfs2_dlm_unlock\", status, lockres);\n\t\tgoto bail;\n\t}\n\n\tuser_wait_on_busy_lock(lockres);\n\n\tstatus = 0;\nbail:\n\treturn status;\n}\n\nstatic void user_dlm_recovery_handler_noop(int node_num,\n\t\t\t\t\t   void *recovery_data)\n{\n\t \n\treturn;\n}\n\nvoid user_dlm_set_locking_protocol(void)\n{\n\tocfs2_stack_glue_set_max_proto_version(&user_dlm_lproto.lp_max_version);\n}\n\nstruct ocfs2_cluster_connection *user_dlm_register(const struct qstr *name)\n{\n\tint rc;\n\tstruct ocfs2_cluster_connection *conn;\n\n\trc = ocfs2_cluster_connect_agnostic(name->name, name->len,\n\t\t\t\t\t    &user_dlm_lproto,\n\t\t\t\t\t    user_dlm_recovery_handler_noop,\n\t\t\t\t\t    NULL, &conn);\n\tif (rc)\n\t\tmlog_errno(rc);\n\n\treturn rc ? ERR_PTR(rc) : conn;\n}\n\nvoid user_dlm_unregister(struct ocfs2_cluster_connection *conn)\n{\n\tocfs2_cluster_disconnect(conn, 0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}