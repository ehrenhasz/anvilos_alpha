{
  "module_name": "quota_local.c",
  "hash_id": "41a99713b34763d87bcadb7fa72809c605496c4080496dfab5ccb8ee7d817042",
  "original_prompt": "Ingested from linux-6.6.14/fs/ocfs2/quota_local.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/quota.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n\n#include <cluster/masklog.h>\n\n#include \"ocfs2_fs.h\"\n#include \"ocfs2.h\"\n#include \"inode.h\"\n#include \"alloc.h\"\n#include \"file.h\"\n#include \"buffer_head_io.h\"\n#include \"journal.h\"\n#include \"sysfile.h\"\n#include \"dlmglue.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"ocfs2_trace.h\"\n\n \nstatic inline unsigned int ol_quota_entries_per_block(struct super_block *sb)\n{\n\treturn ((sb->s_blocksize - OCFS2_QBLK_RESERVED_SPACE) /\n\t\tsizeof(struct ocfs2_local_disk_dqblk));\n}\n\n \nstatic inline unsigned int ol_chunk_blocks(struct super_block *sb)\n{\n\treturn ((sb->s_blocksize - sizeof(struct ocfs2_local_disk_chunk) -\n\t\t OCFS2_QBLK_RESERVED_SPACE) << 3) /\n\t       ol_quota_entries_per_block(sb);\n}\n\n \nstatic unsigned int ol_chunk_entries(struct super_block *sb)\n{\n\treturn ol_chunk_blocks(sb) * ol_quota_entries_per_block(sb);\n}\n\n \nstatic unsigned int ol_quota_chunk_block(struct super_block *sb, int c)\n{\n\t \n\treturn 1 + (ol_chunk_blocks(sb) + 1) * c;\n}\n\nstatic unsigned int ol_dqblk_block(struct super_block *sb, int c, int off)\n{\n\tint epb = ol_quota_entries_per_block(sb);\n\n\treturn ol_quota_chunk_block(sb, c) + 1 + off / epb;\n}\n\nstatic unsigned int ol_dqblk_block_off(struct super_block *sb, int c, int off)\n{\n\tint epb = ol_quota_entries_per_block(sb);\n\n\treturn (off % epb) * sizeof(struct ocfs2_local_disk_dqblk);\n}\n\n \nstatic loff_t ol_dqblk_off(struct super_block *sb, int c, int off)\n{\n\treturn (ol_dqblk_block(sb, c, off) << sb->s_blocksize_bits) +\n\t       ol_dqblk_block_off(sb, c, off);\n}\n\nstatic inline unsigned int ol_dqblk_block_offset(struct super_block *sb, loff_t off)\n{\n\treturn off & ((1 << sb->s_blocksize_bits) - 1);\n}\n\n \nstatic int ol_dqblk_chunk_off(struct super_block *sb, int c, loff_t off)\n{\n\tint epb = ol_quota_entries_per_block(sb);\n\n\treturn ((off >> sb->s_blocksize_bits) -\n\t\t\tol_quota_chunk_block(sb, c) - 1) * epb\n\t       + ((unsigned int)(off & ((1 << sb->s_blocksize_bits) - 1))) /\n\t\t sizeof(struct ocfs2_local_disk_dqblk);\n}\n\n \nstatic int ocfs2_modify_bh(struct inode *inode, struct buffer_head *bh,\n\t\tvoid (*modify)(struct buffer_head *, void *), void *private)\n{\n\tstruct super_block *sb = inode->i_sb;\n\thandle_t *handle;\n\tint status;\n\n\thandle = ocfs2_start_trans(OCFS2_SB(sb),\n\t\t\t\t   OCFS2_QUOTA_BLOCK_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\tstatus = ocfs2_journal_access_dq(handle, INODE_CACHE(inode), bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tocfs2_commit_trans(OCFS2_SB(sb), handle);\n\t\treturn status;\n\t}\n\tlock_buffer(bh);\n\tmodify(bh, private);\n\tunlock_buffer(bh);\n\tocfs2_journal_dirty(handle, bh);\n\n\tstatus = ocfs2_commit_trans(OCFS2_SB(sb), handle);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\treturn 0;\n}\n\n \nstatic int ocfs2_read_quota_block(struct inode *inode, u64 v_block,\n\t\t\t\t  struct buffer_head **bh)\n{\n\tint rc = 0;\n\tstruct buffer_head *tmp = *bh;\n\n\tif (i_size_read(inode) >> inode->i_sb->s_blocksize_bits <= v_block)\n\t\treturn ocfs2_error(inode->i_sb,\n\t\t\t\t\"Quota file %llu is probably corrupted! Requested to read block %Lu but file has size only %Lu\\n\",\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t\t(unsigned long long)v_block,\n\t\t\t\t(unsigned long long)i_size_read(inode));\n\n\trc = ocfs2_read_virt_blocks(inode, v_block, 1, &tmp, 0,\n\t\t\t\t    ocfs2_validate_quota_block);\n\tif (rc)\n\t\tmlog_errno(rc);\n\n\t \n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}\n\n \nstatic int ocfs2_local_check_quota_file(struct super_block *sb, int type)\n{\n\tunsigned int lmagics[OCFS2_MAXQUOTAS] = OCFS2_LOCAL_QMAGICS;\n\tunsigned int lversions[OCFS2_MAXQUOTAS] = OCFS2_LOCAL_QVERSIONS;\n\tunsigned int gmagics[OCFS2_MAXQUOTAS] = OCFS2_GLOBAL_QMAGICS;\n\tunsigned int gversions[OCFS2_MAXQUOTAS] = OCFS2_GLOBAL_QVERSIONS;\n\tunsigned int ino[OCFS2_MAXQUOTAS] = { USER_QUOTA_SYSTEM_INODE,\n\t\t\t\t\t      GROUP_QUOTA_SYSTEM_INODE };\n\tstruct buffer_head *bh = NULL;\n\tstruct inode *linode = sb_dqopt(sb)->files[type];\n\tstruct inode *ginode = NULL;\n\tstruct ocfs2_disk_dqheader *dqhead;\n\tint status, ret = 0;\n\n\t \n\tstatus = ocfs2_read_quota_block(linode, 0, &bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tmlog(ML_ERROR, \"failed to read quota file header (type=%d)\\n\",\n\t\t\ttype);\n\t\tgoto out_err;\n\t}\n\tdqhead = (struct ocfs2_disk_dqheader *)(bh->b_data);\n\tif (le32_to_cpu(dqhead->dqh_magic) != lmagics[type]) {\n\t\tmlog(ML_ERROR, \"quota file magic does not match (%u != %u),\"\n\t\t\t\" type=%d\\n\", le32_to_cpu(dqhead->dqh_magic),\n\t\t\tlmagics[type], type);\n\t\tgoto out_err;\n\t}\n\tif (le32_to_cpu(dqhead->dqh_version) != lversions[type]) {\n\t\tmlog(ML_ERROR, \"quota file version does not match (%u != %u),\"\n\t\t\t\" type=%d\\n\", le32_to_cpu(dqhead->dqh_version),\n\t\t\tlversions[type], type);\n\t\tgoto out_err;\n\t}\n\tbrelse(bh);\n\tbh = NULL;\n\n\t \n\tginode = ocfs2_get_system_file_inode(OCFS2_SB(sb), ino[type],\n\t\t\t\t\t\tOCFS2_INVALID_SLOT);\n\tif (!ginode) {\n\t\tmlog(ML_ERROR, \"cannot get global quota file inode \"\n\t\t\t\t\"(type=%d)\\n\", type);\n\t\tgoto out_err;\n\t}\n\t \n\tstatus = ocfs2_read_quota_block(ginode, 0, &bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tmlog(ML_ERROR, \"failed to read global quota file header \"\n\t\t\t\t\"(type=%d)\\n\", type);\n\t\tgoto out_err;\n\t}\n\tdqhead = (struct ocfs2_disk_dqheader *)(bh->b_data);\n\tif (le32_to_cpu(dqhead->dqh_magic) != gmagics[type]) {\n\t\tmlog(ML_ERROR, \"global quota file magic does not match \"\n\t\t\t\"(%u != %u), type=%d\\n\",\n\t\t\tle32_to_cpu(dqhead->dqh_magic), gmagics[type], type);\n\t\tgoto out_err;\n\t}\n\tif (le32_to_cpu(dqhead->dqh_version) != gversions[type]) {\n\t\tmlog(ML_ERROR, \"global quota file version does not match \"\n\t\t\t\"(%u != %u), type=%d\\n\",\n\t\t\tle32_to_cpu(dqhead->dqh_version), gversions[type],\n\t\t\ttype);\n\t\tgoto out_err;\n\t}\n\n\tret = 1;\nout_err:\n\tbrelse(bh);\n\tiput(ginode);\n\treturn ret;\n}\n\n \nstatic void ocfs2_release_local_quota_bitmaps(struct list_head *head)\n{\n\tstruct ocfs2_quota_chunk *pos, *next;\n\n\tlist_for_each_entry_safe(pos, next, head, qc_chunk) {\n\t\tlist_del(&pos->qc_chunk);\n\t\tbrelse(pos->qc_headerbh);\n\t\tkmem_cache_free(ocfs2_qf_chunk_cachep, pos);\n\t}\n}\n\n \nstatic int ocfs2_load_local_quota_bitmaps(struct inode *inode,\n\t\t\tstruct ocfs2_local_disk_dqinfo *ldinfo,\n\t\t\tstruct list_head *head)\n{\n\tstruct ocfs2_quota_chunk *newchunk;\n\tint i, status;\n\n\tINIT_LIST_HEAD(head);\n\tfor (i = 0; i < le32_to_cpu(ldinfo->dqi_chunks); i++) {\n\t\tnewchunk = kmem_cache_alloc(ocfs2_qf_chunk_cachep, GFP_NOFS);\n\t\tif (!newchunk) {\n\t\t\tocfs2_release_local_quota_bitmaps(head);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tnewchunk->qc_num = i;\n\t\tnewchunk->qc_headerbh = NULL;\n\t\tstatus = ocfs2_read_quota_block(inode,\n\t\t\t\tol_quota_chunk_block(inode->i_sb, i),\n\t\t\t\t&newchunk->qc_headerbh);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tkmem_cache_free(ocfs2_qf_chunk_cachep, newchunk);\n\t\t\tocfs2_release_local_quota_bitmaps(head);\n\t\t\treturn status;\n\t\t}\n\t\tlist_add_tail(&newchunk->qc_chunk, head);\n\t}\n\treturn 0;\n}\n\nstatic void olq_update_info(struct buffer_head *bh, void *private)\n{\n\tstruct mem_dqinfo *info = private;\n\tstruct ocfs2_mem_dqinfo *oinfo = info->dqi_priv;\n\tstruct ocfs2_local_disk_dqinfo *ldinfo;\n\n\tldinfo = (struct ocfs2_local_disk_dqinfo *)(bh->b_data +\n\t\t\t\t\t\tOCFS2_LOCAL_INFO_OFF);\n\tspin_lock(&dq_data_lock);\n\tldinfo->dqi_flags = cpu_to_le32(oinfo->dqi_flags);\n\tldinfo->dqi_chunks = cpu_to_le32(oinfo->dqi_chunks);\n\tldinfo->dqi_blocks = cpu_to_le32(oinfo->dqi_blocks);\n\tspin_unlock(&dq_data_lock);\n}\n\nstatic int ocfs2_add_recovery_chunk(struct super_block *sb,\n\t\t\t\t    struct ocfs2_local_disk_chunk *dchunk,\n\t\t\t\t    int chunk,\n\t\t\t\t    struct list_head *head)\n{\n\tstruct ocfs2_recovery_chunk *rc;\n\n\trc = kmalloc(sizeof(struct ocfs2_recovery_chunk), GFP_NOFS);\n\tif (!rc)\n\t\treturn -ENOMEM;\n\trc->rc_chunk = chunk;\n\trc->rc_bitmap = kmalloc(sb->s_blocksize, GFP_NOFS);\n\tif (!rc->rc_bitmap) {\n\t\tkfree(rc);\n\t\treturn -ENOMEM;\n\t}\n\tmemcpy(rc->rc_bitmap, dchunk->dqc_bitmap,\n\t       (ol_chunk_entries(sb) + 7) >> 3);\n\tlist_add_tail(&rc->rc_list, head);\n\treturn 0;\n}\n\nstatic void free_recovery_list(struct list_head *head)\n{\n\tstruct ocfs2_recovery_chunk *next;\n\tstruct ocfs2_recovery_chunk *rchunk;\n\n\tlist_for_each_entry_safe(rchunk, next, head, rc_list) {\n\t\tlist_del(&rchunk->rc_list);\n\t\tkfree(rchunk->rc_bitmap);\n\t\tkfree(rchunk);\n\t}\n}\n\nvoid ocfs2_free_quota_recovery(struct ocfs2_quota_recovery *rec)\n{\n\tint type;\n\n\tfor (type = 0; type < OCFS2_MAXQUOTAS; type++)\n\t\tfree_recovery_list(&(rec->r_list[type]));\n\tkfree(rec);\n}\n\n \nstatic int ocfs2_recovery_load_quota(struct inode *lqinode,\n\t\t\t\t     struct ocfs2_local_disk_dqinfo *ldinfo,\n\t\t\t\t     int type,\n\t\t\t\t     struct list_head *head)\n{\n\tstruct super_block *sb = lqinode->i_sb;\n\tstruct buffer_head *hbh;\n\tstruct ocfs2_local_disk_chunk *dchunk;\n\tint i, chunks = le32_to_cpu(ldinfo->dqi_chunks);\n\tint status = 0;\n\n\tfor (i = 0; i < chunks; i++) {\n\t\thbh = NULL;\n\t\tstatus = ocfs2_read_quota_block(lqinode,\n\t\t\t\t\t\tol_quota_chunk_block(sb, i),\n\t\t\t\t\t\t&hbh);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tbreak;\n\t\t}\n\t\tdchunk = (struct ocfs2_local_disk_chunk *)hbh->b_data;\n\t\tif (le32_to_cpu(dchunk->dqc_free) < ol_chunk_entries(sb))\n\t\t\tstatus = ocfs2_add_recovery_chunk(sb, dchunk, i, head);\n\t\tbrelse(hbh);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t}\n\tif (status < 0)\n\t\tfree_recovery_list(head);\n\treturn status;\n}\n\nstatic struct ocfs2_quota_recovery *ocfs2_alloc_quota_recovery(void)\n{\n\tint type;\n\tstruct ocfs2_quota_recovery *rec;\n\n\trec = kmalloc(sizeof(struct ocfs2_quota_recovery), GFP_NOFS);\n\tif (!rec)\n\t\treturn NULL;\n\tfor (type = 0; type < OCFS2_MAXQUOTAS; type++)\n\t\tINIT_LIST_HEAD(&(rec->r_list[type]));\n\treturn rec;\n}\n\n \nstruct ocfs2_quota_recovery *ocfs2_begin_quota_recovery(\n\t\t\t\t\t\tstruct ocfs2_super *osb,\n\t\t\t\t\t\tint slot_num)\n{\n\tunsigned int feature[OCFS2_MAXQUOTAS] = {\n\t\t\t\t\tOCFS2_FEATURE_RO_COMPAT_USRQUOTA,\n\t\t\t\t\tOCFS2_FEATURE_RO_COMPAT_GRPQUOTA};\n\tunsigned int ino[OCFS2_MAXQUOTAS] = { LOCAL_USER_QUOTA_SYSTEM_INODE,\n\t\t\t\t\t      LOCAL_GROUP_QUOTA_SYSTEM_INODE };\n\tstruct super_block *sb = osb->sb;\n\tstruct ocfs2_local_disk_dqinfo *ldinfo;\n\tstruct inode *lqinode;\n\tstruct buffer_head *bh;\n\tint type;\n\tint status = 0;\n\tstruct ocfs2_quota_recovery *rec;\n\n\tprintk(KERN_NOTICE \"ocfs2: Beginning quota recovery on device (%s) for \"\n\t       \"slot %u\\n\", osb->dev_str, slot_num);\n\n\trec = ocfs2_alloc_quota_recovery();\n\tif (!rec)\n\t\treturn ERR_PTR(-ENOMEM);\n\t \n\n\tfor (type = 0; type < OCFS2_MAXQUOTAS; type++) {\n\t\tif (!OCFS2_HAS_RO_COMPAT_FEATURE(sb, feature[type]))\n\t\t\tcontinue;\n\t\t \n\t\tlqinode = ocfs2_get_system_file_inode(osb, ino[type], slot_num);\n\t\tif (!lqinode) {\n\t\t\tstatus = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\tstatus = ocfs2_inode_lock_full(lqinode, NULL, 1,\n\t\t\t\t\t       OCFS2_META_LOCK_RECOVERY);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto out_put;\n\t\t}\n\t\t \n\t\tbh = NULL;\n\t\tstatus = ocfs2_read_quota_block(lqinode, 0, &bh);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tmlog(ML_ERROR, \"failed to read quota file info header \"\n\t\t\t\t\"(slot=%d type=%d)\\n\", slot_num, type);\n\t\t\tgoto out_lock;\n\t\t}\n\t\tldinfo = (struct ocfs2_local_disk_dqinfo *)(bh->b_data +\n\t\t\t\t\t\t\tOCFS2_LOCAL_INFO_OFF);\n\t\tstatus = ocfs2_recovery_load_quota(lqinode, ldinfo, type,\n\t\t\t\t\t\t   &rec->r_list[type]);\n\t\tbrelse(bh);\nout_lock:\n\t\tocfs2_inode_unlock(lqinode, 1);\nout_put:\n\t\tiput(lqinode);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t}\nout:\n\tif (status < 0) {\n\t\tocfs2_free_quota_recovery(rec);\n\t\trec = ERR_PTR(status);\n\t}\n\treturn rec;\n}\n\n \nstatic int ocfs2_recover_local_quota_file(struct inode *lqinode,\n\t\t\t\t\t  int type,\n\t\t\t\t\t  struct ocfs2_quota_recovery *rec)\n{\n\tstruct super_block *sb = lqinode->i_sb;\n\tstruct ocfs2_mem_dqinfo *oinfo = sb_dqinfo(sb, type)->dqi_priv;\n\tstruct ocfs2_local_disk_chunk *dchunk;\n\tstruct ocfs2_local_disk_dqblk *dqblk;\n\tstruct dquot *dquot;\n\thandle_t *handle;\n\tstruct buffer_head *hbh = NULL, *qbh = NULL;\n\tint status = 0;\n\tint bit, chunk;\n\tstruct ocfs2_recovery_chunk *rchunk, *next;\n\tqsize_t spacechange, inodechange;\n\n\ttrace_ocfs2_recover_local_quota_file((unsigned long)lqinode->i_ino, type);\n\n\tlist_for_each_entry_safe(rchunk, next, &(rec->r_list[type]), rc_list) {\n\t\tchunk = rchunk->rc_chunk;\n\t\thbh = NULL;\n\t\tstatus = ocfs2_read_quota_block(lqinode,\n\t\t\t\t\t\tol_quota_chunk_block(sb, chunk),\n\t\t\t\t\t\t&hbh);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tbreak;\n\t\t}\n\t\tdchunk = (struct ocfs2_local_disk_chunk *)hbh->b_data;\n\t\tfor_each_set_bit(bit, rchunk->rc_bitmap, ol_chunk_entries(sb)) {\n\t\t\tqbh = NULL;\n\t\t\tstatus = ocfs2_read_quota_block(lqinode,\n\t\t\t\t\t\tol_dqblk_block(sb, chunk, bit),\n\t\t\t\t\t\t&qbh);\n\t\t\tif (status) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdqblk = (struct ocfs2_local_disk_dqblk *)(qbh->b_data +\n\t\t\t\tol_dqblk_block_off(sb, chunk, bit));\n\t\t\tdquot = dqget(sb,\n\t\t\t\t      make_kqid(&init_user_ns, type,\n\t\t\t\t\t\tle64_to_cpu(dqblk->dqb_id)));\n\t\t\tif (IS_ERR(dquot)) {\n\t\t\t\tstatus = PTR_ERR(dquot);\n\t\t\t\tmlog(ML_ERROR, \"Failed to get quota structure \"\n\t\t\t\t     \"for id %u, type %d. Cannot finish quota \"\n\t\t\t\t     \"file recovery.\\n\",\n\t\t\t\t     (unsigned)le64_to_cpu(dqblk->dqb_id),\n\t\t\t\t     type);\n\t\t\t\tgoto out_put_bh;\n\t\t\t}\n\t\t\tstatus = ocfs2_lock_global_qf(oinfo, 1);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto out_put_dquot;\n\t\t\t}\n\n\t\t\thandle = ocfs2_start_trans(OCFS2_SB(sb),\n\t\t\t\t\t\t   OCFS2_QSYNC_CREDITS);\n\t\t\tif (IS_ERR(handle)) {\n\t\t\t\tstatus = PTR_ERR(handle);\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto out_drop_lock;\n\t\t\t}\n\t\t\tdown_write(&sb_dqopt(sb)->dqio_sem);\n\t\t\tspin_lock(&dquot->dq_dqb_lock);\n\t\t\t \n\t\t\tspacechange = le64_to_cpu(dqblk->dqb_spacemod);\n\t\t\tinodechange = le64_to_cpu(dqblk->dqb_inodemod);\n\t\t\tdquot->dq_dqb.dqb_curspace += spacechange;\n\t\t\tdquot->dq_dqb.dqb_curinodes += inodechange;\n\t\t\tspin_unlock(&dquot->dq_dqb_lock);\n\t\t\t \n\t\t\tstatus = ocfs2_global_release_dquot(dquot);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto out_commit;\n\t\t\t}\n\t\t\t \n\t\t\tstatus = ocfs2_journal_access_dq(handle,\n\t\t\t\t\tINODE_CACHE(lqinode),\n\t\t\t\t\tqbh, OCFS2_JOURNAL_ACCESS_WRITE);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto out_commit;\n\t\t\t}\n\t\t\tlock_buffer(qbh);\n\t\t\tWARN_ON(!ocfs2_test_bit_unaligned(bit, dchunk->dqc_bitmap));\n\t\t\tocfs2_clear_bit_unaligned(bit, dchunk->dqc_bitmap);\n\t\t\tle32_add_cpu(&dchunk->dqc_free, 1);\n\t\t\tunlock_buffer(qbh);\n\t\t\tocfs2_journal_dirty(handle, qbh);\nout_commit:\n\t\t\tup_write(&sb_dqopt(sb)->dqio_sem);\n\t\t\tocfs2_commit_trans(OCFS2_SB(sb), handle);\nout_drop_lock:\n\t\t\tocfs2_unlock_global_qf(oinfo, 1);\nout_put_dquot:\n\t\t\tdqput(dquot);\nout_put_bh:\n\t\t\tbrelse(qbh);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tbrelse(hbh);\n\t\tlist_del(&rchunk->rc_list);\n\t\tkfree(rchunk->rc_bitmap);\n\t\tkfree(rchunk);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t}\n\tif (status < 0)\n\t\tfree_recovery_list(&(rec->r_list[type]));\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}\n\n \nint ocfs2_finish_quota_recovery(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_quota_recovery *rec,\n\t\t\t\tint slot_num)\n{\n\tunsigned int ino[OCFS2_MAXQUOTAS] = { LOCAL_USER_QUOTA_SYSTEM_INODE,\n\t\t\t\t\t      LOCAL_GROUP_QUOTA_SYSTEM_INODE };\n\tstruct super_block *sb = osb->sb;\n\tstruct ocfs2_local_disk_dqinfo *ldinfo;\n\tstruct buffer_head *bh;\n\thandle_t *handle;\n\tint type;\n\tint status = 0;\n\tstruct inode *lqinode;\n\tunsigned int flags;\n\n\tprintk(KERN_NOTICE \"ocfs2: Finishing quota recovery on device (%s) for \"\n\t       \"slot %u\\n\", osb->dev_str, slot_num);\n\n\tdown_read(&sb->s_umount);\n\tfor (type = 0; type < OCFS2_MAXQUOTAS; type++) {\n\t\tif (list_empty(&(rec->r_list[type])))\n\t\t\tcontinue;\n\t\ttrace_ocfs2_finish_quota_recovery(slot_num);\n\t\tlqinode = ocfs2_get_system_file_inode(osb, ino[type], slot_num);\n\t\tif (!lqinode) {\n\t\t\tstatus = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\tstatus = ocfs2_inode_lock_full(lqinode, NULL, 1,\n\t\t\t\t\t\t       OCFS2_META_LOCK_NOQUEUE);\n\t\t \n\t\tif (status == -EAGAIN) {\n\t\t\tprintk(KERN_NOTICE \"ocfs2: Skipping quota recovery on \"\n\t\t\t       \"device (%s) for slot %d because quota file is \"\n\t\t\t       \"locked.\\n\", osb->dev_str, slot_num);\n\t\t\tstatus = 0;\n\t\t\tgoto out_put;\n\t\t} else if (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto out_put;\n\t\t}\n\t\t \n\t\tbh = NULL;\n\t\tstatus = ocfs2_read_quota_block(lqinode, 0, &bh);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tmlog(ML_ERROR, \"failed to read quota file info header \"\n\t\t\t\t\"(slot=%d type=%d)\\n\", slot_num, type);\n\t\t\tgoto out_lock;\n\t\t}\n\t\tldinfo = (struct ocfs2_local_disk_dqinfo *)(bh->b_data +\n\t\t\t\t\t\t\tOCFS2_LOCAL_INFO_OFF);\n\t\t \n\t\tflags = le32_to_cpu(ldinfo->dqi_flags);\n\t\tif (!(flags & OLQF_CLEAN))\n\t\t\tstatus = ocfs2_recover_local_quota_file(lqinode,\n\t\t\t\t\t\t\t\ttype,\n\t\t\t\t\t\t\t\trec);\n\t\t \n\t\tif (slot_num == osb->slot_num)\n\t\t\tgoto out_bh;\n\t\t \n\t\thandle = ocfs2_start_trans(osb,\n\t\t\t\t\t   OCFS2_LOCAL_QINFO_WRITE_CREDITS);\n\t\tif (IS_ERR(handle)) {\n\t\t\tstatus = PTR_ERR(handle);\n\t\t\tmlog_errno(status);\n\t\t\tgoto out_bh;\n\t\t}\n\t\tstatus = ocfs2_journal_access_dq(handle, INODE_CACHE(lqinode),\n\t\t\t\t\t\t bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto out_trans;\n\t\t}\n\t\tlock_buffer(bh);\n\t\tldinfo->dqi_flags = cpu_to_le32(flags | OLQF_CLEAN);\n\t\tunlock_buffer(bh);\n\t\tocfs2_journal_dirty(handle, bh);\nout_trans:\n\t\tocfs2_commit_trans(osb, handle);\nout_bh:\n\t\tbrelse(bh);\nout_lock:\n\t\tocfs2_inode_unlock(lqinode, 1);\nout_put:\n\t\tiput(lqinode);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t}\nout:\n\tup_read(&sb->s_umount);\n\tkfree(rec);\n\treturn status;\n}\n\n \nstatic int ocfs2_local_read_info(struct super_block *sb, int type)\n{\n\tstruct ocfs2_local_disk_dqinfo *ldinfo;\n\tstruct mem_dqinfo *info = sb_dqinfo(sb, type);\n\tstruct ocfs2_mem_dqinfo *oinfo;\n\tstruct inode *lqinode = sb_dqopt(sb)->files[type];\n\tint status;\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_quota_recovery *rec;\n\tint locked = 0;\n\n\tinfo->dqi_max_spc_limit = 0x7fffffffffffffffLL;\n\tinfo->dqi_max_ino_limit = 0x7fffffffffffffffLL;\n\toinfo = kmalloc(sizeof(struct ocfs2_mem_dqinfo), GFP_NOFS);\n\tif (!oinfo) {\n\t\tmlog(ML_ERROR, \"failed to allocate memory for ocfs2 quota\"\n\t\t\t       \" info.\");\n\t\tgoto out_err;\n\t}\n\tinfo->dqi_priv = oinfo;\n\toinfo->dqi_type = type;\n\tINIT_LIST_HEAD(&oinfo->dqi_chunk);\n\toinfo->dqi_rec = NULL;\n\toinfo->dqi_lqi_bh = NULL;\n\toinfo->dqi_libh = NULL;\n\n\tstatus = ocfs2_global_read_info(sb, type);\n\tif (status < 0)\n\t\tgoto out_err;\n\n\tstatus = ocfs2_inode_lock(lqinode, &oinfo->dqi_lqi_bh, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_err;\n\t}\n\tlocked = 1;\n\n\t \n\tstatus = ocfs2_read_quota_block(lqinode, 0, &bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tmlog(ML_ERROR, \"failed to read quota file info header \"\n\t\t\t\"(type=%d)\\n\", type);\n\t\tgoto out_err;\n\t}\n\tldinfo = (struct ocfs2_local_disk_dqinfo *)(bh->b_data +\n\t\t\t\t\t\tOCFS2_LOCAL_INFO_OFF);\n\toinfo->dqi_flags = le32_to_cpu(ldinfo->dqi_flags);\n\toinfo->dqi_chunks = le32_to_cpu(ldinfo->dqi_chunks);\n\toinfo->dqi_blocks = le32_to_cpu(ldinfo->dqi_blocks);\n\toinfo->dqi_libh = bh;\n\n\t \n\tif (!(oinfo->dqi_flags & OLQF_CLEAN)) {\n\t\trec = OCFS2_SB(sb)->quota_rec;\n\t\tif (!rec) {\n\t\t\trec = ocfs2_alloc_quota_recovery();\n\t\t\tif (!rec) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto out_err;\n\t\t\t}\n\t\t\tOCFS2_SB(sb)->quota_rec = rec;\n\t\t}\n\n\t\tstatus = ocfs2_recovery_load_quota(lqinode, ldinfo, type,\n                                                   &rec->r_list[type]);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\tstatus = ocfs2_load_local_quota_bitmaps(lqinode,\n\t\t\t\t\t\tldinfo,\n\t\t\t\t\t\t&oinfo->dqi_chunk);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_err;\n\t}\n\n\t \n\toinfo->dqi_flags &= ~OLQF_CLEAN;\n\tstatus = ocfs2_modify_bh(lqinode, bh, olq_update_info, info);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_err;\n\t}\n\n\treturn 0;\nout_err:\n\tif (oinfo) {\n\t\tiput(oinfo->dqi_gqinode);\n\t\tocfs2_simple_drop_lockres(OCFS2_SB(sb), &oinfo->dqi_gqlock);\n\t\tocfs2_lock_res_free(&oinfo->dqi_gqlock);\n\t\tbrelse(oinfo->dqi_lqi_bh);\n\t\tif (locked)\n\t\t\tocfs2_inode_unlock(lqinode, 1);\n\t\tocfs2_release_local_quota_bitmaps(&oinfo->dqi_chunk);\n\t\tkfree(oinfo);\n\t}\n\tbrelse(bh);\n\treturn -1;\n}\n\n \nstatic int ocfs2_local_write_info(struct super_block *sb, int type)\n{\n\tstruct mem_dqinfo *info = sb_dqinfo(sb, type);\n\tstruct buffer_head *bh = ((struct ocfs2_mem_dqinfo *)info->dqi_priv)\n\t\t\t\t\t\t->dqi_libh;\n\tint status;\n\n\tstatus = ocfs2_modify_bh(sb_dqopt(sb)->files[type], bh, olq_update_info,\n\t\t\t\t info);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ocfs2_local_free_info(struct super_block *sb, int type)\n{\n\tstruct mem_dqinfo *info = sb_dqinfo(sb, type);\n\tstruct ocfs2_mem_dqinfo *oinfo = info->dqi_priv;\n\tstruct ocfs2_quota_chunk *chunk;\n\tstruct ocfs2_local_disk_chunk *dchunk;\n\tint mark_clean = 1, len;\n\tint status = 0;\n\n\tiput(oinfo->dqi_gqinode);\n\tocfs2_simple_drop_lockres(OCFS2_SB(sb), &oinfo->dqi_gqlock);\n\tocfs2_lock_res_free(&oinfo->dqi_gqlock);\n\tlist_for_each_entry(chunk, &oinfo->dqi_chunk, qc_chunk) {\n\t\tdchunk = (struct ocfs2_local_disk_chunk *)\n\t\t\t\t\t(chunk->qc_headerbh->b_data);\n\t\tif (chunk->qc_num < oinfo->dqi_chunks - 1) {\n\t\t\tlen = ol_chunk_entries(sb);\n\t\t} else {\n\t\t\tlen = (oinfo->dqi_blocks -\n\t\t\t       ol_quota_chunk_block(sb, chunk->qc_num) - 1)\n\t\t\t      * ol_quota_entries_per_block(sb);\n\t\t}\n\t\t \n\t\tif (le32_to_cpu(dchunk->dqc_free) != len) {\n\t\t\tmlog(ML_ERROR, \"releasing quota file with used \"\n\t\t\t\t\t\"entries (type=%d)\\n\", type);\n\t\t\tmark_clean = 0;\n\t\t}\n\t}\n\tocfs2_release_local_quota_bitmaps(&oinfo->dqi_chunk);\n\n\t \n\tif (oinfo->dqi_rec) {\n\t\tocfs2_free_quota_recovery(oinfo->dqi_rec);\n\t\tmark_clean = 0;\n\t}\n\n\tif (!mark_clean)\n\t\tgoto out;\n\n\t \n\toinfo->dqi_flags |= OLQF_CLEAN;\n\tstatus = ocfs2_modify_bh(sb_dqopt(sb)->files[type],\n\t\t\t\t oinfo->dqi_libh,\n\t\t\t\t olq_update_info,\n\t\t\t\t info);\n\tif (status < 0)\n\t\tmlog_errno(status);\nout:\n\tocfs2_inode_unlock(sb_dqopt(sb)->files[type], 1);\n\tbrelse(oinfo->dqi_libh);\n\tbrelse(oinfo->dqi_lqi_bh);\n\tkfree(oinfo);\n\treturn status;\n}\n\nstatic void olq_set_dquot(struct buffer_head *bh, void *private)\n{\n\tstruct ocfs2_dquot *od = private;\n\tstruct ocfs2_local_disk_dqblk *dqblk;\n\tstruct super_block *sb = od->dq_dquot.dq_sb;\n\n\tdqblk = (struct ocfs2_local_disk_dqblk *)(bh->b_data\n\t\t+ ol_dqblk_block_offset(sb, od->dq_local_off));\n\n\tdqblk->dqb_id = cpu_to_le64(from_kqid(&init_user_ns,\n\t\t\t\t\t      od->dq_dquot.dq_id));\n\tspin_lock(&od->dq_dquot.dq_dqb_lock);\n\tdqblk->dqb_spacemod = cpu_to_le64(od->dq_dquot.dq_dqb.dqb_curspace -\n\t\t\t\t\t  od->dq_origspace);\n\tdqblk->dqb_inodemod = cpu_to_le64(od->dq_dquot.dq_dqb.dqb_curinodes -\n\t\t\t\t\t  od->dq_originodes);\n\tspin_unlock(&od->dq_dquot.dq_dqb_lock);\n\ttrace_olq_set_dquot(\n\t\t(unsigned long long)le64_to_cpu(dqblk->dqb_spacemod),\n\t\t(unsigned long long)le64_to_cpu(dqblk->dqb_inodemod),\n\t\tfrom_kqid(&init_user_ns, od->dq_dquot.dq_id));\n}\n\n \nint ocfs2_local_write_dquot(struct dquot *dquot)\n{\n\tstruct super_block *sb = dquot->dq_sb;\n\tstruct ocfs2_dquot *od = OCFS2_DQUOT(dquot);\n\tstruct buffer_head *bh;\n\tstruct inode *lqinode = sb_dqopt(sb)->files[dquot->dq_id.type];\n\tint status;\n\n\tstatus = ocfs2_read_quota_phys_block(lqinode, od->dq_local_phys_blk,\n\t\t\t\t\t     &bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\tstatus = ocfs2_modify_bh(lqinode, bh, olq_set_dquot, od);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\nout:\n\tbrelse(bh);\n\treturn status;\n}\n\n \nstatic struct ocfs2_quota_chunk *ocfs2_find_free_entry(struct super_block *sb,\n\t\t\t\t\t\t       int type,\n\t\t\t\t\t\t       int *offset)\n{\n\tstruct mem_dqinfo *info = sb_dqinfo(sb, type);\n\tstruct ocfs2_mem_dqinfo *oinfo = info->dqi_priv;\n\tstruct ocfs2_quota_chunk *chunk = NULL, *iter;\n\tstruct ocfs2_local_disk_chunk *dchunk;\n\tint found = 0, len;\n\n\tlist_for_each_entry(iter, &oinfo->dqi_chunk, qc_chunk) {\n\t\tdchunk = (struct ocfs2_local_disk_chunk *)\n\t\t\t\t\t\titer->qc_headerbh->b_data;\n\t\tif (le32_to_cpu(dchunk->dqc_free) > 0) {\n\t\t\tchunk = iter;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!chunk)\n\t\treturn NULL;\n\n\tif (chunk->qc_num < oinfo->dqi_chunks - 1) {\n\t\tlen = ol_chunk_entries(sb);\n\t} else {\n\t\tlen = (oinfo->dqi_blocks -\n\t\t       ol_quota_chunk_block(sb, chunk->qc_num) - 1)\n\t\t      * ol_quota_entries_per_block(sb);\n\t}\n\n\tfound = ocfs2_find_next_zero_bit_unaligned(dchunk->dqc_bitmap, len, 0);\n\t \n\tif (found == len) {\n\t\tmlog(ML_ERROR, \"Did not find empty entry in chunk %d with %u\"\n\t\t     \" entries free (type=%d)\\n\", chunk->qc_num,\n\t\t     le32_to_cpu(dchunk->dqc_free), type);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\t*offset = found;\n\treturn chunk;\n}\n\n \nstatic struct ocfs2_quota_chunk *ocfs2_local_quota_add_chunk(\n\t\t\t\t\t\t\tstruct super_block *sb,\n\t\t\t\t\t\t\tint type,\n\t\t\t\t\t\t\tint *offset)\n{\n\tstruct mem_dqinfo *info = sb_dqinfo(sb, type);\n\tstruct ocfs2_mem_dqinfo *oinfo = info->dqi_priv;\n\tstruct inode *lqinode = sb_dqopt(sb)->files[type];\n\tstruct ocfs2_quota_chunk *chunk = NULL;\n\tstruct ocfs2_local_disk_chunk *dchunk;\n\tint status;\n\thandle_t *handle;\n\tstruct buffer_head *bh = NULL, *dbh = NULL;\n\tu64 p_blkno;\n\n\t \n\tstatus = ocfs2_extend_no_holes(lqinode, NULL,\n\t\t\t\t       i_size_read(lqinode) + 2 * sb->s_blocksize,\n\t\t\t\t       i_size_read(lqinode));\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\tstatus = ocfs2_simple_size_update(lqinode, oinfo->dqi_lqi_bh,\n\t\t\t\t\t  i_size_read(lqinode) + 2 * sb->s_blocksize);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tchunk = kmem_cache_alloc(ocfs2_qf_chunk_cachep, GFP_NOFS);\n\tif (!chunk) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\t \n\thandle = ocfs2_start_trans(OCFS2_SB(sb),\n\t\t\tOCFS2_LOCAL_QINFO_WRITE_CREDITS +\n\t\t\t2 * OCFS2_QUOTA_BLOCK_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\t \n\tstatus = ocfs2_extent_map_get_blocks(lqinode, oinfo->dqi_blocks,\n\t\t\t\t\t     &p_blkno, NULL, NULL);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_trans;\n\t}\n\tbh = sb_getblk(sb, p_blkno);\n\tif (!bh) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto out_trans;\n\t}\n\tdchunk = (struct ocfs2_local_disk_chunk *)bh->b_data;\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(lqinode), bh);\n\tstatus = ocfs2_journal_access_dq(handle, INODE_CACHE(lqinode), bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_trans;\n\t}\n\tlock_buffer(bh);\n\tdchunk->dqc_free = cpu_to_le32(ol_quota_entries_per_block(sb));\n\tmemset(dchunk->dqc_bitmap, 0,\n\t       sb->s_blocksize - sizeof(struct ocfs2_local_disk_chunk) -\n\t       OCFS2_QBLK_RESERVED_SPACE);\n\tunlock_buffer(bh);\n\tocfs2_journal_dirty(handle, bh);\n\n\t \n\tstatus = ocfs2_extent_map_get_blocks(lqinode, oinfo->dqi_blocks + 1,\n\t\t\t\t\t     &p_blkno, NULL, NULL);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_trans;\n\t}\n\tdbh = sb_getblk(sb, p_blkno);\n\tif (!dbh) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto out_trans;\n\t}\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(lqinode), dbh);\n\tstatus = ocfs2_journal_access_dq(handle, INODE_CACHE(lqinode), dbh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_trans;\n\t}\n\tlock_buffer(dbh);\n\tmemset(dbh->b_data, 0, sb->s_blocksize - OCFS2_QBLK_RESERVED_SPACE);\n\tunlock_buffer(dbh);\n\tocfs2_journal_dirty(handle, dbh);\n\n\t \n\toinfo->dqi_blocks += 2;\n\toinfo->dqi_chunks++;\n\tstatus = ocfs2_local_write_info(sb, type);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_trans;\n\t}\n\tstatus = ocfs2_commit_trans(OCFS2_SB(sb), handle);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tlist_add_tail(&chunk->qc_chunk, &oinfo->dqi_chunk);\n\tchunk->qc_num = list_entry(chunk->qc_chunk.prev,\n\t\t\t\t   struct ocfs2_quota_chunk,\n\t\t\t\t   qc_chunk)->qc_num + 1;\n\tchunk->qc_headerbh = bh;\n\t*offset = 0;\n\treturn chunk;\nout_trans:\n\tocfs2_commit_trans(OCFS2_SB(sb), handle);\nout:\n\tbrelse(bh);\n\tbrelse(dbh);\n\tkmem_cache_free(ocfs2_qf_chunk_cachep, chunk);\n\treturn ERR_PTR(status);\n}\n\n \nstatic struct ocfs2_quota_chunk *ocfs2_extend_local_quota_file(\n\t\t\t\t\t\t       struct super_block *sb,\n\t\t\t\t\t\t       int type,\n\t\t\t\t\t\t       int *offset)\n{\n\tstruct mem_dqinfo *info = sb_dqinfo(sb, type);\n\tstruct ocfs2_mem_dqinfo *oinfo = info->dqi_priv;\n\tstruct ocfs2_quota_chunk *chunk;\n\tstruct inode *lqinode = sb_dqopt(sb)->files[type];\n\tstruct ocfs2_local_disk_chunk *dchunk;\n\tint epb = ol_quota_entries_per_block(sb);\n\tunsigned int chunk_blocks;\n\tstruct buffer_head *bh;\n\tu64 p_blkno;\n\tint status;\n\thandle_t *handle;\n\n\tif (list_empty(&oinfo->dqi_chunk))\n\t\treturn ocfs2_local_quota_add_chunk(sb, type, offset);\n\t \n\tchunk = list_entry(oinfo->dqi_chunk.prev,\n\t\t\tstruct ocfs2_quota_chunk, qc_chunk);\n\tchunk_blocks = oinfo->dqi_blocks -\n\t\t\tol_quota_chunk_block(sb, chunk->qc_num) - 1;\n\tif (ol_chunk_blocks(sb) == chunk_blocks)\n\t\treturn ocfs2_local_quota_add_chunk(sb, type, offset);\n\n\t \n\tstatus = ocfs2_extend_no_holes(lqinode, NULL,\n\t\t\t\t       i_size_read(lqinode) + sb->s_blocksize,\n\t\t\t\t       i_size_read(lqinode));\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\tstatus = ocfs2_simple_size_update(lqinode, oinfo->dqi_lqi_bh,\n\t\t\t\t\t  i_size_read(lqinode) + sb->s_blocksize);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\t \n\tstatus = ocfs2_extent_map_get_blocks(lqinode, oinfo->dqi_blocks,\n\t\t\t\t\t     &p_blkno, NULL, NULL);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\tbh = sb_getblk(sb, p_blkno);\n\tif (!bh) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(lqinode), bh);\n\n\t \n\thandle = ocfs2_start_trans(OCFS2_SB(sb),\n\t\t\tOCFS2_LOCAL_QINFO_WRITE_CREDITS +\n\t\t\t2 * OCFS2_QUOTA_BLOCK_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\t \n\tstatus = ocfs2_journal_access_dq(handle, INODE_CACHE(lqinode), bh,\n\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_trans;\n\t}\n\tlock_buffer(bh);\n\tmemset(bh->b_data, 0, sb->s_blocksize);\n\tunlock_buffer(bh);\n\tocfs2_journal_dirty(handle, bh);\n\n\t \n\tstatus = ocfs2_journal_access_dq(handle, INODE_CACHE(lqinode),\n\t\t\t\t\t chunk->qc_headerbh,\n\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_trans;\n\t}\n\n\tdchunk = (struct ocfs2_local_disk_chunk *)chunk->qc_headerbh->b_data;\n\tlock_buffer(chunk->qc_headerbh);\n\tle32_add_cpu(&dchunk->dqc_free, ol_quota_entries_per_block(sb));\n\tunlock_buffer(chunk->qc_headerbh);\n\tocfs2_journal_dirty(handle, chunk->qc_headerbh);\n\n\t \n\toinfo->dqi_blocks++;\n\tstatus = ocfs2_local_write_info(sb, type);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_trans;\n\t}\n\n\tstatus = ocfs2_commit_trans(OCFS2_SB(sb), handle);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\t*offset = chunk_blocks * epb;\n\treturn chunk;\nout_trans:\n\tocfs2_commit_trans(OCFS2_SB(sb), handle);\nout:\n\treturn ERR_PTR(status);\n}\n\nstatic void olq_alloc_dquot(struct buffer_head *bh, void *private)\n{\n\tint *offset = private;\n\tstruct ocfs2_local_disk_chunk *dchunk;\n\n\tdchunk = (struct ocfs2_local_disk_chunk *)bh->b_data;\n\tocfs2_set_bit_unaligned(*offset, dchunk->dqc_bitmap);\n\tle32_add_cpu(&dchunk->dqc_free, -1);\n}\n\n \nint ocfs2_create_local_dquot(struct dquot *dquot)\n{\n\tstruct super_block *sb = dquot->dq_sb;\n\tint type = dquot->dq_id.type;\n\tstruct inode *lqinode = sb_dqopt(sb)->files[type];\n\tstruct ocfs2_quota_chunk *chunk;\n\tstruct ocfs2_dquot *od = OCFS2_DQUOT(dquot);\n\tint offset;\n\tint status;\n\tu64 pcount;\n\n\tdown_write(&OCFS2_I(lqinode)->ip_alloc_sem);\n\tchunk = ocfs2_find_free_entry(sb, type, &offset);\n\tif (!chunk) {\n\t\tchunk = ocfs2_extend_local_quota_file(sb, type, &offset);\n\t\tif (IS_ERR(chunk)) {\n\t\t\tstatus = PTR_ERR(chunk);\n\t\t\tgoto out;\n\t\t}\n\t} else if (IS_ERR(chunk)) {\n\t\tstatus = PTR_ERR(chunk);\n\t\tgoto out;\n\t}\n\tod->dq_local_off = ol_dqblk_off(sb, chunk->qc_num, offset);\n\tod->dq_chunk = chunk;\n\tstatus = ocfs2_extent_map_get_blocks(lqinode,\n\t\t\t\t     ol_dqblk_block(sb, chunk->qc_num, offset),\n\t\t\t\t     &od->dq_local_phys_blk,\n\t\t\t\t     &pcount,\n\t\t\t\t     NULL);\n\n\t \n\tstatus = ocfs2_local_write_dquot(dquot);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\t \n\tstatus = ocfs2_modify_bh(lqinode, chunk->qc_headerbh, olq_alloc_dquot,\n\t\t\t\t &offset);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\nout:\n\tup_write(&OCFS2_I(lqinode)->ip_alloc_sem);\n\treturn status;\n}\n\n \nint ocfs2_local_release_dquot(handle_t *handle, struct dquot *dquot)\n{\n\tint status;\n\tint type = dquot->dq_id.type;\n\tstruct ocfs2_dquot *od = OCFS2_DQUOT(dquot);\n\tstruct super_block *sb = dquot->dq_sb;\n\tstruct ocfs2_local_disk_chunk *dchunk;\n\tint offset;\n\n\tstatus = ocfs2_journal_access_dq(handle,\n\t\t\tINODE_CACHE(sb_dqopt(sb)->files[type]),\n\t\t\tod->dq_chunk->qc_headerbh, OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\toffset = ol_dqblk_chunk_off(sb, od->dq_chunk->qc_num,\n\t\t\t\t\t     od->dq_local_off);\n\tdchunk = (struct ocfs2_local_disk_chunk *)\n\t\t\t(od->dq_chunk->qc_headerbh->b_data);\n\t \n\tlock_buffer(od->dq_chunk->qc_headerbh);\n\tocfs2_clear_bit_unaligned(offset, dchunk->dqc_bitmap);\n\tle32_add_cpu(&dchunk->dqc_free, 1);\n\tunlock_buffer(od->dq_chunk->qc_headerbh);\n\tocfs2_journal_dirty(handle, od->dq_chunk->qc_headerbh);\n\nout:\n\treturn status;\n}\n\nstatic const struct quota_format_ops ocfs2_format_ops = {\n\t.check_quota_file\t= ocfs2_local_check_quota_file,\n\t.read_file_info\t\t= ocfs2_local_read_info,\n\t.write_file_info\t= ocfs2_global_write_info,\n\t.free_file_info\t\t= ocfs2_local_free_info,\n};\n\nstruct quota_format_type ocfs2_quota_format = {\n\t.qf_fmt_id = QFMT_OCFS2,\n\t.qf_ops = &ocfs2_format_ops,\n\t.qf_owner = THIS_MODULE\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}