{
  "module_name": "dlmglue.c",
  "hash_id": "1263e8c178623f2fcf749192d709a3021f551630223752506644f681264b3090",
  "original_prompt": "Ingested from linux-6.6.14/fs/ocfs2/dlmglue.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/time.h>\n#include <linux/delay.h>\n#include <linux/quotaops.h>\n#include <linux/sched/signal.h>\n\n#define MLOG_MASK_PREFIX ML_DLM_GLUE\n#include <cluster/masklog.h>\n\n#include \"ocfs2.h\"\n#include \"ocfs2_lockingver.h\"\n\n#include \"alloc.h\"\n#include \"dcache.h\"\n#include \"dlmglue.h\"\n#include \"extent_map.h\"\n#include \"file.h\"\n#include \"heartbeat.h\"\n#include \"inode.h\"\n#include \"journal.h\"\n#include \"stackglue.h\"\n#include \"slot_map.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"refcounttree.h\"\n#include \"acl.h\"\n\n#include \"buffer_head_io.h\"\n\nstruct ocfs2_mask_waiter {\n\tstruct list_head\tmw_item;\n\tint\t\t\tmw_status;\n\tstruct completion\tmw_complete;\n\tunsigned long\t\tmw_mask;\n\tunsigned long\t\tmw_goal;\n#ifdef CONFIG_OCFS2_FS_STATS\n\tktime_t\t\t\tmw_lock_start;\n#endif\n};\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\n\n \nenum ocfs2_unblock_action {\n\tUNBLOCK_CONTINUE\t= 0,  \n\tUNBLOCK_CONTINUE_POST\t= 1,  \n\tUNBLOCK_STOP_POST\t= 2,  \n};\n\nstruct ocfs2_unblock_ctl {\n\tint requeue;\n\tenum ocfs2_unblock_action unblock_action;\n};\n\n \n#ifdef CONFIG_DEBUG_LOCK_ALLOC\nstatic struct lock_class_key lockdep_keys[OCFS2_NUM_LOCK_TYPES];\n#endif\n\nstatic int ocfs2_check_meta_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\tint new_level);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\n\nstatic int ocfs2_data_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t     int blocking);\n\nstatic int ocfs2_dentry_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t       int blocking);\n\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\n\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\n\nstatic int ocfs2_check_refcount_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t    int new_level);\nstatic int ocfs2_refcount_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t int blocking);\n\n#define mlog_meta_lvb(__level, __lockres) ocfs2_dump_meta_lvb_info(__level, __PRETTY_FUNCTION__, __LINE__, __lockres)\n\n \nstatic void ocfs2_dump_meta_lvb_info(u64 level,\n\t\t\t\t     const char *function,\n\t\t\t\t     unsigned int line,\n\t\t\t\t     struct ocfs2_lock_res *lockres)\n{\n\tstruct ocfs2_meta_lvb *lvb = ocfs2_dlm_lvb(&lockres->l_lksb);\n\n\tmlog(level, \"LVB information for %s (called from %s:%u):\\n\",\n\t     lockres->l_name, function, line);\n\tmlog(level, \"version: %u, clusters: %u, generation: 0x%x\\n\",\n\t     lvb->lvb_version, be32_to_cpu(lvb->lvb_iclusters),\n\t     be32_to_cpu(lvb->lvb_igeneration));\n\tmlog(level, \"size: %llu, uid %u, gid %u, mode 0x%x\\n\",\n\t     (unsigned long long)be64_to_cpu(lvb->lvb_isize),\n\t     be32_to_cpu(lvb->lvb_iuid), be32_to_cpu(lvb->lvb_igid),\n\t     be16_to_cpu(lvb->lvb_imode));\n\tmlog(level, \"nlink %u, atime_packed 0x%llx, ctime_packed 0x%llx, \"\n\t     \"mtime_packed 0x%llx iattr 0x%x\\n\", be16_to_cpu(lvb->lvb_inlink),\n\t     (long long)be64_to_cpu(lvb->lvb_iatime_packed),\n\t     (long long)be64_to_cpu(lvb->lvb_ictime_packed),\n\t     (long long)be64_to_cpu(lvb->lvb_imtime_packed),\n\t     be32_to_cpu(lvb->lvb_iattr));\n}\n\n\n \nstruct ocfs2_lock_res_ops {\n\t \n\tstruct ocfs2_super * (*get_osb)(struct ocfs2_lock_res *);\n\n\t \n\tvoid (*post_unlock)(struct ocfs2_super *, struct ocfs2_lock_res *);\n\n\t \n\tint (*check_downconvert)(struct ocfs2_lock_res *, int);\n\n\t \n\tvoid (*set_lvb)(struct ocfs2_lock_res *);\n\n\t \n\tint (*downconvert_worker)(struct ocfs2_lock_res *, int);\n\n\t \n\tint flags;\n};\n\n \n#define LOCK_TYPE_REQUIRES_REFRESH 0x1\n\n \n#define LOCK_TYPE_USES_LVB\t\t0x2\n\nstatic struct ocfs2_lock_res_ops ocfs2_inode_rw_lops = {\n\t.get_osb\t= ocfs2_get_inode_osb,\n\t.flags\t\t= 0,\n};\n\nstatic struct ocfs2_lock_res_ops ocfs2_inode_inode_lops = {\n\t.get_osb\t= ocfs2_get_inode_osb,\n\t.check_downconvert = ocfs2_check_meta_downconvert,\n\t.set_lvb\t= ocfs2_set_meta_lvb,\n\t.downconvert_worker = ocfs2_data_convert_worker,\n\t.flags\t\t= LOCK_TYPE_REQUIRES_REFRESH|LOCK_TYPE_USES_LVB,\n};\n\nstatic struct ocfs2_lock_res_ops ocfs2_super_lops = {\n\t.flags\t\t= LOCK_TYPE_REQUIRES_REFRESH,\n};\n\nstatic struct ocfs2_lock_res_ops ocfs2_rename_lops = {\n\t.flags\t\t= 0,\n};\n\nstatic struct ocfs2_lock_res_ops ocfs2_nfs_sync_lops = {\n\t.flags\t\t= 0,\n};\n\nstatic struct ocfs2_lock_res_ops ocfs2_trim_fs_lops = {\n\t.flags\t\t= LOCK_TYPE_REQUIRES_REFRESH|LOCK_TYPE_USES_LVB,\n};\n\nstatic struct ocfs2_lock_res_ops ocfs2_orphan_scan_lops = {\n\t.flags\t\t= LOCK_TYPE_REQUIRES_REFRESH|LOCK_TYPE_USES_LVB,\n};\n\nstatic struct ocfs2_lock_res_ops ocfs2_dentry_lops = {\n\t.get_osb\t= ocfs2_get_dentry_osb,\n\t.post_unlock\t= ocfs2_dentry_post_unlock,\n\t.downconvert_worker = ocfs2_dentry_convert_worker,\n\t.flags\t\t= 0,\n};\n\nstatic struct ocfs2_lock_res_ops ocfs2_inode_open_lops = {\n\t.get_osb\t= ocfs2_get_inode_osb,\n\t.flags\t\t= 0,\n};\n\nstatic struct ocfs2_lock_res_ops ocfs2_flock_lops = {\n\t.get_osb\t= ocfs2_get_file_osb,\n\t.flags\t\t= 0,\n};\n\nstatic struct ocfs2_lock_res_ops ocfs2_qinfo_lops = {\n\t.set_lvb\t= ocfs2_set_qinfo_lvb,\n\t.get_osb\t= ocfs2_get_qinfo_osb,\n\t.flags\t\t= LOCK_TYPE_REQUIRES_REFRESH | LOCK_TYPE_USES_LVB,\n};\n\nstatic struct ocfs2_lock_res_ops ocfs2_refcount_block_lops = {\n\t.check_downconvert = ocfs2_check_refcount_downconvert,\n\t.downconvert_worker = ocfs2_refcount_convert_worker,\n\t.flags\t\t= 0,\n};\n\nstatic inline int ocfs2_is_inode_lock(struct ocfs2_lock_res *lockres)\n{\n\treturn lockres->l_type == OCFS2_LOCK_TYPE_META ||\n\t\tlockres->l_type == OCFS2_LOCK_TYPE_RW ||\n\t\tlockres->l_type == OCFS2_LOCK_TYPE_OPEN;\n}\n\nstatic inline struct ocfs2_lock_res *ocfs2_lksb_to_lock_res(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn container_of(lksb, struct ocfs2_lock_res, l_lksb);\n}\n\nstatic inline struct inode *ocfs2_lock_res_inode(struct ocfs2_lock_res *lockres)\n{\n\tBUG_ON(!ocfs2_is_inode_lock(lockres));\n\n\treturn (struct inode *) lockres->l_priv;\n}\n\nstatic inline struct ocfs2_dentry_lock *ocfs2_lock_res_dl(struct ocfs2_lock_res *lockres)\n{\n\tBUG_ON(lockres->l_type != OCFS2_LOCK_TYPE_DENTRY);\n\n\treturn (struct ocfs2_dentry_lock *)lockres->l_priv;\n}\n\nstatic inline struct ocfs2_mem_dqinfo *ocfs2_lock_res_qinfo(struct ocfs2_lock_res *lockres)\n{\n\tBUG_ON(lockres->l_type != OCFS2_LOCK_TYPE_QINFO);\n\n\treturn (struct ocfs2_mem_dqinfo *)lockres->l_priv;\n}\n\nstatic inline struct ocfs2_refcount_tree *\nocfs2_lock_res_refcount_tree(struct ocfs2_lock_res *res)\n{\n\treturn container_of(res, struct ocfs2_refcount_tree, rf_lockres);\n}\n\nstatic inline struct ocfs2_super *ocfs2_get_lockres_osb(struct ocfs2_lock_res *lockres)\n{\n\tif (lockres->l_ops->get_osb)\n\t\treturn lockres->l_ops->get_osb(lockres);\n\n\treturn (struct ocfs2_super *)lockres->l_priv;\n}\n\nstatic int ocfs2_lock_create(struct ocfs2_super *osb,\n\t\t\t     struct ocfs2_lock_res *lockres,\n\t\t\t     int level,\n\t\t\t     u32 dlm_flags);\nstatic inline int ocfs2_may_continue_on_blocked_lock(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\t     int wanted);\nstatic void __ocfs2_cluster_unlock(struct ocfs2_super *osb,\n\t\t\t\t   struct ocfs2_lock_res *lockres,\n\t\t\t\t   int level, unsigned long caller_ip);\nstatic inline void ocfs2_cluster_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres,\n\t\t\t\t\tint level)\n{\n\t__ocfs2_cluster_unlock(osb, lockres, level, _RET_IP_);\n}\n\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_recover_from_dlm_error(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\tint convert);\n#define ocfs2_log_dlm_error(_func, _err, _lockres) do {\t\t\t\t\t\\\n\tif ((_lockres)->l_type != OCFS2_LOCK_TYPE_DENTRY)\t\t\t\t\\\n\t\tmlog(ML_ERROR, \"DLM error %d while calling %s on resource %s\\n\",\t\\\n\t\t     _err, _func, _lockres->l_name);\t\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\t\t\\\n\t\tmlog(ML_ERROR, \"DLM error %d while calling %s on resource %.*s%08x\\n\",\t\\\n\t\t     _err, _func, OCFS2_DENTRY_LOCK_INO_START - 1, (_lockres)->l_name,\t\\\n\t\t     (unsigned int)ocfs2_get_dentry_lock_ino(_lockres));\t\t\\\n} while (0)\nstatic int ocfs2_downconvert_thread(void *arg);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic unsigned int ocfs2_prepare_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t      int new_level);\nstatic int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\n\n\nstatic void ocfs2_build_lock_name(enum ocfs2_lock_type type,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 generation,\n\t\t\t\t  char *name)\n{\n\tint len;\n\n\tBUG_ON(type >= OCFS2_NUM_LOCK_TYPES);\n\n\tlen = snprintf(name, OCFS2_LOCK_ID_MAX_LEN, \"%c%s%016llx%08x\",\n\t\t       ocfs2_lock_type_char(type), OCFS2_LOCK_ID_PAD,\n\t\t       (long long)blkno, generation);\n\n\tBUG_ON(len != (OCFS2_LOCK_ID_MAX_LEN - 1));\n\n\tmlog(0, \"built lock resource with name: %s\\n\", name);\n}\n\nstatic DEFINE_SPINLOCK(ocfs2_dlm_tracking_lock);\n\nstatic void ocfs2_add_lockres_tracking(struct ocfs2_lock_res *res,\n\t\t\t\t       struct ocfs2_dlm_debug *dlm_debug)\n{\n\tmlog(0, \"Add tracking for lockres %s\\n\", res->l_name);\n\n\tspin_lock(&ocfs2_dlm_tracking_lock);\n\tlist_add(&res->l_debug_list, &dlm_debug->d_lockres_tracking);\n\tspin_unlock(&ocfs2_dlm_tracking_lock);\n}\n\nstatic void ocfs2_remove_lockres_tracking(struct ocfs2_lock_res *res)\n{\n\tspin_lock(&ocfs2_dlm_tracking_lock);\n\tif (!list_empty(&res->l_debug_list))\n\t\tlist_del_init(&res->l_debug_list);\n\tspin_unlock(&ocfs2_dlm_tracking_lock);\n}\n\n#ifdef CONFIG_OCFS2_FS_STATS\nstatic void ocfs2_init_lock_stats(struct ocfs2_lock_res *res)\n{\n\tres->l_lock_refresh = 0;\n\tres->l_lock_wait = 0;\n\tmemset(&res->l_lock_prmode, 0, sizeof(struct ocfs2_lock_stats));\n\tmemset(&res->l_lock_exmode, 0, sizeof(struct ocfs2_lock_stats));\n}\n\nstatic void ocfs2_update_lock_stats(struct ocfs2_lock_res *res, int level,\n\t\t\t\t    struct ocfs2_mask_waiter *mw, int ret)\n{\n\tu32 usec;\n\tktime_t kt;\n\tstruct ocfs2_lock_stats *stats;\n\n\tif (level == LKM_PRMODE)\n\t\tstats = &res->l_lock_prmode;\n\telse if (level == LKM_EXMODE)\n\t\tstats = &res->l_lock_exmode;\n\telse\n\t\treturn;\n\n\tkt = ktime_sub(ktime_get(), mw->mw_lock_start);\n\tusec = ktime_to_us(kt);\n\n\tstats->ls_gets++;\n\tstats->ls_total += ktime_to_ns(kt);\n\t \n\tif (unlikely(stats->ls_gets == 0)) {\n\t\tstats->ls_gets++;\n\t\tstats->ls_total = ktime_to_ns(kt);\n\t}\n\n\tif (stats->ls_max < usec)\n\t\tstats->ls_max = usec;\n\n\tif (ret)\n\t\tstats->ls_fail++;\n\n\tstats->ls_last = ktime_to_us(ktime_get_real());\n}\n\nstatic inline void ocfs2_track_lock_refresh(struct ocfs2_lock_res *lockres)\n{\n\tlockres->l_lock_refresh++;\n}\n\nstatic inline void ocfs2_track_lock_wait(struct ocfs2_lock_res *lockres)\n{\n\tstruct ocfs2_mask_waiter *mw;\n\n\tif (list_empty(&lockres->l_mask_waiters)) {\n\t\tlockres->l_lock_wait = 0;\n\t\treturn;\n\t}\n\n\tmw = list_first_entry(&lockres->l_mask_waiters,\n\t\t\t\tstruct ocfs2_mask_waiter, mw_item);\n\tlockres->l_lock_wait =\n\t\t\tktime_to_us(ktime_mono_to_real(mw->mw_lock_start));\n}\n\nstatic inline void ocfs2_init_start_time(struct ocfs2_mask_waiter *mw)\n{\n\tmw->mw_lock_start = ktime_get();\n}\n#else\nstatic inline void ocfs2_init_lock_stats(struct ocfs2_lock_res *res)\n{\n}\nstatic inline void ocfs2_update_lock_stats(struct ocfs2_lock_res *res,\n\t\t\t   int level, struct ocfs2_mask_waiter *mw, int ret)\n{\n}\nstatic inline void ocfs2_track_lock_refresh(struct ocfs2_lock_res *lockres)\n{\n}\nstatic inline void ocfs2_track_lock_wait(struct ocfs2_lock_res *lockres)\n{\n}\nstatic inline void ocfs2_init_start_time(struct ocfs2_mask_waiter *mw)\n{\n}\n#endif\n\nstatic void ocfs2_lock_res_init_common(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *res,\n\t\t\t\t       enum ocfs2_lock_type type,\n\t\t\t\t       struct ocfs2_lock_res_ops *ops,\n\t\t\t\t       void *priv)\n{\n\tres->l_type          = type;\n\tres->l_ops           = ops;\n\tres->l_priv          = priv;\n\n\tres->l_level         = DLM_LOCK_IV;\n\tres->l_requested     = DLM_LOCK_IV;\n\tres->l_blocking      = DLM_LOCK_IV;\n\tres->l_action        = OCFS2_AST_INVALID;\n\tres->l_unlock_action = OCFS2_UNLOCK_INVALID;\n\n\tres->l_flags         = OCFS2_LOCK_INITIALIZED;\n\n\tocfs2_add_lockres_tracking(res, osb->osb_dlm_debug);\n\n\tocfs2_init_lock_stats(res);\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type != OCFS2_LOCK_TYPE_OPEN)\n\t\tlockdep_init_map(&res->l_lockdep_map, ocfs2_lock_type_strings[type],\n\t\t\t\t &lockdep_keys[type], 0);\n\telse\n\t\tres->l_lockdep_map.key = NULL;\n#endif\n}\n\nvoid ocfs2_lock_res_init_once(struct ocfs2_lock_res *res)\n{\n\t \n\tmemset(res, 0, sizeof(struct ocfs2_lock_res));\n\tspin_lock_init(&res->l_lock);\n\tinit_waitqueue_head(&res->l_event);\n\tINIT_LIST_HEAD(&res->l_blocked_list);\n\tINIT_LIST_HEAD(&res->l_mask_waiters);\n\tINIT_LIST_HEAD(&res->l_holders);\n}\n\nvoid ocfs2_inode_lock_res_init(struct ocfs2_lock_res *res,\n\t\t\t       enum ocfs2_lock_type type,\n\t\t\t       unsigned int generation,\n\t\t\t       struct inode *inode)\n{\n\tstruct ocfs2_lock_res_ops *ops;\n\n\tswitch(type) {\n\t\tcase OCFS2_LOCK_TYPE_RW:\n\t\t\tops = &ocfs2_inode_rw_lops;\n\t\t\tbreak;\n\t\tcase OCFS2_LOCK_TYPE_META:\n\t\t\tops = &ocfs2_inode_inode_lops;\n\t\t\tbreak;\n\t\tcase OCFS2_LOCK_TYPE_OPEN:\n\t\t\tops = &ocfs2_inode_open_lops;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmlog_bug_on_msg(1, \"type: %d\\n\", type);\n\t\t\tops = NULL;  \n\t\t\tbreak;\n\t}\n\n\tocfs2_build_lock_name(type, OCFS2_I(inode)->ip_blkno,\n\t\t\t      generation, res->l_name);\n\tocfs2_lock_res_init_common(OCFS2_SB(inode->i_sb), res, type, ops, inode);\n}\n\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres)\n{\n\tstruct inode *inode = ocfs2_lock_res_inode(lockres);\n\n\treturn OCFS2_SB(inode->i_sb);\n}\n\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres)\n{\n\tstruct ocfs2_mem_dqinfo *info = lockres->l_priv;\n\n\treturn OCFS2_SB(info->dqi_gi.dqi_sb);\n}\n\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres)\n{\n\tstruct ocfs2_file_private *fp = lockres->l_priv;\n\n\treturn OCFS2_SB(fp->fp_file->f_mapping->host->i_sb);\n}\n\nstatic __u64 ocfs2_get_dentry_lock_ino(struct ocfs2_lock_res *lockres)\n{\n\t__be64 inode_blkno_be;\n\n\tmemcpy(&inode_blkno_be, &lockres->l_name[OCFS2_DENTRY_LOCK_INO_START],\n\t       sizeof(__be64));\n\n\treturn be64_to_cpu(inode_blkno_be);\n}\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres)\n{\n\tstruct ocfs2_dentry_lock *dl = lockres->l_priv;\n\n\treturn OCFS2_SB(dl->dl_inode->i_sb);\n}\n\nvoid ocfs2_dentry_lock_res_init(struct ocfs2_dentry_lock *dl,\n\t\t\t\tu64 parent, struct inode *inode)\n{\n\tint len;\n\tu64 inode_blkno = OCFS2_I(inode)->ip_blkno;\n\t__be64 inode_blkno_be = cpu_to_be64(inode_blkno);\n\tstruct ocfs2_lock_res *lockres = &dl->dl_lockres;\n\n\tocfs2_lock_res_init_once(lockres);\n\n\t \n\tlen = snprintf(lockres->l_name, OCFS2_DENTRY_LOCK_INO_START,\n\t\t       \"%c%016llx\",\n\t\t       ocfs2_lock_type_char(OCFS2_LOCK_TYPE_DENTRY),\n\t\t       (long long)parent);\n\n\tBUG_ON(len != (OCFS2_DENTRY_LOCK_INO_START - 1));\n\n\tmemcpy(&lockres->l_name[OCFS2_DENTRY_LOCK_INO_START], &inode_blkno_be,\n\t       sizeof(__be64));\n\n\tocfs2_lock_res_init_common(OCFS2_SB(inode->i_sb), lockres,\n\t\t\t\t   OCFS2_LOCK_TYPE_DENTRY, &ocfs2_dentry_lops,\n\t\t\t\t   dl);\n}\n\nstatic void ocfs2_super_lock_res_init(struct ocfs2_lock_res *res,\n\t\t\t\t      struct ocfs2_super *osb)\n{\n\t \n\tocfs2_lock_res_init_once(res);\n\tocfs2_build_lock_name(OCFS2_LOCK_TYPE_SUPER, OCFS2_SUPER_BLOCK_BLKNO,\n\t\t\t      0, res->l_name);\n\tocfs2_lock_res_init_common(osb, res, OCFS2_LOCK_TYPE_SUPER,\n\t\t\t\t   &ocfs2_super_lops, osb);\n}\n\nstatic void ocfs2_rename_lock_res_init(struct ocfs2_lock_res *res,\n\t\t\t\t       struct ocfs2_super *osb)\n{\n\t \n\tocfs2_lock_res_init_once(res);\n\tocfs2_build_lock_name(OCFS2_LOCK_TYPE_RENAME, 0, 0, res->l_name);\n\tocfs2_lock_res_init_common(osb, res, OCFS2_LOCK_TYPE_RENAME,\n\t\t\t\t   &ocfs2_rename_lops, osb);\n}\n\nstatic void ocfs2_nfs_sync_lock_res_init(struct ocfs2_lock_res *res,\n\t\t\t\t\t struct ocfs2_super *osb)\n{\n\t \n\tocfs2_lock_res_init_once(res);\n\tocfs2_build_lock_name(OCFS2_LOCK_TYPE_NFS_SYNC, 0, 0, res->l_name);\n\tocfs2_lock_res_init_common(osb, res, OCFS2_LOCK_TYPE_NFS_SYNC,\n\t\t\t\t   &ocfs2_nfs_sync_lops, osb);\n}\n\nstatic void ocfs2_nfs_sync_lock_init(struct ocfs2_super *osb)\n{\n\tocfs2_nfs_sync_lock_res_init(&osb->osb_nfs_sync_lockres, osb);\n\tinit_rwsem(&osb->nfs_sync_rwlock);\n}\n\nvoid ocfs2_trim_fs_lock_res_init(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_lock_res *lockres = &osb->osb_trim_fs_lockres;\n\n\t \n\tmutex_lock(&osb->obs_trim_fs_mutex);\n\n\tocfs2_lock_res_init_once(lockres);\n\tocfs2_build_lock_name(OCFS2_LOCK_TYPE_TRIM_FS, 0, 0, lockres->l_name);\n\tocfs2_lock_res_init_common(osb, lockres, OCFS2_LOCK_TYPE_TRIM_FS,\n\t\t\t\t   &ocfs2_trim_fs_lops, osb);\n}\n\nvoid ocfs2_trim_fs_lock_res_uninit(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_lock_res *lockres = &osb->osb_trim_fs_lockres;\n\n\tocfs2_simple_drop_lockres(osb, lockres);\n\tocfs2_lock_res_free(lockres);\n\n\tmutex_unlock(&osb->obs_trim_fs_mutex);\n}\n\nstatic void ocfs2_orphan_scan_lock_res_init(struct ocfs2_lock_res *res,\n\t\t\t\t\t    struct ocfs2_super *osb)\n{\n\tocfs2_lock_res_init_once(res);\n\tocfs2_build_lock_name(OCFS2_LOCK_TYPE_ORPHAN_SCAN, 0, 0, res->l_name);\n\tocfs2_lock_res_init_common(osb, res, OCFS2_LOCK_TYPE_ORPHAN_SCAN,\n\t\t\t\t   &ocfs2_orphan_scan_lops, osb);\n}\n\nvoid ocfs2_file_lock_res_init(struct ocfs2_lock_res *lockres,\n\t\t\t      struct ocfs2_file_private *fp)\n{\n\tstruct inode *inode = fp->fp_file->f_mapping->host;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\tocfs2_lock_res_init_once(lockres);\n\tocfs2_build_lock_name(OCFS2_LOCK_TYPE_FLOCK, oi->ip_blkno,\n\t\t\t      inode->i_generation, lockres->l_name);\n\tocfs2_lock_res_init_common(OCFS2_SB(inode->i_sb), lockres,\n\t\t\t\t   OCFS2_LOCK_TYPE_FLOCK, &ocfs2_flock_lops,\n\t\t\t\t   fp);\n\tlockres->l_flags |= OCFS2_LOCK_NOCACHE;\n}\n\nvoid ocfs2_qinfo_lock_res_init(struct ocfs2_lock_res *lockres,\n\t\t\t       struct ocfs2_mem_dqinfo *info)\n{\n\tocfs2_lock_res_init_once(lockres);\n\tocfs2_build_lock_name(OCFS2_LOCK_TYPE_QINFO, info->dqi_gi.dqi_type,\n\t\t\t      0, lockres->l_name);\n\tocfs2_lock_res_init_common(OCFS2_SB(info->dqi_gi.dqi_sb), lockres,\n\t\t\t\t   OCFS2_LOCK_TYPE_QINFO, &ocfs2_qinfo_lops,\n\t\t\t\t   info);\n}\n\nvoid ocfs2_refcount_lock_res_init(struct ocfs2_lock_res *lockres,\n\t\t\t\t  struct ocfs2_super *osb, u64 ref_blkno,\n\t\t\t\t  unsigned int generation)\n{\n\tocfs2_lock_res_init_once(lockres);\n\tocfs2_build_lock_name(OCFS2_LOCK_TYPE_REFCOUNT, ref_blkno,\n\t\t\t      generation, lockres->l_name);\n\tocfs2_lock_res_init_common(osb, lockres, OCFS2_LOCK_TYPE_REFCOUNT,\n\t\t\t\t   &ocfs2_refcount_block_lops, osb);\n}\n\nvoid ocfs2_lock_res_free(struct ocfs2_lock_res *res)\n{\n\tif (!(res->l_flags & OCFS2_LOCK_INITIALIZED))\n\t\treturn;\n\n\tocfs2_remove_lockres_tracking(res);\n\n\tmlog_bug_on_msg(!list_empty(&res->l_blocked_list),\n\t\t\t\"Lockres %s is on the blocked list\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(!list_empty(&res->l_mask_waiters),\n\t\t\t\"Lockres %s has mask waiters pending\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(spin_is_locked(&res->l_lock),\n\t\t\t\"Lockres %s is locked\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(res->l_ro_holders,\n\t\t\t\"Lockres %s has %u ro holders\\n\",\n\t\t\tres->l_name, res->l_ro_holders);\n\tmlog_bug_on_msg(res->l_ex_holders,\n\t\t\t\"Lockres %s has %u ex holders\\n\",\n\t\t\tres->l_name, res->l_ex_holders);\n\n\t \n\tmemset(&res->l_lksb, 0, sizeof(res->l_lksb));\n\n\tres->l_flags = 0UL;\n}\n\n \nstatic inline void ocfs2_add_holder(struct ocfs2_lock_res *lockres,\n\t\t\t\t   struct ocfs2_lock_holder *oh)\n{\n\tINIT_LIST_HEAD(&oh->oh_list);\n\toh->oh_owner_pid = get_pid(task_pid(current));\n\n\tspin_lock(&lockres->l_lock);\n\tlist_add_tail(&oh->oh_list, &lockres->l_holders);\n\tspin_unlock(&lockres->l_lock);\n}\n\nstatic struct ocfs2_lock_holder *\nocfs2_pid_holder(struct ocfs2_lock_res *lockres,\n\t\tstruct pid *pid)\n{\n\tstruct ocfs2_lock_holder *oh;\n\n\tspin_lock(&lockres->l_lock);\n\tlist_for_each_entry(oh, &lockres->l_holders, oh_list) {\n\t\tif (oh->oh_owner_pid == pid) {\n\t\t\tspin_unlock(&lockres->l_lock);\n\t\t\treturn oh;\n\t\t}\n\t}\n\tspin_unlock(&lockres->l_lock);\n\treturn NULL;\n}\n\nstatic inline void ocfs2_remove_holder(struct ocfs2_lock_res *lockres,\n\t\t\t\t       struct ocfs2_lock_holder *oh)\n{\n\tspin_lock(&lockres->l_lock);\n\tlist_del(&oh->oh_list);\n\tspin_unlock(&lockres->l_lock);\n\n\tput_pid(oh->oh_owner_pid);\n}\n\n\nstatic inline void ocfs2_inc_holders(struct ocfs2_lock_res *lockres,\n\t\t\t\t     int level)\n{\n\tBUG_ON(!lockres);\n\n\tswitch(level) {\n\tcase DLM_LOCK_EX:\n\t\tlockres->l_ex_holders++;\n\t\tbreak;\n\tcase DLM_LOCK_PR:\n\t\tlockres->l_ro_holders++;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}\n\nstatic inline void ocfs2_dec_holders(struct ocfs2_lock_res *lockres,\n\t\t\t\t     int level)\n{\n\tBUG_ON(!lockres);\n\n\tswitch(level) {\n\tcase DLM_LOCK_EX:\n\t\tBUG_ON(!lockres->l_ex_holders);\n\t\tlockres->l_ex_holders--;\n\t\tbreak;\n\tcase DLM_LOCK_PR:\n\t\tBUG_ON(!lockres->l_ro_holders);\n\t\tlockres->l_ro_holders--;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}\n\n \nstatic inline int ocfs2_highest_compat_lock_level(int level)\n{\n\tint new_level = DLM_LOCK_EX;\n\n\tif (level == DLM_LOCK_EX)\n\t\tnew_level = DLM_LOCK_NL;\n\telse if (level == DLM_LOCK_PR)\n\t\tnew_level = DLM_LOCK_PR;\n\treturn new_level;\n}\n\nstatic void lockres_set_flags(struct ocfs2_lock_res *lockres,\n\t\t\t      unsigned long newflags)\n{\n\tstruct ocfs2_mask_waiter *mw, *tmp;\n\n \tassert_spin_locked(&lockres->l_lock);\n\n\tlockres->l_flags = newflags;\n\n\tlist_for_each_entry_safe(mw, tmp, &lockres->l_mask_waiters, mw_item) {\n\t\tif ((lockres->l_flags & mw->mw_mask) != mw->mw_goal)\n\t\t\tcontinue;\n\n\t\tlist_del_init(&mw->mw_item);\n\t\tmw->mw_status = 0;\n\t\tcomplete(&mw->mw_complete);\n\t\tocfs2_track_lock_wait(lockres);\n\t}\n}\nstatic void lockres_or_flags(struct ocfs2_lock_res *lockres, unsigned long or)\n{\n\tlockres_set_flags(lockres, lockres->l_flags | or);\n}\nstatic void lockres_clear_flags(struct ocfs2_lock_res *lockres,\n\t\t\t\tunsigned long clear)\n{\n\tlockres_set_flags(lockres, lockres->l_flags & ~clear);\n}\n\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres)\n{\n\tBUG_ON(!(lockres->l_flags & OCFS2_LOCK_BUSY));\n\tBUG_ON(!(lockres->l_flags & OCFS2_LOCK_ATTACHED));\n\tBUG_ON(!(lockres->l_flags & OCFS2_LOCK_BLOCKED));\n\tBUG_ON(lockres->l_blocking <= DLM_LOCK_NL);\n\n\tlockres->l_level = lockres->l_requested;\n\tif (lockres->l_level <=\n\t    ocfs2_highest_compat_lock_level(lockres->l_blocking)) {\n\t\tlockres->l_blocking = DLM_LOCK_NL;\n\t\tlockres_clear_flags(lockres, OCFS2_LOCK_BLOCKED);\n\t}\n\tlockres_clear_flags(lockres, OCFS2_LOCK_BUSY);\n}\n\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres)\n{\n\tBUG_ON(!(lockres->l_flags & OCFS2_LOCK_BUSY));\n\tBUG_ON(!(lockres->l_flags & OCFS2_LOCK_ATTACHED));\n\n\t \n\tif (lockres->l_level == DLM_LOCK_NL &&\n\t    lockres->l_ops->flags & LOCK_TYPE_REQUIRES_REFRESH)\n\t\tlockres_or_flags(lockres, OCFS2_LOCK_NEEDS_REFRESH);\n\n\tlockres->l_level = lockres->l_requested;\n\n\t \n\tif (!(lockres->l_flags & OCFS2_LOCK_NONBLOCK_FINISHED))\n\t\tlockres_or_flags(lockres, OCFS2_LOCK_UPCONVERT_FINISHING);\n\telse\n\t\tlockres_clear_flags(lockres, OCFS2_LOCK_NONBLOCK_FINISHED);\n\n\tlockres_clear_flags(lockres, OCFS2_LOCK_BUSY);\n}\n\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres)\n{\n\tBUG_ON((!(lockres->l_flags & OCFS2_LOCK_BUSY)));\n\tBUG_ON(lockres->l_flags & OCFS2_LOCK_ATTACHED);\n\n\tif (lockres->l_requested > DLM_LOCK_NL &&\n\t    !(lockres->l_flags & OCFS2_LOCK_LOCAL) &&\n\t    lockres->l_ops->flags & LOCK_TYPE_REQUIRES_REFRESH)\n\t\tlockres_or_flags(lockres, OCFS2_LOCK_NEEDS_REFRESH);\n\n\tlockres->l_level = lockres->l_requested;\n\tlockres_or_flags(lockres, OCFS2_LOCK_ATTACHED);\n\tlockres_clear_flags(lockres, OCFS2_LOCK_BUSY);\n}\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres,\n\t\t\t\t     int level)\n{\n\tint needs_downconvert = 0;\n\n\tassert_spin_locked(&lockres->l_lock);\n\n\tif (level > lockres->l_blocking) {\n\t\t \n\t\tif (ocfs2_highest_compat_lock_level(level) <\n\t\t    ocfs2_highest_compat_lock_level(lockres->l_blocking))\n\t\t\tneeds_downconvert = 1;\n\n\t\tlockres->l_blocking = level;\n\t}\n\n\tmlog(ML_BASTS, \"lockres %s, block %d, level %d, l_block %d, dwn %d\\n\",\n\t     lockres->l_name, level, lockres->l_level, lockres->l_blocking,\n\t     needs_downconvert);\n\n\tif (needs_downconvert)\n\t\tlockres_or_flags(lockres, OCFS2_LOCK_BLOCKED);\n\tmlog(0, \"needs_downconvert = %d\\n\", needs_downconvert);\n\treturn needs_downconvert;\n}\n\n \n\n \nstatic void __lockres_clear_pending(struct ocfs2_lock_res *lockres,\n\t\t\t\t    unsigned int generation,\n\t\t\t\t    struct ocfs2_super *osb)\n{\n\tassert_spin_locked(&lockres->l_lock);\n\n\t \n\tif (!(lockres->l_flags & OCFS2_LOCK_PENDING) ||\n\t    (lockres->l_pending_gen != generation))\n\t\treturn;\n\n\tlockres_clear_flags(lockres, OCFS2_LOCK_PENDING);\n\tlockres->l_pending_gen++;\n\n\t \n\tif (lockres->l_flags & OCFS2_LOCK_BLOCKED)\n\t\tocfs2_wake_downconvert_thread(osb);\n}\n\n \nstatic void lockres_clear_pending(struct ocfs2_lock_res *lockres,\n\t\t\t\t  unsigned int generation,\n\t\t\t\t  struct ocfs2_super *osb)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\t__lockres_clear_pending(lockres, generation, osb);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n}\n\nstatic unsigned int lockres_set_pending(struct ocfs2_lock_res *lockres)\n{\n\tassert_spin_locked(&lockres->l_lock);\n\tBUG_ON(!(lockres->l_flags & OCFS2_LOCK_BUSY));\n\n\tlockres_or_flags(lockres, OCFS2_LOCK_PENDING);\n\n\treturn lockres->l_pending_gen;\n}\n\nstatic void ocfs2_blocking_ast(struct ocfs2_dlm_lksb *lksb, int level)\n{\n\tstruct ocfs2_lock_res *lockres = ocfs2_lksb_to_lock_res(lksb);\n\tstruct ocfs2_super *osb = ocfs2_get_lockres_osb(lockres);\n\tint needs_downconvert;\n\tunsigned long flags;\n\n\tBUG_ON(level <= DLM_LOCK_NL);\n\n\tmlog(ML_BASTS, \"BAST fired for lockres %s, blocking %d, level %d, \"\n\t     \"type %s\\n\", lockres->l_name, level, lockres->l_level,\n\t     ocfs2_lock_type_string(lockres->l_type));\n\n\t \n\tif (lockres->l_flags & OCFS2_LOCK_NOCACHE)\n\t\treturn;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tneeds_downconvert = ocfs2_generic_handle_bast(lockres, level);\n\tif (needs_downconvert)\n\t\tocfs2_schedule_blocked_lock(osb, lockres);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\twake_up(&lockres->l_event);\n\n\tocfs2_wake_downconvert_thread(osb);\n}\n\nstatic void ocfs2_locking_ast(struct ocfs2_dlm_lksb *lksb)\n{\n\tstruct ocfs2_lock_res *lockres = ocfs2_lksb_to_lock_res(lksb);\n\tstruct ocfs2_super *osb = ocfs2_get_lockres_osb(lockres);\n\tunsigned long flags;\n\tint status;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\n\tstatus = ocfs2_dlm_lock_status(&lockres->l_lksb);\n\n\tif (status == -EAGAIN) {\n\t\tlockres_clear_flags(lockres, OCFS2_LOCK_BUSY);\n\t\tgoto out;\n\t}\n\n\tif (status) {\n\t\tmlog(ML_ERROR, \"lockres %s: lksb status value of %d!\\n\",\n\t\t     lockres->l_name, status);\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\treturn;\n\t}\n\n\tmlog(ML_BASTS, \"AST fired for lockres %s, action %d, unlock %d, \"\n\t     \"level %d => %d\\n\", lockres->l_name, lockres->l_action,\n\t     lockres->l_unlock_action, lockres->l_level, lockres->l_requested);\n\n\tswitch(lockres->l_action) {\n\tcase OCFS2_AST_ATTACH:\n\t\tocfs2_generic_handle_attach_action(lockres);\n\t\tlockres_clear_flags(lockres, OCFS2_LOCK_LOCAL);\n\t\tbreak;\n\tcase OCFS2_AST_CONVERT:\n\t\tocfs2_generic_handle_convert_action(lockres);\n\t\tbreak;\n\tcase OCFS2_AST_DOWNCONVERT:\n\t\tocfs2_generic_handle_downconvert_action(lockres);\n\t\tbreak;\n\tdefault:\n\t\tmlog(ML_ERROR, \"lockres %s: AST fired with invalid action: %u, \"\n\t\t     \"flags 0x%lx, unlock: %u\\n\",\n\t\t     lockres->l_name, lockres->l_action, lockres->l_flags,\n\t\t     lockres->l_unlock_action);\n\t\tBUG();\n\t}\nout:\n\t \n\tlockres->l_action = OCFS2_AST_INVALID;\n\n\t \n\tif (lockres->l_unlock_action == OCFS2_UNLOCK_CANCEL_CONVERT)\n\t\tlockres->l_unlock_action = OCFS2_UNLOCK_INVALID;\n\n\t \n\t__lockres_clear_pending(lockres, lockres->l_pending_gen,  osb);\n\n\twake_up(&lockres->l_event);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n}\n\nstatic void ocfs2_unlock_ast(struct ocfs2_dlm_lksb *lksb, int error)\n{\n\tstruct ocfs2_lock_res *lockres = ocfs2_lksb_to_lock_res(lksb);\n\tunsigned long flags;\n\n\tmlog(ML_BASTS, \"UNLOCK AST fired for lockres %s, action = %d\\n\",\n\t     lockres->l_name, lockres->l_unlock_action);\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tif (error) {\n\t\tmlog(ML_ERROR, \"Dlm passes error %d for lock %s, \"\n\t\t     \"unlock_action %d\\n\", error, lockres->l_name,\n\t\t     lockres->l_unlock_action);\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\treturn;\n\t}\n\n\tswitch(lockres->l_unlock_action) {\n\tcase OCFS2_UNLOCK_CANCEL_CONVERT:\n\t\tmlog(0, \"Cancel convert success for %s\\n\", lockres->l_name);\n\t\tlockres->l_action = OCFS2_AST_INVALID;\n\t\t \n\t\tif (lockres->l_flags & OCFS2_LOCK_BLOCKED)\n\t\t\tocfs2_wake_downconvert_thread(ocfs2_get_lockres_osb(lockres));\n\t\tbreak;\n\tcase OCFS2_UNLOCK_DROP_LOCK:\n\t\tlockres->l_level = DLM_LOCK_IV;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tlockres_clear_flags(lockres, OCFS2_LOCK_BUSY);\n\tlockres->l_unlock_action = OCFS2_UNLOCK_INVALID;\n\twake_up(&lockres->l_event);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n}\n\n \nstatic struct ocfs2_locking_protocol lproto = {\n\t.lp_max_version = {\n\t\t.pv_major = OCFS2_LOCKING_PROTOCOL_MAJOR,\n\t\t.pv_minor = OCFS2_LOCKING_PROTOCOL_MINOR,\n\t},\n\t.lp_lock_ast\t\t= ocfs2_locking_ast,\n\t.lp_blocking_ast\t= ocfs2_blocking_ast,\n\t.lp_unlock_ast\t\t= ocfs2_unlock_ast,\n};\n\nvoid ocfs2_set_locking_protocol(void)\n{\n\tocfs2_stack_glue_set_max_proto_version(&lproto.lp_max_version);\n}\n\nstatic inline void ocfs2_recover_from_dlm_error(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\tint convert)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tlockres_clear_flags(lockres, OCFS2_LOCK_BUSY);\n\tlockres_clear_flags(lockres, OCFS2_LOCK_UPCONVERT_FINISHING);\n\tif (convert)\n\t\tlockres->l_action = OCFS2_AST_INVALID;\n\telse\n\t\tlockres->l_unlock_action = OCFS2_UNLOCK_INVALID;\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\twake_up(&lockres->l_event);\n}\n\n \nstatic int ocfs2_lock_create(struct ocfs2_super *osb,\n\t\t\t     struct ocfs2_lock_res *lockres,\n\t\t\t     int level,\n\t\t\t     u32 dlm_flags)\n{\n\tint ret = 0;\n\tunsigned long flags;\n\tunsigned int gen;\n\n\tmlog(0, \"lock %s, level = %d, flags = %u\\n\", lockres->l_name, level,\n\t     dlm_flags);\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tif ((lockres->l_flags & OCFS2_LOCK_ATTACHED) ||\n\t    (lockres->l_flags & OCFS2_LOCK_BUSY)) {\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\tgoto bail;\n\t}\n\n\tlockres->l_action = OCFS2_AST_ATTACH;\n\tlockres->l_requested = level;\n\tlockres_or_flags(lockres, OCFS2_LOCK_BUSY);\n\tgen = lockres_set_pending(lockres);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\tret = ocfs2_dlm_lock(osb->cconn,\n\t\t\t     level,\n\t\t\t     &lockres->l_lksb,\n\t\t\t     dlm_flags,\n\t\t\t     lockres->l_name,\n\t\t\t     OCFS2_LOCK_ID_MAX_LEN - 1);\n\tlockres_clear_pending(lockres, gen, osb);\n\tif (ret) {\n\t\tocfs2_log_dlm_error(\"ocfs2_dlm_lock\", ret, lockres);\n\t\tocfs2_recover_from_dlm_error(lockres, 1);\n\t}\n\n\tmlog(0, \"lock %s, return from ocfs2_dlm_lock\\n\", lockres->l_name);\n\nbail:\n\treturn ret;\n}\n\nstatic inline int ocfs2_check_wait_flag(struct ocfs2_lock_res *lockres,\n\t\t\t\t\tint flag)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tret = lockres->l_flags & flag;\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\treturn ret;\n}\n\nstatic inline void ocfs2_wait_on_busy_lock(struct ocfs2_lock_res *lockres)\n\n{\n\twait_event(lockres->l_event,\n\t\t   !ocfs2_check_wait_flag(lockres, OCFS2_LOCK_BUSY));\n}\n\nstatic inline void ocfs2_wait_on_refreshing_lock(struct ocfs2_lock_res *lockres)\n\n{\n\twait_event(lockres->l_event,\n\t\t   !ocfs2_check_wait_flag(lockres, OCFS2_LOCK_REFRESHING));\n}\n\n \nstatic inline int ocfs2_may_continue_on_blocked_lock(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\t     int wanted)\n{\n\tBUG_ON(!(lockres->l_flags & OCFS2_LOCK_BLOCKED));\n\n\treturn wanted <= ocfs2_highest_compat_lock_level(lockres->l_blocking);\n}\n\nstatic void ocfs2_init_mask_waiter(struct ocfs2_mask_waiter *mw)\n{\n\tINIT_LIST_HEAD(&mw->mw_item);\n\tinit_completion(&mw->mw_complete);\n\tocfs2_init_start_time(mw);\n}\n\nstatic int ocfs2_wait_for_mask(struct ocfs2_mask_waiter *mw)\n{\n\twait_for_completion(&mw->mw_complete);\n\t \n\treinit_completion(&mw->mw_complete);\n\treturn mw->mw_status;\n}\n\nstatic void lockres_add_mask_waiter(struct ocfs2_lock_res *lockres,\n\t\t\t\t    struct ocfs2_mask_waiter *mw,\n\t\t\t\t    unsigned long mask,\n\t\t\t\t    unsigned long goal)\n{\n\tBUG_ON(!list_empty(&mw->mw_item));\n\n\tassert_spin_locked(&lockres->l_lock);\n\n\tlist_add_tail(&mw->mw_item, &lockres->l_mask_waiters);\n\tmw->mw_mask = mask;\n\tmw->mw_goal = goal;\n\tocfs2_track_lock_wait(lockres);\n}\n\n \nstatic int __lockres_remove_mask_waiter(struct ocfs2_lock_res *lockres,\n\t\t\t\t      struct ocfs2_mask_waiter *mw)\n{\n\tint ret = 0;\n\n\tassert_spin_locked(&lockres->l_lock);\n\tif (!list_empty(&mw->mw_item)) {\n\t\tif ((lockres->l_flags & mw->mw_mask) != mw->mw_goal)\n\t\t\tret = -EBUSY;\n\n\t\tlist_del_init(&mw->mw_item);\n\t\tinit_completion(&mw->mw_complete);\n\t\tocfs2_track_lock_wait(lockres);\n\t}\n\n\treturn ret;\n}\n\nstatic int lockres_remove_mask_waiter(struct ocfs2_lock_res *lockres,\n\t\t\t\t      struct ocfs2_mask_waiter *mw)\n{\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tret = __lockres_remove_mask_waiter(lockres, mw);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\treturn ret;\n\n}\n\nstatic int ocfs2_wait_for_mask_interruptible(struct ocfs2_mask_waiter *mw,\n\t\t\t\t\t     struct ocfs2_lock_res *lockres)\n{\n\tint ret;\n\n\tret = wait_for_completion_interruptible(&mw->mw_complete);\n\tif (ret)\n\t\tlockres_remove_mask_waiter(lockres, mw);\n\telse\n\t\tret = mw->mw_status;\n\t \n\treinit_completion(&mw->mw_complete);\n\treturn ret;\n}\n\nstatic int __ocfs2_cluster_lock(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres,\n\t\t\t\tint level,\n\t\t\t\tu32 lkm_flags,\n\t\t\t\tint arg_flags,\n\t\t\t\tint l_subclass,\n\t\t\t\tunsigned long caller_ip)\n{\n\tstruct ocfs2_mask_waiter mw;\n\tint wait, catch_signals = !(osb->s_mount_opt & OCFS2_MOUNT_NOINTR);\n\tint ret = 0;  \n\tunsigned long flags;\n\tunsigned int gen;\n\tint noqueue_attempted = 0;\n\tint dlm_locked = 0;\n\tint kick_dc = 0;\n\n\tif (!(lockres->l_flags & OCFS2_LOCK_INITIALIZED)) {\n\t\tmlog_errno(-EINVAL);\n\t\treturn -EINVAL;\n\t}\n\n\tocfs2_init_mask_waiter(&mw);\n\n\tif (lockres->l_ops->flags & LOCK_TYPE_USES_LVB)\n\t\tlkm_flags |= DLM_LKF_VALBLK;\n\nagain:\n\twait = 0;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\n\tif (catch_signals && signal_pending(current)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto unlock;\n\t}\n\n\tmlog_bug_on_msg(lockres->l_flags & OCFS2_LOCK_FREEING,\n\t\t\t\"Cluster lock called on freeing lockres %s! flags \"\n\t\t\t\"0x%lx\\n\", lockres->l_name, lockres->l_flags);\n\n\t \n\tif (lockres->l_flags & OCFS2_LOCK_BUSY &&\n\t    level > lockres->l_level) {\n\t\t \n\t\tlockres_add_mask_waiter(lockres, &mw, OCFS2_LOCK_BUSY, 0);\n\t\twait = 1;\n\t\tgoto unlock;\n\t}\n\n\tif (lockres->l_flags & OCFS2_LOCK_UPCONVERT_FINISHING) {\n\t\t \n\t\tif (level <= lockres->l_level)\n\t\t\tgoto update_holders;\n\t}\n\n\tif (lockres->l_flags & OCFS2_LOCK_BLOCKED &&\n\t    !ocfs2_may_continue_on_blocked_lock(lockres, level)) {\n\t\t \n\t\tlockres_add_mask_waiter(lockres, &mw, OCFS2_LOCK_BLOCKED, 0);\n\t\twait = 1;\n\t\tgoto unlock;\n\t}\n\n\tif (level > lockres->l_level) {\n\t\tif (noqueue_attempted > 0) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto unlock;\n\t\t}\n\t\tif (lkm_flags & DLM_LKF_NOQUEUE)\n\t\t\tnoqueue_attempted = 1;\n\n\t\tif (lockres->l_action != OCFS2_AST_INVALID)\n\t\t\tmlog(ML_ERROR, \"lockres %s has action %u pending\\n\",\n\t\t\t     lockres->l_name, lockres->l_action);\n\n\t\tif (!(lockres->l_flags & OCFS2_LOCK_ATTACHED)) {\n\t\t\tlockres->l_action = OCFS2_AST_ATTACH;\n\t\t\tlkm_flags &= ~DLM_LKF_CONVERT;\n\t\t} else {\n\t\t\tlockres->l_action = OCFS2_AST_CONVERT;\n\t\t\tlkm_flags |= DLM_LKF_CONVERT;\n\t\t}\n\n\t\tlockres->l_requested = level;\n\t\tlockres_or_flags(lockres, OCFS2_LOCK_BUSY);\n\t\tgen = lockres_set_pending(lockres);\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\t\tBUG_ON(level == DLM_LOCK_IV);\n\t\tBUG_ON(level == DLM_LOCK_NL);\n\n\t\tmlog(ML_BASTS, \"lockres %s, convert from %d to %d\\n\",\n\t\t     lockres->l_name, lockres->l_level, level);\n\n\t\t \n\t\tret = ocfs2_dlm_lock(osb->cconn,\n\t\t\t\t     level,\n\t\t\t\t     &lockres->l_lksb,\n\t\t\t\t     lkm_flags,\n\t\t\t\t     lockres->l_name,\n\t\t\t\t     OCFS2_LOCK_ID_MAX_LEN - 1);\n\t\tlockres_clear_pending(lockres, gen, osb);\n\t\tif (ret) {\n\t\t\tif (!(lkm_flags & DLM_LKF_NOQUEUE) ||\n\t\t\t    (ret != -EAGAIN)) {\n\t\t\t\tocfs2_log_dlm_error(\"ocfs2_dlm_lock\",\n\t\t\t\t\t\t    ret, lockres);\n\t\t\t}\n\t\t\tocfs2_recover_from_dlm_error(lockres, 1);\n\t\t\tgoto out;\n\t\t}\n\t\tdlm_locked = 1;\n\n\t\tmlog(0, \"lock %s, successful return from ocfs2_dlm_lock\\n\",\n\t\t     lockres->l_name);\n\n\t\t \n\t\tcatch_signals = 0;\n\n\t\t \n\t\tgoto again;\n\t}\n\nupdate_holders:\n\t \n\tocfs2_inc_holders(lockres, level);\n\n\tret = 0;\nunlock:\n\tlockres_clear_flags(lockres, OCFS2_LOCK_UPCONVERT_FINISHING);\n\n\t \n\tkick_dc = (lockres->l_flags & OCFS2_LOCK_BLOCKED);\n\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\tif (kick_dc)\n\t\tocfs2_wake_downconvert_thread(osb);\nout:\n\t \n\tif (wait && arg_flags & OCFS2_LOCK_NONBLOCK &&\n\t    mw.mw_mask & (OCFS2_LOCK_BUSY|OCFS2_LOCK_BLOCKED)) {\n\t\twait = 0;\n\t\tspin_lock_irqsave(&lockres->l_lock, flags);\n\t\tif (__lockres_remove_mask_waiter(lockres, &mw)) {\n\t\t\tif (dlm_locked)\n\t\t\t\tlockres_or_flags(lockres,\n\t\t\t\t\tOCFS2_LOCK_NONBLOCK_FINISHED);\n\t\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\t\tret = -EAGAIN;\n\t\t} else {\n\t\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\t\tgoto again;\n\t\t}\n\t}\n\tif (wait) {\n\t\tret = ocfs2_wait_for_mask(&mw);\n\t\tif (ret == 0)\n\t\t\tgoto again;\n\t\tmlog_errno(ret);\n\t}\n\tocfs2_update_lock_stats(lockres, level, &mw, ret);\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (!ret && lockres->l_lockdep_map.key != NULL) {\n\t\tif (level == DLM_LOCK_PR)\n\t\t\trwsem_acquire_read(&lockres->l_lockdep_map, l_subclass,\n\t\t\t\t!!(arg_flags & OCFS2_META_LOCK_NOQUEUE),\n\t\t\t\tcaller_ip);\n\t\telse\n\t\t\trwsem_acquire(&lockres->l_lockdep_map, l_subclass,\n\t\t\t\t!!(arg_flags & OCFS2_META_LOCK_NOQUEUE),\n\t\t\t\tcaller_ip);\n\t}\n#endif\n\treturn ret;\n}\n\nstatic inline int ocfs2_cluster_lock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres,\n\t\t\t\t     int level,\n\t\t\t\t     u32 lkm_flags,\n\t\t\t\t     int arg_flags)\n{\n\treturn __ocfs2_cluster_lock(osb, lockres, level, lkm_flags, arg_flags,\n\t\t\t\t    0, _RET_IP_);\n}\n\n\nstatic void __ocfs2_cluster_unlock(struct ocfs2_super *osb,\n\t\t\t\t   struct ocfs2_lock_res *lockres,\n\t\t\t\t   int level,\n\t\t\t\t   unsigned long caller_ip)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tocfs2_dec_holders(lockres, level);\n\tocfs2_downconvert_on_unlock(osb, lockres);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (lockres->l_lockdep_map.key != NULL)\n\t\trwsem_release(&lockres->l_lockdep_map, caller_ip);\n#endif\n}\n\nstatic int ocfs2_create_new_lock(struct ocfs2_super *osb,\n\t\t\t\t struct ocfs2_lock_res *lockres,\n\t\t\t\t int ex,\n\t\t\t\t int local)\n{\n\tint level =  ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tunsigned long flags;\n\tu32 lkm_flags = local ? DLM_LKF_LOCAL : 0;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tBUG_ON(lockres->l_flags & OCFS2_LOCK_ATTACHED);\n\tlockres_or_flags(lockres, OCFS2_LOCK_LOCAL);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\treturn ocfs2_lock_create(osb, lockres, level, lkm_flags);\n}\n\n \nint ocfs2_create_new_inode_locks(struct inode *inode)\n{\n\tint ret;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tBUG_ON(!ocfs2_inode_is_new(inode));\n\n\tmlog(0, \"Inode %llu\\n\", (unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\t \n\n\tret = ocfs2_create_new_lock(osb, &OCFS2_I(inode)->ip_rw_lockres, 1, 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto bail;\n\t}\n\n\t \n\tret = ocfs2_create_new_lock(osb, &OCFS2_I(inode)->ip_inode_lockres, 1, 0);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto bail;\n\t}\n\n\tret = ocfs2_create_new_lock(osb, &OCFS2_I(inode)->ip_open_lockres, 0, 0);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nbail:\n\treturn ret;\n}\n\nint ocfs2_rw_lock(struct inode *inode, int write)\n{\n\tint status, level;\n\tstruct ocfs2_lock_res *lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu take %s RW lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     write ? \"EXMODE\" : \"PRMODE\");\n\n\tif (ocfs2_mount_local(osb))\n\t\treturn 0;\n\n\tlockres = &OCFS2_I(inode)->ip_rw_lockres;\n\n\tlevel = write ? DLM_LOCK_EX : DLM_LOCK_PR;\n\n\tstatus = ocfs2_cluster_lock(osb, lockres, level, 0, 0);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\treturn status;\n}\n\nint ocfs2_try_rw_lock(struct inode *inode, int write)\n{\n\tint status, level;\n\tstruct ocfs2_lock_res *lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu try to take %s RW lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     write ? \"EXMODE\" : \"PRMODE\");\n\n\tif (ocfs2_mount_local(osb))\n\t\treturn 0;\n\n\tlockres = &OCFS2_I(inode)->ip_rw_lockres;\n\n\tlevel = write ? DLM_LOCK_EX : DLM_LOCK_PR;\n\n\tstatus = ocfs2_cluster_lock(osb, lockres, level, DLM_LKF_NOQUEUE, 0);\n\treturn status;\n}\n\nvoid ocfs2_rw_unlock(struct inode *inode, int write)\n{\n\tint level = write ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_rw_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s RW lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     write ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(osb, lockres, level);\n}\n\n \nint ocfs2_open_lock(struct inode *inode)\n{\n\tint status = 0;\n\tstruct ocfs2_lock_res *lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu take PRMODE open lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tif (ocfs2_is_hard_readonly(osb) || ocfs2_mount_local(osb))\n\t\tgoto out;\n\n\tlockres = &OCFS2_I(inode)->ip_open_lockres;\n\n\tstatus = ocfs2_cluster_lock(osb, lockres, DLM_LOCK_PR, 0, 0);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\nout:\n\treturn status;\n}\n\nint ocfs2_try_open_lock(struct inode *inode, int write)\n{\n\tint status = 0, level;\n\tstruct ocfs2_lock_res *lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu try to take %s open lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     write ? \"EXMODE\" : \"PRMODE\");\n\n\tif (ocfs2_is_hard_readonly(osb)) {\n\t\tif (write)\n\t\t\tstatus = -EROFS;\n\t\tgoto out;\n\t}\n\n\tif (ocfs2_mount_local(osb))\n\t\tgoto out;\n\n\tlockres = &OCFS2_I(inode)->ip_open_lockres;\n\n\tlevel = write ? DLM_LOCK_EX : DLM_LOCK_PR;\n\n\t \n\tstatus = ocfs2_cluster_lock(osb, lockres, level, DLM_LKF_NOQUEUE, 0);\n\nout:\n\treturn status;\n}\n\n \nvoid ocfs2_open_unlock(struct inode *inode)\n{\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_open_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop open lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tif (ocfs2_mount_local(osb))\n\t\tgoto out;\n\n\tif(lockres->l_ro_holders)\n\t\tocfs2_cluster_unlock(osb, lockres, DLM_LOCK_PR);\n\tif(lockres->l_ex_holders)\n\t\tocfs2_cluster_unlock(osb, lockres, DLM_LOCK_EX);\n\nout:\n\treturn;\n}\n\nstatic int ocfs2_flock_handle_signal(struct ocfs2_lock_res *lockres,\n\t\t\t\t     int level)\n{\n\tint ret;\n\tstruct ocfs2_super *osb = ocfs2_get_lockres_osb(lockres);\n\tunsigned long flags;\n\tstruct ocfs2_mask_waiter mw;\n\n\tocfs2_init_mask_waiter(&mw);\n\nretry_cancel:\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tif (lockres->l_flags & OCFS2_LOCK_BUSY) {\n\t\tret = ocfs2_prepare_cancel_convert(osb, lockres);\n\t\tif (ret) {\n\t\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\t\tret = ocfs2_cancel_convert(osb, lockres);\n\t\t\tif (ret < 0) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tgoto retry_cancel;\n\t\t}\n\t\tlockres_add_mask_waiter(lockres, &mw, OCFS2_LOCK_BUSY, 0);\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\t\tocfs2_wait_for_mask(&mw);\n\t\tgoto retry_cancel;\n\t}\n\n\tret = -ERESTARTSYS;\n\t \n\tif (lockres->l_level == level)\n\t\tret = 0;\n\n\tmlog(0, \"Cancel returning %d. flags: 0x%lx, level: %d, act: %d\\n\", ret,\n\t     lockres->l_flags, lockres->l_level, lockres->l_action);\n\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\nout:\n\treturn ret;\n}\n\n \nint ocfs2_file_lock(struct file *file, int ex, int trylock)\n{\n\tint ret, level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tunsigned int lkm_flags = trylock ? DLM_LKF_NOQUEUE : 0;\n\tunsigned long flags;\n\tstruct ocfs2_file_private *fp = file->private_data;\n\tstruct ocfs2_lock_res *lockres = &fp->fp_flock;\n\tstruct ocfs2_super *osb = OCFS2_SB(file->f_mapping->host->i_sb);\n\tstruct ocfs2_mask_waiter mw;\n\n\tocfs2_init_mask_waiter(&mw);\n\n\tif ((lockres->l_flags & OCFS2_LOCK_BUSY) ||\n\t    (lockres->l_level > DLM_LOCK_NL)) {\n\t\tmlog(ML_ERROR,\n\t\t     \"File lock \\\"%s\\\" has busy or locked state: flags: 0x%lx, \"\n\t\t     \"level: %u\\n\", lockres->l_name, lockres->l_flags,\n\t\t     lockres->l_level);\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tif (!(lockres->l_flags & OCFS2_LOCK_ATTACHED)) {\n\t\tlockres_add_mask_waiter(lockres, &mw, OCFS2_LOCK_BUSY, 0);\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\t\t \n\t\tret = ocfs2_lock_create(osb, lockres, DLM_LOCK_NL, 0);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_wait_for_mask(&mw);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tspin_lock_irqsave(&lockres->l_lock, flags);\n\t}\n\n\tlockres->l_action = OCFS2_AST_CONVERT;\n\tlkm_flags |= DLM_LKF_CONVERT;\n\tlockres->l_requested = level;\n\tlockres_or_flags(lockres, OCFS2_LOCK_BUSY);\n\n\tlockres_add_mask_waiter(lockres, &mw, OCFS2_LOCK_BUSY, 0);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\tret = ocfs2_dlm_lock(osb->cconn, level, &lockres->l_lksb, lkm_flags,\n\t\t\t     lockres->l_name, OCFS2_LOCK_ID_MAX_LEN - 1);\n\tif (ret) {\n\t\tif (!trylock || (ret != -EAGAIN)) {\n\t\t\tocfs2_log_dlm_error(\"ocfs2_dlm_lock\", ret, lockres);\n\t\t\tret = -EINVAL;\n\t\t}\n\n\t\tocfs2_recover_from_dlm_error(lockres, 1);\n\t\tlockres_remove_mask_waiter(lockres, &mw);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_wait_for_mask_interruptible(&mw, lockres);\n\tif (ret == -ERESTARTSYS) {\n\t\t \n\t\tret = ocfs2_flock_handle_signal(lockres, level);\n\t} else if (!ret && (level > lockres->l_level)) {\n\t\t \n\t\tBUG_ON(!trylock);\n\t\tret = -EAGAIN;\n\t}\n\nout:\n\n\tmlog(0, \"Lock: \\\"%s\\\" ex: %d, trylock: %d, returns: %d\\n\",\n\t     lockres->l_name, ex, trylock, ret);\n\treturn ret;\n}\n\nvoid ocfs2_file_unlock(struct file *file)\n{\n\tint ret;\n\tunsigned int gen;\n\tunsigned long flags;\n\tstruct ocfs2_file_private *fp = file->private_data;\n\tstruct ocfs2_lock_res *lockres = &fp->fp_flock;\n\tstruct ocfs2_super *osb = OCFS2_SB(file->f_mapping->host->i_sb);\n\tstruct ocfs2_mask_waiter mw;\n\n\tocfs2_init_mask_waiter(&mw);\n\n\tif (!(lockres->l_flags & OCFS2_LOCK_ATTACHED))\n\t\treturn;\n\n\tif (lockres->l_level == DLM_LOCK_NL)\n\t\treturn;\n\n\tmlog(0, \"Unlock: \\\"%s\\\" flags: 0x%lx, level: %d, act: %d\\n\",\n\t     lockres->l_name, lockres->l_flags, lockres->l_level,\n\t     lockres->l_action);\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\t \n\tlockres_or_flags(lockres, OCFS2_LOCK_BLOCKED);\n\tlockres->l_blocking = DLM_LOCK_EX;\n\n\tgen = ocfs2_prepare_downconvert(lockres, DLM_LOCK_NL);\n\tlockres_add_mask_waiter(lockres, &mw, OCFS2_LOCK_BUSY, 0);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\tret = ocfs2_downconvert_lock(osb, lockres, DLM_LOCK_NL, 0, gen);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn;\n\t}\n\n\tret = ocfs2_wait_for_mask(&mw);\n\tif (ret)\n\t\tmlog_errno(ret);\n}\n\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres)\n{\n\tint kick = 0;\n\n\t \n\tif (lockres->l_flags & OCFS2_LOCK_BLOCKED) {\n\t\tswitch(lockres->l_blocking) {\n\t\tcase DLM_LOCK_EX:\n\t\t\tif (!lockres->l_ex_holders && !lockres->l_ro_holders)\n\t\t\t\tkick = 1;\n\t\t\tbreak;\n\t\tcase DLM_LOCK_PR:\n\t\t\tif (!lockres->l_ex_holders)\n\t\t\t\tkick = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t}\n\n\tif (kick)\n\t\tocfs2_wake_downconvert_thread(osb);\n}\n\n#define OCFS2_SEC_BITS   34\n#define OCFS2_SEC_SHIFT  (64 - OCFS2_SEC_BITS)\n#define OCFS2_NSEC_MASK  ((1ULL << OCFS2_SEC_SHIFT) - 1)\n\n \nstatic u64 ocfs2_pack_timespec(struct timespec64 *spec)\n{\n\tu64 res;\n\tu64 sec = clamp_t(time64_t, spec->tv_sec, 0, 0x3ffffffffull);\n\tu32 nsec = spec->tv_nsec;\n\n\tres = (sec << OCFS2_SEC_SHIFT) | (nsec & OCFS2_NSEC_MASK);\n\n\treturn res;\n}\n\n \nstatic void __ocfs2_stuff_meta_lvb(struct inode *inode)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_lock_res *lockres = &oi->ip_inode_lockres;\n\tstruct ocfs2_meta_lvb *lvb;\n\tstruct timespec64 ctime = inode_get_ctime(inode);\n\n\tlvb = ocfs2_dlm_lvb(&lockres->l_lksb);\n\n\t \n\tif (oi->ip_flags & OCFS2_INODE_DELETED) {\n\t\tlvb->lvb_version = 0;\n\t\tgoto out;\n\t}\n\n\tlvb->lvb_version   = OCFS2_LVB_VERSION;\n\tlvb->lvb_isize\t   = cpu_to_be64(i_size_read(inode));\n\tlvb->lvb_iclusters = cpu_to_be32(oi->ip_clusters);\n\tlvb->lvb_iuid      = cpu_to_be32(i_uid_read(inode));\n\tlvb->lvb_igid      = cpu_to_be32(i_gid_read(inode));\n\tlvb->lvb_imode     = cpu_to_be16(inode->i_mode);\n\tlvb->lvb_inlink    = cpu_to_be16(inode->i_nlink);\n\tlvb->lvb_iatime_packed  =\n\t\tcpu_to_be64(ocfs2_pack_timespec(&inode->i_atime));\n\tlvb->lvb_ictime_packed =\n\t\tcpu_to_be64(ocfs2_pack_timespec(&ctime));\n\tlvb->lvb_imtime_packed =\n\t\tcpu_to_be64(ocfs2_pack_timespec(&inode->i_mtime));\n\tlvb->lvb_iattr    = cpu_to_be32(oi->ip_attr);\n\tlvb->lvb_idynfeatures = cpu_to_be16(oi->ip_dyn_features);\n\tlvb->lvb_igeneration = cpu_to_be32(inode->i_generation);\n\nout:\n\tmlog_meta_lvb(0, lockres);\n}\n\nstatic void ocfs2_unpack_timespec(struct timespec64 *spec,\n\t\t\t\t  u64 packed_time)\n{\n\tspec->tv_sec = packed_time >> OCFS2_SEC_SHIFT;\n\tspec->tv_nsec = packed_time & OCFS2_NSEC_MASK;\n}\n\nstatic int ocfs2_refresh_inode_from_lvb(struct inode *inode)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_lock_res *lockres = &oi->ip_inode_lockres;\n\tstruct ocfs2_meta_lvb *lvb;\n\tstruct timespec64 ctime;\n\n\tmlog_meta_lvb(0, lockres);\n\n\tlvb = ocfs2_dlm_lvb(&lockres->l_lksb);\n\tif (inode_wrong_type(inode, be16_to_cpu(lvb->lvb_imode)))\n\t\treturn -ESTALE;\n\n\t \n\tspin_lock(&oi->ip_lock);\n\toi->ip_clusters = be32_to_cpu(lvb->lvb_iclusters);\n\ti_size_write(inode, be64_to_cpu(lvb->lvb_isize));\n\n\toi->ip_attr = be32_to_cpu(lvb->lvb_iattr);\n\toi->ip_dyn_features = be16_to_cpu(lvb->lvb_idynfeatures);\n\tocfs2_set_inode_flags(inode);\n\n\t \n\tif (S_ISLNK(inode->i_mode) && !oi->ip_clusters)\n\t\tinode->i_blocks = 0;\n\telse\n\t\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\n\ti_uid_write(inode, be32_to_cpu(lvb->lvb_iuid));\n\ti_gid_write(inode, be32_to_cpu(lvb->lvb_igid));\n\tinode->i_mode    = be16_to_cpu(lvb->lvb_imode);\n\tset_nlink(inode, be16_to_cpu(lvb->lvb_inlink));\n\tocfs2_unpack_timespec(&inode->i_atime,\n\t\t\t      be64_to_cpu(lvb->lvb_iatime_packed));\n\tocfs2_unpack_timespec(&inode->i_mtime,\n\t\t\t      be64_to_cpu(lvb->lvb_imtime_packed));\n\tocfs2_unpack_timespec(&ctime,\n\t\t\t      be64_to_cpu(lvb->lvb_ictime_packed));\n\tinode_set_ctime_to_ts(inode, ctime);\n\tspin_unlock(&oi->ip_lock);\n\treturn 0;\n}\n\nstatic inline int ocfs2_meta_lvb_is_trustable(struct inode *inode,\n\t\t\t\t\t      struct ocfs2_lock_res *lockres)\n{\n\tstruct ocfs2_meta_lvb *lvb = ocfs2_dlm_lvb(&lockres->l_lksb);\n\n\tif (ocfs2_dlm_lvb_valid(&lockres->l_lksb)\n\t    && lvb->lvb_version == OCFS2_LVB_VERSION\n\t    && be32_to_cpu(lvb->lvb_igeneration) == inode->i_generation)\n\t\treturn 1;\n\treturn 0;\n}\n\n \nstatic int ocfs2_should_refresh_lock_res(struct ocfs2_lock_res *lockres)\n{\n\tunsigned long flags;\n\tint status = 0;\n\nrefresh_check:\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tif (!(lockres->l_flags & OCFS2_LOCK_NEEDS_REFRESH)) {\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\tgoto bail;\n\t}\n\n\tif (lockres->l_flags & OCFS2_LOCK_REFRESHING) {\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\t\tocfs2_wait_on_refreshing_lock(lockres);\n\t\tgoto refresh_check;\n\t}\n\n\t \n\tlockres_or_flags(lockres, OCFS2_LOCK_REFRESHING);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\tstatus = 1;\nbail:\n\tmlog(0, \"status %d\\n\", status);\n\treturn status;\n}\n\n \nstatic inline void ocfs2_complete_lock_res_refresh(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\t   int status)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tlockres_clear_flags(lockres, OCFS2_LOCK_REFRESHING);\n\tif (!status)\n\t\tlockres_clear_flags(lockres, OCFS2_LOCK_NEEDS_REFRESH);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\twake_up(&lockres->l_event);\n}\n\n \nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh)\n{\n\tint status = 0;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_lock_res *lockres = &oi->ip_inode_lockres;\n\tstruct ocfs2_dinode *fe;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (ocfs2_mount_local(osb))\n\t\tgoto bail;\n\n\tspin_lock(&oi->ip_lock);\n\tif (oi->ip_flags & OCFS2_INODE_DELETED) {\n\t\tmlog(0, \"Orphaned inode %llu was deleted while we \"\n\t\t     \"were waiting on a lock. ip_flags = 0x%x\\n\",\n\t\t     (unsigned long long)oi->ip_blkno, oi->ip_flags);\n\t\tspin_unlock(&oi->ip_lock);\n\t\tstatus = -ENOENT;\n\t\tgoto bail;\n\t}\n\tspin_unlock(&oi->ip_lock);\n\n\tif (!ocfs2_should_refresh_lock_res(lockres))\n\t\tgoto bail;\n\n\t \n\tocfs2_metadata_cache_purge(INODE_CACHE(inode));\n\n\tocfs2_extent_map_trunc(inode, 0);\n\n\tif (ocfs2_meta_lvb_is_trustable(inode, lockres)) {\n\t\tmlog(0, \"Trusting LVB on inode %llu\\n\",\n\t\t     (unsigned long long)oi->ip_blkno);\n\t\tstatus = ocfs2_refresh_inode_from_lvb(inode);\n\t\tgoto bail_refresh;\n\t} else {\n\t\t \n\t\t \n\t\tstatus = ocfs2_read_inode_block(inode, bh);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail_refresh;\n\t\t}\n\t\tfe = (struct ocfs2_dinode *) (*bh)->b_data;\n\t\tif (inode_wrong_type(inode, le16_to_cpu(fe->i_mode))) {\n\t\t\tstatus = -ESTALE;\n\t\t\tgoto bail_refresh;\n\t\t}\n\n\t\t \n\t\tmlog_bug_on_msg(inode->i_generation !=\n\t\t\t\tle32_to_cpu(fe->i_generation),\n\t\t\t\t\"Invalid dinode %llu disk generation: %u \"\n\t\t\t\t\"inode->i_generation: %u\\n\",\n\t\t\t\t(unsigned long long)oi->ip_blkno,\n\t\t\t\tle32_to_cpu(fe->i_generation),\n\t\t\t\tinode->i_generation);\n\t\tmlog_bug_on_msg(le64_to_cpu(fe->i_dtime) ||\n\t\t\t\t!(fe->i_flags & cpu_to_le32(OCFS2_VALID_FL)),\n\t\t\t\t\"Stale dinode %llu dtime: %llu flags: 0x%x\\n\",\n\t\t\t\t(unsigned long long)oi->ip_blkno,\n\t\t\t\t(unsigned long long)le64_to_cpu(fe->i_dtime),\n\t\t\t\tle32_to_cpu(fe->i_flags));\n\n\t\tocfs2_refresh_inode(inode, fe);\n\t\tocfs2_track_lock_refresh(lockres);\n\t}\n\n\tstatus = 0;\nbail_refresh:\n\tocfs2_complete_lock_res_refresh(lockres, status);\nbail:\n\treturn status;\n}\n\nstatic int ocfs2_assign_bh(struct inode *inode,\n\t\t\t   struct buffer_head **ret_bh,\n\t\t\t   struct buffer_head *passed_bh)\n{\n\tint status;\n\n\tif (passed_bh) {\n\t\t \n\t\t*ret_bh = passed_bh;\n\t\tget_bh(*ret_bh);\n\n\t\treturn 0;\n\t}\n\n\tstatus = ocfs2_read_inode_block(inode, ret_bh);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\treturn status;\n}\n\n \nint ocfs2_inode_lock_full_nested(struct inode *inode,\n\t\t\t\t struct buffer_head **ret_bh,\n\t\t\t\t int ex,\n\t\t\t\t int arg_flags,\n\t\t\t\t int subclass)\n{\n\tint status, level, acquired;\n\tu32 dlm_flags;\n\tstruct ocfs2_lock_res *lockres = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct buffer_head *local_bh = NULL;\n\n\tmlog(0, \"inode %llu, take %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tstatus = 0;\n\tacquired = 0;\n\t \n\tif (ocfs2_is_hard_readonly(osb)) {\n\t\tif (ex)\n\t\t\tstatus = -EROFS;\n\t\tgoto getbh;\n\t}\n\n\tif ((arg_flags & OCFS2_META_LOCK_GETBH) ||\n\t    ocfs2_mount_local(osb))\n\t\tgoto update;\n\n\tif (!(arg_flags & OCFS2_META_LOCK_RECOVERY))\n\t\tocfs2_wait_for_recovery(osb);\n\n\tlockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tlevel = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tdlm_flags = 0;\n\tif (arg_flags & OCFS2_META_LOCK_NOQUEUE)\n\t\tdlm_flags |= DLM_LKF_NOQUEUE;\n\n\tstatus = __ocfs2_cluster_lock(osb, lockres, level, dlm_flags,\n\t\t\t\t      arg_flags, subclass, _RET_IP_);\n\tif (status < 0) {\n\t\tif (status != -EAGAIN)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t \n\tacquired = 1;\n\n\t \n\tif (!(arg_flags & OCFS2_META_LOCK_RECOVERY))\n\t\tocfs2_wait_for_recovery(osb);\n\nupdate:\n\t \n\tif (inode->i_state & I_NEW) {\n\t\tstatus = 0;\n\t\tif (lockres)\n\t\t\tocfs2_complete_lock_res_refresh(lockres, 0);\n\t\tgoto bail;\n\t}\n\n\t \n\tstatus = ocfs2_inode_lock_update(inode, &local_bh);\n\tif (status < 0) {\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\ngetbh:\n\tif (ret_bh) {\n\t\tstatus = ocfs2_assign_bh(inode, ret_bh, local_bh);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\nbail:\n\tif (status < 0) {\n\t\tif (ret_bh && (*ret_bh)) {\n\t\t\tbrelse(*ret_bh);\n\t\t\t*ret_bh = NULL;\n\t\t}\n\t\tif (acquired)\n\t\t\tocfs2_inode_unlock(inode, ex);\n\t}\n\n\tbrelse(local_bh);\n\treturn status;\n}\n\n \nint ocfs2_inode_lock_with_page(struct inode *inode,\n\t\t\t      struct buffer_head **ret_bh,\n\t\t\t      int ex,\n\t\t\t      struct page *page)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock_full(inode, ret_bh, ex, OCFS2_LOCK_NONBLOCK);\n\tif (ret == -EAGAIN) {\n\t\tunlock_page(page);\n\t\t \n\t\tif (ocfs2_inode_lock(inode, ret_bh, ex) == 0)\n\t\t\tocfs2_inode_unlock(inode, ex);\n\t\tret = AOP_TRUNCATED_PAGE;\n\t}\n\n\treturn ret;\n}\n\nint ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level, int wait)\n{\n\tint ret;\n\n\tif (wait)\n\t\tret = ocfs2_inode_lock(inode, NULL, 0);\n\telse\n\t\tret = ocfs2_try_inode_lock(inode, NULL, 0);\n\n\tif (ret < 0) {\n\t\tif (ret != -EAGAIN)\n\t\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tif (wait)\n\t\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\telse\n\t\t\tret = ocfs2_try_inode_lock(inode, &bh, 1);\n\n\t\tif (ret < 0) {\n\t\t\tif (ret != -EAGAIN)\n\t\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(osb) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(osb, lockres, level);\n}\n\n \nint ocfs2_inode_lock_tracker(struct inode *inode,\n\t\t\t     struct buffer_head **ret_bh,\n\t\t\t     int ex,\n\t\t\t     struct ocfs2_lock_holder *oh)\n{\n\tint status = 0;\n\tstruct ocfs2_lock_res *lockres;\n\tstruct ocfs2_lock_holder *tmp_oh;\n\tstruct pid *pid = task_pid(current);\n\n\n\tlockres = &OCFS2_I(inode)->ip_inode_lockres;\n\ttmp_oh = ocfs2_pid_holder(lockres, pid);\n\n\tif (!tmp_oh) {\n\t\t \n\t\tstatus = ocfs2_inode_lock_full(inode, ret_bh, ex, 0);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENOENT)\n\t\t\t\tmlog_errno(status);\n\t\t\treturn status;\n\t\t}\n\n\t\toh->oh_ex = ex;\n\t\tocfs2_add_holder(lockres, oh);\n\t\treturn 0;\n\t}\n\n\tif (unlikely(ex && !tmp_oh->oh_ex)) {\n\t\t \n\t\tmlog(ML_ERROR, \"Recursive locking is not permitted to \"\n\t\t     \"upgrade to EX level from PR level.\\n\");\n\t\tdump_stack();\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (ret_bh) {\n\t\tstatus = ocfs2_inode_lock_full(inode, ret_bh, ex,\n\t\t\t\t\t       OCFS2_META_LOCK_GETBH);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENOENT)\n\t\t\t\tmlog_errno(status);\n\t\t\treturn status;\n\t\t}\n\t}\n\treturn 1;\n}\n\nvoid ocfs2_inode_unlock_tracker(struct inode *inode,\n\t\t\t\tint ex,\n\t\t\t\tstruct ocfs2_lock_holder *oh,\n\t\t\t\tint had_lock)\n{\n\tstruct ocfs2_lock_res *lockres;\n\n\tlockres = &OCFS2_I(inode)->ip_inode_lockres;\n\t \n\tif (!had_lock) {\n\t\tocfs2_inode_unlock(inode, oh->oh_ex);\n\t\tocfs2_remove_holder(lockres, oh);\n\t}\n}\n\nint ocfs2_orphan_scan_lock(struct ocfs2_super *osb, u32 *seqno)\n{\n\tstruct ocfs2_lock_res *lockres;\n\tstruct ocfs2_orphan_scan_lvb *lvb;\n\tint status = 0;\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn -EROFS;\n\n\tif (ocfs2_mount_local(osb))\n\t\treturn 0;\n\n\tlockres = &osb->osb_orphan_scan.os_lockres;\n\tstatus = ocfs2_cluster_lock(osb, lockres, DLM_LOCK_EX, 0, 0);\n\tif (status < 0)\n\t\treturn status;\n\n\tlvb = ocfs2_dlm_lvb(&lockres->l_lksb);\n\tif (ocfs2_dlm_lvb_valid(&lockres->l_lksb) &&\n\t    lvb->lvb_version == OCFS2_ORPHAN_LVB_VERSION)\n\t\t*seqno = be32_to_cpu(lvb->lvb_os_seqno);\n\telse\n\t\t*seqno = osb->osb_orphan_scan.os_seqno + 1;\n\n\treturn status;\n}\n\nvoid ocfs2_orphan_scan_unlock(struct ocfs2_super *osb, u32 seqno)\n{\n\tstruct ocfs2_lock_res *lockres;\n\tstruct ocfs2_orphan_scan_lvb *lvb;\n\n\tif (!ocfs2_is_hard_readonly(osb) && !ocfs2_mount_local(osb)) {\n\t\tlockres = &osb->osb_orphan_scan.os_lockres;\n\t\tlvb = ocfs2_dlm_lvb(&lockres->l_lksb);\n\t\tlvb->lvb_version = OCFS2_ORPHAN_LVB_VERSION;\n\t\tlvb->lvb_os_seqno = cpu_to_be32(seqno);\n\t\tocfs2_cluster_unlock(osb, lockres, DLM_LOCK_EX);\n\t}\n}\n\nint ocfs2_super_lock(struct ocfs2_super *osb,\n\t\t     int ex)\n{\n\tint status = 0;\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &osb->osb_super_lockres;\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn -EROFS;\n\n\tif (ocfs2_mount_local(osb))\n\t\tgoto bail;\n\n\tstatus = ocfs2_cluster_lock(osb, lockres, level, 0, 0);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t \n\tstatus = ocfs2_should_refresh_lock_res(lockres);\n\tif (status) {\n\t\tstatus = ocfs2_refresh_slot_info(osb);\n\n\t\tocfs2_complete_lock_res_refresh(lockres, status);\n\n\t\tif (status < 0) {\n\t\t\tocfs2_cluster_unlock(osb, lockres, level);\n\t\t\tmlog_errno(status);\n\t\t}\n\t\tocfs2_track_lock_refresh(lockres);\n\t}\nbail:\n\treturn status;\n}\n\nvoid ocfs2_super_unlock(struct ocfs2_super *osb,\n\t\t\tint ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &osb->osb_super_lockres;\n\n\tif (!ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(osb, lockres, level);\n}\n\nint ocfs2_rename_lock(struct ocfs2_super *osb)\n{\n\tint status;\n\tstruct ocfs2_lock_res *lockres = &osb->osb_rename_lockres;\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn -EROFS;\n\n\tif (ocfs2_mount_local(osb))\n\t\treturn 0;\n\n\tstatus = ocfs2_cluster_lock(osb, lockres, DLM_LOCK_EX, 0, 0);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\treturn status;\n}\n\nvoid ocfs2_rename_unlock(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_lock_res *lockres = &osb->osb_rename_lockres;\n\n\tif (!ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(osb, lockres, DLM_LOCK_EX);\n}\n\nint ocfs2_nfs_sync_lock(struct ocfs2_super *osb, int ex)\n{\n\tint status;\n\tstruct ocfs2_lock_res *lockres = &osb->osb_nfs_sync_lockres;\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn -EROFS;\n\n\tif (ex)\n\t\tdown_write(&osb->nfs_sync_rwlock);\n\telse\n\t\tdown_read(&osb->nfs_sync_rwlock);\n\n\tif (ocfs2_mount_local(osb))\n\t\treturn 0;\n\n\tstatus = ocfs2_cluster_lock(osb, lockres, ex ? LKM_EXMODE : LKM_PRMODE,\n\t\t\t\t    0, 0);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"lock on nfs sync lock failed %d\\n\", status);\n\n\t\tif (ex)\n\t\t\tup_write(&osb->nfs_sync_rwlock);\n\t\telse\n\t\t\tup_read(&osb->nfs_sync_rwlock);\n\t}\n\n\treturn status;\n}\n\nvoid ocfs2_nfs_sync_unlock(struct ocfs2_super *osb, int ex)\n{\n\tstruct ocfs2_lock_res *lockres = &osb->osb_nfs_sync_lockres;\n\n\tif (!ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(osb, lockres,\n\t\t\t\t     ex ? LKM_EXMODE : LKM_PRMODE);\n\tif (ex)\n\t\tup_write(&osb->nfs_sync_rwlock);\n\telse\n\t\tup_read(&osb->nfs_sync_rwlock);\n}\n\nint ocfs2_trim_fs_lock(struct ocfs2_super *osb,\n\t\t       struct ocfs2_trim_fs_info *info, int trylock)\n{\n\tint status;\n\tstruct ocfs2_trim_fs_lvb *lvb;\n\tstruct ocfs2_lock_res *lockres = &osb->osb_trim_fs_lockres;\n\n\tif (info)\n\t\tinfo->tf_valid = 0;\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn -EROFS;\n\n\tif (ocfs2_mount_local(osb))\n\t\treturn 0;\n\n\tstatus = ocfs2_cluster_lock(osb, lockres, DLM_LOCK_EX,\n\t\t\t\t    trylock ? DLM_LKF_NOQUEUE : 0, 0);\n\tif (status < 0) {\n\t\tif (status != -EAGAIN)\n\t\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\n\tif (info) {\n\t\tlvb = ocfs2_dlm_lvb(&lockres->l_lksb);\n\t\tif (ocfs2_dlm_lvb_valid(&lockres->l_lksb) &&\n\t\t    lvb->lvb_version == OCFS2_TRIMFS_LVB_VERSION) {\n\t\t\tinfo->tf_valid = 1;\n\t\t\tinfo->tf_success = lvb->lvb_success;\n\t\t\tinfo->tf_nodenum = be32_to_cpu(lvb->lvb_nodenum);\n\t\t\tinfo->tf_start = be64_to_cpu(lvb->lvb_start);\n\t\t\tinfo->tf_len = be64_to_cpu(lvb->lvb_len);\n\t\t\tinfo->tf_minlen = be64_to_cpu(lvb->lvb_minlen);\n\t\t\tinfo->tf_trimlen = be64_to_cpu(lvb->lvb_trimlen);\n\t\t}\n\t}\n\n\treturn status;\n}\n\nvoid ocfs2_trim_fs_unlock(struct ocfs2_super *osb,\n\t\t\t  struct ocfs2_trim_fs_info *info)\n{\n\tstruct ocfs2_trim_fs_lvb *lvb;\n\tstruct ocfs2_lock_res *lockres = &osb->osb_trim_fs_lockres;\n\n\tif (ocfs2_mount_local(osb))\n\t\treturn;\n\n\tif (info) {\n\t\tlvb = ocfs2_dlm_lvb(&lockres->l_lksb);\n\t\tlvb->lvb_version = OCFS2_TRIMFS_LVB_VERSION;\n\t\tlvb->lvb_success = info->tf_success;\n\t\tlvb->lvb_nodenum = cpu_to_be32(info->tf_nodenum);\n\t\tlvb->lvb_start = cpu_to_be64(info->tf_start);\n\t\tlvb->lvb_len = cpu_to_be64(info->tf_len);\n\t\tlvb->lvb_minlen = cpu_to_be64(info->tf_minlen);\n\t\tlvb->lvb_trimlen = cpu_to_be64(info->tf_trimlen);\n\t}\n\n\tocfs2_cluster_unlock(osb, lockres, DLM_LOCK_EX);\n}\n\nint ocfs2_dentry_lock(struct dentry *dentry, int ex)\n{\n\tint ret;\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_dentry_lock *dl = dentry->d_fsdata;\n\tstruct ocfs2_super *osb = OCFS2_SB(dentry->d_sb);\n\n\tBUG_ON(!dl);\n\n\tif (ocfs2_is_hard_readonly(osb)) {\n\t\tif (ex)\n\t\t\treturn -EROFS;\n\t\treturn 0;\n\t}\n\n\tif (ocfs2_mount_local(osb))\n\t\treturn 0;\n\n\tret = ocfs2_cluster_lock(osb, &dl->dl_lockres, level, 0, 0);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\treturn ret;\n}\n\nvoid ocfs2_dentry_unlock(struct dentry *dentry, int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_dentry_lock *dl = dentry->d_fsdata;\n\tstruct ocfs2_super *osb = OCFS2_SB(dentry->d_sb);\n\n\tif (!ocfs2_is_hard_readonly(osb) && !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(osb, &dl->dl_lockres, level);\n}\n\n \nstatic void ocfs2_dlm_debug_free(struct kref *kref)\n{\n\tstruct ocfs2_dlm_debug *dlm_debug;\n\n\tdlm_debug = container_of(kref, struct ocfs2_dlm_debug, d_refcnt);\n\n\tkfree(dlm_debug);\n}\n\nvoid ocfs2_put_dlm_debug(struct ocfs2_dlm_debug *dlm_debug)\n{\n\tif (dlm_debug)\n\t\tkref_put(&dlm_debug->d_refcnt, ocfs2_dlm_debug_free);\n}\n\nstatic void ocfs2_get_dlm_debug(struct ocfs2_dlm_debug *debug)\n{\n\tkref_get(&debug->d_refcnt);\n}\n\nstruct ocfs2_dlm_debug *ocfs2_new_dlm_debug(void)\n{\n\tstruct ocfs2_dlm_debug *dlm_debug;\n\n\tdlm_debug = kmalloc(sizeof(struct ocfs2_dlm_debug), GFP_KERNEL);\n\tif (!dlm_debug) {\n\t\tmlog_errno(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\tkref_init(&dlm_debug->d_refcnt);\n\tINIT_LIST_HEAD(&dlm_debug->d_lockres_tracking);\n\tdlm_debug->d_filter_secs = 0;\nout:\n\treturn dlm_debug;\n}\n\n \nstruct ocfs2_dlm_seq_priv {\n\tstruct ocfs2_dlm_debug *p_dlm_debug;\n\tstruct ocfs2_lock_res p_iter_res;\n\tstruct ocfs2_lock_res p_tmp_res;\n};\n\nstatic struct ocfs2_lock_res *ocfs2_dlm_next_res(struct ocfs2_lock_res *start,\n\t\t\t\t\t\t struct ocfs2_dlm_seq_priv *priv)\n{\n\tstruct ocfs2_lock_res *iter, *ret = NULL;\n\tstruct ocfs2_dlm_debug *dlm_debug = priv->p_dlm_debug;\n\n\tassert_spin_locked(&ocfs2_dlm_tracking_lock);\n\n\tlist_for_each_entry(iter, &start->l_debug_list, l_debug_list) {\n\t\t \n\t\tif (&iter->l_debug_list == &dlm_debug->d_lockres_tracking) {\n\t\t\tmlog(0, \"End of list found, %p\\n\", ret);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (iter->l_ops != NULL) {\n\t\t\tret = iter;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic void *ocfs2_dlm_seq_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct ocfs2_dlm_seq_priv *priv = m->private;\n\tstruct ocfs2_lock_res *iter;\n\n\tspin_lock(&ocfs2_dlm_tracking_lock);\n\titer = ocfs2_dlm_next_res(&priv->p_iter_res, priv);\n\tif (iter) {\n\t\t \n\t\tpriv->p_tmp_res = *iter;\n\t\titer = &priv->p_tmp_res;\n\t}\n\tspin_unlock(&ocfs2_dlm_tracking_lock);\n\n\treturn iter;\n}\n\nstatic void ocfs2_dlm_seq_stop(struct seq_file *m, void *v)\n{\n}\n\nstatic void *ocfs2_dlm_seq_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct ocfs2_dlm_seq_priv *priv = m->private;\n\tstruct ocfs2_lock_res *iter = v;\n\tstruct ocfs2_lock_res *dummy = &priv->p_iter_res;\n\n\tspin_lock(&ocfs2_dlm_tracking_lock);\n\titer = ocfs2_dlm_next_res(iter, priv);\n\tlist_del_init(&dummy->l_debug_list);\n\tif (iter) {\n\t\tlist_add(&dummy->l_debug_list, &iter->l_debug_list);\n\t\tpriv->p_tmp_res = *iter;\n\t\titer = &priv->p_tmp_res;\n\t}\n\tspin_unlock(&ocfs2_dlm_tracking_lock);\n\n\treturn iter;\n}\n\n \n#define OCFS2_DLM_DEBUG_STR_VERSION 4\nstatic int ocfs2_dlm_seq_show(struct seq_file *m, void *v)\n{\n\tint i;\n\tchar *lvb;\n\tstruct ocfs2_lock_res *lockres = v;\n#ifdef CONFIG_OCFS2_FS_STATS\n\tu64 now, last;\n\tstruct ocfs2_dlm_debug *dlm_debug =\n\t\t\t((struct ocfs2_dlm_seq_priv *)m->private)->p_dlm_debug;\n#endif\n\n\tif (!lockres)\n\t\treturn -EINVAL;\n\n#ifdef CONFIG_OCFS2_FS_STATS\n\tif (!lockres->l_lock_wait && dlm_debug->d_filter_secs) {\n\t\tnow = ktime_to_us(ktime_get_real());\n\t\tif (lockres->l_lock_prmode.ls_last >\n\t\t    lockres->l_lock_exmode.ls_last)\n\t\t\tlast = lockres->l_lock_prmode.ls_last;\n\t\telse\n\t\t\tlast = lockres->l_lock_exmode.ls_last;\n\t\t \n\t\tif (div_u64(now - last, 1000000) > dlm_debug->d_filter_secs)\n\t\t\treturn 0;\n\t}\n#endif\n\n\tseq_printf(m, \"0x%x\\t\", OCFS2_DLM_DEBUG_STR_VERSION);\n\n\tif (lockres->l_type == OCFS2_LOCK_TYPE_DENTRY)\n\t\tseq_printf(m, \"%.*s%08x\\t\", OCFS2_DENTRY_LOCK_INO_START - 1,\n\t\t\t   lockres->l_name,\n\t\t\t   (unsigned int)ocfs2_get_dentry_lock_ino(lockres));\n\telse\n\t\tseq_printf(m, \"%.*s\\t\", OCFS2_LOCK_ID_MAX_LEN, lockres->l_name);\n\n\tseq_printf(m, \"%d\\t\"\n\t\t   \"0x%lx\\t\"\n\t\t   \"0x%x\\t\"\n\t\t   \"0x%x\\t\"\n\t\t   \"%u\\t\"\n\t\t   \"%u\\t\"\n\t\t   \"%d\\t\"\n\t\t   \"%d\\t\",\n\t\t   lockres->l_level,\n\t\t   lockres->l_flags,\n\t\t   lockres->l_action,\n\t\t   lockres->l_unlock_action,\n\t\t   lockres->l_ro_holders,\n\t\t   lockres->l_ex_holders,\n\t\t   lockres->l_requested,\n\t\t   lockres->l_blocking);\n\n\t \n\tlvb = ocfs2_dlm_lvb(&lockres->l_lksb);\n\tfor(i = 0; i < DLM_LVB_LEN; i++)\n\t\tseq_printf(m, \"0x%x\\t\", lvb[i]);\n\n#ifdef CONFIG_OCFS2_FS_STATS\n# define lock_num_prmode(_l)\t\t((_l)->l_lock_prmode.ls_gets)\n# define lock_num_exmode(_l)\t\t((_l)->l_lock_exmode.ls_gets)\n# define lock_num_prmode_failed(_l)\t((_l)->l_lock_prmode.ls_fail)\n# define lock_num_exmode_failed(_l)\t((_l)->l_lock_exmode.ls_fail)\n# define lock_total_prmode(_l)\t\t((_l)->l_lock_prmode.ls_total)\n# define lock_total_exmode(_l)\t\t((_l)->l_lock_exmode.ls_total)\n# define lock_max_prmode(_l)\t\t((_l)->l_lock_prmode.ls_max)\n# define lock_max_exmode(_l)\t\t((_l)->l_lock_exmode.ls_max)\n# define lock_refresh(_l)\t\t((_l)->l_lock_refresh)\n# define lock_last_prmode(_l)\t\t((_l)->l_lock_prmode.ls_last)\n# define lock_last_exmode(_l)\t\t((_l)->l_lock_exmode.ls_last)\n# define lock_wait(_l)\t\t\t((_l)->l_lock_wait)\n#else\n# define lock_num_prmode(_l)\t\t(0)\n# define lock_num_exmode(_l)\t\t(0)\n# define lock_num_prmode_failed(_l)\t(0)\n# define lock_num_exmode_failed(_l)\t(0)\n# define lock_total_prmode(_l)\t\t(0ULL)\n# define lock_total_exmode(_l)\t\t(0ULL)\n# define lock_max_prmode(_l)\t\t(0)\n# define lock_max_exmode(_l)\t\t(0)\n# define lock_refresh(_l)\t\t(0)\n# define lock_last_prmode(_l)\t\t(0ULL)\n# define lock_last_exmode(_l)\t\t(0ULL)\n# define lock_wait(_l)\t\t\t(0ULL)\n#endif\n\t \n\tseq_printf(m, \"%u\\t\"\n\t\t   \"%u\\t\"\n\t\t   \"%u\\t\"\n\t\t   \"%u\\t\"\n\t\t   \"%llu\\t\"\n\t\t   \"%llu\\t\"\n\t\t   \"%u\\t\"\n\t\t   \"%u\\t\"\n\t\t   \"%u\\t\"\n\t\t   \"%llu\\t\"\n\t\t   \"%llu\\t\"\n\t\t   \"%llu\\t\",\n\t\t   lock_num_prmode(lockres),\n\t\t   lock_num_exmode(lockres),\n\t\t   lock_num_prmode_failed(lockres),\n\t\t   lock_num_exmode_failed(lockres),\n\t\t   lock_total_prmode(lockres),\n\t\t   lock_total_exmode(lockres),\n\t\t   lock_max_prmode(lockres),\n\t\t   lock_max_exmode(lockres),\n\t\t   lock_refresh(lockres),\n\t\t   lock_last_prmode(lockres),\n\t\t   lock_last_exmode(lockres),\n\t\t   lock_wait(lockres));\n\n\t \n\tseq_printf(m, \"\\n\");\n\treturn 0;\n}\n\nstatic const struct seq_operations ocfs2_dlm_seq_ops = {\n\t.start =\tocfs2_dlm_seq_start,\n\t.stop =\t\tocfs2_dlm_seq_stop,\n\t.next =\t\tocfs2_dlm_seq_next,\n\t.show =\t\tocfs2_dlm_seq_show,\n};\n\nstatic int ocfs2_dlm_debug_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\tstruct ocfs2_dlm_seq_priv *priv = seq->private;\n\tstruct ocfs2_lock_res *res = &priv->p_iter_res;\n\n\tocfs2_remove_lockres_tracking(res);\n\tocfs2_put_dlm_debug(priv->p_dlm_debug);\n\treturn seq_release_private(inode, file);\n}\n\nstatic int ocfs2_dlm_debug_open(struct inode *inode, struct file *file)\n{\n\tstruct ocfs2_dlm_seq_priv *priv;\n\tstruct ocfs2_super *osb;\n\n\tpriv = __seq_open_private(file, &ocfs2_dlm_seq_ops, sizeof(*priv));\n\tif (!priv) {\n\t\tmlog_errno(-ENOMEM);\n\t\treturn -ENOMEM;\n\t}\n\n\tosb = inode->i_private;\n\tocfs2_get_dlm_debug(osb->osb_dlm_debug);\n\tpriv->p_dlm_debug = osb->osb_dlm_debug;\n\tINIT_LIST_HEAD(&priv->p_iter_res.l_debug_list);\n\n\tocfs2_add_lockres_tracking(&priv->p_iter_res,\n\t\t\t\t   priv->p_dlm_debug);\n\n\treturn 0;\n}\n\nstatic const struct file_operations ocfs2_dlm_debug_fops = {\n\t.open =\t\tocfs2_dlm_debug_open,\n\t.release =\tocfs2_dlm_debug_release,\n\t.read =\t\tseq_read,\n\t.llseek =\tseq_lseek,\n};\n\nstatic void ocfs2_dlm_init_debug(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_dlm_debug *dlm_debug = osb->osb_dlm_debug;\n\n\tdebugfs_create_file(\"locking_state\", S_IFREG|S_IRUSR,\n\t\t\t    osb->osb_debug_root, osb, &ocfs2_dlm_debug_fops);\n\n\tdebugfs_create_u32(\"locking_filter\", 0600, osb->osb_debug_root,\n\t\t\t   &dlm_debug->d_filter_secs);\n\tocfs2_get_dlm_debug(dlm_debug);\n}\n\nstatic void ocfs2_dlm_shutdown_debug(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_dlm_debug *dlm_debug = osb->osb_dlm_debug;\n\n\tif (dlm_debug)\n\t\tocfs2_put_dlm_debug(dlm_debug);\n}\n\nint ocfs2_dlm_init(struct ocfs2_super *osb)\n{\n\tint status = 0;\n\tstruct ocfs2_cluster_connection *conn = NULL;\n\n\tif (ocfs2_mount_local(osb)) {\n\t\tosb->node_num = 0;\n\t\tgoto local;\n\t}\n\n\tocfs2_dlm_init_debug(osb);\n\n\t \n\tosb->dc_task = kthread_run(ocfs2_downconvert_thread, osb, \"ocfs2dc-%s\",\n\t\t\tosb->uuid_str);\n\tif (IS_ERR(osb->dc_task)) {\n\t\tstatus = PTR_ERR(osb->dc_task);\n\t\tosb->dc_task = NULL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t \n\tstatus = ocfs2_cluster_connect(osb->osb_cluster_stack,\n\t\t\t\t       osb->osb_cluster_name,\n\t\t\t\t       strlen(osb->osb_cluster_name),\n\t\t\t\t       osb->uuid_str,\n\t\t\t\t       strlen(osb->uuid_str),\n\t\t\t\t       &lproto, ocfs2_do_node_down, osb,\n\t\t\t\t       &conn);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_cluster_this_node(conn, &osb->node_num);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tmlog(ML_ERROR,\n\t\t     \"could not find this host's node number\\n\");\n\t\tocfs2_cluster_disconnect(conn, 0);\n\t\tgoto bail;\n\t}\n\nlocal:\n\tocfs2_super_lock_res_init(&osb->osb_super_lockres, osb);\n\tocfs2_rename_lock_res_init(&osb->osb_rename_lockres, osb);\n\tocfs2_nfs_sync_lock_init(osb);\n\tocfs2_orphan_scan_lock_res_init(&osb->osb_orphan_scan.os_lockres, osb);\n\n\tosb->cconn = conn;\nbail:\n\tif (status < 0) {\n\t\tocfs2_dlm_shutdown_debug(osb);\n\t\tif (osb->dc_task)\n\t\t\tkthread_stop(osb->dc_task);\n\t}\n\n\treturn status;\n}\n\nvoid ocfs2_dlm_shutdown(struct ocfs2_super *osb,\n\t\t\tint hangup_pending)\n{\n\tocfs2_drop_osb_locks(osb);\n\n\t \n\n\tif (osb->dc_task) {\n\t\tkthread_stop(osb->dc_task);\n\t\tosb->dc_task = NULL;\n\t}\n\n\tocfs2_lock_res_free(&osb->osb_super_lockres);\n\tocfs2_lock_res_free(&osb->osb_rename_lockres);\n\tocfs2_lock_res_free(&osb->osb_nfs_sync_lockres);\n\tocfs2_lock_res_free(&osb->osb_orphan_scan.os_lockres);\n\n\tif (osb->cconn) {\n\t\tocfs2_cluster_disconnect(osb->cconn, hangup_pending);\n\t\tosb->cconn = NULL;\n\n\t\tocfs2_dlm_shutdown_debug(osb);\n\t}\n}\n\nstatic int ocfs2_drop_lock(struct ocfs2_super *osb,\n\t\t\t   struct ocfs2_lock_res *lockres)\n{\n\tint ret;\n\tunsigned long flags;\n\tu32 lkm_flags = 0;\n\n\t \n\tif (!(lockres->l_flags & OCFS2_LOCK_INITIALIZED))\n\t\tgoto out;\n\n\tif (lockres->l_ops->flags & LOCK_TYPE_USES_LVB)\n\t\tlkm_flags |= DLM_LKF_VALBLK;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\n\tmlog_bug_on_msg(!(lockres->l_flags & OCFS2_LOCK_FREEING),\n\t\t\t\"lockres %s, flags 0x%lx\\n\",\n\t\t\tlockres->l_name, lockres->l_flags);\n\n\twhile (lockres->l_flags & OCFS2_LOCK_BUSY) {\n\t\tmlog(0, \"waiting on busy lock \\\"%s\\\": flags = %lx, action = \"\n\t\t     \"%u, unlock_action = %u\\n\",\n\t\t     lockres->l_name, lockres->l_flags, lockres->l_action,\n\t\t     lockres->l_unlock_action);\n\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\t\t \n\t\tocfs2_wait_on_busy_lock(lockres);\n\n\t\tspin_lock_irqsave(&lockres->l_lock, flags);\n\t}\n\n\tif (lockres->l_ops->flags & LOCK_TYPE_USES_LVB) {\n\t\tif (lockres->l_flags & OCFS2_LOCK_ATTACHED &&\n\t\t    lockres->l_level == DLM_LOCK_EX &&\n\t\t    !(lockres->l_flags & OCFS2_LOCK_NEEDS_REFRESH))\n\t\t\tlockres->l_ops->set_lvb(lockres);\n\t}\n\n\tif (lockres->l_flags & OCFS2_LOCK_BUSY)\n\t\tmlog(ML_ERROR, \"destroying busy lock: \\\"%s\\\"\\n\",\n\t\t     lockres->l_name);\n\tif (lockres->l_flags & OCFS2_LOCK_BLOCKED)\n\t\tmlog(0, \"destroying blocked lock: \\\"%s\\\"\\n\", lockres->l_name);\n\n\tif (!(lockres->l_flags & OCFS2_LOCK_ATTACHED)) {\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\tgoto out;\n\t}\n\n\tlockres_clear_flags(lockres, OCFS2_LOCK_ATTACHED);\n\n\t \n\tBUG_ON(lockres->l_action != OCFS2_AST_INVALID);\n\n\t \n\tlockres_or_flags(lockres, OCFS2_LOCK_BUSY);\n\tlockres->l_unlock_action = OCFS2_UNLOCK_DROP_LOCK;\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\tmlog(0, \"lock %s\\n\", lockres->l_name);\n\n\tret = ocfs2_dlm_unlock(osb->cconn, &lockres->l_lksb, lkm_flags);\n\tif (ret) {\n\t\tocfs2_log_dlm_error(\"ocfs2_dlm_unlock\", ret, lockres);\n\t\tmlog(ML_ERROR, \"lockres flags: %lu\\n\", lockres->l_flags);\n\t\tocfs2_dlm_dump_lksb(&lockres->l_lksb);\n\t\tBUG();\n\t}\n\tmlog(0, \"lock %s, successful return from ocfs2_dlm_unlock\\n\",\n\t     lockres->l_name);\n\n\tocfs2_wait_on_busy_lock(lockres);\nout:\n\treturn 0;\n}\n\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\n \nvoid ocfs2_mark_lockres_freeing(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres)\n{\n\tint status;\n\tstruct ocfs2_mask_waiter mw;\n\tunsigned long flags, flags2;\n\n\tocfs2_init_mask_waiter(&mw);\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tlockres->l_flags |= OCFS2_LOCK_FREEING;\n\tif (lockres->l_flags & OCFS2_LOCK_QUEUED && current == osb->dc_task) {\n\t\t \n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\tspin_lock_irqsave(&osb->dc_task_lock, flags2);\n\t\tlist_del_init(&lockres->l_blocked_list);\n\t\tosb->blocked_lock_count--;\n\t\tspin_unlock_irqrestore(&osb->dc_task_lock, flags2);\n\t\t \n\t\tWARN_ON_ONCE(lockres->l_ops->post_unlock);\n\t\t \n\t\tocfs2_process_blocked_lock(osb, lockres);\n\t\treturn;\n\t}\n\twhile (lockres->l_flags & OCFS2_LOCK_QUEUED) {\n\t\tlockres_add_mask_waiter(lockres, &mw, OCFS2_LOCK_QUEUED, 0);\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\t\tmlog(0, \"Waiting on lockres %s\\n\", lockres->l_name);\n\n\t\tstatus = ocfs2_wait_for_mask(&mw);\n\t\tif (status)\n\t\t\tmlog_errno(status);\n\n\t\tspin_lock_irqsave(&lockres->l_lock, flags);\n\t}\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n}\n\nvoid ocfs2_simple_drop_lockres(struct ocfs2_super *osb,\n\t\t\t       struct ocfs2_lock_res *lockres)\n{\n\tint ret;\n\n\tocfs2_mark_lockres_freeing(osb, lockres);\n\tret = ocfs2_drop_lock(osb, lockres);\n\tif (ret)\n\t\tmlog_errno(ret);\n}\n\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb)\n{\n\tocfs2_simple_drop_lockres(osb, &osb->osb_super_lockres);\n\tocfs2_simple_drop_lockres(osb, &osb->osb_rename_lockres);\n\tocfs2_simple_drop_lockres(osb, &osb->osb_nfs_sync_lockres);\n\tocfs2_simple_drop_lockres(osb, &osb->osb_orphan_scan.os_lockres);\n}\n\nint ocfs2_drop_inode_locks(struct inode *inode)\n{\n\tint status, err;\n\n\t \n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_open_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\n\tstatus = err;\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_inode_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\tif (err < 0 && !status)\n\t\tstatus = err;\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_rw_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\tif (err < 0 && !status)\n\t\tstatus = err;\n\n\treturn status;\n}\n\nstatic unsigned int ocfs2_prepare_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t      int new_level)\n{\n\tassert_spin_locked(&lockres->l_lock);\n\n\tBUG_ON(lockres->l_blocking <= DLM_LOCK_NL);\n\n\tif (lockres->l_level <= new_level) {\n\t\tmlog(ML_ERROR, \"lockres %s, lvl %d <= %d, blcklst %d, mask %d, \"\n\t\t     \"type %d, flags 0x%lx, hold %d %d, act %d %d, req %d, \"\n\t\t     \"block %d, pgen %d\\n\", lockres->l_name, lockres->l_level,\n\t\t     new_level, list_empty(&lockres->l_blocked_list),\n\t\t     list_empty(&lockres->l_mask_waiters), lockres->l_type,\n\t\t     lockres->l_flags, lockres->l_ro_holders,\n\t\t     lockres->l_ex_holders, lockres->l_action,\n\t\t     lockres->l_unlock_action, lockres->l_requested,\n\t\t     lockres->l_blocking, lockres->l_pending_gen);\n\t\tBUG();\n\t}\n\n\tmlog(ML_BASTS, \"lockres %s, level %d => %d, blocking %d\\n\",\n\t     lockres->l_name, lockres->l_level, new_level, lockres->l_blocking);\n\n\tlockres->l_action = OCFS2_AST_DOWNCONVERT;\n\tlockres->l_requested = new_level;\n\tlockres_or_flags(lockres, OCFS2_LOCK_BUSY);\n\treturn lockres_set_pending(lockres);\n}\n\nstatic int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation)\n{\n\tint ret;\n\tu32 dlm_flags = DLM_LKF_CONVERT;\n\n\tmlog(ML_BASTS, \"lockres %s, level %d => %d\\n\", lockres->l_name,\n\t     lockres->l_level, new_level);\n\n\t \n\tif (ocfs2_userspace_stack(osb) &&\n\t    lockres->l_ops->flags & LOCK_TYPE_USES_LVB)\n\t\tlvb = 1;\n\n\tif (lvb)\n\t\tdlm_flags |= DLM_LKF_VALBLK;\n\n\tret = ocfs2_dlm_lock(osb->cconn,\n\t\t\t     new_level,\n\t\t\t     &lockres->l_lksb,\n\t\t\t     dlm_flags,\n\t\t\t     lockres->l_name,\n\t\t\t     OCFS2_LOCK_ID_MAX_LEN - 1);\n\tlockres_clear_pending(lockres, generation, osb);\n\tif (ret) {\n\t\tocfs2_log_dlm_error(\"ocfs2_dlm_lock\", ret, lockres);\n\t\tocfs2_recover_from_dlm_error(lockres, 1);\n\t\tgoto bail;\n\t}\n\n\tret = 0;\nbail:\n\treturn ret;\n}\n\n \nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres)\n{\n\tassert_spin_locked(&lockres->l_lock);\n\n\tif (lockres->l_unlock_action == OCFS2_UNLOCK_CANCEL_CONVERT) {\n\t\t \n\t\tmlog(ML_BASTS, \"lockres %s, skip convert\\n\", lockres->l_name);\n\t\treturn 0;\n\t}\n\n\t \n\tBUG_ON(lockres->l_action != OCFS2_AST_CONVERT &&\n\t       lockres->l_action != OCFS2_AST_DOWNCONVERT);\n\t \n\tlockres->l_unlock_action = OCFS2_UNLOCK_CANCEL_CONVERT;\n\n\tmlog_bug_on_msg(!(lockres->l_flags & OCFS2_LOCK_BUSY),\n\t\t\t\"lock %s, invalid flags: 0x%lx\\n\",\n\t\t\tlockres->l_name, lockres->l_flags);\n\n\tmlog(ML_BASTS, \"lockres %s\\n\", lockres->l_name);\n\n\treturn 1;\n}\n\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres)\n{\n\tint ret;\n\n\tret = ocfs2_dlm_unlock(osb->cconn, &lockres->l_lksb,\n\t\t\t       DLM_LKF_CANCEL);\n\tif (ret) {\n\t\tocfs2_log_dlm_error(\"ocfs2_dlm_unlock\", ret, lockres);\n\t\tocfs2_recover_from_dlm_error(lockres, 0);\n\t}\n\n\tmlog(ML_BASTS, \"lockres %s\\n\", lockres->l_name);\n\n\treturn ret;\n}\n\nstatic int ocfs2_unblock_lock(struct ocfs2_super *osb,\n\t\t\t      struct ocfs2_lock_res *lockres,\n\t\t\t      struct ocfs2_unblock_ctl *ctl)\n{\n\tunsigned long flags;\n\tint blocking;\n\tint new_level;\n\tint level;\n\tint ret = 0;\n\tint set_lvb = 0;\n\tunsigned int gen;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\nrecheck:\n\t \n\tif (!(lockres->l_flags & OCFS2_LOCK_BLOCKED)) {\n\t\tBUG_ON(lockres->l_blocking != DLM_LOCK_NL);\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\tret = 0;\n\t\tgoto leave;\n\t}\n\n\tif (lockres->l_flags & OCFS2_LOCK_BUSY) {\n\t\t \n\t\tif (lockres->l_flags & OCFS2_LOCK_PENDING) {\n\t\t\tmlog(ML_BASTS, \"lockres %s, ReQ: Pending\\n\",\n\t\t\t     lockres->l_name);\n\t\t\tgoto leave_requeue;\n\t\t}\n\n\t\tctl->requeue = 1;\n\t\tret = ocfs2_prepare_cancel_convert(osb, lockres);\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\tif (ret) {\n\t\t\tret = ocfs2_cancel_convert(osb, lockres);\n\t\t\tif (ret < 0)\n\t\t\t\tmlog_errno(ret);\n\t\t}\n\t\tgoto leave;\n\t}\n\n\t \n\tif (lockres->l_flags & OCFS2_LOCK_UPCONVERT_FINISHING)\n\t\tgoto leave_requeue;\n\n\t \n\tif (lockres->l_level == DLM_LOCK_NL) {\n\t\tBUG_ON(lockres->l_ex_holders || lockres->l_ro_holders);\n\t\tmlog(ML_BASTS, \"lockres %s, Aborting dc\\n\", lockres->l_name);\n\t\tlockres->l_blocking = DLM_LOCK_NL;\n\t\tlockres_clear_flags(lockres, OCFS2_LOCK_BLOCKED);\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\tgoto leave;\n\t}\n\n\t \n\tif ((lockres->l_blocking == DLM_LOCK_EX)\n\t    && (lockres->l_ex_holders || lockres->l_ro_holders)) {\n\t\tmlog(ML_BASTS, \"lockres %s, ReQ: EX/PR Holders %u,%u\\n\",\n\t\t     lockres->l_name, lockres->l_ex_holders,\n\t\t     lockres->l_ro_holders);\n\t\tgoto leave_requeue;\n\t}\n\n\t \n\tif (lockres->l_blocking == DLM_LOCK_PR &&\n\t    lockres->l_ex_holders) {\n\t\tmlog(ML_BASTS, \"lockres %s, ReQ: EX Holders %u\\n\",\n\t\t     lockres->l_name, lockres->l_ex_holders);\n\t\tgoto leave_requeue;\n\t}\n\n\t \n\tif ((lockres->l_ops->flags & LOCK_TYPE_REQUIRES_REFRESH)\n\t    && (lockres->l_flags & OCFS2_LOCK_REFRESHING)) {\n\t\tmlog(ML_BASTS, \"lockres %s, ReQ: Lock Refreshing\\n\",\n\t\t     lockres->l_name);\n\t\tgoto leave_requeue;\n\t}\n\n\tnew_level = ocfs2_highest_compat_lock_level(lockres->l_blocking);\n\n\tif (lockres->l_ops->check_downconvert\n\t    && !lockres->l_ops->check_downconvert(lockres, new_level)) {\n\t\tmlog(ML_BASTS, \"lockres %s, ReQ: Checkpointing\\n\",\n\t\t     lockres->l_name);\n\t\tgoto leave_requeue;\n\t}\n\n\t \n\tif (!lockres->l_ops->downconvert_worker)\n\t\tgoto downconvert;\n\n\t \n\tblocking = lockres->l_blocking;\n\tlevel = lockres->l_level;\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\tctl->unblock_action = lockres->l_ops->downconvert_worker(lockres, blocking);\n\n\tif (ctl->unblock_action == UNBLOCK_STOP_POST) {\n\t\tmlog(ML_BASTS, \"lockres %s, UNBLOCK_STOP_POST\\n\",\n\t\t     lockres->l_name);\n\t\tgoto leave;\n\t}\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tif ((blocking != lockres->l_blocking) || (level != lockres->l_level)) {\n\t\t \n\t\tmlog(ML_BASTS, \"lockres %s, block=%d:%d, level=%d:%d, \"\n\t\t     \"Recheck\\n\", lockres->l_name, blocking,\n\t\t     lockres->l_blocking, level, lockres->l_level);\n\t\tgoto recheck;\n\t}\n\ndownconvert:\n\tctl->requeue = 0;\n\n\tif (lockres->l_ops->flags & LOCK_TYPE_USES_LVB) {\n\t\tif (lockres->l_level == DLM_LOCK_EX)\n\t\t\tset_lvb = 1;\n\n\t\t \n\t\tif (set_lvb && !(lockres->l_flags & OCFS2_LOCK_NEEDS_REFRESH))\n\t\t\tlockres->l_ops->set_lvb(lockres);\n\t}\n\n\tgen = ocfs2_prepare_downconvert(lockres, new_level);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\tret = ocfs2_downconvert_lock(osb, lockres, new_level, set_lvb,\n\t\t\t\t     gen);\n\t \n\tif (ret == -EBUSY) {\n\t\tctl->requeue = 1;\n\t\tmlog(ML_BASTS, \"lockres %s, ReQ: Downconvert busy\\n\",\n\t\t     lockres->l_name);\n\t\tret = 0;\n\t\tmsleep(20);\n\t}\n\nleave:\n\tif (ret)\n\t\tmlog_errno(ret);\n\treturn ret;\n\nleave_requeue:\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\tctl->requeue = 1;\n\n\treturn 0;\n}\n\nstatic int ocfs2_data_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t     int blocking)\n{\n\tstruct inode *inode;\n\tstruct address_space *mapping;\n\tstruct ocfs2_inode_info *oi;\n\n       \tinode = ocfs2_lock_res_inode(lockres);\n\tmapping = inode->i_mapping;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\toi = OCFS2_I(inode);\n\t\toi->ip_dir_lock_gen++;\n\t\tmlog(0, \"generation: %u\\n\", oi->ip_dir_lock_gen);\n\t\tgoto out_forget;\n\t}\n\n\tif (!S_ISREG(inode->i_mode))\n\t\tgoto out;\n\n\t \n\tunmap_mapping_range(mapping, 0, 0, 0);\n\n\tif (filemap_fdatawrite(mapping)) {\n\t\tmlog(ML_ERROR, \"Could not sync inode %llu for downconvert!\",\n\t\t     (unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t}\n\tsync_mapping_buffers(mapping);\n\tif (blocking == DLM_LOCK_EX) {\n\t\ttruncate_inode_pages(mapping, 0);\n\t} else {\n\t\t \n\t\tfilemap_fdatawait(mapping);\n\t}\n\nout_forget:\n\tforget_all_cached_acls(inode);\n\nout:\n\treturn UNBLOCK_CONTINUE;\n}\n\nstatic int ocfs2_ci_checkpointed(struct ocfs2_caching_info *ci,\n\t\t\t\t struct ocfs2_lock_res *lockres,\n\t\t\t\t int new_level)\n{\n\tint checkpointed = ocfs2_ci_fully_checkpointed(ci);\n\n\tBUG_ON(new_level != DLM_LOCK_NL && new_level != DLM_LOCK_PR);\n\tBUG_ON(lockres->l_level != DLM_LOCK_EX && !checkpointed);\n\n\tif (checkpointed)\n\t\treturn 1;\n\n\tocfs2_start_checkpoint(OCFS2_SB(ocfs2_metadata_cache_get_super(ci)));\n\treturn 0;\n}\n\nstatic int ocfs2_check_meta_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\tint new_level)\n{\n\tstruct inode *inode = ocfs2_lock_res_inode(lockres);\n\n\treturn ocfs2_ci_checkpointed(INODE_CACHE(inode), lockres, new_level);\n}\n\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres)\n{\n\tstruct inode *inode = ocfs2_lock_res_inode(lockres);\n\n\t__ocfs2_stuff_meta_lvb(inode);\n}\n\n \nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres)\n{\n\tstruct ocfs2_dentry_lock *dl = ocfs2_lock_res_dl(lockres);\n\tocfs2_dentry_lock_put(osb, dl);\n}\n\n \nstatic int ocfs2_dentry_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t       int blocking)\n{\n\tstruct ocfs2_dentry_lock *dl = ocfs2_lock_res_dl(lockres);\n\tstruct ocfs2_inode_info *oi = OCFS2_I(dl->dl_inode);\n\tstruct dentry *dentry;\n\tunsigned long flags;\n\tint extra_ref = 0;\n\n\t \n\tif (blocking == DLM_LOCK_PR)\n\t\treturn UNBLOCK_CONTINUE;\n\n\t \n\tspin_lock(&oi->ip_lock);\n\toi->ip_flags |= OCFS2_INODE_MAYBE_ORPHANED;\n\tspin_unlock(&oi->ip_lock);\n\n\t \n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tspin_lock(&dentry_attach_lock);\n\tif (!(lockres->l_flags & OCFS2_LOCK_FREEING)\n\t    && dl->dl_count) {\n\t\tdl->dl_count++;\n\t\textra_ref = 1;\n\t}\n\tspin_unlock(&dentry_attach_lock);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\tmlog(0, \"extra_ref = %d\\n\", extra_ref);\n\n\t \n\tif (!extra_ref)\n\t\treturn UNBLOCK_CONTINUE;\n\n\tspin_lock(&dentry_attach_lock);\n\twhile (1) {\n\t\tdentry = ocfs2_find_local_alias(dl->dl_inode,\n\t\t\t\t\t\tdl->dl_parent_blkno, 1);\n\t\tif (!dentry)\n\t\t\tbreak;\n\t\tspin_unlock(&dentry_attach_lock);\n\n\t\tif (S_ISDIR(dl->dl_inode->i_mode))\n\t\t\tshrink_dcache_parent(dentry);\n\n\t\tmlog(0, \"d_delete(%pd);\\n\", dentry);\n\n\t\t \n\t\td_delete(dentry);\n\t\tdput(dentry);\n\n\t\tspin_lock(&dentry_attach_lock);\n\t}\n\tspin_unlock(&dentry_attach_lock);\n\n\t \n\tif (dl->dl_count == 1)\n\t\treturn UNBLOCK_STOP_POST;\n\n\treturn UNBLOCK_CONTINUE_POST;\n}\n\nstatic int ocfs2_check_refcount_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t    int new_level)\n{\n\tstruct ocfs2_refcount_tree *tree =\n\t\t\t\tocfs2_lock_res_refcount_tree(lockres);\n\n\treturn ocfs2_ci_checkpointed(&tree->rf_ci, lockres, new_level);\n}\n\nstatic int ocfs2_refcount_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t int blocking)\n{\n\tstruct ocfs2_refcount_tree *tree =\n\t\t\t\tocfs2_lock_res_refcount_tree(lockres);\n\n\tocfs2_metadata_cache_purge(&tree->rf_ci);\n\n\treturn UNBLOCK_CONTINUE;\n}\n\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres)\n{\n\tstruct ocfs2_qinfo_lvb *lvb;\n\tstruct ocfs2_mem_dqinfo *oinfo = ocfs2_lock_res_qinfo(lockres);\n\tstruct mem_dqinfo *info = sb_dqinfo(oinfo->dqi_gi.dqi_sb,\n\t\t\t\t\t    oinfo->dqi_gi.dqi_type);\n\n\tlvb = ocfs2_dlm_lvb(&lockres->l_lksb);\n\tlvb->lvb_version = OCFS2_QINFO_LVB_VERSION;\n\tlvb->lvb_bgrace = cpu_to_be32(info->dqi_bgrace);\n\tlvb->lvb_igrace = cpu_to_be32(info->dqi_igrace);\n\tlvb->lvb_syncms = cpu_to_be32(oinfo->dqi_syncms);\n\tlvb->lvb_blocks = cpu_to_be32(oinfo->dqi_gi.dqi_blocks);\n\tlvb->lvb_free_blk = cpu_to_be32(oinfo->dqi_gi.dqi_free_blk);\n\tlvb->lvb_free_entry = cpu_to_be32(oinfo->dqi_gi.dqi_free_entry);\n}\n\nvoid ocfs2_qinfo_unlock(struct ocfs2_mem_dqinfo *oinfo, int ex)\n{\n\tstruct ocfs2_lock_res *lockres = &oinfo->dqi_gqlock;\n\tstruct ocfs2_super *osb = OCFS2_SB(oinfo->dqi_gi.dqi_sb);\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\n\tif (!ocfs2_is_hard_readonly(osb) && !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(osb, lockres, level);\n}\n\nstatic int ocfs2_refresh_qinfo(struct ocfs2_mem_dqinfo *oinfo)\n{\n\tstruct mem_dqinfo *info = sb_dqinfo(oinfo->dqi_gi.dqi_sb,\n\t\t\t\t\t    oinfo->dqi_gi.dqi_type);\n\tstruct ocfs2_lock_res *lockres = &oinfo->dqi_gqlock;\n\tstruct ocfs2_qinfo_lvb *lvb = ocfs2_dlm_lvb(&lockres->l_lksb);\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_global_disk_dqinfo *gdinfo;\n\tint status = 0;\n\n\tif (ocfs2_dlm_lvb_valid(&lockres->l_lksb) &&\n\t    lvb->lvb_version == OCFS2_QINFO_LVB_VERSION) {\n\t\tinfo->dqi_bgrace = be32_to_cpu(lvb->lvb_bgrace);\n\t\tinfo->dqi_igrace = be32_to_cpu(lvb->lvb_igrace);\n\t\toinfo->dqi_syncms = be32_to_cpu(lvb->lvb_syncms);\n\t\toinfo->dqi_gi.dqi_blocks = be32_to_cpu(lvb->lvb_blocks);\n\t\toinfo->dqi_gi.dqi_free_blk = be32_to_cpu(lvb->lvb_free_blk);\n\t\toinfo->dqi_gi.dqi_free_entry =\n\t\t\t\t\tbe32_to_cpu(lvb->lvb_free_entry);\n\t} else {\n\t\tstatus = ocfs2_read_quota_phys_block(oinfo->dqi_gqinode,\n\t\t\t\t\t\t     oinfo->dqi_giblk, &bh);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tgdinfo = (struct ocfs2_global_disk_dqinfo *)\n\t\t\t\t\t(bh->b_data + OCFS2_GLOBAL_INFO_OFF);\n\t\tinfo->dqi_bgrace = le32_to_cpu(gdinfo->dqi_bgrace);\n\t\tinfo->dqi_igrace = le32_to_cpu(gdinfo->dqi_igrace);\n\t\toinfo->dqi_syncms = le32_to_cpu(gdinfo->dqi_syncms);\n\t\toinfo->dqi_gi.dqi_blocks = le32_to_cpu(gdinfo->dqi_blocks);\n\t\toinfo->dqi_gi.dqi_free_blk = le32_to_cpu(gdinfo->dqi_free_blk);\n\t\toinfo->dqi_gi.dqi_free_entry =\n\t\t\t\t\tle32_to_cpu(gdinfo->dqi_free_entry);\n\t\tbrelse(bh);\n\t\tocfs2_track_lock_refresh(lockres);\n\t}\n\nbail:\n\treturn status;\n}\n\n \nint ocfs2_qinfo_lock(struct ocfs2_mem_dqinfo *oinfo, int ex)\n{\n\tstruct ocfs2_lock_res *lockres = &oinfo->dqi_gqlock;\n\tstruct ocfs2_super *osb = OCFS2_SB(oinfo->dqi_gi.dqi_sb);\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tint status = 0;\n\n\t \n\tif (ocfs2_is_hard_readonly(osb)) {\n\t\tif (ex)\n\t\t\tstatus = -EROFS;\n\t\tgoto bail;\n\t}\n\tif (ocfs2_mount_local(osb))\n\t\tgoto bail;\n\n\tstatus = ocfs2_cluster_lock(osb, lockres, level, 0, 0);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tif (!ocfs2_should_refresh_lock_res(lockres))\n\t\tgoto bail;\n\t \n\tstatus = ocfs2_refresh_qinfo(oinfo);\n\tif (status)\n\t\tocfs2_qinfo_unlock(oinfo, ex);\n\tocfs2_complete_lock_res_refresh(lockres, status);\nbail:\n\treturn status;\n}\n\nint ocfs2_refcount_lock(struct ocfs2_refcount_tree *ref_tree, int ex)\n{\n\tint status;\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &ref_tree->rf_lockres;\n\tstruct ocfs2_super *osb = lockres->l_priv;\n\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn -EROFS;\n\n\tif (ocfs2_mount_local(osb))\n\t\treturn 0;\n\n\tstatus = ocfs2_cluster_lock(osb, lockres, level, 0, 0);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\treturn status;\n}\n\nvoid ocfs2_refcount_unlock(struct ocfs2_refcount_tree *ref_tree, int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &ref_tree->rf_lockres;\n\tstruct ocfs2_super *osb = lockres->l_priv;\n\n\tif (!ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(osb, lockres, level);\n}\n\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres)\n{\n\tint status;\n\tstruct ocfs2_unblock_ctl ctl = {0, 0,};\n\tunsigned long flags;\n\n\t \n\n\tBUG_ON(!lockres);\n\tBUG_ON(!lockres->l_ops);\n\n\tmlog(ML_BASTS, \"lockres %s blocked\\n\", lockres->l_name);\n\n\t \n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tif (lockres->l_flags & OCFS2_LOCK_FREEING)\n\t\tgoto unqueue;\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\tstatus = ocfs2_unblock_lock(osb, lockres, &ctl);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\nunqueue:\n\tif (lockres->l_flags & OCFS2_LOCK_FREEING || !ctl.requeue) {\n\t\tlockres_clear_flags(lockres, OCFS2_LOCK_QUEUED);\n\t} else\n\t\tocfs2_schedule_blocked_lock(osb, lockres);\n\n\tmlog(ML_BASTS, \"lockres %s, requeue = %s.\\n\", lockres->l_name,\n\t     ctl.requeue ? \"yes\" : \"no\");\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\tif (ctl.unblock_action != UNBLOCK_CONTINUE\n\t    && lockres->l_ops->post_unlock)\n\t\tlockres->l_ops->post_unlock(osb, lockres);\n}\n\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres)\n{\n\tunsigned long flags;\n\n\tassert_spin_locked(&lockres->l_lock);\n\n\tif (lockres->l_flags & OCFS2_LOCK_FREEING) {\n\t\t \n\t\tmlog(ML_BASTS, \"lockres %s won't be scheduled: flags 0x%lx\\n\",\n\t\t     lockres->l_name, lockres->l_flags);\n\t\treturn;\n\t}\n\n\tlockres_or_flags(lockres, OCFS2_LOCK_QUEUED);\n\n\tspin_lock_irqsave(&osb->dc_task_lock, flags);\n\tif (list_empty(&lockres->l_blocked_list)) {\n\t\tlist_add_tail(&lockres->l_blocked_list,\n\t\t\t      &osb->blocked_lock_list);\n\t\tosb->blocked_lock_count++;\n\t}\n\tspin_unlock_irqrestore(&osb->dc_task_lock, flags);\n}\n\nstatic void ocfs2_downconvert_thread_do_work(struct ocfs2_super *osb)\n{\n\tunsigned long processed;\n\tunsigned long flags;\n\tstruct ocfs2_lock_res *lockres;\n\n\tspin_lock_irqsave(&osb->dc_task_lock, flags);\n\t \n\tosb->dc_work_sequence = osb->dc_wake_sequence;\n\n\tprocessed = osb->blocked_lock_count;\n\t \n\twhile (processed && !list_empty(&osb->blocked_lock_list)) {\n\t\tlockres = list_entry(osb->blocked_lock_list.next,\n\t\t\t\t     struct ocfs2_lock_res, l_blocked_list);\n\t\tlist_del_init(&lockres->l_blocked_list);\n\t\tosb->blocked_lock_count--;\n\t\tspin_unlock_irqrestore(&osb->dc_task_lock, flags);\n\n\t\tBUG_ON(!processed);\n\t\tprocessed--;\n\n\t\tocfs2_process_blocked_lock(osb, lockres);\n\n\t\tspin_lock_irqsave(&osb->dc_task_lock, flags);\n\t}\n\tspin_unlock_irqrestore(&osb->dc_task_lock, flags);\n}\n\nstatic int ocfs2_downconvert_thread_lists_empty(struct ocfs2_super *osb)\n{\n\tint empty = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&osb->dc_task_lock, flags);\n\tif (list_empty(&osb->blocked_lock_list))\n\t\tempty = 1;\n\n\tspin_unlock_irqrestore(&osb->dc_task_lock, flags);\n\treturn empty;\n}\n\nstatic int ocfs2_downconvert_thread_should_wake(struct ocfs2_super *osb)\n{\n\tint should_wake = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&osb->dc_task_lock, flags);\n\tif (osb->dc_work_sequence != osb->dc_wake_sequence)\n\t\tshould_wake = 1;\n\tspin_unlock_irqrestore(&osb->dc_task_lock, flags);\n\n\treturn should_wake;\n}\n\nstatic int ocfs2_downconvert_thread(void *arg)\n{\n\tstruct ocfs2_super *osb = arg;\n\n\t \n\twhile (!(kthread_should_stop() &&\n\t\tocfs2_downconvert_thread_lists_empty(osb))) {\n\n\t\twait_event_interruptible(osb->dc_event,\n\t\t\t\t\t ocfs2_downconvert_thread_should_wake(osb) ||\n\t\t\t\t\t kthread_should_stop());\n\n\t\tmlog(0, \"downconvert_thread: awoken\\n\");\n\n\t\tocfs2_downconvert_thread_do_work(osb);\n\t}\n\n\tosb->dc_task = NULL;\n\treturn 0;\n}\n\nvoid ocfs2_wake_downconvert_thread(struct ocfs2_super *osb)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&osb->dc_task_lock, flags);\n\t \n\tosb->dc_wake_sequence++;\n\tspin_unlock_irqrestore(&osb->dc_task_lock, flags);\n\twake_up(&osb->dc_event);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}