{
  "module_name": "xattr.c",
  "hash_id": "4f1900dd64db7102af086bb983c40fb4a149fbd488ee923a776f5b1bfeb01339",
  "original_prompt": "Ingested from linux-6.6.14/fs/ocfs2/xattr.c",
  "human_readable_source": "\n \n\n#include <linux/capability.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/uio.h>\n#include <linux/sched.h>\n#include <linux/splice.h>\n#include <linux/mount.h>\n#include <linux/writeback.h>\n#include <linux/falloc.h>\n#include <linux/sort.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/security.h>\n\n#include <cluster/masklog.h>\n\n#include \"ocfs2.h\"\n#include \"alloc.h\"\n#include \"blockcheck.h\"\n#include \"dlmglue.h\"\n#include \"file.h\"\n#include \"symlink.h\"\n#include \"sysfile.h\"\n#include \"inode.h\"\n#include \"journal.h\"\n#include \"ocfs2_fs.h\"\n#include \"suballoc.h\"\n#include \"uptodate.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"xattr.h\"\n#include \"refcounttree.h\"\n#include \"acl.h\"\n#include \"ocfs2_trace.h\"\n\nstruct ocfs2_xattr_def_value_root {\n\tstruct ocfs2_xattr_value_root\txv;\n\tstruct ocfs2_extent_rec\t\ter;\n};\n\nstruct ocfs2_xattr_bucket {\n\t \n\tstruct inode *bu_inode;\n\n\t \n\tstruct buffer_head *bu_bhs[OCFS2_XATTR_MAX_BLOCKS_PER_BUCKET];\n\n\t \n\tint bu_blocks;\n};\n\nstruct ocfs2_xattr_set_ctxt {\n\thandle_t *handle;\n\tstruct ocfs2_alloc_context *meta_ac;\n\tstruct ocfs2_alloc_context *data_ac;\n\tstruct ocfs2_cached_dealloc_ctxt dealloc;\n\tint set_abort;\n};\n\n#define OCFS2_XATTR_ROOT_SIZE\t(sizeof(struct ocfs2_xattr_def_value_root))\n#define OCFS2_XATTR_INLINE_SIZE\t80\n#define OCFS2_XATTR_HEADER_GAP\t4\n#define OCFS2_XATTR_FREE_IN_IBODY\t(OCFS2_MIN_XATTR_INLINE_SIZE \\\n\t\t\t\t\t - sizeof(struct ocfs2_xattr_header) \\\n\t\t\t\t\t - OCFS2_XATTR_HEADER_GAP)\n#define OCFS2_XATTR_FREE_IN_BLOCK(ptr)\t((ptr)->i_sb->s_blocksize \\\n\t\t\t\t\t - sizeof(struct ocfs2_xattr_block) \\\n\t\t\t\t\t - sizeof(struct ocfs2_xattr_header) \\\n\t\t\t\t\t - OCFS2_XATTR_HEADER_GAP)\n\nstatic struct ocfs2_xattr_def_value_root def_xv = {\n\t.xv.xr_list.l_count = cpu_to_le16(1),\n};\n\nconst struct xattr_handler *ocfs2_xattr_handlers[] = {\n\t&ocfs2_xattr_user_handler,\n\t&ocfs2_xattr_trusted_handler,\n\t&ocfs2_xattr_security_handler,\n\tNULL\n};\n\nstatic const struct xattr_handler *ocfs2_xattr_handler_map[OCFS2_XATTR_MAX] = {\n\t[OCFS2_XATTR_INDEX_USER]\t\t= &ocfs2_xattr_user_handler,\n\t[OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS]\t= &nop_posix_acl_access,\n\t[OCFS2_XATTR_INDEX_POSIX_ACL_DEFAULT]\t= &nop_posix_acl_default,\n\t[OCFS2_XATTR_INDEX_TRUSTED]\t\t= &ocfs2_xattr_trusted_handler,\n\t[OCFS2_XATTR_INDEX_SECURITY]\t\t= &ocfs2_xattr_security_handler,\n};\n\nstruct ocfs2_xattr_info {\n\tint\t\txi_name_index;\n\tconst char\t*xi_name;\n\tint\t\txi_name_len;\n\tconst void\t*xi_value;\n\tsize_t\t\txi_value_len;\n};\n\nstruct ocfs2_xattr_search {\n\tstruct buffer_head *inode_bh;\n\t \n\tstruct buffer_head *xattr_bh;\n\tstruct ocfs2_xattr_header *header;\n\tstruct ocfs2_xattr_bucket *bucket;\n\tvoid *base;\n\tvoid *end;\n\tstruct ocfs2_xattr_entry *here;\n\tint not_found;\n};\n\n \nstruct ocfs2_xa_loc;\nstruct ocfs2_xa_loc_operations {\n\t \n\tint (*xlo_journal_access)(handle_t *handle, struct ocfs2_xa_loc *loc,\n\t\t\t\t  int type);\n\tvoid (*xlo_journal_dirty)(handle_t *handle, struct ocfs2_xa_loc *loc);\n\n\t \n\tvoid *(*xlo_offset_pointer)(struct ocfs2_xa_loc *loc, int offset);\n\n\t \n\tint (*xlo_can_reuse)(struct ocfs2_xa_loc *loc,\n\t\t\t     struct ocfs2_xattr_info *xi);\n\n\t \n\tint (*xlo_check_space)(struct ocfs2_xa_loc *loc,\n\t\t\t       struct ocfs2_xattr_info *xi);\n\n\t \n\tint (*xlo_get_free_start)(struct ocfs2_xa_loc *loc);\n\n\t \n\tvoid (*xlo_wipe_namevalue)(struct ocfs2_xa_loc *loc);\n\n\t \n\tvoid (*xlo_add_entry)(struct ocfs2_xa_loc *loc, u32 name_hash);\n\n\t \n\tvoid (*xlo_add_namevalue)(struct ocfs2_xa_loc *loc, int size);\n\n\t \n\tvoid (*xlo_fill_value_buf)(struct ocfs2_xa_loc *loc,\n\t\t\t\t   struct ocfs2_xattr_value_buf *vb);\n};\n\n \nstruct ocfs2_xa_loc {\n\t \n\tstruct inode *xl_inode;\n\n\t \n\tstruct ocfs2_xattr_header *xl_header;\n\n\t \n\tint xl_size;\n\n\t \n\tstruct ocfs2_xattr_entry *xl_entry;\n\n\t \n\n\t \n\tvoid *xl_storage;\n\n\t \n\tconst struct ocfs2_xa_loc_operations *xl_ops;\n};\n\n \nstatic int namevalue_size(int name_len, uint64_t value_len)\n{\n\tif (value_len > OCFS2_XATTR_INLINE_SIZE)\n\t\treturn OCFS2_XATTR_SIZE(name_len) + OCFS2_XATTR_ROOT_SIZE;\n\telse\n\t\treturn OCFS2_XATTR_SIZE(name_len) + OCFS2_XATTR_SIZE(value_len);\n}\n\nstatic int namevalue_size_xi(struct ocfs2_xattr_info *xi)\n{\n\treturn namevalue_size(xi->xi_name_len, xi->xi_value_len);\n}\n\nstatic int namevalue_size_xe(struct ocfs2_xattr_entry *xe)\n{\n\tu64 value_len = le64_to_cpu(xe->xe_value_size);\n\n\tBUG_ON((value_len > OCFS2_XATTR_INLINE_SIZE) &&\n\t       ocfs2_xattr_is_local(xe));\n\treturn namevalue_size(xe->xe_name_len, value_len);\n}\n\n\nstatic int ocfs2_xattr_bucket_get_name_value(struct super_block *sb,\n\t\t\t\t\t     struct ocfs2_xattr_header *xh,\n\t\t\t\t\t     int index,\n\t\t\t\t\t     int *block_off,\n\t\t\t\t\t     int *new_offset);\n\nstatic int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);\nstatic int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);\n\nstatic int ocfs2_xattr_tree_list_index_block(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *blk_bh,\n\t\t\t\t\tchar *buffer,\n\t\t\t\t\tsize_t buffer_size);\n\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\n\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\n\ntypedef int (xattr_tree_rec_func)(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno, u32 cpos, u32 len, void *para);\nstatic int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);\nstatic int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);\nstatic int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);\n\nstatic int ocfs2_mv_xattr_buckets(struct inode *inode, handle_t *handle,\n\t\t\t\t  u64 src_blk, u64 last_blk, u64 to_blk,\n\t\t\t\t  unsigned int start_bucket,\n\t\t\t\t  u32 *first_hash);\nstatic int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);\nstatic int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);\n\nstatic inline u16 ocfs2_xattr_buckets_per_cluster(struct ocfs2_super *osb)\n{\n\treturn (1 << osb->s_clustersize_bits) / OCFS2_XATTR_BUCKET_SIZE;\n}\n\nstatic inline u16 ocfs2_blocks_per_xattr_bucket(struct super_block *sb)\n{\n\treturn OCFS2_XATTR_BUCKET_SIZE / (1 << sb->s_blocksize_bits);\n}\n\n#define bucket_blkno(_b) ((_b)->bu_bhs[0]->b_blocknr)\n#define bucket_block(_b, _n) ((_b)->bu_bhs[(_n)]->b_data)\n#define bucket_xh(_b) ((struct ocfs2_xattr_header *)bucket_block((_b), 0))\n\nstatic struct ocfs2_xattr_bucket *ocfs2_xattr_bucket_new(struct inode *inode)\n{\n\tstruct ocfs2_xattr_bucket *bucket;\n\tint blks = ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\n\tBUG_ON(blks > OCFS2_XATTR_MAX_BLOCKS_PER_BUCKET);\n\n\tbucket = kzalloc(sizeof(struct ocfs2_xattr_bucket), GFP_NOFS);\n\tif (bucket) {\n\t\tbucket->bu_inode = inode;\n\t\tbucket->bu_blocks = blks;\n\t}\n\n\treturn bucket;\n}\n\nstatic void ocfs2_xattr_bucket_relse(struct ocfs2_xattr_bucket *bucket)\n{\n\tint i;\n\n\tfor (i = 0; i < bucket->bu_blocks; i++) {\n\t\tbrelse(bucket->bu_bhs[i]);\n\t\tbucket->bu_bhs[i] = NULL;\n\t}\n}\n\nstatic void ocfs2_xattr_bucket_free(struct ocfs2_xattr_bucket *bucket)\n{\n\tif (bucket) {\n\t\tocfs2_xattr_bucket_relse(bucket);\n\t\tbucket->bu_inode = NULL;\n\t\tkfree(bucket);\n\t}\n}\n\n \nstatic int ocfs2_init_xattr_bucket(struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t   u64 xb_blkno, int new)\n{\n\tint i, rc = 0;\n\n\tfor (i = 0; i < bucket->bu_blocks; i++) {\n\t\tbucket->bu_bhs[i] = sb_getblk(bucket->bu_inode->i_sb,\n\t\t\t\t\t      xb_blkno + i);\n\t\tif (!bucket->bu_bhs[i]) {\n\t\t\trc = -ENOMEM;\n\t\t\tmlog_errno(rc);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!ocfs2_buffer_uptodate(INODE_CACHE(bucket->bu_inode),\n\t\t\t\t\t   bucket->bu_bhs[i])) {\n\t\t\tif (new)\n\t\t\t\tocfs2_set_new_buffer_uptodate(INODE_CACHE(bucket->bu_inode),\n\t\t\t\t\t\t\t      bucket->bu_bhs[i]);\n\t\t\telse {\n\t\t\t\tset_buffer_uptodate(bucket->bu_bhs[i]);\n\t\t\t\tocfs2_set_buffer_uptodate(INODE_CACHE(bucket->bu_inode),\n\t\t\t\t\t\t\t  bucket->bu_bhs[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (rc)\n\t\tocfs2_xattr_bucket_relse(bucket);\n\treturn rc;\n}\n\n \nstatic int ocfs2_read_xattr_bucket(struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t   u64 xb_blkno)\n{\n\tint rc;\n\n\trc = ocfs2_read_blocks(INODE_CACHE(bucket->bu_inode), xb_blkno,\n\t\t\t       bucket->bu_blocks, bucket->bu_bhs, 0,\n\t\t\t       NULL);\n\tif (!rc) {\n\t\tspin_lock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\t\trc = ocfs2_validate_meta_ecc_bhs(bucket->bu_inode->i_sb,\n\t\t\t\t\t\t bucket->bu_bhs,\n\t\t\t\t\t\t bucket->bu_blocks,\n\t\t\t\t\t\t &bucket_xh(bucket)->xh_check);\n\t\tspin_unlock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\t\tif (rc)\n\t\t\tmlog_errno(rc);\n\t}\n\n\tif (rc)\n\t\tocfs2_xattr_bucket_relse(bucket);\n\treturn rc;\n}\n\nstatic int ocfs2_xattr_bucket_journal_access(handle_t *handle,\n\t\t\t\t\t     struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t     int type)\n{\n\tint i, rc = 0;\n\n\tfor (i = 0; i < bucket->bu_blocks; i++) {\n\t\trc = ocfs2_journal_access(handle,\n\t\t\t\t\t  INODE_CACHE(bucket->bu_inode),\n\t\t\t\t\t  bucket->bu_bhs[i], type);\n\t\tif (rc) {\n\t\t\tmlog_errno(rc);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn rc;\n}\n\nstatic void ocfs2_xattr_bucket_journal_dirty(handle_t *handle,\n\t\t\t\t\t     struct ocfs2_xattr_bucket *bucket)\n{\n\tint i;\n\n\tspin_lock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\tocfs2_compute_meta_ecc_bhs(bucket->bu_inode->i_sb,\n\t\t\t\t   bucket->bu_bhs, bucket->bu_blocks,\n\t\t\t\t   &bucket_xh(bucket)->xh_check);\n\tspin_unlock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\n\tfor (i = 0; i < bucket->bu_blocks; i++)\n\t\tocfs2_journal_dirty(handle, bucket->bu_bhs[i]);\n}\n\nstatic void ocfs2_xattr_bucket_copy_data(struct ocfs2_xattr_bucket *dest,\n\t\t\t\t\t struct ocfs2_xattr_bucket *src)\n{\n\tint i;\n\tint blocksize = src->bu_inode->i_sb->s_blocksize;\n\n\tBUG_ON(dest->bu_blocks != src->bu_blocks);\n\tBUG_ON(dest->bu_inode != src->bu_inode);\n\n\tfor (i = 0; i < src->bu_blocks; i++) {\n\t\tmemcpy(bucket_block(dest, i), bucket_block(src, i),\n\t\t       blocksize);\n\t}\n}\n\nstatic int ocfs2_validate_xattr_block(struct super_block *sb,\n\t\t\t\t      struct buffer_head *bh)\n{\n\tint rc;\n\tstruct ocfs2_xattr_block *xb =\n\t\t(struct ocfs2_xattr_block *)bh->b_data;\n\n\ttrace_ocfs2_validate_xattr_block((unsigned long long)bh->b_blocknr);\n\n\tBUG_ON(!buffer_uptodate(bh));\n\n\t \n\trc = ocfs2_validate_meta_ecc(sb, bh->b_data, &xb->xb_check);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\n\tif (!OCFS2_IS_VALID_XATTR_BLOCK(xb)) {\n\t\treturn ocfs2_error(sb,\n\t\t\t\t   \"Extended attribute block #%llu has bad signature %.*s\\n\",\n\t\t\t\t   (unsigned long long)bh->b_blocknr, 7,\n\t\t\t\t   xb->xb_signature);\n\t}\n\n\tif (le64_to_cpu(xb->xb_blkno) != bh->b_blocknr) {\n\t\treturn ocfs2_error(sb,\n\t\t\t\t   \"Extended attribute block #%llu has an invalid xb_blkno of %llu\\n\",\n\t\t\t\t   (unsigned long long)bh->b_blocknr,\n\t\t\t\t   (unsigned long long)le64_to_cpu(xb->xb_blkno));\n\t}\n\n\tif (le32_to_cpu(xb->xb_fs_generation) != OCFS2_SB(sb)->fs_generation) {\n\t\treturn ocfs2_error(sb,\n\t\t\t\t   \"Extended attribute block #%llu has an invalid xb_fs_generation of #%u\\n\",\n\t\t\t\t   (unsigned long long)bh->b_blocknr,\n\t\t\t\t   le32_to_cpu(xb->xb_fs_generation));\n\t}\n\n\treturn 0;\n}\n\nstatic int ocfs2_read_xattr_block(struct inode *inode, u64 xb_blkno,\n\t\t\t\t  struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(INODE_CACHE(inode), xb_blkno, &tmp,\n\t\t\t      ocfs2_validate_xattr_block);\n\n\t \n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}\n\nstatic inline const char *ocfs2_xattr_prefix(int name_index)\n{\n\tconst struct xattr_handler *handler = NULL;\n\n\tif (name_index > 0 && name_index < OCFS2_XATTR_MAX)\n\t\thandler = ocfs2_xattr_handler_map[name_index];\n\treturn handler ? xattr_prefix(handler) : NULL;\n}\n\nstatic u32 ocfs2_xattr_name_hash(struct inode *inode,\n\t\t\t\t const char *name,\n\t\t\t\t int name_len)\n{\n\t \n\tu32 hash = OCFS2_SB(inode->i_sb)->uuid_hash;\n\tint i;\n\n\t \n\tfor (i = 0; i < name_len; i++) {\n\t\thash = (hash << OCFS2_HASH_SHIFT) ^\n\t\t       (hash >> (8*sizeof(hash) - OCFS2_HASH_SHIFT)) ^\n\t\t       *name++;\n\t}\n\n\treturn hash;\n}\n\nstatic int ocfs2_xattr_entry_real_size(int name_len, size_t value_len)\n{\n\treturn namevalue_size(name_len, value_len) +\n\t\tsizeof(struct ocfs2_xattr_entry);\n}\n\nstatic int ocfs2_xi_entry_usage(struct ocfs2_xattr_info *xi)\n{\n\treturn namevalue_size_xi(xi) +\n\t\tsizeof(struct ocfs2_xattr_entry);\n}\n\nstatic int ocfs2_xe_entry_usage(struct ocfs2_xattr_entry *xe)\n{\n\treturn namevalue_size_xe(xe) +\n\t\tsizeof(struct ocfs2_xattr_entry);\n}\n\nint ocfs2_calc_security_init(struct inode *dir,\n\t\t\t     struct ocfs2_security_xattr_info *si,\n\t\t\t     int *want_clusters,\n\t\t\t     int *xattr_credits,\n\t\t\t     struct ocfs2_alloc_context **xattr_ac)\n{\n\tint ret = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tint s_size = ocfs2_xattr_entry_real_size(strlen(si->name),\n\t\t\t\t\t\t si->value_len);\n\n\t \n\tif (dir->i_sb->s_blocksize == OCFS2_MIN_BLOCKSIZE ||\n\t    s_size > OCFS2_XATTR_FREE_IN_IBODY) {\n\t\tret = ocfs2_reserve_new_metadata_blocks(osb, 1, xattr_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*xattr_credits += OCFS2_XATTR_BLOCK_CREATE_CREDITS;\n\t}\n\n\t \n\tif (si->value_len > OCFS2_XATTR_INLINE_SIZE) {\n\t\tint new_clusters = ocfs2_clusters_for_bytes(dir->i_sb,\n\t\t\t\t\t\t\t    si->value_len);\n\n\t\t*xattr_credits += ocfs2_clusters_to_blocks(dir->i_sb,\n\t\t\t\t\t\t\t   new_clusters);\n\t\t*want_clusters += new_clusters;\n\t}\n\treturn ret;\n}\n\nint ocfs2_calc_xattr_init(struct inode *dir,\n\t\t\t  struct buffer_head *dir_bh,\n\t\t\t  umode_t mode,\n\t\t\t  struct ocfs2_security_xattr_info *si,\n\t\t\t  int *want_clusters,\n\t\t\t  int *xattr_credits,\n\t\t\t  int *want_meta)\n{\n\tint ret = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tint s_size = 0, a_size = 0, acl_len = 0, new_clusters;\n\n\tif (si->enable)\n\t\ts_size = ocfs2_xattr_entry_real_size(strlen(si->name),\n\t\t\t\t\t\t     si->value_len);\n\n\tif (osb->s_mount_opt & OCFS2_MOUNT_POSIX_ACL) {\n\t\tdown_read(&OCFS2_I(dir)->ip_xattr_sem);\n\t\tacl_len = ocfs2_xattr_get_nolock(dir, dir_bh,\n\t\t\t\t\tOCFS2_XATTR_INDEX_POSIX_ACL_DEFAULT,\n\t\t\t\t\t\"\", NULL, 0);\n\t\tup_read(&OCFS2_I(dir)->ip_xattr_sem);\n\t\tif (acl_len > 0) {\n\t\t\ta_size = ocfs2_xattr_entry_real_size(0, acl_len);\n\t\t\tif (S_ISDIR(mode))\n\t\t\t\ta_size <<= 1;\n\t\t} else if (acl_len != 0 && acl_len != -ENODATA) {\n\t\t\tret = acl_len;\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (!(s_size + a_size))\n\t\treturn ret;\n\n\t \n\tif (dir->i_sb->s_blocksize == OCFS2_MIN_BLOCKSIZE ||\n\t    (S_ISDIR(mode) && ocfs2_supports_inline_data(osb)) ||\n\t    (s_size + a_size) > OCFS2_XATTR_FREE_IN_IBODY) {\n\t\t*want_meta = *want_meta + 1;\n\t\t*xattr_credits += OCFS2_XATTR_BLOCK_CREATE_CREDITS;\n\t}\n\n\tif (dir->i_sb->s_blocksize == OCFS2_MIN_BLOCKSIZE &&\n\t    (s_size + a_size) > OCFS2_XATTR_FREE_IN_BLOCK(dir)) {\n\t\t*want_clusters += 1;\n\t\t*xattr_credits += ocfs2_blocks_per_xattr_bucket(dir->i_sb);\n\t}\n\n\t \n\tif (si->enable && si->value_len > OCFS2_XATTR_INLINE_SIZE) {\n\t\tnew_clusters = ocfs2_clusters_for_bytes(dir->i_sb,\n\t\t\t\t\t\t\tsi->value_len);\n\t\t*xattr_credits += ocfs2_clusters_to_blocks(dir->i_sb,\n\t\t\t\t\t\t\t   new_clusters);\n\t\t*want_clusters += new_clusters;\n\t}\n\tif (osb->s_mount_opt & OCFS2_MOUNT_POSIX_ACL &&\n\t    acl_len > OCFS2_XATTR_INLINE_SIZE) {\n\t\t \n\t\tnew_clusters = (S_ISDIR(mode) ? 2 : 1) *\n\t\t\t\tocfs2_clusters_for_bytes(dir->i_sb, acl_len);\n\t\t*xattr_credits += ocfs2_clusters_to_blocks(dir->i_sb,\n\t\t\t\t\t\t\t   new_clusters);\n\t\t*want_clusters += new_clusters;\n\t}\n\n\treturn ret;\n}\n\nstatic int ocfs2_xattr_extend_allocation(struct inode *inode,\n\t\t\t\t\t u32 clusters_to_add,\n\t\t\t\t\t struct ocfs2_xattr_value_buf *vb,\n\t\t\t\t\t struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint status = 0, credits;\n\thandle_t *handle = ctxt->handle;\n\tenum ocfs2_alloc_restarted why;\n\tu32 prev_clusters, logical_start = le32_to_cpu(vb->vb_xv->xr_clusters);\n\tstruct ocfs2_extent_tree et;\n\n\tocfs2_init_xattr_value_extent_tree(&et, INODE_CACHE(inode), vb);\n\n\twhile (clusters_to_add) {\n\t\ttrace_ocfs2_xattr_extend_allocation(clusters_to_add);\n\n\t\tstatus = vb->vb_access(handle, INODE_CACHE(inode), vb->vb_bh,\n\t\t\t\t       OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tbreak;\n\t\t}\n\n\t\tprev_clusters = le32_to_cpu(vb->vb_xv->xr_clusters);\n\t\tstatus = ocfs2_add_clusters_in_btree(handle,\n\t\t\t\t\t\t     &et,\n\t\t\t\t\t\t     &logical_start,\n\t\t\t\t\t\t     clusters_to_add,\n\t\t\t\t\t\t     0,\n\t\t\t\t\t\t     ctxt->data_ac,\n\t\t\t\t\t\t     ctxt->meta_ac,\n\t\t\t\t\t\t     &why);\n\t\tif ((status < 0) && (status != -EAGAIN)) {\n\t\t\tif (status != -ENOSPC)\n\t\t\t\tmlog_errno(status);\n\t\t\tbreak;\n\t\t}\n\n\t\tocfs2_journal_dirty(handle, vb->vb_bh);\n\n\t\tclusters_to_add -= le32_to_cpu(vb->vb_xv->xr_clusters) -\n\t\t\t\t\t prev_clusters;\n\n\t\tif (why != RESTART_NONE && clusters_to_add) {\n\t\t\t \n\t\t\tBUG_ON(why == RESTART_META);\n\n\t\t\tcredits = ocfs2_calc_extend_credits(inode->i_sb,\n\t\t\t\t\t\t\t    &vb->vb_xv->xr_list);\n\t\t\tstatus = ocfs2_extend_trans(handle, credits);\n\t\t\tif (status < 0) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn status;\n}\n\nstatic int __ocfs2_remove_xattr_range(struct inode *inode,\n\t\t\t\t      struct ocfs2_xattr_value_buf *vb,\n\t\t\t\t      u32 cpos, u32 phys_cpos, u32 len,\n\t\t\t\t      unsigned int ext_flags,\n\t\t\t\t      struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret;\n\tu64 phys_blkno = ocfs2_clusters_to_blocks(inode->i_sb, phys_cpos);\n\thandle_t *handle = ctxt->handle;\n\tstruct ocfs2_extent_tree et;\n\n\tocfs2_init_xattr_value_extent_tree(&et, INODE_CACHE(inode), vb);\n\n\tret = vb->vb_access(handle, INODE_CACHE(inode), vb->vb_bh,\n\t\t\t    OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_remove_extent(handle, &et, cpos, len, ctxt->meta_ac,\n\t\t\t\t  &ctxt->dealloc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tle32_add_cpu(&vb->vb_xv->xr_clusters, -len);\n\tocfs2_journal_dirty(handle, vb->vb_bh);\n\n\tif (ext_flags & OCFS2_EXT_REFCOUNTED)\n\t\tret = ocfs2_decrease_refcount(inode, handle,\n\t\t\t\t\tocfs2_blocks_to_clusters(inode->i_sb,\n\t\t\t\t\t\t\t\t phys_blkno),\n\t\t\t\t\tlen, ctxt->meta_ac, &ctxt->dealloc, 1);\n\telse\n\t\tret = ocfs2_cache_cluster_dealloc(&ctxt->dealloc,\n\t\t\t\t\t\t  phys_blkno, len);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\treturn ret;\n}\n\nstatic int ocfs2_xattr_shrink_size(struct inode *inode,\n\t\t\t\t   u32 old_clusters,\n\t\t\t\t   u32 new_clusters,\n\t\t\t\t   struct ocfs2_xattr_value_buf *vb,\n\t\t\t\t   struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret = 0;\n\tunsigned int ext_flags;\n\tu32 trunc_len, cpos, phys_cpos, alloc_size;\n\tu64 block;\n\n\tif (old_clusters <= new_clusters)\n\t\treturn 0;\n\n\tcpos = new_clusters;\n\ttrunc_len = old_clusters - new_clusters;\n\twhile (trunc_len) {\n\t\tret = ocfs2_xattr_get_clusters(inode, cpos, &phys_cpos,\n\t\t\t\t\t       &alloc_size,\n\t\t\t\t\t       &vb->vb_xv->xr_list, &ext_flags);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (alloc_size > trunc_len)\n\t\t\talloc_size = trunc_len;\n\n\t\tret = __ocfs2_remove_xattr_range(inode, vb, cpos,\n\t\t\t\t\t\t phys_cpos, alloc_size,\n\t\t\t\t\t\t ext_flags, ctxt);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tblock = ocfs2_clusters_to_blocks(inode->i_sb, phys_cpos);\n\t\tocfs2_remove_xattr_clusters_from_cache(INODE_CACHE(inode),\n\t\t\t\t\t\t       block, alloc_size);\n\t\tcpos += alloc_size;\n\t\ttrunc_len -= alloc_size;\n\t}\n\nout:\n\treturn ret;\n}\n\nstatic int ocfs2_xattr_value_truncate(struct inode *inode,\n\t\t\t\t      struct ocfs2_xattr_value_buf *vb,\n\t\t\t\t      int len,\n\t\t\t\t      struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret;\n\tu32 new_clusters = ocfs2_clusters_for_bytes(inode->i_sb, len);\n\tu32 old_clusters = le32_to_cpu(vb->vb_xv->xr_clusters);\n\n\tif (new_clusters == old_clusters)\n\t\treturn 0;\n\n\tif (new_clusters > old_clusters)\n\t\tret = ocfs2_xattr_extend_allocation(inode,\n\t\t\t\t\t\t    new_clusters - old_clusters,\n\t\t\t\t\t\t    vb, ctxt);\n\telse\n\t\tret = ocfs2_xattr_shrink_size(inode,\n\t\t\t\t\t      old_clusters, new_clusters,\n\t\t\t\t\t      vb, ctxt);\n\n\treturn ret;\n}\n\nstatic int ocfs2_xattr_list_entry(struct super_block *sb,\n\t\t\t\t  char *buffer, size_t size,\n\t\t\t\t  size_t *result, int type,\n\t\t\t\t  const char *name, int name_len)\n{\n\tchar *p = buffer + *result;\n\tconst char *prefix;\n\tint prefix_len;\n\tint total_len;\n\n\tswitch(type) {\n\tcase OCFS2_XATTR_INDEX_USER:\n\t\tif (OCFS2_SB(sb)->s_mount_opt & OCFS2_MOUNT_NOUSERXATTR)\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS:\n\tcase OCFS2_XATTR_INDEX_POSIX_ACL_DEFAULT:\n\t\tif (!(sb->s_flags & SB_POSIXACL))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase OCFS2_XATTR_INDEX_TRUSTED:\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn 0;\n\t\tbreak;\n\t}\n\n\tprefix = ocfs2_xattr_prefix(type);\n\tif (!prefix)\n\t\treturn 0;\n\tprefix_len = strlen(prefix);\n\ttotal_len = prefix_len + name_len + 1;\n\t*result += total_len;\n\n\t \n\tif (!size)\n\t\treturn 0;\n\n\tif (*result > size)\n\t\treturn -ERANGE;\n\n\tmemcpy(p, prefix, prefix_len);\n\tmemcpy(p + prefix_len, name, name_len);\n\tp[prefix_len + name_len] = '\\0';\n\n\treturn 0;\n}\n\nstatic int ocfs2_xattr_list_entries(struct inode *inode,\n\t\t\t\t    struct ocfs2_xattr_header *header,\n\t\t\t\t    char *buffer, size_t buffer_size)\n{\n\tsize_t result = 0;\n\tint i, type, ret;\n\tconst char *name;\n\n\tfor (i = 0 ; i < le16_to_cpu(header->xh_count); i++) {\n\t\tstruct ocfs2_xattr_entry *entry = &header->xh_entries[i];\n\t\ttype = ocfs2_xattr_get_type(entry);\n\t\tname = (const char *)header +\n\t\t\tle16_to_cpu(entry->xe_name_offset);\n\n\t\tret = ocfs2_xattr_list_entry(inode->i_sb,\n\t\t\t\t\t     buffer, buffer_size,\n\t\t\t\t\t     &result, type, name,\n\t\t\t\t\t     entry->xe_name_len);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn result;\n}\n\nint ocfs2_has_inline_xattr_value_outside(struct inode *inode,\n\t\t\t\t\t struct ocfs2_dinode *di)\n{\n\tstruct ocfs2_xattr_header *xh;\n\tint i;\n\n\txh = (struct ocfs2_xattr_header *)\n\t\t ((void *)di + inode->i_sb->s_blocksize -\n\t\t le16_to_cpu(di->i_xattr_inline_size));\n\n\tfor (i = 0; i < le16_to_cpu(xh->xh_count); i++)\n\t\tif (!ocfs2_xattr_is_local(&xh->xh_entries[i]))\n\t\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int ocfs2_xattr_ibody_list(struct inode *inode,\n\t\t\t\t  struct ocfs2_dinode *di,\n\t\t\t\t  char *buffer,\n\t\t\t\t  size_t buffer_size)\n{\n\tstruct ocfs2_xattr_header *header = NULL;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tint ret = 0;\n\n\tif (!(oi->ip_dyn_features & OCFS2_INLINE_XATTR_FL))\n\t\treturn ret;\n\n\theader = (struct ocfs2_xattr_header *)\n\t\t ((void *)di + inode->i_sb->s_blocksize -\n\t\t le16_to_cpu(di->i_xattr_inline_size));\n\n\tret = ocfs2_xattr_list_entries(inode, header, buffer, buffer_size);\n\n\treturn ret;\n}\n\nstatic int ocfs2_xattr_block_list(struct inode *inode,\n\t\t\t\t  struct ocfs2_dinode *di,\n\t\t\t\t  char *buffer,\n\t\t\t\t  size_t buffer_size)\n{\n\tstruct buffer_head *blk_bh = NULL;\n\tstruct ocfs2_xattr_block *xb;\n\tint ret = 0;\n\n\tif (!di->i_xattr_loc)\n\t\treturn ret;\n\n\tret = ocfs2_read_xattr_block(inode, le64_to_cpu(di->i_xattr_loc),\n\t\t\t\t     &blk_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\txb = (struct ocfs2_xattr_block *)blk_bh->b_data;\n\tif (!(le16_to_cpu(xb->xb_flags) & OCFS2_XATTR_INDEXED)) {\n\t\tstruct ocfs2_xattr_header *header = &xb->xb_attrs.xb_header;\n\t\tret = ocfs2_xattr_list_entries(inode, header,\n\t\t\t\t\t       buffer, buffer_size);\n\t} else\n\t\tret = ocfs2_xattr_tree_list_index_block(inode, blk_bh,\n\t\t\t\t\t\t   buffer, buffer_size);\n\n\tbrelse(blk_bh);\n\n\treturn ret;\n}\n\nssize_t ocfs2_listxattr(struct dentry *dentry,\n\t\t\tchar *buffer,\n\t\t\tsize_t size)\n{\n\tint ret = 0, i_ret = 0, b_ret = 0;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dinode *di = NULL;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(d_inode(dentry));\n\n\tif (!ocfs2_supports_xattr(OCFS2_SB(dentry->d_sb)))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!(oi->ip_dyn_features & OCFS2_HAS_XATTR_FL))\n\t\treturn ret;\n\n\tret = ocfs2_inode_lock(d_inode(dentry), &di_bh, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tdown_read(&oi->ip_xattr_sem);\n\ti_ret = ocfs2_xattr_ibody_list(d_inode(dentry), di, buffer, size);\n\tif (i_ret < 0)\n\t\tb_ret = 0;\n\telse {\n\t\tif (buffer) {\n\t\t\tbuffer += i_ret;\n\t\t\tsize -= i_ret;\n\t\t}\n\t\tb_ret = ocfs2_xattr_block_list(d_inode(dentry), di,\n\t\t\t\t\t       buffer, size);\n\t\tif (b_ret < 0)\n\t\t\ti_ret = 0;\n\t}\n\tup_read(&oi->ip_xattr_sem);\n\tocfs2_inode_unlock(d_inode(dentry), 0);\n\n\tbrelse(di_bh);\n\n\treturn i_ret + b_ret;\n}\n\nstatic int ocfs2_xattr_find_entry(int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs)\n{\n\tstruct ocfs2_xattr_entry *entry;\n\tsize_t name_len;\n\tint i, cmp = 1;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\n\tname_len = strlen(name);\n\tentry = xs->here;\n\tfor (i = 0; i < le16_to_cpu(xs->header->xh_count); i++) {\n\t\tcmp = name_index - ocfs2_xattr_get_type(entry);\n\t\tif (!cmp)\n\t\t\tcmp = name_len - entry->xe_name_len;\n\t\tif (!cmp)\n\t\t\tcmp = memcmp(name, (xs->base +\n\t\t\t\t     le16_to_cpu(entry->xe_name_offset)),\n\t\t\t\t     name_len);\n\t\tif (cmp == 0)\n\t\t\tbreak;\n\t\tentry += 1;\n\t}\n\txs->here = entry;\n\n\treturn cmp ? -ENODATA : 0;\n}\n\nstatic int ocfs2_xattr_get_value_outside(struct inode *inode,\n\t\t\t\t\t struct ocfs2_xattr_value_root *xv,\n\t\t\t\t\t void *buffer,\n\t\t\t\t\t size_t len)\n{\n\tu32 cpos, p_cluster, num_clusters, bpc, clusters;\n\tu64 blkno;\n\tint i, ret = 0;\n\tsize_t cplen, blocksize;\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_extent_list *el;\n\n\tel = &xv->xr_list;\n\tclusters = le32_to_cpu(xv->xr_clusters);\n\tbpc = ocfs2_clusters_to_blocks(inode->i_sb, 1);\n\tblocksize = inode->i_sb->s_blocksize;\n\n\tcpos = 0;\n\twhile (cpos < clusters) {\n\t\tret = ocfs2_xattr_get_clusters(inode, cpos, &p_cluster,\n\t\t\t\t\t       &num_clusters, el, NULL);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tblkno = ocfs2_clusters_to_blocks(inode->i_sb, p_cluster);\n\t\t \n\t\tfor (i = 0; i < num_clusters * bpc; i++, blkno++) {\n\t\t\tret = ocfs2_read_block(INODE_CACHE(inode), blkno,\n\t\t\t\t\t       &bh, NULL);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tcplen = len >= blocksize ? blocksize : len;\n\t\t\tmemcpy(buffer, bh->b_data, cplen);\n\t\t\tlen -= cplen;\n\t\t\tbuffer += cplen;\n\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t\tif (len == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tcpos += num_clusters;\n\t}\nout:\n\treturn ret;\n}\n\nstatic int ocfs2_xattr_ibody_get(struct inode *inode,\n\t\t\t\t int name_index,\n\t\t\t\t const char *name,\n\t\t\t\t void *buffer,\n\t\t\t\t size_t buffer_size,\n\t\t\t\t struct ocfs2_xattr_search *xs)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)xs->inode_bh->b_data;\n\tstruct ocfs2_xattr_value_root *xv;\n\tsize_t size;\n\tint ret = 0;\n\n\tif (!(oi->ip_dyn_features & OCFS2_INLINE_XATTR_FL))\n\t\treturn -ENODATA;\n\n\txs->end = (void *)di + inode->i_sb->s_blocksize;\n\txs->header = (struct ocfs2_xattr_header *)\n\t\t\t(xs->end - le16_to_cpu(di->i_xattr_inline_size));\n\txs->base = (void *)xs->header;\n\txs->here = xs->header->xh_entries;\n\n\tret = ocfs2_xattr_find_entry(name_index, name, xs);\n\tif (ret)\n\t\treturn ret;\n\tsize = le64_to_cpu(xs->here->xe_value_size);\n\tif (buffer) {\n\t\tif (size > buffer_size)\n\t\t\treturn -ERANGE;\n\t\tif (ocfs2_xattr_is_local(xs->here)) {\n\t\t\tmemcpy(buffer, (void *)xs->base +\n\t\t\t       le16_to_cpu(xs->here->xe_name_offset) +\n\t\t\t       OCFS2_XATTR_SIZE(xs->here->xe_name_len), size);\n\t\t} else {\n\t\t\txv = (struct ocfs2_xattr_value_root *)\n\t\t\t\t(xs->base + le16_to_cpu(\n\t\t\t\t xs->here->xe_name_offset) +\n\t\t\t\tOCFS2_XATTR_SIZE(xs->here->xe_name_len));\n\t\t\tret = ocfs2_xattr_get_value_outside(inode, xv,\n\t\t\t\t\t\t\t    buffer, size);\n\t\t\tif (ret < 0) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn size;\n}\n\nstatic int ocfs2_xattr_block_get(struct inode *inode,\n\t\t\t\t int name_index,\n\t\t\t\t const char *name,\n\t\t\t\t void *buffer,\n\t\t\t\t size_t buffer_size,\n\t\t\t\t struct ocfs2_xattr_search *xs)\n{\n\tstruct ocfs2_xattr_block *xb;\n\tstruct ocfs2_xattr_value_root *xv;\n\tsize_t size;\n\tint ret = -ENODATA, name_offset, name_len, i;\n\tint block_off;\n\n\txs->bucket = ocfs2_xattr_bucket_new(inode);\n\tif (!xs->bucket) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto cleanup;\n\t}\n\n\tret = ocfs2_xattr_block_find(inode, name_index, name, xs);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto cleanup;\n\t}\n\n\tif (xs->not_found) {\n\t\tret = -ENODATA;\n\t\tgoto cleanup;\n\t}\n\n\txb = (struct ocfs2_xattr_block *)xs->xattr_bh->b_data;\n\tsize = le64_to_cpu(xs->here->xe_value_size);\n\tif (buffer) {\n\t\tret = -ERANGE;\n\t\tif (size > buffer_size)\n\t\t\tgoto cleanup;\n\n\t\tname_offset = le16_to_cpu(xs->here->xe_name_offset);\n\t\tname_len = OCFS2_XATTR_SIZE(xs->here->xe_name_len);\n\t\ti = xs->here - xs->header->xh_entries;\n\n\t\tif (le16_to_cpu(xb->xb_flags) & OCFS2_XATTR_INDEXED) {\n\t\t\tret = ocfs2_xattr_bucket_get_name_value(inode->i_sb,\n\t\t\t\t\t\t\t\tbucket_xh(xs->bucket),\n\t\t\t\t\t\t\t\ti,\n\t\t\t\t\t\t\t\t&block_off,\n\t\t\t\t\t\t\t\t&name_offset);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\txs->base = bucket_block(xs->bucket, block_off);\n\t\t}\n\t\tif (ocfs2_xattr_is_local(xs->here)) {\n\t\t\tmemcpy(buffer, (void *)xs->base +\n\t\t\t       name_offset + name_len, size);\n\t\t} else {\n\t\t\txv = (struct ocfs2_xattr_value_root *)\n\t\t\t\t(xs->base + name_offset + name_len);\n\t\t\tret = ocfs2_xattr_get_value_outside(inode, xv,\n\t\t\t\t\t\t\t    buffer, size);\n\t\t\tif (ret < 0) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\t}\n\tret = size;\ncleanup:\n\tocfs2_xattr_bucket_free(xs->bucket);\n\n\tbrelse(xs->xattr_bh);\n\txs->xattr_bh = NULL;\n\treturn ret;\n}\n\nint ocfs2_xattr_get_nolock(struct inode *inode,\n\t\t\t   struct buffer_head *di_bh,\n\t\t\t   int name_index,\n\t\t\t   const char *name,\n\t\t\t   void *buffer,\n\t\t\t   size_t buffer_size)\n{\n\tint ret;\n\tstruct ocfs2_dinode *di = NULL;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_xattr_search xis = {\n\t\t.not_found = -ENODATA,\n\t};\n\tstruct ocfs2_xattr_search xbs = {\n\t\t.not_found = -ENODATA,\n\t};\n\n\tif (!ocfs2_supports_xattr(OCFS2_SB(inode->i_sb)))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!(oi->ip_dyn_features & OCFS2_HAS_XATTR_FL))\n\t\treturn -ENODATA;\n\n\txis.inode_bh = xbs.inode_bh = di_bh;\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tret = ocfs2_xattr_ibody_get(inode, name_index, name, buffer,\n\t\t\t\t    buffer_size, &xis);\n\tif (ret == -ENODATA && di->i_xattr_loc)\n\t\tret = ocfs2_xattr_block_get(inode, name_index, name, buffer,\n\t\t\t\t\t    buffer_size, &xbs);\n\n\treturn ret;\n}\n\n \nstatic int ocfs2_xattr_get(struct inode *inode,\n\t\t\t   int name_index,\n\t\t\t   const char *name,\n\t\t\t   void *buffer,\n\t\t\t   size_t buffer_size)\n{\n\tint ret, had_lock;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_lock_holder oh;\n\n\thad_lock = ocfs2_inode_lock_tracker(inode, &di_bh, 0, &oh);\n\tif (had_lock < 0) {\n\t\tmlog_errno(had_lock);\n\t\treturn had_lock;\n\t}\n\tdown_read(&OCFS2_I(inode)->ip_xattr_sem);\n\tret = ocfs2_xattr_get_nolock(inode, di_bh, name_index,\n\t\t\t\t     name, buffer, buffer_size);\n\tup_read(&OCFS2_I(inode)->ip_xattr_sem);\n\n\tocfs2_inode_unlock_tracker(inode, 0, &oh, had_lock);\n\n\tbrelse(di_bh);\n\n\treturn ret;\n}\n\nstatic int __ocfs2_xattr_set_value_outside(struct inode *inode,\n\t\t\t\t\t   handle_t *handle,\n\t\t\t\t\t   struct ocfs2_xattr_value_buf *vb,\n\t\t\t\t\t   const void *value,\n\t\t\t\t\t   int value_len)\n{\n\tint ret = 0, i, cp_len;\n\tu16 blocksize = inode->i_sb->s_blocksize;\n\tu32 p_cluster, num_clusters;\n\tu32 cpos = 0, bpc = ocfs2_clusters_to_blocks(inode->i_sb, 1);\n\tu32 clusters = ocfs2_clusters_for_bytes(inode->i_sb, value_len);\n\tu64 blkno;\n\tstruct buffer_head *bh = NULL;\n\tunsigned int ext_flags;\n\tstruct ocfs2_xattr_value_root *xv = vb->vb_xv;\n\n\tBUG_ON(clusters > le32_to_cpu(xv->xr_clusters));\n\n\twhile (cpos < clusters) {\n\t\tret = ocfs2_xattr_get_clusters(inode, cpos, &p_cluster,\n\t\t\t\t\t       &num_clusters, &xv->xr_list,\n\t\t\t\t\t       &ext_flags);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tBUG_ON(ext_flags & OCFS2_EXT_REFCOUNTED);\n\n\t\tblkno = ocfs2_clusters_to_blocks(inode->i_sb, p_cluster);\n\n\t\tfor (i = 0; i < num_clusters * bpc; i++, blkno++) {\n\t\t\tret = ocfs2_read_block(INODE_CACHE(inode), blkno,\n\t\t\t\t\t       &bh, NULL);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = ocfs2_journal_access(handle,\n\t\t\t\t\t\t   INODE_CACHE(inode),\n\t\t\t\t\t\t   bh,\n\t\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_WRITE);\n\t\t\tif (ret < 0) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tcp_len = value_len > blocksize ? blocksize : value_len;\n\t\t\tmemcpy(bh->b_data, value, cp_len);\n\t\t\tvalue_len -= cp_len;\n\t\t\tvalue += cp_len;\n\t\t\tif (cp_len < blocksize)\n\t\t\t\tmemset(bh->b_data + cp_len, 0,\n\t\t\t\t       blocksize - cp_len);\n\n\t\t\tocfs2_journal_dirty(handle, bh);\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\n\t\t\t \n\t\t\tif (!value_len)\n\t\t\t\tbreak;\n\t\t}\n\t\tcpos += num_clusters;\n\t}\nout:\n\tbrelse(bh);\n\n\treturn ret;\n}\n\nstatic int ocfs2_xa_check_space_helper(int needed_space, int free_start,\n\t\t\t\t       int num_entries)\n{\n\tint free_space;\n\n\tif (!needed_space)\n\t\treturn 0;\n\n\tfree_space = free_start -\n\t\tsizeof(struct ocfs2_xattr_header) -\n\t\t(num_entries * sizeof(struct ocfs2_xattr_entry)) -\n\t\tOCFS2_XATTR_HEADER_GAP;\n\tif (free_space < 0)\n\t\treturn -EIO;\n\tif (free_space < needed_space)\n\t\treturn -ENOSPC;\n\n\treturn 0;\n}\n\nstatic int ocfs2_xa_journal_access(handle_t *handle, struct ocfs2_xa_loc *loc,\n\t\t\t\t   int type)\n{\n\treturn loc->xl_ops->xlo_journal_access(handle, loc, type);\n}\n\nstatic void ocfs2_xa_journal_dirty(handle_t *handle, struct ocfs2_xa_loc *loc)\n{\n\tloc->xl_ops->xlo_journal_dirty(handle, loc);\n}\n\n \nstatic void *ocfs2_xa_offset_pointer(struct ocfs2_xa_loc *loc, int offset)\n{\n\tBUG_ON(offset >= loc->xl_size);\n\treturn loc->xl_ops->xlo_offset_pointer(loc, offset);\n}\n\n \nstatic void ocfs2_xa_wipe_namevalue(struct ocfs2_xa_loc *loc)\n{\n\tloc->xl_ops->xlo_wipe_namevalue(loc);\n}\n\n \nstatic int ocfs2_xa_get_free_start(struct ocfs2_xa_loc *loc)\n{\n\treturn loc->xl_ops->xlo_get_free_start(loc);\n}\n\n \nstatic int ocfs2_xa_can_reuse_entry(struct ocfs2_xa_loc *loc,\n\t\t\t\t    struct ocfs2_xattr_info *xi)\n{\n\treturn loc->xl_ops->xlo_can_reuse(loc, xi);\n}\n\n \nstatic int ocfs2_xa_check_space(struct ocfs2_xa_loc *loc,\n\t\t\t\tstruct ocfs2_xattr_info *xi)\n{\n\treturn loc->xl_ops->xlo_check_space(loc, xi);\n}\n\nstatic void ocfs2_xa_add_entry(struct ocfs2_xa_loc *loc, u32 name_hash)\n{\n\tloc->xl_ops->xlo_add_entry(loc, name_hash);\n\tloc->xl_entry->xe_name_hash = cpu_to_le32(name_hash);\n\t \n\tloc->xl_entry->xe_name_offset = cpu_to_le16(loc->xl_size);\n}\n\nstatic void ocfs2_xa_add_namevalue(struct ocfs2_xa_loc *loc,\n\t\t\t\t   struct ocfs2_xattr_info *xi)\n{\n\tint size = namevalue_size_xi(xi);\n\tint nameval_offset;\n\tchar *nameval_buf;\n\n\tloc->xl_ops->xlo_add_namevalue(loc, size);\n\tloc->xl_entry->xe_value_size = cpu_to_le64(xi->xi_value_len);\n\tloc->xl_entry->xe_name_len = xi->xi_name_len;\n\tocfs2_xattr_set_type(loc->xl_entry, xi->xi_name_index);\n\tocfs2_xattr_set_local(loc->xl_entry,\n\t\t\t      xi->xi_value_len <= OCFS2_XATTR_INLINE_SIZE);\n\n\tnameval_offset = le16_to_cpu(loc->xl_entry->xe_name_offset);\n\tnameval_buf = ocfs2_xa_offset_pointer(loc, nameval_offset);\n\tmemset(nameval_buf, 0, size);\n\tmemcpy(nameval_buf, xi->xi_name, xi->xi_name_len);\n}\n\nstatic void ocfs2_xa_fill_value_buf(struct ocfs2_xa_loc *loc,\n\t\t\t\t    struct ocfs2_xattr_value_buf *vb)\n{\n\tint nameval_offset = le16_to_cpu(loc->xl_entry->xe_name_offset);\n\tint name_size = OCFS2_XATTR_SIZE(loc->xl_entry->xe_name_len);\n\n\t \n\tBUG_ON(ocfs2_xattr_is_local(loc->xl_entry));\n\tBUG_ON(namevalue_size_xe(loc->xl_entry) !=\n\t       (name_size + OCFS2_XATTR_ROOT_SIZE));\n\n\tloc->xl_ops->xlo_fill_value_buf(loc, vb);\n\tvb->vb_xv =\n\t\t(struct ocfs2_xattr_value_root *)ocfs2_xa_offset_pointer(loc,\n\t\t\t\t\t\t\tnameval_offset +\n\t\t\t\t\t\t\tname_size);\n}\n\nstatic int ocfs2_xa_block_journal_access(handle_t *handle,\n\t\t\t\t\t struct ocfs2_xa_loc *loc, int type)\n{\n\tstruct buffer_head *bh = loc->xl_storage;\n\tocfs2_journal_access_func access;\n\n\tif (loc->xl_size == (bh->b_size -\n\t\t\t     offsetof(struct ocfs2_xattr_block,\n\t\t\t\t      xb_attrs.xb_header)))\n\t\taccess = ocfs2_journal_access_xb;\n\telse\n\t\taccess = ocfs2_journal_access_di;\n\treturn access(handle, INODE_CACHE(loc->xl_inode), bh, type);\n}\n\nstatic void ocfs2_xa_block_journal_dirty(handle_t *handle,\n\t\t\t\t\t struct ocfs2_xa_loc *loc)\n{\n\tstruct buffer_head *bh = loc->xl_storage;\n\n\tocfs2_journal_dirty(handle, bh);\n}\n\nstatic void *ocfs2_xa_block_offset_pointer(struct ocfs2_xa_loc *loc,\n\t\t\t\t\t   int offset)\n{\n\treturn (char *)loc->xl_header + offset;\n}\n\nstatic int ocfs2_xa_block_can_reuse(struct ocfs2_xa_loc *loc,\n\t\t\t\t    struct ocfs2_xattr_info *xi)\n{\n\t \n\treturn namevalue_size_xe(loc->xl_entry) ==\n\t\tnamevalue_size_xi(xi);\n}\n\nstatic int ocfs2_xa_block_get_free_start(struct ocfs2_xa_loc *loc)\n{\n\tstruct ocfs2_xattr_header *xh = loc->xl_header;\n\tint i, count = le16_to_cpu(xh->xh_count);\n\tint offset, free_start = loc->xl_size;\n\n\tfor (i = 0; i < count; i++) {\n\t\toffset = le16_to_cpu(xh->xh_entries[i].xe_name_offset);\n\t\tif (offset < free_start)\n\t\t\tfree_start = offset;\n\t}\n\n\treturn free_start;\n}\n\nstatic int ocfs2_xa_block_check_space(struct ocfs2_xa_loc *loc,\n\t\t\t\t      struct ocfs2_xattr_info *xi)\n{\n\tint count = le16_to_cpu(loc->xl_header->xh_count);\n\tint free_start = ocfs2_xa_get_free_start(loc);\n\tint needed_space = ocfs2_xi_entry_usage(xi);\n\n\t \n\tif (loc->xl_entry) {\n\t\t \n\t\tif (ocfs2_xa_can_reuse_entry(loc, xi))\n\t\t\tneeded_space = 0;\n\t\telse\n\t\t\tneeded_space -= ocfs2_xe_entry_usage(loc->xl_entry);\n\t}\n\tif (needed_space < 0)\n\t\tneeded_space = 0;\n\treturn ocfs2_xa_check_space_helper(needed_space, free_start, count);\n}\n\n \nstatic void ocfs2_xa_block_wipe_namevalue(struct ocfs2_xa_loc *loc)\n{\n\tint i, offset;\n\tint namevalue_offset, first_namevalue_offset, namevalue_size;\n\tstruct ocfs2_xattr_entry *entry = loc->xl_entry;\n\tstruct ocfs2_xattr_header *xh = loc->xl_header;\n\tint count = le16_to_cpu(xh->xh_count);\n\n\tnamevalue_offset = le16_to_cpu(entry->xe_name_offset);\n\tnamevalue_size = namevalue_size_xe(entry);\n\tfirst_namevalue_offset = ocfs2_xa_get_free_start(loc);\n\n\t \n\tmemmove((char *)xh + first_namevalue_offset + namevalue_size,\n\t\t(char *)xh + first_namevalue_offset,\n\t\tnamevalue_offset - first_namevalue_offset);\n\tmemset((char *)xh + first_namevalue_offset, 0, namevalue_size);\n\n\t \n\tfor (i = 0; i < count; i++) {\n\t\toffset = le16_to_cpu(xh->xh_entries[i].xe_name_offset);\n\t\tif (offset <= namevalue_offset)\n\t\t\tle16_add_cpu(&xh->xh_entries[i].xe_name_offset,\n\t\t\t\t     namevalue_size);\n\t}\n\n\t \n}\n\nstatic void ocfs2_xa_block_add_entry(struct ocfs2_xa_loc *loc, u32 name_hash)\n{\n\tint count = le16_to_cpu(loc->xl_header->xh_count);\n\tloc->xl_entry = &(loc->xl_header->xh_entries[count]);\n\tle16_add_cpu(&loc->xl_header->xh_count, 1);\n\tmemset(loc->xl_entry, 0, sizeof(struct ocfs2_xattr_entry));\n}\n\nstatic void ocfs2_xa_block_add_namevalue(struct ocfs2_xa_loc *loc, int size)\n{\n\tint free_start = ocfs2_xa_get_free_start(loc);\n\n\tloc->xl_entry->xe_name_offset = cpu_to_le16(free_start - size);\n}\n\nstatic void ocfs2_xa_block_fill_value_buf(struct ocfs2_xa_loc *loc,\n\t\t\t\t\t  struct ocfs2_xattr_value_buf *vb)\n{\n\tstruct buffer_head *bh = loc->xl_storage;\n\n\tif (loc->xl_size == (bh->b_size -\n\t\t\t     offsetof(struct ocfs2_xattr_block,\n\t\t\t\t      xb_attrs.xb_header)))\n\t\tvb->vb_access = ocfs2_journal_access_xb;\n\telse\n\t\tvb->vb_access = ocfs2_journal_access_di;\n\tvb->vb_bh = bh;\n}\n\n \nstatic const struct ocfs2_xa_loc_operations ocfs2_xa_block_loc_ops = {\n\t.xlo_journal_access\t= ocfs2_xa_block_journal_access,\n\t.xlo_journal_dirty\t= ocfs2_xa_block_journal_dirty,\n\t.xlo_offset_pointer\t= ocfs2_xa_block_offset_pointer,\n\t.xlo_check_space\t= ocfs2_xa_block_check_space,\n\t.xlo_can_reuse\t\t= ocfs2_xa_block_can_reuse,\n\t.xlo_get_free_start\t= ocfs2_xa_block_get_free_start,\n\t.xlo_wipe_namevalue\t= ocfs2_xa_block_wipe_namevalue,\n\t.xlo_add_entry\t\t= ocfs2_xa_block_add_entry,\n\t.xlo_add_namevalue\t= ocfs2_xa_block_add_namevalue,\n\t.xlo_fill_value_buf\t= ocfs2_xa_block_fill_value_buf,\n};\n\nstatic int ocfs2_xa_bucket_journal_access(handle_t *handle,\n\t\t\t\t\t  struct ocfs2_xa_loc *loc, int type)\n{\n\tstruct ocfs2_xattr_bucket *bucket = loc->xl_storage;\n\n\treturn ocfs2_xattr_bucket_journal_access(handle, bucket, type);\n}\n\nstatic void ocfs2_xa_bucket_journal_dirty(handle_t *handle,\n\t\t\t\t\t  struct ocfs2_xa_loc *loc)\n{\n\tstruct ocfs2_xattr_bucket *bucket = loc->xl_storage;\n\n\tocfs2_xattr_bucket_journal_dirty(handle, bucket);\n}\n\nstatic void *ocfs2_xa_bucket_offset_pointer(struct ocfs2_xa_loc *loc,\n\t\t\t\t\t    int offset)\n{\n\tstruct ocfs2_xattr_bucket *bucket = loc->xl_storage;\n\tint block, block_offset;\n\n\t \n\tblock = offset >> loc->xl_inode->i_sb->s_blocksize_bits;\n\tblock_offset = offset % loc->xl_inode->i_sb->s_blocksize;\n\n\treturn bucket_block(bucket, block) + block_offset;\n}\n\nstatic int ocfs2_xa_bucket_can_reuse(struct ocfs2_xa_loc *loc,\n\t\t\t\t     struct ocfs2_xattr_info *xi)\n{\n\treturn namevalue_size_xe(loc->xl_entry) >=\n\t\tnamevalue_size_xi(xi);\n}\n\nstatic int ocfs2_xa_bucket_get_free_start(struct ocfs2_xa_loc *loc)\n{\n\tstruct ocfs2_xattr_bucket *bucket = loc->xl_storage;\n\treturn le16_to_cpu(bucket_xh(bucket)->xh_free_start);\n}\n\nstatic int ocfs2_bucket_align_free_start(struct super_block *sb,\n\t\t\t\t\t int free_start, int size)\n{\n\t \n\tif (((free_start - size) >> sb->s_blocksize_bits) !=\n\t    ((free_start - 1) >> sb->s_blocksize_bits))\n\t\tfree_start -= free_start % sb->s_blocksize;\n\n\treturn free_start;\n}\n\nstatic int ocfs2_xa_bucket_check_space(struct ocfs2_xa_loc *loc,\n\t\t\t\t       struct ocfs2_xattr_info *xi)\n{\n\tint rc;\n\tint count = le16_to_cpu(loc->xl_header->xh_count);\n\tint free_start = ocfs2_xa_get_free_start(loc);\n\tint needed_space = ocfs2_xi_entry_usage(xi);\n\tint size = namevalue_size_xi(xi);\n\tstruct super_block *sb = loc->xl_inode->i_sb;\n\n\t \n\tif (loc->xl_entry) {\n\t\t \n\t\tif (ocfs2_xa_can_reuse_entry(loc, xi))\n\t\t\tneeded_space = 0;\n\t\telse\n\t\t\tneeded_space -= sizeof(struct ocfs2_xattr_entry);\n\t}\n\tBUG_ON(needed_space < 0);\n\n\tif (free_start < size) {\n\t\tif (needed_space)\n\t\t\treturn -ENOSPC;\n\t} else {\n\t\t \n\t\trc = ocfs2_xa_check_space_helper(needed_space, free_start,\n\t\t\t\t\t\t count);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tfree_start = ocfs2_bucket_align_free_start(sb, free_start,\n\t\t\t\t\t\t\t   size);\n\t}\n\treturn ocfs2_xa_check_space_helper(needed_space, free_start, count);\n}\n\nstatic void ocfs2_xa_bucket_wipe_namevalue(struct ocfs2_xa_loc *loc)\n{\n\tle16_add_cpu(&loc->xl_header->xh_name_value_len,\n\t\t     -namevalue_size_xe(loc->xl_entry));\n}\n\nstatic void ocfs2_xa_bucket_add_entry(struct ocfs2_xa_loc *loc, u32 name_hash)\n{\n\tstruct ocfs2_xattr_header *xh = loc->xl_header;\n\tint count = le16_to_cpu(xh->xh_count);\n\tint low = 0, high = count - 1, tmp;\n\tstruct ocfs2_xattr_entry *tmp_xe;\n\n\t \n\twhile (low <= high && count) {\n\t\ttmp = (low + high) / 2;\n\t\ttmp_xe = &xh->xh_entries[tmp];\n\n\t\tif (name_hash > le32_to_cpu(tmp_xe->xe_name_hash))\n\t\t\tlow = tmp + 1;\n\t\telse if (name_hash < le32_to_cpu(tmp_xe->xe_name_hash))\n\t\t\thigh = tmp - 1;\n\t\telse {\n\t\t\tlow = tmp;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (low != count)\n\t\tmemmove(&xh->xh_entries[low + 1],\n\t\t\t&xh->xh_entries[low],\n\t\t\t((count - low) * sizeof(struct ocfs2_xattr_entry)));\n\n\tle16_add_cpu(&xh->xh_count, 1);\n\tloc->xl_entry = &xh->xh_entries[low];\n\tmemset(loc->xl_entry, 0, sizeof(struct ocfs2_xattr_entry));\n}\n\nstatic void ocfs2_xa_bucket_add_namevalue(struct ocfs2_xa_loc *loc, int size)\n{\n\tint free_start = ocfs2_xa_get_free_start(loc);\n\tstruct ocfs2_xattr_header *xh = loc->xl_header;\n\tstruct super_block *sb = loc->xl_inode->i_sb;\n\tint nameval_offset;\n\n\tfree_start = ocfs2_bucket_align_free_start(sb, free_start, size);\n\tnameval_offset = free_start - size;\n\tloc->xl_entry->xe_name_offset = cpu_to_le16(nameval_offset);\n\txh->xh_free_start = cpu_to_le16(nameval_offset);\n\tle16_add_cpu(&xh->xh_name_value_len, size);\n\n}\n\nstatic void ocfs2_xa_bucket_fill_value_buf(struct ocfs2_xa_loc *loc,\n\t\t\t\t\t   struct ocfs2_xattr_value_buf *vb)\n{\n\tstruct ocfs2_xattr_bucket *bucket = loc->xl_storage;\n\tstruct super_block *sb = loc->xl_inode->i_sb;\n\tint nameval_offset = le16_to_cpu(loc->xl_entry->xe_name_offset);\n\tint size = namevalue_size_xe(loc->xl_entry);\n\tint block_offset = nameval_offset >> sb->s_blocksize_bits;\n\n\t \n\tBUG_ON(block_offset !=\n\t       ((nameval_offset + size - 1) >> sb->s_blocksize_bits));\n\t \n\tBUG_ON(!bucket->bu_bhs[block_offset]);\n\n\tvb->vb_access = ocfs2_journal_access;\n\tvb->vb_bh = bucket->bu_bhs[block_offset];\n}\n\n \nstatic const struct ocfs2_xa_loc_operations ocfs2_xa_bucket_loc_ops = {\n\t.xlo_journal_access\t= ocfs2_xa_bucket_journal_access,\n\t.xlo_journal_dirty\t= ocfs2_xa_bucket_journal_dirty,\n\t.xlo_offset_pointer\t= ocfs2_xa_bucket_offset_pointer,\n\t.xlo_check_space\t= ocfs2_xa_bucket_check_space,\n\t.xlo_can_reuse\t\t= ocfs2_xa_bucket_can_reuse,\n\t.xlo_get_free_start\t= ocfs2_xa_bucket_get_free_start,\n\t.xlo_wipe_namevalue\t= ocfs2_xa_bucket_wipe_namevalue,\n\t.xlo_add_entry\t\t= ocfs2_xa_bucket_add_entry,\n\t.xlo_add_namevalue\t= ocfs2_xa_bucket_add_namevalue,\n\t.xlo_fill_value_buf\t= ocfs2_xa_bucket_fill_value_buf,\n};\n\nstatic unsigned int ocfs2_xa_value_clusters(struct ocfs2_xa_loc *loc)\n{\n\tstruct ocfs2_xattr_value_buf vb;\n\n\tif (ocfs2_xattr_is_local(loc->xl_entry))\n\t\treturn 0;\n\n\tocfs2_xa_fill_value_buf(loc, &vb);\n\treturn le32_to_cpu(vb.vb_xv->xr_clusters);\n}\n\nstatic int ocfs2_xa_value_truncate(struct ocfs2_xa_loc *loc, u64 bytes,\n\t\t\t\t   struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint trunc_rc, access_rc;\n\tstruct ocfs2_xattr_value_buf vb;\n\n\tocfs2_xa_fill_value_buf(loc, &vb);\n\ttrunc_rc = ocfs2_xattr_value_truncate(loc->xl_inode, &vb, bytes,\n\t\t\t\t\t      ctxt);\n\n\t \n\taccess_rc = ocfs2_xa_journal_access(ctxt->handle, loc,\n\t\t\t\t\t    OCFS2_JOURNAL_ACCESS_WRITE);\n\n\t \n\treturn trunc_rc ? trunc_rc : access_rc;\n}\n\nstatic void ocfs2_xa_remove_entry(struct ocfs2_xa_loc *loc)\n{\n\tint index, count;\n\tstruct ocfs2_xattr_header *xh = loc->xl_header;\n\tstruct ocfs2_xattr_entry *entry = loc->xl_entry;\n\n\tocfs2_xa_wipe_namevalue(loc);\n\tloc->xl_entry = NULL;\n\n\tle16_add_cpu(&xh->xh_count, -1);\n\tcount = le16_to_cpu(xh->xh_count);\n\n\t \n\tif (count) {\n\t\tindex = ((char *)entry - (char *)&xh->xh_entries) /\n\t\t\tsizeof(struct ocfs2_xattr_entry);\n\t\tmemmove(&xh->xh_entries[index], &xh->xh_entries[index + 1],\n\t\t\t(count - index) * sizeof(struct ocfs2_xattr_entry));\n\t\tmemset(&xh->xh_entries[count], 0,\n\t\t       sizeof(struct ocfs2_xattr_entry));\n\t}\n}\n\n \nstatic void ocfs2_xa_cleanup_value_truncate(struct ocfs2_xa_loc *loc,\n\t\t\t\t\t    const char *what,\n\t\t\t\t\t    unsigned int orig_clusters)\n{\n\tunsigned int new_clusters = ocfs2_xa_value_clusters(loc);\n\tchar *nameval_buf = ocfs2_xa_offset_pointer(loc,\n\t\t\t\tle16_to_cpu(loc->xl_entry->xe_name_offset));\n\n\tif (new_clusters < orig_clusters) {\n\t\tmlog(ML_ERROR,\n\t\t     \"Partial truncate while %s xattr %.*s.  Leaking \"\n\t\t     \"%u clusters and removing the entry\\n\",\n\t\t     what, loc->xl_entry->xe_name_len, nameval_buf,\n\t\t     orig_clusters - new_clusters);\n\t\tocfs2_xa_remove_entry(loc);\n\t} else if (!orig_clusters) {\n\t\tmlog(ML_ERROR,\n\t\t     \"Unable to allocate an external value for xattr \"\n\t\t     \"%.*s safely.  Leaking %u clusters and removing the \"\n\t\t     \"entry\\n\",\n\t\t     loc->xl_entry->xe_name_len, nameval_buf,\n\t\t     new_clusters - orig_clusters);\n\t\tocfs2_xa_remove_entry(loc);\n\t} else if (new_clusters > orig_clusters)\n\t\tmlog(ML_ERROR,\n\t\t     \"Unable to grow xattr %.*s safely.  %u new clusters \"\n\t\t     \"have been added, but the value will not be \"\n\t\t     \"modified\\n\",\n\t\t     loc->xl_entry->xe_name_len, nameval_buf,\n\t\t     new_clusters - orig_clusters);\n}\n\nstatic int ocfs2_xa_remove(struct ocfs2_xa_loc *loc,\n\t\t\t   struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint rc = 0;\n\tunsigned int orig_clusters;\n\n\tif (!ocfs2_xattr_is_local(loc->xl_entry)) {\n\t\torig_clusters = ocfs2_xa_value_clusters(loc);\n\t\trc = ocfs2_xa_value_truncate(loc, 0, ctxt);\n\t\tif (rc) {\n\t\t\tmlog_errno(rc);\n\t\t\t \n\t\t\tif (orig_clusters != ocfs2_xa_value_clusters(loc))\n\t\t\t\trc = 0;\n\t\t\tocfs2_xa_cleanup_value_truncate(loc, \"removing\",\n\t\t\t\t\t\t\torig_clusters);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tocfs2_xa_remove_entry(loc);\n\nout:\n\treturn rc;\n}\n\nstatic void ocfs2_xa_install_value_root(struct ocfs2_xa_loc *loc)\n{\n\tint name_size = OCFS2_XATTR_SIZE(loc->xl_entry->xe_name_len);\n\tchar *nameval_buf;\n\n\tnameval_buf = ocfs2_xa_offset_pointer(loc,\n\t\t\t\tle16_to_cpu(loc->xl_entry->xe_name_offset));\n\tmemcpy(nameval_buf + name_size, &def_xv, OCFS2_XATTR_ROOT_SIZE);\n}\n\n \nstatic int ocfs2_xa_reuse_entry(struct ocfs2_xa_loc *loc,\n\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\tstruct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint rc = 0;\n\tint name_size = OCFS2_XATTR_SIZE(xi->xi_name_len);\n\tunsigned int orig_clusters;\n\tchar *nameval_buf;\n\tint xe_local = ocfs2_xattr_is_local(loc->xl_entry);\n\tint xi_local = xi->xi_value_len <= OCFS2_XATTR_INLINE_SIZE;\n\n\tBUG_ON(OCFS2_XATTR_SIZE(loc->xl_entry->xe_name_len) !=\n\t       name_size);\n\n\tnameval_buf = ocfs2_xa_offset_pointer(loc,\n\t\t\t\tle16_to_cpu(loc->xl_entry->xe_name_offset));\n\tif (xe_local) {\n\t\tmemset(nameval_buf + name_size, 0,\n\t\t       namevalue_size_xe(loc->xl_entry) - name_size);\n\t\tif (!xi_local)\n\t\t\tocfs2_xa_install_value_root(loc);\n\t} else {\n\t\torig_clusters = ocfs2_xa_value_clusters(loc);\n\t\tif (xi_local) {\n\t\t\trc = ocfs2_xa_value_truncate(loc, 0, ctxt);\n\t\t\tif (rc < 0)\n\t\t\t\tmlog_errno(rc);\n\t\t\telse\n\t\t\t\tmemset(nameval_buf + name_size, 0,\n\t\t\t\t       namevalue_size_xe(loc->xl_entry) -\n\t\t\t\t       name_size);\n\t\t} else if (le64_to_cpu(loc->xl_entry->xe_value_size) >\n\t\t\t   xi->xi_value_len) {\n\t\t\trc = ocfs2_xa_value_truncate(loc, xi->xi_value_len,\n\t\t\t\t\t\t     ctxt);\n\t\t\tif (rc < 0)\n\t\t\t\tmlog_errno(rc);\n\t\t}\n\n\t\tif (rc) {\n\t\t\tocfs2_xa_cleanup_value_truncate(loc, \"reusing\",\n\t\t\t\t\t\t\torig_clusters);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tloc->xl_entry->xe_value_size = cpu_to_le64(xi->xi_value_len);\n\tocfs2_xattr_set_local(loc->xl_entry, xi_local);\n\nout:\n\treturn rc;\n}\n\n \nstatic int ocfs2_xa_prepare_entry(struct ocfs2_xa_loc *loc,\n\t\t\t\t  struct ocfs2_xattr_info *xi,\n\t\t\t\t  u32 name_hash,\n\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint rc = 0;\n\tunsigned int orig_clusters;\n\t__le64 orig_value_size = 0;\n\n\trc = ocfs2_xa_check_space(loc, xi);\n\tif (rc)\n\t\tgoto out;\n\n\tif (loc->xl_entry) {\n\t\tif (ocfs2_xa_can_reuse_entry(loc, xi)) {\n\t\t\torig_value_size = loc->xl_entry->xe_value_size;\n\t\t\trc = ocfs2_xa_reuse_entry(loc, xi, ctxt);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t\tgoto alloc_value;\n\t\t}\n\n\t\tif (!ocfs2_xattr_is_local(loc->xl_entry)) {\n\t\t\torig_clusters = ocfs2_xa_value_clusters(loc);\n\t\t\trc = ocfs2_xa_value_truncate(loc, 0, ctxt);\n\t\t\tif (rc) {\n\t\t\t\tmlog_errno(rc);\n\t\t\t\tocfs2_xa_cleanup_value_truncate(loc,\n\t\t\t\t\t\t\t\t\"overwriting\",\n\t\t\t\t\t\t\t\torig_clusters);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tocfs2_xa_wipe_namevalue(loc);\n\t} else\n\t\tocfs2_xa_add_entry(loc, name_hash);\n\n\t \n\tocfs2_xa_add_namevalue(loc, xi);\n\tif (xi->xi_value_len > OCFS2_XATTR_INLINE_SIZE)\n\t\tocfs2_xa_install_value_root(loc);\n\nalloc_value:\n\tif (xi->xi_value_len > OCFS2_XATTR_INLINE_SIZE) {\n\t\torig_clusters = ocfs2_xa_value_clusters(loc);\n\t\trc = ocfs2_xa_value_truncate(loc, xi->xi_value_len, ctxt);\n\t\tif (rc < 0) {\n\t\t\tctxt->set_abort = 1;\n\t\t\tocfs2_xa_cleanup_value_truncate(loc, \"growing\",\n\t\t\t\t\t\t\torig_clusters);\n\t\t\t \n\t\t\tif (loc->xl_entry) {\n\t\t\t\tBUG_ON(!orig_value_size);\n\t\t\t\tloc->xl_entry->xe_value_size = orig_value_size;\n\t\t\t}\n\t\t\tmlog_errno(rc);\n\t\t}\n\t}\n\nout:\n\treturn rc;\n}\n\n \nstatic int ocfs2_xa_store_value(struct ocfs2_xa_loc *loc,\n\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\tstruct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint rc = 0;\n\tint nameval_offset = le16_to_cpu(loc->xl_entry->xe_name_offset);\n\tint name_size = OCFS2_XATTR_SIZE(xi->xi_name_len);\n\tchar *nameval_buf;\n\tstruct ocfs2_xattr_value_buf vb;\n\n\tnameval_buf = ocfs2_xa_offset_pointer(loc, nameval_offset);\n\tif (xi->xi_value_len > OCFS2_XATTR_INLINE_SIZE) {\n\t\tocfs2_xa_fill_value_buf(loc, &vb);\n\t\trc = __ocfs2_xattr_set_value_outside(loc->xl_inode,\n\t\t\t\t\t\t     ctxt->handle, &vb,\n\t\t\t\t\t\t     xi->xi_value,\n\t\t\t\t\t\t     xi->xi_value_len);\n\t} else\n\t\tmemcpy(nameval_buf + name_size, xi->xi_value, xi->xi_value_len);\n\n\treturn rc;\n}\n\nstatic int ocfs2_xa_set(struct ocfs2_xa_loc *loc,\n\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\tstruct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret;\n\tu32 name_hash = ocfs2_xattr_name_hash(loc->xl_inode, xi->xi_name,\n\t\t\t\t\t      xi->xi_name_len);\n\n\tret = ocfs2_xa_journal_access(ctxt->handle, loc,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t \n\n\t \n\tif (!xi->xi_value) {\n\t\tret = ocfs2_xa_remove(loc, ctxt);\n\t\tgoto out_dirty;\n\t}\n\n\tret = ocfs2_xa_prepare_entry(loc, xi, name_hash, ctxt);\n\tif (ret) {\n\t\tif (ret != -ENOSPC)\n\t\t\tmlog_errno(ret);\n\t\tgoto out_dirty;\n\t}\n\n\tret = ocfs2_xa_store_value(loc, xi, ctxt);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout_dirty:\n\tocfs2_xa_journal_dirty(ctxt->handle, loc);\n\nout:\n\treturn ret;\n}\n\nstatic void ocfs2_init_dinode_xa_loc(struct ocfs2_xa_loc *loc,\n\t\t\t\t     struct inode *inode,\n\t\t\t\t     struct buffer_head *bh,\n\t\t\t\t     struct ocfs2_xattr_entry *entry)\n{\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)bh->b_data;\n\n\tBUG_ON(!(OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_XATTR_FL));\n\n\tloc->xl_inode = inode;\n\tloc->xl_ops = &ocfs2_xa_block_loc_ops;\n\tloc->xl_storage = bh;\n\tloc->xl_entry = entry;\n\tloc->xl_size = le16_to_cpu(di->i_xattr_inline_size);\n\tloc->xl_header =\n\t\t(struct ocfs2_xattr_header *)(bh->b_data + bh->b_size -\n\t\t\t\t\t      loc->xl_size);\n}\n\nstatic void ocfs2_init_xattr_block_xa_loc(struct ocfs2_xa_loc *loc,\n\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t\t  struct ocfs2_xattr_entry *entry)\n{\n\tstruct ocfs2_xattr_block *xb =\n\t\t(struct ocfs2_xattr_block *)bh->b_data;\n\n\tBUG_ON(le16_to_cpu(xb->xb_flags) & OCFS2_XATTR_INDEXED);\n\n\tloc->xl_inode = inode;\n\tloc->xl_ops = &ocfs2_xa_block_loc_ops;\n\tloc->xl_storage = bh;\n\tloc->xl_header = &(xb->xb_attrs.xb_header);\n\tloc->xl_entry = entry;\n\tloc->xl_size = bh->b_size - offsetof(struct ocfs2_xattr_block,\n\t\t\t\t\t     xb_attrs.xb_header);\n}\n\nstatic void ocfs2_init_xattr_bucket_xa_loc(struct ocfs2_xa_loc *loc,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   struct ocfs2_xattr_entry *entry)\n{\n\tloc->xl_inode = bucket->bu_inode;\n\tloc->xl_ops = &ocfs2_xa_bucket_loc_ops;\n\tloc->xl_storage = bucket;\n\tloc->xl_header = bucket_xh(bucket);\n\tloc->xl_entry = entry;\n\tloc->xl_size = OCFS2_XATTR_BUCKET_SIZE;\n}\n\n \nstatic int ocfs2_lock_xattr_remove_allocators(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_value_root *xv,\n\t\t\t\t\tstruct ocfs2_caching_info *ref_ci,\n\t\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\t\tstruct ocfs2_alloc_context **meta_ac,\n\t\t\t\t\tint *ref_credits)\n{\n\tint ret, meta_add = 0;\n\tu32 p_cluster, num_clusters;\n\tunsigned int ext_flags;\n\n\t*ref_credits = 0;\n\tret = ocfs2_xattr_get_clusters(inode, 0, &p_cluster,\n\t\t\t\t       &num_clusters,\n\t\t\t\t       &xv->xr_list,\n\t\t\t\t       &ext_flags);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (!(ext_flags & OCFS2_EXT_REFCOUNTED))\n\t\tgoto out;\n\n\tret = ocfs2_refcounted_xattr_delete_need(inode, ref_ci,\n\t\t\t\t\t\t ref_root_bh, xv,\n\t\t\t\t\t\t &meta_add, ref_credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_reserve_new_metadata_blocks(OCFS2_SB(inode->i_sb),\n\t\t\t\t\t\tmeta_add, meta_ac);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\treturn ret;\n}\n\nstatic int ocfs2_remove_value_outside(struct inode*inode,\n\t\t\t\t      struct ocfs2_xattr_value_buf *vb,\n\t\t\t\t      struct ocfs2_xattr_header *header,\n\t\t\t\t      struct ocfs2_caching_info *ref_ci,\n\t\t\t\t      struct buffer_head *ref_root_bh)\n{\n\tint ret = 0, i, ref_credits;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_xattr_set_ctxt ctxt = { NULL, NULL, };\n\tvoid *val;\n\n\tocfs2_init_dealloc_ctxt(&ctxt.dealloc);\n\n\tfor (i = 0; i < le16_to_cpu(header->xh_count); i++) {\n\t\tstruct ocfs2_xattr_entry *entry = &header->xh_entries[i];\n\n\t\tif (ocfs2_xattr_is_local(entry))\n\t\t\tcontinue;\n\n\t\tval = (void *)header +\n\t\t\tle16_to_cpu(entry->xe_name_offset);\n\t\tvb->vb_xv = (struct ocfs2_xattr_value_root *)\n\t\t\t(val + OCFS2_XATTR_SIZE(entry->xe_name_len));\n\n\t\tret = ocfs2_lock_xattr_remove_allocators(inode, vb->vb_xv,\n\t\t\t\t\t\t\t ref_ci, ref_root_bh,\n\t\t\t\t\t\t\t &ctxt.meta_ac,\n\t\t\t\t\t\t\t &ref_credits);\n\n\t\tctxt.handle = ocfs2_start_trans(osb, ref_credits +\n\t\t\t\t\tocfs2_remove_extent_credits(osb->sb));\n\t\tif (IS_ERR(ctxt.handle)) {\n\t\t\tret = PTR_ERR(ctxt.handle);\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = ocfs2_xattr_value_truncate(inode, vb, 0, &ctxt);\n\n\t\tocfs2_commit_trans(osb, ctxt.handle);\n\t\tif (ctxt.meta_ac) {\n\t\t\tocfs2_free_alloc_context(ctxt.meta_ac);\n\t\t\tctxt.meta_ac = NULL;\n\t\t}\n\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\tif (ctxt.meta_ac)\n\t\tocfs2_free_alloc_context(ctxt.meta_ac);\n\tocfs2_schedule_truncate_log_flush(osb, 1);\n\tocfs2_run_deallocs(osb, &ctxt.dealloc);\n\treturn ret;\n}\n\nstatic int ocfs2_xattr_ibody_remove(struct inode *inode,\n\t\t\t\t    struct buffer_head *di_bh,\n\t\t\t\t    struct ocfs2_caching_info *ref_ci,\n\t\t\t\t    struct buffer_head *ref_root_bh)\n{\n\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_xattr_header *header;\n\tint ret;\n\tstruct ocfs2_xattr_value_buf vb = {\n\t\t.vb_bh = di_bh,\n\t\t.vb_access = ocfs2_journal_access_di,\n\t};\n\n\theader = (struct ocfs2_xattr_header *)\n\t\t ((void *)di + inode->i_sb->s_blocksize -\n\t\t le16_to_cpu(di->i_xattr_inline_size));\n\n\tret = ocfs2_remove_value_outside(inode, &vb, header,\n\t\t\t\t\t ref_ci, ref_root_bh);\n\n\treturn ret;\n}\n\nstruct ocfs2_rm_xattr_bucket_para {\n\tstruct ocfs2_caching_info *ref_ci;\n\tstruct buffer_head *ref_root_bh;\n};\n\nstatic int ocfs2_xattr_block_remove(struct inode *inode,\n\t\t\t\t    struct buffer_head *blk_bh,\n\t\t\t\t    struct ocfs2_caching_info *ref_ci,\n\t\t\t\t    struct buffer_head *ref_root_bh)\n{\n\tstruct ocfs2_xattr_block *xb;\n\tint ret = 0;\n\tstruct ocfs2_xattr_value_buf vb = {\n\t\t.vb_bh = blk_bh,\n\t\t.vb_access = ocfs2_journal_access_xb,\n\t};\n\tstruct ocfs2_rm_xattr_bucket_para args = {\n\t\t.ref_ci = ref_ci,\n\t\t.ref_root_bh = ref_root_bh,\n\t};\n\n\txb = (struct ocfs2_xattr_block *)blk_bh->b_data;\n\tif (!(le16_to_cpu(xb->xb_flags) & OCFS2_XATTR_INDEXED)) {\n\t\tstruct ocfs2_xattr_header *header = &(xb->xb_attrs.xb_header);\n\t\tret = ocfs2_remove_value_outside(inode, &vb, header,\n\t\t\t\t\t\t ref_ci, ref_root_bh);\n\t} else\n\t\tret = ocfs2_iterate_xattr_index_block(inode,\n\t\t\t\t\t\tblk_bh,\n\t\t\t\t\t\tocfs2_rm_xattr_cluster,\n\t\t\t\t\t\t&args);\n\n\treturn ret;\n}\n\nstatic int ocfs2_xattr_free_block(struct inode *inode,\n\t\t\t\t  u64 block,\n\t\t\t\t  struct ocfs2_caching_info *ref_ci,\n\t\t\t\t  struct buffer_head *ref_root_bh)\n{\n\tstruct inode *xb_alloc_inode;\n\tstruct buffer_head *xb_alloc_bh = NULL;\n\tstruct buffer_head *blk_bh = NULL;\n\tstruct ocfs2_xattr_block *xb;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\thandle_t *handle;\n\tint ret = 0;\n\tu64 blk, bg_blkno;\n\tu16 bit;\n\n\tret = ocfs2_read_xattr_block(inode, block, &blk_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_xattr_block_remove(inode, blk_bh, ref_ci, ref_root_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\txb = (struct ocfs2_xattr_block *)blk_bh->b_data;\n\tblk = le64_to_cpu(xb->xb_blkno);\n\tbit = le16_to_cpu(xb->xb_suballoc_bit);\n\tif (xb->xb_suballoc_loc)\n\t\tbg_blkno = le64_to_cpu(xb->xb_suballoc_loc);\n\telse\n\t\tbg_blkno = ocfs2_which_suballoc_group(blk, bit);\n\n\txb_alloc_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\tEXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\tle16_to_cpu(xb->xb_suballoc_slot));\n\tif (!xb_alloc_inode) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tinode_lock(xb_alloc_inode);\n\n\tret = ocfs2_inode_lock(xb_alloc_inode, &xb_alloc_bh, 1);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out_mutex;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_SUBALLOC_FREE);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out_unlock;\n\t}\n\n\tret = ocfs2_free_suballoc_bits(handle, xb_alloc_inode, xb_alloc_bh,\n\t\t\t\t       bit, bg_blkno, 1);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tocfs2_commit_trans(osb, handle);\nout_unlock:\n\tocfs2_inode_unlock(xb_alloc_inode, 1);\n\tbrelse(xb_alloc_bh);\nout_mutex:\n\tinode_unlock(xb_alloc_inode);\n\tiput(xb_alloc_inode);\nout:\n\tbrelse(blk_bh);\n\treturn ret;\n}\n\n \nint ocfs2_xattr_remove(struct inode *inode, struct buffer_head *di_bh)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_refcount_tree *ref_tree = NULL;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_caching_info *ref_ci = NULL;\n\thandle_t *handle;\n\tint ret;\n\n\tif (!ocfs2_supports_xattr(OCFS2_SB(inode->i_sb)))\n\t\treturn 0;\n\n\tif (!(oi->ip_dyn_features & OCFS2_HAS_XATTR_FL))\n\t\treturn 0;\n\n\tif (ocfs2_is_refcount_inode(inode)) {\n\t\tret = ocfs2_lock_refcount_tree(OCFS2_SB(inode->i_sb),\n\t\t\t\t\t       le64_to_cpu(di->i_refcount_loc),\n\t\t\t\t\t       1, &ref_tree, &ref_root_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tref_ci = &ref_tree->rf_ci;\n\n\t}\n\n\tif (oi->ip_dyn_features & OCFS2_INLINE_XATTR_FL) {\n\t\tret = ocfs2_xattr_ibody_remove(inode, di_bh,\n\t\t\t\t\t       ref_ci, ref_root_bh);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (di->i_xattr_loc) {\n\t\tret = ocfs2_xattr_free_block(inode,\n\t\t\t\t\t     le64_to_cpu(di->i_xattr_loc),\n\t\t\t\t\t     ref_ci, ref_root_bh);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\thandle = ocfs2_start_trans((OCFS2_SB(inode->i_sb)),\n\t\t\t\t   OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tdi->i_xattr_loc = 0;\n\n\tspin_lock(&oi->ip_lock);\n\toi->ip_dyn_features &= ~(OCFS2_INLINE_XATTR_FL | OCFS2_HAS_XATTR_FL);\n\tdi->i_dyn_features = cpu_to_le16(oi->ip_dyn_features);\n\tspin_unlock(&oi->ip_lock);\n\tocfs2_update_inode_fsync_trans(handle, inode, 0);\n\n\tocfs2_journal_dirty(handle, di_bh);\nout_commit:\n\tocfs2_commit_trans(OCFS2_SB(inode->i_sb), handle);\nout:\n\tif (ref_tree)\n\t\tocfs2_unlock_refcount_tree(OCFS2_SB(inode->i_sb), ref_tree, 1);\n\tbrelse(ref_root_bh);\n\treturn ret;\n}\n\nstatic int ocfs2_xattr_has_space_inline(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tunsigned int xattrsize = OCFS2_SB(inode->i_sb)->s_xattr_inline_size;\n\tint free;\n\n\tif (xattrsize < OCFS2_MIN_XATTR_INLINE_SIZE)\n\t\treturn 0;\n\n\tif (oi->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tstruct ocfs2_inline_data *idata = &di->id2.i_data;\n\t\tfree = le16_to_cpu(idata->id_count) - le64_to_cpu(di->i_size);\n\t} else if (ocfs2_inode_is_fast_symlink(inode)) {\n\t\tfree = ocfs2_fast_symlink_chars(inode->i_sb) -\n\t\t\tle64_to_cpu(di->i_size);\n\t} else {\n\t\tstruct ocfs2_extent_list *el = &di->id2.i_list;\n\t\tfree = (le16_to_cpu(el->l_count) -\n\t\t\tle16_to_cpu(el->l_next_free_rec)) *\n\t\t\tsizeof(struct ocfs2_extent_rec);\n\t}\n\tif (free >= xattrsize)\n\t\treturn 1;\n\n\treturn 0;\n}\n\n \nstatic int ocfs2_xattr_ibody_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)xs->inode_bh->b_data;\n\tint ret;\n\tint has_space = 0;\n\n\tif (inode->i_sb->s_blocksize == OCFS2_MIN_BLOCKSIZE)\n\t\treturn 0;\n\n\tif (!(oi->ip_dyn_features & OCFS2_INLINE_XATTR_FL)) {\n\t\tdown_read(&oi->ip_alloc_sem);\n\t\thas_space = ocfs2_xattr_has_space_inline(inode, di);\n\t\tup_read(&oi->ip_alloc_sem);\n\t\tif (!has_space)\n\t\t\treturn 0;\n\t}\n\n\txs->xattr_bh = xs->inode_bh;\n\txs->end = (void *)di + inode->i_sb->s_blocksize;\n\tif (oi->ip_dyn_features & OCFS2_INLINE_XATTR_FL)\n\t\txs->header = (struct ocfs2_xattr_header *)\n\t\t\t(xs->end - le16_to_cpu(di->i_xattr_inline_size));\n\telse\n\t\txs->header = (struct ocfs2_xattr_header *)\n\t\t\t(xs->end - OCFS2_SB(inode->i_sb)->s_xattr_inline_size);\n\txs->base = (void *)xs->header;\n\txs->here = xs->header->xh_entries;\n\n\t \n\tif (oi->ip_dyn_features & OCFS2_INLINE_XATTR_FL) {\n\t\tret = ocfs2_xattr_find_entry(name_index, name, xs);\n\t\tif (ret && ret != -ENODATA)\n\t\t\treturn ret;\n\t\txs->not_found = ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ocfs2_xattr_ibody_init(struct inode *inode,\n\t\t\t\t  struct buffer_head *di_bh,\n\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tunsigned int xattrsize = osb->s_xattr_inline_size;\n\n\tif (!ocfs2_xattr_has_space_inline(inode, di)) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(ctxt->handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t \n\tif (oi->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tstruct ocfs2_inline_data *idata = &di->id2.i_data;\n\t\tle16_add_cpu(&idata->id_count, -xattrsize);\n\t} else if (!(ocfs2_inode_is_fast_symlink(inode))) {\n\t\tstruct ocfs2_extent_list *el = &di->id2.i_list;\n\t\tle16_add_cpu(&el->l_count, -(xattrsize /\n\t\t\t\t\t     sizeof(struct ocfs2_extent_rec)));\n\t}\n\tdi->i_xattr_inline_size = cpu_to_le16(xattrsize);\n\n\tspin_lock(&oi->ip_lock);\n\toi->ip_dyn_features |= OCFS2_INLINE_XATTR_FL|OCFS2_HAS_XATTR_FL;\n\tdi->i_dyn_features = cpu_to_le16(oi->ip_dyn_features);\n\tspin_unlock(&oi->ip_lock);\n\n\tocfs2_journal_dirty(ctxt->handle, di_bh);\n\nout:\n\treturn ret;\n}\n\n \nstatic int ocfs2_xattr_ibody_set(struct inode *inode,\n\t\t\t\t struct ocfs2_xattr_info *xi,\n\t\t\t\t struct ocfs2_xattr_search *xs,\n\t\t\t\t struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_xa_loc loc;\n\n\tif (inode->i_sb->s_blocksize == OCFS2_MIN_BLOCKSIZE)\n\t\treturn -ENOSPC;\n\n\tdown_write(&oi->ip_alloc_sem);\n\tif (!(oi->ip_dyn_features & OCFS2_INLINE_XATTR_FL)) {\n\t\tret = ocfs2_xattr_ibody_init(inode, xs->inode_bh, ctxt);\n\t\tif (ret) {\n\t\t\tif (ret != -ENOSPC)\n\t\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tocfs2_init_dinode_xa_loc(&loc, inode, xs->inode_bh,\n\t\t\t\t xs->not_found ? NULL : xs->here);\n\tret = ocfs2_xa_set(&loc, xi, ctxt);\n\tif (ret) {\n\t\tif (ret != -ENOSPC)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\txs->here = loc.xl_entry;\n\nout:\n\tup_write(&oi->ip_alloc_sem);\n\n\treturn ret;\n}\n\n \nstatic int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs)\n{\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)xs->inode_bh->b_data;\n\tstruct buffer_head *blk_bh = NULL;\n\tstruct ocfs2_xattr_block *xb;\n\tint ret = 0;\n\n\tif (!di->i_xattr_loc)\n\t\treturn ret;\n\n\tret = ocfs2_read_xattr_block(inode, le64_to_cpu(di->i_xattr_loc),\n\t\t\t\t     &blk_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\txs->xattr_bh = blk_bh;\n\txb = (struct ocfs2_xattr_block *)blk_bh->b_data;\n\n\tif (!(le16_to_cpu(xb->xb_flags) & OCFS2_XATTR_INDEXED)) {\n\t\txs->header = &xb->xb_attrs.xb_header;\n\t\txs->base = (void *)xs->header;\n\t\txs->end = (void *)(blk_bh->b_data) + blk_bh->b_size;\n\t\txs->here = xs->header->xh_entries;\n\n\t\tret = ocfs2_xattr_find_entry(name_index, name, xs);\n\t} else\n\t\tret = ocfs2_xattr_index_block_find(inode, blk_bh,\n\t\t\t\t\t\t   name_index,\n\t\t\t\t\t\t   name, xs);\n\n\tif (ret && ret != -ENODATA) {\n\t\txs->xattr_bh = NULL;\n\t\tgoto cleanup;\n\t}\n\txs->not_found = ret;\n\treturn 0;\ncleanup:\n\tbrelse(blk_bh);\n\n\treturn ret;\n}\n\nstatic int ocfs2_create_xattr_block(struct inode *inode,\n\t\t\t\t    struct buffer_head *inode_bh,\n\t\t\t\t    struct ocfs2_xattr_set_ctxt *ctxt,\n\t\t\t\t    int indexed,\n\t\t\t\t    struct buffer_head **ret_bh)\n{\n\tint ret;\n\tu16 suballoc_bit_start;\n\tu32 num_got;\n\tu64 suballoc_loc, first_blkno;\n\tstruct ocfs2_dinode *di =  (struct ocfs2_dinode *)inode_bh->b_data;\n\tstruct buffer_head *new_bh = NULL;\n\tstruct ocfs2_xattr_block *xblk;\n\n\tret = ocfs2_journal_access_di(ctxt->handle, INODE_CACHE(inode),\n\t\t\t\t      inode_bh, OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto end;\n\t}\n\n\tret = ocfs2_claim_metadata(ctxt->handle, ctxt->meta_ac, 1,\n\t\t\t\t   &suballoc_loc, &suballoc_bit_start,\n\t\t\t\t   &num_got, &first_blkno);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto end;\n\t}\n\n\tnew_bh = sb_getblk(inode->i_sb, first_blkno);\n\tif (!new_bh) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto end;\n\t}\n\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(inode), new_bh);\n\n\tret = ocfs2_journal_access_xb(ctxt->handle, INODE_CACHE(inode),\n\t\t\t\t      new_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto end;\n\t}\n\n\t \n\txblk = (struct ocfs2_xattr_block *)new_bh->b_data;\n\tmemset(xblk, 0, inode->i_sb->s_blocksize);\n\tstrcpy((void *)xblk, OCFS2_XATTR_BLOCK_SIGNATURE);\n\txblk->xb_suballoc_slot = cpu_to_le16(ctxt->meta_ac->ac_alloc_slot);\n\txblk->xb_suballoc_loc = cpu_to_le64(suballoc_loc);\n\txblk->xb_suballoc_bit = cpu_to_le16(suballoc_bit_start);\n\txblk->xb_fs_generation =\n\t\tcpu_to_le32(OCFS2_SB(inode->i_sb)->fs_generation);\n\txblk->xb_blkno = cpu_to_le64(first_blkno);\n\tif (indexed) {\n\t\tstruct ocfs2_xattr_tree_root *xr = &xblk->xb_attrs.xb_root;\n\t\txr->xt_clusters = cpu_to_le32(1);\n\t\txr->xt_last_eb_blk = 0;\n\t\txr->xt_list.l_tree_depth = 0;\n\t\txr->xt_list.l_count = cpu_to_le16(\n\t\t\t\t\tocfs2_xattr_recs_per_xb(inode->i_sb));\n\t\txr->xt_list.l_next_free_rec = cpu_to_le16(1);\n\t\txblk->xb_flags = cpu_to_le16(OCFS2_XATTR_INDEXED);\n\t}\n\tocfs2_journal_dirty(ctxt->handle, new_bh);\n\n\t \n\tdi->i_xattr_loc = cpu_to_le64(first_blkno);\n\n\tspin_lock(&OCFS2_I(inode)->ip_lock);\n\tOCFS2_I(inode)->ip_dyn_features |= OCFS2_HAS_XATTR_FL;\n\tdi->i_dyn_features = cpu_to_le16(OCFS2_I(inode)->ip_dyn_features);\n\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n\n\tocfs2_journal_dirty(ctxt->handle, inode_bh);\n\n\t*ret_bh = new_bh;\n\tnew_bh = NULL;\n\nend:\n\tbrelse(new_bh);\n\treturn ret;\n}\n\n \nstatic int ocfs2_xattr_block_set(struct inode *inode,\n\t\t\t\t struct ocfs2_xattr_info *xi,\n\t\t\t\t struct ocfs2_xattr_search *xs,\n\t\t\t\t struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tstruct buffer_head *new_bh = NULL;\n\tstruct ocfs2_xattr_block *xblk = NULL;\n\tint ret;\n\tstruct ocfs2_xa_loc loc;\n\n\tif (!xs->xattr_bh) {\n\t\tret = ocfs2_create_xattr_block(inode, xs->inode_bh, ctxt,\n\t\t\t\t\t       0, &new_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto end;\n\t\t}\n\n\t\txs->xattr_bh = new_bh;\n\t\txblk = (struct ocfs2_xattr_block *)xs->xattr_bh->b_data;\n\t\txs->header = &xblk->xb_attrs.xb_header;\n\t\txs->base = (void *)xs->header;\n\t\txs->end = (void *)xblk + inode->i_sb->s_blocksize;\n\t\txs->here = xs->header->xh_entries;\n\t} else\n\t\txblk = (struct ocfs2_xattr_block *)xs->xattr_bh->b_data;\n\n\tif (!(le16_to_cpu(xblk->xb_flags) & OCFS2_XATTR_INDEXED)) {\n\t\tocfs2_init_xattr_block_xa_loc(&loc, inode, xs->xattr_bh,\n\t\t\t\t\t      xs->not_found ? NULL : xs->here);\n\n\t\tret = ocfs2_xa_set(&loc, xi, ctxt);\n\t\tif (!ret)\n\t\t\txs->here = loc.xl_entry;\n\t\telse if ((ret != -ENOSPC) || ctxt->set_abort)\n\t\t\tgoto end;\n\t\telse {\n\t\t\tret = ocfs2_xattr_create_index_block(inode, xs, ctxt);\n\t\t\tif (ret)\n\t\t\t\tgoto end;\n\t\t}\n\t}\n\n\tif (le16_to_cpu(xblk->xb_flags) & OCFS2_XATTR_INDEXED)\n\t\tret = ocfs2_xattr_set_entry_index_block(inode, xi, xs, ctxt);\n\nend:\n\treturn ret;\n}\n\n \nstatic int ocfs2_xattr_can_be_in_inode(struct inode *inode,\n\t\t\t\t       struct ocfs2_xattr_info *xi,\n\t\t\t\t       struct ocfs2_xattr_search *xs)\n{\n\tstruct ocfs2_xattr_entry *last;\n\tint free, i;\n\tsize_t min_offs = xs->end - xs->base;\n\n\tif (!xs->header)\n\t\treturn 0;\n\n\tlast = xs->header->xh_entries;\n\n\tfor (i = 0; i < le16_to_cpu(xs->header->xh_count); i++) {\n\t\tsize_t offs = le16_to_cpu(last->xe_name_offset);\n\t\tif (offs < min_offs)\n\t\t\tmin_offs = offs;\n\t\tlast += 1;\n\t}\n\n\tfree = min_offs - ((void *)last - xs->base) - OCFS2_XATTR_HEADER_GAP;\n\tif (free < 0)\n\t\treturn 0;\n\n\tBUG_ON(!xs->not_found);\n\n\tif (free >= (sizeof(struct ocfs2_xattr_entry) + namevalue_size_xi(xi)))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int ocfs2_calc_xattr_set_need(struct inode *inode,\n\t\t\t\t     struct ocfs2_dinode *di,\n\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t     struct ocfs2_xattr_search *xis,\n\t\t\t\t     struct ocfs2_xattr_search *xbs,\n\t\t\t\t     int *clusters_need,\n\t\t\t\t     int *meta_need,\n\t\t\t\t     int *credits_need)\n{\n\tint ret = 0, old_in_xb = 0;\n\tint clusters_add = 0, meta_add = 0, credits = 0;\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_xattr_block *xb = NULL;\n\tstruct ocfs2_xattr_entry *xe = NULL;\n\tstruct ocfs2_xattr_value_root *xv = NULL;\n\tchar *base = NULL;\n\tint name_offset, name_len = 0;\n\tu32 new_clusters = ocfs2_clusters_for_bytes(inode->i_sb,\n\t\t\t\t\t\t    xi->xi_value_len);\n\tu64 value_size;\n\n\t \n\tif (xi->xi_value_len > OCFS2_XATTR_INLINE_SIZE)\n\t\tcredits += new_clusters *\n\t\t\t   ocfs2_clusters_to_blocks(inode->i_sb, 1);\n\n\tif (xis->not_found && xbs->not_found) {\n\t\tcredits += ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\n\t\tif (xi->xi_value_len > OCFS2_XATTR_INLINE_SIZE) {\n\t\t\tclusters_add += new_clusters;\n\t\t\tcredits += ocfs2_calc_extend_credits(inode->i_sb,\n\t\t\t\t\t\t\t&def_xv.xv.xr_list);\n\t\t}\n\n\t\tgoto meta_guess;\n\t}\n\n\tif (!xis->not_found) {\n\t\txe = xis->here;\n\t\tname_offset = le16_to_cpu(xe->xe_name_offset);\n\t\tname_len = OCFS2_XATTR_SIZE(xe->xe_name_len);\n\t\tbase = xis->base;\n\t\tcredits += OCFS2_INODE_UPDATE_CREDITS;\n\t} else {\n\t\tint i, block_off = 0;\n\t\txb = (struct ocfs2_xattr_block *)xbs->xattr_bh->b_data;\n\t\txe = xbs->here;\n\t\tname_offset = le16_to_cpu(xe->xe_name_offset);\n\t\tname_len = OCFS2_XATTR_SIZE(xe->xe_name_len);\n\t\ti = xbs->here - xbs->header->xh_entries;\n\t\told_in_xb = 1;\n\n\t\tif (le16_to_cpu(xb->xb_flags) & OCFS2_XATTR_INDEXED) {\n\t\t\tret = ocfs2_xattr_bucket_get_name_value(inode->i_sb,\n\t\t\t\t\t\t\tbucket_xh(xbs->bucket),\n\t\t\t\t\t\t\ti, &block_off,\n\t\t\t\t\t\t\t&name_offset);\n\t\t\tbase = bucket_block(xbs->bucket, block_off);\n\t\t\tcredits += ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\t\t} else {\n\t\t\tbase = xbs->base;\n\t\t\tcredits += OCFS2_XATTR_BLOCK_UPDATE_CREDITS;\n\t\t}\n\t}\n\n\t \n\tif (!xi->xi_value) {\n\t\tif (!ocfs2_xattr_is_local(xe))\n\t\t\tcredits += ocfs2_remove_extent_credits(inode->i_sb);\n\n\t\tgoto out;\n\t}\n\n\t \n\tvalue_size = le64_to_cpu(xe->xe_value_size);\n\n\tif (old_in_xb) {\n\t\t \n\t\tif (ocfs2_xattr_can_be_in_inode(inode, xi, xis)) {\n\t\t\tclusters_add += new_clusters;\n\t\t\tcredits += ocfs2_remove_extent_credits(inode->i_sb) +\n\t\t\t\t    OCFS2_INODE_UPDATE_CREDITS;\n\t\t\tif (!ocfs2_xattr_is_local(xe))\n\t\t\t\tcredits += ocfs2_calc_extend_credits(\n\t\t\t\t\t\t\tinode->i_sb,\n\t\t\t\t\t\t\t&def_xv.xv.xr_list);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (xi->xi_value_len > OCFS2_XATTR_INLINE_SIZE) {\n\t\t \n\t\tu32 old_clusters = 0;\n\n\t\tif (!ocfs2_xattr_is_local(xe)) {\n\t\t\told_clusters =\tocfs2_clusters_for_bytes(inode->i_sb,\n\t\t\t\t\t\t\t\t value_size);\n\t\t\txv = (struct ocfs2_xattr_value_root *)\n\t\t\t     (base + name_offset + name_len);\n\t\t\tvalue_size = OCFS2_XATTR_ROOT_SIZE;\n\t\t} else\n\t\t\txv = &def_xv.xv;\n\n\t\tif (old_clusters >= new_clusters) {\n\t\t\tcredits += ocfs2_remove_extent_credits(inode->i_sb);\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tmeta_add += ocfs2_extend_meta_needed(&xv->xr_list);\n\t\t\tclusters_add += new_clusters - old_clusters;\n\t\t\tcredits += ocfs2_calc_extend_credits(inode->i_sb,\n\t\t\t\t\t\t\t     &xv->xr_list);\n\t\t\tif (value_size >= OCFS2_XATTR_ROOT_SIZE)\n\t\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t \n\t\tif ((ocfs2_xattr_is_local(xe) &&\n\t\t     (value_size >= xi->xi_value_len)) ||\n\t\t    (!ocfs2_xattr_is_local(xe) &&\n\t\t     OCFS2_XATTR_ROOT_SIZE >= xi->xi_value_len))\n\t\t\tgoto out;\n\t}\n\nmeta_guess:\n\t \n\tif (di->i_xattr_loc) {\n\t\tif (!xbs->xattr_bh) {\n\t\t\tret = ocfs2_read_xattr_block(inode,\n\t\t\t\t\t\t     le64_to_cpu(di->i_xattr_loc),\n\t\t\t\t\t\t     &bh);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\txb = (struct ocfs2_xattr_block *)bh->b_data;\n\t\t} else\n\t\t\txb = (struct ocfs2_xattr_block *)xbs->xattr_bh->b_data;\n\n\t\t \n\t\tif (le16_to_cpu(xb->xb_flags) & OCFS2_XATTR_INDEXED) {\n\t\t\tstruct ocfs2_extent_list *el =\n\t\t\t\t &xb->xb_attrs.xb_root.xt_list;\n\t\t\tmeta_add += ocfs2_extend_meta_needed(el);\n\t\t\tcredits += ocfs2_calc_extend_credits(inode->i_sb,\n\t\t\t\t\t\t\t     el);\n\t\t} else\n\t\t\tcredits += OCFS2_SUBALLOC_ALLOC + 1;\n\n\t\t \n\t\tclusters_add += 1;\n\t\tcredits += ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\t\tif (OCFS2_XATTR_BUCKET_SIZE ==\n\t\t\tOCFS2_SB(inode->i_sb)->s_clustersize) {\n\t\t\tcredits += ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\t\t\tclusters_add += 1;\n\t\t}\n\t} else {\n\t\tcredits += OCFS2_XATTR_BLOCK_CREATE_CREDITS;\n\t\tif (xi->xi_value_len > OCFS2_XATTR_INLINE_SIZE) {\n\t\t\tstruct ocfs2_extent_list *el = &def_xv.xv.xr_list;\n\t\t\tmeta_add += ocfs2_extend_meta_needed(el);\n\t\t\tcredits += ocfs2_calc_extend_credits(inode->i_sb,\n\t\t\t\t\t\t\t     el);\n\t\t} else {\n\t\t\tmeta_add += 1;\n\t\t}\n\t}\nout:\n\tif (clusters_need)\n\t\t*clusters_need = clusters_add;\n\tif (meta_need)\n\t\t*meta_need = meta_add;\n\tif (credits_need)\n\t\t*credits_need = credits;\n\tbrelse(bh);\n\treturn ret;\n}\n\nstatic int ocfs2_init_xattr_set_ctxt(struct inode *inode,\n\t\t\t\t     struct ocfs2_dinode *di,\n\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t     struct ocfs2_xattr_search *xis,\n\t\t\t\t     struct ocfs2_xattr_search *xbs,\n\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt,\n\t\t\t\t     int extra_meta,\n\t\t\t\t     int *credits)\n{\n\tint clusters_add, meta_add, ret;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmemset(ctxt, 0, sizeof(struct ocfs2_xattr_set_ctxt));\n\n\tocfs2_init_dealloc_ctxt(&ctxt->dealloc);\n\n\tret = ocfs2_calc_xattr_set_need(inode, di, xi, xis, xbs,\n\t\t\t\t\t&clusters_add, &meta_add, credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tmeta_add += extra_meta;\n\ttrace_ocfs2_init_xattr_set_ctxt(xi->xi_name, meta_add,\n\t\t\t\t\tclusters_add, *credits);\n\n\tif (meta_add) {\n\t\tret = ocfs2_reserve_new_metadata_blocks(osb, meta_add,\n\t\t\t\t\t\t\t&ctxt->meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (clusters_add) {\n\t\tret = ocfs2_reserve_clusters(osb, clusters_add, &ctxt->data_ac);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\nout:\n\tif (ret) {\n\t\tif (ctxt->meta_ac) {\n\t\t\tocfs2_free_alloc_context(ctxt->meta_ac);\n\t\t\tctxt->meta_ac = NULL;\n\t\t}\n\n\t\t \n\t}\n\n\treturn ret;\n}\n\nstatic int __ocfs2_xattr_set_handle(struct inode *inode,\n\t\t\t\t    struct ocfs2_dinode *di,\n\t\t\t\t    struct ocfs2_xattr_info *xi,\n\t\t\t\t    struct ocfs2_xattr_search *xis,\n\t\t\t\t    struct ocfs2_xattr_search *xbs,\n\t\t\t\t    struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret = 0, credits, old_found;\n\n\tif (!xi->xi_value) {\n\t\t \n\t\tif (!xis->not_found)\n\t\t\tret = ocfs2_xattr_ibody_set(inode, xi, xis, ctxt);\n\t\telse if (!xbs->not_found)\n\t\t\tret = ocfs2_xattr_block_set(inode, xi, xbs, ctxt);\n\t} else {\n\t\t \n\t\tret = ocfs2_xattr_ibody_set(inode, xi, xis, ctxt);\n\t\tif (!ret && !xbs->not_found) {\n\t\t\t \n\t\t\txi->xi_value = NULL;\n\t\t\txi->xi_value_len = 0;\n\n\t\t\told_found = xis->not_found;\n\t\t\txis->not_found = -ENODATA;\n\t\t\tret = ocfs2_calc_xattr_set_need(inode,\n\t\t\t\t\t\t\tdi,\n\t\t\t\t\t\t\txi,\n\t\t\t\t\t\t\txis,\n\t\t\t\t\t\t\txbs,\n\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t&credits);\n\t\t\txis->not_found = old_found;\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = ocfs2_extend_trans(ctxt->handle, credits);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tret = ocfs2_xattr_block_set(inode, xi, xbs, ctxt);\n\t\t} else if ((ret == -ENOSPC) && !ctxt->set_abort) {\n\t\t\tif (di->i_xattr_loc && !xbs->xattr_bh) {\n\t\t\t\tret = ocfs2_xattr_block_find(inode,\n\t\t\t\t\t\t\t     xi->xi_name_index,\n\t\t\t\t\t\t\t     xi->xi_name, xbs);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\n\t\t\t\told_found = xis->not_found;\n\t\t\t\txis->not_found = -ENODATA;\n\t\t\t\tret = ocfs2_calc_xattr_set_need(inode,\n\t\t\t\t\t\t\t\tdi,\n\t\t\t\t\t\t\t\txi,\n\t\t\t\t\t\t\t\txis,\n\t\t\t\t\t\t\t\txbs,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\t&credits);\n\t\t\t\txis->not_found = old_found;\n\t\t\t\tif (ret) {\n\t\t\t\t\tmlog_errno(ret);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tret = ocfs2_extend_trans(ctxt->handle, credits);\n\t\t\t\tif (ret) {\n\t\t\t\t\tmlog_errno(ret);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\t \n\t\t\tret = ocfs2_xattr_block_set(inode, xi, xbs, ctxt);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tif (!xis->not_found) {\n\t\t\t\t \n\t\t\t\txi->xi_value = NULL;\n\t\t\t\txi->xi_value_len = 0;\n\t\t\t\txbs->not_found = -ENODATA;\n\t\t\t\tret = ocfs2_calc_xattr_set_need(inode,\n\t\t\t\t\t\t\t\tdi,\n\t\t\t\t\t\t\t\txi,\n\t\t\t\t\t\t\t\txis,\n\t\t\t\t\t\t\t\txbs,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\t&credits);\n\t\t\t\tif (ret) {\n\t\t\t\t\tmlog_errno(ret);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tret = ocfs2_extend_trans(ctxt->handle, credits);\n\t\t\t\tif (ret) {\n\t\t\t\t\tmlog_errno(ret);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tret = ocfs2_xattr_ibody_set(inode, xi,\n\t\t\t\t\t\t\t    xis, ctxt);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!ret) {\n\t\t \n\t\tret = ocfs2_journal_access_di(ctxt->handle, INODE_CACHE(inode),\n\t\t\t\t\t      xis->inode_bh,\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tinode_set_ctime_current(inode);\n\t\tdi->i_ctime = cpu_to_le64(inode_get_ctime(inode).tv_sec);\n\t\tdi->i_ctime_nsec = cpu_to_le32(inode_get_ctime(inode).tv_nsec);\n\t\tocfs2_journal_dirty(ctxt->handle, xis->inode_bh);\n\t}\nout:\n\treturn ret;\n}\n\n \nint ocfs2_xattr_set_handle(handle_t *handle,\n\t\t\t   struct inode *inode,\n\t\t\t   struct buffer_head *di_bh,\n\t\t\t   int name_index,\n\t\t\t   const char *name,\n\t\t\t   const void *value,\n\t\t\t   size_t value_len,\n\t\t\t   int flags,\n\t\t\t   struct ocfs2_alloc_context *meta_ac,\n\t\t\t   struct ocfs2_alloc_context *data_ac)\n{\n\tstruct ocfs2_dinode *di;\n\tint ret;\n\n\tstruct ocfs2_xattr_info xi = {\n\t\t.xi_name_index = name_index,\n\t\t.xi_name = name,\n\t\t.xi_name_len = strlen(name),\n\t\t.xi_value = value,\n\t\t.xi_value_len = value_len,\n\t};\n\n\tstruct ocfs2_xattr_search xis = {\n\t\t.not_found = -ENODATA,\n\t};\n\n\tstruct ocfs2_xattr_search xbs = {\n\t\t.not_found = -ENODATA,\n\t};\n\n\tstruct ocfs2_xattr_set_ctxt ctxt = {\n\t\t.handle = handle,\n\t\t.meta_ac = meta_ac,\n\t\t.data_ac = data_ac,\n\t};\n\n\tif (!ocfs2_supports_xattr(OCFS2_SB(inode->i_sb)))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (inode->i_sb->s_blocksize == OCFS2_MIN_BLOCKSIZE) {\n\t\txbs.bucket = ocfs2_xattr_bucket_new(inode);\n\t\tif (!xbs.bucket) {\n\t\t\tmlog_errno(-ENOMEM);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\txis.inode_bh = xbs.inode_bh = di_bh;\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tdown_write(&OCFS2_I(inode)->ip_xattr_sem);\n\n\tret = ocfs2_xattr_ibody_find(inode, name_index, name, &xis);\n\tif (ret)\n\t\tgoto cleanup;\n\tif (xis.not_found) {\n\t\tret = ocfs2_xattr_block_find(inode, name_index, name, &xbs);\n\t\tif (ret)\n\t\t\tgoto cleanup;\n\t}\n\n\tret = __ocfs2_xattr_set_handle(inode, di, &xi, &xis, &xbs, &ctxt);\n\ncleanup:\n\tup_write(&OCFS2_I(inode)->ip_xattr_sem);\n\tbrelse(xbs.xattr_bh);\n\tocfs2_xattr_bucket_free(xbs.bucket);\n\n\treturn ret;\n}\n\n \nint ocfs2_xattr_set(struct inode *inode,\n\t\t    int name_index,\n\t\t    const char *name,\n\t\t    const void *value,\n\t\t    size_t value_len,\n\t\t    int flags)\n{\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tint ret, credits, had_lock, ref_meta = 0, ref_credits = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct ocfs2_xattr_set_ctxt ctxt = { NULL, NULL, NULL, };\n\tstruct ocfs2_refcount_tree *ref_tree = NULL;\n\tstruct ocfs2_lock_holder oh;\n\n\tstruct ocfs2_xattr_info xi = {\n\t\t.xi_name_index = name_index,\n\t\t.xi_name = name,\n\t\t.xi_name_len = strlen(name),\n\t\t.xi_value = value,\n\t\t.xi_value_len = value_len,\n\t};\n\n\tstruct ocfs2_xattr_search xis = {\n\t\t.not_found = -ENODATA,\n\t};\n\n\tstruct ocfs2_xattr_search xbs = {\n\t\t.not_found = -ENODATA,\n\t};\n\n\tif (!ocfs2_supports_xattr(osb))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\txbs.bucket = ocfs2_xattr_bucket_new(inode);\n\tif (!xbs.bucket) {\n\t\tmlog_errno(-ENOMEM);\n\t\treturn -ENOMEM;\n\t}\n\n\thad_lock = ocfs2_inode_lock_tracker(inode, &di_bh, 1, &oh);\n\tif (had_lock < 0) {\n\t\tret = had_lock;\n\t\tmlog_errno(ret);\n\t\tgoto cleanup_nolock;\n\t}\n\txis.inode_bh = xbs.inode_bh = di_bh;\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tdown_write(&OCFS2_I(inode)->ip_xattr_sem);\n\t \n\tret = ocfs2_xattr_ibody_find(inode, name_index, name, &xis);\n\tif (ret)\n\t\tgoto cleanup;\n\tif (xis.not_found) {\n\t\tret = ocfs2_xattr_block_find(inode, name_index, name, &xbs);\n\t\tif (ret)\n\t\t\tgoto cleanup;\n\t}\n\n\tif (xis.not_found && xbs.not_found) {\n\t\tret = -ENODATA;\n\t\tif (flags & XATTR_REPLACE)\n\t\t\tgoto cleanup;\n\t\tret = 0;\n\t\tif (!value)\n\t\t\tgoto cleanup;\n\t} else {\n\t\tret = -EEXIST;\n\t\tif (flags & XATTR_CREATE)\n\t\t\tgoto cleanup;\n\t}\n\n\t \n\tif (ocfs2_is_refcount_inode(inode) &&\n\t    (!xis.not_found || !xbs.not_found)) {\n\t\tret = ocfs2_prepare_refcount_xattr(inode, di, &xi,\n\t\t\t\t\t\t   &xis, &xbs, &ref_tree,\n\t\t\t\t\t\t   &ref_meta, &ref_credits);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tinode_lock(tl_inode);\n\n\tif (ocfs2_truncate_log_needs_flush(osb)) {\n\t\tret = __ocfs2_flush_truncate_log(osb);\n\t\tif (ret < 0) {\n\t\t\tinode_unlock(tl_inode);\n\t\t\tmlog_errno(ret);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\tinode_unlock(tl_inode);\n\n\tret = ocfs2_init_xattr_set_ctxt(inode, di, &xi, &xis,\n\t\t\t\t\t&xbs, &ctxt, ref_meta, &credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto cleanup;\n\t}\n\n\t \n\tcredits += OCFS2_INODE_UPDATE_CREDITS;\n\tctxt.handle = ocfs2_start_trans(osb, credits + ref_credits);\n\tif (IS_ERR(ctxt.handle)) {\n\t\tret = PTR_ERR(ctxt.handle);\n\t\tmlog_errno(ret);\n\t\tgoto out_free_ac;\n\t}\n\n\tret = __ocfs2_xattr_set_handle(inode, di, &xi, &xis, &xbs, &ctxt);\n\tocfs2_update_inode_fsync_trans(ctxt.handle, inode, 0);\n\n\tocfs2_commit_trans(osb, ctxt.handle);\n\nout_free_ac:\n\tif (ctxt.data_ac)\n\t\tocfs2_free_alloc_context(ctxt.data_ac);\n\tif (ctxt.meta_ac)\n\t\tocfs2_free_alloc_context(ctxt.meta_ac);\n\tif (ocfs2_dealloc_has_cluster(&ctxt.dealloc))\n\t\tocfs2_schedule_truncate_log_flush(osb, 1);\n\tocfs2_run_deallocs(osb, &ctxt.dealloc);\n\ncleanup:\n\tif (ref_tree)\n\t\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\tup_write(&OCFS2_I(inode)->ip_xattr_sem);\n\tif (!value && !ret) {\n\t\tret = ocfs2_try_remove_refcount_tree(inode, di_bh);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\tocfs2_inode_unlock_tracker(inode, 1, &oh, had_lock);\ncleanup_nolock:\n\tbrelse(di_bh);\n\tbrelse(xbs.xattr_bh);\n\tocfs2_xattr_bucket_free(xbs.bucket);\n\n\treturn ret;\n}\n\n \nstatic int ocfs2_xattr_get_rec(struct inode *inode,\n\t\t\t       u32 name_hash,\n\t\t\t       u64 *p_blkno,\n\t\t\t       u32 *e_cpos,\n\t\t\t       u32 *num_clusters,\n\t\t\t       struct ocfs2_extent_list *el)\n{\n\tint ret = 0, i;\n\tstruct buffer_head *eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_rec *rec = NULL;\n\tu64 e_blkno = 0;\n\n\tif (el->l_tree_depth) {\n\t\tret = ocfs2_find_leaf(INODE_CACHE(inode), el, name_hash,\n\t\t\t\t      &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tret = ocfs2_error(inode->i_sb,\n\t\t\t\t\t  \"Inode %lu has non zero tree depth in xattr tree block %llu\\n\",\n\t\t\t\t\t  inode->i_ino,\n\t\t\t\t\t  (unsigned long long)eb_bh->b_blocknr);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfor (i = le16_to_cpu(el->l_next_free_rec) - 1; i >= 0; i--) {\n\t\trec = &el->l_recs[i];\n\n\t\tif (le32_to_cpu(rec->e_cpos) <= name_hash) {\n\t\t\te_blkno = le64_to_cpu(rec->e_blkno);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!e_blkno) {\n\t\tret = ocfs2_error(inode->i_sb, \"Inode %lu has bad extent record (%u, %u, 0) in xattr\\n\",\n\t\t\t\t  inode->i_ino,\n\t\t\t\t  le32_to_cpu(rec->e_cpos),\n\t\t\t\t  ocfs2_rec_clusters(el, rec));\n\t\tgoto out;\n\t}\n\n\t*p_blkno = le64_to_cpu(rec->e_blkno);\n\t*num_clusters = le16_to_cpu(rec->e_leaf_clusters);\n\tif (e_cpos)\n\t\t*e_cpos = le32_to_cpu(rec->e_cpos);\nout:\n\tbrelse(eb_bh);\n\treturn ret;\n}\n\ntypedef int (xattr_bucket_func)(struct inode *inode,\n\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\tvoid *para);\n\nstatic int ocfs2_find_xe_in_bucket(struct inode *inode,\n\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t   int name_index,\n\t\t\t\t   const char *name,\n\t\t\t\t   u32 name_hash,\n\t\t\t\t   u16 *xe_index,\n\t\t\t\t   int *found)\n{\n\tint i, ret = 0, cmp = 1, block_off, new_offset;\n\tstruct ocfs2_xattr_header *xh = bucket_xh(bucket);\n\tsize_t name_len = strlen(name);\n\tstruct ocfs2_xattr_entry *xe = NULL;\n\tchar *xe_name;\n\n\t \n\tfor (i = 0; i < le16_to_cpu(xh->xh_count); i++) {\n\t\txe = &xh->xh_entries[i];\n\n\t\tif (name_hash > le32_to_cpu(xe->xe_name_hash))\n\t\t\tcontinue;\n\t\telse if (name_hash < le32_to_cpu(xe->xe_name_hash))\n\t\t\tbreak;\n\n\t\tcmp = name_index - ocfs2_xattr_get_type(xe);\n\t\tif (!cmp)\n\t\t\tcmp = name_len - xe->xe_name_len;\n\t\tif (cmp)\n\t\t\tcontinue;\n\n\t\tret = ocfs2_xattr_bucket_get_name_value(inode->i_sb,\n\t\t\t\t\t\t\txh,\n\t\t\t\t\t\t\ti,\n\t\t\t\t\t\t\t&block_off,\n\t\t\t\t\t\t\t&new_offset);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\n\t\txe_name = bucket_block(bucket, block_off) + new_offset;\n\t\tif (!memcmp(name, xe_name, name_len)) {\n\t\t\t*xe_index = i;\n\t\t\t*found = 1;\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n \nstatic int ocfs2_xattr_bucket_find(struct inode *inode,\n\t\t\t\t   int name_index,\n\t\t\t\t   const char *name,\n\t\t\t\t   u32 name_hash,\n\t\t\t\t   u64 p_blkno,\n\t\t\t\t   u32 first_hash,\n\t\t\t\t   u32 num_clusters,\n\t\t\t\t   struct ocfs2_xattr_search *xs)\n{\n\tint ret, found = 0;\n\tstruct ocfs2_xattr_header *xh = NULL;\n\tstruct ocfs2_xattr_entry *xe = NULL;\n\tu16 index = 0;\n\tu16 blk_per_bucket = ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\tint low_bucket = 0, bucket, high_bucket;\n\tstruct ocfs2_xattr_bucket *search;\n\tu64 blkno, lower_blkno = 0;\n\n\tsearch = ocfs2_xattr_bucket_new(inode);\n\tif (!search) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_xattr_bucket(search, p_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\txh = bucket_xh(search);\n\thigh_bucket = le16_to_cpu(xh->xh_num_buckets) - 1;\n\twhile (low_bucket <= high_bucket) {\n\t\tocfs2_xattr_bucket_relse(search);\n\n\t\tbucket = (low_bucket + high_bucket) / 2;\n\t\tblkno = p_blkno + bucket * blk_per_bucket;\n\t\tret = ocfs2_read_xattr_bucket(search, blkno);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\txh = bucket_xh(search);\n\t\txe = &xh->xh_entries[0];\n\t\tif (name_hash < le32_to_cpu(xe->xe_name_hash)) {\n\t\t\thigh_bucket = bucket - 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (xh->xh_count)\n\t\t\txe = &xh->xh_entries[le16_to_cpu(xh->xh_count) - 1];\n\n\t\t \n\t\tlower_blkno = blkno;\n\n\t\tif (name_hash > le32_to_cpu(xe->xe_name_hash)) {\n\t\t\tlow_bucket = bucket + 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tret = ocfs2_find_xe_in_bucket(inode, search,\n\t\t\t\t\t      name_index, name, name_hash,\n\t\t\t\t\t      &index, &found);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\t}\n\n\t \n\tif (!lower_blkno)\n\t\tlower_blkno = p_blkno;\n\n\t \n\tret = ocfs2_read_xattr_bucket(xs->bucket, lower_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\txs->header = bucket_xh(xs->bucket);\n\txs->base = bucket_block(xs->bucket, 0);\n\txs->end = xs->base + inode->i_sb->s_blocksize;\n\n\tif (found) {\n\t\txs->here = &xs->header->xh_entries[index];\n\t\ttrace_ocfs2_xattr_bucket_find(OCFS2_I(inode)->ip_blkno,\n\t\t\tname, name_index, name_hash,\n\t\t\t(unsigned long long)bucket_blkno(xs->bucket),\n\t\t\tindex);\n\t} else\n\t\tret = -ENODATA;\n\nout:\n\tocfs2_xattr_bucket_free(search);\n\treturn ret;\n}\n\nstatic int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs)\n{\n\tint ret;\n\tstruct ocfs2_xattr_block *xb =\n\t\t\t(struct ocfs2_xattr_block *)root_bh->b_data;\n\tstruct ocfs2_xattr_tree_root *xb_root = &xb->xb_attrs.xb_root;\n\tstruct ocfs2_extent_list *el = &xb_root->xt_list;\n\tu64 p_blkno = 0;\n\tu32 first_hash, num_clusters = 0;\n\tu32 name_hash = ocfs2_xattr_name_hash(inode, name, strlen(name));\n\n\tif (le16_to_cpu(el->l_next_free_rec) == 0)\n\t\treturn -ENODATA;\n\n\ttrace_ocfs2_xattr_index_block_find(OCFS2_I(inode)->ip_blkno,\n\t\t\t\t\tname, name_index, name_hash,\n\t\t\t\t\t(unsigned long long)root_bh->b_blocknr,\n\t\t\t\t\t-1);\n\n\tret = ocfs2_xattr_get_rec(inode, name_hash, &p_blkno, &first_hash,\n\t\t\t\t  &num_clusters, el);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tBUG_ON(p_blkno == 0 || num_clusters == 0 || first_hash > name_hash);\n\n\ttrace_ocfs2_xattr_index_block_find_rec(OCFS2_I(inode)->ip_blkno,\n\t\t\t\t\tname, name_index, first_hash,\n\t\t\t\t\t(unsigned long long)p_blkno,\n\t\t\t\t\tnum_clusters);\n\n\tret = ocfs2_xattr_bucket_find(inode, name_index, name, name_hash,\n\t\t\t\t      p_blkno, first_hash, num_clusters, xs);\n\nout:\n\treturn ret;\n}\n\nstatic int ocfs2_iterate_xattr_buckets(struct inode *inode,\n\t\t\t\t       u64 blkno,\n\t\t\t\t       u32 clusters,\n\t\t\t\t       xattr_bucket_func *func,\n\t\t\t\t       void *para)\n{\n\tint i, ret = 0;\n\tu32 bpc = ocfs2_xattr_buckets_per_cluster(OCFS2_SB(inode->i_sb));\n\tu32 num_buckets = clusters * bpc;\n\tstruct ocfs2_xattr_bucket *bucket;\n\n\tbucket = ocfs2_xattr_bucket_new(inode);\n\tif (!bucket) {\n\t\tmlog_errno(-ENOMEM);\n\t\treturn -ENOMEM;\n\t}\n\n\ttrace_ocfs2_iterate_xattr_buckets(\n\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t(unsigned long long)blkno, clusters);\n\n\tfor (i = 0; i < num_buckets; i++, blkno += bucket->bu_blocks) {\n\t\tret = ocfs2_read_xattr_bucket(bucket, blkno);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (i == 0)\n\t\t\tnum_buckets = le16_to_cpu(bucket_xh(bucket)->xh_num_buckets);\n\n\t\ttrace_ocfs2_iterate_xattr_bucket((unsigned long long)blkno,\n\t\t     le32_to_cpu(bucket_xh(bucket)->xh_entries[0].xe_name_hash));\n\t\tif (func) {\n\t\t\tret = func(inode, bucket, para);\n\t\t\tif (ret && ret != -ERANGE)\n\t\t\t\tmlog_errno(ret);\n\t\t\t \n\t\t}\n\n\t\tocfs2_xattr_bucket_relse(bucket);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tocfs2_xattr_bucket_free(bucket);\n\treturn ret;\n}\n\nstruct ocfs2_xattr_tree_list {\n\tchar *buffer;\n\tsize_t buffer_size;\n\tsize_t result;\n};\n\nstatic int ocfs2_xattr_bucket_get_name_value(struct super_block *sb,\n\t\t\t\t\t     struct ocfs2_xattr_header *xh,\n\t\t\t\t\t     int index,\n\t\t\t\t\t     int *block_off,\n\t\t\t\t\t     int *new_offset)\n{\n\tu16 name_offset;\n\n\tif (index < 0 || index >= le16_to_cpu(xh->xh_count))\n\t\treturn -EINVAL;\n\n\tname_offset = le16_to_cpu(xh->xh_entries[index].xe_name_offset);\n\n\t*block_off = name_offset >> sb->s_blocksize_bits;\n\t*new_offset = name_offset % sb->s_blocksize;\n\n\treturn 0;\n}\n\nstatic int ocfs2_list_xattr_bucket(struct inode *inode,\n\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t   void *para)\n{\n\tint ret = 0, type;\n\tstruct ocfs2_xattr_tree_list *xl = (struct ocfs2_xattr_tree_list *)para;\n\tint i, block_off, new_offset;\n\tconst char *name;\n\n\tfor (i = 0 ; i < le16_to_cpu(bucket_xh(bucket)->xh_count); i++) {\n\t\tstruct ocfs2_xattr_entry *entry = &bucket_xh(bucket)->xh_entries[i];\n\t\ttype = ocfs2_xattr_get_type(entry);\n\n\t\tret = ocfs2_xattr_bucket_get_name_value(inode->i_sb,\n\t\t\t\t\t\t\tbucket_xh(bucket),\n\t\t\t\t\t\t\ti,\n\t\t\t\t\t\t\t&block_off,\n\t\t\t\t\t\t\t&new_offset);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tname = (const char *)bucket_block(bucket, block_off) +\n\t\t\tnew_offset;\n\t\tret = ocfs2_xattr_list_entry(inode->i_sb,\n\t\t\t\t\t     xl->buffer,\n\t\t\t\t\t     xl->buffer_size,\n\t\t\t\t\t     &xl->result,\n\t\t\t\t\t     type, name,\n\t\t\t\t\t     entry->xe_name_len);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *blk_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para)\n{\n\tstruct ocfs2_xattr_block *xb =\n\t\t\t(struct ocfs2_xattr_block *)blk_bh->b_data;\n\tstruct ocfs2_extent_list *el = &xb->xb_attrs.xb_root.xt_list;\n\tint ret = 0;\n\tu32 name_hash = UINT_MAX, e_cpos = 0, num_clusters = 0;\n\tu64 p_blkno = 0;\n\n\tif (!el->l_next_free_rec || !rec_func)\n\t\treturn 0;\n\n\twhile (name_hash > 0) {\n\t\tret = ocfs2_xattr_get_rec(inode, name_hash, &p_blkno,\n\t\t\t\t\t  &e_cpos, &num_clusters, el);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = rec_func(inode, blk_bh, p_blkno, e_cpos,\n\t\t\t       num_clusters, para);\n\t\tif (ret) {\n\t\t\tif (ret != -ERANGE)\n\t\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (e_cpos == 0)\n\t\t\tbreak;\n\n\t\tname_hash = e_cpos - 1;\n\t}\n\n\treturn ret;\n\n}\n\nstatic int ocfs2_list_xattr_tree_rec(struct inode *inode,\n\t\t\t\t     struct buffer_head *root_bh,\n\t\t\t\t     u64 blkno, u32 cpos, u32 len, void *para)\n{\n\treturn ocfs2_iterate_xattr_buckets(inode, blkno, len,\n\t\t\t\t\t   ocfs2_list_xattr_bucket, para);\n}\n\nstatic int ocfs2_xattr_tree_list_index_block(struct inode *inode,\n\t\t\t\t\t     struct buffer_head *blk_bh,\n\t\t\t\t\t     char *buffer,\n\t\t\t\t\t     size_t buffer_size)\n{\n\tint ret;\n\tstruct ocfs2_xattr_tree_list xl = {\n\t\t.buffer = buffer,\n\t\t.buffer_size = buffer_size,\n\t\t.result = 0,\n\t};\n\n\tret = ocfs2_iterate_xattr_index_block(inode, blk_bh,\n\t\t\t\t\t      ocfs2_list_xattr_tree_rec, &xl);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = xl.result;\nout:\n\treturn ret;\n}\n\nstatic int cmp_xe(const void *a, const void *b)\n{\n\tconst struct ocfs2_xattr_entry *l = a, *r = b;\n\tu32 l_hash = le32_to_cpu(l->xe_name_hash);\n\tu32 r_hash = le32_to_cpu(r->xe_name_hash);\n\n\tif (l_hash > r_hash)\n\t\treturn 1;\n\tif (l_hash < r_hash)\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic void swap_xe(void *a, void *b, int size)\n{\n\tstruct ocfs2_xattr_entry *l = a, *r = b, tmp;\n\n\ttmp = *l;\n\tmemcpy(l, r, sizeof(struct ocfs2_xattr_entry));\n\tmemcpy(r, &tmp, sizeof(struct ocfs2_xattr_entry));\n}\n\n \nstatic void ocfs2_cp_xattr_block_to_bucket(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *xb_bh,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket)\n{\n\tint i, blocksize = inode->i_sb->s_blocksize;\n\tint blks = ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\tu16 offset, size, off_change;\n\tstruct ocfs2_xattr_entry *xe;\n\tstruct ocfs2_xattr_block *xb =\n\t\t\t\t(struct ocfs2_xattr_block *)xb_bh->b_data;\n\tstruct ocfs2_xattr_header *xb_xh = &xb->xb_attrs.xb_header;\n\tstruct ocfs2_xattr_header *xh = bucket_xh(bucket);\n\tu16 count = le16_to_cpu(xb_xh->xh_count);\n\tchar *src = xb_bh->b_data;\n\tchar *target = bucket_block(bucket, blks - 1);\n\n\ttrace_ocfs2_cp_xattr_block_to_bucket_begin(\n\t\t\t\t(unsigned long long)xb_bh->b_blocknr,\n\t\t\t\t(unsigned long long)bucket_blkno(bucket));\n\n\tfor (i = 0; i < blks; i++)\n\t\tmemset(bucket_block(bucket, i), 0, blocksize);\n\n\t \n\toff_change = offsetof(struct ocfs2_xattr_block, xb_attrs.xb_header);\n\txe = &xb_xh->xh_entries[count - 1];\n\toffset = le16_to_cpu(xe->xe_name_offset) + off_change;\n\tsize = blocksize - offset;\n\n\t \n\tmemcpy(target + offset, src + offset, size);\n\n\t \n\txh->xh_count = xb_xh->xh_count;\n\txh->xh_num_buckets = cpu_to_le16(1);\n\txh->xh_name_value_len = cpu_to_le16(size);\n\txh->xh_free_start = cpu_to_le16(OCFS2_XATTR_BUCKET_SIZE - size);\n\n\t \n\ttarget = bucket_block(bucket, 0);\n\toffset = offsetof(struct ocfs2_xattr_header, xh_entries);\n\tsize = count * sizeof(struct ocfs2_xattr_entry);\n\tmemcpy(target + offset, (char *)xb_xh + offset, size);\n\n\t \n\toff_change = OCFS2_XATTR_BUCKET_SIZE - blocksize +\n\t\t offsetof(struct ocfs2_xattr_block, xb_attrs.xb_header);\n\tfor (i = 0; i < count; i++)\n\t\tle16_add_cpu(&xh->xh_entries[i].xe_name_offset, off_change);\n\n\ttrace_ocfs2_cp_xattr_block_to_bucket_end(offset, size, off_change);\n\n\tsort(target + offset, count, sizeof(struct ocfs2_xattr_entry),\n\t     cmp_xe, swap_xe);\n}\n\n \nstatic void ocfs2_xattr_update_xattr_search(struct inode *inode,\n\t\t\t\t\t    struct ocfs2_xattr_search *xs,\n\t\t\t\t\t    struct buffer_head *old_bh)\n{\n\tchar *buf = old_bh->b_data;\n\tstruct ocfs2_xattr_block *old_xb = (struct ocfs2_xattr_block *)buf;\n\tstruct ocfs2_xattr_header *old_xh = &old_xb->xb_attrs.xb_header;\n\tint i;\n\n\txs->header = bucket_xh(xs->bucket);\n\txs->base = bucket_block(xs->bucket, 0);\n\txs->end = xs->base + inode->i_sb->s_blocksize;\n\n\tif (xs->not_found)\n\t\treturn;\n\n\ti = xs->here - old_xh->xh_entries;\n\txs->here = &xs->header->xh_entries[i];\n}\n\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret;\n\tu32 bit_off, len;\n\tu64 blkno;\n\thandle_t *handle = ctxt->handle;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct buffer_head *xb_bh = xs->xattr_bh;\n\tstruct ocfs2_xattr_block *xb =\n\t\t\t(struct ocfs2_xattr_block *)xb_bh->b_data;\n\tstruct ocfs2_xattr_tree_root *xr;\n\tu16 xb_flags = le16_to_cpu(xb->xb_flags);\n\n\ttrace_ocfs2_xattr_create_index_block_begin(\n\t\t\t\t(unsigned long long)xb_bh->b_blocknr);\n\n\tBUG_ON(xb_flags & OCFS2_XATTR_INDEXED);\n\tBUG_ON(!xs->bucket);\n\n\t \n\tdown_write(&oi->ip_alloc_sem);\n\n\tret = ocfs2_journal_access_xb(handle, INODE_CACHE(inode), xb_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = __ocfs2_claim_clusters(handle, ctxt->data_ac,\n\t\t\t\t     1, 1, &bit_off, &len);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t \n\tblkno = ocfs2_clusters_to_blocks(inode->i_sb, bit_off);\n\n\ttrace_ocfs2_xattr_create_index_block((unsigned long long)blkno);\n\n\tret = ocfs2_init_xattr_bucket(xs->bucket, blkno, 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_xattr_bucket_journal_access(handle, xs->bucket,\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_CREATE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_cp_xattr_block_to_bucket(inode, xb_bh, xs->bucket);\n\tocfs2_xattr_bucket_journal_dirty(handle, xs->bucket);\n\n\tocfs2_xattr_update_xattr_search(inode, xs, xb_bh);\n\n\t \n\tmemset(&xb->xb_attrs, 0, inode->i_sb->s_blocksize -\n\t       offsetof(struct ocfs2_xattr_block, xb_attrs));\n\n\txr = &xb->xb_attrs.xb_root;\n\txr->xt_clusters = cpu_to_le32(1);\n\txr->xt_last_eb_blk = 0;\n\txr->xt_list.l_tree_depth = 0;\n\txr->xt_list.l_count = cpu_to_le16(ocfs2_xattr_recs_per_xb(inode->i_sb));\n\txr->xt_list.l_next_free_rec = cpu_to_le16(1);\n\n\txr->xt_list.l_recs[0].e_cpos = 0;\n\txr->xt_list.l_recs[0].e_blkno = cpu_to_le64(blkno);\n\txr->xt_list.l_recs[0].e_leaf_clusters = cpu_to_le16(1);\n\n\txb->xb_flags = cpu_to_le16(xb_flags | OCFS2_XATTR_INDEXED);\n\n\tocfs2_journal_dirty(handle, xb_bh);\n\nout:\n\tup_write(&oi->ip_alloc_sem);\n\n\treturn ret;\n}\n\nstatic int cmp_xe_offset(const void *a, const void *b)\n{\n\tconst struct ocfs2_xattr_entry *l = a, *r = b;\n\tu32 l_name_offset = le16_to_cpu(l->xe_name_offset);\n\tu32 r_name_offset = le16_to_cpu(r->xe_name_offset);\n\n\tif (l_name_offset < r_name_offset)\n\t\treturn 1;\n\tif (l_name_offset > r_name_offset)\n\t\treturn -1;\n\treturn 0;\n}\n\n \nstatic int ocfs2_defrag_xattr_bucket(struct inode *inode,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     struct ocfs2_xattr_bucket *bucket)\n{\n\tint ret, i;\n\tsize_t end, offset, len;\n\tstruct ocfs2_xattr_header *xh;\n\tchar *entries, *buf, *bucket_buf = NULL;\n\tu64 blkno = bucket_blkno(bucket);\n\tu16 xh_free_start;\n\tsize_t blocksize = inode->i_sb->s_blocksize;\n\tstruct ocfs2_xattr_entry *xe;\n\n\t \n\tbucket_buf = kmalloc(OCFS2_XATTR_BUCKET_SIZE, GFP_NOFS);\n\tif (!bucket_buf) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tbuf = bucket_buf;\n\tfor (i = 0; i < bucket->bu_blocks; i++, buf += blocksize)\n\t\tmemcpy(buf, bucket_block(bucket, i), blocksize);\n\n\tret = ocfs2_xattr_bucket_journal_access(handle, bucket,\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\txh = (struct ocfs2_xattr_header *)bucket_buf;\n\tentries = (char *)xh->xh_entries;\n\txh_free_start = le16_to_cpu(xh->xh_free_start);\n\n\ttrace_ocfs2_defrag_xattr_bucket(\n\t     (unsigned long long)blkno, le16_to_cpu(xh->xh_count),\n\t     xh_free_start, le16_to_cpu(xh->xh_name_value_len));\n\n\t \n\tsort(entries, le16_to_cpu(xh->xh_count),\n\t     sizeof(struct ocfs2_xattr_entry),\n\t     cmp_xe_offset, swap_xe);\n\n\t \n\txe = xh->xh_entries;\n\tend = OCFS2_XATTR_BUCKET_SIZE;\n\tfor (i = 0; i < le16_to_cpu(xh->xh_count); i++, xe++) {\n\t\toffset = le16_to_cpu(xe->xe_name_offset);\n\t\tlen = namevalue_size_xe(xe);\n\n\t\t \n\t\tif (((end - len) / blocksize !=\n\t\t\t(end - 1) / blocksize))\n\t\t\tend = end - end % blocksize;\n\n\t\tif (end > offset + len) {\n\t\t\tmemmove(bucket_buf + end - len,\n\t\t\t\tbucket_buf + offset, len);\n\t\t\txe->xe_name_offset = cpu_to_le16(end - len);\n\t\t}\n\n\t\tmlog_bug_on_msg(end < offset + len, \"Defrag check failed for \"\n\t\t\t\t\"bucket %llu\\n\", (unsigned long long)blkno);\n\n\t\tend -= len;\n\t}\n\n\tmlog_bug_on_msg(xh_free_start > end, \"Defrag check failed for \"\n\t\t\t\"bucket %llu\\n\", (unsigned long long)blkno);\n\n\tif (xh_free_start == end)\n\t\tgoto out;\n\n\tmemset(bucket_buf + xh_free_start, 0, end - xh_free_start);\n\txh->xh_free_start = cpu_to_le16(end);\n\n\t \n\tsort(entries, le16_to_cpu(xh->xh_count),\n\t     sizeof(struct ocfs2_xattr_entry),\n\t     cmp_xe, swap_xe);\n\n\tbuf = bucket_buf;\n\tfor (i = 0; i < bucket->bu_blocks; i++, buf += blocksize)\n\t\tmemcpy(bucket_block(bucket, i), buf, blocksize);\n\tocfs2_xattr_bucket_journal_dirty(handle, bucket);\n\nout:\n\tkfree(bucket_buf);\n\treturn ret;\n}\n\n \nstatic int ocfs2_mv_xattr_bucket_cross_cluster(struct inode *inode,\n\t\t\t\t\t       handle_t *handle,\n\t\t\t\t\t       struct ocfs2_xattr_bucket *first,\n\t\t\t\t\t       struct ocfs2_xattr_bucket *target,\n\t\t\t\t\t       u64 new_blkno,\n\t\t\t\t\t       u32 num_clusters,\n\t\t\t\t\t       u32 *first_hash)\n{\n\tint ret;\n\tstruct super_block *sb = inode->i_sb;\n\tint blks_per_bucket = ocfs2_blocks_per_xattr_bucket(sb);\n\tint num_buckets = ocfs2_xattr_buckets_per_cluster(OCFS2_SB(sb));\n\tint to_move = num_buckets / 2;\n\tu64 src_blkno;\n\tu64 last_cluster_blkno = bucket_blkno(first) +\n\t\t((num_clusters - 1) * ocfs2_clusters_to_blocks(sb, 1));\n\n\tBUG_ON(le16_to_cpu(bucket_xh(first)->xh_num_buckets) < num_buckets);\n\tBUG_ON(OCFS2_XATTR_BUCKET_SIZE == OCFS2_SB(sb)->s_clustersize);\n\n\ttrace_ocfs2_mv_xattr_bucket_cross_cluster(\n\t\t\t\t(unsigned long long)last_cluster_blkno,\n\t\t\t\t(unsigned long long)new_blkno);\n\n\tret = ocfs2_mv_xattr_buckets(inode, handle, bucket_blkno(first),\n\t\t\t\t     last_cluster_blkno, new_blkno,\n\t\t\t\t     to_move, first_hash);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t \n\tsrc_blkno = last_cluster_blkno + (to_move * blks_per_bucket);\n\n\t \n\tif (bucket_blkno(target) >= src_blkno) {\n\t\t \n\t\tsrc_blkno = new_blkno +\n\t\t\t(bucket_blkno(target) - src_blkno);\n\n\t\tocfs2_xattr_bucket_relse(first);\n\t\tocfs2_xattr_bucket_relse(target);\n\n\t\t \n\t\tret = ocfs2_read_xattr_bucket(first, new_blkno);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tret = ocfs2_read_xattr_bucket(target, src_blkno);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\n\t}\n\nout:\n\treturn ret;\n}\n\n \nstatic int ocfs2_xattr_find_divide_pos(struct ocfs2_xattr_header *xh)\n{\n\tstruct ocfs2_xattr_entry *entries = xh->xh_entries;\n\tint count = le16_to_cpu(xh->xh_count);\n\tint delta, middle = count / 2;\n\n\t \n\tfor (delta = 0; delta < middle; delta++) {\n\t\t \n\t\tif (cmp_xe(&entries[middle - delta - 1],\n\t\t\t   &entries[middle - delta]))\n\t\t\treturn middle - delta;\n\n\t\t \n\t\tif ((middle + delta + 1) == count)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (cmp_xe(&entries[middle + delta],\n\t\t\t   &entries[middle + delta + 1]))\n\t\t\treturn middle + delta + 1;\n\t}\n\n\t \n\treturn count;\n}\n\n \nstatic int ocfs2_divide_xattr_bucket(struct inode *inode,\n\t\t\t\t    handle_t *handle,\n\t\t\t\t    u64 blk,\n\t\t\t\t    u64 new_blk,\n\t\t\t\t    u32 *first_hash,\n\t\t\t\t    int new_bucket_head)\n{\n\tint ret, i;\n\tint count, start, len, name_value_len = 0, name_offset = 0;\n\tstruct ocfs2_xattr_bucket *s_bucket = NULL, *t_bucket = NULL;\n\tstruct ocfs2_xattr_header *xh;\n\tstruct ocfs2_xattr_entry *xe;\n\tint blocksize = inode->i_sb->s_blocksize;\n\n\ttrace_ocfs2_divide_xattr_bucket_begin((unsigned long long)blk,\n\t\t\t\t\t      (unsigned long long)new_blk);\n\n\ts_bucket = ocfs2_xattr_bucket_new(inode);\n\tt_bucket = ocfs2_xattr_bucket_new(inode);\n\tif (!s_bucket || !t_bucket) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_xattr_bucket(s_bucket, blk);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_xattr_bucket_journal_access(handle, s_bucket,\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t \n\tret = ocfs2_init_xattr_bucket(t_bucket, new_blk, new_bucket_head);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t \n\tret = ocfs2_xattr_bucket_journal_access(handle, t_bucket,\n\t\t\t\t\t\tnew_bucket_head ?\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_CREATE :\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\txh = bucket_xh(s_bucket);\n\tcount = le16_to_cpu(xh->xh_count);\n\tstart = ocfs2_xattr_find_divide_pos(xh);\n\n\tif (start == count) {\n\t\txe = &xh->xh_entries[start-1];\n\n\t\t \n\t\tfor (i = 0; i < t_bucket->bu_blocks; i++)\n\t\t\tmemset(bucket_block(t_bucket, i), 0, blocksize);\n\n\t\txh = bucket_xh(t_bucket);\n\t\txh->xh_free_start = cpu_to_le16(blocksize);\n\t\txh->xh_entries[0].xe_name_hash = xe->xe_name_hash;\n\t\tle32_add_cpu(&xh->xh_entries[0].xe_name_hash, 1);\n\n\t\tgoto set_num_buckets;\n\t}\n\n\t \n\tocfs2_xattr_bucket_copy_data(t_bucket, s_bucket);\n\n\t \n\txh = bucket_xh(t_bucket);\n\n\t \n\tname_offset = OCFS2_XATTR_BUCKET_SIZE;\n\tname_value_len = 0;\n\tfor (i = 0; i < start; i++) {\n\t\txe = &xh->xh_entries[i];\n\t\tname_value_len += namevalue_size_xe(xe);\n\t\tif (le16_to_cpu(xe->xe_name_offset) < name_offset)\n\t\t\tname_offset = le16_to_cpu(xe->xe_name_offset);\n\t}\n\n\t \n\txe = &xh->xh_entries[start];\n\tlen = sizeof(struct ocfs2_xattr_entry) * (count - start);\n\ttrace_ocfs2_divide_xattr_bucket_move(len,\n\t\t\t(int)((char *)xe - (char *)xh),\n\t\t\t(int)((char *)xh->xh_entries - (char *)xh));\n\tmemmove((char *)xh->xh_entries, (char *)xe, len);\n\txe = &xh->xh_entries[count - start];\n\tlen = sizeof(struct ocfs2_xattr_entry) * start;\n\tmemset((char *)xe, 0, len);\n\n\tle16_add_cpu(&xh->xh_count, -start);\n\tle16_add_cpu(&xh->xh_name_value_len, -name_value_len);\n\n\t \n\txh->xh_free_start = cpu_to_le16(OCFS2_XATTR_BUCKET_SIZE);\n\tfor (i = 0; i < le16_to_cpu(xh->xh_count); i++) {\n\t\txe = &xh->xh_entries[i];\n\t\tif (le16_to_cpu(xe->xe_name_offset) <\n\t\t    le16_to_cpu(xh->xh_free_start))\n\t\t\txh->xh_free_start = xe->xe_name_offset;\n\t}\n\nset_num_buckets:\n\t \n\tif (new_bucket_head)\n\t\txh->xh_num_buckets = cpu_to_le16(1);\n\telse\n\t\txh->xh_num_buckets = 0;\n\n\tocfs2_xattr_bucket_journal_dirty(handle, t_bucket);\n\n\t \n\tif (first_hash)\n\t\t*first_hash = le32_to_cpu(xh->xh_entries[0].xe_name_hash);\n\n\t \n\tif (start == count)\n\t\tgoto out;\n\n\txh = bucket_xh(s_bucket);\n\tmemset(&xh->xh_entries[start], 0,\n\t       sizeof(struct ocfs2_xattr_entry) * (count - start));\n\txh->xh_count = cpu_to_le16(start);\n\txh->xh_free_start = cpu_to_le16(name_offset);\n\txh->xh_name_value_len = cpu_to_le16(name_value_len);\n\n\tocfs2_xattr_bucket_journal_dirty(handle, s_bucket);\n\nout:\n\tocfs2_xattr_bucket_free(s_bucket);\n\tocfs2_xattr_bucket_free(t_bucket);\n\n\treturn ret;\n}\n\n \nstatic int ocfs2_cp_xattr_bucket(struct inode *inode,\n\t\t\t\t handle_t *handle,\n\t\t\t\t u64 s_blkno,\n\t\t\t\t u64 t_blkno,\n\t\t\t\t int t_is_new)\n{\n\tint ret;\n\tstruct ocfs2_xattr_bucket *s_bucket = NULL, *t_bucket = NULL;\n\n\tBUG_ON(s_blkno == t_blkno);\n\n\ttrace_ocfs2_cp_xattr_bucket((unsigned long long)s_blkno,\n\t\t\t\t    (unsigned long long)t_blkno,\n\t\t\t\t    t_is_new);\n\n\ts_bucket = ocfs2_xattr_bucket_new(inode);\n\tt_bucket = ocfs2_xattr_bucket_new(inode);\n\tif (!s_bucket || !t_bucket) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_xattr_bucket(s_bucket, s_blkno);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tret = ocfs2_init_xattr_bucket(t_bucket, t_blkno, t_is_new);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tret = ocfs2_xattr_bucket_journal_access(handle, t_bucket,\n\t\t\t\t\t\tt_is_new ?\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_CREATE :\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret)\n\t\tgoto out;\n\n\tocfs2_xattr_bucket_copy_data(t_bucket, s_bucket);\n\tocfs2_xattr_bucket_journal_dirty(handle, t_bucket);\n\nout:\n\tocfs2_xattr_bucket_free(t_bucket);\n\tocfs2_xattr_bucket_free(s_bucket);\n\n\treturn ret;\n}\n\n \nstatic int ocfs2_mv_xattr_buckets(struct inode *inode, handle_t *handle,\n\t\t\t\t  u64 src_blk, u64 last_blk, u64 to_blk,\n\t\t\t\t  unsigned int start_bucket,\n\t\t\t\t  u32 *first_hash)\n{\n\tint i, ret, credits;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tint blks_per_bucket = ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\tint num_buckets = ocfs2_xattr_buckets_per_cluster(osb);\n\tstruct ocfs2_xattr_bucket *old_first, *new_first;\n\n\ttrace_ocfs2_mv_xattr_buckets((unsigned long long)last_blk,\n\t\t\t\t     (unsigned long long)to_blk);\n\n\tBUG_ON(start_bucket >= num_buckets);\n\tif (start_bucket) {\n\t\tnum_buckets -= start_bucket;\n\t\tlast_blk += (start_bucket * blks_per_bucket);\n\t}\n\n\t \n\told_first = ocfs2_xattr_bucket_new(inode);\n\t \n\tnew_first = ocfs2_xattr_bucket_new(inode);\n\tif (!old_first || !new_first) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_xattr_bucket(old_first, src_blk);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t \n\tcredits = ((num_buckets + 1) * blks_per_bucket);\n\tret = ocfs2_extend_trans(handle, credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_xattr_bucket_journal_access(handle, old_first,\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < num_buckets; i++) {\n\t\tret = ocfs2_cp_xattr_bucket(inode, handle,\n\t\t\t\t\t    last_blk + (i * blks_per_bucket),\n\t\t\t\t\t    to_blk + (i * blks_per_bucket),\n\t\t\t\t\t    1);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tret = ocfs2_read_xattr_bucket(new_first, to_blk);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tret = ocfs2_xattr_bucket_journal_access(handle, new_first,\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t \n\tle16_add_cpu(&bucket_xh(old_first)->xh_num_buckets, -num_buckets);\n\tocfs2_xattr_bucket_journal_dirty(handle, old_first);\n\n\tbucket_xh(new_first)->xh_num_buckets = cpu_to_le16(num_buckets);\n\tocfs2_xattr_bucket_journal_dirty(handle, new_first);\n\n\tif (first_hash)\n\t\t*first_hash = le32_to_cpu(bucket_xh(new_first)->xh_entries[0].xe_name_hash);\n\nout:\n\tocfs2_xattr_bucket_free(new_first);\n\tocfs2_xattr_bucket_free(old_first);\n\treturn ret;\n}\n\n \nstatic int ocfs2_divide_xattr_cluster(struct inode *inode,\n\t\t\t\t      handle_t *handle,\n\t\t\t\t      u64 prev_blk,\n\t\t\t\t      u64 new_blk,\n\t\t\t\t      u32 *first_hash)\n{\n\tu16 blk_per_bucket = ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\tint ret, credits = 2 * blk_per_bucket;\n\n\tBUG_ON(OCFS2_XATTR_BUCKET_SIZE < OCFS2_SB(inode->i_sb)->s_clustersize);\n\n\tret = ocfs2_extend_trans(handle, credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t \n\treturn  ocfs2_divide_xattr_bucket(inode, handle, prev_blk,\n\t\t\t\t\t  new_blk, first_hash, 1);\n}\n\n \nstatic int ocfs2_adjust_xattr_cross_cluster(struct inode *inode,\n\t\t\t\t\t    handle_t *handle,\n\t\t\t\t\t    struct ocfs2_xattr_bucket *first,\n\t\t\t\t\t    struct ocfs2_xattr_bucket *target,\n\t\t\t\t\t    u64 new_blk,\n\t\t\t\t\t    u32 prev_clusters,\n\t\t\t\t\t    u32 *v_start,\n\t\t\t\t\t    int *extend)\n{\n\tint ret;\n\n\ttrace_ocfs2_adjust_xattr_cross_cluster(\n\t\t\t(unsigned long long)bucket_blkno(first),\n\t\t\t(unsigned long long)new_blk, prev_clusters);\n\n\tif (ocfs2_xattr_buckets_per_cluster(OCFS2_SB(inode->i_sb)) > 1) {\n\t\tret = ocfs2_mv_xattr_bucket_cross_cluster(inode,\n\t\t\t\t\t\t\t  handle,\n\t\t\t\t\t\t\t  first, target,\n\t\t\t\t\t\t\t  new_blk,\n\t\t\t\t\t\t\t  prev_clusters,\n\t\t\t\t\t\t\t  v_start);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t} else {\n\t\t \n\t\tu64 last_blk = bucket_blkno(first) +\n\t\t\t((prev_clusters - 1) *\n\t\t\t ocfs2_clusters_to_blocks(inode->i_sb, 1));\n\n\t\tif (prev_clusters > 1 && bucket_blkno(target) != last_blk) {\n\t\t\tret = ocfs2_mv_xattr_buckets(inode, handle,\n\t\t\t\t\t\t     bucket_blkno(first),\n\t\t\t\t\t\t     last_blk, new_blk, 0,\n\t\t\t\t\t\t     v_start);\n\t\t\tif (ret)\n\t\t\t\tmlog_errno(ret);\n\t\t} else {\n\t\t\tret = ocfs2_divide_xattr_cluster(inode, handle,\n\t\t\t\t\t\t\t last_blk, new_blk,\n\t\t\t\t\t\t\t v_start);\n\t\t\tif (ret)\n\t\t\t\tmlog_errno(ret);\n\n\t\t\tif ((bucket_blkno(target) == last_blk) && extend)\n\t\t\t\t*extend = 0;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n \nstatic int ocfs2_add_new_xattr_cluster(struct inode *inode,\n\t\t\t\t       struct buffer_head *root_bh,\n\t\t\t\t       struct ocfs2_xattr_bucket *first,\n\t\t\t\t       struct ocfs2_xattr_bucket *target,\n\t\t\t\t       u32 *num_clusters,\n\t\t\t\t       u32 prev_cpos,\n\t\t\t\t       int *extend,\n\t\t\t\t       struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret;\n\tu16 bpc = ocfs2_clusters_to_blocks(inode->i_sb, 1);\n\tu32 prev_clusters = *num_clusters;\n\tu32 clusters_to_add = 1, bit_off, num_bits, v_start = 0;\n\tu64 block;\n\thandle_t *handle = ctxt->handle;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_extent_tree et;\n\n\ttrace_ocfs2_add_new_xattr_cluster_begin(\n\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t(unsigned long long)bucket_blkno(first),\n\t\tprev_cpos, prev_clusters);\n\n\tocfs2_init_xattr_tree_extent_tree(&et, INODE_CACHE(inode), root_bh);\n\n\tret = ocfs2_journal_access_xb(handle, INODE_CACHE(inode), root_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\n\tret = __ocfs2_claim_clusters(handle, ctxt->data_ac, 1,\n\t\t\t\t     clusters_to_add, &bit_off, &num_bits);\n\tif (ret < 0) {\n\t\tif (ret != -ENOSPC)\n\t\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\n\tBUG_ON(num_bits > clusters_to_add);\n\n\tblock = ocfs2_clusters_to_blocks(osb->sb, bit_off);\n\ttrace_ocfs2_add_new_xattr_cluster((unsigned long long)block, num_bits);\n\n\tif (bucket_blkno(first) + (prev_clusters * bpc) == block &&\n\t    (prev_clusters + num_bits) << osb->s_clustersize_bits <=\n\t     OCFS2_MAX_XATTR_TREE_LEAF_SIZE) {\n\t\t \n\t\tv_start = prev_cpos + prev_clusters;\n\t\t*num_clusters = prev_clusters + num_bits;\n\t} else {\n\t\tret = ocfs2_adjust_xattr_cross_cluster(inode,\n\t\t\t\t\t\t       handle,\n\t\t\t\t\t\t       first,\n\t\t\t\t\t\t       target,\n\t\t\t\t\t\t       block,\n\t\t\t\t\t\t       prev_clusters,\n\t\t\t\t\t\t       &v_start,\n\t\t\t\t\t\t       extend);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto leave;\n\t\t}\n\t}\n\n\ttrace_ocfs2_add_new_xattr_cluster_insert((unsigned long long)block,\n\t\t\t\t\t\t v_start, num_bits);\n\tret = ocfs2_insert_extent(handle, &et, v_start, block,\n\t\t\t\t  num_bits, 0, ctxt->meta_ac);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\n\tocfs2_journal_dirty(handle, root_bh);\n\nleave:\n\treturn ret;\n}\n\n \nstatic int ocfs2_extend_xattr_bucket(struct inode *inode,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     struct ocfs2_xattr_bucket *first,\n\t\t\t\t     u64 target_blk,\n\t\t\t\t     u32 num_clusters)\n{\n\tint ret, credits;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tu16 blk_per_bucket = ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\tu64 end_blk;\n\tu16 new_bucket = le16_to_cpu(bucket_xh(first)->xh_num_buckets);\n\n\ttrace_ocfs2_extend_xattr_bucket((unsigned long long)target_blk,\n\t\t\t\t\t(unsigned long long)bucket_blkno(first),\n\t\t\t\t\tnum_clusters, new_bucket);\n\n\t \n\tBUG_ON(new_bucket >=\n\t       (num_clusters * ocfs2_xattr_buckets_per_cluster(osb)));\n\n\t \n\tend_blk = bucket_blkno(first) + ((new_bucket - 1) * blk_per_bucket);\n\n\t \n\tcredits = (end_blk - target_blk) + (3 * blk_per_bucket);\n\tret = ocfs2_extend_trans(handle, credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_xattr_bucket_journal_access(handle, first,\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\twhile (end_blk != target_blk) {\n\t\tret = ocfs2_cp_xattr_bucket(inode, handle, end_blk,\n\t\t\t\t\t    end_blk + blk_per_bucket, 0);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tend_blk -= blk_per_bucket;\n\t}\n\n\t \n\tret = ocfs2_divide_xattr_bucket(inode, handle, target_blk,\n\t\t\t\t\ttarget_blk + blk_per_bucket, NULL, 0);\n\n\tle16_add_cpu(&bucket_xh(first)->xh_num_buckets, 1);\n\tocfs2_xattr_bucket_journal_dirty(handle, first);\n\nout:\n\treturn ret;\n}\n\n \nstatic int ocfs2_add_new_xattr_bucket(struct inode *inode,\n\t\t\t\t      struct buffer_head *xb_bh,\n\t\t\t\t      struct ocfs2_xattr_bucket *target,\n\t\t\t\t      struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tstruct ocfs2_xattr_block *xb =\n\t\t\t(struct ocfs2_xattr_block *)xb_bh->b_data;\n\tstruct ocfs2_xattr_tree_root *xb_root = &xb->xb_attrs.xb_root;\n\tstruct ocfs2_extent_list *el = &xb_root->xt_list;\n\tu32 name_hash =\n\t\tle32_to_cpu(bucket_xh(target)->xh_entries[0].xe_name_hash);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tint ret, num_buckets, extend = 1;\n\tu64 p_blkno;\n\tu32 e_cpos, num_clusters;\n\t \n\tstruct ocfs2_xattr_bucket *first;\n\n\ttrace_ocfs2_add_new_xattr_bucket(\n\t\t\t\t(unsigned long long)bucket_blkno(target));\n\n\t \n\tfirst = ocfs2_xattr_bucket_new(inode);\n\tif (!first) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_xattr_get_rec(inode, name_hash, &p_blkno, &e_cpos,\n\t\t\t\t  &num_clusters, el);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_xattr_bucket(first, p_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tnum_buckets = ocfs2_xattr_buckets_per_cluster(osb) * num_clusters;\n\tif (num_buckets == le16_to_cpu(bucket_xh(first)->xh_num_buckets)) {\n\t\t \n\t\tret = ocfs2_add_new_xattr_cluster(inode,\n\t\t\t\t\t\t  xb_bh,\n\t\t\t\t\t\t  first,\n\t\t\t\t\t\t  target,\n\t\t\t\t\t\t  &num_clusters,\n\t\t\t\t\t\t  e_cpos,\n\t\t\t\t\t\t  &extend,\n\t\t\t\t\t\t  ctxt);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (extend) {\n\t\tret = ocfs2_extend_xattr_bucket(inode,\n\t\t\t\t\t\tctxt->handle,\n\t\t\t\t\t\tfirst,\n\t\t\t\t\t\tbucket_blkno(target),\n\t\t\t\t\t\tnum_clusters);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\nout:\n\tocfs2_xattr_bucket_free(first);\n\n\treturn ret;\n}\n\n \nstatic int ocfs2_xattr_bucket_value_truncate(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t     int xe_off,\n\t\t\t\t\t     int len,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret, offset;\n\tu64 value_blk;\n\tstruct ocfs2_xattr_entry *xe;\n\tstruct ocfs2_xattr_header *xh = bucket_xh(bucket);\n\tsize_t blocksize = inode->i_sb->s_blocksize;\n\tstruct ocfs2_xattr_value_buf vb = {\n\t\t.vb_access = ocfs2_journal_access,\n\t};\n\n\txe = &xh->xh_entries[xe_off];\n\n\tBUG_ON(!xe || ocfs2_xattr_is_local(xe));\n\n\toffset = le16_to_cpu(xe->xe_name_offset) +\n\t\t OCFS2_XATTR_SIZE(xe->xe_name_len);\n\n\tvalue_blk = offset / blocksize;\n\n\t \n\tBUG_ON(value_blk != (offset + OCFS2_XATTR_ROOT_SIZE - 1) / blocksize);\n\n\tvb.vb_bh = bucket->bu_bhs[value_blk];\n\tBUG_ON(!vb.vb_bh);\n\n\tvb.vb_xv = (struct ocfs2_xattr_value_root *)\n\t\t(vb.vb_bh->b_data + offset % blocksize);\n\n\t \n\ttrace_ocfs2_xattr_bucket_value_truncate(\n\t\t\t(unsigned long long)bucket_blkno(bucket), xe_off, len);\n\tret = ocfs2_xattr_value_truncate(inode, &vb, len, ctxt);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_xattr_bucket_journal_access(ctxt->handle, bucket,\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\txe->xe_value_size = cpu_to_le64(len);\n\n\tocfs2_xattr_bucket_journal_dirty(ctxt->handle, bucket);\n\nout:\n\treturn ret;\n}\n\nstatic int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para)\n{\n\tint ret;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\thandle_t *handle;\n\tstruct ocfs2_xattr_block *xb =\n\t\t\t(struct ocfs2_xattr_block *)root_bh->b_data;\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\tstruct ocfs2_cached_dealloc_ctxt dealloc;\n\tstruct ocfs2_extent_tree et;\n\n\tret = ocfs2_iterate_xattr_buckets(inode, blkno, len,\n\t\t\t\t\t  ocfs2_delete_xattr_in_bucket, para);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tocfs2_init_xattr_tree_extent_tree(&et, INODE_CACHE(inode), root_bh);\n\n\tocfs2_init_dealloc_ctxt(&dealloc);\n\n\ttrace_ocfs2_rm_xattr_cluster(\n\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t(unsigned long long)blkno, cpos, len);\n\n\tocfs2_remove_xattr_clusters_from_cache(INODE_CACHE(inode), blkno,\n\t\t\t\t\t       len);\n\n\tret = ocfs2_lock_allocators(inode, &et, 0, 1, NULL, &meta_ac);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tinode_lock(tl_inode);\n\n\tif (ocfs2_truncate_log_needs_flush(osb)) {\n\t\tret = __ocfs2_flush_truncate_log(osb);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\thandle = ocfs2_start_trans(osb, ocfs2_remove_extent_credits(osb->sb));\n\tif (IS_ERR(handle)) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_xb(handle, INODE_CACHE(inode), root_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tret = ocfs2_remove_extent(handle, &et, cpos, len, meta_ac,\n\t\t\t\t  &dealloc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tle32_add_cpu(&xb->xb_attrs.xb_root.xt_clusters, -len);\n\tocfs2_journal_dirty(handle, root_bh);\n\n\tret = ocfs2_truncate_log_append(osb, handle, blkno, len);\n\tif (ret)\n\t\tmlog_errno(ret);\n\tocfs2_update_inode_fsync_trans(handle, inode, 0);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\nout:\n\tocfs2_schedule_truncate_log_flush(osb, 1);\n\n\tinode_unlock(tl_inode);\n\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\n\tocfs2_run_deallocs(osb, &dealloc);\n\n\treturn ret;\n}\n\n \nstatic int ocfs2_check_xattr_bucket_collision(struct inode *inode,\n\t\t\t\t\t      struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t      const char *name)\n{\n\tstruct ocfs2_xattr_header *xh = bucket_xh(bucket);\n\tu32 name_hash = ocfs2_xattr_name_hash(inode, name, strlen(name));\n\n\tif (name_hash != le32_to_cpu(xh->xh_entries[0].xe_name_hash))\n\t\treturn 0;\n\n\tif (xh->xh_entries[le16_to_cpu(xh->xh_count) - 1].xe_name_hash ==\n\t    xh->xh_entries[0].xe_name_hash) {\n\t\tmlog(ML_ERROR, \"Too much hash collision in xattr bucket %llu, \"\n\t\t     \"hash = %u\\n\",\n\t\t     (unsigned long long)bucket_blkno(bucket),\n\t\t     le32_to_cpu(xh->xh_entries[0].xe_name_hash));\n\t\treturn -ENOSPC;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ocfs2_xattr_set_entry_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs,\n\t\t\t\t\tstruct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret;\n\tstruct ocfs2_xa_loc loc;\n\n\ttrace_ocfs2_xattr_set_entry_bucket(xi->xi_name);\n\n\tocfs2_init_xattr_bucket_xa_loc(&loc, xs->bucket,\n\t\t\t\t       xs->not_found ? NULL : xs->here);\n\tret = ocfs2_xa_set(&loc, xi, ctxt);\n\tif (!ret) {\n\t\txs->here = loc.xl_entry;\n\t\tgoto out;\n\t}\n\tif (ret != -ENOSPC) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t \n\tret = ocfs2_defrag_xattr_bucket(inode, ctxt->handle,\n\t\t\t\t\txs->bucket);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_xa_set(&loc, xi, ctxt);\n\tif (!ret) {\n\t\txs->here = loc.xl_entry;\n\t\tgoto out;\n\t}\n\tif (ret != -ENOSPC)\n\t\tmlog_errno(ret);\n\n\nout:\n\treturn ret;\n}\n\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret;\n\n\ttrace_ocfs2_xattr_set_entry_index_block(xi->xi_name);\n\n\tret = ocfs2_xattr_set_entry_bucket(inode, xi, xs, ctxt);\n\tif (!ret)\n\t\tgoto out;\n\tif (ret != -ENOSPC) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t \n\n\t \n\tret = ocfs2_check_xattr_bucket_collision(inode,\n\t\t\t\t\t\t xs->bucket,\n\t\t\t\t\t\t xi->xi_name);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_add_new_xattr_bucket(inode,\n\t\t\t\t\t xs->xattr_bh,\n\t\t\t\t\t xs->bucket,\n\t\t\t\t\t ctxt);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t \n\tocfs2_xattr_bucket_relse(xs->bucket);\n\tret = ocfs2_xattr_index_block_find(inode, xs->xattr_bh,\n\t\t\t\t\t   xi->xi_name_index,\n\t\t\t\t\t   xi->xi_name, xs);\n\tif (ret && ret != -ENODATA)\n\t\tgoto out;\n\txs->not_found = ret;\n\n\t \n\tret = ocfs2_xattr_set_entry_bucket(inode, xi, xs, ctxt);\n\tif (ret && (ret != -ENOSPC))\n\t\tmlog_errno(ret);\n\nout:\n\treturn ret;\n}\n\nstatic int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para)\n{\n\tint ret = 0, ref_credits;\n\tstruct ocfs2_xattr_header *xh = bucket_xh(bucket);\n\tu16 i;\n\tstruct ocfs2_xattr_entry *xe;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_xattr_set_ctxt ctxt = {NULL, NULL,};\n\tint credits = ocfs2_remove_extent_credits(osb->sb) +\n\t\tocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\tstruct ocfs2_xattr_value_root *xv;\n\tstruct ocfs2_rm_xattr_bucket_para *args =\n\t\t\t(struct ocfs2_rm_xattr_bucket_para *)para;\n\n\tocfs2_init_dealloc_ctxt(&ctxt.dealloc);\n\n\tfor (i = 0; i < le16_to_cpu(xh->xh_count); i++) {\n\t\txe = &xh->xh_entries[i];\n\t\tif (ocfs2_xattr_is_local(xe))\n\t\t\tcontinue;\n\n\t\tret = ocfs2_get_xattr_tree_value_root(inode->i_sb, bucket,\n\t\t\t\t\t\t      i, &xv, NULL);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = ocfs2_lock_xattr_remove_allocators(inode, xv,\n\t\t\t\t\t\t\t args->ref_ci,\n\t\t\t\t\t\t\t args->ref_root_bh,\n\t\t\t\t\t\t\t &ctxt.meta_ac,\n\t\t\t\t\t\t\t &ref_credits);\n\n\t\tctxt.handle = ocfs2_start_trans(osb, credits + ref_credits);\n\t\tif (IS_ERR(ctxt.handle)) {\n\t\t\tret = PTR_ERR(ctxt.handle);\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = ocfs2_xattr_bucket_value_truncate(inode, bucket,\n\t\t\t\t\t\t\ti, 0, &ctxt);\n\n\t\tocfs2_commit_trans(osb, ctxt.handle);\n\t\tif (ctxt.meta_ac) {\n\t\t\tocfs2_free_alloc_context(ctxt.meta_ac);\n\t\t\tctxt.meta_ac = NULL;\n\t\t}\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ctxt.meta_ac)\n\t\tocfs2_free_alloc_context(ctxt.meta_ac);\n\tocfs2_schedule_truncate_log_flush(osb, 1);\n\tocfs2_run_deallocs(osb, &ctxt.dealloc);\n\treturn ret;\n}\n\n \nstatic int ocfs2_xattr_bucket_post_refcount(struct inode *inode,\n\t\t\t\t\t    handle_t *handle,\n\t\t\t\t\t    void *para)\n{\n\tint ret;\n\tstruct ocfs2_xattr_bucket *bucket =\n\t\t\t(struct ocfs2_xattr_bucket *)para;\n\n\tret = ocfs2_xattr_bucket_journal_access(handle, bucket,\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tocfs2_xattr_bucket_journal_dirty(handle, bucket);\n\n\treturn 0;\n}\n\n \nstatic int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_add,\n\t\t\t\t\tint *credits)\n{\n\tint ret = 0;\n\tstruct ocfs2_xattr_block *xb;\n\tstruct ocfs2_xattr_entry *xe;\n\tchar *base;\n\tu32 p_cluster, num_clusters;\n\tunsigned int ext_flags;\n\tint name_offset, name_len;\n\tstruct ocfs2_xattr_value_buf vb;\n\tstruct ocfs2_xattr_bucket *bucket = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_post_refcount refcount;\n\tstruct ocfs2_post_refcount *p = NULL;\n\tstruct buffer_head *ref_root_bh = NULL;\n\n\tif (!xis->not_found) {\n\t\txe = xis->here;\n\t\tname_offset = le16_to_cpu(xe->xe_name_offset);\n\t\tname_len = OCFS2_XATTR_SIZE(xe->xe_name_len);\n\t\tbase = xis->base;\n\t\tvb.vb_bh = xis->inode_bh;\n\t\tvb.vb_access = ocfs2_journal_access_di;\n\t} else {\n\t\tint i, block_off = 0;\n\t\txb = (struct ocfs2_xattr_block *)xbs->xattr_bh->b_data;\n\t\txe = xbs->here;\n\t\tname_offset = le16_to_cpu(xe->xe_name_offset);\n\t\tname_len = OCFS2_XATTR_SIZE(xe->xe_name_len);\n\t\ti = xbs->here - xbs->header->xh_entries;\n\n\t\tif (le16_to_cpu(xb->xb_flags) & OCFS2_XATTR_INDEXED) {\n\t\t\tret = ocfs2_xattr_bucket_get_name_value(inode->i_sb,\n\t\t\t\t\t\t\tbucket_xh(xbs->bucket),\n\t\t\t\t\t\t\ti, &block_off,\n\t\t\t\t\t\t\t&name_offset);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbase = bucket_block(xbs->bucket, block_off);\n\t\t\tvb.vb_bh = xbs->bucket->bu_bhs[block_off];\n\t\t\tvb.vb_access = ocfs2_journal_access;\n\n\t\t\tif (ocfs2_meta_ecc(osb)) {\n\t\t\t\t \n\t\t\t\tbucket = xbs->bucket;\n\t\t\t\trefcount.credits = bucket->bu_blocks;\n\t\t\t\trefcount.para = bucket;\n\t\t\t\trefcount.func =\n\t\t\t\t\tocfs2_xattr_bucket_post_refcount;\n\t\t\t\tp = &refcount;\n\t\t\t}\n\t\t} else {\n\t\t\tbase = xbs->base;\n\t\t\tvb.vb_bh = xbs->xattr_bh;\n\t\t\tvb.vb_access = ocfs2_journal_access_xb;\n\t\t}\n\t}\n\n\tif (ocfs2_xattr_is_local(xe))\n\t\tgoto out;\n\n\tvb.vb_xv = (struct ocfs2_xattr_value_root *)\n\t\t\t\t(base + name_offset + name_len);\n\n\tret = ocfs2_xattr_get_clusters(inode, 0, &p_cluster,\n\t\t\t\t       &num_clusters, &vb.vb_xv->xr_list,\n\t\t\t\t       &ext_flags);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t \n\tif (!(ext_flags & OCFS2_EXT_REFCOUNTED))\n\t\tgoto out;\n\n\tret = ocfs2_lock_refcount_tree(osb, le64_to_cpu(di->i_refcount_loc),\n\t\t\t\t       1, ref_tree, &ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t \n\tif (!xi->xi_value || xi->xi_value_len <= OCFS2_XATTR_INLINE_SIZE) {\n\n\t\tret = ocfs2_refcounted_xattr_delete_need(inode,\n\t\t\t\t\t\t\t &(*ref_tree)->rf_ci,\n\t\t\t\t\t\t\t ref_root_bh, vb.vb_xv,\n\t\t\t\t\t\t\t meta_add, credits);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_refcount_cow_xattr(inode, di, &vb,\n\t\t\t\t       *ref_tree, ref_root_bh, 0,\n\t\t\t\t       le32_to_cpu(vb.vb_xv->xr_clusters), p);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tbrelse(ref_root_bh);\n\treturn ret;\n}\n\n \nstatic int ocfs2_xattr_value_attach_refcount(struct inode *inode,\n\t\t\t\tstruct ocfs2_xattr_value_root *xv,\n\t\t\t\tstruct ocfs2_extent_tree *value_et,\n\t\t\t\tstruct ocfs2_caching_info *ref_ci,\n\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t\tstruct ocfs2_post_refcount *refcount)\n{\n\tint ret = 0;\n\tu32 clusters = le32_to_cpu(xv->xr_clusters);\n\tu32 cpos, p_cluster, num_clusters;\n\tstruct ocfs2_extent_list *el = &xv->xr_list;\n\tunsigned int ext_flags;\n\n\tcpos = 0;\n\twhile (cpos < clusters) {\n\t\tret = ocfs2_xattr_get_clusters(inode, cpos, &p_cluster,\n\t\t\t\t\t       &num_clusters, el, &ext_flags);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tcpos += num_clusters;\n\t\tif ((ext_flags & OCFS2_EXT_REFCOUNTED))\n\t\t\tcontinue;\n\n\t\tBUG_ON(!p_cluster);\n\n\t\tret = ocfs2_add_refcount_flag(inode, value_et,\n\t\t\t\t\t      ref_ci, ref_root_bh,\n\t\t\t\t\t      cpos - num_clusters,\n\t\t\t\t\t      p_cluster, num_clusters,\n\t\t\t\t\t      dealloc, refcount);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n \nstatic int ocfs2_xattr_attach_refcount_normal(struct inode *inode,\n\t\t\t\tstruct ocfs2_xattr_value_buf *vb,\n\t\t\t\tstruct ocfs2_xattr_header *header,\n\t\t\t\tstruct ocfs2_caching_info *ref_ci,\n\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\n\tstruct ocfs2_xattr_entry *xe;\n\tstruct ocfs2_xattr_value_root *xv;\n\tstruct ocfs2_extent_tree et;\n\tint i, ret = 0;\n\n\tfor (i = 0; i < le16_to_cpu(header->xh_count); i++) {\n\t\txe = &header->xh_entries[i];\n\n\t\tif (ocfs2_xattr_is_local(xe))\n\t\t\tcontinue;\n\n\t\txv = (struct ocfs2_xattr_value_root *)((void *)header +\n\t\t\tle16_to_cpu(xe->xe_name_offset) +\n\t\t\tOCFS2_XATTR_SIZE(xe->xe_name_len));\n\n\t\tvb->vb_xv = xv;\n\t\tocfs2_init_xattr_value_extent_tree(&et, INODE_CACHE(inode), vb);\n\n\t\tret = ocfs2_xattr_value_attach_refcount(inode, xv, &et,\n\t\t\t\t\t\t\tref_ci, ref_root_bh,\n\t\t\t\t\t\t\tdealloc, NULL);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int ocfs2_xattr_inline_attach_refcount(struct inode *inode,\n\t\t\t\tstruct buffer_head *fe_bh,\n\t\t\t\tstruct ocfs2_caching_info *ref_ci,\n\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)fe_bh->b_data;\n\tstruct ocfs2_xattr_header *header = (struct ocfs2_xattr_header *)\n\t\t\t\t(fe_bh->b_data + inode->i_sb->s_blocksize -\n\t\t\t\tle16_to_cpu(di->i_xattr_inline_size));\n\tstruct ocfs2_xattr_value_buf vb = {\n\t\t.vb_bh = fe_bh,\n\t\t.vb_access = ocfs2_journal_access_di,\n\t};\n\n\treturn ocfs2_xattr_attach_refcount_normal(inode, &vb, header,\n\t\t\t\t\t\t  ref_ci, ref_root_bh, dealloc);\n}\n\nstruct ocfs2_xattr_tree_value_refcount_para {\n\tstruct ocfs2_caching_info *ref_ci;\n\tstruct buffer_head *ref_root_bh;\n\tstruct ocfs2_cached_dealloc_ctxt *dealloc;\n};\n\nstatic int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh)\n{\n\tint ret, block_off, name_offset;\n\tstruct ocfs2_xattr_header *xh = bucket_xh(bucket);\n\tstruct ocfs2_xattr_entry *xe = &xh->xh_entries[offset];\n\tvoid *base;\n\n\tret = ocfs2_xattr_bucket_get_name_value(sb,\n\t\t\t\t\t\tbucket_xh(bucket),\n\t\t\t\t\t\toffset,\n\t\t\t\t\t\t&block_off,\n\t\t\t\t\t\t&name_offset);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tbase = bucket_block(bucket, block_off);\n\n\t*xv = (struct ocfs2_xattr_value_root *)(base + name_offset +\n\t\t\t OCFS2_XATTR_SIZE(xe->xe_name_len));\n\n\tif (bh)\n\t\t*bh = bucket->bu_bhs[block_off];\nout:\n\treturn ret;\n}\n\n \nstatic int ocfs2_xattr_bucket_value_refcount(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t     void *para)\n{\n\tint i, ret = 0;\n\tstruct ocfs2_extent_tree et;\n\tstruct ocfs2_xattr_tree_value_refcount_para *ref =\n\t\t\t(struct ocfs2_xattr_tree_value_refcount_para *)para;\n\tstruct ocfs2_xattr_header *xh =\n\t\t\t(struct ocfs2_xattr_header *)bucket->bu_bhs[0]->b_data;\n\tstruct ocfs2_xattr_entry *xe;\n\tstruct ocfs2_xattr_value_buf vb = {\n\t\t.vb_access = ocfs2_journal_access,\n\t};\n\tstruct ocfs2_post_refcount refcount = {\n\t\t.credits = bucket->bu_blocks,\n\t\t.para = bucket,\n\t\t.func = ocfs2_xattr_bucket_post_refcount,\n\t};\n\tstruct ocfs2_post_refcount *p = NULL;\n\n\t \n\tif (ocfs2_meta_ecc(OCFS2_SB(inode->i_sb)))\n\t\tp = &refcount;\n\n\ttrace_ocfs2_xattr_bucket_value_refcount(\n\t\t\t\t(unsigned long long)bucket_blkno(bucket),\n\t\t\t\tle16_to_cpu(xh->xh_count));\n\tfor (i = 0; i < le16_to_cpu(xh->xh_count); i++) {\n\t\txe = &xh->xh_entries[i];\n\n\t\tif (ocfs2_xattr_is_local(xe))\n\t\t\tcontinue;\n\n\t\tret = ocfs2_get_xattr_tree_value_root(inode->i_sb, bucket, i,\n\t\t\t\t\t\t      &vb.vb_xv, &vb.vb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tocfs2_init_xattr_value_extent_tree(&et,\n\t\t\t\t\t\t   INODE_CACHE(inode), &vb);\n\n\t\tret = ocfs2_xattr_value_attach_refcount(inode, vb.vb_xv,\n\t\t\t\t\t\t\t&et, ref->ref_ci,\n\t\t\t\t\t\t\tref->ref_root_bh,\n\t\t\t\t\t\t\tref->dealloc, p);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n\n}\n\nstatic int ocfs2_refcount_xattr_tree_rec(struct inode *inode,\n\t\t\t\t     struct buffer_head *root_bh,\n\t\t\t\t     u64 blkno, u32 cpos, u32 len, void *para)\n{\n\treturn ocfs2_iterate_xattr_buckets(inode, blkno, len,\n\t\t\t\t\t   ocfs2_xattr_bucket_value_refcount,\n\t\t\t\t\t   para);\n}\n\nstatic int ocfs2_xattr_block_attach_refcount(struct inode *inode,\n\t\t\t\tstruct buffer_head *blk_bh,\n\t\t\t\tstruct ocfs2_caching_info *ref_ci,\n\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret = 0;\n\tstruct ocfs2_xattr_block *xb =\n\t\t\t\t(struct ocfs2_xattr_block *)blk_bh->b_data;\n\n\tif (!(le16_to_cpu(xb->xb_flags) & OCFS2_XATTR_INDEXED)) {\n\t\tstruct ocfs2_xattr_header *header = &xb->xb_attrs.xb_header;\n\t\tstruct ocfs2_xattr_value_buf vb = {\n\t\t\t.vb_bh = blk_bh,\n\t\t\t.vb_access = ocfs2_journal_access_xb,\n\t\t};\n\n\t\tret = ocfs2_xattr_attach_refcount_normal(inode, &vb, header,\n\t\t\t\t\t\t\t ref_ci, ref_root_bh,\n\t\t\t\t\t\t\t dealloc);\n\t} else {\n\t\tstruct ocfs2_xattr_tree_value_refcount_para para = {\n\t\t\t.ref_ci = ref_ci,\n\t\t\t.ref_root_bh = ref_root_bh,\n\t\t\t.dealloc = dealloc,\n\t\t};\n\n\t\tret = ocfs2_iterate_xattr_index_block(inode, blk_bh,\n\t\t\t\t\t\tocfs2_refcount_xattr_tree_rec,\n\t\t\t\t\t\t&para);\n\t}\n\n\treturn ret;\n}\n\nint ocfs2_xattr_attach_refcount_tree(struct inode *inode,\n\t\t\t\t     struct buffer_head *fe_bh,\n\t\t\t\t     struct ocfs2_caching_info *ref_ci,\n\t\t\t\t     struct buffer_head *ref_root_bh,\n\t\t\t\t     struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret = 0;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)fe_bh->b_data;\n\tstruct buffer_head *blk_bh = NULL;\n\n\tif (oi->ip_dyn_features & OCFS2_INLINE_XATTR_FL) {\n\t\tret = ocfs2_xattr_inline_attach_refcount(inode, fe_bh,\n\t\t\t\t\t\t\t ref_ci, ref_root_bh,\n\t\t\t\t\t\t\t dealloc);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!di->i_xattr_loc)\n\t\tgoto out;\n\n\tret = ocfs2_read_xattr_block(inode, le64_to_cpu(di->i_xattr_loc),\n\t\t\t\t     &blk_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_xattr_block_attach_refcount(inode, blk_bh, ref_ci,\n\t\t\t\t\t\tref_root_bh, dealloc);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\tbrelse(blk_bh);\nout:\n\n\treturn ret;\n}\n\ntypedef int (should_xattr_reflinked)(struct ocfs2_xattr_entry *xe);\n \nstruct ocfs2_xattr_reflink {\n\tstruct inode *old_inode;\n\tstruct inode *new_inode;\n\tstruct buffer_head *old_bh;\n\tstruct buffer_head *new_bh;\n\tstruct ocfs2_caching_info *ref_ci;\n\tstruct buffer_head *ref_root_bh;\n\tstruct ocfs2_cached_dealloc_ctxt *dealloc;\n\tshould_xattr_reflinked *xattr_reflinked;\n};\n\n \ntypedef int (get_xattr_value_root)(struct super_block *sb,\n\t\t\t\t   struct buffer_head *bh,\n\t\t\t\t   struct ocfs2_xattr_header *xh,\n\t\t\t\t   int offset,\n\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t   struct buffer_head **ret_bh,\n\t\t\t\t   void *para);\n\n \nstatic int ocfs2_value_metas_in_xattr_header(struct super_block *sb,\n\t\t\t\t\t     struct buffer_head *bh,\n\t\t\t\t\t     struct ocfs2_xattr_header *xh,\n\t\t\t\t\t     int *metas, int *credits,\n\t\t\t\t\t     int *num_recs,\n\t\t\t\t\t     get_xattr_value_root *func,\n\t\t\t\t\t     void *para)\n{\n\tint i, ret = 0;\n\tstruct ocfs2_xattr_value_root *xv;\n\tstruct ocfs2_xattr_entry *xe;\n\n\tfor (i = 0; i < le16_to_cpu(xh->xh_count); i++) {\n\t\txe = &xh->xh_entries[i];\n\t\tif (ocfs2_xattr_is_local(xe))\n\t\t\tcontinue;\n\n\t\tret = func(sb, bh, xh, i, &xv, NULL, para);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\t*metas += le16_to_cpu(xv->xr_list.l_tree_depth) *\n\t\t\t  le16_to_cpu(xv->xr_list.l_next_free_rec);\n\n\t\t*credits += ocfs2_calc_extend_credits(sb,\n\t\t\t\t\t\t&def_xv.xv.xr_list);\n\n\t\t \n\t\tif (!xv->xr_list.l_tree_depth)\n\t\t\t*num_recs += le16_to_cpu(xv->xr_list.l_next_free_rec);\n\t\telse\n\t\t\t*num_recs += ocfs2_clusters_for_bytes(sb,\n\t\t\t\t\t\t\t      XATTR_SIZE_MAX);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int ocfs2_get_xattr_value_root(struct super_block *sb,\n\t\t\t\t      struct buffer_head *bh,\n\t\t\t\t      struct ocfs2_xattr_header *xh,\n\t\t\t\t      int offset,\n\t\t\t\t      struct ocfs2_xattr_value_root **xv,\n\t\t\t\t      struct buffer_head **ret_bh,\n\t\t\t\t      void *para)\n{\n\tstruct ocfs2_xattr_entry *xe = &xh->xh_entries[offset];\n\n\t*xv = (struct ocfs2_xattr_value_root *)((void *)xh +\n\t\tle16_to_cpu(xe->xe_name_offset) +\n\t\tOCFS2_XATTR_SIZE(xe->xe_name_len));\n\n\tif (ret_bh)\n\t\t*ret_bh = bh;\n\n\treturn 0;\n}\n\n \nstatic int ocfs2_reflink_lock_xattr_allocators(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_xattr_header *xh,\n\t\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\t\tint *credits,\n\t\t\t\t\tstruct ocfs2_alloc_context **meta_ac)\n{\n\tint ret, meta_add = 0, num_recs = 0;\n\tstruct ocfs2_refcount_block *rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\n\t*credits = 0;\n\n\tret = ocfs2_value_metas_in_xattr_header(osb->sb, NULL, xh,\n\t\t\t\t\t\t&meta_add, credits, &num_recs,\n\t\t\t\t\t\tocfs2_get_xattr_value_root,\n\t\t\t\t\t\tNULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t \n\tnum_recs = num_recs / ocfs2_refcount_recs_per_rb(osb->sb) * 2;\n\tmeta_add += num_recs;\n\t*credits += num_recs + num_recs * OCFS2_EXPAND_REFCOUNT_TREE_CREDITS;\n\tif (le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL)\n\t\t*credits += le16_to_cpu(rb->rf_list.l_tree_depth) *\n\t\t\t    le16_to_cpu(rb->rf_list.l_next_free_rec) + 1;\n\telse\n\t\t*credits += 1;\n\n\tret = ocfs2_reserve_new_metadata_blocks(osb, meta_add, meta_ac);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\treturn ret;\n}\n\n \nstatic int ocfs2_reflink_xattr_header(handle_t *handle,\n\t\t\t\t      struct ocfs2_xattr_reflink *args,\n\t\t\t\t      struct buffer_head *old_bh,\n\t\t\t\t      struct ocfs2_xattr_header *xh,\n\t\t\t\t      struct buffer_head *new_bh,\n\t\t\t\t      struct ocfs2_xattr_header *new_xh,\n\t\t\t\t      struct ocfs2_xattr_value_buf *vb,\n\t\t\t\t      struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t      get_xattr_value_root *func,\n\t\t\t\t      void *para)\n{\n\tint ret = 0, i, j;\n\tstruct super_block *sb = args->old_inode->i_sb;\n\tstruct buffer_head *value_bh;\n\tstruct ocfs2_xattr_entry *xe, *last;\n\tstruct ocfs2_xattr_value_root *xv, *new_xv;\n\tstruct ocfs2_extent_tree data_et;\n\tu32 clusters, cpos, p_cluster, num_clusters;\n\tunsigned int ext_flags = 0;\n\n\ttrace_ocfs2_reflink_xattr_header((unsigned long long)old_bh->b_blocknr,\n\t\t\t\t\t le16_to_cpu(xh->xh_count));\n\n\tlast = &new_xh->xh_entries[le16_to_cpu(new_xh->xh_count)];\n\tfor (i = 0, j = 0; i < le16_to_cpu(xh->xh_count); i++, j++) {\n\t\txe = &xh->xh_entries[i];\n\n\t\tif (args->xattr_reflinked && !args->xattr_reflinked(xe)) {\n\t\t\txe = &new_xh->xh_entries[j];\n\n\t\t\tle16_add_cpu(&new_xh->xh_count, -1);\n\t\t\tif (new_xh->xh_count) {\n\t\t\t\tmemmove(xe, xe + 1,\n\t\t\t\t\t(void *)last - (void *)xe);\n\t\t\t\tmemset(last, 0,\n\t\t\t\t       sizeof(struct ocfs2_xattr_entry));\n\t\t\t}\n\n\t\t\t \n\t\t\tj--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ocfs2_xattr_is_local(xe))\n\t\t\tcontinue;\n\n\t\tret = func(sb, old_bh, xh, i, &xv, NULL, para);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = func(sb, new_bh, new_xh, j, &new_xv, &value_bh, para);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (xv->xr_list.l_tree_depth) {\n\t\t\tmemcpy(new_xv, &def_xv, OCFS2_XATTR_ROOT_SIZE);\n\t\t\tvb->vb_xv = new_xv;\n\t\t\tvb->vb_bh = value_bh;\n\t\t\tocfs2_init_xattr_value_extent_tree(&data_et,\n\t\t\t\t\tINODE_CACHE(args->new_inode), vb);\n\t\t}\n\n\t\tclusters = le32_to_cpu(xv->xr_clusters);\n\t\tcpos = 0;\n\t\twhile (cpos < clusters) {\n\t\t\tret = ocfs2_xattr_get_clusters(args->old_inode,\n\t\t\t\t\t\t       cpos,\n\t\t\t\t\t\t       &p_cluster,\n\t\t\t\t\t\t       &num_clusters,\n\t\t\t\t\t\t       &xv->xr_list,\n\t\t\t\t\t\t       &ext_flags);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tBUG_ON(!p_cluster);\n\n\t\t\tif (xv->xr_list.l_tree_depth) {\n\t\t\t\tret = ocfs2_insert_extent(handle,\n\t\t\t\t\t\t&data_et, cpos,\n\t\t\t\t\t\tocfs2_clusters_to_blocks(\n\t\t\t\t\t\t\targs->old_inode->i_sb,\n\t\t\t\t\t\t\tp_cluster),\n\t\t\t\t\t\tnum_clusters, ext_flags,\n\t\t\t\t\t\tmeta_ac);\n\t\t\t\tif (ret) {\n\t\t\t\t\tmlog_errno(ret);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tret = ocfs2_increase_refcount(handle, args->ref_ci,\n\t\t\t\t\t\t      args->ref_root_bh,\n\t\t\t\t\t\t      p_cluster, num_clusters,\n\t\t\t\t\t\t      meta_ac, args->dealloc);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tcpos += num_clusters;\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}\n\nstatic int ocfs2_reflink_xattr_inline(struct ocfs2_xattr_reflink *args)\n{\n\tint ret = 0, credits = 0;\n\thandle_t *handle;\n\tstruct ocfs2_super *osb = OCFS2_SB(args->old_inode->i_sb);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)args->old_bh->b_data;\n\tint inline_size = le16_to_cpu(di->i_xattr_inline_size);\n\tint header_off = osb->sb->s_blocksize - inline_size;\n\tstruct ocfs2_xattr_header *xh = (struct ocfs2_xattr_header *)\n\t\t\t\t\t(args->old_bh->b_data + header_off);\n\tstruct ocfs2_xattr_header *new_xh = (struct ocfs2_xattr_header *)\n\t\t\t\t\t(args->new_bh->b_data + header_off);\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\tstruct ocfs2_inode_info *new_oi;\n\tstruct ocfs2_dinode *new_di;\n\tstruct ocfs2_xattr_value_buf vb = {\n\t\t.vb_bh = args->new_bh,\n\t\t.vb_access = ocfs2_journal_access_di,\n\t};\n\n\tret = ocfs2_reflink_lock_xattr_allocators(osb, xh, args->ref_root_bh,\n\t\t\t\t\t\t  &credits, &meta_ac);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(args->new_inode),\n\t\t\t\t      args->new_bh, OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tmemcpy(args->new_bh->b_data + header_off,\n\t       args->old_bh->b_data + header_off, inline_size);\n\n\tnew_di = (struct ocfs2_dinode *)args->new_bh->b_data;\n\tnew_di->i_xattr_inline_size = cpu_to_le16(inline_size);\n\n\tret = ocfs2_reflink_xattr_header(handle, args, args->old_bh, xh,\n\t\t\t\t\t args->new_bh, new_xh, &vb, meta_ac,\n\t\t\t\t\t ocfs2_get_xattr_value_root, NULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tnew_oi = OCFS2_I(args->new_inode);\n\t \n\tif (!(new_oi->ip_dyn_features & OCFS2_INLINE_DATA_FL) &&\n\t    !(ocfs2_inode_is_fast_symlink(args->new_inode))) {\n\t\tstruct ocfs2_extent_list *el = &new_di->id2.i_list;\n\t\tle16_add_cpu(&el->l_count, -(inline_size /\n\t\t\t\t\tsizeof(struct ocfs2_extent_rec)));\n\t}\n\tspin_lock(&new_oi->ip_lock);\n\tnew_oi->ip_dyn_features |= OCFS2_HAS_XATTR_FL | OCFS2_INLINE_XATTR_FL;\n\tnew_di->i_dyn_features = cpu_to_le16(new_oi->ip_dyn_features);\n\tspin_unlock(&new_oi->ip_lock);\n\n\tocfs2_journal_dirty(handle, args->new_bh);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\nout:\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\treturn ret;\n}\n\nstatic int ocfs2_create_empty_xattr_block(struct inode *inode,\n\t\t\t\t\t  struct buffer_head *fe_bh,\n\t\t\t\t\t  struct buffer_head **ret_bh,\n\t\t\t\t\t  int indexed)\n{\n\tint ret;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_xattr_set_ctxt ctxt;\n\n\tmemset(&ctxt, 0, sizeof(ctxt));\n\tret = ocfs2_reserve_new_metadata_blocks(osb, 1, &ctxt.meta_ac);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tctxt.handle = ocfs2_start_trans(osb, OCFS2_XATTR_BLOCK_CREATE_CREDITS);\n\tif (IS_ERR(ctxt.handle)) {\n\t\tret = PTR_ERR(ctxt.handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_create_empty_xattr_block(\n\t\t\t\t(unsigned long long)fe_bh->b_blocknr, indexed);\n\tret = ocfs2_create_xattr_block(inode, fe_bh, &ctxt, indexed,\n\t\t\t\t       ret_bh);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\tocfs2_commit_trans(osb, ctxt.handle);\nout:\n\tocfs2_free_alloc_context(ctxt.meta_ac);\n\treturn ret;\n}\n\nstatic int ocfs2_reflink_xattr_block(struct ocfs2_xattr_reflink *args,\n\t\t\t\t     struct buffer_head *blk_bh,\n\t\t\t\t     struct buffer_head *new_blk_bh)\n{\n\tint ret = 0, credits = 0;\n\thandle_t *handle;\n\tstruct ocfs2_inode_info *new_oi = OCFS2_I(args->new_inode);\n\tstruct ocfs2_dinode *new_di;\n\tstruct ocfs2_super *osb = OCFS2_SB(args->new_inode->i_sb);\n\tint header_off = offsetof(struct ocfs2_xattr_block, xb_attrs.xb_header);\n\tstruct ocfs2_xattr_block *xb =\n\t\t\t(struct ocfs2_xattr_block *)blk_bh->b_data;\n\tstruct ocfs2_xattr_header *xh = &xb->xb_attrs.xb_header;\n\tstruct ocfs2_xattr_block *new_xb =\n\t\t\t(struct ocfs2_xattr_block *)new_blk_bh->b_data;\n\tstruct ocfs2_xattr_header *new_xh = &new_xb->xb_attrs.xb_header;\n\tstruct ocfs2_alloc_context *meta_ac;\n\tstruct ocfs2_xattr_value_buf vb = {\n\t\t.vb_bh = new_blk_bh,\n\t\t.vb_access = ocfs2_journal_access_xb,\n\t};\n\n\tret = ocfs2_reflink_lock_xattr_allocators(osb, xh, args->ref_root_bh,\n\t\t\t\t\t\t  &credits, &meta_ac);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t \n\thandle = ocfs2_start_trans(osb, credits + 1);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (!(new_oi->ip_dyn_features & OCFS2_HAS_XATTR_FL)) {\n\t\tret = ocfs2_journal_access_di(handle,\n\t\t\t\t\t      INODE_CACHE(args->new_inode),\n\t\t\t\t\t      args->new_bh,\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\t}\n\n\tret = ocfs2_journal_access_xb(handle, INODE_CACHE(args->new_inode),\n\t\t\t\t      new_blk_bh, OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tmemcpy(new_blk_bh->b_data + header_off, blk_bh->b_data + header_off,\n\t       osb->sb->s_blocksize - header_off);\n\n\tret = ocfs2_reflink_xattr_header(handle, args, blk_bh, xh,\n\t\t\t\t\t new_blk_bh, new_xh, &vb, meta_ac,\n\t\t\t\t\t ocfs2_get_xattr_value_root, NULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tocfs2_journal_dirty(handle, new_blk_bh);\n\n\tif (!(new_oi->ip_dyn_features & OCFS2_HAS_XATTR_FL)) {\n\t\tnew_di = (struct ocfs2_dinode *)args->new_bh->b_data;\n\t\tspin_lock(&new_oi->ip_lock);\n\t\tnew_oi->ip_dyn_features |= OCFS2_HAS_XATTR_FL;\n\t\tnew_di->i_dyn_features = cpu_to_le16(new_oi->ip_dyn_features);\n\t\tspin_unlock(&new_oi->ip_lock);\n\n\t\tocfs2_journal_dirty(handle, args->new_bh);\n\t}\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\nout:\n\tocfs2_free_alloc_context(meta_ac);\n\treturn ret;\n}\n\nstruct ocfs2_reflink_xattr_tree_args {\n\tstruct ocfs2_xattr_reflink *reflink;\n\tstruct buffer_head *old_blk_bh;\n\tstruct buffer_head *new_blk_bh;\n\tstruct ocfs2_xattr_bucket *old_bucket;\n\tstruct ocfs2_xattr_bucket *new_bucket;\n};\n\n \nstatic int ocfs2_get_reflink_xattr_value_root(struct super_block *sb,\n\t\t\t\t\tstruct buffer_head *bh,\n\t\t\t\t\tstruct ocfs2_xattr_header *xh,\n\t\t\t\t\tint offset,\n\t\t\t\t\tstruct ocfs2_xattr_value_root **xv,\n\t\t\t\t\tstruct buffer_head **ret_bh,\n\t\t\t\t\tvoid *para)\n{\n\tstruct ocfs2_reflink_xattr_tree_args *args =\n\t\t\t(struct ocfs2_reflink_xattr_tree_args *)para;\n\tstruct ocfs2_xattr_bucket *bucket;\n\n\tif (bh == args->old_bucket->bu_bhs[0])\n\t\tbucket = args->old_bucket;\n\telse\n\t\tbucket = args->new_bucket;\n\n\treturn ocfs2_get_xattr_tree_value_root(sb, bucket, offset,\n\t\t\t\t\t       xv, ret_bh);\n}\n\nstruct ocfs2_value_tree_metas {\n\tint num_metas;\n\tint credits;\n\tint num_recs;\n};\n\nstatic int ocfs2_value_tree_metas_in_bucket(struct super_block *sb,\n\t\t\t\t\tstruct buffer_head *bh,\n\t\t\t\t\tstruct ocfs2_xattr_header *xh,\n\t\t\t\t\tint offset,\n\t\t\t\t\tstruct ocfs2_xattr_value_root **xv,\n\t\t\t\t\tstruct buffer_head **ret_bh,\n\t\t\t\t\tvoid *para)\n{\n\tstruct ocfs2_xattr_bucket *bucket =\n\t\t\t\t(struct ocfs2_xattr_bucket *)para;\n\n\treturn ocfs2_get_xattr_tree_value_root(sb, bucket, offset,\n\t\t\t\t\t       xv, ret_bh);\n}\n\nstatic int ocfs2_calc_value_tree_metas(struct inode *inode,\n\t\t\t\t      struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t      void *para)\n{\n\tstruct ocfs2_value_tree_metas *metas =\n\t\t\t(struct ocfs2_value_tree_metas *)para;\n\tstruct ocfs2_xattr_header *xh =\n\t\t\t(struct ocfs2_xattr_header *)bucket->bu_bhs[0]->b_data;\n\n\t \n\tmetas->credits += bucket->bu_blocks;\n\treturn ocfs2_value_metas_in_xattr_header(inode->i_sb, bucket->bu_bhs[0],\n\t\t\t\t\txh, &metas->num_metas,\n\t\t\t\t\t&metas->credits, &metas->num_recs,\n\t\t\t\t\tocfs2_value_tree_metas_in_bucket,\n\t\t\t\t\tbucket);\n}\n\n \nstatic int ocfs2_lock_reflink_xattr_rec_allocators(\n\t\t\t\tstruct ocfs2_reflink_xattr_tree_args *args,\n\t\t\t\tstruct ocfs2_extent_tree *xt_et,\n\t\t\t\tu64 blkno, u32 len, int *credits,\n\t\t\t\tstruct ocfs2_alloc_context **meta_ac,\n\t\t\t\tstruct ocfs2_alloc_context **data_ac)\n{\n\tint ret, num_free_extents;\n\tstruct ocfs2_value_tree_metas metas;\n\tstruct ocfs2_super *osb = OCFS2_SB(args->reflink->old_inode->i_sb);\n\tstruct ocfs2_refcount_block *rb;\n\n\tmemset(&metas, 0, sizeof(metas));\n\n\tret = ocfs2_iterate_xattr_buckets(args->reflink->old_inode, blkno, len,\n\t\t\t\t\t  ocfs2_calc_value_tree_metas, &metas);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t*credits = metas.credits;\n\n\t \n\trb = (struct ocfs2_refcount_block *)args->reflink->ref_root_bh->b_data;\n\tmetas.num_recs =\n\t\t(metas.num_recs + ocfs2_refcount_recs_per_rb(osb->sb) - 1) /\n\t\t ocfs2_refcount_recs_per_rb(osb->sb) * 2;\n\tmetas.num_metas += metas.num_recs;\n\t*credits += metas.num_recs +\n\t\t    metas.num_recs * OCFS2_EXPAND_REFCOUNT_TREE_CREDITS;\n\tif (le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL)\n\t\t*credits += le16_to_cpu(rb->rf_list.l_tree_depth) *\n\t\t\t    le16_to_cpu(rb->rf_list.l_next_free_rec) + 1;\n\telse\n\t\t*credits += 1;\n\n\t \n\tnum_free_extents = ocfs2_num_free_extents(xt_et);\n\tif (num_free_extents < 0) {\n\t\tret = num_free_extents;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (num_free_extents < len)\n\t\tmetas.num_metas += ocfs2_extend_meta_needed(xt_et->et_root_el);\n\n\t*credits += ocfs2_calc_extend_credits(osb->sb,\n\t\t\t\t\t      xt_et->et_root_el);\n\n\tif (metas.num_metas) {\n\t\tret = ocfs2_reserve_new_metadata_blocks(osb, metas.num_metas,\n\t\t\t\t\t\t\tmeta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (len) {\n\t\tret = ocfs2_reserve_clusters(osb, len, data_ac);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\nout:\n\tif (ret) {\n\t\tif (*meta_ac) {\n\t\t\tocfs2_free_alloc_context(*meta_ac);\n\t\t\t*meta_ac = NULL;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int ocfs2_reflink_xattr_bucket(handle_t *handle,\n\t\t\t\tu64 blkno, u64 new_blkno, u32 clusters,\n\t\t\t\tu32 *cpos, int num_buckets,\n\t\t\t\tstruct ocfs2_alloc_context *meta_ac,\n\t\t\t\tstruct ocfs2_alloc_context *data_ac,\n\t\t\t\tstruct ocfs2_reflink_xattr_tree_args *args)\n{\n\tint i, j, ret = 0;\n\tstruct super_block *sb = args->reflink->old_inode->i_sb;\n\tint bpb = args->old_bucket->bu_blocks;\n\tstruct ocfs2_xattr_value_buf vb = {\n\t\t.vb_access = ocfs2_journal_access,\n\t};\n\n\tfor (i = 0; i < num_buckets; i++, blkno += bpb, new_blkno += bpb) {\n\t\tret = ocfs2_read_xattr_bucket(args->old_bucket, blkno);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = ocfs2_init_xattr_bucket(args->new_bucket, new_blkno, 1);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = ocfs2_xattr_bucket_journal_access(handle,\n\t\t\t\t\t\targs->new_bucket,\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_CREATE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (j = 0; j < bpb; j++)\n\t\t\tmemcpy(bucket_block(args->new_bucket, j),\n\t\t\t       bucket_block(args->old_bucket, j),\n\t\t\t       sb->s_blocksize);\n\n\t\t \n\t\tif (i == 0) {\n\t\t\t*cpos = le32_to_cpu(bucket_xh(args->new_bucket)->\n\t\t\t\t\t    xh_entries[0].xe_name_hash);\n\t\t\tbucket_xh(args->new_bucket)->xh_num_buckets =\n\t\t\t\tcpu_to_le16(num_buckets);\n\t\t}\n\n\t\tocfs2_xattr_bucket_journal_dirty(handle, args->new_bucket);\n\n\t\tret = ocfs2_reflink_xattr_header(handle, args->reflink,\n\t\t\t\t\targs->old_bucket->bu_bhs[0],\n\t\t\t\t\tbucket_xh(args->old_bucket),\n\t\t\t\t\targs->new_bucket->bu_bhs[0],\n\t\t\t\t\tbucket_xh(args->new_bucket),\n\t\t\t\t\t&vb, meta_ac,\n\t\t\t\t\tocfs2_get_reflink_xattr_value_root,\n\t\t\t\t\targs);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tret = ocfs2_xattr_bucket_journal_access(handle,\n\t\t\t\t\t\targs->new_bucket,\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tocfs2_xattr_bucket_journal_dirty(handle, args->new_bucket);\n\n\t\tocfs2_xattr_bucket_relse(args->old_bucket);\n\t\tocfs2_xattr_bucket_relse(args->new_bucket);\n\t}\n\n\tocfs2_xattr_bucket_relse(args->old_bucket);\n\tocfs2_xattr_bucket_relse(args->new_bucket);\n\treturn ret;\n}\n\nstatic int ocfs2_reflink_xattr_buckets(handle_t *handle,\n\t\t\t\tstruct inode *inode,\n\t\t\t\tstruct ocfs2_reflink_xattr_tree_args *args,\n\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\tstruct ocfs2_alloc_context *meta_ac,\n\t\t\t\tstruct ocfs2_alloc_context *data_ac,\n\t\t\t\tu64 blkno, u32 cpos, u32 len)\n{\n\tint ret, first_inserted = 0;\n\tu32 p_cluster, num_clusters, reflink_cpos = 0;\n\tu64 new_blkno;\n\tunsigned int num_buckets, reflink_buckets;\n\tunsigned int bpc =\n\t\tocfs2_xattr_buckets_per_cluster(OCFS2_SB(inode->i_sb));\n\n\tret = ocfs2_read_xattr_bucket(args->old_bucket, blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tnum_buckets = le16_to_cpu(bucket_xh(args->old_bucket)->xh_num_buckets);\n\tocfs2_xattr_bucket_relse(args->old_bucket);\n\n\twhile (len && num_buckets) {\n\t\tret = ocfs2_claim_clusters(handle, data_ac,\n\t\t\t\t\t   1, &p_cluster, &num_clusters);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tnew_blkno = ocfs2_clusters_to_blocks(inode->i_sb, p_cluster);\n\t\treflink_buckets = min(num_buckets, bpc * num_clusters);\n\n\t\tret = ocfs2_reflink_xattr_bucket(handle, blkno,\n\t\t\t\t\t\t new_blkno, num_clusters,\n\t\t\t\t\t\t &reflink_cpos, reflink_buckets,\n\t\t\t\t\t\t meta_ac, data_ac, args);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif (!first_inserted) {\n\t\t\treflink_cpos = cpos;\n\t\t\tfirst_inserted = 1;\n\t\t}\n\t\tret = ocfs2_insert_extent(handle, et, reflink_cpos, new_blkno,\n\t\t\t\t\t  num_clusters, 0, meta_ac);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\n\t\ttrace_ocfs2_reflink_xattr_buckets((unsigned long long)new_blkno,\n\t\t\t\t\t\t  num_clusters, reflink_cpos);\n\n\t\tlen -= num_clusters;\n\t\tblkno += ocfs2_clusters_to_blocks(inode->i_sb, num_clusters);\n\t\tnum_buckets -= reflink_buckets;\n\t}\nout:\n\treturn ret;\n}\n\n \nstatic int ocfs2_reflink_xattr_rec(struct inode *inode,\n\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t   u64 blkno,\n\t\t\t\t   u32 cpos,\n\t\t\t\t   u32 len,\n\t\t\t\t   void *para)\n{\n\tint ret, credits = 0;\n\thandle_t *handle;\n\tstruct ocfs2_reflink_xattr_tree_args *args =\n\t\t\t(struct ocfs2_reflink_xattr_tree_args *)para;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\tstruct ocfs2_alloc_context *data_ac = NULL;\n\tstruct ocfs2_extent_tree et;\n\n\ttrace_ocfs2_reflink_xattr_rec((unsigned long long)blkno, len);\n\n\tocfs2_init_xattr_tree_extent_tree(&et,\n\t\t\t\t\t  INODE_CACHE(args->reflink->new_inode),\n\t\t\t\t\t  args->new_blk_bh);\n\n\tret = ocfs2_lock_reflink_xattr_rec_allocators(args, &et, blkno,\n\t\t\t\t\t\t      len, &credits,\n\t\t\t\t\t\t      &meta_ac, &data_ac);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_reflink_xattr_buckets(handle, inode, args, &et,\n\t\t\t\t\t  meta_ac, data_ac,\n\t\t\t\t\t  blkno, cpos, len);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\tocfs2_commit_trans(osb, handle);\n\nout:\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\tif (data_ac)\n\t\tocfs2_free_alloc_context(data_ac);\n\treturn ret;\n}\n\n \nstatic int ocfs2_reflink_xattr_tree(struct ocfs2_xattr_reflink *args,\n\t\t\t\t    struct buffer_head *blk_bh,\n\t\t\t\t    struct buffer_head *new_blk_bh)\n{\n\tint ret;\n\tstruct ocfs2_reflink_xattr_tree_args para;\n\n\tmemset(&para, 0, sizeof(para));\n\tpara.reflink = args;\n\tpara.old_blk_bh = blk_bh;\n\tpara.new_blk_bh = new_blk_bh;\n\n\tpara.old_bucket = ocfs2_xattr_bucket_new(args->old_inode);\n\tif (!para.old_bucket) {\n\t\tmlog_errno(-ENOMEM);\n\t\treturn -ENOMEM;\n\t}\n\n\tpara.new_bucket = ocfs2_xattr_bucket_new(args->new_inode);\n\tif (!para.new_bucket) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_iterate_xattr_index_block(args->old_inode, blk_bh,\n\t\t\t\t\t      ocfs2_reflink_xattr_rec,\n\t\t\t\t\t      &para);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tocfs2_xattr_bucket_free(para.old_bucket);\n\tocfs2_xattr_bucket_free(para.new_bucket);\n\treturn ret;\n}\n\nstatic int ocfs2_reflink_xattr_in_block(struct ocfs2_xattr_reflink *args,\n\t\t\t\t\tstruct buffer_head *blk_bh)\n{\n\tint ret, indexed = 0;\n\tstruct buffer_head *new_blk_bh = NULL;\n\tstruct ocfs2_xattr_block *xb =\n\t\t\t(struct ocfs2_xattr_block *)blk_bh->b_data;\n\n\n\tif (le16_to_cpu(xb->xb_flags) & OCFS2_XATTR_INDEXED)\n\t\tindexed = 1;\n\n\tret = ocfs2_create_empty_xattr_block(args->new_inode, args->new_bh,\n\t\t\t\t\t     &new_blk_bh, indexed);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (!indexed)\n\t\tret = ocfs2_reflink_xattr_block(args, blk_bh, new_blk_bh);\n\telse\n\t\tret = ocfs2_reflink_xattr_tree(args, blk_bh, new_blk_bh);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tbrelse(new_blk_bh);\n\treturn ret;\n}\n\nstatic int ocfs2_reflink_xattr_no_security(struct ocfs2_xattr_entry *xe)\n{\n\tint type = ocfs2_xattr_get_type(xe);\n\n\treturn type != OCFS2_XATTR_INDEX_SECURITY &&\n\t       type != OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS &&\n\t       type != OCFS2_XATTR_INDEX_POSIX_ACL_DEFAULT;\n}\n\nint ocfs2_reflink_xattrs(struct inode *old_inode,\n\t\t\t struct buffer_head *old_bh,\n\t\t\t struct inode *new_inode,\n\t\t\t struct buffer_head *new_bh,\n\t\t\t bool preserve_security)\n{\n\tint ret;\n\tstruct ocfs2_xattr_reflink args;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(old_inode);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)old_bh->b_data;\n\tstruct buffer_head *blk_bh = NULL;\n\tstruct ocfs2_cached_dealloc_ctxt dealloc;\n\tstruct ocfs2_refcount_tree *ref_tree;\n\tstruct buffer_head *ref_root_bh = NULL;\n\n\tret = ocfs2_lock_refcount_tree(OCFS2_SB(old_inode->i_sb),\n\t\t\t\t       le64_to_cpu(di->i_refcount_loc),\n\t\t\t\t       1, &ref_tree, &ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_init_dealloc_ctxt(&dealloc);\n\n\targs.old_inode = old_inode;\n\targs.new_inode = new_inode;\n\targs.old_bh = old_bh;\n\targs.new_bh = new_bh;\n\targs.ref_ci = &ref_tree->rf_ci;\n\targs.ref_root_bh = ref_root_bh;\n\targs.dealloc = &dealloc;\n\tif (preserve_security)\n\t\targs.xattr_reflinked = NULL;\n\telse\n\t\targs.xattr_reflinked = ocfs2_reflink_xattr_no_security;\n\n\tif (oi->ip_dyn_features & OCFS2_INLINE_XATTR_FL) {\n\t\tret = ocfs2_reflink_xattr_inline(&args);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tif (!di->i_xattr_loc)\n\t\tgoto out_unlock;\n\n\tret = ocfs2_read_xattr_block(old_inode, le64_to_cpu(di->i_xattr_loc),\n\t\t\t\t     &blk_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out_unlock;\n\t}\n\n\tret = ocfs2_reflink_xattr_in_block(&args, blk_bh);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\tbrelse(blk_bh);\n\nout_unlock:\n\tocfs2_unlock_refcount_tree(OCFS2_SB(old_inode->i_sb),\n\t\t\t\t   ref_tree, 1);\n\tbrelse(ref_root_bh);\n\n\tif (ocfs2_dealloc_has_cluster(&dealloc)) {\n\t\tocfs2_schedule_truncate_log_flush(OCFS2_SB(old_inode->i_sb), 1);\n\t\tocfs2_run_deallocs(OCFS2_SB(old_inode->i_sb), &dealloc);\n\t}\n\nout:\n\treturn ret;\n}\n\n \nint ocfs2_init_security_and_acl(struct inode *dir,\n\t\t\t\tstruct inode *inode,\n\t\t\t\tconst struct qstr *qstr)\n{\n\tint ret = 0;\n\tstruct buffer_head *dir_bh = NULL;\n\n\tret = ocfs2_init_security_get(inode, dir, qstr, NULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\n\tret = ocfs2_inode_lock(dir, &dir_bh, 0);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\tret = ocfs2_init_acl(NULL, inode, dir, NULL, dir_bh, NULL, NULL);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\tocfs2_inode_unlock(dir, 0);\n\tbrelse(dir_bh);\nleave:\n\treturn ret;\n}\n\n \nstatic int ocfs2_xattr_security_get(const struct xattr_handler *handler,\n\t\t\t\t    struct dentry *unused, struct inode *inode,\n\t\t\t\t    const char *name, void *buffer, size_t size)\n{\n\treturn ocfs2_xattr_get(inode, OCFS2_XATTR_INDEX_SECURITY,\n\t\t\t       name, buffer, size);\n}\n\nstatic int ocfs2_xattr_security_set(const struct xattr_handler *handler,\n\t\t\t\t    struct mnt_idmap *idmap,\n\t\t\t\t    struct dentry *unused, struct inode *inode,\n\t\t\t\t    const char *name, const void *value,\n\t\t\t\t    size_t size, int flags)\n{\n\treturn ocfs2_xattr_set(inode, OCFS2_XATTR_INDEX_SECURITY,\n\t\t\t       name, value, size, flags);\n}\n\nstatic int ocfs2_initxattrs(struct inode *inode, const struct xattr *xattr_array,\n\t\t     void *fs_info)\n{\n\tstruct ocfs2_security_xattr_info *si = fs_info;\n\tconst struct xattr *xattr;\n\tint err = 0;\n\n\tif (si) {\n\t\tsi->value = kmemdup(xattr_array->value, xattr_array->value_len,\n\t\t\t\t    GFP_KERNEL);\n\t\tif (!si->value)\n\t\t\treturn -ENOMEM;\n\n\t\tsi->name = xattr_array->name;\n\t\tsi->value_len = xattr_array->value_len;\n\t\treturn 0;\n\t}\n\n\tfor (xattr = xattr_array; xattr->name != NULL; xattr++) {\n\t\terr = ocfs2_xattr_set(inode, OCFS2_XATTR_INDEX_SECURITY,\n\t\t\t\t      xattr->name, xattr->value,\n\t\t\t\t      xattr->value_len, XATTR_CREATE);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\treturn err;\n}\n\nint ocfs2_init_security_get(struct inode *inode,\n\t\t\t    struct inode *dir,\n\t\t\t    const struct qstr *qstr,\n\t\t\t    struct ocfs2_security_xattr_info *si)\n{\n\tint ret;\n\n\t \n\tif (!ocfs2_supports_xattr(OCFS2_SB(dir->i_sb)))\n\t\treturn -EOPNOTSUPP;\n\tif (si) {\n\t\tret = security_inode_init_security(inode, dir, qstr,\n\t\t\t\t\t\t   &ocfs2_initxattrs, si);\n\t\t \n\t\tif (!ret && !si->name)\n\t\t\tsi->enable = 0;\n\n\t\treturn ret;\n\t}\n\n\treturn security_inode_init_security(inode, dir, qstr,\n\t\t\t\t\t    &ocfs2_initxattrs, NULL);\n}\n\nint ocfs2_init_security_set(handle_t *handle,\n\t\t\t    struct inode *inode,\n\t\t\t    struct buffer_head *di_bh,\n\t\t\t    struct ocfs2_security_xattr_info *si,\n\t\t\t    struct ocfs2_alloc_context *xattr_ac,\n\t\t\t    struct ocfs2_alloc_context *data_ac)\n{\n\treturn ocfs2_xattr_set_handle(handle, inode, di_bh,\n\t\t\t\t     OCFS2_XATTR_INDEX_SECURITY,\n\t\t\t\t     si->name, si->value, si->value_len, 0,\n\t\t\t\t     xattr_ac, data_ac);\n}\n\nconst struct xattr_handler ocfs2_xattr_security_handler = {\n\t.prefix\t= XATTR_SECURITY_PREFIX,\n\t.get\t= ocfs2_xattr_security_get,\n\t.set\t= ocfs2_xattr_security_set,\n};\n\n \nstatic int ocfs2_xattr_trusted_get(const struct xattr_handler *handler,\n\t\t\t\t   struct dentry *unused, struct inode *inode,\n\t\t\t\t   const char *name, void *buffer, size_t size)\n{\n\treturn ocfs2_xattr_get(inode, OCFS2_XATTR_INDEX_TRUSTED,\n\t\t\t       name, buffer, size);\n}\n\nstatic int ocfs2_xattr_trusted_set(const struct xattr_handler *handler,\n\t\t\t\t   struct mnt_idmap *idmap,\n\t\t\t\t   struct dentry *unused, struct inode *inode,\n\t\t\t\t   const char *name, const void *value,\n\t\t\t\t   size_t size, int flags)\n{\n\treturn ocfs2_xattr_set(inode, OCFS2_XATTR_INDEX_TRUSTED,\n\t\t\t       name, value, size, flags);\n}\n\nconst struct xattr_handler ocfs2_xattr_trusted_handler = {\n\t.prefix\t= XATTR_TRUSTED_PREFIX,\n\t.get\t= ocfs2_xattr_trusted_get,\n\t.set\t= ocfs2_xattr_trusted_set,\n};\n\n \nstatic int ocfs2_xattr_user_get(const struct xattr_handler *handler,\n\t\t\t\tstruct dentry *unused, struct inode *inode,\n\t\t\t\tconst char *name, void *buffer, size_t size)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (osb->s_mount_opt & OCFS2_MOUNT_NOUSERXATTR)\n\t\treturn -EOPNOTSUPP;\n\treturn ocfs2_xattr_get(inode, OCFS2_XATTR_INDEX_USER, name,\n\t\t\t       buffer, size);\n}\n\nstatic int ocfs2_xattr_user_set(const struct xattr_handler *handler,\n\t\t\t\tstruct mnt_idmap *idmap,\n\t\t\t\tstruct dentry *unused, struct inode *inode,\n\t\t\t\tconst char *name, const void *value,\n\t\t\t\tsize_t size, int flags)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (osb->s_mount_opt & OCFS2_MOUNT_NOUSERXATTR)\n\t\treturn -EOPNOTSUPP;\n\n\treturn ocfs2_xattr_set(inode, OCFS2_XATTR_INDEX_USER,\n\t\t\t       name, value, size, flags);\n}\n\nconst struct xattr_handler ocfs2_xattr_user_handler = {\n\t.prefix\t= XATTR_USER_PREFIX,\n\t.get\t= ocfs2_xattr_user_get,\n\t.set\t= ocfs2_xattr_user_set,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}