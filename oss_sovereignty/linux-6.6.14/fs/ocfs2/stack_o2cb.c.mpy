{
  "module_name": "stack_o2cb.c",
  "hash_id": "a57a52655b95d30b437eee9bfa64c0bffd53cef3982d9fc7df6e82b355179363",
  "original_prompt": "Ingested from linux-6.6.14/fs/ocfs2/stack_o2cb.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n \n#include <linux/fs.h>\n\n#include \"cluster/masklog.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include \"cluster/tcp.h\"\n\n#include \"stackglue.h\"\n\nstruct o2dlm_private {\n\tstruct dlm_eviction_cb op_eviction_cb;\n};\n\nstatic struct ocfs2_stack_plugin o2cb_stack;\n\n \n#if (DLM_LOCK_IV != LKM_IVMODE)\n# error Lock modes do not match\n#endif\n#if (DLM_LOCK_NL != LKM_NLMODE)\n# error Lock modes do not match\n#endif\n#if (DLM_LOCK_CR != LKM_CRMODE)\n# error Lock modes do not match\n#endif\n#if (DLM_LOCK_CW != LKM_CWMODE)\n# error Lock modes do not match\n#endif\n#if (DLM_LOCK_PR != LKM_PRMODE)\n# error Lock modes do not match\n#endif\n#if (DLM_LOCK_PW != LKM_PWMODE)\n# error Lock modes do not match\n#endif\n#if (DLM_LOCK_EX != LKM_EXMODE)\n# error Lock modes do not match\n#endif\nstatic inline int mode_to_o2dlm(int mode)\n{\n\tBUG_ON(mode > LKM_MAXMODE);\n\n\treturn mode;\n}\n\nstatic int flags_to_o2dlm(u32 flags)\n{\n\tint o2dlm_flags = 0;\n\n\tif (flags & DLM_LKF_NOQUEUE)\n\t\to2dlm_flags |= LKM_NOQUEUE;\n\tif (flags & DLM_LKF_CANCEL)\n\t\to2dlm_flags |= LKM_CANCEL;\n\tif (flags & DLM_LKF_CONVERT)\n\t\to2dlm_flags |= LKM_CONVERT;\n\tif (flags & DLM_LKF_VALBLK)\n\t\to2dlm_flags |= LKM_VALBLK;\n\tif (flags & DLM_LKF_IVVALBLK)\n\t\to2dlm_flags |= LKM_INVVALBLK;\n\tif (flags & DLM_LKF_ORPHAN)\n\t\to2dlm_flags |= LKM_ORPHAN;\n\tif (flags & DLM_LKF_FORCEUNLOCK)\n\t\to2dlm_flags |= LKM_FORCE;\n\tif (flags & DLM_LKF_TIMEOUT)\n\t\to2dlm_flags |= LKM_TIMEOUT;\n\tif (flags & DLM_LKF_LOCAL)\n\t\to2dlm_flags |= LKM_LOCAL;\n\n\treturn o2dlm_flags;\n}\n\n \n \nstatic int status_map[] = {\n\t[DLM_NORMAL]\t\t\t= 0,\t\t \n\t[DLM_GRANTED]\t\t\t= -EINVAL,\n\t[DLM_DENIED]\t\t\t= -EACCES,\n\t[DLM_DENIED_NOLOCKS]\t\t= -EACCES,\n\t[DLM_WORKING]\t\t\t= -EACCES,\n\t[DLM_BLOCKED]\t\t\t= -EINVAL,\n\t[DLM_BLOCKED_ORPHAN]\t\t= -EINVAL,\n\t[DLM_DENIED_GRACE_PERIOD]\t= -EACCES,\n\t[DLM_SYSERR]\t\t\t= -ENOMEM,\t \n\t[DLM_NOSUPPORT]\t\t\t= -EPROTO,\n\t[DLM_CANCELGRANT]\t\t= -EBUSY,\t \n\t[DLM_IVLOCKID]\t\t\t= -EINVAL,\n\t[DLM_SYNC]\t\t\t= -EINVAL,\n\t[DLM_BADTYPE]\t\t\t= -EINVAL,\n\t[DLM_BADRESOURCE]\t\t= -EINVAL,\n\t[DLM_MAXHANDLES]\t\t= -ENOMEM,\n\t[DLM_NOCLINFO]\t\t\t= -EINVAL,\n\t[DLM_NOLOCKMGR]\t\t\t= -EINVAL,\n\t[DLM_NOPURGED]\t\t\t= -EINVAL,\n\t[DLM_BADARGS]\t\t\t= -EINVAL,\n\t[DLM_VOID]\t\t\t= -EINVAL,\n\t[DLM_NOTQUEUED]\t\t\t= -EAGAIN,\t \n\t[DLM_IVBUFLEN]\t\t\t= -EINVAL,\n\t[DLM_CVTUNGRANT]\t\t= -EPERM,\n\t[DLM_BADPARAM]\t\t\t= -EINVAL,\n\t[DLM_VALNOTVALID]\t\t= -EINVAL,\n\t[DLM_REJECTED]\t\t\t= -EPERM,\n\t[DLM_ABORT]\t\t\t= -EINVAL,\n\t[DLM_CANCEL]\t\t\t= -DLM_ECANCEL,\t \n\t[DLM_IVRESHANDLE]\t\t= -EINVAL,\n\t[DLM_DEADLOCK]\t\t\t= -EDEADLK,\n\t[DLM_DENIED_NOASTS]\t\t= -EINVAL,\n\t[DLM_FORWARD]\t\t\t= -EINVAL,\n\t[DLM_TIMEOUT]\t\t\t= -ETIMEDOUT,\n\t[DLM_IVGROUPID]\t\t\t= -EINVAL,\n\t[DLM_VERS_CONFLICT]\t\t= -EOPNOTSUPP,\n\t[DLM_BAD_DEVICE_PATH]\t\t= -ENOENT,\n\t[DLM_NO_DEVICE_PERMISSION]\t= -EPERM,\n\t[DLM_NO_CONTROL_DEVICE]\t\t= -ENOENT,\n\t[DLM_RECOVERING]\t\t= -ENOTCONN,\n\t[DLM_MIGRATING]\t\t\t= -ERESTART,\n\t[DLM_MAXSTATS]\t\t\t= -EINVAL,\n};\n\nstatic int dlm_status_to_errno(enum dlm_status status)\n{\n\tBUG_ON(status < 0 || status >= ARRAY_SIZE(status_map));\n\n\treturn status_map[status];\n}\n\nstatic void o2dlm_lock_ast_wrapper(void *astarg)\n{\n\tstruct ocfs2_dlm_lksb *lksb = astarg;\n\n\tlksb->lksb_conn->cc_proto->lp_lock_ast(lksb);\n}\n\nstatic void o2dlm_blocking_ast_wrapper(void *astarg, int level)\n{\n\tstruct ocfs2_dlm_lksb *lksb = astarg;\n\n\tlksb->lksb_conn->cc_proto->lp_blocking_ast(lksb, level);\n}\n\nstatic void o2dlm_unlock_ast_wrapper(void *astarg, enum dlm_status status)\n{\n\tstruct ocfs2_dlm_lksb *lksb = astarg;\n\tint error = dlm_status_to_errno(status);\n\n\t \n\tif (status == DLM_CANCELGRANT)\n\t\treturn;\n\n\tlksb->lksb_conn->cc_proto->lp_unlock_ast(lksb, error);\n}\n\nstatic int o2cb_dlm_lock(struct ocfs2_cluster_connection *conn,\n\t\t\t int mode,\n\t\t\t struct ocfs2_dlm_lksb *lksb,\n\t\t\t u32 flags,\n\t\t\t void *name,\n\t\t\t unsigned int namelen)\n{\n\tenum dlm_status status;\n\tint o2dlm_mode = mode_to_o2dlm(mode);\n\tint o2dlm_flags = flags_to_o2dlm(flags);\n\tint ret;\n\n\tstatus = dlmlock(conn->cc_lockspace, o2dlm_mode, &lksb->lksb_o2dlm,\n\t\t\t o2dlm_flags, name, namelen,\n\t\t\t o2dlm_lock_ast_wrapper, lksb,\n\t\t\t o2dlm_blocking_ast_wrapper);\n\tret = dlm_status_to_errno(status);\n\treturn ret;\n}\n\nstatic int o2cb_dlm_unlock(struct ocfs2_cluster_connection *conn,\n\t\t\t   struct ocfs2_dlm_lksb *lksb,\n\t\t\t   u32 flags)\n{\n\tenum dlm_status status;\n\tint o2dlm_flags = flags_to_o2dlm(flags);\n\tint ret;\n\n\tstatus = dlmunlock(conn->cc_lockspace, &lksb->lksb_o2dlm,\n\t\t\t   o2dlm_flags, o2dlm_unlock_ast_wrapper, lksb);\n\tret = dlm_status_to_errno(status);\n\treturn ret;\n}\n\nstatic int o2cb_dlm_lock_status(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn dlm_status_to_errno(lksb->lksb_o2dlm.status);\n}\n\n \nstatic int o2cb_dlm_lvb_valid(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn 1;\n}\n\nstatic void *o2cb_dlm_lvb(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn (void *)(lksb->lksb_o2dlm.lvb);\n}\n\nstatic void o2cb_dump_lksb(struct ocfs2_dlm_lksb *lksb)\n{\n\tdlm_print_one_lock(lksb->lksb_o2dlm.lockid);\n}\n\n \nstatic int o2cb_cluster_check(void)\n{\n\tu8 node_num;\n\tint i;\n\tunsigned long hbmap[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\tunsigned long netmap[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\n\tnode_num = o2nm_this_node();\n\tif (node_num == O2NM_MAX_NODES) {\n\t\tprintk(KERN_ERR \"o2cb: This node has not been configured.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n#define\tO2CB_MAP_STABILIZE_COUNT\t60\n\tfor (i = 0; i < O2CB_MAP_STABILIZE_COUNT; ++i) {\n\t\to2hb_fill_node_map(hbmap, O2NM_MAX_NODES);\n\t\tif (!test_bit(node_num, hbmap)) {\n\t\t\tprintk(KERN_ERR \"o2cb: %s heartbeat has not been \"\n\t\t\t       \"started.\\n\", (o2hb_global_heartbeat_active() ?\n\t\t\t\t\t      \"Global\" : \"Local\"));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\to2net_fill_node_map(netmap, O2NM_MAX_NODES);\n\t\t \n\t\tset_bit(node_num, netmap);\n\t\tif (bitmap_equal(hbmap, netmap, O2NM_MAX_NODES))\n\t\t\treturn 0;\n\t\tif (i < O2CB_MAP_STABILIZE_COUNT - 1)\n\t\t\tmsleep(1000);\n\t}\n\n\tprintk(KERN_ERR \"o2cb: This node could not connect to nodes:\");\n\ti = -1;\n\twhile ((i = find_next_bit(hbmap, O2NM_MAX_NODES,\n\t\t\t\t  i + 1)) < O2NM_MAX_NODES) {\n\t\tif (!test_bit(i, netmap))\n\t\t\tprintk(\" %u\", i);\n\t}\n\tprintk(\".\\n\");\n\n\treturn -ENOTCONN;\n}\n\n \nstatic void o2dlm_eviction_cb(int node_num, void *data)\n{\n\tstruct ocfs2_cluster_connection *conn = data;\n\n\tprintk(KERN_NOTICE \"o2cb: o2dlm has evicted node %d from domain %.*s\\n\",\n\t       node_num, conn->cc_namelen, conn->cc_name);\n\n\tconn->cc_recovery_handler(node_num, conn->cc_recovery_data);\n}\n\nstatic int o2cb_cluster_connect(struct ocfs2_cluster_connection *conn)\n{\n\tint rc = 0;\n\tu32 dlm_key;\n\tstruct dlm_ctxt *dlm;\n\tstruct o2dlm_private *priv;\n\tstruct dlm_protocol_version fs_version;\n\n\tBUG_ON(conn == NULL);\n\tBUG_ON(conn->cc_proto == NULL);\n\n\t \n\trc = o2cb_cluster_check();\n\tif (rc) {\n\t\tprintk(KERN_ERR \"o2cb: Cluster check failed. Fix errors \"\n\t\t       \"before retrying.\\n\");\n\t\tgoto out;\n\t}\n\n\tpriv = kzalloc(sizeof(struct o2dlm_private), GFP_KERNEL);\n\tif (!priv) {\n\t\trc = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\t \n\tdlm_setup_eviction_cb(&priv->op_eviction_cb, o2dlm_eviction_cb,\n\t\t\t      conn);\n\n\tconn->cc_private = priv;\n\n\t \n\tdlm_key = crc32_le(0, conn->cc_name, conn->cc_namelen);\n\tfs_version.pv_major = conn->cc_version.pv_major;\n\tfs_version.pv_minor = conn->cc_version.pv_minor;\n\n\tdlm = dlm_register_domain(conn->cc_name, dlm_key, &fs_version);\n\tif (IS_ERR(dlm)) {\n\t\trc = PTR_ERR(dlm);\n\t\tmlog_errno(rc);\n\t\tgoto out_free;\n\t}\n\n\tconn->cc_version.pv_major = fs_version.pv_major;\n\tconn->cc_version.pv_minor = fs_version.pv_minor;\n\tconn->cc_lockspace = dlm;\n\n\tdlm_register_eviction_cb(dlm, &priv->op_eviction_cb);\n\nout_free:\n\tif (rc)\n\t\tkfree(conn->cc_private);\n\nout:\n\treturn rc;\n}\n\nstatic int o2cb_cluster_disconnect(struct ocfs2_cluster_connection *conn)\n{\n\tstruct dlm_ctxt *dlm = conn->cc_lockspace;\n\tstruct o2dlm_private *priv = conn->cc_private;\n\n\tdlm_unregister_eviction_cb(&priv->op_eviction_cb);\n\tconn->cc_private = NULL;\n\tkfree(priv);\n\n\tdlm_unregister_domain(dlm);\n\tconn->cc_lockspace = NULL;\n\n\treturn 0;\n}\n\nstatic int o2cb_cluster_this_node(struct ocfs2_cluster_connection *conn,\n\t\t\t\t  unsigned int *node)\n{\n\tint node_num;\n\n\tnode_num = o2nm_this_node();\n\tif (node_num == O2NM_INVALID_NODE_NUM)\n\t\treturn -ENOENT;\n\n\tif (node_num >= O2NM_MAX_NODES)\n\t\treturn -EOVERFLOW;\n\n\t*node = node_num;\n\treturn 0;\n}\n\nstatic struct ocfs2_stack_operations o2cb_stack_ops = {\n\t.connect\t= o2cb_cluster_connect,\n\t.disconnect\t= o2cb_cluster_disconnect,\n\t.this_node\t= o2cb_cluster_this_node,\n\t.dlm_lock\t= o2cb_dlm_lock,\n\t.dlm_unlock\t= o2cb_dlm_unlock,\n\t.lock_status\t= o2cb_dlm_lock_status,\n\t.lvb_valid\t= o2cb_dlm_lvb_valid,\n\t.lock_lvb\t= o2cb_dlm_lvb,\n\t.dump_lksb\t= o2cb_dump_lksb,\n};\n\nstatic struct ocfs2_stack_plugin o2cb_stack = {\n\t.sp_name\t= \"o2cb\",\n\t.sp_ops\t\t= &o2cb_stack_ops,\n\t.sp_owner\t= THIS_MODULE,\n};\n\nstatic int __init o2cb_stack_init(void)\n{\n\treturn ocfs2_stack_glue_register(&o2cb_stack);\n}\n\nstatic void __exit o2cb_stack_exit(void)\n{\n\tocfs2_stack_glue_unregister(&o2cb_stack);\n}\n\nMODULE_AUTHOR(\"Oracle\");\nMODULE_DESCRIPTION(\"ocfs2 driver for the classic o2cb stack\");\nMODULE_LICENSE(\"GPL\");\nmodule_init(o2cb_stack_init);\nmodule_exit(o2cb_stack_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}