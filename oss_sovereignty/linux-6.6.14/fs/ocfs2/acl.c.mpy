{
  "module_name": "acl.c",
  "hash_id": "7618b0f48fdac64cc4ae000cca85737aa9d0a72ad64dbcfb52488a50052e2bc4",
  "original_prompt": "Ingested from linux-6.6.14/fs/ocfs2/acl.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\n#include <cluster/masklog.h>\n\n#include \"ocfs2.h\"\n#include \"alloc.h\"\n#include \"dlmglue.h\"\n#include \"file.h\"\n#include \"inode.h\"\n#include \"journal.h\"\n#include \"ocfs2_fs.h\"\n\n#include \"xattr.h\"\n#include \"acl.h\"\n\n \nstatic struct posix_acl *ocfs2_acl_from_xattr(const void *value, size_t size)\n{\n\tint n, count;\n\tstruct posix_acl *acl;\n\n\tif (!value)\n\t\treturn NULL;\n\tif (size < sizeof(struct posix_acl_entry))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tcount = size / sizeof(struct posix_acl_entry);\n\n\tacl = posix_acl_alloc(count, GFP_NOFS);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\tfor (n = 0; n < count; n++) {\n\t\tstruct ocfs2_acl_entry *entry =\n\t\t\t(struct ocfs2_acl_entry *)value;\n\n\t\tacl->a_entries[n].e_tag  = le16_to_cpu(entry->e_tag);\n\t\tacl->a_entries[n].e_perm = le16_to_cpu(entry->e_perm);\n\t\tswitch(acl->a_entries[n].e_tag) {\n\t\tcase ACL_USER:\n\t\t\tacl->a_entries[n].e_uid =\n\t\t\t\tmake_kuid(&init_user_ns,\n\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tacl->a_entries[n].e_gid =\n\t\t\t\tmake_kgid(&init_user_ns,\n\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tvalue += sizeof(struct posix_acl_entry);\n\n\t}\n\treturn acl;\n}\n\n \nstatic void *ocfs2_acl_to_xattr(const struct posix_acl *acl, size_t *size)\n{\n\tstruct ocfs2_acl_entry *entry = NULL;\n\tchar *ocfs2_acl;\n\tsize_t n;\n\n\t*size = acl->a_count * sizeof(struct posix_acl_entry);\n\n\tocfs2_acl = kmalloc(*size, GFP_NOFS);\n\tif (!ocfs2_acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tentry = (struct ocfs2_acl_entry *)ocfs2_acl;\n\tfor (n = 0; n < acl->a_count; n++, entry++) {\n\t\tentry->e_tag  = cpu_to_le16(acl->a_entries[n].e_tag);\n\t\tentry->e_perm = cpu_to_le16(acl->a_entries[n].e_perm);\n\t\tswitch(acl->a_entries[n].e_tag) {\n\t\tcase ACL_USER:\n\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\tfrom_kuid(&init_user_ns,\n\t\t\t\t\t  acl->a_entries[n].e_uid));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\tfrom_kgid(&init_user_ns,\n\t\t\t\t\t  acl->a_entries[n].e_gid));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tentry->e_id = cpu_to_le32(ACL_UNDEFINED_ID);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ocfs2_acl;\n}\n\nstatic struct posix_acl *ocfs2_get_acl_nolock(struct inode *inode,\n\t\t\t\t\t      int type,\n\t\t\t\t\t      struct buffer_head *di_bh)\n{\n\tint name_index;\n\tchar *value = NULL;\n\tstruct posix_acl *acl;\n\tint retval;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tretval = ocfs2_xattr_get_nolock(inode, di_bh, name_index, \"\", NULL, 0);\n\tif (retval > 0) {\n\t\tvalue = kmalloc(retval, GFP_NOFS);\n\t\tif (!value)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tretval = ocfs2_xattr_get_nolock(inode, di_bh, name_index,\n\t\t\t\t\t\t\"\", value, retval);\n\t}\n\n\tif (retval > 0)\n\t\tacl = ocfs2_acl_from_xattr(value, retval);\n\telse if (retval == -ENODATA || retval == 0)\n\t\tacl = NULL;\n\telse\n\t\tacl = ERR_PTR(retval);\n\n\tkfree(value);\n\n\treturn acl;\n}\n\n \nstatic int ocfs2_acl_set_mode(struct inode *inode, struct buffer_head *di_bh,\n\t\t\t      handle_t *handle, umode_t new_mode)\n{\n\tint ret, commit_handle = 0;\n\tstruct ocfs2_dinode *di;\n\n\tif (di_bh == NULL) {\n\t\tret = ocfs2_read_inode_block(inode, &di_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t} else\n\t\tget_bh(di_bh);\n\n\tif (handle == NULL) {\n\t\thandle = ocfs2_start_trans(OCFS2_SB(inode->i_sb),\n\t\t\t\t\t   OCFS2_INODE_UPDATE_CREDITS);\n\t\tif (IS_ERR(handle)) {\n\t\t\tret = PTR_ERR(handle);\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_brelse;\n\t\t}\n\n\t\tcommit_handle = 1;\n\t}\n\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tinode->i_mode = new_mode;\n\tinode_set_ctime_current(inode);\n\tdi->i_mode = cpu_to_le16(inode->i_mode);\n\tdi->i_ctime = cpu_to_le64(inode_get_ctime(inode).tv_sec);\n\tdi->i_ctime_nsec = cpu_to_le32(inode_get_ctime(inode).tv_nsec);\n\tocfs2_update_inode_fsync_trans(handle, inode, 0);\n\n\tocfs2_journal_dirty(handle, di_bh);\n\nout_commit:\n\tif (commit_handle)\n\t\tocfs2_commit_trans(OCFS2_SB(inode->i_sb), handle);\nout_brelse:\n\tbrelse(di_bh);\nout:\n\treturn ret;\n}\n\n \nstatic int ocfs2_set_acl(handle_t *handle,\n\t\t\t struct inode *inode,\n\t\t\t struct buffer_head *di_bh,\n\t\t\t int type,\n\t\t\t struct posix_acl *acl,\n\t\t\t struct ocfs2_alloc_context *meta_ac,\n\t\t\t struct ocfs2_alloc_context *data_ac)\n{\n\tint name_index;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint ret;\n\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tvalue = ocfs2_acl_to_xattr(acl, &size);\n\t\tif (IS_ERR(value))\n\t\t\treturn (int)PTR_ERR(value);\n\t}\n\n\tif (handle)\n\t\tret = ocfs2_xattr_set_handle(handle, inode, di_bh, name_index,\n\t\t\t\t\t     \"\", value, size, 0,\n\t\t\t\t\t     meta_ac, data_ac);\n\telse\n\t\tret = ocfs2_xattr_set(inode, name_index, \"\", value, size, 0);\n\n\tkfree(value);\n\tif (!ret)\n\t\tset_cached_acl(inode, type, acl);\n\n\treturn ret;\n}\n\nint ocfs2_iop_set_acl(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\t      struct posix_acl *acl, int type)\n{\n\tstruct buffer_head *bh = NULL;\n\tint status, had_lock;\n\tstruct ocfs2_lock_holder oh;\n\tstruct inode *inode = d_inode(dentry);\n\n\thad_lock = ocfs2_inode_lock_tracker(inode, &bh, 1, &oh);\n\tif (had_lock < 0)\n\t\treturn had_lock;\n\tif (type == ACL_TYPE_ACCESS && acl) {\n\t\tumode_t mode;\n\n\t\tstatus = posix_acl_update_mode(&nop_mnt_idmap, inode, &mode,\n\t\t\t\t\t       &acl);\n\t\tif (status)\n\t\t\tgoto unlock;\n\n\t\tstatus = ocfs2_acl_set_mode(inode, bh, NULL, mode);\n\t\tif (status)\n\t\t\tgoto unlock;\n\t}\n\tstatus = ocfs2_set_acl(NULL, inode, bh, type, acl, NULL, NULL);\nunlock:\n\tocfs2_inode_unlock_tracker(inode, 1, &oh, had_lock);\n\tbrelse(bh);\n\treturn status;\n}\n\nstruct posix_acl *ocfs2_iop_get_acl(struct inode *inode, int type, bool rcu)\n{\n\tstruct ocfs2_super *osb;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct posix_acl *acl;\n\tint had_lock;\n\tstruct ocfs2_lock_holder oh;\n\n\tif (rcu)\n\t\treturn ERR_PTR(-ECHILD);\n\n\tosb = OCFS2_SB(inode->i_sb);\n\tif (!(osb->s_mount_opt & OCFS2_MOUNT_POSIX_ACL))\n\t\treturn NULL;\n\n\thad_lock = ocfs2_inode_lock_tracker(inode, &di_bh, 0, &oh);\n\tif (had_lock < 0)\n\t\treturn ERR_PTR(had_lock);\n\n\tdown_read(&OCFS2_I(inode)->ip_xattr_sem);\n\tacl = ocfs2_get_acl_nolock(inode, type, di_bh);\n\tup_read(&OCFS2_I(inode)->ip_xattr_sem);\n\n\tocfs2_inode_unlock_tracker(inode, 0, &oh, had_lock);\n\tbrelse(di_bh);\n\treturn acl;\n}\n\nint ocfs2_acl_chmod(struct inode *inode, struct buffer_head *bh)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct posix_acl *acl;\n\tint ret;\n\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!(osb->s_mount_opt & OCFS2_MOUNT_POSIX_ACL))\n\t\treturn 0;\n\n\tdown_read(&OCFS2_I(inode)->ip_xattr_sem);\n\tacl = ocfs2_get_acl_nolock(inode, ACL_TYPE_ACCESS, bh);\n\tup_read(&OCFS2_I(inode)->ip_xattr_sem);\n\tif (IS_ERR_OR_NULL(acl))\n\t\treturn PTR_ERR_OR_ZERO(acl);\n\tret = __posix_acl_chmod(&acl, GFP_KERNEL, inode->i_mode);\n\tif (ret)\n\t\treturn ret;\n\tret = ocfs2_set_acl(NULL, inode, NULL, ACL_TYPE_ACCESS,\n\t\t\t    acl, NULL, NULL);\n\tposix_acl_release(acl);\n\treturn ret;\n}\n\n \nint ocfs2_init_acl(handle_t *handle,\n\t\t   struct inode *inode,\n\t\t   struct inode *dir,\n\t\t   struct buffer_head *di_bh,\n\t\t   struct buffer_head *dir_bh,\n\t\t   struct ocfs2_alloc_context *meta_ac,\n\t\t   struct ocfs2_alloc_context *data_ac)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct posix_acl *acl = NULL;\n\tint ret = 0, ret2;\n\tumode_t mode;\n\n\tif (!S_ISLNK(inode->i_mode)) {\n\t\tif (osb->s_mount_opt & OCFS2_MOUNT_POSIX_ACL) {\n\t\t\tdown_read(&OCFS2_I(dir)->ip_xattr_sem);\n\t\t\tacl = ocfs2_get_acl_nolock(dir, ACL_TYPE_DEFAULT,\n\t\t\t\t\t\t   dir_bh);\n\t\t\tup_read(&OCFS2_I(dir)->ip_xattr_sem);\n\t\t\tif (IS_ERR(acl))\n\t\t\t\treturn PTR_ERR(acl);\n\t\t}\n\t\tif (!acl) {\n\t\t\tmode = inode->i_mode & ~current_umask();\n\t\t\tret = ocfs2_acl_set_mode(inode, di_bh, handle, mode);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\t}\n\tif ((osb->s_mount_opt & OCFS2_MOUNT_POSIX_ACL) && acl) {\n\t\tif (S_ISDIR(inode->i_mode)) {\n\t\t\tret = ocfs2_set_acl(handle, inode, di_bh,\n\t\t\t\t\t    ACL_TYPE_DEFAULT, acl,\n\t\t\t\t\t    meta_ac, data_ac);\n\t\t\tif (ret)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t\tmode = inode->i_mode;\n\t\tret = __posix_acl_create(&acl, GFP_NOFS, &mode);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret2 = ocfs2_acl_set_mode(inode, di_bh, handle, mode);\n\t\tif (ret2) {\n\t\t\tmlog_errno(ret2);\n\t\t\tret = ret2;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tif (ret > 0) {\n\t\t\tret = ocfs2_set_acl(handle, inode,\n\t\t\t\t\t    di_bh, ACL_TYPE_ACCESS,\n\t\t\t\t\t    acl, meta_ac, data_ac);\n\t\t}\n\t}\ncleanup:\n\tposix_acl_release(acl);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}