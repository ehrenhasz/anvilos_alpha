{
  "module_name": "inode.c",
  "hash_id": "4e5ee9e28d1ebc2806cab8e2e72e4037325cc1c4a0b57150d217efe9304bfb79",
  "original_prompt": "Ingested from linux-6.6.14/fs/ocfs2/inode.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/quotaops.h>\n#include <linux/iversion.h>\n\n#include <asm/byteorder.h>\n\n#include <cluster/masklog.h>\n\n#include \"ocfs2.h\"\n\n#include \"alloc.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"dlmglue.h\"\n#include \"extent_map.h\"\n#include \"file.h\"\n#include \"heartbeat.h\"\n#include \"inode.h\"\n#include \"journal.h\"\n#include \"namei.h\"\n#include \"suballoc.h\"\n#include \"super.h\"\n#include \"symlink.h\"\n#include \"sysfile.h\"\n#include \"uptodate.h\"\n#include \"xattr.h\"\n#include \"refcounttree.h\"\n#include \"ocfs2_trace.h\"\n#include \"filecheck.h\"\n\n#include \"buffer_head_io.h\"\n\nstruct ocfs2_find_inode_args\n{\n\tu64\t\tfi_blkno;\n\tunsigned long\tfi_ino;\n\tunsigned int\tfi_flags;\n\tunsigned int\tfi_sysfile_type;\n};\n\nstatic struct lock_class_key ocfs2_sysfile_lock_key[NUM_SYSTEM_INODES];\n\nstatic int ocfs2_read_locked_inode(struct inode *inode,\n\t\t\t\t   struct ocfs2_find_inode_args *args);\nstatic int ocfs2_init_locked_inode(struct inode *inode, void *opaque);\nstatic int ocfs2_find_actor(struct inode *inode, void *opaque);\nstatic int ocfs2_truncate_for_delete(struct ocfs2_super *osb,\n\t\t\t\t    struct inode *inode,\n\t\t\t\t    struct buffer_head *fe_bh);\n\nstatic int ocfs2_filecheck_read_inode_block_full(struct inode *inode,\n\t\t\t\t\t\t struct buffer_head **bh,\n\t\t\t\t\t\t int flags, int type);\nstatic int ocfs2_filecheck_validate_inode_block(struct super_block *sb,\n\t\t\t\t\t\tstruct buffer_head *bh);\nstatic int ocfs2_filecheck_repair_inode_block(struct super_block *sb,\n\t\t\t\t\t      struct buffer_head *bh);\n\nvoid ocfs2_set_inode_flags(struct inode *inode)\n{\n\tunsigned int flags = OCFS2_I(inode)->ip_attr;\n\n\tinode->i_flags &= ~(S_IMMUTABLE |\n\t\tS_SYNC | S_APPEND | S_NOATIME | S_DIRSYNC);\n\n\tif (flags & OCFS2_IMMUTABLE_FL)\n\t\tinode->i_flags |= S_IMMUTABLE;\n\n\tif (flags & OCFS2_SYNC_FL)\n\t\tinode->i_flags |= S_SYNC;\n\tif (flags & OCFS2_APPEND_FL)\n\t\tinode->i_flags |= S_APPEND;\n\tif (flags & OCFS2_NOATIME_FL)\n\t\tinode->i_flags |= S_NOATIME;\n\tif (flags & OCFS2_DIRSYNC_FL)\n\t\tinode->i_flags |= S_DIRSYNC;\n}\n\n \nvoid ocfs2_get_inode_flags(struct ocfs2_inode_info *oi)\n{\n\tunsigned int flags = oi->vfs_inode.i_flags;\n\n\toi->ip_attr &= ~(OCFS2_SYNC_FL|OCFS2_APPEND_FL|\n\t\t\tOCFS2_IMMUTABLE_FL|OCFS2_NOATIME_FL|OCFS2_DIRSYNC_FL);\n\tif (flags & S_SYNC)\n\t\toi->ip_attr |= OCFS2_SYNC_FL;\n\tif (flags & S_APPEND)\n\t\toi->ip_attr |= OCFS2_APPEND_FL;\n\tif (flags & S_IMMUTABLE)\n\t\toi->ip_attr |= OCFS2_IMMUTABLE_FL;\n\tif (flags & S_NOATIME)\n\t\toi->ip_attr |= OCFS2_NOATIME_FL;\n\tif (flags & S_DIRSYNC)\n\t\toi->ip_attr |= OCFS2_DIRSYNC_FL;\n}\n\nstruct inode *ocfs2_ilookup(struct super_block *sb, u64 blkno)\n{\n\tstruct ocfs2_find_inode_args args;\n\n\targs.fi_blkno = blkno;\n\targs.fi_flags = 0;\n\targs.fi_ino = ino_from_blkno(sb, blkno);\n\targs.fi_sysfile_type = 0;\n\n\treturn ilookup5(sb, blkno, ocfs2_find_actor, &args);\n}\nstruct inode *ocfs2_iget(struct ocfs2_super *osb, u64 blkno, unsigned flags,\n\t\t\t int sysfile_type)\n{\n\tint rc = -ESTALE;\n\tstruct inode *inode = NULL;\n\tstruct super_block *sb = osb->sb;\n\tstruct ocfs2_find_inode_args args;\n\tjournal_t *journal = osb->journal->j_journal;\n\n\ttrace_ocfs2_iget_begin((unsigned long long)blkno, flags,\n\t\t\t       sysfile_type);\n\n\t \n\tif (blkno == 0) {\n\t\tinode = ERR_PTR(-EINVAL);\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tgoto bail;\n\t}\n\n\targs.fi_blkno = blkno;\n\targs.fi_flags = flags;\n\targs.fi_ino = ino_from_blkno(sb, blkno);\n\targs.fi_sysfile_type = sysfile_type;\n\n\tinode = iget5_locked(sb, args.fi_ino, ocfs2_find_actor,\n\t\t\t     ocfs2_init_locked_inode, &args);\n\t \n\tif (inode == NULL) {\n\t\tinode = ERR_PTR(-ENOMEM);\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tgoto bail;\n\t}\n\ttrace_ocfs2_iget5_locked(inode->i_state);\n\tif (inode->i_state & I_NEW) {\n\t\trc = ocfs2_read_locked_inode(inode, &args);\n\t\tunlock_new_inode(inode);\n\t}\n\tif (is_bad_inode(inode)) {\n\t\tiput(inode);\n\t\tinode = ERR_PTR(rc);\n\t\tgoto bail;\n\t}\n\n\t \n\tif (journal) {\n\t\ttransaction_t *transaction;\n\t\ttid_t tid;\n\t\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\t\tread_lock(&journal->j_state_lock);\n\t\tif (journal->j_running_transaction)\n\t\t\ttransaction = journal->j_running_transaction;\n\t\telse\n\t\t\ttransaction = journal->j_committing_transaction;\n\t\tif (transaction)\n\t\t\ttid = transaction->t_tid;\n\t\telse\n\t\t\ttid = journal->j_commit_sequence;\n\t\tread_unlock(&journal->j_state_lock);\n\t\toi->i_sync_tid = tid;\n\t\toi->i_datasync_tid = tid;\n\t}\n\nbail:\n\tif (!IS_ERR(inode)) {\n\t\ttrace_ocfs2_iget_end(inode, \n\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t}\n\n\treturn inode;\n}\n\n\n \n\nstatic int ocfs2_find_actor(struct inode *inode, void *opaque)\n{\n\tstruct ocfs2_find_inode_args *args = NULL;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tint ret = 0;\n\n\targs = opaque;\n\n\tmlog_bug_on_msg(!inode, \"No inode in find actor!\\n\");\n\n\ttrace_ocfs2_find_actor(inode, inode->i_ino, opaque, args->fi_blkno);\n\n\tif (oi->ip_blkno != args->fi_blkno)\n\t\tgoto bail;\n\n\tret = 1;\nbail:\n\treturn ret;\n}\n\n \nstatic int ocfs2_init_locked_inode(struct inode *inode, void *opaque)\n{\n\tstruct ocfs2_find_inode_args *args = opaque;\n\tstatic struct lock_class_key ocfs2_quota_ip_alloc_sem_key,\n\t\t\t\t     ocfs2_file_ip_alloc_sem_key;\n\n\tinode->i_ino = args->fi_ino;\n\tOCFS2_I(inode)->ip_blkno = args->fi_blkno;\n\tif (args->fi_sysfile_type != 0)\n\t\tlockdep_set_class(&inode->i_rwsem,\n\t\t\t&ocfs2_sysfile_lock_key[args->fi_sysfile_type]);\n\tif (args->fi_sysfile_type == USER_QUOTA_SYSTEM_INODE ||\n\t    args->fi_sysfile_type == GROUP_QUOTA_SYSTEM_INODE ||\n\t    args->fi_sysfile_type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    args->fi_sysfile_type == LOCAL_GROUP_QUOTA_SYSTEM_INODE)\n\t\tlockdep_set_class(&OCFS2_I(inode)->ip_alloc_sem,\n\t\t\t\t  &ocfs2_quota_ip_alloc_sem_key);\n\telse\n\t\tlockdep_set_class(&OCFS2_I(inode)->ip_alloc_sem,\n\t\t\t\t  &ocfs2_file_ip_alloc_sem_key);\n\n\treturn 0;\n}\n\nvoid ocfs2_populate_inode(struct inode *inode, struct ocfs2_dinode *fe,\n\t\t\t  int create_ino)\n{\n\tstruct super_block *sb;\n\tstruct ocfs2_super *osb;\n\tint use_plocks = 1;\n\n\tsb = inode->i_sb;\n\tosb = OCFS2_SB(sb);\n\n\tif ((osb->s_mount_opt & OCFS2_MOUNT_LOCALFLOCKS) ||\n\t    ocfs2_mount_local(osb) || !ocfs2_stack_supports_plocks())\n\t\tuse_plocks = 0;\n\n\t \n\tBUG_ON(!OCFS2_IS_VALID_DINODE(fe));   \n\tBUG_ON(!(fe->i_flags & cpu_to_le32(OCFS2_VALID_FL)));\n\tBUG_ON(le32_to_cpu(fe->i_fs_generation) != osb->fs_generation);\n\n\n\tOCFS2_I(inode)->ip_clusters = le32_to_cpu(fe->i_clusters);\n\tOCFS2_I(inode)->ip_attr = le32_to_cpu(fe->i_attr);\n\tOCFS2_I(inode)->ip_dyn_features = le16_to_cpu(fe->i_dyn_features);\n\n\tinode_set_iversion(inode, 1);\n\tinode->i_generation = le32_to_cpu(fe->i_generation);\n\tinode->i_rdev = huge_decode_dev(le64_to_cpu(fe->id1.dev1.i_rdev));\n\tinode->i_mode = le16_to_cpu(fe->i_mode);\n\ti_uid_write(inode, le32_to_cpu(fe->i_uid));\n\ti_gid_write(inode, le32_to_cpu(fe->i_gid));\n\n\t \n\tif (S_ISLNK(inode->i_mode) && !fe->i_clusters) {\n\t\tinode->i_blocks = 0;\n\t\tinode->i_mapping->a_ops = &ocfs2_fast_symlink_aops;\n\t} else {\n\t\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\t\tinode->i_mapping->a_ops = &ocfs2_aops;\n\t}\n\tinode->i_atime.tv_sec = le64_to_cpu(fe->i_atime);\n\tinode->i_atime.tv_nsec = le32_to_cpu(fe->i_atime_nsec);\n\tinode->i_mtime.tv_sec = le64_to_cpu(fe->i_mtime);\n\tinode->i_mtime.tv_nsec = le32_to_cpu(fe->i_mtime_nsec);\n\tinode_set_ctime(inode, le64_to_cpu(fe->i_ctime),\n\t\t        le32_to_cpu(fe->i_ctime_nsec));\n\n\tif (OCFS2_I(inode)->ip_blkno != le64_to_cpu(fe->i_blkno))\n\t\tmlog(ML_ERROR,\n\t\t     \"ip_blkno %llu != i_blkno %llu!\\n\",\n\t\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t     (unsigned long long)le64_to_cpu(fe->i_blkno));\n\n\tset_nlink(inode, ocfs2_read_links_count(fe));\n\n\ttrace_ocfs2_populate_inode(OCFS2_I(inode)->ip_blkno,\n\t\t\t\t   le32_to_cpu(fe->i_flags));\n\tif (fe->i_flags & cpu_to_le32(OCFS2_SYSTEM_FL)) {\n\t\tOCFS2_I(inode)->ip_flags |= OCFS2_INODE_SYSTEM_FILE;\n\t\tinode->i_flags |= S_NOQUOTA;\n\t}\n  \n\tif (fe->i_flags & cpu_to_le32(OCFS2_LOCAL_ALLOC_FL)) {\n\t\tOCFS2_I(inode)->ip_flags |= OCFS2_INODE_BITMAP;\n\t} else if (fe->i_flags & cpu_to_le32(OCFS2_BITMAP_FL)) {\n\t\tOCFS2_I(inode)->ip_flags |= OCFS2_INODE_BITMAP;\n\t} else if (fe->i_flags & cpu_to_le32(OCFS2_QUOTA_FL)) {\n\t\tinode->i_flags |= S_NOQUOTA;\n\t} else if (fe->i_flags & cpu_to_le32(OCFS2_SUPER_BLOCK_FL)) {\n\t\t \n\t\tBUG();\n\t}\n\n\tswitch (inode->i_mode & S_IFMT) {\n\t    case S_IFREG:\n\t\t    if (use_plocks)\n\t\t\t    inode->i_fop = &ocfs2_fops;\n\t\t    else\n\t\t\t    inode->i_fop = &ocfs2_fops_no_plocks;\n\t\t    inode->i_op = &ocfs2_file_iops;\n\t\t    i_size_write(inode, le64_to_cpu(fe->i_size));\n\t\t    break;\n\t    case S_IFDIR:\n\t\t    inode->i_op = &ocfs2_dir_iops;\n\t\t    if (use_plocks)\n\t\t\t    inode->i_fop = &ocfs2_dops;\n\t\t    else\n\t\t\t    inode->i_fop = &ocfs2_dops_no_plocks;\n\t\t    i_size_write(inode, le64_to_cpu(fe->i_size));\n\t\t    OCFS2_I(inode)->ip_dir_lock_gen = 1;\n\t\t    break;\n\t    case S_IFLNK:\n\t\t    inode->i_op = &ocfs2_symlink_inode_operations;\n\t\t    inode_nohighmem(inode);\n\t\t    i_size_write(inode, le64_to_cpu(fe->i_size));\n\t\t    break;\n\t    default:\n\t\t    inode->i_op = &ocfs2_special_file_iops;\n\t\t    init_special_inode(inode, inode->i_mode,\n\t\t\t\t       inode->i_rdev);\n\t\t    break;\n\t}\n\n\tif (create_ino) {\n\t\tinode->i_ino = ino_from_blkno(inode->i_sb,\n\t\t\t       le64_to_cpu(fe->i_blkno));\n\n\t\t \n\t\tBUG_ON(le32_to_cpu(fe->i_flags) & OCFS2_SYSTEM_FL);\n\n\t\tocfs2_inode_lock_res_init(&OCFS2_I(inode)->ip_inode_lockres,\n\t\t\t\t\t  OCFS2_LOCK_TYPE_META, 0, inode);\n\n\t\tocfs2_inode_lock_res_init(&OCFS2_I(inode)->ip_open_lockres,\n\t\t\t\t\t  OCFS2_LOCK_TYPE_OPEN, 0, inode);\n\t}\n\n\tocfs2_inode_lock_res_init(&OCFS2_I(inode)->ip_rw_lockres,\n\t\t\t\t  OCFS2_LOCK_TYPE_RW, inode->i_generation,\n\t\t\t\t  inode);\n\n\tocfs2_set_inode_flags(inode);\n\n\tOCFS2_I(inode)->ip_last_used_slot = 0;\n\tOCFS2_I(inode)->ip_last_used_group = 0;\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tocfs2_resv_set_type(&OCFS2_I(inode)->ip_la_data_resv,\n\t\t\t\t    OCFS2_RESV_FLAG_DIR);\n}\n\nstatic int ocfs2_read_locked_inode(struct inode *inode,\n\t\t\t\t   struct ocfs2_find_inode_args *args)\n{\n\tstruct super_block *sb;\n\tstruct ocfs2_super *osb;\n\tstruct ocfs2_dinode *fe;\n\tstruct buffer_head *bh = NULL;\n\tint status, can_lock, lock_level = 0;\n\tu32 generation = 0;\n\n\tstatus = -EINVAL;\n\tsb = inode->i_sb;\n\tosb = OCFS2_SB(sb);\n\n\t \n\tcan_lock = !(args->fi_flags & OCFS2_FI_FLAG_SYSFILE)\n\t\t&& !(args->fi_flags & OCFS2_FI_FLAG_ORPHAN_RECOVERY)\n\t\t&& !ocfs2_mount_local(osb);\n\n\ttrace_ocfs2_read_locked_inode(\n\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno, can_lock);\n\n\t \n\tif (args->fi_flags & OCFS2_FI_FLAG_SYSFILE)\n\t\tgeneration = osb->fs_generation;\n\n\tocfs2_inode_lock_res_init(&OCFS2_I(inode)->ip_inode_lockres,\n\t\t\t\t  OCFS2_LOCK_TYPE_META,\n\t\t\t\t  generation, inode);\n\n\tocfs2_inode_lock_res_init(&OCFS2_I(inode)->ip_open_lockres,\n\t\t\t\t  OCFS2_LOCK_TYPE_OPEN,\n\t\t\t\t  0, inode);\n\n\tif (can_lock) {\n\t\tstatus = ocfs2_open_lock(inode);\n\t\tif (status) {\n\t\t\tmake_bad_inode(inode);\n\t\t\tmlog_errno(status);\n\t\t\treturn status;\n\t\t}\n\t\tstatus = ocfs2_inode_lock(inode, NULL, lock_level);\n\t\tif (status) {\n\t\t\tmake_bad_inode(inode);\n\t\t\tmlog_errno(status);\n\t\t\treturn status;\n\t\t}\n\t}\n\n\tif (args->fi_flags & OCFS2_FI_FLAG_ORPHAN_RECOVERY) {\n\t\tstatus = ocfs2_try_open_lock(inode, 0);\n\t\tif (status) {\n\t\t\tmake_bad_inode(inode);\n\t\t\treturn status;\n\t\t}\n\t}\n\n\tif (can_lock) {\n\t\tif (args->fi_flags & OCFS2_FI_FLAG_FILECHECK_CHK)\n\t\t\tstatus = ocfs2_filecheck_read_inode_block_full(inode,\n\t\t\t\t\t\t&bh, OCFS2_BH_IGNORE_CACHE, 0);\n\t\telse if (args->fi_flags & OCFS2_FI_FLAG_FILECHECK_FIX)\n\t\t\tstatus = ocfs2_filecheck_read_inode_block_full(inode,\n\t\t\t\t\t\t&bh, OCFS2_BH_IGNORE_CACHE, 1);\n\t\telse\n\t\t\tstatus = ocfs2_read_inode_block_full(inode,\n\t\t\t\t\t\t&bh, OCFS2_BH_IGNORE_CACHE);\n\t} else {\n\t\tstatus = ocfs2_read_blocks_sync(osb, args->fi_blkno, 1, &bh);\n\t\t \n\t\tif (!status && !buffer_jbd(bh)) {\n\t\t\tif (args->fi_flags & OCFS2_FI_FLAG_FILECHECK_CHK)\n\t\t\t\tstatus = ocfs2_filecheck_validate_inode_block(\n\t\t\t\t\t\t\t\tosb->sb, bh);\n\t\t\telse if (args->fi_flags & OCFS2_FI_FLAG_FILECHECK_FIX)\n\t\t\t\tstatus = ocfs2_filecheck_repair_inode_block(\n\t\t\t\t\t\t\t\tosb->sb, bh);\n\t\t\telse\n\t\t\t\tstatus = ocfs2_validate_inode_block(\n\t\t\t\t\t\t\t\tosb->sb, bh);\n\t\t}\n\t}\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = -EINVAL;\n\tfe = (struct ocfs2_dinode *) bh->b_data;\n\n\t \n\tmlog_bug_on_msg(!!(fe->i_flags & cpu_to_le32(OCFS2_SYSTEM_FL)) !=\n\t\t\t!!(args->fi_flags & OCFS2_FI_FLAG_SYSFILE),\n\t\t\t\"Inode %llu: system file state is ambiguous\\n\",\n\t\t\t(unsigned long long)args->fi_blkno);\n\n\tif (S_ISCHR(le16_to_cpu(fe->i_mode)) ||\n\t    S_ISBLK(le16_to_cpu(fe->i_mode)))\n\t\tinode->i_rdev = huge_decode_dev(le64_to_cpu(fe->id1.dev1.i_rdev));\n\n\tocfs2_populate_inode(inode, fe, 0);\n\n\tBUG_ON(args->fi_blkno != le64_to_cpu(fe->i_blkno));\n\n\tif (buffer_dirty(bh) && !buffer_jbd(bh)) {\n\t\tif (can_lock) {\n\t\t\tocfs2_inode_unlock(inode, lock_level);\n\t\t\tlock_level = 1;\n\t\t\tocfs2_inode_lock(inode, NULL, lock_level);\n\t\t}\n\t\tstatus = ocfs2_write_block(osb, bh, INODE_CACHE(inode));\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = 0;\n\nbail:\n\tif (can_lock)\n\t\tocfs2_inode_unlock(inode, lock_level);\n\n\tif (status < 0)\n\t\tmake_bad_inode(inode);\n\n\tbrelse(bh);\n\n\treturn status;\n}\n\nvoid ocfs2_sync_blockdev(struct super_block *sb)\n{\n\tsync_blockdev(sb->s_bdev);\n}\n\nstatic int ocfs2_truncate_for_delete(struct ocfs2_super *osb,\n\t\t\t\t     struct inode *inode,\n\t\t\t\t     struct buffer_head *fe_bh)\n{\n\tint status = 0;\n\tstruct ocfs2_dinode *fe;\n\thandle_t *handle = NULL;\n\n\tfe = (struct ocfs2_dinode *) fe_bh->b_data;\n\n\t \n\tif (fe->i_clusters) {\n\t\tif (ocfs2_should_order_data(inode))\n\t\t\tocfs2_begin_ordered_truncate(inode, 0);\n\n\t\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\t\tif (IS_ERR(handle)) {\n\t\t\tstatus = PTR_ERR(handle);\n\t\t\thandle = NULL;\n\t\t\tmlog_errno(status);\n\t\t\tgoto out;\n\t\t}\n\n\t\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode),\n\t\t\t\t\t\t fe_bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto out;\n\t\t}\n\n\t\ti_size_write(inode, 0);\n\n\t\tstatus = ocfs2_mark_inode_dirty(handle, inode, fe_bh);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto out;\n\t\t}\n\n\t\tocfs2_commit_trans(osb, handle);\n\t\thandle = NULL;\n\n\t\tstatus = ocfs2_commit_truncate(osb, inode, fe_bh);\n\t\tif (status < 0)\n\t\t\tmlog_errno(status);\n\t}\n\nout:\n\tif (handle)\n\t\tocfs2_commit_trans(osb, handle);\n\treturn status;\n}\n\nstatic int ocfs2_remove_inode(struct inode *inode,\n\t\t\t      struct buffer_head *di_bh,\n\t\t\t      struct inode *orphan_dir_inode,\n\t\t\t      struct buffer_head *orphan_dir_bh)\n{\n\tint status;\n\tstruct inode *inode_alloc_inode = NULL;\n\tstruct buffer_head *inode_alloc_bh = NULL;\n\thandle_t *handle;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *) di_bh->b_data;\n\n\tinode_alloc_inode =\n\t\tocfs2_get_system_file_inode(osb, INODE_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t    le16_to_cpu(di->i_suballoc_slot));\n\tif (!inode_alloc_inode) {\n\t\tstatus = -ENOENT;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tinode_lock(inode_alloc_inode);\n\tstatus = ocfs2_inode_lock(inode_alloc_inode, &inode_alloc_bh, 1);\n\tif (status < 0) {\n\t\tinode_unlock(inode_alloc_inode);\n\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_DELETE_INODE_CREDITS +\n\t\t\t\t   ocfs2_quota_trans_credits(inode->i_sb));\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\tgoto bail_unlock;\n\t}\n\n\tif (!(OCFS2_I(inode)->ip_flags & OCFS2_INODE_SKIP_ORPHAN_DIR)) {\n\t\tstatus = ocfs2_orphan_del(osb, handle, orphan_dir_inode, inode,\n\t\t\t\t\t  orphan_dir_bh, false);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail_commit;\n\t\t}\n\t}\n\n\t \n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail_commit;\n\t}\n\n\tdi->i_dtime = cpu_to_le64(ktime_get_real_seconds());\n\tdi->i_flags &= cpu_to_le32(~(OCFS2_VALID_FL | OCFS2_ORPHANED_FL));\n\tocfs2_journal_dirty(handle, di_bh);\n\n\tocfs2_remove_from_cache(INODE_CACHE(inode), di_bh);\n\tdquot_free_inode(inode);\n\n\tstatus = ocfs2_free_dinode(handle, inode_alloc_inode,\n\t\t\t\t   inode_alloc_bh, di);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\nbail_commit:\n\tocfs2_commit_trans(osb, handle);\nbail_unlock:\n\tocfs2_inode_unlock(inode_alloc_inode, 1);\n\tinode_unlock(inode_alloc_inode);\n\tbrelse(inode_alloc_bh);\nbail:\n\tiput(inode_alloc_inode);\n\n\treturn status;\n}\n\n \nstatic int ocfs2_check_orphan_recovery_state(struct ocfs2_super *osb,\n\t\t\t\t\t     int slot)\n{\n\tint ret = 0;\n\n\tspin_lock(&osb->osb_lock);\n\tif (ocfs2_node_map_test_bit(osb, &osb->osb_recovering_orphan_dirs, slot)) {\n\t\tret = -EDEADLK;\n\t\tgoto out;\n\t}\n\t \n\tosb->osb_orphan_wipes[slot]++;\nout:\n\tspin_unlock(&osb->osb_lock);\n\ttrace_ocfs2_check_orphan_recovery_state(slot, ret);\n\treturn ret;\n}\n\nstatic void ocfs2_signal_wipe_completion(struct ocfs2_super *osb,\n\t\t\t\t\t int slot)\n{\n\tspin_lock(&osb->osb_lock);\n\tosb->osb_orphan_wipes[slot]--;\n\tspin_unlock(&osb->osb_lock);\n\n\twake_up(&osb->osb_wipe_event);\n}\n\nstatic int ocfs2_wipe_inode(struct inode *inode,\n\t\t\t    struct buffer_head *di_bh)\n{\n\tint status, orphaned_slot = -1;\n\tstruct inode *orphan_dir_inode = NULL;\n\tstruct buffer_head *orphan_dir_bh = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *) di_bh->b_data;\n\n\tif (!(OCFS2_I(inode)->ip_flags & OCFS2_INODE_SKIP_ORPHAN_DIR)) {\n\t\torphaned_slot = le16_to_cpu(di->i_orphaned_slot);\n\n\t\tstatus = ocfs2_check_orphan_recovery_state(osb, orphaned_slot);\n\t\tif (status)\n\t\t\treturn status;\n\n\t\torphan_dir_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t\t       ORPHAN_DIR_SYSTEM_INODE,\n\t\t\t\t\t\t\t       orphaned_slot);\n\t\tif (!orphan_dir_inode) {\n\t\t\tstatus = -ENOENT;\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\t \n\t\tinode_lock(orphan_dir_inode);\n\t\tstatus = ocfs2_inode_lock(orphan_dir_inode, &orphan_dir_bh, 1);\n\t\tif (status < 0) {\n\t\t\tinode_unlock(orphan_dir_inode);\n\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t \n\tstatus = ocfs2_truncate_for_delete(osb, inode, di_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail_unlock_dir;\n\t}\n\n\t \n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstatus = ocfs2_dx_dir_truncate(inode, di_bh);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail_unlock_dir;\n\t\t}\n\t}\n\n\t \n\tstatus = ocfs2_xattr_remove(inode, di_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail_unlock_dir;\n\t}\n\n\tstatus = ocfs2_remove_refcount_tree(inode, di_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail_unlock_dir;\n\t}\n\n\tstatus = ocfs2_remove_inode(inode, di_bh, orphan_dir_inode,\n\t\t\t\t    orphan_dir_bh);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\nbail_unlock_dir:\n\tif (OCFS2_I(inode)->ip_flags & OCFS2_INODE_SKIP_ORPHAN_DIR)\n\t\treturn status;\n\n\tocfs2_inode_unlock(orphan_dir_inode, 1);\n\tinode_unlock(orphan_dir_inode);\n\tbrelse(orphan_dir_bh);\nbail:\n\tiput(orphan_dir_inode);\n\tocfs2_signal_wipe_completion(osb, orphaned_slot);\n\n\treturn status;\n}\n\n \nstatic int ocfs2_inode_is_valid_to_delete(struct inode *inode)\n{\n\tint ret = 0;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\ttrace_ocfs2_inode_is_valid_to_delete(current, osb->dc_task,\n\t\t\t\t\t     (unsigned long long)oi->ip_blkno,\n\t\t\t\t\t     oi->ip_flags);\n\n\t \n\tif (inode == osb->root_inode) {\n\t\tmlog(ML_ERROR, \"Skipping delete of root inode.\\n\");\n\t\tgoto bail;\n\t}\n\n\t \n\tif (current == osb->dc_task)\n\t\tgoto bail;\n\n\tspin_lock(&oi->ip_lock);\n\t \n\tif (oi->ip_flags & OCFS2_INODE_SYSTEM_FILE) {\n\t\tmlog(ML_ERROR, \"Skipping delete of system file %llu\\n\",\n\t\t     (unsigned long long)oi->ip_blkno);\n\t\tgoto bail_unlock;\n\t}\n\n\tret = 1;\nbail_unlock:\n\tspin_unlock(&oi->ip_lock);\nbail:\n\treturn ret;\n}\n\n \nstatic int ocfs2_query_inode_wipe(struct inode *inode,\n\t\t\t\t  struct buffer_head *di_bh,\n\t\t\t\t  int *wipe)\n{\n\tint status = 0, reason = 0;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_dinode *di;\n\n\t*wipe = 0;\n\n\ttrace_ocfs2_query_inode_wipe_begin((unsigned long long)oi->ip_blkno,\n\t\t\t\t\t   inode->i_nlink);\n\n\t \n\tif (!ocfs2_inode_is_valid_to_delete(inode)) {\n\t\treason = 1;\n\t\tgoto bail;\n\t}\n\n\t \n\tif (inode->i_nlink)\n\t\tgoto bail;\n\n\t \n\tdi = (struct ocfs2_dinode *) di_bh->b_data;\n\tif (!(di->i_flags & cpu_to_le32(OCFS2_ORPHANED_FL)) &&\n\t    !(oi->ip_flags & OCFS2_INODE_SKIP_ORPHAN_DIR)) {\n\t\t \n\t\tif (di->i_dyn_features & cpu_to_le16(OCFS2_HAS_REFCOUNT_FL)) {\n\t\t\treason = 2;\n\t\t\tgoto bail;\n\t\t}\n\n\t\t \n\t\tstatus = -EEXIST;\n\t\tmlog(ML_ERROR,\n\t\t     \"Inode %llu (on-disk %llu) not orphaned! \"\n\t\t     \"Disk flags  0x%x, inode flags 0x%x\\n\",\n\t\t     (unsigned long long)oi->ip_blkno,\n\t\t     (unsigned long long)le64_to_cpu(di->i_blkno),\n\t\t     le32_to_cpu(di->i_flags), oi->ip_flags);\n\t\tgoto bail;\n\t}\n\n\t \n\tif (di->i_dtime) {\n\t\tstatus = -EEXIST;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t \n\tstatus = ocfs2_try_open_lock(inode, 1);\n\tif (status == -EAGAIN) {\n\t\tstatus = 0;\n\t\treason = 3;\n\t\tgoto bail;\n\t}\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t*wipe = 1;\n\ttrace_ocfs2_query_inode_wipe_succ(le16_to_cpu(di->i_orphaned_slot));\n\nbail:\n\ttrace_ocfs2_query_inode_wipe_end(status, reason);\n\treturn status;\n}\n\n \nstatic void ocfs2_cleanup_delete_inode(struct inode *inode,\n\t\t\t\t       int sync_data)\n{\n\ttrace_ocfs2_cleanup_delete_inode(\n\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno, sync_data);\n\tif (sync_data)\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\ttruncate_inode_pages_final(&inode->i_data);\n}\n\nstatic void ocfs2_delete_inode(struct inode *inode)\n{\n\tint wipe, status;\n\tsigset_t oldset;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dinode *di = NULL;\n\n\ttrace_ocfs2_delete_inode(inode->i_ino,\n\t\t\t\t (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t\t is_bad_inode(inode));\n\n\t \n\tif (is_bad_inode(inode) || !OCFS2_I(inode)->ip_blkno)\n\t\tgoto bail;\n\n\tif (!ocfs2_inode_is_valid_to_delete(inode)) {\n\t\t \n\t\tocfs2_cleanup_delete_inode(inode, 0);\n\t\tgoto bail;\n\t}\n\n\tdquot_initialize(inode);\n\n\t \n\tocfs2_block_signals(&oldset);\n\n\t \n\tstatus = ocfs2_nfs_sync_lock(OCFS2_SB(inode->i_sb), 0);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"getting nfs sync lock(PR) failed %d\\n\", status);\n\t\tocfs2_cleanup_delete_inode(inode, 0);\n\t\tgoto bail_unblock;\n\t}\n\t \n\tstatus = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (status < 0) {\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t\tocfs2_cleanup_delete_inode(inode, 0);\n\t\tgoto bail_unlock_nfs_sync;\n\t}\n\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\t \n\tif (unlikely(di->i_flags & cpu_to_le32(OCFS2_DIO_ORPHANED_FL))) {\n\t\tocfs2_cleanup_delete_inode(inode, 0);\n\t\tgoto bail_unlock_inode;\n\t}\n\n\t \n\tstatus = ocfs2_query_inode_wipe(inode, di_bh, &wipe);\n\tif (!wipe || status < 0) {\n\t\t \n\t\tif (status < 0)\n\t\t\tmlog_errno(status);\n\n\t\t \n\t\tocfs2_cleanup_delete_inode(inode, 1);\n\t\tgoto bail_unlock_inode;\n\t}\n\n\tocfs2_cleanup_delete_inode(inode, 0);\n\n\tstatus = ocfs2_wipe_inode(inode, di_bh);\n\tif (status < 0) {\n\t\tif (status != -EDEADLK)\n\t\t\tmlog_errno(status);\n\t\tgoto bail_unlock_inode;\n\t}\n\n\t \n\tOCFS2_I(inode)->ip_flags |= OCFS2_INODE_DELETED;\n\nbail_unlock_inode:\n\tocfs2_inode_unlock(inode, 1);\n\tbrelse(di_bh);\n\nbail_unlock_nfs_sync:\n\tocfs2_nfs_sync_unlock(OCFS2_SB(inode->i_sb), 0);\n\nbail_unblock:\n\tocfs2_unblock_signals(&oldset);\nbail:\n\treturn;\n}\n\nstatic void ocfs2_clear_inode(struct inode *inode)\n{\n\tint status;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tclear_inode(inode);\n\ttrace_ocfs2_clear_inode((unsigned long long)oi->ip_blkno,\n\t\t\t\tinode->i_nlink);\n\n\tmlog_bug_on_msg(osb == NULL,\n\t\t\t\"Inode=%lu\\n\", inode->i_ino);\n\n\tdquot_drop(inode);\n\n\t \n\tocfs2_open_unlock(inode);\n\n\t \n\tocfs2_mark_lockres_freeing(osb, &oi->ip_rw_lockres);\n\tocfs2_mark_lockres_freeing(osb, &oi->ip_inode_lockres);\n\tocfs2_mark_lockres_freeing(osb, &oi->ip_open_lockres);\n\n\tocfs2_resv_discard(&osb->osb_la_resmap,\n\t\t\t   &oi->ip_la_data_resv);\n\tocfs2_resv_init_once(&oi->ip_la_data_resv);\n\n\t \n\tif (!(oi->ip_flags & OCFS2_INODE_DELETED))\n\t\tocfs2_checkpoint_inode(inode);\n\n\tmlog_bug_on_msg(!list_empty(&oi->ip_io_markers),\n\t\t\t\"Clear inode of %llu, inode has io markers\\n\",\n\t\t\t(unsigned long long)oi->ip_blkno);\n\tmlog_bug_on_msg(!list_empty(&oi->ip_unwritten_list),\n\t\t\t\"Clear inode of %llu, inode has unwritten extents\\n\",\n\t\t\t(unsigned long long)oi->ip_blkno);\n\n\tocfs2_extent_map_trunc(inode, 0);\n\n\tstatus = ocfs2_drop_inode_locks(inode);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\tocfs2_lock_res_free(&oi->ip_rw_lockres);\n\tocfs2_lock_res_free(&oi->ip_inode_lockres);\n\tocfs2_lock_res_free(&oi->ip_open_lockres);\n\n\tocfs2_metadata_cache_exit(INODE_CACHE(inode));\n\n\tmlog_bug_on_msg(INODE_CACHE(inode)->ci_num_cached,\n\t\t\t\"Clear inode of %llu, inode has %u cache items\\n\",\n\t\t\t(unsigned long long)oi->ip_blkno,\n\t\t\tINODE_CACHE(inode)->ci_num_cached);\n\n\tmlog_bug_on_msg(!(INODE_CACHE(inode)->ci_flags & OCFS2_CACHE_FL_INLINE),\n\t\t\t\"Clear inode of %llu, inode has a bad flag\\n\",\n\t\t\t(unsigned long long)oi->ip_blkno);\n\n\tmlog_bug_on_msg(spin_is_locked(&oi->ip_lock),\n\t\t\t\"Clear inode of %llu, inode is locked\\n\",\n\t\t\t(unsigned long long)oi->ip_blkno);\n\n\tmlog_bug_on_msg(!mutex_trylock(&oi->ip_io_mutex),\n\t\t\t\"Clear inode of %llu, io_mutex is locked\\n\",\n\t\t\t(unsigned long long)oi->ip_blkno);\n\tmutex_unlock(&oi->ip_io_mutex);\n\n\t \n\tmlog_bug_on_msg(!down_write_trylock(&oi->ip_alloc_sem),\n\t\t\t\"Clear inode of %llu, alloc_sem is locked\\n\",\n\t\t\t(unsigned long long)oi->ip_blkno);\n\tup_write(&oi->ip_alloc_sem);\n\n\tmlog_bug_on_msg(oi->ip_open_count,\n\t\t\t\"Clear inode of %llu has open count %d\\n\",\n\t\t\t(unsigned long long)oi->ip_blkno, oi->ip_open_count);\n\n\t \n\toi->ip_flags = 0;\n\toi->ip_dir_start_lookup = 0;\n\toi->ip_blkno = 0ULL;\n\n\t \n\tjbd2_journal_release_jbd_inode(osb->journal->j_journal,\n\t\t\t\t       &oi->ip_jinode);\n}\n\nvoid ocfs2_evict_inode(struct inode *inode)\n{\n\tif (!inode->i_nlink ||\n\t    (OCFS2_I(inode)->ip_flags & OCFS2_INODE_MAYBE_ORPHANED)) {\n\t\tocfs2_delete_inode(inode);\n\t} else {\n\t\ttruncate_inode_pages_final(&inode->i_data);\n\t}\n\tocfs2_clear_inode(inode);\n}\n\n \nint ocfs2_drop_inode(struct inode *inode)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\ttrace_ocfs2_drop_inode((unsigned long long)oi->ip_blkno,\n\t\t\t\tinode->i_nlink, oi->ip_flags);\n\n\tassert_spin_locked(&inode->i_lock);\n\tinode->i_state |= I_WILL_FREE;\n\tspin_unlock(&inode->i_lock);\n\twrite_inode_now(inode, 1);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(inode->i_state & I_NEW);\n\tinode->i_state &= ~I_WILL_FREE;\n\n\treturn 1;\n}\n\n \nint ocfs2_inode_revalidate(struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tint status = 0;\n\n\ttrace_ocfs2_inode_revalidate(inode,\n\t\tinode ? (unsigned long long)OCFS2_I(inode)->ip_blkno : 0ULL,\n\t\tinode ? (unsigned long long)OCFS2_I(inode)->ip_flags : 0);\n\n\tif (!inode) {\n\t\tstatus = -ENOENT;\n\t\tgoto bail;\n\t}\n\n\tspin_lock(&OCFS2_I(inode)->ip_lock);\n\tif (OCFS2_I(inode)->ip_flags & OCFS2_INODE_DELETED) {\n\t\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n\t\tstatus = -ENOENT;\n\t\tgoto bail;\n\t}\n\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n\n\t \n\tstatus = ocfs2_inode_lock(inode, NULL, 0);\n\tif (status < 0) {\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tocfs2_inode_unlock(inode, 0);\nbail:\n\treturn status;\n}\n\n \nint ocfs2_mark_inode_dirty(handle_t *handle,\n\t\t\t   struct inode *inode,\n\t\t\t   struct buffer_head *bh)\n{\n\tint status;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) bh->b_data;\n\n\ttrace_ocfs2_mark_inode_dirty((unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode), bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tspin_lock(&OCFS2_I(inode)->ip_lock);\n\tfe->i_clusters = cpu_to_le32(OCFS2_I(inode)->ip_clusters);\n\tocfs2_get_inode_flags(OCFS2_I(inode));\n\tfe->i_attr = cpu_to_le32(OCFS2_I(inode)->ip_attr);\n\tfe->i_dyn_features = cpu_to_le16(OCFS2_I(inode)->ip_dyn_features);\n\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n\n\tfe->i_size = cpu_to_le64(i_size_read(inode));\n\tocfs2_set_links_count(fe, inode->i_nlink);\n\tfe->i_uid = cpu_to_le32(i_uid_read(inode));\n\tfe->i_gid = cpu_to_le32(i_gid_read(inode));\n\tfe->i_mode = cpu_to_le16(inode->i_mode);\n\tfe->i_atime = cpu_to_le64(inode->i_atime.tv_sec);\n\tfe->i_atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);\n\tfe->i_ctime = cpu_to_le64(inode_get_ctime(inode).tv_sec);\n\tfe->i_ctime_nsec = cpu_to_le32(inode_get_ctime(inode).tv_nsec);\n\tfe->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);\n\tfe->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\n\tocfs2_journal_dirty(handle, bh);\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\nleave:\n\treturn status;\n}\n\n \nvoid ocfs2_refresh_inode(struct inode *inode,\n\t\t\t struct ocfs2_dinode *fe)\n{\n\tspin_lock(&OCFS2_I(inode)->ip_lock);\n\n\tOCFS2_I(inode)->ip_clusters = le32_to_cpu(fe->i_clusters);\n\tOCFS2_I(inode)->ip_attr = le32_to_cpu(fe->i_attr);\n\tOCFS2_I(inode)->ip_dyn_features = le16_to_cpu(fe->i_dyn_features);\n\tocfs2_set_inode_flags(inode);\n\ti_size_write(inode, le64_to_cpu(fe->i_size));\n\tset_nlink(inode, ocfs2_read_links_count(fe));\n\ti_uid_write(inode, le32_to_cpu(fe->i_uid));\n\ti_gid_write(inode, le32_to_cpu(fe->i_gid));\n\tinode->i_mode = le16_to_cpu(fe->i_mode);\n\tif (S_ISLNK(inode->i_mode) && le32_to_cpu(fe->i_clusters) == 0)\n\t\tinode->i_blocks = 0;\n\telse\n\t\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\tinode->i_atime.tv_sec = le64_to_cpu(fe->i_atime);\n\tinode->i_atime.tv_nsec = le32_to_cpu(fe->i_atime_nsec);\n\tinode->i_mtime.tv_sec = le64_to_cpu(fe->i_mtime);\n\tinode->i_mtime.tv_nsec = le32_to_cpu(fe->i_mtime_nsec);\n\tinode_set_ctime(inode, le64_to_cpu(fe->i_ctime),\n\t\t\tle32_to_cpu(fe->i_ctime_nsec));\n\n\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n}\n\nint ocfs2_validate_inode_block(struct super_block *sb,\n\t\t\t       struct buffer_head *bh)\n{\n\tint rc;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)bh->b_data;\n\n\ttrace_ocfs2_validate_inode_block((unsigned long long)bh->b_blocknr);\n\n\tBUG_ON(!buffer_uptodate(bh));\n\n\t \n\trc = ocfs2_validate_meta_ecc(sb, bh->b_data, &di->i_check);\n\tif (rc) {\n\t\tmlog(ML_ERROR, \"Checksum failed for dinode %llu\\n\",\n\t\t     (unsigned long long)bh->b_blocknr);\n\t\tgoto bail;\n\t}\n\n\t \n\n\trc = -EINVAL;\n\n\tif (!OCFS2_IS_VALID_DINODE(di)) {\n\t\trc = ocfs2_error(sb, \"Invalid dinode #%llu: signature = %.*s\\n\",\n\t\t\t\t (unsigned long long)bh->b_blocknr, 7,\n\t\t\t\t di->i_signature);\n\t\tgoto bail;\n\t}\n\n\tif (le64_to_cpu(di->i_blkno) != bh->b_blocknr) {\n\t\trc = ocfs2_error(sb, \"Invalid dinode #%llu: i_blkno is %llu\\n\",\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t (unsigned long long)le64_to_cpu(di->i_blkno));\n\t\tgoto bail;\n\t}\n\n\tif (!(di->i_flags & cpu_to_le32(OCFS2_VALID_FL))) {\n\t\trc = ocfs2_error(sb,\n\t\t\t\t \"Invalid dinode #%llu: OCFS2_VALID_FL not set\\n\",\n\t\t\t\t (unsigned long long)bh->b_blocknr);\n\t\tgoto bail;\n\t}\n\n\tif (le32_to_cpu(di->i_fs_generation) !=\n\t    OCFS2_SB(sb)->fs_generation) {\n\t\trc = ocfs2_error(sb,\n\t\t\t\t \"Invalid dinode #%llu: fs_generation is %u\\n\",\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t le32_to_cpu(di->i_fs_generation));\n\t\tgoto bail;\n\t}\n\n\trc = 0;\n\nbail:\n\treturn rc;\n}\n\nstatic int ocfs2_filecheck_validate_inode_block(struct super_block *sb,\n\t\t\t\t\t\tstruct buffer_head *bh)\n{\n\tint rc = 0;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)bh->b_data;\n\n\ttrace_ocfs2_filecheck_validate_inode_block(\n\t\t(unsigned long long)bh->b_blocknr);\n\n\tBUG_ON(!buffer_uptodate(bh));\n\n\t \n\trc = ocfs2_validate_meta_ecc(sb, bh->b_data, &di->i_check);\n\tif (rc) {\n\t\tmlog(ML_ERROR,\n\t\t     \"Filecheck: checksum failed for dinode %llu\\n\",\n\t\t     (unsigned long long)bh->b_blocknr);\n\t\trc = -OCFS2_FILECHECK_ERR_BLOCKECC;\n\t}\n\n\tif (!OCFS2_IS_VALID_DINODE(di)) {\n\t\tmlog(ML_ERROR,\n\t\t     \"Filecheck: invalid dinode #%llu: signature = %.*s\\n\",\n\t\t     (unsigned long long)bh->b_blocknr, 7, di->i_signature);\n\t\trc = -OCFS2_FILECHECK_ERR_INVALIDINO;\n\t\tgoto bail;\n\t} else if (rc)\n\t\tgoto bail;\n\n\tif (le64_to_cpu(di->i_blkno) != bh->b_blocknr) {\n\t\tmlog(ML_ERROR,\n\t\t     \"Filecheck: invalid dinode #%llu: i_blkno is %llu\\n\",\n\t\t     (unsigned long long)bh->b_blocknr,\n\t\t     (unsigned long long)le64_to_cpu(di->i_blkno));\n\t\trc = -OCFS2_FILECHECK_ERR_BLOCKNO;\n\t\tgoto bail;\n\t}\n\n\tif (!(di->i_flags & cpu_to_le32(OCFS2_VALID_FL))) {\n\t\tmlog(ML_ERROR,\n\t\t     \"Filecheck: invalid dinode #%llu: OCFS2_VALID_FL \"\n\t\t     \"not set\\n\",\n\t\t     (unsigned long long)bh->b_blocknr);\n\t\trc = -OCFS2_FILECHECK_ERR_VALIDFLAG;\n\t\tgoto bail;\n\t}\n\n\tif (le32_to_cpu(di->i_fs_generation) !=\n\t    OCFS2_SB(sb)->fs_generation) {\n\t\tmlog(ML_ERROR,\n\t\t     \"Filecheck: invalid dinode #%llu: fs_generation is %u\\n\",\n\t\t     (unsigned long long)bh->b_blocknr,\n\t\t     le32_to_cpu(di->i_fs_generation));\n\t\trc = -OCFS2_FILECHECK_ERR_GENERATION;\n\t}\n\nbail:\n\treturn rc;\n}\n\nstatic int ocfs2_filecheck_repair_inode_block(struct super_block *sb,\n\t\t\t\t\t      struct buffer_head *bh)\n{\n\tint changed = 0;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)bh->b_data;\n\n\tif (!ocfs2_filecheck_validate_inode_block(sb, bh))\n\t\treturn 0;\n\n\ttrace_ocfs2_filecheck_repair_inode_block(\n\t\t(unsigned long long)bh->b_blocknr);\n\n\tif (ocfs2_is_hard_readonly(OCFS2_SB(sb)) ||\n\t    ocfs2_is_soft_readonly(OCFS2_SB(sb))) {\n\t\tmlog(ML_ERROR,\n\t\t     \"Filecheck: cannot repair dinode #%llu \"\n\t\t     \"on readonly filesystem\\n\",\n\t\t     (unsigned long long)bh->b_blocknr);\n\t\treturn -OCFS2_FILECHECK_ERR_READONLY;\n\t}\n\n\tif (buffer_jbd(bh)) {\n\t\tmlog(ML_ERROR,\n\t\t     \"Filecheck: cannot repair dinode #%llu, \"\n\t\t     \"its buffer is in jbd\\n\",\n\t\t     (unsigned long long)bh->b_blocknr);\n\t\treturn -OCFS2_FILECHECK_ERR_INJBD;\n\t}\n\n\tif (!OCFS2_IS_VALID_DINODE(di)) {\n\t\t \n\t\treturn -OCFS2_FILECHECK_ERR_INVALIDINO;\n\t}\n\n\tif (!(di->i_flags & cpu_to_le32(OCFS2_VALID_FL))) {\n\t\t \n\t\treturn -OCFS2_FILECHECK_ERR_VALIDFLAG;\n\t}\n\n\tif (le64_to_cpu(di->i_blkno) != bh->b_blocknr) {\n\t\tdi->i_blkno = cpu_to_le64(bh->b_blocknr);\n\t\tchanged = 1;\n\t\tmlog(ML_ERROR,\n\t\t     \"Filecheck: reset dinode #%llu: i_blkno to %llu\\n\",\n\t\t     (unsigned long long)bh->b_blocknr,\n\t\t     (unsigned long long)le64_to_cpu(di->i_blkno));\n\t}\n\n\tif (le32_to_cpu(di->i_fs_generation) !=\n\t    OCFS2_SB(sb)->fs_generation) {\n\t\tdi->i_fs_generation = cpu_to_le32(OCFS2_SB(sb)->fs_generation);\n\t\tchanged = 1;\n\t\tmlog(ML_ERROR,\n\t\t     \"Filecheck: reset dinode #%llu: fs_generation to %u\\n\",\n\t\t     (unsigned long long)bh->b_blocknr,\n\t\t     le32_to_cpu(di->i_fs_generation));\n\t}\n\n\tif (changed || ocfs2_validate_meta_ecc(sb, bh->b_data, &di->i_check)) {\n\t\tocfs2_compute_meta_ecc(sb, bh->b_data, &di->i_check);\n\t\tmark_buffer_dirty(bh);\n\t\tmlog(ML_ERROR,\n\t\t     \"Filecheck: reset dinode #%llu: compute meta ecc\\n\",\n\t\t     (unsigned long long)bh->b_blocknr);\n\t}\n\n\treturn 0;\n}\n\nstatic int\nocfs2_filecheck_read_inode_block_full(struct inode *inode,\n\t\t\t\t      struct buffer_head **bh,\n\t\t\t\t      int flags, int type)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\tif (!type)  \n\t\trc = ocfs2_read_blocks(INODE_CACHE(inode),\n\t\t\t\tOCFS2_I(inode)->ip_blkno,\n\t\t\t\t1, &tmp, flags,\n\t\t\t\tocfs2_filecheck_validate_inode_block);\n\telse  \n\t\trc = ocfs2_read_blocks(INODE_CACHE(inode),\n\t\t\t\tOCFS2_I(inode)->ip_blkno,\n\t\t\t\t1, &tmp, flags,\n\t\t\t\tocfs2_filecheck_repair_inode_block);\n\n\t \n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}\n\nint ocfs2_read_inode_block_full(struct inode *inode, struct buffer_head **bh,\n\t\t\t\tint flags)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_blocks(INODE_CACHE(inode), OCFS2_I(inode)->ip_blkno,\n\t\t\t       1, &tmp, flags, ocfs2_validate_inode_block);\n\n\t \n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}\n\nint ocfs2_read_inode_block(struct inode *inode, struct buffer_head **bh)\n{\n\treturn ocfs2_read_inode_block_full(inode, bh, 0);\n}\n\n\nstatic u64 ocfs2_inode_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tstruct ocfs2_inode_info *oi = cache_info_to_inode(ci);\n\n\treturn oi->ip_blkno;\n}\n\nstatic struct super_block *ocfs2_inode_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tstruct ocfs2_inode_info *oi = cache_info_to_inode(ci);\n\n\treturn oi->vfs_inode.i_sb;\n}\n\nstatic void ocfs2_inode_cache_lock(struct ocfs2_caching_info *ci)\n{\n\tstruct ocfs2_inode_info *oi = cache_info_to_inode(ci);\n\n\tspin_lock(&oi->ip_lock);\n}\n\nstatic void ocfs2_inode_cache_unlock(struct ocfs2_caching_info *ci)\n{\n\tstruct ocfs2_inode_info *oi = cache_info_to_inode(ci);\n\n\tspin_unlock(&oi->ip_lock);\n}\n\nstatic void ocfs2_inode_cache_io_lock(struct ocfs2_caching_info *ci)\n{\n\tstruct ocfs2_inode_info *oi = cache_info_to_inode(ci);\n\n\tmutex_lock(&oi->ip_io_mutex);\n}\n\nstatic void ocfs2_inode_cache_io_unlock(struct ocfs2_caching_info *ci)\n{\n\tstruct ocfs2_inode_info *oi = cache_info_to_inode(ci);\n\n\tmutex_unlock(&oi->ip_io_mutex);\n}\n\nconst struct ocfs2_caching_operations ocfs2_inode_caching_ops = {\n\t.co_owner\t\t= ocfs2_inode_cache_owner,\n\t.co_get_super\t\t= ocfs2_inode_cache_get_super,\n\t.co_cache_lock\t\t= ocfs2_inode_cache_lock,\n\t.co_cache_unlock\t= ocfs2_inode_cache_unlock,\n\t.co_io_lock\t\t= ocfs2_inode_cache_io_lock,\n\t.co_io_unlock\t\t= ocfs2_inode_cache_io_unlock,\n};\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}