{
  "module_name": "dlmglue.h",
  "hash_id": "2c12c5632d7ea8a0bac6c4842a76af7f47dc4d77a70ebaf1eccc644be486313d",
  "original_prompt": "Ingested from linux-6.6.14/fs/ocfs2/dlmglue.h",
  "human_readable_source": " \n \n\n\n#ifndef DLMGLUE_H\n#define DLMGLUE_H\n\n#include \"dcache.h\"\n\n#define OCFS2_LVB_VERSION 5\n\nstruct ocfs2_meta_lvb {\n\t__u8         lvb_version;\n\t__u8         lvb_reserved0;\n\t__be16       lvb_idynfeatures;\n\t__be32       lvb_iclusters;\n\t__be32       lvb_iuid;\n\t__be32       lvb_igid;\n\t__be64       lvb_iatime_packed;\n\t__be64       lvb_ictime_packed;\n\t__be64       lvb_imtime_packed;\n\t__be64       lvb_isize;\n\t__be16       lvb_imode;\n\t__be16       lvb_inlink;\n\t__be32       lvb_iattr;\n\t__be32       lvb_igeneration;\n\t__be32       lvb_reserved2;\n};\n\n#define OCFS2_QINFO_LVB_VERSION 1\n\nstruct ocfs2_qinfo_lvb {\n\t__u8\tlvb_version;\n\t__u8\tlvb_reserved[3];\n\t__be32\tlvb_bgrace;\n\t__be32\tlvb_igrace;\n\t__be32\tlvb_syncms;\n\t__be32\tlvb_blocks;\n\t__be32\tlvb_free_blk;\n\t__be32\tlvb_free_entry;\n};\n\n#define OCFS2_ORPHAN_LVB_VERSION 1\n\nstruct ocfs2_orphan_scan_lvb {\n\t__u8\tlvb_version;\n\t__u8\tlvb_reserved[3];\n\t__be32\tlvb_os_seqno;\n};\n\n#define OCFS2_TRIMFS_LVB_VERSION 1\n\nstruct ocfs2_trim_fs_lvb {\n\t__u8\tlvb_version;\n\t__u8\tlvb_success;\n\t__u8\tlvb_reserved[2];\n\t__be32\tlvb_nodenum;\n\t__be64\tlvb_start;\n\t__be64\tlvb_len;\n\t__be64\tlvb_minlen;\n\t__be64\tlvb_trimlen;\n};\n\nstruct ocfs2_trim_fs_info {\n\tu8\ttf_valid;\t \n\tu8\ttf_success;\t \n\tu32\ttf_nodenum;\t \n\tu64\ttf_start;\t \n\tu64\ttf_len;\t\t \n\tu64\ttf_minlen;\t \n\tu64\ttf_trimlen;\t \n};\n\nstruct ocfs2_lock_holder {\n\tstruct list_head oh_list;\n\tstruct pid *oh_owner_pid;\n\tint oh_ex;\n};\n\n \n \n#define OCFS2_META_LOCK_RECOVERY\t(0x01)\n \n#define OCFS2_META_LOCK_NOQUEUE\t\t(0x02)\n \n#define OCFS2_LOCK_NONBLOCK\t\t(0x04)\n \n#define OCFS2_META_LOCK_GETBH\t\t(0x08)\n\n \nenum {\n\tOI_LS_NORMAL = 0,\n\tOI_LS_PARENT,\n\tOI_LS_RENAME1,\n\tOI_LS_RENAME2,\n\tOI_LS_REFLINK_TARGET,\n};\n\nint ocfs2_dlm_init(struct ocfs2_super *osb);\nvoid ocfs2_dlm_shutdown(struct ocfs2_super *osb, int hangup_pending);\nvoid ocfs2_lock_res_init_once(struct ocfs2_lock_res *res);\nvoid ocfs2_inode_lock_res_init(struct ocfs2_lock_res *res,\n\t\t\t       enum ocfs2_lock_type type,\n\t\t\t       unsigned int generation,\n\t\t\t       struct inode *inode);\nvoid ocfs2_dentry_lock_res_init(struct ocfs2_dentry_lock *dl,\n\t\t\t\tu64 parent, struct inode *inode);\nstruct ocfs2_file_private;\nvoid ocfs2_file_lock_res_init(struct ocfs2_lock_res *lockres,\n\t\t\t      struct ocfs2_file_private *fp);\nstruct ocfs2_mem_dqinfo;\nvoid ocfs2_qinfo_lock_res_init(struct ocfs2_lock_res *lockres,\n                               struct ocfs2_mem_dqinfo *info);\nvoid ocfs2_refcount_lock_res_init(struct ocfs2_lock_res *lockres,\n\t\t\t\t  struct ocfs2_super *osb, u64 ref_blkno,\n\t\t\t\t  unsigned int generation);\nvoid ocfs2_lock_res_free(struct ocfs2_lock_res *res);\nint ocfs2_create_new_inode_locks(struct inode *inode);\nint ocfs2_drop_inode_locks(struct inode *inode);\nint ocfs2_rw_lock(struct inode *inode, int write);\nint ocfs2_try_rw_lock(struct inode *inode, int write);\nvoid ocfs2_rw_unlock(struct inode *inode, int write);\nint ocfs2_open_lock(struct inode *inode);\nint ocfs2_try_open_lock(struct inode *inode, int write);\nvoid ocfs2_open_unlock(struct inode *inode);\nint ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level, int wait);\nint ocfs2_inode_lock_full_nested(struct inode *inode,\n\t\t\t struct buffer_head **ret_bh,\n\t\t\t int ex,\n\t\t\t int arg_flags,\n\t\t\t int subclass);\nint ocfs2_inode_lock_with_page(struct inode *inode,\n\t\t\t      struct buffer_head **ret_bh,\n\t\t\t      int ex,\n\t\t\t      struct page *page);\n \n#define ocfs2_inode_lock_full(i, r, e, f)\\\n\t\tocfs2_inode_lock_full_nested(i, r, e, f, OI_LS_NORMAL)\n#define ocfs2_inode_lock_nested(i, b, e, s)\\\n\t\tocfs2_inode_lock_full_nested(i, b, e, 0, s)\n \n#define ocfs2_inode_lock(i, b, e) ocfs2_inode_lock_full_nested(i, b, e, 0, OI_LS_NORMAL)\n#define ocfs2_try_inode_lock(i, b, e)\\\n\t\tocfs2_inode_lock_full_nested(i, b, e, OCFS2_META_LOCK_NOQUEUE,\\\n\t\tOI_LS_NORMAL)\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex);\nint ocfs2_super_lock(struct ocfs2_super *osb,\n\t\t     int ex);\nvoid ocfs2_super_unlock(struct ocfs2_super *osb,\n\t\t\tint ex);\nint ocfs2_orphan_scan_lock(struct ocfs2_super *osb, u32 *seqno);\nvoid ocfs2_orphan_scan_unlock(struct ocfs2_super *osb, u32 seqno);\n\nint ocfs2_rename_lock(struct ocfs2_super *osb);\nvoid ocfs2_rename_unlock(struct ocfs2_super *osb);\nint ocfs2_nfs_sync_lock(struct ocfs2_super *osb, int ex);\nvoid ocfs2_nfs_sync_unlock(struct ocfs2_super *osb, int ex);\nvoid ocfs2_trim_fs_lock_res_init(struct ocfs2_super *osb);\nvoid ocfs2_trim_fs_lock_res_uninit(struct ocfs2_super *osb);\nint ocfs2_trim_fs_lock(struct ocfs2_super *osb,\n\t\t       struct ocfs2_trim_fs_info *info, int trylock);\nvoid ocfs2_trim_fs_unlock(struct ocfs2_super *osb,\n\t\t\t  struct ocfs2_trim_fs_info *info);\nint ocfs2_dentry_lock(struct dentry *dentry, int ex);\nvoid ocfs2_dentry_unlock(struct dentry *dentry, int ex);\nint ocfs2_file_lock(struct file *file, int ex, int trylock);\nvoid ocfs2_file_unlock(struct file *file);\nint ocfs2_qinfo_lock(struct ocfs2_mem_dqinfo *oinfo, int ex);\nvoid ocfs2_qinfo_unlock(struct ocfs2_mem_dqinfo *oinfo, int ex);\nstruct ocfs2_refcount_tree;\nint ocfs2_refcount_lock(struct ocfs2_refcount_tree *ref_tree, int ex);\nvoid ocfs2_refcount_unlock(struct ocfs2_refcount_tree *ref_tree, int ex);\n\n\nvoid ocfs2_mark_lockres_freeing(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nvoid ocfs2_simple_drop_lockres(struct ocfs2_super *osb,\n\t\t\t       struct ocfs2_lock_res *lockres);\n\n \nvoid ocfs2_wake_downconvert_thread(struct ocfs2_super *osb);\n\nstruct ocfs2_dlm_debug *ocfs2_new_dlm_debug(void);\nvoid ocfs2_put_dlm_debug(struct ocfs2_dlm_debug *dlm_debug);\n\n \nvoid ocfs2_set_locking_protocol(void);\n\n \nint ocfs2_inode_lock_tracker(struct inode *inode,\n\t\t\t     struct buffer_head **ret_bh,\n\t\t\t     int ex,\n\t\t\t     struct ocfs2_lock_holder *oh);\nvoid ocfs2_inode_unlock_tracker(struct inode *inode,\n\t\t\t\tint ex,\n\t\t\t\tstruct ocfs2_lock_holder *oh,\n\t\t\t\tint had_lock);\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}