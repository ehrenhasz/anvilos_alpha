{
  "module_name": "quota_global.c",
  "hash_id": "3d7ed380e369d18d2e37b29684ff14b01c9e92d681979cf7048f1cc7172d84cc",
  "original_prompt": "Ingested from linux-6.6.14/fs/ocfs2/quota_global.c",
  "human_readable_source": "\n \n#include <linux/spinlock.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/quota.h>\n#include <linux/quotaops.h>\n#include <linux/dqblk_qtree.h>\n#include <linux/jiffies.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/llist.h>\n#include <linux/iversion.h>\n\n#include <cluster/masklog.h>\n\n#include \"ocfs2_fs.h\"\n#include \"ocfs2.h\"\n#include \"alloc.h\"\n#include \"blockcheck.h\"\n#include \"inode.h\"\n#include \"journal.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"dlmglue.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"quota.h\"\n#include \"ocfs2_trace.h\"\n\n \n\nstatic void qsync_work_fn(struct work_struct *work);\n\nstatic void ocfs2_global_disk2memdqb(struct dquot *dquot, void *dp)\n{\n\tstruct ocfs2_global_disk_dqblk *d = dp;\n\tstruct mem_dqblk *m = &dquot->dq_dqb;\n\n\t \n\tif (!test_bit(DQ_LASTSET_B + QIF_ILIMITS_B, &dquot->dq_flags)) {\n\t\tm->dqb_ihardlimit = le64_to_cpu(d->dqb_ihardlimit);\n\t\tm->dqb_isoftlimit = le64_to_cpu(d->dqb_isoftlimit);\n\t}\n\tif (!test_bit(DQ_LASTSET_B + QIF_INODES_B, &dquot->dq_flags))\n\t\tm->dqb_curinodes = le64_to_cpu(d->dqb_curinodes);\n\tif (!test_bit(DQ_LASTSET_B + QIF_BLIMITS_B, &dquot->dq_flags)) {\n\t\tm->dqb_bhardlimit = le64_to_cpu(d->dqb_bhardlimit);\n\t\tm->dqb_bsoftlimit = le64_to_cpu(d->dqb_bsoftlimit);\n\t}\n\tif (!test_bit(DQ_LASTSET_B + QIF_SPACE_B, &dquot->dq_flags))\n\t\tm->dqb_curspace = le64_to_cpu(d->dqb_curspace);\n\tif (!test_bit(DQ_LASTSET_B + QIF_BTIME_B, &dquot->dq_flags))\n\t\tm->dqb_btime = le64_to_cpu(d->dqb_btime);\n\tif (!test_bit(DQ_LASTSET_B + QIF_ITIME_B, &dquot->dq_flags))\n\t\tm->dqb_itime = le64_to_cpu(d->dqb_itime);\n\tOCFS2_DQUOT(dquot)->dq_use_count = le32_to_cpu(d->dqb_use_count);\n}\n\nstatic void ocfs2_global_mem2diskdqb(void *dp, struct dquot *dquot)\n{\n\tstruct ocfs2_global_disk_dqblk *d = dp;\n\tstruct mem_dqblk *m = &dquot->dq_dqb;\n\n\td->dqb_id = cpu_to_le32(from_kqid(&init_user_ns, dquot->dq_id));\n\td->dqb_use_count = cpu_to_le32(OCFS2_DQUOT(dquot)->dq_use_count);\n\td->dqb_ihardlimit = cpu_to_le64(m->dqb_ihardlimit);\n\td->dqb_isoftlimit = cpu_to_le64(m->dqb_isoftlimit);\n\td->dqb_curinodes = cpu_to_le64(m->dqb_curinodes);\n\td->dqb_bhardlimit = cpu_to_le64(m->dqb_bhardlimit);\n\td->dqb_bsoftlimit = cpu_to_le64(m->dqb_bsoftlimit);\n\td->dqb_curspace = cpu_to_le64(m->dqb_curspace);\n\td->dqb_btime = cpu_to_le64(m->dqb_btime);\n\td->dqb_itime = cpu_to_le64(m->dqb_itime);\n\td->dqb_pad1 = d->dqb_pad2 = 0;\n}\n\nstatic int ocfs2_global_is_id(void *dp, struct dquot *dquot)\n{\n\tstruct ocfs2_global_disk_dqblk *d = dp;\n\tstruct ocfs2_mem_dqinfo *oinfo =\n\t\t\tsb_dqinfo(dquot->dq_sb, dquot->dq_id.type)->dqi_priv;\n\n\tif (qtree_entry_unused(&oinfo->dqi_gi, dp))\n\t\treturn 0;\n\n\treturn qid_eq(make_kqid(&init_user_ns, dquot->dq_id.type,\n\t\t\t\tle32_to_cpu(d->dqb_id)),\n\t\t      dquot->dq_id);\n}\n\nconst struct qtree_fmt_operations ocfs2_global_ops = {\n\t.mem2disk_dqblk = ocfs2_global_mem2diskdqb,\n\t.disk2mem_dqblk = ocfs2_global_disk2memdqb,\n\t.is_id = ocfs2_global_is_id,\n};\n\nint ocfs2_validate_quota_block(struct super_block *sb, struct buffer_head *bh)\n{\n\tstruct ocfs2_disk_dqtrailer *dqt =\n\t\tocfs2_block_dqtrailer(sb->s_blocksize, bh->b_data);\n\n\ttrace_ocfs2_validate_quota_block((unsigned long long)bh->b_blocknr);\n\n\tBUG_ON(!buffer_uptodate(bh));\n\n\t \n\treturn ocfs2_validate_meta_ecc(sb, bh->b_data, &dqt->dq_check);\n}\n\nint ocfs2_read_quota_phys_block(struct inode *inode, u64 p_block,\n\t\t\t\tstruct buffer_head **bhp)\n{\n\tint rc;\n\n\t*bhp = NULL;\n\trc = ocfs2_read_blocks(INODE_CACHE(inode), p_block, 1, bhp, 0,\n\t\t\t       ocfs2_validate_quota_block);\n\tif (rc)\n\t\tmlog_errno(rc);\n\treturn rc;\n}\n\n \nssize_t ocfs2_quota_read(struct super_block *sb, int type, char *data,\n\t\t\t size_t len, loff_t off)\n{\n\tstruct ocfs2_mem_dqinfo *oinfo = sb_dqinfo(sb, type)->dqi_priv;\n\tstruct inode *gqinode = oinfo->dqi_gqinode;\n\tloff_t i_size = i_size_read(gqinode);\n\tint offset = off & (sb->s_blocksize - 1);\n\tsector_t blk = off >> sb->s_blocksize_bits;\n\tint err = 0;\n\tstruct buffer_head *bh;\n\tsize_t toread, tocopy;\n\tu64 pblock = 0, pcount = 0;\n\n\tif (off > i_size)\n\t\treturn 0;\n\tif (off + len > i_size)\n\t\tlen = i_size - off;\n\ttoread = len;\n\twhile (toread > 0) {\n\t\ttocopy = min_t(size_t, (sb->s_blocksize - offset), toread);\n\t\tif (!pcount) {\n\t\t\terr = ocfs2_extent_map_get_blocks(gqinode, blk, &pblock,\n\t\t\t\t\t\t\t  &pcount, NULL);\n\t\t\tif (err) {\n\t\t\t\tmlog_errno(err);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t} else {\n\t\t\tpcount--;\n\t\t\tpblock++;\n\t\t}\n\t\tbh = NULL;\n\t\terr = ocfs2_read_quota_phys_block(gqinode, pblock, &bh);\n\t\tif (err) {\n\t\t\tmlog_errno(err);\n\t\t\treturn err;\n\t\t}\n\t\tmemcpy(data, bh->b_data + offset, tocopy);\n\t\tbrelse(bh);\n\t\toffset = 0;\n\t\ttoread -= tocopy;\n\t\tdata += tocopy;\n\t\tblk++;\n\t}\n\treturn len;\n}\n\n \nssize_t ocfs2_quota_write(struct super_block *sb, int type,\n\t\t\t  const char *data, size_t len, loff_t off)\n{\n\tstruct mem_dqinfo *info = sb_dqinfo(sb, type);\n\tstruct ocfs2_mem_dqinfo *oinfo = info->dqi_priv;\n\tstruct inode *gqinode = oinfo->dqi_gqinode;\n\tint offset = off & (sb->s_blocksize - 1);\n\tsector_t blk = off >> sb->s_blocksize_bits;\n\tint err = 0, new = 0, ja_type;\n\tstruct buffer_head *bh = NULL;\n\thandle_t *handle = journal_current_handle();\n\tu64 pblock, pcount;\n\n\tif (!handle) {\n\t\tmlog(ML_ERROR, \"Quota write (off=%llu, len=%llu) cancelled \"\n\t\t     \"because transaction was not started.\\n\",\n\t\t     (unsigned long long)off, (unsigned long long)len);\n\t\treturn -EIO;\n\t}\n\tif (len > sb->s_blocksize - OCFS2_QBLK_RESERVED_SPACE - offset) {\n\t\tWARN_ON(1);\n\t\tlen = sb->s_blocksize - OCFS2_QBLK_RESERVED_SPACE - offset;\n\t}\n\n\tif (i_size_read(gqinode) < off + len) {\n\t\tloff_t rounded_end =\n\t\t\t\tocfs2_align_bytes_to_blocks(sb, off + len);\n\n\t\t \n\t\terr = ocfs2_simple_size_update(gqinode,\n\t\t\t\t\t       oinfo->dqi_gqi_bh,\n\t\t\t\t\t       rounded_end);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\tnew = 1;\n\t}\n\terr = ocfs2_extent_map_get_blocks(gqinode, blk, &pblock, &pcount, NULL);\n\tif (err) {\n\t\tmlog_errno(err);\n\t\tgoto out;\n\t}\n\t \n\tif ((offset || len < sb->s_blocksize - OCFS2_QBLK_RESERVED_SPACE) &&\n\t    !new) {\n\t\terr = ocfs2_read_quota_phys_block(gqinode, pblock, &bh);\n\t\tja_type = OCFS2_JOURNAL_ACCESS_WRITE;\n\t} else {\n\t\tbh = sb_getblk(sb, pblock);\n\t\tif (!bh)\n\t\t\terr = -ENOMEM;\n\t\tja_type = OCFS2_JOURNAL_ACCESS_CREATE;\n\t}\n\tif (err) {\n\t\tmlog_errno(err);\n\t\tgoto out;\n\t}\n\tlock_buffer(bh);\n\tif (new)\n\t\tmemset(bh->b_data, 0, sb->s_blocksize);\n\tmemcpy(bh->b_data + offset, data, len);\n\tflush_dcache_page(bh->b_page);\n\tset_buffer_uptodate(bh);\n\tunlock_buffer(bh);\n\tocfs2_set_buffer_uptodate(INODE_CACHE(gqinode), bh);\n\terr = ocfs2_journal_access_dq(handle, INODE_CACHE(gqinode), bh,\n\t\t\t\t      ja_type);\n\tif (err < 0) {\n\t\tbrelse(bh);\n\t\tgoto out;\n\t}\n\tocfs2_journal_dirty(handle, bh);\n\tbrelse(bh);\nout:\n\tif (err) {\n\t\tmlog_errno(err);\n\t\treturn err;\n\t}\n\tinode_inc_iversion(gqinode);\n\tocfs2_mark_inode_dirty(handle, gqinode, oinfo->dqi_gqi_bh);\n\treturn len;\n}\n\nint ocfs2_lock_global_qf(struct ocfs2_mem_dqinfo *oinfo, int ex)\n{\n\tint status;\n\tstruct buffer_head *bh = NULL;\n\n\tstatus = ocfs2_inode_lock(oinfo->dqi_gqinode, &bh, ex);\n\tif (status < 0)\n\t\treturn status;\n\tspin_lock(&dq_data_lock);\n\tif (!oinfo->dqi_gqi_count++)\n\t\toinfo->dqi_gqi_bh = bh;\n\telse\n\t\tWARN_ON(bh != oinfo->dqi_gqi_bh);\n\tspin_unlock(&dq_data_lock);\n\tif (ex) {\n\t\tinode_lock(oinfo->dqi_gqinode);\n\t\tdown_write(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t} else {\n\t\tdown_read(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t}\n\treturn 0;\n}\n\nvoid ocfs2_unlock_global_qf(struct ocfs2_mem_dqinfo *oinfo, int ex)\n{\n\tif (ex) {\n\t\tup_write(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t\tinode_unlock(oinfo->dqi_gqinode);\n\t} else {\n\t\tup_read(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t}\n\tocfs2_inode_unlock(oinfo->dqi_gqinode, ex);\n\tbrelse(oinfo->dqi_gqi_bh);\n\tspin_lock(&dq_data_lock);\n\tif (!--oinfo->dqi_gqi_count)\n\t\toinfo->dqi_gqi_bh = NULL;\n\tspin_unlock(&dq_data_lock);\n}\n\n \nint ocfs2_global_read_info(struct super_block *sb, int type)\n{\n\tunsigned int ino[OCFS2_MAXQUOTAS] = { USER_QUOTA_SYSTEM_INODE,\n\t\t\t\t\t      GROUP_QUOTA_SYSTEM_INODE };\n\tstruct ocfs2_global_disk_dqinfo dinfo;\n\tstruct mem_dqinfo *info = sb_dqinfo(sb, type);\n\tstruct ocfs2_mem_dqinfo *oinfo = info->dqi_priv;\n\tu64 pcount;\n\tint status;\n\n\toinfo->dqi_gi.dqi_sb = sb;\n\toinfo->dqi_gi.dqi_type = type;\n\tocfs2_qinfo_lock_res_init(&oinfo->dqi_gqlock, oinfo);\n\toinfo->dqi_gi.dqi_entry_size = sizeof(struct ocfs2_global_disk_dqblk);\n\toinfo->dqi_gi.dqi_ops = &ocfs2_global_ops;\n\toinfo->dqi_gqi_bh = NULL;\n\toinfo->dqi_gqi_count = 0;\n\n\t \n\toinfo->dqi_gqinode = ocfs2_get_system_file_inode(OCFS2_SB(sb), ino[type],\n\t\t\tOCFS2_INVALID_SLOT);\n\tif (!oinfo->dqi_gqinode) {\n\t\tmlog(ML_ERROR, \"failed to get global quota inode (type=%d)\\n\",\n\t\t\ttype);\n\t\tstatus = -EINVAL;\n\t\tgoto out_err;\n\t}\n\n\tstatus = ocfs2_lock_global_qf(oinfo, 0);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_err;\n\t}\n\n\tstatus = ocfs2_extent_map_get_blocks(oinfo->dqi_gqinode, 0, &oinfo->dqi_giblk,\n\t\t\t\t\t     &pcount, NULL);\n\tif (status < 0)\n\t\tgoto out_unlock;\n\n\tstatus = ocfs2_qinfo_lock(oinfo, 0);\n\tif (status < 0)\n\t\tgoto out_unlock;\n\tstatus = sb->s_op->quota_read(sb, type, (char *)&dinfo,\n\t\t\t\t      sizeof(struct ocfs2_global_disk_dqinfo),\n\t\t\t\t      OCFS2_GLOBAL_INFO_OFF);\n\tocfs2_qinfo_unlock(oinfo, 0);\n\tocfs2_unlock_global_qf(oinfo, 0);\n\tif (status != sizeof(struct ocfs2_global_disk_dqinfo)) {\n\t\tmlog(ML_ERROR, \"Cannot read global quota info (%d).\\n\",\n\t\t     status);\n\t\tif (status >= 0)\n\t\t\tstatus = -EIO;\n\t\tmlog_errno(status);\n\t\tgoto out_err;\n\t}\n\tinfo->dqi_bgrace = le32_to_cpu(dinfo.dqi_bgrace);\n\tinfo->dqi_igrace = le32_to_cpu(dinfo.dqi_igrace);\n\toinfo->dqi_syncms = le32_to_cpu(dinfo.dqi_syncms);\n\toinfo->dqi_gi.dqi_blocks = le32_to_cpu(dinfo.dqi_blocks);\n\toinfo->dqi_gi.dqi_free_blk = le32_to_cpu(dinfo.dqi_free_blk);\n\toinfo->dqi_gi.dqi_free_entry = le32_to_cpu(dinfo.dqi_free_entry);\n\toinfo->dqi_gi.dqi_blocksize_bits = sb->s_blocksize_bits;\n\toinfo->dqi_gi.dqi_usable_bs = sb->s_blocksize -\n\t\t\t\t\t\tOCFS2_QBLK_RESERVED_SPACE;\n\toinfo->dqi_gi.dqi_qtree_depth = qtree_depth(&oinfo->dqi_gi);\n\tINIT_DELAYED_WORK(&oinfo->dqi_sync_work, qsync_work_fn);\n\tschedule_delayed_work(&oinfo->dqi_sync_work,\n\t\t\t      msecs_to_jiffies(oinfo->dqi_syncms));\n\nout_err:\n\treturn status;\nout_unlock:\n\tocfs2_unlock_global_qf(oinfo, 0);\n\tmlog_errno(status);\n\tgoto out_err;\n}\n\n \nstatic int __ocfs2_global_write_info(struct super_block *sb, int type)\n{\n\tstruct mem_dqinfo *info = sb_dqinfo(sb, type);\n\tstruct ocfs2_mem_dqinfo *oinfo = info->dqi_priv;\n\tstruct ocfs2_global_disk_dqinfo dinfo;\n\tssize_t size;\n\n\tspin_lock(&dq_data_lock);\n\tinfo->dqi_flags &= ~DQF_INFO_DIRTY;\n\tdinfo.dqi_bgrace = cpu_to_le32(info->dqi_bgrace);\n\tdinfo.dqi_igrace = cpu_to_le32(info->dqi_igrace);\n\tspin_unlock(&dq_data_lock);\n\tdinfo.dqi_syncms = cpu_to_le32(oinfo->dqi_syncms);\n\tdinfo.dqi_blocks = cpu_to_le32(oinfo->dqi_gi.dqi_blocks);\n\tdinfo.dqi_free_blk = cpu_to_le32(oinfo->dqi_gi.dqi_free_blk);\n\tdinfo.dqi_free_entry = cpu_to_le32(oinfo->dqi_gi.dqi_free_entry);\n\tsize = sb->s_op->quota_write(sb, type, (char *)&dinfo,\n\t\t\t\t     sizeof(struct ocfs2_global_disk_dqinfo),\n\t\t\t\t     OCFS2_GLOBAL_INFO_OFF);\n\tif (size != sizeof(struct ocfs2_global_disk_dqinfo)) {\n\t\tmlog(ML_ERROR, \"Cannot write global quota info structure\\n\");\n\t\tif (size >= 0)\n\t\t\tsize = -EIO;\n\t\treturn size;\n\t}\n\treturn 0;\n}\n\nint ocfs2_global_write_info(struct super_block *sb, int type)\n{\n\tint err;\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\tstruct ocfs2_mem_dqinfo *info = dqopt->info[type].dqi_priv;\n\n\tdown_write(&dqopt->dqio_sem);\n\terr = ocfs2_qinfo_lock(info, 1);\n\tif (err < 0)\n\t\tgoto out_sem;\n\terr = __ocfs2_global_write_info(sb, type);\n\tocfs2_qinfo_unlock(info, 1);\nout_sem:\n\tup_write(&dqopt->dqio_sem);\n\treturn err;\n}\n\nstatic int ocfs2_global_qinit_alloc(struct super_block *sb, int type)\n{\n\tstruct ocfs2_mem_dqinfo *oinfo = sb_dqinfo(sb, type)->dqi_priv;\n\n\t \n\treturn oinfo->dqi_gi.dqi_qtree_depth;\n}\n\nstatic int ocfs2_calc_global_qinit_credits(struct super_block *sb, int type)\n{\n\t \n\treturn (ocfs2_global_qinit_alloc(sb, type) + 2) *\n\t\t\tOCFS2_QUOTA_BLOCK_UPDATE_CREDITS + 1;\n}\n\n \nint __ocfs2_sync_dquot(struct dquot *dquot, int freeing)\n{\n\tint err, err2;\n\tstruct super_block *sb = dquot->dq_sb;\n\tint type = dquot->dq_id.type;\n\tstruct ocfs2_mem_dqinfo *info = sb_dqinfo(sb, type)->dqi_priv;\n\tstruct ocfs2_global_disk_dqblk dqblk;\n\ts64 spacechange, inodechange;\n\ttime64_t olditime, oldbtime;\n\n\terr = sb->s_op->quota_read(sb, type, (char *)&dqblk,\n\t\t\t\t   sizeof(struct ocfs2_global_disk_dqblk),\n\t\t\t\t   dquot->dq_off);\n\tif (err != sizeof(struct ocfs2_global_disk_dqblk)) {\n\t\tif (err >= 0) {\n\t\t\tmlog(ML_ERROR, \"Short read from global quota file \"\n\t\t\t\t       \"(%u read)\\n\", err);\n\t\t\terr = -EIO;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t \n\tspin_lock(&dquot->dq_dqb_lock);\n\tspacechange = dquot->dq_dqb.dqb_curspace -\n\t\t\t\t\tOCFS2_DQUOT(dquot)->dq_origspace;\n\tinodechange = dquot->dq_dqb.dqb_curinodes -\n\t\t\t\t\tOCFS2_DQUOT(dquot)->dq_originodes;\n\tolditime = dquot->dq_dqb.dqb_itime;\n\toldbtime = dquot->dq_dqb.dqb_btime;\n\tocfs2_global_disk2memdqb(dquot, &dqblk);\n\ttrace_ocfs2_sync_dquot(from_kqid(&init_user_ns, dquot->dq_id),\n\t\t\t       dquot->dq_dqb.dqb_curspace,\n\t\t\t       (long long)spacechange,\n\t\t\t       dquot->dq_dqb.dqb_curinodes,\n\t\t\t       (long long)inodechange);\n\tif (!test_bit(DQ_LASTSET_B + QIF_SPACE_B, &dquot->dq_flags))\n\t\tdquot->dq_dqb.dqb_curspace += spacechange;\n\tif (!test_bit(DQ_LASTSET_B + QIF_INODES_B, &dquot->dq_flags))\n\t\tdquot->dq_dqb.dqb_curinodes += inodechange;\n\t \n\tif (dquot->dq_dqb.dqb_bsoftlimit &&\n\t    dquot->dq_dqb.dqb_curspace > dquot->dq_dqb.dqb_bsoftlimit) {\n\t\tif (!test_bit(DQ_LASTSET_B + QIF_BTIME_B, &dquot->dq_flags) &&\n\t\t    oldbtime > 0) {\n\t\t\tif (dquot->dq_dqb.dqb_btime > 0)\n\t\t\t\tdquot->dq_dqb.dqb_btime =\n\t\t\t\t\tmin(dquot->dq_dqb.dqb_btime, oldbtime);\n\t\t\telse\n\t\t\t\tdquot->dq_dqb.dqb_btime = oldbtime;\n\t\t}\n\t} else {\n\t\tdquot->dq_dqb.dqb_btime = 0;\n\t\tclear_bit(DQ_BLKS_B, &dquot->dq_flags);\n\t}\n\t \n\tif (dquot->dq_dqb.dqb_isoftlimit &&\n\t    dquot->dq_dqb.dqb_curinodes > dquot->dq_dqb.dqb_isoftlimit) {\n\t\tif (!test_bit(DQ_LASTSET_B + QIF_ITIME_B, &dquot->dq_flags) &&\n\t\t    olditime > 0) {\n\t\t\tif (dquot->dq_dqb.dqb_itime > 0)\n\t\t\t\tdquot->dq_dqb.dqb_itime =\n\t\t\t\t\tmin(dquot->dq_dqb.dqb_itime, olditime);\n\t\t\telse\n\t\t\t\tdquot->dq_dqb.dqb_itime = olditime;\n\t\t}\n\t} else {\n\t\tdquot->dq_dqb.dqb_itime = 0;\n\t\tclear_bit(DQ_INODES_B, &dquot->dq_flags);\n\t}\n\t \n\t__clear_bit(DQ_LASTSET_B + QIF_SPACE_B, &dquot->dq_flags);\n\t__clear_bit(DQ_LASTSET_B + QIF_INODES_B, &dquot->dq_flags);\n\t__clear_bit(DQ_LASTSET_B + QIF_BLIMITS_B, &dquot->dq_flags);\n\t__clear_bit(DQ_LASTSET_B + QIF_ILIMITS_B, &dquot->dq_flags);\n\t__clear_bit(DQ_LASTSET_B + QIF_BTIME_B, &dquot->dq_flags);\n\t__clear_bit(DQ_LASTSET_B + QIF_ITIME_B, &dquot->dq_flags);\n\tOCFS2_DQUOT(dquot)->dq_origspace = dquot->dq_dqb.dqb_curspace;\n\tOCFS2_DQUOT(dquot)->dq_originodes = dquot->dq_dqb.dqb_curinodes;\n\tspin_unlock(&dquot->dq_dqb_lock);\n\terr = ocfs2_qinfo_lock(info, freeing);\n\tif (err < 0) {\n\t\tmlog(ML_ERROR, \"Failed to lock quota info, losing quota write\"\n\t\t\t       \" (type=%d, id=%u)\\n\", dquot->dq_id.type,\n\t\t\t       (unsigned)from_kqid(&init_user_ns, dquot->dq_id));\n\t\tgoto out;\n\t}\n\tif (freeing)\n\t\tOCFS2_DQUOT(dquot)->dq_use_count--;\n\terr = qtree_write_dquot(&info->dqi_gi, dquot);\n\tif (err < 0)\n\t\tgoto out_qlock;\n\tif (freeing && !OCFS2_DQUOT(dquot)->dq_use_count) {\n\t\terr = qtree_release_dquot(&info->dqi_gi, dquot);\n\t\tif (info_dirty(sb_dqinfo(sb, type))) {\n\t\t\terr2 = __ocfs2_global_write_info(sb, type);\n\t\t\tif (!err)\n\t\t\t\terr = err2;\n\t\t}\n\t}\nout_qlock:\n\tocfs2_qinfo_unlock(info, freeing);\nout:\n\tif (err < 0)\n\t\tmlog_errno(err);\n\treturn err;\n}\n\n \nstatic int ocfs2_sync_dquot_helper(struct dquot *dquot, unsigned long type)\n{\n\thandle_t *handle;\n\tstruct super_block *sb = dquot->dq_sb;\n\tstruct ocfs2_mem_dqinfo *oinfo = sb_dqinfo(sb, type)->dqi_priv;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\tint status = 0;\n\n\ttrace_ocfs2_sync_dquot_helper(from_kqid(&init_user_ns, dquot->dq_id),\n\t\t\t\t      dquot->dq_id.type,\n\t\t\t\t      type, sb->s_id);\n\tif (type != dquot->dq_id.type)\n\t\tgoto out;\n\tstatus = ocfs2_lock_global_qf(oinfo, 1);\n\tif (status < 0)\n\t\tgoto out;\n\n\thandle = ocfs2_start_trans(osb, OCFS2_QSYNC_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\tgoto out_ilock;\n\t}\n\tdown_write(&sb_dqopt(sb)->dqio_sem);\n\tstatus = ocfs2_sync_dquot(dquot);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\t \n\tstatus = ocfs2_local_write_dquot(dquot);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\tup_write(&sb_dqopt(sb)->dqio_sem);\n\tocfs2_commit_trans(osb, handle);\nout_ilock:\n\tocfs2_unlock_global_qf(oinfo, 1);\nout:\n\treturn status;\n}\n\nstatic void qsync_work_fn(struct work_struct *work)\n{\n\tstruct ocfs2_mem_dqinfo *oinfo = container_of(work,\n\t\t\t\t\t\t      struct ocfs2_mem_dqinfo,\n\t\t\t\t\t\t      dqi_sync_work.work);\n\tstruct super_block *sb = oinfo->dqi_gqinode->i_sb;\n\n\t \n\tif (down_read_trylock(&sb->s_umount)) {\n\t\tdquot_scan_active(sb, ocfs2_sync_dquot_helper, oinfo->dqi_type);\n\t\tup_read(&sb->s_umount);\n\t}\n\tschedule_delayed_work(&oinfo->dqi_sync_work,\n\t\t\t      msecs_to_jiffies(oinfo->dqi_syncms));\n}\n\n \n\nstatic int ocfs2_write_dquot(struct dquot *dquot)\n{\n\thandle_t *handle;\n\tstruct ocfs2_super *osb = OCFS2_SB(dquot->dq_sb);\n\tint status = 0;\n\n\ttrace_ocfs2_write_dquot(from_kqid(&init_user_ns, dquot->dq_id),\n\t\t\t\tdquot->dq_id.type);\n\n\thandle = ocfs2_start_trans(osb, OCFS2_QWRITE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\tdown_write(&sb_dqopt(dquot->dq_sb)->dqio_sem);\n\tstatus = ocfs2_local_write_dquot(dquot);\n\tup_write(&sb_dqopt(dquot->dq_sb)->dqio_sem);\n\tocfs2_commit_trans(osb, handle);\nout:\n\treturn status;\n}\n\nstatic int ocfs2_calc_qdel_credits(struct super_block *sb, int type)\n{\n\tstruct ocfs2_mem_dqinfo *oinfo = sb_dqinfo(sb, type)->dqi_priv;\n\t \n\treturn (oinfo->dqi_gi.dqi_qtree_depth + 2) *\n\t       OCFS2_QUOTA_BLOCK_UPDATE_CREDITS +\n\t       OCFS2_QINFO_WRITE_CREDITS +\n\t       OCFS2_INODE_UPDATE_CREDITS;\n}\n\nvoid ocfs2_drop_dquot_refs(struct work_struct *work)\n{\n\tstruct ocfs2_super *osb = container_of(work, struct ocfs2_super,\n\t\t\t\t\t       dquot_drop_work);\n\tstruct llist_node *list;\n\tstruct ocfs2_dquot *odquot, *next_odquot;\n\n\tlist = llist_del_all(&osb->dquot_drop_list);\n\tllist_for_each_entry_safe(odquot, next_odquot, list, list) {\n\t\t \n\t\tdqput(&odquot->dq_dquot);\n\t}\n}\n\n \nstatic int ocfs2_release_dquot(struct dquot *dquot)\n{\n\thandle_t *handle;\n\tstruct ocfs2_mem_dqinfo *oinfo =\n\t\t\tsb_dqinfo(dquot->dq_sb, dquot->dq_id.type)->dqi_priv;\n\tstruct ocfs2_super *osb = OCFS2_SB(dquot->dq_sb);\n\tint status = 0;\n\n\ttrace_ocfs2_release_dquot(from_kqid(&init_user_ns, dquot->dq_id),\n\t\t\t\t  dquot->dq_id.type);\n\n\tmutex_lock(&dquot->dq_lock);\n\t \n\tif (dquot_is_busy(dquot))\n\t\tgoto out;\n\t \n\tif (current == osb->dc_task) {\n\t\t \n\t\tdqgrab(dquot);\n\t\t \n\t\tif (llist_add(&OCFS2_DQUOT(dquot)->list, &osb->dquot_drop_list))\n\t\t\tqueue_work(osb->ocfs2_wq, &osb->dquot_drop_work);\n\t\tgoto out;\n\t}\n\tstatus = ocfs2_lock_global_qf(oinfo, 1);\n\tif (status < 0)\n\t\tgoto out;\n\thandle = ocfs2_start_trans(osb,\n\t\tocfs2_calc_qdel_credits(dquot->dq_sb, dquot->dq_id.type));\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\tgoto out_ilock;\n\t}\n\n\tstatus = ocfs2_global_release_dquot(dquot);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_trans;\n\t}\n\tstatus = ocfs2_local_release_dquot(handle, dquot);\n\t \n\tif (status < 0)\n\t\tmlog_errno(status);\n\t \n\tdquot->dq_off = 0;\n\tclear_bit(DQ_ACTIVE_B, &dquot->dq_flags);\nout_trans:\n\tocfs2_commit_trans(osb, handle);\nout_ilock:\n\tocfs2_unlock_global_qf(oinfo, 1);\nout:\n\tmutex_unlock(&dquot->dq_lock);\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}\n\n \nstatic int ocfs2_acquire_dquot(struct dquot *dquot)\n{\n\tint status = 0, err;\n\tint ex = 0;\n\tstruct super_block *sb = dquot->dq_sb;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\tint type = dquot->dq_id.type;\n\tstruct ocfs2_mem_dqinfo *info = sb_dqinfo(sb, type)->dqi_priv;\n\tstruct inode *gqinode = info->dqi_gqinode;\n\tint need_alloc = ocfs2_global_qinit_alloc(sb, type);\n\thandle_t *handle;\n\n\ttrace_ocfs2_acquire_dquot(from_kqid(&init_user_ns, dquot->dq_id),\n\t\t\t\t  type);\n\tmutex_lock(&dquot->dq_lock);\n\t \n\tstatus = ocfs2_lock_global_qf(info, 1);\n\tif (status < 0)\n\t\tgoto out;\n\tstatus = ocfs2_qinfo_lock(info, 0);\n\tif (status < 0)\n\t\tgoto out_dq;\n\t \n\tstatus = qtree_read_dquot(&info->dqi_gi, dquot);\n\tocfs2_qinfo_unlock(info, 0);\n\tif (status < 0)\n\t\tgoto out_dq;\n\n\tOCFS2_DQUOT(dquot)->dq_use_count++;\n\tOCFS2_DQUOT(dquot)->dq_origspace = dquot->dq_dqb.dqb_curspace;\n\tOCFS2_DQUOT(dquot)->dq_originodes = dquot->dq_dqb.dqb_curinodes;\n\tif (!dquot->dq_off) {\t \n\t\tex = 1;\n\t\t \n\t\tWARN_ON(journal_current_handle());\n\t\tstatus = ocfs2_extend_no_holes(gqinode, NULL,\n\t\t\ti_size_read(gqinode) + (need_alloc << sb->s_blocksize_bits),\n\t\t\ti_size_read(gqinode));\n\t\tif (status < 0)\n\t\t\tgoto out_dq;\n\t}\n\n\thandle = ocfs2_start_trans(osb,\n\t\t\t\t   ocfs2_calc_global_qinit_credits(sb, type));\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tgoto out_dq;\n\t}\n\tstatus = ocfs2_qinfo_lock(info, ex);\n\tif (status < 0)\n\t\tgoto out_trans;\n\tstatus = qtree_write_dquot(&info->dqi_gi, dquot);\n\tif (ex && info_dirty(sb_dqinfo(sb, type))) {\n\t\terr = __ocfs2_global_write_info(sb, type);\n\t\tif (!status)\n\t\t\tstatus = err;\n\t}\n\tocfs2_qinfo_unlock(info, ex);\nout_trans:\n\tocfs2_commit_trans(osb, handle);\nout_dq:\n\tocfs2_unlock_global_qf(info, 1);\n\tif (status < 0)\n\t\tgoto out;\n\n\tstatus = ocfs2_create_local_dquot(dquot);\n\tif (status < 0)\n\t\tgoto out;\n\tset_bit(DQ_ACTIVE_B, &dquot->dq_flags);\nout:\n\tmutex_unlock(&dquot->dq_lock);\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}\n\nstatic int ocfs2_get_next_id(struct super_block *sb, struct kqid *qid)\n{\n\tint type = qid->type;\n\tstruct ocfs2_mem_dqinfo *info = sb_dqinfo(sb, type)->dqi_priv;\n\tint status = 0;\n\n\ttrace_ocfs2_get_next_id(from_kqid(&init_user_ns, *qid), type);\n\tif (!sb_has_quota_loaded(sb, type)) {\n\t\tstatus = -ESRCH;\n\t\tgoto out;\n\t}\n\tstatus = ocfs2_lock_global_qf(info, 0);\n\tif (status < 0)\n\t\tgoto out;\n\tstatus = ocfs2_qinfo_lock(info, 0);\n\tif (status < 0)\n\t\tgoto out_global;\n\tstatus = qtree_get_next_id(&info->dqi_gi, qid);\n\tocfs2_qinfo_unlock(info, 0);\nout_global:\n\tocfs2_unlock_global_qf(info, 0);\nout:\n\t \n\tif (status && status != -ENOENT && status != -ESRCH)\n\t\tmlog_errno(status);\n\treturn status;\n}\n\nstatic int ocfs2_mark_dquot_dirty(struct dquot *dquot)\n{\n\tunsigned long mask = (1 << (DQ_LASTSET_B + QIF_ILIMITS_B)) |\n\t\t\t     (1 << (DQ_LASTSET_B + QIF_BLIMITS_B)) |\n\t\t\t     (1 << (DQ_LASTSET_B + QIF_INODES_B)) |\n\t\t\t     (1 << (DQ_LASTSET_B + QIF_SPACE_B)) |\n\t\t\t     (1 << (DQ_LASTSET_B + QIF_BTIME_B)) |\n\t\t\t     (1 << (DQ_LASTSET_B + QIF_ITIME_B));\n\tint sync = 0;\n\tint status;\n\tstruct super_block *sb = dquot->dq_sb;\n\tint type = dquot->dq_id.type;\n\tstruct ocfs2_mem_dqinfo *oinfo = sb_dqinfo(sb, type)->dqi_priv;\n\thandle_t *handle;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\ttrace_ocfs2_mark_dquot_dirty(from_kqid(&init_user_ns, dquot->dq_id),\n\t\t\t\t     type);\n\n\t \n\tspin_lock(&dquot->dq_dqb_lock);\n\tif (dquot->dq_flags & mask)\n\t\tsync = 1;\n\tspin_unlock(&dquot->dq_dqb_lock);\n\t \n\tif (!sync || journal_current_handle()) {\n\t\tstatus = ocfs2_write_dquot(dquot);\n\t\tgoto out;\n\t}\n\tstatus = ocfs2_lock_global_qf(oinfo, 1);\n\tif (status < 0)\n\t\tgoto out;\n\thandle = ocfs2_start_trans(osb, OCFS2_QSYNC_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\tgoto out_ilock;\n\t}\n\tdown_write(&sb_dqopt(sb)->dqio_sem);\n\tstatus = ocfs2_sync_dquot(dquot);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_dlock;\n\t}\n\t \n\tstatus = ocfs2_local_write_dquot(dquot);\nout_dlock:\n\tup_write(&sb_dqopt(sb)->dqio_sem);\n\tocfs2_commit_trans(osb, handle);\nout_ilock:\n\tocfs2_unlock_global_qf(oinfo, 1);\nout:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}\n\n \nstatic int ocfs2_write_info(struct super_block *sb, int type)\n{\n\thandle_t *handle;\n\tint status = 0;\n\tstruct ocfs2_mem_dqinfo *oinfo = sb_dqinfo(sb, type)->dqi_priv;\n\n\tstatus = ocfs2_lock_global_qf(oinfo, 1);\n\tif (status < 0)\n\t\tgoto out;\n\thandle = ocfs2_start_trans(OCFS2_SB(sb), OCFS2_QINFO_WRITE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\tgoto out_ilock;\n\t}\n\tstatus = dquot_commit_info(sb, type);\n\tocfs2_commit_trans(OCFS2_SB(sb), handle);\nout_ilock:\n\tocfs2_unlock_global_qf(oinfo, 1);\nout:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}\n\nstatic struct dquot *ocfs2_alloc_dquot(struct super_block *sb, int type)\n{\n\tstruct ocfs2_dquot *dquot =\n\t\t\t\tkmem_cache_zalloc(ocfs2_dquot_cachep, GFP_NOFS);\n\n\tif (!dquot)\n\t\treturn NULL;\n\treturn &dquot->dq_dquot;\n}\n\nstatic void ocfs2_destroy_dquot(struct dquot *dquot)\n{\n\tkmem_cache_free(ocfs2_dquot_cachep, dquot);\n}\n\nconst struct dquot_operations ocfs2_quota_operations = {\n\t \n\t.acquire_dquot\t= ocfs2_acquire_dquot,\n\t.release_dquot\t= ocfs2_release_dquot,\n\t.mark_dirty\t= ocfs2_mark_dquot_dirty,\n\t.write_info\t= ocfs2_write_info,\n\t.alloc_dquot\t= ocfs2_alloc_dquot,\n\t.destroy_dquot\t= ocfs2_destroy_dquot,\n\t.get_next_id\t= ocfs2_get_next_id,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}