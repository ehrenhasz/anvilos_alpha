{
  "module_name": "alloc.c",
  "hash_id": "5978aa92cf836edbf79eca0e1c425311599bd7cd6c748be6997e9fe0157cae85",
  "original_prompt": "Ingested from linux-6.6.14/fs/ocfs2/alloc.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/blkdev.h>\n#include <linux/sched/signal.h>\n\n#include <cluster/masklog.h>\n\n#include \"ocfs2.h\"\n\n#include \"alloc.h\"\n#include \"aops.h\"\n#include \"blockcheck.h\"\n#include \"dlmglue.h\"\n#include \"extent_map.h\"\n#include \"inode.h\"\n#include \"journal.h\"\n#include \"localalloc.h\"\n#include \"suballoc.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"xattr.h\"\n#include \"refcounttree.h\"\n#include \"ocfs2_trace.h\"\n\n#include \"buffer_head_io.h\"\n\nenum ocfs2_contig_type {\n\tCONTIG_NONE = 0,\n\tCONTIG_LEFT,\n\tCONTIG_RIGHT,\n\tCONTIG_LEFTRIGHT,\n};\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\n \nstruct ocfs2_extent_tree_operations {\n\t \n\tvoid (*eo_set_last_eb_blk)(struct ocfs2_extent_tree *et,\n\t\t\t\t   u64 blkno);\n\tu64 (*eo_get_last_eb_blk)(struct ocfs2_extent_tree *et);\n\n\t \n\tvoid (*eo_update_clusters)(struct ocfs2_extent_tree *et,\n\t\t\t\t   u32 new_clusters);\n\n\t \n\tvoid (*eo_extent_map_insert)(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\n\n\t \n\tvoid (*eo_extent_map_truncate)(struct ocfs2_extent_tree *et,\n\t\t\t\t       u32 clusters);\n\n\t \n\tint (*eo_insert_check)(struct ocfs2_extent_tree *et,\n\t\t\t       struct ocfs2_extent_rec *rec);\n\tint (*eo_sanity_check)(struct ocfs2_extent_tree *et);\n\n\t \n\n\t \n\tvoid (*eo_fill_root_el)(struct ocfs2_extent_tree *et);\n\n\t \n\tvoid (*eo_fill_max_leaf_clusters)(struct ocfs2_extent_tree *et);\n\n\t \n\tenum ocfs2_contig_type\n\t\t(*eo_extent_contig)(struct ocfs2_extent_tree *et,\n\t\t\t\t    struct ocfs2_extent_rec *ext,\n\t\t\t\t    struct ocfs2_extent_rec *insert_rec);\n};\n\n\n \nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_reuse_blk_from_dealloc(handle_t *handle,\n\t\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\t\tstruct buffer_head **new_eb_bh,\n\t\t\t\t\tint blk_wanted, int *blk_given);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic const struct ocfs2_extent_tree_operations ocfs2_dinode_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_dinode_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_dinode_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_dinode_update_clusters,\n\t.eo_extent_map_insert\t= ocfs2_dinode_extent_map_insert,\n\t.eo_extent_map_truncate\t= ocfs2_dinode_extent_map_truncate,\n\t.eo_insert_check\t= ocfs2_dinode_insert_check,\n\t.eo_sanity_check\t= ocfs2_dinode_sanity_check,\n\t.eo_fill_root_el\t= ocfs2_dinode_fill_root_el,\n};\n\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno)\n{\n\tstruct ocfs2_dinode *di = et->et_object;\n\n\tBUG_ON(et->et_ops != &ocfs2_dinode_et_ops);\n\tdi->i_last_eb_blk = cpu_to_le64(blkno);\n}\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_dinode *di = et->et_object;\n\n\tBUG_ON(et->et_ops != &ocfs2_dinode_et_ops);\n\treturn le64_to_cpu(di->i_last_eb_blk);\n}\n\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters)\n{\n\tstruct ocfs2_inode_info *oi = cache_info_to_inode(et->et_ci);\n\tstruct ocfs2_dinode *di = et->et_object;\n\n\tle32_add_cpu(&di->i_clusters, clusters);\n\tspin_lock(&oi->ip_lock);\n\toi->ip_clusters = le32_to_cpu(di->i_clusters);\n\tspin_unlock(&oi->ip_lock);\n}\n\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec)\n{\n\tstruct inode *inode = &cache_info_to_inode(et->et_ci)->vfs_inode;\n\n\tocfs2_extent_map_insert_rec(inode, rec);\n}\n\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters)\n{\n\tstruct inode *inode = &cache_info_to_inode(et->et_ci)->vfs_inode;\n\n\tocfs2_extent_map_trunc(inode, clusters);\n}\n\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec)\n{\n\tstruct ocfs2_inode_info *oi = cache_info_to_inode(et->et_ci);\n\tstruct ocfs2_super *osb = OCFS2_SB(oi->vfs_inode.i_sb);\n\n\tBUG_ON(oi->ip_dyn_features & OCFS2_INLINE_DATA_FL);\n\tmlog_bug_on_msg(!ocfs2_sparse_alloc(osb) &&\n\t\t\t(oi->ip_clusters != le32_to_cpu(rec->e_cpos)),\n\t\t\t\"Device %s, asking for sparse allocation: inode %llu, \"\n\t\t\t\"cpos %u, clusters %u\\n\",\n\t\t\tosb->dev_str,\n\t\t\t(unsigned long long)oi->ip_blkno,\n\t\t\trec->e_cpos, oi->ip_clusters);\n\n\treturn 0;\n}\n\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_dinode *di = et->et_object;\n\n\tBUG_ON(et->et_ops != &ocfs2_dinode_et_ops);\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(di));\n\n\treturn 0;\n}\n\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_dinode *di = et->et_object;\n\n\tet->et_root_el = &di->id2.i_list;\n}\n\n\nstatic void ocfs2_xattr_value_fill_root_el(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_xattr_value_buf *vb = et->et_object;\n\n\tet->et_root_el = &vb->vb_xv->xr_list;\n}\n\nstatic void ocfs2_xattr_value_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t      u64 blkno)\n{\n\tstruct ocfs2_xattr_value_buf *vb = et->et_object;\n\n\tvb->vb_xv->xr_last_eb_blk = cpu_to_le64(blkno);\n}\n\nstatic u64 ocfs2_xattr_value_get_last_eb_blk(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_xattr_value_buf *vb = et->et_object;\n\n\treturn le64_to_cpu(vb->vb_xv->xr_last_eb_blk);\n}\n\nstatic void ocfs2_xattr_value_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t      u32 clusters)\n{\n\tstruct ocfs2_xattr_value_buf *vb = et->et_object;\n\n\tle32_add_cpu(&vb->vb_xv->xr_clusters, clusters);\n}\n\nstatic const struct ocfs2_extent_tree_operations ocfs2_xattr_value_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_xattr_value_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_xattr_value_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_xattr_value_update_clusters,\n\t.eo_fill_root_el\t= ocfs2_xattr_value_fill_root_el,\n};\n\nstatic void ocfs2_xattr_tree_fill_root_el(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_xattr_block *xb = et->et_object;\n\n\tet->et_root_el = &xb->xb_attrs.xb_root.xt_list;\n}\n\nstatic void ocfs2_xattr_tree_fill_max_leaf_clusters(struct ocfs2_extent_tree *et)\n{\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(et->et_ci);\n\tet->et_max_leaf_clusters =\n\t\tocfs2_clusters_for_bytes(sb, OCFS2_MAX_XATTR_TREE_LEAF_SIZE);\n}\n\nstatic void ocfs2_xattr_tree_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u64 blkno)\n{\n\tstruct ocfs2_xattr_block *xb = et->et_object;\n\tstruct ocfs2_xattr_tree_root *xt = &xb->xb_attrs.xb_root;\n\n\txt->xt_last_eb_blk = cpu_to_le64(blkno);\n}\n\nstatic u64 ocfs2_xattr_tree_get_last_eb_blk(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_xattr_block *xb = et->et_object;\n\tstruct ocfs2_xattr_tree_root *xt = &xb->xb_attrs.xb_root;\n\n\treturn le64_to_cpu(xt->xt_last_eb_blk);\n}\n\nstatic void ocfs2_xattr_tree_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters)\n{\n\tstruct ocfs2_xattr_block *xb = et->et_object;\n\n\tle32_add_cpu(&xb->xb_attrs.xb_root.xt_clusters, clusters);\n}\n\nstatic const struct ocfs2_extent_tree_operations ocfs2_xattr_tree_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_xattr_tree_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_xattr_tree_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_xattr_tree_update_clusters,\n\t.eo_fill_root_el\t= ocfs2_xattr_tree_fill_root_el,\n\t.eo_fill_max_leaf_clusters = ocfs2_xattr_tree_fill_max_leaf_clusters,\n};\n\nstatic void ocfs2_dx_root_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t  u64 blkno)\n{\n\tstruct ocfs2_dx_root_block *dx_root = et->et_object;\n\n\tdx_root->dr_last_eb_blk = cpu_to_le64(blkno);\n}\n\nstatic u64 ocfs2_dx_root_get_last_eb_blk(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_dx_root_block *dx_root = et->et_object;\n\n\treturn le64_to_cpu(dx_root->dr_last_eb_blk);\n}\n\nstatic void ocfs2_dx_root_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t  u32 clusters)\n{\n\tstruct ocfs2_dx_root_block *dx_root = et->et_object;\n\n\tle32_add_cpu(&dx_root->dr_clusters, clusters);\n}\n\nstatic int ocfs2_dx_root_sanity_check(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_dx_root_block *dx_root = et->et_object;\n\n\tBUG_ON(!OCFS2_IS_VALID_DX_ROOT(dx_root));\n\n\treturn 0;\n}\n\nstatic void ocfs2_dx_root_fill_root_el(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_dx_root_block *dx_root = et->et_object;\n\n\tet->et_root_el = &dx_root->dr_list;\n}\n\nstatic const struct ocfs2_extent_tree_operations ocfs2_dx_root_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_dx_root_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_dx_root_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_dx_root_update_clusters,\n\t.eo_sanity_check\t= ocfs2_dx_root_sanity_check,\n\t.eo_fill_root_el\t= ocfs2_dx_root_fill_root_el,\n};\n\nstatic void ocfs2_refcount_tree_fill_root_el(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_refcount_block *rb = et->et_object;\n\n\tet->et_root_el = &rb->rf_list;\n}\n\nstatic void ocfs2_refcount_tree_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t\tu64 blkno)\n{\n\tstruct ocfs2_refcount_block *rb = et->et_object;\n\n\trb->rf_last_eb_blk = cpu_to_le64(blkno);\n}\n\nstatic u64 ocfs2_refcount_tree_get_last_eb_blk(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_refcount_block *rb = et->et_object;\n\n\treturn le64_to_cpu(rb->rf_last_eb_blk);\n}\n\nstatic void ocfs2_refcount_tree_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t\tu32 clusters)\n{\n\tstruct ocfs2_refcount_block *rb = et->et_object;\n\n\tle32_add_cpu(&rb->rf_clusters, clusters);\n}\n\nstatic enum ocfs2_contig_type\nocfs2_refcount_tree_extent_contig(struct ocfs2_extent_tree *et,\n\t\t\t\t  struct ocfs2_extent_rec *ext,\n\t\t\t\t  struct ocfs2_extent_rec *insert_rec)\n{\n\treturn CONTIG_NONE;\n}\n\nstatic const struct ocfs2_extent_tree_operations ocfs2_refcount_tree_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_refcount_tree_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_refcount_tree_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_refcount_tree_update_clusters,\n\t.eo_fill_root_el\t= ocfs2_refcount_tree_fill_root_el,\n\t.eo_extent_contig\t= ocfs2_refcount_tree_extent_contig,\n};\n\nstatic void __ocfs2_init_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *bh,\n\t\t\t\t     ocfs2_journal_access_func access,\n\t\t\t\t     void *obj,\n\t\t\t\t     const struct ocfs2_extent_tree_operations *ops)\n{\n\tet->et_ops = ops;\n\tet->et_root_bh = bh;\n\tet->et_ci = ci;\n\tet->et_root_journal_access = access;\n\tif (!obj)\n\t\tobj = (void *)bh->b_data;\n\tet->et_object = obj;\n\tet->et_dealloc = NULL;\n\n\tet->et_ops->eo_fill_root_el(et);\n\tif (!et->et_ops->eo_fill_max_leaf_clusters)\n\t\tet->et_max_leaf_clusters = 0;\n\telse\n\t\tet->et_ops->eo_fill_max_leaf_clusters(et);\n}\n\nvoid ocfs2_init_dinode_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t   struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_di,\n\t\t\t\t NULL, &ocfs2_dinode_et_ops);\n}\n\nvoid ocfs2_init_xattr_tree_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t       struct ocfs2_caching_info *ci,\n\t\t\t\t       struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_xb,\n\t\t\t\t NULL, &ocfs2_xattr_tree_et_ops);\n}\n\nvoid ocfs2_init_xattr_value_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t\tstruct ocfs2_caching_info *ci,\n\t\t\t\t\tstruct ocfs2_xattr_value_buf *vb)\n{\n\t__ocfs2_init_extent_tree(et, ci, vb->vb_bh, vb->vb_access, vb,\n\t\t\t\t &ocfs2_xattr_value_et_ops);\n}\n\nvoid ocfs2_init_dx_root_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t    struct ocfs2_caching_info *ci,\n\t\t\t\t    struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_dr,\n\t\t\t\t NULL, &ocfs2_dx_root_et_ops);\n}\n\nvoid ocfs2_init_refcount_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_rb,\n\t\t\t\t NULL, &ocfs2_refcount_tree_et_ops);\n}\n\nstatic inline void ocfs2_et_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t    u64 new_last_eb_blk)\n{\n\tet->et_ops->eo_set_last_eb_blk(et, new_last_eb_blk);\n}\n\nstatic inline u64 ocfs2_et_get_last_eb_blk(struct ocfs2_extent_tree *et)\n{\n\treturn et->et_ops->eo_get_last_eb_blk(et);\n}\n\nstatic inline void ocfs2_et_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t    u32 clusters)\n{\n\tet->et_ops->eo_update_clusters(et, clusters);\n}\n\nstatic inline void ocfs2_et_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t      struct ocfs2_extent_rec *rec)\n{\n\tif (et->et_ops->eo_extent_map_insert)\n\t\tet->et_ops->eo_extent_map_insert(et, rec);\n}\n\nstatic inline void ocfs2_et_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t\tu32 clusters)\n{\n\tif (et->et_ops->eo_extent_map_truncate)\n\t\tet->et_ops->eo_extent_map_truncate(et, clusters);\n}\n\nstatic inline int ocfs2_et_root_journal_access(handle_t *handle,\n\t\t\t\t\t       struct ocfs2_extent_tree *et,\n\t\t\t\t\t       int type)\n{\n\treturn et->et_root_journal_access(handle, et->et_ci, et->et_root_bh,\n\t\t\t\t\t  type);\n}\n\nstatic inline enum ocfs2_contig_type\n\tocfs2_et_extent_contig(struct ocfs2_extent_tree *et,\n\t\t\t       struct ocfs2_extent_rec *rec,\n\t\t\t       struct ocfs2_extent_rec *insert_rec)\n{\n\tif (et->et_ops->eo_extent_contig)\n\t\treturn et->et_ops->eo_extent_contig(et, rec, insert_rec);\n\n\treturn ocfs2_extent_rec_contig(\n\t\t\t\tocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\trec, insert_rec);\n}\n\nstatic inline int ocfs2_et_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t\tstruct ocfs2_extent_rec *rec)\n{\n\tint ret = 0;\n\n\tif (et->et_ops->eo_insert_check)\n\t\tret = et->et_ops->eo_insert_check(et, rec);\n\treturn ret;\n}\n\nstatic inline int ocfs2_et_sanity_check(struct ocfs2_extent_tree *et)\n{\n\tint ret = 0;\n\n\tif (et->et_ops->eo_sanity_check)\n\t\tret = et->et_ops->eo_sanity_check(et);\n\treturn ret;\n}\n\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n \nvoid ocfs2_reinit_path(struct ocfs2_path *path, int keep_root)\n{\n\tint i, start = 0, depth = 0;\n\tstruct ocfs2_path_item *node;\n\n\tif (keep_root)\n\t\tstart = 1;\n\n\tfor(i = start; i < path_num_items(path); i++) {\n\t\tnode = &path->p_node[i];\n\n\t\tbrelse(node->bh);\n\t\tnode->bh = NULL;\n\t\tnode->el = NULL;\n\t}\n\n\t \n\tif (keep_root)\n\t\tdepth = le16_to_cpu(path_root_el(path)->l_tree_depth);\n\telse\n\t\tpath_root_access(path) = NULL;\n\n\tpath->p_tree_depth = depth;\n}\n\nvoid ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}\n\n \nstatic void ocfs2_cp_path(struct ocfs2_path *dest, struct ocfs2_path *src)\n{\n\tint i;\n\n\tBUG_ON(path_root_bh(dest) != path_root_bh(src));\n\tBUG_ON(path_root_el(dest) != path_root_el(src));\n\tBUG_ON(path_root_access(dest) != path_root_access(src));\n\n\tocfs2_reinit_path(dest, 1);\n\n\tfor(i = 1; i < OCFS2_MAX_PATH_DEPTH; i++) {\n\t\tdest->p_node[i].bh = src->p_node[i].bh;\n\t\tdest->p_node[i].el = src->p_node[i].el;\n\n\t\tif (dest->p_node[i].bh)\n\t\t\tget_bh(dest->p_node[i].bh);\n\t}\n}\n\n \nstatic void ocfs2_mv_path(struct ocfs2_path *dest, struct ocfs2_path *src)\n{\n\tint i;\n\n\tBUG_ON(path_root_bh(dest) != path_root_bh(src));\n\tBUG_ON(path_root_access(dest) != path_root_access(src));\n\n\tfor(i = 1; i < OCFS2_MAX_PATH_DEPTH; i++) {\n\t\tbrelse(dest->p_node[i].bh);\n\n\t\tdest->p_node[i].bh = src->p_node[i].bh;\n\t\tdest->p_node[i].el = src->p_node[i].el;\n\n\t\tsrc->p_node[i].bh = NULL;\n\t\tsrc->p_node[i].el = NULL;\n\t}\n}\n\n \nstatic inline void ocfs2_path_insert_eb(struct ocfs2_path *path, int index,\n\t\t\t\t\tstruct buffer_head *eb_bh)\n{\n\tstruct ocfs2_extent_block *eb = (struct ocfs2_extent_block *)eb_bh->b_data;\n\n\t \n\tBUG_ON(index == 0);\n\n\tpath->p_node[index].bh = eb_bh;\n\tpath->p_node[index].el = &eb->h_list;\n}\n\nstatic struct ocfs2_path *ocfs2_new_path(struct buffer_head *root_bh,\n\t\t\t\t\t struct ocfs2_extent_list *root_el,\n\t\t\t\t\t ocfs2_journal_access_func access)\n{\n\tstruct ocfs2_path *path;\n\n\tBUG_ON(le16_to_cpu(root_el->l_tree_depth) >= OCFS2_MAX_PATH_DEPTH);\n\n\tpath = kzalloc(sizeof(*path), GFP_NOFS);\n\tif (path) {\n\t\tpath->p_tree_depth = le16_to_cpu(root_el->l_tree_depth);\n\t\tget_bh(root_bh);\n\t\tpath_root_bh(path) = root_bh;\n\t\tpath_root_el(path) = root_el;\n\t\tpath_root_access(path) = access;\n\t}\n\n\treturn path;\n}\n\nstruct ocfs2_path *ocfs2_new_path_from_path(struct ocfs2_path *path)\n{\n\treturn ocfs2_new_path(path_root_bh(path), path_root_el(path),\n\t\t\t      path_root_access(path));\n}\n\nstruct ocfs2_path *ocfs2_new_path_from_et(struct ocfs2_extent_tree *et)\n{\n\treturn ocfs2_new_path(et->et_root_bh, et->et_root_el,\n\t\t\t      et->et_root_journal_access);\n}\n\n \nint ocfs2_path_bh_journal_access(handle_t *handle,\n\t\t\t\t struct ocfs2_caching_info *ci,\n\t\t\t\t struct ocfs2_path *path,\n\t\t\t\t int idx)\n{\n\tocfs2_journal_access_func access = path_root_access(path);\n\n\tif (!access)\n\t\taccess = ocfs2_journal_access;\n\n\tif (idx)\n\t\taccess = ocfs2_journal_access_eb;\n\n\treturn access(handle, ci, path->p_node[idx].bh,\n\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n}\n\n \nint ocfs2_journal_access_path(struct ocfs2_caching_info *ci,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_path *path)\n{\n\tint i, ret = 0;\n\n\tif (!path)\n\t\tgoto out;\n\n\tfor(i = 0; i < path_num_items(path); i++) {\n\t\tret = ocfs2_path_bh_journal_access(handle, ci, path, i);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}\n\n \nint ocfs2_search_extent_list(struct ocfs2_extent_list *el, u32 v_cluster)\n{\n\tint ret = -1;\n\tint i;\n\tstruct ocfs2_extent_rec *rec;\n\tu32 rec_end, rec_start, clusters;\n\n\tfor(i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {\n\t\trec = &el->l_recs[i];\n\n\t\trec_start = le32_to_cpu(rec->e_cpos);\n\t\tclusters = ocfs2_rec_clusters(el, rec);\n\n\t\trec_end = rec_start + clusters;\n\n\t\tif (v_cluster >= rec_start && v_cluster < rec_end) {\n\t\t\tret = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n \nstatic int ocfs2_block_extent_contig(struct super_block *sb,\n\t\t\t\t     struct ocfs2_extent_rec *ext,\n\t\t\t\t     u64 blkno)\n{\n\tu64 blk_end = le64_to_cpu(ext->e_blkno);\n\n\tblk_end += ocfs2_clusters_to_blocks(sb,\n\t\t\t\t    le16_to_cpu(ext->e_leaf_clusters));\n\n\treturn blkno == blk_end;\n}\n\nstatic int ocfs2_extents_adjacent(struct ocfs2_extent_rec *left,\n\t\t\t\t  struct ocfs2_extent_rec *right)\n{\n\tu32 left_range;\n\n\tleft_range = le32_to_cpu(left->e_cpos) +\n\t\tle16_to_cpu(left->e_leaf_clusters);\n\n\treturn (left_range == le32_to_cpu(right->e_cpos));\n}\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec)\n{\n\tu64 blkno = le64_to_cpu(insert_rec->e_blkno);\n\n\t \n\tif (ext->e_flags != insert_rec->e_flags)\n\t\treturn CONTIG_NONE;\n\n\tif (ocfs2_extents_adjacent(ext, insert_rec) &&\n\t    ocfs2_block_extent_contig(sb, ext, blkno))\n\t\t\treturn CONTIG_RIGHT;\n\n\tblkno = le64_to_cpu(ext->e_blkno);\n\tif (ocfs2_extents_adjacent(insert_rec, ext) &&\n\t    ocfs2_block_extent_contig(sb, insert_rec, blkno))\n\t\treturn CONTIG_LEFT;\n\n\treturn CONTIG_NONE;\n}\n\n \nenum ocfs2_append_type {\n\tAPPEND_NONE = 0,\n\tAPPEND_TAIL,\n};\n\nenum ocfs2_split_type {\n\tSPLIT_NONE = 0,\n\tSPLIT_LEFT,\n\tSPLIT_RIGHT,\n};\n\nstruct ocfs2_insert_type {\n\tenum ocfs2_split_type\tins_split;\n\tenum ocfs2_append_type\tins_appending;\n\tenum ocfs2_contig_type\tins_contig;\n\tint\t\t\tins_contig_index;\n\tint\t\t\tins_tree_depth;\n};\n\nstruct ocfs2_merge_ctxt {\n\tenum ocfs2_contig_type\tc_contig_type;\n\tint\t\t\tc_has_empty_extent;\n\tint\t\t\tc_split_covers_rec;\n};\n\nstatic int ocfs2_validate_extent_block(struct super_block *sb,\n\t\t\t\t       struct buffer_head *bh)\n{\n\tint rc;\n\tstruct ocfs2_extent_block *eb =\n\t\t(struct ocfs2_extent_block *)bh->b_data;\n\n\ttrace_ocfs2_validate_extent_block((unsigned long long)bh->b_blocknr);\n\n\tBUG_ON(!buffer_uptodate(bh));\n\n\t \n\trc = ocfs2_validate_meta_ecc(sb, bh->b_data, &eb->h_check);\n\tif (rc) {\n\t\tmlog(ML_ERROR, \"Checksum failed for extent block %llu\\n\",\n\t\t     (unsigned long long)bh->b_blocknr);\n\t\treturn rc;\n\t}\n\n\t \n\n\tif (!OCFS2_IS_VALID_EXTENT_BLOCK(eb)) {\n\t\trc = ocfs2_error(sb,\n\t\t\t\t \"Extent block #%llu has bad signature %.*s\\n\",\n\t\t\t\t (unsigned long long)bh->b_blocknr, 7,\n\t\t\t\t eb->h_signature);\n\t\tgoto bail;\n\t}\n\n\tif (le64_to_cpu(eb->h_blkno) != bh->b_blocknr) {\n\t\trc = ocfs2_error(sb,\n\t\t\t\t \"Extent block #%llu has an invalid h_blkno of %llu\\n\",\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t (unsigned long long)le64_to_cpu(eb->h_blkno));\n\t\tgoto bail;\n\t}\n\n\tif (le32_to_cpu(eb->h_fs_generation) != OCFS2_SB(sb)->fs_generation)\n\t\trc = ocfs2_error(sb,\n\t\t\t\t \"Extent block #%llu has an invalid h_fs_generation of #%u\\n\",\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t le32_to_cpu(eb->h_fs_generation));\nbail:\n\treturn rc;\n}\n\nint ocfs2_read_extent_block(struct ocfs2_caching_info *ci, u64 eb_blkno,\n\t\t\t    struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(ci, eb_blkno, &tmp,\n\t\t\t      ocfs2_validate_extent_block);\n\n\t \n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}\n\n\n \nint ocfs2_num_free_extents(struct ocfs2_extent_tree *et)\n{\n\tint retval;\n\tstruct ocfs2_extent_list *el = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct buffer_head *eb_bh = NULL;\n\tu64 last_eb_blk = 0;\n\n\tel = et->et_root_el;\n\tlast_eb_blk = ocfs2_et_get_last_eb_blk(et);\n\n\tif (last_eb_blk) {\n\t\tretval = ocfs2_read_extent_block(et->et_ci, last_eb_blk,\n\t\t\t\t\t\t &eb_bh);\n\t\tif (retval < 0) {\n\t\t\tmlog_errno(retval);\n\t\t\tgoto bail;\n\t\t}\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\t}\n\n\tBUG_ON(el->l_tree_depth != 0);\n\n\tretval = le16_to_cpu(el->l_count) - le16_to_cpu(el->l_next_free_rec);\nbail:\n\tbrelse(eb_bh);\n\n\ttrace_ocfs2_num_free_extents(retval);\n\treturn retval;\n}\n\n \nstatic int ocfs2_create_new_meta_bhs(handle_t *handle,\n\t\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t\t     int wanted,\n\t\t\t\t     struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t     struct buffer_head *bhs[])\n{\n\tint count, status, i;\n\tu16 suballoc_bit_start;\n\tu32 num_got;\n\tu64 suballoc_loc, first_blkno;\n\tstruct ocfs2_super *osb =\n\t\tOCFS2_SB(ocfs2_metadata_cache_get_super(et->et_ci));\n\tstruct ocfs2_extent_block *eb;\n\n\tcount = 0;\n\twhile (count < wanted) {\n\t\tstatus = ocfs2_claim_metadata(handle,\n\t\t\t\t\t      meta_ac,\n\t\t\t\t\t      wanted - count,\n\t\t\t\t\t      &suballoc_loc,\n\t\t\t\t\t      &suballoc_bit_start,\n\t\t\t\t\t      &num_got,\n\t\t\t\t\t      &first_blkno);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tfor(i = count;  i < (num_got + count); i++) {\n\t\t\tbhs[i] = sb_getblk(osb->sb, first_blkno);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tocfs2_set_new_buffer_uptodate(et->et_ci, bhs[i]);\n\n\t\t\tstatus = ocfs2_journal_access_eb(handle, et->et_ci,\n\t\t\t\t\t\t\t bhs[i],\n\t\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\n\t\t\tmemset(bhs[i]->b_data, 0, osb->sb->s_blocksize);\n\t\t\teb = (struct ocfs2_extent_block *) bhs[i]->b_data;\n\t\t\t \n\t\t\tstrcpy(eb->h_signature, OCFS2_EXTENT_BLOCK_SIGNATURE);\n\t\t\teb->h_blkno = cpu_to_le64(first_blkno);\n\t\t\teb->h_fs_generation = cpu_to_le32(osb->fs_generation);\n\t\t\teb->h_suballoc_slot =\n\t\t\t\tcpu_to_le16(meta_ac->ac_alloc_slot);\n\t\t\teb->h_suballoc_loc = cpu_to_le64(suballoc_loc);\n\t\t\teb->h_suballoc_bit = cpu_to_le16(suballoc_bit_start);\n\t\t\teb->h_list.l_count =\n\t\t\t\tcpu_to_le16(ocfs2_extent_recs_per_eb(osb->sb));\n\n\t\t\tsuballoc_bit_start++;\n\t\t\tfirst_blkno++;\n\n\t\t\t \n\t\t\tocfs2_journal_dirty(handle, bhs[i]);\n\t\t}\n\n\t\tcount += num_got;\n\t}\n\n\tstatus = 0;\nbail:\n\tif (status < 0) {\n\t\tfor(i = 0; i < wanted; i++) {\n\t\t\tbrelse(bhs[i]);\n\t\t\tbhs[i] = NULL;\n\t\t}\n\t}\n\treturn status;\n}\n\n \nstatic inline u32 ocfs2_sum_rightmost_rec(struct ocfs2_extent_list  *el)\n{\n\tint i;\n\n\ti = le16_to_cpu(el->l_next_free_rec) - 1;\n\n\treturn le32_to_cpu(el->l_recs[i].e_cpos) +\n\t\tocfs2_rec_clusters(el, &el->l_recs[i]);\n}\n\n \nstatic int ocfs2_adjust_rightmost_branch(handle_t *handle,\n\t\t\t\t\t struct ocfs2_extent_tree *et)\n{\n\tint status;\n\tstruct ocfs2_path *path = NULL;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\n\tpath = ocfs2_new_path_from_et(et);\n\tif (!path) {\n\t\tstatus = -ENOMEM;\n\t\treturn status;\n\t}\n\n\tstatus = ocfs2_find_path(et->et_ci, path, UINT_MAX);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tstatus = ocfs2_extend_trans(handle, path_num_items(path));\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tstatus = ocfs2_journal_access_path(et->et_ci, handle, path);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tel = path_leaf_el(path);\n\trec = &el->l_recs[le16_to_cpu(el->l_next_free_rec) - 1];\n\n\tocfs2_adjust_rightmost_records(handle, et, path, rec);\n\nout:\n\tocfs2_free_path(path);\n\treturn status;\n}\n\n \nstatic int ocfs2_add_branch(handle_t *handle,\n\t\t\t    struct ocfs2_extent_tree *et,\n\t\t\t    struct buffer_head *eb_bh,\n\t\t\t    struct buffer_head **last_eb_bh,\n\t\t\t    struct ocfs2_alloc_context *meta_ac)\n{\n\tint status, new_blocks, i, block_given = 0;\n\tu64 next_blkno, new_last_eb_blk;\n\tstruct buffer_head *bh;\n\tstruct buffer_head **new_eb_bhs = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list  *eb_el;\n\tstruct ocfs2_extent_list  *el;\n\tu32 new_cpos, root_end;\n\n\tBUG_ON(!last_eb_bh || !*last_eb_bh);\n\n\tif (eb_bh) {\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\t} else\n\t\tel = et->et_root_el;\n\n\t \n\tBUG_ON(!el->l_tree_depth);\n\n\tnew_blocks = le16_to_cpu(el->l_tree_depth);\n\n\teb = (struct ocfs2_extent_block *)(*last_eb_bh)->b_data;\n\tnew_cpos = ocfs2_sum_rightmost_rec(&eb->h_list);\n\troot_end = ocfs2_sum_rightmost_rec(et->et_root_el);\n\n\t \n\tif (root_end > new_cpos) {\n\t\ttrace_ocfs2_adjust_rightmost_branch(\n\t\t\t(unsigned long long)\n\t\t\tocfs2_metadata_cache_owner(et->et_ci),\n\t\t\troot_end, new_cpos);\n\n\t\tstatus = ocfs2_adjust_rightmost_branch(handle, et);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t \n\tnew_eb_bhs = kcalloc(new_blocks, sizeof(struct buffer_head *),\n\t\t\t     GFP_KERNEL);\n\tif (!new_eb_bhs) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t \n\tif (!ocfs2_is_dealloc_empty(et)) {\n\t\tstatus = ocfs2_reuse_blk_from_dealloc(handle, et,\n\t\t\t\t\t\t      new_eb_bhs, new_blocks,\n\t\t\t\t\t\t      &block_given);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tBUG_ON(block_given > new_blocks);\n\n\tif (block_given < new_blocks) {\n\t\tBUG_ON(!meta_ac);\n\t\tstatus = ocfs2_create_new_meta_bhs(handle, et,\n\t\t\t\t\t\t   new_blocks - block_given,\n\t\t\t\t\t\t   meta_ac,\n\t\t\t\t\t\t   &new_eb_bhs[block_given]);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t \n\tnext_blkno = new_last_eb_blk = 0;\n\tfor(i = 0; i < new_blocks; i++) {\n\t\tbh = new_eb_bhs[i];\n\t\teb = (struct ocfs2_extent_block *) bh->b_data;\n\t\t \n\t\tBUG_ON(!OCFS2_IS_VALID_EXTENT_BLOCK(eb));\n\t\teb_el = &eb->h_list;\n\n\t\tstatus = ocfs2_journal_access_eb(handle, et->et_ci, bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\teb->h_next_leaf_blk = 0;\n\t\teb_el->l_tree_depth = cpu_to_le16(i);\n\t\teb_el->l_next_free_rec = cpu_to_le16(1);\n\t\t \n\t\teb_el->l_recs[0].e_cpos = cpu_to_le32(new_cpos);\n\t\teb_el->l_recs[0].e_blkno = cpu_to_le64(next_blkno);\n\t\t \n\t\teb_el->l_recs[0].e_int_clusters = cpu_to_le32(0);\n\t\tif (!eb_el->l_tree_depth)\n\t\t\tnew_last_eb_blk = le64_to_cpu(eb->h_blkno);\n\n\t\tocfs2_journal_dirty(handle, bh);\n\t\tnext_blkno = le64_to_cpu(eb->h_blkno);\n\t}\n\n\t \n\tstatus = ocfs2_journal_access_eb(handle, et->et_ci, *last_eb_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tstatus = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tif (eb_bh) {\n\t\tstatus = ocfs2_journal_access_eb(handle, et->et_ci, eb_bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t \n\ti = le16_to_cpu(el->l_next_free_rec);\n\tel->l_recs[i].e_blkno = cpu_to_le64(next_blkno);\n\tel->l_recs[i].e_cpos = cpu_to_le32(new_cpos);\n\tel->l_recs[i].e_int_clusters = 0;\n\tle16_add_cpu(&el->l_next_free_rec, 1);\n\n\t \n\tocfs2_et_set_last_eb_blk(et, new_last_eb_blk);\n\n\teb = (struct ocfs2_extent_block *) (*last_eb_bh)->b_data;\n\teb->h_next_leaf_blk = cpu_to_le64(new_last_eb_blk);\n\n\tocfs2_journal_dirty(handle, *last_eb_bh);\n\tocfs2_journal_dirty(handle, et->et_root_bh);\n\tif (eb_bh)\n\t\tocfs2_journal_dirty(handle, eb_bh);\n\n\t \n\tbrelse(*last_eb_bh);\n\tget_bh(new_eb_bhs[0]);\n\t*last_eb_bh = new_eb_bhs[0];\n\n\tstatus = 0;\nbail:\n\tif (new_eb_bhs) {\n\t\tfor (i = 0; i < new_blocks; i++)\n\t\t\tbrelse(new_eb_bhs[i]);\n\t\tkfree(new_eb_bhs);\n\t}\n\n\treturn status;\n}\n\n \nstatic int ocfs2_shift_tree_depth(handle_t *handle,\n\t\t\t\t  struct ocfs2_extent_tree *et,\n\t\t\t\t  struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t  struct buffer_head **ret_new_eb_bh)\n{\n\tint status, i, block_given = 0;\n\tu32 new_clusters;\n\tstruct buffer_head *new_eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list  *root_el;\n\tstruct ocfs2_extent_list  *eb_el;\n\n\tif (!ocfs2_is_dealloc_empty(et)) {\n\t\tstatus = ocfs2_reuse_blk_from_dealloc(handle, et,\n\t\t\t\t\t\t      &new_eb_bh, 1,\n\t\t\t\t\t\t      &block_given);\n\t} else if (meta_ac) {\n\t\tstatus = ocfs2_create_new_meta_bhs(handle, et, 1, meta_ac,\n\t\t\t\t\t\t   &new_eb_bh);\n\n\t} else {\n\t\tBUG();\n\t}\n\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\teb = (struct ocfs2_extent_block *) new_eb_bh->b_data;\n\t \n\tBUG_ON(!OCFS2_IS_VALID_EXTENT_BLOCK(eb));\n\n\teb_el = &eb->h_list;\n\troot_el = et->et_root_el;\n\n\tstatus = ocfs2_journal_access_eb(handle, et->et_ci, new_eb_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t \n\teb_el->l_tree_depth = root_el->l_tree_depth;\n\teb_el->l_next_free_rec = root_el->l_next_free_rec;\n\tfor (i = 0; i < le16_to_cpu(root_el->l_next_free_rec); i++)\n\t\teb_el->l_recs[i] = root_el->l_recs[i];\n\n\tocfs2_journal_dirty(handle, new_eb_bh);\n\n\tstatus = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tnew_clusters = ocfs2_sum_rightmost_rec(eb_el);\n\n\t \n\tle16_add_cpu(&root_el->l_tree_depth, 1);\n\troot_el->l_recs[0].e_cpos = 0;\n\troot_el->l_recs[0].e_blkno = eb->h_blkno;\n\troot_el->l_recs[0].e_int_clusters = cpu_to_le32(new_clusters);\n\tfor (i = 1; i < le16_to_cpu(root_el->l_next_free_rec); i++)\n\t\tmemset(&root_el->l_recs[i], 0, sizeof(struct ocfs2_extent_rec));\n\troot_el->l_next_free_rec = cpu_to_le16(1);\n\n\t \n\tif (root_el->l_tree_depth == cpu_to_le16(1))\n\t\tocfs2_et_set_last_eb_blk(et, le64_to_cpu(eb->h_blkno));\n\n\tocfs2_journal_dirty(handle, et->et_root_bh);\n\n\t*ret_new_eb_bh = new_eb_bh;\n\tnew_eb_bh = NULL;\n\tstatus = 0;\nbail:\n\tbrelse(new_eb_bh);\n\n\treturn status;\n}\n\n \nstatic int ocfs2_find_branch_target(struct ocfs2_extent_tree *et,\n\t\t\t\t    struct buffer_head **target_bh)\n{\n\tint status = 0, i;\n\tu64 blkno;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list  *el;\n\tstruct buffer_head *bh = NULL;\n\tstruct buffer_head *lowest_bh = NULL;\n\n\t*target_bh = NULL;\n\n\tel = et->et_root_el;\n\n\twhile(le16_to_cpu(el->l_tree_depth) > 1) {\n\t\tif (le16_to_cpu(el->l_next_free_rec) == 0) {\n\t\t\tstatus = ocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t\"Owner %llu has empty extent list (next_free_rec == 0)\\n\",\n\t\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci));\n\t\t\tgoto bail;\n\t\t}\n\t\ti = le16_to_cpu(el->l_next_free_rec) - 1;\n\t\tblkno = le64_to_cpu(el->l_recs[i].e_blkno);\n\t\tif (!blkno) {\n\t\t\tstatus = ocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t\"Owner %llu has extent list where extent # %d has no physical block start\\n\",\n\t\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci), i);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\n\t\tstatus = ocfs2_read_extent_block(et->et_ci, blkno, &bh);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (le16_to_cpu(el->l_next_free_rec) <\n\t\t    le16_to_cpu(el->l_count)) {\n\t\t\tbrelse(lowest_bh);\n\t\t\tlowest_bh = bh;\n\t\t\tget_bh(lowest_bh);\n\t\t}\n\t}\n\n\t \n\tel = et->et_root_el;\n\tif (!lowest_bh && (el->l_next_free_rec == el->l_count))\n\t\tstatus = 1;\n\n\t*target_bh = lowest_bh;\nbail:\n\tbrelse(bh);\n\n\treturn status;\n}\n\n \nstatic int ocfs2_grow_tree(handle_t *handle, struct ocfs2_extent_tree *et,\n\t\t\t   int *final_depth, struct buffer_head **last_eb_bh,\n\t\t\t   struct ocfs2_alloc_context *meta_ac)\n{\n\tint ret, shift;\n\tstruct ocfs2_extent_list *el = et->et_root_el;\n\tint depth = le16_to_cpu(el->l_tree_depth);\n\tstruct buffer_head *bh = NULL;\n\n\tBUG_ON(meta_ac == NULL && ocfs2_is_dealloc_empty(et));\n\n\tshift = ocfs2_find_branch_target(et, &bh);\n\tif (shift < 0) {\n\t\tret = shift;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t \n\tif (shift) {\n\t\tBUG_ON(bh);\n\t\ttrace_ocfs2_grow_tree(\n\t\t\t(unsigned long long)\n\t\t\tocfs2_metadata_cache_owner(et->et_ci),\n\t\t\tdepth);\n\n\t\t \n\t\tret = ocfs2_shift_tree_depth(handle, et, meta_ac, &bh);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tdepth++;\n\t\tif (depth == 1) {\n\t\t\t \n\t\t\tBUG_ON(*last_eb_bh);\n\t\t\tget_bh(bh);\n\t\t\t*last_eb_bh = bh;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tret = ocfs2_add_branch(handle, et, bh, last_eb_bh,\n\t\t\t       meta_ac);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\nout:\n\tif (final_depth)\n\t\t*final_depth = depth;\n\tbrelse(bh);\n\treturn ret;\n}\n\n \nstatic void ocfs2_shift_records_right(struct ocfs2_extent_list *el)\n{\n\tint next_free = le16_to_cpu(el->l_next_free_rec);\n\tint count = le16_to_cpu(el->l_count);\n\tunsigned int num_bytes;\n\n\tBUG_ON(!next_free);\n\t \n\tBUG_ON(next_free >= count);\n\n\tnum_bytes = sizeof(struct ocfs2_extent_rec) * next_free;\n\n\tmemmove(&el->l_recs[1], &el->l_recs[0], num_bytes);\n}\n\nstatic void ocfs2_rotate_leaf(struct ocfs2_extent_list *el,\n\t\t\t      struct ocfs2_extent_rec *insert_rec)\n{\n\tint i, insert_index, next_free, has_empty, num_bytes;\n\tu32 insert_cpos = le32_to_cpu(insert_rec->e_cpos);\n\tstruct ocfs2_extent_rec *rec;\n\n\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\thas_empty = ocfs2_is_empty_extent(&el->l_recs[0]);\n\n\tBUG_ON(!next_free);\n\n\t \n\tBUG_ON(el->l_next_free_rec == el->l_count && !has_empty);\n\n\t \n\tif (has_empty) {\n\t\t \n\t\tfor(i = 0; i < (next_free - 1); i++)\n\t\t\tel->l_recs[i] = el->l_recs[i+1];\n\n\t\tnext_free--;\n\t}\n\n\t \n\tfor(i = 0; i < next_free; i++) {\n\t\trec = &el->l_recs[i];\n\n\t\tif (insert_cpos < le32_to_cpu(rec->e_cpos))\n\t\t\tbreak;\n\t}\n\tinsert_index = i;\n\n\ttrace_ocfs2_rotate_leaf(insert_cpos, insert_index,\n\t\t\t\thas_empty, next_free,\n\t\t\t\tle16_to_cpu(el->l_count));\n\n\tBUG_ON(insert_index < 0);\n\tBUG_ON(insert_index >= le16_to_cpu(el->l_count));\n\tBUG_ON(insert_index > next_free);\n\n\t \n\tif (insert_index != next_free) {\n\t\tBUG_ON(next_free >= le16_to_cpu(el->l_count));\n\n\t\tnum_bytes = next_free - insert_index;\n\t\tnum_bytes *= sizeof(struct ocfs2_extent_rec);\n\t\tmemmove(&el->l_recs[insert_index + 1],\n\t\t\t&el->l_recs[insert_index],\n\t\t\tnum_bytes);\n\t}\n\n\t \n\tnext_free++;\n\tel->l_next_free_rec = cpu_to_le16(next_free);\n\t \n\tBUG_ON(le16_to_cpu(el->l_next_free_rec) > le16_to_cpu(el->l_count));\n\n\tel->l_recs[insert_index] = *insert_rec;\n\n}\n\nstatic void ocfs2_remove_empty_extent(struct ocfs2_extent_list *el)\n{\n\tint size, num_recs = le16_to_cpu(el->l_next_free_rec);\n\n\tBUG_ON(num_recs == 0);\n\n\tif (ocfs2_is_empty_extent(&el->l_recs[0])) {\n\t\tnum_recs--;\n\t\tsize = num_recs * sizeof(struct ocfs2_extent_rec);\n\t\tmemmove(&el->l_recs[0], &el->l_recs[1], size);\n\t\tmemset(&el->l_recs[num_recs], 0,\n\t\t       sizeof(struct ocfs2_extent_rec));\n\t\tel->l_next_free_rec = cpu_to_le16(num_recs);\n\t}\n}\n\n \nstatic void ocfs2_create_empty_extent(struct ocfs2_extent_list *el)\n{\n\tint next_free = le16_to_cpu(el->l_next_free_rec);\n\n\tBUG_ON(le16_to_cpu(el->l_tree_depth) != 0);\n\n\tif (next_free == 0)\n\t\tgoto set_and_inc;\n\n\tif (ocfs2_is_empty_extent(&el->l_recs[0]))\n\t\treturn;\n\n\tmlog_bug_on_msg(el->l_count == el->l_next_free_rec,\n\t\t\t\"Asked to create an empty extent in a full list:\\n\"\n\t\t\t\"count = %u, tree depth = %u\",\n\t\t\tle16_to_cpu(el->l_count),\n\t\t\tle16_to_cpu(el->l_tree_depth));\n\n\tocfs2_shift_records_right(el);\n\nset_and_inc:\n\tle16_add_cpu(&el->l_next_free_rec, 1);\n\tmemset(&el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n}\n\n \nint ocfs2_find_subtree_root(struct ocfs2_extent_tree *et,\n\t\t\t    struct ocfs2_path *left,\n\t\t\t    struct ocfs2_path *right)\n{\n\tint i = 0;\n\n\t \n\tBUG_ON(path_root_bh(left) != path_root_bh(right));\n\n\tdo {\n\t\ti++;\n\n\t\t \n\t\tmlog_bug_on_msg(i > left->p_tree_depth,\n\t\t\t\t\"Owner %llu, left depth %u, right depth %u\\n\"\n\t\t\t\t\"left leaf blk %llu, right leaf blk %llu\\n\",\n\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\tleft->p_tree_depth, right->p_tree_depth,\n\t\t\t\t(unsigned long long)path_leaf_bh(left)->b_blocknr,\n\t\t\t\t(unsigned long long)path_leaf_bh(right)->b_blocknr);\n\t} while (left->p_node[i].bh->b_blocknr ==\n\t\t right->p_node[i].bh->b_blocknr);\n\n\treturn i - 1;\n}\n\ntypedef void (path_insert_t)(void *, struct buffer_head *);\n\n \nstatic int __ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t\t     struct ocfs2_extent_list *root_el, u32 cpos,\n\t\t\t     path_insert_t *func, void *data)\n{\n\tint i, ret = 0;\n\tu32 range;\n\tu64 blkno;\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\n\tel = root_el;\n\twhile (el->l_tree_depth) {\n\t\tif (le16_to_cpu(el->l_next_free_rec) == 0) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(ci),\n\t\t\t\t    \"Owner %llu has empty extent list at depth %u\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t\t\t    le16_to_cpu(el->l_tree_depth));\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\n\t\t}\n\n\t\tfor(i = 0; i < le16_to_cpu(el->l_next_free_rec) - 1; i++) {\n\t\t\trec = &el->l_recs[i];\n\n\t\t\t \n\t\t\trange = le32_to_cpu(rec->e_cpos) +\n\t\t\t\tocfs2_rec_clusters(el, rec);\n\t\t\tif (cpos >= le32_to_cpu(rec->e_cpos) && cpos < range)\n\t\t\t    break;\n\t\t}\n\n\t\tblkno = le64_to_cpu(el->l_recs[i].e_blkno);\n\t\tif (blkno == 0) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(ci),\n\t\t\t\t    \"Owner %llu has bad blkno in extent list at depth %u (index %d)\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t\t\t    le16_to_cpu(el->l_tree_depth), i);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\t\tret = ocfs2_read_extent_block(ci, blkno, &bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (le16_to_cpu(el->l_next_free_rec) >\n\t\t    le16_to_cpu(el->l_count)) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(ci),\n\t\t\t\t    \"Owner %llu has bad count in extent list at block %llu (next free=%u, count=%u)\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t\t\t    (unsigned long long)bh->b_blocknr,\n\t\t\t\t    le16_to_cpu(el->l_next_free_rec),\n\t\t\t\t    le16_to_cpu(el->l_count));\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (func)\n\t\t\tfunc(data, bh);\n\t}\n\nout:\n\t \n\tbrelse(bh);\n\n\treturn ret;\n}\n\n \nstruct find_path_data {\n\tint index;\n\tstruct ocfs2_path *path;\n};\nstatic void find_path_ins(void *data, struct buffer_head *bh)\n{\n\tstruct find_path_data *fp = data;\n\n\tget_bh(bh);\n\tocfs2_path_insert_eb(fp->path, fp->index, bh);\n\tfp->index++;\n}\nint ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}\n\nstatic void find_leaf_ins(void *data, struct buffer_head *bh)\n{\n\tstruct ocfs2_extent_block *eb =(struct ocfs2_extent_block *)bh->b_data;\n\tstruct ocfs2_extent_list *el = &eb->h_list;\n\tstruct buffer_head **ret = data;\n\n\t \n\tif (le16_to_cpu(el->l_tree_depth) == 0) {\n\t\tget_bh(bh);\n\t\t*ret = bh;\n\t}\n}\n \nint ocfs2_find_leaf(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_extent_list *root_el, u32 cpos,\n\t\t    struct buffer_head **leaf_bh)\n{\n\tint ret;\n\tstruct buffer_head *bh = NULL;\n\n\tret = __ocfs2_find_path(ci, root_el, cpos, find_leaf_ins, &bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t*leaf_bh = bh;\nout:\n\treturn ret;\n}\n\n \nstatic void ocfs2_adjust_adjacent_records(struct ocfs2_extent_rec *left_rec,\n\t\t\t\t  struct ocfs2_extent_rec *right_rec,\n\t\t\t\t  struct ocfs2_extent_list *right_child_el)\n{\n\tu32 left_clusters, right_end;\n\n\t \n\tleft_clusters = le32_to_cpu(right_child_el->l_recs[0].e_cpos);\n\tif (!ocfs2_rec_clusters(right_child_el, &right_child_el->l_recs[0])) {\n\t\tBUG_ON(right_child_el->l_tree_depth);\n\t\tBUG_ON(le16_to_cpu(right_child_el->l_next_free_rec) <= 1);\n\t\tleft_clusters = le32_to_cpu(right_child_el->l_recs[1].e_cpos);\n\t}\n\tleft_clusters -= le32_to_cpu(left_rec->e_cpos);\n\tleft_rec->e_int_clusters = cpu_to_le32(left_clusters);\n\n\t \n\tright_end = le32_to_cpu(right_rec->e_cpos);\n\tright_end += le32_to_cpu(right_rec->e_int_clusters);\n\n\tright_rec->e_cpos = left_rec->e_cpos;\n\tle32_add_cpu(&right_rec->e_cpos, left_clusters);\n\n\tright_end -= le32_to_cpu(right_rec->e_cpos);\n\tright_rec->e_int_clusters = cpu_to_le32(right_end);\n}\n\n \nstatic void ocfs2_adjust_root_records(struct ocfs2_extent_list *root_el,\n\t\t\t\t      struct ocfs2_extent_list *left_el,\n\t\t\t\t      struct ocfs2_extent_list *right_el,\n\t\t\t\t      u64 left_el_blkno)\n{\n\tint i;\n\n\tBUG_ON(le16_to_cpu(root_el->l_tree_depth) <=\n\t       le16_to_cpu(left_el->l_tree_depth));\n\n\tfor(i = 0; i < le16_to_cpu(root_el->l_next_free_rec) - 1; i++) {\n\t\tif (le64_to_cpu(root_el->l_recs[i].e_blkno) == left_el_blkno)\n\t\t\tbreak;\n\t}\n\n\t \n\tBUG_ON(i >= (le16_to_cpu(root_el->l_next_free_rec) - 1));\n\n\tocfs2_adjust_adjacent_records(&root_el->l_recs[i],\n\t\t\t\t      &root_el->l_recs[i + 1], right_el);\n}\n\n \nstatic void ocfs2_complete_edge_insert(handle_t *handle,\n\t\t\t\t       struct ocfs2_path *left_path,\n\t\t\t\t       struct ocfs2_path *right_path,\n\t\t\t\t       int subtree_index)\n{\n\tint i, idx;\n\tstruct ocfs2_extent_list *el, *left_el, *right_el;\n\tstruct ocfs2_extent_rec *left_rec, *right_rec;\n\tstruct buffer_head *root_bh;\n\n\t \n\tleft_el = path_leaf_el(left_path);\n\tright_el = path_leaf_el(right_path);\n\tfor(i = left_path->p_tree_depth - 1; i > subtree_index; i--) {\n\t\ttrace_ocfs2_complete_edge_insert(i);\n\n\t\t \n\t\tel = left_path->p_node[i].el;\n\t\tidx = le16_to_cpu(left_el->l_next_free_rec) - 1;\n\t\tleft_rec = &el->l_recs[idx];\n\n\t\tel = right_path->p_node[i].el;\n\t\tright_rec = &el->l_recs[0];\n\n\t\tocfs2_adjust_adjacent_records(left_rec, right_rec, right_el);\n\n\t\tocfs2_journal_dirty(handle, left_path->p_node[i].bh);\n\t\tocfs2_journal_dirty(handle, right_path->p_node[i].bh);\n\n\t\t \n\t\tleft_el = left_path->p_node[i].el;\n\t\tright_el = right_path->p_node[i].el;\n\t}\n\n\t \n\n\tel = left_path->p_node[subtree_index].el;\n\tleft_el = left_path->p_node[subtree_index + 1].el;\n\tright_el = right_path->p_node[subtree_index + 1].el;\n\n\tocfs2_adjust_root_records(el, left_el, right_el,\n\t\t\t\t  left_path->p_node[subtree_index + 1].bh->b_blocknr);\n\n\troot_bh = left_path->p_node[subtree_index].bh;\n\n\tocfs2_journal_dirty(handle, root_bh);\n}\n\nstatic int ocfs2_rotate_subtree_right(handle_t *handle,\n\t\t\t\t      struct ocfs2_extent_tree *et,\n\t\t\t\t      struct ocfs2_path *left_path,\n\t\t\t\t      struct ocfs2_path *right_path,\n\t\t\t\t      int subtree_index)\n{\n\tint ret, i;\n\tstruct buffer_head *right_leaf_bh;\n\tstruct buffer_head *left_leaf_bh = NULL;\n\tstruct buffer_head *root_bh;\n\tstruct ocfs2_extent_list *right_el, *left_el;\n\tstruct ocfs2_extent_rec move_rec;\n\n\tleft_leaf_bh = path_leaf_bh(left_path);\n\tleft_el = path_leaf_el(left_path);\n\n\tif (left_el->l_next_free_rec != left_el->l_count) {\n\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t    \"Inode %llu has non-full interior leaf node %llu (next free = %u)\\n\",\n\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t    (unsigned long long)left_leaf_bh->b_blocknr,\n\t\t\t    le16_to_cpu(left_el->l_next_free_rec));\n\t\treturn -EROFS;\n\t}\n\n\t \n\tif (ocfs2_is_empty_extent(&left_el->l_recs[0]))\n\t\treturn 0;\n\n\troot_bh = left_path->p_node[subtree_index].bh;\n\tBUG_ON(root_bh != right_path->p_node[subtree_index].bh);\n\n\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, right_path,\n\t\t\t\t\t   subtree_index);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tfor(i = subtree_index + 1; i < path_num_items(right_path); i++) {\n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t   right_path, i);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t   left_path, i);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tright_leaf_bh = path_leaf_bh(right_path);\n\tright_el = path_leaf_el(right_path);\n\n\t \n\tmlog_bug_on_msg(!right_el->l_next_free_rec, \"Inode %llu: Rotate fails \"\n\t\t\t\"because rightmost leaf block %llu is empty\\n\",\n\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t(unsigned long long)right_leaf_bh->b_blocknr);\n\n\tocfs2_create_empty_extent(right_el);\n\n\tocfs2_journal_dirty(handle, right_leaf_bh);\n\n\t \n\ti = le16_to_cpu(left_el->l_next_free_rec) - 1;\n\tmove_rec = left_el->l_recs[i];\n\tright_el->l_recs[0] = move_rec;\n\n\t \n\tle16_add_cpu(&left_el->l_next_free_rec, -1);\n\tocfs2_shift_records_right(left_el);\n\tmemset(&left_el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n\tle16_add_cpu(&left_el->l_next_free_rec, 1);\n\n\tocfs2_journal_dirty(handle, left_leaf_bh);\n\n\tocfs2_complete_edge_insert(handle, left_path, right_path,\n\t\t\t\t   subtree_index);\n\nout:\n\treturn ret;\n}\n\n \nint ocfs2_find_cpos_for_left_leaf(struct super_block *sb,\n\t\t\t\t  struct ocfs2_path *path, u32 *cpos)\n{\n\tint i, j, ret = 0;\n\tu64 blkno;\n\tstruct ocfs2_extent_list *el;\n\n\tBUG_ON(path->p_tree_depth == 0);\n\n\t*cpos = 0;\n\n\tblkno = path_leaf_bh(path)->b_blocknr;\n\n\t \n\ti = path->p_tree_depth - 1;\n\twhile (i >= 0) {\n\t\tel = path->p_node[i].el;\n\n\t\t \n\t\tfor(j = 0; j < le16_to_cpu(el->l_next_free_rec); j++) {\n\t\t\tif (le64_to_cpu(el->l_recs[j].e_blkno) == blkno) {\n\t\t\t\tif (j == 0) {\n\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t \n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\t \n\t\t\t\t\tgoto next_node;\n\t\t\t\t}\n\n\t\t\t\t*cpos = le32_to_cpu(el->l_recs[j - 1].e_cpos);\n\t\t\t\t*cpos = *cpos + ocfs2_rec_clusters(el,\n\t\t\t\t\t\t\t   &el->l_recs[j - 1]);\n\t\t\t\t*cpos = *cpos - 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tocfs2_error(sb, \"Invalid extent tree at extent block %llu\\n\",\n\t\t\t    (unsigned long long)blkno);\n\t\tret = -EROFS;\n\t\tgoto out;\n\nnext_node:\n\t\tblkno = path->p_node[i].bh->b_blocknr;\n\t\ti--;\n\t}\n\nout:\n\treturn ret;\n}\n\n \nstatic int ocfs2_extend_rotate_transaction(handle_t *handle, int subtree_depth,\n\t\t\t\t\t   int op_credits,\n\t\t\t\t\t   struct ocfs2_path *path)\n{\n\tint ret = 0;\n\tint credits = (path->p_tree_depth - subtree_depth) * 2 + 1 + op_credits;\n\n\tif (jbd2_handle_buffer_credits(handle) < credits)\n\t\tret = ocfs2_extend_trans(handle,\n\t\t\t\tcredits - jbd2_handle_buffer_credits(handle));\n\n\treturn ret;\n}\n\n \nstatic int ocfs2_rotate_requires_path_adjustment(struct ocfs2_path *left_path,\n\t\t\t\t\t\t u32 insert_cpos)\n{\n\tstruct ocfs2_extent_list *left_el;\n\tstruct ocfs2_extent_rec *rec;\n\tint next_free;\n\n\tleft_el = path_leaf_el(left_path);\n\tnext_free = le16_to_cpu(left_el->l_next_free_rec);\n\trec = &left_el->l_recs[next_free - 1];\n\n\tif (insert_cpos > le32_to_cpu(rec->e_cpos))\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int ocfs2_leftmost_rec_contains(struct ocfs2_extent_list *el, u32 cpos)\n{\n\tint next_free = le16_to_cpu(el->l_next_free_rec);\n\tunsigned int range;\n\tstruct ocfs2_extent_rec *rec;\n\n\tif (next_free == 0)\n\t\treturn 0;\n\n\trec = &el->l_recs[0];\n\tif (ocfs2_is_empty_extent(rec)) {\n\t\t \n\t\tif (next_free == 1)\n\t\t\treturn 0;\n\t\trec = &el->l_recs[1];\n\t}\n\n\trange = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);\n\tif (cpos >= le32_to_cpu(rec->e_cpos) && cpos < range)\n\t\treturn 1;\n\treturn 0;\n}\n\n \nstatic int ocfs2_rotate_tree_right(handle_t *handle,\n\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t   enum ocfs2_split_type split,\n\t\t\t\t   u32 insert_cpos,\n\t\t\t\t   struct ocfs2_path *right_path,\n\t\t\t\t   struct ocfs2_path **ret_left_path)\n{\n\tint ret, start, orig_credits = jbd2_handle_buffer_credits(handle);\n\tu32 cpos;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(et->et_ci);\n\n\t*ret_left_path = NULL;\n\n\tleft_path = ocfs2_new_path_from_path(right_path);\n\tif (!left_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_cpos_for_left_leaf(sb, right_path, &cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_rotate_tree_right(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\tinsert_cpos, cpos);\n\n\t \n\twhile (cpos && insert_cpos <= cpos) {\n\t\ttrace_ocfs2_rotate_tree_right(\n\t\t\t(unsigned long long)\n\t\t\tocfs2_metadata_cache_owner(et->et_ci),\n\t\t\tinsert_cpos, cpos);\n\n\t\tret = ocfs2_find_path(et->et_ci, left_path, cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tmlog_bug_on_msg(path_leaf_bh(left_path) ==\n\t\t\t\tpath_leaf_bh(right_path),\n\t\t\t\t\"Owner %llu: error during insert of %u \"\n\t\t\t\t\"(left path cpos %u) results in two identical \"\n\t\t\t\t\"paths ending at %llu\\n\",\n\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\tinsert_cpos, cpos,\n\t\t\t\t(unsigned long long)\n\t\t\t\tpath_leaf_bh(left_path)->b_blocknr);\n\n\t\tif (split == SPLIT_NONE &&\n\t\t    ocfs2_rotate_requires_path_adjustment(left_path,\n\t\t\t\t\t\t\t  insert_cpos)) {\n\n\t\t\t \n\t\t\t*ret_left_path = left_path;\n\t\t\tgoto out_ret_path;\n\t\t}\n\n\t\tstart = ocfs2_find_subtree_root(et, left_path, right_path);\n\n\t\ttrace_ocfs2_rotate_subtree(start,\n\t\t\t(unsigned long long)\n\t\t\tright_path->p_node[start].bh->b_blocknr,\n\t\t\tright_path->p_tree_depth);\n\n\t\tret = ocfs2_extend_rotate_transaction(handle, start,\n\t\t\t\t\t\t      orig_credits, right_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_rotate_subtree_right(handle, et, left_path,\n\t\t\t\t\t\t right_path, start);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (split != SPLIT_NONE &&\n\t\t    ocfs2_leftmost_rec_contains(path_leaf_el(right_path),\n\t\t\t\t\t\tinsert_cpos)) {\n\t\t\t \n\t\t\t*ret_left_path = left_path;\n\t\t\tgoto out_ret_path;\n\t\t}\n\n\t\t \n\t\tocfs2_mv_path(right_path, left_path);\n\n\t\tret = ocfs2_find_cpos_for_left_leaf(sb, right_path, &cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tocfs2_free_path(left_path);\n\nout_ret_path:\n\treturn ret;\n}\n\nstatic int ocfs2_update_edge_lengths(handle_t *handle,\n\t\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_path *path)\n{\n\tint i, idx, ret;\n\tstruct ocfs2_extent_rec *rec;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_block *eb;\n\tu32 range;\n\n\tret = ocfs2_journal_access_path(et->et_ci, handle, path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t \n\teb = (struct ocfs2_extent_block *)path_leaf_bh(path)->b_data;\n\tBUG_ON(eb->h_next_leaf_blk != 0ULL);\n\n\tel = &eb->h_list;\n\tBUG_ON(le16_to_cpu(el->l_next_free_rec) == 0);\n\tidx = le16_to_cpu(el->l_next_free_rec) - 1;\n\trec = &el->l_recs[idx];\n\trange = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);\n\n\tfor (i = 0; i < path->p_tree_depth; i++) {\n\t\tel = path->p_node[i].el;\n\t\tidx = le16_to_cpu(el->l_next_free_rec) - 1;\n\t\trec = &el->l_recs[idx];\n\n\t\trec->e_int_clusters = cpu_to_le32(range);\n\t\tle32_add_cpu(&rec->e_int_clusters, -le32_to_cpu(rec->e_cpos));\n\n\t\tocfs2_journal_dirty(handle, path->p_node[i].bh);\n\t}\nout:\n\treturn ret;\n}\n\nstatic void ocfs2_unlink_path(handle_t *handle,\n\t\t\t      struct ocfs2_extent_tree *et,\n\t\t\t      struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t      struct ocfs2_path *path, int unlink_start)\n{\n\tint ret, i;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\tstruct buffer_head *bh;\n\n\tfor(i = unlink_start; i < path_num_items(path); i++) {\n\t\tbh = path->p_node[i].bh;\n\n\t\teb = (struct ocfs2_extent_block *)bh->b_data;\n\t\t \n\t\tel = &eb->h_list;\n\t\tif (le16_to_cpu(el->l_next_free_rec) > 1) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"Inode %llu, attempted to remove extent block \"\n\t\t\t     \"%llu with %u records\\n\",\n\t\t\t     (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t     (unsigned long long)le64_to_cpu(eb->h_blkno),\n\t\t\t     le16_to_cpu(el->l_next_free_rec));\n\n\t\t\tocfs2_journal_dirty(handle, bh);\n\t\t\tocfs2_remove_from_cache(et->et_ci, bh);\n\t\t\tcontinue;\n\t\t}\n\n\t\tel->l_next_free_rec = 0;\n\t\tmemset(&el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n\n\t\tocfs2_journal_dirty(handle, bh);\n\n\t\tret = ocfs2_cache_extent_block_free(dealloc, eb);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\n\t\tocfs2_remove_from_cache(et->et_ci, bh);\n\t}\n}\n\nstatic void ocfs2_unlink_subtree(handle_t *handle,\n\t\t\t\t struct ocfs2_extent_tree *et,\n\t\t\t\t struct ocfs2_path *left_path,\n\t\t\t\t struct ocfs2_path *right_path,\n\t\t\t\t int subtree_index,\n\t\t\t\t struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint i;\n\tstruct buffer_head *root_bh = left_path->p_node[subtree_index].bh;\n\tstruct ocfs2_extent_list *root_el = left_path->p_node[subtree_index].el;\n\tstruct ocfs2_extent_block *eb;\n\n\teb = (struct ocfs2_extent_block *)right_path->p_node[subtree_index + 1].bh->b_data;\n\n\tfor(i = 1; i < le16_to_cpu(root_el->l_next_free_rec); i++)\n\t\tif (root_el->l_recs[i].e_blkno == eb->h_blkno)\n\t\t\tbreak;\n\n\tBUG_ON(i >= le16_to_cpu(root_el->l_next_free_rec));\n\n\tmemset(&root_el->l_recs[i], 0, sizeof(struct ocfs2_extent_rec));\n\tle16_add_cpu(&root_el->l_next_free_rec, -1);\n\n\teb = (struct ocfs2_extent_block *)path_leaf_bh(left_path)->b_data;\n\teb->h_next_leaf_blk = 0;\n\n\tocfs2_journal_dirty(handle, root_bh);\n\tocfs2_journal_dirty(handle, path_leaf_bh(left_path));\n\n\tocfs2_unlink_path(handle, et, dealloc, right_path,\n\t\t\t  subtree_index + 1);\n}\n\nstatic int ocfs2_rotate_subtree_left(handle_t *handle,\n\t\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_path *left_path,\n\t\t\t\t     struct ocfs2_path *right_path,\n\t\t\t\t     int subtree_index,\n\t\t\t\t     struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t\t     int *deleted)\n{\n\tint ret, i, del_right_subtree = 0, right_has_empty = 0;\n\tstruct buffer_head *root_bh, *et_root_bh = path_root_bh(right_path);\n\tstruct ocfs2_extent_list *right_leaf_el, *left_leaf_el;\n\tstruct ocfs2_extent_block *eb;\n\n\t*deleted = 0;\n\n\tright_leaf_el = path_leaf_el(right_path);\n\tleft_leaf_el = path_leaf_el(left_path);\n\troot_bh = left_path->p_node[subtree_index].bh;\n\tBUG_ON(root_bh != right_path->p_node[subtree_index].bh);\n\n\tif (!ocfs2_is_empty_extent(&left_leaf_el->l_recs[0]))\n\t\treturn 0;\n\n\teb = (struct ocfs2_extent_block *)path_leaf_bh(right_path)->b_data;\n\tif (ocfs2_is_empty_extent(&right_leaf_el->l_recs[0])) {\n\t\t \n\n\t\tif (eb->h_next_leaf_blk != 0ULL)\n\t\t\treturn -EAGAIN;\n\n\t\tif (le16_to_cpu(right_leaf_el->l_next_free_rec) > 1) {\n\t\t\tret = ocfs2_journal_access_eb(handle, et->et_ci,\n\t\t\t\t\t\t      path_leaf_bh(right_path),\n\t\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tocfs2_remove_empty_extent(right_leaf_el);\n\t\t} else\n\t\t\tright_has_empty = 1;\n\t}\n\n\tif (eb->h_next_leaf_blk == 0ULL &&\n\t    le16_to_cpu(right_leaf_el->l_next_free_rec) == 1) {\n\t\t \n\t\tret = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tdel_right_subtree = 1;\n\t}\n\n\t \n\tBUG_ON(right_has_empty && !del_right_subtree);\n\n\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, right_path,\n\t\t\t\t\t   subtree_index);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tfor(i = subtree_index + 1; i < path_num_items(right_path); i++) {\n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t   right_path, i);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t   left_path, i);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!right_has_empty) {\n\t\t \n\t\tocfs2_rotate_leaf(left_leaf_el, &right_leaf_el->l_recs[0]);\n\t\tmemset(&right_leaf_el->l_recs[0], 0,\n\t\t       sizeof(struct ocfs2_extent_rec));\n\t}\n\tif (eb->h_next_leaf_blk == 0ULL) {\n\t\t \n\t\tocfs2_remove_empty_extent(right_leaf_el);\n\t}\n\n\tocfs2_journal_dirty(handle, path_leaf_bh(left_path));\n\tocfs2_journal_dirty(handle, path_leaf_bh(right_path));\n\n\tif (del_right_subtree) {\n\t\tocfs2_unlink_subtree(handle, et, left_path, right_path,\n\t\t\t\t     subtree_index, dealloc);\n\t\tret = ocfs2_update_edge_lengths(handle, et, left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *)path_leaf_bh(left_path)->b_data;\n\t\tocfs2_et_set_last_eb_blk(et, le64_to_cpu(eb->h_blkno));\n\n\t\t \n\t\tif (right_has_empty)\n\t\t\tocfs2_remove_empty_extent(left_leaf_el);\n\n\t\tocfs2_journal_dirty(handle, et_root_bh);\n\n\t\t*deleted = 1;\n\t} else\n\t\tocfs2_complete_edge_insert(handle, left_path, right_path,\n\t\t\t\t\t   subtree_index);\n\nout:\n\treturn ret;\n}\n\n \nint ocfs2_find_cpos_for_right_leaf(struct super_block *sb,\n\t\t\t\t   struct ocfs2_path *path, u32 *cpos)\n{\n\tint i, j, ret = 0;\n\tu64 blkno;\n\tstruct ocfs2_extent_list *el;\n\n\t*cpos = 0;\n\n\tif (path->p_tree_depth == 0)\n\t\treturn 0;\n\n\tblkno = path_leaf_bh(path)->b_blocknr;\n\n\t \n\ti = path->p_tree_depth - 1;\n\twhile (i >= 0) {\n\t\tint next_free;\n\n\t\tel = path->p_node[i].el;\n\n\t\t \n\t\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\t\tfor(j = 0; j < le16_to_cpu(el->l_next_free_rec); j++) {\n\t\t\tif (le64_to_cpu(el->l_recs[j].e_blkno) == blkno) {\n\t\t\t\tif (j == (next_free - 1)) {\n\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t \n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\t \n\t\t\t\t\tgoto next_node;\n\t\t\t\t}\n\n\t\t\t\t*cpos = le32_to_cpu(el->l_recs[j + 1].e_cpos);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tocfs2_error(sb, \"Invalid extent tree at extent block %llu\\n\",\n\t\t\t    (unsigned long long)blkno);\n\t\tret = -EROFS;\n\t\tgoto out;\n\nnext_node:\n\t\tblkno = path->p_node[i].bh->b_blocknr;\n\t\ti--;\n\t}\n\nout:\n\treturn ret;\n}\n\nstatic int ocfs2_rotate_rightmost_leaf_left(handle_t *handle,\n\t\t\t\t\t    struct ocfs2_extent_tree *et,\n\t\t\t\t\t    struct ocfs2_path *path)\n{\n\tint ret;\n\tstruct buffer_head *bh = path_leaf_bh(path);\n\tstruct ocfs2_extent_list *el = path_leaf_el(path);\n\n\tif (!ocfs2_is_empty_extent(&el->l_recs[0]))\n\t\treturn 0;\n\n\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, path,\n\t\t\t\t\t   path_num_items(path) - 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_remove_empty_extent(el);\n\tocfs2_journal_dirty(handle, bh);\n\nout:\n\treturn ret;\n}\n\nstatic int __ocfs2_rotate_tree_left(handle_t *handle,\n\t\t\t\t    struct ocfs2_extent_tree *et,\n\t\t\t\t    int orig_credits,\n\t\t\t\t    struct ocfs2_path *path,\n\t\t\t\t    struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t\t    struct ocfs2_path **empty_extent_path)\n{\n\tint ret, subtree_root, deleted;\n\tu32 right_cpos;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_path *right_path = NULL;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(et->et_ci);\n\n\tif (!ocfs2_is_empty_extent(&(path_leaf_el(path)->l_recs[0])))\n\t\treturn 0;\n\n\t*empty_extent_path = NULL;\n\n\tret = ocfs2_find_cpos_for_right_leaf(sb, path, &right_cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tleft_path = ocfs2_new_path_from_path(path);\n\tif (!left_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_cp_path(left_path, path);\n\n\tright_path = ocfs2_new_path_from_path(path);\n\tif (!right_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\twhile (right_cpos) {\n\t\tret = ocfs2_find_path(et->et_ci, right_path, right_cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tsubtree_root = ocfs2_find_subtree_root(et, left_path,\n\t\t\t\t\t\t       right_path);\n\n\t\ttrace_ocfs2_rotate_subtree(subtree_root,\n\t\t     (unsigned long long)\n\t\t     right_path->p_node[subtree_root].bh->b_blocknr,\n\t\t     right_path->p_tree_depth);\n\n\t\tret = ocfs2_extend_rotate_transaction(handle, 0,\n\t\t\t\t\t\t      orig_credits, left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t   left_path, 0);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_rotate_subtree_left(handle, et, left_path,\n\t\t\t\t\t\tright_path, subtree_root,\n\t\t\t\t\t\tdealloc, &deleted);\n\t\tif (ret == -EAGAIN) {\n\t\t\t \n\t\t\t*empty_extent_path = right_path;\n\t\t\tright_path = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif (deleted)\n\t\t\tbreak;\n\n\t\tocfs2_mv_path(left_path, right_path);\n\n\t\tret = ocfs2_find_cpos_for_right_leaf(sb, left_path,\n\t\t\t\t\t\t     &right_cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tocfs2_free_path(right_path);\n\tocfs2_free_path(left_path);\n\n\treturn ret;\n}\n\nstatic int ocfs2_remove_rightmost_path(handle_t *handle,\n\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\tstruct ocfs2_path *path,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret, subtree_index;\n\tu32 cpos;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\n\tret = ocfs2_et_sanity_check(et);\n\tif (ret)\n\t\tgoto out;\n\n\tret = ocfs2_journal_access_path(et->et_ci, handle, path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_cpos_for_left_leaf(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t    path, &cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (cpos) {\n\t\t \n\t\tleft_path = ocfs2_new_path_from_path(path);\n\t\tif (!left_path) {\n\t\t\tret = -ENOMEM;\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_find_path(et->et_ci, left_path, cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_journal_access_path(et->et_ci, handle, left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tsubtree_index = ocfs2_find_subtree_root(et, left_path, path);\n\n\t\tocfs2_unlink_subtree(handle, et, left_path, path,\n\t\t\t\t     subtree_index, dealloc);\n\t\tret = ocfs2_update_edge_lengths(handle, et, left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *)path_leaf_bh(left_path)->b_data;\n\t\tocfs2_et_set_last_eb_blk(et, le64_to_cpu(eb->h_blkno));\n\t} else {\n\t\t \n\t\tocfs2_unlink_path(handle, et, dealloc, path, 1);\n\n\t\tel = et->et_root_el;\n\t\tel->l_tree_depth = 0;\n\t\tel->l_next_free_rec = 0;\n\t\tmemset(&el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n\n\t\tocfs2_et_set_last_eb_blk(et, 0);\n\t}\n\n\tocfs2_journal_dirty(handle, path_root_bh(path));\n\nout:\n\tocfs2_free_path(left_path);\n\treturn ret;\n}\n\nstatic int ocfs2_remove_rightmost_empty_extent(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\tstruct ocfs2_path *path,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\thandle_t *handle;\n\tint ret;\n\tint credits = path->p_tree_depth * 2 + 1;\n\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tret = ocfs2_remove_rightmost_path(handle, et, path, dealloc);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\tocfs2_commit_trans(osb, handle);\n\treturn ret;\n}\n\n \nstatic int ocfs2_rotate_tree_left(handle_t *handle,\n\t\t\t\t  struct ocfs2_extent_tree *et,\n\t\t\t\t  struct ocfs2_path *path,\n\t\t\t\t  struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret, orig_credits = jbd2_handle_buffer_credits(handle);\n\tstruct ocfs2_path *tmp_path = NULL, *restart_path = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\n\tel = path_leaf_el(path);\n\tif (!ocfs2_is_empty_extent(&el->l_recs[0]))\n\t\treturn 0;\n\n\tif (path->p_tree_depth == 0) {\nrightmost_no_delete:\n\t\t \n\t\tret = ocfs2_rotate_rightmost_leaf_left(handle, et, path);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t \n\n\teb = (struct ocfs2_extent_block *)path_leaf_bh(path)->b_data;\n\tel = &eb->h_list;\n\tif (eb->h_next_leaf_blk == 0) {\n\t\t \n\t\tif (le16_to_cpu(el->l_next_free_rec) > 1)\n\t\t\tgoto rightmost_no_delete;\n\n\t\tif (le16_to_cpu(el->l_next_free_rec) == 0) {\n\t\t\tret = ocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t\"Owner %llu has empty extent block at %llu\\n\",\n\t\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\t\t(unsigned long long)le64_to_cpu(eb->h_blkno));\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\n\t\tret = ocfs2_remove_rightmost_path(handle, et, path,\n\t\t\t\t\t\t  dealloc);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t \ntry_rotate:\n\tret = __ocfs2_rotate_tree_left(handle, et, orig_credits, path,\n\t\t\t\t       dealloc, &restart_path);\n\tif (ret && ret != -EAGAIN) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\twhile (ret == -EAGAIN) {\n\t\ttmp_path = restart_path;\n\t\trestart_path = NULL;\n\n\t\tret = __ocfs2_rotate_tree_left(handle, et, orig_credits,\n\t\t\t\t\t       tmp_path, dealloc,\n\t\t\t\t\t       &restart_path);\n\t\tif (ret && ret != -EAGAIN) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tocfs2_free_path(tmp_path);\n\t\ttmp_path = NULL;\n\n\t\tif (ret == 0)\n\t\t\tgoto try_rotate;\n\t}\n\nout:\n\tocfs2_free_path(tmp_path);\n\tocfs2_free_path(restart_path);\n\treturn ret;\n}\n\nstatic void ocfs2_cleanup_merge(struct ocfs2_extent_list *el,\n\t\t\t\tint index)\n{\n\tstruct ocfs2_extent_rec *rec = &el->l_recs[index];\n\tunsigned int size;\n\n\tif (rec->e_leaf_clusters == 0) {\n\t\t \n\t\tif (index > 0) {\n\t\t\tBUG_ON(ocfs2_is_empty_extent(&el->l_recs[0]));\n\t\t\tsize = index * sizeof(struct ocfs2_extent_rec);\n\t\t\tmemmove(&el->l_recs[1], &el->l_recs[0], size);\n\t\t}\n\n\t\t \n\t\tmemset(&el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n\t}\n}\n\nstatic int ocfs2_get_right_path(struct ocfs2_extent_tree *et,\n\t\t\t\tstruct ocfs2_path *left_path,\n\t\t\t\tstruct ocfs2_path **ret_right_path)\n{\n\tint ret;\n\tu32 right_cpos;\n\tstruct ocfs2_path *right_path = NULL;\n\tstruct ocfs2_extent_list *left_el;\n\n\t*ret_right_path = NULL;\n\n\t \n\tBUG_ON(left_path->p_tree_depth == 0);\n\n\tleft_el = path_leaf_el(left_path);\n\tBUG_ON(left_el->l_next_free_rec != left_el->l_count);\n\n\tret = ocfs2_find_cpos_for_right_leaf(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t     left_path, &right_cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t \n\tBUG_ON(right_cpos == 0);\n\n\tright_path = ocfs2_new_path_from_path(left_path);\n\tif (!right_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, right_path, right_cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t*ret_right_path = right_path;\nout:\n\tif (ret)\n\t\tocfs2_free_path(right_path);\n\treturn ret;\n}\n\n \nstatic int ocfs2_merge_rec_right(struct ocfs2_path *left_path,\n\t\t\t\t handle_t *handle,\n\t\t\t\t struct ocfs2_extent_tree *et,\n\t\t\t\t struct ocfs2_extent_rec *split_rec,\n\t\t\t\t int index)\n{\n\tint ret, next_free, i;\n\tunsigned int split_clusters = le16_to_cpu(split_rec->e_leaf_clusters);\n\tstruct ocfs2_extent_rec *left_rec;\n\tstruct ocfs2_extent_rec *right_rec;\n\tstruct ocfs2_extent_list *right_el;\n\tstruct ocfs2_path *right_path = NULL;\n\tint subtree_index = 0;\n\tstruct ocfs2_extent_list *el = path_leaf_el(left_path);\n\tstruct buffer_head *bh = path_leaf_bh(left_path);\n\tstruct buffer_head *root_bh = NULL;\n\n\tBUG_ON(index >= le16_to_cpu(el->l_next_free_rec));\n\tleft_rec = &el->l_recs[index];\n\n\tif (index == le16_to_cpu(el->l_next_free_rec) - 1 &&\n\t    le16_to_cpu(el->l_next_free_rec) == le16_to_cpu(el->l_count)) {\n\t\t \n\t\tret = ocfs2_get_right_path(et, left_path, &right_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tright_el = path_leaf_el(right_path);\n\t\tnext_free = le16_to_cpu(right_el->l_next_free_rec);\n\t\tBUG_ON(next_free <= 0);\n\t\tright_rec = &right_el->l_recs[0];\n\t\tif (ocfs2_is_empty_extent(right_rec)) {\n\t\t\tBUG_ON(next_free <= 1);\n\t\t\tright_rec = &right_el->l_recs[1];\n\t\t}\n\n\t\tBUG_ON(le32_to_cpu(left_rec->e_cpos) +\n\t\t       le16_to_cpu(left_rec->e_leaf_clusters) !=\n\t\t       le32_to_cpu(right_rec->e_cpos));\n\n\t\tsubtree_index = ocfs2_find_subtree_root(et, left_path,\n\t\t\t\t\t\t\tright_path);\n\n\t\tret = ocfs2_extend_rotate_transaction(handle, subtree_index,\n\t\t\t\t\tjbd2_handle_buffer_credits(handle),\n\t\t\t\t\tright_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\troot_bh = left_path->p_node[subtree_index].bh;\n\t\tBUG_ON(root_bh != right_path->p_node[subtree_index].bh);\n\n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, right_path,\n\t\t\t\t\t\t   subtree_index);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (i = subtree_index + 1;\n\t\t     i < path_num_items(right_path); i++) {\n\t\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t\t   right_path, i);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t\t   left_path, i);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\tBUG_ON(index == le16_to_cpu(el->l_next_free_rec) - 1);\n\t\tright_rec = &el->l_recs[index + 1];\n\t}\n\n\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, left_path,\n\t\t\t\t\t   path_num_items(left_path) - 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tle16_add_cpu(&left_rec->e_leaf_clusters, -split_clusters);\n\n\tle32_add_cpu(&right_rec->e_cpos, -split_clusters);\n\tle64_add_cpu(&right_rec->e_blkno,\n\t\t     -ocfs2_clusters_to_blocks(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t       split_clusters));\n\tle16_add_cpu(&right_rec->e_leaf_clusters, split_clusters);\n\n\tocfs2_cleanup_merge(el, index);\n\n\tocfs2_journal_dirty(handle, bh);\n\tif (right_path) {\n\t\tocfs2_journal_dirty(handle, path_leaf_bh(right_path));\n\t\tocfs2_complete_edge_insert(handle, left_path, right_path,\n\t\t\t\t\t   subtree_index);\n\t}\nout:\n\tocfs2_free_path(right_path);\n\treturn ret;\n}\n\nstatic int ocfs2_get_left_path(struct ocfs2_extent_tree *et,\n\t\t\t       struct ocfs2_path *right_path,\n\t\t\t       struct ocfs2_path **ret_left_path)\n{\n\tint ret;\n\tu32 left_cpos;\n\tstruct ocfs2_path *left_path = NULL;\n\n\t*ret_left_path = NULL;\n\n\t \n\tBUG_ON(right_path->p_tree_depth == 0);\n\n\tret = ocfs2_find_cpos_for_left_leaf(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t    right_path, &left_cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t \n\tBUG_ON(left_cpos == 0);\n\n\tleft_path = ocfs2_new_path_from_path(right_path);\n\tif (!left_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, left_path, left_cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t*ret_left_path = left_path;\nout:\n\tif (ret)\n\t\tocfs2_free_path(left_path);\n\treturn ret;\n}\n\n \nstatic int ocfs2_merge_rec_left(struct ocfs2_path *right_path,\n\t\t\t\thandle_t *handle,\n\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\tstruct ocfs2_extent_rec *split_rec,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t\tint index)\n{\n\tint ret, i, subtree_index = 0, has_empty_extent = 0;\n\tunsigned int split_clusters = le16_to_cpu(split_rec->e_leaf_clusters);\n\tstruct ocfs2_extent_rec *left_rec;\n\tstruct ocfs2_extent_rec *right_rec;\n\tstruct ocfs2_extent_list *el = path_leaf_el(right_path);\n\tstruct buffer_head *bh = path_leaf_bh(right_path);\n\tstruct buffer_head *root_bh = NULL;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_extent_list *left_el;\n\n\tBUG_ON(index < 0);\n\n\tright_rec = &el->l_recs[index];\n\tif (index == 0) {\n\t\t \n\t\tret = ocfs2_get_left_path(et, right_path, &left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tleft_el = path_leaf_el(left_path);\n\t\tBUG_ON(le16_to_cpu(left_el->l_next_free_rec) !=\n\t\t       le16_to_cpu(left_el->l_count));\n\n\t\tleft_rec = &left_el->l_recs[\n\t\t\t\tle16_to_cpu(left_el->l_next_free_rec) - 1];\n\t\tBUG_ON(le32_to_cpu(left_rec->e_cpos) +\n\t\t       le16_to_cpu(left_rec->e_leaf_clusters) !=\n\t\t       le32_to_cpu(split_rec->e_cpos));\n\n\t\tsubtree_index = ocfs2_find_subtree_root(et, left_path,\n\t\t\t\t\t\t\tright_path);\n\n\t\tret = ocfs2_extend_rotate_transaction(handle, subtree_index,\n\t\t\t\t\tjbd2_handle_buffer_credits(handle),\n\t\t\t\t\tleft_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\troot_bh = left_path->p_node[subtree_index].bh;\n\t\tBUG_ON(root_bh != right_path->p_node[subtree_index].bh);\n\n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, right_path,\n\t\t\t\t\t\t   subtree_index);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (i = subtree_index + 1;\n\t\t     i < path_num_items(right_path); i++) {\n\t\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t\t   right_path, i);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t\t   left_path, i);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tleft_rec = &el->l_recs[index - 1];\n\t\tif (ocfs2_is_empty_extent(&el->l_recs[0]))\n\t\t\thas_empty_extent = 1;\n\t}\n\n\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, right_path,\n\t\t\t\t\t   path_num_items(right_path) - 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (has_empty_extent && index == 1) {\n\t\t \n\t\t*left_rec = *split_rec;\n\t} else\n\t\tle16_add_cpu(&left_rec->e_leaf_clusters, split_clusters);\n\n\tle32_add_cpu(&right_rec->e_cpos, split_clusters);\n\tle64_add_cpu(&right_rec->e_blkno,\n\t\t     ocfs2_clusters_to_blocks(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t      split_clusters));\n\tle16_add_cpu(&right_rec->e_leaf_clusters, -split_clusters);\n\n\tocfs2_cleanup_merge(el, index);\n\n\tocfs2_journal_dirty(handle, bh);\n\tif (left_path) {\n\t\tocfs2_journal_dirty(handle, path_leaf_bh(left_path));\n\n\t\t \n\t\tif (le16_to_cpu(right_rec->e_leaf_clusters) == 0 &&\n\t\t    le16_to_cpu(el->l_next_free_rec) == 1) {\n\t\t\t \n\t\t\tret = ocfs2_extend_rotate_transaction(handle, 0,\n\t\t\t\t\tjbd2_handle_buffer_credits(handle),\n\t\t\t\t\tright_path);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = ocfs2_remove_rightmost_path(handle, et,\n\t\t\t\t\t\t\t  right_path,\n\t\t\t\t\t\t\t  dealloc);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t \n\t\t\tocfs2_mv_path(right_path, left_path);\n\t\t\tleft_path = NULL;\n\t\t} else\n\t\t\tocfs2_complete_edge_insert(handle, left_path,\n\t\t\t\t\t\t   right_path, subtree_index);\n\t}\nout:\n\tocfs2_free_path(left_path);\n\treturn ret;\n}\n\nstatic int ocfs2_try_to_merge_extent(handle_t *handle,\n\t\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_path *path,\n\t\t\t\t     int split_index,\n\t\t\t\t     struct ocfs2_extent_rec *split_rec,\n\t\t\t\t     struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t\t     struct ocfs2_merge_ctxt *ctxt)\n{\n\tint ret = 0;\n\tstruct ocfs2_extent_list *el = path_leaf_el(path);\n\tstruct ocfs2_extent_rec *rec = &el->l_recs[split_index];\n\n\tBUG_ON(ctxt->c_contig_type == CONTIG_NONE);\n\n\tif (ctxt->c_split_covers_rec && ctxt->c_has_empty_extent) {\n\t\t \n\t\tret = ocfs2_extend_rotate_transaction(handle, 0,\n\t\t\t\tjbd2_handle_buffer_credits(handle),\n\t\t\t\tpath);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\tret = ocfs2_rotate_tree_left(handle, et, path, dealloc);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tsplit_index--;\n\t\trec = &el->l_recs[split_index];\n\t}\n\n\tif (ctxt->c_contig_type == CONTIG_LEFTRIGHT) {\n\t\t \n\t\tBUG_ON(!ctxt->c_split_covers_rec);\n\n\t\t \n\t\tret = ocfs2_merge_rec_right(path, handle, et, split_rec,\n\t\t\t\t\t    split_index);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tBUG_ON(!ocfs2_is_empty_extent(&el->l_recs[0]));\n\n\t\t \n\t\tret = ocfs2_extend_rotate_transaction(handle, 0,\n\t\t\t\t\tjbd2_handle_buffer_credits(handle),\n\t\t\t\t\tpath);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tret = ocfs2_rotate_tree_left(handle, et, path, dealloc);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\trec = &el->l_recs[split_index];\n\n\t\t \n\t\tret = ocfs2_merge_rec_left(path, handle, et, rec,\n\t\t\t\t\t   dealloc, split_index);\n\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tret = ocfs2_extend_rotate_transaction(handle, 0,\n\t\t\t\tjbd2_handle_buffer_credits(handle),\n\t\t\t\tpath);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_rotate_tree_left(handle, et, path, dealloc);\n\t\t \n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tret = 0;\n\t} else {\n\t\t \n\t\tif (ctxt->c_contig_type == CONTIG_RIGHT) {\n\t\t\tret = ocfs2_merge_rec_left(path, handle, et,\n\t\t\t\t\t\t   split_rec, dealloc,\n\t\t\t\t\t\t   split_index);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\tret = ocfs2_merge_rec_right(path, handle,\n\t\t\t\t\t\t    et, split_rec,\n\t\t\t\t\t\t    split_index);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (ctxt->c_split_covers_rec) {\n\t\t\t \n\t\t\tret = ocfs2_extend_rotate_transaction(handle, 0,\n\t\t\t\t\tjbd2_handle_buffer_credits(handle),\n\t\t\t\t\tpath);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tret = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t \n\t\t\tret = ocfs2_rotate_tree_left(handle, et, path,\n\t\t\t\t\t\t     dealloc);\n\t\t\tif (ret)\n\t\t\t\tmlog_errno(ret);\n\t\t\tret = 0;\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}\n\nstatic void ocfs2_subtract_from_rec(struct super_block *sb,\n\t\t\t\t    enum ocfs2_split_type split,\n\t\t\t\t    struct ocfs2_extent_rec *rec,\n\t\t\t\t    struct ocfs2_extent_rec *split_rec)\n{\n\tu64 len_blocks;\n\n\tlen_blocks = ocfs2_clusters_to_blocks(sb,\n\t\t\t\tle16_to_cpu(split_rec->e_leaf_clusters));\n\n\tif (split == SPLIT_LEFT) {\n\t\t \n\t\tle32_add_cpu(&rec->e_cpos,\n\t\t\t     le16_to_cpu(split_rec->e_leaf_clusters));\n\t\tle64_add_cpu(&rec->e_blkno, len_blocks);\n\t\tle16_add_cpu(&rec->e_leaf_clusters,\n\t\t\t     -le16_to_cpu(split_rec->e_leaf_clusters));\n\t} else {\n\t\t \n\t\tle16_add_cpu(&rec->e_leaf_clusters,\n\t\t\t     -le16_to_cpu(split_rec->e_leaf_clusters));\n\t}\n}\n\n \nstatic void ocfs2_insert_at_leaf(struct ocfs2_extent_tree *et,\n\t\t\t\t struct ocfs2_extent_rec *insert_rec,\n\t\t\t\t struct ocfs2_extent_list *el,\n\t\t\t\t struct ocfs2_insert_type *insert)\n{\n\tint i = insert->ins_contig_index;\n\tunsigned int range;\n\tstruct ocfs2_extent_rec *rec;\n\n\tBUG_ON(le16_to_cpu(el->l_tree_depth) != 0);\n\n\tif (insert->ins_split != SPLIT_NONE) {\n\t\ti = ocfs2_search_extent_list(el, le32_to_cpu(insert_rec->e_cpos));\n\t\tBUG_ON(i == -1);\n\t\trec = &el->l_recs[i];\n\t\tocfs2_subtract_from_rec(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\tinsert->ins_split, rec,\n\t\t\t\t\tinsert_rec);\n\t\tgoto rotate;\n\t}\n\n\t \n\tif (insert->ins_contig != CONTIG_NONE) {\n\t\trec = &el->l_recs[i];\n\t\tif (insert->ins_contig == CONTIG_LEFT) {\n\t\t\trec->e_blkno = insert_rec->e_blkno;\n\t\t\trec->e_cpos = insert_rec->e_cpos;\n\t\t}\n\t\tle16_add_cpu(&rec->e_leaf_clusters,\n\t\t\t     le16_to_cpu(insert_rec->e_leaf_clusters));\n\t\treturn;\n\t}\n\n\t \n\tif (le16_to_cpu(el->l_next_free_rec) == 0 ||\n\t    ((le16_to_cpu(el->l_next_free_rec) == 1) &&\n\t     ocfs2_is_empty_extent(&el->l_recs[0]))) {\n\t\tel->l_recs[0] = *insert_rec;\n\t\tel->l_next_free_rec = cpu_to_le16(1);\n\t\treturn;\n\t}\n\n\t \n\tif (insert->ins_appending == APPEND_TAIL) {\n\t\ti = le16_to_cpu(el->l_next_free_rec) - 1;\n\t\trec = &el->l_recs[i];\n\t\trange = le32_to_cpu(rec->e_cpos)\n\t\t\t+ le16_to_cpu(rec->e_leaf_clusters);\n\t\tBUG_ON(le32_to_cpu(insert_rec->e_cpos) < range);\n\n\t\tmlog_bug_on_msg(le16_to_cpu(el->l_next_free_rec) >=\n\t\t\t\tle16_to_cpu(el->l_count),\n\t\t\t\t\"owner %llu, depth %u, count %u, next free %u, \"\n\t\t\t\t\"rec.cpos %u, rec.clusters %u, \"\n\t\t\t\t\"insert.cpos %u, insert.clusters %u\\n\",\n\t\t\t\tocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\tle16_to_cpu(el->l_tree_depth),\n\t\t\t\tle16_to_cpu(el->l_count),\n\t\t\t\tle16_to_cpu(el->l_next_free_rec),\n\t\t\t\tle32_to_cpu(el->l_recs[i].e_cpos),\n\t\t\t\tle16_to_cpu(el->l_recs[i].e_leaf_clusters),\n\t\t\t\tle32_to_cpu(insert_rec->e_cpos),\n\t\t\t\tle16_to_cpu(insert_rec->e_leaf_clusters));\n\t\ti++;\n\t\tel->l_recs[i] = *insert_rec;\n\t\tle16_add_cpu(&el->l_next_free_rec, 1);\n\t\treturn;\n\t}\n\nrotate:\n\t \n\tocfs2_rotate_leaf(el, insert_rec);\n}\n\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec)\n{\n\tint i, next_free;\n\tstruct buffer_head *bh;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\n\t \n\tfor (i = 0; i < path->p_tree_depth; i++) {\n\t\tbh = path->p_node[i].bh;\n\t\tel = path->p_node[i].el;\n\n\t\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\t\tif (next_free == 0) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu has a bad extent list\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci));\n\t\t\treturn;\n\t\t}\n\n\t\trec = &el->l_recs[next_free - 1];\n\n\t\trec->e_int_clusters = insert_rec->e_cpos;\n\t\tle32_add_cpu(&rec->e_int_clusters,\n\t\t\t     le16_to_cpu(insert_rec->e_leaf_clusters));\n\t\tle32_add_cpu(&rec->e_int_clusters,\n\t\t\t     -le32_to_cpu(rec->e_cpos));\n\n\t\tocfs2_journal_dirty(handle, bh);\n\t}\n}\n\nstatic int ocfs2_append_rec_to_path(handle_t *handle,\n\t\t\t\t    struct ocfs2_extent_tree *et,\n\t\t\t\t    struct ocfs2_extent_rec *insert_rec,\n\t\t\t\t    struct ocfs2_path *right_path,\n\t\t\t\t    struct ocfs2_path **ret_left_path)\n{\n\tint ret, next_free;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_path *left_path = NULL;\n\n\t*ret_left_path = NULL;\n\n\t \n\tBUG_ON(right_path->p_tree_depth == 0);\n\n\t \n\tel = path_leaf_el(right_path);\n\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\tif (next_free == 0 ||\n\t    (next_free == 1 && ocfs2_is_empty_extent(&el->l_recs[0]))) {\n\t\tu32 left_cpos;\n\n\t\tret = ocfs2_find_cpos_for_left_leaf(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t\t    right_path, &left_cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\ttrace_ocfs2_append_rec_to_path(\n\t\t\t(unsigned long long)\n\t\t\tocfs2_metadata_cache_owner(et->et_ci),\n\t\t\tle32_to_cpu(insert_rec->e_cpos),\n\t\t\tleft_cpos);\n\n\t\t \n\t\tif (left_cpos) {\n\t\t\tleft_path = ocfs2_new_path_from_path(right_path);\n\t\t\tif (!left_path) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = ocfs2_find_path(et->et_ci, left_path,\n\t\t\t\t\t      left_cpos);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t \n\t\t}\n\t}\n\n\tret = ocfs2_journal_access_path(et->et_ci, handle, right_path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_adjust_rightmost_records(handle, et, right_path, insert_rec);\n\n\t*ret_left_path = left_path;\n\tret = 0;\nout:\n\tif (ret != 0)\n\t\tocfs2_free_path(left_path);\n\n\treturn ret;\n}\n\nstatic void ocfs2_split_record(struct ocfs2_extent_tree *et,\n\t\t\t       struct ocfs2_path *left_path,\n\t\t\t       struct ocfs2_path *right_path,\n\t\t\t       struct ocfs2_extent_rec *split_rec,\n\t\t\t       enum ocfs2_split_type split)\n{\n\tint index;\n\tu32 cpos = le32_to_cpu(split_rec->e_cpos);\n\tstruct ocfs2_extent_list *left_el = NULL, *right_el, *insert_el, *el;\n\tstruct ocfs2_extent_rec *rec, *tmprec;\n\n\tright_el = path_leaf_el(right_path);\n\tif (left_path)\n\t\tleft_el = path_leaf_el(left_path);\n\n\tel = right_el;\n\tinsert_el = right_el;\n\tindex = ocfs2_search_extent_list(el, cpos);\n\tif (index != -1) {\n\t\tif (index == 0 && left_path) {\n\t\t\tBUG_ON(ocfs2_is_empty_extent(&el->l_recs[0]));\n\n\t\t\t \n\n\t\t\tif (split == SPLIT_LEFT) {\n\t\t\t\t \n\t\t\t\tinsert_el = left_el;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\ttmprec = &right_el->l_recs[index];\n\t\t\t\tocfs2_rotate_leaf(left_el, tmprec);\n\t\t\t\tel = left_el;\n\n\t\t\t\tmemset(tmprec, 0, sizeof(*tmprec));\n\t\t\t\tindex = ocfs2_search_extent_list(left_el, cpos);\n\t\t\t\tBUG_ON(index == -1);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tBUG_ON(!left_path);\n\t\tBUG_ON(!ocfs2_is_empty_extent(&left_el->l_recs[0]));\n\t\t \n\t\tel = left_el;\n\t\tinsert_el = left_el;\n\t\tindex = ocfs2_search_extent_list(el, cpos);\n\t\tBUG_ON(index == -1);\n\t}\n\n\trec = &el->l_recs[index];\n\tocfs2_subtract_from_rec(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\tsplit, rec, split_rec);\n\tocfs2_rotate_leaf(insert_el, split_rec);\n}\n\n \nstatic int ocfs2_insert_path(handle_t *handle,\n\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t     struct ocfs2_path *left_path,\n\t\t\t     struct ocfs2_path *right_path,\n\t\t\t     struct ocfs2_extent_rec *insert_rec,\n\t\t\t     struct ocfs2_insert_type *insert)\n{\n\tint ret, subtree_index;\n\tstruct buffer_head *leaf_bh = path_leaf_bh(right_path);\n\n\tif (left_path) {\n\t\t \n\t\tret = ocfs2_extend_trans(handle, left_path->p_tree_depth);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_journal_access_path(et->et_ci, handle, left_path);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tret = ocfs2_journal_access_path(et->et_ci, handle, right_path);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (insert->ins_split != SPLIT_NONE) {\n\t\t \n\t\tocfs2_split_record(et, left_path, right_path,\n\t\t\t\t   insert_rec, insert->ins_split);\n\n\t\t \n\t\tif (left_path)\n\t\t\tocfs2_journal_dirty(handle,\n\t\t\t\t\t    path_leaf_bh(left_path));\n\t} else\n\t\tocfs2_insert_at_leaf(et, insert_rec, path_leaf_el(right_path),\n\t\t\t\t     insert);\n\n\tocfs2_journal_dirty(handle, leaf_bh);\n\n\tif (left_path) {\n\t\t \n\t\tsubtree_index = ocfs2_find_subtree_root(et, left_path,\n\t\t\t\t\t\t\tright_path);\n\t\tocfs2_complete_edge_insert(handle, left_path, right_path,\n\t\t\t\t\t   subtree_index);\n\t}\n\n\tret = 0;\nout:\n\treturn ret;\n}\n\nstatic int ocfs2_do_insert_extent(handle_t *handle,\n\t\t\t\t  struct ocfs2_extent_tree *et,\n\t\t\t\t  struct ocfs2_extent_rec *insert_rec,\n\t\t\t\t  struct ocfs2_insert_type *type)\n{\n\tint ret, rotate = 0;\n\tu32 cpos;\n\tstruct ocfs2_path *right_path = NULL;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_extent_list *el;\n\n\tel = et->et_root_el;\n\n\tret = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (le16_to_cpu(el->l_tree_depth) == 0) {\n\t\tocfs2_insert_at_leaf(et, insert_rec, el, type);\n\t\tgoto out_update_clusters;\n\t}\n\n\tright_path = ocfs2_new_path_from_et(et);\n\tif (!right_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t \n\tcpos = le32_to_cpu(insert_rec->e_cpos);\n\tif (type->ins_appending == APPEND_NONE &&\n\t    type->ins_contig == CONTIG_NONE) {\n\t\trotate = 1;\n\t\tcpos = UINT_MAX;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, right_path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t \n\tif (rotate) {\n\t\tret = ocfs2_rotate_tree_right(handle, et, type->ins_split,\n\t\t\t\t\t      le32_to_cpu(insert_rec->e_cpos),\n\t\t\t\t\t      right_path, &left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tret = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t} else if (type->ins_appending == APPEND_TAIL\n\t\t   && type->ins_contig != CONTIG_LEFT) {\n\t\tret = ocfs2_append_rec_to_path(handle, et, insert_rec,\n\t\t\t\t\t       right_path, &left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ocfs2_insert_path(handle, et, left_path, right_path,\n\t\t\t\tinsert_rec, type);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\nout_update_clusters:\n\tif (type->ins_split == SPLIT_NONE)\n\t\tocfs2_et_update_clusters(et,\n\t\t\t\t\t le16_to_cpu(insert_rec->e_leaf_clusters));\n\n\tocfs2_journal_dirty(handle, et->et_root_bh);\n\nout:\n\tocfs2_free_path(left_path);\n\tocfs2_free_path(right_path);\n\n\treturn ret;\n}\n\nstatic int ocfs2_figure_merge_contig_type(struct ocfs2_extent_tree *et,\n\t\t\t       struct ocfs2_path *path,\n\t\t\t       struct ocfs2_extent_list *el, int index,\n\t\t\t       struct ocfs2_extent_rec *split_rec,\n\t\t\t       struct ocfs2_merge_ctxt *ctxt)\n{\n\tint status = 0;\n\tenum ocfs2_contig_type ret = CONTIG_NONE;\n\tu32 left_cpos, right_cpos;\n\tstruct ocfs2_extent_rec *rec = NULL;\n\tstruct ocfs2_extent_list *new_el;\n\tstruct ocfs2_path *left_path = NULL, *right_path = NULL;\n\tstruct buffer_head *bh;\n\tstruct ocfs2_extent_block *eb;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(et->et_ci);\n\n\tif (index > 0) {\n\t\trec = &el->l_recs[index - 1];\n\t} else if (path->p_tree_depth > 0) {\n\t\tstatus = ocfs2_find_cpos_for_left_leaf(sb, path, &left_cpos);\n\t\tif (status)\n\t\t\tgoto exit;\n\n\t\tif (left_cpos != 0) {\n\t\t\tleft_path = ocfs2_new_path_from_path(path);\n\t\t\tif (!left_path) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tstatus = ocfs2_find_path(et->et_ci, left_path,\n\t\t\t\t\t\t left_cpos);\n\t\t\tif (status)\n\t\t\t\tgoto free_left_path;\n\n\t\t\tnew_el = path_leaf_el(left_path);\n\n\t\t\tif (le16_to_cpu(new_el->l_next_free_rec) !=\n\t\t\t    le16_to_cpu(new_el->l_count)) {\n\t\t\t\tbh = path_leaf_bh(left_path);\n\t\t\t\teb = (struct ocfs2_extent_block *)bh->b_data;\n\t\t\t\tstatus = ocfs2_error(sb,\n\t\t\t\t\t\t\"Extent block #%llu has an invalid l_next_free_rec of %d.  It should have matched the l_count of %d\\n\",\n\t\t\t\t\t\t(unsigned long long)le64_to_cpu(eb->h_blkno),\n\t\t\t\t\t\tle16_to_cpu(new_el->l_next_free_rec),\n\t\t\t\t\t\tle16_to_cpu(new_el->l_count));\n\t\t\t\tgoto free_left_path;\n\t\t\t}\n\t\t\trec = &new_el->l_recs[\n\t\t\t\tle16_to_cpu(new_el->l_next_free_rec) - 1];\n\t\t}\n\t}\n\n\t \n\tif (rec) {\n\t\tif (index == 1 && ocfs2_is_empty_extent(rec)) {\n\t\t\tif (split_rec->e_cpos == el->l_recs[index].e_cpos)\n\t\t\t\tret = CONTIG_RIGHT;\n\t\t} else {\n\t\t\tret = ocfs2_et_extent_contig(et, rec, split_rec);\n\t\t}\n\t}\n\n\trec = NULL;\n\tif (index < (le16_to_cpu(el->l_next_free_rec) - 1))\n\t\trec = &el->l_recs[index + 1];\n\telse if (le16_to_cpu(el->l_next_free_rec) == le16_to_cpu(el->l_count) &&\n\t\t path->p_tree_depth > 0) {\n\t\tstatus = ocfs2_find_cpos_for_right_leaf(sb, path, &right_cpos);\n\t\tif (status)\n\t\t\tgoto free_left_path;\n\n\t\tif (right_cpos == 0)\n\t\t\tgoto free_left_path;\n\n\t\tright_path = ocfs2_new_path_from_path(path);\n\t\tif (!right_path) {\n\t\t\tstatus = -ENOMEM;\n\t\t\tmlog_errno(status);\n\t\t\tgoto free_left_path;\n\t\t}\n\n\t\tstatus = ocfs2_find_path(et->et_ci, right_path, right_cpos);\n\t\tif (status)\n\t\t\tgoto free_right_path;\n\n\t\tnew_el = path_leaf_el(right_path);\n\t\trec = &new_el->l_recs[0];\n\t\tif (ocfs2_is_empty_extent(rec)) {\n\t\t\tif (le16_to_cpu(new_el->l_next_free_rec) <= 1) {\n\t\t\t\tbh = path_leaf_bh(right_path);\n\t\t\t\teb = (struct ocfs2_extent_block *)bh->b_data;\n\t\t\t\tstatus = ocfs2_error(sb,\n\t\t\t\t\t\t\"Extent block #%llu has an invalid l_next_free_rec of %d\\n\",\n\t\t\t\t\t\t(unsigned long long)le64_to_cpu(eb->h_blkno),\n\t\t\t\t\t\tle16_to_cpu(new_el->l_next_free_rec));\n\t\t\t\tgoto free_right_path;\n\t\t\t}\n\t\t\trec = &new_el->l_recs[1];\n\t\t}\n\t}\n\n\tif (rec) {\n\t\tenum ocfs2_contig_type contig_type;\n\n\t\tcontig_type = ocfs2_et_extent_contig(et, rec, split_rec);\n\n\t\tif (contig_type == CONTIG_LEFT && ret == CONTIG_RIGHT)\n\t\t\tret = CONTIG_LEFTRIGHT;\n\t\telse if (ret == CONTIG_NONE)\n\t\t\tret = contig_type;\n\t}\n\nfree_right_path:\n\tocfs2_free_path(right_path);\nfree_left_path:\n\tocfs2_free_path(left_path);\nexit:\n\tif (status == 0)\n\t\tctxt->c_contig_type = ret;\n\n\treturn status;\n}\n\nstatic void ocfs2_figure_contig_type(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_insert_type *insert,\n\t\t\t\t     struct ocfs2_extent_list *el,\n\t\t\t\t     struct ocfs2_extent_rec *insert_rec)\n{\n\tint i;\n\tenum ocfs2_contig_type contig_type = CONTIG_NONE;\n\n\tBUG_ON(le16_to_cpu(el->l_tree_depth) != 0);\n\n\tfor(i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {\n\t\tcontig_type = ocfs2_et_extent_contig(et, &el->l_recs[i],\n\t\t\t\t\t\t     insert_rec);\n\t\tif (contig_type != CONTIG_NONE) {\n\t\t\tinsert->ins_contig_index = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tinsert->ins_contig = contig_type;\n\n\tif (insert->ins_contig != CONTIG_NONE) {\n\t\tstruct ocfs2_extent_rec *rec =\n\t\t\t\t&el->l_recs[insert->ins_contig_index];\n\t\tunsigned int len = le16_to_cpu(rec->e_leaf_clusters) +\n\t\t\t\t   le16_to_cpu(insert_rec->e_leaf_clusters);\n\n\t\t \n\t\tif (et->et_max_leaf_clusters &&\n\t\t    (len > et->et_max_leaf_clusters))\n\t\t\tinsert->ins_contig = CONTIG_NONE;\n\t}\n}\n\n \nstatic void ocfs2_figure_appending_type(struct ocfs2_insert_type *insert,\n\t\t\t\t\tstruct ocfs2_extent_list *el,\n\t\t\t\t\tstruct ocfs2_extent_rec *insert_rec)\n{\n\tint i;\n\tu32 cpos = le32_to_cpu(insert_rec->e_cpos);\n\tstruct ocfs2_extent_rec *rec;\n\n\tinsert->ins_appending = APPEND_NONE;\n\n\tBUG_ON(le16_to_cpu(el->l_tree_depth) != 0);\n\n\tif (!el->l_next_free_rec)\n\t\tgoto set_tail_append;\n\n\tif (ocfs2_is_empty_extent(&el->l_recs[0])) {\n\t\t \n\t\tif (le16_to_cpu(el->l_next_free_rec) == 1)\n\t\t\tgoto set_tail_append;\n\t}\n\n\ti = le16_to_cpu(el->l_next_free_rec) - 1;\n\trec = &el->l_recs[i];\n\n\tif (cpos >=\n\t    (le32_to_cpu(rec->e_cpos) + le16_to_cpu(rec->e_leaf_clusters)))\n\t\tgoto set_tail_append;\n\n\treturn;\n\nset_tail_append:\n\tinsert->ins_appending = APPEND_TAIL;\n}\n\n \nstatic int ocfs2_figure_insert_type(struct ocfs2_extent_tree *et,\n\t\t\t\t    struct buffer_head **last_eb_bh,\n\t\t\t\t    struct ocfs2_extent_rec *insert_rec,\n\t\t\t\t    int *free_records,\n\t\t\t\t    struct ocfs2_insert_type *insert)\n{\n\tint ret;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_path *path = NULL;\n\tstruct buffer_head *bh = NULL;\n\n\tinsert->ins_split = SPLIT_NONE;\n\n\tel = et->et_root_el;\n\tinsert->ins_tree_depth = le16_to_cpu(el->l_tree_depth);\n\n\tif (el->l_tree_depth) {\n\t\t \n\t\tret = ocfs2_read_extent_block(et->et_ci,\n\t\t\t\t\t      ocfs2_et_get_last_eb_blk(et),\n\t\t\t\t\t      &bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\teb = (struct ocfs2_extent_block *) bh->b_data;\n\t\tel = &eb->h_list;\n\t}\n\n\t \n\t*free_records = le16_to_cpu(el->l_count) -\n\t\tle16_to_cpu(el->l_next_free_rec);\n\n\tif (!insert->ins_tree_depth) {\n\t\tocfs2_figure_contig_type(et, insert, el, insert_rec);\n\t\tocfs2_figure_appending_type(insert, el, insert_rec);\n\t\treturn 0;\n\t}\n\n\tpath = ocfs2_new_path_from_et(et);\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t \n\tret = ocfs2_find_path(et->et_ci, path, le32_to_cpu(insert_rec->e_cpos));\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tel = path_leaf_el(path);\n\n\t \n\tocfs2_figure_contig_type(et, insert, el, insert_rec);\n\n\t \n\tif (insert->ins_contig == CONTIG_LEFT &&\n\t    insert->ins_contig_index == 0)\n\t\tinsert->ins_contig = CONTIG_NONE;\n\n\t \n\tif (ocfs2_et_get_last_eb_blk(et) ==\n\t    path_leaf_bh(path)->b_blocknr) {\n\t\t \n\t\tocfs2_figure_appending_type(insert, el, insert_rec);\n\t}\n\nout:\n\tocfs2_free_path(path);\n\n\tif (ret == 0)\n\t\t*last_eb_bh = bh;\n\telse\n\t\tbrelse(bh);\n\treturn ret;\n}\n\n \nint ocfs2_insert_extent(handle_t *handle,\n\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\tu32 cpos,\n\t\t\tu64 start_blk,\n\t\t\tu32 new_clusters,\n\t\t\tu8 flags,\n\t\t\tstruct ocfs2_alloc_context *meta_ac)\n{\n\tint status;\n\tint free_records;\n\tstruct buffer_head *last_eb_bh = NULL;\n\tstruct ocfs2_insert_type insert = {0, };\n\tstruct ocfs2_extent_rec rec;\n\n\ttrace_ocfs2_insert_extent_start(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\tcpos, new_clusters);\n\n\tmemset(&rec, 0, sizeof(rec));\n\trec.e_cpos = cpu_to_le32(cpos);\n\trec.e_blkno = cpu_to_le64(start_blk);\n\trec.e_leaf_clusters = cpu_to_le16(new_clusters);\n\trec.e_flags = flags;\n\tstatus = ocfs2_et_insert_check(et, &rec);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_figure_insert_type(et, &last_eb_bh, &rec,\n\t\t\t\t\t  &free_records, &insert);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_insert_extent(insert.ins_appending, insert.ins_contig,\n\t\t\t\t  insert.ins_contig_index, free_records,\n\t\t\t\t  insert.ins_tree_depth);\n\n\tif (insert.ins_contig == CONTIG_NONE && free_records == 0) {\n\t\tstatus = ocfs2_grow_tree(handle, et,\n\t\t\t\t\t &insert.ins_tree_depth, &last_eb_bh,\n\t\t\t\t\t meta_ac);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t \n\tstatus = ocfs2_do_insert_extent(handle, et, &rec, &insert);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\telse\n\t\tocfs2_et_extent_map_insert(et, &rec);\n\nbail:\n\tbrelse(last_eb_bh);\n\n\treturn status;\n}\n\n \nint ocfs2_add_clusters_in_btree(handle_t *handle,\n\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\tu32 *logical_offset,\n\t\t\t\tu32 clusters_to_add,\n\t\t\t\tint mark_unwritten,\n\t\t\t\tstruct ocfs2_alloc_context *data_ac,\n\t\t\t\tstruct ocfs2_alloc_context *meta_ac,\n\t\t\t\tenum ocfs2_alloc_restarted *reason_ret)\n{\n\tint status = 0, err = 0;\n\tint need_free = 0;\n\tint free_extents;\n\tenum ocfs2_alloc_restarted reason = RESTART_NONE;\n\tu32 bit_off, num_bits;\n\tu64 block;\n\tu8 flags = 0;\n\tstruct ocfs2_super *osb =\n\t\tOCFS2_SB(ocfs2_metadata_cache_get_super(et->et_ci));\n\n\tBUG_ON(!clusters_to_add);\n\n\tif (mark_unwritten)\n\t\tflags = OCFS2_EXT_UNWRITTEN;\n\n\tfree_extents = ocfs2_num_free_extents(et);\n\tif (free_extents < 0) {\n\t\tstatus = free_extents;\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t \n\tif (!free_extents && !meta_ac) {\n\t\terr = -1;\n\t\tstatus = -EAGAIN;\n\t\treason = RESTART_META;\n\t\tgoto leave;\n\t} else if ((!free_extents)\n\t\t   && (ocfs2_alloc_context_bits_left(meta_ac)\n\t\t       < ocfs2_extend_meta_needed(et->et_root_el))) {\n\t\terr = -2;\n\t\tstatus = -EAGAIN;\n\t\treason = RESTART_META;\n\t\tgoto leave;\n\t}\n\n\tstatus = __ocfs2_claim_clusters(handle, data_ac, 1,\n\t\t\t\t\tclusters_to_add, &bit_off, &num_bits);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tBUG_ON(num_bits > clusters_to_add);\n\n\t \n\tstatus = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tneed_free = 1;\n\t\tgoto bail;\n\t}\n\n\tblock = ocfs2_clusters_to_blocks(osb->sb, bit_off);\n\ttrace_ocfs2_add_clusters_in_btree(\n\t     (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t     bit_off, num_bits);\n\tstatus = ocfs2_insert_extent(handle, et, *logical_offset, block,\n\t\t\t\t     num_bits, flags, meta_ac);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tneed_free = 1;\n\t\tgoto bail;\n\t}\n\n\tocfs2_journal_dirty(handle, et->et_root_bh);\n\n\tclusters_to_add -= num_bits;\n\t*logical_offset += num_bits;\n\n\tif (clusters_to_add) {\n\t\terr = clusters_to_add;\n\t\tstatus = -EAGAIN;\n\t\treason = RESTART_TRANS;\n\t}\n\nbail:\n\tif (need_free) {\n\t\tif (data_ac->ac_which == OCFS2_AC_USE_LOCAL)\n\t\t\tocfs2_free_local_alloc_bits(osb, handle, data_ac,\n\t\t\t\t\tbit_off, num_bits);\n\t\telse\n\t\t\tocfs2_free_clusters(handle,\n\t\t\t\t\tdata_ac->ac_inode,\n\t\t\t\t\tdata_ac->ac_bh,\n\t\t\t\t\tocfs2_clusters_to_blocks(osb->sb, bit_off),\n\t\t\t\t\tnum_bits);\n\t}\n\nleave:\n\tif (reason_ret)\n\t\t*reason_ret = reason;\n\ttrace_ocfs2_add_clusters_in_btree_ret(status, reason, err);\n\treturn status;\n}\n\nstatic void ocfs2_make_right_split_rec(struct super_block *sb,\n\t\t\t\t       struct ocfs2_extent_rec *split_rec,\n\t\t\t\t       u32 cpos,\n\t\t\t\t       struct ocfs2_extent_rec *rec)\n{\n\tu32 rec_cpos = le32_to_cpu(rec->e_cpos);\n\tu32 rec_range = rec_cpos + le16_to_cpu(rec->e_leaf_clusters);\n\n\tmemset(split_rec, 0, sizeof(struct ocfs2_extent_rec));\n\n\tsplit_rec->e_cpos = cpu_to_le32(cpos);\n\tsplit_rec->e_leaf_clusters = cpu_to_le16(rec_range - cpos);\n\n\tsplit_rec->e_blkno = rec->e_blkno;\n\tle64_add_cpu(&split_rec->e_blkno,\n\t\t     ocfs2_clusters_to_blocks(sb, cpos - rec_cpos));\n\n\tsplit_rec->e_flags = rec->e_flags;\n}\n\nstatic int ocfs2_split_and_insert(handle_t *handle,\n\t\t\t\t  struct ocfs2_extent_tree *et,\n\t\t\t\t  struct ocfs2_path *path,\n\t\t\t\t  struct buffer_head **last_eb_bh,\n\t\t\t\t  int split_index,\n\t\t\t\t  struct ocfs2_extent_rec *orig_split_rec,\n\t\t\t\t  struct ocfs2_alloc_context *meta_ac)\n{\n\tint ret = 0, depth;\n\tunsigned int insert_range, rec_range, do_leftright = 0;\n\tstruct ocfs2_extent_rec tmprec;\n\tstruct ocfs2_extent_list *rightmost_el;\n\tstruct ocfs2_extent_rec rec;\n\tstruct ocfs2_extent_rec split_rec = *orig_split_rec;\n\tstruct ocfs2_insert_type insert;\n\tstruct ocfs2_extent_block *eb;\n\nleftright:\n\t \n\trec = path_leaf_el(path)->l_recs[split_index];\n\n\trightmost_el = et->et_root_el;\n\n\tdepth = le16_to_cpu(rightmost_el->l_tree_depth);\n\tif (depth) {\n\t\tBUG_ON(!(*last_eb_bh));\n\t\teb = (struct ocfs2_extent_block *) (*last_eb_bh)->b_data;\n\t\trightmost_el = &eb->h_list;\n\t}\n\n\tif (le16_to_cpu(rightmost_el->l_next_free_rec) ==\n\t    le16_to_cpu(rightmost_el->l_count)) {\n\t\tret = ocfs2_grow_tree(handle, et,\n\t\t\t\t      &depth, last_eb_bh, meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tmemset(&insert, 0, sizeof(struct ocfs2_insert_type));\n\tinsert.ins_appending = APPEND_NONE;\n\tinsert.ins_contig = CONTIG_NONE;\n\tinsert.ins_tree_depth = depth;\n\n\tinsert_range = le32_to_cpu(split_rec.e_cpos) +\n\t\tle16_to_cpu(split_rec.e_leaf_clusters);\n\trec_range = le32_to_cpu(rec.e_cpos) +\n\t\tle16_to_cpu(rec.e_leaf_clusters);\n\n\tif (split_rec.e_cpos == rec.e_cpos) {\n\t\tinsert.ins_split = SPLIT_LEFT;\n\t} else if (insert_range == rec_range) {\n\t\tinsert.ins_split = SPLIT_RIGHT;\n\t} else {\n\t\t \n\t\tinsert.ins_split = SPLIT_RIGHT;\n\n\t\tocfs2_make_right_split_rec(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t   &tmprec, insert_range, &rec);\n\n\t\tsplit_rec = tmprec;\n\n\t\tBUG_ON(do_leftright);\n\t\tdo_leftright = 1;\n\t}\n\n\tret = ocfs2_do_insert_extent(handle, et, &split_rec, &insert);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (do_leftright == 1) {\n\t\tu32 cpos;\n\t\tstruct ocfs2_extent_list *el;\n\n\t\tdo_leftright++;\n\t\tsplit_rec = *orig_split_rec;\n\n\t\tocfs2_reinit_path(path, 1);\n\n\t\tcpos = le32_to_cpu(split_rec.e_cpos);\n\t\tret = ocfs2_find_path(et->et_ci, path, cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tel = path_leaf_el(path);\n\t\tsplit_index = ocfs2_search_extent_list(el, cpos);\n\t\tif (split_index == -1) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu has an extent at cpos %u which can no longer be found\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\t    cpos);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t\tgoto leftright;\n\t}\nout:\n\n\treturn ret;\n}\n\nstatic int ocfs2_replace_extent_rec(handle_t *handle,\n\t\t\t\t    struct ocfs2_extent_tree *et,\n\t\t\t\t    struct ocfs2_path *path,\n\t\t\t\t    struct ocfs2_extent_list *el,\n\t\t\t\t    int split_index,\n\t\t\t\t    struct ocfs2_extent_rec *split_rec)\n{\n\tint ret;\n\n\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, path,\n\t\t\t\t\t   path_num_items(path) - 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tel->l_recs[split_index] = *split_rec;\n\n\tocfs2_journal_dirty(handle, path_leaf_bh(path));\nout:\n\treturn ret;\n}\n\n \nint ocfs2_split_extent(handle_t *handle,\n\t\t       struct ocfs2_extent_tree *et,\n\t\t       struct ocfs2_path *path,\n\t\t       int split_index,\n\t\t       struct ocfs2_extent_rec *split_rec,\n\t\t       struct ocfs2_alloc_context *meta_ac,\n\t\t       struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret = 0;\n\tstruct ocfs2_extent_list *el = path_leaf_el(path);\n\tstruct buffer_head *last_eb_bh = NULL;\n\tstruct ocfs2_extent_rec *rec = &el->l_recs[split_index];\n\tstruct ocfs2_merge_ctxt ctxt;\n\n\tif (le32_to_cpu(rec->e_cpos) > le32_to_cpu(split_rec->e_cpos) ||\n\t    ((le32_to_cpu(rec->e_cpos) + le16_to_cpu(rec->e_leaf_clusters)) <\n\t     (le32_to_cpu(split_rec->e_cpos) + le16_to_cpu(split_rec->e_leaf_clusters)))) {\n\t\tret = -EIO;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_figure_merge_contig_type(et, path, el,\n\t\t\t\t\t     split_index,\n\t\t\t\t\t     split_rec,\n\t\t\t\t\t     &ctxt);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t \n\tif (path->p_tree_depth) {\n\t\tret = ocfs2_read_extent_block(et->et_ci,\n\t\t\t\t\t      ocfs2_et_get_last_eb_blk(et),\n\t\t\t\t\t      &last_eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (rec->e_cpos == split_rec->e_cpos &&\n\t    rec->e_leaf_clusters == split_rec->e_leaf_clusters)\n\t\tctxt.c_split_covers_rec = 1;\n\telse\n\t\tctxt.c_split_covers_rec = 0;\n\n\tctxt.c_has_empty_extent = ocfs2_is_empty_extent(&el->l_recs[0]);\n\n\ttrace_ocfs2_split_extent(split_index, ctxt.c_contig_type,\n\t\t\t\t ctxt.c_has_empty_extent,\n\t\t\t\t ctxt.c_split_covers_rec);\n\n\tif (ctxt.c_contig_type == CONTIG_NONE) {\n\t\tif (ctxt.c_split_covers_rec)\n\t\t\tret = ocfs2_replace_extent_rec(handle, et, path, el,\n\t\t\t\t\t\t       split_index, split_rec);\n\t\telse\n\t\t\tret = ocfs2_split_and_insert(handle, et, path,\n\t\t\t\t\t\t     &last_eb_bh, split_index,\n\t\t\t\t\t\t     split_rec, meta_ac);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t} else {\n\t\tret = ocfs2_try_to_merge_extent(handle, et, path,\n\t\t\t\t\t\tsplit_index, split_rec,\n\t\t\t\t\t\tdealloc, &ctxt);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\nout:\n\tbrelse(last_eb_bh);\n\treturn ret;\n}\n\n \nint ocfs2_change_extent_flag(handle_t *handle,\n\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t     u32 cpos, u32 len, u32 phys,\n\t\t\t     struct ocfs2_alloc_context *meta_ac,\n\t\t\t     struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t     int new_flags, int clear_flags)\n{\n\tint ret, index;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(et->et_ci);\n\tu64 start_blkno = ocfs2_clusters_to_blocks(sb, phys);\n\tstruct ocfs2_extent_rec split_rec;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\n\tleft_path = ocfs2_new_path_from_et(et);\n\tif (!left_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, left_path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tel = path_leaf_el(left_path);\n\n\tindex = ocfs2_search_extent_list(el, cpos);\n\tif (index == -1) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Owner %llu has an extent at cpos %u which can no longer be found\\n\",\n\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t    cpos);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\tret = -EIO;\n\trec = &el->l_recs[index];\n\tif (new_flags && (rec->e_flags & new_flags)) {\n\t\tmlog(ML_ERROR, \"Owner %llu tried to set %d flags on an \"\n\t\t     \"extent that already had them\\n\",\n\t\t     (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t     new_flags);\n\t\tgoto out;\n\t}\n\n\tif (clear_flags && !(rec->e_flags & clear_flags)) {\n\t\tmlog(ML_ERROR, \"Owner %llu tried to clear %d flags on an \"\n\t\t     \"extent that didn't have them\\n\",\n\t\t     (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t     clear_flags);\n\t\tgoto out;\n\t}\n\n\tmemset(&split_rec, 0, sizeof(struct ocfs2_extent_rec));\n\tsplit_rec.e_cpos = cpu_to_le32(cpos);\n\tsplit_rec.e_leaf_clusters = cpu_to_le16(len);\n\tsplit_rec.e_blkno = cpu_to_le64(start_blkno);\n\tsplit_rec.e_flags = rec->e_flags;\n\tif (new_flags)\n\t\tsplit_rec.e_flags |= new_flags;\n\tif (clear_flags)\n\t\tsplit_rec.e_flags &= ~clear_flags;\n\n\tret = ocfs2_split_extent(handle, et, left_path,\n\t\t\t\t index, &split_rec, meta_ac,\n\t\t\t\t dealloc);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tocfs2_free_path(left_path);\n\treturn ret;\n\n}\n\n \nint ocfs2_mark_extent_written(struct inode *inode,\n\t\t\t      struct ocfs2_extent_tree *et,\n\t\t\t      handle_t *handle, u32 cpos, u32 len, u32 phys,\n\t\t\t      struct ocfs2_alloc_context *meta_ac,\n\t\t\t      struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret;\n\n\ttrace_ocfs2_mark_extent_written(\n\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\tcpos, len, phys);\n\n\tif (!ocfs2_writes_unwritten_extents(OCFS2_SB(inode->i_sb))) {\n\t\tocfs2_error(inode->i_sb, \"Inode %llu has unwritten extents that are being written to, but the feature bit is not set in the super block\\n\",\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\t \n\tocfs2_et_extent_map_truncate(et, 0);\n\n\tret = ocfs2_change_extent_flag(handle, et, cpos,\n\t\t\t\t       len, phys, meta_ac, dealloc,\n\t\t\t\t       0, OCFS2_EXT_UNWRITTEN);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\treturn ret;\n}\n\nstatic int ocfs2_split_tree(handle_t *handle, struct ocfs2_extent_tree *et,\n\t\t\t    struct ocfs2_path *path,\n\t\t\t    int index, u32 new_range,\n\t\t\t    struct ocfs2_alloc_context *meta_ac)\n{\n\tint ret, depth, credits;\n\tstruct buffer_head *last_eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *rightmost_el, *el;\n\tstruct ocfs2_extent_rec split_rec;\n\tstruct ocfs2_extent_rec *rec;\n\tstruct ocfs2_insert_type insert;\n\n\t \n\tel = path_leaf_el(path);\n\trec = &el->l_recs[index];\n\tocfs2_make_right_split_rec(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t   &split_rec, new_range, rec);\n\n\tdepth = path->p_tree_depth;\n\tif (depth > 0) {\n\t\tret = ocfs2_read_extent_block(et->et_ci,\n\t\t\t\t\t      ocfs2_et_get_last_eb_blk(et),\n\t\t\t\t\t      &last_eb_bh);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) last_eb_bh->b_data;\n\t\trightmost_el = &eb->h_list;\n\t} else\n\t\trightmost_el = path_leaf_el(path);\n\n\tcredits = path->p_tree_depth +\n\t\t  ocfs2_extend_meta_needed(et->et_root_el);\n\tret = ocfs2_extend_trans(handle, credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (le16_to_cpu(rightmost_el->l_next_free_rec) ==\n\t    le16_to_cpu(rightmost_el->l_count)) {\n\t\tret = ocfs2_grow_tree(handle, et, &depth, &last_eb_bh,\n\t\t\t\t      meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tmemset(&insert, 0, sizeof(struct ocfs2_insert_type));\n\tinsert.ins_appending = APPEND_NONE;\n\tinsert.ins_contig = CONTIG_NONE;\n\tinsert.ins_split = SPLIT_RIGHT;\n\tinsert.ins_tree_depth = depth;\n\n\tret = ocfs2_do_insert_extent(handle, et, &split_rec, &insert);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tbrelse(last_eb_bh);\n\treturn ret;\n}\n\nstatic int ocfs2_truncate_rec(handle_t *handle,\n\t\t\t      struct ocfs2_extent_tree *et,\n\t\t\t      struct ocfs2_path *path, int index,\n\t\t\t      struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t      u32 cpos, u32 len)\n{\n\tint ret;\n\tu32 left_cpos, rec_range, trunc_range;\n\tint is_rightmost_tree_rec = 0;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(et->et_ci);\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_extent_list *el = path_leaf_el(path);\n\tstruct ocfs2_extent_rec *rec;\n\tstruct ocfs2_extent_block *eb;\n\n\tif (ocfs2_is_empty_extent(&el->l_recs[0]) && index > 0) {\n\t\t \n\t\tret = ocfs2_extend_rotate_transaction(handle, 0,\n\t\t\t\tjbd2_handle_buffer_credits(handle),\n\t\t\t\tpath);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_rotate_tree_left(handle, et, path, dealloc);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tindex--;\n\t}\n\n\tif (index == (le16_to_cpu(el->l_next_free_rec) - 1) &&\n\t    path->p_tree_depth) {\n\t\t \n\t\teb = (struct ocfs2_extent_block *)path_leaf_bh(path)->b_data;\n\t\tif (eb->h_next_leaf_blk == 0)\n\t\t\tis_rightmost_tree_rec = 1;\n\t}\n\n\trec = &el->l_recs[index];\n\tif (index == 0 && path->p_tree_depth &&\n\t    le32_to_cpu(rec->e_cpos) == cpos) {\n\t\t \n\n\t\tret = ocfs2_find_cpos_for_left_leaf(sb, path, &left_cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (left_cpos && le16_to_cpu(el->l_next_free_rec) > 1) {\n\t\t\tleft_path = ocfs2_new_path_from_path(path);\n\t\t\tif (!left_path) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = ocfs2_find_path(et->et_ci, left_path,\n\t\t\t\t\t      left_cpos);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = ocfs2_extend_rotate_transaction(handle, 0,\n\t\t\t\t\tjbd2_handle_buffer_credits(handle),\n\t\t\t\t\tpath);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_path(et->et_ci, handle, path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_path(et->et_ci, handle, left_path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\trec_range = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);\n\ttrunc_range = cpos + len;\n\n\tif (le32_to_cpu(rec->e_cpos) == cpos && rec_range == trunc_range) {\n\t\tint next_free;\n\n\t\tmemset(rec, 0, sizeof(*rec));\n\t\tocfs2_cleanup_merge(el, index);\n\n\t\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\t\tif (is_rightmost_tree_rec && next_free > 1) {\n\t\t\t \n\t\t\trec = &el->l_recs[next_free - 1];\n\t\t\tocfs2_adjust_rightmost_records(handle, et, path,\n\t\t\t\t\t\t       rec);\n\t\t}\n\t} else if (le32_to_cpu(rec->e_cpos) == cpos) {\n\t\t \n\t\tle32_add_cpu(&rec->e_cpos, len);\n\t\tle64_add_cpu(&rec->e_blkno, ocfs2_clusters_to_blocks(sb, len));\n\t\tle16_add_cpu(&rec->e_leaf_clusters, -len);\n\t} else if (rec_range == trunc_range) {\n\t\t \n\t\tle16_add_cpu(&rec->e_leaf_clusters, -len);\n\t\tif (is_rightmost_tree_rec)\n\t\t\tocfs2_adjust_rightmost_records(handle, et, path, rec);\n\t} else {\n\t\t \n\t\tmlog(ML_ERROR, \"Owner %llu: Invalid record truncate: (%u, %u) \"\n\t\t     \"(%u, %u)\\n\",\n\t\t     (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t     le32_to_cpu(rec->e_cpos),\n\t\t     le16_to_cpu(rec->e_leaf_clusters), cpos, len);\n\t\tBUG();\n\t}\n\n\tif (left_path) {\n\t\tint subtree_index;\n\n\t\tsubtree_index = ocfs2_find_subtree_root(et, left_path, path);\n\t\tocfs2_complete_edge_insert(handle, left_path, path,\n\t\t\t\t\t   subtree_index);\n\t}\n\n\tocfs2_journal_dirty(handle, path_leaf_bh(path));\n\n\tret = ocfs2_rotate_tree_left(handle, et, path, dealloc);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tocfs2_free_path(left_path);\n\treturn ret;\n}\n\nint ocfs2_remove_extent(handle_t *handle,\n\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\tu32 cpos, u32 len,\n\t\t\tstruct ocfs2_alloc_context *meta_ac,\n\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret, index;\n\tu32 rec_range, trunc_range;\n\tstruct ocfs2_extent_rec *rec;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_path *path = NULL;\n\n\t \n\tocfs2_et_extent_map_truncate(et, 0);\n\n\tpath = ocfs2_new_path_from_et(et);\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tel = path_leaf_el(path);\n\tindex = ocfs2_search_extent_list(el, cpos);\n\tif (index == -1) {\n\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t    \"Owner %llu has an extent at cpos %u which can no longer be found\\n\",\n\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t    cpos);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\t \n\trec = &el->l_recs[index];\n\trec_range = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);\n\ttrunc_range = cpos + len;\n\n\tBUG_ON(cpos < le32_to_cpu(rec->e_cpos) || trunc_range > rec_range);\n\n\ttrace_ocfs2_remove_extent(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\tcpos, len, index, le32_to_cpu(rec->e_cpos),\n\t\tocfs2_rec_clusters(el, rec));\n\n\tif (le32_to_cpu(rec->e_cpos) == cpos || rec_range == trunc_range) {\n\t\tret = ocfs2_truncate_rec(handle, et, path, index, dealloc,\n\t\t\t\t\t cpos, len);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tret = ocfs2_split_tree(handle, et, path, index,\n\t\t\t\t       trunc_range, meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tocfs2_reinit_path(path, 1);\n\n\t\tret = ocfs2_find_path(et->et_ci, path, cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tel = path_leaf_el(path);\n\t\tindex = ocfs2_search_extent_list(el, cpos);\n\t\tif (index == -1) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu: split at cpos %u lost record\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\t    cpos);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\trec = &el->l_recs[index];\n\t\trec_range = le32_to_cpu(rec->e_cpos) +\n\t\t\tocfs2_rec_clusters(el, rec);\n\t\tif (rec_range != trunc_range) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu: error after split at cpos %u trunc len %u, existing record is (%u,%u)\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\t    cpos, len, le32_to_cpu(rec->e_cpos),\n\t\t\t\t    ocfs2_rec_clusters(el, rec));\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_truncate_rec(handle, et, path, index, dealloc,\n\t\t\t\t\t cpos, len);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\nout:\n\tocfs2_free_path(path);\n\treturn ret;\n}\n\n \nstatic int ocfs2_reserve_blocks_for_rec_trunc(struct inode *inode,\n\t\t\t\t\t      struct ocfs2_extent_tree *et,\n\t\t\t\t\t      u32 extents_to_split,\n\t\t\t\t\t      struct ocfs2_alloc_context **ac,\n\t\t\t\t\t      int extra_blocks)\n{\n\tint ret = 0, num_free_extents;\n\tunsigned int max_recs_needed = 2 * extents_to_split;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\t*ac = NULL;\n\n\tnum_free_extents = ocfs2_num_free_extents(et);\n\tif (num_free_extents < 0) {\n\t\tret = num_free_extents;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (!num_free_extents ||\n\t    (ocfs2_sparse_alloc(osb) && num_free_extents < max_recs_needed))\n\t\textra_blocks += ocfs2_extend_meta_needed(et->et_root_el);\n\n\tif (extra_blocks) {\n\t\tret = ocfs2_reserve_new_metadata_blocks(osb, extra_blocks, ac);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -ENOSPC)\n\t\t\t\tmlog_errno(ret);\n\t\t}\n\t}\n\nout:\n\tif (ret) {\n\t\tif (*ac) {\n\t\t\tocfs2_free_alloc_context(*ac);\n\t\t\t*ac = NULL;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint ocfs2_remove_btree_range(struct inode *inode,\n\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t     u32 cpos, u32 phys_cpos, u32 len, int flags,\n\t\t\t     struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t     u64 refcount_loc, bool refcount_tree_locked)\n{\n\tint ret, credits = 0, extra_blocks = 0;\n\tu64 phys_blkno = ocfs2_clusters_to_blocks(inode->i_sb, phys_cpos);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\thandle_t *handle;\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\tstruct ocfs2_refcount_tree *ref_tree = NULL;\n\n\tif ((flags & OCFS2_EXT_REFCOUNTED) && len) {\n\t\tBUG_ON(!ocfs2_is_refcount_inode(inode));\n\n\t\tif (!refcount_tree_locked) {\n\t\t\tret = ocfs2_lock_refcount_tree(osb, refcount_loc, 1,\n\t\t\t\t\t\t       &ref_tree, NULL);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\n\t\tret = ocfs2_prepare_refcount_change_for_del(inode,\n\t\t\t\t\t\t\t    refcount_loc,\n\t\t\t\t\t\t\t    phys_blkno,\n\t\t\t\t\t\t\t    len,\n\t\t\t\t\t\t\t    &credits,\n\t\t\t\t\t\t\t    &extra_blocks);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tret = ocfs2_reserve_blocks_for_rec_trunc(inode, et, 1, &meta_ac,\n\t\t\t\t\t\t extra_blocks);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto bail;\n\t}\n\n\tinode_lock(tl_inode);\n\n\tif (ocfs2_truncate_log_needs_flush(osb)) {\n\t\tret = __ocfs2_flush_truncate_log(osb);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\thandle = ocfs2_start_trans(osb,\n\t\t\tocfs2_remove_extent_credits(osb->sb) + credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tdquot_free_space_nodirty(inode,\n\t\t\t\t  ocfs2_clusters_to_bytes(inode->i_sb, len));\n\n\tret = ocfs2_remove_extent(handle, et, cpos, len, meta_ac, dealloc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tocfs2_et_update_clusters(et, -len);\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\n\tocfs2_journal_dirty(handle, et->et_root_bh);\n\n\tif (phys_blkno) {\n\t\tif (flags & OCFS2_EXT_REFCOUNTED)\n\t\t\tret = ocfs2_decrease_refcount(inode, handle,\n\t\t\t\t\tocfs2_blocks_to_clusters(osb->sb,\n\t\t\t\t\t\t\t\t phys_blkno),\n\t\t\t\t\tlen, meta_ac,\n\t\t\t\t\tdealloc, 1);\n\t\telse\n\t\t\tret = ocfs2_truncate_log_append(osb, handle,\n\t\t\t\t\t\t\tphys_blkno, len);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\n\t}\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\nout:\n\tinode_unlock(tl_inode);\nbail:\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\n\tif (ref_tree)\n\t\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\n\treturn ret;\n}\n\nint ocfs2_truncate_log_needs_flush(struct ocfs2_super *osb)\n{\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\ttl = &di->id2.i_dealloc;\n\n\tmlog_bug_on_msg(le16_to_cpu(tl->tl_used) > le16_to_cpu(tl->tl_count),\n\t\t\t\"slot %d, invalid truncate log parameters: used = \"\n\t\t\t\"%u, count = %u\\n\", osb->slot_num,\n\t\t\tle16_to_cpu(tl->tl_used), le16_to_cpu(tl->tl_count));\n\treturn le16_to_cpu(tl->tl_used) == le16_to_cpu(tl->tl_count);\n}\n\nstatic int ocfs2_truncate_log_can_coalesce(struct ocfs2_truncate_log *tl,\n\t\t\t\t\t   unsigned int new_start)\n{\n\tunsigned int tail_index;\n\tunsigned int current_tail;\n\n\t \n\tif (!le16_to_cpu(tl->tl_used))\n\t\treturn 0;\n\n\ttail_index = le16_to_cpu(tl->tl_used) - 1;\n\tcurrent_tail = le32_to_cpu(tl->tl_recs[tail_index].t_start);\n\tcurrent_tail += le32_to_cpu(tl->tl_recs[tail_index].t_clusters);\n\n\treturn current_tail == new_start;\n}\n\nint ocfs2_truncate_log_append(struct ocfs2_super *osb,\n\t\t\t      handle_t *handle,\n\t\t\t      u64 start_blk,\n\t\t\t      unsigned int num_clusters)\n{\n\tint status, index;\n\tunsigned int start_cluster, tl_count;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tBUG_ON(inode_trylock(tl_inode));\n\n\tstart_cluster = ocfs2_blocks_to_clusters(osb->sb, start_blk);\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\n\t \n\tBUG_ON(!OCFS2_IS_VALID_DINODE(di));\n\n\ttl = &di->id2.i_dealloc;\n\ttl_count = le16_to_cpu(tl->tl_count);\n\tmlog_bug_on_msg(tl_count > ocfs2_truncate_recs_per_inode(osb->sb) ||\n\t\t\ttl_count == 0,\n\t\t\t\"Truncate record count on #%llu invalid \"\n\t\t\t\"wanted %u, actual %u\\n\",\n\t\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\t\tocfs2_truncate_recs_per_inode(osb->sb),\n\t\t\tle16_to_cpu(tl->tl_count));\n\n\t \n\tindex = le16_to_cpu(tl->tl_used);\n\tif (index >= tl_count) {\n\t\tstatus = -ENOSPC;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(tl_inode), tl_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_truncate_log_append(\n\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno, index,\n\t\tstart_cluster, num_clusters);\n\tif (ocfs2_truncate_log_can_coalesce(tl, start_cluster)) {\n\t\t \n\t\tindex--;\n\n\t\tnum_clusters += le32_to_cpu(tl->tl_recs[index].t_clusters);\n\t\ttrace_ocfs2_truncate_log_append(\n\t\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\t\tindex, le32_to_cpu(tl->tl_recs[index].t_start),\n\t\t\tnum_clusters);\n\t} else {\n\t\ttl->tl_recs[index].t_start = cpu_to_le32(start_cluster);\n\t\ttl->tl_used = cpu_to_le16(index + 1);\n\t}\n\ttl->tl_recs[index].t_clusters = cpu_to_le32(num_clusters);\n\n\tocfs2_journal_dirty(handle, tl_bh);\n\n\tosb->truncated_clusters += num_clusters;\nbail:\n\treturn status;\n}\n\nstatic int ocfs2_replay_truncate_records(struct ocfs2_super *osb,\n\t\t\t\t\t struct inode *data_alloc_inode,\n\t\t\t\t\t struct buffer_head *data_alloc_bh)\n{\n\tint status = 0;\n\tint i;\n\tunsigned int num_clusters;\n\tu64 start_blk;\n\tstruct ocfs2_truncate_rec rec;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\thandle_t *handle;\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\ttl = &di->id2.i_dealloc;\n\ti = le16_to_cpu(tl->tl_used) - 1;\n\twhile (i >= 0) {\n\t\thandle = ocfs2_start_trans(osb, OCFS2_TRUNCATE_LOG_FLUSH_ONE_REC);\n\t\tif (IS_ERR(handle)) {\n\t\t\tstatus = PTR_ERR(handle);\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\t \n\t\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(tl_inode), tl_bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (status < 0) {\n\t\t\tocfs2_commit_trans(osb, handle);\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\ttl->tl_used = cpu_to_le16(i);\n\n\t\tocfs2_journal_dirty(handle, tl_bh);\n\n\t\trec = tl->tl_recs[i];\n\t\tstart_blk = ocfs2_clusters_to_blocks(data_alloc_inode->i_sb,\n\t\t\t\t\t\t    le32_to_cpu(rec.t_start));\n\t\tnum_clusters = le32_to_cpu(rec.t_clusters);\n\n\t\t \n\t\tif (start_blk) {\n\t\t\ttrace_ocfs2_replay_truncate_records(\n\t\t\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\t\t\ti, le32_to_cpu(rec.t_start), num_clusters);\n\n\t\t\tstatus = ocfs2_free_clusters(handle, data_alloc_inode,\n\t\t\t\t\t\t     data_alloc_bh, start_blk,\n\t\t\t\t\t\t     num_clusters);\n\t\t\tif (status < 0) {\n\t\t\t\tocfs2_commit_trans(osb, handle);\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\n\t\tocfs2_commit_trans(osb, handle);\n\t\ti--;\n\t}\n\n\tosb->truncated_clusters = 0;\n\nbail:\n\treturn status;\n}\n\n \nint __ocfs2_flush_truncate_log(struct ocfs2_super *osb)\n{\n\tint status;\n\tunsigned int num_to_flush;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct inode *data_alloc_inode = NULL;\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct buffer_head *data_alloc_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(inode_trylock(tl_inode));\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\n\t \n\tBUG_ON(!OCFS2_IS_VALID_DINODE(di));\n\n\ttl = &di->id2.i_dealloc;\n\tnum_to_flush = le16_to_cpu(tl->tl_used);\n\ttrace_ocfs2_flush_truncate_log(\n\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\tnum_to_flush);\n\tif (!num_to_flush) {\n\t\tstatus = 0;\n\t\tgoto out;\n\t}\n\n\t \n\tjbd2_journal_lock_updates(journal->j_journal);\n\tstatus = jbd2_journal_flush(journal->j_journal, 0);\n\tjbd2_journal_unlock_updates(journal->j_journal);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tdata_alloc_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t       GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t\t       OCFS2_INVALID_SLOT);\n\tif (!data_alloc_inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Could not get bitmap inode!\\n\");\n\t\tgoto out;\n\t}\n\n\tinode_lock(data_alloc_inode);\n\n\tstatus = ocfs2_inode_lock(data_alloc_inode, &data_alloc_bh, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_mutex;\n\t}\n\n\tstatus = ocfs2_replay_truncate_records(osb, data_alloc_inode,\n\t\t\t\t\t       data_alloc_bh);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\tbrelse(data_alloc_bh);\n\tocfs2_inode_unlock(data_alloc_inode, 1);\n\nout_mutex:\n\tinode_unlock(data_alloc_inode);\n\tiput(data_alloc_inode);\n\nout:\n\treturn status;\n}\n\nint ocfs2_flush_truncate_log(struct ocfs2_super *osb)\n{\n\tint status;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\n\tinode_lock(tl_inode);\n\tstatus = __ocfs2_flush_truncate_log(osb);\n\tinode_unlock(tl_inode);\n\n\treturn status;\n}\n\nstatic void ocfs2_truncate_log_worker(struct work_struct *work)\n{\n\tint status;\n\tstruct ocfs2_super *osb =\n\t\tcontainer_of(work, struct ocfs2_super,\n\t\t\t     osb_truncate_log_wq.work);\n\n\tstatus = ocfs2_flush_truncate_log(osb);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\telse\n\t\tocfs2_init_steal_slots(osb);\n}\n\n#define OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL (2 * HZ)\nvoid ocfs2_schedule_truncate_log_flush(struct ocfs2_super *osb,\n\t\t\t\t       int cancel)\n{\n\tif (osb->osb_tl_inode &&\n\t\t\tatomic_read(&osb->osb_tl_disable) == 0) {\n\t\t \n\t\tif (cancel)\n\t\t\tcancel_delayed_work(&osb->osb_truncate_log_wq);\n\n\t\tqueue_delayed_work(osb->ocfs2_wq, &osb->osb_truncate_log_wq,\n\t\t\t\t   OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL);\n\t}\n}\n\n \nint ocfs2_try_to_free_truncate_log(struct ocfs2_super *osb,\n\t\t\t\t\tunsigned int needed)\n{\n\ttid_t target;\n\tint ret = 0;\n\tunsigned int truncated_clusters;\n\n\tinode_lock(osb->osb_tl_inode);\n\ttruncated_clusters = osb->truncated_clusters;\n\tinode_unlock(osb->osb_tl_inode);\n\n\t \n\tif (truncated_clusters < needed)\n\t\tgoto out;\n\n\tret = ocfs2_flush_truncate_log(osb);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (jbd2_journal_start_commit(osb->journal->j_journal, &target)) {\n\t\tjbd2_log_wait_commit(osb->journal->j_journal, target);\n\t\tret = 1;\n\t}\nout:\n\treturn ret;\n}\n\nstatic int ocfs2_get_truncate_log_info(struct ocfs2_super *osb,\n\t\t\t\t       int slot_num,\n\t\t\t\t       struct inode **tl_inode,\n\t\t\t\t       struct buffer_head **tl_bh)\n{\n\tint status;\n\tstruct inode *inode = NULL;\n\tstruct buffer_head *bh = NULL;\n\n\tinode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t   TRUNCATE_LOG_SYSTEM_INODE,\n\t\t\t\t\t   slot_num);\n\tif (!inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Could not get load truncate log inode!\\n\");\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_read_inode_block(inode, &bh);\n\tif (status < 0) {\n\t\tiput(inode);\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t*tl_inode = inode;\n\t*tl_bh    = bh;\nbail:\n\treturn status;\n}\n\n \nint ocfs2_begin_truncate_log_recovery(struct ocfs2_super *osb,\n\t\t\t\t      int slot_num,\n\t\t\t\t      struct ocfs2_dinode **tl_copy)\n{\n\tint status;\n\tstruct inode *tl_inode = NULL;\n\tstruct buffer_head *tl_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\t*tl_copy = NULL;\n\n\ttrace_ocfs2_begin_truncate_log_recovery(slot_num);\n\n\tstatus = ocfs2_get_truncate_log_info(osb, slot_num, &tl_inode, &tl_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\n\t \n\tBUG_ON(!OCFS2_IS_VALID_DINODE(di));\n\n\ttl = &di->id2.i_dealloc;\n\tif (le16_to_cpu(tl->tl_used)) {\n\t\ttrace_ocfs2_truncate_log_recovery_num(le16_to_cpu(tl->tl_used));\n\n\t\t \n\t\t*tl_copy = kmemdup(tl_bh->b_data, tl_bh->b_size, GFP_KERNEL);\n\t\tif (!(*tl_copy)) {\n\t\t\tstatus = -ENOMEM;\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\t \n\t\ttl->tl_used = 0;\n\n\t\tocfs2_compute_meta_ecc(osb->sb, tl_bh->b_data, &di->i_check);\n\t\tstatus = ocfs2_write_block(osb, tl_bh, INODE_CACHE(tl_inode));\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\nbail:\n\tiput(tl_inode);\n\tbrelse(tl_bh);\n\n\tif (status < 0) {\n\t\tkfree(*tl_copy);\n\t\t*tl_copy = NULL;\n\t\tmlog_errno(status);\n\t}\n\n\treturn status;\n}\n\nint ocfs2_complete_truncate_log_recovery(struct ocfs2_super *osb,\n\t\t\t\t\t struct ocfs2_dinode *tl_copy)\n{\n\tint status = 0;\n\tint i;\n\tunsigned int clusters, num_recs, start_cluster;\n\tu64 start_blk;\n\thandle_t *handle;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct ocfs2_truncate_log *tl;\n\n\tif (OCFS2_I(tl_inode)->ip_blkno == le64_to_cpu(tl_copy->i_blkno)) {\n\t\tmlog(ML_ERROR, \"Asked to recover my own truncate log!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttl = &tl_copy->id2.i_dealloc;\n\tnum_recs = le16_to_cpu(tl->tl_used);\n\ttrace_ocfs2_complete_truncate_log_recovery(\n\t\t(unsigned long long)le64_to_cpu(tl_copy->i_blkno),\n\t\tnum_recs);\n\n\tinode_lock(tl_inode);\n\tfor(i = 0; i < num_recs; i++) {\n\t\tif (ocfs2_truncate_log_needs_flush(osb)) {\n\t\t\tstatus = __ocfs2_flush_truncate_log(osb);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail_up;\n\t\t\t}\n\t\t}\n\n\t\thandle = ocfs2_start_trans(osb, OCFS2_TRUNCATE_LOG_UPDATE);\n\t\tif (IS_ERR(handle)) {\n\t\t\tstatus = PTR_ERR(handle);\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail_up;\n\t\t}\n\n\t\tclusters = le32_to_cpu(tl->tl_recs[i].t_clusters);\n\t\tstart_cluster = le32_to_cpu(tl->tl_recs[i].t_start);\n\t\tstart_blk = ocfs2_clusters_to_blocks(osb->sb, start_cluster);\n\n\t\tstatus = ocfs2_truncate_log_append(osb, handle,\n\t\t\t\t\t\t   start_blk, clusters);\n\t\tocfs2_commit_trans(osb, handle);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail_up;\n\t\t}\n\t}\n\nbail_up:\n\tinode_unlock(tl_inode);\n\n\treturn status;\n}\n\nvoid ocfs2_truncate_log_shutdown(struct ocfs2_super *osb)\n{\n\tint status;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\n\tatomic_set(&osb->osb_tl_disable, 1);\n\n\tif (tl_inode) {\n\t\tcancel_delayed_work(&osb->osb_truncate_log_wq);\n\t\tflush_workqueue(osb->ocfs2_wq);\n\n\t\tstatus = ocfs2_flush_truncate_log(osb);\n\t\tif (status < 0)\n\t\t\tmlog_errno(status);\n\n\t\tbrelse(osb->osb_tl_bh);\n\t\tiput(osb->osb_tl_inode);\n\t}\n}\n\nint ocfs2_truncate_log_init(struct ocfs2_super *osb)\n{\n\tint status;\n\tstruct inode *tl_inode = NULL;\n\tstruct buffer_head *tl_bh = NULL;\n\n\tstatus = ocfs2_get_truncate_log_info(osb,\n\t\t\t\t\t     osb->slot_num,\n\t\t\t\t\t     &tl_inode,\n\t\t\t\t\t     &tl_bh);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\t \n\tINIT_DELAYED_WORK(&osb->osb_truncate_log_wq,\n\t\t\t  ocfs2_truncate_log_worker);\n\tatomic_set(&osb->osb_tl_disable, 0);\n\tosb->osb_tl_bh    = tl_bh;\n\tosb->osb_tl_inode = tl_inode;\n\n\treturn status;\n}\n\n \n\n \nstruct ocfs2_cached_block_free {\n\tstruct ocfs2_cached_block_free\t\t*free_next;\n\tu64\t\t\t\t\tfree_bg;\n\tu64\t\t\t\t\tfree_blk;\n\tunsigned int\t\t\t\tfree_bit;\n};\n\nstruct ocfs2_per_slot_free_list {\n\tstruct ocfs2_per_slot_free_list\t\t*f_next_suballocator;\n\tint\t\t\t\t\tf_inode_type;\n\tint\t\t\t\t\tf_slot;\n\tstruct ocfs2_cached_block_free\t\t*f_first;\n};\n\nstatic int ocfs2_free_cached_blocks(struct ocfs2_super *osb,\n\t\t\t\t    int sysfile_type,\n\t\t\t\t    int slot,\n\t\t\t\t    struct ocfs2_cached_block_free *head)\n{\n\tint ret;\n\tu64 bg_blkno;\n\thandle_t *handle;\n\tstruct inode *inode;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_cached_block_free *tmp;\n\n\tinode = ocfs2_get_system_file_inode(osb, sysfile_type, slot);\n\tif (!inode) {\n\t\tret = -EINVAL;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tinode_lock(inode);\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_mutex;\n\t}\n\n\twhile (head) {\n\t\tif (head->free_bg)\n\t\t\tbg_blkno = head->free_bg;\n\t\telse\n\t\t\tbg_blkno = ocfs2_which_suballoc_group(head->free_blk,\n\t\t\t\t\t\t\t      head->free_bit);\n\t\thandle = ocfs2_start_trans(osb, OCFS2_SUBALLOC_FREE);\n\t\tif (IS_ERR(handle)) {\n\t\t\tret = PTR_ERR(handle);\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\ttrace_ocfs2_free_cached_blocks(\n\t\t     (unsigned long long)head->free_blk, head->free_bit);\n\n\t\tret = ocfs2_free_suballoc_bits(handle, inode, di_bh,\n\t\t\t\t\t       head->free_bit, bg_blkno, 1);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\n\t\tocfs2_commit_trans(osb, handle);\n\n\t\ttmp = head;\n\t\thead = head->free_next;\n\t\tkfree(tmp);\n\t}\n\nout_unlock:\n\tocfs2_inode_unlock(inode, 1);\n\tbrelse(di_bh);\nout_mutex:\n\tinode_unlock(inode);\n\tiput(inode);\nout:\n\twhile(head) {\n\t\t \n\t\ttmp = head;\n\t\thead = head->free_next;\n\t\tkfree(tmp);\n\t}\n\n\treturn ret;\n}\n\nint ocfs2_cache_cluster_dealloc(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\tu64 blkno, unsigned int bit)\n{\n\tint ret = 0;\n\tstruct ocfs2_cached_block_free *item;\n\n\titem = kzalloc(sizeof(*item), GFP_NOFS);\n\tif (item == NULL) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\ttrace_ocfs2_cache_cluster_dealloc((unsigned long long)blkno, bit);\n\n\titem->free_blk = blkno;\n\titem->free_bit = bit;\n\titem->free_next = ctxt->c_global_allocator;\n\n\tctxt->c_global_allocator = item;\n\treturn ret;\n}\n\nstatic int ocfs2_free_cached_clusters(struct ocfs2_super *osb,\n\t\t\t\t      struct ocfs2_cached_block_free *head)\n{\n\tstruct ocfs2_cached_block_free *tmp;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\thandle_t *handle;\n\tint ret = 0;\n\n\tinode_lock(tl_inode);\n\n\twhile (head) {\n\t\tif (ocfs2_truncate_log_needs_flush(osb)) {\n\t\t\tret = __ocfs2_flush_truncate_log(osb);\n\t\t\tif (ret < 0) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\thandle = ocfs2_start_trans(osb, OCFS2_TRUNCATE_LOG_UPDATE);\n\t\tif (IS_ERR(handle)) {\n\t\t\tret = PTR_ERR(handle);\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = ocfs2_truncate_log_append(osb, handle, head->free_blk,\n\t\t\t\t\t\thead->free_bit);\n\n\t\tocfs2_commit_trans(osb, handle);\n\t\ttmp = head;\n\t\thead = head->free_next;\n\t\tkfree(tmp);\n\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tinode_unlock(tl_inode);\n\n\twhile (head) {\n\t\t \n\t\ttmp = head;\n\t\thead = head->free_next;\n\t\tkfree(tmp);\n\t}\n\n\treturn ret;\n}\n\nint ocfs2_run_deallocs(struct ocfs2_super *osb,\n\t\t       struct ocfs2_cached_dealloc_ctxt *ctxt)\n{\n\tint ret = 0, ret2;\n\tstruct ocfs2_per_slot_free_list *fl;\n\n\tif (!ctxt)\n\t\treturn 0;\n\n\twhile (ctxt->c_first_suballocator) {\n\t\tfl = ctxt->c_first_suballocator;\n\n\t\tif (fl->f_first) {\n\t\t\ttrace_ocfs2_run_deallocs(fl->f_inode_type,\n\t\t\t\t\t\t fl->f_slot);\n\t\t\tret2 = ocfs2_free_cached_blocks(osb,\n\t\t\t\t\t\t\tfl->f_inode_type,\n\t\t\t\t\t\t\tfl->f_slot,\n\t\t\t\t\t\t\tfl->f_first);\n\t\t\tif (ret2)\n\t\t\t\tmlog_errno(ret2);\n\t\t\tif (!ret)\n\t\t\t\tret = ret2;\n\t\t}\n\n\t\tctxt->c_first_suballocator = fl->f_next_suballocator;\n\t\tkfree(fl);\n\t}\n\n\tif (ctxt->c_global_allocator) {\n\t\tret2 = ocfs2_free_cached_clusters(osb,\n\t\t\t\t\t\t  ctxt->c_global_allocator);\n\t\tif (ret2)\n\t\t\tmlog_errno(ret2);\n\t\tif (!ret)\n\t\t\tret = ret2;\n\n\t\tctxt->c_global_allocator = NULL;\n\t}\n\n\treturn ret;\n}\n\nstatic struct ocfs2_per_slot_free_list *\nocfs2_find_per_slot_free_list(int type,\n\t\t\t      int slot,\n\t\t\t      struct ocfs2_cached_dealloc_ctxt *ctxt)\n{\n\tstruct ocfs2_per_slot_free_list *fl = ctxt->c_first_suballocator;\n\n\twhile (fl) {\n\t\tif (fl->f_inode_type == type && fl->f_slot == slot)\n\t\t\treturn fl;\n\n\t\tfl = fl->f_next_suballocator;\n\t}\n\n\tfl = kmalloc(sizeof(*fl), GFP_NOFS);\n\tif (fl) {\n\t\tfl->f_inode_type = type;\n\t\tfl->f_slot = slot;\n\t\tfl->f_first = NULL;\n\t\tfl->f_next_suballocator = ctxt->c_first_suballocator;\n\n\t\tctxt->c_first_suballocator = fl;\n\t}\n\treturn fl;\n}\n\nstatic struct ocfs2_per_slot_free_list *\nocfs2_find_preferred_free_list(int type,\n\t\t\t       int preferred_slot,\n\t\t\t       int *real_slot,\n\t\t\t       struct ocfs2_cached_dealloc_ctxt *ctxt)\n{\n\tstruct ocfs2_per_slot_free_list *fl = ctxt->c_first_suballocator;\n\n\twhile (fl) {\n\t\tif (fl->f_inode_type == type && fl->f_slot == preferred_slot) {\n\t\t\t*real_slot = fl->f_slot;\n\t\t\treturn fl;\n\t\t}\n\n\t\tfl = fl->f_next_suballocator;\n\t}\n\n\t \n\tfl = ctxt->c_first_suballocator;\n\t*real_slot = fl->f_slot;\n\n\treturn fl;\n}\n\n \nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_per_slot_free_list *fl = NULL;\n\n\tif (!et->et_dealloc)\n\t\treturn 1;\n\n\tfl = et->et_dealloc->c_first_suballocator;\n\tif (!fl)\n\t\treturn 1;\n\n\tif (!fl->f_first)\n\t\treturn 1;\n\n\treturn 0;\n}\n\n \nstatic int ocfs2_reuse_blk_from_dealloc(handle_t *handle,\n\t\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\t\tstruct buffer_head **new_eb_bh,\n\t\t\t\t\tint blk_wanted, int *blk_given)\n{\n\tint i, status = 0, real_slot;\n\tstruct ocfs2_cached_dealloc_ctxt *dealloc;\n\tstruct ocfs2_per_slot_free_list *fl;\n\tstruct ocfs2_cached_block_free *bf;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_super *osb =\n\t\tOCFS2_SB(ocfs2_metadata_cache_get_super(et->et_ci));\n\n\t*blk_given = 0;\n\n\t \n\tdealloc = et->et_dealloc;\n\tif (!dealloc)\n\t\tgoto bail;\n\n\tfor (i = 0; i < blk_wanted; i++) {\n\t\t \n\t\tfl = ocfs2_find_preferred_free_list(EXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t\t    osb->slot_num, &real_slot,\n\t\t\t\t\t\t    dealloc);\n\t\t \n\t\tif (!fl) {\n\t\t\tstatus = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tbf = fl->f_first;\n\t\tfl->f_first = bf->free_next;\n\n\t\tnew_eb_bh[i] = sb_getblk(osb->sb, bf->free_blk);\n\t\tif (new_eb_bh[i] == NULL) {\n\t\t\tstatus = -ENOMEM;\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tmlog(0, \"Reusing block(%llu) from \"\n\t\t     \"dealloc(local slot:%d, real slot:%d)\\n\",\n\t\t     bf->free_blk, osb->slot_num, real_slot);\n\n\t\tocfs2_set_new_buffer_uptodate(et->et_ci, new_eb_bh[i]);\n\n\t\tstatus = ocfs2_journal_access_eb(handle, et->et_ci,\n\t\t\t\t\t\t new_eb_bh[i],\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tmemset(new_eb_bh[i]->b_data, 0, osb->sb->s_blocksize);\n\t\teb = (struct ocfs2_extent_block *) new_eb_bh[i]->b_data;\n\n\t\t \n\t\tstrcpy(eb->h_signature, OCFS2_EXTENT_BLOCK_SIGNATURE);\n\t\teb->h_blkno = cpu_to_le64(bf->free_blk);\n\t\teb->h_fs_generation = cpu_to_le32(osb->fs_generation);\n\t\teb->h_suballoc_slot = cpu_to_le16(real_slot);\n\t\teb->h_suballoc_loc = cpu_to_le64(bf->free_bg);\n\t\teb->h_suballoc_bit = cpu_to_le16(bf->free_bit);\n\t\teb->h_list.l_count =\n\t\t\tcpu_to_le16(ocfs2_extent_recs_per_eb(osb->sb));\n\n\t\t \n\t\tocfs2_journal_dirty(handle, new_eb_bh[i]);\n\n\t\tif (!fl->f_first) {\n\t\t\tdealloc->c_first_suballocator = fl->f_next_suballocator;\n\t\t\tkfree(fl);\n\t\t}\n\t\tkfree(bf);\n\t}\n\n\t*blk_given = i;\n\nbail:\n\tif (unlikely(status < 0)) {\n\t\tfor (i = 0; i < blk_wanted; i++)\n\t\t\tbrelse(new_eb_bh[i]);\n\t}\n\n\treturn status;\n}\n\nint ocfs2_cache_block_dealloc(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t      int type, int slot, u64 suballoc,\n\t\t\t      u64 blkno, unsigned int bit)\n{\n\tint ret;\n\tstruct ocfs2_per_slot_free_list *fl;\n\tstruct ocfs2_cached_block_free *item;\n\n\tfl = ocfs2_find_per_slot_free_list(type, slot, ctxt);\n\tif (fl == NULL) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\titem = kzalloc(sizeof(*item), GFP_NOFS);\n\tif (item == NULL) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_cache_block_dealloc(type, slot,\n\t\t\t\t\t(unsigned long long)suballoc,\n\t\t\t\t\t(unsigned long long)blkno, bit);\n\n\titem->free_bg = suballoc;\n\titem->free_blk = blkno;\n\titem->free_bit = bit;\n\titem->free_next = fl->f_first;\n\n\tfl->f_first = item;\n\n\tret = 0;\nout:\n\treturn ret;\n}\n\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb)\n{\n\treturn ocfs2_cache_block_dealloc(ctxt, EXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t le16_to_cpu(eb->h_suballoc_slot),\n\t\t\t\t\t le64_to_cpu(eb->h_suballoc_loc),\n\t\t\t\t\t le64_to_cpu(eb->h_blkno),\n\t\t\t\t\t le16_to_cpu(eb->h_suballoc_bit));\n}\n\nstatic int ocfs2_zero_func(handle_t *handle, struct buffer_head *bh)\n{\n\tset_buffer_uptodate(bh);\n\tmark_buffer_dirty(bh);\n\treturn 0;\n}\n\nvoid ocfs2_map_and_dirty_page(struct inode *inode, handle_t *handle,\n\t\t\t      unsigned int from, unsigned int to,\n\t\t\t      struct page *page, int zero, u64 *phys)\n{\n\tint ret, partial = 0;\n\tloff_t start_byte = ((loff_t)page->index << PAGE_SHIFT) + from;\n\tloff_t length = to - from;\n\n\tret = ocfs2_map_page_blocks(page, phys, inode, from, to, 0);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\tif (zero)\n\t\tzero_user_segment(page, from, to);\n\n\t \n\tret = walk_page_buffers(handle, page_buffers(page),\n\t\t\t\tfrom, to, &partial,\n\t\t\t\tocfs2_zero_func);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\telse if (ocfs2_should_order_data(inode)) {\n\t\tret = ocfs2_jbd2_inode_add_write(handle, inode,\n\t\t\t\t\t\t start_byte, length);\n\t\tif (ret < 0)\n\t\t\tmlog_errno(ret);\n\t}\n\n\tif (!partial)\n\t\tSetPageUptodate(page);\n\n\tflush_dcache_page(page);\n}\n\nstatic void ocfs2_zero_cluster_pages(struct inode *inode, loff_t start,\n\t\t\t\t     loff_t end, struct page **pages,\n\t\t\t\t     int numpages, u64 phys, handle_t *handle)\n{\n\tint i;\n\tstruct page *page;\n\tunsigned int from, to = PAGE_SIZE;\n\tstruct super_block *sb = inode->i_sb;\n\n\tBUG_ON(!ocfs2_sparse_alloc(OCFS2_SB(sb)));\n\n\tif (numpages == 0)\n\t\tgoto out;\n\n\tto = PAGE_SIZE;\n\tfor(i = 0; i < numpages; i++) {\n\t\tpage = pages[i];\n\n\t\tfrom = start & (PAGE_SIZE - 1);\n\t\tif ((end >> PAGE_SHIFT) == page->index)\n\t\t\tto = end & (PAGE_SIZE - 1);\n\n\t\tBUG_ON(from > PAGE_SIZE);\n\t\tBUG_ON(to > PAGE_SIZE);\n\n\t\tocfs2_map_and_dirty_page(inode, handle, from, to, page, 1,\n\t\t\t\t\t &phys);\n\n\t\tstart = (page->index + 1) << PAGE_SHIFT;\n\t}\nout:\n\tif (pages)\n\t\tocfs2_unlock_and_free_pages(pages, numpages);\n}\n\nint ocfs2_grab_pages(struct inode *inode, loff_t start, loff_t end,\n\t\t     struct page **pages, int *num)\n{\n\tint numpages, ret = 0;\n\tstruct address_space *mapping = inode->i_mapping;\n\tunsigned long index;\n\tloff_t last_page_bytes;\n\n\tBUG_ON(start > end);\n\n\tnumpages = 0;\n\tlast_page_bytes = PAGE_ALIGN(end);\n\tindex = start >> PAGE_SHIFT;\n\tdo {\n\t\tpages[numpages] = find_or_create_page(mapping, index, GFP_NOFS);\n\t\tif (!pages[numpages]) {\n\t\t\tret = -ENOMEM;\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tnumpages++;\n\t\tindex++;\n\t} while (index < (last_page_bytes >> PAGE_SHIFT));\n\nout:\n\tif (ret != 0) {\n\t\tif (pages)\n\t\t\tocfs2_unlock_and_free_pages(pages, numpages);\n\t\tnumpages = 0;\n\t}\n\n\t*num = numpages;\n\n\treturn ret;\n}\n\nstatic int ocfs2_grab_eof_pages(struct inode *inode, loff_t start, loff_t end,\n\t\t\t\tstruct page **pages, int *num)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tBUG_ON(start >> OCFS2_SB(sb)->s_clustersize_bits !=\n\t       (end - 1) >> OCFS2_SB(sb)->s_clustersize_bits);\n\n\treturn ocfs2_grab_pages(inode, start, end, pages, num);\n}\n\n \nint ocfs2_zero_range_for_truncate(struct inode *inode, handle_t *handle,\n\t\t\t\t  u64 range_start, u64 range_end)\n{\n\tint ret = 0, numpages;\n\tstruct page **pages = NULL;\n\tu64 phys;\n\tunsigned int ext_flags;\n\tstruct super_block *sb = inode->i_sb;\n\n\t \n\tif (!ocfs2_sparse_alloc(OCFS2_SB(sb)))\n\t\treturn 0;\n\n\t \n\trange_end = min_t(u64, range_end, i_size_read(inode));\n\tif (range_start >= range_end)\n\t\treturn 0;\n\n\tpages = kcalloc(ocfs2_pages_per_cluster(sb),\n\t\t\tsizeof(struct page *), GFP_NOFS);\n\tif (pages == NULL) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_extent_map_get_blocks(inode,\n\t\t\t\t\t  range_start >> sb->s_blocksize_bits,\n\t\t\t\t\t  &phys, NULL, &ext_flags);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t \n\tif (phys == 0 || ext_flags & OCFS2_EXT_UNWRITTEN)\n\t\tgoto out;\n\n\tret = ocfs2_grab_eof_pages(inode, range_start, range_end, pages,\n\t\t\t\t   &numpages);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_zero_cluster_pages(inode, range_start, range_end, pages,\n\t\t\t\t numpages, phys, handle);\n\n\t \n\tret = filemap_fdatawrite_range(inode->i_mapping, range_start,\n\t\t\t\t       range_end - 1);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tkfree(pages);\n\n\treturn ret;\n}\n\nstatic void ocfs2_zero_dinode_id2_with_xattr(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_dinode *di)\n{\n\tunsigned int blocksize = 1 << inode->i_sb->s_blocksize_bits;\n\tunsigned int xattrsize = le16_to_cpu(di->i_xattr_inline_size);\n\n\tif (le16_to_cpu(di->i_dyn_features) & OCFS2_INLINE_XATTR_FL)\n\t\tmemset(&di->id2, 0, blocksize -\n\t\t\t\t    offsetof(struct ocfs2_dinode, id2) -\n\t\t\t\t    xattrsize);\n\telse\n\t\tmemset(&di->id2, 0, blocksize -\n\t\t\t\t    offsetof(struct ocfs2_dinode, id2));\n}\n\nvoid ocfs2_dinode_new_extent_list(struct inode *inode,\n\t\t\t\t  struct ocfs2_dinode *di)\n{\n\tocfs2_zero_dinode_id2_with_xattr(inode, di);\n\tdi->id2.i_list.l_tree_depth = 0;\n\tdi->id2.i_list.l_next_free_rec = 0;\n\tdi->id2.i_list.l_count = cpu_to_le16(\n\t\tocfs2_extent_recs_per_inode_with_xattr(inode->i_sb, di));\n}\n\nvoid ocfs2_set_inode_data_inline(struct inode *inode, struct ocfs2_dinode *di)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_inline_data *idata = &di->id2.i_data;\n\n\tspin_lock(&oi->ip_lock);\n\toi->ip_dyn_features |= OCFS2_INLINE_DATA_FL;\n\tdi->i_dyn_features = cpu_to_le16(oi->ip_dyn_features);\n\tspin_unlock(&oi->ip_lock);\n\n\t \n\tocfs2_zero_dinode_id2_with_xattr(inode, di);\n\n\tidata->id_count = cpu_to_le16(\n\t\t\tocfs2_max_inline_data_with_xattr(inode->i_sb, di));\n}\n\nint ocfs2_convert_inline_data_to_extents(struct inode *inode,\n\t\t\t\t\t struct buffer_head *di_bh)\n{\n\tint ret, has_data, num_pages = 0;\n\tint need_free = 0;\n\tu32 bit_off, num;\n\thandle_t *handle;\n\tu64 block;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_alloc_context *data_ac = NULL;\n\tstruct page *page = NULL;\n\tstruct ocfs2_extent_tree et;\n\tint did_quota = 0;\n\n\thas_data = i_size_read(inode) ? 1 : 0;\n\n\tif (has_data) {\n\t\tret = ocfs2_reserve_clusters(osb, 1, &data_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\thandle = ocfs2_start_trans(osb,\n\t\t\t\t   ocfs2_inline_to_extents_credits(osb->sb));\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tif (has_data) {\n\t\tunsigned int page_end = min_t(unsigned, PAGE_SIZE,\n\t\t\t\t\t\t\tosb->s_clustersize);\n\t\tu64 phys;\n\n\t\tret = dquot_alloc_space_nodirty(inode,\n\t\t\t\t       ocfs2_clusters_to_bytes(osb->sb, 1));\n\t\tif (ret)\n\t\t\tgoto out_commit;\n\t\tdid_quota = 1;\n\n\t\tdata_ac->ac_resv = &oi->ip_la_data_resv;\n\n\t\tret = ocfs2_claim_clusters(handle, data_ac, 1, &bit_off,\n\t\t\t\t\t   &num);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\n\t\t \n\t\tblock = phys = ocfs2_clusters_to_blocks(inode->i_sb, bit_off);\n\n\t\tret = ocfs2_grab_eof_pages(inode, 0, page_end, &page,\n\t\t\t\t\t   &num_pages);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tneed_free = 1;\n\t\t\tgoto out_commit;\n\t\t}\n\n\t\t \n\t\tret = ocfs2_read_inline_data(inode, page, di_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tneed_free = 1;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tocfs2_map_and_dirty_page(inode, handle, 0, page_end, page, 0,\n\t\t\t\t\t &phys);\n\t}\n\n\tspin_lock(&oi->ip_lock);\n\toi->ip_dyn_features &= ~OCFS2_INLINE_DATA_FL;\n\tdi->i_dyn_features = cpu_to_le16(oi->ip_dyn_features);\n\tspin_unlock(&oi->ip_lock);\n\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\tocfs2_dinode_new_extent_list(inode, di);\n\n\tocfs2_journal_dirty(handle, di_bh);\n\n\tif (has_data) {\n\t\t \n\t\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(inode), di_bh);\n\t\tret = ocfs2_insert_extent(handle, &et, 0, block, 1, 0, NULL);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tneed_free = 1;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\t}\n\nout_unlock:\n\tif (page)\n\t\tocfs2_unlock_and_free_pages(&page, num_pages);\n\nout_commit:\n\tif (ret < 0 && did_quota)\n\t\tdquot_free_space_nodirty(inode,\n\t\t\t\t\t  ocfs2_clusters_to_bytes(osb->sb, 1));\n\n\tif (need_free) {\n\t\tif (data_ac->ac_which == OCFS2_AC_USE_LOCAL)\n\t\t\tocfs2_free_local_alloc_bits(osb, handle, data_ac,\n\t\t\t\t\tbit_off, num);\n\t\telse\n\t\t\tocfs2_free_clusters(handle,\n\t\t\t\t\tdata_ac->ac_inode,\n\t\t\t\t\tdata_ac->ac_bh,\n\t\t\t\t\tocfs2_clusters_to_blocks(osb->sb, bit_off),\n\t\t\t\t\tnum);\n\t}\n\n\tocfs2_commit_trans(osb, handle);\n\nout:\n\tif (data_ac)\n\t\tocfs2_free_alloc_context(data_ac);\n\treturn ret;\n}\n\n \nint ocfs2_commit_truncate(struct ocfs2_super *osb,\n\t\t\t  struct inode *inode,\n\t\t\t  struct buffer_head *di_bh)\n{\n\tint status = 0, i, flags = 0;\n\tu32 new_highest_cpos, range, trunc_cpos, trunc_len, phys_cpos, coff;\n\tu64 blkno = 0;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\tstruct ocfs2_path *path = NULL;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_extent_list *root_el = &(di->id2.i_list);\n\tu64 refcount_loc = le64_to_cpu(di->i_refcount_loc);\n\tstruct ocfs2_extent_tree et;\n\tstruct ocfs2_cached_dealloc_ctxt dealloc;\n\tstruct ocfs2_refcount_tree *ref_tree = NULL;\n\n\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(inode), di_bh);\n\tocfs2_init_dealloc_ctxt(&dealloc);\n\n\tnew_highest_cpos = ocfs2_clusters_for_bytes(osb->sb,\n\t\t\t\t\t\t     i_size_read(inode));\n\n\tpath = ocfs2_new_path(di_bh, &di->id2.i_list,\n\t\t\t      ocfs2_journal_access_di);\n\tif (!path) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_extent_map_trunc(inode, new_highest_cpos);\n\nstart:\n\t \n\tif (OCFS2_I(inode)->ip_clusters == 0) {\n\t\tstatus = 0;\n\t\tgoto bail;\n\t}\n\n\t \n\tstatus = ocfs2_find_path(INODE_CACHE(inode), path, UINT_MAX);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_commit_truncate(\n\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\tnew_highest_cpos,\n\t\tOCFS2_I(inode)->ip_clusters,\n\t\tpath->p_tree_depth);\n\n\t \n\tel = path_leaf_el(path);\n\tif (le16_to_cpu(el->l_next_free_rec) == 0) {\n\t\tocfs2_error(inode->i_sb,\n\t\t\t    \"Inode %llu has empty extent block at %llu\\n\",\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t    (unsigned long long)path_leaf_bh(path)->b_blocknr);\n\t\tstatus = -EROFS;\n\t\tgoto bail;\n\t}\n\n\ti = le16_to_cpu(el->l_next_free_rec) - 1;\n\trec = &el->l_recs[i];\n\tflags = rec->e_flags;\n\trange = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);\n\n\tif (i == 0 && ocfs2_is_empty_extent(rec)) {\n\t\t \n\t\tif (root_el->l_tree_depth && rec->e_int_clusters == 0) {\n\t\t\tmlog(ML_ERROR, \"Inode %lu has an empty \"\n\t\t\t\t    \"extent record, depth %u\\n\", inode->i_ino,\n\t\t\t\t    le16_to_cpu(root_el->l_tree_depth));\n\t\t\tstatus = ocfs2_remove_rightmost_empty_extent(osb,\n\t\t\t\t\t&et, path, &dealloc);\n\t\t\tif (status) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\n\t\t\tocfs2_reinit_path(path, 1);\n\t\t\tgoto start;\n\t\t} else {\n\t\t\ttrunc_cpos = le32_to_cpu(rec->e_cpos);\n\t\t\ttrunc_len = 0;\n\t\t\tblkno = 0;\n\t\t}\n\t} else if (le32_to_cpu(rec->e_cpos) >= new_highest_cpos) {\n\t\t \n\t\ttrunc_cpos = le32_to_cpu(rec->e_cpos);\n\t\ttrunc_len = ocfs2_rec_clusters(el, rec);\n\t\tblkno = le64_to_cpu(rec->e_blkno);\n\t} else if (range > new_highest_cpos) {\n\t\t \n\t\ttrunc_cpos = new_highest_cpos;\n\t\ttrunc_len = range - new_highest_cpos;\n\t\tcoff = new_highest_cpos - le32_to_cpu(rec->e_cpos);\n\t\tblkno = le64_to_cpu(rec->e_blkno) +\n\t\t\t\tocfs2_clusters_to_blocks(inode->i_sb, coff);\n\t} else {\n\t\t \n\t\tstatus = 0;\n\t\tgoto bail;\n\t}\n\n\tphys_cpos = ocfs2_blocks_to_clusters(inode->i_sb, blkno);\n\n\tif ((flags & OCFS2_EXT_REFCOUNTED) && trunc_len && !ref_tree) {\n\t\tstatus = ocfs2_lock_refcount_tree(osb, refcount_loc, 1,\n\t\t\t\t&ref_tree, NULL);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = ocfs2_remove_btree_range(inode, &et, trunc_cpos,\n\t\t\t\t\t  phys_cpos, trunc_len, flags, &dealloc,\n\t\t\t\t\t  refcount_loc, true);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_reinit_path(path, 1);\n\n\t \n\tgoto start;\n\nbail:\n\tif (ref_tree)\n\t\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\n\tocfs2_schedule_truncate_log_flush(osb, 1);\n\n\tocfs2_run_deallocs(osb, &dealloc);\n\n\tocfs2_free_path(path);\n\n\treturn status;\n}\n\n \nint ocfs2_truncate_inline(struct inode *inode, struct buffer_head *di_bh,\n\t\t\t  unsigned int start, unsigned int end, int trunc)\n{\n\tint ret;\n\tunsigned int numbytes;\n\thandle_t *handle;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_inline_data *idata = &di->id2.i_data;\n\n\t \n\tif (start >= i_size_read(inode))\n\t\treturn 0;\n\n\tif (end > i_size_read(inode))\n\t\tend = i_size_read(inode);\n\n\tBUG_ON(start > end);\n\n\tif (!(OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) ||\n\t    !(le16_to_cpu(di->i_dyn_features) & OCFS2_INLINE_DATA_FL) ||\n\t    !ocfs2_supports_inline_data(osb)) {\n\t\tocfs2_error(inode->i_sb,\n\t\t\t    \"Inline data flags for inode %llu don't agree! Disk: 0x%x, Memory: 0x%x, Superblock: 0x%x\\n\",\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t    le16_to_cpu(di->i_dyn_features),\n\t\t\t    OCFS2_I(inode)->ip_dyn_features,\n\t\t\t    osb->s_feature_incompat);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tnumbytes = end - start;\n\tmemset(idata->id_data + start, 0, numbytes);\n\n\t \n\tif (trunc) {\n\t\ti_size_write(inode, start);\n\t\tdi->i_size = cpu_to_le64(start);\n\t}\n\n\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\tinode->i_mtime = inode_set_ctime_current(inode);\n\n\tdi->i_ctime = di->i_mtime = cpu_to_le64(inode_get_ctime(inode).tv_sec);\n\tdi->i_ctime_nsec = di->i_mtime_nsec = cpu_to_le32(inode_get_ctime(inode).tv_nsec);\n\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\tocfs2_journal_dirty(handle, di_bh);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\nout:\n\treturn ret;\n}\n\nstatic int ocfs2_trim_extent(struct super_block *sb,\n\t\t\t     struct ocfs2_group_desc *gd,\n\t\t\t     u64 group, u32 start, u32 count)\n{\n\tu64 discard, bcount;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tbcount = ocfs2_clusters_to_blocks(sb, count);\n\tdiscard = ocfs2_clusters_to_blocks(sb, start);\n\n\t \n\tif (group != osb->first_cluster_group_blkno)\n\t\tdiscard += le64_to_cpu(gd->bg_blkno);\n\n\ttrace_ocfs2_trim_extent(sb, (unsigned long long)discard, bcount);\n\n\treturn sb_issue_discard(sb, discard, bcount, GFP_NOFS, 0);\n}\n\nstatic int ocfs2_trim_group(struct super_block *sb,\n\t\t\t    struct ocfs2_group_desc *gd, u64 group,\n\t\t\t    u32 start, u32 max, u32 minbits)\n{\n\tint ret = 0, count = 0, next;\n\tvoid *bitmap = gd->bg_bitmap;\n\n\tif (le16_to_cpu(gd->bg_free_bits_count) < minbits)\n\t\treturn 0;\n\n\ttrace_ocfs2_trim_group((unsigned long long)le64_to_cpu(gd->bg_blkno),\n\t\t\t       start, max, minbits);\n\n\twhile (start < max) {\n\t\tstart = ocfs2_find_next_zero_bit(bitmap, max, start);\n\t\tif (start >= max)\n\t\t\tbreak;\n\t\tnext = ocfs2_find_next_bit(bitmap, max, start);\n\n\t\tif ((next - start) >= minbits) {\n\t\t\tret = ocfs2_trim_extent(sb, gd, group,\n\t\t\t\t\t\tstart, next - start);\n\t\t\tif (ret < 0) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount += next - start;\n\t\t}\n\t\tstart = next + 1;\n\n\t\tif (fatal_signal_pending(current)) {\n\t\t\tcount = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((le16_to_cpu(gd->bg_free_bits_count) - count) < minbits)\n\t\t\tbreak;\n\t}\n\n\tif (ret < 0)\n\t\tcount = ret;\n\n\treturn count;\n}\n\nstatic\nint ocfs2_trim_mainbm(struct super_block *sb, struct fstrim_range *range)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\tu64 start, len, trimmed = 0, first_group, last_group = 0, group = 0;\n\tint ret, cnt;\n\tu32 first_bit, last_bit, minlen;\n\tstruct buffer_head *main_bm_bh = NULL;\n\tstruct inode *main_bm_inode = NULL;\n\tstruct buffer_head *gd_bh = NULL;\n\tstruct ocfs2_dinode *main_bm;\n\tstruct ocfs2_group_desc *gd = NULL;\n\n\tstart = range->start >> osb->s_clustersize_bits;\n\tlen = range->len >> osb->s_clustersize_bits;\n\tminlen = range->minlen >> osb->s_clustersize_bits;\n\n\tif (minlen >= osb->bitmap_cpg || range->len < sb->s_blocksize)\n\t\treturn -EINVAL;\n\n\ttrace_ocfs2_trim_mainbm(start, len, minlen);\n\nnext_group:\n\tmain_bm_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t    GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t\t    OCFS2_INVALID_SLOT);\n\tif (!main_bm_inode) {\n\t\tret = -EIO;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tinode_lock(main_bm_inode);\n\n\tret = ocfs2_inode_lock(main_bm_inode, &main_bm_bh, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out_mutex;\n\t}\n\tmain_bm = (struct ocfs2_dinode *)main_bm_bh->b_data;\n\n\t \n\tif (!group) {\n\t\tif (start >= le32_to_cpu(main_bm->i_clusters)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tif (start + len > le32_to_cpu(main_bm->i_clusters))\n\t\t\tlen = le32_to_cpu(main_bm->i_clusters) - start;\n\n\t\t \n\t\tfirst_group = ocfs2_which_cluster_group(main_bm_inode, start);\n\t\tif (first_group == osb->first_cluster_group_blkno)\n\t\t\tfirst_bit = start;\n\t\telse\n\t\t\tfirst_bit = start - ocfs2_blocks_to_clusters(sb,\n\t\t\t\t\t\t\t\tfirst_group);\n\t\tlast_group = ocfs2_which_cluster_group(main_bm_inode,\n\t\t\t\t\t\t       start + len - 1);\n\t\tgroup = first_group;\n\t}\n\n\tdo {\n\t\tif (first_bit + len >= osb->bitmap_cpg)\n\t\t\tlast_bit = osb->bitmap_cpg;\n\t\telse\n\t\t\tlast_bit = first_bit + len;\n\n\t\tret = ocfs2_read_group_descriptor(main_bm_inode,\n\t\t\t\t\t\t  main_bm, group,\n\t\t\t\t\t\t  &gd_bh);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tgd = (struct ocfs2_group_desc *)gd_bh->b_data;\n\t\tcnt = ocfs2_trim_group(sb, gd, group,\n\t\t\t\t       first_bit, last_bit, minlen);\n\t\tbrelse(gd_bh);\n\t\tgd_bh = NULL;\n\t\tif (cnt < 0) {\n\t\t\tret = cnt;\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\ttrimmed += cnt;\n\t\tlen -= osb->bitmap_cpg - first_bit;\n\t\tfirst_bit = 0;\n\t\tif (group == osb->first_cluster_group_blkno)\n\t\t\tgroup = ocfs2_clusters_to_blocks(sb, osb->bitmap_cpg);\n\t\telse\n\t\t\tgroup += ocfs2_clusters_to_blocks(sb, osb->bitmap_cpg);\n\t} while (0);\n\nout_unlock:\n\tocfs2_inode_unlock(main_bm_inode, 0);\n\tbrelse(main_bm_bh);\n\tmain_bm_bh = NULL;\nout_mutex:\n\tinode_unlock(main_bm_inode);\n\tiput(main_bm_inode);\n\n\t \n\tif (ret >= 0 && group <= last_group) {\n\t\tcond_resched();\n\t\tgoto next_group;\n\t}\nout:\n\trange->len = trimmed * sb->s_blocksize;\n\treturn ret;\n}\n\nint ocfs2_trim_fs(struct super_block *sb, struct fstrim_range *range)\n{\n\tint ret;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\tstruct ocfs2_trim_fs_info info, *pinfo = NULL;\n\n\tocfs2_trim_fs_lock_res_init(osb);\n\n\ttrace_ocfs2_trim_fs(range->start, range->len, range->minlen);\n\n\tret = ocfs2_trim_fs_lock(osb, NULL, 1);\n\tif (ret < 0) {\n\t\tif (ret != -EAGAIN) {\n\t\t\tmlog_errno(ret);\n\t\t\tocfs2_trim_fs_lock_res_uninit(osb);\n\t\t\treturn ret;\n\t\t}\n\n\t\tmlog(ML_NOTICE, \"Wait for trim on device (%s) to \"\n\t\t     \"finish, which is running from another node.\\n\",\n\t\t     osb->dev_str);\n\t\tret = ocfs2_trim_fs_lock(osb, &info, 0);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tocfs2_trim_fs_lock_res_uninit(osb);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (info.tf_valid && info.tf_success &&\n\t\t    info.tf_start == range->start &&\n\t\t    info.tf_len == range->len &&\n\t\t    info.tf_minlen == range->minlen) {\n\t\t\t \n\t\t\tmlog(ML_NOTICE, \"The same trim on device (%s) was \"\n\t\t\t     \"just done from node (%u), return.\\n\",\n\t\t\t     osb->dev_str, info.tf_nodenum);\n\t\t\trange->len = info.tf_trimlen;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tinfo.tf_nodenum = osb->node_num;\n\tinfo.tf_start = range->start;\n\tinfo.tf_len = range->len;\n\tinfo.tf_minlen = range->minlen;\n\n\tret = ocfs2_trim_mainbm(sb, range);\n\n\tinfo.tf_trimlen = range->len;\n\tinfo.tf_success = (ret < 0 ? 0 : 1);\n\tpinfo = &info;\nout:\n\tocfs2_trim_fs_unlock(osb, pinfo);\n\tocfs2_trim_fs_lock_res_uninit(osb);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}