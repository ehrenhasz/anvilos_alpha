{
  "module_name": "aops.c",
  "hash_id": "3156add543a9acaa260667a5a3815ef2552c25af417bd22164ccf16674ff1fc3",
  "original_prompt": "Ingested from linux-6.6.14/fs/ocfs2/aops.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <asm/byteorder.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/quotaops.h>\n#include <linux/blkdev.h>\n#include <linux/uio.h>\n#include <linux/mm.h>\n\n#include <cluster/masklog.h>\n\n#include \"ocfs2.h\"\n\n#include \"alloc.h\"\n#include \"aops.h\"\n#include \"dlmglue.h\"\n#include \"extent_map.h\"\n#include \"file.h\"\n#include \"inode.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"super.h\"\n#include \"symlink.h\"\n#include \"refcounttree.h\"\n#include \"ocfs2_trace.h\"\n\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"namei.h\"\n#include \"sysfile.h\"\n\nstatic int ocfs2_symlink_get_block(struct inode *inode, sector_t iblock,\n\t\t\t\t   struct buffer_head *bh_result, int create)\n{\n\tint err = -EIO;\n\tint status;\n\tstruct ocfs2_dinode *fe = NULL;\n\tstruct buffer_head *bh = NULL;\n\tstruct buffer_head *buffer_cache_bh = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tvoid *kaddr;\n\n\ttrace_ocfs2_symlink_get_block(\n\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t(unsigned long long)iblock, bh_result, create);\n\n\tBUG_ON(ocfs2_inode_is_fast_symlink(inode));\n\n\tif ((iblock << inode->i_sb->s_blocksize_bits) > PATH_MAX + 1) {\n\t\tmlog(ML_ERROR, \"block offset > PATH_MAX: %llu\",\n\t\t     (unsigned long long)iblock);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_read_inode_block(inode, &bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tfe = (struct ocfs2_dinode *) bh->b_data;\n\n\tif ((u64)iblock >= ocfs2_clusters_to_blocks(inode->i_sb,\n\t\t\t\t\t\t    le32_to_cpu(fe->i_clusters))) {\n\t\terr = -ENOMEM;\n\t\tmlog(ML_ERROR, \"block offset is outside the allocated size: \"\n\t\t     \"%llu\\n\", (unsigned long long)iblock);\n\t\tgoto bail;\n\t}\n\n\t \n\tif (!buffer_uptodate(bh_result) && ocfs2_inode_is_new(inode)) {\n\t\tu64 blkno = le64_to_cpu(fe->id2.i_list.l_recs[0].e_blkno) +\n\t\t\t    iblock;\n\t\tbuffer_cache_bh = sb_getblk(osb->sb, blkno);\n\t\tif (!buffer_cache_bh) {\n\t\t\terr = -ENOMEM;\n\t\t\tmlog(ML_ERROR, \"couldn't getblock for symlink!\\n\");\n\t\t\tgoto bail;\n\t\t}\n\n\t\t \n\t\tif (buffer_jbd(buffer_cache_bh)\n\t\t    && ocfs2_inode_is_new(inode)) {\n\t\t\tkaddr = kmap_atomic(bh_result->b_page);\n\t\t\tif (!kaddr) {\n\t\t\t\tmlog(ML_ERROR, \"couldn't kmap!\\n\");\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tmemcpy(kaddr + (bh_result->b_size * iblock),\n\t\t\t       buffer_cache_bh->b_data,\n\t\t\t       bh_result->b_size);\n\t\t\tkunmap_atomic(kaddr);\n\t\t\tset_buffer_uptodate(bh_result);\n\t\t}\n\t\tbrelse(buffer_cache_bh);\n\t}\n\n\tmap_bh(bh_result, inode->i_sb,\n\t       le64_to_cpu(fe->id2.i_list.l_recs[0].e_blkno) + iblock);\n\n\terr = 0;\n\nbail:\n\tbrelse(bh);\n\n\treturn err;\n}\n\nstatic int ocfs2_lock_get_block(struct inode *inode, sector_t iblock,\n\t\t    struct buffer_head *bh_result, int create)\n{\n\tint ret = 0;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\tdown_read(&oi->ip_alloc_sem);\n\tret = ocfs2_get_block(inode, iblock, bh_result, create);\n\tup_read(&oi->ip_alloc_sem);\n\n\treturn ret;\n}\n\nint ocfs2_get_block(struct inode *inode, sector_t iblock,\n\t\t    struct buffer_head *bh_result, int create)\n{\n\tint err = 0;\n\tunsigned int ext_flags;\n\tu64 max_blocks = bh_result->b_size >> inode->i_blkbits;\n\tu64 p_blkno, count, past_eof;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\ttrace_ocfs2_get_block((unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t      (unsigned long long)iblock, bh_result, create);\n\n\tif (OCFS2_I(inode)->ip_flags & OCFS2_INODE_SYSTEM_FILE)\n\t\tmlog(ML_NOTICE, \"get_block on system inode 0x%p (%lu)\\n\",\n\t\t     inode, inode->i_ino);\n\n\tif (S_ISLNK(inode->i_mode)) {\n\t\t \n\t\terr = ocfs2_symlink_get_block(inode, iblock, bh_result, create);\n\t\tgoto bail;\n\t}\n\n\terr = ocfs2_extent_map_get_blocks(inode, iblock, &p_blkno, &count,\n\t\t\t\t\t  &ext_flags);\n\tif (err) {\n\t\tmlog(ML_ERROR, \"Error %d from get_blocks(0x%p, %llu, 1, \"\n\t\t     \"%llu, NULL)\\n\", err, inode, (unsigned long long)iblock,\n\t\t     (unsigned long long)p_blkno);\n\t\tgoto bail;\n\t}\n\n\tif (max_blocks < count)\n\t\tcount = max_blocks;\n\n\t \n\tif (create && p_blkno == 0 && ocfs2_sparse_alloc(osb)) {\n\t\tclear_buffer_dirty(bh_result);\n\t\tclear_buffer_uptodate(bh_result);\n\t\tgoto bail;\n\t}\n\n\t \n\tif (p_blkno && !(ext_flags & OCFS2_EXT_UNWRITTEN))\n\t\tmap_bh(bh_result, inode->i_sb, p_blkno);\n\n\tbh_result->b_size = count << inode->i_blkbits;\n\n\tif (!ocfs2_sparse_alloc(osb)) {\n\t\tif (p_blkno == 0) {\n\t\t\terr = -EIO;\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"iblock = %llu p_blkno = %llu blkno=(%llu)\\n\",\n\t\t\t     (unsigned long long)iblock,\n\t\t\t     (unsigned long long)p_blkno,\n\t\t\t     (unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t\t\tmlog(ML_ERROR, \"Size %llu, clusters %u\\n\", (unsigned long long)i_size_read(inode), OCFS2_I(inode)->ip_clusters);\n\t\t\tdump_stack();\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tpast_eof = ocfs2_blocks_for_bytes(inode->i_sb, i_size_read(inode));\n\n\ttrace_ocfs2_get_block_end((unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t\t  (unsigned long long)past_eof);\n\tif (create && (iblock >= past_eof))\n\t\tset_buffer_new(bh_result);\n\nbail:\n\tif (err < 0)\n\t\terr = -EIO;\n\n\treturn err;\n}\n\nint ocfs2_read_inline_data(struct inode *inode, struct page *page,\n\t\t\t   struct buffer_head *di_bh)\n{\n\tvoid *kaddr;\n\tloff_t size;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tif (!(le16_to_cpu(di->i_dyn_features) & OCFS2_INLINE_DATA_FL)) {\n\t\tocfs2_error(inode->i_sb, \"Inode %llu lost inline data flag\\n\",\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t\treturn -EROFS;\n\t}\n\n\tsize = i_size_read(inode);\n\n\tif (size > PAGE_SIZE ||\n\t    size > ocfs2_max_inline_data_with_xattr(inode->i_sb, di)) {\n\t\tocfs2_error(inode->i_sb,\n\t\t\t    \"Inode %llu has with inline data has bad size: %Lu\\n\",\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t    (unsigned long long)size);\n\t\treturn -EROFS;\n\t}\n\n\tkaddr = kmap_atomic(page);\n\tif (size)\n\t\tmemcpy(kaddr, di->id2.i_data.id_data, size);\n\t \n\tmemset(kaddr + size, 0, PAGE_SIZE - size);\n\tflush_dcache_page(page);\n\tkunmap_atomic(kaddr);\n\n\tSetPageUptodate(page);\n\n\treturn 0;\n}\n\nstatic int ocfs2_readpage_inline(struct inode *inode, struct page *page)\n{\n\tint ret;\n\tstruct buffer_head *di_bh = NULL;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(!(OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL));\n\n\tret = ocfs2_read_inode_block(inode, &di_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_inline_data(inode, page, di_bh);\nout:\n\tunlock_page(page);\n\n\tbrelse(di_bh);\n\treturn ret;\n}\n\nstatic int ocfs2_read_folio(struct file *file, struct folio *folio)\n{\n\tstruct inode *inode = folio->mapping->host;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tloff_t start = folio_pos(folio);\n\tint ret, unlock = 1;\n\n\ttrace_ocfs2_readpage((unsigned long long)oi->ip_blkno, folio->index);\n\n\tret = ocfs2_inode_lock_with_page(inode, NULL, 0, &folio->page);\n\tif (ret != 0) {\n\t\tif (ret == AOP_TRUNCATED_PAGE)\n\t\t\tunlock = 0;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (down_read_trylock(&oi->ip_alloc_sem) == 0) {\n\t\t \n\t\tret = AOP_TRUNCATED_PAGE;\n\t\tfolio_unlock(folio);\n\t\tunlock = 0;\n\t\tdown_read(&oi->ip_alloc_sem);\n\t\tup_read(&oi->ip_alloc_sem);\n\t\tgoto out_inode_unlock;\n\t}\n\n\t \n\tif (start >= i_size_read(inode)) {\n\t\tfolio_zero_segment(folio, 0, folio_size(folio));\n\t\tfolio_mark_uptodate(folio);\n\t\tret = 0;\n\t\tgoto out_alloc;\n\t}\n\n\tif (oi->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\tret = ocfs2_readpage_inline(inode, &folio->page);\n\telse\n\t\tret = block_read_full_folio(folio, ocfs2_get_block);\n\tunlock = 0;\n\nout_alloc:\n\tup_read(&oi->ip_alloc_sem);\nout_inode_unlock:\n\tocfs2_inode_unlock(inode, 0);\nout:\n\tif (unlock)\n\t\tfolio_unlock(folio);\n\treturn ret;\n}\n\n \nstatic void ocfs2_readahead(struct readahead_control *rac)\n{\n\tint ret;\n\tstruct inode *inode = rac->mapping->host;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\t \n\tret = ocfs2_inode_lock_full(inode, NULL, 0, OCFS2_LOCK_NONBLOCK);\n\tif (ret)\n\t\treturn;\n\n\tif (down_read_trylock(&oi->ip_alloc_sem) == 0)\n\t\tgoto out_unlock;\n\n\t \n\tif (oi->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\tgoto out_up;\n\n\t \n\tif (readahead_pos(rac) >= i_size_read(inode))\n\t\tgoto out_up;\n\n\tmpage_readahead(rac, ocfs2_get_block);\n\nout_up:\n\tup_read(&oi->ip_alloc_sem);\nout_unlock:\n\tocfs2_inode_unlock(inode, 0);\n}\n\n \nstatic int ocfs2_writepage(struct page *page, struct writeback_control *wbc)\n{\n\ttrace_ocfs2_writepage(\n\t\t(unsigned long long)OCFS2_I(page->mapping->host)->ip_blkno,\n\t\tpage->index);\n\n\treturn block_write_full_page(page, ocfs2_get_block, wbc);\n}\n\n \nint walk_page_buffers(\thandle_t *handle,\n\t\t\tstruct buffer_head *head,\n\t\t\tunsigned from,\n\t\t\tunsigned to,\n\t\t\tint *partial,\n\t\t\tint (*fn)(\thandle_t *handle,\n\t\t\t\t\tstruct buffer_head *bh))\n{\n\tstruct buffer_head *bh;\n\tunsigned block_start, block_end;\n\tunsigned blocksize = head->b_size;\n\tint err, ret = 0;\n\tstruct buffer_head *next;\n\n\tfor (\tbh = head, block_start = 0;\n\t\tret == 0 && (bh != head || !block_start);\n\t    \tblock_start = block_end, bh = next)\n\t{\n\t\tnext = bh->b_this_page;\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (partial && !buffer_uptodate(bh))\n\t\t\t\t*partial = 1;\n\t\t\tcontinue;\n\t\t}\n\t\terr = (*fn)(handle, bh);\n\t\tif (!ret)\n\t\t\tret = err;\n\t}\n\treturn ret;\n}\n\nstatic sector_t ocfs2_bmap(struct address_space *mapping, sector_t block)\n{\n\tsector_t status;\n\tu64 p_blkno = 0;\n\tint err = 0;\n\tstruct inode *inode = mapping->host;\n\n\ttrace_ocfs2_bmap((unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t (unsigned long long)block);\n\n\t \n\tif (ocfs2_is_refcount_inode(inode))\n\t\treturn 0;\n\n\t \n\tif (!INODE_JOURNAL(inode)) {\n\t\terr = ocfs2_inode_lock(inode, NULL, 0);\n\t\tif (err) {\n\t\t\tif (err != -ENOENT)\n\t\t\t\tmlog_errno(err);\n\t\t\tgoto bail;\n\t\t}\n\t\tdown_read(&OCFS2_I(inode)->ip_alloc_sem);\n\t}\n\n\tif (!(OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL))\n\t\terr = ocfs2_extent_map_get_blocks(inode, block, &p_blkno, NULL,\n\t\t\t\t\t\t  NULL);\n\n\tif (!INODE_JOURNAL(inode)) {\n\t\tup_read(&OCFS2_I(inode)->ip_alloc_sem);\n\t\tocfs2_inode_unlock(inode, 0);\n\t}\n\n\tif (err) {\n\t\tmlog(ML_ERROR, \"get_blocks() failed, block = %llu\\n\",\n\t\t     (unsigned long long)block);\n\t\tmlog_errno(err);\n\t\tgoto bail;\n\t}\n\nbail:\n\tstatus = err ? 0 : p_blkno;\n\n\treturn status;\n}\n\nstatic bool ocfs2_release_folio(struct folio *folio, gfp_t wait)\n{\n\tif (!folio_buffers(folio))\n\t\treturn false;\n\treturn try_to_free_buffers(folio);\n}\n\nstatic void ocfs2_figure_cluster_boundaries(struct ocfs2_super *osb,\n\t\t\t\t\t    u32 cpos,\n\t\t\t\t\t    unsigned int *start,\n\t\t\t\t\t    unsigned int *end)\n{\n\tunsigned int cluster_start = 0, cluster_end = PAGE_SIZE;\n\n\tif (unlikely(PAGE_SHIFT > osb->s_clustersize_bits)) {\n\t\tunsigned int cpp;\n\n\t\tcpp = 1 << (PAGE_SHIFT - osb->s_clustersize_bits);\n\n\t\tcluster_start = cpos % cpp;\n\t\tcluster_start = cluster_start << osb->s_clustersize_bits;\n\n\t\tcluster_end = cluster_start + osb->s_clustersize;\n\t}\n\n\tBUG_ON(cluster_start > PAGE_SIZE);\n\tBUG_ON(cluster_end > PAGE_SIZE);\n\n\tif (start)\n\t\t*start = cluster_start;\n\tif (end)\n\t\t*end = cluster_end;\n}\n\n \nstatic void ocfs2_clear_page_regions(struct page *page,\n\t\t\t\t     struct ocfs2_super *osb, u32 cpos,\n\t\t\t\t     unsigned from, unsigned to)\n{\n\tvoid *kaddr;\n\tunsigned int cluster_start, cluster_end;\n\n\tocfs2_figure_cluster_boundaries(osb, cpos, &cluster_start, &cluster_end);\n\n\tkaddr = kmap_atomic(page);\n\n\tif (from || to) {\n\t\tif (from > cluster_start)\n\t\t\tmemset(kaddr + cluster_start, 0, from - cluster_start);\n\t\tif (to < cluster_end)\n\t\t\tmemset(kaddr + to, 0, cluster_end - to);\n\t} else {\n\t\tmemset(kaddr + cluster_start, 0, cluster_end - cluster_start);\n\t}\n\n\tkunmap_atomic(kaddr);\n}\n\n \nstatic int ocfs2_should_read_blk(struct inode *inode, struct page *page,\n\t\t\t\t unsigned int block_start)\n{\n\tu64 offset = page_offset(page) + block_start;\n\n\tif (ocfs2_sparse_alloc(OCFS2_SB(inode->i_sb)))\n\t\treturn 1;\n\n\tif (i_size_read(inode) > offset)\n\t\treturn 1;\n\n\treturn 0;\n}\n\n \nint ocfs2_map_page_blocks(struct page *page, u64 *p_blkno,\n\t\t\t  struct inode *inode, unsigned int from,\n\t\t\t  unsigned int to, int new)\n{\n\tint ret = 0;\n\tstruct buffer_head *head, *bh, *wait[2], **wait_bh = wait;\n\tunsigned int block_end, block_start;\n\tunsigned int bsize = i_blocksize(inode);\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, bsize, 0);\n\n\thead = page_buffers(page);\n\tfor (bh = head, block_start = 0; bh != head || !block_start;\n\t     bh = bh->b_this_page, block_start += bsize) {\n\t\tblock_end = block_start + bsize;\n\n\t\tclear_buffer_new(bh);\n\n\t\t \n\t\tif (block_start >= to || block_end <= from) {\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (new)\n\t\t\tset_buffer_new(bh);\n\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tmap_bh(bh, inode->i_sb, *p_blkno);\n\t\t\tclean_bdev_bh_alias(bh);\n\t\t}\n\n\t\tif (PageUptodate(page)) {\n\t\t\tset_buffer_uptodate(bh);\n\t\t} else if (!buffer_uptodate(bh) && !buffer_delay(bh) &&\n\t\t\t   !buffer_new(bh) &&\n\t\t\t   ocfs2_should_read_blk(inode, page, block_start) &&\n\t\t\t   (block_start < from || block_end > to)) {\n\t\t\tbh_read_nowait(bh, 0);\n\t\t\t*wait_bh++=bh;\n\t\t}\n\n\t\t*p_blkno = *p_blkno + 1;\n\t}\n\n\t \n\twhile(wait_bh > wait) {\n\t\twait_on_buffer(*--wait_bh);\n\t\tif (!buffer_uptodate(*wait_bh))\n\t\t\tret = -EIO;\n\t}\n\n\tif (ret == 0 || !new)\n\t\treturn ret;\n\n\t \n\tbh = head;\n\tblock_start = 0;\n\tdo {\n\t\tblock_end = block_start + bsize;\n\t\tif (block_end <= from)\n\t\t\tgoto next_bh;\n\t\tif (block_start >= to)\n\t\t\tbreak;\n\n\t\tzero_user(page, block_start, bh->b_size);\n\t\tset_buffer_uptodate(bh);\n\t\tmark_buffer_dirty(bh);\n\nnext_bh:\n\t\tblock_start = block_end;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\n\treturn ret;\n}\n\n#if (PAGE_SIZE >= OCFS2_MAX_CLUSTERSIZE)\n#define OCFS2_MAX_CTXT_PAGES\t1\n#else\n#define OCFS2_MAX_CTXT_PAGES\t(OCFS2_MAX_CLUSTERSIZE / PAGE_SIZE)\n#endif\n\n#define OCFS2_MAX_CLUSTERS_PER_PAGE\t(PAGE_SIZE / OCFS2_MIN_CLUSTERSIZE)\n\nstruct ocfs2_unwritten_extent {\n\tstruct list_head\tue_node;\n\tstruct list_head\tue_ip_node;\n\tu32\t\t\tue_cpos;\n\tu32\t\t\tue_phys;\n};\n\n \nstruct ocfs2_write_cluster_desc {\n\tu32\t\tc_cpos;\n\tu32\t\tc_phys;\n\t \n\tunsigned\tc_new;\n\tunsigned\tc_clear_unwritten;\n\tunsigned\tc_needs_zero;\n};\n\nstruct ocfs2_write_ctxt {\n\t \n\tu32\t\t\t\tw_cpos;\n\tu32\t\t\t\tw_clen;\n\n\t \n\tu32\t\t\t\tw_first_new_cpos;\n\n\t \n\tocfs2_write_type_t\t\tw_type;\n\n\tstruct ocfs2_write_cluster_desc\tw_desc[OCFS2_MAX_CLUSTERS_PER_PAGE];\n\n\t \n\tunsigned int\t\t\tw_large_pages;\n\n\t \n\tunsigned int\t\t\tw_num_pages;\n\tstruct page\t\t\t*w_pages[OCFS2_MAX_CTXT_PAGES];\n\tstruct page\t\t\t*w_target_page;\n\n\t \n\tunsigned int\t\t\tw_target_locked:1;\n\n\t \n\tunsigned int\t\t\tw_target_from;\n\tunsigned int\t\t\tw_target_to;\n\n\t \n\thandle_t\t\t\t*w_handle;\n\n\tstruct buffer_head\t\t*w_di_bh;\n\n\tstruct ocfs2_cached_dealloc_ctxt w_dealloc;\n\n\tstruct list_head\t\tw_unwritten_list;\n\tunsigned int\t\t\tw_unwritten_count;\n};\n\nvoid ocfs2_unlock_and_free_pages(struct page **pages, int num_pages)\n{\n\tint i;\n\n\tfor(i = 0; i < num_pages; i++) {\n\t\tif (pages[i]) {\n\t\t\tunlock_page(pages[i]);\n\t\t\tmark_page_accessed(pages[i]);\n\t\t\tput_page(pages[i]);\n\t\t}\n\t}\n}\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t \n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}\n\nstatic void ocfs2_free_unwritten_list(struct inode *inode,\n\t\t\t\t struct list_head *head)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_unwritten_extent *ue = NULL, *tmp = NULL;\n\n\tlist_for_each_entry_safe(ue, tmp, head, ue_node) {\n\t\tlist_del(&ue->ue_node);\n\t\tspin_lock(&oi->ip_lock);\n\t\tlist_del(&ue->ue_ip_node);\n\t\tspin_unlock(&oi->ip_lock);\n\t\tkfree(ue);\n\t}\n}\n\nstatic void ocfs2_free_write_ctxt(struct inode *inode,\n\t\t\t\t  struct ocfs2_write_ctxt *wc)\n{\n\tocfs2_free_unwritten_list(inode, &wc->w_unwritten_list);\n\tocfs2_unlock_pages(wc);\n\tbrelse(wc->w_di_bh);\n\tkfree(wc);\n}\n\nstatic int ocfs2_alloc_write_ctxt(struct ocfs2_write_ctxt **wcp,\n\t\t\t\t  struct ocfs2_super *osb, loff_t pos,\n\t\t\t\t  unsigned len, ocfs2_write_type_t type,\n\t\t\t\t  struct buffer_head *di_bh)\n{\n\tu32 cend;\n\tstruct ocfs2_write_ctxt *wc;\n\n\twc = kzalloc(sizeof(struct ocfs2_write_ctxt), GFP_NOFS);\n\tif (!wc)\n\t\treturn -ENOMEM;\n\n\twc->w_cpos = pos >> osb->s_clustersize_bits;\n\twc->w_first_new_cpos = UINT_MAX;\n\tcend = (pos + len - 1) >> osb->s_clustersize_bits;\n\twc->w_clen = cend - wc->w_cpos + 1;\n\tget_bh(di_bh);\n\twc->w_di_bh = di_bh;\n\twc->w_type = type;\n\n\tif (unlikely(PAGE_SHIFT > osb->s_clustersize_bits))\n\t\twc->w_large_pages = 1;\n\telse\n\t\twc->w_large_pages = 0;\n\n\tocfs2_init_dealloc_ctxt(&wc->w_dealloc);\n\tINIT_LIST_HEAD(&wc->w_unwritten_list);\n\n\t*wcp = wc;\n\n\treturn 0;\n}\n\n \nstatic void ocfs2_zero_new_buffers(struct page *page, unsigned from, unsigned to)\n{\n\tunsigned int block_start, block_end;\n\tstruct buffer_head *head, *bh;\n\n\tBUG_ON(!PageLocked(page));\n\tif (!page_has_buffers(page))\n\t\treturn;\n\n\tbh = head = page_buffers(page);\n\tblock_start = 0;\n\tdo {\n\t\tblock_end = block_start + bh->b_size;\n\n\t\tif (buffer_new(bh)) {\n\t\t\tif (block_end > from && block_start < to) {\n\t\t\t\tif (!PageUptodate(page)) {\n\t\t\t\t\tunsigned start, end;\n\n\t\t\t\t\tstart = max(from, block_start);\n\t\t\t\t\tend = min(to, block_end);\n\n\t\t\t\t\tzero_user_segment(page, start, end);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t}\n\n\t\t\t\tclear_buffer_new(bh);\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t}\n\t\t}\n\n\t\tblock_start = block_end;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n}\n\n \nstatic void ocfs2_write_failure(struct inode *inode,\n\t\t\t\tstruct ocfs2_write_ctxt *wc,\n\t\t\t\tloff_t user_pos, unsigned user_len)\n{\n\tint i;\n\tunsigned from = user_pos & (PAGE_SIZE - 1),\n\t\tto = user_pos + user_len;\n\tstruct page *tmppage;\n\n\tif (wc->w_target_page)\n\t\tocfs2_zero_new_buffers(wc->w_target_page, from, to);\n\n\tfor(i = 0; i < wc->w_num_pages; i++) {\n\t\ttmppage = wc->w_pages[i];\n\n\t\tif (tmppage && page_has_buffers(tmppage)) {\n\t\t\tif (ocfs2_should_order_data(inode))\n\t\t\t\tocfs2_jbd2_inode_add_write(wc->w_handle, inode,\n\t\t\t\t\t\t\t   user_pos, user_len);\n\n\t\t\tblock_commit_write(tmppage, from, to);\n\t\t}\n\t}\n}\n\nstatic int ocfs2_prepare_page_for_write(struct inode *inode, u64 *p_blkno,\n\t\t\t\t\tstruct ocfs2_write_ctxt *wc,\n\t\t\t\t\tstruct page *page, u32 cpos,\n\t\t\t\t\tloff_t user_pos, unsigned user_len,\n\t\t\t\t\tint new)\n{\n\tint ret;\n\tunsigned int map_from = 0, map_to = 0;\n\tunsigned int cluster_start, cluster_end;\n\tunsigned int user_data_from = 0, user_data_to = 0;\n\n\tocfs2_figure_cluster_boundaries(OCFS2_SB(inode->i_sb), cpos,\n\t\t\t\t\t&cluster_start, &cluster_end);\n\n\t \n\tnew = new | ((i_size_read(inode) <= page_offset(page)) &&\n\t\t\t(page_offset(page) <= user_pos));\n\n\tif (page == wc->w_target_page) {\n\t\tmap_from = user_pos & (PAGE_SIZE - 1);\n\t\tmap_to = map_from + user_len;\n\n\t\tif (new)\n\t\t\tret = ocfs2_map_page_blocks(page, p_blkno, inode,\n\t\t\t\t\t\t    cluster_start, cluster_end,\n\t\t\t\t\t\t    new);\n\t\telse\n\t\t\tret = ocfs2_map_page_blocks(page, p_blkno, inode,\n\t\t\t\t\t\t    map_from, map_to, new);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tuser_data_from = map_from;\n\t\tuser_data_to = map_to;\n\t\tif (new) {\n\t\t\tmap_from = cluster_start;\n\t\t\tmap_to = cluster_end;\n\t\t}\n\t} else {\n\t\t \n\t\tBUG_ON(!new);\n\n\t\tmap_from = cluster_start;\n\t\tmap_to = cluster_end;\n\n\t\tret = ocfs2_map_page_blocks(page, p_blkno, inode,\n\t\t\t\t\t    cluster_start, cluster_end, new);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tif (new && !PageUptodate(page))\n\t\tocfs2_clear_page_regions(page, OCFS2_SB(inode->i_sb),\n\t\t\t\t\t cpos, user_data_from, user_data_to);\n\n\tflush_dcache_page(page);\n\nout:\n\treturn ret;\n}\n\n \nstatic int ocfs2_grab_pages_for_write(struct address_space *mapping,\n\t\t\t\t      struct ocfs2_write_ctxt *wc,\n\t\t\t\t      u32 cpos, loff_t user_pos,\n\t\t\t\t      unsigned user_len, int new,\n\t\t\t\t      struct page *mmap_page)\n{\n\tint ret = 0, i;\n\tunsigned long start, target_index, end_index, index;\n\tstruct inode *inode = mapping->host;\n\tloff_t last_byte;\n\n\ttarget_index = user_pos >> PAGE_SHIFT;\n\n\t \n\tif (new) {\n\t\twc->w_num_pages = ocfs2_pages_per_cluster(inode->i_sb);\n\t\tstart = ocfs2_align_clusters_to_page_index(inode->i_sb, cpos);\n\t\t \n\t\tlast_byte = max(user_pos + user_len, i_size_read(inode));\n\t\tBUG_ON(last_byte < 1);\n\t\tend_index = ((last_byte - 1) >> PAGE_SHIFT) + 1;\n\t\tif ((start + wc->w_num_pages) > end_index)\n\t\t\twc->w_num_pages = end_index - start;\n\t} else {\n\t\twc->w_num_pages = 1;\n\t\tstart = target_index;\n\t}\n\tend_index = (user_pos + user_len - 1) >> PAGE_SHIFT;\n\n\tfor(i = 0; i < wc->w_num_pages; i++) {\n\t\tindex = start + i;\n\n\t\tif (index >= target_index && index <= end_index &&\n\t\t    wc->w_type == OCFS2_WRITE_MMAP) {\n\t\t\t \n\t\t\tlock_page(mmap_page);\n\n\t\t\t \n\t\t\tif (mmap_page->mapping != mapping) {\n\t\t\t\tWARN_ON(mmap_page->mapping);\n\t\t\t\tunlock_page(mmap_page);\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tget_page(mmap_page);\n\t\t\twc->w_pages[i] = mmap_page;\n\t\t\twc->w_target_locked = true;\n\t\t} else if (index >= target_index && index <= end_index &&\n\t\t\t   wc->w_type == OCFS2_WRITE_DIRECT) {\n\t\t\t \n\t\t\twc->w_pages[i] = NULL;\n\t\t\tcontinue;\n\t\t} else {\n\t\t\twc->w_pages[i] = find_or_create_page(mapping, index,\n\t\t\t\t\t\t\t     GFP_NOFS);\n\t\t\tif (!wc->w_pages[i]) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\twait_for_stable_page(wc->w_pages[i]);\n\n\t\tif (index == target_index)\n\t\t\twc->w_target_page = wc->w_pages[i];\n\t}\nout:\n\tif (ret)\n\t\twc->w_target_locked = false;\n\treturn ret;\n}\n\n \nstatic int ocfs2_write_cluster(struct address_space *mapping,\n\t\t\t       u32 *phys, unsigned int new,\n\t\t\t       unsigned int clear_unwritten,\n\t\t\t       unsigned int should_zero,\n\t\t\t       struct ocfs2_alloc_context *data_ac,\n\t\t\t       struct ocfs2_alloc_context *meta_ac,\n\t\t\t       struct ocfs2_write_ctxt *wc, u32 cpos,\n\t\t\t       loff_t user_pos, unsigned user_len)\n{\n\tint ret, i;\n\tu64 p_blkno;\n\tstruct inode *inode = mapping->host;\n\tstruct ocfs2_extent_tree et;\n\tint bpc = ocfs2_clusters_to_blocks(inode->i_sb, 1);\n\n\tif (new) {\n\t\tu32 tmp_pos;\n\n\t\t \n\t\ttmp_pos = cpos;\n\t\tret = ocfs2_add_inode_data(OCFS2_SB(inode->i_sb), inode,\n\t\t\t\t\t   &tmp_pos, 1, !clear_unwritten,\n\t\t\t\t\t   wc->w_di_bh, wc->w_handle,\n\t\t\t\t\t   data_ac, meta_ac, NULL);\n\t\t \n\t\tmlog_bug_on_msg(ret == -EAGAIN,\n\t\t\t\t\"Inode %llu: EAGAIN return during allocation.\\n\",\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t} else if (clear_unwritten) {\n\t\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(inode),\n\t\t\t\t\t      wc->w_di_bh);\n\t\tret = ocfs2_mark_extent_written(inode, &et,\n\t\t\t\t\t\twc->w_handle, cpos, 1, *phys,\n\t\t\t\t\t\tmeta_ac, &wc->w_dealloc);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tret = ocfs2_get_clusters(inode, cpos, phys, NULL, NULL);\n\tif (ret < 0) {\n\t\tmlog(ML_ERROR, \"Get physical blkno failed for inode %llu, \"\n\t\t\t    \"at logical cluster %u\",\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno, cpos);\n\t\tgoto out;\n\t}\n\n\tBUG_ON(*phys == 0);\n\n\tp_blkno = ocfs2_clusters_to_blocks(inode->i_sb, *phys);\n\tif (!should_zero)\n\t\tp_blkno += (user_pos >> inode->i_sb->s_blocksize_bits) & (u64)(bpc - 1);\n\n\tfor(i = 0; i < wc->w_num_pages; i++) {\n\t\tint tmpret;\n\n\t\t \n\t\tif (wc->w_pages[i] == NULL) {\n\t\t\tp_blkno++;\n\t\t\tcontinue;\n\t\t}\n\n\t\ttmpret = ocfs2_prepare_page_for_write(inode, &p_blkno, wc,\n\t\t\t\t\t\t      wc->w_pages[i], cpos,\n\t\t\t\t\t\t      user_pos, user_len,\n\t\t\t\t\t\t      should_zero);\n\t\tif (tmpret) {\n\t\t\tmlog_errno(tmpret);\n\t\t\tif (ret == 0)\n\t\t\t\tret = tmpret;\n\t\t}\n\t}\n\n\t \n\tif (ret && new)\n\t\tocfs2_write_failure(inode, wc, user_pos, user_len);\n\nout:\n\n\treturn ret;\n}\n\nstatic int ocfs2_write_cluster_by_desc(struct address_space *mapping,\n\t\t\t\t       struct ocfs2_alloc_context *data_ac,\n\t\t\t\t       struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t       struct ocfs2_write_ctxt *wc,\n\t\t\t\t       loff_t pos, unsigned len)\n{\n\tint ret, i;\n\tloff_t cluster_off;\n\tunsigned int local_len = len;\n\tstruct ocfs2_write_cluster_desc *desc;\n\tstruct ocfs2_super *osb = OCFS2_SB(mapping->host->i_sb);\n\n\tfor (i = 0; i < wc->w_clen; i++) {\n\t\tdesc = &wc->w_desc[i];\n\n\t\t \n\t\tlocal_len = len;\n\t\tcluster_off = pos & (osb->s_clustersize - 1);\n\t\tif ((cluster_off + local_len) > osb->s_clustersize)\n\t\t\tlocal_len = osb->s_clustersize - cluster_off;\n\n\t\tret = ocfs2_write_cluster(mapping, &desc->c_phys,\n\t\t\t\t\t  desc->c_new,\n\t\t\t\t\t  desc->c_clear_unwritten,\n\t\t\t\t\t  desc->c_needs_zero,\n\t\t\t\t\t  data_ac, meta_ac,\n\t\t\t\t\t  wc, desc->c_cpos, pos, local_len);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tlen -= local_len;\n\t\tpos += local_len;\n\t}\n\n\tret = 0;\nout:\n\treturn ret;\n}\n\n \nstatic void ocfs2_set_target_boundaries(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_write_ctxt *wc,\n\t\t\t\t\tloff_t pos, unsigned len, int alloc)\n{\n\tstruct ocfs2_write_cluster_desc *desc;\n\n\twc->w_target_from = pos & (PAGE_SIZE - 1);\n\twc->w_target_to = wc->w_target_from + len;\n\n\tif (alloc == 0)\n\t\treturn;\n\n\t \n\n\tif (wc->w_large_pages) {\n\t\t \n\t\tdesc = &wc->w_desc[0];\n\t\tif (desc->c_needs_zero)\n\t\t\tocfs2_figure_cluster_boundaries(osb,\n\t\t\t\t\t\t\tdesc->c_cpos,\n\t\t\t\t\t\t\t&wc->w_target_from,\n\t\t\t\t\t\t\tNULL);\n\n\t\tdesc = &wc->w_desc[wc->w_clen - 1];\n\t\tif (desc->c_needs_zero)\n\t\t\tocfs2_figure_cluster_boundaries(osb,\n\t\t\t\t\t\t\tdesc->c_cpos,\n\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t&wc->w_target_to);\n\t} else {\n\t\twc->w_target_from = 0;\n\t\twc->w_target_to = PAGE_SIZE;\n\t}\n}\n\n \nstatic int ocfs2_unwritten_check(struct inode *inode,\n\t\t\t\t struct ocfs2_write_ctxt *wc,\n\t\t\t\t struct ocfs2_write_cluster_desc *desc)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_unwritten_extent *ue = NULL, *new = NULL;\n\tint ret = 0;\n\n\tif (!desc->c_needs_zero)\n\t\treturn 0;\n\nretry:\n\tspin_lock(&oi->ip_lock);\n\t \n\tlist_for_each_entry(ue, &oi->ip_unwritten_list, ue_ip_node) {\n\t\tif (desc->c_cpos == ue->ue_cpos) {\n\t\t\tBUG_ON(desc->c_new);\n\t\t\tdesc->c_needs_zero = 0;\n\t\t\tdesc->c_clear_unwritten = 0;\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tif (wc->w_type != OCFS2_WRITE_DIRECT)\n\t\tgoto unlock;\n\n\tif (new == NULL) {\n\t\tspin_unlock(&oi->ip_lock);\n\t\tnew = kmalloc(sizeof(struct ocfs2_unwritten_extent),\n\t\t\t     GFP_NOFS);\n\t\tif (new == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tgoto retry;\n\t}\n\t \n\tnew->ue_cpos = desc->c_cpos;\n\tnew->ue_phys = desc->c_phys;\n\tdesc->c_clear_unwritten = 0;\n\tlist_add_tail(&new->ue_ip_node, &oi->ip_unwritten_list);\n\tlist_add_tail(&new->ue_node, &wc->w_unwritten_list);\n\twc->w_unwritten_count++;\n\tnew = NULL;\nunlock:\n\tspin_unlock(&oi->ip_lock);\nout:\n\tkfree(new);\n\treturn ret;\n}\n\n \nstatic int ocfs2_populate_write_desc(struct inode *inode,\n\t\t\t\t     struct ocfs2_write_ctxt *wc,\n\t\t\t\t     unsigned int *clusters_to_alloc,\n\t\t\t\t     unsigned int *extents_to_split)\n{\n\tint ret;\n\tstruct ocfs2_write_cluster_desc *desc;\n\tunsigned int num_clusters = 0;\n\tunsigned int ext_flags = 0;\n\tu32 phys = 0;\n\tint i;\n\n\t*clusters_to_alloc = 0;\n\t*extents_to_split = 0;\n\n\tfor (i = 0; i < wc->w_clen; i++) {\n\t\tdesc = &wc->w_desc[i];\n\t\tdesc->c_cpos = wc->w_cpos + i;\n\n\t\tif (num_clusters == 0) {\n\t\t\t \n\t\t\tret = ocfs2_get_clusters(inode, desc->c_cpos, &phys,\n\t\t\t\t\t\t &num_clusters, &ext_flags);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t \n\t\t\tBUG_ON(ext_flags & OCFS2_EXT_REFCOUNTED);\n\n\t\t\t \n\t\t\tif (ext_flags & OCFS2_EXT_UNWRITTEN)\n\t\t\t\t*extents_to_split = *extents_to_split + 2;\n\t\t} else if (phys) {\n\t\t\t \n\t\t\tphys++;\n\t\t}\n\n\t\t \n\t\tif (desc->c_cpos >= wc->w_first_new_cpos) {\n\t\t\tBUG_ON(phys == 0);\n\t\t\tdesc->c_needs_zero = 1;\n\t\t}\n\n\t\tdesc->c_phys = phys;\n\t\tif (phys == 0) {\n\t\t\tdesc->c_new = 1;\n\t\t\tdesc->c_needs_zero = 1;\n\t\t\tdesc->c_clear_unwritten = 1;\n\t\t\t*clusters_to_alloc = *clusters_to_alloc + 1;\n\t\t}\n\n\t\tif (ext_flags & OCFS2_EXT_UNWRITTEN) {\n\t\t\tdesc->c_clear_unwritten = 1;\n\t\t\tdesc->c_needs_zero = 1;\n\t\t}\n\n\t\tret = ocfs2_unwritten_check(inode, wc, desc);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tnum_clusters--;\n\t}\n\n\tret = 0;\nout:\n\treturn ret;\n}\n\nstatic int ocfs2_write_begin_inline(struct address_space *mapping,\n\t\t\t\t    struct inode *inode,\n\t\t\t\t    struct ocfs2_write_ctxt *wc)\n{\n\tint ret;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct page *page;\n\thandle_t *handle;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)wc->w_di_bh->b_data;\n\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tpage = find_or_create_page(mapping, 0, GFP_NOFS);\n\tif (!page) {\n\t\tocfs2_commit_trans(osb, handle);\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\t \n\twc->w_pages[0] = wc->w_target_page = page;\n\twc->w_num_pages = 1;\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), wc->w_di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tocfs2_commit_trans(osb, handle);\n\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (!(OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL))\n\t\tocfs2_set_inode_data_inline(inode, di);\n\n\tif (!PageUptodate(page)) {\n\t\tret = ocfs2_read_inline_data(inode, page, wc->w_di_bh);\n\t\tif (ret) {\n\t\t\tocfs2_commit_trans(osb, handle);\n\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\twc->w_handle = handle;\nout:\n\treturn ret;\n}\n\nint ocfs2_size_fits_inline_data(struct buffer_head *di_bh, u64 new_size)\n{\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tif (new_size <= le16_to_cpu(di->id2.i_data.id_count))\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int ocfs2_try_to_write_inline_data(struct address_space *mapping,\n\t\t\t\t\t  struct inode *inode, loff_t pos,\n\t\t\t\t\t  unsigned len, struct page *mmap_page,\n\t\t\t\t\t  struct ocfs2_write_ctxt *wc)\n{\n\tint ret, written = 0;\n\tloff_t end = pos + len;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_dinode *di = NULL;\n\n\ttrace_ocfs2_try_to_write_inline_data((unsigned long long)oi->ip_blkno,\n\t\t\t\t\t     len, (unsigned long long)pos,\n\t\t\t\t\t     oi->ip_dyn_features);\n\n\t \n\tif (oi->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tif (mmap_page == NULL &&\n\t\t    ocfs2_size_fits_inline_data(wc->w_di_bh, end))\n\t\t\tgoto do_inline_write;\n\n\t\t \n\t\tret = ocfs2_convert_inline_data_to_extents(inode, wc->w_di_bh);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t \n\tif (oi->ip_clusters != 0 || i_size_read(inode) != 0)\n\t\treturn 0;\n\n\t \n\tdi = (struct ocfs2_dinode *)wc->w_di_bh->b_data;\n\tif (mmap_page ||\n\t    end > ocfs2_max_inline_data_with_xattr(inode->i_sb, di))\n\t\treturn 0;\n\ndo_inline_write:\n\tret = ocfs2_write_begin_inline(mapping, inode, wc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t \n\twritten = 1;\nout:\n\treturn written ? written : ret;\n}\n\n \nstatic int ocfs2_expand_nonsparse_inode(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *di_bh,\n\t\t\t\t\tloff_t pos, unsigned len,\n\t\t\t\t\tstruct ocfs2_write_ctxt *wc)\n{\n\tint ret;\n\tloff_t newsize = pos + len;\n\n\tBUG_ON(ocfs2_sparse_alloc(OCFS2_SB(inode->i_sb)));\n\n\tif (newsize <= i_size_read(inode))\n\t\treturn 0;\n\n\tret = ocfs2_extend_no_holes(inode, di_bh, newsize, pos);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\t \n\tif (wc)\n\t\twc->w_first_new_cpos =\n\t\t\tocfs2_clusters_for_bytes(inode->i_sb, i_size_read(inode));\n\n\treturn ret;\n}\n\nstatic int ocfs2_zero_tail(struct inode *inode, struct buffer_head *di_bh,\n\t\t\t   loff_t pos)\n{\n\tint ret = 0;\n\n\tBUG_ON(!ocfs2_sparse_alloc(OCFS2_SB(inode->i_sb)));\n\tif (pos > i_size_read(inode))\n\t\tret = ocfs2_zero_extend(inode, di_bh, pos);\n\n\treturn ret;\n}\n\nint ocfs2_write_begin_nolock(struct address_space *mapping,\n\t\t\t     loff_t pos, unsigned len, ocfs2_write_type_t type,\n\t\t\t     struct page **pagep, void **fsdata,\n\t\t\t     struct buffer_head *di_bh, struct page *mmap_page)\n{\n\tint ret, cluster_of_pages, credits = OCFS2_INODE_UPDATE_CREDITS;\n\tunsigned int clusters_to_alloc, extents_to_split, clusters_need = 0;\n\tstruct ocfs2_write_ctxt *wc;\n\tstruct inode *inode = mapping->host;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_alloc_context *data_ac = NULL;\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\thandle_t *handle;\n\tstruct ocfs2_extent_tree et;\n\tint try_free = 1, ret1;\n\ntry_again:\n\tret = ocfs2_alloc_write_ctxt(&wc, osb, pos, len, type, di_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tif (ocfs2_supports_inline_data(osb)) {\n\t\tret = ocfs2_try_to_write_inline_data(mapping, inode, pos, len,\n\t\t\t\t\t\t     mmap_page, wc);\n\t\tif (ret == 1) {\n\t\t\tret = 0;\n\t\t\tgoto success;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tif (type != OCFS2_WRITE_DIRECT) {\n\t\tif (ocfs2_sparse_alloc(osb))\n\t\t\tret = ocfs2_zero_tail(inode, di_bh, pos);\n\t\telse\n\t\t\tret = ocfs2_expand_nonsparse_inode(inode, di_bh, pos,\n\t\t\t\t\t\t\t   len, wc);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ocfs2_check_range_for_refcount(inode, pos, len);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t} else if (ret == 1) {\n\t\tclusters_need = wc->w_clen;\n\t\tret = ocfs2_refcount_cow(inode, di_bh,\n\t\t\t\t\t wc->w_cpos, wc->w_clen, UINT_MAX);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ocfs2_populate_write_desc(inode, wc, &clusters_to_alloc,\n\t\t\t\t\t&extents_to_split);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tclusters_need += clusters_to_alloc;\n\n\tdi = (struct ocfs2_dinode *)wc->w_di_bh->b_data;\n\n\ttrace_ocfs2_write_begin_nolock(\n\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t(long long)i_size_read(inode),\n\t\t\tle32_to_cpu(di->i_clusters),\n\t\t\tpos, len, type, mmap_page,\n\t\t\tclusters_to_alloc, extents_to_split);\n\n\t \n\tif (clusters_to_alloc || extents_to_split) {\n\t\t \n\t\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(inode),\n\t\t\t\t\t      wc->w_di_bh);\n\t\tret = ocfs2_lock_allocators(inode, &et,\n\t\t\t\t\t    clusters_to_alloc, extents_to_split,\n\t\t\t\t\t    &data_ac, &meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (data_ac)\n\t\t\tdata_ac->ac_resv = &OCFS2_I(inode)->ip_la_data_resv;\n\n\t\tcredits = ocfs2_calc_extend_credits(inode->i_sb,\n\t\t\t\t\t\t    &di->id2.i_list);\n\t} else if (type == OCFS2_WRITE_DIRECT)\n\t\t \n\t\tgoto success;\n\n\t \n\tif (wc->w_clen && (wc->w_desc[0].c_needs_zero ||\n\t\t\t   wc->w_desc[wc->w_clen - 1].c_needs_zero))\n\t\tcluster_of_pages = 1;\n\telse\n\t\tcluster_of_pages = 0;\n\n\tocfs2_set_target_boundaries(osb, wc, pos, len, cluster_of_pages);\n\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\twc->w_handle = handle;\n\n\tif (clusters_to_alloc) {\n\t\tret = dquot_alloc_space_nodirty(inode,\n\t\t\tocfs2_clusters_to_bytes(osb->sb, clusters_to_alloc));\n\t\tif (ret)\n\t\t\tgoto out_commit;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), wc->w_di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_quota;\n\t}\n\n\t \n\tret = ocfs2_grab_pages_for_write(mapping, wc, wc->w_cpos, pos, len,\n\t\t\t\t\t cluster_of_pages, mmap_page);\n\tif (ret) {\n\t\t \n\t\tif (type == OCFS2_WRITE_MMAP && ret == -EAGAIN) {\n\t\t\tBUG_ON(wc->w_target_page);\n\t\t\tret = 0;\n\t\t\tgoto out_quota;\n\t\t}\n\n\t\tmlog_errno(ret);\n\t\tgoto out_quota;\n\t}\n\n\tret = ocfs2_write_cluster_by_desc(mapping, data_ac, meta_ac, wc, pos,\n\t\t\t\t\t  len);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_quota;\n\t}\n\n\tif (data_ac)\n\t\tocfs2_free_alloc_context(data_ac);\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\nsuccess:\n\tif (pagep)\n\t\t*pagep = wc->w_target_page;\n\t*fsdata = wc;\n\treturn 0;\nout_quota:\n\tif (clusters_to_alloc)\n\t\tdquot_free_space(inode,\n\t\t\t  ocfs2_clusters_to_bytes(osb->sb, clusters_to_alloc));\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\nout:\n\t \n\tif (wc->w_target_locked)\n\t\tunlock_page(mmap_page);\n\n\tocfs2_free_write_ctxt(inode, wc);\n\n\tif (data_ac) {\n\t\tocfs2_free_alloc_context(data_ac);\n\t\tdata_ac = NULL;\n\t}\n\tif (meta_ac) {\n\t\tocfs2_free_alloc_context(meta_ac);\n\t\tmeta_ac = NULL;\n\t}\n\n\tif (ret == -ENOSPC && try_free) {\n\t\t \n\t\ttry_free = 0;\n\n\t\tret1 = ocfs2_try_to_free_truncate_log(osb, clusters_need);\n\t\tif (ret1 == 1)\n\t\t\tgoto try_again;\n\n\t\tif (ret1 < 0)\n\t\t\tmlog_errno(ret1);\n\t}\n\n\treturn ret;\n}\n\nstatic int ocfs2_write_begin(struct file *file, struct address_space *mapping,\n\t\t\t     loff_t pos, unsigned len,\n\t\t\t     struct page **pagep, void **fsdata)\n{\n\tint ret;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct inode *inode = mapping->host;\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t \n\tdown_write(&OCFS2_I(inode)->ip_alloc_sem);\n\n\tret = ocfs2_write_begin_nolock(mapping, pos, len, OCFS2_WRITE_BUFFER,\n\t\t\t\t       pagep, fsdata, di_bh, NULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_fail;\n\t}\n\n\tbrelse(di_bh);\n\n\treturn 0;\n\nout_fail:\n\tup_write(&OCFS2_I(inode)->ip_alloc_sem);\n\n\tbrelse(di_bh);\n\tocfs2_inode_unlock(inode, 1);\n\n\treturn ret;\n}\n\nstatic void ocfs2_write_end_inline(struct inode *inode, loff_t pos,\n\t\t\t\t   unsigned len, unsigned *copied,\n\t\t\t\t   struct ocfs2_dinode *di,\n\t\t\t\t   struct ocfs2_write_ctxt *wc)\n{\n\tvoid *kaddr;\n\n\tif (unlikely(*copied < len)) {\n\t\tif (!PageUptodate(wc->w_target_page)) {\n\t\t\t*copied = 0;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tkaddr = kmap_atomic(wc->w_target_page);\n\tmemcpy(di->id2.i_data.id_data + pos, kaddr + pos, *copied);\n\tkunmap_atomic(kaddr);\n\n\ttrace_ocfs2_write_end_inline(\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     (unsigned long long)pos, *copied,\n\t     le16_to_cpu(di->id2.i_data.id_count),\n\t     le16_to_cpu(di->i_dyn_features));\n}\n\nint ocfs2_write_end_nolock(struct address_space *mapping,\n\t\t\t   loff_t pos, unsigned len, unsigned copied, void *fsdata)\n{\n\tint i, ret;\n\tunsigned from, to, start = pos & (PAGE_SIZE - 1);\n\tstruct inode *inode = mapping->host;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_write_ctxt *wc = fsdata;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)wc->w_di_bh->b_data;\n\thandle_t *handle = wc->w_handle;\n\tstruct page *tmppage;\n\n\tBUG_ON(!list_empty(&wc->w_unwritten_list));\n\n\tif (handle) {\n\t\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode),\n\t\t\t\twc->w_di_bh, OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (ret) {\n\t\t\tcopied = ret;\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tocfs2_write_end_inline(inode, pos, len, &copied, di, wc);\n\t\tgoto out_write_size;\n\t}\n\n\tif (unlikely(copied < len) && wc->w_target_page) {\n\t\tloff_t new_isize;\n\n\t\tif (!PageUptodate(wc->w_target_page))\n\t\t\tcopied = 0;\n\n\t\tnew_isize = max_t(loff_t, i_size_read(inode), pos + copied);\n\t\tif (new_isize > page_offset(wc->w_target_page))\n\t\t\tocfs2_zero_new_buffers(wc->w_target_page, start+copied,\n\t\t\t\t\t       start+len);\n\t\telse {\n\t\t\t \n\t\t\tblock_invalidate_folio(page_folio(wc->w_target_page),\n\t\t\t\t\t\t0, PAGE_SIZE);\n\t\t}\n\t}\n\tif (wc->w_target_page)\n\t\tflush_dcache_page(wc->w_target_page);\n\n\tfor(i = 0; i < wc->w_num_pages; i++) {\n\t\ttmppage = wc->w_pages[i];\n\n\t\t \n\t\tif (tmppage == NULL)\n\t\t\tcontinue;\n\n\t\tif (tmppage == wc->w_target_page) {\n\t\t\tfrom = wc->w_target_from;\n\t\t\tto = wc->w_target_to;\n\n\t\t\tBUG_ON(from > PAGE_SIZE ||\n\t\t\t       to > PAGE_SIZE ||\n\t\t\t       to < from);\n\t\t} else {\n\t\t\t \n\t\t\tfrom = 0;\n\t\t\tto = PAGE_SIZE;\n\t\t}\n\n\t\tif (page_has_buffers(tmppage)) {\n\t\t\tif (handle && ocfs2_should_order_data(inode)) {\n\t\t\t\tloff_t start_byte =\n\t\t\t\t\t((loff_t)tmppage->index << PAGE_SHIFT) +\n\t\t\t\t\tfrom;\n\t\t\t\tloff_t length = to - from;\n\t\t\t\tocfs2_jbd2_inode_add_write(handle, inode,\n\t\t\t\t\t\t\t   start_byte, length);\n\t\t\t}\n\t\t\tblock_commit_write(tmppage, from, to);\n\t\t}\n\t}\n\nout_write_size:\n\t \n\tif (wc->w_type != OCFS2_WRITE_DIRECT) {\n\t\tpos += copied;\n\t\tif (pos > i_size_read(inode)) {\n\t\t\ti_size_write(inode, pos);\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\t\tdi->i_size = cpu_to_le64((u64)i_size_read(inode));\n\t\tinode->i_mtime = inode_set_ctime_current(inode);\n\t\tdi->i_mtime = di->i_ctime = cpu_to_le64(inode->i_mtime.tv_sec);\n\t\tdi->i_mtime_nsec = di->i_ctime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\t\tif (handle)\n\t\t\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\t}\n\tif (handle)\n\t\tocfs2_journal_dirty(handle, wc->w_di_bh);\n\nout:\n\t \n\tocfs2_unlock_pages(wc);\n\n\tif (handle)\n\t\tocfs2_commit_trans(osb, handle);\n\n\tocfs2_run_deallocs(osb, &wc->w_dealloc);\n\n\tbrelse(wc->w_di_bh);\n\tkfree(wc);\n\n\treturn copied;\n}\n\nstatic int ocfs2_write_end(struct file *file, struct address_space *mapping,\n\t\t\t   loff_t pos, unsigned len, unsigned copied,\n\t\t\t   struct page *page, void *fsdata)\n{\n\tint ret;\n\tstruct inode *inode = mapping->host;\n\n\tret = ocfs2_write_end_nolock(mapping, pos, len, copied, fsdata);\n\n\tup_write(&OCFS2_I(inode)->ip_alloc_sem);\n\tocfs2_inode_unlock(inode, 1);\n\n\treturn ret;\n}\n\nstruct ocfs2_dio_write_ctxt {\n\tstruct list_head\tdw_zero_list;\n\tunsigned\t\tdw_zero_count;\n\tint\t\t\tdw_orphaned;\n\tpid_t\t\t\tdw_writer_pid;\n};\n\nstatic struct ocfs2_dio_write_ctxt *\nocfs2_dio_alloc_write_ctx(struct buffer_head *bh, int *alloc)\n{\n\tstruct ocfs2_dio_write_ctxt *dwc = NULL;\n\n\tif (bh->b_private)\n\t\treturn bh->b_private;\n\n\tdwc = kmalloc(sizeof(struct ocfs2_dio_write_ctxt), GFP_NOFS);\n\tif (dwc == NULL)\n\t\treturn NULL;\n\tINIT_LIST_HEAD(&dwc->dw_zero_list);\n\tdwc->dw_zero_count = 0;\n\tdwc->dw_orphaned = 0;\n\tdwc->dw_writer_pid = task_pid_nr(current);\n\tbh->b_private = dwc;\n\t*alloc = 1;\n\n\treturn dwc;\n}\n\nstatic void ocfs2_dio_free_write_ctx(struct inode *inode,\n\t\t\t\t     struct ocfs2_dio_write_ctxt *dwc)\n{\n\tocfs2_free_unwritten_list(inode, &dwc->dw_zero_list);\n\tkfree(dwc);\n}\n\n \nstatic int ocfs2_dio_wr_get_block(struct inode *inode, sector_t iblock,\n\t\t\t       struct buffer_head *bh_result, int create)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_write_ctxt *wc;\n\tstruct ocfs2_write_cluster_desc *desc = NULL;\n\tstruct ocfs2_dio_write_ctxt *dwc = NULL;\n\tstruct buffer_head *di_bh = NULL;\n\tu64 p_blkno;\n\tunsigned int i_blkbits = inode->i_sb->s_blocksize_bits;\n\tloff_t pos = iblock << i_blkbits;\n\tsector_t endblk = (i_size_read(inode) - 1) >> i_blkbits;\n\tunsigned len, total_len = bh_result->b_size;\n\tint ret = 0, first_get_block = 0;\n\n\tlen = osb->s_clustersize - (pos & (osb->s_clustersize - 1));\n\tlen = min(total_len, len);\n\n\t \n\n\tif ((iblock <= endblk) &&\n\t    ((iblock + ((len - 1) >> i_blkbits)) > endblk))\n\t\tlen = (endblk - iblock + 1) << i_blkbits;\n\n\tmlog(0, \"get block of %lu at %llu:%u req %u\\n\",\n\t\t\tinode->i_ino, pos, len, total_len);\n\n\t \n\tif (pos + total_len <= i_size_read(inode)) {\n\n\t\t \n\t\tret = ocfs2_lock_get_block(inode, iblock, bh_result, create);\n\t\tif (buffer_mapped(bh_result) &&\n\t\t    !buffer_new(bh_result) &&\n\t\t    ret == 0)\n\t\t\tgoto out;\n\n\t\t \n\t\tbh_result->b_state = 0;\n\t}\n\n\tdwc = ocfs2_dio_alloc_write_ctx(bh_result, &first_get_block);\n\tif (unlikely(dwc == NULL)) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (ocfs2_clusters_for_bytes(inode->i_sb, pos + total_len) >\n\t    ocfs2_clusters_for_bytes(inode->i_sb, i_size_read(inode)) &&\n\t    !dwc->dw_orphaned) {\n\t\t \n\t\tret = ocfs2_add_inode_to_orphan(osb, inode);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tdwc->dw_orphaned = 1;\n\t}\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdown_write(&oi->ip_alloc_sem);\n\n\tif (first_get_block) {\n\t\tif (ocfs2_sparse_alloc(osb))\n\t\t\tret = ocfs2_zero_tail(inode, di_bh, pos);\n\t\telse\n\t\t\tret = ocfs2_expand_nonsparse_inode(inode, di_bh, pos,\n\t\t\t\t\t\t\t   total_len, NULL);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tret = ocfs2_write_begin_nolock(inode->i_mapping, pos, len,\n\t\t\t\t       OCFS2_WRITE_DIRECT, NULL,\n\t\t\t\t       (void **)&wc, di_bh, NULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto unlock;\n\t}\n\n\tdesc = &wc->w_desc[0];\n\n\tp_blkno = ocfs2_clusters_to_blocks(inode->i_sb, desc->c_phys);\n\tBUG_ON(p_blkno == 0);\n\tp_blkno += iblock & (u64)(ocfs2_clusters_to_blocks(inode->i_sb, 1) - 1);\n\n\tmap_bh(bh_result, inode->i_sb, p_blkno);\n\tbh_result->b_size = len;\n\tif (desc->c_needs_zero)\n\t\tset_buffer_new(bh_result);\n\n\tif (iblock > endblk)\n\t\tset_buffer_new(bh_result);\n\n\t \n\tset_buffer_defer_completion(bh_result);\n\n\tif (!list_empty(&wc->w_unwritten_list)) {\n\t\tstruct ocfs2_unwritten_extent *ue = NULL;\n\n\t\tue = list_first_entry(&wc->w_unwritten_list,\n\t\t\t\t      struct ocfs2_unwritten_extent,\n\t\t\t\t      ue_node);\n\t\tBUG_ON(ue->ue_cpos != desc->c_cpos);\n\t\t \n\t\tue->ue_phys = desc->c_phys;\n\n\t\tlist_splice_tail_init(&wc->w_unwritten_list, &dwc->dw_zero_list);\n\t\tdwc->dw_zero_count += wc->w_unwritten_count;\n\t}\n\n\tret = ocfs2_write_end_nolock(inode->i_mapping, pos, len, len, wc);\n\tBUG_ON(ret != len);\n\tret = 0;\nunlock:\n\tup_write(&oi->ip_alloc_sem);\n\tocfs2_inode_unlock(inode, 1);\n\tbrelse(di_bh);\nout:\n\tif (ret < 0)\n\t\tret = -EIO;\n\treturn ret;\n}\n\nstatic int ocfs2_dio_end_io_write(struct inode *inode,\n\t\t\t\t  struct ocfs2_dio_write_ctxt *dwc,\n\t\t\t\t  loff_t offset,\n\t\t\t\t  ssize_t bytes)\n{\n\tstruct ocfs2_cached_dealloc_ctxt dealloc;\n\tstruct ocfs2_extent_tree et;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_unwritten_extent *ue = NULL;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_alloc_context *data_ac = NULL;\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\thandle_t *handle = NULL;\n\tloff_t end = offset + bytes;\n\tint ret = 0, credits = 0;\n\n\tocfs2_init_dealloc_ctxt(&dealloc);\n\n\t \n\tif (list_empty(&dwc->dw_zero_list) &&\n\t    end <= i_size_read(inode) &&\n\t    !dwc->dw_orphaned)\n\t\tgoto out;\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdown_write(&oi->ip_alloc_sem);\n\n\t \n\tif (dwc->dw_orphaned) {\n\t\tBUG_ON(dwc->dw_writer_pid != task_pid_nr(current));\n\n\t\tend = end > i_size_read(inode) ? end : 0;\n\n\t\tret = ocfs2_del_inode_from_orphan(osb, inode, di_bh,\n\t\t\t\t!!end, end);\n\t\tif (ret < 0)\n\t\t\tmlog_errno(ret);\n\t}\n\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(inode), di_bh);\n\n\t \n\tet.et_dealloc = &dealloc;\n\n\tret = ocfs2_lock_allocators(inode, &et, 0, dwc->dw_zero_count*2,\n\t\t\t\t    &data_ac, &meta_ac);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto unlock;\n\t}\n\n\tcredits = ocfs2_calc_extend_credits(inode->i_sb, &di->id2.i_list);\n\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto unlock;\n\t}\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto commit;\n\t}\n\n\tlist_for_each_entry(ue, &dwc->dw_zero_list, ue_node) {\n\t\tret = ocfs2_mark_extent_written(inode, &et, handle,\n\t\t\t\t\t\tue->ue_cpos, 1,\n\t\t\t\t\t\tue->ue_phys,\n\t\t\t\t\t\tmeta_ac, &dealloc);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (end > i_size_read(inode)) {\n\t\tret = ocfs2_set_inode_size(handle, inode, di_bh, end);\n\t\tif (ret < 0)\n\t\t\tmlog_errno(ret);\n\t}\ncommit:\n\tocfs2_commit_trans(osb, handle);\nunlock:\n\tup_write(&oi->ip_alloc_sem);\n\tocfs2_inode_unlock(inode, 1);\n\tbrelse(di_bh);\nout:\n\tif (data_ac)\n\t\tocfs2_free_alloc_context(data_ac);\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\tocfs2_run_deallocs(osb, &dealloc);\n\tocfs2_dio_free_write_ctx(inode, dwc);\n\n\treturn ret;\n}\n\n \nstatic int ocfs2_dio_end_io(struct kiocb *iocb,\n\t\t\t    loff_t offset,\n\t\t\t    ssize_t bytes,\n\t\t\t    void *private)\n{\n\tstruct inode *inode = file_inode(iocb->ki_filp);\n\tint level;\n\tint ret = 0;\n\n\t \n\tBUG_ON(!ocfs2_iocb_is_rw_locked(iocb));\n\n\tif (bytes <= 0)\n\t\tmlog_ratelimited(ML_ERROR, \"Direct IO failed, bytes = %lld\",\n\t\t\t\t (long long)bytes);\n\tif (private) {\n\t\tif (bytes > 0)\n\t\t\tret = ocfs2_dio_end_io_write(inode, private, offset,\n\t\t\t\t\t\t     bytes);\n\t\telse\n\t\t\tocfs2_dio_free_write_ctx(inode, private);\n\t}\n\n\tocfs2_iocb_clear_rw_locked(iocb);\n\n\tlevel = ocfs2_iocb_rw_locked_level(iocb);\n\tocfs2_rw_unlock(inode, level);\n\treturn ret;\n}\n\nstatic ssize_t ocfs2_direct_IO(struct kiocb *iocb, struct iov_iter *iter)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tget_block_t *get_block;\n\n\t \n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\treturn 0;\n\n\t \n\tif (iocb->ki_pos + iter->count > i_size_read(inode) &&\n\t    !ocfs2_supports_append_dio(osb))\n\t\treturn 0;\n\n\tif (iov_iter_rw(iter) == READ)\n\t\tget_block = ocfs2_lock_get_block;\n\telse\n\t\tget_block = ocfs2_dio_wr_get_block;\n\n\treturn __blockdev_direct_IO(iocb, inode, inode->i_sb->s_bdev,\n\t\t\t\t    iter, get_block,\n\t\t\t\t    ocfs2_dio_end_io, 0);\n}\n\nconst struct address_space_operations ocfs2_aops = {\n\t.dirty_folio\t\t= block_dirty_folio,\n\t.read_folio\t\t= ocfs2_read_folio,\n\t.readahead\t\t= ocfs2_readahead,\n\t.writepage\t\t= ocfs2_writepage,\n\t.write_begin\t\t= ocfs2_write_begin,\n\t.write_end\t\t= ocfs2_write_end,\n\t.bmap\t\t\t= ocfs2_bmap,\n\t.direct_IO\t\t= ocfs2_direct_IO,\n\t.invalidate_folio\t= block_invalidate_folio,\n\t.release_folio\t\t= ocfs2_release_folio,\n\t.migrate_folio\t\t= buffer_migrate_folio,\n\t.is_partially_uptodate\t= block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}