{
  "module_name": "ioctl.c",
  "hash_id": "773199d880d060dd0205260f1d930a6d377ffdf0c00bb63b49c7b0d3f09038c4",
  "original_prompt": "Ingested from linux-6.6.14/fs/ocfs2/ioctl.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/compat.h>\n#include <linux/fileattr.h>\n\n#include <cluster/masklog.h>\n\n#include \"ocfs2.h\"\n#include \"alloc.h\"\n#include \"dlmglue.h\"\n#include \"file.h\"\n#include \"inode.h\"\n#include \"journal.h\"\n\n#include \"ocfs2_fs.h\"\n#include \"ioctl.h\"\n#include \"resize.h\"\n#include \"refcounttree.h\"\n#include \"sysfile.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"move_extents.h\"\n\n#define o2info_from_user(a, b)\t\\\n\t\tcopy_from_user(&(a), (b), sizeof(a))\n#define o2info_to_user(a, b)\t\\\n\t\tcopy_to_user((typeof(a) __user *)b, &(a), sizeof(a))\n\n \nstatic inline void o2info_set_request_error(struct ocfs2_info_request *kreq,\n\t\t\t\t\tstruct ocfs2_info_request __user *req)\n{\n\tkreq->ir_flags |= OCFS2_INFO_FL_ERROR;\n\t(void)put_user(kreq->ir_flags, (__u32 __user *)&(req->ir_flags));\n}\n\nstatic inline void o2info_set_request_filled(struct ocfs2_info_request *req)\n{\n\treq->ir_flags |= OCFS2_INFO_FL_FILLED;\n}\n\nstatic inline void o2info_clear_request_filled(struct ocfs2_info_request *req)\n{\n\treq->ir_flags &= ~OCFS2_INFO_FL_FILLED;\n}\n\nstatic inline int o2info_coherent(struct ocfs2_info_request *req)\n{\n\treturn (!(req->ir_flags & OCFS2_INFO_FL_NON_COHERENT));\n}\n\nint ocfs2_fileattr_get(struct dentry *dentry, struct fileattr *fa)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tunsigned int flags;\n\tint status;\n\n\tstatus = ocfs2_inode_lock(inode, NULL, 0);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\tocfs2_get_inode_flags(OCFS2_I(inode));\n\tflags = OCFS2_I(inode)->ip_attr;\n\tocfs2_inode_unlock(inode, 0);\n\n\tfileattr_fill_flags(fa, flags & OCFS2_FL_VISIBLE);\n\n\treturn status;\n}\n\nint ocfs2_fileattr_set(struct mnt_idmap *idmap,\n\t\t       struct dentry *dentry, struct fileattr *fa)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tunsigned int flags = fa->flags;\n\tstruct ocfs2_inode_info *ocfs2_inode = OCFS2_I(inode);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\thandle_t *handle = NULL;\n\tstruct buffer_head *bh = NULL;\n\tunsigned oldflags;\n\tint status;\n\n\tif (fileattr_has_fsx(fa))\n\t\treturn -EOPNOTSUPP;\n\n\tstatus = ocfs2_inode_lock(inode, &bh, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tif (!S_ISDIR(inode->i_mode))\n\t\tflags &= ~OCFS2_DIRSYNC_FL;\n\n\toldflags = ocfs2_inode->ip_attr;\n\tflags = flags & OCFS2_FL_MODIFIABLE;\n\tflags |= oldflags & ~OCFS2_FL_MODIFIABLE;\n\n\t \n\tstatus = -EPERM;\n\tif ((flags ^ oldflags) & (FS_APPEND_FL | FS_IMMUTABLE_FL) &&\n\t    !capable(CAP_LINUX_IMMUTABLE))\n\t\tgoto bail_unlock;\n\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\tgoto bail_unlock;\n\t}\n\n\tocfs2_inode->ip_attr = flags;\n\tocfs2_set_inode_flags(inode);\n\n\tstatus = ocfs2_mark_inode_dirty(handle, inode, bh);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\tocfs2_commit_trans(osb, handle);\n\nbail_unlock:\n\tocfs2_inode_unlock(inode, 1);\nbail:\n\tbrelse(bh);\n\n\treturn status;\n}\n\nstatic int ocfs2_info_handle_blocksize(struct inode *inode,\n\t\t\t\t       struct ocfs2_info_request __user *req)\n{\n\tstruct ocfs2_info_blocksize oib;\n\n\tif (o2info_from_user(oib, req))\n\t\treturn -EFAULT;\n\n\toib.ib_blocksize = inode->i_sb->s_blocksize;\n\n\to2info_set_request_filled(&oib.ib_req);\n\n\tif (o2info_to_user(oib, req))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int ocfs2_info_handle_clustersize(struct inode *inode,\n\t\t\t\t\t struct ocfs2_info_request __user *req)\n{\n\tstruct ocfs2_info_clustersize oic;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (o2info_from_user(oic, req))\n\t\treturn -EFAULT;\n\n\toic.ic_clustersize = osb->s_clustersize;\n\n\to2info_set_request_filled(&oic.ic_req);\n\n\tif (o2info_to_user(oic, req))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int ocfs2_info_handle_maxslots(struct inode *inode,\n\t\t\t\t      struct ocfs2_info_request __user *req)\n{\n\tstruct ocfs2_info_maxslots oim;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (o2info_from_user(oim, req))\n\t\treturn -EFAULT;\n\n\toim.im_max_slots = osb->max_slots;\n\n\to2info_set_request_filled(&oim.im_req);\n\n\tif (o2info_to_user(oim, req))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int ocfs2_info_handle_label(struct inode *inode,\n\t\t\t\t   struct ocfs2_info_request __user *req)\n{\n\tstruct ocfs2_info_label oil;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (o2info_from_user(oil, req))\n\t\treturn -EFAULT;\n\n\tmemcpy(oil.il_label, osb->vol_label, OCFS2_MAX_VOL_LABEL_LEN);\n\n\to2info_set_request_filled(&oil.il_req);\n\n\tif (o2info_to_user(oil, req))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int ocfs2_info_handle_uuid(struct inode *inode,\n\t\t\t\t  struct ocfs2_info_request __user *req)\n{\n\tstruct ocfs2_info_uuid oiu;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (o2info_from_user(oiu, req))\n\t\treturn -EFAULT;\n\n\tmemcpy(oiu.iu_uuid_str, osb->uuid_str, OCFS2_TEXT_UUID_LEN + 1);\n\n\to2info_set_request_filled(&oiu.iu_req);\n\n\tif (o2info_to_user(oiu, req))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int ocfs2_info_handle_fs_features(struct inode *inode,\n\t\t\t\t\t struct ocfs2_info_request __user *req)\n{\n\tstruct ocfs2_info_fs_features oif;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (o2info_from_user(oif, req))\n\t\treturn -EFAULT;\n\n\toif.if_compat_features = osb->s_feature_compat;\n\toif.if_incompat_features = osb->s_feature_incompat;\n\toif.if_ro_compat_features = osb->s_feature_ro_compat;\n\n\to2info_set_request_filled(&oif.if_req);\n\n\tif (o2info_to_user(oif, req))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int ocfs2_info_handle_journal_size(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_info_request __user *req)\n{\n\tstruct ocfs2_info_journal_size oij;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (o2info_from_user(oij, req))\n\t\treturn -EFAULT;\n\n\toij.ij_journal_size = i_size_read(osb->journal->j_inode);\n\n\to2info_set_request_filled(&oij.ij_req);\n\n\tif (o2info_to_user(oij, req))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int ocfs2_info_scan_inode_alloc(struct ocfs2_super *osb,\n\t\t\t\t       struct inode *inode_alloc, u64 blkno,\n\t\t\t\t       struct ocfs2_info_freeinode *fi,\n\t\t\t\t       u32 slot)\n{\n\tint status = 0, unlock = 0;\n\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_dinode *dinode_alloc = NULL;\n\n\tif (inode_alloc)\n\t\tinode_lock(inode_alloc);\n\n\tif (inode_alloc && o2info_coherent(&fi->ifi_req)) {\n\t\tstatus = ocfs2_inode_lock(inode_alloc, &bh, 0);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tunlock = 1;\n\t} else {\n\t\tstatus = ocfs2_read_blocks_sync(osb, blkno, 1, &bh);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tdinode_alloc = (struct ocfs2_dinode *)bh->b_data;\n\n\tfi->ifi_stat[slot].lfi_total =\n\t\tle32_to_cpu(dinode_alloc->id1.bitmap1.i_total);\n\tfi->ifi_stat[slot].lfi_free =\n\t\tle32_to_cpu(dinode_alloc->id1.bitmap1.i_total) -\n\t\tle32_to_cpu(dinode_alloc->id1.bitmap1.i_used);\n\nbail:\n\tif (unlock)\n\t\tocfs2_inode_unlock(inode_alloc, 0);\n\n\tif (inode_alloc)\n\t\tinode_unlock(inode_alloc);\n\n\tbrelse(bh);\n\n\treturn status;\n}\n\nstatic int ocfs2_info_handle_freeinode(struct inode *inode,\n\t\t\t\t       struct ocfs2_info_request __user *req)\n{\n\tu32 i;\n\tu64 blkno = -1;\n\tchar namebuf[40];\n\tint status, type = INODE_ALLOC_SYSTEM_INODE;\n\tstruct ocfs2_info_freeinode *oifi = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct inode *inode_alloc = NULL;\n\n\toifi = kzalloc(sizeof(struct ocfs2_info_freeinode), GFP_KERNEL);\n\tif (!oifi) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto out_err;\n\t}\n\n\tif (o2info_from_user(*oifi, req)) {\n\t\tstatus = -EFAULT;\n\t\tgoto out_free;\n\t}\n\n\toifi->ifi_slotnum = osb->max_slots;\n\n\tfor (i = 0; i < oifi->ifi_slotnum; i++) {\n\t\tif (o2info_coherent(&oifi->ifi_req)) {\n\t\t\tinode_alloc = ocfs2_get_system_file_inode(osb, type, i);\n\t\t\tif (!inode_alloc) {\n\t\t\t\tmlog(ML_ERROR, \"unable to get alloc inode in \"\n\t\t\t\t    \"slot %u\\n\", i);\n\t\t\t\tstatus = -EIO;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t} else {\n\t\t\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\t\t\ttype, i);\n\t\t\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode,\n\t\t\t\t\t\t\t    namebuf,\n\t\t\t\t\t\t\t    strlen(namebuf),\n\t\t\t\t\t\t\t    &blkno);\n\t\t\tif (status < 0) {\n\t\t\t\tstatus = -ENOENT;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\n\t\tstatus = ocfs2_info_scan_inode_alloc(osb, inode_alloc, blkno, oifi, i);\n\n\t\tiput(inode_alloc);\n\t\tinode_alloc = NULL;\n\n\t\tif (status < 0)\n\t\t\tgoto bail;\n\t}\n\n\to2info_set_request_filled(&oifi->ifi_req);\n\n\tif (o2info_to_user(*oifi, req)) {\n\t\tstatus = -EFAULT;\n\t\tgoto out_free;\n\t}\n\n\tstatus = 0;\nbail:\n\tif (status)\n\t\to2info_set_request_error(&oifi->ifi_req, req);\nout_free:\n\tkfree(oifi);\nout_err:\n\treturn status;\n}\n\nstatic void o2ffg_update_histogram(struct ocfs2_info_free_chunk_list *hist,\n\t\t\t\t   unsigned int chunksize)\n{\n\tu32 index;\n\n\tindex = __ilog2_u32(chunksize);\n\tif (index >= OCFS2_INFO_MAX_HIST)\n\t\tindex = OCFS2_INFO_MAX_HIST - 1;\n\n\thist->fc_chunks[index]++;\n\thist->fc_clusters[index] += chunksize;\n}\n\nstatic void o2ffg_update_stats(struct ocfs2_info_freefrag_stats *stats,\n\t\t\t       unsigned int chunksize)\n{\n\tif (chunksize > stats->ffs_max)\n\t\tstats->ffs_max = chunksize;\n\n\tif (chunksize < stats->ffs_min)\n\t\tstats->ffs_min = chunksize;\n\n\tstats->ffs_avg += chunksize;\n\tstats->ffs_free_chunks_real++;\n}\n\nstatic void ocfs2_info_update_ffg(struct ocfs2_info_freefrag *ffg,\n\t\t\t\t  unsigned int chunksize)\n{\n\to2ffg_update_histogram(&(ffg->iff_ffs.ffs_fc_hist), chunksize);\n\to2ffg_update_stats(&(ffg->iff_ffs), chunksize);\n}\n\nstatic int ocfs2_info_freefrag_scan_chain(struct ocfs2_super *osb,\n\t\t\t\t\t  struct inode *gb_inode,\n\t\t\t\t\t  struct ocfs2_dinode *gb_dinode,\n\t\t\t\t\t  struct ocfs2_chain_rec *rec,\n\t\t\t\t\t  struct ocfs2_info_freefrag *ffg,\n\t\t\t\t\t  u32 chunks_in_group)\n{\n\tint status = 0, used;\n\tu64 blkno;\n\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_group_desc *bg = NULL;\n\n\tunsigned int max_bits, num_clusters;\n\tunsigned int offset = 0, cluster, chunk;\n\tunsigned int chunk_free, last_chunksize = 0;\n\n\tif (!le32_to_cpu(rec->c_free))\n\t\tgoto bail;\n\n\tdo {\n\t\tif (!bg)\n\t\t\tblkno = le64_to_cpu(rec->c_blkno);\n\t\telse\n\t\t\tblkno = le64_to_cpu(bg->bg_next_group);\n\n\t\tif (bh) {\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t}\n\n\t\tif (o2info_coherent(&ffg->iff_req))\n\t\t\tstatus = ocfs2_read_group_descriptor(gb_inode,\n\t\t\t\t\t\t\t     gb_dinode,\n\t\t\t\t\t\t\t     blkno, &bh);\n\t\telse\n\t\t\tstatus = ocfs2_read_blocks_sync(osb, blkno, 1, &bh);\n\n\t\tif (status < 0) {\n\t\t\tmlog(ML_ERROR, \"Can't read the group descriptor # \"\n\t\t\t     \"%llu from device.\", (unsigned long long)blkno);\n\t\t\tstatus = -EIO;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tbg = (struct ocfs2_group_desc *)bh->b_data;\n\n\t\tif (!le16_to_cpu(bg->bg_free_bits_count))\n\t\t\tcontinue;\n\n\t\tmax_bits = le16_to_cpu(bg->bg_bits);\n\t\toffset = 0;\n\n\t\tfor (chunk = 0; chunk < chunks_in_group; chunk++) {\n\t\t\t \n\t\t\tif ((offset + ffg->iff_chunksize) > max_bits)\n\t\t\t\tnum_clusters = max_bits - offset;\n\t\t\telse\n\t\t\t\tnum_clusters = ffg->iff_chunksize;\n\n\t\t\tchunk_free = 0;\n\t\t\tfor (cluster = 0; cluster < num_clusters; cluster++) {\n\t\t\t\tused = ocfs2_test_bit(offset,\n\t\t\t\t\t\t(unsigned long *)bg->bg_bitmap);\n\t\t\t\t \n\t\t\t\tif (!used) {\n\t\t\t\t\tlast_chunksize++;\n\t\t\t\t\tchunk_free++;\n\t\t\t\t}\n\n\t\t\t\tif (used && last_chunksize) {\n\t\t\t\t\tocfs2_info_update_ffg(ffg,\n\t\t\t\t\t\t\t      last_chunksize);\n\t\t\t\t\tlast_chunksize = 0;\n\t\t\t\t}\n\n\t\t\t\toffset++;\n\t\t\t}\n\n\t\t\tif (chunk_free == ffg->iff_chunksize)\n\t\t\t\tffg->iff_ffs.ffs_free_chunks++;\n\t\t}\n\n\t\t \n\t\tif (last_chunksize)\n\t\t\tocfs2_info_update_ffg(ffg, last_chunksize);\n\n\t} while (le64_to_cpu(bg->bg_next_group));\n\nbail:\n\tbrelse(bh);\n\n\treturn status;\n}\n\nstatic int ocfs2_info_freefrag_scan_bitmap(struct ocfs2_super *osb,\n\t\t\t\t\t   struct inode *gb_inode, u64 blkno,\n\t\t\t\t\t   struct ocfs2_info_freefrag *ffg)\n{\n\tu32 chunks_in_group;\n\tint status = 0, unlock = 0, i;\n\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_chain_list *cl = NULL;\n\tstruct ocfs2_chain_rec *rec = NULL;\n\tstruct ocfs2_dinode *gb_dinode = NULL;\n\n\tif (gb_inode)\n\t\tinode_lock(gb_inode);\n\n\tif (o2info_coherent(&ffg->iff_req)) {\n\t\tstatus = ocfs2_inode_lock(gb_inode, &bh, 0);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tunlock = 1;\n\t} else {\n\t\tstatus = ocfs2_read_blocks_sync(osb, blkno, 1, &bh);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tgb_dinode = (struct ocfs2_dinode *)bh->b_data;\n\tcl = &(gb_dinode->id2.i_chain);\n\n\t \n\tif (ffg->iff_chunksize > le16_to_cpu(cl->cl_cpg)) {\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tmemset(&ffg->iff_ffs, 0, sizeof(struct ocfs2_info_freefrag_stats));\n\n\tffg->iff_ffs.ffs_min = ~0U;\n\tffg->iff_ffs.ffs_clusters =\n\t\t\tle32_to_cpu(gb_dinode->id1.bitmap1.i_total);\n\tffg->iff_ffs.ffs_free_clusters = ffg->iff_ffs.ffs_clusters -\n\t\t\tle32_to_cpu(gb_dinode->id1.bitmap1.i_used);\n\n\tchunks_in_group = le16_to_cpu(cl->cl_cpg) / ffg->iff_chunksize + 1;\n\n\tfor (i = 0; i < le16_to_cpu(cl->cl_next_free_rec); i++) {\n\t\trec = &(cl->cl_recs[i]);\n\t\tstatus = ocfs2_info_freefrag_scan_chain(osb, gb_inode,\n\t\t\t\t\t\t\tgb_dinode,\n\t\t\t\t\t\t\trec, ffg,\n\t\t\t\t\t\t\tchunks_in_group);\n\t\tif (status)\n\t\t\tgoto bail;\n\t}\n\n\tif (ffg->iff_ffs.ffs_free_chunks_real)\n\t\tffg->iff_ffs.ffs_avg = (ffg->iff_ffs.ffs_avg /\n\t\t\t\t\tffg->iff_ffs.ffs_free_chunks_real);\nbail:\n\tif (unlock)\n\t\tocfs2_inode_unlock(gb_inode, 0);\n\n\tif (gb_inode)\n\t\tinode_unlock(gb_inode);\n\n\tiput(gb_inode);\n\tbrelse(bh);\n\n\treturn status;\n}\n\nstatic int ocfs2_info_handle_freefrag(struct inode *inode,\n\t\t\t\t      struct ocfs2_info_request __user *req)\n{\n\tu64 blkno = -1;\n\tchar namebuf[40];\n\tint status, type = GLOBAL_BITMAP_SYSTEM_INODE;\n\n\tstruct ocfs2_info_freefrag *oiff;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct inode *gb_inode = NULL;\n\n\toiff = kzalloc(sizeof(struct ocfs2_info_freefrag), GFP_KERNEL);\n\tif (!oiff) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto out_err;\n\t}\n\n\tif (o2info_from_user(*oiff, req)) {\n\t\tstatus = -EFAULT;\n\t\tgoto out_free;\n\t}\n\t \n\tif ((oiff->iff_chunksize & (oiff->iff_chunksize - 1)) ||\n\t    (!oiff->iff_chunksize)) {\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tif (o2info_coherent(&oiff->iff_req)) {\n\t\tgb_inode = ocfs2_get_system_file_inode(osb, type,\n\t\t\t\t\t\t       OCFS2_INVALID_SLOT);\n\t\tif (!gb_inode) {\n\t\t\tmlog(ML_ERROR, \"unable to get global_bitmap inode\\n\");\n\t\t\tstatus = -EIO;\n\t\t\tgoto bail;\n\t\t}\n\t} else {\n\t\tocfs2_sprintf_system_inode_name(namebuf, sizeof(namebuf), type,\n\t\t\t\t\t\tOCFS2_INVALID_SLOT);\n\t\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode,\n\t\t\t\t\t\t    namebuf,\n\t\t\t\t\t\t    strlen(namebuf),\n\t\t\t\t\t\t    &blkno);\n\t\tif (status < 0) {\n\t\t\tstatus = -ENOENT;\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = ocfs2_info_freefrag_scan_bitmap(osb, gb_inode, blkno, oiff);\n\tif (status < 0)\n\t\tgoto bail;\n\n\to2info_set_request_filled(&oiff->iff_req);\n\n\tif (o2info_to_user(*oiff, req)) {\n\t\tstatus = -EFAULT;\n\t\tgoto out_free;\n\t}\n\n\tstatus = 0;\nbail:\n\tif (status)\n\t\to2info_set_request_error(&oiff->iff_req, req);\nout_free:\n\tkfree(oiff);\nout_err:\n\treturn status;\n}\n\nstatic int ocfs2_info_handle_unknown(struct inode *inode,\n\t\t\t\t     struct ocfs2_info_request __user *req)\n{\n\tstruct ocfs2_info_request oir;\n\n\tif (o2info_from_user(oir, req))\n\t\treturn -EFAULT;\n\n\to2info_clear_request_filled(&oir);\n\n\tif (o2info_to_user(oir, req))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n \nstatic int ocfs2_info_handle_request(struct inode *inode,\n\t\t\t\t     struct ocfs2_info_request __user *req)\n{\n\tint status = -EFAULT;\n\tstruct ocfs2_info_request oir;\n\n\tif (o2info_from_user(oir, req))\n\t\tgoto bail;\n\n\tstatus = -EINVAL;\n\tif (oir.ir_magic != OCFS2_INFO_MAGIC)\n\t\tgoto bail;\n\n\tswitch (oir.ir_code) {\n\tcase OCFS2_INFO_BLOCKSIZE:\n\t\tif (oir.ir_size == sizeof(struct ocfs2_info_blocksize))\n\t\t\tstatus = ocfs2_info_handle_blocksize(inode, req);\n\t\tbreak;\n\tcase OCFS2_INFO_CLUSTERSIZE:\n\t\tif (oir.ir_size == sizeof(struct ocfs2_info_clustersize))\n\t\t\tstatus = ocfs2_info_handle_clustersize(inode, req);\n\t\tbreak;\n\tcase OCFS2_INFO_MAXSLOTS:\n\t\tif (oir.ir_size == sizeof(struct ocfs2_info_maxslots))\n\t\t\tstatus = ocfs2_info_handle_maxslots(inode, req);\n\t\tbreak;\n\tcase OCFS2_INFO_LABEL:\n\t\tif (oir.ir_size == sizeof(struct ocfs2_info_label))\n\t\t\tstatus = ocfs2_info_handle_label(inode, req);\n\t\tbreak;\n\tcase OCFS2_INFO_UUID:\n\t\tif (oir.ir_size == sizeof(struct ocfs2_info_uuid))\n\t\t\tstatus = ocfs2_info_handle_uuid(inode, req);\n\t\tbreak;\n\tcase OCFS2_INFO_FS_FEATURES:\n\t\tif (oir.ir_size == sizeof(struct ocfs2_info_fs_features))\n\t\t\tstatus = ocfs2_info_handle_fs_features(inode, req);\n\t\tbreak;\n\tcase OCFS2_INFO_JOURNAL_SIZE:\n\t\tif (oir.ir_size == sizeof(struct ocfs2_info_journal_size))\n\t\t\tstatus = ocfs2_info_handle_journal_size(inode, req);\n\t\tbreak;\n\tcase OCFS2_INFO_FREEINODE:\n\t\tif (oir.ir_size == sizeof(struct ocfs2_info_freeinode))\n\t\t\tstatus = ocfs2_info_handle_freeinode(inode, req);\n\t\tbreak;\n\tcase OCFS2_INFO_FREEFRAG:\n\t\tif (oir.ir_size == sizeof(struct ocfs2_info_freefrag))\n\t\t\tstatus = ocfs2_info_handle_freefrag(inode, req);\n\t\tbreak;\n\tdefault:\n\t\tstatus = ocfs2_info_handle_unknown(inode, req);\n\t\tbreak;\n\t}\n\nbail:\n\treturn status;\n}\n\nstatic int ocfs2_get_request_ptr(struct ocfs2_info *info, int idx,\n\t\t\t\t u64 *req_addr, int compat_flag)\n{\n\tint status = -EFAULT;\n\tu64 __user *bp = NULL;\n\n\tif (compat_flag) {\n#ifdef CONFIG_COMPAT\n\t\t \n\t\tbp = (u64 __user *)(unsigned long)compat_ptr(info->oi_requests);\n#else\n\t\tBUG();\n#endif\n\t} else\n\t\tbp = (u64 __user *)(unsigned long)(info->oi_requests);\n\n\tif (o2info_from_user(*req_addr, bp + idx))\n\t\tgoto bail;\n\n\tstatus = 0;\nbail:\n\treturn status;\n}\n\n \nstatic noinline_for_stack int\nocfs2_info_handle(struct inode *inode, struct ocfs2_info *info, int compat_flag)\n{\n\tint i, status = 0;\n\tu64 req_addr;\n\tstruct ocfs2_info_request __user *reqp;\n\n\tif ((info->oi_count > OCFS2_INFO_MAX_REQUEST) ||\n\t    (!info->oi_requests)) {\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tfor (i = 0; i < info->oi_count; i++) {\n\n\t\tstatus = ocfs2_get_request_ptr(info, i, &req_addr, compat_flag);\n\t\tif (status)\n\t\t\tbreak;\n\n\t\treqp = (struct ocfs2_info_request __user *)(unsigned long)req_addr;\n\t\tif (!reqp) {\n\t\t\tstatus = -EINVAL;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tstatus = ocfs2_info_handle_request(inode, reqp);\n\t\tif (status)\n\t\t\tbreak;\n\t}\n\nbail:\n\treturn status;\n}\n\nlong ocfs2_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tvoid __user *argp = (void __user *)arg;\n\tint status;\n\n\tswitch (cmd) {\n\tcase OCFS2_IOC_RESVSP:\n\tcase OCFS2_IOC_RESVSP64:\n\tcase OCFS2_IOC_UNRESVSP:\n\tcase OCFS2_IOC_UNRESVSP64:\n\t{\n\t\tstruct ocfs2_space_resv sr;\n\n\t\tif (copy_from_user(&sr, (int __user *) arg, sizeof(sr)))\n\t\t\treturn -EFAULT;\n\n\t\treturn ocfs2_change_file_space(filp, cmd, &sr);\n\t}\n\tcase OCFS2_IOC_GROUP_EXTEND:\n\t{\n\t\tint new_clusters;\n\n\t\tif (!capable(CAP_SYS_RESOURCE))\n\t\t\treturn -EPERM;\n\n\t\tif (get_user(new_clusters, (int __user *)arg))\n\t\t\treturn -EFAULT;\n\n\t\tstatus = mnt_want_write_file(filp);\n\t\tif (status)\n\t\t\treturn status;\n\t\tstatus = ocfs2_group_extend(inode, new_clusters);\n\t\tmnt_drop_write_file(filp);\n\t\treturn status;\n\t}\n\tcase OCFS2_IOC_GROUP_ADD:\n\tcase OCFS2_IOC_GROUP_ADD64:\n\t{\n\t\tstruct ocfs2_new_group_input input;\n\n\t\tif (!capable(CAP_SYS_RESOURCE))\n\t\t\treturn -EPERM;\n\n\t\tif (copy_from_user(&input, (int __user *) arg, sizeof(input)))\n\t\t\treturn -EFAULT;\n\n\t\tstatus = mnt_want_write_file(filp);\n\t\tif (status)\n\t\t\treturn status;\n\t\tstatus = ocfs2_group_add(inode, &input);\n\t\tmnt_drop_write_file(filp);\n\t\treturn status;\n\t}\n\tcase OCFS2_IOC_REFLINK:\n\t{\n\t\tstruct reflink_arguments args;\n\t\tconst char __user *old_path;\n\t\tconst char __user *new_path;\n\t\tbool preserve;\n\n\t\tif (copy_from_user(&args, argp, sizeof(args)))\n\t\t\treturn -EFAULT;\n\t\told_path = (const char __user *)(unsigned long)args.old_path;\n\t\tnew_path = (const char __user *)(unsigned long)args.new_path;\n\t\tpreserve = (args.preserve != 0);\n\n\t\treturn ocfs2_reflink_ioctl(inode, old_path, new_path, preserve);\n\t}\n\tcase OCFS2_IOC_INFO:\n\t{\n\t\tstruct ocfs2_info info;\n\n\t\tif (copy_from_user(&info, argp, sizeof(struct ocfs2_info)))\n\t\t\treturn -EFAULT;\n\n\t\treturn ocfs2_info_handle(inode, &info, 0);\n\t}\n\tcase FITRIM:\n\t{\n\t\tstruct super_block *sb = inode->i_sb;\n\t\tstruct fstrim_range range;\n\t\tint ret = 0;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (!bdev_max_discard_sectors(sb->s_bdev))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (copy_from_user(&range, argp, sizeof(range)))\n\t\t\treturn -EFAULT;\n\n\t\trange.minlen = max_t(u64, bdev_discard_granularity(sb->s_bdev),\n\t\t\t\t     range.minlen);\n\t\tret = ocfs2_trim_fs(sb, &range);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (copy_to_user(argp, &range, sizeof(range)))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\t}\n\tcase OCFS2_IOC_MOVE_EXT:\n\t\treturn ocfs2_ioctl_move_extents(filp, argp);\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}\n\n#ifdef CONFIG_COMPAT\nlong ocfs2_compat_ioctl(struct file *file, unsigned cmd, unsigned long arg)\n{\n\tbool preserve;\n\tstruct reflink_arguments args;\n\tstruct inode *inode = file_inode(file);\n\tstruct ocfs2_info info;\n\tvoid __user *argp = (void __user *)arg;\n\n\tswitch (cmd) {\n\tcase OCFS2_IOC_RESVSP:\n\tcase OCFS2_IOC_RESVSP64:\n\tcase OCFS2_IOC_UNRESVSP:\n\tcase OCFS2_IOC_UNRESVSP64:\n\tcase OCFS2_IOC_GROUP_EXTEND:\n\tcase OCFS2_IOC_GROUP_ADD:\n\tcase OCFS2_IOC_GROUP_ADD64:\n\t\tbreak;\n\tcase OCFS2_IOC_REFLINK:\n\t\tif (copy_from_user(&args, argp, sizeof(args)))\n\t\t\treturn -EFAULT;\n\t\tpreserve = (args.preserve != 0);\n\n\t\treturn ocfs2_reflink_ioctl(inode, compat_ptr(args.old_path),\n\t\t\t\t\t   compat_ptr(args.new_path), preserve);\n\tcase OCFS2_IOC_INFO:\n\t\tif (copy_from_user(&info, argp, sizeof(struct ocfs2_info)))\n\t\t\treturn -EFAULT;\n\n\t\treturn ocfs2_info_handle(inode, &info, 1);\n\tcase FITRIM:\n\tcase OCFS2_IOC_MOVE_EXT:\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\n\treturn ocfs2_ioctl(file, cmd, arg);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}