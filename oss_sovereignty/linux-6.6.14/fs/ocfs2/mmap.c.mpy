{
  "module_name": "mmap.c",
  "hash_id": "06512e33ef2a4cc095f255aba5712436d64262916b15ef7c0ce8e7abf1637045",
  "original_prompt": "Ingested from linux-6.6.14/fs/ocfs2/mmap.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/rbtree.h>\n\n#include <cluster/masklog.h>\n\n#include \"ocfs2.h\"\n\n#include \"aops.h\"\n#include \"dlmglue.h\"\n#include \"file.h\"\n#include \"inode.h\"\n#include \"mmap.h\"\n#include \"super.h\"\n#include \"ocfs2_trace.h\"\n\n\nstatic vm_fault_t ocfs2_fault(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tsigset_t oldset;\n\tvm_fault_t ret;\n\n\tocfs2_block_signals(&oldset);\n\tret = filemap_fault(vmf);\n\tocfs2_unblock_signals(&oldset);\n\n\ttrace_ocfs2_fault(OCFS2_I(vma->vm_file->f_mapping->host)->ip_blkno,\n\t\t\t  vma, vmf->page, vmf->pgoff);\n\treturn ret;\n}\n\nstatic vm_fault_t __ocfs2_page_mkwrite(struct file *file,\n\t\t\tstruct buffer_head *di_bh, struct page *page)\n{\n\tint err;\n\tvm_fault_t ret = VM_FAULT_NOPAGE;\n\tstruct inode *inode = file_inode(file);\n\tstruct address_space *mapping = inode->i_mapping;\n\tloff_t pos = page_offset(page);\n\tunsigned int len = PAGE_SIZE;\n\tpgoff_t last_index;\n\tstruct page *locked_page = NULL;\n\tvoid *fsdata;\n\tloff_t size = i_size_read(inode);\n\n\tlast_index = (size - 1) >> PAGE_SHIFT;\n\n\t \n\tif ((page->mapping != inode->i_mapping) ||\n\t    (!PageUptodate(page)) ||\n\t    (page_offset(page) >= size))\n\t\tgoto out;\n\n\t \n\tif (page->index == last_index)\n\t\tlen = ((size - 1) & ~PAGE_MASK) + 1;\n\n\terr = ocfs2_write_begin_nolock(mapping, pos, len, OCFS2_WRITE_MMAP,\n\t\t\t\t       &locked_page, &fsdata, di_bh, page);\n\tif (err) {\n\t\tif (err != -ENOSPC)\n\t\t\tmlog_errno(err);\n\t\tret = vmf_error(err);\n\t\tgoto out;\n\t}\n\n\tif (!locked_page) {\n\t\tret = VM_FAULT_NOPAGE;\n\t\tgoto out;\n\t}\n\terr = ocfs2_write_end_nolock(mapping, pos, len, len, fsdata);\n\tBUG_ON(err != len);\n\tret = VM_FAULT_LOCKED;\nout:\n\treturn ret;\n}\n\nstatic vm_fault_t ocfs2_page_mkwrite(struct vm_fault *vmf)\n{\n\tstruct page *page = vmf->page;\n\tstruct inode *inode = file_inode(vmf->vma->vm_file);\n\tstruct buffer_head *di_bh = NULL;\n\tsigset_t oldset;\n\tint err;\n\tvm_fault_t ret;\n\n\tsb_start_pagefault(inode->i_sb);\n\tocfs2_block_signals(&oldset);\n\n\t \n\terr = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (err < 0) {\n\t\tmlog_errno(err);\n\t\tret = vmf_error(err);\n\t\tgoto out;\n\t}\n\n\t \n\tdown_write(&OCFS2_I(inode)->ip_alloc_sem);\n\n\tret = __ocfs2_page_mkwrite(vmf->vma->vm_file, di_bh, page);\n\n\tup_write(&OCFS2_I(inode)->ip_alloc_sem);\n\n\tbrelse(di_bh);\n\tocfs2_inode_unlock(inode, 1);\n\nout:\n\tocfs2_unblock_signals(&oldset);\n\tsb_end_pagefault(inode->i_sb);\n\treturn ret;\n}\n\nstatic const struct vm_operations_struct ocfs2_file_vm_ops = {\n\t.fault\t\t= ocfs2_fault,\n\t.page_mkwrite\t= ocfs2_page_mkwrite,\n};\n\nint ocfs2_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tint ret = 0, lock_level = 0;\n\n\tret = ocfs2_inode_lock_atime(file_inode(file),\n\t\t\t\t    file->f_path.mnt, &lock_level, 1);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tocfs2_inode_unlock(file_inode(file), lock_level);\nout:\n\tvma->vm_ops = &ocfs2_file_vm_ops;\n\treturn 0;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}