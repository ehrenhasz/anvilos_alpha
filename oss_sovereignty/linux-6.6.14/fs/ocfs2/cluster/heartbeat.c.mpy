{
  "module_name": "heartbeat.c",
  "hash_id": "5f24b0d35be7f1af2122cbd71f941e1b3af8f4f7590c9002679514e4c90357c2",
  "original_prompt": "Ingested from linux-6.6.14/fs/ocfs2/cluster/heartbeat.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/kthread.h>\n#include <linux/configfs.h>\n#include <linux/random.h>\n#include <linux/crc32.h>\n#include <linux/time.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/ktime.h>\n#include \"heartbeat.h\"\n#include \"tcp.h\"\n#include \"nodemanager.h\"\n#include \"quorum.h\"\n\n#include \"masklog.h\"\n\n\n \nstatic DECLARE_RWSEM(o2hb_callback_sem);\n\n \nstatic DEFINE_SPINLOCK(o2hb_live_lock);\nstatic struct list_head o2hb_live_slots[O2NM_MAX_NODES];\nstatic unsigned long o2hb_live_node_bitmap[BITS_TO_LONGS(O2NM_MAX_NODES)];\nstatic LIST_HEAD(o2hb_node_events);\nstatic DECLARE_WAIT_QUEUE_HEAD(o2hb_steady_queue);\n\n \nstatic unsigned long o2hb_region_bitmap[BITS_TO_LONGS(O2NM_MAX_REGIONS)];\nstatic unsigned long o2hb_live_region_bitmap[BITS_TO_LONGS(O2NM_MAX_REGIONS)];\nstatic unsigned long o2hb_quorum_region_bitmap[BITS_TO_LONGS(O2NM_MAX_REGIONS)];\nstatic unsigned long o2hb_failed_region_bitmap[BITS_TO_LONGS(O2NM_MAX_REGIONS)];\n\n#define O2HB_DB_TYPE_LIVENODES\t\t0\n#define O2HB_DB_TYPE_LIVEREGIONS\t1\n#define O2HB_DB_TYPE_QUORUMREGIONS\t2\n#define O2HB_DB_TYPE_FAILEDREGIONS\t3\n#define O2HB_DB_TYPE_REGION_LIVENODES\t4\n#define O2HB_DB_TYPE_REGION_NUMBER\t5\n#define O2HB_DB_TYPE_REGION_ELAPSED_TIME\t6\n#define O2HB_DB_TYPE_REGION_PINNED\t7\nstruct o2hb_debug_buf {\n\tint db_type;\n\tint db_size;\n\tint db_len;\n\tvoid *db_data;\n};\n\nstatic struct o2hb_debug_buf *o2hb_db_livenodes;\nstatic struct o2hb_debug_buf *o2hb_db_liveregions;\nstatic struct o2hb_debug_buf *o2hb_db_quorumregions;\nstatic struct o2hb_debug_buf *o2hb_db_failedregions;\n\n#define O2HB_DEBUG_DIR\t\t\t\"o2hb\"\n#define O2HB_DEBUG_LIVENODES\t\t\"livenodes\"\n#define O2HB_DEBUG_LIVEREGIONS\t\t\"live_regions\"\n#define O2HB_DEBUG_QUORUMREGIONS\t\"quorum_regions\"\n#define O2HB_DEBUG_FAILEDREGIONS\t\"failed_regions\"\n#define O2HB_DEBUG_REGION_NUMBER\t\"num\"\n#define O2HB_DEBUG_REGION_ELAPSED_TIME\t\"elapsed_time_in_ms\"\n#define O2HB_DEBUG_REGION_PINNED\t\"pinned\"\n\nstatic struct dentry *o2hb_debug_dir;\n\nstatic LIST_HEAD(o2hb_all_regions);\n\nstatic struct o2hb_callback {\n\tstruct list_head list;\n} o2hb_callbacks[O2HB_NUM_CB];\n\nstatic struct o2hb_callback *hbcall_from_type(enum o2hb_callback_type type);\n\nenum o2hb_heartbeat_modes {\n\tO2HB_HEARTBEAT_LOCAL\t\t= 0,\n\tO2HB_HEARTBEAT_GLOBAL,\n\tO2HB_HEARTBEAT_NUM_MODES,\n};\n\nstatic const char *o2hb_heartbeat_mode_desc[O2HB_HEARTBEAT_NUM_MODES] = {\n\t\"local\",\t \n\t\"global\",\t \n};\n\nunsigned int o2hb_dead_threshold = O2HB_DEFAULT_DEAD_THRESHOLD;\nstatic unsigned int o2hb_heartbeat_mode = O2HB_HEARTBEAT_LOCAL;\n\n \nstatic unsigned int o2hb_dependent_users;\n\n \n#define O2HB_PIN_CUT_OFF\t\t3\n\n \nstatic int o2hb_region_pin(const char *region_uuid);\nstatic void o2hb_region_unpin(const char *region_uuid);\n\n \nstatic void o2hb_dead_threshold_set(unsigned int threshold)\n{\n\tif (threshold > O2HB_MIN_DEAD_THRESHOLD) {\n\t\tspin_lock(&o2hb_live_lock);\n\t\tif (list_empty(&o2hb_all_regions))\n\t\t\to2hb_dead_threshold = threshold;\n\t\tspin_unlock(&o2hb_live_lock);\n\t}\n}\n\nstatic int o2hb_global_heartbeat_mode_set(unsigned int hb_mode)\n{\n\tint ret = -1;\n\n\tif (hb_mode < O2HB_HEARTBEAT_NUM_MODES) {\n\t\tspin_lock(&o2hb_live_lock);\n\t\tif (list_empty(&o2hb_all_regions)) {\n\t\t\to2hb_heartbeat_mode = hb_mode;\n\t\t\tret = 0;\n\t\t}\n\t\tspin_unlock(&o2hb_live_lock);\n\t}\n\n\treturn ret;\n}\n\nstruct o2hb_node_event {\n\tstruct list_head        hn_item;\n\tenum o2hb_callback_type hn_event_type;\n\tstruct o2nm_node        *hn_node;\n\tint                     hn_node_num;\n};\n\nstruct o2hb_disk_slot {\n\tstruct o2hb_disk_heartbeat_block *ds_raw_block;\n\tu8\t\t\tds_node_num;\n\tu64\t\t\tds_last_time;\n\tu64\t\t\tds_last_generation;\n\tu16\t\t\tds_equal_samples;\n\tu16\t\t\tds_changed_samples;\n\tstruct list_head\tds_live_item;\n};\n\n \nstruct o2hb_region {\n\tstruct config_item\thr_item;\n\n\tstruct list_head\thr_all_item;\n\tunsigned\t\thr_unclean_stop:1,\n\t\t\t\thr_aborted_start:1,\n\t\t\t\thr_item_pinned:1,\n\t\t\t\thr_item_dropped:1,\n\t\t\t\thr_node_deleted:1;\n\n\t \n\tstruct task_struct \t*hr_task;\n\n\tunsigned int\t\thr_blocks;\n\tunsigned long long\thr_start_block;\n\n\tunsigned int\t\thr_block_bits;\n\tunsigned int\t\thr_block_bytes;\n\n\tunsigned int\t\thr_slots_per_page;\n\tunsigned int\t\thr_num_pages;\n\n\tstruct page             **hr_slot_data;\n\tstruct block_device\t*hr_bdev;\n\tstruct o2hb_disk_slot\t*hr_slots;\n\n\t \n\tunsigned long\t\thr_live_node_bitmap[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\tunsigned int\t\thr_region_num;\n\n\tstruct dentry\t\t*hr_debug_dir;\n\tstruct o2hb_debug_buf\t*hr_db_livenodes;\n\tstruct o2hb_debug_buf\t*hr_db_regnum;\n\tstruct o2hb_debug_buf\t*hr_db_elapsed_time;\n\tstruct o2hb_debug_buf\t*hr_db_pinned;\n\n\t \n\tatomic_t\t\thr_steady_iterations;\n\n\t \n\tatomic_t\t\thr_unsteady_iterations;\n\n\tunsigned int\t\thr_timeout_ms;\n\n\t \n\tu64\t\t\thr_generation;\n\n\tstruct delayed_work\thr_write_timeout_work;\n\tunsigned long\t\thr_last_timeout_start;\n\n\t \n\tstruct delayed_work\thr_nego_timeout_work;\n\tunsigned long\t\thr_nego_node_bitmap[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\n\t \n\tstruct o2hb_disk_heartbeat_block *hr_tmp_block;\n\n\t \n\tunsigned int\t\thr_key;\n\tstruct list_head\thr_handler_list;\n\n\t \n\tint\t\t\thr_last_hb_status;\n};\n\nstruct o2hb_bio_wait_ctxt {\n\tatomic_t          wc_num_reqs;\n\tstruct completion wc_io_complete;\n\tint               wc_error;\n};\n\n#define O2HB_NEGO_TIMEOUT_MS (O2HB_MAX_WRITE_TIMEOUT_MS/2)\n\nenum {\n\tO2HB_NEGO_TIMEOUT_MSG = 1,\n\tO2HB_NEGO_APPROVE_MSG = 2,\n};\n\nstruct o2hb_nego_msg {\n\tu8 node_num;\n};\n\nstatic void o2hb_write_timeout(struct work_struct *work)\n{\n\tint failed, quorum;\n\tstruct o2hb_region *reg =\n\t\tcontainer_of(work, struct o2hb_region,\n\t\t\t     hr_write_timeout_work.work);\n\n\tmlog(ML_ERROR, \"Heartbeat write timeout to device %pg after %u \"\n\t     \"milliseconds\\n\", reg->hr_bdev,\n\t     jiffies_to_msecs(jiffies - reg->hr_last_timeout_start));\n\n\tif (o2hb_global_heartbeat_active()) {\n\t\tspin_lock(&o2hb_live_lock);\n\t\tif (test_bit(reg->hr_region_num, o2hb_quorum_region_bitmap))\n\t\t\tset_bit(reg->hr_region_num, o2hb_failed_region_bitmap);\n\t\tfailed = bitmap_weight(o2hb_failed_region_bitmap,\n\t\t\t\t\tO2NM_MAX_REGIONS);\n\t\tquorum = bitmap_weight(o2hb_quorum_region_bitmap,\n\t\t\t\t\tO2NM_MAX_REGIONS);\n\t\tspin_unlock(&o2hb_live_lock);\n\n\t\tmlog(ML_HEARTBEAT, \"Number of regions %d, failed regions %d\\n\",\n\t\t     quorum, failed);\n\n\t\t \n\t\tif ((failed << 1) < quorum)\n\t\t\treturn;\n\t}\n\n\to2quo_disk_timeout();\n}\n\nstatic void o2hb_arm_timeout(struct o2hb_region *reg)\n{\n\t \n\tif (atomic_read(&reg->hr_steady_iterations) != 0)\n\t\treturn;\n\n\tmlog(ML_HEARTBEAT, \"Queue write timeout for %u ms\\n\",\n\t     O2HB_MAX_WRITE_TIMEOUT_MS);\n\n\tif (o2hb_global_heartbeat_active()) {\n\t\tspin_lock(&o2hb_live_lock);\n\t\tclear_bit(reg->hr_region_num, o2hb_failed_region_bitmap);\n\t\tspin_unlock(&o2hb_live_lock);\n\t}\n\tcancel_delayed_work(&reg->hr_write_timeout_work);\n\tschedule_delayed_work(&reg->hr_write_timeout_work,\n\t\t\t      msecs_to_jiffies(O2HB_MAX_WRITE_TIMEOUT_MS));\n\n\tcancel_delayed_work(&reg->hr_nego_timeout_work);\n\t \n\tschedule_delayed_work(&reg->hr_nego_timeout_work,\n\t\t\t      msecs_to_jiffies(O2HB_NEGO_TIMEOUT_MS));\n\tbitmap_zero(reg->hr_nego_node_bitmap, O2NM_MAX_NODES);\n}\n\nstatic void o2hb_disarm_timeout(struct o2hb_region *reg)\n{\n\tcancel_delayed_work_sync(&reg->hr_write_timeout_work);\n\tcancel_delayed_work_sync(&reg->hr_nego_timeout_work);\n}\n\nstatic int o2hb_send_nego_msg(int key, int type, u8 target)\n{\n\tstruct o2hb_nego_msg msg;\n\tint status, ret;\n\n\tmsg.node_num = o2nm_this_node();\nagain:\n\tret = o2net_send_message(type, key, &msg, sizeof(msg),\n\t\t\ttarget, &status);\n\n\tif (ret == -EAGAIN || ret == -ENOMEM) {\n\t\tmsleep(100);\n\t\tgoto again;\n\t}\n\n\treturn ret;\n}\n\nstatic void o2hb_nego_timeout(struct work_struct *work)\n{\n\tunsigned long live_node_bitmap[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\tint master_node, i, ret;\n\tstruct o2hb_region *reg;\n\n\treg = container_of(work, struct o2hb_region, hr_nego_timeout_work.work);\n\t \n\tif (reg->hr_last_hb_status)\n\t\treturn;\n\n\to2hb_fill_node_map(live_node_bitmap, O2NM_MAX_NODES);\n\t \n\tmaster_node = find_first_bit(live_node_bitmap, O2NM_MAX_NODES);\n\n\tif (master_node == o2nm_this_node()) {\n\t\tif (!test_bit(master_node, reg->hr_nego_node_bitmap)) {\n\t\t\tprintk(KERN_NOTICE \"o2hb: node %d hb write hung for %ds on region %s (%pg).\\n\",\n\t\t\t\to2nm_this_node(), O2HB_NEGO_TIMEOUT_MS/1000,\n\t\t\t\tconfig_item_name(&reg->hr_item), reg->hr_bdev);\n\t\t\tset_bit(master_node, reg->hr_nego_node_bitmap);\n\t\t}\n\t\tif (!bitmap_equal(reg->hr_nego_node_bitmap, live_node_bitmap,\n\t\t\t\t  O2NM_MAX_NODES)) {\n\t\t\t \n\t\t\tschedule_delayed_work(&reg->hr_nego_timeout_work,\n\t\t\t\tmsecs_to_jiffies(1000));\n\n\t\t\treturn;\n\t\t}\n\n\t\tprintk(KERN_NOTICE \"o2hb: all nodes hb write hung, maybe region %s (%pg) is down.\\n\",\n\t\t\tconfig_item_name(&reg->hr_item), reg->hr_bdev);\n\t\t \n\t\to2hb_arm_timeout(reg);\n\n\t\ti = -1;\n\t\twhile ((i = find_next_bit(live_node_bitmap,\n\t\t\t\tO2NM_MAX_NODES, i + 1)) < O2NM_MAX_NODES) {\n\t\t\tif (i == master_node)\n\t\t\t\tcontinue;\n\n\t\t\tmlog(ML_HEARTBEAT, \"send NEGO_APPROVE msg to node %d\\n\", i);\n\t\t\tret = o2hb_send_nego_msg(reg->hr_key,\n\t\t\t\t\tO2HB_NEGO_APPROVE_MSG, i);\n\t\t\tif (ret)\n\t\t\t\tmlog(ML_ERROR, \"send NEGO_APPROVE msg to node %d fail %d\\n\",\n\t\t\t\t\ti, ret);\n\t\t}\n\t} else {\n\t\t \n\t\tprintk(KERN_NOTICE \"o2hb: node %d hb write hung for %ds on region %s (%pg), negotiate timeout with node %d.\\n\",\n\t\t\to2nm_this_node(), O2HB_NEGO_TIMEOUT_MS/1000, config_item_name(&reg->hr_item),\n\t\t\treg->hr_bdev, master_node);\n\t\tret = o2hb_send_nego_msg(reg->hr_key, O2HB_NEGO_TIMEOUT_MSG,\n\t\t\t\tmaster_node);\n\t\tif (ret)\n\t\t\tmlog(ML_ERROR, \"send NEGO_TIMEOUT msg to node %d fail %d\\n\",\n\t\t\t\tmaster_node, ret);\n\t}\n}\n\nstatic int o2hb_nego_timeout_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\tvoid **ret_data)\n{\n\tstruct o2hb_region *reg = data;\n\tstruct o2hb_nego_msg *nego_msg;\n\n\tnego_msg = (struct o2hb_nego_msg *)msg->buf;\n\tprintk(KERN_NOTICE \"o2hb: receive negotiate timeout message from node %d on region %s (%pg).\\n\",\n\t\tnego_msg->node_num, config_item_name(&reg->hr_item), reg->hr_bdev);\n\tif (nego_msg->node_num < O2NM_MAX_NODES)\n\t\tset_bit(nego_msg->node_num, reg->hr_nego_node_bitmap);\n\telse\n\t\tmlog(ML_ERROR, \"got nego timeout message from bad node.\\n\");\n\n\treturn 0;\n}\n\nstatic int o2hb_nego_approve_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\tvoid **ret_data)\n{\n\tstruct o2hb_region *reg = data;\n\n\tprintk(KERN_NOTICE \"o2hb: negotiate timeout approved by master node on region %s (%pg).\\n\",\n\t\tconfig_item_name(&reg->hr_item), reg->hr_bdev);\n\to2hb_arm_timeout(reg);\n\treturn 0;\n}\n\nstatic inline void o2hb_bio_wait_init(struct o2hb_bio_wait_ctxt *wc)\n{\n\tatomic_set(&wc->wc_num_reqs, 1);\n\tinit_completion(&wc->wc_io_complete);\n\twc->wc_error = 0;\n}\n\n \nstatic inline void o2hb_bio_wait_dec(struct o2hb_bio_wait_ctxt *wc,\n\t\t\t\t     unsigned int num)\n{\n\t \n\twhile(num--) {\n\t\tif (atomic_dec_and_test(&wc->wc_num_reqs)) {\n\t\t\tBUG_ON(num > 0);\n\t\t\tcomplete(&wc->wc_io_complete);\n\t\t}\n\t}\n}\n\nstatic void o2hb_wait_on_io(struct o2hb_bio_wait_ctxt *wc)\n{\n\to2hb_bio_wait_dec(wc, 1);\n\twait_for_completion(&wc->wc_io_complete);\n}\n\nstatic void o2hb_bio_end_io(struct bio *bio)\n{\n\tstruct o2hb_bio_wait_ctxt *wc = bio->bi_private;\n\n\tif (bio->bi_status) {\n\t\tmlog(ML_ERROR, \"IO Error %d\\n\", bio->bi_status);\n\t\twc->wc_error = blk_status_to_errno(bio->bi_status);\n\t}\n\n\to2hb_bio_wait_dec(wc, 1);\n\tbio_put(bio);\n}\n\n \nstatic struct bio *o2hb_setup_one_bio(struct o2hb_region *reg,\n\t\t\t\t      struct o2hb_bio_wait_ctxt *wc,\n\t\t\t\t      unsigned int *current_slot,\n\t\t\t\t      unsigned int max_slots, blk_opf_t opf)\n{\n\tint len, current_page;\n\tunsigned int vec_len, vec_start;\n\tunsigned int bits = reg->hr_block_bits;\n\tunsigned int spp = reg->hr_slots_per_page;\n\tunsigned int cs = *current_slot;\n\tstruct bio *bio;\n\tstruct page *page;\n\n\t \n\tbio = bio_alloc(reg->hr_bdev, 16, opf, GFP_ATOMIC);\n\tif (!bio) {\n\t\tmlog(ML_ERROR, \"Could not alloc slots BIO!\\n\");\n\t\tbio = ERR_PTR(-ENOMEM);\n\t\tgoto bail;\n\t}\n\n\t \n\tbio->bi_iter.bi_sector = (reg->hr_start_block + cs) << (bits - 9);\n\tbio->bi_private = wc;\n\tbio->bi_end_io = o2hb_bio_end_io;\n\n\tvec_start = (cs << bits) % PAGE_SIZE;\n\twhile(cs < max_slots) {\n\t\tcurrent_page = cs / spp;\n\t\tpage = reg->hr_slot_data[current_page];\n\n\t\tvec_len = min(PAGE_SIZE - vec_start,\n\t\t\t      (max_slots-cs) * (PAGE_SIZE/spp) );\n\n\t\tmlog(ML_HB_BIO, \"page %d, vec_len = %u, vec_start = %u\\n\",\n\t\t     current_page, vec_len, vec_start);\n\n\t\tlen = bio_add_page(bio, page, vec_len, vec_start);\n\t\tif (len != vec_len) break;\n\n\t\tcs += vec_len / (PAGE_SIZE/spp);\n\t\tvec_start = 0;\n\t}\n\nbail:\n\t*current_slot = cs;\n\treturn bio;\n}\n\nstatic int o2hb_read_slots(struct o2hb_region *reg,\n\t\t\t   unsigned int begin_slot,\n\t\t\t   unsigned int max_slots)\n{\n\tunsigned int current_slot = begin_slot;\n\tint status;\n\tstruct o2hb_bio_wait_ctxt wc;\n\tstruct bio *bio;\n\n\to2hb_bio_wait_init(&wc);\n\n\twhile(current_slot < max_slots) {\n\t\tbio = o2hb_setup_one_bio(reg, &wc, &current_slot, max_slots,\n\t\t\t\t\t REQ_OP_READ);\n\t\tif (IS_ERR(bio)) {\n\t\t\tstatus = PTR_ERR(bio);\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail_and_wait;\n\t\t}\n\n\t\tatomic_inc(&wc.wc_num_reqs);\n\t\tsubmit_bio(bio);\n\t}\n\n\tstatus = 0;\n\nbail_and_wait:\n\to2hb_wait_on_io(&wc);\n\tif (wc.wc_error && !status)\n\t\tstatus = wc.wc_error;\n\n\treturn status;\n}\n\nstatic int o2hb_issue_node_write(struct o2hb_region *reg,\n\t\t\t\t struct o2hb_bio_wait_ctxt *write_wc)\n{\n\tint status;\n\tunsigned int slot;\n\tstruct bio *bio;\n\n\to2hb_bio_wait_init(write_wc);\n\n\tslot = o2nm_this_node();\n\n\tbio = o2hb_setup_one_bio(reg, write_wc, &slot, slot+1,\n\t\t\t\t REQ_OP_WRITE | REQ_SYNC);\n\tif (IS_ERR(bio)) {\n\t\tstatus = PTR_ERR(bio);\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tatomic_inc(&write_wc->wc_num_reqs);\n\tsubmit_bio(bio);\n\n\tstatus = 0;\nbail:\n\treturn status;\n}\n\nstatic u32 o2hb_compute_block_crc_le(struct o2hb_region *reg,\n\t\t\t\t     struct o2hb_disk_heartbeat_block *hb_block)\n{\n\t__le32 old_cksum;\n\tu32 ret;\n\n\t \n\told_cksum = hb_block->hb_cksum;\n\thb_block->hb_cksum = 0;\n\n\tret = crc32_le(0, (unsigned char *) hb_block, reg->hr_block_bytes);\n\n\thb_block->hb_cksum = old_cksum;\n\n\treturn ret;\n}\n\nstatic void o2hb_dump_slot(struct o2hb_disk_heartbeat_block *hb_block)\n{\n\tmlog(ML_ERROR, \"Dump slot information: seq = 0x%llx, node = %u, \"\n\t     \"cksum = 0x%x, generation 0x%llx\\n\",\n\t     (long long)le64_to_cpu(hb_block->hb_seq),\n\t     hb_block->hb_node, le32_to_cpu(hb_block->hb_cksum),\n\t     (long long)le64_to_cpu(hb_block->hb_generation));\n}\n\nstatic int o2hb_verify_crc(struct o2hb_region *reg,\n\t\t\t   struct o2hb_disk_heartbeat_block *hb_block)\n{\n\tu32 read, computed;\n\n\tread = le32_to_cpu(hb_block->hb_cksum);\n\tcomputed = o2hb_compute_block_crc_le(reg, hb_block);\n\n\treturn read == computed;\n}\n\n \nstatic int o2hb_check_own_slot(struct o2hb_region *reg)\n{\n\tstruct o2hb_disk_slot *slot;\n\tstruct o2hb_disk_heartbeat_block *hb_block;\n\tchar *errstr;\n\n\tslot = &reg->hr_slots[o2nm_this_node()];\n\t \n\tif (!slot->ds_last_time)\n\t\treturn 0;\n\n\thb_block = slot->ds_raw_block;\n\tif (le64_to_cpu(hb_block->hb_seq) == slot->ds_last_time &&\n\t    le64_to_cpu(hb_block->hb_generation) == slot->ds_last_generation &&\n\t    hb_block->hb_node == slot->ds_node_num)\n\t\treturn 1;\n\n#define ERRSTR1\t\t\"Another node is heartbeating on device\"\n#define ERRSTR2\t\t\"Heartbeat generation mismatch on device\"\n#define ERRSTR3\t\t\"Heartbeat sequence mismatch on device\"\n\n\tif (hb_block->hb_node != slot->ds_node_num)\n\t\terrstr = ERRSTR1;\n\telse if (le64_to_cpu(hb_block->hb_generation) !=\n\t\t slot->ds_last_generation)\n\t\terrstr = ERRSTR2;\n\telse\n\t\terrstr = ERRSTR3;\n\n\tmlog(ML_ERROR, \"%s (%pg): expected(%u:0x%llx, 0x%llx), \"\n\t     \"ondisk(%u:0x%llx, 0x%llx)\\n\", errstr, reg->hr_bdev,\n\t     slot->ds_node_num, (unsigned long long)slot->ds_last_generation,\n\t     (unsigned long long)slot->ds_last_time, hb_block->hb_node,\n\t     (unsigned long long)le64_to_cpu(hb_block->hb_generation),\n\t     (unsigned long long)le64_to_cpu(hb_block->hb_seq));\n\n\treturn 0;\n}\n\nstatic inline void o2hb_prepare_block(struct o2hb_region *reg,\n\t\t\t\t      u64 generation)\n{\n\tint node_num;\n\tu64 cputime;\n\tstruct o2hb_disk_slot *slot;\n\tstruct o2hb_disk_heartbeat_block *hb_block;\n\n\tnode_num = o2nm_this_node();\n\tslot = &reg->hr_slots[node_num];\n\n\thb_block = (struct o2hb_disk_heartbeat_block *)slot->ds_raw_block;\n\tmemset(hb_block, 0, reg->hr_block_bytes);\n\t \n\tcputime = ktime_get_real_seconds();\n\tif (!cputime)\n\t\tcputime = 1;\n\n\thb_block->hb_seq = cpu_to_le64(cputime);\n\thb_block->hb_node = node_num;\n\thb_block->hb_generation = cpu_to_le64(generation);\n\thb_block->hb_dead_ms = cpu_to_le32(o2hb_dead_threshold * O2HB_REGION_TIMEOUT_MS);\n\n\t \n\thb_block->hb_cksum = cpu_to_le32(o2hb_compute_block_crc_le(reg,\n\t\t\t\t\t\t\t\t   hb_block));\n\n\tmlog(ML_HB_BIO, \"our node generation = 0x%llx, cksum = 0x%x\\n\",\n\t     (long long)generation,\n\t     le32_to_cpu(hb_block->hb_cksum));\n}\n\nstatic void o2hb_fire_callbacks(struct o2hb_callback *hbcall,\n\t\t\t\tstruct o2nm_node *node,\n\t\t\t\tint idx)\n{\n\tstruct o2hb_callback_func *f;\n\n\tlist_for_each_entry(f, &hbcall->list, hc_item) {\n\t\tmlog(ML_HEARTBEAT, \"calling funcs %p\\n\", f);\n\t\t(f->hc_func)(node, idx, f->hc_data);\n\t}\n}\n\n \nstatic void o2hb_run_event_list(struct o2hb_node_event *queued_event)\n{\n\tstruct o2hb_callback *hbcall;\n\tstruct o2hb_node_event *event;\n\n\t \n\tdown_write(&o2hb_callback_sem);\n\n\tspin_lock(&o2hb_live_lock);\n\twhile (!list_empty(&o2hb_node_events)\n\t       && !list_empty(&queued_event->hn_item)) {\n\t\tevent = list_entry(o2hb_node_events.next,\n\t\t\t\t   struct o2hb_node_event,\n\t\t\t\t   hn_item);\n\t\tlist_del_init(&event->hn_item);\n\t\tspin_unlock(&o2hb_live_lock);\n\n\t\tmlog(ML_HEARTBEAT, \"Node %s event for %d\\n\",\n\t\t     event->hn_event_type == O2HB_NODE_UP_CB ? \"UP\" : \"DOWN\",\n\t\t     event->hn_node_num);\n\n\t\thbcall = hbcall_from_type(event->hn_event_type);\n\n\t\t \n\t\tBUG_ON(IS_ERR(hbcall));\n\n\t\to2hb_fire_callbacks(hbcall, event->hn_node, event->hn_node_num);\n\n\t\tspin_lock(&o2hb_live_lock);\n\t}\n\tspin_unlock(&o2hb_live_lock);\n\n\tup_write(&o2hb_callback_sem);\n}\n\nstatic void o2hb_queue_node_event(struct o2hb_node_event *event,\n\t\t\t\t  enum o2hb_callback_type type,\n\t\t\t\t  struct o2nm_node *node,\n\t\t\t\t  int node_num)\n{\n\tassert_spin_locked(&o2hb_live_lock);\n\n\tBUG_ON((!node) && (type != O2HB_NODE_DOWN_CB));\n\n\tevent->hn_event_type = type;\n\tevent->hn_node = node;\n\tevent->hn_node_num = node_num;\n\n\tmlog(ML_HEARTBEAT, \"Queue node %s event for node %d\\n\",\n\t     type == O2HB_NODE_UP_CB ? \"UP\" : \"DOWN\", node_num);\n\n\tlist_add_tail(&event->hn_item, &o2hb_node_events);\n}\n\nstatic void o2hb_shutdown_slot(struct o2hb_disk_slot *slot)\n{\n\tstruct o2hb_node_event event =\n\t\t{ .hn_item = LIST_HEAD_INIT(event.hn_item), };\n\tstruct o2nm_node *node;\n\tint queued = 0;\n\n\tnode = o2nm_get_node_by_num(slot->ds_node_num);\n\tif (!node)\n\t\treturn;\n\n\tspin_lock(&o2hb_live_lock);\n\tif (!list_empty(&slot->ds_live_item)) {\n\t\tmlog(ML_HEARTBEAT, \"Shutdown, node %d leaves region\\n\",\n\t\t     slot->ds_node_num);\n\n\t\tlist_del_init(&slot->ds_live_item);\n\n\t\tif (list_empty(&o2hb_live_slots[slot->ds_node_num])) {\n\t\t\tclear_bit(slot->ds_node_num, o2hb_live_node_bitmap);\n\n\t\t\to2hb_queue_node_event(&event, O2HB_NODE_DOWN_CB, node,\n\t\t\t\t\t      slot->ds_node_num);\n\t\t\tqueued = 1;\n\t\t}\n\t}\n\tspin_unlock(&o2hb_live_lock);\n\n\tif (queued)\n\t\to2hb_run_event_list(&event);\n\n\to2nm_node_put(node);\n}\n\nstatic void o2hb_set_quorum_device(struct o2hb_region *reg)\n{\n\tif (!o2hb_global_heartbeat_active())\n\t\treturn;\n\n\t \n\tif (kthread_should_stop())\n\t\treturn;\n\n\t \n\tif (atomic_read(&reg->hr_steady_iterations) != 0)\n\t\treturn;\n\n\tspin_lock(&o2hb_live_lock);\n\n\tif (test_bit(reg->hr_region_num, o2hb_quorum_region_bitmap))\n\t\tgoto unlock;\n\n\t \n\tif (!bitmap_equal(reg->hr_live_node_bitmap, o2hb_live_node_bitmap,\n\t\t\t  O2NM_MAX_NODES))\n\t\tgoto unlock;\n\n\tprintk(KERN_NOTICE \"o2hb: Region %s (%pg) is now a quorum device\\n\",\n\t       config_item_name(&reg->hr_item), reg->hr_bdev);\n\n\tset_bit(reg->hr_region_num, o2hb_quorum_region_bitmap);\n\n\t \n\tif (bitmap_weight(o2hb_quorum_region_bitmap,\n\t\t\t   O2NM_MAX_REGIONS) > O2HB_PIN_CUT_OFF)\n\t\to2hb_region_unpin(NULL);\nunlock:\n\tspin_unlock(&o2hb_live_lock);\n}\n\nstatic int o2hb_check_slot(struct o2hb_region *reg,\n\t\t\t   struct o2hb_disk_slot *slot)\n{\n\tint changed = 0, gen_changed = 0;\n\tstruct o2hb_node_event event =\n\t\t{ .hn_item = LIST_HEAD_INIT(event.hn_item), };\n\tstruct o2nm_node *node;\n\tstruct o2hb_disk_heartbeat_block *hb_block = reg->hr_tmp_block;\n\tu64 cputime;\n\tunsigned int dead_ms = o2hb_dead_threshold * O2HB_REGION_TIMEOUT_MS;\n\tunsigned int slot_dead_ms;\n\tint tmp;\n\tint queued = 0;\n\n\tmemcpy(hb_block, slot->ds_raw_block, reg->hr_block_bytes);\n\n\t \n\tnode = o2nm_get_node_by_num(slot->ds_node_num);\n\tif (!node) {\n\t\tspin_lock(&o2hb_live_lock);\n\t\ttmp = test_bit(slot->ds_node_num, o2hb_live_node_bitmap);\n\t\tspin_unlock(&o2hb_live_lock);\n\t\tif (!tmp)\n\t\t\treturn 0;\n\t}\n\n\tif (!o2hb_verify_crc(reg, hb_block)) {\n\t\t \n\t\tspin_lock(&o2hb_live_lock);\n\n\t\t \n\t\tif (list_empty(&slot->ds_live_item))\n\t\t\tgoto out;\n\n\t\t \n\t\tmlog(ML_ERROR, \"Node %d has written a bad crc to %pg\\n\",\n\t\t     slot->ds_node_num, reg->hr_bdev);\n\t\to2hb_dump_slot(hb_block);\n\n\t\tslot->ds_equal_samples++;\n\t\tgoto fire_callbacks;\n\t}\n\n\t \n\tcputime = le64_to_cpu(hb_block->hb_seq);\n\tif (slot->ds_last_time != cputime)\n\t\tslot->ds_changed_samples++;\n\telse\n\t\tslot->ds_equal_samples++;\n\tslot->ds_last_time = cputime;\n\n\t \n\tif (slot->ds_last_generation != le64_to_cpu(hb_block->hb_generation)) {\n\t\tgen_changed = 1;\n\t\tslot->ds_equal_samples = 0;\n\t\tmlog(ML_HEARTBEAT, \"Node %d changed generation (0x%llx \"\n\t\t     \"to 0x%llx)\\n\", slot->ds_node_num,\n\t\t     (long long)slot->ds_last_generation,\n\t\t     (long long)le64_to_cpu(hb_block->hb_generation));\n\t}\n\n\tslot->ds_last_generation = le64_to_cpu(hb_block->hb_generation);\n\n\tmlog(ML_HEARTBEAT, \"Slot %d gen 0x%llx cksum 0x%x \"\n\t     \"seq %llu last %llu changed %u equal %u\\n\",\n\t     slot->ds_node_num, (long long)slot->ds_last_generation,\n\t     le32_to_cpu(hb_block->hb_cksum),\n\t     (unsigned long long)le64_to_cpu(hb_block->hb_seq),\n\t     (unsigned long long)slot->ds_last_time, slot->ds_changed_samples,\n\t     slot->ds_equal_samples);\n\n\tspin_lock(&o2hb_live_lock);\n\nfire_callbacks:\n\t \n\tif (list_empty(&slot->ds_live_item) &&\n\t    slot->ds_changed_samples >= O2HB_LIVE_THRESHOLD) {\n\t\tmlog(ML_HEARTBEAT, \"Node %d (id 0x%llx) joined my region\\n\",\n\t\t     slot->ds_node_num, (long long)slot->ds_last_generation);\n\n\t\tset_bit(slot->ds_node_num, reg->hr_live_node_bitmap);\n\n\t\t \n\t\tif (list_empty(&o2hb_live_slots[slot->ds_node_num])) {\n\t\t\tmlog(ML_HEARTBEAT, \"o2hb: Add node %d to live nodes \"\n\t\t\t     \"bitmap\\n\", slot->ds_node_num);\n\t\t\tset_bit(slot->ds_node_num, o2hb_live_node_bitmap);\n\n\t\t\to2hb_queue_node_event(&event, O2HB_NODE_UP_CB, node,\n\t\t\t\t\t      slot->ds_node_num);\n\n\t\t\tchanged = 1;\n\t\t\tqueued = 1;\n\t\t}\n\n\t\tlist_add_tail(&slot->ds_live_item,\n\t\t\t      &o2hb_live_slots[slot->ds_node_num]);\n\n\t\tslot->ds_equal_samples = 0;\n\n\t\t \n\t\tslot_dead_ms = le32_to_cpu(hb_block->hb_dead_ms);\n\t\tif (slot_dead_ms && slot_dead_ms != dead_ms) {\n\t\t\t \n\t\t\tmlog(ML_ERROR, \"Node %d on device %pg has a dead count \"\n\t\t\t     \"of %u ms, but our count is %u ms.\\n\"\n\t\t\t     \"Please double check your configuration values \"\n\t\t\t     \"for 'O2CB_HEARTBEAT_THRESHOLD'\\n\",\n\t\t\t     slot->ds_node_num, reg->hr_bdev, slot_dead_ms,\n\t\t\t     dead_ms);\n\t\t}\n\t\tgoto out;\n\t}\n\n\t \n\tif (list_empty(&slot->ds_live_item))\n\t\tgoto out;\n\n\t \n\tif (slot->ds_equal_samples >= o2hb_dead_threshold || gen_changed) {\n\t\tmlog(ML_HEARTBEAT, \"Node %d left my region\\n\",\n\t\t     slot->ds_node_num);\n\n\t\tclear_bit(slot->ds_node_num, reg->hr_live_node_bitmap);\n\n\t\t \n\t\tlist_del_init(&slot->ds_live_item);\n\t\tif (list_empty(&o2hb_live_slots[slot->ds_node_num])) {\n\t\t\tmlog(ML_HEARTBEAT, \"o2hb: Remove node %d from live \"\n\t\t\t     \"nodes bitmap\\n\", slot->ds_node_num);\n\t\t\tclear_bit(slot->ds_node_num, o2hb_live_node_bitmap);\n\n\t\t\t \n\t\t\to2hb_queue_node_event(&event, O2HB_NODE_DOWN_CB,\n\t\t\t\t\t      node, slot->ds_node_num);\n\n\t\t\tchanged = 1;\n\t\t\tqueued = 1;\n\t\t}\n\n\t\t \n\t\tif (!gen_changed)\n\t\t\tslot->ds_changed_samples = 0;\n\t\tgoto out;\n\t}\n\tif (slot->ds_changed_samples) {\n\t\tslot->ds_changed_samples = 0;\n\t\tslot->ds_equal_samples = 0;\n\t}\nout:\n\tspin_unlock(&o2hb_live_lock);\n\n\tif (queued)\n\t\to2hb_run_event_list(&event);\n\n\tif (node)\n\t\to2nm_node_put(node);\n\treturn changed;\n}\n\nstatic int o2hb_highest_node(unsigned long *nodes, int numbits)\n{\n\treturn find_last_bit(nodes, numbits);\n}\n\nstatic int o2hb_lowest_node(unsigned long *nodes, int numbits)\n{\n\treturn find_first_bit(nodes, numbits);\n}\n\nstatic int o2hb_do_disk_heartbeat(struct o2hb_region *reg)\n{\n\tint i, ret, highest_node, lowest_node;\n\tint membership_change = 0, own_slot_ok = 0;\n\tunsigned long configured_nodes[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\tunsigned long live_node_bitmap[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\tstruct o2hb_bio_wait_ctxt write_wc;\n\n\tret = o2nm_configured_node_map(configured_nodes,\n\t\t\t\t       sizeof(configured_nodes));\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto bail;\n\t}\n\n\t \n\to2hb_fill_node_map(live_node_bitmap, O2NM_MAX_NODES);\n\ti = -1;\n\twhile ((i = find_next_bit(live_node_bitmap,\n\t\t\t\t  O2NM_MAX_NODES, i + 1)) < O2NM_MAX_NODES) {\n\t\tset_bit(i, configured_nodes);\n\t}\n\n\thighest_node = o2hb_highest_node(configured_nodes, O2NM_MAX_NODES);\n\tlowest_node = o2hb_lowest_node(configured_nodes, O2NM_MAX_NODES);\n\tif (highest_node >= O2NM_MAX_NODES || lowest_node >= O2NM_MAX_NODES) {\n\t\tmlog(ML_NOTICE, \"o2hb: No configured nodes found!\\n\");\n\t\tret = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\t \n\tret = o2hb_read_slots(reg, lowest_node, highest_node + 1);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto bail;\n\t}\n\n\t \n\town_slot_ok = o2hb_check_own_slot(reg);\n\n\t \n\to2hb_prepare_block(reg, reg->hr_generation);\n\n\tret = o2hb_issue_node_write(reg, &write_wc);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto bail;\n\t}\n\n\ti = -1;\n\twhile((i = find_next_bit(configured_nodes,\n\t\t\t\t O2NM_MAX_NODES, i + 1)) < O2NM_MAX_NODES) {\n\t\tmembership_change |= o2hb_check_slot(reg, &reg->hr_slots[i]);\n\t}\n\n\t \n\to2hb_wait_on_io(&write_wc);\n\tif (write_wc.wc_error) {\n\t\t \n\t\tmlog(ML_ERROR, \"Write error %d on device \\\"%pg\\\"\\n\",\n\t\t     write_wc.wc_error, reg->hr_bdev);\n\t\tret = write_wc.wc_error;\n\t\tgoto bail;\n\t}\n\n\t \n\tif (own_slot_ok) {\n\t\to2hb_set_quorum_device(reg);\n\t\to2hb_arm_timeout(reg);\n\t\treg->hr_last_timeout_start = jiffies;\n\t}\n\nbail:\n\t \n\tif (atomic_read(&reg->hr_steady_iterations) != 0) {\n\t\tif (!ret && own_slot_ok && !membership_change) {\n\t\t\tif (atomic_dec_and_test(&reg->hr_steady_iterations))\n\t\t\t\twake_up(&o2hb_steady_queue);\n\t\t}\n\t}\n\n\tif (atomic_read(&reg->hr_steady_iterations) != 0) {\n\t\tif (atomic_dec_and_test(&reg->hr_unsteady_iterations)) {\n\t\t\tprintk(KERN_NOTICE \"o2hb: Unable to stabilize \"\n\t\t\t       \"heartbeat on region %s (%pg)\\n\",\n\t\t\t       config_item_name(&reg->hr_item),\n\t\t\t       reg->hr_bdev);\n\t\t\tatomic_set(&reg->hr_steady_iterations, 0);\n\t\t\treg->hr_aborted_start = 1;\n\t\t\twake_up(&o2hb_steady_queue);\n\t\t\tret = -EIO;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n \nstatic int o2hb_thread(void *data)\n{\n\tint i, ret;\n\tstruct o2hb_region *reg = data;\n\tstruct o2hb_bio_wait_ctxt write_wc;\n\tktime_t before_hb, after_hb;\n\tunsigned int elapsed_msec;\n\n\tmlog(ML_HEARTBEAT|ML_KTHREAD, \"hb thread running\\n\");\n\n\tset_user_nice(current, MIN_NICE);\n\n\t \n\tret = o2nm_depend_this_node();\n\tif (ret) {\n\t\tmlog(ML_ERROR, \"Node has been deleted, ret = %d\\n\", ret);\n\t\treg->hr_node_deleted = 1;\n\t\twake_up(&o2hb_steady_queue);\n\t\treturn 0;\n\t}\n\n\twhile (!kthread_should_stop() &&\n\t       !reg->hr_unclean_stop && !reg->hr_aborted_start) {\n\t\t \n\t\tbefore_hb = ktime_get_real();\n\n\t\tret = o2hb_do_disk_heartbeat(reg);\n\t\treg->hr_last_hb_status = ret;\n\n\t\tafter_hb = ktime_get_real();\n\n\t\telapsed_msec = (unsigned int)\n\t\t\t\tktime_ms_delta(after_hb, before_hb);\n\n\t\tmlog(ML_HEARTBEAT,\n\t\t     \"start = %lld, end = %lld, msec = %u, ret = %d\\n\",\n\t\t     before_hb, after_hb, elapsed_msec, ret);\n\n\t\tif (!kthread_should_stop() &&\n\t\t    elapsed_msec < reg->hr_timeout_ms) {\n\t\t\t \n\t\t\tmsleep_interruptible(reg->hr_timeout_ms - elapsed_msec);\n\t\t}\n\t}\n\n\to2hb_disarm_timeout(reg);\n\n\t \n\tfor(i = 0; !reg->hr_unclean_stop && i < reg->hr_blocks; i++)\n\t\to2hb_shutdown_slot(&reg->hr_slots[i]);\n\n\t \n\tif (!reg->hr_unclean_stop && !reg->hr_aborted_start) {\n\t\to2hb_prepare_block(reg, 0);\n\t\tret = o2hb_issue_node_write(reg, &write_wc);\n\t\tif (ret == 0)\n\t\t\to2hb_wait_on_io(&write_wc);\n\t\telse\n\t\t\tmlog_errno(ret);\n\t}\n\n\t \n\to2nm_undepend_this_node();\n\n\tmlog(ML_HEARTBEAT|ML_KTHREAD, \"o2hb thread exiting\\n\");\n\n\treturn 0;\n}\n\n#ifdef CONFIG_DEBUG_FS\nstatic int o2hb_debug_open(struct inode *inode, struct file *file)\n{\n\tstruct o2hb_debug_buf *db = inode->i_private;\n\tstruct o2hb_region *reg;\n\tunsigned long map[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\tunsigned long lts;\n\tchar *buf = NULL;\n\tint i = -1;\n\tint out = 0;\n\n\t \n\tBUG_ON(sizeof(map) < db->db_size);\n\n\tbuf = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\tgoto bail;\n\n\tswitch (db->db_type) {\n\tcase O2HB_DB_TYPE_LIVENODES:\n\tcase O2HB_DB_TYPE_LIVEREGIONS:\n\tcase O2HB_DB_TYPE_QUORUMREGIONS:\n\tcase O2HB_DB_TYPE_FAILEDREGIONS:\n\t\tspin_lock(&o2hb_live_lock);\n\t\tmemcpy(map, db->db_data, db->db_size);\n\t\tspin_unlock(&o2hb_live_lock);\n\t\tbreak;\n\n\tcase O2HB_DB_TYPE_REGION_LIVENODES:\n\t\tspin_lock(&o2hb_live_lock);\n\t\treg = (struct o2hb_region *)db->db_data;\n\t\tmemcpy(map, reg->hr_live_node_bitmap, db->db_size);\n\t\tspin_unlock(&o2hb_live_lock);\n\t\tbreak;\n\n\tcase O2HB_DB_TYPE_REGION_NUMBER:\n\t\treg = (struct o2hb_region *)db->db_data;\n\t\tout += scnprintf(buf + out, PAGE_SIZE - out, \"%d\\n\",\n\t\t\t\treg->hr_region_num);\n\t\tgoto done;\n\n\tcase O2HB_DB_TYPE_REGION_ELAPSED_TIME:\n\t\treg = (struct o2hb_region *)db->db_data;\n\t\tlts = reg->hr_last_timeout_start;\n\t\t \n\t\tif (lts)\n\t\t\tlts = jiffies_to_msecs(jiffies - lts);\n\t\tout += scnprintf(buf + out, PAGE_SIZE - out, \"%lu\\n\", lts);\n\t\tgoto done;\n\n\tcase O2HB_DB_TYPE_REGION_PINNED:\n\t\treg = (struct o2hb_region *)db->db_data;\n\t\tout += scnprintf(buf + out, PAGE_SIZE - out, \"%u\\n\",\n\t\t\t\t!!reg->hr_item_pinned);\n\t\tgoto done;\n\n\tdefault:\n\t\tgoto done;\n\t}\n\n\twhile ((i = find_next_bit(map, db->db_len, i + 1)) < db->db_len)\n\t\tout += scnprintf(buf + out, PAGE_SIZE - out, \"%d \", i);\n\tout += scnprintf(buf + out, PAGE_SIZE - out, \"\\n\");\n\ndone:\n\ti_size_write(inode, out);\n\n\tfile->private_data = buf;\n\n\treturn 0;\nbail:\n\treturn -ENOMEM;\n}\n\nstatic int o2hb_debug_release(struct inode *inode, struct file *file)\n{\n\tkfree(file->private_data);\n\treturn 0;\n}\n\nstatic ssize_t o2hb_debug_read(struct file *file, char __user *buf,\n\t\t\t\t size_t nbytes, loff_t *ppos)\n{\n\treturn simple_read_from_buffer(buf, nbytes, ppos, file->private_data,\n\t\t\t\t       i_size_read(file->f_mapping->host));\n}\n#else\nstatic int o2hb_debug_open(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}\nstatic int o2hb_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}\nstatic ssize_t o2hb_debug_read(struct file *file, char __user *buf,\n\t\t\t       size_t nbytes, loff_t *ppos)\n{\n\treturn 0;\n}\n#endif   \n\nstatic const struct file_operations o2hb_debug_fops = {\n\t.open =\t\to2hb_debug_open,\n\t.release =\to2hb_debug_release,\n\t.read =\t\to2hb_debug_read,\n\t.llseek =\tgeneric_file_llseek,\n};\n\nvoid o2hb_exit(void)\n{\n\tdebugfs_remove_recursive(o2hb_debug_dir);\n\tkfree(o2hb_db_livenodes);\n\tkfree(o2hb_db_liveregions);\n\tkfree(o2hb_db_quorumregions);\n\tkfree(o2hb_db_failedregions);\n}\n\nstatic void o2hb_debug_create(const char *name, struct dentry *dir,\n\t\t\t      struct o2hb_debug_buf **db, int db_len, int type,\n\t\t\t      int size, int len, void *data)\n{\n\t*db = kmalloc(db_len, GFP_KERNEL);\n\tif (!*db)\n\t\treturn;\n\n\t(*db)->db_type = type;\n\t(*db)->db_size = size;\n\t(*db)->db_len = len;\n\t(*db)->db_data = data;\n\n\tdebugfs_create_file(name, S_IFREG|S_IRUSR, dir, *db, &o2hb_debug_fops);\n}\n\nstatic void o2hb_debug_init(void)\n{\n\to2hb_debug_dir = debugfs_create_dir(O2HB_DEBUG_DIR, NULL);\n\n\to2hb_debug_create(O2HB_DEBUG_LIVENODES, o2hb_debug_dir,\n\t\t\t  &o2hb_db_livenodes, sizeof(*o2hb_db_livenodes),\n\t\t\t  O2HB_DB_TYPE_LIVENODES, sizeof(o2hb_live_node_bitmap),\n\t\t\t  O2NM_MAX_NODES, o2hb_live_node_bitmap);\n\n\to2hb_debug_create(O2HB_DEBUG_LIVEREGIONS, o2hb_debug_dir,\n\t\t\t  &o2hb_db_liveregions, sizeof(*o2hb_db_liveregions),\n\t\t\t  O2HB_DB_TYPE_LIVEREGIONS,\n\t\t\t  sizeof(o2hb_live_region_bitmap), O2NM_MAX_REGIONS,\n\t\t\t  o2hb_live_region_bitmap);\n\n\to2hb_debug_create(O2HB_DEBUG_QUORUMREGIONS, o2hb_debug_dir,\n\t\t\t  &o2hb_db_quorumregions,\n\t\t\t  sizeof(*o2hb_db_quorumregions),\n\t\t\t  O2HB_DB_TYPE_QUORUMREGIONS,\n\t\t\t  sizeof(o2hb_quorum_region_bitmap), O2NM_MAX_REGIONS,\n\t\t\t  o2hb_quorum_region_bitmap);\n\n\to2hb_debug_create(O2HB_DEBUG_FAILEDREGIONS, o2hb_debug_dir,\n\t\t\t  &o2hb_db_failedregions,\n\t\t\t  sizeof(*o2hb_db_failedregions),\n\t\t\t  O2HB_DB_TYPE_FAILEDREGIONS,\n\t\t\t  sizeof(o2hb_failed_region_bitmap), O2NM_MAX_REGIONS,\n\t\t\t  o2hb_failed_region_bitmap);\n}\n\nvoid o2hb_init(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(o2hb_callbacks); i++)\n\t\tINIT_LIST_HEAD(&o2hb_callbacks[i].list);\n\n\tfor (i = 0; i < ARRAY_SIZE(o2hb_live_slots); i++)\n\t\tINIT_LIST_HEAD(&o2hb_live_slots[i]);\n\n\tbitmap_zero(o2hb_live_node_bitmap, O2NM_MAX_NODES);\n\tbitmap_zero(o2hb_region_bitmap, O2NM_MAX_REGIONS);\n\tbitmap_zero(o2hb_live_region_bitmap, O2NM_MAX_REGIONS);\n\tbitmap_zero(o2hb_quorum_region_bitmap, O2NM_MAX_REGIONS);\n\tbitmap_zero(o2hb_failed_region_bitmap, O2NM_MAX_REGIONS);\n\n\to2hb_dependent_users = 0;\n\n\to2hb_debug_init();\n}\n\n \nstatic void o2hb_fill_node_map_from_callback(unsigned long *map,\n\t\t\t\t\t     unsigned int bits)\n{\n\tbitmap_copy(map, o2hb_live_node_bitmap, bits);\n}\n\n \nvoid o2hb_fill_node_map(unsigned long *map, unsigned int bits)\n{\n\t \n\tdown_read(&o2hb_callback_sem);\n\tspin_lock(&o2hb_live_lock);\n\to2hb_fill_node_map_from_callback(map, bits);\n\tspin_unlock(&o2hb_live_lock);\n\tup_read(&o2hb_callback_sem);\n}\nEXPORT_SYMBOL_GPL(o2hb_fill_node_map);\n\n \n\nstatic struct o2hb_region *to_o2hb_region(struct config_item *item)\n{\n\treturn item ? container_of(item, struct o2hb_region, hr_item) : NULL;\n}\n\n \nstatic void o2hb_region_release(struct config_item *item)\n{\n\tint i;\n\tstruct page *page;\n\tstruct o2hb_region *reg = to_o2hb_region(item);\n\n\tmlog(ML_HEARTBEAT, \"hb region release (%pg)\\n\", reg->hr_bdev);\n\n\tkfree(reg->hr_tmp_block);\n\n\tif (reg->hr_slot_data) {\n\t\tfor (i = 0; i < reg->hr_num_pages; i++) {\n\t\t\tpage = reg->hr_slot_data[i];\n\t\t\tif (page)\n\t\t\t\t__free_page(page);\n\t\t}\n\t\tkfree(reg->hr_slot_data);\n\t}\n\n\tif (reg->hr_bdev)\n\t\tblkdev_put(reg->hr_bdev, NULL);\n\n\tkfree(reg->hr_slots);\n\n\tdebugfs_remove_recursive(reg->hr_debug_dir);\n\tkfree(reg->hr_db_livenodes);\n\tkfree(reg->hr_db_regnum);\n\tkfree(reg->hr_db_elapsed_time);\n\tkfree(reg->hr_db_pinned);\n\n\tspin_lock(&o2hb_live_lock);\n\tlist_del(&reg->hr_all_item);\n\tspin_unlock(&o2hb_live_lock);\n\n\to2net_unregister_handler_list(&reg->hr_handler_list);\n\tkfree(reg);\n}\n\nstatic int o2hb_read_block_input(struct o2hb_region *reg,\n\t\t\t\t const char *page,\n\t\t\t\t unsigned long *ret_bytes,\n\t\t\t\t unsigned int *ret_bits)\n{\n\tunsigned long bytes;\n\tchar *p = (char *)page;\n\n\tbytes = simple_strtoul(p, &p, 0);\n\tif (!p || (*p && (*p != '\\n')))\n\t\treturn -EINVAL;\n\n\t \n\tif (bytes > 4096 || bytes < 512)\n\t\treturn -ERANGE;\n\tif (hweight16(bytes) != 1)\n\t\treturn -EINVAL;\n\n\tif (ret_bytes)\n\t\t*ret_bytes = bytes;\n\tif (ret_bits)\n\t\t*ret_bits = ffs(bytes) - 1;\n\n\treturn 0;\n}\n\nstatic ssize_t o2hb_region_block_bytes_show(struct config_item *item,\n\t\t\t\t\t    char *page)\n{\n\treturn sprintf(page, \"%u\\n\", to_o2hb_region(item)->hr_block_bytes);\n}\n\nstatic ssize_t o2hb_region_block_bytes_store(struct config_item *item,\n\t\t\t\t\t     const char *page,\n\t\t\t\t\t     size_t count)\n{\n\tstruct o2hb_region *reg = to_o2hb_region(item);\n\tint status;\n\tunsigned long block_bytes;\n\tunsigned int block_bits;\n\n\tif (reg->hr_bdev)\n\t\treturn -EINVAL;\n\n\tstatus = o2hb_read_block_input(reg, page, &block_bytes,\n\t\t\t\t       &block_bits);\n\tif (status)\n\t\treturn status;\n\n\treg->hr_block_bytes = (unsigned int)block_bytes;\n\treg->hr_block_bits = block_bits;\n\n\treturn count;\n}\n\nstatic ssize_t o2hb_region_start_block_show(struct config_item *item,\n\t\t\t\t\t    char *page)\n{\n\treturn sprintf(page, \"%llu\\n\", to_o2hb_region(item)->hr_start_block);\n}\n\nstatic ssize_t o2hb_region_start_block_store(struct config_item *item,\n\t\t\t\t\t     const char *page,\n\t\t\t\t\t     size_t count)\n{\n\tstruct o2hb_region *reg = to_o2hb_region(item);\n\tunsigned long long tmp;\n\tchar *p = (char *)page;\n\tssize_t ret;\n\n\tif (reg->hr_bdev)\n\t\treturn -EINVAL;\n\n\tret = kstrtoull(p, 0, &tmp);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\treg->hr_start_block = tmp;\n\n\treturn count;\n}\n\nstatic ssize_t o2hb_region_blocks_show(struct config_item *item, char *page)\n{\n\treturn sprintf(page, \"%d\\n\", to_o2hb_region(item)->hr_blocks);\n}\n\nstatic ssize_t o2hb_region_blocks_store(struct config_item *item,\n\t\t\t\t\tconst char *page,\n\t\t\t\t\tsize_t count)\n{\n\tstruct o2hb_region *reg = to_o2hb_region(item);\n\tunsigned long tmp;\n\tchar *p = (char *)page;\n\n\tif (reg->hr_bdev)\n\t\treturn -EINVAL;\n\n\ttmp = simple_strtoul(p, &p, 0);\n\tif (!p || (*p && (*p != '\\n')))\n\t\treturn -EINVAL;\n\n\tif (tmp > O2NM_MAX_NODES || tmp == 0)\n\t\treturn -ERANGE;\n\n\treg->hr_blocks = (unsigned int)tmp;\n\n\treturn count;\n}\n\nstatic ssize_t o2hb_region_dev_show(struct config_item *item, char *page)\n{\n\tunsigned int ret = 0;\n\n\tif (to_o2hb_region(item)->hr_bdev)\n\t\tret = sprintf(page, \"%pg\\n\", to_o2hb_region(item)->hr_bdev);\n\n\treturn ret;\n}\n\nstatic void o2hb_init_region_params(struct o2hb_region *reg)\n{\n\treg->hr_slots_per_page = PAGE_SIZE >> reg->hr_block_bits;\n\treg->hr_timeout_ms = O2HB_REGION_TIMEOUT_MS;\n\n\tmlog(ML_HEARTBEAT, \"hr_start_block = %llu, hr_blocks = %u\\n\",\n\t     reg->hr_start_block, reg->hr_blocks);\n\tmlog(ML_HEARTBEAT, \"hr_block_bytes = %u, hr_block_bits = %u\\n\",\n\t     reg->hr_block_bytes, reg->hr_block_bits);\n\tmlog(ML_HEARTBEAT, \"hr_timeout_ms = %u\\n\", reg->hr_timeout_ms);\n\tmlog(ML_HEARTBEAT, \"dead threshold = %u\\n\", o2hb_dead_threshold);\n}\n\nstatic int o2hb_map_slot_data(struct o2hb_region *reg)\n{\n\tint i, j;\n\tunsigned int last_slot;\n\tunsigned int spp = reg->hr_slots_per_page;\n\tstruct page *page;\n\tchar *raw;\n\tstruct o2hb_disk_slot *slot;\n\n\treg->hr_tmp_block = kmalloc(reg->hr_block_bytes, GFP_KERNEL);\n\tif (reg->hr_tmp_block == NULL)\n\t\treturn -ENOMEM;\n\n\treg->hr_slots = kcalloc(reg->hr_blocks,\n\t\t\t\tsizeof(struct o2hb_disk_slot), GFP_KERNEL);\n\tif (reg->hr_slots == NULL)\n\t\treturn -ENOMEM;\n\n\tfor(i = 0; i < reg->hr_blocks; i++) {\n\t\tslot = &reg->hr_slots[i];\n\t\tslot->ds_node_num = i;\n\t\tINIT_LIST_HEAD(&slot->ds_live_item);\n\t\tslot->ds_raw_block = NULL;\n\t}\n\n\treg->hr_num_pages = (reg->hr_blocks + spp - 1) / spp;\n\tmlog(ML_HEARTBEAT, \"Going to require %u pages to cover %u blocks \"\n\t\t\t   \"at %u blocks per page\\n\",\n\t     reg->hr_num_pages, reg->hr_blocks, spp);\n\n\treg->hr_slot_data = kcalloc(reg->hr_num_pages, sizeof(struct page *),\n\t\t\t\t    GFP_KERNEL);\n\tif (!reg->hr_slot_data)\n\t\treturn -ENOMEM;\n\n\tfor(i = 0; i < reg->hr_num_pages; i++) {\n\t\tpage = alloc_page(GFP_KERNEL);\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\n\t\treg->hr_slot_data[i] = page;\n\n\t\tlast_slot = i * spp;\n\t\traw = page_address(page);\n\t\tfor (j = 0;\n\t\t     (j < spp) && ((j + last_slot) < reg->hr_blocks);\n\t\t     j++) {\n\t\t\tBUG_ON((j + last_slot) >= reg->hr_blocks);\n\n\t\t\tslot = &reg->hr_slots[j + last_slot];\n\t\t\tslot->ds_raw_block =\n\t\t\t\t(struct o2hb_disk_heartbeat_block *) raw;\n\n\t\t\traw += reg->hr_block_bytes;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int o2hb_populate_slot_data(struct o2hb_region *reg)\n{\n\tint ret, i;\n\tstruct o2hb_disk_slot *slot;\n\tstruct o2hb_disk_heartbeat_block *hb_block;\n\n\tret = o2hb_read_slots(reg, 0, reg->hr_blocks);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tfor(i = 0; i < reg->hr_blocks; i++) {\n\t\tslot = &reg->hr_slots[i];\n\t\thb_block = (struct o2hb_disk_heartbeat_block *) slot->ds_raw_block;\n\n\t\t \n\t\tslot->ds_last_time = le64_to_cpu(hb_block->hb_seq);\n\t\tslot->ds_last_generation = le64_to_cpu(hb_block->hb_generation);\n\t}\n\nout:\n\treturn ret;\n}\n\n \nstatic ssize_t o2hb_region_dev_store(struct config_item *item,\n\t\t\t\t     const char *page,\n\t\t\t\t     size_t count)\n{\n\tstruct o2hb_region *reg = to_o2hb_region(item);\n\tstruct task_struct *hb_task;\n\tlong fd;\n\tint sectsize;\n\tchar *p = (char *)page;\n\tstruct fd f;\n\tssize_t ret = -EINVAL;\n\tint live_threshold;\n\n\tif (reg->hr_bdev)\n\t\tgoto out;\n\n\t \n\tif (o2nm_this_node() == O2NM_MAX_NODES)\n\t\tgoto out;\n\n\tfd = simple_strtol(p, &p, 0);\n\tif (!p || (*p && (*p != '\\n')))\n\t\tgoto out;\n\n\tif (fd < 0 || fd >= INT_MAX)\n\t\tgoto out;\n\n\tf = fdget(fd);\n\tif (f.file == NULL)\n\t\tgoto out;\n\n\tif (reg->hr_blocks == 0 || reg->hr_start_block == 0 ||\n\t    reg->hr_block_bytes == 0)\n\t\tgoto out2;\n\n\tif (!S_ISBLK(f.file->f_mapping->host->i_mode))\n\t\tgoto out2;\n\n\treg->hr_bdev = blkdev_get_by_dev(f.file->f_mapping->host->i_rdev,\n\t\t\t\t\t BLK_OPEN_WRITE | BLK_OPEN_READ, NULL,\n\t\t\t\t\t NULL);\n\tif (IS_ERR(reg->hr_bdev)) {\n\t\tret = PTR_ERR(reg->hr_bdev);\n\t\treg->hr_bdev = NULL;\n\t\tgoto out2;\n\t}\n\n\tsectsize = bdev_logical_block_size(reg->hr_bdev);\n\tif (sectsize != reg->hr_block_bytes) {\n\t\tmlog(ML_ERROR,\n\t\t     \"blocksize %u incorrect for device, expected %d\",\n\t\t     reg->hr_block_bytes, sectsize);\n\t\tret = -EINVAL;\n\t\tgoto out3;\n\t}\n\n\to2hb_init_region_params(reg);\n\n\t \n\tdo {\n\t\tget_random_bytes(&reg->hr_generation,\n\t\t\t\t sizeof(reg->hr_generation));\n\t} while (reg->hr_generation == 0);\n\n\tret = o2hb_map_slot_data(reg);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out3;\n\t}\n\n\tret = o2hb_populate_slot_data(reg);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out3;\n\t}\n\n\tINIT_DELAYED_WORK(&reg->hr_write_timeout_work, o2hb_write_timeout);\n\tINIT_DELAYED_WORK(&reg->hr_nego_timeout_work, o2hb_nego_timeout);\n\n\t \n\tlive_threshold = O2HB_LIVE_THRESHOLD;\n\tif (o2hb_global_heartbeat_active()) {\n\t\tspin_lock(&o2hb_live_lock);\n\t\tif (bitmap_weight(o2hb_region_bitmap, O2NM_MAX_REGIONS) == 1)\n\t\t\tlive_threshold <<= 1;\n\t\tspin_unlock(&o2hb_live_lock);\n\t}\n\t++live_threshold;\n\tatomic_set(&reg->hr_steady_iterations, live_threshold);\n\t \n\tatomic_set(&reg->hr_unsteady_iterations, (live_threshold * 3));\n\n\thb_task = kthread_run(o2hb_thread, reg, \"o2hb-%s\",\n\t\t\t      reg->hr_item.ci_name);\n\tif (IS_ERR(hb_task)) {\n\t\tret = PTR_ERR(hb_task);\n\t\tmlog_errno(ret);\n\t\tgoto out3;\n\t}\n\n\tspin_lock(&o2hb_live_lock);\n\treg->hr_task = hb_task;\n\tspin_unlock(&o2hb_live_lock);\n\n\tret = wait_event_interruptible(o2hb_steady_queue,\n\t\t\t\tatomic_read(&reg->hr_steady_iterations) == 0 ||\n\t\t\t\treg->hr_node_deleted);\n\tif (ret) {\n\t\tatomic_set(&reg->hr_steady_iterations, 0);\n\t\treg->hr_aborted_start = 1;\n\t}\n\n\tif (reg->hr_aborted_start) {\n\t\tret = -EIO;\n\t\tgoto out3;\n\t}\n\n\tif (reg->hr_node_deleted) {\n\t\tret = -EINVAL;\n\t\tgoto out3;\n\t}\n\n\t \n\tspin_lock(&o2hb_live_lock);\n\thb_task = reg->hr_task;\n\tif (o2hb_global_heartbeat_active())\n\t\tset_bit(reg->hr_region_num, o2hb_live_region_bitmap);\n\tspin_unlock(&o2hb_live_lock);\n\n\tif (hb_task)\n\t\tret = count;\n\telse\n\t\tret = -EIO;\n\n\tif (hb_task && o2hb_global_heartbeat_active())\n\t\tprintk(KERN_NOTICE \"o2hb: Heartbeat started on region %s (%pg)\\n\",\n\t\t       config_item_name(&reg->hr_item), reg->hr_bdev);\n\nout3:\n\tif (ret < 0) {\n\t\tblkdev_put(reg->hr_bdev, NULL);\n\t\treg->hr_bdev = NULL;\n\t}\nout2:\n\tfdput(f);\nout:\n\treturn ret;\n}\n\nstatic ssize_t o2hb_region_pid_show(struct config_item *item, char *page)\n{\n\tstruct o2hb_region *reg = to_o2hb_region(item);\n\tpid_t pid = 0;\n\n\tspin_lock(&o2hb_live_lock);\n\tif (reg->hr_task)\n\t\tpid = task_pid_nr(reg->hr_task);\n\tspin_unlock(&o2hb_live_lock);\n\n\tif (!pid)\n\t\treturn 0;\n\n\treturn sprintf(page, \"%u\\n\", pid);\n}\n\nCONFIGFS_ATTR(o2hb_region_, block_bytes);\nCONFIGFS_ATTR(o2hb_region_, start_block);\nCONFIGFS_ATTR(o2hb_region_, blocks);\nCONFIGFS_ATTR(o2hb_region_, dev);\nCONFIGFS_ATTR_RO(o2hb_region_, pid);\n\nstatic struct configfs_attribute *o2hb_region_attrs[] = {\n\t&o2hb_region_attr_block_bytes,\n\t&o2hb_region_attr_start_block,\n\t&o2hb_region_attr_blocks,\n\t&o2hb_region_attr_dev,\n\t&o2hb_region_attr_pid,\n\tNULL,\n};\n\nstatic struct configfs_item_operations o2hb_region_item_ops = {\n\t.release\t\t= o2hb_region_release,\n};\n\nstatic const struct config_item_type o2hb_region_type = {\n\t.ct_item_ops\t= &o2hb_region_item_ops,\n\t.ct_attrs\t= o2hb_region_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\n \n\nstruct o2hb_heartbeat_group {\n\tstruct config_group hs_group;\n\t \n};\n\nstatic struct o2hb_heartbeat_group *to_o2hb_heartbeat_group(struct config_group *group)\n{\n\treturn group ?\n\t\tcontainer_of(group, struct o2hb_heartbeat_group, hs_group)\n\t\t: NULL;\n}\n\nstatic void o2hb_debug_region_init(struct o2hb_region *reg,\n\t\t\t\t   struct dentry *parent)\n{\n\tstruct dentry *dir;\n\n\tdir = debugfs_create_dir(config_item_name(&reg->hr_item), parent);\n\treg->hr_debug_dir = dir;\n\n\to2hb_debug_create(O2HB_DEBUG_LIVENODES, dir, &(reg->hr_db_livenodes),\n\t\t\t  sizeof(*(reg->hr_db_livenodes)),\n\t\t\t  O2HB_DB_TYPE_REGION_LIVENODES,\n\t\t\t  sizeof(reg->hr_live_node_bitmap), O2NM_MAX_NODES,\n\t\t\t  reg);\n\n\to2hb_debug_create(O2HB_DEBUG_REGION_NUMBER, dir, &(reg->hr_db_regnum),\n\t\t\t  sizeof(*(reg->hr_db_regnum)),\n\t\t\t  O2HB_DB_TYPE_REGION_NUMBER, 0, O2NM_MAX_NODES, reg);\n\n\to2hb_debug_create(O2HB_DEBUG_REGION_ELAPSED_TIME, dir,\n\t\t\t  &(reg->hr_db_elapsed_time),\n\t\t\t  sizeof(*(reg->hr_db_elapsed_time)),\n\t\t\t  O2HB_DB_TYPE_REGION_ELAPSED_TIME, 0, 0, reg);\n\n\to2hb_debug_create(O2HB_DEBUG_REGION_PINNED, dir, &(reg->hr_db_pinned),\n\t\t\t  sizeof(*(reg->hr_db_pinned)),\n\t\t\t  O2HB_DB_TYPE_REGION_PINNED, 0, 0, reg);\n\n}\n\nstatic struct config_item *o2hb_heartbeat_group_make_item(struct config_group *group,\n\t\t\t\t\t\t\t  const char *name)\n{\n\tstruct o2hb_region *reg = NULL;\n\tint ret;\n\n\treg = kzalloc(sizeof(struct o2hb_region), GFP_KERNEL);\n\tif (reg == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (strlen(name) > O2HB_MAX_REGION_NAME_LEN) {\n\t\tret = -ENAMETOOLONG;\n\t\tgoto free;\n\t}\n\n\tspin_lock(&o2hb_live_lock);\n\treg->hr_region_num = 0;\n\tif (o2hb_global_heartbeat_active()) {\n\t\treg->hr_region_num = find_first_zero_bit(o2hb_region_bitmap,\n\t\t\t\t\t\t\t O2NM_MAX_REGIONS);\n\t\tif (reg->hr_region_num >= O2NM_MAX_REGIONS) {\n\t\t\tspin_unlock(&o2hb_live_lock);\n\t\t\tret = -EFBIG;\n\t\t\tgoto free;\n\t\t}\n\t\tset_bit(reg->hr_region_num, o2hb_region_bitmap);\n\t}\n\tlist_add_tail(&reg->hr_all_item, &o2hb_all_regions);\n\tspin_unlock(&o2hb_live_lock);\n\n\tconfig_item_init_type_name(&reg->hr_item, name, &o2hb_region_type);\n\n\t \n\treg->hr_key = crc32_le(reg->hr_region_num + O2NM_MAX_REGIONS,\n\t\tname, strlen(name));\n\tINIT_LIST_HEAD(&reg->hr_handler_list);\n\tret = o2net_register_handler(O2HB_NEGO_TIMEOUT_MSG, reg->hr_key,\n\t\t\tsizeof(struct o2hb_nego_msg),\n\t\t\to2hb_nego_timeout_handler,\n\t\t\treg, NULL, &reg->hr_handler_list);\n\tif (ret)\n\t\tgoto remove_item;\n\n\tret = o2net_register_handler(O2HB_NEGO_APPROVE_MSG, reg->hr_key,\n\t\t\tsizeof(struct o2hb_nego_msg),\n\t\t\to2hb_nego_approve_handler,\n\t\t\treg, NULL, &reg->hr_handler_list);\n\tif (ret)\n\t\tgoto unregister_handler;\n\n\to2hb_debug_region_init(reg, o2hb_debug_dir);\n\n\treturn &reg->hr_item;\n\nunregister_handler:\n\to2net_unregister_handler_list(&reg->hr_handler_list);\nremove_item:\n\tspin_lock(&o2hb_live_lock);\n\tlist_del(&reg->hr_all_item);\n\tif (o2hb_global_heartbeat_active())\n\t\tclear_bit(reg->hr_region_num, o2hb_region_bitmap);\n\tspin_unlock(&o2hb_live_lock);\nfree:\n\tkfree(reg);\n\treturn ERR_PTR(ret);\n}\n\nstatic void o2hb_heartbeat_group_drop_item(struct config_group *group,\n\t\t\t\t\t   struct config_item *item)\n{\n\tstruct task_struct *hb_task;\n\tstruct o2hb_region *reg = to_o2hb_region(item);\n\tint quorum_region = 0;\n\n\t \n\tspin_lock(&o2hb_live_lock);\n\thb_task = reg->hr_task;\n\treg->hr_task = NULL;\n\treg->hr_item_dropped = 1;\n\tspin_unlock(&o2hb_live_lock);\n\n\tif (hb_task)\n\t\tkthread_stop(hb_task);\n\n\tif (o2hb_global_heartbeat_active()) {\n\t\tspin_lock(&o2hb_live_lock);\n\t\tclear_bit(reg->hr_region_num, o2hb_region_bitmap);\n\t\tclear_bit(reg->hr_region_num, o2hb_live_region_bitmap);\n\t\tif (test_bit(reg->hr_region_num, o2hb_quorum_region_bitmap))\n\t\t\tquorum_region = 1;\n\t\tclear_bit(reg->hr_region_num, o2hb_quorum_region_bitmap);\n\t\tspin_unlock(&o2hb_live_lock);\n\t\tprintk(KERN_NOTICE \"o2hb: Heartbeat %s on region %s (%pg)\\n\",\n\t\t       ((atomic_read(&reg->hr_steady_iterations) == 0) ?\n\t\t\t\"stopped\" : \"start aborted\"), config_item_name(item),\n\t\t       reg->hr_bdev);\n\t}\n\n\t \n\tif (atomic_read(&reg->hr_steady_iterations) != 0) {\n\t\treg->hr_aborted_start = 1;\n\t\tatomic_set(&reg->hr_steady_iterations, 0);\n\t\twake_up(&o2hb_steady_queue);\n\t}\n\n\tconfig_item_put(item);\n\n\tif (!o2hb_global_heartbeat_active() || !quorum_region)\n\t\treturn;\n\n\t \n\tspin_lock(&o2hb_live_lock);\n\n\tif (!o2hb_dependent_users)\n\t\tgoto unlock;\n\n\tif (bitmap_weight(o2hb_quorum_region_bitmap,\n\t\t\t   O2NM_MAX_REGIONS) <= O2HB_PIN_CUT_OFF)\n\t\to2hb_region_pin(NULL);\n\nunlock:\n\tspin_unlock(&o2hb_live_lock);\n}\n\nstatic ssize_t o2hb_heartbeat_group_dead_threshold_show(struct config_item *item,\n\t\tchar *page)\n{\n\treturn sprintf(page, \"%u\\n\", o2hb_dead_threshold);\n}\n\nstatic ssize_t o2hb_heartbeat_group_dead_threshold_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tunsigned long tmp;\n\tchar *p = (char *)page;\n\n\ttmp = simple_strtoul(p, &p, 10);\n\tif (!p || (*p && (*p != '\\n')))\n                return -EINVAL;\n\n\t \n\to2hb_dead_threshold_set((unsigned int) tmp);\n\n\treturn count;\n}\n\nstatic ssize_t o2hb_heartbeat_group_mode_show(struct config_item *item,\n\t\tchar *page)\n{\n\treturn sprintf(page, \"%s\\n\",\n\t\t       o2hb_heartbeat_mode_desc[o2hb_heartbeat_mode]);\n}\n\nstatic ssize_t o2hb_heartbeat_group_mode_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tunsigned int i;\n\tint ret;\n\tsize_t len;\n\n\tlen = (page[count - 1] == '\\n') ? count - 1 : count;\n\tif (!len)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < O2HB_HEARTBEAT_NUM_MODES; ++i) {\n\t\tif (strncasecmp(page, o2hb_heartbeat_mode_desc[i], len))\n\t\t\tcontinue;\n\n\t\tret = o2hb_global_heartbeat_mode_set(i);\n\t\tif (!ret)\n\t\t\tprintk(KERN_NOTICE \"o2hb: Heartbeat mode set to %s\\n\",\n\t\t\t       o2hb_heartbeat_mode_desc[i]);\n\t\treturn count;\n\t}\n\n\treturn -EINVAL;\n\n}\n\nCONFIGFS_ATTR(o2hb_heartbeat_group_, dead_threshold);\nCONFIGFS_ATTR(o2hb_heartbeat_group_, mode);\n\nstatic struct configfs_attribute *o2hb_heartbeat_group_attrs[] = {\n\t&o2hb_heartbeat_group_attr_dead_threshold,\n\t&o2hb_heartbeat_group_attr_mode,\n\tNULL,\n};\n\nstatic struct configfs_group_operations o2hb_heartbeat_group_group_ops = {\n\t.make_item\t= o2hb_heartbeat_group_make_item,\n\t.drop_item\t= o2hb_heartbeat_group_drop_item,\n};\n\nstatic const struct config_item_type o2hb_heartbeat_group_type = {\n\t.ct_group_ops\t= &o2hb_heartbeat_group_group_ops,\n\t.ct_attrs\t= o2hb_heartbeat_group_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\n \nstruct config_group *o2hb_alloc_hb_set(void)\n{\n\tstruct o2hb_heartbeat_group *hs = NULL;\n\tstruct config_group *ret = NULL;\n\n\ths = kzalloc(sizeof(struct o2hb_heartbeat_group), GFP_KERNEL);\n\tif (hs == NULL)\n\t\tgoto out;\n\n\tconfig_group_init_type_name(&hs->hs_group, \"heartbeat\",\n\t\t\t\t    &o2hb_heartbeat_group_type);\n\n\tret = &hs->hs_group;\nout:\n\tif (ret == NULL)\n\t\tkfree(hs);\n\treturn ret;\n}\n\nvoid o2hb_free_hb_set(struct config_group *group)\n{\n\tstruct o2hb_heartbeat_group *hs = to_o2hb_heartbeat_group(group);\n\tkfree(hs);\n}\n\n \n\nstatic struct o2hb_callback *hbcall_from_type(enum o2hb_callback_type type)\n{\n\tif (type == O2HB_NUM_CB)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn &o2hb_callbacks[type];\n}\n\nvoid o2hb_setup_callback(struct o2hb_callback_func *hc,\n\t\t\t enum o2hb_callback_type type,\n\t\t\t o2hb_cb_func *func,\n\t\t\t void *data,\n\t\t\t int priority)\n{\n\tINIT_LIST_HEAD(&hc->hc_item);\n\thc->hc_func = func;\n\thc->hc_data = data;\n\thc->hc_priority = priority;\n\thc->hc_type = type;\n\thc->hc_magic = O2HB_CB_MAGIC;\n}\nEXPORT_SYMBOL_GPL(o2hb_setup_callback);\n\n \nstatic int o2hb_region_pin(const char *region_uuid)\n{\n\tint ret = 0, found = 0;\n\tstruct o2hb_region *reg;\n\tchar *uuid;\n\n\tassert_spin_locked(&o2hb_live_lock);\n\n\tlist_for_each_entry(reg, &o2hb_all_regions, hr_all_item) {\n\t\tif (reg->hr_item_dropped)\n\t\t\tcontinue;\n\n\t\tuuid = config_item_name(&reg->hr_item);\n\n\t\t \n\t\tif (region_uuid) {\n\t\t\tif (strcmp(region_uuid, uuid))\n\t\t\t\tcontinue;\n\t\t\tfound = 1;\n\t\t}\n\n\t\tif (reg->hr_item_pinned || reg->hr_item_dropped)\n\t\t\tgoto skip_pin;\n\n\t\t \n\t\tret = o2nm_depend_item(&reg->hr_item);\n\t\tif (!ret) {\n\t\t\tmlog(ML_CLUSTER, \"Pin region %s\\n\", uuid);\n\t\t\treg->hr_item_pinned = 1;\n\t\t} else {\n\t\t\tif (ret == -ENOENT && found)\n\t\t\t\tret = 0;\n\t\t\telse {\n\t\t\t\tmlog(ML_ERROR, \"Pin region %s fails with %d\\n\",\n\t\t\t\t     uuid, ret);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\nskip_pin:\n\t\tif (found)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n \nstatic void o2hb_region_unpin(const char *region_uuid)\n{\n\tstruct o2hb_region *reg;\n\tchar *uuid;\n\tint found = 0;\n\n\tassert_spin_locked(&o2hb_live_lock);\n\n\tlist_for_each_entry(reg, &o2hb_all_regions, hr_all_item) {\n\t\tif (reg->hr_item_dropped)\n\t\t\tcontinue;\n\n\t\tuuid = config_item_name(&reg->hr_item);\n\t\tif (region_uuid) {\n\t\t\tif (strcmp(region_uuid, uuid))\n\t\t\t\tcontinue;\n\t\t\tfound = 1;\n\t\t}\n\n\t\tif (reg->hr_item_pinned) {\n\t\t\tmlog(ML_CLUSTER, \"Unpin region %s\\n\", uuid);\n\t\t\to2nm_undepend_item(&reg->hr_item);\n\t\t\treg->hr_item_pinned = 0;\n\t\t}\n\t\tif (found)\n\t\t\tbreak;\n\t}\n}\n\nstatic int o2hb_region_inc_user(const char *region_uuid)\n{\n\tint ret = 0;\n\n\tspin_lock(&o2hb_live_lock);\n\n\t \n\tif (!o2hb_global_heartbeat_active()) {\n\t    ret = o2hb_region_pin(region_uuid);\n\t    goto unlock;\n\t}\n\n\t \n\to2hb_dependent_users++;\n\tif (o2hb_dependent_users > 1)\n\t\tgoto unlock;\n\n\tif (bitmap_weight(o2hb_quorum_region_bitmap,\n\t\t\t   O2NM_MAX_REGIONS) <= O2HB_PIN_CUT_OFF)\n\t\tret = o2hb_region_pin(NULL);\n\nunlock:\n\tspin_unlock(&o2hb_live_lock);\n\treturn ret;\n}\n\nstatic void o2hb_region_dec_user(const char *region_uuid)\n{\n\tspin_lock(&o2hb_live_lock);\n\n\t \n\tif (!o2hb_global_heartbeat_active()) {\n\t    o2hb_region_unpin(region_uuid);\n\t    goto unlock;\n\t}\n\n\t \n\to2hb_dependent_users--;\n\tif (!o2hb_dependent_users)\n\t\to2hb_region_unpin(NULL);\n\nunlock:\n\tspin_unlock(&o2hb_live_lock);\n}\n\nint o2hb_register_callback(const char *region_uuid,\n\t\t\t   struct o2hb_callback_func *hc)\n{\n\tstruct o2hb_callback_func *f;\n\tstruct o2hb_callback *hbcall;\n\tint ret;\n\n\tBUG_ON(hc->hc_magic != O2HB_CB_MAGIC);\n\tBUG_ON(!list_empty(&hc->hc_item));\n\n\thbcall = hbcall_from_type(hc->hc_type);\n\tif (IS_ERR(hbcall)) {\n\t\tret = PTR_ERR(hbcall);\n\t\tgoto out;\n\t}\n\n\tif (region_uuid) {\n\t\tret = o2hb_region_inc_user(region_uuid);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tdown_write(&o2hb_callback_sem);\n\n\tlist_for_each_entry(f, &hbcall->list, hc_item) {\n\t\tif (hc->hc_priority < f->hc_priority) {\n\t\t\tlist_add_tail(&hc->hc_item, &f->hc_item);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (list_empty(&hc->hc_item))\n\t\tlist_add_tail(&hc->hc_item, &hbcall->list);\n\n\tup_write(&o2hb_callback_sem);\n\tret = 0;\nout:\n\tmlog(ML_CLUSTER, \"returning %d on behalf of %p for funcs %p\\n\",\n\t     ret, __builtin_return_address(0), hc);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(o2hb_register_callback);\n\nvoid o2hb_unregister_callback(const char *region_uuid,\n\t\t\t      struct o2hb_callback_func *hc)\n{\n\tBUG_ON(hc->hc_magic != O2HB_CB_MAGIC);\n\n\tmlog(ML_CLUSTER, \"on behalf of %p for funcs %p\\n\",\n\t     __builtin_return_address(0), hc);\n\n\t \n\tif (list_empty(&hc->hc_item))\n\t\treturn;\n\n\tif (region_uuid)\n\t\to2hb_region_dec_user(region_uuid);\n\n\tdown_write(&o2hb_callback_sem);\n\n\tlist_del_init(&hc->hc_item);\n\n\tup_write(&o2hb_callback_sem);\n}\nEXPORT_SYMBOL_GPL(o2hb_unregister_callback);\n\nint o2hb_check_node_heartbeating_no_sem(u8 node_num)\n{\n\tunsigned long testing_map[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\n\tspin_lock(&o2hb_live_lock);\n\to2hb_fill_node_map_from_callback(testing_map, O2NM_MAX_NODES);\n\tspin_unlock(&o2hb_live_lock);\n\tif (!test_bit(node_num, testing_map)) {\n\t\tmlog(ML_HEARTBEAT,\n\t\t     \"node (%u) does not have heartbeating enabled.\\n\",\n\t\t     node_num);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\nEXPORT_SYMBOL_GPL(o2hb_check_node_heartbeating_no_sem);\n\nint o2hb_check_node_heartbeating_from_callback(u8 node_num)\n{\n\tunsigned long testing_map[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\n\to2hb_fill_node_map_from_callback(testing_map, O2NM_MAX_NODES);\n\tif (!test_bit(node_num, testing_map)) {\n\t\tmlog(ML_HEARTBEAT,\n\t\t     \"node (%u) does not have heartbeating enabled.\\n\",\n\t\t     node_num);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\nEXPORT_SYMBOL_GPL(o2hb_check_node_heartbeating_from_callback);\n\n \nvoid o2hb_stop_all_regions(void)\n{\n\tstruct o2hb_region *reg;\n\n\tmlog(ML_ERROR, \"stopping heartbeat on all active regions.\\n\");\n\n\tspin_lock(&o2hb_live_lock);\n\n\tlist_for_each_entry(reg, &o2hb_all_regions, hr_all_item)\n\t\treg->hr_unclean_stop = 1;\n\n\tspin_unlock(&o2hb_live_lock);\n}\nEXPORT_SYMBOL_GPL(o2hb_stop_all_regions);\n\nint o2hb_get_all_regions(char *region_uuids, u8 max_regions)\n{\n\tstruct o2hb_region *reg;\n\tint numregs = 0;\n\tchar *p;\n\n\tspin_lock(&o2hb_live_lock);\n\n\tp = region_uuids;\n\tlist_for_each_entry(reg, &o2hb_all_regions, hr_all_item) {\n\t\tif (reg->hr_item_dropped)\n\t\t\tcontinue;\n\n\t\tmlog(0, \"Region: %s\\n\", config_item_name(&reg->hr_item));\n\t\tif (numregs < max_regions) {\n\t\t\tmemcpy(p, config_item_name(&reg->hr_item),\n\t\t\t       O2HB_MAX_REGION_NAME_LEN);\n\t\t\tp += O2HB_MAX_REGION_NAME_LEN;\n\t\t}\n\t\tnumregs++;\n\t}\n\n\tspin_unlock(&o2hb_live_lock);\n\n\treturn numregs;\n}\nEXPORT_SYMBOL_GPL(o2hb_get_all_regions);\n\nint o2hb_global_heartbeat_active(void)\n{\n\treturn (o2hb_heartbeat_mode == O2HB_HEARTBEAT_GLOBAL);\n}\nEXPORT_SYMBOL(o2hb_global_heartbeat_active);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}