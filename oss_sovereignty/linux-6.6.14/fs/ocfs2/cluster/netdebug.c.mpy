{
  "module_name": "netdebug.c",
  "hash_id": "405078ad3e5ed2b06c1163461e9d6fbf692a68933f8deccb0b4ac1f1c0dd85df",
  "original_prompt": "Ingested from linux-6.6.14/fs/ocfs2/cluster/netdebug.c",
  "human_readable_source": "\n \n\n#ifdef CONFIG_DEBUG_FS\n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/kref.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n\n#include <linux/uaccess.h>\n\n#include \"tcp.h\"\n#include \"nodemanager.h\"\n#define MLOG_MASK_PREFIX ML_TCP\n#include \"masklog.h\"\n\n#include \"tcp_internal.h\"\n\n#define O2NET_DEBUG_DIR\t\t\"o2net\"\n#define SC_DEBUG_NAME\t\t\"sock_containers\"\n#define NST_DEBUG_NAME\t\t\"send_tracking\"\n#define STATS_DEBUG_NAME\t\"stats\"\n#define NODES_DEBUG_NAME\t\"connected_nodes\"\n\n#define SHOW_SOCK_CONTAINERS\t0\n#define SHOW_SOCK_STATS\t\t1\n\nstatic struct dentry *o2net_dentry;\n\nstatic DEFINE_SPINLOCK(o2net_debug_lock);\n\nstatic LIST_HEAD(sock_containers);\nstatic LIST_HEAD(send_tracking);\n\nvoid o2net_debug_add_nst(struct o2net_send_tracking *nst)\n{\n\tspin_lock_bh(&o2net_debug_lock);\n\tlist_add(&nst->st_net_debug_item, &send_tracking);\n\tspin_unlock_bh(&o2net_debug_lock);\n}\n\nvoid o2net_debug_del_nst(struct o2net_send_tracking *nst)\n{\n\tspin_lock_bh(&o2net_debug_lock);\n\tif (!list_empty(&nst->st_net_debug_item))\n\t\tlist_del_init(&nst->st_net_debug_item);\n\tspin_unlock_bh(&o2net_debug_lock);\n}\n\nstatic struct o2net_send_tracking\n\t\t\t*next_nst(struct o2net_send_tracking *nst_start)\n{\n\tstruct o2net_send_tracking *nst, *ret = NULL;\n\n\tassert_spin_locked(&o2net_debug_lock);\n\n\tlist_for_each_entry(nst, &nst_start->st_net_debug_item,\n\t\t\t    st_net_debug_item) {\n\t\t \n\t\tif (&nst->st_net_debug_item == &send_tracking)\n\t\t\tbreak;\n\n\t\t \n\t\tif (nst->st_task != NULL) {\n\t\t\tret = nst;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic void *nst_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\tstruct o2net_send_tracking *nst, *dummy_nst = seq->private;\n\n\tspin_lock_bh(&o2net_debug_lock);\n\tnst = next_nst(dummy_nst);\n\tspin_unlock_bh(&o2net_debug_lock);\n\n\treturn nst;\n}\n\nstatic void *nst_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct o2net_send_tracking *nst, *dummy_nst = seq->private;\n\n\tspin_lock_bh(&o2net_debug_lock);\n\tnst = next_nst(dummy_nst);\n\tlist_del_init(&dummy_nst->st_net_debug_item);\n\tif (nst)\n\t\tlist_add(&dummy_nst->st_net_debug_item,\n\t\t\t &nst->st_net_debug_item);\n\tspin_unlock_bh(&o2net_debug_lock);\n\n\treturn nst;  \n}\n\nstatic int nst_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct o2net_send_tracking *nst, *dummy_nst = seq->private;\n\tktime_t now;\n\ts64 sock, send, status;\n\n\tspin_lock_bh(&o2net_debug_lock);\n\tnst = next_nst(dummy_nst);\n\tif (!nst)\n\t\tgoto out;\n\n\tnow = ktime_get();\n\tsock = ktime_to_us(ktime_sub(now, nst->st_sock_time));\n\tsend = ktime_to_us(ktime_sub(now, nst->st_send_time));\n\tstatus = ktime_to_us(ktime_sub(now, nst->st_status_time));\n\n\t \n\tseq_printf(seq, \"%p:\\n\"\n\t\t   \"  pid:          %lu\\n\"\n\t\t   \"  tgid:         %lu\\n\"\n\t\t   \"  process name: %s\\n\"\n\t\t   \"  node:         %u\\n\"\n\t\t   \"  sc:           %p\\n\"\n\t\t   \"  message id:   %d\\n\"\n\t\t   \"  message type: %u\\n\"\n\t\t   \"  message key:  0x%08x\\n\"\n\t\t   \"  sock acquiry: %lld usecs ago\\n\"\n\t\t   \"  send start:   %lld usecs ago\\n\"\n\t\t   \"  wait start:   %lld usecs ago\\n\",\n\t\t   nst, (unsigned long)task_pid_nr(nst->st_task),\n\t\t   (unsigned long)nst->st_task->tgid,\n\t\t   nst->st_task->comm, nst->st_node,\n\t\t   nst->st_sc, nst->st_id, nst->st_msg_type,\n\t\t   nst->st_msg_key,\n\t\t   (long long)sock,\n\t\t   (long long)send,\n\t\t   (long long)status);\n\nout:\n\tspin_unlock_bh(&o2net_debug_lock);\n\n\treturn 0;\n}\n\nstatic void nst_seq_stop(struct seq_file *seq, void *v)\n{\n}\n\nstatic const struct seq_operations nst_seq_ops = {\n\t.start = nst_seq_start,\n\t.next = nst_seq_next,\n\t.stop = nst_seq_stop,\n\t.show = nst_seq_show,\n};\n\nstatic int nst_fop_open(struct inode *inode, struct file *file)\n{\n\tstruct o2net_send_tracking *dummy_nst;\n\n\tdummy_nst = __seq_open_private(file, &nst_seq_ops, sizeof(*dummy_nst));\n\tif (!dummy_nst)\n\t\treturn -ENOMEM;\n\to2net_debug_add_nst(dummy_nst);\n\n\treturn 0;\n}\n\nstatic int nst_fop_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\tstruct o2net_send_tracking *dummy_nst = seq->private;\n\n\to2net_debug_del_nst(dummy_nst);\n\treturn seq_release_private(inode, file);\n}\n\nstatic const struct file_operations nst_seq_fops = {\n\t.open = nst_fop_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = nst_fop_release,\n};\n\nvoid o2net_debug_add_sc(struct o2net_sock_container *sc)\n{\n\tspin_lock_bh(&o2net_debug_lock);\n\tlist_add(&sc->sc_net_debug_item, &sock_containers);\n\tspin_unlock_bh(&o2net_debug_lock);\n}\n\nvoid o2net_debug_del_sc(struct o2net_sock_container *sc)\n{\n\tspin_lock_bh(&o2net_debug_lock);\n\tlist_del_init(&sc->sc_net_debug_item);\n\tspin_unlock_bh(&o2net_debug_lock);\n}\n\nstruct o2net_sock_debug {\n\tint dbg_ctxt;\n\tstruct o2net_sock_container *dbg_sock;\n};\n\nstatic struct o2net_sock_container\n\t\t\t*next_sc(struct o2net_sock_container *sc_start)\n{\n\tstruct o2net_sock_container *sc, *ret = NULL;\n\n\tassert_spin_locked(&o2net_debug_lock);\n\n\tlist_for_each_entry(sc, &sc_start->sc_net_debug_item,\n\t\t\t    sc_net_debug_item) {\n\t\t \n\t\tif (&sc->sc_net_debug_item == &sock_containers)\n\t\t\tbreak;\n\n\t\t \n\t\tif (sc->sc_page != NULL) {\n\t\t\tret = sc;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic void *sc_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\tstruct o2net_sock_debug *sd = seq->private;\n\tstruct o2net_sock_container *sc, *dummy_sc = sd->dbg_sock;\n\n\tspin_lock_bh(&o2net_debug_lock);\n\tsc = next_sc(dummy_sc);\n\tspin_unlock_bh(&o2net_debug_lock);\n\n\treturn sc;\n}\n\nstatic void *sc_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct o2net_sock_debug *sd = seq->private;\n\tstruct o2net_sock_container *sc, *dummy_sc = sd->dbg_sock;\n\n\tspin_lock_bh(&o2net_debug_lock);\n\tsc = next_sc(dummy_sc);\n\tlist_del_init(&dummy_sc->sc_net_debug_item);\n\tif (sc)\n\t\tlist_add(&dummy_sc->sc_net_debug_item, &sc->sc_net_debug_item);\n\tspin_unlock_bh(&o2net_debug_lock);\n\n\treturn sc;  \n}\n\n#ifdef CONFIG_OCFS2_FS_STATS\n# define sc_send_count(_s)\t\t((_s)->sc_send_count)\n# define sc_recv_count(_s)\t\t((_s)->sc_recv_count)\n# define sc_tv_acquiry_total_ns(_s)\t(ktime_to_ns((_s)->sc_tv_acquiry_total))\n# define sc_tv_send_total_ns(_s)\t(ktime_to_ns((_s)->sc_tv_send_total))\n# define sc_tv_status_total_ns(_s)\t(ktime_to_ns((_s)->sc_tv_status_total))\n# define sc_tv_process_total_ns(_s)\t(ktime_to_ns((_s)->sc_tv_process_total))\n#else\n# define sc_send_count(_s)\t\t(0U)\n# define sc_recv_count(_s)\t\t(0U)\n# define sc_tv_acquiry_total_ns(_s)\t(0LL)\n# define sc_tv_send_total_ns(_s)\t(0LL)\n# define sc_tv_status_total_ns(_s)\t(0LL)\n# define sc_tv_process_total_ns(_s)\t(0LL)\n#endif\n\n \n#define O2NET_STATS_STR_VERSION\t\t1\nstatic void sc_show_sock_stats(struct seq_file *seq,\n\t\t\t       struct o2net_sock_container *sc)\n{\n\tif (!sc)\n\t\treturn;\n\n\tseq_printf(seq, \"%d,%u,%lu,%lld,%lld,%lld,%lu,%lld\\n\", O2NET_STATS_STR_VERSION,\n\t\t   sc->sc_node->nd_num, (unsigned long)sc_send_count(sc),\n\t\t   (long long)sc_tv_acquiry_total_ns(sc),\n\t\t   (long long)sc_tv_send_total_ns(sc),\n\t\t   (long long)sc_tv_status_total_ns(sc),\n\t\t   (unsigned long)sc_recv_count(sc),\n\t\t   (long long)sc_tv_process_total_ns(sc));\n}\n\nstatic void sc_show_sock_container(struct seq_file *seq,\n\t\t\t\t   struct o2net_sock_container *sc)\n{\n\tstruct inet_sock *inet = NULL;\n\t__be32 saddr = 0, daddr = 0;\n\t__be16 sport = 0, dport = 0;\n\n\tif (!sc)\n\t\treturn;\n\n\tif (sc->sc_sock) {\n\t\tinet = inet_sk(sc->sc_sock->sk);\n\t\t \n\t\tsaddr = (__force __be32)inet->inet_saddr;\n\t\tdaddr = (__force __be32)inet->inet_daddr;\n\t\tsport = (__force __be16)inet->inet_sport;\n\t\tdport = (__force __be16)inet->inet_dport;\n\t}\n\n\t \n\tseq_printf(seq, \"%p:\\n\"\n\t\t   \"  krefs:           %d\\n\"\n\t\t   \"  sock:            %pI4:%u -> \"\n\t\t\t\t      \"%pI4:%u\\n\"\n\t\t   \"  remote node:     %s\\n\"\n\t\t   \"  page off:        %zu\\n\"\n\t\t   \"  handshake ok:    %u\\n\"\n\t\t   \"  timer:           %lld usecs\\n\"\n\t\t   \"  data ready:      %lld usecs\\n\"\n\t\t   \"  advance start:   %lld usecs\\n\"\n\t\t   \"  advance stop:    %lld usecs\\n\"\n\t\t   \"  func start:      %lld usecs\\n\"\n\t\t   \"  func stop:       %lld usecs\\n\"\n\t\t   \"  func key:        0x%08x\\n\"\n\t\t   \"  func type:       %u\\n\",\n\t\t   sc,\n\t\t   kref_read(&sc->sc_kref),\n\t\t   &saddr, inet ? ntohs(sport) : 0,\n\t\t   &daddr, inet ? ntohs(dport) : 0,\n\t\t   sc->sc_node->nd_name,\n\t\t   sc->sc_page_off,\n\t\t   sc->sc_handshake_ok,\n\t\t   (long long)ktime_to_us(sc->sc_tv_timer),\n\t\t   (long long)ktime_to_us(sc->sc_tv_data_ready),\n\t\t   (long long)ktime_to_us(sc->sc_tv_advance_start),\n\t\t   (long long)ktime_to_us(sc->sc_tv_advance_stop),\n\t\t   (long long)ktime_to_us(sc->sc_tv_func_start),\n\t\t   (long long)ktime_to_us(sc->sc_tv_func_stop),\n\t\t   sc->sc_msg_key,\n\t\t   sc->sc_msg_type);\n}\n\nstatic int sc_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct o2net_sock_debug *sd = seq->private;\n\tstruct o2net_sock_container *sc, *dummy_sc = sd->dbg_sock;\n\n\tspin_lock_bh(&o2net_debug_lock);\n\tsc = next_sc(dummy_sc);\n\n\tif (sc) {\n\t\tif (sd->dbg_ctxt == SHOW_SOCK_CONTAINERS)\n\t\t\tsc_show_sock_container(seq, sc);\n\t\telse\n\t\t\tsc_show_sock_stats(seq, sc);\n\t}\n\n\tspin_unlock_bh(&o2net_debug_lock);\n\n\treturn 0;\n}\n\nstatic void sc_seq_stop(struct seq_file *seq, void *v)\n{\n}\n\nstatic const struct seq_operations sc_seq_ops = {\n\t.start = sc_seq_start,\n\t.next = sc_seq_next,\n\t.stop = sc_seq_stop,\n\t.show = sc_seq_show,\n};\n\nstatic int sc_common_open(struct file *file, int ctxt)\n{\n\tstruct o2net_sock_debug *sd;\n\tstruct o2net_sock_container *dummy_sc;\n\n\tdummy_sc = kzalloc(sizeof(*dummy_sc), GFP_KERNEL);\n\tif (!dummy_sc)\n\t\treturn -ENOMEM;\n\n\tsd = __seq_open_private(file, &sc_seq_ops, sizeof(*sd));\n\tif (!sd) {\n\t\tkfree(dummy_sc);\n\t\treturn -ENOMEM;\n\t}\n\n\tsd->dbg_ctxt = ctxt;\n\tsd->dbg_sock = dummy_sc;\n\n\to2net_debug_add_sc(dummy_sc);\n\n\treturn 0;\n}\n\nstatic int sc_fop_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\tstruct o2net_sock_debug *sd = seq->private;\n\tstruct o2net_sock_container *dummy_sc = sd->dbg_sock;\n\n\to2net_debug_del_sc(dummy_sc);\n\tkfree(dummy_sc);\n\treturn seq_release_private(inode, file);\n}\n\nstatic int stats_fop_open(struct inode *inode, struct file *file)\n{\n\treturn sc_common_open(file, SHOW_SOCK_STATS);\n}\n\nstatic const struct file_operations stats_seq_fops = {\n\t.open = stats_fop_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = sc_fop_release,\n};\n\nstatic int sc_fop_open(struct inode *inode, struct file *file)\n{\n\treturn sc_common_open(file, SHOW_SOCK_CONTAINERS);\n}\n\nstatic const struct file_operations sc_seq_fops = {\n\t.open = sc_fop_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = sc_fop_release,\n};\n\nstatic int o2net_fill_bitmap(char *buf, int len)\n{\n\tunsigned long map[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\tint i = -1, out = 0;\n\n\to2net_fill_node_map(map, O2NM_MAX_NODES);\n\n\twhile ((i = find_next_bit(map, O2NM_MAX_NODES, i + 1)) < O2NM_MAX_NODES)\n\t\tout += scnprintf(buf + out, PAGE_SIZE - out, \"%d \", i);\n\tout += scnprintf(buf + out, PAGE_SIZE - out, \"\\n\");\n\n\treturn out;\n}\n\nstatic int nodes_fop_open(struct inode *inode, struct file *file)\n{\n\tchar *buf;\n\n\tbuf = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\ti_size_write(inode, o2net_fill_bitmap(buf, PAGE_SIZE));\n\n\tfile->private_data = buf;\n\n\treturn 0;\n}\n\nstatic int o2net_debug_release(struct inode *inode, struct file *file)\n{\n\tkfree(file->private_data);\n\treturn 0;\n}\n\nstatic ssize_t o2net_debug_read(struct file *file, char __user *buf,\n\t\t\t\tsize_t nbytes, loff_t *ppos)\n{\n\treturn simple_read_from_buffer(buf, nbytes, ppos, file->private_data,\n\t\t\t\t       i_size_read(file->f_mapping->host));\n}\n\nstatic const struct file_operations nodes_fops = {\n\t.open\t\t= nodes_fop_open,\n\t.release\t= o2net_debug_release,\n\t.read\t\t= o2net_debug_read,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nvoid o2net_debugfs_exit(void)\n{\n\tdebugfs_remove_recursive(o2net_dentry);\n}\n\nvoid o2net_debugfs_init(void)\n{\n\tumode_t mode = S_IFREG|S_IRUSR;\n\n\to2net_dentry = debugfs_create_dir(O2NET_DEBUG_DIR, NULL);\n\n\tdebugfs_create_file(NST_DEBUG_NAME, mode, o2net_dentry, NULL,\n\t\t\t    &nst_seq_fops);\n\tdebugfs_create_file(SC_DEBUG_NAME, mode, o2net_dentry, NULL,\n\t\t\t    &sc_seq_fops);\n\tdebugfs_create_file(STATS_DEBUG_NAME, mode, o2net_dentry, NULL,\n\t\t\t    &stats_seq_fops);\n\tdebugfs_create_file(NODES_DEBUG_NAME, mode, o2net_dentry, NULL,\n\t\t\t    &nodes_fops);\n}\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}