{
  "module_name": "tcp.c",
  "hash_id": "f90b028b16c2b0913541ceadc54ed97e1e2f2a844e95d34cc82d5e1feade2514",
  "original_prompt": "Ingested from linux-6.6.14/fs/ocfs2/cluster/tcp.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/sched/mm.h>\n#include <linux/jiffies.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/kref.h>\n#include <linux/net.h>\n#include <linux/export.h>\n#include <net/tcp.h>\n#include <trace/events/sock.h>\n\n#include <linux/uaccess.h>\n\n#include \"heartbeat.h\"\n#include \"tcp.h\"\n#include \"nodemanager.h\"\n#define MLOG_MASK_PREFIX ML_TCP\n#include \"masklog.h\"\n#include \"quorum.h\"\n\n#include \"tcp_internal.h\"\n\n#define SC_NODEF_FMT \"node %s (num %u) at %pI4:%u\"\n#define SC_NODEF_ARGS(sc) sc->sc_node->nd_name, sc->sc_node->nd_num,\t\\\n\t\t\t  &sc->sc_node->nd_ipv4_address,\t\t\\\n\t\t\t  ntohs(sc->sc_node->nd_ipv4_port)\n\n \n#define msglog(hdr, fmt, args...) do {\t\t\t\t\t\\\n\ttypeof(hdr) __hdr = (hdr);\t\t\t\t\t\\\n\tmlog(ML_MSG, \"[mag %u len %u typ %u stat %d sys_stat %d \"\t\\\n\t     \"key %08x num %u] \" fmt,\t\t\t\t\t\\\n\t     be16_to_cpu(__hdr->magic), be16_to_cpu(__hdr->data_len), \t\\\n\t     be16_to_cpu(__hdr->msg_type), be32_to_cpu(__hdr->status),\t\\\n\t     be32_to_cpu(__hdr->sys_status), be32_to_cpu(__hdr->key),\t\\\n\t     be32_to_cpu(__hdr->msg_num) ,  ##args);\t\t\t\\\n} while (0)\n\n#define sclog(sc, fmt, args...) do {\t\t\t\t\t\\\n\ttypeof(sc) __sc = (sc);\t\t\t\t\t\t\\\n\tmlog(ML_SOCKET, \"[sc %p refs %d sock %p node %u page %p \"\t\\\n\t     \"pg_off %zu] \" fmt, __sc,\t\t\t\t\t\\\n\t     kref_read(&__sc->sc_kref), __sc->sc_sock,\t\\\n\t    __sc->sc_node->nd_num, __sc->sc_page, __sc->sc_page_off ,\t\\\n\t    ##args);\t\t\t\t\t\t\t\\\n} while (0)\n\nstatic DEFINE_RWLOCK(o2net_handler_lock);\nstatic struct rb_root o2net_handler_tree = RB_ROOT;\n\nstatic struct o2net_node o2net_nodes[O2NM_MAX_NODES];\n\n \nstatic struct socket *o2net_listen_sock;\n\n \nstatic struct workqueue_struct *o2net_wq;\nstatic struct work_struct o2net_listen_work;\n\nstatic struct o2hb_callback_func o2net_hb_up, o2net_hb_down;\n#define O2NET_HB_PRI 0x1\n\nstatic struct o2net_handshake *o2net_hand;\nstatic struct o2net_msg *o2net_keep_req, *o2net_keep_resp;\n\nstatic int o2net_sys_err_translations[O2NET_ERR_MAX] =\n\t\t{[O2NET_ERR_NONE]\t= 0,\n\t\t [O2NET_ERR_NO_HNDLR]\t= -ENOPROTOOPT,\n\t\t [O2NET_ERR_OVERFLOW]\t= -EOVERFLOW,\n\t\t [O2NET_ERR_DIED]\t= -EHOSTDOWN,};\n\n \nstatic void o2net_sc_connect_completed(struct work_struct *work);\nstatic void o2net_rx_until_empty(struct work_struct *work);\nstatic void o2net_shutdown_sc(struct work_struct *work);\nstatic void o2net_listen_data_ready(struct sock *sk);\nstatic void o2net_sc_send_keep_req(struct work_struct *work);\nstatic void o2net_idle_timer(struct timer_list *t);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\n#ifdef CONFIG_DEBUG_FS\nstatic void o2net_init_nst(struct o2net_send_tracking *nst, u32 msgtype,\n\t\t\t   u32 msgkey, struct task_struct *task, u8 node)\n{\n\tINIT_LIST_HEAD(&nst->st_net_debug_item);\n\tnst->st_task = task;\n\tnst->st_msg_type = msgtype;\n\tnst->st_msg_key = msgkey;\n\tnst->st_node = node;\n}\n\nstatic inline void o2net_set_nst_sock_time(struct o2net_send_tracking *nst)\n{\n\tnst->st_sock_time = ktime_get();\n}\n\nstatic inline void o2net_set_nst_send_time(struct o2net_send_tracking *nst)\n{\n\tnst->st_send_time = ktime_get();\n}\n\nstatic inline void o2net_set_nst_status_time(struct o2net_send_tracking *nst)\n{\n\tnst->st_status_time = ktime_get();\n}\n\nstatic inline void o2net_set_nst_sock_container(struct o2net_send_tracking *nst,\n\t\t\t\t\t\tstruct o2net_sock_container *sc)\n{\n\tnst->st_sc = sc;\n}\n\nstatic inline void o2net_set_nst_msg_id(struct o2net_send_tracking *nst,\n\t\t\t\t\tu32 msg_id)\n{\n\tnst->st_id = msg_id;\n}\n\nstatic inline void o2net_set_sock_timer(struct o2net_sock_container *sc)\n{\n\tsc->sc_tv_timer = ktime_get();\n}\n\nstatic inline void o2net_set_data_ready_time(struct o2net_sock_container *sc)\n{\n\tsc->sc_tv_data_ready = ktime_get();\n}\n\nstatic inline void o2net_set_advance_start_time(struct o2net_sock_container *sc)\n{\n\tsc->sc_tv_advance_start = ktime_get();\n}\n\nstatic inline void o2net_set_advance_stop_time(struct o2net_sock_container *sc)\n{\n\tsc->sc_tv_advance_stop = ktime_get();\n}\n\nstatic inline void o2net_set_func_start_time(struct o2net_sock_container *sc)\n{\n\tsc->sc_tv_func_start = ktime_get();\n}\n\nstatic inline void o2net_set_func_stop_time(struct o2net_sock_container *sc)\n{\n\tsc->sc_tv_func_stop = ktime_get();\n}\n\n#else   \n# define o2net_init_nst(a, b, c, d, e)\n# define o2net_set_nst_sock_time(a)\n# define o2net_set_nst_send_time(a)\n# define o2net_set_nst_status_time(a)\n# define o2net_set_nst_sock_container(a, b)\n# define o2net_set_nst_msg_id(a, b)\n# define o2net_set_sock_timer(a)\n# define o2net_set_data_ready_time(a)\n# define o2net_set_advance_start_time(a)\n# define o2net_set_advance_stop_time(a)\n# define o2net_set_func_start_time(a)\n# define o2net_set_func_stop_time(a)\n#endif  \n\n#ifdef CONFIG_OCFS2_FS_STATS\nstatic ktime_t o2net_get_func_run_time(struct o2net_sock_container *sc)\n{\n\treturn ktime_sub(sc->sc_tv_func_stop, sc->sc_tv_func_start);\n}\n\nstatic void o2net_update_send_stats(struct o2net_send_tracking *nst,\n\t\t\t\t    struct o2net_sock_container *sc)\n{\n\tsc->sc_tv_status_total = ktime_add(sc->sc_tv_status_total,\n\t\t\t\t\t   ktime_sub(ktime_get(),\n\t\t\t\t\t\t     nst->st_status_time));\n\tsc->sc_tv_send_total = ktime_add(sc->sc_tv_send_total,\n\t\t\t\t\t ktime_sub(nst->st_status_time,\n\t\t\t\t\t\t   nst->st_send_time));\n\tsc->sc_tv_acquiry_total = ktime_add(sc->sc_tv_acquiry_total,\n\t\t\t\t\t    ktime_sub(nst->st_send_time,\n\t\t\t\t\t\t      nst->st_sock_time));\n\tsc->sc_send_count++;\n}\n\nstatic void o2net_update_recv_stats(struct o2net_sock_container *sc)\n{\n\tsc->sc_tv_process_total = ktime_add(sc->sc_tv_process_total,\n\t\t\t\t\t    o2net_get_func_run_time(sc));\n\tsc->sc_recv_count++;\n}\n\n#else\n\n# define o2net_update_send_stats(a, b)\n\n# define o2net_update_recv_stats(sc)\n\n#endif  \n\nstatic inline unsigned int o2net_reconnect_delay(void)\n{\n\treturn o2nm_single_cluster->cl_reconnect_delay_ms;\n}\n\nstatic inline unsigned int o2net_keepalive_delay(void)\n{\n\treturn o2nm_single_cluster->cl_keepalive_delay_ms;\n}\n\nstatic inline unsigned int o2net_idle_timeout(void)\n{\n\treturn o2nm_single_cluster->cl_idle_timeout_ms;\n}\n\nstatic inline int o2net_sys_err_to_errno(enum o2net_system_error err)\n{\n\tint trans;\n\tBUG_ON(err >= O2NET_ERR_MAX);\n\ttrans = o2net_sys_err_translations[err];\n\n\t \n\tBUG_ON(err != O2NET_ERR_NONE && trans == 0);\n\treturn trans;\n}\n\nstatic struct o2net_node * o2net_nn_from_num(u8 node_num)\n{\n\tBUG_ON(node_num >= ARRAY_SIZE(o2net_nodes));\n\treturn &o2net_nodes[node_num];\n}\n\nstatic u8 o2net_num_from_nn(struct o2net_node *nn)\n{\n\tBUG_ON(nn == NULL);\n\treturn nn - o2net_nodes;\n}\n\n \n\nstatic int o2net_prep_nsw(struct o2net_node *nn, struct o2net_status_wait *nsw)\n{\n\tint ret;\n\n\tspin_lock(&nn->nn_lock);\n\tret = idr_alloc(&nn->nn_status_idr, nsw, 0, 0, GFP_ATOMIC);\n\tif (ret >= 0) {\n\t\tnsw->ns_id = ret;\n\t\tlist_add_tail(&nsw->ns_node_item, &nn->nn_status_list);\n\t}\n\tspin_unlock(&nn->nn_lock);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tinit_waitqueue_head(&nsw->ns_wq);\n\tnsw->ns_sys_status = O2NET_ERR_NONE;\n\tnsw->ns_status = 0;\n\treturn 0;\n}\n\nstatic void o2net_complete_nsw_locked(struct o2net_node *nn,\n\t\t\t\t      struct o2net_status_wait *nsw,\n\t\t\t\t      enum o2net_system_error sys_status,\n\t\t\t\t      s32 status)\n{\n\tassert_spin_locked(&nn->nn_lock);\n\n\tif (!list_empty(&nsw->ns_node_item)) {\n\t\tlist_del_init(&nsw->ns_node_item);\n\t\tnsw->ns_sys_status = sys_status;\n\t\tnsw->ns_status = status;\n\t\tidr_remove(&nn->nn_status_idr, nsw->ns_id);\n\t\twake_up(&nsw->ns_wq);\n\t}\n}\n\nstatic void o2net_complete_nsw(struct o2net_node *nn,\n\t\t\t       struct o2net_status_wait *nsw,\n\t\t\t       u64 id, enum o2net_system_error sys_status,\n\t\t\t       s32 status)\n{\n\tspin_lock(&nn->nn_lock);\n\tif (nsw == NULL) {\n\t\tif (id > INT_MAX)\n\t\t\tgoto out;\n\n\t\tnsw = idr_find(&nn->nn_status_idr, id);\n\t\tif (nsw == NULL)\n\t\t\tgoto out;\n\t}\n\n\to2net_complete_nsw_locked(nn, nsw, sys_status, status);\n\nout:\n\tspin_unlock(&nn->nn_lock);\n\treturn;\n}\n\nstatic void o2net_complete_nodes_nsw(struct o2net_node *nn)\n{\n\tstruct o2net_status_wait *nsw, *tmp;\n\tunsigned int num_kills = 0;\n\n\tassert_spin_locked(&nn->nn_lock);\n\n\tlist_for_each_entry_safe(nsw, tmp, &nn->nn_status_list, ns_node_item) {\n\t\to2net_complete_nsw_locked(nn, nsw, O2NET_ERR_DIED, 0);\n\t\tnum_kills++;\n\t}\n\n\tmlog(0, \"completed %d messages for node %u\\n\", num_kills,\n\t     o2net_num_from_nn(nn));\n}\n\nstatic int o2net_nsw_completed(struct o2net_node *nn,\n\t\t\t       struct o2net_status_wait *nsw)\n{\n\tint completed;\n\tspin_lock(&nn->nn_lock);\n\tcompleted = list_empty(&nsw->ns_node_item);\n\tspin_unlock(&nn->nn_lock);\n\treturn completed;\n}\n\n \n\nstatic void sc_kref_release(struct kref *kref)\n{\n\tstruct o2net_sock_container *sc = container_of(kref,\n\t\t\t\t\tstruct o2net_sock_container, sc_kref);\n\tBUG_ON(timer_pending(&sc->sc_idle_timeout));\n\n\tsclog(sc, \"releasing\\n\");\n\n\tif (sc->sc_sock) {\n\t\tsock_release(sc->sc_sock);\n\t\tsc->sc_sock = NULL;\n\t}\n\n\to2nm_undepend_item(&sc->sc_node->nd_item);\n\to2nm_node_put(sc->sc_node);\n\tsc->sc_node = NULL;\n\n\to2net_debug_del_sc(sc);\n\n\tif (sc->sc_page)\n\t\t__free_page(sc->sc_page);\n\tkfree(sc);\n}\n\nstatic void sc_put(struct o2net_sock_container *sc)\n{\n\tsclog(sc, \"put\\n\");\n\tkref_put(&sc->sc_kref, sc_kref_release);\n}\nstatic void sc_get(struct o2net_sock_container *sc)\n{\n\tsclog(sc, \"get\\n\");\n\tkref_get(&sc->sc_kref);\n}\nstatic struct o2net_sock_container *sc_alloc(struct o2nm_node *node)\n{\n\tstruct o2net_sock_container *sc, *ret = NULL;\n\tstruct page *page = NULL;\n\tint status = 0;\n\n\tpage = alloc_page(GFP_NOFS);\n\tsc = kzalloc(sizeof(*sc), GFP_NOFS);\n\tif (sc == NULL || page == NULL)\n\t\tgoto out;\n\n\tkref_init(&sc->sc_kref);\n\to2nm_node_get(node);\n\tsc->sc_node = node;\n\n\t \n\tstatus = o2nm_depend_item(&node->nd_item);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\to2nm_node_put(node);\n\t\tgoto out;\n\t}\n\tINIT_WORK(&sc->sc_connect_work, o2net_sc_connect_completed);\n\tINIT_WORK(&sc->sc_rx_work, o2net_rx_until_empty);\n\tINIT_WORK(&sc->sc_shutdown_work, o2net_shutdown_sc);\n\tINIT_DELAYED_WORK(&sc->sc_keepalive_work, o2net_sc_send_keep_req);\n\n\ttimer_setup(&sc->sc_idle_timeout, o2net_idle_timer, 0);\n\n\tsclog(sc, \"alloced\\n\");\n\n\tret = sc;\n\tsc->sc_page = page;\n\to2net_debug_add_sc(sc);\n\tsc = NULL;\n\tpage = NULL;\n\nout:\n\tif (page)\n\t\t__free_page(page);\n\tkfree(sc);\n\n\treturn ret;\n}\n\n \n\nstatic void o2net_sc_queue_work(struct o2net_sock_container *sc,\n\t\t\t\tstruct work_struct *work)\n{\n\tsc_get(sc);\n\tif (!queue_work(o2net_wq, work))\n\t\tsc_put(sc);\n}\nstatic void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}\nstatic void o2net_sc_cancel_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\t struct delayed_work *work)\n{\n\tif (cancel_delayed_work(work))\n\t\tsc_put(sc);\n}\n\nstatic atomic_t o2net_connected_peers = ATOMIC_INIT(0);\n\nint o2net_num_connected_peers(void)\n{\n\treturn atomic_read(&o2net_connected_peers);\n}\n\nstatic void o2net_set_nn_state(struct o2net_node *nn,\n\t\t\t       struct o2net_sock_container *sc,\n\t\t\t       unsigned valid, int err)\n{\n\tint was_valid = nn->nn_sc_valid;\n\tint was_err = nn->nn_persistent_error;\n\tstruct o2net_sock_container *old_sc = nn->nn_sc;\n\n\tassert_spin_locked(&nn->nn_lock);\n\n\tif (old_sc && !sc)\n\t\tatomic_dec(&o2net_connected_peers);\n\telse if (!old_sc && sc)\n\t\tatomic_inc(&o2net_connected_peers);\n\n\t \n\tBUG_ON(sc && nn->nn_sc && nn->nn_sc != sc);\n\tmlog_bug_on_msg(err && valid, \"err %d valid %u\\n\", err, valid);\n\tmlog_bug_on_msg(valid && !sc, \"valid %u sc %p\\n\", valid, sc);\n\n\tif (was_valid && !valid && err == 0)\n\t\terr = -ENOTCONN;\n\n\tmlog(ML_CONN, \"node %u sc: %p -> %p, valid %u -> %u, err %d -> %d\\n\",\n\t     o2net_num_from_nn(nn), nn->nn_sc, sc, nn->nn_sc_valid, valid,\n\t     nn->nn_persistent_error, err);\n\n\tnn->nn_sc = sc;\n\tnn->nn_sc_valid = valid ? 1 : 0;\n\tnn->nn_persistent_error = err;\n\n\t \n\tif (nn->nn_persistent_error || nn->nn_sc_valid)\n\t\twake_up(&nn->nn_sc_wq);\n\n\tif (was_valid && !was_err && nn->nn_persistent_error) {\n\t\to2quo_conn_err(o2net_num_from_nn(nn));\n\t\tqueue_delayed_work(o2net_wq, &nn->nn_still_up,\n\t\t\t\t   msecs_to_jiffies(O2NET_QUORUM_DELAY_MS));\n\t}\n\n\tif (was_valid && !valid) {\n\t\tif (old_sc)\n\t\t\tprintk(KERN_NOTICE \"o2net: No longer connected to \"\n\t\t\t\tSC_NODEF_FMT \"\\n\", SC_NODEF_ARGS(old_sc));\n\t\to2net_complete_nodes_nsw(nn);\n\t}\n\n\tif (!was_valid && valid) {\n\t\to2quo_conn_up(o2net_num_from_nn(nn));\n\t\tcancel_delayed_work(&nn->nn_connect_expired);\n\t\tprintk(KERN_NOTICE \"o2net: %s \" SC_NODEF_FMT \"\\n\",\n\t\t       o2nm_this_node() > sc->sc_node->nd_num ?\n\t\t       \"Connected to\" : \"Accepted connection from\",\n\t\t       SC_NODEF_ARGS(sc));\n\t}\n\n\t \n\tif (!valid && o2net_wq) {\n\t\tunsigned long delay;\n\t\t \n\t\tdelay = (nn->nn_last_connect_attempt +\n\t\t\t msecs_to_jiffies(o2net_reconnect_delay()))\n\t\t\t- jiffies;\n\t\tif (delay > msecs_to_jiffies(o2net_reconnect_delay()))\n\t\t\tdelay = 0;\n\t\tmlog(ML_CONN, \"queueing conn attempt in %lu jiffies\\n\", delay);\n\t\tqueue_delayed_work(o2net_wq, &nn->nn_connect_work, delay);\n\n\t\t \n\t\tdelay += msecs_to_jiffies(o2net_idle_timeout());\n\t\tqueue_delayed_work(o2net_wq, &nn->nn_connect_expired, delay);\n\t}\n\n\t \n\tif ((old_sc == NULL) && sc)\n\t\tsc_get(sc);\n\tif (old_sc && (old_sc != sc)) {\n\t\to2net_sc_queue_work(old_sc, &old_sc->sc_shutdown_work);\n\t\tsc_put(old_sc);\n\t}\n}\n\n \nstatic void o2net_data_ready(struct sock *sk)\n{\n\tvoid (*ready)(struct sock *sk);\n\tstruct o2net_sock_container *sc;\n\n\ttrace_sk_data_ready(sk);\n\n\tread_lock_bh(&sk->sk_callback_lock);\n\tsc = sk->sk_user_data;\n\tif (sc) {\n\t\tsclog(sc, \"data_ready hit\\n\");\n\t\to2net_set_data_ready_time(sc);\n\t\to2net_sc_queue_work(sc, &sc->sc_rx_work);\n\t\tready = sc->sc_data_ready;\n\t} else {\n\t\tready = sk->sk_data_ready;\n\t}\n\tread_unlock_bh(&sk->sk_callback_lock);\n\n\tready(sk);\n}\n\n \nstatic void o2net_state_change(struct sock *sk)\n{\n\tvoid (*state_change)(struct sock *sk);\n\tstruct o2net_sock_container *sc;\n\n\tread_lock_bh(&sk->sk_callback_lock);\n\tsc = sk->sk_user_data;\n\tif (sc == NULL) {\n\t\tstate_change = sk->sk_state_change;\n\t\tgoto out;\n\t}\n\n\tsclog(sc, \"state_change to %d\\n\", sk->sk_state);\n\n\tstate_change = sc->sc_state_change;\n\n\tswitch(sk->sk_state) {\n\t \n\tcase TCP_SYN_SENT:\n\tcase TCP_SYN_RECV:\n\t\tbreak;\n\tcase TCP_ESTABLISHED:\n\t\to2net_sc_queue_work(sc, &sc->sc_connect_work);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_INFO \"o2net: Connection to \" SC_NODEF_FMT\n\t\t\t\" shutdown, state %d\\n\",\n\t\t\tSC_NODEF_ARGS(sc), sk->sk_state);\n\t\to2net_sc_queue_work(sc, &sc->sc_shutdown_work);\n\t\tbreak;\n\t}\nout:\n\tread_unlock_bh(&sk->sk_callback_lock);\n\tstate_change(sk);\n}\n\n \nstatic void o2net_register_callbacks(struct sock *sk,\n\t\t\t\t     struct o2net_sock_container *sc)\n{\n\twrite_lock_bh(&sk->sk_callback_lock);\n\n\t \n\tif (sk->sk_data_ready == o2net_listen_data_ready) {\n\t\tsk->sk_data_ready = sk->sk_user_data;\n\t\tsk->sk_user_data = NULL;\n\t}\n\n\tBUG_ON(sk->sk_user_data != NULL);\n\tsk->sk_user_data = sc;\n\tsc_get(sc);\n\n\tsc->sc_data_ready = sk->sk_data_ready;\n\tsc->sc_state_change = sk->sk_state_change;\n\tsk->sk_data_ready = o2net_data_ready;\n\tsk->sk_state_change = o2net_state_change;\n\n\tmutex_init(&sc->sc_send_lock);\n\n\twrite_unlock_bh(&sk->sk_callback_lock);\n}\n\nstatic int o2net_unregister_callbacks(struct sock *sk,\n\t\t\t           struct o2net_sock_container *sc)\n{\n\tint ret = 0;\n\n\twrite_lock_bh(&sk->sk_callback_lock);\n\tif (sk->sk_user_data == sc) {\n\t\tret = 1;\n\t\tsk->sk_user_data = NULL;\n\t\tsk->sk_data_ready = sc->sc_data_ready;\n\t\tsk->sk_state_change = sc->sc_state_change;\n\t}\n\twrite_unlock_bh(&sk->sk_callback_lock);\n\n\treturn ret;\n}\n\n \nstatic void o2net_ensure_shutdown(struct o2net_node *nn,\n\t\t\t           struct o2net_sock_container *sc,\n\t\t\t\t   int err)\n{\n\tspin_lock(&nn->nn_lock);\n\tif (nn->nn_sc == sc)\n\t\to2net_set_nn_state(nn, NULL, 0, err);\n\tspin_unlock(&nn->nn_lock);\n}\n\n \nstatic void o2net_shutdown_sc(struct work_struct *work)\n{\n\tstruct o2net_sock_container *sc =\n\t\tcontainer_of(work, struct o2net_sock_container,\n\t\t\t     sc_shutdown_work);\n\tstruct o2net_node *nn = o2net_nn_from_num(sc->sc_node->nd_num);\n\n\tsclog(sc, \"shutting down\\n\");\n\n\t \n\tif (o2net_unregister_callbacks(sc->sc_sock->sk, sc)) {\n\t\t \n\t\tdel_timer_sync(&sc->sc_idle_timeout);\n\t\to2net_sc_cancel_delayed_work(sc, &sc->sc_keepalive_work);\n\t\tsc_put(sc);\n\t\tkernel_sock_shutdown(sc->sc_sock, SHUT_RDWR);\n\t}\n\n\t \n\to2net_ensure_shutdown(nn, sc, 0);\n\tsc_put(sc);\n}\n\n \n\nstatic int o2net_handler_cmp(struct o2net_msg_handler *nmh, u32 msg_type,\n\t\t\t     u32 key)\n{\n\tint ret = memcmp(&nmh->nh_key, &key, sizeof(key));\n\n\tif (ret == 0)\n\t\tret = memcmp(&nmh->nh_msg_type, &msg_type, sizeof(msg_type));\n\n\treturn ret;\n}\n\nstatic struct o2net_msg_handler *\no2net_handler_tree_lookup(u32 msg_type, u32 key, struct rb_node ***ret_p,\n\t\t\t  struct rb_node **ret_parent)\n{\n\tstruct rb_node **p = &o2net_handler_tree.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct o2net_msg_handler *nmh, *ret = NULL;\n\tint cmp;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tnmh = rb_entry(parent, struct o2net_msg_handler, nh_node);\n\t\tcmp = o2net_handler_cmp(nmh, msg_type, key);\n\n\t\tif (cmp < 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (cmp > 0)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\tret = nmh;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret_p != NULL)\n\t\t*ret_p = p;\n\tif (ret_parent != NULL)\n\t\t*ret_parent = parent;\n\n\treturn ret;\n}\n\nstatic void o2net_handler_kref_release(struct kref *kref)\n{\n\tstruct o2net_msg_handler *nmh;\n\tnmh = container_of(kref, struct o2net_msg_handler, nh_kref);\n\n\tkfree(nmh);\n}\n\nstatic void o2net_handler_put(struct o2net_msg_handler *nmh)\n{\n\tkref_put(&nmh->nh_kref, o2net_handler_kref_release);\n}\n\n \nint o2net_register_handler(u32 msg_type, u32 key, u32 max_len,\n\t\t\t   o2net_msg_handler_func *func, void *data,\n\t\t\t   o2net_post_msg_handler_func *post_func,\n\t\t\t   struct list_head *unreg_list)\n{\n\tstruct o2net_msg_handler *nmh = NULL;\n\tstruct rb_node **p, *parent;\n\tint ret = 0;\n\n\tif (max_len > O2NET_MAX_PAYLOAD_BYTES) {\n\t\tmlog(0, \"max_len for message handler out of range: %u\\n\",\n\t\t\tmax_len);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!msg_type) {\n\t\tmlog(0, \"no message type provided: %u, %p\\n\", msg_type, func);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\n\t}\n\tif (!func) {\n\t\tmlog(0, \"no message handler provided: %u, %p\\n\",\n\t\t       msg_type, func);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n       \tnmh = kzalloc(sizeof(struct o2net_msg_handler), GFP_NOFS);\n\tif (nmh == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tnmh->nh_func = func;\n\tnmh->nh_func_data = data;\n\tnmh->nh_post_func = post_func;\n\tnmh->nh_msg_type = msg_type;\n\tnmh->nh_max_len = max_len;\n\tnmh->nh_key = key;\n\t \n\tkref_init(&nmh->nh_kref);\n\tINIT_LIST_HEAD(&nmh->nh_unregister_item);\n\n\twrite_lock(&o2net_handler_lock);\n\tif (o2net_handler_tree_lookup(msg_type, key, &p, &parent))\n\t\tret = -EEXIST;\n\telse {\n\t        rb_link_node(&nmh->nh_node, parent, p);\n\t\trb_insert_color(&nmh->nh_node, &o2net_handler_tree);\n\t\tlist_add_tail(&nmh->nh_unregister_item, unreg_list);\n\n\t\tmlog(ML_TCP, \"registered handler func %p type %u key %08x\\n\",\n\t\t     func, msg_type, key);\n\t\t \n\t\tmlog_bug_on_msg(o2net_handler_tree_lookup(msg_type, key, &p,\n\t\t\t\t\t\t\t  &parent) == NULL,\n\t\t\t        \"couldn't find handler we *just* registered \"\n\t\t\t\t\"for type %u key %08x\\n\", msg_type, key);\n\t}\n\twrite_unlock(&o2net_handler_lock);\n\nout:\n\tif (ret)\n\t\tkfree(nmh);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(o2net_register_handler);\n\nvoid o2net_unregister_handler_list(struct list_head *list)\n{\n\tstruct o2net_msg_handler *nmh, *n;\n\n\twrite_lock(&o2net_handler_lock);\n\tlist_for_each_entry_safe(nmh, n, list, nh_unregister_item) {\n\t\tmlog(ML_TCP, \"unregistering handler func %p type %u key %08x\\n\",\n\t\t     nmh->nh_func, nmh->nh_msg_type, nmh->nh_key);\n\t\trb_erase(&nmh->nh_node, &o2net_handler_tree);\n\t\tlist_del_init(&nmh->nh_unregister_item);\n\t\tkref_put(&nmh->nh_kref, o2net_handler_kref_release);\n\t}\n\twrite_unlock(&o2net_handler_lock);\n}\nEXPORT_SYMBOL_GPL(o2net_unregister_handler_list);\n\nstatic struct o2net_msg_handler *o2net_handler_get(u32 msg_type, u32 key)\n{\n\tstruct o2net_msg_handler *nmh;\n\n\tread_lock(&o2net_handler_lock);\n\tnmh = o2net_handler_tree_lookup(msg_type, key, NULL, NULL);\n\tif (nmh)\n\t\tkref_get(&nmh->nh_kref);\n\tread_unlock(&o2net_handler_lock);\n\n\treturn nmh;\n}\n\n \n\nstatic int o2net_recv_tcp_msg(struct socket *sock, void *data, size_t len)\n{\n\tstruct kvec vec = { .iov_len = len, .iov_base = data, };\n\tstruct msghdr msg = { .msg_flags = MSG_DONTWAIT, };\n\tiov_iter_kvec(&msg.msg_iter, ITER_DEST, &vec, 1, len);\n\treturn sock_recvmsg(sock, &msg, MSG_DONTWAIT);\n}\n\nstatic int o2net_send_tcp_msg(struct socket *sock, struct kvec *vec,\n\t\t\t      size_t veclen, size_t total)\n{\n\tint ret;\n\tstruct msghdr msg = {.msg_flags = 0,};\n\n\tif (sock == NULL) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = kernel_sendmsg(sock, &msg, vec, veclen, total);\n\tif (likely(ret == total))\n\t\treturn 0;\n\tmlog(ML_ERROR, \"sendmsg returned %d instead of %zu\\n\", ret, total);\n\tif (ret >= 0)\n\t\tret = -EPIPE;  \nout:\n\tmlog(0, \"returning error: %d\\n\", ret);\n\treturn ret;\n}\n\nstatic void o2net_sendpage(struct o2net_sock_container *sc,\n\t\t\t   void *virt, size_t size)\n{\n\tstruct o2net_node *nn = o2net_nn_from_num(sc->sc_node->nd_num);\n\tstruct msghdr msg = {};\n\tstruct bio_vec bv;\n\tssize_t ret;\n\n\tbvec_set_virt(&bv, virt, size);\n\tiov_iter_bvec(&msg.msg_iter, ITER_SOURCE, &bv, 1, size);\n\n\twhile (1) {\n\t\tmsg.msg_flags = MSG_DONTWAIT | MSG_SPLICE_PAGES;\n\t\tmutex_lock(&sc->sc_send_lock);\n\t\tret = sock_sendmsg(sc->sc_sock, &msg);\n\t\tmutex_unlock(&sc->sc_send_lock);\n\n\t\tif (ret == size)\n\t\t\tbreak;\n\t\tif (ret == (ssize_t)-EAGAIN) {\n\t\t\tmlog(0, \"sendpage of size %zu to \" SC_NODEF_FMT\n\t\t\t     \" returned EAGAIN\\n\", size, SC_NODEF_ARGS(sc));\n\t\t\tcond_resched();\n\t\t\tcontinue;\n\t\t}\n\t\tmlog(ML_ERROR, \"sendpage of size %zu to \" SC_NODEF_FMT\n\t\t     \" failed with %zd\\n\", size, SC_NODEF_ARGS(sc), ret);\n\t\to2net_ensure_shutdown(nn, sc, 0);\n\t\tbreak;\n\t}\n}\n\nstatic void o2net_init_msg(struct o2net_msg *msg, u16 data_len, u16 msg_type, u32 key)\n{\n\tmemset(msg, 0, sizeof(struct o2net_msg));\n\tmsg->magic = cpu_to_be16(O2NET_MSG_MAGIC);\n\tmsg->data_len = cpu_to_be16(data_len);\n\tmsg->msg_type = cpu_to_be16(msg_type);\n\tmsg->sys_status = cpu_to_be32(O2NET_ERR_NONE);\n\tmsg->status = 0;\n\tmsg->key = cpu_to_be32(key);\n}\n\nstatic int o2net_tx_can_proceed(struct o2net_node *nn,\n\t\t\t        struct o2net_sock_container **sc_ret,\n\t\t\t\tint *error)\n{\n\tint ret = 0;\n\n\tspin_lock(&nn->nn_lock);\n\tif (nn->nn_persistent_error) {\n\t\tret = 1;\n\t\t*sc_ret = NULL;\n\t\t*error = nn->nn_persistent_error;\n\t} else if (nn->nn_sc_valid) {\n\t\tkref_get(&nn->nn_sc->sc_kref);\n\n\t\tret = 1;\n\t\t*sc_ret = nn->nn_sc;\n\t\t*error = 0;\n\t}\n\tspin_unlock(&nn->nn_lock);\n\n\treturn ret;\n}\n\n \nvoid o2net_fill_node_map(unsigned long *map, unsigned int bits)\n{\n\tstruct o2net_sock_container *sc;\n\tint node, ret;\n\n\tbitmap_zero(map, bits);\n\tfor (node = 0; node < O2NM_MAX_NODES; ++node) {\n\t\tif (!o2net_tx_can_proceed(o2net_nn_from_num(node), &sc, &ret))\n\t\t\tcontinue;\n\t\tif (!ret) {\n\t\t\tset_bit(node, map);\n\t\t\tsc_put(sc);\n\t\t}\n\t}\n}\nEXPORT_SYMBOL_GPL(o2net_fill_node_map);\n\nint o2net_send_message_vec(u32 msg_type, u32 key, struct kvec *caller_vec,\n\t\t\t   size_t caller_veclen, u8 target_node, int *status)\n{\n\tint ret = 0;\n\tstruct o2net_msg *msg = NULL;\n\tsize_t veclen, caller_bytes = 0;\n\tstruct kvec *vec = NULL;\n\tstruct o2net_sock_container *sc = NULL;\n\tstruct o2net_node *nn = o2net_nn_from_num(target_node);\n\tstruct o2net_status_wait nsw = {\n\t\t.ns_node_item = LIST_HEAD_INIT(nsw.ns_node_item),\n\t};\n\tstruct o2net_send_tracking nst;\n\n\to2net_init_nst(&nst, msg_type, key, current, target_node);\n\n\tif (o2net_wq == NULL) {\n\t\tmlog(0, \"attempt to tx without o2netd running\\n\");\n\t\tret = -ESRCH;\n\t\tgoto out;\n\t}\n\n\tif (caller_veclen == 0) {\n\t\tmlog(0, \"bad kvec array length\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tcaller_bytes = iov_length((struct iovec *)caller_vec, caller_veclen);\n\tif (caller_bytes > O2NET_MAX_PAYLOAD_BYTES) {\n\t\tmlog(0, \"total payload len %zu too large\\n\", caller_bytes);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (target_node == o2nm_this_node()) {\n\t\tret = -ELOOP;\n\t\tgoto out;\n\t}\n\n\to2net_debug_add_nst(&nst);\n\n\to2net_set_nst_sock_time(&nst);\n\n\twait_event(nn->nn_sc_wq, o2net_tx_can_proceed(nn, &sc, &ret));\n\tif (ret)\n\t\tgoto out;\n\n\to2net_set_nst_sock_container(&nst, sc);\n\n\tveclen = caller_veclen + 1;\n\tvec = kmalloc_array(veclen, sizeof(struct kvec), GFP_ATOMIC);\n\tif (vec == NULL) {\n\t\tmlog(0, \"failed to %zu element kvec!\\n\", veclen);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmsg = kmalloc(sizeof(struct o2net_msg), GFP_ATOMIC);\n\tif (!msg) {\n\t\tmlog(0, \"failed to allocate a o2net_msg!\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\to2net_init_msg(msg, caller_bytes, msg_type, key);\n\n\tvec[0].iov_len = sizeof(struct o2net_msg);\n\tvec[0].iov_base = msg;\n\tmemcpy(&vec[1], caller_vec, caller_veclen * sizeof(struct kvec));\n\n\tret = o2net_prep_nsw(nn, &nsw);\n\tif (ret)\n\t\tgoto out;\n\n\tmsg->msg_num = cpu_to_be32(nsw.ns_id);\n\to2net_set_nst_msg_id(&nst, nsw.ns_id);\n\n\to2net_set_nst_send_time(&nst);\n\n\t \n\tmutex_lock(&sc->sc_send_lock);\n\tret = o2net_send_tcp_msg(sc->sc_sock, vec, veclen,\n\t\t\t\t sizeof(struct o2net_msg) + caller_bytes);\n\tmutex_unlock(&sc->sc_send_lock);\n\tmsglog(msg, \"sending returned %d\\n\", ret);\n\tif (ret < 0) {\n\t\tmlog(0, \"error returned from o2net_send_tcp_msg=%d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\t \n\to2net_set_nst_status_time(&nst);\n\twait_event(nsw.ns_wq, o2net_nsw_completed(nn, &nsw));\n\n\to2net_update_send_stats(&nst, sc);\n\n\t \n\tret = o2net_sys_err_to_errno(nsw.ns_sys_status);\n\tif (status && !ret)\n\t\t*status = nsw.ns_status;\n\n\tmlog(0, \"woken, returning system status %d, user status %d\\n\",\n\t     ret, nsw.ns_status);\nout:\n\to2net_debug_del_nst(&nst);  \n\tif (sc)\n\t\tsc_put(sc);\n\tkfree(vec);\n\tkfree(msg);\n\to2net_complete_nsw(nn, &nsw, 0, 0, 0);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(o2net_send_message_vec);\n\nint o2net_send_message(u32 msg_type, u32 key, void *data, u32 len,\n\t\t       u8 target_node, int *status)\n{\n\tstruct kvec vec = {\n\t\t.iov_base = data,\n\t\t.iov_len = len,\n\t};\n\treturn o2net_send_message_vec(msg_type, key, &vec, 1,\n\t\t\t\t      target_node, status);\n}\nEXPORT_SYMBOL_GPL(o2net_send_message);\n\nstatic int o2net_send_status_magic(struct socket *sock, struct o2net_msg *hdr,\n\t\t\t\t   enum o2net_system_error syserr, int err)\n{\n\tstruct kvec vec = {\n\t\t.iov_base = hdr,\n\t\t.iov_len = sizeof(struct o2net_msg),\n\t};\n\n\tBUG_ON(syserr >= O2NET_ERR_MAX);\n\n\t \n\thdr->sys_status = cpu_to_be32(syserr);\n\thdr->status = cpu_to_be32(err);\n\thdr->magic = cpu_to_be16(O2NET_MSG_STATUS_MAGIC);   \n\thdr->data_len = 0;\n\n\tmsglog(hdr, \"about to send status magic %d\\n\", err);\n\t \n\treturn o2net_send_tcp_msg(sock, &vec, 1, sizeof(struct o2net_msg));\n}\n\n \nstatic int o2net_process_message(struct o2net_sock_container *sc,\n\t\t\t\t struct o2net_msg *hdr)\n{\n\tstruct o2net_node *nn = o2net_nn_from_num(sc->sc_node->nd_num);\n\tint ret = 0, handler_status;\n\tenum  o2net_system_error syserr;\n\tstruct o2net_msg_handler *nmh = NULL;\n\tvoid *ret_data = NULL;\n\n\tmsglog(hdr, \"processing message\\n\");\n\n\to2net_sc_postpone_idle(sc);\n\n\tswitch(be16_to_cpu(hdr->magic)) {\n\t\tcase O2NET_MSG_STATUS_MAGIC:\n\t\t\t \n\t\t\to2net_complete_nsw(nn, NULL,\n\t\t\t\t\t   be32_to_cpu(hdr->msg_num),\n\t\t\t\t\t   be32_to_cpu(hdr->sys_status),\n\t\t\t\t\t   be32_to_cpu(hdr->status));\n\t\t\tgoto out;\n\t\tcase O2NET_MSG_KEEP_REQ_MAGIC:\n\t\t\to2net_sendpage(sc, o2net_keep_resp,\n\t\t\t\t       sizeof(*o2net_keep_resp));\n\t\t\tgoto out;\n\t\tcase O2NET_MSG_KEEP_RESP_MAGIC:\n\t\t\tgoto out;\n\t\tcase O2NET_MSG_MAGIC:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmsglog(hdr, \"bad magic\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t}\n\n\t \n\thandler_status = 0;\n\tnmh = o2net_handler_get(be16_to_cpu(hdr->msg_type),\n\t\t\t\tbe32_to_cpu(hdr->key));\n\tif (!nmh) {\n\t\tmlog(ML_TCP, \"couldn't find handler for type %u key %08x\\n\",\n\t\t     be16_to_cpu(hdr->msg_type), be32_to_cpu(hdr->key));\n\t\tsyserr = O2NET_ERR_NO_HNDLR;\n\t\tgoto out_respond;\n\t}\n\n\tsyserr = O2NET_ERR_NONE;\n\n\tif (be16_to_cpu(hdr->data_len) > nmh->nh_max_len)\n\t\tsyserr = O2NET_ERR_OVERFLOW;\n\n\tif (syserr != O2NET_ERR_NONE)\n\t\tgoto out_respond;\n\n\to2net_set_func_start_time(sc);\n\tsc->sc_msg_key = be32_to_cpu(hdr->key);\n\tsc->sc_msg_type = be16_to_cpu(hdr->msg_type);\n\thandler_status = (nmh->nh_func)(hdr, sizeof(struct o2net_msg) +\n\t\t\t\t\t     be16_to_cpu(hdr->data_len),\n\t\t\t\t\tnmh->nh_func_data, &ret_data);\n\to2net_set_func_stop_time(sc);\n\n\to2net_update_recv_stats(sc);\n\nout_respond:\n\t \n\tmutex_lock(&sc->sc_send_lock);\n\tret = o2net_send_status_magic(sc->sc_sock, hdr, syserr,\n\t\t\t\t      handler_status);\n\tmutex_unlock(&sc->sc_send_lock);\n\thdr = NULL;\n\tmlog(0, \"sending handler status %d, syserr %d returned %d\\n\",\n\t     handler_status, syserr, ret);\n\n\tif (nmh) {\n\t\tBUG_ON(ret_data != NULL && nmh->nh_post_func == NULL);\n\t\tif (nmh->nh_post_func)\n\t\t\t(nmh->nh_post_func)(handler_status, nmh->nh_func_data,\n\t\t\t\t\t    ret_data);\n\t}\n\nout:\n\tif (nmh)\n\t\to2net_handler_put(nmh);\n\treturn ret;\n}\n\nstatic int o2net_check_handshake(struct o2net_sock_container *sc)\n{\n\tstruct o2net_handshake *hand = page_address(sc->sc_page);\n\tstruct o2net_node *nn = o2net_nn_from_num(sc->sc_node->nd_num);\n\n\tif (hand->protocol_version != cpu_to_be64(O2NET_PROTOCOL_VERSION)) {\n\t\tprintk(KERN_NOTICE \"o2net: \" SC_NODEF_FMT \" Advertised net \"\n\t\t       \"protocol version %llu but %llu is required. \"\n\t\t       \"Disconnecting.\\n\", SC_NODEF_ARGS(sc),\n\t\t       (unsigned long long)be64_to_cpu(hand->protocol_version),\n\t\t       O2NET_PROTOCOL_VERSION);\n\n\t\t \n\t\to2net_ensure_shutdown(nn, sc, -ENOTCONN);\n\t\treturn -1;\n\t}\n\n\t \n\tif (be32_to_cpu(hand->o2net_idle_timeout_ms) !=\n\t\t\t\to2net_idle_timeout()) {\n\t\tprintk(KERN_NOTICE \"o2net: \" SC_NODEF_FMT \" uses a network \"\n\t\t       \"idle timeout of %u ms, but we use %u ms locally. \"\n\t\t       \"Disconnecting.\\n\", SC_NODEF_ARGS(sc),\n\t\t       be32_to_cpu(hand->o2net_idle_timeout_ms),\n\t\t       o2net_idle_timeout());\n\t\to2net_ensure_shutdown(nn, sc, -ENOTCONN);\n\t\treturn -1;\n\t}\n\n\tif (be32_to_cpu(hand->o2net_keepalive_delay_ms) !=\n\t\t\to2net_keepalive_delay()) {\n\t\tprintk(KERN_NOTICE \"o2net: \" SC_NODEF_FMT \" uses a keepalive \"\n\t\t       \"delay of %u ms, but we use %u ms locally. \"\n\t\t       \"Disconnecting.\\n\", SC_NODEF_ARGS(sc),\n\t\t       be32_to_cpu(hand->o2net_keepalive_delay_ms),\n\t\t       o2net_keepalive_delay());\n\t\to2net_ensure_shutdown(nn, sc, -ENOTCONN);\n\t\treturn -1;\n\t}\n\n\tif (be32_to_cpu(hand->o2hb_heartbeat_timeout_ms) !=\n\t\t\tO2HB_MAX_WRITE_TIMEOUT_MS) {\n\t\tprintk(KERN_NOTICE \"o2net: \" SC_NODEF_FMT \" uses a heartbeat \"\n\t\t       \"timeout of %u ms, but we use %u ms locally. \"\n\t\t       \"Disconnecting.\\n\", SC_NODEF_ARGS(sc),\n\t\t       be32_to_cpu(hand->o2hb_heartbeat_timeout_ms),\n\t\t       O2HB_MAX_WRITE_TIMEOUT_MS);\n\t\to2net_ensure_shutdown(nn, sc, -ENOTCONN);\n\t\treturn -1;\n\t}\n\n\tsc->sc_handshake_ok = 1;\n\n\tspin_lock(&nn->nn_lock);\n\t \n\tif (nn->nn_sc == sc) {\n\t\to2net_sc_reset_idle_timer(sc);\n\t\tatomic_set(&nn->nn_timeout, 0);\n\t\to2net_set_nn_state(nn, sc, 1, 0);\n\t}\n\tspin_unlock(&nn->nn_lock);\n\n\t \n\tsc->sc_page_off -= sizeof(struct o2net_handshake);\n\tif (sc->sc_page_off)\n\t\tmemmove(hand, hand + 1, sc->sc_page_off);\n\n\treturn 0;\n}\n\n \nstatic int o2net_advance_rx(struct o2net_sock_container *sc)\n{\n\tstruct o2net_msg *hdr;\n\tint ret = 0;\n\tvoid *data;\n\tsize_t datalen;\n\n\tsclog(sc, \"receiving\\n\");\n\to2net_set_advance_start_time(sc);\n\n\tif (unlikely(sc->sc_handshake_ok == 0)) {\n\t\tif(sc->sc_page_off < sizeof(struct o2net_handshake)) {\n\t\t\tdata = page_address(sc->sc_page) + sc->sc_page_off;\n\t\t\tdatalen = sizeof(struct o2net_handshake) - sc->sc_page_off;\n\t\t\tret = o2net_recv_tcp_msg(sc->sc_sock, data, datalen);\n\t\t\tif (ret > 0)\n\t\t\t\tsc->sc_page_off += ret;\n\t\t}\n\n\t\tif (sc->sc_page_off == sizeof(struct o2net_handshake)) {\n\t\t\to2net_check_handshake(sc);\n\t\t\tif (unlikely(sc->sc_handshake_ok == 0))\n\t\t\t\tret = -EPROTO;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t \n\tif (sc->sc_page_off < sizeof(struct o2net_msg)) {\n\t\tdata = page_address(sc->sc_page) + sc->sc_page_off;\n\t\tdatalen = sizeof(struct o2net_msg) - sc->sc_page_off;\n\t\tret = o2net_recv_tcp_msg(sc->sc_sock, data, datalen);\n\t\tif (ret > 0) {\n\t\t\tsc->sc_page_off += ret;\n\t\t\t \n\t\t\tif (sc->sc_page_off == sizeof(struct o2net_msg)) {\n\t\t\t\thdr = page_address(sc->sc_page);\n\t\t\t\tif (be16_to_cpu(hdr->data_len) >\n\t\t\t\t    O2NET_MAX_PAYLOAD_BYTES)\n\t\t\t\t\tret = -EOVERFLOW;\n\t\t\t}\n\t\t}\n\t\tif (ret <= 0)\n\t\t\tgoto out;\n\t}\n\n\tif (sc->sc_page_off < sizeof(struct o2net_msg)) {\n\t\t \n\t\tgoto out;\n\t}\n\n\t \n\thdr = page_address(sc->sc_page);\n\n\tmsglog(hdr, \"at page_off %zu\\n\", sc->sc_page_off);\n\n\t \n\tif (sc->sc_page_off - sizeof(struct o2net_msg) < be16_to_cpu(hdr->data_len)) {\n\t\t \n\t\tdata = page_address(sc->sc_page) + sc->sc_page_off;\n\t\tdatalen = (sizeof(struct o2net_msg) + be16_to_cpu(hdr->data_len)) -\n\t\t\t  sc->sc_page_off;\n\t\tret = o2net_recv_tcp_msg(sc->sc_sock, data, datalen);\n\t\tif (ret > 0)\n\t\t\tsc->sc_page_off += ret;\n\t\tif (ret <= 0)\n\t\t\tgoto out;\n\t}\n\n\tif (sc->sc_page_off - sizeof(struct o2net_msg) == be16_to_cpu(hdr->data_len)) {\n\t\t \n\t\tret = o2net_process_message(sc, hdr);\n\t\tif (ret == 0)\n\t\t\tret = 1;\n\t\tsc->sc_page_off = 0;\n\t}\n\nout:\n\tsclog(sc, \"ret = %d\\n\", ret);\n\to2net_set_advance_stop_time(sc);\n\treturn ret;\n}\n\n \nstatic void o2net_rx_until_empty(struct work_struct *work)\n{\n\tstruct o2net_sock_container *sc =\n\t\tcontainer_of(work, struct o2net_sock_container, sc_rx_work);\n\tint ret;\n\n\tdo {\n\t\tret = o2net_advance_rx(sc);\n\t} while (ret > 0);\n\n\tif (ret <= 0 && ret != -EAGAIN) {\n\t\tstruct o2net_node *nn = o2net_nn_from_num(sc->sc_node->nd_num);\n\t\tsclog(sc, \"saw error %d, closing\\n\", ret);\n\t\t \n\t\to2net_ensure_shutdown(nn, sc, 0);\n\t}\n\n\tsc_put(sc);\n}\n\nstatic void o2net_initialize_handshake(void)\n{\n\to2net_hand->o2hb_heartbeat_timeout_ms = cpu_to_be32(\n\t\tO2HB_MAX_WRITE_TIMEOUT_MS);\n\to2net_hand->o2net_idle_timeout_ms = cpu_to_be32(o2net_idle_timeout());\n\to2net_hand->o2net_keepalive_delay_ms = cpu_to_be32(\n\t\to2net_keepalive_delay());\n\to2net_hand->o2net_reconnect_delay_ms = cpu_to_be32(\n\t\to2net_reconnect_delay());\n}\n\n \n\n \nstatic void o2net_sc_connect_completed(struct work_struct *work)\n{\n\tstruct o2net_sock_container *sc =\n\t\tcontainer_of(work, struct o2net_sock_container,\n\t\t\t     sc_connect_work);\n\n\tmlog(ML_MSG, \"sc sending handshake with ver %llu id %llx\\n\",\n              (unsigned long long)O2NET_PROTOCOL_VERSION,\n\t      (unsigned long long)be64_to_cpu(o2net_hand->connector_id));\n\n\to2net_initialize_handshake();\n\to2net_sendpage(sc, o2net_hand, sizeof(*o2net_hand));\n\tsc_put(sc);\n}\n\n \nstatic void o2net_sc_send_keep_req(struct work_struct *work)\n{\n\tstruct o2net_sock_container *sc =\n\t\tcontainer_of(work, struct o2net_sock_container,\n\t\t\t     sc_keepalive_work.work);\n\n\to2net_sendpage(sc, o2net_keep_req, sizeof(*o2net_keep_req));\n\tsc_put(sc);\n}\n\n \nstatic void o2net_idle_timer(struct timer_list *t)\n{\n\tstruct o2net_sock_container *sc = from_timer(sc, t, sc_idle_timeout);\n\tstruct o2net_node *nn = o2net_nn_from_num(sc->sc_node->nd_num);\n#ifdef CONFIG_DEBUG_FS\n\tunsigned long msecs = ktime_to_ms(ktime_get()) -\n\t\tktime_to_ms(sc->sc_tv_timer);\n#else\n\tunsigned long msecs = o2net_idle_timeout();\n#endif\n\n\tprintk(KERN_NOTICE \"o2net: Connection to \" SC_NODEF_FMT \" has been \"\n\t       \"idle for %lu.%lu secs.\\n\",\n\t       SC_NODEF_ARGS(sc), msecs / 1000, msecs % 1000);\n\n\t \n\tatomic_set(&nn->nn_timeout, 1);\n\to2quo_conn_err(o2net_num_from_nn(nn));\n\tqueue_delayed_work(o2net_wq, &nn->nn_still_up,\n\t\t\tmsecs_to_jiffies(O2NET_QUORUM_DELAY_MS));\n\n\to2net_sc_reset_idle_timer(sc);\n\n}\n\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc)\n{\n\to2net_sc_cancel_delayed_work(sc, &sc->sc_keepalive_work);\n\to2net_sc_queue_delayed_work(sc, &sc->sc_keepalive_work,\n\t\t      msecs_to_jiffies(o2net_keepalive_delay()));\n\to2net_set_sock_timer(sc);\n\tmod_timer(&sc->sc_idle_timeout,\n\t       jiffies + msecs_to_jiffies(o2net_idle_timeout()));\n}\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc)\n{\n\tstruct o2net_node *nn = o2net_nn_from_num(sc->sc_node->nd_num);\n\n\t \n\tif (atomic_read(&nn->nn_timeout)) {\n\t\to2quo_conn_up(o2net_num_from_nn(nn));\n\t\tcancel_delayed_work(&nn->nn_still_up);\n\t\tatomic_set(&nn->nn_timeout, 0);\n\t}\n\n\t \n\tif (timer_pending(&sc->sc_idle_timeout))\n\t\to2net_sc_reset_idle_timer(sc);\n}\n\n \nstatic void o2net_start_connect(struct work_struct *work)\n{\n\tstruct o2net_node *nn =\n\t\tcontainer_of(work, struct o2net_node, nn_connect_work.work);\n\tstruct o2net_sock_container *sc = NULL;\n\tstruct o2nm_node *node = NULL, *mynode = NULL;\n\tstruct socket *sock = NULL;\n\tstruct sockaddr_in myaddr = {0, }, remoteaddr = {0, };\n\tint ret = 0, stop;\n\tunsigned int timeout;\n\tunsigned int nofs_flag;\n\n\t \n\tnofs_flag = memalloc_nofs_save();\n\t \n\tif (o2nm_this_node() <= o2net_num_from_nn(nn))\n\t\tgoto out;\n\n\t \n\tnode = o2nm_get_node_by_num(o2net_num_from_nn(nn));\n\tif (node == NULL)\n\t\tgoto out;\n\n\tmynode = o2nm_get_node_by_num(o2nm_this_node());\n\tif (mynode == NULL)\n\t\tgoto out;\n\n\tspin_lock(&nn->nn_lock);\n\t \n\ttimeout = atomic_read(&nn->nn_timeout);\n\tstop = (nn->nn_sc ||\n\t\t(nn->nn_persistent_error &&\n\t\t(nn->nn_persistent_error != -ENOTCONN || timeout == 0)));\n\tspin_unlock(&nn->nn_lock);\n\tif (stop)\n\t\tgoto out;\n\n\tnn->nn_last_connect_attempt = jiffies;\n\n\tsc = sc_alloc(node);\n\tif (sc == NULL) {\n\t\tmlog(0, \"couldn't allocate sc\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = sock_create(PF_INET, SOCK_STREAM, IPPROTO_TCP, &sock);\n\tif (ret < 0) {\n\t\tmlog(0, \"can't create socket: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tsc->sc_sock = sock;  \n\n\tsock->sk->sk_allocation = GFP_ATOMIC;\n\tsock->sk->sk_use_task_frag = false;\n\n\tmyaddr.sin_family = AF_INET;\n\tmyaddr.sin_addr.s_addr = mynode->nd_ipv4_address;\n\tmyaddr.sin_port = htons(0);  \n\n\tret = sock->ops->bind(sock, (struct sockaddr *)&myaddr,\n\t\t\t      sizeof(myaddr));\n\tif (ret) {\n\t\tmlog(ML_ERROR, \"bind failed with %d at address %pI4\\n\",\n\t\t     ret, &mynode->nd_ipv4_address);\n\t\tgoto out;\n\t}\n\n\ttcp_sock_set_nodelay(sc->sc_sock->sk);\n\ttcp_sock_set_user_timeout(sock->sk, O2NET_TCP_USER_TIMEOUT);\n\n\to2net_register_callbacks(sc->sc_sock->sk, sc);\n\n\tspin_lock(&nn->nn_lock);\n\t \n\to2net_set_nn_state(nn, sc, 0, 0);\n\tspin_unlock(&nn->nn_lock);\n\n\tremoteaddr.sin_family = AF_INET;\n\tremoteaddr.sin_addr.s_addr = node->nd_ipv4_address;\n\tremoteaddr.sin_port = node->nd_ipv4_port;\n\n\tret = sc->sc_sock->ops->connect(sc->sc_sock,\n\t\t\t\t\t(struct sockaddr *)&remoteaddr,\n\t\t\t\t\tsizeof(remoteaddr),\n\t\t\t\t\tO_NONBLOCK);\n\tif (ret == -EINPROGRESS)\n\t\tret = 0;\n\nout:\n\tif (ret && sc) {\n\t\tprintk(KERN_NOTICE \"o2net: Connect attempt to \" SC_NODEF_FMT\n\t\t       \" failed with errno %d\\n\", SC_NODEF_ARGS(sc), ret);\n\t\t \n\t\to2net_ensure_shutdown(nn, sc, 0);\n\t}\n\tif (sc)\n\t\tsc_put(sc);\n\tif (node)\n\t\to2nm_node_put(node);\n\tif (mynode)\n\t\to2nm_node_put(mynode);\n\n\tmemalloc_nofs_restore(nofs_flag);\n\treturn;\n}\n\nstatic void o2net_connect_expired(struct work_struct *work)\n{\n\tstruct o2net_node *nn =\n\t\tcontainer_of(work, struct o2net_node, nn_connect_expired.work);\n\n\tspin_lock(&nn->nn_lock);\n\tif (!nn->nn_sc_valid) {\n\t\tprintk(KERN_NOTICE \"o2net: No connection established with \"\n\t\t       \"node %u after %u.%u seconds, check network and\"\n\t\t       \" cluster configuration.\\n\",\n\t\t     o2net_num_from_nn(nn),\n\t\t     o2net_idle_timeout() / 1000,\n\t\t     o2net_idle_timeout() % 1000);\n\n\t\to2net_set_nn_state(nn, NULL, 0, 0);\n\t}\n\tspin_unlock(&nn->nn_lock);\n}\n\nstatic void o2net_still_up(struct work_struct *work)\n{\n\tstruct o2net_node *nn =\n\t\tcontainer_of(work, struct o2net_node, nn_still_up.work);\n\n\to2quo_hb_still_up(o2net_num_from_nn(nn));\n}\n\n \n\nvoid o2net_disconnect_node(struct o2nm_node *node)\n{\n\tstruct o2net_node *nn = o2net_nn_from_num(node->nd_num);\n\n\t \n\tspin_lock(&nn->nn_lock);\n\tatomic_set(&nn->nn_timeout, 0);\n\to2net_set_nn_state(nn, NULL, 0, -ENOTCONN);\n\tspin_unlock(&nn->nn_lock);\n\n\tif (o2net_wq) {\n\t\tcancel_delayed_work(&nn->nn_connect_expired);\n\t\tcancel_delayed_work(&nn->nn_connect_work);\n\t\tcancel_delayed_work(&nn->nn_still_up);\n\t\tflush_workqueue(o2net_wq);\n\t}\n}\n\nstatic void o2net_hb_node_down_cb(struct o2nm_node *node, int node_num,\n\t\t\t\t  void *data)\n{\n\to2quo_hb_down(node_num);\n\n\tif (!node)\n\t\treturn;\n\n\tif (node_num != o2nm_this_node())\n\t\to2net_disconnect_node(node);\n\n\tBUG_ON(atomic_read(&o2net_connected_peers) < 0);\n}\n\nstatic void o2net_hb_node_up_cb(struct o2nm_node *node, int node_num,\n\t\t\t\tvoid *data)\n{\n\tstruct o2net_node *nn = o2net_nn_from_num(node_num);\n\n\to2quo_hb_up(node_num);\n\n\tBUG_ON(!node);\n\n\t \n\tnn->nn_last_connect_attempt = jiffies -\n\t\t(msecs_to_jiffies(o2net_reconnect_delay()) + 1);\n\n\tif (node_num != o2nm_this_node()) {\n\t\t \n\t\tspin_lock(&nn->nn_lock);\n\t\tatomic_set(&nn->nn_timeout, 0);\n\t\tif (nn->nn_persistent_error)\n\t\t\to2net_set_nn_state(nn, NULL, 0, 0);\n\t\tspin_unlock(&nn->nn_lock);\n\t}\n}\n\nvoid o2net_unregister_hb_callbacks(void)\n{\n\to2hb_unregister_callback(NULL, &o2net_hb_up);\n\to2hb_unregister_callback(NULL, &o2net_hb_down);\n}\n\nint o2net_register_hb_callbacks(void)\n{\n\tint ret;\n\n\to2hb_setup_callback(&o2net_hb_down, O2HB_NODE_DOWN_CB,\n\t\t\t    o2net_hb_node_down_cb, NULL, O2NET_HB_PRI);\n\to2hb_setup_callback(&o2net_hb_up, O2HB_NODE_UP_CB,\n\t\t\t    o2net_hb_node_up_cb, NULL, O2NET_HB_PRI);\n\n\tret = o2hb_register_callback(NULL, &o2net_hb_up);\n\tif (ret == 0)\n\t\tret = o2hb_register_callback(NULL, &o2net_hb_down);\n\n\tif (ret)\n\t\to2net_unregister_hb_callbacks();\n\n\treturn ret;\n}\n\n \n\nstatic int o2net_accept_one(struct socket *sock, int *more)\n{\n\tint ret;\n\tstruct sockaddr_in sin;\n\tstruct socket *new_sock = NULL;\n\tstruct o2nm_node *node = NULL;\n\tstruct o2nm_node *local_node = NULL;\n\tstruct o2net_sock_container *sc = NULL;\n\tstruct o2net_node *nn;\n\tunsigned int nofs_flag;\n\n\t \n\tnofs_flag = memalloc_nofs_save();\n\n\tBUG_ON(sock == NULL);\n\t*more = 0;\n\tret = sock_create_lite(sock->sk->sk_family, sock->sk->sk_type,\n\t\t\t       sock->sk->sk_protocol, &new_sock);\n\tif (ret)\n\t\tgoto out;\n\n\tnew_sock->type = sock->type;\n\tnew_sock->ops = sock->ops;\n\tret = sock->ops->accept(sock, new_sock, O_NONBLOCK, false);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t*more = 1;\n\tnew_sock->sk->sk_allocation = GFP_ATOMIC;\n\n\ttcp_sock_set_nodelay(new_sock->sk);\n\ttcp_sock_set_user_timeout(new_sock->sk, O2NET_TCP_USER_TIMEOUT);\n\n\tret = new_sock->ops->getname(new_sock, (struct sockaddr *) &sin, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tnode = o2nm_get_node_by_ip(sin.sin_addr.s_addr);\n\tif (node == NULL) {\n\t\tprintk(KERN_NOTICE \"o2net: Attempt to connect from unknown \"\n\t\t       \"node at %pI4:%d\\n\", &sin.sin_addr.s_addr,\n\t\t       ntohs(sin.sin_port));\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (o2nm_this_node() >= node->nd_num) {\n\t\tlocal_node = o2nm_get_node_by_num(o2nm_this_node());\n\t\tif (local_node)\n\t\t\tprintk(KERN_NOTICE \"o2net: Unexpected connect attempt \"\n\t\t\t\t\t\"seen at node '%s' (%u, %pI4:%d) from \"\n\t\t\t\t\t\"node '%s' (%u, %pI4:%d)\\n\",\n\t\t\t\t\tlocal_node->nd_name, local_node->nd_num,\n\t\t\t\t\t&(local_node->nd_ipv4_address),\n\t\t\t\t\tntohs(local_node->nd_ipv4_port),\n\t\t\t\t\tnode->nd_name,\n\t\t\t\t\tnode->nd_num, &sin.sin_addr.s_addr,\n\t\t\t\t\tntohs(sin.sin_port));\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (!o2hb_check_node_heartbeating_from_callback(node->nd_num)) {\n\t\tmlog(ML_CONN, \"attempt to connect from node '%s' at \"\n\t\t     \"%pI4:%d but it isn't heartbeating\\n\",\n\t\t     node->nd_name, &sin.sin_addr.s_addr,\n\t\t     ntohs(sin.sin_port));\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tnn = o2net_nn_from_num(node->nd_num);\n\n\tspin_lock(&nn->nn_lock);\n\tif (nn->nn_sc)\n\t\tret = -EBUSY;\n\telse\n\t\tret = 0;\n\tspin_unlock(&nn->nn_lock);\n\tif (ret) {\n\t\tprintk(KERN_NOTICE \"o2net: Attempt to connect from node '%s' \"\n\t\t       \"at %pI4:%d but it already has an open connection\\n\",\n\t\t       node->nd_name, &sin.sin_addr.s_addr,\n\t\t       ntohs(sin.sin_port));\n\t\tgoto out;\n\t}\n\n\tsc = sc_alloc(node);\n\tif (sc == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tsc->sc_sock = new_sock;\n\tnew_sock = NULL;\n\n\tspin_lock(&nn->nn_lock);\n\tatomic_set(&nn->nn_timeout, 0);\n\to2net_set_nn_state(nn, sc, 0, 0);\n\tspin_unlock(&nn->nn_lock);\n\n\to2net_register_callbacks(sc->sc_sock->sk, sc);\n\to2net_sc_queue_work(sc, &sc->sc_rx_work);\n\n\to2net_initialize_handshake();\n\to2net_sendpage(sc, o2net_hand, sizeof(*o2net_hand));\n\nout:\n\tif (new_sock)\n\t\tsock_release(new_sock);\n\tif (node)\n\t\to2nm_node_put(node);\n\tif (local_node)\n\t\to2nm_node_put(local_node);\n\tif (sc)\n\t\tsc_put(sc);\n\n\tmemalloc_nofs_restore(nofs_flag);\n\treturn ret;\n}\n\n \n\nstatic void o2net_accept_many(struct work_struct *work)\n{\n\tstruct socket *sock = o2net_listen_sock;\n\tint\tmore;\n\n\t \n\n\tfor (;;) {\n\t\to2net_accept_one(sock, &more);\n\t\tif (!more)\n\t\t\tbreak;\n\t\tcond_resched();\n\t}\n}\n\nstatic void o2net_listen_data_ready(struct sock *sk)\n{\n\tvoid (*ready)(struct sock *sk);\n\n\ttrace_sk_data_ready(sk);\n\n\tread_lock_bh(&sk->sk_callback_lock);\n\tready = sk->sk_user_data;\n\tif (ready == NULL) {  \n\t\tready = sk->sk_data_ready;\n\t\tgoto out;\n\t}\n\n\t \n\n\tif (sk->sk_state == TCP_LISTEN) {\n\t\tqueue_work(o2net_wq, &o2net_listen_work);\n\t} else {\n\t\tready = NULL;\n\t}\n\nout:\n\tread_unlock_bh(&sk->sk_callback_lock);\n\tif (ready != NULL)\n\t\tready(sk);\n}\n\nstatic int o2net_open_listening_sock(__be32 addr, __be16 port)\n{\n\tstruct socket *sock = NULL;\n\tint ret;\n\tstruct sockaddr_in sin = {\n\t\t.sin_family = PF_INET,\n\t\t.sin_addr = { .s_addr = addr },\n\t\t.sin_port = port,\n\t};\n\n\tret = sock_create(PF_INET, SOCK_STREAM, IPPROTO_TCP, &sock);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR \"o2net: Error %d while creating socket\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tsock->sk->sk_allocation = GFP_ATOMIC;\n\n\twrite_lock_bh(&sock->sk->sk_callback_lock);\n\tsock->sk->sk_user_data = sock->sk->sk_data_ready;\n\tsock->sk->sk_data_ready = o2net_listen_data_ready;\n\twrite_unlock_bh(&sock->sk->sk_callback_lock);\n\n\to2net_listen_sock = sock;\n\tINIT_WORK(&o2net_listen_work, o2net_accept_many);\n\n\tsock->sk->sk_reuse = SK_CAN_REUSE;\n\tret = sock->ops->bind(sock, (struct sockaddr *)&sin, sizeof(sin));\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR \"o2net: Error %d while binding socket at \"\n\t\t       \"%pI4:%u\\n\", ret, &addr, ntohs(port)); \n\t\tgoto out;\n\t}\n\n\tret = sock->ops->listen(sock, 64);\n\tif (ret < 0)\n\t\tprintk(KERN_ERR \"o2net: Error %d while listening on %pI4:%u\\n\",\n\t\t       ret, &addr, ntohs(port));\n\nout:\n\tif (ret) {\n\t\to2net_listen_sock = NULL;\n\t\tif (sock)\n\t\t\tsock_release(sock);\n\t}\n\treturn ret;\n}\n\n \nint o2net_start_listening(struct o2nm_node *node)\n{\n\tint ret = 0;\n\n\tBUG_ON(o2net_wq != NULL);\n\tBUG_ON(o2net_listen_sock != NULL);\n\n\tmlog(ML_KTHREAD, \"starting o2net thread...\\n\");\n\to2net_wq = alloc_ordered_workqueue(\"o2net\", WQ_MEM_RECLAIM);\n\tif (o2net_wq == NULL) {\n\t\tmlog(ML_ERROR, \"unable to launch o2net thread\\n\");\n\t\treturn -ENOMEM;  \n\t}\n\n\tret = o2net_open_listening_sock(node->nd_ipv4_address,\n\t\t\t\t\tnode->nd_ipv4_port);\n\tif (ret) {\n\t\tdestroy_workqueue(o2net_wq);\n\t\to2net_wq = NULL;\n\t} else\n\t\to2quo_conn_up(node->nd_num);\n\n\treturn ret;\n}\n\n \nvoid o2net_stop_listening(struct o2nm_node *node)\n{\n\tstruct socket *sock = o2net_listen_sock;\n\tsize_t i;\n\n\tBUG_ON(o2net_wq == NULL);\n\tBUG_ON(o2net_listen_sock == NULL);\n\n\t \n\twrite_lock_bh(&sock->sk->sk_callback_lock);\n\tsock->sk->sk_data_ready = sock->sk->sk_user_data;\n\tsock->sk->sk_user_data = NULL;\n\twrite_unlock_bh(&sock->sk->sk_callback_lock);\n\n\tfor (i = 0; i < ARRAY_SIZE(o2net_nodes); i++) {\n\t\tstruct o2nm_node *node = o2nm_get_node_by_num(i);\n\t\tif (node) {\n\t\t\to2net_disconnect_node(node);\n\t\t\to2nm_node_put(node);\n\t\t}\n\t}\n\n\t \n\tmlog(ML_KTHREAD, \"waiting for o2net thread to exit....\\n\");\n\tdestroy_workqueue(o2net_wq);\n\to2net_wq = NULL;\n\n\tsock_release(o2net_listen_sock);\n\to2net_listen_sock = NULL;\n\n\to2quo_conn_err(node->nd_num);\n}\n\n \n\nint o2net_init(void)\n{\n\tstruct folio *folio;\n\tvoid *p;\n\tunsigned long i;\n\n\to2quo_init();\n\to2net_debugfs_init();\n\n\tfolio = folio_alloc(GFP_KERNEL | __GFP_ZERO, 0);\n\tif (!folio)\n\t\tgoto out;\n\n\tp = folio_address(folio);\n\to2net_hand = p;\n\tp += sizeof(struct o2net_handshake);\n\to2net_keep_req = p;\n\tp += sizeof(struct o2net_msg);\n\to2net_keep_resp = p;\n\n\to2net_hand->protocol_version = cpu_to_be64(O2NET_PROTOCOL_VERSION);\n\to2net_hand->connector_id = cpu_to_be64(1);\n\n\to2net_keep_req->magic = cpu_to_be16(O2NET_MSG_KEEP_REQ_MAGIC);\n\to2net_keep_resp->magic = cpu_to_be16(O2NET_MSG_KEEP_RESP_MAGIC);\n\n\tfor (i = 0; i < ARRAY_SIZE(o2net_nodes); i++) {\n\t\tstruct o2net_node *nn = o2net_nn_from_num(i);\n\n\t\tatomic_set(&nn->nn_timeout, 0);\n\t\tspin_lock_init(&nn->nn_lock);\n\t\tINIT_DELAYED_WORK(&nn->nn_connect_work, o2net_start_connect);\n\t\tINIT_DELAYED_WORK(&nn->nn_connect_expired,\n\t\t\t\t  o2net_connect_expired);\n\t\tINIT_DELAYED_WORK(&nn->nn_still_up, o2net_still_up);\n\t\t \n\t\tnn->nn_persistent_error = -ENOTCONN;\n\t\tinit_waitqueue_head(&nn->nn_sc_wq);\n\t\tidr_init(&nn->nn_status_idr);\n\t\tINIT_LIST_HEAD(&nn->nn_status_list);\n\t}\n\n\treturn 0;\n\nout:\n\to2net_debugfs_exit();\n\to2quo_exit();\n\treturn -ENOMEM;\n}\n\nvoid o2net_exit(void)\n{\n\to2quo_exit();\n\to2net_debugfs_exit();\n\tfolio_put(virt_to_folio(o2net_hand));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}